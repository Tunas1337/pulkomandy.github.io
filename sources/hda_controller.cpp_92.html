
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>hda_controller.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2007-2012, Haiku, Inc. All Rights Reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Ithamar Adema, ithamar AT unet DOT nl</a>
<a name="ln7"> *		Axel DÃ¶rfler, axeld@pinc-software.de</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10"> </a>
<a name="ln11">#include &quot;hda_controller_defs.h&quot;</a>
<a name="ln12"> </a>
<a name="ln13">#include &lt;algorithm&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;vm/vm.h&gt;</a>
<a name="ln16"> </a>
<a name="ln17">#include &quot;driver.h&quot;</a>
<a name="ln18">#include &quot;hda_codec_defs.h&quot;</a>
<a name="ln19"> </a>
<a name="ln20"> </a>
<a name="ln21">#define MAKE_RATE(base, multiply, divide) \</a>
<a name="ln22">	((base == 44100 ? FORMAT_44_1_BASE_RATE : 0) \</a>
<a name="ln23">		| ((multiply - 1) &lt;&lt; FORMAT_MULTIPLY_RATE_SHIFT) \</a>
<a name="ln24">		| ((divide - 1) &lt;&lt; FORMAT_DIVIDE_RATE_SHIFT))</a>
<a name="ln25"> </a>
<a name="ln26">#define HDAC_INPUT_STREAM_OFFSET(controller, index) \</a>
<a name="ln27">	((index) * HDAC_STREAM_SIZE)</a>
<a name="ln28">#define HDAC_OUTPUT_STREAM_OFFSET(controller, index) \</a>
<a name="ln29">	(((controller)-&gt;num_input_streams + (index)) * HDAC_STREAM_SIZE)</a>
<a name="ln30">#define HDAC_BIDIR_STREAM_OFFSET(controller, index) \</a>
<a name="ln31">	(((controller)-&gt;num_input_streams + (controller)-&gt;num_output_streams \</a>
<a name="ln32">		+ (index)) * HDAC_STREAM_SIZE)</a>
<a name="ln33"> </a>
<a name="ln34">#define ALIGN(size, align)	(((size) + align - 1) &amp; ~(align - 1))</a>
<a name="ln35"> </a>
<a name="ln36"> </a>
<a name="ln37">#define PCI_VENDOR_AMD			0x1002</a>
<a name="ln38">#define PCI_VENDOR_CREATIVE		0x1102</a>
<a name="ln39">#define PCI_VENDOR_INTEL		0x8086</a>
<a name="ln40">#define PCI_VENDOR_NVIDIA		0x10de</a>
<a name="ln41">#define PCI_VENDOR_VMWARE		0x15ad</a>
<a name="ln42">#define PCI_ALL_DEVICES			0xffffffff</a>
<a name="ln43"> </a>
<a name="ln44">#define HDA_QUIRK_SNOOP					0x0001</a>
<a name="ln45">#define HDA_QUIRK_NO_MSI				0x0002</a>
<a name="ln46">#define HDA_QUIRK_NO_CORBRP_RESET_ACK	0x0004</a>
<a name="ln47"> </a>
<a name="ln48"> </a>
<a name="ln49">static const struct {</a>
<a name="ln50">	uint32 vendor_id, device_id;</a>
<a name="ln51">	uint32 quirks;</a>
<a name="ln52">} kControllerQuirks[] = {</a>
<a name="ln53">	{ PCI_VENDOR_INTEL, 0x080a, HDA_QUIRK_SNOOP },</a>
<a name="ln54">	{ PCI_VENDOR_INTEL, 0x0a0c, HDA_QUIRK_SNOOP },</a>
<a name="ln55">	{ PCI_VENDOR_INTEL, 0x0c0c, HDA_QUIRK_SNOOP },</a>
<a name="ln56">	{ PCI_VENDOR_INTEL, 0x0d0c, HDA_QUIRK_SNOOP },</a>
<a name="ln57">	{ PCI_VENDOR_INTEL, 0x0f04, HDA_QUIRK_SNOOP },</a>
<a name="ln58">	{ PCI_VENDOR_INTEL, 0x160c, HDA_QUIRK_SNOOP },</a>
<a name="ln59">	{ PCI_VENDOR_INTEL, 0x1c20, HDA_QUIRK_SNOOP },</a>
<a name="ln60">	{ PCI_VENDOR_INTEL, 0x1d20, HDA_QUIRK_SNOOP },</a>
<a name="ln61">	{ PCI_VENDOR_INTEL, 0x1e20, HDA_QUIRK_SNOOP },</a>
<a name="ln62">	{ PCI_VENDOR_INTEL, 0x2284, HDA_QUIRK_SNOOP },</a>
<a name="ln63">	{ PCI_VENDOR_INTEL, 0x3198, HDA_QUIRK_SNOOP },</a>
<a name="ln64">	{ PCI_VENDOR_INTEL, 0x34c8, HDA_QUIRK_SNOOP },</a>
<a name="ln65">	{ PCI_VENDOR_INTEL, 0x3b56, HDA_QUIRK_SNOOP },</a>
<a name="ln66">	{ PCI_VENDOR_INTEL, 0x3b57, HDA_QUIRK_SNOOP },</a>
<a name="ln67">	{ PCI_VENDOR_INTEL, 0x5a98, HDA_QUIRK_SNOOP },</a>
<a name="ln68">	{ PCI_VENDOR_INTEL, 0x811b, HDA_QUIRK_SNOOP },</a>
<a name="ln69">	{ PCI_VENDOR_INTEL, 0x8c20, HDA_QUIRK_SNOOP },</a>
<a name="ln70">	{ PCI_VENDOR_INTEL, 0x8ca0, HDA_QUIRK_SNOOP },</a>
<a name="ln71">	{ PCI_VENDOR_INTEL, 0x8d20, HDA_QUIRK_SNOOP },</a>
<a name="ln72">	{ PCI_VENDOR_INTEL, 0x8d21, HDA_QUIRK_SNOOP },</a>
<a name="ln73">	{ PCI_VENDOR_INTEL, 0x9c20, HDA_QUIRK_SNOOP },</a>
<a name="ln74">	{ PCI_VENDOR_INTEL, 0x9c21, HDA_QUIRK_SNOOP },</a>
<a name="ln75">	{ PCI_VENDOR_INTEL, 0x9ca0, HDA_QUIRK_SNOOP },</a>
<a name="ln76">	{ PCI_VENDOR_INTEL, 0x9d70, HDA_QUIRK_SNOOP },</a>
<a name="ln77">	{ PCI_VENDOR_INTEL, 0x9d71, HDA_QUIRK_SNOOP },</a>
<a name="ln78">	{ PCI_VENDOR_INTEL, 0x9dc8, HDA_QUIRK_SNOOP },</a>
<a name="ln79">	{ PCI_VENDOR_INTEL, 0xa170, HDA_QUIRK_SNOOP },</a>
<a name="ln80">	{ PCI_VENDOR_INTEL, 0xa171, HDA_QUIRK_SNOOP },</a>
<a name="ln81">	{ PCI_VENDOR_INTEL, 0xa2f0, HDA_QUIRK_SNOOP },</a>
<a name="ln82">	{ PCI_VENDOR_INTEL, 0xa348, HDA_QUIRK_SNOOP },</a>
<a name="ln83">	// Enable snooping for ATI and Nvidia, right now for all their hda-devices,</a>
<a name="ln84">	// but only based on guessing.</a>
<a name="ln85">	{ PCI_VENDOR_AMD, PCI_ALL_DEVICES, HDA_QUIRK_SNOOP },</a>
<a name="ln86">	{ PCI_VENDOR_NVIDIA, PCI_ALL_DEVICES, HDA_QUIRK_SNOOP | HDA_QUIRK_NO_MSI</a>
<a name="ln87">		| HDA_QUIRK_NO_CORBRP_RESET_ACK },</a>
<a name="ln88">	{ PCI_VENDOR_CREATIVE, 0x0010, HDA_QUIRK_NO_MSI },</a>
<a name="ln89">	{ PCI_VENDOR_CREATIVE, 0x0012, HDA_QUIRK_NO_MSI },</a>
<a name="ln90">	{ PCI_VENDOR_VMWARE, PCI_ALL_DEVICES, HDA_QUIRK_NO_CORBRP_RESET_ACK },</a>
<a name="ln91">};</a>
<a name="ln92"> </a>
<a name="ln93"> </a>
<a name="ln94">static const struct {</a>
<a name="ln95">	uint32 multi_rate;</a>
<a name="ln96">	uint32 hw_rate;</a>
<a name="ln97">	uint32 rate;</a>
<a name="ln98">} kRates[] = {</a>
<a name="ln99">	{B_SR_8000, MAKE_RATE(48000, 1, 6), 8000},</a>
<a name="ln100">	{B_SR_11025, MAKE_RATE(44100, 1, 4), 11025},</a>
<a name="ln101">	{B_SR_16000, MAKE_RATE(48000, 1, 3), 16000},</a>
<a name="ln102">	{B_SR_22050, MAKE_RATE(44100, 1, 2), 22050},</a>
<a name="ln103">	{B_SR_32000, MAKE_RATE(48000, 2, 3), 32000},</a>
<a name="ln104">	{B_SR_44100, MAKE_RATE(44100, 1, 1), 44100},</a>
<a name="ln105">	{B_SR_48000, MAKE_RATE(48000, 1, 1), 48000},</a>
<a name="ln106">	{B_SR_88200, MAKE_RATE(44100, 2, 1), 88200},</a>
<a name="ln107">	{B_SR_96000, MAKE_RATE(48000, 2, 1), 96000},</a>
<a name="ln108">	{B_SR_176400, MAKE_RATE(44100, 4, 1), 176400},</a>
<a name="ln109">	{B_SR_192000, MAKE_RATE(48000, 4, 1), 192000},</a>
<a name="ln110">	// this one is not supported by hardware.</a>
<a name="ln111">	// {B_SR_384000, MAKE_RATE(44100, ??, ??), 384000},</a>
<a name="ln112">};</a>
<a name="ln113"> </a>
<a name="ln114"> </a>
<a name="ln115">static uint32</a>
<a name="ln116">get_controller_quirks(pci_info&amp; info)</a>
<a name="ln117">{</a>
<a name="ln118">	for (size_t i = 0;</a>
<a name="ln119">			i &lt; sizeof(kControllerQuirks) / sizeof(kControllerQuirks[0]); i++) {</a>
<a name="ln120">		if (info.vendor_id == kControllerQuirks[i].vendor_id</a>
<a name="ln121">			&amp;&amp; (kControllerQuirks[i].device_id == PCI_ALL_DEVICES</a>
<a name="ln122">				|| kControllerQuirks[i].device_id == info.device_id))</a>
<a name="ln123">			return kControllerQuirks[i].quirks;</a>
<a name="ln124">	}</a>
<a name="ln125">	return 0;</a>
<a name="ln126">}</a>
<a name="ln127"> </a>
<a name="ln128"> </a>
<a name="ln129">static inline bool</a>
<a name="ln130">update_pci_register(hda_controller* controller, uint8 reg, uint32 mask,</a>
<a name="ln131">	uint32 value, uint8 size, bool check = false)</a>
<a name="ln132">{</a>
<a name="ln133">	uint32 originalValue = (gPci-&gt;read_pci_config)(controller-&gt;pci_info.bus,</a>
<a name="ln134">		controller-&gt;pci_info.device, controller-&gt;pci_info.function, reg, size);</a>
<a name="ln135">	(gPci-&gt;write_pci_config)(controller-&gt;pci_info.bus,</a>
<a name="ln136">		controller-&gt;pci_info.device, controller-&gt;pci_info.function,</a>
<a name="ln137">		reg, size, (originalValue &amp; mask) | value);</a>
<a name="ln138"> </a>
<a name="ln139">	if (!check)</a>
<a name="ln140">		return true;</a>
<a name="ln141"> </a>
<a name="ln142">	uint32 newValue = (gPci-&gt;read_pci_config)(controller-&gt;pci_info.bus,</a>
<a name="ln143">		controller-&gt;pci_info.device, controller-&gt;pci_info.function, reg, size);</a>
<a name="ln144">	return (newValue &amp; ~mask) == value;</a>
<a name="ln145">}</a>
<a name="ln146"> </a>
<a name="ln147"> </a>
<a name="ln148">static inline rirb_t&amp;</a>
<a name="ln149">current_rirb(hda_controller* controller)</a>
<a name="ln150">{</a>
<a name="ln151">	return controller-&gt;rirb[controller-&gt;rirb_read_pos];</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154"> </a>
<a name="ln155">static inline uint32</a>
<a name="ln156">next_rirb(hda_controller* controller)</a>
<a name="ln157">{</a>
<a name="ln158">	return (controller-&gt;rirb_read_pos + 1) % controller-&gt;rirb_length;</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161"> </a>
<a name="ln162">static inline uint32</a>
<a name="ln163">next_corb(hda_controller* controller)</a>
<a name="ln164">{</a>
<a name="ln165">	return (controller-&gt;corb_write_pos + 1) % controller-&gt;corb_length;</a>
<a name="ln166">}</a>
<a name="ln167"> </a>
<a name="ln168"> </a>
<a name="ln169">/*! Called with interrupts off.</a>
<a name="ln170">	Returns \c true, if the scheduler shall be invoked.</a>
<a name="ln171">*/</a>
<a name="ln172">static bool</a>
<a name="ln173">stream_handle_interrupt(hda_controller* controller, hda_stream* stream,</a>
<a name="ln174">	uint32 index)</a>
<a name="ln175">{</a>
<a name="ln176">	if (!stream-&gt;running)</a>
<a name="ln177">		return false;</a>
<a name="ln178"> </a>
<a name="ln179">	uint8 status = stream-&gt;Read8(HDAC_STREAM_STATUS);</a>
<a name="ln180">	if (status == 0)</a>
<a name="ln181">		return false;</a>
<a name="ln182"> </a>
<a name="ln183">	stream-&gt;Write8(HDAC_STREAM_STATUS, status);</a>
<a name="ln184"> </a>
<a name="ln185">	if ((status &amp; STATUS_FIFO_ERROR) != 0)</a>
<a name="ln186">		dprintf(&quot;hda: stream fifo error (id:%&quot; B_PRIu32 &quot;)\n&quot;, stream-&gt;id);</a>
<a name="ln187">	if ((status &amp; STATUS_DESCRIPTOR_ERROR) != 0) {</a>
<a name="ln188">		dprintf(&quot;hda: stream descriptor error (id:%&quot; B_PRIu32 &quot;)\n&quot;,</a>
<a name="ln189">			stream-&gt;id);</a>
<a name="ln190">	}</a>
<a name="ln191"> </a>
<a name="ln192">	if ((status &amp; STATUS_BUFFER_COMPLETED) == 0) {</a>
<a name="ln193">		dprintf(&quot;hda: stream buffer not completed (id:%&quot; B_PRIu32 &quot;)\n&quot;,</a>
<a name="ln194">			stream-&gt;id);</a>
<a name="ln195">		return false;</a>
<a name="ln196">	}</a>
<a name="ln197"> </a>
<a name="ln198">	// Normally we should use the DMA position for the stream. Apparently there</a>
<a name="ln199">	// are broken chipsets, which don't support it correctly. If we detect this,</a>
<a name="ln200">	// we switch to using the LPIB instead. The link position is ahead of the</a>
<a name="ln201">	// DMA position for recording and behind for playback streams, but just</a>
<a name="ln202">	// for determining the currently active buffer, it should be good enough.</a>
<a name="ln203">	if (stream-&gt;use_dma_position &amp;&amp; stream-&gt;incorrect_position_count &gt;= 32) {</a>
<a name="ln204">		dprintf(&quot;hda: DMA position for stream (id:%&quot; B_PRIu32 &quot;) seems to be &quot;</a>
<a name="ln205">			&quot;broken. Switching to using LPIB.\n&quot;, stream-&gt;id);</a>
<a name="ln206">		stream-&gt;use_dma_position = false;</a>
<a name="ln207">	}</a>
<a name="ln208"> </a>
<a name="ln209">	// Determine the buffer we're switching to. Some chipsets seem to trigger</a>
<a name="ln210">	// the interrupt before the DMA position in memory has been updated. We</a>
<a name="ln211">	// round it, so we still get the right buffer.</a>
<a name="ln212">	uint32 dmaPosition = stream-&gt;use_dma_position</a>
<a name="ln213">		? controller-&gt;stream_positions[index * 2]</a>
<a name="ln214">		: stream-&gt;Read32(HDAC_STREAM_POSITION);</a>
<a name="ln215">	uint32 bufferIndex = ((dmaPosition + stream-&gt;buffer_size / 2)</a>
<a name="ln216">		/ stream-&gt;buffer_size) % stream-&gt;num_buffers;</a>
<a name="ln217"> </a>
<a name="ln218">	// get the current recording/playing position and the system time</a>
<a name="ln219">	uint32 linkBytePosition = stream-&gt;Read32(HDAC_STREAM_POSITION);</a>
<a name="ln220">	bigtime_t now = system_time();</a>
<a name="ln221"> </a>
<a name="ln222">	// compute the frame position for the byte position</a>
<a name="ln223">	uint32 linkFramePosition = 0;</a>
<a name="ln224">	while (linkBytePosition &gt;= stream-&gt;buffer_size) {</a>
<a name="ln225">		linkFramePosition += stream-&gt;buffer_length;</a>
<a name="ln226">		linkBytePosition -= stream-&gt;buffer_size;</a>
<a name="ln227">	}</a>
<a name="ln228">	linkFramePosition += std::min(</a>
<a name="ln229">		linkBytePosition / (stream-&gt;num_channels * stream-&gt;sample_size),</a>
<a name="ln230">		stream-&gt;buffer_length);</a>
<a name="ln231"> </a>
<a name="ln232">	// compute the number of frames processed since the previous interrupt</a>
<a name="ln233">	int32 framesProcessed = (int32)linkFramePosition</a>
<a name="ln234">		- (int32)stream-&gt;last_link_frame_position;</a>
<a name="ln235">	if (framesProcessed &lt; 0)</a>
<a name="ln236">		framesProcessed += stream-&gt;num_buffers * stream-&gt;buffer_length;</a>
<a name="ln237">	stream-&gt;last_link_frame_position = linkFramePosition;</a>
<a name="ln238"> </a>
<a name="ln239">	// update stream playing/recording state and notify buffer_exchange()</a>
<a name="ln240">	acquire_spinlock(&amp;stream-&gt;lock);</a>
<a name="ln241"> </a>
<a name="ln242">	if (bufferIndex == (stream-&gt;buffer_cycle + 1) % stream-&gt;num_buffers)</a>
<a name="ln243">		stream-&gt;incorrect_position_count = 0;</a>
<a name="ln244">	else</a>
<a name="ln245">		stream-&gt;incorrect_position_count++;</a>
<a name="ln246"> </a>
<a name="ln247">	stream-&gt;real_time = now;</a>
<a name="ln248">	stream-&gt;frames_count += framesProcessed;</a>
<a name="ln249">	stream-&gt;buffer_cycle = bufferIndex;</a>
<a name="ln250"> </a>
<a name="ln251">	release_spinlock(&amp;stream-&gt;lock);</a>
<a name="ln252"> </a>
<a name="ln253">	release_sem_etc(controller-&gt;buffer_ready_sem, 1, B_DO_NOT_RESCHEDULE);</a>
<a name="ln254"> </a>
<a name="ln255">	return true;</a>
<a name="ln256">}</a>
<a name="ln257"> </a>
<a name="ln258"> </a>
<a name="ln259">static int32</a>
<a name="ln260">hda_interrupt_handler(hda_controller* controller)</a>
<a name="ln261">{</a>
<a name="ln262">	int32 handled = B_HANDLED_INTERRUPT;</a>
<a name="ln263"> </a>
<a name="ln264">	// Check if this interrupt is ours</a>
<a name="ln265">	uint32 intrStatus = controller-&gt;Read32(HDAC_INTR_STATUS);</a>
<a name="ln266">	if ((intrStatus &amp; INTR_STATUS_GLOBAL) == 0)</a>
<a name="ln267">		return B_UNHANDLED_INTERRUPT;</a>
<a name="ln268"> </a>
<a name="ln269">	// Controller or stream related?</a>
<a name="ln270">	if (intrStatus &amp; INTR_STATUS_CONTROLLER) {</a>
<a name="ln271">		uint8 rirbStatus = controller-&gt;Read8(HDAC_RIRB_STATUS);</a>
<a name="ln272">		uint8 corbStatus = controller-&gt;Read8(HDAC_CORB_STATUS);</a>
<a name="ln273"> </a>
<a name="ln274">		// Check for incoming responses</a>
<a name="ln275">		if (rirbStatus) {</a>
<a name="ln276">			controller-&gt;Write8(HDAC_RIRB_STATUS, rirbStatus);</a>
<a name="ln277"> </a>
<a name="ln278">			if ((rirbStatus &amp; RIRB_STATUS_RESPONSE) != 0) {</a>
<a name="ln279">				uint16 writePos = (controller-&gt;Read16(HDAC_RIRB_WRITE_POS) + 1)</a>
<a name="ln280">					% controller-&gt;rirb_length;</a>
<a name="ln281"> </a>
<a name="ln282">				for (; controller-&gt;rirb_read_pos != writePos;</a>
<a name="ln283">						controller-&gt;rirb_read_pos = next_rirb(controller)) {</a>
<a name="ln284">					uint32 response = current_rirb(controller).response;</a>
<a name="ln285">					uint32 responseFlags = current_rirb(controller).flags;</a>
<a name="ln286">					uint32 cad = responseFlags &amp; RESPONSE_FLAGS_CODEC_MASK;</a>
<a name="ln287">					hda_codec* codec = controller-&gt;codecs[cad];</a>
<a name="ln288"> </a>
<a name="ln289">					if (codec == NULL) {</a>
<a name="ln290">						dprintf(&quot;hda: Response for unknown codec %&quot; B_PRIu32</a>
<a name="ln291">							&quot;: %08&quot; B_PRIx32 &quot;/%08&quot; B_PRIx32 &quot;\n&quot;, cad,</a>
<a name="ln292">							response, responseFlags);</a>
<a name="ln293">						continue;</a>
<a name="ln294">					}</a>
<a name="ln295"> </a>
<a name="ln296">					if ((responseFlags &amp; RESPONSE_FLAGS_UNSOLICITED) != 0) {</a>
<a name="ln297">						dprintf(&quot;hda: Unsolicited response: %08&quot; B_PRIx32</a>
<a name="ln298">							&quot;/%08&quot; B_PRIx32 &quot;\n&quot;, response, responseFlags);</a>
<a name="ln299">						codec-&gt;unsol_responses[codec-&gt;unsol_response_write++] =</a>
<a name="ln300">							response;</a>
<a name="ln301">						codec-&gt;unsol_response_write %= MAX_CODEC_UNSOL_RESPONSES;</a>
<a name="ln302">						release_sem_etc(codec-&gt;unsol_response_sem, 1,</a>
<a name="ln303">							B_DO_NOT_RESCHEDULE);</a>
<a name="ln304">						handled = B_INVOKE_SCHEDULER;</a>
<a name="ln305">						continue;</a>
<a name="ln306">					}</a>
<a name="ln307">					if (codec-&gt;response_count &gt;= MAX_CODEC_RESPONSES) {</a>
<a name="ln308">						dprintf(&quot;hda: too many responses received for codec %&quot;</a>
<a name="ln309">							B_PRIu32 &quot;: %08&quot; B_PRIx32 &quot;/%08&quot; B_PRIx32 &quot;!\n&quot;,</a>
<a name="ln310">							cad, response, responseFlags);</a>
<a name="ln311">						continue;</a>
<a name="ln312">					}</a>
<a name="ln313"> </a>
<a name="ln314">					// Store response in codec</a>
<a name="ln315">					codec-&gt;responses[codec-&gt;response_count++] = response;</a>
<a name="ln316">					release_sem_etc(codec-&gt;response_sem, 1, B_DO_NOT_RESCHEDULE);</a>
<a name="ln317">					handled = B_INVOKE_SCHEDULER;</a>
<a name="ln318">				}</a>
<a name="ln319">			}</a>
<a name="ln320"> </a>
<a name="ln321">			if ((rirbStatus &amp; RIRB_STATUS_OVERRUN) != 0)</a>
<a name="ln322">				dprintf(&quot;hda: RIRB Overflow\n&quot;);</a>
<a name="ln323">		}</a>
<a name="ln324"> </a>
<a name="ln325">		// Check for sending errors</a>
<a name="ln326">		if (corbStatus) {</a>
<a name="ln327">			controller-&gt;Write8(HDAC_CORB_STATUS, corbStatus);</a>
<a name="ln328"> </a>
<a name="ln329">			if ((corbStatus &amp; CORB_STATUS_MEMORY_ERROR) != 0)</a>
<a name="ln330">				dprintf(&quot;hda: CORB Memory Error!\n&quot;);</a>
<a name="ln331">		}</a>
<a name="ln332">	}</a>
<a name="ln333"> </a>
<a name="ln334">	if ((intrStatus &amp; INTR_STATUS_STREAM_MASK) != 0) {</a>
<a name="ln335">		for (uint32 index = 0; index &lt; HDA_MAX_STREAMS; index++) {</a>
<a name="ln336">			if ((intrStatus &amp; (1 &lt;&lt; index)) != 0) {</a>
<a name="ln337">				if (controller-&gt;streams[index]) {</a>
<a name="ln338">					if (stream_handle_interrupt(controller,</a>
<a name="ln339">							controller-&gt;streams[index], index)) {</a>
<a name="ln340">						handled = B_INVOKE_SCHEDULER;</a>
<a name="ln341">					}</a>
<a name="ln342">				} else {</a>
<a name="ln343">					dprintf(&quot;hda: Stream interrupt for unconfigured stream &quot;</a>
<a name="ln344">						&quot;%&quot; B_PRIu32 &quot;!\n&quot;, index);</a>
<a name="ln345">				}</a>
<a name="ln346">			}</a>
<a name="ln347">		}</a>
<a name="ln348">	}</a>
<a name="ln349"> </a>
<a name="ln350">	// NOTE: See HDA001 =&gt; CIS/GIS cannot be cleared!</a>
<a name="ln351"> </a>
<a name="ln352">	return handled;</a>
<a name="ln353">}</a>
<a name="ln354"> </a>
<a name="ln355"> </a>
<a name="ln356">static status_t</a>
<a name="ln357">reset_controller(hda_controller* controller)</a>
<a name="ln358">{</a>
<a name="ln359">	uint32 control = controller-&gt;Read32(HDAC_GLOBAL_CONTROL);</a>
<a name="ln360">	if ((control &amp; GLOBAL_CONTROL_RESET) != 0) {</a>
<a name="ln361">		controller-&gt;Write32(HDAC_INTR_CONTROL, 0);</a>
<a name="ln362"> </a>
<a name="ln363">		// stop streams</a>
<a name="ln364"> </a>
<a name="ln365">		for (uint32 i = 0; i &lt; controller-&gt;num_input_streams; i++) {</a>
<a name="ln366">			controller-&gt;Write8(HDAC_STREAM_CONTROL0 + HDAC_STREAM_BASE</a>
<a name="ln367">				+ HDAC_INPUT_STREAM_OFFSET(controller, i), 0);</a>
<a name="ln368">			controller-&gt;Write8(HDAC_STREAM_STATUS + HDAC_STREAM_BASE</a>
<a name="ln369">				+ HDAC_INPUT_STREAM_OFFSET(controller, i), 0);</a>
<a name="ln370">		}</a>
<a name="ln371">		for (uint32 i = 0; i &lt; controller-&gt;num_output_streams; i++) {</a>
<a name="ln372">			controller-&gt;Write8(HDAC_STREAM_CONTROL0 + HDAC_STREAM_BASE</a>
<a name="ln373">				+ HDAC_OUTPUT_STREAM_OFFSET(controller, i), 0);</a>
<a name="ln374">			controller-&gt;Write8(HDAC_STREAM_STATUS + HDAC_STREAM_BASE</a>
<a name="ln375">				+ HDAC_OUTPUT_STREAM_OFFSET(controller, i), 0);</a>
<a name="ln376">		}</a>
<a name="ln377">		for (uint32 i = 0; i &lt; controller-&gt;num_bidir_streams; i++) {</a>
<a name="ln378">			controller-&gt;Write8(HDAC_STREAM_CONTROL0 + HDAC_STREAM_BASE</a>
<a name="ln379">				+ HDAC_BIDIR_STREAM_OFFSET(controller, i), 0);</a>
<a name="ln380">			controller-&gt;Write8(HDAC_STREAM_STATUS + HDAC_STREAM_BASE</a>
<a name="ln381">				+ HDAC_BIDIR_STREAM_OFFSET(controller, i), 0);</a>
<a name="ln382">		}</a>
<a name="ln383"> </a>
<a name="ln384">		// stop DMA</a>
<a name="ln385">		controller-&gt;ReadModifyWrite8(HDAC_CORB_CONTROL, HDAC_CORB_CONTROL_MASK, 0);</a>
<a name="ln386">		controller-&gt;ReadModifyWrite8(HDAC_RIRB_CONTROL, HDAC_RIRB_CONTROL_MASK, 0);</a>
<a name="ln387"> </a>
<a name="ln388">		uint8 corbControl = 0;</a>
<a name="ln389">		uint8 rirbControl = 0;</a>
<a name="ln390">		for (int timeout = 0; timeout &lt; 10; timeout++) {</a>
<a name="ln391">			snooze(100);</a>
<a name="ln392"> </a>
<a name="ln393">			corbControl = controller-&gt;Read8(HDAC_CORB_CONTROL);</a>
<a name="ln394">			rirbControl = controller-&gt;Read8(HDAC_RIRB_CONTROL);</a>
<a name="ln395">			if (corbControl == 0 &amp;&amp; rirbControl == 0)</a>
<a name="ln396">				break;</a>
<a name="ln397">		}</a>
<a name="ln398">		if (corbControl != 0 || rirbControl != 0) {</a>
<a name="ln399">			dprintf(&quot;hda: unable to stop dma\n&quot;);</a>
<a name="ln400">			return B_BUSY;</a>
<a name="ln401">		}</a>
<a name="ln402"> </a>
<a name="ln403">		// reset DMA position buffer</a>
<a name="ln404">		controller-&gt;Write32(HDAC_DMA_POSITION_BASE_LOWER, 0);</a>
<a name="ln405">		controller-&gt;Write32(HDAC_DMA_POSITION_BASE_UPPER, 0);</a>
<a name="ln406"> </a>
<a name="ln407">		control = controller-&gt;Read32(HDAC_GLOBAL_CONTROL);</a>
<a name="ln408">	}</a>
<a name="ln409"> </a>
<a name="ln410">	// Set reset bit - it must be asserted for at least 100us</a>
<a name="ln411">	controller-&gt;Write32(HDAC_GLOBAL_CONTROL, control &amp; ~GLOBAL_CONTROL_RESET);</a>
<a name="ln412"> </a>
<a name="ln413">	for (int timeout = 0; timeout &lt; 10; timeout++) {</a>
<a name="ln414">		snooze(100);</a>
<a name="ln415"> </a>
<a name="ln416">		control = controller-&gt;Read32(HDAC_GLOBAL_CONTROL);</a>
<a name="ln417">		if ((control &amp; GLOBAL_CONTROL_RESET) == 0)</a>
<a name="ln418">			break;</a>
<a name="ln419">	}</a>
<a name="ln420">	if ((control &amp; GLOBAL_CONTROL_RESET) != 0) {</a>
<a name="ln421">		dprintf(&quot;hda: unable to reset controller\n&quot;);</a>
<a name="ln422">		return B_BUSY;</a>
<a name="ln423">	}</a>
<a name="ln424"> </a>
<a name="ln425">	// Wait for codec PLL to lock at least 100us, section 5.5.1.2</a>
<a name="ln426">	snooze(1000);</a>
<a name="ln427"> </a>
<a name="ln428">	// Unset reset bit</a>
<a name="ln429"> </a>
<a name="ln430">	control = controller-&gt;Read32(HDAC_GLOBAL_CONTROL);</a>
<a name="ln431">	controller-&gt;Write32(HDAC_GLOBAL_CONTROL, control | GLOBAL_CONTROL_RESET);</a>
<a name="ln432"> </a>
<a name="ln433">	for (int timeout = 0; timeout &lt; 10; timeout++) {</a>
<a name="ln434">		snooze(100);</a>
<a name="ln435"> </a>
<a name="ln436">		control = controller-&gt;Read32(HDAC_GLOBAL_CONTROL);</a>
<a name="ln437">		if ((control &amp; GLOBAL_CONTROL_RESET) != 0)</a>
<a name="ln438">			break;</a>
<a name="ln439">	}</a>
<a name="ln440">	if ((control &amp; GLOBAL_CONTROL_RESET) == 0) {</a>
<a name="ln441">		dprintf(&quot;hda: unable to exit reset\n&quot;);</a>
<a name="ln442">		return B_BUSY;</a>
<a name="ln443">	}</a>
<a name="ln444"> </a>
<a name="ln445">	// Wait for codecs to finish their own reset (apparently needs more</a>
<a name="ln446">	// time than documented in the specs)</a>
<a name="ln447">	snooze(1000);</a>
<a name="ln448"> </a>
<a name="ln449">	// Enable unsolicited responses</a>
<a name="ln450">	control = controller-&gt;Read32(HDAC_GLOBAL_CONTROL);</a>
<a name="ln451">	controller-&gt;Write32(HDAC_GLOBAL_CONTROL,</a>
<a name="ln452">		control | GLOBAL_CONTROL_UNSOLICITED);</a>
<a name="ln453"> </a>
<a name="ln454">	return B_OK;</a>
<a name="ln455">}</a>
<a name="ln456"> </a>
<a name="ln457"> </a>
<a name="ln458">/*! Allocates and initializes the Command Output Ring Buffer (CORB), and</a>
<a name="ln459">	Response Input Ring Buffer (RIRB) to the maximum supported size, and also</a>
<a name="ln460">	the DMA position buffer.</a>
<a name="ln461"> </a>
<a name="ln462">	Programs the controller hardware to make use of these buffers (the DMA</a>
<a name="ln463">	positioning is actually enabled in hda_stream_setup_buffers()).</a>
<a name="ln464">*/</a>
<a name="ln465">static status_t</a>
<a name="ln466">init_corb_rirb_pos(hda_controller* controller, uint32 quirks)</a>
<a name="ln467">{</a>
<a name="ln468">	// Determine and set size of CORB</a>
<a name="ln469">	uint8 corbSize = controller-&gt;Read8(HDAC_CORB_SIZE);</a>
<a name="ln470">	if ((corbSize &amp; CORB_SIZE_CAP_256_ENTRIES) != 0) {</a>
<a name="ln471">		controller-&gt;corb_length = 256;</a>
<a name="ln472">		controller-&gt;ReadModifyWrite8(</a>
<a name="ln473">			HDAC_CORB_SIZE, HDAC_CORB_SIZE_MASK,</a>
<a name="ln474">			CORB_SIZE_256_ENTRIES);</a>
<a name="ln475">	} else if (corbSize &amp; CORB_SIZE_CAP_16_ENTRIES) {</a>
<a name="ln476">		controller-&gt;corb_length = 16;</a>
<a name="ln477">		controller-&gt;ReadModifyWrite8(</a>
<a name="ln478">			HDAC_CORB_SIZE, HDAC_CORB_SIZE_MASK,</a>
<a name="ln479">			CORB_SIZE_16_ENTRIES);</a>
<a name="ln480">	} else if (corbSize &amp; CORB_SIZE_CAP_2_ENTRIES) {</a>
<a name="ln481">		controller-&gt;corb_length = 2;</a>
<a name="ln482">		controller-&gt;ReadModifyWrite8(</a>
<a name="ln483">			HDAC_CORB_SIZE, HDAC_CORB_SIZE_MASK,</a>
<a name="ln484">			CORB_SIZE_2_ENTRIES);</a>
<a name="ln485">	}</a>
<a name="ln486"> </a>
<a name="ln487">	// Determine and set size of RIRB</a>
<a name="ln488">	uint8 rirbSize = controller-&gt;Read8(HDAC_RIRB_SIZE);</a>
<a name="ln489">	if (rirbSize &amp; RIRB_SIZE_CAP_256_ENTRIES) {</a>
<a name="ln490">		controller-&gt;rirb_length = 256;</a>
<a name="ln491">		controller-&gt;ReadModifyWrite8(</a>
<a name="ln492">			HDAC_RIRB_SIZE, HDAC_RIRB_SIZE_MASK,</a>
<a name="ln493">			RIRB_SIZE_256_ENTRIES);</a>
<a name="ln494">	} else if (rirbSize &amp; RIRB_SIZE_CAP_16_ENTRIES) {</a>
<a name="ln495">		controller-&gt;rirb_length = 16;</a>
<a name="ln496">		controller-&gt;ReadModifyWrite8(</a>
<a name="ln497">			HDAC_RIRB_SIZE, HDAC_RIRB_SIZE_MASK,</a>
<a name="ln498">			RIRB_SIZE_16_ENTRIES);</a>
<a name="ln499">	} else if (rirbSize &amp; RIRB_SIZE_CAP_2_ENTRIES) {</a>
<a name="ln500">		controller-&gt;rirb_length = 2;</a>
<a name="ln501">		controller-&gt;ReadModifyWrite8(</a>
<a name="ln502">			HDAC_RIRB_SIZE, HDAC_RIRB_SIZE_MASK,</a>
<a name="ln503">			RIRB_SIZE_2_ENTRIES);</a>
<a name="ln504">	}</a>
<a name="ln505"> </a>
<a name="ln506">	// Determine rirb offset in memory and total size of corb+alignment+rirb</a>
<a name="ln507">	uint32 rirbOffset = ALIGN(controller-&gt;corb_length * sizeof(corb_t), 128);</a>
<a name="ln508">	uint32 posOffset = ALIGN(rirbOffset</a>
<a name="ln509">		+ controller-&gt;rirb_length * sizeof(rirb_t), 128);</a>
<a name="ln510">	uint8 posSize = 8 * (controller-&gt;num_input_streams</a>
<a name="ln511">		+ controller-&gt;num_output_streams + controller-&gt;num_bidir_streams);</a>
<a name="ln512"> </a>
<a name="ln513">	uint32 memSize = PAGE_ALIGN(posOffset + posSize);</a>
<a name="ln514"> </a>
<a name="ln515">	// Allocate memory area</a>
<a name="ln516">	controller-&gt;corb_rirb_pos_area = create_area(&quot;hda corb/rirb/pos&quot;,</a>
<a name="ln517">		(void**)&amp;controller-&gt;corb, B_ANY_KERNEL_ADDRESS, memSize,</a>
<a name="ln518">		B_CONTIGUOUS, 0);</a>
<a name="ln519">	if (controller-&gt;corb_rirb_pos_area &lt; 0)</a>
<a name="ln520">		return controller-&gt;corb_rirb_pos_area;</a>
<a name="ln521"> </a>
<a name="ln522">	// Rirb is after corb+aligment</a>
<a name="ln523">	controller-&gt;rirb = (rirb_t*)(((uint8*)controller-&gt;corb) + rirbOffset);</a>
<a name="ln524"> </a>
<a name="ln525">	physical_entry pe;</a>
<a name="ln526">	status_t status = get_memory_map(controller-&gt;corb, memSize, &amp;pe, 1);</a>
<a name="ln527">	if (status != B_OK) {</a>
<a name="ln528">		delete_area(controller-&gt;corb_rirb_pos_area);</a>
<a name="ln529">		return status;</a>
<a name="ln530">	}</a>
<a name="ln531"> </a>
<a name="ln532">	if (!controller-&gt;dma_snooping) {</a>
<a name="ln533">		vm_set_area_memory_type(controller-&gt;corb_rirb_pos_area,</a>
<a name="ln534">			pe.address, B_MTR_UC);</a>
<a name="ln535">	}</a>
<a name="ln536"> </a>
<a name="ln537">	// Program CORB/RIRB for these locations</a>
<a name="ln538">	controller-&gt;Write32(HDAC_CORB_BASE_LOWER, (uint32)pe.address);</a>
<a name="ln539">	controller-&gt;Write32(HDAC_CORB_BASE_UPPER,</a>
<a name="ln540">		(uint32)((uint64)pe.address &gt;&gt; 32));</a>
<a name="ln541">	controller-&gt;Write32(HDAC_RIRB_BASE_LOWER, (uint32)pe.address + rirbOffset);</a>
<a name="ln542">	controller-&gt;Write32(HDAC_RIRB_BASE_UPPER,</a>
<a name="ln543">		(uint32)(((uint64)pe.address + rirbOffset) &gt;&gt; 32));</a>
<a name="ln544"> </a>
<a name="ln545">	// Program DMA position update</a>
<a name="ln546">	controller-&gt;Write32(HDAC_DMA_POSITION_BASE_LOWER,</a>
<a name="ln547">		(uint32)pe.address + posOffset);</a>
<a name="ln548">	controller-&gt;Write32(HDAC_DMA_POSITION_BASE_UPPER,</a>
<a name="ln549">		(uint32)(((uint64)pe.address + posOffset) &gt;&gt; 32));</a>
<a name="ln550"> </a>
<a name="ln551">	controller-&gt;stream_positions = (uint32*)</a>
<a name="ln552">		((uint8*)controller-&gt;corb + posOffset);</a>
<a name="ln553"> </a>
<a name="ln554">	controller-&gt;ReadModifyWrite16(HDAC_CORB_WRITE_POS,</a>
<a name="ln555">		HDAC_CORB_WRITE_POS_MASK, 0);</a>
<a name="ln556"> </a>
<a name="ln557">	// Reset CORB read pointer. Preseve bits marked as RsvdP.</a>
<a name="ln558">	// After setting the reset bit, we must wait for the hardware</a>
<a name="ln559">	// to acknowledge it, then manually unset it and wait for that</a>
<a name="ln560">	// to be acknowledged as well.</a>
<a name="ln561">	uint16 corbReadPointer = controller-&gt;Read16(HDAC_CORB_READ_POS);</a>
<a name="ln562"> </a>
<a name="ln563">	corbReadPointer |= CORB_READ_POS_RESET;</a>
<a name="ln564">	controller-&gt;Write16(HDAC_CORB_READ_POS, corbReadPointer);</a>
<a name="ln565">	for (int timeout = 0; timeout &lt; 10; timeout++) {</a>
<a name="ln566">		snooze(100);</a>
<a name="ln567">		corbReadPointer = controller-&gt;Read16(HDAC_CORB_READ_POS);</a>
<a name="ln568">		if ((corbReadPointer &amp; CORB_READ_POS_RESET) != 0)</a>
<a name="ln569">			break;</a>
<a name="ln570">	}</a>
<a name="ln571">	if ((corbReadPointer &amp; CORB_READ_POS_RESET) == 0) {</a>
<a name="ln572">		dprintf(&quot;hda: CORB read pointer reset not acknowledged\n&quot;);</a>
<a name="ln573"> </a>
<a name="ln574">		// According to HDA spec v1.0a ch3.3.21, software must read the</a>
<a name="ln575">		// bit as 1 to verify that the reset completed, but not all HDA</a>
<a name="ln576">		// controllers follow that...</a>
<a name="ln577">		if ((quirks &amp; HDA_QUIRK_NO_CORBRP_RESET_ACK) == 0)</a>
<a name="ln578">			return B_BUSY;</a>
<a name="ln579">	}</a>
<a name="ln580"> </a>
<a name="ln581">	corbReadPointer &amp;= ~CORB_READ_POS_RESET;</a>
<a name="ln582">	controller-&gt;Write16(HDAC_CORB_READ_POS, corbReadPointer);</a>
<a name="ln583">	for (int timeout = 0; timeout &lt; 10; timeout++) {</a>
<a name="ln584">		snooze(100);</a>
<a name="ln585">		corbReadPointer = controller-&gt;Read16(HDAC_CORB_READ_POS);</a>
<a name="ln586">		if ((corbReadPointer &amp; CORB_READ_POS_RESET) == 0)</a>
<a name="ln587">			break;</a>
<a name="ln588">	}</a>
<a name="ln589">	if ((corbReadPointer &amp; CORB_READ_POS_RESET) != 0) {</a>
<a name="ln590">		dprintf(&quot;hda: CORB read pointer reset failed\n&quot;);</a>
<a name="ln591">		return B_BUSY;</a>
<a name="ln592">	}</a>
<a name="ln593"> </a>
<a name="ln594">	// Reset RIRB write pointer</a>
<a name="ln595">	controller-&gt;ReadModifyWrite16(HDAC_RIRB_WRITE_POS,</a>
<a name="ln596">		RIRB_WRITE_POS_RESET, RIRB_WRITE_POS_RESET);</a>
<a name="ln597"> </a>
<a name="ln598">	// Generate interrupt for every response</a>
<a name="ln599">	controller-&gt;ReadModifyWrite16(HDAC_RESPONSE_INTR_COUNT,</a>
<a name="ln600">		HDAC_RESPONSE_INTR_COUNT_MASK, 1);</a>
<a name="ln601"> </a>
<a name="ln602">	// Setup cached read/write indices</a>
<a name="ln603">	controller-&gt;rirb_read_pos = 1;</a>
<a name="ln604">	controller-&gt;corb_write_pos = 0;</a>
<a name="ln605"> </a>
<a name="ln606">	// Gentlemen, start your engines...</a>
<a name="ln607">	controller-&gt;ReadModifyWrite8(HDAC_CORB_CONTROL,</a>
<a name="ln608">		HDAC_CORB_CONTROL_MASK,</a>
<a name="ln609">		CORB_CONTROL_RUN | CORB_CONTROL_MEMORY_ERROR_INTR);</a>
<a name="ln610">	controller-&gt;ReadModifyWrite8(HDAC_RIRB_CONTROL,</a>
<a name="ln611">		HDAC_RIRB_CONTROL_MASK,</a>
<a name="ln612">		RIRB_CONTROL_DMA_ENABLE | RIRB_CONTROL_OVERRUN_INTR</a>
<a name="ln613">		| RIRB_CONTROL_RESPONSE_INTR);</a>
<a name="ln614"> </a>
<a name="ln615">	return B_OK;</a>
<a name="ln616">}</a>
<a name="ln617"> </a>
<a name="ln618"> </a>
<a name="ln619">//	#pragma mark - public stream functions</a>
<a name="ln620"> </a>
<a name="ln621"> </a>
<a name="ln622">void</a>
<a name="ln623">hda_stream_delete(hda_stream* stream)</a>
<a name="ln624">{</a>
<a name="ln625">	if (stream-&gt;buffer_area &gt;= 0)</a>
<a name="ln626">		delete_area(stream-&gt;buffer_area);</a>
<a name="ln627"> </a>
<a name="ln628">	if (stream-&gt;buffer_descriptors_area &gt;= 0)</a>
<a name="ln629">		delete_area(stream-&gt;buffer_descriptors_area);</a>
<a name="ln630"> </a>
<a name="ln631">	free(stream);</a>
<a name="ln632">}</a>
<a name="ln633"> </a>
<a name="ln634"> </a>
<a name="ln635">hda_stream*</a>
<a name="ln636">hda_stream_new(hda_audio_group* audioGroup, int type)</a>
<a name="ln637">{</a>
<a name="ln638">	hda_controller* controller = audioGroup-&gt;codec-&gt;controller;</a>
<a name="ln639"> </a>
<a name="ln640">	hda_stream* stream = (hda_stream*)calloc(1, sizeof(hda_stream));</a>
<a name="ln641">	if (stream == NULL)</a>
<a name="ln642">		return NULL;</a>
<a name="ln643"> </a>
<a name="ln644">	stream-&gt;buffer_area = B_ERROR;</a>
<a name="ln645">	stream-&gt;buffer_descriptors_area = B_ERROR;</a>
<a name="ln646">	stream-&gt;type = type;</a>
<a name="ln647">	stream-&gt;controller = controller;</a>
<a name="ln648">	stream-&gt;incorrect_position_count = 0;</a>
<a name="ln649">	stream-&gt;use_dma_position = true;</a>
<a name="ln650"> </a>
<a name="ln651">	switch (type) {</a>
<a name="ln652">		case STREAM_PLAYBACK:</a>
<a name="ln653">			stream-&gt;id = 1;</a>
<a name="ln654">			stream-&gt;offset = HDAC_OUTPUT_STREAM_OFFSET(controller, 0);</a>
<a name="ln655">			break;</a>
<a name="ln656"> </a>
<a name="ln657">		case STREAM_RECORD:</a>
<a name="ln658">			stream-&gt;id = 2;</a>
<a name="ln659">			stream-&gt;offset = HDAC_INPUT_STREAM_OFFSET(controller, 0);</a>
<a name="ln660">			break;</a>
<a name="ln661"> </a>
<a name="ln662">		default:</a>
<a name="ln663">			dprintf(&quot;%s: Unknown stream type %d!\n&quot;, __func__, type);</a>
<a name="ln664">			free(stream);</a>
<a name="ln665">			return NULL;</a>
<a name="ln666">	}</a>
<a name="ln667"> </a>
<a name="ln668">	// find I/O and Pin widgets for this stream</a>
<a name="ln669"> </a>
<a name="ln670">	if (hda_audio_group_get_widgets(audioGroup, stream) == B_OK) {</a>
<a name="ln671">		switch (type) {</a>
<a name="ln672">			case STREAM_PLAYBACK:</a>
<a name="ln673">				controller-&gt;streams[controller-&gt;num_input_streams] = stream;</a>
<a name="ln674">				break;</a>
<a name="ln675">			case STREAM_RECORD:</a>
<a name="ln676">				controller-&gt;streams[0] = stream;</a>
<a name="ln677">				break;</a>
<a name="ln678">		}</a>
<a name="ln679"> </a>
<a name="ln680">		return stream;</a>
<a name="ln681">	}</a>
<a name="ln682"> </a>
<a name="ln683">	dprintf(&quot;hda: hda_audio_group_get_widgets failed for %s stream\n&quot;,</a>
<a name="ln684">		type == STREAM_PLAYBACK ? &quot; playback&quot; : &quot;record&quot;);</a>
<a name="ln685"> </a>
<a name="ln686">	free(stream);</a>
<a name="ln687">	return NULL;</a>
<a name="ln688">}</a>
<a name="ln689"> </a>
<a name="ln690"> </a>
<a name="ln691">/*!	Starts a stream's DMA engine, and enables generating and receiving</a>
<a name="ln692">	interrupts for this stream.</a>
<a name="ln693">*/</a>
<a name="ln694">status_t</a>
<a name="ln695">hda_stream_start(hda_controller* controller, hda_stream* stream)</a>
<a name="ln696">{</a>
<a name="ln697">	dprintf(&quot;hda_stream_start() offset %&quot; B_PRIx32 &quot;\n&quot;, stream-&gt;offset);</a>
<a name="ln698"> </a>
<a name="ln699">	stream-&gt;frames_count = 0;</a>
<a name="ln700">	stream-&gt;last_link_frame_position = 0;</a>
<a name="ln701"> </a>
<a name="ln702">	controller-&gt;Write32(HDAC_INTR_CONTROL, controller-&gt;Read32(HDAC_INTR_CONTROL)</a>
<a name="ln703">		| (1 &lt;&lt; (stream-&gt;offset / HDAC_STREAM_SIZE)));</a>
<a name="ln704">	stream-&gt;Write8(HDAC_STREAM_CONTROL0, stream-&gt;Read8(HDAC_STREAM_CONTROL0)</a>
<a name="ln705">		| CONTROL0_BUFFER_COMPLETED_INTR | CONTROL0_FIFO_ERROR_INTR</a>
<a name="ln706">		| CONTROL0_DESCRIPTOR_ERROR_INTR | CONTROL0_RUN);</a>
<a name="ln707"> </a>
<a name="ln708">	stream-&gt;running = true;</a>
<a name="ln709">	return B_OK;</a>
<a name="ln710">}</a>
<a name="ln711"> </a>
<a name="ln712"> </a>
<a name="ln713">/*!	Stops the stream's DMA engine, and turns off interrupts for this</a>
<a name="ln714">	stream.</a>
<a name="ln715">*/</a>
<a name="ln716">status_t</a>
<a name="ln717">hda_stream_stop(hda_controller* controller, hda_stream* stream)</a>
<a name="ln718">{</a>
<a name="ln719">	dprintf(&quot;hda_stream_stop()\n&quot;);</a>
<a name="ln720">	stream-&gt;Write8(HDAC_STREAM_CONTROL0, stream-&gt;Read8(HDAC_STREAM_CONTROL0)</a>
<a name="ln721">		&amp; ~(CONTROL0_BUFFER_COMPLETED_INTR | CONTROL0_FIFO_ERROR_INTR</a>
<a name="ln722">			| CONTROL0_DESCRIPTOR_ERROR_INTR | CONTROL0_RUN));</a>
<a name="ln723">	controller-&gt;Write32(HDAC_INTR_CONTROL, controller-&gt;Read32(HDAC_INTR_CONTROL)</a>
<a name="ln724">		&amp; ~(1 &lt;&lt; (stream-&gt;offset / HDAC_STREAM_SIZE)));</a>
<a name="ln725"> </a>
<a name="ln726">	stream-&gt;running = false;</a>
<a name="ln727"> </a>
<a name="ln728">	return B_OK;</a>
<a name="ln729">}</a>
<a name="ln730"> </a>
<a name="ln731"> </a>
<a name="ln732">status_t</a>
<a name="ln733">hda_stream_setup_buffers(hda_audio_group* audioGroup, hda_stream* stream,</a>
<a name="ln734">	const char* desc)</a>
<a name="ln735">{</a>
<a name="ln736">	// Clear previously allocated memory</a>
<a name="ln737">	if (stream-&gt;buffer_area &gt;= 0) {</a>
<a name="ln738">		delete_area(stream-&gt;buffer_area);</a>
<a name="ln739">		stream-&gt;buffer_area = B_ERROR;</a>
<a name="ln740">	}</a>
<a name="ln741"> </a>
<a name="ln742">	if (stream-&gt;buffer_descriptors_area &gt;= 0) {</a>
<a name="ln743">		delete_area(stream-&gt;buffer_descriptors_area);</a>
<a name="ln744">		stream-&gt;buffer_descriptors_area = B_ERROR;</a>
<a name="ln745">	}</a>
<a name="ln746"> </a>
<a name="ln747">	// Find out stream format and sample rate</a>
<a name="ln748">	uint16 format = (stream-&gt;num_channels - 1) &amp; 0xf;</a>
<a name="ln749">	switch (stream-&gt;sample_format) {</a>
<a name="ln750">		case B_FMT_8BIT_S:	format |= FORMAT_8BIT; stream-&gt;bps = 8; break;</a>
<a name="ln751">		case B_FMT_16BIT:	format |= FORMAT_16BIT; stream-&gt;bps = 16; break;</a>
<a name="ln752">		case B_FMT_20BIT:	format |= FORMAT_20BIT; stream-&gt;bps = 20; break;</a>
<a name="ln753">		case B_FMT_24BIT:	format |= FORMAT_24BIT; stream-&gt;bps = 24; break;</a>
<a name="ln754">		case B_FMT_32BIT:	format |= FORMAT_32BIT; stream-&gt;bps = 32; break;</a>
<a name="ln755"> </a>
<a name="ln756">		default:</a>
<a name="ln757">			dprintf(&quot;hda: Invalid sample format: 0x%&quot; B_PRIx32 &quot;\n&quot;,</a>
<a name="ln758">				stream-&gt;sample_format);</a>
<a name="ln759">			break;</a>
<a name="ln760">	}</a>
<a name="ln761"> </a>
<a name="ln762">	for (uint32 index = 0; index &lt; sizeof(kRates) / sizeof(kRates[0]); index++) {</a>
<a name="ln763">		if (kRates[index].multi_rate == stream-&gt;sample_rate) {</a>
<a name="ln764">			format |= kRates[index].hw_rate;</a>
<a name="ln765">			stream-&gt;rate = kRates[index].rate;</a>
<a name="ln766">			break;</a>
<a name="ln767">		}</a>
<a name="ln768">	}</a>
<a name="ln769"> </a>
<a name="ln770">	// Calculate size of buffer (aligned to 128 bytes)</a>
<a name="ln771">	stream-&gt;buffer_size = ALIGN(stream-&gt;buffer_length * stream-&gt;num_channels</a>
<a name="ln772">		* stream-&gt;sample_size, 128);</a>
<a name="ln773"> </a>
<a name="ln774">	dprintf(&quot;hda: sample size %&quot; B_PRIu32 &quot;, num channels %&quot; B_PRIu32 &quot;, &quot;</a>
<a name="ln775">		&quot;buffer length %&quot; B_PRIu32 &quot;\n&quot;, stream-&gt;sample_size,</a>
<a name="ln776">		stream-&gt;num_channels, stream-&gt;buffer_length);</a>
<a name="ln777">	dprintf(&quot;hda: %s: setup stream %&quot; B_PRIu32 &quot;: SR=%&quot; B_PRIu32 &quot;, SF=%&quot;</a>
<a name="ln778">		B_PRIu32 &quot; F=0x%x (0x%&quot; B_PRIx32 &quot;)\n&quot;, __func__, stream-&gt;id,</a>
<a name="ln779">		stream-&gt;rate, stream-&gt;bps, format, stream-&gt;sample_format);</a>
<a name="ln780"> </a>
<a name="ln781">	// Calculate total size of all buffers (aligned to size of B_PAGE_SIZE)</a>
<a name="ln782">	uint32 alloc = stream-&gt;buffer_size * stream-&gt;num_buffers;</a>
<a name="ln783">	alloc = PAGE_ALIGN(alloc);</a>
<a name="ln784"> </a>
<a name="ln785">	// Allocate memory for buffers</a>
<a name="ln786">	uint8* buffer;</a>
<a name="ln787">	stream-&gt;buffer_area = create_area(&quot;hda buffers&quot;, (void**)&amp;buffer,</a>
<a name="ln788">		B_ANY_KERNEL_ADDRESS, alloc, B_CONTIGUOUS, B_READ_AREA | B_WRITE_AREA);</a>
<a name="ln789">	if (stream-&gt;buffer_area &lt; B_OK)</a>
<a name="ln790">		return stream-&gt;buffer_area;</a>
<a name="ln791"> </a>
<a name="ln792">	// Get the physical address of memory</a>
<a name="ln793">	physical_entry pe;</a>
<a name="ln794">	status_t status = get_memory_map(buffer, alloc, &amp;pe, 1);</a>
<a name="ln795">	if (status != B_OK) {</a>
<a name="ln796">		delete_area(stream-&gt;buffer_area);</a>
<a name="ln797">		return status;</a>
<a name="ln798">	}</a>
<a name="ln799"> </a>
<a name="ln800">	phys_addr_t bufferPhysicalAddress = pe.address;</a>
<a name="ln801"> </a>
<a name="ln802">	if (!stream-&gt;controller-&gt;dma_snooping) {</a>
<a name="ln803">		vm_set_area_memory_type(stream-&gt;buffer_area,</a>
<a name="ln804">			bufferPhysicalAddress, B_MTR_UC);</a>
<a name="ln805">	}</a>
<a name="ln806"> </a>
<a name="ln807">	dprintf(&quot;hda: %s(%s): Allocated %&quot; B_PRIu32 &quot; bytes for %&quot; B_PRIu32</a>
<a name="ln808">		&quot; buffers\n&quot;, __func__, desc, alloc, stream-&gt;num_buffers);</a>
<a name="ln809"> </a>
<a name="ln810">	// Store pointers (both virtual/physical)</a>
<a name="ln811">	for (uint32 index = 0; index &lt; stream-&gt;num_buffers; index++) {</a>
<a name="ln812">		stream-&gt;buffers[index] = buffer + (index * stream-&gt;buffer_size);</a>
<a name="ln813">		stream-&gt;physical_buffers[index] = bufferPhysicalAddress</a>
<a name="ln814">			+ (index * stream-&gt;buffer_size);</a>
<a name="ln815">	}</a>
<a name="ln816"> </a>
<a name="ln817">	// Now allocate BDL for buffer range</a>
<a name="ln818">	uint32 bdlCount = stream-&gt;num_buffers;</a>
<a name="ln819">	alloc = bdlCount * sizeof(bdl_entry_t);</a>
<a name="ln820">	alloc = PAGE_ALIGN(alloc);</a>
<a name="ln821"> </a>
<a name="ln822">	bdl_entry_t* bufferDescriptors;</a>
<a name="ln823">	stream-&gt;buffer_descriptors_area = create_area(&quot;hda buffer descriptors&quot;,</a>
<a name="ln824">		(void**)&amp;bufferDescriptors, B_ANY_KERNEL_ADDRESS, alloc,</a>
<a name="ln825">		B_CONTIGUOUS, 0);</a>
<a name="ln826">	if (stream-&gt;buffer_descriptors_area &lt; B_OK) {</a>
<a name="ln827">		delete_area(stream-&gt;buffer_area);</a>
<a name="ln828">		return stream-&gt;buffer_descriptors_area;</a>
<a name="ln829">	}</a>
<a name="ln830"> </a>
<a name="ln831">	// Get the physical address of memory</a>
<a name="ln832">	status = get_memory_map(bufferDescriptors, alloc, &amp;pe, 1);</a>
<a name="ln833">	if (status != B_OK) {</a>
<a name="ln834">		delete_area(stream-&gt;buffer_area);</a>
<a name="ln835">		delete_area(stream-&gt;buffer_descriptors_area);</a>
<a name="ln836">		return status;</a>
<a name="ln837">	}</a>
<a name="ln838"> </a>
<a name="ln839">	stream-&gt;physical_buffer_descriptors = pe.address;</a>
<a name="ln840"> </a>
<a name="ln841">	if (!stream-&gt;controller-&gt;dma_snooping) {</a>
<a name="ln842">		vm_set_area_memory_type(stream-&gt;buffer_descriptors_area,</a>
<a name="ln843">			stream-&gt;physical_buffer_descriptors, B_MTR_UC);</a>
<a name="ln844">	}</a>
<a name="ln845"> </a>
<a name="ln846">	dprintf(&quot;hda: %s(%s): Allocated %&quot; B_PRIu32 &quot; bytes for %&quot; B_PRIu32</a>
<a name="ln847">		&quot; BDLEs\n&quot;, __func__, desc, alloc, bdlCount);</a>
<a name="ln848"> </a>
<a name="ln849">	// Setup buffer descriptor list (BDL) entries</a>
<a name="ln850">	uint32 fragments = 0;</a>
<a name="ln851">	for (uint32 index = 0; index &lt; stream-&gt;num_buffers;</a>
<a name="ln852">			index++, bufferDescriptors++) {</a>
<a name="ln853">		bufferDescriptors-&gt;lower = (uint32)stream-&gt;physical_buffers[index];</a>
<a name="ln854">		bufferDescriptors-&gt;upper</a>
<a name="ln855">			= (uint32)((uint64)stream-&gt;physical_buffers[index] &gt;&gt; 32);</a>
<a name="ln856">		fragments++;</a>
<a name="ln857">		bufferDescriptors-&gt;length = stream-&gt;buffer_size;</a>
<a name="ln858">		bufferDescriptors-&gt;ioc = 1;</a>
<a name="ln859">			// we want an interrupt after every buffer</a>
<a name="ln860">	}</a>
<a name="ln861"> </a>
<a name="ln862">	// Configure stream registers</a>
<a name="ln863">	stream-&gt;Write16(HDAC_STREAM_FORMAT, format);</a>
<a name="ln864">	stream-&gt;Write32(HDAC_STREAM_BUFFERS_BASE_LOWER,</a>
<a name="ln865">		(uint32)stream-&gt;physical_buffer_descriptors);</a>
<a name="ln866">	stream-&gt;Write32(HDAC_STREAM_BUFFERS_BASE_UPPER,</a>
<a name="ln867">		(uint32)(stream-&gt;physical_buffer_descriptors &gt;&gt; 32));</a>
<a name="ln868">	stream-&gt;Write16(HDAC_STREAM_LAST_VALID, fragments - 1);</a>
<a name="ln869">	// total cyclic buffer size in _bytes_</a>
<a name="ln870">	stream-&gt;Write32(HDAC_STREAM_BUFFER_SIZE, stream-&gt;buffer_size</a>
<a name="ln871">		* stream-&gt;num_buffers);</a>
<a name="ln872">	stream-&gt;Write8(HDAC_STREAM_CONTROL2, stream-&gt;id &lt;&lt; CONTROL2_STREAM_SHIFT);</a>
<a name="ln873"> </a>
<a name="ln874">	stream-&gt;controller-&gt;Write32(HDAC_DMA_POSITION_BASE_LOWER,</a>
<a name="ln875">		stream-&gt;controller-&gt;Read32(HDAC_DMA_POSITION_BASE_LOWER)</a>
<a name="ln876">		| DMA_POSITION_ENABLED);</a>
<a name="ln877"> </a>
<a name="ln878">	dprintf(&quot;hda: stream: %&quot; B_PRIu32 &quot; fifo size: %d num_io_widgets: %&quot;</a>
<a name="ln879">		B_PRIu32 &quot;\n&quot;, stream-&gt;id, stream-&gt;Read16(HDAC_STREAM_FIFO_SIZE),</a>
<a name="ln880">		stream-&gt;num_io_widgets);</a>
<a name="ln881">	dprintf(&quot;hda: widgets: &quot;);</a>
<a name="ln882"> </a>
<a name="ln883">	hda_codec* codec = audioGroup-&gt;codec;</a>
<a name="ln884">	uint32 channelNum = 0;</a>
<a name="ln885">	for (uint32 i = 0; i &lt; stream-&gt;num_io_widgets; i++) {</a>
<a name="ln886">		corb_t verb[2];</a>
<a name="ln887">		verb[0] = MAKE_VERB(codec-&gt;addr, stream-&gt;io_widgets[i],</a>
<a name="ln888">			VID_SET_CONVERTER_FORMAT, format);</a>
<a name="ln889">		uint32 val = stream-&gt;id &lt;&lt; 4;</a>
<a name="ln890">		if (channelNum &lt; stream-&gt;num_channels)</a>
<a name="ln891">			val |= channelNum;</a>
<a name="ln892">		else</a>
<a name="ln893">			val = 0;</a>
<a name="ln894">		verb[1] = MAKE_VERB(codec-&gt;addr, stream-&gt;io_widgets[i],</a>
<a name="ln895">			VID_SET_CONVERTER_STREAM_CHANNEL, val);</a>
<a name="ln896"> </a>
<a name="ln897">		uint32 response[2];</a>
<a name="ln898">		hda_send_verbs(codec, verb, response, 2);</a>
<a name="ln899">		//channelNum += 2; // TODO stereo widget ? Every output gets the same stream for now</a>
<a name="ln900">		dprintf(&quot;%&quot; B_PRIu32 &quot; &quot;, stream-&gt;io_widgets[i]);</a>
<a name="ln901"> </a>
<a name="ln902">		hda_widget* widget = hda_audio_group_get_widget(audioGroup,</a>
<a name="ln903">			stream-&gt;io_widgets[i]);</a>
<a name="ln904">		if ((widget-&gt;capabilities.audio &amp; AUDIO_CAP_DIGITAL) != 0) {</a>
<a name="ln905">			verb[0] = MAKE_VERB(codec-&gt;addr, stream-&gt;io_widgets[i],</a>
<a name="ln906">				VID_SET_DIGITAL_CONVERTER_CONTROL1, format);</a>
<a name="ln907">			hda_send_verbs(codec, verb, response, 1);</a>
<a name="ln908">		}</a>
<a name="ln909">	}</a>
<a name="ln910">	dprintf(&quot;\n&quot;);</a>
<a name="ln911"> </a>
<a name="ln912">	snooze(1000);</a>
<a name="ln913">	return B_OK;</a>
<a name="ln914">}</a>
<a name="ln915"> </a>
<a name="ln916"> </a>
<a name="ln917">//	#pragma mark - public controller functions</a>
<a name="ln918"> </a>
<a name="ln919"> </a>
<a name="ln920">status_t</a>
<a name="ln921">hda_send_verbs(hda_codec* codec, corb_t* verbs, uint32* responses, uint32 count)</a>
<a name="ln922">{</a>
<a name="ln923">	hda_controller* controller = codec-&gt;controller;</a>
<a name="ln924">	uint32 sent = 0;</a>
<a name="ln925"> </a>
<a name="ln926">	codec-&gt;response_count = 0;</a>
<a name="ln927"> </a>
<a name="ln928">	while (sent &lt; count) {</a>
<a name="ln929">		uint32 readPos = controller-&gt;Read16(HDAC_CORB_READ_POS);</a>
<a name="ln930">		uint32 queued = 0;</a>
<a name="ln931"> </a>
<a name="ln932">		while (sent &lt; count) {</a>
<a name="ln933">			uint32 writePos = next_corb(controller);</a>
<a name="ln934"> </a>
<a name="ln935">			if (writePos == readPos) {</a>
<a name="ln936">				// There is no space left in the ring buffer; execute the</a>
<a name="ln937">				// queued commands and wait until</a>
<a name="ln938">				break;</a>
<a name="ln939">			}</a>
<a name="ln940"> </a>
<a name="ln941">			controller-&gt;corb[writePos] = verbs[sent++];</a>
<a name="ln942">			controller-&gt;corb_write_pos = writePos;</a>
<a name="ln943">			queued++;</a>
<a name="ln944">		}</a>
<a name="ln945"> </a>
<a name="ln946">		controller-&gt;Write16(HDAC_CORB_WRITE_POS, controller-&gt;corb_write_pos);</a>
<a name="ln947">		status_t status = acquire_sem_etc(codec-&gt;response_sem, queued,</a>
<a name="ln948">			B_RELATIVE_TIMEOUT, 50000ULL);</a>
<a name="ln949">		if (status != B_OK)</a>
<a name="ln950">			return status;</a>
<a name="ln951">	}</a>
<a name="ln952"> </a>
<a name="ln953">	if (responses != NULL)</a>
<a name="ln954">		memcpy(responses, codec-&gt;responses, count * sizeof(uint32));</a>
<a name="ln955"> </a>
<a name="ln956">	return B_OK;</a>
<a name="ln957">}</a>
<a name="ln958"> </a>
<a name="ln959"> </a>
<a name="ln960">status_t</a>
<a name="ln961">hda_verb_write(hda_codec* codec, uint32 nid, uint32 vid, uint16 payload)</a>
<a name="ln962">{</a>
<a name="ln963">	corb_t verb = MAKE_VERB(codec-&gt;addr, nid, vid, payload);</a>
<a name="ln964">	return hda_send_verbs(codec, &amp;verb, NULL, 1);</a>
<a name="ln965">}</a>
<a name="ln966"> </a>
<a name="ln967"> </a>
<a name="ln968">status_t</a>
<a name="ln969">hda_verb_read(hda_codec* codec, uint32 nid, uint32 vid, uint32* response)</a>
<a name="ln970">{</a>
<a name="ln971">	corb_t verb = MAKE_VERB(codec-&gt;addr, nid, vid, 0);</a>
<a name="ln972">	return hda_send_verbs(codec, &amp;verb, response, 1);</a>
<a name="ln973">}</a>
<a name="ln974"> </a>
<a name="ln975"> </a>
<a name="ln976">/*! Setup hardware for use; detect codecs; etc */</a>
<a name="ln977">status_t</a>
<a name="ln978">hda_hw_init(hda_controller* controller)</a>
<a name="ln979">{</a>
<a name="ln980">	uint16 capabilities;</a>
<a name="ln981">	uint16 stateStatus;</a>
<a name="ln982">	uint16 cmd;</a>
<a name="ln983">	status_t status;</a>
<a name="ln984">	uint32 quirks = get_controller_quirks(controller-&gt;pci_info);</a>
<a name="ln985"> </a>
<a name="ln986">	// Map MMIO registers</a>
<a name="ln987">	controller-&gt;regs_area = map_physical_memory(&quot;hda_hw_regs&quot;,</a>
<a name="ln988">		controller-&gt;pci_info.u.h0.base_registers[0],</a>
<a name="ln989">		controller-&gt;pci_info.u.h0.base_register_sizes[0], B_ANY_KERNEL_ADDRESS,</a>
<a name="ln990">		0, (void**)&amp;controller-&gt;regs);</a>
<a name="ln991">	if (controller-&gt;regs_area &lt; B_OK) {</a>
<a name="ln992">		status = controller-&gt;regs_area;</a>
<a name="ln993">		goto error;</a>
<a name="ln994">	}</a>
<a name="ln995"> </a>
<a name="ln996">	cmd = (gPci-&gt;read_pci_config)(controller-&gt;pci_info.bus,</a>
<a name="ln997">		controller-&gt;pci_info.device, controller-&gt;pci_info.function,</a>
<a name="ln998">		PCI_command, 2);</a>
<a name="ln999">	if (!(cmd &amp; PCI_command_master)) {</a>
<a name="ln1000">		dprintf(&quot;hda: enabling PCI bus mastering\n&quot;);</a>
<a name="ln1001">		cmd |= PCI_command_master;</a>
<a name="ln1002">	}</a>
<a name="ln1003">	if (!(cmd &amp; PCI_command_memory)) {</a>
<a name="ln1004">		dprintf(&quot;hda: enabling PCI memory access\n&quot;);</a>
<a name="ln1005">		cmd |= PCI_command_memory;</a>
<a name="ln1006">	}</a>
<a name="ln1007">	if ((cmd &amp; PCI_command_int_disable)) {</a>
<a name="ln1008">		dprintf(&quot;hda: enabling PCI interrupts\n&quot;);</a>
<a name="ln1009">		cmd &amp;= ~PCI_command_int_disable;</a>
<a name="ln1010">	}</a>
<a name="ln1011">	(gPci-&gt;write_pci_config)(controller-&gt;pci_info.bus,</a>
<a name="ln1012">		controller-&gt;pci_info.device, controller-&gt;pci_info.function,</a>
<a name="ln1013">			PCI_command, 2, cmd);</a>
<a name="ln1014"> </a>
<a name="ln1015">	// Absolute minimum hw is online; we can now install interrupt handler</a>
<a name="ln1016"> </a>
<a name="ln1017">	controller-&gt;irq = controller-&gt;pci_info.u.h0.interrupt_line;</a>
<a name="ln1018">	controller-&gt;msi = false;</a>
<a name="ln1019"> </a>
<a name="ln1020">	if (gPCIx86Module != NULL &amp;&amp; (quirks &amp; HDA_QUIRK_NO_MSI) == 0</a>
<a name="ln1021">			&amp;&amp; gPCIx86Module-&gt;get_msi_count(</a>
<a name="ln1022">				controller-&gt;pci_info.bus, controller-&gt;pci_info.device,</a>
<a name="ln1023">				controller-&gt;pci_info.function) &gt;= 1) {</a>
<a name="ln1024">		// Try MSI first</a>
<a name="ln1025">		uint8 vector;</a>
<a name="ln1026">		if (gPCIx86Module-&gt;configure_msi(controller-&gt;pci_info.bus,</a>
<a name="ln1027">				controller-&gt;pci_info.device, controller-&gt;pci_info.function,</a>
<a name="ln1028">				1, &amp;vector) == B_OK</a>
<a name="ln1029">			&amp;&amp; gPCIx86Module-&gt;enable_msi(controller-&gt;pci_info.bus,</a>
<a name="ln1030">				controller-&gt;pci_info.device, controller-&gt;pci_info.function)</a>
<a name="ln1031">					== B_OK) {</a>
<a name="ln1032">			dprintf(&quot;hda: using MSI vector %u\n&quot;, vector);</a>
<a name="ln1033">			controller-&gt;irq = vector;</a>
<a name="ln1034">			controller-&gt;msi = true;</a>
<a name="ln1035">		}</a>
<a name="ln1036">	}</a>
<a name="ln1037"> </a>
<a name="ln1038">	status = install_io_interrupt_handler(controller-&gt;irq,</a>
<a name="ln1039">		(interrupt_handler)hda_interrupt_handler, controller, 0);</a>
<a name="ln1040">	if (status != B_OK)</a>
<a name="ln1041">		goto no_irq;</a>
<a name="ln1042"> </a>
<a name="ln1043">	// TCSEL is reset to TC0 (clear 0-2 bits)</a>
<a name="ln1044">	update_pci_register(controller, PCI_HDA_TCSEL, PCI_HDA_TCSEL_MASK, 0, 1);</a>
<a name="ln1045"> </a>
<a name="ln1046">	controller-&gt;dma_snooping = false;</a>
<a name="ln1047"> </a>
<a name="ln1048">	if ((quirks &amp; HDA_QUIRK_SNOOP) != 0) {</a>
<a name="ln1049">		switch (controller-&gt;pci_info.vendor_id) {</a>
<a name="ln1050">			case PCI_VENDOR_NVIDIA:</a>
<a name="ln1051">			{</a>
<a name="ln1052">				controller-&gt;dma_snooping = update_pci_register(controller,</a>
<a name="ln1053">					NVIDIA_HDA_TRANSREG, NVIDIA_HDA_TRANSREG_MASK,</a>
<a name="ln1054">					NVIDIA_HDA_ENABLE_COHBITS, 1, true);</a>
<a name="ln1055">				if (!controller-&gt;dma_snooping)</a>
<a name="ln1056">					break;</a>
<a name="ln1057"> </a>
<a name="ln1058">				controller-&gt;dma_snooping = update_pci_register(controller,</a>
<a name="ln1059">					NVIDIA_HDA_ISTRM_COH, ~NVIDIA_HDA_ENABLE_COHBIT,</a>
<a name="ln1060">					NVIDIA_HDA_ENABLE_COHBIT, 1, true);</a>
<a name="ln1061">				if (!controller-&gt;dma_snooping)</a>
<a name="ln1062">					break;</a>
<a name="ln1063"> </a>
<a name="ln1064">				controller-&gt;dma_snooping = update_pci_register(controller,</a>
<a name="ln1065">					NVIDIA_HDA_OSTRM_COH, ~NVIDIA_HDA_ENABLE_COHBIT,</a>
<a name="ln1066">					NVIDIA_HDA_ENABLE_COHBIT, 1, true);</a>
<a name="ln1067"> </a>
<a name="ln1068">				break;</a>
<a name="ln1069">			}</a>
<a name="ln1070"> </a>
<a name="ln1071">			case PCI_VENDOR_AMD:</a>
<a name="ln1072">			{</a>
<a name="ln1073">				controller-&gt;dma_snooping = update_pci_register(controller,</a>
<a name="ln1074">					ATI_HDA_MISC_CNTR2, ATI_HDA_MISC_CNTR2_MASK,</a>
<a name="ln1075">					ATI_HDA_ENABLE_SNOOP, 1, true);</a>
<a name="ln1076">				break;</a>
<a name="ln1077">			}</a>
<a name="ln1078"> </a>
<a name="ln1079">			case PCI_VENDOR_INTEL:</a>
<a name="ln1080">				controller-&gt;dma_snooping = update_pci_register(controller,</a>
<a name="ln1081">					INTEL_SCH_HDA_DEVC, ~INTEL_SCH_HDA_DEVC_SNOOP, 0, 2, true);</a>
<a name="ln1082">				break;</a>
<a name="ln1083">		}</a>
<a name="ln1084">	}</a>
<a name="ln1085"> </a>
<a name="ln1086">	dprintf(&quot;hda: DMA snooping: %s\n&quot;,</a>
<a name="ln1087">		controller-&gt;dma_snooping ? &quot;yes&quot; : &quot;no&quot;);</a>
<a name="ln1088"> </a>
<a name="ln1089">	capabilities = controller-&gt;Read16(HDAC_GLOBAL_CAP);</a>
<a name="ln1090">	controller-&gt;num_input_streams = GLOBAL_CAP_INPUT_STREAMS(capabilities);</a>
<a name="ln1091">	controller-&gt;num_output_streams = GLOBAL_CAP_OUTPUT_STREAMS(capabilities);</a>
<a name="ln1092">	controller-&gt;num_bidir_streams = GLOBAL_CAP_BIDIR_STREAMS(capabilities);</a>
<a name="ln1093"> </a>
<a name="ln1094">	// show some hw features</a>
<a name="ln1095">	dprintf(&quot;hda: HDA v%d.%d, O:%&quot; B_PRIu32 &quot;/I:%&quot; B_PRIu32 &quot;/B:%&quot; B_PRIu32</a>
<a name="ln1096">		&quot;, #SDO:%d, 64bit:%s\n&quot;,</a>
<a name="ln1097">		controller-&gt;Read8(HDAC_VERSION_MAJOR),</a>
<a name="ln1098">		controller-&gt;Read8(HDAC_VERSION_MINOR),</a>
<a name="ln1099">		controller-&gt;num_output_streams, controller-&gt;num_input_streams,</a>
<a name="ln1100">		controller-&gt;num_bidir_streams,</a>
<a name="ln1101">		GLOBAL_CAP_NUM_SDO(capabilities),</a>
<a name="ln1102">		GLOBAL_CAP_64BIT(capabilities) ? &quot;yes&quot; : &quot;no&quot;);</a>
<a name="ln1103"> </a>
<a name="ln1104">	// Get controller into valid state</a>
<a name="ln1105">	status = reset_controller(controller);</a>
<a name="ln1106">	if (status != B_OK) {</a>
<a name="ln1107">		dprintf(&quot;hda: reset_controller failed\n&quot;);</a>
<a name="ln1108">		goto reset_failed;</a>
<a name="ln1109">	}</a>
<a name="ln1110"> </a>
<a name="ln1111">	// Setup CORB/RIRB/DMA POS</a>
<a name="ln1112">	status = init_corb_rirb_pos(controller, quirks);</a>
<a name="ln1113">	if (status != B_OK) {</a>
<a name="ln1114">		dprintf(&quot;hda: init_corb_rirb_pos failed\n&quot;);</a>
<a name="ln1115">		goto corb_rirb_failed;</a>
<a name="ln1116">	}</a>
<a name="ln1117"> </a>
<a name="ln1118">	// Don't enable codec state change interrupts. We don't handle</a>
<a name="ln1119">	// them, as we want to use the STATE_STATUS register to identify</a>
<a name="ln1120">	// available codecs. We'd have to clear that register in the interrupt</a>
<a name="ln1121">	// handler to 'ack' the codec change.</a>
<a name="ln1122">	controller-&gt;ReadModifyWrite16(HDAC_WAKE_ENABLE, HDAC_WAKE_ENABLE_MASK, 0);</a>
<a name="ln1123"> </a>
<a name="ln1124">	// Enable controller interrupts</a>
<a name="ln1125">	controller-&gt;Write32(HDAC_INTR_CONTROL, INTR_CONTROL_GLOBAL_ENABLE</a>
<a name="ln1126">		| INTR_CONTROL_CONTROLLER_ENABLE);</a>
<a name="ln1127"> </a>
<a name="ln1128">	snooze(1000);</a>
<a name="ln1129"> </a>
<a name="ln1130">	stateStatus = controller-&gt;Read16(HDAC_STATE_STATUS);</a>
<a name="ln1131">	if (!stateStatus) {</a>
<a name="ln1132">		dprintf(&quot;hda: bad codec status\n&quot;);</a>
<a name="ln1133">		status = ENODEV;</a>
<a name="ln1134">		goto corb_rirb_failed;</a>
<a name="ln1135">	}</a>
<a name="ln1136">	controller-&gt;Write16(HDAC_STATE_STATUS, stateStatus);</a>
<a name="ln1137"> </a>
<a name="ln1138">	// Create codecs</a>
<a name="ln1139">	for (uint32 index = 0; index &lt; HDA_MAX_CODECS; index++) {</a>
<a name="ln1140">		if ((stateStatus &amp; (1 &lt;&lt; index)) != 0)</a>
<a name="ln1141">			hda_codec_new(controller, index);</a>
<a name="ln1142">	}</a>
<a name="ln1143">	for (uint32 index = 0; index &lt; HDA_MAX_CODECS; index++) {</a>
<a name="ln1144">		if (controller-&gt;codecs[index]</a>
<a name="ln1145">			&amp;&amp; controller-&gt;codecs[index]-&gt;num_audio_groups &gt; 0) {</a>
<a name="ln1146">			controller-&gt;active_codec = controller-&gt;codecs[index];</a>
<a name="ln1147">			break;</a>
<a name="ln1148">		}</a>
<a name="ln1149">	}</a>
<a name="ln1150"> </a>
<a name="ln1151">	controller-&gt;buffer_ready_sem = create_sem(0, &quot;hda_buffer_sem&quot;);</a>
<a name="ln1152">	if (controller-&gt;buffer_ready_sem &lt; B_OK) {</a>
<a name="ln1153">		dprintf(&quot;hda: failed to create semaphore\n&quot;);</a>
<a name="ln1154">		status = ENODEV;</a>
<a name="ln1155">		goto corb_rirb_failed;</a>
<a name="ln1156">	}</a>
<a name="ln1157"> </a>
<a name="ln1158">	if (controller-&gt;active_codec != NULL)</a>
<a name="ln1159">		return B_OK;</a>
<a name="ln1160"> </a>
<a name="ln1161">	dprintf(&quot;hda: no active codec\n&quot;);</a>
<a name="ln1162">	status = ENODEV;</a>
<a name="ln1163"> </a>
<a name="ln1164">	delete_sem(controller-&gt;buffer_ready_sem);</a>
<a name="ln1165"> </a>
<a name="ln1166">corb_rirb_failed:</a>
<a name="ln1167">	controller-&gt;Write32(HDAC_INTR_CONTROL, 0);</a>
<a name="ln1168"> </a>
<a name="ln1169">reset_failed:</a>
<a name="ln1170">	if (controller-&gt;msi) {</a>
<a name="ln1171">		gPCIx86Module-&gt;disable_msi(controller-&gt;pci_info.bus,</a>
<a name="ln1172">			controller-&gt;pci_info.device, controller-&gt;pci_info.function);</a>
<a name="ln1173">	}</a>
<a name="ln1174"> </a>
<a name="ln1175">	remove_io_interrupt_handler(controller-&gt;irq,</a>
<a name="ln1176">		(interrupt_handler)hda_interrupt_handler, controller);</a>
<a name="ln1177"> </a>
<a name="ln1178">no_irq:</a>
<a name="ln1179">	delete_area(controller-&gt;regs_area);</a>
<a name="ln1180">	controller-&gt;regs_area = B_ERROR;</a>
<a name="ln1181">	controller-&gt;regs = NULL;</a>
<a name="ln1182"> </a>
<a name="ln1183">error:</a>
<a name="ln1184">	dprintf(&quot;hda: ERROR: %s(%&quot; B_PRIx32 &quot;)\n&quot;, strerror(status), status);</a>
<a name="ln1185"> </a>
<a name="ln1186">	return status;</a>
<a name="ln1187">}</a>
<a name="ln1188"> </a>
<a name="ln1189"> </a>
<a name="ln1190">/*! Stop any activity */</a>
<a name="ln1191">void</a>
<a name="ln1192">hda_hw_stop(hda_controller* controller)</a>
<a name="ln1193">{</a>
<a name="ln1194">	// Stop all audio streams</a>
<a name="ln1195">	for (uint32 index = 0; index &lt; HDA_MAX_STREAMS; index++) {</a>
<a name="ln1196">		if (controller-&gt;streams[index] &amp;&amp; controller-&gt;streams[index]-&gt;running)</a>
<a name="ln1197">			hda_stream_stop(controller, controller-&gt;streams[index]);</a>
<a name="ln1198">	}</a>
<a name="ln1199">}</a>
<a name="ln1200"> </a>
<a name="ln1201"> </a>
<a name="ln1202">/*! Free resources */</a>
<a name="ln1203">void</a>
<a name="ln1204">hda_hw_uninit(hda_controller* controller)</a>
<a name="ln1205">{</a>
<a name="ln1206">	if (controller == NULL)</a>
<a name="ln1207">		return;</a>
<a name="ln1208"> </a>
<a name="ln1209">	// Stop all audio streams</a>
<a name="ln1210">	hda_hw_stop(controller);</a>
<a name="ln1211"> </a>
<a name="ln1212">	if (controller-&gt;buffer_ready_sem &gt;= B_OK) {</a>
<a name="ln1213">		delete_sem(controller-&gt;buffer_ready_sem);</a>
<a name="ln1214">		controller-&gt;buffer_ready_sem = B_ERROR;</a>
<a name="ln1215">	}</a>
<a name="ln1216"> </a>
<a name="ln1217">	reset_controller(controller);</a>
<a name="ln1218"> </a>
<a name="ln1219">	// Disable interrupts, and remove interrupt handler</a>
<a name="ln1220">	controller-&gt;Write32(HDAC_INTR_CONTROL, 0);</a>
<a name="ln1221"> </a>
<a name="ln1222">	if (controller-&gt;msi) {</a>
<a name="ln1223">		// Disable MSI</a>
<a name="ln1224">		gPCIx86Module-&gt;disable_msi(controller-&gt;pci_info.bus,</a>
<a name="ln1225">			controller-&gt;pci_info.device, controller-&gt;pci_info.function);</a>
<a name="ln1226">	}</a>
<a name="ln1227"> </a>
<a name="ln1228">	remove_io_interrupt_handler(controller-&gt;irq,</a>
<a name="ln1229">		(interrupt_handler)hda_interrupt_handler, controller);</a>
<a name="ln1230"> </a>
<a name="ln1231">	if (gPCIx86Module != NULL) {</a>
<a name="ln1232">		put_module(B_PCI_X86_MODULE_NAME);</a>
<a name="ln1233">		gPCIx86Module = NULL;</a>
<a name="ln1234">	}</a>
<a name="ln1235"> </a>
<a name="ln1236">	// Delete corb/rirb area</a>
<a name="ln1237">	if (controller-&gt;corb_rirb_pos_area &gt;= 0) {</a>
<a name="ln1238">		delete_area(controller-&gt;corb_rirb_pos_area);</a>
<a name="ln1239">		controller-&gt;corb_rirb_pos_area = B_ERROR;</a>
<a name="ln1240">		controller-&gt;corb = NULL;</a>
<a name="ln1241">		controller-&gt;rirb = NULL;</a>
<a name="ln1242">		controller-&gt;stream_positions = NULL;</a>
<a name="ln1243">	}</a>
<a name="ln1244"> </a>
<a name="ln1245">	// Unmap registers</a>
<a name="ln1246">	if (controller-&gt;regs_area &gt;= 0) {</a>
<a name="ln1247">		delete_area(controller-&gt;regs_area);</a>
<a name="ln1248">		controller-&gt;regs_area = B_ERROR;</a>
<a name="ln1249">		controller-&gt;regs = NULL;</a>
<a name="ln1250">	}</a>
<a name="ln1251"> </a>
<a name="ln1252">	// Now delete all codecs</a>
<a name="ln1253">	for (uint32 index = 0; index &lt; HDA_MAX_CODECS; index++) {</a>
<a name="ln1254">		if (controller-&gt;codecs[index] != NULL)</a>
<a name="ln1255">			hda_codec_delete(controller-&gt;codecs[index]);</a>
<a name="ln1256">	}</a>
<a name="ln1257">	controller-&gt;active_codec = NULL;</a>
<a name="ln1258">}</a>

</code></pre>
<div class="balloon" rel="1224"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'gPCIx86Module' pointer was utilized before it was verified against nullptr. Check lines: 1224, 1231.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
