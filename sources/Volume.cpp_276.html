
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>Volume.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2001-2011, Ingo Weinhold, ingo_weinhold@gmx.de.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> */</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;Volume.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;errno.h&gt;</a>
<a name="ln9">#include &lt;string.h&gt;</a>
<a name="ln10">#include &lt;unistd.h&gt;</a>
<a name="ln11">#include &lt;sys/stat.h&gt;</a>
<a name="ln12"> </a>
<a name="ln13">#include &lt;algorithm&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;fs_cache.h&gt;</a>
<a name="ln16"> </a>
<a name="ln17">#include &lt;util/AutoLock.h&gt;</a>
<a name="ln18">#include &lt;util/OpenHashTable.h&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;fs/fd.h&gt;	// kernel private</a>
<a name="ln21">#include &lt;io_requests.h&gt;</a>
<a name="ln22">#include &lt;thread.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;IORequest.h&quot;	// kernel internal</a>
<a name="ln25"> </a>
<a name="ln26">#include &quot;Compatibility.h&quot;</a>
<a name="ln27">#include &quot;Debug.h&quot;</a>
<a name="ln28">#include &quot;FileSystem.h&quot;</a>
<a name="ln29">#include &quot;IOCtlInfo.h&quot;</a>
<a name="ln30">#include &quot;kernel_interface.h&quot;</a>
<a name="ln31">#include &quot;KernelRequestHandler.h&quot;</a>
<a name="ln32">#include &quot;PortReleaser.h&quot;</a>
<a name="ln33">#include &quot;RequestAllocator.h&quot;</a>
<a name="ln34">#include &quot;RequestPort.h&quot;</a>
<a name="ln35">#include &quot;Requests.h&quot;</a>
<a name="ln36">#include &quot;userlandfs_ioctl.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">// missing ioctl()s</a>
<a name="ln39">// TODO: Place somewhere else.</a>
<a name="ln40">#define		IOCTL_FILE_UNCACHED_IO	10000</a>
<a name="ln41">#define		IOCTL_CREATE_TIME		10002</a>
<a name="ln42">#define		IOCTL_MODIFIED_TIME		10003</a>
<a name="ln43"> </a>
<a name="ln44">// If a thread of the userland server enters userland FS kernel code and</a>
<a name="ln45">// is sending a request, this is the time after which it shall time out</a>
<a name="ln46">// waiting for a reply.</a>
<a name="ln47">static const bigtime_t kUserlandServerlandPortTimeout = 10000000;	// 10s</a>
<a name="ln48"> </a>
<a name="ln49"> </a>
<a name="ln50">// VNode</a>
<a name="ln51">struct Volume::VNode {</a>
<a name="ln52">	ino_t		id;</a>
<a name="ln53">	void*		clientNode;</a>
<a name="ln54">	void*		fileCache;</a>
<a name="ln55">	VNodeOps*	ops;</a>
<a name="ln56">	int32		useCount;</a>
<a name="ln57">	bool		valid;</a>
<a name="ln58">	bool		published;</a>
<a name="ln59">	VNode*		hash_link;</a>
<a name="ln60"> </a>
<a name="ln61">	VNode(ino_t id, void* clientNode, VNodeOps* ops)</a>
<a name="ln62">		:</a>
<a name="ln63">		id(id),</a>
<a name="ln64">		clientNode(clientNode),</a>
<a name="ln65">		fileCache(NULL),</a>
<a name="ln66">		ops(ops),</a>
<a name="ln67">		useCount(0),</a>
<a name="ln68">		valid(true),</a>
<a name="ln69">		published(true)</a>
<a name="ln70">	{</a>
<a name="ln71">	}</a>
<a name="ln72"> </a>
<a name="ln73">	void Delete(Volume* volume)</a>
<a name="ln74">	{</a>
<a name="ln75">		if (ops != NULL)</a>
<a name="ln76">			volume-&gt;GetFileSystem()-&gt;PutVNodeOps(ops);</a>
<a name="ln77">		delete this;</a>
<a name="ln78">	}</a>
<a name="ln79"> </a>
<a name="ln80">protected:	// should be private, but gcc 2.95.3 issues a warning</a>
<a name="ln81">	~VNode()</a>
<a name="ln82">	{</a>
<a name="ln83">		if (fileCache != NULL) {</a>
<a name="ln84">			ERROR((&quot;VNode %&quot; B_PRId64 &quot; still has a file cache!\n&quot;, id));</a>
<a name="ln85">			file_cache_delete(fileCache);</a>
<a name="ln86">		}</a>
<a name="ln87">	}</a>
<a name="ln88">};</a>
<a name="ln89"> </a>
<a name="ln90"> </a>
<a name="ln91">// VNodeHashDefinition</a>
<a name="ln92">struct Volume::VNodeHashDefinition {</a>
<a name="ln93">	typedef ino_t	KeyType;</a>
<a name="ln94">	typedef	VNode	ValueType;</a>
<a name="ln95"> </a>
<a name="ln96">	size_t HashKey(ino_t key) const</a>
<a name="ln97">		{ return (uint32)key ^ (uint32)(key &gt;&gt; 32); }</a>
<a name="ln98">	size_t Hash(const VNode* value) const</a>
<a name="ln99">		{ return HashKey(value-&gt;id); }</a>
<a name="ln100">	bool Compare(ino_t key, const VNode* value) const</a>
<a name="ln101">		{ return value-&gt;id == key; }</a>
<a name="ln102">	VNode*&amp; GetLink(VNode* value) const</a>
<a name="ln103">		{ return value-&gt;hash_link; }</a>
<a name="ln104">};</a>
<a name="ln105"> </a>
<a name="ln106"> </a>
<a name="ln107">// VNodeMap</a>
<a name="ln108">struct Volume::VNodeMap</a>
<a name="ln109">	: public BOpenHashTable&lt;VNodeHashDefinition&gt; {</a>
<a name="ln110">};</a>
<a name="ln111"> </a>
<a name="ln112"> </a>
<a name="ln113">// IORequestInfo</a>
<a name="ln114">struct Volume::IORequestInfo {</a>
<a name="ln115">	io_request*						request;</a>
<a name="ln116">	int32							id;</a>
<a name="ln117"> </a>
<a name="ln118">	IORequestInfo*					idLink;</a>
<a name="ln119">	IORequestInfo*					structLink;</a>
<a name="ln120"> </a>
<a name="ln121">	IORequestInfo(io_request* request, int32 id)</a>
<a name="ln122">		:</a>
<a name="ln123">		request(request),</a>
<a name="ln124">		id(id)</a>
<a name="ln125">	{</a>
<a name="ln126">	}</a>
<a name="ln127">};</a>
<a name="ln128"> </a>
<a name="ln129"> </a>
<a name="ln130">// IORequestIDHashDefinition</a>
<a name="ln131">struct Volume::IORequestIDHashDefinition {</a>
<a name="ln132">	typedef int32			KeyType;</a>
<a name="ln133">	typedef	IORequestInfo	ValueType;</a>
<a name="ln134"> </a>
<a name="ln135">	size_t HashKey(int32 key) const</a>
<a name="ln136">		{ return key; }</a>
<a name="ln137">	size_t Hash(const IORequestInfo* value) const</a>
<a name="ln138">		{ return HashKey(value-&gt;id); }</a>
<a name="ln139">	bool Compare(int32 key, const IORequestInfo* value) const</a>
<a name="ln140">		{ return value-&gt;id == key; }</a>
<a name="ln141">	IORequestInfo*&amp; GetLink(IORequestInfo* value) const</a>
<a name="ln142">		{ return value-&gt;idLink; }</a>
<a name="ln143">};</a>
<a name="ln144"> </a>
<a name="ln145"> </a>
<a name="ln146">// IORequestStructHashDefinition</a>
<a name="ln147">struct Volume::IORequestStructHashDefinition {</a>
<a name="ln148">	typedef io_request*		KeyType;</a>
<a name="ln149">	typedef	IORequestInfo	ValueType;</a>
<a name="ln150"> </a>
<a name="ln151">	size_t HashKey(io_request* key) const</a>
<a name="ln152">		{ return (size_t)(addr_t)key; }</a>
<a name="ln153">	size_t Hash(const IORequestInfo* value) const</a>
<a name="ln154">		{ return HashKey(value-&gt;request); }</a>
<a name="ln155">	bool Compare(io_request* key, const IORequestInfo* value) const</a>
<a name="ln156">		{ return value-&gt;request == key; }</a>
<a name="ln157">	IORequestInfo*&amp; GetLink(IORequestInfo* value) const</a>
<a name="ln158">		{ return value-&gt;structLink; }</a>
<a name="ln159">};</a>
<a name="ln160"> </a>
<a name="ln161"> </a>
<a name="ln162">// IORequestIDMap</a>
<a name="ln163">struct Volume::IORequestIDMap</a>
<a name="ln164">	: public BOpenHashTable&lt;IORequestIDHashDefinition&gt; {</a>
<a name="ln165">};</a>
<a name="ln166"> </a>
<a name="ln167"> </a>
<a name="ln168">// IORequestStructMap</a>
<a name="ln169">struct Volume::IORequestStructMap</a>
<a name="ln170">	: public BOpenHashTable&lt;IORequestStructHashDefinition&gt; {</a>
<a name="ln171">};</a>
<a name="ln172"> </a>
<a name="ln173"> </a>
<a name="ln174">// IterativeFDIOCookie</a>
<a name="ln175">struct Volume::IterativeFDIOCookie : public BReferenceable {</a>
<a name="ln176">	Volume*				volume;</a>
<a name="ln177">	int					fd;</a>
<a name="ln178">	int32				requestID;</a>
<a name="ln179">	void*				clientCookie;</a>
<a name="ln180">	off_t				offset;</a>
<a name="ln181">	const file_io_vec*	vecs;</a>
<a name="ln182">	uint32				vecCount;</a>
<a name="ln183"> </a>
<a name="ln184">	IterativeFDIOCookie(Volume* volume, int fd, int32 requestID,</a>
<a name="ln185">		void* clientCookie, off_t offset, const file_io_vec* vecs,</a>
<a name="ln186">		uint32 vecCount)</a>
<a name="ln187">		:</a>
<a name="ln188">		volume(volume),</a>
<a name="ln189">		fd(fd),</a>
<a name="ln190">		requestID(requestID),</a>
<a name="ln191">		clientCookie(clientCookie),</a>
<a name="ln192">		offset(offset),</a>
<a name="ln193">		vecs(vecs),</a>
<a name="ln194">		vecCount(vecCount)</a>
<a name="ln195">	{</a>
<a name="ln196">	}</a>
<a name="ln197"> </a>
<a name="ln198">	~IterativeFDIOCookie()</a>
<a name="ln199">	{</a>
<a name="ln200">		if (fd &gt;= 0)</a>
<a name="ln201">			close(fd);</a>
<a name="ln202">	}</a>
<a name="ln203">};</a>
<a name="ln204"> </a>
<a name="ln205"> </a>
<a name="ln206">// AutoIncrementer</a>
<a name="ln207">class Volume::AutoIncrementer {</a>
<a name="ln208">public:</a>
<a name="ln209">	AutoIncrementer(int32* variable)</a>
<a name="ln210">		: fVariable(variable)</a>
<a name="ln211">	{</a>
<a name="ln212">		if (fVariable)</a>
<a name="ln213">			atomic_add(fVariable, 1);</a>
<a name="ln214">	}</a>
<a name="ln215"> </a>
<a name="ln216">	~AutoIncrementer()</a>
<a name="ln217">	{</a>
<a name="ln218">		if (fVariable)</a>
<a name="ln219">			atomic_add(fVariable, -1);</a>
<a name="ln220">	}</a>
<a name="ln221"> </a>
<a name="ln222">	void Keep()</a>
<a name="ln223">	{</a>
<a name="ln224">		fVariable = NULL;</a>
<a name="ln225">	}</a>
<a name="ln226"> </a>
<a name="ln227">private:</a>
<a name="ln228">	int32*	fVariable;</a>
<a name="ln229">};</a>
<a name="ln230"> </a>
<a name="ln231"> </a>
<a name="ln232">// IORequestRemover</a>
<a name="ln233">class Volume::IORequestRemover {</a>
<a name="ln234">public:</a>
<a name="ln235">	IORequestRemover(Volume* volume, int32 requestID)</a>
<a name="ln236">		:</a>
<a name="ln237">		fVolume(volume),</a>
<a name="ln238">		fRequestID(requestID)</a>
<a name="ln239">	{</a>
<a name="ln240">	}</a>
<a name="ln241"> </a>
<a name="ln242">	~IORequestRemover()</a>
<a name="ln243">	{</a>
<a name="ln244">		if (fVolume != NULL)</a>
<a name="ln245">			fVolume-&gt;_UnregisterIORequest(fRequestID);</a>
<a name="ln246">	}</a>
<a name="ln247"> </a>
<a name="ln248">	void Detach()</a>
<a name="ln249">	{</a>
<a name="ln250">		fVolume = NULL;</a>
<a name="ln251">	}</a>
<a name="ln252"> </a>
<a name="ln253">private:</a>
<a name="ln254">	Volume*	fVolume;</a>
<a name="ln255">	int32	fRequestID;</a>
<a name="ln256">};</a>
<a name="ln257"> </a>
<a name="ln258"> </a>
<a name="ln259">// VNodeRemover</a>
<a name="ln260">class Volume::VNodeRemover {</a>
<a name="ln261">public:</a>
<a name="ln262">	VNodeRemover(Volume* volume, VNode* node)</a>
<a name="ln263">		:</a>
<a name="ln264">		fVolume(volume),</a>
<a name="ln265">		fNode(node)</a>
<a name="ln266">	{</a>
<a name="ln267">	}</a>
<a name="ln268"> </a>
<a name="ln269">	~VNodeRemover()</a>
<a name="ln270">	{</a>
<a name="ln271">		if (fNode != NULL) {</a>
<a name="ln272">			MutexLocker locker(fVolume-&gt;fLock);</a>
<a name="ln273">			fVolume-&gt;fVNodes-&gt;Remove(fNode);</a>
<a name="ln274">			locker.Unlock();</a>
<a name="ln275"> </a>
<a name="ln276">			fNode-&gt;Delete(fVolume);</a>
<a name="ln277">		}</a>
<a name="ln278">	}</a>
<a name="ln279"> </a>
<a name="ln280">private:</a>
<a name="ln281">	Volume*	fVolume;</a>
<a name="ln282">	VNode*	fNode;</a>
<a name="ln283">};</a>
<a name="ln284"> </a>
<a name="ln285"> </a>
<a name="ln286">// HasVNodeCapability</a>
<a name="ln287">inline bool</a>
<a name="ln288">Volume::HasVNodeCapability(VNode* vnode, int capability) const</a>
<a name="ln289">{</a>
<a name="ln290">	return vnode-&gt;ops-&gt;capabilities.Get(capability);</a>
<a name="ln291">}</a>
<a name="ln292"> </a>
<a name="ln293"> </a>
<a name="ln294">// constructor</a>
<a name="ln295">Volume::Volume(FileSystem* fileSystem, fs_volume* fsVolume)</a>
<a name="ln296">	:</a>
<a name="ln297">	BReferenceable(),</a>
<a name="ln298">	fFileSystem(fileSystem),</a>
<a name="ln299">	fFSVolume(fsVolume),</a>
<a name="ln300">	fUserlandVolume(NULL),</a>
<a name="ln301">	fRootID(0),</a>
<a name="ln302">	fRootNode(NULL),</a>
<a name="ln303">	fOpenFiles(0),</a>
<a name="ln304">	fOpenDirectories(0),</a>
<a name="ln305">	fOpenAttributeDirectories(0),</a>
<a name="ln306">	fOpenAttributes(0),</a>
<a name="ln307">	fOpenIndexDirectories(0),</a>
<a name="ln308">	fOpenQueries(0),</a>
<a name="ln309">	fVNodes(NULL),</a>
<a name="ln310">	fIORequestInfosByID(NULL),</a>
<a name="ln311">	fIORequestInfosByStruct(NULL),</a>
<a name="ln312">	fLastIORequestID(0),</a>
<a name="ln313">	fVNodeCountingEnabled(false)</a>
<a name="ln314">{</a>
<a name="ln315">	mutex_init(&amp;fLock, &quot;userlandfs volume&quot;);</a>
<a name="ln316">}</a>
<a name="ln317"> </a>
<a name="ln318"> </a>
<a name="ln319">// destructor</a>
<a name="ln320">Volume::~Volume()</a>
<a name="ln321">{</a>
<a name="ln322">	mutex_destroy(&amp;fLock);</a>
<a name="ln323"> </a>
<a name="ln324">	delete fIORequestInfosByID;</a>
<a name="ln325">	delete fIORequestInfosByStruct;</a>
<a name="ln326">	delete fVNodes;</a>
<a name="ln327">}</a>
<a name="ln328"> </a>
<a name="ln329"> </a>
<a name="ln330">// #pragma mark - client methods</a>
<a name="ln331"> </a>
<a name="ln332">// GetVNode</a>
<a name="ln333">status_t</a>
<a name="ln334">Volume::GetVNode(ino_t vnid, void** _node)</a>
<a name="ln335">{</a>
<a name="ln336">	PRINT((&quot;get_vnode(%&quot; B_PRId32 &quot;, %&quot; B_PRId64 &quot;)\n&quot;, GetID(), vnid));</a>
<a name="ln337">	void* vnode;</a>
<a name="ln338">	status_t error = get_vnode(fFSVolume, vnid, &amp;vnode);</a>
<a name="ln339">	if (error == B_OK) {</a>
<a name="ln340">		_IncrementVNodeCount(vnid);</a>
<a name="ln341">		*_node = ((VNode*)vnode)-&gt;clientNode;</a>
<a name="ln342">	}</a>
<a name="ln343"> </a>
<a name="ln344">	return error;</a>
<a name="ln345">}</a>
<a name="ln346"> </a>
<a name="ln347">// PutVNode</a>
<a name="ln348">status_t</a>
<a name="ln349">Volume::PutVNode(ino_t vnid)</a>
<a name="ln350">{</a>
<a name="ln351">	PRINT((&quot;put_vnode(%&quot; B_PRId32 &quot;, %&quot; B_PRId64 &quot;)\n&quot;, GetID(), vnid));</a>
<a name="ln352">	// Decrement the count first. We might not have another chance, since</a>
<a name="ln353">	// put_vnode() could put the last reference, thus causing the node to be</a>
<a name="ln354">	// removed from our map. This is all not very dramatic, but this way we</a>
<a name="ln355">	// avoid an erroneous error message from _DecrementVNodeCount().</a>
<a name="ln356">	_DecrementVNodeCount(vnid);</a>
<a name="ln357"> </a>
<a name="ln358">	return put_vnode(fFSVolume, vnid);</a>
<a name="ln359">}</a>
<a name="ln360"> </a>
<a name="ln361"> </a>
<a name="ln362">// AcquireVNode</a>
<a name="ln363">status_t</a>
<a name="ln364">Volume::AcquireVNode(ino_t vnid)</a>
<a name="ln365">{</a>
<a name="ln366">	PRINT((&quot;acquire_vnode(%&quot; B_PRId32 &quot;, %&quot; B_PRId64 &quot;)\n&quot;, GetID(), vnid));</a>
<a name="ln367">	status_t error = acquire_vnode(fFSVolume, vnid);</a>
<a name="ln368">	if (error == B_OK)</a>
<a name="ln369">		_IncrementVNodeCount(vnid);</a>
<a name="ln370">	return error;</a>
<a name="ln371">}</a>
<a name="ln372"> </a>
<a name="ln373"> </a>
<a name="ln374">// NewVNode</a>
<a name="ln375">status_t</a>
<a name="ln376">Volume::NewVNode(ino_t vnid, void* clientNode,</a>
<a name="ln377">	const FSVNodeCapabilities&amp; capabilities)</a>
<a name="ln378">{</a>
<a name="ln379">	PRINT((&quot;new_vnode(%&quot; B_PRId32 &quot;, %&quot; B_PRId64 &quot;)\n&quot;, GetID(), vnid));</a>
<a name="ln380">	// lookup the node</a>
<a name="ln381">	MutexLocker locker(fLock);</a>
<a name="ln382">	VNode* node = fVNodes-&gt;Lookup(vnid);</a>
<a name="ln383">	if (node != NULL) {</a>
<a name="ln384">		// The node is already known -- this is an error.</a>
<a name="ln385">		RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln386">	}</a>
<a name="ln387"> </a>
<a name="ln388">	// get the ops vector for the node</a>
<a name="ln389">	VNodeOps* ops = fFileSystem-&gt;GetVNodeOps(capabilities);</a>
<a name="ln390">	if (ops == NULL)</a>
<a name="ln391">		RETURN_ERROR(B_NO_MEMORY);</a>
<a name="ln392"> </a>
<a name="ln393">	// create the node</a>
<a name="ln394">	node = new(std::nothrow) VNode(vnid, clientNode, ops);</a>
<a name="ln395">	if (node == NULL) {</a>
<a name="ln396">		fFileSystem-&gt;PutVNodeOps(ops);</a>
<a name="ln397">		RETURN_ERROR(B_NO_MEMORY);</a>
<a name="ln398">	}</a>
<a name="ln399"> </a>
<a name="ln400">	node-&gt;published = false;</a>
<a name="ln401"> </a>
<a name="ln402">	locker.Unlock();</a>
<a name="ln403"> </a>
<a name="ln404">	// tell the VFS</a>
<a name="ln405">	status_t error = new_vnode(fFSVolume, vnid, node, node-&gt;ops-&gt;ops);</a>
<a name="ln406">	if (error != B_OK) {</a>
<a name="ln407">		node-&gt;Delete(this);</a>
<a name="ln408">		RETURN_ERROR(error);</a>
<a name="ln409">	}</a>
<a name="ln410"> </a>
<a name="ln411">	// add the node to our map</a>
<a name="ln412">	locker.Lock();</a>
<a name="ln413">	fVNodes-&gt;Insert(node);</a>
<a name="ln414"> </a>
<a name="ln415">	// Increment its use count. After new_vnode() the caller has a reference,</a>
<a name="ln416">	// but a subsequent publish_vnode() won't get another one. We handle that</a>
<a name="ln417">	// there.</a>
<a name="ln418">	if (fVNodeCountingEnabled)</a>
<a name="ln419">		node-&gt;useCount++;</a>
<a name="ln420"> </a>
<a name="ln421">	return B_OK;</a>
<a name="ln422">}</a>
<a name="ln423"> </a>
<a name="ln424">// PublishVNode</a>
<a name="ln425">status_t</a>
<a name="ln426">Volume::PublishVNode(ino_t vnid, void* clientNode, int type, uint32 flags,</a>
<a name="ln427">	const FSVNodeCapabilities&amp; capabilities)</a>
<a name="ln428">{</a>
<a name="ln429">	PRINT((&quot;publish_vnode(%&quot; B_PRId32 &quot;, %&quot; B_PRId64 &quot;, %p)\n&quot;, GetID(), vnid,</a>
<a name="ln430">		clientNode));</a>
<a name="ln431"> </a>
<a name="ln432">	// lookup the node</a>
<a name="ln433">	MutexLocker locker(fLock);</a>
<a name="ln434">	VNode* node = fVNodes-&gt;Lookup(vnid);</a>
<a name="ln435">	bool nodeKnown = node != NULL;</a>
<a name="ln436"> </a>
<a name="ln437">	if (nodeKnown) {</a>
<a name="ln438">		if (node-&gt;published) {</a>
<a name="ln439">			WARN((&quot;publish_vnode(): vnode (%&quot; B_PRId32 &quot;, %&quot; B_PRId64</a>
<a name="ln440">				&quot;) already published!\n&quot;, GetID(), vnid));</a>
<a name="ln441">			RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln442">		}</a>
<a name="ln443">	} else if (!nodeKnown) {</a>
<a name="ln444">		// The node is not yet known -- create it.</a>
<a name="ln445"> </a>
<a name="ln446">		// get the ops vector for the node</a>
<a name="ln447">		VNodeOps* ops = fFileSystem-&gt;GetVNodeOps(capabilities);</a>
<a name="ln448">		if (ops == NULL)</a>
<a name="ln449">			RETURN_ERROR(B_NO_MEMORY);</a>
<a name="ln450"> </a>
<a name="ln451">		// create the node</a>
<a name="ln452">		node = new(std::nothrow) VNode(vnid, clientNode, ops);</a>
<a name="ln453">		if (node == NULL) {</a>
<a name="ln454">			fFileSystem-&gt;PutVNodeOps(ops);</a>
<a name="ln455">			RETURN_ERROR(B_NO_MEMORY);</a>
<a name="ln456">		}</a>
<a name="ln457">	}</a>
<a name="ln458"> </a>
<a name="ln459">	locker.Unlock();</a>
<a name="ln460"> </a>
<a name="ln461">	// tell the VFS</a>
<a name="ln462">	status_t error = publish_vnode(fFSVolume, vnid, node, node-&gt;ops-&gt;ops,</a>
<a name="ln463">		type, flags);</a>
<a name="ln464">	if (error != B_OK) {</a>
<a name="ln465">		if (nodeKnown) {</a>
<a name="ln466">			// The node was known, i.e. it had been made known via new_vnode()</a>
<a name="ln467">			// and thus already had a use count of 1. Decrement that use count</a>
<a name="ln468">			// and remove the node completely.</a>
<a name="ln469">			_DecrementVNodeCount(vnid);</a>
<a name="ln470">			_RemoveInvalidVNode(vnid);</a>
<a name="ln471">		} else</a>
<a name="ln472">			node-&gt;Delete(this);</a>
<a name="ln473">		RETURN_ERROR(error);</a>
<a name="ln474">	}</a>
<a name="ln475"> </a>
<a name="ln476">	// add the node to our map, if not known yet</a>
<a name="ln477">	locker.Lock();</a>
<a name="ln478">	if (nodeKnown) {</a>
<a name="ln479">		// The node is now published. Don't increment its use count. It already</a>
<a name="ln480">		// has 1 from new_vnode() and this publish_vnode() didn't increment it.</a>
<a name="ln481">		node-&gt;published = true;</a>
<a name="ln482">	} else {</a>
<a name="ln483">		// New node: increment its use count and add it to the map.</a>
<a name="ln484">		if (fVNodeCountingEnabled)</a>
<a name="ln485">			node-&gt;useCount++;</a>
<a name="ln486">		fVNodes-&gt;Insert(node);</a>
<a name="ln487">	}</a>
<a name="ln488"> </a>
<a name="ln489">	return B_OK;</a>
<a name="ln490">}</a>
<a name="ln491"> </a>
<a name="ln492">// RemoveVNode</a>
<a name="ln493">status_t</a>
<a name="ln494">Volume::RemoveVNode(ino_t vnid)</a>
<a name="ln495">{</a>
<a name="ln496">	PRINT((&quot;remove_vnode(%&quot; B_PRId32 &quot;, %&quot; B_PRId64 &quot;)\n&quot;, GetID(), vnid));</a>
<a name="ln497">	return remove_vnode(fFSVolume, vnid);</a>
<a name="ln498">}</a>
<a name="ln499"> </a>
<a name="ln500">// UnremoveVNode</a>
<a name="ln501">status_t</a>
<a name="ln502">Volume::UnremoveVNode(ino_t vnid)</a>
<a name="ln503">{</a>
<a name="ln504">	PRINT((&quot;unremove_vnode(%&quot; B_PRId32 &quot;, %&quot; B_PRId64 &quot;)\n&quot;, GetID(), vnid));</a>
<a name="ln505">	return unremove_vnode(fFSVolume, vnid);</a>
<a name="ln506">}</a>
<a name="ln507"> </a>
<a name="ln508">// GetVNodeRemoved</a>
<a name="ln509">status_t</a>
<a name="ln510">Volume::GetVNodeRemoved(ino_t vnid, bool* removed)</a>
<a name="ln511">{</a>
<a name="ln512">	PRINT((&quot;get_vnode_removed(%&quot; B_PRId32 &quot;, %&quot; B_PRId64 &quot;, %p)\n&quot;, GetID(),</a>
<a name="ln513">		vnid, removed));</a>
<a name="ln514">	return get_vnode_removed(fFSVolume, vnid, removed);</a>
<a name="ln515">}</a>
<a name="ln516"> </a>
<a name="ln517"> </a>
<a name="ln518">// CreateFileCache</a>
<a name="ln519">status_t</a>
<a name="ln520">Volume::CreateFileCache(ino_t vnodeID, off_t size)</a>
<a name="ln521">{</a>
<a name="ln522">	// lookup the node</a>
<a name="ln523">	MutexLocker locker(fLock);</a>
<a name="ln524">	VNode* vnode = fVNodes-&gt;Lookup(vnodeID);</a>
<a name="ln525">	if (vnode == NULL)</a>
<a name="ln526">		RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln527"> </a>
<a name="ln528">	// does the node already have a file cache?</a>
<a name="ln529">	if (vnode-&gt;fileCache != NULL)</a>
<a name="ln530">		RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln531"> </a>
<a name="ln532">	// create the file cache</a>
<a name="ln533">	locker.Unlock();</a>
<a name="ln534">	void* fileCache = file_cache_create(GetID(), vnodeID, size);</a>
<a name="ln535">	locker.Lock();</a>
<a name="ln536"> </a>
<a name="ln537">	// re-check whether the node still lives</a>
<a name="ln538">	vnode = fVNodes-&gt;Lookup(vnodeID);</a>
<a name="ln539">	if (vnode == NULL) {</a>
<a name="ln540">		file_cache_delete(fileCache);</a>
<a name="ln541">		RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln542">	}</a>
<a name="ln543"> </a>
<a name="ln544">	vnode-&gt;fileCache = fileCache;</a>
<a name="ln545"> </a>
<a name="ln546">	return B_OK;</a>
<a name="ln547">}</a>
<a name="ln548"> </a>
<a name="ln549"> </a>
<a name="ln550">// DeleteFileCache</a>
<a name="ln551">status_t</a>
<a name="ln552">Volume::DeleteFileCache(ino_t vnodeID)</a>
<a name="ln553">{</a>
<a name="ln554">	// lookup the node</a>
<a name="ln555">	MutexLocker locker(fLock);</a>
<a name="ln556">	VNode* vnode = fVNodes-&gt;Lookup(vnodeID);</a>
<a name="ln557">	if (vnode == NULL)</a>
<a name="ln558">		RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln559"> </a>
<a name="ln560">	// does the node have a file cache</a>
<a name="ln561">	if (vnode-&gt;fileCache == NULL)</a>
<a name="ln562">		RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln563"> </a>
<a name="ln564">	void* fileCache = vnode-&gt;fileCache;</a>
<a name="ln565">	vnode-&gt;fileCache = NULL;</a>
<a name="ln566"> </a>
<a name="ln567">	locker.Unlock();</a>
<a name="ln568"> </a>
<a name="ln569">	file_cache_delete(fileCache);</a>
<a name="ln570"> </a>
<a name="ln571">	return B_OK;</a>
<a name="ln572">}</a>
<a name="ln573"> </a>
<a name="ln574"> </a>
<a name="ln575">// SetFileCacheEnabled</a>
<a name="ln576">status_t</a>
<a name="ln577">Volume::SetFileCacheEnabled(ino_t vnodeID, bool enabled)</a>
<a name="ln578">{</a>
<a name="ln579">	// lookup the node</a>
<a name="ln580">	MutexLocker locker(fLock);</a>
<a name="ln581">	VNode* vnode = fVNodes-&gt;Lookup(vnodeID);</a>
<a name="ln582">	if (vnode == NULL)</a>
<a name="ln583">		RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln584"> </a>
<a name="ln585">	// does the node have a file cache</a>
<a name="ln586">	if (vnode-&gt;fileCache == NULL)</a>
<a name="ln587">		RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln588"> </a>
<a name="ln589">	void* fileCache = vnode-&gt;fileCache;</a>
<a name="ln590">	locker.Unlock();</a>
<a name="ln591">// TODO: We should use some kind of ref counting to avoid that another thread</a>
<a name="ln592">// deletes the file cache now that we have dropped the lock. Applies to the</a>
<a name="ln593">// other file cache operations as well.</a>
<a name="ln594"> </a>
<a name="ln595">	// enable/disable the file cache</a>
<a name="ln596">	if (enabled) {</a>
<a name="ln597">		file_cache_enable(fileCache);</a>
<a name="ln598">		return B_OK;</a>
<a name="ln599">	}</a>
<a name="ln600"> </a>
<a name="ln601">	return file_cache_disable(fileCache);</a>
<a name="ln602">}</a>
<a name="ln603"> </a>
<a name="ln604"> </a>
<a name="ln605">// SetFileCacheSize</a>
<a name="ln606">status_t</a>
<a name="ln607">Volume::SetFileCacheSize(ino_t vnodeID, off_t size)</a>
<a name="ln608">{</a>
<a name="ln609">	// lookup the node</a>
<a name="ln610">	MutexLocker locker(fLock);</a>
<a name="ln611">	VNode* vnode = fVNodes-&gt;Lookup(vnodeID);</a>
<a name="ln612">	if (vnode == NULL)</a>
<a name="ln613">		RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln614"> </a>
<a name="ln615">	// does the node have a file cache</a>
<a name="ln616">	if (vnode-&gt;fileCache == NULL)</a>
<a name="ln617">		RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln618"> </a>
<a name="ln619">	void* fileCache = vnode-&gt;fileCache;</a>
<a name="ln620">	locker.Unlock();</a>
<a name="ln621"> </a>
<a name="ln622">	// set the size</a>
<a name="ln623">	return file_cache_set_size(fileCache, size);</a>
<a name="ln624">}</a>
<a name="ln625"> </a>
<a name="ln626"> </a>
<a name="ln627">// SyncFileCache</a>
<a name="ln628">status_t</a>
<a name="ln629">Volume::SyncFileCache(ino_t vnodeID)</a>
<a name="ln630">{</a>
<a name="ln631">	// lookup the node</a>
<a name="ln632">	MutexLocker locker(fLock);</a>
<a name="ln633">	VNode* vnode = fVNodes-&gt;Lookup(vnodeID);</a>
<a name="ln634">	if (vnode == NULL)</a>
<a name="ln635">		RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln636"> </a>
<a name="ln637">	// does the node have a file cache</a>
<a name="ln638">	if (vnode-&gt;fileCache == NULL)</a>
<a name="ln639">		RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln640"> </a>
<a name="ln641">	void* fileCache = vnode-&gt;fileCache;</a>
<a name="ln642">	locker.Unlock();</a>
<a name="ln643"> </a>
<a name="ln644">	// sync</a>
<a name="ln645">	return file_cache_sync(fileCache);</a>
<a name="ln646">}</a>
<a name="ln647"> </a>
<a name="ln648"> </a>
<a name="ln649">// ReadFileCache</a>
<a name="ln650">status_t</a>
<a name="ln651">Volume::ReadFileCache(ino_t vnodeID, void* cookie,</a>
<a name="ln652">	off_t offset, void* buffer, size_t* _size)</a>
<a name="ln653">{</a>
<a name="ln654">	// lookup the node</a>
<a name="ln655">	MutexLocker locker(fLock);</a>
<a name="ln656">	VNode* vnode = fVNodes-&gt;Lookup(vnodeID);</a>
<a name="ln657">	if (vnode == NULL)</a>
<a name="ln658">		RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln659"> </a>
<a name="ln660">	// does the node have a file cache</a>
<a name="ln661">	if (vnode-&gt;fileCache == NULL)</a>
<a name="ln662">		RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln663"> </a>
<a name="ln664">	void* fileCache = vnode-&gt;fileCache;</a>
<a name="ln665">	locker.Unlock();</a>
<a name="ln666"> </a>
<a name="ln667">	// read</a>
<a name="ln668">	return file_cache_read(fileCache, cookie, offset, buffer, _size);</a>
<a name="ln669">}</a>
<a name="ln670"> </a>
<a name="ln671"> </a>
<a name="ln672">// WriteFileCache</a>
<a name="ln673">status_t</a>
<a name="ln674">Volume::WriteFileCache(ino_t vnodeID, void* cookie,</a>
<a name="ln675">	off_t offset, const void* buffer, size_t* _size)</a>
<a name="ln676">{</a>
<a name="ln677">	// lookup the node</a>
<a name="ln678">	MutexLocker locker(fLock);</a>
<a name="ln679">	VNode* vnode = fVNodes-&gt;Lookup(vnodeID);</a>
<a name="ln680">	if (vnode == NULL)</a>
<a name="ln681">		RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln682"> </a>
<a name="ln683">	// does the node have a file cache</a>
<a name="ln684">	if (vnode-&gt;fileCache == NULL)</a>
<a name="ln685">		RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln686"> </a>
<a name="ln687">	void* fileCache = vnode-&gt;fileCache;</a>
<a name="ln688">	locker.Unlock();</a>
<a name="ln689"> </a>
<a name="ln690">	// read</a>
<a name="ln691">	return file_cache_write(fileCache, cookie, offset, buffer, _size);</a>
<a name="ln692">}</a>
<a name="ln693"> </a>
<a name="ln694"> </a>
<a name="ln695">status_t</a>
<a name="ln696">Volume::ReadFromIORequest(int32 requestID, void* buffer, size_t size)</a>
<a name="ln697">{</a>
<a name="ln698">	// get the request</a>
<a name="ln699">	io_request* request;</a>
<a name="ln700">	status_t error = _FindIORequest(requestID, &amp;request);</a>
<a name="ln701">	if (error != B_OK)</a>
<a name="ln702">		RETURN_ERROR(error);</a>
<a name="ln703"> </a>
<a name="ln704">	return read_from_io_request(request, buffer, size);</a>
<a name="ln705">}</a>
<a name="ln706"> </a>
<a name="ln707"> </a>
<a name="ln708">status_t</a>
<a name="ln709">Volume::WriteToIORequest(int32 requestID, const void* buffer, size_t size)</a>
<a name="ln710">{</a>
<a name="ln711">	// get the request</a>
<a name="ln712">	io_request* request;</a>
<a name="ln713">	status_t error = _FindIORequest(requestID, &amp;request);</a>
<a name="ln714">	if (error != B_OK)</a>
<a name="ln715">		RETURN_ERROR(error);</a>
<a name="ln716"> </a>
<a name="ln717">	return write_to_io_request(request, buffer, size);</a>
<a name="ln718">}</a>
<a name="ln719"> </a>
<a name="ln720"> </a>
<a name="ln721">// DoIterativeFDIO</a>
<a name="ln722">status_t</a>
<a name="ln723">Volume::DoIterativeFDIO(int fd, int32 requestID, void* clientCookie,</a>
<a name="ln724">	const file_io_vec* vecs, uint32 vecCount)</a>
<a name="ln725">{</a>
<a name="ln726">	// get the request</a>
<a name="ln727">	io_request* request;</a>
<a name="ln728">	status_t error = _FindIORequest(requestID, &amp;request);</a>
<a name="ln729">	if (error != B_OK)</a>
<a name="ln730">		RETURN_ERROR(error);</a>
<a name="ln731"> </a>
<a name="ln732">	// copy the FD into the kernel</a>
<a name="ln733">	fd = dup_foreign_fd(fFileSystem-&gt;GetTeam(), fd, true);</a>
<a name="ln734">	if (fd &lt; 0)</a>
<a name="ln735">		RETURN_ERROR(fd);</a>
<a name="ln736"> </a>
<a name="ln737">	// create a cookie</a>
<a name="ln738">	IterativeFDIOCookie* cookie = new(std::nothrow) IterativeFDIOCookie(</a>
<a name="ln739">		this, fd, requestID, clientCookie, request-&gt;Offset(), vecs, vecCount);</a>
<a name="ln740">	if (cookie == NULL) {</a>
<a name="ln741">		close(fd);</a>
<a name="ln742">		RETURN_ERROR(B_NO_MEMORY);</a>
<a name="ln743">	}</a>
<a name="ln744"> </a>
<a name="ln745">	// we need another reference, so we can still access the cookie below</a>
<a name="ln746">	cookie-&gt;AcquireReference();</a>
<a name="ln747"> </a>
<a name="ln748">// TODO: Up to this point we're responsible for calling the finished hook on</a>
<a name="ln749">// error!</a>
<a name="ln750">	// call the kernel function</a>
<a name="ln751">	error = do_iterative_fd_io(fd, request, &amp;_IterativeFDIOGetVecs,</a>
<a name="ln752">		&amp;_IterativeFDIOFinished, cookie);</a>
<a name="ln753"> </a>
<a name="ln754">	// unset the vecs -- they are on the stack an will become invalid when we</a>
<a name="ln755">	// return</a>
<a name="ln756">	MutexLocker _(fLock);</a>
<a name="ln757">	cookie-&gt;vecs = NULL;</a>
<a name="ln758">	cookie-&gt;vecCount = 0;</a>
<a name="ln759">	cookie-&gt;ReleaseReference();</a>
<a name="ln760"> </a>
<a name="ln761">	return error;</a>
<a name="ln762">}</a>
<a name="ln763"> </a>
<a name="ln764"> </a>
<a name="ln765">status_t</a>
<a name="ln766">Volume::NotifyIORequest(int32 requestID, status_t status)</a>
<a name="ln767">{</a>
<a name="ln768">	// get the request</a>
<a name="ln769">	io_request* request;</a>
<a name="ln770">	status_t error = _FindIORequest(requestID, &amp;request);</a>
<a name="ln771">	if (error != B_OK)</a>
<a name="ln772">		RETURN_ERROR(error);</a>
<a name="ln773"> </a>
<a name="ln774">	notify_io_request(request, status);</a>
<a name="ln775">	return B_OK;</a>
<a name="ln776">}</a>
<a name="ln777"> </a>
<a name="ln778"> </a>
<a name="ln779">// #pragma mark - FS</a>
<a name="ln780"> </a>
<a name="ln781"> </a>
<a name="ln782">// Mount</a>
<a name="ln783">status_t</a>
<a name="ln784">Volume::Mount(const char* device, uint32 flags, const char* parameters)</a>
<a name="ln785">{</a>
<a name="ln786">	// create the maps</a>
<a name="ln787">	fVNodes = new(std::nothrow) VNodeMap;</a>
<a name="ln788">	fIORequestInfosByID = new(std::nothrow) IORequestIDMap;</a>
<a name="ln789">	fIORequestInfosByStruct = new(std::nothrow) IORequestStructMap;</a>
<a name="ln790"> </a>
<a name="ln791">	if (fVNodes == NULL || fIORequestInfosByID == NULL</a>
<a name="ln792">		|| fIORequestInfosByStruct == NULL</a>
<a name="ln793">		|| fVNodes-&gt;Init() != B_OK</a>
<a name="ln794">		|| fIORequestInfosByID-&gt;Init() != B_OK</a>
<a name="ln795">		|| fIORequestInfosByStruct-&gt;Init() != B_OK) {</a>
<a name="ln796">		return B_NO_MEMORY;</a>
<a name="ln797">	}</a>
<a name="ln798"> </a>
<a name="ln799">	// enable vnode counting</a>
<a name="ln800">	fVNodeCountingEnabled = true;</a>
<a name="ln801"> </a>
<a name="ln802">	// init IORequest ID's</a>
<a name="ln803">	fLastIORequestID = 0;</a>
<a name="ln804"> </a>
<a name="ln805">	// mount</a>
<a name="ln806">	status_t error = _Mount(device, flags, parameters);</a>
<a name="ln807">	if (error != B_OK)</a>
<a name="ln808">		RETURN_ERROR(error);</a>
<a name="ln809"> </a>
<a name="ln810">	MutexLocker locker(fLock);</a>
<a name="ln811">	// fetch the root node, so that we can serve Walk() requests on it,</a>
<a name="ln812">	// after the connection to the userland server is gone</a>
<a name="ln813">	fRootNode = fVNodes-&gt;Lookup(fRootID);</a>
<a name="ln814">	if (fRootNode == NULL) {</a>
<a name="ln815">		// The root node was not added while mounting. That's a serious</a>
<a name="ln816">		// problem -- not only because we don't have it, but also because</a>
<a name="ln817">		// the VFS requires publish_vnode() to be invoked for the root node.</a>
<a name="ln818">		ERROR((&quot;Volume::Mount(): new_vnode() was not called for root node! &quot;</a>
<a name="ln819">			&quot;Unmounting...\n&quot;));</a>
<a name="ln820">		locker.Unlock();</a>
<a name="ln821">		Unmount();</a>
<a name="ln822">		return B_ERROR;</a>
<a name="ln823">	}</a>
<a name="ln824"> </a>
<a name="ln825">	// Decrement the root node use count. The publish_vnode() the client FS</a>
<a name="ln826">	// did will be balanced by the VFS.</a>
<a name="ln827">	if (fVNodeCountingEnabled)</a>
<a name="ln828">		fRootNode-&gt;useCount--;</a>
<a name="ln829"> </a>
<a name="ln830">	// init the volume ops vector we'll give the VFS</a>
<a name="ln831">	_InitVolumeOps();</a>
<a name="ln832"> </a>
<a name="ln833">	return B_OK;</a>
<a name="ln834">}</a>
<a name="ln835"> </a>
<a name="ln836">// Unmount</a>
<a name="ln837">status_t</a>
<a name="ln838">Volume::Unmount()</a>
<a name="ln839">{</a>
<a name="ln840">	status_t error = _Unmount();</a>
<a name="ln841"> </a>
<a name="ln842">	// free the memory associated with the maps</a>
<a name="ln843">	{</a>
<a name="ln844">		// vnodes</a>
<a name="ln845">		MutexLocker _(fLock);</a>
<a name="ln846">		if (fVNodes != NULL) {</a>
<a name="ln847">			VNode* node = fVNodes-&gt;Clear(true);</a>
<a name="ln848">			while (node != NULL) {</a>
<a name="ln849">				VNode* nextNode = node-&gt;hash_link;</a>
<a name="ln850">				node-&gt;Delete(this);</a>
<a name="ln851">				node = nextNode;</a>
<a name="ln852">			}</a>
<a name="ln853">			delete fVNodes;</a>
<a name="ln854">			fVNodes = NULL;</a>
<a name="ln855">		}</a>
<a name="ln856"> </a>
<a name="ln857">		// io request infos</a>
<a name="ln858">		if (fIORequestInfosByID != NULL) {</a>
<a name="ln859">			fIORequestInfosByID-&gt;Clear();</a>
<a name="ln860">			delete fIORequestInfosByID;</a>
<a name="ln861">			fIORequestInfosByID = NULL;</a>
<a name="ln862">		}</a>
<a name="ln863"> </a>
<a name="ln864">		if (fIORequestInfosByStruct != NULL) {</a>
<a name="ln865">			IORequestInfo* info = fIORequestInfosByStruct-&gt;Clear(true);</a>
<a name="ln866">			while (info != NULL) {</a>
<a name="ln867">				IORequestInfo* nextInfo = info-&gt;structLink;</a>
<a name="ln868">				delete info;</a>
<a name="ln869">				// TODO: We should probably also notify the request, if that</a>
<a name="ln870">				// hasn't happened yet.</a>
<a name="ln871">				info = nextInfo;</a>
<a name="ln872">			}</a>
<a name="ln873">			delete fIORequestInfosByStruct;</a>
<a name="ln874">			fIORequestInfosByStruct = NULL;</a>
<a name="ln875">		}</a>
<a name="ln876">	}</a>
<a name="ln877"> </a>
<a name="ln878">	fFileSystem-&gt;VolumeUnmounted(this);</a>
<a name="ln879">	return error;</a>
<a name="ln880">}</a>
<a name="ln881"> </a>
<a name="ln882">// Sync</a>
<a name="ln883">status_t</a>
<a name="ln884">Volume::Sync()</a>
<a name="ln885">{</a>
<a name="ln886">	// check capability</a>
<a name="ln887">	if (!HasCapability(FS_VOLUME_CAPABILITY_SYNC))</a>
<a name="ln888">		return B_BAD_VALUE;</a>
<a name="ln889"> </a>
<a name="ln890">	// get a free port</a>
<a name="ln891">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln892">	if (!port)</a>
<a name="ln893">		return B_ERROR;</a>
<a name="ln894">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln895"> </a>
<a name="ln896">	// prepare the request</a>
<a name="ln897">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln898">	SyncVolumeRequest* request;</a>
<a name="ln899">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln900">	if (error != B_OK)</a>
<a name="ln901">		return error;</a>
<a name="ln902"> </a>
<a name="ln903">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln904"> </a>
<a name="ln905">	// send the request</a>
<a name="ln906">	KernelRequestHandler handler(this, SYNC_VOLUME_REPLY);</a>
<a name="ln907">	SyncVolumeReply* reply;</a>
<a name="ln908">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln909">	if (error != B_OK)</a>
<a name="ln910">		return error;</a>
<a name="ln911">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln912"> </a>
<a name="ln913">	// process the reply</a>
<a name="ln914">	if (reply-&gt;error != B_OK)</a>
<a name="ln915">		return reply-&gt;error;</a>
<a name="ln916">	return error;</a>
<a name="ln917">}</a>
<a name="ln918"> </a>
<a name="ln919">// ReadFSInfo</a>
<a name="ln920">status_t</a>
<a name="ln921">Volume::ReadFSInfo(fs_info* info)</a>
<a name="ln922">{</a>
<a name="ln923">	// When the connection to the userland server is lost, we serve</a>
<a name="ln924">	// read_fs_info() requests manually.</a>
<a name="ln925">	status_t error = _ReadFSInfo(info);</a>
<a name="ln926">	if (error != B_OK &amp;&amp; fFileSystem-&gt;GetPortPool()-&gt;IsDisconnected()) {</a>
<a name="ln927">		WARN((&quot;Volume::ReadFSInfo(): connection lost, emulating lookup `.'\n&quot;));</a>
<a name="ln928"> </a>
<a name="ln929">		info-&gt;flags = B_FS_IS_PERSISTENT | B_FS_IS_READONLY;</a>
<a name="ln930">		info-&gt;block_size = 512;</a>
<a name="ln931">		info-&gt;io_size = 512;</a>
<a name="ln932">		info-&gt;total_blocks = 0;</a>
<a name="ln933">		info-&gt;free_blocks = 0;</a>
<a name="ln934">		strlcpy(info-&gt;volume_name, fFileSystem-&gt;GetName(),</a>
<a name="ln935">			sizeof(info-&gt;volume_name));</a>
<a name="ln936">		strlcat(info-&gt;volume_name, &quot;:disconnected&quot;, sizeof(info-&gt;volume_name));</a>
<a name="ln937"> </a>
<a name="ln938">		error = B_OK;</a>
<a name="ln939">	}</a>
<a name="ln940">	return error;</a>
<a name="ln941">}</a>
<a name="ln942"> </a>
<a name="ln943">// WriteFSInfo</a>
<a name="ln944">status_t</a>
<a name="ln945">Volume::WriteFSInfo(const struct fs_info *info, uint32 mask)</a>
<a name="ln946">{</a>
<a name="ln947">	// check capability</a>
<a name="ln948">	if (!HasCapability(FS_VOLUME_CAPABILITY_WRITE_FS_INFO))</a>
<a name="ln949">		return B_BAD_VALUE;</a>
<a name="ln950"> </a>
<a name="ln951">	// get a free port</a>
<a name="ln952">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln953">	if (!port)</a>
<a name="ln954">		return B_ERROR;</a>
<a name="ln955">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln956"> </a>
<a name="ln957">	// prepare the request</a>
<a name="ln958">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln959">	WriteFSInfoRequest* request;</a>
<a name="ln960">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln961">	if (error != B_OK)</a>
<a name="ln962">		return error;</a>
<a name="ln963"> </a>
<a name="ln964">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln965">	request-&gt;info = *info;</a>
<a name="ln966">	request-&gt;mask = mask;</a>
<a name="ln967"> </a>
<a name="ln968">	// send the request</a>
<a name="ln969">	KernelRequestHandler handler(this, WRITE_FS_INFO_REPLY);</a>
<a name="ln970">	WriteFSInfoReply* reply;</a>
<a name="ln971">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln972">	if (error != B_OK)</a>
<a name="ln973">		return error;</a>
<a name="ln974">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln975"> </a>
<a name="ln976">	// process the reply</a>
<a name="ln977">	if (reply-&gt;error != B_OK)</a>
<a name="ln978">		return reply-&gt;error;</a>
<a name="ln979">	return error;</a>
<a name="ln980">}</a>
<a name="ln981"> </a>
<a name="ln982"> </a>
<a name="ln983">// #pragma mark - vnodes</a>
<a name="ln984"> </a>
<a name="ln985"> </a>
<a name="ln986">// Lookup</a>
<a name="ln987">status_t</a>
<a name="ln988">Volume::Lookup(void* dir, const char* entryName, ino_t* vnid)</a>
<a name="ln989">{</a>
<a name="ln990">	// When the connection to the userland server is lost, we serve</a>
<a name="ln991">	// lookup(fRootNode, `.') requests manually to allow clean unmounting.</a>
<a name="ln992">	status_t error = _Lookup(dir, entryName, vnid);</a>
<a name="ln993">	if (error != B_OK &amp;&amp; fFileSystem-&gt;GetPortPool()-&gt;IsDisconnected()</a>
<a name="ln994">		&amp;&amp; dir == fRootNode &amp;&amp; strcmp(entryName, &quot;.&quot;) == 0) {</a>
<a name="ln995">		WARN((&quot;Volume::Lookup(): connection lost, emulating lookup `.'\n&quot;));</a>
<a name="ln996">		void* entryNode;</a>
<a name="ln997">		if (GetVNode(fRootID, &amp;entryNode) != B_OK)</a>
<a name="ln998">			RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln999">		*vnid = fRootID;</a>
<a name="ln1000">		// The VFS will balance the get_vnode() call for the FS.</a>
<a name="ln1001">		_DecrementVNodeCount(*vnid);</a>
<a name="ln1002">		return B_OK;</a>
<a name="ln1003">	}</a>
<a name="ln1004">	return error;</a>
<a name="ln1005">}</a>
<a name="ln1006"> </a>
<a name="ln1007">// GetVNodeName</a>
<a name="ln1008">status_t</a>
<a name="ln1009">Volume::GetVNodeName(void* _node, char* buffer, size_t bufferSize)</a>
<a name="ln1010">{</a>
<a name="ln1011">	// We don't check the capability -- if not implemented by the client FS,</a>
<a name="ln1012">	// the functionality is emulated in userland.</a>
<a name="ln1013"> </a>
<a name="ln1014">	VNode* vnode = (VNode*)_node;</a>
<a name="ln1015"> </a>
<a name="ln1016">	// get a free port</a>
<a name="ln1017">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln1018">	if (!port)</a>
<a name="ln1019">		return B_ERROR;</a>
<a name="ln1020">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln1021"> </a>
<a name="ln1022">	// prepare the request</a>
<a name="ln1023">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln1024">	GetVNodeNameRequest* request;</a>
<a name="ln1025">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln1026">	if (error != B_OK)</a>
<a name="ln1027">		return error;</a>
<a name="ln1028"> </a>
<a name="ln1029">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln1030">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln1031">	request-&gt;size = bufferSize;</a>
<a name="ln1032"> </a>
<a name="ln1033">	// send the request</a>
<a name="ln1034">	KernelRequestHandler handler(this, GET_VNODE_NAME_REPLY);</a>
<a name="ln1035">	GetVNodeNameReply* reply;</a>
<a name="ln1036">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln1037">	if (error != B_OK)</a>
<a name="ln1038">		return error;</a>
<a name="ln1039">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln1040"> </a>
<a name="ln1041">	// process the reply</a>
<a name="ln1042">	if (reply-&gt;error != B_OK)</a>
<a name="ln1043">		return reply-&gt;error;</a>
<a name="ln1044"> </a>
<a name="ln1045">	char* readBuffer = (char*)reply-&gt;buffer.GetData();</a>
<a name="ln1046">	size_t nameLen = reply-&gt;buffer.GetSize();</a>
<a name="ln1047">	nameLen = strnlen(readBuffer, nameLen);</a>
<a name="ln1048">	if (nameLen &lt;= 1 || nameLen &gt;= bufferSize)</a>
<a name="ln1049">		RETURN_ERROR(B_BAD_DATA);</a>
<a name="ln1050"> </a>
<a name="ln1051">	memcpy(buffer, readBuffer, nameLen);</a>
<a name="ln1052">	buffer[nameLen] = '\0';</a>
<a name="ln1053"> </a>
<a name="ln1054">	_SendReceiptAck(port);</a>
<a name="ln1055">	return error;</a>
<a name="ln1056">}</a>
<a name="ln1057"> </a>
<a name="ln1058">// ReadVNode</a>
<a name="ln1059">status_t</a>
<a name="ln1060">Volume::ReadVNode(ino_t vnid, bool reenter, void** _node, fs_vnode_ops** _ops,</a>
<a name="ln1061">	int* type, uint32* flags)</a>
<a name="ln1062">{</a>
<a name="ln1063">	// get a free port</a>
<a name="ln1064">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln1065">	if (!port)</a>
<a name="ln1066">		return B_ERROR;</a>
<a name="ln1067">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln1068"> </a>
<a name="ln1069">	// prepare the request</a>
<a name="ln1070">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln1071">	ReadVNodeRequest* request;</a>
<a name="ln1072">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln1073">	if (error != B_OK)</a>
<a name="ln1074">		return error;</a>
<a name="ln1075"> </a>
<a name="ln1076">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln1077">	request-&gt;vnid = vnid;</a>
<a name="ln1078">	request-&gt;reenter = reenter;</a>
<a name="ln1079"> </a>
<a name="ln1080">	// add the uninitialized node to our map</a>
<a name="ln1081">	VNode* vnode = new(std::nothrow) VNode(vnid, NULL, NULL);</a>
<a name="ln1082">	if (vnode == NULL)</a>
<a name="ln1083">		RETURN_ERROR(B_NO_MEMORY);</a>
<a name="ln1084">	vnode-&gt;valid = false;</a>
<a name="ln1085"> </a>
<a name="ln1086">	MutexLocker locker(fLock);</a>
<a name="ln1087">	fVNodes-&gt;Insert(vnode);</a>
<a name="ln1088">	locker.Unlock();</a>
<a name="ln1089"> </a>
<a name="ln1090">	// send the request</a>
<a name="ln1091">	KernelRequestHandler handler(this, READ_VNODE_REPLY);</a>
<a name="ln1092">	ReadVNodeReply* reply;</a>
<a name="ln1093">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln1094">	if (error != B_OK) {</a>
<a name="ln1095">		_RemoveInvalidVNode(vnid);</a>
<a name="ln1096">		return error;</a>
<a name="ln1097">	}</a>
<a name="ln1098">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln1099"> </a>
<a name="ln1100">	// process the reply</a>
<a name="ln1101">	if (reply-&gt;error != B_OK) {</a>
<a name="ln1102">		_RemoveInvalidVNode(vnid);</a>
<a name="ln1103">		return reply-&gt;error;</a>
<a name="ln1104">	}</a>
<a name="ln1105"> </a>
<a name="ln1106">	// get the ops vector for the node</a>
<a name="ln1107">	VNodeOps* ops = fFileSystem-&gt;GetVNodeOps(reply-&gt;capabilities);</a>
<a name="ln1108">	if (ops == NULL) {</a>
<a name="ln1109">		_RemoveInvalidVNode(vnid);</a>
<a name="ln1110">		RETURN_ERROR(B_NO_MEMORY);</a>
<a name="ln1111">	}</a>
<a name="ln1112"> </a>
<a name="ln1113">	// everything went fine -- mark the node valid</a>
<a name="ln1114">	locker.Lock();</a>
<a name="ln1115">	vnode-&gt;clientNode = reply-&gt;node;</a>
<a name="ln1116">	vnode-&gt;ops = ops;</a>
<a name="ln1117">	vnode-&gt;valid = true;</a>
<a name="ln1118"> </a>
<a name="ln1119">	*_node = vnode;</a>
<a name="ln1120">	*type = reply-&gt;type;</a>
<a name="ln1121">	*flags = reply-&gt;flags;</a>
<a name="ln1122">	*_ops = ops-&gt;ops;</a>
<a name="ln1123">	return B_OK;</a>
<a name="ln1124">}</a>
<a name="ln1125"> </a>
<a name="ln1126">// WriteVNode</a>
<a name="ln1127">status_t</a>
<a name="ln1128">Volume::WriteVNode(void* node, bool reenter)</a>
<a name="ln1129">{</a>
<a name="ln1130">	status_t error = _WriteVNode(node, reenter);</a>
<a name="ln1131">	if (error != B_OK &amp;&amp; fFileSystem-&gt;GetPortPool()-&gt;IsDisconnected()) {</a>
<a name="ln1132">		// This isn't really necessary, since the VFS basically ignores the</a>
<a name="ln1133">		// return value -- at least Haiku. The fshell panic()s; didn't check</a>
<a name="ln1134">		// BeOS. It doesn't harm to appear to behave nicely. :-)</a>
<a name="ln1135">		WARN((&quot;Volume::WriteVNode(): connection lost, forcing write vnode\n&quot;));</a>
<a name="ln1136">		return B_OK;</a>
<a name="ln1137">	}</a>
<a name="ln1138">	return error;</a>
<a name="ln1139">}</a>
<a name="ln1140"> </a>
<a name="ln1141">// RemoveVNode</a>
<a name="ln1142">status_t</a>
<a name="ln1143">Volume::RemoveVNode(void* _node, bool reenter)</a>
<a name="ln1144">{</a>
<a name="ln1145">	VNode* vnode = (VNode*)_node;</a>
<a name="ln1146"> </a>
<a name="ln1147">	// At any rate remove the vnode from our map and delete it. We don't do that</a>
<a name="ln1148">	// right now, though, since we might still need to serve file cache requests</a>
<a name="ln1149">	// from the client FS.</a>
<a name="ln1150">	VNodeRemover nodeRemover(this, vnode);</a>
<a name="ln1151"> </a>
<a name="ln1152">	void* clientNode = vnode-&gt;clientNode;</a>
<a name="ln1153"> </a>
<a name="ln1154">	// get a free port</a>
<a name="ln1155">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln1156">	if (!port)</a>
<a name="ln1157">		return B_ERROR;</a>
<a name="ln1158">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln1159"> </a>
<a name="ln1160">	// prepare the request</a>
<a name="ln1161">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln1162">	FSRemoveVNodeRequest* request;</a>
<a name="ln1163">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln1164">	if (error != B_OK)</a>
<a name="ln1165">		return error;</a>
<a name="ln1166"> </a>
<a name="ln1167">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln1168">	request-&gt;node = clientNode;</a>
<a name="ln1169">	request-&gt;reenter = reenter;</a>
<a name="ln1170"> </a>
<a name="ln1171">	// send the request</a>
<a name="ln1172">	KernelRequestHandler handler(this, FS_REMOVE_VNODE_REPLY);</a>
<a name="ln1173">	FSRemoveVNodeReply* reply;</a>
<a name="ln1174">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln1175">	if (error != B_OK)</a>
<a name="ln1176">		return error;</a>
<a name="ln1177">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln1178"> </a>
<a name="ln1179">	// process the reply</a>
<a name="ln1180">	if (reply-&gt;error != B_OK)</a>
<a name="ln1181">		return reply-&gt;error;</a>
<a name="ln1182">	return error;</a>
<a name="ln1183">}</a>
<a name="ln1184"> </a>
<a name="ln1185"> </a>
<a name="ln1186">// #pragma mark - asynchronous I/O</a>
<a name="ln1187"> </a>
<a name="ln1188"> </a>
<a name="ln1189">// DoIO</a>
<a name="ln1190">status_t</a>
<a name="ln1191">Volume::DoIO(void* _node, void* cookie, io_request* ioRequest)</a>
<a name="ln1192">{</a>
<a name="ln1193">	VNode* vnode = (VNode*)_node;</a>
<a name="ln1194"> </a>
<a name="ln1195">	// check capability</a>
<a name="ln1196">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_IO))</a>
<a name="ln1197">		return B_UNSUPPORTED;</a>
<a name="ln1198"> </a>
<a name="ln1199">	// register the IO request</a>
<a name="ln1200">	int32 requestID;</a>
<a name="ln1201">	status_t error = _RegisterIORequest(ioRequest, &amp;requestID);</a>
<a name="ln1202">	if (error != B_OK) {</a>
<a name="ln1203">		notify_io_request(ioRequest, error);</a>
<a name="ln1204">		return error;</a>
<a name="ln1205">	}</a>
<a name="ln1206"> </a>
<a name="ln1207">	IORequestRemover requestRemover(this, requestID);</a>
<a name="ln1208"> </a>
<a name="ln1209">	// get a free port</a>
<a name="ln1210">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln1211">	if (!port) {</a>
<a name="ln1212">		notify_io_request(ioRequest, B_ERROR);</a>
<a name="ln1213">		return B_ERROR;</a>
<a name="ln1214">	}</a>
<a name="ln1215">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln1216"> </a>
<a name="ln1217">	// prepare the request</a>
<a name="ln1218">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln1219">	DoIORequest* request;</a>
<a name="ln1220">	error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln1221">	if (error != B_OK) {</a>
<a name="ln1222">		notify_io_request(ioRequest, error);</a>
<a name="ln1223">		return error;</a>
<a name="ln1224">	}</a>
<a name="ln1225"> </a>
<a name="ln1226">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln1227">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln1228">	request-&gt;fileCookie = cookie;</a>
<a name="ln1229">	request-&gt;request = requestID;</a>
<a name="ln1230">	request-&gt;offset = ioRequest-&gt;Offset();</a>
<a name="ln1231">	request-&gt;length = ioRequest-&gt;Length();</a>
<a name="ln1232">	request-&gt;isWrite = ioRequest-&gt;IsWrite();</a>
<a name="ln1233">	request-&gt;isVIP = (ioRequest-&gt;Flags() &amp; B_VIP_IO_REQUEST) != 0;</a>
<a name="ln1234"> </a>
<a name="ln1235">	// send the request</a>
<a name="ln1236">	KernelRequestHandler handler(this, DO_IO_REPLY);</a>
<a name="ln1237">	DoIOReply* reply;</a>
<a name="ln1238"> </a>
<a name="ln1239">	// TODO: when to notify the io_request?</a>
<a name="ln1240">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln1241">	if (error != B_OK)</a>
<a name="ln1242">		return error;</a>
<a name="ln1243">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln1244"> </a>
<a name="ln1245">	// process the reply</a>
<a name="ln1246">	if (reply-&gt;error != B_OK)</a>
<a name="ln1247">		return reply-&gt;error;</a>
<a name="ln1248"> </a>
<a name="ln1249">	requestRemover.Detach();</a>
<a name="ln1250"> </a>
<a name="ln1251">	return B_OK;</a>
<a name="ln1252">}</a>
<a name="ln1253"> </a>
<a name="ln1254"> </a>
<a name="ln1255">// CancelIO</a>
<a name="ln1256">status_t</a>
<a name="ln1257">Volume::CancelIO(void* _node, void* cookie, io_request* ioRequest)</a>
<a name="ln1258">{</a>
<a name="ln1259">	VNode* vnode = (VNode*)_node;</a>
<a name="ln1260"> </a>
<a name="ln1261">	// check capability</a>
<a name="ln1262">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_CANCEL_IO))</a>
<a name="ln1263">		return B_BAD_VALUE;</a>
<a name="ln1264"> </a>
<a name="ln1265">	// find the request</a>
<a name="ln1266">	int32 requestID;</a>
<a name="ln1267">	status_t error = _FindIORequest(ioRequest, &amp;requestID);</a>
<a name="ln1268">	if (error != B_OK)</a>
<a name="ln1269">		return error;</a>
<a name="ln1270"> </a>
<a name="ln1271">	IORequestRemover requestRemover(this, requestID);</a>
<a name="ln1272"> </a>
<a name="ln1273">	// get a free port</a>
<a name="ln1274">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln1275">	if (!port)</a>
<a name="ln1276">		return B_ERROR;</a>
<a name="ln1277">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln1278"> </a>
<a name="ln1279">	// prepare the request</a>
<a name="ln1280">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln1281">	CancelIORequest* request;</a>
<a name="ln1282">	error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln1283">	if (error != B_OK)</a>
<a name="ln1284">		return error;</a>
<a name="ln1285"> </a>
<a name="ln1286">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln1287">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln1288">	request-&gt;fileCookie = cookie;</a>
<a name="ln1289">	request-&gt;request = requestID;</a>
<a name="ln1290"> </a>
<a name="ln1291">	// send the request</a>
<a name="ln1292">	KernelRequestHandler handler(this, CANCEL_IO_REPLY);</a>
<a name="ln1293">	CancelIOReply* reply;</a>
<a name="ln1294">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln1295">	if (error != B_OK) {</a>
<a name="ln1296">		_UnregisterIORequest(requestID);</a>
<a name="ln1297">		return error;</a>
<a name="ln1298">	}</a>
<a name="ln1299">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln1300"> </a>
<a name="ln1301">	// process the reply</a>
<a name="ln1302">	if (reply-&gt;error != B_OK) {</a>
<a name="ln1303">		_UnregisterIORequest(requestID);</a>
<a name="ln1304">		return reply-&gt;error;</a>
<a name="ln1305">	}</a>
<a name="ln1306"> </a>
<a name="ln1307">	return B_OK;</a>
<a name="ln1308">}</a>
<a name="ln1309"> </a>
<a name="ln1310"> </a>
<a name="ln1311">// #pragma mark - nodes</a>
<a name="ln1312"> </a>
<a name="ln1313"> </a>
<a name="ln1314">// IOCtl</a>
<a name="ln1315">status_t</a>
<a name="ln1316">Volume::IOCtl(void* _node, void* cookie, uint32 command, void *buffer,</a>
<a name="ln1317">	size_t len)</a>
<a name="ln1318">{</a>
<a name="ln1319">	VNode* vnode = (VNode*)_node;</a>
<a name="ln1320"> </a>
<a name="ln1321">	// check the command and its parameters</a>
<a name="ln1322">	bool isBuffer = false;</a>
<a name="ln1323">	int32 bufferSize = 0;</a>
<a name="ln1324">	int32 writeSize = 0;</a>
<a name="ln1325">	switch (command) {</a>
<a name="ln1326">		case IOCTL_FILE_UNCACHED_IO:</a>
<a name="ln1327">			buffer = NULL;</a>
<a name="ln1328">			break;</a>
<a name="ln1329">		case IOCTL_CREATE_TIME:</a>
<a name="ln1330">		case IOCTL_MODIFIED_TIME:</a>
<a name="ln1331">			isBuffer = 0;</a>
<a name="ln1332">			bufferSize = 0;</a>
<a name="ln1333">			writeSize = sizeof(bigtime_t);</a>
<a name="ln1334">			break;</a>
<a name="ln1335">		case USERLANDFS_IOCTL:</a>
<a name="ln1336">			area_id area;</a>
<a name="ln1337">			area_info info;</a>
<a name="ln1338">			PRINT((&quot;Volume::IOCtl(): USERLANDFS_IOCTL\n&quot;));</a>
<a name="ln1339">			if ((area = area_for(buffer)) &gt;= 0) {</a>
<a name="ln1340">				if (get_area_info(area, &amp;info) == B_OK) {</a>
<a name="ln1341">					if ((uint8*)buffer - (uint8*)info.address</a>
<a name="ln1342">							+ sizeof(userlandfs_ioctl) &lt;= info.size) {</a>
<a name="ln1343">						if (strncmp(((userlandfs_ioctl*)buffer)-&gt;magic,</a>
<a name="ln1344">								kUserlandFSIOCtlMagic,</a>
<a name="ln1345">								USERLAND_IOCTL_MAGIC_LENGTH) == 0) {</a>
<a name="ln1346">							return _InternalIOCtl((userlandfs_ioctl*)buffer,</a>
<a name="ln1347">								bufferSize);</a>
<a name="ln1348">						} else</a>
<a name="ln1349">							PRINT((&quot;Volume::IOCtl(): bad magic\n&quot;));</a>
<a name="ln1350">					} else</a>
<a name="ln1351">						PRINT((&quot;Volume::IOCtl(): bad buffer size\n&quot;));</a>
<a name="ln1352">				} else</a>
<a name="ln1353">					PRINT((&quot;Volume::IOCtl(): failed to get area info\n&quot;));</a>
<a name="ln1354">			} else</a>
<a name="ln1355">				PRINT((&quot;Volume::IOCtl(): bad area\n&quot;));</a>
<a name="ln1356">			// fall through...</a>
<a name="ln1357">		default:</a>
<a name="ln1358">		{</a>
<a name="ln1359">			// We don't know the command. Check whether the FileSystem knows</a>
<a name="ln1360">			// about it.</a>
<a name="ln1361">			const IOCtlInfo* info = fFileSystem-&gt;GetIOCtlInfo(command);</a>
<a name="ln1362">			if (!info) {</a>
<a name="ln1363">				PRINT((&quot;Volume::IOCtl(): unknown command\n&quot;));</a>
<a name="ln1364">				return B_BAD_VALUE;</a>
<a name="ln1365">			}</a>
<a name="ln1366"> </a>
<a name="ln1367">			isBuffer = info-&gt;isBuffer;</a>
<a name="ln1368">			bufferSize = info-&gt;bufferSize;</a>
<a name="ln1369">			writeSize = info-&gt;writeBufferSize;</a>
<a name="ln1370"> </a>
<a name="ln1371">			// If the buffer shall indeed specify a buffer, check it.</a>
<a name="ln1372">			if (info-&gt;isBuffer) {</a>
<a name="ln1373">				if (!buffer) {</a>
<a name="ln1374">					PRINT((&quot;Volume::IOCtl(): buffer is NULL\n&quot;));</a>
<a name="ln1375">					return B_BAD_VALUE;</a>
<a name="ln1376">				}</a>
<a name="ln1377"> </a>
<a name="ln1378">				area_id area = area_for(buffer);</a>
<a name="ln1379">				if (area &lt; 0) {</a>
<a name="ln1380">					PRINT((&quot;Volume::IOCtl(): bad area\n&quot;));</a>
<a name="ln1381">					return B_BAD_VALUE;</a>
<a name="ln1382">				}</a>
<a name="ln1383"> </a>
<a name="ln1384">				area_info info;</a>
<a name="ln1385">				if (get_area_info(area, &amp;info) != B_OK) {</a>
<a name="ln1386">					PRINT((&quot;Volume::IOCtl(): failed to get area info\n&quot;));</a>
<a name="ln1387">					return B_BAD_VALUE;</a>
<a name="ln1388">				}</a>
<a name="ln1389"> </a>
<a name="ln1390">				int32 areaSize = info.size - ((uint8*)buffer</a>
<a name="ln1391">					- (uint8*)info.address);</a>
<a name="ln1392">				if (bufferSize &gt; areaSize || writeSize &gt; areaSize) {</a>
<a name="ln1393">					PRINT((&quot;Volume::IOCtl(): bad buffer size\n&quot;));</a>
<a name="ln1394">					return B_BAD_VALUE;</a>
<a name="ln1395">				}</a>
<a name="ln1396"> </a>
<a name="ln1397">				if (writeSize &gt; 0 &amp;&amp; !(info.protection &amp; B_WRITE_AREA)) {</a>
<a name="ln1398">					PRINT((&quot;Volume::IOCtl(): buffer not writable\n&quot;));</a>
<a name="ln1399">					return B_BAD_VALUE;</a>
<a name="ln1400">				}</a>
<a name="ln1401">			}</a>
<a name="ln1402">			break;</a>
<a name="ln1403">		}</a>
<a name="ln1404">	}</a>
<a name="ln1405"> </a>
<a name="ln1406">	// check capability</a>
<a name="ln1407">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_IOCTL))</a>
<a name="ln1408">		return B_BAD_VALUE;</a>
<a name="ln1409"> </a>
<a name="ln1410">	// get a free port</a>
<a name="ln1411">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln1412">	if (!port)</a>
<a name="ln1413">		return B_ERROR;</a>
<a name="ln1414">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln1415"> </a>
<a name="ln1416">	// prepare the request</a>
<a name="ln1417">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln1418">	IOCtlRequest* request;</a>
<a name="ln1419">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln1420">	if (error != B_OK)</a>
<a name="ln1421">		return error;</a>
<a name="ln1422"> </a>
<a name="ln1423">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln1424">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln1425">	request-&gt;fileCookie = cookie;</a>
<a name="ln1426">	request-&gt;command = command;</a>
<a name="ln1427">	request-&gt;bufferParameter = buffer;</a>
<a name="ln1428">	request-&gt;isBuffer = isBuffer;</a>
<a name="ln1429">	request-&gt;lenParameter = len;</a>
<a name="ln1430">	request-&gt;writeSize = writeSize;</a>
<a name="ln1431"> </a>
<a name="ln1432">	if (isBuffer &amp;&amp; bufferSize &gt; 0) {</a>
<a name="ln1433">		error = allocator.AllocateData(request-&gt;buffer, buffer, bufferSize, 8);</a>
<a name="ln1434">		if (error != B_OK)</a>
<a name="ln1435">			return error;</a>
<a name="ln1436">	}</a>
<a name="ln1437"> </a>
<a name="ln1438">	// send the request</a>
<a name="ln1439">	KernelRequestHandler handler(this, IOCTL_REPLY);</a>
<a name="ln1440">	IOCtlReply* reply;</a>
<a name="ln1441">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln1442">	if (error != B_OK)</a>
<a name="ln1443">		return error;</a>
<a name="ln1444">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln1445"> </a>
<a name="ln1446">	// process the reply</a>
<a name="ln1447">	if (reply-&gt;error != B_OK)</a>
<a name="ln1448">		return reply-&gt;error;</a>
<a name="ln1449"> </a>
<a name="ln1450">	// Copy back the buffer even if the result is not B_OK. The protocol</a>
<a name="ln1451">	// is defined by the FS developer and may include writing data into</a>
<a name="ln1452">	// the buffer in some error cases.</a>
<a name="ln1453">	if (isBuffer &amp;&amp; writeSize &gt; 0 &amp;&amp; reply-&gt;buffer.GetData()) {</a>
<a name="ln1454">		if (writeSize &gt; reply-&gt;buffer.GetSize())</a>
<a name="ln1455">			writeSize = reply-&gt;buffer.GetSize();</a>
<a name="ln1456">		memcpy(buffer, reply-&gt;buffer.GetData(), writeSize);</a>
<a name="ln1457">		_SendReceiptAck(port);</a>
<a name="ln1458">	}</a>
<a name="ln1459">	return reply-&gt;ioctlError;</a>
<a name="ln1460">}</a>
<a name="ln1461"> </a>
<a name="ln1462">// SetFlags</a>
<a name="ln1463">status_t</a>
<a name="ln1464">Volume::SetFlags(void* _node, void* cookie, int flags)</a>
<a name="ln1465">{</a>
<a name="ln1466">	VNode* vnode = (VNode*)_node;</a>
<a name="ln1467"> </a>
<a name="ln1468">	// check capability</a>
<a name="ln1469">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_SET_FLAGS))</a>
<a name="ln1470">		return B_BAD_VALUE;</a>
<a name="ln1471"> </a>
<a name="ln1472">	// get a free port</a>
<a name="ln1473">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln1474">	if (!port)</a>
<a name="ln1475">		return B_ERROR;</a>
<a name="ln1476">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln1477"> </a>
<a name="ln1478">	// prepare the request</a>
<a name="ln1479">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln1480">	SetFlagsRequest* request;</a>
<a name="ln1481">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln1482">	if (error != B_OK)</a>
<a name="ln1483">		return error;</a>
<a name="ln1484"> </a>
<a name="ln1485">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln1486">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln1487">	request-&gt;fileCookie = cookie;</a>
<a name="ln1488">	request-&gt;flags = flags;</a>
<a name="ln1489"> </a>
<a name="ln1490">	// send the request</a>
<a name="ln1491">	KernelRequestHandler handler(this, SET_FLAGS_REPLY);</a>
<a name="ln1492">	SetFlagsReply* reply;</a>
<a name="ln1493">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln1494">	if (error != B_OK)</a>
<a name="ln1495">		return error;</a>
<a name="ln1496">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln1497"> </a>
<a name="ln1498">	// process the reply</a>
<a name="ln1499">	if (reply-&gt;error != B_OK)</a>
<a name="ln1500">		return reply-&gt;error;</a>
<a name="ln1501">	return error;</a>
<a name="ln1502">}</a>
<a name="ln1503"> </a>
<a name="ln1504">// Select</a>
<a name="ln1505">status_t</a>
<a name="ln1506">Volume::Select(void* _node, void* cookie, uint8 event, selectsync* sync)</a>
<a name="ln1507">{</a>
<a name="ln1508">	VNode* vnode = (VNode*)_node;</a>
<a name="ln1509"> </a>
<a name="ln1510">	// check capability</a>
<a name="ln1511">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_SELECT)) {</a>
<a name="ln1512">		notify_select_event(sync, event);</a>
<a name="ln1513">		return B_OK;</a>
<a name="ln1514">	}</a>
<a name="ln1515"> </a>
<a name="ln1516">	// get a free port</a>
<a name="ln1517">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln1518">	if (!port)</a>
<a name="ln1519">		return B_ERROR;</a>
<a name="ln1520">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln1521"> </a>
<a name="ln1522">	// prepare the request</a>
<a name="ln1523">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln1524">	SelectRequest* request;</a>
<a name="ln1525">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln1526">	if (error != B_OK)</a>
<a name="ln1527">		return error;</a>
<a name="ln1528"> </a>
<a name="ln1529">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln1530">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln1531">	request-&gt;fileCookie = cookie;</a>
<a name="ln1532">	request-&gt;event = event;</a>
<a name="ln1533">	request-&gt;sync = sync;</a>
<a name="ln1534"> </a>
<a name="ln1535">	// add a selectsync entry</a>
<a name="ln1536">	error = fFileSystem-&gt;AddSelectSyncEntry(sync);</a>
<a name="ln1537">	if (error != B_OK)</a>
<a name="ln1538">		return error;</a>
<a name="ln1539"> </a>
<a name="ln1540">	// send the request</a>
<a name="ln1541">	KernelRequestHandler handler(this, SELECT_REPLY);</a>
<a name="ln1542">	SelectReply* reply;</a>
<a name="ln1543">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln1544">	if (error != B_OK) {</a>
<a name="ln1545">		fFileSystem-&gt;RemoveSelectSyncEntry(sync);</a>
<a name="ln1546">		return error;</a>
<a name="ln1547">	}</a>
<a name="ln1548">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln1549"> </a>
<a name="ln1550">	// process the reply</a>
<a name="ln1551">	if (reply-&gt;error != B_OK) {</a>
<a name="ln1552">		fFileSystem-&gt;RemoveSelectSyncEntry(sync);</a>
<a name="ln1553">		return reply-&gt;error;</a>
<a name="ln1554">	}</a>
<a name="ln1555">	return error;</a>
<a name="ln1556">}</a>
<a name="ln1557"> </a>
<a name="ln1558">// Deselect</a>
<a name="ln1559">status_t</a>
<a name="ln1560">Volume::Deselect(void* _node, void* cookie, uint8 event, selectsync* sync)</a>
<a name="ln1561">{</a>
<a name="ln1562">	VNode* vnode = (VNode*)_node;</a>
<a name="ln1563"> </a>
<a name="ln1564">	// check capability</a>
<a name="ln1565">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_DESELECT))</a>
<a name="ln1566">		return B_OK;</a>
<a name="ln1567"> </a>
<a name="ln1568">	struct SyncRemover {</a>
<a name="ln1569">		SyncRemover(FileSystem* fs, selectsync* sync)</a>
<a name="ln1570">			: fs(fs), sync(sync) {}</a>
<a name="ln1571">		~SyncRemover() { fs-&gt;RemoveSelectSyncEntry(sync); }</a>
<a name="ln1572"> </a>
<a name="ln1573">		FileSystem*	fs;</a>
<a name="ln1574">		selectsync*	sync;</a>
<a name="ln1575">	} syncRemover(fFileSystem, sync);</a>
<a name="ln1576"> </a>
<a name="ln1577">	// get a free port</a>
<a name="ln1578">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln1579">	if (!port)</a>
<a name="ln1580">		return B_ERROR;</a>
<a name="ln1581">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln1582"> </a>
<a name="ln1583">	// prepare the request</a>
<a name="ln1584">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln1585">	DeselectRequest* request;</a>
<a name="ln1586">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln1587">	if (error != B_OK)</a>
<a name="ln1588">		return error;</a>
<a name="ln1589"> </a>
<a name="ln1590">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln1591">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln1592">	request-&gt;fileCookie = cookie;</a>
<a name="ln1593">	request-&gt;event = event;</a>
<a name="ln1594">	request-&gt;sync = sync;</a>
<a name="ln1595"> </a>
<a name="ln1596">	// send the request</a>
<a name="ln1597">	KernelRequestHandler handler(this, DESELECT_REPLY);</a>
<a name="ln1598">	DeselectReply* reply;</a>
<a name="ln1599">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln1600">	if (error != B_OK)</a>
<a name="ln1601">		return error;</a>
<a name="ln1602">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln1603"> </a>
<a name="ln1604">	// process the reply</a>
<a name="ln1605">	if (reply-&gt;error != B_OK)</a>
<a name="ln1606">		return reply-&gt;error;</a>
<a name="ln1607">	return error;</a>
<a name="ln1608">}</a>
<a name="ln1609"> </a>
<a name="ln1610">// FSync</a>
<a name="ln1611">status_t</a>
<a name="ln1612">Volume::FSync(void* _node)</a>
<a name="ln1613">{</a>
<a name="ln1614">	VNode* vnode = (VNode*)_node;</a>
<a name="ln1615"> </a>
<a name="ln1616">	// check capability</a>
<a name="ln1617">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_FSYNC))</a>
<a name="ln1618">		return B_BAD_VALUE;</a>
<a name="ln1619"> </a>
<a name="ln1620">	// get a free port</a>
<a name="ln1621">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln1622">	if (!port)</a>
<a name="ln1623">		return B_ERROR;</a>
<a name="ln1624">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln1625"> </a>
<a name="ln1626">	// prepare the request</a>
<a name="ln1627">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln1628">	FSyncRequest* request;</a>
<a name="ln1629">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln1630">	if (error != B_OK)</a>
<a name="ln1631">		return error;</a>
<a name="ln1632"> </a>
<a name="ln1633">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln1634">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln1635"> </a>
<a name="ln1636">	// send the request</a>
<a name="ln1637">	KernelRequestHandler handler(this, FSYNC_REPLY);</a>
<a name="ln1638">	FSyncReply* reply;</a>
<a name="ln1639">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln1640">	if (error != B_OK)</a>
<a name="ln1641">		return error;</a>
<a name="ln1642">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln1643"> </a>
<a name="ln1644">	// process the reply</a>
<a name="ln1645">	if (reply-&gt;error != B_OK)</a>
<a name="ln1646">		return reply-&gt;error;</a>
<a name="ln1647">	return error;</a>
<a name="ln1648">}</a>
<a name="ln1649"> </a>
<a name="ln1650">// ReadSymlink</a>
<a name="ln1651">status_t</a>
<a name="ln1652">Volume::ReadSymlink(void* _node, char* buffer, size_t bufferSize,</a>
<a name="ln1653">	size_t* bytesRead)</a>
<a name="ln1654">{</a>
<a name="ln1655">	VNode* vnode = (VNode*)_node;</a>
<a name="ln1656"> </a>
<a name="ln1657">	*bytesRead = 0;</a>
<a name="ln1658"> </a>
<a name="ln1659">	// check capability</a>
<a name="ln1660">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_READ_SYMLINK))</a>
<a name="ln1661">		return B_BAD_VALUE;</a>
<a name="ln1662"> </a>
<a name="ln1663">	// get a free port</a>
<a name="ln1664">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln1665">	if (!port)</a>
<a name="ln1666">		return B_ERROR;</a>
<a name="ln1667">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln1668"> </a>
<a name="ln1669">	// prepare the request</a>
<a name="ln1670">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln1671">	ReadSymlinkRequest* request;</a>
<a name="ln1672">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln1673">	if (error != B_OK)</a>
<a name="ln1674">		return error;</a>
<a name="ln1675"> </a>
<a name="ln1676">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln1677">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln1678">	request-&gt;size = bufferSize;</a>
<a name="ln1679"> </a>
<a name="ln1680">	// send the request</a>
<a name="ln1681">	KernelRequestHandler handler(this, READ_SYMLINK_REPLY);</a>
<a name="ln1682">	ReadSymlinkReply* reply;</a>
<a name="ln1683">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln1684">	if (error != B_OK)</a>
<a name="ln1685">		return error;</a>
<a name="ln1686">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln1687"> </a>
<a name="ln1688">	// process the reply</a>
<a name="ln1689">	if (reply-&gt;error != B_OK)</a>
<a name="ln1690">		return reply-&gt;error;</a>
<a name="ln1691">	void* readBuffer = reply-&gt;buffer.GetData();</a>
<a name="ln1692">	if (reply-&gt;bytesRead &gt; (uint32)reply-&gt;buffer.GetSize()</a>
<a name="ln1693">		|| reply-&gt;bytesRead &gt; bufferSize) {</a>
<a name="ln1694">		return B_BAD_DATA;</a>
<a name="ln1695">	}</a>
<a name="ln1696">	if (reply-&gt;bytesRead &gt; 0)</a>
<a name="ln1697">		memcpy(buffer, readBuffer, reply-&gt;bytesRead);</a>
<a name="ln1698">	*bytesRead = reply-&gt;bytesRead;</a>
<a name="ln1699">	_SendReceiptAck(port);</a>
<a name="ln1700">	return error;</a>
<a name="ln1701">}</a>
<a name="ln1702"> </a>
<a name="ln1703">// CreateSymlink</a>
<a name="ln1704">status_t</a>
<a name="ln1705">Volume::CreateSymlink(void* _dir, const char* name, const char* target,</a>
<a name="ln1706">	int mode)</a>
<a name="ln1707">{</a>
<a name="ln1708">	VNode* vnode = (VNode*)_dir;</a>
<a name="ln1709"> </a>
<a name="ln1710">	// check capability</a>
<a name="ln1711">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_CREATE_SYMLINK))</a>
<a name="ln1712">		return B_BAD_VALUE;</a>
<a name="ln1713"> </a>
<a name="ln1714">	// get a free port</a>
<a name="ln1715">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln1716">	if (!port)</a>
<a name="ln1717">		return B_ERROR;</a>
<a name="ln1718">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln1719"> </a>
<a name="ln1720">	// prepare the request</a>
<a name="ln1721">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln1722">	CreateSymlinkRequest* request;</a>
<a name="ln1723">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln1724">	if (error != B_OK)</a>
<a name="ln1725">		return error;</a>
<a name="ln1726"> </a>
<a name="ln1727">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln1728">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln1729">	error = allocator.AllocateString(request-&gt;name, name);</a>
<a name="ln1730">	if (error == B_OK)</a>
<a name="ln1731">		error = allocator.AllocateString(request-&gt;target, target);</a>
<a name="ln1732">	if (error != B_OK)</a>
<a name="ln1733">		return error;</a>
<a name="ln1734">	request-&gt;mode = mode;</a>
<a name="ln1735"> </a>
<a name="ln1736">	// send the request</a>
<a name="ln1737">	KernelRequestHandler handler(this, CREATE_SYMLINK_REPLY);</a>
<a name="ln1738">	CreateSymlinkReply* reply;</a>
<a name="ln1739">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln1740">	if (error != B_OK)</a>
<a name="ln1741">		return error;</a>
<a name="ln1742">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln1743"> </a>
<a name="ln1744">	// process the reply</a>
<a name="ln1745">	if (reply-&gt;error != B_OK)</a>
<a name="ln1746">		return reply-&gt;error;</a>
<a name="ln1747">	return error;</a>
<a name="ln1748">}</a>
<a name="ln1749"> </a>
<a name="ln1750">// Link</a>
<a name="ln1751">status_t</a>
<a name="ln1752">Volume::Link(void* _dir, const char* name, void* node)</a>
<a name="ln1753">{</a>
<a name="ln1754">	VNode* vnode = (VNode*)_dir;</a>
<a name="ln1755">	VNode* targetVnode = (VNode*)node;</a>
<a name="ln1756"> </a>
<a name="ln1757">	// check capability</a>
<a name="ln1758">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_LINK))</a>
<a name="ln1759">		return B_BAD_VALUE;</a>
<a name="ln1760"> </a>
<a name="ln1761">	// get a free port</a>
<a name="ln1762">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln1763">	if (!port)</a>
<a name="ln1764">		return B_ERROR;</a>
<a name="ln1765">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln1766"> </a>
<a name="ln1767">	// prepare the request</a>
<a name="ln1768">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln1769">	LinkRequest* request;</a>
<a name="ln1770">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln1771">	if (error != B_OK)</a>
<a name="ln1772">		return error;</a>
<a name="ln1773"> </a>
<a name="ln1774">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln1775">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln1776">	error = allocator.AllocateString(request-&gt;name, name);</a>
<a name="ln1777">	request-&gt;target = targetVnode-&gt;clientNode;</a>
<a name="ln1778">	if (error != B_OK)</a>
<a name="ln1779">		return error;</a>
<a name="ln1780"> </a>
<a name="ln1781">	// send the request</a>
<a name="ln1782">	KernelRequestHandler handler(this, LINK_REPLY);</a>
<a name="ln1783">	LinkReply* reply;</a>
<a name="ln1784">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln1785">	if (error != B_OK)</a>
<a name="ln1786">		return error;</a>
<a name="ln1787">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln1788"> </a>
<a name="ln1789">	// process the reply</a>
<a name="ln1790">	if (reply-&gt;error != B_OK)</a>
<a name="ln1791">		return reply-&gt;error;</a>
<a name="ln1792">	return error;</a>
<a name="ln1793">}</a>
<a name="ln1794"> </a>
<a name="ln1795">// Unlink</a>
<a name="ln1796">status_t</a>
<a name="ln1797">Volume::Unlink(void* _dir, const char* name)</a>
<a name="ln1798">{</a>
<a name="ln1799">	VNode* vnode = (VNode*)_dir;</a>
<a name="ln1800"> </a>
<a name="ln1801">	// check capability</a>
<a name="ln1802">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_UNLINK))</a>
<a name="ln1803">		return B_BAD_VALUE;</a>
<a name="ln1804"> </a>
<a name="ln1805">	// get a free port</a>
<a name="ln1806">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln1807">	if (!port)</a>
<a name="ln1808">		return B_ERROR;</a>
<a name="ln1809">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln1810"> </a>
<a name="ln1811">	// prepare the request</a>
<a name="ln1812">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln1813">	UnlinkRequest* request;</a>
<a name="ln1814">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln1815">	if (error != B_OK)</a>
<a name="ln1816">		return error;</a>
<a name="ln1817"> </a>
<a name="ln1818">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln1819">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln1820">	error = allocator.AllocateString(request-&gt;name, name);</a>
<a name="ln1821">	if (error != B_OK)</a>
<a name="ln1822">		return error;</a>
<a name="ln1823"> </a>
<a name="ln1824">	// send the request</a>
<a name="ln1825">	KernelRequestHandler handler(this, UNLINK_REPLY);</a>
<a name="ln1826">	UnlinkReply* reply;</a>
<a name="ln1827">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln1828">	if (error != B_OK)</a>
<a name="ln1829">		return error;</a>
<a name="ln1830">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln1831"> </a>
<a name="ln1832">	// process the reply</a>
<a name="ln1833">	if (reply-&gt;error != B_OK)</a>
<a name="ln1834">		return reply-&gt;error;</a>
<a name="ln1835">	return error;</a>
<a name="ln1836">}</a>
<a name="ln1837"> </a>
<a name="ln1838">// Rename</a>
<a name="ln1839">status_t</a>
<a name="ln1840">Volume::Rename(void* _oldDir, const char* oldName, void* _newDir,</a>
<a name="ln1841">	const char* newName)</a>
<a name="ln1842">{</a>
<a name="ln1843">	VNode* oldVNode = (VNode*)_oldDir;</a>
<a name="ln1844">	VNode* newVNode = (VNode*)_newDir;</a>
<a name="ln1845"> </a>
<a name="ln1846">	// check capability</a>
<a name="ln1847">	if (!HasVNodeCapability(oldVNode, FS_VNODE_CAPABILITY_RENAME))</a>
<a name="ln1848">		return B_BAD_VALUE;</a>
<a name="ln1849"> </a>
<a name="ln1850">	// get a free port</a>
<a name="ln1851">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln1852">	if (!port)</a>
<a name="ln1853">		return B_ERROR;</a>
<a name="ln1854">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln1855"> </a>
<a name="ln1856">	// prepare the request</a>
<a name="ln1857">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln1858">	RenameRequest* request;</a>
<a name="ln1859">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln1860">	if (error != B_OK)</a>
<a name="ln1861">		return error;</a>
<a name="ln1862"> </a>
<a name="ln1863">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln1864">	request-&gt;oldDir = oldVNode-&gt;clientNode;</a>
<a name="ln1865">	request-&gt;newDir = newVNode-&gt;clientNode;</a>
<a name="ln1866">	error = allocator.AllocateString(request-&gt;oldName, oldName);</a>
<a name="ln1867">	if (error == B_OK)</a>
<a name="ln1868">		error = allocator.AllocateString(request-&gt;newName, newName);</a>
<a name="ln1869">	if (error != B_OK)</a>
<a name="ln1870">		return error;</a>
<a name="ln1871"> </a>
<a name="ln1872">	// send the request</a>
<a name="ln1873">	KernelRequestHandler handler(this, RENAME_REPLY);</a>
<a name="ln1874">	RenameReply* reply;</a>
<a name="ln1875">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln1876">	if (error != B_OK)</a>
<a name="ln1877">		return error;</a>
<a name="ln1878">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln1879"> </a>
<a name="ln1880">	// process the reply</a>
<a name="ln1881">	if (reply-&gt;error != B_OK)</a>
<a name="ln1882">		return reply-&gt;error;</a>
<a name="ln1883">	return error;</a>
<a name="ln1884">}</a>
<a name="ln1885"> </a>
<a name="ln1886">// Access</a>
<a name="ln1887">status_t</a>
<a name="ln1888">Volume::Access(void* _node, int mode)</a>
<a name="ln1889">{</a>
<a name="ln1890">	VNode* vnode = (VNode*)_node;</a>
<a name="ln1891"> </a>
<a name="ln1892">	// check capability</a>
<a name="ln1893">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_ACCESS))</a>
<a name="ln1894">		return B_OK;</a>
<a name="ln1895"> </a>
<a name="ln1896">	// get a free port</a>
<a name="ln1897">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln1898">	if (!port)</a>
<a name="ln1899">		return B_ERROR;</a>
<a name="ln1900">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln1901"> </a>
<a name="ln1902">	// prepare the request</a>
<a name="ln1903">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln1904">	AccessRequest* request;</a>
<a name="ln1905">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln1906">	if (error != B_OK)</a>
<a name="ln1907">		return error;</a>
<a name="ln1908"> </a>
<a name="ln1909">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln1910">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln1911">	request-&gt;mode = mode;</a>
<a name="ln1912"> </a>
<a name="ln1913">	// send the request</a>
<a name="ln1914">	KernelRequestHandler handler(this, ACCESS_REPLY);</a>
<a name="ln1915">	AccessReply* reply;</a>
<a name="ln1916">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln1917">	if (error != B_OK)</a>
<a name="ln1918">		return error;</a>
<a name="ln1919">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln1920"> </a>
<a name="ln1921">	// process the reply</a>
<a name="ln1922">	if (reply-&gt;error != B_OK)</a>
<a name="ln1923">		return reply-&gt;error;</a>
<a name="ln1924">	return error;</a>
<a name="ln1925">}</a>
<a name="ln1926"> </a>
<a name="ln1927">// ReadStat</a>
<a name="ln1928">status_t</a>
<a name="ln1929">Volume::ReadStat(void* node, struct stat* st)</a>
<a name="ln1930">{</a>
<a name="ln1931">	// When the connection to the userland server is lost, we serve</a>
<a name="ln1932">	// read_stat(fRootNode) requests manually to allow clean unmounting.</a>
<a name="ln1933">	status_t error = _ReadStat(node, st);</a>
<a name="ln1934">	if (error != B_OK &amp;&amp; fFileSystem-&gt;GetPortPool()-&gt;IsDisconnected()</a>
<a name="ln1935">		&amp;&amp; node == fRootNode) {</a>
<a name="ln1936">		WARN((&quot;Volume::ReadStat(): connection lost, emulating stat for the &quot;</a>
<a name="ln1937">			&quot;root node\n&quot;));</a>
<a name="ln1938"> </a>
<a name="ln1939">		st-&gt;st_dev = GetID();</a>
<a name="ln1940">		st-&gt;st_ino = fRootID;</a>
<a name="ln1941">		st-&gt;st_mode = ACCESSPERMS;</a>
<a name="ln1942">		st-&gt;st_nlink = 1;</a>
<a name="ln1943">		st-&gt;st_uid = 0;</a>
<a name="ln1944">		st-&gt;st_gid = 0;</a>
<a name="ln1945">		st-&gt;st_size = 512;</a>
<a name="ln1946">		st-&gt;st_blksize = 512;</a>
<a name="ln1947">		st-&gt;st_atime = 0;</a>
<a name="ln1948">		st-&gt;st_mtime = 0;</a>
<a name="ln1949">		st-&gt;st_ctime = 0;</a>
<a name="ln1950">		st-&gt;st_crtime = 0;</a>
<a name="ln1951"> </a>
<a name="ln1952">		error = B_OK;</a>
<a name="ln1953">	}</a>
<a name="ln1954">	return error;</a>
<a name="ln1955">}</a>
<a name="ln1956"> </a>
<a name="ln1957">// WriteStat</a>
<a name="ln1958">status_t</a>
<a name="ln1959">Volume::WriteStat(void* _node, const struct stat* st, uint32 mask)</a>
<a name="ln1960">{</a>
<a name="ln1961">	VNode* vnode = (VNode*)_node;</a>
<a name="ln1962"> </a>
<a name="ln1963">	// check capability</a>
<a name="ln1964">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_WRITE_STAT))</a>
<a name="ln1965">		return B_BAD_VALUE;</a>
<a name="ln1966"> </a>
<a name="ln1967">	// get a free port</a>
<a name="ln1968">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln1969">	if (!port)</a>
<a name="ln1970">		return B_ERROR;</a>
<a name="ln1971">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln1972"> </a>
<a name="ln1973">	// prepare the request</a>
<a name="ln1974">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln1975">	WriteStatRequest* request;</a>
<a name="ln1976">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln1977">	if (error != B_OK)</a>
<a name="ln1978">		return error;</a>
<a name="ln1979"> </a>
<a name="ln1980">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln1981">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln1982">	request-&gt;st = *st;</a>
<a name="ln1983">	request-&gt;mask = mask;</a>
<a name="ln1984"> </a>
<a name="ln1985">	// send the request</a>
<a name="ln1986">	KernelRequestHandler handler(this, WRITE_STAT_REPLY);</a>
<a name="ln1987">	WriteStatReply* reply;</a>
<a name="ln1988">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln1989">	if (error != B_OK)</a>
<a name="ln1990">		return error;</a>
<a name="ln1991">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln1992"> </a>
<a name="ln1993">	// process the reply</a>
<a name="ln1994">	if (reply-&gt;error != B_OK)</a>
<a name="ln1995">		return reply-&gt;error;</a>
<a name="ln1996">	return error;</a>
<a name="ln1997">}</a>
<a name="ln1998"> </a>
<a name="ln1999"> </a>
<a name="ln2000">// #pragma mark - files</a>
<a name="ln2001"> </a>
<a name="ln2002">// Create</a>
<a name="ln2003">status_t</a>
<a name="ln2004">Volume::Create(void* _dir, const char* name, int openMode, int mode,</a>
<a name="ln2005">	void** cookie, ino_t* vnid)</a>
<a name="ln2006">{</a>
<a name="ln2007">	VNode* vnode = (VNode*)_dir;</a>
<a name="ln2008"> </a>
<a name="ln2009">	// check capability</a>
<a name="ln2010">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_CREATE))</a>
<a name="ln2011">		return B_BAD_VALUE;</a>
<a name="ln2012"> </a>
<a name="ln2013">	// get a free port</a>
<a name="ln2014">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln2015">	if (!port)</a>
<a name="ln2016">		return B_ERROR;</a>
<a name="ln2017">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln2018">	AutoIncrementer incrementer(&amp;fOpenFiles);</a>
<a name="ln2019"> </a>
<a name="ln2020">	// prepare the request</a>
<a name="ln2021">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln2022">	CreateRequest* request;</a>
<a name="ln2023">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln2024">	if (error != B_OK)</a>
<a name="ln2025">		return error;</a>
<a name="ln2026"> </a>
<a name="ln2027">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln2028">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln2029">	error = allocator.AllocateString(request-&gt;name, name);</a>
<a name="ln2030">	request-&gt;openMode = openMode;</a>
<a name="ln2031">	request-&gt;mode = mode;</a>
<a name="ln2032">	if (error != B_OK)</a>
<a name="ln2033">		return error;</a>
<a name="ln2034"> </a>
<a name="ln2035">	// send the request</a>
<a name="ln2036">	KernelRequestHandler handler(this, CREATE_REPLY);</a>
<a name="ln2037">	CreateReply* reply;</a>
<a name="ln2038">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln2039">	if (error != B_OK)</a>
<a name="ln2040">		return error;</a>
<a name="ln2041">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln2042"> </a>
<a name="ln2043">	// process the reply</a>
<a name="ln2044">	if (reply-&gt;error != B_OK)</a>
<a name="ln2045">		return reply-&gt;error;</a>
<a name="ln2046">	incrementer.Keep();</a>
<a name="ln2047">	*vnid = reply-&gt;vnid;</a>
<a name="ln2048">	*cookie = reply-&gt;fileCookie;</a>
<a name="ln2049"> </a>
<a name="ln2050">	// The VFS will balance the publish_vnode() call for the FS.</a>
<a name="ln2051">	if (error == B_OK)</a>
<a name="ln2052">		_DecrementVNodeCount(*vnid);</a>
<a name="ln2053">	return error;</a>
<a name="ln2054">}</a>
<a name="ln2055"> </a>
<a name="ln2056">// Open</a>
<a name="ln2057">status_t</a>
<a name="ln2058">Volume::Open(void* _node, int openMode, void** cookie)</a>
<a name="ln2059">{</a>
<a name="ln2060">	VNode* vnode = (VNode*)_node;</a>
<a name="ln2061"> </a>
<a name="ln2062">	// check capability</a>
<a name="ln2063">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_OPEN))</a>
<a name="ln2064">		return B_BAD_VALUE;</a>
<a name="ln2065"> </a>
<a name="ln2066">	// get a free port</a>
<a name="ln2067">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln2068">	if (!port)</a>
<a name="ln2069">		return B_ERROR;</a>
<a name="ln2070">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln2071">	AutoIncrementer incrementer(&amp;fOpenFiles);</a>
<a name="ln2072"> </a>
<a name="ln2073">	// prepare the request</a>
<a name="ln2074">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln2075">	OpenRequest* request;</a>
<a name="ln2076">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln2077">	if (error != B_OK)</a>
<a name="ln2078">		return error;</a>
<a name="ln2079">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln2080">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln2081">	request-&gt;openMode = openMode;</a>
<a name="ln2082"> </a>
<a name="ln2083">	// send the request</a>
<a name="ln2084">	KernelRequestHandler handler(this, OPEN_REPLY);</a>
<a name="ln2085">	OpenReply* reply;</a>
<a name="ln2086">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln2087">	if (error != B_OK)</a>
<a name="ln2088">		return error;</a>
<a name="ln2089">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln2090"> </a>
<a name="ln2091">	// process the reply</a>
<a name="ln2092">	if (reply-&gt;error != B_OK)</a>
<a name="ln2093">		return reply-&gt;error;</a>
<a name="ln2094">	incrementer.Keep();</a>
<a name="ln2095">	*cookie = reply-&gt;fileCookie;</a>
<a name="ln2096">	return error;</a>
<a name="ln2097">}</a>
<a name="ln2098"> </a>
<a name="ln2099">// Close</a>
<a name="ln2100">status_t</a>
<a name="ln2101">Volume::Close(void* node, void* cookie)</a>
<a name="ln2102">{</a>
<a name="ln2103">	status_t error = _Close(node, cookie);</a>
<a name="ln2104">	if (error != B_OK &amp;&amp; fFileSystem-&gt;GetPortPool()-&gt;IsDisconnected()) {</a>
<a name="ln2105">		// This isn't really necessary, as the return value is irrelevant to</a>
<a name="ln2106">		// the VFS. OBOS ignores it completely. The fsshell returns it to the</a>
<a name="ln2107">		// userland, but considers the node closed anyway.</a>
<a name="ln2108">		WARN((&quot;Volume::Close(): connection lost, forcing close\n&quot;));</a>
<a name="ln2109">		return B_OK;</a>
<a name="ln2110">	}</a>
<a name="ln2111">	return error;</a>
<a name="ln2112">}</a>
<a name="ln2113"> </a>
<a name="ln2114">// FreeCookie</a>
<a name="ln2115">status_t</a>
<a name="ln2116">Volume::FreeCookie(void* node, void* cookie)</a>
<a name="ln2117">{</a>
<a name="ln2118">	status_t error = _FreeCookie(node, cookie);</a>
<a name="ln2119">	bool disconnected = false;</a>
<a name="ln2120">	if (error != B_OK &amp;&amp; fFileSystem-&gt;GetPortPool()-&gt;IsDisconnected()) {</a>
<a name="ln2121">		// This isn't really necessary, as the return value is irrelevant to</a>
<a name="ln2122">		// the VFS. It's completely ignored by OBOS as well as by the fsshell.</a>
<a name="ln2123">		WARN((&quot;Volume::FreeCookie(): connection lost, forcing free cookie\n&quot;));</a>
<a name="ln2124">		error = B_OK;</a>
<a name="ln2125">		disconnected = true;</a>
<a name="ln2126">	}</a>
<a name="ln2127"> </a>
<a name="ln2128">	int32 openFiles = atomic_add(&amp;fOpenFiles, -1);</a>
<a name="ln2129">	if (openFiles &lt;= 1 &amp;&amp; disconnected)</a>
<a name="ln2130">		_PutAllPendingVNodes();</a>
<a name="ln2131">	return error;</a>
<a name="ln2132">}</a>
<a name="ln2133"> </a>
<a name="ln2134">// Read</a>
<a name="ln2135">status_t</a>
<a name="ln2136">Volume::Read(void* _node, void* cookie, off_t pos, void* buffer,</a>
<a name="ln2137">	size_t bufferSize, size_t* bytesRead)</a>
<a name="ln2138">{</a>
<a name="ln2139">	VNode* vnode = (VNode*)_node;</a>
<a name="ln2140"> </a>
<a name="ln2141">	*bytesRead = 0;</a>
<a name="ln2142"> </a>
<a name="ln2143">	// check capability</a>
<a name="ln2144">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_READ))</a>
<a name="ln2145">		return B_BAD_VALUE;</a>
<a name="ln2146"> </a>
<a name="ln2147">	// get a free port</a>
<a name="ln2148">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln2149">	if (!port)</a>
<a name="ln2150">		return B_ERROR;</a>
<a name="ln2151">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln2152"> </a>
<a name="ln2153">	// prepare the request</a>
<a name="ln2154">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln2155">	ReadRequest* request;</a>
<a name="ln2156">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln2157">	if (error != B_OK)</a>
<a name="ln2158">		return error;</a>
<a name="ln2159"> </a>
<a name="ln2160">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln2161">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln2162">	request-&gt;fileCookie = cookie;</a>
<a name="ln2163">	request-&gt;pos = pos;</a>
<a name="ln2164">	request-&gt;size = bufferSize;</a>
<a name="ln2165"> </a>
<a name="ln2166">	// send the request</a>
<a name="ln2167">	KernelRequestHandler handler(this, READ_REPLY);</a>
<a name="ln2168">	ReadReply* reply;</a>
<a name="ln2169">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln2170">	if (error != B_OK)</a>
<a name="ln2171">		return error;</a>
<a name="ln2172">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln2173"> </a>
<a name="ln2174">	// process the reply</a>
<a name="ln2175">	if (reply-&gt;error != B_OK)</a>
<a name="ln2176">		return reply-&gt;error;</a>
<a name="ln2177">	void* readBuffer = reply-&gt;buffer.GetData();</a>
<a name="ln2178">	if (reply-&gt;bytesRead &gt; (uint32)reply-&gt;buffer.GetSize()</a>
<a name="ln2179">		|| reply-&gt;bytesRead &gt; bufferSize) {</a>
<a name="ln2180">		return B_BAD_DATA;</a>
<a name="ln2181">	}</a>
<a name="ln2182">	if (reply-&gt;bytesRead &gt; 0</a>
<a name="ln2183">		&amp;&amp; user_memcpy(buffer, readBuffer, reply-&gt;bytesRead) &lt; B_OK) {</a>
<a name="ln2184">		return B_BAD_ADDRESS;</a>
<a name="ln2185">	}</a>
<a name="ln2186"> </a>
<a name="ln2187">	*bytesRead = reply-&gt;bytesRead;</a>
<a name="ln2188">	_SendReceiptAck(port);</a>
<a name="ln2189">	return error;</a>
<a name="ln2190">}</a>
<a name="ln2191"> </a>
<a name="ln2192">// Write</a>
<a name="ln2193">status_t</a>
<a name="ln2194">Volume::Write(void* _node, void* cookie, off_t pos, const void* buffer,</a>
<a name="ln2195">	size_t size, size_t* bytesWritten)</a>
<a name="ln2196">{</a>
<a name="ln2197">	VNode* vnode = (VNode*)_node;</a>
<a name="ln2198"> </a>
<a name="ln2199">	*bytesWritten = 0;</a>
<a name="ln2200"> </a>
<a name="ln2201">	// check capability</a>
<a name="ln2202">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_WRITE))</a>
<a name="ln2203">		return B_BAD_VALUE;</a>
<a name="ln2204"> </a>
<a name="ln2205">	// get a free port</a>
<a name="ln2206">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln2207">	if (!port)</a>
<a name="ln2208">		return B_ERROR;</a>
<a name="ln2209">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln2210"> </a>
<a name="ln2211">	// prepare the request</a>
<a name="ln2212">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln2213">	WriteRequest* request;</a>
<a name="ln2214">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln2215">	if (error != B_OK)</a>
<a name="ln2216">		return error;</a>
<a name="ln2217"> </a>
<a name="ln2218">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln2219">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln2220">	request-&gt;fileCookie = cookie;</a>
<a name="ln2221">	request-&gt;pos = pos;</a>
<a name="ln2222">	error = allocator.AllocateData(request-&gt;buffer, buffer, size, 1);</a>
<a name="ln2223">	if (error != B_OK)</a>
<a name="ln2224">		return error;</a>
<a name="ln2225"> </a>
<a name="ln2226">	// send the request</a>
<a name="ln2227">	KernelRequestHandler handler(this, WRITE_REPLY);</a>
<a name="ln2228">	WriteReply* reply;</a>
<a name="ln2229">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln2230">	if (error != B_OK)</a>
<a name="ln2231">		return error;</a>
<a name="ln2232">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln2233"> </a>
<a name="ln2234">	// process the reply</a>
<a name="ln2235">	if (reply-&gt;error != B_OK)</a>
<a name="ln2236">		return reply-&gt;error;</a>
<a name="ln2237">	*bytesWritten = reply-&gt;bytesWritten;</a>
<a name="ln2238">	return error;</a>
<a name="ln2239">}</a>
<a name="ln2240"> </a>
<a name="ln2241"> </a>
<a name="ln2242">// #pragma mark - directories</a>
<a name="ln2243"> </a>
<a name="ln2244">// CreateDir</a>
<a name="ln2245">status_t</a>
<a name="ln2246">Volume::CreateDir(void* _dir, const char* name, int mode)</a>
<a name="ln2247">{</a>
<a name="ln2248">	VNode* vnode = (VNode*)_dir;</a>
<a name="ln2249"> </a>
<a name="ln2250">	// check capability</a>
<a name="ln2251">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_CREATE_DIR))</a>
<a name="ln2252">		return B_BAD_VALUE;</a>
<a name="ln2253"> </a>
<a name="ln2254">	// get a free port</a>
<a name="ln2255">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln2256">	if (!port)</a>
<a name="ln2257">		return B_ERROR;</a>
<a name="ln2258">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln2259"> </a>
<a name="ln2260">	// prepare the request</a>
<a name="ln2261">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln2262">	CreateDirRequest* request;</a>
<a name="ln2263">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln2264">	if (error != B_OK)</a>
<a name="ln2265">		return error;</a>
<a name="ln2266"> </a>
<a name="ln2267">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln2268">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln2269">	error = allocator.AllocateString(request-&gt;name, name);</a>
<a name="ln2270">	request-&gt;mode = mode;</a>
<a name="ln2271">	if (error != B_OK)</a>
<a name="ln2272">		return error;</a>
<a name="ln2273"> </a>
<a name="ln2274">	// send the request</a>
<a name="ln2275">	KernelRequestHandler handler(this, CREATE_DIR_REPLY);</a>
<a name="ln2276">	CreateDirReply* reply;</a>
<a name="ln2277">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln2278">	if (error != B_OK)</a>
<a name="ln2279">		return error;</a>
<a name="ln2280">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln2281"> </a>
<a name="ln2282">	// process the reply</a>
<a name="ln2283">	if (reply-&gt;error != B_OK)</a>
<a name="ln2284">		return reply-&gt;error;</a>
<a name="ln2285">	return error;</a>
<a name="ln2286">}</a>
<a name="ln2287"> </a>
<a name="ln2288">// RemoveDir</a>
<a name="ln2289">status_t</a>
<a name="ln2290">Volume::RemoveDir(void* _dir, const char* name)</a>
<a name="ln2291">{</a>
<a name="ln2292">	VNode* vnode = (VNode*)_dir;</a>
<a name="ln2293"> </a>
<a name="ln2294">	// check capability</a>
<a name="ln2295">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_REMOVE_DIR))</a>
<a name="ln2296">		return B_BAD_VALUE;</a>
<a name="ln2297"> </a>
<a name="ln2298">	// get a free port</a>
<a name="ln2299">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln2300">	if (!port)</a>
<a name="ln2301">		return B_ERROR;</a>
<a name="ln2302">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln2303"> </a>
<a name="ln2304">	// prepare the request</a>
<a name="ln2305">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln2306">	RemoveDirRequest* request;</a>
<a name="ln2307">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln2308">	if (error != B_OK)</a>
<a name="ln2309">		return error;</a>
<a name="ln2310"> </a>
<a name="ln2311">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln2312">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln2313">	error = allocator.AllocateString(request-&gt;name, name);</a>
<a name="ln2314">	if (error != B_OK)</a>
<a name="ln2315">		return error;</a>
<a name="ln2316"> </a>
<a name="ln2317">	// send the request</a>
<a name="ln2318">	KernelRequestHandler handler(this, REMOVE_DIR_REPLY);</a>
<a name="ln2319">	RemoveDirReply* reply;</a>
<a name="ln2320">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln2321">	if (error != B_OK)</a>
<a name="ln2322">		return error;</a>
<a name="ln2323">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln2324"> </a>
<a name="ln2325">	// process the reply</a>
<a name="ln2326">	if (reply-&gt;error != B_OK)</a>
<a name="ln2327">		return reply-&gt;error;</a>
<a name="ln2328">	return error;</a>
<a name="ln2329">}</a>
<a name="ln2330"> </a>
<a name="ln2331">// OpenDir</a>
<a name="ln2332">status_t</a>
<a name="ln2333">Volume::OpenDir(void* _node, void** cookie)</a>
<a name="ln2334">{</a>
<a name="ln2335">	VNode* vnode = (VNode*)_node;</a>
<a name="ln2336"> </a>
<a name="ln2337">	// check capability</a>
<a name="ln2338">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_OPEN_DIR))</a>
<a name="ln2339">		return B_BAD_VALUE;</a>
<a name="ln2340"> </a>
<a name="ln2341">	// get a free port</a>
<a name="ln2342">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln2343">	if (!port)</a>
<a name="ln2344">		return B_ERROR;</a>
<a name="ln2345">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln2346">	AutoIncrementer incrementer(&amp;fOpenDirectories);</a>
<a name="ln2347"> </a>
<a name="ln2348">	// prepare the request</a>
<a name="ln2349">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln2350">	OpenDirRequest* request;</a>
<a name="ln2351">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln2352">	if (error != B_OK)</a>
<a name="ln2353">		return error;</a>
<a name="ln2354"> </a>
<a name="ln2355">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln2356">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln2357"> </a>
<a name="ln2358">	// send the request</a>
<a name="ln2359">	KernelRequestHandler handler(this, OPEN_DIR_REPLY);</a>
<a name="ln2360">	OpenDirReply* reply;</a>
<a name="ln2361">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln2362">	if (error != B_OK)</a>
<a name="ln2363">		return error;</a>
<a name="ln2364">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln2365"> </a>
<a name="ln2366">	// process the reply</a>
<a name="ln2367">	if (reply-&gt;error != B_OK)</a>
<a name="ln2368">		return reply-&gt;error;</a>
<a name="ln2369">	incrementer.Keep();</a>
<a name="ln2370">	*cookie = reply-&gt;dirCookie;</a>
<a name="ln2371">	return error;</a>
<a name="ln2372">}</a>
<a name="ln2373"> </a>
<a name="ln2374">// CloseDir</a>
<a name="ln2375">status_t</a>
<a name="ln2376">Volume::CloseDir(void* node, void* cookie)</a>
<a name="ln2377">{</a>
<a name="ln2378">	status_t error = _CloseDir(node, cookie);</a>
<a name="ln2379">	if (error != B_OK &amp;&amp; fFileSystem-&gt;GetPortPool()-&gt;IsDisconnected()) {</a>
<a name="ln2380">		// This isn't really necessary, as the return value is irrelevant to</a>
<a name="ln2381">		// the VFS. OBOS ignores it completely. The fsshell returns it to the</a>
<a name="ln2382">		// userland, but considers the node closed anyway.</a>
<a name="ln2383">		WARN((&quot;Volume::CloseDir(): connection lost, forcing close dir\n&quot;));</a>
<a name="ln2384">		return B_OK;</a>
<a name="ln2385">	}</a>
<a name="ln2386">	return error;</a>
<a name="ln2387">}</a>
<a name="ln2388"> </a>
<a name="ln2389">// FreeDirCookie</a>
<a name="ln2390">status_t</a>
<a name="ln2391">Volume::FreeDirCookie(void* node, void* cookie)</a>
<a name="ln2392">{</a>
<a name="ln2393">	status_t error = _FreeDirCookie(node, cookie);</a>
<a name="ln2394">	bool disconnected = false;</a>
<a name="ln2395">	if (error != B_OK &amp;&amp; fFileSystem-&gt;GetPortPool()-&gt;IsDisconnected()) {</a>
<a name="ln2396">		// This isn't really necessary, as the return value is irrelevant to</a>
<a name="ln2397">		// the VFS. It's completely ignored by OBOS as well as by the fsshell.</a>
<a name="ln2398">		WARN((&quot;Volume::FreeDirCookie(): connection lost, forcing free dir &quot;</a>
<a name="ln2399">			&quot;cookie\n&quot;));</a>
<a name="ln2400">		error = B_OK;</a>
<a name="ln2401">		disconnected = true;</a>
<a name="ln2402">	}</a>
<a name="ln2403">	int32 openDirs = atomic_add(&amp;fOpenDirectories, -1);</a>
<a name="ln2404">	if (openDirs &lt;= 1 &amp;&amp; disconnected)</a>
<a name="ln2405">		_PutAllPendingVNodes();</a>
<a name="ln2406">	return error;</a>
<a name="ln2407">}</a>
<a name="ln2408"> </a>
<a name="ln2409">// ReadDir</a>
<a name="ln2410">status_t</a>
<a name="ln2411">Volume::ReadDir(void* _node, void* cookie, void* buffer, size_t bufferSize,</a>
<a name="ln2412">	uint32 count, uint32* countRead)</a>
<a name="ln2413">{</a>
<a name="ln2414">	VNode* vnode = (VNode*)_node;</a>
<a name="ln2415"> </a>
<a name="ln2416">	*countRead = 0;</a>
<a name="ln2417"> </a>
<a name="ln2418">	// check capability</a>
<a name="ln2419">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_READ_DIR))</a>
<a name="ln2420">		return B_BAD_VALUE;</a>
<a name="ln2421"> </a>
<a name="ln2422">	// get a free port</a>
<a name="ln2423">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln2424">	if (!port)</a>
<a name="ln2425">		return B_ERROR;</a>
<a name="ln2426">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln2427"> </a>
<a name="ln2428">	// prepare the request</a>
<a name="ln2429">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln2430">	ReadDirRequest* request;</a>
<a name="ln2431">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln2432">	if (error != B_OK)</a>
<a name="ln2433">		return error;</a>
<a name="ln2434"> </a>
<a name="ln2435">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln2436">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln2437">	request-&gt;dirCookie = cookie;</a>
<a name="ln2438">	request-&gt;bufferSize = bufferSize;</a>
<a name="ln2439">	request-&gt;count = count;</a>
<a name="ln2440"> </a>
<a name="ln2441">	// send the request</a>
<a name="ln2442">	KernelRequestHandler handler(this, READ_DIR_REPLY);</a>
<a name="ln2443">	ReadDirReply* reply;</a>
<a name="ln2444">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln2445">	if (error != B_OK)</a>
<a name="ln2446">		return error;</a>
<a name="ln2447">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln2448"> </a>
<a name="ln2449">	// process the reply</a>
<a name="ln2450">	if (reply-&gt;error != B_OK)</a>
<a name="ln2451">		return reply-&gt;error;</a>
<a name="ln2452">	if (reply-&gt;count &lt; 0 || reply-&gt;count &gt; count)</a>
<a name="ln2453">		return B_BAD_DATA;</a>
<a name="ln2454">	if ((int32)bufferSize &lt; reply-&gt;buffer.GetSize())</a>
<a name="ln2455">		return B_BAD_DATA;</a>
<a name="ln2456"> </a>
<a name="ln2457">	PRINT((&quot;Volume::ReadDir(): buffer returned: %&quot; B_PRId32 &quot; bytes\n&quot;,</a>
<a name="ln2458">		reply-&gt;buffer.GetSize()));</a>
<a name="ln2459"> </a>
<a name="ln2460">	*countRead = reply-&gt;count;</a>
<a name="ln2461">	if (*countRead &gt; 0) {</a>
<a name="ln2462">		// copy the buffer -- limit the number of bytes to copy</a>
<a name="ln2463">		uint32 maxBytes = *countRead</a>
<a name="ln2464">			* (sizeof(struct dirent) + B_FILE_NAME_LENGTH);</a>
<a name="ln2465">		uint32 copyBytes = reply-&gt;buffer.GetSize();</a>
<a name="ln2466">		if (copyBytes &gt; maxBytes)</a>
<a name="ln2467">			copyBytes = maxBytes;</a>
<a name="ln2468">		memcpy(buffer, reply-&gt;buffer.GetData(), copyBytes);</a>
<a name="ln2469">	}</a>
<a name="ln2470">	_SendReceiptAck(port);</a>
<a name="ln2471">	return error;</a>
<a name="ln2472">}</a>
<a name="ln2473"> </a>
<a name="ln2474">// RewindDir</a>
<a name="ln2475">status_t</a>
<a name="ln2476">Volume::RewindDir(void* _node, void* cookie)</a>
<a name="ln2477">{</a>
<a name="ln2478">	VNode* vnode = (VNode*)_node;</a>
<a name="ln2479"> </a>
<a name="ln2480">	// check capability</a>
<a name="ln2481">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_REWIND_DIR))</a>
<a name="ln2482">		return B_BAD_VALUE;</a>
<a name="ln2483"> </a>
<a name="ln2484">	// get a free port</a>
<a name="ln2485">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln2486">	if (!port)</a>
<a name="ln2487">		return B_ERROR;</a>
<a name="ln2488">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln2489"> </a>
<a name="ln2490">	// prepare the request</a>
<a name="ln2491">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln2492">	RewindDirRequest* request;</a>
<a name="ln2493">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln2494">	if (error != B_OK)</a>
<a name="ln2495">		return error;</a>
<a name="ln2496"> </a>
<a name="ln2497">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln2498">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln2499">	request-&gt;dirCookie = cookie;</a>
<a name="ln2500"> </a>
<a name="ln2501">	// send the request</a>
<a name="ln2502">	KernelRequestHandler handler(this, REWIND_DIR_REPLY);</a>
<a name="ln2503">	RewindDirReply* reply;</a>
<a name="ln2504">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln2505">	if (error != B_OK)</a>
<a name="ln2506">		return error;</a>
<a name="ln2507">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln2508"> </a>
<a name="ln2509">	// process the reply</a>
<a name="ln2510">	if (reply-&gt;error != B_OK)</a>
<a name="ln2511">		return reply-&gt;error;</a>
<a name="ln2512">	return error;</a>
<a name="ln2513">}</a>
<a name="ln2514"> </a>
<a name="ln2515"> </a>
<a name="ln2516">// #pragma mark - attribute directories</a>
<a name="ln2517"> </a>
<a name="ln2518"> </a>
<a name="ln2519">// OpenAttrDir</a>
<a name="ln2520">status_t</a>
<a name="ln2521">Volume::OpenAttrDir(void* _node, void** cookie)</a>
<a name="ln2522">{</a>
<a name="ln2523">	VNode* vnode = (VNode*)_node;</a>
<a name="ln2524"> </a>
<a name="ln2525">	// check capability</a>
<a name="ln2526">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_OPEN_ATTR_DIR))</a>
<a name="ln2527">		return B_BAD_VALUE;</a>
<a name="ln2528"> </a>
<a name="ln2529">	// get a free port</a>
<a name="ln2530">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln2531">	if (!port)</a>
<a name="ln2532">		return B_ERROR;</a>
<a name="ln2533">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln2534">	AutoIncrementer incrementer(&amp;fOpenAttributeDirectories);</a>
<a name="ln2535"> </a>
<a name="ln2536">	// prepare the request</a>
<a name="ln2537">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln2538">	OpenAttrDirRequest* request;</a>
<a name="ln2539">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln2540">	if (error != B_OK)</a>
<a name="ln2541">		return error;</a>
<a name="ln2542"> </a>
<a name="ln2543">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln2544">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln2545"> </a>
<a name="ln2546">	// send the request</a>
<a name="ln2547">	KernelRequestHandler handler(this, OPEN_ATTR_DIR_REPLY);</a>
<a name="ln2548">	OpenAttrDirReply* reply;</a>
<a name="ln2549">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln2550">	if (error != B_OK)</a>
<a name="ln2551">		return error;</a>
<a name="ln2552">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln2553"> </a>
<a name="ln2554">	// process the reply</a>
<a name="ln2555">	if (reply-&gt;error != B_OK)</a>
<a name="ln2556">		return reply-&gt;error;</a>
<a name="ln2557">	incrementer.Keep();</a>
<a name="ln2558">	*cookie = reply-&gt;attrDirCookie;</a>
<a name="ln2559">	return error;</a>
<a name="ln2560">}</a>
<a name="ln2561"> </a>
<a name="ln2562">// CloseAttrDir</a>
<a name="ln2563">status_t</a>
<a name="ln2564">Volume::CloseAttrDir(void* node, void* cookie)</a>
<a name="ln2565">{</a>
<a name="ln2566">	status_t error = _CloseAttrDir(node, cookie);</a>
<a name="ln2567">	if (error != B_OK &amp;&amp; fFileSystem-&gt;GetPortPool()-&gt;IsDisconnected()) {</a>
<a name="ln2568">		// This isn't really necessary, as the return value is irrelevant to</a>
<a name="ln2569">		// the VFS. OBOS ignores it completely. The fsshell returns it to the</a>
<a name="ln2570">		// userland, but considers the node closed anyway.</a>
<a name="ln2571">		WARN((&quot;Volume::CloseAttrDir(): connection lost, forcing close attr &quot;</a>
<a name="ln2572">			&quot;dir\n&quot;));</a>
<a name="ln2573">		return B_OK;</a>
<a name="ln2574">	}</a>
<a name="ln2575">	return error;</a>
<a name="ln2576">}</a>
<a name="ln2577"> </a>
<a name="ln2578">// FreeAttrDirCookie</a>
<a name="ln2579">status_t</a>
<a name="ln2580">Volume::FreeAttrDirCookie(void* node, void* cookie)</a>
<a name="ln2581">{</a>
<a name="ln2582">	status_t error = _FreeAttrDirCookie(node, cookie);</a>
<a name="ln2583">	bool disconnected = false;</a>
<a name="ln2584">	if (error != B_OK &amp;&amp; fFileSystem-&gt;GetPortPool()-&gt;IsDisconnected()) {</a>
<a name="ln2585">		// This isn't really necessary, as the return value is irrelevant to</a>
<a name="ln2586">		// the VFS. It's completely ignored by OBOS as well as by the fsshell.</a>
<a name="ln2587">		WARN((&quot;Volume::FreeAttrDirCookie(): connection lost, forcing free attr &quot;</a>
<a name="ln2588">			&quot;dir cookie\n&quot;));</a>
<a name="ln2589">		error = B_OK;</a>
<a name="ln2590">		disconnected = true;</a>
<a name="ln2591">	}</a>
<a name="ln2592"> </a>
<a name="ln2593">	int32 openAttrDirs = atomic_add(&amp;fOpenAttributeDirectories, -1);</a>
<a name="ln2594">	if (openAttrDirs &lt;= 1 &amp;&amp; disconnected)</a>
<a name="ln2595">		_PutAllPendingVNodes();</a>
<a name="ln2596">	return error;</a>
<a name="ln2597">}</a>
<a name="ln2598"> </a>
<a name="ln2599">// ReadAttrDir</a>
<a name="ln2600">status_t</a>
<a name="ln2601">Volume::ReadAttrDir(void* _node, void* cookie, void* buffer,</a>
<a name="ln2602">	size_t bufferSize, uint32 count, uint32* countRead)</a>
<a name="ln2603">{</a>
<a name="ln2604">	VNode* vnode = (VNode*)_node;</a>
<a name="ln2605"> </a>
<a name="ln2606">	// check capability</a>
<a name="ln2607">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_READ_ATTR_DIR))</a>
<a name="ln2608">		return B_BAD_VALUE;</a>
<a name="ln2609"> </a>
<a name="ln2610">	*countRead = 0;</a>
<a name="ln2611">	// get a free port</a>
<a name="ln2612">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln2613">	if (!port)</a>
<a name="ln2614">		return B_ERROR;</a>
<a name="ln2615">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln2616"> </a>
<a name="ln2617">	// prepare the request</a>
<a name="ln2618">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln2619">	ReadAttrDirRequest* request;</a>
<a name="ln2620">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln2621">	if (error != B_OK)</a>
<a name="ln2622">		return error;</a>
<a name="ln2623"> </a>
<a name="ln2624">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln2625">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln2626">	request-&gt;attrDirCookie = cookie;</a>
<a name="ln2627">	request-&gt;bufferSize = bufferSize;</a>
<a name="ln2628">	request-&gt;count = count;</a>
<a name="ln2629"> </a>
<a name="ln2630">	// send the request</a>
<a name="ln2631">	KernelRequestHandler handler(this, READ_ATTR_DIR_REPLY);</a>
<a name="ln2632">	ReadAttrDirReply* reply;</a>
<a name="ln2633">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln2634">	if (error != B_OK)</a>
<a name="ln2635">		return error;</a>
<a name="ln2636">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln2637"> </a>
<a name="ln2638">	// process the reply</a>
<a name="ln2639">	if (reply-&gt;error != B_OK)</a>
<a name="ln2640">		return reply-&gt;error;</a>
<a name="ln2641">	if (reply-&gt;count &lt; 0 || reply-&gt;count &gt; count)</a>
<a name="ln2642">		return B_BAD_DATA;</a>
<a name="ln2643">	if ((int32)bufferSize &lt; reply-&gt;buffer.GetSize())</a>
<a name="ln2644">		return B_BAD_DATA;</a>
<a name="ln2645"> </a>
<a name="ln2646">	*countRead = reply-&gt;count;</a>
<a name="ln2647">	if (*countRead &gt; 0) {</a>
<a name="ln2648">		// copy the buffer -- limit the number of bytes to copy</a>
<a name="ln2649">		uint32 maxBytes = *countRead</a>
<a name="ln2650">			* (sizeof(struct dirent) + B_ATTR_NAME_LENGTH);</a>
<a name="ln2651">		uint32 copyBytes = reply-&gt;buffer.GetSize();</a>
<a name="ln2652">		if (copyBytes &gt; maxBytes)</a>
<a name="ln2653">			copyBytes = maxBytes;</a>
<a name="ln2654">		memcpy(buffer, reply-&gt;buffer.GetData(), copyBytes);</a>
<a name="ln2655">	}</a>
<a name="ln2656">	_SendReceiptAck(port);</a>
<a name="ln2657">	return error;</a>
<a name="ln2658">}</a>
<a name="ln2659"> </a>
<a name="ln2660">// RewindAttrDir</a>
<a name="ln2661">status_t</a>
<a name="ln2662">Volume::RewindAttrDir(void* _node, void* cookie)</a>
<a name="ln2663">{</a>
<a name="ln2664">	VNode* vnode = (VNode*)_node;</a>
<a name="ln2665"> </a>
<a name="ln2666">	// check capability</a>
<a name="ln2667">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_REWIND_ATTR_DIR))</a>
<a name="ln2668">		return B_BAD_VALUE;</a>
<a name="ln2669"> </a>
<a name="ln2670">	// get a free port</a>
<a name="ln2671">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln2672">	if (!port)</a>
<a name="ln2673">		return B_ERROR;</a>
<a name="ln2674">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln2675"> </a>
<a name="ln2676">	// prepare the request</a>
<a name="ln2677">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln2678">	RewindAttrDirRequest* request;</a>
<a name="ln2679">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln2680">	if (error != B_OK)</a>
<a name="ln2681">		return error;</a>
<a name="ln2682"> </a>
<a name="ln2683">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln2684">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln2685">	request-&gt;attrDirCookie = cookie;</a>
<a name="ln2686"> </a>
<a name="ln2687">	// send the request</a>
<a name="ln2688">	KernelRequestHandler handler(this, REWIND_ATTR_DIR_REPLY);</a>
<a name="ln2689">	RewindAttrDirReply* reply;</a>
<a name="ln2690">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln2691">	if (error != B_OK)</a>
<a name="ln2692">		return error;</a>
<a name="ln2693">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln2694"> </a>
<a name="ln2695">	// process the reply</a>
<a name="ln2696">	if (reply-&gt;error != B_OK)</a>
<a name="ln2697">		return reply-&gt;error;</a>
<a name="ln2698">	return error;</a>
<a name="ln2699">}</a>
<a name="ln2700"> </a>
<a name="ln2701"> </a>
<a name="ln2702">// #pragma mark - attributes</a>
<a name="ln2703"> </a>
<a name="ln2704">// CreateAttr</a>
<a name="ln2705">status_t</a>
<a name="ln2706">Volume::CreateAttr(void* _node, const char* name, uint32 type, int openMode,</a>
<a name="ln2707">	void** cookie)</a>
<a name="ln2708">{</a>
<a name="ln2709">	VNode* vnode = (VNode*)_node;</a>
<a name="ln2710"> </a>
<a name="ln2711">	// check capability</a>
<a name="ln2712">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_CREATE_ATTR))</a>
<a name="ln2713">		return B_BAD_VALUE;</a>
<a name="ln2714"> </a>
<a name="ln2715">	// get a free port</a>
<a name="ln2716">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln2717">	if (!port)</a>
<a name="ln2718">		return B_ERROR;</a>
<a name="ln2719">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln2720">	AutoIncrementer incrementer(&amp;fOpenAttributes);</a>
<a name="ln2721"> </a>
<a name="ln2722">	// prepare the request</a>
<a name="ln2723">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln2724">	CreateAttrRequest* request;</a>
<a name="ln2725">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln2726">	if (error != B_OK)</a>
<a name="ln2727">		return error;</a>
<a name="ln2728"> </a>
<a name="ln2729">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln2730">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln2731">	error = allocator.AllocateString(request-&gt;name, name);</a>
<a name="ln2732">	request-&gt;type = type;</a>
<a name="ln2733">	request-&gt;openMode = openMode;</a>
<a name="ln2734">	if (error != B_OK)</a>
<a name="ln2735">		return error;</a>
<a name="ln2736"> </a>
<a name="ln2737">	// send the request</a>
<a name="ln2738">	KernelRequestHandler handler(this, CREATE_ATTR_REPLY);</a>
<a name="ln2739">	CreateAttrReply* reply;</a>
<a name="ln2740">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln2741">	if (error != B_OK)</a>
<a name="ln2742">		return error;</a>
<a name="ln2743">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln2744"> </a>
<a name="ln2745">	// process the reply</a>
<a name="ln2746">	if (reply-&gt;error != B_OK)</a>
<a name="ln2747">		return reply-&gt;error;</a>
<a name="ln2748">	incrementer.Keep();</a>
<a name="ln2749">	*cookie = reply-&gt;attrCookie;</a>
<a name="ln2750">	return error;</a>
<a name="ln2751">}</a>
<a name="ln2752"> </a>
<a name="ln2753">// OpenAttr</a>
<a name="ln2754">status_t</a>
<a name="ln2755">Volume::OpenAttr(void* _node, const char* name, int openMode,</a>
<a name="ln2756">	void** cookie)</a>
<a name="ln2757">{</a>
<a name="ln2758">	VNode* vnode = (VNode*)_node;</a>
<a name="ln2759"> </a>
<a name="ln2760">	// check capability</a>
<a name="ln2761">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_OPEN_ATTR))</a>
<a name="ln2762">		return B_BAD_VALUE;</a>
<a name="ln2763"> </a>
<a name="ln2764">	// get a free port</a>
<a name="ln2765">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln2766">	if (!port)</a>
<a name="ln2767">		return B_ERROR;</a>
<a name="ln2768">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln2769">	AutoIncrementer incrementer(&amp;fOpenAttributes);</a>
<a name="ln2770"> </a>
<a name="ln2771">	// prepare the request</a>
<a name="ln2772">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln2773">	OpenAttrRequest* request;</a>
<a name="ln2774">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln2775">	if (error != B_OK)</a>
<a name="ln2776">		return error;</a>
<a name="ln2777"> </a>
<a name="ln2778">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln2779">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln2780">	error = allocator.AllocateString(request-&gt;name, name);</a>
<a name="ln2781">	request-&gt;openMode = openMode;</a>
<a name="ln2782">	if (error != B_OK)</a>
<a name="ln2783">		return error;</a>
<a name="ln2784"> </a>
<a name="ln2785">	// send the request</a>
<a name="ln2786">	KernelRequestHandler handler(this, OPEN_ATTR_REPLY);</a>
<a name="ln2787">	OpenAttrReply* reply;</a>
<a name="ln2788">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln2789">	if (error != B_OK)</a>
<a name="ln2790">		return error;</a>
<a name="ln2791">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln2792"> </a>
<a name="ln2793">	// process the reply</a>
<a name="ln2794">	if (reply-&gt;error != B_OK)</a>
<a name="ln2795">		return reply-&gt;error;</a>
<a name="ln2796">	incrementer.Keep();</a>
<a name="ln2797">	*cookie = reply-&gt;attrCookie;</a>
<a name="ln2798">	return error;</a>
<a name="ln2799">}</a>
<a name="ln2800"> </a>
<a name="ln2801">// CloseAttr</a>
<a name="ln2802">status_t</a>
<a name="ln2803">Volume::CloseAttr(void* node, void* cookie)</a>
<a name="ln2804">{</a>
<a name="ln2805">	status_t error = _CloseAttr(node, cookie);</a>
<a name="ln2806">	if (error != B_OK &amp;&amp; fFileSystem-&gt;GetPortPool()-&gt;IsDisconnected()) {</a>
<a name="ln2807">		// This isn't really necessary, as the return value is irrelevant to</a>
<a name="ln2808">		// the VFS. OBOS ignores it completely. The fsshell returns it to the</a>
<a name="ln2809">		// userland, but considers the node closed anyway.</a>
<a name="ln2810">		WARN((&quot;Volume::CloseAttr(): connection lost, forcing close attr\n&quot;));</a>
<a name="ln2811">		return B_OK;</a>
<a name="ln2812">	}</a>
<a name="ln2813">	return error;</a>
<a name="ln2814">}</a>
<a name="ln2815"> </a>
<a name="ln2816">// FreeAttrCookie</a>
<a name="ln2817">status_t</a>
<a name="ln2818">Volume::FreeAttrCookie(void* node, void* cookie)</a>
<a name="ln2819">{</a>
<a name="ln2820">	status_t error = _FreeAttrCookie(node, cookie);</a>
<a name="ln2821">	bool disconnected = false;</a>
<a name="ln2822">	if (error != B_OK &amp;&amp; fFileSystem-&gt;GetPortPool()-&gt;IsDisconnected()) {</a>
<a name="ln2823">		// This isn't really necessary, as the return value is irrelevant to</a>
<a name="ln2824">		// the VFS. It's completely ignored by OBOS as well as by the fsshell.</a>
<a name="ln2825">		WARN((&quot;Volume::FreeAttrCookie(): connection lost, forcing free attr &quot;</a>
<a name="ln2826">			&quot;cookie\n&quot;));</a>
<a name="ln2827">		error = B_OK;</a>
<a name="ln2828">		disconnected = true;</a>
<a name="ln2829">	}</a>
<a name="ln2830"> </a>
<a name="ln2831">	int32 openAttributes = atomic_add(&amp;fOpenAttributes, -1);</a>
<a name="ln2832">	if (openAttributes &lt;= 1 &amp;&amp; disconnected)</a>
<a name="ln2833">		_PutAllPendingVNodes();</a>
<a name="ln2834">	return error;</a>
<a name="ln2835">}</a>
<a name="ln2836"> </a>
<a name="ln2837">// ReadAttr</a>
<a name="ln2838">status_t</a>
<a name="ln2839">Volume::ReadAttr(void* _node, void* cookie, off_t pos,</a>
<a name="ln2840">	void* buffer, size_t bufferSize, size_t* bytesRead)</a>
<a name="ln2841">{</a>
<a name="ln2842">	VNode* vnode = (VNode*)_node;</a>
<a name="ln2843"> </a>
<a name="ln2844">	*bytesRead = 0;</a>
<a name="ln2845"> </a>
<a name="ln2846">	// check capability</a>
<a name="ln2847">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_READ_ATTR))</a>
<a name="ln2848">		return B_BAD_VALUE;</a>
<a name="ln2849"> </a>
<a name="ln2850">	// get a free port</a>
<a name="ln2851">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln2852">	if (!port)</a>
<a name="ln2853">		return B_ERROR;</a>
<a name="ln2854">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln2855"> </a>
<a name="ln2856">	// prepare the request</a>
<a name="ln2857">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln2858">	ReadAttrRequest* request;</a>
<a name="ln2859">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln2860">	if (error != B_OK)</a>
<a name="ln2861">		return error;</a>
<a name="ln2862"> </a>
<a name="ln2863">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln2864">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln2865">	request-&gt;attrCookie = cookie;</a>
<a name="ln2866">	request-&gt;pos = pos;</a>
<a name="ln2867">	request-&gt;size = bufferSize;</a>
<a name="ln2868"> </a>
<a name="ln2869">	// send the request</a>
<a name="ln2870">	KernelRequestHandler handler(this, READ_ATTR_REPLY);</a>
<a name="ln2871">	ReadAttrReply* reply;</a>
<a name="ln2872">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln2873">	if (error != B_OK)</a>
<a name="ln2874">		return error;</a>
<a name="ln2875">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln2876"> </a>
<a name="ln2877">	// process the reply</a>
<a name="ln2878">	if (reply-&gt;error != B_OK)</a>
<a name="ln2879">		return reply-&gt;error;</a>
<a name="ln2880">	void* readBuffer = reply-&gt;buffer.GetData();</a>
<a name="ln2881">	if (reply-&gt;bytesRead &gt; (uint32)reply-&gt;buffer.GetSize()</a>
<a name="ln2882">		|| reply-&gt;bytesRead &gt; bufferSize) {</a>
<a name="ln2883">		return B_BAD_DATA;</a>
<a name="ln2884">	}</a>
<a name="ln2885">	if (reply-&gt;bytesRead &gt; 0)</a>
<a name="ln2886">		memcpy(buffer, readBuffer, reply-&gt;bytesRead);</a>
<a name="ln2887">	*bytesRead = reply-&gt;bytesRead;</a>
<a name="ln2888">	_SendReceiptAck(port);</a>
<a name="ln2889">	return error;</a>
<a name="ln2890">}</a>
<a name="ln2891"> </a>
<a name="ln2892">// WriteAttr</a>
<a name="ln2893">status_t</a>
<a name="ln2894">Volume::WriteAttr(void* _node, void* cookie, off_t pos,</a>
<a name="ln2895">	const void* buffer, size_t bufferSize, size_t* bytesWritten)</a>
<a name="ln2896">{</a>
<a name="ln2897">	VNode* vnode = (VNode*)_node;</a>
<a name="ln2898"> </a>
<a name="ln2899">	*bytesWritten = 0;</a>
<a name="ln2900"> </a>
<a name="ln2901">	// check capability</a>
<a name="ln2902">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_WRITE_ATTR))</a>
<a name="ln2903">		return B_BAD_VALUE;</a>
<a name="ln2904"> </a>
<a name="ln2905">	// get a free port</a>
<a name="ln2906">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln2907">	if (!port)</a>
<a name="ln2908">		return B_ERROR;</a>
<a name="ln2909">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln2910"> </a>
<a name="ln2911">	// prepare the request</a>
<a name="ln2912">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln2913">	WriteAttrRequest* request;</a>
<a name="ln2914">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln2915">	if (error != B_OK)</a>
<a name="ln2916">		return error;</a>
<a name="ln2917"> </a>
<a name="ln2918">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln2919">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln2920">	request-&gt;attrCookie = cookie;</a>
<a name="ln2921">	request-&gt;pos = pos;</a>
<a name="ln2922">	error = allocator.AllocateData(request-&gt;buffer, buffer, bufferSize, 1);</a>
<a name="ln2923">	if (error != B_OK)</a>
<a name="ln2924">		return error;</a>
<a name="ln2925"> </a>
<a name="ln2926">	// send the request</a>
<a name="ln2927">	KernelRequestHandler handler(this, WRITE_ATTR_REPLY);</a>
<a name="ln2928">	WriteAttrReply* reply;</a>
<a name="ln2929">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln2930">	if (error != B_OK)</a>
<a name="ln2931">		return error;</a>
<a name="ln2932">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln2933"> </a>
<a name="ln2934">	// process the reply</a>
<a name="ln2935">	if (reply-&gt;error != B_OK)</a>
<a name="ln2936">		return reply-&gt;error;</a>
<a name="ln2937">	*bytesWritten = reply-&gt;bytesWritten;</a>
<a name="ln2938">	return error;</a>
<a name="ln2939">}</a>
<a name="ln2940"> </a>
<a name="ln2941">// ReadAttrStat</a>
<a name="ln2942">status_t</a>
<a name="ln2943">Volume::ReadAttrStat(void* _node, void* cookie, struct stat *st)</a>
<a name="ln2944">{</a>
<a name="ln2945">	VNode* vnode = (VNode*)_node;</a>
<a name="ln2946"> </a>
<a name="ln2947">	// check capability</a>
<a name="ln2948">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_READ_ATTR_STAT))</a>
<a name="ln2949">		return B_BAD_VALUE;</a>
<a name="ln2950"> </a>
<a name="ln2951">	// get a free port</a>
<a name="ln2952">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln2953">	if (!port)</a>
<a name="ln2954">		return B_ERROR;</a>
<a name="ln2955">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln2956"> </a>
<a name="ln2957">	// prepare the request</a>
<a name="ln2958">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln2959">	ReadAttrStatRequest* request;</a>
<a name="ln2960">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln2961">	if (error != B_OK)</a>
<a name="ln2962">		return error;</a>
<a name="ln2963"> </a>
<a name="ln2964">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln2965">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln2966">	request-&gt;attrCookie = cookie;</a>
<a name="ln2967"> </a>
<a name="ln2968">	// send the request</a>
<a name="ln2969">	KernelRequestHandler handler(this, READ_ATTR_STAT_REPLY);</a>
<a name="ln2970">	ReadAttrStatReply* reply;</a>
<a name="ln2971">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln2972">	if (error != B_OK)</a>
<a name="ln2973">		return error;</a>
<a name="ln2974">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln2975"> </a>
<a name="ln2976">	// process the reply</a>
<a name="ln2977">	if (reply-&gt;error != B_OK)</a>
<a name="ln2978">		return reply-&gt;error;</a>
<a name="ln2979">	*st = reply-&gt;st;</a>
<a name="ln2980">	return error;</a>
<a name="ln2981">}</a>
<a name="ln2982"> </a>
<a name="ln2983">// WriteAttrStat</a>
<a name="ln2984">status_t</a>
<a name="ln2985">Volume::WriteAttrStat(void* _node, void* cookie, const struct stat *st,</a>
<a name="ln2986">	int statMask)</a>
<a name="ln2987">{</a>
<a name="ln2988">	VNode* vnode = (VNode*)_node;</a>
<a name="ln2989"> </a>
<a name="ln2990">	// check capability</a>
<a name="ln2991">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_WRITE_ATTR_STAT))</a>
<a name="ln2992">		return B_BAD_VALUE;</a>
<a name="ln2993"> </a>
<a name="ln2994">	// get a free port</a>
<a name="ln2995">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln2996">	if (!port)</a>
<a name="ln2997">		return B_ERROR;</a>
<a name="ln2998">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln2999"> </a>
<a name="ln3000">	// prepare the request</a>
<a name="ln3001">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln3002">	WriteAttrStatRequest* request;</a>
<a name="ln3003">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln3004">	if (error != B_OK)</a>
<a name="ln3005">		return error;</a>
<a name="ln3006"> </a>
<a name="ln3007">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln3008">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln3009">	request-&gt;attrCookie = cookie;</a>
<a name="ln3010">	request-&gt;st = *st;</a>
<a name="ln3011">	request-&gt;mask = statMask;</a>
<a name="ln3012"> </a>
<a name="ln3013">	// send the request</a>
<a name="ln3014">	KernelRequestHandler handler(this, WRITE_ATTR_STAT_REPLY);</a>
<a name="ln3015">	WriteAttrStatReply* reply;</a>
<a name="ln3016">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln3017">	if (error != B_OK)</a>
<a name="ln3018">		return error;</a>
<a name="ln3019">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln3020"> </a>
<a name="ln3021">	// process the reply</a>
<a name="ln3022">	if (reply-&gt;error != B_OK)</a>
<a name="ln3023">		return reply-&gt;error;</a>
<a name="ln3024">	return error;</a>
<a name="ln3025">}</a>
<a name="ln3026"> </a>
<a name="ln3027">// RenameAttr</a>
<a name="ln3028">status_t</a>
<a name="ln3029">Volume::RenameAttr(void* _oldNode, const char* oldName, void* _newNode,</a>
<a name="ln3030">	const char* newName)</a>
<a name="ln3031">{</a>
<a name="ln3032">	VNode* oldVNode = (VNode*)_oldNode;</a>
<a name="ln3033">	VNode* newVNode = (VNode*)_newNode;</a>
<a name="ln3034"> </a>
<a name="ln3035">	// check capability</a>
<a name="ln3036">	if (!HasVNodeCapability(oldVNode, FS_VNODE_CAPABILITY_RENAME_ATTR))</a>
<a name="ln3037">		return B_BAD_VALUE;</a>
<a name="ln3038"> </a>
<a name="ln3039">	// get a free port</a>
<a name="ln3040">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln3041">	if (!port)</a>
<a name="ln3042">		return B_ERROR;</a>
<a name="ln3043">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln3044"> </a>
<a name="ln3045">	// prepare the request</a>
<a name="ln3046">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln3047">	RenameAttrRequest* request;</a>
<a name="ln3048">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln3049">	if (error != B_OK)</a>
<a name="ln3050">		return error;</a>
<a name="ln3051"> </a>
<a name="ln3052">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln3053">	request-&gt;oldNode = oldVNode-&gt;clientNode;</a>
<a name="ln3054">	request-&gt;newNode = newVNode-&gt;clientNode;</a>
<a name="ln3055">	error = allocator.AllocateString(request-&gt;oldName, oldName);</a>
<a name="ln3056">	if (error == B_OK)</a>
<a name="ln3057">		error = allocator.AllocateString(request-&gt;newName, newName);</a>
<a name="ln3058">	if (error != B_OK)</a>
<a name="ln3059">		return error;</a>
<a name="ln3060"> </a>
<a name="ln3061">	// send the request</a>
<a name="ln3062">	KernelRequestHandler handler(this, RENAME_ATTR_REPLY);</a>
<a name="ln3063">	RenameAttrReply* reply;</a>
<a name="ln3064">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln3065">	if (error != B_OK)</a>
<a name="ln3066">		return error;</a>
<a name="ln3067">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln3068"> </a>
<a name="ln3069">	// process the reply</a>
<a name="ln3070">	if (reply-&gt;error != B_OK)</a>
<a name="ln3071">		return reply-&gt;error;</a>
<a name="ln3072">	return error;</a>
<a name="ln3073">}</a>
<a name="ln3074"> </a>
<a name="ln3075">// RemoveAttr</a>
<a name="ln3076">status_t</a>
<a name="ln3077">Volume::RemoveAttr(void* _node, const char* name)</a>
<a name="ln3078">{</a>
<a name="ln3079">	VNode* vnode = (VNode*)_node;</a>
<a name="ln3080"> </a>
<a name="ln3081">	// check capability</a>
<a name="ln3082">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_REMOVE_ATTR))</a>
<a name="ln3083">		return B_BAD_VALUE;</a>
<a name="ln3084"> </a>
<a name="ln3085">	// get a free port</a>
<a name="ln3086">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln3087">	if (!port)</a>
<a name="ln3088">		return B_ERROR;</a>
<a name="ln3089">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln3090"> </a>
<a name="ln3091">	// prepare the request</a>
<a name="ln3092">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln3093">	RemoveAttrRequest* request;</a>
<a name="ln3094">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln3095">	if (error != B_OK)</a>
<a name="ln3096">		return error;</a>
<a name="ln3097"> </a>
<a name="ln3098">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln3099">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln3100">	error = allocator.AllocateString(request-&gt;name, name);</a>
<a name="ln3101">	if (error != B_OK)</a>
<a name="ln3102">		return error;</a>
<a name="ln3103"> </a>
<a name="ln3104">	// send the request</a>
<a name="ln3105">	KernelRequestHandler handler(this, REMOVE_ATTR_REPLY);</a>
<a name="ln3106">	RemoveAttrReply* reply;</a>
<a name="ln3107">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln3108">	if (error != B_OK)</a>
<a name="ln3109">		return error;</a>
<a name="ln3110">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln3111"> </a>
<a name="ln3112">	// process the reply</a>
<a name="ln3113">	if (reply-&gt;error != B_OK)</a>
<a name="ln3114">		return reply-&gt;error;</a>
<a name="ln3115">	return error;</a>
<a name="ln3116">}</a>
<a name="ln3117"> </a>
<a name="ln3118"> </a>
<a name="ln3119">// #pragma mark - indices</a>
<a name="ln3120"> </a>
<a name="ln3121"> </a>
<a name="ln3122">// OpenIndexDir</a>
<a name="ln3123">status_t</a>
<a name="ln3124">Volume::OpenIndexDir(void** cookie)</a>
<a name="ln3125">{</a>
<a name="ln3126">	// check capability</a>
<a name="ln3127">	if (!HasCapability(FS_VOLUME_CAPABILITY_OPEN_INDEX_DIR))</a>
<a name="ln3128">		return B_BAD_VALUE;</a>
<a name="ln3129"> </a>
<a name="ln3130">	// get a free port</a>
<a name="ln3131">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln3132">	if (!port)</a>
<a name="ln3133">		return B_ERROR;</a>
<a name="ln3134">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln3135">	AutoIncrementer incrementer(&amp;fOpenIndexDirectories);</a>
<a name="ln3136"> </a>
<a name="ln3137">	// prepare the request</a>
<a name="ln3138">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln3139">	OpenIndexDirRequest* request;</a>
<a name="ln3140">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln3141">	if (error != B_OK)</a>
<a name="ln3142">		return error;</a>
<a name="ln3143"> </a>
<a name="ln3144">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln3145"> </a>
<a name="ln3146">	// send the request</a>
<a name="ln3147">	KernelRequestHandler handler(this, OPEN_INDEX_DIR_REPLY);</a>
<a name="ln3148">	OpenIndexDirReply* reply;</a>
<a name="ln3149">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln3150">	if (error != B_OK)</a>
<a name="ln3151">		return error;</a>
<a name="ln3152">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln3153"> </a>
<a name="ln3154">	// process the reply</a>
<a name="ln3155">	if (reply-&gt;error != B_OK)</a>
<a name="ln3156">		return reply-&gt;error;</a>
<a name="ln3157">	incrementer.Keep();</a>
<a name="ln3158">	*cookie = reply-&gt;indexDirCookie;</a>
<a name="ln3159">	return error;</a>
<a name="ln3160">}</a>
<a name="ln3161"> </a>
<a name="ln3162">// CloseIndexDir</a>
<a name="ln3163">status_t</a>
<a name="ln3164">Volume::CloseIndexDir(void* cookie)</a>
<a name="ln3165">{</a>
<a name="ln3166">	status_t error = _CloseIndexDir(cookie);</a>
<a name="ln3167">	if (error != B_OK &amp;&amp; fFileSystem-&gt;GetPortPool()-&gt;IsDisconnected()) {</a>
<a name="ln3168">		// This isn't really necessary, as the return value is irrelevant to</a>
<a name="ln3169">		// the VFS. OBOS ignores it completely. The fsshell returns it to the</a>
<a name="ln3170">		// userland, but considers the node closed anyway.</a>
<a name="ln3171">		WARN((&quot;Volume::CloseIndexDir(): connection lost, forcing close &quot;</a>
<a name="ln3172">			&quot;index dir\n&quot;));</a>
<a name="ln3173">		return B_OK;</a>
<a name="ln3174">	}</a>
<a name="ln3175">	return error;</a>
<a name="ln3176">}</a>
<a name="ln3177"> </a>
<a name="ln3178">// FreeIndexDirCookie</a>
<a name="ln3179">status_t</a>
<a name="ln3180">Volume::FreeIndexDirCookie(void* cookie)</a>
<a name="ln3181">{</a>
<a name="ln3182">	status_t error = _FreeIndexDirCookie(cookie);</a>
<a name="ln3183">	bool disconnected = false;</a>
<a name="ln3184">	if (error != B_OK &amp;&amp; fFileSystem-&gt;GetPortPool()-&gt;IsDisconnected()) {</a>
<a name="ln3185">		// This isn't really necessary, as the return value is irrelevant to</a>
<a name="ln3186">		// the VFS. It's completely ignored by OBOS as well as by the fsshell.</a>
<a name="ln3187">		WARN((&quot;Volume::FreeIndexDirCookie(): connection lost, forcing free &quot;</a>
<a name="ln3188">			&quot;index dir cookie\n&quot;));</a>
<a name="ln3189">		error = B_OK;</a>
<a name="ln3190">		disconnected = true;</a>
<a name="ln3191">	}</a>
<a name="ln3192"> </a>
<a name="ln3193">	int32 openIndexDirs = atomic_add(&amp;fOpenIndexDirectories, -1);</a>
<a name="ln3194">	if (openIndexDirs &lt;= 1 &amp;&amp; disconnected)</a>
<a name="ln3195">		_PutAllPendingVNodes();</a>
<a name="ln3196">	return error;</a>
<a name="ln3197">}</a>
<a name="ln3198"> </a>
<a name="ln3199">// ReadIndexDir</a>
<a name="ln3200">status_t</a>
<a name="ln3201">Volume::ReadIndexDir(void* cookie, void* buffer, size_t bufferSize,</a>
<a name="ln3202">	uint32 count, uint32* countRead)</a>
<a name="ln3203">{</a>
<a name="ln3204">	*countRead = 0;</a>
<a name="ln3205"> </a>
<a name="ln3206">	// check capability</a>
<a name="ln3207">	if (!HasCapability(FS_VOLUME_CAPABILITY_READ_INDEX_DIR))</a>
<a name="ln3208">		return B_BAD_VALUE;</a>
<a name="ln3209"> </a>
<a name="ln3210">	// get a free port</a>
<a name="ln3211">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln3212">	if (!port)</a>
<a name="ln3213">		return B_ERROR;</a>
<a name="ln3214">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln3215"> </a>
<a name="ln3216">	// prepare the request</a>
<a name="ln3217">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln3218">	ReadIndexDirRequest* request;</a>
<a name="ln3219">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln3220">	if (error != B_OK)</a>
<a name="ln3221">		return error;</a>
<a name="ln3222"> </a>
<a name="ln3223">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln3224">	request-&gt;indexDirCookie = cookie;</a>
<a name="ln3225">	request-&gt;bufferSize = bufferSize;</a>
<a name="ln3226">	request-&gt;count = count;</a>
<a name="ln3227"> </a>
<a name="ln3228">	// send the request</a>
<a name="ln3229">	KernelRequestHandler handler(this, READ_INDEX_DIR_REPLY);</a>
<a name="ln3230">	ReadIndexDirReply* reply;</a>
<a name="ln3231">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln3232">	if (error != B_OK)</a>
<a name="ln3233">		return error;</a>
<a name="ln3234">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln3235"> </a>
<a name="ln3236">	// process the reply</a>
<a name="ln3237">	if (reply-&gt;error != B_OK)</a>
<a name="ln3238">		return reply-&gt;error;</a>
<a name="ln3239">	if (reply-&gt;count &lt; 0 || reply-&gt;count &gt; count)</a>
<a name="ln3240">		return B_BAD_DATA;</a>
<a name="ln3241">	if ((int32)bufferSize &lt; reply-&gt;buffer.GetSize())</a>
<a name="ln3242">		return B_BAD_DATA;</a>
<a name="ln3243"> </a>
<a name="ln3244">	*countRead = reply-&gt;count;</a>
<a name="ln3245">	if (*countRead &gt; 0) {</a>
<a name="ln3246">		// copy the buffer -- limit the number of bytes to copy</a>
<a name="ln3247">		uint32 maxBytes = *countRead</a>
<a name="ln3248">			* (sizeof(struct dirent) + B_FILE_NAME_LENGTH);</a>
<a name="ln3249">		uint32 copyBytes = reply-&gt;buffer.GetSize();</a>
<a name="ln3250">		if (copyBytes &gt; maxBytes)</a>
<a name="ln3251">			copyBytes = maxBytes;</a>
<a name="ln3252">		memcpy(buffer, reply-&gt;buffer.GetData(), copyBytes);</a>
<a name="ln3253">	}</a>
<a name="ln3254">	_SendReceiptAck(port);</a>
<a name="ln3255">	return error;</a>
<a name="ln3256">}</a>
<a name="ln3257"> </a>
<a name="ln3258">// RewindIndexDir</a>
<a name="ln3259">status_t</a>
<a name="ln3260">Volume::RewindIndexDir(void* cookie)</a>
<a name="ln3261">{</a>
<a name="ln3262">	// check capability</a>
<a name="ln3263">	if (!HasCapability(FS_VOLUME_CAPABILITY_REWIND_INDEX_DIR))</a>
<a name="ln3264">		return B_BAD_VALUE;</a>
<a name="ln3265"> </a>
<a name="ln3266">	// get a free port</a>
<a name="ln3267">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln3268">	if (!port)</a>
<a name="ln3269">		return B_ERROR;</a>
<a name="ln3270">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln3271"> </a>
<a name="ln3272">	// prepare the request</a>
<a name="ln3273">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln3274">	RewindIndexDirRequest* request;</a>
<a name="ln3275">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln3276">	if (error != B_OK)</a>
<a name="ln3277">		return error;</a>
<a name="ln3278"> </a>
<a name="ln3279">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln3280">	request-&gt;indexDirCookie = cookie;</a>
<a name="ln3281"> </a>
<a name="ln3282">	// send the request</a>
<a name="ln3283">	KernelRequestHandler handler(this, REWIND_INDEX_DIR_REPLY);</a>
<a name="ln3284">	RewindIndexDirReply* reply;</a>
<a name="ln3285">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln3286">	if (error != B_OK)</a>
<a name="ln3287">		return error;</a>
<a name="ln3288">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln3289"> </a>
<a name="ln3290">	// process the reply</a>
<a name="ln3291">	if (reply-&gt;error != B_OK)</a>
<a name="ln3292">		return reply-&gt;error;</a>
<a name="ln3293">	return error;</a>
<a name="ln3294">}</a>
<a name="ln3295"> </a>
<a name="ln3296">// CreateIndex</a>
<a name="ln3297">status_t</a>
<a name="ln3298">Volume::CreateIndex(const char* name, uint32 type, uint32 flags)</a>
<a name="ln3299">{</a>
<a name="ln3300">	// check capability</a>
<a name="ln3301">	if (!HasCapability(FS_VOLUME_CAPABILITY_CREATE_INDEX))</a>
<a name="ln3302">		return B_BAD_VALUE;</a>
<a name="ln3303"> </a>
<a name="ln3304">	// get a free port</a>
<a name="ln3305">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln3306">	if (!port)</a>
<a name="ln3307">		return B_ERROR;</a>
<a name="ln3308">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln3309"> </a>
<a name="ln3310">	// prepare the request</a>
<a name="ln3311">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln3312">	CreateIndexRequest* request;</a>
<a name="ln3313">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln3314">	if (error != B_OK)</a>
<a name="ln3315">		return error;</a>
<a name="ln3316"> </a>
<a name="ln3317">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln3318">	error = allocator.AllocateString(request-&gt;name, name);</a>
<a name="ln3319">	request-&gt;type = type;</a>
<a name="ln3320">	request-&gt;flags = flags;</a>
<a name="ln3321">	if (error != B_OK)</a>
<a name="ln3322">		return error;</a>
<a name="ln3323"> </a>
<a name="ln3324">	// send the request</a>
<a name="ln3325">	KernelRequestHandler handler(this, CREATE_INDEX_REPLY);</a>
<a name="ln3326">	CreateIndexReply* reply;</a>
<a name="ln3327">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln3328">	if (error != B_OK)</a>
<a name="ln3329">		return error;</a>
<a name="ln3330">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln3331"> </a>
<a name="ln3332">	// process the reply</a>
<a name="ln3333">	if (reply-&gt;error != B_OK)</a>
<a name="ln3334">		return reply-&gt;error;</a>
<a name="ln3335">	return error;</a>
<a name="ln3336">}</a>
<a name="ln3337"> </a>
<a name="ln3338">// RemoveIndex</a>
<a name="ln3339">status_t</a>
<a name="ln3340">Volume::RemoveIndex(const char* name)</a>
<a name="ln3341">{</a>
<a name="ln3342">	// check capability</a>
<a name="ln3343">	if (!HasCapability(FS_VOLUME_CAPABILITY_REMOVE_INDEX))</a>
<a name="ln3344">		return B_BAD_VALUE;</a>
<a name="ln3345"> </a>
<a name="ln3346">	// get a free port</a>
<a name="ln3347">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln3348">	if (!port)</a>
<a name="ln3349">		return B_ERROR;</a>
<a name="ln3350">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln3351"> </a>
<a name="ln3352">	// prepare the request</a>
<a name="ln3353">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln3354">	RemoveIndexRequest* request;</a>
<a name="ln3355">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln3356">	if (error != B_OK)</a>
<a name="ln3357">		return error;</a>
<a name="ln3358"> </a>
<a name="ln3359">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln3360">	error = allocator.AllocateString(request-&gt;name, name);</a>
<a name="ln3361">	if (error != B_OK)</a>
<a name="ln3362">		return error;</a>
<a name="ln3363"> </a>
<a name="ln3364">	// send the request</a>
<a name="ln3365">	KernelRequestHandler handler(this, REMOVE_INDEX_REPLY);</a>
<a name="ln3366">	RemoveIndexReply* reply;</a>
<a name="ln3367">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln3368">	if (error != B_OK)</a>
<a name="ln3369">		return error;</a>
<a name="ln3370">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln3371"> </a>
<a name="ln3372">	// process the reply</a>
<a name="ln3373">	if (reply-&gt;error != B_OK)</a>
<a name="ln3374">		return reply-&gt;error;</a>
<a name="ln3375">	return error;</a>
<a name="ln3376">}</a>
<a name="ln3377"> </a>
<a name="ln3378">// ReadIndexStat</a>
<a name="ln3379">status_t</a>
<a name="ln3380">Volume::ReadIndexStat(const char* name, struct stat *st)</a>
<a name="ln3381">{</a>
<a name="ln3382">	// check capability</a>
<a name="ln3383">	if (!HasCapability(FS_VOLUME_CAPABILITY_READ_INDEX_STAT))</a>
<a name="ln3384">		return B_BAD_VALUE;</a>
<a name="ln3385"> </a>
<a name="ln3386">	// get a free port</a>
<a name="ln3387">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln3388">	if (!port)</a>
<a name="ln3389">		return B_ERROR;</a>
<a name="ln3390">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln3391"> </a>
<a name="ln3392">	// prepare the request</a>
<a name="ln3393">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln3394">	ReadIndexStatRequest* request;</a>
<a name="ln3395">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln3396">	if (error != B_OK)</a>
<a name="ln3397">		return error;</a>
<a name="ln3398"> </a>
<a name="ln3399">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln3400">	error = allocator.AllocateString(request-&gt;name, name);</a>
<a name="ln3401">	if (error != B_OK)</a>
<a name="ln3402">		return error;</a>
<a name="ln3403"> </a>
<a name="ln3404">	// send the request</a>
<a name="ln3405">	KernelRequestHandler handler(this, READ_INDEX_STAT_REPLY);</a>
<a name="ln3406">	ReadIndexStatReply* reply;</a>
<a name="ln3407">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln3408">	if (error != B_OK)</a>
<a name="ln3409">		return error;</a>
<a name="ln3410">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln3411"> </a>
<a name="ln3412">	// process the reply</a>
<a name="ln3413">	if (reply-&gt;error != B_OK)</a>
<a name="ln3414">		return reply-&gt;error;</a>
<a name="ln3415">	*st = reply-&gt;st;</a>
<a name="ln3416">	return error;</a>
<a name="ln3417">}</a>
<a name="ln3418"> </a>
<a name="ln3419"> </a>
<a name="ln3420">// #pragma mark - queries</a>
<a name="ln3421"> </a>
<a name="ln3422"> </a>
<a name="ln3423">// OpenQuery</a>
<a name="ln3424">status_t</a>
<a name="ln3425">Volume::OpenQuery(const char* queryString, uint32 flags, port_id targetPort,</a>
<a name="ln3426">	uint32 token, void** cookie)</a>
<a name="ln3427">{</a>
<a name="ln3428">	// check capability</a>
<a name="ln3429">	if (!HasCapability(FS_VOLUME_CAPABILITY_OPEN_QUERY))</a>
<a name="ln3430">		return B_BAD_VALUE;</a>
<a name="ln3431"> </a>
<a name="ln3432">	// get a free port</a>
<a name="ln3433">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln3434">	if (!port)</a>
<a name="ln3435">		return B_ERROR;</a>
<a name="ln3436">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln3437">	AutoIncrementer incrementer(&amp;fOpenQueries);</a>
<a name="ln3438"> </a>
<a name="ln3439">	// prepare the request</a>
<a name="ln3440">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln3441">	OpenQueryRequest* request;</a>
<a name="ln3442">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln3443">	if (error != B_OK)</a>
<a name="ln3444">		return error;</a>
<a name="ln3445"> </a>
<a name="ln3446">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln3447">	error = allocator.AllocateString(request-&gt;queryString, queryString);</a>
<a name="ln3448">	if (error != B_OK)</a>
<a name="ln3449">		return error;</a>
<a name="ln3450">	request-&gt;flags = flags;</a>
<a name="ln3451">	request-&gt;port = targetPort;</a>
<a name="ln3452">	request-&gt;token = token;</a>
<a name="ln3453"> </a>
<a name="ln3454">	// send the request</a>
<a name="ln3455">	KernelRequestHandler handler(this, OPEN_QUERY_REPLY);</a>
<a name="ln3456">	OpenQueryReply* reply;</a>
<a name="ln3457">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln3458">	if (error != B_OK)</a>
<a name="ln3459">		return error;</a>
<a name="ln3460">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln3461"> </a>
<a name="ln3462">	// process the reply</a>
<a name="ln3463">	if (reply-&gt;error != B_OK)</a>
<a name="ln3464">		return reply-&gt;error;</a>
<a name="ln3465">	incrementer.Keep();</a>
<a name="ln3466">	*cookie = reply-&gt;queryCookie;</a>
<a name="ln3467">	return error;</a>
<a name="ln3468">}</a>
<a name="ln3469"> </a>
<a name="ln3470">// CloseQuery</a>
<a name="ln3471">status_t</a>
<a name="ln3472">Volume::CloseQuery(void* cookie)</a>
<a name="ln3473">{</a>
<a name="ln3474">	status_t error = _CloseQuery(cookie);</a>
<a name="ln3475">	if (error != B_OK &amp;&amp; fFileSystem-&gt;GetPortPool()-&gt;IsDisconnected()) {</a>
<a name="ln3476">		// This isn't really necessary, as the return value is irrelevant to</a>
<a name="ln3477">		// the VFS. OBOS ignores it completely. The fsshell returns it to the</a>
<a name="ln3478">		// userland, but considers the node closed anyway.</a>
<a name="ln3479">		WARN((&quot;Volume::CloseQuery(): connection lost, forcing close query\n&quot;));</a>
<a name="ln3480">		return B_OK;</a>
<a name="ln3481">	}</a>
<a name="ln3482">	return error;</a>
<a name="ln3483">}</a>
<a name="ln3484"> </a>
<a name="ln3485">// FreeQueryCookie</a>
<a name="ln3486">status_t</a>
<a name="ln3487">Volume::FreeQueryCookie(void* cookie)</a>
<a name="ln3488">{</a>
<a name="ln3489">	status_t error = _FreeQueryCookie(cookie);</a>
<a name="ln3490">	bool disconnected = false;</a>
<a name="ln3491">	if (error != B_OK &amp;&amp; fFileSystem-&gt;GetPortPool()-&gt;IsDisconnected()) {</a>
<a name="ln3492">		// This isn't really necessary, as the return value is irrelevant to</a>
<a name="ln3493">		// the VFS. It's completely ignored by OBOS as well as by the fsshell.</a>
<a name="ln3494">		WARN((&quot;Volume::FreeQueryCookie(): connection lost, forcing free &quot;</a>
<a name="ln3495">			&quot;query cookie\n&quot;));</a>
<a name="ln3496">		error = B_OK;</a>
<a name="ln3497">		disconnected = true;</a>
<a name="ln3498">	}</a>
<a name="ln3499"> </a>
<a name="ln3500">	int32 openQueries = atomic_add(&amp;fOpenQueries, -1);</a>
<a name="ln3501">	if (openQueries &lt;= 1 &amp;&amp; disconnected)</a>
<a name="ln3502">		_PutAllPendingVNodes();</a>
<a name="ln3503">	return error;</a>
<a name="ln3504">}</a>
<a name="ln3505"> </a>
<a name="ln3506">// ReadQuery</a>
<a name="ln3507">status_t</a>
<a name="ln3508">Volume::ReadQuery(void* cookie, void* buffer, size_t bufferSize,</a>
<a name="ln3509">	uint32 count, uint32* countRead)</a>
<a name="ln3510">{</a>
<a name="ln3511">	*countRead = 0;</a>
<a name="ln3512"> </a>
<a name="ln3513">	// check capability</a>
<a name="ln3514">	if (!HasCapability(FS_VOLUME_CAPABILITY_READ_QUERY))</a>
<a name="ln3515">		return B_BAD_VALUE;</a>
<a name="ln3516"> </a>
<a name="ln3517">	// get a free port</a>
<a name="ln3518">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln3519">	if (!port)</a>
<a name="ln3520">		return B_ERROR;</a>
<a name="ln3521">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln3522"> </a>
<a name="ln3523">	// prepare the request</a>
<a name="ln3524">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln3525">	ReadQueryRequest* request;</a>
<a name="ln3526">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln3527">	if (error != B_OK)</a>
<a name="ln3528">		return error;</a>
<a name="ln3529"> </a>
<a name="ln3530">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln3531">	request-&gt;queryCookie = cookie;</a>
<a name="ln3532">	request-&gt;bufferSize = bufferSize;</a>
<a name="ln3533">	request-&gt;count = count;</a>
<a name="ln3534"> </a>
<a name="ln3535">	// send the request</a>
<a name="ln3536">	KernelRequestHandler handler(this, READ_QUERY_REPLY);</a>
<a name="ln3537">	ReadQueryReply* reply;</a>
<a name="ln3538">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln3539">	if (error != B_OK)</a>
<a name="ln3540">		return error;</a>
<a name="ln3541">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln3542"> </a>
<a name="ln3543">	// process the reply</a>
<a name="ln3544">	if (reply-&gt;error != B_OK)</a>
<a name="ln3545">		return reply-&gt;error;</a>
<a name="ln3546">	if (reply-&gt;count &lt; 0 || reply-&gt;count &gt; count)</a>
<a name="ln3547">		return B_BAD_DATA;</a>
<a name="ln3548">	if ((int32)bufferSize &lt; reply-&gt;buffer.GetSize())</a>
<a name="ln3549">		return B_BAD_DATA;</a>
<a name="ln3550"> </a>
<a name="ln3551">	*countRead = reply-&gt;count;</a>
<a name="ln3552">	if (*countRead &gt; 0) {</a>
<a name="ln3553">		// copy the buffer -- limit the number of bytes to copy</a>
<a name="ln3554">		uint32 maxBytes = *countRead</a>
<a name="ln3555">			* (sizeof(struct dirent) + B_FILE_NAME_LENGTH);</a>
<a name="ln3556">		uint32 copyBytes = reply-&gt;buffer.GetSize();</a>
<a name="ln3557">		if (copyBytes &gt; maxBytes)</a>
<a name="ln3558">			copyBytes = maxBytes;</a>
<a name="ln3559">		memcpy(buffer, reply-&gt;buffer.GetData(), copyBytes);</a>
<a name="ln3560">	}</a>
<a name="ln3561">	_SendReceiptAck(port);</a>
<a name="ln3562">	return error;</a>
<a name="ln3563">}</a>
<a name="ln3564"> </a>
<a name="ln3565">// RewindQuery</a>
<a name="ln3566">status_t</a>
<a name="ln3567">Volume::RewindQuery(void* cookie)</a>
<a name="ln3568">{</a>
<a name="ln3569">	// check capability</a>
<a name="ln3570">	if (!HasCapability(FS_VOLUME_CAPABILITY_REWIND_QUERY))</a>
<a name="ln3571">		return B_BAD_VALUE;</a>
<a name="ln3572"> </a>
<a name="ln3573">	// get a free port</a>
<a name="ln3574">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln3575">	if (!port)</a>
<a name="ln3576">		return B_ERROR;</a>
<a name="ln3577">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln3578"> </a>
<a name="ln3579">	// prepare the request</a>
<a name="ln3580">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln3581">	RewindQueryRequest* request;</a>
<a name="ln3582">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln3583">	if (error != B_OK)</a>
<a name="ln3584">		return error;</a>
<a name="ln3585"> </a>
<a name="ln3586">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln3587">	request-&gt;queryCookie = cookie;</a>
<a name="ln3588"> </a>
<a name="ln3589">	// send the request</a>
<a name="ln3590">	KernelRequestHandler handler(this, REWIND_QUERY_REPLY);</a>
<a name="ln3591">	RewindQueryReply* reply;</a>
<a name="ln3592">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln3593">	if (error != B_OK)</a>
<a name="ln3594">		return error;</a>
<a name="ln3595">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln3596"> </a>
<a name="ln3597">	// process the reply</a>
<a name="ln3598">	if (reply-&gt;error != B_OK)</a>
<a name="ln3599">		return reply-&gt;error;</a>
<a name="ln3600">	return error;</a>
<a name="ln3601">}</a>
<a name="ln3602"> </a>
<a name="ln3603">// #pragma mark -</a>
<a name="ln3604">// #pragma mark ----- private implementations -----</a>
<a name="ln3605"> </a>
<a name="ln3606"> </a>
<a name="ln3607">// _InitVolumeOps</a>
<a name="ln3608">void</a>
<a name="ln3609">Volume::_InitVolumeOps()</a>
<a name="ln3610">{</a>
<a name="ln3611">	memcpy(&amp;fVolumeOps, &amp;gUserlandFSVolumeOps, sizeof(fs_volume_ops));</a>
<a name="ln3612"> </a>
<a name="ln3613">	#undef CLEAR_UNSUPPORTED</a>
<a name="ln3614">	#define CLEAR_UNSUPPORTED(capability, op) 	\</a>
<a name="ln3615">		if (!fCapabilities.Get(capability))				\</a>
<a name="ln3616">			fVolumeOps.op = NULL</a>
<a name="ln3617"> </a>
<a name="ln3618">	// FS operations</a>
<a name="ln3619">	// FS_VOLUME_CAPABILITY_UNMOUNT: unmount</a>
<a name="ln3620">		// always needed</a>
<a name="ln3621"> </a>
<a name="ln3622">	// FS_VOLUME_CAPABILITY_READ_FS_INFO: read_fs_info</a>
<a name="ln3623">		// always needed</a>
<a name="ln3624">	CLEAR_UNSUPPORTED(FS_VOLUME_CAPABILITY_WRITE_FS_INFO, write_fs_info);</a>
<a name="ln3625">	CLEAR_UNSUPPORTED(FS_VOLUME_CAPABILITY_SYNC, sync);</a>
<a name="ln3626"> </a>
<a name="ln3627">	// vnode operations</a>
<a name="ln3628">	// FS_VOLUME_CAPABILITY_GET_VNODE: get_vnode</a>
<a name="ln3629">		// always needed</a>
<a name="ln3630"> </a>
<a name="ln3631">	// index directory &amp; index operations</a>
<a name="ln3632">	CLEAR_UNSUPPORTED(FS_VOLUME_CAPABILITY_OPEN_INDEX_DIR, open_index_dir);</a>
<a name="ln3633">	// FS_VOLUME_CAPABILITY_CLOSE_INDEX_DIR: close_index_dir</a>
<a name="ln3634">		// always needed</a>
<a name="ln3635">	// FS_VOLUME_CAPABILITY_FREE_INDEX_DIR_COOKIE: free_index_dir_cookie</a>
<a name="ln3636">		// always needed</a>
<a name="ln3637">	CLEAR_UNSUPPORTED(FS_VOLUME_CAPABILITY_READ_INDEX_DIR, read_index_dir);</a>
<a name="ln3638">	CLEAR_UNSUPPORTED(FS_VOLUME_CAPABILITY_REWIND_INDEX_DIR, rewind_index_dir);</a>
<a name="ln3639"> </a>
<a name="ln3640">	CLEAR_UNSUPPORTED(FS_VOLUME_CAPABILITY_CREATE_INDEX, create_index);</a>
<a name="ln3641">	CLEAR_UNSUPPORTED(FS_VOLUME_CAPABILITY_REMOVE_INDEX, remove_index);</a>
<a name="ln3642">	CLEAR_UNSUPPORTED(FS_VOLUME_CAPABILITY_READ_INDEX_STAT, read_index_stat);</a>
<a name="ln3643"> </a>
<a name="ln3644">	// query operations</a>
<a name="ln3645">	CLEAR_UNSUPPORTED(FS_VOLUME_CAPABILITY_OPEN_QUERY, open_query);</a>
<a name="ln3646">	// FS_VOLUME_CAPABILITY_CLOSE_QUERY: close_query</a>
<a name="ln3647">		// always needed</a>
<a name="ln3648">	// FS_VOLUME_CAPABILITY_FREE_QUERY_COOKIE: free_query_cookie</a>
<a name="ln3649">		// always needed</a>
<a name="ln3650">	CLEAR_UNSUPPORTED(FS_VOLUME_CAPABILITY_READ_QUERY, read_query);</a>
<a name="ln3651">	CLEAR_UNSUPPORTED(FS_VOLUME_CAPABILITY_REWIND_QUERY, rewind_query);</a>
<a name="ln3652"> </a>
<a name="ln3653">	#undef CLEAR_UNSUPPORTED</a>
<a name="ln3654">}</a>
<a name="ln3655"> </a>
<a name="ln3656"> </a>
<a name="ln3657">// #pragma mark -</a>
<a name="ln3658"> </a>
<a name="ln3659"> </a>
<a name="ln3660">// _Mount</a>
<a name="ln3661">status_t</a>
<a name="ln3662">Volume::_Mount(const char* device, uint32 flags, const char* parameters)</a>
<a name="ln3663">{</a>
<a name="ln3664">	// get a free port</a>
<a name="ln3665">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln3666">	if (!port)</a>
<a name="ln3667">		return B_ERROR;</a>
<a name="ln3668">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln3669"> </a>
<a name="ln3670">	// get the current working directory</a>
<a name="ln3671">	char cwd[B_PATH_NAME_LENGTH];</a>
<a name="ln3672">	if (!getcwd(cwd, sizeof(cwd)))</a>
<a name="ln3673">		return errno;</a>
<a name="ln3674"> </a>
<a name="ln3675">	// prepare the request</a>
<a name="ln3676">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln3677">	MountVolumeRequest* request;</a>
<a name="ln3678">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln3679">	if (error != B_OK)</a>
<a name="ln3680">		return error;</a>
<a name="ln3681"> </a>
<a name="ln3682">	request-&gt;nsid = GetID();</a>
<a name="ln3683">	error = allocator.AllocateString(request-&gt;cwd, cwd);</a>
<a name="ln3684">	if (error == B_OK)</a>
<a name="ln3685">		error = allocator.AllocateString(request-&gt;device, device);</a>
<a name="ln3686">	request-&gt;flags = flags;</a>
<a name="ln3687">	if (error == B_OK)</a>
<a name="ln3688">		error = allocator.AllocateString(request-&gt;parameters, parameters);</a>
<a name="ln3689">	if (error != B_OK)</a>
<a name="ln3690">		return error;</a>
<a name="ln3691"> </a>
<a name="ln3692">	// send the request</a>
<a name="ln3693">	KernelRequestHandler handler(this, MOUNT_VOLUME_REPLY);</a>
<a name="ln3694">	MountVolumeReply* reply;</a>
<a name="ln3695">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln3696">	if (error != B_OK)</a>
<a name="ln3697">		return error;</a>
<a name="ln3698">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln3699"> </a>
<a name="ln3700">	// process the reply</a>
<a name="ln3701">	if (reply-&gt;error != B_OK)</a>
<a name="ln3702">		return reply-&gt;error;</a>
<a name="ln3703">	fRootID = reply-&gt;rootID;</a>
<a name="ln3704">	fUserlandVolume = reply-&gt;volume;</a>
<a name="ln3705">	fCapabilities = reply-&gt;capabilities;</a>
<a name="ln3706"> </a>
<a name="ln3707">	return error;</a>
<a name="ln3708">}</a>
<a name="ln3709"> </a>
<a name="ln3710">// _Unmount</a>
<a name="ln3711">status_t</a>
<a name="ln3712">Volume::_Unmount()</a>
<a name="ln3713">{</a>
<a name="ln3714">	// get a free port</a>
<a name="ln3715">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln3716">	if (!port)</a>
<a name="ln3717">		return B_ERROR;</a>
<a name="ln3718">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln3719"> </a>
<a name="ln3720">	// prepare the request</a>
<a name="ln3721">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln3722">	UnmountVolumeRequest* request;</a>
<a name="ln3723">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln3724">	if (error != B_OK)</a>
<a name="ln3725">		return error;</a>
<a name="ln3726"> </a>
<a name="ln3727">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln3728"> </a>
<a name="ln3729">	// send the request</a>
<a name="ln3730">	KernelRequestHandler handler(this, UNMOUNT_VOLUME_REPLY);</a>
<a name="ln3731">	UnmountVolumeReply* reply;</a>
<a name="ln3732">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln3733">	if (error != B_OK)</a>
<a name="ln3734">		return error;</a>
<a name="ln3735">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln3736"> </a>
<a name="ln3737">	// process the reply</a>
<a name="ln3738">	if (reply-&gt;error != B_OK)</a>
<a name="ln3739">		return reply-&gt;error;</a>
<a name="ln3740">	return error;</a>
<a name="ln3741">}</a>
<a name="ln3742"> </a>
<a name="ln3743">// _ReadFSInfo</a>
<a name="ln3744">status_t</a>
<a name="ln3745">Volume::_ReadFSInfo(fs_info* info)</a>
<a name="ln3746">{</a>
<a name="ln3747">	// check capability</a>
<a name="ln3748">	if (!HasCapability(FS_VOLUME_CAPABILITY_READ_FS_INFO))</a>
<a name="ln3749">		return B_BAD_VALUE;</a>
<a name="ln3750"> </a>
<a name="ln3751">	// get a free port</a>
<a name="ln3752">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln3753">	if (!port)</a>
<a name="ln3754">		return B_ERROR;</a>
<a name="ln3755">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln3756"> </a>
<a name="ln3757">	// prepare the request</a>
<a name="ln3758">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln3759">	ReadFSInfoRequest* request;</a>
<a name="ln3760">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln3761">	if (error != B_OK)</a>
<a name="ln3762">		return error;</a>
<a name="ln3763"> </a>
<a name="ln3764">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln3765"> </a>
<a name="ln3766">	// send the request</a>
<a name="ln3767">	KernelRequestHandler handler(this, READ_FS_INFO_REPLY);</a>
<a name="ln3768">	ReadFSInfoReply* reply;</a>
<a name="ln3769">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln3770">	if (error != B_OK)</a>
<a name="ln3771">		return error;</a>
<a name="ln3772">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln3773"> </a>
<a name="ln3774">	// process the reply</a>
<a name="ln3775">	if (reply-&gt;error != B_OK)</a>
<a name="ln3776">		return reply-&gt;error;</a>
<a name="ln3777">	*info = reply-&gt;info;</a>
<a name="ln3778">	return error;</a>
<a name="ln3779">}</a>
<a name="ln3780"> </a>
<a name="ln3781">// _Lookup</a>
<a name="ln3782">status_t</a>
<a name="ln3783">Volume::_Lookup(void* _dir, const char* entryName, ino_t* vnid)</a>
<a name="ln3784">{</a>
<a name="ln3785">	VNode* vnode = (VNode*)_dir;</a>
<a name="ln3786"> </a>
<a name="ln3787">	// get a free port</a>
<a name="ln3788">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln3789">	if (!port)</a>
<a name="ln3790">		return B_ERROR;</a>
<a name="ln3791">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln3792"> </a>
<a name="ln3793">	// prepare the request</a>
<a name="ln3794">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln3795">	LookupRequest* request;</a>
<a name="ln3796">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln3797">	if (error != B_OK)</a>
<a name="ln3798">		return error;</a>
<a name="ln3799">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln3800">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln3801">	error = allocator.AllocateString(request-&gt;entryName, entryName);</a>
<a name="ln3802">	if (error != B_OK)</a>
<a name="ln3803">		return error;</a>
<a name="ln3804"> </a>
<a name="ln3805">	// send the request</a>
<a name="ln3806">	KernelRequestHandler handler(this, LOOKUP_REPLY);</a>
<a name="ln3807">	LookupReply* reply;</a>
<a name="ln3808">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln3809">	if (error != B_OK)</a>
<a name="ln3810">		return error;</a>
<a name="ln3811">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln3812"> </a>
<a name="ln3813">	// process the reply</a>
<a name="ln3814">	if (reply-&gt;error != B_OK)</a>
<a name="ln3815">		return reply-&gt;error;</a>
<a name="ln3816">	*vnid = reply-&gt;vnid;</a>
<a name="ln3817"> </a>
<a name="ln3818">	// The VFS will balance the get_vnode() call for the FS.</a>
<a name="ln3819">	_DecrementVNodeCount(*vnid);</a>
<a name="ln3820">	return error;</a>
<a name="ln3821">}</a>
<a name="ln3822"> </a>
<a name="ln3823">// _WriteVNode</a>
<a name="ln3824">status_t</a>
<a name="ln3825">Volume::_WriteVNode(void* _node, bool reenter)</a>
<a name="ln3826">{</a>
<a name="ln3827">	VNode* vnode = (VNode*)_node;</a>
<a name="ln3828"> </a>
<a name="ln3829">	// At any rate remove the vnode from our map and delete it. We don't do that</a>
<a name="ln3830">	// right now, though, since we might still need to serve file cache requests</a>
<a name="ln3831">	// from the client FS.</a>
<a name="ln3832">	VNodeRemover nodeRemover(this, vnode);</a>
<a name="ln3833"> </a>
<a name="ln3834">	void* clientNode = vnode-&gt;clientNode;</a>
<a name="ln3835"> </a>
<a name="ln3836">	// get a free port</a>
<a name="ln3837">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln3838">	if (!port)</a>
<a name="ln3839">		return B_ERROR;</a>
<a name="ln3840">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln3841"> </a>
<a name="ln3842">	// prepare the request</a>
<a name="ln3843">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln3844">	WriteVNodeRequest* request;</a>
<a name="ln3845">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln3846">	if (error != B_OK)</a>
<a name="ln3847">		return error;</a>
<a name="ln3848">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln3849">	request-&gt;node = clientNode;</a>
<a name="ln3850">	request-&gt;reenter = reenter;</a>
<a name="ln3851"> </a>
<a name="ln3852">	// send the request</a>
<a name="ln3853">	KernelRequestHandler handler(this, WRITE_VNODE_REPLY);</a>
<a name="ln3854">	WriteVNodeReply* reply;</a>
<a name="ln3855">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln3856">	if (error != B_OK)</a>
<a name="ln3857">		return error;</a>
<a name="ln3858">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln3859"> </a>
<a name="ln3860">	// process the reply</a>
<a name="ln3861">	if (reply-&gt;error != B_OK)</a>
<a name="ln3862">		return reply-&gt;error;</a>
<a name="ln3863">	return error;</a>
<a name="ln3864">}</a>
<a name="ln3865"> </a>
<a name="ln3866">// _ReadStat</a>
<a name="ln3867">status_t</a>
<a name="ln3868">Volume::_ReadStat(void* _node, struct stat* st)</a>
<a name="ln3869">{</a>
<a name="ln3870">	VNode* vnode = (VNode*)_node;</a>
<a name="ln3871"> </a>
<a name="ln3872">	// check capability</a>
<a name="ln3873">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_READ_STAT))</a>
<a name="ln3874">		return B_BAD_VALUE;</a>
<a name="ln3875"> </a>
<a name="ln3876">	// get a free port</a>
<a name="ln3877">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln3878">	if (!port)</a>
<a name="ln3879">		return B_ERROR;</a>
<a name="ln3880">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln3881"> </a>
<a name="ln3882">	// prepare the request</a>
<a name="ln3883">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln3884">	ReadStatRequest* request;</a>
<a name="ln3885">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln3886">	if (error != B_OK)</a>
<a name="ln3887">		return error;</a>
<a name="ln3888"> </a>
<a name="ln3889">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln3890">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln3891"> </a>
<a name="ln3892">	// send the request</a>
<a name="ln3893">	KernelRequestHandler handler(this, READ_STAT_REPLY);</a>
<a name="ln3894">	ReadStatReply* reply;</a>
<a name="ln3895">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln3896">	if (error != B_OK)</a>
<a name="ln3897">		return error;</a>
<a name="ln3898">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln3899"> </a>
<a name="ln3900">	// process the reply</a>
<a name="ln3901">	if (reply-&gt;error != B_OK)</a>
<a name="ln3902">		return reply-&gt;error;</a>
<a name="ln3903">	*st = reply-&gt;st;</a>
<a name="ln3904">	return error;</a>
<a name="ln3905">}</a>
<a name="ln3906"> </a>
<a name="ln3907">// _Close</a>
<a name="ln3908">status_t</a>
<a name="ln3909">Volume::_Close(void* _node, void* cookie)</a>
<a name="ln3910">{</a>
<a name="ln3911">	VNode* vnode = (VNode*)_node;</a>
<a name="ln3912"> </a>
<a name="ln3913">	// check capability</a>
<a name="ln3914">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_CLOSE))</a>
<a name="ln3915">		return B_OK;</a>
<a name="ln3916"> </a>
<a name="ln3917">	// get a free port</a>
<a name="ln3918">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln3919">	if (!port)</a>
<a name="ln3920">		return B_ERROR;</a>
<a name="ln3921">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln3922"> </a>
<a name="ln3923">	// prepare the request</a>
<a name="ln3924">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln3925">	CloseRequest* request;</a>
<a name="ln3926">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln3927">	if (error != B_OK)</a>
<a name="ln3928">		return error;</a>
<a name="ln3929"> </a>
<a name="ln3930">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln3931">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln3932">	request-&gt;fileCookie = cookie;</a>
<a name="ln3933"> </a>
<a name="ln3934">	// send the request</a>
<a name="ln3935">	KernelRequestHandler handler(this, CLOSE_REPLY);</a>
<a name="ln3936">	CloseReply* reply;</a>
<a name="ln3937">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln3938">	if (error != B_OK)</a>
<a name="ln3939">		return error;</a>
<a name="ln3940">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln3941"> </a>
<a name="ln3942">	// process the reply</a>
<a name="ln3943">	if (reply-&gt;error != B_OK)</a>
<a name="ln3944">		return reply-&gt;error;</a>
<a name="ln3945">	return error;</a>
<a name="ln3946">}</a>
<a name="ln3947"> </a>
<a name="ln3948">// _FreeCookie</a>
<a name="ln3949">status_t</a>
<a name="ln3950">Volume::_FreeCookie(void* _node, void* cookie)</a>
<a name="ln3951">{</a>
<a name="ln3952">	VNode* vnode = (VNode*)_node;</a>
<a name="ln3953"> </a>
<a name="ln3954">	// check capability</a>
<a name="ln3955">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_FREE_COOKIE))</a>
<a name="ln3956">		return B_OK;</a>
<a name="ln3957"> </a>
<a name="ln3958">	// get a free port</a>
<a name="ln3959">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln3960">	if (!port)</a>
<a name="ln3961">		return B_ERROR;</a>
<a name="ln3962">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln3963"> </a>
<a name="ln3964">	// prepare the request</a>
<a name="ln3965">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln3966">	FreeCookieRequest* request;</a>
<a name="ln3967">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln3968">	if (error != B_OK)</a>
<a name="ln3969">		return error;</a>
<a name="ln3970"> </a>
<a name="ln3971">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln3972">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln3973">	request-&gt;fileCookie = cookie;</a>
<a name="ln3974"> </a>
<a name="ln3975">	// send the request</a>
<a name="ln3976">	KernelRequestHandler handler(this, FREE_COOKIE_REPLY);</a>
<a name="ln3977">	FreeCookieReply* reply;</a>
<a name="ln3978">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln3979">	if (error != B_OK)</a>
<a name="ln3980">		return error;</a>
<a name="ln3981">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln3982"> </a>
<a name="ln3983">	// process the reply</a>
<a name="ln3984">	if (reply-&gt;error != B_OK)</a>
<a name="ln3985">		return reply-&gt;error;</a>
<a name="ln3986">	return error;</a>
<a name="ln3987">}</a>
<a name="ln3988"> </a>
<a name="ln3989">// _CloseDir</a>
<a name="ln3990">status_t</a>
<a name="ln3991">Volume::_CloseDir(void* _node, void* cookie)</a>
<a name="ln3992">{</a>
<a name="ln3993">	VNode* vnode = (VNode*)_node;</a>
<a name="ln3994"> </a>
<a name="ln3995">	// check capability</a>
<a name="ln3996">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_CLOSE_DIR))</a>
<a name="ln3997">		return B_OK;</a>
<a name="ln3998"> </a>
<a name="ln3999">	// get a free port</a>
<a name="ln4000">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln4001">	if (!port)</a>
<a name="ln4002">		return B_ERROR;</a>
<a name="ln4003">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln4004"> </a>
<a name="ln4005">	// prepare the request</a>
<a name="ln4006">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln4007">	CloseDirRequest* request;</a>
<a name="ln4008">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln4009">	if (error != B_OK)</a>
<a name="ln4010">		return error;</a>
<a name="ln4011"> </a>
<a name="ln4012">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln4013">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln4014">	request-&gt;dirCookie = cookie;</a>
<a name="ln4015"> </a>
<a name="ln4016">	// send the request</a>
<a name="ln4017">	KernelRequestHandler handler(this, CLOSE_DIR_REPLY);</a>
<a name="ln4018">	CloseDirReply* reply;</a>
<a name="ln4019">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln4020">	if (error != B_OK)</a>
<a name="ln4021">		return error;</a>
<a name="ln4022">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln4023"> </a>
<a name="ln4024">	// process the reply</a>
<a name="ln4025">	if (reply-&gt;error != B_OK)</a>
<a name="ln4026">		return reply-&gt;error;</a>
<a name="ln4027">	return error;</a>
<a name="ln4028">}</a>
<a name="ln4029"> </a>
<a name="ln4030">// _FreeDirCookie</a>
<a name="ln4031">status_t</a>
<a name="ln4032">Volume::_FreeDirCookie(void* _node, void* cookie)</a>
<a name="ln4033">{</a>
<a name="ln4034">	VNode* vnode = (VNode*)_node;</a>
<a name="ln4035"> </a>
<a name="ln4036">	// check capability</a>
<a name="ln4037">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_FREE_DIR_COOKIE))</a>
<a name="ln4038">		return B_OK;</a>
<a name="ln4039"> </a>
<a name="ln4040">	// get a free port</a>
<a name="ln4041">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln4042">	if (!port)</a>
<a name="ln4043">		return B_ERROR;</a>
<a name="ln4044">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln4045"> </a>
<a name="ln4046">	// prepare the request</a>
<a name="ln4047">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln4048">	FreeDirCookieRequest* request;</a>
<a name="ln4049">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln4050">	if (error != B_OK)</a>
<a name="ln4051">		return error;</a>
<a name="ln4052"> </a>
<a name="ln4053">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln4054">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln4055">	request-&gt;dirCookie = cookie;</a>
<a name="ln4056"> </a>
<a name="ln4057">	// send the request</a>
<a name="ln4058">	KernelRequestHandler handler(this, FREE_DIR_COOKIE_REPLY);</a>
<a name="ln4059">	FreeDirCookieReply* reply;</a>
<a name="ln4060">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln4061">	if (error != B_OK)</a>
<a name="ln4062">		return error;</a>
<a name="ln4063">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln4064"> </a>
<a name="ln4065">	// process the reply</a>
<a name="ln4066">	if (reply-&gt;error != B_OK)</a>
<a name="ln4067">		return reply-&gt;error;</a>
<a name="ln4068">	return error;</a>
<a name="ln4069">}</a>
<a name="ln4070"> </a>
<a name="ln4071">// _CloseAttrDir</a>
<a name="ln4072">status_t</a>
<a name="ln4073">Volume::_CloseAttrDir(void* _node, void* cookie)</a>
<a name="ln4074">{</a>
<a name="ln4075">	VNode* vnode = (VNode*)_node;</a>
<a name="ln4076"> </a>
<a name="ln4077">	// check capability</a>
<a name="ln4078">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_CLOSE_ATTR_DIR))</a>
<a name="ln4079">		return B_OK;</a>
<a name="ln4080"> </a>
<a name="ln4081">	// get a free port</a>
<a name="ln4082">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln4083">	if (!port)</a>
<a name="ln4084">		return B_ERROR;</a>
<a name="ln4085">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln4086"> </a>
<a name="ln4087">	// prepare the request</a>
<a name="ln4088">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln4089">	CloseAttrDirRequest* request;</a>
<a name="ln4090">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln4091">	if (error != B_OK)</a>
<a name="ln4092">		return error;</a>
<a name="ln4093"> </a>
<a name="ln4094">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln4095">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln4096">	request-&gt;attrDirCookie = cookie;</a>
<a name="ln4097"> </a>
<a name="ln4098">	// send the request</a>
<a name="ln4099">	KernelRequestHandler handler(this, CLOSE_ATTR_DIR_REPLY);</a>
<a name="ln4100">	CloseAttrDirReply* reply;</a>
<a name="ln4101">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln4102">	if (error != B_OK)</a>
<a name="ln4103">		return error;</a>
<a name="ln4104">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln4105"> </a>
<a name="ln4106">	// process the reply</a>
<a name="ln4107">	if (reply-&gt;error != B_OK)</a>
<a name="ln4108">		return reply-&gt;error;</a>
<a name="ln4109">	return error;</a>
<a name="ln4110">}</a>
<a name="ln4111"> </a>
<a name="ln4112">// _FreeAttrDirCookie</a>
<a name="ln4113">status_t</a>
<a name="ln4114">Volume::_FreeAttrDirCookie(void* _node, void* cookie)</a>
<a name="ln4115">{</a>
<a name="ln4116">	VNode* vnode = (VNode*)_node;</a>
<a name="ln4117"> </a>
<a name="ln4118">	// check capability</a>
<a name="ln4119">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_FREE_ATTR_DIR_COOKIE))</a>
<a name="ln4120">		return B_OK;</a>
<a name="ln4121"> </a>
<a name="ln4122">	// get a free port</a>
<a name="ln4123">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln4124">	if (!port)</a>
<a name="ln4125">		return B_ERROR;</a>
<a name="ln4126">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln4127"> </a>
<a name="ln4128">	// prepare the request</a>
<a name="ln4129">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln4130">	FreeAttrDirCookieRequest* request;</a>
<a name="ln4131">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln4132">	if (error != B_OK)</a>
<a name="ln4133">		return error;</a>
<a name="ln4134"> </a>
<a name="ln4135">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln4136">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln4137">	request-&gt;attrDirCookie = cookie;</a>
<a name="ln4138"> </a>
<a name="ln4139">	// send the request</a>
<a name="ln4140">	KernelRequestHandler handler(this, FREE_ATTR_DIR_COOKIE_REPLY);</a>
<a name="ln4141">	FreeAttrDirCookieReply* reply;</a>
<a name="ln4142">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln4143">	if (error != B_OK)</a>
<a name="ln4144">		return error;</a>
<a name="ln4145">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln4146"> </a>
<a name="ln4147">	// process the reply</a>
<a name="ln4148">	if (reply-&gt;error != B_OK)</a>
<a name="ln4149">		return reply-&gt;error;</a>
<a name="ln4150">	return error;</a>
<a name="ln4151">}</a>
<a name="ln4152"> </a>
<a name="ln4153">// _CloseAttr</a>
<a name="ln4154">status_t</a>
<a name="ln4155">Volume::_CloseAttr(void* _node, void* cookie)</a>
<a name="ln4156">{</a>
<a name="ln4157">	VNode* vnode = (VNode*)_node;</a>
<a name="ln4158"> </a>
<a name="ln4159">	// check capability</a>
<a name="ln4160">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_CLOSE_ATTR))</a>
<a name="ln4161">		return B_OK;</a>
<a name="ln4162"> </a>
<a name="ln4163">	// get a free port</a>
<a name="ln4164">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln4165">	if (!port)</a>
<a name="ln4166">		return B_ERROR;</a>
<a name="ln4167">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln4168"> </a>
<a name="ln4169">	// prepare the request</a>
<a name="ln4170">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln4171">	CloseAttrRequest* request;</a>
<a name="ln4172">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln4173">	if (error != B_OK)</a>
<a name="ln4174">		return error;</a>
<a name="ln4175"> </a>
<a name="ln4176">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln4177">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln4178">	request-&gt;attrCookie = cookie;</a>
<a name="ln4179"> </a>
<a name="ln4180">	// send the request</a>
<a name="ln4181">	KernelRequestHandler handler(this, CLOSE_ATTR_REPLY);</a>
<a name="ln4182">	CloseAttrReply* reply;</a>
<a name="ln4183">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln4184">	if (error != B_OK)</a>
<a name="ln4185">		return error;</a>
<a name="ln4186">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln4187"> </a>
<a name="ln4188">	// process the reply</a>
<a name="ln4189">	if (reply-&gt;error != B_OK)</a>
<a name="ln4190">		return reply-&gt;error;</a>
<a name="ln4191">	return error;</a>
<a name="ln4192">}</a>
<a name="ln4193"> </a>
<a name="ln4194">// _FreeAttrCookie</a>
<a name="ln4195">status_t</a>
<a name="ln4196">Volume::_FreeAttrCookie(void* _node, void* cookie)</a>
<a name="ln4197">{</a>
<a name="ln4198">	VNode* vnode = (VNode*)_node;</a>
<a name="ln4199"> </a>
<a name="ln4200">	// check capability</a>
<a name="ln4201">	if (!HasVNodeCapability(vnode, FS_VNODE_CAPABILITY_FREE_ATTR_COOKIE))</a>
<a name="ln4202">		return B_OK;</a>
<a name="ln4203"> </a>
<a name="ln4204">	// get a free port</a>
<a name="ln4205">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln4206">	if (!port)</a>
<a name="ln4207">		return B_ERROR;</a>
<a name="ln4208">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln4209"> </a>
<a name="ln4210">	// prepare the request</a>
<a name="ln4211">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln4212">	FreeAttrCookieRequest* request;</a>
<a name="ln4213">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln4214">	if (error != B_OK)</a>
<a name="ln4215">		return error;</a>
<a name="ln4216"> </a>
<a name="ln4217">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln4218">	request-&gt;node = vnode-&gt;clientNode;</a>
<a name="ln4219">	request-&gt;attrCookie = cookie;</a>
<a name="ln4220"> </a>
<a name="ln4221">	// send the request</a>
<a name="ln4222">	KernelRequestHandler handler(this, FREE_ATTR_COOKIE_REPLY);</a>
<a name="ln4223">	FreeAttrCookieReply* reply;</a>
<a name="ln4224">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln4225">	if (error != B_OK)</a>
<a name="ln4226">		return error;</a>
<a name="ln4227">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln4228"> </a>
<a name="ln4229">	// process the reply</a>
<a name="ln4230">	if (reply-&gt;error != B_OK)</a>
<a name="ln4231">		return reply-&gt;error;</a>
<a name="ln4232">	return error;</a>
<a name="ln4233">}</a>
<a name="ln4234"> </a>
<a name="ln4235">// _CloseIndexDir</a>
<a name="ln4236">status_t</a>
<a name="ln4237">Volume::_CloseIndexDir(void* cookie)</a>
<a name="ln4238">{</a>
<a name="ln4239">	// check capability</a>
<a name="ln4240">	if (!HasCapability(FS_VOLUME_CAPABILITY_CLOSE_INDEX_DIR))</a>
<a name="ln4241">		return B_OK;</a>
<a name="ln4242"> </a>
<a name="ln4243">	// get a free port</a>
<a name="ln4244">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln4245">	if (!port)</a>
<a name="ln4246">		return B_ERROR;</a>
<a name="ln4247">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln4248"> </a>
<a name="ln4249">	// prepare the request</a>
<a name="ln4250">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln4251">	CloseIndexDirRequest* request;</a>
<a name="ln4252">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln4253">	if (error != B_OK)</a>
<a name="ln4254">		return error;</a>
<a name="ln4255"> </a>
<a name="ln4256">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln4257">	request-&gt;indexDirCookie = cookie;</a>
<a name="ln4258"> </a>
<a name="ln4259">	// send the request</a>
<a name="ln4260">	KernelRequestHandler handler(this, CLOSE_INDEX_DIR_REPLY);</a>
<a name="ln4261">	CloseIndexDirReply* reply;</a>
<a name="ln4262">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln4263">	if (error != B_OK)</a>
<a name="ln4264">		return error;</a>
<a name="ln4265">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln4266"> </a>
<a name="ln4267">	// process the reply</a>
<a name="ln4268">	if (reply-&gt;error != B_OK)</a>
<a name="ln4269">		return reply-&gt;error;</a>
<a name="ln4270">	return error;</a>
<a name="ln4271">}</a>
<a name="ln4272"> </a>
<a name="ln4273">// _FreeIndexDirCookie</a>
<a name="ln4274">status_t</a>
<a name="ln4275">Volume::_FreeIndexDirCookie(void* cookie)</a>
<a name="ln4276">{</a>
<a name="ln4277">	// check capability</a>
<a name="ln4278">	if (!HasCapability(FS_VOLUME_CAPABILITY_FREE_INDEX_DIR_COOKIE))</a>
<a name="ln4279">		return B_OK;</a>
<a name="ln4280"> </a>
<a name="ln4281">	// get a free port</a>
<a name="ln4282">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln4283">	if (!port)</a>
<a name="ln4284">		return B_ERROR;</a>
<a name="ln4285">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln4286"> </a>
<a name="ln4287">	// prepare the request</a>
<a name="ln4288">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln4289">	FreeIndexDirCookieRequest* request;</a>
<a name="ln4290">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln4291">	if (error != B_OK)</a>
<a name="ln4292">		return error;</a>
<a name="ln4293"> </a>
<a name="ln4294">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln4295">	request-&gt;indexDirCookie = cookie;</a>
<a name="ln4296"> </a>
<a name="ln4297">	// send the request</a>
<a name="ln4298">	KernelRequestHandler handler(this, FREE_INDEX_DIR_COOKIE_REPLY);</a>
<a name="ln4299">	FreeIndexDirCookieReply* reply;</a>
<a name="ln4300">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln4301">	if (error != B_OK)</a>
<a name="ln4302">		return error;</a>
<a name="ln4303">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln4304"> </a>
<a name="ln4305">	// process the reply</a>
<a name="ln4306">	if (reply-&gt;error != B_OK)</a>
<a name="ln4307">		return reply-&gt;error;</a>
<a name="ln4308">	return error;</a>
<a name="ln4309">}</a>
<a name="ln4310"> </a>
<a name="ln4311">// _CloseQuery</a>
<a name="ln4312">status_t</a>
<a name="ln4313">Volume::_CloseQuery(void* cookie)</a>
<a name="ln4314">{</a>
<a name="ln4315">	// check capability</a>
<a name="ln4316">	if (!HasCapability(FS_VOLUME_CAPABILITY_CLOSE_QUERY))</a>
<a name="ln4317">		return B_OK;</a>
<a name="ln4318"> </a>
<a name="ln4319">	// get a free port</a>
<a name="ln4320">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln4321">	if (!port)</a>
<a name="ln4322">		return B_ERROR;</a>
<a name="ln4323">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln4324"> </a>
<a name="ln4325">	// prepare the request</a>
<a name="ln4326">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln4327">	CloseQueryRequest* request;</a>
<a name="ln4328">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln4329">	if (error != B_OK)</a>
<a name="ln4330">		return error;</a>
<a name="ln4331"> </a>
<a name="ln4332">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln4333">	request-&gt;queryCookie = cookie;</a>
<a name="ln4334"> </a>
<a name="ln4335">	// send the request</a>
<a name="ln4336">	KernelRequestHandler handler(this, CLOSE_QUERY_REPLY);</a>
<a name="ln4337">	CloseQueryReply* reply;</a>
<a name="ln4338">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln4339">	if (error != B_OK)</a>
<a name="ln4340">		return error;</a>
<a name="ln4341">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln4342"> </a>
<a name="ln4343">	// process the reply</a>
<a name="ln4344">	if (reply-&gt;error != B_OK)</a>
<a name="ln4345">		return reply-&gt;error;</a>
<a name="ln4346">	return error;</a>
<a name="ln4347">}</a>
<a name="ln4348"> </a>
<a name="ln4349">// _FreeQueryCookie</a>
<a name="ln4350">status_t</a>
<a name="ln4351">Volume::_FreeQueryCookie(void* cookie)</a>
<a name="ln4352">{</a>
<a name="ln4353">	// check capability</a>
<a name="ln4354">	if (!HasCapability(FS_VOLUME_CAPABILITY_FREE_QUERY_COOKIE))</a>
<a name="ln4355">		return B_OK;</a>
<a name="ln4356"> </a>
<a name="ln4357">	// get a free port</a>
<a name="ln4358">	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln4359">	if (!port)</a>
<a name="ln4360">		return B_ERROR;</a>
<a name="ln4361">	PortReleaser _(fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln4362"> </a>
<a name="ln4363">	// prepare the request</a>
<a name="ln4364">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln4365">	FreeQueryCookieRequest* request;</a>
<a name="ln4366">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln4367">	if (error != B_OK)</a>
<a name="ln4368">		return error;</a>
<a name="ln4369"> </a>
<a name="ln4370">	request-&gt;volume = fUserlandVolume;</a>
<a name="ln4371">	request-&gt;queryCookie = cookie;</a>
<a name="ln4372"> </a>
<a name="ln4373">	// send the request</a>
<a name="ln4374">	KernelRequestHandler handler(this, FREE_QUERY_COOKIE_REPLY);</a>
<a name="ln4375">	FreeQueryCookieReply* reply;</a>
<a name="ln4376">	error = _SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln4377">	if (error != B_OK)</a>
<a name="ln4378">		return error;</a>
<a name="ln4379">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln4380"> </a>
<a name="ln4381">	// process the reply</a>
<a name="ln4382">	if (reply-&gt;error != B_OK)</a>
<a name="ln4383">		return reply-&gt;error;</a>
<a name="ln4384">	return error;</a>
<a name="ln4385">}</a>
<a name="ln4386"> </a>
<a name="ln4387">// _SendRequest</a>
<a name="ln4388">status_t</a>
<a name="ln4389">Volume::_SendRequest(RequestPort* port, RequestAllocator* allocator,</a>
<a name="ln4390">	RequestHandler* handler, Request** reply)</a>
<a name="ln4391">{</a>
<a name="ln4392">	// fill in the caller info</a>
<a name="ln4393">	KernelRequest* request = static_cast&lt;KernelRequest*&gt;(</a>
<a name="ln4394">		allocator-&gt;GetRequest());</a>
<a name="ln4395">	Thread* thread = thread_get_current_thread();</a>
<a name="ln4396">	request-&gt;team = thread-&gt;team-&gt;id;</a>
<a name="ln4397">	request-&gt;thread = thread-&gt;id;</a>
<a name="ln4398">	request-&gt;user = geteuid();</a>
<a name="ln4399">	request-&gt;group = getegid();</a>
<a name="ln4400"> </a>
<a name="ln4401">	if (!fFileSystem-&gt;IsUserlandServerThread())</a>
<a name="ln4402">		return port-&gt;SendRequest(allocator, handler, reply);</a>
<a name="ln4403">	// Here it gets dangerous: a thread of the userland server team being here</a>
<a name="ln4404">	// calls for trouble. We try receiving the request with a timeout, and</a>
<a name="ln4405">	// close the port -- which will disconnect the whole FS.</a>
<a name="ln4406">	status_t error = port-&gt;SendRequest(allocator, handler, reply,</a>
<a name="ln4407">		kUserlandServerlandPortTimeout);</a>
<a name="ln4408">	if (error == B_TIMED_OUT || error == B_WOULD_BLOCK)</a>
<a name="ln4409">		port-&gt;Close();</a>
<a name="ln4410">	return error;</a>
<a name="ln4411">}</a>
<a name="ln4412"> </a>
<a name="ln4413">// _SendReceiptAck</a>
<a name="ln4414">status_t</a>
<a name="ln4415">Volume::_SendReceiptAck(RequestPort* port)</a>
<a name="ln4416">{</a>
<a name="ln4417">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln4418">	ReceiptAckReply* request;</a>
<a name="ln4419">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln4420">	if (error != B_OK)</a>
<a name="ln4421">		return error;</a>
<a name="ln4422">	return port-&gt;SendRequest(&amp;allocator);</a>
<a name="ln4423">}</a>
<a name="ln4424"> </a>
<a name="ln4425">// _IncrementVNodeCount</a>
<a name="ln4426">void</a>
<a name="ln4427">Volume::_IncrementVNodeCount(ino_t vnid)</a>
<a name="ln4428">{</a>
<a name="ln4429">	MutexLocker _(fLock);</a>
<a name="ln4430"> </a>
<a name="ln4431">	if (!fVNodeCountingEnabled)</a>
<a name="ln4432">		return;</a>
<a name="ln4433"> </a>
<a name="ln4434">	VNode* vnode = fVNodes-&gt;Lookup(vnid);</a>
<a name="ln4435">	if (vnode == NULL) {</a>
<a name="ln4436">		ERROR((&quot;Volume::_IncrementVNodeCount(): Node with ID %&quot; B_PRId64</a>
<a name="ln4437">			&quot; not known!\n&quot;, vnid));</a>
<a name="ln4438">		return;</a>
<a name="ln4439">	}</a>
<a name="ln4440"> </a>
<a name="ln4441">	vnode-&gt;useCount++;</a>
<a name="ln4442">//PRINT((&quot;_IncrementVNodeCount(%Ld): count: %ld, fVNodeCountMap size: %ld\n&quot;, vnid, *count, fVNodeCountMap-&gt;Size()));</a>
<a name="ln4443">}</a>
<a name="ln4444"> </a>
<a name="ln4445"> </a>
<a name="ln4446">// _DecrementVNodeCount</a>
<a name="ln4447">void</a>
<a name="ln4448">Volume::_DecrementVNodeCount(ino_t vnid)</a>
<a name="ln4449">{</a>
<a name="ln4450">	MutexLocker _(fLock);</a>
<a name="ln4451"> </a>
<a name="ln4452">	if (!fVNodeCountingEnabled)</a>
<a name="ln4453">		return;</a>
<a name="ln4454"> </a>
<a name="ln4455">	VNode* vnode = fVNodes-&gt;Lookup(vnid);</a>
<a name="ln4456">	if (vnode == NULL) {</a>
<a name="ln4457">		ERROR((&quot;Volume::_DecrementVNodeCount(): Node with ID %&quot; B_PRId64 &quot; not &quot;</a>
<a name="ln4458">			&quot;known!\n&quot;, vnid));</a>
<a name="ln4459">		return;</a>
<a name="ln4460">	}</a>
<a name="ln4461"> </a>
<a name="ln4462">	vnode-&gt;useCount--;</a>
<a name="ln4463">//PRINT((&quot;_DecrementVNodeCount(%Ld): count: %ld, fVNodeCountMap size: %ld\n&quot;, vnid, tmpCount, fVNodeCountMap-&gt;Size()));</a>
<a name="ln4464">}</a>
<a name="ln4465"> </a>
<a name="ln4466"> </a>
<a name="ln4467">// _RemoveInvalidVNode</a>
<a name="ln4468">void</a>
<a name="ln4469">Volume::_RemoveInvalidVNode(ino_t vnid)</a>
<a name="ln4470">{</a>
<a name="ln4471">	MutexLocker locker(fLock);</a>
<a name="ln4472"> </a>
<a name="ln4473">	VNode* vnode = fVNodes-&gt;Lookup(vnid);</a>
<a name="ln4474">	if (vnode == NULL) {</a>
<a name="ln4475">		ERROR((&quot;Volume::_RemoveInvalidVNode(): Node with ID %&quot; B_PRId64</a>
<a name="ln4476">			&quot; not known!\n&quot;, vnid));</a>
<a name="ln4477">		return;</a>
<a name="ln4478">	}</a>
<a name="ln4479"> </a>
<a name="ln4480">	fVNodes-&gt;Remove(vnode);</a>
<a name="ln4481">	locker.Unlock();</a>
<a name="ln4482"> </a>
<a name="ln4483">	// release all references acquired so far</a>
<a name="ln4484">	if (fVNodeCountingEnabled) {</a>
<a name="ln4485">		for (; vnode-&gt;useCount &gt; 0; vnode-&gt;useCount--)</a>
<a name="ln4486">			put_vnode(fFSVolume, vnid);</a>
<a name="ln4487">	}</a>
<a name="ln4488"> </a>
<a name="ln4489">	vnode-&gt;Delete(this);</a>
<a name="ln4490">}</a>
<a name="ln4491"> </a>
<a name="ln4492"> </a>
<a name="ln4493">// _InternalIOCtl</a>
<a name="ln4494">status_t</a>
<a name="ln4495">Volume::_InternalIOCtl(userlandfs_ioctl* buffer, int32 bufferSize)</a>
<a name="ln4496">{</a>
<a name="ln4497">	if (buffer-&gt;version != USERLAND_IOCTL_CURRENT_VERSION)</a>
<a name="ln4498">		return B_BAD_VALUE;</a>
<a name="ln4499">	status_t result = B_OK;</a>
<a name="ln4500">	switch (buffer-&gt;command) {</a>
<a name="ln4501">		case USERLAND_IOCTL_PUT_ALL_PENDING_VNODES:</a>
<a name="ln4502">			result = _PutAllPendingVNodes();</a>
<a name="ln4503">			break;</a>
<a name="ln4504">		default:</a>
<a name="ln4505">			return B_BAD_VALUE;</a>
<a name="ln4506">	}</a>
<a name="ln4507">	buffer-&gt;error = result;</a>
<a name="ln4508">	return B_OK;</a>
<a name="ln4509">}</a>
<a name="ln4510"> </a>
<a name="ln4511">// _PutAllPendingVNodes</a>
<a name="ln4512">status_t</a>
<a name="ln4513">Volume::_PutAllPendingVNodes()</a>
<a name="ln4514">{</a>
<a name="ln4515">PRINT((&quot;Volume::_PutAllPendingVNodes()\n&quot;));</a>
<a name="ln4516">	if (!fFileSystem-&gt;GetPortPool()-&gt;IsDisconnected()) {</a>
<a name="ln4517">		PRINT((&quot;Volume::_PutAllPendingVNodes() failed: still connected\n&quot;));</a>
<a name="ln4518">		return USERLAND_IOCTL_STILL_CONNECTED;</a>
<a name="ln4519">	}</a>
<a name="ln4520"> </a>
<a name="ln4521">	MutexLocker locker(fLock);</a>
<a name="ln4522"> </a>
<a name="ln4523">	if (!fVNodeCountingEnabled) {</a>
<a name="ln4524">		PRINT((&quot;Volume::_PutAllPendingVNodes() failed: vnode counting &quot;</a>
<a name="ln4525">			&quot;disabled\n&quot;));</a>
<a name="ln4526">		return USERLAND_IOCTL_VNODE_COUNTING_DISABLED;</a>
<a name="ln4527">	}</a>
<a name="ln4528">	// Check whether there are open entities at the moment.</a>
<a name="ln4529">	if (atomic_get(&amp;fOpenFiles) &gt; 0) {</a>
<a name="ln4530">		PRINT((&quot;Volume::_PutAllPendingVNodes() failed: open files\n&quot;));</a>
<a name="ln4531">		return USERLAND_IOCTL_OPEN_FILES;</a>
<a name="ln4532">	}</a>
<a name="ln4533">	if (atomic_get(&amp;fOpenDirectories) &gt; 0) {</a>
<a name="ln4534">		PRINT((&quot;Volume::_PutAllPendingVNodes() failed: open dirs\n&quot;));</a>
<a name="ln4535">		return USERLAND_IOCTL_OPEN_DIRECTORIES;</a>
<a name="ln4536">	}</a>
<a name="ln4537">	if (atomic_get(&amp;fOpenAttributeDirectories) &gt; 0) {</a>
<a name="ln4538">		PRINT((&quot;Volume::_PutAllPendingVNodes() failed: open attr dirs\n&quot;));</a>
<a name="ln4539">		return USERLAND_IOCTL_OPEN_ATTRIBUTE_DIRECTORIES;</a>
<a name="ln4540">	}</a>
<a name="ln4541">	if (atomic_get(&amp;fOpenAttributes) &gt; 0) {</a>
<a name="ln4542">		PRINT((&quot;Volume::_PutAllPendingVNodes() failed: open attributes\n&quot;));</a>
<a name="ln4543">		return USERLAND_IOCTL_OPEN_ATTRIBUTES;</a>
<a name="ln4544">	}</a>
<a name="ln4545">	if (atomic_get(&amp;fOpenIndexDirectories) &gt; 0) {</a>
<a name="ln4546">		PRINT((&quot;Volume::_PutAllPendingVNodes() failed: open index dirs\n&quot;));</a>
<a name="ln4547">		return USERLAND_IOCTL_OPEN_INDEX_DIRECTORIES;</a>
<a name="ln4548">	}</a>
<a name="ln4549">	if (atomic_get(&amp;fOpenQueries) &gt; 0) {</a>
<a name="ln4550">		PRINT((&quot;Volume::_PutAllPendingVNodes() failed: open queries\n&quot;));</a>
<a name="ln4551">		return USERLAND_IOCTL_OPEN_QUERIES;</a>
<a name="ln4552">	}</a>
<a name="ln4553">	// No open entities. Since the port pool is disconnected, no new</a>
<a name="ln4554">	// entities can be opened. Disable node counting and put all pending</a>
<a name="ln4555">	// vnodes.</a>
<a name="ln4556">	fVNodeCountingEnabled = false;</a>
<a name="ln4557"> </a>
<a name="ln4558">	int32 putVNodeCount = 0;</a>
<a name="ln4559"> </a>
<a name="ln4560">	// Since the vnode map can still change, we need to iterate to the first</a>
<a name="ln4561">	// node we need to put, drop the lock, put the node, and restart from the</a>
<a name="ln4562">	// beginning.</a>
<a name="ln4563">	// TODO: Optimize by extracting batches of relevant nodes to an on-stack</a>
<a name="ln4564">	// array.</a>
<a name="ln4565">	bool nodeFound;</a>
<a name="ln4566">	do {</a>
<a name="ln4567">		nodeFound = false;</a>
<a name="ln4568"> </a>
<a name="ln4569">		// get the next node to put</a>
<a name="ln4570">		for (VNodeMap::Iterator it = fVNodes-&gt;GetIterator();</a>
<a name="ln4571">				VNode* vnode = it.Next();) {</a>
<a name="ln4572">			if (vnode-&gt;useCount &gt; 0) {</a>
<a name="ln4573">				ino_t vnid = vnode-&gt;id;</a>
<a name="ln4574">				int32 count = vnode-&gt;useCount;</a>
<a name="ln4575">				vnode-&gt;useCount = 0;</a>
<a name="ln4576">				fs_vnode_ops* ops = vnode-&gt;ops-&gt;ops;</a>
<a name="ln4577">				bool published = vnode-&gt;published;</a>
<a name="ln4578"> </a>
<a name="ln4579">				locker.Unlock();</a>
<a name="ln4580"> </a>
<a name="ln4581">				// If the node has not yet been published, we have to do that</a>
<a name="ln4582">				// before putting otherwise the VFS will complain that the node</a>
<a name="ln4583">				// is busy when the last reference is gone.</a>
<a name="ln4584">				if (!published)</a>
<a name="ln4585">					publish_vnode(fFSVolume, vnid, vnode, ops, S_IFDIR, 0);</a>
<a name="ln4586"> </a>
<a name="ln4587">				for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln4588">					PutVNode(vnid);</a>
<a name="ln4589">					putVNodeCount++;</a>
<a name="ln4590">				}</a>
<a name="ln4591"> </a>
<a name="ln4592">				locker.Lock();</a>
<a name="ln4593"> </a>
<a name="ln4594">				nodeFound = true;</a>
<a name="ln4595">				break;</a>
<a name="ln4596">			}</a>
<a name="ln4597">		}</a>
<a name="ln4598">	} while (nodeFound);</a>
<a name="ln4599"> </a>
<a name="ln4600">	PRINT((&quot;Volume::_PutAllPendingVNodes() successful: Put %&quot; B_PRId32</a>
<a name="ln4601">		&quot; vnodes\n&quot;, putVNodeCount));</a>
<a name="ln4602"> </a>
<a name="ln4603">	return B_OK;</a>
<a name="ln4604">}</a>
<a name="ln4605"> </a>
<a name="ln4606"> </a>
<a name="ln4607">// _RegisterIORequest</a>
<a name="ln4608">status_t</a>
<a name="ln4609">Volume::_RegisterIORequest(io_request* request, int32* requestID)</a>
<a name="ln4610">{</a>
<a name="ln4611">	MutexLocker _(fLock);</a>
<a name="ln4612"> </a>
<a name="ln4613">	// get the next free ID</a>
<a name="ln4614">	while (fIORequestInfosByID-&gt;Lookup(++fLastIORequestID) != NULL) {</a>
<a name="ln4615">	}</a>
<a name="ln4616"> </a>
<a name="ln4617">	// allocate the info</a>
<a name="ln4618">	IORequestInfo* info = new(std::nothrow) IORequestInfo(request,</a>
<a name="ln4619">		++fLastIORequestID);</a>
<a name="ln4620">	if (info == NULL)</a>
<a name="ln4621">		return B_NO_MEMORY;</a>
<a name="ln4622"> </a>
<a name="ln4623">	// add the info to the maps</a>
<a name="ln4624">	fIORequestInfosByID-&gt;Insert(info);</a>
<a name="ln4625">	fIORequestInfosByStruct-&gt;Insert(info);</a>
<a name="ln4626"> </a>
<a name="ln4627">	*requestID = info-&gt;id;</a>
<a name="ln4628"> </a>
<a name="ln4629">	return B_OK;</a>
<a name="ln4630">}</a>
<a name="ln4631"> </a>
<a name="ln4632"> </a>
<a name="ln4633">// _UnregisterIORequest</a>
<a name="ln4634">status_t</a>
<a name="ln4635">Volume::_UnregisterIORequest(int32 requestID)</a>
<a name="ln4636">{</a>
<a name="ln4637">	MutexLocker _(fLock);</a>
<a name="ln4638"> </a>
<a name="ln4639">	if (IORequestInfo* info = fIORequestInfosByID-&gt;Lookup(requestID)) {</a>
<a name="ln4640">		fIORequestInfosByID-&gt;Remove(info);</a>
<a name="ln4641">		fIORequestInfosByStruct-&gt;Remove(info);</a>
<a name="ln4642">		return B_OK;</a>
<a name="ln4643">	}</a>
<a name="ln4644"> </a>
<a name="ln4645">	return B_ENTRY_NOT_FOUND;</a>
<a name="ln4646">}</a>
<a name="ln4647"> </a>
<a name="ln4648"> </a>
<a name="ln4649">// _FindIORequest</a>
<a name="ln4650">status_t</a>
<a name="ln4651">Volume::_FindIORequest(int32 requestID, io_request** request)</a>
<a name="ln4652">{</a>
<a name="ln4653">	MutexLocker _(fLock);</a>
<a name="ln4654"> </a>
<a name="ln4655">	if (IORequestInfo* info = fIORequestInfosByID-&gt;Lookup(requestID)) {</a>
<a name="ln4656">		*request = info-&gt;request;</a>
<a name="ln4657">		return B_OK;</a>
<a name="ln4658">	}</a>
<a name="ln4659"> </a>
<a name="ln4660">	return B_ENTRY_NOT_FOUND;</a>
<a name="ln4661">}</a>
<a name="ln4662"> </a>
<a name="ln4663"> </a>
<a name="ln4664">// _FindIORequest</a>
<a name="ln4665">status_t</a>
<a name="ln4666">Volume::_FindIORequest(io_request* request, int32* requestID)</a>
<a name="ln4667">{</a>
<a name="ln4668">	MutexLocker _(fLock);</a>
<a name="ln4669"> </a>
<a name="ln4670">	if (IORequestInfo* info = fIORequestInfosByStruct-&gt;Lookup(request)) {</a>
<a name="ln4671">		*requestID = info-&gt;id;</a>
<a name="ln4672">		return B_OK;</a>
<a name="ln4673">	}</a>
<a name="ln4674"> </a>
<a name="ln4675">	return B_ENTRY_NOT_FOUND;</a>
<a name="ln4676">}</a>
<a name="ln4677"> </a>
<a name="ln4678"> </a>
<a name="ln4679">/*static*/ status_t</a>
<a name="ln4680">Volume::_IterativeFDIOGetVecs(void* _cookie, io_request* ioRequest,</a>
<a name="ln4681">	off_t offset, size_t size, struct file_io_vec* vecs, size_t* _count)</a>
<a name="ln4682">{</a>
<a name="ln4683">	IterativeFDIOCookie* cookie = (IterativeFDIOCookie*)_cookie;</a>
<a name="ln4684">	Volume* volume = cookie-&gt;volume;</a>
<a name="ln4685"> </a>
<a name="ln4686">	MutexLocker locker(volume-&gt;fLock);</a>
<a name="ln4687"> </a>
<a name="ln4688">	// If there are vecs cached in the cookie and the offset matches, return</a>
<a name="ln4689">	// those.</a>
<a name="ln4690">	if (cookie-&gt;vecs != NULL) {</a>
<a name="ln4691">		size_t vecCount = 0;</a>
<a name="ln4692">		if (offset == cookie-&gt;offset) {</a>
<a name="ln4693">			// good, copy the vecs</a>
<a name="ln4694">			while (size &gt; 0 &amp;&amp; vecCount &lt; cookie-&gt;vecCount</a>
<a name="ln4695">					&amp;&amp; vecCount &lt; *_count) {</a>
<a name="ln4696">				off_t maxSize = std::min((off_t)size,</a>
<a name="ln4697">					cookie-&gt;vecs[vecCount].length);</a>
<a name="ln4698">				vecs[vecCount].offset = cookie-&gt;vecs[vecCount].offset;</a>
<a name="ln4699">				vecs[vecCount].length = maxSize;</a>
<a name="ln4700"> </a>
<a name="ln4701">				size -= maxSize;</a>
<a name="ln4702">				vecCount++;</a>
<a name="ln4703">			}</a>
<a name="ln4704">		}</a>
<a name="ln4705"> </a>
<a name="ln4706">		cookie-&gt;vecs = NULL;</a>
<a name="ln4707">		cookie-&gt;vecCount = 0;</a>
<a name="ln4708"> </a>
<a name="ln4709">		// got some vecs? -- then we're done</a>
<a name="ln4710">		if (vecCount &gt; 0) {</a>
<a name="ln4711">			*_count = vecCount;</a>
<a name="ln4712">			return B_OK;</a>
<a name="ln4713">		}</a>
<a name="ln4714">	}</a>
<a name="ln4715"> </a>
<a name="ln4716">	// we have to ask the client FS</a>
<a name="ln4717">	int32 requestID = cookie-&gt;requestID;</a>
<a name="ln4718">	void* clientCookie = cookie-&gt;clientCookie;</a>
<a name="ln4719">	locker.Unlock();</a>
<a name="ln4720"> </a>
<a name="ln4721">	// get a free port</a>
<a name="ln4722">	RequestPort* port = volume-&gt;fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln4723">	if (!port)</a>
<a name="ln4724">		return B_ERROR;</a>
<a name="ln4725">	PortReleaser _(volume-&gt;fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln4726"> </a>
<a name="ln4727">	// prepare the request</a>
<a name="ln4728">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln4729">	IterativeIOGetVecsRequest* request;</a>
<a name="ln4730">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln4731">	if (error != B_OK)</a>
<a name="ln4732">		return error;</a>
<a name="ln4733"> </a>
<a name="ln4734">	request-&gt;volume = volume-&gt;fUserlandVolume;</a>
<a name="ln4735">	request-&gt;cookie = clientCookie;</a>
<a name="ln4736">	request-&gt;offset = offset;</a>
<a name="ln4737">	request-&gt;request = requestID;</a>
<a name="ln4738">	request-&gt;size = size;</a>
<a name="ln4739">	size_t maxVecs = std::min(*_count,</a>
<a name="ln4740">		(size_t)IterativeIOGetVecsReply::MAX_VECS);</a>
<a name="ln4741">	request-&gt;vecCount = maxVecs;</a>
<a name="ln4742"> </a>
<a name="ln4743">	// send the request</a>
<a name="ln4744">	KernelRequestHandler handler(volume, ITERATIVE_IO_GET_VECS_REPLY);</a>
<a name="ln4745">	IterativeIOGetVecsReply* reply;</a>
<a name="ln4746">	error = volume-&gt;_SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln4747">	if (error != B_OK)</a>
<a name="ln4748">		return error;</a>
<a name="ln4749">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln4750"> </a>
<a name="ln4751">	// process the reply</a>
<a name="ln4752">	if (reply-&gt;error != B_OK)</a>
<a name="ln4753">		return reply-&gt;error;</a>
<a name="ln4754">	uint32 vecCount = reply-&gt;vecCount;</a>
<a name="ln4755">	if (vecCount &lt; 0 || vecCount &gt; maxVecs)</a>
<a name="ln4756">		return B_BAD_DATA;</a>
<a name="ln4757"> </a>
<a name="ln4758">	memcpy(vecs, reply-&gt;vecs, vecCount * sizeof(file_io_vec));</a>
<a name="ln4759">	*_count = vecCount;</a>
<a name="ln4760"> </a>
<a name="ln4761">	return B_OK;</a>
<a name="ln4762">}</a>
<a name="ln4763"> </a>
<a name="ln4764"> </a>
<a name="ln4765">/*static*/ status_t</a>
<a name="ln4766">Volume::_IterativeFDIOFinished(void* _cookie, io_request* ioRequest,</a>
<a name="ln4767">	status_t status, bool partialTransfer, size_t bytesTransferred)</a>
<a name="ln4768">{</a>
<a name="ln4769">	IterativeFDIOCookie* cookie = (IterativeFDIOCookie*)_cookie;</a>
<a name="ln4770">	Volume* volume = cookie-&gt;volume;</a>
<a name="ln4771"> </a>
<a name="ln4772">	// At any rate, we're done with the cookie after this call -- it will not</a>
<a name="ln4773">	// be used anymore.</a>
<a name="ln4774">	BReference&lt;IterativeFDIOCookie&gt; _(cookie, true);</a>
<a name="ln4775"> </a>
<a name="ln4776">	// We also want to dispose of the request.</a>
<a name="ln4777">	IORequestRemover _2(volume, cookie-&gt;requestID);</a>
<a name="ln4778"> </a>
<a name="ln4779">	// get a free port</a>
<a name="ln4780">	RequestPort* port = volume-&gt;fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();</a>
<a name="ln4781">	if (!port)</a>
<a name="ln4782">		return B_ERROR;</a>
<a name="ln4783">	PortReleaser _3(volume-&gt;fFileSystem-&gt;GetPortPool(), port);</a>
<a name="ln4784"> </a>
<a name="ln4785">	// prepare the request</a>
<a name="ln4786">	RequestAllocator allocator(port-&gt;GetPort());</a>
<a name="ln4787">	IterativeIOFinishedRequest* request;</a>
<a name="ln4788">	status_t error = AllocateRequest(allocator, &amp;request);</a>
<a name="ln4789">	if (error != B_OK)</a>
<a name="ln4790">		return error;</a>
<a name="ln4791"> </a>
<a name="ln4792">	request-&gt;volume = volume-&gt;fUserlandVolume;</a>
<a name="ln4793">	request-&gt;cookie = cookie-&gt;clientCookie;</a>
<a name="ln4794">	request-&gt;request = cookie-&gt;requestID;</a>
<a name="ln4795">	request-&gt;status = status;</a>
<a name="ln4796">	request-&gt;partialTransfer = partialTransfer;</a>
<a name="ln4797">	request-&gt;bytesTransferred = bytesTransferred;</a>
<a name="ln4798"> </a>
<a name="ln4799">	// send the request</a>
<a name="ln4800">	KernelRequestHandler handler(volume, ITERATIVE_IO_FINISHED_REPLY);</a>
<a name="ln4801">	IterativeIOFinishedReply* reply;</a>
<a name="ln4802">	error = volume-&gt;_SendRequest(port, &amp;allocator, &amp;handler, (Request**)&amp;reply);</a>
<a name="ln4803">	if (error != B_OK)</a>
<a name="ln4804">		return error;</a>
<a name="ln4805">	RequestReleaser requestReleaser(port, reply);</a>
<a name="ln4806"> </a>
<a name="ln4807">	// process the reply</a>
<a name="ln4808">	if (reply-&gt;error != B_OK)</a>
<a name="ln4809">		return reply-&gt;error;</a>
<a name="ln4810">	return B_OK;</a>
<a name="ln4811">}</a>

</code></pre>
<div class="balloon" rel="2051"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'error == ((int) 0)' is always true.</p></div>
<div class="balloon" rel="295"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fVolumeOps.</p></div>
<div class="balloon" rel="61"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: hash_link.</p></div>
<div class="balloon" rel="121"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: idLink, structLink.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
