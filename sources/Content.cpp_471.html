
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>Content.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">Open Tracker License</a>
<a name="ln3"> </a>
<a name="ln4">Terms and Conditions</a>
<a name="ln5"> </a>
<a name="ln6">Copyright (c) 1991-2001, Be Incorporated. All rights reserved.</a>
<a name="ln7"> </a>
<a name="ln8">Permission is hereby granted, free of charge, to any person obtaining a copy of</a>
<a name="ln9">this software and associated documentation files (the &quot;Software&quot;), to deal in</a>
<a name="ln10">the Software without restriction, including without limitation the rights to</a>
<a name="ln11">use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies</a>
<a name="ln12">of the Software, and to permit persons to whom the Software is furnished to do</a>
<a name="ln13">so, subject to the following conditions:</a>
<a name="ln14"> </a>
<a name="ln15">The above copyright notice and this permission notice applies to all licensees</a>
<a name="ln16">and shall be included in all copies or substantial portions of the Software.</a>
<a name="ln17"> </a>
<a name="ln18">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</a>
<a name="ln19">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF TITLE, MERCHANTABILITY,</a>
<a name="ln20">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL</a>
<a name="ln21">BE INCORPORATED BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN</a>
<a name="ln22">AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF, OR IN</a>
<a name="ln23">CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</a>
<a name="ln24"> </a>
<a name="ln25">Except as contained in this notice, the name of Be Incorporated shall not be</a>
<a name="ln26">used in advertising or otherwise to promote the sale, use or other dealings in</a>
<a name="ln27">this Software without prior written authorization from Be Incorporated.</a>
<a name="ln28"> </a>
<a name="ln29">BeMail(TM), Tracker(TM), Be(R), BeOS(R), and BeIA(TM) are trademarks or</a>
<a name="ln30">registered trademarks of Be Incorporated in the United States and other</a>
<a name="ln31">countries. Other brand product names are registered trademarks or trademarks</a>
<a name="ln32">of their respective holders. All rights reserved.</a>
<a name="ln33">*/</a>
<a name="ln34"> </a>
<a name="ln35"> </a>
<a name="ln36">#include &lt;ctype.h&gt;</a>
<a name="ln37">#include &lt;stdio.h&gt;</a>
<a name="ln38">#include &lt;stdlib.h&gt;</a>
<a name="ln39">#include &lt;strings.h&gt;</a>
<a name="ln40"> </a>
<a name="ln41">#include &lt;Alert.h&gt;</a>
<a name="ln42">#include &lt;Beep.h&gt;</a>
<a name="ln43">#include &lt;Clipboard.h&gt;</a>
<a name="ln44">#include &lt;ControlLook.h&gt;</a>
<a name="ln45">#include &lt;Debug.h&gt;</a>
<a name="ln46">#include &lt;E-mail.h&gt;</a>
<a name="ln47">#include &lt;Input.h&gt;</a>
<a name="ln48">#include &lt;Locale.h&gt;</a>
<a name="ln49">#include &lt;MenuItem.h&gt;</a>
<a name="ln50">#include &lt;Mime.h&gt;</a>
<a name="ln51">#include &lt;NodeInfo.h&gt;</a>
<a name="ln52">#include &lt;NodeMonitor.h&gt;</a>
<a name="ln53">#include &lt;Path.h&gt;</a>
<a name="ln54">#include &lt;PopUpMenu.h&gt;</a>
<a name="ln55">#include &lt;Region.h&gt;</a>
<a name="ln56">#include &lt;Roster.h&gt;</a>
<a name="ln57">#include &lt;ScrollView.h&gt;</a>
<a name="ln58">#include &lt;TextView.h&gt;</a>
<a name="ln59">#include &lt;UTF8.h&gt;</a>
<a name="ln60"> </a>
<a name="ln61">#include &lt;MailMessage.h&gt;</a>
<a name="ln62">#include &lt;MailAttachment.h&gt;</a>
<a name="ln63">#include &lt;mail_util.h&gt;</a>
<a name="ln64"> </a>
<a name="ln65">#include &quot;MailApp.h&quot;</a>
<a name="ln66">#include &quot;MailSupport.h&quot;</a>
<a name="ln67">#include &quot;MailWindow.h&quot;</a>
<a name="ln68">#include &quot;Messages.h&quot;</a>
<a name="ln69">#include &quot;Content.h&quot;</a>
<a name="ln70">#include &quot;Utilities.h&quot;</a>
<a name="ln71">#include &quot;FieldMsg.h&quot;</a>
<a name="ln72">#include &quot;Words.h&quot;</a>
<a name="ln73"> </a>
<a name="ln74"> </a>
<a name="ln75">#define DEBUG_SPELLCHECK 0</a>
<a name="ln76">#if DEBUG_SPELLCHECK</a>
<a name="ln77">#	define DSPELL(x) x</a>
<a name="ln78">#else</a>
<a name="ln79">#	define DSPELL(x) ;</a>
<a name="ln80">#endif</a>
<a name="ln81"> </a>
<a name="ln82"> </a>
<a name="ln83">#define B_TRANSLATION_CONTEXT &quot;Mail&quot;</a>
<a name="ln84"> </a>
<a name="ln85"> </a>
<a name="ln86">const rgb_color kNormalTextColor = {0, 0, 0, 255};</a>
<a name="ln87">const rgb_color kSpellTextColor = {255, 0, 0, 255};</a>
<a name="ln88">const rgb_color kHyperLinkColor = {0, 0, 255, 255};</a>
<a name="ln89">const rgb_color kHeaderColor = {72, 72, 72, 255};</a>
<a name="ln90"> </a>
<a name="ln91">const rgb_color kQuoteColors[] = {</a>
<a name="ln92">	{0, 0, 0x80, 0},		// 3rd, 6th, ... quote level color (blue)</a>
<a name="ln93">	{0, 0x80, 0, 0},		// 1st, 4th, ... quote level color (green)</a>
<a name="ln94">	{0x80, 0, 0, 0}			// 2nd, ... (red)</a>
<a name="ln95">};</a>
<a name="ln96">const int32 kNumQuoteColors = 3;</a>
<a name="ln97"> </a>
<a name="ln98">const rgb_color kDiffColors[] = {</a>
<a name="ln99">	{0xb0, 0, 0, 0},		// '-', red</a>
<a name="ln100">	{0, 0x90, 0, 0},		// '+', green</a>
<a name="ln101">	{0x6a, 0x6a, 0x6a, 0}	// '@@', dark grey</a>
<a name="ln102">};</a>
<a name="ln103"> </a>
<a name="ln104">void Unicode2UTF8(int32 c, char **out);</a>
<a name="ln105"> </a>
<a name="ln106"> </a>
<a name="ln107">inline bool</a>
<a name="ln108">IsInitialUTF8Byte(uchar b)</a>
<a name="ln109">{</a>
<a name="ln110">	return ((b &amp; 0xC0) != 0x80);</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113"> </a>
<a name="ln114">void</a>
<a name="ln115">Unicode2UTF8(int32 c, char **out)</a>
<a name="ln116">{</a>
<a name="ln117">	char *s = *out;</a>
<a name="ln118"> </a>
<a name="ln119">	ASSERT(c &lt; 0x200000);</a>
<a name="ln120"> </a>
<a name="ln121">	if (c &lt; 0x80)</a>
<a name="ln122">		*(s++) = c;</a>
<a name="ln123">	else if (c &lt; 0x800) {</a>
<a name="ln124">		*(s++) = 0xc0 | (c &gt;&gt; 6);</a>
<a name="ln125">		*(s++) = 0x80 | (c &amp; 0x3f);</a>
<a name="ln126">	} else if (c &lt; 0x10000) {</a>
<a name="ln127">		*(s++) = 0xe0 | (c &gt;&gt; 12);</a>
<a name="ln128">		*(s++) = 0x80 | ((c &gt;&gt; 6) &amp; 0x3f);</a>
<a name="ln129">		*(s++) = 0x80 | (c &amp; 0x3f);</a>
<a name="ln130">	} else if (c &lt; 0x200000) {</a>
<a name="ln131">		*(s++) = 0xf0 | (c &gt;&gt; 18);</a>
<a name="ln132">		*(s++) = 0x80 | ((c &gt;&gt; 12) &amp; 0x3f);</a>
<a name="ln133">		*(s++) = 0x80 | ((c &gt;&gt; 6) &amp; 0x3f);</a>
<a name="ln134">		*(s++) = 0x80 | (c &amp; 0x3f);</a>
<a name="ln135">	}</a>
<a name="ln136">	*out = s;</a>
<a name="ln137">}</a>
<a name="ln138"> </a>
<a name="ln139"> </a>
<a name="ln140">static bool</a>
<a name="ln141">FilterHTMLTag(int32 &amp;first, char **t, char *end)</a>
<a name="ln142">{</a>
<a name="ln143">	const char *newlineTags[] = {</a>
<a name="ln144">		&quot;br&quot;, &quot;/p&quot;, &quot;/div&quot;, &quot;/table&quot;, &quot;/tr&quot;,</a>
<a name="ln145">		NULL};</a>
<a name="ln146"> </a>
<a name="ln147">	char *a = *t;</a>
<a name="ln148"> </a>
<a name="ln149">	// check for some common entities (in ISO-Latin-1)</a>
<a name="ln150">	if (first == '&amp;') {</a>
<a name="ln151">		// filter out and convert decimal values</a>
<a name="ln152">		if (a[1] == '#' &amp;&amp; sscanf(a + 2, &quot;%&quot; B_SCNd32 &quot;;&quot;, &amp;first) == 1) {</a>
<a name="ln153">			t[0] += strchr(a, ';') - a;</a>
<a name="ln154">			return false;</a>
<a name="ln155">		}</a>
<a name="ln156"> </a>
<a name="ln157">		const struct { const char *name; int32 code; } entities[] = {</a>
<a name="ln158">			// this list is sorted alphabetically to be binary searchable</a>
<a name="ln159">			// the current implementation doesn't do this, though</a>
<a name="ln160"> </a>
<a name="ln161">			// &quot;name&quot; is the entity name,</a>
<a name="ln162">			// &quot;code&quot; is the corresponding unicode</a>
<a name="ln163">			{&quot;AElig;&quot;,	0x00c6},</a>
<a name="ln164">			{&quot;Aacute;&quot;,	0x00c1},</a>
<a name="ln165">			{&quot;Acirc;&quot;,	0x00c2},</a>
<a name="ln166">			{&quot;Agrave;&quot;,	0x00c0},</a>
<a name="ln167">			{&quot;Aring;&quot;,	0x00c5},</a>
<a name="ln168">			{&quot;Atilde;&quot;,	0x00c3},</a>
<a name="ln169">			{&quot;Auml;&quot;,	0x00c4},</a>
<a name="ln170">			{&quot;Ccedil;&quot;,	0x00c7},</a>
<a name="ln171">			{&quot;Eacute;&quot;,	0x00c9},</a>
<a name="ln172">			{&quot;Ecirc;&quot;,	0x00ca},</a>
<a name="ln173">			{&quot;Egrave;&quot;,	0x00c8},</a>
<a name="ln174">			{&quot;Euml;&quot;,	0x00cb},</a>
<a name="ln175">			{&quot;Iacute;&quot;, 0x00cd},</a>
<a name="ln176">			{&quot;Icirc;&quot;,	0x00ce},</a>
<a name="ln177">			{&quot;Igrave;&quot;, 0x00cc},</a>
<a name="ln178">			{&quot;Iuml;&quot;,	0x00cf},</a>
<a name="ln179">			{&quot;Ntilde;&quot;,	0x00d1},</a>
<a name="ln180">			{&quot;Oacute;&quot;, 0x00d3},</a>
<a name="ln181">			{&quot;Ocirc;&quot;,	0x00d4},</a>
<a name="ln182">			{&quot;Ograve;&quot;, 0x00d2},</a>
<a name="ln183">			{&quot;Ouml;&quot;,	0x00d6},</a>
<a name="ln184">			{&quot;Uacute;&quot;, 0x00da},</a>
<a name="ln185">			{&quot;Ucirc;&quot;,	0x00db},</a>
<a name="ln186">			{&quot;Ugrave;&quot;, 0x00d9},</a>
<a name="ln187">			{&quot;Uuml;&quot;,	0x00dc},</a>
<a name="ln188">			{&quot;aacute;&quot;, 0x00e1},</a>
<a name="ln189">			{&quot;acirc;&quot;,	0x00e2},</a>
<a name="ln190">			{&quot;aelig;&quot;,	0x00e6},</a>
<a name="ln191">			{&quot;agrave;&quot;, 0x00e0},</a>
<a name="ln192">			{&quot;amp;&quot;,	'&amp;'},</a>
<a name="ln193">			{&quot;aring;&quot;,	0x00e5},</a>
<a name="ln194">			{&quot;atilde;&quot;, 0x00e3},</a>
<a name="ln195">			{&quot;auml;&quot;,	0x00e4},</a>
<a name="ln196">			{&quot;ccedil;&quot;,	0x00e7},</a>
<a name="ln197">			{&quot;copy;&quot;,	0x00a9},</a>
<a name="ln198">			{&quot;eacute;&quot;,	0x00e9},</a>
<a name="ln199">			{&quot;ecirc;&quot;,	0x00ea},</a>
<a name="ln200">			{&quot;egrave;&quot;,	0x00e8},</a>
<a name="ln201">			{&quot;euml;&quot;,	0x00eb},</a>
<a name="ln202">			{&quot;gt;&quot;,		'&gt;'},</a>
<a name="ln203">			{&quot;iacute;&quot;, 0x00ed},</a>
<a name="ln204">			{&quot;icirc;&quot;,	0x00ee},</a>
<a name="ln205">			{&quot;igrave;&quot;, 0x00ec},</a>
<a name="ln206">			{&quot;iuml;&quot;,	0x00ef},</a>
<a name="ln207">			{&quot;lt;&quot;,		'&lt;'},</a>
<a name="ln208">			{&quot;nbsp;&quot;,	' '},</a>
<a name="ln209">			{&quot;ntilde;&quot;,	0x00f1},</a>
<a name="ln210">			{&quot;oacute;&quot;, 0x00f3},</a>
<a name="ln211">			{&quot;ocirc;&quot;,	0x00f4},</a>
<a name="ln212">			{&quot;ograve;&quot;, 0x00f2},</a>
<a name="ln213">			{&quot;ouml;&quot;,	0x00f6},</a>
<a name="ln214">			{&quot;quot;&quot;,	'&quot;'},</a>
<a name="ln215">			{&quot;szlig;&quot;,	0x00df},</a>
<a name="ln216">			{&quot;uacute;&quot;, 0x00fa},</a>
<a name="ln217">			{&quot;ucirc;&quot;,	0x00fb},</a>
<a name="ln218">			{&quot;ugrave;&quot;, 0x00f9},</a>
<a name="ln219">			{&quot;uuml;&quot;,	0x00fc},</a>
<a name="ln220">			{NULL, 0}</a>
<a name="ln221">		};</a>
<a name="ln222"> </a>
<a name="ln223">		for (int32 i = 0; entities[i].name; i++) {</a>
<a name="ln224">			// entities are case-sensitive</a>
<a name="ln225">			int32 length = strlen(entities[i].name);</a>
<a name="ln226">			if (!strncmp(a + 1, entities[i].name, length)) {</a>
<a name="ln227">				t[0] += length;	// note that the '&amp;' is included here</a>
<a name="ln228">				first = entities[i].code;</a>
<a name="ln229">				return false;</a>
<a name="ln230">			}</a>
<a name="ln231">		}</a>
<a name="ln232">	}</a>
<a name="ln233"> </a>
<a name="ln234">	// no tag to filter</a>
<a name="ln235">	if (first != '&lt;')</a>
<a name="ln236">		return false;</a>
<a name="ln237"> </a>
<a name="ln238">	a++;</a>
<a name="ln239"> </a>
<a name="ln240">	// is the tag one of the newline tags?</a>
<a name="ln241"> </a>
<a name="ln242">	bool newline = false;</a>
<a name="ln243">	for (int i = 0; newlineTags[i]; i++) {</a>
<a name="ln244">		int length = strlen(newlineTags[i]);</a>
<a name="ln245">		if (!strncasecmp(a, (char *)newlineTags[i], length) &amp;&amp; !isalnum(a[length])) {</a>
<a name="ln246">			newline = true;</a>
<a name="ln247">			break;</a>
<a name="ln248">		}</a>
<a name="ln249">	}</a>
<a name="ln250"> </a>
<a name="ln251">	// oh, it's not, so skip it!</a>
<a name="ln252"> </a>
<a name="ln253">	if (!strncasecmp(a, &quot;head&quot;, 4)) {	// skip &quot;head&quot; completely</a>
<a name="ln254">		for (; a[0] &amp;&amp; a &lt; end; a++) {</a>
<a name="ln255">			// Find the end of the HEAD section, or the start of the BODY,</a>
<a name="ln256">			// which happens for some malformed spam.</a>
<a name="ln257">			if (strncasecmp (a, &quot;&lt;/head&quot;, 6) == 0 ||</a>
<a name="ln258">				strncasecmp (a, &quot;&lt;body&quot;, 5) == 0)</a>
<a name="ln259">				break;</a>
<a name="ln260">		}</a>
<a name="ln261">	}</a>
<a name="ln262"> </a>
<a name="ln263">	// skip until tag end</a>
<a name="ln264">	while (a[0] &amp;&amp; a[0] != '&gt;' &amp;&amp; a &lt; end)</a>
<a name="ln265">		a++;</a>
<a name="ln266"> </a>
<a name="ln267">	t[0] = a;</a>
<a name="ln268"> </a>
<a name="ln269">	if (newline) {</a>
<a name="ln270">		first = '\n';</a>
<a name="ln271">		return false;</a>
<a name="ln272">	}</a>
<a name="ln273"> </a>
<a name="ln274">	return true;</a>
<a name="ln275">}</a>
<a name="ln276"> </a>
<a name="ln277"> </a>
<a name="ln278">/*! Returns the type of the next URL in the string.</a>
<a name="ln279"> *</a>
<a name="ln280"> * If the &quot;url&quot; string is specified, it will fill it with the complete</a>
<a name="ln281"> * URL.</a>
<a name="ln282"> */</a>
<a name="ln283">static uint8</a>
<a name="ln284">FindURL(const BString&amp; string, int32 startIndex, int32&amp; urlPos,</a>
<a name="ln285">	int32&amp; urlLength, BString* urlString = NULL)</a>
<a name="ln286">{</a>
<a name="ln287">	uint8 type = 0;</a>
<a name="ln288">	urlPos = string.Length();</a>
<a name="ln289"> </a>
<a name="ln290">	int32 baseOffset = string.FindFirst(&quot;://&quot;, startIndex),</a>
<a name="ln291">		mailtoOffset = string.FindFirst(&quot;mailto:&quot;, startIndex);</a>
<a name="ln292">	if (baseOffset == B_ERROR &amp;&amp; mailtoOffset == B_ERROR)</a>
<a name="ln293">		return 0;</a>
<a name="ln294">	if (baseOffset == B_ERROR)</a>
<a name="ln295">		baseOffset = string.Length();</a>
<a name="ln296">	if (mailtoOffset == B_ERROR)</a>
<a name="ln297">		mailtoOffset = string.Length();</a>
<a name="ln298"> </a>
<a name="ln299">	if (baseOffset &lt; mailtoOffset) {</a>
<a name="ln300">		type = TYPE_URL;</a>
<a name="ln301"> </a>
<a name="ln302">		// Find the actual start of the URL</a>
<a name="ln303">		urlPos = baseOffset;</a>
<a name="ln304">		while (urlPos &gt;= startIndex &amp;&amp; (isalnum(string.ByteAt(urlPos - 1))</a>
<a name="ln305">				|| string.ByteAt(urlPos - 1) == '-'))</a>
<a name="ln306">			urlPos--;</a>
<a name="ln307">	} else if (mailtoOffset &lt; baseOffset) {</a>
<a name="ln308">		type = TYPE_MAILTO;</a>
<a name="ln309">		urlPos = mailtoOffset;</a>
<a name="ln310">	}</a>
<a name="ln311"> </a>
<a name="ln312">	// find the end of the URL based on word boundaries</a>
<a name="ln313">	const char* str = string.String() + urlPos;</a>
<a name="ln314">	urlLength = strcspn(str, &quot; \t&lt;&gt;)\&quot;\\,\r\n&quot;);</a>
<a name="ln315"> </a>
<a name="ln316">	// filter out some punctuation marks if they are the last character</a>
<a name="ln317">	while (urlLength &gt; 0) {</a>
<a name="ln318">		char suffix = str[urlLength - 1];</a>
<a name="ln319">		if (suffix != '.'</a>
<a name="ln320">				&amp;&amp; suffix != ','</a>
<a name="ln321">				&amp;&amp; suffix != '?'</a>
<a name="ln322">				&amp;&amp; suffix != '!'</a>
<a name="ln323">				&amp;&amp; suffix != ':'</a>
<a name="ln324">				&amp;&amp; suffix != ';')</a>
<a name="ln325">			break;</a>
<a name="ln326">		urlLength--;</a>
<a name="ln327">	}</a>
<a name="ln328"> </a>
<a name="ln329">	if (urlString != NULL)</a>
<a name="ln330">		*urlString = BString(string.String() + urlPos, urlLength);</a>
<a name="ln331"> </a>
<a name="ln332">	return type;</a>
<a name="ln333">}</a>
<a name="ln334"> </a>
<a name="ln335"> </a>
<a name="ln336">static void</a>
<a name="ln337">CopyQuotes(const char *text, size_t length, char *outText, size_t &amp;outLength)</a>
<a name="ln338">{</a>
<a name="ln339">	// count qoute level (to be able to wrap quotes correctly)</a>
<a name="ln340"> </a>
<a name="ln341">	const char *quote = QUOTE;</a>
<a name="ln342">	int32 level = 0;</a>
<a name="ln343">	for (size_t i = 0; i &lt; length; i++) {</a>
<a name="ln344">		if (text[i] == quote[0])</a>
<a name="ln345">			level++;</a>
<a name="ln346">		else if (text[i] != ' ' &amp;&amp; text[i] != '\t')</a>
<a name="ln347">			break;</a>
<a name="ln348">	}</a>
<a name="ln349"> </a>
<a name="ln350">	// if there are too much quotes, try to preserve the quote color level</a>
<a name="ln351">	if (level &gt; 10)</a>
<a name="ln352">		level = kNumQuoteColors * 3 + (level % kNumQuoteColors);</a>
<a name="ln353"> </a>
<a name="ln354">	// copy the quotes to outText</a>
<a name="ln355"> </a>
<a name="ln356">	const int32 quoteLength = strlen(QUOTE);</a>
<a name="ln357">	outLength = 0;</a>
<a name="ln358">	while (level-- &gt; 0) {</a>
<a name="ln359">		strcpy(outText + outLength, QUOTE);</a>
<a name="ln360">		outLength += quoteLength;</a>
<a name="ln361">	}</a>
<a name="ln362">}</a>
<a name="ln363"> </a>
<a name="ln364"> </a>
<a name="ln365">int32</a>
<a name="ln366">diff_mode(char c)</a>
<a name="ln367">{</a>
<a name="ln368">	if (c == '+')</a>
<a name="ln369">		return 2;</a>
<a name="ln370">	if (c == '-')</a>
<a name="ln371">		return 1;</a>
<a name="ln372">	if (c == '@')</a>
<a name="ln373">		return 3;</a>
<a name="ln374">	if (c == ' ')</a>
<a name="ln375">		return 0;</a>
<a name="ln376"> </a>
<a name="ln377">	// everything else ends the diff mode</a>
<a name="ln378">	return -1;</a>
<a name="ln379">}</a>
<a name="ln380"> </a>
<a name="ln381"> </a>
<a name="ln382">bool</a>
<a name="ln383">is_quote_char(char c)</a>
<a name="ln384">{</a>
<a name="ln385">	return c == '&gt;' || c == '|';</a>
<a name="ln386">}</a>
<a name="ln387"> </a>
<a name="ln388"> </a>
<a name="ln389">/*!	Fills the specified text_run_array with the correct values for the</a>
<a name="ln390">	specified text.</a>
<a name="ln391">	If &quot;view&quot; is NULL, it will assume that &quot;line&quot; lies on a line break,</a>
<a name="ln392">	if not, it will correctly retrieve the number of quotes the current</a>
<a name="ln393">	line already has.</a>
<a name="ln394">*/</a>
<a name="ln395">void</a>
<a name="ln396">FillInQuoteTextRuns(BTextView* view, quote_context* context, const char* line,</a>
<a name="ln397">	int32 length, const BFont&amp; font, text_run_array* style, int32 maxStyles)</a>
<a name="ln398">{</a>
<a name="ln399">	text_run* runs = style-&gt;runs;</a>
<a name="ln400">	int32 index = style-&gt;count;</a>
<a name="ln401">	bool begin;</a>
<a name="ln402">	int32 pos = 0;</a>
<a name="ln403">	int32 diffMode = 0;</a>
<a name="ln404">	bool inDiff = false;</a>
<a name="ln405">	bool wasDiff = false;</a>
<a name="ln406">	int32 level = 0;</a>
<a name="ln407"> </a>
<a name="ln408">	// get index to the beginning of the current line</a>
<a name="ln409"> </a>
<a name="ln410">	if (context != NULL) {</a>
<a name="ln411">		level = context-&gt;level;</a>
<a name="ln412">		diffMode = context-&gt;diff_mode;</a>
<a name="ln413">		begin = context-&gt;begin;</a>
<a name="ln414">		inDiff = context-&gt;in_diff;</a>
<a name="ln415">		wasDiff = context-&gt;was_diff;</a>
<a name="ln416">	} else if (view != NULL) {</a>
<a name="ln417">		int32 start, end;</a>
<a name="ln418">		view-&gt;GetSelection(&amp;end, &amp;end);</a>
<a name="ln419"> </a>
<a name="ln420">		begin = view-&gt;TextLength() == 0</a>
<a name="ln421">			|| view-&gt;ByteAt(view-&gt;TextLength() - 1) == '\n';</a>
<a name="ln422"> </a>
<a name="ln423">		// the following line works only reliable when text wrapping is set to</a>
<a name="ln424">		// off; so the complicated version actually used here is necessary:</a>
<a name="ln425">		// start = view-&gt;OffsetAt(view-&gt;CurrentLine());</a>
<a name="ln426"> </a>
<a name="ln427">		const char *text = view-&gt;Text();</a>
<a name="ln428"> </a>
<a name="ln429">		if (!begin) {</a>
<a name="ln430">			// if the text is not the start of a new line, go back</a>
<a name="ln431">			// to the first character in the current line</a>
<a name="ln432">			for (start = end; start &gt; 0; start--) {</a>
<a name="ln433">				if (text[start - 1] == '\n')</a>
<a name="ln434">					break;</a>
<a name="ln435">			}</a>
<a name="ln436">		}</a>
<a name="ln437"> </a>
<a name="ln438">		// get number of nested qoutes for current line</a>
<a name="ln439"> </a>
<a name="ln440">		if (!begin &amp;&amp; start &lt; end) {</a>
<a name="ln441">			begin = true;</a>
<a name="ln442">				// if there was no text in this line, there may come</a>
<a name="ln443">				// more nested quotes</a>
<a name="ln444"> </a>
<a name="ln445">			diffMode = diff_mode(text[start]);</a>
<a name="ln446">			if (diffMode == 0) {</a>
<a name="ln447">				for (int32 i = start; i &lt; end; i++) {</a>
<a name="ln448">					if (is_quote_char(text[i]))</a>
<a name="ln449">						level++;</a>
<a name="ln450">					else if (text[i] != ' ' &amp;&amp; text[i] != '\t') {</a>
<a name="ln451">						begin = false;</a>
<a name="ln452">						break;</a>
<a name="ln453">					}</a>
<a name="ln454">				}</a>
<a name="ln455">			} else</a>
<a name="ln456">				inDiff = true;</a>
<a name="ln457"> </a>
<a name="ln458">			if (begin) {</a>
<a name="ln459">				// skip leading spaces (tabs &amp; newlines aren't allowed here)</a>
<a name="ln460">				while (line[pos] == ' ')</a>
<a name="ln461">					pos++;</a>
<a name="ln462">			}</a>
<a name="ln463">		}</a>
<a name="ln464">	} else</a>
<a name="ln465">		begin = true;</a>
<a name="ln466"> </a>
<a name="ln467">	// set styles for all qoute levels in the text to be inserted</a>
<a name="ln468"> </a>
<a name="ln469">	for (int32 pos = 0; pos &lt; length;) {</a>
<a name="ln470">		int32 next;</a>
<a name="ln471">		if (begin &amp;&amp; is_quote_char(line[pos])) {</a>
<a name="ln472">			begin = false;</a>
<a name="ln473"> </a>
<a name="ln474">			while (pos &lt; length &amp;&amp; line[pos] != '\n') {</a>
<a name="ln475">				// insert style for each quote level</a>
<a name="ln476">				level++;</a>
<a name="ln477"> </a>
<a name="ln478">				bool search = true;</a>
<a name="ln479">				for (next = pos + 1; next &lt; length; next++) {</a>
<a name="ln480">					if ((search &amp;&amp; is_quote_char(line[next]))</a>
<a name="ln481">						|| line[next] == '\n')</a>
<a name="ln482">						break;</a>
<a name="ln483">					else if (search &amp;&amp; line[next] != ' ' &amp;&amp; line[next] != '\t')</a>
<a name="ln484">						search = false;</a>
<a name="ln485">				}</a>
<a name="ln486"> </a>
<a name="ln487">				runs[index].offset = pos;</a>
<a name="ln488">				runs[index].font = font;</a>
<a name="ln489">				runs[index].color = level &gt; 0</a>
<a name="ln490">					? kQuoteColors[level % kNumQuoteColors] : kNormalTextColor;</a>
<a name="ln491"> </a>
<a name="ln492">				pos = next;</a>
<a name="ln493">				if (++index &gt;= maxStyles)</a>
<a name="ln494">					break;</a>
<a name="ln495">			}</a>
<a name="ln496">		} else {</a>
<a name="ln497">			if (begin) {</a>
<a name="ln498">				if (!inDiff) {</a>
<a name="ln499">					inDiff = !strncmp(&amp;line[pos], &quot;--- &quot;, 4);</a>
<a name="ln500">					wasDiff = false;</a>
<a name="ln501">				}</a>
<a name="ln502">				if (inDiff) {</a>
<a name="ln503">					diffMode = diff_mode(line[pos]);</a>
<a name="ln504">					if (diffMode &lt; 0) {</a>
<a name="ln505">						inDiff = false;</a>
<a name="ln506">						wasDiff = true;</a>
<a name="ln507">					}</a>
<a name="ln508">				}</a>
<a name="ln509">			}</a>
<a name="ln510"> </a>
<a name="ln511">			runs[index].offset = pos;</a>
<a name="ln512">			runs[index].font = font;</a>
<a name="ln513">			if (wasDiff)</a>
<a name="ln514">				runs[index].color = kDiffColors[diff_mode('@') - 1];</a>
<a name="ln515">			else if (diffMode &lt;= 0) {</a>
<a name="ln516">				runs[index].color = level &gt; 0</a>
<a name="ln517">					? kQuoteColors[level % kNumQuoteColors] : kNormalTextColor;</a>
<a name="ln518">			} else</a>
<a name="ln519">				runs[index].color = kDiffColors[diffMode - 1];</a>
<a name="ln520"> </a>
<a name="ln521">			begin = false;</a>
<a name="ln522"> </a>
<a name="ln523">			for (next = pos; next &lt; length; next++) {</a>
<a name="ln524">				if (line[next] == '\n') {</a>
<a name="ln525">					begin = true;</a>
<a name="ln526">					wasDiff = false;</a>
<a name="ln527">					break;</a>
<a name="ln528">				}</a>
<a name="ln529">			}</a>
<a name="ln530"> </a>
<a name="ln531">			pos = next;</a>
<a name="ln532">			index++;</a>
<a name="ln533">		}</a>
<a name="ln534"> </a>
<a name="ln535">		if (pos &lt; length)</a>
<a name="ln536">			begin = line[pos] == '\n';</a>
<a name="ln537"> </a>
<a name="ln538">		if (begin) {</a>
<a name="ln539">			pos++;</a>
<a name="ln540">			level = 0;</a>
<a name="ln541">			wasDiff = false;</a>
<a name="ln542"> </a>
<a name="ln543">			// skip one leading space (tabs &amp; newlines aren't allowed here)</a>
<a name="ln544">			if (!inDiff &amp;&amp; pos &lt; length &amp;&amp; line[pos] == ' ')</a>
<a name="ln545">				pos++;</a>
<a name="ln546">		}</a>
<a name="ln547"> </a>
<a name="ln548">		if (index &gt;= maxStyles)</a>
<a name="ln549">			break;</a>
<a name="ln550">	}</a>
<a name="ln551">	style-&gt;count = index;</a>
<a name="ln552"> </a>
<a name="ln553">	if (context) {</a>
<a name="ln554">		// update context for next run</a>
<a name="ln555">		context-&gt;level = level;</a>
<a name="ln556">		context-&gt;diff_mode = diffMode;</a>
<a name="ln557">		context-&gt;begin = begin;</a>
<a name="ln558">		context-&gt;in_diff = inDiff;</a>
<a name="ln559">		context-&gt;was_diff = wasDiff;</a>
<a name="ln560">	}</a>
<a name="ln561">}</a>
<a name="ln562"> </a>
<a name="ln563"> </a>
<a name="ln564">//	#pragma mark -</a>
<a name="ln565"> </a>
<a name="ln566"> </a>
<a name="ln567">TextRunArray::TextRunArray(size_t entries)</a>
<a name="ln568">	:</a>
<a name="ln569">	fNumEntries(entries)</a>
<a name="ln570">{</a>
<a name="ln571">	fArray = (text_run_array *)malloc(sizeof(int32) + sizeof(text_run) * entries);</a>
<a name="ln572">	if (fArray != NULL)</a>
<a name="ln573">		fArray-&gt;count = 0;</a>
<a name="ln574">}</a>
<a name="ln575"> </a>
<a name="ln576"> </a>
<a name="ln577">TextRunArray::~TextRunArray()</a>
<a name="ln578">{</a>
<a name="ln579">	free(fArray);</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582"> </a>
<a name="ln583">//	#pragma mark -</a>
<a name="ln584"> </a>
<a name="ln585"> </a>
<a name="ln586">TContentView::TContentView(bool incoming, BFont* font,</a>
<a name="ln587">	bool showHeader, bool coloredQuotes)</a>
<a name="ln588">	:</a>
<a name="ln589">	BView(&quot;m_content&quot;, B_WILL_DRAW | B_FULL_UPDATE_ON_RESIZE),</a>
<a name="ln590">	fFocus(false),</a>
<a name="ln591">	fIncoming(incoming)</a>
<a name="ln592">{</a>
<a name="ln593">	SetViewUIColor(B_PANEL_BACKGROUND_COLOR);</a>
<a name="ln594"> </a>
<a name="ln595">	BGroupLayout* layout = new BGroupLayout(B_VERTICAL, 0);</a>
<a name="ln596">	SetLayout(layout);</a>
<a name="ln597"> </a>
<a name="ln598">	fTextView = new TTextView(fIncoming, this, font, showHeader,</a>
<a name="ln599">		coloredQuotes);</a>
<a name="ln600"> </a>
<a name="ln601">	BScrollView* scrollView = new BScrollView(&quot;&quot;, fTextView, 0, true, true);</a>
<a name="ln602">	scrollView-&gt;SetBorders(BControlLook::B_TOP_BORDER);</a>
<a name="ln603">	AddChild(scrollView);</a>
<a name="ln604">}</a>
<a name="ln605"> </a>
<a name="ln606"> </a>
<a name="ln607">void</a>
<a name="ln608">TContentView::FindString(const char *str)</a>
<a name="ln609">{</a>
<a name="ln610">	int32	finish;</a>
<a name="ln611">	int32	pass = 0;</a>
<a name="ln612">	int32	start = 0;</a>
<a name="ln613"> </a>
<a name="ln614">	if (str == NULL)</a>
<a name="ln615">		return;</a>
<a name="ln616"> </a>
<a name="ln617">	//</a>
<a name="ln618">	//	Start from current selection or from the beginning of the pool</a>
<a name="ln619">	//</a>
<a name="ln620">	const char *text = fTextView-&gt;Text();</a>
<a name="ln621">	int32 count = fTextView-&gt;TextLength();</a>
<a name="ln622">	fTextView-&gt;GetSelection(&amp;start, &amp;finish);</a>
<a name="ln623">	if (start != finish)</a>
<a name="ln624">		start = finish;</a>
<a name="ln625">	if (!count || text == NULL)</a>
<a name="ln626">		return;</a>
<a name="ln627"> </a>
<a name="ln628">	//</a>
<a name="ln629">	//	Do the find</a>
<a name="ln630">	//</a>
<a name="ln631">	while (pass &lt; 2) {</a>
<a name="ln632">		long found = -1;</a>
<a name="ln633">		char lc = tolower(str[0]);</a>
<a name="ln634">		char uc = toupper(str[0]);</a>
<a name="ln635">		for (long i = start; i &lt; count; i++) {</a>
<a name="ln636">			if (text[i] == lc || text[i] == uc) {</a>
<a name="ln637">				const char *s = str;</a>
<a name="ln638">				const char *t = text + i;</a>
<a name="ln639">				while (*s &amp;&amp; (tolower(*s) == tolower(*t))) {</a>
<a name="ln640">					s++;</a>
<a name="ln641">					t++;</a>
<a name="ln642">				}</a>
<a name="ln643">				if (*s == 0) {</a>
<a name="ln644">					found = i;</a>
<a name="ln645">					break;</a>
<a name="ln646">				}</a>
<a name="ln647">			}</a>
<a name="ln648">		}</a>
<a name="ln649"> </a>
<a name="ln650">		//</a>
<a name="ln651">		//	Select the text if it worked</a>
<a name="ln652">		//</a>
<a name="ln653">		if (found != -1) {</a>
<a name="ln654">			Window()-&gt;Activate();</a>
<a name="ln655">			fTextView-&gt;Select(found, found + strlen(str));</a>
<a name="ln656">			fTextView-&gt;ScrollToSelection();</a>
<a name="ln657">			fTextView-&gt;MakeFocus(true);</a>
<a name="ln658">			return;</a>
<a name="ln659">		}</a>
<a name="ln660">		else if (start) {</a>
<a name="ln661">			start = 0;</a>
<a name="ln662">			text = fTextView-&gt;Text();</a>
<a name="ln663">			count = fTextView-&gt;TextLength();</a>
<a name="ln664">			pass++;</a>
<a name="ln665">		} else {</a>
<a name="ln666">			beep();</a>
<a name="ln667">			return;</a>
<a name="ln668">		}</a>
<a name="ln669">	}</a>
<a name="ln670">}</a>
<a name="ln671"> </a>
<a name="ln672"> </a>
<a name="ln673">void</a>
<a name="ln674">TContentView::Focus(bool focus)</a>
<a name="ln675">{</a>
<a name="ln676">	if (fFocus != focus) {</a>
<a name="ln677">		fFocus = focus;</a>
<a name="ln678">		Draw(Frame());</a>
<a name="ln679">	}</a>
<a name="ln680">}</a>
<a name="ln681"> </a>
<a name="ln682"> </a>
<a name="ln683">void</a>
<a name="ln684">TContentView::MessageReceived(BMessage *msg)</a>
<a name="ln685">{</a>
<a name="ln686">	switch (msg-&gt;what) {</a>
<a name="ln687">		case CHANGE_FONT:</a>
<a name="ln688">		{</a>
<a name="ln689">			BFont *font;</a>
<a name="ln690">			msg-&gt;FindPointer(&quot;font&quot;, (void **)&amp;font);</a>
<a name="ln691">			fTextView-&gt;UpdateFont(font);</a>
<a name="ln692">			fTextView-&gt;Invalidate(Bounds());</a>
<a name="ln693">			break;</a>
<a name="ln694">		}</a>
<a name="ln695"> </a>
<a name="ln696">		case M_QUOTE:</a>
<a name="ln697">		{</a>
<a name="ln698">			int32 start, finish;</a>
<a name="ln699">			fTextView-&gt;GetSelection(&amp;start, &amp;finish);</a>
<a name="ln700">			fTextView-&gt;AddQuote(start, finish);</a>
<a name="ln701">			break;</a>
<a name="ln702">		}</a>
<a name="ln703">		case M_REMOVE_QUOTE:</a>
<a name="ln704">		{</a>
<a name="ln705">			int32 start, finish;</a>
<a name="ln706">			fTextView-&gt;GetSelection(&amp;start, &amp;finish);</a>
<a name="ln707">			fTextView-&gt;RemoveQuote(start, finish);</a>
<a name="ln708">			break;</a>
<a name="ln709">		}</a>
<a name="ln710"> </a>
<a name="ln711">		case M_SIGNATURE:</a>
<a name="ln712">		{</a>
<a name="ln713">			if (fTextView-&gt;IsReaderThreadRunning()) {</a>
<a name="ln714">				// Do not add the signature until the reader thread</a>
<a name="ln715">				// is finished. Resubmit the message for later processing</a>
<a name="ln716">				Window()-&gt;PostMessage(msg);</a>
<a name="ln717">				break;</a>
<a name="ln718">			}</a>
<a name="ln719"> </a>
<a name="ln720">			entry_ref ref;</a>
<a name="ln721">			msg-&gt;FindRef(&quot;ref&quot;, &amp;ref);</a>
<a name="ln722"> </a>
<a name="ln723">			BFile file(&amp;ref, B_READ_ONLY);</a>
<a name="ln724">			if (file.InitCheck() == B_OK) {</a>
<a name="ln725">				int32 start, finish;</a>
<a name="ln726">				fTextView-&gt;GetSelection(&amp;start, &amp;finish);</a>
<a name="ln727"> </a>
<a name="ln728">				off_t size;</a>
<a name="ln729">				file.GetSize(&amp;size);</a>
<a name="ln730">				if (size &gt; 32768)	// safety against corrupt signatures</a>
<a name="ln731">					break;</a>
<a name="ln732"> </a>
<a name="ln733">				char *signature = (char *)malloc(size);</a>
<a name="ln734">				if (signature == NULL)</a>
<a name="ln735">					break;</a>
<a name="ln736">				ssize_t bytesRead = file.Read(signature, size);</a>
<a name="ln737">				if (bytesRead &lt; B_OK) {</a>
<a name="ln738">					free (signature);</a>
<a name="ln739">					break;</a>
<a name="ln740">				}</a>
<a name="ln741"> </a>
<a name="ln742">				const char *text = fTextView-&gt;Text();</a>
<a name="ln743">				int32 length = fTextView-&gt;TextLength();</a>
<a name="ln744"> </a>
<a name="ln745">				// reserve some empty lines before the signature</a>
<a name="ln746">				const char* newLines = &quot;\n\n\n\n&quot;;</a>
<a name="ln747">				if (length &amp;&amp; text[length - 1] == '\n')</a>
<a name="ln748">					newLines++;</a>
<a name="ln749"> </a>
<a name="ln750">				fTextView-&gt;Select(length, length);</a>
<a name="ln751">				fTextView-&gt;Insert(newLines, strlen(newLines));</a>
<a name="ln752">				length += strlen(newLines);</a>
<a name="ln753"> </a>
<a name="ln754">				// append the signature</a>
<a name="ln755">				fTextView-&gt;Select(length, length);</a>
<a name="ln756">				fTextView-&gt;Insert(signature, bytesRead);</a>
<a name="ln757">				fTextView-&gt;Select(length, length + bytesRead);</a>
<a name="ln758">				fTextView-&gt;ScrollToSelection();</a>
<a name="ln759"> </a>
<a name="ln760">				// set the editing cursor position</a>
<a name="ln761">				fTextView-&gt;Select(length - 2 , length - 2);</a>
<a name="ln762">				fTextView-&gt;ScrollToSelection();</a>
<a name="ln763">				free (signature);</a>
<a name="ln764">			} else {</a>
<a name="ln765">				beep();</a>
<a name="ln766">				BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln767">					B_TRANSLATE(&quot;An error occurred trying to open this &quot;</a>
<a name="ln768">						&quot;signature.&quot;), B_TRANSLATE(&quot;Sorry&quot;));</a>
<a name="ln769">				alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln770">				alert-&gt;Go();</a>
<a name="ln771">			}</a>
<a name="ln772">			break;</a>
<a name="ln773">		}</a>
<a name="ln774"> </a>
<a name="ln775">		case M_FIND:</a>
<a name="ln776">			FindString(msg-&gt;FindString(&quot;findthis&quot;));</a>
<a name="ln777">			break;</a>
<a name="ln778"> </a>
<a name="ln779">		default:</a>
<a name="ln780">			BView::MessageReceived(msg);</a>
<a name="ln781">	}</a>
<a name="ln782">}</a>
<a name="ln783"> </a>
<a name="ln784"> </a>
<a name="ln785">//	#pragma mark -</a>
<a name="ln786"> </a>
<a name="ln787"> </a>
<a name="ln788">TTextView::TTextView(bool incoming, TContentView *view,</a>
<a name="ln789">	BFont *font, bool showHeader, bool coloredQuotes)</a>
<a name="ln790">	:</a>
<a name="ln791">	BTextView(&quot;&quot;, B_WILL_DRAW | B_NAVIGABLE),</a>
<a name="ln792"> </a>
<a name="ln793">	fHeader(showHeader),</a>
<a name="ln794">	fColoredQuotes(coloredQuotes),</a>
<a name="ln795">	fReady(false),</a>
<a name="ln796">	fYankBuffer(NULL),</a>
<a name="ln797">	fLastPosition(-1),</a>
<a name="ln798">	fMail(NULL),</a>
<a name="ln799">	fFont(font),</a>
<a name="ln800">	fParent(view),</a>
<a name="ln801">	fStopLoading(false),</a>
<a name="ln802">	fThread(0),</a>
<a name="ln803">	fPanel(NULL),</a>
<a name="ln804">	fIncoming(incoming),</a>
<a name="ln805">	fSpellCheck(false),</a>
<a name="ln806">	fRaw(false),</a>
<a name="ln807">	fCursor(false),</a>
<a name="ln808">	fFirstSpellMark(NULL)</a>
<a name="ln809">{</a>
<a name="ln810">	fStopSem = create_sem(1, &quot;reader_sem&quot;);</a>
<a name="ln811">	SetStylable(true);</a>
<a name="ln812">	SetInsets(4, 4, 4, 4);</a>
<a name="ln813">		// TODO: have some font size related value here</a>
<a name="ln814">		// (ideally the same as in BTextControl, etc. from BControlLook)</a>
<a name="ln815"> </a>
<a name="ln816">	fEnclosures = new BList();</a>
<a name="ln817"> </a>
<a name="ln818">	// Enclosure pop up menu</a>
<a name="ln819">	fEnclosureMenu = new BPopUpMenu(&quot;Enclosure&quot;, false, false);</a>
<a name="ln820">	fEnclosureMenu-&gt;SetFont(be_plain_font);</a>
<a name="ln821">	fEnclosureMenu-&gt;AddItem(new BMenuItem(</a>
<a name="ln822">		B_TRANSLATE(&quot;Save attachment&quot; B_UTF8_ELLIPSIS),	new BMessage(M_SAVE)));</a>
<a name="ln823">	fEnclosureMenu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Open attachment&quot;),</a>
<a name="ln824">		new BMessage(M_OPEN)));</a>
<a name="ln825"> </a>
<a name="ln826">	// Hyperlink pop up menu</a>
<a name="ln827">	fLinkMenu = new BPopUpMenu(&quot;Link&quot;, false, false);</a>
<a name="ln828">	fLinkMenu-&gt;SetFont(be_plain_font);</a>
<a name="ln829">	fLinkMenu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Open this link&quot;),</a>
<a name="ln830">		new BMessage(M_OPEN)));</a>
<a name="ln831">	fLinkMenu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Copy link location&quot;),</a>
<a name="ln832">		new BMessage(M_COPY)));</a>
<a name="ln833"> </a>
<a name="ln834">	SetDoesUndo(true);</a>
<a name="ln835"> </a>
<a name="ln836">	//Undo function</a>
<a name="ln837">	fUndoBuffer.On();</a>
<a name="ln838">	fInputMethodUndoBuffer.On();</a>
<a name="ln839">	fUndoState.replaced = false;</a>
<a name="ln840">	fUndoState.deleted = false;</a>
<a name="ln841">	fInputMethodUndoState.active = false;</a>
<a name="ln842">	fInputMethodUndoState.replace = false;</a>
<a name="ln843">}</a>
<a name="ln844"> </a>
<a name="ln845"> </a>
<a name="ln846">TTextView::~TTextView()</a>
<a name="ln847">{</a>
<a name="ln848">	ClearList();</a>
<a name="ln849">	delete fPanel;</a>
<a name="ln850"> </a>
<a name="ln851">	if (fYankBuffer)</a>
<a name="ln852">		free(fYankBuffer);</a>
<a name="ln853"> </a>
<a name="ln854">	delete_sem(fStopSem);</a>
<a name="ln855">}</a>
<a name="ln856"> </a>
<a name="ln857"> </a>
<a name="ln858">void</a>
<a name="ln859">TTextView::UpdateFont(const BFont* newFont)</a>
<a name="ln860">{</a>
<a name="ln861">	fFont = *newFont;</a>
<a name="ln862"> </a>
<a name="ln863">	// update the text run array safely with new font</a>
<a name="ln864">	text_run_array *runArray = RunArray(0, INT32_MAX);</a>
<a name="ln865">	for (int i = 0; i &lt; runArray-&gt;count; i++)</a>
<a name="ln866">		runArray-&gt;runs[i].font = *newFont;</a>
<a name="ln867"> </a>
<a name="ln868">	SetRunArray(0, INT32_MAX, runArray);</a>
<a name="ln869">	FreeRunArray(runArray);</a>
<a name="ln870">}</a>
<a name="ln871"> </a>
<a name="ln872"> </a>
<a name="ln873">void</a>
<a name="ln874">TTextView::AttachedToWindow()</a>
<a name="ln875">{</a>
<a name="ln876">	BTextView::AttachedToWindow();</a>
<a name="ln877">	fFont.SetSpacing(B_FIXED_SPACING);</a>
<a name="ln878">	SetFontAndColor(&amp;fFont);</a>
<a name="ln879"> </a>
<a name="ln880">	if (fMail != NULL) {</a>
<a name="ln881">		LoadMessage(fMail, false, NULL);</a>
<a name="ln882">		if (fIncoming)</a>
<a name="ln883">			MakeEditable(false);</a>
<a name="ln884">	}</a>
<a name="ln885">}</a>
<a name="ln886"> </a>
<a name="ln887"> </a>
<a name="ln888">void</a>
<a name="ln889">TTextView::KeyDown(const char *key, int32 count)</a>
<a name="ln890">{</a>
<a name="ln891">	char		raw;</a>
<a name="ln892">	int32		end;</a>
<a name="ln893">	int32 		start;</a>
<a name="ln894">	uint32		mods;</a>
<a name="ln895">	BMessage	*msg;</a>
<a name="ln896">	int32		textLen = TextLength();</a>
<a name="ln897"> </a>
<a name="ln898">	msg = Window()-&gt;CurrentMessage();</a>
<a name="ln899">	mods = msg-&gt;FindInt32(&quot;modifiers&quot;);</a>
<a name="ln900"> </a>
<a name="ln901">	switch (key[0]) {</a>
<a name="ln902">		case B_HOME:</a>
<a name="ln903">			if (IsSelectable()) {</a>
<a name="ln904">				if (IsEditable())</a>
<a name="ln905">					BTextView::KeyDown(key, count);</a>
<a name="ln906">				else {</a>
<a name="ln907">					// scroll to the beginning</a>
<a name="ln908">					Select(0, 0);</a>
<a name="ln909">					ScrollToSelection();</a>
<a name="ln910">				}</a>
<a name="ln911">			}</a>
<a name="ln912">			break;</a>
<a name="ln913"> </a>
<a name="ln914">		case B_END:</a>
<a name="ln915">			if (IsSelectable()) {</a>
<a name="ln916">				if (IsEditable())</a>
<a name="ln917">					BTextView::KeyDown(key, count);</a>
<a name="ln918">				else {</a>
<a name="ln919">					// scroll to the end</a>
<a name="ln920">					int32 length = TextLength();</a>
<a name="ln921">					Select(length, length);</a>
<a name="ln922">					ScrollToSelection();</a>
<a name="ln923">				}</a>
<a name="ln924">			}</a>
<a name="ln925">			break;</a>
<a name="ln926"> </a>
<a name="ln927">		case 0x02:						// ^b - back 1 char</a>
<a name="ln928">			if (IsSelectable()) {</a>
<a name="ln929">				GetSelection(&amp;start, &amp;end);</a>
<a name="ln930">				while (!IsInitialUTF8Byte(ByteAt(--start))) {</a>
<a name="ln931">					if (start &lt; 0) {</a>
<a name="ln932">						start = 0;</a>
<a name="ln933">						break;</a>
<a name="ln934">					}</a>
<a name="ln935">				}</a>
<a name="ln936">				if (start &gt;= 0) {</a>
<a name="ln937">					Select(start, start);</a>
<a name="ln938">					ScrollToSelection();</a>
<a name="ln939">				}</a>
<a name="ln940">			}</a>
<a name="ln941">			break;</a>
<a name="ln942"> </a>
<a name="ln943">		case B_DELETE:</a>
<a name="ln944">			if (IsSelectable()) {</a>
<a name="ln945">				if ((key[0] == B_DELETE) || (mods &amp; B_CONTROL_KEY)) {</a>
<a name="ln946">					// ^d</a>
<a name="ln947">					if (IsEditable()) {</a>
<a name="ln948">						GetSelection(&amp;start, &amp;end);</a>
<a name="ln949">						if (start != end)</a>
<a name="ln950">							Delete();</a>
<a name="ln951">						else {</a>
<a name="ln952">							for (end = start + 1; !IsInitialUTF8Byte(ByteAt(end)); end++) {</a>
<a name="ln953">								if (end &gt; textLen) {</a>
<a name="ln954">									end = textLen;</a>
<a name="ln955">									break;</a>
<a name="ln956">								}</a>
<a name="ln957">							}</a>
<a name="ln958">							Select(start, end);</a>
<a name="ln959">							Delete();</a>
<a name="ln960">						}</a>
<a name="ln961">					}</a>
<a name="ln962">				}</a>
<a name="ln963">				else</a>
<a name="ln964">					Select(textLen, textLen);</a>
<a name="ln965">				ScrollToSelection();</a>
<a name="ln966">			}</a>
<a name="ln967">			break;</a>
<a name="ln968"> </a>
<a name="ln969">		case 0x05:						// ^e - end of line</a>
<a name="ln970">			if (IsSelectable() &amp;&amp; (mods &amp; B_CONTROL_KEY)) {</a>
<a name="ln971">				if (CurrentLine() == CountLines() - 1)</a>
<a name="ln972">					Select(TextLength(), TextLength());</a>
<a name="ln973">				else {</a>
<a name="ln974">					GoToLine(CurrentLine() + 1);</a>
<a name="ln975">					GetSelection(&amp;start, &amp;end);</a>
<a name="ln976">					Select(start - 1, start - 1);</a>
<a name="ln977">				}</a>
<a name="ln978">			}</a>
<a name="ln979">			break;</a>
<a name="ln980"> </a>
<a name="ln981">		case 0x06:						// ^f - forward 1 char</a>
<a name="ln982">			if (IsSelectable()) {</a>
<a name="ln983">				GetSelection(&amp;start, &amp;end);</a>
<a name="ln984">				if (end &gt; start)</a>
<a name="ln985">					start = end;</a>
<a name="ln986">				else {</a>
<a name="ln987">					for (end = start + 1; !IsInitialUTF8Byte(ByteAt(end));</a>
<a name="ln988">						end++) {</a>
<a name="ln989">						if (end &gt; textLen) {</a>
<a name="ln990">							end = textLen;</a>
<a name="ln991">							break;</a>
<a name="ln992">						}</a>
<a name="ln993">					}</a>
<a name="ln994">					start = end;</a>
<a name="ln995">				}</a>
<a name="ln996">				Select(start, start);</a>
<a name="ln997">				ScrollToSelection();</a>
<a name="ln998">			}</a>
<a name="ln999">			break;</a>
<a name="ln1000"> </a>
<a name="ln1001">		case 0x0e:						// ^n - next line</a>
<a name="ln1002">			if (IsSelectable()) {</a>
<a name="ln1003">				raw = B_DOWN_ARROW;</a>
<a name="ln1004">				BTextView::KeyDown(&amp;raw, 1);</a>
<a name="ln1005">			}</a>
<a name="ln1006">			break;</a>
<a name="ln1007"> </a>
<a name="ln1008">		case 0x0f:						// ^o - open line</a>
<a name="ln1009">			if (IsEditable()) {</a>
<a name="ln1010">				GetSelection(&amp;start, &amp;end);</a>
<a name="ln1011">				Delete();</a>
<a name="ln1012"> </a>
<a name="ln1013">				char newLine = '\n';</a>
<a name="ln1014">				Insert(&amp;newLine, 1);</a>
<a name="ln1015">				Select(start, start);</a>
<a name="ln1016">				ScrollToSelection();</a>
<a name="ln1017">			}</a>
<a name="ln1018">			break;</a>
<a name="ln1019"> </a>
<a name="ln1020">		case B_PAGE_UP:</a>
<a name="ln1021">			if (mods &amp; B_CONTROL_KEY) {	// ^k kill text from cursor to e-o-line</a>
<a name="ln1022">				if (IsEditable()) {</a>
<a name="ln1023">					GetSelection(&amp;start, &amp;end);</a>
<a name="ln1024">					if ((start != fLastPosition) &amp;&amp; (fYankBuffer)) {</a>
<a name="ln1025">						free(fYankBuffer);</a>
<a name="ln1026">						fYankBuffer = NULL;</a>
<a name="ln1027">					}</a>
<a name="ln1028">					fLastPosition = start;</a>
<a name="ln1029">					if (CurrentLine() &lt; CountLines() - 1) {</a>
<a name="ln1030">						GoToLine(CurrentLine() + 1);</a>
<a name="ln1031">						GetSelection(&amp;end, &amp;end);</a>
<a name="ln1032">						end--;</a>
<a name="ln1033">					}</a>
<a name="ln1034">					else</a>
<a name="ln1035">						end = TextLength();</a>
<a name="ln1036">					if (end &lt; start)</a>
<a name="ln1037">						break;</a>
<a name="ln1038">					if (start == end)</a>
<a name="ln1039">						end++;</a>
<a name="ln1040">					Select(start, end);</a>
<a name="ln1041">					if (fYankBuffer) {</a>
<a name="ln1042">						fYankBuffer = (char *)realloc(fYankBuffer,</a>
<a name="ln1043">									 strlen(fYankBuffer) + (end - start) + 1);</a>
<a name="ln1044">						GetText(start, end - start,</a>
<a name="ln1045">							    &amp;fYankBuffer[strlen(fYankBuffer)]);</a>
<a name="ln1046">					} else {</a>
<a name="ln1047">						fYankBuffer = (char *)malloc(end - start + 1);</a>
<a name="ln1048">						GetText(start, end - start, fYankBuffer);</a>
<a name="ln1049">					}</a>
<a name="ln1050">					Delete();</a>
<a name="ln1051">					ScrollToSelection();</a>
<a name="ln1052">				}</a>
<a name="ln1053">				break;</a>
<a name="ln1054">			}</a>
<a name="ln1055"> </a>
<a name="ln1056">			BTextView::KeyDown(key, count);</a>
<a name="ln1057">			break;</a>
<a name="ln1058"> </a>
<a name="ln1059">		case 0x10:						// ^p goto previous line</a>
<a name="ln1060">			if (IsSelectable()) {</a>
<a name="ln1061">				raw = B_UP_ARROW;</a>
<a name="ln1062">				BTextView::KeyDown(&amp;raw, 1);</a>
<a name="ln1063">			}</a>
<a name="ln1064">			break;</a>
<a name="ln1065"> </a>
<a name="ln1066">		case 0x19:						// ^y yank text</a>
<a name="ln1067">			if (IsEditable() &amp;&amp; fYankBuffer) {</a>
<a name="ln1068">				Delete();</a>
<a name="ln1069">				Insert(fYankBuffer);</a>
<a name="ln1070">				ScrollToSelection();</a>
<a name="ln1071">			}</a>
<a name="ln1072">			break;</a>
<a name="ln1073"> </a>
<a name="ln1074">		default:</a>
<a name="ln1075">			BTextView::KeyDown(key, count);</a>
<a name="ln1076">	}</a>
<a name="ln1077">}</a>
<a name="ln1078"> </a>
<a name="ln1079"> </a>
<a name="ln1080">void</a>
<a name="ln1081">TTextView::MakeFocus(bool focus)</a>
<a name="ln1082">{</a>
<a name="ln1083">	if (!focus) {</a>
<a name="ln1084">		// ToDo: can someone please translate this? Otherwise I will remove it - axeld.</a>
<a name="ln1085">		// MakeFocus(false) は、IM も Inactive になり、そのまま確定される。</a>
<a name="ln1086">		// しかしこの場合、input_server が B_INPUT_METHOD_EVENT(B_INPUT_METHOD_STOPPED)</a>
<a name="ln1087">		// を送ってこないまま矛盾してしまうので、やむを得ずここでつじつまあわせ処理している。</a>
<a name="ln1088">		fInputMethodUndoState.active = false;</a>
<a name="ln1089">		// fInputMethodUndoBufferに溜まっている最後のデータがK_INSERTEDなら（確定）正規のバッファへ追加</a>
<a name="ln1090">		if (fInputMethodUndoBuffer.CountItems() &gt; 0) {</a>
<a name="ln1091">			KUndoItem *item = fInputMethodUndoBuffer.ItemAt(fInputMethodUndoBuffer.CountItems() - 1);</a>
<a name="ln1092">			if (item-&gt;History == K_INSERTED) {</a>
<a name="ln1093">				fUndoBuffer.MakeNewUndoItem();</a>
<a name="ln1094">				fUndoBuffer.AddUndo(item-&gt;RedoText, item-&gt;Length, item-&gt;Offset, item-&gt;History, item-&gt;CursorPos);</a>
<a name="ln1095">				fUndoBuffer.MakeNewUndoItem();</a>
<a name="ln1096">			}</a>
<a name="ln1097">			fInputMethodUndoBuffer.MakeEmpty();</a>
<a name="ln1098">		}</a>
<a name="ln1099">	}</a>
<a name="ln1100">	BTextView::MakeFocus(focus);</a>
<a name="ln1101"> </a>
<a name="ln1102">	fParent-&gt;Focus(focus);</a>
<a name="ln1103">}</a>
<a name="ln1104"> </a>
<a name="ln1105"> </a>
<a name="ln1106">void</a>
<a name="ln1107">TTextView::MessageReceived(BMessage *msg)</a>
<a name="ln1108">{</a>
<a name="ln1109">	switch (msg-&gt;what) {</a>
<a name="ln1110">		case B_SIMPLE_DATA:</a>
<a name="ln1111">		{</a>
<a name="ln1112">			if (fIncoming)</a>
<a name="ln1113">				break;</a>
<a name="ln1114"> </a>
<a name="ln1115">			BMessage message(REFS_RECEIVED);</a>
<a name="ln1116">			bool isEnclosure = false;</a>
<a name="ln1117">			bool inserted = false;</a>
<a name="ln1118"> </a>
<a name="ln1119">			off_t len = 0;</a>
<a name="ln1120">			int32 end;</a>
<a name="ln1121">			int32 start;</a>
<a name="ln1122"> </a>
<a name="ln1123">			int32 index = 0;</a>
<a name="ln1124">			entry_ref ref;</a>
<a name="ln1125">			while (msg-&gt;FindRef(&quot;refs&quot;, index++, &amp;ref) == B_OK) {</a>
<a name="ln1126">				BFile file(&amp;ref, B_READ_ONLY);</a>
<a name="ln1127">				if (file.InitCheck() == B_OK) {</a>
<a name="ln1128">					BNodeInfo node(&amp;file);</a>
<a name="ln1129">					char type[B_FILE_NAME_LENGTH];</a>
<a name="ln1130">					node.GetType(type);</a>
<a name="ln1131"> </a>
<a name="ln1132">					off_t size = 0;</a>
<a name="ln1133">					file.GetSize(&amp;size);</a>
<a name="ln1134"> </a>
<a name="ln1135">					if (!strncasecmp(type, &quot;text/&quot;, 5) &amp;&amp; size &gt; 0) {</a>
<a name="ln1136">						len += size;</a>
<a name="ln1137">						char *text = (char *)malloc(size);</a>
<a name="ln1138">						if (text == NULL) {</a>
<a name="ln1139">							puts(&quot;no memory!&quot;);</a>
<a name="ln1140">							return;</a>
<a name="ln1141">						}</a>
<a name="ln1142">						if (file.Read(text, size) &lt; B_OK) {</a>
<a name="ln1143">							puts(&quot;could not read from file&quot;);</a>
<a name="ln1144">							free(text);</a>
<a name="ln1145">							continue;</a>
<a name="ln1146">						}</a>
<a name="ln1147">						if (!inserted) {</a>
<a name="ln1148">							GetSelection(&amp;start, &amp;end);</a>
<a name="ln1149">							Delete();</a>
<a name="ln1150">							inserted = true;</a>
<a name="ln1151">						}</a>
<a name="ln1152"> </a>
<a name="ln1153">						int32 offset = 0;</a>
<a name="ln1154">						for (int32 loop = 0; loop &lt; size; loop++) {</a>
<a name="ln1155">							if (text[loop] == '\n') {</a>
<a name="ln1156">								Insert(&amp;text[offset], loop - offset + 1);</a>
<a name="ln1157">								offset = loop + 1;</a>
<a name="ln1158">							} else if (text[loop] == '\r') {</a>
<a name="ln1159">								text[loop] = '\n';</a>
<a name="ln1160">								Insert(&amp;text[offset], loop - offset + 1);</a>
<a name="ln1161">								if ((loop + 1 &lt; size)</a>
<a name="ln1162">										&amp;&amp; (text[loop + 1] == '\n'))</a>
<a name="ln1163">									loop++;</a>
<a name="ln1164">								offset = loop + 1;</a>
<a name="ln1165">							}</a>
<a name="ln1166">						}</a>
<a name="ln1167">						free(text);</a>
<a name="ln1168">					} else {</a>
<a name="ln1169">						isEnclosure = true;</a>
<a name="ln1170">						message.AddRef(&quot;refs&quot;, &amp;ref);</a>
<a name="ln1171">					}</a>
<a name="ln1172">				}</a>
<a name="ln1173">			}</a>
<a name="ln1174"> </a>
<a name="ln1175">			if (index == 1) {</a>
<a name="ln1176">				// message doesn't contain any refs - maybe the parent class likes it</a>
<a name="ln1177">				BTextView::MessageReceived(msg);</a>
<a name="ln1178">				break;</a>
<a name="ln1179">			}</a>
<a name="ln1180"> </a>
<a name="ln1181">			if (inserted)</a>
<a name="ln1182">				Select(start, start + len);</a>
<a name="ln1183">			if (isEnclosure)</a>
<a name="ln1184">				Window()-&gt;PostMessage(&amp;message, Window());</a>
<a name="ln1185">			break;</a>
<a name="ln1186">		}</a>
<a name="ln1187"> </a>
<a name="ln1188">		case M_HEADER:</a>
<a name="ln1189">			msg-&gt;FindBool(&quot;header&quot;, &amp;fHeader);</a>
<a name="ln1190">			SetText(NULL);</a>
<a name="ln1191">			LoadMessage(fMail, false, NULL);</a>
<a name="ln1192">			break;</a>
<a name="ln1193"> </a>
<a name="ln1194">		case M_RAW:</a>
<a name="ln1195">			StopLoad();</a>
<a name="ln1196"> </a>
<a name="ln1197">			msg-&gt;FindBool(&quot;raw&quot;, &amp;fRaw);</a>
<a name="ln1198">			SetText(NULL);</a>
<a name="ln1199">			LoadMessage(fMail, false, NULL);</a>
<a name="ln1200">			break;</a>
<a name="ln1201"> </a>
<a name="ln1202">		case M_SELECT:</a>
<a name="ln1203">			if (IsSelectable())</a>
<a name="ln1204">				Select(0, TextLength());</a>
<a name="ln1205">			break;</a>
<a name="ln1206"> </a>
<a name="ln1207">		case M_SAVE:</a>
<a name="ln1208">			Save(msg);</a>
<a name="ln1209">			break;</a>
<a name="ln1210"> </a>
<a name="ln1211">		case B_NODE_MONITOR:</a>
<a name="ln1212">		{</a>
<a name="ln1213">			int32 opcode;</a>
<a name="ln1214">			if (msg-&gt;FindInt32(&quot;opcode&quot;, &amp;opcode) == B_NO_ERROR) {</a>
<a name="ln1215">				dev_t device;</a>
<a name="ln1216">				if (msg-&gt;FindInt32(&quot;device&quot;, &amp;device) &lt; B_OK)</a>
<a name="ln1217">					break;</a>
<a name="ln1218">				ino_t inode;</a>
<a name="ln1219">				if (msg-&gt;FindInt64(&quot;node&quot;, &amp;inode) &lt; B_OK)</a>
<a name="ln1220">					break;</a>
<a name="ln1221"> </a>
<a name="ln1222">				hyper_text *enclosure;</a>
<a name="ln1223">				for (int32 index = 0;</a>
<a name="ln1224">						(enclosure = (hyper_text *)fEnclosures-&gt;ItemAt(index++)) != NULL;) {</a>
<a name="ln1225">					if (device == enclosure-&gt;node.device</a>
<a name="ln1226">						&amp;&amp; inode == enclosure-&gt;node.node) {</a>
<a name="ln1227">						if (opcode == B_ENTRY_REMOVED) {</a>
<a name="ln1228">							enclosure-&gt;saved = false;</a>
<a name="ln1229">							enclosure-&gt;have_ref = false;</a>
<a name="ln1230">						} else if (opcode == B_ENTRY_MOVED) {</a>
<a name="ln1231">							enclosure-&gt;ref.device = device;</a>
<a name="ln1232">							msg-&gt;FindInt64(&quot;to directory&quot;, &amp;enclosure-&gt;ref.directory);</a>
<a name="ln1233"> </a>
<a name="ln1234">							const char *name;</a>
<a name="ln1235">							msg-&gt;FindString(&quot;name&quot;, &amp;name);</a>
<a name="ln1236">							enclosure-&gt;ref.set_name(name);</a>
<a name="ln1237">						}</a>
<a name="ln1238">						break;</a>
<a name="ln1239">					}</a>
<a name="ln1240">				}</a>
<a name="ln1241">			}</a>
<a name="ln1242">			break;</a>
<a name="ln1243">		}</a>
<a name="ln1244"> </a>
<a name="ln1245">		//</a>
<a name="ln1246">		// Tracker has responded to a BMessage that was dragged out of</a>
<a name="ln1247">		// this email message.  It has created a file for us, we just have to</a>
<a name="ln1248">		// put the stuff in it.</a>
<a name="ln1249">		//</a>
<a name="ln1250">		case B_COPY_TARGET:</a>
<a name="ln1251">		{</a>
<a name="ln1252">			BMessage data;</a>
<a name="ln1253">			if (msg-&gt;FindMessage(&quot;be:originator-data&quot;, &amp;data) == B_OK) {</a>
<a name="ln1254">				entry_ref directory;</a>
<a name="ln1255">				const char *name;</a>
<a name="ln1256">				hyper_text *enclosure;</a>
<a name="ln1257"> </a>
<a name="ln1258">				if (data.FindPointer(&quot;enclosure&quot;, (void **)&amp;enclosure) == B_OK</a>
<a name="ln1259">					&amp;&amp; msg-&gt;FindString(&quot;name&quot;, &amp;name) == B_OK</a>
<a name="ln1260">					&amp;&amp; msg-&gt;FindRef(&quot;directory&quot;, &amp;directory) == B_OK) {</a>
<a name="ln1261">					switch (enclosure-&gt;type) {</a>
<a name="ln1262">						case TYPE_ENCLOSURE:</a>
<a name="ln1263">						case TYPE_BE_ENCLOSURE:</a>
<a name="ln1264">						{</a>
<a name="ln1265">							//</a>
<a name="ln1266">							//	Enclosure.  Decode the data and write it out.</a>
<a name="ln1267">							//</a>
<a name="ln1268">							BMessage saveMsg(M_SAVE);</a>
<a name="ln1269">							saveMsg.AddString(&quot;name&quot;, name);</a>
<a name="ln1270">							saveMsg.AddRef(&quot;directory&quot;, &amp;directory);</a>
<a name="ln1271">							saveMsg.AddPointer(&quot;enclosure&quot;, enclosure);</a>
<a name="ln1272">							Save(&amp;saveMsg, false);</a>
<a name="ln1273">							break;</a>
<a name="ln1274">						}</a>
<a name="ln1275"> </a>
<a name="ln1276">						case TYPE_URL:</a>
<a name="ln1277">						{</a>
<a name="ln1278">							const char *replyType;</a>
<a name="ln1279">							if (msg-&gt;FindString(&quot;be:filetypes&quot;, &amp;replyType) != B_OK)</a>
<a name="ln1280">								// drag recipient didn't ask for any specific type,</a>
<a name="ln1281">								// create a bookmark file as default</a>
<a name="ln1282">								replyType = &quot;application/x-vnd.Be-bookmark&quot;;</a>
<a name="ln1283"> </a>
<a name="ln1284">							BDirectory dir(&amp;directory);</a>
<a name="ln1285">							BFile file(&amp;dir, name, B_READ_WRITE);</a>
<a name="ln1286">							if (file.InitCheck() == B_OK) {</a>
<a name="ln1287">								if (strcmp(replyType, &quot;application/x-vnd.Be-bookmark&quot;) == 0) {</a>
<a name="ln1288">									// we got a request to create a bookmark, stuff</a>
<a name="ln1289">									// it with the url attribute</a>
<a name="ln1290">									file.WriteAttr(&quot;META:url&quot;, B_STRING_TYPE, 0,</a>
<a name="ln1291">													enclosure-&gt;name, strlen(enclosure-&gt;name) + 1);</a>
<a name="ln1292">								} else if (strcasecmp(replyType, &quot;text/plain&quot;) == 0) {</a>
<a name="ln1293">									// create a plain text file, stuff it with</a>
<a name="ln1294">									// the url as text</a>
<a name="ln1295">									file.Write(enclosure-&gt;name, strlen(enclosure-&gt;name));</a>
<a name="ln1296">								}</a>
<a name="ln1297"> </a>
<a name="ln1298">								BNodeInfo fileInfo(&amp;file);</a>
<a name="ln1299">								fileInfo.SetType(replyType);</a>
<a name="ln1300">							}</a>
<a name="ln1301">							break;</a>
<a name="ln1302">						}</a>
<a name="ln1303"> </a>
<a name="ln1304">						case TYPE_MAILTO:</a>
<a name="ln1305">						{</a>
<a name="ln1306">							//</a>
<a name="ln1307">							//	Add some attributes to the already created</a>
<a name="ln1308">							//	person file.  Strip out the 'mailto:' if</a>
<a name="ln1309">							//  possible.</a>
<a name="ln1310">							//</a>
<a name="ln1311">							char *addrStart = enclosure-&gt;name;</a>
<a name="ln1312">							while (true) {</a>
<a name="ln1313">								if (*addrStart == ':') {</a>
<a name="ln1314">									addrStart++;</a>
<a name="ln1315">									break;</a>
<a name="ln1316">								}</a>
<a name="ln1317"> </a>
<a name="ln1318">								if (*addrStart == '\0') {</a>
<a name="ln1319">									addrStart = enclosure-&gt;name;</a>
<a name="ln1320">									break;</a>
<a name="ln1321">								}</a>
<a name="ln1322"> </a>
<a name="ln1323">								addrStart++;</a>
<a name="ln1324">							}</a>
<a name="ln1325"> </a>
<a name="ln1326">							const char *replyType;</a>
<a name="ln1327">							if (msg-&gt;FindString(&quot;be:filetypes&quot;, &amp;replyType) != B_OK)</a>
<a name="ln1328">								// drag recipient didn't ask for any specific type,</a>
<a name="ln1329">								// create a bookmark file as default</a>
<a name="ln1330">								replyType = &quot;application/x-vnd.Be-bookmark&quot;;</a>
<a name="ln1331"> </a>
<a name="ln1332">							BDirectory dir(&amp;directory);</a>
<a name="ln1333">							BFile file(&amp;dir, name, B_READ_WRITE);</a>
<a name="ln1334">							if (file.InitCheck() == B_OK) {</a>
<a name="ln1335">								if (!strcmp(replyType, &quot;application/x-person&quot;)) {</a>
<a name="ln1336">									// we got a request to create a bookmark, stuff</a>
<a name="ln1337">									// it with the address attribute</a>
<a name="ln1338">									file.WriteAttr(&quot;META:email&quot;, B_STRING_TYPE, 0,</a>
<a name="ln1339">									  addrStart, strlen(enclosure-&gt;name) + 1);</a>
<a name="ln1340">								} else if (!strcasecmp(replyType, &quot;text/plain&quot;)) {</a>
<a name="ln1341">									// create a plain text file, stuff it with the</a>
<a name="ln1342">									// email as text</a>
<a name="ln1343">									file.Write(addrStart, strlen(addrStart));</a>
<a name="ln1344">								}</a>
<a name="ln1345"> </a>
<a name="ln1346">								BNodeInfo fileInfo(&amp;file);</a>
<a name="ln1347">								fileInfo.SetType(replyType);</a>
<a name="ln1348">							}</a>
<a name="ln1349">							break;</a>
<a name="ln1350">						}</a>
<a name="ln1351">					}</a>
<a name="ln1352">				} else {</a>
<a name="ln1353">					//</a>
<a name="ln1354">					// Assume this is handled by BTextView...</a>
<a name="ln1355">					// (Probably drag clipping.)</a>
<a name="ln1356">					//</a>
<a name="ln1357">					BTextView::MessageReceived(msg);</a>
<a name="ln1358">				}</a>
<a name="ln1359">			}</a>
<a name="ln1360">			break;</a>
<a name="ln1361">		}</a>
<a name="ln1362"> </a>
<a name="ln1363">		case B_INPUT_METHOD_EVENT:</a>
<a name="ln1364">		{</a>
<a name="ln1365">			int32 im_op;</a>
<a name="ln1366">			if (msg-&gt;FindInt32(&quot;be:opcode&quot;, &amp;im_op) == B_OK){</a>
<a name="ln1367">				switch (im_op) {</a>
<a name="ln1368">					case B_INPUT_METHOD_STARTED:</a>
<a name="ln1369">						fInputMethodUndoState.replace = true;</a>
<a name="ln1370">						fInputMethodUndoState.active = true;</a>
<a name="ln1371">						break;</a>
<a name="ln1372">					case B_INPUT_METHOD_STOPPED:</a>
<a name="ln1373">						fInputMethodUndoState.active = false;</a>
<a name="ln1374">						if (fInputMethodUndoBuffer.CountItems() &gt; 0) {</a>
<a name="ln1375">							KUndoItem *undo = fInputMethodUndoBuffer.ItemAt(</a>
<a name="ln1376">								fInputMethodUndoBuffer.CountItems() - 1);</a>
<a name="ln1377">							if (undo-&gt;History == K_INSERTED){</a>
<a name="ln1378">								fUndoBuffer.MakeNewUndoItem();</a>
<a name="ln1379">								fUndoBuffer.AddUndo(undo-&gt;RedoText, undo-&gt;Length,</a>
<a name="ln1380">									undo-&gt;Offset, undo-&gt;History, undo-&gt;CursorPos);</a>
<a name="ln1381">								fUndoBuffer.MakeNewUndoItem();</a>
<a name="ln1382">							}</a>
<a name="ln1383">							fInputMethodUndoBuffer.MakeEmpty();</a>
<a name="ln1384">						}</a>
<a name="ln1385">						break;</a>
<a name="ln1386">					case B_INPUT_METHOD_CHANGED:</a>
<a name="ln1387">						fInputMethodUndoState.active = true;</a>
<a name="ln1388">						break;</a>
<a name="ln1389">					case B_INPUT_METHOD_LOCATION_REQUEST:</a>
<a name="ln1390">						fInputMethodUndoState.active = true;</a>
<a name="ln1391">						break;</a>
<a name="ln1392">				}</a>
<a name="ln1393">			}</a>
<a name="ln1394">			BTextView::MessageReceived(msg);</a>
<a name="ln1395">			break;</a>
<a name="ln1396">		}</a>
<a name="ln1397"> </a>
<a name="ln1398">		case M_REDO:</a>
<a name="ln1399">			Redo();</a>
<a name="ln1400">			break;</a>
<a name="ln1401"> </a>
<a name="ln1402">		default:</a>
<a name="ln1403">			BTextView::MessageReceived(msg);</a>
<a name="ln1404">	}</a>
<a name="ln1405">}</a>
<a name="ln1406"> </a>
<a name="ln1407"> </a>
<a name="ln1408">void</a>
<a name="ln1409">TTextView::MouseDown(BPoint where)</a>
<a name="ln1410">{</a>
<a name="ln1411">	if (IsEditable()) {</a>
<a name="ln1412">		BPoint point;</a>
<a name="ln1413">		uint32 buttons;</a>
<a name="ln1414">		GetMouse(&amp;point, &amp;buttons);</a>
<a name="ln1415">		if (gDictCount &amp;&amp; (buttons == B_SECONDARY_MOUSE_BUTTON)) {</a>
<a name="ln1416">			int32 offset, start, end, length;</a>
<a name="ln1417">			const char *text = Text();</a>
<a name="ln1418">			offset = OffsetAt(where);</a>
<a name="ln1419">			if (isalpha(text[offset])) {</a>
<a name="ln1420">				length = TextLength();</a>
<a name="ln1421"> </a>
<a name="ln1422">				//Find start and end of word</a>
<a name="ln1423">				//FindSpellBoundry(length, offset, &amp;start, &amp;end);</a>
<a name="ln1424"> </a>
<a name="ln1425">				char c;</a>
<a name="ln1426">				bool isAlpha, isApost, isCap;</a>
<a name="ln1427">				int32 first;</a>
<a name="ln1428"> </a>
<a name="ln1429">				for (first = offset;</a>
<a name="ln1430">					(first &gt;= 0) &amp;&amp; (((c = text[first]) == '\'') || isalpha(c));</a>
<a name="ln1431">					first--) {}</a>
<a name="ln1432">				isCap = isupper(text[++first]);</a>
<a name="ln1433"> </a>
<a name="ln1434">				for (start = offset, c = text[start], isAlpha = isalpha(c), isApost = (c=='\'');</a>
<a name="ln1435">					(start &gt;= 0) &amp;&amp; (isAlpha || (isApost</a>
<a name="ln1436">					&amp;&amp; (((c = text[start+1]) != 's') || !isCap) &amp;&amp; isalpha(c)</a>
<a name="ln1437">					&amp;&amp; isalpha(text[start-1])));</a>
<a name="ln1438">					start--, c = text[start], isAlpha = isalpha(c), isApost = (c == '\'')) {}</a>
<a name="ln1439">				start++;</a>
<a name="ln1440"> </a>
<a name="ln1441">				for (end = offset, c = text[end], isAlpha = isalpha(c), isApost = (c == '\'');</a>
<a name="ln1442">					(end &lt; length) &amp;&amp; (isAlpha || (isApost</a>
<a name="ln1443">					&amp;&amp; (((c = text[end + 1]) != 's') || !isCap) &amp;&amp; isalpha(c)));</a>
<a name="ln1444">					end++, c = text[end], isAlpha = isalpha(c), isApost = (c == '\'')) {}</a>
<a name="ln1445"> </a>
<a name="ln1446">				length = end - start;</a>
<a name="ln1447">				BString srcWord;</a>
<a name="ln1448">				srcWord.SetTo(text + start, length);</a>
<a name="ln1449"> </a>
<a name="ln1450">				bool		foundWord = false;</a>
<a name="ln1451">				BList 		matches;</a>
<a name="ln1452">				BString 	*string;</a>
<a name="ln1453"> </a>
<a name="ln1454">				BMenuItem *menuItem;</a>
<a name="ln1455">				BPopUpMenu menu(&quot;Words&quot;, false, false);</a>
<a name="ln1456"> </a>
<a name="ln1457">				for (int32 i = 0; i &lt; gDictCount; i++)</a>
<a name="ln1458">					gWords[i]-&gt;FindBestMatches(&amp;matches,</a>
<a name="ln1459">						srcWord.String());</a>
<a name="ln1460"> </a>
<a name="ln1461">				if (matches.CountItems()) {</a>
<a name="ln1462">					sort_word_list(&amp;matches, srcWord.String());</a>
<a name="ln1463">					for (int32 i = 0; (string = (BString *)matches.ItemAt(i)) != NULL; i++) {</a>
<a name="ln1464">						menu.AddItem((menuItem = new BMenuItem(string-&gt;String(), NULL)));</a>
<a name="ln1465">						if (!strcasecmp(string-&gt;String(), srcWord.String())) {</a>
<a name="ln1466">							menuItem-&gt;SetEnabled(false);</a>
<a name="ln1467">							foundWord = true;</a>
<a name="ln1468">						}</a>
<a name="ln1469">						delete string;</a>
<a name="ln1470">					}</a>
<a name="ln1471">				} else {</a>
<a name="ln1472">					menuItem = new BMenuItem(B_TRANSLATE(&quot;No matches&quot;), NULL);</a>
<a name="ln1473">					menuItem-&gt;SetEnabled(false);</a>
<a name="ln1474">					menu.AddItem(menuItem);</a>
<a name="ln1475">				}</a>
<a name="ln1476"> </a>
<a name="ln1477">				BMenuItem *addItem = NULL;</a>
<a name="ln1478">				if (!foundWord &amp;&amp; gUserDict &gt;= 0) {</a>
<a name="ln1479">					menu.AddSeparatorItem();</a>
<a name="ln1480">					addItem = new BMenuItem(B_TRANSLATE(&quot;Add&quot;), NULL);</a>
<a name="ln1481">					menu.AddItem(addItem);</a>
<a name="ln1482">				}</a>
<a name="ln1483"> </a>
<a name="ln1484">				point = ConvertToScreen(where);</a>
<a name="ln1485">				if ((menuItem = menu.Go(point, false, false)) != NULL) {</a>
<a name="ln1486">					if (menuItem == addItem) {</a>
<a name="ln1487">						BString newItem(srcWord.String());</a>
<a name="ln1488">						newItem &lt;&lt; &quot;\n&quot;;</a>
<a name="ln1489">						gWords[gUserDict]-&gt;InitIndex();</a>
<a name="ln1490">						gExactWords[gUserDict]-&gt;InitIndex();</a>
<a name="ln1491">						gUserDictFile-&gt;Write(newItem.String(), newItem.Length());</a>
<a name="ln1492">						gWords[gUserDict]-&gt;BuildIndex();</a>
<a name="ln1493">						gExactWords[gUserDict]-&gt;BuildIndex();</a>
<a name="ln1494"> </a>
<a name="ln1495">						if (fSpellCheck)</a>
<a name="ln1496">							CheckSpelling(0, TextLength());</a>
<a name="ln1497">					} else {</a>
<a name="ln1498">						int32 len = strlen(menuItem-&gt;Label());</a>
<a name="ln1499">						Select(start, start);</a>
<a name="ln1500">						Delete(start, end);</a>
<a name="ln1501">						Insert(start, menuItem-&gt;Label(), len);</a>
<a name="ln1502">						Select(start+len, start+len);</a>
<a name="ln1503">					}</a>
<a name="ln1504">				}</a>
<a name="ln1505">			}</a>
<a name="ln1506">			return;</a>
<a name="ln1507">		} else if (fSpellCheck &amp;&amp; IsEditable()) {</a>
<a name="ln1508">			int32 start, end;</a>
<a name="ln1509"> </a>
<a name="ln1510">			GetSelection(&amp;start, &amp;end);</a>
<a name="ln1511">			FindSpellBoundry(1, start, &amp;start, &amp;end);</a>
<a name="ln1512">			CheckSpelling(start, end);</a>
<a name="ln1513">		}</a>
<a name="ln1514">	} else {</a>
<a name="ln1515">		// is not editable, look for enclosures/links</a>
<a name="ln1516"> </a>
<a name="ln1517">		int32 clickOffset = OffsetAt(where);</a>
<a name="ln1518">		int32 items = fEnclosures-&gt;CountItems();</a>
<a name="ln1519">		for (int32 loop = 0; loop &lt; items; loop++) {</a>
<a name="ln1520">			hyper_text *enclosure = (hyper_text*) fEnclosures-&gt;ItemAt(loop);</a>
<a name="ln1521">			if (clickOffset &lt; enclosure-&gt;text_start || clickOffset &gt;= enclosure-&gt;text_end)</a>
<a name="ln1522">				continue;</a>
<a name="ln1523"> </a>
<a name="ln1524">			//</a>
<a name="ln1525">			// The user is clicking on this attachment</a>
<a name="ln1526">			//</a>
<a name="ln1527"> </a>
<a name="ln1528">			int32 start;</a>
<a name="ln1529">			int32 finish;</a>
<a name="ln1530">			Select(enclosure-&gt;text_start, enclosure-&gt;text_end);</a>
<a name="ln1531">			GetSelection(&amp;start, &amp;finish);</a>
<a name="ln1532">			Window()-&gt;UpdateIfNeeded();</a>
<a name="ln1533"> </a>
<a name="ln1534">			bool drag = false;</a>
<a name="ln1535">			bool held = false;</a>
<a name="ln1536">			uint32 buttons = 0;</a>
<a name="ln1537">			if (Window()-&gt;CurrentMessage()) {</a>
<a name="ln1538">				Window()-&gt;CurrentMessage()-&gt;FindInt32(&quot;buttons&quot;,</a>
<a name="ln1539">				  (int32 *) &amp;buttons);</a>
<a name="ln1540">			}</a>
<a name="ln1541"> </a>
<a name="ln1542">			//</a>
<a name="ln1543">			// If this is the primary button, wait to see if the user is going</a>
<a name="ln1544">			// to single click, hold, or drag.</a>
<a name="ln1545">			//</a>
<a name="ln1546">			if (buttons != B_SECONDARY_MOUSE_BUTTON) {</a>
<a name="ln1547">				BPoint point = where;</a>
<a name="ln1548">				bigtime_t popupDelay;</a>
<a name="ln1549">				get_click_speed(&amp;popupDelay);</a>
<a name="ln1550">				popupDelay *= 2;</a>
<a name="ln1551">				popupDelay += system_time();</a>
<a name="ln1552">				while (buttons &amp;&amp; abs((int)(point.x - where.x)) &lt; 4</a>
<a name="ln1553">					&amp;&amp; abs((int)(point.y - where.y)) &lt; 4</a>
<a name="ln1554">					&amp;&amp; system_time() &lt; popupDelay) {</a>
<a name="ln1555">					snooze(10000);</a>
<a name="ln1556">					GetMouse(&amp;point, &amp;buttons);</a>
<a name="ln1557">				}</a>
<a name="ln1558"> </a>
<a name="ln1559">				if (system_time() &lt; popupDelay) {</a>
<a name="ln1560">					//</a>
<a name="ln1561">					// The user either dragged this or released the button.</a>
<a name="ln1562">					// check if it was dragged.</a>
<a name="ln1563">					//</a>
<a name="ln1564">					if (!(abs((int)(point.x - where.x)) &lt; 4</a>
<a name="ln1565">						&amp;&amp; abs((int)(point.y - where.y)) &lt; 4) &amp;&amp; buttons)</a>
<a name="ln1566">						drag = true;</a>
<a name="ln1567">				} else  {</a>
<a name="ln1568">					//</a>
<a name="ln1569">					//	The user held the button down.</a>
<a name="ln1570">					//</a>
<a name="ln1571">					held = true;</a>
<a name="ln1572">				}</a>
<a name="ln1573">			}</a>
<a name="ln1574"> </a>
<a name="ln1575">			//</a>
<a name="ln1576">			//	If the user has right clicked on this menu,</a>
<a name="ln1577">			// 	or held the button down on it for a while,</a>
<a name="ln1578">			//	pop up a context menu.</a>
<a name="ln1579">			//</a>
<a name="ln1580">			if (buttons == B_SECONDARY_MOUSE_BUTTON || held) {</a>
<a name="ln1581">				//</a>
<a name="ln1582">				// Right mouse click... Display a menu</a>
<a name="ln1583">				//</a>
<a name="ln1584">				BPoint point = where;</a>
<a name="ln1585">				ConvertToScreen(&amp;point);</a>
<a name="ln1586"> </a>
<a name="ln1587">				BMenuItem *item;</a>
<a name="ln1588">				if ((enclosure-&gt;type != TYPE_ENCLOSURE)</a>
<a name="ln1589">					&amp;&amp; (enclosure-&gt;type != TYPE_BE_ENCLOSURE))</a>
<a name="ln1590">					item = fLinkMenu-&gt;Go(point, true);</a>
<a name="ln1591">				else</a>
<a name="ln1592">					item = fEnclosureMenu-&gt;Go(point, true);</a>
<a name="ln1593"> </a>
<a name="ln1594">				BMessage *msg;</a>
<a name="ln1595">				if (item &amp;&amp; (msg = item-&gt;Message()) != NULL) {</a>
<a name="ln1596">					if (msg-&gt;what == M_SAVE) {</a>
<a name="ln1597">						if (fPanel)</a>
<a name="ln1598">							fPanel-&gt;SetEnclosure(enclosure);</a>
<a name="ln1599">						else {</a>
<a name="ln1600">							fPanel = new TSavePanel(enclosure, this);</a>
<a name="ln1601">							fPanel-&gt;Window()-&gt;Show();</a>
<a name="ln1602">						}</a>
<a name="ln1603">					} else if (msg-&gt;what == M_COPY) {</a>
<a name="ln1604">						// copy link location to clipboard</a>
<a name="ln1605"> </a>
<a name="ln1606">						if (be_clipboard-&gt;Lock()) {</a>
<a name="ln1607">							be_clipboard-&gt;Clear();</a>
<a name="ln1608"> </a>
<a name="ln1609">							BMessage *clip;</a>
<a name="ln1610">							if ((clip = be_clipboard-&gt;Data()) != NULL) {</a>
<a name="ln1611">								clip-&gt;AddData(&quot;text/plain&quot;, B_MIME_TYPE,</a>
<a name="ln1612">									enclosure-&gt;name, strlen(enclosure-&gt;name));</a>
<a name="ln1613">								be_clipboard-&gt;Commit();</a>
<a name="ln1614">							}</a>
<a name="ln1615">							be_clipboard-&gt;Unlock();</a>
<a name="ln1616">						}</a>
<a name="ln1617">					} else</a>
<a name="ln1618">						Open(enclosure);</a>
<a name="ln1619">				}</a>
<a name="ln1620">			} else {</a>
<a name="ln1621">				//</a>
<a name="ln1622">				// Left button.  If the user single clicks, open this link.</a>
<a name="ln1623">				// Otherwise, initiate a drag.</a>
<a name="ln1624">				//</a>
<a name="ln1625">				if (drag) {</a>
<a name="ln1626">					BMessage dragMessage(B_SIMPLE_DATA);</a>
<a name="ln1627">					dragMessage.AddInt32(&quot;be:actions&quot;, B_COPY_TARGET);</a>
<a name="ln1628">					dragMessage.AddString(&quot;be:types&quot;, B_FILE_MIME_TYPE);</a>
<a name="ln1629">					switch (enclosure-&gt;type) {</a>
<a name="ln1630">						case TYPE_BE_ENCLOSURE:</a>
<a name="ln1631">						case TYPE_ENCLOSURE:</a>
<a name="ln1632">							//</a>
<a name="ln1633">							// Attachment.  The type is specified in the message.</a>
<a name="ln1634">							//</a>
<a name="ln1635">							dragMessage.AddString(&quot;be:types&quot;, B_FILE_MIME_TYPE);</a>
<a name="ln1636">							dragMessage.AddString(&quot;be:filetypes&quot;,</a>
<a name="ln1637">								enclosure-&gt;content_type ? enclosure-&gt;content_type : &quot;&quot;);</a>
<a name="ln1638">							dragMessage.AddString(&quot;be:clip_name&quot;, enclosure-&gt;name);</a>
<a name="ln1639">							break;</a>
<a name="ln1640"> </a>
<a name="ln1641">						case TYPE_URL:</a>
<a name="ln1642">							//</a>
<a name="ln1643">							// URL.  The user can drag it into the tracker to</a>
<a name="ln1644">							// create a bookmark file.</a>
<a name="ln1645">							//</a>
<a name="ln1646">							dragMessage.AddString(&quot;be:types&quot;, B_FILE_MIME_TYPE);</a>
<a name="ln1647">							dragMessage.AddString(&quot;be:filetypes&quot;,</a>
<a name="ln1648">							  &quot;application/x-vnd.Be-bookmark&quot;);</a>
<a name="ln1649">							dragMessage.AddString(&quot;be:filetypes&quot;, &quot;text/plain&quot;);</a>
<a name="ln1650">							dragMessage.AddString(&quot;be:clip_name&quot;, &quot;Bookmark&quot;);</a>
<a name="ln1651"> </a>
<a name="ln1652">							dragMessage.AddString(&quot;be:url&quot;, enclosure-&gt;name);</a>
<a name="ln1653">							break;</a>
<a name="ln1654"> </a>
<a name="ln1655">						case TYPE_MAILTO:</a>
<a name="ln1656">							//</a>
<a name="ln1657">							// Mailto address.  The user can drag it into the</a>
<a name="ln1658">							// tracker to create a people file.</a>
<a name="ln1659">							//</a>
<a name="ln1660">							dragMessage.AddString(&quot;be:types&quot;, B_FILE_MIME_TYPE);</a>
<a name="ln1661">							dragMessage.AddString(&quot;be:filetypes&quot;,</a>
<a name="ln1662">							  &quot;application/x-person&quot;);</a>
<a name="ln1663">							dragMessage.AddString(&quot;be:filetypes&quot;, &quot;text/plain&quot;);</a>
<a name="ln1664">							dragMessage.AddString(&quot;be:clip_name&quot;, &quot;Person&quot;);</a>
<a name="ln1665"> </a>
<a name="ln1666">							dragMessage.AddString(&quot;be:email&quot;, enclosure-&gt;name);</a>
<a name="ln1667">							break;</a>
<a name="ln1668"> </a>
<a name="ln1669">						default:</a>
<a name="ln1670">							//</a>
<a name="ln1671">							// Otherwise it doesn't have a type that I know how</a>
<a name="ln1672">							// to save.  It won't have any types and if any</a>
<a name="ln1673">							// program wants to accept it, more power to them.</a>
<a name="ln1674">							// (tracker won't.)</a>
<a name="ln1675">							//</a>
<a name="ln1676">							dragMessage.AddString(&quot;be:clip_name&quot;, &quot;Hyperlink&quot;);</a>
<a name="ln1677">					}</a>
<a name="ln1678"> </a>
<a name="ln1679">					BMessage data;</a>
<a name="ln1680">					data.AddPointer(&quot;enclosure&quot;, enclosure);</a>
<a name="ln1681">					dragMessage.AddMessage(&quot;be:originator-data&quot;, &amp;data);</a>
<a name="ln1682"> </a>
<a name="ln1683">					BRegion selectRegion;</a>
<a name="ln1684">					GetTextRegion(start, finish, &amp;selectRegion);</a>
<a name="ln1685">					DragMessage(&amp;dragMessage, selectRegion.Frame(), this);</a>
<a name="ln1686">				} else {</a>
<a name="ln1687">					//</a>
<a name="ln1688">					//	User Single clicked on the attachment.  Open it.</a>
<a name="ln1689">					//</a>
<a name="ln1690">					Open(enclosure);</a>
<a name="ln1691">				}</a>
<a name="ln1692">			}</a>
<a name="ln1693">			return;</a>
<a name="ln1694">		}</a>
<a name="ln1695">	}</a>
<a name="ln1696">	BTextView::MouseDown(where);</a>
<a name="ln1697">}</a>
<a name="ln1698"> </a>
<a name="ln1699"> </a>
<a name="ln1700">void</a>
<a name="ln1701">TTextView::MouseMoved(BPoint where, uint32 code, const BMessage *msg)</a>
<a name="ln1702">{</a>
<a name="ln1703">	int32 start = OffsetAt(where);</a>
<a name="ln1704"> </a>
<a name="ln1705">	for (int32 loop = fEnclosures-&gt;CountItems(); loop-- &gt; 0;) {</a>
<a name="ln1706">		hyper_text *enclosure = (hyper_text *)fEnclosures-&gt;ItemAt(loop);</a>
<a name="ln1707">		if ((start &gt;= enclosure-&gt;text_start) &amp;&amp; (start &lt; enclosure-&gt;text_end)) {</a>
<a name="ln1708">			if (!fCursor)</a>
<a name="ln1709">				SetViewCursor(B_CURSOR_SYSTEM_DEFAULT);</a>
<a name="ln1710">			fCursor = true;</a>
<a name="ln1711">			return;</a>
<a name="ln1712">		}</a>
<a name="ln1713">	}</a>
<a name="ln1714"> </a>
<a name="ln1715">	if (fCursor) {</a>
<a name="ln1716">		SetViewCursor(B_CURSOR_I_BEAM);</a>
<a name="ln1717">		fCursor = false;</a>
<a name="ln1718">	}</a>
<a name="ln1719"> </a>
<a name="ln1720">	BTextView::MouseMoved(where, code, msg);</a>
<a name="ln1721">}</a>
<a name="ln1722"> </a>
<a name="ln1723"> </a>
<a name="ln1724">void</a>
<a name="ln1725">TTextView::ClearList()</a>
<a name="ln1726">{</a>
<a name="ln1727">	hyper_text *enclosure;</a>
<a name="ln1728">	while ((enclosure = (hyper_text *)fEnclosures-&gt;FirstItem()) != NULL) {</a>
<a name="ln1729">		fEnclosures-&gt;RemoveItem(enclosure);</a>
<a name="ln1730"> </a>
<a name="ln1731">		if (enclosure-&gt;name)</a>
<a name="ln1732">			free(enclosure-&gt;name);</a>
<a name="ln1733">		if (enclosure-&gt;content_type)</a>
<a name="ln1734">			free(enclosure-&gt;content_type);</a>
<a name="ln1735">		if (enclosure-&gt;encoding)</a>
<a name="ln1736">			free(enclosure-&gt;encoding);</a>
<a name="ln1737">		if (enclosure-&gt;have_ref &amp;&amp; !enclosure-&gt;saved) {</a>
<a name="ln1738">			BEntry entry(&amp;enclosure-&gt;ref);</a>
<a name="ln1739">			entry.Remove();</a>
<a name="ln1740">		}</a>
<a name="ln1741"> </a>
<a name="ln1742">		watch_node(&amp;enclosure-&gt;node, B_STOP_WATCHING, this);</a>
<a name="ln1743">		free(enclosure);</a>
<a name="ln1744">	}</a>
<a name="ln1745">}</a>
<a name="ln1746"> </a>
<a name="ln1747"> </a>
<a name="ln1748">void</a>
<a name="ln1749">TTextView::LoadMessage(BEmailMessage *mail, bool quoteIt, const char *text)</a>
<a name="ln1750">{</a>
<a name="ln1751">	StopLoad();</a>
<a name="ln1752"> </a>
<a name="ln1753">	fMail = mail;</a>
<a name="ln1754"> </a>
<a name="ln1755">	ClearList();</a>
<a name="ln1756"> </a>
<a name="ln1757">	MakeSelectable(true);</a>
<a name="ln1758">	MakeEditable(false);</a>
<a name="ln1759">	if (text)</a>
<a name="ln1760">		Insert(text, strlen(text));</a>
<a name="ln1761"> </a>
<a name="ln1762">	//attr_info attrInfo;</a>
<a name="ln1763">	TTextView::Reader *reader = new TTextView::Reader(fHeader, fRaw, quoteIt, fIncoming,</a>
<a name="ln1764">				text != NULL, true,</a>
<a name="ln1765">				// I removed the following, because I absolutely can't imagine why it's</a>
<a name="ln1766">				// there (the mail kit should be able to deal with non-compliant mails)</a>
<a name="ln1767">				// -- axeld.</a>
<a name="ln1768">				// fFile-&gt;GetAttrInfo(B_MAIL_ATTR_MIME, &amp;attrInfo) == B_OK,</a>
<a name="ln1769">				this, mail, fEnclosures, fStopSem);</a>
<a name="ln1770"> </a>
<a name="ln1771">	resume_thread(fThread = spawn_thread(Reader::Run, &quot;reader&quot;, B_NORMAL_PRIORITY, reader));</a>
<a name="ln1772">}</a>
<a name="ln1773"> </a>
<a name="ln1774"> </a>
<a name="ln1775">void</a>
<a name="ln1776">TTextView::Open(hyper_text *enclosure)</a>
<a name="ln1777">{</a>
<a name="ln1778">	switch (enclosure-&gt;type) {</a>
<a name="ln1779">		case TYPE_URL:</a>
<a name="ln1780">		{</a>
<a name="ln1781">			const struct {const char *urlType, *handler; } handlerTable[] = {</a>
<a name="ln1782">				{&quot;http&quot;,	B_URL_HTTP},</a>
<a name="ln1783">				{&quot;https&quot;,	B_URL_HTTPS},</a>
<a name="ln1784">				{&quot;ftp&quot;,		B_URL_FTP},</a>
<a name="ln1785">				{&quot;gopher&quot;,	B_URL_GOPHER},</a>
<a name="ln1786">				{&quot;mailto&quot;,	B_URL_MAILTO},</a>
<a name="ln1787">				{&quot;news&quot;,	B_URL_NEWS},</a>
<a name="ln1788">				{&quot;nntp&quot;,	B_URL_NNTP},</a>
<a name="ln1789">				{&quot;telnet&quot;,	B_URL_TELNET},</a>
<a name="ln1790">				{&quot;rlogin&quot;,	B_URL_RLOGIN},</a>
<a name="ln1791">				{&quot;tn3270&quot;,	B_URL_TN3270},</a>
<a name="ln1792">				{&quot;wais&quot;,	B_URL_WAIS},</a>
<a name="ln1793">				{&quot;file&quot;,	B_URL_FILE},</a>
<a name="ln1794">				{NULL,		NULL}</a>
<a name="ln1795">			};</a>
<a name="ln1796">			const char *handlerToLaunch = NULL;</a>
<a name="ln1797"> </a>
<a name="ln1798">			const char *colonPos = strchr(enclosure-&gt;name, ':');</a>
<a name="ln1799">			if (colonPos) {</a>
<a name="ln1800">				int urlTypeLength = colonPos - enclosure-&gt;name;</a>
<a name="ln1801"> </a>
<a name="ln1802">				for (int32 index = 0; handlerTable[index].urlType; index++) {</a>
<a name="ln1803">					if (!strncasecmp(enclosure-&gt;name,</a>
<a name="ln1804">							handlerTable[index].urlType, urlTypeLength)) {</a>
<a name="ln1805">						handlerToLaunch = handlerTable[index].handler;</a>
<a name="ln1806">						break;</a>
<a name="ln1807">					}</a>
<a name="ln1808">				}</a>
<a name="ln1809">			}</a>
<a name="ln1810">			if (handlerToLaunch) {</a>
<a name="ln1811">				entry_ref appRef;</a>
<a name="ln1812">				if (be_roster-&gt;FindApp(handlerToLaunch, &amp;appRef) != B_OK)</a>
<a name="ln1813">					handlerToLaunch = NULL;</a>
<a name="ln1814">			}</a>
<a name="ln1815">			if (!handlerToLaunch)</a>
<a name="ln1816">				handlerToLaunch = &quot;application/x-vnd.Be-Bookmark&quot;;</a>
<a name="ln1817"> </a>
<a name="ln1818">			status_t result = be_roster-&gt;Launch(handlerToLaunch, 1, &amp;enclosure-&gt;name);</a>
<a name="ln1819">			if (result != B_NO_ERROR &amp;&amp; result != B_ALREADY_RUNNING) {</a>
<a name="ln1820">				beep();</a>
<a name="ln1821">				BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln1822">					B_TRANSLATE(&quot;There is no installed handler for &quot;</a>
<a name="ln1823">						&quot;URL links.&quot;), B_TRANSLATE(&quot;Sorry&quot;));</a>
<a name="ln1824">				alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln1825">				alert-&gt;Go();</a>
<a name="ln1826">			}</a>
<a name="ln1827">			break;</a>
<a name="ln1828">		}</a>
<a name="ln1829"> </a>
<a name="ln1830">		case TYPE_MAILTO:</a>
<a name="ln1831">			if (be_roster-&gt;Launch(B_MAIL_TYPE, 1, &amp;enclosure-&gt;name) &lt; B_OK) {</a>
<a name="ln1832">				char *argv[] = {(char *)&quot;Mail&quot;, enclosure-&gt;name};</a>
<a name="ln1833">				be_app-&gt;ArgvReceived(2, argv);</a>
<a name="ln1834">			}</a>
<a name="ln1835">			break;</a>
<a name="ln1836"> </a>
<a name="ln1837">		case TYPE_ENCLOSURE:</a>
<a name="ln1838">		case TYPE_BE_ENCLOSURE:</a>
<a name="ln1839">			if (!enclosure-&gt;have_ref) {</a>
<a name="ln1840">				BPath path;</a>
<a name="ln1841">				if (find_directory(B_SYSTEM_TEMP_DIRECTORY, &amp;path) == B_NO_ERROR) {</a>
<a name="ln1842">					BDirectory dir(path.Path());</a>
<a name="ln1843">					if (dir.InitCheck() == B_NO_ERROR) {</a>
<a name="ln1844">						char name[B_FILE_NAME_LENGTH];</a>
<a name="ln1845">						char baseName[B_FILE_NAME_LENGTH];</a>
<a name="ln1846">						strcpy(baseName, enclosure-&gt;name ? enclosure-&gt;name : &quot;enclosure&quot;);</a>
<a name="ln1847">						strcpy(name, baseName);</a>
<a name="ln1848">						for (int32 index = 0; dir.Contains(name); index++) {</a>
<a name="ln1849">							snprintf(name, B_FILE_NAME_LENGTH, &quot;%s_%&quot; B_PRId32,</a>
<a name="ln1850">								baseName, index);</a>
<a name="ln1851">						}</a>
<a name="ln1852"> </a>
<a name="ln1853">						BEntry entry(path.Path());</a>
<a name="ln1854">						entry_ref ref;</a>
<a name="ln1855">						entry.GetRef(&amp;ref);</a>
<a name="ln1856"> </a>
<a name="ln1857">						BMessage save(M_SAVE);</a>
<a name="ln1858">						save.AddRef(&quot;directory&quot;, &amp;ref);</a>
<a name="ln1859">						save.AddString(&quot;name&quot;, name);</a>
<a name="ln1860">						save.AddPointer(&quot;enclosure&quot;, enclosure);</a>
<a name="ln1861">						if (Save(&amp;save) != B_NO_ERROR)</a>
<a name="ln1862">							break;</a>
<a name="ln1863">						enclosure-&gt;saved = false;</a>
<a name="ln1864">					}</a>
<a name="ln1865">				}</a>
<a name="ln1866">			}</a>
<a name="ln1867"> </a>
<a name="ln1868">			BMessenger tracker(&quot;application/x-vnd.Be-TRAK&quot;);</a>
<a name="ln1869">			if (tracker.IsValid()) {</a>
<a name="ln1870">				BMessage openMsg(B_REFS_RECEIVED);</a>
<a name="ln1871">				openMsg.AddRef(&quot;refs&quot;, &amp;enclosure-&gt;ref);</a>
<a name="ln1872">				tracker.SendMessage(&amp;openMsg);</a>
<a name="ln1873">			}</a>
<a name="ln1874">			break;</a>
<a name="ln1875">	}</a>
<a name="ln1876">}</a>
<a name="ln1877"> </a>
<a name="ln1878"> </a>
<a name="ln1879">status_t</a>
<a name="ln1880">TTextView::Save(BMessage *msg, bool makeNewFile)</a>
<a name="ln1881">{</a>
<a name="ln1882">	const char		*name;</a>
<a name="ln1883">	entry_ref		ref;</a>
<a name="ln1884">	BFile			file;</a>
<a name="ln1885">	BPath			path;</a>
<a name="ln1886">	hyper_text		*enclosure;</a>
<a name="ln1887">	status_t		result = B_NO_ERROR;</a>
<a name="ln1888">	char 			entry_name[B_FILE_NAME_LENGTH];</a>
<a name="ln1889"> </a>
<a name="ln1890">	msg-&gt;FindString(&quot;name&quot;, &amp;name);</a>
<a name="ln1891">	msg-&gt;FindRef(&quot;directory&quot;, &amp;ref);</a>
<a name="ln1892">	msg-&gt;FindPointer(&quot;enclosure&quot;, (void **)&amp;enclosure);</a>
<a name="ln1893"> </a>
<a name="ln1894">	BDirectory dir;</a>
<a name="ln1895">	dir.SetTo(&amp;ref);</a>
<a name="ln1896">	result = dir.InitCheck();</a>
<a name="ln1897"> </a>
<a name="ln1898">	if (result == B_OK) {</a>
<a name="ln1899">		if (makeNewFile) {</a>
<a name="ln1900">			//</a>
<a name="ln1901">			// Search for the file and delete it if it already exists.</a>
<a name="ln1902">			// (It may not, that's ok.)</a>
<a name="ln1903">			//</a>
<a name="ln1904">			BEntry entry;</a>
<a name="ln1905">			if (dir.FindEntry(name, &amp;entry) == B_NO_ERROR)</a>
<a name="ln1906">				entry.Remove();</a>
<a name="ln1907"> </a>
<a name="ln1908">			if ((enclosure-&gt;have_ref) &amp;&amp; (!enclosure-&gt;saved)) {</a>
<a name="ln1909">				entry.SetTo(&amp;enclosure-&gt;ref);</a>
<a name="ln1910"> </a>
<a name="ln1911">				//</a>
<a name="ln1912">				// Added true arg and entry_name so MoveTo clobbers as</a>
<a name="ln1913">				// before. This may not be the correct behaviour, but</a>
<a name="ln1914">				// it's the preserved behaviour.</a>
<a name="ln1915">				//</a>
<a name="ln1916">				entry.GetName(entry_name);</a>
<a name="ln1917">				result = entry.MoveTo(&amp;dir, entry_name, true);</a>
<a name="ln1918">				if (result == B_NO_ERROR) {</a>
<a name="ln1919">					entry.Rename(name);</a>
<a name="ln1920">					entry.GetRef(&amp;enclosure-&gt;ref);</a>
<a name="ln1921">					entry.GetNodeRef(&amp;enclosure-&gt;node);</a>
<a name="ln1922">					enclosure-&gt;saved = true;</a>
<a name="ln1923">					return result;</a>
<a name="ln1924">				}</a>
<a name="ln1925">			}</a>
<a name="ln1926"> </a>
<a name="ln1927">			if (result == B_NO_ERROR) {</a>
<a name="ln1928">				result = dir.CreateFile(name, &amp;file);</a>
<a name="ln1929">				if (result == B_NO_ERROR &amp;&amp; enclosure-&gt;content_type) {</a>
<a name="ln1930">					char type[B_MIME_TYPE_LENGTH];</a>
<a name="ln1931"> </a>
<a name="ln1932">					if (!strcasecmp(enclosure-&gt;content_type, &quot;message/rfc822&quot;))</a>
<a name="ln1933">						strcpy(type, &quot;text/x-email&quot;);</a>
<a name="ln1934">					else if (!strcasecmp(enclosure-&gt;content_type, &quot;message/delivery-status&quot;))</a>
<a name="ln1935">						strcpy(type, &quot;text/plain&quot;);</a>
<a name="ln1936">					else</a>
<a name="ln1937">						strcpy(type, enclosure-&gt;content_type);</a>
<a name="ln1938"> </a>
<a name="ln1939">					BNodeInfo info(&amp;file);</a>
<a name="ln1940">					info.SetType(type);</a>
<a name="ln1941">				}</a>
<a name="ln1942">			}</a>
<a name="ln1943">		} else {</a>
<a name="ln1944">			//</a>
<a name="ln1945">			// 	This file was dragged into the tracker or desktop.  The file</a>
<a name="ln1946">			//	already exists.</a>
<a name="ln1947">			//</a>
<a name="ln1948">			result = file.SetTo(&amp;dir, name, B_WRITE_ONLY);</a>
<a name="ln1949">		}</a>
<a name="ln1950">	}</a>
<a name="ln1951"> </a>
<a name="ln1952">	if (enclosure-&gt;component == NULL)</a>
<a name="ln1953">		result = B_ERROR;</a>
<a name="ln1954"> </a>
<a name="ln1955">	if (result == B_NO_ERROR) {</a>
<a name="ln1956">		//</a>
<a name="ln1957">		// Write the data</a>
<a name="ln1958">		//</a>
<a name="ln1959">		enclosure-&gt;component-&gt;GetDecodedData(&amp;file);</a>
<a name="ln1960"> </a>
<a name="ln1961">		BEntry entry;</a>
<a name="ln1962">		dir.FindEntry(name, &amp;entry);</a>
<a name="ln1963">		entry.GetRef(&amp;enclosure-&gt;ref);</a>
<a name="ln1964">		enclosure-&gt;have_ref = true;</a>
<a name="ln1965">		enclosure-&gt;saved = true;</a>
<a name="ln1966">		entry.GetPath(&amp;path);</a>
<a name="ln1967">		update_mime_info(path.Path(), false, true,</a>
<a name="ln1968">			!cistrcmp(&quot;application/octet-stream&quot;, enclosure-&gt;content_type ? enclosure-&gt;content_type : B_EMPTY_STRING));</a>
<a name="ln1969">		entry.GetNodeRef(&amp;enclosure-&gt;node);</a>
<a name="ln1970">		watch_node(&amp;enclosure-&gt;node, B_WATCH_NAME, this);</a>
<a name="ln1971">	}</a>
<a name="ln1972"> </a>
<a name="ln1973">	if (result != B_NO_ERROR) {</a>
<a name="ln1974">		beep();</a>
<a name="ln1975">		BAlert* alert = new BAlert(&quot;&quot;, B_TRANSLATE(&quot;An error occurred trying to save &quot;</a>
<a name="ln1976">				&quot;the attachment.&quot;),	B_TRANSLATE(&quot;Sorry&quot;));</a>
<a name="ln1977">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln1978">		alert-&gt;Go();</a>
<a name="ln1979">	}</a>
<a name="ln1980"> </a>
<a name="ln1981">	return result;</a>
<a name="ln1982">}</a>
<a name="ln1983"> </a>
<a name="ln1984"> </a>
<a name="ln1985">void</a>
<a name="ln1986">TTextView::StopLoad()</a>
<a name="ln1987">{</a>
<a name="ln1988">	Window()-&gt;Unlock();</a>
<a name="ln1989"> </a>
<a name="ln1990">	thread_info	info;</a>
<a name="ln1991">	if (fThread != 0 &amp;&amp; get_thread_info(fThread, &amp;info) == B_NO_ERROR) {</a>
<a name="ln1992">		fStopLoading = true;</a>
<a name="ln1993">		acquire_sem(fStopSem);</a>
<a name="ln1994">		int32 result;</a>
<a name="ln1995">		wait_for_thread(fThread, &amp;result);</a>
<a name="ln1996">		fThread = 0;</a>
<a name="ln1997">		release_sem(fStopSem);</a>
<a name="ln1998">		fStopLoading = false;</a>
<a name="ln1999">	}</a>
<a name="ln2000"> </a>
<a name="ln2001">	Window()-&gt;Lock();</a>
<a name="ln2002">}</a>
<a name="ln2003"> </a>
<a name="ln2004"> </a>
<a name="ln2005">bool</a>
<a name="ln2006">TTextView::IsReaderThreadRunning()</a>
<a name="ln2007">{</a>
<a name="ln2008">	if (fThread == 0)</a>
<a name="ln2009">		return false;</a>
<a name="ln2010"> </a>
<a name="ln2011">	thread_info info;</a>
<a name="ln2012">	for (int i = 5; i &gt; 0; i--, usleep(100000))</a>
<a name="ln2013">		if (get_thread_info(fThread, &amp;info) != B_OK)</a>
<a name="ln2014">			return false;</a>
<a name="ln2015">	return true;</a>
<a name="ln2016">}</a>
<a name="ln2017"> </a>
<a name="ln2018"> </a>
<a name="ln2019">void</a>
<a name="ln2020">TTextView::AddAsContent(BEmailMessage *mail, bool wrap, uint32 charset, mail_encoding encoding)</a>
<a name="ln2021">{</a>
<a name="ln2022">	if (mail == NULL)</a>
<a name="ln2023">		return;</a>
<a name="ln2024"> </a>
<a name="ln2025">	int32 textLength = TextLength();</a>
<a name="ln2026">	const char *text = Text();</a>
<a name="ln2027"> </a>
<a name="ln2028">	BTextMailComponent *body = mail-&gt;Body();</a>
<a name="ln2029">	if (body == NULL) {</a>
<a name="ln2030">		if (mail-&gt;SetBody(body = new BTextMailComponent()) &lt; B_OK)</a>
<a name="ln2031">			return;</a>
<a name="ln2032">	}</a>
<a name="ln2033">	body-&gt;SetEncoding(encoding, charset);</a>
<a name="ln2034"> </a>
<a name="ln2035">	// Just add the text as a whole if we can, or ...</a>
<a name="ln2036">	if (!wrap) {</a>
<a name="ln2037">		body-&gt;AppendText(text);</a>
<a name="ln2038">		return;</a>
<a name="ln2039">	}</a>
<a name="ln2040"> </a>
<a name="ln2041">	// ... do word wrapping.</a>
<a name="ln2042"> </a>
<a name="ln2043">	BWindow	*window = Window();</a>
<a name="ln2044">	char *saveText = strdup(text);</a>
<a name="ln2045">	BRect saveTextRect = TextRect();</a>
<a name="ln2046"> </a>
<a name="ln2047">	// do this before we start messing with the fonts</a>
<a name="ln2048">	// the user will never know...</a>
<a name="ln2049">	window-&gt;DisableUpdates();</a>
<a name="ln2050">	Hide();</a>
<a name="ln2051">	BScrollBar *vScroller = ScrollBar(B_VERTICAL);</a>
<a name="ln2052">	BScrollBar *hScroller = ScrollBar(B_HORIZONTAL);</a>
<a name="ln2053">	if (vScroller != NULL)</a>
<a name="ln2054">		vScroller-&gt;SetTarget((BView *)NULL);</a>
<a name="ln2055">	if (hScroller != NULL)</a>
<a name="ln2056">		hScroller-&gt;SetTarget((BView *)NULL);</a>
<a name="ln2057"> </a>
<a name="ln2058">	// Temporarily set the font to a fixed width font for line wrapping</a>
<a name="ln2059">	// calculations.  If the font doesn't have as many of the symbols as</a>
<a name="ln2060">	// the preferred font, go back to using the user's preferred font.</a>
<a name="ln2061"> </a>
<a name="ln2062">	bool *boolArray;</a>
<a name="ln2063">	int missingCharactersFixedWidth = 0;</a>
<a name="ln2064">	int missingCharactersPreferredFont = 0;</a>
<a name="ln2065">	int32 numberOfCharacters;</a>
<a name="ln2066"> </a>
<a name="ln2067">	numberOfCharacters = BString(text).CountChars();</a>
<a name="ln2068">	if (numberOfCharacters &gt; 0</a>
<a name="ln2069">		&amp;&amp; (boolArray = (bool *)malloc(sizeof(bool) * numberOfCharacters)) != NULL) {</a>
<a name="ln2070">		memset(boolArray, 0, sizeof (bool) * numberOfCharacters);</a>
<a name="ln2071">		be_fixed_font-&gt;GetHasGlyphs(text, numberOfCharacters, boolArray);</a>
<a name="ln2072">		for (int i = 0; i &lt; numberOfCharacters; i++) {</a>
<a name="ln2073">			if (!boolArray[i])</a>
<a name="ln2074">				missingCharactersFixedWidth += 1;</a>
<a name="ln2075">		}</a>
<a name="ln2076"> </a>
<a name="ln2077">		memset(boolArray, 0, sizeof (bool) * numberOfCharacters);</a>
<a name="ln2078">		fFont.GetHasGlyphs(text, numberOfCharacters, boolArray);</a>
<a name="ln2079">		for (int i = 0; i &lt; numberOfCharacters; i++) {</a>
<a name="ln2080">			if (!boolArray[i])</a>
<a name="ln2081">				missingCharactersPreferredFont += 1;</a>
<a name="ln2082">		}</a>
<a name="ln2083"> </a>
<a name="ln2084">		free(boolArray);</a>
<a name="ln2085">	}</a>
<a name="ln2086"> </a>
<a name="ln2087">	if (missingCharactersFixedWidth &gt; missingCharactersPreferredFont)</a>
<a name="ln2088">		SetFontAndColor(0, textLength, &amp;fFont);</a>
<a name="ln2089">	else // All things being equal, the fixed font is better for wrapping.</a>
<a name="ln2090">		SetFontAndColor(0, textLength, be_fixed_font);</a>
<a name="ln2091"> </a>
<a name="ln2092">	// calculate a text rect that is 72 columns wide</a>
<a name="ln2093">	BRect newTextRect = saveTextRect;</a>
<a name="ln2094">	newTextRect.right = newTextRect.left + be_fixed_font-&gt;StringWidth(&quot;m&quot;) * 72;</a>
<a name="ln2095">	SetTextRect(newTextRect);</a>
<a name="ln2096"> </a>
<a name="ln2097">	// hard-wrap, based on TextView's soft-wrapping</a>
<a name="ln2098">	int32 numLines = CountLines();</a>
<a name="ln2099">	bool spaceMoved = false;</a>
<a name="ln2100">	char *content = (char *)malloc(textLength + numLines * 72);</a>
<a name="ln2101">		// more we'll ever need</a>
<a name="ln2102">	if (content != NULL) {</a>
<a name="ln2103">		int32 contentLength = 0;</a>
<a name="ln2104"> </a>
<a name="ln2105">		int32 nextUrlAt = 0, nextUrlLength = 0;</a>
<a name="ln2106">		BString textStr(text);</a>
<a name="ln2107">		FindURL(text, 0, nextUrlAt, nextUrlLength, NULL);</a>
<a name="ln2108"> </a>
<a name="ln2109">		for (int32 i = 0; i &lt; numLines; i++) {</a>
<a name="ln2110">			int32 startOffset = OffsetAt(i);</a>
<a name="ln2111">			if (spaceMoved) {</a>
<a name="ln2112">				startOffset++;</a>
<a name="ln2113">				spaceMoved = false;</a>
<a name="ln2114">			}</a>
<a name="ln2115">			int32 endOffset = OffsetAt(i + 1);</a>
<a name="ln2116">			int32 lineLength = endOffset - startOffset;</a>
<a name="ln2117"> </a>
<a name="ln2118">			// don't break URLs into several parts</a>
<a name="ln2119">			if (nextUrlAt &gt;= startOffset &amp;&amp; nextUrlAt &lt; endOffset</a>
<a name="ln2120">					&amp;&amp; (nextUrlAt + nextUrlLength) &gt; endOffset) {</a>
<a name="ln2121">				int32 pos = nextUrlAt + nextUrlLength;</a>
<a name="ln2122"> </a>
<a name="ln2123">				// find first break character after the URL</a>
<a name="ln2124">				for (; text[pos]; pos++) {</a>
<a name="ln2125">					if (isalnum(text[pos]) || isspace(text[pos]))</a>
<a name="ln2126">						break;</a>
<a name="ln2127">				}</a>
<a name="ln2128">				if (text[pos] &amp;&amp; isspace(text[pos]) &amp;&amp; text[pos] != '\n')</a>
<a name="ln2129">					pos++;</a>
<a name="ln2130"> </a>
<a name="ln2131">				endOffset += pos - endOffset;</a>
<a name="ln2132">				lineLength = endOffset - startOffset;</a>
<a name="ln2133"> </a>
<a name="ln2134">				// insert a newline (and the same number of quotes) after the</a>
<a name="ln2135">				// URL to make sure the rest of the text is properly wrapped</a>
<a name="ln2136"> </a>
<a name="ln2137">				char buffer[64];</a>
<a name="ln2138">				if (text[pos] == '\n')</a>
<a name="ln2139">					buffer[0] = '\0';</a>
<a name="ln2140">				else</a>
<a name="ln2141">					strcpy(buffer, &quot;\n&quot;);</a>
<a name="ln2142"> </a>
<a name="ln2143">				size_t quoteLength;</a>
<a name="ln2144">				CopyQuotes(text + startOffset, lineLength, buffer + strlen(buffer), quoteLength);</a>
<a name="ln2145"> </a>
<a name="ln2146">				Insert(pos, buffer, strlen(buffer));</a>
<a name="ln2147">				numLines = CountLines();</a>
<a name="ln2148">				text = Text();</a>
<a name="ln2149">				i++;</a>
<a name="ln2150"> </a>
<a name="ln2151">				textStr = BString(text);</a>
<a name="ln2152">				FindURL(text, endOffset, nextUrlAt, nextUrlLength, NULL);</a>
<a name="ln2153">			}</a>
<a name="ln2154">			if (text[endOffset - 1] != ' '</a>
<a name="ln2155">				&amp;&amp; text[endOffset - 1] != '\n'</a>
<a name="ln2156">				&amp;&amp; text[endOffset] == ' ') {</a>
<a name="ln2157">				// make sure spaces will be part of this line</a>
<a name="ln2158">				endOffset++;</a>
<a name="ln2159">				lineLength++;</a>
<a name="ln2160">				spaceMoved = true;</a>
<a name="ln2161">			}</a>
<a name="ln2162"> </a>
<a name="ln2163">			memcpy(content + contentLength, text + startOffset, lineLength);</a>
<a name="ln2164">			contentLength += lineLength;</a>
<a name="ln2165"> </a>
<a name="ln2166">			// add a newline to every line except for the ones</a>
<a name="ln2167">			// that already end in newlines, and the last line</a>
<a name="ln2168">			if ((text[endOffset - 1] != '\n') &amp;&amp; (i &lt; numLines - 1)) {</a>
<a name="ln2169">				content[contentLength++] = '\n';</a>
<a name="ln2170"> </a>
<a name="ln2171">				// copy quote level of the first line</a>
<a name="ln2172">				size_t quoteLength;</a>
<a name="ln2173">				CopyQuotes(text + startOffset, lineLength, content + contentLength, quoteLength);</a>
<a name="ln2174">				contentLength += quoteLength;</a>
<a name="ln2175">			}</a>
<a name="ln2176">		}</a>
<a name="ln2177">		content[contentLength] = '\0';</a>
<a name="ln2178"> </a>
<a name="ln2179">		body-&gt;AppendText(content);</a>
<a name="ln2180">		free(content);</a>
<a name="ln2181">	}</a>
<a name="ln2182"> </a>
<a name="ln2183">	// reset the text rect and font</a>
<a name="ln2184">	SetTextRect(saveTextRect);</a>
<a name="ln2185">	SetText(saveText);</a>
<a name="ln2186">	free(saveText);</a>
<a name="ln2187">	SetFontAndColor(0, textLength, &amp;fFont);</a>
<a name="ln2188"> </a>
<a name="ln2189">	// should be OK to hook these back up now</a>
<a name="ln2190">	if (vScroller != NULL)</a>
<a name="ln2191">		vScroller-&gt;SetTarget(this);</a>
<a name="ln2192">	if (hScroller != NULL)</a>
<a name="ln2193">		hScroller-&gt;SetTarget(this);</a>
<a name="ln2194"> </a>
<a name="ln2195">	Show();</a>
<a name="ln2196">	window-&gt;EnableUpdates();</a>
<a name="ln2197">}</a>
<a name="ln2198"> </a>
<a name="ln2199"> </a>
<a name="ln2200">//	#pragma mark -</a>
<a name="ln2201"> </a>
<a name="ln2202"> </a>
<a name="ln2203">TTextView::Reader::Reader(bool header, bool raw, bool quote, bool incoming,</a>
<a name="ln2204">		bool stripHeader, bool mime, TTextView *view, BEmailMessage *mail,</a>
<a name="ln2205">		BList *list, sem_id sem)</a>
<a name="ln2206">	:</a>
<a name="ln2207">	fHeader(header),</a>
<a name="ln2208">	fRaw(raw),</a>
<a name="ln2209">	fQuote(quote),</a>
<a name="ln2210">	fIncoming(incoming),</a>
<a name="ln2211">	fStripHeader(stripHeader),</a>
<a name="ln2212">	fMime(mime),</a>
<a name="ln2213">	fView(view),</a>
<a name="ln2214">	fMail(mail),</a>
<a name="ln2215">	fEnclosures(list),</a>
<a name="ln2216">	fStopSem(sem)</a>
<a name="ln2217">{</a>
<a name="ln2218">}</a>
<a name="ln2219"> </a>
<a name="ln2220"> </a>
<a name="ln2221">bool</a>
<a name="ln2222">TTextView::Reader::ParseMail(BMailContainer *container,</a>
<a name="ln2223">	BTextMailComponent *ignore)</a>
<a name="ln2224">{</a>
<a name="ln2225">	int32 count = 0;</a>
<a name="ln2226">	for (int32 i = 0; i &lt; container-&gt;CountComponents(); i++) {</a>
<a name="ln2227">		if (fView-&gt;fStopLoading)</a>
<a name="ln2228">			return false;</a>
<a name="ln2229"> </a>
<a name="ln2230">		BMailComponent *component;</a>
<a name="ln2231">		if ((component = container-&gt;GetComponent(i)) == NULL) {</a>
<a name="ln2232">			if (fView-&gt;fStopLoading)</a>
<a name="ln2233">				return false;</a>
<a name="ln2234"> </a>
<a name="ln2235">			hyper_text *enclosure = (hyper_text *)malloc(sizeof(hyper_text));</a>
<a name="ln2236">			if (enclosure == NULL)</a>
<a name="ln2237">				return false;</a>
<a name="ln2238"> </a>
<a name="ln2239">			memset((void*)enclosure, 0, sizeof(hyper_text));</a>
<a name="ln2240"> </a>
<a name="ln2241">			enclosure-&gt;type = TYPE_ENCLOSURE;</a>
<a name="ln2242"> </a>
<a name="ln2243">			const char *name = &quot;\n&lt;Attachment: could not handle&gt;\n&quot;;</a>
<a name="ln2244"> </a>
<a name="ln2245">			fView-&gt;GetSelection(&amp;enclosure-&gt;text_start, &amp;enclosure-&gt;text_end);</a>
<a name="ln2246">			enclosure-&gt;text_start++;</a>
<a name="ln2247">			enclosure-&gt;text_end += strlen(name) - 1;</a>
<a name="ln2248"> </a>
<a name="ln2249">			Insert(name, strlen(name), true);</a>
<a name="ln2250">			fEnclosures-&gt;AddItem(enclosure);</a>
<a name="ln2251">			continue;</a>
<a name="ln2252">		}</a>
<a name="ln2253"> </a>
<a name="ln2254">		count++;</a>
<a name="ln2255">		if (component == ignore)</a>
<a name="ln2256">			continue;</a>
<a name="ln2257"> </a>
<a name="ln2258">		if (component-&gt;ComponentType() == B_MAIL_MULTIPART_CONTAINER) {</a>
<a name="ln2259">			BMIMEMultipartMailContainer *c = dynamic_cast&lt;BMIMEMultipartMailContainer *&gt;(container-&gt;GetComponent(i));</a>
<a name="ln2260">			ASSERT(c != NULL);</a>
<a name="ln2261"> </a>
<a name="ln2262">			if (!ParseMail(c, ignore))</a>
<a name="ln2263">				count--;</a>
<a name="ln2264">		} else if (fIncoming) {</a>
<a name="ln2265">			hyper_text *enclosure = (hyper_text *)malloc(sizeof(hyper_text));</a>
<a name="ln2266">			if (enclosure == NULL)</a>
<a name="ln2267">				return false;</a>
<a name="ln2268"> </a>
<a name="ln2269">			memset((void*)enclosure, 0, sizeof(hyper_text));</a>
<a name="ln2270"> </a>
<a name="ln2271">			enclosure-&gt;type = TYPE_ENCLOSURE;</a>
<a name="ln2272">			enclosure-&gt;component = component;</a>
<a name="ln2273"> </a>
<a name="ln2274">			BString name;</a>
<a name="ln2275">			char fileName[B_FILE_NAME_LENGTH];</a>
<a name="ln2276">			strcpy(fileName, &quot;untitled&quot;);</a>
<a name="ln2277">			if (BMailAttachment *attachment = dynamic_cast &lt;BMailAttachment *&gt; (component))</a>
<a name="ln2278">				attachment-&gt;FileName(fileName);</a>
<a name="ln2279"> </a>
<a name="ln2280">			BPath path(fileName);</a>
<a name="ln2281">			enclosure-&gt;name = strdup(path.Leaf());</a>
<a name="ln2282"> </a>
<a name="ln2283">			BMimeType type;</a>
<a name="ln2284">			component-&gt;MIMEType(&amp;type);</a>
<a name="ln2285">			enclosure-&gt;content_type = strdup(type.Type());</a>
<a name="ln2286"> </a>
<a name="ln2287">			char typeDescription[B_MIME_TYPE_LENGTH];</a>
<a name="ln2288">			if (type.GetShortDescription(typeDescription) != B_OK)</a>
<a name="ln2289">				strcpy(typeDescription, type.Type() ? type.Type() : B_EMPTY_STRING);</a>
<a name="ln2290"> </a>
<a name="ln2291">			name = &quot;\n&lt;&quot;;</a>
<a name="ln2292">			name.Append(B_TRANSLATE_COMMENT(&quot;Enclosure: %name% (Type: %type%)&quot;,</a>
<a name="ln2293">				&quot;Don't translate the variables %name% and %type%.&quot;));</a>
<a name="ln2294">			name.Append(&quot;&gt;\n&quot;);</a>
<a name="ln2295">			name.ReplaceFirst(&quot;%name%&quot;, enclosure-&gt;name);</a>
<a name="ln2296">			name.ReplaceFirst(&quot;%type%&quot;, typeDescription);</a>
<a name="ln2297"> </a>
<a name="ln2298">			fView-&gt;GetSelection(&amp;enclosure-&gt;text_start, &amp;enclosure-&gt;text_end);</a>
<a name="ln2299">			enclosure-&gt;text_start++;</a>
<a name="ln2300">			enclosure-&gt;text_end += strlen(name.String()) - 1;</a>
<a name="ln2301"> </a>
<a name="ln2302">			Insert(name.String(), name.Length(), true);</a>
<a name="ln2303">			fEnclosures-&gt;AddItem(enclosure);</a>
<a name="ln2304">		}</a>
<a name="ln2305">//			default:</a>
<a name="ln2306">//			{</a>
<a name="ln2307">//				PlainTextBodyComponent *body = dynamic_cast&lt;PlainTextBodyComponent *&gt;(container-&gt;GetComponent(i));</a>
<a name="ln2308">//				const char *text;</a>
<a name="ln2309">//				if (body &amp;&amp; (text = body-&gt;Text()) != NULL)</a>
<a name="ln2310">//					Insert(text, strlen(text), false);</a>
<a name="ln2311">//			}</a>
<a name="ln2312">	}</a>
<a name="ln2313">	return count &gt; 0;</a>
<a name="ln2314">}</a>
<a name="ln2315"> </a>
<a name="ln2316"> </a>
<a name="ln2317">bool</a>
<a name="ln2318">TTextView::Reader::Process(const char *data, int32 data_len, bool isHeader)</a>
<a name="ln2319">{</a>
<a name="ln2320">	char line[522];</a>
<a name="ln2321">	int32 count = 0;</a>
<a name="ln2322"> </a>
<a name="ln2323">	const BString dataStr(data, data_len);</a>
<a name="ln2324">	BString nextUrl;</a>
<a name="ln2325">	int32 nextUrlPos = 0, nextUrlLength = 0;</a>
<a name="ln2326">	uint8 nextUrlType</a>
<a name="ln2327">		= FindURL(dataStr, 0, nextUrlPos, nextUrlLength, &amp;nextUrl);</a>
<a name="ln2328"> </a>
<a name="ln2329">	for (int32 loop = 0; loop &lt; data_len; loop++) {</a>
<a name="ln2330">		if (fView-&gt;fStopLoading)</a>
<a name="ln2331">			return false;</a>
<a name="ln2332"> </a>
<a name="ln2333">		if (fQuote &amp;&amp; (!loop || (loop &amp;&amp; data[loop - 1] == '\n'))) {</a>
<a name="ln2334">			strcpy(&amp;line[count], QUOTE);</a>
<a name="ln2335">			count += strlen(QUOTE);</a>
<a name="ln2336">		}</a>
<a name="ln2337">		if (!fRaw &amp;&amp; fIncoming &amp;&amp; (loop &lt; data_len - 7)) {</a>
<a name="ln2338">			uint8 type = (nextUrlPos == loop) ? nextUrlType : 0;</a>
<a name="ln2339"> </a>
<a name="ln2340">			if (type) {</a>
<a name="ln2341">				if (!Insert(line, count, false, isHeader))</a>
<a name="ln2342">					return false;</a>
<a name="ln2343">				count = 0;</a>
<a name="ln2344"> </a>
<a name="ln2345">				hyper_text *enclosure = (hyper_text *)malloc(sizeof(hyper_text));</a>
<a name="ln2346">				if (enclosure == NULL)</a>
<a name="ln2347">					return false;</a>
<a name="ln2348"> </a>
<a name="ln2349">				memset((void*)enclosure, 0, sizeof(hyper_text));</a>
<a name="ln2350">				fView-&gt;GetSelection(&amp;enclosure-&gt;text_start,</a>
<a name="ln2351">					&amp;enclosure-&gt;text_end);</a>
<a name="ln2352">				enclosure-&gt;type = type;</a>
<a name="ln2353">				enclosure-&gt;name = strdup(nextUrl.String());</a>
<a name="ln2354">				if (enclosure-&gt;name == NULL) {</a>
<a name="ln2355">					free(enclosure);</a>
<a name="ln2356">					return false;</a>
<a name="ln2357">				}</a>
<a name="ln2358"> </a>
<a name="ln2359">				Insert(&amp;data[loop], nextUrlLength, true, isHeader);</a>
<a name="ln2360">				enclosure-&gt;text_end += nextUrlLength;</a>
<a name="ln2361">				loop += nextUrlLength - 1;</a>
<a name="ln2362"> </a>
<a name="ln2363">				fEnclosures-&gt;AddItem(enclosure);</a>
<a name="ln2364"> </a>
<a name="ln2365">				nextUrlType</a>
<a name="ln2366">					= FindURL(dataStr, loop,</a>
<a name="ln2367">						nextUrlPos, nextUrlLength, &amp;nextUrl);</a>
<a name="ln2368">				continue;</a>
<a name="ln2369">			}</a>
<a name="ln2370">		}</a>
<a name="ln2371">		if (!fRaw &amp;&amp; fMime &amp;&amp; data[loop] == '=') {</a>
<a name="ln2372">			if ((loop) &amp;&amp; (loop &lt; data_len - 1) &amp;&amp; (data[loop + 1] == '\r'))</a>
<a name="ln2373">				loop += 2;</a>
<a name="ln2374">			else</a>
<a name="ln2375">				line[count++] = data[loop];</a>
<a name="ln2376">		} else if (data[loop] != '\r')</a>
<a name="ln2377">			line[count++] = data[loop];</a>
<a name="ln2378"> </a>
<a name="ln2379">		if (count &gt; 511 || (count &amp;&amp; loop == data_len - 1)) {</a>
<a name="ln2380">			if (!Insert(line, count, false, isHeader))</a>
<a name="ln2381">				return false;</a>
<a name="ln2382">			count = 0;</a>
<a name="ln2383">		}</a>
<a name="ln2384">	}</a>
<a name="ln2385">	return true;</a>
<a name="ln2386">}</a>
<a name="ln2387"> </a>
<a name="ln2388"> </a>
<a name="ln2389">bool</a>
<a name="ln2390">TTextView::Reader::Insert(const char *line, int32 count, bool isHyperLink,</a>
<a name="ln2391">	bool isHeader)</a>
<a name="ln2392">{</a>
<a name="ln2393">	if (!count)</a>
<a name="ln2394">		return true;</a>
<a name="ln2395"> </a>
<a name="ln2396">	BFont font(fView-&gt;Font());</a>
<a name="ln2397">	TextRunArray style(count / 8 + 8);</a>
<a name="ln2398"> </a>
<a name="ln2399">	if (fView-&gt;fColoredQuotes &amp;&amp; !isHeader &amp;&amp; !isHyperLink) {</a>
<a name="ln2400">		FillInQuoteTextRuns(fView, &amp;fQuoteContext, line, count, font,</a>
<a name="ln2401">			&amp;style.Array(), style.MaxEntries());</a>
<a name="ln2402">	} else {</a>
<a name="ln2403">		text_run_array &amp;array = style.Array();</a>
<a name="ln2404">		array.count = 1;</a>
<a name="ln2405">		array.runs[0].offset = 0;</a>
<a name="ln2406">		if (isHeader) {</a>
<a name="ln2407">			array.runs[0].color = isHyperLink ? kHyperLinkColor : kHeaderColor;</a>
<a name="ln2408">			font.SetSize(font.Size() * 0.9);</a>
<a name="ln2409">		} else {</a>
<a name="ln2410">			array.runs[0].color = isHyperLink</a>
<a name="ln2411">				? kHyperLinkColor : kNormalTextColor;</a>
<a name="ln2412">		}</a>
<a name="ln2413">		array.runs[0].font = font;</a>
<a name="ln2414">	}</a>
<a name="ln2415"> </a>
<a name="ln2416">	if (!fView-&gt;Window()-&gt;Lock())</a>
<a name="ln2417">		return false;</a>
<a name="ln2418"> </a>
<a name="ln2419">	fView-&gt;Insert(fView-&gt;TextLength(), line, count, &amp;style.Array());</a>
<a name="ln2420"> </a>
<a name="ln2421">	fView-&gt;Window()-&gt;Unlock();</a>
<a name="ln2422">	return true;</a>
<a name="ln2423">}</a>
<a name="ln2424"> </a>
<a name="ln2425"> </a>
<a name="ln2426">status_t</a>
<a name="ln2427">TTextView::Reader::Run(void *_this)</a>
<a name="ln2428">{</a>
<a name="ln2429">	Reader *reader = (Reader *)_this;</a>
<a name="ln2430">	TTextView *view = reader-&gt;fView;</a>
<a name="ln2431">	char *msg = NULL;</a>
<a name="ln2432">	off_t size = 0;</a>
<a name="ln2433">	int32 len = 0;</a>
<a name="ln2434"> </a>
<a name="ln2435">	if (!reader-&gt;Lock())</a>
<a name="ln2436">		return B_INTERRUPTED;</a>
<a name="ln2437"> </a>
<a name="ln2438">	BFile *file = dynamic_cast&lt;BFile *&gt;(reader-&gt;fMail-&gt;Data());</a>
<a name="ln2439">	if (file != NULL) {</a>
<a name="ln2440">		len = header_len(file);</a>
<a name="ln2441"> </a>
<a name="ln2442">		if (reader-&gt;fHeader)</a>
<a name="ln2443">			size = len;</a>
<a name="ln2444">		if (reader-&gt;fRaw || !reader-&gt;fMime)</a>
<a name="ln2445">			file-&gt;GetSize(&amp;size);</a>
<a name="ln2446"> </a>
<a name="ln2447">		if (size != 0 &amp;&amp; (msg = (char *)malloc(size)) == NULL)</a>
<a name="ln2448">			goto done;</a>
<a name="ln2449">		file-&gt;Seek(0, 0);</a>
<a name="ln2450"> </a>
<a name="ln2451">		if (msg)</a>
<a name="ln2452">			size = file-&gt;Read(msg, size);</a>
<a name="ln2453">	}</a>
<a name="ln2454"> </a>
<a name="ln2455">	// show the header?</a>
<a name="ln2456">	if (reader-&gt;fHeader &amp;&amp; len) {</a>
<a name="ln2457">		// strip all headers except &quot;From&quot;, &quot;To&quot;, &quot;Reply-To&quot;, &quot;Subject&quot;, and &quot;Date&quot;</a>
<a name="ln2458">	 	if (reader-&gt;fStripHeader) {</a>
<a name="ln2459">		 	const char *header = msg;</a>
<a name="ln2460">		 	char *buffer = NULL;</a>
<a name="ln2461"> </a>
<a name="ln2462">			while (strncmp(header, &quot;\r\n&quot;, 2)) {</a>
<a name="ln2463">				const char *eol = header;</a>
<a name="ln2464">				while ((eol = strstr(eol, &quot;\r\n&quot;)) != NULL &amp;&amp; isspace(eol[2]))</a>
<a name="ln2465">					eol += 2;</a>
<a name="ln2466">				if (eol == NULL)</a>
<a name="ln2467">					break;</a>
<a name="ln2468"> </a>
<a name="ln2469">				eol += 2;	// CR+LF belong to the line</a>
<a name="ln2470">				size_t length = eol - header;</a>
<a name="ln2471"> </a>
<a name="ln2472">		 		buffer = (char *)realloc(buffer, length + 1);</a>
<a name="ln2473">		 		if (buffer == NULL)</a>
<a name="ln2474">		 			goto done;</a>
<a name="ln2475"> </a>
<a name="ln2476">		 		memcpy(buffer, header, length);</a>
<a name="ln2477"> </a>
<a name="ln2478">				length = rfc2047_to_utf8(&amp;buffer, &amp;length, length);</a>
<a name="ln2479"> </a>
<a name="ln2480">		 		if (!strncasecmp(header, &quot;Reply-To: &quot;, 10)</a>
<a name="ln2481">		 			|| !strncasecmp(header, &quot;To: &quot;, 4)</a>
<a name="ln2482">		 			|| !strncasecmp(header, &quot;From: &quot;, 6)</a>
<a name="ln2483">		 			|| !strncasecmp(header, &quot;Subject: &quot;, 8)</a>
<a name="ln2484">		 			|| !strncasecmp(header, &quot;Date: &quot;, 6))</a>
<a name="ln2485">		 			reader-&gt;Process(buffer, length, true);</a>
<a name="ln2486"> </a>
<a name="ln2487">		 		header = eol;</a>
<a name="ln2488">	 		}</a>
<a name="ln2489">		 	free(buffer);</a>
<a name="ln2490">	 		reader-&gt;Process(&quot;\r\n&quot;, 2, true);</a>
<a name="ln2491">	 	}</a>
<a name="ln2492">	 	else if (!reader-&gt;Process(msg, len, true))</a>
<a name="ln2493">			goto done;</a>
<a name="ln2494">	}</a>
<a name="ln2495"> </a>
<a name="ln2496">	if (reader-&gt;fRaw) {</a>
<a name="ln2497">		if (!reader-&gt;Process((const char *)msg + len, size - len))</a>
<a name="ln2498">			goto done;</a>
<a name="ln2499">	} else {</a>
<a name="ln2500">		//reader-&gt;fFile-&gt;Seek(0, 0);</a>
<a name="ln2501">		//BEmailMessage *mail = new BEmailMessage(reader-&gt;fFile);</a>
<a name="ln2502">		BEmailMessage *mail = reader-&gt;fMail;</a>
<a name="ln2503"> </a>
<a name="ln2504">		// at first, insert the mail body</a>
<a name="ln2505">		BTextMailComponent *body = NULL;</a>
<a name="ln2506">		if (mail-&gt;BodyText() &amp;&amp; !view-&gt;fStopLoading) {</a>
<a name="ln2507">			char *bodyText = const_cast&lt;char *&gt;(mail-&gt;BodyText());</a>
<a name="ln2508">			int32 bodyLength = strlen(bodyText);</a>
<a name="ln2509">			body = mail-&gt;Body();</a>
<a name="ln2510">			bool isHTML = false;</a>
<a name="ln2511"> </a>
<a name="ln2512">			BMimeType type;</a>
<a name="ln2513">			if (body-&gt;MIMEType(&amp;type) == B_OK &amp;&amp; type == &quot;text/html&quot;) {</a>
<a name="ln2514">				// strip out HTML tags</a>
<a name="ln2515">				char *t = bodyText, *a, *end = bodyText + bodyLength;</a>
<a name="ln2516">				bodyText = (char *)malloc(bodyLength + 1);</a>
<a name="ln2517">				isHTML = true;</a>
<a name="ln2518"> </a>
<a name="ln2519">				// TODO: is it correct to assume that the text is in Latin-1?</a>
<a name="ln2520">				//		because if it isn't, the code below won't work correctly...</a>
<a name="ln2521"> </a>
<a name="ln2522">				for (a = bodyText; t &lt; end; t++) {</a>
<a name="ln2523">					int32 c = *t;</a>
<a name="ln2524"> </a>
<a name="ln2525">					// compact spaces</a>
<a name="ln2526">					bool space = false;</a>
<a name="ln2527">					while (c &amp;&amp; (c == ' ' || c == '\t')) {</a>
<a name="ln2528">						c = *(++t);</a>
<a name="ln2529">						space = true;</a>
<a name="ln2530">					}</a>
<a name="ln2531">					if (space) {</a>
<a name="ln2532">						c = ' ';</a>
<a name="ln2533">						t--;</a>
<a name="ln2534">					} else if (FilterHTMLTag(c, &amp;t, end))	// the tag filter</a>
<a name="ln2535">						continue;</a>
<a name="ln2536"> </a>
<a name="ln2537">					Unicode2UTF8(c, &amp;a);</a>
<a name="ln2538">				}</a>
<a name="ln2539"> </a>
<a name="ln2540">				*a = 0;</a>
<a name="ln2541">				bodyLength = strlen(bodyText);</a>
<a name="ln2542">				body = NULL;	// to add the HTML text as enclosure</a>
<a name="ln2543">			}</a>
<a name="ln2544">			if (!reader-&gt;Process(bodyText, bodyLength))</a>
<a name="ln2545">				goto done;</a>
<a name="ln2546"> </a>
<a name="ln2547">			if (isHTML)</a>
<a name="ln2548">				free(bodyText);</a>
<a name="ln2549">		}</a>
<a name="ln2550"> </a>
<a name="ln2551">		if (!reader-&gt;ParseMail(mail, body))</a>
<a name="ln2552">			goto done;</a>
<a name="ln2553"> </a>
<a name="ln2554">		//reader-&gt;fView-&gt;fMail = mail;</a>
<a name="ln2555">	}</a>
<a name="ln2556"> </a>
<a name="ln2557">	if (!view-&gt;fStopLoading &amp;&amp; view-&gt;Window()-&gt;Lock()) {</a>
<a name="ln2558">		view-&gt;Select(0, 0);</a>
<a name="ln2559">		view-&gt;MakeSelectable(true);</a>
<a name="ln2560">		if (!reader-&gt;fIncoming)</a>
<a name="ln2561">			view-&gt;MakeEditable(true);</a>
<a name="ln2562"> </a>
<a name="ln2563">		view-&gt;Window()-&gt;Unlock();</a>
<a name="ln2564">	}</a>
<a name="ln2565"> </a>
<a name="ln2566">done:</a>
<a name="ln2567">	// restore the reading position if available</a>
<a name="ln2568">	view-&gt;Window()-&gt;PostMessage(M_READ_POS);</a>
<a name="ln2569"> </a>
<a name="ln2570">	reader-&gt;Unlock();</a>
<a name="ln2571"> </a>
<a name="ln2572">	delete reader;</a>
<a name="ln2573">	free(msg);</a>
<a name="ln2574"> </a>
<a name="ln2575">	return B_NO_ERROR;</a>
<a name="ln2576">}</a>
<a name="ln2577"> </a>
<a name="ln2578"> </a>
<a name="ln2579">status_t</a>
<a name="ln2580">TTextView::Reader::Unlock()</a>
<a name="ln2581">{</a>
<a name="ln2582">	return release_sem(fStopSem);</a>
<a name="ln2583">}</a>
<a name="ln2584"> </a>
<a name="ln2585"> </a>
<a name="ln2586">bool</a>
<a name="ln2587">TTextView::Reader::Lock()</a>
<a name="ln2588">{</a>
<a name="ln2589">	if (acquire_sem_etc(fStopSem, 1, B_TIMEOUT, 0) != B_NO_ERROR)</a>
<a name="ln2590">		return false;</a>
<a name="ln2591"> </a>
<a name="ln2592">	return true;</a>
<a name="ln2593">}</a>
<a name="ln2594"> </a>
<a name="ln2595"> </a>
<a name="ln2596">//====================================================================</a>
<a name="ln2597">//	#pragma mark -</a>
<a name="ln2598"> </a>
<a name="ln2599"> </a>
<a name="ln2600">TSavePanel::TSavePanel(hyper_text *enclosure, TTextView *view)</a>
<a name="ln2601">	: BFilePanel(B_SAVE_PANEL)</a>
<a name="ln2602">{</a>
<a name="ln2603">	fEnclosure = enclosure;</a>
<a name="ln2604">	fView = view;</a>
<a name="ln2605">	if (enclosure-&gt;name)</a>
<a name="ln2606">		SetSaveText(enclosure-&gt;name);</a>
<a name="ln2607">}</a>
<a name="ln2608"> </a>
<a name="ln2609"> </a>
<a name="ln2610">void</a>
<a name="ln2611">TSavePanel::SendMessage(const BMessenger * /* messenger */, BMessage *msg)</a>
<a name="ln2612">{</a>
<a name="ln2613">	const char	*name = NULL;</a>
<a name="ln2614">	BMessage	save(M_SAVE);</a>
<a name="ln2615">	entry_ref	ref;</a>
<a name="ln2616"> </a>
<a name="ln2617">	if ((!msg-&gt;FindRef(&quot;directory&quot;, &amp;ref)) &amp;&amp; (!msg-&gt;FindString(&quot;name&quot;, &amp;name))) {</a>
<a name="ln2618">		save.AddPointer(&quot;enclosure&quot;, fEnclosure);</a>
<a name="ln2619">		save.AddString(&quot;name&quot;, name);</a>
<a name="ln2620">		save.AddRef(&quot;directory&quot;, &amp;ref);</a>
<a name="ln2621">		fView-&gt;Window()-&gt;PostMessage(&amp;save, fView);</a>
<a name="ln2622">	}</a>
<a name="ln2623">}</a>
<a name="ln2624"> </a>
<a name="ln2625"> </a>
<a name="ln2626">void</a>
<a name="ln2627">TSavePanel::SetEnclosure(hyper_text *enclosure)</a>
<a name="ln2628">{</a>
<a name="ln2629">	fEnclosure = enclosure;</a>
<a name="ln2630">	if (enclosure-&gt;name)</a>
<a name="ln2631">		SetSaveText(enclosure-&gt;name);</a>
<a name="ln2632">	else</a>
<a name="ln2633">		SetSaveText(&quot;&quot;);</a>
<a name="ln2634"> </a>
<a name="ln2635">	if (!IsShowing())</a>
<a name="ln2636">		Show();</a>
<a name="ln2637">	Window()-&gt;Activate();</a>
<a name="ln2638">}</a>
<a name="ln2639"> </a>
<a name="ln2640"> </a>
<a name="ln2641">//--------------------------------------------------------------------</a>
<a name="ln2642">//	#pragma mark -</a>
<a name="ln2643"> </a>
<a name="ln2644"> </a>
<a name="ln2645">void</a>
<a name="ln2646">TTextView::InsertText(const char *insertText, int32 length, int32 offset,</a>
<a name="ln2647">	const text_run_array *runs)</a>
<a name="ln2648">{</a>
<a name="ln2649">	ContentChanged();</a>
<a name="ln2650"> </a>
<a name="ln2651">	// Undo function</a>
<a name="ln2652"> </a>
<a name="ln2653">	int32 cursorPos, dummy;</a>
<a name="ln2654">	GetSelection(&amp;cursorPos, &amp;dummy);</a>
<a name="ln2655"> </a>
<a name="ln2656">	if (fInputMethodUndoState.active) {</a>
<a name="ln2657">		// IMアクティブ時は、一旦別のバッファへ記憶</a>
<a name="ln2658">		fInputMethodUndoBuffer.AddUndo(insertText, length, offset, K_INSERTED, cursorPos);</a>
<a name="ln2659">		fInputMethodUndoState.replace = false;</a>
<a name="ln2660">	} else {</a>
<a name="ln2661">		if (fUndoState.replaced) {</a>
<a name="ln2662">			fUndoBuffer.AddUndo(insertText, length, offset, K_REPLACED, cursorPos);</a>
<a name="ln2663">		} else {</a>
<a name="ln2664">			if (length == 1 &amp;&amp; insertText[0] == 0x0a)</a>
<a name="ln2665">				fUndoBuffer.MakeNewUndoItem();</a>
<a name="ln2666"> </a>
<a name="ln2667">			fUndoBuffer.AddUndo(insertText, length, offset, K_INSERTED, cursorPos);</a>
<a name="ln2668"> </a>
<a name="ln2669">			if (length == 1 &amp;&amp; insertText[0] == 0x0a)</a>
<a name="ln2670">				fUndoBuffer.MakeNewUndoItem();</a>
<a name="ln2671">		}</a>
<a name="ln2672">	}</a>
<a name="ln2673"> </a>
<a name="ln2674">	fUndoState.replaced = false;</a>
<a name="ln2675">	fUndoState.deleted = false;</a>
<a name="ln2676"> </a>
<a name="ln2677">	struct text_runs : text_run_array { text_run _runs[1]; } style;</a>
<a name="ln2678">	if (runs == NULL &amp;&amp; IsEditable()) {</a>
<a name="ln2679">		style.count = 1;</a>
<a name="ln2680">		style.runs[0].offset = 0;</a>
<a name="ln2681">		style.runs[0].font = fFont;</a>
<a name="ln2682">		style.runs[0].color = kNormalTextColor;</a>
<a name="ln2683">		runs = &amp;style;</a>
<a name="ln2684">	}</a>
<a name="ln2685"> </a>
<a name="ln2686">	BTextView::InsertText(insertText, length, offset, runs);</a>
<a name="ln2687"> </a>
<a name="ln2688">	if (fSpellCheck &amp;&amp; IsEditable())</a>
<a name="ln2689">	{</a>
<a name="ln2690">		UpdateSpellMarks(offset, length);</a>
<a name="ln2691"> </a>
<a name="ln2692">		rgb_color color;</a>
<a name="ln2693">		GetFontAndColor(offset - 1, NULL, &amp;color);</a>
<a name="ln2694">		const char *text = Text();</a>
<a name="ln2695"> </a>
<a name="ln2696">		if (length &gt; 1</a>
<a name="ln2697">			|| isalpha(text[offset + 1])</a>
<a name="ln2698">			|| (!isalpha(text[offset]) &amp;&amp; text[offset] != '\'')</a>
<a name="ln2699">			|| (color.red == kSpellTextColor.red</a>
<a name="ln2700">				&amp;&amp; color.green == kSpellTextColor.green</a>
<a name="ln2701">				&amp;&amp; color.blue == kSpellTextColor.blue))</a>
<a name="ln2702">		{</a>
<a name="ln2703">			int32 start, end;</a>
<a name="ln2704">			FindSpellBoundry(length, offset, &amp;start, &amp;end);</a>
<a name="ln2705"> </a>
<a name="ln2706">			DSPELL(printf(&quot;Offset %ld, start %ld, end %ld\n&quot;, offset, start, end));</a>
<a name="ln2707">			DSPELL(printf(&quot;\t\&quot;%10.10s...\&quot;\n&quot;, text + start));</a>
<a name="ln2708"> </a>
<a name="ln2709">			CheckSpelling(start, end);</a>
<a name="ln2710">		}</a>
<a name="ln2711">	}</a>
<a name="ln2712">}</a>
<a name="ln2713"> </a>
<a name="ln2714"> </a>
<a name="ln2715">void</a>
<a name="ln2716">TTextView::DeleteText(int32 start, int32 finish)</a>
<a name="ln2717">{</a>
<a name="ln2718">	ContentChanged();</a>
<a name="ln2719"> </a>
<a name="ln2720">	// Undo function</a>
<a name="ln2721">	int32 cursorPos, dummy;</a>
<a name="ln2722">	GetSelection(&amp;cursorPos, &amp;dummy);</a>
<a name="ln2723">	if (fInputMethodUndoState.active) {</a>
<a name="ln2724">		if (fInputMethodUndoState.replace) {</a>
<a name="ln2725">			fUndoBuffer.AddUndo(&amp;Text()[start], finish - start, start, K_DELETED, cursorPos);</a>
<a name="ln2726">			fInputMethodUndoState.replace = false;</a>
<a name="ln2727">		} else {</a>
<a name="ln2728">			fInputMethodUndoBuffer.AddUndo(&amp;Text()[start], finish - start, start,</a>
<a name="ln2729">				K_DELETED, cursorPos);</a>
<a name="ln2730">		}</a>
<a name="ln2731">	} else</a>
<a name="ln2732">		fUndoBuffer.AddUndo(&amp;Text()[start], finish - start, start, K_DELETED, cursorPos);</a>
<a name="ln2733"> </a>
<a name="ln2734">	fUndoState.deleted = true;</a>
<a name="ln2735">	fUndoState.replaced = true;</a>
<a name="ln2736"> </a>
<a name="ln2737">	BTextView::DeleteText(start, finish);</a>
<a name="ln2738">	if (fSpellCheck &amp;&amp; IsEditable()) {</a>
<a name="ln2739">		UpdateSpellMarks(start, start - finish);</a>
<a name="ln2740"> </a>
<a name="ln2741">		int32 s, e;</a>
<a name="ln2742">		FindSpellBoundry(1, start, &amp;s, &amp;e);</a>
<a name="ln2743">		CheckSpelling(s, e);</a>
<a name="ln2744">	}</a>
<a name="ln2745">}</a>
<a name="ln2746"> </a>
<a name="ln2747"> </a>
<a name="ln2748">void</a>
<a name="ln2749">TTextView::ContentChanged(void)</a>
<a name="ln2750">{</a>
<a name="ln2751">	BLooper *looper = Looper();</a>
<a name="ln2752">	if (looper == NULL)</a>
<a name="ln2753">		return;</a>
<a name="ln2754"> </a>
<a name="ln2755">	BMessage msg(FIELD_CHANGED);</a>
<a name="ln2756">	msg.AddInt32(&quot;bitmask&quot;, FIELD_BODY);</a>
<a name="ln2757">	msg.AddPointer(&quot;source&quot;, this);</a>
<a name="ln2758">	looper-&gt;PostMessage(&amp;msg);</a>
<a name="ln2759">}</a>
<a name="ln2760"> </a>
<a name="ln2761"> </a>
<a name="ln2762">void</a>
<a name="ln2763">TTextView::CheckSpelling(int32 start, int32 end, int32 flags)</a>
<a name="ln2764">{</a>
<a name="ln2765">	const char 	*text = Text();</a>
<a name="ln2766">	const char 	*next, *endPtr, *word = NULL;</a>
<a name="ln2767">	int32 		wordLength = 0, wordOffset;</a>
<a name="ln2768">	int32		nextHighlight = start;</a>
<a name="ln2769">	BString 	testWord;</a>
<a name="ln2770">	bool		isCap = false;</a>
<a name="ln2771">	bool		isAlpha;</a>
<a name="ln2772">	bool		isApost;</a>
<a name="ln2773"> </a>
<a name="ln2774">	for (next = text + start, endPtr = text + end; next &lt;= endPtr; next++) {</a>
<a name="ln2775">		//printf(&quot;next=%c\n&quot;, *next);</a>
<a name="ln2776">		// ToDo: this has to be refined to other languages...</a>
<a name="ln2777">		// Alpha signifies the start of a word</a>
<a name="ln2778">		isAlpha = isalpha(*next);</a>
<a name="ln2779">		isApost = (*next == '\'');</a>
<a name="ln2780">		if (!word &amp;&amp; isAlpha) {</a>
<a name="ln2781">			//printf(&quot;Found word start\n&quot;);</a>
<a name="ln2782">			word = next;</a>
<a name="ln2783">			wordLength++;</a>
<a name="ln2784">			isCap = isupper(*word);</a>
<a name="ln2785">		} else if (word &amp;&amp; (isAlpha || isApost) &amp;&amp; !(isApost &amp;&amp; !isalpha(next[1]))</a>
<a name="ln2786">					&amp;&amp; !(isCap &amp;&amp; isApost &amp;&amp; (next[1] == 's'))) {</a>
<a name="ln2787">			// Word continues check</a>
<a name="ln2788">			wordLength++;</a>
<a name="ln2789">			//printf(&quot;Word continues...\n&quot;);</a>
<a name="ln2790">		} else if (word) {</a>
<a name="ln2791">			// End of word reached</a>
<a name="ln2792"> </a>
<a name="ln2793">			//printf(&quot;Word End\n&quot;);</a>
<a name="ln2794">			// Don't check single characters</a>
<a name="ln2795">			if (wordLength &gt; 1) {</a>
<a name="ln2796">				bool isUpper = true;</a>
<a name="ln2797"> </a>
<a name="ln2798">				// Look for all uppercase</a>
<a name="ln2799">				for (int32 i = 0; i &lt; wordLength; i++) {</a>
<a name="ln2800">					if (word[i] == '\'')</a>
<a name="ln2801">						break;</a>
<a name="ln2802"> </a>
<a name="ln2803">					if (islower(word[i])) {</a>
<a name="ln2804">						isUpper = false;</a>
<a name="ln2805">						break;</a>
<a name="ln2806">					}</a>
<a name="ln2807">				}</a>
<a name="ln2808"> </a>
<a name="ln2809">				// Don't check all uppercase words</a>
<a name="ln2810">				if (!isUpper) {</a>
<a name="ln2811">					bool foundMatch = false;</a>
<a name="ln2812">					wordOffset = word - text;</a>
<a name="ln2813">					testWord.SetTo(word, wordLength);</a>
<a name="ln2814"> </a>
<a name="ln2815">					testWord = testWord.ToLower();</a>
<a name="ln2816">					DSPELL(printf(&quot;Testing: \&quot;%s\&quot;\n&quot;, testWord.String()));</a>
<a name="ln2817"> </a>
<a name="ln2818">					int32 key = -1;</a>
<a name="ln2819">					if (gDictCount)</a>
<a name="ln2820">						key = gExactWords[0]-&gt;GetKey(testWord.String());</a>
<a name="ln2821"> </a>
<a name="ln2822">					// Search all dictionaries</a>
<a name="ln2823">					for (int32 i = 0; i &lt; gDictCount; i++) {</a>
<a name="ln2824">						if (gExactWords[i]-&gt;Lookup(key) &gt;= 0) {</a>
<a name="ln2825">							foundMatch = true;</a>
<a name="ln2826">							break;</a>
<a name="ln2827">						}</a>
<a name="ln2828">					}</a>
<a name="ln2829"> </a>
<a name="ln2830">					if (!foundMatch) {</a>
<a name="ln2831">						if (flags &amp; S_CLEAR_ERRORS)</a>
<a name="ln2832">							RemoveSpellMark(nextHighlight, wordOffset);</a>
<a name="ln2833"> </a>
<a name="ln2834">						if (flags &amp; S_SHOW_ERRORS)</a>
<a name="ln2835">							AddSpellMark(wordOffset, wordOffset + wordLength);</a>
<a name="ln2836">					} else if (flags &amp; S_CLEAR_ERRORS)</a>
<a name="ln2837">						RemoveSpellMark(nextHighlight, wordOffset + wordLength);</a>
<a name="ln2838"> </a>
<a name="ln2839">					nextHighlight = wordOffset + wordLength;</a>
<a name="ln2840">				}</a>
<a name="ln2841">			}</a>
<a name="ln2842">			// Reset state to looking for word</a>
<a name="ln2843">			word = NULL;</a>
<a name="ln2844">			wordLength = 0;</a>
<a name="ln2845">		}</a>
<a name="ln2846">	}</a>
<a name="ln2847"> </a>
<a name="ln2848">	if (nextHighlight &lt;= end</a>
<a name="ln2849">		&amp;&amp; (flags &amp; S_CLEAR_ERRORS) != 0</a>
<a name="ln2850">		&amp;&amp; nextHighlight &lt; TextLength())</a>
<a name="ln2851">		SetFontAndColor(nextHighlight, end, NULL, B_FONT_ALL, &amp;kNormalTextColor);</a>
<a name="ln2852">}</a>
<a name="ln2853"> </a>
<a name="ln2854"> </a>
<a name="ln2855">void</a>
<a name="ln2856">TTextView::FindSpellBoundry(int32 length, int32 offset, int32 *_start, int32 *_end)</a>
<a name="ln2857">{</a>
<a name="ln2858">	int32 start, end, textLength;</a>
<a name="ln2859">	const char *text = Text();</a>
<a name="ln2860">	textLength = TextLength();</a>
<a name="ln2861"> </a>
<a name="ln2862">	for (start = offset - 1; start &gt;= 0</a>
<a name="ln2863">		&amp;&amp; (isalpha(text[start]) || text[start] == '\''); start--) {}</a>
<a name="ln2864"> </a>
<a name="ln2865">	start++;</a>
<a name="ln2866"> </a>
<a name="ln2867">	for (end = offset + length; end &lt; textLength</a>
<a name="ln2868">		&amp;&amp; (isalpha(text[end]) || text[end] == '\''); end++) {}</a>
<a name="ln2869"> </a>
<a name="ln2870">	*_start = start;</a>
<a name="ln2871">	*_end = end;</a>
<a name="ln2872">}</a>
<a name="ln2873"> </a>
<a name="ln2874"> </a>
<a name="ln2875">TTextView::spell_mark *</a>
<a name="ln2876">TTextView::FindSpellMark(int32 start, int32 end, spell_mark **_previousMark)</a>
<a name="ln2877">{</a>
<a name="ln2878">	spell_mark *lastMark = NULL;</a>
<a name="ln2879"> </a>
<a name="ln2880">	for (spell_mark *spellMark = fFirstSpellMark; spellMark; spellMark = spellMark-&gt;next) {</a>
<a name="ln2881">		if (spellMark-&gt;start &lt; end &amp;&amp; spellMark-&gt;end &gt; start) {</a>
<a name="ln2882">			if (_previousMark)</a>
<a name="ln2883">				*_previousMark = lastMark;</a>
<a name="ln2884">			return spellMark;</a>
<a name="ln2885">		}</a>
<a name="ln2886"> </a>
<a name="ln2887">		lastMark = spellMark;</a>
<a name="ln2888">	}</a>
<a name="ln2889">	return NULL;</a>
<a name="ln2890">}</a>
<a name="ln2891"> </a>
<a name="ln2892"> </a>
<a name="ln2893">void</a>
<a name="ln2894">TTextView::UpdateSpellMarks(int32 offset, int32 length)</a>
<a name="ln2895">{</a>
<a name="ln2896">	DSPELL(printf(&quot;UpdateSpellMarks: offset = %ld, length = %ld\n&quot;, offset, length));</a>
<a name="ln2897"> </a>
<a name="ln2898">	spell_mark *spellMark;</a>
<a name="ln2899">	for (spellMark = fFirstSpellMark; spellMark; spellMark = spellMark-&gt;next) {</a>
<a name="ln2900">		DSPELL(printf(&quot;\tfound: %ld - %ld\n&quot;, spellMark-&gt;start, spellMark-&gt;end));</a>
<a name="ln2901"> </a>
<a name="ln2902">		if (spellMark-&gt;end &lt; offset)</a>
<a name="ln2903">			continue;</a>
<a name="ln2904"> </a>
<a name="ln2905">		if (spellMark-&gt;start &gt; offset)</a>
<a name="ln2906">			spellMark-&gt;start += length;</a>
<a name="ln2907"> </a>
<a name="ln2908">		spellMark-&gt;end += length;</a>
<a name="ln2909"> </a>
<a name="ln2910">		DSPELL(printf(&quot;\t-&gt; reset: %ld - %ld\n&quot;, spellMark-&gt;start, spellMark-&gt;end));</a>
<a name="ln2911">	}</a>
<a name="ln2912">}</a>
<a name="ln2913"> </a>
<a name="ln2914"> </a>
<a name="ln2915">status_t</a>
<a name="ln2916">TTextView::AddSpellMark(int32 start, int32 end)</a>
<a name="ln2917">{</a>
<a name="ln2918">	DSPELL(printf(&quot;AddSpellMark: start = %ld, end = %ld\n&quot;, start, end));</a>
<a name="ln2919"> </a>
<a name="ln2920">	// check if there is already a mark for this passage</a>
<a name="ln2921">	spell_mark *spellMark = FindSpellMark(start, end);</a>
<a name="ln2922">	if (spellMark) {</a>
<a name="ln2923">		if (spellMark-&gt;start == start &amp;&amp; spellMark-&gt;end == end) {</a>
<a name="ln2924">			DSPELL(printf(&quot;\tfound one\n&quot;));</a>
<a name="ln2925">			return B_OK;</a>
<a name="ln2926">		}</a>
<a name="ln2927"> </a>
<a name="ln2928">		DSPELL(printf(&quot;\tremove old one\n&quot;));</a>
<a name="ln2929">		RemoveSpellMark(start, end);</a>
<a name="ln2930">	}</a>
<a name="ln2931"> </a>
<a name="ln2932">	spellMark = (spell_mark *)malloc(sizeof(spell_mark));</a>
<a name="ln2933">	if (spellMark == NULL)</a>
<a name="ln2934">		return B_NO_MEMORY;</a>
<a name="ln2935"> </a>
<a name="ln2936">	spellMark-&gt;start = start;</a>
<a name="ln2937">	spellMark-&gt;end = end;</a>
<a name="ln2938">	spellMark-&gt;style = RunArray(start, end);</a>
<a name="ln2939"> </a>
<a name="ln2940">	// set the spell marks appearance</a>
<a name="ln2941">	BFont font(fFont);</a>
<a name="ln2942">	font.SetFace(B_BOLD_FACE | B_ITALIC_FACE);</a>
<a name="ln2943">	SetFontAndColor(start, end, &amp;font, B_FONT_ALL, &amp;kSpellTextColor);</a>
<a name="ln2944"> </a>
<a name="ln2945">	// add it to the queue</a>
<a name="ln2946">	spellMark-&gt;next = fFirstSpellMark;</a>
<a name="ln2947">	fFirstSpellMark = spellMark;</a>
<a name="ln2948"> </a>
<a name="ln2949">	return B_OK;</a>
<a name="ln2950">}</a>
<a name="ln2951"> </a>
<a name="ln2952"> </a>
<a name="ln2953">bool</a>
<a name="ln2954">TTextView::RemoveSpellMark(int32 start, int32 end)</a>
<a name="ln2955">{</a>
<a name="ln2956">	DSPELL(printf(&quot;RemoveSpellMark: start = %ld, end = %ld\n&quot;, start, end));</a>
<a name="ln2957"> </a>
<a name="ln2958">	// find spell mark</a>
<a name="ln2959">	spell_mark *lastMark = NULL;</a>
<a name="ln2960">	spell_mark *spellMark = FindSpellMark(start, end, &amp;lastMark);</a>
<a name="ln2961">	if (spellMark == NULL) {</a>
<a name="ln2962">		DSPELL(printf(&quot;\tnot found!\n&quot;));</a>
<a name="ln2963">		return false;</a>
<a name="ln2964">	}</a>
<a name="ln2965"> </a>
<a name="ln2966">	DSPELL(printf(&quot;\tfound: %ld - %ld\n&quot;, spellMark-&gt;start, spellMark-&gt;end));</a>
<a name="ln2967"> </a>
<a name="ln2968">	// dequeue the spell mark</a>
<a name="ln2969">	if (lastMark)</a>
<a name="ln2970">		lastMark-&gt;next = spellMark-&gt;next;</a>
<a name="ln2971">	else</a>
<a name="ln2972">		fFirstSpellMark = spellMark-&gt;next;</a>
<a name="ln2973"> </a>
<a name="ln2974">	if (spellMark-&gt;start &lt; start)</a>
<a name="ln2975">		start = spellMark-&gt;start;</a>
<a name="ln2976">	if (spellMark-&gt;end &gt; end)</a>
<a name="ln2977">		end = spellMark-&gt;end;</a>
<a name="ln2978"> </a>
<a name="ln2979">	// reset old text run array</a>
<a name="ln2980">	SetRunArray(start, end, spellMark-&gt;style);</a>
<a name="ln2981"> </a>
<a name="ln2982">	free(spellMark-&gt;style);</a>
<a name="ln2983">	free(spellMark);</a>
<a name="ln2984"> </a>
<a name="ln2985">	return true;</a>
<a name="ln2986">}</a>
<a name="ln2987"> </a>
<a name="ln2988"> </a>
<a name="ln2989">void</a>
<a name="ln2990">TTextView::RemoveSpellMarks()</a>
<a name="ln2991">{</a>
<a name="ln2992">	spell_mark *spellMark, *nextMark;</a>
<a name="ln2993"> </a>
<a name="ln2994">	for (spellMark = fFirstSpellMark; spellMark; spellMark = nextMark) {</a>
<a name="ln2995">		nextMark = spellMark-&gt;next;</a>
<a name="ln2996"> </a>
<a name="ln2997">		// reset old text run array</a>
<a name="ln2998">		SetRunArray(spellMark-&gt;start, spellMark-&gt;end, spellMark-&gt;style);</a>
<a name="ln2999"> </a>
<a name="ln3000">		free(spellMark-&gt;style);</a>
<a name="ln3001">		free(spellMark);</a>
<a name="ln3002">	}</a>
<a name="ln3003"> </a>
<a name="ln3004">	fFirstSpellMark = NULL;</a>
<a name="ln3005">}</a>
<a name="ln3006"> </a>
<a name="ln3007"> </a>
<a name="ln3008">void</a>
<a name="ln3009">TTextView::EnableSpellCheck(bool enable)</a>
<a name="ln3010">{</a>
<a name="ln3011">	if (fSpellCheck == enable)</a>
<a name="ln3012">		return;</a>
<a name="ln3013"> </a>
<a name="ln3014">	fSpellCheck = enable;</a>
<a name="ln3015">	int32 textLength = TextLength();</a>
<a name="ln3016">	if (fSpellCheck) {</a>
<a name="ln3017">		// work-around for a bug in the BTextView class</a>
<a name="ln3018">		// which causes lots of flicker</a>
<a name="ln3019">		int32 start, end;</a>
<a name="ln3020">		GetSelection(&amp;start, &amp;end);</a>
<a name="ln3021">		if (start != end)</a>
<a name="ln3022">			Select(start, start);</a>
<a name="ln3023"> </a>
<a name="ln3024">		CheckSpelling(0, textLength);</a>
<a name="ln3025"> </a>
<a name="ln3026">		if (start != end)</a>
<a name="ln3027">			Select(start, end);</a>
<a name="ln3028">	}</a>
<a name="ln3029">	else</a>
<a name="ln3030">		RemoveSpellMarks();</a>
<a name="ln3031">}</a>
<a name="ln3032"> </a>
<a name="ln3033"> </a>
<a name="ln3034">void</a>
<a name="ln3035">TTextView::WindowActivated(bool flag)</a>
<a name="ln3036">{</a>
<a name="ln3037">	if (!flag) {</a>
<a name="ln3038">		// WindowActivated(false) は、IM も Inactive になり、そのまま確定される。</a>
<a name="ln3039">		// しかしこの場合、input_server が B_INPUT_METHOD_EVENT(B_INPUT_METHOD_STOPPED)</a>
<a name="ln3040">		// を送ってこないまま矛盾してしまうので、やむを得ずここでつじつまあわせ処理している。</a>
<a name="ln3041">		// OpenBeOSで修正されることを願って暫定処置としている。</a>
<a name="ln3042">		fInputMethodUndoState.active = false;</a>
<a name="ln3043">		// fInputMethodUndoBufferに溜まっている最後のデータがK_INSERTEDなら（確定）正規のバッファへ追加</a>
<a name="ln3044">		if (fInputMethodUndoBuffer.CountItems() &gt; 0) {</a>
<a name="ln3045">			KUndoItem *item = fInputMethodUndoBuffer.ItemAt(fInputMethodUndoBuffer.CountItems() - 1);</a>
<a name="ln3046">			if (item-&gt;History == K_INSERTED) {</a>
<a name="ln3047">				fUndoBuffer.MakeNewUndoItem();</a>
<a name="ln3048">				fUndoBuffer.AddUndo(item-&gt;RedoText, item-&gt;Length, item-&gt;Offset,</a>
<a name="ln3049">					item-&gt;History, item-&gt;CursorPos);</a>
<a name="ln3050">				fUndoBuffer.MakeNewUndoItem();</a>
<a name="ln3051">			}</a>
<a name="ln3052">			fInputMethodUndoBuffer.MakeEmpty();</a>
<a name="ln3053">		}</a>
<a name="ln3054">	}</a>
<a name="ln3055">	BTextView::WindowActivated(flag);</a>
<a name="ln3056">}</a>
<a name="ln3057"> </a>
<a name="ln3058"> </a>
<a name="ln3059">void</a>
<a name="ln3060">TTextView::AddQuote(int32 start, int32 finish)</a>
<a name="ln3061">{</a>
<a name="ln3062">	BRect rect = Bounds();</a>
<a name="ln3063"> </a>
<a name="ln3064">	int32 lineStart;</a>
<a name="ln3065">	GoToLine(CurrentLine());</a>
<a name="ln3066">	GetSelection(&amp;lineStart, &amp;lineStart);</a>
<a name="ln3067">	lineStart = LineStart(lineStart);</a>
<a name="ln3068"> </a>
<a name="ln3069">	// make sure that we're changing the whole last line, too</a>
<a name="ln3070">	int32 lineEnd = finish &gt; lineStart ? finish - 1 : finish;</a>
<a name="ln3071">	{</a>
<a name="ln3072">		const char *text = Text();</a>
<a name="ln3073">		while (text[lineEnd] &amp;&amp; text[lineEnd] != '\n')</a>
<a name="ln3074">			lineEnd++;</a>
<a name="ln3075">	}</a>
<a name="ln3076">	Select(lineStart, lineEnd);</a>
<a name="ln3077"> </a>
<a name="ln3078">	int32 textLength = lineEnd - lineStart;</a>
<a name="ln3079">	char *text = (char *)malloc(textLength + 1);</a>
<a name="ln3080">	if (text == NULL)</a>
<a name="ln3081">		return;</a>
<a name="ln3082"> </a>
<a name="ln3083">	GetText(lineStart, textLength, text);</a>
<a name="ln3084"> </a>
<a name="ln3085">	int32 quoteLength = strlen(QUOTE);</a>
<a name="ln3086">	int32 targetLength = 0;</a>
<a name="ln3087">	char *target = NULL;</a>
<a name="ln3088">	int32 lastLine = 0;</a>
<a name="ln3089"> </a>
<a name="ln3090">	for (int32 index = 0; index &lt; textLength; index++) {</a>
<a name="ln3091">		if (text[index] == '\n' || index == textLength - 1) {</a>
<a name="ln3092">			// add quote to this line</a>
<a name="ln3093">			int32 lineLength = index - lastLine + 1;</a>
<a name="ln3094"> </a>
<a name="ln3095">			char* newTarget = (char *)realloc(target,</a>
<a name="ln3096">				targetLength + lineLength + quoteLength);</a>
<a name="ln3097">			if (newTarget == NULL) {</a>
<a name="ln3098">				// free the old buffer</a>
<a name="ln3099">				free(target);</a>
<a name="ln3100">				target = NULL;</a>
<a name="ln3101">				free(text);</a>
<a name="ln3102">				return;</a>
<a name="ln3103">			} else {</a>
<a name="ln3104">				target = newTarget;</a>
<a name="ln3105">			}</a>
<a name="ln3106"> </a>
<a name="ln3107">			// copy the quote sign</a>
<a name="ln3108">			memcpy(&amp;target[targetLength], QUOTE, quoteLength);</a>
<a name="ln3109">			targetLength += quoteLength;</a>
<a name="ln3110"> </a>
<a name="ln3111">			// copy the rest of the line</a>
<a name="ln3112">			memcpy(&amp;target[targetLength], &amp;text[lastLine], lineLength);</a>
<a name="ln3113">			targetLength += lineLength;</a>
<a name="ln3114"> </a>
<a name="ln3115">			lastLine = index + 1;</a>
<a name="ln3116">		}</a>
<a name="ln3117">	}</a>
<a name="ln3118"> </a>
<a name="ln3119">	// replace with quoted text</a>
<a name="ln3120">	free(text);</a>
<a name="ln3121">	Delete();</a>
<a name="ln3122"> </a>
<a name="ln3123">	if (fColoredQuotes) {</a>
<a name="ln3124">		const BFont *font = Font();</a>
<a name="ln3125">		TextRunArray style(targetLength / 8 + 8);</a>
<a name="ln3126"> </a>
<a name="ln3127">		FillInQuoteTextRuns(NULL, NULL, target, targetLength, font,</a>
<a name="ln3128">			&amp;style.Array(), style.MaxEntries());</a>
<a name="ln3129">		Insert(target, targetLength, &amp;style.Array());</a>
<a name="ln3130">	} else</a>
<a name="ln3131">		Insert(target, targetLength);</a>
<a name="ln3132"> </a>
<a name="ln3133">	free(target);</a>
<a name="ln3134"> </a>
<a name="ln3135">	// redo the old selection (compute the new start if necessary)</a>
<a name="ln3136">	Select(start + quoteLength, finish + (targetLength - textLength));</a>
<a name="ln3137"> </a>
<a name="ln3138">	ScrollTo(rect.LeftTop());</a>
<a name="ln3139">}</a>
<a name="ln3140"> </a>
<a name="ln3141"> </a>
<a name="ln3142">void</a>
<a name="ln3143">TTextView::RemoveQuote(int32 start, int32 finish)</a>
<a name="ln3144">{</a>
<a name="ln3145">	BRect rect = Bounds();</a>
<a name="ln3146"> </a>
<a name="ln3147">	GoToLine(CurrentLine());</a>
<a name="ln3148">	int32 lineStart;</a>
<a name="ln3149">	GetSelection(&amp;lineStart, &amp;lineStart);</a>
<a name="ln3150">	lineStart = LineStart(lineStart);</a>
<a name="ln3151"> </a>
<a name="ln3152">	// make sure that we're changing the whole last line, too</a>
<a name="ln3153">	int32 lineEnd = finish &gt; lineStart ? finish - 1 : finish;</a>
<a name="ln3154">	const char *text = Text();</a>
<a name="ln3155">	while (text[lineEnd] &amp;&amp; text[lineEnd] != '\n')</a>
<a name="ln3156">		lineEnd++;</a>
<a name="ln3157"> </a>
<a name="ln3158">	Select(lineStart, lineEnd);</a>
<a name="ln3159"> </a>
<a name="ln3160">	int32 length = lineEnd - lineStart;</a>
<a name="ln3161">	char *target = (char *)malloc(length + 1);</a>
<a name="ln3162">	if (target == NULL)</a>
<a name="ln3163">		return;</a>
<a name="ln3164"> </a>
<a name="ln3165">	int32 quoteLength = strlen(QUOTE);</a>
<a name="ln3166">	int32 removed = 0;</a>
<a name="ln3167">	text += lineStart;</a>
<a name="ln3168"> </a>
<a name="ln3169">	for (int32 index = 0; index &lt; length;) {</a>
<a name="ln3170">		// find out the length of the current line</a>
<a name="ln3171">		int32 lineLength = 0;</a>
<a name="ln3172">		while (index + lineLength &lt; length &amp;&amp; text[lineLength] != '\n')</a>
<a name="ln3173">			lineLength++;</a>
<a name="ln3174"> </a>
<a name="ln3175">		// include the newline to be part of this line</a>
<a name="ln3176">		if (text[lineLength] == '\n' &amp;&amp; index + lineLength + 1 &lt; length)</a>
<a name="ln3177">			lineLength++;</a>
<a name="ln3178"> </a>
<a name="ln3179">		if (!strncmp(text, QUOTE, quoteLength)) {</a>
<a name="ln3180">			// remove quote</a>
<a name="ln3181">			length -= quoteLength;</a>
<a name="ln3182">			removed += quoteLength;</a>
<a name="ln3183"> </a>
<a name="ln3184">			lineLength -= quoteLength;</a>
<a name="ln3185">			text += quoteLength;</a>
<a name="ln3186">		}</a>
<a name="ln3187"> </a>
<a name="ln3188">		if (lineLength == 0) {</a>
<a name="ln3189">			target[index] = '\0';</a>
<a name="ln3190">			break;</a>
<a name="ln3191">		}</a>
<a name="ln3192"> </a>
<a name="ln3193">		memcpy(&amp;target[index], text, lineLength);</a>
<a name="ln3194"> </a>
<a name="ln3195">		text += lineLength;</a>
<a name="ln3196">		index += lineLength;</a>
<a name="ln3197">	}</a>
<a name="ln3198"> </a>
<a name="ln3199">	if (removed) {</a>
<a name="ln3200">		Delete();</a>
<a name="ln3201"> </a>
<a name="ln3202">		if (fColoredQuotes) {</a>
<a name="ln3203">			const BFont *font = Font();</a>
<a name="ln3204">			TextRunArray style(length / 8 + 8);</a>
<a name="ln3205"> </a>
<a name="ln3206">			FillInQuoteTextRuns(NULL, NULL, target, length, font,</a>
<a name="ln3207">				&amp;style.Array(), style.MaxEntries());</a>
<a name="ln3208">			Insert(target, length, &amp;style.Array());</a>
<a name="ln3209">		} else</a>
<a name="ln3210">			Insert(target, length);</a>
<a name="ln3211"> </a>
<a name="ln3212">		// redo old selection</a>
<a name="ln3213">		bool noSelection = start == finish;</a>
<a name="ln3214"> </a>
<a name="ln3215">		if (start &gt; lineStart + quoteLength)</a>
<a name="ln3216">			start -= quoteLength;</a>
<a name="ln3217">		else</a>
<a name="ln3218">			start = lineStart;</a>
<a name="ln3219"> </a>
<a name="ln3220">		if (noSelection)</a>
<a name="ln3221">			finish = start;</a>
<a name="ln3222">		else</a>
<a name="ln3223">			finish -= removed;</a>
<a name="ln3224">	}</a>
<a name="ln3225"> </a>
<a name="ln3226">	free(target);</a>
<a name="ln3227"> </a>
<a name="ln3228">	Select(start, finish);</a>
<a name="ln3229">	ScrollTo(rect.LeftTop());</a>
<a name="ln3230">}</a>
<a name="ln3231"> </a>
<a name="ln3232"> </a>
<a name="ln3233">int32</a>
<a name="ln3234">TTextView::LineStart(int32 offset)</a>
<a name="ln3235">{</a>
<a name="ln3236">	if (offset &lt;= 0)</a>
<a name="ln3237">		return 0;</a>
<a name="ln3238"> </a>
<a name="ln3239">	while (offset &gt; 0) {</a>
<a name="ln3240">		offset = PreviousByte(offset);</a>
<a name="ln3241">		if (ByteAt(offset) == B_ENTER)</a>
<a name="ln3242">			return offset + 1;</a>
<a name="ln3243">	}</a>
<a name="ln3244"> </a>
<a name="ln3245">	return offset;</a>
<a name="ln3246">}</a>
<a name="ln3247"> </a>
<a name="ln3248"> </a>
<a name="ln3249">int32</a>
<a name="ln3250">TTextView::PreviousByte(int32 offset) const</a>
<a name="ln3251">{</a>
<a name="ln3252">	if (offset &lt;= 0)</a>
<a name="ln3253">		return 0;</a>
<a name="ln3254"> </a>
<a name="ln3255">	int32 count = 6;</a>
<a name="ln3256"> </a>
<a name="ln3257">	for (--offset; offset &gt; 0 &amp;&amp; count; --offset, --count) {</a>
<a name="ln3258">		if ((ByteAt(offset) &amp; 0xC0) != 0x80)</a>
<a name="ln3259">			break;</a>
<a name="ln3260">	}</a>
<a name="ln3261"> </a>
<a name="ln3262">	return count ? offset : 0;</a>
<a name="ln3263">}</a>
<a name="ln3264"> </a>
<a name="ln3265"> </a>
<a name="ln3266">void</a>
<a name="ln3267">TTextView::Undo(BClipboard */*clipboard*/)</a>
<a name="ln3268">{</a>
<a name="ln3269">	if (fInputMethodUndoState.active)</a>
<a name="ln3270">		return;</a>
<a name="ln3271"> </a>
<a name="ln3272">	int32 length, offset, cursorPos;</a>
<a name="ln3273">	undo_type history;</a>
<a name="ln3274">	char *text;</a>
<a name="ln3275">	status_t status;</a>
<a name="ln3276"> </a>
<a name="ln3277">	status = fUndoBuffer.Undo(&amp;text, &amp;length, &amp;offset, &amp;history, &amp;cursorPos);</a>
<a name="ln3278">	if (status == B_OK) {</a>
<a name="ln3279">		fUndoBuffer.Off();</a>
<a name="ln3280"> </a>
<a name="ln3281">		switch (history) {</a>
<a name="ln3282">			case K_INSERTED:</a>
<a name="ln3283">				BTextView::Delete(offset, offset + length);</a>
<a name="ln3284">				Select(offset, offset);</a>
<a name="ln3285">				break;</a>
<a name="ln3286"> </a>
<a name="ln3287">			case K_DELETED:</a>
<a name="ln3288">				BTextView::Insert(offset, text, length);</a>
<a name="ln3289">				Select(offset, offset + length);</a>
<a name="ln3290">				break;</a>
<a name="ln3291"> </a>
<a name="ln3292">			case K_REPLACED:</a>
<a name="ln3293">				BTextView::Delete(offset, offset + length);</a>
<a name="ln3294">				status = fUndoBuffer.Undo(&amp;text, &amp;length, &amp;offset, &amp;history, &amp;cursorPos);</a>
<a name="ln3295">				if (status == B_OK &amp;&amp; history == K_DELETED) {</a>
<a name="ln3296">					BTextView::Insert(offset, text, length);</a>
<a name="ln3297">					Select(offset, offset + length);</a>
<a name="ln3298">				} else {</a>
<a name="ln3299">					::beep();</a>
<a name="ln3300">					BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln3301">						B_TRANSLATE(&quot;Inconsistency occurred in the undo/redo &quot;</a>
<a name="ln3302">							&quot;buffer.&quot;),	B_TRANSLATE(&quot;OK&quot;));</a>
<a name="ln3303">					alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln3304">					alert-&gt;Go();</a>
<a name="ln3305">				}</a>
<a name="ln3306">				break;</a>
<a name="ln3307">		}</a>
<a name="ln3308">		ScrollToSelection();</a>
<a name="ln3309">		ContentChanged();</a>
<a name="ln3310">		fUndoBuffer.On();</a>
<a name="ln3311">	}</a>
<a name="ln3312">}</a>
<a name="ln3313"> </a>
<a name="ln3314"> </a>
<a name="ln3315">void</a>
<a name="ln3316">TTextView::Redo()</a>
<a name="ln3317">{</a>
<a name="ln3318">	if (fInputMethodUndoState.active)</a>
<a name="ln3319">		return;</a>
<a name="ln3320"> </a>
<a name="ln3321">	int32 length, offset, cursorPos;</a>
<a name="ln3322">	undo_type history;</a>
<a name="ln3323">	char *text;</a>
<a name="ln3324">	status_t status;</a>
<a name="ln3325">	bool replaced;</a>
<a name="ln3326"> </a>
<a name="ln3327">	status = fUndoBuffer.Redo(&amp;text, &amp;length, &amp;offset, &amp;history, &amp;cursorPos, &amp;replaced);</a>
<a name="ln3328">	if (status == B_OK) {</a>
<a name="ln3329">		fUndoBuffer.Off();</a>
<a name="ln3330"> </a>
<a name="ln3331">		switch (history) {</a>
<a name="ln3332">			case K_INSERTED:</a>
<a name="ln3333">				BTextView::Insert(offset, text, length);</a>
<a name="ln3334">				Select(offset, offset + length);</a>
<a name="ln3335">				break;</a>
<a name="ln3336"> </a>
<a name="ln3337">			case K_DELETED:</a>
<a name="ln3338">				BTextView::Delete(offset, offset + length);</a>
<a name="ln3339">				if (replaced) {</a>
<a name="ln3340">					fUndoBuffer.Redo(&amp;text, &amp;length, &amp;offset, &amp;history, &amp;cursorPos, &amp;replaced);</a>
<a name="ln3341">					BTextView::Insert(offset, text, length);</a>
<a name="ln3342">				}</a>
<a name="ln3343">				Select(offset, offset + length);</a>
<a name="ln3344">				break;</a>
<a name="ln3345"> </a>
<a name="ln3346">			case K_REPLACED:</a>
<a name="ln3347">				::beep();</a>
<a name="ln3348">				BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln3349">					B_TRANSLATE(&quot;Inconsistency occurred in the undo/redo &quot;</a>
<a name="ln3350">						&quot;buffer.&quot;),	B_TRANSLATE(&quot;OK&quot;));</a>
<a name="ln3351">				alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln3352">				alert-&gt;Go();</a>
<a name="ln3353">				break;</a>
<a name="ln3354">		}</a>
<a name="ln3355">		ScrollToSelection();</a>
<a name="ln3356">		ContentChanged();</a>
<a name="ln3357">		fUndoBuffer.On();</a>
<a name="ln3358">	}</a>
<a name="ln3359">}</a>

</code></pre>
<div class="balloon" rel="2345"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v630/" target="_blank">V630</a> The 'malloc' function is used to allocate memory for an array of objects which are classes containing constructors and destructors.</p></div>
<div class="balloon" rel="2265"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v630/" target="_blank">V630</a> The 'malloc' function is used to allocate memory for an array of objects which are classes containing constructors and destructors.</p></div>
<div class="balloon" rel="2235"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v630/" target="_blank">V630</a> The 'malloc' function is used to allocate memory for an array of objects which are classes containing constructors and destructors.</p></div>
<div class="balloon" rel="771"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="1826"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="2285"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'type.Type()' pointer was utilized before it was verified against nullptr. Check lines: 2285, 2289.</p></div>
<div class="balloon" rel="1979"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="3305"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
