
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>CP_setup.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">	Copyright (c) 2002, Thomas Kurschel</a>
<a name="ln3"> </a>
<a name="ln4"> </a>
<a name="ln5">	Part of Radeon accelerant</a>
<a name="ln6"> </a>
<a name="ln7">	CP initialization/sync/cleanup.</a>
<a name="ln8"> </a>
<a name="ln9">	It also handles command buffer synchronization.</a>
<a name="ln10"> </a>
<a name="ln11">	non-local memory is used as following:</a>
<a name="ln12">	- 2048 dwords for ring buffer</a>
<a name="ln13">	- 253 indirect buffers a 4k (1024 dwords)</a>
<a name="ln14">	- 8 dwords for returned data (i.e. current read ptr)</a>
<a name="ln15">	  &amp; 6 dwords for &quot;scratch registers&quot;</a>
<a name="ln16"> </a>
<a name="ln17">	usage of scratch registers:</a>
<a name="ln18">	- reg 0 = reached engine.count</a>
<a name="ln19"> </a>
<a name="ln20">	with a granularity of 4 KByte, we need 2+253+1=256 blocks, which is exactly 1 MB</a>
<a name="ln21">*/</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;radeon_driver.h&quot;</a>
<a name="ln24">#include &quot;CPMicroCode.h&quot;</a>
<a name="ln25">#include &quot;mmio.h&quot;</a>
<a name="ln26">#include &quot;cp_regs.h&quot;</a>
<a name="ln27">#include &quot;pll_regs.h&quot;</a>
<a name="ln28">#include &quot;rbbm_regs.h&quot;</a>
<a name="ln29">#include &quot;buscntrl_regs.h&quot;</a>
<a name="ln30">#include &quot;config_regs.h&quot;</a>
<a name="ln31">#include &quot;memcntrl_regs.h&quot;</a>
<a name="ln32">#include &quot;utils.h&quot;</a>
<a name="ln33">#include &quot;pll_access.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &quot;log_coll.h&quot;</a>
<a name="ln36">#include &quot;log_enum.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">#include &lt;string.h&gt;</a>
<a name="ln39"> </a>
<a name="ln40">#if 0</a>
<a name="ln41"> </a>
<a name="ln42">// macros for user-space</a>
<a name="ln43"> </a>
<a name="ln44">#define ALLOC_MEM( asize, mem_type, aglobal, handle, offset ) \</a>
<a name="ln45">	{ \</a>
<a name="ln46">		radeon_alloc_mem am; \</a>
<a name="ln47">\</a>
<a name="ln48">		am.magic = RADEON_PRIVATE_DATA_MAGIC; \</a>
<a name="ln49">		am.size = (asize) * 4; \</a>
<a name="ln50">		am.memory_type = (mt_nonlocal); \</a>
<a name="ln51">		am.global = (aglobal); \</a>
<a name="ln52">\</a>
<a name="ln53">		res = ioctl( ai-&gt;fd, RADEON_ALLOC_MEM, &amp;am ); \</a>
<a name="ln54">		if( res == B_OK ) \</a>
<a name="ln55">			*(handle) = am.handle; \</a>
<a name="ln56">			*(offset) = am.offset; \</a>
<a name="ln57">	}</a>
<a name="ln58"> </a>
<a name="ln59">#define MEM2CPU( mem ) \</a>
<a name="ln60">	((uint32 *)(ai-&gt;mapped_memory[(mem).memory_type].data + (mem).offset))</a>
<a name="ln61"> </a>
<a name="ln62">#define MEM2GC( mem ) ((mem).offset + si-&gt;memory[(mem).memory_type].virtual_addr_start)</a>
<a name="ln63"> </a>
<a name="ln64">#define FREE_MEM( mem_type, handle ) \</a>
<a name="ln65">	{ \</a>
<a name="ln66">		radeon_free_mem fm; \</a>
<a name="ln67">\</a>
<a name="ln68">		fm.magic = RADEON_PRIVATE_DATA_MAGIC; \</a>
<a name="ln69">		fm.memory_type = mem_type; \</a>
<a name="ln70">		fm.handle = offset; \</a>
<a name="ln71">\</a>
<a name="ln72">		ioctl( ai-&gt;fd, RADEON_FREE_MEM, &amp;fm ); \</a>
<a name="ln73">	}</a>
<a name="ln74"> </a>
<a name="ln75">#else</a>
<a name="ln76"> </a>
<a name="ln77">// macros for kernel-space</a>
<a name="ln78"> </a>
<a name="ln79">// allocate memory</a>
<a name="ln80">// if memory_type is non-local, it is replaced with default non-local type</a>
<a name="ln81">#define ALLOC_MEM( asize, mem_type, aglobal, handle, offset ) \</a>
<a name="ln82">	if( mem_type == mt_nonlocal ) \</a>
<a name="ln83">		mem_type = di-&gt;si-&gt;nonlocal_type; \</a>
<a name="ln84">	res = mem_alloc( di-&gt;memmgr[mem_type], asize, NULL, handle, offset );</a>
<a name="ln85"> </a>
<a name="ln86">// get address as seen by program to access allocated memory</a>
<a name="ln87">// (memory_type must _not_ be non-local, see ALLOC_MEM)</a>
<a name="ln88">#define MEM2CPU( memory_type, offset ) \</a>
<a name="ln89">	((uint8 *)(memory_type == mt_local ? di-&gt;si-&gt;local_mem : \</a>
<a name="ln90">	(memory_type == mt_PCI ? di-&gt;pci_gart.buffer.ptr : di-&gt;agp_gart.buffer.ptr)) \</a>
<a name="ln91">	+ (offset))</a>
<a name="ln92"> </a>
<a name="ln93">// get graphics card's virtual address of allocated memory</a>
<a name="ln94">// (memory_type must _not_ be non-local, see ALLOC_MEM)</a>
<a name="ln95">#define MEM2GC( memory_type, offset ) \</a>
<a name="ln96">	(di-&gt;si-&gt;memory[(memory_type)].virtual_addr_start + (offset))</a>
<a name="ln97"> </a>
<a name="ln98">// free memory</a>
<a name="ln99">// if memory_type is non-local, it is replaced with default non-local type</a>
<a name="ln100">#define FREE_MEM( mem_type, handle ) \</a>
<a name="ln101">	mem_free( \</a>
<a name="ln102">		di-&gt;memmgr[ mem_type == mt_nonlocal ? di-&gt;si-&gt;nonlocal_type : mem_type], \</a>
<a name="ln103">		handle, NULL );</a>
<a name="ln104"> </a>
<a name="ln105">#endif</a>
<a name="ln106"> </a>
<a name="ln107"> </a>
<a name="ln108">void Radeon_DiscardAllIndirectBuffers( device_info *di );</a>
<a name="ln109"> </a>
<a name="ln110">#define RADEON_SCRATCH_REG_OFFSET	32</a>
<a name="ln111"> </a>
<a name="ln112"> </a>
<a name="ln113">void Radeon_FlushPixelCache( device_info *di );</a>
<a name="ln114"> </a>
<a name="ln115">// wait until engine is idle;</a>
<a name="ln116">// acquire_lock - 	true, if lock must be hold</a>
<a name="ln117">//					false, if lock is already acquired</a>
<a name="ln118">// keep_lock -		true, keep lock on exit (only valid if acquire_lock is true)</a>
<a name="ln119">void Radeon_WaitForIdle( device_info *di, bool acquire_lock, bool keep_lock )</a>
<a name="ln120">{</a>
<a name="ln121">	if( acquire_lock )</a>
<a name="ln122">		ACQUIRE_BEN( di-&gt;si-&gt;cp.lock );</a>
<a name="ln123"> </a>
<a name="ln124">	Radeon_WaitForFifo( di, 64 );</a>
<a name="ln125"> </a>
<a name="ln126">	while( 1 ) {</a>
<a name="ln127">		bigtime_t start_time = system_time();</a>
<a name="ln128"> </a>
<a name="ln129">		do {</a>
<a name="ln130">			if( (INREG( di-&gt;regs, RADEON_RBBM_STATUS ) &amp; RADEON_RBBM_ACTIVE) == 0 ) {</a>
<a name="ln131">				Radeon_FlushPixelCache( di );</a>
<a name="ln132"> </a>
<a name="ln133">				if( acquire_lock &amp;&amp; !keep_lock)</a>
<a name="ln134">					RELEASE_BEN( di-&gt;si-&gt;cp.lock );</a>
<a name="ln135"> </a>
<a name="ln136">				return;</a>
<a name="ln137">			}</a>
<a name="ln138"> </a>
<a name="ln139">			snooze( 1 );</a>
<a name="ln140">		} while( system_time() - start_time &lt; 1000000 );</a>
<a name="ln141"> </a>
<a name="ln142">		SHOW_ERROR( 3, &quot;Engine didn't become idle (rbbm_status=%lx, cp_stat=%lx, tlb_address=%lx, tlb_data=%lx)&quot;,</a>
<a name="ln143">			INREG( di-&gt;regs, RADEON_RBBM_STATUS ),</a>
<a name="ln144">			INREG( di-&gt;regs, RADEON_CP_STAT ),</a>
<a name="ln145">			INREG( di-&gt;regs, RADEON_AIC_TLB_ADDR ),</a>
<a name="ln146">			INREG( di-&gt;regs, RADEON_AIC_TLB_DATA ));</a>
<a name="ln147"> </a>
<a name="ln148">		LOG( di-&gt;si-&gt;log, _Radeon_WaitForIdle );</a>
<a name="ln149"> </a>
<a name="ln150">		Radeon_ResetEngine( di );</a>
<a name="ln151">	}</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154"> </a>
<a name="ln155">// wait until &quot;entries&quot; FIFO entries are empty</a>
<a name="ln156">// lock must be hold</a>
<a name="ln157">void Radeon_WaitForFifo( device_info *di, int entries )</a>
<a name="ln158">{</a>
<a name="ln159">	while( 1 ) {</a>
<a name="ln160">		bigtime_t start_time = system_time();</a>
<a name="ln161"> </a>
<a name="ln162">		do {</a>
<a name="ln163">			int slots = INREG( di-&gt;regs, RADEON_RBBM_STATUS ) &amp; RADEON_RBBM_FIFOCNT_MASK;</a>
<a name="ln164"> </a>
<a name="ln165">			if ( slots &gt;= entries )</a>
<a name="ln166">				return;</a>
<a name="ln167"> </a>
<a name="ln168">			snooze( 1 );</a>
<a name="ln169">		} while( system_time() - start_time &lt; 1000000 );</a>
<a name="ln170"> </a>
<a name="ln171">		LOG( di-&gt;si-&gt;log, _Radeon_WaitForFifo );</a>
<a name="ln172"> </a>
<a name="ln173">		Radeon_ResetEngine( di );</a>
<a name="ln174">	}</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177">// flush pixel cache of graphics card</a>
<a name="ln178">void Radeon_FlushPixelCache( device_info *di )</a>
<a name="ln179">{</a>
<a name="ln180">	bigtime_t start_time;</a>
<a name="ln181"> </a>
<a name="ln182">	OUTREGP( di-&gt;regs, RADEON_RB2D_DSTCACHE_CTLSTAT, RADEON_RB2D_DC_FLUSH_ALL,</a>
<a name="ln183">		~RADEON_RB2D_DC_FLUSH_ALL );</a>
<a name="ln184"> </a>
<a name="ln185">	start_time = system_time();</a>
<a name="ln186"> </a>
<a name="ln187">	do {</a>
<a name="ln188">		if( (INREG( di-&gt;regs, RADEON_RB2D_DSTCACHE_CTLSTAT )</a>
<a name="ln189">			 &amp; RADEON_RB2D_DC_BUSY) == 0 )</a>
<a name="ln190">			return;</a>
<a name="ln191"> </a>
<a name="ln192">		snooze( 1 );</a>
<a name="ln193">	} while( system_time() - start_time &lt; 1000000 );</a>
<a name="ln194"> </a>
<a name="ln195">	LOG( di-&gt;si-&gt;log, _Radeon_FlushPixelCache );</a>
<a name="ln196"> </a>
<a name="ln197">	SHOW_ERROR0( 0, &quot;pixel cache didn't become empty&quot; );</a>
<a name="ln198">}</a>
<a name="ln199"> </a>
<a name="ln200">// reset graphics card's engine</a>
<a name="ln201">// lock must be hold</a>
<a name="ln202">void Radeon_ResetEngine( device_info *di )</a>
<a name="ln203">{</a>
<a name="ln204">	vuint8 *regs = di-&gt;regs;</a>
<a name="ln205">	shared_info *si = di-&gt;si;</a>
<a name="ln206">	uint32 clock_cntl_index, mclk_cntl, rbbm_soft_reset, host_path_cntl;</a>
<a name="ln207">	uint32 cur_read_ptr;</a>
<a name="ln208"> </a>
<a name="ln209">	SHOW_FLOW0( 3, &quot;&quot; );</a>
<a name="ln210"> </a>
<a name="ln211">	Radeon_FlushPixelCache( di );</a>
<a name="ln212"> </a>
<a name="ln213">	clock_cntl_index = INREG( regs, RADEON_CLOCK_CNTL_INDEX );</a>
<a name="ln214">	RADEONPllErrataAfterIndex( regs, di-&gt;asic );	// drm has no errata here!</a>
<a name="ln215">	mclk_cntl = Radeon_INPLL( regs, di-&gt;asic, RADEON_MCLK_CNTL );</a>
<a name="ln216"> </a>
<a name="ln217">	// enable clock of units to be reset</a>
<a name="ln218">	Radeon_OUTPLL( regs, di-&gt;asic, RADEON_MCLK_CNTL, mclk_cntl |</a>
<a name="ln219">      RADEON_FORCEON_MCLKA |</a>
<a name="ln220">      RADEON_FORCEON_MCLKB |</a>
<a name="ln221">      RADEON_FORCEON_YCLKA |</a>
<a name="ln222">      RADEON_FORCEON_YCLKB |</a>
<a name="ln223">      RADEON_FORCEON_MC |</a>
<a name="ln224">      RADEON_FORCEON_AIC );</a>
<a name="ln225"> </a>
<a name="ln226">	// do the reset</a>
<a name="ln227">    host_path_cntl = INREG( regs, RADEON_HOST_PATH_CNTL );</a>
<a name="ln228">	rbbm_soft_reset = INREG( regs, RADEON_RBBM_SOFT_RESET );</a>
<a name="ln229"> </a>
<a name="ln230">	OUTREG( regs, RADEON_RBBM_SOFT_RESET, (rbbm_soft_reset |</a>
<a name="ln231">			RADEON_SOFT_RESET_CP |</a>
<a name="ln232">			RADEON_SOFT_RESET_HI |</a>
<a name="ln233">			RADEON_SOFT_RESET_SE |</a>
<a name="ln234">			RADEON_SOFT_RESET_RE |</a>
<a name="ln235">			RADEON_SOFT_RESET_PP |</a>
<a name="ln236">			RADEON_SOFT_RESET_E2 |</a>
<a name="ln237">			RADEON_SOFT_RESET_RB ) );</a>
<a name="ln238">	INREG( regs, RADEON_RBBM_SOFT_RESET);</a>
<a name="ln239">	OUTREG( regs, RADEON_RBBM_SOFT_RESET, rbbm_soft_reset &amp;</a>
<a name="ln240">		~( RADEON_SOFT_RESET_CP |</a>
<a name="ln241">		   RADEON_SOFT_RESET_HI |</a>
<a name="ln242">		   RADEON_SOFT_RESET_SE |</a>
<a name="ln243">		   RADEON_SOFT_RESET_RE |</a>
<a name="ln244">		   RADEON_SOFT_RESET_PP |</a>
<a name="ln245">		   RADEON_SOFT_RESET_E2 |</a>
<a name="ln246">		   RADEON_SOFT_RESET_RB ) );</a>
<a name="ln247">	INREG( regs, RADEON_RBBM_SOFT_RESET);</a>
<a name="ln248"> </a>
<a name="ln249">    OUTREG( regs, RADEON_HOST_PATH_CNTL, host_path_cntl | RADEON_HDP_SOFT_RESET );</a>
<a name="ln250">    INREG( regs, RADEON_HOST_PATH_CNTL );</a>
<a name="ln251">    OUTREG( regs, RADEON_HOST_PATH_CNTL, host_path_cntl );</a>
<a name="ln252"> </a>
<a name="ln253">	Radeon_OUTPLL( regs, di-&gt;asic, RADEON_MCLK_CNTL, mclk_cntl );</a>
<a name="ln254">   	OUTREG( regs, RADEON_CLOCK_CNTL_INDEX, clock_cntl_index );</a>
<a name="ln255">   	//RADEONPllErrataAfterIndex( regs, di-&gt;asic ); // drm doesn't do this here!</a>
<a name="ln256">   	OUTREG( regs, RADEON_RBBM_SOFT_RESET, rbbm_soft_reset);</a>
<a name="ln257"> </a>
<a name="ln258">	if ( di-&gt;acc_dma )</a>
<a name="ln259">	{</a>
<a name="ln260">		// reset ring buffer</a>
<a name="ln261">		cur_read_ptr = INREG( regs, RADEON_CP_RB_RPTR );</a>
<a name="ln262">		OUTREG( regs, RADEON_CP_RB_WPTR, cur_read_ptr );</a>
<a name="ln263"> </a>
<a name="ln264">		//if( si-&gt;cp.ring.head ) {</a>
<a name="ln265">		// during init, there are no feedback data</a>
<a name="ln266">		if( si-&gt;cp.feedback.mem_handle != 0 ) {</a>
<a name="ln267">			*(uint32 *)MEM2CPU( si-&gt;cp.feedback.mem_type, si-&gt;cp.feedback.head_mem_offset) =</a>
<a name="ln268">				cur_read_ptr;</a>
<a name="ln269">			//	*si-&gt;cp.ring.head = cur_read_ptr;</a>
<a name="ln270">			si-&gt;cp.ring.tail = cur_read_ptr;</a>
<a name="ln271">		}</a>
<a name="ln272"> </a>
<a name="ln273">		// mark all buffers as being finished</a>
<a name="ln274">		Radeon_DiscardAllIndirectBuffers( di );</a>
<a name="ln275">	}</a>
<a name="ln276"> </a>
<a name="ln277">	++si-&gt;engine.count;</a>
<a name="ln278">	return;</a>
<a name="ln279">}</a>
<a name="ln280"> </a>
<a name="ln281"> </a>
<a name="ln282">// upload Micro-Code of CP</a>
<a name="ln283">static void loadMicroEngineRAMData( device_info *di )</a>
<a name="ln284">{</a>
<a name="ln285">	int i;</a>
<a name="ln286">	const uint32 (*microcode)[2];</a>
<a name="ln287"> </a>
<a name="ln288">	SHOW_FLOW0( 3, &quot;&quot; );</a>
<a name="ln289"> </a>
<a name="ln290">	switch( di-&gt;asic ) {</a>
<a name="ln291">	case rt_r300:</a>
<a name="ln292">	case rt_rv350:</a>
<a name="ln293">	case rt_r350:</a>
<a name="ln294">	case rt_rv380:</a>
<a name="ln295">	case rt_r420:</a>
<a name="ln296">		microcode = r300_cp_microcode;</a>
<a name="ln297">		break;</a>
<a name="ln298">	case rt_r200:</a>
<a name="ln299">		microcode = r200_cp_microcode;</a>
<a name="ln300">		break;</a>
<a name="ln301">	case rt_rs100:</a>
<a name="ln302">	default:</a>
<a name="ln303">		microcode = radeon_cp_microcode;</a>
<a name="ln304">	}</a>
<a name="ln305"> </a>
<a name="ln306">	Radeon_WaitForIdle( di, false, false );</a>
<a name="ln307"> </a>
<a name="ln308">	OUTREG( di-&gt;regs, RADEON_CP_ME_RAM_ADDR, 0 );</a>
<a name="ln309"> </a>
<a name="ln310">	for ( i = 0 ; i &lt; 256 ; i++ ) {</a>
<a name="ln311">		OUTREG( di-&gt;regs, RADEON_CP_ME_RAM_DATAH, microcode[i][1] );</a>
<a name="ln312">		OUTREG( di-&gt;regs, RADEON_CP_ME_RAM_DATAL, microcode[i][0] );</a>
<a name="ln313">	}</a>
<a name="ln314">}</a>
<a name="ln315"> </a>
<a name="ln316">// aring_size - size of ring in dwords</a>
<a name="ln317">static status_t initRingBuffer( device_info *di, int aring_size )</a>
<a name="ln318">{</a>
<a name="ln319">	status_t res;</a>
<a name="ln320">	shared_info *si = di-&gt;si;</a>
<a name="ln321">	CP_info *cp = &amp;si-&gt;cp;</a>
<a name="ln322">	vuint8 *regs = di-&gt;regs;</a>
<a name="ln323">	int32 offset;</a>
<a name="ln324">	memory_type_e memory_type;</a>
<a name="ln325"> </a>
<a name="ln326">	memset( &amp;cp-&gt;ring, 0, sizeof( cp-&gt;ring ));</a>
<a name="ln327"> </a>
<a name="ln328">	// ring and indirect buffers can be either in AGP or PCI GART</a>
<a name="ln329">	// (it seems that they cannot be in graphics memory, at least</a>
<a name="ln330">	//  I had serious coherency problems when I tried that)</a>
<a name="ln331">	memory_type = mt_nonlocal;</a>
<a name="ln332"> </a>
<a name="ln333">	ALLOC_MEM( aring_size * 4, memory_type, true,</a>
<a name="ln334">		&amp;cp-&gt;ring.mem_handle, &amp;offset );</a>
<a name="ln335"> </a>
<a name="ln336">	if( res != B_OK ) {</a>
<a name="ln337">		SHOW_ERROR0( 0, &quot;Cannot allocate ring buffer&quot; );</a>
<a name="ln338">		return res;</a>
<a name="ln339">	}</a>
<a name="ln340"> </a>
<a name="ln341">	// setup CP buffer</a>
<a name="ln342">	cp-&gt;ring.mem_type = memory_type;</a>
<a name="ln343">	cp-&gt;ring.mem_offset = offset;</a>
<a name="ln344">	cp-&gt;ring.vm_base = MEM2GC( memory_type, offset );</a>
<a name="ln345">	cp-&gt;ring.size = aring_size;</a>
<a name="ln346">	cp-&gt;ring.tail_mask = aring_size - 1;</a>
<a name="ln347">	OUTREG( regs, RADEON_CP_RB_BASE, cp-&gt;ring.vm_base );</a>
<a name="ln348">	SHOW_INFO( 3, &quot;CP buffer address=%lx&quot;, cp-&gt;ring.vm_base );</a>
<a name="ln349"> </a>
<a name="ln350">	// set ring buffer size</a>
<a name="ln351">	// (it's log2 of qwords)</a>
<a name="ln352">	OUTREG( regs, RADEON_CP_RB_CNTL, radeon_log2( cp-&gt;ring.size / 2 ));</a>
<a name="ln353">	SHOW_INFO( 3, &quot;CP buffer size mask=%d&quot;, radeon_log2( cp-&gt;ring.size / 2 ) );</a>
<a name="ln354"> </a>
<a name="ln355">	// set write pointer delay to zero;</a>
<a name="ln356">	// we assume that memory synchronization is done correctly my MoBo</a>
<a name="ln357">	// and Radeon_SendCP contains a hack that hopefully fixes such problems</a>
<a name="ln358">	OUTREG( regs, RADEON_CP_RB_WPTR_DELAY, 0 );</a>
<a name="ln359"> </a>
<a name="ln360">	memset( MEM2CPU( cp-&gt;ring.mem_type, cp-&gt;ring.mem_offset), 0, cp-&gt;ring.size * 4 );</a>
<a name="ln361"> </a>
<a name="ln362">	// set CP buffer pointers</a>
<a name="ln363">	OUTREG( regs, RADEON_CP_RB_RPTR, 0 );</a>
<a name="ln364">	OUTREG( regs, RADEON_CP_RB_WPTR, 0 );</a>
<a name="ln365">	//*cp-&gt;ring.head = 0;</a>
<a name="ln366">	cp-&gt;ring.tail = 0;</a>
<a name="ln367"> </a>
<a name="ln368">	return B_OK;</a>
<a name="ln369">}</a>
<a name="ln370"> </a>
<a name="ln371">static void uninitRingBuffer( device_info *di )</a>
<a name="ln372">{</a>
<a name="ln373">	vuint8 *regs = di-&gt;regs;</a>
<a name="ln374"> </a>
<a name="ln375">	// abort any activity</a>
<a name="ln376">	Radeon_ResetEngine( di );</a>
<a name="ln377"> </a>
<a name="ln378">	// disable CP BM</a>
<a name="ln379">	OUTREG( regs, RADEON_CP_CSQ_CNTL, RADEON_CSQ_PRIDIS_INDDIS );</a>
<a name="ln380">	// read-back for flushing</a>
<a name="ln381">	INREG( regs, RADEON_CP_CSQ_CNTL );</a>
<a name="ln382"> </a>
<a name="ln383">	FREE_MEM( mt_nonlocal, di-&gt;si-&gt;cp.ring.mem_handle );</a>
<a name="ln384">}</a>
<a name="ln385"> </a>
<a name="ln386">static status_t initCPFeedback( device_info *di )</a>
<a name="ln387">{</a>
<a name="ln388">	CP_info *cp = &amp;di-&gt;si-&gt;cp;</a>
<a name="ln389">	vuint8 *regs = di-&gt;regs;</a>
<a name="ln390">	int32 offset;</a>
<a name="ln391">	memory_type_e memory_type;</a>
<a name="ln392">	status_t res;</a>
<a name="ln393"> </a>
<a name="ln394">	// status information should be in PCI memory, so CPU can</a>
<a name="ln395">	// poll it without locking the bus (PCI memory is the only</a>
<a name="ln396">	// cachable memory available)</a>
<a name="ln397">	memory_type = mt_PCI;</a>
<a name="ln398"> </a>
<a name="ln399">	ALLOC_MEM( RADEON_SCRATCH_REG_OFFSET + 0x40, memory_type, true,</a>
<a name="ln400">		&amp;cp-&gt;feedback.mem_handle, &amp;offset );</a>
<a name="ln401"> </a>
<a name="ln402">	if( res != B_OK ) {</a>
<a name="ln403">		SHOW_ERROR0( 0, &quot;Cannot allocate buffers for status information&quot; );</a>
<a name="ln404">		return res;</a>
<a name="ln405">	}</a>
<a name="ln406"> </a>
<a name="ln407">	// setup CP read pointer buffer</a>
<a name="ln408">	cp-&gt;feedback.mem_type = memory_type;</a>
<a name="ln409">	cp-&gt;feedback.head_mem_offset = offset;</a>
<a name="ln410">	cp-&gt;feedback.head_vm_address = MEM2GC( memory_type, cp-&gt;feedback.head_mem_offset );</a>
<a name="ln411">	OUTREG( regs, RADEON_CP_RB_RPTR_ADDR, cp-&gt;feedback.head_vm_address );</a>
<a name="ln412">	SHOW_INFO( 3, &quot;CP read pointer buffer==%lx&quot;, cp-&gt;feedback.head_vm_address );</a>
<a name="ln413"> </a>
<a name="ln414">	// setup scratch register buffer</a>
<a name="ln415">	cp-&gt;feedback.scratch_mem_offset = offset + RADEON_SCRATCH_REG_OFFSET;</a>
<a name="ln416">	cp-&gt;feedback.scratch_vm_start = MEM2GC( memory_type, cp-&gt;feedback.scratch_mem_offset );</a>
<a name="ln417">	OUTREG( regs, RADEON_SCRATCH_ADDR, cp-&gt;feedback.scratch_vm_start );</a>
<a name="ln418">	OUTREG( regs, RADEON_SCRATCH_UMSK, 0x3f );</a>
<a name="ln419"> </a>
<a name="ln420">	*(uint32 *)MEM2CPU( cp-&gt;feedback.mem_type, cp-&gt;feedback.head_mem_offset) = 0;</a>
<a name="ln421">	memset( MEM2CPU( cp-&gt;feedback.mem_type, cp-&gt;feedback.scratch_mem_offset), 0, 0x40 );</a>
<a name="ln422">	//*cp-&gt;ring.head = 0;</a>
<a name="ln423"> </a>
<a name="ln424">	return B_OK;</a>
<a name="ln425">}</a>
<a name="ln426"> </a>
<a name="ln427">static void uninitCPFeedback( device_info *di )</a>
<a name="ln428">{</a>
<a name="ln429">	vuint8 *regs = di-&gt;regs;</a>
<a name="ln430"> </a>
<a name="ln431">	// don't allow any scratch buffer update</a>
<a name="ln432">	OUTREG( regs, RADEON_SCRATCH_UMSK, 0x0 );</a>
<a name="ln433"> </a>
<a name="ln434">	FREE_MEM( mt_PCI, di-&gt;si-&gt;cp.feedback.mem_handle );</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437">static status_t initIndirectBuffers( device_info *di )</a>
<a name="ln438">{</a>
<a name="ln439">	CP_info *cp = &amp;di-&gt;si-&gt;cp;</a>
<a name="ln440">	int32 offset;</a>
<a name="ln441">	memory_type_e memory_type;</a>
<a name="ln442">	int i;</a>
<a name="ln443">	status_t res;</a>
<a name="ln444"> </a>
<a name="ln445">	memory_type = mt_nonlocal;</a>
<a name="ln446"> </a>
<a name="ln447">	ALLOC_MEM( NUM_INDIRECT_BUFFERS * INDIRECT_BUFFER_SIZE * 4, memory_type,</a>
<a name="ln448">		true, &amp;cp-&gt;buffers.mem_handle, &amp;offset );</a>
<a name="ln449"> </a>
<a name="ln450">	if( res != B_OK ) {</a>
<a name="ln451">		SHOW_ERROR0( 0, &quot;Cannot allocate indirect buffers&quot; );</a>
<a name="ln452">		return B_ERROR;</a>
<a name="ln453">	}</a>
<a name="ln454"> </a>
<a name="ln455">	cp-&gt;buffers.mem_type = memory_type;</a>
<a name="ln456">	cp-&gt;buffers.mem_offset = offset;</a>
<a name="ln457">	cp-&gt;buffers.vm_start = MEM2GC( memory_type, cp-&gt;buffers.mem_offset );</a>
<a name="ln458"> </a>
<a name="ln459">	for( i = 0; i &lt; NUM_INDIRECT_BUFFERS - 1; ++i ) {</a>
<a name="ln460">		cp-&gt;buffers.buffers[i].next = i + 1;</a>
<a name="ln461">	}</a>
<a name="ln462"> </a>
<a name="ln463">	cp-&gt;buffers.buffers[i].next = -1;</a>
<a name="ln464"> </a>
<a name="ln465">	cp-&gt;buffers.free_list = 0;</a>
<a name="ln466">	cp-&gt;buffers.oldest = -1;</a>
<a name="ln467">	cp-&gt;buffers.newest = -1;</a>
<a name="ln468">	cp-&gt;buffers.active_state = -1;</a>
<a name="ln469">	cp-&gt;buffers.cur_tag = 0;</a>
<a name="ln470"> </a>
<a name="ln471">	memset( MEM2CPU( cp-&gt;buffers.mem_type, cp-&gt;buffers.mem_offset), 0,</a>
<a name="ln472">		NUM_INDIRECT_BUFFERS * INDIRECT_BUFFER_SIZE * 4 );</a>
<a name="ln473"> </a>
<a name="ln474">	return B_OK;</a>
<a name="ln475">}</a>
<a name="ln476"> </a>
<a name="ln477">static void uninitIndirectBuffers( device_info *di )</a>
<a name="ln478">{</a>
<a name="ln479">	FREE_MEM( mt_nonlocal, di-&gt;si-&gt;cp.buffers.mem_handle );</a>
<a name="ln480">}</a>
<a name="ln481"> </a>
<a name="ln482">// initialize CP so it's ready for BM</a>
<a name="ln483">status_t Radeon_InitCP( device_info *di )</a>
<a name="ln484">{</a>
<a name="ln485">	thread_id thid;</a>
<a name="ln486">    thread_info thinfo;</a>
<a name="ln487">	status_t res;</a>
<a name="ln488"> </a>
<a name="ln489">	SHOW_FLOW0( 3, &quot;&quot; );</a>
<a name="ln490"> </a>
<a name="ln491">	// this is _really_ necessary so functions like ResetEngine() know</a>
<a name="ln492">	// that the CP is not set up yet</a>
<a name="ln493">	memset( &amp;di-&gt;si-&gt;cp, 0, sizeof( di-&gt;si-&gt;cp ));</a>
<a name="ln494"> </a>
<a name="ln495">	if( (res = INIT_BEN( di-&gt;si-&gt;cp.lock, &quot;Radeon CP&quot; )) &lt; 0 )</a>
<a name="ln496">		return res;</a>
<a name="ln497"> </a>
<a name="ln498">	// HACK: change owner of benaphore semaphore to team of calling thread;</a>
<a name="ln499">	// reason: user code cannot acquire kernel semaphores, but the accelerant</a>
<a name="ln500">	// is in user space; interestingly, it's enough to change the semaphore's</a>
<a name="ln501">	// owner to _any_ non-system team (that's the only security check done by</a>
<a name="ln502">	// the kernel)</a>
<a name="ln503">	thid = find_thread( NULL );</a>
<a name="ln504">    get_thread_info( thid, &amp;thinfo );</a>
<a name="ln505">    set_sem_owner( di-&gt;si-&gt;cp.lock.sem, thinfo.team );</a>
<a name="ln506"> </a>
<a name="ln507">	// init raw CP</a>
<a name="ln508">	if ( di-&gt;acc_dma ) loadMicroEngineRAMData( di );</a>
<a name="ln509"> </a>
<a name="ln510">	// do soft-reset</a>
<a name="ln511">	Radeon_ResetEngine( di );</a>
<a name="ln512"> </a>
<a name="ln513">	// after warm-reset, the CP may still be active and thus react to</a>
<a name="ln514">	// register writes during initialization unpredictably, so we better</a>
<a name="ln515">	// stop it first</a>
<a name="ln516">	OUTREG( di-&gt;regs, RADEON_CP_CSQ_CNTL, RADEON_CSQ_PRIDIS_INDDIS );</a>
<a name="ln517">	INREG( di-&gt;regs, RADEON_CP_CSQ_CNTL );</a>
<a name="ln518"> </a>
<a name="ln519">	// reset CP to make disabling active</a>
<a name="ln520">	Radeon_ResetEngine( di );</a>
<a name="ln521"> </a>
<a name="ln522">	if ( di-&gt;acc_dma )</a>
<a name="ln523">	{</a>
<a name="ln524">		res = initRingBuffer( di, CP_RING_SIZE );</a>
<a name="ln525">		if( res &lt; 0 )</a>
<a name="ln526">			goto err4;</a>
<a name="ln527"> </a>
<a name="ln528">		res = initCPFeedback( di );</a>
<a name="ln529">		if( res &lt; 0 )</a>
<a name="ln530">			goto err3;</a>
<a name="ln531"> </a>
<a name="ln532">		res = initIndirectBuffers( di );</a>
<a name="ln533">		if( res &lt; 0 )</a>
<a name="ln534">			goto err2;</a>
<a name="ln535"> </a>
<a name="ln536">		// tell CP to use BM</a>
<a name="ln537">		Radeon_WaitForIdle( di, false, false );</a>
<a name="ln538"> </a>
<a name="ln539">		// enable direct and indirect CP bus mastering</a>
<a name="ln540">		OUTREG( di-&gt;regs, RADEON_CP_CSQ_CNTL, RADEON_CSQ_PRIBM_INDBM );</a>
<a name="ln541"> </a>
<a name="ln542">		// allow bus mastering in general</a>
<a name="ln543">		OUTREGP( di-&gt;regs, RADEON_BUS_CNTL, 0, ~RADEON_BUS_MASTER_DIS );</a>
<a name="ln544">	}</a>
<a name="ln545"> </a>
<a name="ln546"> </a>
<a name="ln547">	// don't allow mixing of 2D/3D/scratch/wait_until commands</a>
<a name="ln548">	// (in fact, this doesn't seem to make any difference as we do a</a>
<a name="ln549">	// manual sync in all these cases anyway)</a>
<a name="ln550">	OUTREG( di-&gt;regs, RADEON_ISYNC_CNTL,</a>
<a name="ln551">		RADEON_ISYNC_ANY2D_IDLE3D |</a>
<a name="ln552">		RADEON_ISYNC_ANY3D_IDLE2D |</a>
<a name="ln553">		RADEON_ISYNC_WAIT_IDLEGUI |</a>
<a name="ln554">		RADEON_ISYNC_CPSCRATCH_IDLEGUI );</a>
<a name="ln555"> </a>
<a name="ln556">	SHOW_FLOW( 3, &quot;bus_cntl=%lx&quot;, INREG( di-&gt;regs, RADEON_BUS_CNTL ));</a>
<a name="ln557"> </a>
<a name="ln558">	SHOW_FLOW0( 3, &quot;Done&quot; );</a>
<a name="ln559"> </a>
<a name="ln560">	return B_OK;</a>
<a name="ln561"> </a>
<a name="ln562">//err:</a>
<a name="ln563">//	uninitIndirectBuffers( ai );</a>
<a name="ln564">err2:</a>
<a name="ln565">	uninitCPFeedback( di );</a>
<a name="ln566">err3:</a>
<a name="ln567">	uninitRingBuffer( di );</a>
<a name="ln568">err4:</a>
<a name="ln569">	DELETE_BEN( di-&gt;si-&gt;cp.lock );</a>
<a name="ln570">	return res;</a>
<a name="ln571">}</a>
<a name="ln572"> </a>
<a name="ln573"> </a>
<a name="ln574">// shutdown CP, freeing any memory</a>
<a name="ln575">void Radeon_UninitCP( device_info *di )</a>
<a name="ln576">{</a>
<a name="ln577">	vuint8 *regs = di-&gt;regs;</a>
<a name="ln578"> </a>
<a name="ln579">	// abort any pending commands</a>
<a name="ln580">	Radeon_ResetEngine( di );</a>
<a name="ln581"> </a>
<a name="ln582">	// disable CP BM</a>
<a name="ln583">	OUTREG( regs, RADEON_CP_CSQ_CNTL, RADEON_CSQ_PRIDIS_INDDIS );</a>
<a name="ln584">	// read-back for flushing</a>
<a name="ln585">	INREG( regs, RADEON_CP_CSQ_CNTL );</a>
<a name="ln586"> </a>
<a name="ln587">	if ( di-&gt;acc_dma )</a>
<a name="ln588">	{</a>
<a name="ln589">		uninitRingBuffer( di );</a>
<a name="ln590">		uninitCPFeedback( di );</a>
<a name="ln591">		uninitIndirectBuffers( di );</a>
<a name="ln592">	}</a>
<a name="ln593"> </a>
<a name="ln594">	DELETE_BEN( di-&gt;si-&gt;cp.lock );</a>
<a name="ln595">}</a>
<a name="ln596"> </a>
<a name="ln597"> </a>
<a name="ln598">// mark all indirect buffers as being free;</a>
<a name="ln599">// this should only be called after a reset;</a>
<a name="ln600">// lock must be hold</a>
<a name="ln601">void Radeon_DiscardAllIndirectBuffers( device_info *di )</a>
<a name="ln602">{</a>
<a name="ln603">	CP_info *cp = &amp;di-&gt;si-&gt;cp;</a>
<a name="ln604"> </a>
<a name="ln605">	// during init, there is no indirect buffer</a>
<a name="ln606">	if( cp-&gt;buffers.mem_handle == 0 )</a>
<a name="ln607">		return;</a>
<a name="ln608"> </a>
<a name="ln609">	// mark all sent indirect buffers as free</a>
<a name="ln610">	while( cp-&gt;buffers.oldest != -1 ) {</a>
<a name="ln611">		indirect_buffer *oldest_buffer =</a>
<a name="ln612">			&amp;cp-&gt;buffers.buffers[cp-&gt;buffers.oldest];</a>
<a name="ln613">		int tmp_oldest_buffer;</a>
<a name="ln614"> </a>
<a name="ln615">		SHOW_FLOW( 0, &quot;%d&quot;, cp-&gt;buffers.oldest );</a>
<a name="ln616"> </a>
<a name="ln617">		// remove buffer from &quot;used&quot; list</a>
<a name="ln618">		tmp_oldest_buffer = oldest_buffer-&gt;next;</a>
<a name="ln619"> </a>
<a name="ln620">		if( tmp_oldest_buffer == -1 )</a>
<a name="ln621">			cp-&gt;buffers.newest = -1;</a>
<a name="ln622"> </a>
<a name="ln623">		// put it on free list</a>
<a name="ln624">		oldest_buffer-&gt;next = cp-&gt;buffers.free_list;</a>
<a name="ln625">		cp-&gt;buffers.free_list = cp-&gt;buffers.oldest;</a>
<a name="ln626"> </a>
<a name="ln627">		cp-&gt;buffers.oldest = tmp_oldest_buffer;</a>
<a name="ln628">	}</a>
<a name="ln629">}</a>
<a name="ln630"> </a>
<a name="ln631">// lets hide this in here, as it's got lots of lovely register headers already...</a>
<a name="ln632">// does it go here, or in the accelerant anyway?</a>
<a name="ln633">// for now i'm assuming you turn on dynamic clocks, and they take care of themselves onwards...</a>
<a name="ln634">// so doing it at driver init seems sensible after a valid detection of course...</a>
<a name="ln635">void Radeon_SetDynamicClock( device_info *di, int mode)</a>
<a name="ln636">{</a>
<a name="ln637">    vuint8 *regs = di-&gt;regs;</a>
<a name="ln638">    radeon_type asic = di-&gt;asic;</a>
<a name="ln639">    uint32 tmp;</a>
<a name="ln640"> </a>
<a name="ln641">    switch(mode) {</a>
<a name="ln642">	case 0: /* Turn everything OFF (ForceON to everything)*/</a>
<a name="ln643">		if ( di-&gt;num_crtc != 2 ) {</a>
<a name="ln644">			tmp = Radeon_INPLL(regs, asic, RADEON_SCLK_CNTL);</a>
<a name="ln645">			tmp |= (RADEON_SCLK_FORCE_CP   | RADEON_SCLK_FORCE_HDP |</a>
<a name="ln646">				RADEON_SCLK_FORCE_DISP1 | RADEON_SCLK_FORCE_TOP |</a>
<a name="ln647">				RADEON_SCLK_FORCE_E2   | RADEON_SCLK_FORCE_SE  |</a>
<a name="ln648">				RADEON_SCLK_FORCE_IDCT | RADEON_SCLK_FORCE_VIP |</a>
<a name="ln649">				RADEON_SCLK_FORCE_RE   | RADEON_SCLK_FORCE_PB  |</a>
<a name="ln650">				RADEON_SCLK_FORCE_TAM  | RADEON_SCLK_FORCE_TDM |</a>
<a name="ln651">				RADEON_SCLK_FORCE_RB);</a>
<a name="ln652">			Radeon_OUTPLL(regs, asic, RADEON_SCLK_CNTL, tmp);</a>
<a name="ln653">		} else if (asic == rt_rv350) {</a>
<a name="ln654">			/* for RV350/M10, no delays are required. */</a>
<a name="ln655">			tmp = Radeon_INPLL(regs, asic, R300_SCLK_CNTL2);</a>
<a name="ln656">			tmp |= (R300_SCLK_FORCE_TCL |</a>
<a name="ln657">				R300_SCLK_FORCE_GA  |</a>
<a name="ln658">				R300_SCLK_FORCE_CBA);</a>
<a name="ln659">			Radeon_OUTPLL(regs, asic, R300_SCLK_CNTL2, tmp);</a>
<a name="ln660"> </a>
<a name="ln661">			tmp = Radeon_INPLL(regs, asic, RADEON_SCLK_CNTL);</a>
<a name="ln662">			tmp |= (RADEON_SCLK_FORCE_DISP2 | RADEON_SCLK_FORCE_CP      |</a>
<a name="ln663">				RADEON_SCLK_FORCE_HDP   | RADEON_SCLK_FORCE_DISP1   |</a>
<a name="ln664">				RADEON_SCLK_FORCE_TOP   | RADEON_SCLK_FORCE_E2      |</a>
<a name="ln665">				R300_SCLK_FORCE_VAP     | RADEON_SCLK_FORCE_IDCT    |</a>
<a name="ln666">				RADEON_SCLK_FORCE_VIP   | R300_SCLK_FORCE_SR        |</a>
<a name="ln667">				R300_SCLK_FORCE_PX      | R300_SCLK_FORCE_TX        |</a>
<a name="ln668">				R300_SCLK_FORCE_US      | RADEON_SCLK_FORCE_TV_SCLK |</a>
<a name="ln669">				R300_SCLK_FORCE_SU      | RADEON_SCLK_FORCE_OV0);</a>
<a name="ln670">			Radeon_OUTPLL(regs, asic, RADEON_SCLK_CNTL, tmp);</a>
<a name="ln671"> </a>
<a name="ln672">			tmp = Radeon_INPLL(regs, asic, RADEON_SCLK_MORE_CNTL);</a>
<a name="ln673">			tmp |= RADEON_SCLK_MORE_FORCEON;</a>
<a name="ln674">			Radeon_OUTPLL(regs, asic, RADEON_SCLK_MORE_CNTL, tmp);</a>
<a name="ln675"> </a>
<a name="ln676">			tmp = Radeon_INPLL(regs, asic, RADEON_MCLK_CNTL);</a>
<a name="ln677">			tmp |= (RADEON_FORCEON_MCLKA |</a>
<a name="ln678">				RADEON_FORCEON_MCLKB |</a>
<a name="ln679">				RADEON_FORCEON_YCLKA |</a>
<a name="ln680">				RADEON_FORCEON_YCLKB |</a>
<a name="ln681">				RADEON_FORCEON_MC);</a>
<a name="ln682">			Radeon_OUTPLL(regs, asic, RADEON_MCLK_CNTL, tmp);</a>
<a name="ln683"> </a>
<a name="ln684">			tmp = Radeon_INPLL(regs, asic, RADEON_VCLK_ECP_CNTL);</a>
<a name="ln685">			tmp &amp;= ~(RADEON_PIXCLK_ALWAYS_ONb  |</a>
<a name="ln686">				RADEON_PIXCLK_DAC_ALWAYS_ONb |</a>
<a name="ln687">			R300_DISP_DAC_PIXCLK_DAC_BLANK_OFF);</a>
<a name="ln688">			Radeon_OUTPLL(regs, asic, RADEON_VCLK_ECP_CNTL, tmp);</a>
<a name="ln689"> </a>
<a name="ln690">			tmp = Radeon_INPLL(regs, asic, RADEON_PIXCLKS_CNTL);</a>
<a name="ln691">			tmp &amp;= ~(RADEON_PIX2CLK_ALWAYS_ONb         |</a>
<a name="ln692">				RADEON_PIX2CLK_DAC_ALWAYS_ONb     |</a>
<a name="ln693">				RADEON_DISP_TVOUT_PIXCLK_TV_ALWAYS_ONb |</a>
<a name="ln694">				R300_DVOCLK_ALWAYS_ONb            |</a>
<a name="ln695">				RADEON_PIXCLK_BLEND_ALWAYS_ONb    |</a>
<a name="ln696">				RADEON_PIXCLK_GV_ALWAYS_ONb       |</a>
<a name="ln697">				R300_PIXCLK_DVO_ALWAYS_ONb        |</a>
<a name="ln698">				RADEON_PIXCLK_LVDS_ALWAYS_ONb     |</a>
<a name="ln699">				RADEON_PIXCLK_TMDS_ALWAYS_ONb     |</a>
<a name="ln700">				R300_PIXCLK_TRANS_ALWAYS_ONb      |</a>
<a name="ln701">				R300_PIXCLK_TVO_ALWAYS_ONb        |</a>
<a name="ln702">				R300_P2G2CLK_ALWAYS_ONb            |</a>
<a name="ln703">				R300_P2G2CLK_DAC_ALWAYS_ONb           |</a>
<a name="ln704">				R300_DISP_DAC_PIXCLK_DAC2_BLANK_OFF);</a>
<a name="ln705">			Radeon_OUTPLL(regs, asic, RADEON_PIXCLKS_CNTL, tmp);</a>
<a name="ln706">		}  else {</a>
<a name="ln707">			tmp = Radeon_INPLL(regs, asic, RADEON_SCLK_CNTL);</a>
<a name="ln708">			tmp |= (RADEON_SCLK_FORCE_CP | RADEON_SCLK_FORCE_E2);</a>
<a name="ln709">			tmp |= RADEON_SCLK_FORCE_SE;</a>
<a name="ln710"> </a>
<a name="ln711">			if ( di-&gt;num_crtc != 2 ) {</a>
<a name="ln712">				tmp |= ( RADEON_SCLK_FORCE_RB    |</a>
<a name="ln713">				RADEON_SCLK_FORCE_TDM   |</a>
<a name="ln714">				RADEON_SCLK_FORCE_TAM   |</a>
<a name="ln715">				RADEON_SCLK_FORCE_PB    |</a>
<a name="ln716">				RADEON_SCLK_FORCE_RE    |</a>
<a name="ln717">				RADEON_SCLK_FORCE_VIP   |</a>
<a name="ln718">				RADEON_SCLK_FORCE_IDCT  |</a>
<a name="ln719">				RADEON_SCLK_FORCE_TOP   |</a>
<a name="ln720">				RADEON_SCLK_FORCE_DISP1 |</a>
<a name="ln721">				RADEON_SCLK_FORCE_DISP2 |</a>
<a name="ln722">				RADEON_SCLK_FORCE_HDP    );</a>
<a name="ln723">			} else if ((asic == rt_r300) || (asic == rt_r350)) {</a>
<a name="ln724">				tmp |= ( RADEON_SCLK_FORCE_HDP   |</a>
<a name="ln725">					RADEON_SCLK_FORCE_DISP1 |</a>
<a name="ln726">					RADEON_SCLK_FORCE_DISP2 |</a>
<a name="ln727">					RADEON_SCLK_FORCE_TOP   |</a>
<a name="ln728">					RADEON_SCLK_FORCE_IDCT  |</a>
<a name="ln729">					RADEON_SCLK_FORCE_VIP);</a>
<a name="ln730">			}</a>
<a name="ln731">			Radeon_OUTPLL(regs, asic, RADEON_SCLK_CNTL, tmp);</a>
<a name="ln732"> </a>
<a name="ln733">			snooze(16000);</a>
<a name="ln734"> </a>
<a name="ln735">			if ((asic == rt_r300) || (asic == rt_r350)) {</a>
<a name="ln736">				tmp = Radeon_INPLL(regs, asic, R300_SCLK_CNTL2);</a>
<a name="ln737">				tmp |= ( R300_SCLK_FORCE_TCL |</a>
<a name="ln738">					R300_SCLK_FORCE_GA  |</a>
<a name="ln739">					R300_SCLK_FORCE_CBA);</a>
<a name="ln740">				Radeon_OUTPLL(regs, asic, R300_SCLK_CNTL2, tmp);</a>
<a name="ln741">				snooze(16000);</a>
<a name="ln742">			}</a>
<a name="ln743"> </a>
<a name="ln744">			if (di-&gt;is_igp) {</a>
<a name="ln745">				tmp = Radeon_INPLL(regs, asic, RADEON_MCLK_CNTL);</a>
<a name="ln746">				tmp &amp;= ~(RADEON_FORCEON_MCLKA |</a>
<a name="ln747">					RADEON_FORCEON_YCLKA);</a>
<a name="ln748">				Radeon_OUTPLL(regs, asic, RADEON_MCLK_CNTL, tmp);</a>
<a name="ln749">				snooze(16000);</a>
<a name="ln750">			}</a>
<a name="ln751"> </a>
<a name="ln752">			if ((asic == rt_rv200) ||</a>
<a name="ln753">				(asic == rt_rv250) ||</a>
<a name="ln754">				(asic == rt_rv280)) {</a>
<a name="ln755">				tmp = Radeon_INPLL(regs, asic, RADEON_SCLK_MORE_CNTL);</a>
<a name="ln756">				tmp |= RADEON_SCLK_MORE_FORCEON;</a>
<a name="ln757">				Radeon_OUTPLL(regs, asic, RADEON_SCLK_MORE_CNTL, tmp);</a>
<a name="ln758">				snooze(16000);</a>
<a name="ln759">			}</a>
<a name="ln760"> </a>
<a name="ln761">			tmp = Radeon_INPLL(regs, asic, RADEON_PIXCLKS_CNTL);</a>
<a name="ln762">			tmp &amp;= ~(RADEON_PIX2CLK_ALWAYS_ONb         |</a>
<a name="ln763">				RADEON_PIX2CLK_DAC_ALWAYS_ONb     |</a>
<a name="ln764">				RADEON_PIXCLK_BLEND_ALWAYS_ONb    |</a>
<a name="ln765">				RADEON_PIXCLK_GV_ALWAYS_ONb       |</a>
<a name="ln766">				RADEON_PIXCLK_DIG_TMDS_ALWAYS_ONb |</a>
<a name="ln767">				RADEON_PIXCLK_LVDS_ALWAYS_ONb     |</a>
<a name="ln768">				RADEON_PIXCLK_TMDS_ALWAYS_ONb);</a>
<a name="ln769"> </a>
<a name="ln770">			Radeon_OUTPLL(regs, asic, RADEON_PIXCLKS_CNTL, tmp);</a>
<a name="ln771">			snooze(16000);</a>
<a name="ln772"> </a>
<a name="ln773">			tmp = Radeon_INPLL(regs, asic, RADEON_VCLK_ECP_CNTL);</a>
<a name="ln774">			tmp &amp;= ~(RADEON_PIXCLK_ALWAYS_ONb  |</a>
<a name="ln775">				RADEON_PIXCLK_DAC_ALWAYS_ONb);</a>
<a name="ln776">			Radeon_OUTPLL(regs, asic, RADEON_VCLK_ECP_CNTL, tmp);</a>
<a name="ln777">		}</a>
<a name="ln778">		SHOW_FLOW0( 3, &quot;Dynamic Clock Scaling Disabled&quot; );</a>
<a name="ln779">		break;</a>
<a name="ln780">	case 1:</a>
<a name="ln781">		if ( di-&gt;num_crtc != 2 ) {</a>
<a name="ln782">			tmp = Radeon_INPLL(regs, asic, RADEON_SCLK_CNTL);</a>
<a name="ln783">			if ((INREG( regs, RADEON_CONFIG_CNTL) &amp; RADEON_CFG_ATI_REV_ID_MASK) &gt; RADEON_CFG_ATI_REV_A13) {</a>
<a name="ln784">				tmp &amp;= ~(RADEON_SCLK_FORCE_CP | RADEON_SCLK_FORCE_RB);</a>
<a name="ln785">			}</a>
<a name="ln786">			tmp &amp;= ~(RADEON_SCLK_FORCE_HDP  | RADEON_SCLK_FORCE_DISP1 |</a>
<a name="ln787">				RADEON_SCLK_FORCE_TOP  | RADEON_SCLK_FORCE_SE   |</a>
<a name="ln788">				RADEON_SCLK_FORCE_IDCT | RADEON_SCLK_FORCE_RE   |</a>
<a name="ln789">				RADEON_SCLK_FORCE_PB   | RADEON_SCLK_FORCE_TAM  |</a>
<a name="ln790">				RADEON_SCLK_FORCE_TDM);</a>
<a name="ln791">			Radeon_OUTPLL(regs, asic, RADEON_SCLK_CNTL, tmp);</a>
<a name="ln792">		} else if ((asic == rt_r300)</a>
<a name="ln793">				|| (asic == rt_r350)</a>
<a name="ln794">				|| (asic == rt_rv350)) {</a>
<a name="ln795">			if (asic == rt_rv350) {</a>
<a name="ln796">				tmp = Radeon_INPLL(regs, asic, R300_SCLK_CNTL2);</a>
<a name="ln797">				tmp &amp;= ~(R300_SCLK_FORCE_TCL |</a>
<a name="ln798">					R300_SCLK_FORCE_GA  |</a>
<a name="ln799">					R300_SCLK_FORCE_CBA);</a>
<a name="ln800">				tmp |=  (R300_SCLK_TCL_MAX_DYN_STOP_LAT |</a>
<a name="ln801">					R300_SCLK_GA_MAX_DYN_STOP_LAT  |</a>
<a name="ln802">					R300_SCLK_CBA_MAX_DYN_STOP_LAT);</a>
<a name="ln803">				Radeon_OUTPLL(regs, asic, R300_SCLK_CNTL2, tmp);</a>
<a name="ln804"> </a>
<a name="ln805">				tmp = Radeon_INPLL(regs, asic, RADEON_SCLK_CNTL);</a>
<a name="ln806">				tmp &amp;= ~(RADEON_SCLK_FORCE_DISP2 | RADEON_SCLK_FORCE_CP      |</a>
<a name="ln807">					RADEON_SCLK_FORCE_HDP   | RADEON_SCLK_FORCE_DISP1   |</a>
<a name="ln808">					RADEON_SCLK_FORCE_TOP   | RADEON_SCLK_FORCE_E2      |</a>
<a name="ln809">					R300_SCLK_FORCE_VAP     | RADEON_SCLK_FORCE_IDCT    |</a>
<a name="ln810">					RADEON_SCLK_FORCE_VIP   | R300_SCLK_FORCE_SR        |</a>
<a name="ln811">					R300_SCLK_FORCE_PX      | R300_SCLK_FORCE_TX        |</a>
<a name="ln812">					R300_SCLK_FORCE_US      | RADEON_SCLK_FORCE_TV_SCLK |</a>
<a name="ln813">					R300_SCLK_FORCE_SU      | RADEON_SCLK_FORCE_OV0);</a>
<a name="ln814">					tmp |=  RADEON_DYN_STOP_LAT_MASK;</a>
<a name="ln815">				Radeon_OUTPLL(regs, asic, RADEON_SCLK_CNTL, tmp);</a>
<a name="ln816"> </a>
<a name="ln817">				tmp = Radeon_INPLL(regs, asic, RADEON_SCLK_MORE_CNTL);</a>
<a name="ln818">				tmp &amp;= ~RADEON_SCLK_MORE_FORCEON;</a>
<a name="ln819">				tmp |=  RADEON_SCLK_MORE_MAX_DYN_STOP_LAT;</a>
<a name="ln820">				Radeon_OUTPLL(regs, asic, RADEON_SCLK_MORE_CNTL, tmp);</a>
<a name="ln821"> </a>
<a name="ln822">				tmp = Radeon_INPLL(regs, asic, RADEON_VCLK_ECP_CNTL);</a>
<a name="ln823">				tmp |= (RADEON_PIXCLK_ALWAYS_ONb |</a>
<a name="ln824">					RADEON_PIXCLK_DAC_ALWAYS_ONb);</a>
<a name="ln825">				Radeon_OUTPLL(regs, asic, RADEON_VCLK_ECP_CNTL, tmp);</a>
<a name="ln826"> </a>
<a name="ln827">				tmp = Radeon_INPLL(regs, asic, RADEON_PIXCLKS_CNTL);</a>
<a name="ln828">				tmp |= (RADEON_PIX2CLK_ALWAYS_ONb         |</a>
<a name="ln829">					RADEON_PIX2CLK_DAC_ALWAYS_ONb     |</a>
<a name="ln830">					RADEON_DISP_TVOUT_PIXCLK_TV_ALWAYS_ONb |</a>
<a name="ln831">					R300_DVOCLK_ALWAYS_ONb            |</a>
<a name="ln832">					RADEON_PIXCLK_BLEND_ALWAYS_ONb    |</a>
<a name="ln833">					RADEON_PIXCLK_GV_ALWAYS_ONb       |</a>
<a name="ln834">					R300_PIXCLK_DVO_ALWAYS_ONb        |</a>
<a name="ln835">					RADEON_PIXCLK_LVDS_ALWAYS_ONb     |</a>
<a name="ln836">					RADEON_PIXCLK_TMDS_ALWAYS_ONb     |</a>
<a name="ln837">					R300_PIXCLK_TRANS_ALWAYS_ONb      |</a>
<a name="ln838">					R300_PIXCLK_TVO_ALWAYS_ONb        |</a>
<a name="ln839">					R300_P2G2CLK_ALWAYS_ONb           |</a>
<a name="ln840">					R300_P2G2CLK_DAC_ALWAYS_ONb);</a>
<a name="ln841">				Radeon_OUTPLL(regs, asic, RADEON_PIXCLKS_CNTL, tmp);</a>
<a name="ln842"> </a>
<a name="ln843">				tmp = Radeon_INPLL(regs, asic, RADEON_MCLK_MISC);</a>
<a name="ln844">				tmp |= (RADEON_MC_MCLK_DYN_ENABLE |</a>
<a name="ln845">					RADEON_IO_MCLK_DYN_ENABLE);</a>
<a name="ln846">				Radeon_OUTPLL(regs, asic, RADEON_MCLK_MISC, tmp);</a>
<a name="ln847"> </a>
<a name="ln848">				tmp = Radeon_INPLL(regs, asic, RADEON_MCLK_CNTL);</a>
<a name="ln849">				tmp |= (RADEON_FORCEON_MCLKA |</a>
<a name="ln850">					RADEON_FORCEON_MCLKB);</a>
<a name="ln851"> </a>
<a name="ln852">				tmp &amp;= ~(RADEON_FORCEON_YCLKA  |</a>
<a name="ln853">					RADEON_FORCEON_YCLKB  |</a>
<a name="ln854">					RADEON_FORCEON_MC);</a>
<a name="ln855"> </a>
<a name="ln856">				/* Some releases of vbios have set DISABLE_MC_MCLKA</a>
<a name="ln857">				and DISABLE_MC_MCLKB bits in the vbios table.  Setting these</a>
<a name="ln858">				bits will cause H/W hang when reading video memory with dynamic clocking</a>
<a name="ln859">				enabled. */</a>
<a name="ln860">				if ((tmp &amp; R300_DISABLE_MC_MCLKA) &amp;&amp;</a>
<a name="ln861">				(tmp &amp; R300_DISABLE_MC_MCLKB)) {</a>
<a name="ln862">					/* If both bits are set, then check the active channels */</a>
<a name="ln863">					tmp = Radeon_INPLL(regs, asic, RADEON_MCLK_CNTL);</a>
<a name="ln864">					if (di-&gt;ram.width == 64) {</a>
<a name="ln865">						if (INREG( regs, RADEON_MEM_CNTL) &amp; R300_MEM_USE_CD_CH_ONLY)</a>
<a name="ln866">						tmp &amp;= ~R300_DISABLE_MC_MCLKB;</a>
<a name="ln867">						else</a>
<a name="ln868">						tmp &amp;= ~R300_DISABLE_MC_MCLKA;</a>
<a name="ln869">					} else {</a>
<a name="ln870">						tmp &amp;= ~(R300_DISABLE_MC_MCLKA |</a>
<a name="ln871">						R300_DISABLE_MC_MCLKB);</a>
<a name="ln872">					}</a>
<a name="ln873">				}</a>
<a name="ln874"> </a>
<a name="ln875">				Radeon_OUTPLL(regs, asic, RADEON_MCLK_CNTL, tmp);</a>
<a name="ln876">			} else {</a>
<a name="ln877">				tmp = Radeon_INPLL(regs, asic, RADEON_SCLK_CNTL);</a>
<a name="ln878">				tmp &amp;= ~(R300_SCLK_FORCE_VAP);</a>
<a name="ln879">				tmp |= RADEON_SCLK_FORCE_CP;</a>
<a name="ln880">				Radeon_OUTPLL(regs, asic, RADEON_SCLK_CNTL, tmp);</a>
<a name="ln881">				snooze(15000);</a>
<a name="ln882"> </a>
<a name="ln883">				tmp = Radeon_INPLL(regs, asic, R300_SCLK_CNTL2);</a>
<a name="ln884">				tmp &amp;= ~(R300_SCLK_FORCE_TCL |</a>
<a name="ln885">				R300_SCLK_FORCE_GA  |</a>
<a name="ln886">				R300_SCLK_FORCE_CBA);</a>
<a name="ln887">				Radeon_OUTPLL(regs, asic, R300_SCLK_CNTL2, tmp);</a>
<a name="ln888">			}</a>
<a name="ln889">		} else {</a>
<a name="ln890">			tmp = Radeon_INPLL(regs, asic, RADEON_CLK_PWRMGT_CNTL);</a>
<a name="ln891"> </a>
<a name="ln892">			tmp &amp;= ~(RADEON_ACTIVE_HILO_LAT_MASK     |</a>
<a name="ln893">				RADEON_DISP_DYN_STOP_LAT_MASK   |</a>
<a name="ln894">				RADEON_DYN_STOP_MODE_MASK);</a>
<a name="ln895"> </a>
<a name="ln896">			tmp |= (RADEON_ENGIN_DYNCLK_MODE |</a>
<a name="ln897">			(0x01 &lt;&lt; RADEON_ACTIVE_HILO_LAT_SHIFT));</a>
<a name="ln898">			Radeon_OUTPLL(regs, asic, RADEON_CLK_PWRMGT_CNTL, tmp);</a>
<a name="ln899">			snooze(15000);</a>
<a name="ln900"> </a>
<a name="ln901">			tmp = Radeon_INPLL(regs, asic, RADEON_CLK_PIN_CNTL);</a>
<a name="ln902">			tmp |= RADEON_SCLK_DYN_START_CNTL;</a>
<a name="ln903">			Radeon_OUTPLL(regs, asic, RADEON_CLK_PIN_CNTL, tmp);</a>
<a name="ln904">			snooze(15000);</a>
<a name="ln905"> </a>
<a name="ln906">			/* When DRI is enabled, setting DYN_STOP_LAT to zero can cause some R200</a>
<a name="ln907">			to lockup randomly, leave them as set by BIOS.</a>
<a name="ln908">			*/</a>
<a name="ln909">			tmp = Radeon_INPLL(regs, asic, RADEON_SCLK_CNTL);</a>
<a name="ln910">			/*tmp &amp;= RADEON_SCLK_SRC_SEL_MASK;*/</a>
<a name="ln911">			tmp &amp;= ~RADEON_SCLK_FORCEON_MASK;</a>
<a name="ln912"> </a>
<a name="ln913">			/*RAGE_6::A11 A12 A12N1 A13, RV250::A11 A12, R300*/</a>
<a name="ln914">			if (((asic == rt_rv250) &amp;&amp;</a>
<a name="ln915">				((INREG( regs, RADEON_CONFIG_CNTL) &amp; RADEON_CFG_ATI_REV_ID_MASK) &lt;</a>
<a name="ln916">				  RADEON_CFG_ATI_REV_A13)) ||</a>
<a name="ln917">				((asic == rt_rv100) &amp;&amp;</a>
<a name="ln918">				((INREG( regs, RADEON_CONFIG_CNTL) &amp; RADEON_CFG_ATI_REV_ID_MASK) &lt;=</a>
<a name="ln919">				  RADEON_CFG_ATI_REV_A13)))</a>
<a name="ln920">			{</a>
<a name="ln921">				tmp |= RADEON_SCLK_FORCE_CP;</a>
<a name="ln922">				tmp |= RADEON_SCLK_FORCE_VIP;</a>
<a name="ln923">			}</a>
<a name="ln924"> </a>
<a name="ln925">			Radeon_OUTPLL(regs, asic, RADEON_SCLK_CNTL, tmp);</a>
<a name="ln926"> </a>
<a name="ln927">			if ((asic == rt_rv200) ||</a>
<a name="ln928">				(asic == rt_rv250) ||</a>
<a name="ln929">				(asic == rt_rv280)) {</a>
<a name="ln930">				tmp = Radeon_INPLL(regs, asic, RADEON_SCLK_MORE_CNTL);</a>
<a name="ln931">				tmp &amp;= ~RADEON_SCLK_MORE_FORCEON;</a>
<a name="ln932"> </a>
<a name="ln933">				/* RV200::A11 A12 RV250::A11 A12 */</a>
<a name="ln934">				if (((asic == rt_rv200) ||</a>
<a name="ln935">					 (asic == rt_rv250)) &amp;&amp;</a>
<a name="ln936">					((INREG( regs, RADEON_CONFIG_CNTL) &amp; RADEON_CFG_ATI_REV_ID_MASK) &lt;</a>
<a name="ln937">					  RADEON_CFG_ATI_REV_A13))</a>
<a name="ln938">				{</a>
<a name="ln939">					tmp |= RADEON_SCLK_MORE_FORCEON;</a>
<a name="ln940">				}</a>
<a name="ln941">				Radeon_OUTPLL(regs, asic, RADEON_SCLK_MORE_CNTL, tmp);</a>
<a name="ln942">				snooze(15000);</a>
<a name="ln943">			}</a>
<a name="ln944"> </a>
<a name="ln945">			/* RV200::A11 A12, RV250::A11 A12 */</a>
<a name="ln946">			if (((asic == rt_rv200) ||</a>
<a name="ln947">				 (asic == rt_rv250)) &amp;&amp;</a>
<a name="ln948">				((INREG( regs, RADEON_CONFIG_CNTL) &amp; RADEON_CFG_ATI_REV_ID_MASK) &lt;</a>
<a name="ln949">				  RADEON_CFG_ATI_REV_A13))</a>
<a name="ln950">			{</a>
<a name="ln951">				tmp = Radeon_INPLL(regs, asic, RADEON_PLL_PWRMGT_CNTL);</a>
<a name="ln952">				tmp |= RADEON_TCL_BYPASS_DISABLE;</a>
<a name="ln953">				Radeon_OUTPLL(regs, asic, RADEON_PLL_PWRMGT_CNTL, tmp);</a>
<a name="ln954">			}</a>
<a name="ln955">			snooze(15000);</a>
<a name="ln956"> </a>
<a name="ln957">			/*enable dynamic mode for display clocks (PIXCLK and PIX2CLK)*/</a>
<a name="ln958">			tmp = Radeon_INPLL(regs, asic, RADEON_PIXCLKS_CNTL);</a>
<a name="ln959">			tmp |=  (RADEON_PIX2CLK_ALWAYS_ONb         |</a>
<a name="ln960">				RADEON_PIX2CLK_DAC_ALWAYS_ONb     |</a>
<a name="ln961">				RADEON_PIXCLK_BLEND_ALWAYS_ONb    |</a>
<a name="ln962">				RADEON_PIXCLK_GV_ALWAYS_ONb       |</a>
<a name="ln963">				RADEON_PIXCLK_DIG_TMDS_ALWAYS_ONb |</a>
<a name="ln964">				RADEON_PIXCLK_LVDS_ALWAYS_ONb     |</a>
<a name="ln965">				RADEON_PIXCLK_TMDS_ALWAYS_ONb);</a>
<a name="ln966"> </a>
<a name="ln967">			Radeon_OUTPLL(regs, asic, RADEON_PIXCLKS_CNTL, tmp);</a>
<a name="ln968">			snooze(15000);</a>
<a name="ln969"> </a>
<a name="ln970">			tmp = Radeon_INPLL(regs, asic, RADEON_VCLK_ECP_CNTL);</a>
<a name="ln971">			tmp |= (RADEON_PIXCLK_ALWAYS_ONb  |</a>
<a name="ln972">				RADEON_PIXCLK_DAC_ALWAYS_ONb);</a>
<a name="ln973"> </a>
<a name="ln974">			Radeon_OUTPLL(regs, asic, RADEON_VCLK_ECP_CNTL, tmp);</a>
<a name="ln975">			snooze(15000);</a>
<a name="ln976">		}</a>
<a name="ln977">		SHOW_FLOW0( 3, &quot;Dynamic Clock Scaling Enabled&quot; );</a>
<a name="ln978">		break;</a>
<a name="ln979">	default:</a>
<a name="ln980">		break;</a>
<a name="ln981">	}</a>
<a name="ln982">}</a>

</code></pre>
<div class="balloon" rel="711"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'di->num_crtc != 2' is always false.</p></div>
<div class="balloon" rel="142"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="142"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fifth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="142"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the sixth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="142"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the seventh actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="348"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="412"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="556"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
