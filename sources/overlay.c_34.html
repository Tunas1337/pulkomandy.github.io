
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>overlay.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">	Copyright (c) 2002-2004, Thomas Kurschel</a>
<a name="ln3">	</a>
<a name="ln4">	Part of Radeon accelerant</a>
<a name="ln5">		</a>
<a name="ln6">	Hardware access routines for overlays</a>
<a name="ln7">*/</a>
<a name="ln8"> </a>
<a name="ln9">#include &quot;GlobalData.h&quot;</a>
<a name="ln10">#include &quot;radeon_interface.h&quot;</a>
<a name="ln11">#include &quot;mmio.h&quot;</a>
<a name="ln12">#include &quot;overlay_regs.h&quot;</a>
<a name="ln13">#include &quot;pll_regs.h&quot;</a>
<a name="ln14">#include &quot;capture_regs.h&quot;</a>
<a name="ln15">#include &quot;utils.h&quot;</a>
<a name="ln16">#include &quot;pll_access.h&quot;</a>
<a name="ln17">#include &lt;math.h&gt;</a>
<a name="ln18">#include &lt;string.h&gt;</a>
<a name="ln19">#include &quot;CP.h&quot;</a>
<a name="ln20"> </a>
<a name="ln21"> </a>
<a name="ln22">void Radeon_TempHideOverlay( accelerator_info *ai );</a>
<a name="ln23"> </a>
<a name="ln24">// standard (linear) gamma</a>
<a name="ln25">static struct {</a>
<a name="ln26">    uint16 reg;</a>
<a name="ln27">    bool r200_or_above;</a>
<a name="ln28">    uint32 slope;</a>
<a name="ln29">    uint32 offset;</a>
<a name="ln30">} std_gamma[] = {</a>
<a name="ln31">    { RADEON_OV0_GAMMA_0_F, false, 0x100, 0x0000 },</a>
<a name="ln32">    { RADEON_OV0_GAMMA_10_1F, false, 0x100, 0x0020 },</a>
<a name="ln33">    { RADEON_OV0_GAMMA_20_3F, false, 0x100, 0x0040 },</a>
<a name="ln34">    { RADEON_OV0_GAMMA_40_7F, false, 0x100, 0x0080 },</a>
<a name="ln35">    { RADEON_OV0_GAMMA_80_BF, true, 0x100, 0x0100 },</a>
<a name="ln36">    { RADEON_OV0_GAMMA_C0_FF, true, 0x100, 0x0100 },</a>
<a name="ln37">    { RADEON_OV0_GAMMA_100_13F, true, 0x100, 0x0200 },</a>
<a name="ln38">    { RADEON_OV0_GAMMA_140_17F, true, 0x100, 0x0200 },</a>
<a name="ln39">    { RADEON_OV0_GAMMA_180_1BF, true, 0x100, 0x0300 },</a>
<a name="ln40">    { RADEON_OV0_GAMMA_1C0_1FF, true, 0x100, 0x0300 },</a>
<a name="ln41">    { RADEON_OV0_GAMMA_200_23F, true, 0x100, 0x0400 },</a>
<a name="ln42">    { RADEON_OV0_GAMMA_240_27F, true, 0x100, 0x0400 },</a>
<a name="ln43">    { RADEON_OV0_GAMMA_280_2BF, true, 0x100, 0x0500 },</a>
<a name="ln44">    { RADEON_OV0_GAMMA_2C0_2FF, true, 0x100, 0x0500 },</a>
<a name="ln45">    { RADEON_OV0_GAMMA_300_33F, true, 0x100, 0x0600 },</a>
<a name="ln46">    { RADEON_OV0_GAMMA_340_37F, true, 0x100, 0x0600 },</a>
<a name="ln47">    { RADEON_OV0_GAMMA_380_3BF, false, 0x100, 0x0700 },</a>
<a name="ln48">    { RADEON_OV0_GAMMA_3C0_3FF, false, 0x100, 0x0700 }</a>
<a name="ln49">};</a>
<a name="ln50"> </a>
<a name="ln51"> </a>
<a name="ln52">// setup overlay unit before first use</a>
<a name="ln53">void Radeon_InitOverlay( </a>
<a name="ln54">	accelerator_info *ai, int crtc_idx )</a>
<a name="ln55">{</a>
<a name="ln56">	vuint8 *regs = ai-&gt;regs;</a>
<a name="ln57">	shared_info *si = ai-&gt;si;</a>
<a name="ln58">	uint i;</a>
<a name="ln59">	uint32 ecp_div;</a>
<a name="ln60">	</a>
<a name="ln61">	SHOW_FLOW0( 0, &quot;&quot; );</a>
<a name="ln62">	</a>
<a name="ln63">	// make sure we really write this value as the &quot;toggle&quot; bit</a>
<a name="ln64">	// contained in it (which is zero initially) is edge-sensitive!</a>
<a name="ln65">	// for capturing, we need to select &quot;software&quot; video port</a>
<a name="ln66">	si-&gt;overlay_mgr.auto_flip_reg = RADEON_OV0_VID_PORT_SELECT_SOFTWARE;</a>
<a name="ln67">	</a>
<a name="ln68">	OUTREG( regs, RADEON_OV0_SCALE_CNTL, RADEON_SCALER_SOFT_RESET );</a>
<a name="ln69">	OUTREG( regs, RADEON_OV0_AUTO_FLIP_CNTRL, si-&gt;overlay_mgr.auto_flip_reg );</a>
<a name="ln70">	OUTREG( regs, RADEON_OV0_FILTER_CNTL, 			// use fixed filter coefficients</a>
<a name="ln71">		RADEON_OV0_HC_COEF_ON_HORZ_Y |</a>
<a name="ln72">		RADEON_OV0_HC_COEF_ON_HORZ_UV |</a>
<a name="ln73">		RADEON_OV0_HC_COEF_ON_VERT_Y |</a>
<a name="ln74">		RADEON_OV0_HC_COEF_ON_VERT_UV );</a>
<a name="ln75">	OUTREG( regs, RADEON_OV0_KEY_CNTL, RADEON_GRAPHIC_KEY_FN_EQ |</a>
<a name="ln76">		RADEON_VIDEO_KEY_FN_FALSE |</a>
<a name="ln77">		RADEON_CMP_MIX_OR );</a>
<a name="ln78">	OUTREG( regs, RADEON_OV0_TEST, 0 );</a>
<a name="ln79">//	OUTREG( regs, RADEON_FCP_CNTL, RADEON_FCP_CNTL_GND );	// disable capture clock</a>
<a name="ln80">//	OUTREG( regs, RADEON_CAP0_TRIG_CNTL, 0 );				// disable capturing</a>
<a name="ln81">	OUTREG( regs, RADEON_OV0_REG_LOAD_CNTL, 0 );</a>
<a name="ln82">	// tell deinterlacer to always show recent field</a>
<a name="ln83">	OUTREG( regs, RADEON_OV0_DEINTERLACE_PATTERN, </a>
<a name="ln84">		0xaaaaa | (9 &lt;&lt; RADEON_OV0_DEINT_PAT_LEN_M1_SHIFT) );</a>
<a name="ln85">	</a>
<a name="ln86">	// set gamma</a>
<a name="ln87">	for( i = 0; i &lt; sizeof( std_gamma ) / sizeof( std_gamma[0] ); ++i ) {</a>
<a name="ln88">		if( !std_gamma[i].r200_or_above || si-&gt;asic &gt;= rt_r200 ) {</a>
<a name="ln89">			OUTREG( regs, std_gamma[i].reg,	</a>
<a name="ln90">				(std_gamma[i].slope &lt;&lt; 16) | std_gamma[i].offset );</a>
<a name="ln91">		}</a>
<a name="ln92">	}</a>
<a name="ln93">	</a>
<a name="ln94">	// overlay unit can only handle up to 175 MHz, if pixel clock is higher,</a>
<a name="ln95">	// only every second pixel is handled</a>
<a name="ln96">	if( si-&gt;crtc[crtc_idx].mode.timing.pixel_clock &lt; 175000 )</a>
<a name="ln97">		ecp_div = 0;</a>
<a name="ln98">	else</a>
<a name="ln99">		ecp_div = 1;</a>
<a name="ln100"> </a>
<a name="ln101">	Radeon_OUTPLLP( regs, si-&gt;asic, RADEON_VCLK_ECP_CNTL, </a>
<a name="ln102">		ecp_div &lt;&lt; RADEON_ECP_DIV_SHIFT, ~RADEON_ECP_DIV_MASK );</a>
<a name="ln103"> </a>
<a name="ln104">	// Force the overlay clock on for integrated chips</a>
<a name="ln105">	if ((si-&gt;asic == rt_rs100) || </a>
<a name="ln106">	(si-&gt;asic == rt_rs200) ||</a>
<a name="ln107">	(si-&gt;asic == rt_rs300)) {</a>
<a name="ln108">		Radeon_OUTPLL( regs, si-&gt;asic, RADEON_VCLK_ECP_CNTL,</a>
<a name="ln109">        	(Radeon_INPLL( regs, si-&gt;asic, RADEON_VCLK_ECP_CNTL) | (1&lt;&lt;18)));</a>
<a name="ln110">    }</a>
<a name="ln111">    </a>
<a name="ln112">	si-&gt;active_overlay.crtc_idx = si-&gt;pending_overlay.crtc_idx;</a>
<a name="ln113">	</a>
<a name="ln114">	// invalidate active colour space</a>
<a name="ln115">	si-&gt;active_overlay.ob.space = -1;</a>
<a name="ln116">	</a>
<a name="ln117">	// invalidate position/scaling</a>
<a name="ln118">	si-&gt;active_overlay.ob.width = -1;</a>
<a name="ln119">}</a>
<a name="ln120"> </a>
<a name="ln121">// colour space transformation matrix</a>
<a name="ln122">typedef struct space_transform</a>
<a name="ln123">{</a>
<a name="ln124">    float   RefLuma;	// scaling of luma to use full RGB range</a>
<a name="ln125">    float   RefRCb;		// b/u -&gt; r</a>
<a name="ln126">    float   RefRY;		// g/y -&gt; r</a>
<a name="ln127">    float   RefRCr;		// r/v -&gt; r</a>
<a name="ln128">    float   RefGCb;</a>
<a name="ln129">    float   RefGY;</a>
<a name="ln130">    float   RefGCr;</a>
<a name="ln131">    float   RefBCb;</a>
<a name="ln132">    float   RefBY;</a>
<a name="ln133">    float   RefBCr;</a>
<a name="ln134">} space_transform;</a>
<a name="ln135"> </a>
<a name="ln136"> </a>
<a name="ln137">// Parameters for ITU-R BT.601 and ITU-R BT.709 colour spaces</a>
<a name="ln138">space_transform trans_yuv[2] =</a>
<a name="ln139">{</a>
<a name="ln140">    { 1.1678, 0.0, 1, 1.6007, -0.3929, 1, -0.8154, 2.0232, 1, 0.0 }, /* BT.601 */</a>
<a name="ln141">    { 1.1678, 0.0, 1, 1.7980, -0.2139, 1, -0.5345, 2.1186, 1, 0.0 }  /* BT.709 */</a>
<a name="ln142">};</a>
<a name="ln143"> </a>
<a name="ln144"> </a>
<a name="ln145">// RGB is a pass through</a>
<a name="ln146">space_transform trans_rgb =</a>
<a name="ln147">	{ 1, 0, 0, 1, 0, 1, 0, 1, 0, 0 };</a>
<a name="ln148"> </a>
<a name="ln149"> </a>
<a name="ln150">// set overlay colour space transformation matrix</a>
<a name="ln151">static void Radeon_SetTransform( </a>
<a name="ln152">	accelerator_info *ai,</a>
<a name="ln153">	float	    bright,</a>
<a name="ln154">	float	    cont,</a>
<a name="ln155">	float	    sat, </a>
<a name="ln156">	float	    hue,</a>
<a name="ln157">	float	    red_intensity, </a>
<a name="ln158">	float	    green_intensity, </a>
<a name="ln159">	float	    blue_intensity,</a>
<a name="ln160">	uint	    ref)</a>
<a name="ln161">{</a>
<a name="ln162">	vuint8 *regs = ai-&gt;regs;</a>
<a name="ln163">	shared_info *si = ai-&gt;si;</a>
<a name="ln164">	float	    OvHueSin, OvHueCos;</a>
<a name="ln165">	float	    CAdjOff;</a>
<a name="ln166">	float		CAdjRY, CAdjGY, CAdjBY;</a>
<a name="ln167">	float	    CAdjRCb, CAdjRCr;</a>
<a name="ln168">	float	    CAdjGCb, CAdjGCr;</a>
<a name="ln169">	float	    CAdjBCb, CAdjBCr;</a>
<a name="ln170">	float	    RedAdj,GreenAdj,BlueAdj;</a>
<a name="ln171">	float	    OvROff, OvGOff, OvBOff;</a>
<a name="ln172">	float		OvRY, OvGY, OvBY;</a>
<a name="ln173">	float	    OvRCb, OvRCr;</a>
<a name="ln174">	float	    OvGCb, OvGCr;</a>
<a name="ln175">	float	    OvBCb, OvBCr;</a>
<a name="ln176">	float	    Loff;</a>
<a name="ln177">	float	    Coff;</a>
<a name="ln178">	</a>
<a name="ln179">	uint32	    dwOvROff, dwOvGOff, dwOvBOff;</a>
<a name="ln180">	uint32		dwOvRY, dwOvGY, dwOvBY;</a>
<a name="ln181">	uint32	    dwOvRCb, dwOvRCr;</a>
<a name="ln182">	uint32	    dwOvGCb, dwOvGCr;</a>
<a name="ln183">	uint32	    dwOvBCb, dwOvBCr;</a>
<a name="ln184">	</a>
<a name="ln185">	space_transform	*trans;</a>
<a name="ln186">	</a>
<a name="ln187">	SHOW_FLOW0( 0, &quot;&quot; );</a>
<a name="ln188"> </a>
<a name="ln189">	// get proper conversion formula</a>
<a name="ln190">	switch( si-&gt;pending_overlay.ob.space ) {</a>
<a name="ln191">	case B_YCbCr422:</a>
<a name="ln192">	case B_YUV12:</a>
<a name="ln193">		Loff = 16 * 4;		// internal representation is 10 Bits</a>
<a name="ln194">		Coff = 128 * 4;</a>
<a name="ln195">		</a>
<a name="ln196">		if (ref &gt;= 2) </a>
<a name="ln197">			ref = 0;</a>
<a name="ln198">		</a>
<a name="ln199">		trans = &amp;trans_yuv[ref];</a>
<a name="ln200">		break;</a>
<a name="ln201">		</a>
<a name="ln202">	case B_RGB15:</a>
<a name="ln203">	case B_RGB16:</a>
<a name="ln204">	case B_RGB32:</a>
<a name="ln205">	default:</a>
<a name="ln206">		Loff = 0;</a>
<a name="ln207">		Coff = 0;</a>
<a name="ln208">		trans = &amp;trans_rgb;</a>
<a name="ln209">	}</a>
<a name="ln210">	</a>
<a name="ln211">	OvHueSin = sin(hue);</a>
<a name="ln212">	OvHueCos = cos(hue);</a>
<a name="ln213">	</a>
<a name="ln214">	// get matrix values to convert overlay colour space to RGB</a>
<a name="ln215">	// applying colour adjustment, saturation and luma scaling</a>
<a name="ln216">	// (saturation doesn't work with RGB input, perhaps it did with some</a>
<a name="ln217">	//  maths; this is left to the reader :)</a>
<a name="ln218">	CAdjRY = cont * trans-&gt;RefLuma * trans-&gt;RefRY;</a>
<a name="ln219">	CAdjGY = cont * trans-&gt;RefLuma * trans-&gt;RefGY;</a>
<a name="ln220">	CAdjBY = cont * trans-&gt;RefLuma * trans-&gt;RefBY;</a>
<a name="ln221">	</a>
<a name="ln222">	CAdjRCb = sat * -OvHueSin * trans-&gt;RefRCr;</a>
<a name="ln223">	CAdjRCr = sat * OvHueCos * trans-&gt;RefRCr;</a>
<a name="ln224">	CAdjGCb = sat * (OvHueCos * trans-&gt;RefGCb - OvHueSin * trans-&gt;RefGCr);</a>
<a name="ln225">	CAdjGCr = sat * (OvHueSin * trans-&gt;RefGCb + OvHueCos * trans-&gt;RefGCr);</a>
<a name="ln226">	CAdjBCb = sat * OvHueCos * trans-&gt;RefBCb;</a>
<a name="ln227">	CAdjBCr = sat * OvHueSin * trans-&gt;RefBCb;</a>
<a name="ln228">	</a>
<a name="ln229">	// adjust black level</a>
<a name="ln230">	CAdjOff = cont * trans[ref].RefLuma * bright * 1023.0;</a>
<a name="ln231">	RedAdj = cont * trans[ref].RefLuma * red_intensity * 1023.0;</a>
<a name="ln232">	GreenAdj = cont * trans[ref].RefLuma * green_intensity * 1023.0;</a>
<a name="ln233">	BlueAdj = cont * trans[ref].RefLuma * blue_intensity * 1023.0;</a>
<a name="ln234">	</a>
<a name="ln235">	OvRY = CAdjRY;</a>
<a name="ln236">	OvGY = CAdjGY;</a>
<a name="ln237">	OvBY = CAdjBY;</a>
<a name="ln238">	OvRCb = CAdjRCb;</a>
<a name="ln239">	OvRCr = CAdjRCr;</a>
<a name="ln240">	OvGCb = CAdjGCb;</a>
<a name="ln241">	OvGCr = CAdjGCr;</a>
<a name="ln242">	OvBCb = CAdjBCb;</a>
<a name="ln243">	OvBCr = CAdjBCr;</a>
<a name="ln244">	// apply offsets</a>
<a name="ln245">	OvROff = RedAdj + CAdjOff -	CAdjRY * Loff - (OvRCb + OvRCr) * Coff;</a>
<a name="ln246">	OvGOff = GreenAdj + CAdjOff - CAdjGY * Loff - (OvGCb + OvGCr) * Coff;</a>
<a name="ln247">	OvBOff = BlueAdj + CAdjOff - CAdjBY * Loff - (OvBCb + OvBCr) * Coff;</a>
<a name="ln248">	</a>
<a name="ln249">	dwOvROff = ((int32)(OvROff * 2.0)) &amp; 0x1fff;</a>
<a name="ln250">	dwOvGOff = ((int32)(OvGOff * 2.0)) &amp; 0x1fff;</a>
<a name="ln251">	dwOvBOff = ((int32)(OvBOff * 2.0)) &amp; 0x1fff;</a>
<a name="ln252"> </a>
<a name="ln253">	dwOvRY = (((int32)(OvRY * 2048.0))&amp;0x7fff)&lt;&lt;17;</a>
<a name="ln254">	dwOvGY = (((int32)(OvGY * 2048.0))&amp;0x7fff)&lt;&lt;17;</a>
<a name="ln255">	dwOvBY = (((int32)(OvBY * 2048.0))&amp;0x7fff)&lt;&lt;17;</a>
<a name="ln256">	dwOvRCb = (((int32)(OvRCb * 2048.0))&amp;0x7fff)&lt;&lt;1;</a>
<a name="ln257">	dwOvRCr = (((int32)(OvRCr * 2048.0))&amp;0x7fff)&lt;&lt;17;</a>
<a name="ln258">	dwOvGCb = (((int32)(OvGCb * 2048.0))&amp;0x7fff)&lt;&lt;1;</a>
<a name="ln259">	dwOvGCr = (((int32)(OvGCr * 2048.0))&amp;0x7fff)&lt;&lt;17;</a>
<a name="ln260">	dwOvBCb = (((int32)(OvBCb * 2048.0))&amp;0x7fff)&lt;&lt;1;</a>
<a name="ln261">	dwOvBCr = (((int32)(OvBCr * 2048.0))&amp;0x7fff)&lt;&lt;17;</a>
<a name="ln262"> </a>
<a name="ln263">	OUTREG( regs, RADEON_OV0_LIN_TRANS_A, dwOvRCb | dwOvRY );</a>
<a name="ln264">	OUTREG( regs, RADEON_OV0_LIN_TRANS_B, dwOvROff | dwOvRCr );</a>
<a name="ln265">	OUTREG( regs, RADEON_OV0_LIN_TRANS_C, dwOvGCb | dwOvGY );</a>
<a name="ln266">	OUTREG( regs, RADEON_OV0_LIN_TRANS_D, dwOvGOff | dwOvGCr );</a>
<a name="ln267">	OUTREG( regs, RADEON_OV0_LIN_TRANS_E, dwOvBCb | dwOvBY );</a>
<a name="ln268">	OUTREG( regs, RADEON_OV0_LIN_TRANS_F, dwOvBOff | dwOvBCr );</a>
<a name="ln269">	</a>
<a name="ln270">	si-&gt;active_overlay.ob.space = si-&gt;pending_overlay.ob.space;</a>
<a name="ln271">}</a>
<a name="ln272"> </a>
<a name="ln273"> </a>
<a name="ln274">// convert Be colour key to rgb value</a>
<a name="ln275">static uint32 colourKey2RGB32( </a>
<a name="ln276">	uint32 space, uint8 red, uint8 green, uint8 blue ) </a>
<a name="ln277">{</a>
<a name="ln278">	uint32 res;</a>
<a name="ln279">	</a>
<a name="ln280">	SHOW_FLOW0( 3, &quot;&quot; );</a>
<a name="ln281">	</a>
<a name="ln282">	// the way Be defines colour keys may be convinient to some driver developers,</a>
<a name="ln283">	// but it's not well defined - took me some time to find out the format used</a>
<a name="ln284">	// and still I have no idea how alpha is defined; Rudolf told me that alpha is</a>
<a name="ln285">	// never used</a>
<a name="ln286">	switch( space ) {</a>
<a name="ln287">	case B_RGB15:</a>
<a name="ln288">		res = </a>
<a name="ln289">			((uint32)(red &gt;&gt; 0) &lt;&lt; (16+3)) | </a>
<a name="ln290">			((uint32)(green &gt;&gt; 0) &lt;&lt; (8+3)) | </a>
<a name="ln291">			((blue &gt;&gt; 0) &lt;&lt; 3);</a>
<a name="ln292">		break;</a>
<a name="ln293">	case B_RGB16:</a>
<a name="ln294">		res = </a>
<a name="ln295">			((uint32)(red &gt;&gt; 0) &lt;&lt; (16+3)) | </a>
<a name="ln296">			((uint32)(green &gt;&gt; 0) &lt;&lt; (8+2)) | </a>
<a name="ln297">			((blue &gt;&gt; 0) &lt;&lt; 3);</a>
<a name="ln298">		break;</a>
<a name="ln299">	case B_RGB32:</a>
<a name="ln300">	case B_CMAP8:</a>
<a name="ln301">		res = ((uint32)(red) &lt;&lt; 16) | ((uint32)(green) &lt;&lt; 8) | blue;</a>
<a name="ln302">		break;</a>
<a name="ln303">	default:</a>
<a name="ln304">		res = 0;</a>
<a name="ln305">	}</a>
<a name="ln306">	</a>
<a name="ln307">	SHOW_FLOW( 3, &quot;key=%lx&quot;, res );</a>
<a name="ln308">	return res;</a>
<a name="ln309">}</a>
<a name="ln310"> </a>
<a name="ln311"> </a>
<a name="ln312">// set colour key of overlay</a>
<a name="ln313">static void Radeon_SetColourKey( </a>
<a name="ln314">	accelerator_info *ai, const overlay_window *ow )</a>
<a name="ln315">{</a>
<a name="ln316">	virtual_card *vc = ai-&gt;vc;</a>
<a name="ln317">	vuint8 *regs = ai-&gt;regs;</a>
<a name="ln318">	uint32 rgb32, mask32, min32, max32;</a>
<a name="ln319">	</a>
<a name="ln320">	/*SHOW_FLOW( 0, &quot;value=%02x %02x %02x, mask=%02x %02x %02x&quot;,</a>
<a name="ln321">		ow-&gt;red.value, ow-&gt;green.value, ow-&gt;blue.value,</a>
<a name="ln322">		ow-&gt;red.mask, ow-&gt;green.mask, ow-&gt;blue.mask );*/</a>
<a name="ln323">	</a>
<a name="ln324">	// Radeons don't support value and mask as colour key but colour range</a>
<a name="ln325">	rgb32 = colourKey2RGB32( vc-&gt;mode.space, </a>
<a name="ln326">		ow-&gt;red.value, ow-&gt;green.value, ow-&gt;blue.value );</a>
<a name="ln327">	mask32 = colourKey2RGB32( vc-&gt;mode.space,</a>
<a name="ln328">		ow-&gt;red.mask, ow-&gt;green.mask, ow-&gt;blue.mask );</a>
<a name="ln329"> </a>
<a name="ln330">	// ~mask32 are all unimportant (usually low order) bits	</a>
<a name="ln331">	// oring this to the colour should give us the highest valid colour value</a>
<a name="ln332">	// (add would be more precise but may lead to overflows)</a>
<a name="ln333">	min32 = rgb32;</a>
<a name="ln334">	max32 = rgb32 | ~mask32;</a>
<a name="ln335">	</a>
<a name="ln336">	OUTREG( regs, RADEON_OV0_GRAPHICS_KEY_CLR_LOW, min32 );</a>
<a name="ln337">	OUTREG( regs, RADEON_OV0_GRAPHICS_KEY_CLR_HIGH, max32 );</a>
<a name="ln338">	OUTREG( regs, RADEON_OV0_KEY_CNTL, </a>
<a name="ln339">		RADEON_GRAPHIC_KEY_FN_EQ |</a>
<a name="ln340">		RADEON_VIDEO_KEY_FN_FALSE |</a>
<a name="ln341">		RADEON_CMP_MIX_OR );</a>
<a name="ln342">}</a>
<a name="ln343"> </a>
<a name="ln344">typedef struct {</a>
<a name="ln345">	uint max_scale;					// maximum src_width/dest_width, </a>
<a name="ln346">									// i.e. source increment per screen pixel</a>
<a name="ln347">	uint8 group_size; 				// size of one filter group in pixels</a>
<a name="ln348">	uint8 p1_step_by, p23_step_by;	// &gt; 0: log(source pixel increment)+1, 2-tap filter</a>
<a name="ln349">									// = 0: source pixel increment = 1, 4-tap filter</a>
<a name="ln350">} hscale_factor;</a>
<a name="ln351"> </a>
<a name="ln352"> </a>
<a name="ln353">// scaling/filter tables depending on overlay colour space:</a>
<a name="ln354">// magnifying pixels is no problem, but minifying can lead to overload,</a>
<a name="ln355">// so we have to skip pixels and/or use 2-tap filters</a>
<a name="ln356">static hscale_factor scale_RGB16[] = {</a>
<a name="ln357">	{ (2 &lt;&lt; 12), 		2, 1, 1 },</a>
<a name="ln358">	{ (4 &lt;&lt; 12), 		2, 2, 2 },</a>
<a name="ln359">	{ (8 &lt;&lt; 12), 		2, 3, 3 },</a>
<a name="ln360">	{ (16 &lt;&lt; 12), 		2, 4, 4 },</a>
<a name="ln361">	{ (32 &lt;&lt; 12), 		2, 5, 5 }</a>
<a name="ln362">};</a>
<a name="ln363"> </a>
<a name="ln364">static hscale_factor scale_RGB32[] = {</a>
<a name="ln365">	{ (2 &lt;&lt; 12) / 3,	2, 0, 0 },</a>
<a name="ln366">	{ (4 &lt;&lt; 12) / 3,	4, 1, 1 },</a>
<a name="ln367">	{ (8 &lt;&lt; 12) / 3,	4, 2, 2 },</a>
<a name="ln368">	{ (4 &lt;&lt; 12), 		4, 2, 3 },</a>
<a name="ln369">	{ (16 &lt;&lt; 12) / 3,	4, 3, 3 },</a>
<a name="ln370">	{ (8 &lt;&lt; 12), 		4, 3, 4 },</a>
<a name="ln371">	{ (32 &lt;&lt; 12) / 3,	4, 4, 4 },</a>
<a name="ln372">	{ (16 &lt;&lt; 12),		4, 5, 5 }</a>
<a name="ln373">};</a>
<a name="ln374"> </a>
<a name="ln375">static hscale_factor scale_YUV[] = {</a>
<a name="ln376">	{ (16 &lt;&lt; 12) / 16,	2, 0, 0 },</a>
<a name="ln377">	{ (16 &lt;&lt; 12) / 12,	2, 0, 1 },	// mode 4, 1, 0 (as used by YUV12) is impossible</a>
<a name="ln378">	{ (16 &lt;&lt; 12) / 8,	4, 1, 1 },</a>
<a name="ln379">	{ (16 &lt;&lt; 12) / 6,	4, 1, 2 },</a>
<a name="ln380">	{ (16 &lt;&lt; 12) / 4,	4, 2, 2 },</a>
<a name="ln381">	{ (16 &lt;&lt; 12) / 3,	4, 2, 3 },</a>
<a name="ln382">	{ (16 &lt;&lt; 12) / 2,	4, 3, 3 },</a>
<a name="ln383">	{ (16 &lt;&lt; 12) / 1,	4, 4, 4 }</a>
<a name="ln384">};</a>
<a name="ln385"> </a>
<a name="ln386">static hscale_factor scale_YUV12[] = {</a>
<a name="ln387">	{ (16 &lt;&lt; 12) / 16,			2, 0, 0 },</a>
<a name="ln388">	{ (16 &lt;&lt; 12) / 12,			4, 1, 0 },	</a>
<a name="ln389">	{ (16 &lt;&lt; 12) / 12,			2, 0, 1 },	</a>
<a name="ln390">	{ (16 &lt;&lt; 12) / 8,			4, 1, 1 },</a>
<a name="ln391">	{ (16 &lt;&lt; 12) / 6,			4, 1, 2 },</a>
<a name="ln392">	{ (16 &lt;&lt; 12) / 4,			4, 2, 2 },</a>
<a name="ln393">	{ (16 &lt;&lt; 12) / 3,			4, 2, 3 },</a>
<a name="ln394">	{ (16 &lt;&lt; 12) / 2,			4, 3, 3 },</a>
<a name="ln395">	{ (int)((16 &lt;&lt; 12) / 1.5),	4, 3, 4 },</a>
<a name="ln396">	{ (int)((16 &lt;&lt; 12) / 1.0),	4, 4, 4 },</a>
<a name="ln397">	{ (int)((16 &lt;&lt; 12) / 0.75),	4, 4, 5 },</a>
<a name="ln398">	{ (int)((16 &lt;&lt; 12) / 0.5),	4, 5, 5 }</a>
<a name="ln399">};</a>
<a name="ln400"> </a>
<a name="ln401">#define min3( a, b, c ) (min( (a), min( (b), (c) )))</a>
<a name="ln402"> </a>
<a name="ln403">static hscale_factor scale_YUV9[] = {</a>
<a name="ln404">	{ min3( (16 &lt;&lt; 12) / 12,	(3 &lt;&lt; 12) * 1,	(2 &lt;&lt; 12) * 4 * 1 ),	2, 0, 0 },</a>
<a name="ln405">	{ min3( (16 &lt;&lt; 12) / 8, 	(3 &lt;&lt; 12) * 1,	(2 &lt;&lt; 12) * 4 * 1 ),	4, 1, 0 },</a>
<a name="ln406">	{ min3( (16 &lt;&lt; 12) / 10,	(3 &lt;&lt; 12) * 1,	(2 &lt;&lt; 12) * 4 * 1 ),	2, 0, 1 },</a>
<a name="ln407">	{ min3( (16 &lt;&lt; 12) / 6, 	(3 &lt;&lt; 12) * 1,	(2 &lt;&lt; 12) * 4 * 1 ),	4, 1, 1 },</a>
<a name="ln408">	{ min3( (16 &lt;&lt; 12) / 5, 	(3 &lt;&lt; 12) * 1,	(2 &lt;&lt; 12) * 4 * 2 ),	4, 1, 2 },</a>
<a name="ln409">	{ min3( (16 &lt;&lt; 12) / 3, 	(3 &lt;&lt; 12) * 2,	(2 &lt;&lt; 12) * 4 * 2 ),	4, 2, 2 },</a>
<a name="ln410">	{ min3( (int)((16 &lt;&lt; 12) / 2.5), 	(3 &lt;&lt; 12) * 1,	(2 &lt;&lt; 12) * 4 * 4 ),	4, 2, 3 },	// probably, it should be (3 &lt;&lt; 12) * 2</a>
<a name="ln411">	{ min3( (int)((16 &lt;&lt; 12) / 1.5), 	(3 &lt;&lt; 12) * 4,	(2 &lt;&lt; 12) * 4 * 4 ),	4, 3, 3 },</a>
<a name="ln412">	{ min3( (int)((16 &lt;&lt; 12) / 0.75), 	(3 &lt;&lt; 12) * 8,	(2 &lt;&lt; 12) * 4 * 8 ),	4, 4, 4 },</a>
<a name="ln413">	{ min3( (int)((16 &lt;&lt; 12) / 0.625), 	(3 &lt;&lt; 12) * 8,	(2 &lt;&lt; 12) * 4 * 16 ),	4, 4, 5 },</a>
<a name="ln414">	{ min3( (int)((16 &lt;&lt; 12) / 0.375), 	(3 &lt;&lt; 12) * 16,	(2 &lt;&lt; 12) * 4 * 16 ),	4, 5, 5 }</a>
<a name="ln415">};</a>
<a name="ln416"> </a>
<a name="ln417"> </a>
<a name="ln418">// parameters of an overlay colour space</a>
<a name="ln419">typedef struct {</a>
<a name="ln420">	uint8 bpp_shift;				// log2( bytes per pixel (main plain) )</a>
<a name="ln421">	uint8 bpuv_shift;				// log2( bytes per pixel (uv-plane) ); </a>
<a name="ln422">									// if there is one plane only: bpp=bpuv</a>
<a name="ln423">	uint8 num_planes;				// number of planes</a>
<a name="ln424">	uint8 h_uv_sub_sample_shift;	// log2( horizontal pixels per uv pair )</a>
<a name="ln425">	uint8 v_uv_sub_sample_shift;	// log2( vertical pixels per uv pair )</a>
<a name="ln426">	hscale_factor *factors;			// scaling/filter table</a>
<a name="ln427">	uint8 num_factors;</a>
<a name="ln428">} space_params;</a>
<a name="ln429"> </a>
<a name="ln430">static space_params space_params_table[16] = {</a>
<a name="ln431">	{ 0, 0, 0, 0, 0, NULL, 0 },	// reserved</a>
<a name="ln432">	{ 0, 0, 0, 0, 0, NULL, 0 },	// reserved</a>
<a name="ln433">	{ 0, 0, 0, 0, 0, NULL, 0 },	// reserved</a>
<a name="ln434">	{ 1, 1, 1, 0, 0, scale_RGB16, B_COUNT_OF( scale_RGB16 ) },	// RGB15</a>
<a name="ln435">	{ 1, 1, 1, 0, 0, scale_RGB16, B_COUNT_OF( scale_RGB16 ) },	// RGB16</a>
<a name="ln436">	{ 0, 0, 0, 0, 0, NULL, 0 },	// reserved</a>
<a name="ln437">	{ 2, 2, 1, 0, 0, scale_RGB32, B_COUNT_OF( scale_RGB32 ) },	// RGB32</a>
<a name="ln438">	{ 0, 0, 0, 0, 0, NULL, 0 },	// reserved</a>
<a name="ln439">	{ 0, 0, 0, 0, 0, NULL, 0 },	// reserved</a>
<a name="ln440">	{ 0, 0, 3, 2, 2, scale_YUV9, B_COUNT_OF( scale_YUV9 ) },		// YUV9</a>
<a name="ln441">	{ 0, 0, 3, 1, 1, scale_YUV12, B_COUNT_OF( scale_YUV12 ) },	// YUV12, three-plane</a>
<a name="ln442">	{ 1, 1, 1, 1, 0, scale_YUV, B_COUNT_OF( scale_YUV ) },		// VYUY422</a>
<a name="ln443">	{ 1, 1, 1, 1, 0, scale_YUV, B_COUNT_OF( scale_YUV ) },		// YVYU422</a>
<a name="ln444">	{ 0, 1, 2, 1, 1, scale_YUV12, B_COUNT_OF( scale_YUV12 ) },	// YUV12, two-plane</a>
<a name="ln445">	{ 0, 1, 2, 1, 1, NULL, 0 },	// ???</a>
<a name="ln446">	{ 0, 0, 0, 0, 0, NULL, 0 }	// reserved</a>
<a name="ln447">};</a>
<a name="ln448"> </a>
<a name="ln449">// get appropriate scaling/filter parameters</a>
<a name="ln450">static hscale_factor *getHScaleFactor( </a>
<a name="ln451">	accelerator_info *ai,</a>
<a name="ln452">	space_params *params, </a>
<a name="ln453">	uint32 src_left, uint32 src_right, uint32 *h_inc )</a>
<a name="ln454">{</a>
<a name="ln455">	uint words_per_p1_line, words_per_p23_line, max_words_per_line;</a>
<a name="ln456">	bool p1_4tap_allowed, p23_4tap_allowed;</a>
<a name="ln457">	uint i;</a>
<a name="ln458">	uint num_factors;</a>
<a name="ln459">	hscale_factor *factors;</a>
<a name="ln460"> </a>
<a name="ln461">	SHOW_FLOW0( 3, &quot;&quot; );</a>
<a name="ln462"> </a>
<a name="ln463">	// check whether fifo is large enough to feed vertical 4-tap-filter</a>
<a name="ln464"> </a>
<a name="ln465">	words_per_p1_line = </a>
<a name="ln466">		ceilShiftDiv( (src_right - 1) &lt;&lt; params-&gt;bpp_shift, 4 ) - </a>
<a name="ln467">		((src_left &lt;&lt; params-&gt;bpp_shift) &gt;&gt; 4) + 1;</a>
<a name="ln468">	words_per_p23_line = </a>
<a name="ln469">		ceilShiftDiv( (src_right - 1) &lt;&lt; params-&gt;bpuv_shift, 4 ) - </a>
<a name="ln470">		((src_left &lt;&lt; params-&gt;bpuv_shift) &gt;&gt; 4) + 1;</a>
<a name="ln471"> </a>
<a name="ln472">	// overlay scaler line length differs for different revisions </a>
<a name="ln473">	// this needs to be maintained by hand </a>
<a name="ln474">	if (ai-&gt;si-&gt;asic == rt_r200 || ai-&gt;si-&gt;asic &gt;= rt_r300)</a>
<a name="ln475">		max_words_per_line = 1920 / 16;</a>
<a name="ln476">	else</a>
<a name="ln477">		max_words_per_line = 1536 / 16;</a>
<a name="ln478"> </a>
<a name="ln479">	switch (params-&gt;num_planes) {</a>
<a name="ln480">		case 3:</a>
<a name="ln481">			p1_4tap_allowed = words_per_p1_line &lt; max_words_per_line / 2;</a>
<a name="ln482">			p23_4tap_allowed = words_per_p23_line &lt; max_words_per_line / 4;</a>
<a name="ln483">			break;</a>
<a name="ln484">		case 2:</a>
<a name="ln485">			p1_4tap_allowed = words_per_p1_line &lt; max_words_per_line / 2;</a>
<a name="ln486">			p23_4tap_allowed = words_per_p23_line &lt; max_words_per_line / 2;</a>
<a name="ln487">			break;</a>
<a name="ln488">		case 1:</a>
<a name="ln489">		default:</a>
<a name="ln490">			p1_4tap_allowed = p23_4tap_allowed = words_per_p1_line &lt; max_words_per_line;</a>
<a name="ln491">			break;</a>
<a name="ln492">	}</a>
<a name="ln493"> </a>
<a name="ln494">	SHOW_FLOW( 3, &quot;p1_4tap_allowed=%d, p23_4t_allowed=%d&quot;, </a>
<a name="ln495">		(int)p1_4tap_allowed, (int)p23_4tap_allowed );</a>
<a name="ln496"> </a>
<a name="ln497">	// search for proper scaling/filter entry</a>
<a name="ln498">	factors = params-&gt;factors;</a>
<a name="ln499">	num_factors = params-&gt;num_factors;</a>
<a name="ln500"> </a>
<a name="ln501">	if (factors == NULL || num_factors == 0)</a>
<a name="ln502">		return NULL;</a>
<a name="ln503"> </a>
<a name="ln504">	for (i = 0; i &lt; num_factors; ++i, ++factors) {</a>
<a name="ln505">		if (*h_inc &lt;= factors-&gt;max_scale</a>
<a name="ln506">			&amp;&amp; (factors-&gt;p1_step_by &gt; 0 || p1_4tap_allowed)</a>
<a name="ln507">			&amp;&amp; (factors-&gt;p23_step_by &gt; 0 || p23_4tap_allowed))</a>
<a name="ln508">			break;</a>
<a name="ln509">	}</a>
<a name="ln510"> </a>
<a name="ln511">	if (i == num_factors) {</a>
<a name="ln512">		// overlay is asked to be scaled down more than allowed,</a>
<a name="ln513">		// so use least scaling factor supported</a>
<a name="ln514">		--factors;</a>
<a name="ln515">		*h_inc = factors-&gt;max_scale;</a>
<a name="ln516">	}</a>
<a name="ln517"> </a>
<a name="ln518">	SHOW_FLOW( 3, &quot;group_size=%d, p1_step_by=%d, p23_step_by=%d&quot;, </a>
<a name="ln519">		factors-&gt;group_size, factors-&gt;p1_step_by, factors-&gt;p23_step_by );</a>
<a name="ln520"> </a>
<a name="ln521">	return factors;</a>
<a name="ln522">}			</a>
<a name="ln523"> </a>
<a name="ln524"> </a>
<a name="ln525">#define I2FF( a, shift ) ((uint32)((a) * (1 &lt;&lt; (shift))))</a>
<a name="ln526"> </a>
<a name="ln527"> </a>
<a name="ln528">// show overlay on screen</a>
<a name="ln529">static status_t Radeon_ShowOverlay( </a>
<a name="ln530">	accelerator_info *ai, int crtc_idx )</a>
<a name="ln531">{</a>
<a name="ln532">	virtual_card *vc = ai-&gt;vc;</a>
<a name="ln533">	shared_info *si = ai-&gt;si;</a>
<a name="ln534">	vuint8 *regs = ai-&gt;regs;</a>
<a name="ln535">	overlay_info *overlay = &amp;si-&gt;pending_overlay;</a>
<a name="ln536">	overlay_buffer_node *node = overlay-&gt;on;</a>
<a name="ln537">	crtc_info *crtc = &amp;si-&gt;crtc[crtc_idx];</a>
<a name="ln538"> </a>
<a name="ln539">	uint32 ecp_div;</a>
<a name="ln540">	uint32 v_inc, h_inc;</a>
<a name="ln541">	uint32 src_v_inc, src_h_inc;</a>
<a name="ln542">	uint32 src_left, src_top, src_right, src_bottom;</a>
<a name="ln543">	int32 dest_left, dest_top, dest_right, dest_bottom;</a>
<a name="ln544">	uint32 offset;</a>
<a name="ln545">	uint32 tmp;</a>
<a name="ln546">	uint32 p1_h_accum_init, p23_h_accum_init, p1_v_accum_init, p23_v_accum_init;</a>
<a name="ln547">	uint32 p1_active_lines, p23_active_lines;</a>
<a name="ln548">	hscale_factor *factors;</a>
<a name="ln549">	space_params *params;</a>
<a name="ln550">	</a>
<a name="ln551">	uint32 p1_h_inc, p23_h_inc;</a>
<a name="ln552">	uint32 p1_x_start, p1_x_end;</a>
<a name="ln553">	uint32 p23_x_start, p23_x_end;</a>
<a name="ln554">	</a>
<a name="ln555">	uint scale_ctrl;</a>
<a name="ln556">		</a>
<a name="ln557">	/*uint32 buffer[20*2];</a>
<a name="ln558">	uint idx = 0;*/</a>
<a name="ln559">	</a>
<a name="ln560">	SHOW_FLOW0( 0, &quot;&quot; );</a>
<a name="ln561">	</a>
<a name="ln562">	Radeon_SetColourKey( ai, &amp;overlay-&gt;ow );</a>
<a name="ln563">	</a>
<a name="ln564">	// overlay unit can only handle up to 175 MHz; if pixel clock is higher,</a>
<a name="ln565">	// only every second pixel is handled</a>
<a name="ln566">	// (this devider is gets written into PLL by InitOverlay,</a>
<a name="ln567">	//  so we don't need to do it ourself)</a>
<a name="ln568">	if( crtc-&gt;mode.timing.pixel_clock &lt; 175000 )</a>
<a name="ln569">		ecp_div = 0;</a>
<a name="ln570">	else</a>
<a name="ln571">		ecp_div = 1;</a>
<a name="ln572"> </a>
<a name="ln573"> </a>
<a name="ln574">	// scaling is independant of clipping, get this first</a>
<a name="ln575">	{</a>
<a name="ln576">		uint32 src_width, src_height;</a>
<a name="ln577"> </a>
<a name="ln578">		src_width = overlay-&gt;ov.width;</a>
<a name="ln579">		src_height = overlay-&gt;ov.height;</a>
<a name="ln580">	</a>
<a name="ln581">		// this is for graphics card</a>
<a name="ln582">		v_inc = (src_height &lt;&lt; 20) / overlay-&gt;ow.height;</a>
<a name="ln583">		h_inc = (src_width &lt;&lt; (12 + ecp_div)) / overlay-&gt;ow.width;</a>
<a name="ln584">		</a>
<a name="ln585">	</a>
<a name="ln586">		// this is for us	</a>
<a name="ln587">		src_v_inc = (src_height &lt;&lt; 16) / overlay-&gt;ow.height;</a>
<a name="ln588">		src_h_inc = (src_width &lt;&lt; 16) / overlay-&gt;ow.width;</a>
<a name="ln589">	}</a>
<a name="ln590">	</a>
<a name="ln591">	// calculate unclipped position/size</a>
<a name="ln592">	// TBD: I assume that overlay_window.offset_xyz is only a hint where </a>
<a name="ln593">	//      no overlay is visible; another interpretation were to zoom </a>
<a name="ln594">	//      the overlay so it fits into remaining space</a>
<a name="ln595">	src_left = (overlay-&gt;ov.h_start &lt;&lt; 16) + overlay-&gt;ow.offset_left * src_h_inc;</a>
<a name="ln596">	src_top = (overlay-&gt;ov.v_start &lt;&lt; 16) + overlay-&gt;ow.offset_top * src_v_inc;</a>
<a name="ln597">	src_right = ((overlay-&gt;ov.h_start + overlay-&gt;ov.width) &lt;&lt; 16) - </a>
<a name="ln598">		overlay-&gt;ow.offset_right * src_h_inc;</a>
<a name="ln599">	src_bottom = ((overlay-&gt;ov.v_start + overlay-&gt;ov.height) &lt;&lt; 16) - </a>
<a name="ln600">		overlay-&gt;ow.offset_top * src_v_inc;</a>
<a name="ln601">	dest_left = overlay-&gt;ow.h_start + overlay-&gt;ow.offset_left;</a>
<a name="ln602">	dest_top = overlay-&gt;ow.v_start + overlay-&gt;ow.offset_top;</a>
<a name="ln603">	dest_right = overlay-&gt;ow.h_start + overlay-&gt;ow.width - overlay-&gt;ow.offset_right;</a>
<a name="ln604">	dest_bottom = overlay-&gt;ow.v_start + overlay-&gt;ow.height - overlay-&gt;ow.offset_bottom;</a>
<a name="ln605">	</a>
<a name="ln606">	SHOW_FLOW( 3, &quot;ow: h=%d, v=%d, width=%d, height=%d&quot;,</a>
<a name="ln607">		overlay-&gt;ow.h_start, overlay-&gt;ow.v_start, </a>
<a name="ln608">		overlay-&gt;ow.width, overlay-&gt;ow.height );</a>
<a name="ln609">		</a>
<a name="ln610">	SHOW_FLOW( 3, &quot;offset_left=%d, offset_right=%d, offset_top=%d, offset_bottom=%d&quot;, </a>
<a name="ln611">		overlay-&gt;ow.offset_left, overlay-&gt;ow.offset_right, </a>
<a name="ln612">		overlay-&gt;ow.offset_top, overlay-&gt;ow.offset_bottom );</a>
<a name="ln613"> </a>
<a name="ln614">	</a>
<a name="ln615">	// apply virtual screen</a>
<a name="ln616">	dest_left -= vc-&gt;mode.h_display_start + crtc-&gt;rel_x;</a>
<a name="ln617">	dest_top -= vc-&gt;mode.v_display_start + crtc-&gt;rel_y;</a>
<a name="ln618">	dest_right -= vc-&gt;mode.h_display_start + crtc-&gt;rel_x;</a>
<a name="ln619">	dest_bottom -= vc-&gt;mode.v_display_start + crtc-&gt;rel_y;</a>
<a name="ln620"> </a>
<a name="ln621">	// clip to visible area</a>
<a name="ln622">	if( dest_left &lt; 0 ) {</a>
<a name="ln623">		src_left += -dest_left * src_h_inc;</a>
<a name="ln624">		dest_left = 0;</a>
<a name="ln625">	}</a>
<a name="ln626">	if( dest_top &lt; 0 ) {</a>
<a name="ln627">		src_top += -dest_top * src_v_inc;</a>
<a name="ln628">		dest_top = 0;</a>
<a name="ln629">	}</a>
<a name="ln630">	</a>
<a name="ln631">	SHOW_FLOW( 3, &quot;mode: w=%d, h=%d&quot;, </a>
<a name="ln632">		crtc-&gt;mode.timing.h_display, crtc-&gt;mode.timing.v_display );</a>
<a name="ln633">	</a>
<a name="ln634">	if( dest_right &gt; crtc-&gt;mode.timing.h_display )</a>
<a name="ln635">		dest_right = crtc-&gt;mode.timing.h_display;</a>
<a name="ln636">	if( dest_bottom &gt; crtc-&gt;mode.timing.v_display )</a>
<a name="ln637">		dest_bottom = crtc-&gt;mode.timing.v_display;</a>
<a name="ln638"> </a>
<a name="ln639">	SHOW_FLOW( 3, &quot;src=(%d, %d, %d, %d)&quot;, </a>
<a name="ln640">		src_left, src_top, src_right, src_bottom );</a>
<a name="ln641">	SHOW_FLOW( 3, &quot;dest=(%d, %d, %d, %d)&quot;, </a>
<a name="ln642">		dest_left, dest_top, dest_right, dest_bottom );</a>
<a name="ln643"> </a>
<a name="ln644"> </a>
<a name="ln645">	// especially with multi-screen modes the overlay may not be on screen at all</a>
<a name="ln646">	if( dest_left &gt;= dest_right || dest_top &gt;= dest_bottom ||</a>
<a name="ln647">		src_left &gt;= src_right || src_top &gt;= src_bottom )</a>
<a name="ln648">	{</a>
<a name="ln649">		Radeon_TempHideOverlay( ai );</a>
<a name="ln650">		goto done;</a>
<a name="ln651">	}</a>
<a name="ln652">	</a>
<a name="ln653"> </a>
<a name="ln654">	// let's calculate all those nice register values</a>
<a name="ln655">	SHOW_FLOW( 3, &quot;ati_space=%d&quot;, node-&gt;ati_space );</a>
<a name="ln656">	params = &amp;space_params_table[node-&gt;ati_space];</a>
<a name="ln657"> </a>
<a name="ln658">	// choose proper scaler</a>
<a name="ln659">	{</a>
<a name="ln660">		factors = getHScaleFactor( ai, params, src_left &gt;&gt; 16, src_right &gt;&gt; 16, &amp;h_inc );</a>
<a name="ln661">		if( factors == NULL )</a>
<a name="ln662">			return B_ERROR;</a>
<a name="ln663">			</a>
<a name="ln664">		p1_h_inc = factors-&gt;p1_step_by &gt; 0 ? </a>
<a name="ln665">			h_inc &gt;&gt; (factors-&gt;p1_step_by - 1) : h_inc;</a>
<a name="ln666">		p23_h_inc = </a>
<a name="ln667">			(factors-&gt;p23_step_by &gt; 0 ? h_inc &gt;&gt; (factors-&gt;p23_step_by - 1) : h_inc) </a>
<a name="ln668">			&gt;&gt; params-&gt;h_uv_sub_sample_shift;</a>
<a name="ln669">		</a>
<a name="ln670">		SHOW_FLOW( 3, &quot;p1_h_inc=%x, p23_h_inc=%x&quot;, p1_h_inc, p23_h_inc );</a>
<a name="ln671">	}</a>
<a name="ln672"> </a>
<a name="ln673">	// get register value for start/end position of overlay image (pixel-precise only)</a>
<a name="ln674">	{</a>
<a name="ln675">		uint32 p1_step_size, p23_step_size;</a>
<a name="ln676">		uint32 p1_left, p1_right, p1_width;</a>
<a name="ln677">		uint32 p23_left, p23_right, p23_width;</a>
<a name="ln678">		</a>
<a name="ln679">		p1_left = src_left &gt;&gt; 16;</a>
<a name="ln680">		p1_right = src_right &gt;&gt; 16;</a>
<a name="ln681">		p1_width = p1_right - p1_left;</a>
<a name="ln682">		</a>
<a name="ln683">		p1_step_size = factors-&gt;p1_step_by &gt; 0 ? (1 &lt;&lt; (factors-&gt;p1_step_by - 1)) : 1;</a>
<a name="ln684">		p1_x_start = p1_left % (16 &gt;&gt; params-&gt;bpp_shift);</a>
<a name="ln685">		p1_x_end = ((p1_x_start + p1_width - 1) / p1_step_size) * p1_step_size;</a>
<a name="ln686">		</a>
<a name="ln687">		SHOW_FLOW( 3, &quot;p1_x_start=%d, p1_x_end=%d&quot;, p1_x_start, p1_x_end );</a>
<a name="ln688">	</a>
<a name="ln689">		p23_left = (src_left &gt;&gt; 16) &gt;&gt; params-&gt;h_uv_sub_sample_shift;</a>
<a name="ln690">		p23_right = (src_right &gt;&gt; 16) &gt;&gt; params-&gt;h_uv_sub_sample_shift;</a>
<a name="ln691">		p23_width = p23_right - p23_left;</a>
<a name="ln692">	</a>
<a name="ln693">		p23_step_size = factors-&gt;p23_step_by &gt; 0 ? (1 &lt;&lt; (factors-&gt;p23_step_by - 1)) : 1;</a>
<a name="ln694">		// if resolution of Y and U/V differs but YUV are stored in one </a>
<a name="ln695">		// plane then UV alignment depends on Y data, therefore the hack</a>
<a name="ln696">		// (you are welcome to replace this with some cleaner code ;)</a>
<a name="ln697">		p23_x_start = p23_left % </a>
<a name="ln698">			((16 &gt;&gt; params-&gt;bpuv_shift) / </a>
<a name="ln699">			 (node-&gt;ati_space == 11 || node-&gt;ati_space == 12 ? 2 : 1));</a>
<a name="ln700">		p23_x_end = (int)((p23_x_start + p23_width - 1) / p23_step_size) * p23_step_size;</a>
<a name="ln701">		</a>
<a name="ln702">		SHOW_FLOW( 3, &quot;p23_x_start=%d, p23_x_end=%d&quot;, p23_x_start, p23_x_end );</a>
<a name="ln703">		</a>
<a name="ln704">		// get memory location of first word to be read by scaler</a>
<a name="ln705">		// (save relative offset for fast update)</a>
<a name="ln706">		si-&gt;active_overlay.rel_offset = (src_top &gt;&gt; 16) * node-&gt;buffer.bytes_per_row + </a>
<a name="ln707">			((p1_left &lt;&lt; params-&gt;bpp_shift) &amp; ~0xf);</a>
<a name="ln708">		offset = node-&gt;mem_offset + si-&gt;active_overlay.rel_offset;</a>
<a name="ln709">		</a>
<a name="ln710">		SHOW_FLOW( 3, &quot;rel_offset=%x&quot;, si-&gt;active_overlay.rel_offset );</a>
<a name="ln711">	}</a>
<a name="ln712">	</a>
<a name="ln713">	// get active lines for scaler</a>
<a name="ln714">	// (we could add additional blank lines for DVD letter box mode,</a>
<a name="ln715">	//  but this is not supported by API; additionally, this only makes</a>
<a name="ln716">	//  sense if want to put subtitles onto the black border, which is</a>
<a name="ln717">	//  supported neither)</a>
<a name="ln718">	{</a>
<a name="ln719">		uint16 int_top, int_bottom;</a>
<a name="ln720">		</a>
<a name="ln721">		int_top = src_top &gt;&gt; 16;</a>
<a name="ln722">		int_bottom = (src_bottom &gt;&gt; 16);</a>
<a name="ln723">		</a>
<a name="ln724">		p1_active_lines = int_bottom - int_top - 1;</a>
<a name="ln725">		p23_active_lines = </a>
<a name="ln726">			ceilShiftDiv( int_bottom - 1, params-&gt;v_uv_sub_sample_shift ) - </a>
<a name="ln727">			(int_top &gt;&gt; params-&gt;v_uv_sub_sample_shift);</a>
<a name="ln728">			</a>
<a name="ln729">		SHOW_FLOW( 3, &quot;p1_active_lines=%d, p23_active_lines=%d&quot;, </a>
<a name="ln730">			p1_active_lines, p23_active_lines );</a>
<a name="ln731">	}</a>
<a name="ln732">	</a>
<a name="ln733">	// if picture is stretched for flat panel, we need to scale all</a>
<a name="ln734">	// vertical values accordingly</a>
<a name="ln735">	// TBD: there is no description at all concerning this, so v_accum_init may</a>
<a name="ln736">	//      need to be initialized based on original value</a>
<a name="ln737">	{</a>
<a name="ln738">		if( (crtc-&gt;active_displays &amp; (dd_lvds | dd_dvi)) != 0 ) {</a>
<a name="ln739">			uint64 v_ratio;</a>
<a name="ln740">			</a>
<a name="ln741">			// convert 32.32 format to 16.16 format; else we </a>
<a name="ln742">			// cannot multiply two fixed point values without</a>
<a name="ln743">			// overflow</a>
<a name="ln744">			v_ratio = si-&gt;flatpanels[crtc-&gt;flatpanel_port].v_ratio &gt;&gt; (FIX_SHIFT - 16);</a>
<a name="ln745">			</a>
<a name="ln746">			v_inc = (v_inc * v_ratio) &gt;&gt; 16;</a>
<a name="ln747">		}</a>
<a name="ln748">		</a>
<a name="ln749">		SHOW_FLOW( 3, &quot;v_inc=%x&quot;, v_inc );</a>
<a name="ln750">	}</a>
<a name="ln751">	</a>
<a name="ln752">	// get initial horizontal scaler values, taking care of precharge</a>
<a name="ln753">	// don't ask questions about formulas - take them as is</a>
<a name="ln754">	// (TBD: home-brewed sub-pixel source clipping may be wrong, </a>
<a name="ln755">	//       especially for uv-planes)</a>
<a name="ln756">	{</a>
<a name="ln757">		uint32 p23_group_size;</a>
<a name="ln758"> </a>
<a name="ln759">	    tmp = ((src_left &amp; 0xffff) &gt;&gt; 11) + (</a>
<a name="ln760">	    	(</a>
<a name="ln761">		    	I2FF( p1_x_start % factors-&gt;group_size, 12 ) + </a>
<a name="ln762">		    	I2FF( 2.5, 12 ) + </a>
<a name="ln763">		    	p1_h_inc / 2 +</a>
<a name="ln764">		    	I2FF( 0.5, 12-5 )	// rounding</a>
<a name="ln765">	        ) &gt;&gt; (12 - 5));	// scaled by 1 &lt;&lt; 5</a>
<a name="ln766">	        </a>
<a name="ln767">	    SHOW_FLOW( 3, &quot;p1_h_accum_init=%x&quot;, tmp );</a>
<a name="ln768">	</a>
<a name="ln769">		p1_h_accum_init = </a>
<a name="ln770">			((tmp &lt;&lt; 15) &amp; RADEON_OV0_P1_H_ACCUM_INIT_MASK) |</a>
<a name="ln771">			((tmp &lt;&lt; 23) &amp; RADEON_OV0_P1_PRESHIFT_MASK);</a>
<a name="ln772">		</a>
<a name="ln773">		</a>
<a name="ln774">		p23_group_size = 2;</a>
<a name="ln775">		</a>
<a name="ln776">		tmp = ((src_left &amp; 0xffff) &gt;&gt; 11) + (</a>
<a name="ln777">			(</a>
<a name="ln778">				I2FF( p23_x_start % p23_group_size, 12 ) + </a>
<a name="ln779">				I2FF( 2.5, 12 ) +</a>
<a name="ln780">				p23_h_inc / 2 +</a>
<a name="ln781">				I2FF( 0.5, 12-5 )	// rounding </a>
<a name="ln782">			) &gt;&gt; (12 - 5)); // scaled by 1 &lt;&lt; 5</a>
<a name="ln783">	</a>
<a name="ln784">		SHOW_FLOW( 3, &quot;p23_h_accum_init=%x&quot;, tmp );</a>
<a name="ln785">	</a>
<a name="ln786">		p23_h_accum_init = </a>
<a name="ln787">			((tmp &lt;&lt; 15) &amp; RADEON_OV0_P23_H_ACCUM_INIT_MASK) |</a>
<a name="ln788">			((tmp &lt;&lt; 23) &amp; RADEON_OV0_P23_PRESHIFT_MASK);</a>
<a name="ln789">	}</a>
<a name="ln790"> </a>
<a name="ln791">	// get initial vertical scaler values, taking care of precharge</a>
<a name="ln792">	{</a>
<a name="ln793">		uint extra_full_line;</a>
<a name="ln794"> </a>
<a name="ln795">		extra_full_line = factors-&gt;p1_step_by == 0 ? 1 : 0;</a>
<a name="ln796">	</a>
<a name="ln797">	    tmp = ((src_top &amp; 0x0000ffff) &gt;&gt; 11) + (</a>
<a name="ln798">	    	(min( </a>
<a name="ln799">		    	I2FF( 1.5, 20 ) + I2FF( extra_full_line, 20 ) + v_inc / 2, </a>
<a name="ln800">	    		I2FF( 2.5, 20 ) + 2 * I2FF( extra_full_line, 20 )</a>
<a name="ln801">	    	 ) + I2FF( 0.5, 20-5 )) // rounding</a>
<a name="ln802">	    	&gt;&gt; (20 - 5)); // scaled by 1 &lt;&lt; 5</a>
<a name="ln803">	    	</a>
<a name="ln804">	    SHOW_FLOW( 3, &quot;p1_v_accum_init=%x&quot;, tmp );</a>
<a name="ln805">	</a>
<a name="ln806">		p1_v_accum_init = </a>
<a name="ln807">			((tmp &lt;&lt; 15) &amp; RADEON_OV0_P1_V_ACCUM_INIT_MASK) | 0x00000001;</a>
<a name="ln808"> </a>
<a name="ln809">	</a>
<a name="ln810">		extra_full_line = factors-&gt;p23_step_by == 0 ? 1 : 0;</a>
<a name="ln811">	</a>
<a name="ln812">		if( params-&gt;v_uv_sub_sample_shift &gt; 0 ) {</a>
<a name="ln813">			tmp = ((src_top &amp; 0x0000ffff) &gt;&gt; 11) + (</a>
<a name="ln814">				(min( </a>
<a name="ln815">					I2FF( 1.5, 20 ) + </a>
<a name="ln816">						I2FF( extra_full_line, 20 ) + </a>
<a name="ln817">						((v_inc / 2) &gt;&gt; params-&gt;v_uv_sub_sample_shift), </a>
<a name="ln818">					I2FF( 2.5, 20 ) + </a>
<a name="ln819">						2 * I2FF( extra_full_line, 20 )</a>
<a name="ln820">				 ) + I2FF( 0.5, 20-5 )) // rounding</a>
<a name="ln821">				&gt;&gt; (20 - 5)); // scaled by 1 &lt;&lt; 5</a>
<a name="ln822">		} else {</a>
<a name="ln823">			tmp = ((src_top &amp; 0x0000ffff) &gt;&gt; 11) + (</a>
<a name="ln824">				(</a>
<a name="ln825">					I2FF( 2.5, 20 ) + </a>
<a name="ln826">					2 * I2FF( extra_full_line, 20 ) +</a>
<a name="ln827">					I2FF( 0.5, 20-5 )	// rounding</a>
<a name="ln828">				) &gt;&gt; (20 - 5)); // scaled by 1 &lt;&lt; 5</a>
<a name="ln829">		}</a>
<a name="ln830">		</a>
<a name="ln831">		SHOW_FLOW( 3, &quot;p23_v_accum_init=%x&quot;, tmp );</a>
<a name="ln832">	</a>
<a name="ln833">		p23_v_accum_init = </a>
<a name="ln834">			((tmp &lt;&lt; 15) &amp; RADEON_OV0_P23_V_ACCUM_INIT_MASK) | 0x00000001;		</a>
<a name="ln835">	}</a>
<a name="ln836"> </a>
<a name="ln837">	// show me what you've got!</a>
<a name="ln838">	// we could lock double buffering of overlay unit during update</a>
<a name="ln839">	// (new values are copied during vertical blank, so if we've updated</a>
<a name="ln840">	// only some of them, you get a whole frame of mismatched values)</a>
<a name="ln841">	// but during tests I couldn't get the artifacts go away, so</a>
<a name="ln842">	// we use the dangerous way which has the pro to not require any</a>
<a name="ln843">	// waiting</a>
<a name="ln844">	</a>
<a name="ln845">	// let's try to lock overlay unit</a>
<a name="ln846">	// we had to wait now until the lock takes effect, but this is</a>
<a name="ln847">	// impossible with CCE; perhaps we have to convert this code to </a>
<a name="ln848">	// direct register access; did that - let's see what happens...</a>
<a name="ln849">	OUTREG( regs, RADEON_OV0_REG_LOAD_CNTL, RADEON_REG_LD_CTL_LOCK );</a>
<a name="ln850">	</a>
<a name="ln851">	// wait until register access is locked</a>
<a name="ln852">	while( (INREG( regs, RADEON_OV0_REG_LOAD_CNTL) </a>
<a name="ln853">		&amp; RADEON_REG_LD_CTL_LOCK_READBACK) == 0 )</a>
<a name="ln854">		;</a>
<a name="ln855">	</a>
<a name="ln856">	OUTREG( regs, RADEON_OV0_VID_BUF0_BASE_ADRS, offset );</a>
<a name="ln857">	OUTREG( regs, RADEON_OV0_VID_BUF_PITCH0_VALUE, node-&gt;buffer.bytes_per_row );</a>
<a name="ln858">	OUTREG( regs, RADEON_OV0_H_INC, p1_h_inc | (p23_h_inc &lt;&lt; 16) );</a>
<a name="ln859">	OUTREG( regs, RADEON_OV0_STEP_BY, factors-&gt;p1_step_by | (factors-&gt;p23_step_by &lt;&lt; 8) );</a>
<a name="ln860">	OUTREG( regs, RADEON_OV0_V_INC, v_inc );</a>
<a name="ln861">	</a>
<a name="ln862">	OUTREG( regs,</a>
<a name="ln863">		crtc-&gt;crtc_idx == 0 ? RADEON_OV0_Y_X_START : RADEON_OV1_Y_X_START, </a>
<a name="ln864">		(dest_left) | (dest_top &lt;&lt; 16) );</a>
<a name="ln865">	OUTREG( regs, </a>
<a name="ln866">		crtc-&gt;crtc_idx == 0 ? RADEON_OV0_Y_X_END : RADEON_OV1_Y_X_END,</a>
<a name="ln867">		(dest_right - 1) | ((dest_bottom - 1) &lt;&lt; 16) );</a>
<a name="ln868"> </a>
<a name="ln869">	OUTREG( regs, RADEON_OV0_P1_BLANK_LINES_AT_TOP, </a>
<a name="ln870">		RADEON_P1_BLNK_LN_AT_TOP_M1_MASK | (p1_active_lines &lt;&lt; 16) );</a>
<a name="ln871">	OUTREG( regs, RADEON_OV0_P1_X_START_END, p1_x_end | (p1_x_start &lt;&lt; 16) );</a>
<a name="ln872">	OUTREG( regs, RADEON_OV0_P1_H_ACCUM_INIT, p1_h_accum_init );</a>
<a name="ln873">	OUTREG( regs, RADEON_OV0_P1_V_ACCUM_INIT, p1_v_accum_init );</a>
<a name="ln874">	</a>
<a name="ln875">	OUTREG( regs, RADEON_OV0_P23_BLANK_LINES_AT_TOP, </a>
<a name="ln876">		RADEON_P23_BLNK_LN_AT_TOP_M1_MASK | (p23_active_lines &lt;&lt; 16) );</a>
<a name="ln877">	OUTREG( regs, RADEON_OV0_P2_X_START_END, </a>
<a name="ln878">		p23_x_end | (p23_x_start &lt;&lt; 16) );</a>
<a name="ln879">	OUTREG( regs, RADEON_OV0_P3_X_START_END, </a>
<a name="ln880">		p23_x_end | (p23_x_start &lt;&lt; 16) );</a>
<a name="ln881">	OUTREG( regs, RADEON_OV0_P23_H_ACCUM_INIT, p23_h_accum_init );</a>
<a name="ln882">	OUTREG( regs, RADEON_OV0_P23_V_ACCUM_INIT, p23_v_accum_init );</a>
<a name="ln883">	</a>
<a name="ln884">	OUTREG( regs, RADEON_OV0_TEST, node-&gt;test_reg );</a>
<a name="ln885">	</a>
<a name="ln886">	scale_ctrl = RADEON_SCALER_ENABLE | </a>
<a name="ln887">		RADEON_SCALER_DOUBLE_BUFFER | </a>
<a name="ln888">		(node-&gt;ati_space &lt;&lt; 8) | </a>
<a name="ln889">		/* RADEON_SCALER_ADAPTIVE_DEINT | */</a>
<a name="ln890">		RADEON_SCALER_BURST_PER_PLANE |</a>
<a name="ln891">		(crtc-&gt;crtc_idx == 0 ? 0 : RADEON_SCALER_CRTC_SEL );</a>
<a name="ln892">		</a>
<a name="ln893">	switch (node-&gt;ati_space &lt;&lt; 8) {</a>
<a name="ln894">		case RADEON_SCALER_SOURCE_15BPP: // RGB15</a>
<a name="ln895">		case RADEON_SCALER_SOURCE_16BPP:</a>
<a name="ln896">		case RADEON_SCALER_SOURCE_32BPP:</a>
<a name="ln897">			OUTREG( regs, RADEON_OV0_SCALE_CNTL, scale_ctrl | </a>
<a name="ln898">							RADEON_SCALER_LIN_TRANS_BYPASS);</a>
<a name="ln899">			break;</a>
<a name="ln900">		case RADEON_SCALER_SOURCE_VYUY422: // VYUY422</a>
<a name="ln901">		case RADEON_SCALER_SOURCE_YVYU422: // YVYU422</a>
<a name="ln902">			OUTREG( regs, RADEON_OV0_SCALE_CNTL, scale_ctrl);</a>
<a name="ln903">			break;</a>
<a name="ln904">		default:</a>
<a name="ln905">			SHOW_FLOW(4, &quot;What overlay format is this??? %d&quot;, node-&gt;ati_space);</a>
<a name="ln906">			OUTREG( regs, RADEON_OV0_SCALE_CNTL, scale_ctrl |</a>
<a name="ln907">			 (( ai-&gt;si-&gt;asic &gt;= rt_r200) ? R200_SCALER_TEMPORAL_DEINT : 0));</a>
<a name="ln908">		</a>
<a name="ln909">	}</a>
<a name="ln910">	</a>
<a name="ln911">	si-&gt;overlay_mgr.auto_flip_reg ^= RADEON_OV0_SOFT_EOF_TOGGLE;</a>
<a name="ln912">	</a>
<a name="ln913">	OUTREG( regs, RADEON_OV0_AUTO_FLIP_CNTRL, </a>
<a name="ln914">		si-&gt;overlay_mgr.auto_flip_reg );</a>
<a name="ln915">	</a>
<a name="ln916">	OUTREG( regs, RADEON_OV0_REG_LOAD_CNTL, 0 );</a>
<a name="ln917">	</a>
<a name="ln918">done:</a>
<a name="ln919">	ai-&gt;si-&gt;active_overlay.on = ai-&gt;si-&gt;pending_overlay.on;</a>
<a name="ln920">	ai-&gt;si-&gt;active_overlay.ow = ai-&gt;si-&gt;pending_overlay.ow;</a>
<a name="ln921">	ai-&gt;si-&gt;active_overlay.ov = ai-&gt;si-&gt;pending_overlay.ov;</a>
<a name="ln922">	ai-&gt;si-&gt;active_overlay.ob = ai-&gt;si-&gt;pending_overlay.ob;</a>
<a name="ln923">	ai-&gt;si-&gt;active_overlay.h_display_start = vc-&gt;mode.h_display_start;</a>
<a name="ln924">	ai-&gt;si-&gt;active_overlay.v_display_start = vc-&gt;mode.v_display_start;</a>
<a name="ln925"> </a>
<a name="ln926">	return B_OK;</a>
<a name="ln927">}</a>
<a name="ln928"> </a>
<a name="ln929"> </a>
<a name="ln930">// hide overlay, but not permanently</a>
<a name="ln931">void Radeon_TempHideOverlay( </a>
<a name="ln932">	accelerator_info *ai )</a>
<a name="ln933">{</a>
<a name="ln934">	SHOW_FLOW0( 3, &quot;&quot; );</a>
<a name="ln935"> </a>
<a name="ln936">	OUTREG( ai-&gt;regs, RADEON_OV0_SCALE_CNTL, 0 );</a>
<a name="ln937">}</a>
<a name="ln938"> </a>
<a name="ln939"> </a>
<a name="ln940">// hide overlay (can be called even if there is none visible)</a>
<a name="ln941">void Radeon_HideOverlay( </a>
<a name="ln942">	accelerator_info *ai )</a>
<a name="ln943">{</a>
<a name="ln944">	shared_info *si = ai-&gt;si;</a>
<a name="ln945">	</a>
<a name="ln946">	Radeon_TempHideOverlay( ai );</a>
<a name="ln947"> </a>
<a name="ln948">	// remember that there is no overlay to be shown	</a>
<a name="ln949">	si-&gt;active_overlay.on = NULL;</a>
<a name="ln950">	si-&gt;active_overlay.prev_on = NULL;</a>
<a name="ln951">	si-&gt;pending_overlay.on = NULL;</a>
<a name="ln952">	</a>
<a name="ln953">	// invalidate active head so it will be setup again once</a>
<a name="ln954">	// a new overlay is shown</a>
<a name="ln955">	si-&gt;active_overlay.crtc_idx = -1;</a>
<a name="ln956">}</a>
<a name="ln957"> </a>
<a name="ln958"> </a>
<a name="ln959">// show new overlay buffer with same parameters as last one</a>
<a name="ln960">static void Radeon_ReplaceOverlayBuffer( </a>
<a name="ln961">	accelerator_info *ai )</a>
<a name="ln962">{</a>
<a name="ln963">#if 0</a>
<a name="ln964">	shared_info *si = ai-&gt;si;</a>
<a name="ln965">	vuint8 *regs = ai-&gt;regs;</a>
<a name="ln966">	uint32 offset;</a>
<a name="ln967">	int /*old_buf, */new_buf;</a>
<a name="ln968">	</a>
<a name="ln969">	offset = si-&gt;pending_overlay.on-&gt;mem_offset + si-&gt;active_overlay.rel_offset;</a>
<a name="ln970"> </a>
<a name="ln971">	/*old_buf = si-&gt;overlay_mgr.auto_flip_reg &amp; RADEON_OV0_SOFT_BUF_NUM_MASK;</a>
<a name="ln972">	new_buf = old_buf == 0 ? 3 : 0;</a>
<a name="ln973">	si-&gt;overlay_mgr.auto_flip_reg &amp;= ~RADEON_OV0_SOFT_BUF_NUM_MASK;</a>
<a name="ln974">	si-&gt;overlay_mgr.auto_flip_reg |= new_buf;*/</a>
<a name="ln975">	new_buf = 0;</a>
<a name="ln976">	</a>
<a name="ln977">	// lock overlay registers</a>
<a name="ln978">/*	OUTREG( regs, RADEON_OV0_REG_LOAD_CNTL, RADEON_REG_LD_CTL_LOCK );</a>
<a name="ln979">	</a>
<a name="ln980">	// wait until register access is locked</a>
<a name="ln981">	while( (INREG( regs, RADEON_OV0_REG_LOAD_CNTL) </a>
<a name="ln982">		&amp; RADEON_REG_LD_CTL_LOCK_READBACK) == 0 )</a>
<a name="ln983">		;*/</a>
<a name="ln984">	</a>
<a name="ln985">	// setup new buffer</a>
<a name="ln986">	/*OUTREG( regs, </a>
<a name="ln987">		new_buf == 0 ? RADEON_OV0_VID_BUF_PITCH0_VALUE : RADEON_OV0_VID_BUF_PITCH1_VALUE, </a>
<a name="ln988">		si-&gt;pending_overlay.on-&gt;buffer.bytes_per_row );*/</a>
<a name="ln989">	OUTREG( regs, </a>
<a name="ln990">		new_buf == 0 ? RADEON_OV0_VID_BUF0_BASE_ADRS : RADEON_OV0_VID_BUF3_BASE_ADRS, </a>
<a name="ln991">		offset | (new_buf == 0 ? 0 : RADEON_VIF_BUF0_PITCH_SEL));</a>
<a name="ln992">	</a>
<a name="ln993">	// make changes visible	</a>
<a name="ln994">	si-&gt;overlay_mgr.auto_flip_reg ^= RADEON_OV0_SOFT_EOF_TOGGLE;</a>
<a name="ln995">	</a>
<a name="ln996">	OUTREG( regs, RADEON_OV0_AUTO_FLIP_CNTRL, si-&gt;overlay_mgr.auto_flip_reg );</a>
<a name="ln997">	</a>
<a name="ln998">	// unlock overlay registers</a>
<a name="ln999">//	OUTREG( regs, RADEON_OV0_REG_LOAD_CNTL, 0 );</a>
<a name="ln1000"> </a>
<a name="ln1001">	ai-&gt;si-&gt;active_overlay.on = ai-&gt;si-&gt;pending_overlay.on;</a>
<a name="ln1002">#else</a>
<a name="ln1003">	shared_info *si = ai-&gt;si;</a>
<a name="ln1004">	uint32 offset;</a>
<a name="ln1005">	</a>
<a name="ln1006">	if ( ai-&gt;si-&gt;acc_dma )</a>
<a name="ln1007">	{</a>
<a name="ln1008">		START_IB();</a>
<a name="ln1009">	</a>
<a name="ln1010">		offset = si-&gt;pending_overlay.on-&gt;mem_offset + si-&gt;active_overlay.rel_offset;</a>
<a name="ln1011">		</a>
<a name="ln1012">		WRITE_IB_REG( RADEON_OV0_VID_BUF0_BASE_ADRS, offset);</a>
<a name="ln1013">		</a>
<a name="ln1014">		si-&gt;overlay_mgr.auto_flip_reg ^= RADEON_OV0_SOFT_EOF_TOGGLE;</a>
<a name="ln1015">		WRITE_IB_REG( RADEON_OV0_AUTO_FLIP_CNTRL, si-&gt;overlay_mgr.auto_flip_reg );</a>
<a name="ln1016">		</a>
<a name="ln1017">		SUBMIT_IB();</a>
<a name="ln1018">	} else {</a>
<a name="ln1019">		Radeon_WaitForFifo( ai, 2 );</a>
<a name="ln1020">		offset = si-&gt;pending_overlay.on-&gt;mem_offset + si-&gt;active_overlay.rel_offset;</a>
<a name="ln1021">		</a>
<a name="ln1022">		OUTREG( ai-&gt;regs, RADEON_OV0_VID_BUF0_BASE_ADRS, offset);</a>
<a name="ln1023">		</a>
<a name="ln1024">		si-&gt;overlay_mgr.auto_flip_reg ^= RADEON_OV0_SOFT_EOF_TOGGLE;</a>
<a name="ln1025">		OUTREG( ai-&gt;regs, RADEON_OV0_AUTO_FLIP_CNTRL, si-&gt;overlay_mgr.auto_flip_reg );</a>
<a name="ln1026">	}	</a>
<a name="ln1027">	ai-&gt;si-&gt;active_overlay.on = ai-&gt;si-&gt;pending_overlay.on;</a>
<a name="ln1028">#endif</a>
<a name="ln1029">}</a>
<a name="ln1030"> </a>
<a name="ln1031"> </a>
<a name="ln1032">// get number of pixels of overlay shown on virtual port</a>
<a name="ln1033">static int getIntersectArea( </a>
<a name="ln1034">	accelerator_info *ai, overlay_window *ow, crtc_info *crtc )</a>
<a name="ln1035">{</a>
<a name="ln1036">	virtual_card *vc = ai-&gt;vc;</a>
<a name="ln1037">	int left, top, right, bottom;</a>
<a name="ln1038">	</a>
<a name="ln1039">	left = ow-&gt;h_start - (vc-&gt;mode.h_display_start + crtc-&gt;rel_x);</a>
<a name="ln1040">	top = ow-&gt;v_start - (vc-&gt;mode.v_display_start + crtc-&gt;rel_y);</a>
<a name="ln1041">	right = left + ow-&gt;width;</a>
<a name="ln1042">	bottom = top + ow-&gt;height;</a>
<a name="ln1043">	</a>
<a name="ln1044">	if( left &lt; 0 )</a>
<a name="ln1045">		left = 0;</a>
<a name="ln1046">	if( top &lt; 0 )</a>
<a name="ln1047">		top = 0;</a>
<a name="ln1048">	if( right &gt; crtc-&gt;mode.timing.h_display )</a>
<a name="ln1049">		right = crtc-&gt;mode.timing.h_display;</a>
<a name="ln1050">	if( bottom &gt; crtc-&gt;mode.timing.v_display )</a>
<a name="ln1051">		bottom = crtc-&gt;mode.timing.v_display;</a>
<a name="ln1052">		</a>
<a name="ln1053">	if( right &lt; left || bottom &lt; top )</a>
<a name="ln1054">		return 0;</a>
<a name="ln1055">		</a>
<a name="ln1056">	return (right - left) * (bottom - top);</a>
<a name="ln1057">}</a>
<a name="ln1058"> </a>
<a name="ln1059"> </a>
<a name="ln1060">// update overlay, to be called whenever something in terms of </a>
<a name="ln1061">// overlay have or can have been changed</a>
<a name="ln1062">status_t Radeon_UpdateOverlay( </a>
<a name="ln1063">	accelerator_info *ai )</a>
<a name="ln1064">{</a>
<a name="ln1065">	virtual_card *vc = ai-&gt;vc;</a>
<a name="ln1066">	shared_info *si = ai-&gt;si;</a>
<a name="ln1067">	int crtc_idx;</a>
<a name="ln1068"> </a>
<a name="ln1069">	float brightness = 0.0f;</a>
<a name="ln1070">	float contrast = 1.0f;</a>
<a name="ln1071">	float saturation = 1.0f;</a>
<a name="ln1072">	float hue = 0.0f;</a>
<a name="ln1073">	int32 ref = 0;</a>
<a name="ln1074"> </a>
<a name="ln1075">	SHOW_FLOW0( 3, &quot;&quot; );</a>
<a name="ln1076"> </a>
<a name="ln1077">	// don't mess around with overlay of someone else</a>
<a name="ln1078">	if ( !vc-&gt;uses_overlay )</a>
<a name="ln1079">		return B_OK;</a>
<a name="ln1080"> </a>
<a name="ln1081">	// make sure there really is an overlay</a>
<a name="ln1082">	if ( si-&gt;pending_overlay.on == NULL )</a>
<a name="ln1083">		return B_OK;</a>
<a name="ln1084"> </a>
<a name="ln1085">	// verify that the overlay is still valid</a>
<a name="ln1086">	if ((uintptr_t)si-&gt;pending_overlay.ot != si-&gt;overlay_mgr.token )</a>
<a name="ln1087">		return B_BAD_VALUE;</a>
<a name="ln1088"> </a>
<a name="ln1089">	if ( vc-&gt;different_heads &gt; 1 ) {</a>
<a name="ln1090">		int area0, area1;</a>
<a name="ln1091"> </a>
<a name="ln1092">		// determine on which port most of the overlay is shown</a>
<a name="ln1093">		area0 = getIntersectArea( ai, &amp;si-&gt;pending_overlay.ow, &amp;si-&gt;crtc[0] );</a>
<a name="ln1094">		area1 = getIntersectArea( ai, &amp;si-&gt;pending_overlay.ow, &amp;si-&gt;crtc[0] );</a>
<a name="ln1095"> </a>
<a name="ln1096">		SHOW_FLOW( 3, &quot;area0=%d, area1=%d&quot;, area0, area1 );</a>
<a name="ln1097"> </a>
<a name="ln1098">		if (area0 &gt;= area1 )</a>
<a name="ln1099">			crtc_idx = 0;</a>
<a name="ln1100">		else</a>
<a name="ln1101">			crtc_idx = 1;</a>
<a name="ln1102"> </a>
<a name="ln1103">	} else if ( vc-&gt;independant_heads &gt; 1 ) {</a>
<a name="ln1104">		// both ports show the same, use &quot;swap displays&quot; to decide</a>
<a name="ln1105">		// where to show the overlay (to be improved as this flag isn't</a>
<a name="ln1106">		// really designed for that)</a>
<a name="ln1107">		if ( vc-&gt;swap_displays )</a>
<a name="ln1108">			crtc_idx = 1;</a>
<a name="ln1109">		else</a>
<a name="ln1110">			crtc_idx = 0;</a>
<a name="ln1111">			</a>
<a name="ln1112">	} else {</a>
<a name="ln1113">	</a>
<a name="ln1114">		// one crtc used only - pick the one that we use</a>
<a name="ln1115">		crtc_idx = vc-&gt;used_crtc[0] ? 0 : 1;</a>
<a name="ln1116">	}</a>
<a name="ln1117">	</a>
<a name="ln1118">	si-&gt;pending_overlay.crtc_idx = crtc_idx;</a>
<a name="ln1119"> </a>
<a name="ln1120">	// only update registers that have been changed to minimize work</a>
<a name="ln1121">	if( si-&gt;active_overlay.crtc_idx != si-&gt;pending_overlay.crtc_idx ) {</a>
<a name="ln1122">		Radeon_InitOverlay( ai, crtc_idx );</a>
<a name="ln1123">	} </a>
<a name="ln1124">	</a>
<a name="ln1125">	if( si-&gt;active_overlay.ob.space != si-&gt;pending_overlay.ob.space ) {</a>
<a name="ln1126">		Radeon_SetTransform( ai, brightness, contrast, saturation, hue, 0, 0, 0, ref );</a>
<a name="ln1127">	}</a>
<a name="ln1128"> </a>
<a name="ln1129">	if( memcmp( &amp;si-&gt;active_overlay.ow, &amp;si-&gt;pending_overlay.ow, sizeof( si-&gt;active_overlay.ow )) != 0 || </a>
<a name="ln1130">		memcmp( &amp;si-&gt;active_overlay.ov, &amp;si-&gt;pending_overlay.ov, sizeof( si-&gt;active_overlay.ov )) != 0 ||</a>
<a name="ln1131">		si-&gt;active_overlay.h_display_start != vc-&gt;mode.h_display_start ||</a>
<a name="ln1132">		si-&gt;active_overlay.v_display_start != vc-&gt;mode.v_display_start ||</a>
<a name="ln1133">		si-&gt;active_overlay.ob.width != si-&gt;pending_overlay.ob.width ||</a>
<a name="ln1134">		si-&gt;active_overlay.ob.height != si-&gt;pending_overlay.ob.height ||</a>
<a name="ln1135">		si-&gt;active_overlay.ob.bytes_per_row != si-&gt;pending_overlay.ob.bytes_per_row )</a>
<a name="ln1136">		Radeon_ShowOverlay( ai, crtc_idx );</a>
<a name="ln1137">		</a>
<a name="ln1138">	else if( si-&gt;active_overlay.on != si-&gt;pending_overlay.on )</a>
<a name="ln1139">		Radeon_ReplaceOverlayBuffer( ai );</a>
<a name="ln1140">		</a>
<a name="ln1141">	SHOW_FLOW0( 3, &quot;success&quot; );</a>
<a name="ln1142">	</a>
<a name="ln1143">	return B_OK;</a>
<a name="ln1144">}</a>

</code></pre>
<div class="balloon" rel="852"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v712/" target="_blank">V712</a> Be advised that compiler may delete this cycle or make it infinity. Use volatile variable(s) or synchronization primitives to avoid this.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
