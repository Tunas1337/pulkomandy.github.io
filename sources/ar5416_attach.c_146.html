
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ar5416_attach.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * SPDX-License-Identifier: ISC</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2002-2008 Sam Leffler, Errno Consulting</a>
<a name="ln5"> * Copyright (c) 2002-2008 Atheros Communications, Inc.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Permission to use, copy, modify, and/or distribute this software for any</a>
<a name="ln8"> * purpose with or without fee is hereby granted, provided that the above</a>
<a name="ln9"> * copyright notice and this permission notice appear in all copies.</a>
<a name="ln10"> *</a>
<a name="ln11"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES</a>
<a name="ln12"> * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</a>
<a name="ln13"> * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR</a>
<a name="ln14"> * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</a>
<a name="ln15"> * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</a>
<a name="ln16"> * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</a>
<a name="ln17"> * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</a>
<a name="ln18"> *</a>
<a name="ln19"> * $FreeBSD: releng/12.0/sys/dev/ath/ath_hal/ar5416/ar5416_attach.c 326695 2017-12-08 15:57:29Z pfg $</a>
<a name="ln20"> */</a>
<a name="ln21">#include &quot;opt_ah.h&quot;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;ah.h&quot;</a>
<a name="ln24">#include &quot;ah_internal.h&quot;</a>
<a name="ln25">#include &quot;ah_devid.h&quot;</a>
<a name="ln26"> </a>
<a name="ln27">#include &quot;ah_eeprom_v14.h&quot;</a>
<a name="ln28"> </a>
<a name="ln29">#include &quot;ar5416/ar5416.h&quot;</a>
<a name="ln30">#include &quot;ar5416/ar5416reg.h&quot;</a>
<a name="ln31">#include &quot;ar5416/ar5416phy.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;ar5416/ar5416.ini&quot;</a>
<a name="ln34"> </a>
<a name="ln35">static void ar5416ConfigPCIE(struct ath_hal *ah, HAL_BOOL restore,</a>
<a name="ln36">		HAL_BOOL power_off);</a>
<a name="ln37">static void ar5416DisablePCIE(struct ath_hal *ah);</a>
<a name="ln38">static void ar5416WriteIni(struct ath_hal *ah,</a>
<a name="ln39">	    const struct ieee80211_channel *chan);</a>
<a name="ln40">static void ar5416SpurMitigate(struct ath_hal *ah,</a>
<a name="ln41">	    const struct ieee80211_channel *chan);</a>
<a name="ln42"> </a>
<a name="ln43">static void</a>
<a name="ln44">ar5416AniSetup(struct ath_hal *ah)</a>
<a name="ln45">{</a>
<a name="ln46">	static const struct ar5212AniParams aniparams = {</a>
<a name="ln47">		.maxNoiseImmunityLevel	= 4,	/* levels 0..4 */</a>
<a name="ln48">		.totalSizeDesired	= { -55, -55, -55, -55, -62 },</a>
<a name="ln49">		.coarseHigh		= { -14, -14, -14, -14, -12 },</a>
<a name="ln50">		.coarseLow		= { -64, -64, -64, -64, -70 },</a>
<a name="ln51">		.firpwr			= { -78, -78, -78, -78, -80 },</a>
<a name="ln52">		.maxSpurImmunityLevel	= 7,</a>
<a name="ln53">		.cycPwrThr1		= { 2, 4, 6, 8, 10, 12, 14, 16 },</a>
<a name="ln54">		.maxFirstepLevel	= 2,	/* levels 0..2 */</a>
<a name="ln55">		.firstep		= { 0, 4, 8 },</a>
<a name="ln56">		.ofdmTrigHigh		= 500,</a>
<a name="ln57">		.ofdmTrigLow		= 200,</a>
<a name="ln58">		.cckTrigHigh		= 200,</a>
<a name="ln59">		.cckTrigLow		= 100,</a>
<a name="ln60">		.rssiThrHigh		= 40,</a>
<a name="ln61">		.rssiThrLow		= 7,</a>
<a name="ln62">		.period			= 100,</a>
<a name="ln63">	};</a>
<a name="ln64">	/* NB: disable ANI noise immmunity for reliable RIFS rx */</a>
<a name="ln65">	AH5416(ah)-&gt;ah_ani_function &amp;= ~(1 &lt;&lt; HAL_ANI_NOISE_IMMUNITY_LEVEL);</a>
<a name="ln66">	ar5416AniAttach(ah, &amp;aniparams, &amp;aniparams, AH_TRUE);</a>
<a name="ln67">}</a>
<a name="ln68"> </a>
<a name="ln69">/*</a>
<a name="ln70"> * AR5416 doesn't do OLC or temperature compensation.</a>
<a name="ln71"> */</a>
<a name="ln72">static void</a>
<a name="ln73">ar5416olcInit(struct ath_hal *ah)</a>
<a name="ln74">{</a>
<a name="ln75">}</a>
<a name="ln76"> </a>
<a name="ln77">static void</a>
<a name="ln78">ar5416olcTempCompensation(struct ath_hal *ah)</a>
<a name="ln79">{</a>
<a name="ln80">}</a>
<a name="ln81"> </a>
<a name="ln82">/*</a>
<a name="ln83"> * Attach for an AR5416 part.</a>
<a name="ln84"> */</a>
<a name="ln85">void</a>
<a name="ln86">ar5416InitState(struct ath_hal_5416 *ahp5416, uint16_t devid, HAL_SOFTC sc,</a>
<a name="ln87">	HAL_BUS_TAG st, HAL_BUS_HANDLE sh, HAL_STATUS *status)</a>
<a name="ln88">{</a>
<a name="ln89">	struct ath_hal_5212 *ahp;</a>
<a name="ln90">	struct ath_hal *ah;</a>
<a name="ln91"> </a>
<a name="ln92">	ahp = &amp;ahp5416-&gt;ah_5212;</a>
<a name="ln93">	ar5212InitState(ahp, devid, sc, st, sh, status);</a>
<a name="ln94">	ah = &amp;ahp-&gt;ah_priv.h;</a>
<a name="ln95"> </a>
<a name="ln96">	/* override 5212 methods for our needs */</a>
<a name="ln97">	ah-&gt;ah_magic			= AR5416_MAGIC;</a>
<a name="ln98">	ah-&gt;ah_getRateTable		= ar5416GetRateTable;</a>
<a name="ln99">	ah-&gt;ah_detach			= ar5416Detach;</a>
<a name="ln100"> </a>
<a name="ln101">	/* Reset functions */</a>
<a name="ln102">	ah-&gt;ah_reset			= ar5416Reset;</a>
<a name="ln103">	ah-&gt;ah_phyDisable		= ar5416PhyDisable;</a>
<a name="ln104">	ah-&gt;ah_disable			= ar5416Disable;</a>
<a name="ln105">	ah-&gt;ah_configPCIE		= ar5416ConfigPCIE;</a>
<a name="ln106">	ah-&gt;ah_disablePCIE		= ar5416DisablePCIE;</a>
<a name="ln107">	ah-&gt;ah_perCalibration		= ar5416PerCalibration;</a>
<a name="ln108">	ah-&gt;ah_perCalibrationN		= ar5416PerCalibrationN;</a>
<a name="ln109">	ah-&gt;ah_resetCalValid		= ar5416ResetCalValid;</a>
<a name="ln110">	ah-&gt;ah_setTxPowerLimit		= ar5416SetTxPowerLimit;</a>
<a name="ln111">	ah-&gt;ah_setTxPower		= ar5416SetTransmitPower;</a>
<a name="ln112">	ah-&gt;ah_setBoardValues		= ar5416SetBoardValues;</a>
<a name="ln113"> </a>
<a name="ln114">	/* Transmit functions */</a>
<a name="ln115">	ah-&gt;ah_stopTxDma		= ar5416StopTxDma;</a>
<a name="ln116">	ah-&gt;ah_setupTxDesc		= ar5416SetupTxDesc;</a>
<a name="ln117">	ah-&gt;ah_setupXTxDesc		= ar5416SetupXTxDesc;</a>
<a name="ln118">	ah-&gt;ah_fillTxDesc		= ar5416FillTxDesc;</a>
<a name="ln119">	ah-&gt;ah_procTxDesc		= ar5416ProcTxDesc;</a>
<a name="ln120">	ah-&gt;ah_getTxCompletionRates	= ar5416GetTxCompletionRates;</a>
<a name="ln121">	ah-&gt;ah_setupTxQueue		= ar5416SetupTxQueue;</a>
<a name="ln122">	ah-&gt;ah_resetTxQueue		= ar5416ResetTxQueue;</a>
<a name="ln123"> </a>
<a name="ln124">	/* Receive Functions */</a>
<a name="ln125">	ah-&gt;ah_getRxFilter		= ar5416GetRxFilter;</a>
<a name="ln126">	ah-&gt;ah_setRxFilter		= ar5416SetRxFilter;</a>
<a name="ln127">	ah-&gt;ah_stopDmaReceive		= ar5416StopDmaReceive;</a>
<a name="ln128">	ah-&gt;ah_startPcuReceive		= ar5416StartPcuReceive;</a>
<a name="ln129">	ah-&gt;ah_stopPcuReceive		= ar5416StopPcuReceive;</a>
<a name="ln130">	ah-&gt;ah_setupRxDesc		= ar5416SetupRxDesc;</a>
<a name="ln131">	ah-&gt;ah_procRxDesc		= ar5416ProcRxDesc;</a>
<a name="ln132">	ah-&gt;ah_rxMonitor		= ar5416RxMonitor;</a>
<a name="ln133">	ah-&gt;ah_aniPoll			= ar5416AniPoll;</a>
<a name="ln134">	ah-&gt;ah_procMibEvent		= ar5416ProcessMibIntr;</a>
<a name="ln135"> </a>
<a name="ln136">	/* Misc Functions */</a>
<a name="ln137">	ah-&gt;ah_getCapability		= ar5416GetCapability;</a>
<a name="ln138">	ah-&gt;ah_setCapability		= ar5416SetCapability;</a>
<a name="ln139">	ah-&gt;ah_getDiagState		= ar5416GetDiagState;</a>
<a name="ln140">	ah-&gt;ah_setLedState		= ar5416SetLedState;</a>
<a name="ln141">	ah-&gt;ah_gpioCfgOutput		= ar5416GpioCfgOutput;</a>
<a name="ln142">	ah-&gt;ah_gpioCfgInput		= ar5416GpioCfgInput;</a>
<a name="ln143">	ah-&gt;ah_gpioGet			= ar5416GpioGet;</a>
<a name="ln144">	ah-&gt;ah_gpioSet			= ar5416GpioSet;</a>
<a name="ln145">	ah-&gt;ah_gpioSetIntr		= ar5416GpioSetIntr;</a>
<a name="ln146">	ah-&gt;ah_getTsf64			= ar5416GetTsf64;</a>
<a name="ln147">	ah-&gt;ah_setTsf64			= ar5416SetTsf64;</a>
<a name="ln148">	ah-&gt;ah_resetTsf			= ar5416ResetTsf;</a>
<a name="ln149">	ah-&gt;ah_getRfGain		= ar5416GetRfgain;</a>
<a name="ln150">	ah-&gt;ah_setAntennaSwitch		= ar5416SetAntennaSwitch;</a>
<a name="ln151">	ah-&gt;ah_setDecompMask		= ar5416SetDecompMask;</a>
<a name="ln152">	ah-&gt;ah_setCoverageClass		= ar5416SetCoverageClass;</a>
<a name="ln153">	ah-&gt;ah_setQuiet			= ar5416SetQuiet;</a>
<a name="ln154">	ah-&gt;ah_getMibCycleCounts	= ar5416GetMibCycleCounts;</a>
<a name="ln155">	ah-&gt;ah_setChainMasks		= ar5416SetChainMasks;</a>
<a name="ln156"> </a>
<a name="ln157">	ah-&gt;ah_resetKeyCacheEntry	= ar5416ResetKeyCacheEntry;</a>
<a name="ln158">	ah-&gt;ah_setKeyCacheEntry		= ar5416SetKeyCacheEntry;</a>
<a name="ln159"> </a>
<a name="ln160">	/* DFS Functions */</a>
<a name="ln161">	ah-&gt;ah_enableDfs		= ar5416EnableDfs;</a>
<a name="ln162">	ah-&gt;ah_getDfsThresh		= ar5416GetDfsThresh;</a>
<a name="ln163">	ah-&gt;ah_getDfsDefaultThresh	= ar5416GetDfsDefaultThresh;</a>
<a name="ln164">	ah-&gt;ah_procRadarEvent		= ar5416ProcessRadarEvent;</a>
<a name="ln165">	ah-&gt;ah_isFastClockEnabled	= ar5416IsFastClockEnabled;</a>
<a name="ln166"> </a>
<a name="ln167">	/* Spectral Scan Functions */</a>
<a name="ln168">	ah-&gt;ah_spectralConfigure	= ar5416ConfigureSpectralScan;</a>
<a name="ln169">	ah-&gt;ah_spectralGetConfig	= ar5416GetSpectralParams;</a>
<a name="ln170">	ah-&gt;ah_spectralStart		= ar5416StartSpectralScan;</a>
<a name="ln171">	ah-&gt;ah_spectralStop		= ar5416StopSpectralScan;</a>
<a name="ln172">	ah-&gt;ah_spectralIsEnabled	= ar5416IsSpectralEnabled;</a>
<a name="ln173">	ah-&gt;ah_spectralIsActive		= ar5416IsSpectralActive;</a>
<a name="ln174"> </a>
<a name="ln175">	/* Power Management Functions */</a>
<a name="ln176">	ah-&gt;ah_setPowerMode		= ar5416SetPowerMode;</a>
<a name="ln177"> </a>
<a name="ln178">	/* Beacon Management Functions */</a>
<a name="ln179">	ah-&gt;ah_setBeaconTimers		= ar5416SetBeaconTimers;</a>
<a name="ln180">	ah-&gt;ah_beaconInit		= ar5416BeaconInit;</a>
<a name="ln181">	ah-&gt;ah_setStationBeaconTimers	= ar5416SetStaBeaconTimers;</a>
<a name="ln182">	ah-&gt;ah_resetStationBeaconTimers	= ar5416ResetStaBeaconTimers;</a>
<a name="ln183">	ah-&gt;ah_getNextTBTT		= ar5416GetNextTBTT;</a>
<a name="ln184"> </a>
<a name="ln185">	/* 802.11n Functions */</a>
<a name="ln186">	ah-&gt;ah_chainTxDesc		= ar5416ChainTxDesc;</a>
<a name="ln187">	ah-&gt;ah_setupFirstTxDesc		= ar5416SetupFirstTxDesc;</a>
<a name="ln188">	ah-&gt;ah_setupLastTxDesc		= ar5416SetupLastTxDesc;</a>
<a name="ln189">	ah-&gt;ah_set11nRateScenario	= ar5416Set11nRateScenario;</a>
<a name="ln190">	ah-&gt;ah_set11nAggrFirst		= ar5416Set11nAggrFirst;</a>
<a name="ln191">	ah-&gt;ah_set11nAggrMiddle		= ar5416Set11nAggrMiddle;</a>
<a name="ln192">	ah-&gt;ah_set11nAggrLast		= ar5416Set11nAggrLast;</a>
<a name="ln193">	ah-&gt;ah_clr11nAggr		= ar5416Clr11nAggr;</a>
<a name="ln194">	ah-&gt;ah_set11nBurstDuration	= ar5416Set11nBurstDuration;</a>
<a name="ln195">	ah-&gt;ah_get11nExtBusy		= ar5416Get11nExtBusy;</a>
<a name="ln196">	ah-&gt;ah_set11nMac2040		= ar5416Set11nMac2040;</a>
<a name="ln197">	ah-&gt;ah_get11nRxClear		= ar5416Get11nRxClear;</a>
<a name="ln198">	ah-&gt;ah_set11nRxClear		= ar5416Set11nRxClear;</a>
<a name="ln199">	ah-&gt;ah_set11nVirtMoreFrag	= ar5416Set11nVirtualMoreFrag;</a>
<a name="ln200"> </a>
<a name="ln201">	/* Interrupt functions */</a>
<a name="ln202">	ah-&gt;ah_isInterruptPending	= ar5416IsInterruptPending;</a>
<a name="ln203">	ah-&gt;ah_getPendingInterrupts	= ar5416GetPendingInterrupts;</a>
<a name="ln204">	ah-&gt;ah_setInterrupts		= ar5416SetInterrupts;</a>
<a name="ln205"> </a>
<a name="ln206">	/* Bluetooth Coexistence functions */</a>
<a name="ln207">	ah-&gt;ah_btCoexSetInfo		= ar5416SetBTCoexInfo;</a>
<a name="ln208">	ah-&gt;ah_btCoexSetConfig		= ar5416BTCoexConfig;</a>
<a name="ln209">	ah-&gt;ah_btCoexSetQcuThresh	= ar5416BTCoexSetQcuThresh;</a>
<a name="ln210">	ah-&gt;ah_btCoexSetWeights		= ar5416BTCoexSetWeights;</a>
<a name="ln211">	ah-&gt;ah_btCoexSetBmissThresh	= ar5416BTCoexSetupBmissThresh;</a>
<a name="ln212">	ah-&gt;ah_btCoexSetParameter	= ar5416BTCoexSetParameter;</a>
<a name="ln213">	ah-&gt;ah_btCoexDisable		= ar5416BTCoexDisable;</a>
<a name="ln214">	ah-&gt;ah_btCoexEnable		= ar5416BTCoexEnable;</a>
<a name="ln215">	AH5416(ah)-&gt;ah_btCoexSetDiversity = ar5416BTCoexAntennaDiversity;</a>
<a name="ln216"> </a>
<a name="ln217">	ahp-&gt;ah_priv.ah_getWirelessModes= ar5416GetWirelessModes;</a>
<a name="ln218">	ahp-&gt;ah_priv.ah_eepromRead	= ar5416EepromRead;</a>
<a name="ln219">#ifdef AH_SUPPORT_WRITE_EEPROM</a>
<a name="ln220">	ahp-&gt;ah_priv.ah_eepromWrite	= ar5416EepromWrite;</a>
<a name="ln221">#endif</a>
<a name="ln222">	ahp-&gt;ah_priv.ah_getChipPowerLimits = ar5416GetChipPowerLimits;</a>
<a name="ln223"> </a>
<a name="ln224">	/* Internal ops */</a>
<a name="ln225">	AH5416(ah)-&gt;ah_writeIni		= ar5416WriteIni;</a>
<a name="ln226">	AH5416(ah)-&gt;ah_spurMitigate	= ar5416SpurMitigate;</a>
<a name="ln227"> </a>
<a name="ln228">	/* Internal baseband ops */</a>
<a name="ln229">	AH5416(ah)-&gt;ah_initPLL		= ar5416InitPLL;</a>
<a name="ln230"> </a>
<a name="ln231">	/* Internal calibration ops */</a>
<a name="ln232">	AH5416(ah)-&gt;ah_cal_initcal	= ar5416InitCalHardware;</a>
<a name="ln233"> </a>
<a name="ln234">	/* Internal TX power control related operations */</a>
<a name="ln235">	AH5416(ah)-&gt;ah_olcInit = ar5416olcInit;</a>
<a name="ln236">	AH5416(ah)-&gt;ah_olcTempCompensation	= ar5416olcTempCompensation;</a>
<a name="ln237">	AH5416(ah)-&gt;ah_setPowerCalTable	= ar5416SetPowerCalTable;</a>
<a name="ln238"> </a>
<a name="ln239">	/*</a>
<a name="ln240">	 * Start by setting all Owl devices to 2x2</a>
<a name="ln241">	 */</a>
<a name="ln242">	AH5416(ah)-&gt;ah_rx_chainmask = AR5416_DEFAULT_RXCHAINMASK;</a>
<a name="ln243">	AH5416(ah)-&gt;ah_tx_chainmask = AR5416_DEFAULT_TXCHAINMASK;</a>
<a name="ln244"> </a>
<a name="ln245">	/* Enable all ANI functions to begin with */</a>
<a name="ln246">	AH5416(ah)-&gt;ah_ani_function = 0xffffffff;</a>
<a name="ln247"> </a>
<a name="ln248">	/* Set overridable ANI methods */</a>
<a name="ln249">	AH5212(ah)-&gt;ah_aniControl = ar5416AniControl;</a>
<a name="ln250"> </a>
<a name="ln251">	/*</a>
<a name="ln252">	 * Default FIFO Trigger levels</a>
<a name="ln253">	 *</a>
<a name="ln254">	 * These define how filled the TX FIFO needs to be before</a>
<a name="ln255">	 * the baseband begins to be given some data.</a>
<a name="ln256">	 *</a>
<a name="ln257">	 * To be paranoid, we ensure that the TX trigger level always</a>
<a name="ln258">	 * has at least enough space for two TX DMA to occur.</a>
<a name="ln259">	 * The TX DMA size is currently hard-coded to AR_TXCFG_DMASZ_128B.</a>
<a name="ln260">	 * That means we need to leave at least 256 bytes available in</a>
<a name="ln261">	 * the TX DMA FIFO.</a>
<a name="ln262">	 */</a>
<a name="ln263">#define	AR_FTRIG_512B	0x00000080 // 5 bits total</a>
<a name="ln264">	/*</a>
<a name="ln265">	 * AR9285/AR9271 have half the size TX FIFO compared to</a>
<a name="ln266">	 * other devices</a>
<a name="ln267">	 */</a>
<a name="ln268">	if (AR_SREV_KITE(ah) || AR_SREV_9271(ah)) {</a>
<a name="ln269">		AH5212(ah)-&gt;ah_txTrigLev = (AR_FTRIG_256B &gt;&gt; AR_FTRIG_S);</a>
<a name="ln270">		AH5212(ah)-&gt;ah_maxTxTrigLev = ((2048 / 64) - 1);</a>
<a name="ln271">	} else {</a>
<a name="ln272">		AH5212(ah)-&gt;ah_txTrigLev = (AR_FTRIG_512B &gt;&gt; AR_FTRIG_S);</a>
<a name="ln273">		AH5212(ah)-&gt;ah_maxTxTrigLev = ((4096 / 64) - 1);</a>
<a name="ln274">	}</a>
<a name="ln275">#undef	AR_FTRIG_512B</a>
<a name="ln276"> </a>
<a name="ln277">	/* And now leave some headspace - 256 bytes */</a>
<a name="ln278">	AH5212(ah)-&gt;ah_maxTxTrigLev -= 4;</a>
<a name="ln279">}</a>
<a name="ln280"> </a>
<a name="ln281">uint32_t</a>
<a name="ln282">ar5416GetRadioRev(struct ath_hal *ah)</a>
<a name="ln283">{</a>
<a name="ln284">	uint32_t val;</a>
<a name="ln285">	int i;</a>
<a name="ln286"> </a>
<a name="ln287">	/* Read Radio Chip Rev Extract */</a>
<a name="ln288">	OS_REG_WRITE(ah, AR_PHY(0x36), 0x00007058);</a>
<a name="ln289">	for (i = 0; i &lt; 8; i++)</a>
<a name="ln290">		OS_REG_WRITE(ah, AR_PHY(0x20), 0x00010000);</a>
<a name="ln291">	val = (OS_REG_READ(ah, AR_PHY(256)) &gt;&gt; 24) &amp; 0xff;</a>
<a name="ln292">	val = ((val &amp; 0xf0) &gt;&gt; 4) | ((val &amp; 0x0f) &lt;&lt; 4);</a>
<a name="ln293">	return ath_hal_reverseBits(val, 8);</a>
<a name="ln294">}</a>
<a name="ln295"> </a>
<a name="ln296">/*</a>
<a name="ln297"> * Attach for an AR5416 part.</a>
<a name="ln298"> */</a>
<a name="ln299">static struct ath_hal *</a>
<a name="ln300">ar5416Attach(uint16_t devid, HAL_SOFTC sc,</a>
<a name="ln301">	HAL_BUS_TAG st, HAL_BUS_HANDLE sh, uint16_t *eepromdata,</a>
<a name="ln302">	HAL_OPS_CONFIG *ah_config, HAL_STATUS *status)</a>
<a name="ln303">{</a>
<a name="ln304">	struct ath_hal_5416 *ahp5416;</a>
<a name="ln305">	struct ath_hal_5212 *ahp;</a>
<a name="ln306">	struct ath_hal *ah;</a>
<a name="ln307">	uint32_t val;</a>
<a name="ln308">	HAL_STATUS ecode;</a>
<a name="ln309">	HAL_BOOL rfStatus;</a>
<a name="ln310"> </a>
<a name="ln311">	HALDEBUG(AH_NULL, HAL_DEBUG_ATTACH, &quot;%s: sc %p st %p sh %p\n&quot;,</a>
<a name="ln312">	    __func__, sc, (void*) st, (void*) sh);</a>
<a name="ln313"> </a>
<a name="ln314">	/* NB: memory is returned zero'd */</a>
<a name="ln315">	ahp5416 = ath_hal_malloc(sizeof (struct ath_hal_5416) +</a>
<a name="ln316">		/* extra space for Owl 2.1/2.2 WAR */</a>
<a name="ln317">		sizeof(ar5416Addac)</a>
<a name="ln318">	);</a>
<a name="ln319">	if (ahp5416 == AH_NULL) {</a>
<a name="ln320">		HALDEBUG(AH_NULL, HAL_DEBUG_ANY,</a>
<a name="ln321">		    &quot;%s: cannot allocate memory for state block\n&quot;, __func__);</a>
<a name="ln322">		*status = HAL_ENOMEM;</a>
<a name="ln323">		return AH_NULL;</a>
<a name="ln324">	}</a>
<a name="ln325">	ar5416InitState(ahp5416, devid, sc, st, sh, status);</a>
<a name="ln326">	ahp = &amp;ahp5416-&gt;ah_5212;</a>
<a name="ln327">	ah = &amp;ahp-&gt;ah_priv.h;</a>
<a name="ln328"> </a>
<a name="ln329">	if (!ar5416SetResetReg(ah, HAL_RESET_POWER_ON)) {</a>
<a name="ln330">		/* reset chip */</a>
<a name="ln331">		HALDEBUG(ah, HAL_DEBUG_ANY, &quot;%s: couldn't reset chip\n&quot;, __func__);</a>
<a name="ln332">		ecode = HAL_EIO;</a>
<a name="ln333">		goto bad;</a>
<a name="ln334">	}</a>
<a name="ln335"> </a>
<a name="ln336">	if (!ar5416SetPowerMode(ah, HAL_PM_AWAKE, AH_TRUE)) {</a>
<a name="ln337">		HALDEBUG(ah, HAL_DEBUG_ANY, &quot;%s: couldn't wakeup chip\n&quot;, __func__);</a>
<a name="ln338">		ecode = HAL_EIO;</a>
<a name="ln339">		goto bad;</a>
<a name="ln340">	}</a>
<a name="ln341">	/* Read Revisions from Chips before taking out of reset */</a>
<a name="ln342">	val = OS_REG_READ(ah, AR_SREV) &amp; AR_SREV_ID;</a>
<a name="ln343">	AH_PRIVATE(ah)-&gt;ah_macVersion = val &gt;&gt; AR_SREV_ID_S;</a>
<a name="ln344">	AH_PRIVATE(ah)-&gt;ah_macRev = val &amp; AR_SREV_REVISION;</a>
<a name="ln345">	AH_PRIVATE(ah)-&gt;ah_ispcie = (devid == AR5416_DEVID_PCIE);</a>
<a name="ln346"> </a>
<a name="ln347">	/* setup common ini data; rf backends handle remainder */</a>
<a name="ln348">	HAL_INI_INIT(&amp;ahp-&gt;ah_ini_modes, ar5416Modes, 6);</a>
<a name="ln349">	HAL_INI_INIT(&amp;ahp-&gt;ah_ini_common, ar5416Common, 2);</a>
<a name="ln350"> </a>
<a name="ln351">	HAL_INI_INIT(&amp;AH5416(ah)-&gt;ah_ini_bb_rfgain, ar5416BB_RfGain, 3);</a>
<a name="ln352">	HAL_INI_INIT(&amp;AH5416(ah)-&gt;ah_ini_bank0, ar5416Bank0, 2);</a>
<a name="ln353">	HAL_INI_INIT(&amp;AH5416(ah)-&gt;ah_ini_bank1, ar5416Bank1, 2);</a>
<a name="ln354">	HAL_INI_INIT(&amp;AH5416(ah)-&gt;ah_ini_bank2, ar5416Bank2, 2);</a>
<a name="ln355">	HAL_INI_INIT(&amp;AH5416(ah)-&gt;ah_ini_bank3, ar5416Bank3, 3);</a>
<a name="ln356">	HAL_INI_INIT(&amp;AH5416(ah)-&gt;ah_ini_bank6, ar5416Bank6, 3);</a>
<a name="ln357">	HAL_INI_INIT(&amp;AH5416(ah)-&gt;ah_ini_bank7, ar5416Bank7, 2);</a>
<a name="ln358">	HAL_INI_INIT(&amp;AH5416(ah)-&gt;ah_ini_addac, ar5416Addac, 2);</a>
<a name="ln359"> </a>
<a name="ln360">	if (! IS_5416V2_2(ah)) {		/* Owl 2.1/2.0 */</a>
<a name="ln361">		struct ini {</a>
<a name="ln362">			uint32_t	*data;		/* NB: !const */</a>
<a name="ln363">			int		rows, cols;</a>
<a name="ln364">		};</a>
<a name="ln365">		ath_hal_printf(ah, &quot;[ath] Enabling CLKDRV workaround for AR5416 &lt; v2.2\n&quot;);</a>
<a name="ln366">		/* override CLKDRV value */</a>
<a name="ln367">		OS_MEMCPY(&amp;AH5416(ah)[1], ar5416Addac, sizeof(ar5416Addac));</a>
<a name="ln368">		AH5416(ah)-&gt;ah_ini_addac.data = (uint32_t *) &amp;AH5416(ah)[1];</a>
<a name="ln369">		HAL_INI_VAL((struct ini *)&amp;AH5416(ah)-&gt;ah_ini_addac, 31, 1) = 0;</a>
<a name="ln370">	}</a>
<a name="ln371"> </a>
<a name="ln372">	HAL_INI_INIT(&amp;AH5416(ah)-&gt;ah_ini_pcieserdes, ar5416PciePhy, 2);</a>
<a name="ln373">	ar5416AttachPCIE(ah);</a>
<a name="ln374"> </a>
<a name="ln375">	ecode = ath_hal_v14EepromAttach(ah);</a>
<a name="ln376">	if (ecode != HAL_OK)</a>
<a name="ln377">		goto bad;</a>
<a name="ln378"> </a>
<a name="ln379">	if (!ar5416ChipReset(ah, AH_NULL)) {	/* reset chip */</a>
<a name="ln380">		HALDEBUG(ah, HAL_DEBUG_ANY, &quot;%s: chip reset failed\n&quot;,</a>
<a name="ln381">		    __func__);</a>
<a name="ln382">		ecode = HAL_EIO;</a>
<a name="ln383">		goto bad;</a>
<a name="ln384">	}</a>
<a name="ln385"> </a>
<a name="ln386">	AH_PRIVATE(ah)-&gt;ah_phyRev = OS_REG_READ(ah, AR_PHY_CHIP_ID);</a>
<a name="ln387"> </a>
<a name="ln388">	if (!ar5212ChipTest(ah)) {</a>
<a name="ln389">		HALDEBUG(ah, HAL_DEBUG_ANY, &quot;%s: hardware self-test failed\n&quot;,</a>
<a name="ln390">		    __func__);</a>
<a name="ln391">		ecode = HAL_ESELFTEST;</a>
<a name="ln392">		goto bad;</a>
<a name="ln393">	}</a>
<a name="ln394"> </a>
<a name="ln395">	/*</a>
<a name="ln396">	 * Set correct Baseband to analog shift</a>
<a name="ln397">	 * setting to access analog chips.</a>
<a name="ln398">	 */</a>
<a name="ln399">	OS_REG_WRITE(ah, AR_PHY(0), 0x00000007);</a>
<a name="ln400"> </a>
<a name="ln401">	/* Read Radio Chip Rev Extract */</a>
<a name="ln402">	AH_PRIVATE(ah)-&gt;ah_analog5GhzRev = ar5416GetRadioRev(ah);</a>
<a name="ln403">	switch (AH_PRIVATE(ah)-&gt;ah_analog5GhzRev &amp; AR_RADIO_SREV_MAJOR) {</a>
<a name="ln404">        case AR_RAD5122_SREV_MAJOR:	/* Fowl: 5G/2x2 */</a>
<a name="ln405">        case AR_RAD2122_SREV_MAJOR:	/* Fowl: 2+5G/2x2 */</a>
<a name="ln406">        case AR_RAD2133_SREV_MAJOR:	/* Fowl: 2G/3x3 */</a>
<a name="ln407">	case AR_RAD5133_SREV_MAJOR:	/* Fowl: 2+5G/3x3 */</a>
<a name="ln408">		break;</a>
<a name="ln409">	default:</a>
<a name="ln410">		if (AH_PRIVATE(ah)-&gt;ah_analog5GhzRev == 0) {</a>
<a name="ln411">			/*</a>
<a name="ln412">			 * When RF_Silen is used the analog chip is reset.</a>
<a name="ln413">			 * So when the system boots with radio switch off</a>
<a name="ln414">			 * the RF chip rev reads back as zero and we need</a>
<a name="ln415">			 * to use the mac+phy revs to set the radio rev.</a>
<a name="ln416">			 */</a>
<a name="ln417">			AH_PRIVATE(ah)-&gt;ah_analog5GhzRev =</a>
<a name="ln418">				AR_RAD5133_SREV_MAJOR;</a>
<a name="ln419">			break;</a>
<a name="ln420">		}</a>
<a name="ln421">		/* NB: silently accept anything in release code per Atheros */</a>
<a name="ln422">#ifdef AH_DEBUG</a>
<a name="ln423">		HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln424">		    &quot;%s: 5G Radio Chip Rev 0x%02X is not supported by &quot;</a>
<a name="ln425">		    &quot;this driver\n&quot;, __func__,</a>
<a name="ln426">		    AH_PRIVATE(ah)-&gt;ah_analog5GhzRev);</a>
<a name="ln427">		ecode = HAL_ENOTSUPP;</a>
<a name="ln428">		goto bad;</a>
<a name="ln429">#endif</a>
<a name="ln430">	}</a>
<a name="ln431"> </a>
<a name="ln432">	/*</a>
<a name="ln433">	 * Got everything we need now to setup the capabilities.</a>
<a name="ln434">	 */</a>
<a name="ln435">	if (!ar5416FillCapabilityInfo(ah)) {</a>
<a name="ln436">		ecode = HAL_EEREAD;</a>
<a name="ln437">		goto bad;</a>
<a name="ln438">	}</a>
<a name="ln439"> </a>
<a name="ln440">	ecode = ath_hal_eepromGet(ah, AR_EEP_MACADDR, ahp-&gt;ah_macaddr);</a>
<a name="ln441">	if (ecode != HAL_OK) {</a>
<a name="ln442">		HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln443">		    &quot;%s: error getting mac address from EEPROM\n&quot;, __func__);</a>
<a name="ln444">		goto bad;</a>
<a name="ln445">        }</a>
<a name="ln446">	/* XXX How about the serial number ? */</a>
<a name="ln447">	/* Read Reg Domain */</a>
<a name="ln448">	AH_PRIVATE(ah)-&gt;ah_currentRD =</a>
<a name="ln449">	    ath_hal_eepromGet(ah, AR_EEP_REGDMN_0, AH_NULL);</a>
<a name="ln450">	AH_PRIVATE(ah)-&gt;ah_currentRDext =</a>
<a name="ln451">	    ath_hal_eepromGet(ah, AR_EEP_REGDMN_1, AH_NULL);</a>
<a name="ln452"> </a>
<a name="ln453">	/*</a>
<a name="ln454">	 * ah_miscMode is populated by ar5416FillCapabilityInfo()</a>
<a name="ln455">	 * starting from griffin. Set here to make sure that</a>
<a name="ln456">	 * AR_MISC_MODE_MIC_NEW_LOC_ENABLE is set before a GTK is</a>
<a name="ln457">	 * placed into hardware.</a>
<a name="ln458">	 */</a>
<a name="ln459">	if (ahp-&gt;ah_miscMode != 0)</a>
<a name="ln460">		OS_REG_WRITE(ah, AR_MISC_MODE, OS_REG_READ(ah, AR_MISC_MODE) | ahp-&gt;ah_miscMode);</a>
<a name="ln461"> </a>
<a name="ln462">	rfStatus = ar2133RfAttach(ah, &amp;ecode);</a>
<a name="ln463">	if (!rfStatus) {</a>
<a name="ln464">		HALDEBUG(ah, HAL_DEBUG_ANY, &quot;%s: RF setup failed, status %u\n&quot;,</a>
<a name="ln465">		    __func__, ecode);</a>
<a name="ln466">		goto bad;</a>
<a name="ln467">	}</a>
<a name="ln468"> </a>
<a name="ln469">	ar5416AniSetup(ah);			/* Anti Noise Immunity */</a>
<a name="ln470"> </a>
<a name="ln471">	AH5416(ah)-&gt;nf_2g.max = AR_PHY_CCA_MAX_GOOD_VAL_5416_2GHZ;</a>
<a name="ln472">	AH5416(ah)-&gt;nf_2g.min = AR_PHY_CCA_MIN_GOOD_VAL_5416_2GHZ;</a>
<a name="ln473">	AH5416(ah)-&gt;nf_2g.nominal = AR_PHY_CCA_NOM_VAL_5416_2GHZ;</a>
<a name="ln474">	AH5416(ah)-&gt;nf_5g.max = AR_PHY_CCA_MAX_GOOD_VAL_5416_5GHZ;</a>
<a name="ln475">	AH5416(ah)-&gt;nf_5g.min = AR_PHY_CCA_MIN_GOOD_VAL_5416_5GHZ;</a>
<a name="ln476">	AH5416(ah)-&gt;nf_5g.nominal = AR_PHY_CCA_NOM_VAL_5416_5GHZ;</a>
<a name="ln477"> </a>
<a name="ln478">	ar5416InitNfHistBuff(AH5416(ah)-&gt;ah_cal.nfCalHist);</a>
<a name="ln479"> </a>
<a name="ln480">	HALDEBUG(ah, HAL_DEBUG_ATTACH, &quot;%s: return\n&quot;, __func__);</a>
<a name="ln481"> </a>
<a name="ln482">	return ah;</a>
<a name="ln483">bad:</a>
<a name="ln484">	if (ahp)</a>
<a name="ln485">		ar5416Detach((struct ath_hal *) ahp);</a>
<a name="ln486">	if (status)</a>
<a name="ln487">		*status = ecode;</a>
<a name="ln488">	return AH_NULL;</a>
<a name="ln489">}</a>
<a name="ln490"> </a>
<a name="ln491">void</a>
<a name="ln492">ar5416Detach(struct ath_hal *ah)</a>
<a name="ln493">{</a>
<a name="ln494">	HALDEBUG(ah, HAL_DEBUG_ATTACH, &quot;%s:\n&quot;, __func__);</a>
<a name="ln495"> </a>
<a name="ln496">	HALASSERT(ah != AH_NULL);</a>
<a name="ln497">	HALASSERT(ah-&gt;ah_magic == AR5416_MAGIC);</a>
<a name="ln498"> </a>
<a name="ln499">	/* Make sure that chip is awake before writing to it */</a>
<a name="ln500">	if (! ar5416SetPowerMode(ah, HAL_PM_AWAKE, AH_TRUE))</a>
<a name="ln501">		HALDEBUG(ah, HAL_DEBUG_UNMASKABLE,</a>
<a name="ln502">		    &quot;%s: failed to wake up chip\n&quot;,</a>
<a name="ln503">		    __func__);</a>
<a name="ln504"> </a>
<a name="ln505">	ar5416AniDetach(ah);</a>
<a name="ln506">	ar5212RfDetach(ah);</a>
<a name="ln507">	ah-&gt;ah_disable(ah);</a>
<a name="ln508">	ar5416SetPowerMode(ah, HAL_PM_FULL_SLEEP, AH_TRUE);</a>
<a name="ln509">	ath_hal_eepromDetach(ah);</a>
<a name="ln510">	ath_hal_free(ah);</a>
<a name="ln511">}</a>
<a name="ln512"> </a>
<a name="ln513">void</a>
<a name="ln514">ar5416AttachPCIE(struct ath_hal *ah)</a>
<a name="ln515">{</a>
<a name="ln516">	if (AH_PRIVATE(ah)-&gt;ah_ispcie)</a>
<a name="ln517">		ath_hal_configPCIE(ah, AH_FALSE, AH_FALSE);</a>
<a name="ln518">	else</a>
<a name="ln519">		ath_hal_disablePCIE(ah);</a>
<a name="ln520">}</a>
<a name="ln521"> </a>
<a name="ln522">static void</a>
<a name="ln523">ar5416ConfigPCIE(struct ath_hal *ah, HAL_BOOL restore, HAL_BOOL power_off)</a>
<a name="ln524">{</a>
<a name="ln525"> </a>
<a name="ln526">	/* This is only applicable for AR5418 (AR5416 PCIe) */</a>
<a name="ln527">	if (! AH_PRIVATE(ah)-&gt;ah_ispcie)</a>
<a name="ln528">		return;</a>
<a name="ln529"> </a>
<a name="ln530">	if (! restore) {</a>
<a name="ln531">		ath_hal_ini_write(ah, &amp;AH5416(ah)-&gt;ah_ini_pcieserdes, 1, 0);</a>
<a name="ln532">		OS_DELAY(1000);</a>
<a name="ln533">	}</a>
<a name="ln534"> </a>
<a name="ln535">	if (power_off) {		/* Power-off */</a>
<a name="ln536">		/* clear bit 19 to disable L1 */</a>
<a name="ln537">		OS_REG_CLR_BIT(ah, AR_PCIE_PM_CTRL, AR_PCIE_PM_CTRL_ENA);</a>
<a name="ln538">	} else {			/* Power-on */</a>
<a name="ln539">		/* Set default WAR values for Owl */</a>
<a name="ln540">		OS_REG_WRITE(ah, AR_WA, AR_WA_DEFAULT);</a>
<a name="ln541"> </a>
<a name="ln542">		/* set bit 19 to allow forcing of pcie core into L1 state */</a>
<a name="ln543">		OS_REG_SET_BIT(ah, AR_PCIE_PM_CTRL, AR_PCIE_PM_CTRL_ENA);</a>
<a name="ln544">	}</a>
<a name="ln545">}</a>
<a name="ln546"> </a>
<a name="ln547">/*</a>
<a name="ln548"> * Disable PCIe PHY if PCIe isn't used.</a>
<a name="ln549"> */</a>
<a name="ln550">static void</a>
<a name="ln551">ar5416DisablePCIE(struct ath_hal *ah)</a>
<a name="ln552">{</a>
<a name="ln553"> </a>
<a name="ln554">	/* PCIe? Don't */</a>
<a name="ln555">	if (AH_PRIVATE(ah)-&gt;ah_ispcie)</a>
<a name="ln556">		return;</a>
<a name="ln557"> </a>
<a name="ln558">	/* .. Only applicable for AR5416v2 or later */</a>
<a name="ln559">	if (! (AR_SREV_OWL(ah) &amp;&amp; AR_SREV_OWL_20_OR_LATER(ah)))</a>
<a name="ln560">		return;</a>
<a name="ln561"> </a>
<a name="ln562">	OS_REG_WRITE_BUFFER_ENABLE(ah);</a>
<a name="ln563"> </a>
<a name="ln564">	/*</a>
<a name="ln565">	 * Disable the PCIe PHY.</a>
<a name="ln566">	 */</a>
<a name="ln567">	OS_REG_WRITE(ah, AR_PCIE_SERDES, 0x9248fc00);</a>
<a name="ln568">	OS_REG_WRITE(ah, AR_PCIE_SERDES, 0x24924924);</a>
<a name="ln569">	OS_REG_WRITE(ah, AR_PCIE_SERDES, 0x28000029);</a>
<a name="ln570">	OS_REG_WRITE(ah, AR_PCIE_SERDES, 0x57160824);</a>
<a name="ln571">	OS_REG_WRITE(ah, AR_PCIE_SERDES, 0x25980579);</a>
<a name="ln572">	OS_REG_WRITE(ah, AR_PCIE_SERDES, 0x00000000);</a>
<a name="ln573">	OS_REG_WRITE(ah, AR_PCIE_SERDES, 0x1aaabe40);</a>
<a name="ln574">	OS_REG_WRITE(ah, AR_PCIE_SERDES, 0xbe105554);</a>
<a name="ln575">	OS_REG_WRITE(ah, AR_PCIE_SERDES, 0x000e1007);</a>
<a name="ln576"> </a>
<a name="ln577">	/* Load the new settings */</a>
<a name="ln578">	OS_REG_WRITE(ah, AR_PCIE_SERDES2, 0x00000000);</a>
<a name="ln579"> </a>
<a name="ln580">	OS_REG_WRITE_BUFFER_FLUSH(ah);</a>
<a name="ln581">	OS_REG_WRITE_BUFFER_DISABLE(ah);</a>
<a name="ln582">}</a>
<a name="ln583"> </a>
<a name="ln584">static void</a>
<a name="ln585">ar5416WriteIni(struct ath_hal *ah, const struct ieee80211_channel *chan)</a>
<a name="ln586">{</a>
<a name="ln587">	u_int modesIndex, freqIndex;</a>
<a name="ln588">	int regWrites = 0;</a>
<a name="ln589"> </a>
<a name="ln590">	/* Setup the indices for the next set of register array writes */</a>
<a name="ln591">	/* XXX Ignore 11n dynamic mode on the AR5416 for the moment */</a>
<a name="ln592">	if (IEEE80211_IS_CHAN_2GHZ(chan)) {</a>
<a name="ln593">		freqIndex = 2;</a>
<a name="ln594">		if (IEEE80211_IS_CHAN_HT40(chan))</a>
<a name="ln595">			modesIndex = 3;</a>
<a name="ln596">		else if (IEEE80211_IS_CHAN_108G(chan))</a>
<a name="ln597">			modesIndex = 5;</a>
<a name="ln598">		else</a>
<a name="ln599">			modesIndex = 4;</a>
<a name="ln600">	} else {</a>
<a name="ln601">		freqIndex = 1;</a>
<a name="ln602">		if (IEEE80211_IS_CHAN_HT40(chan) ||</a>
<a name="ln603">		    IEEE80211_IS_CHAN_TURBO(chan))</a>
<a name="ln604">			modesIndex = 2;</a>
<a name="ln605">		else</a>
<a name="ln606">			modesIndex = 1;</a>
<a name="ln607">	}</a>
<a name="ln608"> </a>
<a name="ln609">	/* Set correct Baseband to analog shift setting to access analog chips. */</a>
<a name="ln610">	OS_REG_WRITE(ah, AR_PHY(0), 0x00000007);</a>
<a name="ln611"> </a>
<a name="ln612">	/*</a>
<a name="ln613">	 * Write addac shifts</a>
<a name="ln614">	 */</a>
<a name="ln615">	OS_REG_WRITE(ah, AR_PHY_ADC_SERIAL_CTL, AR_PHY_SEL_EXTERNAL_RADIO);</a>
<a name="ln616"> </a>
<a name="ln617">	/* NB: only required for Sowl */</a>
<a name="ln618">	if (AR_SREV_SOWL(ah))</a>
<a name="ln619">		ar5416EepromSetAddac(ah, chan);</a>
<a name="ln620"> </a>
<a name="ln621">	regWrites = ath_hal_ini_write(ah, &amp;AH5416(ah)-&gt;ah_ini_addac, 1,</a>
<a name="ln622">	    regWrites);</a>
<a name="ln623">	OS_REG_WRITE(ah, AR_PHY_ADC_SERIAL_CTL, AR_PHY_SEL_INTERNAL_ADDAC);</a>
<a name="ln624"> </a>
<a name="ln625">	regWrites = ath_hal_ini_write(ah, &amp;AH5212(ah)-&gt;ah_ini_modes,</a>
<a name="ln626">	    modesIndex, regWrites);</a>
<a name="ln627">	regWrites = ath_hal_ini_write(ah, &amp;AH5212(ah)-&gt;ah_ini_common,</a>
<a name="ln628">	    1, regWrites);</a>
<a name="ln629"> </a>
<a name="ln630">	/* XXX updated regWrites? */</a>
<a name="ln631">	AH5212(ah)-&gt;ah_rfHal-&gt;writeRegs(ah, modesIndex, freqIndex, regWrites);</a>
<a name="ln632">}</a>
<a name="ln633"> </a>
<a name="ln634">/*</a>
<a name="ln635"> * Convert to baseband spur frequency given input channel frequency</a>
<a name="ln636"> * and compute register settings below.</a>
<a name="ln637"> */</a>
<a name="ln638"> </a>
<a name="ln639">static void</a>
<a name="ln640">ar5416SpurMitigate(struct ath_hal *ah, const struct ieee80211_channel *chan)</a>
<a name="ln641">{</a>
<a name="ln642">    uint16_t freq = ath_hal_gethwchannel(ah, chan);</a>
<a name="ln643">    static const int pilot_mask_reg[4] = { AR_PHY_TIMING7, AR_PHY_TIMING8,</a>
<a name="ln644">                AR_PHY_PILOT_MASK_01_30, AR_PHY_PILOT_MASK_31_60 };</a>
<a name="ln645">    static const int chan_mask_reg[4] = { AR_PHY_TIMING9, AR_PHY_TIMING10,</a>
<a name="ln646">                AR_PHY_CHANNEL_MASK_01_30, AR_PHY_CHANNEL_MASK_31_60 };</a>
<a name="ln647">    static const int inc[4] = { 0, 100, 0, 0 };</a>
<a name="ln648"> </a>
<a name="ln649">    int bb_spur = AR_NO_SPUR;</a>
<a name="ln650">    int bin, cur_bin;</a>
<a name="ln651">    int spur_freq_sd;</a>
<a name="ln652">    int spur_delta_phase;</a>
<a name="ln653">    int denominator;</a>
<a name="ln654">    int upper, lower, cur_vit_mask;</a>
<a name="ln655">    int tmp, new;</a>
<a name="ln656">    int i;</a>
<a name="ln657"> </a>
<a name="ln658">    int8_t mask_m[123];</a>
<a name="ln659">    int8_t mask_p[123];</a>
<a name="ln660">    int8_t mask_amt;</a>
<a name="ln661">    int tmp_mask;</a>
<a name="ln662">    int cur_bb_spur;</a>
<a name="ln663">    HAL_BOOL is2GHz = IEEE80211_IS_CHAN_2GHZ(chan);</a>
<a name="ln664"> </a>
<a name="ln665">    OS_MEMZERO(mask_m, sizeof(mask_m));</a>
<a name="ln666">    OS_MEMZERO(mask_p, sizeof(mask_p));</a>
<a name="ln667"> </a>
<a name="ln668">    /*</a>
<a name="ln669">     * Need to verify range +/- 9.5 for static ht20, otherwise spur</a>
<a name="ln670">     * is out-of-band and can be ignored.</a>
<a name="ln671">     */</a>
<a name="ln672">    /* XXX ath9k changes */</a>
<a name="ln673">    for (i = 0; i &lt; AR5416_EEPROM_MODAL_SPURS; i++) {</a>
<a name="ln674">        cur_bb_spur = ath_hal_getSpurChan(ah, i, is2GHz);</a>
<a name="ln675">        if (AR_NO_SPUR == cur_bb_spur)</a>
<a name="ln676">            break;</a>
<a name="ln677">        cur_bb_spur = cur_bb_spur - (freq * 10);</a>
<a name="ln678">        if ((cur_bb_spur &gt; -95) &amp;&amp; (cur_bb_spur &lt; 95)) {</a>
<a name="ln679">            bb_spur = cur_bb_spur;</a>
<a name="ln680">            break;</a>
<a name="ln681">        }</a>
<a name="ln682">    }</a>
<a name="ln683">    if (AR_NO_SPUR == bb_spur)</a>
<a name="ln684">        return;</a>
<a name="ln685"> </a>
<a name="ln686">    bin = bb_spur * 32;</a>
<a name="ln687"> </a>
<a name="ln688">    tmp = OS_REG_READ(ah, AR_PHY_TIMING_CTRL4_CHAIN(0));</a>
<a name="ln689">    new = tmp | (AR_PHY_TIMING_CTRL4_ENABLE_SPUR_RSSI |</a>
<a name="ln690">        AR_PHY_TIMING_CTRL4_ENABLE_SPUR_FILTER |</a>
<a name="ln691">        AR_PHY_TIMING_CTRL4_ENABLE_CHAN_MASK |</a>
<a name="ln692">        AR_PHY_TIMING_CTRL4_ENABLE_PILOT_MASK);</a>
<a name="ln693"> </a>
<a name="ln694">    OS_REG_WRITE_BUFFER_ENABLE(ah);</a>
<a name="ln695"> </a>
<a name="ln696">    OS_REG_WRITE(ah, AR_PHY_TIMING_CTRL4_CHAIN(0), new);</a>
<a name="ln697"> </a>
<a name="ln698">    new = (AR_PHY_SPUR_REG_MASK_RATE_CNTL |</a>
<a name="ln699">        AR_PHY_SPUR_REG_ENABLE_MASK_PPM |</a>
<a name="ln700">        AR_PHY_SPUR_REG_MASK_RATE_SELECT |</a>
<a name="ln701">        AR_PHY_SPUR_REG_ENABLE_VIT_SPUR_RSSI |</a>
<a name="ln702">        SM(AR5416_SPUR_RSSI_THRESH, AR_PHY_SPUR_REG_SPUR_RSSI_THRESH));</a>
<a name="ln703">    OS_REG_WRITE(ah, AR_PHY_SPUR_REG, new);</a>
<a name="ln704">    /*</a>
<a name="ln705">     * Should offset bb_spur by +/- 10 MHz for dynamic 2040 MHz</a>
<a name="ln706">     * config, no offset for HT20.</a>
<a name="ln707">     * spur_delta_phase = bb_spur/40 * 2**21 for static ht20,</a>
<a name="ln708">     * /80 for dyn2040.</a>
<a name="ln709">     */</a>
<a name="ln710">    spur_delta_phase = ((bb_spur * 524288) / 100) &amp;</a>
<a name="ln711">        AR_PHY_TIMING11_SPUR_DELTA_PHASE;</a>
<a name="ln712">    /*</a>
<a name="ln713">     * in 11A mode the denominator of spur_freq_sd should be 40 and</a>
<a name="ln714">     * it should be 44 in 11G</a>
<a name="ln715">     */</a>
<a name="ln716">    denominator = IEEE80211_IS_CHAN_2GHZ(chan) ? 440 : 400;</a>
<a name="ln717">    spur_freq_sd = ((bb_spur * 2048) / denominator) &amp; 0x3ff;</a>
<a name="ln718"> </a>
<a name="ln719">    new = (AR_PHY_TIMING11_USE_SPUR_IN_AGC |</a>
<a name="ln720">        SM(spur_freq_sd, AR_PHY_TIMING11_SPUR_FREQ_SD) |</a>
<a name="ln721">        SM(spur_delta_phase, AR_PHY_TIMING11_SPUR_DELTA_PHASE));</a>
<a name="ln722">    OS_REG_WRITE(ah, AR_PHY_TIMING11, new);</a>
<a name="ln723"> </a>
<a name="ln724"> </a>
<a name="ln725">    /*</a>
<a name="ln726">     * ============================================</a>
<a name="ln727">     * pilot mask 1 [31:0] = +6..-26, no 0 bin</a>
<a name="ln728">     * pilot mask 2 [19:0] = +26..+7</a>
<a name="ln729">     *</a>
<a name="ln730">     * channel mask 1 [31:0] = +6..-26, no 0 bin</a>
<a name="ln731">     * channel mask 2 [19:0] = +26..+7</a>
<a name="ln732">     */</a>
<a name="ln733">    //cur_bin = -26;</a>
<a name="ln734">    cur_bin = -6000;</a>
<a name="ln735">    upper = bin + 100;</a>
<a name="ln736">    lower = bin - 100;</a>
<a name="ln737"> </a>
<a name="ln738">    for (i = 0; i &lt; 4; i++) {</a>
<a name="ln739">        int pilot_mask = 0;</a>
<a name="ln740">        int chan_mask  = 0;</a>
<a name="ln741">        int bp         = 0;</a>
<a name="ln742">        for (bp = 0; bp &lt; 30; bp++) {</a>
<a name="ln743">            if ((cur_bin &gt; lower) &amp;&amp; (cur_bin &lt; upper)) {</a>
<a name="ln744">                pilot_mask = pilot_mask | 0x1 &lt;&lt; bp;</a>
<a name="ln745">                chan_mask  = chan_mask | 0x1 &lt;&lt; bp;</a>
<a name="ln746">            }</a>
<a name="ln747">            cur_bin += 100;</a>
<a name="ln748">        }</a>
<a name="ln749">        cur_bin += inc[i];</a>
<a name="ln750">        OS_REG_WRITE(ah, pilot_mask_reg[i], pilot_mask);</a>
<a name="ln751">        OS_REG_WRITE(ah, chan_mask_reg[i], chan_mask);</a>
<a name="ln752">    }</a>
<a name="ln753"> </a>
<a name="ln754">    /* =================================================</a>
<a name="ln755">     * viterbi mask 1 based on channel magnitude</a>
<a name="ln756">     * four levels 0-3</a>
<a name="ln757">     *  - mask (-27 to 27) (reg 64,0x9900 to 67,0x990c)</a>
<a name="ln758">     *      [1 2 2 1] for -9.6 or [1 2 1] for +16</a>
<a name="ln759">     *  - enable_mask_ppm, all bins move with freq</a>
<a name="ln760">     *</a>
<a name="ln761">     *  - mask_select,    8 bits for rates (reg 67,0x990c)</a>
<a name="ln762">     *  - mask_rate_cntl, 8 bits for rates (reg 67,0x990c)</a>
<a name="ln763">     *      choose which mask to use mask or mask2</a>
<a name="ln764">     */</a>
<a name="ln765"> </a>
<a name="ln766">    /*</a>
<a name="ln767">     * viterbi mask 2  2nd set for per data rate puncturing</a>
<a name="ln768">     * four levels 0-3</a>
<a name="ln769">     *  - mask_select, 8 bits for rates (reg 67)</a>
<a name="ln770">     *  - mask (-27 to 27) (reg 98,0x9988 to 101,0x9994)</a>
<a name="ln771">     *      [1 2 2 1] for -9.6 or [1 2 1] for +16</a>
<a name="ln772">     */</a>
<a name="ln773">    cur_vit_mask = 6100;</a>
<a name="ln774">    upper        = bin + 120;</a>
<a name="ln775">    lower        = bin - 120;</a>
<a name="ln776"> </a>
<a name="ln777">    for (i = 0; i &lt; 123; i++) {</a>
<a name="ln778">        if ((cur_vit_mask &gt; lower) &amp;&amp; (cur_vit_mask &lt; upper)) {</a>
<a name="ln779">            if ((abs(cur_vit_mask - bin)) &lt; 75) {</a>
<a name="ln780">                mask_amt = 1;</a>
<a name="ln781">            } else {</a>
<a name="ln782">                mask_amt = 0;</a>
<a name="ln783">            }</a>
<a name="ln784">            if (cur_vit_mask &lt; 0) {</a>
<a name="ln785">                mask_m[abs(cur_vit_mask / 100)] = mask_amt;</a>
<a name="ln786">            } else {</a>
<a name="ln787">                mask_p[cur_vit_mask / 100] = mask_amt;</a>
<a name="ln788">            }</a>
<a name="ln789">        }</a>
<a name="ln790">        cur_vit_mask -= 100;</a>
<a name="ln791">    }</a>
<a name="ln792"> </a>
<a name="ln793">    tmp_mask = (mask_m[46] &lt;&lt; 30) | (mask_m[47] &lt;&lt; 28)</a>
<a name="ln794">          | (mask_m[48] &lt;&lt; 26) | (mask_m[49] &lt;&lt; 24)</a>
<a name="ln795">          | (mask_m[50] &lt;&lt; 22) | (mask_m[51] &lt;&lt; 20)</a>
<a name="ln796">          | (mask_m[52] &lt;&lt; 18) | (mask_m[53] &lt;&lt; 16)</a>
<a name="ln797">          | (mask_m[54] &lt;&lt; 14) | (mask_m[55] &lt;&lt; 12)</a>
<a name="ln798">          | (mask_m[56] &lt;&lt; 10) | (mask_m[57] &lt;&lt;  8)</a>
<a name="ln799">          | (mask_m[58] &lt;&lt;  6) | (mask_m[59] &lt;&lt;  4)</a>
<a name="ln800">          | (mask_m[60] &lt;&lt;  2) | (mask_m[61] &lt;&lt;  0);</a>
<a name="ln801">    OS_REG_WRITE(ah, AR_PHY_BIN_MASK_1, tmp_mask);</a>
<a name="ln802">    OS_REG_WRITE(ah, AR_PHY_VIT_MASK2_M_46_61, tmp_mask);</a>
<a name="ln803"> </a>
<a name="ln804">    tmp_mask =             (mask_m[31] &lt;&lt; 28)</a>
<a name="ln805">          | (mask_m[32] &lt;&lt; 26) | (mask_m[33] &lt;&lt; 24)</a>
<a name="ln806">          | (mask_m[34] &lt;&lt; 22) | (mask_m[35] &lt;&lt; 20)</a>
<a name="ln807">          | (mask_m[36] &lt;&lt; 18) | (mask_m[37] &lt;&lt; 16)</a>
<a name="ln808">          | (mask_m[48] &lt;&lt; 14) | (mask_m[39] &lt;&lt; 12)</a>
<a name="ln809">          | (mask_m[40] &lt;&lt; 10) | (mask_m[41] &lt;&lt;  8)</a>
<a name="ln810">          | (mask_m[42] &lt;&lt;  6) | (mask_m[43] &lt;&lt;  4)</a>
<a name="ln811">          | (mask_m[44] &lt;&lt;  2) | (mask_m[45] &lt;&lt;  0);</a>
<a name="ln812">    OS_REG_WRITE(ah, AR_PHY_BIN_MASK_2, tmp_mask);</a>
<a name="ln813">    OS_REG_WRITE(ah, AR_PHY_MASK2_M_31_45, tmp_mask);</a>
<a name="ln814"> </a>
<a name="ln815">    tmp_mask = (mask_m[16] &lt;&lt; 30) | (mask_m[16] &lt;&lt; 28)</a>
<a name="ln816">          | (mask_m[18] &lt;&lt; 26) | (mask_m[18] &lt;&lt; 24)</a>
<a name="ln817">          | (mask_m[20] &lt;&lt; 22) | (mask_m[20] &lt;&lt; 20)</a>
<a name="ln818">          | (mask_m[22] &lt;&lt; 18) | (mask_m[22] &lt;&lt; 16)</a>
<a name="ln819">          | (mask_m[24] &lt;&lt; 14) | (mask_m[24] &lt;&lt; 12)</a>
<a name="ln820">          | (mask_m[25] &lt;&lt; 10) | (mask_m[26] &lt;&lt;  8)</a>
<a name="ln821">          | (mask_m[27] &lt;&lt;  6) | (mask_m[28] &lt;&lt;  4)</a>
<a name="ln822">          | (mask_m[29] &lt;&lt;  2) | (mask_m[30] &lt;&lt;  0);</a>
<a name="ln823">    OS_REG_WRITE(ah, AR_PHY_BIN_MASK_3, tmp_mask);</a>
<a name="ln824">    OS_REG_WRITE(ah, AR_PHY_MASK2_M_16_30, tmp_mask);</a>
<a name="ln825"> </a>
<a name="ln826">    tmp_mask = (mask_m[ 0] &lt;&lt; 30) | (mask_m[ 1] &lt;&lt; 28)</a>
<a name="ln827">          | (mask_m[ 2] &lt;&lt; 26) | (mask_m[ 3] &lt;&lt; 24)</a>
<a name="ln828">          | (mask_m[ 4] &lt;&lt; 22) | (mask_m[ 5] &lt;&lt; 20)</a>
<a name="ln829">          | (mask_m[ 6] &lt;&lt; 18) | (mask_m[ 7] &lt;&lt; 16)</a>
<a name="ln830">          | (mask_m[ 8] &lt;&lt; 14) | (mask_m[ 9] &lt;&lt; 12)</a>
<a name="ln831">          | (mask_m[10] &lt;&lt; 10) | (mask_m[11] &lt;&lt;  8)</a>
<a name="ln832">          | (mask_m[12] &lt;&lt;  6) | (mask_m[13] &lt;&lt;  4)</a>
<a name="ln833">          | (mask_m[14] &lt;&lt;  2) | (mask_m[15] &lt;&lt;  0);</a>
<a name="ln834">    OS_REG_WRITE(ah, AR_PHY_MASK_CTL, tmp_mask);</a>
<a name="ln835">    OS_REG_WRITE(ah, AR_PHY_MASK2_M_00_15, tmp_mask);</a>
<a name="ln836"> </a>
<a name="ln837">    tmp_mask =             (mask_p[15] &lt;&lt; 28)</a>
<a name="ln838">          | (mask_p[14] &lt;&lt; 26) | (mask_p[13] &lt;&lt; 24)</a>
<a name="ln839">          | (mask_p[12] &lt;&lt; 22) | (mask_p[11] &lt;&lt; 20)</a>
<a name="ln840">          | (mask_p[10] &lt;&lt; 18) | (mask_p[ 9] &lt;&lt; 16)</a>
<a name="ln841">          | (mask_p[ 8] &lt;&lt; 14) | (mask_p[ 7] &lt;&lt; 12)</a>
<a name="ln842">          | (mask_p[ 6] &lt;&lt; 10) | (mask_p[ 5] &lt;&lt;  8)</a>
<a name="ln843">          | (mask_p[ 4] &lt;&lt;  6) | (mask_p[ 3] &lt;&lt;  4)</a>
<a name="ln844">          | (mask_p[ 2] &lt;&lt;  2) | (mask_p[ 1] &lt;&lt;  0);</a>
<a name="ln845">    OS_REG_WRITE(ah, AR_PHY_BIN_MASK2_1, tmp_mask);</a>
<a name="ln846">    OS_REG_WRITE(ah, AR_PHY_MASK2_P_15_01, tmp_mask);</a>
<a name="ln847"> </a>
<a name="ln848">    tmp_mask =             (mask_p[30] &lt;&lt; 28)</a>
<a name="ln849">          | (mask_p[29] &lt;&lt; 26) | (mask_p[28] &lt;&lt; 24)</a>
<a name="ln850">          | (mask_p[27] &lt;&lt; 22) | (mask_p[26] &lt;&lt; 20)</a>
<a name="ln851">          | (mask_p[25] &lt;&lt; 18) | (mask_p[24] &lt;&lt; 16)</a>
<a name="ln852">          | (mask_p[23] &lt;&lt; 14) | (mask_p[22] &lt;&lt; 12)</a>
<a name="ln853">          | (mask_p[21] &lt;&lt; 10) | (mask_p[20] &lt;&lt;  8)</a>
<a name="ln854">          | (mask_p[19] &lt;&lt;  6) | (mask_p[18] &lt;&lt;  4)</a>
<a name="ln855">          | (mask_p[17] &lt;&lt;  2) | (mask_p[16] &lt;&lt;  0);</a>
<a name="ln856">    OS_REG_WRITE(ah, AR_PHY_BIN_MASK2_2, tmp_mask);</a>
<a name="ln857">    OS_REG_WRITE(ah, AR_PHY_MASK2_P_30_16, tmp_mask);</a>
<a name="ln858"> </a>
<a name="ln859">    tmp_mask =             (mask_p[45] &lt;&lt; 28)</a>
<a name="ln860">          | (mask_p[44] &lt;&lt; 26) | (mask_p[43] &lt;&lt; 24)</a>
<a name="ln861">          | (mask_p[42] &lt;&lt; 22) | (mask_p[41] &lt;&lt; 20)</a>
<a name="ln862">          | (mask_p[40] &lt;&lt; 18) | (mask_p[39] &lt;&lt; 16)</a>
<a name="ln863">          | (mask_p[38] &lt;&lt; 14) | (mask_p[37] &lt;&lt; 12)</a>
<a name="ln864">          | (mask_p[36] &lt;&lt; 10) | (mask_p[35] &lt;&lt;  8)</a>
<a name="ln865">          | (mask_p[34] &lt;&lt;  6) | (mask_p[33] &lt;&lt;  4)</a>
<a name="ln866">          | (mask_p[32] &lt;&lt;  2) | (mask_p[31] &lt;&lt;  0);</a>
<a name="ln867">    OS_REG_WRITE(ah, AR_PHY_BIN_MASK2_3, tmp_mask);</a>
<a name="ln868">    OS_REG_WRITE(ah, AR_PHY_MASK2_P_45_31, tmp_mask);</a>
<a name="ln869"> </a>
<a name="ln870">    tmp_mask = (mask_p[61] &lt;&lt; 30) | (mask_p[60] &lt;&lt; 28)</a>
<a name="ln871">          | (mask_p[59] &lt;&lt; 26) | (mask_p[58] &lt;&lt; 24)</a>
<a name="ln872">          | (mask_p[57] &lt;&lt; 22) | (mask_p[56] &lt;&lt; 20)</a>
<a name="ln873">          | (mask_p[55] &lt;&lt; 18) | (mask_p[54] &lt;&lt; 16)</a>
<a name="ln874">          | (mask_p[53] &lt;&lt; 14) | (mask_p[52] &lt;&lt; 12)</a>
<a name="ln875">          | (mask_p[51] &lt;&lt; 10) | (mask_p[50] &lt;&lt;  8)</a>
<a name="ln876">          | (mask_p[49] &lt;&lt;  6) | (mask_p[48] &lt;&lt;  4)</a>
<a name="ln877">          | (mask_p[47] &lt;&lt;  2) | (mask_p[46] &lt;&lt;  0);</a>
<a name="ln878">    OS_REG_WRITE(ah, AR_PHY_BIN_MASK2_4, tmp_mask);</a>
<a name="ln879">    OS_REG_WRITE(ah, AR_PHY_MASK2_P_61_45, tmp_mask);</a>
<a name="ln880"> </a>
<a name="ln881">    OS_REG_WRITE_BUFFER_FLUSH(ah);</a>
<a name="ln882">    OS_REG_WRITE_BUFFER_DISABLE(ah);</a>
<a name="ln883">}</a>
<a name="ln884"> </a>
<a name="ln885">/*</a>
<a name="ln886"> * Fill all software cached or static hardware state information.</a>
<a name="ln887"> * Return failure if capabilities are to come from EEPROM and</a>
<a name="ln888"> * cannot be read.</a>
<a name="ln889"> */</a>
<a name="ln890">HAL_BOOL</a>
<a name="ln891">ar5416FillCapabilityInfo(struct ath_hal *ah)</a>
<a name="ln892">{</a>
<a name="ln893">	struct ath_hal_private *ahpriv = AH_PRIVATE(ah);</a>
<a name="ln894">	HAL_CAPABILITIES *pCap = &amp;ahpriv-&gt;ah_caps;</a>
<a name="ln895">	uint16_t val;</a>
<a name="ln896"> </a>
<a name="ln897">	/* Construct wireless mode from EEPROM */</a>
<a name="ln898">	pCap-&gt;halWirelessModes = 0;</a>
<a name="ln899">	if (ath_hal_eepromGetFlag(ah, AR_EEP_AMODE)) {</a>
<a name="ln900">		pCap-&gt;halWirelessModes |= HAL_MODE_11A</a>
<a name="ln901">				       |  HAL_MODE_11NA_HT20</a>
<a name="ln902">				       |  HAL_MODE_11NA_HT40PLUS</a>
<a name="ln903">				       |  HAL_MODE_11NA_HT40MINUS</a>
<a name="ln904">				       ;</a>
<a name="ln905">	}</a>
<a name="ln906">	if (ath_hal_eepromGetFlag(ah, AR_EEP_GMODE)) {</a>
<a name="ln907">		pCap-&gt;halWirelessModes |= HAL_MODE_11G</a>
<a name="ln908">				       |  HAL_MODE_11NG_HT20</a>
<a name="ln909">				       |  HAL_MODE_11NG_HT40PLUS</a>
<a name="ln910">				       |  HAL_MODE_11NG_HT40MINUS</a>
<a name="ln911">				       ;</a>
<a name="ln912">		pCap-&gt;halWirelessModes |= HAL_MODE_11A</a>
<a name="ln913">				       |  HAL_MODE_11NA_HT20</a>
<a name="ln914">				       |  HAL_MODE_11NA_HT40PLUS</a>
<a name="ln915">				       |  HAL_MODE_11NA_HT40MINUS</a>
<a name="ln916">				       ;</a>
<a name="ln917">	}</a>
<a name="ln918"> </a>
<a name="ln919">	pCap-&gt;halLow2GhzChan = 2312;</a>
<a name="ln920">	pCap-&gt;halHigh2GhzChan = 2732;</a>
<a name="ln921"> </a>
<a name="ln922">	pCap-&gt;halLow5GhzChan = 4915;</a>
<a name="ln923">	pCap-&gt;halHigh5GhzChan = 6100;</a>
<a name="ln924"> </a>
<a name="ln925">	pCap-&gt;halCipherCkipSupport = AH_FALSE;</a>
<a name="ln926">	pCap-&gt;halCipherTkipSupport = AH_TRUE;</a>
<a name="ln927">	pCap-&gt;halCipherAesCcmSupport = ath_hal_eepromGetFlag(ah, AR_EEP_AES);</a>
<a name="ln928"> </a>
<a name="ln929">	pCap-&gt;halMicCkipSupport    = AH_FALSE;</a>
<a name="ln930">	pCap-&gt;halMicTkipSupport    = AH_TRUE;</a>
<a name="ln931">	pCap-&gt;halMicAesCcmSupport  = ath_hal_eepromGetFlag(ah, AR_EEP_AES);</a>
<a name="ln932">	/*</a>
<a name="ln933">	 * Starting with Griffin TX+RX mic keys can be combined</a>
<a name="ln934">	 * in one key cache slot.</a>
<a name="ln935">	 */</a>
<a name="ln936">	pCap-&gt;halTkipMicTxRxKeySupport = AH_TRUE;</a>
<a name="ln937">	pCap-&gt;halChanSpreadSupport = AH_TRUE;</a>
<a name="ln938">	pCap-&gt;halSleepAfterBeaconBroken = AH_TRUE;</a>
<a name="ln939"> </a>
<a name="ln940">	pCap-&gt;halCompressSupport = AH_FALSE;</a>
<a name="ln941">	pCap-&gt;halBurstSupport = AH_TRUE;</a>
<a name="ln942">	pCap-&gt;halFastFramesSupport = AH_TRUE;</a>
<a name="ln943">	pCap-&gt;halChapTuningSupport = AH_TRUE;</a>
<a name="ln944">	pCap-&gt;halTurboPrimeSupport = AH_TRUE;</a>
<a name="ln945"> </a>
<a name="ln946">	pCap-&gt;halTurboGSupport = pCap-&gt;halWirelessModes &amp; HAL_MODE_108G;</a>
<a name="ln947"> </a>
<a name="ln948">	pCap-&gt;halPSPollBroken = AH_TRUE;	/* XXX fixed in later revs? */</a>
<a name="ln949">	pCap-&gt;halNumMRRetries = 4;		/* Hardware supports 4 MRR */</a>
<a name="ln950">	pCap-&gt;halNumTxMaps = 1;			/* Single TX ptr per descr */</a>
<a name="ln951">	pCap-&gt;halVEOLSupport = AH_TRUE;</a>
<a name="ln952">	pCap-&gt;halBssIdMaskSupport = AH_TRUE;</a>
<a name="ln953">	pCap-&gt;halMcastKeySrchSupport = AH_TRUE;	/* Works on AR5416 and later */</a>
<a name="ln954">	pCap-&gt;halTsfAddSupport = AH_TRUE;</a>
<a name="ln955">	pCap-&gt;hal4AddrAggrSupport = AH_FALSE;	/* Broken in Owl */</a>
<a name="ln956">	pCap-&gt;halSpectralScanSupport = AH_FALSE;	/* AR9280 and later */</a>
<a name="ln957"> </a>
<a name="ln958">	if (ath_hal_eepromGet(ah, AR_EEP_MAXQCU, &amp;val) == HAL_OK)</a>
<a name="ln959">		pCap-&gt;halTotalQueues = val;</a>
<a name="ln960">	else</a>
<a name="ln961">		pCap-&gt;halTotalQueues = HAL_NUM_TX_QUEUES;</a>
<a name="ln962"> </a>
<a name="ln963">	if (ath_hal_eepromGet(ah, AR_EEP_KCENTRIES, &amp;val) == HAL_OK)</a>
<a name="ln964">		pCap-&gt;halKeyCacheSize = val;</a>
<a name="ln965">	else</a>
<a name="ln966">		pCap-&gt;halKeyCacheSize = AR5416_KEYTABLE_SIZE;</a>
<a name="ln967"> </a>
<a name="ln968">	/* XXX Which chips? */</a>
<a name="ln969">	pCap-&gt;halChanHalfRate = AH_TRUE;</a>
<a name="ln970">	pCap-&gt;halChanQuarterRate = AH_TRUE;</a>
<a name="ln971"> </a>
<a name="ln972">	pCap-&gt;halTxTstampPrecision = 32;</a>
<a name="ln973">	pCap-&gt;halRxTstampPrecision = 32;</a>
<a name="ln974">	pCap-&gt;halHwPhyCounterSupport = AH_TRUE;</a>
<a name="ln975">	pCap-&gt;halIntrMask = HAL_INT_COMMON</a>
<a name="ln976">			| HAL_INT_RX</a>
<a name="ln977">			| HAL_INT_TX</a>
<a name="ln978">			| HAL_INT_FATAL</a>
<a name="ln979">			| HAL_INT_BNR</a>
<a name="ln980">			| HAL_INT_BMISC</a>
<a name="ln981">			| HAL_INT_DTIMSYNC</a>
<a name="ln982">			| HAL_INT_TSFOOR</a>
<a name="ln983">			| HAL_INT_CST</a>
<a name="ln984">			| HAL_INT_GTT</a>
<a name="ln985">			;</a>
<a name="ln986"> </a>
<a name="ln987">	pCap-&gt;halFastCCSupport = AH_TRUE;</a>
<a name="ln988">	pCap-&gt;halNumGpioPins = 14;</a>
<a name="ln989">	pCap-&gt;halWowSupport = AH_FALSE;</a>
<a name="ln990">	pCap-&gt;halWowMatchPatternExact = AH_FALSE;</a>
<a name="ln991">	pCap-&gt;halBtCoexSupport = AH_FALSE;	/* XXX need support */</a>
<a name="ln992">	pCap-&gt;halAutoSleepSupport = AH_FALSE;</a>
<a name="ln993">	pCap-&gt;hal4kbSplitTransSupport = AH_TRUE;</a>
<a name="ln994">	/* Disable this so Block-ACK works correctly */</a>
<a name="ln995">	pCap-&gt;halHasRxSelfLinkedTail = AH_FALSE;</a>
<a name="ln996">#if 0	/* XXX not yet */</a>
<a name="ln997">	pCap-&gt;halNumAntCfg2GHz = ar5416GetNumAntConfig(ahp, HAL_FREQ_BAND_2GHZ);</a>
<a name="ln998">	pCap-&gt;halNumAntCfg5GHz = ar5416GetNumAntConfig(ahp, HAL_FREQ_BAND_5GHZ);</a>
<a name="ln999">#endif</a>
<a name="ln1000">	pCap-&gt;halHTSupport = AH_TRUE;</a>
<a name="ln1001">	pCap-&gt;halTxChainMask = ath_hal_eepromGet(ah, AR_EEP_TXMASK, AH_NULL);</a>
<a name="ln1002">	/* XXX CB71 uses GPIO 0 to indicate 3 rx chains */</a>
<a name="ln1003">	pCap-&gt;halRxChainMask = ath_hal_eepromGet(ah, AR_EEP_RXMASK, AH_NULL);</a>
<a name="ln1004">	/* AR5416 may have 3 antennas but is a 2x2 stream device */</a>
<a name="ln1005">	pCap-&gt;halTxStreams = 2;</a>
<a name="ln1006">	pCap-&gt;halRxStreams = 2;</a>
<a name="ln1007"> </a>
<a name="ln1008">	/*</a>
<a name="ln1009">	 * If the TX or RX chainmask has less than 2 chains active,</a>
<a name="ln1010">	 * mark it as a 1-stream device for the relevant stream.</a>
<a name="ln1011">	 */</a>
<a name="ln1012">	if (owl_get_ntxchains(pCap-&gt;halTxChainMask) == 1)</a>
<a name="ln1013">		pCap-&gt;halTxStreams = 1;</a>
<a name="ln1014">	/* XXX Eww */</a>
<a name="ln1015">	if (owl_get_ntxchains(pCap-&gt;halRxChainMask) == 1)</a>
<a name="ln1016">		pCap-&gt;halRxStreams = 1;</a>
<a name="ln1017">	pCap-&gt;halRtsAggrLimit = 8*1024;		/* Owl 2.0 limit */</a>
<a name="ln1018">	pCap-&gt;halMbssidAggrSupport = AH_FALSE;	/* Broken on Owl */</a>
<a name="ln1019">	pCap-&gt;halForcePpmSupport = AH_TRUE;</a>
<a name="ln1020">	pCap-&gt;halEnhancedPmSupport = AH_TRUE;</a>
<a name="ln1021">	pCap-&gt;halBssidMatchSupport = AH_TRUE;</a>
<a name="ln1022">	pCap-&gt;halGTTSupport = AH_TRUE;</a>
<a name="ln1023">	pCap-&gt;halCSTSupport = AH_TRUE;</a>
<a name="ln1024">	pCap-&gt;halEnhancedDfsSupport = AH_FALSE;</a>
<a name="ln1025">	/*</a>
<a name="ln1026">	 * BB Read WAR: this is only for AR5008/AR9001 NICs</a>
<a name="ln1027">	 * It is also set individually in the AR91xx attach functions.</a>
<a name="ln1028">	 */</a>
<a name="ln1029">	if (AR_SREV_OWL(ah))</a>
<a name="ln1030">		pCap-&gt;halHasBBReadWar = AH_TRUE;</a>
<a name="ln1031"> </a>
<a name="ln1032">	if (ath_hal_eepromGetFlag(ah, AR_EEP_RFKILL) &amp;&amp;</a>
<a name="ln1033">	    ath_hal_eepromGet(ah, AR_EEP_RFSILENT, &amp;ahpriv-&gt;ah_rfsilent) == HAL_OK) {</a>
<a name="ln1034">		/* NB: enabled by default */</a>
<a name="ln1035">		ahpriv-&gt;ah_rfkillEnabled = AH_TRUE;</a>
<a name="ln1036">		pCap-&gt;halRfSilentSupport = AH_TRUE;</a>
<a name="ln1037">	}</a>
<a name="ln1038"> </a>
<a name="ln1039">	/*</a>
<a name="ln1040">	 * The MAC will mark frames as RXed if there's a descriptor</a>
<a name="ln1041">	 * to write them to. So if it hits a self-linked final descriptor,</a>
<a name="ln1042">	 * it'll keep ACKing frames even though they're being silently</a>
<a name="ln1043">	 * dropped. Thus, this particular feature of the driver can't</a>
<a name="ln1044">	 * be used for 802.11n devices.</a>
<a name="ln1045">	 */</a>
<a name="ln1046">	ahpriv-&gt;ah_rxornIsFatal = AH_FALSE;</a>
<a name="ln1047"> </a>
<a name="ln1048">	/*</a>
<a name="ln1049">	 * If it's a PCI NIC, ask the HAL OS layer to serialise</a>
<a name="ln1050">	 * register access, or SMP machines may cause the hardware</a>
<a name="ln1051">	 * to hang. This is applicable to AR5416 and AR9220; I'm not</a>
<a name="ln1052">	 * sure about AR9160 or AR9227.</a>
<a name="ln1053">	 */</a>
<a name="ln1054">	if (! AH_PRIVATE(ah)-&gt;ah_ispcie)</a>
<a name="ln1055">		pCap-&gt;halSerialiseRegWar = 1;</a>
<a name="ln1056"> </a>
<a name="ln1057">	/*</a>
<a name="ln1058">	 * AR5416 and later NICs support MYBEACON filtering.</a>
<a name="ln1059">	 */</a>
<a name="ln1060">	pCap-&gt;halRxDoMyBeacon = AH_TRUE;</a>
<a name="ln1061"> </a>
<a name="ln1062">	return AH_TRUE;</a>
<a name="ln1063">}</a>
<a name="ln1064"> </a>
<a name="ln1065">static const char*</a>
<a name="ln1066">ar5416Probe(uint16_t vendorid, uint16_t devid)</a>
<a name="ln1067">{</a>
<a name="ln1068">	if (vendorid == ATHEROS_VENDOR_ID) {</a>
<a name="ln1069">		if (devid == AR5416_DEVID_PCI)</a>
<a name="ln1070">			return &quot;Atheros 5416&quot;;</a>
<a name="ln1071">		if (devid == AR5416_DEVID_PCIE)</a>
<a name="ln1072">			return &quot;Atheros 5418&quot;;</a>
<a name="ln1073">	}</a>
<a name="ln1074">	return AH_NULL;</a>
<a name="ln1075">}</a>
<a name="ln1076">AH_CHIP(AR5416, ar5416Probe, ar5416Attach);</a>

</code></pre>
<div class="balloon" rel="367"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The '1' index is pointing beyond array bound.</p></div>
<div class="balloon" rel="368"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The '1' index is pointing beyond array bound.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
