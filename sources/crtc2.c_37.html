
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>crtc2.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* second CTRC functionality for GeForce cards */</a>
<a name="ln2">/* Author:</a>
<a name="ln3">   Rudolf Cornelissen 11/2002-9/2004</a>
<a name="ln4">*/</a>
<a name="ln5"> </a>
<a name="ln6">#define MODULE_BIT 0x00020000</a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;std.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">/*Adjust passed parameters to a valid mode line*/</a>
<a name="ln11">status_t eng_crtc2_validate_timing(</a>
<a name="ln12">	uint16 *hd_e,uint16 *hs_s,uint16 *hs_e,uint16 *ht,</a>
<a name="ln13">	uint16 *vd_e,uint16 *vs_s,uint16 *vs_e,uint16 *vt</a>
<a name="ln14">)</a>
<a name="ln15">{</a>
<a name="ln16">/* horizontal */</a>
<a name="ln17">	/* make all parameters multiples of 8 */</a>
<a name="ln18">	*hd_e &amp;= 0xfff8;</a>
<a name="ln19">	*hs_s &amp;= 0xfff8;</a>
<a name="ln20">	*hs_e &amp;= 0xfff8;</a>
<a name="ln21">	*ht   &amp;= 0xfff8;</a>
<a name="ln22"> </a>
<a name="ln23">	/* confine to required number of bits, taking logic into account */</a>
<a name="ln24">	if (*hd_e &gt; ((0x01ff - 2) &lt;&lt; 3)) *hd_e = ((0x01ff - 2) &lt;&lt; 3);</a>
<a name="ln25">	if (*hs_s &gt; ((0x01ff - 1) &lt;&lt; 3)) *hs_s = ((0x01ff - 1) &lt;&lt; 3);</a>
<a name="ln26">	if (*hs_e &gt; ( 0x01ff      &lt;&lt; 3)) *hs_e = ( 0x01ff      &lt;&lt; 3);</a>
<a name="ln27">	if (*ht   &gt; ((0x01ff + 5) &lt;&lt; 3)) *ht   = ((0x01ff + 5) &lt;&lt; 3);</a>
<a name="ln28"> </a>
<a name="ln29">	/* NOTE: keep horizontal timing at multiples of 8! */</a>
<a name="ln30">	/* confine to a reasonable width */</a>
<a name="ln31">	if (*hd_e &lt; 640) *hd_e = 640;</a>
<a name="ln32">	if (*hd_e &gt; 2048) *hd_e = 2048;</a>
<a name="ln33"> </a>
<a name="ln34">	/* if hor. total does not leave room for a sensible sync pulse, increase it! */</a>
<a name="ln35">	if (*ht &lt; (*hd_e + 80)) *ht = (*hd_e + 80);</a>
<a name="ln36"> </a>
<a name="ln37">	/* if hor. total does not adhere to max. blanking pulse width, decrease it! */</a>
<a name="ln38">	if (*ht &gt; (*hd_e + 0x3f8)) *ht = (*hd_e + 0x3f8);</a>
<a name="ln39"> </a>
<a name="ln40">	/* make sure sync pulse is not during display */</a>
<a name="ln41">	if (*hs_e &gt; (*ht - 8)) *hs_e = (*ht - 8);</a>
<a name="ln42">	if (*hs_s &lt; (*hd_e + 8)) *hs_s = (*hd_e + 8);</a>
<a name="ln43"> </a>
<a name="ln44">	/* correct sync pulse if it is too long:</a>
<a name="ln45">	 * there are only 5 bits available to save this in the card registers! */</a>
<a name="ln46">	if (*hs_e &gt; (*hs_s + 0xf8)) *hs_e = (*hs_s + 0xf8);</a>
<a name="ln47"> </a>
<a name="ln48">/*vertical*/</a>
<a name="ln49">	/* confine to required number of bits, taking logic into account */</a>
<a name="ln50">	//fixme if needed: on GeForce cards there are 12 instead of 11 bits...</a>
<a name="ln51">	if (*vd_e &gt; (0x7ff - 2)) *vd_e = (0x7ff - 2);</a>
<a name="ln52">	if (*vs_s &gt; (0x7ff - 1)) *vs_s = (0x7ff - 1);</a>
<a name="ln53">	if (*vs_e &gt;  0x7ff     ) *vs_e =  0x7ff     ;</a>
<a name="ln54">	if (*vt   &gt; (0x7ff + 2)) *vt   = (0x7ff + 2);</a>
<a name="ln55"> </a>
<a name="ln56">	/* confine to a reasonable height */</a>
<a name="ln57">	if (*vd_e &lt; 480) *vd_e = 480;</a>
<a name="ln58">	if (*vd_e &gt; 1536) *vd_e = 1536;</a>
<a name="ln59"> </a>
<a name="ln60">	/*if vertical total does not leave room for a sync pulse, increase it!*/</a>
<a name="ln61">	if (*vt &lt; (*vd_e + 3)) *vt = (*vd_e + 3);</a>
<a name="ln62"> </a>
<a name="ln63">	/* if vert. total does not adhere to max. blanking pulse width, decrease it! */</a>
<a name="ln64">	if (*vt &gt; (*vd_e + 0xff)) *vt = (*vd_e + 0xff);</a>
<a name="ln65"> </a>
<a name="ln66">	/* make sure sync pulse is not during display */</a>
<a name="ln67">	if (*vs_e &gt; (*vt - 1)) *vs_e = (*vt - 1);</a>
<a name="ln68">	if (*vs_s &lt; (*vd_e + 1)) *vs_s = (*vd_e + 1);</a>
<a name="ln69"> </a>
<a name="ln70">	/* correct sync pulse if it is too long:</a>
<a name="ln71">	 * there are only 4 bits available to save this in the card registers! */</a>
<a name="ln72">	if (*vs_e &gt; (*vs_s + 0x0f)) *vs_e = (*vs_s + 0x0f);</a>
<a name="ln73"> </a>
<a name="ln74">	return B_OK;</a>
<a name="ln75">}</a>
<a name="ln76"> </a>
<a name="ln77">/*set a mode line - inputs are in pixels*/</a>
<a name="ln78">status_t eng_crtc2_set_timing(display_mode target)</a>
<a name="ln79">{</a>
<a name="ln80">	uint8 temp;</a>
<a name="ln81"> </a>
<a name="ln82">	uint32 htotal;		/*total horizontal total VCLKs*/</a>
<a name="ln83">	uint32 hdisp_e;            /*end of horizontal display (begins at 0)*/</a>
<a name="ln84">	uint32 hsync_s;            /*begin of horizontal sync pulse*/</a>
<a name="ln85">	uint32 hsync_e;            /*end of horizontal sync pulse*/</a>
<a name="ln86">	uint32 hblnk_s;            /*begin horizontal blanking*/</a>
<a name="ln87">	uint32 hblnk_e;            /*end horizontal blanking*/</a>
<a name="ln88"> </a>
<a name="ln89">	uint32 vtotal;		/*total vertical total scanlines*/</a>
<a name="ln90">	uint32 vdisp_e;            /*end of vertical display*/</a>
<a name="ln91">	uint32 vsync_s;            /*begin of vertical sync pulse*/</a>
<a name="ln92">	uint32 vsync_e;            /*end of vertical sync pulse*/</a>
<a name="ln93">	uint32 vblnk_s;            /*begin vertical blanking*/</a>
<a name="ln94">	uint32 vblnk_e;            /*end vertical blanking*/</a>
<a name="ln95"> </a>
<a name="ln96">	uint32 linecomp;	/*split screen and vdisp_e interrupt*/</a>
<a name="ln97"> </a>
<a name="ln98">	LOG(4,(&quot;CRTC2: setting timing\n&quot;));</a>
<a name="ln99"> </a>
<a name="ln100">	/* setup tuned internal modeline for flatpanel if connected and active */</a>
<a name="ln101">	/* notes:</a>
<a name="ln102">	 * - the CRTC modeline must end earlier than the panel modeline to keep correct</a>
<a name="ln103">	 *   sync going;</a>
<a name="ln104">	 * - if the CRTC modeline ends too soon, pixelnoise will occur in 8 (or so) pixel</a>
<a name="ln105">	 *   wide horizontal stripes. This can be observed earliest on fullscreen overlay,</a>
<a name="ln106">	 *   and if it gets worse, also normal desktop output will suffer. The stripes</a>
<a name="ln107">	 *   are mainly visible at the left of the screen, over the entire screen height. */</a>
<a name="ln108">	if (si-&gt;ps.tmds2_active)</a>
<a name="ln109">	{</a>
<a name="ln110">		LOG(2,(&quot;CRTC2: DFP active: tuning modeline\n&quot;));</a>
<a name="ln111"> </a>
<a name="ln112">		/* horizontal timing */</a>
<a name="ln113">		target.timing.h_sync_start =</a>
<a name="ln114">			((uint16)((si-&gt;ps.p2_timing.h_sync_start / ((float)si-&gt;ps.p2_timing.h_display)) *</a>
<a name="ln115">			target.timing.h_display)) &amp; 0xfff8;</a>
<a name="ln116"> </a>
<a name="ln117">		target.timing.h_sync_end =</a>
<a name="ln118">			((uint16)((si-&gt;ps.p2_timing.h_sync_end / ((float)si-&gt;ps.p2_timing.h_display)) *</a>
<a name="ln119">			target.timing.h_display)) &amp; 0xfff8;</a>
<a name="ln120"> </a>
<a name="ln121">		target.timing.h_total =</a>
<a name="ln122">			(((uint16)((si-&gt;ps.p2_timing.h_total / ((float)si-&gt;ps.p2_timing.h_display)) *</a>
<a name="ln123">			target.timing.h_display)) &amp; 0xfff8) - 8;</a>
<a name="ln124"> </a>
<a name="ln125">		/* in native mode the CRTC needs some extra time to keep synced correctly;</a>
<a name="ln126">		 * OTOH the overlay unit distorts if we reserve too much time! */</a>
<a name="ln127">		if (target.timing.h_display == si-&gt;ps.p2_timing.h_display)</a>
<a name="ln128">		{</a>
<a name="ln129">			/* NV11 timing has different constraints than later cards */</a>
<a name="ln130">			if (si-&gt;ps.card_type == NV11)</a>
<a name="ln131">				target.timing.h_total -= 56;</a>
<a name="ln132">			else</a>
<a name="ln133">				/* confirmed NV34 with 1680x1050 panel */</a>
<a name="ln134">				target.timing.h_total -= 32;</a>
<a name="ln135">		}</a>
<a name="ln136"> </a>
<a name="ln137">		if (target.timing.h_sync_start == target.timing.h_display)</a>
<a name="ln138">			target.timing.h_sync_start += 8;</a>
<a name="ln139">		if (target.timing.h_sync_end == target.timing.h_total)</a>
<a name="ln140">			target.timing.h_sync_end -= 8;</a>
<a name="ln141"> </a>
<a name="ln142">		/* vertical timing */</a>
<a name="ln143">		target.timing.v_sync_start =</a>
<a name="ln144">			((uint16)((si-&gt;ps.p2_timing.v_sync_start / ((float)si-&gt;ps.p2_timing.v_display)) *</a>
<a name="ln145">			target.timing.v_display));</a>
<a name="ln146"> </a>
<a name="ln147">		target.timing.v_sync_end =</a>
<a name="ln148">			((uint16)((si-&gt;ps.p2_timing.v_sync_end / ((float)si-&gt;ps.p2_timing.v_display)) *</a>
<a name="ln149">			target.timing.v_display));</a>
<a name="ln150"> </a>
<a name="ln151">		target.timing.v_total =</a>
<a name="ln152">			((uint16)((si-&gt;ps.p2_timing.v_total / ((float)si-&gt;ps.p2_timing.v_display)) *</a>
<a name="ln153">			target.timing.v_display)) - 1;</a>
<a name="ln154"> </a>
<a name="ln155">		if (target.timing.v_sync_start == target.timing.v_display)</a>
<a name="ln156">			target.timing.v_sync_start += 1;</a>
<a name="ln157">		if (target.timing.v_sync_end == target.timing.v_total)</a>
<a name="ln158">			target.timing.v_sync_end -= 1;</a>
<a name="ln159"> </a>
<a name="ln160">		/* disable GPU scaling testmode so automatic scaling will be done */</a>
<a name="ln161">		DAC2W(FP_DEBUG1, 0);</a>
<a name="ln162">	}</a>
<a name="ln163"> </a>
<a name="ln164">	/* Modify parameters as required by standard VGA */</a>
<a name="ln165">	htotal = ((target.timing.h_total &gt;&gt; 3) - 5);</a>
<a name="ln166">	hdisp_e = ((target.timing.h_display &gt;&gt; 3) - 1);</a>
<a name="ln167">	hblnk_s = hdisp_e;</a>
<a name="ln168">	hblnk_e = (htotal + 4);//0;</a>
<a name="ln169">	hsync_s = (target.timing.h_sync_start &gt;&gt; 3);</a>
<a name="ln170">	hsync_e = (target.timing.h_sync_end &gt;&gt; 3);</a>
<a name="ln171"> </a>
<a name="ln172">	vtotal = target.timing.v_total - 2;</a>
<a name="ln173">	vdisp_e = target.timing.v_display - 1;</a>
<a name="ln174">	vblnk_s = vdisp_e;</a>
<a name="ln175">	vblnk_e = (vtotal + 1);</a>
<a name="ln176">	vsync_s = target.timing.v_sync_start;//-1;</a>
<a name="ln177">	vsync_e = target.timing.v_sync_end;//-1;</a>
<a name="ln178"> </a>
<a name="ln179">	/* prevent memory adress counter from being reset (linecomp may not occur) */</a>
<a name="ln180">	linecomp = target.timing.v_display;</a>
<a name="ln181"> </a>
<a name="ln182">	/* enable access to secondary head */</a>
<a name="ln183">	set_crtc_owner(1);</a>
<a name="ln184"> </a>
<a name="ln185">	/* Note for laptop and DVI flatpanels:</a>
<a name="ln186">	 * CRTC timing has a seperate set of registers from flatpanel timing.</a>
<a name="ln187">	 * The flatpanel timing registers have scaling registers that are used to match</a>
<a name="ln188">	 * these two modelines. */</a>
<a name="ln189">	{</a>
<a name="ln190">		LOG(4,(&quot;CRTC2: Setting full timing...\n&quot;));</a>
<a name="ln191"> </a>
<a name="ln192">		/* log the mode that will be set */</a>
<a name="ln193">		LOG(2,(&quot;CRTC2:\n\tHTOT:%x\n\tHDISPEND:%x\n\tHBLNKS:%x\n\tHBLNKE:%x\n\tHSYNCS:%x\n\tHSYNCE:%x\n\t&quot;,htotal,hdisp_e,hblnk_s,hblnk_e,hsync_s,hsync_e));</a>
<a name="ln194">		LOG(2,(&quot;VTOT:%x\n\tVDISPEND:%x\n\tVBLNKS:%x\n\tVBLNKE:%x\n\tVSYNCS:%x\n\tVSYNCE:%x\n&quot;,vtotal,vdisp_e,vblnk_s,vblnk_e,vsync_s,vsync_e));</a>
<a name="ln195"> </a>
<a name="ln196">		/* actually program the card! */</a>
<a name="ln197">		/* unlock CRTC registers at index 0-7 */</a>
<a name="ln198">		CRTC2W(VSYNCE, (CRTC2R(VSYNCE) &amp; 0x7f));</a>
<a name="ln199">		/* horizontal standard VGA regs */</a>
<a name="ln200">		CRTC2W(HTOTAL, (htotal &amp; 0xff));</a>
<a name="ln201">		CRTC2W(HDISPE, (hdisp_e &amp; 0xff));</a>
<a name="ln202">		CRTC2W(HBLANKS, (hblnk_s &amp; 0xff));</a>
<a name="ln203">		/* also unlock vertical retrace registers in advance */</a>
<a name="ln204">		CRTC2W(HBLANKE, ((hblnk_e &amp; 0x1f) | 0x80));</a>
<a name="ln205">		CRTC2W(HSYNCS, (hsync_s &amp; 0xff));</a>
<a name="ln206">		CRTC2W(HSYNCE, ((hsync_e &amp; 0x1f) | ((hblnk_e &amp; 0x20) &lt;&lt; 2)));</a>
<a name="ln207"> </a>
<a name="ln208">		/* vertical standard VGA regs */</a>
<a name="ln209">		CRTC2W(VTOTAL, (vtotal &amp; 0xff));</a>
<a name="ln210">		CRTC2W(OVERFLOW,</a>
<a name="ln211">		(</a>
<a name="ln212">			((vtotal &amp; 0x100) &gt;&gt; (8 - 0)) | ((vtotal &amp; 0x200) &gt;&gt; (9 - 5)) |</a>
<a name="ln213">			((vdisp_e &amp; 0x100) &gt;&gt; (8 - 1)) | ((vdisp_e &amp; 0x200) &gt;&gt; (9 - 6)) |</a>
<a name="ln214">			((vsync_s &amp; 0x100) &gt;&gt; (8 - 2)) | ((vsync_s &amp; 0x200) &gt;&gt; (9 - 7)) |</a>
<a name="ln215">			((vblnk_s &amp; 0x100) &gt;&gt; (8 - 3)) | ((linecomp &amp; 0x100) &gt;&gt; (8 - 4))</a>
<a name="ln216">		));</a>
<a name="ln217">		CRTC2W(PRROWSCN, 0x00); /* not used */</a>
<a name="ln218">		CRTC2W(MAXSCLIN, (((vblnk_s &amp; 0x200) &gt;&gt; (9 - 5)) | ((linecomp &amp; 0x200) &gt;&gt; (9 - 6))));</a>
<a name="ln219">		CRTC2W(VSYNCS, (vsync_s &amp; 0xff));</a>
<a name="ln220">		CRTC2W(VSYNCE, ((CRTC2R(VSYNCE) &amp; 0xf0) | (vsync_e &amp; 0x0f)));</a>
<a name="ln221">		CRTC2W(VDISPE, (vdisp_e &amp; 0xff));</a>
<a name="ln222">		CRTC2W(VBLANKS, (vblnk_s &amp; 0xff));</a>
<a name="ln223">		CRTC2W(VBLANKE, (vblnk_e &amp; 0xff));</a>
<a name="ln224">		CRTC2W(LINECOMP, (linecomp &amp; 0xff));</a>
<a name="ln225"> </a>
<a name="ln226">		/* horizontal extended regs */</a>
<a name="ln227">		//fixme: we reset bit4. is this correct??</a>
<a name="ln228">		CRTC2W(HEB, (CRTC2R(HEB) &amp; 0xe0) |</a>
<a name="ln229">			(</a>
<a name="ln230">		 	((htotal &amp; 0x100) &gt;&gt; (8 - 0)) |</a>
<a name="ln231">			((hdisp_e &amp; 0x100) &gt;&gt; (8 - 1)) |</a>
<a name="ln232">			((hblnk_s &amp; 0x100) &gt;&gt; (8 - 2)) |</a>
<a name="ln233">			((hsync_s &amp; 0x100) &gt;&gt; (8 - 3))</a>
<a name="ln234">			));</a>
<a name="ln235"> </a>
<a name="ln236">		/* (mostly) vertical extended regs */</a>
<a name="ln237">		CRTC2W(LSR,</a>
<a name="ln238">			(</a>
<a name="ln239">		 	((vtotal &amp; 0x400) &gt;&gt; (10 - 0)) |</a>
<a name="ln240">			((vdisp_e &amp; 0x400) &gt;&gt; (10 - 1)) |</a>
<a name="ln241">			((vsync_s &amp; 0x400) &gt;&gt; (10 - 2)) |</a>
<a name="ln242">			((vblnk_s &amp; 0x400) &gt;&gt; (10 - 3)) |</a>
<a name="ln243">			((hblnk_e &amp; 0x040) &gt;&gt; (6 - 4))</a>
<a name="ln244">			//fixme: we still miss one linecomp bit!?! is this it??</a>
<a name="ln245">			//| ((linecomp &amp; 0x400) &gt;&gt; 3)	</a>
<a name="ln246">			));</a>
<a name="ln247"> </a>
<a name="ln248">		/* more vertical extended regs */</a>
<a name="ln249">		CRTC2W(EXTRA,</a>
<a name="ln250">			(</a>
<a name="ln251">		 	((vtotal &amp; 0x800) &gt;&gt; (11 - 0)) |</a>
<a name="ln252">			((vdisp_e &amp; 0x800) &gt;&gt; (11 - 2)) |</a>
<a name="ln253">			((vsync_s &amp; 0x800) &gt;&gt; (11 - 4)) |</a>
<a name="ln254">			((vblnk_s &amp; 0x800) &gt;&gt; (11 - 6))</a>
<a name="ln255">			//fixme: do we miss another linecomp bit!?!</a>
<a name="ln256">			));</a>
<a name="ln257"> </a>
<a name="ln258">		/* setup 'large screen' mode */</a>
<a name="ln259">		if (target.timing.h_display &gt;= 1280)</a>
<a name="ln260">			CRTC2W(REPAINT1, (CRTC2R(REPAINT1) &amp; 0xfb));</a>
<a name="ln261">		else</a>
<a name="ln262">			CRTC2W(REPAINT1, (CRTC2R(REPAINT1) | 0x04));</a>
<a name="ln263"> </a>
<a name="ln264">		/* setup HSYNC &amp; VSYNC polarity */</a>
<a name="ln265">		LOG(2,(&quot;CRTC2: sync polarity: &quot;));</a>
<a name="ln266">		temp = ENG_REG8(RG8_MISCR);</a>
<a name="ln267">		if (target.timing.flags &amp; B_POSITIVE_HSYNC)</a>
<a name="ln268">		{</a>
<a name="ln269">			LOG(2,(&quot;H:pos &quot;));</a>
<a name="ln270">			temp &amp;= ~0x40;</a>
<a name="ln271">		}</a>
<a name="ln272">		else</a>
<a name="ln273">		{</a>
<a name="ln274">			LOG(2,(&quot;H:neg &quot;));</a>
<a name="ln275">			temp |= 0x40;</a>
<a name="ln276">		}</a>
<a name="ln277">		if (target.timing.flags &amp; B_POSITIVE_VSYNC)</a>
<a name="ln278">		{</a>
<a name="ln279">			LOG(2,(&quot;V:pos &quot;));</a>
<a name="ln280">			temp &amp;= ~0x80;</a>
<a name="ln281">		}</a>
<a name="ln282">		else</a>
<a name="ln283">		{</a>
<a name="ln284">			LOG(2,(&quot;V:neg &quot;));</a>
<a name="ln285">			temp |= 0x80;</a>
<a name="ln286">		}</a>
<a name="ln287">		ENG_REG8(RG8_MISCW) = temp;</a>
<a name="ln288"> </a>
<a name="ln289">		LOG(2,(&quot;, MISC reg readback: $%02x\n&quot;, ENG_REG8(RG8_MISCR)));</a>
<a name="ln290">	}</a>
<a name="ln291"> </a>
<a name="ln292">	/* always disable interlaced operation */</a>
<a name="ln293">	/* (interlace is supported on upto and including NV10, NV15, and NV30 and up) */</a>
<a name="ln294">	CRTC2W(INTERLACE, 0xff);</a>
<a name="ln295"> </a>
<a name="ln296">	/* disable CRTC slaved mode unless a panel is in use */</a>
<a name="ln297">	// fixme: this kills TVout when it was in use...</a>
<a name="ln298">	if (!si-&gt;ps.tmds2_active) CRTC2W(PIXEL, (CRTC2R(PIXEL) &amp; 0x7f));</a>
<a name="ln299"> </a>
<a name="ln300">	/* setup flatpanel if connected and active */</a>
<a name="ln301">	if (si-&gt;ps.tmds2_active)</a>
<a name="ln302">	{</a>
<a name="ln303">		uint32 iscale_x, iscale_y;</a>
<a name="ln304"> </a>
<a name="ln305">		/* calculate inverse scaling factors used by hardware in 20.12 format */</a>
<a name="ln306">		iscale_x = (((1 &lt;&lt; 12) * target.timing.h_display) / si-&gt;ps.p2_timing.h_display);</a>
<a name="ln307">		iscale_y = (((1 &lt;&lt; 12) * target.timing.v_display) / si-&gt;ps.p2_timing.v_display);</a>
<a name="ln308"> </a>
<a name="ln309">		/* unblock flatpanel timing programming (or something like that..) */</a>
<a name="ln310">		CRTC2W(FP_HTIMING, 0);</a>
<a name="ln311">		CRTC2W(FP_VTIMING, 0);</a>
<a name="ln312">		LOG(2,(&quot;CRTC2: FP_HTIMING reg readback: $%02x\n&quot;, CRTC2R(FP_HTIMING)));</a>
<a name="ln313">		LOG(2,(&quot;CRTC2: FP_VTIMING reg readback: $%02x\n&quot;, CRTC2R(FP_VTIMING)));</a>
<a name="ln314"> </a>
<a name="ln315">		/* enable full width visibility on flatpanel */</a>
<a name="ln316">		DAC2W(FP_HVALID_S, 0);</a>
<a name="ln317">		DAC2W(FP_HVALID_E, (si-&gt;ps.p2_timing.h_display - 1));</a>
<a name="ln318">		/* enable full height visibility on flatpanel */</a>
<a name="ln319">		DAC2W(FP_VVALID_S, 0);</a>
<a name="ln320">		DAC2W(FP_VVALID_E, (si-&gt;ps.p2_timing.v_display - 1));</a>
<a name="ln321"> </a>
<a name="ln322">		/* nVidia cards support upscaling except on ??? */</a>
<a name="ln323">		/* NV11 cards can upscale after all! */</a>
<a name="ln324">		if (0)//si-&gt;ps.card_type == NV11)</a>
<a name="ln325">		{</a>
<a name="ln326">			/* disable last fetched line limiting */</a>
<a name="ln327">			DAC2W(FP_DEBUG2, 0x00000000);</a>
<a name="ln328">			/* inform panel to scale if needed */</a>
<a name="ln329">			if ((iscale_x != (1 &lt;&lt; 12)) || (iscale_y != (1 &lt;&lt; 12)))</a>
<a name="ln330">			{</a>
<a name="ln331">				LOG(2,(&quot;CRTC2: DFP needs to do scaling\n&quot;));</a>
<a name="ln332">				DAC2W(FP_TG_CTRL, (DAC2R(FP_TG_CTRL) | 0x00000100));</a>
<a name="ln333">			}</a>
<a name="ln334">			else</a>
<a name="ln335">			{</a>
<a name="ln336">				LOG(2,(&quot;CRTC2: no scaling for DFP needed\n&quot;));</a>
<a name="ln337">				DAC2W(FP_TG_CTRL, (DAC2R(FP_TG_CTRL) &amp; 0xfffffeff));</a>
<a name="ln338">			}</a>
<a name="ln339">		}</a>
<a name="ln340">		else</a>
<a name="ln341">		{</a>
<a name="ln342">			float dm_aspect;</a>
<a name="ln343"> </a>
<a name="ln344">			LOG(2,(&quot;CRTC2: GPU scales for DFP if needed\n&quot;));</a>
<a name="ln345"> </a>
<a name="ln346">			/* calculate display mode aspect */</a>
<a name="ln347">			dm_aspect = (target.timing.h_display / ((float)target.timing.v_display));</a>
<a name="ln348"> </a>
<a name="ln349">			/* limit last fetched line if vertical scaling is done */</a>
<a name="ln350">			if (iscale_y != (1 &lt;&lt; 12))</a>
<a name="ln351">				DAC2W(FP_DEBUG2, ((1 &lt;&lt; 28) | ((target.timing.v_display - 1) &lt;&lt; 16)));</a>
<a name="ln352">			else</a>
<a name="ln353">				DAC2W(FP_DEBUG2, 0x00000000);</a>
<a name="ln354"> </a>
<a name="ln355">			/* inform panel not to scale */</a>
<a name="ln356">			DAC2W(FP_TG_CTRL, (DAC2R(FP_TG_CTRL) &amp; 0xfffffeff));</a>
<a name="ln357"> </a>
<a name="ln358">			/* GPU scaling is automatically setup by hardware, so only modify this</a>
<a name="ln359">			 * scalingfactor for non 4:3 (1.33) aspect panels;</a>
<a name="ln360">			 * let's consider 1280x1024 1:33 aspect (it's 1.25 aspect actually!) */</a>
<a name="ln361"> </a>
<a name="ln362">			/* correct for widescreen panels relative to mode...</a>
<a name="ln363">			 * (so if panel is more widescreen than mode being set) */</a>
<a name="ln364">			/* BTW: known widescreen panels:</a>
<a name="ln365">			 * 1280 x  800 (1.60),</a>
<a name="ln366">			 * 1440 x  900 (1.60),</a>
<a name="ln367">			 * 1680 x 1050 (1.60),</a>
<a name="ln368">			 * 1920 x 1200 (1.60). */</a>
<a name="ln369">			/* known 4:3 aspect non-standard resolution panels:</a>
<a name="ln370">			 * 1400 x 1050 (1.33). */</a>
<a name="ln371">			/* NOTE:</a>
<a name="ln372">			 * allow 0.10 difference so 1280x1024 panels will be used fullscreen! */</a>
<a name="ln373">			if ((iscale_x != (1 &lt;&lt; 12)) &amp;&amp; (si-&gt;ps.panel2_aspect &gt; (dm_aspect + 0.10)))</a>
<a name="ln374">			{</a>
<a name="ln375">				uint16 diff;</a>
<a name="ln376"> </a>
<a name="ln377">				LOG(2,(&quot;CRTC2: (relative) widescreen panel: tuning horizontal scaling\n&quot;));</a>
<a name="ln378"> </a>
<a name="ln379">				/* X-scaling should be the same as Y-scaling */</a>
<a name="ln380">				iscale_x = iscale_y;</a>
<a name="ln381">				/* enable testmode (b12) and program new X-scaling factor */</a>
<a name="ln382">				DAC2W(FP_DEBUG1, (((iscale_x &gt;&gt; 1) &amp; 0x00000fff) | (1 &lt;&lt; 12)));</a>
<a name="ln383">				/* center/cut-off left and right side of screen */</a>
<a name="ln384">				diff = ((si-&gt;ps.p2_timing.h_display -</a>
<a name="ln385">						(target.timing.h_display * ((1 &lt;&lt; 12) / ((float)iscale_x))))</a>
<a name="ln386">						/ 2);</a>
<a name="ln387">				DAC2W(FP_HVALID_S, diff);</a>
<a name="ln388">				DAC2W(FP_HVALID_E, ((si-&gt;ps.p2_timing.h_display - diff) - 1));</a>
<a name="ln389">			}</a>
<a name="ln390">			/* correct for portrait panels... */</a>
<a name="ln391">			/* NOTE:</a>
<a name="ln392">			 * allow 0.10 difference so 1280x1024 panels will be used fullscreen! */</a>
<a name="ln393">			if ((iscale_y != (1 &lt;&lt; 12)) &amp;&amp; (si-&gt;ps.panel2_aspect &lt; (dm_aspect - 0.10)))</a>
<a name="ln394">			{</a>
<a name="ln395">				LOG(2,(&quot;CRTC2: (relative) portrait panel: should tune vertical scaling\n&quot;));</a>
<a name="ln396">				/* fixme: implement if this kind of portrait panels exist on nVidia... */</a>
<a name="ln397">			}</a>
<a name="ln398">		}</a>
<a name="ln399"> </a>
<a name="ln400">		/* do some logging.. */</a>
<a name="ln401">		LOG(2,(&quot;CRTC2: FP_HVALID_S reg readback: $%08x\n&quot;, DAC2R(FP_HVALID_S)));</a>
<a name="ln402">		LOG(2,(&quot;CRTC2: FP_HVALID_E reg readback: $%08x\n&quot;, DAC2R(FP_HVALID_E)));</a>
<a name="ln403">		LOG(2,(&quot;CRTC2: FP_VVALID_S reg readback: $%08x\n&quot;, DAC2R(FP_VVALID_S)));</a>
<a name="ln404">		LOG(2,(&quot;CRTC2: FP_VVALID_E reg readback: $%08x\n&quot;, DAC2R(FP_VVALID_E)));</a>
<a name="ln405">		LOG(2,(&quot;CRTC2: FP_DEBUG0 reg readback: $%08x\n&quot;, DAC2R(FP_DEBUG0)));</a>
<a name="ln406">		LOG(2,(&quot;CRTC2: FP_DEBUG1 reg readback: $%08x\n&quot;, DAC2R(FP_DEBUG1)));</a>
<a name="ln407">		LOG(2,(&quot;CRTC2: FP_DEBUG2 reg readback: $%08x\n&quot;, DAC2R(FP_DEBUG2)));</a>
<a name="ln408">		LOG(2,(&quot;CRTC2: FP_DEBUG3 reg readback: $%08x\n&quot;, DAC2R(FP_DEBUG3)));</a>
<a name="ln409">		LOG(2,(&quot;CRTC2: FP_TG_CTRL reg readback: $%08x\n&quot;, DAC2R(FP_TG_CTRL)));</a>
<a name="ln410">	}</a>
<a name="ln411"> </a>
<a name="ln412">	return B_OK;</a>
<a name="ln413">}</a>
<a name="ln414"> </a>
<a name="ln415">status_t eng_crtc2_depth(int mode)</a>
<a name="ln416">{</a>
<a name="ln417">	uint8 viddelay = 0;</a>
<a name="ln418">	uint32 genctrl = 0;</a>
<a name="ln419"> </a>
<a name="ln420">	/* set VCLK scaling */</a>
<a name="ln421">	switch(mode)</a>
<a name="ln422">	{</a>
<a name="ln423">	case BPP8:</a>
<a name="ln424">		viddelay = 0x01;</a>
<a name="ln425">		/* genctrl b4 &amp; b5 reset: 'direct mode' */</a>
<a name="ln426">		genctrl = 0x00101100;</a>
<a name="ln427">		break;</a>
<a name="ln428">	case BPP15:</a>
<a name="ln429">		viddelay = 0x02;</a>
<a name="ln430">		/* genctrl b4 &amp; b5 set: 'indirect mode' (via colorpalette) */</a>
<a name="ln431">		genctrl = 0x00100130;</a>
<a name="ln432">		break;</a>
<a name="ln433">	case BPP16:</a>
<a name="ln434">		viddelay = 0x02;</a>
<a name="ln435">		/* genctrl b4 &amp; b5 set: 'indirect mode' (via colorpalette) */</a>
<a name="ln436">		genctrl = 0x00101130;</a>
<a name="ln437">		break;</a>
<a name="ln438">	case BPP24:</a>
<a name="ln439">		viddelay = 0x03;</a>
<a name="ln440">		/* genctrl b4 &amp; b5 set: 'indirect mode' (via colorpalette) */</a>
<a name="ln441">		genctrl = 0x00100130;</a>
<a name="ln442">		break;</a>
<a name="ln443">	case BPP32:</a>
<a name="ln444">		viddelay = 0x03;</a>
<a name="ln445">		/* genctrl b4 &amp; b5 set: 'indirect mode' (via colorpalette) */</a>
<a name="ln446">		genctrl = 0x00101130;</a>
<a name="ln447">		break;</a>
<a name="ln448">	}</a>
<a name="ln449">	/* enable access to secondary head */</a>
<a name="ln450">	set_crtc_owner(1);</a>
<a name="ln451"> </a>
<a name="ln452">	CRTC2W(PIXEL, ((CRTC2R(PIXEL) &amp; 0xfc) | viddelay));</a>
<a name="ln453">	DAC2W(GENCTRL, genctrl);</a>
<a name="ln454"> </a>
<a name="ln455">	return B_OK;</a>
<a name="ln456">}</a>
<a name="ln457"> </a>
<a name="ln458">status_t eng_crtc2_dpms(bool display, bool h, bool v)</a>
<a name="ln459">{</a>
<a name="ln460">	uint8 temp;</a>
<a name="ln461"> </a>
<a name="ln462">	LOG(4,(&quot;CRTC2: setting DPMS: &quot;));</a>
<a name="ln463"> </a>
<a name="ln464">	/* enable access to secondary head */</a>
<a name="ln465">	set_crtc_owner(1);</a>
<a name="ln466"> </a>
<a name="ln467">	/* start synchronous reset: required before turning screen off! */</a>
<a name="ln468">	SEQW(RESET, 0x01);</a>
<a name="ln469"> </a>
<a name="ln470">	/* turn screen off */</a>
<a name="ln471">	temp = SEQR(CLKMODE);</a>
<a name="ln472">	if (display)</a>
<a name="ln473">	{</a>
<a name="ln474">		SEQW(CLKMODE, (temp &amp; ~0x20));</a>
<a name="ln475"> </a>
<a name="ln476">		/* end synchronous reset if display should be enabled */</a>
<a name="ln477">		SEQW(RESET, 0x03);</a>
<a name="ln478"> </a>
<a name="ln479">		//'safe mode' test! feedback needed with this 'setting'!</a>
<a name="ln480">		if (0)//si-&gt;ps.tmds2_active)</a>
<a name="ln481">		{</a>
<a name="ln482">			/* powerup both LVDS (laptop panellink) and TMDS (DVI panellink)</a>
<a name="ln483">			 * internal transmitters... */</a>
<a name="ln484">			/* note:</a>
<a name="ln485">			 * the powerbits in this register are hardwired to the DVI connectors,</a>
<a name="ln486">			 * instead of to the DACs! (confirmed NV34) */</a>
<a name="ln487">			//fixme...</a>
<a name="ln488">			DAC2W(FP_DEBUG0, (DAC2R(FP_DEBUG0) &amp; 0xcfffffff));</a>
<a name="ln489">			/* ... and powerup external TMDS transmitter if it exists */</a>
<a name="ln490">			/* (confirmed OK on NV28 and NV34) */</a>
<a name="ln491">			CRTC2W(0x59, (CRTC2R(0x59) | 0x01));</a>
<a name="ln492">		}</a>
<a name="ln493"> </a>
<a name="ln494">		LOG(4,(&quot;display on, &quot;));</a>
<a name="ln495">	}</a>
<a name="ln496">	else</a>
<a name="ln497">	{</a>
<a name="ln498">		SEQW(CLKMODE, (temp | 0x20));</a>
<a name="ln499"> </a>
<a name="ln500">		//'safe mode' test! feedback needed with this 'setting'!</a>
<a name="ln501">		if (0)//si-&gt;ps.tmds2_active)</a>
<a name="ln502">		{</a>
<a name="ln503">			/* powerdown both LVDS (laptop panellink) and TMDS (DVI panellink)</a>
<a name="ln504">			 * internal transmitters... */</a>
<a name="ln505">			/* note:</a>
<a name="ln506">			 * the powerbits in this register are hardwired to the DVI connectors,</a>
<a name="ln507">			 * instead of to the DACs! (confirmed NV34) */</a>
<a name="ln508">			//fixme...</a>
<a name="ln509">			DAC2W(FP_DEBUG0, (DAC2R(FP_DEBUG0) | 0x30000000));</a>
<a name="ln510">			/* ... and powerdown external TMDS transmitter if it exists */</a>
<a name="ln511">			/* (confirmed OK on NV28 and NV34) */</a>
<a name="ln512">			CRTC2W(0x59, (CRTC2R(0x59) &amp; 0xfe));</a>
<a name="ln513">		}</a>
<a name="ln514"> </a>
<a name="ln515">		LOG(4,(&quot;display off, &quot;));</a>
<a name="ln516">	}</a>
<a name="ln517"> </a>
<a name="ln518">	if (h)</a>
<a name="ln519">	{</a>
<a name="ln520">		CRTC2W(REPAINT1, (CRTC2R(REPAINT1) &amp; 0x7f));</a>
<a name="ln521">		LOG(4,(&quot;hsync enabled, &quot;));</a>
<a name="ln522">	}</a>
<a name="ln523">	else</a>
<a name="ln524">	{</a>
<a name="ln525">		CRTC2W(REPAINT1, (CRTC2R(REPAINT1) | 0x80));</a>
<a name="ln526">		LOG(4,(&quot;hsync disabled, &quot;));</a>
<a name="ln527">	}</a>
<a name="ln528">	if (v)</a>
<a name="ln529">	{</a>
<a name="ln530">		CRTC2W(REPAINT1, (CRTC2R(REPAINT1) &amp; 0xbf));</a>
<a name="ln531">		LOG(4,(&quot;vsync enabled\n&quot;));</a>
<a name="ln532">	}</a>
<a name="ln533">	else</a>
<a name="ln534">	{</a>
<a name="ln535">		CRTC2W(REPAINT1, (CRTC2R(REPAINT1) | 0x40));</a>
<a name="ln536">		LOG(4,(&quot;vsync disabled\n&quot;));</a>
<a name="ln537">	}</a>
<a name="ln538"> </a>
<a name="ln539">	return B_OK;</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542">status_t eng_crtc2_dpms_fetch(bool *display, bool *h, bool *v)</a>
<a name="ln543">{</a>
<a name="ln544">	/* enable access to secondary head */</a>
<a name="ln545">	set_crtc_owner(1);</a>
<a name="ln546"> </a>
<a name="ln547">	*display = !(SEQR(CLKMODE) &amp; 0x20);</a>
<a name="ln548">	*h = !(CRTC2R(REPAINT1) &amp; 0x80);</a>
<a name="ln549">	*v = !(CRTC2R(REPAINT1) &amp; 0x40);</a>
<a name="ln550"> </a>
<a name="ln551">	LOG(4,(&quot;CTRC2: fetched DPMS state: &quot;));</a>
<a name="ln552">	if (*display) LOG(4,(&quot;display on, &quot;));</a>
<a name="ln553">	else LOG(4,(&quot;display off, &quot;));</a>
<a name="ln554">	if (*h) LOG(4,(&quot;hsync enabled, &quot;));</a>
<a name="ln555">	else LOG(4,(&quot;hsync disabled, &quot;));</a>
<a name="ln556">	if (*v) LOG(4,(&quot;vsync enabled\n&quot;));</a>
<a name="ln557">	else LOG(4,(&quot;vsync disabled\n&quot;));</a>
<a name="ln558"> </a>
<a name="ln559">	return B_OK;</a>
<a name="ln560">}</a>
<a name="ln561"> </a>
<a name="ln562">status_t eng_crtc2_set_display_pitch() </a>
<a name="ln563">{</a>
<a name="ln564">	uint32 offset;</a>
<a name="ln565"> </a>
<a name="ln566">	LOG(4,(&quot;CRTC2: setting card pitch (offset between lines)\n&quot;));</a>
<a name="ln567"> </a>
<a name="ln568">	/* figure out offset value hardware needs */</a>
<a name="ln569">	offset = si-&gt;fbc.bytes_per_row / 8;</a>
<a name="ln570"> </a>
<a name="ln571">	LOG(2,(&quot;CRTC2: offset register set to: $%04x\n&quot;, offset));</a>
<a name="ln572"> </a>
<a name="ln573">	/* enable access to secondary head */</a>
<a name="ln574">	set_crtc_owner(1);</a>
<a name="ln575"> </a>
<a name="ln576">	/* program the card */</a>
<a name="ln577">	CRTC2W(PITCHL, (offset &amp; 0x00ff));</a>
<a name="ln578">	CRTC2W(REPAINT0, ((CRTC2R(REPAINT0) &amp; 0x1f) | ((offset &amp; 0x0700) &gt;&gt; 3)));</a>
<a name="ln579"> </a>
<a name="ln580">	return B_OK;</a>
<a name="ln581">}</a>
<a name="ln582"> </a>
<a name="ln583">status_t eng_crtc2_set_display_start(uint32 startadd,uint8 bpp) </a>
<a name="ln584">{</a>
<a name="ln585">	uint32 timeout = 0;</a>
<a name="ln586"> </a>
<a name="ln587">	LOG(4,(&quot;CRTC2: setting card RAM to be displayed bpp %d\n&quot;, bpp));</a>
<a name="ln588"> </a>
<a name="ln589">	LOG(2,(&quot;CRTC2: startadd: $%08x\n&quot;, startadd));</a>
<a name="ln590">	LOG(2,(&quot;CRTC2: frameRAM: $%08x\n&quot;, si-&gt;framebuffer));</a>
<a name="ln591">	LOG(2,(&quot;CRTC2: framebuffer: $%08x\n&quot;, si-&gt;fbc.frame_buffer));</a>
<a name="ln592"> </a>
<a name="ln593">	/* we might have no retraces during setmode! */</a>
<a name="ln594">	/* wait 25mS max. for retrace to occur (refresh &gt; 40Hz) */</a>
<a name="ln595">	while (((ENG_REG32(RG32_RASTER2) &amp; 0x000007ff) &lt; si-&gt;dm.timing.v_display) &amp;&amp;</a>
<a name="ln596">			(timeout &lt; (25000/10)))</a>
<a name="ln597">	{</a>
<a name="ln598">		/* don't snooze much longer or retrace might get missed! */</a>
<a name="ln599">		snooze(10);</a>
<a name="ln600">		timeout++;</a>
<a name="ln601">	}</a>
<a name="ln602"> </a>
<a name="ln603">	/* enable access to secondary head */</a>
<a name="ln604">	set_crtc_owner(1);</a>
<a name="ln605"> </a>
<a name="ln606">	/* upto 4Gb RAM adressing: must be used on NV10 and later! */</a>
<a name="ln607">	/* NOTE:</a>
<a name="ln608">	 * While this register also exists on pre-NV10 cards, it will</a>
<a name="ln609">	 * wrap-around at 16Mb boundaries!! */</a>
<a name="ln610"> </a>
<a name="ln611">	/* 30bit adress in 32bit words */</a>
<a name="ln612">	ENG_REG32(RG32_NV10FB2STADD32) = (startadd &amp; 0xfffffffc);</a>
<a name="ln613"> </a>
<a name="ln614">	/* set byte adress: (b0 - 1) */</a>
<a name="ln615">	ATB2W(HORPIXPAN, ((startadd &amp; 0x00000003) &lt;&lt; 1));</a>
<a name="ln616"> </a>
<a name="ln617">	return B_OK;</a>
<a name="ln618">}</a>
<a name="ln619"> </a>
<a name="ln620">status_t eng_crtc2_cursor_init()</a>
<a name="ln621">{</a>
<a name="ln622">	int i;</a>
<a name="ln623">	uint32 * fb;</a>
<a name="ln624">	/* cursor bitmap will be stored at the start of the framebuffer */</a>
<a name="ln625">	const uint32 curadd = 0;</a>
<a name="ln626"> </a>
<a name="ln627">	/* enable access to secondary head */</a>
<a name="ln628">	set_crtc_owner(1);</a>
<a name="ln629"> </a>
<a name="ln630">	/* set cursor bitmap adress ... */</a>
<a name="ln631">	if (si-&gt;ps.laptop)</a>
<a name="ln632">	{</a>
<a name="ln633">		/* must be used this way on pre-NV10 and on all 'Go' cards! */</a>
<a name="ln634"> </a>
<a name="ln635">		/* cursorbitmap must start on 2Kbyte boundary: */</a>
<a name="ln636">		/* set adress bit11-16, and set 'no doublescan' (registerbit 1 = 0) */</a>
<a name="ln637">		CRTC2W(CURCTL0, ((curadd &amp; 0x0001f800) &gt;&gt; 9));</a>
<a name="ln638">		/* set adress bit17-23, and set graphics mode cursor(?) (registerbit 7 = 1) */</a>
<a name="ln639">		CRTC2W(CURCTL1, (((curadd &amp; 0x00fe0000) &gt;&gt; 17) | 0x80));</a>
<a name="ln640">		/* set adress bit24-31 */</a>
<a name="ln641">		CRTC2W(CURCTL2, ((curadd &amp; 0xff000000) &gt;&gt; 24));</a>
<a name="ln642">	}</a>
<a name="ln643">	else</a>
<a name="ln644">	{</a>
<a name="ln645">		/* upto 4Gb RAM adressing:</a>
<a name="ln646">		 * can be used on NV10 and later (except for 'Go' cards)! */</a>
<a name="ln647">		/* NOTE:</a>
<a name="ln648">		 * This register does not exist on pre-NV10 and 'Go' cards. */</a>
<a name="ln649"> </a>
<a name="ln650">		/* cursorbitmap must still start on 2Kbyte boundary: */</a>
<a name="ln651">		ENG_REG32(RG32_NV10CUR2ADD32) = (curadd &amp; 0xfffff800);</a>
<a name="ln652">	}</a>
<a name="ln653"> </a>
<a name="ln654">	/* set cursor colour: not needed because of direct nature of cursor bitmap. */</a>
<a name="ln655"> </a>
<a name="ln656">	/*clear cursor*/</a>
<a name="ln657">	fb = (uint32 *) si-&gt;framebuffer + curadd;</a>
<a name="ln658">	for (i=0;i&lt;(2048/4);i++)</a>
<a name="ln659">	{</a>
<a name="ln660">		fb[i]=0;</a>
<a name="ln661">	}</a>
<a name="ln662"> </a>
<a name="ln663">	/* select 32x32 pixel, 16bit color cursorbitmap, no doublescan */</a>
<a name="ln664">	ENG_REG32(RG32_2CURCONF) = 0x02000100;</a>
<a name="ln665"> </a>
<a name="ln666">	/* activate hardware cursor */</a>
<a name="ln667">	eng_crtc2_cursor_show();</a>
<a name="ln668"> </a>
<a name="ln669">	return B_OK;</a>
<a name="ln670">}</a>
<a name="ln671"> </a>
<a name="ln672">status_t eng_crtc2_cursor_show()</a>
<a name="ln673">{</a>
<a name="ln674">	LOG(4,(&quot;CRTC2: enabling cursor\n&quot;));</a>
<a name="ln675"> </a>
<a name="ln676">	/* enable access to secondary head */</a>
<a name="ln677">	set_crtc_owner(1);</a>
<a name="ln678"> </a>
<a name="ln679">	/* b0 = 1 enables cursor */</a>
<a name="ln680">	CRTC2W(CURCTL0, (CRTC2R(CURCTL0) | 0x01));</a>
<a name="ln681"> </a>
<a name="ln682">	return B_OK;</a>
<a name="ln683">}</a>
<a name="ln684"> </a>
<a name="ln685">status_t eng_crtc2_cursor_hide()</a>
<a name="ln686">{</a>
<a name="ln687">	LOG(4,(&quot;CRTC2: disabling cursor\n&quot;));</a>
<a name="ln688"> </a>
<a name="ln689">	/* enable access to secondary head */</a>
<a name="ln690">	set_crtc_owner(1);</a>
<a name="ln691"> </a>
<a name="ln692">	/* b0 = 0 disables cursor */</a>
<a name="ln693">	CRTC2W(CURCTL0, (CRTC2R(CURCTL0) &amp; 0xfe));</a>
<a name="ln694"> </a>
<a name="ln695">	return B_OK;</a>
<a name="ln696">}</a>
<a name="ln697"> </a>
<a name="ln698">/*set up cursor shape*/</a>
<a name="ln699">status_t eng_crtc2_cursor_define(uint8* andMask,uint8* xorMask)</a>
<a name="ln700">{</a>
<a name="ln701">	int x, y;</a>
<a name="ln702">	uint8 b;</a>
<a name="ln703">	uint16 *cursor;</a>
<a name="ln704">	uint16 pixel;</a>
<a name="ln705"> </a>
<a name="ln706">	/* get a pointer to the cursor */</a>
<a name="ln707">	cursor = (uint16*) si-&gt;framebuffer;</a>
<a name="ln708"> </a>
<a name="ln709">	/* draw the cursor */</a>
<a name="ln710">	/* (Nvidia cards have a RGB15 direct color cursor bitmap, bit #16 is transparancy) */</a>
<a name="ln711">	for (y = 0; y &lt; 16; y++)</a>
<a name="ln712">	{</a>
<a name="ln713">		b = 0x80;</a>
<a name="ln714">		for (x = 0; x &lt; 8; x++)</a>
<a name="ln715">		{</a>
<a name="ln716">			/* preset transparant */</a>
<a name="ln717">			pixel = 0x0000;</a>
<a name="ln718">			/* set white if requested */</a>
<a name="ln719">			if ((!(*andMask &amp; b)) &amp;&amp; (!(*xorMask &amp; b))) pixel = 0xffff;</a>
<a name="ln720">			/* set black if requested */</a>
<a name="ln721">			if ((!(*andMask &amp; b)) &amp;&amp;   (*xorMask &amp; b))  pixel = 0x8000;</a>
<a name="ln722">			/* set invert if requested */</a>
<a name="ln723">			if (  (*andMask &amp; b)  &amp;&amp;   (*xorMask &amp; b))  pixel = 0x7fff;</a>
<a name="ln724">			/* place the pixel in the bitmap */</a>
<a name="ln725">			cursor[x + (y * 32)] = pixel;</a>
<a name="ln726">			b &gt;&gt;= 1;</a>
<a name="ln727">		}</a>
<a name="ln728">		xorMask++;</a>
<a name="ln729">		andMask++;</a>
<a name="ln730">		b = 0x80;</a>
<a name="ln731">		for (; x &lt; 16; x++)</a>
<a name="ln732">		{</a>
<a name="ln733">			/* preset transparant */</a>
<a name="ln734">			pixel = 0x0000;</a>
<a name="ln735">			/* set white if requested */</a>
<a name="ln736">			if ((!(*andMask &amp; b)) &amp;&amp; (!(*xorMask &amp; b))) pixel = 0xffff;</a>
<a name="ln737">			/* set black if requested */</a>
<a name="ln738">			if ((!(*andMask &amp; b)) &amp;&amp;   (*xorMask &amp; b))  pixel = 0x8000;</a>
<a name="ln739">			/* set invert if requested */</a>
<a name="ln740">			if (  (*andMask &amp; b)  &amp;&amp;   (*xorMask &amp; b))  pixel = 0x7fff;</a>
<a name="ln741">			/* place the pixel in the bitmap */</a>
<a name="ln742">			cursor[x + (y * 32)] = pixel;</a>
<a name="ln743">			b &gt;&gt;= 1;</a>
<a name="ln744">		}</a>
<a name="ln745">		xorMask++;</a>
<a name="ln746">		andMask++;</a>
<a name="ln747">	}</a>
<a name="ln748"> </a>
<a name="ln749">	return B_OK;</a>
<a name="ln750">}</a>
<a name="ln751"> </a>
<a name="ln752">/* position the cursor */</a>
<a name="ln753">status_t eng_crtc2_cursor_position(uint16 x, uint16 y)</a>
<a name="ln754">{</a>
<a name="ln755">	uint16 yhigh;</a>
<a name="ln756"> </a>
<a name="ln757">	/* make sure we are beyond the first line of the cursorbitmap being drawn during</a>
<a name="ln758">	 * updating the position to prevent distortions: no double buffering feature */</a>
<a name="ln759">	/* Note:</a>
<a name="ln760">	 * we need to return as quick as possible or some apps will exhibit lagging.. */</a>
<a name="ln761"> </a>
<a name="ln762">	/* read the old cursor Y position */</a>
<a name="ln763">	yhigh = ((DAC2R(CURPOS) &amp; 0x0fff0000) &gt;&gt; 16); </a>
<a name="ln764">	/* make sure we will wait until we are below both the old and new Y position:</a>
<a name="ln765">	 * visible cursorbitmap drawing needs to be done at least... */</a>
<a name="ln766">	if (y &gt; yhigh) yhigh = y;</a>
<a name="ln767"> </a>
<a name="ln768">	if (yhigh &lt; (si-&gt;dm.timing.v_display - 16))</a>
<a name="ln769">	{</a>
<a name="ln770">		/* we have vertical lines below old and new cursorposition to spare. So we</a>
<a name="ln771">		 * update the cursor postion 'mid-screen', but below that area. */</a>
<a name="ln772">		while (((uint16)(ENG_REG32(RG32_RASTER2) &amp; 0x000007ff)) &lt; (yhigh + 16))</a>
<a name="ln773">		{</a>
<a name="ln774">			snooze(10);</a>
<a name="ln775">		}</a>
<a name="ln776">	}</a>
<a name="ln777">	else</a>
<a name="ln778">	{</a>
<a name="ln779">		/* no room to spare, just wait for retrace (is relatively slow) */</a>
<a name="ln780">		while ((ENG_REG32(RG32_RASTER2) &amp; 0x000007ff) &lt; si-&gt;dm.timing.v_display)</a>
<a name="ln781">		{</a>
<a name="ln782">			/* don't snooze much longer or retrace might get missed! */</a>
<a name="ln783">			snooze(10);</a>
<a name="ln784">		}</a>
<a name="ln785">	}</a>
<a name="ln786"> </a>
<a name="ln787">	/* update cursorposition */</a>
<a name="ln788">	DAC2W(CURPOS, ((x &amp; 0x0fff) | ((y &amp; 0x0fff) &lt;&lt; 16)));</a>
<a name="ln789"> </a>
<a name="ln790">	return B_OK;</a>
<a name="ln791">}</a>

</code></pre>
<div class="balloon" rel="637"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The 'curadd' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="639"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The 'curadd' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="651"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The 'curadd' named constant with the value of 0 is used in the bitwise operation.</p></div>
<div class="balloon" rel="641"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The 'curadd' named constant with the value of 0 is used in the bitwise operation.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
