
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>if_bwi.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * SPDX-License-Identifier: BSD-3-Clause</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2007 The DragonFly Project.  All rights reserved.</a>
<a name="ln5"> * </a>
<a name="ln6"> * This code is derived from software contributed to The DragonFly Project</a>
<a name="ln7"> * by Sepherosa Ziehau &lt;sepherosa@gmail.com&gt;</a>
<a name="ln8"> * </a>
<a name="ln9"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln10"> * modification, are permitted provided that the following conditions</a>
<a name="ln11"> * are met:</a>
<a name="ln12"> * </a>
<a name="ln13"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln14"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln15"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln16"> *    notice, this list of conditions and the following disclaimer in</a>
<a name="ln17"> *    the documentation and/or other materials provided with the</a>
<a name="ln18"> *    distribution.</a>
<a name="ln19"> * 3. Neither the name of The DragonFly Project nor the names of its</a>
<a name="ln20"> *    contributors may be used to endorse or promote products derived</a>
<a name="ln21"> *    from this software without specific, prior written permission.</a>
<a name="ln22"> * </a>
<a name="ln23"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</a>
<a name="ln24"> * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</a>
<a name="ln25"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS</a>
<a name="ln26"> * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE</a>
<a name="ln27"> * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,</a>
<a name="ln28"> * INCIDENTAL, SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING,</a>
<a name="ln29"> * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</a>
<a name="ln30"> * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED</a>
<a name="ln31"> * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</a>
<a name="ln32"> * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT</a>
<a name="ln33"> * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln34"> * SUCH DAMAGE.</a>
<a name="ln35"> * </a>
<a name="ln36"> * $DragonFly: src/sys/dev/netif/bwi/if_bwi.c,v 1.19 2008/02/15 11:15:38 sephe Exp $</a>
<a name="ln37"> */</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln40">__FBSDID(&quot;$FreeBSD: releng/12.0/sys/dev/bwi/if_bwi.c 337570 2018-08-10 13:06:14Z kevans $&quot;);</a>
<a name="ln41"> </a>
<a name="ln42">#include &quot;opt_inet.h&quot;</a>
<a name="ln43">#include &quot;opt_bwi.h&quot;</a>
<a name="ln44">#include &quot;opt_wlan.h&quot;</a>
<a name="ln45"> </a>
<a name="ln46">#include &lt;sys/param.h&gt;</a>
<a name="ln47">#include &lt;sys/endian.h&gt;</a>
<a name="ln48">#include &lt;sys/kernel.h&gt;</a>
<a name="ln49">#include &lt;sys/bus.h&gt;</a>
<a name="ln50">#include &lt;sys/malloc.h&gt;</a>
<a name="ln51">#include &lt;sys/proc.h&gt;</a>
<a name="ln52">#include &lt;sys/rman.h&gt;</a>
<a name="ln53">#include &lt;sys/socket.h&gt;</a>
<a name="ln54">#include &lt;sys/sockio.h&gt;</a>
<a name="ln55">#include &lt;sys/sysctl.h&gt;</a>
<a name="ln56">#include &lt;sys/systm.h&gt;</a>
<a name="ln57">#include &lt;sys/taskqueue.h&gt;</a>
<a name="ln58"> </a>
<a name="ln59">#include &lt;net/if.h&gt;</a>
<a name="ln60">#include &lt;net/if_var.h&gt;</a>
<a name="ln61">#include &lt;net/if_dl.h&gt;</a>
<a name="ln62">#include &lt;net/if_media.h&gt;</a>
<a name="ln63">#include &lt;net/if_types.h&gt;</a>
<a name="ln64">#include &lt;net/if_arp.h&gt;</a>
<a name="ln65">#include &lt;net/ethernet.h&gt;</a>
<a name="ln66">#include &lt;net/if_llc.h&gt;</a>
<a name="ln67"> </a>
<a name="ln68">#include &lt;net80211/ieee80211_var.h&gt;</a>
<a name="ln69">#include &lt;net80211/ieee80211_radiotap.h&gt;</a>
<a name="ln70">#include &lt;net80211/ieee80211_regdomain.h&gt;</a>
<a name="ln71">#include &lt;net80211/ieee80211_phy.h&gt;</a>
<a name="ln72">#include &lt;net80211/ieee80211_ratectl.h&gt;</a>
<a name="ln73"> </a>
<a name="ln74">#include &lt;net/bpf.h&gt;</a>
<a name="ln75"> </a>
<a name="ln76">#ifdef INET</a>
<a name="ln77">#include &lt;netinet/in.h&gt; </a>
<a name="ln78">#include &lt;netinet/if_ether.h&gt;</a>
<a name="ln79">#endif</a>
<a name="ln80"> </a>
<a name="ln81">#include &lt;machine/bus.h&gt;</a>
<a name="ln82"> </a>
<a name="ln83">#include &lt;dev/pci/pcivar.h&gt;</a>
<a name="ln84">#include &lt;dev/pci/pcireg.h&gt;</a>
<a name="ln85"> </a>
<a name="ln86">#include &lt;dev/bwi/bitops.h&gt;</a>
<a name="ln87">#include &lt;dev/bwi/if_bwireg.h&gt;</a>
<a name="ln88">#include &lt;dev/bwi/if_bwivar.h&gt;</a>
<a name="ln89">#include &lt;dev/bwi/bwimac.h&gt;</a>
<a name="ln90">#include &lt;dev/bwi/bwirf.h&gt;</a>
<a name="ln91"> </a>
<a name="ln92">struct bwi_clock_freq {</a>
<a name="ln93">	u_int		clkfreq_min;</a>
<a name="ln94">	u_int		clkfreq_max;</a>
<a name="ln95">};</a>
<a name="ln96"> </a>
<a name="ln97">struct bwi_myaddr_bssid {</a>
<a name="ln98">	uint8_t		myaddr[IEEE80211_ADDR_LEN];</a>
<a name="ln99">	uint8_t		bssid[IEEE80211_ADDR_LEN];</a>
<a name="ln100">} __packed;</a>
<a name="ln101"> </a>
<a name="ln102">static struct ieee80211vap *bwi_vap_create(struct ieee80211com *,</a>
<a name="ln103">		    const char [IFNAMSIZ], int, enum ieee80211_opmode, int,</a>
<a name="ln104">		    const uint8_t [IEEE80211_ADDR_LEN],</a>
<a name="ln105">		    const uint8_t [IEEE80211_ADDR_LEN]);</a>
<a name="ln106">static void	bwi_vap_delete(struct ieee80211vap *);</a>
<a name="ln107">static void	bwi_init(struct bwi_softc *);</a>
<a name="ln108">static void	bwi_parent(struct ieee80211com *);</a>
<a name="ln109">static int	bwi_transmit(struct ieee80211com *, struct mbuf *);</a>
<a name="ln110">static void	bwi_start_locked(struct bwi_softc *);</a>
<a name="ln111">static int	bwi_raw_xmit(struct ieee80211_node *, struct mbuf *,</a>
<a name="ln112">			const struct ieee80211_bpf_params *);</a>
<a name="ln113">static void	bwi_watchdog(void *);</a>
<a name="ln114">static void	bwi_scan_start(struct ieee80211com *);</a>
<a name="ln115">static void	bwi_getradiocaps(struct ieee80211com *, int, int *,</a>
<a name="ln116">		    struct ieee80211_channel[]);</a>
<a name="ln117">static void	bwi_set_channel(struct ieee80211com *);</a>
<a name="ln118">static void	bwi_scan_end(struct ieee80211com *);</a>
<a name="ln119">static int	bwi_newstate(struct ieee80211vap *, enum ieee80211_state, int);</a>
<a name="ln120">static void	bwi_updateslot(struct ieee80211com *);</a>
<a name="ln121">static int	bwi_media_change(struct ifnet *);</a>
<a name="ln122"> </a>
<a name="ln123">static void	bwi_calibrate(void *);</a>
<a name="ln124"> </a>
<a name="ln125">static int	bwi_calc_rssi(struct bwi_softc *, const struct bwi_rxbuf_hdr *);</a>
<a name="ln126">static int	bwi_calc_noise(struct bwi_softc *);</a>
<a name="ln127">static __inline uint8_t bwi_plcp2rate(uint32_t, enum ieee80211_phytype);</a>
<a name="ln128">static void	bwi_rx_radiotap(struct bwi_softc *, struct mbuf *,</a>
<a name="ln129">			struct bwi_rxbuf_hdr *, const void *, int, int, int);</a>
<a name="ln130"> </a>
<a name="ln131">static void	bwi_restart(void *, int);</a>
<a name="ln132">static void	bwi_init_statechg(struct bwi_softc *, int);</a>
<a name="ln133">static void	bwi_stop(struct bwi_softc *, int);</a>
<a name="ln134">static void	bwi_stop_locked(struct bwi_softc *, int);</a>
<a name="ln135">static int	bwi_newbuf(struct bwi_softc *, int, int);</a>
<a name="ln136">static int	bwi_encap(struct bwi_softc *, int, struct mbuf *,</a>
<a name="ln137">			  struct ieee80211_node *);</a>
<a name="ln138">static int	bwi_encap_raw(struct bwi_softc *, int, struct mbuf *,</a>
<a name="ln139">			  struct ieee80211_node *,</a>
<a name="ln140">			  const struct ieee80211_bpf_params *);</a>
<a name="ln141"> </a>
<a name="ln142">static void	bwi_init_rxdesc_ring32(struct bwi_softc *, uint32_t,</a>
<a name="ln143">				       bus_addr_t, int, int);</a>
<a name="ln144">static void	bwi_reset_rx_ring32(struct bwi_softc *, uint32_t);</a>
<a name="ln145"> </a>
<a name="ln146">static int	bwi_init_tx_ring32(struct bwi_softc *, int);</a>
<a name="ln147">static int	bwi_init_rx_ring32(struct bwi_softc *);</a>
<a name="ln148">static int	bwi_init_txstats32(struct bwi_softc *);</a>
<a name="ln149">static void	bwi_free_tx_ring32(struct bwi_softc *, int);</a>
<a name="ln150">static void	bwi_free_rx_ring32(struct bwi_softc *);</a>
<a name="ln151">static void	bwi_free_txstats32(struct bwi_softc *);</a>
<a name="ln152">static void	bwi_setup_rx_desc32(struct bwi_softc *, int, bus_addr_t, int);</a>
<a name="ln153">static void	bwi_setup_tx_desc32(struct bwi_softc *, struct bwi_ring_data *,</a>
<a name="ln154">				    int, bus_addr_t, int);</a>
<a name="ln155">static int	bwi_rxeof32(struct bwi_softc *);</a>
<a name="ln156">static void	bwi_start_tx32(struct bwi_softc *, uint32_t, int);</a>
<a name="ln157">static void	bwi_txeof_status32(struct bwi_softc *);</a>
<a name="ln158"> </a>
<a name="ln159">static int	bwi_init_tx_ring64(struct bwi_softc *, int);</a>
<a name="ln160">static int	bwi_init_rx_ring64(struct bwi_softc *);</a>
<a name="ln161">static int	bwi_init_txstats64(struct bwi_softc *);</a>
<a name="ln162">static void	bwi_free_tx_ring64(struct bwi_softc *, int);</a>
<a name="ln163">static void	bwi_free_rx_ring64(struct bwi_softc *);</a>
<a name="ln164">static void	bwi_free_txstats64(struct bwi_softc *);</a>
<a name="ln165">static void	bwi_setup_rx_desc64(struct bwi_softc *, int, bus_addr_t, int);</a>
<a name="ln166">static void	bwi_setup_tx_desc64(struct bwi_softc *, struct bwi_ring_data *,</a>
<a name="ln167">				    int, bus_addr_t, int);</a>
<a name="ln168">static int	bwi_rxeof64(struct bwi_softc *);</a>
<a name="ln169">static void	bwi_start_tx64(struct bwi_softc *, uint32_t, int);</a>
<a name="ln170">static void	bwi_txeof_status64(struct bwi_softc *);</a>
<a name="ln171"> </a>
<a name="ln172">static int	bwi_rxeof(struct bwi_softc *, int);</a>
<a name="ln173">static void	_bwi_txeof(struct bwi_softc *, uint16_t, int, int);</a>
<a name="ln174">static void	bwi_txeof(struct bwi_softc *);</a>
<a name="ln175">static void	bwi_txeof_status(struct bwi_softc *, int);</a>
<a name="ln176">static void	bwi_enable_intrs(struct bwi_softc *, uint32_t);</a>
<a name="ln177">static void	bwi_disable_intrs(struct bwi_softc *, uint32_t);</a>
<a name="ln178"> </a>
<a name="ln179">static int	bwi_dma_alloc(struct bwi_softc *);</a>
<a name="ln180">static void	bwi_dma_free(struct bwi_softc *);</a>
<a name="ln181">static int	bwi_dma_ring_alloc(struct bwi_softc *, bus_dma_tag_t,</a>
<a name="ln182">				   struct bwi_ring_data *, bus_size_t,</a>
<a name="ln183">				   uint32_t);</a>
<a name="ln184">static int	bwi_dma_mbuf_create(struct bwi_softc *);</a>
<a name="ln185">static void	bwi_dma_mbuf_destroy(struct bwi_softc *, int, int);</a>
<a name="ln186">static int	bwi_dma_txstats_alloc(struct bwi_softc *, uint32_t, bus_size_t);</a>
<a name="ln187">static void	bwi_dma_txstats_free(struct bwi_softc *);</a>
<a name="ln188">static void	bwi_dma_ring_addr(void *, bus_dma_segment_t *, int, int);</a>
<a name="ln189">static void	bwi_dma_buf_addr(void *, bus_dma_segment_t *, int,</a>
<a name="ln190">				 bus_size_t, int);</a>
<a name="ln191"> </a>
<a name="ln192">static void	bwi_power_on(struct bwi_softc *, int);</a>
<a name="ln193">static int	bwi_power_off(struct bwi_softc *, int);</a>
<a name="ln194">static int	bwi_set_clock_mode(struct bwi_softc *, enum bwi_clock_mode);</a>
<a name="ln195">static int	bwi_set_clock_delay(struct bwi_softc *);</a>
<a name="ln196">static void	bwi_get_clock_freq(struct bwi_softc *, struct bwi_clock_freq *);</a>
<a name="ln197">static int	bwi_get_pwron_delay(struct bwi_softc *sc);</a>
<a name="ln198">static void	bwi_set_addr_filter(struct bwi_softc *, uint16_t,</a>
<a name="ln199">				    const uint8_t *);</a>
<a name="ln200">static void	bwi_set_bssid(struct bwi_softc *, const uint8_t *);</a>
<a name="ln201"> </a>
<a name="ln202">static void	bwi_get_card_flags(struct bwi_softc *);</a>
<a name="ln203">static void	bwi_get_eaddr(struct bwi_softc *, uint16_t, uint8_t *);</a>
<a name="ln204"> </a>
<a name="ln205">static int	bwi_bus_attach(struct bwi_softc *);</a>
<a name="ln206">static int	bwi_bbp_attach(struct bwi_softc *);</a>
<a name="ln207">static int	bwi_bbp_power_on(struct bwi_softc *, enum bwi_clock_mode);</a>
<a name="ln208">static void	bwi_bbp_power_off(struct bwi_softc *);</a>
<a name="ln209"> </a>
<a name="ln210">static const char *bwi_regwin_name(const struct bwi_regwin *);</a>
<a name="ln211">static uint32_t	bwi_regwin_disable_bits(struct bwi_softc *);</a>
<a name="ln212">static void	bwi_regwin_info(struct bwi_softc *, uint16_t *, uint8_t *);</a>
<a name="ln213">static int	bwi_regwin_select(struct bwi_softc *, int);</a>
<a name="ln214"> </a>
<a name="ln215">static void	bwi_led_attach(struct bwi_softc *);</a>
<a name="ln216">static void	bwi_led_newstate(struct bwi_softc *, enum ieee80211_state);</a>
<a name="ln217">static void	bwi_led_event(struct bwi_softc *, int);</a>
<a name="ln218">static void	bwi_led_blink_start(struct bwi_softc *, int, int);</a>
<a name="ln219">static void	bwi_led_blink_next(void *);</a>
<a name="ln220">static void	bwi_led_blink_end(void *);</a>
<a name="ln221"> </a>
<a name="ln222">static const struct {</a>
<a name="ln223">	uint16_t	did_min;</a>
<a name="ln224">	uint16_t	did_max;</a>
<a name="ln225">	uint16_t	bbp_id;</a>
<a name="ln226">} bwi_bbpid_map[] = {</a>
<a name="ln227">	{ 0x4301, 0x4301, 0x4301 },</a>
<a name="ln228">	{ 0x4305, 0x4307, 0x4307 },</a>
<a name="ln229">	{ 0x4402, 0x4403, 0x4402 },</a>
<a name="ln230">	{ 0x4610, 0x4615, 0x4610 },</a>
<a name="ln231">	{ 0x4710, 0x4715, 0x4710 },</a>
<a name="ln232">	{ 0x4720, 0x4725, 0x4309 }</a>
<a name="ln233">};</a>
<a name="ln234"> </a>
<a name="ln235">static const struct {</a>
<a name="ln236">	uint16_t	bbp_id;</a>
<a name="ln237">	int		nregwin;</a>
<a name="ln238">} bwi_regwin_count[] = {</a>
<a name="ln239">	{ 0x4301, 5 },</a>
<a name="ln240">	{ 0x4306, 6 },</a>
<a name="ln241">	{ 0x4307, 5 },</a>
<a name="ln242">	{ 0x4310, 8 },</a>
<a name="ln243">	{ 0x4401, 3 },</a>
<a name="ln244">	{ 0x4402, 3 },</a>
<a name="ln245">	{ 0x4610, 9 },</a>
<a name="ln246">	{ 0x4704, 9 },</a>
<a name="ln247">	{ 0x4710, 9 },</a>
<a name="ln248">	{ 0x5365, 7 }</a>
<a name="ln249">};</a>
<a name="ln250"> </a>
<a name="ln251">#define CLKSRC(src) 				\</a>
<a name="ln252">[BWI_CLKSRC_ ## src] = {			\</a>
<a name="ln253">	.freq_min = BWI_CLKSRC_ ##src## _FMIN,	\</a>
<a name="ln254">	.freq_max = BWI_CLKSRC_ ##src## _FMAX	\</a>
<a name="ln255">}</a>
<a name="ln256"> </a>
<a name="ln257">static const struct {</a>
<a name="ln258">	u_int	freq_min;</a>
<a name="ln259">	u_int	freq_max;</a>
<a name="ln260">} bwi_clkfreq[BWI_CLKSRC_MAX] = {</a>
<a name="ln261">	CLKSRC(LP_OSC),</a>
<a name="ln262">	CLKSRC(CS_OSC),</a>
<a name="ln263">	CLKSRC(PCI)</a>
<a name="ln264">};</a>
<a name="ln265"> </a>
<a name="ln266">#undef CLKSRC</a>
<a name="ln267"> </a>
<a name="ln268">#define VENDOR_LED_ACT(vendor)				\</a>
<a name="ln269">{							\</a>
<a name="ln270">	.vid = PCI_VENDOR_##vendor,			\</a>
<a name="ln271">	.led_act = { BWI_VENDOR_LED_ACT_##vendor }	\</a>
<a name="ln272">}</a>
<a name="ln273"> </a>
<a name="ln274">static const struct {</a>
<a name="ln275">#define	PCI_VENDOR_COMPAQ	0x0e11</a>
<a name="ln276">#define	PCI_VENDOR_LINKSYS	0x1737</a>
<a name="ln277">	uint16_t	vid;</a>
<a name="ln278">	uint8_t		led_act[BWI_LED_MAX];</a>
<a name="ln279">} bwi_vendor_led_act[] = {</a>
<a name="ln280">	VENDOR_LED_ACT(COMPAQ),</a>
<a name="ln281">	VENDOR_LED_ACT(LINKSYS)</a>
<a name="ln282">#undef PCI_VENDOR_LINKSYS</a>
<a name="ln283">#undef PCI_VENDOR_COMPAQ</a>
<a name="ln284">};</a>
<a name="ln285"> </a>
<a name="ln286">static const uint8_t bwi_default_led_act[BWI_LED_MAX] =</a>
<a name="ln287">	{ BWI_VENDOR_LED_ACT_DEFAULT };</a>
<a name="ln288"> </a>
<a name="ln289">#undef VENDOR_LED_ACT</a>
<a name="ln290"> </a>
<a name="ln291">static const struct {</a>
<a name="ln292">	int	on_dur;</a>
<a name="ln293">	int	off_dur;</a>
<a name="ln294">} bwi_led_duration[109] = {</a>
<a name="ln295">	[0]	= { 400, 100 },</a>
<a name="ln296">	[2]	= { 150, 75 },</a>
<a name="ln297">	[4]	= { 90, 45 },</a>
<a name="ln298">	[11]	= { 66, 34 },</a>
<a name="ln299">	[12]	= { 53, 26 },</a>
<a name="ln300">	[18]	= { 42, 21 },</a>
<a name="ln301">	[22]	= { 35, 17 },</a>
<a name="ln302">	[24]	= { 32, 16 },</a>
<a name="ln303">	[36]	= { 21, 10 },</a>
<a name="ln304">	[48]	= { 16, 8 },</a>
<a name="ln305">	[72]	= { 11, 5 },</a>
<a name="ln306">	[96]	= { 9, 4 },</a>
<a name="ln307">	[108]	= { 7, 3 }</a>
<a name="ln308">};</a>
<a name="ln309"> </a>
<a name="ln310">static const uint8_t bwi_chan_2ghz[] =</a>
<a name="ln311">	{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 };</a>
<a name="ln312"> </a>
<a name="ln313">#ifdef BWI_DEBUG</a>
<a name="ln314">#ifdef BWI_DEBUG_VERBOSE</a>
<a name="ln315">static uint32_t bwi_debug = BWI_DBG_ATTACH | BWI_DBG_INIT | BWI_DBG_TXPOWER;</a>
<a name="ln316">#else</a>
<a name="ln317">static uint32_t	bwi_debug;</a>
<a name="ln318">#endif</a>
<a name="ln319">TUNABLE_INT(&quot;hw.bwi.debug&quot;, (int *)&amp;bwi_debug);</a>
<a name="ln320">#endif	/* BWI_DEBUG */</a>
<a name="ln321"> </a>
<a name="ln322">static const uint8_t bwi_zero_addr[IEEE80211_ADDR_LEN];</a>
<a name="ln323"> </a>
<a name="ln324">uint16_t</a>
<a name="ln325">bwi_read_sprom(struct bwi_softc *sc, uint16_t ofs)</a>
<a name="ln326">{</a>
<a name="ln327">	return CSR_READ_2(sc, ofs + BWI_SPROM_START);</a>
<a name="ln328">}</a>
<a name="ln329"> </a>
<a name="ln330">static __inline void</a>
<a name="ln331">bwi_setup_desc32(struct bwi_softc *sc, struct bwi_desc32 *desc_array,</a>
<a name="ln332">		 int ndesc, int desc_idx, bus_addr_t paddr, int buf_len,</a>
<a name="ln333">		 int tx)</a>
<a name="ln334">{</a>
<a name="ln335">	struct bwi_desc32 *desc = &amp;desc_array[desc_idx];</a>
<a name="ln336">	uint32_t ctrl, addr, addr_hi, addr_lo;</a>
<a name="ln337"> </a>
<a name="ln338">	addr_lo = __SHIFTOUT(paddr, BWI_DESC32_A_ADDR_MASK);</a>
<a name="ln339">	addr_hi = __SHIFTOUT(paddr, BWI_DESC32_A_FUNC_MASK);</a>
<a name="ln340"> </a>
<a name="ln341">	addr = __SHIFTIN(addr_lo, BWI_DESC32_A_ADDR_MASK) |</a>
<a name="ln342">	       __SHIFTIN(BWI_DESC32_A_FUNC_TXRX, BWI_DESC32_A_FUNC_MASK);</a>
<a name="ln343"> </a>
<a name="ln344">	ctrl = __SHIFTIN(buf_len, BWI_DESC32_C_BUFLEN_MASK) |</a>
<a name="ln345">	       __SHIFTIN(addr_hi, BWI_DESC32_C_ADDRHI_MASK);</a>
<a name="ln346">	if (desc_idx == ndesc - 1)</a>
<a name="ln347">		ctrl |= BWI_DESC32_C_EOR;</a>
<a name="ln348">	if (tx) {</a>
<a name="ln349">		/* XXX */</a>
<a name="ln350">		ctrl |= BWI_DESC32_C_FRAME_START |</a>
<a name="ln351">			BWI_DESC32_C_FRAME_END |</a>
<a name="ln352">			BWI_DESC32_C_INTR;</a>
<a name="ln353">	}</a>
<a name="ln354"> </a>
<a name="ln355">	desc-&gt;addr = htole32(addr);</a>
<a name="ln356">	desc-&gt;ctrl = htole32(ctrl);</a>
<a name="ln357">}</a>
<a name="ln358"> </a>
<a name="ln359">int</a>
<a name="ln360">bwi_attach(struct bwi_softc *sc)</a>
<a name="ln361">{</a>
<a name="ln362">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln363">	device_t dev = sc-&gt;sc_dev;</a>
<a name="ln364">	struct bwi_mac *mac;</a>
<a name="ln365">	struct bwi_phy *phy;</a>
<a name="ln366">	int i, error;</a>
<a name="ln367"> </a>
<a name="ln368">	BWI_LOCK_INIT(sc);</a>
<a name="ln369"> </a>
<a name="ln370">	/*</a>
<a name="ln371">	 * Initialize taskq and various tasks</a>
<a name="ln372">	 */</a>
<a name="ln373">	sc-&gt;sc_tq = taskqueue_create(&quot;bwi_taskq&quot;, M_NOWAIT | M_ZERO,</a>
<a name="ln374">		taskqueue_thread_enqueue, &amp;sc-&gt;sc_tq);</a>
<a name="ln375">	taskqueue_start_threads(&amp;sc-&gt;sc_tq, 1, PI_NET, &quot;%s taskq&quot;,</a>
<a name="ln376">		device_get_nameunit(dev));</a>
<a name="ln377">	TASK_INIT(&amp;sc-&gt;sc_restart_task, 0, bwi_restart, sc);</a>
<a name="ln378">	callout_init_mtx(&amp;sc-&gt;sc_calib_ch, &amp;sc-&gt;sc_mtx, 0);</a>
<a name="ln379">	mbufq_init(&amp;sc-&gt;sc_snd, ifqmaxlen);</a>
<a name="ln380"> </a>
<a name="ln381">	/*</a>
<a name="ln382">	 * Initialize sysctl variables</a>
<a name="ln383">	 */</a>
<a name="ln384">	sc-&gt;sc_fw_version = BWI_FW_VERSION3;</a>
<a name="ln385">	sc-&gt;sc_led_idle = (2350 * hz) / 1000;</a>
<a name="ln386">	sc-&gt;sc_led_ticks = ticks - sc-&gt;sc_led_idle;</a>
<a name="ln387">	sc-&gt;sc_led_blink = 1;</a>
<a name="ln388">	sc-&gt;sc_txpwr_calib = 1;</a>
<a name="ln389">#ifdef BWI_DEBUG</a>
<a name="ln390">	sc-&gt;sc_debug = bwi_debug;</a>
<a name="ln391">#endif</a>
<a name="ln392">	bwi_power_on(sc, 1);</a>
<a name="ln393"> </a>
<a name="ln394">	error = bwi_bbp_attach(sc);</a>
<a name="ln395">	if (error)</a>
<a name="ln396">		goto fail;</a>
<a name="ln397"> </a>
<a name="ln398">	error = bwi_bbp_power_on(sc, BWI_CLOCK_MODE_FAST);</a>
<a name="ln399">	if (error)</a>
<a name="ln400">		goto fail;</a>
<a name="ln401"> </a>
<a name="ln402">	if (BWI_REGWIN_EXIST(&amp;sc-&gt;sc_com_regwin)) {</a>
<a name="ln403">		error = bwi_set_clock_delay(sc);</a>
<a name="ln404">		if (error)</a>
<a name="ln405">			goto fail;</a>
<a name="ln406"> </a>
<a name="ln407">		error = bwi_set_clock_mode(sc, BWI_CLOCK_MODE_FAST);</a>
<a name="ln408">		if (error)</a>
<a name="ln409">			goto fail;</a>
<a name="ln410"> </a>
<a name="ln411">		error = bwi_get_pwron_delay(sc);</a>
<a name="ln412">		if (error)</a>
<a name="ln413">			goto fail;</a>
<a name="ln414">	}</a>
<a name="ln415"> </a>
<a name="ln416">	error = bwi_bus_attach(sc);</a>
<a name="ln417">	if (error)</a>
<a name="ln418">		goto fail;</a>
<a name="ln419"> </a>
<a name="ln420">	bwi_get_card_flags(sc);</a>
<a name="ln421"> </a>
<a name="ln422">	bwi_led_attach(sc);</a>
<a name="ln423"> </a>
<a name="ln424">	for (i = 0; i &lt; sc-&gt;sc_nmac; ++i) {</a>
<a name="ln425">		struct bwi_regwin *old;</a>
<a name="ln426"> </a>
<a name="ln427">		mac = &amp;sc-&gt;sc_mac[i];</a>
<a name="ln428">		error = bwi_regwin_switch(sc, &amp;mac-&gt;mac_regwin, &amp;old);</a>
<a name="ln429">		if (error)</a>
<a name="ln430">			goto fail;</a>
<a name="ln431"> </a>
<a name="ln432">		error = bwi_mac_lateattach(mac);</a>
<a name="ln433">		if (error)</a>
<a name="ln434">			goto fail;</a>
<a name="ln435"> </a>
<a name="ln436">		error = bwi_regwin_switch(sc, old, NULL);</a>
<a name="ln437">		if (error)</a>
<a name="ln438">			goto fail;</a>
<a name="ln439">	}</a>
<a name="ln440"> </a>
<a name="ln441">	/*</a>
<a name="ln442">	 * XXX First MAC is known to exist</a>
<a name="ln443">	 * TODO2</a>
<a name="ln444">	 */</a>
<a name="ln445">	mac = &amp;sc-&gt;sc_mac[0];</a>
<a name="ln446">	phy = &amp;mac-&gt;mac_phy;</a>
<a name="ln447"> </a>
<a name="ln448">	bwi_bbp_power_off(sc);</a>
<a name="ln449"> </a>
<a name="ln450">	error = bwi_dma_alloc(sc);</a>
<a name="ln451">	if (error)</a>
<a name="ln452">		goto fail;</a>
<a name="ln453"> </a>
<a name="ln454">	error = bwi_mac_fw_alloc(mac);</a>
<a name="ln455">	if (error)</a>
<a name="ln456">		goto fail;</a>
<a name="ln457"> </a>
<a name="ln458">	callout_init_mtx(&amp;sc-&gt;sc_watchdog_timer, &amp;sc-&gt;sc_mtx, 0);</a>
<a name="ln459"> </a>
<a name="ln460">	/*</a>
<a name="ln461">	 * Setup ratesets, phytype, channels and get MAC address</a>
<a name="ln462">	 */</a>
<a name="ln463">	if (phy-&gt;phy_mode == IEEE80211_MODE_11B ||</a>
<a name="ln464">	    phy-&gt;phy_mode == IEEE80211_MODE_11G) {</a>
<a name="ln465">		if (phy-&gt;phy_mode == IEEE80211_MODE_11B) {</a>
<a name="ln466">			ic-&gt;ic_phytype = IEEE80211_T_DS;</a>
<a name="ln467">		} else {</a>
<a name="ln468">			ic-&gt;ic_phytype = IEEE80211_T_OFDM;</a>
<a name="ln469">		}</a>
<a name="ln470"> </a>
<a name="ln471">		bwi_get_eaddr(sc, BWI_SPROM_11BG_EADDR, ic-&gt;ic_macaddr);</a>
<a name="ln472">		if (IEEE80211_IS_MULTICAST(ic-&gt;ic_macaddr)) {</a>
<a name="ln473">			bwi_get_eaddr(sc, BWI_SPROM_11A_EADDR, ic-&gt;ic_macaddr);</a>
<a name="ln474">			if (IEEE80211_IS_MULTICAST(ic-&gt;ic_macaddr)) {</a>
<a name="ln475">				device_printf(dev,</a>
<a name="ln476">				    &quot;invalid MAC address: %6D\n&quot;,</a>
<a name="ln477">				    ic-&gt;ic_macaddr, &quot;:&quot;);</a>
<a name="ln478">			}</a>
<a name="ln479">		}</a>
<a name="ln480">	} else if (phy-&gt;phy_mode == IEEE80211_MODE_11A) {</a>
<a name="ln481">		/* TODO:11A */</a>
<a name="ln482">		error = ENXIO;</a>
<a name="ln483">		goto fail;</a>
<a name="ln484">	} else {</a>
<a name="ln485">		panic(&quot;unknown phymode %d\n&quot;, phy-&gt;phy_mode);</a>
<a name="ln486">	}</a>
<a name="ln487"> </a>
<a name="ln488">	/* Get locale */</a>
<a name="ln489">	sc-&gt;sc_locale = __SHIFTOUT(bwi_read_sprom(sc, BWI_SPROM_CARD_INFO),</a>
<a name="ln490">				   BWI_SPROM_CARD_INFO_LOCALE);</a>
<a name="ln491">	DPRINTF(sc, BWI_DBG_ATTACH, &quot;locale: %d\n&quot;, sc-&gt;sc_locale);</a>
<a name="ln492">	/* XXX use locale */</a>
<a name="ln493"> </a>
<a name="ln494">	ic-&gt;ic_softc = sc;</a>
<a name="ln495"> </a>
<a name="ln496">	bwi_getradiocaps(ic, IEEE80211_CHAN_MAX, &amp;ic-&gt;ic_nchans,</a>
<a name="ln497">	    ic-&gt;ic_channels);</a>
<a name="ln498"> </a>
<a name="ln499">	ic-&gt;ic_name = device_get_nameunit(dev);</a>
<a name="ln500">	ic-&gt;ic_caps = IEEE80211_C_STA |</a>
<a name="ln501">		      IEEE80211_C_SHSLOT |</a>
<a name="ln502">		      IEEE80211_C_SHPREAMBLE |</a>
<a name="ln503">		      IEEE80211_C_WPA |</a>
<a name="ln504">		      IEEE80211_C_BGSCAN |</a>
<a name="ln505">		      IEEE80211_C_MONITOR;</a>
<a name="ln506">	ic-&gt;ic_opmode = IEEE80211_M_STA;</a>
<a name="ln507">	ieee80211_ifattach(ic);</a>
<a name="ln508"> </a>
<a name="ln509">	ic-&gt;ic_headroom = sizeof(struct bwi_txbuf_hdr);</a>
<a name="ln510"> </a>
<a name="ln511">	/* override default methods */</a>
<a name="ln512">	ic-&gt;ic_vap_create = bwi_vap_create;</a>
<a name="ln513">	ic-&gt;ic_vap_delete = bwi_vap_delete;</a>
<a name="ln514">	ic-&gt;ic_raw_xmit = bwi_raw_xmit;</a>
<a name="ln515">	ic-&gt;ic_updateslot = bwi_updateslot;</a>
<a name="ln516">	ic-&gt;ic_scan_start = bwi_scan_start;</a>
<a name="ln517">	ic-&gt;ic_scan_end = bwi_scan_end;</a>
<a name="ln518">	ic-&gt;ic_getradiocaps = bwi_getradiocaps;</a>
<a name="ln519">	ic-&gt;ic_set_channel = bwi_set_channel;</a>
<a name="ln520">	ic-&gt;ic_transmit = bwi_transmit;</a>
<a name="ln521">	ic-&gt;ic_parent = bwi_parent;</a>
<a name="ln522"> </a>
<a name="ln523">	sc-&gt;sc_rates = ieee80211_get_ratetable(ic-&gt;ic_curchan);</a>
<a name="ln524"> </a>
<a name="ln525">	ieee80211_radiotap_attach(ic,</a>
<a name="ln526">	    &amp;sc-&gt;sc_tx_th.wt_ihdr, sizeof(sc-&gt;sc_tx_th),</a>
<a name="ln527">		BWI_TX_RADIOTAP_PRESENT,</a>
<a name="ln528">	    &amp;sc-&gt;sc_rx_th.wr_ihdr, sizeof(sc-&gt;sc_rx_th),</a>
<a name="ln529">		BWI_RX_RADIOTAP_PRESENT);</a>
<a name="ln530"> </a>
<a name="ln531">	/*</a>
<a name="ln532">	 * Add sysctl nodes</a>
<a name="ln533">	 */</a>
<a name="ln534">	SYSCTL_ADD_INT(device_get_sysctl_ctx(dev),</a>
<a name="ln535">		        SYSCTL_CHILDREN(device_get_sysctl_tree(dev)), OID_AUTO,</a>
<a name="ln536">		        &quot;fw_version&quot;, CTLFLAG_RD, &amp;sc-&gt;sc_fw_version, 0,</a>
<a name="ln537">		        &quot;Firmware version&quot;);</a>
<a name="ln538">	SYSCTL_ADD_INT(device_get_sysctl_ctx(dev),</a>
<a name="ln539">		        SYSCTL_CHILDREN(device_get_sysctl_tree(dev)), OID_AUTO,</a>
<a name="ln540">		        &quot;led_idle&quot;, CTLFLAG_RW, &amp;sc-&gt;sc_led_idle, 0,</a>
<a name="ln541">		        &quot;# ticks before LED enters idle state&quot;);</a>
<a name="ln542">	SYSCTL_ADD_INT(device_get_sysctl_ctx(dev),</a>
<a name="ln543">		       SYSCTL_CHILDREN(device_get_sysctl_tree(dev)), OID_AUTO,</a>
<a name="ln544">		       &quot;led_blink&quot;, CTLFLAG_RW, &amp;sc-&gt;sc_led_blink, 0,</a>
<a name="ln545">		       &quot;Allow LED to blink&quot;);</a>
<a name="ln546">	SYSCTL_ADD_INT(device_get_sysctl_ctx(dev),</a>
<a name="ln547">		       SYSCTL_CHILDREN(device_get_sysctl_tree(dev)), OID_AUTO,</a>
<a name="ln548">		       &quot;txpwr_calib&quot;, CTLFLAG_RW, &amp;sc-&gt;sc_txpwr_calib, 0,</a>
<a name="ln549">		       &quot;Enable software TX power calibration&quot;);</a>
<a name="ln550">#ifdef BWI_DEBUG</a>
<a name="ln551">	SYSCTL_ADD_UINT(device_get_sysctl_ctx(dev),</a>
<a name="ln552">		        SYSCTL_CHILDREN(device_get_sysctl_tree(dev)), OID_AUTO,</a>
<a name="ln553">		        &quot;debug&quot;, CTLFLAG_RW, &amp;sc-&gt;sc_debug, 0, &quot;Debug flags&quot;);</a>
<a name="ln554">#endif</a>
<a name="ln555">	if (bootverbose)</a>
<a name="ln556">		ieee80211_announce(ic);</a>
<a name="ln557"> </a>
<a name="ln558">	return (0);</a>
<a name="ln559">fail:</a>
<a name="ln560">	BWI_LOCK_DESTROY(sc);</a>
<a name="ln561">	return (error);</a>
<a name="ln562">}</a>
<a name="ln563"> </a>
<a name="ln564">int</a>
<a name="ln565">bwi_detach(struct bwi_softc *sc)</a>
<a name="ln566">{</a>
<a name="ln567">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln568">	int i;</a>
<a name="ln569"> </a>
<a name="ln570">	bwi_stop(sc, 1);</a>
<a name="ln571">	callout_drain(&amp;sc-&gt;sc_led_blink_ch);</a>
<a name="ln572">	callout_drain(&amp;sc-&gt;sc_calib_ch);</a>
<a name="ln573">	callout_drain(&amp;sc-&gt;sc_watchdog_timer);</a>
<a name="ln574">	ieee80211_ifdetach(ic);</a>
<a name="ln575"> </a>
<a name="ln576">	for (i = 0; i &lt; sc-&gt;sc_nmac; ++i)</a>
<a name="ln577">		bwi_mac_detach(&amp;sc-&gt;sc_mac[i]);</a>
<a name="ln578">	bwi_dma_free(sc);</a>
<a name="ln579">	taskqueue_free(sc-&gt;sc_tq);</a>
<a name="ln580">	mbufq_drain(&amp;sc-&gt;sc_snd);</a>
<a name="ln581"> </a>
<a name="ln582">	BWI_LOCK_DESTROY(sc);</a>
<a name="ln583"> </a>
<a name="ln584">	return (0);</a>
<a name="ln585">}</a>
<a name="ln586"> </a>
<a name="ln587">static struct ieee80211vap *</a>
<a name="ln588">bwi_vap_create(struct ieee80211com *ic, const char name[IFNAMSIZ], int unit,</a>
<a name="ln589">    enum ieee80211_opmode opmode, int flags,</a>
<a name="ln590">    const uint8_t bssid[IEEE80211_ADDR_LEN],</a>
<a name="ln591">    const uint8_t mac[IEEE80211_ADDR_LEN])</a>
<a name="ln592">{</a>
<a name="ln593">	struct bwi_vap *bvp;</a>
<a name="ln594">	struct ieee80211vap *vap;</a>
<a name="ln595"> </a>
<a name="ln596">	if (!TAILQ_EMPTY(&amp;ic-&gt;ic_vaps))		/* only one at a time */</a>
<a name="ln597">		return NULL;</a>
<a name="ln598">	bvp = malloc(sizeof(struct bwi_vap), M_80211_VAP, M_WAITOK | M_ZERO);</a>
<a name="ln599">	vap = &amp;bvp-&gt;bv_vap;</a>
<a name="ln600">	/* enable s/w bmiss handling for sta mode */</a>
<a name="ln601">	ieee80211_vap_setup(ic, vap, name, unit, opmode,</a>
<a name="ln602">	    flags | IEEE80211_CLONE_NOBEACONS, bssid);</a>
<a name="ln603"> </a>
<a name="ln604">	/* override default methods */</a>
<a name="ln605">	bvp-&gt;bv_newstate = vap-&gt;iv_newstate;</a>
<a name="ln606">	vap-&gt;iv_newstate = bwi_newstate;</a>
<a name="ln607">#if 0</a>
<a name="ln608">	vap-&gt;iv_update_beacon = bwi_beacon_update;</a>
<a name="ln609">#endif</a>
<a name="ln610">	ieee80211_ratectl_init(vap);</a>
<a name="ln611"> </a>
<a name="ln612">	/* complete setup */</a>
<a name="ln613">	ieee80211_vap_attach(vap, bwi_media_change, ieee80211_media_status,</a>
<a name="ln614">	    mac);</a>
<a name="ln615">	ic-&gt;ic_opmode = opmode;</a>
<a name="ln616">	return vap;</a>
<a name="ln617">}</a>
<a name="ln618"> </a>
<a name="ln619">static void</a>
<a name="ln620">bwi_vap_delete(struct ieee80211vap *vap)</a>
<a name="ln621">{</a>
<a name="ln622">	struct bwi_vap *bvp = BWI_VAP(vap);</a>
<a name="ln623"> </a>
<a name="ln624">	ieee80211_ratectl_deinit(vap);</a>
<a name="ln625">	ieee80211_vap_detach(vap);</a>
<a name="ln626">	free(bvp, M_80211_VAP);</a>
<a name="ln627">}</a>
<a name="ln628"> </a>
<a name="ln629">void</a>
<a name="ln630">bwi_suspend(struct bwi_softc *sc)</a>
<a name="ln631">{</a>
<a name="ln632">	bwi_stop(sc, 1);</a>
<a name="ln633">}</a>
<a name="ln634"> </a>
<a name="ln635">void</a>
<a name="ln636">bwi_resume(struct bwi_softc *sc)</a>
<a name="ln637">{</a>
<a name="ln638"> </a>
<a name="ln639">	if (sc-&gt;sc_ic.ic_nrunning &gt; 0)</a>
<a name="ln640">		bwi_init(sc);</a>
<a name="ln641">}</a>
<a name="ln642"> </a>
<a name="ln643">int</a>
<a name="ln644">bwi_shutdown(struct bwi_softc *sc)</a>
<a name="ln645">{</a>
<a name="ln646">	bwi_stop(sc, 1);</a>
<a name="ln647">	return 0;</a>
<a name="ln648">}</a>
<a name="ln649"> </a>
<a name="ln650">static void</a>
<a name="ln651">bwi_power_on(struct bwi_softc *sc, int with_pll)</a>
<a name="ln652">{</a>
<a name="ln653">	uint32_t gpio_in, gpio_out, gpio_en;</a>
<a name="ln654">	uint16_t status;</a>
<a name="ln655"> </a>
<a name="ln656">	gpio_in = pci_read_config(sc-&gt;sc_dev, BWI_PCIR_GPIO_IN, 4);</a>
<a name="ln657">	if (gpio_in &amp; BWI_PCIM_GPIO_PWR_ON)</a>
<a name="ln658">		goto back;</a>
<a name="ln659"> </a>
<a name="ln660">	gpio_out = pci_read_config(sc-&gt;sc_dev, BWI_PCIR_GPIO_OUT, 4);</a>
<a name="ln661">	gpio_en = pci_read_config(sc-&gt;sc_dev, BWI_PCIR_GPIO_ENABLE, 4);</a>
<a name="ln662"> </a>
<a name="ln663">	gpio_out |= BWI_PCIM_GPIO_PWR_ON;</a>
<a name="ln664">	gpio_en |= BWI_PCIM_GPIO_PWR_ON;</a>
<a name="ln665">	if (with_pll) {</a>
<a name="ln666">		/* Turn off PLL first */</a>
<a name="ln667">		gpio_out |= BWI_PCIM_GPIO_PLL_PWR_OFF;</a>
<a name="ln668">		gpio_en |= BWI_PCIM_GPIO_PLL_PWR_OFF;</a>
<a name="ln669">	}</a>
<a name="ln670"> </a>
<a name="ln671">	pci_write_config(sc-&gt;sc_dev, BWI_PCIR_GPIO_OUT, gpio_out, 4);</a>
<a name="ln672">	pci_write_config(sc-&gt;sc_dev, BWI_PCIR_GPIO_ENABLE, gpio_en, 4);</a>
<a name="ln673">	DELAY(1000);</a>
<a name="ln674"> </a>
<a name="ln675">	if (with_pll) {</a>
<a name="ln676">		/* Turn on PLL */</a>
<a name="ln677">		gpio_out &amp;= ~BWI_PCIM_GPIO_PLL_PWR_OFF;</a>
<a name="ln678">		pci_write_config(sc-&gt;sc_dev, BWI_PCIR_GPIO_OUT, gpio_out, 4);</a>
<a name="ln679">		DELAY(5000);</a>
<a name="ln680">	}</a>
<a name="ln681"> </a>
<a name="ln682">back:</a>
<a name="ln683">	/* Clear &quot;Signaled Target Abort&quot; */</a>
<a name="ln684">	status = pci_read_config(sc-&gt;sc_dev, PCIR_STATUS, 2);</a>
<a name="ln685">	status &amp;= ~PCIM_STATUS_STABORT;</a>
<a name="ln686">	pci_write_config(sc-&gt;sc_dev, PCIR_STATUS, status, 2);</a>
<a name="ln687">}</a>
<a name="ln688"> </a>
<a name="ln689">static int</a>
<a name="ln690">bwi_power_off(struct bwi_softc *sc, int with_pll)</a>
<a name="ln691">{</a>
<a name="ln692">	uint32_t gpio_out, gpio_en;</a>
<a name="ln693"> </a>
<a name="ln694">	pci_read_config(sc-&gt;sc_dev, BWI_PCIR_GPIO_IN, 4); /* dummy read */</a>
<a name="ln695">	gpio_out = pci_read_config(sc-&gt;sc_dev, BWI_PCIR_GPIO_OUT, 4);</a>
<a name="ln696">	gpio_en = pci_read_config(sc-&gt;sc_dev, BWI_PCIR_GPIO_ENABLE, 4);</a>
<a name="ln697"> </a>
<a name="ln698">	gpio_out &amp;= ~BWI_PCIM_GPIO_PWR_ON;</a>
<a name="ln699">	gpio_en |= BWI_PCIM_GPIO_PWR_ON;</a>
<a name="ln700">	if (with_pll) {</a>
<a name="ln701">		gpio_out |= BWI_PCIM_GPIO_PLL_PWR_OFF;</a>
<a name="ln702">		gpio_en |= BWI_PCIM_GPIO_PLL_PWR_OFF;</a>
<a name="ln703">	}</a>
<a name="ln704"> </a>
<a name="ln705">	pci_write_config(sc-&gt;sc_dev, BWI_PCIR_GPIO_OUT, gpio_out, 4);</a>
<a name="ln706">	pci_write_config(sc-&gt;sc_dev, BWI_PCIR_GPIO_ENABLE, gpio_en, 4);</a>
<a name="ln707">	return 0;</a>
<a name="ln708">}</a>
<a name="ln709"> </a>
<a name="ln710">int</a>
<a name="ln711">bwi_regwin_switch(struct bwi_softc *sc, struct bwi_regwin *rw,</a>
<a name="ln712">		  struct bwi_regwin **old_rw)</a>
<a name="ln713">{</a>
<a name="ln714">	int error;</a>
<a name="ln715"> </a>
<a name="ln716">	if (old_rw != NULL)</a>
<a name="ln717">		*old_rw = NULL;</a>
<a name="ln718"> </a>
<a name="ln719">	if (!BWI_REGWIN_EXIST(rw))</a>
<a name="ln720">		return EINVAL;</a>
<a name="ln721"> </a>
<a name="ln722">	if (sc-&gt;sc_cur_regwin != rw) {</a>
<a name="ln723">		error = bwi_regwin_select(sc, rw-&gt;rw_id);</a>
<a name="ln724">		if (error) {</a>
<a name="ln725">			device_printf(sc-&gt;sc_dev, &quot;can't select regwin %d\n&quot;,</a>
<a name="ln726">				  rw-&gt;rw_id);</a>
<a name="ln727">			return error;</a>
<a name="ln728">		}</a>
<a name="ln729">	}</a>
<a name="ln730"> </a>
<a name="ln731">	if (old_rw != NULL)</a>
<a name="ln732">		*old_rw = sc-&gt;sc_cur_regwin;</a>
<a name="ln733">	sc-&gt;sc_cur_regwin = rw;</a>
<a name="ln734">	return 0;</a>
<a name="ln735">}</a>
<a name="ln736"> </a>
<a name="ln737">static int</a>
<a name="ln738">bwi_regwin_select(struct bwi_softc *sc, int id)</a>
<a name="ln739">{</a>
<a name="ln740">	uint32_t win = BWI_PCIM_REGWIN(id);</a>
<a name="ln741">	int i;</a>
<a name="ln742"> </a>
<a name="ln743">#define RETRY_MAX	50</a>
<a name="ln744">	for (i = 0; i &lt; RETRY_MAX; ++i) {</a>
<a name="ln745">		pci_write_config(sc-&gt;sc_dev, BWI_PCIR_SEL_REGWIN, win, 4);</a>
<a name="ln746">		if (pci_read_config(sc-&gt;sc_dev, BWI_PCIR_SEL_REGWIN, 4) == win)</a>
<a name="ln747">			return 0;</a>
<a name="ln748">		DELAY(10);</a>
<a name="ln749">	}</a>
<a name="ln750">#undef RETRY_MAX</a>
<a name="ln751"> </a>
<a name="ln752">	return ENXIO;</a>
<a name="ln753">}</a>
<a name="ln754"> </a>
<a name="ln755">static void</a>
<a name="ln756">bwi_regwin_info(struct bwi_softc *sc, uint16_t *type, uint8_t *rev)</a>
<a name="ln757">{</a>
<a name="ln758">	uint32_t val;</a>
<a name="ln759"> </a>
<a name="ln760">	val = CSR_READ_4(sc, BWI_ID_HI);</a>
<a name="ln761">	*type = BWI_ID_HI_REGWIN_TYPE(val);</a>
<a name="ln762">	*rev = BWI_ID_HI_REGWIN_REV(val);</a>
<a name="ln763"> </a>
<a name="ln764">	DPRINTF(sc, BWI_DBG_ATTACH, &quot;regwin: type 0x%03x, rev %d, &quot;</a>
<a name="ln765">		&quot;vendor 0x%04x\n&quot;, *type, *rev,</a>
<a name="ln766">		__SHIFTOUT(val, BWI_ID_HI_REGWIN_VENDOR_MASK));</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769">static int</a>
<a name="ln770">bwi_bbp_attach(struct bwi_softc *sc)</a>
<a name="ln771">{</a>
<a name="ln772">	uint16_t bbp_id, rw_type;</a>
<a name="ln773">	uint8_t rw_rev;</a>
<a name="ln774">	uint32_t info;</a>
<a name="ln775">	int error, nregwin, i;</a>
<a name="ln776"> </a>
<a name="ln777">	/*</a>
<a name="ln778">	 * Get 0th regwin information</a>
<a name="ln779">	 * NOTE: 0th regwin should exist</a>
<a name="ln780">	 */</a>
<a name="ln781">	error = bwi_regwin_select(sc, 0);</a>
<a name="ln782">	if (error) {</a>
<a name="ln783">		device_printf(sc-&gt;sc_dev, &quot;can't select regwin 0\n&quot;);</a>
<a name="ln784">		return error;</a>
<a name="ln785">	}</a>
<a name="ln786">	bwi_regwin_info(sc, &amp;rw_type, &amp;rw_rev);</a>
<a name="ln787"> </a>
<a name="ln788">	/*</a>
<a name="ln789">	 * Find out BBP id</a>
<a name="ln790">	 */</a>
<a name="ln791">	bbp_id = 0;</a>
<a name="ln792">	info = 0;</a>
<a name="ln793">	if (rw_type == BWI_REGWIN_T_COM) {</a>
<a name="ln794">		info = CSR_READ_4(sc, BWI_INFO);</a>
<a name="ln795">		bbp_id = __SHIFTOUT(info, BWI_INFO_BBPID_MASK);</a>
<a name="ln796"> </a>
<a name="ln797">		BWI_CREATE_REGWIN(&amp;sc-&gt;sc_com_regwin, 0, rw_type, rw_rev);</a>
<a name="ln798"> </a>
<a name="ln799">		sc-&gt;sc_cap = CSR_READ_4(sc, BWI_CAPABILITY);</a>
<a name="ln800">	} else {</a>
<a name="ln801">		for (i = 0; i &lt; nitems(bwi_bbpid_map); ++i) {</a>
<a name="ln802">			if (sc-&gt;sc_pci_did &gt;= bwi_bbpid_map[i].did_min &amp;&amp;</a>
<a name="ln803">			    sc-&gt;sc_pci_did &lt;= bwi_bbpid_map[i].did_max) {</a>
<a name="ln804">				bbp_id = bwi_bbpid_map[i].bbp_id;</a>
<a name="ln805">				break;</a>
<a name="ln806">			}</a>
<a name="ln807">		}</a>
<a name="ln808">		if (bbp_id == 0) {</a>
<a name="ln809">			device_printf(sc-&gt;sc_dev, &quot;no BBP id for device id &quot;</a>
<a name="ln810">				      &quot;0x%04x\n&quot;, sc-&gt;sc_pci_did);</a>
<a name="ln811">			return ENXIO;</a>
<a name="ln812">		}</a>
<a name="ln813"> </a>
<a name="ln814">		info = __SHIFTIN(sc-&gt;sc_pci_revid, BWI_INFO_BBPREV_MASK) |</a>
<a name="ln815">		       __SHIFTIN(0, BWI_INFO_BBPPKG_MASK);</a>
<a name="ln816">	}</a>
<a name="ln817"> </a>
<a name="ln818">	/*</a>
<a name="ln819">	 * Find out number of regwins</a>
<a name="ln820">	 */</a>
<a name="ln821">	nregwin = 0;</a>
<a name="ln822">	if (rw_type == BWI_REGWIN_T_COM &amp;&amp; rw_rev &gt;= 4) {</a>
<a name="ln823">		nregwin = __SHIFTOUT(info, BWI_INFO_NREGWIN_MASK);</a>
<a name="ln824">	} else {</a>
<a name="ln825">		for (i = 0; i &lt; nitems(bwi_regwin_count); ++i) {</a>
<a name="ln826">			if (bwi_regwin_count[i].bbp_id == bbp_id) {</a>
<a name="ln827">				nregwin = bwi_regwin_count[i].nregwin;</a>
<a name="ln828">				break;</a>
<a name="ln829">			}</a>
<a name="ln830">		}</a>
<a name="ln831">		if (nregwin == 0) {</a>
<a name="ln832">			device_printf(sc-&gt;sc_dev, &quot;no number of win for &quot;</a>
<a name="ln833">				      &quot;BBP id 0x%04x\n&quot;, bbp_id);</a>
<a name="ln834">			return ENXIO;</a>
<a name="ln835">		}</a>
<a name="ln836">	}</a>
<a name="ln837"> </a>
<a name="ln838">	/* Record BBP id/rev for later using */</a>
<a name="ln839">	sc-&gt;sc_bbp_id = bbp_id;</a>
<a name="ln840">	sc-&gt;sc_bbp_rev = __SHIFTOUT(info, BWI_INFO_BBPREV_MASK);</a>
<a name="ln841">	sc-&gt;sc_bbp_pkg = __SHIFTOUT(info, BWI_INFO_BBPPKG_MASK);</a>
<a name="ln842">	device_printf(sc-&gt;sc_dev, &quot;BBP: id 0x%04x, rev 0x%x, pkg %d\n&quot;,</a>
<a name="ln843">		      sc-&gt;sc_bbp_id, sc-&gt;sc_bbp_rev, sc-&gt;sc_bbp_pkg);</a>
<a name="ln844"> </a>
<a name="ln845">	DPRINTF(sc, BWI_DBG_ATTACH, &quot;nregwin %d, cap 0x%08x\n&quot;,</a>
<a name="ln846">		nregwin, sc-&gt;sc_cap);</a>
<a name="ln847"> </a>
<a name="ln848">	/*</a>
<a name="ln849">	 * Create rest of the regwins</a>
<a name="ln850">	 */</a>
<a name="ln851"> </a>
<a name="ln852">	/* Don't re-create common regwin, if it is already created */</a>
<a name="ln853">	i = BWI_REGWIN_EXIST(&amp;sc-&gt;sc_com_regwin) ? 1 : 0;</a>
<a name="ln854"> </a>
<a name="ln855">	for (; i &lt; nregwin; ++i) {</a>
<a name="ln856">		/*</a>
<a name="ln857">		 * Get regwin information</a>
<a name="ln858">		 */</a>
<a name="ln859">		error = bwi_regwin_select(sc, i);</a>
<a name="ln860">		if (error) {</a>
<a name="ln861">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln862">				      &quot;can't select regwin %d\n&quot;, i);</a>
<a name="ln863">			return error;</a>
<a name="ln864">		}</a>
<a name="ln865">		bwi_regwin_info(sc, &amp;rw_type, &amp;rw_rev);</a>
<a name="ln866"> </a>
<a name="ln867">		/*</a>
<a name="ln868">		 * Try attach:</a>
<a name="ln869">		 * 1) Bus (PCI/PCIE) regwin</a>
<a name="ln870">		 * 2) MAC regwin</a>
<a name="ln871">		 * Ignore rest types of regwin</a>
<a name="ln872">		 */</a>
<a name="ln873">		if (rw_type == BWI_REGWIN_T_BUSPCI ||</a>
<a name="ln874">		    rw_type == BWI_REGWIN_T_BUSPCIE) {</a>
<a name="ln875">			if (BWI_REGWIN_EXIST(&amp;sc-&gt;sc_bus_regwin)) {</a>
<a name="ln876">				device_printf(sc-&gt;sc_dev,</a>
<a name="ln877">					      &quot;bus regwin already exists\n&quot;);</a>
<a name="ln878">			} else {</a>
<a name="ln879">				BWI_CREATE_REGWIN(&amp;sc-&gt;sc_bus_regwin, i,</a>
<a name="ln880">						  rw_type, rw_rev);</a>
<a name="ln881">			}</a>
<a name="ln882">		} else if (rw_type == BWI_REGWIN_T_MAC) {</a>
<a name="ln883">			/* XXX ignore return value */</a>
<a name="ln884">			bwi_mac_attach(sc, i, rw_rev);</a>
<a name="ln885">		}</a>
<a name="ln886">	}</a>
<a name="ln887"> </a>
<a name="ln888">	/* At least one MAC shold exist */</a>
<a name="ln889">	if (!BWI_REGWIN_EXIST(&amp;sc-&gt;sc_mac[0].mac_regwin)) {</a>
<a name="ln890">		device_printf(sc-&gt;sc_dev, &quot;no MAC was found\n&quot;);</a>
<a name="ln891">		return ENXIO;</a>
<a name="ln892">	}</a>
<a name="ln893">	KASSERT(sc-&gt;sc_nmac &gt; 0, (&quot;no mac's&quot;));</a>
<a name="ln894"> </a>
<a name="ln895">	/* Bus regwin must exist */</a>
<a name="ln896">	if (!BWI_REGWIN_EXIST(&amp;sc-&gt;sc_bus_regwin)) {</a>
<a name="ln897">		device_printf(sc-&gt;sc_dev, &quot;no bus regwin was found\n&quot;);</a>
<a name="ln898">		return ENXIO;</a>
<a name="ln899">	}</a>
<a name="ln900"> </a>
<a name="ln901">	/* Start with first MAC */</a>
<a name="ln902">	error = bwi_regwin_switch(sc, &amp;sc-&gt;sc_mac[0].mac_regwin, NULL);</a>
<a name="ln903">	if (error)</a>
<a name="ln904">		return error;</a>
<a name="ln905"> </a>
<a name="ln906">	return 0;</a>
<a name="ln907">}</a>
<a name="ln908"> </a>
<a name="ln909">int</a>
<a name="ln910">bwi_bus_init(struct bwi_softc *sc, struct bwi_mac *mac)</a>
<a name="ln911">{</a>
<a name="ln912">	struct bwi_regwin *old, *bus;</a>
<a name="ln913">	uint32_t val;</a>
<a name="ln914">	int error;</a>
<a name="ln915"> </a>
<a name="ln916">	bus = &amp;sc-&gt;sc_bus_regwin;</a>
<a name="ln917">	KASSERT(sc-&gt;sc_cur_regwin == &amp;mac-&gt;mac_regwin, (&quot;not cur regwin&quot;));</a>
<a name="ln918"> </a>
<a name="ln919">	/*</a>
<a name="ln920">	 * Tell bus to generate requested interrupts</a>
<a name="ln921">	 */</a>
<a name="ln922">	if (bus-&gt;rw_rev &lt; 6 &amp;&amp; bus-&gt;rw_type == BWI_REGWIN_T_BUSPCI) {</a>
<a name="ln923">		/*</a>
<a name="ln924">		 * NOTE: Read BWI_FLAGS from MAC regwin</a>
<a name="ln925">		 */</a>
<a name="ln926">		val = CSR_READ_4(sc, BWI_FLAGS);</a>
<a name="ln927"> </a>
<a name="ln928">		error = bwi_regwin_switch(sc, bus, &amp;old);</a>
<a name="ln929">		if (error)</a>
<a name="ln930">			return error;</a>
<a name="ln931"> </a>
<a name="ln932">		CSR_SETBITS_4(sc, BWI_INTRVEC, (val &amp; BWI_FLAGS_INTR_MASK));</a>
<a name="ln933">	} else {</a>
<a name="ln934">		uint32_t mac_mask;</a>
<a name="ln935"> </a>
<a name="ln936">		mac_mask = 1 &lt;&lt; mac-&gt;mac_id;</a>
<a name="ln937"> </a>
<a name="ln938">		error = bwi_regwin_switch(sc, bus, &amp;old);</a>
<a name="ln939">		if (error)</a>
<a name="ln940">			return error;</a>
<a name="ln941"> </a>
<a name="ln942">		val = pci_read_config(sc-&gt;sc_dev, BWI_PCIR_INTCTL, 4);</a>
<a name="ln943">		val |= mac_mask &lt;&lt; 8;</a>
<a name="ln944">		pci_write_config(sc-&gt;sc_dev, BWI_PCIR_INTCTL, val, 4);</a>
<a name="ln945">	}</a>
<a name="ln946"> </a>
<a name="ln947">	if (sc-&gt;sc_flags &amp; BWI_F_BUS_INITED)</a>
<a name="ln948">		goto back;</a>
<a name="ln949"> </a>
<a name="ln950">	if (bus-&gt;rw_type == BWI_REGWIN_T_BUSPCI) {</a>
<a name="ln951">		/*</a>
<a name="ln952">		 * Enable prefetch and burst</a>
<a name="ln953">		 */</a>
<a name="ln954">		CSR_SETBITS_4(sc, BWI_BUS_CONFIG,</a>
<a name="ln955">			      BWI_BUS_CONFIG_PREFETCH | BWI_BUS_CONFIG_BURST);</a>
<a name="ln956"> </a>
<a name="ln957">		if (bus-&gt;rw_rev &lt; 5) {</a>
<a name="ln958">			struct bwi_regwin *com = &amp;sc-&gt;sc_com_regwin;</a>
<a name="ln959"> </a>
<a name="ln960">			/*</a>
<a name="ln961">			 * Configure timeouts for bus operation</a>
<a name="ln962">			 */</a>
<a name="ln963"> </a>
<a name="ln964">			/*</a>
<a name="ln965">			 * Set service timeout and request timeout</a>
<a name="ln966">			 */</a>
<a name="ln967">			CSR_SETBITS_4(sc, BWI_CONF_LO,</a>
<a name="ln968">			__SHIFTIN(BWI_CONF_LO_SERVTO, BWI_CONF_LO_SERVTO_MASK) |</a>
<a name="ln969">			__SHIFTIN(BWI_CONF_LO_REQTO, BWI_CONF_LO_REQTO_MASK));</a>
<a name="ln970"> </a>
<a name="ln971">			/*</a>
<a name="ln972">			 * If there is common regwin, we switch to that regwin</a>
<a name="ln973">			 * and switch back to bus regwin once we have done.</a>
<a name="ln974">			 */</a>
<a name="ln975">			if (BWI_REGWIN_EXIST(com)) {</a>
<a name="ln976">				error = bwi_regwin_switch(sc, com, NULL);</a>
<a name="ln977">				if (error)</a>
<a name="ln978">					return error;</a>
<a name="ln979">			}</a>
<a name="ln980"> </a>
<a name="ln981">			/* Let bus know what we have changed */</a>
<a name="ln982">			CSR_WRITE_4(sc, BWI_BUS_ADDR, BWI_BUS_ADDR_MAGIC);</a>
<a name="ln983">			CSR_READ_4(sc, BWI_BUS_ADDR); /* Flush */</a>
<a name="ln984">			CSR_WRITE_4(sc, BWI_BUS_DATA, 0);</a>
<a name="ln985">			CSR_READ_4(sc, BWI_BUS_DATA); /* Flush */</a>
<a name="ln986"> </a>
<a name="ln987">			if (BWI_REGWIN_EXIST(com)) {</a>
<a name="ln988">				error = bwi_regwin_switch(sc, bus, NULL);</a>
<a name="ln989">				if (error)</a>
<a name="ln990">					return error;</a>
<a name="ln991">			}</a>
<a name="ln992">		} else if (bus-&gt;rw_rev &gt;= 11) {</a>
<a name="ln993">			/*</a>
<a name="ln994">			 * Enable memory read multiple</a>
<a name="ln995">			 */</a>
<a name="ln996">			CSR_SETBITS_4(sc, BWI_BUS_CONFIG, BWI_BUS_CONFIG_MRM);</a>
<a name="ln997">		}</a>
<a name="ln998">	} else {</a>
<a name="ln999">		/* TODO:PCIE */</a>
<a name="ln1000">	}</a>
<a name="ln1001"> </a>
<a name="ln1002">	sc-&gt;sc_flags |= BWI_F_BUS_INITED;</a>
<a name="ln1003">back:</a>
<a name="ln1004">	return bwi_regwin_switch(sc, old, NULL);</a>
<a name="ln1005">}</a>
<a name="ln1006"> </a>
<a name="ln1007">static void</a>
<a name="ln1008">bwi_get_card_flags(struct bwi_softc *sc)</a>
<a name="ln1009">{</a>
<a name="ln1010">#define	PCI_VENDOR_APPLE 0x106b</a>
<a name="ln1011">#define	PCI_VENDOR_DELL  0x1028</a>
<a name="ln1012">	sc-&gt;sc_card_flags = bwi_read_sprom(sc, BWI_SPROM_CARD_FLAGS);</a>
<a name="ln1013">	if (sc-&gt;sc_card_flags == 0xffff)</a>
<a name="ln1014">		sc-&gt;sc_card_flags = 0;</a>
<a name="ln1015"> </a>
<a name="ln1016">	if (sc-&gt;sc_pci_subvid == PCI_VENDOR_DELL &amp;&amp;</a>
<a name="ln1017">	    sc-&gt;sc_bbp_id == BWI_BBPID_BCM4301 &amp;&amp;</a>
<a name="ln1018">	    sc-&gt;sc_pci_revid == 0x74)</a>
<a name="ln1019">		sc-&gt;sc_card_flags |= BWI_CARD_F_BT_COEXIST;</a>
<a name="ln1020"> </a>
<a name="ln1021">	if (sc-&gt;sc_pci_subvid == PCI_VENDOR_APPLE &amp;&amp;</a>
<a name="ln1022">	    sc-&gt;sc_pci_subdid == 0x4e &amp;&amp; /* XXX */</a>
<a name="ln1023">	    sc-&gt;sc_pci_revid &gt; 0x40)</a>
<a name="ln1024">		sc-&gt;sc_card_flags |= BWI_CARD_F_PA_GPIO9;</a>
<a name="ln1025"> </a>
<a name="ln1026">	DPRINTF(sc, BWI_DBG_ATTACH, &quot;card flags 0x%04x\n&quot;, sc-&gt;sc_card_flags);</a>
<a name="ln1027">#undef PCI_VENDOR_DELL</a>
<a name="ln1028">#undef PCI_VENDOR_APPLE</a>
<a name="ln1029">}</a>
<a name="ln1030"> </a>
<a name="ln1031">static void</a>
<a name="ln1032">bwi_get_eaddr(struct bwi_softc *sc, uint16_t eaddr_ofs, uint8_t *eaddr)</a>
<a name="ln1033">{</a>
<a name="ln1034">	int i;</a>
<a name="ln1035"> </a>
<a name="ln1036">	for (i = 0; i &lt; 3; ++i) {</a>
<a name="ln1037">		*((uint16_t *)eaddr + i) =</a>
<a name="ln1038">			htobe16(bwi_read_sprom(sc, eaddr_ofs + 2 * i));</a>
<a name="ln1039">	}</a>
<a name="ln1040">}</a>
<a name="ln1041"> </a>
<a name="ln1042">static void</a>
<a name="ln1043">bwi_get_clock_freq(struct bwi_softc *sc, struct bwi_clock_freq *freq)</a>
<a name="ln1044">{</a>
<a name="ln1045">	struct bwi_regwin *com;</a>
<a name="ln1046">	uint32_t val;</a>
<a name="ln1047">	u_int div;</a>
<a name="ln1048">	int src;</a>
<a name="ln1049"> </a>
<a name="ln1050">	bzero(freq, sizeof(*freq));</a>
<a name="ln1051">	com = &amp;sc-&gt;sc_com_regwin;</a>
<a name="ln1052"> </a>
<a name="ln1053">	KASSERT(BWI_REGWIN_EXIST(com), (&quot;regwin does not exist&quot;));</a>
<a name="ln1054">	KASSERT(sc-&gt;sc_cur_regwin == com, (&quot;wrong regwin&quot;));</a>
<a name="ln1055">	KASSERT(sc-&gt;sc_cap &amp; BWI_CAP_CLKMODE, (&quot;wrong clock mode&quot;));</a>
<a name="ln1056"> </a>
<a name="ln1057">	/*</a>
<a name="ln1058">	 * Calculate clock frequency</a>
<a name="ln1059">	 */</a>
<a name="ln1060">	src = -1;</a>
<a name="ln1061">	div = 0;</a>
<a name="ln1062">	if (com-&gt;rw_rev &lt; 6) {</a>
<a name="ln1063">		val = pci_read_config(sc-&gt;sc_dev, BWI_PCIR_GPIO_OUT, 4);</a>
<a name="ln1064">		if (val &amp; BWI_PCIM_GPIO_OUT_CLKSRC) {</a>
<a name="ln1065">			src = BWI_CLKSRC_PCI;</a>
<a name="ln1066">			div = 64;</a>
<a name="ln1067">		} else {</a>
<a name="ln1068">			src = BWI_CLKSRC_CS_OSC;</a>
<a name="ln1069">			div = 32;</a>
<a name="ln1070">		}</a>
<a name="ln1071">	} else if (com-&gt;rw_rev &lt; 10) {</a>
<a name="ln1072">		val = CSR_READ_4(sc, BWI_CLOCK_CTRL);</a>
<a name="ln1073"> </a>
<a name="ln1074">		src = __SHIFTOUT(val, BWI_CLOCK_CTRL_CLKSRC);</a>
<a name="ln1075">		if (src == BWI_CLKSRC_LP_OSC) {</a>
<a name="ln1076">			div = 1;</a>
<a name="ln1077">		} else {</a>
<a name="ln1078">			div = (__SHIFTOUT(val, BWI_CLOCK_CTRL_FDIV) + 1) &lt;&lt; 2;</a>
<a name="ln1079"> </a>
<a name="ln1080">			/* Unknown source */</a>
<a name="ln1081">			if (src &gt;= BWI_CLKSRC_MAX)</a>
<a name="ln1082">				src = BWI_CLKSRC_CS_OSC;</a>
<a name="ln1083">		}</a>
<a name="ln1084">	} else {</a>
<a name="ln1085">		val = CSR_READ_4(sc, BWI_CLOCK_INFO);</a>
<a name="ln1086"> </a>
<a name="ln1087">		src = BWI_CLKSRC_CS_OSC;</a>
<a name="ln1088">		div = (__SHIFTOUT(val, BWI_CLOCK_INFO_FDIV) + 1) &lt;&lt; 2;</a>
<a name="ln1089">	}</a>
<a name="ln1090"> </a>
<a name="ln1091">	KASSERT(src &gt;= 0 &amp;&amp; src &lt; BWI_CLKSRC_MAX, (&quot;bad src %d&quot;, src));</a>
<a name="ln1092">	KASSERT(div != 0, (&quot;div zero&quot;));</a>
<a name="ln1093"> </a>
<a name="ln1094">	DPRINTF(sc, BWI_DBG_ATTACH, &quot;clksrc %s\n&quot;,</a>
<a name="ln1095">		src == BWI_CLKSRC_PCI ? &quot;PCI&quot; :</a>
<a name="ln1096">		(src == BWI_CLKSRC_LP_OSC ? &quot;LP_OSC&quot; : &quot;CS_OSC&quot;));</a>
<a name="ln1097"> </a>
<a name="ln1098">	freq-&gt;clkfreq_min = bwi_clkfreq[src].freq_min / div;</a>
<a name="ln1099">	freq-&gt;clkfreq_max = bwi_clkfreq[src].freq_max / div;</a>
<a name="ln1100"> </a>
<a name="ln1101">	DPRINTF(sc, BWI_DBG_ATTACH, &quot;clkfreq min %u, max %u\n&quot;,</a>
<a name="ln1102">		freq-&gt;clkfreq_min, freq-&gt;clkfreq_max);</a>
<a name="ln1103">}</a>
<a name="ln1104"> </a>
<a name="ln1105">static int</a>
<a name="ln1106">bwi_set_clock_mode(struct bwi_softc *sc, enum bwi_clock_mode clk_mode)</a>
<a name="ln1107">{</a>
<a name="ln1108">	struct bwi_regwin *old, *com;</a>
<a name="ln1109">	uint32_t clk_ctrl, clk_src;</a>
<a name="ln1110">	int error, pwr_off = 0;</a>
<a name="ln1111"> </a>
<a name="ln1112">	com = &amp;sc-&gt;sc_com_regwin;</a>
<a name="ln1113">	if (!BWI_REGWIN_EXIST(com))</a>
<a name="ln1114">		return 0;</a>
<a name="ln1115"> </a>
<a name="ln1116">	if (com-&gt;rw_rev &gt;= 10 || com-&gt;rw_rev &lt; 6)</a>
<a name="ln1117">		return 0;</a>
<a name="ln1118"> </a>
<a name="ln1119">	/*</a>
<a name="ln1120">	 * For common regwin whose rev is [6, 10), the chip</a>
<a name="ln1121">	 * must be capable to change clock mode.</a>
<a name="ln1122">	 */</a>
<a name="ln1123">	if ((sc-&gt;sc_cap &amp; BWI_CAP_CLKMODE) == 0)</a>
<a name="ln1124">		return 0;</a>
<a name="ln1125"> </a>
<a name="ln1126">	error = bwi_regwin_switch(sc, com, &amp;old);</a>
<a name="ln1127">	if (error)</a>
<a name="ln1128">		return error;</a>
<a name="ln1129"> </a>
<a name="ln1130">	if (clk_mode == BWI_CLOCK_MODE_FAST)</a>
<a name="ln1131">		bwi_power_on(sc, 0);	/* Don't turn on PLL */</a>
<a name="ln1132"> </a>
<a name="ln1133">	clk_ctrl = CSR_READ_4(sc, BWI_CLOCK_CTRL);</a>
<a name="ln1134">	clk_src = __SHIFTOUT(clk_ctrl, BWI_CLOCK_CTRL_CLKSRC);</a>
<a name="ln1135"> </a>
<a name="ln1136">	switch (clk_mode) {</a>
<a name="ln1137">	case BWI_CLOCK_MODE_FAST:</a>
<a name="ln1138">		clk_ctrl &amp;= ~BWI_CLOCK_CTRL_SLOW;</a>
<a name="ln1139">		clk_ctrl |= BWI_CLOCK_CTRL_IGNPLL;</a>
<a name="ln1140">		break;</a>
<a name="ln1141">	case BWI_CLOCK_MODE_SLOW:</a>
<a name="ln1142">		clk_ctrl |= BWI_CLOCK_CTRL_SLOW;</a>
<a name="ln1143">		break;</a>
<a name="ln1144">	case BWI_CLOCK_MODE_DYN:</a>
<a name="ln1145">		clk_ctrl &amp;= ~(BWI_CLOCK_CTRL_SLOW |</a>
<a name="ln1146">			      BWI_CLOCK_CTRL_IGNPLL |</a>
<a name="ln1147">			      BWI_CLOCK_CTRL_NODYN);</a>
<a name="ln1148">		if (clk_src != BWI_CLKSRC_CS_OSC) {</a>
<a name="ln1149">			clk_ctrl |= BWI_CLOCK_CTRL_NODYN;</a>
<a name="ln1150">			pwr_off = 1;</a>
<a name="ln1151">		}</a>
<a name="ln1152">		break;</a>
<a name="ln1153">	}</a>
<a name="ln1154">	CSR_WRITE_4(sc, BWI_CLOCK_CTRL, clk_ctrl);</a>
<a name="ln1155"> </a>
<a name="ln1156">	if (pwr_off)</a>
<a name="ln1157">		bwi_power_off(sc, 0);	/* Leave PLL as it is */</a>
<a name="ln1158"> </a>
<a name="ln1159">	return bwi_regwin_switch(sc, old, NULL);</a>
<a name="ln1160">}</a>
<a name="ln1161"> </a>
<a name="ln1162">static int</a>
<a name="ln1163">bwi_set_clock_delay(struct bwi_softc *sc)</a>
<a name="ln1164">{</a>
<a name="ln1165">	struct bwi_regwin *old, *com;</a>
<a name="ln1166">	int error;</a>
<a name="ln1167"> </a>
<a name="ln1168">	com = &amp;sc-&gt;sc_com_regwin;</a>
<a name="ln1169">	if (!BWI_REGWIN_EXIST(com))</a>
<a name="ln1170">		return 0;</a>
<a name="ln1171"> </a>
<a name="ln1172">	error = bwi_regwin_switch(sc, com, &amp;old);</a>
<a name="ln1173">	if (error)</a>
<a name="ln1174">		return error;</a>
<a name="ln1175"> </a>
<a name="ln1176">	if (sc-&gt;sc_bbp_id == BWI_BBPID_BCM4321) {</a>
<a name="ln1177">		if (sc-&gt;sc_bbp_rev == 0)</a>
<a name="ln1178">			CSR_WRITE_4(sc, BWI_CONTROL, BWI_CONTROL_MAGIC0);</a>
<a name="ln1179">		else if (sc-&gt;sc_bbp_rev == 1)</a>
<a name="ln1180">			CSR_WRITE_4(sc, BWI_CONTROL, BWI_CONTROL_MAGIC1);</a>
<a name="ln1181">	}</a>
<a name="ln1182"> </a>
<a name="ln1183">	if (sc-&gt;sc_cap &amp; BWI_CAP_CLKMODE) {</a>
<a name="ln1184">		if (com-&gt;rw_rev &gt;= 10) {</a>
<a name="ln1185">			CSR_FILT_SETBITS_4(sc, BWI_CLOCK_INFO, 0xffff, 0x40000);</a>
<a name="ln1186">		} else {</a>
<a name="ln1187">			struct bwi_clock_freq freq;</a>
<a name="ln1188"> </a>
<a name="ln1189">			bwi_get_clock_freq(sc, &amp;freq);</a>
<a name="ln1190">			CSR_WRITE_4(sc, BWI_PLL_ON_DELAY,</a>
<a name="ln1191">				howmany(freq.clkfreq_max * 150, 1000000));</a>
<a name="ln1192">			CSR_WRITE_4(sc, BWI_FREQ_SEL_DELAY,</a>
<a name="ln1193">				howmany(freq.clkfreq_max * 15, 1000000));</a>
<a name="ln1194">		}</a>
<a name="ln1195">	}</a>
<a name="ln1196"> </a>
<a name="ln1197">	return bwi_regwin_switch(sc, old, NULL);</a>
<a name="ln1198">}</a>
<a name="ln1199"> </a>
<a name="ln1200">static void</a>
<a name="ln1201">bwi_init(struct bwi_softc *sc)</a>
<a name="ln1202">{</a>
<a name="ln1203">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1204"> </a>
<a name="ln1205">	BWI_LOCK(sc);</a>
<a name="ln1206">	bwi_init_statechg(sc, 1);</a>
<a name="ln1207">	BWI_UNLOCK(sc);</a>
<a name="ln1208"> </a>
<a name="ln1209">	if (sc-&gt;sc_flags &amp; BWI_F_RUNNING)</a>
<a name="ln1210">		ieee80211_start_all(ic);		/* start all vap's */</a>
<a name="ln1211">}</a>
<a name="ln1212"> </a>
<a name="ln1213">static void</a>
<a name="ln1214">bwi_init_statechg(struct bwi_softc *sc, int statechg)</a>
<a name="ln1215">{</a>
<a name="ln1216">	struct bwi_mac *mac;</a>
<a name="ln1217">	int error;</a>
<a name="ln1218"> </a>
<a name="ln1219">	BWI_ASSERT_LOCKED(sc);</a>
<a name="ln1220"> </a>
<a name="ln1221">	bwi_stop_locked(sc, statechg);</a>
<a name="ln1222"> </a>
<a name="ln1223">	bwi_bbp_power_on(sc, BWI_CLOCK_MODE_FAST);</a>
<a name="ln1224"> </a>
<a name="ln1225">	/* TODO: 2 MAC */</a>
<a name="ln1226"> </a>
<a name="ln1227">	mac = &amp;sc-&gt;sc_mac[0];</a>
<a name="ln1228">	error = bwi_regwin_switch(sc, &amp;mac-&gt;mac_regwin, NULL);</a>
<a name="ln1229">	if (error) {</a>
<a name="ln1230">		device_printf(sc-&gt;sc_dev, &quot;%s: error %d on regwin switch\n&quot;,</a>
<a name="ln1231">		    __func__, error);</a>
<a name="ln1232">		goto bad;</a>
<a name="ln1233">	}</a>
<a name="ln1234">	error = bwi_mac_init(mac);</a>
<a name="ln1235">	if (error) {</a>
<a name="ln1236">		device_printf(sc-&gt;sc_dev, &quot;%s: error %d on MAC init\n&quot;,</a>
<a name="ln1237">		    __func__, error);</a>
<a name="ln1238">		goto bad;</a>
<a name="ln1239">	}</a>
<a name="ln1240"> </a>
<a name="ln1241">	bwi_bbp_power_on(sc, BWI_CLOCK_MODE_DYN);</a>
<a name="ln1242"> </a>
<a name="ln1243">	bwi_set_bssid(sc, bwi_zero_addr);	/* Clear BSSID */</a>
<a name="ln1244">	bwi_set_addr_filter(sc, BWI_ADDR_FILTER_MYADDR, sc-&gt;sc_ic.ic_macaddr);</a>
<a name="ln1245"> </a>
<a name="ln1246">	bwi_mac_reset_hwkeys(mac);</a>
<a name="ln1247"> </a>
<a name="ln1248">	if ((mac-&gt;mac_flags &amp; BWI_MAC_F_HAS_TXSTATS) == 0) {</a>
<a name="ln1249">		int i;</a>
<a name="ln1250"> </a>
<a name="ln1251">#define NRETRY	1000</a>
<a name="ln1252">		/*</a>
<a name="ln1253">		 * Drain any possible pending TX status</a>
<a name="ln1254">		 */</a>
<a name="ln1255">		for (i = 0; i &lt; NRETRY; ++i) {</a>
<a name="ln1256">			if ((CSR_READ_4(sc, BWI_TXSTATUS0) &amp;</a>
<a name="ln1257">			     BWI_TXSTATUS0_VALID) == 0)</a>
<a name="ln1258">				break;</a>
<a name="ln1259">			CSR_READ_4(sc, BWI_TXSTATUS1);</a>
<a name="ln1260">		}</a>
<a name="ln1261">		if (i == NRETRY)</a>
<a name="ln1262">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1263">			    &quot;%s: can't drain TX status\n&quot;, __func__);</a>
<a name="ln1264">#undef NRETRY</a>
<a name="ln1265">	}</a>
<a name="ln1266"> </a>
<a name="ln1267">	if (mac-&gt;mac_phy.phy_mode == IEEE80211_MODE_11G)</a>
<a name="ln1268">		bwi_mac_updateslot(mac, 1);</a>
<a name="ln1269"> </a>
<a name="ln1270">	/* Start MAC */</a>
<a name="ln1271">	error = bwi_mac_start(mac);</a>
<a name="ln1272">	if (error) {</a>
<a name="ln1273">		device_printf(sc-&gt;sc_dev, &quot;%s: error %d starting MAC\n&quot;,</a>
<a name="ln1274">		    __func__, error);</a>
<a name="ln1275">		goto bad;</a>
<a name="ln1276">	}</a>
<a name="ln1277"> </a>
<a name="ln1278">	/* Clear stop flag before enabling interrupt */</a>
<a name="ln1279">	sc-&gt;sc_flags &amp;= ~BWI_F_STOP;</a>
<a name="ln1280">	sc-&gt;sc_flags |= BWI_F_RUNNING;</a>
<a name="ln1281">	callout_reset(&amp;sc-&gt;sc_watchdog_timer, hz, bwi_watchdog, sc);</a>
<a name="ln1282"> </a>
<a name="ln1283">	/* Enable intrs */</a>
<a name="ln1284">	bwi_enable_intrs(sc, BWI_INIT_INTRS);</a>
<a name="ln1285">	return;</a>
<a name="ln1286">bad:</a>
<a name="ln1287">	bwi_stop_locked(sc, 1);</a>
<a name="ln1288">}</a>
<a name="ln1289"> </a>
<a name="ln1290">static void</a>
<a name="ln1291">bwi_parent(struct ieee80211com *ic)</a>
<a name="ln1292">{</a>
<a name="ln1293">	struct bwi_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1294">	int startall = 0;</a>
<a name="ln1295"> </a>
<a name="ln1296">	BWI_LOCK(sc);</a>
<a name="ln1297">	if (ic-&gt;ic_nrunning &gt; 0) {</a>
<a name="ln1298">		struct bwi_mac *mac;</a>
<a name="ln1299">		int promisc = -1;</a>
<a name="ln1300"> </a>
<a name="ln1301">		KASSERT(sc-&gt;sc_cur_regwin-&gt;rw_type == BWI_REGWIN_T_MAC,</a>
<a name="ln1302">		    (&quot;current regwin type %d&quot;,</a>
<a name="ln1303">		    sc-&gt;sc_cur_regwin-&gt;rw_type));</a>
<a name="ln1304">		mac = (struct bwi_mac *)sc-&gt;sc_cur_regwin;</a>
<a name="ln1305"> </a>
<a name="ln1306">		if (ic-&gt;ic_promisc &gt; 0 &amp;&amp; (sc-&gt;sc_flags &amp; BWI_F_PROMISC) == 0) {</a>
<a name="ln1307">			promisc = 1;</a>
<a name="ln1308">			sc-&gt;sc_flags |= BWI_F_PROMISC;</a>
<a name="ln1309">		} else if (ic-&gt;ic_promisc == 0 &amp;&amp;</a>
<a name="ln1310">		    (sc-&gt;sc_flags &amp; BWI_F_PROMISC) != 0) {</a>
<a name="ln1311">			promisc = 0;</a>
<a name="ln1312">			sc-&gt;sc_flags &amp;= ~BWI_F_PROMISC;</a>
<a name="ln1313">		}</a>
<a name="ln1314"> </a>
<a name="ln1315">		if (promisc &gt;= 0)</a>
<a name="ln1316">			bwi_mac_set_promisc(mac, promisc);</a>
<a name="ln1317">	}</a>
<a name="ln1318">	if (ic-&gt;ic_nrunning &gt; 0) {</a>
<a name="ln1319">		if ((sc-&gt;sc_flags &amp; BWI_F_RUNNING) == 0) {</a>
<a name="ln1320">			bwi_init_statechg(sc, 1);</a>
<a name="ln1321">			startall = 1;</a>
<a name="ln1322">		}</a>
<a name="ln1323">	} else if (sc-&gt;sc_flags &amp; BWI_F_RUNNING)</a>
<a name="ln1324">		bwi_stop_locked(sc, 1);</a>
<a name="ln1325">	BWI_UNLOCK(sc);</a>
<a name="ln1326">	if (startall)</a>
<a name="ln1327">		ieee80211_start_all(ic);</a>
<a name="ln1328">}</a>
<a name="ln1329"> </a>
<a name="ln1330">static int</a>
<a name="ln1331">bwi_transmit(struct ieee80211com *ic, struct mbuf *m)</a>
<a name="ln1332">{</a>
<a name="ln1333">	struct bwi_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1334">	int error;</a>
<a name="ln1335"> </a>
<a name="ln1336">	BWI_LOCK(sc);</a>
<a name="ln1337">	if ((sc-&gt;sc_flags &amp; BWI_F_RUNNING) == 0) {</a>
<a name="ln1338">		BWI_UNLOCK(sc);</a>
<a name="ln1339">		return (ENXIO);</a>
<a name="ln1340">	}</a>
<a name="ln1341">	error = mbufq_enqueue(&amp;sc-&gt;sc_snd, m);</a>
<a name="ln1342">	if (error) {</a>
<a name="ln1343">		BWI_UNLOCK(sc);</a>
<a name="ln1344">		return (error);</a>
<a name="ln1345">	}</a>
<a name="ln1346">	bwi_start_locked(sc);</a>
<a name="ln1347">	BWI_UNLOCK(sc);</a>
<a name="ln1348">	return (0);</a>
<a name="ln1349">}</a>
<a name="ln1350"> </a>
<a name="ln1351">static void</a>
<a name="ln1352">bwi_start_locked(struct bwi_softc *sc)</a>
<a name="ln1353">{</a>
<a name="ln1354">	struct bwi_txbuf_data *tbd = &amp;sc-&gt;sc_tx_bdata[BWI_TX_DATA_RING];</a>
<a name="ln1355">	struct ieee80211_frame *wh;</a>
<a name="ln1356">	struct ieee80211_node *ni;</a>
<a name="ln1357">	struct mbuf *m;</a>
<a name="ln1358">	int trans, idx;</a>
<a name="ln1359"> </a>
<a name="ln1360">	BWI_ASSERT_LOCKED(sc);</a>
<a name="ln1361"> </a>
<a name="ln1362">	trans = 0;</a>
<a name="ln1363">	idx = tbd-&gt;tbd_idx;</a>
<a name="ln1364"> </a>
<a name="ln1365">	while (tbd-&gt;tbd_buf[idx].tb_mbuf == NULL &amp;&amp;</a>
<a name="ln1366">	    tbd-&gt;tbd_used + BWI_TX_NSPRDESC &lt; BWI_TX_NDESC &amp;&amp;</a>
<a name="ln1367">	    (m = mbufq_dequeue(&amp;sc-&gt;sc_snd)) != NULL) {</a>
<a name="ln1368">		ni = (struct ieee80211_node *) m-&gt;m_pkthdr.rcvif;</a>
<a name="ln1369">		wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln1370">		if ((wh-&gt;i_fc[1] &amp; IEEE80211_FC1_PROTECTED) != 0 &amp;&amp;</a>
<a name="ln1371">		    ieee80211_crypto_encap(ni, m) == NULL) {</a>
<a name="ln1372">			if_inc_counter(ni-&gt;ni_vap-&gt;iv_ifp,</a>
<a name="ln1373">			    IFCOUNTER_OERRORS, 1);</a>
<a name="ln1374">			ieee80211_free_node(ni);</a>
<a name="ln1375">			m_freem(m);</a>
<a name="ln1376">			continue;</a>
<a name="ln1377">		}</a>
<a name="ln1378">		if (bwi_encap(sc, idx, m, ni) != 0) {</a>
<a name="ln1379">			/* 'm' is freed in bwi_encap() if we reach here */</a>
<a name="ln1380">			if (ni != NULL) {</a>
<a name="ln1381">				if_inc_counter(ni-&gt;ni_vap-&gt;iv_ifp,</a>
<a name="ln1382">				    IFCOUNTER_OERRORS, 1);</a>
<a name="ln1383">				ieee80211_free_node(ni);</a>
<a name="ln1384">			} else</a>
<a name="ln1385">				counter_u64_add(sc-&gt;sc_ic.ic_oerrors, 1);</a>
<a name="ln1386">			continue;</a>
<a name="ln1387">		}</a>
<a name="ln1388">		trans = 1;</a>
<a name="ln1389">		tbd-&gt;tbd_used++;</a>
<a name="ln1390">		idx = (idx + 1) % BWI_TX_NDESC;</a>
<a name="ln1391">	}</a>
<a name="ln1392"> </a>
<a name="ln1393">	tbd-&gt;tbd_idx = idx;</a>
<a name="ln1394">	if (trans)</a>
<a name="ln1395">		sc-&gt;sc_tx_timer = 5;</a>
<a name="ln1396">}</a>
<a name="ln1397"> </a>
<a name="ln1398">static int</a>
<a name="ln1399">bwi_raw_xmit(struct ieee80211_node *ni, struct mbuf *m,</a>
<a name="ln1400">	const struct ieee80211_bpf_params *params)</a>
<a name="ln1401">{</a>
<a name="ln1402">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln1403">	struct bwi_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1404">	/* XXX wme? */</a>
<a name="ln1405">	struct bwi_txbuf_data *tbd = &amp;sc-&gt;sc_tx_bdata[BWI_TX_DATA_RING];</a>
<a name="ln1406">	int idx, error;</a>
<a name="ln1407"> </a>
<a name="ln1408">	if ((sc-&gt;sc_flags &amp; BWI_F_RUNNING) == 0) {</a>
<a name="ln1409">		m_freem(m);</a>
<a name="ln1410">		return ENETDOWN;</a>
<a name="ln1411">	}</a>
<a name="ln1412"> </a>
<a name="ln1413">	BWI_LOCK(sc);</a>
<a name="ln1414">	idx = tbd-&gt;tbd_idx;</a>
<a name="ln1415">	KASSERT(tbd-&gt;tbd_buf[idx].tb_mbuf == NULL, (&quot;slot %d not empty&quot;, idx));</a>
<a name="ln1416">	if (params == NULL) {</a>
<a name="ln1417">		/*</a>
<a name="ln1418">		 * Legacy path; interpret frame contents to decide</a>
<a name="ln1419">		 * precisely how to send the frame.</a>
<a name="ln1420">		 */</a>
<a name="ln1421">		error = bwi_encap(sc, idx, m, ni);</a>
<a name="ln1422">	} else {</a>
<a name="ln1423">		/*</a>
<a name="ln1424">		 * Caller supplied explicit parameters to use in</a>
<a name="ln1425">		 * sending the frame.</a>
<a name="ln1426">		 */</a>
<a name="ln1427">		error = bwi_encap_raw(sc, idx, m, ni, params);</a>
<a name="ln1428">	}</a>
<a name="ln1429">	if (error == 0) {</a>
<a name="ln1430">		tbd-&gt;tbd_used++;</a>
<a name="ln1431">		tbd-&gt;tbd_idx = (idx + 1) % BWI_TX_NDESC;</a>
<a name="ln1432">		sc-&gt;sc_tx_timer = 5;</a>
<a name="ln1433">	}</a>
<a name="ln1434">	BWI_UNLOCK(sc);</a>
<a name="ln1435">	return error;</a>
<a name="ln1436">}</a>
<a name="ln1437"> </a>
<a name="ln1438">static void</a>
<a name="ln1439">bwi_watchdog(void *arg)</a>
<a name="ln1440">{</a>
<a name="ln1441">	struct bwi_softc *sc;</a>
<a name="ln1442"> </a>
<a name="ln1443">	sc = arg;</a>
<a name="ln1444">	BWI_ASSERT_LOCKED(sc);</a>
<a name="ln1445">	if (sc-&gt;sc_tx_timer != 0 &amp;&amp; --sc-&gt;sc_tx_timer == 0) {</a>
<a name="ln1446">		device_printf(sc-&gt;sc_dev, &quot;watchdog timeout\n&quot;);</a>
<a name="ln1447">		counter_u64_add(sc-&gt;sc_ic.ic_oerrors, 1);</a>
<a name="ln1448">		taskqueue_enqueue(sc-&gt;sc_tq, &amp;sc-&gt;sc_restart_task);</a>
<a name="ln1449">	}</a>
<a name="ln1450">	callout_reset(&amp;sc-&gt;sc_watchdog_timer, hz, bwi_watchdog, sc);</a>
<a name="ln1451">}</a>
<a name="ln1452"> </a>
<a name="ln1453">static void</a>
<a name="ln1454">bwi_stop(struct bwi_softc *sc, int statechg)</a>
<a name="ln1455">{</a>
<a name="ln1456">	BWI_LOCK(sc);</a>
<a name="ln1457">	bwi_stop_locked(sc, statechg);</a>
<a name="ln1458">	BWI_UNLOCK(sc);</a>
<a name="ln1459">}</a>
<a name="ln1460"> </a>
<a name="ln1461">static void</a>
<a name="ln1462">bwi_stop_locked(struct bwi_softc *sc, int statechg)</a>
<a name="ln1463">{</a>
<a name="ln1464">	struct bwi_mac *mac;</a>
<a name="ln1465">	int i, error, pwr_off = 0;</a>
<a name="ln1466"> </a>
<a name="ln1467">	BWI_ASSERT_LOCKED(sc);</a>
<a name="ln1468"> </a>
<a name="ln1469">	callout_stop(&amp;sc-&gt;sc_calib_ch);</a>
<a name="ln1470">	callout_stop(&amp;sc-&gt;sc_led_blink_ch);</a>
<a name="ln1471">	sc-&gt;sc_led_blinking = 0;</a>
<a name="ln1472">	sc-&gt;sc_flags |= BWI_F_STOP;</a>
<a name="ln1473"> </a>
<a name="ln1474">	if (sc-&gt;sc_flags &amp; BWI_F_RUNNING) {</a>
<a name="ln1475">		KASSERT(sc-&gt;sc_cur_regwin-&gt;rw_type == BWI_REGWIN_T_MAC,</a>
<a name="ln1476">		    (&quot;current regwin type %d&quot;, sc-&gt;sc_cur_regwin-&gt;rw_type));</a>
<a name="ln1477">		mac = (struct bwi_mac *)sc-&gt;sc_cur_regwin;</a>
<a name="ln1478"> </a>
<a name="ln1479">		bwi_disable_intrs(sc, BWI_ALL_INTRS);</a>
<a name="ln1480">		CSR_READ_4(sc, BWI_MAC_INTR_MASK);</a>
<a name="ln1481">		bwi_mac_stop(mac);</a>
<a name="ln1482">	}</a>
<a name="ln1483"> </a>
<a name="ln1484">	for (i = 0; i &lt; sc-&gt;sc_nmac; ++i) {</a>
<a name="ln1485">		struct bwi_regwin *old_rw;</a>
<a name="ln1486"> </a>
<a name="ln1487">		mac = &amp;sc-&gt;sc_mac[i];</a>
<a name="ln1488">		if ((mac-&gt;mac_flags &amp; BWI_MAC_F_INITED) == 0)</a>
<a name="ln1489">			continue;</a>
<a name="ln1490"> </a>
<a name="ln1491">		error = bwi_regwin_switch(sc, &amp;mac-&gt;mac_regwin, &amp;old_rw);</a>
<a name="ln1492">		if (error)</a>
<a name="ln1493">			continue;</a>
<a name="ln1494"> </a>
<a name="ln1495">		bwi_mac_shutdown(mac);</a>
<a name="ln1496">		pwr_off = 1;</a>
<a name="ln1497"> </a>
<a name="ln1498">		bwi_regwin_switch(sc, old_rw, NULL);</a>
<a name="ln1499">	}</a>
<a name="ln1500"> </a>
<a name="ln1501">	if (pwr_off)</a>
<a name="ln1502">		bwi_bbp_power_off(sc);</a>
<a name="ln1503"> </a>
<a name="ln1504">	sc-&gt;sc_tx_timer = 0;</a>
<a name="ln1505">	callout_stop(&amp;sc-&gt;sc_watchdog_timer);</a>
<a name="ln1506">	sc-&gt;sc_flags &amp;= ~BWI_F_RUNNING;</a>
<a name="ln1507">}</a>
<a name="ln1508"> </a>
<a name="ln1509">void</a>
<a name="ln1510">bwi_intr(void *xsc)</a>
<a name="ln1511">{</a>
<a name="ln1512">	struct bwi_softc *sc = xsc;</a>
<a name="ln1513">	struct bwi_mac *mac;</a>
<a name="ln1514">	uint32_t intr_status;</a>
<a name="ln1515">	uint32_t txrx_intr_status[BWI_TXRX_NRING];</a>
<a name="ln1516">	int i, txrx_error, tx = 0, rx_data = -1;</a>
<a name="ln1517"> </a>
<a name="ln1518">	BWI_LOCK(sc);</a>
<a name="ln1519"> </a>
<a name="ln1520">#ifndef __HAIKU__</a>
<a name="ln1521">	if ((sc-&gt;sc_flags &amp; BWI_F_RUNNING) == 0 ||</a>
<a name="ln1522">	    (sc-&gt;sc_flags &amp; BWI_F_STOP)) {</a>
<a name="ln1523">		BWI_UNLOCK(sc);</a>
<a name="ln1524">		return;</a>
<a name="ln1525">	}</a>
<a name="ln1526">	/*</a>
<a name="ln1527">	 * Get interrupt status</a>
<a name="ln1528">	 */</a>
<a name="ln1529">	intr_status = CSR_READ_4(sc, BWI_MAC_INTR_STATUS);</a>
<a name="ln1530">	if (intr_status == 0xffffffff) {	/* Not for us */</a>
<a name="ln1531">		BWI_UNLOCK(sc);</a>
<a name="ln1532">		return;</a>
<a name="ln1533">	}</a>
<a name="ln1534"> </a>
<a name="ln1535">	DPRINTF(sc, BWI_DBG_INTR, &quot;intr status 0x%08x\n&quot;, intr_status);</a>
<a name="ln1536"> </a>
<a name="ln1537">	intr_status &amp;= CSR_READ_4(sc, BWI_MAC_INTR_MASK);</a>
<a name="ln1538">	if (intr_status == 0) {		/* Nothing is interesting */</a>
<a name="ln1539">		BWI_UNLOCK(sc);</a>
<a name="ln1540">		return;</a>
<a name="ln1541">	}</a>
<a name="ln1542">#else</a>
<a name="ln1543">	intr_status = atomic_get((int32 *)&amp;sc-&gt;sc_intr_status);</a>
<a name="ln1544">#endif</a>
<a name="ln1545"> </a>
<a name="ln1546">	KASSERT(sc-&gt;sc_cur_regwin-&gt;rw_type == BWI_REGWIN_T_MAC,</a>
<a name="ln1547">	    (&quot;current regwin type %d&quot;, sc-&gt;sc_cur_regwin-&gt;rw_type));</a>
<a name="ln1548">	mac = (struct bwi_mac *)sc-&gt;sc_cur_regwin;</a>
<a name="ln1549"> </a>
<a name="ln1550">	txrx_error = 0;</a>
<a name="ln1551">	DPRINTF(sc, BWI_DBG_INTR, &quot;%s\n&quot;, &quot;TX/RX intr&quot;);</a>
<a name="ln1552">	for (i = 0; i &lt; BWI_TXRX_NRING; ++i) {</a>
<a name="ln1553">		uint32_t mask;</a>
<a name="ln1554"> </a>
<a name="ln1555">		if (BWI_TXRX_IS_RX(i))</a>
<a name="ln1556">			mask = BWI_TXRX_RX_INTRS;</a>
<a name="ln1557">		else</a>
<a name="ln1558">			mask = BWI_TXRX_TX_INTRS;</a>
<a name="ln1559"> </a>
<a name="ln1560">		txrx_intr_status[i] =</a>
<a name="ln1561">		CSR_READ_4(sc, BWI_TXRX_INTR_STATUS(i)) &amp; mask;</a>
<a name="ln1562"> </a>
<a name="ln1563">		_DPRINTF(sc, BWI_DBG_INTR, &quot;, %d 0x%08x&quot;,</a>
<a name="ln1564">			 i, txrx_intr_status[i]);</a>
<a name="ln1565"> </a>
<a name="ln1566">		if (txrx_intr_status[i] &amp; BWI_TXRX_INTR_ERROR) {</a>
<a name="ln1567">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1568">			    &quot;%s: intr fatal TX/RX (%d) error 0x%08x\n&quot;,</a>
<a name="ln1569">			    __func__, i, txrx_intr_status[i]);</a>
<a name="ln1570">			txrx_error = 1;</a>
<a name="ln1571">		}</a>
<a name="ln1572">	}</a>
<a name="ln1573">	_DPRINTF(sc, BWI_DBG_INTR, &quot;%s\n&quot;, &quot;&quot;);</a>
<a name="ln1574"> </a>
<a name="ln1575">	/*</a>
<a name="ln1576">	 * Acknowledge interrupt</a>
<a name="ln1577">	 */</a>
<a name="ln1578">	CSR_WRITE_4(sc, BWI_MAC_INTR_STATUS, intr_status);</a>
<a name="ln1579"> </a>
<a name="ln1580">	for (i = 0; i &lt; BWI_TXRX_NRING; ++i)</a>
<a name="ln1581">		CSR_WRITE_4(sc, BWI_TXRX_INTR_STATUS(i), txrx_intr_status[i]);</a>
<a name="ln1582"> </a>
<a name="ln1583">#if !defined(__HAIKU__)</a>
<a name="ln1584">	/* Disable all interrupts */</a>
<a name="ln1585">	bwi_disable_intrs(sc, BWI_ALL_INTRS);</a>
<a name="ln1586">#endif</a>
<a name="ln1587"> </a>
<a name="ln1588">	/*</a>
<a name="ln1589">	 * http://bcm-specs.sipsolutions.net/Interrupts</a>
<a name="ln1590">	 * Says for this bit (0x800):</a>
<a name="ln1591">	 * &quot;Fatal Error</a>
<a name="ln1592">	 *</a>
<a name="ln1593">	 * We got this one while testing things when by accident the</a>
<a name="ln1594">	 * template ram wasn't set to big endian when it should have</a>
<a name="ln1595">	 * been after writing the initial values. It keeps on being</a>
<a name="ln1596">	 * triggered, the only way to stop it seems to shut down the</a>
<a name="ln1597">	 * chip.&quot;</a>
<a name="ln1598">	 *</a>
<a name="ln1599">	 * Suggesting that we should never get it and if we do we're not</a>
<a name="ln1600">	 * feeding TX packets into the MAC correctly if we do...  Apparently,</a>
<a name="ln1601">	 * it is valid only on mac version 5 and higher, but I couldn't</a>
<a name="ln1602">	 * find a reference for that...  Since I see them from time to time</a>
<a name="ln1603">	 * on my card, this suggests an error in the tx path still...</a>
<a name="ln1604">	 */</a>
<a name="ln1605">	if (intr_status &amp; BWI_INTR_PHY_TXERR) {</a>
<a name="ln1606">		if (mac-&gt;mac_flags &amp; BWI_MAC_F_PHYE_RESET) {</a>
<a name="ln1607">			device_printf(sc-&gt;sc_dev, &quot;%s: intr PHY TX error\n&quot;,</a>
<a name="ln1608">			    __func__);</a>
<a name="ln1609">			taskqueue_enqueue(sc-&gt;sc_tq, &amp;sc-&gt;sc_restart_task);</a>
<a name="ln1610">			BWI_UNLOCK(sc);</a>
<a name="ln1611">			return;</a>
<a name="ln1612">		}</a>
<a name="ln1613">	}</a>
<a name="ln1614"> </a>
<a name="ln1615">	if (txrx_error) {</a>
<a name="ln1616">		/* TODO: reset device */</a>
<a name="ln1617">	}</a>
<a name="ln1618"> </a>
<a name="ln1619">	if (intr_status &amp; BWI_INTR_TBTT)</a>
<a name="ln1620">		bwi_mac_config_ps(mac);</a>
<a name="ln1621"> </a>
<a name="ln1622">	if (intr_status &amp; BWI_INTR_EO_ATIM)</a>
<a name="ln1623">		device_printf(sc-&gt;sc_dev, &quot;EO_ATIM\n&quot;);</a>
<a name="ln1624"> </a>
<a name="ln1625">	if (intr_status &amp; BWI_INTR_PMQ) {</a>
<a name="ln1626">		for (;;) {</a>
<a name="ln1627">			if ((CSR_READ_4(sc, BWI_MAC_PS_STATUS) &amp; 0x8) == 0)</a>
<a name="ln1628">				break;</a>
<a name="ln1629">		}</a>
<a name="ln1630">		CSR_WRITE_2(sc, BWI_MAC_PS_STATUS, 0x2);</a>
<a name="ln1631">	}</a>
<a name="ln1632"> </a>
<a name="ln1633">	if (intr_status &amp; BWI_INTR_NOISE)</a>
<a name="ln1634">		device_printf(sc-&gt;sc_dev, &quot;intr noise\n&quot;);</a>
<a name="ln1635"> </a>
<a name="ln1636">	if (txrx_intr_status[0] &amp; BWI_TXRX_INTR_RX) {</a>
<a name="ln1637">		rx_data = sc-&gt;sc_rxeof(sc);</a>
<a name="ln1638">		if (sc-&gt;sc_flags &amp; BWI_F_STOP) {</a>
<a name="ln1639">			BWI_UNLOCK(sc);</a>
<a name="ln1640">			return;</a>
<a name="ln1641">		}</a>
<a name="ln1642">	}</a>
<a name="ln1643"> </a>
<a name="ln1644">	if (txrx_intr_status[3] &amp; BWI_TXRX_INTR_RX) {</a>
<a name="ln1645">		sc-&gt;sc_txeof_status(sc);</a>
<a name="ln1646">		tx = 1;</a>
<a name="ln1647">	}</a>
<a name="ln1648"> </a>
<a name="ln1649">	if (intr_status &amp; BWI_INTR_TX_DONE) {</a>
<a name="ln1650">		bwi_txeof(sc);</a>
<a name="ln1651">		tx = 1;</a>
<a name="ln1652">	}</a>
<a name="ln1653"> </a>
<a name="ln1654">	/* Re-enable interrupts */</a>
<a name="ln1655">	bwi_enable_intrs(sc, BWI_INIT_INTRS);</a>
<a name="ln1656"> </a>
<a name="ln1657">	if (sc-&gt;sc_blink_led != NULL &amp;&amp; sc-&gt;sc_led_blink) {</a>
<a name="ln1658">		int evt = BWI_LED_EVENT_NONE;</a>
<a name="ln1659"> </a>
<a name="ln1660">		if (tx &amp;&amp; rx_data &gt; 0) {</a>
<a name="ln1661">			if (sc-&gt;sc_rx_rate &gt; sc-&gt;sc_tx_rate)</a>
<a name="ln1662">				evt = BWI_LED_EVENT_RX;</a>
<a name="ln1663">			else</a>
<a name="ln1664">				evt = BWI_LED_EVENT_TX;</a>
<a name="ln1665">		} else if (tx) {</a>
<a name="ln1666">			evt = BWI_LED_EVENT_TX;</a>
<a name="ln1667">		} else if (rx_data &gt; 0) {</a>
<a name="ln1668">			evt = BWI_LED_EVENT_RX;</a>
<a name="ln1669">		} else if (rx_data == 0) {</a>
<a name="ln1670">			evt = BWI_LED_EVENT_POLL;</a>
<a name="ln1671">		}</a>
<a name="ln1672"> </a>
<a name="ln1673">		if (evt != BWI_LED_EVENT_NONE)</a>
<a name="ln1674">			bwi_led_event(sc, evt);</a>
<a name="ln1675">	}</a>
<a name="ln1676"> </a>
<a name="ln1677">	BWI_UNLOCK(sc);</a>
<a name="ln1678">}</a>
<a name="ln1679"> </a>
<a name="ln1680">static void</a>
<a name="ln1681">bwi_scan_start(struct ieee80211com *ic)</a>
<a name="ln1682">{</a>
<a name="ln1683">	struct bwi_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1684"> </a>
<a name="ln1685">	BWI_LOCK(sc);</a>
<a name="ln1686">	/* Enable MAC beacon promiscuity */</a>
<a name="ln1687">	CSR_SETBITS_4(sc, BWI_MAC_STATUS, BWI_MAC_STATUS_PASS_BCN);</a>
<a name="ln1688">	BWI_UNLOCK(sc);</a>
<a name="ln1689">}</a>
<a name="ln1690"> </a>
<a name="ln1691">static void</a>
<a name="ln1692">bwi_getradiocaps(struct ieee80211com *ic,</a>
<a name="ln1693">    int maxchans, int *nchans, struct ieee80211_channel chans[])</a>
<a name="ln1694">{</a>
<a name="ln1695">	struct bwi_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1696">	struct bwi_mac *mac;</a>
<a name="ln1697">	struct bwi_phy *phy;</a>
<a name="ln1698">	uint8_t bands[IEEE80211_MODE_BYTES];</a>
<a name="ln1699"> </a>
<a name="ln1700">	/*</a>
<a name="ln1701">	 * XXX First MAC is known to exist</a>
<a name="ln1702">	 * TODO2</a>
<a name="ln1703">	 */</a>
<a name="ln1704">	mac = &amp;sc-&gt;sc_mac[0];</a>
<a name="ln1705">	phy = &amp;mac-&gt;mac_phy;</a>
<a name="ln1706"> </a>
<a name="ln1707">	memset(bands, 0, sizeof(bands));</a>
<a name="ln1708">	switch (phy-&gt;phy_mode) {</a>
<a name="ln1709">	case IEEE80211_MODE_11G:</a>
<a name="ln1710">		setbit(bands, IEEE80211_MODE_11G);</a>
<a name="ln1711">		/* FALLTHROUGH */</a>
<a name="ln1712">	case IEEE80211_MODE_11B:</a>
<a name="ln1713">		setbit(bands, IEEE80211_MODE_11B);</a>
<a name="ln1714">		break;</a>
<a name="ln1715">	case IEEE80211_MODE_11A:</a>
<a name="ln1716">		/* TODO:11A */</a>
<a name="ln1717">		setbit(bands, IEEE80211_MODE_11A);</a>
<a name="ln1718">		device_printf(sc-&gt;sc_dev, &quot;no 11a support\n&quot;);</a>
<a name="ln1719">		return;</a>
<a name="ln1720">	default:</a>
<a name="ln1721">		panic(&quot;unknown phymode %d\n&quot;, phy-&gt;phy_mode);</a>
<a name="ln1722">	}</a>
<a name="ln1723"> </a>
<a name="ln1724">	ieee80211_add_channel_list_2ghz(chans, maxchans, nchans,</a>
<a name="ln1725">	    bwi_chan_2ghz, nitems(bwi_chan_2ghz), bands, 0);</a>
<a name="ln1726">}</a>
<a name="ln1727"> </a>
<a name="ln1728">static void</a>
<a name="ln1729">bwi_set_channel(struct ieee80211com *ic)</a>
<a name="ln1730">{</a>
<a name="ln1731">	struct bwi_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1732">	struct ieee80211_channel *c = ic-&gt;ic_curchan;</a>
<a name="ln1733">	struct bwi_mac *mac;</a>
<a name="ln1734"> </a>
<a name="ln1735">	BWI_LOCK(sc);</a>
<a name="ln1736">	KASSERT(sc-&gt;sc_cur_regwin-&gt;rw_type == BWI_REGWIN_T_MAC,</a>
<a name="ln1737">	    (&quot;current regwin type %d&quot;, sc-&gt;sc_cur_regwin-&gt;rw_type));</a>
<a name="ln1738">	mac = (struct bwi_mac *)sc-&gt;sc_cur_regwin;</a>
<a name="ln1739">	bwi_rf_set_chan(mac, ieee80211_chan2ieee(ic, c), 0);</a>
<a name="ln1740"> </a>
<a name="ln1741">	sc-&gt;sc_rates = ieee80211_get_ratetable(c);</a>
<a name="ln1742"> </a>
<a name="ln1743">	/*</a>
<a name="ln1744">	 * Setup radio tap channel freq and flags</a>
<a name="ln1745">	 */</a>
<a name="ln1746">	sc-&gt;sc_tx_th.wt_chan_freq = sc-&gt;sc_rx_th.wr_chan_freq =</a>
<a name="ln1747">		htole16(c-&gt;ic_freq);</a>
<a name="ln1748">	sc-&gt;sc_tx_th.wt_chan_flags = sc-&gt;sc_rx_th.wr_chan_flags =</a>
<a name="ln1749">		htole16(c-&gt;ic_flags &amp; 0xffff);</a>
<a name="ln1750"> </a>
<a name="ln1751">	BWI_UNLOCK(sc);</a>
<a name="ln1752">}</a>
<a name="ln1753"> </a>
<a name="ln1754">static void</a>
<a name="ln1755">bwi_scan_end(struct ieee80211com *ic)</a>
<a name="ln1756">{</a>
<a name="ln1757">	struct bwi_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1758"> </a>
<a name="ln1759">	BWI_LOCK(sc);</a>
<a name="ln1760">	CSR_CLRBITS_4(sc, BWI_MAC_STATUS, BWI_MAC_STATUS_PASS_BCN);</a>
<a name="ln1761">	BWI_UNLOCK(sc);</a>
<a name="ln1762">}</a>
<a name="ln1763"> </a>
<a name="ln1764">static int</a>
<a name="ln1765">bwi_newstate(struct ieee80211vap *vap, enum ieee80211_state nstate, int arg)</a>
<a name="ln1766">{</a>
<a name="ln1767">	struct bwi_vap *bvp = BWI_VAP(vap);</a>
<a name="ln1768">	struct ieee80211com *ic= vap-&gt;iv_ic;</a>
<a name="ln1769">	struct bwi_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1770">	enum ieee80211_state ostate = vap-&gt;iv_state;</a>
<a name="ln1771">	struct bwi_mac *mac;</a>
<a name="ln1772">	int error;</a>
<a name="ln1773"> </a>
<a name="ln1774">	BWI_LOCK(sc);</a>
<a name="ln1775"> </a>
<a name="ln1776">	callout_stop(&amp;sc-&gt;sc_calib_ch);</a>
<a name="ln1777"> </a>
<a name="ln1778">	if (nstate == IEEE80211_S_INIT)</a>
<a name="ln1779">		sc-&gt;sc_txpwrcb_type = BWI_TXPWR_INIT;</a>
<a name="ln1780"> </a>
<a name="ln1781">	bwi_led_newstate(sc, nstate);</a>
<a name="ln1782"> </a>
<a name="ln1783">	error = bvp-&gt;bv_newstate(vap, nstate, arg);</a>
<a name="ln1784">	if (error != 0)</a>
<a name="ln1785">		goto back;</a>
<a name="ln1786"> </a>
<a name="ln1787">	/*</a>
<a name="ln1788">	 * Clear the BSSID when we stop a STA</a>
<a name="ln1789">	 */</a>
<a name="ln1790">	if (vap-&gt;iv_opmode == IEEE80211_M_STA) {</a>
<a name="ln1791">		if (ostate == IEEE80211_S_RUN &amp;&amp; nstate != IEEE80211_S_RUN) {</a>
<a name="ln1792">			/*</a>
<a name="ln1793">			 * Clear out the BSSID.  If we reassociate to</a>
<a name="ln1794">			 * the same AP, this will reinialize things</a>
<a name="ln1795">			 * correctly...</a>
<a name="ln1796">			 */</a>
<a name="ln1797">			if (ic-&gt;ic_opmode == IEEE80211_M_STA &amp;&amp; </a>
<a name="ln1798">			    !(sc-&gt;sc_flags &amp; BWI_F_STOP))</a>
<a name="ln1799">				bwi_set_bssid(sc, bwi_zero_addr);</a>
<a name="ln1800">		}</a>
<a name="ln1801">	}</a>
<a name="ln1802"> </a>
<a name="ln1803">	if (vap-&gt;iv_opmode == IEEE80211_M_MONITOR) {</a>
<a name="ln1804">		/* Nothing to do */</a>
<a name="ln1805">	} else if (nstate == IEEE80211_S_RUN) {</a>
<a name="ln1806">		bwi_set_bssid(sc, vap-&gt;iv_bss-&gt;ni_bssid);</a>
<a name="ln1807"> </a>
<a name="ln1808">		KASSERT(sc-&gt;sc_cur_regwin-&gt;rw_type == BWI_REGWIN_T_MAC,</a>
<a name="ln1809">		    (&quot;current regwin type %d&quot;, sc-&gt;sc_cur_regwin-&gt;rw_type));</a>
<a name="ln1810">		mac = (struct bwi_mac *)sc-&gt;sc_cur_regwin;</a>
<a name="ln1811"> </a>
<a name="ln1812">		/* Initial TX power calibration */</a>
<a name="ln1813">		bwi_mac_calibrate_txpower(mac, BWI_TXPWR_INIT);</a>
<a name="ln1814">#ifdef notyet</a>
<a name="ln1815">		sc-&gt;sc_txpwrcb_type = BWI_TXPWR_FORCE;</a>
<a name="ln1816">#else</a>
<a name="ln1817">		sc-&gt;sc_txpwrcb_type = BWI_TXPWR_CALIB;</a>
<a name="ln1818">#endif</a>
<a name="ln1819"> </a>
<a name="ln1820">		callout_reset(&amp;sc-&gt;sc_calib_ch, hz, bwi_calibrate, sc);</a>
<a name="ln1821">	}</a>
<a name="ln1822">back:</a>
<a name="ln1823">	BWI_UNLOCK(sc);</a>
<a name="ln1824"> </a>
<a name="ln1825">	return error;</a>
<a name="ln1826">}</a>
<a name="ln1827"> </a>
<a name="ln1828">static int</a>
<a name="ln1829">bwi_media_change(struct ifnet *ifp)</a>
<a name="ln1830">{</a>
<a name="ln1831">	int error = ieee80211_media_change(ifp);</a>
<a name="ln1832">	/* NB: only the fixed rate can change and that doesn't need a reset */</a>
<a name="ln1833">	return (error == ENETRESET ? 0 : error);</a>
<a name="ln1834">}</a>
<a name="ln1835"> </a>
<a name="ln1836">static int</a>
<a name="ln1837">bwi_dma_alloc(struct bwi_softc *sc)</a>
<a name="ln1838">{</a>
<a name="ln1839">	int error, i, has_txstats;</a>
<a name="ln1840">	bus_addr_t lowaddr = 0;</a>
<a name="ln1841">	bus_size_t tx_ring_sz, rx_ring_sz, desc_sz = 0;</a>
<a name="ln1842">	uint32_t txrx_ctrl_step = 0;</a>
<a name="ln1843"> </a>
<a name="ln1844">	has_txstats = 0;</a>
<a name="ln1845">	for (i = 0; i &lt; sc-&gt;sc_nmac; ++i) {</a>
<a name="ln1846">		if (sc-&gt;sc_mac[i].mac_flags &amp; BWI_MAC_F_HAS_TXSTATS) {</a>
<a name="ln1847">			has_txstats = 1;</a>
<a name="ln1848">			break;</a>
<a name="ln1849">		}</a>
<a name="ln1850">	}</a>
<a name="ln1851"> </a>
<a name="ln1852">	switch (sc-&gt;sc_bus_space) {</a>
<a name="ln1853">	case BWI_BUS_SPACE_30BIT:</a>
<a name="ln1854">	case BWI_BUS_SPACE_32BIT:</a>
<a name="ln1855">		if (sc-&gt;sc_bus_space == BWI_BUS_SPACE_30BIT)</a>
<a name="ln1856">			lowaddr = BWI_BUS_SPACE_MAXADDR;</a>
<a name="ln1857">		else</a>
<a name="ln1858">			lowaddr = BUS_SPACE_MAXADDR_32BIT;</a>
<a name="ln1859">		desc_sz = sizeof(struct bwi_desc32);</a>
<a name="ln1860">		txrx_ctrl_step = 0x20;</a>
<a name="ln1861"> </a>
<a name="ln1862">		sc-&gt;sc_init_tx_ring = bwi_init_tx_ring32;</a>
<a name="ln1863">		sc-&gt;sc_free_tx_ring = bwi_free_tx_ring32;</a>
<a name="ln1864">		sc-&gt;sc_init_rx_ring = bwi_init_rx_ring32;</a>
<a name="ln1865">		sc-&gt;sc_free_rx_ring = bwi_free_rx_ring32;</a>
<a name="ln1866">		sc-&gt;sc_setup_rxdesc = bwi_setup_rx_desc32;</a>
<a name="ln1867">		sc-&gt;sc_setup_txdesc = bwi_setup_tx_desc32;</a>
<a name="ln1868">		sc-&gt;sc_rxeof = bwi_rxeof32;</a>
<a name="ln1869">		sc-&gt;sc_start_tx = bwi_start_tx32;</a>
<a name="ln1870">		if (has_txstats) {</a>
<a name="ln1871">			sc-&gt;sc_init_txstats = bwi_init_txstats32;</a>
<a name="ln1872">			sc-&gt;sc_free_txstats = bwi_free_txstats32;</a>
<a name="ln1873">			sc-&gt;sc_txeof_status = bwi_txeof_status32;</a>
<a name="ln1874">		}</a>
<a name="ln1875">		break;</a>
<a name="ln1876"> </a>
<a name="ln1877">	case BWI_BUS_SPACE_64BIT:</a>
<a name="ln1878">		lowaddr = BUS_SPACE_MAXADDR;	/* XXX */</a>
<a name="ln1879">		desc_sz = sizeof(struct bwi_desc64);</a>
<a name="ln1880">		txrx_ctrl_step = 0x40;</a>
<a name="ln1881"> </a>
<a name="ln1882">		sc-&gt;sc_init_tx_ring = bwi_init_tx_ring64;</a>
<a name="ln1883">		sc-&gt;sc_free_tx_ring = bwi_free_tx_ring64;</a>
<a name="ln1884">		sc-&gt;sc_init_rx_ring = bwi_init_rx_ring64;</a>
<a name="ln1885">		sc-&gt;sc_free_rx_ring = bwi_free_rx_ring64;</a>
<a name="ln1886">		sc-&gt;sc_setup_rxdesc = bwi_setup_rx_desc64;</a>
<a name="ln1887">		sc-&gt;sc_setup_txdesc = bwi_setup_tx_desc64;</a>
<a name="ln1888">		sc-&gt;sc_rxeof = bwi_rxeof64;</a>
<a name="ln1889">		sc-&gt;sc_start_tx = bwi_start_tx64;</a>
<a name="ln1890">		if (has_txstats) {</a>
<a name="ln1891">			sc-&gt;sc_init_txstats = bwi_init_txstats64;</a>
<a name="ln1892">			sc-&gt;sc_free_txstats = bwi_free_txstats64;</a>
<a name="ln1893">			sc-&gt;sc_txeof_status = bwi_txeof_status64;</a>
<a name="ln1894">		}</a>
<a name="ln1895">		break;</a>
<a name="ln1896">	}</a>
<a name="ln1897"> </a>
<a name="ln1898">	KASSERT(lowaddr != 0, (&quot;lowaddr zero&quot;));</a>
<a name="ln1899">	KASSERT(desc_sz != 0, (&quot;desc_sz zero&quot;));</a>
<a name="ln1900">	KASSERT(txrx_ctrl_step != 0, (&quot;txrx_ctrl_step zero&quot;));</a>
<a name="ln1901"> </a>
<a name="ln1902">	tx_ring_sz = roundup(desc_sz * BWI_TX_NDESC, BWI_RING_ALIGN);</a>
<a name="ln1903">	rx_ring_sz = roundup(desc_sz * BWI_RX_NDESC, BWI_RING_ALIGN);</a>
<a name="ln1904"> </a>
<a name="ln1905">	/*</a>
<a name="ln1906">	 * Create top level DMA tag</a>
<a name="ln1907">	 */</a>
<a name="ln1908">	error = bus_dma_tag_create(bus_get_dma_tag(sc-&gt;sc_dev),	/* parent */</a>
<a name="ln1909">			       BWI_ALIGN, 0,		/* alignment, bounds */</a>
<a name="ln1910">			       lowaddr,			/* lowaddr */</a>
<a name="ln1911">			       BUS_SPACE_MAXADDR,	/* highaddr */</a>
<a name="ln1912">			       NULL, NULL,		/* filter, filterarg */</a>
<a name="ln1913">			       BUS_SPACE_MAXSIZE,	/* maxsize */</a>
<a name="ln1914">			       BUS_SPACE_UNRESTRICTED,	/* nsegments */</a>
<a name="ln1915">			       BUS_SPACE_MAXSIZE_32BIT,	/* maxsegsize */</a>
<a name="ln1916">			       0,			/* flags */</a>
<a name="ln1917">			       NULL, NULL,		/* lockfunc, lockarg */</a>
<a name="ln1918">			       &amp;sc-&gt;sc_parent_dtag);</a>
<a name="ln1919">	if (error) {</a>
<a name="ln1920">		device_printf(sc-&gt;sc_dev, &quot;can't create parent DMA tag\n&quot;);</a>
<a name="ln1921">		return error;</a>
<a name="ln1922">	}</a>
<a name="ln1923"> </a>
<a name="ln1924">#define TXRX_CTRL(idx)	(BWI_TXRX_CTRL_BASE + (idx) * txrx_ctrl_step)</a>
<a name="ln1925"> </a>
<a name="ln1926">	/*</a>
<a name="ln1927">	 * Create TX ring DMA stuffs</a>
<a name="ln1928">	 */</a>
<a name="ln1929">	error = bus_dma_tag_create(sc-&gt;sc_parent_dtag,</a>
<a name="ln1930">				BWI_RING_ALIGN, 0,</a>
<a name="ln1931">				BUS_SPACE_MAXADDR,</a>
<a name="ln1932">				BUS_SPACE_MAXADDR,</a>
<a name="ln1933">				NULL, NULL,</a>
<a name="ln1934">				tx_ring_sz,</a>
<a name="ln1935">				1,</a>
<a name="ln1936">				tx_ring_sz,</a>
<a name="ln1937">				0,</a>
<a name="ln1938">				NULL, NULL,</a>
<a name="ln1939">				&amp;sc-&gt;sc_txring_dtag);</a>
<a name="ln1940">	if (error) {</a>
<a name="ln1941">		device_printf(sc-&gt;sc_dev, &quot;can't create TX ring DMA tag\n&quot;);</a>
<a name="ln1942">		return error;</a>
<a name="ln1943">	}</a>
<a name="ln1944"> </a>
<a name="ln1945">	for (i = 0; i &lt; BWI_TX_NRING; ++i) {</a>
<a name="ln1946">		error = bwi_dma_ring_alloc(sc, sc-&gt;sc_txring_dtag,</a>
<a name="ln1947">					   &amp;sc-&gt;sc_tx_rdata[i], tx_ring_sz,</a>
<a name="ln1948">					   TXRX_CTRL(i));</a>
<a name="ln1949">		if (error) {</a>
<a name="ln1950">			device_printf(sc-&gt;sc_dev, &quot;%dth TX ring &quot;</a>
<a name="ln1951">				      &quot;DMA alloc failed\n&quot;, i);</a>
<a name="ln1952">			return error;</a>
<a name="ln1953">		}</a>
<a name="ln1954">	}</a>
<a name="ln1955"> </a>
<a name="ln1956">	/*</a>
<a name="ln1957">	 * Create RX ring DMA stuffs</a>
<a name="ln1958">	 */</a>
<a name="ln1959">	error = bus_dma_tag_create(sc-&gt;sc_parent_dtag,</a>
<a name="ln1960">				BWI_RING_ALIGN, 0,</a>
<a name="ln1961">				BUS_SPACE_MAXADDR,</a>
<a name="ln1962">				BUS_SPACE_MAXADDR,</a>
<a name="ln1963">				NULL, NULL,</a>
<a name="ln1964">				rx_ring_sz,</a>
<a name="ln1965">				1,</a>
<a name="ln1966">				rx_ring_sz,</a>
<a name="ln1967">				0,</a>
<a name="ln1968">				NULL, NULL,</a>
<a name="ln1969">				&amp;sc-&gt;sc_rxring_dtag);</a>
<a name="ln1970">	if (error) {</a>
<a name="ln1971">		device_printf(sc-&gt;sc_dev, &quot;can't create RX ring DMA tag\n&quot;);</a>
<a name="ln1972">		return error;</a>
<a name="ln1973">	}</a>
<a name="ln1974"> </a>
<a name="ln1975">	error = bwi_dma_ring_alloc(sc, sc-&gt;sc_rxring_dtag, &amp;sc-&gt;sc_rx_rdata,</a>
<a name="ln1976">				   rx_ring_sz, TXRX_CTRL(0));</a>
<a name="ln1977">	if (error) {</a>
<a name="ln1978">		device_printf(sc-&gt;sc_dev, &quot;RX ring DMA alloc failed\n&quot;);</a>
<a name="ln1979">		return error;</a>
<a name="ln1980">	}</a>
<a name="ln1981"> </a>
<a name="ln1982">	if (has_txstats) {</a>
<a name="ln1983">		error = bwi_dma_txstats_alloc(sc, TXRX_CTRL(3), desc_sz);</a>
<a name="ln1984">		if (error) {</a>
<a name="ln1985">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1986">				      &quot;TX stats DMA alloc failed\n&quot;);</a>
<a name="ln1987">			return error;</a>
<a name="ln1988">		}</a>
<a name="ln1989">	}</a>
<a name="ln1990"> </a>
<a name="ln1991">#undef TXRX_CTRL</a>
<a name="ln1992"> </a>
<a name="ln1993">	return bwi_dma_mbuf_create(sc);</a>
<a name="ln1994">}</a>
<a name="ln1995"> </a>
<a name="ln1996">static void</a>
<a name="ln1997">bwi_dma_free(struct bwi_softc *sc)</a>
<a name="ln1998">{</a>
<a name="ln1999">	if (sc-&gt;sc_txring_dtag != NULL) {</a>
<a name="ln2000">		int i;</a>
<a name="ln2001"> </a>
<a name="ln2002">		for (i = 0; i &lt; BWI_TX_NRING; ++i) {</a>
<a name="ln2003">			struct bwi_ring_data *rd = &amp;sc-&gt;sc_tx_rdata[i];</a>
<a name="ln2004"> </a>
<a name="ln2005">			if (rd-&gt;rdata_desc != NULL) {</a>
<a name="ln2006">				bus_dmamap_unload(sc-&gt;sc_txring_dtag,</a>
<a name="ln2007">						  rd-&gt;rdata_dmap);</a>
<a name="ln2008">				bus_dmamem_free(sc-&gt;sc_txring_dtag,</a>
<a name="ln2009">						rd-&gt;rdata_desc,</a>
<a name="ln2010">						rd-&gt;rdata_dmap);</a>
<a name="ln2011">			}</a>
<a name="ln2012">		}</a>
<a name="ln2013">		bus_dma_tag_destroy(sc-&gt;sc_txring_dtag);</a>
<a name="ln2014">	}</a>
<a name="ln2015"> </a>
<a name="ln2016">	if (sc-&gt;sc_rxring_dtag != NULL) {</a>
<a name="ln2017">		struct bwi_ring_data *rd = &amp;sc-&gt;sc_rx_rdata;</a>
<a name="ln2018"> </a>
<a name="ln2019">		if (rd-&gt;rdata_desc != NULL) {</a>
<a name="ln2020">			bus_dmamap_unload(sc-&gt;sc_rxring_dtag, rd-&gt;rdata_dmap);</a>
<a name="ln2021">			bus_dmamem_free(sc-&gt;sc_rxring_dtag, rd-&gt;rdata_desc,</a>
<a name="ln2022">					rd-&gt;rdata_dmap);</a>
<a name="ln2023">		}</a>
<a name="ln2024">		bus_dma_tag_destroy(sc-&gt;sc_rxring_dtag);</a>
<a name="ln2025">	}</a>
<a name="ln2026"> </a>
<a name="ln2027">	bwi_dma_txstats_free(sc);</a>
<a name="ln2028">	bwi_dma_mbuf_destroy(sc, BWI_TX_NRING, 1);</a>
<a name="ln2029"> </a>
<a name="ln2030">	if (sc-&gt;sc_parent_dtag != NULL)</a>
<a name="ln2031">		bus_dma_tag_destroy(sc-&gt;sc_parent_dtag);</a>
<a name="ln2032">}</a>
<a name="ln2033"> </a>
<a name="ln2034">static int</a>
<a name="ln2035">bwi_dma_ring_alloc(struct bwi_softc *sc, bus_dma_tag_t dtag,</a>
<a name="ln2036">		   struct bwi_ring_data *rd, bus_size_t size,</a>
<a name="ln2037">		   uint32_t txrx_ctrl)</a>
<a name="ln2038">{</a>
<a name="ln2039">	int error;</a>
<a name="ln2040"> </a>
<a name="ln2041">	error = bus_dmamem_alloc(dtag, &amp;rd-&gt;rdata_desc,</a>
<a name="ln2042">				 BUS_DMA_WAITOK | BUS_DMA_ZERO,</a>
<a name="ln2043">				 &amp;rd-&gt;rdata_dmap);</a>
<a name="ln2044">	if (error) {</a>
<a name="ln2045">		device_printf(sc-&gt;sc_dev, &quot;can't allocate DMA mem\n&quot;);</a>
<a name="ln2046">		return error;</a>
<a name="ln2047">	}</a>
<a name="ln2048"> </a>
<a name="ln2049">	error = bus_dmamap_load(dtag, rd-&gt;rdata_dmap, rd-&gt;rdata_desc, size,</a>
<a name="ln2050">				bwi_dma_ring_addr, &amp;rd-&gt;rdata_paddr,</a>
<a name="ln2051">				BUS_DMA_NOWAIT);</a>
<a name="ln2052">	if (error) {</a>
<a name="ln2053">		device_printf(sc-&gt;sc_dev, &quot;can't load DMA mem\n&quot;);</a>
<a name="ln2054">		bus_dmamem_free(dtag, rd-&gt;rdata_desc, rd-&gt;rdata_dmap);</a>
<a name="ln2055">		rd-&gt;rdata_desc = NULL;</a>
<a name="ln2056">		return error;</a>
<a name="ln2057">	}</a>
<a name="ln2058"> </a>
<a name="ln2059">	rd-&gt;rdata_txrx_ctrl = txrx_ctrl;</a>
<a name="ln2060">	return 0;</a>
<a name="ln2061">}</a>
<a name="ln2062"> </a>
<a name="ln2063">static int</a>
<a name="ln2064">bwi_dma_txstats_alloc(struct bwi_softc *sc, uint32_t ctrl_base,</a>
<a name="ln2065">		      bus_size_t desc_sz)</a>
<a name="ln2066">{</a>
<a name="ln2067">	struct bwi_txstats_data *st;</a>
<a name="ln2068">	bus_size_t dma_size;</a>
<a name="ln2069">	int error;</a>
<a name="ln2070"> </a>
<a name="ln2071">	st = malloc(sizeof(*st), M_DEVBUF, M_NOWAIT | M_ZERO);</a>
<a name="ln2072">	if (st == NULL) {</a>
<a name="ln2073">		device_printf(sc-&gt;sc_dev, &quot;can't allocate txstats data\n&quot;);</a>
<a name="ln2074">		return ENOMEM;</a>
<a name="ln2075">	}</a>
<a name="ln2076">	sc-&gt;sc_txstats = st;</a>
<a name="ln2077"> </a>
<a name="ln2078">	/*</a>
<a name="ln2079">	 * Create TX stats descriptor DMA stuffs</a>
<a name="ln2080">	 */</a>
<a name="ln2081">	dma_size = roundup(desc_sz * BWI_TXSTATS_NDESC, BWI_RING_ALIGN);</a>
<a name="ln2082"> </a>
<a name="ln2083">	error = bus_dma_tag_create(sc-&gt;sc_parent_dtag,</a>
<a name="ln2084">				BWI_RING_ALIGN,</a>
<a name="ln2085">				0,</a>
<a name="ln2086">				BUS_SPACE_MAXADDR,</a>
<a name="ln2087">				BUS_SPACE_MAXADDR,</a>
<a name="ln2088">				NULL, NULL,</a>
<a name="ln2089">				dma_size,</a>
<a name="ln2090">				1,</a>
<a name="ln2091">				dma_size,</a>
<a name="ln2092">				0,</a>
<a name="ln2093">				NULL, NULL,</a>
<a name="ln2094">				&amp;st-&gt;stats_ring_dtag);</a>
<a name="ln2095">	if (error) {</a>
<a name="ln2096">		device_printf(sc-&gt;sc_dev, &quot;can't create txstats ring &quot;</a>
<a name="ln2097">			      &quot;DMA tag\n&quot;);</a>
<a name="ln2098">		return error;</a>
<a name="ln2099">	}</a>
<a name="ln2100"> </a>
<a name="ln2101">	error = bus_dmamem_alloc(st-&gt;stats_ring_dtag, &amp;st-&gt;stats_ring,</a>
<a name="ln2102">				 BUS_DMA_WAITOK | BUS_DMA_ZERO,</a>
<a name="ln2103">				 &amp;st-&gt;stats_ring_dmap);</a>
<a name="ln2104">	if (error) {</a>
<a name="ln2105">		device_printf(sc-&gt;sc_dev, &quot;can't allocate txstats ring &quot;</a>
<a name="ln2106">			      &quot;DMA mem\n&quot;);</a>
<a name="ln2107">		bus_dma_tag_destroy(st-&gt;stats_ring_dtag);</a>
<a name="ln2108">		st-&gt;stats_ring_dtag = NULL;</a>
<a name="ln2109">		return error;</a>
<a name="ln2110">	}</a>
<a name="ln2111"> </a>
<a name="ln2112">	error = bus_dmamap_load(st-&gt;stats_ring_dtag, st-&gt;stats_ring_dmap,</a>
<a name="ln2113">				st-&gt;stats_ring, dma_size,</a>
<a name="ln2114">				bwi_dma_ring_addr, &amp;st-&gt;stats_ring_paddr,</a>
<a name="ln2115">				BUS_DMA_NOWAIT);</a>
<a name="ln2116">	if (error) {</a>
<a name="ln2117">		device_printf(sc-&gt;sc_dev, &quot;can't load txstats ring DMA mem\n&quot;);</a>
<a name="ln2118">		bus_dmamem_free(st-&gt;stats_ring_dtag, st-&gt;stats_ring,</a>
<a name="ln2119">				st-&gt;stats_ring_dmap);</a>
<a name="ln2120">		bus_dma_tag_destroy(st-&gt;stats_ring_dtag);</a>
<a name="ln2121">		st-&gt;stats_ring_dtag = NULL;</a>
<a name="ln2122">		return error;</a>
<a name="ln2123">	}</a>
<a name="ln2124"> </a>
<a name="ln2125">	/*</a>
<a name="ln2126">	 * Create TX stats DMA stuffs</a>
<a name="ln2127">	 */</a>
<a name="ln2128">	dma_size = roundup(sizeof(struct bwi_txstats) * BWI_TXSTATS_NDESC,</a>
<a name="ln2129">			   BWI_ALIGN);</a>
<a name="ln2130"> </a>
<a name="ln2131">	error = bus_dma_tag_create(sc-&gt;sc_parent_dtag,</a>
<a name="ln2132">				BWI_ALIGN,</a>
<a name="ln2133">				0,</a>
<a name="ln2134">				BUS_SPACE_MAXADDR,</a>
<a name="ln2135">				BUS_SPACE_MAXADDR,</a>
<a name="ln2136">				NULL, NULL,</a>
<a name="ln2137">				dma_size,</a>
<a name="ln2138">				1,</a>
<a name="ln2139">				dma_size,</a>
<a name="ln2140">				0,</a>
<a name="ln2141">				NULL, NULL,</a>
<a name="ln2142">				&amp;st-&gt;stats_dtag);</a>
<a name="ln2143">	if (error) {</a>
<a name="ln2144">		device_printf(sc-&gt;sc_dev, &quot;can't create txstats DMA tag\n&quot;);</a>
<a name="ln2145">		return error;</a>
<a name="ln2146">	}</a>
<a name="ln2147"> </a>
<a name="ln2148">	error = bus_dmamem_alloc(st-&gt;stats_dtag, (void **)&amp;st-&gt;stats,</a>
<a name="ln2149">				 BUS_DMA_WAITOK | BUS_DMA_ZERO,</a>
<a name="ln2150">				 &amp;st-&gt;stats_dmap);</a>
<a name="ln2151">	if (error) {</a>
<a name="ln2152">		device_printf(sc-&gt;sc_dev, &quot;can't allocate txstats DMA mem\n&quot;);</a>
<a name="ln2153">		bus_dma_tag_destroy(st-&gt;stats_dtag);</a>
<a name="ln2154">		st-&gt;stats_dtag = NULL;</a>
<a name="ln2155">		return error;</a>
<a name="ln2156">	}</a>
<a name="ln2157"> </a>
<a name="ln2158">	error = bus_dmamap_load(st-&gt;stats_dtag, st-&gt;stats_dmap, st-&gt;stats,</a>
<a name="ln2159">				dma_size, bwi_dma_ring_addr, &amp;st-&gt;stats_paddr,</a>
<a name="ln2160">				BUS_DMA_NOWAIT);</a>
<a name="ln2161">	if (error) {</a>
<a name="ln2162">		device_printf(sc-&gt;sc_dev, &quot;can't load txstats DMA mem\n&quot;);</a>
<a name="ln2163">		bus_dmamem_free(st-&gt;stats_dtag, st-&gt;stats, st-&gt;stats_dmap);</a>
<a name="ln2164">		bus_dma_tag_destroy(st-&gt;stats_dtag);</a>
<a name="ln2165">		st-&gt;stats_dtag = NULL;</a>
<a name="ln2166">		return error;</a>
<a name="ln2167">	}</a>
<a name="ln2168"> </a>
<a name="ln2169">	st-&gt;stats_ctrl_base = ctrl_base;</a>
<a name="ln2170">	return 0;</a>
<a name="ln2171">}</a>
<a name="ln2172"> </a>
<a name="ln2173">static void</a>
<a name="ln2174">bwi_dma_txstats_free(struct bwi_softc *sc)</a>
<a name="ln2175">{</a>
<a name="ln2176">	struct bwi_txstats_data *st;</a>
<a name="ln2177"> </a>
<a name="ln2178">	if (sc-&gt;sc_txstats == NULL)</a>
<a name="ln2179">		return;</a>
<a name="ln2180">	st = sc-&gt;sc_txstats;</a>
<a name="ln2181"> </a>
<a name="ln2182">	if (st-&gt;stats_ring_dtag != NULL) {</a>
<a name="ln2183">		bus_dmamap_unload(st-&gt;stats_ring_dtag, st-&gt;stats_ring_dmap);</a>
<a name="ln2184">		bus_dmamem_free(st-&gt;stats_ring_dtag, st-&gt;stats_ring,</a>
<a name="ln2185">				st-&gt;stats_ring_dmap);</a>
<a name="ln2186">		bus_dma_tag_destroy(st-&gt;stats_ring_dtag);</a>
<a name="ln2187">	}</a>
<a name="ln2188"> </a>
<a name="ln2189">	if (st-&gt;stats_dtag != NULL) {</a>
<a name="ln2190">		bus_dmamap_unload(st-&gt;stats_dtag, st-&gt;stats_dmap);</a>
<a name="ln2191">		bus_dmamem_free(st-&gt;stats_dtag, st-&gt;stats, st-&gt;stats_dmap);</a>
<a name="ln2192">		bus_dma_tag_destroy(st-&gt;stats_dtag);</a>
<a name="ln2193">	}</a>
<a name="ln2194"> </a>
<a name="ln2195">	free(st, M_DEVBUF);</a>
<a name="ln2196">}</a>
<a name="ln2197"> </a>
<a name="ln2198">static void</a>
<a name="ln2199">bwi_dma_ring_addr(void *arg, bus_dma_segment_t *seg, int nseg, int error)</a>
<a name="ln2200">{</a>
<a name="ln2201">	KASSERT(nseg == 1, (&quot;too many segments\n&quot;));</a>
<a name="ln2202">	*((bus_addr_t *)arg) = seg-&gt;ds_addr;</a>
<a name="ln2203">}</a>
<a name="ln2204"> </a>
<a name="ln2205">static int</a>
<a name="ln2206">bwi_dma_mbuf_create(struct bwi_softc *sc)</a>
<a name="ln2207">{</a>
<a name="ln2208">	struct bwi_rxbuf_data *rbd = &amp;sc-&gt;sc_rx_bdata;</a>
<a name="ln2209">	int i, j, k, ntx, error;</a>
<a name="ln2210"> </a>
<a name="ln2211">	/*</a>
<a name="ln2212">	 * Create TX/RX mbuf DMA tag</a>
<a name="ln2213">	 */</a>
<a name="ln2214">	error = bus_dma_tag_create(sc-&gt;sc_parent_dtag,</a>
<a name="ln2215">				1,</a>
<a name="ln2216">				0,</a>
<a name="ln2217">				BUS_SPACE_MAXADDR,</a>
<a name="ln2218">				BUS_SPACE_MAXADDR,</a>
<a name="ln2219">				NULL, NULL,</a>
<a name="ln2220">				MCLBYTES,</a>
<a name="ln2221">				1,</a>
<a name="ln2222">				MCLBYTES,</a>
<a name="ln2223">				BUS_DMA_ALLOCNOW,</a>
<a name="ln2224">				NULL, NULL,</a>
<a name="ln2225">				&amp;sc-&gt;sc_buf_dtag);</a>
<a name="ln2226">	if (error) {</a>
<a name="ln2227">		device_printf(sc-&gt;sc_dev, &quot;can't create mbuf DMA tag\n&quot;);</a>
<a name="ln2228">		return error;</a>
<a name="ln2229">	}</a>
<a name="ln2230"> </a>
<a name="ln2231">	ntx = 0;</a>
<a name="ln2232"> </a>
<a name="ln2233">	/*</a>
<a name="ln2234">	 * Create TX mbuf DMA map</a>
<a name="ln2235">	 */</a>
<a name="ln2236">	for (i = 0; i &lt; BWI_TX_NRING; ++i) {</a>
<a name="ln2237">		struct bwi_txbuf_data *tbd = &amp;sc-&gt;sc_tx_bdata[i];</a>
<a name="ln2238"> </a>
<a name="ln2239">		for (j = 0; j &lt; BWI_TX_NDESC; ++j) {</a>
<a name="ln2240">			error = bus_dmamap_create(sc-&gt;sc_buf_dtag, 0,</a>
<a name="ln2241">						  &amp;tbd-&gt;tbd_buf[j].tb_dmap);</a>
<a name="ln2242">			if (error) {</a>
<a name="ln2243">				device_printf(sc-&gt;sc_dev, &quot;can't create &quot;</a>
<a name="ln2244">					      &quot;%dth tbd, %dth DMA map\n&quot;, i, j);</a>
<a name="ln2245"> </a>
<a name="ln2246">				ntx = i;</a>
<a name="ln2247">				for (k = 0; k &lt; j; ++k) {</a>
<a name="ln2248">					bus_dmamap_destroy(sc-&gt;sc_buf_dtag,</a>
<a name="ln2249">						tbd-&gt;tbd_buf[k].tb_dmap);</a>
<a name="ln2250">				}</a>
<a name="ln2251">				goto fail;</a>
<a name="ln2252">			}</a>
<a name="ln2253">		}</a>
<a name="ln2254">	}</a>
<a name="ln2255">	ntx = BWI_TX_NRING;</a>
<a name="ln2256"> </a>
<a name="ln2257">	/*</a>
<a name="ln2258">	 * Create RX mbuf DMA map and a spare DMA map</a>
<a name="ln2259">	 */</a>
<a name="ln2260">	error = bus_dmamap_create(sc-&gt;sc_buf_dtag, 0,</a>
<a name="ln2261">				  &amp;rbd-&gt;rbd_tmp_dmap);</a>
<a name="ln2262">	if (error) {</a>
<a name="ln2263">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln2264">			      &quot;can't create spare RX buf DMA map\n&quot;);</a>
<a name="ln2265">		goto fail;</a>
<a name="ln2266">	}</a>
<a name="ln2267"> </a>
<a name="ln2268">	for (j = 0; j &lt; BWI_RX_NDESC; ++j) {</a>
<a name="ln2269">		error = bus_dmamap_create(sc-&gt;sc_buf_dtag, 0,</a>
<a name="ln2270">					  &amp;rbd-&gt;rbd_buf[j].rb_dmap);</a>
<a name="ln2271">		if (error) {</a>
<a name="ln2272">			device_printf(sc-&gt;sc_dev, &quot;can't create %dth &quot;</a>
<a name="ln2273">				      &quot;RX buf DMA map\n&quot;, j);</a>
<a name="ln2274"> </a>
<a name="ln2275">			for (k = 0; k &lt; j; ++k) {</a>
<a name="ln2276">				bus_dmamap_destroy(sc-&gt;sc_buf_dtag,</a>
<a name="ln2277">					rbd-&gt;rbd_buf[j].rb_dmap);</a>
<a name="ln2278">			}</a>
<a name="ln2279">			bus_dmamap_destroy(sc-&gt;sc_buf_dtag,</a>
<a name="ln2280">					   rbd-&gt;rbd_tmp_dmap);</a>
<a name="ln2281">			goto fail;</a>
<a name="ln2282">		}</a>
<a name="ln2283">	}</a>
<a name="ln2284"> </a>
<a name="ln2285">	return 0;</a>
<a name="ln2286">fail:</a>
<a name="ln2287">	bwi_dma_mbuf_destroy(sc, ntx, 0);</a>
<a name="ln2288">	return error;</a>
<a name="ln2289">}</a>
<a name="ln2290"> </a>
<a name="ln2291">static void</a>
<a name="ln2292">bwi_dma_mbuf_destroy(struct bwi_softc *sc, int ntx, int nrx)</a>
<a name="ln2293">{</a>
<a name="ln2294">	int i, j;</a>
<a name="ln2295"> </a>
<a name="ln2296">	if (sc-&gt;sc_buf_dtag == NULL)</a>
<a name="ln2297">		return;</a>
<a name="ln2298"> </a>
<a name="ln2299">	for (i = 0; i &lt; ntx; ++i) {</a>
<a name="ln2300">		struct bwi_txbuf_data *tbd = &amp;sc-&gt;sc_tx_bdata[i];</a>
<a name="ln2301"> </a>
<a name="ln2302">		for (j = 0; j &lt; BWI_TX_NDESC; ++j) {</a>
<a name="ln2303">			struct bwi_txbuf *tb = &amp;tbd-&gt;tbd_buf[j];</a>
<a name="ln2304"> </a>
<a name="ln2305">			if (tb-&gt;tb_mbuf != NULL) {</a>
<a name="ln2306">				bus_dmamap_unload(sc-&gt;sc_buf_dtag,</a>
<a name="ln2307">						  tb-&gt;tb_dmap);</a>
<a name="ln2308">				m_freem(tb-&gt;tb_mbuf);</a>
<a name="ln2309">			}</a>
<a name="ln2310">			if (tb-&gt;tb_ni != NULL)</a>
<a name="ln2311">				ieee80211_free_node(tb-&gt;tb_ni);</a>
<a name="ln2312">			bus_dmamap_destroy(sc-&gt;sc_buf_dtag, tb-&gt;tb_dmap);</a>
<a name="ln2313">		}</a>
<a name="ln2314">	}</a>
<a name="ln2315"> </a>
<a name="ln2316">	if (nrx) {</a>
<a name="ln2317">		struct bwi_rxbuf_data *rbd = &amp;sc-&gt;sc_rx_bdata;</a>
<a name="ln2318"> </a>
<a name="ln2319">		bus_dmamap_destroy(sc-&gt;sc_buf_dtag, rbd-&gt;rbd_tmp_dmap);</a>
<a name="ln2320">		for (j = 0; j &lt; BWI_RX_NDESC; ++j) {</a>
<a name="ln2321">			struct bwi_rxbuf *rb = &amp;rbd-&gt;rbd_buf[j];</a>
<a name="ln2322"> </a>
<a name="ln2323">			if (rb-&gt;rb_mbuf != NULL) {</a>
<a name="ln2324">				bus_dmamap_unload(sc-&gt;sc_buf_dtag,</a>
<a name="ln2325">						  rb-&gt;rb_dmap);</a>
<a name="ln2326">				m_freem(rb-&gt;rb_mbuf);</a>
<a name="ln2327">			}</a>
<a name="ln2328">			bus_dmamap_destroy(sc-&gt;sc_buf_dtag, rb-&gt;rb_dmap);</a>
<a name="ln2329">		}</a>
<a name="ln2330">	}</a>
<a name="ln2331"> </a>
<a name="ln2332">	bus_dma_tag_destroy(sc-&gt;sc_buf_dtag);</a>
<a name="ln2333">	sc-&gt;sc_buf_dtag = NULL;</a>
<a name="ln2334">}</a>
<a name="ln2335"> </a>
<a name="ln2336">static void</a>
<a name="ln2337">bwi_enable_intrs(struct bwi_softc *sc, uint32_t enable_intrs)</a>
<a name="ln2338">{</a>
<a name="ln2339">	CSR_SETBITS_4(sc, BWI_MAC_INTR_MASK, enable_intrs);</a>
<a name="ln2340">}</a>
<a name="ln2341"> </a>
<a name="ln2342">static void</a>
<a name="ln2343">bwi_disable_intrs(struct bwi_softc *sc, uint32_t disable_intrs)</a>
<a name="ln2344">{</a>
<a name="ln2345">	CSR_CLRBITS_4(sc, BWI_MAC_INTR_MASK, disable_intrs);</a>
<a name="ln2346">}</a>
<a name="ln2347"> </a>
<a name="ln2348">static int</a>
<a name="ln2349">bwi_init_tx_ring32(struct bwi_softc *sc, int ring_idx)</a>
<a name="ln2350">{</a>
<a name="ln2351">	struct bwi_ring_data *rd;</a>
<a name="ln2352">	struct bwi_txbuf_data *tbd;</a>
<a name="ln2353">	uint32_t val, addr_hi, addr_lo;</a>
<a name="ln2354"> </a>
<a name="ln2355">	KASSERT(ring_idx &lt; BWI_TX_NRING, (&quot;ring_idx %d&quot;, ring_idx));</a>
<a name="ln2356">	rd = &amp;sc-&gt;sc_tx_rdata[ring_idx];</a>
<a name="ln2357">	tbd = &amp;sc-&gt;sc_tx_bdata[ring_idx];</a>
<a name="ln2358"> </a>
<a name="ln2359">	tbd-&gt;tbd_idx = 0;</a>
<a name="ln2360">	tbd-&gt;tbd_used = 0;</a>
<a name="ln2361"> </a>
<a name="ln2362">	bzero(rd-&gt;rdata_desc, sizeof(struct bwi_desc32) * BWI_TX_NDESC);</a>
<a name="ln2363">	bus_dmamap_sync(sc-&gt;sc_txring_dtag, rd-&gt;rdata_dmap,</a>
<a name="ln2364">			BUS_DMASYNC_PREWRITE);</a>
<a name="ln2365"> </a>
<a name="ln2366">	addr_lo = __SHIFTOUT(rd-&gt;rdata_paddr, BWI_TXRX32_RINGINFO_ADDR_MASK);</a>
<a name="ln2367">	addr_hi = __SHIFTOUT(rd-&gt;rdata_paddr, BWI_TXRX32_RINGINFO_FUNC_MASK);</a>
<a name="ln2368"> </a>
<a name="ln2369">	val = __SHIFTIN(addr_lo, BWI_TXRX32_RINGINFO_ADDR_MASK) |</a>
<a name="ln2370">	      __SHIFTIN(BWI_TXRX32_RINGINFO_FUNC_TXRX,</a>
<a name="ln2371">	      		BWI_TXRX32_RINGINFO_FUNC_MASK);</a>
<a name="ln2372">	CSR_WRITE_4(sc, rd-&gt;rdata_txrx_ctrl + BWI_TX32_RINGINFO, val);</a>
<a name="ln2373"> </a>
<a name="ln2374">	val = __SHIFTIN(addr_hi, BWI_TXRX32_CTRL_ADDRHI_MASK) |</a>
<a name="ln2375">	      BWI_TXRX32_CTRL_ENABLE;</a>
<a name="ln2376">	CSR_WRITE_4(sc, rd-&gt;rdata_txrx_ctrl + BWI_TX32_CTRL, val);</a>
<a name="ln2377"> </a>
<a name="ln2378">	return 0;</a>
<a name="ln2379">}</a>
<a name="ln2380"> </a>
<a name="ln2381">static void</a>
<a name="ln2382">bwi_init_rxdesc_ring32(struct bwi_softc *sc, uint32_t ctrl_base,</a>
<a name="ln2383">		       bus_addr_t paddr, int hdr_size, int ndesc)</a>
<a name="ln2384">{</a>
<a name="ln2385">	uint32_t val, addr_hi, addr_lo;</a>
<a name="ln2386"> </a>
<a name="ln2387">	addr_lo = __SHIFTOUT(paddr, BWI_TXRX32_RINGINFO_ADDR_MASK);</a>
<a name="ln2388">	addr_hi = __SHIFTOUT(paddr, BWI_TXRX32_RINGINFO_FUNC_MASK);</a>
<a name="ln2389"> </a>
<a name="ln2390">	val = __SHIFTIN(addr_lo, BWI_TXRX32_RINGINFO_ADDR_MASK) |</a>
<a name="ln2391">	      __SHIFTIN(BWI_TXRX32_RINGINFO_FUNC_TXRX,</a>
<a name="ln2392">	      		BWI_TXRX32_RINGINFO_FUNC_MASK);</a>
<a name="ln2393">	CSR_WRITE_4(sc, ctrl_base + BWI_RX32_RINGINFO, val);</a>
<a name="ln2394"> </a>
<a name="ln2395">	val = __SHIFTIN(hdr_size, BWI_RX32_CTRL_HDRSZ_MASK) |</a>
<a name="ln2396">	      __SHIFTIN(addr_hi, BWI_TXRX32_CTRL_ADDRHI_MASK) |</a>
<a name="ln2397">	      BWI_TXRX32_CTRL_ENABLE;</a>
<a name="ln2398">	CSR_WRITE_4(sc, ctrl_base + BWI_RX32_CTRL, val);</a>
<a name="ln2399"> </a>
<a name="ln2400">	CSR_WRITE_4(sc, ctrl_base + BWI_RX32_INDEX,</a>
<a name="ln2401">		    (ndesc - 1) * sizeof(struct bwi_desc32));</a>
<a name="ln2402">}</a>
<a name="ln2403"> </a>
<a name="ln2404">static int</a>
<a name="ln2405">bwi_init_rx_ring32(struct bwi_softc *sc)</a>
<a name="ln2406">{</a>
<a name="ln2407">	struct bwi_ring_data *rd = &amp;sc-&gt;sc_rx_rdata;</a>
<a name="ln2408">	int i, error;</a>
<a name="ln2409"> </a>
<a name="ln2410">	sc-&gt;sc_rx_bdata.rbd_idx = 0;</a>
<a name="ln2411"> </a>
<a name="ln2412">	for (i = 0; i &lt; BWI_RX_NDESC; ++i) {</a>
<a name="ln2413">		error = bwi_newbuf(sc, i, 1);</a>
<a name="ln2414">		if (error) {</a>
<a name="ln2415">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln2416">				  &quot;can't allocate %dth RX buffer\n&quot;, i);</a>
<a name="ln2417">			return error;</a>
<a name="ln2418">		}</a>
<a name="ln2419">	}</a>
<a name="ln2420">	bus_dmamap_sync(sc-&gt;sc_rxring_dtag, rd-&gt;rdata_dmap,</a>
<a name="ln2421">			BUS_DMASYNC_PREWRITE);</a>
<a name="ln2422"> </a>
<a name="ln2423">	bwi_init_rxdesc_ring32(sc, rd-&gt;rdata_txrx_ctrl, rd-&gt;rdata_paddr,</a>
<a name="ln2424">			       sizeof(struct bwi_rxbuf_hdr), BWI_RX_NDESC);</a>
<a name="ln2425">	return 0;</a>
<a name="ln2426">}</a>
<a name="ln2427"> </a>
<a name="ln2428">static int</a>
<a name="ln2429">bwi_init_txstats32(struct bwi_softc *sc)</a>
<a name="ln2430">{</a>
<a name="ln2431">	struct bwi_txstats_data *st = sc-&gt;sc_txstats;</a>
<a name="ln2432">	bus_addr_t stats_paddr;</a>
<a name="ln2433">	int i;</a>
<a name="ln2434"> </a>
<a name="ln2435">	bzero(st-&gt;stats, BWI_TXSTATS_NDESC * sizeof(struct bwi_txstats));</a>
<a name="ln2436">	bus_dmamap_sync(st-&gt;stats_dtag, st-&gt;stats_dmap, BUS_DMASYNC_PREWRITE);</a>
<a name="ln2437"> </a>
<a name="ln2438">	st-&gt;stats_idx = 0;</a>
<a name="ln2439"> </a>
<a name="ln2440">	stats_paddr = st-&gt;stats_paddr;</a>
<a name="ln2441">	for (i = 0; i &lt; BWI_TXSTATS_NDESC; ++i) {</a>
<a name="ln2442">		bwi_setup_desc32(sc, st-&gt;stats_ring, BWI_TXSTATS_NDESC, i,</a>
<a name="ln2443">				 stats_paddr, sizeof(struct bwi_txstats), 0);</a>
<a name="ln2444">		stats_paddr += sizeof(struct bwi_txstats);</a>
<a name="ln2445">	}</a>
<a name="ln2446">	bus_dmamap_sync(st-&gt;stats_ring_dtag, st-&gt;stats_ring_dmap,</a>
<a name="ln2447">			BUS_DMASYNC_PREWRITE);</a>
<a name="ln2448"> </a>
<a name="ln2449">	bwi_init_rxdesc_ring32(sc, st-&gt;stats_ctrl_base,</a>
<a name="ln2450">			       st-&gt;stats_ring_paddr, 0, BWI_TXSTATS_NDESC);</a>
<a name="ln2451">	return 0;</a>
<a name="ln2452">}</a>
<a name="ln2453"> </a>
<a name="ln2454">static void</a>
<a name="ln2455">bwi_setup_rx_desc32(struct bwi_softc *sc, int buf_idx, bus_addr_t paddr,</a>
<a name="ln2456">		    int buf_len)</a>
<a name="ln2457">{</a>
<a name="ln2458">	struct bwi_ring_data *rd = &amp;sc-&gt;sc_rx_rdata;</a>
<a name="ln2459"> </a>
<a name="ln2460">	KASSERT(buf_idx &lt; BWI_RX_NDESC, (&quot;buf_idx %d&quot;, buf_idx));</a>
<a name="ln2461">	bwi_setup_desc32(sc, rd-&gt;rdata_desc, BWI_RX_NDESC, buf_idx,</a>
<a name="ln2462">			 paddr, buf_len, 0);</a>
<a name="ln2463">}</a>
<a name="ln2464"> </a>
<a name="ln2465">static void</a>
<a name="ln2466">bwi_setup_tx_desc32(struct bwi_softc *sc, struct bwi_ring_data *rd,</a>
<a name="ln2467">		    int buf_idx, bus_addr_t paddr, int buf_len)</a>
<a name="ln2468">{</a>
<a name="ln2469">	KASSERT(buf_idx &lt; BWI_TX_NDESC, (&quot;buf_idx %d&quot;, buf_idx));</a>
<a name="ln2470">	bwi_setup_desc32(sc, rd-&gt;rdata_desc, BWI_TX_NDESC, buf_idx,</a>
<a name="ln2471">			 paddr, buf_len, 1);</a>
<a name="ln2472">}</a>
<a name="ln2473"> </a>
<a name="ln2474">static int</a>
<a name="ln2475">bwi_init_tx_ring64(struct bwi_softc *sc, int ring_idx)</a>
<a name="ln2476">{</a>
<a name="ln2477">	/* TODO:64 */</a>
<a name="ln2478">	return EOPNOTSUPP;</a>
<a name="ln2479">}</a>
<a name="ln2480"> </a>
<a name="ln2481">static int</a>
<a name="ln2482">bwi_init_rx_ring64(struct bwi_softc *sc)</a>
<a name="ln2483">{</a>
<a name="ln2484">	/* TODO:64 */</a>
<a name="ln2485">	return EOPNOTSUPP;</a>
<a name="ln2486">}</a>
<a name="ln2487"> </a>
<a name="ln2488">static int</a>
<a name="ln2489">bwi_init_txstats64(struct bwi_softc *sc)</a>
<a name="ln2490">{</a>
<a name="ln2491">	/* TODO:64 */</a>
<a name="ln2492">	return EOPNOTSUPP;</a>
<a name="ln2493">}</a>
<a name="ln2494"> </a>
<a name="ln2495">static void</a>
<a name="ln2496">bwi_setup_rx_desc64(struct bwi_softc *sc, int buf_idx, bus_addr_t paddr,</a>
<a name="ln2497">		    int buf_len)</a>
<a name="ln2498">{</a>
<a name="ln2499">	/* TODO:64 */</a>
<a name="ln2500">}</a>
<a name="ln2501"> </a>
<a name="ln2502">static void</a>
<a name="ln2503">bwi_setup_tx_desc64(struct bwi_softc *sc, struct bwi_ring_data *rd,</a>
<a name="ln2504">		    int buf_idx, bus_addr_t paddr, int buf_len)</a>
<a name="ln2505">{</a>
<a name="ln2506">	/* TODO:64 */</a>
<a name="ln2507">}</a>
<a name="ln2508"> </a>
<a name="ln2509">static void</a>
<a name="ln2510">bwi_dma_buf_addr(void *arg, bus_dma_segment_t *seg, int nseg,</a>
<a name="ln2511">		 bus_size_t mapsz __unused, int error)</a>
<a name="ln2512">{</a>
<a name="ln2513">        if (!error) {</a>
<a name="ln2514">		KASSERT(nseg == 1, (&quot;too many segments(%d)\n&quot;, nseg));</a>
<a name="ln2515">		*((bus_addr_t *)arg) = seg-&gt;ds_addr;</a>
<a name="ln2516">	}</a>
<a name="ln2517">}</a>
<a name="ln2518"> </a>
<a name="ln2519">static int</a>
<a name="ln2520">bwi_newbuf(struct bwi_softc *sc, int buf_idx, int init)</a>
<a name="ln2521">{</a>
<a name="ln2522">	struct bwi_rxbuf_data *rbd = &amp;sc-&gt;sc_rx_bdata;</a>
<a name="ln2523">	struct bwi_rxbuf *rxbuf = &amp;rbd-&gt;rbd_buf[buf_idx];</a>
<a name="ln2524">	struct bwi_rxbuf_hdr *hdr;</a>
<a name="ln2525">	bus_dmamap_t map;</a>
<a name="ln2526">	bus_addr_t paddr;</a>
<a name="ln2527">	struct mbuf *m;</a>
<a name="ln2528">	int error;</a>
<a name="ln2529"> </a>
<a name="ln2530">	KASSERT(buf_idx &lt; BWI_RX_NDESC, (&quot;buf_idx %d&quot;, buf_idx));</a>
<a name="ln2531"> </a>
<a name="ln2532">	m = m_getcl(M_NOWAIT, MT_DATA, M_PKTHDR);</a>
<a name="ln2533">	if (m == NULL) {</a>
<a name="ln2534">		error = ENOBUFS;</a>
<a name="ln2535"> </a>
<a name="ln2536">		/*</a>
<a name="ln2537">		 * If the NIC is up and running, we need to:</a>
<a name="ln2538">		 * - Clear RX buffer's header.</a>
<a name="ln2539">		 * - Restore RX descriptor settings.</a>
<a name="ln2540">		 */</a>
<a name="ln2541">		if (init)</a>
<a name="ln2542">			return error;</a>
<a name="ln2543">		else</a>
<a name="ln2544">			goto back;</a>
<a name="ln2545">	}</a>
<a name="ln2546">	m-&gt;m_len = m-&gt;m_pkthdr.len = MCLBYTES;</a>
<a name="ln2547"> </a>
<a name="ln2548">	/*</a>
<a name="ln2549">	 * Try to load RX buf into temporary DMA map</a>
<a name="ln2550">	 */</a>
<a name="ln2551">	error = bus_dmamap_load_mbuf(sc-&gt;sc_buf_dtag, rbd-&gt;rbd_tmp_dmap, m,</a>
<a name="ln2552">				     bwi_dma_buf_addr, &amp;paddr, BUS_DMA_NOWAIT);</a>
<a name="ln2553">	if (error) {</a>
<a name="ln2554">		m_freem(m);</a>
<a name="ln2555"> </a>
<a name="ln2556">		/*</a>
<a name="ln2557">		 * See the comment above</a>
<a name="ln2558">		 */</a>
<a name="ln2559">		if (init)</a>
<a name="ln2560">			return error;</a>
<a name="ln2561">		else</a>
<a name="ln2562">			goto back;</a>
<a name="ln2563">	}</a>
<a name="ln2564"> </a>
<a name="ln2565">	if (!init)</a>
<a name="ln2566">		bus_dmamap_unload(sc-&gt;sc_buf_dtag, rxbuf-&gt;rb_dmap);</a>
<a name="ln2567">	rxbuf-&gt;rb_mbuf = m;</a>
<a name="ln2568">	rxbuf-&gt;rb_paddr = paddr;</a>
<a name="ln2569"> </a>
<a name="ln2570">	/*</a>
<a name="ln2571">	 * Swap RX buf's DMA map with the loaded temporary one</a>
<a name="ln2572">	 */</a>
<a name="ln2573">	map = rxbuf-&gt;rb_dmap;</a>
<a name="ln2574">	rxbuf-&gt;rb_dmap = rbd-&gt;rbd_tmp_dmap;</a>
<a name="ln2575">	rbd-&gt;rbd_tmp_dmap = map;</a>
<a name="ln2576"> </a>
<a name="ln2577">back:</a>
<a name="ln2578">	/*</a>
<a name="ln2579">	 * Clear RX buf header</a>
<a name="ln2580">	 */</a>
<a name="ln2581">	hdr = mtod(rxbuf-&gt;rb_mbuf, struct bwi_rxbuf_hdr *);</a>
<a name="ln2582">	bzero(hdr, sizeof(*hdr));</a>
<a name="ln2583">	bus_dmamap_sync(sc-&gt;sc_buf_dtag, rxbuf-&gt;rb_dmap, BUS_DMASYNC_PREWRITE);</a>
<a name="ln2584"> </a>
<a name="ln2585">	/*</a>
<a name="ln2586">	 * Setup RX buf descriptor</a>
<a name="ln2587">	 */</a>
<a name="ln2588">	sc-&gt;sc_setup_rxdesc(sc, buf_idx, rxbuf-&gt;rb_paddr,</a>
<a name="ln2589">			    rxbuf-&gt;rb_mbuf-&gt;m_len - sizeof(*hdr));</a>
<a name="ln2590">	return error;</a>
<a name="ln2591">}</a>
<a name="ln2592"> </a>
<a name="ln2593">static void</a>
<a name="ln2594">bwi_set_addr_filter(struct bwi_softc *sc, uint16_t addr_ofs,</a>
<a name="ln2595">		    const uint8_t *addr)</a>
<a name="ln2596">{</a>
<a name="ln2597">	int i;</a>
<a name="ln2598"> </a>
<a name="ln2599">	CSR_WRITE_2(sc, BWI_ADDR_FILTER_CTRL,</a>
<a name="ln2600">		    BWI_ADDR_FILTER_CTRL_SET | addr_ofs);</a>
<a name="ln2601"> </a>
<a name="ln2602">	for (i = 0; i &lt; (IEEE80211_ADDR_LEN / 2); ++i) {</a>
<a name="ln2603">		uint16_t addr_val;</a>
<a name="ln2604"> </a>
<a name="ln2605">		addr_val = (uint16_t)addr[i * 2] |</a>
<a name="ln2606">			   (((uint16_t)addr[(i * 2) + 1]) &lt;&lt; 8);</a>
<a name="ln2607">		CSR_WRITE_2(sc, BWI_ADDR_FILTER_DATA, addr_val);</a>
<a name="ln2608">	}</a>
<a name="ln2609">}</a>
<a name="ln2610"> </a>
<a name="ln2611">static int</a>
<a name="ln2612">bwi_rxeof(struct bwi_softc *sc, int end_idx)</a>
<a name="ln2613">{</a>
<a name="ln2614">	struct bwi_ring_data *rd = &amp;sc-&gt;sc_rx_rdata;</a>
<a name="ln2615">	struct bwi_rxbuf_data *rbd = &amp;sc-&gt;sc_rx_bdata;</a>
<a name="ln2616">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln2617">	int idx, rx_data = 0;</a>
<a name="ln2618"> </a>
<a name="ln2619">	idx = rbd-&gt;rbd_idx;</a>
<a name="ln2620">	while (idx != end_idx) {</a>
<a name="ln2621">		struct bwi_rxbuf *rb = &amp;rbd-&gt;rbd_buf[idx];</a>
<a name="ln2622">		struct bwi_rxbuf_hdr *hdr;</a>
<a name="ln2623">		struct ieee80211_frame_min *wh;</a>
<a name="ln2624">		struct ieee80211_node *ni;</a>
<a name="ln2625">		struct mbuf *m;</a>
<a name="ln2626">		uint32_t plcp;</a>
<a name="ln2627">		uint16_t flags2;</a>
<a name="ln2628">		int buflen, wh_ofs, hdr_extra, rssi, noise, type, rate;</a>
<a name="ln2629"> </a>
<a name="ln2630">		m = rb-&gt;rb_mbuf;</a>
<a name="ln2631">		bus_dmamap_sync(sc-&gt;sc_buf_dtag, rb-&gt;rb_dmap,</a>
<a name="ln2632">				BUS_DMASYNC_POSTREAD);</a>
<a name="ln2633"> </a>
<a name="ln2634">		if (bwi_newbuf(sc, idx, 0)) {</a>
<a name="ln2635">			counter_u64_add(ic-&gt;ic_ierrors, 1);</a>
<a name="ln2636">			goto next;</a>
<a name="ln2637">		}</a>
<a name="ln2638"> </a>
<a name="ln2639">		hdr = mtod(m, struct bwi_rxbuf_hdr *);</a>
<a name="ln2640">		flags2 = le16toh(hdr-&gt;rxh_flags2);</a>
<a name="ln2641"> </a>
<a name="ln2642">		hdr_extra = 0;</a>
<a name="ln2643">		if (flags2 &amp; BWI_RXH_F2_TYPE2FRAME)</a>
<a name="ln2644">			hdr_extra = 2;</a>
<a name="ln2645">		wh_ofs = hdr_extra + 6;	/* XXX magic number */</a>
<a name="ln2646"> </a>
<a name="ln2647">		buflen = le16toh(hdr-&gt;rxh_buflen);</a>
<a name="ln2648">		if (buflen &lt; BWI_FRAME_MIN_LEN(wh_ofs)) {</a>
<a name="ln2649">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln2650">			    &quot;%s: zero length data, hdr_extra %d\n&quot;,</a>
<a name="ln2651">			    __func__, hdr_extra);</a>
<a name="ln2652">			counter_u64_add(ic-&gt;ic_ierrors, 1);</a>
<a name="ln2653">			m_freem(m);</a>
<a name="ln2654">			goto next;</a>
<a name="ln2655">		}</a>
<a name="ln2656"> </a>
<a name="ln2657">	        bcopy((uint8_t *)(hdr + 1) + hdr_extra, &amp;plcp, sizeof(plcp));	</a>
<a name="ln2658">		rssi = bwi_calc_rssi(sc, hdr);</a>
<a name="ln2659">		noise = bwi_calc_noise(sc);</a>
<a name="ln2660"> </a>
<a name="ln2661">		m-&gt;m_len = m-&gt;m_pkthdr.len = buflen + sizeof(*hdr);</a>
<a name="ln2662">		m_adj(m, sizeof(*hdr) + wh_ofs);</a>
<a name="ln2663"> </a>
<a name="ln2664">		if (htole16(hdr-&gt;rxh_flags1) &amp; BWI_RXH_F1_OFDM)</a>
<a name="ln2665">			rate = bwi_plcp2rate(plcp, IEEE80211_T_OFDM);</a>
<a name="ln2666">		else</a>
<a name="ln2667">			rate = bwi_plcp2rate(plcp, IEEE80211_T_CCK);</a>
<a name="ln2668"> </a>
<a name="ln2669">		/* RX radio tap */</a>
<a name="ln2670">		if (ieee80211_radiotap_active(ic))</a>
<a name="ln2671">			bwi_rx_radiotap(sc, m, hdr, &amp;plcp, rate, rssi, noise);</a>
<a name="ln2672"> </a>
<a name="ln2673">		m_adj(m, -IEEE80211_CRC_LEN);</a>
<a name="ln2674"> </a>
<a name="ln2675">		BWI_UNLOCK(sc);</a>
<a name="ln2676"> </a>
<a name="ln2677">		wh = mtod(m, struct ieee80211_frame_min *);</a>
<a name="ln2678">		ni = ieee80211_find_rxnode(ic, wh);</a>
<a name="ln2679">		if (ni != NULL) {</a>
<a name="ln2680">			type = ieee80211_input(ni, m, rssi - noise, noise);</a>
<a name="ln2681">			ieee80211_free_node(ni);</a>
<a name="ln2682">		} else</a>
<a name="ln2683">			type = ieee80211_input_all(ic, m, rssi - noise, noise);</a>
<a name="ln2684">		if (type == IEEE80211_FC0_TYPE_DATA) {</a>
<a name="ln2685">			rx_data = 1;</a>
<a name="ln2686">			sc-&gt;sc_rx_rate = rate;</a>
<a name="ln2687">		}</a>
<a name="ln2688"> </a>
<a name="ln2689">		BWI_LOCK(sc);</a>
<a name="ln2690">next:</a>
<a name="ln2691">		idx = (idx + 1) % BWI_RX_NDESC;</a>
<a name="ln2692"> </a>
<a name="ln2693">		if (sc-&gt;sc_flags &amp; BWI_F_STOP) {</a>
<a name="ln2694">			/*</a>
<a name="ln2695">			 * Take the fast lane, don't do</a>
<a name="ln2696">			 * any damage to softc</a>
<a name="ln2697">			 */</a>
<a name="ln2698">			return -1;</a>
<a name="ln2699">		}</a>
<a name="ln2700">	}</a>
<a name="ln2701"> </a>
<a name="ln2702">	rbd-&gt;rbd_idx = idx;</a>
<a name="ln2703">	bus_dmamap_sync(sc-&gt;sc_rxring_dtag, rd-&gt;rdata_dmap,</a>
<a name="ln2704">			BUS_DMASYNC_PREWRITE);</a>
<a name="ln2705"> </a>
<a name="ln2706">	return rx_data;</a>
<a name="ln2707">}</a>
<a name="ln2708"> </a>
<a name="ln2709">static int</a>
<a name="ln2710">bwi_rxeof32(struct bwi_softc *sc)</a>
<a name="ln2711">{</a>
<a name="ln2712">	uint32_t val, rx_ctrl;</a>
<a name="ln2713">	int end_idx, rx_data;</a>
<a name="ln2714"> </a>
<a name="ln2715">	rx_ctrl = sc-&gt;sc_rx_rdata.rdata_txrx_ctrl;</a>
<a name="ln2716"> </a>
<a name="ln2717">	val = CSR_READ_4(sc, rx_ctrl + BWI_RX32_STATUS);</a>
<a name="ln2718">	end_idx = __SHIFTOUT(val, BWI_RX32_STATUS_INDEX_MASK) /</a>
<a name="ln2719">		  sizeof(struct bwi_desc32);</a>
<a name="ln2720"> </a>
<a name="ln2721">	rx_data = bwi_rxeof(sc, end_idx);</a>
<a name="ln2722">	if (rx_data &gt;= 0) {</a>
<a name="ln2723">		CSR_WRITE_4(sc, rx_ctrl + BWI_RX32_INDEX,</a>
<a name="ln2724">			    end_idx * sizeof(struct bwi_desc32));</a>
<a name="ln2725">	}</a>
<a name="ln2726">	return rx_data;</a>
<a name="ln2727">}</a>
<a name="ln2728"> </a>
<a name="ln2729">static int</a>
<a name="ln2730">bwi_rxeof64(struct bwi_softc *sc)</a>
<a name="ln2731">{</a>
<a name="ln2732">	/* TODO:64 */</a>
<a name="ln2733">	return 0;</a>
<a name="ln2734">}</a>
<a name="ln2735"> </a>
<a name="ln2736">static void</a>
<a name="ln2737">bwi_reset_rx_ring32(struct bwi_softc *sc, uint32_t rx_ctrl)</a>
<a name="ln2738">{</a>
<a name="ln2739">	int i;</a>
<a name="ln2740"> </a>
<a name="ln2741">	CSR_WRITE_4(sc, rx_ctrl + BWI_RX32_CTRL, 0);</a>
<a name="ln2742"> </a>
<a name="ln2743">#define NRETRY 10</a>
<a name="ln2744"> </a>
<a name="ln2745">	for (i = 0; i &lt; NRETRY; ++i) {</a>
<a name="ln2746">		uint32_t status;</a>
<a name="ln2747"> </a>
<a name="ln2748">		status = CSR_READ_4(sc, rx_ctrl + BWI_RX32_STATUS);</a>
<a name="ln2749">		if (__SHIFTOUT(status, BWI_RX32_STATUS_STATE_MASK) ==</a>
<a name="ln2750">		    BWI_RX32_STATUS_STATE_DISABLED)</a>
<a name="ln2751">			break;</a>
<a name="ln2752"> </a>
<a name="ln2753">		DELAY(1000);</a>
<a name="ln2754">	}</a>
<a name="ln2755">	if (i == NRETRY)</a>
<a name="ln2756">		device_printf(sc-&gt;sc_dev, &quot;reset rx ring timedout\n&quot;);</a>
<a name="ln2757"> </a>
<a name="ln2758">#undef NRETRY</a>
<a name="ln2759"> </a>
<a name="ln2760">	CSR_WRITE_4(sc, rx_ctrl + BWI_RX32_RINGINFO, 0);</a>
<a name="ln2761">}</a>
<a name="ln2762"> </a>
<a name="ln2763">static void</a>
<a name="ln2764">bwi_free_txstats32(struct bwi_softc *sc)</a>
<a name="ln2765">{</a>
<a name="ln2766">	bwi_reset_rx_ring32(sc, sc-&gt;sc_txstats-&gt;stats_ctrl_base);</a>
<a name="ln2767">}</a>
<a name="ln2768"> </a>
<a name="ln2769">static void</a>
<a name="ln2770">bwi_free_rx_ring32(struct bwi_softc *sc)</a>
<a name="ln2771">{</a>
<a name="ln2772">	struct bwi_ring_data *rd = &amp;sc-&gt;sc_rx_rdata;</a>
<a name="ln2773">	struct bwi_rxbuf_data *rbd = &amp;sc-&gt;sc_rx_bdata;</a>
<a name="ln2774">	int i;</a>
<a name="ln2775"> </a>
<a name="ln2776">	bwi_reset_rx_ring32(sc, rd-&gt;rdata_txrx_ctrl);</a>
<a name="ln2777"> </a>
<a name="ln2778">	for (i = 0; i &lt; BWI_RX_NDESC; ++i) {</a>
<a name="ln2779">		struct bwi_rxbuf *rb = &amp;rbd-&gt;rbd_buf[i];</a>
<a name="ln2780"> </a>
<a name="ln2781">		if (rb-&gt;rb_mbuf != NULL) {</a>
<a name="ln2782">			bus_dmamap_unload(sc-&gt;sc_buf_dtag, rb-&gt;rb_dmap);</a>
<a name="ln2783">			m_freem(rb-&gt;rb_mbuf);</a>
<a name="ln2784">			rb-&gt;rb_mbuf = NULL;</a>
<a name="ln2785">		}</a>
<a name="ln2786">	}</a>
<a name="ln2787">}</a>
<a name="ln2788"> </a>
<a name="ln2789">static void</a>
<a name="ln2790">bwi_free_tx_ring32(struct bwi_softc *sc, int ring_idx)</a>
<a name="ln2791">{</a>
<a name="ln2792">	struct bwi_ring_data *rd;</a>
<a name="ln2793">	struct bwi_txbuf_data *tbd;</a>
<a name="ln2794">	uint32_t state, val;</a>
<a name="ln2795">	int i;</a>
<a name="ln2796"> </a>
<a name="ln2797">	KASSERT(ring_idx &lt; BWI_TX_NRING, (&quot;ring_idx %d&quot;, ring_idx));</a>
<a name="ln2798">	rd = &amp;sc-&gt;sc_tx_rdata[ring_idx];</a>
<a name="ln2799">	tbd = &amp;sc-&gt;sc_tx_bdata[ring_idx];</a>
<a name="ln2800"> </a>
<a name="ln2801">#define NRETRY 10</a>
<a name="ln2802"> </a>
<a name="ln2803">	for (i = 0; i &lt; NRETRY; ++i) {</a>
<a name="ln2804">		val = CSR_READ_4(sc, rd-&gt;rdata_txrx_ctrl + BWI_TX32_STATUS);</a>
<a name="ln2805">		state = __SHIFTOUT(val, BWI_TX32_STATUS_STATE_MASK);</a>
<a name="ln2806">		if (state == BWI_TX32_STATUS_STATE_DISABLED ||</a>
<a name="ln2807">		    state == BWI_TX32_STATUS_STATE_IDLE ||</a>
<a name="ln2808">		    state == BWI_TX32_STATUS_STATE_STOPPED)</a>
<a name="ln2809">			break;</a>
<a name="ln2810"> </a>
<a name="ln2811">		DELAY(1000);</a>
<a name="ln2812">	}</a>
<a name="ln2813">	if (i == NRETRY) {</a>
<a name="ln2814">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln2815">		    &quot;%s: wait for TX ring(%d) stable timed out\n&quot;,</a>
<a name="ln2816">		    __func__, ring_idx);</a>
<a name="ln2817">	}</a>
<a name="ln2818"> </a>
<a name="ln2819">	CSR_WRITE_4(sc, rd-&gt;rdata_txrx_ctrl + BWI_TX32_CTRL, 0);</a>
<a name="ln2820">	for (i = 0; i &lt; NRETRY; ++i) {</a>
<a name="ln2821">		val = CSR_READ_4(sc, rd-&gt;rdata_txrx_ctrl + BWI_TX32_STATUS);</a>
<a name="ln2822">		state = __SHIFTOUT(val, BWI_TX32_STATUS_STATE_MASK);</a>
<a name="ln2823">		if (state == BWI_TX32_STATUS_STATE_DISABLED)</a>
<a name="ln2824">			break;</a>
<a name="ln2825"> </a>
<a name="ln2826">		DELAY(1000);</a>
<a name="ln2827">	}</a>
<a name="ln2828">	if (i == NRETRY)</a>
<a name="ln2829">		device_printf(sc-&gt;sc_dev, &quot;%s: reset TX ring (%d) timed out\n&quot;,</a>
<a name="ln2830">		     __func__, ring_idx);</a>
<a name="ln2831"> </a>
<a name="ln2832">#undef NRETRY</a>
<a name="ln2833"> </a>
<a name="ln2834">	DELAY(1000);</a>
<a name="ln2835"> </a>
<a name="ln2836">	CSR_WRITE_4(sc, rd-&gt;rdata_txrx_ctrl + BWI_TX32_RINGINFO, 0);</a>
<a name="ln2837"> </a>
<a name="ln2838">	for (i = 0; i &lt; BWI_TX_NDESC; ++i) {</a>
<a name="ln2839">		struct bwi_txbuf *tb = &amp;tbd-&gt;tbd_buf[i];</a>
<a name="ln2840"> </a>
<a name="ln2841">		if (tb-&gt;tb_mbuf != NULL) {</a>
<a name="ln2842">			bus_dmamap_unload(sc-&gt;sc_buf_dtag, tb-&gt;tb_dmap);</a>
<a name="ln2843">			m_freem(tb-&gt;tb_mbuf);</a>
<a name="ln2844">			tb-&gt;tb_mbuf = NULL;</a>
<a name="ln2845">		}</a>
<a name="ln2846">		if (tb-&gt;tb_ni != NULL) {</a>
<a name="ln2847">			ieee80211_free_node(tb-&gt;tb_ni);</a>
<a name="ln2848">			tb-&gt;tb_ni = NULL;</a>
<a name="ln2849">		}</a>
<a name="ln2850">	}</a>
<a name="ln2851">}</a>
<a name="ln2852"> </a>
<a name="ln2853">static void</a>
<a name="ln2854">bwi_free_txstats64(struct bwi_softc *sc)</a>
<a name="ln2855">{</a>
<a name="ln2856">	/* TODO:64 */</a>
<a name="ln2857">}</a>
<a name="ln2858"> </a>
<a name="ln2859">static void</a>
<a name="ln2860">bwi_free_rx_ring64(struct bwi_softc *sc)</a>
<a name="ln2861">{</a>
<a name="ln2862">	/* TODO:64 */</a>
<a name="ln2863">}</a>
<a name="ln2864"> </a>
<a name="ln2865">static void</a>
<a name="ln2866">bwi_free_tx_ring64(struct bwi_softc *sc, int ring_idx)</a>
<a name="ln2867">{</a>
<a name="ln2868">	/* TODO:64 */</a>
<a name="ln2869">}</a>
<a name="ln2870"> </a>
<a name="ln2871">/* XXX does not belong here */</a>
<a name="ln2872">#define IEEE80211_OFDM_PLCP_RATE_MASK	__BITS(3, 0)</a>
<a name="ln2873">#define IEEE80211_OFDM_PLCP_LEN_MASK	__BITS(16, 5)</a>
<a name="ln2874"> </a>
<a name="ln2875">static __inline void</a>
<a name="ln2876">bwi_ofdm_plcp_header(uint32_t *plcp0, int pkt_len, uint8_t rate)</a>
<a name="ln2877">{</a>
<a name="ln2878">	uint32_t plcp;</a>
<a name="ln2879"> </a>
<a name="ln2880">	plcp = __SHIFTIN(ieee80211_rate2plcp(rate, IEEE80211_T_OFDM),</a>
<a name="ln2881">		    IEEE80211_OFDM_PLCP_RATE_MASK) |</a>
<a name="ln2882">	       __SHIFTIN(pkt_len, IEEE80211_OFDM_PLCP_LEN_MASK);</a>
<a name="ln2883">	*plcp0 = htole32(plcp);</a>
<a name="ln2884">}</a>
<a name="ln2885"> </a>
<a name="ln2886">static __inline void</a>
<a name="ln2887">bwi_ds_plcp_header(struct ieee80211_ds_plcp_hdr *plcp, int pkt_len,</a>
<a name="ln2888">		   uint8_t rate)</a>
<a name="ln2889">{</a>
<a name="ln2890">	int len, service, pkt_bitlen;</a>
<a name="ln2891"> </a>
<a name="ln2892">	pkt_bitlen = pkt_len * NBBY;</a>
<a name="ln2893">	len = howmany(pkt_bitlen * 2, rate);</a>
<a name="ln2894"> </a>
<a name="ln2895">	service = IEEE80211_PLCP_SERVICE_LOCKED;</a>
<a name="ln2896">	if (rate == (11 * 2)) {</a>
<a name="ln2897">		int pkt_bitlen1;</a>
<a name="ln2898"> </a>
<a name="ln2899">		/*</a>
<a name="ln2900">		 * PLCP service field needs to be adjusted,</a>
<a name="ln2901">		 * if TX rate is 11Mbytes/s</a>
<a name="ln2902">		 */</a>
<a name="ln2903">		pkt_bitlen1 = len * 11;</a>
<a name="ln2904">		if (pkt_bitlen1 - pkt_bitlen &gt;= NBBY)</a>
<a name="ln2905">			service |= IEEE80211_PLCP_SERVICE_LENEXT7;</a>
<a name="ln2906">	}</a>
<a name="ln2907"> </a>
<a name="ln2908">	plcp-&gt;i_signal = ieee80211_rate2plcp(rate, IEEE80211_T_CCK);</a>
<a name="ln2909">	plcp-&gt;i_service = service;</a>
<a name="ln2910">	plcp-&gt;i_length = htole16(len);</a>
<a name="ln2911">	/* NOTE: do NOT touch i_crc */</a>
<a name="ln2912">}</a>
<a name="ln2913"> </a>
<a name="ln2914">static __inline void</a>
<a name="ln2915">bwi_plcp_header(const struct ieee80211_rate_table *rt,</a>
<a name="ln2916">	void *plcp, int pkt_len, uint8_t rate)</a>
<a name="ln2917">{</a>
<a name="ln2918">	enum ieee80211_phytype modtype;</a>
<a name="ln2919"> </a>
<a name="ln2920">	/*</a>
<a name="ln2921">	 * Assume caller has zeroed 'plcp'</a>
<a name="ln2922">	 */</a>
<a name="ln2923">	modtype = ieee80211_rate2phytype(rt, rate);</a>
<a name="ln2924">	if (modtype == IEEE80211_T_OFDM)</a>
<a name="ln2925">		bwi_ofdm_plcp_header(plcp, pkt_len, rate);</a>
<a name="ln2926">	else if (modtype == IEEE80211_T_DS)</a>
<a name="ln2927">		bwi_ds_plcp_header(plcp, pkt_len, rate);</a>
<a name="ln2928">	else</a>
<a name="ln2929">		panic(&quot;unsupport modulation type %u\n&quot;, modtype);</a>
<a name="ln2930">}</a>
<a name="ln2931"> </a>
<a name="ln2932">static int</a>
<a name="ln2933">bwi_encap(struct bwi_softc *sc, int idx, struct mbuf *m,</a>
<a name="ln2934">	  struct ieee80211_node *ni)</a>
<a name="ln2935">{</a>
<a name="ln2936">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln2937">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln2938">	struct bwi_ring_data *rd = &amp;sc-&gt;sc_tx_rdata[BWI_TX_DATA_RING];</a>
<a name="ln2939">	struct bwi_txbuf_data *tbd = &amp;sc-&gt;sc_tx_bdata[BWI_TX_DATA_RING];</a>
<a name="ln2940">	struct bwi_txbuf *tb = &amp;tbd-&gt;tbd_buf[idx];</a>
<a name="ln2941">	struct bwi_mac *mac;</a>
<a name="ln2942">	struct bwi_txbuf_hdr *hdr;</a>
<a name="ln2943">	struct ieee80211_frame *wh;</a>
<a name="ln2944">	const struct ieee80211_txparam *tp = ni-&gt;ni_txparms;</a>
<a name="ln2945">	uint8_t rate, rate_fb;</a>
<a name="ln2946">	uint32_t mac_ctrl;</a>
<a name="ln2947">	uint16_t phy_ctrl;</a>
<a name="ln2948">	bus_addr_t paddr;</a>
<a name="ln2949">	int type, ismcast, pkt_len, error, rix;</a>
<a name="ln2950">#if 0</a>
<a name="ln2951">	const uint8_t *p;</a>
<a name="ln2952">	int i;</a>
<a name="ln2953">#endif</a>
<a name="ln2954"> </a>
<a name="ln2955">	KASSERT(sc-&gt;sc_cur_regwin-&gt;rw_type == BWI_REGWIN_T_MAC,</a>
<a name="ln2956">	    (&quot;current regwin type %d&quot;, sc-&gt;sc_cur_regwin-&gt;rw_type));</a>
<a name="ln2957">	mac = (struct bwi_mac *)sc-&gt;sc_cur_regwin;</a>
<a name="ln2958"> </a>
<a name="ln2959">	wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln2960">	type = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_TYPE_MASK;</a>
<a name="ln2961">	ismcast = IEEE80211_IS_MULTICAST(wh-&gt;i_addr1);</a>
<a name="ln2962"> </a>
<a name="ln2963">	/* Get 802.11 frame len before prepending TX header */</a>
<a name="ln2964">	pkt_len = m-&gt;m_pkthdr.len + IEEE80211_CRC_LEN;</a>
<a name="ln2965"> </a>
<a name="ln2966">	/*</a>
<a name="ln2967">	 * Find TX rate</a>
<a name="ln2968">	 */</a>
<a name="ln2969">	if (type != IEEE80211_FC0_TYPE_DATA || (m-&gt;m_flags &amp; M_EAPOL)) {</a>
<a name="ln2970">		rate = rate_fb = tp-&gt;mgmtrate;</a>
<a name="ln2971">	} else if (ismcast) {</a>
<a name="ln2972">		rate = rate_fb = tp-&gt;mcastrate;</a>
<a name="ln2973">	} else if (tp-&gt;ucastrate != IEEE80211_FIXED_RATE_NONE) {</a>
<a name="ln2974">		rate = rate_fb = tp-&gt;ucastrate;</a>
<a name="ln2975">	} else {</a>
<a name="ln2976">		rix = ieee80211_ratectl_rate(ni, NULL, pkt_len);</a>
<a name="ln2977">		rate = ni-&gt;ni_txrate;</a>
<a name="ln2978"> </a>
<a name="ln2979">		if (rix &gt; 0) {</a>
<a name="ln2980">			rate_fb = ni-&gt;ni_rates.rs_rates[rix-1] &amp;</a>
<a name="ln2981">				  IEEE80211_RATE_VAL;</a>
<a name="ln2982">		} else {</a>
<a name="ln2983">			rate_fb = rate;</a>
<a name="ln2984">		}</a>
<a name="ln2985">	}</a>
<a name="ln2986">	tb-&gt;tb_rate[0] = rate;</a>
<a name="ln2987">	tb-&gt;tb_rate[1] = rate_fb;</a>
<a name="ln2988">	sc-&gt;sc_tx_rate = rate;</a>
<a name="ln2989"> </a>
<a name="ln2990">	/*</a>
<a name="ln2991">	 * TX radio tap</a>
<a name="ln2992">	 */</a>
<a name="ln2993">	if (ieee80211_radiotap_active_vap(vap)) {</a>
<a name="ln2994">		sc-&gt;sc_tx_th.wt_flags = 0;</a>
<a name="ln2995">		if (wh-&gt;i_fc[1] &amp; IEEE80211_FC1_PROTECTED)</a>
<a name="ln2996">			sc-&gt;sc_tx_th.wt_flags |= IEEE80211_RADIOTAP_F_WEP;</a>
<a name="ln2997">		if (ieee80211_rate2phytype(sc-&gt;sc_rates, rate) == IEEE80211_T_DS &amp;&amp;</a>
<a name="ln2998">		    (ic-&gt;ic_flags &amp; IEEE80211_F_SHPREAMBLE) &amp;&amp;</a>
<a name="ln2999">		    rate != (1 * 2)) {</a>
<a name="ln3000">			sc-&gt;sc_tx_th.wt_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;</a>
<a name="ln3001">		}</a>
<a name="ln3002">		sc-&gt;sc_tx_th.wt_rate = rate;</a>
<a name="ln3003"> </a>
<a name="ln3004">		ieee80211_radiotap_tx(vap, m);</a>
<a name="ln3005">	}</a>
<a name="ln3006"> </a>
<a name="ln3007">	/*</a>
<a name="ln3008">	 * Setup the embedded TX header</a>
<a name="ln3009">	 */</a>
<a name="ln3010">	M_PREPEND(m, sizeof(*hdr), M_NOWAIT);</a>
<a name="ln3011">	if (m == NULL) {</a>
<a name="ln3012">		device_printf(sc-&gt;sc_dev, &quot;%s: prepend TX header failed\n&quot;,</a>
<a name="ln3013">		    __func__);</a>
<a name="ln3014">		return ENOBUFS;</a>
<a name="ln3015">	}</a>
<a name="ln3016">	hdr = mtod(m, struct bwi_txbuf_hdr *);</a>
<a name="ln3017"> </a>
<a name="ln3018">	bzero(hdr, sizeof(*hdr));</a>
<a name="ln3019"> </a>
<a name="ln3020">	bcopy(wh-&gt;i_fc, hdr-&gt;txh_fc, sizeof(hdr-&gt;txh_fc));</a>
<a name="ln3021">	bcopy(wh-&gt;i_addr1, hdr-&gt;txh_addr1, sizeof(hdr-&gt;txh_addr1));</a>
<a name="ln3022"> </a>
<a name="ln3023">	if (!ismcast) {</a>
<a name="ln3024">		uint16_t dur;</a>
<a name="ln3025"> </a>
<a name="ln3026">		dur = ieee80211_ack_duration(sc-&gt;sc_rates, rate,</a>
<a name="ln3027">		    ic-&gt;ic_flags &amp; ~IEEE80211_F_SHPREAMBLE);</a>
<a name="ln3028"> </a>
<a name="ln3029">		hdr-&gt;txh_fb_duration = htole16(dur);</a>
<a name="ln3030">	}</a>
<a name="ln3031"> </a>
<a name="ln3032">	hdr-&gt;txh_id = __SHIFTIN(BWI_TX_DATA_RING, BWI_TXH_ID_RING_MASK) |</a>
<a name="ln3033">		      __SHIFTIN(idx, BWI_TXH_ID_IDX_MASK);</a>
<a name="ln3034"> </a>
<a name="ln3035">	bwi_plcp_header(sc-&gt;sc_rates, hdr-&gt;txh_plcp, pkt_len, rate);</a>
<a name="ln3036">	bwi_plcp_header(sc-&gt;sc_rates, hdr-&gt;txh_fb_plcp, pkt_len, rate_fb);</a>
<a name="ln3037"> </a>
<a name="ln3038">	phy_ctrl = __SHIFTIN(mac-&gt;mac_rf.rf_ant_mode,</a>
<a name="ln3039">			     BWI_TXH_PHY_C_ANTMODE_MASK);</a>
<a name="ln3040">	if (ieee80211_rate2phytype(sc-&gt;sc_rates, rate) == IEEE80211_T_OFDM)</a>
<a name="ln3041">		phy_ctrl |= BWI_TXH_PHY_C_OFDM;</a>
<a name="ln3042">	else if ((ic-&gt;ic_flags &amp; IEEE80211_F_SHPREAMBLE) &amp;&amp; rate != (2 * 1))</a>
<a name="ln3043">		phy_ctrl |= BWI_TXH_PHY_C_SHPREAMBLE;</a>
<a name="ln3044"> </a>
<a name="ln3045">	mac_ctrl = BWI_TXH_MAC_C_HWSEQ | BWI_TXH_MAC_C_FIRST_FRAG;</a>
<a name="ln3046">	if (!ismcast)</a>
<a name="ln3047">		mac_ctrl |= BWI_TXH_MAC_C_ACK;</a>
<a name="ln3048">	if (ieee80211_rate2phytype(sc-&gt;sc_rates, rate_fb) == IEEE80211_T_OFDM)</a>
<a name="ln3049">		mac_ctrl |= BWI_TXH_MAC_C_FB_OFDM;</a>
<a name="ln3050"> </a>
<a name="ln3051">	hdr-&gt;txh_mac_ctrl = htole32(mac_ctrl);</a>
<a name="ln3052">	hdr-&gt;txh_phy_ctrl = htole16(phy_ctrl);</a>
<a name="ln3053"> </a>
<a name="ln3054">	/* Catch any further usage */</a>
<a name="ln3055">	hdr = NULL;</a>
<a name="ln3056">	wh = NULL;</a>
<a name="ln3057"> </a>
<a name="ln3058">	/* DMA load */</a>
<a name="ln3059">	error = bus_dmamap_load_mbuf(sc-&gt;sc_buf_dtag, tb-&gt;tb_dmap, m,</a>
<a name="ln3060">				     bwi_dma_buf_addr, &amp;paddr, BUS_DMA_NOWAIT);</a>
<a name="ln3061">	if (error &amp;&amp; error != EFBIG) {</a>
<a name="ln3062">		device_printf(sc-&gt;sc_dev, &quot;%s: can't load TX buffer (1) %d\n&quot;,</a>
<a name="ln3063">		    __func__, error);</a>
<a name="ln3064">		goto back;</a>
<a name="ln3065">	}</a>
<a name="ln3066"> </a>
<a name="ln3067">	if (error) {	/* error == EFBIG */</a>
<a name="ln3068">		struct mbuf *m_new;</a>
<a name="ln3069"> </a>
<a name="ln3070">		m_new = m_defrag(m, M_NOWAIT);</a>
<a name="ln3071">		if (m_new == NULL) {</a>
<a name="ln3072">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln3073">			    &quot;%s: can't defrag TX buffer\n&quot;, __func__);</a>
<a name="ln3074">			error = ENOBUFS;</a>
<a name="ln3075">			goto back;</a>
<a name="ln3076">		} else {</a>
<a name="ln3077">			m = m_new;</a>
<a name="ln3078">		}</a>
<a name="ln3079"> </a>
<a name="ln3080">		error = bus_dmamap_load_mbuf(sc-&gt;sc_buf_dtag, tb-&gt;tb_dmap, m,</a>
<a name="ln3081">					     bwi_dma_buf_addr, &amp;paddr,</a>
<a name="ln3082">					     BUS_DMA_NOWAIT);</a>
<a name="ln3083">		if (error) {</a>
<a name="ln3084">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln3085">			    &quot;%s: can't load TX buffer (2) %d\n&quot;,</a>
<a name="ln3086">			    __func__, error);</a>
<a name="ln3087">			goto back;</a>
<a name="ln3088">		}</a>
<a name="ln3089">	}</a>
<a name="ln3090">	error = 0;</a>
<a name="ln3091"> </a>
<a name="ln3092">	bus_dmamap_sync(sc-&gt;sc_buf_dtag, tb-&gt;tb_dmap, BUS_DMASYNC_PREWRITE);</a>
<a name="ln3093"> </a>
<a name="ln3094">	tb-&gt;tb_mbuf = m;</a>
<a name="ln3095">	tb-&gt;tb_ni = ni;</a>
<a name="ln3096"> </a>
<a name="ln3097">#if 0</a>
<a name="ln3098">	p = mtod(m, const uint8_t *);</a>
<a name="ln3099">	for (i = 0; i &lt; m-&gt;m_pkthdr.len; ++i) {</a>
<a name="ln3100">		if (i != 0 &amp;&amp; i % 8 == 0)</a>
<a name="ln3101">			printf(&quot;\n&quot;);</a>
<a name="ln3102">		printf(&quot;%02x &quot;, p[i]);</a>
<a name="ln3103">	}</a>
<a name="ln3104">	printf(&quot;\n&quot;);</a>
<a name="ln3105">#endif</a>
<a name="ln3106">	DPRINTF(sc, BWI_DBG_TX, &quot;idx %d, pkt_len %d, buflen %d\n&quot;,</a>
<a name="ln3107">		idx, pkt_len, m-&gt;m_pkthdr.len);</a>
<a name="ln3108"> </a>
<a name="ln3109">	/* Setup TX descriptor */</a>
<a name="ln3110">	sc-&gt;sc_setup_txdesc(sc, rd, idx, paddr, m-&gt;m_pkthdr.len);</a>
<a name="ln3111">	bus_dmamap_sync(sc-&gt;sc_txring_dtag, rd-&gt;rdata_dmap,</a>
<a name="ln3112">			BUS_DMASYNC_PREWRITE);</a>
<a name="ln3113"> </a>
<a name="ln3114">	/* Kick start */</a>
<a name="ln3115">	sc-&gt;sc_start_tx(sc, rd-&gt;rdata_txrx_ctrl, idx);</a>
<a name="ln3116"> </a>
<a name="ln3117">back:</a>
<a name="ln3118">	if (error)</a>
<a name="ln3119">		m_freem(m);</a>
<a name="ln3120">	return error;</a>
<a name="ln3121">}</a>
<a name="ln3122"> </a>
<a name="ln3123">static int</a>
<a name="ln3124">bwi_encap_raw(struct bwi_softc *sc, int idx, struct mbuf *m,</a>
<a name="ln3125">	  struct ieee80211_node *ni, const struct ieee80211_bpf_params *params)</a>
<a name="ln3126">{</a>
<a name="ln3127">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln3128">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln3129">	struct bwi_ring_data *rd = &amp;sc-&gt;sc_tx_rdata[BWI_TX_DATA_RING];</a>
<a name="ln3130">	struct bwi_txbuf_data *tbd = &amp;sc-&gt;sc_tx_bdata[BWI_TX_DATA_RING];</a>
<a name="ln3131">	struct bwi_txbuf *tb = &amp;tbd-&gt;tbd_buf[idx];</a>
<a name="ln3132">	struct bwi_mac *mac;</a>
<a name="ln3133">	struct bwi_txbuf_hdr *hdr;</a>
<a name="ln3134">	struct ieee80211_frame *wh;</a>
<a name="ln3135">	uint8_t rate, rate_fb;</a>
<a name="ln3136">	uint32_t mac_ctrl;</a>
<a name="ln3137">	uint16_t phy_ctrl;</a>
<a name="ln3138">	bus_addr_t paddr;</a>
<a name="ln3139">	int ismcast, pkt_len, error;</a>
<a name="ln3140"> </a>
<a name="ln3141">	KASSERT(sc-&gt;sc_cur_regwin-&gt;rw_type == BWI_REGWIN_T_MAC,</a>
<a name="ln3142">	    (&quot;current regwin type %d&quot;, sc-&gt;sc_cur_regwin-&gt;rw_type));</a>
<a name="ln3143">	mac = (struct bwi_mac *)sc-&gt;sc_cur_regwin;</a>
<a name="ln3144"> </a>
<a name="ln3145">	wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln3146">	ismcast = IEEE80211_IS_MULTICAST(wh-&gt;i_addr1);</a>
<a name="ln3147"> </a>
<a name="ln3148">	/* Get 802.11 frame len before prepending TX header */</a>
<a name="ln3149">	pkt_len = m-&gt;m_pkthdr.len + IEEE80211_CRC_LEN;</a>
<a name="ln3150"> </a>
<a name="ln3151">	/*</a>
<a name="ln3152">	 * Find TX rate</a>
<a name="ln3153">	 */</a>
<a name="ln3154">	rate = params-&gt;ibp_rate0;</a>
<a name="ln3155">	if (!ieee80211_isratevalid(ic-&gt;ic_rt, rate)) {</a>
<a name="ln3156">		/* XXX fall back to mcast/mgmt rate? */</a>
<a name="ln3157">		m_freem(m);</a>
<a name="ln3158">		return EINVAL;</a>
<a name="ln3159">	}</a>
<a name="ln3160">	if (params-&gt;ibp_try1 != 0) {</a>
<a name="ln3161">		rate_fb = params-&gt;ibp_rate1;</a>
<a name="ln3162">		if (!ieee80211_isratevalid(ic-&gt;ic_rt, rate_fb)) {</a>
<a name="ln3163">			/* XXX fall back to rate0? */</a>
<a name="ln3164">			m_freem(m);</a>
<a name="ln3165">			return EINVAL;</a>
<a name="ln3166">		}</a>
<a name="ln3167">	} else</a>
<a name="ln3168">		rate_fb = rate;</a>
<a name="ln3169">	tb-&gt;tb_rate[0] = rate;</a>
<a name="ln3170">	tb-&gt;tb_rate[1] = rate_fb;</a>
<a name="ln3171">	sc-&gt;sc_tx_rate = rate;</a>
<a name="ln3172"> </a>
<a name="ln3173">	/*</a>
<a name="ln3174">	 * TX radio tap</a>
<a name="ln3175">	 */</a>
<a name="ln3176">	if (ieee80211_radiotap_active_vap(vap)) {</a>
<a name="ln3177">		sc-&gt;sc_tx_th.wt_flags = 0;</a>
<a name="ln3178">		/* XXX IEEE80211_BPF_CRYPTO */</a>
<a name="ln3179">		if (wh-&gt;i_fc[1] &amp; IEEE80211_FC1_PROTECTED)</a>
<a name="ln3180">			sc-&gt;sc_tx_th.wt_flags |= IEEE80211_RADIOTAP_F_WEP;</a>
<a name="ln3181">		if (params-&gt;ibp_flags &amp; IEEE80211_BPF_SHORTPRE)</a>
<a name="ln3182">			sc-&gt;sc_tx_th.wt_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;</a>
<a name="ln3183">		sc-&gt;sc_tx_th.wt_rate = rate;</a>
<a name="ln3184"> </a>
<a name="ln3185">		ieee80211_radiotap_tx(vap, m);</a>
<a name="ln3186">	}</a>
<a name="ln3187"> </a>
<a name="ln3188">	/*</a>
<a name="ln3189">	 * Setup the embedded TX header</a>
<a name="ln3190">	 */</a>
<a name="ln3191">	M_PREPEND(m, sizeof(*hdr), M_NOWAIT);</a>
<a name="ln3192">	if (m == NULL) {</a>
<a name="ln3193">		device_printf(sc-&gt;sc_dev, &quot;%s: prepend TX header failed\n&quot;,</a>
<a name="ln3194">		    __func__);</a>
<a name="ln3195">		return ENOBUFS;</a>
<a name="ln3196">	}</a>
<a name="ln3197">	hdr = mtod(m, struct bwi_txbuf_hdr *);</a>
<a name="ln3198"> </a>
<a name="ln3199">	bzero(hdr, sizeof(*hdr));</a>
<a name="ln3200"> </a>
<a name="ln3201">	bcopy(wh-&gt;i_fc, hdr-&gt;txh_fc, sizeof(hdr-&gt;txh_fc));</a>
<a name="ln3202">	bcopy(wh-&gt;i_addr1, hdr-&gt;txh_addr1, sizeof(hdr-&gt;txh_addr1));</a>
<a name="ln3203"> </a>
<a name="ln3204">	mac_ctrl = BWI_TXH_MAC_C_HWSEQ | BWI_TXH_MAC_C_FIRST_FRAG;</a>
<a name="ln3205">	if (!ismcast &amp;&amp; (params-&gt;ibp_flags &amp; IEEE80211_BPF_NOACK) == 0) {</a>
<a name="ln3206">		uint16_t dur;</a>
<a name="ln3207"> </a>
<a name="ln3208">		dur = ieee80211_ack_duration(sc-&gt;sc_rates, rate_fb, 0);</a>
<a name="ln3209"> </a>
<a name="ln3210">		hdr-&gt;txh_fb_duration = htole16(dur);</a>
<a name="ln3211">		mac_ctrl |= BWI_TXH_MAC_C_ACK;</a>
<a name="ln3212">	}</a>
<a name="ln3213"> </a>
<a name="ln3214">	hdr-&gt;txh_id = __SHIFTIN(BWI_TX_DATA_RING, BWI_TXH_ID_RING_MASK) |</a>
<a name="ln3215">		      __SHIFTIN(idx, BWI_TXH_ID_IDX_MASK);</a>
<a name="ln3216"> </a>
<a name="ln3217">	bwi_plcp_header(sc-&gt;sc_rates, hdr-&gt;txh_plcp, pkt_len, rate);</a>
<a name="ln3218">	bwi_plcp_header(sc-&gt;sc_rates, hdr-&gt;txh_fb_plcp, pkt_len, rate_fb);</a>
<a name="ln3219"> </a>
<a name="ln3220">	phy_ctrl = __SHIFTIN(mac-&gt;mac_rf.rf_ant_mode,</a>
<a name="ln3221">			     BWI_TXH_PHY_C_ANTMODE_MASK);</a>
<a name="ln3222">	if (ieee80211_rate2phytype(sc-&gt;sc_rates, rate) == IEEE80211_T_OFDM) {</a>
<a name="ln3223">		phy_ctrl |= BWI_TXH_PHY_C_OFDM;</a>
<a name="ln3224">		mac_ctrl |= BWI_TXH_MAC_C_FB_OFDM;</a>
<a name="ln3225">	} else if (params-&gt;ibp_flags &amp; IEEE80211_BPF_SHORTPRE)</a>
<a name="ln3226">		phy_ctrl |= BWI_TXH_PHY_C_SHPREAMBLE;</a>
<a name="ln3227"> </a>
<a name="ln3228">	hdr-&gt;txh_mac_ctrl = htole32(mac_ctrl);</a>
<a name="ln3229">	hdr-&gt;txh_phy_ctrl = htole16(phy_ctrl);</a>
<a name="ln3230"> </a>
<a name="ln3231">	/* Catch any further usage */</a>
<a name="ln3232">	hdr = NULL;</a>
<a name="ln3233">	wh = NULL;</a>
<a name="ln3234"> </a>
<a name="ln3235">	/* DMA load */</a>
<a name="ln3236">	error = bus_dmamap_load_mbuf(sc-&gt;sc_buf_dtag, tb-&gt;tb_dmap, m,</a>
<a name="ln3237">				     bwi_dma_buf_addr, &amp;paddr, BUS_DMA_NOWAIT);</a>
<a name="ln3238">	if (error != 0) {</a>
<a name="ln3239">		struct mbuf *m_new;</a>
<a name="ln3240"> </a>
<a name="ln3241">		if (error != EFBIG) {</a>
<a name="ln3242">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln3243">			    &quot;%s: can't load TX buffer (1) %d\n&quot;,</a>
<a name="ln3244">			    __func__, error);</a>
<a name="ln3245">			goto back;</a>
<a name="ln3246">		}</a>
<a name="ln3247">		m_new = m_defrag(m, M_NOWAIT);</a>
<a name="ln3248">		if (m_new == NULL) {</a>
<a name="ln3249">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln3250">			    &quot;%s: can't defrag TX buffer\n&quot;, __func__);</a>
<a name="ln3251">			error = ENOBUFS;</a>
<a name="ln3252">			goto back;</a>
<a name="ln3253">		}</a>
<a name="ln3254">		m = m_new;</a>
<a name="ln3255">		error = bus_dmamap_load_mbuf(sc-&gt;sc_buf_dtag, tb-&gt;tb_dmap, m,</a>
<a name="ln3256">					     bwi_dma_buf_addr, &amp;paddr,</a>
<a name="ln3257">					     BUS_DMA_NOWAIT);</a>
<a name="ln3258">		if (error) {</a>
<a name="ln3259">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln3260">			    &quot;%s: can't load TX buffer (2) %d\n&quot;,</a>
<a name="ln3261">			    __func__, error);</a>
<a name="ln3262">			goto back;</a>
<a name="ln3263">		}</a>
<a name="ln3264">	}</a>
<a name="ln3265"> </a>
<a name="ln3266">	bus_dmamap_sync(sc-&gt;sc_buf_dtag, tb-&gt;tb_dmap, BUS_DMASYNC_PREWRITE);</a>
<a name="ln3267"> </a>
<a name="ln3268">	tb-&gt;tb_mbuf = m;</a>
<a name="ln3269">	tb-&gt;tb_ni = ni;</a>
<a name="ln3270"> </a>
<a name="ln3271">	DPRINTF(sc, BWI_DBG_TX, &quot;idx %d, pkt_len %d, buflen %d\n&quot;,</a>
<a name="ln3272">		idx, pkt_len, m-&gt;m_pkthdr.len);</a>
<a name="ln3273"> </a>
<a name="ln3274">	/* Setup TX descriptor */</a>
<a name="ln3275">	sc-&gt;sc_setup_txdesc(sc, rd, idx, paddr, m-&gt;m_pkthdr.len);</a>
<a name="ln3276">	bus_dmamap_sync(sc-&gt;sc_txring_dtag, rd-&gt;rdata_dmap,</a>
<a name="ln3277">			BUS_DMASYNC_PREWRITE);</a>
<a name="ln3278"> </a>
<a name="ln3279">	/* Kick start */</a>
<a name="ln3280">	sc-&gt;sc_start_tx(sc, rd-&gt;rdata_txrx_ctrl, idx);</a>
<a name="ln3281">back:</a>
<a name="ln3282">	if (error)</a>
<a name="ln3283">		m_freem(m);</a>
<a name="ln3284">	return error;</a>
<a name="ln3285">}</a>
<a name="ln3286"> </a>
<a name="ln3287">static void</a>
<a name="ln3288">bwi_start_tx32(struct bwi_softc *sc, uint32_t tx_ctrl, int idx)</a>
<a name="ln3289">{</a>
<a name="ln3290">	idx = (idx + 1) % BWI_TX_NDESC;</a>
<a name="ln3291">	CSR_WRITE_4(sc, tx_ctrl + BWI_TX32_INDEX,</a>
<a name="ln3292">		    idx * sizeof(struct bwi_desc32));</a>
<a name="ln3293">}</a>
<a name="ln3294"> </a>
<a name="ln3295">static void</a>
<a name="ln3296">bwi_start_tx64(struct bwi_softc *sc, uint32_t tx_ctrl, int idx)</a>
<a name="ln3297">{</a>
<a name="ln3298">	/* TODO:64 */</a>
<a name="ln3299">}</a>
<a name="ln3300"> </a>
<a name="ln3301">static void</a>
<a name="ln3302">bwi_txeof_status32(struct bwi_softc *sc)</a>
<a name="ln3303">{</a>
<a name="ln3304">	uint32_t val, ctrl_base;</a>
<a name="ln3305">	int end_idx;</a>
<a name="ln3306"> </a>
<a name="ln3307">	ctrl_base = sc-&gt;sc_txstats-&gt;stats_ctrl_base;</a>
<a name="ln3308"> </a>
<a name="ln3309">	val = CSR_READ_4(sc, ctrl_base + BWI_RX32_STATUS);</a>
<a name="ln3310">	end_idx = __SHIFTOUT(val, BWI_RX32_STATUS_INDEX_MASK) /</a>
<a name="ln3311">		  sizeof(struct bwi_desc32);</a>
<a name="ln3312"> </a>
<a name="ln3313">	bwi_txeof_status(sc, end_idx);</a>
<a name="ln3314"> </a>
<a name="ln3315">	CSR_WRITE_4(sc, ctrl_base + BWI_RX32_INDEX,</a>
<a name="ln3316">		    end_idx * sizeof(struct bwi_desc32));</a>
<a name="ln3317"> </a>
<a name="ln3318">	bwi_start_locked(sc);</a>
<a name="ln3319">}</a>
<a name="ln3320"> </a>
<a name="ln3321">static void</a>
<a name="ln3322">bwi_txeof_status64(struct bwi_softc *sc)</a>
<a name="ln3323">{</a>
<a name="ln3324">	/* TODO:64 */</a>
<a name="ln3325">}</a>
<a name="ln3326"> </a>
<a name="ln3327">static void</a>
<a name="ln3328">_bwi_txeof(struct bwi_softc *sc, uint16_t tx_id, int acked, int data_txcnt)</a>
<a name="ln3329">{</a>
<a name="ln3330">	struct bwi_txbuf_data *tbd;</a>
<a name="ln3331">	struct bwi_txbuf *tb;</a>
<a name="ln3332">	int ring_idx, buf_idx;</a>
<a name="ln3333">	struct ieee80211_node *ni;</a>
<a name="ln3334"> </a>
<a name="ln3335">	if (tx_id == 0) {</a>
<a name="ln3336">		device_printf(sc-&gt;sc_dev, &quot;%s: zero tx id\n&quot;, __func__);</a>
<a name="ln3337">		return;</a>
<a name="ln3338">	}</a>
<a name="ln3339"> </a>
<a name="ln3340">	ring_idx = __SHIFTOUT(tx_id, BWI_TXH_ID_RING_MASK);</a>
<a name="ln3341">	buf_idx = __SHIFTOUT(tx_id, BWI_TXH_ID_IDX_MASK);</a>
<a name="ln3342"> </a>
<a name="ln3343">	KASSERT(ring_idx == BWI_TX_DATA_RING, (&quot;ring_idx %d&quot;, ring_idx));</a>
<a name="ln3344">	KASSERT(buf_idx &lt; BWI_TX_NDESC, (&quot;buf_idx %d&quot;, buf_idx));</a>
<a name="ln3345"> </a>
<a name="ln3346">	tbd = &amp;sc-&gt;sc_tx_bdata[ring_idx];</a>
<a name="ln3347">	KASSERT(tbd-&gt;tbd_used &gt; 0, (&quot;tbd_used %d&quot;, tbd-&gt;tbd_used));</a>
<a name="ln3348">	tbd-&gt;tbd_used--;</a>
<a name="ln3349"> </a>
<a name="ln3350">	tb = &amp;tbd-&gt;tbd_buf[buf_idx];</a>
<a name="ln3351">	DPRINTF(sc, BWI_DBG_TXEOF, &quot;txeof idx %d, &quot;</a>
<a name="ln3352">		&quot;acked %d, data_txcnt %d, ni %p\n&quot;,</a>
<a name="ln3353">		buf_idx, acked, data_txcnt, tb-&gt;tb_ni);</a>
<a name="ln3354"> </a>
<a name="ln3355">	bus_dmamap_unload(sc-&gt;sc_buf_dtag, tb-&gt;tb_dmap);</a>
<a name="ln3356"> </a>
<a name="ln3357">	if ((ni = tb-&gt;tb_ni) != NULL) {</a>
<a name="ln3358">		const struct bwi_txbuf_hdr *hdr =</a>
<a name="ln3359">		    mtod(tb-&gt;tb_mbuf, const struct bwi_txbuf_hdr *);</a>
<a name="ln3360">		struct ieee80211_ratectl_tx_status txs;</a>
<a name="ln3361"> </a>
<a name="ln3362">		/* NB: update rate control only for unicast frames */</a>
<a name="ln3363">		if (hdr-&gt;txh_mac_ctrl &amp; htole32(BWI_TXH_MAC_C_ACK)) {</a>
<a name="ln3364">			/*</a>
<a name="ln3365">			 * Feed back 'acked and data_txcnt'.  Note that the</a>
<a name="ln3366">			 * generic AMRR code only understands one tx rate</a>
<a name="ln3367">			 * and the estimator doesn't handle real retry counts</a>
<a name="ln3368">			 * well so to avoid over-aggressive downshifting we</a>
<a name="ln3369">			 * treat any number of retries as &quot;1&quot;.</a>
<a name="ln3370">			 */</a>
<a name="ln3371">			txs.flags = IEEE80211_RATECTL_STATUS_LONG_RETRY;</a>
<a name="ln3372">			txs.long_retries = acked;</a>
<a name="ln3373">			if (data_txcnt &gt; 1)</a>
<a name="ln3374">				txs.status = IEEE80211_RATECTL_TX_SUCCESS;</a>
<a name="ln3375">			else {</a>
<a name="ln3376">				txs.status =</a>
<a name="ln3377">				    IEEE80211_RATECTL_TX_FAIL_UNSPECIFIED;</a>
<a name="ln3378">			}</a>
<a name="ln3379">			ieee80211_ratectl_tx_complete(ni, &amp;txs);</a>
<a name="ln3380">		}</a>
<a name="ln3381">		ieee80211_tx_complete(ni, tb-&gt;tb_mbuf, !acked);</a>
<a name="ln3382">		tb-&gt;tb_ni = NULL;</a>
<a name="ln3383">	} else</a>
<a name="ln3384">		m_freem(tb-&gt;tb_mbuf);</a>
<a name="ln3385">	tb-&gt;tb_mbuf = NULL;</a>
<a name="ln3386"> </a>
<a name="ln3387">	if (tbd-&gt;tbd_used == 0)</a>
<a name="ln3388">		sc-&gt;sc_tx_timer = 0;</a>
<a name="ln3389">}</a>
<a name="ln3390"> </a>
<a name="ln3391">static void</a>
<a name="ln3392">bwi_txeof_status(struct bwi_softc *sc, int end_idx)</a>
<a name="ln3393">{</a>
<a name="ln3394">	struct bwi_txstats_data *st = sc-&gt;sc_txstats;</a>
<a name="ln3395">	int idx;</a>
<a name="ln3396"> </a>
<a name="ln3397">	bus_dmamap_sync(st-&gt;stats_dtag, st-&gt;stats_dmap, BUS_DMASYNC_POSTREAD);</a>
<a name="ln3398"> </a>
<a name="ln3399">	idx = st-&gt;stats_idx;</a>
<a name="ln3400">	while (idx != end_idx) {</a>
<a name="ln3401">		const struct bwi_txstats *stats = &amp;st-&gt;stats[idx];</a>
<a name="ln3402"> </a>
<a name="ln3403">		if ((stats-&gt;txs_flags &amp; BWI_TXS_F_PENDING) == 0) {</a>
<a name="ln3404">			int data_txcnt;</a>
<a name="ln3405"> </a>
<a name="ln3406">			data_txcnt = __SHIFTOUT(stats-&gt;txs_txcnt,</a>
<a name="ln3407">						BWI_TXS_TXCNT_DATA);</a>
<a name="ln3408">			_bwi_txeof(sc, le16toh(stats-&gt;txs_id),</a>
<a name="ln3409">				   stats-&gt;txs_flags &amp; BWI_TXS_F_ACKED,</a>
<a name="ln3410">				   data_txcnt);</a>
<a name="ln3411">		}</a>
<a name="ln3412">		idx = (idx + 1) % BWI_TXSTATS_NDESC;</a>
<a name="ln3413">	}</a>
<a name="ln3414">	st-&gt;stats_idx = idx;</a>
<a name="ln3415">}</a>
<a name="ln3416"> </a>
<a name="ln3417">static void</a>
<a name="ln3418">bwi_txeof(struct bwi_softc *sc)</a>
<a name="ln3419">{</a>
<a name="ln3420"> </a>
<a name="ln3421">	for (;;) {</a>
<a name="ln3422">		uint32_t tx_status0, tx_status1;</a>
<a name="ln3423">		uint16_t tx_id;</a>
<a name="ln3424">		int data_txcnt;</a>
<a name="ln3425"> </a>
<a name="ln3426">		tx_status0 = CSR_READ_4(sc, BWI_TXSTATUS0);</a>
<a name="ln3427">		if ((tx_status0 &amp; BWI_TXSTATUS0_VALID) == 0)</a>
<a name="ln3428">			break;</a>
<a name="ln3429">		tx_status1 = CSR_READ_4(sc, BWI_TXSTATUS1);</a>
<a name="ln3430"> </a>
<a name="ln3431">		tx_id = __SHIFTOUT(tx_status0, BWI_TXSTATUS0_TXID_MASK);</a>
<a name="ln3432">		data_txcnt = __SHIFTOUT(tx_status0,</a>
<a name="ln3433">				BWI_TXSTATUS0_DATA_TXCNT_MASK);</a>
<a name="ln3434"> </a>
<a name="ln3435">		if (tx_status0 &amp; (BWI_TXSTATUS0_AMPDU | BWI_TXSTATUS0_PENDING))</a>
<a name="ln3436">			continue;</a>
<a name="ln3437"> </a>
<a name="ln3438">		_bwi_txeof(sc, le16toh(tx_id), tx_status0 &amp; BWI_TXSTATUS0_ACKED,</a>
<a name="ln3439">		    data_txcnt);</a>
<a name="ln3440">	}</a>
<a name="ln3441"> </a>
<a name="ln3442">	bwi_start_locked(sc);</a>
<a name="ln3443">}</a>
<a name="ln3444"> </a>
<a name="ln3445">static int</a>
<a name="ln3446">bwi_bbp_power_on(struct bwi_softc *sc, enum bwi_clock_mode clk_mode)</a>
<a name="ln3447">{</a>
<a name="ln3448">	bwi_power_on(sc, 1);</a>
<a name="ln3449">	return bwi_set_clock_mode(sc, clk_mode);</a>
<a name="ln3450">}</a>
<a name="ln3451"> </a>
<a name="ln3452">static void</a>
<a name="ln3453">bwi_bbp_power_off(struct bwi_softc *sc)</a>
<a name="ln3454">{</a>
<a name="ln3455">	bwi_set_clock_mode(sc, BWI_CLOCK_MODE_SLOW);</a>
<a name="ln3456">	bwi_power_off(sc, 1);</a>
<a name="ln3457">}</a>
<a name="ln3458"> </a>
<a name="ln3459">static int</a>
<a name="ln3460">bwi_get_pwron_delay(struct bwi_softc *sc)</a>
<a name="ln3461">{</a>
<a name="ln3462">	struct bwi_regwin *com, *old;</a>
<a name="ln3463">	struct bwi_clock_freq freq;</a>
<a name="ln3464">	uint32_t val;</a>
<a name="ln3465">	int error;</a>
<a name="ln3466"> </a>
<a name="ln3467">	com = &amp;sc-&gt;sc_com_regwin;</a>
<a name="ln3468">	KASSERT(BWI_REGWIN_EXIST(com), (&quot;no regwin&quot;));</a>
<a name="ln3469"> </a>
<a name="ln3470">	if ((sc-&gt;sc_cap &amp; BWI_CAP_CLKMODE) == 0)</a>
<a name="ln3471">		return 0;</a>
<a name="ln3472"> </a>
<a name="ln3473">	error = bwi_regwin_switch(sc, com, &amp;old);</a>
<a name="ln3474">	if (error)</a>
<a name="ln3475">		return error;</a>
<a name="ln3476"> </a>
<a name="ln3477">	bwi_get_clock_freq(sc, &amp;freq);</a>
<a name="ln3478"> </a>
<a name="ln3479">	val = CSR_READ_4(sc, BWI_PLL_ON_DELAY);</a>
<a name="ln3480">	sc-&gt;sc_pwron_delay = howmany((val + 2) * 1000000, freq.clkfreq_min);</a>
<a name="ln3481">	DPRINTF(sc, BWI_DBG_ATTACH, &quot;power on delay %u\n&quot;, sc-&gt;sc_pwron_delay);</a>
<a name="ln3482"> </a>
<a name="ln3483">	return bwi_regwin_switch(sc, old, NULL);</a>
<a name="ln3484">}</a>
<a name="ln3485"> </a>
<a name="ln3486">static int</a>
<a name="ln3487">bwi_bus_attach(struct bwi_softc *sc)</a>
<a name="ln3488">{</a>
<a name="ln3489">	struct bwi_regwin *bus, *old;</a>
<a name="ln3490">	int error;</a>
<a name="ln3491"> </a>
<a name="ln3492">	bus = &amp;sc-&gt;sc_bus_regwin;</a>
<a name="ln3493"> </a>
<a name="ln3494">	error = bwi_regwin_switch(sc, bus, &amp;old);</a>
<a name="ln3495">	if (error)</a>
<a name="ln3496">		return error;</a>
<a name="ln3497"> </a>
<a name="ln3498">	if (!bwi_regwin_is_enabled(sc, bus))</a>
<a name="ln3499">		bwi_regwin_enable(sc, bus, 0);</a>
<a name="ln3500"> </a>
<a name="ln3501">	/* Disable interripts */</a>
<a name="ln3502">	CSR_WRITE_4(sc, BWI_INTRVEC, 0);</a>
<a name="ln3503"> </a>
<a name="ln3504">	return bwi_regwin_switch(sc, old, NULL);</a>
<a name="ln3505">}</a>
<a name="ln3506"> </a>
<a name="ln3507">static const char *</a>
<a name="ln3508">bwi_regwin_name(const struct bwi_regwin *rw)</a>
<a name="ln3509">{</a>
<a name="ln3510">	switch (rw-&gt;rw_type) {</a>
<a name="ln3511">	case BWI_REGWIN_T_COM:</a>
<a name="ln3512">		return &quot;COM&quot;;</a>
<a name="ln3513">	case BWI_REGWIN_T_BUSPCI:</a>
<a name="ln3514">		return &quot;PCI&quot;;</a>
<a name="ln3515">	case BWI_REGWIN_T_MAC:</a>
<a name="ln3516">		return &quot;MAC&quot;;</a>
<a name="ln3517">	case BWI_REGWIN_T_BUSPCIE:</a>
<a name="ln3518">		return &quot;PCIE&quot;;</a>
<a name="ln3519">	}</a>
<a name="ln3520">	panic(&quot;unknown regwin type 0x%04x\n&quot;, rw-&gt;rw_type);</a>
<a name="ln3521">	return NULL;</a>
<a name="ln3522">}</a>
<a name="ln3523"> </a>
<a name="ln3524">static uint32_t</a>
<a name="ln3525">bwi_regwin_disable_bits(struct bwi_softc *sc)</a>
<a name="ln3526">{</a>
<a name="ln3527">	uint32_t busrev;</a>
<a name="ln3528"> </a>
<a name="ln3529">	/* XXX cache this */</a>
<a name="ln3530">	busrev = __SHIFTOUT(CSR_READ_4(sc, BWI_ID_LO), BWI_ID_LO_BUSREV_MASK);</a>
<a name="ln3531">	DPRINTF(sc, BWI_DBG_ATTACH | BWI_DBG_INIT | BWI_DBG_MISC,</a>
<a name="ln3532">		&quot;bus rev %u\n&quot;, busrev);</a>
<a name="ln3533"> </a>
<a name="ln3534">	if (busrev == BWI_BUSREV_0)</a>
<a name="ln3535">		return BWI_STATE_LO_DISABLE1;</a>
<a name="ln3536">	else if (busrev == BWI_BUSREV_1)</a>
<a name="ln3537">		return BWI_STATE_LO_DISABLE2;</a>
<a name="ln3538">	else</a>
<a name="ln3539">		return (BWI_STATE_LO_DISABLE1 | BWI_STATE_LO_DISABLE2);</a>
<a name="ln3540">}</a>
<a name="ln3541"> </a>
<a name="ln3542">int</a>
<a name="ln3543">bwi_regwin_is_enabled(struct bwi_softc *sc, struct bwi_regwin *rw)</a>
<a name="ln3544">{</a>
<a name="ln3545">	uint32_t val, disable_bits;</a>
<a name="ln3546"> </a>
<a name="ln3547">	disable_bits = bwi_regwin_disable_bits(sc);</a>
<a name="ln3548">	val = CSR_READ_4(sc, BWI_STATE_LO);</a>
<a name="ln3549"> </a>
<a name="ln3550">	if ((val &amp; (BWI_STATE_LO_CLOCK |</a>
<a name="ln3551">		    BWI_STATE_LO_RESET |</a>
<a name="ln3552">		    disable_bits)) == BWI_STATE_LO_CLOCK) {</a>
<a name="ln3553">		DPRINTF(sc, BWI_DBG_ATTACH | BWI_DBG_INIT, &quot;%s is enabled\n&quot;,</a>
<a name="ln3554">			bwi_regwin_name(rw));</a>
<a name="ln3555">		return 1;</a>
<a name="ln3556">	} else {</a>
<a name="ln3557">		DPRINTF(sc, BWI_DBG_ATTACH | BWI_DBG_INIT, &quot;%s is disabled\n&quot;,</a>
<a name="ln3558">			bwi_regwin_name(rw));</a>
<a name="ln3559">		return 0;</a>
<a name="ln3560">	}</a>
<a name="ln3561">}</a>
<a name="ln3562"> </a>
<a name="ln3563">void</a>
<a name="ln3564">bwi_regwin_disable(struct bwi_softc *sc, struct bwi_regwin *rw, uint32_t flags)</a>
<a name="ln3565">{</a>
<a name="ln3566">	uint32_t state_lo, disable_bits;</a>
<a name="ln3567">	int i;</a>
<a name="ln3568"> </a>
<a name="ln3569">	state_lo = CSR_READ_4(sc, BWI_STATE_LO);</a>
<a name="ln3570"> </a>
<a name="ln3571">	/*</a>
<a name="ln3572">	 * If current regwin is in 'reset' state, it was already disabled.</a>
<a name="ln3573">	 */</a>
<a name="ln3574">	if (state_lo &amp; BWI_STATE_LO_RESET) {</a>
<a name="ln3575">		DPRINTF(sc, BWI_DBG_ATTACH | BWI_DBG_INIT,</a>
<a name="ln3576">			&quot;%s was already disabled\n&quot;, bwi_regwin_name(rw));</a>
<a name="ln3577">		return;</a>
<a name="ln3578">	}</a>
<a name="ln3579"> </a>
<a name="ln3580">	disable_bits = bwi_regwin_disable_bits(sc);</a>
<a name="ln3581"> </a>
<a name="ln3582">	/*</a>
<a name="ln3583">	 * Disable normal clock</a>
<a name="ln3584">	 */</a>
<a name="ln3585">	state_lo = BWI_STATE_LO_CLOCK | disable_bits;</a>
<a name="ln3586">	CSR_WRITE_4(sc, BWI_STATE_LO, state_lo);</a>
<a name="ln3587"> </a>
<a name="ln3588">	/*</a>
<a name="ln3589">	 * Wait until normal clock is disabled</a>
<a name="ln3590">	 */</a>
<a name="ln3591">#define NRETRY	1000</a>
<a name="ln3592">	for (i = 0; i &lt; NRETRY; ++i) {</a>
<a name="ln3593">		state_lo = CSR_READ_4(sc, BWI_STATE_LO);</a>
<a name="ln3594">		if (state_lo &amp; disable_bits)</a>
<a name="ln3595">			break;</a>
<a name="ln3596">		DELAY(10);</a>
<a name="ln3597">	}</a>
<a name="ln3598">	if (i == NRETRY) {</a>
<a name="ln3599">		device_printf(sc-&gt;sc_dev, &quot;%s disable clock timeout\n&quot;,</a>
<a name="ln3600">			      bwi_regwin_name(rw));</a>
<a name="ln3601">	}</a>
<a name="ln3602"> </a>
<a name="ln3603">	for (i = 0; i &lt; NRETRY; ++i) {</a>
<a name="ln3604">		uint32_t state_hi;</a>
<a name="ln3605"> </a>
<a name="ln3606">		state_hi = CSR_READ_4(sc, BWI_STATE_HI);</a>
<a name="ln3607">		if ((state_hi &amp; BWI_STATE_HI_BUSY) == 0)</a>
<a name="ln3608">			break;</a>
<a name="ln3609">		DELAY(10);</a>
<a name="ln3610">	}</a>
<a name="ln3611">	if (i == NRETRY) {</a>
<a name="ln3612">		device_printf(sc-&gt;sc_dev, &quot;%s wait BUSY unset timeout\n&quot;,</a>
<a name="ln3613">			      bwi_regwin_name(rw));</a>
<a name="ln3614">	}</a>
<a name="ln3615">#undef NRETRY</a>
<a name="ln3616"> </a>
<a name="ln3617">	/*</a>
<a name="ln3618">	 * Reset and disable regwin with gated clock</a>
<a name="ln3619">	 */</a>
<a name="ln3620">	state_lo = BWI_STATE_LO_RESET | disable_bits |</a>
<a name="ln3621">		   BWI_STATE_LO_CLOCK | BWI_STATE_LO_GATED_CLOCK |</a>
<a name="ln3622">		   __SHIFTIN(flags, BWI_STATE_LO_FLAGS_MASK);</a>
<a name="ln3623">	CSR_WRITE_4(sc, BWI_STATE_LO, state_lo);</a>
<a name="ln3624"> </a>
<a name="ln3625">	/* Flush pending bus write */</a>
<a name="ln3626">	CSR_READ_4(sc, BWI_STATE_LO);</a>
<a name="ln3627">	DELAY(1);</a>
<a name="ln3628"> </a>
<a name="ln3629">	/* Reset and disable regwin */</a>
<a name="ln3630">	state_lo = BWI_STATE_LO_RESET | disable_bits |</a>
<a name="ln3631">		   __SHIFTIN(flags, BWI_STATE_LO_FLAGS_MASK);</a>
<a name="ln3632">	CSR_WRITE_4(sc, BWI_STATE_LO, state_lo);</a>
<a name="ln3633"> </a>
<a name="ln3634">	/* Flush pending bus write */</a>
<a name="ln3635">	CSR_READ_4(sc, BWI_STATE_LO);</a>
<a name="ln3636">	DELAY(1);</a>
<a name="ln3637">}</a>
<a name="ln3638"> </a>
<a name="ln3639">void</a>
<a name="ln3640">bwi_regwin_enable(struct bwi_softc *sc, struct bwi_regwin *rw, uint32_t flags)</a>
<a name="ln3641">{</a>
<a name="ln3642">	uint32_t state_lo, state_hi, imstate;</a>
<a name="ln3643"> </a>
<a name="ln3644">	bwi_regwin_disable(sc, rw, flags);</a>
<a name="ln3645"> </a>
<a name="ln3646">	/* Reset regwin with gated clock */</a>
<a name="ln3647">	state_lo = BWI_STATE_LO_RESET |</a>
<a name="ln3648">		   BWI_STATE_LO_CLOCK |</a>
<a name="ln3649">		   BWI_STATE_LO_GATED_CLOCK |</a>
<a name="ln3650">		   __SHIFTIN(flags, BWI_STATE_LO_FLAGS_MASK);</a>
<a name="ln3651">	CSR_WRITE_4(sc, BWI_STATE_LO, state_lo);</a>
<a name="ln3652"> </a>
<a name="ln3653">	/* Flush pending bus write */</a>
<a name="ln3654">	CSR_READ_4(sc, BWI_STATE_LO);</a>
<a name="ln3655">	DELAY(1);</a>
<a name="ln3656"> </a>
<a name="ln3657">	state_hi = CSR_READ_4(sc, BWI_STATE_HI);</a>
<a name="ln3658">	if (state_hi &amp; BWI_STATE_HI_SERROR)</a>
<a name="ln3659">		CSR_WRITE_4(sc, BWI_STATE_HI, 0);</a>
<a name="ln3660"> </a>
<a name="ln3661">	imstate = CSR_READ_4(sc, BWI_IMSTATE);</a>
<a name="ln3662">	if (imstate &amp; (BWI_IMSTATE_INBAND_ERR | BWI_IMSTATE_TIMEOUT)) {</a>
<a name="ln3663">		imstate &amp;= ~(BWI_IMSTATE_INBAND_ERR | BWI_IMSTATE_TIMEOUT);</a>
<a name="ln3664">		CSR_WRITE_4(sc, BWI_IMSTATE, imstate);</a>
<a name="ln3665">	}</a>
<a name="ln3666"> </a>
<a name="ln3667">	/* Enable regwin with gated clock */</a>
<a name="ln3668">	state_lo = BWI_STATE_LO_CLOCK |</a>
<a name="ln3669">		   BWI_STATE_LO_GATED_CLOCK |</a>
<a name="ln3670">		   __SHIFTIN(flags, BWI_STATE_LO_FLAGS_MASK);</a>
<a name="ln3671">	CSR_WRITE_4(sc, BWI_STATE_LO, state_lo);</a>
<a name="ln3672"> </a>
<a name="ln3673">	/* Flush pending bus write */</a>
<a name="ln3674">	CSR_READ_4(sc, BWI_STATE_LO);</a>
<a name="ln3675">	DELAY(1);</a>
<a name="ln3676"> </a>
<a name="ln3677">	/* Enable regwin with normal clock */</a>
<a name="ln3678">	state_lo = BWI_STATE_LO_CLOCK |</a>
<a name="ln3679">		   __SHIFTIN(flags, BWI_STATE_LO_FLAGS_MASK);</a>
<a name="ln3680">	CSR_WRITE_4(sc, BWI_STATE_LO, state_lo);</a>
<a name="ln3681"> </a>
<a name="ln3682">	/* Flush pending bus write */</a>
<a name="ln3683">	CSR_READ_4(sc, BWI_STATE_LO);</a>
<a name="ln3684">	DELAY(1);</a>
<a name="ln3685">}</a>
<a name="ln3686"> </a>
<a name="ln3687">static void</a>
<a name="ln3688">bwi_set_bssid(struct bwi_softc *sc, const uint8_t *bssid)</a>
<a name="ln3689">{</a>
<a name="ln3690">	struct bwi_mac *mac;</a>
<a name="ln3691">	struct bwi_myaddr_bssid buf;</a>
<a name="ln3692">	const uint8_t *p;</a>
<a name="ln3693">	uint32_t val;</a>
<a name="ln3694">	int n, i;</a>
<a name="ln3695"> </a>
<a name="ln3696">	KASSERT(sc-&gt;sc_cur_regwin-&gt;rw_type == BWI_REGWIN_T_MAC,</a>
<a name="ln3697">	    (&quot;current regwin type %d&quot;, sc-&gt;sc_cur_regwin-&gt;rw_type));</a>
<a name="ln3698">	mac = (struct bwi_mac *)sc-&gt;sc_cur_regwin;</a>
<a name="ln3699"> </a>
<a name="ln3700">	bwi_set_addr_filter(sc, BWI_ADDR_FILTER_BSSID, bssid);</a>
<a name="ln3701"> </a>
<a name="ln3702">	bcopy(sc-&gt;sc_ic.ic_macaddr, buf.myaddr, sizeof(buf.myaddr));</a>
<a name="ln3703">	bcopy(bssid, buf.bssid, sizeof(buf.bssid));</a>
<a name="ln3704"> </a>
<a name="ln3705">	n = sizeof(buf) / sizeof(val);</a>
<a name="ln3706">	p = (const uint8_t *)&amp;buf;</a>
<a name="ln3707">	for (i = 0; i &lt; n; ++i) {</a>
<a name="ln3708">		int j;</a>
<a name="ln3709"> </a>
<a name="ln3710">		val = 0;</a>
<a name="ln3711">		for (j = 0; j &lt; sizeof(val); ++j)</a>
<a name="ln3712">			val |= ((uint32_t)(*p++)) &lt;&lt; (j * 8);</a>
<a name="ln3713"> </a>
<a name="ln3714">		TMPLT_WRITE_4(mac, 0x20 + (i * sizeof(val)), val);</a>
<a name="ln3715">	}</a>
<a name="ln3716">}</a>
<a name="ln3717"> </a>
<a name="ln3718">static void</a>
<a name="ln3719">bwi_updateslot(struct ieee80211com *ic)</a>
<a name="ln3720">{</a>
<a name="ln3721">	struct bwi_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln3722">	struct bwi_mac *mac;</a>
<a name="ln3723"> </a>
<a name="ln3724">	BWI_LOCK(sc);</a>
<a name="ln3725">	if (sc-&gt;sc_flags &amp; BWI_F_RUNNING) {</a>
<a name="ln3726">		DPRINTF(sc, BWI_DBG_80211, &quot;%s\n&quot;, __func__);</a>
<a name="ln3727"> </a>
<a name="ln3728">		KASSERT(sc-&gt;sc_cur_regwin-&gt;rw_type == BWI_REGWIN_T_MAC,</a>
<a name="ln3729">		    (&quot;current regwin type %d&quot;, sc-&gt;sc_cur_regwin-&gt;rw_type));</a>
<a name="ln3730">		mac = (struct bwi_mac *)sc-&gt;sc_cur_regwin;</a>
<a name="ln3731"> </a>
<a name="ln3732">		bwi_mac_updateslot(mac, (ic-&gt;ic_flags &amp; IEEE80211_F_SHSLOT));</a>
<a name="ln3733">	}</a>
<a name="ln3734">	BWI_UNLOCK(sc);</a>
<a name="ln3735">}</a>
<a name="ln3736"> </a>
<a name="ln3737">static void</a>
<a name="ln3738">bwi_calibrate(void *xsc)</a>
<a name="ln3739">{</a>
<a name="ln3740">	struct bwi_softc *sc = xsc;</a>
<a name="ln3741">	struct bwi_mac *mac;</a>
<a name="ln3742"> </a>
<a name="ln3743">	BWI_ASSERT_LOCKED(sc);</a>
<a name="ln3744"> </a>
<a name="ln3745">	KASSERT(sc-&gt;sc_ic.ic_opmode != IEEE80211_M_MONITOR,</a>
<a name="ln3746">	    (&quot;opmode %d&quot;, sc-&gt;sc_ic.ic_opmode));</a>
<a name="ln3747"> </a>
<a name="ln3748">	KASSERT(sc-&gt;sc_cur_regwin-&gt;rw_type == BWI_REGWIN_T_MAC,</a>
<a name="ln3749">	    (&quot;current regwin type %d&quot;, sc-&gt;sc_cur_regwin-&gt;rw_type));</a>
<a name="ln3750">	mac = (struct bwi_mac *)sc-&gt;sc_cur_regwin;</a>
<a name="ln3751"> </a>
<a name="ln3752">	bwi_mac_calibrate_txpower(mac, sc-&gt;sc_txpwrcb_type);</a>
<a name="ln3753">	sc-&gt;sc_txpwrcb_type = BWI_TXPWR_CALIB;</a>
<a name="ln3754"> </a>
<a name="ln3755">	/* XXX 15 seconds */</a>
<a name="ln3756">	callout_reset(&amp;sc-&gt;sc_calib_ch, hz * 15, bwi_calibrate, sc);</a>
<a name="ln3757">}</a>
<a name="ln3758"> </a>
<a name="ln3759">static int</a>
<a name="ln3760">bwi_calc_rssi(struct bwi_softc *sc, const struct bwi_rxbuf_hdr *hdr)</a>
<a name="ln3761">{</a>
<a name="ln3762">	struct bwi_mac *mac;</a>
<a name="ln3763"> </a>
<a name="ln3764">	KASSERT(sc-&gt;sc_cur_regwin-&gt;rw_type == BWI_REGWIN_T_MAC,</a>
<a name="ln3765">	    (&quot;current regwin type %d&quot;, sc-&gt;sc_cur_regwin-&gt;rw_type));</a>
<a name="ln3766">	mac = (struct bwi_mac *)sc-&gt;sc_cur_regwin;</a>
<a name="ln3767"> </a>
<a name="ln3768">	return bwi_rf_calc_rssi(mac, hdr);</a>
<a name="ln3769">}</a>
<a name="ln3770"> </a>
<a name="ln3771">static int</a>
<a name="ln3772">bwi_calc_noise(struct bwi_softc *sc)</a>
<a name="ln3773">{</a>
<a name="ln3774">	struct bwi_mac *mac;</a>
<a name="ln3775"> </a>
<a name="ln3776">	KASSERT(sc-&gt;sc_cur_regwin-&gt;rw_type == BWI_REGWIN_T_MAC,</a>
<a name="ln3777">	    (&quot;current regwin type %d&quot;, sc-&gt;sc_cur_regwin-&gt;rw_type));</a>
<a name="ln3778">	mac = (struct bwi_mac *)sc-&gt;sc_cur_regwin;</a>
<a name="ln3779"> </a>
<a name="ln3780">	return bwi_rf_calc_noise(mac);</a>
<a name="ln3781">}</a>
<a name="ln3782"> </a>
<a name="ln3783">static __inline uint8_t</a>
<a name="ln3784">bwi_plcp2rate(const uint32_t plcp0, enum ieee80211_phytype type)</a>
<a name="ln3785">{</a>
<a name="ln3786">	uint32_t plcp = le32toh(plcp0) &amp; IEEE80211_OFDM_PLCP_RATE_MASK;</a>
<a name="ln3787">	return (ieee80211_plcp2rate(plcp, type));</a>
<a name="ln3788">}</a>
<a name="ln3789"> </a>
<a name="ln3790">static void</a>
<a name="ln3791">bwi_rx_radiotap(struct bwi_softc *sc, struct mbuf *m,</a>
<a name="ln3792">    struct bwi_rxbuf_hdr *hdr, const void *plcp, int rate, int rssi, int noise)</a>
<a name="ln3793">{</a>
<a name="ln3794">	const struct ieee80211_frame_min *wh;</a>
<a name="ln3795"> </a>
<a name="ln3796">	sc-&gt;sc_rx_th.wr_flags = IEEE80211_RADIOTAP_F_FCS;</a>
<a name="ln3797">	if (htole16(hdr-&gt;rxh_flags1) &amp; BWI_RXH_F1_SHPREAMBLE)</a>
<a name="ln3798">		sc-&gt;sc_rx_th.wr_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;</a>
<a name="ln3799"> </a>
<a name="ln3800">	wh = mtod(m, const struct ieee80211_frame_min *);</a>
<a name="ln3801">	if (wh-&gt;i_fc[1] &amp; IEEE80211_FC1_PROTECTED)</a>
<a name="ln3802">		sc-&gt;sc_rx_th.wr_flags |= IEEE80211_RADIOTAP_F_WEP;</a>
<a name="ln3803"> </a>
<a name="ln3804">	sc-&gt;sc_rx_th.wr_tsf = hdr-&gt;rxh_tsf; /* No endian conversion */</a>
<a name="ln3805">	sc-&gt;sc_rx_th.wr_rate = rate;</a>
<a name="ln3806">	sc-&gt;sc_rx_th.wr_antsignal = rssi;</a>
<a name="ln3807">	sc-&gt;sc_rx_th.wr_antnoise = noise;</a>
<a name="ln3808">}</a>
<a name="ln3809"> </a>
<a name="ln3810">static void</a>
<a name="ln3811">bwi_led_attach(struct bwi_softc *sc)</a>
<a name="ln3812">{</a>
<a name="ln3813">	const uint8_t *led_act = NULL;</a>
<a name="ln3814">	uint16_t gpio, val[BWI_LED_MAX];</a>
<a name="ln3815">	int i;</a>
<a name="ln3816"> </a>
<a name="ln3817">	for (i = 0; i &lt; nitems(bwi_vendor_led_act); ++i) {</a>
<a name="ln3818">		if (sc-&gt;sc_pci_subvid == bwi_vendor_led_act[i].vid) {</a>
<a name="ln3819">			led_act = bwi_vendor_led_act[i].led_act;</a>
<a name="ln3820">			break;</a>
<a name="ln3821">		}</a>
<a name="ln3822">	}</a>
<a name="ln3823">	if (led_act == NULL)</a>
<a name="ln3824">		led_act = bwi_default_led_act;</a>
<a name="ln3825"> </a>
<a name="ln3826">	gpio = bwi_read_sprom(sc, BWI_SPROM_GPIO01);</a>
<a name="ln3827">	val[0] = __SHIFTOUT(gpio, BWI_SPROM_GPIO_0);</a>
<a name="ln3828">	val[1] = __SHIFTOUT(gpio, BWI_SPROM_GPIO_1);</a>
<a name="ln3829"> </a>
<a name="ln3830">	gpio = bwi_read_sprom(sc, BWI_SPROM_GPIO23);</a>
<a name="ln3831">	val[2] = __SHIFTOUT(gpio, BWI_SPROM_GPIO_2);</a>
<a name="ln3832">	val[3] = __SHIFTOUT(gpio, BWI_SPROM_GPIO_3);</a>
<a name="ln3833"> </a>
<a name="ln3834">	for (i = 0; i &lt; BWI_LED_MAX; ++i) {</a>
<a name="ln3835">		struct bwi_led *led = &amp;sc-&gt;sc_leds[i];</a>
<a name="ln3836"> </a>
<a name="ln3837">		if (val[i] == 0xff) {</a>
<a name="ln3838">			led-&gt;l_act = led_act[i];</a>
<a name="ln3839">		} else {</a>
<a name="ln3840">			if (val[i] &amp; BWI_LED_ACT_LOW)</a>
<a name="ln3841">				led-&gt;l_flags |= BWI_LED_F_ACTLOW;</a>
<a name="ln3842">			led-&gt;l_act = __SHIFTOUT(val[i], BWI_LED_ACT_MASK);</a>
<a name="ln3843">		}</a>
<a name="ln3844">		led-&gt;l_mask = (1 &lt;&lt; i);</a>
<a name="ln3845"> </a>
<a name="ln3846">		if (led-&gt;l_act == BWI_LED_ACT_BLINK_SLOW ||</a>
<a name="ln3847">		    led-&gt;l_act == BWI_LED_ACT_BLINK_POLL ||</a>
<a name="ln3848">		    led-&gt;l_act == BWI_LED_ACT_BLINK) {</a>
<a name="ln3849">			led-&gt;l_flags |= BWI_LED_F_BLINK;</a>
<a name="ln3850">			if (led-&gt;l_act == BWI_LED_ACT_BLINK_POLL)</a>
<a name="ln3851">				led-&gt;l_flags |= BWI_LED_F_POLLABLE;</a>
<a name="ln3852">			else if (led-&gt;l_act == BWI_LED_ACT_BLINK_SLOW)</a>
<a name="ln3853">				led-&gt;l_flags |= BWI_LED_F_SLOW;</a>
<a name="ln3854"> </a>
<a name="ln3855">			if (sc-&gt;sc_blink_led == NULL) {</a>
<a name="ln3856">				sc-&gt;sc_blink_led = led;</a>
<a name="ln3857">				if (led-&gt;l_flags &amp; BWI_LED_F_SLOW)</a>
<a name="ln3858">					BWI_LED_SLOWDOWN(sc-&gt;sc_led_idle);</a>
<a name="ln3859">			}</a>
<a name="ln3860">		}</a>
<a name="ln3861"> </a>
<a name="ln3862">		DPRINTF(sc, BWI_DBG_LED | BWI_DBG_ATTACH,</a>
<a name="ln3863">			&quot;%dth led, act %d, lowact %d\n&quot;, i,</a>
<a name="ln3864">			led-&gt;l_act, led-&gt;l_flags &amp; BWI_LED_F_ACTLOW);</a>
<a name="ln3865">	}</a>
<a name="ln3866">	callout_init_mtx(&amp;sc-&gt;sc_led_blink_ch, &amp;sc-&gt;sc_mtx, 0);</a>
<a name="ln3867">}</a>
<a name="ln3868"> </a>
<a name="ln3869">static __inline uint16_t</a>
<a name="ln3870">bwi_led_onoff(const struct bwi_led *led, uint16_t val, int on)</a>
<a name="ln3871">{</a>
<a name="ln3872">	if (led-&gt;l_flags &amp; BWI_LED_F_ACTLOW)</a>
<a name="ln3873">		on = !on;</a>
<a name="ln3874">	if (on)</a>
<a name="ln3875">		val |= led-&gt;l_mask;</a>
<a name="ln3876">	else</a>
<a name="ln3877">		val &amp;= ~led-&gt;l_mask;</a>
<a name="ln3878">	return val;</a>
<a name="ln3879">}</a>
<a name="ln3880"> </a>
<a name="ln3881">static void</a>
<a name="ln3882">bwi_led_newstate(struct bwi_softc *sc, enum ieee80211_state nstate)</a>
<a name="ln3883">{</a>
<a name="ln3884">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln3885">	uint16_t val;</a>
<a name="ln3886">	int i;</a>
<a name="ln3887"> </a>
<a name="ln3888">	if (nstate == IEEE80211_S_INIT) {</a>
<a name="ln3889">		callout_stop(&amp;sc-&gt;sc_led_blink_ch);</a>
<a name="ln3890">		sc-&gt;sc_led_blinking = 0;</a>
<a name="ln3891">	}</a>
<a name="ln3892"> </a>
<a name="ln3893">	if ((sc-&gt;sc_flags &amp; BWI_F_RUNNING) == 0)</a>
<a name="ln3894">		return;</a>
<a name="ln3895"> </a>
<a name="ln3896">	val = CSR_READ_2(sc, BWI_MAC_GPIO_CTRL);</a>
<a name="ln3897">	for (i = 0; i &lt; BWI_LED_MAX; ++i) {</a>
<a name="ln3898">		struct bwi_led *led = &amp;sc-&gt;sc_leds[i];</a>
<a name="ln3899">		int on;</a>
<a name="ln3900"> </a>
<a name="ln3901">		if (led-&gt;l_act == BWI_LED_ACT_UNKN ||</a>
<a name="ln3902">		    led-&gt;l_act == BWI_LED_ACT_NULL)</a>
<a name="ln3903">			continue;</a>
<a name="ln3904"> </a>
<a name="ln3905">		if ((led-&gt;l_flags &amp; BWI_LED_F_BLINK) &amp;&amp;</a>
<a name="ln3906">		    nstate != IEEE80211_S_INIT)</a>
<a name="ln3907">		    	continue;</a>
<a name="ln3908"> </a>
<a name="ln3909">		switch (led-&gt;l_act) {</a>
<a name="ln3910">		case BWI_LED_ACT_ON:	/* Always on */</a>
<a name="ln3911">			on = 1;</a>
<a name="ln3912">			break;</a>
<a name="ln3913">		case BWI_LED_ACT_OFF:	/* Always off */</a>
<a name="ln3914">		case BWI_LED_ACT_5GHZ:	/* TODO: 11A */</a>
<a name="ln3915">			on = 0;</a>
<a name="ln3916">			break;</a>
<a name="ln3917">		default:</a>
<a name="ln3918">			on = 1;</a>
<a name="ln3919">			switch (nstate) {</a>
<a name="ln3920">			case IEEE80211_S_INIT:</a>
<a name="ln3921">				on = 0;</a>
<a name="ln3922">				break;</a>
<a name="ln3923">			case IEEE80211_S_RUN:</a>
<a name="ln3924">				if (led-&gt;l_act == BWI_LED_ACT_11G &amp;&amp;</a>
<a name="ln3925">				    ic-&gt;ic_curmode != IEEE80211_MODE_11G)</a>
<a name="ln3926">					on = 0;</a>
<a name="ln3927">				break;</a>
<a name="ln3928">			default:</a>
<a name="ln3929">				if (led-&gt;l_act == BWI_LED_ACT_ASSOC)</a>
<a name="ln3930">					on = 0;</a>
<a name="ln3931">				break;</a>
<a name="ln3932">			}</a>
<a name="ln3933">			break;</a>
<a name="ln3934">		}</a>
<a name="ln3935"> </a>
<a name="ln3936">		val = bwi_led_onoff(led, val, on);</a>
<a name="ln3937">	}</a>
<a name="ln3938">	CSR_WRITE_2(sc, BWI_MAC_GPIO_CTRL, val);</a>
<a name="ln3939">}</a>
<a name="ln3940">static void</a>
<a name="ln3941">bwi_led_event(struct bwi_softc *sc, int event)</a>
<a name="ln3942">{</a>
<a name="ln3943">	struct bwi_led *led = sc-&gt;sc_blink_led;</a>
<a name="ln3944">	int rate;</a>
<a name="ln3945"> </a>
<a name="ln3946">	if (event == BWI_LED_EVENT_POLL) {</a>
<a name="ln3947">		if ((led-&gt;l_flags &amp; BWI_LED_F_POLLABLE) == 0)</a>
<a name="ln3948">			return;</a>
<a name="ln3949">		if (ticks - sc-&gt;sc_led_ticks &lt; sc-&gt;sc_led_idle)</a>
<a name="ln3950">			return;</a>
<a name="ln3951">	}</a>
<a name="ln3952"> </a>
<a name="ln3953">	sc-&gt;sc_led_ticks = ticks;</a>
<a name="ln3954">	if (sc-&gt;sc_led_blinking)</a>
<a name="ln3955">		return;</a>
<a name="ln3956"> </a>
<a name="ln3957">	switch (event) {</a>
<a name="ln3958">	case BWI_LED_EVENT_RX:</a>
<a name="ln3959">		rate = sc-&gt;sc_rx_rate;</a>
<a name="ln3960">		break;</a>
<a name="ln3961">	case BWI_LED_EVENT_TX:</a>
<a name="ln3962">		rate = sc-&gt;sc_tx_rate;</a>
<a name="ln3963">		break;</a>
<a name="ln3964">	case BWI_LED_EVENT_POLL:</a>
<a name="ln3965">		rate = 0;</a>
<a name="ln3966">		break;</a>
<a name="ln3967">	default:</a>
<a name="ln3968">		panic(&quot;unknown LED event %d\n&quot;, event);</a>
<a name="ln3969">		break;</a>
<a name="ln3970">	}</a>
<a name="ln3971">	bwi_led_blink_start(sc, bwi_led_duration[rate].on_dur,</a>
<a name="ln3972">	    bwi_led_duration[rate].off_dur);</a>
<a name="ln3973">}</a>
<a name="ln3974"> </a>
<a name="ln3975">static void</a>
<a name="ln3976">bwi_led_blink_start(struct bwi_softc *sc, int on_dur, int off_dur)</a>
<a name="ln3977">{</a>
<a name="ln3978">	struct bwi_led *led = sc-&gt;sc_blink_led;</a>
<a name="ln3979">	uint16_t val;</a>
<a name="ln3980"> </a>
<a name="ln3981">	val = CSR_READ_2(sc, BWI_MAC_GPIO_CTRL);</a>
<a name="ln3982">	val = bwi_led_onoff(led, val, 1);</a>
<a name="ln3983">	CSR_WRITE_2(sc, BWI_MAC_GPIO_CTRL, val);</a>
<a name="ln3984"> </a>
<a name="ln3985">	if (led-&gt;l_flags &amp; BWI_LED_F_SLOW) {</a>
<a name="ln3986">		BWI_LED_SLOWDOWN(on_dur);</a>
<a name="ln3987">		BWI_LED_SLOWDOWN(off_dur);</a>
<a name="ln3988">	}</a>
<a name="ln3989"> </a>
<a name="ln3990">	sc-&gt;sc_led_blinking = 1;</a>
<a name="ln3991">	sc-&gt;sc_led_blink_offdur = off_dur;</a>
<a name="ln3992"> </a>
<a name="ln3993">	callout_reset(&amp;sc-&gt;sc_led_blink_ch, on_dur, bwi_led_blink_next, sc);</a>
<a name="ln3994">}</a>
<a name="ln3995"> </a>
<a name="ln3996">static void</a>
<a name="ln3997">bwi_led_blink_next(void *xsc)</a>
<a name="ln3998">{</a>
<a name="ln3999">	struct bwi_softc *sc = xsc;</a>
<a name="ln4000">	uint16_t val;</a>
<a name="ln4001"> </a>
<a name="ln4002">	val = CSR_READ_2(sc, BWI_MAC_GPIO_CTRL);</a>
<a name="ln4003">	val = bwi_led_onoff(sc-&gt;sc_blink_led, val, 0);</a>
<a name="ln4004">	CSR_WRITE_2(sc, BWI_MAC_GPIO_CTRL, val);</a>
<a name="ln4005"> </a>
<a name="ln4006">	callout_reset(&amp;sc-&gt;sc_led_blink_ch, sc-&gt;sc_led_blink_offdur,</a>
<a name="ln4007">	    bwi_led_blink_end, sc);</a>
<a name="ln4008">}</a>
<a name="ln4009"> </a>
<a name="ln4010">static void</a>
<a name="ln4011">bwi_led_blink_end(void *xsc)</a>
<a name="ln4012">{</a>
<a name="ln4013">	struct bwi_softc *sc = xsc;</a>
<a name="ln4014">	sc-&gt;sc_led_blinking = 0;</a>
<a name="ln4015">}</a>
<a name="ln4016"> </a>
<a name="ln4017">static void</a>
<a name="ln4018">bwi_restart(void *xsc, int pending)</a>
<a name="ln4019">{</a>
<a name="ln4020">	struct bwi_softc *sc = xsc;</a>
<a name="ln4021"> </a>
<a name="ln4022">	device_printf(sc-&gt;sc_dev, &quot;%s begin, help!\n&quot;, __func__);</a>
<a name="ln4023">	BWI_LOCK(sc);</a>
<a name="ln4024">	bwi_init_statechg(sc, 0);</a>
<a name="ln4025">#if 0</a>
<a name="ln4026">	bwi_start_locked(sc);</a>
<a name="ln4027">#endif</a>
<a name="ln4028">	BWI_UNLOCK(sc);</a>
<a name="ln4029">}</a>

</code></pre>
<div class="balloon" rel="1372"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'ni' pointer was utilized before it was verified against nullptr. Check lines: 1372, 1380.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
