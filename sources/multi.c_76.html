
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>multi.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Auvia BeOS Driver for Via VT82xx Southbridge audio</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2003, Jerome Duval (jerome.duval@free.fr)</a>
<a name="ln5"> *</a>
<a name="ln6"> * Original code : BeOS Driver for Intel ICH AC'97 Link interface</a>
<a name="ln7"> * Copyright (c) 2002, Marcus Overhagen &lt;marcus@overhagen.de&gt;</a>
<a name="ln8"> *</a>
<a name="ln9"> * All rights reserved.</a>
<a name="ln10"> * Redistribution and use in source and binary forms, with or without modification,</a>
<a name="ln11"> * are permitted provided that the following conditions are met:</a>
<a name="ln12"> *</a>
<a name="ln13"> * - Redistributions of source code must retain the above copyright notice,</a>
<a name="ln14"> *   this list of conditions and the following disclaimer.</a>
<a name="ln15"> * - Redistributions in binary form must reproduce the above copyright notice,</a>
<a name="ln16"> *   this list of conditions and the following disclaimer in the documentation</a>
<a name="ln17"> *   and/or other materials provided with the distribution.</a>
<a name="ln18"> *</a>
<a name="ln19"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND</a>
<a name="ln20"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</a>
<a name="ln21"> * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</a>
<a name="ln22"> * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR</a>
<a name="ln23"> * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</a>
<a name="ln24"> * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS</a>
<a name="ln25"> * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</a>
<a name="ln26"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</a>
<a name="ln27"> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,</a>
<a name="ln28"> * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln29"> *</a>
<a name="ln30"> */</a>
<a name="ln31"> </a>
<a name="ln32">#include &lt;OS.h&gt;</a>
<a name="ln33">#include &lt;string.h&gt;</a>
<a name="ln34">#include &lt;MediaDefs.h&gt;</a>
<a name="ln35">#include &quot;hmulti_audio.h&quot;</a>
<a name="ln36">#include &quot;multi.h&quot;</a>
<a name="ln37">#include &quot;ac97.h&quot;</a>
<a name="ln38"> </a>
<a name="ln39">//#define DEBUG 1</a>
<a name="ln40"> </a>
<a name="ln41">#include &quot;debug.h&quot;</a>
<a name="ln42">#include &quot;auvia.h&quot;</a>
<a name="ln43">#include &quot;util.h&quot;</a>
<a name="ln44">#include &quot;io.h&quot;</a>
<a name="ln45"> </a>
<a name="ln46"> </a>
<a name="ln47">static void</a>
<a name="ln48">auvia_ac97_get_mix(void *card, const void *cookie, int32 type, float *values) {</a>
<a name="ln49">	auvia_dev *dev = (auvia_dev*)card;</a>
<a name="ln50">	ac97_source_info *info = (ac97_source_info *)cookie;</a>
<a name="ln51">	uint16 value, mask;</a>
<a name="ln52">	float gain;</a>
<a name="ln53"> </a>
<a name="ln54">	switch (type) {</a>
<a name="ln55">		case B_MIX_GAIN:</a>
<a name="ln56">			value = auvia_codec_read(&amp;dev-&gt;config, info-&gt;reg);</a>
<a name="ln57">			//PRINT((&quot;B_MIX_GAIN value : %u\n&quot;, value));</a>
<a name="ln58">			if (info-&gt;type &amp; B_MIX_STEREO) {</a>
<a name="ln59">				mask = ((1 &lt;&lt; (info-&gt;bits + 1)) - 1) &lt;&lt; 8;</a>
<a name="ln60">				gain = ((value &amp; mask) &gt;&gt; 8) * info-&gt;granularity;</a>
<a name="ln61">				if (info-&gt;polarity == 1)</a>
<a name="ln62">					values[0] = info-&gt;max_gain - gain;</a>
<a name="ln63">				else</a>
<a name="ln64">					values[0] = gain - info-&gt;min_gain;</a>
<a name="ln65"> </a>
<a name="ln66">				mask = ((1 &lt;&lt; (info-&gt;bits + 1)) - 1);</a>
<a name="ln67">				gain = (value &amp; mask) * info-&gt;granularity;</a>
<a name="ln68">				if (info-&gt;polarity == 1)</a>
<a name="ln69">					values[1] = info-&gt;max_gain - gain;</a>
<a name="ln70">				else</a>
<a name="ln71">					values[1] = gain - info-&gt;min_gain;</a>
<a name="ln72">			} else {</a>
<a name="ln73">				mask = ((1 &lt;&lt; (info-&gt;bits + 1)) - 1);</a>
<a name="ln74">				gain = (value &amp; mask) * info-&gt;granularity;</a>
<a name="ln75">				if (info-&gt;polarity == 1)</a>
<a name="ln76">					values[0] = info-&gt;max_gain - gain;</a>
<a name="ln77">				else</a>
<a name="ln78">					values[0] = gain - info-&gt;min_gain;</a>
<a name="ln79">			}</a>
<a name="ln80">			break;</a>
<a name="ln81">		case B_MIX_MUTE:</a>
<a name="ln82">			mask = ((1 &lt;&lt; 1) - 1) &lt;&lt; 15;</a>
<a name="ln83">			value = auvia_codec_read(&amp;dev-&gt;config, info-&gt;reg);</a>
<a name="ln84">			//PRINT((&quot;B_MIX_MUTE value : %u\n&quot;, value));</a>
<a name="ln85">			value &amp;= mask;</a>
<a name="ln86">			values[0] = ((value &gt;&gt; 15) == 1) ? 1.0 : 0.0;</a>
<a name="ln87">			break;</a>
<a name="ln88">		case B_MIX_MICBOOST:</a>
<a name="ln89">			mask = ((1 &lt;&lt; 1) - 1) &lt;&lt; 6;</a>
<a name="ln90">			value = auvia_codec_read(&amp;dev-&gt;config, info-&gt;reg);</a>
<a name="ln91">			//PRINT((&quot;B_MIX_MICBOOST value : %u\n&quot;, value));</a>
<a name="ln92">			value &amp;= mask;</a>
<a name="ln93">			values[0] = ((value &gt;&gt; 6) == 1) ? 1.0 : 0.0;</a>
<a name="ln94">			break;</a>
<a name="ln95">		case B_MIX_MUX:</a>
<a name="ln96">			mask = ((1 &lt;&lt; 3) - 1);</a>
<a name="ln97">			value = auvia_codec_read(&amp;dev-&gt;config, AC97_RECORD_SELECT);</a>
<a name="ln98">			value &amp;= mask;</a>
<a name="ln99">			//PRINT((&quot;B_MIX_MUX value : %u\n&quot;, value));</a>
<a name="ln100">			values[0] = (float)value;</a>
<a name="ln101">			break;</a>
<a name="ln102">	}</a>
<a name="ln103">}</a>
<a name="ln104"> </a>
<a name="ln105">static void</a>
<a name="ln106">auvia_ac97_set_mix(void *card, const void *cookie, int32 type, float *values) {</a>
<a name="ln107">	auvia_dev *dev = (auvia_dev*)card;</a>
<a name="ln108">	ac97_source_info *info = (ac97_source_info *)cookie;</a>
<a name="ln109">	uint16 value, mask;</a>
<a name="ln110">	float gain;</a>
<a name="ln111"> </a>
<a name="ln112">	switch (type) {</a>
<a name="ln113">		case B_MIX_GAIN:</a>
<a name="ln114">			value = auvia_codec_read(&amp;dev-&gt;config, info-&gt;reg);</a>
<a name="ln115">			if (info-&gt;type &amp; B_MIX_STEREO) {</a>
<a name="ln116">				mask = ((1 &lt;&lt; (info-&gt;bits + 1)) - 1) &lt;&lt; 8;</a>
<a name="ln117">				value &amp;= ~mask;</a>
<a name="ln118"> </a>
<a name="ln119">				if (info-&gt;polarity == 1)</a>
<a name="ln120">					gain = info-&gt;max_gain - values[0];</a>
<a name="ln121">				else</a>
<a name="ln122">					gain =  values[0] - info-&gt;min_gain;</a>
<a name="ln123">				value |= ((uint16)(gain	/ info-&gt;granularity) &lt;&lt; 8) &amp; mask;</a>
<a name="ln124"> </a>
<a name="ln125">				mask = ((1 &lt;&lt; (info-&gt;bits + 1)) - 1);</a>
<a name="ln126">				value &amp;= ~mask;</a>
<a name="ln127">				if (info-&gt;polarity == 1)</a>
<a name="ln128">					gain = info-&gt;max_gain - values[1];</a>
<a name="ln129">				else</a>
<a name="ln130">					gain =  values[1] - info-&gt;min_gain;</a>
<a name="ln131">				value |= ((uint16)(gain / info-&gt;granularity)) &amp; mask;</a>
<a name="ln132">			} else {</a>
<a name="ln133">				mask = ((1 &lt;&lt; (info-&gt;bits + 1)) - 1);</a>
<a name="ln134">				value &amp;= ~mask;</a>
<a name="ln135">				if (info-&gt;polarity == 1)</a>
<a name="ln136">					gain = info-&gt;max_gain - values[0];</a>
<a name="ln137">				else</a>
<a name="ln138">					gain =  values[0] - info-&gt;min_gain;</a>
<a name="ln139">				value |= ((uint16)(gain / info-&gt;granularity)) &amp; mask;</a>
<a name="ln140">			}</a>
<a name="ln141">			//PRINT((&quot;B_MIX_GAIN value : %u\n&quot;, value));</a>
<a name="ln142">			auvia_codec_write(&amp;dev-&gt;config, info-&gt;reg, value);</a>
<a name="ln143">			break;</a>
<a name="ln144">		case B_MIX_MUTE:</a>
<a name="ln145">			mask = ((1 &lt;&lt; 1) - 1) &lt;&lt; 15;</a>
<a name="ln146">			value = auvia_codec_read(&amp;dev-&gt;config, info-&gt;reg);</a>
<a name="ln147">			value &amp;= ~mask;</a>
<a name="ln148">			value |= ((values[0] == 1.0 ? 1 : 0 ) &lt;&lt; 15 &amp; mask);</a>
<a name="ln149">			if (info-&gt;reg == AC97_SURR_VOLUME) {</a>
<a name="ln150">				// there is a independent mute for each channel</a>
<a name="ln151">				mask = ((1 &lt;&lt; 1) - 1) &lt;&lt; 7;</a>
<a name="ln152">				value &amp;= ~mask;</a>
<a name="ln153">				value |= ((values[0] == 1.0 ? 1 : 0 ) &lt;&lt; 7 &amp; mask);</a>
<a name="ln154">			}</a>
<a name="ln155">			//PRINT((&quot;B_MIX_MUTE value : %u\n&quot;, value));</a>
<a name="ln156">			auvia_codec_write(&amp;dev-&gt;config, info-&gt;reg, value);</a>
<a name="ln157">			break;</a>
<a name="ln158">		case B_MIX_MICBOOST:</a>
<a name="ln159">			mask = ((1 &lt;&lt; 1) - 1) &lt;&lt; 6;</a>
<a name="ln160">			value = auvia_codec_read(&amp;dev-&gt;config, info-&gt;reg);</a>
<a name="ln161">			value &amp;= ~mask;</a>
<a name="ln162">			value |= ((values[0] == 1.0 ? 1 : 0 ) &lt;&lt; 6 &amp; mask);</a>
<a name="ln163">			//PRINT((&quot;B_MIX_MICBOOST value : %u\n&quot;, value));</a>
<a name="ln164">			auvia_codec_write(&amp;dev-&gt;config, info-&gt;reg, value);</a>
<a name="ln165">			break;</a>
<a name="ln166">		case B_MIX_MUX:</a>
<a name="ln167">			mask = ((1 &lt;&lt; 3) - 1);</a>
<a name="ln168">			value = ((int32)values[0]) &amp; mask;</a>
<a name="ln169">			value = value | (value &lt;&lt; 8);</a>
<a name="ln170">			//PRINT((&quot;B_MIX_MUX value : %u\n&quot;, value));</a>
<a name="ln171">			auvia_codec_write(&amp;dev-&gt;config, AC97_RECORD_SELECT, value);</a>
<a name="ln172">			break;</a>
<a name="ln173">	}</a>
<a name="ln174"> </a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177"> </a>
<a name="ln178">static int32</a>
<a name="ln179">auvia_create_group_control(multi_dev *multi, int32 *index, int32 parent,</a>
<a name="ln180">	int32 string, const char* name)</a>
<a name="ln181">{</a>
<a name="ln182">	int32 i = *index;</a>
<a name="ln183">	(*index)++;</a>
<a name="ln184">	multi-&gt;controls[i].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + i;</a>
<a name="ln185">	multi-&gt;controls[i].mix_control.parent = parent;</a>
<a name="ln186">	multi-&gt;controls[i].mix_control.flags = B_MULTI_MIX_GROUP;</a>
<a name="ln187">	multi-&gt;controls[i].mix_control.master = EMU_MULTI_CONTROL_MASTERID;</a>
<a name="ln188">	multi-&gt;controls[i].mix_control.string = string;</a>
<a name="ln189">	if (name)</a>
<a name="ln190">		strlcpy(multi-&gt;controls[i].mix_control.name, name,</a>
<a name="ln191">			sizeof(multi-&gt;controls[i].mix_control.name));</a>
<a name="ln192"> </a>
<a name="ln193">	return multi-&gt;controls[i].mix_control.id;</a>
<a name="ln194">}</a>
<a name="ln195"> </a>
<a name="ln196"> </a>
<a name="ln197">static status_t</a>
<a name="ln198">auvia_create_controls_list(multi_dev *multi)</a>
<a name="ln199">{</a>
<a name="ln200">	uint32 	i = 0, index = 0, count, id, parent, parent2, parent3;</a>
<a name="ln201">	auvia_dev *card = (auvia_dev*)multi-&gt;card;</a>
<a name="ln202">	const ac97_source_info *info;</a>
<a name="ln203"> </a>
<a name="ln204">	parent = auvia_create_group_control(multi, &amp;index, 0, 0, &quot;Record&quot;);</a>
<a name="ln205"> </a>
<a name="ln206">	/* AC97 Record */</a>
<a name="ln207">	info = &amp;source_info[0];</a>
<a name="ln208">	PRINT((&quot;name : %s\n&quot;, info-&gt;name));</a>
<a name="ln209"> </a>
<a name="ln210">	parent2 = auvia_create_group_control(multi, &amp;index, parent, 0, info-&gt;name);</a>
<a name="ln211"> </a>
<a name="ln212">	if (info-&gt;type &amp; B_MIX_GAIN) {</a>
<a name="ln213">		if (info-&gt;type &amp; B_MIX_MUTE) {</a>
<a name="ln214">			multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln215">			multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_ENABLE;</a>
<a name="ln216">			multi-&gt;controls[index].mix_control.master = EMU_MULTI_CONTROL_MASTERID;</a>
<a name="ln217">			multi-&gt;controls[index].mix_control.parent = parent2;</a>
<a name="ln218">			multi-&gt;controls[index].mix_control.string = S_MUTE;</a>
<a name="ln219">			multi-&gt;controls[index].cookie = info;</a>
<a name="ln220">			multi-&gt;controls[index].type = B_MIX_MUTE;</a>
<a name="ln221">			multi-&gt;controls[index].get = &amp;auvia_ac97_get_mix;</a>
<a name="ln222">			multi-&gt;controls[index].set = &amp;auvia_ac97_set_mix;</a>
<a name="ln223">			index++;</a>
<a name="ln224">		}</a>
<a name="ln225"> </a>
<a name="ln226">		multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln227">		multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_GAIN;</a>
<a name="ln228">		multi-&gt;controls[index].mix_control.master = EMU_MULTI_CONTROL_MASTERID;</a>
<a name="ln229">		multi-&gt;controls[index].mix_control.parent = parent2;</a>
<a name="ln230">		strlcpy(multi-&gt;controls[index].mix_control.name, info-&gt;name,</a>
<a name="ln231">			sizeof(multi-&gt;controls[index].mix_control.name));</a>
<a name="ln232">		multi-&gt;controls[index].mix_control.u.gain.min_gain = info-&gt;min_gain;</a>
<a name="ln233">		multi-&gt;controls[index].mix_control.u.gain.max_gain = info-&gt;max_gain;</a>
<a name="ln234">		multi-&gt;controls[index].mix_control.u.gain.granularity = info-&gt;granularity;</a>
<a name="ln235">		multi-&gt;controls[index].cookie = info;</a>
<a name="ln236">		multi-&gt;controls[index].type = B_MIX_GAIN;</a>
<a name="ln237">		multi-&gt;controls[index].get = &amp;auvia_ac97_get_mix;</a>
<a name="ln238">		multi-&gt;controls[index].set = &amp;auvia_ac97_set_mix;</a>
<a name="ln239">		id = multi-&gt;controls[index].mix_control.id;</a>
<a name="ln240">		index++;</a>
<a name="ln241"> </a>
<a name="ln242">		if (info-&gt;type &amp; B_MIX_STEREO) {</a>
<a name="ln243">			multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln244">			multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_GAIN;</a>
<a name="ln245">			multi-&gt;controls[index].mix_control.master = id;</a>
<a name="ln246">			multi-&gt;controls[index].mix_control.parent = parent2;</a>
<a name="ln247">			strlcpy(multi-&gt;controls[index].mix_control.name, info-&gt;name,</a>
<a name="ln248">				sizeof(multi-&gt;controls[index].mix_control.name));</a>
<a name="ln249">			multi-&gt;controls[index].mix_control.u.gain.min_gain = info-&gt;min_gain;</a>
<a name="ln250">			multi-&gt;controls[index].mix_control.u.gain.max_gain = info-&gt;max_gain;</a>
<a name="ln251">			multi-&gt;controls[index].mix_control.u.gain.granularity = info-&gt;granularity;</a>
<a name="ln252">			multi-&gt;controls[index].cookie = info;</a>
<a name="ln253">			multi-&gt;controls[index].type = B_MIX_GAIN;</a>
<a name="ln254">			multi-&gt;controls[index].get = &amp;auvia_ac97_get_mix;</a>
<a name="ln255">			multi-&gt;controls[index].set = &amp;auvia_ac97_set_mix;</a>
<a name="ln256">			index++;</a>
<a name="ln257">		}</a>
<a name="ln258"> </a>
<a name="ln259">		if (info-&gt;type &amp; B_MIX_RECORDMUX) {</a>
<a name="ln260">			multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln261">			multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_MUX;</a>
<a name="ln262">			multi-&gt;controls[index].mix_control.parent = parent2;</a>
<a name="ln263">			strcpy(multi-&gt;controls[index].mix_control.name, &quot;Record mux&quot;);</a>
<a name="ln264">			multi-&gt;controls[index].cookie = info;</a>
<a name="ln265">			multi-&gt;controls[index].type = B_MIX_MUX;</a>
<a name="ln266">			multi-&gt;controls[index].get = &amp;auvia_ac97_get_mix;</a>
<a name="ln267">			multi-&gt;controls[index].set = &amp;auvia_ac97_set_mix;</a>
<a name="ln268">			parent3 = multi-&gt;controls[index].mix_control.id;</a>
<a name="ln269">			index++;</a>
<a name="ln270"> </a>
<a name="ln271">			multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln272">			multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_MUX_VALUE;</a>
<a name="ln273">			multi-&gt;controls[index].mix_control.parent = parent3;</a>
<a name="ln274">			multi-&gt;controls[index].mix_control.string = S_MIC;</a>
<a name="ln275">			index++;</a>
<a name="ln276">			multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln277">			multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_MUX_VALUE;</a>
<a name="ln278">			multi-&gt;controls[index].mix_control.parent = parent3;</a>
<a name="ln279">			strcpy(multi-&gt;controls[index].mix_control.name, &quot;CD in&quot;);</a>
<a name="ln280">			index++;</a>
<a name="ln281">			multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln282">			multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_MUX_VALUE;</a>
<a name="ln283">			multi-&gt;controls[index].mix_control.parent = parent3;</a>
<a name="ln284">			strcpy(multi-&gt;controls[index].mix_control.name, &quot;Video in&quot;);</a>
<a name="ln285">			index++;</a>
<a name="ln286">			multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln287">			multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_MUX_VALUE;</a>
<a name="ln288">			multi-&gt;controls[index].mix_control.parent = parent3;</a>
<a name="ln289">			strcpy(multi-&gt;controls[index].mix_control.name, &quot;Aux in&quot;);</a>
<a name="ln290">			index++;</a>
<a name="ln291">			multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln292">			multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_MUX_VALUE;</a>
<a name="ln293">			multi-&gt;controls[index].mix_control.parent = parent3;</a>
<a name="ln294">			strcpy(multi-&gt;controls[index].mix_control.name, &quot;Line in&quot;);</a>
<a name="ln295">			index++;</a>
<a name="ln296">			multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln297">			multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_MUX_VALUE;</a>
<a name="ln298">			multi-&gt;controls[index].mix_control.parent = parent3;</a>
<a name="ln299">			multi-&gt;controls[index].mix_control.string = S_STEREO_MIX;</a>
<a name="ln300">			index++;</a>
<a name="ln301">			multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln302">			multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_MUX_VALUE;</a>
<a name="ln303">			multi-&gt;controls[index].mix_control.parent = parent3;</a>
<a name="ln304">			multi-&gt;controls[index].mix_control.string = S_MONO_MIX;</a>
<a name="ln305">			index++;</a>
<a name="ln306">			multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln307">			multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_MUX_VALUE;</a>
<a name="ln308">			multi-&gt;controls[index].mix_control.parent = parent3;</a>
<a name="ln309">			strcpy(multi-&gt;controls[index].mix_control.name, &quot;TAD&quot;);</a>
<a name="ln310">			index++;</a>
<a name="ln311">		}</a>
<a name="ln312">	}</a>
<a name="ln313"> </a>
<a name="ln314">	parent = auvia_create_group_control(multi, &amp;index, 0, 0, &quot;AC97 mixer&quot;);</a>
<a name="ln315"> </a>
<a name="ln316">	count = source_info_size;</a>
<a name="ln317">	count--;</a>
<a name="ln318"> </a>
<a name="ln319">	for (i = 1; i &lt; count ; i++) {</a>
<a name="ln320">		info = &amp;source_info[i];</a>
<a name="ln321">		PRINT((&quot;name : %s\n&quot;, info-&gt;name));</a>
<a name="ln322"> </a>
<a name="ln323">		parent2 = auvia_create_group_control(multi, &amp;index, parent, 0, info-&gt;name);</a>
<a name="ln324"> </a>
<a name="ln325">		if (info-&gt;type &amp; B_MIX_GAIN) {</a>
<a name="ln326">			if (info-&gt;type &amp; B_MIX_MUTE) {</a>
<a name="ln327">				multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln328">				multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_ENABLE;</a>
<a name="ln329">				multi-&gt;controls[index].mix_control.master = EMU_MULTI_CONTROL_MASTERID;</a>
<a name="ln330">				multi-&gt;controls[index].mix_control.parent = parent2;</a>
<a name="ln331">				multi-&gt;controls[index].mix_control.string = S_MUTE;</a>
<a name="ln332">				multi-&gt;controls[index].cookie = info;</a>
<a name="ln333">				multi-&gt;controls[index].type = B_MIX_MUTE;</a>
<a name="ln334">				multi-&gt;controls[index].get = &amp;auvia_ac97_get_mix;</a>
<a name="ln335">				multi-&gt;controls[index].set = &amp;auvia_ac97_set_mix;</a>
<a name="ln336">				index++;</a>
<a name="ln337">			}</a>
<a name="ln338"> </a>
<a name="ln339">			multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln340">			multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_GAIN;</a>
<a name="ln341">			multi-&gt;controls[index].mix_control.master = EMU_MULTI_CONTROL_MASTERID;</a>
<a name="ln342">			multi-&gt;controls[index].mix_control.parent = parent2;</a>
<a name="ln343">			strlcpy(multi-&gt;controls[index].mix_control.name, info-&gt;name,</a>
<a name="ln344">				sizeof(multi-&gt;controls[index].mix_control.name));</a>
<a name="ln345">			multi-&gt;controls[index].mix_control.u.gain.min_gain = info-&gt;min_gain;</a>
<a name="ln346">			multi-&gt;controls[index].mix_control.u.gain.max_gain = info-&gt;max_gain;</a>
<a name="ln347">			multi-&gt;controls[index].mix_control.u.gain.granularity = info-&gt;granularity;</a>
<a name="ln348">			multi-&gt;controls[index].cookie = info;</a>
<a name="ln349">			multi-&gt;controls[index].type = B_MIX_GAIN;</a>
<a name="ln350">			multi-&gt;controls[index].get = &amp;auvia_ac97_get_mix;</a>
<a name="ln351">			multi-&gt;controls[index].set = &amp;auvia_ac97_set_mix;</a>
<a name="ln352">			id = multi-&gt;controls[index].mix_control.id;</a>
<a name="ln353">			index++;</a>
<a name="ln354"> </a>
<a name="ln355">			if (info-&gt;type &amp; B_MIX_STEREO) {</a>
<a name="ln356">				multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln357">				multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_GAIN;</a>
<a name="ln358">				multi-&gt;controls[index].mix_control.master = id;</a>
<a name="ln359">				multi-&gt;controls[index].mix_control.parent = parent2;</a>
<a name="ln360">				strlcpy(multi-&gt;controls[index].mix_control.name, info-&gt;name,</a>
<a name="ln361">					sizeof(multi-&gt;controls[index].mix_control.name));</a>
<a name="ln362">				multi-&gt;controls[index].mix_control.u.gain.min_gain = info-&gt;min_gain;</a>
<a name="ln363">				multi-&gt;controls[index].mix_control.u.gain.max_gain = info-&gt;max_gain;</a>
<a name="ln364">				multi-&gt;controls[index].mix_control.u.gain.granularity = info-&gt;granularity;</a>
<a name="ln365">				multi-&gt;controls[index].cookie = info;</a>
<a name="ln366">				multi-&gt;controls[index].type = B_MIX_GAIN;</a>
<a name="ln367">				multi-&gt;controls[index].get = &amp;auvia_ac97_get_mix;</a>
<a name="ln368">				multi-&gt;controls[index].set = &amp;auvia_ac97_set_mix;</a>
<a name="ln369">				index++;</a>
<a name="ln370">			}</a>
<a name="ln371">		}</a>
<a name="ln372">	}</a>
<a name="ln373"> </a>
<a name="ln374">	parent = auvia_create_group_control(multi, &amp;index, 0, S_SETUP, NULL);</a>
<a name="ln375"> </a>
<a name="ln376">	/* AC97 20db Boost Mic */</a>
<a name="ln377">	info = &amp;source_info[6];</a>
<a name="ln378"> </a>
<a name="ln379">	if (info-&gt;type &amp; B_MIX_GAIN &amp;&amp; info-&gt;type &amp; B_MIX_MICBOOST) {</a>
<a name="ln380">		multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln381">		multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_ENABLE;</a>
<a name="ln382">		multi-&gt;controls[index].mix_control.master = EMU_MULTI_CONTROL_MASTERID;</a>
<a name="ln383">		multi-&gt;controls[index].mix_control.parent = parent;</a>
<a name="ln384">		strcpy(multi-&gt;controls[index].mix_control.name, &quot;Mic +20dB&quot;);</a>
<a name="ln385">		multi-&gt;controls[index].cookie = info;</a>
<a name="ln386">		multi-&gt;controls[index].type = B_MIX_MICBOOST;</a>
<a name="ln387">		multi-&gt;controls[index].get = &amp;auvia_ac97_get_mix;</a>
<a name="ln388">		multi-&gt;controls[index].set = &amp;auvia_ac97_set_mix;</a>
<a name="ln389">		index++;</a>
<a name="ln390">	}</a>
<a name="ln391"> </a>
<a name="ln392">	multi-&gt;control_count = index;</a>
<a name="ln393">	PRINT((&quot;multi-&gt;control_count %lu\n&quot;, multi-&gt;control_count));</a>
<a name="ln394">	return B_OK;</a>
<a name="ln395">}</a>
<a name="ln396"> </a>
<a name="ln397"> </a>
<a name="ln398">static status_t</a>
<a name="ln399">auvia_get_mix(auvia_dev *card, multi_mix_value_info * mmvi)</a>
<a name="ln400">{</a>
<a name="ln401">	int32 i, id;</a>
<a name="ln402">	multi_mixer_control *control = NULL;</a>
<a name="ln403">	for (i = 0; i &lt; mmvi-&gt;item_count; i++) {</a>
<a name="ln404">		id = mmvi-&gt;values[i].id - EMU_MULTI_CONTROL_FIRSTID;</a>
<a name="ln405">		if (id &lt; 0 || id &gt;= card-&gt;multi.control_count) {</a>
<a name="ln406">			PRINT((&quot;auvia_get_mix : invalid control id requested : %li\n&quot;, id));</a>
<a name="ln407">			continue;</a>
<a name="ln408">		}</a>
<a name="ln409">		control = &amp;card-&gt;multi.controls[id];</a>
<a name="ln410"> </a>
<a name="ln411">		if (control-&gt;mix_control.flags &amp; B_MULTI_MIX_GAIN) {</a>
<a name="ln412">			if (control-&gt;get) {</a>
<a name="ln413">				float values[2];</a>
<a name="ln414">				control-&gt;get(card, control-&gt;cookie, control-&gt;type, values);</a>
<a name="ln415">				if (control-&gt;mix_control.master == EMU_MULTI_CONTROL_MASTERID)</a>
<a name="ln416">					mmvi-&gt;values[i].u.gain = values[0];</a>
<a name="ln417">				else</a>
<a name="ln418">					mmvi-&gt;values[i].u.gain = values[1];</a>
<a name="ln419">			}</a>
<a name="ln420">		}</a>
<a name="ln421"> </a>
<a name="ln422">		if (control-&gt;mix_control.flags &amp; B_MULTI_MIX_ENABLE &amp;&amp; control-&gt;get) {</a>
<a name="ln423">			float values[1];</a>
<a name="ln424">			control-&gt;get(card, control-&gt;cookie, control-&gt;type, values);</a>
<a name="ln425">			mmvi-&gt;values[i].u.enable = (values[0] == 1.0);</a>
<a name="ln426">		}</a>
<a name="ln427"> </a>
<a name="ln428">		if (control-&gt;mix_control.flags &amp; B_MULTI_MIX_MUX &amp;&amp; control-&gt;get) {</a>
<a name="ln429">			float values[1];</a>
<a name="ln430">			control-&gt;get(card, control-&gt;cookie, control-&gt;type, values);</a>
<a name="ln431">			mmvi-&gt;values[i].u.mux = (int32)values[0];</a>
<a name="ln432">		}</a>
<a name="ln433">	}</a>
<a name="ln434">	return B_OK;</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437"> </a>
<a name="ln438">static status_t</a>
<a name="ln439">auvia_set_mix(auvia_dev *card, multi_mix_value_info * mmvi)</a>
<a name="ln440">{</a>
<a name="ln441">	int32 i, id;</a>
<a name="ln442">	multi_mixer_control *control = NULL;</a>
<a name="ln443">	for (i = 0; i &lt; mmvi-&gt;item_count; i++) {</a>
<a name="ln444">		id = mmvi-&gt;values[i].id - EMU_MULTI_CONTROL_FIRSTID;</a>
<a name="ln445">		if (id &lt; 0 || id &gt;= card-&gt;multi.control_count) {</a>
<a name="ln446">			PRINT((&quot;auvia_set_mix : invalid control id requested : %li\n&quot;, id));</a>
<a name="ln447">			continue;</a>
<a name="ln448">		}</a>
<a name="ln449">		control = &amp;card-&gt;multi.controls[id];</a>
<a name="ln450"> </a>
<a name="ln451">		if (control-&gt;mix_control.flags &amp; B_MULTI_MIX_GAIN) {</a>
<a name="ln452">			multi_mixer_control *control2 = NULL;</a>
<a name="ln453">			if (i + 1 &lt; mmvi-&gt;item_count) {</a>
<a name="ln454">				id = mmvi-&gt;values[i + 1].id - EMU_MULTI_CONTROL_FIRSTID;</a>
<a name="ln455">				if (id &lt; 0 || id &gt;= card-&gt;multi.control_count) {</a>
<a name="ln456">					PRINT((&quot;auvia_set_mix : invalid control id requested : %li\n&quot;, id));</a>
<a name="ln457">				} else {</a>
<a name="ln458">					control2 = &amp;card-&gt;multi.controls[id];</a>
<a name="ln459">					if (control2-&gt;mix_control.master != control-&gt;mix_control.id)</a>
<a name="ln460">						control2 = NULL;</a>
<a name="ln461">				}</a>
<a name="ln462">			}</a>
<a name="ln463"> </a>
<a name="ln464">			if (control-&gt;set) {</a>
<a name="ln465">				float values[2];</a>
<a name="ln466">				values[0] = 0.0;</a>
<a name="ln467">				values[1] = 0.0;</a>
<a name="ln468"> </a>
<a name="ln469">				if (control-&gt;mix_control.master == EMU_MULTI_CONTROL_MASTERID)</a>
<a name="ln470">					values[0] = mmvi-&gt;values[i].u.gain;</a>
<a name="ln471">				else</a>
<a name="ln472">					values[1] = mmvi-&gt;values[i].u.gain;</a>
<a name="ln473"> </a>
<a name="ln474">				if (control2 &amp;&amp; control2-&gt;mix_control.master != EMU_MULTI_CONTROL_MASTERID)</a>
<a name="ln475">					values[1] = mmvi-&gt;values[i + 1].u.gain;</a>
<a name="ln476"> </a>
<a name="ln477">				control-&gt;set(card, control-&gt;cookie, control-&gt;type, values);</a>
<a name="ln478">			}</a>
<a name="ln479"> </a>
<a name="ln480">			if (control2)</a>
<a name="ln481">				i++;</a>
<a name="ln482">		}</a>
<a name="ln483"> </a>
<a name="ln484">		if (control-&gt;mix_control.flags &amp; B_MULTI_MIX_ENABLE &amp;&amp; control-&gt;set) {</a>
<a name="ln485">			float values[1];</a>
<a name="ln486"> </a>
<a name="ln487">			values[0] = mmvi-&gt;values[i].u.enable ? 1.0 : 0.0;</a>
<a name="ln488">			control-&gt;set(card, control-&gt;cookie, control-&gt;type, values);</a>
<a name="ln489">		}</a>
<a name="ln490"> </a>
<a name="ln491">		if (control-&gt;mix_control.flags &amp; B_MULTI_MIX_MUX &amp;&amp; control-&gt;set) {</a>
<a name="ln492">			float values[1];</a>
<a name="ln493"> </a>
<a name="ln494">			values[0] = (float)mmvi-&gt;values[i].u.mux;</a>
<a name="ln495">			control-&gt;set(card, control-&gt;cookie, control-&gt;type, values);</a>
<a name="ln496">		}</a>
<a name="ln497">	}</a>
<a name="ln498">	return B_OK;</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501"> </a>
<a name="ln502">static status_t</a>
<a name="ln503">auvia_list_mix_controls(auvia_dev *card, multi_mix_control_info * mmci)</a>
<a name="ln504">{</a>
<a name="ln505">	multi_mix_control	*mmc;</a>
<a name="ln506">	int32 i;</a>
<a name="ln507"> </a>
<a name="ln508">	mmc = mmci-&gt;controls;</a>
<a name="ln509">	if (mmci-&gt;control_count &lt; 24)</a>
<a name="ln510">		return B_ERROR;</a>
<a name="ln511"> </a>
<a name="ln512">	if (auvia_create_controls_list(&amp;card-&gt;multi) &lt; B_OK)</a>
<a name="ln513">		return B_ERROR;</a>
<a name="ln514">	for (i = 0; i &lt; card-&gt;multi.control_count; i++) {</a>
<a name="ln515">		mmc[i] = card-&gt;multi.controls[i].mix_control;</a>
<a name="ln516">	}</a>
<a name="ln517"> </a>
<a name="ln518">	mmci-&gt;control_count = card-&gt;multi.control_count;</a>
<a name="ln519">	return B_OK;</a>
<a name="ln520">}</a>
<a name="ln521"> </a>
<a name="ln522"> </a>
<a name="ln523">static status_t</a>
<a name="ln524">auvia_list_mix_connections(auvia_dev *card, multi_mix_connection_info * data)</a>
<a name="ln525">{</a>
<a name="ln526">	return B_ERROR;</a>
<a name="ln527">}</a>
<a name="ln528"> </a>
<a name="ln529"> </a>
<a name="ln530">static status_t</a>
<a name="ln531">auvia_list_mix_channels(auvia_dev *card, multi_mix_channel_info *data)</a>
<a name="ln532">{</a>
<a name="ln533">	return B_ERROR;</a>
<a name="ln534">}</a>
<a name="ln535"> </a>
<a name="ln536">/*multi_channel_info chans[] = {</a>
<a name="ln537">{  0, B_MULTI_OUTPUT_CHANNEL, 	B_CHANNEL_LEFT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln538">{  1, B_MULTI_OUTPUT_CHANNEL, 	B_CHANNEL_RIGHT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln539">{  2, B_MULTI_OUTPUT_CHANNEL, 	B_CHANNEL_LEFT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln540">{  3, B_MULTI_OUTPUT_CHANNEL, 	B_CHANNEL_RIGHT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln541">{  4, B_MULTI_INPUT_CHANNEL, 	B_CHANNEL_LEFT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln542">{  5, B_MULTI_INPUT_CHANNEL, 	B_CHANNEL_RIGHT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln543">{  6, B_MULTI_INPUT_CHANNEL, 	B_CHANNEL_LEFT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln544">{  7, B_MULTI_INPUT_CHANNEL, 	B_CHANNEL_RIGHT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln545">{  8, B_MULTI_OUTPUT_BUS, 		B_CHANNEL_LEFT | B_CHANNEL_STEREO_BUS, 	B_CHANNEL_MINI_JACK_STEREO },</a>
<a name="ln546">{  9, B_MULTI_OUTPUT_BUS, 		B_CHANNEL_RIGHT | B_CHANNEL_STEREO_BUS, B_CHANNEL_MINI_JACK_STEREO },</a>
<a name="ln547">{  10, B_MULTI_INPUT_BUS, 		B_CHANNEL_LEFT | B_CHANNEL_STEREO_BUS, 	B_CHANNEL_MINI_JACK_STEREO },</a>
<a name="ln548">{  11, B_MULTI_INPUT_BUS, 		B_CHANNEL_RIGHT | B_CHANNEL_STEREO_BUS, B_CHANNEL_MINI_JACK_STEREO },</a>
<a name="ln549">};*/</a>
<a name="ln550"> </a>
<a name="ln551">/*multi_channel_info chans[] = {</a>
<a name="ln552">{  0, B_MULTI_OUTPUT_CHANNEL, 	B_CHANNEL_LEFT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln553">{  1, B_MULTI_OUTPUT_CHANNEL, 	B_CHANNEL_RIGHT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln554">{  2, B_MULTI_OUTPUT_CHANNEL, 	B_CHANNEL_LEFT | B_CHANNEL_SURROUND_BUS, 0 },</a>
<a name="ln555">{  3, B_MULTI_OUTPUT_CHANNEL, 	B_CHANNEL_RIGHT | B_CHANNEL_SURROUND_BUS, 0 },</a>
<a name="ln556">{  4, B_MULTI_OUTPUT_CHANNEL, 	B_CHANNEL_REARLEFT | B_CHANNEL_SURROUND_BUS, 0 },</a>
<a name="ln557">{  5, B_MULTI_OUTPUT_CHANNEL, 	B_CHANNEL_REARRIGHT | B_CHANNEL_SURROUND_BUS, 0 },</a>
<a name="ln558">{  6, B_MULTI_INPUT_CHANNEL, 	B_CHANNEL_LEFT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln559">{  7, B_MULTI_INPUT_CHANNEL, 	B_CHANNEL_RIGHT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln560">{  8, B_MULTI_INPUT_CHANNEL, 	B_CHANNEL_LEFT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln561">{  9, B_MULTI_INPUT_CHANNEL, 	B_CHANNEL_RIGHT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln562">{  10, B_MULTI_OUTPUT_BUS, 		B_CHANNEL_LEFT | B_CHANNEL_STEREO_BUS, 	B_CHANNEL_MINI_JACK_STEREO },</a>
<a name="ln563">{  11, B_MULTI_OUTPUT_BUS, 		B_CHANNEL_RIGHT | B_CHANNEL_STEREO_BUS, B_CHANNEL_MINI_JACK_STEREO },</a>
<a name="ln564">{  12, B_MULTI_INPUT_BUS, 		B_CHANNEL_LEFT | B_CHANNEL_STEREO_BUS, 	B_CHANNEL_MINI_JACK_STEREO },</a>
<a name="ln565">{  13, B_MULTI_INPUT_BUS, 		B_CHANNEL_RIGHT | B_CHANNEL_STEREO_BUS, B_CHANNEL_MINI_JACK_STEREO },</a>
<a name="ln566">};*/</a>
<a name="ln567"> </a>
<a name="ln568"> </a>
<a name="ln569">static void</a>
<a name="ln570">auvia_create_channels_list(multi_dev *multi)</a>
<a name="ln571">{</a>
<a name="ln572">	auvia_stream *stream;</a>
<a name="ln573">	uint32 index, i, mode, designations;</a>
<a name="ln574">	multi_channel_info *chans;</a>
<a name="ln575">	uint32 chan_designations[] = {</a>
<a name="ln576">		B_CHANNEL_LEFT,</a>
<a name="ln577">		B_CHANNEL_RIGHT,</a>
<a name="ln578">		B_CHANNEL_REARLEFT,</a>
<a name="ln579">		B_CHANNEL_REARRIGHT,</a>
<a name="ln580">		B_CHANNEL_CENTER,</a>
<a name="ln581">		B_CHANNEL_SUB</a>
<a name="ln582">	};</a>
<a name="ln583"> </a>
<a name="ln584">	chans = multi-&gt;chans;</a>
<a name="ln585">	index = 0;</a>
<a name="ln586"> </a>
<a name="ln587">	for (mode = AUVIA_USE_PLAY; mode != -1;</a>
<a name="ln588">		mode = (mode == AUVIA_USE_PLAY) ? AUVIA_USE_RECORD : -1) {</a>
<a name="ln589">		LIST_FOREACH(stream, &amp;((auvia_dev*)multi-&gt;card)-&gt;streams, next) {</a>
<a name="ln590">			if ((stream-&gt;use &amp; mode) == 0)</a>
<a name="ln591">				continue;</a>
<a name="ln592"> </a>
<a name="ln593">			if (stream-&gt;channels == 2)</a>
<a name="ln594">				designations = B_CHANNEL_STEREO_BUS;</a>
<a name="ln595">			else</a>
<a name="ln596">				designations = B_CHANNEL_SURROUND_BUS;</a>
<a name="ln597"> </a>
<a name="ln598">			for (i = 0; i &lt; stream-&gt;channels; i++) {</a>
<a name="ln599">				chans[index].channel_id = index;</a>
<a name="ln600">				chans[index].kind = (mode == AUVIA_USE_PLAY) ? B_MULTI_OUTPUT_CHANNEL : B_MULTI_INPUT_CHANNEL;</a>
<a name="ln601">				chans[index].designations = designations | chan_designations[i];</a>
<a name="ln602">				chans[index].connectors = 0;</a>
<a name="ln603">				index++;</a>
<a name="ln604">			}</a>
<a name="ln605">		}</a>
<a name="ln606"> </a>
<a name="ln607">		if (mode == AUVIA_USE_PLAY) {</a>
<a name="ln608">			multi-&gt;output_channel_count = index;</a>
<a name="ln609">		} else {</a>
<a name="ln610">			multi-&gt;input_channel_count = index - multi-&gt;output_channel_count;</a>
<a name="ln611">		}</a>
<a name="ln612">	}</a>
<a name="ln613"> </a>
<a name="ln614">	chans[index].channel_id = index;</a>
<a name="ln615">	chans[index].kind = B_MULTI_OUTPUT_BUS;</a>
<a name="ln616">	chans[index].designations = B_CHANNEL_LEFT | B_CHANNEL_STEREO_BUS;</a>
<a name="ln617">	chans[index].connectors = B_CHANNEL_MINI_JACK_STEREO;</a>
<a name="ln618">	index++;</a>
<a name="ln619"> </a>
<a name="ln620">	chans[index].channel_id = index;</a>
<a name="ln621">	chans[index].kind = B_MULTI_OUTPUT_BUS;</a>
<a name="ln622">	chans[index].designations = B_CHANNEL_RIGHT | B_CHANNEL_STEREO_BUS;</a>
<a name="ln623">	chans[index].connectors = B_CHANNEL_MINI_JACK_STEREO;</a>
<a name="ln624">	index++;</a>
<a name="ln625"> </a>
<a name="ln626">	multi-&gt;output_bus_channel_count = index - multi-&gt;output_channel_count</a>
<a name="ln627">		- multi-&gt;input_channel_count;</a>
<a name="ln628"> </a>
<a name="ln629">	chans[index].channel_id = index;</a>
<a name="ln630">	chans[index].kind = B_MULTI_INPUT_BUS;</a>
<a name="ln631">	chans[index].designations = B_CHANNEL_LEFT | B_CHANNEL_STEREO_BUS;</a>
<a name="ln632">	chans[index].connectors = B_CHANNEL_MINI_JACK_STEREO;</a>
<a name="ln633">	index++;</a>
<a name="ln634"> </a>
<a name="ln635">	chans[index].channel_id = index;</a>
<a name="ln636">	chans[index].kind = B_MULTI_INPUT_BUS;</a>
<a name="ln637">	chans[index].designations = B_CHANNEL_RIGHT | B_CHANNEL_STEREO_BUS;</a>
<a name="ln638">	chans[index].connectors = B_CHANNEL_MINI_JACK_STEREO;</a>
<a name="ln639">	index++;</a>
<a name="ln640"> </a>
<a name="ln641">	multi-&gt;input_bus_channel_count = index - multi-&gt;output_channel_count</a>
<a name="ln642">		- multi-&gt;input_channel_count - multi-&gt;output_bus_channel_count;</a>
<a name="ln643"> </a>
<a name="ln644">	multi-&gt;aux_bus_channel_count = 0;</a>
<a name="ln645">}</a>
<a name="ln646"> </a>
<a name="ln647"> </a>
<a name="ln648">static status_t</a>
<a name="ln649">auvia_get_description(auvia_dev *card, multi_description *data)</a>
<a name="ln650">{</a>
<a name="ln651">	uint32 size;</a>
<a name="ln652"> </a>
<a name="ln653">	data-&gt;interface_version = B_CURRENT_INTERFACE_VERSION;</a>
<a name="ln654">	data-&gt;interface_minimum = B_CURRENT_INTERFACE_VERSION;</a>
<a name="ln655"> </a>
<a name="ln656">	if (IS_686(&amp;card-&gt;config))</a>
<a name="ln657">		strncpy(data-&gt;friendly_name, FRIENDLY_NAME_686, 32);</a>
<a name="ln658">	else if (IS_8233(&amp;card-&gt;config)) {</a>
<a name="ln659">		switch (card-&gt;info.revision) {</a>
<a name="ln660">			case VIATECH_8233_AC97_REV_8233_10:</a>
<a name="ln661">				strncpy(data-&gt;friendly_name, FRIENDLY_NAME_8233, 32);</a>
<a name="ln662">				break;</a>
<a name="ln663">			case VIATECH_8233_AC97_REV_8233C:</a>
<a name="ln664">				strncpy(data-&gt;friendly_name, FRIENDLY_NAME_8233C, 32);</a>
<a name="ln665">				break;</a>
<a name="ln666">			case VIATECH_8233_AC97_REV_8233:</a>
<a name="ln667">				strncpy(data-&gt;friendly_name, FRIENDLY_NAME_8233, 32);</a>
<a name="ln668">				break;</a>
<a name="ln669">			case VIATECH_8233_AC97_REV_8233A:</a>
<a name="ln670">				strncpy(data-&gt;friendly_name, FRIENDLY_NAME_8233A, 32);</a>
<a name="ln671">				break;</a>
<a name="ln672">			case VIATECH_8233_AC97_REV_8235:</a>
<a name="ln673">				strncpy(data-&gt;friendly_name, FRIENDLY_NAME_8235, 32);</a>
<a name="ln674">				break;</a>
<a name="ln675">			case VIATECH_8233_AC97_REV_8237:</a>
<a name="ln676">				strncpy(data-&gt;friendly_name, FRIENDLY_NAME_8237, 32);</a>
<a name="ln677">				break;</a>
<a name="ln678">			default:</a>
<a name="ln679">				strncpy(data-&gt;friendly_name, FRIENDLY_NAME, 32);</a>
<a name="ln680">		}</a>
<a name="ln681">	}</a>
<a name="ln682">	strcpy(data-&gt;vendor_info, AUTHOR);</a>
<a name="ln683"> </a>
<a name="ln684">	/*data-&gt;output_channel_count = 6;</a>
<a name="ln685">	data-&gt;input_channel_count = 4;</a>
<a name="ln686">	data-&gt;output_bus_channel_count = 2;</a>
<a name="ln687">	data-&gt;input_bus_channel_count = 2;</a>
<a name="ln688">	data-&gt;aux_bus_channel_count = 0;*/</a>
<a name="ln689"> </a>
<a name="ln690">	data-&gt;output_channel_count = card-&gt;multi.output_channel_count;</a>
<a name="ln691">	data-&gt;input_channel_count = card-&gt;multi.input_channel_count;</a>
<a name="ln692">	data-&gt;output_bus_channel_count = card-&gt;multi.output_bus_channel_count;</a>
<a name="ln693">	data-&gt;input_bus_channel_count = card-&gt;multi.input_bus_channel_count;</a>
<a name="ln694">	data-&gt;aux_bus_channel_count = card-&gt;multi.aux_bus_channel_count;</a>
<a name="ln695"> </a>
<a name="ln696">	size = card-&gt;multi.output_channel_count + card-&gt;multi.input_channel_count</a>
<a name="ln697">			+ card-&gt;multi.output_bus_channel_count + card-&gt;multi.input_bus_channel_count</a>
<a name="ln698">			+ card-&gt;multi.aux_bus_channel_count;</a>
<a name="ln699"> </a>
<a name="ln700">	// for each channel, starting with the first output channel,</a>
<a name="ln701">	// then the second, third..., followed by the first input</a>
<a name="ln702">	// channel, second, third, ..., followed by output bus</a>
<a name="ln703">	// channels and input bus channels and finally auxillary channels,</a>
<a name="ln704"> </a>
<a name="ln705">	LOG((&quot;request_channel_count = %d\n&quot;,data-&gt;request_channel_count));</a>
<a name="ln706">	if (data-&gt;request_channel_count &gt;= size) {</a>
<a name="ln707">		LOG((&quot;copying data\n&quot;));</a>
<a name="ln708">		memcpy(data-&gt;channels, card-&gt;multi.chans, size * sizeof(card-&gt;multi.chans[0]));</a>
<a name="ln709">	}</a>
<a name="ln710"> </a>
<a name="ln711">	data-&gt;output_rates = B_SR_48000;// | B_SR_44100 | B_SR_CVSR;</a>
<a name="ln712">	data-&gt;input_rates = B_SR_48000;// | B_SR_44100 | B_SR_CVSR;</a>
<a name="ln713">	//data-&gt;output_rates = B_SR_44100;</a>
<a name="ln714">	//data-&gt;input_rates = B_SR_44100;</a>
<a name="ln715">	data-&gt;min_cvsr_rate = 0;</a>
<a name="ln716">	data-&gt;max_cvsr_rate = 48000;</a>
<a name="ln717">	//data-&gt;max_cvsr_rate = 44100;</a>
<a name="ln718"> </a>
<a name="ln719">	data-&gt;output_formats = B_FMT_16BIT;</a>
<a name="ln720">	data-&gt;input_formats = B_FMT_16BIT;</a>
<a name="ln721">	data-&gt;lock_sources = B_MULTI_LOCK_INTERNAL;</a>
<a name="ln722">	data-&gt;timecode_sources = 0;</a>
<a name="ln723">	data-&gt;interface_flags = B_MULTI_INTERFACE_PLAYBACK | B_MULTI_INTERFACE_RECORD;</a>
<a name="ln724">	data-&gt;start_latency = 3000;</a>
<a name="ln725"> </a>
<a name="ln726">	strcpy(data-&gt;control_panel, &quot;&quot;);</a>
<a name="ln727"> </a>
<a name="ln728">	return B_OK;</a>
<a name="ln729">}</a>
<a name="ln730"> </a>
<a name="ln731"> </a>
<a name="ln732">static status_t</a>
<a name="ln733">auvia_get_enabled_channels(auvia_dev *card, multi_channel_enable *data)</a>
<a name="ln734">{</a>
<a name="ln735">	B_SET_CHANNEL(data-&gt;enable_bits, 0, true);</a>
<a name="ln736">	B_SET_CHANNEL(data-&gt;enable_bits, 1, true);</a>
<a name="ln737">	B_SET_CHANNEL(data-&gt;enable_bits, 2, true);</a>
<a name="ln738">	B_SET_CHANNEL(data-&gt;enable_bits, 3, true);</a>
<a name="ln739">	data-&gt;lock_source = B_MULTI_LOCK_INTERNAL;</a>
<a name="ln740">/*</a>
<a name="ln741">	uint32			lock_source;</a>
<a name="ln742">	int32			lock_data;</a>
<a name="ln743">	uint32			timecode_source;</a>
<a name="ln744">	uint32 *		connectors;</a>
<a name="ln745">*/</a>
<a name="ln746">	return B_OK;</a>
<a name="ln747">}</a>
<a name="ln748"> </a>
<a name="ln749"> </a>
<a name="ln750">static status_t</a>
<a name="ln751">auvia_set_enabled_channels(auvia_dev *card, multi_channel_enable *data)</a>
<a name="ln752">{</a>
<a name="ln753">	PRINT((&quot;set_enabled_channels 0 : %s\n&quot;, B_TEST_CHANNEL(data-&gt;enable_bits, 0) ? &quot;enabled&quot;: &quot;disabled&quot;));</a>
<a name="ln754">	PRINT((&quot;set_enabled_channels 1 : %s\n&quot;, B_TEST_CHANNEL(data-&gt;enable_bits, 1) ? &quot;enabled&quot;: &quot;disabled&quot;));</a>
<a name="ln755">	PRINT((&quot;set_enabled_channels 2 : %s\n&quot;, B_TEST_CHANNEL(data-&gt;enable_bits, 2) ? &quot;enabled&quot;: &quot;disabled&quot;));</a>
<a name="ln756">	PRINT((&quot;set_enabled_channels 3 : %s\n&quot;, B_TEST_CHANNEL(data-&gt;enable_bits, 3) ? &quot;enabled&quot;: &quot;disabled&quot;));</a>
<a name="ln757">	return B_OK;</a>
<a name="ln758">}</a>
<a name="ln759"> </a>
<a name="ln760"> </a>
<a name="ln761">static status_t</a>
<a name="ln762">auvia_get_global_format(auvia_dev *card, multi_format_info *data)</a>
<a name="ln763">{</a>
<a name="ln764">	data-&gt;output_latency = 0;</a>
<a name="ln765">	data-&gt;input_latency = 0;</a>
<a name="ln766">	data-&gt;timecode_kind = 0;</a>
<a name="ln767">	data-&gt;input.rate = B_SR_48000;</a>
<a name="ln768">	data-&gt;input.cvsr = 48000;</a>
<a name="ln769">	data-&gt;input.format = B_FMT_16BIT;</a>
<a name="ln770">	data-&gt;output.rate = B_SR_48000;</a>
<a name="ln771">	data-&gt;output.cvsr = 48000;</a>
<a name="ln772">	data-&gt;output.format = B_FMT_16BIT;</a>
<a name="ln773">	/*data-&gt;input.rate = B_SR_44100;</a>
<a name="ln774">	data-&gt;input.cvsr = 44100;</a>
<a name="ln775">	data-&gt;input.format = B_FMT_16BIT;</a>
<a name="ln776">	data-&gt;output.rate = B_SR_44100;</a>
<a name="ln777">	data-&gt;output.cvsr = 44100;</a>
<a name="ln778">	data-&gt;output.format = B_FMT_16BIT;*/</a>
<a name="ln779">	return B_OK;</a>
<a name="ln780">}</a>
<a name="ln781"> </a>
<a name="ln782"> </a>
<a name="ln783">static status_t</a>
<a name="ln784">auvia_get_buffers(auvia_dev *card, multi_buffer_list *data)</a>
<a name="ln785">{</a>
<a name="ln786">	uint32 i, j, pchannels, rchannels;</a>
<a name="ln787"> </a>
<a name="ln788">	LOG((&quot;flags = %#x\n&quot;,data-&gt;flags));</a>
<a name="ln789">	LOG((&quot;request_playback_buffers = %#x\n&quot;,data-&gt;request_playback_buffers));</a>
<a name="ln790">	LOG((&quot;request_playback_channels = %#x\n&quot;,data-&gt;request_playback_channels));</a>
<a name="ln791">	LOG((&quot;request_playback_buffer_size = %#x\n&quot;,data-&gt;request_playback_buffer_size));</a>
<a name="ln792">	LOG((&quot;request_record_buffers = %#x\n&quot;,data-&gt;request_record_buffers));</a>
<a name="ln793">	LOG((&quot;request_record_channels = %#x\n&quot;,data-&gt;request_record_channels));</a>
<a name="ln794">	LOG((&quot;request_record_buffer_size = %#x\n&quot;,data-&gt;request_record_buffer_size));</a>
<a name="ln795"> </a>
<a name="ln796">	pchannels = card-&gt;pstream-&gt;channels;</a>
<a name="ln797">	rchannels = card-&gt;rstream-&gt;channels;</a>
<a name="ln798"> </a>
<a name="ln799">	if (data-&gt;request_playback_buffers &lt; BUFFER_COUNT ||</a>
<a name="ln800">		data-&gt;request_playback_channels &lt; (pchannels) ||</a>
<a name="ln801">		data-&gt;request_record_buffers &lt; BUFFER_COUNT ||</a>
<a name="ln802">		data-&gt;request_record_channels &lt; (rchannels)) {</a>
<a name="ln803">		LOG((&quot;not enough channels/buffers\n&quot;));</a>
<a name="ln804">	}</a>
<a name="ln805"> </a>
<a name="ln806">	ASSERT(BUFFER_COUNT == 2);</a>
<a name="ln807"> </a>
<a name="ln808">	data-&gt;flags = B_MULTI_BUFFER_PLAYBACK | B_MULTI_BUFFER_RECORD; // XXX ???</a>
<a name="ln809">//	data-&gt;flags = 0;</a>
<a name="ln810"> </a>
<a name="ln811">	data-&gt;return_playback_buffers = BUFFER_COUNT;	/* playback_buffers[b][] */</a>
<a name="ln812">	data-&gt;return_playback_channels = pchannels;		/* playback_buffers[][c] */</a>
<a name="ln813">	data-&gt;return_playback_buffer_size = BUFFER_FRAMES;		/* frames */</a>
<a name="ln814"> </a>
<a name="ln815">	for (i = 0; i &lt; BUFFER_COUNT; i++)</a>
<a name="ln816">		for (j = 0; j &lt; pchannels; j++)</a>
<a name="ln817">			auvia_stream_get_nth_buffer(card-&gt;pstream, j, i,</a>
<a name="ln818">				&amp;data-&gt;playback_buffers[i][j].base,</a>
<a name="ln819">				&amp;data-&gt;playback_buffers[i][j].stride);</a>
<a name="ln820"> </a>
<a name="ln821">	data-&gt;return_record_buffers = BUFFER_COUNT;</a>
<a name="ln822">	data-&gt;return_record_channels = rchannels;</a>
<a name="ln823">	data-&gt;return_record_buffer_size = BUFFER_FRAMES;	/* frames */</a>
<a name="ln824"> </a>
<a name="ln825">	for (i = 0; i &lt; BUFFER_COUNT; i++)</a>
<a name="ln826">		for (j = 0; j&lt;rchannels; j++)</a>
<a name="ln827">			auvia_stream_get_nth_buffer(card-&gt;rstream, j, i,</a>
<a name="ln828">				&amp;data-&gt;record_buffers[i][j].base,</a>
<a name="ln829">				&amp;data-&gt;record_buffers[i][j].stride);</a>
<a name="ln830"> </a>
<a name="ln831">	return B_OK;</a>
<a name="ln832">}</a>
<a name="ln833"> </a>
<a name="ln834"> </a>
<a name="ln835">static void</a>
<a name="ln836">auvia_play_inth(void* inthparams)</a>
<a name="ln837">{</a>
<a name="ln838">	auvia_stream *stream = (auvia_stream *)inthparams;</a>
<a name="ln839">	//int32 count;</a>
<a name="ln840"> </a>
<a name="ln841">	//TRACE((&quot;auvia_play_inth\n&quot;));</a>
<a name="ln842"> </a>
<a name="ln843">	acquire_spinlock(&amp;slock);</a>
<a name="ln844">	stream-&gt;real_time = system_time();</a>
<a name="ln845">	stream-&gt;frames_count += BUFFER_FRAMES;</a>
<a name="ln846">	stream-&gt;buffer_cycle = (stream-&gt;trigblk</a>
<a name="ln847">		+ stream-&gt;blkmod - 1) % stream-&gt;blkmod;</a>
<a name="ln848">	stream-&gt;update_needed = true;</a>
<a name="ln849">	release_spinlock(&amp;slock);</a>
<a name="ln850"> </a>
<a name="ln851">	//get_sem_count(stream-&gt;card-&gt;buffer_ready_sem, &amp;count);</a>
<a name="ln852">	//if (count &lt;= 0)</a>
<a name="ln853">		release_sem_etc(stream-&gt;card-&gt;buffer_ready_sem, 1, B_DO_NOT_RESCHEDULE);</a>
<a name="ln854">}</a>
<a name="ln855"> </a>
<a name="ln856"> </a>
<a name="ln857">static void</a>
<a name="ln858">auvia_record_inth(void* inthparams)</a>
<a name="ln859">{</a>
<a name="ln860">	auvia_stream *stream = (auvia_stream *)inthparams;</a>
<a name="ln861">	//int32 count;</a>
<a name="ln862"> </a>
<a name="ln863">	//TRACE((&quot;auvia_record_inth\n&quot;));</a>
<a name="ln864"> </a>
<a name="ln865">	acquire_spinlock(&amp;slock);</a>
<a name="ln866">	stream-&gt;real_time = system_time();</a>
<a name="ln867">	stream-&gt;frames_count += BUFFER_FRAMES;</a>
<a name="ln868">	stream-&gt;buffer_cycle = (stream-&gt;trigblk</a>
<a name="ln869">		+ stream-&gt;blkmod - 1) % stream-&gt;blkmod;</a>
<a name="ln870">	stream-&gt;update_needed = true;</a>
<a name="ln871">	release_spinlock(&amp;slock);</a>
<a name="ln872"> </a>
<a name="ln873">	//get_sem_count(stream-&gt;card-&gt;buffer_ready_sem, &amp;count);</a>
<a name="ln874">	//if (count &lt;= 0)</a>
<a name="ln875">		release_sem_etc(stream-&gt;card-&gt;buffer_ready_sem, 1, B_DO_NOT_RESCHEDULE);</a>
<a name="ln876">}</a>
<a name="ln877"> </a>
<a name="ln878"> </a>
<a name="ln879">static status_t</a>
<a name="ln880">auvia_buffer_exchange(auvia_dev *card, multi_buffer_info *data)</a>
<a name="ln881">{</a>
<a name="ln882">	cpu_status status;</a>
<a name="ln883">	auvia_stream *pstream, *rstream;</a>
<a name="ln884">	multi_buffer_info buffer_info;</a>
<a name="ln885"> </a>
<a name="ln886">#ifdef __HAIKU__</a>
<a name="ln887">	if (user_memcpy(&amp;buffer_info, data, sizeof(buffer_info)) &lt; B_OK)</a>
<a name="ln888">		return B_BAD_ADDRESS;</a>
<a name="ln889">#else</a>
<a name="ln890">	memcpy(&amp;buffer_info, data, sizeof(buffer_info));</a>
<a name="ln891">#endif</a>
<a name="ln892"> </a>
<a name="ln893">	buffer_info.flags = B_MULTI_BUFFER_PLAYBACK | B_MULTI_BUFFER_RECORD;</a>
<a name="ln894"> </a>
<a name="ln895">	if (!(card-&gt;pstream-&gt;state &amp; AUVIA_STATE_STARTED))</a>
<a name="ln896">		auvia_stream_start(card-&gt;pstream, auvia_play_inth, card-&gt;pstream);</a>
<a name="ln897"> </a>
<a name="ln898">	if (!(card-&gt;rstream-&gt;state &amp; AUVIA_STATE_STARTED))</a>
<a name="ln899">		auvia_stream_start(card-&gt;rstream, auvia_record_inth, card-&gt;rstream);</a>
<a name="ln900"> </a>
<a name="ln901">	if (acquire_sem_etc(card-&gt;buffer_ready_sem, 1, B_RELATIVE_TIMEOUT | B_CAN_INTERRUPT, 50000)</a>
<a name="ln902">		== B_TIMED_OUT) {</a>
<a name="ln903">		LOG((&quot;buffer_exchange timeout ff\n&quot;));</a>
<a name="ln904">	}</a>
<a name="ln905"> </a>
<a name="ln906">	status = lock();</a>
<a name="ln907"> </a>
<a name="ln908">	LIST_FOREACH(pstream, &amp;card-&gt;streams, next) {</a>
<a name="ln909">		if ((pstream-&gt;use &amp; AUVIA_USE_PLAY) == 0 ||</a>
<a name="ln910">			(pstream-&gt;state &amp; AUVIA_STATE_STARTED) == 0)</a>
<a name="ln911">			continue;</a>
<a name="ln912">		if (pstream-&gt;update_needed)</a>
<a name="ln913">			break;</a>
<a name="ln914">	}</a>
<a name="ln915"> </a>
<a name="ln916">	LIST_FOREACH(rstream, &amp;card-&gt;streams, next) {</a>
<a name="ln917">		if ((rstream-&gt;use &amp; AUVIA_USE_RECORD) == 0 ||</a>
<a name="ln918">			(rstream-&gt;state &amp; AUVIA_STATE_STARTED) == 0)</a>
<a name="ln919">			continue;</a>
<a name="ln920">		if (rstream-&gt;update_needed)</a>
<a name="ln921">			break;</a>
<a name="ln922">	}</a>
<a name="ln923"> </a>
<a name="ln924">	if (!pstream)</a>
<a name="ln925">		pstream = card-&gt;pstream;</a>
<a name="ln926">	if (!rstream)</a>
<a name="ln927">		rstream = card-&gt;rstream;</a>
<a name="ln928"> </a>
<a name="ln929">	/* do playback */</a>
<a name="ln930">	buffer_info.playback_buffer_cycle = pstream-&gt;buffer_cycle;</a>
<a name="ln931">	buffer_info.played_real_time = pstream-&gt;real_time;</a>
<a name="ln932">	buffer_info.played_frames_count = pstream-&gt;frames_count;</a>
<a name="ln933">	buffer_info._reserved_0 = pstream-&gt;first_channel;</a>
<a name="ln934">	pstream-&gt;update_needed = false;</a>
<a name="ln935"> </a>
<a name="ln936">	/* do record */</a>
<a name="ln937">	buffer_info.record_buffer_cycle = rstream-&gt;buffer_cycle;</a>
<a name="ln938">	buffer_info.recorded_frames_count = rstream-&gt;frames_count;</a>
<a name="ln939">	buffer_info.recorded_real_time = rstream-&gt;real_time;</a>
<a name="ln940">	buffer_info._reserved_1 = rstream-&gt;first_channel;</a>
<a name="ln941">	rstream-&gt;update_needed = false;</a>
<a name="ln942">	unlock(status);</a>
<a name="ln943"> </a>
<a name="ln944">#ifdef __HAIKU__</a>
<a name="ln945">	if (user_memcpy(data, &amp;buffer_info, sizeof(buffer_info)) &lt; B_OK)</a>
<a name="ln946">		return B_BAD_ADDRESS;</a>
<a name="ln947">#else</a>
<a name="ln948">	memcpy(data, &amp;buffer_info, sizeof(buffer_info));</a>
<a name="ln949">#endif</a>
<a name="ln950"> </a>
<a name="ln951">	//TRACE((&quot;buffer_exchange ended\n&quot;));</a>
<a name="ln952">	return B_OK;</a>
<a name="ln953">}</a>
<a name="ln954"> </a>
<a name="ln955"> </a>
<a name="ln956">static status_t</a>
<a name="ln957">auvia_buffer_force_stop(auvia_dev *card)</a>
<a name="ln958">{</a>
<a name="ln959">	//auvia_voice_halt(card-&gt;pvoice);</a>
<a name="ln960">	return B_OK;</a>
<a name="ln961">}</a>
<a name="ln962"> </a>
<a name="ln963"> </a>
<a name="ln964">static status_t</a>
<a name="ln965">auvia_multi_control(void *cookie, uint32 op, void *data, size_t length)</a>
<a name="ln966">{</a>
<a name="ln967">	auvia_dev *card = (auvia_dev *)cookie;</a>
<a name="ln968"> </a>
<a name="ln969">    switch (op) {</a>
<a name="ln970">		case B_MULTI_GET_DESCRIPTION:</a>
<a name="ln971">			LOG((&quot;B_MULTI_GET_DESCRIPTION\n&quot;));</a>
<a name="ln972">			return auvia_get_description(card, (multi_description *)data);</a>
<a name="ln973">		case B_MULTI_GET_EVENT_INFO:</a>
<a name="ln974">			LOG((&quot;B_MULTI_GET_EVENT_INFO\n&quot;));</a>
<a name="ln975">			return B_ERROR;</a>
<a name="ln976">		case B_MULTI_SET_EVENT_INFO:</a>
<a name="ln977">			LOG((&quot;B_MULTI_SET_EVENT_INFO\n&quot;));</a>
<a name="ln978">			return B_ERROR;</a>
<a name="ln979">		case B_MULTI_GET_EVENT:</a>
<a name="ln980">			LOG((&quot;B_MULTI_GET_EVENT\n&quot;));</a>
<a name="ln981">			return B_ERROR;</a>
<a name="ln982">		case B_MULTI_GET_ENABLED_CHANNELS:</a>
<a name="ln983">			LOG((&quot;B_MULTI_GET_ENABLED_CHANNELS\n&quot;));</a>
<a name="ln984">			return auvia_get_enabled_channels(card, (multi_channel_enable *)data);</a>
<a name="ln985">		case B_MULTI_SET_ENABLED_CHANNELS:</a>
<a name="ln986">			LOG((&quot;B_MULTI_SET_ENABLED_CHANNELS\n&quot;));</a>
<a name="ln987">			return auvia_set_enabled_channels(card, (multi_channel_enable *)data);</a>
<a name="ln988">		case B_MULTI_GET_GLOBAL_FORMAT:</a>
<a name="ln989">			LOG((&quot;B_MULTI_GET_GLOBAL_FORMAT\n&quot;));</a>
<a name="ln990">			return auvia_get_global_format(card, (multi_format_info *)data);</a>
<a name="ln991">		case B_MULTI_SET_GLOBAL_FORMAT:</a>
<a name="ln992">			LOG((&quot;B_MULTI_SET_GLOBAL_FORMAT\n&quot;));</a>
<a name="ln993">			return B_OK; /* XXX BUG! we *MUST* return B_OK, returning B_ERROR will prevent</a>
<a name="ln994">						  * BeOS to accept the format returned in B_MULTI_GET_GLOBAL_FORMAT</a>
<a name="ln995">						  */</a>
<a name="ln996">		case B_MULTI_GET_CHANNEL_FORMATS:</a>
<a name="ln997">			LOG((&quot;B_MULTI_GET_CHANNEL_FORMATS\n&quot;));</a>
<a name="ln998">			return B_ERROR;</a>
<a name="ln999">		case B_MULTI_SET_CHANNEL_FORMATS:	/* only implemented if possible */</a>
<a name="ln1000">			LOG((&quot;B_MULTI_SET_CHANNEL_FORMATS\n&quot;));</a>
<a name="ln1001">			return B_ERROR;</a>
<a name="ln1002">		case B_MULTI_GET_MIX:</a>
<a name="ln1003">			LOG((&quot;B_MULTI_GET_MIX\n&quot;));</a>
<a name="ln1004">			return auvia_get_mix(card, (multi_mix_value_info *)data);</a>
<a name="ln1005">		case B_MULTI_SET_MIX:</a>
<a name="ln1006">			LOG((&quot;B_MULTI_SET_MIX\n&quot;));</a>
<a name="ln1007">			return auvia_set_mix(card, (multi_mix_value_info *)data);</a>
<a name="ln1008">		case B_MULTI_LIST_MIX_CHANNELS:</a>
<a name="ln1009">			LOG((&quot;B_MULTI_LIST_MIX_CHANNELS\n&quot;));</a>
<a name="ln1010">			return auvia_list_mix_channels(card, (multi_mix_channel_info *)data);</a>
<a name="ln1011">		case B_MULTI_LIST_MIX_CONTROLS:</a>
<a name="ln1012">			LOG((&quot;B_MULTI_LIST_MIX_CONTROLS\n&quot;));</a>
<a name="ln1013">			return auvia_list_mix_controls(card, (multi_mix_control_info *)data);</a>
<a name="ln1014">		case B_MULTI_LIST_MIX_CONNECTIONS:</a>
<a name="ln1015">			LOG((&quot;B_MULTI_LIST_MIX_CONNECTIONS\n&quot;));</a>
<a name="ln1016">			return auvia_list_mix_connections(card, (multi_mix_connection_info *)data);</a>
<a name="ln1017">		case B_MULTI_GET_BUFFERS:			/* Fill out the struct for the first time; doesn't start anything. */</a>
<a name="ln1018">			LOG((&quot;B_MULTI_GET_BUFFERS\n&quot;));</a>
<a name="ln1019">			return auvia_get_buffers(card, data);</a>
<a name="ln1020">		case B_MULTI_SET_BUFFERS:			/* Set what buffers to use, if the driver supports soft buffers. */</a>
<a name="ln1021">			LOG((&quot;B_MULTI_SET_BUFFERS\n&quot;));</a>
<a name="ln1022">			return B_ERROR; /* we do not support soft buffers */</a>
<a name="ln1023">		case B_MULTI_SET_START_TIME:			/* When to actually start */</a>
<a name="ln1024">			LOG((&quot;B_MULTI_SET_START_TIME\n&quot;));</a>
<a name="ln1025">			return B_ERROR;</a>
<a name="ln1026">		case B_MULTI_BUFFER_EXCHANGE:		/* stop and go are derived from this being called */</a>
<a name="ln1027">			//TRACE((&quot;B_MULTI_BUFFER_EXCHANGE\n&quot;));</a>
<a name="ln1028">			return auvia_buffer_exchange(card, (multi_buffer_info *)data);</a>
<a name="ln1029">		case B_MULTI_BUFFER_FORCE_STOP:		/* force stop of playback, nothing in data */</a>
<a name="ln1030">			LOG((&quot;B_MULTI_BUFFER_FORCE_STOP\n&quot;));</a>
<a name="ln1031">			return auvia_buffer_force_stop(card);</a>
<a name="ln1032">	}</a>
<a name="ln1033">	LOG((&quot;ERROR: unknown multi_control %#x\n&quot;,op));</a>
<a name="ln1034">	return B_ERROR;</a>
<a name="ln1035">}</a>
<a name="ln1036"> </a>
<a name="ln1037">static status_t auvia_open(const char *name, uint32 flags, void** cookie);</a>
<a name="ln1038">static status_t auvia_close(void* cookie);</a>
<a name="ln1039">static status_t auvia_free(void* cookie);</a>
<a name="ln1040">static status_t auvia_control(void* cookie, uint32 op, void* arg, size_t len);</a>
<a name="ln1041">static status_t auvia_read(void* cookie, off_t position, void *buf, size_t* num_bytes);</a>
<a name="ln1042">static status_t auvia_write(void* cookie, off_t position, const void* buffer, size_t* num_bytes);</a>
<a name="ln1043"> </a>
<a name="ln1044">device_hooks multi_hooks = {</a>
<a name="ln1045">	auvia_open, 			/* -&gt; open entry point */</a>
<a name="ln1046">	auvia_close, 			/* -&gt; close entry point */</a>
<a name="ln1047">	auvia_free,			/* -&gt; free cookie */</a>
<a name="ln1048">	auvia_control, 		/* -&gt; control entry point */</a>
<a name="ln1049">	auvia_read,			/* -&gt; read entry point */</a>
<a name="ln1050">	auvia_write,			/* -&gt; write entry point */</a>
<a name="ln1051">	NULL,					/* start select */</a>
<a name="ln1052">	NULL,					/* stop select */</a>
<a name="ln1053">	NULL,					/* scatter-gather read from the device */</a>
<a name="ln1054">	NULL					/* scatter-gather write to the device */</a>
<a name="ln1055">};</a>
<a name="ln1056"> </a>
<a name="ln1057"> </a>
<a name="ln1058">static status_t</a>
<a name="ln1059">auvia_open(const char *name, uint32 flags, void** cookie)</a>
<a name="ln1060">{</a>
<a name="ln1061">	auvia_dev *card = NULL;</a>
<a name="ln1062">	int ix;</a>
<a name="ln1063"> </a>
<a name="ln1064">	LOG((&quot;open()\n&quot;));</a>
<a name="ln1065"> </a>
<a name="ln1066">	for (ix=0; ix&lt;num_cards; ix++) {</a>
<a name="ln1067">		if (!strcmp(cards[ix].name, name)) {</a>
<a name="ln1068">			card = &amp;cards[ix];</a>
<a name="ln1069">		}</a>
<a name="ln1070">	}</a>
<a name="ln1071"> </a>
<a name="ln1072">	if (card == NULL) {</a>
<a name="ln1073">		LOG((&quot;open() card not found %s\n&quot;, name));</a>
<a name="ln1074">		for (ix=0; ix&lt;num_cards; ix++) {</a>
<a name="ln1075">			LOG((&quot;open() card available %s\n&quot;, cards[ix].name));</a>
<a name="ln1076">		}</a>
<a name="ln1077">		return B_ERROR;</a>
<a name="ln1078">	}</a>
<a name="ln1079"> </a>
<a name="ln1080">	LOG((&quot;open() got card\n&quot;));</a>
<a name="ln1081"> </a>
<a name="ln1082">	if (card-&gt;pstream !=NULL)</a>
<a name="ln1083">		return B_ERROR;</a>
<a name="ln1084">	if (card-&gt;rstream !=NULL)</a>
<a name="ln1085">		return B_ERROR;</a>
<a name="ln1086"> </a>
<a name="ln1087">	*cookie = card;</a>
<a name="ln1088">	card-&gt;multi.card = card;</a>
<a name="ln1089"> </a>
<a name="ln1090">	LOG((&quot;stream_new\n&quot;));</a>
<a name="ln1091"> </a>
<a name="ln1092">	card-&gt;rstream = auvia_stream_new(card, AUVIA_USE_RECORD, BUFFER_FRAMES, BUFFER_COUNT);</a>
<a name="ln1093">	card-&gt;pstream = auvia_stream_new(card, AUVIA_USE_PLAY, BUFFER_FRAMES, BUFFER_COUNT);</a>
<a name="ln1094"> </a>
<a name="ln1095">	card-&gt;buffer_ready_sem = create_sem(0, &quot;pbuffer ready&quot;);</a>
<a name="ln1096"> </a>
<a name="ln1097">	LOG((&quot;stream_setaudio\n&quot;));</a>
<a name="ln1098"> </a>
<a name="ln1099">	auvia_stream_set_audioparms(card-&gt;pstream, 2, true, 48000);</a>
<a name="ln1100">	auvia_stream_set_audioparms(card-&gt;rstream, 2, true, 48000);</a>
<a name="ln1101"> </a>
<a name="ln1102">	card-&gt;pstream-&gt;first_channel = 0;</a>
<a name="ln1103">	card-&gt;rstream-&gt;first_channel = 2;</a>
<a name="ln1104"> </a>
<a name="ln1105">	auvia_stream_commit_parms(card-&gt;pstream);</a>
<a name="ln1106">	auvia_stream_commit_parms(card-&gt;rstream);</a>
<a name="ln1107"> </a>
<a name="ln1108">	auvia_create_channels_list(&amp;card-&gt;multi);</a>
<a name="ln1109"> </a>
<a name="ln1110">	return B_OK;</a>
<a name="ln1111">}</a>
<a name="ln1112"> </a>
<a name="ln1113"> </a>
<a name="ln1114">static status_t</a>
<a name="ln1115">auvia_close(void* cookie)</a>
<a name="ln1116">{</a>
<a name="ln1117">	//auvia_dev *card = cookie;</a>
<a name="ln1118">	LOG((&quot;close()\n&quot;));</a>
<a name="ln1119"> </a>
<a name="ln1120">	return B_OK;</a>
<a name="ln1121">}</a>
<a name="ln1122"> </a>
<a name="ln1123"> </a>
<a name="ln1124">static status_t</a>
<a name="ln1125">auvia_free(void* cookie)</a>
<a name="ln1126">{</a>
<a name="ln1127">	auvia_dev *card = cookie;</a>
<a name="ln1128">	auvia_stream *stream;</a>
<a name="ln1129">	LOG((&quot;free()\n&quot;));</a>
<a name="ln1130"> </a>
<a name="ln1131">	if (card-&gt;buffer_ready_sem &gt; B_OK)</a>
<a name="ln1132">			delete_sem(card-&gt;buffer_ready_sem);</a>
<a name="ln1133"> </a>
<a name="ln1134">	LIST_FOREACH(stream, &amp;card-&gt;streams, next) {</a>
<a name="ln1135">		auvia_stream_halt(stream);</a>
<a name="ln1136">	}</a>
<a name="ln1137"> </a>
<a name="ln1138">	while (!LIST_EMPTY(&amp;card-&gt;streams)) {</a>
<a name="ln1139">		auvia_stream_delete(LIST_FIRST(&amp;card-&gt;streams));</a>
<a name="ln1140">	}</a>
<a name="ln1141"> </a>
<a name="ln1142">	card-&gt;pstream = NULL;</a>
<a name="ln1143">	card-&gt;rstream = NULL;</a>
<a name="ln1144"> </a>
<a name="ln1145">	return B_OK;</a>
<a name="ln1146">}</a>
<a name="ln1147"> </a>
<a name="ln1148"> </a>
<a name="ln1149">static status_t</a>
<a name="ln1150">auvia_control(void* cookie, uint32 op, void* arg, size_t len)</a>
<a name="ln1151">{</a>
<a name="ln1152">	return auvia_multi_control(cookie, op, arg, len);</a>
<a name="ln1153">}</a>
<a name="ln1154"> </a>
<a name="ln1155"> </a>
<a name="ln1156">static status_t</a>
<a name="ln1157">auvia_read(void* cookie, off_t position, void *buf, size_t* num_bytes)</a>
<a name="ln1158">{</a>
<a name="ln1159">	*num_bytes = 0;				/* tell caller nothing was read */</a>
<a name="ln1160">	return B_IO_ERROR;</a>
<a name="ln1161">}</a>
<a name="ln1162"> </a>
<a name="ln1163"> </a>
<a name="ln1164">static status_t</a>
<a name="ln1165">auvia_write(void* cookie, off_t position, const void* buffer, size_t* num_bytes)</a>
<a name="ln1166">{</a>
<a name="ln1167">	*num_bytes = 0;				/* tell caller nothing was written */</a>
<a name="ln1168">	return B_IO_ERROR;</a>
<a name="ln1169">}</a>

</code></pre>
<div class="balloon" rel="393"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'debug_printf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="406"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'debug_printf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="446"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'debug_printf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="456"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'debug_printf' function. The memsize type argument is expected.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
