
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>WidgetAttributeText.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">Open Tracker License</a>
<a name="ln3"> </a>
<a name="ln4">Terms and Conditions</a>
<a name="ln5"> </a>
<a name="ln6">Copyright (c) 1991-2000, Be Incorporated. All rights reserved.</a>
<a name="ln7"> </a>
<a name="ln8">Permission is hereby granted, free of charge, to any person obtaining a copy of</a>
<a name="ln9">this software and associated documentation files (the &quot;Software&quot;), to deal in</a>
<a name="ln10">the Software without restriction, including without limitation the rights to</a>
<a name="ln11">use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies</a>
<a name="ln12">of the Software, and to permit persons to whom the Software is furnished to do</a>
<a name="ln13">so, subject to the following conditions:</a>
<a name="ln14"> </a>
<a name="ln15">The above copyright notice and this permission notice applies to all licensees</a>
<a name="ln16">and shall be included in all copies or substantial portions of the Software.</a>
<a name="ln17"> </a>
<a name="ln18">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</a>
<a name="ln19">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF TITLE, MERCHANTABILITY,</a>
<a name="ln20">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL</a>
<a name="ln21">BE INCORPORATED BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN</a>
<a name="ln22">AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION</a>
<a name="ln23">WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</a>
<a name="ln24"> </a>
<a name="ln25">Except as contained in this notice, the name of Be Incorporated shall not be</a>
<a name="ln26">used in advertising or otherwise to promote the sale, use or other dealings in</a>
<a name="ln27">this Software without prior written authorization from Be Incorporated.</a>
<a name="ln28"> </a>
<a name="ln29">Tracker(TM), Be(R), BeOS(R), and BeIA(TM) are trademarks or registered trademarks</a>
<a name="ln30">of Be Incorporated in the United States and other countries. Other brand product</a>
<a name="ln31">names are registered trademarks or trademarks of their respective holders.</a>
<a name="ln32">All rights reserved.</a>
<a name="ln33">*/</a>
<a name="ln34"> </a>
<a name="ln35"> </a>
<a name="ln36">#include &quot;WidgetAttributeText.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">#include &lt;ctype.h&gt;</a>
<a name="ln39">#include &lt;stdlib.h&gt;</a>
<a name="ln40">#include &lt;strings.h&gt;</a>
<a name="ln41"> </a>
<a name="ln42">#include &lt;fs_attr.h&gt;</a>
<a name="ln43">#include &lt;parsedate.h&gt;</a>
<a name="ln44"> </a>
<a name="ln45">#include &lt;Alert.h&gt;</a>
<a name="ln46">#include &lt;AppFileInfo.h&gt;</a>
<a name="ln47">#include &lt;Catalog.h&gt;</a>
<a name="ln48">#include &lt;DateFormat.h&gt;</a>
<a name="ln49">#include &lt;DateTimeFormat.h&gt;</a>
<a name="ln50">#include &lt;Debug.h&gt;</a>
<a name="ln51">#include &lt;Locale.h&gt;</a>
<a name="ln52">#include &lt;NodeInfo.h&gt;</a>
<a name="ln53">#include &lt;Path.h&gt;</a>
<a name="ln54">#include &lt;StringFormat.h&gt;</a>
<a name="ln55">#include &lt;SupportDefs.h&gt;</a>
<a name="ln56">#include &lt;TextView.h&gt;</a>
<a name="ln57">#include &lt;Volume.h&gt;</a>
<a name="ln58">#include &lt;VolumeRoster.h&gt;</a>
<a name="ln59"> </a>
<a name="ln60">#include &quot;Attributes.h&quot;</a>
<a name="ln61">#include &quot;FindPanel.h&quot;</a>
<a name="ln62">#include &quot;FSUndoRedo.h&quot;</a>
<a name="ln63">#include &quot;FSUtils.h&quot;</a>
<a name="ln64">#include &quot;Model.h&quot;</a>
<a name="ln65">#include &quot;OpenWithWindow.h&quot;</a>
<a name="ln66">#include &quot;MimeTypes.h&quot;</a>
<a name="ln67">#include &quot;PoseView.h&quot;</a>
<a name="ln68">#include &quot;SettingsViews.h&quot;</a>
<a name="ln69">#include &quot;Utilities.h&quot;</a>
<a name="ln70">#include &quot;ViewState.h&quot;</a>
<a name="ln71"> </a>
<a name="ln72"> </a>
<a name="ln73">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln74">#define B_TRANSLATION_CONTEXT &quot;WidgetAttributeText&quot;</a>
<a name="ln75"> </a>
<a name="ln76"> </a>
<a name="ln77">const int32 kGenericReadBufferSize = 1024;</a>
<a name="ln78"> </a>
<a name="ln79">const char* kSizeFormats[] = {</a>
<a name="ln80">	&quot;%.2f %s&quot;,</a>
<a name="ln81">	&quot;%.1f %s&quot;,</a>
<a name="ln82">	&quot;%.f %s&quot;,</a>
<a name="ln83">	&quot;%.f%s&quot;,</a>
<a name="ln84">	0</a>
<a name="ln85">};</a>
<a name="ln86"> </a>
<a name="ln87"> </a>
<a name="ln88">bool NameAttributeText::sSortFolderNamesFirst = false;</a>
<a name="ln89">bool RealNameAttributeText::sSortFolderNamesFirst = false;</a>
<a name="ln90"> </a>
<a name="ln91"> </a>
<a name="ln92">template &lt;class View&gt;</a>
<a name="ln93">float</a>
<a name="ln94">TruncFileSizeBase(BString* outString, int64 value, const View* view,</a>
<a name="ln95">	float width)</a>
<a name="ln96">{</a>
<a name="ln97">	// ToDo: If slow, replace float divisions with shifts</a>
<a name="ln98">	//       if fast enough, try fitting more decimal places.</a>
<a name="ln99"> </a>
<a name="ln100">	// ToDo: Update string_for_size() in libshared to be able to</a>
<a name="ln101">	//       handle this case.</a>
<a name="ln102"> </a>
<a name="ln103">	BString buffer;</a>
<a name="ln104"> </a>
<a name="ln105">	// format file size value</a>
<a name="ln106">	if (value == kUnknownSize) {</a>
<a name="ln107">		*outString = &quot;-&quot;;</a>
<a name="ln108">		return view-&gt;StringWidth(&quot;-&quot;);</a>
<a name="ln109">	} else if (value &lt; kKBSize) {</a>
<a name="ln110">		static BStringFormat format(B_TRANSLATE(</a>
<a name="ln111">			&quot;{0, plural, one{# byte} other{# bytes}}&quot;));</a>
<a name="ln112">		format.Format(buffer, value);</a>
<a name="ln113">		if (view-&gt;StringWidth(buffer.String()) &gt; width)</a>
<a name="ln114">			buffer.SetToFormat(B_TRANSLATE(&quot;%Ld B&quot;), value);</a>
<a name="ln115">	} else {</a>
<a name="ln116">		const char* suffix;</a>
<a name="ln117">		float doubleValue;</a>
<a name="ln118">		if (value &gt;= kTBSize) {</a>
<a name="ln119">			suffix = B_TRANSLATE(&quot;TiB&quot;);</a>
<a name="ln120">			doubleValue = (double)value / kTBSize;</a>
<a name="ln121">		} else if (value &gt;= kGBSize) {</a>
<a name="ln122">			suffix = B_TRANSLATE(&quot;GiB&quot;);</a>
<a name="ln123">			doubleValue = (double)value / kGBSize;</a>
<a name="ln124">		} else if (value &gt;= kMBSize) {</a>
<a name="ln125">			suffix = B_TRANSLATE(&quot;MiB&quot;);</a>
<a name="ln126">			doubleValue = (double)value / kMBSize;</a>
<a name="ln127">		} else {</a>
<a name="ln128">			ASSERT(value &gt;= kKBSize);</a>
<a name="ln129">			suffix = B_TRANSLATE(&quot;KiB&quot;);</a>
<a name="ln130">			doubleValue = (double)value / kKBSize;</a>
<a name="ln131">		}</a>
<a name="ln132"> </a>
<a name="ln133">		for (int32 index = 0; ; index++) {</a>
<a name="ln134">			if (kSizeFormats[index] == 0)</a>
<a name="ln135">				break;</a>
<a name="ln136"> </a>
<a name="ln137">			buffer.SetToFormat(kSizeFormats[index], doubleValue, suffix);</a>
<a name="ln138">			// strip off an insignificant zero so we don't get readings</a>
<a name="ln139">			// such as 1.00</a>
<a name="ln140">			char* period = 0;</a>
<a name="ln141">			for (char* tmp = const_cast&lt;char*&gt;(buffer.String()); *tmp != '\0';</a>
<a name="ln142">					tmp++) {</a>
<a name="ln143">				if (*tmp == '.')</a>
<a name="ln144">					period = tmp;</a>
<a name="ln145">			}</a>
<a name="ln146">			if (period &amp;&amp; period[1] &amp;&amp; period[2] == '0')</a>
<a name="ln147">				// move the rest of the string over the insignificant zero</a>
<a name="ln148">				for (char* tmp = &amp;period[2]; *tmp; tmp++)</a>
<a name="ln149">					*tmp = tmp[1];</a>
<a name="ln150"> </a>
<a name="ln151">			float resultWidth = view-&gt;StringWidth(buffer);</a>
<a name="ln152">			if (resultWidth &lt;= width) {</a>
<a name="ln153">				*outString = buffer.String();</a>
<a name="ln154">				return resultWidth;</a>
<a name="ln155">			}</a>
<a name="ln156">		}</a>
<a name="ln157">	}</a>
<a name="ln158"> </a>
<a name="ln159">	return TruncStringBase(outString, buffer.String(), buffer.Length(), view,</a>
<a name="ln160">		width, (uint32)B_TRUNCATE_END);</a>
<a name="ln161">}</a>
<a name="ln162"> </a>
<a name="ln163"> </a>
<a name="ln164">template &lt;class View&gt;</a>
<a name="ln165">float</a>
<a name="ln166">TruncStringBase(BString* outString, const char* inString, int32 length,</a>
<a name="ln167">	const View* view, float width, uint32 truncMode = B_TRUNCATE_MIDDLE)</a>
<a name="ln168">{</a>
<a name="ln169">	// we are using a template version of this call to make sure</a>
<a name="ln170">	// the right StringWidth gets picked up for BView x BPoseView</a>
<a name="ln171">	// for max speed and flexibility</a>
<a name="ln172"> </a>
<a name="ln173">	// a standard ellipsis inserting fitting algorithm</a>
<a name="ln174">	if (view-&gt;StringWidth(inString, length) &lt;= width)</a>
<a name="ln175">		*outString = inString;</a>
<a name="ln176">	else {</a>
<a name="ln177">		const char* source[1];</a>
<a name="ln178">		char* results[1];</a>
<a name="ln179"> </a>
<a name="ln180">		source[0] = inString;</a>
<a name="ln181">		results[0] = outString-&gt;LockBuffer(length + 3);</a>
<a name="ln182"> </a>
<a name="ln183">		BFont font;</a>
<a name="ln184">		view-&gt;GetFont(&amp;font);</a>
<a name="ln185"> </a>
<a name="ln186">		font.GetTruncatedStrings(source, 1, truncMode, width, results);</a>
<a name="ln187">		outString-&gt;UnlockBuffer();</a>
<a name="ln188">	}</a>
<a name="ln189"> </a>
<a name="ln190">	return view-&gt;StringWidth(outString-&gt;String(), outString-&gt;Length());</a>
<a name="ln191">}</a>
<a name="ln192"> </a>
<a name="ln193"> </a>
<a name="ln194">template &lt;class View&gt;</a>
<a name="ln195">float</a>
<a name="ln196">TruncTimeBase(BString* outString, int64 value, const View* view, float width)</a>
<a name="ln197">{</a>
<a name="ln198">	float resultWidth = width + 1;</a>
<a name="ln199"> </a>
<a name="ln200">	time_t timeValue = (time_t)value;</a>
<a name="ln201"> </a>
<a name="ln202">	// Find the longest possible format that will fit the available space</a>
<a name="ln203">	struct {</a>
<a name="ln204">		BDateFormatStyle dateStyle;</a>
<a name="ln205">		BTimeFormatStyle timeStyle;</a>
<a name="ln206">	} formats[] = {</a>
<a name="ln207">		{ B_LONG_DATE_FORMAT, B_MEDIUM_TIME_FORMAT },</a>
<a name="ln208">		{ B_LONG_DATE_FORMAT, B_SHORT_TIME_FORMAT },</a>
<a name="ln209">		{ B_MEDIUM_DATE_FORMAT, B_SHORT_TIME_FORMAT },</a>
<a name="ln210">		{ B_SHORT_DATE_FORMAT, B_SHORT_TIME_FORMAT },</a>
<a name="ln211">	};</a>
<a name="ln212"> </a>
<a name="ln213">	BString date;</a>
<a name="ln214">	BDateTimeFormat formatter;</a>
<a name="ln215">	for (unsigned int i = 0; i &lt; B_COUNT_OF(formats); ++i) {</a>
<a name="ln216">		if (formatter.Format(date, timeValue, formats[i].dateStyle,</a>
<a name="ln217">				formats[i].timeStyle) == B_OK) {</a>
<a name="ln218">			resultWidth = view-&gt;StringWidth(date.String(), date.Length());</a>
<a name="ln219">			if (resultWidth &lt;= width) {</a>
<a name="ln220">				// Found a format that fits the available space, stop searching</a>
<a name="ln221">				break;</a>
<a name="ln222">			}</a>
<a name="ln223">		}</a>
<a name="ln224">	}</a>
<a name="ln225"> </a>
<a name="ln226">	// If we couldn't fit the date, try with just the time</a>
<a name="ln227">	// TODO we could use only the time for &quot;today&quot; dates</a>
<a name="ln228">	if (resultWidth &gt; width</a>
<a name="ln229">		&amp;&amp; BDateFormat().Format(date, timeValue,</a>
<a name="ln230">			B_SHORT_DATE_FORMAT) == B_OK) {</a>
<a name="ln231">		resultWidth = view-&gt;StringWidth(date.String(), date.Length());</a>
<a name="ln232">	}</a>
<a name="ln233"> </a>
<a name="ln234">	if (resultWidth &gt; width) {</a>
<a name="ln235">		// even the shortest format string didn't do it, insert ellipsis</a>
<a name="ln236">		resultWidth = TruncStringBase(outString, date.String(),</a>
<a name="ln237">			(ssize_t)date.Length(), view, width);</a>
<a name="ln238">	} else</a>
<a name="ln239">		*outString = date;</a>
<a name="ln240"> </a>
<a name="ln241">	return resultWidth;</a>
<a name="ln242">}</a>
<a name="ln243"> </a>
<a name="ln244"> </a>
<a name="ln245">// #pragma mark - WidgetAttributeText base class</a>
<a name="ln246"> </a>
<a name="ln247"> </a>
<a name="ln248">WidgetAttributeText*</a>
<a name="ln249">WidgetAttributeText::NewWidgetText(const Model* model,</a>
<a name="ln250">	const BColumn* column, const BPoseView* view)</a>
<a name="ln251">{</a>
<a name="ln252">	// call this to make the right WidgetAttributeText type for a</a>
<a name="ln253">	// given column</a>
<a name="ln254"> </a>
<a name="ln255">	const char* attrName = column-&gt;AttrName();</a>
<a name="ln256"> </a>
<a name="ln257">	if (strcmp(attrName, kAttrPath) == 0)</a>
<a name="ln258">		return new PathAttributeText(model, column);</a>
<a name="ln259"> </a>
<a name="ln260">	if (strcmp(attrName, kAttrMIMEType) == 0)</a>
<a name="ln261">		return new KindAttributeText(model, column);</a>
<a name="ln262"> </a>
<a name="ln263">	if (strcmp(attrName, kAttrStatName) == 0)</a>
<a name="ln264">		return new NameAttributeText(model, column);</a>
<a name="ln265"> </a>
<a name="ln266">	if (strcmp(attrName, kAttrRealName) == 0)</a>
<a name="ln267">		return new RealNameAttributeText(model, column);</a>
<a name="ln268"> </a>
<a name="ln269">	if (strcmp(attrName, kAttrStatSize) == 0)</a>
<a name="ln270">		return new SizeAttributeText(model, column);</a>
<a name="ln271"> </a>
<a name="ln272">	if (strcmp(attrName, kAttrStatModified) == 0)</a>
<a name="ln273">		return new ModificationTimeAttributeText(model, column);</a>
<a name="ln274"> </a>
<a name="ln275">	if (strcmp(attrName, kAttrStatCreated) == 0)</a>
<a name="ln276">		return new CreationTimeAttributeText(model, column);</a>
<a name="ln277"> </a>
<a name="ln278">#ifdef OWNER_GROUP_ATTRIBUTES</a>
<a name="ln279">	if (strcmp(attrName, kAttrStatOwner) == 0)</a>
<a name="ln280">		return new OwnerAttributeText(model, column);</a>
<a name="ln281"> </a>
<a name="ln282">	if (strcmp(attrName, kAttrStatGroup) == 0)</a>
<a name="ln283">		return new GroupAttributeText(model, column);</a>
<a name="ln284">#endif</a>
<a name="ln285">	if (strcmp(attrName, kAttrStatMode) == 0)</a>
<a name="ln286">		return new ModeAttributeText(model, column);</a>
<a name="ln287"> </a>
<a name="ln288">	if (strcmp(attrName, kAttrOpenWithRelation) == 0)</a>
<a name="ln289">		return new OpenWithRelationAttributeText(model, column, view);</a>
<a name="ln290"> </a>
<a name="ln291">	if (strcmp(attrName, kAttrAppVersion) == 0)</a>
<a name="ln292">		return new AppShortVersionAttributeText(model, column);</a>
<a name="ln293"> </a>
<a name="ln294">	if (strcmp(attrName, kAttrSystemVersion) == 0)</a>
<a name="ln295">		return new SystemShortVersionAttributeText(model, column);</a>
<a name="ln296"> </a>
<a name="ln297">	if (strcmp(attrName, kAttrOriginalPath) == 0)</a>
<a name="ln298">		return new OriginalPathAttributeText(model, column);</a>
<a name="ln299"> </a>
<a name="ln300">	if (column-&gt;DisplayAs() != NULL) {</a>
<a name="ln301">		if (!strncmp(column-&gt;DisplayAs(), &quot;checkbox&quot;, 8))</a>
<a name="ln302">			return new CheckboxAttributeText(model, column);</a>
<a name="ln303"> </a>
<a name="ln304">		if (!strncmp(column-&gt;DisplayAs(), &quot;duration&quot;, 8))</a>
<a name="ln305">			return new DurationAttributeText(model, column);</a>
<a name="ln306"> </a>
<a name="ln307">		if (!strncmp(column-&gt;DisplayAs(), &quot;rating&quot;, 6))</a>
<a name="ln308">			return new RatingAttributeText(model, column);</a>
<a name="ln309">	}</a>
<a name="ln310"> </a>
<a name="ln311">	return new GenericAttributeText(model, column);</a>
<a name="ln312">}</a>
<a name="ln313"> </a>
<a name="ln314"> </a>
<a name="ln315">WidgetAttributeText::WidgetAttributeText(const Model* model,</a>
<a name="ln316">	const BColumn* column)</a>
<a name="ln317">	:</a>
<a name="ln318">	fModel(const_cast&lt;Model*&gt;(model)),</a>
<a name="ln319">	fColumn(column),</a>
<a name="ln320">	fOldWidth(-1.0f),</a>
<a name="ln321">	fTruncatedWidth(-1.0f),</a>
<a name="ln322">	fDirty(true),</a>
<a name="ln323">	fValueIsDefined(false)</a>
<a name="ln324">{</a>
<a name="ln325">	ASSERT(fColumn != NULL);</a>
<a name="ln326"> </a>
<a name="ln327">	if (fColumn == NULL)</a>
<a name="ln328">		return;</a>
<a name="ln329"> </a>
<a name="ln330">	ASSERT(fColumn-&gt;Width() &gt; 0);</a>
<a name="ln331">}</a>
<a name="ln332"> </a>
<a name="ln333"> </a>
<a name="ln334">WidgetAttributeText::~WidgetAttributeText()</a>
<a name="ln335">{</a>
<a name="ln336">}</a>
<a name="ln337"> </a>
<a name="ln338"> </a>
<a name="ln339">const char*</a>
<a name="ln340">WidgetAttributeText::FittingText(const BPoseView* view)</a>
<a name="ln341">{</a>
<a name="ln342">	if (fDirty || fColumn-&gt;Width() != fOldWidth || CheckSettingsChanged()</a>
<a name="ln343">		|| !fValueIsDefined) {</a>
<a name="ln344">		CheckViewChanged(view);</a>
<a name="ln345">	}</a>
<a name="ln346"> </a>
<a name="ln347">	ASSERT(!fDirty);</a>
<a name="ln348">	return fText.String();</a>
<a name="ln349">}</a>
<a name="ln350"> </a>
<a name="ln351"> </a>
<a name="ln352">bool</a>
<a name="ln353">WidgetAttributeText::CheckViewChanged(const BPoseView* view)</a>
<a name="ln354">{</a>
<a name="ln355">	BString newText;</a>
<a name="ln356">	FitValue(&amp;newText, view);</a>
<a name="ln357">	if (newText == fText)</a>
<a name="ln358">		return false;</a>
<a name="ln359"> </a>
<a name="ln360">	fText = newText;</a>
<a name="ln361">	return true;</a>
<a name="ln362">}</a>
<a name="ln363"> </a>
<a name="ln364"> </a>
<a name="ln365">bool</a>
<a name="ln366">WidgetAttributeText::CheckSettingsChanged()</a>
<a name="ln367">{</a>
<a name="ln368">	return false;</a>
<a name="ln369">}</a>
<a name="ln370"> </a>
<a name="ln371"> </a>
<a name="ln372">float</a>
<a name="ln373">WidgetAttributeText::TruncString(BString* outString, const char* inString,</a>
<a name="ln374">	int32 length, const BPoseView* view, float width, uint32 truncMode)</a>
<a name="ln375">{</a>
<a name="ln376">	return TruncStringBase(outString, inString, length, view, width, truncMode);</a>
<a name="ln377">}</a>
<a name="ln378"> </a>
<a name="ln379"> </a>
<a name="ln380">float</a>
<a name="ln381">WidgetAttributeText::TruncFileSize(BString* outString, int64 value,</a>
<a name="ln382">	const BPoseView* view, float width)</a>
<a name="ln383">{</a>
<a name="ln384">	return TruncFileSizeBase(outString, value, view, width);</a>
<a name="ln385">}</a>
<a name="ln386"> </a>
<a name="ln387"> </a>
<a name="ln388">float</a>
<a name="ln389">WidgetAttributeText::TruncTime(BString* outString, int64 value,</a>
<a name="ln390">	const BPoseView* view, float width)</a>
<a name="ln391">{</a>
<a name="ln392">	return TruncTimeBase(outString, value, view, width);</a>
<a name="ln393">}</a>
<a name="ln394"> </a>
<a name="ln395"> </a>
<a name="ln396">float</a>
<a name="ln397">WidgetAttributeText::CurrentWidth() const</a>
<a name="ln398">{</a>
<a name="ln399">	return fTruncatedWidth;</a>
<a name="ln400">}</a>
<a name="ln401"> </a>
<a name="ln402"> </a>
<a name="ln403">float</a>
<a name="ln404">WidgetAttributeText::Width(const BPoseView* pose)</a>
<a name="ln405">{</a>
<a name="ln406">	FittingText(pose);</a>
<a name="ln407">	return CurrentWidth();</a>
<a name="ln408">}</a>
<a name="ln409"> </a>
<a name="ln410"> </a>
<a name="ln411">void</a>
<a name="ln412">WidgetAttributeText::SetUpEditing(BTextView*)</a>
<a name="ln413">{</a>
<a name="ln414">	ASSERT(fColumn-&gt;Editable());</a>
<a name="ln415">}</a>
<a name="ln416"> </a>
<a name="ln417"> </a>
<a name="ln418">bool</a>
<a name="ln419">WidgetAttributeText::CommitEditedText(BTextView*)</a>
<a name="ln420">{</a>
<a name="ln421">	// can't do anything here at this point</a>
<a name="ln422">	TRESPASS();</a>
<a name="ln423">	return false;</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426"> </a>
<a name="ln427">status_t</a>
<a name="ln428">WidgetAttributeText::AttrAsString(const Model* model, BString* outString,</a>
<a name="ln429">	const char* attrName, int32 attrType, float width, BView* view,</a>
<a name="ln430">	int64* resultingValue)</a>
<a name="ln431">{</a>
<a name="ln432">	int64 value;</a>
<a name="ln433"> </a>
<a name="ln434">	status_t error = model-&gt;InitCheck();</a>
<a name="ln435">	if (error != B_OK)</a>
<a name="ln436">		return error;</a>
<a name="ln437"> </a>
<a name="ln438">	switch (attrType) {</a>
<a name="ln439">		case B_TIME_TYPE:</a>
<a name="ln440">			if (strcmp(attrName, kAttrStatModified) == 0)</a>
<a name="ln441">				value = model-&gt;StatBuf()-&gt;st_mtime;</a>
<a name="ln442">			else if (strcmp(attrName, kAttrStatCreated) == 0)</a>
<a name="ln443">				value = model-&gt;StatBuf()-&gt;st_crtime;</a>
<a name="ln444">			else {</a>
<a name="ln445">				TRESPASS();</a>
<a name="ln446">				// not yet supported</a>
<a name="ln447">				return B_ERROR;</a>
<a name="ln448">			}</a>
<a name="ln449">			TruncTimeBase(outString, value, view, width);</a>
<a name="ln450">			if (resultingValue)</a>
<a name="ln451">				*resultingValue = value;</a>
<a name="ln452"> </a>
<a name="ln453">			return B_OK;</a>
<a name="ln454"> </a>
<a name="ln455">		case B_STRING_TYPE:</a>
<a name="ln456">			if (strcmp(attrName, kAttrPath) == 0) {</a>
<a name="ln457">				BEntry entry(model-&gt;EntryRef());</a>
<a name="ln458">				BPath path;</a>
<a name="ln459">				BString tmp;</a>
<a name="ln460"> </a>
<a name="ln461">				if (entry.InitCheck() == B_OK</a>
<a name="ln462">					&amp;&amp; entry.GetPath(&amp;path) == B_OK) {</a>
<a name="ln463">					tmp = path.Path();</a>
<a name="ln464">					TruncateLeaf(&amp;tmp);</a>
<a name="ln465">				} else</a>
<a name="ln466">					tmp = &quot;-&quot;;</a>
<a name="ln467"> </a>
<a name="ln468">				if (width &gt; 0) {</a>
<a name="ln469">					TruncStringBase(outString, tmp.String(), tmp.Length(), view,</a>
<a name="ln470">						width);</a>
<a name="ln471">				} else</a>
<a name="ln472">					*outString = tmp.String();</a>
<a name="ln473"> </a>
<a name="ln474">				return B_OK;</a>
<a name="ln475">			}</a>
<a name="ln476">			break;</a>
<a name="ln477"> </a>
<a name="ln478">		case kSizeType:</a>
<a name="ln479">//			TruncFileSizeBase(outString, model-&gt;StatBuf()-&gt;st_size, view,</a>
<a name="ln480">//				width);</a>
<a name="ln481">			return B_OK;</a>
<a name="ln482">			break;</a>
<a name="ln483"> </a>
<a name="ln484">		default:</a>
<a name="ln485">			TRESPASS();</a>
<a name="ln486">			// not yet supported</a>
<a name="ln487">			return B_ERROR;</a>
<a name="ln488"> </a>
<a name="ln489">	}</a>
<a name="ln490"> </a>
<a name="ln491">	TRESPASS();</a>
<a name="ln492">	return B_ERROR;</a>
<a name="ln493">}</a>
<a name="ln494"> </a>
<a name="ln495"> </a>
<a name="ln496">bool</a>
<a name="ln497">WidgetAttributeText::IsEditable() const</a>
<a name="ln498">{</a>
<a name="ln499">	return fColumn-&gt;Editable()</a>
<a name="ln500">		&amp;&amp; !BVolume(fModel-&gt;StatBuf()-&gt;st_dev).IsReadOnly();</a>
<a name="ln501">}</a>
<a name="ln502"> </a>
<a name="ln503"> </a>
<a name="ln504">void</a>
<a name="ln505">WidgetAttributeText::SetDirty(bool value)</a>
<a name="ln506">{</a>
<a name="ln507">	fDirty = value;</a>
<a name="ln508">}</a>
<a name="ln509"> </a>
<a name="ln510"> </a>
<a name="ln511">// #pragma mark - StringAttributeText</a>
<a name="ln512"> </a>
<a name="ln513"> </a>
<a name="ln514">StringAttributeText::StringAttributeText(const Model* model,</a>
<a name="ln515">	const BColumn* column)</a>
<a name="ln516">	:</a>
<a name="ln517">	WidgetAttributeText(model, column),</a>
<a name="ln518">	fValueDirty(true)</a>
<a name="ln519">{</a>
<a name="ln520">}</a>
<a name="ln521"> </a>
<a name="ln522"> </a>
<a name="ln523">const char*</a>
<a name="ln524">StringAttributeText::ValueAsText(const BPoseView* /*view*/)</a>
<a name="ln525">{</a>
<a name="ln526">	if (fValueDirty)</a>
<a name="ln527">		ReadValue(&amp;fFullValueText);</a>
<a name="ln528"> </a>
<a name="ln529">	return fFullValueText.String();</a>
<a name="ln530">}</a>
<a name="ln531"> </a>
<a name="ln532"> </a>
<a name="ln533">bool</a>
<a name="ln534">StringAttributeText::CheckAttributeChanged()</a>
<a name="ln535">{</a>
<a name="ln536">	BString newString;</a>
<a name="ln537">	ReadValue(&amp;newString);</a>
<a name="ln538"> </a>
<a name="ln539">	if (newString == fFullValueText)</a>
<a name="ln540">		return false;</a>
<a name="ln541"> </a>
<a name="ln542">	fFullValueText = newString;</a>
<a name="ln543">	fDirty = true;		// have to redo fitted string</a>
<a name="ln544">	return true;</a>
<a name="ln545">}</a>
<a name="ln546"> </a>
<a name="ln547"> </a>
<a name="ln548">void</a>
<a name="ln549">StringAttributeText::FitValue(BString* outString, const BPoseView* view)</a>
<a name="ln550">{</a>
<a name="ln551">	if (fValueDirty)</a>
<a name="ln552">		ReadValue(&amp;fFullValueText);</a>
<a name="ln553">	fOldWidth = fColumn-&gt;Width();</a>
<a name="ln554"> </a>
<a name="ln555">	fTruncatedWidth = TruncString(outString, fFullValueText.String(),</a>
<a name="ln556">		fFullValueText.Length(), view, fOldWidth);</a>
<a name="ln557">	fDirty = false;</a>
<a name="ln558">}</a>
<a name="ln559"> </a>
<a name="ln560"> </a>
<a name="ln561">float</a>
<a name="ln562">StringAttributeText::PreferredWidth(const BPoseView* pose) const</a>
<a name="ln563">{</a>
<a name="ln564">	return pose-&gt;StringWidth(fFullValueText.String());</a>
<a name="ln565">}</a>
<a name="ln566"> </a>
<a name="ln567"> </a>
<a name="ln568">int</a>
<a name="ln569">StringAttributeText::Compare(WidgetAttributeText&amp; attr, BPoseView* view)</a>
<a name="ln570">{</a>
<a name="ln571">	StringAttributeText* compareTo = dynamic_cast&lt;StringAttributeText*&gt;(&amp;attr);</a>
<a name="ln572">	ThrowOnAssert(compareTo != NULL);</a>
<a name="ln573"> </a>
<a name="ln574">	if (fValueDirty)</a>
<a name="ln575">		ReadValue(&amp;fFullValueText);</a>
<a name="ln576"> </a>
<a name="ln577">	return NaturalCompare(fFullValueText.String(),</a>
<a name="ln578">		compareTo-&gt;ValueAsText(view));</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581"> </a>
<a name="ln582">bool</a>
<a name="ln583">StringAttributeText::CommitEditedText(BTextView* textView)</a>
<a name="ln584">{</a>
<a name="ln585">	ASSERT(fColumn-&gt;Editable());</a>
<a name="ln586">	const char* text = textView-&gt;Text();</a>
<a name="ln587"> </a>
<a name="ln588">	if (fFullValueText == text) {</a>
<a name="ln589">		// no change</a>
<a name="ln590">		return false;</a>
<a name="ln591">	}</a>
<a name="ln592"> </a>
<a name="ln593">	if (textView-&gt;TextLength() == 0) {</a>
<a name="ln594">		// cannot do an empty name</a>
<a name="ln595">		return false;</a>
<a name="ln596">	}</a>
<a name="ln597"> </a>
<a name="ln598">	// cause re-truncation</a>
<a name="ln599">	fDirty = true;</a>
<a name="ln600"> </a>
<a name="ln601">	if (!CommitEditedTextFlavor(textView))</a>
<a name="ln602">		return false;</a>
<a name="ln603"> </a>
<a name="ln604">	// update text and width in this widget</a>
<a name="ln605">	fFullValueText = text;</a>
<a name="ln606"> </a>
<a name="ln607">	return true;</a>
<a name="ln608">}</a>
<a name="ln609"> </a>
<a name="ln610"> </a>
<a name="ln611">// #pragma mark - ScalarAttributeText</a>
<a name="ln612"> </a>
<a name="ln613"> </a>
<a name="ln614">ScalarAttributeText::ScalarAttributeText(const Model* model,</a>
<a name="ln615">	const BColumn* column)</a>
<a name="ln616">	:</a>
<a name="ln617">	WidgetAttributeText(model, column),</a>
<a name="ln618">	fValue(0),</a>
<a name="ln619">	fValueDirty(true)</a>
<a name="ln620">{</a>
<a name="ln621">}</a>
<a name="ln622"> </a>
<a name="ln623"> </a>
<a name="ln624">int64</a>
<a name="ln625">ScalarAttributeText::Value()</a>
<a name="ln626">{</a>
<a name="ln627">	if (fValueDirty)</a>
<a name="ln628">		fValue = ReadValue();</a>
<a name="ln629"> </a>
<a name="ln630">	return fValue;</a>
<a name="ln631">}</a>
<a name="ln632"> </a>
<a name="ln633"> </a>
<a name="ln634">bool</a>
<a name="ln635">ScalarAttributeText::CheckAttributeChanged()</a>
<a name="ln636">{</a>
<a name="ln637">	int64 newValue = ReadValue();</a>
<a name="ln638">	if (newValue == fValue)</a>
<a name="ln639">		return false;</a>
<a name="ln640"> </a>
<a name="ln641">	fValue = newValue;</a>
<a name="ln642">	fDirty = true;</a>
<a name="ln643">		// have to redo fitted string</a>
<a name="ln644"> </a>
<a name="ln645">	return true;</a>
<a name="ln646">}</a>
<a name="ln647"> </a>
<a name="ln648"> </a>
<a name="ln649">float</a>
<a name="ln650">ScalarAttributeText::PreferredWidth(const BPoseView* pose) const</a>
<a name="ln651">{</a>
<a name="ln652">	BString widthString;</a>
<a name="ln653">	widthString &lt;&lt; fValue;</a>
<a name="ln654">	return pose-&gt;StringWidth(widthString.String());</a>
<a name="ln655">}</a>
<a name="ln656"> </a>
<a name="ln657"> </a>
<a name="ln658">int</a>
<a name="ln659">ScalarAttributeText::Compare(WidgetAttributeText&amp; attr, BPoseView*)</a>
<a name="ln660">{</a>
<a name="ln661">	ScalarAttributeText* compareTo = dynamic_cast&lt;ScalarAttributeText*&gt;(&amp;attr);</a>
<a name="ln662">	ThrowOnAssert(compareTo != NULL);</a>
<a name="ln663"> </a>
<a name="ln664">	if (fValueDirty)</a>
<a name="ln665">		fValue = ReadValue();</a>
<a name="ln666"> </a>
<a name="ln667">	return fValue &gt;= compareTo-&gt;Value()</a>
<a name="ln668">		? (fValue == compareTo-&gt;Value() ? 0 : 1) : -1;</a>
<a name="ln669">}</a>
<a name="ln670"> </a>
<a name="ln671"> </a>
<a name="ln672">// #pragma mark - PathAttributeText</a>
<a name="ln673"> </a>
<a name="ln674"> </a>
<a name="ln675">PathAttributeText::PathAttributeText(const Model* model, const BColumn* column)</a>
<a name="ln676">	:</a>
<a name="ln677">	StringAttributeText(model, column)</a>
<a name="ln678">{</a>
<a name="ln679">}</a>
<a name="ln680"> </a>
<a name="ln681"> </a>
<a name="ln682">void</a>
<a name="ln683">PathAttributeText::ReadValue(BString* outString)</a>
<a name="ln684">{</a>
<a name="ln685">	// get the path</a>
<a name="ln686">	BEntry entry(fModel-&gt;EntryRef());</a>
<a name="ln687">	BPath path;</a>
<a name="ln688"> </a>
<a name="ln689">	if (entry.InitCheck() == B_OK &amp;&amp; entry.GetPath(&amp;path) == B_OK) {</a>
<a name="ln690">		*outString = path.Path();</a>
<a name="ln691">		TruncateLeaf(outString);</a>
<a name="ln692">	} else</a>
<a name="ln693">		*outString = &quot;-&quot;;</a>
<a name="ln694"> </a>
<a name="ln695">	fValueDirty = false;</a>
<a name="ln696">}</a>
<a name="ln697"> </a>
<a name="ln698"> </a>
<a name="ln699">// #pragma mark - OriginalPathAttributeText</a>
<a name="ln700"> </a>
<a name="ln701"> </a>
<a name="ln702">OriginalPathAttributeText::OriginalPathAttributeText(const Model* model,</a>
<a name="ln703">	const BColumn* column)</a>
<a name="ln704">	:</a>
<a name="ln705">	StringAttributeText(model, column)</a>
<a name="ln706">{</a>
<a name="ln707">}</a>
<a name="ln708"> </a>
<a name="ln709"> </a>
<a name="ln710">void</a>
<a name="ln711">OriginalPathAttributeText::ReadValue(BString* outString)</a>
<a name="ln712">{</a>
<a name="ln713">	BEntry entry(fModel-&gt;EntryRef());</a>
<a name="ln714">	BPath path;</a>
<a name="ln715"> </a>
<a name="ln716">	// get the original path</a>
<a name="ln717">	if (entry.InitCheck() == B_OK &amp;&amp; FSGetOriginalPath(&amp;entry, &amp;path) == B_OK)</a>
<a name="ln718">		*outString = path.Path();</a>
<a name="ln719">	else</a>
<a name="ln720">		*outString = &quot;-&quot;;</a>
<a name="ln721"> </a>
<a name="ln722">	fValueDirty = false;</a>
<a name="ln723">}</a>
<a name="ln724"> </a>
<a name="ln725"> </a>
<a name="ln726">// #pragma mark - KindAttributeText</a>
<a name="ln727"> </a>
<a name="ln728"> </a>
<a name="ln729">KindAttributeText::KindAttributeText(const Model* model, const BColumn* column)</a>
<a name="ln730">	:</a>
<a name="ln731">	StringAttributeText(model, column)</a>
<a name="ln732">{</a>
<a name="ln733">}</a>
<a name="ln734"> </a>
<a name="ln735"> </a>
<a name="ln736">void</a>
<a name="ln737">KindAttributeText::ReadValue(BString* outString)</a>
<a name="ln738">{</a>
<a name="ln739">	BMimeType mime;</a>
<a name="ln740">	char desc[B_MIME_TYPE_LENGTH];</a>
<a name="ln741"> </a>
<a name="ln742">	// get the mime type</a>
<a name="ln743">	if (mime.SetType(fModel-&gt;MimeType()) != B_OK)</a>
<a name="ln744">		*outString = B_TRANSLATE(&quot;Unknown&quot;);</a>
<a name="ln745">	else if (mime.GetShortDescription(desc) == B_OK) {</a>
<a name="ln746">		// get the short mime type description</a>
<a name="ln747">		*outString = desc;</a>
<a name="ln748">	} else</a>
<a name="ln749">		*outString = fModel-&gt;MimeType();</a>
<a name="ln750"> </a>
<a name="ln751">	fValueDirty = false;</a>
<a name="ln752">}</a>
<a name="ln753"> </a>
<a name="ln754"> </a>
<a name="ln755">// #pragma mark - NameAttributeText</a>
<a name="ln756"> </a>
<a name="ln757"> </a>
<a name="ln758">NameAttributeText::NameAttributeText(const Model* model,</a>
<a name="ln759">	const BColumn* column)</a>
<a name="ln760">	:</a>
<a name="ln761">	StringAttributeText(model, column)</a>
<a name="ln762">{</a>
<a name="ln763">}</a>
<a name="ln764"> </a>
<a name="ln765"> </a>
<a name="ln766">int</a>
<a name="ln767">NameAttributeText::Compare(WidgetAttributeText&amp; attr, BPoseView* view)</a>
<a name="ln768">{</a>
<a name="ln769">	NameAttributeText* compareTo = dynamic_cast&lt;NameAttributeText*&gt;(&amp;attr);</a>
<a name="ln770">	ThrowOnAssert(compareTo != NULL);</a>
<a name="ln771"> </a>
<a name="ln772">	if (fValueDirty)</a>
<a name="ln773">		ReadValue(&amp;fFullValueText);</a>
<a name="ln774"> </a>
<a name="ln775">	if (NameAttributeText::sSortFolderNamesFirst)</a>
<a name="ln776">		return fModel-&gt;CompareFolderNamesFirst(attr.TargetModel());</a>
<a name="ln777"> </a>
<a name="ln778">	return NaturalCompare(fFullValueText.String(),</a>
<a name="ln779">		compareTo-&gt;ValueAsText(view));</a>
<a name="ln780">}</a>
<a name="ln781"> </a>
<a name="ln782"> </a>
<a name="ln783">void</a>
<a name="ln784">NameAttributeText::ReadValue(BString* outString)</a>
<a name="ln785">{</a>
<a name="ln786">	*outString = fModel-&gt;Name();</a>
<a name="ln787"> </a>
<a name="ln788">	fValueDirty = false;</a>
<a name="ln789">}</a>
<a name="ln790"> </a>
<a name="ln791"> </a>
<a name="ln792">void</a>
<a name="ln793">NameAttributeText::FitValue(BString* outString, const BPoseView* view)</a>
<a name="ln794">{</a>
<a name="ln795">	if (fValueDirty)</a>
<a name="ln796">		ReadValue(&amp;fFullValueText);</a>
<a name="ln797">	fOldWidth = fColumn-&gt;Width();</a>
<a name="ln798">	fTruncatedWidth = TruncString(outString, fFullValueText.String(),</a>
<a name="ln799">		fFullValueText.Length(), view, fOldWidth, B_TRUNCATE_END);</a>
<a name="ln800">	fDirty = false;</a>
<a name="ln801">}</a>
<a name="ln802"> </a>
<a name="ln803"> </a>
<a name="ln804">void</a>
<a name="ln805">NameAttributeText::SetUpEditing(BTextView* textView)</a>
<a name="ln806">{</a>
<a name="ln807">	DisallowFilenameKeys(textView);</a>
<a name="ln808"> </a>
<a name="ln809">	textView-&gt;SetMaxBytes(B_FILE_NAME_LENGTH);</a>
<a name="ln810">	textView-&gt;SetText(fFullValueText.String(), fFullValueText.Length());</a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813"> </a>
<a name="ln814">bool</a>
<a name="ln815">NameAttributeText::CommitEditedTextFlavor(BTextView* textView)</a>
<a name="ln816">{</a>
<a name="ln817">	const char* text = textView-&gt;Text();</a>
<a name="ln818"> </a>
<a name="ln819">	BEntry entry(fModel-&gt;EntryRef());</a>
<a name="ln820">	if (entry.InitCheck() != B_OK)</a>
<a name="ln821">		return false;</a>
<a name="ln822"> </a>
<a name="ln823">	BDirectory	parent;</a>
<a name="ln824">	if (entry.GetParent(&amp;parent) != B_OK)</a>
<a name="ln825">		return false;</a>
<a name="ln826"> </a>
<a name="ln827">	bool removeExisting = false;</a>
<a name="ln828">	if (parent.Contains(text)) {</a>
<a name="ln829">		BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln830">			B_TRANSLATE(&quot;That name is already taken. &quot;</a>
<a name="ln831">			&quot;Please type another one.&quot;),</a>
<a name="ln832">			B_TRANSLATE(&quot;Replace other file&quot;),</a>
<a name="ln833">			B_TRANSLATE(&quot;OK&quot;),</a>
<a name="ln834">			NULL, B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln835">		alert-&gt;SetShortcut(0, 'r');</a>
<a name="ln836">		if (alert-&gt;Go())</a>
<a name="ln837">			return false;</a>
<a name="ln838"> </a>
<a name="ln839">		removeExisting = true;</a>
<a name="ln840">	}</a>
<a name="ln841"> </a>
<a name="ln842">	// TODO:</a>
<a name="ln843">	// use model-flavor specific virtuals for all of these special</a>
<a name="ln844">	// renamings</a>
<a name="ln845">	status_t result;</a>
<a name="ln846">	if (fModel-&gt;IsVolume()) {</a>
<a name="ln847">		BVolume	volume(fModel-&gt;NodeRef()-&gt;device);</a>
<a name="ln848">		result = volume.InitCheck();</a>
<a name="ln849">		if (result == B_OK) {</a>
<a name="ln850">			RenameVolumeUndo undo(volume, text);</a>
<a name="ln851"> </a>
<a name="ln852">			result = volume.SetName(text);</a>
<a name="ln853">			if (result != B_OK)</a>
<a name="ln854">				undo.Remove();</a>
<a name="ln855">		}</a>
<a name="ln856">	} else {</a>
<a name="ln857">		if (fModel-&gt;IsQuery()) {</a>
<a name="ln858">			BModelWriteOpener opener(fModel);</a>
<a name="ln859">			ASSERT(fModel-&gt;Node());</a>
<a name="ln860">			MoreOptionsStruct::SetQueryTemporary(fModel-&gt;Node(), false);</a>
<a name="ln861">		}</a>
<a name="ln862"> </a>
<a name="ln863">		RenameUndo undo(entry, text);</a>
<a name="ln864"> </a>
<a name="ln865">		result = entry.Rename(text, removeExisting);</a>
<a name="ln866">		if (result != B_OK)</a>
<a name="ln867">			undo.Remove();</a>
<a name="ln868">	}</a>
<a name="ln869"> </a>
<a name="ln870">	return result == B_OK;</a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873"> </a>
<a name="ln874">void</a>
<a name="ln875">NameAttributeText::SetSortFolderNamesFirst(bool enabled)</a>
<a name="ln876">{</a>
<a name="ln877">	NameAttributeText::sSortFolderNamesFirst = enabled;</a>
<a name="ln878">}</a>
<a name="ln879"> </a>
<a name="ln880"> </a>
<a name="ln881">bool</a>
<a name="ln882">NameAttributeText::IsEditable() const</a>
<a name="ln883">{</a>
<a name="ln884">	return StringAttributeText::IsEditable()</a>
<a name="ln885">		&amp;&amp; !fModel-&gt;HasLocalizedName();</a>
<a name="ln886">}</a>
<a name="ln887"> </a>
<a name="ln888"> </a>
<a name="ln889">// #pragma mark - RealNameAttributeText</a>
<a name="ln890"> </a>
<a name="ln891"> </a>
<a name="ln892">RealNameAttributeText::RealNameAttributeText(const Model* model,</a>
<a name="ln893">	const BColumn* column)</a>
<a name="ln894">	:</a>
<a name="ln895">	StringAttributeText(model, column)</a>
<a name="ln896">{</a>
<a name="ln897">}</a>
<a name="ln898"> </a>
<a name="ln899"> </a>
<a name="ln900">int</a>
<a name="ln901">RealNameAttributeText::Compare(WidgetAttributeText&amp; attr, BPoseView* view)</a>
<a name="ln902">{</a>
<a name="ln903">	RealNameAttributeText* compareTo</a>
<a name="ln904">		= dynamic_cast&lt;RealNameAttributeText*&gt;(&amp;attr);</a>
<a name="ln905">	ThrowOnAssert(compareTo != NULL);</a>
<a name="ln906"> </a>
<a name="ln907">	if (fValueDirty)</a>
<a name="ln908">		ReadValue(&amp;fFullValueText);</a>
<a name="ln909"> </a>
<a name="ln910">	if (RealNameAttributeText::sSortFolderNamesFirst)</a>
<a name="ln911">		return fModel-&gt;CompareFolderNamesFirst(attr.TargetModel());</a>
<a name="ln912"> </a>
<a name="ln913">	return NaturalCompare(fFullValueText.String(),</a>
<a name="ln914">		compareTo-&gt;ValueAsText(view));</a>
<a name="ln915">}</a>
<a name="ln916"> </a>
<a name="ln917"> </a>
<a name="ln918">void</a>
<a name="ln919">RealNameAttributeText::ReadValue(BString* outString)</a>
<a name="ln920">{</a>
<a name="ln921">	*outString = fModel-&gt;EntryRef()-&gt;name;</a>
<a name="ln922"> </a>
<a name="ln923">	fValueDirty = false;</a>
<a name="ln924">}</a>
<a name="ln925"> </a>
<a name="ln926"> </a>
<a name="ln927">void</a>
<a name="ln928">RealNameAttributeText::FitValue(BString* outString, const BPoseView* view)</a>
<a name="ln929">{</a>
<a name="ln930">	if (fValueDirty)</a>
<a name="ln931">		ReadValue(&amp;fFullValueText);</a>
<a name="ln932">	fOldWidth = fColumn-&gt;Width();</a>
<a name="ln933">	fTruncatedWidth = TruncString(outString, fFullValueText.String(),</a>
<a name="ln934">		fFullValueText.Length(), view, fOldWidth, B_TRUNCATE_END);</a>
<a name="ln935">	fDirty = false;</a>
<a name="ln936">}</a>
<a name="ln937"> </a>
<a name="ln938"> </a>
<a name="ln939">void</a>
<a name="ln940">RealNameAttributeText::SetUpEditing(BTextView* textView)</a>
<a name="ln941">{</a>
<a name="ln942">	DisallowFilenameKeys(textView);</a>
<a name="ln943"> </a>
<a name="ln944">	textView-&gt;SetMaxBytes(B_FILE_NAME_LENGTH);</a>
<a name="ln945">	textView-&gt;SetText(fFullValueText.String(), fFullValueText.Length());</a>
<a name="ln946">}</a>
<a name="ln947"> </a>
<a name="ln948"> </a>
<a name="ln949">bool</a>
<a name="ln950">RealNameAttributeText::CommitEditedTextFlavor(BTextView* textView)</a>
<a name="ln951">{</a>
<a name="ln952">	const char* text = textView-&gt;Text();</a>
<a name="ln953"> </a>
<a name="ln954">	BEntry entry(fModel-&gt;EntryRef());</a>
<a name="ln955">	if (entry.InitCheck() != B_OK)</a>
<a name="ln956">		return false;</a>
<a name="ln957"> </a>
<a name="ln958">	BDirectory	parent;</a>
<a name="ln959">	if (entry.GetParent(&amp;parent) != B_OK)</a>
<a name="ln960">		return false;</a>
<a name="ln961"> </a>
<a name="ln962">	bool removeExisting = false;</a>
<a name="ln963">	if (parent.Contains(text)) {</a>
<a name="ln964">		BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln965">			B_TRANSLATE(&quot;That name is already taken. &quot;</a>
<a name="ln966">			&quot;Please type another one.&quot;),</a>
<a name="ln967">			B_TRANSLATE(&quot;Replace other file&quot;),</a>
<a name="ln968">			B_TRANSLATE(&quot;OK&quot;),</a>
<a name="ln969">			NULL, B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln970"> </a>
<a name="ln971">		alert-&gt;SetShortcut(0, 'r');</a>
<a name="ln972"> </a>
<a name="ln973">		if (alert-&gt;Go())</a>
<a name="ln974">			return false;</a>
<a name="ln975"> </a>
<a name="ln976">		removeExisting = true;</a>
<a name="ln977">	}</a>
<a name="ln978"> </a>
<a name="ln979">	// TODO:</a>
<a name="ln980">	// use model-flavor specific virtuals for all of these special</a>
<a name="ln981">	// renamings</a>
<a name="ln982">	status_t result;</a>
<a name="ln983">	if (fModel-&gt;IsVolume()) {</a>
<a name="ln984">		BVolume volume(fModel-&gt;NodeRef()-&gt;device);</a>
<a name="ln985">		result = volume.InitCheck();</a>
<a name="ln986">		if (result == B_OK) {</a>
<a name="ln987">			RenameVolumeUndo undo(volume, text);</a>
<a name="ln988"> </a>
<a name="ln989">			result = volume.SetName(text);</a>
<a name="ln990">			if (result != B_OK)</a>
<a name="ln991">				undo.Remove();</a>
<a name="ln992">		}</a>
<a name="ln993">	} else {</a>
<a name="ln994">		if (fModel-&gt;IsQuery()) {</a>
<a name="ln995">			BModelWriteOpener opener(fModel);</a>
<a name="ln996">			ASSERT(fModel-&gt;Node());</a>
<a name="ln997">			MoreOptionsStruct::SetQueryTemporary(fModel-&gt;Node(), false);</a>
<a name="ln998">		}</a>
<a name="ln999"> </a>
<a name="ln1000">		RenameUndo undo(entry, text);</a>
<a name="ln1001"> </a>
<a name="ln1002">		result = entry.Rename(text, removeExisting);</a>
<a name="ln1003">		if (result != B_OK)</a>
<a name="ln1004">			undo.Remove();</a>
<a name="ln1005">	}</a>
<a name="ln1006"> </a>
<a name="ln1007">	return result == B_OK;</a>
<a name="ln1008">}</a>
<a name="ln1009"> </a>
<a name="ln1010"> </a>
<a name="ln1011">void</a>
<a name="ln1012">RealNameAttributeText::SetSortFolderNamesFirst(bool enabled)</a>
<a name="ln1013">{</a>
<a name="ln1014">	RealNameAttributeText::sSortFolderNamesFirst = enabled;</a>
<a name="ln1015">}</a>
<a name="ln1016"> </a>
<a name="ln1017"> </a>
<a name="ln1018">// #pragma mark - owner/group</a>
<a name="ln1019"> </a>
<a name="ln1020"> </a>
<a name="ln1021">#ifdef OWNER_GROUP_ATTRIBUTES</a>
<a name="ln1022">OwnerAttributeText::OwnerAttributeText(const Model* model,</a>
<a name="ln1023">	const BColumn* column)</a>
<a name="ln1024">	:</a>
<a name="ln1025">	StringAttributeText(model, column)</a>
<a name="ln1026">{</a>
<a name="ln1027">}</a>
<a name="ln1028"> </a>
<a name="ln1029"> </a>
<a name="ln1030">void</a>
<a name="ln1031">OwnerAttributeText::ReadValue(BString* outString)</a>
<a name="ln1032">{</a>
<a name="ln1033">	uid_t nodeOwner = fModel-&gt;StatBuf()-&gt;st_uid;</a>
<a name="ln1034">	BString user;</a>
<a name="ln1035"> </a>
<a name="ln1036">	if (nodeOwner == 0) {</a>
<a name="ln1037">		if (getenv(&quot;USER&quot;) != NULL)</a>
<a name="ln1038">			user &lt;&lt; getenv(&quot;USER&quot;);</a>
<a name="ln1039">		else</a>
<a name="ln1040">			user &lt;&lt; &quot;root&quot;;</a>
<a name="ln1041">	} else</a>
<a name="ln1042">		user &lt;&lt; nodeOwner;</a>
<a name="ln1043">	*outString = user.String();</a>
<a name="ln1044"> </a>
<a name="ln1045">	fValueDirty = false;</a>
<a name="ln1046">}</a>
<a name="ln1047"> </a>
<a name="ln1048"> </a>
<a name="ln1049">GroupAttributeText::GroupAttributeText(const Model* model,</a>
<a name="ln1050">	const BColumn* column)</a>
<a name="ln1051">	:</a>
<a name="ln1052">	StringAttributeText(model, column)</a>
<a name="ln1053">{</a>
<a name="ln1054">}</a>
<a name="ln1055"> </a>
<a name="ln1056"> </a>
<a name="ln1057">void</a>
<a name="ln1058">GroupAttributeText::ReadValue(BString* outString)</a>
<a name="ln1059">{</a>
<a name="ln1060">	gid_t nodeGroup = fModel-&gt;StatBuf()-&gt;st_gid;</a>
<a name="ln1061">	BString group;</a>
<a name="ln1062"> </a>
<a name="ln1063">	if (nodeGroup == 0) {</a>
<a name="ln1064">		if (getenv(&quot;GROUP&quot;) != NULL)</a>
<a name="ln1065">			group &lt;&lt; getenv(&quot;GROUP&quot;);</a>
<a name="ln1066">		else</a>
<a name="ln1067">			group &lt;&lt; &quot;0&quot;;</a>
<a name="ln1068">	} else</a>
<a name="ln1069">		group &lt;&lt; nodeGroup;</a>
<a name="ln1070">	*outString = group.String();</a>
<a name="ln1071"> </a>
<a name="ln1072">	fValueDirty = false;</a>
<a name="ln1073">}</a>
<a name="ln1074">#endif  // OWNER_GROUP_ATTRIBUTES</a>
<a name="ln1075"> </a>
<a name="ln1076"> </a>
<a name="ln1077">//	#pragma mark - ModeAttributeText</a>
<a name="ln1078"> </a>
<a name="ln1079"> </a>
<a name="ln1080">ModeAttributeText::ModeAttributeText(const Model* model,</a>
<a name="ln1081">	const BColumn* column)</a>
<a name="ln1082">	:</a>
<a name="ln1083">	StringAttributeText(model, column)</a>
<a name="ln1084">{</a>
<a name="ln1085">}</a>
<a name="ln1086"> </a>
<a name="ln1087"> </a>
<a name="ln1088">void</a>
<a name="ln1089">ModeAttributeText::ReadValue(BString* outString)</a>
<a name="ln1090">{</a>
<a name="ln1091">	mode_t mode = fModel-&gt;StatBuf()-&gt;st_mode;</a>
<a name="ln1092">	mode_t baseMask = 00400;</a>
<a name="ln1093">	char buffer[11];</a>
<a name="ln1094"> </a>
<a name="ln1095">	char* scanner = buffer;</a>
<a name="ln1096"> </a>
<a name="ln1097">	if (S_ISDIR(mode))</a>
<a name="ln1098">		*scanner++ = 'd';</a>
<a name="ln1099">	else if (S_ISLNK(mode))</a>
<a name="ln1100">		*scanner++ = 'l';</a>
<a name="ln1101">	else if (S_ISBLK(mode))</a>
<a name="ln1102">		*scanner++ = 'b';</a>
<a name="ln1103">	else if (S_ISCHR(mode))</a>
<a name="ln1104">		*scanner++ = 'c';</a>
<a name="ln1105">	else</a>
<a name="ln1106">		*scanner++ = '-';</a>
<a name="ln1107"> </a>
<a name="ln1108">	for (int32 index = 0; index &lt; 9; index++) {</a>
<a name="ln1109">		*scanner++ = (mode &amp; baseMask) ? &quot;rwx&quot;[index % 3] : '-';</a>
<a name="ln1110">		baseMask &gt;&gt;= 1;</a>
<a name="ln1111">	}</a>
<a name="ln1112"> </a>
<a name="ln1113">	*scanner = 0;</a>
<a name="ln1114">	*outString = buffer;</a>
<a name="ln1115"> </a>
<a name="ln1116">	fValueDirty = false;</a>
<a name="ln1117">}</a>
<a name="ln1118"> </a>
<a name="ln1119"> </a>
<a name="ln1120">//	#pragma mark - SizeAttributeText</a>
<a name="ln1121"> </a>
<a name="ln1122"> </a>
<a name="ln1123">SizeAttributeText::SizeAttributeText(const Model* model,</a>
<a name="ln1124">	const BColumn* column)</a>
<a name="ln1125">	:</a>
<a name="ln1126">	ScalarAttributeText(model, column)</a>
<a name="ln1127">{</a>
<a name="ln1128">}</a>
<a name="ln1129"> </a>
<a name="ln1130"> </a>
<a name="ln1131">int64</a>
<a name="ln1132">SizeAttributeText::ReadValue()</a>
<a name="ln1133">{</a>
<a name="ln1134">	fValueDirty = false;</a>
<a name="ln1135">	// get the size</a>
<a name="ln1136"> </a>
<a name="ln1137">	if (fModel-&gt;IsVolume()) {</a>
<a name="ln1138">		BVolume volume(fModel-&gt;NodeRef()-&gt;device);</a>
<a name="ln1139"> </a>
<a name="ln1140">		return volume.Capacity();</a>
<a name="ln1141">	}</a>
<a name="ln1142"> </a>
<a name="ln1143">	if (fModel-&gt;IsDirectory() || fModel-&gt;IsQuery()</a>
<a name="ln1144">		|| fModel-&gt;IsQueryTemplate() || fModel-&gt;IsSymLink()</a>
<a name="ln1145">		|| fModel-&gt;IsVirtualDirectory()) {</a>
<a name="ln1146">		return kUnknownSize;</a>
<a name="ln1147">	}</a>
<a name="ln1148"> </a>
<a name="ln1149">	fValueIsDefined = true;</a>
<a name="ln1150"> </a>
<a name="ln1151">	return fModel-&gt;StatBuf()-&gt;st_size;</a>
<a name="ln1152">}</a>
<a name="ln1153"> </a>
<a name="ln1154"> </a>
<a name="ln1155">void</a>
<a name="ln1156">SizeAttributeText::FitValue(BString* outString, const BPoseView* view)</a>
<a name="ln1157">{</a>
<a name="ln1158">	if (fValueDirty)</a>
<a name="ln1159">		fValue = ReadValue();</a>
<a name="ln1160"> </a>
<a name="ln1161">	fOldWidth = fColumn-&gt;Width();</a>
<a name="ln1162">	fTruncatedWidth = TruncFileSize(outString, fValue, view, fOldWidth);</a>
<a name="ln1163">	fDirty = false;</a>
<a name="ln1164">}</a>
<a name="ln1165"> </a>
<a name="ln1166"> </a>
<a name="ln1167">float</a>
<a name="ln1168">SizeAttributeText::PreferredWidth(const BPoseView* pose) const</a>
<a name="ln1169">{</a>
<a name="ln1170">	if (fValueIsDefined) {</a>
<a name="ln1171">		BString widthString;</a>
<a name="ln1172">		TruncFileSize(&amp;widthString, fValue, pose, 100000);</a>
<a name="ln1173">		return pose-&gt;StringWidth(widthString.String());</a>
<a name="ln1174">	}</a>
<a name="ln1175"> </a>
<a name="ln1176">	return pose-&gt;StringWidth(&quot;-&quot;);</a>
<a name="ln1177">}</a>
<a name="ln1178"> </a>
<a name="ln1179"> </a>
<a name="ln1180">// #pragma mark - TimeAttributeText</a>
<a name="ln1181"> </a>
<a name="ln1182"> </a>
<a name="ln1183">TimeAttributeText::TimeAttributeText(const Model* model,</a>
<a name="ln1184">	const BColumn* column)</a>
<a name="ln1185">	:</a>
<a name="ln1186">	ScalarAttributeText(model, column),</a>
<a name="ln1187">	fLastClockIs24(false),</a>
<a name="ln1188">	fLastDateOrder(kDateFormatEnd),</a>
<a name="ln1189">	fLastTimeFormatSeparator(kSeparatorsEnd)</a>
<a name="ln1190">{</a>
<a name="ln1191">}</a>
<a name="ln1192"> </a>
<a name="ln1193"> </a>
<a name="ln1194">float</a>
<a name="ln1195">TimeAttributeText::PreferredWidth(const BPoseView* pose) const</a>
<a name="ln1196">{</a>
<a name="ln1197">	BString widthString;</a>
<a name="ln1198">	TruncTimeBase(&amp;widthString, fValue, pose, 100000);</a>
<a name="ln1199">	return pose-&gt;StringWidth(widthString.String());</a>
<a name="ln1200">}</a>
<a name="ln1201"> </a>
<a name="ln1202"> </a>
<a name="ln1203">void</a>
<a name="ln1204">TimeAttributeText::FitValue(BString* outString, const BPoseView* view)</a>
<a name="ln1205">{</a>
<a name="ln1206">	if (fValueDirty)</a>
<a name="ln1207">		fValue = ReadValue();</a>
<a name="ln1208"> </a>
<a name="ln1209">	fOldWidth = fColumn-&gt;Width();</a>
<a name="ln1210">	fTruncatedWidth = TruncTime(outString, fValue, view, fOldWidth);</a>
<a name="ln1211">	fDirty = false;</a>
<a name="ln1212">}</a>
<a name="ln1213"> </a>
<a name="ln1214"> </a>
<a name="ln1215">bool</a>
<a name="ln1216">TimeAttributeText::CheckSettingsChanged(void)</a>
<a name="ln1217">{</a>
<a name="ln1218">	// TODO : check against the actual locale settings</a>
<a name="ln1219">	return false;</a>
<a name="ln1220">}</a>
<a name="ln1221"> </a>
<a name="ln1222"> </a>
<a name="ln1223">//	#pragma mark - CreationTimeAttributeText</a>
<a name="ln1224"> </a>
<a name="ln1225"> </a>
<a name="ln1226">CreationTimeAttributeText::CreationTimeAttributeText(const Model* model,</a>
<a name="ln1227">	const BColumn* column)</a>
<a name="ln1228">	:</a>
<a name="ln1229">	TimeAttributeText(model, column)</a>
<a name="ln1230">{</a>
<a name="ln1231">}</a>
<a name="ln1232"> </a>
<a name="ln1233"> </a>
<a name="ln1234">int64</a>
<a name="ln1235">CreationTimeAttributeText::ReadValue()</a>
<a name="ln1236">{</a>
<a name="ln1237">	fValueDirty = false;</a>
<a name="ln1238">	fValueIsDefined = true;</a>
<a name="ln1239">	return fModel-&gt;StatBuf()-&gt;st_crtime;</a>
<a name="ln1240">}</a>
<a name="ln1241"> </a>
<a name="ln1242"> </a>
<a name="ln1243">//	#pragma mark - ModificationTimeAttributeText</a>
<a name="ln1244"> </a>
<a name="ln1245"> </a>
<a name="ln1246">ModificationTimeAttributeText::ModificationTimeAttributeText(</a>
<a name="ln1247">	const Model* model, const BColumn* column)</a>
<a name="ln1248">	:</a>
<a name="ln1249">	TimeAttributeText(model, column)</a>
<a name="ln1250">{</a>
<a name="ln1251">}</a>
<a name="ln1252"> </a>
<a name="ln1253"> </a>
<a name="ln1254">int64</a>
<a name="ln1255">ModificationTimeAttributeText::ReadValue()</a>
<a name="ln1256">{</a>
<a name="ln1257">	fValueDirty = false;</a>
<a name="ln1258">	fValueIsDefined = true;</a>
<a name="ln1259">	return fModel-&gt;StatBuf()-&gt;st_mtime;</a>
<a name="ln1260">}</a>
<a name="ln1261"> </a>
<a name="ln1262"> </a>
<a name="ln1263">//	#pragma mark - GenericAttributeText</a>
<a name="ln1264"> </a>
<a name="ln1265"> </a>
<a name="ln1266">GenericAttributeText::GenericAttributeText(const Model* model,</a>
<a name="ln1267">	const BColumn* column)</a>
<a name="ln1268">	:</a>
<a name="ln1269">	StringAttributeText(model, column)</a>
<a name="ln1270">{</a>
<a name="ln1271">}</a>
<a name="ln1272"> </a>
<a name="ln1273"> </a>
<a name="ln1274">bool</a>
<a name="ln1275">GenericAttributeText::CheckAttributeChanged()</a>
<a name="ln1276">{</a>
<a name="ln1277">	GenericValueStruct tmpValue = fValue;</a>
<a name="ln1278">	BString tmpString(fFullValueText);</a>
<a name="ln1279">	ReadValue(&amp;fFullValueText);</a>
<a name="ln1280"> </a>
<a name="ln1281">	// fDirty could already be true, in that case we mustn't set it to</a>
<a name="ln1282">	// false, even if the attribute text hasn't changed</a>
<a name="ln1283">	bool changed = fValue.int64t != tmpValue.int64t</a>
<a name="ln1284">		|| tmpString != fFullValueText;</a>
<a name="ln1285">	if (changed)</a>
<a name="ln1286">		fDirty = true;</a>
<a name="ln1287"> </a>
<a name="ln1288">	return fDirty;</a>
<a name="ln1289">}</a>
<a name="ln1290"> </a>
<a name="ln1291"> </a>
<a name="ln1292">float</a>
<a name="ln1293">GenericAttributeText::PreferredWidth(const BPoseView* pose) const</a>
<a name="ln1294">{</a>
<a name="ln1295">	return pose-&gt;StringWidth(fFullValueText.String());</a>
<a name="ln1296">}</a>
<a name="ln1297"> </a>
<a name="ln1298"> </a>
<a name="ln1299">void</a>
<a name="ln1300">GenericAttributeText::ReadValue(BString* outString)</a>
<a name="ln1301">{</a>
<a name="ln1302">	BModelOpener opener(const_cast&lt;Model*&gt;(fModel));</a>
<a name="ln1303"> </a>
<a name="ln1304">	ssize_t length = 0;</a>
<a name="ln1305">	fFullValueText = &quot;-&quot;;</a>
<a name="ln1306">	fValue.int64t = 0;</a>
<a name="ln1307">	fValueIsDefined = false;</a>
<a name="ln1308">	fValueDirty = false;</a>
<a name="ln1309"> </a>
<a name="ln1310">	if (!fModel-&gt;Node())</a>
<a name="ln1311">		return;</a>
<a name="ln1312"> </a>
<a name="ln1313">	switch (fColumn-&gt;AttrType()) {</a>
<a name="ln1314">		case B_STRING_TYPE:</a>
<a name="ln1315">		{</a>
<a name="ln1316">			char buffer[kGenericReadBufferSize];</a>
<a name="ln1317">			length = fModel-&gt;Node()-&gt;ReadAttr(fColumn-&gt;AttrName(),</a>
<a name="ln1318">				fColumn-&gt;AttrType(), 0, buffer, kGenericReadBufferSize - 1);</a>
<a name="ln1319"> </a>
<a name="ln1320">			if (length &gt; 0) {</a>
<a name="ln1321">				buffer[length] = '\0';</a>
<a name="ln1322">				// make sure the buffer is null-terminated even if we</a>
<a name="ln1323">				// didn't read the whole attribute in or it wasn't to</a>
<a name="ln1324">				// begin with</a>
<a name="ln1325"> </a>
<a name="ln1326">				*outString = buffer;</a>
<a name="ln1327">				fValueIsDefined = true;</a>
<a name="ln1328">			}</a>
<a name="ln1329">			break;</a>
<a name="ln1330">		}</a>
<a name="ln1331"> </a>
<a name="ln1332">		case B_SSIZE_T_TYPE:</a>
<a name="ln1333">		case B_TIME_TYPE:</a>
<a name="ln1334">		case B_OFF_T_TYPE:</a>
<a name="ln1335">		case B_FLOAT_TYPE:</a>
<a name="ln1336">		case B_BOOL_TYPE:</a>
<a name="ln1337">		case B_CHAR_TYPE:</a>
<a name="ln1338">		case B_INT8_TYPE:</a>
<a name="ln1339">		case B_INT16_TYPE:</a>
<a name="ln1340">		case B_INT32_TYPE:</a>
<a name="ln1341">		case B_INT64_TYPE:</a>
<a name="ln1342">		case B_UINT8_TYPE:</a>
<a name="ln1343">		case B_UINT16_TYPE:</a>
<a name="ln1344">		case B_UINT32_TYPE:</a>
<a name="ln1345">		case B_UINT64_TYPE:</a>
<a name="ln1346">		case B_DOUBLE_TYPE:</a>
<a name="ln1347">		{</a>
<a name="ln1348">			// read in the numerical bit representation and attach it</a>
<a name="ln1349">			// with a type, depending on the bytes that could be read</a>
<a name="ln1350">			attr_info info;</a>
<a name="ln1351">			GenericValueStruct tmp;</a>
<a name="ln1352">			if (fModel-&gt;Node()-&gt;GetAttrInfo(fColumn-&gt;AttrName(), &amp;info)</a>
<a name="ln1353">					== B_OK) {</a>
<a name="ln1354">				if (info.size &amp;&amp; info.size &lt;= (off_t)sizeof(int64)) {</a>
<a name="ln1355">					length = fModel-&gt;Node()-&gt;ReadAttr(fColumn-&gt;AttrName(),</a>
<a name="ln1356">						fColumn-&gt;AttrType(), 0, &amp;tmp, (size_t)info.size);</a>
<a name="ln1357">				}</a>
<a name="ln1358"> </a>
<a name="ln1359">				// We used tmp as a block of memory, now set the</a>
<a name="ln1360">				// correct fValue:</a>
<a name="ln1361"> </a>
<a name="ln1362">				if (length == info.size) {</a>
<a name="ln1363">					if (fColumn-&gt;AttrType() == B_FLOAT_TYPE</a>
<a name="ln1364">						|| fColumn-&gt;AttrType() == B_DOUBLE_TYPE) {</a>
<a name="ln1365">						// filter out special float/double types</a>
<a name="ln1366">						switch (info.size) {</a>
<a name="ln1367">							case sizeof(float):</a>
<a name="ln1368">								fValueIsDefined = true;</a>
<a name="ln1369">								fValue.floatt = tmp.floatt;</a>
<a name="ln1370">								break;</a>
<a name="ln1371"> </a>
<a name="ln1372">							case sizeof(double):</a>
<a name="ln1373">								fValueIsDefined = true;</a>
<a name="ln1374">								fValue.doublet = tmp.doublet;</a>
<a name="ln1375">								break;</a>
<a name="ln1376"> </a>
<a name="ln1377">							default:</a>
<a name="ln1378">								TRESPASS();</a>
<a name="ln1379">								break;</a>
<a name="ln1380">						}</a>
<a name="ln1381">					} else {</a>
<a name="ln1382">						// handle the standard data types</a>
<a name="ln1383">						switch (info.size) {</a>
<a name="ln1384">							case sizeof(char):</a>
<a name="ln1385">								// Takes care of bool too.</a>
<a name="ln1386">								fValueIsDefined = true;</a>
<a name="ln1387">								fValue.int8t = tmp.int8t;</a>
<a name="ln1388">								break;</a>
<a name="ln1389"> </a>
<a name="ln1390">							case sizeof(int16):</a>
<a name="ln1391">								fValueIsDefined = true;</a>
<a name="ln1392">								fValue.int16t = tmp.int16t;</a>
<a name="ln1393">								break;</a>
<a name="ln1394"> </a>
<a name="ln1395">							case sizeof(int32):</a>
<a name="ln1396">								// Takes care of time_t too.</a>
<a name="ln1397">								fValueIsDefined = true;</a>
<a name="ln1398">								fValue.int32t = tmp.int32t;</a>
<a name="ln1399">								break;</a>
<a name="ln1400"> </a>
<a name="ln1401">							case sizeof(int64):</a>
<a name="ln1402">								// Takes care of off_t too.</a>
<a name="ln1403">								fValueIsDefined = true;</a>
<a name="ln1404">								fValue.int64t = tmp.int64t;</a>
<a name="ln1405">								break;</a>
<a name="ln1406"> </a>
<a name="ln1407">							default:</a>
<a name="ln1408">								TRESPASS();</a>
<a name="ln1409">								break;</a>
<a name="ln1410">						}</a>
<a name="ln1411">					}</a>
<a name="ln1412">				}</a>
<a name="ln1413">			}</a>
<a name="ln1414">			break;</a>
<a name="ln1415">		}</a>
<a name="ln1416">	}</a>
<a name="ln1417">}</a>
<a name="ln1418"> </a>
<a name="ln1419"> </a>
<a name="ln1420">void</a>
<a name="ln1421">GenericAttributeText::FitValue(BString* outString, const BPoseView* view)</a>
<a name="ln1422">{</a>
<a name="ln1423">	if (fValueDirty)</a>
<a name="ln1424">		ReadValue(&amp;fFullValueText);</a>
<a name="ln1425"> </a>
<a name="ln1426">	fOldWidth = fColumn-&gt;Width();</a>
<a name="ln1427"> </a>
<a name="ln1428">	if (!fValueIsDefined) {</a>
<a name="ln1429">		*outString = &quot;-&quot;;</a>
<a name="ln1430">		fTruncatedWidth = TruncString(outString, fFullValueText.String(),</a>
<a name="ln1431">			fFullValueText.Length(), view, fOldWidth);</a>
<a name="ln1432">		fDirty = false;</a>
<a name="ln1433">		return;</a>
<a name="ln1434">	}</a>
<a name="ln1435"> </a>
<a name="ln1436">	char buffer[256];</a>
<a name="ln1437"> </a>
<a name="ln1438">	switch (fColumn-&gt;AttrType()) {</a>
<a name="ln1439">		case B_SIZE_T_TYPE:</a>
<a name="ln1440">			TruncFileSizeBase(outString, fValue.int32t, view, fOldWidth);</a>
<a name="ln1441">			return;</a>
<a name="ln1442"> </a>
<a name="ln1443">		case B_SSIZE_T_TYPE:</a>
<a name="ln1444">			if (fValue.int32t &gt; 0) {</a>
<a name="ln1445">				TruncFileSizeBase(outString, fValue.int32t, view, fOldWidth);</a>
<a name="ln1446">				return;</a>
<a name="ln1447">			}</a>
<a name="ln1448">			sprintf(buffer, &quot;%s&quot;, strerror(fValue.int32t));</a>
<a name="ln1449">			fFullValueText = buffer;</a>
<a name="ln1450">			break;</a>
<a name="ln1451"> </a>
<a name="ln1452">		case B_STRING_TYPE:</a>
<a name="ln1453">			fTruncatedWidth = TruncString(outString, fFullValueText.String(),</a>
<a name="ln1454">				fFullValueText.Length(), view, fOldWidth);</a>
<a name="ln1455">			fDirty = false;</a>
<a name="ln1456">			return;</a>
<a name="ln1457"> </a>
<a name="ln1458">		case B_OFF_T_TYPE:</a>
<a name="ln1459">			// As a side effect update the fFullValueText to the string</a>
<a name="ln1460">			// representation of value</a>
<a name="ln1461">			TruncFileSize(&amp;fFullValueText, fValue.off_tt, view, 100000);</a>
<a name="ln1462">			fTruncatedWidth = TruncFileSize(outString, fValue.off_tt, view,</a>
<a name="ln1463">				fOldWidth);</a>
<a name="ln1464">			fDirty = false;</a>
<a name="ln1465">			return;</a>
<a name="ln1466"> </a>
<a name="ln1467">		case B_TIME_TYPE:</a>
<a name="ln1468">			// As a side effect update the fFullValueText to the string</a>
<a name="ln1469">			// representation of value</a>
<a name="ln1470">			TruncTime(&amp;fFullValueText, fValue.time_tt, view, 100000);</a>
<a name="ln1471">			fTruncatedWidth = TruncTime(outString, fValue.time_tt, view,</a>
<a name="ln1472">				fOldWidth);</a>
<a name="ln1473">			fDirty = false;</a>
<a name="ln1474">			return;</a>
<a name="ln1475"> </a>
<a name="ln1476">		case B_BOOL_TYPE:</a>
<a name="ln1477">			// For now use true/false, would be nice to be able to set</a>
<a name="ln1478">			// the value text</a>
<a name="ln1479"> </a>
<a name="ln1480"> 			sprintf(buffer, &quot;%s&quot;, fValue.boolt ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln1481">			fFullValueText = buffer;</a>
<a name="ln1482">			break;</a>
<a name="ln1483"> </a>
<a name="ln1484">		case B_CHAR_TYPE:</a>
<a name="ln1485">			// Make sure no non-printable characters are displayed:</a>
<a name="ln1486">			if (!isprint(fValue.uint8t)) {</a>
<a name="ln1487">				*outString = &quot;-&quot;;</a>
<a name="ln1488">				fTruncatedWidth = TruncString(outString, fFullValueText.String(),</a>
<a name="ln1489">					fFullValueText.Length(), view, fOldWidth);</a>
<a name="ln1490">				fDirty = false;</a>
<a name="ln1491">				return;</a>
<a name="ln1492">			}</a>
<a name="ln1493"> </a>
<a name="ln1494">			sprintf(buffer, &quot;%c&quot;, fValue.uint8t);</a>
<a name="ln1495">			fFullValueText = buffer;</a>
<a name="ln1496">			break;</a>
<a name="ln1497"> </a>
<a name="ln1498">		case B_INT8_TYPE:</a>
<a name="ln1499">			sprintf(buffer, &quot;%d&quot;, fValue.int8t);</a>
<a name="ln1500">			fFullValueText = buffer;</a>
<a name="ln1501">			break;</a>
<a name="ln1502"> </a>
<a name="ln1503">		case B_UINT8_TYPE:</a>
<a name="ln1504">			sprintf(buffer, &quot;%d&quot;, fValue.uint8t);</a>
<a name="ln1505">			fFullValueText = buffer;</a>
<a name="ln1506">			break;</a>
<a name="ln1507"> </a>
<a name="ln1508">		case B_INT16_TYPE:</a>
<a name="ln1509">			sprintf(buffer, &quot;%d&quot;, fValue.int16t);</a>
<a name="ln1510">			fFullValueText = buffer;</a>
<a name="ln1511">			break;</a>
<a name="ln1512"> </a>
<a name="ln1513">		case B_UINT16_TYPE:</a>
<a name="ln1514">			sprintf(buffer, &quot;%d&quot;, fValue.uint16t);</a>
<a name="ln1515">			fFullValueText = buffer;</a>
<a name="ln1516">			break;</a>
<a name="ln1517"> </a>
<a name="ln1518">		case B_INT32_TYPE:</a>
<a name="ln1519">			sprintf(buffer, &quot;%&quot; B_PRId32, fValue.int32t);</a>
<a name="ln1520">			fFullValueText = buffer;</a>
<a name="ln1521">			break;</a>
<a name="ln1522"> </a>
<a name="ln1523">		case B_UINT32_TYPE:</a>
<a name="ln1524">			sprintf(buffer, &quot;%&quot; B_PRId32, fValue.uint32t);</a>
<a name="ln1525">			fFullValueText = buffer;</a>
<a name="ln1526">			break;</a>
<a name="ln1527"> </a>
<a name="ln1528">		case B_INT64_TYPE:</a>
<a name="ln1529">			sprintf(buffer, &quot;%&quot; B_PRId64, fValue.int64t);</a>
<a name="ln1530">			fFullValueText = buffer;</a>
<a name="ln1531">			break;</a>
<a name="ln1532"> </a>
<a name="ln1533">		case B_UINT64_TYPE:</a>
<a name="ln1534">			sprintf(buffer, &quot;%&quot; B_PRId64, fValue.uint64t);</a>
<a name="ln1535">			fFullValueText = buffer;</a>
<a name="ln1536">			break;</a>
<a name="ln1537"> </a>
<a name="ln1538">		case B_FLOAT_TYPE:</a>
<a name="ln1539">			snprintf(buffer, sizeof(buffer), &quot;%g&quot;, fValue.floatt);</a>
<a name="ln1540">			fFullValueText = buffer;</a>
<a name="ln1541">			break;</a>
<a name="ln1542"> </a>
<a name="ln1543">		case B_DOUBLE_TYPE:</a>
<a name="ln1544">			snprintf(buffer, sizeof(buffer), &quot;%g&quot;, fValue.doublet);</a>
<a name="ln1545">			fFullValueText = buffer;</a>
<a name="ln1546">			break;</a>
<a name="ln1547"> </a>
<a name="ln1548">		default:</a>
<a name="ln1549">			*outString = &quot;-&quot;;</a>
<a name="ln1550">			fTruncatedWidth = TruncString(outString, fFullValueText.String(),</a>
<a name="ln1551">				fFullValueText.Length(), view, fOldWidth);</a>
<a name="ln1552">			fDirty = false;</a>
<a name="ln1553">			return;</a>
<a name="ln1554">	}</a>
<a name="ln1555">	fTruncatedWidth = TruncString(outString, buffer, (ssize_t)strlen(buffer),</a>
<a name="ln1556">		view, fOldWidth);</a>
<a name="ln1557">	fDirty = false;</a>
<a name="ln1558">}</a>
<a name="ln1559"> </a>
<a name="ln1560"> </a>
<a name="ln1561">const char*</a>
<a name="ln1562">GenericAttributeText::ValueAsText(const BPoseView* view)</a>
<a name="ln1563">{</a>
<a name="ln1564">	// TODO: redesign this - this is to make sure the value is valid</a>
<a name="ln1565">	bool oldDirty = fDirty;</a>
<a name="ln1566">	BString outString;</a>
<a name="ln1567">	FitValue(&amp;outString, view);</a>
<a name="ln1568">	fDirty = oldDirty;</a>
<a name="ln1569"> </a>
<a name="ln1570">	return fFullValueText.String();</a>
<a name="ln1571">}</a>
<a name="ln1572"> </a>
<a name="ln1573"> </a>
<a name="ln1574">int</a>
<a name="ln1575">GenericAttributeText::Compare(WidgetAttributeText&amp; attr, BPoseView*)</a>
<a name="ln1576">{</a>
<a name="ln1577">	GenericAttributeText* compareTo</a>
<a name="ln1578">		= dynamic_cast&lt;GenericAttributeText*&gt;(&amp;attr);</a>
<a name="ln1579">	ThrowOnAssert(compareTo != NULL);</a>
<a name="ln1580"> </a>
<a name="ln1581">	if (fValueDirty)</a>
<a name="ln1582">		ReadValue(&amp;fFullValueText);</a>
<a name="ln1583"> </a>
<a name="ln1584">	if (compareTo-&gt;fValueDirty)</a>
<a name="ln1585">		compareTo-&gt;ReadValue(&amp;compareTo-&gt;fFullValueText);</a>
<a name="ln1586"> </a>
<a name="ln1587">	// sort undefined values last, regardless of the other value</a>
<a name="ln1588">	if (!fValueIsDefined)</a>
<a name="ln1589">		return compareTo-&gt;fValueIsDefined ? 1 : 0;</a>
<a name="ln1590"> </a>
<a name="ln1591">	if (!compareTo-&gt;fValueIsDefined)</a>
<a name="ln1592">		return -1;</a>
<a name="ln1593"> </a>
<a name="ln1594">	switch (fColumn-&gt;AttrType()) {</a>
<a name="ln1595">		case B_STRING_TYPE:</a>
<a name="ln1596">			return fFullValueText.ICompare(compareTo-&gt;fFullValueText);</a>
<a name="ln1597"> </a>
<a name="ln1598">		case B_CHAR_TYPE:</a>
<a name="ln1599">		{</a>
<a name="ln1600">			char vStr[2] = { static_cast&lt;char&gt;(fValue.uint8t), 0 };</a>
<a name="ln1601">			char cStr[2] = { static_cast&lt;char&gt;(compareTo-&gt;fValue.uint8t), 0};</a>
<a name="ln1602"> </a>
<a name="ln1603">			BString valueStr(vStr);</a>
<a name="ln1604">			BString compareToStr(cStr);</a>
<a name="ln1605"> </a>
<a name="ln1606">			return valueStr.ICompare(compareToStr);</a>
<a name="ln1607">		}</a>
<a name="ln1608"> </a>
<a name="ln1609">		case B_FLOAT_TYPE:</a>
<a name="ln1610">			return fValue.floatt &gt;= compareTo-&gt;fValue.floatt ?</a>
<a name="ln1611">				(fValue.floatt == compareTo-&gt;fValue.floatt ? 0 : 1) : -1;</a>
<a name="ln1612"> </a>
<a name="ln1613">		case B_DOUBLE_TYPE:</a>
<a name="ln1614">			return fValue.doublet &gt;= compareTo-&gt;fValue.doublet ?</a>
<a name="ln1615">				(fValue.doublet == compareTo-&gt;fValue.doublet ? 0 : 1) : -1;</a>
<a name="ln1616"> </a>
<a name="ln1617">		case B_BOOL_TYPE:</a>
<a name="ln1618">			return fValue.boolt &gt;= compareTo-&gt;fValue.boolt ?</a>
<a name="ln1619">				(fValue.boolt == compareTo-&gt;fValue.boolt ? 0 : 1) : -1;</a>
<a name="ln1620"> </a>
<a name="ln1621">		case B_UINT8_TYPE:</a>
<a name="ln1622">			return fValue.uint8t &gt;= compareTo-&gt;fValue.uint8t ?</a>
<a name="ln1623">				(fValue.uint8t == compareTo-&gt;fValue.uint8t ? 0 : 1) : -1;</a>
<a name="ln1624"> </a>
<a name="ln1625">		case B_INT8_TYPE:</a>
<a name="ln1626">			return fValue.int8t &gt;= compareTo-&gt;fValue.int8t ?</a>
<a name="ln1627">					(fValue.int8t == compareTo-&gt;fValue.int8t ? 0 : 1) : -1;</a>
<a name="ln1628"> </a>
<a name="ln1629">		case B_UINT16_TYPE:</a>
<a name="ln1630">			return fValue.uint16t &gt;= compareTo-&gt;fValue.uint16t ?</a>
<a name="ln1631">				(fValue.uint16t == compareTo-&gt;fValue.uint16t ? 0 : 1) : -1;</a>
<a name="ln1632"> </a>
<a name="ln1633">		case B_INT16_TYPE:</a>
<a name="ln1634">			return fValue.int16t &gt;= compareTo-&gt;fValue.int16t ?</a>
<a name="ln1635">				(fValue.int16t == compareTo-&gt;fValue.int16t ? 0 : 1) : -1;</a>
<a name="ln1636"> </a>
<a name="ln1637">		case B_UINT32_TYPE:</a>
<a name="ln1638">			return fValue.uint32t &gt;= compareTo-&gt;fValue.uint32t ?</a>
<a name="ln1639">				(fValue.uint32t == compareTo-&gt;fValue.uint32t ? 0 : 1) : -1;</a>
<a name="ln1640"> </a>
<a name="ln1641">		case B_TIME_TYPE:</a>
<a name="ln1642">			// time_t typedef'd to a long, i.e. a int32</a>
<a name="ln1643">		case B_INT32_TYPE:</a>
<a name="ln1644">			return fValue.int32t &gt;= compareTo-&gt;fValue.int32t ?</a>
<a name="ln1645">				(fValue.int32t == compareTo-&gt;fValue.int32t ? 0 : 1) : -1;</a>
<a name="ln1646"> </a>
<a name="ln1647">		case B_OFF_T_TYPE:</a>
<a name="ln1648">			// off_t typedef'd to a long long, i.e. a int64</a>
<a name="ln1649">		case B_INT64_TYPE:</a>
<a name="ln1650">			return fValue.int64t &gt;= compareTo-&gt;fValue.int64t ?</a>
<a name="ln1651">				(fValue.int64t == compareTo-&gt;fValue.int64t ? 0 : 1) : -1;</a>
<a name="ln1652"> </a>
<a name="ln1653">		case B_UINT64_TYPE:</a>
<a name="ln1654">		default:</a>
<a name="ln1655">			return fValue.uint64t &gt;= compareTo-&gt;fValue.uint64t ?</a>
<a name="ln1656">				(fValue.uint64t == compareTo-&gt;fValue.uint64t ? 0 : 1) : -1;</a>
<a name="ln1657">	}</a>
<a name="ln1658"> </a>
<a name="ln1659">	return 0;</a>
<a name="ln1660">}</a>
<a name="ln1661"> </a>
<a name="ln1662"> </a>
<a name="ln1663">bool</a>
<a name="ln1664">GenericAttributeText::CommitEditedText(BTextView* textView)</a>
<a name="ln1665">{</a>
<a name="ln1666">	ASSERT(fColumn-&gt;Editable());</a>
<a name="ln1667">	const char* text = textView-&gt;Text();</a>
<a name="ln1668"> </a>
<a name="ln1669">	if (fFullValueText == text)</a>
<a name="ln1670">		// no change</a>
<a name="ln1671">		return false;</a>
<a name="ln1672"> </a>
<a name="ln1673">	if (!CommitEditedTextFlavor(textView))</a>
<a name="ln1674">		return false;</a>
<a name="ln1675"> </a>
<a name="ln1676">	// update text and width in this widget</a>
<a name="ln1677">	fFullValueText = text;</a>
<a name="ln1678">	// cause re-truncation</a>
<a name="ln1679">	fDirty = true;</a>
<a name="ln1680">	fValueDirty = true;</a>
<a name="ln1681"> </a>
<a name="ln1682">	return true;</a>
<a name="ln1683">}</a>
<a name="ln1684"> </a>
<a name="ln1685"> </a>
<a name="ln1686">void</a>
<a name="ln1687">GenericAttributeText::SetUpEditing(BTextView* textView)</a>
<a name="ln1688">{</a>
<a name="ln1689">	textView-&gt;SetMaxBytes(kGenericReadBufferSize - 1);</a>
<a name="ln1690">	textView-&gt;SetText(fFullValueText.String(), fFullValueText.Length());</a>
<a name="ln1691">}</a>
<a name="ln1692"> </a>
<a name="ln1693"> </a>
<a name="ln1694">bool</a>
<a name="ln1695">GenericAttributeText::CommitEditedTextFlavor(BTextView* textView)</a>
<a name="ln1696">{</a>
<a name="ln1697">	BNode node(fModel-&gt;EntryRef());</a>
<a name="ln1698"> </a>
<a name="ln1699">	if (node.InitCheck() != B_OK)</a>
<a name="ln1700">		return false;</a>
<a name="ln1701"> </a>
<a name="ln1702">	uint32 type = fColumn-&gt;AttrType();</a>
<a name="ln1703"> </a>
<a name="ln1704">	if (type != B_STRING_TYPE</a>
<a name="ln1705">		&amp;&amp; type != B_UINT64_TYPE</a>
<a name="ln1706">		&amp;&amp; type != B_UINT32_TYPE</a>
<a name="ln1707">		&amp;&amp; type != B_UINT16_TYPE</a>
<a name="ln1708">		&amp;&amp; type != B_UINT8_TYPE</a>
<a name="ln1709">		&amp;&amp; type != B_INT64_TYPE</a>
<a name="ln1710">		&amp;&amp; type != B_INT32_TYPE</a>
<a name="ln1711">		&amp;&amp; type != B_INT16_TYPE</a>
<a name="ln1712">		&amp;&amp; type != B_INT8_TYPE</a>
<a name="ln1713">		&amp;&amp; type != B_OFF_T_TYPE</a>
<a name="ln1714">		&amp;&amp; type != B_TIME_TYPE</a>
<a name="ln1715">		&amp;&amp; type != B_FLOAT_TYPE</a>
<a name="ln1716">		&amp;&amp; type != B_DOUBLE_TYPE</a>
<a name="ln1717">		&amp;&amp; type != B_CHAR_TYPE</a>
<a name="ln1718">		&amp;&amp; type != B_BOOL_TYPE) {</a>
<a name="ln1719">		BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln1720">			B_TRANSLATE(&quot;Sorry, you cannot edit that attribute.&quot;),</a>
<a name="ln1721">			B_TRANSLATE(&quot;Cancel&quot;),</a>
<a name="ln1722">			0, 0, B_WIDTH_AS_USUAL, B_STOP_ALERT);</a>
<a name="ln1723">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln1724">		alert-&gt;Go();</a>
<a name="ln1725">		return false;</a>
<a name="ln1726">	}</a>
<a name="ln1727"> </a>
<a name="ln1728">	const char* columnName = fColumn-&gt;AttrName();</a>
<a name="ln1729">	ssize_t size = 0;</a>
<a name="ln1730"> </a>
<a name="ln1731">	switch (type) {</a>
<a name="ln1732">		case B_STRING_TYPE:</a>
<a name="ln1733">			size = fModel-&gt;WriteAttr(columnName, type, 0, textView-&gt;Text(),</a>
<a name="ln1734">				(size_t)(textView-&gt;TextLength() + 1));</a>
<a name="ln1735">			break;</a>
<a name="ln1736"> </a>
<a name="ln1737">		case B_BOOL_TYPE:</a>
<a name="ln1738">		{</a>
<a name="ln1739">			bool value = strncasecmp(textView-&gt;Text(), &quot;0&quot;, 1) != 0</a>
<a name="ln1740">				&amp;&amp; strncasecmp(textView-&gt;Text(), &quot;off&quot;, 2) != 0</a>
<a name="ln1741">				&amp;&amp; strncasecmp(textView-&gt;Text(), &quot;no&quot;, 3) != 0</a>
<a name="ln1742">				&amp;&amp; strncasecmp(textView-&gt;Text(), &quot;false&quot;, 4) != 0</a>
<a name="ln1743">				&amp;&amp; strlen(textView-&gt;Text()) != 0;</a>
<a name="ln1744"> </a>
<a name="ln1745">			size = fModel-&gt;WriteAttr(columnName, type, 0, &amp;value, sizeof(bool));</a>
<a name="ln1746">			break;</a>
<a name="ln1747">		}</a>
<a name="ln1748"> </a>
<a name="ln1749">		case B_CHAR_TYPE:</a>
<a name="ln1750">		{</a>
<a name="ln1751">			char ch;</a>
<a name="ln1752">			sscanf(textView-&gt;Text(), &quot;%c&quot;, &amp;ch);</a>
<a name="ln1753">			//Check if we read the start of a multi-byte glyph:</a>
<a name="ln1754">			if (!isprint(ch)) {</a>
<a name="ln1755">				BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln1756">					B_TRANSLATE(&quot;Sorry, the 'Character' &quot;</a>
<a name="ln1757">					&quot;attribute cannot store a multi-byte glyph.&quot;),</a>
<a name="ln1758">					B_TRANSLATE(&quot;Cancel&quot;),</a>
<a name="ln1759">					0, 0, B_WIDTH_AS_USUAL, B_STOP_ALERT);</a>
<a name="ln1760">				alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln1761">				alert-&gt;Go();</a>
<a name="ln1762">				return false;</a>
<a name="ln1763">			}</a>
<a name="ln1764"> </a>
<a name="ln1765">			size = fModel-&gt;WriteAttr(columnName, type, 0, &amp;ch, sizeof(char));</a>
<a name="ln1766">			break;</a>
<a name="ln1767">		}</a>
<a name="ln1768"> </a>
<a name="ln1769">		case B_FLOAT_TYPE:</a>
<a name="ln1770">		{</a>
<a name="ln1771">			float floatVal;</a>
<a name="ln1772"> </a>
<a name="ln1773">			if (sscanf(textView-&gt;Text(), &quot;%f&quot;, &amp;floatVal) == 1) {</a>
<a name="ln1774">				fValueIsDefined = true;</a>
<a name="ln1775">				fValue.floatt = floatVal;</a>
<a name="ln1776">				size = fModel-&gt;WriteAttr(columnName, type, 0, &amp;floatVal,</a>
<a name="ln1777">					sizeof(float));</a>
<a name="ln1778">			} else {</a>
<a name="ln1779">				// If the value was already defined, it's on disk.</a>
<a name="ln1780">				// Otherwise not.</a>
<a name="ln1781">				return fValueIsDefined;</a>
<a name="ln1782">			}</a>
<a name="ln1783">			break;</a>
<a name="ln1784">		}</a>
<a name="ln1785"> </a>
<a name="ln1786">		case B_DOUBLE_TYPE:</a>
<a name="ln1787">		{</a>
<a name="ln1788">			double doubleVal;</a>
<a name="ln1789"> </a>
<a name="ln1790">			if (sscanf(textView-&gt;Text(), &quot;%lf&quot;, &amp;doubleVal) == 1) {</a>
<a name="ln1791">				fValueIsDefined = true;</a>
<a name="ln1792">				fValue.doublet = doubleVal;</a>
<a name="ln1793">				size = fModel-&gt;WriteAttr(columnName, type, 0, &amp;doubleVal,</a>
<a name="ln1794">					sizeof(double));</a>
<a name="ln1795">			} else {</a>
<a name="ln1796">				// If the value was already defined, it's on disk.</a>
<a name="ln1797">				// Otherwise not.</a>
<a name="ln1798">				return fValueIsDefined;</a>
<a name="ln1799">			}</a>
<a name="ln1800">			break;</a>
<a name="ln1801">		}</a>
<a name="ln1802"> </a>
<a name="ln1803">		case B_TIME_TYPE:</a>
<a name="ln1804">		case B_OFF_T_TYPE:</a>
<a name="ln1805">		case B_UINT64_TYPE:</a>
<a name="ln1806">		case B_UINT32_TYPE:</a>
<a name="ln1807">		case B_UINT16_TYPE:</a>
<a name="ln1808">		case B_UINT8_TYPE:</a>
<a name="ln1809">		case B_INT64_TYPE:</a>
<a name="ln1810">		case B_INT32_TYPE:</a>
<a name="ln1811">		case B_INT16_TYPE:</a>
<a name="ln1812">		case B_INT8_TYPE:</a>
<a name="ln1813">		{</a>
<a name="ln1814">			GenericValueStruct tmp;</a>
<a name="ln1815">			size_t scalarSize = 0;</a>
<a name="ln1816"> </a>
<a name="ln1817">			switch (type) {</a>
<a name="ln1818">				case B_TIME_TYPE:</a>
<a name="ln1819">					tmp.time_tt = parsedate(textView-&gt;Text(), time(0));</a>
<a name="ln1820">					scalarSize = sizeof(time_t);</a>
<a name="ln1821">					break;</a>
<a name="ln1822"> </a>
<a name="ln1823">				// do some size independent conversion on builtin types</a>
<a name="ln1824">				case B_OFF_T_TYPE:</a>
<a name="ln1825">					tmp.off_tt = StringToScalar(textView-&gt;Text());</a>
<a name="ln1826">					scalarSize = sizeof(off_t);</a>
<a name="ln1827">					break;</a>
<a name="ln1828"> </a>
<a name="ln1829">				case B_UINT64_TYPE:</a>
<a name="ln1830">				case B_INT64_TYPE:</a>
<a name="ln1831">					tmp.int64t = StringToScalar(textView-&gt;Text());</a>
<a name="ln1832">					scalarSize = sizeof(int64);</a>
<a name="ln1833">					break;</a>
<a name="ln1834"> </a>
<a name="ln1835">				case B_UINT32_TYPE:</a>
<a name="ln1836">				case B_INT32_TYPE:</a>
<a name="ln1837">					tmp.int32t = (int32)StringToScalar(textView-&gt;Text());</a>
<a name="ln1838">					scalarSize = sizeof(int32);</a>
<a name="ln1839">					break;</a>
<a name="ln1840"> </a>
<a name="ln1841">				case B_UINT16_TYPE:</a>
<a name="ln1842">				case B_INT16_TYPE:</a>
<a name="ln1843">					tmp.int16t = (int16)StringToScalar(textView-&gt;Text());</a>
<a name="ln1844">					scalarSize = sizeof(int16);</a>
<a name="ln1845">					break;</a>
<a name="ln1846"> </a>
<a name="ln1847">				case B_UINT8_TYPE:</a>
<a name="ln1848">				case B_INT8_TYPE:</a>
<a name="ln1849">					tmp.int8t = (int8)StringToScalar(textView-&gt;Text());</a>
<a name="ln1850">					scalarSize = sizeof(int8);</a>
<a name="ln1851">					break;</a>
<a name="ln1852"> </a>
<a name="ln1853">				default:</a>
<a name="ln1854">					TRESPASS();</a>
<a name="ln1855">			}</a>
<a name="ln1856"> </a>
<a name="ln1857">			size = fModel-&gt;WriteAttr(columnName, type, 0, &amp;tmp, scalarSize);</a>
<a name="ln1858">			break;</a>
<a name="ln1859">		}</a>
<a name="ln1860">	}</a>
<a name="ln1861"> </a>
<a name="ln1862">	if (size &lt; 0) {</a>
<a name="ln1863">		BAlert* alert = new BAlert(&quot;&quot;,</a>
<a name="ln1864">			B_TRANSLATE(&quot;There was an error writing the attribute.&quot;),</a>
<a name="ln1865">			B_TRANSLATE(&quot;Cancel&quot;),</a>
<a name="ln1866">			0, 0, B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln1867">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln1868">		alert-&gt;Go();</a>
<a name="ln1869"> </a>
<a name="ln1870">		fValueIsDefined = false;</a>
<a name="ln1871">		return false;</a>
<a name="ln1872">	}</a>
<a name="ln1873"> </a>
<a name="ln1874">	fValueIsDefined = true;</a>
<a name="ln1875">	return true;</a>
<a name="ln1876">}</a>
<a name="ln1877"> </a>
<a name="ln1878"> </a>
<a name="ln1879">// #pragma mark - DurationAttributeText (display as: duration)</a>
<a name="ln1880"> </a>
<a name="ln1881"> </a>
<a name="ln1882">DurationAttributeText::DurationAttributeText(const Model* model,</a>
<a name="ln1883">	const BColumn* column)</a>
<a name="ln1884">	:</a>
<a name="ln1885">	GenericAttributeText(model, column)</a>
<a name="ln1886">{</a>
<a name="ln1887">}</a>
<a name="ln1888"> </a>
<a name="ln1889"> </a>
<a name="ln1890">// TODO: support editing!</a>
<a name="ln1891"> </a>
<a name="ln1892"> </a>
<a name="ln1893">void</a>
<a name="ln1894">DurationAttributeText::FitValue(BString* outString, const BPoseView* view)</a>
<a name="ln1895">{</a>
<a name="ln1896">	if (fValueDirty)</a>
<a name="ln1897">		ReadValue(&amp;fFullValueText);</a>
<a name="ln1898"> </a>
<a name="ln1899">	fOldWidth = fColumn-&gt;Width();</a>
<a name="ln1900">	fDirty = false;</a>
<a name="ln1901"> </a>
<a name="ln1902">	if (!fValueIsDefined) {</a>
<a name="ln1903">		*outString = &quot;-&quot;;</a>
<a name="ln1904">		fTruncatedWidth = TruncString(outString, fFullValueText.String(),</a>
<a name="ln1905">			fFullValueText.Length(), view, fOldWidth);</a>
<a name="ln1906">		return;</a>
<a name="ln1907">	}</a>
<a name="ln1908"> </a>
<a name="ln1909">	int64 time = 0;</a>
<a name="ln1910"> </a>
<a name="ln1911">	switch (fColumn-&gt;AttrType()) {</a>
<a name="ln1912">		case B_TIME_TYPE:</a>
<a name="ln1913">			time = fValue.time_tt * 1000000LL;</a>
<a name="ln1914">			break;</a>
<a name="ln1915"> </a>
<a name="ln1916">		case B_INT8_TYPE:</a>
<a name="ln1917">			time = fValue.int8t * 1000000LL;</a>
<a name="ln1918">			break;</a>
<a name="ln1919"> </a>
<a name="ln1920">		case B_INT16_TYPE:</a>
<a name="ln1921">			time = fValue.int16t * 1000000LL;</a>
<a name="ln1922">			break;</a>
<a name="ln1923"> </a>
<a name="ln1924">		case B_INT32_TYPE:</a>
<a name="ln1925">			time = fValue.int32t * 1000000LL;</a>
<a name="ln1926">			break;</a>
<a name="ln1927"> </a>
<a name="ln1928">		case B_INT64_TYPE:</a>
<a name="ln1929">			time = fValue.int64t;</a>
<a name="ln1930">			break;</a>
<a name="ln1931">	}</a>
<a name="ln1932"> </a>
<a name="ln1933">	// TODO: ignores micro seconds for now</a>
<a name="ln1934">	int32 seconds = time / 1000000LL;</a>
<a name="ln1935"> </a>
<a name="ln1936">	bool negative = seconds &lt; 0;</a>
<a name="ln1937">	if (negative)</a>
<a name="ln1938">		seconds = -seconds;</a>
<a name="ln1939"> </a>
<a name="ln1940">	int32 hours = seconds / 3600;</a>
<a name="ln1941">	seconds -= hours * 3600;</a>
<a name="ln1942">	int32 minutes = seconds / 60;</a>
<a name="ln1943">	seconds = seconds % 60;</a>
<a name="ln1944"> </a>
<a name="ln1945">	char buffer[256];</a>
<a name="ln1946">	if (hours &gt; 0) {</a>
<a name="ln1947">		snprintf(buffer, sizeof(buffer), &quot;%s%&quot; B_PRId32 &quot;:%02&quot; B_PRId32 &quot;:%02&quot;</a>
<a name="ln1948">			B_PRId32, negative ? &quot;-&quot; : &quot;&quot;, hours, minutes, seconds);</a>
<a name="ln1949">	} else {</a>
<a name="ln1950">		snprintf(buffer, sizeof(buffer), &quot;%s%&quot; B_PRId32 &quot;:%02&quot; B_PRId32,</a>
<a name="ln1951">			negative ? &quot;-&quot; : &quot;&quot;, minutes, seconds);</a>
<a name="ln1952">	}</a>
<a name="ln1953"> </a>
<a name="ln1954">	fFullValueText = buffer;</a>
<a name="ln1955"> </a>
<a name="ln1956">	fTruncatedWidth = TruncString(outString, fFullValueText.String(),</a>
<a name="ln1957">		fFullValueText.Length(), view, fOldWidth);</a>
<a name="ln1958">}</a>
<a name="ln1959"> </a>
<a name="ln1960"> </a>
<a name="ln1961">// #pragma mark - CheckboxAttributeText (display as: checkbox)</a>
<a name="ln1962"> </a>
<a name="ln1963"> </a>
<a name="ln1964">CheckboxAttributeText::CheckboxAttributeText(const Model* model,</a>
<a name="ln1965">	const BColumn* column)</a>
<a name="ln1966">	:</a>
<a name="ln1967">	GenericAttributeText(model, column),</a>
<a name="ln1968">	fOnChar(&quot;✖&quot;),</a>
<a name="ln1969">	fOffChar(&quot;-&quot;)</a>
<a name="ln1970">{</a>
<a name="ln1971">	// TODO: better have common data in the column object!</a>
<a name="ln1972">	if (const char* separator = strchr(column-&gt;DisplayAs(), ':')) {</a>
<a name="ln1973">		BString chars(separator + 1);</a>
<a name="ln1974">		int32 length;</a>
<a name="ln1975">		const char* c = chars.CharAt(0, &amp;length);</a>
<a name="ln1976">		fOnChar.SetTo(c, length);</a>
<a name="ln1977">		if (c[length]) {</a>
<a name="ln1978">			c = chars.CharAt(1, &amp;length);</a>
<a name="ln1979">			fOffChar.SetTo(c, length);</a>
<a name="ln1980">		}</a>
<a name="ln1981">	}</a>
<a name="ln1982">}</a>
<a name="ln1983"> </a>
<a name="ln1984"> </a>
<a name="ln1985">void</a>
<a name="ln1986">CheckboxAttributeText::SetUpEditing(BTextView* view)</a>
<a name="ln1987">{</a>
<a name="ln1988">	// TODO: support editing for real!</a>
<a name="ln1989">	BString outString;</a>
<a name="ln1990">	GenericAttributeText::FitValue(&amp;outString, NULL);</a>
<a name="ln1991">	GenericAttributeText::SetUpEditing(view);</a>
<a name="ln1992">}</a>
<a name="ln1993"> </a>
<a name="ln1994"> </a>
<a name="ln1995">void</a>
<a name="ln1996">CheckboxAttributeText::FitValue(BString* outString, const BPoseView* view)</a>
<a name="ln1997">{</a>
<a name="ln1998">	if (fValueDirty)</a>
<a name="ln1999">		ReadValue(&amp;fFullValueText);</a>
<a name="ln2000"> </a>
<a name="ln2001">	fOldWidth = fColumn-&gt;Width();</a>
<a name="ln2002">	fDirty = false;</a>
<a name="ln2003"> </a>
<a name="ln2004">	if (!fValueIsDefined) {</a>
<a name="ln2005">		*outString = fOffChar;</a>
<a name="ln2006">		fTruncatedWidth = TruncString(outString, fFullValueText.String(),</a>
<a name="ln2007">			fFullValueText.Length(), view, fOldWidth);</a>
<a name="ln2008">		return;</a>
<a name="ln2009">	}</a>
<a name="ln2010"> </a>
<a name="ln2011">	bool checked = false;</a>
<a name="ln2012"> </a>
<a name="ln2013">	switch (fColumn-&gt;AttrType()) {</a>
<a name="ln2014">		case B_BOOL_TYPE:</a>
<a name="ln2015">			checked = fValue.boolt;</a>
<a name="ln2016">			break;</a>
<a name="ln2017"> </a>
<a name="ln2018">		case B_INT8_TYPE:</a>
<a name="ln2019">		case B_UINT8_TYPE:</a>
<a name="ln2020">			checked = fValue.int8t != 0;</a>
<a name="ln2021">			break;</a>
<a name="ln2022"> </a>
<a name="ln2023">		case B_INT16_TYPE:</a>
<a name="ln2024">		case B_UINT16_TYPE:</a>
<a name="ln2025">			checked = fValue.int16t != 0;</a>
<a name="ln2026">			break;</a>
<a name="ln2027"> </a>
<a name="ln2028">		case B_INT32_TYPE:</a>
<a name="ln2029">		case B_UINT32_TYPE:</a>
<a name="ln2030">			checked = fValue.int32t != 0;</a>
<a name="ln2031">			break;</a>
<a name="ln2032">	}</a>
<a name="ln2033"> </a>
<a name="ln2034">	fFullValueText = checked ? fOnChar : fOffChar;</a>
<a name="ln2035"> </a>
<a name="ln2036">	fTruncatedWidth = TruncString(outString, fFullValueText.String(),</a>
<a name="ln2037">		fFullValueText.Length(), view, fOldWidth);</a>
<a name="ln2038">}</a>
<a name="ln2039"> </a>
<a name="ln2040"> </a>
<a name="ln2041">// #pragma mark - RatingAttributeText (display as: rating)</a>
<a name="ln2042"> </a>
<a name="ln2043"> </a>
<a name="ln2044">RatingAttributeText::RatingAttributeText(const Model* model,</a>
<a name="ln2045">	const BColumn* column)</a>
<a name="ln2046">	:</a>
<a name="ln2047">	GenericAttributeText(model, column),</a>
<a name="ln2048">	fCount(5),</a>
<a name="ln2049">	fMax(10)</a>
<a name="ln2050">{</a>
<a name="ln2051">	// TODO: support different star counts/max via specifier</a>
<a name="ln2052">}</a>
<a name="ln2053"> </a>
<a name="ln2054"> </a>
<a name="ln2055">void</a>
<a name="ln2056">RatingAttributeText::SetUpEditing(BTextView* view)</a>
<a name="ln2057">{</a>
<a name="ln2058">	// TODO: support editing for real!</a>
<a name="ln2059">	BString outString;</a>
<a name="ln2060">	GenericAttributeText::FitValue(&amp;outString, NULL);</a>
<a name="ln2061">	GenericAttributeText::SetUpEditing(view);</a>
<a name="ln2062">}</a>
<a name="ln2063"> </a>
<a name="ln2064"> </a>
<a name="ln2065">void</a>
<a name="ln2066">RatingAttributeText::FitValue(BString* ratingString, const BPoseView* view)</a>
<a name="ln2067">{</a>
<a name="ln2068">	if (fValueDirty)</a>
<a name="ln2069">		ReadValue(&amp;fFullValueText);</a>
<a name="ln2070"> </a>
<a name="ln2071">	fOldWidth = fColumn-&gt;Width();</a>
<a name="ln2072">	fDirty = false;</a>
<a name="ln2073"> </a>
<a name="ln2074">	int64 rating;</a>
<a name="ln2075">	if (fValueIsDefined) {</a>
<a name="ln2076">		switch (fColumn-&gt;AttrType()) {</a>
<a name="ln2077">			case B_INT8_TYPE:</a>
<a name="ln2078">				rating = fValue.int8t;</a>
<a name="ln2079">				break;</a>
<a name="ln2080"> </a>
<a name="ln2081">			case B_INT16_TYPE:</a>
<a name="ln2082">				rating = fValue.int16t;</a>
<a name="ln2083">				break;</a>
<a name="ln2084"> </a>
<a name="ln2085">			case B_INT32_TYPE:</a>
<a name="ln2086">				rating = fValue.int32t;</a>
<a name="ln2087">				break;</a>
<a name="ln2088"> </a>
<a name="ln2089">			default:</a>
<a name="ln2090">				rating = 0;</a>
<a name="ln2091">				break;</a>
<a name="ln2092">		}</a>
<a name="ln2093">	} else</a>
<a name="ln2094">		rating = 0;</a>
<a name="ln2095"> </a>
<a name="ln2096">	if (rating &gt; fMax)</a>
<a name="ln2097">		rating = fMax;</a>
<a name="ln2098"> </a>
<a name="ln2099">	if (rating &lt; 0)</a>
<a name="ln2100">		rating = 0;</a>
<a name="ln2101"> </a>
<a name="ln2102">	int32 steps = fMax / fCount;</a>
<a name="ln2103">	fFullValueText = &quot;&quot;;</a>
<a name="ln2104"> </a>
<a name="ln2105">	for (int32 i = 0; i &lt; fCount; i++) {</a>
<a name="ln2106">		int64 n = i * steps;</a>
<a name="ln2107">		if (rating &gt; n)</a>
<a name="ln2108">			fFullValueText += &quot;★&quot;;</a>
<a name="ln2109">		else</a>
<a name="ln2110">			fFullValueText += &quot;☆&quot;;</a>
<a name="ln2111">	}</a>
<a name="ln2112"> </a>
<a name="ln2113">	fTruncatedWidth = TruncString(ratingString, fFullValueText.String(),</a>
<a name="ln2114">		fFullValueText.Length(), view, fOldWidth);</a>
<a name="ln2115">}</a>
<a name="ln2116"> </a>
<a name="ln2117"> </a>
<a name="ln2118">// #pragma mark - OpenWithRelationAttributeText</a>
<a name="ln2119"> </a>
<a name="ln2120"> </a>
<a name="ln2121">OpenWithRelationAttributeText::OpenWithRelationAttributeText(const Model* model,</a>
<a name="ln2122">	const BColumn* column, const BPoseView* view)</a>
<a name="ln2123">	:</a>
<a name="ln2124">	ScalarAttributeText(model, column),</a>
<a name="ln2125">	fPoseView(view)</a>
<a name="ln2126">{</a>
<a name="ln2127">}</a>
<a name="ln2128"> </a>
<a name="ln2129"> </a>
<a name="ln2130">int64</a>
<a name="ln2131">OpenWithRelationAttributeText::ReadValue()</a>
<a name="ln2132">{</a>
<a name="ln2133">	fValueDirty = false;</a>
<a name="ln2134"> </a>
<a name="ln2135">	const OpenWithPoseView* view</a>
<a name="ln2136">		= dynamic_cast&lt;const OpenWithPoseView*&gt;(fPoseView);</a>
<a name="ln2137">	if (view != NULL) {</a>
<a name="ln2138">		fValue = view-&gt;OpenWithRelation(fModel);</a>
<a name="ln2139">		fValueIsDefined = true;</a>
<a name="ln2140">	}</a>
<a name="ln2141"> </a>
<a name="ln2142">	return fValue;</a>
<a name="ln2143">}</a>
<a name="ln2144"> </a>
<a name="ln2145"> </a>
<a name="ln2146">float</a>
<a name="ln2147">OpenWithRelationAttributeText::PreferredWidth(const BPoseView* pose) const</a>
<a name="ln2148">{</a>
<a name="ln2149">	BString widthString;</a>
<a name="ln2150">	TruncString(&amp;widthString, fRelationText.String(), fRelationText.Length(),</a>
<a name="ln2151">		pose, 500, B_TRUNCATE_END);</a>
<a name="ln2152">	return pose-&gt;StringWidth(widthString.String());</a>
<a name="ln2153">}</a>
<a name="ln2154"> </a>
<a name="ln2155"> </a>
<a name="ln2156">void</a>
<a name="ln2157">OpenWithRelationAttributeText::FitValue(BString* outString,</a>
<a name="ln2158">	const BPoseView* view)</a>
<a name="ln2159">{</a>
<a name="ln2160">	if (fValueDirty)</a>
<a name="ln2161">		ReadValue();</a>
<a name="ln2162"> </a>
<a name="ln2163">	ASSERT(view == fPoseView);</a>
<a name="ln2164">	const OpenWithPoseView* launchWithView</a>
<a name="ln2165">		= dynamic_cast&lt;const OpenWithPoseView*&gt;(view);</a>
<a name="ln2166">	if (launchWithView != NULL)</a>
<a name="ln2167">		launchWithView-&gt;OpenWithRelationDescription(fModel, &amp;fRelationText);</a>
<a name="ln2168"> </a>
<a name="ln2169">	fOldWidth = fColumn-&gt;Width();</a>
<a name="ln2170">	fTruncatedWidth = TruncString(outString, fRelationText.String(),</a>
<a name="ln2171">		fRelationText.Length(), view, fOldWidth, B_TRUNCATE_END);</a>
<a name="ln2172">	fDirty = false;</a>
<a name="ln2173">}</a>
<a name="ln2174"> </a>
<a name="ln2175"> </a>
<a name="ln2176">// #pragma mark - VersionAttributeText</a>
<a name="ln2177"> </a>
<a name="ln2178"> </a>
<a name="ln2179">VersionAttributeText::VersionAttributeText(const Model* model,</a>
<a name="ln2180">	const BColumn* column, bool app)</a>
<a name="ln2181">	:</a>
<a name="ln2182">	StringAttributeText(model, column),</a>
<a name="ln2183">	fAppVersion(app)</a>
<a name="ln2184">{</a>
<a name="ln2185">}</a>
<a name="ln2186"> </a>
<a name="ln2187"> </a>
<a name="ln2188">void</a>
<a name="ln2189">VersionAttributeText::ReadValue(BString* outString)</a>
<a name="ln2190">{</a>
<a name="ln2191">	fValueDirty = false;</a>
<a name="ln2192"> </a>
<a name="ln2193">	BModelOpener opener(fModel);</a>
<a name="ln2194">	BFile* file = dynamic_cast&lt;BFile*&gt;(fModel-&gt;Node());</a>
<a name="ln2195">	if (file != NULL) {</a>
<a name="ln2196">		BAppFileInfo info(file);</a>
<a name="ln2197">		version_info version;</a>
<a name="ln2198">		if (info.InitCheck() == B_OK</a>
<a name="ln2199">			&amp;&amp; info.GetVersionInfo(&amp;version, fAppVersion</a>
<a name="ln2200">				? B_APP_VERSION_KIND : B_SYSTEM_VERSION_KIND) == B_OK) {</a>
<a name="ln2201">			*outString = version.short_info;</a>
<a name="ln2202">			return;</a>
<a name="ln2203">		}</a>
<a name="ln2204">	}</a>
<a name="ln2205"> </a>
<a name="ln2206">	*outString = &quot;-&quot;;</a>
<a name="ln2207">}</a>

</code></pre>
<div class="balloon" rel="974"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="1762"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="1871"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="837"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="1725"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="1266"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fValue.</p></div>
<div class="balloon" rel="1734"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'textView->TextLength() + 1' operator to the 'size_t' type, not the result.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
