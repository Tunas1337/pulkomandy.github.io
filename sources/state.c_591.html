
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>state.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright (c) 1989, 1993</a>
<a name="ln3"> *	The Regents of the University of California.  All rights reserved.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln6"> * modification, are permitted provided that the following conditions</a>
<a name="ln7"> * are met:</a>
<a name="ln8"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln9"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln10"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln11"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln12"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln13"> * 3. All advertising materials mentioning features or use of this software</a>
<a name="ln14"> *    must display the following acknowledgement:</a>
<a name="ln15"> *	This product includes software developed by the University of</a>
<a name="ln16"> *	California, Berkeley and its contributors.</a>
<a name="ln17"> * 4. Neither the name of the University nor the names of its contributors</a>
<a name="ln18"> *    may be used to endorse or promote products derived from this software</a>
<a name="ln19"> *    without specific prior written permission.</a>
<a name="ln20"> *</a>
<a name="ln21"> * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln22"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln23"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln24"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</a>
<a name="ln25"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln26"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln27"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln28"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln29"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln30"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln31"> * SUCH DAMAGE.</a>
<a name="ln32"> */</a>
<a name="ln33"> </a>
<a name="ln34">#if 0</a>
<a name="ln35">#ifndef lint</a>
<a name="ln36">static const char sccsid[] = &quot;@(#)state.c	8.5 (Berkeley) 5/30/95&quot;;</a>
<a name="ln37">#endif</a>
<a name="ln38">#endif</a>
<a name="ln39">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln40">__FBSDID(&quot;$FreeBSD: src/contrib/telnet/telnetd/state.c,v 1.14 2003/05/04 02:54:49 obrien Exp $&quot;);</a>
<a name="ln41"> </a>
<a name="ln42">#include &lt;stdarg.h&gt;</a>
<a name="ln43">#include &quot;telnetd.h&quot;</a>
<a name="ln44">#ifdef	AUTHENTICATION</a>
<a name="ln45">#include &lt;libtelnet/auth.h&gt;</a>
<a name="ln46">#endif</a>
<a name="ln47">#ifdef	ENCRYPTION</a>
<a name="ln48">#include &lt;libtelnet/encrypt.h&gt;</a>
<a name="ln49">#endif</a>
<a name="ln50"> </a>
<a name="ln51">unsigned char	doopt[] = { IAC, DO, '%', 'c', 0 };</a>
<a name="ln52">unsigned char	dont[] = { IAC, DONT, '%', 'c', 0 };</a>
<a name="ln53">unsigned char	will[] = { IAC, WILL, '%', 'c', 0 };</a>
<a name="ln54">unsigned char	wont[] = { IAC, WONT, '%', 'c', 0 };</a>
<a name="ln55">int	not42 = 1;</a>
<a name="ln56"> </a>
<a name="ln57">/*</a>
<a name="ln58"> * Buffer for sub-options, and macros</a>
<a name="ln59"> * for suboptions buffer manipulations</a>
<a name="ln60"> */</a>
<a name="ln61">unsigned char subbuffer[512], *subpointer= subbuffer, *subend= subbuffer;</a>
<a name="ln62"> </a>
<a name="ln63">#define	SB_CLEAR()	subpointer = subbuffer</a>
<a name="ln64">#define	SB_TERM()	{ subend = subpointer; SB_CLEAR(); }</a>
<a name="ln65">#define	SB_ACCUM(c)	if (subpointer &lt; (subbuffer+sizeof subbuffer)) { \</a>
<a name="ln66">				*subpointer++ = (c); \</a>
<a name="ln67">			}</a>
<a name="ln68">#define	SB_GET()	((*subpointer++)&amp;0xff)</a>
<a name="ln69">#define	SB_EOF()	(subpointer &gt;= subend)</a>
<a name="ln70">#define	SB_LEN()	(subend - subpointer)</a>
<a name="ln71"> </a>
<a name="ln72">#ifdef	ENV_HACK</a>
<a name="ln73">unsigned char *subsave;</a>
<a name="ln74">#define SB_SAVE()	subsave = subpointer;</a>
<a name="ln75">#define	SB_RESTORE()	subpointer = subsave;</a>
<a name="ln76">#endif</a>
<a name="ln77"> </a>
<a name="ln78"> </a>
<a name="ln79">/*</a>
<a name="ln80"> * State for recv fsm</a>
<a name="ln81"> */</a>
<a name="ln82">#define	TS_DATA		0	/* base state */</a>
<a name="ln83">#define	TS_IAC		1	/* look for double IAC's */</a>
<a name="ln84">#define	TS_CR		2	/* CR-LF -&gt;'s CR */</a>
<a name="ln85">#define	TS_SB		3	/* throw away begin's... */</a>
<a name="ln86">#define	TS_SE		4	/* ...end's (suboption negotiation) */</a>
<a name="ln87">#define	TS_WILL		5	/* will option negotiation */</a>
<a name="ln88">#define	TS_WONT		6	/* wont &quot; */</a>
<a name="ln89">#define	TS_DO		7	/* do &quot; */</a>
<a name="ln90">#define	TS_DONT		8	/* dont &quot; */</a>
<a name="ln91"> </a>
<a name="ln92">static void doclientstat(void);</a>
<a name="ln93"> </a>
<a name="ln94">void</a>
<a name="ln95">telrcv(void)</a>
<a name="ln96">{</a>
<a name="ln97">	int c;</a>
<a name="ln98">	static int state = TS_DATA;</a>
<a name="ln99"> </a>
<a name="ln100">	while (ncc &gt; 0) {</a>
<a name="ln101">		if ((&amp;ptyobuf[BUFSIZ] - pfrontp) &lt; 2)</a>
<a name="ln102">			break;</a>
<a name="ln103">		c = *netip++ &amp; 0377, ncc--;</a>
<a name="ln104">#ifdef	ENCRYPTION</a>
<a name="ln105">		if (decrypt_input)</a>
<a name="ln106">			c = (*decrypt_input)(c);</a>
<a name="ln107">#endif	/* ENCRYPTION */</a>
<a name="ln108">		switch (state) {</a>
<a name="ln109"> </a>
<a name="ln110">		case TS_CR:</a>
<a name="ln111">			state = TS_DATA;</a>
<a name="ln112">			/* Strip off \n or \0 after a \r */</a>
<a name="ln113">			if ((c == 0) || (c == '\n')) {</a>
<a name="ln114">				break;</a>
<a name="ln115">			}</a>
<a name="ln116">			/* FALLTHROUGH */</a>
<a name="ln117"> </a>
<a name="ln118">		case TS_DATA:</a>
<a name="ln119">			if (c == IAC) {</a>
<a name="ln120">				state = TS_IAC;</a>
<a name="ln121">				break;</a>
<a name="ln122">			}</a>
<a name="ln123">			/*</a>
<a name="ln124">			 * We now map \r\n ==&gt; \r for pragmatic reasons.</a>
<a name="ln125">			 * Many client implementations send \r\n when</a>
<a name="ln126">			 * the user hits the CarriageReturn key.</a>
<a name="ln127">			 *</a>
<a name="ln128">			 * We USED to map \r\n ==&gt; \n, since \r\n says</a>
<a name="ln129">			 * that we want to be in column 1 of the next</a>
<a name="ln130">			 * printable line, and \n is the standard</a>
<a name="ln131">			 * unix way of saying that (\r is only good</a>
<a name="ln132">			 * if CRMOD is set, which it normally is).</a>
<a name="ln133">			 */</a>
<a name="ln134">			if ((c == '\r') &amp;&amp; his_state_is_wont(TELOPT_BINARY)) {</a>
<a name="ln135">				int nc = *netip;</a>
<a name="ln136">#ifdef	ENCRYPTION</a>
<a name="ln137">				if (decrypt_input)</a>
<a name="ln138">					nc = (*decrypt_input)(nc &amp; 0xff);</a>
<a name="ln139">#endif	/* ENCRYPTION */</a>
<a name="ln140">#ifdef	LINEMODE</a>
<a name="ln141">				/*</a>
<a name="ln142">				 * If we are operating in linemode,</a>
<a name="ln143">				 * convert to local end-of-line.</a>
<a name="ln144">				 */</a>
<a name="ln145">				if (linemode &amp;&amp; (ncc &gt; 0) &amp;&amp; (('\n' == nc) ||</a>
<a name="ln146">					 ((0 == nc) &amp;&amp; tty_iscrnl())) ) {</a>
<a name="ln147">					netip++; ncc--;</a>
<a name="ln148">					c = '\n';</a>
<a name="ln149">				} else</a>
<a name="ln150">#endif</a>
<a name="ln151">				{</a>
<a name="ln152">#ifdef	ENCRYPTION</a>
<a name="ln153">					if (decrypt_input)</a>
<a name="ln154">						(void)(*decrypt_input)(-1);</a>
<a name="ln155">#endif	/* ENCRYPTION */</a>
<a name="ln156">					state = TS_CR;</a>
<a name="ln157">				}</a>
<a name="ln158">			}</a>
<a name="ln159">			*pfrontp++ = c;</a>
<a name="ln160">			break;</a>
<a name="ln161"> </a>
<a name="ln162">		case TS_IAC:</a>
<a name="ln163">gotiac:			switch (c) {</a>
<a name="ln164"> </a>
<a name="ln165">			/*</a>
<a name="ln166">			 * Send the process on the pty side an</a>
<a name="ln167">			 * interrupt.  Do this with a NULL or</a>
<a name="ln168">			 * interrupt char; depending on the tty mode.</a>
<a name="ln169">			 */</a>
<a name="ln170">			case IP:</a>
<a name="ln171">				DIAG(TD_OPTIONS,</a>
<a name="ln172">					printoption(&quot;td: recv IAC&quot;, c));</a>
<a name="ln173">				interrupt();</a>
<a name="ln174">				break;</a>
<a name="ln175"> </a>
<a name="ln176">			case BREAK:</a>
<a name="ln177">				DIAG(TD_OPTIONS,</a>
<a name="ln178">					printoption(&quot;td: recv IAC&quot;, c));</a>
<a name="ln179">				sendbrk();</a>
<a name="ln180">				break;</a>
<a name="ln181"> </a>
<a name="ln182">			/*</a>
<a name="ln183">			 * Are You There?</a>
<a name="ln184">			 */</a>
<a name="ln185">			case AYT:</a>
<a name="ln186">				DIAG(TD_OPTIONS,</a>
<a name="ln187">					printoption(&quot;td: recv IAC&quot;, c));</a>
<a name="ln188">				recv_ayt();</a>
<a name="ln189">				break;</a>
<a name="ln190"> </a>
<a name="ln191">			/*</a>
<a name="ln192">			 * Abort Output</a>
<a name="ln193">			 */</a>
<a name="ln194">			case AO:</a>
<a name="ln195">			    {</a>
<a name="ln196">				DIAG(TD_OPTIONS,</a>
<a name="ln197">					printoption(&quot;td: recv IAC&quot;, c));</a>
<a name="ln198">				ptyflush();	/* half-hearted */</a>
<a name="ln199">				init_termbuf();</a>
<a name="ln200"> </a>
<a name="ln201">				if (slctab[SLC_AO].sptr &amp;&amp;</a>
<a name="ln202">				    *slctab[SLC_AO].sptr != (cc_t)(_POSIX_VDISABLE)) {</a>
<a name="ln203">				    *pfrontp++ =</a>
<a name="ln204">					(unsigned char)*slctab[SLC_AO].sptr;</a>
<a name="ln205">				}</a>
<a name="ln206"> </a>
<a name="ln207">				netclear();	/* clear buffer back */</a>
<a name="ln208">				output_data(&quot;%c%c&quot;, IAC, DM);</a>
<a name="ln209">				neturg = nfrontp-1; /* off by one XXX */</a>
<a name="ln210">				DIAG(TD_OPTIONS,</a>
<a name="ln211">					printoption(&quot;td: send IAC&quot;, DM));</a>
<a name="ln212">				break;</a>
<a name="ln213">			    }</a>
<a name="ln214"> </a>
<a name="ln215">			/*</a>
<a name="ln216">			 * Erase Character and</a>
<a name="ln217">			 * Erase Line</a>
<a name="ln218">			 */</a>
<a name="ln219">			case EC:</a>
<a name="ln220">			case EL:</a>
<a name="ln221">			    {</a>
<a name="ln222">				cc_t ch;</a>
<a name="ln223"> </a>
<a name="ln224">				DIAG(TD_OPTIONS,</a>
<a name="ln225">					printoption(&quot;td: recv IAC&quot;, c));</a>
<a name="ln226">				ptyflush();	/* half-hearted */</a>
<a name="ln227">				init_termbuf();</a>
<a name="ln228">				if (c == EC)</a>
<a name="ln229">					ch = *slctab[SLC_EC].sptr;</a>
<a name="ln230">				else</a>
<a name="ln231">					ch = *slctab[SLC_EL].sptr;</a>
<a name="ln232">				if (ch != (cc_t)(_POSIX_VDISABLE))</a>
<a name="ln233">					*pfrontp++ = (unsigned char)ch;</a>
<a name="ln234">				break;</a>
<a name="ln235">			    }</a>
<a name="ln236"> </a>
<a name="ln237">			/*</a>
<a name="ln238">			 * Check for urgent data...</a>
<a name="ln239">			 */</a>
<a name="ln240">			case DM:</a>
<a name="ln241">				DIAG(TD_OPTIONS,</a>
<a name="ln242">					printoption(&quot;td: recv IAC&quot;, c));</a>
<a name="ln243">				SYNCHing = stilloob(net);</a>
<a name="ln244">				settimer(gotDM);</a>
<a name="ln245">				break;</a>
<a name="ln246"> </a>
<a name="ln247"> </a>
<a name="ln248">			/*</a>
<a name="ln249">			 * Begin option subnegotiation...</a>
<a name="ln250">			 */</a>
<a name="ln251">			case SB:</a>
<a name="ln252">				state = TS_SB;</a>
<a name="ln253">				SB_CLEAR();</a>
<a name="ln254">				continue;</a>
<a name="ln255"> </a>
<a name="ln256">			case WILL:</a>
<a name="ln257">				state = TS_WILL;</a>
<a name="ln258">				continue;</a>
<a name="ln259"> </a>
<a name="ln260">			case WONT:</a>
<a name="ln261">				state = TS_WONT;</a>
<a name="ln262">				continue;</a>
<a name="ln263"> </a>
<a name="ln264">			case DO:</a>
<a name="ln265">				state = TS_DO;</a>
<a name="ln266">				continue;</a>
<a name="ln267"> </a>
<a name="ln268">			case DONT:</a>
<a name="ln269">				state = TS_DONT;</a>
<a name="ln270">				continue;</a>
<a name="ln271">			case EOR:</a>
<a name="ln272">				if (his_state_is_will(TELOPT_EOR))</a>
<a name="ln273">					doeof();</a>
<a name="ln274">				break;</a>
<a name="ln275"> </a>
<a name="ln276">			/*</a>
<a name="ln277">			 * Handle RFC 10xx Telnet linemode option additions</a>
<a name="ln278">			 * to command stream (EOF, SUSP, ABORT).</a>
<a name="ln279">			 */</a>
<a name="ln280">			case xEOF:</a>
<a name="ln281">				doeof();</a>
<a name="ln282">				break;</a>
<a name="ln283"> </a>
<a name="ln284">			case SUSP:</a>
<a name="ln285">				sendsusp();</a>
<a name="ln286">				break;</a>
<a name="ln287"> </a>
<a name="ln288">			case ABORT:</a>
<a name="ln289">				sendbrk();</a>
<a name="ln290">				break;</a>
<a name="ln291"> </a>
<a name="ln292">			case IAC:</a>
<a name="ln293">				*pfrontp++ = c;</a>
<a name="ln294">				break;</a>
<a name="ln295">			}</a>
<a name="ln296">			state = TS_DATA;</a>
<a name="ln297">			break;</a>
<a name="ln298"> </a>
<a name="ln299">		case TS_SB:</a>
<a name="ln300">			if (c == IAC) {</a>
<a name="ln301">				state = TS_SE;</a>
<a name="ln302">			} else {</a>
<a name="ln303">				SB_ACCUM(c);</a>
<a name="ln304">			}</a>
<a name="ln305">			break;</a>
<a name="ln306"> </a>
<a name="ln307">		case TS_SE:</a>
<a name="ln308">			if (c != SE) {</a>
<a name="ln309">				if (c != IAC) {</a>
<a name="ln310">					/*</a>
<a name="ln311">					 * bad form of suboption negotiation.</a>
<a name="ln312">					 * handle it in such a way as to avoid</a>
<a name="ln313">					 * damage to local state.  Parse</a>
<a name="ln314">					 * suboption buffer found so far,</a>
<a name="ln315">					 * then treat remaining stream as</a>
<a name="ln316">					 * another command sequence.</a>
<a name="ln317">					 */</a>
<a name="ln318"> </a>
<a name="ln319">					/* for DIAGNOSTICS */</a>
<a name="ln320">					SB_ACCUM(IAC);</a>
<a name="ln321">					SB_ACCUM(c);</a>
<a name="ln322">					subpointer -= 2;</a>
<a name="ln323"> </a>
<a name="ln324">					SB_TERM();</a>
<a name="ln325">					suboption();</a>
<a name="ln326">					state = TS_IAC;</a>
<a name="ln327">					goto gotiac;</a>
<a name="ln328">				}</a>
<a name="ln329">				SB_ACCUM(c);</a>
<a name="ln330">				state = TS_SB;</a>
<a name="ln331">			} else {</a>
<a name="ln332">				/* for DIAGNOSTICS */</a>
<a name="ln333">				SB_ACCUM(IAC);</a>
<a name="ln334">				SB_ACCUM(SE);</a>
<a name="ln335">				subpointer -= 2;</a>
<a name="ln336"> </a>
<a name="ln337">				SB_TERM();</a>
<a name="ln338">				suboption();	/* handle sub-option */</a>
<a name="ln339">				state = TS_DATA;</a>
<a name="ln340">			}</a>
<a name="ln341">			break;</a>
<a name="ln342"> </a>
<a name="ln343">		case TS_WILL:</a>
<a name="ln344">			willoption(c);</a>
<a name="ln345">			state = TS_DATA;</a>
<a name="ln346">			continue;</a>
<a name="ln347"> </a>
<a name="ln348">		case TS_WONT:</a>
<a name="ln349">			wontoption(c);</a>
<a name="ln350">			state = TS_DATA;</a>
<a name="ln351">			continue;</a>
<a name="ln352"> </a>
<a name="ln353">		case TS_DO:</a>
<a name="ln354">			dooption(c);</a>
<a name="ln355">			state = TS_DATA;</a>
<a name="ln356">			continue;</a>
<a name="ln357"> </a>
<a name="ln358">		case TS_DONT:</a>
<a name="ln359">			dontoption(c);</a>
<a name="ln360">			state = TS_DATA;</a>
<a name="ln361">			continue;</a>
<a name="ln362"> </a>
<a name="ln363">		default:</a>
<a name="ln364">			syslog(LOG_ERR, &quot;panic state=%d&quot;, state);</a>
<a name="ln365">			printf(&quot;telnetd: panic state=%d\n&quot;, state);</a>
<a name="ln366">			exit(1);</a>
<a name="ln367">		}</a>
<a name="ln368">	}</a>
<a name="ln369">}  /* end of telrcv */</a>
<a name="ln370"> </a>
<a name="ln371">/*</a>
<a name="ln372"> * The will/wont/do/dont state machines are based on Dave Borman's</a>
<a name="ln373"> * Telnet option processing state machine.</a>
<a name="ln374"> *</a>
<a name="ln375"> * These correspond to the following states:</a>
<a name="ln376"> *	my_state = the last negotiated state</a>
<a name="ln377"> *	want_state = what I want the state to go to</a>
<a name="ln378"> *	want_resp = how many requests I have sent</a>
<a name="ln379"> * All state defaults are negative, and resp defaults to 0.</a>
<a name="ln380"> *</a>
<a name="ln381"> * When initiating a request to change state to new_state:</a>
<a name="ln382"> *</a>
<a name="ln383"> * if ((want_resp == 0 &amp;&amp; new_state == my_state) || want_state == new_state) {</a>
<a name="ln384"> *	do nothing;</a>
<a name="ln385"> * } else {</a>
<a name="ln386"> *	want_state = new_state;</a>
<a name="ln387"> *	send new_state;</a>
<a name="ln388"> *	want_resp++;</a>
<a name="ln389"> * }</a>
<a name="ln390"> *</a>
<a name="ln391"> * When receiving new_state:</a>
<a name="ln392"> *</a>
<a name="ln393"> * if (want_resp) {</a>
<a name="ln394"> *	want_resp--;</a>
<a name="ln395"> *	if (want_resp &amp;&amp; (new_state == my_state))</a>
<a name="ln396"> *		want_resp--;</a>
<a name="ln397"> * }</a>
<a name="ln398"> * if ((want_resp == 0) &amp;&amp; (new_state != want_state)) {</a>
<a name="ln399"> *	if (ok_to_switch_to new_state)</a>
<a name="ln400"> *		want_state = new_state;</a>
<a name="ln401"> *	else</a>
<a name="ln402"> *		want_resp++;</a>
<a name="ln403"> *	send want_state;</a>
<a name="ln404"> * }</a>
<a name="ln405"> * my_state = new_state;</a>
<a name="ln406"> *</a>
<a name="ln407"> * Note that new_state is implied in these functions by the function itself.</a>
<a name="ln408"> * will and do imply positive new_state, wont and dont imply negative.</a>
<a name="ln409"> *</a>
<a name="ln410"> * Finally, there is one catch.  If we send a negative response to a</a>
<a name="ln411"> * positive request, my_state will be the positive while want_state will</a>
<a name="ln412"> * remain negative.  my_state will revert to negative when the negative</a>
<a name="ln413"> * acknowlegment arrives from the peer.  Thus, my_state generally tells</a>
<a name="ln414"> * us not only the last negotiated state, but also tells us what the peer</a>
<a name="ln415"> * wants to be doing as well.  It is important to understand this difference</a>
<a name="ln416"> * as we may wish to be processing data streams based on our desired state</a>
<a name="ln417"> * (want_state) or based on what the peer thinks the state is (my_state).</a>
<a name="ln418"> *</a>
<a name="ln419"> * This all works fine because if the peer sends a positive request, the data</a>
<a name="ln420"> * that we receive prior to negative acknowlegment will probably be affected</a>
<a name="ln421"> * by the positive state, and we can process it as such (if we can; if we</a>
<a name="ln422"> * can't then it really doesn't matter).  If it is that important, then the</a>
<a name="ln423"> * peer probably should be buffering until this option state negotiation</a>
<a name="ln424"> * is complete.</a>
<a name="ln425"> *</a>
<a name="ln426"> */</a>
<a name="ln427">void</a>
<a name="ln428">send_do(int option, int init)</a>
<a name="ln429">{</a>
<a name="ln430">	if (init) {</a>
<a name="ln431">		if ((do_dont_resp[option] == 0 &amp;&amp; his_state_is_will(option)) ||</a>
<a name="ln432">		    his_want_state_is_will(option))</a>
<a name="ln433">			return;</a>
<a name="ln434">		/*</a>
<a name="ln435">		 * Special case for TELOPT_TM:  We send a DO, but pretend</a>
<a name="ln436">		 * that we sent a DONT, so that we can send more DOs if</a>
<a name="ln437">		 * we want to.</a>
<a name="ln438">		 */</a>
<a name="ln439">		if (option == TELOPT_TM)</a>
<a name="ln440">			set_his_want_state_wont(option);</a>
<a name="ln441">		else</a>
<a name="ln442">			set_his_want_state_will(option);</a>
<a name="ln443">		do_dont_resp[option]++;</a>
<a name="ln444">	}</a>
<a name="ln445">	output_data((const char *)doopt, option);</a>
<a name="ln446"> </a>
<a name="ln447">	DIAG(TD_OPTIONS, printoption(&quot;td: send do&quot;, option));</a>
<a name="ln448">}</a>
<a name="ln449"> </a>
<a name="ln450">void</a>
<a name="ln451">willoption(int option)</a>
<a name="ln452">{</a>
<a name="ln453">	int changeok = 0;</a>
<a name="ln454">	void (*func)(void) = 0;</a>
<a name="ln455"> </a>
<a name="ln456">	/*</a>
<a name="ln457">	 * process input from peer.</a>
<a name="ln458">	 */</a>
<a name="ln459"> </a>
<a name="ln460">	DIAG(TD_OPTIONS, printoption(&quot;td: recv will&quot;, option));</a>
<a name="ln461"> </a>
<a name="ln462">	if (do_dont_resp[option]) {</a>
<a name="ln463">		do_dont_resp[option]--;</a>
<a name="ln464">		if (do_dont_resp[option] &amp;&amp; his_state_is_will(option))</a>
<a name="ln465">			do_dont_resp[option]--;</a>
<a name="ln466">	}</a>
<a name="ln467">	if (do_dont_resp[option] == 0) {</a>
<a name="ln468">	    if (his_want_state_is_wont(option)) {</a>
<a name="ln469">		switch (option) {</a>
<a name="ln470"> </a>
<a name="ln471">		case TELOPT_BINARY:</a>
<a name="ln472">			init_termbuf();</a>
<a name="ln473">			tty_binaryin(1);</a>
<a name="ln474">			set_termbuf();</a>
<a name="ln475">			changeok++;</a>
<a name="ln476">			break;</a>
<a name="ln477"> </a>
<a name="ln478">		case TELOPT_ECHO:</a>
<a name="ln479">			/*</a>
<a name="ln480">			 * See comments below for more info.</a>
<a name="ln481">			 */</a>
<a name="ln482">			not42 = 0;	/* looks like a 4.2 system */</a>
<a name="ln483">			break;</a>
<a name="ln484"> </a>
<a name="ln485">		case TELOPT_TM:</a>
<a name="ln486">#if	defined(LINEMODE) &amp;&amp; defined(KLUDGELINEMODE)</a>
<a name="ln487">			/*</a>
<a name="ln488">			 * This telnetd implementation does not really</a>
<a name="ln489">			 * support timing marks, it just uses them to</a>
<a name="ln490">			 * support the kludge linemode stuff.  If we</a>
<a name="ln491">			 * receive a will or wont TM in response to our</a>
<a name="ln492">			 * do TM request that may have been sent to</a>
<a name="ln493">			 * determine kludge linemode support, process</a>
<a name="ln494">			 * it, otherwise TM should get a negative</a>
<a name="ln495">			 * response back.</a>
<a name="ln496">			 */</a>
<a name="ln497">			/*</a>
<a name="ln498">			 * Handle the linemode kludge stuff.</a>
<a name="ln499">			 * If we are not currently supporting any</a>
<a name="ln500">			 * linemode at all, then we assume that this</a>
<a name="ln501">			 * is the client telling us to use kludge</a>
<a name="ln502">			 * linemode in response to our query.  Set the</a>
<a name="ln503">			 * linemode type that is to be supported, note</a>
<a name="ln504">			 * that the client wishes to use linemode, and</a>
<a name="ln505">			 * eat the will TM as though it never arrived.</a>
<a name="ln506">			 */</a>
<a name="ln507">			if (lmodetype &lt; KLUDGE_LINEMODE) {</a>
<a name="ln508">				lmodetype = KLUDGE_LINEMODE;</a>
<a name="ln509">				clientstat(TELOPT_LINEMODE, WILL, 0);</a>
<a name="ln510">				send_wont(TELOPT_SGA, 1);</a>
<a name="ln511">			} else if (lmodetype == NO_AUTOKLUDGE) {</a>
<a name="ln512">				lmodetype = KLUDGE_OK;</a>
<a name="ln513">			}</a>
<a name="ln514">#endif	/* defined(LINEMODE) &amp;&amp; defined(KLUDGELINEMODE) */</a>
<a name="ln515">			/*</a>
<a name="ln516">			 * We never respond to a WILL TM, and</a>
<a name="ln517">			 * we leave the state WONT.</a>
<a name="ln518">			 */</a>
<a name="ln519">			return;</a>
<a name="ln520"> </a>
<a name="ln521">		case TELOPT_LFLOW:</a>
<a name="ln522">			/*</a>
<a name="ln523">			 * If we are going to support flow control</a>
<a name="ln524">			 * option, then don't worry peer that we can't</a>
<a name="ln525">			 * change the flow control characters.</a>
<a name="ln526">			 */</a>
<a name="ln527">			slctab[SLC_XON].defset.flag &amp;= ~SLC_LEVELBITS;</a>
<a name="ln528">			slctab[SLC_XON].defset.flag |= SLC_DEFAULT;</a>
<a name="ln529">			slctab[SLC_XOFF].defset.flag &amp;= ~SLC_LEVELBITS;</a>
<a name="ln530">			slctab[SLC_XOFF].defset.flag |= SLC_DEFAULT;</a>
<a name="ln531">		case TELOPT_TTYPE:</a>
<a name="ln532">		case TELOPT_SGA:</a>
<a name="ln533">		case TELOPT_NAWS:</a>
<a name="ln534">		case TELOPT_TSPEED:</a>
<a name="ln535">		case TELOPT_XDISPLOC:</a>
<a name="ln536">		case TELOPT_NEW_ENVIRON:</a>
<a name="ln537">		case TELOPT_OLD_ENVIRON:</a>
<a name="ln538">			changeok++;</a>
<a name="ln539">			break;</a>
<a name="ln540"> </a>
<a name="ln541">#ifdef	LINEMODE</a>
<a name="ln542">		case TELOPT_LINEMODE:</a>
<a name="ln543"># ifdef	KLUDGELINEMODE</a>
<a name="ln544">			/*</a>
<a name="ln545">			 * Note client's desire to use linemode.</a>
<a name="ln546">			 */</a>
<a name="ln547">			lmodetype = REAL_LINEMODE;</a>
<a name="ln548"># endif	/* KLUDGELINEMODE */</a>
<a name="ln549">			func = doclientstat;</a>
<a name="ln550">			changeok++;</a>
<a name="ln551">			break;</a>
<a name="ln552">#endif	/* LINEMODE */</a>
<a name="ln553"> </a>
<a name="ln554">#ifdef	AUTHENTICATION</a>
<a name="ln555">		case TELOPT_AUTHENTICATION:</a>
<a name="ln556">			func = auth_request;</a>
<a name="ln557">			changeok++;</a>
<a name="ln558">			break;</a>
<a name="ln559">#endif</a>
<a name="ln560"> </a>
<a name="ln561">#ifdef	ENCRYPTION</a>
<a name="ln562">		case TELOPT_ENCRYPT:</a>
<a name="ln563">			func = encrypt_send_support;</a>
<a name="ln564">			changeok++;</a>
<a name="ln565">			break;</a>
<a name="ln566">#endif	/* ENCRYPTION */</a>
<a name="ln567"> </a>
<a name="ln568">		default:</a>
<a name="ln569">			break;</a>
<a name="ln570">		}</a>
<a name="ln571">		if (changeok) {</a>
<a name="ln572">			set_his_want_state_will(option);</a>
<a name="ln573">			send_do(option, 0);</a>
<a name="ln574">		} else {</a>
<a name="ln575">			do_dont_resp[option]++;</a>
<a name="ln576">			send_dont(option, 0);</a>
<a name="ln577">		}</a>
<a name="ln578">	    } else {</a>
<a name="ln579">		/*</a>
<a name="ln580">		 * Option processing that should happen when</a>
<a name="ln581">		 * we receive conformation of a change in</a>
<a name="ln582">		 * state that we had requested.</a>
<a name="ln583">		 */</a>
<a name="ln584">		switch (option) {</a>
<a name="ln585">		case TELOPT_ECHO:</a>
<a name="ln586">			not42 = 0;	/* looks like a 4.2 system */</a>
<a name="ln587">			/*</a>
<a name="ln588">			 * Egads, he responded &quot;WILL ECHO&quot;.  Turn</a>
<a name="ln589">			 * it off right now!</a>
<a name="ln590">			 */</a>
<a name="ln591">			send_dont(option, 1);</a>
<a name="ln592">			/*</a>
<a name="ln593">			 * &quot;WILL ECHO&quot;.  Kludge upon kludge!</a>
<a name="ln594">			 * A 4.2 client is now echoing user input at</a>
<a name="ln595">			 * the tty.  This is probably undesireable and</a>
<a name="ln596">			 * it should be stopped.  The client will</a>
<a name="ln597">			 * respond WONT TM to the DO TM that we send to</a>
<a name="ln598">			 * check for kludge linemode.  When the WONT TM</a>
<a name="ln599">			 * arrives, linemode will be turned off and a</a>
<a name="ln600">			 * change propogated to the pty.  This change</a>
<a name="ln601">			 * will cause us to process the new pty state</a>
<a name="ln602">			 * in localstat(), which will notice that</a>
<a name="ln603">			 * linemode is off and send a WILL ECHO</a>
<a name="ln604">			 * so that we are properly in character mode and</a>
<a name="ln605">			 * all is well.</a>
<a name="ln606">			 */</a>
<a name="ln607">			break;</a>
<a name="ln608">#ifdef	LINEMODE</a>
<a name="ln609">		case TELOPT_LINEMODE:</a>
<a name="ln610"># ifdef	KLUDGELINEMODE</a>
<a name="ln611">			/*</a>
<a name="ln612">			 * Note client's desire to use linemode.</a>
<a name="ln613">			 */</a>
<a name="ln614">			lmodetype = REAL_LINEMODE;</a>
<a name="ln615"># endif	/* KLUDGELINEMODE */</a>
<a name="ln616">			func = doclientstat;</a>
<a name="ln617">			break;</a>
<a name="ln618">#endif	/* LINEMODE */</a>
<a name="ln619"> </a>
<a name="ln620">#ifdef	AUTHENTICATION</a>
<a name="ln621">		case TELOPT_AUTHENTICATION:</a>
<a name="ln622">			func = auth_request;</a>
<a name="ln623">			break;</a>
<a name="ln624">#endif</a>
<a name="ln625"> </a>
<a name="ln626">#ifdef	ENCRYPTION</a>
<a name="ln627">		case TELOPT_ENCRYPT:</a>
<a name="ln628">			func = encrypt_send_support;</a>
<a name="ln629">			break;</a>
<a name="ln630">#endif	/* ENCRYPTION */</a>
<a name="ln631">		case TELOPT_LFLOW:</a>
<a name="ln632">			func = flowstat;</a>
<a name="ln633">			break;</a>
<a name="ln634">		}</a>
<a name="ln635">	    }</a>
<a name="ln636">	}</a>
<a name="ln637">	set_his_state_will(option);</a>
<a name="ln638">	if (func)</a>
<a name="ln639">		(*func)();</a>
<a name="ln640">}  /* end of willoption */</a>
<a name="ln641"> </a>
<a name="ln642">void</a>
<a name="ln643">send_dont(int option, int init)</a>
<a name="ln644">{</a>
<a name="ln645">	if (init) {</a>
<a name="ln646">		if ((do_dont_resp[option] == 0 &amp;&amp; his_state_is_wont(option)) ||</a>
<a name="ln647">		    his_want_state_is_wont(option))</a>
<a name="ln648">			return;</a>
<a name="ln649">		set_his_want_state_wont(option);</a>
<a name="ln650">		do_dont_resp[option]++;</a>
<a name="ln651">	}</a>
<a name="ln652">	output_data((const char *)dont, option);</a>
<a name="ln653"> </a>
<a name="ln654">	DIAG(TD_OPTIONS, printoption(&quot;td: send dont&quot;, option));</a>
<a name="ln655">}</a>
<a name="ln656"> </a>
<a name="ln657">void</a>
<a name="ln658">wontoption(int option)</a>
<a name="ln659">{</a>
<a name="ln660">	/*</a>
<a name="ln661">	 * Process client input.</a>
<a name="ln662">	 */</a>
<a name="ln663"> </a>
<a name="ln664">	DIAG(TD_OPTIONS, printoption(&quot;td: recv wont&quot;, option));</a>
<a name="ln665"> </a>
<a name="ln666">	if (do_dont_resp[option]) {</a>
<a name="ln667">		do_dont_resp[option]--;</a>
<a name="ln668">		if (do_dont_resp[option] &amp;&amp; his_state_is_wont(option))</a>
<a name="ln669">			do_dont_resp[option]--;</a>
<a name="ln670">	}</a>
<a name="ln671">	if (do_dont_resp[option] == 0) {</a>
<a name="ln672">	    if (his_want_state_is_will(option)) {</a>
<a name="ln673">		/* it is always ok to change to negative state */</a>
<a name="ln674">		switch (option) {</a>
<a name="ln675">		case TELOPT_ECHO:</a>
<a name="ln676">			not42 = 1; /* doesn't seem to be a 4.2 system */</a>
<a name="ln677">			break;</a>
<a name="ln678"> </a>
<a name="ln679">		case TELOPT_BINARY:</a>
<a name="ln680">			init_termbuf();</a>
<a name="ln681">			tty_binaryin(0);</a>
<a name="ln682">			set_termbuf();</a>
<a name="ln683">			break;</a>
<a name="ln684"> </a>
<a name="ln685">#ifdef	LINEMODE</a>
<a name="ln686">		case TELOPT_LINEMODE:</a>
<a name="ln687"># ifdef	KLUDGELINEMODE</a>
<a name="ln688">			/*</a>
<a name="ln689">			 * If real linemode is supported, then client is</a>
<a name="ln690">			 * asking to turn linemode off.</a>
<a name="ln691">			 */</a>
<a name="ln692">			if (lmodetype != REAL_LINEMODE)</a>
<a name="ln693">				break;</a>
<a name="ln694">			lmodetype = KLUDGE_LINEMODE;</a>
<a name="ln695"># endif	/* KLUDGELINEMODE */</a>
<a name="ln696">			clientstat(TELOPT_LINEMODE, WONT, 0);</a>
<a name="ln697">			break;</a>
<a name="ln698">#endif	/* LINEMODE */</a>
<a name="ln699"> </a>
<a name="ln700">		case TELOPT_TM:</a>
<a name="ln701">			/*</a>
<a name="ln702">			 * If we get a WONT TM, and had sent a DO TM,</a>
<a name="ln703">			 * don't respond with a DONT TM, just leave it</a>
<a name="ln704">			 * as is.  Short circut the state machine to</a>
<a name="ln705">			 * achive this.</a>
<a name="ln706">			 */</a>
<a name="ln707">			set_his_want_state_wont(TELOPT_TM);</a>
<a name="ln708">			return;</a>
<a name="ln709"> </a>
<a name="ln710">		case TELOPT_LFLOW:</a>
<a name="ln711">			/*</a>
<a name="ln712">			 * If we are not going to support flow control</a>
<a name="ln713">			 * option, then let peer know that we can't</a>
<a name="ln714">			 * change the flow control characters.</a>
<a name="ln715">			 */</a>
<a name="ln716">			slctab[SLC_XON].defset.flag &amp;= ~SLC_LEVELBITS;</a>
<a name="ln717">			slctab[SLC_XON].defset.flag |= SLC_CANTCHANGE;</a>
<a name="ln718">			slctab[SLC_XOFF].defset.flag &amp;= ~SLC_LEVELBITS;</a>
<a name="ln719">			slctab[SLC_XOFF].defset.flag |= SLC_CANTCHANGE;</a>
<a name="ln720">			break;</a>
<a name="ln721"> </a>
<a name="ln722">#ifdef	AUTHENTICATION</a>
<a name="ln723">		case TELOPT_AUTHENTICATION:</a>
<a name="ln724">			auth_finished(0, AUTH_REJECT);</a>
<a name="ln725">			break;</a>
<a name="ln726">#endif</a>
<a name="ln727"> </a>
<a name="ln728">		/*</a>
<a name="ln729">		 * For options that we might spin waiting for</a>
<a name="ln730">		 * sub-negotiation, if the client turns off the</a>
<a name="ln731">		 * option rather than responding to the request,</a>
<a name="ln732">		 * we have to treat it here as if we got a response</a>
<a name="ln733">		 * to the sub-negotiation, (by updating the timers)</a>
<a name="ln734">		 * so that we'll break out of the loop.</a>
<a name="ln735">		 */</a>
<a name="ln736">		case TELOPT_TTYPE:</a>
<a name="ln737">			settimer(ttypesubopt);</a>
<a name="ln738">			break;</a>
<a name="ln739"> </a>
<a name="ln740">		case TELOPT_TSPEED:</a>
<a name="ln741">			settimer(tspeedsubopt);</a>
<a name="ln742">			break;</a>
<a name="ln743"> </a>
<a name="ln744">		case TELOPT_XDISPLOC:</a>
<a name="ln745">			settimer(xdisplocsubopt);</a>
<a name="ln746">			break;</a>
<a name="ln747"> </a>
<a name="ln748">		case TELOPT_OLD_ENVIRON:</a>
<a name="ln749">			settimer(oenvironsubopt);</a>
<a name="ln750">			break;</a>
<a name="ln751"> </a>
<a name="ln752">		case TELOPT_NEW_ENVIRON:</a>
<a name="ln753">			settimer(environsubopt);</a>
<a name="ln754">			break;</a>
<a name="ln755"> </a>
<a name="ln756">		default:</a>
<a name="ln757">			break;</a>
<a name="ln758">		}</a>
<a name="ln759">		set_his_want_state_wont(option);</a>
<a name="ln760">		if (his_state_is_will(option))</a>
<a name="ln761">			send_dont(option, 0);</a>
<a name="ln762">	    } else {</a>
<a name="ln763">		switch (option) {</a>
<a name="ln764">		case TELOPT_TM:</a>
<a name="ln765">#if	defined(LINEMODE) &amp;&amp; defined(KLUDGELINEMODE)</a>
<a name="ln766">			if (lmodetype &lt; NO_AUTOKLUDGE) {</a>
<a name="ln767">				lmodetype = NO_LINEMODE;</a>
<a name="ln768">				clientstat(TELOPT_LINEMODE, WONT, 0);</a>
<a name="ln769">				send_will(TELOPT_SGA, 1);</a>
<a name="ln770">				send_will(TELOPT_ECHO, 1);</a>
<a name="ln771">			}</a>
<a name="ln772">#endif	/* defined(LINEMODE) &amp;&amp; defined(KLUDGELINEMODE) */</a>
<a name="ln773">			break;</a>
<a name="ln774"> </a>
<a name="ln775">#ifdef AUTHENTICATION</a>
<a name="ln776">		case TELOPT_AUTHENTICATION:</a>
<a name="ln777">			auth_finished(0, AUTH_REJECT);</a>
<a name="ln778">			break;</a>
<a name="ln779">#endif</a>
<a name="ln780">		default:</a>
<a name="ln781">			break;</a>
<a name="ln782">		}</a>
<a name="ln783">	    }</a>
<a name="ln784">	}</a>
<a name="ln785">	set_his_state_wont(option);</a>
<a name="ln786"> </a>
<a name="ln787">}  /* end of wontoption */</a>
<a name="ln788"> </a>
<a name="ln789">void</a>
<a name="ln790">send_will(int option, int init)</a>
<a name="ln791">{</a>
<a name="ln792">	if (init) {</a>
<a name="ln793">		if ((will_wont_resp[option] == 0 &amp;&amp; my_state_is_will(option))||</a>
<a name="ln794">		    my_want_state_is_will(option))</a>
<a name="ln795">			return;</a>
<a name="ln796">		set_my_want_state_will(option);</a>
<a name="ln797">		will_wont_resp[option]++;</a>
<a name="ln798">	}</a>
<a name="ln799">	output_data((const char *)will, option);</a>
<a name="ln800"> </a>
<a name="ln801">	DIAG(TD_OPTIONS, printoption(&quot;td: send will&quot;, option));</a>
<a name="ln802">}</a>
<a name="ln803"> </a>
<a name="ln804">#if	!defined(LINEMODE) || !defined(KLUDGELINEMODE)</a>
<a name="ln805">/*</a>
<a name="ln806"> * When we get a DONT SGA, we will try once to turn it</a>
<a name="ln807"> * back on.  If the other side responds DONT SGA, we</a>
<a name="ln808"> * leave it at that.  This is so that when we talk to</a>
<a name="ln809"> * clients that understand KLUDGELINEMODE but not LINEMODE,</a>
<a name="ln810"> * we'll keep them in char-at-a-time mode.</a>
<a name="ln811"> */</a>
<a name="ln812">int turn_on_sga = 0;</a>
<a name="ln813">#endif</a>
<a name="ln814"> </a>
<a name="ln815">void</a>
<a name="ln816">dooption(int option)</a>
<a name="ln817">{</a>
<a name="ln818">	int changeok = 0;</a>
<a name="ln819"> </a>
<a name="ln820">	/*</a>
<a name="ln821">	 * Process client input.</a>
<a name="ln822">	 */</a>
<a name="ln823"> </a>
<a name="ln824">	DIAG(TD_OPTIONS, printoption(&quot;td: recv do&quot;, option));</a>
<a name="ln825"> </a>
<a name="ln826">	if (will_wont_resp[option]) {</a>
<a name="ln827">		will_wont_resp[option]--;</a>
<a name="ln828">		if (will_wont_resp[option] &amp;&amp; my_state_is_will(option))</a>
<a name="ln829">			will_wont_resp[option]--;</a>
<a name="ln830">	}</a>
<a name="ln831">	if ((will_wont_resp[option] == 0) &amp;&amp; (my_want_state_is_wont(option))) {</a>
<a name="ln832">		switch (option) {</a>
<a name="ln833">		case TELOPT_ECHO:</a>
<a name="ln834">#ifdef	LINEMODE</a>
<a name="ln835"># ifdef	KLUDGELINEMODE</a>
<a name="ln836">			if (lmodetype == NO_LINEMODE)</a>
<a name="ln837"># else</a>
<a name="ln838">			if (his_state_is_wont(TELOPT_LINEMODE))</a>
<a name="ln839"># endif</a>
<a name="ln840">#endif</a>
<a name="ln841">			{</a>
<a name="ln842">				init_termbuf();</a>
<a name="ln843">				tty_setecho(1);</a>
<a name="ln844">				set_termbuf();</a>
<a name="ln845">			}</a>
<a name="ln846">			changeok++;</a>
<a name="ln847">			break;</a>
<a name="ln848"> </a>
<a name="ln849">		case TELOPT_BINARY:</a>
<a name="ln850">			init_termbuf();</a>
<a name="ln851">			tty_binaryout(1);</a>
<a name="ln852">			set_termbuf();</a>
<a name="ln853">			changeok++;</a>
<a name="ln854">			break;</a>
<a name="ln855"> </a>
<a name="ln856">		case TELOPT_SGA:</a>
<a name="ln857">#if	defined(LINEMODE) &amp;&amp; defined(KLUDGELINEMODE)</a>
<a name="ln858">			/*</a>
<a name="ln859">			 * If kludge linemode is in use, then we must</a>
<a name="ln860">			 * process an incoming do SGA for linemode</a>
<a name="ln861">			 * purposes.</a>
<a name="ln862">			 */</a>
<a name="ln863">			if (lmodetype == KLUDGE_LINEMODE) {</a>
<a name="ln864">				/*</a>
<a name="ln865">				 * Receipt of &quot;do SGA&quot; in kludge</a>
<a name="ln866">				 * linemode is the peer asking us to</a>
<a name="ln867">				 * turn off linemode.  Make note of</a>
<a name="ln868">				 * the request.</a>
<a name="ln869">				 */</a>
<a name="ln870">				clientstat(TELOPT_LINEMODE, WONT, 0);</a>
<a name="ln871">				/*</a>
<a name="ln872">				 * If linemode did not get turned off</a>
<a name="ln873">				 * then don't tell peer that we did.</a>
<a name="ln874">				 * Breaking here forces a wont SGA to</a>
<a name="ln875">				 * be returned.</a>
<a name="ln876">				 */</a>
<a name="ln877">				if (linemode)</a>
<a name="ln878">					break;</a>
<a name="ln879">			}</a>
<a name="ln880">#else</a>
<a name="ln881">			turn_on_sga = 0;</a>
<a name="ln882">#endif	/* defined(LINEMODE) &amp;&amp; defined(KLUDGELINEMODE) */</a>
<a name="ln883">			changeok++;</a>
<a name="ln884">			break;</a>
<a name="ln885"> </a>
<a name="ln886">		case TELOPT_STATUS:</a>
<a name="ln887">			changeok++;</a>
<a name="ln888">			break;</a>
<a name="ln889"> </a>
<a name="ln890">		case TELOPT_TM:</a>
<a name="ln891">			/*</a>
<a name="ln892">			 * Special case for TM.  We send a WILL, but</a>
<a name="ln893">			 * pretend we sent a WONT.</a>
<a name="ln894">			 */</a>
<a name="ln895">			send_will(option, 0);</a>
<a name="ln896">			set_my_want_state_wont(option);</a>
<a name="ln897">			set_my_state_wont(option);</a>
<a name="ln898">			return;</a>
<a name="ln899"> </a>
<a name="ln900">		case TELOPT_LOGOUT:</a>
<a name="ln901">			/*</a>
<a name="ln902">			 * When we get a LOGOUT option, respond</a>
<a name="ln903">			 * with a WILL LOGOUT, make sure that</a>
<a name="ln904">			 * it gets written out to the network,</a>
<a name="ln905">			 * and then just go away...</a>
<a name="ln906">			 */</a>
<a name="ln907">			set_my_want_state_will(TELOPT_LOGOUT);</a>
<a name="ln908">			send_will(TELOPT_LOGOUT, 0);</a>
<a name="ln909">			set_my_state_will(TELOPT_LOGOUT);</a>
<a name="ln910">			(void)netflush();</a>
<a name="ln911">			cleanup(0);</a>
<a name="ln912">			/* NOT REACHED */</a>
<a name="ln913">			break;</a>
<a name="ln914"> </a>
<a name="ln915">#ifdef	ENCRYPTION</a>
<a name="ln916">		case TELOPT_ENCRYPT:</a>
<a name="ln917">			changeok++;</a>
<a name="ln918">			break;</a>
<a name="ln919">#endif	/* ENCRYPTION */</a>
<a name="ln920">		case TELOPT_LINEMODE:</a>
<a name="ln921">		case TELOPT_TTYPE:</a>
<a name="ln922">		case TELOPT_NAWS:</a>
<a name="ln923">		case TELOPT_TSPEED:</a>
<a name="ln924">		case TELOPT_LFLOW:</a>
<a name="ln925">		case TELOPT_XDISPLOC:</a>
<a name="ln926">#ifdef	TELOPT_ENVIRON</a>
<a name="ln927">		case TELOPT_NEW_ENVIRON:</a>
<a name="ln928">#endif</a>
<a name="ln929">		case TELOPT_OLD_ENVIRON:</a>
<a name="ln930">		default:</a>
<a name="ln931">			break;</a>
<a name="ln932">		}</a>
<a name="ln933">		if (changeok) {</a>
<a name="ln934">			set_my_want_state_will(option);</a>
<a name="ln935">			send_will(option, 0);</a>
<a name="ln936">		} else {</a>
<a name="ln937">			will_wont_resp[option]++;</a>
<a name="ln938">			send_wont(option, 0);</a>
<a name="ln939">		}</a>
<a name="ln940">	}</a>
<a name="ln941">	set_my_state_will(option);</a>
<a name="ln942"> </a>
<a name="ln943">}  /* end of dooption */</a>
<a name="ln944"> </a>
<a name="ln945">void</a>
<a name="ln946">send_wont(int option, int init)</a>
<a name="ln947">{</a>
<a name="ln948">	if (init) {</a>
<a name="ln949">		if ((will_wont_resp[option] == 0 &amp;&amp; my_state_is_wont(option)) ||</a>
<a name="ln950">		    my_want_state_is_wont(option))</a>
<a name="ln951">			return;</a>
<a name="ln952">		set_my_want_state_wont(option);</a>
<a name="ln953">		will_wont_resp[option]++;</a>
<a name="ln954">	}</a>
<a name="ln955">	output_data((const char *)wont, option);</a>
<a name="ln956"> </a>
<a name="ln957">	DIAG(TD_OPTIONS, printoption(&quot;td: send wont&quot;, option));</a>
<a name="ln958">}</a>
<a name="ln959"> </a>
<a name="ln960">void</a>
<a name="ln961">dontoption(int option)</a>
<a name="ln962">{</a>
<a name="ln963">	/*</a>
<a name="ln964">	 * Process client input.</a>
<a name="ln965">	 */</a>
<a name="ln966"> </a>
<a name="ln967"> </a>
<a name="ln968">	DIAG(TD_OPTIONS, printoption(&quot;td: recv dont&quot;, option));</a>
<a name="ln969"> </a>
<a name="ln970">	if (will_wont_resp[option]) {</a>
<a name="ln971">		will_wont_resp[option]--;</a>
<a name="ln972">		if (will_wont_resp[option] &amp;&amp; my_state_is_wont(option))</a>
<a name="ln973">			will_wont_resp[option]--;</a>
<a name="ln974">	}</a>
<a name="ln975">	if ((will_wont_resp[option] == 0) &amp;&amp; (my_want_state_is_will(option))) {</a>
<a name="ln976">		switch (option) {</a>
<a name="ln977">		case TELOPT_BINARY:</a>
<a name="ln978">			init_termbuf();</a>
<a name="ln979">			tty_binaryout(0);</a>
<a name="ln980">			set_termbuf();</a>
<a name="ln981">			break;</a>
<a name="ln982"> </a>
<a name="ln983">		case TELOPT_ECHO:	/* we should stop echoing */</a>
<a name="ln984">#ifdef	LINEMODE</a>
<a name="ln985"># ifdef	KLUDGELINEMODE</a>
<a name="ln986">			if ((lmodetype != REAL_LINEMODE) &amp;&amp;</a>
<a name="ln987">			    (lmodetype != KLUDGE_LINEMODE))</a>
<a name="ln988"># else</a>
<a name="ln989">			if (his_state_is_wont(TELOPT_LINEMODE))</a>
<a name="ln990"># endif</a>
<a name="ln991">#endif</a>
<a name="ln992">			{</a>
<a name="ln993">				init_termbuf();</a>
<a name="ln994">				tty_setecho(0);</a>
<a name="ln995">				set_termbuf();</a>
<a name="ln996">			}</a>
<a name="ln997">			break;</a>
<a name="ln998"> </a>
<a name="ln999">		case TELOPT_SGA:</a>
<a name="ln1000">#if	defined(LINEMODE) &amp;&amp; defined(KLUDGELINEMODE)</a>
<a name="ln1001">			/*</a>
<a name="ln1002">			 * If kludge linemode is in use, then we</a>
<a name="ln1003">			 * must process an incoming do SGA for</a>
<a name="ln1004">			 * linemode purposes.</a>
<a name="ln1005">			 */</a>
<a name="ln1006">			if ((lmodetype == KLUDGE_LINEMODE) ||</a>
<a name="ln1007">			    (lmodetype == KLUDGE_OK)) {</a>
<a name="ln1008">				/*</a>
<a name="ln1009">				 * The client is asking us to turn</a>
<a name="ln1010">				 * linemode on.</a>
<a name="ln1011">				 */</a>
<a name="ln1012">				lmodetype = KLUDGE_LINEMODE;</a>
<a name="ln1013">				clientstat(TELOPT_LINEMODE, WILL, 0);</a>
<a name="ln1014">				/*</a>
<a name="ln1015">				 * If we did not turn line mode on,</a>
<a name="ln1016">				 * then what do we say?  Will SGA?</a>
<a name="ln1017">				 * This violates design of telnet.</a>
<a name="ln1018">				 * Gross.  Very Gross.</a>
<a name="ln1019">				 */</a>
<a name="ln1020">			}</a>
<a name="ln1021">			break;</a>
<a name="ln1022">#else</a>
<a name="ln1023">			set_my_want_state_wont(option);</a>
<a name="ln1024">			if (my_state_is_will(option))</a>
<a name="ln1025">				send_wont(option, 0);</a>
<a name="ln1026">			set_my_state_wont(option);</a>
<a name="ln1027">			if (turn_on_sga ^= 1)</a>
<a name="ln1028">				send_will(option, 1);</a>
<a name="ln1029">			return;</a>
<a name="ln1030">#endif	/* defined(LINEMODE) &amp;&amp; defined(KLUDGELINEMODE) */</a>
<a name="ln1031"> </a>
<a name="ln1032">		default:</a>
<a name="ln1033">			break;</a>
<a name="ln1034">		}</a>
<a name="ln1035"> </a>
<a name="ln1036">		set_my_want_state_wont(option);</a>
<a name="ln1037">		if (my_state_is_will(option))</a>
<a name="ln1038">			send_wont(option, 0);</a>
<a name="ln1039">	}</a>
<a name="ln1040">	set_my_state_wont(option);</a>
<a name="ln1041"> </a>
<a name="ln1042">}  /* end of dontoption */</a>
<a name="ln1043"> </a>
<a name="ln1044">#ifdef	ENV_HACK</a>
<a name="ln1045">int env_ovar = -1;</a>
<a name="ln1046">int env_ovalue = -1;</a>
<a name="ln1047">#else	/* ENV_HACK */</a>
<a name="ln1048"># define env_ovar OLD_ENV_VAR</a>
<a name="ln1049"># define env_ovalue OLD_ENV_VALUE</a>
<a name="ln1050">#endif	/* ENV_HACK */</a>
<a name="ln1051"> </a>
<a name="ln1052">/*</a>
<a name="ln1053"> * suboption()</a>
<a name="ln1054"> *</a>
<a name="ln1055"> *	Look at the sub-option buffer, and try to be helpful to the other</a>
<a name="ln1056"> * side.</a>
<a name="ln1057"> *</a>
<a name="ln1058"> *	Currently we recognize:</a>
<a name="ln1059"> *</a>
<a name="ln1060"> *	Terminal type is</a>
<a name="ln1061"> *	Linemode</a>
<a name="ln1062"> *	Window size</a>
<a name="ln1063"> *	Terminal speed</a>
<a name="ln1064"> */</a>
<a name="ln1065">void</a>
<a name="ln1066">suboption(void)</a>
<a name="ln1067">{</a>
<a name="ln1068">    int subchar;</a>
<a name="ln1069"> </a>
<a name="ln1070">    DIAG(TD_OPTIONS, {netflush(); printsub('&lt;', subpointer, SB_LEN()+2);});</a>
<a name="ln1071"> </a>
<a name="ln1072">    subchar = SB_GET();</a>
<a name="ln1073">    switch (subchar) {</a>
<a name="ln1074">    case TELOPT_TSPEED: {</a>
<a name="ln1075">	int xspeed, rspeed;</a>
<a name="ln1076"> </a>
<a name="ln1077">	if (his_state_is_wont(TELOPT_TSPEED))	/* Ignore if option disabled */</a>
<a name="ln1078">		break;</a>
<a name="ln1079"> </a>
<a name="ln1080">	settimer(tspeedsubopt);</a>
<a name="ln1081"> </a>
<a name="ln1082">	if (SB_EOF() || SB_GET() != TELQUAL_IS)</a>
<a name="ln1083">		return;</a>
<a name="ln1084"> </a>
<a name="ln1085">	xspeed = atoi((char *)subpointer);</a>
<a name="ln1086"> </a>
<a name="ln1087">	while (SB_GET() != ',' &amp;&amp; !SB_EOF());</a>
<a name="ln1088">	if (SB_EOF())</a>
<a name="ln1089">		return;</a>
<a name="ln1090"> </a>
<a name="ln1091">	rspeed = atoi((char *)subpointer);</a>
<a name="ln1092">	clientstat(TELOPT_TSPEED, xspeed, rspeed);</a>
<a name="ln1093"> </a>
<a name="ln1094">	break;</a>
<a name="ln1095"> </a>
<a name="ln1096">    }  /* end of case TELOPT_TSPEED */</a>
<a name="ln1097"> </a>
<a name="ln1098">    case TELOPT_TTYPE: {		/* Yaaaay! */</a>
<a name="ln1099">	static char terminalname[41];</a>
<a name="ln1100"> </a>
<a name="ln1101">	if (his_state_is_wont(TELOPT_TTYPE))	/* Ignore if option disabled */</a>
<a name="ln1102">		break;</a>
<a name="ln1103">	settimer(ttypesubopt);</a>
<a name="ln1104"> </a>
<a name="ln1105">	if (SB_EOF() || SB_GET() != TELQUAL_IS) {</a>
<a name="ln1106">	    return;		/* ??? XXX but, this is the most robust */</a>
<a name="ln1107">	}</a>
<a name="ln1108"> </a>
<a name="ln1109">	terminaltype = terminalname;</a>
<a name="ln1110"> </a>
<a name="ln1111">	while ((terminaltype &lt; (terminalname + sizeof terminalname-1)) &amp;&amp;</a>
<a name="ln1112">								    !SB_EOF()) {</a>
<a name="ln1113">	    int c;</a>
<a name="ln1114"> </a>
<a name="ln1115">	    c = SB_GET();</a>
<a name="ln1116">	    if (isupper(c)) {</a>
<a name="ln1117">		c = tolower(c);</a>
<a name="ln1118">	    }</a>
<a name="ln1119">	    *terminaltype++ = c;    /* accumulate name */</a>
<a name="ln1120">	}</a>
<a name="ln1121">	*terminaltype = 0;</a>
<a name="ln1122">	terminaltype = terminalname;</a>
<a name="ln1123">	break;</a>
<a name="ln1124">    }  /* end of case TELOPT_TTYPE */</a>
<a name="ln1125"> </a>
<a name="ln1126">    case TELOPT_NAWS: {</a>
<a name="ln1127">	int xwinsize, ywinsize;</a>
<a name="ln1128"> </a>
<a name="ln1129">	if (his_state_is_wont(TELOPT_NAWS))	/* Ignore if option disabled */</a>
<a name="ln1130">		break;</a>
<a name="ln1131"> </a>
<a name="ln1132">	if (SB_EOF())</a>
<a name="ln1133">		return;</a>
<a name="ln1134">	xwinsize = SB_GET() &lt;&lt; 8;</a>
<a name="ln1135">	if (SB_EOF())</a>
<a name="ln1136">		return;</a>
<a name="ln1137">	xwinsize |= SB_GET();</a>
<a name="ln1138">	if (SB_EOF())</a>
<a name="ln1139">		return;</a>
<a name="ln1140">	ywinsize = SB_GET() &lt;&lt; 8;</a>
<a name="ln1141">	if (SB_EOF())</a>
<a name="ln1142">		return;</a>
<a name="ln1143">	ywinsize |= SB_GET();</a>
<a name="ln1144">	clientstat(TELOPT_NAWS, xwinsize, ywinsize);</a>
<a name="ln1145"> </a>
<a name="ln1146">	break;</a>
<a name="ln1147"> </a>
<a name="ln1148">    }  /* end of case TELOPT_NAWS */</a>
<a name="ln1149"> </a>
<a name="ln1150">#ifdef	LINEMODE</a>
<a name="ln1151">    case TELOPT_LINEMODE: {</a>
<a name="ln1152">	int request;</a>
<a name="ln1153"> </a>
<a name="ln1154">	if (his_state_is_wont(TELOPT_LINEMODE))	/* Ignore if option disabled */</a>
<a name="ln1155">		break;</a>
<a name="ln1156">	/*</a>
<a name="ln1157">	 * Process linemode suboptions.</a>
<a name="ln1158">	 */</a>
<a name="ln1159">	if (SB_EOF())</a>
<a name="ln1160">	    break;		/* garbage was sent */</a>
<a name="ln1161">	request = SB_GET();	/* get will/wont */</a>
<a name="ln1162"> </a>
<a name="ln1163">	if (SB_EOF())</a>
<a name="ln1164">	    break;		/* another garbage check */</a>
<a name="ln1165"> </a>
<a name="ln1166">	if (request == LM_SLC) {  /* SLC is not preceeded by WILL or WONT */</a>
<a name="ln1167">		/*</a>
<a name="ln1168">		 * Process suboption buffer of slc's</a>
<a name="ln1169">		 */</a>
<a name="ln1170">		start_slc(1);</a>
<a name="ln1171">		do_opt_slc(subpointer, subend - subpointer);</a>
<a name="ln1172">		(void) end_slc(0);</a>
<a name="ln1173">		break;</a>
<a name="ln1174">	} else if (request == LM_MODE) {</a>
<a name="ln1175">		if (SB_EOF())</a>
<a name="ln1176">		    return;</a>
<a name="ln1177">		useeditmode = SB_GET();  /* get mode flag */</a>
<a name="ln1178">		clientstat(LM_MODE, 0, 0);</a>
<a name="ln1179">		break;</a>
<a name="ln1180">	}</a>
<a name="ln1181"> </a>
<a name="ln1182">	if (SB_EOF())</a>
<a name="ln1183">	    break;</a>
<a name="ln1184">	switch (SB_GET()) {  /* what suboption? */</a>
<a name="ln1185">	case LM_FORWARDMASK:</a>
<a name="ln1186">		/*</a>
<a name="ln1187">		 * According to spec, only server can send request for</a>
<a name="ln1188">		 * forwardmask, and client can only return a positive response.</a>
<a name="ln1189">		 * So don't worry about it.</a>
<a name="ln1190">		 */</a>
<a name="ln1191"> </a>
<a name="ln1192">	default:</a>
<a name="ln1193">		break;</a>
<a name="ln1194">	}</a>
<a name="ln1195">	break;</a>
<a name="ln1196">    }  /* end of case TELOPT_LINEMODE */</a>
<a name="ln1197">#endif</a>
<a name="ln1198">    case TELOPT_STATUS: {</a>
<a name="ln1199">	int mode;</a>
<a name="ln1200"> </a>
<a name="ln1201">	if (SB_EOF())</a>
<a name="ln1202">	    break;</a>
<a name="ln1203">	mode = SB_GET();</a>
<a name="ln1204">	switch (mode) {</a>
<a name="ln1205">	case TELQUAL_SEND:</a>
<a name="ln1206">	    if (my_state_is_will(TELOPT_STATUS))</a>
<a name="ln1207">		send_status();</a>
<a name="ln1208">	    break;</a>
<a name="ln1209"> </a>
<a name="ln1210">	case TELQUAL_IS:</a>
<a name="ln1211">	    break;</a>
<a name="ln1212"> </a>
<a name="ln1213">	default:</a>
<a name="ln1214">	    break;</a>
<a name="ln1215">	}</a>
<a name="ln1216">	break;</a>
<a name="ln1217">    }  /* end of case TELOPT_STATUS */</a>
<a name="ln1218"> </a>
<a name="ln1219">    case TELOPT_XDISPLOC: {</a>
<a name="ln1220">	if (SB_EOF() || SB_GET() != TELQUAL_IS)</a>
<a name="ln1221">		return;</a>
<a name="ln1222">	settimer(xdisplocsubopt);</a>
<a name="ln1223">	subpointer[SB_LEN()] = '\0';</a>
<a name="ln1224">	(void)setenv(&quot;DISPLAY&quot;, (char *)subpointer, 1);</a>
<a name="ln1225">	break;</a>
<a name="ln1226">    }  /* end of case TELOPT_XDISPLOC */</a>
<a name="ln1227"> </a>
<a name="ln1228">#ifdef	TELOPT_NEW_ENVIRON</a>
<a name="ln1229">    case TELOPT_NEW_ENVIRON:</a>
<a name="ln1230">#endif</a>
<a name="ln1231">    case TELOPT_OLD_ENVIRON: {</a>
<a name="ln1232">	int c;</a>
<a name="ln1233">	char *cp, *varp, *valp;</a>
<a name="ln1234"> </a>
<a name="ln1235">	if (SB_EOF())</a>
<a name="ln1236">		return;</a>
<a name="ln1237">	c = SB_GET();</a>
<a name="ln1238">	if (c == TELQUAL_IS) {</a>
<a name="ln1239">		if (subchar == TELOPT_OLD_ENVIRON)</a>
<a name="ln1240">			settimer(oenvironsubopt);</a>
<a name="ln1241">		else</a>
<a name="ln1242">			settimer(environsubopt);</a>
<a name="ln1243">	} else if (c != TELQUAL_INFO) {</a>
<a name="ln1244">		return;</a>
<a name="ln1245">	}</a>
<a name="ln1246"> </a>
<a name="ln1247">#ifdef	TELOPT_NEW_ENVIRON</a>
<a name="ln1248">	if (subchar == TELOPT_NEW_ENVIRON) {</a>
<a name="ln1249">	    while (!SB_EOF()) {</a>
<a name="ln1250">		c = SB_GET();</a>
<a name="ln1251">		if ((c == NEW_ENV_VAR) || (c == ENV_USERVAR))</a>
<a name="ln1252">			break;</a>
<a name="ln1253">	    }</a>
<a name="ln1254">	} else</a>
<a name="ln1255">#endif</a>
<a name="ln1256">	{</a>
<a name="ln1257">#ifdef	ENV_HACK</a>
<a name="ln1258">	    /*</a>
<a name="ln1259">	     * We only want to do this if we haven't already decided</a>
<a name="ln1260">	     * whether or not the other side has its VALUE and VAR</a>
<a name="ln1261">	     * reversed.</a>
<a name="ln1262">	     */</a>
<a name="ln1263">	    if (env_ovar &lt; 0) {</a>
<a name="ln1264">		int last = -1;		/* invalid value */</a>
<a name="ln1265">		int empty = 0;</a>
<a name="ln1266">		int got_var = 0, got_value = 0, got_uservar = 0;</a>
<a name="ln1267"> </a>
<a name="ln1268">		/*</a>
<a name="ln1269">		 * The other side might have its VALUE and VAR values</a>
<a name="ln1270">		 * reversed.  To be interoperable, we need to determine</a>
<a name="ln1271">		 * which way it is.  If the first recognized character</a>
<a name="ln1272">		 * is a VAR or VALUE, then that will tell us what</a>
<a name="ln1273">		 * type of client it is.  If the fist recognized</a>
<a name="ln1274">		 * character is a USERVAR, then we continue scanning</a>
<a name="ln1275">		 * the suboption looking for two consecutive</a>
<a name="ln1276">		 * VAR or VALUE fields.  We should not get two</a>
<a name="ln1277">		 * consecutive VALUE fields, so finding two</a>
<a name="ln1278">		 * consecutive VALUE or VAR fields will tell us</a>
<a name="ln1279">		 * what the client is.</a>
<a name="ln1280">		 */</a>
<a name="ln1281">		SB_SAVE();</a>
<a name="ln1282">		while (!SB_EOF()) {</a>
<a name="ln1283">			c = SB_GET();</a>
<a name="ln1284">			switch(c) {</a>
<a name="ln1285">			case OLD_ENV_VAR:</a>
<a name="ln1286">				if (last &lt; 0 || last == OLD_ENV_VAR</a>
<a name="ln1287">				    || (empty &amp;&amp; (last == OLD_ENV_VALUE)))</a>
<a name="ln1288">					goto env_ovar_ok;</a>
<a name="ln1289">				got_var++;</a>
<a name="ln1290">				last = OLD_ENV_VAR;</a>
<a name="ln1291">				break;</a>
<a name="ln1292">			case OLD_ENV_VALUE:</a>
<a name="ln1293">				if (last &lt; 0 || last == OLD_ENV_VALUE</a>
<a name="ln1294">				    || (empty &amp;&amp; (last == OLD_ENV_VAR)))</a>
<a name="ln1295">					goto env_ovar_wrong;</a>
<a name="ln1296">				got_value++;</a>
<a name="ln1297">				last = OLD_ENV_VALUE;</a>
<a name="ln1298">				break;</a>
<a name="ln1299">			case ENV_USERVAR:</a>
<a name="ln1300">				/* count strings of USERVAR as one */</a>
<a name="ln1301">				if (last != ENV_USERVAR)</a>
<a name="ln1302">					got_uservar++;</a>
<a name="ln1303">				if (empty) {</a>
<a name="ln1304">					if (last == OLD_ENV_VALUE)</a>
<a name="ln1305">						goto env_ovar_ok;</a>
<a name="ln1306">					if (last == OLD_ENV_VAR)</a>
<a name="ln1307">						goto env_ovar_wrong;</a>
<a name="ln1308">				}</a>
<a name="ln1309">				last = ENV_USERVAR;</a>
<a name="ln1310">				break;</a>
<a name="ln1311">			case ENV_ESC:</a>
<a name="ln1312">				if (!SB_EOF())</a>
<a name="ln1313">					c = SB_GET();</a>
<a name="ln1314">				/* FALLTHROUGH */</a>
<a name="ln1315">			default:</a>
<a name="ln1316">				empty = 0;</a>
<a name="ln1317">				continue;</a>
<a name="ln1318">			}</a>
<a name="ln1319">			empty = 1;</a>
<a name="ln1320">		}</a>
<a name="ln1321">		if (empty) {</a>
<a name="ln1322">			if (last == OLD_ENV_VALUE)</a>
<a name="ln1323">				goto env_ovar_ok;</a>
<a name="ln1324">			if (last == OLD_ENV_VAR)</a>
<a name="ln1325">				goto env_ovar_wrong;</a>
<a name="ln1326">		}</a>
<a name="ln1327">		/*</a>
<a name="ln1328">		 * Ok, the first thing was a USERVAR, and there</a>
<a name="ln1329">		 * are not two consecutive VAR or VALUE commands,</a>
<a name="ln1330">		 * and none of the VAR or VALUE commands are empty.</a>
<a name="ln1331">		 * If the client has sent us a well-formed option,</a>
<a name="ln1332">		 * then the number of VALUEs received should always</a>
<a name="ln1333">		 * be less than or equal to the number of VARs and</a>
<a name="ln1334">		 * USERVARs received.</a>
<a name="ln1335">		 *</a>
<a name="ln1336">		 * If we got exactly as many VALUEs as VARs and</a>
<a name="ln1337">		 * USERVARs, the client has the same definitions.</a>
<a name="ln1338">		 *</a>
<a name="ln1339">		 * If we got exactly as many VARs as VALUEs and</a>
<a name="ln1340">		 * USERVARS, the client has reversed definitions.</a>
<a name="ln1341">		 */</a>
<a name="ln1342">		if (got_uservar + got_var == got_value) {</a>
<a name="ln1343">	    env_ovar_ok:</a>
<a name="ln1344">			env_ovar = OLD_ENV_VAR;</a>
<a name="ln1345">			env_ovalue = OLD_ENV_VALUE;</a>
<a name="ln1346">		} else if (got_uservar + got_value == got_var) {</a>
<a name="ln1347">	    env_ovar_wrong:</a>
<a name="ln1348">			env_ovar = OLD_ENV_VALUE;</a>
<a name="ln1349">			env_ovalue = OLD_ENV_VAR;</a>
<a name="ln1350">			DIAG(TD_OPTIONS,</a>
<a name="ln1351">			    output_data(&quot;ENVIRON VALUE and VAR are reversed!\r\n&quot;));</a>
<a name="ln1352"> </a>
<a name="ln1353">		}</a>
<a name="ln1354">	    }</a>
<a name="ln1355">	    SB_RESTORE();</a>
<a name="ln1356">#endif</a>
<a name="ln1357"> </a>
<a name="ln1358">	    while (!SB_EOF()) {</a>
<a name="ln1359">		c = SB_GET();</a>
<a name="ln1360">		if ((c == env_ovar) || (c == ENV_USERVAR))</a>
<a name="ln1361">			break;</a>
<a name="ln1362">	    }</a>
<a name="ln1363">	}</a>
<a name="ln1364"> </a>
<a name="ln1365">	if (SB_EOF())</a>
<a name="ln1366">		return;</a>
<a name="ln1367"> </a>
<a name="ln1368">	cp = varp = (char *)subpointer;</a>
<a name="ln1369">	valp = 0;</a>
<a name="ln1370"> </a>
<a name="ln1371">	while (!SB_EOF()) {</a>
<a name="ln1372">		c = SB_GET();</a>
<a name="ln1373">		if (subchar == TELOPT_OLD_ENVIRON) {</a>
<a name="ln1374">			if (c == env_ovar)</a>
<a name="ln1375">				c = NEW_ENV_VAR;</a>
<a name="ln1376">			else if (c == env_ovalue)</a>
<a name="ln1377">				c = NEW_ENV_VALUE;</a>
<a name="ln1378">		}</a>
<a name="ln1379">		switch (c) {</a>
<a name="ln1380"> </a>
<a name="ln1381">		case NEW_ENV_VALUE:</a>
<a name="ln1382">			*cp = '\0';</a>
<a name="ln1383">			cp = valp = (char *)subpointer;</a>
<a name="ln1384">			break;</a>
<a name="ln1385"> </a>
<a name="ln1386">		case NEW_ENV_VAR:</a>
<a name="ln1387">		case ENV_USERVAR:</a>
<a name="ln1388">			*cp = '\0';</a>
<a name="ln1389">			if (valp)</a>
<a name="ln1390">				(void)setenv(varp, valp, 1);</a>
<a name="ln1391">			else</a>
<a name="ln1392">				unsetenv(varp);</a>
<a name="ln1393">			cp = varp = (char *)subpointer;</a>
<a name="ln1394">			valp = 0;</a>
<a name="ln1395">			break;</a>
<a name="ln1396"> </a>
<a name="ln1397">		case ENV_ESC:</a>
<a name="ln1398">			if (SB_EOF())</a>
<a name="ln1399">				break;</a>
<a name="ln1400">			c = SB_GET();</a>
<a name="ln1401">			/* FALLTHROUGH */</a>
<a name="ln1402">		default:</a>
<a name="ln1403">			*cp++ = c;</a>
<a name="ln1404">			break;</a>
<a name="ln1405">		}</a>
<a name="ln1406">	}</a>
<a name="ln1407">	*cp = '\0';</a>
<a name="ln1408">	if (valp)</a>
<a name="ln1409">		(void)setenv(varp, valp, 1);</a>
<a name="ln1410">	else</a>
<a name="ln1411">		unsetenv(varp);</a>
<a name="ln1412">	break;</a>
<a name="ln1413">    }  /* end of case TELOPT_NEW_ENVIRON */</a>
<a name="ln1414">#ifdef	AUTHENTICATION</a>
<a name="ln1415">    case TELOPT_AUTHENTICATION:</a>
<a name="ln1416">	if (SB_EOF())</a>
<a name="ln1417">		break;</a>
<a name="ln1418">	switch(SB_GET()) {</a>
<a name="ln1419">	case TELQUAL_SEND:</a>
<a name="ln1420">	case TELQUAL_REPLY:</a>
<a name="ln1421">		/*</a>
<a name="ln1422">		 * These are sent by us and cannot be sent by</a>
<a name="ln1423">		 * the client.</a>
<a name="ln1424">		 */</a>
<a name="ln1425">		break;</a>
<a name="ln1426">	case TELQUAL_IS:</a>
<a name="ln1427">		auth_is(subpointer, SB_LEN());</a>
<a name="ln1428">		break;</a>
<a name="ln1429">	case TELQUAL_NAME:</a>
<a name="ln1430">		auth_name(subpointer, SB_LEN());</a>
<a name="ln1431">		break;</a>
<a name="ln1432">	}</a>
<a name="ln1433">	break;</a>
<a name="ln1434">#endif</a>
<a name="ln1435">#ifdef	ENCRYPTION</a>
<a name="ln1436">    case TELOPT_ENCRYPT:</a>
<a name="ln1437">	if (SB_EOF())</a>
<a name="ln1438">		break;</a>
<a name="ln1439">	switch(SB_GET()) {</a>
<a name="ln1440">	case ENCRYPT_SUPPORT:</a>
<a name="ln1441">		encrypt_support(subpointer, SB_LEN());</a>
<a name="ln1442">		break;</a>
<a name="ln1443">	case ENCRYPT_IS:</a>
<a name="ln1444">		encrypt_is(subpointer, SB_LEN());</a>
<a name="ln1445">		break;</a>
<a name="ln1446">	case ENCRYPT_REPLY:</a>
<a name="ln1447">		encrypt_reply(subpointer, SB_LEN());</a>
<a name="ln1448">		break;</a>
<a name="ln1449">	case ENCRYPT_START:</a>
<a name="ln1450">		encrypt_start(subpointer, SB_LEN());</a>
<a name="ln1451">		break;</a>
<a name="ln1452">	case ENCRYPT_END:</a>
<a name="ln1453">		encrypt_end();</a>
<a name="ln1454">		break;</a>
<a name="ln1455">	case ENCRYPT_REQSTART:</a>
<a name="ln1456">		encrypt_request_start(subpointer, SB_LEN());</a>
<a name="ln1457">		break;</a>
<a name="ln1458">	case ENCRYPT_REQEND:</a>
<a name="ln1459">		/*</a>
<a name="ln1460">		 * We can always send an REQEND so that we cannot</a>
<a name="ln1461">		 * get stuck encrypting.  We should only get this</a>
<a name="ln1462">		 * if we have been able to get in the correct mode</a>
<a name="ln1463">		 * anyhow.</a>
<a name="ln1464">		 */</a>
<a name="ln1465">		encrypt_request_end();</a>
<a name="ln1466">		break;</a>
<a name="ln1467">	case ENCRYPT_ENC_KEYID:</a>
<a name="ln1468">		encrypt_enc_keyid(subpointer, SB_LEN());</a>
<a name="ln1469">		break;</a>
<a name="ln1470">	case ENCRYPT_DEC_KEYID:</a>
<a name="ln1471">		encrypt_dec_keyid(subpointer, SB_LEN());</a>
<a name="ln1472">		break;</a>
<a name="ln1473">	default:</a>
<a name="ln1474">		break;</a>
<a name="ln1475">	}</a>
<a name="ln1476">	break;</a>
<a name="ln1477">#endif	/* ENCRYPTION */</a>
<a name="ln1478"> </a>
<a name="ln1479">    default:</a>
<a name="ln1480">	break;</a>
<a name="ln1481">    }  /* end of switch */</a>
<a name="ln1482"> </a>
<a name="ln1483">}  /* end of suboption */</a>
<a name="ln1484"> </a>
<a name="ln1485">static void</a>
<a name="ln1486">doclientstat(void)</a>
<a name="ln1487">{</a>
<a name="ln1488">	clientstat(TELOPT_LINEMODE, WILL, 0);</a>
<a name="ln1489">}</a>
<a name="ln1490"> </a>
<a name="ln1491">#define	ADD(c)	 *ncp++ = c</a>
<a name="ln1492">#define	ADD_DATA(c) { *ncp++ = c; if (c == SE || c == IAC) *ncp++ = c; }</a>
<a name="ln1493">void</a>
<a name="ln1494">send_status(void)</a>
<a name="ln1495">{</a>
<a name="ln1496">	unsigned char statusbuf[256];</a>
<a name="ln1497">	unsigned char *ncp;</a>
<a name="ln1498">	unsigned char i;</a>
<a name="ln1499"> </a>
<a name="ln1500">	ncp = statusbuf;</a>
<a name="ln1501"> </a>
<a name="ln1502">	netflush();	/* get rid of anything waiting to go out */</a>
<a name="ln1503"> </a>
<a name="ln1504">	ADD(IAC);</a>
<a name="ln1505">	ADD(SB);</a>
<a name="ln1506">	ADD(TELOPT_STATUS);</a>
<a name="ln1507">	ADD(TELQUAL_IS);</a>
<a name="ln1508"> </a>
<a name="ln1509">	/*</a>
<a name="ln1510">	 * We check the want_state rather than the current state,</a>
<a name="ln1511">	 * because if we received a DO/WILL for an option that we</a>
<a name="ln1512">	 * don't support, and the other side didn't send a DONT/WONT</a>
<a name="ln1513">	 * in response to our WONT/DONT, then the &quot;state&quot; will be</a>
<a name="ln1514">	 * WILL/DO, and the &quot;want_state&quot; will be WONT/DONT.  We</a>
<a name="ln1515">	 * need to go by the latter.</a>
<a name="ln1516">	 */</a>
<a name="ln1517">	for (i = 0; i &lt; (unsigned char)NTELOPTS; i++) {</a>
<a name="ln1518">		if (my_want_state_is_will(i)) {</a>
<a name="ln1519">			ADD(WILL);</a>
<a name="ln1520">			ADD_DATA(i);</a>
<a name="ln1521">			if (i == IAC)</a>
<a name="ln1522">				ADD(IAC);</a>
<a name="ln1523">		}</a>
<a name="ln1524">		if (his_want_state_is_will(i)) {</a>
<a name="ln1525">			ADD(DO);</a>
<a name="ln1526">			ADD_DATA(i);</a>
<a name="ln1527">			if (i == IAC)</a>
<a name="ln1528">				ADD(IAC);</a>
<a name="ln1529">		}</a>
<a name="ln1530">	}</a>
<a name="ln1531"> </a>
<a name="ln1532">	if (his_want_state_is_will(TELOPT_LFLOW)) {</a>
<a name="ln1533">		ADD(SB);</a>
<a name="ln1534">		ADD(TELOPT_LFLOW);</a>
<a name="ln1535">		if (flowmode) {</a>
<a name="ln1536">			ADD(LFLOW_ON);</a>
<a name="ln1537">		} else {</a>
<a name="ln1538">			ADD(LFLOW_OFF);</a>
<a name="ln1539">		}</a>
<a name="ln1540">		ADD(SE);</a>
<a name="ln1541"> </a>
<a name="ln1542">		if (restartany &gt;= 0) {</a>
<a name="ln1543">			ADD(SB);</a>
<a name="ln1544">			ADD(TELOPT_LFLOW);</a>
<a name="ln1545">			if (restartany) {</a>
<a name="ln1546">				ADD(LFLOW_RESTART_ANY);</a>
<a name="ln1547">			} else {</a>
<a name="ln1548">				ADD(LFLOW_RESTART_XON);</a>
<a name="ln1549">			}</a>
<a name="ln1550">			ADD(SE);</a>
<a name="ln1551">		}</a>
<a name="ln1552">	}</a>
<a name="ln1553"> </a>
<a name="ln1554">#ifdef	LINEMODE</a>
<a name="ln1555">	if (his_want_state_is_will(TELOPT_LINEMODE)) {</a>
<a name="ln1556">		unsigned char *cp, *cpe;</a>
<a name="ln1557">		int len;</a>
<a name="ln1558"> </a>
<a name="ln1559">		ADD(SB);</a>
<a name="ln1560">		ADD(TELOPT_LINEMODE);</a>
<a name="ln1561">		ADD(LM_MODE);</a>
<a name="ln1562">		ADD_DATA(editmode);</a>
<a name="ln1563">		ADD(SE);</a>
<a name="ln1564"> </a>
<a name="ln1565">		ADD(SB);</a>
<a name="ln1566">		ADD(TELOPT_LINEMODE);</a>
<a name="ln1567">		ADD(LM_SLC);</a>
<a name="ln1568">		start_slc(0);</a>
<a name="ln1569">		send_slc();</a>
<a name="ln1570">		len = end_slc(&amp;cp);</a>
<a name="ln1571">		for (cpe = cp + len; cp &lt; cpe; cp++)</a>
<a name="ln1572">			ADD_DATA(*cp);</a>
<a name="ln1573">		ADD(SE);</a>
<a name="ln1574">	}</a>
<a name="ln1575">#endif	/* LINEMODE */</a>
<a name="ln1576"> </a>
<a name="ln1577">	ADD(IAC);</a>
<a name="ln1578">	ADD(SE);</a>
<a name="ln1579"> </a>
<a name="ln1580">	output_datalen(statusbuf, ncp - statusbuf);</a>
<a name="ln1581">	netflush();	/* Send it on its way */</a>
<a name="ln1582"> </a>
<a name="ln1583">	DIAG(TD_OPTIONS,</a>
<a name="ln1584">		{printsub('&gt;', statusbuf, ncp - statusbuf); netflush();});</a>
<a name="ln1585">}</a>
<a name="ln1586"> </a>
<a name="ln1587">/*</a>
<a name="ln1588"> * This function appends data to nfrontp and advances nfrontp.</a>
<a name="ln1589"> * Returns the number of characters written altogether (the</a>
<a name="ln1590"> * buffer may have been flushed in the process).</a>
<a name="ln1591"> */</a>
<a name="ln1592"> </a>
<a name="ln1593">int</a>
<a name="ln1594">output_data(const char *format, ...)</a>
<a name="ln1595">{</a>
<a name="ln1596">	va_list args;</a>
<a name="ln1597">	int len;</a>
<a name="ln1598">	char *buf;</a>
<a name="ln1599"> </a>
<a name="ln1600">	va_start(args, format);</a>
<a name="ln1601">	if ((len = vasprintf(&amp;buf, format, args)) == -1)</a>
<a name="ln1602">		return -1;</a>
<a name="ln1603">	output_datalen(buf, len);</a>
<a name="ln1604">	va_end(args);</a>
<a name="ln1605">	free(buf);</a>
<a name="ln1606">	return (len);</a>
<a name="ln1607">}</a>
<a name="ln1608"> </a>
<a name="ln1609">void</a>
<a name="ln1610">output_datalen(const char *buf, int len)</a>
<a name="ln1611">{</a>
<a name="ln1612">	int remaining, copied;</a>
<a name="ln1613">	</a>
<a name="ln1614">	remaining = BUFSIZ - (nfrontp - netobuf);</a>
<a name="ln1615">	while (len &gt; 0) {</a>
<a name="ln1616">		/* Free up enough space if the room is too low*/</a>
<a name="ln1617">		if ((len &gt; BUFSIZ ? BUFSIZ : len) &gt; remaining) {</a>
<a name="ln1618">			netflush();</a>
<a name="ln1619">			remaining = BUFSIZ - (nfrontp - netobuf);</a>
<a name="ln1620">		}</a>
<a name="ln1621"> </a>
<a name="ln1622">		/* Copy out as much as will fit */</a>
<a name="ln1623">		copied = remaining &gt; len ? len : remaining;</a>
<a name="ln1624">		memmove(nfrontp, buf, copied);</a>
<a name="ln1625">		nfrontp += copied;</a>
<a name="ln1626">		len -= copied;</a>
<a name="ln1627">		remaining -= copied;</a>
<a name="ln1628">		buf += copied;</a>
<a name="ln1629">	}</a>
<a name="ln1630">	return;</a>
<a name="ln1631">}</a>

</code></pre>
<div class="balloon" rel="1521"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'i == 255' is always false.</p></div>
<div class="balloon" rel="1527"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'i == 255' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
