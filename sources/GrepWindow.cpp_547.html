
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>GrepWindow.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright (c) 1998-2007 Matthijs Hollemans</a>
<a name="ln3"> * All rights reserved. Distributed under the terms of the MIT License.</a>
<a name="ln4"> */</a>
<a name="ln5">#include &quot;GrepWindow.h&quot;</a>
<a name="ln6"> </a>
<a name="ln7">#include &lt;ctype.h&gt;</a>
<a name="ln8">#include &lt;errno.h&gt;</a>
<a name="ln9">#include &lt;new&gt;</a>
<a name="ln10">#include &lt;stdio.h&gt;</a>
<a name="ln11">#include &lt;stdlib.h&gt;</a>
<a name="ln12">#include &lt;string.h&gt;</a>
<a name="ln13">#include &lt;unistd.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;Application.h&gt;</a>
<a name="ln16">#include &lt;AppFileInfo.h&gt;</a>
<a name="ln17">#include &lt;Alert.h&gt;</a>
<a name="ln18">#include &lt;Clipboard.h&gt;</a>
<a name="ln19">#include &lt;LayoutBuilder.h&gt;</a>
<a name="ln20">#include &lt;MessageRunner.h&gt;</a>
<a name="ln21">#include &lt;MimeType.h&gt;</a>
<a name="ln22">#include &lt;Path.h&gt;</a>
<a name="ln23">#include &lt;PathMonitor.h&gt;</a>
<a name="ln24">#include &lt;Roster.h&gt;</a>
<a name="ln25">#include &lt;SpaceLayoutItem.h&gt;</a>
<a name="ln26">#include &lt;String.h&gt;</a>
<a name="ln27">#include &lt;UTF8.h&gt;</a>
<a name="ln28"> </a>
<a name="ln29">#include &quot;ChangesIterator.h&quot;</a>
<a name="ln30">#include &quot;GlobalDefs.h&quot;</a>
<a name="ln31">#include &quot;Grepper.h&quot;</a>
<a name="ln32">#include &quot;InitialIterator.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln35">#define B_TRANSLATION_CONTEXT &quot;GrepWindow&quot;</a>
<a name="ln36"> </a>
<a name="ln37"> </a>
<a name="ln38">using std::nothrow;</a>
<a name="ln39"> </a>
<a name="ln40">static const bigtime_t kChangesPulseInterval = 150000;</a>
<a name="ln41"> </a>
<a name="ln42">#define TRACE_NODE_MONITORING</a>
<a name="ln43">#ifdef TRACE_NODE_MONITORING</a>
<a name="ln44"># define TRACE_NM(x...) printf(x)</a>
<a name="ln45">#else</a>
<a name="ln46"># define TRACE_NM(x...)</a>
<a name="ln47">#endif</a>
<a name="ln48"> </a>
<a name="ln49">//#define TRACE_FUNCTIONS</a>
<a name="ln50">#ifdef TRACE_FUNCTIONS</a>
<a name="ln51">	class FunctionTracer {</a>
<a name="ln52">	public:</a>
<a name="ln53">		FunctionTracer(const char* functionName)</a>
<a name="ln54">			: fName(functionName)</a>
<a name="ln55">		{</a>
<a name="ln56">			printf(&quot;%s - enter\n&quot;, fName.String());</a>
<a name="ln57">		}</a>
<a name="ln58">		~FunctionTracer()</a>
<a name="ln59">		{</a>
<a name="ln60">			printf(&quot;%s - exit\n&quot;, fName.String());</a>
<a name="ln61">		}</a>
<a name="ln62">	private:</a>
<a name="ln63">		BString	fName;</a>
<a name="ln64">	};</a>
<a name="ln65"># define CALLED()	FunctionTracer functionTracer(__PRETTY_FUNCTION__)</a>
<a name="ln66">#else</a>
<a name="ln67"># define CALLED()</a>
<a name="ln68">#endif // TRACE_FUNCTIONS</a>
<a name="ln69"> </a>
<a name="ln70"> </a>
<a name="ln71">GrepWindow::GrepWindow(BMessage* message)</a>
<a name="ln72">	: BWindow(BRect(0, 0, 525, 430), NULL, B_DOCUMENT_WINDOW,</a>
<a name="ln73">		B_AUTO_UPDATE_SIZE_LIMITS),</a>
<a name="ln74">	fSearchText(NULL),</a>
<a name="ln75">	fSearchResults(NULL),</a>
<a name="ln76">	fMenuBar(NULL),</a>
<a name="ln77">	fFileMenu(NULL),</a>
<a name="ln78">	fNew(NULL),</a>
<a name="ln79">	fOpen(NULL),</a>
<a name="ln80">	fClose(NULL),</a>
<a name="ln81">	fQuit(NULL),</a>
<a name="ln82">	fActionMenu(NULL),</a>
<a name="ln83">	fSelectAll(NULL),</a>
<a name="ln84">	fSearch(NULL),</a>
<a name="ln85">	fTrimSelection(NULL),</a>
<a name="ln86">	fCopyText(NULL),</a>
<a name="ln87">	fSelectInTracker(NULL),</a>
<a name="ln88">	fOpenSelection(NULL),</a>
<a name="ln89">	fPreferencesMenu(NULL),</a>
<a name="ln90">	fRecurseLinks(NULL),</a>
<a name="ln91">	fRecurseDirs(NULL),</a>
<a name="ln92">	fSkipDotDirs(NULL),</a>
<a name="ln93">	fCaseSensitive(NULL),</a>
<a name="ln94">	fRegularExpression(NULL),</a>
<a name="ln95">	fTextOnly(NULL),</a>
<a name="ln96">	fInvokeEditor(NULL),</a>
<a name="ln97">	fHistoryMenu(NULL),</a>
<a name="ln98">	fEncodingMenu(NULL),</a>
<a name="ln99">	fUTF8(NULL),</a>
<a name="ln100">	fShiftJIS(NULL),</a>
<a name="ln101">	fEUC(NULL),</a>
<a name="ln102">	fJIS(NULL),</a>
<a name="ln103"> </a>
<a name="ln104">	fShowLinesCheckbox(NULL),</a>
<a name="ln105">	fButton(NULL),</a>
<a name="ln106"> </a>
<a name="ln107">	fGrepper(NULL),</a>
<a name="ln108">	fOldPattern(&quot;&quot;),</a>
<a name="ln109">	fModel(new (nothrow) Model()),</a>
<a name="ln110">	fLastNodeMonitorEvent(system_time()),</a>
<a name="ln111">	fChangesIterator(NULL),</a>
<a name="ln112">	fChangesPulse(NULL),</a>
<a name="ln113"> </a>
<a name="ln114">	fFilePanel(NULL)</a>
<a name="ln115">{</a>
<a name="ln116">	if (fModel == NULL)</a>
<a name="ln117">		return;</a>
<a name="ln118"> </a>
<a name="ln119">	entry_ref directory;</a>
<a name="ln120">	_InitRefsReceived(&amp;directory, message);</a>
<a name="ln121"> </a>
<a name="ln122">	fModel-&gt;fDirectory = directory;</a>
<a name="ln123">	fModel-&gt;fSelectedFiles = *message;</a>
<a name="ln124"> </a>
<a name="ln125">	_SetWindowTitle();</a>
<a name="ln126">	_CreateMenus();</a>
<a name="ln127">	_CreateViews();</a>
<a name="ln128">	_LayoutViews();</a>
<a name="ln129">	_LoadPrefs();</a>
<a name="ln130">	_TileIfMultipleWindows();</a>
<a name="ln131"> </a>
<a name="ln132">	Show();</a>
<a name="ln133">}</a>
<a name="ln134"> </a>
<a name="ln135"> </a>
<a name="ln136">GrepWindow::~GrepWindow()</a>
<a name="ln137">{</a>
<a name="ln138">	delete fGrepper;</a>
<a name="ln139">	delete fModel;</a>
<a name="ln140">}</a>
<a name="ln141"> </a>
<a name="ln142"> </a>
<a name="ln143">void GrepWindow::FrameResized(float width, float height)</a>
<a name="ln144">{</a>
<a name="ln145">	BWindow::FrameResized(width, height);</a>
<a name="ln146">	fModel-&gt;fFrame = Frame();</a>
<a name="ln147">	_SavePrefs();</a>
<a name="ln148">}</a>
<a name="ln149"> </a>
<a name="ln150"> </a>
<a name="ln151">void GrepWindow::FrameMoved(BPoint origin)</a>
<a name="ln152">{</a>
<a name="ln153">	BWindow::FrameMoved(origin);</a>
<a name="ln154">	fModel-&gt;fFrame = Frame();</a>
<a name="ln155">	_SavePrefs();</a>
<a name="ln156">}</a>
<a name="ln157"> </a>
<a name="ln158"> </a>
<a name="ln159">void GrepWindow::MenusBeginning()</a>
<a name="ln160">{</a>
<a name="ln161">	fModel-&gt;FillHistoryMenu(fHistoryMenu);</a>
<a name="ln162">	BWindow::MenusBeginning();</a>
<a name="ln163">}</a>
<a name="ln164"> </a>
<a name="ln165"> </a>
<a name="ln166">void GrepWindow::MenusEnded()</a>
<a name="ln167">{</a>
<a name="ln168">	for (int32 t = fHistoryMenu-&gt;CountItems(); t &gt; 0; --t)</a>
<a name="ln169">		delete fHistoryMenu-&gt;RemoveItem(t - 1);</a>
<a name="ln170"> </a>
<a name="ln171">	BWindow::MenusEnded();</a>
<a name="ln172">}</a>
<a name="ln173"> </a>
<a name="ln174"> </a>
<a name="ln175">void GrepWindow::MessageReceived(BMessage* message)</a>
<a name="ln176">{</a>
<a name="ln177">	switch (message-&gt;what) {</a>
<a name="ln178">		case MSG_NEW_WINDOW:</a>
<a name="ln179">			_OnNewWindow();</a>
<a name="ln180">			break;</a>
<a name="ln181"> </a>
<a name="ln182">		case B_SIMPLE_DATA:</a>
<a name="ln183">			_OnFileDrop(message);</a>
<a name="ln184">			break;</a>
<a name="ln185"> </a>
<a name="ln186">		case MSG_OPEN_PANEL:</a>
<a name="ln187">			_OnOpenPanel();</a>
<a name="ln188">			break;</a>
<a name="ln189"> </a>
<a name="ln190">		case MSG_REFS_RECEIVED:</a>
<a name="ln191">			_OnRefsReceived(message);</a>
<a name="ln192">			break;</a>
<a name="ln193"> </a>
<a name="ln194">		case B_CANCEL:</a>
<a name="ln195">			_OnOpenPanelCancel();</a>
<a name="ln196">			break;</a>
<a name="ln197"> </a>
<a name="ln198">		case MSG_RECURSE_LINKS:</a>
<a name="ln199">			_OnRecurseLinks();</a>
<a name="ln200">			break;</a>
<a name="ln201"> </a>
<a name="ln202">		case MSG_RECURSE_DIRS:</a>
<a name="ln203">			_OnRecurseDirs();</a>
<a name="ln204">			break;</a>
<a name="ln205"> </a>
<a name="ln206">		case MSG_SKIP_DOT_DIRS:</a>
<a name="ln207">			_OnSkipDotDirs();</a>
<a name="ln208">			break;</a>
<a name="ln209"> </a>
<a name="ln210">		case MSG_CASE_SENSITIVE:</a>
<a name="ln211">			_OnCaseSensitive();</a>
<a name="ln212">			break;</a>
<a name="ln213"> </a>
<a name="ln214">		case MSG_REGULAR_EXPRESSION:</a>
<a name="ln215">			_OnRegularExpression();</a>
<a name="ln216">			break;</a>
<a name="ln217"> </a>
<a name="ln218">		case MSG_TEXT_ONLY:</a>
<a name="ln219">			_OnTextOnly();</a>
<a name="ln220">			break;</a>
<a name="ln221"> </a>
<a name="ln222">		case MSG_INVOKE_EDITOR:</a>
<a name="ln223">			_OnInvokeEditor();</a>
<a name="ln224">			break;</a>
<a name="ln225"> </a>
<a name="ln226">		case MSG_SEARCH_TEXT:</a>
<a name="ln227">			_OnSearchText();</a>
<a name="ln228">			break;</a>
<a name="ln229"> </a>
<a name="ln230">		case MSG_SELECT_HISTORY:</a>
<a name="ln231">			_OnHistoryItem(message);</a>
<a name="ln232">			break;</a>
<a name="ln233"> </a>
<a name="ln234">		case MSG_START_CANCEL:</a>
<a name="ln235">			_OnStartCancel();</a>
<a name="ln236">			break;</a>
<a name="ln237"> </a>
<a name="ln238">		case MSG_SEARCH_FINISHED:</a>
<a name="ln239">			_OnSearchFinished();</a>
<a name="ln240">			break;</a>
<a name="ln241"> </a>
<a name="ln242">		case MSG_START_NODE_MONITORING:</a>
<a name="ln243">			_StartNodeMonitoring();</a>
<a name="ln244">			break;</a>
<a name="ln245"> </a>
<a name="ln246">		case B_PATH_MONITOR:</a>
<a name="ln247">			_OnNodeMonitorEvent(message);</a>
<a name="ln248">			break;</a>
<a name="ln249"> </a>
<a name="ln250">		case MSG_NODE_MONITOR_PULSE:</a>
<a name="ln251">			_OnNodeMonitorPulse();</a>
<a name="ln252">			break;</a>
<a name="ln253"> </a>
<a name="ln254">		case MSG_REPORT_FILE_NAME:</a>
<a name="ln255">			_OnReportFileName(message);</a>
<a name="ln256">			break;</a>
<a name="ln257"> </a>
<a name="ln258">		case MSG_REPORT_RESULT:</a>
<a name="ln259">			_OnReportResult(message);</a>
<a name="ln260">			break;</a>
<a name="ln261"> </a>
<a name="ln262">		case MSG_REPORT_ERROR:</a>
<a name="ln263">			_OnReportError(message);</a>
<a name="ln264">			break;</a>
<a name="ln265"> </a>
<a name="ln266">		case MSG_SELECT_ALL:</a>
<a name="ln267">			_OnSelectAll(message);</a>
<a name="ln268">			break;</a>
<a name="ln269"> </a>
<a name="ln270">		case MSG_TRIM_SELECTION:</a>
<a name="ln271">			_OnTrimSelection();</a>
<a name="ln272">			break;</a>
<a name="ln273"> </a>
<a name="ln274">		case MSG_COPY_TEXT:</a>
<a name="ln275">			_OnCopyText();</a>
<a name="ln276">			break;</a>
<a name="ln277"> </a>
<a name="ln278">		case MSG_SELECT_IN_TRACKER:</a>
<a name="ln279">			_OnSelectInTracker();</a>
<a name="ln280">			break;</a>
<a name="ln281"> </a>
<a name="ln282">		case MSG_CHECKBOX_SHOW_LINES:</a>
<a name="ln283">			_OnCheckboxShowLines();</a>
<a name="ln284">			break;</a>
<a name="ln285"> </a>
<a name="ln286">		case MSG_OPEN_SELECTION:</a>
<a name="ln287">			// fall through</a>
<a name="ln288">		case MSG_INVOKE_ITEM:</a>
<a name="ln289">			_OnInvokeItem();</a>
<a name="ln290">			break;</a>
<a name="ln291"> </a>
<a name="ln292">		case MSG_QUIT_NOW:</a>
<a name="ln293">			_OnQuitNow();</a>
<a name="ln294">			break;</a>
<a name="ln295"> </a>
<a name="ln296">		case 'utf8':</a>
<a name="ln297">			fModel-&gt;fEncoding = 0;</a>
<a name="ln298">			break;</a>
<a name="ln299"> </a>
<a name="ln300">		case B_SJIS_CONVERSION:</a>
<a name="ln301">			fModel-&gt;fEncoding = B_SJIS_CONVERSION;</a>
<a name="ln302">			break;</a>
<a name="ln303"> </a>
<a name="ln304">		case B_EUC_CONVERSION:</a>
<a name="ln305">			fModel-&gt;fEncoding = B_EUC_CONVERSION;</a>
<a name="ln306">			break;</a>
<a name="ln307"> </a>
<a name="ln308">		case B_JIS_CONVERSION:</a>
<a name="ln309">			fModel-&gt;fEncoding = B_JIS_CONVERSION;</a>
<a name="ln310">			break;</a>
<a name="ln311"> </a>
<a name="ln312">		default:</a>
<a name="ln313">			BWindow::MessageReceived(message);</a>
<a name="ln314">			break;</a>
<a name="ln315">	}</a>
<a name="ln316">}</a>
<a name="ln317"> </a>
<a name="ln318"> </a>
<a name="ln319">void</a>
<a name="ln320">GrepWindow::Quit()</a>
<a name="ln321">{</a>
<a name="ln322">	CALLED();</a>
<a name="ln323"> </a>
<a name="ln324">	_StopNodeMonitoring();</a>
<a name="ln325">	_SavePrefs();</a>
<a name="ln326"> </a>
<a name="ln327">	// TODO: stippi: Looks like this could be done</a>
<a name="ln328">	// by maintaining a counter in GrepApp with the number of open</a>
<a name="ln329">	// grep windows... and just quit when it goes zero</a>
<a name="ln330">	if (be_app-&gt;Lock()) {</a>
<a name="ln331">		be_app-&gt;PostMessage(MSG_TRY_QUIT);</a>
<a name="ln332">		be_app-&gt;Unlock();</a>
<a name="ln333">		BWindow::Quit();</a>
<a name="ln334">	}</a>
<a name="ln335">}</a>
<a name="ln336"> </a>
<a name="ln337"> </a>
<a name="ln338">// #pragma mark -</a>
<a name="ln339"> </a>
<a name="ln340"> </a>
<a name="ln341">void</a>
<a name="ln342">GrepWindow::_InitRefsReceived(entry_ref* directory, BMessage* message)</a>
<a name="ln343">{</a>
<a name="ln344">	// HACK-HACK-HACK:</a>
<a name="ln345">	// If the user selected a single folder and invoked TextSearch on it,</a>
<a name="ln346">	// but recurse directories is switched off, TextSearch would do nothing.</a>
<a name="ln347">	// In that special case, we'd like it to recurse into that folder (but</a>
<a name="ln348">	// not go any deeper after that).</a>
<a name="ln349"> </a>
<a name="ln350">	type_code code;</a>
<a name="ln351">	int32 count;</a>
<a name="ln352">	message-&gt;GetInfo(&quot;refs&quot;, &amp;code, &amp;count);</a>
<a name="ln353"> </a>
<a name="ln354">	if (count == 0) {</a>
<a name="ln355">		if (message-&gt;FindRef(&quot;dir_ref&quot;, 0, directory) == B_OK)</a>
<a name="ln356">			message-&gt;MakeEmpty();</a>
<a name="ln357">	}</a>
<a name="ln358"> </a>
<a name="ln359">	if (count == 1) {</a>
<a name="ln360">		entry_ref ref;</a>
<a name="ln361">		if (message-&gt;FindRef(&quot;refs&quot;, 0, &amp;ref) == B_OK) {</a>
<a name="ln362">			BEntry entry(&amp;ref, true);</a>
<a name="ln363">			if (entry.IsDirectory()) {</a>
<a name="ln364">				// ok, special case, we use this folder as base directory</a>
<a name="ln365">				// and pretend nothing had been selected:</a>
<a name="ln366">				*directory = ref;</a>
<a name="ln367">				message-&gt;MakeEmpty();</a>
<a name="ln368">			}</a>
<a name="ln369">		}</a>
<a name="ln370">	}</a>
<a name="ln371">}</a>
<a name="ln372"> </a>
<a name="ln373"> </a>
<a name="ln374">void</a>
<a name="ln375">GrepWindow::_SetWindowTitle()</a>
<a name="ln376">{</a>
<a name="ln377">	BEntry entry(&amp;fModel-&gt;fDirectory, true);</a>
<a name="ln378">	BString title;</a>
<a name="ln379">	if (entry.InitCheck() == B_OK) {</a>
<a name="ln380">		BPath path;</a>
<a name="ln381">		if (entry.GetPath(&amp;path) == B_OK) {</a>
<a name="ln382">			if (fOldPattern.Length()) {</a>
<a name="ln383">				title = B_TRANSLATE(&quot;%appname% : %path% : %searchtext%&quot;);</a>
<a name="ln384">				title.ReplaceAll(&quot;%searchtext%&quot;, fOldPattern.String());</a>
<a name="ln385">			} else</a>
<a name="ln386">				title = B_TRANSLATE(&quot;%appname% : %path%&quot;);</a>
<a name="ln387"> </a>
<a name="ln388">			title.ReplaceAll(&quot;%appname%&quot;, B_TRANSLATE(APP_NAME));</a>
<a name="ln389">			title.ReplaceAll(&quot;%path%&quot;, path.Path());</a>
<a name="ln390">		}</a>
<a name="ln391">	}</a>
<a name="ln392"> </a>
<a name="ln393">	if (!title.Length())</a>
<a name="ln394">		title = B_TRANSLATE(APP_NAME);</a>
<a name="ln395"> </a>
<a name="ln396">	SetTitle(title.String());</a>
<a name="ln397">}</a>
<a name="ln398"> </a>
<a name="ln399"> </a>
<a name="ln400">void</a>
<a name="ln401">GrepWindow::_CreateMenus()</a>
<a name="ln402">{</a>
<a name="ln403">	fMenuBar = new BMenuBar(&quot;menubar&quot;);</a>
<a name="ln404"> </a>
<a name="ln405">	fFileMenu = new BMenu(B_TRANSLATE(&quot;File&quot;));</a>
<a name="ln406">	fActionMenu = new BMenu(B_TRANSLATE(&quot;Actions&quot;));</a>
<a name="ln407">	fPreferencesMenu = new BMenu(B_TRANSLATE(&quot;Settings&quot;));</a>
<a name="ln408">	fHistoryMenu = new BMenu(B_TRANSLATE(&quot;History&quot;));</a>
<a name="ln409">	fEncodingMenu = new BMenu(B_TRANSLATE(&quot;Encoding&quot;));</a>
<a name="ln410"> </a>
<a name="ln411">	fNew = new BMenuItem(</a>
<a name="ln412">		B_TRANSLATE(&quot;New window&quot;), new BMessage(MSG_NEW_WINDOW), 'N');</a>
<a name="ln413"> </a>
<a name="ln414">	fOpen = new BMenuItem(</a>
<a name="ln415">		B_TRANSLATE(&quot;Set target&quot; B_UTF8_ELLIPSIS), new BMessage(MSG_OPEN_PANEL), 'F');</a>
<a name="ln416"> </a>
<a name="ln417">	fClose = new BMenuItem(</a>
<a name="ln418">		B_TRANSLATE(&quot;Close&quot;), new BMessage(B_QUIT_REQUESTED), 'W');</a>
<a name="ln419"> </a>
<a name="ln420">	fQuit = new BMenuItem(</a>
<a name="ln421">		B_TRANSLATE(&quot;Quit&quot;), new BMessage(MSG_QUIT_NOW), 'Q');</a>
<a name="ln422"> </a>
<a name="ln423">	fSearch = new BMenuItem(</a>
<a name="ln424">		B_TRANSLATE(&quot;Search&quot;), new BMessage(MSG_START_CANCEL), 'S');</a>
<a name="ln425"> </a>
<a name="ln426">	fSelectAll = new BMenuItem(</a>
<a name="ln427">		B_TRANSLATE(&quot;Select all&quot;), new BMessage(MSG_SELECT_ALL), 'A');</a>
<a name="ln428"> </a>
<a name="ln429">	fTrimSelection = new BMenuItem(</a>
<a name="ln430">		B_TRANSLATE(&quot;Trim to selection&quot;), new BMessage(MSG_TRIM_SELECTION), 'T');</a>
<a name="ln431"> </a>
<a name="ln432">	fOpenSelection = new BMenuItem(</a>
<a name="ln433">		B_TRANSLATE(&quot;Open selection&quot;), new BMessage(MSG_OPEN_SELECTION), 'O');</a>
<a name="ln434"> </a>
<a name="ln435">	fSelectInTracker = new BMenuItem(</a>
<a name="ln436">		B_TRANSLATE(&quot;Show files in Tracker&quot;),</a>
<a name="ln437">			new BMessage(MSG_SELECT_IN_TRACKER), 'K');</a>
<a name="ln438"> </a>
<a name="ln439">	fCopyText = new BMenuItem(</a>
<a name="ln440">		B_TRANSLATE(&quot;Copy text to clipboard&quot;), new BMessage(MSG_COPY_TEXT), 'B');</a>
<a name="ln441"> </a>
<a name="ln442">	fRecurseLinks = new BMenuItem(</a>
<a name="ln443">		B_TRANSLATE(&quot;Follow symbolic links&quot;), new BMessage(MSG_RECURSE_LINKS));</a>
<a name="ln444"> </a>
<a name="ln445">	fRecurseDirs = new BMenuItem(</a>
<a name="ln446">		B_TRANSLATE(&quot;Look in sub-folders&quot;), new BMessage(MSG_RECURSE_DIRS));</a>
<a name="ln447"> </a>
<a name="ln448">	fSkipDotDirs = new BMenuItem(</a>
<a name="ln449">		B_TRANSLATE(&quot;Skip folders starting with a dot&quot;),</a>
<a name="ln450">			new BMessage(MSG_SKIP_DOT_DIRS));</a>
<a name="ln451"> </a>
<a name="ln452">	fCaseSensitive = new BMenuItem(</a>
<a name="ln453">		B_TRANSLATE(&quot;Case-sensitive&quot;), new BMessage(MSG_CASE_SENSITIVE));</a>
<a name="ln454"> </a>
<a name="ln455">	fRegularExpression = new BMenuItem(</a>
<a name="ln456">		B_TRANSLATE(&quot;Regular expression&quot;), new BMessage(MSG_REGULAR_EXPRESSION));</a>
<a name="ln457"> </a>
<a name="ln458">	fTextOnly = new BMenuItem(</a>
<a name="ln459">		B_TRANSLATE(&quot;Text files only&quot;), new BMessage(MSG_TEXT_ONLY));</a>
<a name="ln460"> </a>
<a name="ln461">	fInvokeEditor = new BMenuItem(</a>
<a name="ln462">		B_TRANSLATE(&quot;Open files in code editor&quot;), new BMessage(MSG_INVOKE_EDITOR));</a>
<a name="ln463"> </a>
<a name="ln464">	fUTF8 = new BMenuItem(&quot;UTF8&quot;, new BMessage('utf8'));</a>
<a name="ln465">	fShiftJIS = new BMenuItem(&quot;ShiftJIS&quot;, new BMessage(B_SJIS_CONVERSION));</a>
<a name="ln466">	fEUC = new BMenuItem(&quot;EUC&quot;, new BMessage(B_EUC_CONVERSION));</a>
<a name="ln467">	fJIS = new BMenuItem(&quot;JIS&quot;, new BMessage(B_JIS_CONVERSION));</a>
<a name="ln468"> </a>
<a name="ln469">	fFileMenu-&gt;AddItem(fNew);</a>
<a name="ln470">	fFileMenu-&gt;AddSeparatorItem();</a>
<a name="ln471">	fFileMenu-&gt;AddItem(fOpen);</a>
<a name="ln472">	fFileMenu-&gt;AddItem(fClose);</a>
<a name="ln473">	fFileMenu-&gt;AddSeparatorItem();</a>
<a name="ln474">	fFileMenu-&gt;AddItem(fQuit);</a>
<a name="ln475"> </a>
<a name="ln476">	fActionMenu-&gt;AddItem(fSearch);</a>
<a name="ln477">	fActionMenu-&gt;AddSeparatorItem();</a>
<a name="ln478">	fActionMenu-&gt;AddItem(fSelectAll);</a>
<a name="ln479">	fActionMenu-&gt;AddItem(fTrimSelection);</a>
<a name="ln480">	fActionMenu-&gt;AddSeparatorItem();</a>
<a name="ln481">	fActionMenu-&gt;AddItem(fOpenSelection);</a>
<a name="ln482">	fActionMenu-&gt;AddItem(fSelectInTracker);</a>
<a name="ln483">	fActionMenu-&gt;AddItem(fCopyText);</a>
<a name="ln484"> </a>
<a name="ln485">	fPreferencesMenu-&gt;AddItem(fRecurseLinks);</a>
<a name="ln486">	fPreferencesMenu-&gt;AddItem(fRecurseDirs);</a>
<a name="ln487">	fPreferencesMenu-&gt;AddItem(fSkipDotDirs);</a>
<a name="ln488">	fPreferencesMenu-&gt;AddItem(fCaseSensitive);</a>
<a name="ln489">	fPreferencesMenu-&gt;AddItem(fRegularExpression);</a>
<a name="ln490">	fPreferencesMenu-&gt;AddItem(fTextOnly);</a>
<a name="ln491">	fPreferencesMenu-&gt;AddItem(fInvokeEditor);</a>
<a name="ln492"> </a>
<a name="ln493">	fEncodingMenu-&gt;AddItem(fUTF8);</a>
<a name="ln494">	fEncodingMenu-&gt;AddItem(fShiftJIS);</a>
<a name="ln495">	fEncodingMenu-&gt;AddItem(fEUC);</a>
<a name="ln496">	fEncodingMenu-&gt;AddItem(fJIS);</a>
<a name="ln497"> </a>
<a name="ln498">//	fEncodingMenu-&gt;SetLabelFromMarked(true);</a>
<a name="ln499">		// Do we really want this ?</a>
<a name="ln500">	fEncodingMenu-&gt;SetRadioMode(true);</a>
<a name="ln501">	fEncodingMenu-&gt;ItemAt(0)-&gt;SetMarked(true);</a>
<a name="ln502"> </a>
<a name="ln503">	fMenuBar-&gt;AddItem(fFileMenu);</a>
<a name="ln504">	fMenuBar-&gt;AddItem(fActionMenu);</a>
<a name="ln505">	fMenuBar-&gt;AddItem(fPreferencesMenu);</a>
<a name="ln506">	fMenuBar-&gt;AddItem(fHistoryMenu);</a>
<a name="ln507">	fMenuBar-&gt;AddItem(fEncodingMenu);</a>
<a name="ln508"> </a>
<a name="ln509">	fSearch-&gt;SetEnabled(false);</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512"> </a>
<a name="ln513">void</a>
<a name="ln514">GrepWindow::_CreateViews()</a>
<a name="ln515">{</a>
<a name="ln516">	// The search pattern entry field does not send a message when</a>
<a name="ln517">	// &lt;Enter&gt; is pressed, because the &quot;Search/Cancel&quot; button already</a>
<a name="ln518">	// does this and we don't want to send the same message twice.</a>
<a name="ln519"> </a>
<a name="ln520">	fSearchText = new BTextControl(</a>
<a name="ln521">		&quot;SearchText&quot;, NULL, NULL, NULL,</a>
<a name="ln522">		B_WILL_DRAW | B_FULL_UPDATE_ON_RESIZE | B_NAVIGABLE);</a>
<a name="ln523"> </a>
<a name="ln524">	fSearchText-&gt;TextView()-&gt;SetMaxBytes(1000);</a>
<a name="ln525">	fSearchText-&gt;SetModificationMessage(new BMessage(MSG_SEARCH_TEXT));</a>
<a name="ln526"> </a>
<a name="ln527">	fButton = new BButton(</a>
<a name="ln528">		&quot;Button&quot;, B_TRANSLATE(&quot;Search&quot;),</a>
<a name="ln529">		new BMessage(MSG_START_CANCEL));</a>
<a name="ln530">	fButton-&gt;MakeDefault(true);</a>
<a name="ln531">	fButton-&gt;SetEnabled(false);</a>
<a name="ln532"> </a>
<a name="ln533">	fShowLinesCheckbox = new BCheckBox(</a>
<a name="ln534">		&quot;ShowLines&quot;, B_TRANSLATE(&quot;Show lines&quot;),</a>
<a name="ln535">		new BMessage(MSG_CHECKBOX_SHOW_LINES));</a>
<a name="ln536">	fShowLinesCheckbox-&gt;SetValue(B_CONTROL_ON);</a>
<a name="ln537"> </a>
<a name="ln538">	fSearchResults = new GrepListView();</a>
<a name="ln539">	fSearchResults-&gt;SetInvocationMessage(new BMessage(MSG_INVOKE_ITEM));</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542"> </a>
<a name="ln543">void</a>
<a name="ln544">GrepWindow::_LayoutViews()</a>
<a name="ln545">{</a>
<a name="ln546">	BScrollView* scroller = new BScrollView(</a>
<a name="ln547">		&quot;ScrollSearchResults&quot;, fSearchResults,</a>
<a name="ln548">		B_FULL_UPDATE_ON_RESIZE, true, true);</a>
<a name="ln549"> </a>
<a name="ln550">	BLayoutBuilder::Group&lt;&gt;(this, B_VERTICAL, 0)</a>
<a name="ln551">		.SetInsets(0, 0, -1, -1)</a>
<a name="ln552">		.Add(fMenuBar)</a>
<a name="ln553">		.AddGrid(B_USE_HALF_ITEM_INSETS)</a>
<a name="ln554">			.SetInsets(B_USE_WINDOW_SPACING, B_USE_WINDOW_SPACING,</a>
<a name="ln555">				B_USE_WINDOW_SPACING, B_USE_DEFAULT_SPACING)</a>
<a name="ln556">			.Add(fSearchText, 0, 0, 3)</a>
<a name="ln557">			.Add(fShowLinesCheckbox, 0, 1)</a>
<a name="ln558">			.Add(BSpaceLayoutItem::CreateGlue(), 1, 1)</a>
<a name="ln559">			.Add(fButton, 2, 1)</a>
<a name="ln560">		.End()</a>
<a name="ln561">		.AddGroup(B_VERTICAL, 0)</a>
<a name="ln562">			.SetInsets(-2, 0, -1, -1)</a>
<a name="ln563">			.Add(scroller)</a>
<a name="ln564">		.End()</a>
<a name="ln565">	.End();</a>
<a name="ln566"> </a>
<a name="ln567">	fSearchText-&gt;MakeFocus(true);</a>
<a name="ln568"> </a>
<a name="ln569">	SetKeyMenuBar(fMenuBar);</a>
<a name="ln570">}</a>
<a name="ln571"> </a>
<a name="ln572"> </a>
<a name="ln573">void</a>
<a name="ln574">GrepWindow::_TileIfMultipleWindows()</a>
<a name="ln575">{</a>
<a name="ln576">	if (be_app-&gt;Lock()) {</a>
<a name="ln577">		int32 windowCount = be_app-&gt;CountWindows();</a>
<a name="ln578">		be_app-&gt;Unlock();</a>
<a name="ln579"> </a>
<a name="ln580">		if (windowCount &gt; 1)</a>
<a name="ln581">			MoveBy(20, 20);</a>
<a name="ln582">	}</a>
<a name="ln583"> </a>
<a name="ln584">	BScreen screen(this);</a>
<a name="ln585">	BRect screenFrame = screen.Frame();</a>
<a name="ln586">	BRect windowFrame = Frame();</a>
<a name="ln587"> </a>
<a name="ln588">	if (windowFrame.left &gt; screenFrame.right</a>
<a name="ln589">		|| windowFrame.top &gt; screenFrame.bottom</a>
<a name="ln590">		|| windowFrame.right &lt; screenFrame.left</a>
<a name="ln591">		|| windowFrame.bottom &lt; screenFrame.top)</a>
<a name="ln592">		MoveTo(50, 50);</a>
<a name="ln593">}</a>
<a name="ln594"> </a>
<a name="ln595"> </a>
<a name="ln596">// #pragma mark -</a>
<a name="ln597"> </a>
<a name="ln598"> </a>
<a name="ln599">void</a>
<a name="ln600">GrepWindow::_LoadPrefs()</a>
<a name="ln601">{</a>
<a name="ln602">	Lock();</a>
<a name="ln603"> </a>
<a name="ln604">	fModel-&gt;LoadPrefs();</a>
<a name="ln605"> </a>
<a name="ln606">	fRecurseDirs-&gt;SetMarked(fModel-&gt;fRecurseDirs);</a>
<a name="ln607">	fRecurseLinks-&gt;SetMarked(fModel-&gt;fRecurseLinks);</a>
<a name="ln608">	fSkipDotDirs-&gt;SetMarked(fModel-&gt;fSkipDotDirs);</a>
<a name="ln609">	fCaseSensitive-&gt;SetMarked(fModel-&gt;fCaseSensitive);</a>
<a name="ln610">	fRegularExpression-&gt;SetMarked(fModel-&gt;fRegularExpression);</a>
<a name="ln611">	fTextOnly-&gt;SetMarked(fModel-&gt;fTextOnly);</a>
<a name="ln612">	fInvokeEditor-&gt;SetMarked(fModel-&gt;fInvokeEditor);</a>
<a name="ln613"> </a>
<a name="ln614">	fShowLinesCheckbox-&gt;SetValue(fModel-&gt;fShowLines);</a>
<a name="ln615"> </a>
<a name="ln616">	switch (fModel-&gt;fEncoding) {</a>
<a name="ln617">		case 0:</a>
<a name="ln618">			fUTF8-&gt;SetMarked(true);</a>
<a name="ln619">			break;</a>
<a name="ln620">		case B_SJIS_CONVERSION:</a>
<a name="ln621">			fShiftJIS-&gt;SetMarked(true);</a>
<a name="ln622">			break;</a>
<a name="ln623">		case B_EUC_CONVERSION:</a>
<a name="ln624">			fEUC-&gt;SetMarked(true);</a>
<a name="ln625">			break;</a>
<a name="ln626">		case B_JIS_CONVERSION:</a>
<a name="ln627">			fJIS-&gt;SetMarked(true);</a>
<a name="ln628">			break;</a>
<a name="ln629">		default:</a>
<a name="ln630">			printf(&quot;Woops. Bad fModel-&gt;fEncoding value.\n&quot;);</a>
<a name="ln631">			break;</a>
<a name="ln632">	}</a>
<a name="ln633"> </a>
<a name="ln634">	MoveTo(fModel-&gt;fFrame.left, fModel-&gt;fFrame.top);</a>
<a name="ln635">	ResizeTo(fModel-&gt;fFrame.Width(), fModel-&gt;fFrame.Height());</a>
<a name="ln636"> </a>
<a name="ln637">	Unlock();</a>
<a name="ln638">}</a>
<a name="ln639"> </a>
<a name="ln640"> </a>
<a name="ln641">void</a>
<a name="ln642">GrepWindow::_SavePrefs()</a>
<a name="ln643">{</a>
<a name="ln644">	fModel-&gt;SavePrefs();</a>
<a name="ln645">}</a>
<a name="ln646"> </a>
<a name="ln647"> </a>
<a name="ln648">void</a>
<a name="ln649">GrepWindow::_StartNodeMonitoring()</a>
<a name="ln650">{</a>
<a name="ln651">	CALLED();</a>
<a name="ln652"> </a>
<a name="ln653">	_StopNodeMonitoring();</a>
<a name="ln654"> </a>
<a name="ln655">	BMessenger messenger(this);</a>
<a name="ln656">	uint32 fileFlags = B_WATCH_NAME | B_WATCH_STAT | B_WATCH_ATTR;</a>
<a name="ln657"> </a>
<a name="ln658"> </a>
<a name="ln659">	// watch the top level folder only, rest should be done through filtering</a>
<a name="ln660">	// the node monitor notifications</a>
<a name="ln661">	BPath path(&amp;fModel-&gt;fDirectory);</a>
<a name="ln662">	if (path.InitCheck() == B_OK) {</a>
<a name="ln663">		TRACE_NM(&quot;start monitoring root folder: %s\n&quot;, path.Path());</a>
<a name="ln664">		BPrivate::BPathMonitor::StartWatching(path.Path(),</a>
<a name="ln665">			fileFlags | B_WATCH_RECURSIVELY | B_WATCH_FILES_ONLY, messenger);</a>
<a name="ln666">	}</a>
<a name="ln667"> </a>
<a name="ln668">	if (fChangesPulse == NULL) {</a>
<a name="ln669">		BMessage message(MSG_NODE_MONITOR_PULSE);</a>
<a name="ln670">		fChangesPulse = new BMessageRunner(BMessenger(this), &amp;message,</a>
<a name="ln671">			kChangesPulseInterval);</a>
<a name="ln672">	}</a>
<a name="ln673">}</a>
<a name="ln674"> </a>
<a name="ln675"> </a>
<a name="ln676">void</a>
<a name="ln677">GrepWindow::_StopNodeMonitoring()</a>
<a name="ln678">{</a>
<a name="ln679">	if (fChangesPulse == NULL)</a>
<a name="ln680">		return;</a>
<a name="ln681"> </a>
<a name="ln682">	CALLED();</a>
<a name="ln683"> </a>
<a name="ln684">	BPrivate::BPathMonitor::StopWatching(BMessenger(this));</a>
<a name="ln685">	delete fChangesIterator;</a>
<a name="ln686">	fChangesIterator = NULL;</a>
<a name="ln687">	delete fChangesPulse;</a>
<a name="ln688">	fChangesPulse = NULL;</a>
<a name="ln689">}</a>
<a name="ln690"> </a>
<a name="ln691"> </a>
<a name="ln692">// #pragma mark - events</a>
<a name="ln693"> </a>
<a name="ln694"> </a>
<a name="ln695">void</a>
<a name="ln696">GrepWindow::_OnStartCancel()</a>
<a name="ln697">{</a>
<a name="ln698">	CALLED();</a>
<a name="ln699"> </a>
<a name="ln700">	_StopNodeMonitoring();</a>
<a name="ln701"> </a>
<a name="ln702">	if (fModel-&gt;fState == STATE_IDLE) {</a>
<a name="ln703">		fSearchResults-&gt;MakeEmpty();</a>
<a name="ln704"> </a>
<a name="ln705">		if (fSearchText-&gt;TextView()-&gt;TextLength() == 0)</a>
<a name="ln706">			return;</a>
<a name="ln707"> </a>
<a name="ln708">		fModel-&gt;fState = STATE_SEARCH;</a>
<a name="ln709"> </a>
<a name="ln710">		fModel-&gt;AddToHistory(fSearchText-&gt;Text());</a>
<a name="ln711"> </a>
<a name="ln712">		// From now on, we don't want to be notified when the</a>
<a name="ln713">		// search pattern changes, because the control will be</a>
<a name="ln714">		// displaying the names of the files we are grepping.</a>
<a name="ln715"> </a>
<a name="ln716">		fSearchText-&gt;SetModificationMessage(NULL);</a>
<a name="ln717"> </a>
<a name="ln718">		fFileMenu-&gt;SetEnabled(false);</a>
<a name="ln719">		fActionMenu-&gt;SetEnabled(false);</a>
<a name="ln720">		fPreferencesMenu-&gt;SetEnabled(false);</a>
<a name="ln721">		fHistoryMenu-&gt;SetEnabled(false);</a>
<a name="ln722">		fEncodingMenu-&gt;SetEnabled(false);</a>
<a name="ln723"> </a>
<a name="ln724">		fSearchText-&gt;SetEnabled(false);</a>
<a name="ln725"> </a>
<a name="ln726">		fButton-&gt;MakeFocus(true);</a>
<a name="ln727">		fButton-&gt;SetLabel(B_TRANSLATE(&quot;Cancel&quot;));</a>
<a name="ln728"> </a>
<a name="ln729">		fSearch-&gt;SetEnabled(false);</a>
<a name="ln730"> </a>
<a name="ln731">		// We need to remember the search pattern, because during</a>
<a name="ln732">		// the grepping, the text control's text will be replaced</a>
<a name="ln733">		// by the name of the file that's currently being grepped.</a>
<a name="ln734">		// When the grepping finishes, we need to restore the old</a>
<a name="ln735">		// search pattern.</a>
<a name="ln736"> </a>
<a name="ln737">		fOldPattern = fSearchText-&gt;Text();</a>
<a name="ln738"> </a>
<a name="ln739">		_SetWindowTitle();</a>
<a name="ln740"> </a>
<a name="ln741">		FileIterator* iterator = new (nothrow) InitialIterator(fModel);</a>
<a name="ln742">		fGrepper = new (nothrow) Grepper(fOldPattern.String(), fModel,</a>
<a name="ln743">			this, iterator);</a>
<a name="ln744">		if (fGrepper != NULL &amp;&amp; fGrepper-&gt;IsValid())</a>
<a name="ln745">			fGrepper-&gt;Start();</a>
<a name="ln746">		else {</a>
<a name="ln747">			// roll back in case of problems</a>
<a name="ln748">			if (fGrepper == NULL)</a>
<a name="ln749">				delete iterator;</a>
<a name="ln750">			else {</a>
<a name="ln751">				// Grepper owns iterator</a>
<a name="ln752">				delete fGrepper;</a>
<a name="ln753">				fGrepper = NULL;</a>
<a name="ln754">			}</a>
<a name="ln755">			fModel-&gt;fState = STATE_IDLE;</a>
<a name="ln756">			// TODO: better notification to user</a>
<a name="ln757">			fprintf(stderr, &quot;Out of memory.\n&quot;);</a>
<a name="ln758">		}</a>
<a name="ln759">	} else if (fModel-&gt;fState == STATE_SEARCH) {</a>
<a name="ln760">		fModel-&gt;fState = STATE_CANCEL;</a>
<a name="ln761">		fGrepper-&gt;Cancel();</a>
<a name="ln762">	}</a>
<a name="ln763">}</a>
<a name="ln764"> </a>
<a name="ln765"> </a>
<a name="ln766">void</a>
<a name="ln767">GrepWindow::_OnSearchFinished()</a>
<a name="ln768">{</a>
<a name="ln769">	fModel-&gt;fState = STATE_IDLE;</a>
<a name="ln770"> </a>
<a name="ln771">	delete fGrepper;</a>
<a name="ln772">	fGrepper = NULL;</a>
<a name="ln773"> </a>
<a name="ln774">	fFileMenu-&gt;SetEnabled(true);</a>
<a name="ln775">	fActionMenu-&gt;SetEnabled(true);</a>
<a name="ln776">	fPreferencesMenu-&gt;SetEnabled(true);</a>
<a name="ln777">	fHistoryMenu-&gt;SetEnabled(true);</a>
<a name="ln778">	fEncodingMenu-&gt;SetEnabled(true);</a>
<a name="ln779"> </a>
<a name="ln780">	fButton-&gt;SetLabel(B_TRANSLATE(&quot;Search&quot;));</a>
<a name="ln781"> </a>
<a name="ln782">	fButton-&gt;SetEnabled(true);</a>
<a name="ln783">	fSearch-&gt;SetEnabled(true);</a>
<a name="ln784"> </a>
<a name="ln785">	fSearchText-&gt;SetEnabled(true);</a>
<a name="ln786">	fSearchText-&gt;MakeFocus(true);</a>
<a name="ln787">	fSearchText-&gt;SetText(fOldPattern.String());</a>
<a name="ln788">	fSearchText-&gt;TextView()-&gt;SelectAll();</a>
<a name="ln789">	fSearchText-&gt;SetModificationMessage(new BMessage(MSG_SEARCH_TEXT));</a>
<a name="ln790"> </a>
<a name="ln791">	PostMessage(MSG_START_NODE_MONITORING);</a>
<a name="ln792">}</a>
<a name="ln793"> </a>
<a name="ln794"> </a>
<a name="ln795">void</a>
<a name="ln796">GrepWindow::_OnNodeMonitorEvent(BMessage* message)</a>
<a name="ln797">{</a>
<a name="ln798">	int32 opCode;</a>
<a name="ln799">	if (message-&gt;FindInt32(&quot;opcode&quot;, &amp;opCode) != B_OK)</a>
<a name="ln800">		return;</a>
<a name="ln801"> </a>
<a name="ln802">	if (fChangesIterator == NULL) {</a>
<a name="ln803">		fChangesIterator = new (nothrow) ChangesIterator(fModel);</a>
<a name="ln804">		if (fChangesIterator == NULL || !fChangesIterator-&gt;IsValid()) {</a>
<a name="ln805">			delete fChangesIterator;</a>
<a name="ln806">			fChangesIterator = NULL;</a>
<a name="ln807">		}</a>
<a name="ln808">	}</a>
<a name="ln809"> </a>
<a name="ln810">	switch (opCode) {</a>
<a name="ln811">		case B_ENTRY_CREATED:</a>
<a name="ln812">		case B_ENTRY_REMOVED:</a>
<a name="ln813">		{</a>
<a name="ln814">			TRACE_NM(&quot;%s\n&quot;, opCode == B_ENTRY_CREATED ? &quot;B_ENTRY_CREATED&quot;</a>
<a name="ln815">				: &quot;B_ENTRY_REMOVED&quot;);</a>
<a name="ln816">			BString path;</a>
<a name="ln817">			if (message-&gt;FindString(&quot;path&quot;, &amp;path) == B_OK) {</a>
<a name="ln818">				if (opCode == B_ENTRY_CREATED) {</a>
<a name="ln819">					if (fChangesIterator != NULL)</a>
<a name="ln820">						fChangesIterator-&gt;EntryAdded(path.String());</a>
<a name="ln821">				} else {</a>
<a name="ln822">					// in order to remove temporary files</a>
<a name="ln823">					if (fChangesIterator != NULL)</a>
<a name="ln824">						fChangesIterator-&gt;EntryRemoved(path.String());</a>
<a name="ln825">					// remove from the list view already</a>
<a name="ln826">					BEntry entry(path.String());</a>
<a name="ln827">					entry_ref ref;</a>
<a name="ln828">					if (entry.GetRef(&amp;ref) == B_OK)</a>
<a name="ln829">						fSearchResults-&gt;RemoveResults(ref, true);</a>
<a name="ln830">				}</a>
<a name="ln831">			} else {</a>
<a name="ln832">				#ifdef TRACE_NODE_MONITORING</a>
<a name="ln833">					printf(&quot;incompatible message:\n&quot;);</a>
<a name="ln834">					message-&gt;PrintToStream();</a>
<a name="ln835">				#endif</a>
<a name="ln836">			}</a>
<a name="ln837">			TRACE_NM(&quot;path: %s\n&quot;, path.String());</a>
<a name="ln838">			break;</a>
<a name="ln839">		}</a>
<a name="ln840">		case B_ENTRY_MOVED:</a>
<a name="ln841">		{</a>
<a name="ln842">			TRACE_NM(&quot;B_ENTRY_MOVED\n&quot;);</a>
<a name="ln843"> </a>
<a name="ln844">			BString path;</a>
<a name="ln845">			if (message-&gt;FindString(&quot;path&quot;, &amp;path) != B_OK) {</a>
<a name="ln846">				#ifdef TRACE_NODE_MONITORING</a>
<a name="ln847">					printf(&quot;incompatible message:\n&quot;);</a>
<a name="ln848">					message-&gt;PrintToStream();</a>
<a name="ln849">				#endif</a>
<a name="ln850">				break;</a>
<a name="ln851">			}</a>
<a name="ln852"> </a>
<a name="ln853">			bool added;</a>
<a name="ln854">			if (message-&gt;FindBool(&quot;added&quot;, &amp;added) != B_OK)</a>
<a name="ln855">				added = false;</a>
<a name="ln856">			bool removed;</a>
<a name="ln857">			if (message-&gt;FindBool(&quot;removed&quot;, &amp;removed) != B_OK)</a>
<a name="ln858">				removed = false;</a>
<a name="ln859"> </a>
<a name="ln860">			if (added) {</a>
<a name="ln861">				// new files</a>
<a name="ln862">			} else if (removed) {</a>
<a name="ln863">				// remove files</a>
<a name="ln864">			} else {</a>
<a name="ln865">				// files changed location, but are still within the search</a>
<a name="ln866">				// path!</a>
<a name="ln867">				BEntry entry(path.String());</a>
<a name="ln868">				entry_ref ref;</a>
<a name="ln869">				if (entry.GetRef(&amp;ref) == B_OK) {</a>
<a name="ln870">					int32 index;</a>
<a name="ln871">					ResultItem* item = fSearchResults-&gt;FindItem(ref, &amp;index);</a>
<a name="ln872">					if (item != NULL) {</a>
<a name="ln873">						item-&gt;SetText(path.String());</a>
<a name="ln874">						// take care of invalidation, the index is currently</a>
<a name="ln875">						// the full list index, but needs to be the visible</a>
<a name="ln876">						// items index for this</a>
<a name="ln877">						index = fSearchResults-&gt;IndexOf(item);</a>
<a name="ln878">						fSearchResults-&gt;InvalidateItem(index);</a>
<a name="ln879">					}</a>
<a name="ln880">				}</a>
<a name="ln881">			}</a>
<a name="ln882">			break;</a>
<a name="ln883">		}</a>
<a name="ln884">		case B_STAT_CHANGED:</a>
<a name="ln885">		case B_ATTR_CHANGED:</a>
<a name="ln886">		{</a>
<a name="ln887">			TRACE_NM(&quot;%s\n&quot;, opCode == B_STAT_CHANGED ? &quot;B_STAT_CHANGED&quot;</a>
<a name="ln888">				: &quot;B_ATTR_CHANGED&quot;);</a>
<a name="ln889">			// For directly watched files, the path will include the</a>
<a name="ln890">			// name. When the event occurs for a file in a watched directory,</a>
<a name="ln891">			// the message will have an extra name field for the respective</a>
<a name="ln892">			// file.</a>
<a name="ln893">			BString path;</a>
<a name="ln894">			if (message-&gt;FindString(&quot;path&quot;, &amp;path) == B_OK) {</a>
<a name="ln895">				if (fChangesIterator != NULL)</a>
<a name="ln896">					fChangesIterator-&gt;EntryChanged(path.String());</a>
<a name="ln897">			} else {</a>
<a name="ln898">				#ifdef TRACE_NODE_MONITORING</a>
<a name="ln899">					printf(&quot;incompatible message:\n&quot;);</a>
<a name="ln900">					message-&gt;PrintToStream();</a>
<a name="ln901">				#endif</a>
<a name="ln902">			}</a>
<a name="ln903">			TRACE_NM(&quot;path: %s\n&quot;, path.String());</a>
<a name="ln904">// message-&gt;PrintToStream();</a>
<a name="ln905">			break;</a>
<a name="ln906">		}</a>
<a name="ln907"> </a>
<a name="ln908">		default:</a>
<a name="ln909">			TRACE_NM(&quot;unkown op code\n&quot;);</a>
<a name="ln910">			break;</a>
<a name="ln911">	}</a>
<a name="ln912"> </a>
<a name="ln913">	fLastNodeMonitorEvent = system_time();</a>
<a name="ln914">}</a>
<a name="ln915"> </a>
<a name="ln916"> </a>
<a name="ln917">void</a>
<a name="ln918">GrepWindow::_OnNodeMonitorPulse()</a>
<a name="ln919">{</a>
<a name="ln920">	if (fChangesIterator == NULL || fChangesIterator-&gt;IsEmpty())</a>
<a name="ln921">		return;</a>
<a name="ln922"> </a>
<a name="ln923">	if (system_time() - fLastNodeMonitorEvent &lt; kChangesPulseInterval) {</a>
<a name="ln924">		// wait for things to settle down before running the search for changes</a>
<a name="ln925">		return;</a>
<a name="ln926">	}</a>
<a name="ln927"> </a>
<a name="ln928">	if (fModel-&gt;fState != STATE_IDLE) {</a>
<a name="ln929">		// An update or search is still in progress. New node monitor messages</a>
<a name="ln930">		// may arrive while an update is still running. They should not arrive</a>
<a name="ln931">		// during a regular search, but we want to be prepared for that anyways</a>
<a name="ln932">		// and check != STATE_IDLE.</a>
<a name="ln933">		return;</a>
<a name="ln934">	}</a>
<a name="ln935"> </a>
<a name="ln936">	fOldPattern = fSearchText-&gt;Text();</a>
<a name="ln937"> </a>
<a name="ln938">#ifdef TRACE_NODE_MONITORING</a>
<a name="ln939">	fChangesIterator-&gt;PrintToStream();</a>
<a name="ln940">#endif</a>
<a name="ln941"> </a>
<a name="ln942">	fGrepper = new (nothrow) Grepper(fOldPattern.String(), fModel,</a>
<a name="ln943">		this, fChangesIterator);</a>
<a name="ln944">	if (fGrepper != NULL &amp;&amp; fGrepper-&gt;IsValid()) {</a>
<a name="ln945">		fGrepper-&gt;Start();</a>
<a name="ln946">		fChangesIterator = NULL;</a>
<a name="ln947">		fModel-&gt;fState = STATE_UPDATE;</a>
<a name="ln948">	} else {</a>
<a name="ln949">		// roll back in case of problems</a>
<a name="ln950">		if (fGrepper == NULL)</a>
<a name="ln951">			delete fChangesIterator;</a>
<a name="ln952">		else {</a>
<a name="ln953">			// Grepper owns iterator</a>
<a name="ln954">			delete fGrepper;</a>
<a name="ln955">			fGrepper = NULL;</a>
<a name="ln956">		}</a>
<a name="ln957">		fprintf(stderr, &quot;Out of memory.\n&quot;);</a>
<a name="ln958">	}</a>
<a name="ln959">}</a>
<a name="ln960"> </a>
<a name="ln961"> </a>
<a name="ln962">void</a>
<a name="ln963">GrepWindow::_OnReportFileName(BMessage* message)</a>
<a name="ln964">{</a>
<a name="ln965">	if (fModel-&gt;fState != STATE_UPDATE) {</a>
<a name="ln966">		BString name = message-&gt;FindString(&quot;filename&quot;);</a>
<a name="ln967">		fSearchText-&gt;TruncateString(&amp;name, B_TRUNCATE_MIDDLE,</a>
<a name="ln968">			fSearchText-&gt;Bounds().Width() - 10);</a>
<a name="ln969"> </a>
<a name="ln970">		fSearchText-&gt;SetText(name);</a>
<a name="ln971">	}</a>
<a name="ln972">}</a>
<a name="ln973"> </a>
<a name="ln974"> </a>
<a name="ln975">void</a>
<a name="ln976">GrepWindow::_OnReportResult(BMessage* message)</a>
<a name="ln977">{</a>
<a name="ln978">	CALLED();</a>
<a name="ln979">	entry_ref ref;</a>
<a name="ln980">	if (message-&gt;FindRef(&quot;ref&quot;, &amp;ref) != B_OK)</a>
<a name="ln981">		return;</a>
<a name="ln982"> </a>
<a name="ln983">	type_code type;</a>
<a name="ln984">	int32 count;</a>
<a name="ln985">	message-&gt;GetInfo(&quot;text&quot;, &amp;type, &amp;count);</a>
<a name="ln986"> </a>
<a name="ln987">	BStringItem* item = NULL;</a>
<a name="ln988">	if (fModel-&gt;fState == STATE_UPDATE) {</a>
<a name="ln989">		// During updates because of node monitor events, negatives are</a>
<a name="ln990">		// also reported (count == 0).</a>
<a name="ln991">		item = fSearchResults-&gt;RemoveResults(ref, count == 0);</a>
<a name="ln992">	}</a>
<a name="ln993"> </a>
<a name="ln994">	if (count == 0)</a>
<a name="ln995">		return;</a>
<a name="ln996"> </a>
<a name="ln997">	if (item == NULL) {</a>
<a name="ln998">		item = new ResultItem(ref);</a>
<a name="ln999">		fSearchResults-&gt;AddItem(item);</a>
<a name="ln1000">		item-&gt;SetExpanded(fShowLinesCheckbox-&gt;Value() == 1);</a>
<a name="ln1001">	}</a>
<a name="ln1002"> </a>
<a name="ln1003">	const char* buf;</a>
<a name="ln1004">	while (message-&gt;FindString(&quot;text&quot;, --count, &amp;buf) == B_OK) {</a>
<a name="ln1005">		uchar* temp = (uchar*)strdup(buf);</a>
<a name="ln1006">		uchar* ptr = temp;</a>
<a name="ln1007"> </a>
<a name="ln1008">		while (true) {</a>
<a name="ln1009">			// replace all non-printable characters by spaces</a>
<a name="ln1010">			uchar c = *ptr;</a>
<a name="ln1011"> </a>
<a name="ln1012">			if (c == '\0')</a>
<a name="ln1013">				break;</a>
<a name="ln1014"> </a>
<a name="ln1015">			if (!(c &amp; 0x80) &amp;&amp; iscntrl(c))</a>
<a name="ln1016">				*ptr = ' ';</a>
<a name="ln1017"> </a>
<a name="ln1018">			++ptr;</a>
<a name="ln1019">		}</a>
<a name="ln1020"> </a>
<a name="ln1021">		fSearchResults-&gt;AddUnder(new BStringItem((const char*)temp), item);</a>
<a name="ln1022"> </a>
<a name="ln1023">		free(temp);</a>
<a name="ln1024">	}</a>
<a name="ln1025">}</a>
<a name="ln1026"> </a>
<a name="ln1027"> </a>
<a name="ln1028">void</a>
<a name="ln1029">GrepWindow::_OnReportError(BMessage* message)</a>
<a name="ln1030">{</a>
<a name="ln1031">	const char* buf;</a>
<a name="ln1032">	if (message-&gt;FindString(&quot;error&quot;, &amp;buf) == B_OK)</a>
<a name="ln1033">		fSearchResults-&gt;AddItem(new BStringItem(buf));</a>
<a name="ln1034">}</a>
<a name="ln1035"> </a>
<a name="ln1036"> </a>
<a name="ln1037">void</a>
<a name="ln1038">GrepWindow::_OnRecurseLinks()</a>
<a name="ln1039">{</a>
<a name="ln1040">	fModel-&gt;fRecurseLinks = !fModel-&gt;fRecurseLinks;</a>
<a name="ln1041">	fRecurseLinks-&gt;SetMarked(fModel-&gt;fRecurseLinks);</a>
<a name="ln1042">	_ModelChanged();</a>
<a name="ln1043">}</a>
<a name="ln1044"> </a>
<a name="ln1045"> </a>
<a name="ln1046">void</a>
<a name="ln1047">GrepWindow::_OnRecurseDirs()</a>
<a name="ln1048">{</a>
<a name="ln1049">	fModel-&gt;fRecurseDirs = !fModel-&gt;fRecurseDirs;</a>
<a name="ln1050">	fRecurseDirs-&gt;SetMarked(fModel-&gt;fRecurseDirs);</a>
<a name="ln1051">	_ModelChanged();</a>
<a name="ln1052">}</a>
<a name="ln1053"> </a>
<a name="ln1054"> </a>
<a name="ln1055">void</a>
<a name="ln1056">GrepWindow::_OnSkipDotDirs()</a>
<a name="ln1057">{</a>
<a name="ln1058">	fModel-&gt;fSkipDotDirs = !fModel-&gt;fSkipDotDirs;</a>
<a name="ln1059">	fSkipDotDirs-&gt;SetMarked(fModel-&gt;fSkipDotDirs);</a>
<a name="ln1060">	_ModelChanged();</a>
<a name="ln1061">}</a>
<a name="ln1062"> </a>
<a name="ln1063"> </a>
<a name="ln1064">void</a>
<a name="ln1065">GrepWindow::_OnRegularExpression()</a>
<a name="ln1066">{</a>
<a name="ln1067">	fModel-&gt;fRegularExpression = !fModel-&gt;fRegularExpression;</a>
<a name="ln1068">	fRegularExpression-&gt;SetMarked(fModel-&gt;fRegularExpression);</a>
<a name="ln1069">	_ModelChanged();</a>
<a name="ln1070">}</a>
<a name="ln1071"> </a>
<a name="ln1072"> </a>
<a name="ln1073">void</a>
<a name="ln1074">GrepWindow::_OnCaseSensitive()</a>
<a name="ln1075">{</a>
<a name="ln1076">	fModel-&gt;fCaseSensitive = !fModel-&gt;fCaseSensitive;</a>
<a name="ln1077">	fCaseSensitive-&gt;SetMarked(fModel-&gt;fCaseSensitive);</a>
<a name="ln1078">	_ModelChanged();</a>
<a name="ln1079">}</a>
<a name="ln1080"> </a>
<a name="ln1081"> </a>
<a name="ln1082">void</a>
<a name="ln1083">GrepWindow::_OnTextOnly()</a>
<a name="ln1084">{</a>
<a name="ln1085">	fModel-&gt;fTextOnly = !fModel-&gt;fTextOnly;</a>
<a name="ln1086">	fTextOnly-&gt;SetMarked(fModel-&gt;fTextOnly);</a>
<a name="ln1087">	_ModelChanged();</a>
<a name="ln1088">}</a>
<a name="ln1089"> </a>
<a name="ln1090"> </a>
<a name="ln1091">void</a>
<a name="ln1092">GrepWindow::_OnInvokeEditor()</a>
<a name="ln1093">{</a>
<a name="ln1094">	fModel-&gt;fInvokeEditor = !fModel-&gt;fInvokeEditor;</a>
<a name="ln1095">	fInvokeEditor-&gt;SetMarked(fModel-&gt;fInvokeEditor);</a>
<a name="ln1096">	_SavePrefs();</a>
<a name="ln1097">}</a>
<a name="ln1098"> </a>
<a name="ln1099"> </a>
<a name="ln1100">void</a>
<a name="ln1101">GrepWindow::_OnCheckboxShowLines()</a>
<a name="ln1102">{</a>
<a name="ln1103">	// Selection in BOutlineListView in multiple selection mode</a>
<a name="ln1104">	// gets weird when collapsing. I've tried all sorts of things.</a>
<a name="ln1105">	// It seems impossible to make it behave just right.</a>
<a name="ln1106"> </a>
<a name="ln1107">	// Going from collapsed to expande mode, the superitems</a>
<a name="ln1108">	// keep their selection, the subitems don't (yet) have</a>
<a name="ln1109">	// a selection. This works as expected, AFAIK.</a>
<a name="ln1110"> </a>
<a name="ln1111">	// Going from expanded to collapsed mode, I would like</a>
<a name="ln1112">	// for a selected subitem (line) to select its superitem,</a>
<a name="ln1113">	// (its file) and the subitem be unselected.</a>
<a name="ln1114"> </a>
<a name="ln1115">	// I've successfully tried code patches that apply the</a>
<a name="ln1116">	// selection pattern that I want, but with weird effects</a>
<a name="ln1117">	// on subsequent manual selection.</a>
<a name="ln1118">	// Lines stay selected while the user tries to select</a>
<a name="ln1119">	// some other line. It just gets weird.</a>
<a name="ln1120"> </a>
<a name="ln1121">	// It's as though listItem-&gt;Select() and Deselect()</a>
<a name="ln1122">	// put the items in some semi-selected state.</a>
<a name="ln1123">	// Or maybe I've got it all wrong.</a>
<a name="ln1124"> </a>
<a name="ln1125">	// So, here's the plain basic collapse/expand.</a>
<a name="ln1126">	// I think it's the least bad of what's possible on BeOS R5,</a>
<a name="ln1127">	// but perhaps someone comes along with a patch of magic.</a>
<a name="ln1128"> </a>
<a name="ln1129">	fModel-&gt;fShowLines = (fShowLinesCheckbox-&gt;Value() == 1);</a>
<a name="ln1130"> </a>
<a name="ln1131">	int32 numItems = fSearchResults-&gt;FullListCountItems();</a>
<a name="ln1132">	for (int32 x = 0; x &lt; numItems; ++x) {</a>
<a name="ln1133">		BListItem* listItem = fSearchResults-&gt;FullListItemAt(x);</a>
<a name="ln1134">		if (listItem-&gt;OutlineLevel() == 0) {</a>
<a name="ln1135">			if (fModel-&gt;fShowLines) {</a>
<a name="ln1136">				if (!fSearchResults-&gt;IsExpanded(x))</a>
<a name="ln1137">					fSearchResults-&gt;Expand(listItem);</a>
<a name="ln1138">			} else {</a>
<a name="ln1139">				if (fSearchResults-&gt;IsExpanded(x))</a>
<a name="ln1140">					fSearchResults-&gt;Collapse(listItem);</a>
<a name="ln1141">			}</a>
<a name="ln1142">		}</a>
<a name="ln1143">	}</a>
<a name="ln1144"> </a>
<a name="ln1145">	fSearchResults-&gt;Invalidate();</a>
<a name="ln1146"> </a>
<a name="ln1147">	_SavePrefs();</a>
<a name="ln1148">}</a>
<a name="ln1149"> </a>
<a name="ln1150"> </a>
<a name="ln1151">void</a>
<a name="ln1152">GrepWindow::_OnInvokeItem()</a>
<a name="ln1153">{</a>
<a name="ln1154">	for (int32 selectionIndex = 0; ; selectionIndex++) {</a>
<a name="ln1155">		int32 itemIndex = fSearchResults-&gt;CurrentSelection(selectionIndex);</a>
<a name="ln1156">		BListItem* item = fSearchResults-&gt;ItemAt(itemIndex);</a>
<a name="ln1157">		if (item == NULL)</a>
<a name="ln1158">			break;</a>
<a name="ln1159"> </a>
<a name="ln1160">		int32 level = item-&gt;OutlineLevel();</a>
<a name="ln1161">		int32 lineNum = -1;</a>
<a name="ln1162"> </a>
<a name="ln1163">		// Get the line number.</a>
<a name="ln1164">		// only this level has line numbers</a>
<a name="ln1165">		if (level == 1) {</a>
<a name="ln1166">			BStringItem* str = dynamic_cast&lt;BStringItem*&gt;(item);</a>
<a name="ln1167">			if (str != NULL) {</a>
<a name="ln1168">				lineNum = atol(str-&gt;Text());</a>
<a name="ln1169">					// fortunately, atol knows when to stop the conversion</a>
<a name="ln1170">			}</a>
<a name="ln1171">		}</a>
<a name="ln1172"> </a>
<a name="ln1173">		// Get the top-most item and launch its entry_ref.</a>
<a name="ln1174">		while (level != 0) {</a>
<a name="ln1175">			item = fSearchResults-&gt;Superitem(item);</a>
<a name="ln1176">			if (item == NULL)</a>
<a name="ln1177">				break;</a>
<a name="ln1178">			level = item-&gt;OutlineLevel();</a>
<a name="ln1179">		}</a>
<a name="ln1180"> </a>
<a name="ln1181">		ResultItem* entry = dynamic_cast&lt;ResultItem*&gt;(item);</a>
<a name="ln1182">		if (entry != NULL) {</a>
<a name="ln1183">			if (fModel-&gt;fInvokeEditor &amp;&amp; _OpenInEditor(entry-&gt;ref, lineNum))</a>
<a name="ln1184">				return;</a>
<a name="ln1185"> </a>
<a name="ln1186">			// ask tracker to open it for us</a>
<a name="ln1187">			BMessenger target(TRACKER_SIGNATURE);</a>
<a name="ln1188">			BMessage message(B_REFS_RECEIVED);</a>
<a name="ln1189">			message.AddRef(&quot;refs&quot;, &amp;entry-&gt;ref);</a>
<a name="ln1190">			if (lineNum &gt; -1) {</a>
<a name="ln1191">				message.AddInt32(&quot;be:line&quot;, lineNum);</a>
<a name="ln1192">			}</a>
<a name="ln1193">			target.SendMessage(&amp;message);</a>
<a name="ln1194">		}</a>
<a name="ln1195">	}</a>
<a name="ln1196">}</a>
<a name="ln1197"> </a>
<a name="ln1198"> </a>
<a name="ln1199">void</a>
<a name="ln1200">GrepWindow::_OnSearchText()</a>
<a name="ln1201">{</a>
<a name="ln1202">	CALLED();</a>
<a name="ln1203"> </a>
<a name="ln1204">	bool enabled = fSearchText-&gt;TextView()-&gt;TextLength() != 0;</a>
<a name="ln1205">	fButton-&gt;SetEnabled(enabled);</a>
<a name="ln1206">	fSearch-&gt;SetEnabled(enabled);</a>
<a name="ln1207">	_StopNodeMonitoring();</a>
<a name="ln1208">}</a>
<a name="ln1209"> </a>
<a name="ln1210"> </a>
<a name="ln1211">void</a>
<a name="ln1212">GrepWindow::_OnHistoryItem(BMessage* message)</a>
<a name="ln1213">{</a>
<a name="ln1214">	const char* buf;</a>
<a name="ln1215">	if (message-&gt;FindString(&quot;text&quot;, &amp;buf) == B_OK)</a>
<a name="ln1216">		fSearchText-&gt;SetText(buf);</a>
<a name="ln1217">}</a>
<a name="ln1218"> </a>
<a name="ln1219"> </a>
<a name="ln1220">void</a>
<a name="ln1221">GrepWindow::_OnTrimSelection()</a>
<a name="ln1222">{</a>
<a name="ln1223">	if (fSearchResults-&gt;CurrentSelection() &lt; 0) {</a>
<a name="ln1224">		BString text;</a>
<a name="ln1225">		text &lt;&lt; B_TRANSLATE(&quot;Please select the files you wish to keep searching.&quot;);</a>
<a name="ln1226">		text &lt;&lt; &quot;\n&quot;;</a>
<a name="ln1227">		text &lt;&lt; B_TRANSLATE(&quot;The unselected files will be removed from the list.&quot;);</a>
<a name="ln1228">		text &lt;&lt; &quot;\n&quot;;</a>
<a name="ln1229">		BAlert* alert = new BAlert(NULL, text.String(), B_TRANSLATE(&quot;OK&quot;), NULL, NULL,</a>
<a name="ln1230">			B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln1231">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln1232">		alert-&gt;Go(NULL);</a>
<a name="ln1233">		return;</a>
<a name="ln1234">	}</a>
<a name="ln1235"> </a>
<a name="ln1236">	BMessage message;</a>
<a name="ln1237">	BString path;</a>
<a name="ln1238"> </a>
<a name="ln1239">	for (int32 index = 0; ; index++) {</a>
<a name="ln1240">		BStringItem* item = dynamic_cast&lt;BStringItem*&gt;(</a>
<a name="ln1241">			fSearchResults-&gt;ItemAt(index));</a>
<a name="ln1242">		if (item == NULL)</a>
<a name="ln1243">			break;</a>
<a name="ln1244"> </a>
<a name="ln1245">		if (!item-&gt;IsSelected() || item-&gt;OutlineLevel() != 0)</a>
<a name="ln1246">			continue;</a>
<a name="ln1247"> </a>
<a name="ln1248">		if (path == item-&gt;Text())</a>
<a name="ln1249">			continue;</a>
<a name="ln1250"> </a>
<a name="ln1251">		path = item-&gt;Text();</a>
<a name="ln1252">		entry_ref ref;</a>
<a name="ln1253">		if (get_ref_for_path(path.String(), &amp;ref) == B_OK)</a>
<a name="ln1254">			message.AddRef(&quot;refs&quot;, &amp;ref);</a>
<a name="ln1255">	}</a>
<a name="ln1256"> </a>
<a name="ln1257">	fModel-&gt;fDirectory = entry_ref();</a>
<a name="ln1258">		// invalidated on purpose</a>
<a name="ln1259"> </a>
<a name="ln1260">	fModel-&gt;fSelectedFiles.MakeEmpty();</a>
<a name="ln1261">	fModel-&gt;fSelectedFiles = message;</a>
<a name="ln1262"> </a>
<a name="ln1263">	PostMessage(MSG_START_CANCEL);</a>
<a name="ln1264"> </a>
<a name="ln1265">	_SetWindowTitle();</a>
<a name="ln1266">}</a>
<a name="ln1267"> </a>
<a name="ln1268"> </a>
<a name="ln1269">void</a>
<a name="ln1270">GrepWindow::_OnCopyText()</a>
<a name="ln1271">{</a>
<a name="ln1272">	bool onlyCopySelection = true;</a>
<a name="ln1273"> </a>
<a name="ln1274">	if (fSearchResults-&gt;CurrentSelection() &lt; 0)</a>
<a name="ln1275">		onlyCopySelection = false;</a>
<a name="ln1276"> </a>
<a name="ln1277">	BString buffer;</a>
<a name="ln1278"> </a>
<a name="ln1279">	for (int32 index = 0; ; index++) {</a>
<a name="ln1280">		BStringItem* item = dynamic_cast&lt;BStringItem*&gt;(</a>
<a name="ln1281">			fSearchResults-&gt;ItemAt(index));</a>
<a name="ln1282">		if (item == NULL)</a>
<a name="ln1283">			break;</a>
<a name="ln1284"> </a>
<a name="ln1285">		if (onlyCopySelection) {</a>
<a name="ln1286">			if (item-&gt;IsSelected())</a>
<a name="ln1287">				buffer &lt;&lt; item-&gt;Text() &lt;&lt; &quot;\n&quot;;</a>
<a name="ln1288">		} else</a>
<a name="ln1289">			buffer &lt;&lt; item-&gt;Text() &lt;&lt; &quot;\n&quot;;</a>
<a name="ln1290">	}</a>
<a name="ln1291"> </a>
<a name="ln1292">	status_t status = B_OK;</a>
<a name="ln1293"> </a>
<a name="ln1294">	BMessage* clip = NULL;</a>
<a name="ln1295"> </a>
<a name="ln1296">	if (be_clipboard-&gt;Lock()) {</a>
<a name="ln1297">		be_clipboard-&gt;Clear();</a>
<a name="ln1298"> </a>
<a name="ln1299">		clip = be_clipboard-&gt;Data();</a>
<a name="ln1300"> </a>
<a name="ln1301">		clip-&gt;AddData(&quot;text/plain&quot;, B_MIME_TYPE, buffer.String(),</a>
<a name="ln1302">			buffer.Length());</a>
<a name="ln1303"> </a>
<a name="ln1304">		status = be_clipboard-&gt;Commit();</a>
<a name="ln1305"> </a>
<a name="ln1306">		if (status != B_OK) {</a>
<a name="ln1307">			be_clipboard-&gt;Unlock();</a>
<a name="ln1308">			return;</a>
<a name="ln1309">		}</a>
<a name="ln1310"> </a>
<a name="ln1311">		be_clipboard-&gt;Unlock();</a>
<a name="ln1312">	}</a>
<a name="ln1313">}</a>
<a name="ln1314"> </a>
<a name="ln1315"> </a>
<a name="ln1316">void</a>
<a name="ln1317">GrepWindow::_OnSelectInTracker()</a>
<a name="ln1318">{</a>
<a name="ln1319">	if (fSearchResults-&gt;CurrentSelection() &lt; 0) {</a>
<a name="ln1320">		BAlert* alert = new BAlert(&quot;Info&quot;,</a>
<a name="ln1321">			B_TRANSLATE(&quot;Please select the files you wish to have selected for you in &quot;</a>
<a name="ln1322">				&quot;Tracker.&quot;),</a>
<a name="ln1323">			B_TRANSLATE(&quot;OK&quot;), NULL, NULL, B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln1324">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln1325">		alert-&gt;Go(NULL);</a>
<a name="ln1326">		return;</a>
<a name="ln1327">	}</a>
<a name="ln1328"> </a>
<a name="ln1329">	BMessage message;</a>
<a name="ln1330">	BString filePath;</a>
<a name="ln1331">	BPath folderPath;</a>
<a name="ln1332">	BList folderList;</a>
<a name="ln1333">	BString lastFolderAddedToList;</a>
<a name="ln1334"> </a>
<a name="ln1335">	for (int32 index = 0; ; index++) {</a>
<a name="ln1336">		BStringItem* item = dynamic_cast&lt;BStringItem*&gt;(</a>
<a name="ln1337">			fSearchResults-&gt;ItemAt(index));</a>
<a name="ln1338">		if (item == NULL)</a>
<a name="ln1339">			break;</a>
<a name="ln1340"> </a>
<a name="ln1341">		// only open selected and top level (file) items</a>
<a name="ln1342">		if (!item-&gt;IsSelected() || item-&gt;OutlineLevel() &gt; 0)</a>
<a name="ln1343">			continue;</a>
<a name="ln1344"> </a>
<a name="ln1345">		// check if this was previously opened</a>
<a name="ln1346">		if (filePath == item-&gt;Text())</a>
<a name="ln1347">			continue;</a>
<a name="ln1348"> </a>
<a name="ln1349">		filePath = item-&gt;Text();</a>
<a name="ln1350">		entry_ref file_ref;</a>
<a name="ln1351">		if (get_ref_for_path(filePath.String(), &amp;file_ref) != B_OK)</a>
<a name="ln1352">			continue;</a>
<a name="ln1353"> </a>
<a name="ln1354">		message.AddRef(&quot;refs&quot;, &amp;file_ref);</a>
<a name="ln1355"> </a>
<a name="ln1356">		// add parent folder to list of folders to open</a>
<a name="ln1357">		folderPath.SetTo(filePath.String());</a>
<a name="ln1358">		if (folderPath.GetParent(&amp;folderPath) == B_OK) {</a>
<a name="ln1359">			BPath* path = new BPath(folderPath);</a>
<a name="ln1360">			if (path-&gt;Path() != lastFolderAddedToList) {</a>
<a name="ln1361">				// catches some duplicates</a>
<a name="ln1362">				folderList.AddItem(path);</a>
<a name="ln1363">				lastFolderAddedToList = path-&gt;Path();</a>
<a name="ln1364">			} else</a>
<a name="ln1365">				delete path;</a>
<a name="ln1366">		}</a>
<a name="ln1367">	}</a>
<a name="ln1368"> </a>
<a name="ln1369">	_RemoveFolderListDuplicates(&amp;folderList);</a>
<a name="ln1370">	_OpenFoldersInTracker(&amp;folderList);</a>
<a name="ln1371"> </a>
<a name="ln1372">	int32 aShortWhile = 100000;</a>
<a name="ln1373">	snooze(aShortWhile);</a>
<a name="ln1374"> </a>
<a name="ln1375">	if (!_AreAllFoldersOpenInTracker(&amp;folderList)) {</a>
<a name="ln1376">		for (int32 x = 0; x &lt; 5; x++) {</a>
<a name="ln1377">			aShortWhile += 100000;</a>
<a name="ln1378">			snooze(aShortWhile);</a>
<a name="ln1379">			_OpenFoldersInTracker(&amp;folderList);</a>
<a name="ln1380">		}</a>
<a name="ln1381">	}</a>
<a name="ln1382"> </a>
<a name="ln1383">	if (!_AreAllFoldersOpenInTracker(&amp;folderList)) {</a>
<a name="ln1384">		BString str1;</a>
<a name="ln1385">		str1 &lt;&lt; B_TRANSLATE(&quot;%APP_NAME couldn't open one or more folders.&quot;);</a>
<a name="ln1386">		str1.ReplaceFirst(&quot;%APP_NAME&quot;,APP_NAME);</a>
<a name="ln1387">		BAlert* alert = new BAlert(NULL, str1.String(), B_TRANSLATE(&quot;OK&quot;),</a>
<a name="ln1388">			NULL, NULL, B_WIDTH_AS_USUAL, B_STOP_ALERT);</a>
<a name="ln1389">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln1390">		alert-&gt;Go(NULL);</a>
<a name="ln1391">		goto out;</a>
<a name="ln1392">	}</a>
<a name="ln1393"> </a>
<a name="ln1394">	_SelectFilesInTracker(&amp;folderList, &amp;message);</a>
<a name="ln1395"> </a>
<a name="ln1396">out:</a>
<a name="ln1397">	// delete folderList contents</a>
<a name="ln1398">	int32 folderCount = folderList.CountItems();</a>
<a name="ln1399">	for (int32 x = 0; x &lt; folderCount; x++)</a>
<a name="ln1400">		delete static_cast&lt;BPath*&gt;(folderList.ItemAt(x));</a>
<a name="ln1401">}</a>
<a name="ln1402"> </a>
<a name="ln1403"> </a>
<a name="ln1404">void</a>
<a name="ln1405">GrepWindow::_OnQuitNow()</a>
<a name="ln1406">{</a>
<a name="ln1407">	if (be_app-&gt;Lock()) {</a>
<a name="ln1408">		be_app-&gt;PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln1409">		be_app-&gt;Unlock();</a>
<a name="ln1410">	}</a>
<a name="ln1411">}</a>
<a name="ln1412"> </a>
<a name="ln1413"> </a>
<a name="ln1414">void</a>
<a name="ln1415">GrepWindow::_OnFileDrop(BMessage* message)</a>
<a name="ln1416">{</a>
<a name="ln1417">	if (fModel-&gt;fState != STATE_IDLE)</a>
<a name="ln1418">		return;</a>
<a name="ln1419"> </a>
<a name="ln1420">	entry_ref directory;</a>
<a name="ln1421">	_InitRefsReceived(&amp;directory, message);</a>
<a name="ln1422"> </a>
<a name="ln1423">	fModel-&gt;fDirectory = directory;</a>
<a name="ln1424">	fModel-&gt;fSelectedFiles.MakeEmpty();</a>
<a name="ln1425">	fModel-&gt;fSelectedFiles = *message;</a>
<a name="ln1426"> </a>
<a name="ln1427">	fSearchResults-&gt;MakeEmpty();</a>
<a name="ln1428">	fOldPattern = &quot;&quot;;</a>
<a name="ln1429"> </a>
<a name="ln1430">	_SetWindowTitle();</a>
<a name="ln1431">}</a>
<a name="ln1432"> </a>
<a name="ln1433"> </a>
<a name="ln1434">void</a>
<a name="ln1435">GrepWindow::_OnRefsReceived(BMessage* message)</a>
<a name="ln1436">{</a>
<a name="ln1437">	_OnFileDrop(message);</a>
<a name="ln1438">	fOldPattern = &quot;&quot;;</a>
<a name="ln1439">	// It seems a B_CANCEL always follows a B_REFS_RECEIVED</a>
<a name="ln1440">	// from a BFilePanel in Open mode.</a>
<a name="ln1441">	//</a>
<a name="ln1442">	// _OnOpenPanelCancel() is called on B_CANCEL.</a>
<a name="ln1443">	// That's where saving the current dir of the file panel occurs, for now,</a>
<a name="ln1444">	// and also the neccesary deletion of the file panel object.</a>
<a name="ln1445">	// A hidden file panel would otherwise jam the shutdown process.</a>
<a name="ln1446">}</a>
<a name="ln1447"> </a>
<a name="ln1448"> </a>
<a name="ln1449">void</a>
<a name="ln1450">GrepWindow::_OnOpenPanel()</a>
<a name="ln1451">{</a>
<a name="ln1452">	if (fFilePanel != NULL)</a>
<a name="ln1453">		return;</a>
<a name="ln1454"> </a>
<a name="ln1455">	entry_ref path;</a>
<a name="ln1456">	if (get_ref_for_path(fModel-&gt;fFilePanelPath.String(), &amp;path) != B_OK)</a>
<a name="ln1457">		return;</a>
<a name="ln1458"> </a>
<a name="ln1459">	BMessenger messenger(this);</a>
<a name="ln1460">	BMessage message(MSG_REFS_RECEIVED);</a>
<a name="ln1461">	fFilePanel = new BFilePanel(B_OPEN_PANEL, &amp;messenger, &amp;path,</a>
<a name="ln1462">		B_FILE_NODE | B_DIRECTORY_NODE | B_SYMLINK_NODE, true,</a>
<a name="ln1463">		&amp;message, NULL, true, true);</a>
<a name="ln1464"> </a>
<a name="ln1465">	fFilePanel-&gt;Show();</a>
<a name="ln1466">}</a>
<a name="ln1467"> </a>
<a name="ln1468"> </a>
<a name="ln1469">void</a>
<a name="ln1470">GrepWindow::_OnOpenPanelCancel()</a>
<a name="ln1471">{</a>
<a name="ln1472">	entry_ref panelDirRef;</a>
<a name="ln1473">	fFilePanel-&gt;GetPanelDirectory(&amp;panelDirRef);</a>
<a name="ln1474">	BPath path(&amp;panelDirRef);</a>
<a name="ln1475">	fModel-&gt;fFilePanelPath = path.Path();</a>
<a name="ln1476">	delete fFilePanel;</a>
<a name="ln1477">	fFilePanel = NULL;</a>
<a name="ln1478">}</a>
<a name="ln1479"> </a>
<a name="ln1480"> </a>
<a name="ln1481">void</a>
<a name="ln1482">GrepWindow::_OnSelectAll(BMessage* message)</a>
<a name="ln1483">{</a>
<a name="ln1484">	BMessenger messenger(fSearchResults);</a>
<a name="ln1485">	messenger.SendMessage(B_SELECT_ALL);</a>
<a name="ln1486">}</a>
<a name="ln1487"> </a>
<a name="ln1488"> </a>
<a name="ln1489">void</a>
<a name="ln1490">GrepWindow::_OnNewWindow()</a>
<a name="ln1491">{</a>
<a name="ln1492">	BMessage cloneRefs;</a>
<a name="ln1493">		// we don't want GrepWindow::InitRefsReceived()</a>
<a name="ln1494">		// to mess with the refs of the current window</a>
<a name="ln1495"> </a>
<a name="ln1496">	cloneRefs = fModel-&gt;fSelectedFiles;</a>
<a name="ln1497">	cloneRefs.AddRef(&quot;dir_ref&quot;, &amp;(fModel-&gt;fDirectory));</a>
<a name="ln1498"> </a>
<a name="ln1499">	new GrepWindow(&amp;cloneRefs);</a>
<a name="ln1500">}</a>
<a name="ln1501"> </a>
<a name="ln1502"> </a>
<a name="ln1503">// #pragma mark -</a>
<a name="ln1504"> </a>
<a name="ln1505"> </a>
<a name="ln1506">void</a>
<a name="ln1507">GrepWindow::_ModelChanged()</a>
<a name="ln1508">{</a>
<a name="ln1509">	CALLED();</a>
<a name="ln1510"> </a>
<a name="ln1511">	_StopNodeMonitoring();</a>
<a name="ln1512">	_SavePrefs();</a>
<a name="ln1513">}</a>
<a name="ln1514"> </a>
<a name="ln1515">bool</a>
<a name="ln1516">GrepWindow::_OpenInEditor(const entry_ref &amp;ref, int32 lineNum)</a>
<a name="ln1517">{</a>
<a name="ln1518">	BMessage message(B_REFS_RECEIVED);</a>
<a name="ln1519">	message.AddRef(&quot;refs&quot;, &amp;ref);</a>
<a name="ln1520"> </a>
<a name="ln1521">	if (lineNum != -1) {</a>
<a name="ln1522">		message.AddInt32(&quot;line&quot;, lineNum);	// for Pe</a>
<a name="ln1523">		message.AddInt32(&quot;be:line&quot;, lineNum);</a>
<a name="ln1524">	}</a>
<a name="ln1525"> </a>
<a name="ln1526">	// Find the preferred code editor</a>
<a name="ln1527">	char editorSig[B_MIME_TYPE_LENGTH];</a>
<a name="ln1528">	BMimeType mimeType(&quot;text/x-source-code&quot;);</a>
<a name="ln1529">	mimeType.GetPreferredApp(editorSig);</a>
<a name="ln1530"> </a>
<a name="ln1531">	entry_ref editor;</a>
<a name="ln1532">	if (be_roster-&gt;FindApp(editorSig, &amp;editor) != B_OK)</a>
<a name="ln1533">		return false;</a>
<a name="ln1534"> </a>
<a name="ln1535">	if (be_roster-&gt;IsRunning(&amp;editor)) {</a>
<a name="ln1536">		BMessenger msngr(NULL, be_roster-&gt;TeamFor(&amp;editor));</a>
<a name="ln1537">		if (msngr.SendMessage(&amp;message) != B_OK)</a>
<a name="ln1538">			return false;</a>
<a name="ln1539">	} else {</a>
<a name="ln1540">		if (be_roster-&gt;Launch(&amp;editor, &amp;message) != B_OK)</a>
<a name="ln1541">			return false;</a>
<a name="ln1542">	}</a>
<a name="ln1543"> </a>
<a name="ln1544">	return true;</a>
<a name="ln1545">}</a>
<a name="ln1546"> </a>
<a name="ln1547"> </a>
<a name="ln1548">void</a>
<a name="ln1549">GrepWindow::_RemoveFolderListDuplicates(BList* folderList)</a>
<a name="ln1550">{</a>
<a name="ln1551">	if (folderList == NULL)</a>
<a name="ln1552">		return;</a>
<a name="ln1553"> </a>
<a name="ln1554">	int32 folderCount = folderList-&gt;CountItems();</a>
<a name="ln1555">	BString folderX;</a>
<a name="ln1556">	BString folderY;</a>
<a name="ln1557"> </a>
<a name="ln1558">	for (int32 x = 0; x &lt; folderCount; x++) {</a>
<a name="ln1559">		BPath* path = static_cast&lt;BPath*&gt;(folderList-&gt;ItemAt(x));</a>
<a name="ln1560">		folderX = path-&gt;Path();</a>
<a name="ln1561"> </a>
<a name="ln1562">		for (int32 y = x + 1; y &lt; folderCount; y++) {</a>
<a name="ln1563">			path = static_cast&lt;BPath*&gt;(folderList-&gt;ItemAt(y));</a>
<a name="ln1564">			folderY = path-&gt;Path();</a>
<a name="ln1565">			if (folderX == folderY) {</a>
<a name="ln1566">				delete static_cast&lt;BPath*&gt;(folderList-&gt;RemoveItem(y));</a>
<a name="ln1567">				folderCount--;</a>
<a name="ln1568">				y--;</a>
<a name="ln1569">			}</a>
<a name="ln1570">		}</a>
<a name="ln1571">	}</a>
<a name="ln1572">}</a>
<a name="ln1573"> </a>
<a name="ln1574"> </a>
<a name="ln1575">status_t</a>
<a name="ln1576">GrepWindow::_OpenFoldersInTracker(BList* folderList)</a>
<a name="ln1577">{</a>
<a name="ln1578">	status_t status = B_OK;</a>
<a name="ln1579">	BMessage refsMsg(B_REFS_RECEIVED);</a>
<a name="ln1580"> </a>
<a name="ln1581">	int32 folderCount = folderList-&gt;CountItems();</a>
<a name="ln1582">	for (int32 index = 0; index &lt; folderCount; index++) {</a>
<a name="ln1583">		BPath* path = static_cast&lt;BPath*&gt;(folderList-&gt;ItemAt(index));</a>
<a name="ln1584"> </a>
<a name="ln1585">		entry_ref folderRef;</a>
<a name="ln1586">		status = get_ref_for_path(path-&gt;Path(), &amp;folderRef);</a>
<a name="ln1587">		if (status != B_OK)</a>
<a name="ln1588">			return status;</a>
<a name="ln1589"> </a>
<a name="ln1590">		status = refsMsg.AddRef(&quot;refs&quot;, &amp;folderRef);</a>
<a name="ln1591">		if (status != B_OK)</a>
<a name="ln1592">			return status;</a>
<a name="ln1593">	}</a>
<a name="ln1594"> </a>
<a name="ln1595">	status = be_roster-&gt;Launch(TRACKER_SIGNATURE, &amp;refsMsg);</a>
<a name="ln1596">	if (status != B_OK &amp;&amp; status != B_ALREADY_RUNNING)</a>
<a name="ln1597">		return status;</a>
<a name="ln1598"> </a>
<a name="ln1599">	return B_OK;</a>
<a name="ln1600">}</a>
<a name="ln1601"> </a>
<a name="ln1602"> </a>
<a name="ln1603">bool</a>
<a name="ln1604">GrepWindow::_AreAllFoldersOpenInTracker(BList* folderList)</a>
<a name="ln1605">{</a>
<a name="ln1606">	// Compare the folders we want open in Tracker to</a>
<a name="ln1607">	// the actual Tracker windows currently open.</a>
<a name="ln1608"> </a>
<a name="ln1609">	// We build a list of open Tracker windows, and compare</a>
<a name="ln1610">	// it to the list of folders we want open in Tracker.</a>
<a name="ln1611"> </a>
<a name="ln1612">	// If all folders exists in the list of Tracker windows</a>
<a name="ln1613">	// return true</a>
<a name="ln1614"> </a>
<a name="ln1615">	status_t status = B_OK;</a>
<a name="ln1616">	BMessenger trackerMessenger(TRACKER_SIGNATURE);</a>
<a name="ln1617">	BMessage sendMessage;</a>
<a name="ln1618">	BMessage replyMessage;</a>
<a name="ln1619">	BList windowList;</a>
<a name="ln1620"> </a>
<a name="ln1621">	if (!trackerMessenger.IsValid())</a>
<a name="ln1622">		return false;</a>
<a name="ln1623"> </a>
<a name="ln1624">	for (int32 count = 1; ; count++) {</a>
<a name="ln1625">		sendMessage.MakeEmpty();</a>
<a name="ln1626">		replyMessage.MakeEmpty();</a>
<a name="ln1627"> </a>
<a name="ln1628">		sendMessage.what = B_GET_PROPERTY;</a>
<a name="ln1629">		sendMessage.AddSpecifier(&quot;Path&quot;);</a>
<a name="ln1630">		sendMessage.AddSpecifier(&quot;Poses&quot;);</a>
<a name="ln1631">		sendMessage.AddSpecifier(&quot;Window&quot;, count);</a>
<a name="ln1632"> </a>
<a name="ln1633">		status = trackerMessenger.SendMessage(&amp;sendMessage, &amp;replyMessage);</a>
<a name="ln1634">		if (status != B_OK)</a>
<a name="ln1635">			return false;</a>
<a name="ln1636"> </a>
<a name="ln1637">		entry_ref* trackerRef = new (nothrow) entry_ref;</a>
<a name="ln1638">		status = replyMessage.FindRef(&quot;result&quot;, trackerRef);</a>
<a name="ln1639">		if (status != B_OK || !windowList.AddItem(trackerRef)) {</a>
<a name="ln1640">			delete trackerRef;</a>
<a name="ln1641">			break;</a>
<a name="ln1642">		}</a>
<a name="ln1643">	}</a>
<a name="ln1644"> </a>
<a name="ln1645">	int32 folderCount = folderList-&gt;CountItems();</a>
<a name="ln1646">	int32 windowCount = windowList.CountItems();</a>
<a name="ln1647"> </a>
<a name="ln1648">	int32 found = 0;</a>
<a name="ln1649">	BPath* folderPath;</a>
<a name="ln1650">	entry_ref* windowRef;</a>
<a name="ln1651">	BString folderString;</a>
<a name="ln1652">	BString windowString;</a>
<a name="ln1653">	bool result = false;</a>
<a name="ln1654"> </a>
<a name="ln1655">	if (folderCount &gt; windowCount) {</a>
<a name="ln1656">		// at least one folder is not open in Tracker</a>
<a name="ln1657">		goto out;</a>
<a name="ln1658">	}</a>
<a name="ln1659"> </a>
<a name="ln1660">	// Loop over the two lists and see if all folders exist as window</a>
<a name="ln1661">	for (int32 x = 0; x &lt; folderCount; x++) {</a>
<a name="ln1662">		for (int32 y = 0; y &lt; windowCount; y++) {</a>
<a name="ln1663"> </a>
<a name="ln1664">			folderPath = static_cast&lt;BPath*&gt;(folderList-&gt;ItemAt(x));</a>
<a name="ln1665">			windowRef = static_cast&lt;entry_ref*&gt;(windowList.ItemAt(y));</a>
<a name="ln1666"> </a>
<a name="ln1667">			if (folderPath == NULL)</a>
<a name="ln1668">				break;</a>
<a name="ln1669"> </a>
<a name="ln1670">			if (windowRef == NULL)</a>
<a name="ln1671">				break;</a>
<a name="ln1672"> </a>
<a name="ln1673">			folderString = folderPath-&gt;Path();</a>
<a name="ln1674"> </a>
<a name="ln1675">			BEntry entry;</a>
<a name="ln1676">			BPath path;</a>
<a name="ln1677"> </a>
<a name="ln1678">			if (entry.SetTo(windowRef) == B_OK &amp;&amp; path.SetTo(&amp;entry) == B_OK) {</a>
<a name="ln1679"> </a>
<a name="ln1680">				windowString = path.Path();</a>
<a name="ln1681"> </a>
<a name="ln1682">				if (folderString == windowString) {</a>
<a name="ln1683">					found++;</a>
<a name="ln1684">					break;</a>
<a name="ln1685">				}</a>
<a name="ln1686">			}</a>
<a name="ln1687">		}</a>
<a name="ln1688">	}</a>
<a name="ln1689"> </a>
<a name="ln1690">	result = found == folderCount;</a>
<a name="ln1691"> </a>
<a name="ln1692">out:</a>
<a name="ln1693">	// delete list of window entry_refs</a>
<a name="ln1694">	for (int32 x = 0; x &lt; windowCount; x++)</a>
<a name="ln1695">		delete static_cast&lt;entry_ref*&gt;(windowList.ItemAt(x));</a>
<a name="ln1696"> </a>
<a name="ln1697">	return result;</a>
<a name="ln1698">}</a>
<a name="ln1699"> </a>
<a name="ln1700"> </a>
<a name="ln1701">status_t</a>
<a name="ln1702">GrepWindow::_SelectFilesInTracker(BList* folderList, BMessage* refsMessage)</a>
<a name="ln1703">{</a>
<a name="ln1704">	// loops over Tracker windows, find each windowRef,</a>
<a name="ln1705">	// extract the refs that are children of windowRef,</a>
<a name="ln1706">	// add refs to selection-message</a>
<a name="ln1707"> </a>
<a name="ln1708">	status_t status = B_OK;</a>
<a name="ln1709">	BMessenger trackerMessenger(TRACKER_SIGNATURE);</a>
<a name="ln1710">	BMessage windowSendMessage;</a>
<a name="ln1711">	BMessage windowReplyMessage;</a>
<a name="ln1712">	BMessage selectionSendMessage;</a>
<a name="ln1713">	BMessage selectionReplyMessage;</a>
<a name="ln1714"> </a>
<a name="ln1715">	if (!trackerMessenger.IsValid())</a>
<a name="ln1716">		return status;</a>
<a name="ln1717"> </a>
<a name="ln1718">	// loop over Tracker windows</a>
<a name="ln1719">	for (int32 windowCount = 1; ; windowCount++) {</a>
<a name="ln1720"> </a>
<a name="ln1721">		windowSendMessage.MakeEmpty();</a>
<a name="ln1722">		windowReplyMessage.MakeEmpty();</a>
<a name="ln1723"> </a>
<a name="ln1724">		windowSendMessage.what = B_GET_PROPERTY;</a>
<a name="ln1725">		windowSendMessage.AddSpecifier(&quot;Path&quot;);</a>
<a name="ln1726">		windowSendMessage.AddSpecifier(&quot;Poses&quot;);</a>
<a name="ln1727">		windowSendMessage.AddSpecifier(&quot;Window&quot;, windowCount);</a>
<a name="ln1728"> </a>
<a name="ln1729">		status = trackerMessenger.SendMessage(&amp;windowSendMessage,</a>
<a name="ln1730">			&amp;windowReplyMessage);</a>
<a name="ln1731"> </a>
<a name="ln1732">		if (status != B_OK)</a>
<a name="ln1733">			return status;</a>
<a name="ln1734"> </a>
<a name="ln1735">		entry_ref windowRef;</a>
<a name="ln1736">		status = windowReplyMessage.FindRef(&quot;result&quot;, &amp;windowRef);</a>
<a name="ln1737">		if (status != B_OK)</a>
<a name="ln1738">			break;</a>
<a name="ln1739"> </a>
<a name="ln1740">		int32 folderCount = folderList-&gt;CountItems();</a>
<a name="ln1741"> </a>
<a name="ln1742">		// loop over folders in folderList</a>
<a name="ln1743">		for (int32 x = 0; x &lt; folderCount; x++) {</a>
<a name="ln1744">			BPath* folderPath = static_cast&lt;BPath*&gt;(folderList-&gt;ItemAt(x));</a>
<a name="ln1745">			if (folderPath == NULL)</a>
<a name="ln1746">				break;</a>
<a name="ln1747"> </a>
<a name="ln1748">			BString folderString = folderPath-&gt;Path();</a>
<a name="ln1749"> </a>
<a name="ln1750">			BEntry windowEntry;</a>
<a name="ln1751">			BPath windowPath;</a>
<a name="ln1752">			BString windowString;</a>
<a name="ln1753"> </a>
<a name="ln1754">			status = windowEntry.SetTo(&amp;windowRef);</a>
<a name="ln1755">			if (status != B_OK)</a>
<a name="ln1756">				break;</a>
<a name="ln1757"> </a>
<a name="ln1758">			status = windowPath.SetTo(&amp;windowEntry);</a>
<a name="ln1759">			if (status != B_OK)</a>
<a name="ln1760">				break;</a>
<a name="ln1761"> </a>
<a name="ln1762">			windowString = windowPath.Path();</a>
<a name="ln1763"> </a>
<a name="ln1764">			// if match, loop over items in refsMessage</a>
<a name="ln1765">			// and add those that live in window/folder</a>
<a name="ln1766">			// to a selection message</a>
<a name="ln1767"> </a>
<a name="ln1768">			if (windowString == folderString) {</a>
<a name="ln1769">				selectionSendMessage.MakeEmpty();</a>
<a name="ln1770">				selectionSendMessage.what = B_SET_PROPERTY;</a>
<a name="ln1771">				selectionReplyMessage.MakeEmpty();</a>
<a name="ln1772"> </a>
<a name="ln1773">				// loop over refs and add to message</a>
<a name="ln1774">				entry_ref ref;</a>
<a name="ln1775">				for (int32 index = 0; ; index++) {</a>
<a name="ln1776">					status = refsMessage-&gt;FindRef(&quot;refs&quot;, index, &amp;ref);</a>
<a name="ln1777">					if (status != B_OK)</a>
<a name="ln1778">						break;</a>
<a name="ln1779"> </a>
<a name="ln1780">					BDirectory directory(&amp;windowRef);</a>
<a name="ln1781">					BEntry entry(&amp;ref);</a>
<a name="ln1782">					if (directory.Contains(&amp;entry))</a>
<a name="ln1783">						selectionSendMessage.AddRef(&quot;data&quot;, &amp;ref);</a>
<a name="ln1784">				}</a>
<a name="ln1785"> </a>
<a name="ln1786">				// finish selection message</a>
<a name="ln1787">				selectionSendMessage.AddSpecifier(&quot;Selection&quot;);</a>
<a name="ln1788">				selectionSendMessage.AddSpecifier(&quot;Poses&quot;);</a>
<a name="ln1789">				selectionSendMessage.AddSpecifier(&quot;Window&quot;, windowCount);</a>
<a name="ln1790"> </a>
<a name="ln1791">				trackerMessenger.SendMessage(&amp;selectionSendMessage,</a>
<a name="ln1792">					&amp;selectionReplyMessage);</a>
<a name="ln1793">			}</a>
<a name="ln1794">		}</a>
<a name="ln1795">	}</a>
<a name="ln1796"> </a>
<a name="ln1797">	return B_OK;</a>
<a name="ln1798">}</a>

</code></pre>
<div class="balloon" rel="1233"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="1326"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
