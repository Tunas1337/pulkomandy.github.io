
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>scsi_cd.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2004-2012, Haiku, Inc. All rights reserved.</a>
<a name="ln3"> * Copyright 2002-2003, Thomas Kurschel. All rights reserved.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Distributed under the terms of the MIT License.</a>
<a name="ln6"> */</a>
<a name="ln7"> </a>
<a name="ln8"> </a>
<a name="ln9">/*!	Peripheral driver to handle CD-ROM drives. To be more</a>
<a name="ln10">	precisely, it supports CD-ROM and WORM drives (well -</a>
<a name="ln11">	I've never _seen_ a WORM driver).</a>
<a name="ln12"> </a>
<a name="ln13">	Much work is done by scsi_periph and block_io.</a>
<a name="ln14">*/</a>
<a name="ln15"> </a>
<a name="ln16"> </a>
<a name="ln17">#include &quot;scsi_cd.h&quot;</a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;stdlib.h&gt;</a>
<a name="ln20">#include &lt;string.h&gt;</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;algorithm&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &lt;fs/devfs.h&gt;</a>
<a name="ln25">#include &lt;io_requests.h&gt;</a>
<a name="ln26">#include &lt;vm/vm_page.h&gt;</a>
<a name="ln27"> </a>
<a name="ln28">#include &quot;IOCache.h&quot;</a>
<a name="ln29">#include &quot;IOSchedulerSimple.h&quot;</a>
<a name="ln30"> </a>
<a name="ln31"> </a>
<a name="ln32">//#define TRACE_CD_DISK</a>
<a name="ln33">#ifdef TRACE_CD_DISK</a>
<a name="ln34">#	define TRACE(x...) dprintf(&quot;scsi_cd: &quot; x)</a>
<a name="ln35">#else</a>
<a name="ln36">#	define TRACE(x...) ;</a>
<a name="ln37">#endif</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">static const uint8 kCDIcon[] = {</a>
<a name="ln41">	0x6e, 0x63, 0x69, 0x66, 0x05, 0x05, 0x00, 0x02, 0x03, 0x06, 0x05, 0xb8,</a>
<a name="ln42">	0x12, 0xa5, 0xbe, 0x03, 0xe1, 0x3d, 0xe7, 0x84, 0xb8, 0x02, 0x10, 0x49,</a>
<a name="ln43">	0xf7, 0x9f, 0x49, 0xed, 0xd8, 0x00, 0xf1, 0xf1, 0xf1, 0x36, 0xd9, 0xdd,</a>
<a name="ln44">	0xf4, 0x8a, 0x99, 0x96, 0xb9, 0xb4, 0xb8, 0xbe, 0xdb, 0xff, 0xf4, 0xf4,</a>
<a name="ln45">	0xf4, 0x04, 0xeb, 0xd0, 0x02, 0x00, 0x06, 0x02, 0x3c, 0x92, 0xc0, 0x38,</a>
<a name="ln46">	0x8f, 0x5f, 0xb8, 0x54, 0x50, 0x3c, 0x57, 0x63, 0x48, 0xd8, 0xdf, 0x48,</a>
<a name="ln47">	0x89, 0x5b, 0x00, 0x41, 0x37, 0xa9, 0xff, 0xb9, 0xb9, 0xb9, 0x04, 0x01,</a>
<a name="ln48">	0x7e, 0x04, 0x02, 0x04, 0x3f, 0x2c, 0x4e, 0x2c, 0x30, 0x2c, 0x22, 0x40,</a>
<a name="ln49">	0x22, 0x34, 0x22, 0x4c, 0x3f, 0x54, 0x30, 0x54, 0x4e, 0x54, 0x5c, 0x40,</a>
<a name="ln50">	0x5c, 0x4c, 0x5c, 0x34, 0x02, 0x04, 0x3f, 0x3a, 0x43, 0x3a, 0x3b, 0x3a,</a>
<a name="ln51">	0x39, 0x3e, 0x39, 0x3c, 0x39, 0x40, 0x3f, 0x42, 0x3b, 0x42, 0x43, 0x42,</a>
<a name="ln52">	0x45, 0x3e, 0x45, 0x40, 0x45, 0x3c, 0x02, 0x04, 0x4b, 0x3e, 0x4b, 0x3a,</a>
<a name="ln53">	0x4b, 0x42, 0x3f, 0x46, 0x47, 0x46, 0x37, 0x46, 0x33, 0x3e, 0x33, 0x42,</a>
<a name="ln54">	0x33, 0x3a, 0x3f, 0xbb, 0xf7, 0x37, 0xbb, 0xf7, 0x47, 0xbb, 0xf7, 0x02,</a>
<a name="ln55">	0x04, 0x40, 0x2a, 0x54, 0x2a, 0x50, 0x2c, 0x5c, 0x40, 0x5c, 0x34, 0x5c,</a>
<a name="ln56">	0x4c, 0x40, 0x56, 0x50, 0x54, 0x54, 0x56, 0x60, 0x40, 0x60, 0x4c, 0x60,</a>
<a name="ln57">	0x34, 0x06, 0x0a, 0x04, 0x01, 0x03, 0x00, 0x0a, 0x00, 0x02, 0x00, 0x01,</a>
<a name="ln58">	0x18, 0x15, 0xff, 0x01, 0x17, 0x84, 0x00, 0x04, 0x0a, 0x00, 0x02, 0x00,</a>
<a name="ln59">	0x01, 0x18, 0x00, 0x15, 0x01, 0x17, 0x86, 0x00, 0x04, 0x0a, 0x01, 0x02,</a>
<a name="ln60">	0x00, 0x02, 0x00, 0x0a, 0x02, 0x02, 0x02, 0x01, 0x00, 0x0a, 0x03, 0x01,</a>
<a name="ln61">	0x02, 0x10, 0x01, 0x17, 0x82, 0x00, 0x04</a>
<a name="ln62">};</a>
<a name="ln63"> </a>
<a name="ln64"> </a>
<a name="ln65">static scsi_periph_interface *sSCSIPeripheral;</a>
<a name="ln66">static device_manager_info *sDeviceManager;</a>
<a name="ln67"> </a>
<a name="ln68"> </a>
<a name="ln69">#define SCSI_CD_STD_TIMEOUT 10</a>
<a name="ln70"> </a>
<a name="ln71"> </a>
<a name="ln72">static status_t</a>
<a name="ln73">update_capacity(cd_driver_info *info)</a>
<a name="ln74">{</a>
<a name="ln75">	TRACE(&quot;update_capacity()\n&quot;);</a>
<a name="ln76"> </a>
<a name="ln77">	scsi_ccb *ccb = info-&gt;scsi-&gt;alloc_ccb(info-&gt;scsi_device);</a>
<a name="ln78">	if (ccb == NULL)</a>
<a name="ln79">		return B_NO_MEMORY;</a>
<a name="ln80"> </a>
<a name="ln81">	status_t status = sSCSIPeripheral-&gt;check_capacity(</a>
<a name="ln82">		info-&gt;scsi_periph_device, ccb);</a>
<a name="ln83"> </a>
<a name="ln84">	info-&gt;scsi-&gt;free_ccb(ccb);</a>
<a name="ln85"> </a>
<a name="ln86">	return status;</a>
<a name="ln87">}</a>
<a name="ln88"> </a>
<a name="ln89"> </a>
<a name="ln90">/*!	Iteratively correct the reported capacity by trying to read from the device</a>
<a name="ln91">	close to its end.</a>
<a name="ln92">*/</a>
<a name="ln93">static uint64</a>
<a name="ln94">test_capacity(cd_driver_info *info)</a>
<a name="ln95">{</a>
<a name="ln96">	static const size_t kMaxEntries = 4;</a>
<a name="ln97">	const uint32 blockSize = info-&gt;block_size;</a>
<a name="ln98">	const size_t kBufferSize = blockSize * 4;</a>
<a name="ln99"> </a>
<a name="ln100">	TRACE(&quot;test_capacity: read with buffer size %&quot; B_PRIuSIZE &quot;, block size %&quot;</a>
<a name="ln101">		B_PRIu32&quot;, capacity %llu\n&quot;, kBufferSize, blockSize,</a>
<a name="ln102">		info-&gt;original_capacity);</a>
<a name="ln103"> </a>
<a name="ln104">	info-&gt;capacity = info-&gt;original_capacity;</a>
<a name="ln105"> </a>
<a name="ln106">	size_t numBlocks = B_PAGE_SIZE / blockSize;</a>
<a name="ln107">	uint64 offset = info-&gt;original_capacity;</a>
<a name="ln108">	if (offset &lt;= numBlocks)</a>
<a name="ln109">		return B_OK;</a>
<a name="ln110"> </a>
<a name="ln111">	offset -= numBlocks;</a>
<a name="ln112"> </a>
<a name="ln113">	scsi_ccb *request = info-&gt;scsi-&gt;alloc_ccb(info-&gt;scsi_device);</a>
<a name="ln114">	if (request == NULL)</a>
<a name="ln115">		return B_NO_MEMORY;</a>
<a name="ln116"> </a>
<a name="ln117">	// Allocate buffer</a>
<a name="ln118"> </a>
<a name="ln119">	physical_entry entries[4];</a>
<a name="ln120">	size_t numEntries = 0;</a>
<a name="ln121"> </a>
<a name="ln122">	vm_page_reservation reservation;</a>
<a name="ln123">	vm_page_reserve_pages(&amp;reservation,</a>
<a name="ln124">		(kBufferSize - 1 + B_PAGE_SIZE) / B_PAGE_SIZE, VM_PRIORITY_SYSTEM);</a>
<a name="ln125"> </a>
<a name="ln126">	for (size_t left = kBufferSize; numEntries &lt; kMaxEntries &amp;&amp; left &gt; 0;</a>
<a name="ln127">			numEntries++) {</a>
<a name="ln128">		size_t bytes = std::min(left, (size_t)B_PAGE_SIZE);</a>
<a name="ln129"> </a>
<a name="ln130">		vm_page* page = vm_page_allocate_page(&amp;reservation,</a>
<a name="ln131">			PAGE_STATE_WIRED | VM_PAGE_ALLOC_BUSY);</a>
<a name="ln132"> </a>
<a name="ln133">		entries[numEntries].address = page-&gt;physical_page_number * B_PAGE_SIZE;</a>
<a name="ln134">		entries[numEntries].size = bytes;;</a>
<a name="ln135"> </a>
<a name="ln136">		left -= bytes;</a>
<a name="ln137">	}</a>
<a name="ln138"> </a>
<a name="ln139">	vm_page_unreserve_pages(&amp;reservation);</a>
<a name="ln140"> </a>
<a name="ln141">	// Read close to the end of the device to find out its real end</a>
<a name="ln142"> </a>
<a name="ln143">	// Only try 1 second before the end (= 75 blocks)</a>
<a name="ln144">	while (offset &gt; info-&gt;original_capacity - 75) {</a>
<a name="ln145">		size_t bytesTransferred;</a>
<a name="ln146">		status_t status = sSCSIPeripheral-&gt;read_write(info-&gt;scsi_periph_device,</a>
<a name="ln147">			request, offset, numBlocks, entries, numEntries, false,</a>
<a name="ln148">			&amp;bytesTransferred);</a>
<a name="ln149"> </a>
<a name="ln150">		TRACE(&quot;test_capacity: read from offset %llu: %s\n&quot;, offset,</a>
<a name="ln151">			strerror(status));</a>
<a name="ln152"> </a>
<a name="ln153">		if (status == B_OK || (request-&gt;sense[0] &amp; 0x7f) != 0x70)</a>
<a name="ln154">			break;</a>
<a name="ln155"> </a>
<a name="ln156">		switch (request-&gt;sense[2]) {</a>
<a name="ln157">			case SCSIS_KEY_MEDIUM_ERROR:</a>
<a name="ln158">			case SCSIS_KEY_ILLEGAL_REQUEST:</a>
<a name="ln159">			case SCSIS_KEY_VOLUME_OVERFLOW:</a>
<a name="ln160">			{</a>
<a name="ln161">				// find out the problematic sector</a>
<a name="ln162">				uint32 errorBlock = (request-&gt;sense[3] &lt;&lt; 24U)</a>
<a name="ln163">					| (request-&gt;sense[4] &lt;&lt; 16U) | (request-&gt;sense[5] &lt;&lt; 8U)</a>
<a name="ln164">					| request-&gt;sense[6];</a>
<a name="ln165">				if (errorBlock &gt;= offset)</a>
<a name="ln166">					info-&gt;capacity = errorBlock;</a>
<a name="ln167">				break;</a>
<a name="ln168">			}</a>
<a name="ln169"> </a>
<a name="ln170">			default:</a>
<a name="ln171">				break;</a>
<a name="ln172">		}</a>
<a name="ln173"> </a>
<a name="ln174">		if (numBlocks &gt; offset)</a>
<a name="ln175">			break;</a>
<a name="ln176"> </a>
<a name="ln177">		offset -= numBlocks;</a>
<a name="ln178">	}</a>
<a name="ln179"> </a>
<a name="ln180">	info-&gt;scsi-&gt;free_ccb(request);</a>
<a name="ln181"> </a>
<a name="ln182">	for (size_t i = 0; i &lt; numEntries; i++) {</a>
<a name="ln183">		vm_page_set_state(vm_lookup_page(entries[i].address / B_PAGE_SIZE),</a>
<a name="ln184">			PAGE_STATE_FREE);</a>
<a name="ln185">	}</a>
<a name="ln186"> </a>
<a name="ln187">	if (info-&gt;capacity != info-&gt;original_capacity) {</a>
<a name="ln188">		dprintf(&quot;scsi_cd: adjusted capacity from %&quot; B_PRIu64 &quot; to %&quot; B_PRIu64</a>
<a name="ln189">			&quot; blocks.\n&quot;, info-&gt;original_capacity, info-&gt;capacity);</a>
<a name="ln190">	}</a>
<a name="ln191"> </a>
<a name="ln192">	return B_OK;</a>
<a name="ln193">}</a>
<a name="ln194"> </a>
<a name="ln195"> </a>
<a name="ln196">static status_t</a>
<a name="ln197">get_geometry(cd_handle *handle, device_geometry *geometry)</a>
<a name="ln198">{</a>
<a name="ln199">	cd_driver_info *info = handle-&gt;info;</a>
<a name="ln200"> </a>
<a name="ln201">	status_t status = update_capacity(info);</a>
<a name="ln202"> </a>
<a name="ln203">	// it seems that Be expects B_GET_GEOMETRY to always succeed unless</a>
<a name="ln204">	// the medium has been changed; e.g. if we report B_DEV_NO_MEDIA, the</a>
<a name="ln205">	// info is ignored by the CDPlayer and CDBurner</a>
<a name="ln206">	if (status == B_DEV_MEDIA_CHANGED)</a>
<a name="ln207">		return B_DEV_MEDIA_CHANGED;</a>
<a name="ln208"> </a>
<a name="ln209">	devfs_compute_geometry_size(geometry, info-&gt;capacity, info-&gt;block_size);</a>
<a name="ln210"> </a>
<a name="ln211">	geometry-&gt;device_type = info-&gt;device_type;</a>
<a name="ln212">	geometry-&gt;removable = info-&gt;removable;</a>
<a name="ln213"> </a>
<a name="ln214">	// TBD: for all but CD-ROMs, read mode sense - medium type</a>
<a name="ln215">	// (bit 7 of block device specific parameter for Optical Memory Block Device)</a>
<a name="ln216">	// (same for Direct-Access Block Devices)</a>
<a name="ln217">	// (same for write-once block devices)</a>
<a name="ln218">	// (same for optical memory block devices)</a>
<a name="ln219">	geometry-&gt;read_only = true;</a>
<a name="ln220">	geometry-&gt;write_once = info-&gt;device_type == scsi_dev_WORM;</a>
<a name="ln221"> </a>
<a name="ln222">	TRACE(&quot;scsi_disk: get_geometry(): %ld, %ld, %ld, %ld, %d, %d, %d, %d\n&quot;,</a>
<a name="ln223">		geometry-&gt;bytes_per_sector, geometry-&gt;sectors_per_track,</a>
<a name="ln224">		geometry-&gt;cylinder_count, geometry-&gt;head_count, geometry-&gt;device_type,</a>
<a name="ln225">		geometry-&gt;removable, geometry-&gt;read_only, geometry-&gt;write_once);</a>
<a name="ln226"> </a>
<a name="ln227">	return B_OK;</a>
<a name="ln228">}</a>
<a name="ln229"> </a>
<a name="ln230"> </a>
<a name="ln231">static status_t</a>
<a name="ln232">get_toc(cd_driver_info *info, scsi_toc *toc)</a>
<a name="ln233">{</a>
<a name="ln234">	scsi_ccb *ccb;</a>
<a name="ln235">	status_t res;</a>
<a name="ln236">	scsi_cmd_read_toc *cmd;</a>
<a name="ln237">	size_t dataLength;</a>
<a name="ln238">	scsi_toc_general *shortResponse = (scsi_toc_general *)toc-&gt;toc_data;</a>
<a name="ln239"> </a>
<a name="ln240">	TRACE(&quot;get_toc()\n&quot;);</a>
<a name="ln241"> </a>
<a name="ln242">	ccb = info-&gt;scsi-&gt;alloc_ccb(info-&gt;scsi_device);</a>
<a name="ln243">	if (ccb == NULL)</a>
<a name="ln244">		return B_NO_MEMORY;</a>
<a name="ln245"> </a>
<a name="ln246">	// first read number of tracks only</a>
<a name="ln247">	ccb-&gt;flags = SCSI_DIR_IN;</a>
<a name="ln248"> </a>
<a name="ln249">	cmd = (scsi_cmd_read_toc *)ccb-&gt;cdb;</a>
<a name="ln250"> </a>
<a name="ln251">	memset(cmd, 0, sizeof(*cmd));</a>
<a name="ln252">	cmd-&gt;opcode = SCSI_OP_READ_TOC;</a>
<a name="ln253">	cmd-&gt;time = 1;</a>
<a name="ln254">	cmd-&gt;format = SCSI_TOC_FORMAT_TOC;</a>
<a name="ln255">	cmd-&gt;track = 1;</a>
<a name="ln256">	cmd-&gt;allocation_length = B_HOST_TO_BENDIAN_INT16(sizeof(scsi_toc_general));</a>
<a name="ln257"> </a>
<a name="ln258">	ccb-&gt;cdb_length = sizeof(*cmd);</a>
<a name="ln259"> </a>
<a name="ln260">	ccb-&gt;sort = -1;</a>
<a name="ln261">	ccb-&gt;timeout = SCSI_CD_STD_TIMEOUT;</a>
<a name="ln262"> </a>
<a name="ln263">	ccb-&gt;data = toc-&gt;toc_data;</a>
<a name="ln264">	ccb-&gt;sg_list = NULL;</a>
<a name="ln265">	ccb-&gt;data_length = sizeof(toc-&gt;toc_data);</a>
<a name="ln266"> </a>
<a name="ln267">	res = sSCSIPeripheral-&gt;safe_exec(info-&gt;scsi_periph_device, ccb);</a>
<a name="ln268">	if (res != B_OK)</a>
<a name="ln269">		goto err;</a>
<a name="ln270"> </a>
<a name="ln271">	// then read all track infos</a>
<a name="ln272">	// (little hint: number of tracks is last - first + 1;</a>
<a name="ln273">	//  but scsi_toc_toc has already one track, so we get</a>
<a name="ln274">	//  last - first extra tracks; finally, we want the lead-out as</a>
<a name="ln275">	//  well, so we add an extra track)</a>
<a name="ln276">	dataLength = (shortResponse-&gt;last - shortResponse-&gt;first + 1)</a>
<a name="ln277">		* sizeof(scsi_toc_track) + sizeof(scsi_toc_toc);</a>
<a name="ln278">	dataLength = min_c(dataLength, sizeof(toc-&gt;toc_data));</a>
<a name="ln279"> </a>
<a name="ln280">	TRACE(&quot;  tracks: %d - %d, data length %d\n&quot;, shortResponse-&gt;first,</a>
<a name="ln281">		shortResponse-&gt;last, (int)dataLength);</a>
<a name="ln282"> </a>
<a name="ln283">	cmd-&gt;allocation_length = B_HOST_TO_BENDIAN_INT16(dataLength);</a>
<a name="ln284"> </a>
<a name="ln285">	res = sSCSIPeripheral-&gt;safe_exec(info-&gt;scsi_periph_device, ccb);</a>
<a name="ln286"> </a>
<a name="ln287">err:</a>
<a name="ln288">	info-&gt;scsi-&gt;free_ccb(ccb);</a>
<a name="ln289"> </a>
<a name="ln290">	return res;</a>
<a name="ln291">}</a>
<a name="ln292"> </a>
<a name="ln293"> </a>
<a name="ln294">static status_t</a>
<a name="ln295">load_eject(cd_driver_info *info, bool load)</a>
<a name="ln296">{</a>
<a name="ln297">	TRACE(&quot;load_eject()\n&quot;);</a>
<a name="ln298"> </a>
<a name="ln299">	scsi_ccb *ccb = info-&gt;scsi-&gt;alloc_ccb(info-&gt;scsi_device);</a>
<a name="ln300">	if (ccb == NULL)</a>
<a name="ln301">		return B_NO_MEMORY;</a>
<a name="ln302"> </a>
<a name="ln303">	err_res result = sSCSIPeripheral-&gt;send_start_stop(</a>
<a name="ln304">		info-&gt;scsi_periph_device, ccb, load, true);</a>
<a name="ln305"> </a>
<a name="ln306">	info-&gt;scsi-&gt;free_ccb(ccb);</a>
<a name="ln307"> </a>
<a name="ln308">	return result.error_code;</a>
<a name="ln309">}</a>
<a name="ln310"> </a>
<a name="ln311"> </a>
<a name="ln312">static status_t</a>
<a name="ln313">get_position(cd_driver_info *info, scsi_position *position)</a>
<a name="ln314">{</a>
<a name="ln315">	scsi_cmd_read_subchannel cmd;</a>
<a name="ln316"> </a>
<a name="ln317">	TRACE(&quot;get_position()\n&quot;);</a>
<a name="ln318"> </a>
<a name="ln319">	memset(&amp;cmd, 0, sizeof(cmd));</a>
<a name="ln320">	cmd.opcode = SCSI_OP_READ_SUB_CHANNEL;</a>
<a name="ln321">	cmd.time = 1;</a>
<a name="ln322">	cmd.subq = 1;</a>
<a name="ln323">	cmd.parameter_list = scsi_sub_channel_parameter_list_cd_pos;</a>
<a name="ln324">	cmd.track = 0;</a>
<a name="ln325">	cmd.allocation_length = B_HOST_TO_BENDIAN_INT16(sizeof(scsi_position));</a>
<a name="ln326"> </a>
<a name="ln327">	return sSCSIPeripheral-&gt;simple_exec(info-&gt;scsi_periph_device,</a>
<a name="ln328">		&amp;cmd, sizeof(cmd), position, sizeof(*position), SCSI_DIR_IN);</a>
<a name="ln329">}</a>
<a name="ln330"> </a>
<a name="ln331"> </a>
<a name="ln332">static status_t</a>
<a name="ln333">get_set_volume(cd_driver_info *info, scsi_volume *volume, bool set)</a>
<a name="ln334">{</a>
<a name="ln335">	scsi_cmd_mode_sense_6 cmd;</a>
<a name="ln336">	scsi_mode_param_header_6 header;</a>
<a name="ln337">	size_t len;</a>
<a name="ln338">	void *buffer;</a>
<a name="ln339">	scsi_modepage_audio	*page;</a>
<a name="ln340">	status_t res;</a>
<a name="ln341"> </a>
<a name="ln342">	TRACE(&quot;get_set_volume()\n&quot;);</a>
<a name="ln343"> </a>
<a name="ln344">	// determine size of block descriptor</a>
<a name="ln345">	memset(&amp;cmd, 0, sizeof(cmd));</a>
<a name="ln346">	cmd.opcode = SCSI_OP_MODE_SENSE_6;</a>
<a name="ln347">	cmd.page_code = SCSI_MODEPAGE_AUDIO;</a>
<a name="ln348">	cmd.page_control = SCSI_MODE_SENSE_PC_CURRENT;</a>
<a name="ln349">	cmd.allocation_length = sizeof(header);</a>
<a name="ln350"> </a>
<a name="ln351">	memset(&amp;header, -2, sizeof(header));</a>
<a name="ln352"> </a>
<a name="ln353">	res = sSCSIPeripheral-&gt;simple_exec(info-&gt;scsi_periph_device, &amp;cmd,</a>
<a name="ln354">		sizeof(cmd), &amp;header, sizeof(header), SCSI_DIR_IN);</a>
<a name="ln355">	if (res != B_OK)</a>
<a name="ln356">		return res;</a>
<a name="ln357"> </a>
<a name="ln358">	TRACE(&quot;  block_desc_len=%d&quot;, header.block_desc_length);</a>
<a name="ln359">#if 0</a>
<a name="ln360">	// ToDo: why this??</a>
<a name="ln361">	return B_ERROR;</a>
<a name="ln362">#endif</a>
<a name="ln363"> </a>
<a name="ln364">	// retrieve param header, block descriptor and actual codepage</a>
<a name="ln365">	len = sizeof(header) + header.block_desc_length</a>
<a name="ln366">		+ sizeof(scsi_modepage_audio);</a>
<a name="ln367"> </a>
<a name="ln368">	buffer = malloc(len);</a>
<a name="ln369">	if (buffer == NULL)</a>
<a name="ln370">		return B_NO_MEMORY;</a>
<a name="ln371"> </a>
<a name="ln372">	memset(buffer, -1, len);</a>
<a name="ln373"> </a>
<a name="ln374">	cmd.allocation_length = len;</a>
<a name="ln375"> </a>
<a name="ln376">	res = sSCSIPeripheral-&gt;simple_exec(info-&gt;scsi_periph_device, &amp;cmd,</a>
<a name="ln377">		sizeof(cmd), buffer, len, SCSI_DIR_IN);</a>
<a name="ln378">	if (res != B_OK) {</a>
<a name="ln379">		free(buffer);</a>
<a name="ln380">		return res;</a>
<a name="ln381">	}</a>
<a name="ln382"> </a>
<a name="ln383">	TRACE(&quot;  mode_data_len=%d, block_desc_len=%d&quot;,</a>
<a name="ln384">		((scsi_mode_param_header_6 *)buffer)-&gt;mode_data_length,</a>
<a name="ln385">		((scsi_mode_param_header_6 *)buffer)-&gt;block_desc_length);</a>
<a name="ln386"> </a>
<a name="ln387">	// find control page and retrieve values</a>
<a name="ln388">	page = (scsi_modepage_audio *)((char *)buffer + sizeof(header)</a>
<a name="ln389">		+ header.block_desc_length);</a>
<a name="ln390"> </a>
<a name="ln391">	TRACE(&quot;  page=%p, codepage=%d&quot;, page, page-&gt;header.page_code);</a>
<a name="ln392"> </a>
<a name="ln393">	if (!set) {</a>
<a name="ln394">		volume-&gt;port0_channel = page-&gt;ports[0].channel;</a>
<a name="ln395">		volume-&gt;port0_volume  = page-&gt;ports[0].volume;</a>
<a name="ln396">		volume-&gt;port1_channel = page-&gt;ports[1].channel;</a>
<a name="ln397">		volume-&gt;port1_volume  = page-&gt;ports[1].volume;</a>
<a name="ln398">		volume-&gt;port2_channel = page-&gt;ports[2].channel;</a>
<a name="ln399">		volume-&gt;port2_volume  = page-&gt;ports[2].volume;</a>
<a name="ln400">		volume-&gt;port3_channel = page-&gt;ports[3].channel;</a>
<a name="ln401">		volume-&gt;port3_volume  = page-&gt;ports[3].volume;</a>
<a name="ln402"> </a>
<a name="ln403">#if 0</a>
<a name="ln404">		SHOW_FLOW(3, &quot;1: %d - %d&quot;, volume-&gt;port0_channel, volume-&gt;port0_volume);</a>
<a name="ln405">		SHOW_FLOW(3, &quot;2: %d - %d&quot;, volume-&gt;port1_channel, volume-&gt;port1_volume);</a>
<a name="ln406">		SHOW_FLOW(3, &quot;3: %d - %d&quot;, volume-&gt;port2_channel, volume-&gt;port2_volume);</a>
<a name="ln407">		SHOW_FLOW(3, &quot;4: %d - %d&quot;, volume-&gt;port3_channel, volume-&gt;port3_volume);</a>
<a name="ln408">#endif</a>
<a name="ln409">		res = B_OK;</a>
<a name="ln410">	} else {</a>
<a name="ln411">		scsi_cmd_mode_select_6 cmd;</a>
<a name="ln412"> </a>
<a name="ln413">		if (volume-&gt;flags &amp; 0x01)</a>
<a name="ln414">			page-&gt;ports[0].channel = volume-&gt;port0_channel;</a>
<a name="ln415">		if (volume-&gt;flags &amp; 0x02)</a>
<a name="ln416">			page-&gt;ports[0].volume = volume-&gt;port0_volume;</a>
<a name="ln417">		if (volume-&gt;flags &amp; 0x04)</a>
<a name="ln418">			page-&gt;ports[1].channel = volume-&gt;port1_channel;</a>
<a name="ln419">		if (volume-&gt;flags &amp; 0x08)</a>
<a name="ln420">			page-&gt;ports[1].volume = volume-&gt;port1_volume;</a>
<a name="ln421">		if (volume-&gt;flags &amp; 0x10)</a>
<a name="ln422">			page-&gt;ports[2].channel = volume-&gt;port2_channel;</a>
<a name="ln423">		if (volume-&gt;flags &amp; 0x20)</a>
<a name="ln424">			page-&gt;ports[2].volume = volume-&gt;port2_volume;</a>
<a name="ln425">		if (volume-&gt;flags &amp; 0x40)</a>
<a name="ln426">			page-&gt;ports[3].channel = volume-&gt;port3_channel;</a>
<a name="ln427">		if (volume-&gt;flags &amp; 0x80)</a>
<a name="ln428">			page-&gt;ports[3].volume = volume-&gt;port3_volume;</a>
<a name="ln429"> </a>
<a name="ln430">		memset(&amp;cmd, 0, sizeof(cmd));</a>
<a name="ln431">		cmd.opcode = SCSI_OP_MODE_SELECT_6;</a>
<a name="ln432">		cmd.pf = 1;</a>
<a name="ln433">		cmd.param_list_length = sizeof(header) + header.block_desc_length</a>
<a name="ln434">			+ sizeof(*page);</a>
<a name="ln435"> </a>
<a name="ln436">		res = sSCSIPeripheral-&gt;simple_exec(info-&gt;scsi_periph_device,</a>
<a name="ln437">			&amp;cmd, sizeof(cmd), buffer, len, SCSI_DIR_OUT);</a>
<a name="ln438">	}</a>
<a name="ln439"> </a>
<a name="ln440">	free(buffer);</a>
<a name="ln441">	return res;</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444"> </a>
<a name="ln445">/*!	Play audio cd; time is in MSF */</a>
<a name="ln446">static status_t</a>
<a name="ln447">play_msf(cd_driver_info *info, const scsi_play_position *position)</a>
<a name="ln448">{</a>
<a name="ln449">	scsi_cmd_play_msf cmd;</a>
<a name="ln450"> </a>
<a name="ln451">	TRACE(&quot;play_msf(): %d:%d:%d-%d:%d:%d\n&quot;, position-&gt;start_m,</a>
<a name="ln452">		position-&gt;start_s, position-&gt;start_f, position-&gt;end_m, position-&gt;end_s,</a>
<a name="ln453">		position-&gt;end_f);</a>
<a name="ln454"> </a>
<a name="ln455">	memset(&amp;cmd, 0, sizeof(cmd));</a>
<a name="ln456"> </a>
<a name="ln457">	cmd.opcode = SCSI_OP_PLAY_MSF;</a>
<a name="ln458">	cmd.start_minute = position-&gt;start_m;</a>
<a name="ln459">	cmd.start_second = position-&gt;start_s;</a>
<a name="ln460">	cmd.start_frame = position-&gt;start_f;</a>
<a name="ln461">	cmd.end_minute = position-&gt;end_m;</a>
<a name="ln462">	cmd.end_second = position-&gt;end_s;</a>
<a name="ln463">	cmd.end_frame = position-&gt;end_f;</a>
<a name="ln464"> </a>
<a name="ln465">	return sSCSIPeripheral-&gt;simple_exec(info-&gt;scsi_periph_device,</a>
<a name="ln466">		&amp;cmd, sizeof(cmd), NULL, 0, SCSI_DIR_NONE);</a>
<a name="ln467">}</a>
<a name="ln468"> </a>
<a name="ln469"> </a>
<a name="ln470">/*! Play audio cd; time is in track/index */</a>
<a name="ln471">static status_t</a>
<a name="ln472">play_track_index(cd_driver_info *info, const scsi_play_track *buf)</a>
<a name="ln473">{</a>
<a name="ln474">	scsi_toc generic_toc;</a>
<a name="ln475">	scsi_toc_toc *toc;</a>
<a name="ln476">	status_t res;</a>
<a name="ln477">	int start_track, end_track;</a>
<a name="ln478">	scsi_play_position position;</a>
<a name="ln479"> </a>
<a name="ln480">	TRACE(&quot;play_track_index(): %d-%d\n&quot;, buf-&gt;start_track, buf-&gt;end_track);</a>
<a name="ln481"> </a>
<a name="ln482">	// the corresponding command PLAY AUDIO TRACK/INDEX	is deprecated,</a>
<a name="ln483">	// so we have to simulate it by converting track to time via TOC</a>
<a name="ln484">	res = get_toc(info, &amp;generic_toc);</a>
<a name="ln485">	if (res != B_OK)</a>
<a name="ln486">		return res;</a>
<a name="ln487"> </a>
<a name="ln488">	toc = (scsi_toc_toc *)&amp;generic_toc.toc_data[0];</a>
<a name="ln489"> </a>
<a name="ln490">	start_track = buf-&gt;start_track;</a>
<a name="ln491">	end_track = buf-&gt;end_track;</a>
<a name="ln492"> </a>
<a name="ln493">	if (start_track &gt; toc-&gt;last_track)</a>
<a name="ln494">		return B_BAD_INDEX;</a>
<a name="ln495"> </a>
<a name="ln496">	if (end_track &gt; toc-&gt;last_track)</a>
<a name="ln497">		end_track = toc-&gt;last_track + 1;</a>
<a name="ln498"> </a>
<a name="ln499">	if (end_track &lt; toc-&gt;last_track + 1)</a>
<a name="ln500">		++end_track;</a>
<a name="ln501"> </a>
<a name="ln502">	start_track -= toc-&gt;first_track;</a>
<a name="ln503">	end_track -= toc-&gt;first_track;</a>
<a name="ln504"> </a>
<a name="ln505">	if (start_track &lt; 0 || end_track &lt; 0)</a>
<a name="ln506">		return B_BAD_INDEX;</a>
<a name="ln507"> </a>
<a name="ln508">	position.start_m = toc-&gt;tracks[start_track].start.time.minute;</a>
<a name="ln509">	position.start_s = toc-&gt;tracks[start_track].start.time.second;</a>
<a name="ln510">	position.start_f = toc-&gt;tracks[start_track].start.time.frame;</a>
<a name="ln511"> </a>
<a name="ln512">	position.end_m = toc-&gt;tracks[end_track].start.time.minute;</a>
<a name="ln513">	position.end_s = toc-&gt;tracks[end_track].start.time.second;</a>
<a name="ln514">	position.end_f = toc-&gt;tracks[end_track].start.time.frame;</a>
<a name="ln515"> </a>
<a name="ln516">	return play_msf(info, &amp;position);</a>
<a name="ln517">}</a>
<a name="ln518"> </a>
<a name="ln519"> </a>
<a name="ln520">static status_t</a>
<a name="ln521">stop_audio(cd_driver_info *info)</a>
<a name="ln522">{</a>
<a name="ln523">	scsi_cmd_stop_play cmd;</a>
<a name="ln524"> </a>
<a name="ln525">	TRACE(&quot;stop_audio()\n&quot;);</a>
<a name="ln526"> </a>
<a name="ln527">	memset( &amp;cmd, 0, sizeof( cmd ));</a>
<a name="ln528">	cmd.opcode = SCSI_OP_STOP_PLAY;</a>
<a name="ln529"> </a>
<a name="ln530">	return sSCSIPeripheral-&gt;simple_exec(info-&gt;scsi_periph_device,</a>
<a name="ln531">		&amp;cmd, sizeof(cmd), NULL, 0, SCSI_DIR_NONE);</a>
<a name="ln532">}</a>
<a name="ln533"> </a>
<a name="ln534"> </a>
<a name="ln535">static status_t</a>
<a name="ln536">pause_resume(cd_driver_info *info, bool resume)</a>
<a name="ln537">{</a>
<a name="ln538">	scsi_cmd_pause_resume cmd;</a>
<a name="ln539"> </a>
<a name="ln540">	TRACE(&quot;pause_resume()\n&quot;);</a>
<a name="ln541"> </a>
<a name="ln542">	memset(&amp;cmd, 0, sizeof(cmd));</a>
<a name="ln543">	cmd.opcode = SCSI_OP_PAUSE_RESUME;</a>
<a name="ln544">	cmd.resume = resume;</a>
<a name="ln545"> </a>
<a name="ln546">	return sSCSIPeripheral-&gt;simple_exec(info-&gt;scsi_periph_device,</a>
<a name="ln547">		&amp;cmd, sizeof(cmd), NULL, 0, SCSI_DIR_NONE);</a>
<a name="ln548">}</a>
<a name="ln549"> </a>
<a name="ln550"> </a>
<a name="ln551">static status_t</a>
<a name="ln552">scan(cd_driver_info *info, const scsi_scan *buf)</a>
<a name="ln553">{</a>
<a name="ln554">	scsi_cmd_scan cmd;</a>
<a name="ln555">	scsi_position curPos;</a>
<a name="ln556">	scsi_cd_current_position *cdPos;</a>
<a name="ln557"> </a>
<a name="ln558">	TRACE(&quot;scan(direction =% d)\n&quot;, buf-&gt;direction);</a>
<a name="ln559"> </a>
<a name="ln560">	status_t res = get_position(info, &amp;curPos);</a>
<a name="ln561">	if (res != B_OK)</a>
<a name="ln562">		return res;</a>
<a name="ln563"> </a>
<a name="ln564">	cdPos = (scsi_cd_current_position *)((char *)&amp;curPos</a>
<a name="ln565">		+ sizeof(scsi_subchannel_data_header));</a>
<a name="ln566"> </a>
<a name="ln567">	if (buf-&gt;direction == 0) {</a>
<a name="ln568">		scsi_play_position playPos;</a>
<a name="ln569"> </a>
<a name="ln570">		// to stop scan, we issue play command with &quot;open end&quot;</a>
<a name="ln571">		playPos.start_m = cdPos-&gt;absolute_address.time.minute;</a>
<a name="ln572">		playPos.start_s = cdPos-&gt;absolute_address.time.second;</a>
<a name="ln573">		playPos.start_f = cdPos-&gt;absolute_address.time.frame;</a>
<a name="ln574">		playPos.end_m = 99;</a>
<a name="ln575">		playPos.end_s = 59;</a>
<a name="ln576">		playPos.end_f = 24;</a>
<a name="ln577"> </a>
<a name="ln578">		return play_msf(info, &amp;playPos);</a>
<a name="ln579">	}</a>
<a name="ln580"> </a>
<a name="ln581">	memset(&amp;cmd, 0, sizeof(cmd));</a>
<a name="ln582"> </a>
<a name="ln583">	cmd.opcode = SCSI_OP_SCAN;</a>
<a name="ln584">	cmd.direct = buf-&gt;direction &lt; 0;</a>
<a name="ln585">	cmd.start.time = cdPos-&gt;absolute_address.time;</a>
<a name="ln586">	cmd.type = scsi_scan_msf;</a>
<a name="ln587"> </a>
<a name="ln588">	/*</a>
<a name="ln589">	tmp = (uint8 *)&amp;cmd;</a>
<a name="ln590">	dprintf(&quot;%d %d %d %d %d %d %d %d %d %d %d %d\n&quot;,</a>
<a name="ln591">		tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5],</a>
<a name="ln592">		tmp[6], tmp[7], tmp[8], tmp[9], tmp[10], tmp[11]);</a>
<a name="ln593">	*/</a>
<a name="ln594"> </a>
<a name="ln595">	return sSCSIPeripheral-&gt;simple_exec(info-&gt;scsi_periph_device,</a>
<a name="ln596">		&amp;cmd, sizeof(cmd), NULL, 0, SCSI_DIR_NONE);</a>
<a name="ln597">}</a>
<a name="ln598"> </a>
<a name="ln599"> </a>
<a name="ln600">static status_t</a>
<a name="ln601">read_cd(cd_driver_info *info, const scsi_read_cd *readCD)</a>
<a name="ln602">{</a>
<a name="ln603">	scsi_cmd_read_cd *cmd;</a>
<a name="ln604">	uint32 lba, length;</a>
<a name="ln605">	scsi_ccb *ccb;</a>
<a name="ln606">	status_t res;</a>
<a name="ln607"> </a>
<a name="ln608">	// we use safe_exec instead of simple_exec as we want to set</a>
<a name="ln609">	// the sorting order manually (only makes much sense if you grab</a>
<a name="ln610">	// multiple tracks at once, but we are prepared)</a>
<a name="ln611">	ccb = info-&gt;scsi-&gt;alloc_ccb(info-&gt;scsi_device);</a>
<a name="ln612"> </a>
<a name="ln613">	if (ccb == NULL)</a>
<a name="ln614">		return B_NO_MEMORY;</a>
<a name="ln615"> </a>
<a name="ln616">	cmd = (scsi_cmd_read_cd *)ccb-&gt;cdb;</a>
<a name="ln617">	memset(cmd, 0, sizeof(*cmd));</a>
<a name="ln618">	cmd-&gt;opcode = SCSI_OP_READ_CD;</a>
<a name="ln619">	cmd-&gt;sector_type = 1;</a>
<a name="ln620"> </a>
<a name="ln621">	// skip first two seconds, they are lead-in</a>
<a name="ln622">	lba = (readCD-&gt;start_m * 60 + readCD-&gt;start_s) * 75 + readCD-&gt;start_f</a>
<a name="ln623">		- 2 * 75;</a>
<a name="ln624">	length = (readCD-&gt;length_m * 60 + readCD-&gt;length_s) * 75 + readCD-&gt;length_f;</a>
<a name="ln625"> </a>
<a name="ln626">	cmd-&gt;lba = B_HOST_TO_BENDIAN_INT32(lba);</a>
<a name="ln627">	cmd-&gt;high_length = (length &gt;&gt; 16) &amp; 0xff;</a>
<a name="ln628">	cmd-&gt;mid_length = (length &gt;&gt; 8) &amp; 0xff;</a>
<a name="ln629">	cmd-&gt;low_length = length &amp; 0xff;</a>
<a name="ln630"> </a>
<a name="ln631">	cmd-&gt;error_field = scsi_read_cd_error_none;</a>
<a name="ln632">	cmd-&gt;edc_ecc = 0;</a>
<a name="ln633">	cmd-&gt;user_data = 1;</a>
<a name="ln634">	cmd-&gt;header_code = scsi_read_cd_header_none;</a>
<a name="ln635">	cmd-&gt;sync = 0;</a>
<a name="ln636">	cmd-&gt;sub_channel_selection = scsi_read_cd_sub_channel_none;</a>
<a name="ln637"> </a>
<a name="ln638">	ccb-&gt;cdb_length = sizeof(*cmd);</a>
<a name="ln639"> </a>
<a name="ln640">	ccb-&gt;flags = SCSI_DIR_IN | SCSI_DIS_DISCONNECT;</a>
<a name="ln641">	ccb-&gt;sort = lba;</a>
<a name="ln642">	// are 10 seconds enough for timeout?</a>
<a name="ln643">	ccb-&gt;timeout = 10;</a>
<a name="ln644"> </a>
<a name="ln645">	// TODO: we pass a user buffer here!</a>
<a name="ln646">	ccb-&gt;data = (uint8 *)readCD-&gt;buffer;</a>
<a name="ln647">	ccb-&gt;sg_list = NULL;</a>
<a name="ln648">	ccb-&gt;data_length = readCD-&gt;buffer_length;</a>
<a name="ln649"> </a>
<a name="ln650">	res = sSCSIPeripheral-&gt;safe_exec(info-&gt;scsi_periph_device, ccb);</a>
<a name="ln651"> </a>
<a name="ln652">	info-&gt;scsi-&gt;free_ccb(ccb);</a>
<a name="ln653"> </a>
<a name="ln654">	return res;</a>
<a name="ln655">}</a>
<a name="ln656"> </a>
<a name="ln657"> </a>
<a name="ln658">static int</a>
<a name="ln659">log2(uint32 x)</a>
<a name="ln660">{</a>
<a name="ln661">	int y;</a>
<a name="ln662"> </a>
<a name="ln663">	for (y = 31; y &gt;= 0; --y) {</a>
<a name="ln664">		if (x == (1UL &lt;&lt; y))</a>
<a name="ln665">			break;</a>
<a name="ln666">	}</a>
<a name="ln667"> </a>
<a name="ln668">	return y;</a>
<a name="ln669">}</a>
<a name="ln670"> </a>
<a name="ln671"> </a>
<a name="ln672">static status_t</a>
<a name="ln673">do_io(void* cookie, IOOperation* operation)</a>
<a name="ln674">{</a>
<a name="ln675">	cd_driver_info* info = (cd_driver_info*)cookie;</a>
<a name="ln676"> </a>
<a name="ln677">	// TODO: this can go away as soon as we pushed the IOOperation to the upper</a>
<a name="ln678">	// layers - we can then set scsi_periph::io() as callback for the scheduler</a>
<a name="ln679">	size_t bytesTransferred;</a>
<a name="ln680">	status_t status = sSCSIPeripheral-&gt;io(info-&gt;scsi_periph_device, operation,</a>
<a name="ln681">		&amp;bytesTransferred);</a>
<a name="ln682"> </a>
<a name="ln683">	info-&gt;io_scheduler-&gt;OperationCompleted(operation, status, bytesTransferred);</a>
<a name="ln684">	return status;</a>
<a name="ln685">}</a>
<a name="ln686"> </a>
<a name="ln687"> </a>
<a name="ln688">//	#pragma mark - device module API</a>
<a name="ln689"> </a>
<a name="ln690"> </a>
<a name="ln691">static status_t</a>
<a name="ln692">cd_init_device(void* _info, void** _cookie)</a>
<a name="ln693">{</a>
<a name="ln694">	cd_driver_info* info = (cd_driver_info*)_info;</a>
<a name="ln695"> </a>
<a name="ln696">	update_capacity(info);</a>
<a name="ln697">		// Get initial capacity, but ignore the result; we do not care</a>
<a name="ln698">		// whether or not a media is present</a>
<a name="ln699"> </a>
<a name="ln700">	*_cookie = info;</a>
<a name="ln701">	return B_OK;</a>
<a name="ln702">}</a>
<a name="ln703"> </a>
<a name="ln704"> </a>
<a name="ln705">static void</a>
<a name="ln706">cd_uninit_device(void* _cookie)</a>
<a name="ln707">{</a>
<a name="ln708">	cd_driver_info* info = (cd_driver_info*)_cookie;</a>
<a name="ln709"> </a>
<a name="ln710">	delete info-&gt;io_scheduler;</a>
<a name="ln711">	delete info-&gt;dma_resource;</a>
<a name="ln712">	info-&gt;io_scheduler = NULL;</a>
<a name="ln713">	info-&gt;dma_resource = NULL;</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716"> </a>
<a name="ln717">static status_t</a>
<a name="ln718">cd_open(void* _info, const char* path, int openMode, void** _cookie)</a>
<a name="ln719">{</a>
<a name="ln720">	cd_driver_info* info = (cd_driver_info*)_info;</a>
<a name="ln721"> </a>
<a name="ln722">	cd_handle* handle = (cd_handle*)malloc(sizeof(cd_handle));</a>
<a name="ln723">	if (handle == NULL)</a>
<a name="ln724">		return B_NO_MEMORY;</a>
<a name="ln725"> </a>
<a name="ln726">	handle-&gt;info = info;</a>
<a name="ln727"> </a>
<a name="ln728">	status_t status = sSCSIPeripheral-&gt;handle_open(info-&gt;scsi_periph_device,</a>
<a name="ln729">		(periph_handle_cookie)handle, &amp;handle-&gt;scsi_periph_handle);</a>
<a name="ln730">	if (status &lt; B_OK) {</a>
<a name="ln731">		free(handle);</a>
<a name="ln732">		return status;</a>
<a name="ln733">	}</a>
<a name="ln734"> </a>
<a name="ln735">	*_cookie = handle;</a>
<a name="ln736">	return B_OK;</a>
<a name="ln737">}</a>
<a name="ln738"> </a>
<a name="ln739"> </a>
<a name="ln740">static status_t</a>
<a name="ln741">cd_close(void* cookie)</a>
<a name="ln742">{</a>
<a name="ln743">	cd_handle* handle = (cd_handle*)cookie;</a>
<a name="ln744">	TRACE(&quot;close()\n&quot;);</a>
<a name="ln745"> </a>
<a name="ln746">	sSCSIPeripheral-&gt;handle_close(handle-&gt;scsi_periph_handle);</a>
<a name="ln747">	return B_OK;</a>
<a name="ln748">}</a>
<a name="ln749"> </a>
<a name="ln750"> </a>
<a name="ln751">static status_t</a>
<a name="ln752">cd_free(void* cookie)</a>
<a name="ln753">{</a>
<a name="ln754">	cd_handle* handle = (cd_handle*)cookie;</a>
<a name="ln755">	TRACE(&quot;free()\n&quot;);</a>
<a name="ln756"> </a>
<a name="ln757">	sSCSIPeripheral-&gt;handle_free(handle-&gt;scsi_periph_handle);</a>
<a name="ln758">	free(handle);</a>
<a name="ln759">	return B_OK;</a>
<a name="ln760">}</a>
<a name="ln761"> </a>
<a name="ln762"> </a>
<a name="ln763">static status_t</a>
<a name="ln764">cd_read(void* cookie, off_t pos, void* buffer, size_t* _length)</a>
<a name="ln765">{</a>
<a name="ln766">	cd_handle* handle = (cd_handle*)cookie;</a>
<a name="ln767">	size_t length = *_length;</a>
<a name="ln768"> </a>
<a name="ln769">	if (handle-&gt;info-&gt;capacity == 0)</a>
<a name="ln770">		return B_DEV_NO_MEDIA;</a>
<a name="ln771"> </a>
<a name="ln772">	IORequest request;</a>
<a name="ln773">	status_t status = request.Init(pos, (addr_t)buffer, length, false, 0);</a>
<a name="ln774">	if (status != B_OK)</a>
<a name="ln775">		return status;</a>
<a name="ln776"> </a>
<a name="ln777">	if (handle-&gt;info-&gt;io_scheduler == NULL)</a>
<a name="ln778">		return B_DEV_NO_MEDIA;</a>
<a name="ln779"> </a>
<a name="ln780">	status = handle-&gt;info-&gt;io_scheduler-&gt;ScheduleRequest(&amp;request);</a>
<a name="ln781">	if (status != B_OK)</a>
<a name="ln782">		return status;</a>
<a name="ln783"> </a>
<a name="ln784">	status = request.Wait(0, 0);</a>
<a name="ln785">	if (status == B_OK)</a>
<a name="ln786">		*_length = length;</a>
<a name="ln787">	else</a>
<a name="ln788">		dprintf(&quot;cd_read(): request.Wait() returned: %s\n&quot;, strerror(status));</a>
<a name="ln789"> </a>
<a name="ln790">	return status;</a>
<a name="ln791">}</a>
<a name="ln792"> </a>
<a name="ln793"> </a>
<a name="ln794">static status_t</a>
<a name="ln795">cd_write(void* cookie, off_t pos, const void* buffer, size_t* _length)</a>
<a name="ln796">{</a>
<a name="ln797">	cd_handle* handle = (cd_handle*)cookie;</a>
<a name="ln798">	size_t length = *_length;</a>
<a name="ln799"> </a>
<a name="ln800">	if (handle-&gt;info-&gt;capacity == 0)</a>
<a name="ln801">		return B_DEV_NO_MEDIA;</a>
<a name="ln802"> </a>
<a name="ln803">	IORequest request;</a>
<a name="ln804">	status_t status = request.Init(pos, (addr_t)buffer, length, true, 0);</a>
<a name="ln805">	if (status != B_OK)</a>
<a name="ln806">		return status;</a>
<a name="ln807"> </a>
<a name="ln808">	if (handle-&gt;info-&gt;io_scheduler == NULL)</a>
<a name="ln809">		return B_DEV_NO_MEDIA;</a>
<a name="ln810"> </a>
<a name="ln811">	status = handle-&gt;info-&gt;io_scheduler-&gt;ScheduleRequest(&amp;request);</a>
<a name="ln812">	if (status != B_OK)</a>
<a name="ln813">		return status;</a>
<a name="ln814"> </a>
<a name="ln815">	status = request.Wait(0, 0);</a>
<a name="ln816">	if (status == B_OK)</a>
<a name="ln817">		*_length = length;</a>
<a name="ln818">	else</a>
<a name="ln819">		dprintf(&quot;cd_write(): request.Wait() returned: %s\n&quot;, strerror(status));</a>
<a name="ln820"> </a>
<a name="ln821">	return status;</a>
<a name="ln822">}</a>
<a name="ln823"> </a>
<a name="ln824"> </a>
<a name="ln825">static status_t</a>
<a name="ln826">cd_io(void* cookie, io_request* request)</a>
<a name="ln827">{</a>
<a name="ln828">	cd_handle* handle = (cd_handle*)cookie;</a>
<a name="ln829"> </a>
<a name="ln830">	if (handle-&gt;info-&gt;capacity == 0) {</a>
<a name="ln831">		notify_io_request(request, B_DEV_NO_MEDIA);</a>
<a name="ln832">		return B_DEV_NO_MEDIA;</a>
<a name="ln833">	}</a>
<a name="ln834"> </a>
<a name="ln835">	return handle-&gt;info-&gt;io_scheduler-&gt;ScheduleRequest(request);</a>
<a name="ln836">}</a>
<a name="ln837"> </a>
<a name="ln838"> </a>
<a name="ln839">static status_t</a>
<a name="ln840">cd_ioctl(void* cookie, uint32 op, void* buffer, size_t length)</a>
<a name="ln841">{</a>
<a name="ln842">	cd_handle* handle = (cd_handle*)cookie;</a>
<a name="ln843">	cd_driver_info *info = handle-&gt;info;</a>
<a name="ln844"> </a>
<a name="ln845">	TRACE(&quot;ioctl(op = %lu)\n&quot;, op);</a>
<a name="ln846"> </a>
<a name="ln847">	switch (op) {</a>
<a name="ln848">		case B_GET_DEVICE_SIZE:</a>
<a name="ln849">		{</a>
<a name="ln850">			status_t status = update_capacity(info);</a>
<a name="ln851">			if (status != B_OK)</a>
<a name="ln852">				return status;</a>
<a name="ln853"> </a>
<a name="ln854">			size_t size = info-&gt;capacity * info-&gt;block_size;</a>
<a name="ln855">			return user_memcpy(buffer, &amp;size, sizeof(size_t));</a>
<a name="ln856">		}</a>
<a name="ln857"> </a>
<a name="ln858">		case B_GET_GEOMETRY:</a>
<a name="ln859">		{</a>
<a name="ln860">			if (buffer == NULL /*|| length != sizeof(device_geometry)*/)</a>
<a name="ln861">				return B_BAD_VALUE;</a>
<a name="ln862"> </a>
<a name="ln863">		 	device_geometry geometry;</a>
<a name="ln864">			status_t status = get_geometry(handle, &amp;geometry);</a>
<a name="ln865">			if (status != B_OK)</a>
<a name="ln866">				return status;</a>
<a name="ln867"> </a>
<a name="ln868">			return user_memcpy(buffer, &amp;geometry, sizeof(device_geometry));</a>
<a name="ln869">		}</a>
<a name="ln870"> </a>
<a name="ln871">		case B_GET_ICON_NAME:</a>
<a name="ln872">			return user_strlcpy((char*)buffer, &quot;devices/drive-optical&quot;,</a>
<a name="ln873">				B_FILE_NAME_LENGTH);</a>
<a name="ln874"> </a>
<a name="ln875">		case B_GET_VECTOR_ICON:</a>
<a name="ln876">		{</a>
<a name="ln877">			device_icon iconData;</a>
<a name="ln878">			if (length != sizeof(device_icon))</a>
<a name="ln879">				return B_BAD_VALUE;</a>
<a name="ln880">			if (user_memcpy(&amp;iconData, buffer, sizeof(device_icon)) != B_OK)</a>
<a name="ln881">				return B_BAD_ADDRESS;</a>
<a name="ln882"> </a>
<a name="ln883">			if (iconData.icon_size &gt;= (int32)sizeof(kCDIcon)) {</a>
<a name="ln884">				if (user_memcpy(iconData.icon_data, kCDIcon,</a>
<a name="ln885">						sizeof(kCDIcon)) != B_OK)</a>
<a name="ln886">					return B_BAD_ADDRESS;</a>
<a name="ln887">			}</a>
<a name="ln888"> </a>
<a name="ln889">			iconData.icon_size = sizeof(kCDIcon);</a>
<a name="ln890">			return user_memcpy(buffer, &amp;iconData, sizeof(device_icon));</a>
<a name="ln891">		}</a>
<a name="ln892"> </a>
<a name="ln893">		case B_SCSI_GET_TOC:</a>
<a name="ln894">			// TODO: we pass a user buffer here!</a>
<a name="ln895">			return get_toc(info, (scsi_toc *)buffer);</a>
<a name="ln896"> </a>
<a name="ln897">		case B_EJECT_DEVICE:</a>
<a name="ln898">		case B_SCSI_EJECT:</a>
<a name="ln899">			return load_eject(info, false);</a>
<a name="ln900"> </a>
<a name="ln901">		case B_LOAD_MEDIA:</a>
<a name="ln902">			return load_eject(info, true);</a>
<a name="ln903"> </a>
<a name="ln904">		case B_SCSI_GET_POSITION:</a>
<a name="ln905">		{</a>
<a name="ln906">			if (buffer == NULL)</a>
<a name="ln907">				return B_BAD_VALUE;</a>
<a name="ln908"> </a>
<a name="ln909">			scsi_position position;</a>
<a name="ln910">			status_t status = get_position(info, &amp;position);</a>
<a name="ln911">			if (status != B_OK)</a>
<a name="ln912">				return status;</a>
<a name="ln913"> </a>
<a name="ln914">			return user_memcpy(buffer, &amp;position, sizeof(scsi_position));</a>
<a name="ln915">		}</a>
<a name="ln916"> </a>
<a name="ln917">		case B_SCSI_GET_VOLUME:</a>
<a name="ln918">			// TODO: we pass a user buffer here!</a>
<a name="ln919">			return get_set_volume(info, (scsi_volume *)buffer, false);</a>
<a name="ln920">		case B_SCSI_SET_VOLUME:</a>
<a name="ln921">			// TODO: we pass a user buffer here!</a>
<a name="ln922">			return get_set_volume(info, (scsi_volume *)buffer, true);</a>
<a name="ln923"> </a>
<a name="ln924">		case B_SCSI_PLAY_TRACK:</a>
<a name="ln925">		{</a>
<a name="ln926">			scsi_play_track track;</a>
<a name="ln927">			if (user_memcpy(&amp;track, buffer, sizeof(scsi_play_track)) != B_OK)</a>
<a name="ln928">				return B_BAD_ADDRESS;</a>
<a name="ln929"> </a>
<a name="ln930">			return play_track_index(info, &amp;track);</a>
<a name="ln931">		}</a>
<a name="ln932">		case B_SCSI_PLAY_POSITION:</a>
<a name="ln933">		{</a>
<a name="ln934">			scsi_play_position position;</a>
<a name="ln935">			if (user_memcpy(&amp;position, buffer, sizeof(scsi_play_position))</a>
<a name="ln936">					!= B_OK)</a>
<a name="ln937">				return B_BAD_ADDRESS;</a>
<a name="ln938"> </a>
<a name="ln939">			return play_msf(info, &amp;position);</a>
<a name="ln940">		}</a>
<a name="ln941"> </a>
<a name="ln942">		case B_SCSI_STOP_AUDIO:</a>
<a name="ln943">			return stop_audio(info);</a>
<a name="ln944">		case B_SCSI_PAUSE_AUDIO:</a>
<a name="ln945">			return pause_resume(info, false);</a>
<a name="ln946">		case B_SCSI_RESUME_AUDIO:</a>
<a name="ln947">			return pause_resume(info, true);</a>
<a name="ln948"> </a>
<a name="ln949">		case B_SCSI_SCAN:</a>
<a name="ln950">		{</a>
<a name="ln951">			scsi_scan scanBuffer;</a>
<a name="ln952">			if (user_memcpy(&amp;scanBuffer, buffer, sizeof(scsi_scan)) != B_OK)</a>
<a name="ln953">				return B_BAD_ADDRESS;</a>
<a name="ln954"> </a>
<a name="ln955">			return scan(info, &amp;scanBuffer);</a>
<a name="ln956">		}</a>
<a name="ln957">		case B_SCSI_READ_CD:</a>
<a name="ln958">			// TODO: we pass a user buffer here!</a>
<a name="ln959">			return read_cd(info, (scsi_read_cd *)buffer);</a>
<a name="ln960"> </a>
<a name="ln961">		default:</a>
<a name="ln962">			return sSCSIPeripheral-&gt;ioctl(handle-&gt;scsi_periph_handle, op,</a>
<a name="ln963">				buffer, length);</a>
<a name="ln964">	}</a>
<a name="ln965">}</a>
<a name="ln966"> </a>
<a name="ln967"> </a>
<a name="ln968">//	#pragma mark - scsi_periph callbacks</a>
<a name="ln969"> </a>
<a name="ln970"> </a>
<a name="ln971">static void</a>
<a name="ln972">cd_set_capacity(cd_driver_info* info, uint64 capacity, uint32 blockSize)</a>
<a name="ln973">{</a>
<a name="ln974">	TRACE(&quot;cd_set_capacity(info = %p, capacity = %Ld, blockSize = %ld)\n&quot;,</a>
<a name="ln975">		info, capacity, blockSize);</a>
<a name="ln976"> </a>
<a name="ln977">	// get log2, if possible</a>
<a name="ln978">	uint32 blockShift = log2(blockSize);</a>
<a name="ln979"> </a>
<a name="ln980">	if ((1UL &lt;&lt; blockShift) != blockSize)</a>
<a name="ln981">		blockShift = 0;</a>
<a name="ln982"> </a>
<a name="ln983">	if (info-&gt;block_size != blockSize) {</a>
<a name="ln984">		if (capacity == 0) {</a>
<a name="ln985">			// there is obviously no medium in the drive, don't try to update</a>
<a name="ln986">			// the DMA resource</a>
<a name="ln987">			return;</a>
<a name="ln988">		}</a>
<a name="ln989"> </a>
<a name="ln990">		if (info-&gt;block_size != 0) {</a>
<a name="ln991">			dprintf(&quot;old %&quot; B_PRId32 &quot;, new %&quot; B_PRId32 &quot;\n&quot;, info-&gt;block_size,</a>
<a name="ln992">				blockSize);</a>
<a name="ln993">			panic(&quot;updating DMAResource not yet implemented...&quot;);</a>
<a name="ln994">		}</a>
<a name="ln995"> </a>
<a name="ln996">		// TODO: we need to replace the DMAResource in our IOScheduler</a>
<a name="ln997">		status_t status = info-&gt;dma_resource-&gt;Init(info-&gt;node, blockSize, 1024,</a>
<a name="ln998">			32);</a>
<a name="ln999">		if (status != B_OK)</a>
<a name="ln1000">			panic(&quot;initializing DMAResource failed: %s&quot;, strerror(status));</a>
<a name="ln1001"> </a>
<a name="ln1002">		// Allocate the I/O scheduler. If there seems to be sufficient memory</a>
<a name="ln1003">		// we use an IOCache, since that adds caching at the lowest I/O layer</a>
<a name="ln1004">		// and thus dramatically reduces I/O operations and seeks. The</a>
<a name="ln1005">		// disadvantage is that it increases free memory (physical pages)</a>
<a name="ln1006">		// fragmentation, which makes large contiguous allocations more likely</a>
<a name="ln1007">		// to fail.</a>
<a name="ln1008">		size_t freeMemory = vm_page_num_free_pages();</a>
<a name="ln1009">		if (freeMemory &gt; 180 * 1024 * 1024 / B_PAGE_SIZE) {</a>
<a name="ln1010">			info-&gt;io_scheduler = new(std::nothrow) IOCache(info-&gt;dma_resource,</a>
<a name="ln1011">				1024 * 1024);</a>
<a name="ln1012">		} else {</a>
<a name="ln1013">			dprintf(&quot;scsi_cd: Using IOSchedulerSimple instead of IOCache to &quot;</a>
<a name="ln1014">				&quot;avoid memory allocation issues.\n&quot;);</a>
<a name="ln1015">			info-&gt;io_scheduler = new(std::nothrow) IOSchedulerSimple(</a>
<a name="ln1016">				info-&gt;dma_resource);</a>
<a name="ln1017">		}</a>
<a name="ln1018"> </a>
<a name="ln1019">		if (info-&gt;io_scheduler == NULL)</a>
<a name="ln1020">			panic(&quot;allocating IOScheduler failed.&quot;);</a>
<a name="ln1021"> </a>
<a name="ln1022">		// TODO: use whole device name here</a>
<a name="ln1023">		status = info-&gt;io_scheduler-&gt;Init(&quot;scsi&quot;);</a>
<a name="ln1024">		if (status != B_OK)</a>
<a name="ln1025">			panic(&quot;initializing IOScheduler failed: %s&quot;, strerror(status));</a>
<a name="ln1026"> </a>
<a name="ln1027">		info-&gt;io_scheduler-&gt;SetCallback(do_io, info);</a>
<a name="ln1028">		info-&gt;block_size = blockSize;</a>
<a name="ln1029">	}</a>
<a name="ln1030"> </a>
<a name="ln1031">	if (info-&gt;original_capacity != capacity &amp;&amp; info-&gt;io_scheduler != NULL) {</a>
<a name="ln1032">		info-&gt;original_capacity = capacity;</a>
<a name="ln1033"> </a>
<a name="ln1034">		// For CDs, it's obviously relatively normal that they report a larger</a>
<a name="ln1035">		// capacity than it can actually address. Therefore we'll manually</a>
<a name="ln1036">		// correct the value here.</a>
<a name="ln1037">		test_capacity(info);</a>
<a name="ln1038"> </a>
<a name="ln1039">		info-&gt;io_scheduler-&gt;SetDeviceCapacity(info-&gt;capacity * blockSize);</a>
<a name="ln1040">	}</a>
<a name="ln1041">}</a>
<a name="ln1042"> </a>
<a name="ln1043"> </a>
<a name="ln1044">static void</a>
<a name="ln1045">cd_media_changed(cd_driver_info* info, scsi_ccb* request)</a>
<a name="ln1046">{</a>
<a name="ln1047">	// do a capacity check</a>
<a name="ln1048">	// TODO: is this a good idea (e.g. if this is an empty CD)?</a>
<a name="ln1049">	info-&gt;original_capacity = 0;</a>
<a name="ln1050">	info-&gt;capacity = 0;</a>
<a name="ln1051">	sSCSIPeripheral-&gt;check_capacity(info-&gt;scsi_periph_device, request);</a>
<a name="ln1052"> </a>
<a name="ln1053">	if (info-&gt;io_scheduler != NULL)</a>
<a name="ln1054">		info-&gt;io_scheduler-&gt;MediaChanged();</a>
<a name="ln1055">}</a>
<a name="ln1056"> </a>
<a name="ln1057"> </a>
<a name="ln1058">scsi_periph_callbacks callbacks = {</a>
<a name="ln1059">	(void (*)(periph_device_cookie, uint64, uint32))cd_set_capacity,</a>
<a name="ln1060">	(void (*)(periph_device_cookie, scsi_ccb *))cd_media_changed</a>
<a name="ln1061">};</a>
<a name="ln1062"> </a>
<a name="ln1063"> </a>
<a name="ln1064">//	#pragma mark - driver module API</a>
<a name="ln1065"> </a>
<a name="ln1066"> </a>
<a name="ln1067">static float</a>
<a name="ln1068">cd_supports_device(device_node* parent)</a>
<a name="ln1069">{</a>
<a name="ln1070">	const char* bus;</a>
<a name="ln1071">	uint8 deviceType;</a>
<a name="ln1072"> </a>
<a name="ln1073">	// make sure parent is really the SCSI bus manager</a>
<a name="ln1074">	if (sDeviceManager-&gt;get_attr_string(parent, B_DEVICE_BUS, &amp;bus, false))</a>
<a name="ln1075">		return -1;</a>
<a name="ln1076"> </a>
<a name="ln1077">	if (strcmp(bus, &quot;scsi&quot;))</a>
<a name="ln1078">		return 0.0;</a>
<a name="ln1079"> </a>
<a name="ln1080">	// check whether it's really a CD-ROM or WORM</a>
<a name="ln1081">	if (sDeviceManager-&gt;get_attr_uint8(parent, SCSI_DEVICE_TYPE_ITEM,</a>
<a name="ln1082">			&amp;deviceType, true) != B_OK</a>
<a name="ln1083">		|| (deviceType != scsi_dev_CDROM &amp;&amp; deviceType != scsi_dev_WORM))</a>
<a name="ln1084">		return 0.0;</a>
<a name="ln1085"> </a>
<a name="ln1086">	return 0.6;</a>
<a name="ln1087">}</a>
<a name="ln1088"> </a>
<a name="ln1089"> </a>
<a name="ln1090">/*!	Called whenever a new device was added to system;</a>
<a name="ln1091">	if we really support it, we create a new node that gets</a>
<a name="ln1092">	server by the block_io module</a>
<a name="ln1093">*/</a>
<a name="ln1094">static status_t</a>
<a name="ln1095">cd_register_device(device_node* node)</a>
<a name="ln1096">{</a>
<a name="ln1097">	const scsi_res_inquiry* deviceInquiry = NULL;</a>
<a name="ln1098">	size_t inquiryLength;</a>
<a name="ln1099">	uint32 maxBlocks;</a>
<a name="ln1100"> </a>
<a name="ln1101">	// get inquiry data</a>
<a name="ln1102">	if (sDeviceManager-&gt;get_attr_raw(node, SCSI_DEVICE_INQUIRY_ITEM,</a>
<a name="ln1103">			(const void**)&amp;deviceInquiry, &amp;inquiryLength, true) != B_OK</a>
<a name="ln1104">		|| inquiryLength &lt; sizeof(deviceInquiry))</a>
<a name="ln1105">		return B_ERROR;</a>
<a name="ln1106"> </a>
<a name="ln1107">	// get block limit of underlying hardware to lower it (if necessary)</a>
<a name="ln1108">	if (sDeviceManager-&gt;get_attr_uint32(node, B_DMA_MAX_TRANSFER_BLOCKS,</a>
<a name="ln1109">			&amp;maxBlocks, true) != B_OK)</a>
<a name="ln1110">		maxBlocks = INT_MAX;</a>
<a name="ln1111"> </a>
<a name="ln1112">	// using 10 byte commands, at most 0xffff blocks can be transmitted at once</a>
<a name="ln1113">	// (sadly, we cannot update this value later on if only 6 byte commands</a>
<a name="ln1114">	//  are supported, but the block_io module can live with that)</a>
<a name="ln1115">	maxBlocks = min_c(maxBlocks, 0xffff);</a>
<a name="ln1116"> </a>
<a name="ln1117">	// ready to register</a>
<a name="ln1118">	device_attr attrs[] = {</a>
<a name="ln1119">		{&quot;removable&quot;, B_UINT8_TYPE, {ui8: deviceInquiry-&gt;removable_medium}},</a>
<a name="ln1120">		{B_DMA_MAX_TRANSFER_BLOCKS, B_UINT32_TYPE, {ui32: maxBlocks}},</a>
<a name="ln1121">		{ NULL }</a>
<a name="ln1122">	};</a>
<a name="ln1123"> </a>
<a name="ln1124">	return sDeviceManager-&gt;register_node(node, SCSI_CD_DRIVER_MODULE_NAME,</a>
<a name="ln1125">		attrs, NULL, NULL);</a>
<a name="ln1126">}</a>
<a name="ln1127"> </a>
<a name="ln1128"> </a>
<a name="ln1129">static status_t</a>
<a name="ln1130">cd_init_driver(device_node* node, void** _cookie)</a>
<a name="ln1131">{</a>
<a name="ln1132">	TRACE(&quot;cd_init_driver\n&quot;);</a>
<a name="ln1133"> </a>
<a name="ln1134">	uint8 removable;</a>
<a name="ln1135">	status_t status = sDeviceManager-&gt;get_attr_uint8(node, &quot;removable&quot;,</a>
<a name="ln1136">		&amp;removable, false);</a>
<a name="ln1137">	if (status != B_OK)</a>
<a name="ln1138">		return status;</a>
<a name="ln1139"> </a>
<a name="ln1140">	cd_driver_info* info = (cd_driver_info*)malloc(sizeof(cd_driver_info));</a>
<a name="ln1141">	if (info == NULL)</a>
<a name="ln1142">		return B_NO_MEMORY;</a>
<a name="ln1143"> </a>
<a name="ln1144">	memset(info, 0, sizeof(cd_driver_info));</a>
<a name="ln1145"> </a>
<a name="ln1146">	info-&gt;dma_resource = new(std::nothrow) DMAResource;</a>
<a name="ln1147">	if (info-&gt;dma_resource == NULL) {</a>
<a name="ln1148">		free(info);</a>
<a name="ln1149">		return B_NO_MEMORY;</a>
<a name="ln1150">	}</a>
<a name="ln1151"> </a>
<a name="ln1152">	info-&gt;node = node;</a>
<a name="ln1153">	info-&gt;removable = removable;</a>
<a name="ln1154"> </a>
<a name="ln1155">	// set capacity to zero, so it get checked on first opened handle</a>
<a name="ln1156">	info-&gt;original_capacity = 0;</a>
<a name="ln1157">	info-&gt;capacity = 0;</a>
<a name="ln1158">	info-&gt;block_size = 0;</a>
<a name="ln1159"> </a>
<a name="ln1160">	sDeviceManager-&gt;get_attr_uint8(node, SCSI_DEVICE_TYPE_ITEM,</a>
<a name="ln1161">		&amp;info-&gt;device_type, true);</a>
<a name="ln1162"> </a>
<a name="ln1163">	device_node *parent = sDeviceManager-&gt;get_parent_node(node);</a>
<a name="ln1164">	sDeviceManager-&gt;get_driver(parent, (driver_module_info**)&amp;info-&gt;scsi,</a>
<a name="ln1165">		(void**)&amp;info-&gt;scsi_device);</a>
<a name="ln1166">	sDeviceManager-&gt;put_node(parent);</a>
<a name="ln1167"> </a>
<a name="ln1168">	status = sSCSIPeripheral-&gt;register_device((periph_device_cookie)info,</a>
<a name="ln1169">		&amp;callbacks, info-&gt;scsi_device, info-&gt;scsi, info-&gt;node,</a>
<a name="ln1170">		info-&gt;removable, 10, &amp;info-&gt;scsi_periph_device);</a>
<a name="ln1171">	if (status != B_OK) {</a>
<a name="ln1172">		free(info);</a>
<a name="ln1173">		return status;</a>
<a name="ln1174">	}</a>
<a name="ln1175"> </a>
<a name="ln1176">	*_cookie = info;</a>
<a name="ln1177">	return B_OK;</a>
<a name="ln1178">}</a>
<a name="ln1179"> </a>
<a name="ln1180"> </a>
<a name="ln1181">static void</a>
<a name="ln1182">cd_uninit_driver(void* _cookie)</a>
<a name="ln1183">{</a>
<a name="ln1184">	cd_driver_info* info = (cd_driver_info*)_cookie;</a>
<a name="ln1185"> </a>
<a name="ln1186">	sSCSIPeripheral-&gt;unregister_device(info-&gt;scsi_periph_device);</a>
<a name="ln1187">	free(info);</a>
<a name="ln1188">}</a>
<a name="ln1189"> </a>
<a name="ln1190"> </a>
<a name="ln1191">static status_t</a>
<a name="ln1192">cd_register_child_devices(void* _cookie)</a>
<a name="ln1193">{</a>
<a name="ln1194">	cd_driver_info* info = (cd_driver_info*)_cookie;</a>
<a name="ln1195"> </a>
<a name="ln1196">	char* name = sSCSIPeripheral-&gt;compose_device_name(info-&gt;node, &quot;disk/scsi&quot;);</a>
<a name="ln1197">	if (name == NULL)</a>
<a name="ln1198">		return B_ERROR;</a>
<a name="ln1199"> </a>
<a name="ln1200">	status_t status = sDeviceManager-&gt;publish_device(info-&gt;node, name,</a>
<a name="ln1201">		SCSI_CD_DEVICE_MODULE_NAME);</a>
<a name="ln1202"> </a>
<a name="ln1203">	free(name);</a>
<a name="ln1204">	return status;</a>
<a name="ln1205">}</a>
<a name="ln1206"> </a>
<a name="ln1207"> </a>
<a name="ln1208">module_dependency module_dependencies[] = {</a>
<a name="ln1209">	{SCSI_PERIPH_MODULE_NAME, (module_info**)&amp;sSCSIPeripheral},</a>
<a name="ln1210">	{B_DEVICE_MANAGER_MODULE_NAME, (module_info**)&amp;sDeviceManager},</a>
<a name="ln1211">	{}</a>
<a name="ln1212">};</a>
<a name="ln1213"> </a>
<a name="ln1214">struct device_module_info sSCSICDDevice = {</a>
<a name="ln1215">	{</a>
<a name="ln1216">		SCSI_CD_DEVICE_MODULE_NAME,</a>
<a name="ln1217">		0,</a>
<a name="ln1218">		NULL</a>
<a name="ln1219">	},</a>
<a name="ln1220"> </a>
<a name="ln1221">	cd_init_device,</a>
<a name="ln1222">	cd_uninit_device,</a>
<a name="ln1223">	NULL,	// remove,</a>
<a name="ln1224"> </a>
<a name="ln1225">	cd_open,</a>
<a name="ln1226">	cd_close,</a>
<a name="ln1227">	cd_free,</a>
<a name="ln1228">	cd_read,</a>
<a name="ln1229">	cd_write,</a>
<a name="ln1230">	cd_io,</a>
<a name="ln1231">	cd_ioctl,</a>
<a name="ln1232"> </a>
<a name="ln1233">	NULL,	// select</a>
<a name="ln1234">	NULL,	// deselect</a>
<a name="ln1235">};</a>
<a name="ln1236"> </a>
<a name="ln1237">struct driver_module_info sSCSICDDriver = {</a>
<a name="ln1238">	{</a>
<a name="ln1239">		SCSI_CD_DRIVER_MODULE_NAME,</a>
<a name="ln1240">		0,</a>
<a name="ln1241">		NULL</a>
<a name="ln1242">	},</a>
<a name="ln1243"> </a>
<a name="ln1244">	cd_supports_device,</a>
<a name="ln1245">	cd_register_device,</a>
<a name="ln1246">	cd_init_driver,</a>
<a name="ln1247">	cd_uninit_driver,</a>
<a name="ln1248">	cd_register_child_devices,</a>
<a name="ln1249">	NULL,	// rescan</a>
<a name="ln1250">	NULL,	// removed</a>
<a name="ln1251">};</a>
<a name="ln1252"> </a>
<a name="ln1253">module_info* modules[] = {</a>
<a name="ln1254">	(module_info*)&amp;sSCSICDDriver,</a>
<a name="ln1255">	(module_info*)&amp;sSCSICDDevice,</a>
<a name="ln1256">	NULL</a>
<a name="ln1257">};</a>

</code></pre>
<div class="balloon" rel="1104"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v568/" target="_blank">V568</a> It's odd that 'sizeof()' operator evaluates the size of a pointer to a class, but not the size of the 'deviceInquiry' class object.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
