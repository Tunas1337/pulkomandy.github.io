
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>fbsd_busdma_x86.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * Copyright (c) 1997, 1998 Justin T. Gibbs.</a>
<a name="ln3"> * All rights reserved.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln6"> * modification, are permitted provided that the following conditions</a>
<a name="ln7"> * are met:</a>
<a name="ln8"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln9"> *    notice, this list of conditions, and the following disclaimer,</a>
<a name="ln10"> *    without modification, immediately at the beginning of the file.</a>
<a name="ln11"> * 2. The name of the author may not be used to endorse or promote products</a>
<a name="ln12"> *    derived from this software without specific prior written permission.</a>
<a name="ln13"> *</a>
<a name="ln14"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln15"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln16"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln17"> * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR</a>
<a name="ln18"> * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln19"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln20"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln21"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln22"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln23"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln24"> * SUCH DAMAGE.</a>
<a name="ln25"> */</a>
<a name="ln26">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln27">__FBSDID(&quot;$FreeBSD: src/sys/i386/i386/busdma_machdep.c,v 1.74.2.4 2006/10/21 16:26:53 hrs Exp $&quot;);</a>
<a name="ln28"> </a>
<a name="ln29">#include &lt;sys/param.h&gt;</a>
<a name="ln30">#include &lt;sys/systm.h&gt;</a>
<a name="ln31">#include &lt;sys/malloc.h&gt;</a>
<a name="ln32">#include &lt;sys/bus.h&gt;</a>
<a name="ln33">#include &lt;sys/kernel.h&gt;</a>
<a name="ln34">#include &lt;sys/ktr.h&gt;</a>
<a name="ln35">#include &lt;sys/lock.h&gt;</a>
<a name="ln36">#include &lt;sys/mutex.h&gt;</a>
<a name="ln37">#include &lt;sys/mbuf.h&gt;</a>
<a name="ln38">#include &lt;sys/uio.h&gt;</a>
<a name="ln39">#include &lt;sys/sysctl.h&gt;</a>
<a name="ln40"> </a>
<a name="ln41">#include &lt;vm/vm.h&gt;</a>
<a name="ln42"> </a>
<a name="ln43">#include &lt;machine/atomic.h&gt;</a>
<a name="ln44">#include &lt;machine/bus.h&gt;</a>
<a name="ln45"> </a>
<a name="ln46">#ifdef __x86_64__</a>
<a name="ln47">#	define MAX_BPAGES 8192</a>
<a name="ln48">#else</a>
<a name="ln49">#	define MAX_BPAGES 512</a>
<a name="ln50">#endif</a>
<a name="ln51"> </a>
<a name="ln52">/* -hugo */</a>
<a name="ln53">#define malloc(a, b, c)						kernel_malloc(a, b, c)</a>
<a name="ln54">#define free(a, b)							kernel_free(a, b)</a>
<a name="ln55">#define contigmalloc(a, b, c, d, e, f, g)	kernel_contigmalloc(a, b, c, d, e, f, g)</a>
<a name="ln56">#define contigfree(a, b, c)					kernel_contigfree(a, b, c)</a>
<a name="ln57">void busdma_swi(void);</a>
<a name="ln58">void init_bounce_pages(void);</a>
<a name="ln59">void uninit_bounce_pages(void);</a>
<a name="ln60">/* &lt;/&gt; */</a>
<a name="ln61"> </a>
<a name="ln62">struct bounce_zone;</a>
<a name="ln63"> </a>
<a name="ln64">struct bus_dma_tag {</a>
<a name="ln65">	bus_dma_tag_t	  parent;</a>
<a name="ln66">	bus_size_t	  alignment;</a>
<a name="ln67">	bus_addr_t	  boundary;</a>
<a name="ln68">	bus_addr_t	  lowaddr;</a>
<a name="ln69">	bus_addr_t	  highaddr;</a>
<a name="ln70">	bus_dma_filter_t *filter;</a>
<a name="ln71">	void		 *filterarg;</a>
<a name="ln72">	bus_size_t	  maxsize;</a>
<a name="ln73">	u_int		  nsegments;</a>
<a name="ln74">	bus_size_t	  maxsegsz;</a>
<a name="ln75">	int		  flags;</a>
<a name="ln76">	int		  ref_count;</a>
<a name="ln77">	int		  map_count;</a>
<a name="ln78">	bus_dma_lock_t	 *lockfunc;</a>
<a name="ln79">	void		 *lockfuncarg;</a>
<a name="ln80">	bus_dma_segment_t *segments;</a>
<a name="ln81">	struct bounce_zone *bounce_zone;</a>
<a name="ln82">};</a>
<a name="ln83"> </a>
<a name="ln84">struct bounce_page {</a>
<a name="ln85">	vm_offset_t	vaddr;		/* kva of bounce buffer */</a>
<a name="ln86">	bus_addr_t	busaddr;	/* Physical address */</a>
<a name="ln87">	vm_offset_t	datavaddr;	/* kva of client data */</a>
<a name="ln88">	bus_size_t	datacount;	/* client data count */</a>
<a name="ln89">	STAILQ_ENTRY(bounce_page) links;</a>
<a name="ln90">};</a>
<a name="ln91"> </a>
<a name="ln92">int busdma_swi_pending;</a>
<a name="ln93"> </a>
<a name="ln94">struct bounce_zone {</a>
<a name="ln95">	STAILQ_ENTRY(bounce_zone) links;</a>
<a name="ln96">	STAILQ_HEAD(bp_list, bounce_page) bounce_page_list;</a>
<a name="ln97">	int		total_bpages;</a>
<a name="ln98">	int		free_bpages;</a>
<a name="ln99">	int		reserved_bpages;</a>
<a name="ln100">	int		active_bpages;</a>
<a name="ln101">	int		total_bounced;</a>
<a name="ln102">	int		total_deferred;</a>
<a name="ln103">	bus_size_t	alignment;</a>
<a name="ln104">	bus_addr_t	boundary;</a>
<a name="ln105">	bus_addr_t	lowaddr;</a>
<a name="ln106">	char		zoneid[8];</a>
<a name="ln107">	char		lowaddrid[20];</a>
<a name="ln108">	struct sysctl_ctx_list sysctl_tree;</a>
<a name="ln109">	struct sysctl_oid *sysctl_tree_top;</a>
<a name="ln110">};</a>
<a name="ln111"> </a>
<a name="ln112">static struct mtx bounce_lock;</a>
<a name="ln113">static int total_bpages;</a>
<a name="ln114">static int busdma_zonecount;</a>
<a name="ln115">static STAILQ_HEAD(, bounce_zone) bounce_zone_list;</a>
<a name="ln116"> </a>
<a name="ln117">SYSCTL_NODE(_hw, OID_AUTO, busdma, CTLFLAG_RD, 0, &quot;Busdma parameters&quot;);</a>
<a name="ln118">SYSCTL_INT(_hw_busdma, OID_AUTO, total_bpages, CTLFLAG_RD, &amp;total_bpages, 0,</a>
<a name="ln119">	   &quot;Total bounce pages&quot;);</a>
<a name="ln120"> </a>
<a name="ln121">struct bus_dmamap {</a>
<a name="ln122">	struct bp_list	       bpages;</a>
<a name="ln123">	int		       pagesneeded;</a>
<a name="ln124">	int		       pagesreserved;</a>
<a name="ln125">	bus_dma_tag_t	       dmat;</a>
<a name="ln126">	void		      *buf;		/* unmapped buffer pointer */</a>
<a name="ln127">	bus_size_t	       buflen;		/* unmapped buffer length */</a>
<a name="ln128">	bus_dmamap_callback_t *callback;</a>
<a name="ln129">	void		      *callback_arg;</a>
<a name="ln130">	STAILQ_ENTRY(bus_dmamap) links;</a>
<a name="ln131">};</a>
<a name="ln132"> </a>
<a name="ln133">static STAILQ_HEAD(, bus_dmamap) bounce_map_waitinglist;</a>
<a name="ln134">static STAILQ_HEAD(, bus_dmamap) bounce_map_callbacklist;</a>
<a name="ln135">static struct bus_dmamap nobounce_dmamap;</a>
<a name="ln136"> </a>
<a name="ln137">static int alloc_bounce_zone(bus_dma_tag_t dmat);</a>
<a name="ln138">static int alloc_bounce_pages(bus_dma_tag_t dmat, u_int numpages);</a>
<a name="ln139">static int reserve_bounce_pages(bus_dma_tag_t dmat, bus_dmamap_t map,</a>
<a name="ln140">				int commit);</a>
<a name="ln141">static bus_addr_t add_bounce_page(bus_dma_tag_t dmat, bus_dmamap_t map,</a>
<a name="ln142">				   vm_offset_t vaddr, bus_size_t size);</a>
<a name="ln143">static void free_bounce_page(bus_dma_tag_t dmat, struct bounce_page *bpage);</a>
<a name="ln144">static __inline int run_filter(bus_dma_tag_t dmat, bus_addr_t paddr);</a>
<a name="ln145"> </a>
<a name="ln146">/*</a>
<a name="ln147"> * Return true if a match is made.</a>
<a name="ln148"> *</a>
<a name="ln149"> * To find a match walk the chain of bus_dma_tag_t's looking for 'paddr'.</a>
<a name="ln150"> *</a>
<a name="ln151"> * If paddr is within the bounds of the dma tag then call the filter callback</a>
<a name="ln152"> * to check for a match, if there is no filter callback then assume a match.</a>
<a name="ln153"> */</a>
<a name="ln154">static __inline</a>
<a name="ln155">int</a>
<a name="ln156">run_filter(bus_dma_tag_t dmat, bus_addr_t paddr)</a>
<a name="ln157">{</a>
<a name="ln158">	int retval;</a>
<a name="ln159"> </a>
<a name="ln160">	retval = 0;</a>
<a name="ln161"> </a>
<a name="ln162">	do {</a>
<a name="ln163">		if (((paddr &gt; dmat-&gt;lowaddr &amp;&amp; paddr &lt;= dmat-&gt;highaddr)</a>
<a name="ln164">		 || ((paddr &amp; (dmat-&gt;alignment - 1)) != 0))</a>
<a name="ln165">		 &amp;&amp; (dmat-&gt;filter == NULL</a>
<a name="ln166">		  || (*dmat-&gt;filter)(dmat-&gt;filterarg, paddr) != 0))</a>
<a name="ln167">			retval = 1;</a>
<a name="ln168"> </a>
<a name="ln169">		dmat = dmat-&gt;parent;</a>
<a name="ln170">	} while (retval == 0 &amp;&amp; dmat != NULL);</a>
<a name="ln171">	return (retval);</a>
<a name="ln172">}</a>
<a name="ln173"> </a>
<a name="ln174">/*</a>
<a name="ln175"> * Convenience function for manipulating driver locks from busdma (during</a>
<a name="ln176"> * busdma_swi, for example).  Drivers that don't provide their own locks</a>
<a name="ln177"> * should specify &amp;Giant to dmat-&gt;lockfuncarg.  Drivers that use their own</a>
<a name="ln178"> * non-mutex locking scheme don't have to use this at all.</a>
<a name="ln179"> */</a>
<a name="ln180">void</a>
<a name="ln181">busdma_lock_mutex(void *arg, bus_dma_lock_op_t op)</a>
<a name="ln182">{</a>
<a name="ln183">	struct mtx *dmtx;</a>
<a name="ln184"> </a>
<a name="ln185">	dmtx = (struct mtx *)arg;</a>
<a name="ln186">	switch (op) {</a>
<a name="ln187">	case BUS_DMA_LOCK:</a>
<a name="ln188">		mtx_lock(dmtx);</a>
<a name="ln189">		break;</a>
<a name="ln190">	case BUS_DMA_UNLOCK:</a>
<a name="ln191">		mtx_unlock(dmtx);</a>
<a name="ln192">		break;</a>
<a name="ln193">	default:</a>
<a name="ln194">		panic(&quot;Unknown operation 0x%x for busdma_lock_mutex!&quot;, op);</a>
<a name="ln195">	}</a>
<a name="ln196">}</a>
<a name="ln197"> </a>
<a name="ln198">/*</a>
<a name="ln199"> * dflt_lock should never get called.  It gets put into the dma tag when</a>
<a name="ln200"> * lockfunc == NULL, which is only valid if the maps that are associated</a>
<a name="ln201"> * with the tag are meant to never be defered.</a>
<a name="ln202"> * XXX Should have a way to identify which driver is responsible here.</a>
<a name="ln203"> */</a>
<a name="ln204">static</a>
<a name="ln205">void</a>
<a name="ln206">dflt_lock(void *arg, bus_dma_lock_op_t op)</a>
<a name="ln207">{</a>
<a name="ln208">	panic(&quot;driver error: busdma dflt_lock called&quot;);</a>
<a name="ln209">}</a>
<a name="ln210"> </a>
<a name="ln211">#define BUS_DMA_COULD_BOUNCE	BUS_DMA_BUS3</a>
<a name="ln212">#define BUS_DMA_MIN_ALLOC_COMP	BUS_DMA_BUS4</a>
<a name="ln213"> </a>
<a name="ln214">/*</a>
<a name="ln215"> * Allocate a device specific dma_tag.</a>
<a name="ln216"> */</a>
<a name="ln217">int</a>
<a name="ln218">bus_dma_tag_create(bus_dma_tag_t parent, bus_size_t alignment,</a>
<a name="ln219">		   bus_size_t boundary, bus_addr_t lowaddr,</a>
<a name="ln220">		   bus_addr_t highaddr, bus_dma_filter_t *filter,</a>
<a name="ln221">		   void *filterarg, bus_size_t maxsize, int nsegments,</a>
<a name="ln222">		   bus_size_t maxsegsz, int flags, bus_dma_lock_t *lockfunc,</a>
<a name="ln223">		   void *lockfuncarg, bus_dma_tag_t *dmat)</a>
<a name="ln224">{</a>
<a name="ln225">	bus_dma_tag_t newtag;</a>
<a name="ln226">	int error = 0;</a>
<a name="ln227"> </a>
<a name="ln228">	/* Basic sanity checking */</a>
<a name="ln229">	if (boundary != 0 &amp;&amp; boundary &lt; maxsegsz)</a>
<a name="ln230">		maxsegsz = boundary;</a>
<a name="ln231"> </a>
<a name="ln232">	/* Return a NULL tag on failure */</a>
<a name="ln233">	*dmat = NULL;</a>
<a name="ln234"> </a>
<a name="ln235">	newtag = (bus_dma_tag_t)malloc(sizeof(*newtag), M_DEVBUF,</a>
<a name="ln236">	    M_ZERO | M_NOWAIT);</a>
<a name="ln237">	if (newtag == NULL) {</a>
<a name="ln238">		CTR4(KTR_BUSDMA, &quot;%s returned tag %p tag flags 0x%x error %d&quot;,</a>
<a name="ln239">		    __func__, newtag, 0, error);</a>
<a name="ln240">		return (ENOMEM);</a>
<a name="ln241">	}</a>
<a name="ln242"> </a>
<a name="ln243">	newtag-&gt;parent = parent;</a>
<a name="ln244">	newtag-&gt;alignment = alignment;</a>
<a name="ln245">	newtag-&gt;boundary = boundary;</a>
<a name="ln246">	newtag-&gt;lowaddr = trunc_page((vm_paddr_t)lowaddr) + (PAGE_SIZE - 1);</a>
<a name="ln247">	newtag-&gt;highaddr = trunc_page((vm_paddr_t)highaddr) +</a>
<a name="ln248">	    (PAGE_SIZE - 1);</a>
<a name="ln249">	newtag-&gt;filter = filter;</a>
<a name="ln250">	newtag-&gt;filterarg = filterarg;</a>
<a name="ln251">	newtag-&gt;maxsize = maxsize;</a>
<a name="ln252">	newtag-&gt;nsegments = nsegments;</a>
<a name="ln253">	newtag-&gt;maxsegsz = maxsegsz;</a>
<a name="ln254">	newtag-&gt;flags = flags;</a>
<a name="ln255">	newtag-&gt;ref_count = 1; /* Count ourself */</a>
<a name="ln256">	newtag-&gt;map_count = 0;</a>
<a name="ln257">	if (lockfunc != NULL) {</a>
<a name="ln258">		newtag-&gt;lockfunc = lockfunc;</a>
<a name="ln259">		newtag-&gt;lockfuncarg = lockfuncarg;</a>
<a name="ln260">	} else {</a>
<a name="ln261">		newtag-&gt;lockfunc = dflt_lock;</a>
<a name="ln262">		newtag-&gt;lockfuncarg = NULL;</a>
<a name="ln263">	}</a>
<a name="ln264">	newtag-&gt;segments = NULL;</a>
<a name="ln265"> </a>
<a name="ln266">	/* Take into account any restrictions imposed by our parent tag */</a>
<a name="ln267">	if (parent != NULL) {</a>
<a name="ln268">		newtag-&gt;lowaddr = MIN(parent-&gt;lowaddr, newtag-&gt;lowaddr);</a>
<a name="ln269">		newtag-&gt;highaddr = MAX(parent-&gt;highaddr, newtag-&gt;highaddr);</a>
<a name="ln270">		if (newtag-&gt;boundary == 0)</a>
<a name="ln271">			newtag-&gt;boundary = parent-&gt;boundary;</a>
<a name="ln272">		else if (parent-&gt;boundary != 0)</a>
<a name="ln273">			newtag-&gt;boundary = MIN(parent-&gt;boundary,</a>
<a name="ln274">					       newtag-&gt;boundary);</a>
<a name="ln275">		if (newtag-&gt;filter == NULL) {</a>
<a name="ln276">			/*</a>
<a name="ln277">			 * Short circuit looking at our parent directly</a>
<a name="ln278">			 * since we have encapsulated all of its information</a>
<a name="ln279">			 */</a>
<a name="ln280">			newtag-&gt;filter = parent-&gt;filter;</a>
<a name="ln281">			newtag-&gt;filterarg = parent-&gt;filterarg;</a>
<a name="ln282">			newtag-&gt;parent = parent-&gt;parent;</a>
<a name="ln283">		}</a>
<a name="ln284">		if (newtag-&gt;parent != NULL)</a>
<a name="ln285">			atomic_add_int(&amp;parent-&gt;ref_count, 1);</a>
<a name="ln286">	}</a>
<a name="ln287"> </a>
<a name="ln288">	if (newtag-&gt;lowaddr &lt; ptoa((vm_paddr_t)Maxmem)</a>
<a name="ln289">	 || newtag-&gt;alignment &gt; 1)</a>
<a name="ln290">		newtag-&gt;flags |= BUS_DMA_COULD_BOUNCE;</a>
<a name="ln291"> </a>
<a name="ln292">	if (((newtag-&gt;flags &amp; BUS_DMA_COULD_BOUNCE) != 0) &amp;&amp;</a>
<a name="ln293">	    (flags &amp; BUS_DMA_ALLOCNOW) != 0) {</a>
<a name="ln294">		struct bounce_zone *bz;</a>
<a name="ln295"> </a>
<a name="ln296">		/* Must bounce */</a>
<a name="ln297"> </a>
<a name="ln298">		if ((error = alloc_bounce_zone(newtag)) != 0) {</a>
<a name="ln299">			free(newtag, M_DEVBUF);</a>
<a name="ln300">			return (error);</a>
<a name="ln301">		}</a>
<a name="ln302">		bz = newtag-&gt;bounce_zone;</a>
<a name="ln303"> </a>
<a name="ln304">		if (ptoa(bz-&gt;total_bpages) &lt; maxsize) {</a>
<a name="ln305">			int pages;</a>
<a name="ln306"> </a>
<a name="ln307">			pages = atop(maxsize) - bz-&gt;total_bpages;</a>
<a name="ln308"> </a>
<a name="ln309">			/* Add pages to our bounce pool */</a>
<a name="ln310">			if (alloc_bounce_pages(newtag, pages) &lt; pages)</a>
<a name="ln311">				error = ENOMEM;</a>
<a name="ln312">		}</a>
<a name="ln313">		/* Performed initial allocation */</a>
<a name="ln314">		newtag-&gt;flags |= BUS_DMA_MIN_ALLOC_COMP;</a>
<a name="ln315">	}</a>
<a name="ln316"> </a>
<a name="ln317">	if (error != 0) {</a>
<a name="ln318">		free(newtag, M_DEVBUF);</a>
<a name="ln319">	} else {</a>
<a name="ln320">		*dmat = newtag;</a>
<a name="ln321">	}</a>
<a name="ln322">	CTR4(KTR_BUSDMA, &quot;%s returned tag %p tag flags 0x%x error %d&quot;,</a>
<a name="ln323">	    __func__, newtag, (newtag != NULL ? newtag-&gt;flags : 0), error);</a>
<a name="ln324">	return (error);</a>
<a name="ln325">}</a>
<a name="ln326"> </a>
<a name="ln327">int</a>
<a name="ln328">bus_dma_tag_destroy(bus_dma_tag_t dmat)</a>
<a name="ln329">{</a>
<a name="ln330">	bus_dma_tag_t dmat_copy;</a>
<a name="ln331">	int error;</a>
<a name="ln332"> </a>
<a name="ln333">	error = 0;</a>
<a name="ln334">	dmat_copy = dmat;</a>
<a name="ln335"> </a>
<a name="ln336">	if (dmat != NULL) {</a>
<a name="ln337"> </a>
<a name="ln338">		if (dmat-&gt;map_count != 0) {</a>
<a name="ln339">			error = EBUSY;</a>
<a name="ln340">			goto out;</a>
<a name="ln341">		}</a>
<a name="ln342"> </a>
<a name="ln343">		while (dmat != NULL) {</a>
<a name="ln344">			bus_dma_tag_t parent;</a>
<a name="ln345"> </a>
<a name="ln346">			parent = dmat-&gt;parent;</a>
<a name="ln347">			atomic_subtract_int(&amp;dmat-&gt;ref_count, 1);</a>
<a name="ln348">			if (dmat-&gt;ref_count == 0) {</a>
<a name="ln349">				if (dmat-&gt;segments != NULL)</a>
<a name="ln350">					free(dmat-&gt;segments, M_DEVBUF);</a>
<a name="ln351">				free(dmat, M_DEVBUF);</a>
<a name="ln352">				/*</a>
<a name="ln353">				 * Last reference count, so</a>
<a name="ln354">				 * release our reference</a>
<a name="ln355">				 * count on our parent.</a>
<a name="ln356">				 */</a>
<a name="ln357">				dmat = parent;</a>
<a name="ln358">			} else</a>
<a name="ln359">				dmat = NULL;</a>
<a name="ln360">		}</a>
<a name="ln361">	}</a>
<a name="ln362">out:</a>
<a name="ln363">	CTR3(KTR_BUSDMA, &quot;%s tag %p error %d&quot;, __func__, dmat_copy, error);</a>
<a name="ln364">	return (error);</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367">/*</a>
<a name="ln368"> * Allocate a handle for mapping from kva/uva/physical</a>
<a name="ln369"> * address space into bus device space.</a>
<a name="ln370"> */</a>
<a name="ln371">int</a>
<a name="ln372">bus_dmamap_create(bus_dma_tag_t dmat, int flags, bus_dmamap_t *mapp)</a>
<a name="ln373">{</a>
<a name="ln374">	int error;</a>
<a name="ln375"> </a>
<a name="ln376">	error = 0;</a>
<a name="ln377"> </a>
<a name="ln378">	if (dmat-&gt;segments == NULL) {</a>
<a name="ln379">		dmat-&gt;segments = (bus_dma_segment_t *)malloc(</a>
<a name="ln380">		    sizeof(bus_dma_segment_t) * dmat-&gt;nsegments, M_DEVBUF,</a>
<a name="ln381">		    M_NOWAIT);</a>
<a name="ln382">		if (dmat-&gt;segments == NULL) {</a>
<a name="ln383">			CTR3(KTR_BUSDMA, &quot;%s: tag %p error %d&quot;,</a>
<a name="ln384">			    __func__, dmat, ENOMEM);</a>
<a name="ln385">			return (ENOMEM);</a>
<a name="ln386">		}</a>
<a name="ln387">	}</a>
<a name="ln388"> </a>
<a name="ln389">	/*</a>
<a name="ln390">	 * Bouncing might be required if the driver asks for an active</a>
<a name="ln391">	 * exclusion region, a data alignment that is stricter than 1, and/or</a>
<a name="ln392">	 * an active address boundary.</a>
<a name="ln393">	 */</a>
<a name="ln394">	if (dmat-&gt;flags &amp; BUS_DMA_COULD_BOUNCE) {</a>
<a name="ln395"> </a>
<a name="ln396">		/* Must bounce */</a>
<a name="ln397">		struct bounce_zone *bz;</a>
<a name="ln398">		int maxpages;</a>
<a name="ln399"> </a>
<a name="ln400">		if (dmat-&gt;bounce_zone == NULL) {</a>
<a name="ln401">			if ((error = alloc_bounce_zone(dmat)) != 0)</a>
<a name="ln402">				return (error);</a>
<a name="ln403">		}</a>
<a name="ln404">		bz = dmat-&gt;bounce_zone;</a>
<a name="ln405"> </a>
<a name="ln406">		*mapp = (bus_dmamap_t)malloc(sizeof(**mapp), M_DEVBUF,</a>
<a name="ln407">					     M_NOWAIT | M_ZERO);</a>
<a name="ln408">		if (*mapp == NULL) {</a>
<a name="ln409">			CTR3(KTR_BUSDMA, &quot;%s: tag %p error %d&quot;,</a>
<a name="ln410">			    __func__, dmat, ENOMEM);</a>
<a name="ln411">			return (ENOMEM);</a>
<a name="ln412">		}</a>
<a name="ln413"> </a>
<a name="ln414">		/* Initialize the new map */</a>
<a name="ln415">		STAILQ_INIT(&amp;((*mapp)-&gt;bpages));</a>
<a name="ln416"> </a>
<a name="ln417">		/*</a>
<a name="ln418">		 * Attempt to add pages to our pool on a per-instance</a>
<a name="ln419">		 * basis up to a sane limit.</a>
<a name="ln420">		 */</a>
<a name="ln421">		if (dmat-&gt;alignment &gt; 1)</a>
<a name="ln422">			maxpages = MAX_BPAGES;</a>
<a name="ln423">		else</a>
<a name="ln424">			maxpages = MIN(MAX_BPAGES, Maxmem -atop(dmat-&gt;lowaddr));</a>
<a name="ln425">		if ((dmat-&gt;flags &amp; BUS_DMA_MIN_ALLOC_COMP) == 0</a>
<a name="ln426">		 || (dmat-&gt;map_count &gt; 0 &amp;&amp; bz-&gt;total_bpages &lt; maxpages)) {</a>
<a name="ln427">			int pages;</a>
<a name="ln428"> </a>
<a name="ln429">			pages = MAX(atop(dmat-&gt;maxsize), 1);</a>
<a name="ln430">			pages = MIN(maxpages - bz-&gt;total_bpages, pages);</a>
<a name="ln431">			pages = MAX(pages, 1);</a>
<a name="ln432">			if (alloc_bounce_pages(dmat, pages) &lt; pages)</a>
<a name="ln433">				error = ENOMEM;</a>
<a name="ln434"> </a>
<a name="ln435">			if ((dmat-&gt;flags &amp; BUS_DMA_MIN_ALLOC_COMP) == 0) {</a>
<a name="ln436">				if (error == 0)</a>
<a name="ln437">					dmat-&gt;flags |= BUS_DMA_MIN_ALLOC_COMP;</a>
<a name="ln438">			} else {</a>
<a name="ln439">				error = 0;</a>
<a name="ln440">			}</a>
<a name="ln441">		}</a>
<a name="ln442">	} else {</a>
<a name="ln443">		*mapp = NULL;</a>
<a name="ln444">	}</a>
<a name="ln445">	if (error == 0)</a>
<a name="ln446">		dmat-&gt;map_count++;</a>
<a name="ln447">	CTR4(KTR_BUSDMA, &quot;%s: tag %p tag flags 0x%x error %d&quot;,</a>
<a name="ln448">	    __func__, dmat, dmat-&gt;flags, error);</a>
<a name="ln449">	return (error);</a>
<a name="ln450">}</a>
<a name="ln451"> </a>
<a name="ln452">/*</a>
<a name="ln453"> * Destroy a handle for mapping from kva/uva/physical</a>
<a name="ln454"> * address space into bus device space.</a>
<a name="ln455"> */</a>
<a name="ln456">int</a>
<a name="ln457">bus_dmamap_destroy(bus_dma_tag_t dmat, bus_dmamap_t map)</a>
<a name="ln458">{</a>
<a name="ln459">	if (map != NULL &amp;&amp; map != &amp;nobounce_dmamap) {</a>
<a name="ln460">		if (STAILQ_FIRST(&amp;map-&gt;bpages) != NULL) {</a>
<a name="ln461">			CTR3(KTR_BUSDMA, &quot;%s: tag %p error %d&quot;,</a>
<a name="ln462">			    __func__, dmat, EBUSY);</a>
<a name="ln463">			return (EBUSY);</a>
<a name="ln464">		}</a>
<a name="ln465">		free(map, M_DEVBUF);</a>
<a name="ln466">	}</a>
<a name="ln467">	dmat-&gt;map_count--;</a>
<a name="ln468">	CTR2(KTR_BUSDMA, &quot;%s: tag %p error 0&quot;, __func__, dmat);</a>
<a name="ln469">	return (0);</a>
<a name="ln470">}</a>
<a name="ln471"> </a>
<a name="ln472">/*</a>
<a name="ln473"> * Allocate a piece of memory that can be efficiently mapped into</a>
<a name="ln474"> * bus device space based on the constraints lited in the dma tag.</a>
<a name="ln475"> * A dmamap to for use with dmamap_load is also allocated.</a>
<a name="ln476"> */</a>
<a name="ln477">int</a>
<a name="ln478">bus_dmamem_alloc(bus_dma_tag_t dmat, void** vaddr, int flags,</a>
<a name="ln479">		 bus_dmamap_t *mapp)</a>
<a name="ln480">{</a>
<a name="ln481">	int mflags;</a>
<a name="ln482"> </a>
<a name="ln483">	if (flags &amp; BUS_DMA_NOWAIT)</a>
<a name="ln484">		mflags = M_NOWAIT;</a>
<a name="ln485">	else</a>
<a name="ln486">		mflags = M_WAITOK;</a>
<a name="ln487">	if (flags &amp; BUS_DMA_ZERO)</a>
<a name="ln488">		mflags |= M_ZERO;</a>
<a name="ln489"> </a>
<a name="ln490">	/* If we succeed, no mapping/bouncing will be required */</a>
<a name="ln491">	*mapp = NULL;</a>
<a name="ln492"> </a>
<a name="ln493">	if (dmat-&gt;segments == NULL) {</a>
<a name="ln494">		dmat-&gt;segments = (bus_dma_segment_t *)malloc(</a>
<a name="ln495">		    sizeof(bus_dma_segment_t) * dmat-&gt;nsegments, M_DEVBUF,</a>
<a name="ln496">		    M_NOWAIT);</a>
<a name="ln497">		if (dmat-&gt;segments == NULL) {</a>
<a name="ln498">			CTR4(KTR_BUSDMA, &quot;%s: tag %p tag flags 0x%x error %d&quot;,</a>
<a name="ln499">			    __func__, dmat, dmat-&gt;flags, ENOMEM);</a>
<a name="ln500">			return (ENOMEM);</a>
<a name="ln501">		}</a>
<a name="ln502">	}</a>
<a name="ln503"> </a>
<a name="ln504">	/*</a>
<a name="ln505">	 * XXX:</a>
<a name="ln506">	 * (dmat-&gt;alignment &lt; dmat-&gt;maxsize) is just a quick hack; the exact</a>
<a name="ln507">	 * alignment guarantees of malloc need to be nailed down, and the</a>
<a name="ln508">	 * code below should be rewritten to take that into account.</a>
<a name="ln509">	 *</a>
<a name="ln510">	 * In the meantime, we'll warn the user if malloc gets it wrong.</a>
<a name="ln511">	 */</a>
<a name="ln512">	if ((dmat-&gt;maxsize &lt;= PAGE_SIZE) &amp;&amp;</a>
<a name="ln513">	   (dmat-&gt;alignment &lt; dmat-&gt;maxsize) &amp;&amp;</a>
<a name="ln514">	    dmat-&gt;lowaddr &gt;= ptoa((vm_paddr_t)Maxmem)) {</a>
<a name="ln515">		*vaddr = malloc(dmat-&gt;maxsize, M_DEVBUF, mflags);</a>
<a name="ln516">	} else {</a>
<a name="ln517">		/*</a>
<a name="ln518">		 * XXX Use Contigmalloc until it is merged into this facility</a>
<a name="ln519">		 *     and handles multi-seg allocations.  Nobody is doing</a>
<a name="ln520">		 *     multi-seg allocations yet though.</a>
<a name="ln521">		 * XXX Certain AGP hardware does.</a>
<a name="ln522">		 */</a>
<a name="ln523">		*vaddr = contigmalloc(dmat-&gt;maxsize, M_DEVBUF, mflags,</a>
<a name="ln524">		    0ul, dmat-&gt;lowaddr, dmat-&gt;alignment? dmat-&gt;alignment : 1ul,</a>
<a name="ln525">		    dmat-&gt;boundary);</a>
<a name="ln526">	}</a>
<a name="ln527">	if (*vaddr == NULL) {</a>
<a name="ln528">		CTR4(KTR_BUSDMA, &quot;%s: tag %p tag flags 0x%x error %d&quot;,</a>
<a name="ln529">		    __func__, dmat, dmat-&gt;flags, ENOMEM);</a>
<a name="ln530">		return (ENOMEM);</a>
<a name="ln531">	} else if (vtophys(*vaddr) &amp; (dmat-&gt;alignment - 1)) {</a>
<a name="ln532">		printf(&quot;bus_dmamem_alloc failed to align memory: wanted %#x, got %#x\n&quot;,</a>
<a name="ln533">			dmat-&gt;alignment, vtophys(vaddr));</a>
<a name="ln534">	}</a>
<a name="ln535">	CTR4(KTR_BUSDMA, &quot;%s: tag %p tag flags 0x%x error %d&quot;,</a>
<a name="ln536">	    __func__, dmat, dmat-&gt;flags, 0);</a>
<a name="ln537">	return (0);</a>
<a name="ln538">}</a>
<a name="ln539"> </a>
<a name="ln540">/*</a>
<a name="ln541"> * Free a piece of memory and it's allociated dmamap, that was allocated</a>
<a name="ln542"> * via bus_dmamem_alloc.  Make the same choice for free/contigfree.</a>
<a name="ln543"> */</a>
<a name="ln544">void</a>
<a name="ln545">bus_dmamem_free(bus_dma_tag_t dmat, void *vaddr, bus_dmamap_t map)</a>
<a name="ln546">{</a>
<a name="ln547">	/*</a>
<a name="ln548">	 * dmamem does not need to be bounced, so the map should be</a>
<a name="ln549">	 * NULL</a>
<a name="ln550">	 */</a>
<a name="ln551">	if (map != NULL)</a>
<a name="ln552">		panic(&quot;bus_dmamem_free: Invalid map freed\n&quot;);</a>
<a name="ln553">	if ((dmat-&gt;maxsize &lt;= PAGE_SIZE) &amp;&amp;</a>
<a name="ln554">	   (dmat-&gt;alignment &lt; dmat-&gt;maxsize) &amp;&amp;</a>
<a name="ln555">	    dmat-&gt;lowaddr &gt;= ptoa((vm_paddr_t)Maxmem))</a>
<a name="ln556">		free(vaddr, M_DEVBUF);</a>
<a name="ln557">	else {</a>
<a name="ln558">		contigfree(vaddr, dmat-&gt;maxsize, M_DEVBUF);</a>
<a name="ln559">	}</a>
<a name="ln560">	CTR3(KTR_BUSDMA, &quot;%s: tag %p flags 0x%x&quot;, __func__, dmat, dmat-&gt;flags);</a>
<a name="ln561">}</a>
<a name="ln562"> </a>
<a name="ln563">/*</a>
<a name="ln564"> * Utility function to load a linear buffer.  lastaddrp holds state</a>
<a name="ln565"> * between invocations (for multiple-buffer loads).  segp contains</a>
<a name="ln566"> * the starting segment on entrace, and the ending segment on exit.</a>
<a name="ln567"> * first indicates if this is the first invocation of this function.</a>
<a name="ln568"> */</a>
<a name="ln569">static __inline int</a>
<a name="ln570">_bus_dmamap_load_buffer(bus_dma_tag_t dmat,</a>
<a name="ln571">    			bus_dmamap_t map,</a>
<a name="ln572">			void *buf, bus_size_t buflen,</a>
<a name="ln573">			pmap_t pmap,</a>
<a name="ln574">			int flags,</a>
<a name="ln575">			bus_addr_t *lastaddrp,</a>
<a name="ln576">			bus_dma_segment_t *segs,</a>
<a name="ln577">			int *segp,</a>
<a name="ln578">			int first)</a>
<a name="ln579">{</a>
<a name="ln580">	bus_size_t sgsize;</a>
<a name="ln581">	bus_addr_t curaddr, lastaddr, baddr, bmask;</a>
<a name="ln582">	vm_offset_t vaddr;</a>
<a name="ln583">	bus_addr_t paddr;</a>
<a name="ln584">	int needbounce = 0;</a>
<a name="ln585">	int seg;</a>
<a name="ln586"> </a>
<a name="ln587">	if (map == NULL)</a>
<a name="ln588">		map = &amp;nobounce_dmamap;</a>
<a name="ln589"> </a>
<a name="ln590">	if ((map != &amp;nobounce_dmamap &amp;&amp; map-&gt;pagesneeded == 0)</a>
<a name="ln591">	 &amp;&amp; ((dmat-&gt;flags &amp; BUS_DMA_COULD_BOUNCE) != 0)) {</a>
<a name="ln592">		vm_offset_t	vendaddr;</a>
<a name="ln593"> </a>
<a name="ln594">		CTR4(KTR_BUSDMA, &quot;lowaddr= %d Maxmem= %d, boundary= %d, &quot;</a>
<a name="ln595">		    &quot;alignment= %d&quot;, dmat-&gt;lowaddr, ptoa((vm_paddr_t)Maxmem),</a>
<a name="ln596">		    dmat-&gt;boundary, dmat-&gt;alignment);</a>
<a name="ln597">		CTR3(KTR_BUSDMA, &quot;map= %p, nobouncemap= %p, pagesneeded= %d&quot;,</a>
<a name="ln598">		    map, &amp;nobounce_dmamap, map-&gt;pagesneeded);</a>
<a name="ln599">		/*</a>
<a name="ln600">		 * Count the number of bounce pages</a>
<a name="ln601">		 * needed in order to complete this transfer</a>
<a name="ln602">		 */</a>
<a name="ln603">		vaddr = trunc_page((vm_offset_t)buf);</a>
<a name="ln604">		vendaddr = (vm_offset_t)buf + buflen;</a>
<a name="ln605"> </a>
<a name="ln606">		while (vaddr &lt; vendaddr) {</a>
<a name="ln607">			paddr = pmap_kextract(vaddr);</a>
<a name="ln608">			if (run_filter(dmat, paddr) != 0) {</a>
<a name="ln609">				needbounce = 1;</a>
<a name="ln610">				map-&gt;pagesneeded++;</a>
<a name="ln611">			}</a>
<a name="ln612">			vaddr += PAGE_SIZE;</a>
<a name="ln613">		}</a>
<a name="ln614">		CTR1(KTR_BUSDMA, &quot;pagesneeded= %d\n&quot;, map-&gt;pagesneeded);</a>
<a name="ln615">	}</a>
<a name="ln616"> </a>
<a name="ln617">	/* Reserve Necessary Bounce Pages */</a>
<a name="ln618">	if (map-&gt;pagesneeded != 0) {</a>
<a name="ln619">		mtx_lock(&amp;bounce_lock);</a>
<a name="ln620">		if (flags &amp; BUS_DMA_NOWAIT) {</a>
<a name="ln621">			if (reserve_bounce_pages(dmat, map, 0) != 0) {</a>
<a name="ln622">				mtx_unlock(&amp;bounce_lock);</a>
<a name="ln623">				return (ENOMEM);</a>
<a name="ln624">			}</a>
<a name="ln625">		} else {</a>
<a name="ln626">			if (reserve_bounce_pages(dmat, map, 1) != 0) {</a>
<a name="ln627">				/* Queue us for resources */</a>
<a name="ln628">				map-&gt;dmat = dmat;</a>
<a name="ln629">				map-&gt;buf = buf;</a>
<a name="ln630">				map-&gt;buflen = buflen;</a>
<a name="ln631">				STAILQ_INSERT_TAIL(&amp;bounce_map_waitinglist,</a>
<a name="ln632">				    map, links);</a>
<a name="ln633">				mtx_unlock(&amp;bounce_lock);</a>
<a name="ln634">				return (EINPROGRESS);</a>
<a name="ln635">			}</a>
<a name="ln636">		}</a>
<a name="ln637">		mtx_unlock(&amp;bounce_lock);</a>
<a name="ln638">	}</a>
<a name="ln639"> </a>
<a name="ln640">	vaddr = (vm_offset_t)buf;</a>
<a name="ln641">	lastaddr = *lastaddrp;</a>
<a name="ln642">	bmask = ~(dmat-&gt;boundary - 1);</a>
<a name="ln643"> </a>
<a name="ln644">	for (seg = *segp; buflen &gt; 0 ; ) {</a>
<a name="ln645">		/*</a>
<a name="ln646">		 * Get the physical address for this segment.</a>
<a name="ln647">		 */</a>
<a name="ln648">		if (pmap)</a>
<a name="ln649">			curaddr = (bus_addr_t)pmap_extract(pmap, vaddr);</a>
<a name="ln650">		else</a>
<a name="ln651">			curaddr = pmap_kextract(vaddr);</a>
<a name="ln652"> </a>
<a name="ln653">		/*</a>
<a name="ln654">		 * Compute the segment size, and adjust counts.</a>
<a name="ln655">		 */</a>
<a name="ln656">		sgsize = PAGE_SIZE - ((u_long)curaddr &amp; PAGE_MASK);</a>
<a name="ln657">		if (buflen &lt; sgsize)</a>
<a name="ln658">			sgsize = buflen;</a>
<a name="ln659"> </a>
<a name="ln660">		/*</a>
<a name="ln661">		 * Make sure we don't cross any boundaries.</a>
<a name="ln662">		 */</a>
<a name="ln663">		if (dmat-&gt;boundary &gt; 0) {</a>
<a name="ln664">			baddr = (curaddr + dmat-&gt;boundary) &amp; bmask;</a>
<a name="ln665">			if (sgsize &gt; (baddr - curaddr))</a>
<a name="ln666">				sgsize = (baddr - curaddr);</a>
<a name="ln667">		}</a>
<a name="ln668"> </a>
<a name="ln669">		if (map-&gt;pagesneeded != 0 &amp;&amp; run_filter(dmat, curaddr))</a>
<a name="ln670">			curaddr = add_bounce_page(dmat, map, vaddr, sgsize);</a>
<a name="ln671"> </a>
<a name="ln672">		/*</a>
<a name="ln673">		 * Insert chunk into a segment, coalescing with</a>
<a name="ln674">		 * previous segment if possible.</a>
<a name="ln675">		 */</a>
<a name="ln676">		if (first) {</a>
<a name="ln677">			segs[seg].ds_addr = curaddr;</a>
<a name="ln678">			segs[seg].ds_len = sgsize;</a>
<a name="ln679">			first = 0;</a>
<a name="ln680">		} else {</a>
<a name="ln681">			if (needbounce == 0 &amp;&amp; curaddr == lastaddr &amp;&amp;</a>
<a name="ln682">			    (segs[seg].ds_len + sgsize) &lt;= dmat-&gt;maxsegsz &amp;&amp;</a>
<a name="ln683">			    (dmat-&gt;boundary == 0 ||</a>
<a name="ln684">			     (segs[seg].ds_addr &amp; bmask) == (curaddr &amp; bmask)))</a>
<a name="ln685">				segs[seg].ds_len += sgsize;</a>
<a name="ln686">			else {</a>
<a name="ln687">				if (++seg &gt;= dmat-&gt;nsegments)</a>
<a name="ln688">					break;</a>
<a name="ln689">				segs[seg].ds_addr = curaddr;</a>
<a name="ln690">				segs[seg].ds_len = sgsize;</a>
<a name="ln691">			}</a>
<a name="ln692">		}</a>
<a name="ln693"> </a>
<a name="ln694">		lastaddr = curaddr + sgsize;</a>
<a name="ln695">		vaddr += sgsize;</a>
<a name="ln696">		buflen -= sgsize;</a>
<a name="ln697">	}</a>
<a name="ln698"> </a>
<a name="ln699">	*segp = seg;</a>
<a name="ln700">	*lastaddrp = lastaddr;</a>
<a name="ln701"> </a>
<a name="ln702">	/*</a>
<a name="ln703">	 * Did we fit?</a>
<a name="ln704">	 */</a>
<a name="ln705">	return (buflen != 0 ? EFBIG : 0); /* XXX better return value here? */</a>
<a name="ln706">}</a>
<a name="ln707"> </a>
<a name="ln708">/*</a>
<a name="ln709"> * Map the buffer buf into bus space using the dmamap map.</a>
<a name="ln710"> */</a>
<a name="ln711">int</a>
<a name="ln712">bus_dmamap_load(bus_dma_tag_t dmat, bus_dmamap_t map, void *buf,</a>
<a name="ln713">		bus_size_t buflen, bus_dmamap_callback_t *callback,</a>
<a name="ln714">		void *callback_arg, int flags)</a>
<a name="ln715">{</a>
<a name="ln716">	bus_addr_t		lastaddr = 0;</a>
<a name="ln717">	int			error, nsegs = 0;</a>
<a name="ln718"> </a>
<a name="ln719">	if (map != NULL) {</a>
<a name="ln720">		flags |= BUS_DMA_WAITOK;</a>
<a name="ln721">		map-&gt;callback = callback;</a>
<a name="ln722">		map-&gt;callback_arg = callback_arg;</a>
<a name="ln723">	}</a>
<a name="ln724"> </a>
<a name="ln725">	error = _bus_dmamap_load_buffer(dmat, map, buf, buflen, NULL, flags,</a>
<a name="ln726">	     &amp;lastaddr, dmat-&gt;segments, &amp;nsegs, 1);</a>
<a name="ln727"> </a>
<a name="ln728">	CTR5(KTR_BUSDMA, &quot;%s: tag %p tag flags 0x%x error %d nsegs %d&quot;,</a>
<a name="ln729">	    __func__, dmat, dmat-&gt;flags, error, nsegs + 1);</a>
<a name="ln730"> </a>
<a name="ln731">	if (error == EINPROGRESS) {</a>
<a name="ln732">		return (error);</a>
<a name="ln733">	}</a>
<a name="ln734"> </a>
<a name="ln735">	if (error)</a>
<a name="ln736">		(*callback)(callback_arg, dmat-&gt;segments, 0, error);</a>
<a name="ln737">	else</a>
<a name="ln738">		(*callback)(callback_arg, dmat-&gt;segments, nsegs + 1, 0);</a>
<a name="ln739"> </a>
<a name="ln740">	/*</a>
<a name="ln741">	 * Return ENOMEM to the caller so that it can pass it up the stack.</a>
<a name="ln742">	 * This error only happens when NOWAIT is set, so deferal is disabled.</a>
<a name="ln743">	 */</a>
<a name="ln744">	if (error == ENOMEM)</a>
<a name="ln745">		return (error);</a>
<a name="ln746"> </a>
<a name="ln747">	return (0);</a>
<a name="ln748">}</a>
<a name="ln749"> </a>
<a name="ln750">/*</a>
<a name="ln751"> * Like _bus_dmamap_load(), but for mbufs.</a>
<a name="ln752"> */</a>
<a name="ln753">int</a>
<a name="ln754">bus_dmamap_load_mbuf(bus_dma_tag_t dmat, bus_dmamap_t map,</a>
<a name="ln755">		     struct mbuf *m0,</a>
<a name="ln756">		     bus_dmamap_callback2_t *callback, void *callback_arg,</a>
<a name="ln757">		     int flags)</a>
<a name="ln758">{</a>
<a name="ln759">	int nsegs, error;</a>
<a name="ln760"> </a>
<a name="ln761">	M_ASSERTPKTHDR(m0);</a>
<a name="ln762"> </a>
<a name="ln763">	flags |= BUS_DMA_NOWAIT;</a>
<a name="ln764">	nsegs = 0;</a>
<a name="ln765">	error = 0;</a>
<a name="ln766">	if (m0-&gt;m_pkthdr.len &lt;= dmat-&gt;maxsize) {</a>
<a name="ln767">		int first = 1;</a>
<a name="ln768">		bus_addr_t lastaddr = 0;</a>
<a name="ln769">		struct mbuf *m;</a>
<a name="ln770"> </a>
<a name="ln771">		for (m = m0; m != NULL &amp;&amp; error == 0; m = m-&gt;m_next) {</a>
<a name="ln772">			if (m-&gt;m_len &gt; 0) {</a>
<a name="ln773">				error = _bus_dmamap_load_buffer(dmat, map,</a>
<a name="ln774">						m-&gt;m_data, m-&gt;m_len,</a>
<a name="ln775">						NULL, flags, &amp;lastaddr,</a>
<a name="ln776">						dmat-&gt;segments, &amp;nsegs, first);</a>
<a name="ln777">				first = 0;</a>
<a name="ln778">			}</a>
<a name="ln779">		}</a>
<a name="ln780">	} else {</a>
<a name="ln781">		error = EINVAL;</a>
<a name="ln782">	}</a>
<a name="ln783"> </a>
<a name="ln784">	if (error) {</a>
<a name="ln785">		/* force &quot;no valid mappings&quot; in callback */</a>
<a name="ln786">		(*callback)(callback_arg, dmat-&gt;segments, 0, 0, error);</a>
<a name="ln787">	} else {</a>
<a name="ln788">		(*callback)(callback_arg, dmat-&gt;segments,</a>
<a name="ln789">			    nsegs+1, m0-&gt;m_pkthdr.len, error);</a>
<a name="ln790">	}</a>
<a name="ln791">	CTR5(KTR_BUSDMA, &quot;%s: tag %p tag flags 0x%x error %d nsegs %d&quot;,</a>
<a name="ln792">	    __func__, dmat, dmat-&gt;flags, error, nsegs + 1);</a>
<a name="ln793">	return (error);</a>
<a name="ln794">}</a>
<a name="ln795"> </a>
<a name="ln796">int</a>
<a name="ln797">bus_dmamap_load_mbuf_sg(bus_dma_tag_t dmat, bus_dmamap_t map,</a>
<a name="ln798">			struct mbuf *m0, bus_dma_segment_t *segs, int *nsegs,</a>
<a name="ln799">			int flags)</a>
<a name="ln800">{</a>
<a name="ln801">	int error;</a>
<a name="ln802"> </a>
<a name="ln803">	M_ASSERTPKTHDR(m0);</a>
<a name="ln804"> </a>
<a name="ln805">	flags |= BUS_DMA_NOWAIT;</a>
<a name="ln806">	*nsegs = 0;</a>
<a name="ln807">	error = 0;</a>
<a name="ln808">	if (m0-&gt;m_pkthdr.len &lt;= dmat-&gt;maxsize) {</a>
<a name="ln809">		int first = 1;</a>
<a name="ln810">		bus_addr_t lastaddr = 0;</a>
<a name="ln811">		struct mbuf *m;</a>
<a name="ln812"> </a>
<a name="ln813">		for (m = m0; m != NULL &amp;&amp; error == 0; m = m-&gt;m_next) {</a>
<a name="ln814">			if (m-&gt;m_len &gt; 0) {</a>
<a name="ln815">				error = _bus_dmamap_load_buffer(dmat, map,</a>
<a name="ln816">						m-&gt;m_data, m-&gt;m_len,</a>
<a name="ln817">						NULL, flags, &amp;lastaddr,</a>
<a name="ln818">						segs, nsegs, first);</a>
<a name="ln819">				first = 0;</a>
<a name="ln820">			}</a>
<a name="ln821">		}</a>
<a name="ln822">	} else {</a>
<a name="ln823">		error = EINVAL;</a>
<a name="ln824">	}</a>
<a name="ln825"> </a>
<a name="ln826">	/* XXX FIXME: Having to increment nsegs is really annoying */</a>
<a name="ln827">	++*nsegs;</a>
<a name="ln828">	CTR5(KTR_BUSDMA, &quot;%s: tag %p tag flags 0x%x error %d nsegs %d&quot;,</a>
<a name="ln829">	    __func__, dmat, dmat-&gt;flags, error, *nsegs);</a>
<a name="ln830">	return (error);</a>
<a name="ln831">}</a>
<a name="ln832"> </a>
<a name="ln833">#if 0</a>
<a name="ln834">/*</a>
<a name="ln835"> * Like _bus_dmamap_load(), but for uios.</a>
<a name="ln836"> */</a>
<a name="ln837">int</a>
<a name="ln838">bus_dmamap_load_uio(bus_dma_tag_t dmat, bus_dmamap_t map,</a>
<a name="ln839">		    struct uio *uio,</a>
<a name="ln840">		    bus_dmamap_callback2_t *callback, void *callback_arg,</a>
<a name="ln841">		    int flags)</a>
<a name="ln842">{</a>
<a name="ln843">	bus_addr_t lastaddr;</a>
<a name="ln844">	int nsegs, error, first, i;</a>
<a name="ln845">	bus_size_t resid;</a>
<a name="ln846">	struct iovec *iov;</a>
<a name="ln847">	pmap_t pmap;</a>
<a name="ln848"> </a>
<a name="ln849">	flags |= BUS_DMA_NOWAIT;</a>
<a name="ln850">	resid = uio-&gt;uio_resid;</a>
<a name="ln851">	iov = uio-&gt;uio_iov;</a>
<a name="ln852"> </a>
<a name="ln853">	if (uio-&gt;uio_segflg == UIO_USERSPACE) {</a>
<a name="ln854">		KASSERT(uio-&gt;uio_td != NULL,</a>
<a name="ln855">			(&quot;bus_dmamap_load_uio: USERSPACE but no proc&quot;));</a>
<a name="ln856">		pmap = vmspace_pmap(uio-&gt;uio_td-&gt;td_proc-&gt;p_vmspace);</a>
<a name="ln857">	} else</a>
<a name="ln858">		pmap = NULL;</a>
<a name="ln859"> </a>
<a name="ln860">	nsegs = 0;</a>
<a name="ln861">	error = 0;</a>
<a name="ln862">	first = 1;</a>
<a name="ln863">	for (i = 0; i &lt; uio-&gt;uio_iovcnt &amp;&amp; resid != 0 &amp;&amp; !error; i++) {</a>
<a name="ln864">		/*</a>
<a name="ln865">		 * Now at the first iovec to load.  Load each iovec</a>
<a name="ln866">		 * until we have exhausted the residual count.</a>
<a name="ln867">		 */</a>
<a name="ln868">		bus_size_t minlen =</a>
<a name="ln869">			resid &lt; iov[i].iov_len ? resid : iov[i].iov_len;</a>
<a name="ln870">		caddr_t addr = (caddr_t) iov[i].iov_base;</a>
<a name="ln871"> </a>
<a name="ln872">		if (minlen &gt; 0) {</a>
<a name="ln873">			error = _bus_dmamap_load_buffer(dmat, map,</a>
<a name="ln874">					addr, minlen, pmap, flags, &amp;lastaddr,</a>
<a name="ln875">					dmat-&gt;segments, &amp;nsegs, first);</a>
<a name="ln876">			first = 0;</a>
<a name="ln877"> </a>
<a name="ln878">			resid -= minlen;</a>
<a name="ln879">		}</a>
<a name="ln880">	}</a>
<a name="ln881"> </a>
<a name="ln882">	if (error) {</a>
<a name="ln883">		/* force &quot;no valid mappings&quot; in callback */</a>
<a name="ln884">		(*callback)(callback_arg, dmat-&gt;segments, 0, 0, error);</a>
<a name="ln885">	} else {</a>
<a name="ln886">		(*callback)(callback_arg, dmat-&gt;segments,</a>
<a name="ln887">			    nsegs+1, uio-&gt;uio_resid, error);</a>
<a name="ln888">	}</a>
<a name="ln889">	CTR5(KTR_BUSDMA, &quot;%s: tag %p tag flags 0x%x error %d nsegs %d&quot;,</a>
<a name="ln890">	    __func__, dmat, dmat-&gt;flags, error, nsegs + 1);</a>
<a name="ln891">	return (error);</a>
<a name="ln892">}</a>
<a name="ln893">#endif</a>
<a name="ln894"> </a>
<a name="ln895">/*</a>
<a name="ln896"> * Release the mapping held by map.</a>
<a name="ln897"> */</a>
<a name="ln898">void</a>
<a name="ln899">_bus_dmamap_unload(bus_dma_tag_t dmat, bus_dmamap_t map)</a>
<a name="ln900">{</a>
<a name="ln901">	struct bounce_page *bpage;</a>
<a name="ln902"> </a>
<a name="ln903">	while ((bpage = STAILQ_FIRST(&amp;map-&gt;bpages)) != NULL) {</a>
<a name="ln904">		STAILQ_REMOVE_HEAD(&amp;map-&gt;bpages, links);</a>
<a name="ln905">		free_bounce_page(dmat, bpage);</a>
<a name="ln906">	}</a>
<a name="ln907">}</a>
<a name="ln908"> </a>
<a name="ln909">void</a>
<a name="ln910">_bus_dmamap_sync(bus_dma_tag_t dmat, bus_dmamap_t map, bus_dmasync_op_t op)</a>
<a name="ln911">{</a>
<a name="ln912">	struct bounce_page *bpage;</a>
<a name="ln913"> </a>
<a name="ln914">	if ((bpage = STAILQ_FIRST(&amp;map-&gt;bpages)) != NULL) {</a>
<a name="ln915">		/*</a>
<a name="ln916">		 * Handle data bouncing.  We might also</a>
<a name="ln917">		 * want to add support for invalidating</a>
<a name="ln918">		 * the caches on broken hardware</a>
<a name="ln919">		 */</a>
<a name="ln920">		dmat-&gt;bounce_zone-&gt;total_bounced++;</a>
<a name="ln921">		CTR4(KTR_BUSDMA, &quot;%s: tag %p tag flags 0x%x op 0x%x &quot;</a>
<a name="ln922">		    &quot;performing bounce&quot;, __func__, op, dmat, dmat-&gt;flags);</a>
<a name="ln923"> </a>
<a name="ln924">		if (op &amp; BUS_DMASYNC_PREWRITE) {</a>
<a name="ln925">			while (bpage != NULL) {</a>
<a name="ln926">				bcopy((void *)bpage-&gt;datavaddr,</a>
<a name="ln927">				      (void *)bpage-&gt;vaddr,</a>
<a name="ln928">				      bpage-&gt;datacount);</a>
<a name="ln929">				bpage = STAILQ_NEXT(bpage, links);</a>
<a name="ln930">			}</a>
<a name="ln931">		}</a>
<a name="ln932"> </a>
<a name="ln933">		if (op &amp; BUS_DMASYNC_POSTREAD) {</a>
<a name="ln934">			while (bpage != NULL) {</a>
<a name="ln935">				bcopy((void *)bpage-&gt;vaddr,</a>
<a name="ln936">				      (void *)bpage-&gt;datavaddr,</a>
<a name="ln937">				      bpage-&gt;datacount);</a>
<a name="ln938">				bpage = STAILQ_NEXT(bpage, links);</a>
<a name="ln939">			}</a>
<a name="ln940">		}</a>
<a name="ln941">	}</a>
<a name="ln942">}</a>
<a name="ln943"> </a>
<a name="ln944">void</a>
<a name="ln945">init_bounce_pages()</a>
<a name="ln946">{</a>
<a name="ln947"> </a>
<a name="ln948">	total_bpages = 0;</a>
<a name="ln949">	STAILQ_INIT(&amp;bounce_zone_list);</a>
<a name="ln950">	STAILQ_INIT(&amp;bounce_map_waitinglist);</a>
<a name="ln951">	STAILQ_INIT(&amp;bounce_map_callbacklist);</a>
<a name="ln952">	mtx_init(&amp;bounce_lock, &quot;bounce pages lock&quot;, NULL, MTX_DEF);</a>
<a name="ln953">}</a>
<a name="ln954"> </a>
<a name="ln955">/* Haiku extension */</a>
<a name="ln956">void</a>
<a name="ln957">uninit_bounce_pages()</a>
<a name="ln958">{</a>
<a name="ln959">	/* XXX deep free */</a>
<a name="ln960"> </a>
<a name="ln961">	mtx_destroy(&amp;bounce_lock);</a>
<a name="ln962">}</a>
<a name="ln963"> </a>
<a name="ln964">static struct sysctl_ctx_list *</a>
<a name="ln965">busdma_sysctl_tree(struct bounce_zone *bz)</a>
<a name="ln966">{</a>
<a name="ln967">	return (&amp;bz-&gt;sysctl_tree);</a>
<a name="ln968">}</a>
<a name="ln969"> </a>
<a name="ln970">static struct sysctl_oid *</a>
<a name="ln971">busdma_sysctl_tree_top(struct bounce_zone *bz)</a>
<a name="ln972">{</a>
<a name="ln973">	return (bz-&gt;sysctl_tree_top);</a>
<a name="ln974">}</a>
<a name="ln975"> </a>
<a name="ln976">static int</a>
<a name="ln977">alloc_bounce_zone(bus_dma_tag_t dmat)</a>
<a name="ln978">{</a>
<a name="ln979">	struct bounce_zone *bz;</a>
<a name="ln980"> </a>
<a name="ln981">	/* Check to see if we already have a suitable zone */</a>
<a name="ln982">	STAILQ_FOREACH(bz, &amp;bounce_zone_list, links) {</a>
<a name="ln983">		if ((dmat-&gt;alignment &lt;= bz-&gt;alignment)</a>
<a name="ln984">		 &amp;&amp; (dmat-&gt;boundary &lt;= bz-&gt;boundary)</a>
<a name="ln985">		 &amp;&amp; (dmat-&gt;lowaddr &gt;= bz-&gt;lowaddr)) {</a>
<a name="ln986">			dmat-&gt;bounce_zone = bz;</a>
<a name="ln987">			return (0);</a>
<a name="ln988">		}</a>
<a name="ln989">	}</a>
<a name="ln990"> </a>
<a name="ln991">	if ((bz = (struct bounce_zone *)malloc(sizeof(*bz), M_DEVBUF,</a>
<a name="ln992">	    M_NOWAIT | M_ZERO)) == NULL)</a>
<a name="ln993">		return (ENOMEM);</a>
<a name="ln994"> </a>
<a name="ln995">	STAILQ_INIT(&amp;bz-&gt;bounce_page_list);</a>
<a name="ln996">	bz-&gt;free_bpages = 0;</a>
<a name="ln997">	bz-&gt;reserved_bpages = 0;</a>
<a name="ln998">	bz-&gt;active_bpages = 0;</a>
<a name="ln999">	bz-&gt;lowaddr = dmat-&gt;lowaddr;</a>
<a name="ln1000">	bz-&gt;alignment = dmat-&gt;alignment;</a>
<a name="ln1001">	bz-&gt;boundary = dmat-&gt;boundary;</a>
<a name="ln1002">	snprintf(bz-&gt;zoneid, 8, &quot;zone%d&quot;, busdma_zonecount);</a>
<a name="ln1003">	busdma_zonecount++;</a>
<a name="ln1004">	snprintf(bz-&gt;lowaddrid, 18, &quot;%llx&quot;, (uintmax_t)bz-&gt;lowaddr);</a>
<a name="ln1005">	STAILQ_INSERT_TAIL(&amp;bounce_zone_list, bz, links);</a>
<a name="ln1006">	dmat-&gt;bounce_zone = bz;</a>
<a name="ln1007"> </a>
<a name="ln1008">	sysctl_ctx_init(&amp;bz-&gt;sysctl_tree);</a>
<a name="ln1009">	bz-&gt;sysctl_tree_top = SYSCTL_ADD_NODE(&amp;bz-&gt;sysctl_tree,</a>
<a name="ln1010">	    SYSCTL_STATIC_CHILDREN(_hw_busdma), OID_AUTO, bz-&gt;zoneid,</a>
<a name="ln1011">	    CTLFLAG_RD, 0, &quot;&quot;);</a>
<a name="ln1012">	if (bz-&gt;sysctl_tree_top == NULL) {</a>
<a name="ln1013">		sysctl_ctx_free(&amp;bz-&gt;sysctl_tree);</a>
<a name="ln1014">		return (0);	/* XXX error code? */</a>
<a name="ln1015">	}</a>
<a name="ln1016"> </a>
<a name="ln1017">	SYSCTL_ADD_INT(busdma_sysctl_tree(bz),</a>
<a name="ln1018">	    SYSCTL_CHILDREN(busdma_sysctl_tree_top(bz)), OID_AUTO,</a>
<a name="ln1019">	    &quot;total_bpages&quot;, CTLFLAG_RD, &amp;bz-&gt;total_bpages, 0,</a>
<a name="ln1020">	    &quot;Total bounce pages&quot;);</a>
<a name="ln1021">	SYSCTL_ADD_INT(busdma_sysctl_tree(bz),</a>
<a name="ln1022">	    SYSCTL_CHILDREN(busdma_sysctl_tree_top(bz)), OID_AUTO,</a>
<a name="ln1023">	    &quot;free_bpages&quot;, CTLFLAG_RD, &amp;bz-&gt;free_bpages, 0,</a>
<a name="ln1024">	    &quot;Free bounce pages&quot;);</a>
<a name="ln1025">	SYSCTL_ADD_INT(busdma_sysctl_tree(bz),</a>
<a name="ln1026">	    SYSCTL_CHILDREN(busdma_sysctl_tree_top(bz)), OID_AUTO,</a>
<a name="ln1027">	    &quot;reserved_bpages&quot;, CTLFLAG_RD, &amp;bz-&gt;reserved_bpages, 0,</a>
<a name="ln1028">	    &quot;Reserved bounce pages&quot;);</a>
<a name="ln1029">	SYSCTL_ADD_INT(busdma_sysctl_tree(bz),</a>
<a name="ln1030">	    SYSCTL_CHILDREN(busdma_sysctl_tree_top(bz)), OID_AUTO,</a>
<a name="ln1031">	    &quot;active_bpages&quot;, CTLFLAG_RD, &amp;bz-&gt;active_bpages, 0,</a>
<a name="ln1032">	    &quot;Active bounce pages&quot;);</a>
<a name="ln1033">	SYSCTL_ADD_INT(busdma_sysctl_tree(bz),</a>
<a name="ln1034">	    SYSCTL_CHILDREN(busdma_sysctl_tree_top(bz)), OID_AUTO,</a>
<a name="ln1035">	    &quot;total_bounced&quot;, CTLFLAG_RD, &amp;bz-&gt;total_bounced, 0,</a>
<a name="ln1036">	    &quot;Total bounce requests&quot;);</a>
<a name="ln1037">	SYSCTL_ADD_INT(busdma_sysctl_tree(bz),</a>
<a name="ln1038">	    SYSCTL_CHILDREN(busdma_sysctl_tree_top(bz)), OID_AUTO,</a>
<a name="ln1039">	    &quot;total_deferred&quot;, CTLFLAG_RD, &amp;bz-&gt;total_deferred, 0,</a>
<a name="ln1040">	    &quot;Total bounce requests that were deferred&quot;);</a>
<a name="ln1041">	SYSCTL_ADD_STRING(busdma_sysctl_tree(bz),</a>
<a name="ln1042">	    SYSCTL_CHILDREN(busdma_sysctl_tree_top(bz)), OID_AUTO,</a>
<a name="ln1043">	    &quot;lowaddr&quot;, CTLFLAG_RD, bz-&gt;lowaddrid, 0, &quot;&quot;);</a>
<a name="ln1044">	SYSCTL_ADD_INT(busdma_sysctl_tree(bz),</a>
<a name="ln1045">	    SYSCTL_CHILDREN(busdma_sysctl_tree_top(bz)), OID_AUTO,</a>
<a name="ln1046">	    &quot;alignment&quot;, CTLFLAG_RD, &amp;bz-&gt;alignment, 0, &quot;&quot;);</a>
<a name="ln1047">	SYSCTL_ADD_INT(busdma_sysctl_tree(bz),</a>
<a name="ln1048">	    SYSCTL_CHILDREN(busdma_sysctl_tree_top(bz)), OID_AUTO,</a>
<a name="ln1049">	    &quot;boundary&quot;, CTLFLAG_RD, &amp;bz-&gt;boundary, 0, &quot;&quot;);</a>
<a name="ln1050"> </a>
<a name="ln1051">	return (0);</a>
<a name="ln1052">}</a>
<a name="ln1053"> </a>
<a name="ln1054">static int</a>
<a name="ln1055">alloc_bounce_pages(bus_dma_tag_t dmat, u_int numpages)</a>
<a name="ln1056">{</a>
<a name="ln1057">	struct bounce_zone *bz;</a>
<a name="ln1058">	int count;</a>
<a name="ln1059"> </a>
<a name="ln1060">	bz = dmat-&gt;bounce_zone;</a>
<a name="ln1061">	count = 0;</a>
<a name="ln1062">	while (numpages &gt; 0) {</a>
<a name="ln1063">		struct bounce_page *bpage;</a>
<a name="ln1064"> </a>
<a name="ln1065">		bpage = (struct bounce_page *)malloc(sizeof(*bpage), M_DEVBUF,</a>
<a name="ln1066">						     M_NOWAIT | M_ZERO);</a>
<a name="ln1067"> </a>
<a name="ln1068">		if (bpage == NULL)</a>
<a name="ln1069">			break;</a>
<a name="ln1070">		bpage-&gt;vaddr = (vm_offset_t)contigmalloc(PAGE_SIZE, M_DEVBUF,</a>
<a name="ln1071">							 M_NOWAIT, 0ul,</a>
<a name="ln1072">							 bz-&gt;lowaddr,</a>
<a name="ln1073">							 PAGE_SIZE,</a>
<a name="ln1074">							 bz-&gt;boundary);</a>
<a name="ln1075">		if (bpage-&gt;vaddr == 0) {</a>
<a name="ln1076">			free(bpage, M_DEVBUF);</a>
<a name="ln1077">			break;</a>
<a name="ln1078">		}</a>
<a name="ln1079">		bpage-&gt;busaddr = pmap_kextract(bpage-&gt;vaddr);</a>
<a name="ln1080">		mtx_lock(&amp;bounce_lock);</a>
<a name="ln1081">		STAILQ_INSERT_TAIL(&amp;bz-&gt;bounce_page_list, bpage, links);</a>
<a name="ln1082">		total_bpages++;</a>
<a name="ln1083">		bz-&gt;total_bpages++;</a>
<a name="ln1084">		bz-&gt;free_bpages++;</a>
<a name="ln1085">		mtx_unlock(&amp;bounce_lock);</a>
<a name="ln1086">		count++;</a>
<a name="ln1087">		numpages--;</a>
<a name="ln1088">	}</a>
<a name="ln1089">	return (count);</a>
<a name="ln1090">}</a>
<a name="ln1091"> </a>
<a name="ln1092">static int</a>
<a name="ln1093">reserve_bounce_pages(bus_dma_tag_t dmat, bus_dmamap_t map, int commit)</a>
<a name="ln1094">{</a>
<a name="ln1095">	struct bounce_zone *bz;</a>
<a name="ln1096">	int pages;</a>
<a name="ln1097"> </a>
<a name="ln1098">	mtx_assert(&amp;bounce_lock, MA_OWNED);</a>
<a name="ln1099">	bz = dmat-&gt;bounce_zone;</a>
<a name="ln1100">	pages = MIN(bz-&gt;free_bpages, map-&gt;pagesneeded - map-&gt;pagesreserved);</a>
<a name="ln1101">	if (commit == 0 &amp;&amp; map-&gt;pagesneeded &gt; (map-&gt;pagesreserved + pages))</a>
<a name="ln1102">		return (map-&gt;pagesneeded - (map-&gt;pagesreserved + pages));</a>
<a name="ln1103">	bz-&gt;free_bpages -= pages;</a>
<a name="ln1104">	bz-&gt;reserved_bpages += pages;</a>
<a name="ln1105">	map-&gt;pagesreserved += pages;</a>
<a name="ln1106">	pages = map-&gt;pagesneeded - map-&gt;pagesreserved;</a>
<a name="ln1107"> </a>
<a name="ln1108">	return (pages);</a>
<a name="ln1109">}</a>
<a name="ln1110"> </a>
<a name="ln1111">static bus_addr_t</a>
<a name="ln1112">add_bounce_page(bus_dma_tag_t dmat, bus_dmamap_t map, vm_offset_t vaddr,</a>
<a name="ln1113">		bus_size_t size)</a>
<a name="ln1114">{</a>
<a name="ln1115">	struct bounce_zone *bz;</a>
<a name="ln1116">	struct bounce_page *bpage;</a>
<a name="ln1117"> </a>
<a name="ln1118">	KASSERT(dmat-&gt;bounce_zone != NULL, (&quot;no bounce zone in dma tag&quot;));</a>
<a name="ln1119">	KASSERT(map != NULL &amp;&amp; map != &amp;nobounce_dmamap,</a>
<a name="ln1120">	    (&quot;add_bounce_page: bad map %p&quot;, map));</a>
<a name="ln1121"> </a>
<a name="ln1122">	bz = dmat-&gt;bounce_zone;</a>
<a name="ln1123">	if (map-&gt;pagesneeded == 0)</a>
<a name="ln1124">		panic(&quot;add_bounce_page: map doesn't need any pages&quot;);</a>
<a name="ln1125">	map-&gt;pagesneeded--;</a>
<a name="ln1126"> </a>
<a name="ln1127">	if (map-&gt;pagesreserved == 0)</a>
<a name="ln1128">		panic(&quot;add_bounce_page: map doesn't need any pages&quot;);</a>
<a name="ln1129">	map-&gt;pagesreserved--;</a>
<a name="ln1130"> </a>
<a name="ln1131">	mtx_lock(&amp;bounce_lock);</a>
<a name="ln1132">	bpage = STAILQ_FIRST(&amp;bz-&gt;bounce_page_list);</a>
<a name="ln1133">	if (bpage == NULL)</a>
<a name="ln1134">		panic(&quot;add_bounce_page: free page list is empty&quot;);</a>
<a name="ln1135"> </a>
<a name="ln1136">	STAILQ_REMOVE_HEAD(&amp;bz-&gt;bounce_page_list, links);</a>
<a name="ln1137">	bz-&gt;reserved_bpages--;</a>
<a name="ln1138">	bz-&gt;active_bpages++;</a>
<a name="ln1139">	mtx_unlock(&amp;bounce_lock);</a>
<a name="ln1140"> </a>
<a name="ln1141">	bpage-&gt;datavaddr = vaddr;</a>
<a name="ln1142">	bpage-&gt;datacount = size;</a>
<a name="ln1143">	STAILQ_INSERT_TAIL(&amp;(map-&gt;bpages), bpage, links);</a>
<a name="ln1144">	return (bpage-&gt;busaddr);</a>
<a name="ln1145">}</a>
<a name="ln1146"> </a>
<a name="ln1147">static void</a>
<a name="ln1148">free_bounce_page(bus_dma_tag_t dmat, struct bounce_page *bpage)</a>
<a name="ln1149">{</a>
<a name="ln1150">	struct bus_dmamap *map;</a>
<a name="ln1151">	struct bounce_zone *bz;</a>
<a name="ln1152"> </a>
<a name="ln1153">	bz = dmat-&gt;bounce_zone;</a>
<a name="ln1154">	bpage-&gt;datavaddr = 0;</a>
<a name="ln1155">	bpage-&gt;datacount = 0;</a>
<a name="ln1156"> </a>
<a name="ln1157">	mtx_lock(&amp;bounce_lock);</a>
<a name="ln1158">	STAILQ_INSERT_HEAD(&amp;bz-&gt;bounce_page_list, bpage, links);</a>
<a name="ln1159">	bz-&gt;free_bpages++;</a>
<a name="ln1160">	bz-&gt;active_bpages--;</a>
<a name="ln1161">	if ((map = STAILQ_FIRST(&amp;bounce_map_waitinglist)) != NULL) {</a>
<a name="ln1162">		if (reserve_bounce_pages(map-&gt;dmat, map, 1) == 0) {</a>
<a name="ln1163">			STAILQ_REMOVE_HEAD(&amp;bounce_map_waitinglist, links);</a>
<a name="ln1164">			STAILQ_INSERT_TAIL(&amp;bounce_map_callbacklist,</a>
<a name="ln1165">					   map, links);</a>
<a name="ln1166">			busdma_swi_pending = 1;</a>
<a name="ln1167">			bz-&gt;total_deferred++;</a>
<a name="ln1168">#if 0</a>
<a name="ln1169">			swi_sched(vm_ih, 0);</a>
<a name="ln1170">#endif</a>
<a name="ln1171">			busdma_swi();</a>
<a name="ln1172">		}</a>
<a name="ln1173">	}</a>
<a name="ln1174">	mtx_unlock(&amp;bounce_lock);</a>
<a name="ln1175">}</a>
<a name="ln1176"> </a>
<a name="ln1177">void</a>
<a name="ln1178">busdma_swi(void)</a>
<a name="ln1179">{</a>
<a name="ln1180">	bus_dma_tag_t dmat;</a>
<a name="ln1181">	struct bus_dmamap *map;</a>
<a name="ln1182"> </a>
<a name="ln1183">	mtx_lock(&amp;bounce_lock);</a>
<a name="ln1184">	while ((map = STAILQ_FIRST(&amp;bounce_map_callbacklist)) != NULL) {</a>
<a name="ln1185">		STAILQ_REMOVE_HEAD(&amp;bounce_map_callbacklist, links);</a>
<a name="ln1186">		mtx_unlock(&amp;bounce_lock);</a>
<a name="ln1187">		dmat = map-&gt;dmat;</a>
<a name="ln1188">		(dmat-&gt;lockfunc)(dmat-&gt;lockfuncarg, BUS_DMA_LOCK);</a>
<a name="ln1189">		bus_dmamap_load(map-&gt;dmat, map, map-&gt;buf, map-&gt;buflen,</a>
<a name="ln1190">				map-&gt;callback, map-&gt;callback_arg, /*flags*/0);</a>
<a name="ln1191">		(dmat-&gt;lockfunc)(dmat-&gt;lockfuncarg, BUS_DMA_UNLOCK);</a>
<a name="ln1192">		mtx_lock(&amp;bounce_lock);</a>
<a name="ln1193">	}</a>
<a name="ln1194">	mtx_unlock(&amp;bounce_lock);</a>
<a name="ln1195">}</a>

</code></pre>
<div class="balloon" rel="304"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v629/" target="_blank">V629</a> Consider inspecting the '(bz->total_bpages) << 12' expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
