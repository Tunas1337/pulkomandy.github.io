
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ns_name.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*	$NetBSD: ns_name.c,v 1.9 2012/03/13 21:13:39 christos Exp $	*/</a>
<a name="ln2"> </a>
<a name="ln3">/*</a>
<a name="ln4"> * Copyright (c) 2004 by Internet Systems Consortium, Inc. (&quot;ISC&quot;)</a>
<a name="ln5"> * Copyright (c) 1996,1999 by Internet Software Consortium.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Permission to use, copy, modify, and distribute this software for any</a>
<a name="ln8"> * purpose with or without fee is hereby granted, provided that the above</a>
<a name="ln9"> * copyright notice and this permission notice appear in all copies.</a>
<a name="ln10"> *</a>
<a name="ln11"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND ISC DISCLAIMS ALL WARRANTIES</a>
<a name="ln12"> * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</a>
<a name="ln13"> * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR</a>
<a name="ln14"> * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</a>
<a name="ln15"> * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</a>
<a name="ln16"> * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT</a>
<a name="ln17"> * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</a>
<a name="ln18"> */</a>
<a name="ln19"> </a>
<a name="ln20">#ifndef lint</a>
<a name="ln21">static const char rcsid[] = &quot;$Id: ns_name.c,v 1.11 2009/01/23 19:59:16 each Exp $&quot;;</a>
<a name="ln22">#endif</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;port_before.h&quot;</a>
<a name="ln25"> </a>
<a name="ln26">#include &lt;sys/types.h&gt;</a>
<a name="ln27"> </a>
<a name="ln28">#include &lt;netinet/in.h&gt;</a>
<a name="ln29">#include &lt;arpa/nameser.h&gt;</a>
<a name="ln30"> </a>
<a name="ln31">#include &lt;assert.h&gt;</a>
<a name="ln32">#include &lt;errno.h&gt;</a>
<a name="ln33">#include &lt;resolv.h&gt;</a>
<a name="ln34">#include &lt;string.h&gt;</a>
<a name="ln35">#include &lt;ctype.h&gt;</a>
<a name="ln36">#include &lt;stdlib.h&gt;</a>
<a name="ln37">#include &lt;limits.h&gt;</a>
<a name="ln38"> </a>
<a name="ln39">#include &quot;port_after.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41">#ifdef SPRINTF_CHAR</a>
<a name="ln42"># define SPRINTF(x) ((int)strlen(sprintf/**/x))</a>
<a name="ln43">#else</a>
<a name="ln44"># define SPRINTF(x) (sprintf x)</a>
<a name="ln45">#endif</a>
<a name="ln46"> </a>
<a name="ln47">#define NS_TYPE_ELT			0x40 /*%&lt; EDNS0 extended label type */</a>
<a name="ln48">#define DNS_LABELTYPE_BITSTRING		0x41</a>
<a name="ln49"> </a>
<a name="ln50">/* Data. */</a>
<a name="ln51"> </a>
<a name="ln52">static const char	digits[] = &quot;0123456789&quot;;</a>
<a name="ln53"> </a>
<a name="ln54">static const char digitvalue[256] = {</a>
<a name="ln55">	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,	/*16*/</a>
<a name="ln56">	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /*32*/</a>
<a name="ln57">	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /*48*/</a>
<a name="ln58">	 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, /*64*/</a>
<a name="ln59">	-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, /*80*/</a>
<a name="ln60">	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /*96*/</a>
<a name="ln61">	-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, /*112*/</a>
<a name="ln62">	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /*128*/</a>
<a name="ln63">	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,</a>
<a name="ln64">	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,</a>
<a name="ln65">	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,</a>
<a name="ln66">	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,</a>
<a name="ln67">	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,</a>
<a name="ln68">	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,</a>
<a name="ln69">	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,</a>
<a name="ln70">	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /*256*/</a>
<a name="ln71">};</a>
<a name="ln72"> </a>
<a name="ln73">/* Forward. */</a>
<a name="ln74"> </a>
<a name="ln75">static int		special(int);</a>
<a name="ln76">static int		printable(int);</a>
<a name="ln77">static int		dn_find(const u_char *, const u_char *,</a>
<a name="ln78">				const u_char * const *,</a>
<a name="ln79">				const u_char * const *);</a>
<a name="ln80">static int		encode_bitsring(const char **, const char *,</a>
<a name="ln81">					unsigned char **, unsigned char **,</a>
<a name="ln82">					unsigned const char *);</a>
<a name="ln83">static int		labellen(const u_char *);</a>
<a name="ln84">static int		decode_bitstring(const unsigned char **,</a>
<a name="ln85">					 char *, const char *);</a>
<a name="ln86"> </a>
<a name="ln87">/* Public. */</a>
<a name="ln88"> </a>
<a name="ln89">/*%</a>
<a name="ln90"> *	Convert an encoded domain name to printable ascii as per RFC1035.</a>
<a name="ln91"> </a>
<a name="ln92"> * return:</a>
<a name="ln93"> *\li	Number of bytes written to buffer, or -1 (with errno set)</a>
<a name="ln94"> *</a>
<a name="ln95"> * notes:</a>
<a name="ln96"> *\li	The root is returned as &quot;.&quot;</a>
<a name="ln97"> *\li	All other domains are returned in non absolute form</a>
<a name="ln98"> */</a>
<a name="ln99">int</a>
<a name="ln100">ns_name_ntop(const u_char *src, char *dst, size_t dstsiz)</a>
<a name="ln101">{</a>
<a name="ln102">	const u_char *cp;</a>
<a name="ln103">	char *dn, *eom;</a>
<a name="ln104">	u_char c;</a>
<a name="ln105">	u_int n;</a>
<a name="ln106">	int l;</a>
<a name="ln107"> </a>
<a name="ln108">	cp = src;</a>
<a name="ln109">	dn = dst;</a>
<a name="ln110">	eom = dst + dstsiz;</a>
<a name="ln111"> </a>
<a name="ln112">	while ((n = *cp++) != 0) {</a>
<a name="ln113">		if ((n &amp; NS_CMPRSFLGS) == NS_CMPRSFLGS) {</a>
<a name="ln114">			/* Some kind of compression pointer. */</a>
<a name="ln115">			errno = EMSGSIZE;</a>
<a name="ln116">			return (-1);</a>
<a name="ln117">		}</a>
<a name="ln118">		if (dn != dst) {</a>
<a name="ln119">			if (dn &gt;= eom) {</a>
<a name="ln120">				errno = EMSGSIZE;</a>
<a name="ln121">				return (-1);</a>
<a name="ln122">			}</a>
<a name="ln123">			*dn++ = '.';</a>
<a name="ln124">		}</a>
<a name="ln125">		if ((l = labellen(cp - 1)) &lt; 0) {</a>
<a name="ln126">			errno = EMSGSIZE; /*%&lt; XXX */</a>
<a name="ln127">			return (-1);</a>
<a name="ln128">		}</a>
<a name="ln129">		if (dn + l &gt;= eom) {</a>
<a name="ln130">			errno = EMSGSIZE;</a>
<a name="ln131">			return (-1);</a>
<a name="ln132">		}</a>
<a name="ln133">		if ((n &amp; NS_CMPRSFLGS) == NS_TYPE_ELT) {</a>
<a name="ln134">			int m;</a>
<a name="ln135"> </a>
<a name="ln136">			if (n != DNS_LABELTYPE_BITSTRING) {</a>
<a name="ln137">				/* XXX: labellen should reject this case */</a>
<a name="ln138">				errno = EINVAL;</a>
<a name="ln139">				return (-1);</a>
<a name="ln140">			}</a>
<a name="ln141">			if ((m = decode_bitstring(&amp;cp, dn, eom)) &lt; 0)</a>
<a name="ln142">			{</a>
<a name="ln143">				errno = EMSGSIZE;</a>
<a name="ln144">				return (-1);</a>
<a name="ln145">			}</a>
<a name="ln146">			dn += m; </a>
<a name="ln147">			continue;</a>
<a name="ln148">		}</a>
<a name="ln149">		for (; l &gt; 0; l--) {</a>
<a name="ln150">			c = *cp++;</a>
<a name="ln151">			if (special(c)) {</a>
<a name="ln152">				if (dn + 1 &gt;= eom) {</a>
<a name="ln153">					errno = EMSGSIZE;</a>
<a name="ln154">					return (-1);</a>
<a name="ln155">				}</a>
<a name="ln156">				*dn++ = '\\';</a>
<a name="ln157">				*dn++ = (char)c;</a>
<a name="ln158">			} else if (!printable(c)) {</a>
<a name="ln159">				if (dn + 3 &gt;= eom) {</a>
<a name="ln160">					errno = EMSGSIZE;</a>
<a name="ln161">					return (-1);</a>
<a name="ln162">				}</a>
<a name="ln163">				*dn++ = '\\';</a>
<a name="ln164">				*dn++ = digits[c / 100];</a>
<a name="ln165">				*dn++ = digits[(c % 100) / 10];</a>
<a name="ln166">				*dn++ = digits[c % 10];</a>
<a name="ln167">			} else {</a>
<a name="ln168">				if (dn &gt;= eom) {</a>
<a name="ln169">					errno = EMSGSIZE;</a>
<a name="ln170">					return (-1);</a>
<a name="ln171">				}</a>
<a name="ln172">				*dn++ = (char)c;</a>
<a name="ln173">			}</a>
<a name="ln174">		}</a>
<a name="ln175">	}</a>
<a name="ln176">	if (dn == dst) {</a>
<a name="ln177">		if (dn &gt;= eom) {</a>
<a name="ln178">			errno = EMSGSIZE;</a>
<a name="ln179">			return (-1);</a>
<a name="ln180">		}</a>
<a name="ln181">		*dn++ = '.';</a>
<a name="ln182">	}</a>
<a name="ln183">	if (dn &gt;= eom) {</a>
<a name="ln184">		errno = EMSGSIZE;</a>
<a name="ln185">		return (-1);</a>
<a name="ln186">	}</a>
<a name="ln187">	*dn++ = '\0';</a>
<a name="ln188">	assert(INT_MIN &lt;= (dn - dst) &amp;&amp; (dn - dst) &lt;= INT_MAX);</a>
<a name="ln189">	return (int)(dn - dst);</a>
<a name="ln190">}</a>
<a name="ln191"> </a>
<a name="ln192">/*%</a>
<a name="ln193"> *	Convert a ascii string into an encoded domain name as per RFC1035.</a>
<a name="ln194"> *</a>
<a name="ln195"> * return:</a>
<a name="ln196"> *</a>
<a name="ln197"> *\li	-1 if it fails</a>
<a name="ln198"> *\li	1 if string was fully qualified</a>
<a name="ln199"> *\li	0 is string was not fully qualified</a>
<a name="ln200"> *</a>
<a name="ln201"> * notes:</a>
<a name="ln202"> *\li	Enforces label and domain length limits.</a>
<a name="ln203"> */</a>
<a name="ln204">int</a>
<a name="ln205">ns_name_pton(const char *src, u_char *dst, size_t dstsiz) {</a>
<a name="ln206">	return (ns_name_pton2(src, dst, dstsiz, NULL));</a>
<a name="ln207">}</a>
<a name="ln208"> </a>
<a name="ln209">/*</a>
<a name="ln210"> * ns_name_pton2(src, dst, dstsiz, *dstlen)</a>
<a name="ln211"> *	Convert a ascii string into an encoded domain name as per RFC1035.</a>
<a name="ln212"> * return:</a>
<a name="ln213"> *	-1 if it fails</a>
<a name="ln214"> *	1 if string was fully qualified</a>
<a name="ln215"> *	0 is string was not fully qualified</a>
<a name="ln216"> * side effects:</a>
<a name="ln217"> *	fills in *dstlen (if non-NULL)</a>
<a name="ln218"> * notes:</a>
<a name="ln219"> *	Enforces label and domain length limits.</a>
<a name="ln220"> */</a>
<a name="ln221">int</a>
<a name="ln222">ns_name_pton2(const char *src, u_char *dst, size_t dstsiz, size_t *dstlen) {</a>
<a name="ln223">	u_char *label, *bp, *eom;</a>
<a name="ln224">	int c, n, escaped, e = 0;</a>
<a name="ln225">	char *cp;</a>
<a name="ln226"> </a>
<a name="ln227">	escaped = 0;</a>
<a name="ln228">	bp = dst;</a>
<a name="ln229">	eom = dst + dstsiz;</a>
<a name="ln230">	label = bp++;</a>
<a name="ln231"> </a>
<a name="ln232">	while ((c = *src++) != 0) {</a>
<a name="ln233">		if (escaped) {</a>
<a name="ln234">			if (c == '[') { /*%&lt; start a bit string label */</a>
<a name="ln235">				if ((cp = strchr(src, ']')) == NULL) {</a>
<a name="ln236">					errno = EINVAL; /*%&lt; ??? */</a>
<a name="ln237">					return (-1);</a>
<a name="ln238">				}</a>
<a name="ln239">				if ((e = encode_bitsring(&amp;src, cp + 2,</a>
<a name="ln240">							 &amp;label, &amp;bp, eom))</a>
<a name="ln241">				    != 0) {</a>
<a name="ln242">					errno = e;</a>
<a name="ln243">					return (-1);</a>
<a name="ln244">				}</a>
<a name="ln245">				escaped = 0;</a>
<a name="ln246">				label = bp++;</a>
<a name="ln247">				if ((c = *src++) == 0)</a>
<a name="ln248">					goto done;</a>
<a name="ln249">				else if (c != '.') {</a>
<a name="ln250">					errno = EINVAL;</a>
<a name="ln251">					return	(-1);</a>
<a name="ln252">				}</a>
<a name="ln253">				continue;</a>
<a name="ln254">			}</a>
<a name="ln255">			else if ((cp = strchr(digits, c)) != NULL) {</a>
<a name="ln256">				n = (int)(cp - digits) * 100;</a>
<a name="ln257">				if ((c = *src++) == 0 ||</a>
<a name="ln258">				    (cp = strchr(digits, c)) == NULL) {</a>
<a name="ln259">					errno = EMSGSIZE;</a>
<a name="ln260">					return (-1);</a>
<a name="ln261">				}</a>
<a name="ln262">				n += (int)(cp - digits) * 10;</a>
<a name="ln263">				if ((c = *src++) == 0 ||</a>
<a name="ln264">				    (cp = strchr(digits, c)) == NULL) {</a>
<a name="ln265">					errno = EMSGSIZE;</a>
<a name="ln266">					return (-1);</a>
<a name="ln267">				}</a>
<a name="ln268">				n += (int)(cp - digits);</a>
<a name="ln269">				if (n &gt; 255) {</a>
<a name="ln270">					errno = EMSGSIZE;</a>
<a name="ln271">					return (-1);</a>
<a name="ln272">				}</a>
<a name="ln273">				c = n;</a>
<a name="ln274">			}</a>
<a name="ln275">			escaped = 0;</a>
<a name="ln276">		} else if (c == '\\') {</a>
<a name="ln277">			escaped = 1;</a>
<a name="ln278">			continue;</a>
<a name="ln279">		} else if (c == '.') {</a>
<a name="ln280">			c = (int)(bp - label - 1);</a>
<a name="ln281">			if ((c &amp; NS_CMPRSFLGS) != 0) {	/*%&lt; Label too big. */</a>
<a name="ln282">				errno = EMSGSIZE;</a>
<a name="ln283">				return (-1);</a>
<a name="ln284">			}</a>
<a name="ln285">			if (label &gt;= eom) {</a>
<a name="ln286">				errno = EMSGSIZE;</a>
<a name="ln287">				return (-1);</a>
<a name="ln288">			}</a>
<a name="ln289">			*label = c;</a>
<a name="ln290">			/* Fully qualified ? */</a>
<a name="ln291">			if (*src == '\0') {</a>
<a name="ln292">				if (c != 0) {</a>
<a name="ln293">					if (bp &gt;= eom) {</a>
<a name="ln294">						errno = EMSGSIZE;</a>
<a name="ln295">						return (-1);</a>
<a name="ln296">					}</a>
<a name="ln297">					*bp++ = '\0';</a>
<a name="ln298">				}</a>
<a name="ln299">				if ((bp - dst) &gt; MAXCDNAME) {</a>
<a name="ln300">					errno = EMSGSIZE;</a>
<a name="ln301">					return (-1);</a>
<a name="ln302">				}</a>
<a name="ln303">				if (dstlen != NULL)</a>
<a name="ln304">					*dstlen = (bp - dst);</a>
<a name="ln305">				return (1);</a>
<a name="ln306">			}</a>
<a name="ln307">			if (c == 0 || *src == '.') {</a>
<a name="ln308">				errno = EMSGSIZE;</a>
<a name="ln309">				return (-1);</a>
<a name="ln310">			}</a>
<a name="ln311">			label = bp++;</a>
<a name="ln312">			continue;</a>
<a name="ln313">		}</a>
<a name="ln314">		if (bp &gt;= eom) {</a>
<a name="ln315">			errno = EMSGSIZE;</a>
<a name="ln316">			return (-1);</a>
<a name="ln317">		}</a>
<a name="ln318">		*bp++ = (u_char)c;</a>
<a name="ln319">	}</a>
<a name="ln320">	c = (int)(bp - label - 1);</a>
<a name="ln321">	if ((c &amp; NS_CMPRSFLGS) != 0) {		/*%&lt; Label too big. */</a>
<a name="ln322">		errno = EMSGSIZE;</a>
<a name="ln323">		return (-1);</a>
<a name="ln324">	}</a>
<a name="ln325">  done:</a>
<a name="ln326">	if (label &gt;= eom) {</a>
<a name="ln327">		errno = EMSGSIZE;</a>
<a name="ln328">		return (-1);</a>
<a name="ln329">	}</a>
<a name="ln330">	*label = c;</a>
<a name="ln331">	if (c != 0) {</a>
<a name="ln332">		if (bp &gt;= eom) {</a>
<a name="ln333">			errno = EMSGSIZE;</a>
<a name="ln334">			return (-1);</a>
<a name="ln335">		}</a>
<a name="ln336">		*bp++ = 0;</a>
<a name="ln337">	}</a>
<a name="ln338">	if ((bp - dst) &gt; MAXCDNAME) {	/*%&lt; src too big */</a>
<a name="ln339">		errno = EMSGSIZE;</a>
<a name="ln340">		return (-1);</a>
<a name="ln341">	}</a>
<a name="ln342">	if (dstlen != NULL)</a>
<a name="ln343">		*dstlen = (bp - dst);</a>
<a name="ln344">	return (0);</a>
<a name="ln345">}</a>
<a name="ln346"> </a>
<a name="ln347">/*%</a>
<a name="ln348"> *	Convert a network strings labels into all lowercase.</a>
<a name="ln349"> *</a>
<a name="ln350"> * return:</a>
<a name="ln351"> *\li	Number of bytes written to buffer, or -1 (with errno set)</a>
<a name="ln352"> *</a>
<a name="ln353"> * notes:</a>
<a name="ln354"> *\li	Enforces label and domain length limits.</a>
<a name="ln355"> */</a>
<a name="ln356"> </a>
<a name="ln357">int</a>
<a name="ln358">ns_name_ntol(const u_char *src, u_char *dst, size_t dstsiz)</a>
<a name="ln359">{</a>
<a name="ln360">	const u_char *cp;</a>
<a name="ln361">	u_char *dn, *eom;</a>
<a name="ln362">	u_char c;</a>
<a name="ln363">	u_int n;</a>
<a name="ln364">	int l;</a>
<a name="ln365"> </a>
<a name="ln366">	cp = src;</a>
<a name="ln367">	dn = dst;</a>
<a name="ln368">	eom = dst + dstsiz;</a>
<a name="ln369"> </a>
<a name="ln370">	if (dn &gt;= eom) {</a>
<a name="ln371">		errno = EMSGSIZE;</a>
<a name="ln372">		return (-1);</a>
<a name="ln373">	}</a>
<a name="ln374">	while ((n = *cp++) != 0) {</a>
<a name="ln375">		if ((n &amp; NS_CMPRSFLGS) == NS_CMPRSFLGS) {</a>
<a name="ln376">			/* Some kind of compression pointer. */</a>
<a name="ln377">			errno = EMSGSIZE;</a>
<a name="ln378">			return (-1);</a>
<a name="ln379">		}</a>
<a name="ln380">		*dn++ = n;</a>
<a name="ln381">		if ((l = labellen(cp - 1)) &lt; 0) {</a>
<a name="ln382">			errno = EMSGSIZE;</a>
<a name="ln383">			return (-1);</a>
<a name="ln384">		}</a>
<a name="ln385">		if (dn + l &gt;= eom) {</a>
<a name="ln386">			errno = EMSGSIZE;</a>
<a name="ln387">			return (-1);</a>
<a name="ln388">		}</a>
<a name="ln389">		for (; l &gt; 0; l--) {</a>
<a name="ln390">			c = *cp++;</a>
<a name="ln391">			if (isascii(c) &amp;&amp; isupper(c))</a>
<a name="ln392">				*dn++ = tolower(c);</a>
<a name="ln393">			else</a>
<a name="ln394">				*dn++ = c;</a>
<a name="ln395">		}</a>
<a name="ln396">	}</a>
<a name="ln397">	*dn++ = '\0';</a>
<a name="ln398">	assert(INT_MIN &lt;= (dn - dst) &amp;&amp; (dn - dst) &lt;= INT_MAX);</a>
<a name="ln399">	return (int)(dn - dst);</a>
<a name="ln400">}</a>
<a name="ln401"> </a>
<a name="ln402">/*%</a>
<a name="ln403"> *	Unpack a domain name from a message, source may be compressed.</a>
<a name="ln404"> *</a>
<a name="ln405"> * return:</a>
<a name="ln406"> *\li	-1 if it fails, or consumed octets if it succeeds.</a>
<a name="ln407"> */</a>
<a name="ln408">int</a>
<a name="ln409">ns_name_unpack(const u_char *msg, const u_char *eom, const u_char *src,</a>
<a name="ln410">	       u_char *dst, size_t dstsiz)</a>
<a name="ln411">{</a>
<a name="ln412">	return (ns_name_unpack2(msg, eom, src, dst, dstsiz, NULL));</a>
<a name="ln413">}</a>
<a name="ln414"> </a>
<a name="ln415">/*</a>
<a name="ln416"> * ns_name_unpack2(msg, eom, src, dst, dstsiz, *dstlen)</a>
<a name="ln417"> *	Unpack a domain name from a message, source may be compressed.</a>
<a name="ln418"> * return:</a>
<a name="ln419"> *	-1 if it fails, or consumed octets if it succeeds.</a>
<a name="ln420"> * side effect:</a>
<a name="ln421"> *	fills in *dstlen (if non-NULL).</a>
<a name="ln422"> */</a>
<a name="ln423">int</a>
<a name="ln424">ns_name_unpack2(const u_char *msg, const u_char *eom, const u_char *src,</a>
<a name="ln425">		u_char *dst, size_t dstsiz, size_t *dstlen)</a>
<a name="ln426">{</a>
<a name="ln427">	const u_char *srcp, *dstlim;</a>
<a name="ln428">	u_char *dstp;</a>
<a name="ln429">	int n, len, checked, l;</a>
<a name="ln430"> </a>
<a name="ln431">	len = -1;</a>
<a name="ln432">	checked = 0;</a>
<a name="ln433">	dstp = dst;</a>
<a name="ln434">	srcp = src;</a>
<a name="ln435">	dstlim = dst + dstsiz;</a>
<a name="ln436">	if (srcp &lt; msg || srcp &gt;= eom) {</a>
<a name="ln437">		errno = EMSGSIZE;</a>
<a name="ln438">		return (-1);</a>
<a name="ln439">	}</a>
<a name="ln440">	/* Fetch next label in domain name. */</a>
<a name="ln441">	while ((n = *srcp++) != 0) {</a>
<a name="ln442">		/* Check for indirection. */</a>
<a name="ln443">		switch (n &amp; NS_CMPRSFLGS) {</a>
<a name="ln444">		case 0:</a>
<a name="ln445">		case NS_TYPE_ELT:</a>
<a name="ln446">			/* Limit checks. */</a>
<a name="ln447">			if ((l = labellen(srcp - 1)) &lt; 0) {</a>
<a name="ln448">				errno = EMSGSIZE;</a>
<a name="ln449">				return (-1);</a>
<a name="ln450">			}</a>
<a name="ln451">			if (dstp + l + 1 &gt;= dstlim || srcp + l &gt;= eom) {</a>
<a name="ln452">				errno = EMSGSIZE;</a>
<a name="ln453">				return (-1);</a>
<a name="ln454">			}</a>
<a name="ln455">			checked += l + 1;</a>
<a name="ln456">			*dstp++ = n;</a>
<a name="ln457">			memcpy(dstp, srcp, (size_t)l);</a>
<a name="ln458">			dstp += l;</a>
<a name="ln459">			srcp += l;</a>
<a name="ln460">			break;</a>
<a name="ln461"> </a>
<a name="ln462">		case NS_CMPRSFLGS:</a>
<a name="ln463">			if (srcp &gt;= eom) {</a>
<a name="ln464">				errno = EMSGSIZE;</a>
<a name="ln465">				return (-1);</a>
<a name="ln466">			}</a>
<a name="ln467">			if (len &lt; 0) {</a>
<a name="ln468">				assert(INT_MIN &lt;= (srcp - src + 1) &amp;&amp; (srcp - src + 1) &lt;= INT_MAX);</a>
<a name="ln469">				len = (int)(srcp - src + 1);</a>
<a name="ln470">			}</a>
<a name="ln471">			srcp = msg + (((n &amp; 0x3f) &lt;&lt; 8) | (*srcp &amp; 0xff));</a>
<a name="ln472">			if (srcp &lt; msg || srcp &gt;= eom) {  /*%&lt; Out of range. */</a>
<a name="ln473">				errno = EMSGSIZE;</a>
<a name="ln474">				return (-1);</a>
<a name="ln475">			}</a>
<a name="ln476">			checked += 2;</a>
<a name="ln477">			/*</a>
<a name="ln478">			 * Check for loops in the compressed name;</a>
<a name="ln479">			 * if we've looked at the whole message,</a>
<a name="ln480">			 * there must be a loop.</a>
<a name="ln481">			 */</a>
<a name="ln482">			if (checked &gt;= eom - msg) {</a>
<a name="ln483">				errno = EMSGSIZE;</a>
<a name="ln484">				return (-1);</a>
<a name="ln485">			}</a>
<a name="ln486">			break;</a>
<a name="ln487"> </a>
<a name="ln488">		default:</a>
<a name="ln489">			errno = EMSGSIZE;</a>
<a name="ln490">			return (-1);			/*%&lt; flag error */</a>
<a name="ln491">		}</a>
<a name="ln492">	}</a>
<a name="ln493">	*dstp++ = 0;</a>
<a name="ln494">	if (dstlen != NULL)</a>
<a name="ln495">		*dstlen = dstp - dst;</a>
<a name="ln496">	if (len &lt; 0) {</a>
<a name="ln497">		assert(INT_MIN &lt;= (srcp - src) &amp;&amp; (srcp - src) &lt;= INT_MAX);</a>
<a name="ln498">		len = (int)(srcp - src);</a>
<a name="ln499">	}</a>
<a name="ln500">	return len;</a>
<a name="ln501">}</a>
<a name="ln502"> </a>
<a name="ln503">/*%</a>
<a name="ln504"> *	Pack domain name 'domain' into 'comp_dn'.</a>
<a name="ln505"> *</a>
<a name="ln506"> * return:</a>
<a name="ln507"> *\li	Size of the compressed name, or -1.</a>
<a name="ln508"> *</a>
<a name="ln509"> * notes:</a>
<a name="ln510"> *\li	'dnptrs' is an array of pointers to previous compressed names.</a>
<a name="ln511"> *\li	dnptrs[0] is a pointer to the beginning of the message. The array</a>
<a name="ln512"> *	ends with NULL.</a>
<a name="ln513"> *\li	'lastdnptr' is a pointer to the end of the array pointed to</a>
<a name="ln514"> *	by 'dnptrs'.</a>
<a name="ln515"> *</a>
<a name="ln516"> * Side effects:</a>
<a name="ln517"> *\li	The list of pointers in dnptrs is updated for labels inserted into</a>
<a name="ln518"> *	the message as we compress the name.  If 'dnptr' is NULL, we don't</a>
<a name="ln519"> *	try to compress names. If 'lastdnptr' is NULL, we don't update the</a>
<a name="ln520"> *	list.</a>
<a name="ln521"> */</a>
<a name="ln522">int</a>
<a name="ln523">ns_name_pack(const u_char *src, u_char *dst, int dstsiz,</a>
<a name="ln524">	     const u_char **dnptrs, const u_char **lastdnptr)</a>
<a name="ln525">{</a>
<a name="ln526">	u_char *dstp;</a>
<a name="ln527">	const u_char **cpp, **lpp, *eob, *msg;</a>
<a name="ln528">	const u_char *srcp;</a>
<a name="ln529">	int n, l, first = 1;</a>
<a name="ln530"> </a>
<a name="ln531">	srcp = src;</a>
<a name="ln532">	dstp = dst;</a>
<a name="ln533">	eob = dstp + dstsiz;</a>
<a name="ln534">	lpp = cpp = NULL;</a>
<a name="ln535">	if (dnptrs != NULL) {</a>
<a name="ln536">		if ((msg = *dnptrs++) != NULL) {</a>
<a name="ln537">			for (cpp = dnptrs; *cpp != NULL; cpp++)</a>
<a name="ln538">				continue;</a>
<a name="ln539">			lpp = cpp;	/*%&lt; end of list to search */</a>
<a name="ln540">		}</a>
<a name="ln541">	} else</a>
<a name="ln542">		msg = NULL;</a>
<a name="ln543"> </a>
<a name="ln544">	/* make sure the domain we are about to add is legal */</a>
<a name="ln545">	l = 0;</a>
<a name="ln546">	do {</a>
<a name="ln547">		int l0;</a>
<a name="ln548"> </a>
<a name="ln549">		n = *srcp;</a>
<a name="ln550">		if ((n &amp; NS_CMPRSFLGS) == NS_CMPRSFLGS) {</a>
<a name="ln551">			errno = EMSGSIZE;</a>
<a name="ln552">			return (-1);</a>
<a name="ln553">		}</a>
<a name="ln554">		if ((l0 = labellen(srcp)) &lt; 0) {</a>
<a name="ln555">			errno = EINVAL;</a>
<a name="ln556">			return (-1);</a>
<a name="ln557">		}</a>
<a name="ln558">		l += l0 + 1;</a>
<a name="ln559">		if (l &gt; MAXCDNAME) {</a>
<a name="ln560">			errno = EMSGSIZE;</a>
<a name="ln561">			return (-1);</a>
<a name="ln562">		}</a>
<a name="ln563">		srcp += l0 + 1;</a>
<a name="ln564">	} while (n != 0);</a>
<a name="ln565"> </a>
<a name="ln566">	/* from here on we need to reset compression pointer array on error */</a>
<a name="ln567">	srcp = src;</a>
<a name="ln568">	do {</a>
<a name="ln569">		/* Look to see if we can use pointers. */</a>
<a name="ln570">		n = *srcp;</a>
<a name="ln571">		if (n != 0 &amp;&amp; msg != NULL) {</a>
<a name="ln572">			l = dn_find(srcp, msg, (const u_char * const *)dnptrs,</a>
<a name="ln573">				    (const u_char * const *)lpp);</a>
<a name="ln574">			if (l &gt;= 0) {</a>
<a name="ln575">				if (dstp + 1 &gt;= eob) {</a>
<a name="ln576">					goto cleanup;</a>
<a name="ln577">				}</a>
<a name="ln578">				*dstp++ = ((u_int32_t)l &gt;&gt; 8) | NS_CMPRSFLGS;</a>
<a name="ln579">				*dstp++ = l % 256;</a>
<a name="ln580">				assert(INT_MIN &lt;= (dstp - dst) &amp;&amp; (dstp - dst) &lt;= INT_MAX);</a>
<a name="ln581">				return (int)(dstp - dst);</a>
<a name="ln582">			}</a>
<a name="ln583">			/* Not found, save it. */</a>
<a name="ln584">			if (lastdnptr != NULL &amp;&amp; cpp &lt; lastdnptr - 1 &amp;&amp;</a>
<a name="ln585">			    (dstp - msg) &lt; 0x4000 &amp;&amp; first) {</a>
<a name="ln586">				*cpp++ = dstp;</a>
<a name="ln587">				*cpp = NULL;</a>
<a name="ln588">				first = 0;</a>
<a name="ln589">			}</a>
<a name="ln590">		}</a>
<a name="ln591">		/* copy label to buffer */</a>
<a name="ln592">		if ((n &amp; NS_CMPRSFLGS) == NS_CMPRSFLGS) {</a>
<a name="ln593">			/* Should not happen. */</a>
<a name="ln594">			goto cleanup;</a>
<a name="ln595">		}</a>
<a name="ln596">		n = labellen(srcp);</a>
<a name="ln597">		if (dstp + 1 + n &gt;= eob) {</a>
<a name="ln598">			goto cleanup;</a>
<a name="ln599">		}</a>
<a name="ln600">		memcpy(dstp, srcp, (size_t)(n + 1));</a>
<a name="ln601">		srcp += n + 1;</a>
<a name="ln602">		dstp += n + 1;</a>
<a name="ln603">	} while (n != 0);</a>
<a name="ln604"> </a>
<a name="ln605">	if (dstp &gt; eob) {</a>
<a name="ln606">cleanup:</a>
<a name="ln607">		if (msg != NULL)</a>
<a name="ln608">			*lpp = NULL;</a>
<a name="ln609">		errno = EMSGSIZE;</a>
<a name="ln610">		return (-1);</a>
<a name="ln611">	} </a>
<a name="ln612">	assert(INT_MIN &lt;= (dstp - dst) &amp;&amp; (dstp - dst) &lt;= INT_MAX);</a>
<a name="ln613">	return (int)(dstp - dst);</a>
<a name="ln614">}</a>
<a name="ln615"> </a>
<a name="ln616">/*%</a>
<a name="ln617"> *	Expand compressed domain name to presentation format.</a>
<a name="ln618"> *</a>
<a name="ln619"> * return:</a>
<a name="ln620"> *\li	Number of bytes read out of `src', or -1 (with errno set).</a>
<a name="ln621"> *</a>
<a name="ln622"> * note:</a>
<a name="ln623"> *\li	Root domain returns as &quot;.&quot; not &quot;&quot;.</a>
<a name="ln624"> */</a>
<a name="ln625">int</a>
<a name="ln626">ns_name_uncompress(const u_char *msg, const u_char *eom, const u_char *src,</a>
<a name="ln627">		   char *dst, size_t dstsiz)</a>
<a name="ln628">{</a>
<a name="ln629">	u_char tmp[NS_MAXCDNAME];</a>
<a name="ln630">	int n;</a>
<a name="ln631">	</a>
<a name="ln632">	if ((n = ns_name_unpack(msg, eom, src, tmp, sizeof tmp)) == -1)</a>
<a name="ln633">		return (-1);</a>
<a name="ln634">	if (ns_name_ntop(tmp, dst, dstsiz) == -1)</a>
<a name="ln635">		return (-1);</a>
<a name="ln636">	return (n);</a>
<a name="ln637">}</a>
<a name="ln638"> </a>
<a name="ln639">/*%</a>
<a name="ln640"> *	Compress a domain name into wire format, using compression pointers.</a>
<a name="ln641"> *</a>
<a name="ln642"> * return:</a>
<a name="ln643"> *\li	Number of bytes consumed in `dst' or -1 (with errno set).</a>
<a name="ln644"> *</a>
<a name="ln645"> * notes:</a>
<a name="ln646"> *\li	'dnptrs' is an array of pointers to previous compressed names.</a>
<a name="ln647"> *\li	dnptrs[0] is a pointer to the beginning of the message.</a>
<a name="ln648"> *\li	The list ends with NULL.  'lastdnptr' is a pointer to the end of the</a>
<a name="ln649"> *	array pointed to by 'dnptrs'. Side effect is to update the list of</a>
<a name="ln650"> *	pointers for labels inserted into the message as we compress the name.</a>
<a name="ln651"> *\li	If 'dnptr' is NULL, we don't try to compress names. If 'lastdnptr'</a>
<a name="ln652"> *	is NULL, we don't update the list.</a>
<a name="ln653"> */</a>
<a name="ln654">int</a>
<a name="ln655">ns_name_compress(const char *src, u_char *dst, size_t dstsiz,</a>
<a name="ln656">		 const u_char **dnptrs, const u_char **lastdnptr)</a>
<a name="ln657">{</a>
<a name="ln658">	u_char tmp[NS_MAXCDNAME];</a>
<a name="ln659"> </a>
<a name="ln660">	if (ns_name_pton(src, tmp, sizeof tmp) == -1)</a>
<a name="ln661">		return (-1);</a>
<a name="ln662">	return (ns_name_pack(tmp, dst, (int)dstsiz, dnptrs, lastdnptr));</a>
<a name="ln663">}</a>
<a name="ln664"> </a>
<a name="ln665">/*%</a>
<a name="ln666"> * Reset dnptrs so that there are no active references to pointers at or</a>
<a name="ln667"> * after src.</a>
<a name="ln668"> */</a>
<a name="ln669">void</a>
<a name="ln670">ns_name_rollback(const u_char *src, const u_char **dnptrs,</a>
<a name="ln671">		 const u_char **lastdnptr)</a>
<a name="ln672">{</a>
<a name="ln673">	while (dnptrs &lt; lastdnptr &amp;&amp; *dnptrs != NULL) {</a>
<a name="ln674">		if (*dnptrs &gt;= src) {</a>
<a name="ln675">			*dnptrs = NULL;</a>
<a name="ln676">			break;</a>
<a name="ln677">		}</a>
<a name="ln678">		dnptrs++;</a>
<a name="ln679">	}</a>
<a name="ln680">}</a>
<a name="ln681"> </a>
<a name="ln682">/*%</a>
<a name="ln683"> *	Advance *ptrptr to skip over the compressed name it points at.</a>
<a name="ln684"> *</a>
<a name="ln685"> * return:</a>
<a name="ln686"> *\li	0 on success, -1 (with errno set) on failure.</a>
<a name="ln687"> */</a>
<a name="ln688">int</a>
<a name="ln689">ns_name_skip(const u_char **ptrptr, const u_char *eom)</a>
<a name="ln690">{</a>
<a name="ln691">	const u_char *cp;</a>
<a name="ln692">	u_int n;</a>
<a name="ln693">	int l;</a>
<a name="ln694"> </a>
<a name="ln695">	cp = *ptrptr;</a>
<a name="ln696">	while (cp &lt; eom &amp;&amp; (n = *cp++) != 0) {</a>
<a name="ln697">		/* Check for indirection. */</a>
<a name="ln698">		switch (n &amp; NS_CMPRSFLGS) {</a>
<a name="ln699">		case 0:			/*%&lt; normal case, n == len */</a>
<a name="ln700">			cp += n;</a>
<a name="ln701">			continue;</a>
<a name="ln702">		case NS_TYPE_ELT: /*%&lt; EDNS0 extended label */</a>
<a name="ln703">			if ((l = labellen(cp - 1)) &lt; 0) {</a>
<a name="ln704">				errno = EMSGSIZE; /*%&lt; XXX */</a>
<a name="ln705">				return (-1);</a>
<a name="ln706">			}</a>
<a name="ln707">			cp += l;</a>
<a name="ln708">			continue;</a>
<a name="ln709">		case NS_CMPRSFLGS:	/*%&lt; indirection */</a>
<a name="ln710">			cp++;</a>
<a name="ln711">			break;</a>
<a name="ln712">		default:		/*%&lt; illegal type */</a>
<a name="ln713">			errno = EMSGSIZE;</a>
<a name="ln714">			return (-1);</a>
<a name="ln715">		}</a>
<a name="ln716">		break;</a>
<a name="ln717">	}</a>
<a name="ln718">	if (cp &gt; eom) {</a>
<a name="ln719">		errno = EMSGSIZE;</a>
<a name="ln720">		return (-1);</a>
<a name="ln721">	}</a>
<a name="ln722">	*ptrptr = cp;</a>
<a name="ln723">	return (0);</a>
<a name="ln724">}</a>
<a name="ln725"> </a>
<a name="ln726">/* Find the number of octets an nname takes up, including the root label.</a>
<a name="ln727"> * (This is basically ns_name_skip() without compression-pointer support.)</a>
<a name="ln728"> * ((NOTE: can only return zero if passed-in namesiz argument is zero.))</a>
<a name="ln729"> */</a>
<a name="ln730">ssize_t</a>
<a name="ln731">ns_name_length(ns_nname_ct nname, size_t namesiz) {</a>
<a name="ln732">	ns_nname_ct orig = nname;</a>
<a name="ln733">	u_int n;</a>
<a name="ln734"> </a>
<a name="ln735">	while (namesiz-- &gt; 0 &amp;&amp; (n = *nname++) != 0) {</a>
<a name="ln736">		if ((n &amp; NS_CMPRSFLGS) != 0) {</a>
<a name="ln737">			errno = EISDIR;</a>
<a name="ln738">			return (-1);</a>
<a name="ln739">		}</a>
<a name="ln740">		if (n &gt; namesiz) {</a>
<a name="ln741">			errno = EMSGSIZE;</a>
<a name="ln742">			return (-1);</a>
<a name="ln743">		}</a>
<a name="ln744">		nname += n;</a>
<a name="ln745">		namesiz -= n;</a>
<a name="ln746">	}</a>
<a name="ln747">	return (nname - orig);</a>
<a name="ln748">}</a>
<a name="ln749"> </a>
<a name="ln750">/* Compare two nname's for equality.  Return -1 on error (setting errno).</a>
<a name="ln751"> */</a>
<a name="ln752">int</a>
<a name="ln753">ns_name_eq(ns_nname_ct a, size_t as, ns_nname_ct b, size_t bs) {</a>
<a name="ln754">	ns_nname_ct ae = a + as, be = b + bs;</a>
<a name="ln755">	int ac, bc;</a>
<a name="ln756"> </a>
<a name="ln757">	while (ac = *a, bc = *b, ac != 0 &amp;&amp; bc != 0) {</a>
<a name="ln758">		if ((ac &amp; NS_CMPRSFLGS) != 0 || (bc &amp; NS_CMPRSFLGS) != 0) {</a>
<a name="ln759">			errno = EISDIR;</a>
<a name="ln760">			return (-1);</a>
<a name="ln761">		}</a>
<a name="ln762">		if (a + ac &gt;= ae || b + bc &gt;= be) {</a>
<a name="ln763">			errno = EMSGSIZE;</a>
<a name="ln764">			return (-1);</a>
<a name="ln765">		}</a>
<a name="ln766">		if (ac != bc || strncasecmp((const char *) ++a,</a>
<a name="ln767">					    (const char *) ++b,</a>
<a name="ln768">					    (size_t)ac) != 0)</a>
<a name="ln769">			return (0);</a>
<a name="ln770">		a += ac, b += bc;</a>
<a name="ln771">	}</a>
<a name="ln772">	return (ac == 0 &amp;&amp; bc == 0);</a>
<a name="ln773">}</a>
<a name="ln774"> </a>
<a name="ln775">/* Is domain &quot;A&quot; owned by (at or below) domain &quot;B&quot;?</a>
<a name="ln776"> */</a>
<a name="ln777">int</a>
<a name="ln778">ns_name_owned(ns_namemap_ct a, int an, ns_namemap_ct b, int bn) {</a>
<a name="ln779">	/* If A is shorter, it cannot be owned by B. */</a>
<a name="ln780">	if (an &lt; bn)</a>
<a name="ln781">		return (0);</a>
<a name="ln782"> </a>
<a name="ln783">	/* If they are unequal before the length of the shorter, A cannot... */</a>
<a name="ln784">	while (bn &gt; 0) {</a>
<a name="ln785">		if (a-&gt;len != b-&gt;len ||</a>
<a name="ln786">		    strncasecmp((const char *) a-&gt;base,</a>
<a name="ln787">				(const char *) b-&gt;base, (size_t)a-&gt;len) != 0)</a>
<a name="ln788">			return (0);</a>
<a name="ln789">		a++, an--;</a>
<a name="ln790">		b++, bn--;</a>
<a name="ln791">	}</a>
<a name="ln792"> </a>
<a name="ln793">	/* A might be longer or not, but either way, B owns it. */</a>
<a name="ln794">	return (1);</a>
<a name="ln795">}</a>
<a name="ln796"> </a>
<a name="ln797">/* Build an array of &lt;base,len&gt; tuples from an nname, top-down order.</a>
<a name="ln798"> * Return the number of tuples (labels) thus discovered.</a>
<a name="ln799"> */</a>
<a name="ln800">int</a>
<a name="ln801">ns_name_map(ns_nname_ct nname, size_t namelen, ns_namemap_t map, int mapsize) {</a>
<a name="ln802">	u_int n;</a>
<a name="ln803">	int l;</a>
<a name="ln804"> </a>
<a name="ln805">	n = *nname++;</a>
<a name="ln806">	namelen--;</a>
<a name="ln807"> </a>
<a name="ln808">	/* Root zone? */</a>
<a name="ln809">	if (n == 0) {</a>
<a name="ln810">		/* Extra data follows name? */</a>
<a name="ln811">		if (namelen &gt; 0) {</a>
<a name="ln812">			errno = EMSGSIZE;</a>
<a name="ln813">			return (-1);</a>
<a name="ln814">		}</a>
<a name="ln815">		return (0);</a>
<a name="ln816">	}</a>
<a name="ln817"> </a>
<a name="ln818">	/* Compression pointer? */</a>
<a name="ln819">	if ((n &amp; NS_CMPRSFLGS) != 0) {</a>
<a name="ln820">		errno = EISDIR;</a>
<a name="ln821">		return (-1);</a>
<a name="ln822">	}</a>
<a name="ln823"> </a>
<a name="ln824">	/* Label too long? */</a>
<a name="ln825">	if (n &gt; namelen) {</a>
<a name="ln826">		errno = EMSGSIZE;</a>
<a name="ln827">		return (-1);</a>
<a name="ln828">	}</a>
<a name="ln829"> </a>
<a name="ln830">	/* Recurse to get rest of name done first. */</a>
<a name="ln831">	l = ns_name_map(nname + n, namelen - n, map, mapsize);</a>
<a name="ln832">	if (l &lt; 0)</a>
<a name="ln833">		return (-1);</a>
<a name="ln834"> </a>
<a name="ln835">	/* Too many labels? */</a>
<a name="ln836">	if (l &gt;= mapsize) {</a>
<a name="ln837">		errno = ENAMETOOLONG;</a>
<a name="ln838">		return (-1);</a>
<a name="ln839">	}</a>
<a name="ln840"> </a>
<a name="ln841">	/* We're on our way back up-stack, store current map data. */</a>
<a name="ln842">	map[l].base = nname;</a>
<a name="ln843">	map[l].len = n;</a>
<a name="ln844">	return (l + 1);</a>
<a name="ln845">}</a>
<a name="ln846"> </a>
<a name="ln847">/* Count the labels in a domain name.  Root counts, so COM. has two.  This</a>
<a name="ln848"> * is to make the result comparable to the result of ns_name_map().</a>
<a name="ln849"> */</a>
<a name="ln850">int</a>
<a name="ln851">ns_name_labels(ns_nname_ct nname, size_t namesiz) {</a>
<a name="ln852">	int ret = 0;</a>
<a name="ln853">	u_int n;</a>
<a name="ln854"> </a>
<a name="ln855">	while (namesiz-- &gt; 0 &amp;&amp; (n = *nname++) != 0) {</a>
<a name="ln856">		if ((n &amp; NS_CMPRSFLGS) != 0) {</a>
<a name="ln857">			errno = EISDIR;</a>
<a name="ln858">			return (-1);</a>
<a name="ln859">		}</a>
<a name="ln860">		if (n &gt; namesiz) {</a>
<a name="ln861">			errno = EMSGSIZE;</a>
<a name="ln862">			return (-1);</a>
<a name="ln863">		}</a>
<a name="ln864">		nname += n;</a>
<a name="ln865">		namesiz -= n;</a>
<a name="ln866">		ret++;</a>
<a name="ln867">	}</a>
<a name="ln868">	return (ret + 1);</a>
<a name="ln869">}</a>
<a name="ln870"> </a>
<a name="ln871">/* Private. */</a>
<a name="ln872"> </a>
<a name="ln873">/*%</a>
<a name="ln874"> *	Thinking in noninternationalized USASCII (per the DNS spec),</a>
<a name="ln875"> *	is this characted special (&quot;in need of quoting&quot;) ?</a>
<a name="ln876"> *</a>
<a name="ln877"> * return:</a>
<a name="ln878"> *\li	boolean.</a>
<a name="ln879"> */</a>
<a name="ln880">static int</a>
<a name="ln881">special(int ch) {</a>
<a name="ln882">	switch (ch) {</a>
<a name="ln883">	case 0x22: /*%&lt; '&quot;' */</a>
<a name="ln884">	case 0x2E: /*%&lt; '.' */</a>
<a name="ln885">	case 0x3B: /*%&lt; ';' */</a>
<a name="ln886">	case 0x5C: /*%&lt; '\\' */</a>
<a name="ln887">	case 0x28: /*%&lt; '(' */</a>
<a name="ln888">	case 0x29: /*%&lt; ')' */</a>
<a name="ln889">	/* Special modifiers in zone files. */</a>
<a name="ln890">	case 0x40: /*%&lt; '@' */</a>
<a name="ln891">	case 0x24: /*%&lt; '$' */</a>
<a name="ln892">		return (1);</a>
<a name="ln893">	default:</a>
<a name="ln894">		return (0);</a>
<a name="ln895">	}</a>
<a name="ln896">}</a>
<a name="ln897"> </a>
<a name="ln898">/*%</a>
<a name="ln899"> *	Thinking in noninternationalized USASCII (per the DNS spec),</a>
<a name="ln900"> *	is this character visible and not a space when printed ?</a>
<a name="ln901"> *</a>
<a name="ln902"> * return:</a>
<a name="ln903"> *\li	boolean.</a>
<a name="ln904"> */</a>
<a name="ln905">static int</a>
<a name="ln906">printable(int ch) {</a>
<a name="ln907">	return (ch &gt; 0x20 &amp;&amp; ch &lt; 0x7f);</a>
<a name="ln908">}</a>
<a name="ln909"> </a>
<a name="ln910">/*%</a>
<a name="ln911"> *	Thinking in noninternationalized USASCII (per the DNS spec),</a>
<a name="ln912"> *	convert this character to lower case if it's upper case.</a>
<a name="ln913"> */</a>
<a name="ln914">static int</a>
<a name="ln915">mklower(int ch) {</a>
<a name="ln916">	if (ch &gt;= 0x41 &amp;&amp; ch &lt;= 0x5A)</a>
<a name="ln917">		return (ch + 0x20);</a>
<a name="ln918">	return (ch);</a>
<a name="ln919">}</a>
<a name="ln920"> </a>
<a name="ln921">/*%</a>
<a name="ln922"> *	Search for the counted-label name in an array of compressed names.</a>
<a name="ln923"> *</a>
<a name="ln924"> * return:</a>
<a name="ln925"> *\li	offset from msg if found, or -1.</a>
<a name="ln926"> *</a>
<a name="ln927"> * notes:</a>
<a name="ln928"> *\li	dnptrs is the pointer to the first name on the list,</a>
<a name="ln929"> *\li	not the pointer to the start of the message.</a>
<a name="ln930"> */</a>
<a name="ln931">static int</a>
<a name="ln932">dn_find(const u_char *domain, const u_char *msg,</a>
<a name="ln933">	const u_char * const *dnptrs,</a>
<a name="ln934">	const u_char * const *lastdnptr)</a>
<a name="ln935">{</a>
<a name="ln936">	const u_char *dn, *cp, *sp;</a>
<a name="ln937">	const u_char * const *cpp;</a>
<a name="ln938">	u_int n;</a>
<a name="ln939"> </a>
<a name="ln940">	for (cpp = dnptrs; cpp &lt; lastdnptr; cpp++) {</a>
<a name="ln941">		sp = *cpp;</a>
<a name="ln942">		/*</a>
<a name="ln943">		 * terminate search on:</a>
<a name="ln944">		 * root label</a>
<a name="ln945">		 * compression pointer</a>
<a name="ln946">		 * unusable offset</a>
<a name="ln947">		 */</a>
<a name="ln948">		while (*sp != 0 &amp;&amp; (*sp &amp; NS_CMPRSFLGS) == 0 &amp;&amp;</a>
<a name="ln949">		       (sp - msg) &lt; 0x4000) {</a>
<a name="ln950">			dn = domain;</a>
<a name="ln951">			cp = sp;</a>
<a name="ln952">			while ((n = *cp++) != 0) {</a>
<a name="ln953">				/*</a>
<a name="ln954">				 * check for indirection</a>
<a name="ln955">				 */</a>
<a name="ln956">				switch (n &amp; NS_CMPRSFLGS) {</a>
<a name="ln957">				case 0:		/*%&lt; normal case, n == len */</a>
<a name="ln958">					n = labellen(cp - 1); /*%&lt; XXX */</a>
<a name="ln959">					if (n != *dn++)</a>
<a name="ln960">						goto next;</a>
<a name="ln961"> </a>
<a name="ln962">					for (; n &gt; 0; n--)</a>
<a name="ln963">						if (mklower(*dn++) !=</a>
<a name="ln964">						    mklower(*cp++))</a>
<a name="ln965">							goto next;</a>
<a name="ln966">					/* Is next root for both ? */</a>
<a name="ln967">					if (*dn == '\0' &amp;&amp; *cp == '\0') {</a>
<a name="ln968">						assert(INT_MIN &lt;= (sp - msg) &amp;&amp; (sp - msg) &lt;= INT_MAX);</a>
<a name="ln969">						return (int)(sp - msg);</a>
<a name="ln970">					}</a>
<a name="ln971">					if (*dn)</a>
<a name="ln972">						continue;</a>
<a name="ln973">					goto next;</a>
<a name="ln974">				case NS_CMPRSFLGS:	/*%&lt; indirection */</a>
<a name="ln975">					cp = msg + (((n &amp; 0x3f) &lt;&lt; 8) | *cp);</a>
<a name="ln976">					break;</a>
<a name="ln977"> </a>
<a name="ln978">				default:	/*%&lt; illegal type */</a>
<a name="ln979">					errno = EMSGSIZE;</a>
<a name="ln980">					return (-1);</a>
<a name="ln981">				}</a>
<a name="ln982">			}</a>
<a name="ln983"> next: ;</a>
<a name="ln984">			sp += *sp + 1;</a>
<a name="ln985">		}</a>
<a name="ln986">	}</a>
<a name="ln987">	errno = ENOENT;</a>
<a name="ln988">	return (-1);</a>
<a name="ln989">}</a>
<a name="ln990"> </a>
<a name="ln991">static int</a>
<a name="ln992">decode_bitstring(const unsigned char **cpp, char *dn, const char *eom)</a>
<a name="ln993">{</a>
<a name="ln994">	const unsigned char *cp = *cpp;</a>
<a name="ln995">	char *beg = dn, tc;</a>
<a name="ln996">	int b, blen, plen, i;</a>
<a name="ln997"> </a>
<a name="ln998">	if ((blen = (*cp &amp; 0xff)) == 0)</a>
<a name="ln999">		blen = 256;</a>
<a name="ln1000">	plen = (blen + 3) / 4;</a>
<a name="ln1001">	plen += (int)sizeof(&quot;\\[x/]&quot;) + (blen &gt; 99 ? 3 : (blen &gt; 9) ? 2 : 1);</a>
<a name="ln1002">	if (dn + plen &gt;= eom)</a>
<a name="ln1003">		return (-1);</a>
<a name="ln1004"> </a>
<a name="ln1005">	cp++;</a>
<a name="ln1006">	i = SPRINTF((dn, &quot;\\[x&quot;));</a>
<a name="ln1007">	if (i &lt; 0)</a>
<a name="ln1008">		return (-1);</a>
<a name="ln1009">	dn += i;</a>
<a name="ln1010">	for (b = blen; b &gt; 7; b -= 8, cp++) {</a>
<a name="ln1011">		i = SPRINTF((dn, &quot;%02x&quot;, *cp &amp; 0xff));</a>
<a name="ln1012">		if (i &lt; 0)</a>
<a name="ln1013">			return (-1);</a>
<a name="ln1014">		dn += i;</a>
<a name="ln1015">	}</a>
<a name="ln1016">	if (b &gt; 4) {</a>
<a name="ln1017">		tc = *cp++;</a>
<a name="ln1018">		i = SPRINTF((dn, &quot;%02x&quot;, tc &amp; (0xff &lt;&lt; (8 - b))));</a>
<a name="ln1019">		if (i &lt; 0)</a>
<a name="ln1020">			return (-1);</a>
<a name="ln1021">		dn += i;</a>
<a name="ln1022">	} else if (b &gt; 0) {</a>
<a name="ln1023">		tc = *cp++;</a>
<a name="ln1024">		i = SPRINTF((dn, &quot;%1x&quot;,</a>
<a name="ln1025">			       (((u_int32_t)tc &gt;&gt; 4) &amp; 0x0f) &amp; (0x0f &lt;&lt; (4 - b)))); </a>
<a name="ln1026">		if (i &lt; 0)</a>
<a name="ln1027">			return (-1);</a>
<a name="ln1028">		dn += i;</a>
<a name="ln1029">	}</a>
<a name="ln1030">	i = SPRINTF((dn, &quot;/%d]&quot;, blen));</a>
<a name="ln1031">	if (i &lt; 0)</a>
<a name="ln1032">		return (-1);</a>
<a name="ln1033">	dn += i;</a>
<a name="ln1034"> </a>
<a name="ln1035">	*cpp = cp;</a>
<a name="ln1036">	assert(INT_MIN &lt;= (dn - beg) &amp;&amp; (dn - beg) &lt;= INT_MAX);</a>
<a name="ln1037">	return (int)(dn - beg);</a>
<a name="ln1038">}</a>
<a name="ln1039"> </a>
<a name="ln1040">static int</a>
<a name="ln1041">encode_bitsring(const char **bp, const char *end, unsigned char **labelp,</a>
<a name="ln1042">		unsigned char ** dst, unsigned const char *eom)</a>
<a name="ln1043">{</a>
<a name="ln1044">	int afterslash = 0;</a>
<a name="ln1045">	const char *cp = *bp;</a>
<a name="ln1046">	unsigned char *tp;</a>
<a name="ln1047">	char c;</a>
<a name="ln1048">	const char *beg_blen;</a>
<a name="ln1049">	char *end_blen = NULL;</a>
<a name="ln1050">	int value = 0, count = 0, tbcount = 0, blen = 0;</a>
<a name="ln1051"> </a>
<a name="ln1052">	beg_blen = end_blen = NULL;</a>
<a name="ln1053"> </a>
<a name="ln1054">	/* a bitstring must contain at least 2 characters */</a>
<a name="ln1055">	if (end - cp &lt; 2)</a>
<a name="ln1056">		return (EINVAL);</a>
<a name="ln1057"> </a>
<a name="ln1058">	/* XXX: currently, only hex strings are supported */</a>
<a name="ln1059">	if (*cp++ != 'x')</a>
<a name="ln1060">		return (EINVAL);</a>
<a name="ln1061">	if (!isxdigit((*cp) &amp; 0xff)) /*%&lt; reject '\[x/BLEN]' */</a>
<a name="ln1062">		return (EINVAL);</a>
<a name="ln1063"> </a>
<a name="ln1064">	for (tp = *dst + 1; cp &lt; end &amp;&amp; tp &lt; eom; cp++) {</a>
<a name="ln1065">		switch((c = *cp)) {</a>
<a name="ln1066">		case ']':	/*%&lt; end of the bitstring */</a>
<a name="ln1067">			if (afterslash) {</a>
<a name="ln1068">				if (beg_blen == NULL)</a>
<a name="ln1069">					return (EINVAL);</a>
<a name="ln1070">				blen = (int)strtol(beg_blen, &amp;end_blen, 10);</a>
<a name="ln1071">				if (*end_blen != ']')</a>
<a name="ln1072">					return (EINVAL);</a>
<a name="ln1073">			}</a>
<a name="ln1074">			if (count)</a>
<a name="ln1075">				*tp++ = ((value &lt;&lt; 4) &amp; 0xff);</a>
<a name="ln1076">			cp++;	/*%&lt; skip ']' */</a>
<a name="ln1077">			goto done;</a>
<a name="ln1078">		case '/':</a>
<a name="ln1079">			afterslash = 1;</a>
<a name="ln1080">			break;</a>
<a name="ln1081">		default:</a>
<a name="ln1082">			if (afterslash) {</a>
<a name="ln1083">				if (!isdigit(c&amp;0xff))</a>
<a name="ln1084">					return (EINVAL);</a>
<a name="ln1085">				if (beg_blen == NULL) {</a>
<a name="ln1086">					</a>
<a name="ln1087">					if (c == '0') {</a>
<a name="ln1088">						/* blen never begings with 0 */</a>
<a name="ln1089">						return (EINVAL);</a>
<a name="ln1090">					}</a>
<a name="ln1091">					beg_blen = cp;</a>
<a name="ln1092">				}</a>
<a name="ln1093">			} else {</a>
<a name="ln1094">				if (!isxdigit(c&amp;0xff))</a>
<a name="ln1095">					return (EINVAL);</a>
<a name="ln1096">				value &lt;&lt;= 4;</a>
<a name="ln1097">				value += digitvalue[(int)c];</a>
<a name="ln1098">				count += 4;</a>
<a name="ln1099">				tbcount += 4;</a>
<a name="ln1100">				if (tbcount &gt; 256)</a>
<a name="ln1101">					return (EINVAL);</a>
<a name="ln1102">				if (count == 8) {</a>
<a name="ln1103">					*tp++ = value;</a>
<a name="ln1104">					count = 0;</a>
<a name="ln1105">				}</a>
<a name="ln1106">			}</a>
<a name="ln1107">			break;</a>
<a name="ln1108">		}</a>
<a name="ln1109">	}</a>
<a name="ln1110">  done:</a>
<a name="ln1111">	if (cp &gt;= end || tp &gt;= eom)</a>
<a name="ln1112">		return (EMSGSIZE);</a>
<a name="ln1113"> </a>
<a name="ln1114">	/*</a>
<a name="ln1115">	 * bit length validation:</a>
<a name="ln1116">	 * If a &lt;length&gt; is present, the number of digits in the &lt;bit-data&gt;</a>
<a name="ln1117">	 * MUST be just sufficient to contain the number of bits specified</a>
<a name="ln1118">	 * by the &lt;length&gt;. If there are insignificant bits in a final</a>
<a name="ln1119">	 * hexadecimal or octal digit, they MUST be zero.</a>
<a name="ln1120">	 * RFC2673, Section 3.2.</a>
<a name="ln1121">	 */</a>
<a name="ln1122">	if (blen &gt; 0) {</a>
<a name="ln1123">		int traillen;</a>
<a name="ln1124"> </a>
<a name="ln1125">		if (((blen + 3) &amp; ~3) != tbcount)</a>
<a name="ln1126">			return (EINVAL);</a>
<a name="ln1127">		traillen = tbcount - blen; /*%&lt; between 0 and 3 */</a>
<a name="ln1128">		if (((value &lt;&lt; (8 - traillen)) &amp; 0xff) != 0)</a>
<a name="ln1129">			return (EINVAL);</a>
<a name="ln1130">	}</a>
<a name="ln1131">	else</a>
<a name="ln1132">		blen = tbcount;</a>
<a name="ln1133">	if (blen == 256)</a>
<a name="ln1134">		blen = 0;</a>
<a name="ln1135"> </a>
<a name="ln1136">	/* encode the type and the significant bit fields */</a>
<a name="ln1137">	**labelp = DNS_LABELTYPE_BITSTRING;</a>
<a name="ln1138">	**dst = blen;</a>
<a name="ln1139"> </a>
<a name="ln1140">	*bp = cp;</a>
<a name="ln1141">	*dst = tp;</a>
<a name="ln1142"> </a>
<a name="ln1143">	return (0);</a>
<a name="ln1144">}</a>
<a name="ln1145"> </a>
<a name="ln1146">static int</a>
<a name="ln1147">labellen(const u_char *lp)</a>
<a name="ln1148">{</a>
<a name="ln1149">	int bitlen;</a>
<a name="ln1150">	u_char l = *lp;</a>
<a name="ln1151"> </a>
<a name="ln1152">	if ((l &amp; NS_CMPRSFLGS) == NS_CMPRSFLGS) {</a>
<a name="ln1153">		/* should be avoided by the caller */</a>
<a name="ln1154">		return (-1);</a>
<a name="ln1155">	}</a>
<a name="ln1156"> </a>
<a name="ln1157">	if ((l &amp; NS_CMPRSFLGS) == NS_TYPE_ELT) {</a>
<a name="ln1158">		if (l == DNS_LABELTYPE_BITSTRING) {</a>
<a name="ln1159">			if ((bitlen = *(lp + 1)) == 0)</a>
<a name="ln1160">				bitlen = 256;</a>
<a name="ln1161">			return ((bitlen + 7 ) / 8 + 1);</a>
<a name="ln1162">		}</a>
<a name="ln1163">		return (-1);	/*%&lt; unknwon ELT */</a>
<a name="ln1164">	}</a>
<a name="ln1165">	return (l);</a>
<a name="ln1166">}</a>
<a name="ln1167"> </a>
<a name="ln1168">/*! \file */</a>

</code></pre>
<div class="balloon" rel="600"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'n + 1' operator to the 'size_t' type, not the result.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
