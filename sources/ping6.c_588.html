
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ping6.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.</a>
<a name="ln3"> * All rights reserved.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln6"> * modification, are permitted provided that the following conditions</a>
<a name="ln7"> * are met:</a>
<a name="ln8"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln9"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln10"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln11"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln12"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln13"> * 3. Neither the name of the project nor the names of its contributors</a>
<a name="ln14"> *    may be used to endorse or promote products derived from this software</a>
<a name="ln15"> *    without specific prior written permission.</a>
<a name="ln16"> *</a>
<a name="ln17"> * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln18"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln19"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln20"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE</a>
<a name="ln21"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln22"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln23"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln24"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln25"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln26"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln27"> * SUCH DAMAGE.</a>
<a name="ln28"> */</a>
<a name="ln29"> </a>
<a name="ln30">/*</a>
<a name="ln31"> * Copyright (c) 1989, 1993</a>
<a name="ln32"> *	The Regents of the University of California.  All rights reserved.</a>
<a name="ln33"> *</a>
<a name="ln34"> * This code is derived from software contributed to Berkeley by</a>
<a name="ln35"> * Mike Muuss.</a>
<a name="ln36"> *</a>
<a name="ln37"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln38"> * modification, are permitted provided that the following conditions</a>
<a name="ln39"> * are met:</a>
<a name="ln40"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln41"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln42"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln43"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln44"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln45"> * 3. All advertising materials mentioning features or use of this software</a>
<a name="ln46"> *    must display the following acknowledgement:</a>
<a name="ln47"> *	This product includes software developed by the University of</a>
<a name="ln48"> *	California, Berkeley and its contributors.</a>
<a name="ln49"> * 4. Neither the name of the University nor the names of its contributors</a>
<a name="ln50"> *    may be used to endorse or promote products derived from this software</a>
<a name="ln51"> *    without specific prior written permission.</a>
<a name="ln52"> *</a>
<a name="ln53"> * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln54"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln55"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln56"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE</a>
<a name="ln57"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln58"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln59"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln60"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln61"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln62"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln63"> * SUCH DAMAGE.</a>
<a name="ln64"> */</a>
<a name="ln65"> </a>
<a name="ln66">/*</a>
<a name="ln67"> * Using the InterNet Control Message Protocol (ICMP) &quot;ECHO&quot; facility,</a>
<a name="ln68"> * measure round-trip-delays and packet loss across network paths.</a>
<a name="ln69"> *</a>
<a name="ln70"> * Author -</a>
<a name="ln71"> *	Mike Muuss</a>
<a name="ln72"> *	U. S. Army Ballistic Research Laboratory</a>
<a name="ln73"> *	December, 1983</a>
<a name="ln74"> *</a>
<a name="ln75"> * Status -</a>
<a name="ln76"> *	Public Domain.  Distribution Unlimited.</a>
<a name="ln77"> * Bugs -</a>
<a name="ln78"> *	More statistics could always be gathered.</a>
<a name="ln79"> *	This program has to run SUID to ROOT to access the ICMP socket.</a>
<a name="ln80"> */</a>
<a name="ln81"> </a>
<a name="ln82">/*</a>
<a name="ln83"> * NOTE:</a>
<a name="ln84"> * USE_SIN6_SCOPE_ID assumes that sin6_scope_id has the same semantics</a>
<a name="ln85"> * as IPV6_PKTINFO.  Some people object it (sin6_scope_id specifies *link*</a>
<a name="ln86"> * while IPV6_PKTINFO specifies *interface*.  Link is defined as collection of</a>
<a name="ln87"> * network attached to 1 or more interfaces)</a>
<a name="ln88"> */</a>
<a name="ln89">#define USE_SIN6_SCOPE_ID 1</a>
<a name="ln90"> </a>
<a name="ln91">#define USE_RFC2292BIS 1</a>
<a name="ln92">#define HAVE_POLL_H 1</a>
<a name="ln93">#define CMSG_SENDING_UNSUPPORTED 1</a>
<a name="ln94">#undef IPSEC</a>
<a name="ln95">#undef IPV6_OPTIONS</a>
<a name="ln96"> </a>
<a name="ln97">#include &lt;sys/param.h&gt;</a>
<a name="ln98">#include &lt;sys/uio.h&gt;</a>
<a name="ln99">#include &lt;sys/socket.h&gt;</a>
<a name="ln100">#include &lt;sys/time.h&gt;</a>
<a name="ln101"> </a>
<a name="ln102">#include &lt;net/if.h&gt;</a>
<a name="ln103">#include &lt;net/route.h&gt;</a>
<a name="ln104"> </a>
<a name="ln105">#include &lt;netinet/in.h&gt;</a>
<a name="ln106">#include &lt;netinet/ip6.h&gt;</a>
<a name="ln107">#include &lt;netinet/icmp6.h&gt;</a>
<a name="ln108">#include &lt;arpa/inet.h&gt;</a>
<a name="ln109">#include &lt;arpa/nameser.h&gt;</a>
<a name="ln110">#include &lt;netdb.h&gt;</a>
<a name="ln111"> </a>
<a name="ln112">#include &lt;ctype.h&gt;</a>
<a name="ln113">#include &lt;err.h&gt;</a>
<a name="ln114">#include &lt;errno.h&gt;</a>
<a name="ln115">#include &lt;fcntl.h&gt;</a>
<a name="ln116">#include &lt;math.h&gt;</a>
<a name="ln117">#include &lt;signal.h&gt;</a>
<a name="ln118">#include &lt;stdio.h&gt;</a>
<a name="ln119">#include &lt;stdlib.h&gt;</a>
<a name="ln120">#include &lt;string.h&gt;</a>
<a name="ln121">#include &lt;unistd.h&gt;</a>
<a name="ln122">#ifdef HAVE_POLL_H</a>
<a name="ln123">#include &lt;poll.h&gt;</a>
<a name="ln124">#endif</a>
<a name="ln125"> </a>
<a name="ln126">#ifdef IPSEC</a>
<a name="ln127">#include &lt;netipsec/ah.h&gt;</a>
<a name="ln128">#include &lt;netipsec/ipsec.h&gt;</a>
<a name="ln129">#endif</a>
<a name="ln130"> </a>
<a name="ln131">struct tv32 {</a>
<a name="ln132">	u_int32_t tv32_sec;</a>
<a name="ln133">	u_int32_t tv32_usec;</a>
<a name="ln134">};</a>
<a name="ln135"> </a>
<a name="ln136">#define	IP6LEN			40</a>
<a name="ln137">#define MAXPACKETLEN	(IPV6_MAXPACKET - IP6LEN) </a>
<a name="ln138">#define ICMP6ECHOLEN	8	/* icmp echo header len excluding time */</a>
<a name="ln139">#define ICMP6ECHOTMLEN	sizeof(struct tv32)</a>
<a name="ln140">#define ICMP6_NIQLEN	(ICMP6ECHOLEN + 8)</a>
<a name="ln141"># define CONTROLLEN		10240	/* ancillary data buffer size RFC3542 20.1 */</a>
<a name="ln142">/* FQDN case, 64 bits of nonce + 32 bits ttl */</a>
<a name="ln143">#define ICMP6_NIRLEN	(ICMP6ECHOLEN + 12)</a>
<a name="ln144">#define	EXTRA		256	/* for AH and various other headers. weird. */</a>
<a name="ln145">#define	DEFDATALEN	ICMP6ECHOTMLEN</a>
<a name="ln146">#define MAXDATALEN	MAXPACKETLEN - IP6LEN - ICMP6ECHOLEN</a>
<a name="ln147">#define	NROUTES		9		/* number of record route slots */</a>
<a name="ln148"> </a>
<a name="ln149">#define	A(bit)		rcvd_tbl[(bit)&gt;&gt;3]	/* identify byte in array */</a>
<a name="ln150">#define	B(bit)		(1 &lt;&lt; ((bit) &amp; 0x07))	/* identify bit in byte */</a>
<a name="ln151">#define	SET(bit)	(A(bit) |= B(bit))</a>
<a name="ln152">#define	CLR(bit)	(A(bit) &amp;= (~B(bit)))</a>
<a name="ln153">#define	TST(bit)	(A(bit) &amp; B(bit))</a>
<a name="ln154"> </a>
<a name="ln155">#define	F_FLOOD		0x0001</a>
<a name="ln156">#define	F_INTERVAL	0x0002</a>
<a name="ln157">#define	F_PINGFILLED	0x0008</a>
<a name="ln158">#define	F_QUIET		0x0010</a>
<a name="ln159">#define	F_RROUTE	0x0020</a>
<a name="ln160">#define	F_SO_DEBUG	0x0040</a>
<a name="ln161">#define	F_VERBOSE	0x0100</a>
<a name="ln162">#ifdef IPSEC</a>
<a name="ln163">#ifdef IPSEC_POLICY_IPSEC</a>
<a name="ln164">#define	F_POLICY	0x0400</a>
<a name="ln165">#else</a>
<a name="ln166">#define F_AUTHHDR	0x0200</a>
<a name="ln167">#define F_ENCRYPT	0x0400</a>
<a name="ln168">#endif /*IPSEC_POLICY_IPSEC*/</a>
<a name="ln169">#endif /*IPSEC*/</a>
<a name="ln170">#define F_NODEADDR	0x0800</a>
<a name="ln171">#define F_FQDN		0x1000</a>
<a name="ln172">#define F_INTERFACE	0x2000</a>
<a name="ln173">#define F_SRCADDR	0x4000</a>
<a name="ln174">#define F_HOSTNAME	0x10000</a>
<a name="ln175">#define F_FQDNOLD	0x20000</a>
<a name="ln176">#define F_NIGROUP	0x40000</a>
<a name="ln177">#define F_SUPTYPES	0x80000</a>
<a name="ln178">#define F_NOMINMTU	0x100000</a>
<a name="ln179">#define F_ONCE		0x200000</a>
<a name="ln180">#define F_AUDIBLE	0x400000</a>
<a name="ln181">#define F_MISSED	0x800000</a>
<a name="ln182">#define F_NOUSERDATA	(F_NODEADDR | F_FQDN | F_FQDNOLD | F_SUPTYPES)</a>
<a name="ln183">u_int options;</a>
<a name="ln184"> </a>
<a name="ln185">#define IN6LEN		sizeof(struct in6_addr)</a>
<a name="ln186">#define SA6LEN		sizeof(struct sockaddr_in6)</a>
<a name="ln187">#define DUMMY_PORT	10101</a>
<a name="ln188"> </a>
<a name="ln189">#define SIN6(s)	((struct sockaddr_in6 *)(s))</a>
<a name="ln190"> </a>
<a name="ln191">/*</a>
<a name="ln192"> * MAX_DUP_CHK is the number of bits in received table, i.e. the maximum</a>
<a name="ln193"> * number of received sequence numbers we can keep track of.  Change 128</a>
<a name="ln194"> * to 8192 for complete accuracy...</a>
<a name="ln195"> */</a>
<a name="ln196">#define	MAX_DUP_CHK	(8 * 8192)</a>
<a name="ln197">int mx_dup_ck = MAX_DUP_CHK;</a>
<a name="ln198">char rcvd_tbl[MAX_DUP_CHK / 8];</a>
<a name="ln199"> </a>
<a name="ln200">struct addrinfo *res;</a>
<a name="ln201">struct sockaddr_in6 dst;	/* who to ping6 */</a>
<a name="ln202">struct sockaddr_in6 src;	/* src addr of this packet */</a>
<a name="ln203">socklen_t srclen;</a>
<a name="ln204">int datalen = DEFDATALEN;</a>
<a name="ln205">int s;				/* socket file descriptor */</a>
<a name="ln206">u_char outpack[MAXPACKETLEN];</a>
<a name="ln207">char BSPACE = '\b';		/* characters written for flood */</a>
<a name="ln208">char BBELL = '\a';		/* characters written for AUDIBLE */</a>
<a name="ln209">char DOT = '.';</a>
<a name="ln210">char *hostname;</a>
<a name="ln211">int ident;			/* process id to identify our packets */</a>
<a name="ln212">u_int8_t nonce[8];		/* nonce field for node information */</a>
<a name="ln213">int hoplimit = -1;		/* hoplimit */</a>
<a name="ln214">int pathmtu = 0;		/* path MTU for the destination.  0 = unspec. */</a>
<a name="ln215"> </a>
<a name="ln216">/* counters */</a>
<a name="ln217">long nmissedmax;		/* max value of ntransmitted - nreceived - 1 */</a>
<a name="ln218">long npackets;			/* max packets to transmit */</a>
<a name="ln219">long nreceived;			/* # of packets we got back */</a>
<a name="ln220">long nrepeats;			/* number of duplicates */</a>
<a name="ln221">long ntransmitted;		/* sequence # for outbound packets = #sent */</a>
<a name="ln222">struct timeval interval = {1, 0}; /* interval between packets */</a>
<a name="ln223"> </a>
<a name="ln224">/* timing */</a>
<a name="ln225">int timing;			/* flag to do timing */</a>
<a name="ln226">double tmin = 999999999.0;	/* minimum round trip time */</a>
<a name="ln227">double tmax = 0.0;		/* maximum round trip time */</a>
<a name="ln228">double tsum = 0.0;		/* sum of all times, for doing average */</a>
<a name="ln229">double tsumsq = 0.0;		/* sum of all times squared, for std. dev. */</a>
<a name="ln230"> </a>
<a name="ln231">/* for node addresses */</a>
<a name="ln232">u_short naflags;</a>
<a name="ln233"> </a>
<a name="ln234">/* for ancillary data(advanced API) */</a>
<a name="ln235">struct msghdr smsghdr;</a>
<a name="ln236">struct iovec smsgiov;</a>
<a name="ln237">char *scmsg = 0;</a>
<a name="ln238"> </a>
<a name="ln239">volatile sig_atomic_t seenalrm;</a>
<a name="ln240">volatile sig_atomic_t seenint;</a>
<a name="ln241">#ifdef SIGINFO</a>
<a name="ln242">volatile sig_atomic_t seeninfo;</a>
<a name="ln243">#endif</a>
<a name="ln244"> </a>
<a name="ln245">int	 main(int, char *[]);</a>
<a name="ln246">void	 fill(char *, char *);</a>
<a name="ln247">int	 get_hoplim(struct msghdr *);</a>
<a name="ln248">int	 get_pathmtu(struct msghdr *);</a>
<a name="ln249">struct in6_pktinfo *get_rcvpktinfo(struct msghdr *);</a>
<a name="ln250">void	 onsignal(int);</a>
<a name="ln251">void	 retransmit(void);</a>
<a name="ln252">void	 onint(int);</a>
<a name="ln253">size_t	 pingerlen(void);</a>
<a name="ln254">int	 pinger(void);</a>
<a name="ln255">const char *pr_addr(struct sockaddr *, int);</a>
<a name="ln256">void	 pr_icmph(struct icmp6_hdr *, u_char *);</a>
<a name="ln257">void	 pr_iph(struct ip6_hdr *);</a>
<a name="ln258">void	 pr_suptypes(struct icmp6_nodeinfo *, size_t);</a>
<a name="ln259">void	 pr_nodeaddr(struct icmp6_nodeinfo *, int);</a>
<a name="ln260">int	 myechoreply(const struct icmp6_hdr *);</a>
<a name="ln261">int	 mynireply(const struct icmp6_nodeinfo *);</a>
<a name="ln262">char *dnsdecode(const u_char **, const u_char *, const u_char *,</a>
<a name="ln263">	char *, size_t);</a>
<a name="ln264">void	 pr_pack(u_char *, int, struct msghdr *);</a>
<a name="ln265">void	 pr_exthdrs(struct msghdr *);</a>
<a name="ln266">void	 pr_ip6opt(void *, size_t);</a>
<a name="ln267">void	 pr_rthdr(void *, size_t);</a>
<a name="ln268">int	 pr_bitrange(u_int32_t, int, int);</a>
<a name="ln269">void	 pr_retip(struct ip6_hdr *, u_char *);</a>
<a name="ln270">void	 summary(void);</a>
<a name="ln271">void	 tvsub(struct timeval *, struct timeval *);</a>
<a name="ln272">int	 setpolicy(int, char *);</a>
<a name="ln273">char	*nigroup(char *);</a>
<a name="ln274">void	 usage(void);</a>
<a name="ln275"> </a>
<a name="ln276"> </a>
<a name="ln277">int</a>
<a name="ln278">main(argc, argv)</a>
<a name="ln279">	int argc;</a>
<a name="ln280">	char *argv[];</a>
<a name="ln281">{</a>
<a name="ln282">	struct itimerval itimer;</a>
<a name="ln283">	struct sockaddr_in6 from;</a>
<a name="ln284">#ifndef HAVE_ARC4RANDOM</a>
<a name="ln285">	struct timeval seed;</a>
<a name="ln286">#endif</a>
<a name="ln287">#ifdef HAVE_POLL_H</a>
<a name="ln288">	int timeout;</a>
<a name="ln289">#else</a>
<a name="ln290">	struct timeval timeout, *tv;</a>
<a name="ln291">#endif</a>
<a name="ln292">	struct addrinfo hints;</a>
<a name="ln293">#ifdef HAVE_POLL_H</a>
<a name="ln294">	struct pollfd fdmaskp[1];</a>
<a name="ln295">#else</a>
<a name="ln296">	fd_set *fdmaskp;</a>
<a name="ln297">	int fdmasks;</a>
<a name="ln298">#endif</a>
<a name="ln299">	int cc, i;</a>
<a name="ln300">	int ch, hold, packlen, preload, optval, ret_ga;</a>
<a name="ln301">	u_char *datap, *packet;</a>
<a name="ln302">	char *e, *target, *ifname = NULL;</a>
<a name="ln303">	int ip6optlen = 0;</a>
<a name="ln304">	struct cmsghdr *scmsgp = NULL;</a>
<a name="ln305">	struct cmsghdr *cm;</a>
<a name="ln306">#if defined(SO_SNDBUF) &amp;&amp; defined(SO_RCVBUF)</a>
<a name="ln307">	u_long lsockbufsize;</a>
<a name="ln308">	int sockbufsize = 0;</a>
<a name="ln309">#endif</a>
<a name="ln310">	int usepktinfo = 0;</a>
<a name="ln311">	struct in6_pktinfo *pktinfo = NULL;</a>
<a name="ln312">#ifdef IPSEC_POLICY_IPSEC</a>
<a name="ln313">	char *policy_in = NULL;</a>
<a name="ln314">	char *policy_out = NULL;</a>
<a name="ln315">#endif</a>
<a name="ln316">	double intval;</a>
<a name="ln317">#ifdef IPV6_USE_MIN_MTU</a>
<a name="ln318">	int mflag = 0;</a>
<a name="ln319">#endif</a>
<a name="ln320"> </a>
<a name="ln321">	/* just to be sure */</a>
<a name="ln322">	memset(&amp;smsghdr, 0, sizeof(smsghdr));</a>
<a name="ln323">	memset(&amp;smsgiov, 0, sizeof(smsgiov));</a>
<a name="ln324"> </a>
<a name="ln325">	preload = 0;</a>
<a name="ln326">	datap = &amp;outpack[ICMP6ECHOLEN + ICMP6ECHOTMLEN];</a>
<a name="ln327">#ifndef IPSEC</a>
<a name="ln328">#define ADDOPTS</a>
<a name="ln329">#else</a>
<a name="ln330">#ifdef IPSEC_POLICY_IPSEC</a>
<a name="ln331">#define ADDOPTS	&quot;P:&quot;</a>
<a name="ln332">#else</a>
<a name="ln333">#define ADDOPTS	&quot;AE&quot;</a>
<a name="ln334">#endif /*IPSEC_POLICY_IPSEC*/</a>
<a name="ln335">#endif</a>
<a name="ln336">	while ((ch = getopt(argc, argv,</a>
<a name="ln337">	    &quot;a:b:c:dfHh:I:i:l:mnop:qrRS:s:tvwW&quot; ADDOPTS)) != -1) {</a>
<a name="ln338">#undef ADDOPTS</a>
<a name="ln339">		switch (ch) {</a>
<a name="ln340">		case 'a':</a>
<a name="ln341">		{</a>
<a name="ln342">			char *cp;</a>
<a name="ln343"> </a>
<a name="ln344">			options &amp;= ~F_NOUSERDATA;</a>
<a name="ln345">			options |= F_NODEADDR;</a>
<a name="ln346">			for (cp = optarg; *cp != '\0'; cp++) {</a>
<a name="ln347">				switch (*cp) {</a>
<a name="ln348">				case 'a':</a>
<a name="ln349">					naflags |= NI_NODEADDR_FLAG_ALL;</a>
<a name="ln350">					break;</a>
<a name="ln351">				case 'c':</a>
<a name="ln352">				case 'C':</a>
<a name="ln353">					naflags |= NI_NODEADDR_FLAG_COMPAT;</a>
<a name="ln354">					break;</a>
<a name="ln355">				case 'l':</a>
<a name="ln356">				case 'L':</a>
<a name="ln357">					naflags |= NI_NODEADDR_FLAG_LINKLOCAL;</a>
<a name="ln358">					break;</a>
<a name="ln359">				case 's':</a>
<a name="ln360">				case 'S':</a>
<a name="ln361">					naflags |= NI_NODEADDR_FLAG_SITELOCAL;</a>
<a name="ln362">					break;</a>
<a name="ln363">				case 'g':</a>
<a name="ln364">				case 'G':</a>
<a name="ln365">					naflags |= NI_NODEADDR_FLAG_GLOBAL;</a>
<a name="ln366">					break;</a>
<a name="ln367">				case 'A': /* experimental. not in the spec */</a>
<a name="ln368">#ifdef NI_NODEADDR_FLAG_ANYCAST</a>
<a name="ln369">					naflags |= NI_NODEADDR_FLAG_ANYCAST;</a>
<a name="ln370">					break;</a>
<a name="ln371">#else</a>
<a name="ln372">					errx(1,</a>
<a name="ln373">&quot;-a A is not supported on the platform&quot;);</a>
<a name="ln374">					/*NOTREACHED*/</a>
<a name="ln375">#endif</a>
<a name="ln376">				default:</a>
<a name="ln377">					usage();</a>
<a name="ln378">					/*NOTREACHED*/</a>
<a name="ln379">				}</a>
<a name="ln380">			}</a>
<a name="ln381">			break;</a>
<a name="ln382">		}</a>
<a name="ln383">		case 'b':</a>
<a name="ln384">#if defined(SO_SNDBUF) &amp;&amp; defined(SO_RCVBUF)</a>
<a name="ln385">			errno = 0;</a>
<a name="ln386">			e = NULL;</a>
<a name="ln387">			lsockbufsize = strtoul(optarg, &amp;e, 10);</a>
<a name="ln388">			sockbufsize = lsockbufsize;</a>
<a name="ln389">			if (errno || !*optarg || *e ||</a>
<a name="ln390">			    sockbufsize != lsockbufsize)</a>
<a name="ln391">				errx(1, &quot;invalid socket buffer size&quot;);</a>
<a name="ln392">#else</a>
<a name="ln393">			errx(1,</a>
<a name="ln394">&quot;-b option ignored: SO_SNDBUF/SO_RCVBUF socket options not supported&quot;);</a>
<a name="ln395">#endif</a>
<a name="ln396">			break;</a>
<a name="ln397">		case 'c':</a>
<a name="ln398">			npackets = strtol(optarg, &amp;e, 10);</a>
<a name="ln399">			if (npackets &lt;= 0 || *optarg == '\0' || *e != '\0')</a>
<a name="ln400">				errx(1,</a>
<a name="ln401">				    &quot;illegal number of packets -- %s&quot;, optarg);</a>
<a name="ln402">			break;</a>
<a name="ln403">		case 'd':</a>
<a name="ln404">			options |= F_SO_DEBUG;</a>
<a name="ln405">			break;</a>
<a name="ln406">		case 'f':</a>
<a name="ln407">			if (getuid()) {</a>
<a name="ln408">				errno = EPERM;</a>
<a name="ln409">				errx(1, &quot;Must be superuser to flood ping&quot;);</a>
<a name="ln410">			}</a>
<a name="ln411">			options |= F_FLOOD;</a>
<a name="ln412">			setbuf(stdout, (char *)NULL);</a>
<a name="ln413">			break;</a>
<a name="ln414">#ifdef undefined</a>
<a name="ln415">		case 'g':</a>
<a name="ln416">			gateway = optarg;</a>
<a name="ln417">			break;</a>
<a name="ln418">#endif</a>
<a name="ln419">		case 'H':</a>
<a name="ln420">			options |= F_HOSTNAME;</a>
<a name="ln421">			break;</a>
<a name="ln422">		case 'h':		/* hoplimit */</a>
<a name="ln423">			hoplimit = strtol(optarg, &amp;e, 10);</a>
<a name="ln424">			if (*optarg == '\0' || *e != '\0')</a>
<a name="ln425">				errx(1, &quot;illegal hoplimit %s&quot;, optarg);</a>
<a name="ln426">			if (255 &lt; hoplimit || hoplimit &lt; -1)</a>
<a name="ln427">				errx(1,</a>
<a name="ln428">				    &quot;illegal hoplimit -- %s&quot;, optarg);</a>
<a name="ln429">			break;</a>
<a name="ln430">		case 'I':</a>
<a name="ln431">			ifname = optarg;</a>
<a name="ln432">			options |= F_INTERFACE;</a>
<a name="ln433">#ifndef USE_SIN6_SCOPE_ID</a>
<a name="ln434">			usepktinfo++;</a>
<a name="ln435">#endif</a>
<a name="ln436">			break;</a>
<a name="ln437">		case 'i':		/* wait between sending packets */</a>
<a name="ln438">			intval = strtod(optarg, &amp;e);</a>
<a name="ln439">			if (*optarg == '\0' || *e != '\0')</a>
<a name="ln440">				errx(1, &quot;illegal timing interval %s&quot;, optarg);</a>
<a name="ln441">			if (intval &lt; 1 &amp;&amp; getuid()) {</a>
<a name="ln442">				errx(1, &quot;%s: only root may use interval &lt; 1s&quot;,</a>
<a name="ln443">				    strerror(EPERM));</a>
<a name="ln444">			}</a>
<a name="ln445">			interval.tv_sec = (long)intval;</a>
<a name="ln446">			interval.tv_usec =</a>
<a name="ln447">			    (long)((intval - interval.tv_sec) * 1000000);</a>
<a name="ln448">			if (interval.tv_sec &lt; 0)</a>
<a name="ln449">				errx(1, &quot;illegal timing interval %s&quot;, optarg);</a>
<a name="ln450">			/* less than 1/hz does not make sense */</a>
<a name="ln451">			if (interval.tv_sec == 0 &amp;&amp; interval.tv_usec &lt; 1) {</a>
<a name="ln452">				warnx(&quot;too small interval, raised to .000001&quot;);</a>
<a name="ln453">				interval.tv_usec = 1;</a>
<a name="ln454">			}</a>
<a name="ln455">			options |= F_INTERVAL;</a>
<a name="ln456">			break;</a>
<a name="ln457">		case 'l':</a>
<a name="ln458">			if (getuid()) {</a>
<a name="ln459">				errno = EPERM;</a>
<a name="ln460">				errx(1, &quot;Must be superuser to preload&quot;);</a>
<a name="ln461">			}</a>
<a name="ln462">			preload = strtol(optarg, &amp;e, 10);</a>
<a name="ln463">			if (preload &lt; 0 || *optarg == '\0' || *e != '\0')</a>
<a name="ln464">				errx(1, &quot;illegal preload value -- %s&quot;, optarg);</a>
<a name="ln465">			break;</a>
<a name="ln466">		case 'm':</a>
<a name="ln467">#ifdef IPV6_USE_MIN_MTU</a>
<a name="ln468">			mflag++;</a>
<a name="ln469">			break;</a>
<a name="ln470">#else</a>
<a name="ln471">			errx(1, &quot;-%c is not supported on this platform&quot;, ch);</a>
<a name="ln472">			/*NOTREACHED*/</a>
<a name="ln473">#endif</a>
<a name="ln474">		case 'n':</a>
<a name="ln475">			options &amp;= ~F_HOSTNAME;</a>
<a name="ln476">			break;</a>
<a name="ln477">#ifdef undefined</a>
<a name="ln478">		case 'N':</a>
<a name="ln479">			options |= F_NIGROUP;</a>
<a name="ln480">			break;</a>
<a name="ln481">#endif</a>
<a name="ln482">		case 'o':</a>
<a name="ln483">			options |= F_ONCE;</a>
<a name="ln484">			break;</a>
<a name="ln485">		case 'p':		/* fill buffer with user pattern */</a>
<a name="ln486">			options |= F_PINGFILLED;</a>
<a name="ln487">			fill((char *)datap, optarg);</a>
<a name="ln488">				break;</a>
<a name="ln489">		case 'q':</a>
<a name="ln490">			options |= F_QUIET;</a>
<a name="ln491">			break;</a>
<a name="ln492">		case 'r':</a>
<a name="ln493">			options |= F_AUDIBLE;</a>
<a name="ln494">			break;</a>
<a name="ln495">		case 'R':</a>
<a name="ln496">			options |= F_MISSED;</a>
<a name="ln497">			break;</a>
<a name="ln498">		case 'S':</a>
<a name="ln499">			memset(&amp;hints, 0, sizeof(struct addrinfo));</a>
<a name="ln500">			hints.ai_flags = AI_NUMERICHOST; /* allow hostname? */</a>
<a name="ln501">			hints.ai_family = AF_INET6;</a>
<a name="ln502">			hints.ai_socktype = SOCK_RAW;</a>
<a name="ln503">			hints.ai_protocol = IPPROTO_ICMPV6;</a>
<a name="ln504"> </a>
<a name="ln505">			ret_ga = getaddrinfo(optarg, NULL, &amp;hints, &amp;res);</a>
<a name="ln506">			if (ret_ga) {</a>
<a name="ln507">				errx(1, &quot;invalid source address: %s&quot;,</a>
<a name="ln508">				     gai_strerror(ret_ga));</a>
<a name="ln509">			}</a>
<a name="ln510">			/*</a>
<a name="ln511">			 * res-&gt;ai_family must be AF_INET6 and res-&gt;ai_addrlen</a>
<a name="ln512">			 * must be sizeof(src).</a>
<a name="ln513">			 */</a>
<a name="ln514">			memcpy(&amp;src, res-&gt;ai_addr, res-&gt;ai_addrlen);</a>
<a name="ln515">			srclen = res-&gt;ai_addrlen;</a>
<a name="ln516">			freeaddrinfo(res);</a>
<a name="ln517">			options |= F_SRCADDR;</a>
<a name="ln518">			break;</a>
<a name="ln519">		case 's':		/* size of packet to send */</a>
<a name="ln520">			datalen = strtol(optarg, &amp;e, 10);</a>
<a name="ln521">			if (datalen &lt;= 0 || *optarg == '\0' || *e != '\0')</a>
<a name="ln522">				errx(1, &quot;illegal datalen value -- %s&quot;, optarg);</a>
<a name="ln523">			if (datalen &gt; MAXDATALEN) {</a>
<a name="ln524">				errx(1,</a>
<a name="ln525">				    &quot;datalen value too large, maximum is %d&quot;,</a>
<a name="ln526">				    MAXDATALEN);</a>
<a name="ln527">			}</a>
<a name="ln528">			break;</a>
<a name="ln529">		case 't':</a>
<a name="ln530">			options &amp;= ~F_NOUSERDATA;</a>
<a name="ln531">			options |= F_SUPTYPES;</a>
<a name="ln532">			break;</a>
<a name="ln533">		case 'v':</a>
<a name="ln534">			options |= F_VERBOSE;</a>
<a name="ln535">			break;</a>
<a name="ln536">		case 'w':</a>
<a name="ln537">			options &amp;= ~F_NOUSERDATA;</a>
<a name="ln538">			options |= F_FQDN;</a>
<a name="ln539">			break;</a>
<a name="ln540">		case 'W':</a>
<a name="ln541">			options &amp;= ~F_NOUSERDATA;</a>
<a name="ln542">			options |= F_FQDNOLD;</a>
<a name="ln543">			break;</a>
<a name="ln544">#ifdef IPSEC</a>
<a name="ln545">#ifdef IPSEC_POLICY_IPSEC</a>
<a name="ln546">		case 'P':</a>
<a name="ln547">			options |= F_POLICY;</a>
<a name="ln548">			if (!strncmp(&quot;in&quot;, optarg, 2)) {</a>
<a name="ln549">				if ((policy_in = strdup(optarg)) == NULL)</a>
<a name="ln550">					errx(1, &quot;strdup&quot;);</a>
<a name="ln551">			} else if (!strncmp(&quot;out&quot;, optarg, 3)) {</a>
<a name="ln552">				if ((policy_out = strdup(optarg)) == NULL)</a>
<a name="ln553">					errx(1, &quot;strdup&quot;);</a>
<a name="ln554">			} else</a>
<a name="ln555">				errx(1, &quot;invalid security policy&quot;);</a>
<a name="ln556">			break;</a>
<a name="ln557">#else</a>
<a name="ln558">		case 'A':</a>
<a name="ln559">			options |= F_AUTHHDR;</a>
<a name="ln560">			break;</a>
<a name="ln561">		case 'E':</a>
<a name="ln562">			options |= F_ENCRYPT;</a>
<a name="ln563">			break;</a>
<a name="ln564">#endif /*IPSEC_POLICY_IPSEC*/</a>
<a name="ln565">#endif /*IPSEC*/</a>
<a name="ln566">		default:</a>
<a name="ln567">			usage();</a>
<a name="ln568">			/*NOTREACHED*/</a>
<a name="ln569">		}</a>
<a name="ln570">	}</a>
<a name="ln571"> </a>
<a name="ln572">	argc -= optind;</a>
<a name="ln573">	argv += optind;</a>
<a name="ln574"> </a>
<a name="ln575">	if (argc &lt; 1) {</a>
<a name="ln576">		usage();</a>
<a name="ln577">		/*NOTREACHED*/</a>
<a name="ln578">	}</a>
<a name="ln579"> </a>
<a name="ln580">#ifdef undefined</a>
<a name="ln581">	if (options &amp; F_NIGROUP) {</a>
<a name="ln582">		target = nigroup(argv[argc - 1]);</a>
<a name="ln583">		if (target == NULL) {</a>
<a name="ln584">			usage();</a>
<a name="ln585">			/*NOTREACHED*/</a>
<a name="ln586">		}</a>
<a name="ln587">	} else</a>
<a name="ln588">#endif</a>
<a name="ln589">		target = argv[argc - 1];</a>
<a name="ln590"> </a>
<a name="ln591">	/* getaddrinfo */</a>
<a name="ln592">	memset(&amp;hints, 0, sizeof(struct addrinfo));</a>
<a name="ln593">	hints.ai_flags = AI_CANONNAME;</a>
<a name="ln594">	hints.ai_family = AF_INET6;</a>
<a name="ln595">	hints.ai_socktype = SOCK_RAW;</a>
<a name="ln596">	hints.ai_protocol = IPPROTO_ICMPV6;</a>
<a name="ln597"> </a>
<a name="ln598">	ret_ga = getaddrinfo(target, NULL, &amp;hints, &amp;res);</a>
<a name="ln599">	if (ret_ga)</a>
<a name="ln600">		errx(1, &quot;%s&quot;, gai_strerror(ret_ga));</a>
<a name="ln601">	if (res-&gt;ai_canonname)</a>
<a name="ln602">		hostname = res-&gt;ai_canonname;</a>
<a name="ln603">	else</a>
<a name="ln604">		hostname = target;</a>
<a name="ln605"> </a>
<a name="ln606">	if (!res-&gt;ai_addr)</a>
<a name="ln607">		errx(1, &quot;getaddrinfo failed&quot;);</a>
<a name="ln608"> </a>
<a name="ln609">	(void)memcpy(&amp;dst, res-&gt;ai_addr, res-&gt;ai_addrlen);</a>
<a name="ln610"> </a>
<a name="ln611">	if ((s = socket(res-&gt;ai_family, res-&gt;ai_socktype,</a>
<a name="ln612">	    res-&gt;ai_protocol)) &lt; 0)</a>
<a name="ln613">		err(1, &quot;socket&quot;);</a>
<a name="ln614"> </a>
<a name="ln615">	/* set the source address if specified. */</a>
<a name="ln616">	if ((options &amp; F_SRCADDR) &amp;&amp;</a>
<a name="ln617">	    bind(s, (struct sockaddr *)&amp;src, srclen) != 0) {</a>
<a name="ln618">		err(1, &quot;bind&quot;);</a>
<a name="ln619">	}</a>
<a name="ln620"> </a>
<a name="ln621">#ifdef undefined</a>
<a name="ln622">	/* set the gateway (next hop) if specified */</a>
<a name="ln623">	if (gateway) {</a>
<a name="ln624">		struct addrinfo ghints, *gres;</a>
<a name="ln625">		int error;</a>
<a name="ln626"> </a>
<a name="ln627">		memset(&amp;ghints, 0, sizeof(ghints));</a>
<a name="ln628">		ghints.ai_family = AF_INET6;</a>
<a name="ln629">		ghints.ai_socktype = SOCK_RAW;</a>
<a name="ln630">		ghints.ai_protocol = IPPROTO_ICMPV6;</a>
<a name="ln631"> </a>
<a name="ln632">		error = getaddrinfo(gateway, NULL, &amp;hints, &amp;gres);</a>
<a name="ln633">		if (error) {</a>
<a name="ln634">			errx(1, &quot;getaddrinfo for the gateway %s: %s&quot;,</a>
<a name="ln635">			     gateway, gai_strerror(error));</a>
<a name="ln636">		}</a>
<a name="ln637">		if (gres-&gt;ai_next &amp;&amp; (options &amp; F_VERBOSE))</a>
<a name="ln638">			warnx(&quot;gateway resolves to multiple addresses&quot;);</a>
<a name="ln639"> </a>
<a name="ln640">		if (setsockopt(s, IPPROTO_IPV6, IPV6_NEXTHOP,</a>
<a name="ln641">			       gres-&gt;ai_addr, gres-&gt;ai_addrlen)) {</a>
<a name="ln642">			err(1, &quot;setsockopt(IPV6_NEXTHOP)&quot;);</a>
<a name="ln643">		}</a>
<a name="ln644"> </a>
<a name="ln645">		freeaddrinfo(gres);</a>
<a name="ln646">	}</a>
<a name="ln647">#endif</a>
<a name="ln648"> </a>
<a name="ln649">	/*</a>
<a name="ln650">	 * let the kerel pass extension headers of incoming packets,</a>
<a name="ln651">	 * for privileged socket options</a>
<a name="ln652">	 */</a>
<a name="ln653">	if ((options &amp; F_VERBOSE) != 0) {</a>
<a name="ln654">		int opton = 1;</a>
<a name="ln655"> </a>
<a name="ln656">#ifdef IPV6_RECVHOPOPTS</a>
<a name="ln657">		if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVHOPOPTS, &amp;opton,</a>
<a name="ln658">		    sizeof(opton)))</a>
<a name="ln659">			err(1, &quot;setsockopt(IPV6_RECVHOPOPTS)&quot;);</a>
<a name="ln660">#endif</a>
<a name="ln661">#ifdef IPV6_RECVDSTOPTS</a>
<a name="ln662">		if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVDSTOPTS, &amp;opton,</a>
<a name="ln663">		    sizeof(opton)))</a>
<a name="ln664">			err(1, &quot;setsockopt(IPV6_RECVDSTOPTS)&quot;);</a>
<a name="ln665">#endif</a>
<a name="ln666">#ifdef IPV6_RECVRTHDRDSTOPTS</a>
<a name="ln667">		if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVRTHDRDSTOPTS, &amp;opton,</a>
<a name="ln668">		    sizeof(opton)))</a>
<a name="ln669">			err(1, &quot;setsockopt(IPV6_RECVRTHDRDSTOPTS)&quot;);</a>
<a name="ln670">#endif</a>
<a name="ln671">	}</a>
<a name="ln672"> </a>
<a name="ln673">	/* revoke root privilege */</a>
<a name="ln674">	seteuid(getuid());</a>
<a name="ln675">	setuid(getuid());</a>
<a name="ln676"> </a>
<a name="ln677">	if ((options &amp; F_FLOOD) &amp;&amp; (options &amp; F_INTERVAL))</a>
<a name="ln678">		errx(1, &quot;-f and -i incompatible options&quot;);</a>
<a name="ln679"> </a>
<a name="ln680">	if ((options &amp; F_NOUSERDATA) == 0) {</a>
<a name="ln681">		if (datalen &gt;= sizeof(struct tv32)) {</a>
<a name="ln682">			/* we can time transfer */</a>
<a name="ln683">			timing = 1;</a>
<a name="ln684">		} else</a>
<a name="ln685">			timing = 0;</a>
<a name="ln686">		/* in F_VERBOSE case, we may get non-echoreply packets*/</a>
<a name="ln687">		if (options &amp; F_VERBOSE)</a>
<a name="ln688">			packlen = 2048 + IP6LEN + ICMP6ECHOLEN + EXTRA;</a>
<a name="ln689">		else</a>
<a name="ln690">			packlen = datalen + IP6LEN + ICMP6ECHOLEN + EXTRA;</a>
<a name="ln691">	} else {</a>
<a name="ln692">		/* suppress timing for node information query */</a>
<a name="ln693">		timing = 0;</a>
<a name="ln694">		datalen = 2048;</a>
<a name="ln695">		packlen = 2048 + IP6LEN + ICMP6ECHOLEN + EXTRA;</a>
<a name="ln696">	}</a>
<a name="ln697"> </a>
<a name="ln698">	if (!(packet = (u_char *)malloc((u_int)packlen)))</a>
<a name="ln699">		err(1, &quot;Unable to allocate packet&quot;);</a>
<a name="ln700">	if (!(options &amp; F_PINGFILLED))</a>
<a name="ln701">		for (i = ICMP6ECHOLEN; i &lt; packlen; ++i)</a>
<a name="ln702">			*datap++ = i;</a>
<a name="ln703"> </a>
<a name="ln704">	ident = getpid() &amp; 0xFFFF;</a>
<a name="ln705">#ifndef HAVE_ARC4RANDOM</a>
<a name="ln706">	gettimeofday(&amp;seed, NULL);</a>
<a name="ln707">	srand((unsigned int)(seed.tv_sec ^ seed.tv_usec ^ (long)ident));</a>
<a name="ln708">	memset(nonce, 0, sizeof(nonce));</a>
<a name="ln709">	for (i = 0; i &lt; sizeof(nonce); i += sizeof(int))</a>
<a name="ln710">		*((int *)&amp;nonce[i]) = rand();</a>
<a name="ln711">#else</a>
<a name="ln712">	memset(nonce, 0, sizeof(nonce));</a>
<a name="ln713">	for (i = 0; i &lt; sizeof(nonce); i += sizeof(u_int32_t))</a>
<a name="ln714">		*((u_int32_t *)&amp;nonce[i]) = arc4random();</a>
<a name="ln715">#endif</a>
<a name="ln716"> </a>
<a name="ln717">	hold = 1;</a>
<a name="ln718"> </a>
<a name="ln719">	if (options &amp; F_SO_DEBUG)</a>
<a name="ln720">		(void)setsockopt(s, SOL_SOCKET, SO_DEBUG, (char *)&amp;hold,</a>
<a name="ln721">		    sizeof(hold));</a>
<a name="ln722">	optval = IPV6_DEFHLIM;</a>
<a name="ln723">	if (IN6_IS_ADDR_MULTICAST(&amp;dst.sin6_addr))</a>
<a name="ln724">		if (setsockopt(s, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,</a>
<a name="ln725">		    &amp;optval, sizeof(optval)) == -1)</a>
<a name="ln726">			err(1, &quot;IPV6_MULTICAST_HOPS&quot;);</a>
<a name="ln727">#ifdef IPV6_USE_MIN_MTU</a>
<a name="ln728">	if (mflag != 1) {</a>
<a name="ln729">		optval = mflag &gt; 1 ? 0 : 1;</a>
<a name="ln730"> </a>
<a name="ln731">		if (setsockopt(s, IPPROTO_IPV6, IPV6_USE_MIN_MTU,</a>
<a name="ln732">		    &amp;optval, sizeof(optval)) == -1)</a>
<a name="ln733">			err(1, &quot;setsockopt(IPV6_USE_MIN_MTU)&quot;);</a>
<a name="ln734">	}</a>
<a name="ln735">#ifdef IPV6_RECVPATHMTU</a>
<a name="ln736">	else {</a>
<a name="ln737">		optval = 1;</a>
<a name="ln738">		if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVPATHMTU,</a>
<a name="ln739">		    &amp;optval, sizeof(optval)) == -1)</a>
<a name="ln740">			err(1, &quot;setsockopt(IPV6_RECVPATHMTU)&quot;);</a>
<a name="ln741">	}</a>
<a name="ln742">#endif /* IPV6_RECVPATHMTU */</a>
<a name="ln743">#endif /* IPV6_USE_MIN_MTU */</a>
<a name="ln744"> </a>
<a name="ln745">#ifdef IPSEC</a>
<a name="ln746">#ifdef IPSEC_POLICY_IPSEC</a>
<a name="ln747">	if (options &amp; F_POLICY) {</a>
<a name="ln748">		if (setpolicy(s, policy_in) &lt; 0)</a>
<a name="ln749">			errx(1, &quot;%s&quot;, ipsec_strerror());</a>
<a name="ln750">		if (setpolicy(s, policy_out) &lt; 0)</a>
<a name="ln751">			errx(1, &quot;%s&quot;, ipsec_strerror());</a>
<a name="ln752">	}</a>
<a name="ln753">#else</a>
<a name="ln754">	if (options &amp; F_AUTHHDR) {</a>
<a name="ln755">		optval = IPSEC_LEVEL_REQUIRE;</a>
<a name="ln756">#ifdef IPV6_AUTH_TRANS_LEVEL</a>
<a name="ln757">		if (setsockopt(s, IPPROTO_IPV6, IPV6_AUTH_TRANS_LEVEL,</a>
<a name="ln758">		    &amp;optval, sizeof(optval)) == -1)</a>
<a name="ln759">			err(1, &quot;setsockopt(IPV6_AUTH_TRANS_LEVEL)&quot;);</a>
<a name="ln760">#else /* old def */</a>
<a name="ln761">		if (setsockopt(s, IPPROTO_IPV6, IPV6_AUTH_LEVEL,</a>
<a name="ln762">		    &amp;optval, sizeof(optval)) == -1)</a>
<a name="ln763">			err(1, &quot;setsockopt(IPV6_AUTH_LEVEL)&quot;);</a>
<a name="ln764">#endif</a>
<a name="ln765">	}</a>
<a name="ln766">	if (options &amp; F_ENCRYPT) {</a>
<a name="ln767">		optval = IPSEC_LEVEL_REQUIRE;</a>
<a name="ln768">		if (setsockopt(s, IPPROTO_IPV6, IPV6_ESP_TRANS_LEVEL,</a>
<a name="ln769">		    &amp;optval, sizeof(optval)) == -1)</a>
<a name="ln770">			err(1, &quot;setsockopt(IPV6_ESP_TRANS_LEVEL)&quot;);</a>
<a name="ln771">	}</a>
<a name="ln772">#endif /*IPSEC_POLICY_IPSEC*/</a>
<a name="ln773">#endif</a>
<a name="ln774"> </a>
<a name="ln775">#ifdef ICMP6_FILTER</a>
<a name="ln776">    {</a>
<a name="ln777">	struct icmp6_filter filt;</a>
<a name="ln778">	if (!(options &amp; F_VERBOSE)) {</a>
<a name="ln779">		ICMP6_FILTER_SETBLOCKALL(&amp;filt);</a>
<a name="ln780">		if ((options &amp; F_FQDN) || (options &amp; F_FQDNOLD) ||</a>
<a name="ln781">		    (options &amp; F_NODEADDR) || (options &amp; F_SUPTYPES))</a>
<a name="ln782">			ICMP6_FILTER_SETPASS(ICMP6_NI_REPLY, &amp;filt);</a>
<a name="ln783">		else</a>
<a name="ln784">			ICMP6_FILTER_SETPASS(ICMP6_ECHO_REPLY, &amp;filt);</a>
<a name="ln785">	} else {</a>
<a name="ln786">		ICMP6_FILTER_SETPASSALL(&amp;filt);</a>
<a name="ln787">	}</a>
<a name="ln788">	if (setsockopt(s, IPPROTO_ICMPV6, ICMP6_FILTER, &amp;filt,</a>
<a name="ln789">	    sizeof(filt)) &lt; 0)</a>
<a name="ln790">		err(1, &quot;setsockopt(ICMP6_FILTER)&quot;);</a>
<a name="ln791">    }</a>
<a name="ln792">#endif /*ICMP6_FILTER*/</a>
<a name="ln793"> </a>
<a name="ln794">	/* let the kerel pass extension headers of incoming packets */</a>
<a name="ln795">	if ((options &amp; F_VERBOSE) != 0) {</a>
<a name="ln796">		int opton = 1;</a>
<a name="ln797"> </a>
<a name="ln798">#ifdef IPV6_RECVRTHDR</a>
<a name="ln799">		if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVRTHDR, &amp;opton,</a>
<a name="ln800">		    sizeof(opton)))</a>
<a name="ln801">			err(1, &quot;setsockopt(IPV6_RECVRTHDR)&quot;);</a>
<a name="ln802">#endif</a>
<a name="ln803">	}</a>
<a name="ln804"> </a>
<a name="ln805">/*</a>
<a name="ln806">	optval = 1;</a>
<a name="ln807">	if (IN6_IS_ADDR_MULTICAST(&amp;dst.sin6_addr))</a>
<a name="ln808">		if (setsockopt(s, IPPROTO_IPV6, IPV6_MULTICAST_LOOP,</a>
<a name="ln809">		    &amp;optval, sizeof(optval)) == -1)</a>
<a name="ln810">			err(1, &quot;IPV6_MULTICAST_LOOP&quot;);</a>
<a name="ln811">*/</a>
<a name="ln812"> </a>
<a name="ln813">	/* Specify the outgoing interface and/or the source address */</a>
<a name="ln814">	if (usepktinfo)</a>
<a name="ln815">		ip6optlen += CMSG_SPACE(sizeof(struct in6_pktinfo));</a>
<a name="ln816"> </a>
<a name="ln817">	if (hoplimit != -1)</a>
<a name="ln818">		ip6optlen += CMSG_SPACE(sizeof(int));</a>
<a name="ln819"> </a>
<a name="ln820">	/* set IP6 packet options */</a>
<a name="ln821">	if (ip6optlen) {</a>
<a name="ln822">		if ((scmsg = (char *)malloc(ip6optlen)) == 0)</a>
<a name="ln823">			errx(1, &quot;can't allocate enough memory&quot;);</a>
<a name="ln824">		smsghdr.msg_control = (caddr_t)scmsg;</a>
<a name="ln825">		smsghdr.msg_controllen = ip6optlen;</a>
<a name="ln826">		scmsgp = (struct cmsghdr *)scmsg;</a>
<a name="ln827">	}</a>
<a name="ln828">	if (usepktinfo) {</a>
<a name="ln829">		pktinfo = (struct in6_pktinfo *)(CMSG_DATA(scmsgp));</a>
<a name="ln830">		memset(pktinfo, 0, sizeof(*pktinfo));</a>
<a name="ln831">		scmsgp-&gt;cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));</a>
<a name="ln832">		scmsgp-&gt;cmsg_level = IPPROTO_IPV6;</a>
<a name="ln833">		scmsgp-&gt;cmsg_type = IPV6_PKTINFO;</a>
<a name="ln834">		scmsgp = CMSG_NXTHDR(&amp;smsghdr, scmsgp);</a>
<a name="ln835">	}</a>
<a name="ln836"> </a>
<a name="ln837">	/* set the outgoing interface */</a>
<a name="ln838">	if (ifname) {</a>
<a name="ln839">#ifndef USE_SIN6_SCOPE_ID</a>
<a name="ln840">		/* pktinfo must have already been allocated */</a>
<a name="ln841">		if ((pktinfo-&gt;ipi6_ifindex = if_nametoindex(ifname)) == 0)</a>
<a name="ln842">			errx(1, &quot;%s: invalid interface name&quot;, ifname);</a>
<a name="ln843">#else</a>
<a name="ln844">		if ((dst.sin6_scope_id = if_nametoindex(ifname)) == 0)</a>
<a name="ln845">			errx(1, &quot;%s: invalid interface name&quot;, ifname);</a>
<a name="ln846">#endif</a>
<a name="ln847">	}</a>
<a name="ln848">	if (hoplimit != -1) {</a>
<a name="ln849">		scmsgp-&gt;cmsg_len = CMSG_LEN(sizeof(int));</a>
<a name="ln850">		scmsgp-&gt;cmsg_level = IPPROTO_IPV6;</a>
<a name="ln851">		scmsgp-&gt;cmsg_type = IPV6_HOPLIMIT;</a>
<a name="ln852">		*(int *)(CMSG_DATA(scmsgp)) = hoplimit;</a>
<a name="ln853"> </a>
<a name="ln854">		scmsgp = CMSG_NXTHDR(&amp;smsghdr, scmsgp);</a>
<a name="ln855">	}</a>
<a name="ln856"> </a>
<a name="ln857">	if (!(options &amp; F_SRCADDR)) {</a>
<a name="ln858">		/*</a>
<a name="ln859">		 * get the source address. XXX since we revoked the root</a>
<a name="ln860">		 * privilege, we cannot use a raw socket for this.</a>
<a name="ln861">		 */</a>
<a name="ln862">		int dummy;</a>
<a name="ln863">		socklen_t len = sizeof(src);</a>
<a name="ln864"> </a>
<a name="ln865">		if ((dummy = socket(AF_INET6, SOCK_DGRAM, 0)) &lt; 0)</a>
<a name="ln866">			err(1, &quot;UDP socket&quot;);</a>
<a name="ln867"> </a>
<a name="ln868">		src.sin6_family = AF_INET6;</a>
<a name="ln869">		src.sin6_addr = dst.sin6_addr;</a>
<a name="ln870">		src.sin6_port = ntohs(DUMMY_PORT);</a>
<a name="ln871">		src.sin6_scope_id = dst.sin6_scope_id;</a>
<a name="ln872"> </a>
<a name="ln873">#ifdef USE_RFC2292BIS</a>
<a name="ln874">		if (pktinfo &amp;&amp;</a>
<a name="ln875">		    setsockopt(dummy, IPPROTO_IPV6, IPV6_PKTINFO,</a>
<a name="ln876">		    (void *)pktinfo, sizeof(*pktinfo)))</a>
<a name="ln877">			err(1, &quot;UDP setsockopt(IPV6_PKTINFO)&quot;);</a>
<a name="ln878"> </a>
<a name="ln879">		if (hoplimit != -1 &amp;&amp;</a>
<a name="ln880">		    setsockopt(dummy, IPPROTO_IPV6, IPV6_UNICAST_HOPS,</a>
<a name="ln881">		    (void *)&amp;hoplimit, sizeof(hoplimit)))</a>
<a name="ln882">			err(1, &quot;UDP setsockopt(IPV6_UNICAST_HOPS)&quot;);</a>
<a name="ln883"> </a>
<a name="ln884">		if (hoplimit != -1 &amp;&amp;</a>
<a name="ln885">		    setsockopt(dummy, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,</a>
<a name="ln886">		    (void *)&amp;hoplimit, sizeof(hoplimit)))</a>
<a name="ln887">			err(1, &quot;UDP setsockopt(IPV6_MULTICAST_HOPS)&quot;);</a>
<a name="ln888"> </a>
<a name="ln889">#else  /* old advanced API */</a>
<a name="ln890">		if (smsghdr.msg_control &amp;&amp;</a>
<a name="ln891">		    setsockopt(dummy, IPPROTO_IPV6, IPV6_PKTOPTIONS,</a>
<a name="ln892">		    (void *)smsghdr.msg_control, smsghdr.msg_controllen))</a>
<a name="ln893">			err(1, &quot;UDP setsockopt(IPV6_PKTOPTIONS)&quot;);</a>
<a name="ln894">#endif</a>
<a name="ln895"> </a>
<a name="ln896">		if (connect(dummy, (struct sockaddr *)&amp;src, len) &lt; 0)</a>
<a name="ln897">			err(1, &quot;UDP connect&quot;);</a>
<a name="ln898"> </a>
<a name="ln899">		if (getsockname(dummy, (struct sockaddr *)&amp;src, &amp;len) &lt; 0)</a>
<a name="ln900">			err(1, &quot;getsockname&quot;);</a>
<a name="ln901"> </a>
<a name="ln902">		close(dummy);</a>
<a name="ln903">	}</a>
<a name="ln904"> </a>
<a name="ln905">#if defined(SO_SNDBUF) &amp;&amp; defined(SO_RCVBUF)</a>
<a name="ln906">	if (sockbufsize) {</a>
<a name="ln907">		if (datalen &gt; sockbufsize)</a>
<a name="ln908">			warnx(&quot;you need -b to increase socket buffer size&quot;);</a>
<a name="ln909">		if (setsockopt(s, SOL_SOCKET, SO_SNDBUF, &amp;sockbufsize,</a>
<a name="ln910">		    sizeof(sockbufsize)) &lt; 0)</a>
<a name="ln911">			err(1, &quot;setsockopt(SO_SNDBUF)&quot;);</a>
<a name="ln912">		if (setsockopt(s, SOL_SOCKET, SO_RCVBUF, &amp;sockbufsize,</a>
<a name="ln913">		    sizeof(sockbufsize)) &lt; 0)</a>
<a name="ln914">			err(1, &quot;setsockopt(SO_RCVBUF)&quot;);</a>
<a name="ln915">	}</a>
<a name="ln916">	else {</a>
<a name="ln917">		if (datalen &gt; 8 * 1024)	/*XXX*/</a>
<a name="ln918">			warnx(&quot;you need -b to increase socket buffer size&quot;);</a>
<a name="ln919">		/*</a>
<a name="ln920">		 * When pinging the broadcast address, you can get a lot of</a>
<a name="ln921">		 * answers. Doing something so evil is useful if you are trying</a>
<a name="ln922">		 * to stress the ethernet, or just want to fill the arp cache</a>
<a name="ln923">		 * to get some stuff for /etc/ethers.</a>
<a name="ln924">		 */</a>
<a name="ln925">		hold = 48 * 1024;</a>
<a name="ln926">		setsockopt(s, SOL_SOCKET, SO_RCVBUF, (char *)&amp;hold,</a>
<a name="ln927">		    sizeof(hold));</a>
<a name="ln928">	}</a>
<a name="ln929">#endif</a>
<a name="ln930"> </a>
<a name="ln931">	optval = 1;</a>
<a name="ln932">//#ifndef USE_SIN6_SCOPE_ID</a>
<a name="ln933">#ifdef IPV6_RECVPKTINFO</a>
<a name="ln934">	if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVPKTINFO, &amp;optval,</a>
<a name="ln935">	    sizeof(optval)) &lt; 0)</a>
<a name="ln936">		warn(&quot;setsockopt(IPV6_RECVPKTINFO)&quot;); /* XXX err? */</a>
<a name="ln937">#else  /* old adv. API */</a>
<a name="ln938">	if (setsockopt(s, IPPROTO_IPV6, IPV6_PKTINFO, &amp;optval,</a>
<a name="ln939">	    sizeof(optval)) &lt; 0)</a>
<a name="ln940">		warn(&quot;setsockopt(IPV6_PKTINFO)&quot;); /* XXX err? */</a>
<a name="ln941">#endif</a>
<a name="ln942">//#endif /* USE_SIN6_SCOPE_ID */</a>
<a name="ln943">#ifdef IPV6_RECVHOPLIMIT</a>
<a name="ln944">	if (setsockopt(s, IPPROTO_IPV6, IPV6_RECVHOPLIMIT, &amp;optval,</a>
<a name="ln945">	    sizeof(optval)) &lt; 0)</a>
<a name="ln946">		warn(&quot;setsockopt(IPV6_RECVHOPLIMIT)&quot;); /* XXX err? */</a>
<a name="ln947">#else  /* old adv. API */</a>
<a name="ln948">	if (setsockopt(s, IPPROTO_IPV6, IPV6_HOPLIMIT, &amp;optval,</a>
<a name="ln949">	    sizeof(optval)) &lt; 0)</a>
<a name="ln950">		warn(&quot;setsockopt(IPV6_HOPLIMIT)&quot;); /* XXX err? */</a>
<a name="ln951">#endif</a>
<a name="ln952"> </a>
<a name="ln953">	if (hoplimit != -1 &amp;&amp;</a>
<a name="ln954">		setsockopt(s, IPPROTO_IPV6, IPV6_UNICAST_HOPS,</a>
<a name="ln955">			(void *)&amp;hoplimit, sizeof(hoplimit)))</a>
<a name="ln956">		err(1, &quot;setsockopt(IPV6_UNICAST_HOPS)&quot;);</a>
<a name="ln957"> </a>
<a name="ln958">	if (hoplimit != -1 &amp;&amp;</a>
<a name="ln959">		setsockopt(s, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,</a>
<a name="ln960">			(void *)&amp;hoplimit, sizeof(hoplimit)))</a>
<a name="ln961">		err(1, &quot;setsockopt(IPV6_MULTICAST_HOPS)&quot;);</a>
<a name="ln962"> </a>
<a name="ln963"> </a>
<a name="ln964">	printf(&quot;PING6(%lu=40+8+%lu bytes) &quot;, (unsigned long)(40 + pingerlen()),</a>
<a name="ln965">	    (unsigned long)(pingerlen() - 8));</a>
<a name="ln966">	printf(&quot;%s --&gt; &quot;, pr_addr((struct sockaddr *)&amp;src, sizeof(src)));</a>
<a name="ln967">	printf(&quot;%s\n&quot;, pr_addr((struct sockaddr *)&amp;dst, sizeof(dst)));</a>
<a name="ln968"> </a>
<a name="ln969">	while (preload--)		/* Fire off them quickies. */</a>
<a name="ln970">		(void)pinger();</a>
<a name="ln971"> </a>
<a name="ln972">	(void)signal(SIGINT, onsignal);</a>
<a name="ln973">#ifdef SIGINFO</a>
<a name="ln974">	(void)signal(SIGINFO, onsignal);</a>
<a name="ln975">#endif</a>
<a name="ln976"> </a>
<a name="ln977">	if ((options &amp; F_FLOOD) == 0) {</a>
<a name="ln978">		(void)signal(SIGALRM, onsignal);</a>
<a name="ln979">		itimer.it_interval = interval;</a>
<a name="ln980">		itimer.it_value = interval;</a>
<a name="ln981">		(void)setitimer(ITIMER_REAL, &amp;itimer, NULL);</a>
<a name="ln982">		if (ntransmitted == 0)</a>
<a name="ln983">			retransmit();</a>
<a name="ln984">	}</a>
<a name="ln985"> </a>
<a name="ln986">#ifndef HAVE_POLL_H</a>
<a name="ln987">	fdmasks = howmany(s + 1, NFDBITS) * sizeof(fd_mask);</a>
<a name="ln988">	if ((fdmaskp = malloc(fdmasks)) == NULL)</a>
<a name="ln989">		err(1, &quot;malloc&quot;);</a>
<a name="ln990">#endif</a>
<a name="ln991"> </a>
<a name="ln992">	seenalrm = seenint = 0;</a>
<a name="ln993">#ifdef SIGINFO</a>
<a name="ln994">	seeninfo = 0;</a>
<a name="ln995">#endif</a>
<a name="ln996"> </a>
<a name="ln997">	/* For control (ancillary) data received from recvmsg() */</a>
<a name="ln998">	cm = (struct cmsghdr *)malloc(CONTROLLEN);</a>
<a name="ln999">	if (cm == NULL)</a>
<a name="ln1000">		err(1, &quot;malloc&quot;);</a>
<a name="ln1001"> </a>
<a name="ln1002">	for (;;) {</a>
<a name="ln1003">		struct msghdr m;</a>
<a name="ln1004">		struct iovec iov[2];</a>
<a name="ln1005"> </a>
<a name="ln1006">		/* signal handling */</a>
<a name="ln1007">		if (seenalrm) {</a>
<a name="ln1008">			/* last packet sent, timeout reached? */</a>
<a name="ln1009">			if (npackets &amp;&amp; ntransmitted &gt;= npackets)</a>
<a name="ln1010">				break;</a>
<a name="ln1011">			retransmit();</a>
<a name="ln1012">			seenalrm = 0;</a>
<a name="ln1013">			continue;</a>
<a name="ln1014">		}</a>
<a name="ln1015">		if (seenint) {</a>
<a name="ln1016">			onint(SIGINT);</a>
<a name="ln1017">			seenint = 0;</a>
<a name="ln1018">			continue;</a>
<a name="ln1019">		}</a>
<a name="ln1020">#ifdef SIGINFO</a>
<a name="ln1021">		if (seeninfo) {</a>
<a name="ln1022">			summary();</a>
<a name="ln1023">			seeninfo = 0;</a>
<a name="ln1024">			continue;</a>
<a name="ln1025">		}</a>
<a name="ln1026">#endif</a>
<a name="ln1027"> </a>
<a name="ln1028">		if (options &amp; F_FLOOD) {</a>
<a name="ln1029">			(void)pinger();</a>
<a name="ln1030">#ifdef HAVE_POLL_H</a>
<a name="ln1031">			timeout = 10;</a>
<a name="ln1032">#else</a>
<a name="ln1033">			timeout.tv_sec = 0;</a>
<a name="ln1034">			timeout.tv_usec = 10000;</a>
<a name="ln1035">			tv = &amp;timeout;</a>
<a name="ln1036">#endif</a>
<a name="ln1037">		} else {</a>
<a name="ln1038">#ifdef HAVE_POLL_H</a>
<a name="ln1039">			timeout = -1;</a>
<a name="ln1040">#else</a>
<a name="ln1041">			tv = NULL;</a>
<a name="ln1042">#endif</a>
<a name="ln1043">		}</a>
<a name="ln1044">#ifdef HAVE_POLL_H</a>
<a name="ln1045">		fdmaskp[0].fd = s;</a>
<a name="ln1046">		fdmaskp[0].events = POLLIN;</a>
<a name="ln1047">		cc = poll(fdmaskp, 1, timeout);</a>
<a name="ln1048">#else</a>
<a name="ln1049">		memset(fdmaskp, 0, fdmasks);</a>
<a name="ln1050">		FD_SET(s, fdmaskp);</a>
<a name="ln1051">		cc = select(s + 1, fdmaskp, NULL, NULL, tv);</a>
<a name="ln1052">#endif</a>
<a name="ln1053">		if (cc &lt; 0) {</a>
<a name="ln1054">			if (errno != EINTR) {</a>
<a name="ln1055">#ifdef HAVE_POLL_H</a>
<a name="ln1056">				warn(&quot;poll&quot;);</a>
<a name="ln1057">#else</a>
<a name="ln1058">				warn(&quot;select&quot;);</a>
<a name="ln1059">#endif</a>
<a name="ln1060">				sleep(1);</a>
<a name="ln1061">			}</a>
<a name="ln1062">			continue;</a>
<a name="ln1063">		} else if (cc == 0)</a>
<a name="ln1064">			continue;</a>
<a name="ln1065"> </a>
<a name="ln1066">		m.msg_name = (caddr_t)&amp;from;</a>
<a name="ln1067">		m.msg_namelen = sizeof(from);</a>
<a name="ln1068">		memset(&amp;iov, 0, sizeof(iov));</a>
<a name="ln1069">		iov[0].iov_base = (caddr_t)packet;</a>
<a name="ln1070">		iov[0].iov_len = packlen;</a>
<a name="ln1071">		m.msg_iov = iov;</a>
<a name="ln1072">		m.msg_iovlen = 1;</a>
<a name="ln1073">		memset(cm, 0, CONTROLLEN);</a>
<a name="ln1074">		m.msg_control = (void *)cm;</a>
<a name="ln1075">		m.msg_controllen = CONTROLLEN;</a>
<a name="ln1076"> </a>
<a name="ln1077">		cc = recvmsg(s, &amp;m, 0);</a>
<a name="ln1078">		if (cc &lt; 0) {</a>
<a name="ln1079">			if (errno != EINTR) {</a>
<a name="ln1080">				warn(&quot;recvmsg&quot;);</a>
<a name="ln1081">				sleep(1);</a>
<a name="ln1082">			}</a>
<a name="ln1083">			continue;</a>
<a name="ln1084">		} else if (cc == 0) {</a>
<a name="ln1085">			int mtu;</a>
<a name="ln1086"> </a>
<a name="ln1087">			/*</a>
<a name="ln1088">			 * receive control messages only. Process the</a>
<a name="ln1089">			 * exceptions (currently the only possiblity is</a>
<a name="ln1090">			 * a path MTU notification.)</a>
<a name="ln1091">			 */</a>
<a name="ln1092">			if ((mtu = get_pathmtu(&amp;m)) &gt; 0) {</a>
<a name="ln1093">				if ((options &amp; F_VERBOSE) != 0) {</a>
<a name="ln1094">					printf(&quot;new path MTU (%d) is &quot;</a>
<a name="ln1095">					    &quot;notified\n&quot;, mtu);</a>
<a name="ln1096">				}</a>
<a name="ln1097">			}</a>
<a name="ln1098">			continue;</a>
<a name="ln1099">		} else {</a>
<a name="ln1100">			/*</a>
<a name="ln1101">			 * an ICMPv6 message (probably an echoreply) arrived.</a>
<a name="ln1102">			 */</a>
<a name="ln1103">			pr_pack(packet, cc, &amp;m);</a>
<a name="ln1104">		}</a>
<a name="ln1105">		if (((options &amp; F_ONCE) != 0 &amp;&amp; nreceived &gt; 0) ||</a>
<a name="ln1106">		    (npackets &gt; 0 &amp;&amp; nreceived &gt;= npackets))</a>
<a name="ln1107">			break;</a>
<a name="ln1108">		if (ntransmitted - nreceived - 1 &gt; nmissedmax) {</a>
<a name="ln1109">			nmissedmax = ntransmitted - nreceived - 1;</a>
<a name="ln1110">			if (options &amp; F_MISSED)</a>
<a name="ln1111">				(void)write(STDOUT_FILENO, &amp;BBELL, 1);</a>
<a name="ln1112">		}</a>
<a name="ln1113">	}</a>
<a name="ln1114">	summary();</a>
<a name="ln1115">	exit(nreceived == 0 ? 2 : 0);</a>
<a name="ln1116">}</a>
<a name="ln1117"> </a>
<a name="ln1118">void</a>
<a name="ln1119">onsignal(sig)</a>
<a name="ln1120">	int sig;</a>
<a name="ln1121">{</a>
<a name="ln1122"> </a>
<a name="ln1123">	switch (sig) {</a>
<a name="ln1124">	case SIGALRM:</a>
<a name="ln1125">		seenalrm++;</a>
<a name="ln1126">		break;</a>
<a name="ln1127">	case SIGINT:</a>
<a name="ln1128">		seenint++;</a>
<a name="ln1129">		break;</a>
<a name="ln1130">#ifdef SIGINFO</a>
<a name="ln1131">	case SIGINFO:</a>
<a name="ln1132">		seeninfo++;</a>
<a name="ln1133">		break;</a>
<a name="ln1134">#endif</a>
<a name="ln1135">	}</a>
<a name="ln1136">}</a>
<a name="ln1137"> </a>
<a name="ln1138">/*</a>
<a name="ln1139"> * retransmit --</a>
<a name="ln1140"> *	This routine transmits another ping6.</a>
<a name="ln1141"> */</a>
<a name="ln1142">void</a>
<a name="ln1143">retransmit()</a>
<a name="ln1144">{</a>
<a name="ln1145">	struct itimerval itimer;</a>
<a name="ln1146"> </a>
<a name="ln1147">	if (pinger() == 0)</a>
<a name="ln1148">		return;</a>
<a name="ln1149"> </a>
<a name="ln1150">	/*</a>
<a name="ln1151">	 * If we're not transmitting any more packets, change the timer</a>
<a name="ln1152">	 * to wait two round-trip times if we've received any packets or</a>
<a name="ln1153">	 * ten seconds if we haven't.</a>
<a name="ln1154">	 */</a>
<a name="ln1155">#define	MAXWAIT		10</a>
<a name="ln1156">	if (nreceived) {</a>
<a name="ln1157">		itimer.it_value.tv_sec =  2 * tmax / 1000;</a>
<a name="ln1158">		if (itimer.it_value.tv_sec == 0)</a>
<a name="ln1159">			itimer.it_value.tv_sec = 1;</a>
<a name="ln1160">	} else</a>
<a name="ln1161">		itimer.it_value.tv_sec = MAXWAIT;</a>
<a name="ln1162">	itimer.it_interval.tv_sec = 0;</a>
<a name="ln1163">	itimer.it_interval.tv_usec = 0;</a>
<a name="ln1164">	itimer.it_value.tv_usec = 0;</a>
<a name="ln1165"> </a>
<a name="ln1166">	(void)signal(SIGALRM, onsignal);</a>
<a name="ln1167">	(void)setitimer(ITIMER_REAL, &amp;itimer, NULL);</a>
<a name="ln1168">}</a>
<a name="ln1169"> </a>
<a name="ln1170">/*</a>
<a name="ln1171"> * pinger --</a>
<a name="ln1172"> *	Compose and transmit an ICMP ECHO REQUEST packet.  The IP packet</a>
<a name="ln1173"> * will be added on by the kernel.  The ID field is our UNIX process ID,</a>
<a name="ln1174"> * and the sequence number is an ascending integer.  The first 8 bytes</a>
<a name="ln1175"> * of the data portion are used to hold a UNIX &quot;timeval&quot; struct in VAX</a>
<a name="ln1176"> * byte-order, to compute the round-trip time.</a>
<a name="ln1177"> */</a>
<a name="ln1178">size_t</a>
<a name="ln1179">pingerlen()</a>
<a name="ln1180">{</a>
<a name="ln1181">	size_t l;</a>
<a name="ln1182"> </a>
<a name="ln1183">	if (options &amp; F_FQDN)</a>
<a name="ln1184">		l = ICMP6_NIQLEN + sizeof(dst.sin6_addr);</a>
<a name="ln1185">	else if (options &amp; F_FQDNOLD)</a>
<a name="ln1186">		l = ICMP6_NIQLEN;</a>
<a name="ln1187">	else if (options &amp; F_NODEADDR)</a>
<a name="ln1188">		l = ICMP6_NIQLEN + sizeof(dst.sin6_addr);</a>
<a name="ln1189">	else if (options &amp; F_SUPTYPES)</a>
<a name="ln1190">		l = ICMP6_NIQLEN;</a>
<a name="ln1191">	else</a>
<a name="ln1192">		l = ICMP6ECHOLEN + datalen;</a>
<a name="ln1193"> </a>
<a name="ln1194">	return l;</a>
<a name="ln1195">}</a>
<a name="ln1196"> </a>
<a name="ln1197">int</a>
<a name="ln1198">pinger()</a>
<a name="ln1199">{</a>
<a name="ln1200">	struct icmp6_hdr *icp;</a>
<a name="ln1201">	struct iovec iov[2];</a>
<a name="ln1202">	int i, cc;</a>
<a name="ln1203">	struct icmp6_nodeinfo *nip;</a>
<a name="ln1204">	int seq;</a>
<a name="ln1205"> </a>
<a name="ln1206">	if (npackets &amp;&amp; ntransmitted &gt;= npackets)</a>
<a name="ln1207">		return(-1);	/* no more transmission */</a>
<a name="ln1208"> </a>
<a name="ln1209">	icp = (struct icmp6_hdr *)outpack;</a>
<a name="ln1210">	nip = (struct icmp6_nodeinfo *)outpack;</a>
<a name="ln1211">	memset(icp, 0, sizeof(*icp));</a>
<a name="ln1212">	icp-&gt;icmp6_cksum = 0;</a>
<a name="ln1213">	seq = ntransmitted++;</a>
<a name="ln1214">	CLR(seq % mx_dup_ck);</a>
<a name="ln1215"> </a>
<a name="ln1216">	if (options &amp; F_FQDN) {</a>
<a name="ln1217">		icp-&gt;icmp6_type = ICMP6_NI_QUERY;</a>
<a name="ln1218">		icp-&gt;icmp6_code = ICMP6_NI_SUBJ_IPV6;</a>
<a name="ln1219">		nip-&gt;ni_qtype = htons(NI_QTYPE_FQDN);</a>
<a name="ln1220">		nip-&gt;ni_flags = htons(0);</a>
<a name="ln1221"> </a>
<a name="ln1222">		memcpy(nip-&gt;icmp6_ni_nonce, nonce,</a>
<a name="ln1223">		    sizeof(nip-&gt;icmp6_ni_nonce));</a>
<a name="ln1224">		*(u_int16_t *)nip-&gt;icmp6_ni_nonce = ntohs(seq);</a>
<a name="ln1225"> </a>
<a name="ln1226">		memcpy(&amp;outpack[ICMP6_NIQLEN], &amp;dst.sin6_addr,</a>
<a name="ln1227">		    sizeof(dst.sin6_addr));</a>
<a name="ln1228">		cc = ICMP6_NIQLEN + sizeof(dst.sin6_addr);</a>
<a name="ln1229">		datalen = 0;</a>
<a name="ln1230">	} else if (options &amp; F_FQDNOLD) {</a>
<a name="ln1231">		/* packet format in 03 draft - no Subject data on queries */</a>
<a name="ln1232">		icp-&gt;icmp6_type = ICMP6_NI_QUERY;</a>
<a name="ln1233">		icp-&gt;icmp6_code = 0;	/* code field is always 0 */</a>
<a name="ln1234">		nip-&gt;ni_qtype = htons(NI_QTYPE_FQDN);</a>
<a name="ln1235">		nip-&gt;ni_flags = htons(0);</a>
<a name="ln1236"> </a>
<a name="ln1237">		memcpy(nip-&gt;icmp6_ni_nonce, nonce,</a>
<a name="ln1238">		    sizeof(nip-&gt;icmp6_ni_nonce));</a>
<a name="ln1239">		*(u_int16_t *)nip-&gt;icmp6_ni_nonce = ntohs(seq);</a>
<a name="ln1240"> </a>
<a name="ln1241">		cc = ICMP6_NIQLEN;</a>
<a name="ln1242">		datalen = 0;</a>
<a name="ln1243">	} else if (options &amp; F_NODEADDR) {</a>
<a name="ln1244">		icp-&gt;icmp6_type = ICMP6_NI_QUERY;</a>
<a name="ln1245">		icp-&gt;icmp6_code = ICMP6_NI_SUBJ_IPV6;</a>
<a name="ln1246">		nip-&gt;ni_qtype = htons(NI_QTYPE_NODEADDR);</a>
<a name="ln1247">		nip-&gt;ni_flags = naflags;</a>
<a name="ln1248"> </a>
<a name="ln1249">		memcpy(nip-&gt;icmp6_ni_nonce, nonce,</a>
<a name="ln1250">		    sizeof(nip-&gt;icmp6_ni_nonce));</a>
<a name="ln1251">		*(u_int16_t *)nip-&gt;icmp6_ni_nonce = ntohs(seq);</a>
<a name="ln1252"> </a>
<a name="ln1253">		memcpy(&amp;outpack[ICMP6_NIQLEN], &amp;dst.sin6_addr,</a>
<a name="ln1254">		    sizeof(dst.sin6_addr));</a>
<a name="ln1255">		cc = ICMP6_NIQLEN + sizeof(dst.sin6_addr);</a>
<a name="ln1256">		datalen = 0;</a>
<a name="ln1257">	} else if (options &amp; F_SUPTYPES) {</a>
<a name="ln1258">		icp-&gt;icmp6_type = ICMP6_NI_QUERY;</a>
<a name="ln1259">		icp-&gt;icmp6_code = ICMP6_NI_SUBJ_FQDN;	/*empty*/</a>
<a name="ln1260">		nip-&gt;ni_qtype = htons(NI_QTYPE_SUPTYPES);</a>
<a name="ln1261">		/* we support compressed bitmap */</a>
<a name="ln1262">		nip-&gt;ni_flags = NI_SUPTYPE_FLAG_COMPRESS;</a>
<a name="ln1263"> </a>
<a name="ln1264">		memcpy(nip-&gt;icmp6_ni_nonce, nonce,</a>
<a name="ln1265">		    sizeof(nip-&gt;icmp6_ni_nonce));</a>
<a name="ln1266">		*(u_int16_t *)nip-&gt;icmp6_ni_nonce = ntohs(seq);</a>
<a name="ln1267">		cc = ICMP6_NIQLEN;</a>
<a name="ln1268">		datalen = 0;</a>
<a name="ln1269">	} else {</a>
<a name="ln1270">		icp-&gt;icmp6_type = ICMP6_ECHO_REQUEST;</a>
<a name="ln1271">		icp-&gt;icmp6_code = 0;</a>
<a name="ln1272">		icp-&gt;icmp6_id = htons(ident);</a>
<a name="ln1273">		icp-&gt;icmp6_seq = ntohs(seq);</a>
<a name="ln1274">		if (timing) {</a>
<a name="ln1275">			struct timeval tv;</a>
<a name="ln1276">			struct tv32 *tv32;</a>
<a name="ln1277">			(void)gettimeofday(&amp;tv, NULL);</a>
<a name="ln1278">			tv32 = (struct tv32 *)&amp;outpack[ICMP6ECHOLEN];</a>
<a name="ln1279">			tv32-&gt;tv32_sec = htonl(tv.tv_sec);</a>
<a name="ln1280">			tv32-&gt;tv32_usec = htonl(tv.tv_usec);</a>
<a name="ln1281">		}</a>
<a name="ln1282">		cc = ICMP6ECHOLEN + datalen;</a>
<a name="ln1283">	}</a>
<a name="ln1284"> </a>
<a name="ln1285">#ifdef DIAGNOSTIC</a>
<a name="ln1286">	if (pingerlen() != cc)</a>
<a name="ln1287">		errx(1, &quot;internal error; length mismatch&quot;);</a>
<a name="ln1288">#endif</a>
<a name="ln1289"> </a>
<a name="ln1290">	smsghdr.msg_name = (caddr_t)&amp;dst;</a>
<a name="ln1291">	smsghdr.msg_namelen = sizeof(dst);</a>
<a name="ln1292">	memset(&amp;iov, 0, sizeof(iov));</a>
<a name="ln1293">	iov[0].iov_base = (caddr_t)outpack;</a>
<a name="ln1294">	iov[0].iov_len = cc;</a>
<a name="ln1295">	smsghdr.msg_iov = iov;</a>
<a name="ln1296">	smsghdr.msg_iovlen = 1;</a>
<a name="ln1297"> </a>
<a name="ln1298">#ifdef CMSG_SENDING_UNSUPPORTED</a>
<a name="ln1299">	smsghdr.msg_control = NULL;</a>
<a name="ln1300">	smsghdr.msg_controllen = 0;</a>
<a name="ln1301">#endif</a>
<a name="ln1302"> </a>
<a name="ln1303">	i = sendmsg(s, &amp;smsghdr, 0);</a>
<a name="ln1304"> </a>
<a name="ln1305">	if (i &lt; 0 || i != cc)  {</a>
<a name="ln1306">		if (i &lt; 0)</a>
<a name="ln1307">			warn(&quot;sendmsg&quot;);</a>
<a name="ln1308">		(void)printf(&quot;ping6: wrote %s %d chars, ret=%d\n&quot;,</a>
<a name="ln1309">		    hostname, cc, i);</a>
<a name="ln1310">	}</a>
<a name="ln1311">	if (!(options &amp; F_QUIET) &amp;&amp; options &amp; F_FLOOD)</a>
<a name="ln1312">		(void)write(STDOUT_FILENO, &amp;DOT, 1);</a>
<a name="ln1313"> </a>
<a name="ln1314">	return(0);</a>
<a name="ln1315">}</a>
<a name="ln1316"> </a>
<a name="ln1317">int</a>
<a name="ln1318">myechoreply(icp)</a>
<a name="ln1319">	const struct icmp6_hdr *icp;</a>
<a name="ln1320">{</a>
<a name="ln1321">	if (ntohs(icp-&gt;icmp6_id) == ident)</a>
<a name="ln1322">		return 1;</a>
<a name="ln1323">	else</a>
<a name="ln1324">		return 0;</a>
<a name="ln1325">}</a>
<a name="ln1326"> </a>
<a name="ln1327">int</a>
<a name="ln1328">mynireply(nip)</a>
<a name="ln1329">	const struct icmp6_nodeinfo *nip;</a>
<a name="ln1330">{</a>
<a name="ln1331">	if (memcmp(nip-&gt;icmp6_ni_nonce + sizeof(u_int16_t),</a>
<a name="ln1332">	    nonce + sizeof(u_int16_t),</a>
<a name="ln1333">	    sizeof(nonce) - sizeof(u_int16_t)) == 0)</a>
<a name="ln1334">		return 1;</a>
<a name="ln1335">	else</a>
<a name="ln1336">		return 0;</a>
<a name="ln1337">}</a>
<a name="ln1338"> </a>
<a name="ln1339">char *</a>
<a name="ln1340">dnsdecode(sp, ep, base, buf, bufsiz)</a>
<a name="ln1341">	const u_char **sp;</a>
<a name="ln1342">	const u_char *ep;</a>
<a name="ln1343">	const u_char *base;	/*base for compressed name*/</a>
<a name="ln1344">	char *buf;</a>
<a name="ln1345">	size_t bufsiz;</a>
<a name="ln1346">{</a>
<a name="ln1347">	int i;</a>
<a name="ln1348">	const u_char *cp;</a>
<a name="ln1349">	char cresult[MAXDNAME + 1];</a>
<a name="ln1350">	const u_char *comp;</a>
<a name="ln1351">	int l;</a>
<a name="ln1352"> </a>
<a name="ln1353">	cp = *sp;</a>
<a name="ln1354">	*buf = '\0';</a>
<a name="ln1355"> </a>
<a name="ln1356">	if (cp &gt;= ep)</a>
<a name="ln1357">		return NULL;</a>
<a name="ln1358">	while (cp &lt; ep) {</a>
<a name="ln1359">		i = *cp;</a>
<a name="ln1360">		if (i == 0 || cp != *sp) {</a>
<a name="ln1361">			if (strlcat((char *)buf, &quot;.&quot;, bufsiz) &gt;= bufsiz)</a>
<a name="ln1362">				return NULL;	/*result overrun*/</a>
<a name="ln1363">		}</a>
<a name="ln1364">		if (i == 0)</a>
<a name="ln1365">			break;</a>
<a name="ln1366">		cp++;</a>
<a name="ln1367"> </a>
<a name="ln1368">		if ((i &amp; 0xc0) == 0xc0 &amp;&amp; cp - base &gt; (i &amp; 0x3f)) {</a>
<a name="ln1369">			/* DNS compression */</a>
<a name="ln1370">			if (!base)</a>
<a name="ln1371">				return NULL;</a>
<a name="ln1372"> </a>
<a name="ln1373">			comp = base + (i &amp; 0x3f);</a>
<a name="ln1374">			if (dnsdecode(&amp;comp, cp, base, cresult,</a>
<a name="ln1375">			    sizeof(cresult)) == NULL)</a>
<a name="ln1376">				return NULL;</a>
<a name="ln1377">			if (strlcat(buf, cresult, bufsiz) &gt;= bufsiz)</a>
<a name="ln1378">				return NULL;	/*result overrun*/</a>
<a name="ln1379">			break;</a>
<a name="ln1380">		} else if ((i &amp; 0x3f) == i) {</a>
<a name="ln1381">			if (i &gt; ep - cp)</a>
<a name="ln1382">				return NULL;	/*source overrun*/</a>
<a name="ln1383">			while (i-- &gt; 0 &amp;&amp; cp &lt; ep) {</a>
<a name="ln1384">				l = snprintf(cresult, sizeof(cresult),</a>
<a name="ln1385">				    isprint(*cp) ? &quot;%c&quot; : &quot;\\%03o&quot;, *cp &amp; 0xff);</a>
<a name="ln1386">				if (l &gt;= sizeof(cresult) || l &lt; 0)</a>
<a name="ln1387">					return NULL;</a>
<a name="ln1388">				if (strlcat(buf, cresult, bufsiz) &gt;= bufsiz)</a>
<a name="ln1389">					return NULL;	/*result overrun*/</a>
<a name="ln1390">				cp++;</a>
<a name="ln1391">			}</a>
<a name="ln1392">		} else</a>
<a name="ln1393">			return NULL;	/*invalid label*/</a>
<a name="ln1394">	}</a>
<a name="ln1395">	if (i != 0)</a>
<a name="ln1396">		return NULL;	/*not terminated*/</a>
<a name="ln1397">	cp++;</a>
<a name="ln1398">	*sp = cp;</a>
<a name="ln1399">	return buf;</a>
<a name="ln1400">}</a>
<a name="ln1401"> </a>
<a name="ln1402">/*</a>
<a name="ln1403"> * pr_pack --</a>
<a name="ln1404"> *	Print out the packet, if it came from us.  This logic is necessary</a>
<a name="ln1405"> * because ALL readers of the ICMP socket get a copy of ALL ICMP packets</a>
<a name="ln1406"> * which arrive ('tis only fair).  This permits multiple copies of this</a>
<a name="ln1407"> * program to be run without having intermingled output (or statistics!).</a>
<a name="ln1408"> */</a>
<a name="ln1409">void</a>
<a name="ln1410">pr_pack(buf, cc, mhdr)</a>
<a name="ln1411">	u_char *buf;</a>
<a name="ln1412">	int cc;</a>
<a name="ln1413">	struct msghdr *mhdr;</a>
<a name="ln1414">{</a>
<a name="ln1415">#define safeputc(c)	printf((isprint((c)) ? &quot;%c&quot; : &quot;\\%03o&quot;), c)</a>
<a name="ln1416">	struct icmp6_hdr *icp;</a>
<a name="ln1417">	struct icmp6_nodeinfo *ni;</a>
<a name="ln1418">	int i;</a>
<a name="ln1419">	int hoplim;</a>
<a name="ln1420">	struct sockaddr *from;</a>
<a name="ln1421">	int fromlen;</a>
<a name="ln1422">	u_char *cp = NULL, *dp, *end = buf + cc;</a>
<a name="ln1423">	struct in6_pktinfo *pktinfo = NULL;</a>
<a name="ln1424">	struct timeval tv, tp;</a>
<a name="ln1425">	struct tv32 *tpp;</a>
<a name="ln1426">	double triptime = 0;</a>
<a name="ln1427">	int dupflag;</a>
<a name="ln1428">	size_t off;</a>
<a name="ln1429">	int oldfqdn;</a>
<a name="ln1430">	u_int16_t seq;</a>
<a name="ln1431">	char dnsname[MAXDNAME + 1];</a>
<a name="ln1432"> </a>
<a name="ln1433">	(void)gettimeofday(&amp;tv, NULL);</a>
<a name="ln1434"> </a>
<a name="ln1435">	if (!mhdr || !mhdr-&gt;msg_name ||</a>
<a name="ln1436">	    mhdr-&gt;msg_namelen != sizeof(struct sockaddr_in6) ||</a>
<a name="ln1437">	    ((struct sockaddr *)mhdr-&gt;msg_name)-&gt;sa_family != AF_INET6) {</a>
<a name="ln1438">		if (options &amp; F_VERBOSE)</a>
<a name="ln1439">			warnx(&quot;invalid peername&quot;);</a>
<a name="ln1440">		return;</a>
<a name="ln1441">	}</a>
<a name="ln1442">	from = (struct sockaddr *)mhdr-&gt;msg_name;</a>
<a name="ln1443">	fromlen = mhdr-&gt;msg_namelen;</a>
<a name="ln1444">	if (cc &lt; sizeof(struct icmp6_hdr)) {</a>
<a name="ln1445">		if (options &amp; F_VERBOSE)</a>
<a name="ln1446">			warnx(&quot;packet too short (%d bytes) from %s&quot;, cc,</a>
<a name="ln1447">			    pr_addr(from, fromlen));</a>
<a name="ln1448">		return;</a>
<a name="ln1449">	}</a>
<a name="ln1450">	if (((mhdr-&gt;msg_flags &amp; MSG_CTRUNC) != 0) &amp;&amp;</a>
<a name="ln1451">	    (options &amp; F_VERBOSE) != 0)</a>
<a name="ln1452">		warnx(&quot;some control data discarded, insufficient buffer size&quot;);</a>
<a name="ln1453">	icp = (struct icmp6_hdr *)buf;</a>
<a name="ln1454">	ni = (struct icmp6_nodeinfo *)buf;</a>
<a name="ln1455">	off = 0;</a>
<a name="ln1456"> </a>
<a name="ln1457">	if ((hoplim = get_hoplim(mhdr)) == -1) {</a>
<a name="ln1458">		warnx(&quot;failed to get receiving hop limit&quot;);</a>
<a name="ln1459">		return;</a>
<a name="ln1460">	}</a>
<a name="ln1461">	if ((pktinfo = get_rcvpktinfo(mhdr)) == NULL) {</a>
<a name="ln1462">		warnx(&quot;failed to get receiving packet information&quot;);</a>
<a name="ln1463">		return;</a>
<a name="ln1464">	}</a>
<a name="ln1465"> </a>
<a name="ln1466">	if (icp-&gt;icmp6_type == ICMP6_ECHO_REPLY &amp;&amp; myechoreply(icp)) {</a>
<a name="ln1467">		seq = ntohs(icp-&gt;icmp6_seq);</a>
<a name="ln1468">		++nreceived;</a>
<a name="ln1469">		if (timing) {</a>
<a name="ln1470">			tpp = (struct tv32 *)(icp + 1);</a>
<a name="ln1471">			tp.tv_sec = ntohl(tpp-&gt;tv32_sec);</a>
<a name="ln1472">			tp.tv_usec = ntohl(tpp-&gt;tv32_usec);</a>
<a name="ln1473">			tvsub(&amp;tv, &amp;tp);</a>
<a name="ln1474">			triptime = ((double)tv.tv_sec) * 1000.0 +</a>
<a name="ln1475">			    ((double)tv.tv_usec) / 1000.0;</a>
<a name="ln1476">			tsum += triptime;</a>
<a name="ln1477">			tsumsq += triptime * triptime;</a>
<a name="ln1478">			if (triptime &lt; tmin)</a>
<a name="ln1479">				tmin = triptime;</a>
<a name="ln1480">			if (triptime &gt; tmax)</a>
<a name="ln1481">				tmax = triptime;</a>
<a name="ln1482">		}</a>
<a name="ln1483"> </a>
<a name="ln1484">		if (TST(seq % mx_dup_ck)) {</a>
<a name="ln1485">			++nrepeats;</a>
<a name="ln1486">			--nreceived;</a>
<a name="ln1487">			dupflag = 1;</a>
<a name="ln1488">		} else {</a>
<a name="ln1489">			SET(seq % mx_dup_ck);</a>
<a name="ln1490">			dupflag = 0;</a>
<a name="ln1491">		}</a>
<a name="ln1492"> </a>
<a name="ln1493">		if (options &amp; F_QUIET)</a>
<a name="ln1494">			return;</a>
<a name="ln1495"> </a>
<a name="ln1496">		if (options &amp; F_FLOOD)</a>
<a name="ln1497">			(void)write(STDOUT_FILENO, &amp;BSPACE, 1);</a>
<a name="ln1498">		else {</a>
<a name="ln1499">			if (options &amp; F_AUDIBLE)</a>
<a name="ln1500">				(void)write(STDOUT_FILENO, &amp;BBELL, 1);</a>
<a name="ln1501">			(void)printf(&quot;%d bytes from %s, icmp_seq=%u&quot;, cc,</a>
<a name="ln1502">			    pr_addr(from, fromlen), seq);</a>
<a name="ln1503">			(void)printf(&quot; hlim=%d&quot;, hoplim);</a>
<a name="ln1504">			if ((options &amp; F_VERBOSE) != 0) {</a>
<a name="ln1505">				struct sockaddr_in6 dstsa;</a>
<a name="ln1506"> </a>
<a name="ln1507">				memset(&amp;dstsa, 0, sizeof(dstsa));</a>
<a name="ln1508">				dstsa.sin6_family = AF_INET6;</a>
<a name="ln1509">				dstsa.sin6_len = sizeof(dstsa);</a>
<a name="ln1510">				dstsa.sin6_scope_id = pktinfo-&gt;ipi6_ifindex;</a>
<a name="ln1511">				dstsa.sin6_addr = pktinfo-&gt;ipi6_addr;</a>
<a name="ln1512">				(void)printf(&quot; dst=%s&quot;,</a>
<a name="ln1513">				    pr_addr((struct sockaddr *)&amp;dstsa,</a>
<a name="ln1514">				    sizeof(dstsa)));</a>
<a name="ln1515">			}</a>
<a name="ln1516">			if (timing)</a>
<a name="ln1517">				(void)printf(&quot; time=%.3f ms&quot;, triptime);</a>
<a name="ln1518">			if (dupflag)</a>
<a name="ln1519">				(void)printf(&quot;(DUP!)&quot;);</a>
<a name="ln1520">			/* check the data */</a>
<a name="ln1521">			cp = buf + off + ICMP6ECHOLEN + ICMP6ECHOTMLEN;</a>
<a name="ln1522">			dp = outpack + ICMP6ECHOLEN + ICMP6ECHOTMLEN;</a>
<a name="ln1523">			for (i = 8; cp &lt; end; ++i, ++cp, ++dp) {</a>
<a name="ln1524">				if (*cp != *dp) {</a>
<a name="ln1525">					(void)printf(&quot;\nwrong data byte #%d should be 0x%x but was 0x%x&quot;, i, *dp, *cp);</a>
<a name="ln1526">					break;</a>
<a name="ln1527">				}</a>
<a name="ln1528">			}</a>
<a name="ln1529">		}</a>
<a name="ln1530">	} else if (icp-&gt;icmp6_type == ICMP6_NI_REPLY &amp;&amp; mynireply(ni)) {</a>
<a name="ln1531">		seq = ntohs(*(u_int16_t *)ni-&gt;icmp6_ni_nonce);</a>
<a name="ln1532">		++nreceived;</a>
<a name="ln1533">		if (TST(seq % mx_dup_ck)) {</a>
<a name="ln1534">			++nrepeats;</a>
<a name="ln1535">			--nreceived;</a>
<a name="ln1536">			dupflag = 1;</a>
<a name="ln1537">		} else {</a>
<a name="ln1538">			SET(seq % mx_dup_ck);</a>
<a name="ln1539">			dupflag = 0;</a>
<a name="ln1540">		}</a>
<a name="ln1541"> </a>
<a name="ln1542">		if (options &amp; F_QUIET)</a>
<a name="ln1543">			return;</a>
<a name="ln1544"> </a>
<a name="ln1545">		(void)printf(&quot;%d bytes from %s: &quot;, cc, pr_addr(from, fromlen));</a>
<a name="ln1546"> </a>
<a name="ln1547">		switch (ntohs(ni-&gt;ni_code)) {</a>
<a name="ln1548">		case ICMP6_NI_SUCCESS:</a>
<a name="ln1549">			break;</a>
<a name="ln1550">		case ICMP6_NI_REFUSED:</a>
<a name="ln1551">			printf(&quot;refused, type 0x%x&quot;, ntohs(ni-&gt;ni_type));</a>
<a name="ln1552">			goto fqdnend;</a>
<a name="ln1553">		case ICMP6_NI_UNKNOWN:</a>
<a name="ln1554">			printf(&quot;unknown, type 0x%x&quot;, ntohs(ni-&gt;ni_type));</a>
<a name="ln1555">			goto fqdnend;</a>
<a name="ln1556">		default:</a>
<a name="ln1557">			printf(&quot;unknown code 0x%x, type 0x%x&quot;,</a>
<a name="ln1558">			    ntohs(ni-&gt;ni_code), ntohs(ni-&gt;ni_type));</a>
<a name="ln1559">			goto fqdnend;</a>
<a name="ln1560">		}</a>
<a name="ln1561"> </a>
<a name="ln1562">		switch (ntohs(ni-&gt;ni_qtype)) {</a>
<a name="ln1563">		case NI_QTYPE_NOOP:</a>
<a name="ln1564">			printf(&quot;NodeInfo NOOP&quot;);</a>
<a name="ln1565">			break;</a>
<a name="ln1566">		case NI_QTYPE_SUPTYPES:</a>
<a name="ln1567">			pr_suptypes(ni, end - (u_char *)ni);</a>
<a name="ln1568">			break;</a>
<a name="ln1569">		case NI_QTYPE_NODEADDR:</a>
<a name="ln1570">			pr_nodeaddr(ni, end - (u_char *)ni);</a>
<a name="ln1571">			break;</a>
<a name="ln1572">		case NI_QTYPE_FQDN:</a>
<a name="ln1573">		default:	/* XXX: for backward compatibility */</a>
<a name="ln1574">			cp = (u_char *)ni + ICMP6_NIRLEN;</a>
<a name="ln1575">			if (buf[off + ICMP6_NIRLEN] ==</a>
<a name="ln1576">			    cc - off - ICMP6_NIRLEN - 1)</a>
<a name="ln1577">				oldfqdn = 1;</a>
<a name="ln1578">			else</a>
<a name="ln1579">				oldfqdn = 0;</a>
<a name="ln1580">			if (oldfqdn) {</a>
<a name="ln1581">				cp++;	/* skip length */</a>
<a name="ln1582">				while (cp &lt; end) {</a>
<a name="ln1583">					safeputc(*cp &amp; 0xff);</a>
<a name="ln1584">					cp++;</a>
<a name="ln1585">				}</a>
<a name="ln1586">			} else {</a>
<a name="ln1587">				i = 0;</a>
<a name="ln1588">				while (cp &lt; end) {</a>
<a name="ln1589">					if (dnsdecode((const u_char **)&amp;cp, end,</a>
<a name="ln1590">					    (const u_char *)(ni + 1), dnsname,</a>
<a name="ln1591">					    sizeof(dnsname)) == NULL) {</a>
<a name="ln1592">						printf(&quot;???&quot;);</a>
<a name="ln1593">						break;</a>
<a name="ln1594">					}</a>
<a name="ln1595">					/*</a>
<a name="ln1596">					 * name-lookup special handling for</a>
<a name="ln1597">					 * truncated name</a>
<a name="ln1598">					 */</a>
<a name="ln1599">					if (cp + 1 &lt;= end &amp;&amp; !*cp &amp;&amp;</a>
<a name="ln1600">					    strlen(dnsname) &gt; 0) {</a>
<a name="ln1601">						dnsname[strlen(dnsname) - 1] = '\0';</a>
<a name="ln1602">						cp++;</a>
<a name="ln1603">					}</a>
<a name="ln1604">					printf(&quot;%s%s&quot;, i &gt; 0 ? &quot;,&quot; : &quot;&quot;,</a>
<a name="ln1605">					    dnsname);</a>
<a name="ln1606">				}</a>
<a name="ln1607">			}</a>
<a name="ln1608">			if (options &amp; F_VERBOSE) {</a>
<a name="ln1609">				int32_t ttl;</a>
<a name="ln1610">				int comma = 0;</a>
<a name="ln1611"> </a>
<a name="ln1612">				(void)printf(&quot; (&quot;);	/*)*/</a>
<a name="ln1613"> </a>
<a name="ln1614">				switch (ni-&gt;ni_code) {</a>
<a name="ln1615">				case ICMP6_NI_REFUSED:</a>
<a name="ln1616">					(void)printf(&quot;refused&quot;);</a>
<a name="ln1617">					comma++;</a>
<a name="ln1618">					break;</a>
<a name="ln1619">				case ICMP6_NI_UNKNOWN:</a>
<a name="ln1620">					(void)printf(&quot;unknown qtype&quot;);</a>
<a name="ln1621">					comma++;</a>
<a name="ln1622">					break;</a>
<a name="ln1623">				}</a>
<a name="ln1624"> </a>
<a name="ln1625">				if ((end - (u_char *)ni) &lt; ICMP6_NIRLEN) {</a>
<a name="ln1626">					/* case of refusion, unknown */</a>
<a name="ln1627">					/*(*/</a>
<a name="ln1628">					putchar(')');</a>
<a name="ln1629">					goto fqdnend;</a>
<a name="ln1630">				}</a>
<a name="ln1631">				ttl = (int32_t)ntohl(*(u_long *)&amp;buf[off+ICMP6ECHOLEN+8]);</a>
<a name="ln1632">				if (comma)</a>
<a name="ln1633">					printf(&quot;,&quot;);</a>
<a name="ln1634">				if (!(ni-&gt;ni_flags &amp; NI_FQDN_FLAG_VALIDTTL)) {</a>
<a name="ln1635">					(void)printf(&quot;TTL=%d:meaningless&quot;,</a>
<a name="ln1636">					    (int)ttl);</a>
<a name="ln1637">				} else {</a>
<a name="ln1638">					if (ttl &lt; 0) {</a>
<a name="ln1639">						(void)printf(&quot;TTL=%d:invalid&quot;,</a>
<a name="ln1640">						   ttl);</a>
<a name="ln1641">					} else</a>
<a name="ln1642">						(void)printf(&quot;TTL=%d&quot;, ttl);</a>
<a name="ln1643">				}</a>
<a name="ln1644">				comma++;</a>
<a name="ln1645"> </a>
<a name="ln1646">				if (oldfqdn) {</a>
<a name="ln1647">					if (comma)</a>
<a name="ln1648">						printf(&quot;,&quot;);</a>
<a name="ln1649">					printf(&quot;03 draft&quot;);</a>
<a name="ln1650">					comma++;</a>
<a name="ln1651">				} else {</a>
<a name="ln1652">					cp = (u_char *)ni + ICMP6_NIRLEN;</a>
<a name="ln1653">					if (cp == end) {</a>
<a name="ln1654">						if (comma)</a>
<a name="ln1655">							printf(&quot;,&quot;);</a>
<a name="ln1656">						printf(&quot;no name&quot;);</a>
<a name="ln1657">						comma++;</a>
<a name="ln1658">					}</a>
<a name="ln1659">				}</a>
<a name="ln1660"> </a>
<a name="ln1661">				if (buf[off + ICMP6_NIRLEN] !=</a>
<a name="ln1662">				    cc - off - ICMP6_NIRLEN - 1 &amp;&amp; oldfqdn) {</a>
<a name="ln1663">					if (comma)</a>
<a name="ln1664">						printf(&quot;,&quot;);</a>
<a name="ln1665">					(void)printf(&quot;invalid namelen:%d/%lu&quot;,</a>
<a name="ln1666">					    buf[off + ICMP6_NIRLEN],</a>
<a name="ln1667">					    (u_long)cc - off - ICMP6_NIRLEN - 1);</a>
<a name="ln1668">					comma++;</a>
<a name="ln1669">				}</a>
<a name="ln1670">				/*(*/</a>
<a name="ln1671">				putchar(')');</a>
<a name="ln1672">			}</a>
<a name="ln1673">		fqdnend:</a>
<a name="ln1674">			;</a>
<a name="ln1675">		}</a>
<a name="ln1676">	} else {</a>
<a name="ln1677">		/* We've got something other than an ECHOREPLY */</a>
<a name="ln1678">		if (!(options &amp; F_VERBOSE))</a>
<a name="ln1679">			return;</a>
<a name="ln1680">		(void)printf(&quot;%d bytes from %s: &quot;, cc, pr_addr(from, fromlen));</a>
<a name="ln1681">		pr_icmph(icp, end);</a>
<a name="ln1682">	}</a>
<a name="ln1683"> </a>
<a name="ln1684">	if (!(options &amp; F_FLOOD)) {</a>
<a name="ln1685">		(void)putchar('\n');</a>
<a name="ln1686">		if (options &amp; F_VERBOSE)</a>
<a name="ln1687">			pr_exthdrs(mhdr);</a>
<a name="ln1688">		(void)fflush(stdout);</a>
<a name="ln1689">	}</a>
<a name="ln1690">#undef safeputc</a>
<a name="ln1691">}</a>
<a name="ln1692"> </a>
<a name="ln1693">void</a>
<a name="ln1694">pr_exthdrs(mhdr)</a>
<a name="ln1695">	struct msghdr *mhdr;</a>
<a name="ln1696">{</a>
<a name="ln1697">	ssize_t	bufsize;</a>
<a name="ln1698">	void	*bufp;</a>
<a name="ln1699">	struct cmsghdr *cm;</a>
<a name="ln1700"> </a>
<a name="ln1701">	bufsize = 0;</a>
<a name="ln1702">	bufp = mhdr-&gt;msg_control;</a>
<a name="ln1703">	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(mhdr); cm;</a>
<a name="ln1704">	     cm = (struct cmsghdr *)CMSG_NXTHDR(mhdr, cm)) {</a>
<a name="ln1705">		if (cm-&gt;cmsg_level != IPPROTO_IPV6)</a>
<a name="ln1706">			continue;</a>
<a name="ln1707"> </a>
<a name="ln1708">		bufsize = CONTROLLEN - ((caddr_t)CMSG_DATA(cm) - (caddr_t)bufp);</a>
<a name="ln1709">		if (bufsize &lt;= 0)</a>
<a name="ln1710">			continue; </a>
<a name="ln1711">		switch (cm-&gt;cmsg_type) {</a>
<a name="ln1712">		case IPV6_HOPOPTS:</a>
<a name="ln1713">			printf(&quot;  HbH Options: &quot;);</a>
<a name="ln1714">			pr_ip6opt(CMSG_DATA(cm), (size_t)bufsize);</a>
<a name="ln1715">			break;</a>
<a name="ln1716">		case IPV6_DSTOPTS:</a>
<a name="ln1717">#ifdef IPV6_RTHDRDSTOPTS</a>
<a name="ln1718">		case IPV6_RTHDRDSTOPTS:</a>
<a name="ln1719">#endif</a>
<a name="ln1720">			printf(&quot;  Dst Options: &quot;);</a>
<a name="ln1721">			pr_ip6opt(CMSG_DATA(cm), (size_t)bufsize);</a>
<a name="ln1722">			break;</a>
<a name="ln1723">		case IPV6_RTHDR:</a>
<a name="ln1724">			printf(&quot;  Routing: &quot;);</a>
<a name="ln1725">			pr_rthdr(CMSG_DATA(cm), (size_t)bufsize);</a>
<a name="ln1726">			break;</a>
<a name="ln1727">		}</a>
<a name="ln1728">	}</a>
<a name="ln1729">}</a>
<a name="ln1730"> </a>
<a name="ln1731">#if defined USE_RFC2292BIS &amp;&amp; defined IPV6_OPTIONS</a>
<a name="ln1732">void</a>
<a name="ln1733">pr_ip6opt(void *extbuf, size_t bufsize)</a>
<a name="ln1734">{</a>
<a name="ln1735">	struct ip6_hbh *ext;</a>
<a name="ln1736">	int currentlen;</a>
<a name="ln1737">	u_int8_t type;</a>
<a name="ln1738">	socklen_t extlen, len, origextlen;</a>
<a name="ln1739">	void *databuf;</a>
<a name="ln1740">	size_t offset;</a>
<a name="ln1741">	u_int16_t value2;</a>
<a name="ln1742">	u_int32_t value4;</a>
<a name="ln1743"> </a>
<a name="ln1744">	ext = (struct ip6_hbh *)extbuf;</a>
<a name="ln1745">	extlen = (ext-&gt;ip6h_len + 1) * 8;</a>
<a name="ln1746">	printf(&quot;nxt %u, len %u (%lu bytes)\n&quot;, ext-&gt;ip6h_nxt,</a>
<a name="ln1747">	    (unsigned int)ext-&gt;ip6h_len, (unsigned long)extlen);</a>
<a name="ln1748"> </a>
<a name="ln1749">	/*</a>
<a name="ln1750">	 * Bounds checking on the ancillary data buffer:</a>
<a name="ln1751">	 *     subtract the size of a cmsg structure from the buffer size.</a>
<a name="ln1752">	 */</a>
<a name="ln1753">	if (bufsize &lt; (extlen  + CMSG_SPACE(0))) {</a>
<a name="ln1754">		origextlen = extlen;</a>
<a name="ln1755">		extlen = bufsize - CMSG_SPACE(0);</a>
<a name="ln1756">		warnx(&quot;options truncated, showing only %u (total=%u)&quot;,</a>
<a name="ln1757">		    (unsigned int)(extlen / 8 - 1),</a>
<a name="ln1758">		    (unsigned int)(ext-&gt;ip6h_len));</a>
<a name="ln1759">	}</a>
<a name="ln1760"> </a>
<a name="ln1761">	currentlen = 0;</a>
<a name="ln1762">	while (1) {</a>
<a name="ln1763">		currentlen = inet6_opt_next(extbuf, extlen, currentlen,</a>
<a name="ln1764">		    &amp;type, &amp;len, &amp;databuf);</a>
<a name="ln1765">		if (currentlen == -1)</a>
<a name="ln1766">			break;</a>
<a name="ln1767">		switch (type) {</a>
<a name="ln1768">		/*</a>
<a name="ln1769">		 * Note that inet6_opt_next automatically skips any padding</a>
<a name="ln1770">		 * optins.</a>
<a name="ln1771">		 */</a>
<a name="ln1772">		case IP6OPT_JUMBO:</a>
<a name="ln1773">			offset = 0;</a>
<a name="ln1774">			offset = inet6_opt_get_val(databuf, offset,</a>
<a name="ln1775">			    &amp;value4, sizeof(value4));</a>
<a name="ln1776">			printf(&quot;    Jumbo Payload Opt: Length %u\n&quot;,</a>
<a name="ln1777">			    (u_int32_t)ntohl(value4));</a>
<a name="ln1778">			break;</a>
<a name="ln1779">		case IP6OPT_ROUTER_ALERT:</a>
<a name="ln1780">			offset = 0;</a>
<a name="ln1781">			offset = inet6_opt_get_val(databuf, offset,</a>
<a name="ln1782">						   &amp;value2, sizeof(value2));</a>
<a name="ln1783">			printf(&quot;    Router Alert Opt: Type %u\n&quot;,</a>
<a name="ln1784">			    ntohs(value2));</a>
<a name="ln1785">			break;</a>
<a name="ln1786">		default:</a>
<a name="ln1787">			printf(&quot;    Received Opt %u len %lu\n&quot;,</a>
<a name="ln1788">			    type, (unsigned long)len);</a>
<a name="ln1789">			break;</a>
<a name="ln1790">		}</a>
<a name="ln1791">	}</a>
<a name="ln1792">	return;</a>
<a name="ln1793">}</a>
<a name="ln1794">#else  /* !USE_RFC2292BIS */</a>
<a name="ln1795">/* ARGSUSED */</a>
<a name="ln1796">void</a>
<a name="ln1797">pr_ip6opt(void *extbuf, size_t bufsize)</a>
<a name="ln1798">{</a>
<a name="ln1799">	(void)extbuf;</a>
<a name="ln1800">	(void)bufsize;</a>
<a name="ln1801">	putchar('\n');</a>
<a name="ln1802">	return;</a>
<a name="ln1803">}</a>
<a name="ln1804">#endif /* USE_RFC2292BIS */</a>
<a name="ln1805"> </a>
<a name="ln1806">#if defined USE_RFC2292BIS &amp;&amp; defined IPV6_OPTIONS</a>
<a name="ln1807">void</a>
<a name="ln1808">pr_rthdr(void *extbuf, size_t bufsize)</a>
<a name="ln1809">{</a>
<a name="ln1810">	struct in6_addr *in6;</a>
<a name="ln1811">	char ntopbuf[INET6_ADDRSTRLEN];</a>
<a name="ln1812">	struct ip6_rthdr *rh = (struct ip6_rthdr *)extbuf;</a>
<a name="ln1813">	int i, segments, origsegs, rthsize, size0, size1;</a>
<a name="ln1814"> </a>
<a name="ln1815">	/* print fixed part of the header */</a>
<a name="ln1816">	printf(&quot;nxt %u, len %u (%d bytes), type %u, &quot;, rh-&gt;ip6r_nxt,</a>
<a name="ln1817">	    rh-&gt;ip6r_len, (rh-&gt;ip6r_len + 1) &lt;&lt; 3, rh-&gt;ip6r_type);</a>
<a name="ln1818">	if ((segments = inet6_rth_segments(extbuf)) &gt;= 0) {</a>
<a name="ln1819">		printf(&quot;%d segments, &quot;, segments);</a>
<a name="ln1820">		printf(&quot;%d left\n&quot;, rh-&gt;ip6r_segleft);</a>
<a name="ln1821">	} else {</a>
<a name="ln1822">		printf(&quot;segments unknown, &quot;);</a>
<a name="ln1823">		printf(&quot;%d left\n&quot;, rh-&gt;ip6r_segleft);</a>
<a name="ln1824">		return;</a>
<a name="ln1825">	}</a>
<a name="ln1826"> </a>
<a name="ln1827">	/*</a>
<a name="ln1828">	 * Bounds checking on the ancillary data buffer. When calculating</a>
<a name="ln1829">	 * the number of items to show keep in mind:</a>
<a name="ln1830">	 *	- The size of the cmsg structure</a>
<a name="ln1831">	 *	- The size of one segment (the size of a Type 0 routing header)</a>
<a name="ln1832">	 *	- When dividing add a fudge factor of one in case the</a>
<a name="ln1833">	 *	  dividend is not evenly divisible by the divisor</a>
<a name="ln1834">	 */</a>
<a name="ln1835">	rthsize = (rh-&gt;ip6r_len + 1) * 8;</a>
<a name="ln1836">	if (bufsize &lt; (rthsize + CMSG_SPACE(0))) {</a>
<a name="ln1837">		origsegs = segments;</a>
<a name="ln1838">		size0 = inet6_rth_space(IPV6_RTHDR_TYPE_0, 0);</a>
<a name="ln1839">		size1 = inet6_rth_space(IPV6_RTHDR_TYPE_0, 1);</a>
<a name="ln1840">		segments -= (rthsize - (bufsize - CMSG_SPACE(0))) /</a>
<a name="ln1841">		    (size1 - size0) + 1;</a>
<a name="ln1842">		warnx(&quot;segments truncated, showing only %d (total=%d)&quot;,</a>
<a name="ln1843">		    segments, origsegs);</a>
<a name="ln1844">	}</a>
<a name="ln1845"> </a>
<a name="ln1846">	for (i = 0; i &lt; segments; i++) {</a>
<a name="ln1847">		in6 = inet6_rth_getaddr(extbuf, i);</a>
<a name="ln1848">		if (in6 == NULL)</a>
<a name="ln1849">			printf(&quot;   [%d]&lt;NULL&gt;\n&quot;, i);</a>
<a name="ln1850">		else {</a>
<a name="ln1851">			if (!inet_ntop(AF_INET6, in6, ntopbuf,</a>
<a name="ln1852">			    sizeof(ntopbuf)))</a>
<a name="ln1853">				strlcpy(ntopbuf, &quot;?&quot;, sizeof(ntopbuf));</a>
<a name="ln1854">			printf(&quot;   [%d]%s\n&quot;, i, ntopbuf);</a>
<a name="ln1855">		}</a>
<a name="ln1856">	}</a>
<a name="ln1857"> </a>
<a name="ln1858">	return;</a>
<a name="ln1859"> </a>
<a name="ln1860">}</a>
<a name="ln1861"> </a>
<a name="ln1862">#else  /* !USE_RFC2292BIS */</a>
<a name="ln1863">/* ARGSUSED */</a>
<a name="ln1864">void</a>
<a name="ln1865">pr_rthdr(void *extbuf, size_t bufsize)</a>
<a name="ln1866">{</a>
<a name="ln1867">	(void)extbuf;</a>
<a name="ln1868">	(void)bufsize;</a>
<a name="ln1869">	putchar('\n');</a>
<a name="ln1870">	return;</a>
<a name="ln1871">}</a>
<a name="ln1872">#endif /* USE_RFC2292BIS */</a>
<a name="ln1873"> </a>
<a name="ln1874">int</a>
<a name="ln1875">pr_bitrange(v, soff, ii)</a>
<a name="ln1876">	u_int32_t v;</a>
<a name="ln1877">	int soff;</a>
<a name="ln1878">	int ii;</a>
<a name="ln1879">{</a>
<a name="ln1880">	int off;</a>
<a name="ln1881">	int i;</a>
<a name="ln1882"> </a>
<a name="ln1883">	off = 0;</a>
<a name="ln1884">	while (off &lt; 32) {</a>
<a name="ln1885">		/* shift till we have 0x01 */</a>
<a name="ln1886">		if ((v &amp; 0x01) == 0) {</a>
<a name="ln1887">			if (ii &gt; 1)</a>
<a name="ln1888">				printf(&quot;-%u&quot;, soff + off - 1);</a>
<a name="ln1889">			ii = 0;</a>
<a name="ln1890">			switch (v &amp; 0x0f) {</a>
<a name="ln1891">			case 0x00:</a>
<a name="ln1892">				v &gt;&gt;= 4;</a>
<a name="ln1893">				off += 4;</a>
<a name="ln1894">				continue;</a>
<a name="ln1895">			case 0x08:</a>
<a name="ln1896">				v &gt;&gt;= 3;</a>
<a name="ln1897">				off += 3;</a>
<a name="ln1898">				continue;</a>
<a name="ln1899">			case 0x04: case 0x0c:</a>
<a name="ln1900">				v &gt;&gt;= 2;</a>
<a name="ln1901">				off += 2;</a>
<a name="ln1902">				continue;</a>
<a name="ln1903">			default:</a>
<a name="ln1904">				v &gt;&gt;= 1;</a>
<a name="ln1905">				off += 1;</a>
<a name="ln1906">				continue;</a>
<a name="ln1907">			}</a>
<a name="ln1908">		}</a>
<a name="ln1909"> </a>
<a name="ln1910">		/* we have 0x01 with us */</a>
<a name="ln1911">		for (i = 0; i &lt; 32 - off; i++) {</a>
<a name="ln1912">			if ((v &amp; (0x01 &lt;&lt; i)) == 0)</a>
<a name="ln1913">				break;</a>
<a name="ln1914">		}</a>
<a name="ln1915">		if (!ii)</a>
<a name="ln1916">			printf(&quot; %u&quot;, soff + off);</a>
<a name="ln1917">		ii += i;</a>
<a name="ln1918">		v &gt;&gt;= i; off += i;</a>
<a name="ln1919">	}</a>
<a name="ln1920">	return ii;</a>
<a name="ln1921">}</a>
<a name="ln1922"> </a>
<a name="ln1923">void</a>
<a name="ln1924">pr_suptypes(ni, nilen)</a>
<a name="ln1925">	struct icmp6_nodeinfo *ni; /* ni-&gt;qtype must be SUPTYPES */</a>
<a name="ln1926">	size_t nilen;</a>
<a name="ln1927">{</a>
<a name="ln1928">	size_t clen;</a>
<a name="ln1929">	u_int32_t v;</a>
<a name="ln1930">	const u_char *cp, *end;</a>
<a name="ln1931">	u_int16_t cur;</a>
<a name="ln1932">	struct cbit {</a>
<a name="ln1933">		u_int16_t words;	/*32bit count*/</a>
<a name="ln1934">		u_int16_t skip;</a>
<a name="ln1935">	} cbit;</a>
<a name="ln1936">#define MAXQTYPES	(1 &lt;&lt; 16)</a>
<a name="ln1937">	size_t off;</a>
<a name="ln1938">	int b;</a>
<a name="ln1939"> </a>
<a name="ln1940">	cp = (u_char *)(ni + 1);</a>
<a name="ln1941">	end = ((u_char *)ni) + nilen;</a>
<a name="ln1942">	cur = 0;</a>
<a name="ln1943">	b = 0;</a>
<a name="ln1944"> </a>
<a name="ln1945">	printf(&quot;NodeInfo Supported Qtypes&quot;);</a>
<a name="ln1946">	if (options &amp; F_VERBOSE) {</a>
<a name="ln1947">		if (ni-&gt;ni_flags &amp; NI_SUPTYPE_FLAG_COMPRESS)</a>
<a name="ln1948">			printf(&quot;, compressed bitmap&quot;);</a>
<a name="ln1949">		else</a>
<a name="ln1950">			printf(&quot;, raw bitmap&quot;);</a>
<a name="ln1951">	}</a>
<a name="ln1952"> </a>
<a name="ln1953">	while (cp &lt; end) {</a>
<a name="ln1954">		clen = (size_t)(end - cp);</a>
<a name="ln1955">		if ((ni-&gt;ni_flags &amp; NI_SUPTYPE_FLAG_COMPRESS) == 0) {</a>
<a name="ln1956">			if (clen == 0 || clen &gt; MAXQTYPES / 8 ||</a>
<a name="ln1957">			    clen % sizeof(v)) {</a>
<a name="ln1958">				printf(&quot;???&quot;);</a>
<a name="ln1959">				return;</a>
<a name="ln1960">			}</a>
<a name="ln1961">		} else {</a>
<a name="ln1962">			if (clen &lt; sizeof(cbit) || clen % sizeof(v))</a>
<a name="ln1963">				return;</a>
<a name="ln1964">			memcpy(&amp;cbit, cp, sizeof(cbit));</a>
<a name="ln1965">			if (sizeof(cbit) + ntohs(cbit.words) * sizeof(v) &gt;</a>
<a name="ln1966">			    clen)</a>
<a name="ln1967">				return;</a>
<a name="ln1968">			cp += sizeof(cbit);</a>
<a name="ln1969">			clen = ntohs(cbit.words) * sizeof(v);</a>
<a name="ln1970">			if (cur + clen * 8 + (u_long)ntohs(cbit.skip) * 32 &gt;</a>
<a name="ln1971">			    MAXQTYPES)</a>
<a name="ln1972">				return;</a>
<a name="ln1973">		}</a>
<a name="ln1974"> </a>
<a name="ln1975">		for (off = 0; off &lt; clen; off += sizeof(v)) {</a>
<a name="ln1976">			memcpy(&amp;v, cp + off, sizeof(v));</a>
<a name="ln1977">			v = (u_int32_t)ntohl(v);</a>
<a name="ln1978">			b = pr_bitrange(v, (int)(cur + off * 8), b);</a>
<a name="ln1979">		}</a>
<a name="ln1980">		/* flush the remaining bits */</a>
<a name="ln1981">		b = pr_bitrange(0, (int)(cur + off * 8), b);</a>
<a name="ln1982"> </a>
<a name="ln1983">		cp += clen;</a>
<a name="ln1984">		cur += clen * 8;</a>
<a name="ln1985">		if ((ni-&gt;ni_flags &amp; NI_SUPTYPE_FLAG_COMPRESS) != 0)</a>
<a name="ln1986">			cur += ntohs(cbit.skip) * 32;</a>
<a name="ln1987">	}</a>
<a name="ln1988">}</a>
<a name="ln1989"> </a>
<a name="ln1990">void</a>
<a name="ln1991">pr_nodeaddr(ni, nilen)</a>
<a name="ln1992">	struct icmp6_nodeinfo *ni; /* ni-&gt;qtype must be NODEADDR */</a>
<a name="ln1993">	int nilen;</a>
<a name="ln1994">{</a>
<a name="ln1995">	u_char *cp = (u_char *)(ni + 1);</a>
<a name="ln1996">	char ntop_buf[INET6_ADDRSTRLEN];</a>
<a name="ln1997">	int withttl = 0;</a>
<a name="ln1998"> </a>
<a name="ln1999">	nilen -= sizeof(struct icmp6_nodeinfo);</a>
<a name="ln2000"> </a>
<a name="ln2001">	if (options &amp; F_VERBOSE) {</a>
<a name="ln2002">		switch (ni-&gt;ni_code) {</a>
<a name="ln2003">		case ICMP6_NI_REFUSED:</a>
<a name="ln2004">			(void)printf(&quot;refused&quot;);</a>
<a name="ln2005">			break;</a>
<a name="ln2006">		case ICMP6_NI_UNKNOWN:</a>
<a name="ln2007">			(void)printf(&quot;unknown qtype&quot;);</a>
<a name="ln2008">			break;</a>
<a name="ln2009">		}</a>
<a name="ln2010">		if (ni-&gt;ni_flags &amp; NI_NODEADDR_FLAG_TRUNCATE)</a>
<a name="ln2011">			(void)printf(&quot; truncated&quot;);</a>
<a name="ln2012">	}</a>
<a name="ln2013">	putchar('\n');</a>
<a name="ln2014">	if (nilen &lt;= 0)</a>
<a name="ln2015">		printf(&quot;  no address\n&quot;);</a>
<a name="ln2016"> </a>
<a name="ln2017">	/*</a>
<a name="ln2018">	 * In icmp-name-lookups 05 and later, TTL of each returned address</a>
<a name="ln2019">	 * is contained in the resposne. We try to detect the version</a>
<a name="ln2020">	 * by the length of the data, but note that the detection algorithm</a>
<a name="ln2021">	 * is incomplete. We assume the latest draft by default.</a>
<a name="ln2022">	 */</a>
<a name="ln2023">	if (nilen % (sizeof(u_int32_t) + sizeof(struct in6_addr)) == 0)</a>
<a name="ln2024">		withttl = 1;</a>
<a name="ln2025">	while (nilen &gt; 0) {</a>
<a name="ln2026">		u_int32_t ttl;</a>
<a name="ln2027"> </a>
<a name="ln2028">		if (withttl) {</a>
<a name="ln2029">			/* XXX: alignment? */</a>
<a name="ln2030">			ttl = (u_int32_t)ntohl(*(u_int32_t *)cp);</a>
<a name="ln2031">			cp += sizeof(u_int32_t);</a>
<a name="ln2032">			nilen -= sizeof(u_int32_t);</a>
<a name="ln2033">		}</a>
<a name="ln2034"> </a>
<a name="ln2035">		if (inet_ntop(AF_INET6, cp, ntop_buf, sizeof(ntop_buf)) ==</a>
<a name="ln2036">		    NULL)</a>
<a name="ln2037">			strlcpy(ntop_buf, &quot;?&quot;, sizeof(ntop_buf));</a>
<a name="ln2038">		printf(&quot;  %s&quot;, ntop_buf);</a>
<a name="ln2039">		if (withttl) {</a>
<a name="ln2040">			if (ttl == 0xffffffff) {</a>
<a name="ln2041">				/*</a>
<a name="ln2042">				 * XXX: can this convention be applied to all</a>
<a name="ln2043">				 * type of TTL (i.e. non-ND TTL)?</a>
<a name="ln2044">				 */</a>
<a name="ln2045">				printf(&quot;(TTL=infty)&quot;);</a>
<a name="ln2046">			}</a>
<a name="ln2047">			else</a>
<a name="ln2048">				printf(&quot;(TTL=%u)&quot;, ttl);</a>
<a name="ln2049">		}</a>
<a name="ln2050">		putchar('\n');</a>
<a name="ln2051"> </a>
<a name="ln2052">		nilen -= sizeof(struct in6_addr);</a>
<a name="ln2053">		cp += sizeof(struct in6_addr);</a>
<a name="ln2054">	}</a>
<a name="ln2055">}</a>
<a name="ln2056"> </a>
<a name="ln2057">int</a>
<a name="ln2058">get_hoplim(mhdr)</a>
<a name="ln2059">	struct msghdr *mhdr;</a>
<a name="ln2060">{</a>
<a name="ln2061">	struct cmsghdr *cm;</a>
<a name="ln2062"> </a>
<a name="ln2063">	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(mhdr); cm;</a>
<a name="ln2064">	     cm = (struct cmsghdr *)CMSG_NXTHDR(mhdr, cm)) {</a>
<a name="ln2065">		if (cm-&gt;cmsg_len == 0)</a>
<a name="ln2066">			return(-1);</a>
<a name="ln2067"> </a>
<a name="ln2068">		if (cm-&gt;cmsg_level == IPPROTO_IPV6 &amp;&amp;</a>
<a name="ln2069">		    cm-&gt;cmsg_type == IPV6_HOPLIMIT &amp;&amp;</a>
<a name="ln2070">		    cm-&gt;cmsg_len == CMSG_LEN(sizeof(int)))</a>
<a name="ln2071">			return(*(int *)CMSG_DATA(cm));</a>
<a name="ln2072">	}</a>
<a name="ln2073"> </a>
<a name="ln2074">	return(-1);</a>
<a name="ln2075">}</a>
<a name="ln2076"> </a>
<a name="ln2077">struct in6_pktinfo *</a>
<a name="ln2078">get_rcvpktinfo(mhdr)</a>
<a name="ln2079">	struct msghdr *mhdr;</a>
<a name="ln2080">{</a>
<a name="ln2081">	struct cmsghdr *cm;</a>
<a name="ln2082"> </a>
<a name="ln2083">	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(mhdr); cm;</a>
<a name="ln2084">	     cm = (struct cmsghdr *)CMSG_NXTHDR(mhdr, cm)) {</a>
<a name="ln2085">		if (cm-&gt;cmsg_len == 0)</a>
<a name="ln2086">			return(NULL);</a>
<a name="ln2087"> </a>
<a name="ln2088">		if (cm-&gt;cmsg_level == IPPROTO_IPV6 &amp;&amp;</a>
<a name="ln2089">		    cm-&gt;cmsg_type == IPV6_PKTINFO &amp;&amp;</a>
<a name="ln2090">		    cm-&gt;cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo)))</a>
<a name="ln2091">			return((struct in6_pktinfo *)CMSG_DATA(cm));</a>
<a name="ln2092">	}</a>
<a name="ln2093"> </a>
<a name="ln2094">	return(NULL);</a>
<a name="ln2095">}</a>
<a name="ln2096"> </a>
<a name="ln2097">int</a>
<a name="ln2098">get_pathmtu(mhdr)</a>
<a name="ln2099">	struct msghdr *mhdr;</a>
<a name="ln2100">{</a>
<a name="ln2101">#ifdef IPV6_RECVPATHMTU</a>
<a name="ln2102">	struct cmsghdr *cm;</a>
<a name="ln2103">	struct ip6_mtuinfo *mtuctl = NULL;</a>
<a name="ln2104"> </a>
<a name="ln2105">	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(mhdr); cm;</a>
<a name="ln2106">	     cm = (struct cmsghdr *)CMSG_NXTHDR(mhdr, cm)) {</a>
<a name="ln2107">		if (cm-&gt;cmsg_len == 0)</a>
<a name="ln2108">			return(0);</a>
<a name="ln2109"> </a>
<a name="ln2110">		if (cm-&gt;cmsg_level == IPPROTO_IPV6 &amp;&amp;</a>
<a name="ln2111">		    cm-&gt;cmsg_type == IPV6_PATHMTU &amp;&amp;</a>
<a name="ln2112">		    cm-&gt;cmsg_len == CMSG_LEN(sizeof(struct ip6_mtuinfo))) {</a>
<a name="ln2113">			mtuctl = (struct ip6_mtuinfo *)CMSG_DATA(cm);</a>
<a name="ln2114"> </a>
<a name="ln2115">			/*</a>
<a name="ln2116">			 * If the notified destination is different from</a>
<a name="ln2117">			 * the one we are pinging, just ignore the info.</a>
<a name="ln2118">			 * We check the scope ID only when both notified value</a>
<a name="ln2119">			 * and our own value have non-0 values, because we may</a>
<a name="ln2120">			 * have used the default scope zone ID for sending,</a>
<a name="ln2121">			 * in which case the scope ID value is 0.</a>
<a name="ln2122">			 */</a>
<a name="ln2123">			if (!IN6_ARE_ADDR_EQUAL(&amp;mtuctl-&gt;ip6m_addr.sin6_addr,</a>
<a name="ln2124">						&amp;dst.sin6_addr) ||</a>
<a name="ln2125">			    (mtuctl-&gt;ip6m_addr.sin6_scope_id &amp;&amp;</a>
<a name="ln2126">			     dst.sin6_scope_id &amp;&amp;</a>
<a name="ln2127">			     mtuctl-&gt;ip6m_addr.sin6_scope_id !=</a>
<a name="ln2128">			     dst.sin6_scope_id)) {</a>
<a name="ln2129">				if ((options &amp; F_VERBOSE) != 0) {</a>
<a name="ln2130">					printf(&quot;path MTU for %s is notified. &quot;</a>
<a name="ln2131">					       &quot;(ignored)\n&quot;,</a>
<a name="ln2132">					   pr_addr((struct sockaddr *)&amp;mtuctl-&gt;ip6m_addr,</a>
<a name="ln2133">					   sizeof(mtuctl-&gt;ip6m_addr)));</a>
<a name="ln2134">				}</a>
<a name="ln2135">				return(0);</a>
<a name="ln2136">			}</a>
<a name="ln2137"> </a>
<a name="ln2138">			/*</a>
<a name="ln2139">			 * Ignore an invalid MTU. XXX: can we just believe</a>
<a name="ln2140">			 * the kernel check?</a>
<a name="ln2141">			 */</a>
<a name="ln2142">			if (mtuctl-&gt;ip6m_mtu &lt; IPV6_MMTU)</a>
<a name="ln2143">				return(0);</a>
<a name="ln2144"> </a>
<a name="ln2145">			/* notification for our destination. return the MTU. */</a>
<a name="ln2146">			return((int)mtuctl-&gt;ip6m_mtu);</a>
<a name="ln2147">		}</a>
<a name="ln2148">	}</a>
<a name="ln2149">#endif</a>
<a name="ln2150">	return(0);</a>
<a name="ln2151">}</a>
<a name="ln2152"> </a>
<a name="ln2153">/*</a>
<a name="ln2154"> * tvsub --</a>
<a name="ln2155"> *	Subtract 2 timeval structs:  out = out - in.  Out is assumed to</a>
<a name="ln2156"> * be &gt;= in.</a>
<a name="ln2157"> */</a>
<a name="ln2158">void</a>
<a name="ln2159">tvsub(out, in)</a>
<a name="ln2160">	struct timeval *out, *in;</a>
<a name="ln2161">{</a>
<a name="ln2162">	if ((out-&gt;tv_usec -= in-&gt;tv_usec) &lt; 0) {</a>
<a name="ln2163">		--out-&gt;tv_sec;</a>
<a name="ln2164">		out-&gt;tv_usec += 1000000;</a>
<a name="ln2165">	}</a>
<a name="ln2166">	out-&gt;tv_sec -= in-&gt;tv_sec;</a>
<a name="ln2167">}</a>
<a name="ln2168"> </a>
<a name="ln2169">/*</a>
<a name="ln2170"> * onint --</a>
<a name="ln2171"> *	SIGINT handler.</a>
<a name="ln2172"> */</a>
<a name="ln2173">/* ARGSUSED */</a>
<a name="ln2174">void</a>
<a name="ln2175">onint(notused)</a>
<a name="ln2176">	int notused;</a>
<a name="ln2177">{</a>
<a name="ln2178">	summary();</a>
<a name="ln2179"> </a>
<a name="ln2180">	(void)signal(SIGINT, SIG_DFL);</a>
<a name="ln2181">	(void)kill(getpid(), SIGINT);</a>
<a name="ln2182"> </a>
<a name="ln2183">	/* NOTREACHED */</a>
<a name="ln2184">	exit(1);</a>
<a name="ln2185">}</a>
<a name="ln2186"> </a>
<a name="ln2187">/*</a>
<a name="ln2188"> * summary --</a>
<a name="ln2189"> *	Print out statistics.</a>
<a name="ln2190"> */</a>
<a name="ln2191">void</a>
<a name="ln2192">summary()</a>
<a name="ln2193">{</a>
<a name="ln2194">	(void)printf(&quot;\n--- %s ping6 statistics ---\n&quot;, hostname);</a>
<a name="ln2195">	(void)printf(&quot;%ld packets transmitted, &quot;, ntransmitted);</a>
<a name="ln2196">	(void)printf(&quot;%ld packets received, &quot;, nreceived);</a>
<a name="ln2197">	if (nrepeats)</a>
<a name="ln2198">		(void)printf(&quot;+%ld duplicates, &quot;, nrepeats);</a>
<a name="ln2199">	if (ntransmitted) {</a>
<a name="ln2200">		if (nreceived &gt; ntransmitted)</a>
<a name="ln2201">			(void)printf(&quot;-- somebody's duplicating packets!&quot;);</a>
<a name="ln2202">		else</a>
<a name="ln2203">			(void)printf(&quot;%.1f%% packet loss&quot;,</a>
<a name="ln2204">			    ((((double)ntransmitted - nreceived) * 100.0) /</a>
<a name="ln2205">			    ntransmitted));</a>
<a name="ln2206">	}</a>
<a name="ln2207">	(void)putchar('\n');</a>
<a name="ln2208">	if (nreceived &amp;&amp; timing) {</a>
<a name="ln2209">		/* Only display average to microseconds */</a>
<a name="ln2210">		double num = nreceived + nrepeats;</a>
<a name="ln2211">		double avg = tsum / num;</a>
<a name="ln2212">		double dev = sqrt(tsumsq / num - avg * avg);</a>
<a name="ln2213">		(void)printf(</a>
<a name="ln2214">		    &quot;round-trip min/avg/max/std-dev = %.3f/%.3f/%.3f/%.3f ms\n&quot;,</a>
<a name="ln2215">		    tmin, avg, tmax, dev);</a>
<a name="ln2216">		(void)fflush(stdout);</a>
<a name="ln2217">	}</a>
<a name="ln2218">	(void)fflush(stdout);</a>
<a name="ln2219">}</a>
<a name="ln2220"> </a>
<a name="ln2221">/*subject type*/</a>
<a name="ln2222">static const char *niqcode[] = {</a>
<a name="ln2223">	&quot;IPv6 address&quot;,</a>
<a name="ln2224">	&quot;DNS label&quot;,	/*or empty*/</a>
<a name="ln2225">	&quot;IPv4 address&quot;,</a>
<a name="ln2226">};</a>
<a name="ln2227"> </a>
<a name="ln2228">/*result code*/</a>
<a name="ln2229">static const char *nircode[] = {</a>
<a name="ln2230">	&quot;Success&quot;, &quot;Refused&quot;, &quot;Unknown&quot;,</a>
<a name="ln2231">};</a>
<a name="ln2232"> </a>
<a name="ln2233"> </a>
<a name="ln2234">/*</a>
<a name="ln2235"> * pr_icmph --</a>
<a name="ln2236"> *	Print a descriptive string about an ICMP header.</a>
<a name="ln2237"> */</a>
<a name="ln2238">void</a>
<a name="ln2239">pr_icmph(icp, end)</a>
<a name="ln2240">	struct icmp6_hdr *icp;</a>
<a name="ln2241">	u_char *end;</a>
<a name="ln2242">{</a>
<a name="ln2243">	char ntop_buf[INET6_ADDRSTRLEN];</a>
<a name="ln2244">	struct nd_redirect *red;</a>
<a name="ln2245">	struct icmp6_nodeinfo *ni;</a>
<a name="ln2246">	char dnsname[MAXDNAME + 1];</a>
<a name="ln2247">	const u_char *cp;</a>
<a name="ln2248">	size_t l;</a>
<a name="ln2249"> </a>
<a name="ln2250">	switch (icp-&gt;icmp6_type) {</a>
<a name="ln2251">	case ICMP6_DST_UNREACH:</a>
<a name="ln2252">		switch (icp-&gt;icmp6_code) {</a>
<a name="ln2253">		case ICMP6_DST_UNREACH_NOROUTE:</a>
<a name="ln2254">			(void)printf(&quot;No Route to Destination\n&quot;);</a>
<a name="ln2255">			break;</a>
<a name="ln2256">		case ICMP6_DST_UNREACH_ADMIN:</a>
<a name="ln2257">			(void)printf(&quot;Destination Administratively &quot;</a>
<a name="ln2258">			    &quot;Unreachable\n&quot;);</a>
<a name="ln2259">			break;</a>
<a name="ln2260">		case ICMP6_DST_UNREACH_BEYONDSCOPE:</a>
<a name="ln2261">			(void)printf(&quot;Destination Unreachable Beyond Scope\n&quot;);</a>
<a name="ln2262">			break;</a>
<a name="ln2263">		case ICMP6_DST_UNREACH_ADDR:</a>
<a name="ln2264">			(void)printf(&quot;Destination Host Unreachable\n&quot;);</a>
<a name="ln2265">			break;</a>
<a name="ln2266">		case ICMP6_DST_UNREACH_NOPORT:</a>
<a name="ln2267">			(void)printf(&quot;Destination Port Unreachable\n&quot;);</a>
<a name="ln2268">			break;</a>
<a name="ln2269">		default:</a>
<a name="ln2270">			(void)printf(&quot;Destination Unreachable, Bad Code: %d\n&quot;,</a>
<a name="ln2271">			    icp-&gt;icmp6_code);</a>
<a name="ln2272">			break;</a>
<a name="ln2273">		}</a>
<a name="ln2274">		/* Print returned IP header information */</a>
<a name="ln2275">		pr_retip((struct ip6_hdr *)(icp + 1), end);</a>
<a name="ln2276">		break;</a>
<a name="ln2277">	case ICMP6_PACKET_TOO_BIG:</a>
<a name="ln2278">		(void)printf(&quot;Packet too big mtu = %d\n&quot;,</a>
<a name="ln2279">		    (int)ntohl(icp-&gt;icmp6_mtu));</a>
<a name="ln2280">		pr_retip((struct ip6_hdr *)(icp + 1), end);</a>
<a name="ln2281">		break;</a>
<a name="ln2282">	case ICMP6_TIME_EXCEEDED:</a>
<a name="ln2283">		switch (icp-&gt;icmp6_code) {</a>
<a name="ln2284">		case ICMP6_TIME_EXCEED_TRANSIT:</a>
<a name="ln2285">			(void)printf(&quot;Time to live exceeded\n&quot;);</a>
<a name="ln2286">			break;</a>
<a name="ln2287">		case ICMP6_TIME_EXCEED_REASSEMBLY:</a>
<a name="ln2288">			(void)printf(&quot;Frag reassembly time exceeded\n&quot;);</a>
<a name="ln2289">			break;</a>
<a name="ln2290">		default:</a>
<a name="ln2291">			(void)printf(&quot;Time exceeded, Bad Code: %d\n&quot;,</a>
<a name="ln2292">			    icp-&gt;icmp6_code);</a>
<a name="ln2293">			break;</a>
<a name="ln2294">		}</a>
<a name="ln2295">		pr_retip((struct ip6_hdr *)(icp + 1), end);</a>
<a name="ln2296">		break;</a>
<a name="ln2297">	case ICMP6_PARAM_PROB:</a>
<a name="ln2298">		(void)printf(&quot;Parameter problem: &quot;);</a>
<a name="ln2299">		switch (icp-&gt;icmp6_code) {</a>
<a name="ln2300">		case ICMP6_PARAMPROB_HEADER:</a>
<a name="ln2301">			(void)printf(&quot;Erroneous Header &quot;);</a>
<a name="ln2302">			break;</a>
<a name="ln2303">		case ICMP6_PARAMPROB_NEXTHEADER:</a>
<a name="ln2304">			(void)printf(&quot;Unknown Nextheader &quot;);</a>
<a name="ln2305">			break;</a>
<a name="ln2306">		case ICMP6_PARAMPROB_OPTION:</a>
<a name="ln2307">			(void)printf(&quot;Unrecognized Option &quot;);</a>
<a name="ln2308">			break;</a>
<a name="ln2309">		default:</a>
<a name="ln2310">			(void)printf(&quot;Bad code(%d) &quot;, icp-&gt;icmp6_code);</a>
<a name="ln2311">			break;</a>
<a name="ln2312">		}</a>
<a name="ln2313">		(void)printf(&quot;pointer = 0x%02x\n&quot;,</a>
<a name="ln2314">		    (u_int32_t)ntohl(icp-&gt;icmp6_pptr));</a>
<a name="ln2315">		pr_retip((struct ip6_hdr *)(icp + 1), end);</a>
<a name="ln2316">		break;</a>
<a name="ln2317">	case ICMP6_ECHO_REQUEST:</a>
<a name="ln2318">		(void)printf(&quot;Echo Request&quot;);</a>
<a name="ln2319">		/* XXX ID + Seq + Data */</a>
<a name="ln2320">		break;</a>
<a name="ln2321">	case ICMP6_ECHO_REPLY:</a>
<a name="ln2322">		(void)printf(&quot;Echo Reply&quot;);</a>
<a name="ln2323">		/* XXX ID + Seq + Data */</a>
<a name="ln2324">		break;</a>
<a name="ln2325">	case ICMP6_MEMBERSHIP_QUERY:</a>
<a name="ln2326">		(void)printf(&quot;Listener Query&quot;);</a>
<a name="ln2327">		break;</a>
<a name="ln2328">	case ICMP6_MEMBERSHIP_REPORT:</a>
<a name="ln2329">		(void)printf(&quot;Listener Report&quot;);</a>
<a name="ln2330">		break;</a>
<a name="ln2331">	case ICMP6_MEMBERSHIP_REDUCTION:</a>
<a name="ln2332">		(void)printf(&quot;Listener Done&quot;);</a>
<a name="ln2333">		break;</a>
<a name="ln2334">	case ND_ROUTER_SOLICIT:</a>
<a name="ln2335">		(void)printf(&quot;Router Solicitation&quot;);</a>
<a name="ln2336">		break;</a>
<a name="ln2337">	case ND_ROUTER_ADVERT:</a>
<a name="ln2338">		(void)printf(&quot;Router Advertisement&quot;);</a>
<a name="ln2339">		break;</a>
<a name="ln2340">	case ND_NEIGHBOR_SOLICIT:</a>
<a name="ln2341">		(void)printf(&quot;Neighbor Solicitation&quot;);</a>
<a name="ln2342">		break;</a>
<a name="ln2343">	case ND_NEIGHBOR_ADVERT:</a>
<a name="ln2344">		(void)printf(&quot;Neighbor Advertisement&quot;);</a>
<a name="ln2345">		break;</a>
<a name="ln2346">	case ND_REDIRECT:</a>
<a name="ln2347">		red = (struct nd_redirect *)icp;</a>
<a name="ln2348">		(void)printf(&quot;Redirect\n&quot;);</a>
<a name="ln2349">		if (!inet_ntop(AF_INET6, &amp;red-&gt;nd_rd_dst, ntop_buf,</a>
<a name="ln2350">		    sizeof(ntop_buf)))</a>
<a name="ln2351">			strlcpy(ntop_buf, &quot;?&quot;, sizeof(ntop_buf));</a>
<a name="ln2352">		(void)printf(&quot;Destination: %s&quot;, ntop_buf);</a>
<a name="ln2353">		if (!inet_ntop(AF_INET6, &amp;red-&gt;nd_rd_target, ntop_buf,</a>
<a name="ln2354">		    sizeof(ntop_buf)))</a>
<a name="ln2355">			strlcpy(ntop_buf, &quot;?&quot;, sizeof(ntop_buf));</a>
<a name="ln2356">		(void)printf(&quot; New Target: %s&quot;, ntop_buf);</a>
<a name="ln2357">		break;</a>
<a name="ln2358">	case ICMP6_NI_QUERY:</a>
<a name="ln2359">		(void)printf(&quot;Node Information Query&quot;);</a>
<a name="ln2360">		/* XXX ID + Seq + Data */</a>
<a name="ln2361">		ni = (struct icmp6_nodeinfo *)icp;</a>
<a name="ln2362">		l = end - (u_char *)(ni + 1);</a>
<a name="ln2363">		printf(&quot;, &quot;);</a>
<a name="ln2364">		switch (ntohs(ni-&gt;ni_qtype)) {</a>
<a name="ln2365">		case NI_QTYPE_NOOP:</a>
<a name="ln2366">			(void)printf(&quot;NOOP&quot;);</a>
<a name="ln2367">			break;</a>
<a name="ln2368">		case NI_QTYPE_SUPTYPES:</a>
<a name="ln2369">			(void)printf(&quot;Supported qtypes&quot;);</a>
<a name="ln2370">			break;</a>
<a name="ln2371">		case NI_QTYPE_FQDN:</a>
<a name="ln2372">			(void)printf(&quot;DNS name&quot;);</a>
<a name="ln2373">			break;</a>
<a name="ln2374">		case NI_QTYPE_NODEADDR:</a>
<a name="ln2375">			(void)printf(&quot;nodeaddr&quot;);</a>
<a name="ln2376">			break;</a>
<a name="ln2377">		case NI_QTYPE_IPV4ADDR:</a>
<a name="ln2378">			(void)printf(&quot;IPv4 nodeaddr&quot;);</a>
<a name="ln2379">			break;</a>
<a name="ln2380">		default:</a>
<a name="ln2381">			(void)printf(&quot;unknown qtype&quot;);</a>
<a name="ln2382">			break;</a>
<a name="ln2383">		}</a>
<a name="ln2384">		if (options &amp; F_VERBOSE) {</a>
<a name="ln2385">			switch (ni-&gt;ni_code) {</a>
<a name="ln2386">			case ICMP6_NI_SUBJ_IPV6:</a>
<a name="ln2387">				if (l == sizeof(struct in6_addr) &amp;&amp;</a>
<a name="ln2388">				    inet_ntop(AF_INET6, ni + 1, ntop_buf,</a>
<a name="ln2389">				    sizeof(ntop_buf)) != NULL) {</a>
<a name="ln2390">					(void)printf(&quot;, subject=%s(%s)&quot;,</a>
<a name="ln2391">					    niqcode[ni-&gt;ni_code], ntop_buf);</a>
<a name="ln2392">				} else {</a>
<a name="ln2393">#if 1</a>
<a name="ln2394">					/* backward compat to -W */</a>
<a name="ln2395">					(void)printf(&quot;, oldfqdn&quot;);</a>
<a name="ln2396">#else</a>
<a name="ln2397">					(void)printf(&quot;, invalid&quot;);</a>
<a name="ln2398">#endif</a>
<a name="ln2399">				}</a>
<a name="ln2400">				break;</a>
<a name="ln2401">			case ICMP6_NI_SUBJ_FQDN:</a>
<a name="ln2402">				if (end == (u_char *)(ni + 1)) {</a>
<a name="ln2403">					(void)printf(&quot;, no subject&quot;);</a>
<a name="ln2404">					break;</a>
<a name="ln2405">				}</a>
<a name="ln2406">				printf(&quot;, subject=%s&quot;, niqcode[ni-&gt;ni_code]);</a>
<a name="ln2407">				cp = (const u_char *)(ni + 1);</a>
<a name="ln2408">				if (dnsdecode(&amp;cp, end, NULL, dnsname,</a>
<a name="ln2409">				    sizeof(dnsname)) != NULL)</a>
<a name="ln2410">					printf(&quot;(%s)&quot;, dnsname);</a>
<a name="ln2411">				else</a>
<a name="ln2412">					printf(&quot;(invalid)&quot;);</a>
<a name="ln2413">				break;</a>
<a name="ln2414">			case ICMP6_NI_SUBJ_IPV4:</a>
<a name="ln2415">				if (l == sizeof(struct in_addr) &amp;&amp;</a>
<a name="ln2416">				    inet_ntop(AF_INET, ni + 1, ntop_buf,</a>
<a name="ln2417">				    sizeof(ntop_buf)) != NULL) {</a>
<a name="ln2418">					(void)printf(&quot;, subject=%s(%s)&quot;,</a>
<a name="ln2419">					    niqcode[ni-&gt;ni_code], ntop_buf);</a>
<a name="ln2420">				} else</a>
<a name="ln2421">					(void)printf(&quot;, invalid&quot;);</a>
<a name="ln2422">				break;</a>
<a name="ln2423">			default:</a>
<a name="ln2424">				(void)printf(&quot;, invalid&quot;);</a>
<a name="ln2425">				break;</a>
<a name="ln2426">			}</a>
<a name="ln2427">		}</a>
<a name="ln2428">		break;</a>
<a name="ln2429">	case ICMP6_NI_REPLY:</a>
<a name="ln2430">		(void)printf(&quot;Node Information Reply&quot;);</a>
<a name="ln2431">		/* XXX ID + Seq + Data */</a>
<a name="ln2432">		ni = (struct icmp6_nodeinfo *)icp;</a>
<a name="ln2433">		printf(&quot;, &quot;);</a>
<a name="ln2434">		switch (ntohs(ni-&gt;ni_qtype)) {</a>
<a name="ln2435">		case NI_QTYPE_NOOP:</a>
<a name="ln2436">			(void)printf(&quot;NOOP&quot;);</a>
<a name="ln2437">			break;</a>
<a name="ln2438">		case NI_QTYPE_SUPTYPES:</a>
<a name="ln2439">			(void)printf(&quot;Supported qtypes&quot;);</a>
<a name="ln2440">			break;</a>
<a name="ln2441">		case NI_QTYPE_FQDN:</a>
<a name="ln2442">			(void)printf(&quot;DNS name&quot;);</a>
<a name="ln2443">			break;</a>
<a name="ln2444">		case NI_QTYPE_NODEADDR:</a>
<a name="ln2445">			(void)printf(&quot;nodeaddr&quot;);</a>
<a name="ln2446">			break;</a>
<a name="ln2447">		case NI_QTYPE_IPV4ADDR:</a>
<a name="ln2448">			(void)printf(&quot;IPv4 nodeaddr&quot;);</a>
<a name="ln2449">			break;</a>
<a name="ln2450">		default:</a>
<a name="ln2451">			(void)printf(&quot;unknown qtype&quot;);</a>
<a name="ln2452">			break;</a>
<a name="ln2453">		}</a>
<a name="ln2454">		if (options &amp; F_VERBOSE) {</a>
<a name="ln2455">			if (ni-&gt;ni_code &gt; sizeof(nircode) / sizeof(nircode[0]))</a>
<a name="ln2456">				printf(&quot;, invalid&quot;);</a>
<a name="ln2457">			else</a>
<a name="ln2458">				printf(&quot;, %s&quot;, nircode[ni-&gt;ni_code]);</a>
<a name="ln2459">		}</a>
<a name="ln2460">		break;</a>
<a name="ln2461">	default:</a>
<a name="ln2462">		(void)printf(&quot;Bad ICMP type: %d&quot;, icp-&gt;icmp6_type);</a>
<a name="ln2463">	}</a>
<a name="ln2464">}</a>
<a name="ln2465"> </a>
<a name="ln2466">/*</a>
<a name="ln2467"> * pr_iph --</a>
<a name="ln2468"> *	Print an IP6 header.</a>
<a name="ln2469"> */</a>
<a name="ln2470">void</a>
<a name="ln2471">pr_iph(ip6)</a>
<a name="ln2472">	struct ip6_hdr *ip6;</a>
<a name="ln2473">{</a>
<a name="ln2474">	u_int32_t flow = ip6-&gt;ip6_flow &amp; IPV6_FLOWLABEL_MASK;</a>
<a name="ln2475">	u_int8_t tc;</a>
<a name="ln2476">	char ntop_buf[INET6_ADDRSTRLEN];</a>
<a name="ln2477"> </a>
<a name="ln2478">	tc = *(&amp;ip6-&gt;ip6_vfc + 1); /* XXX */</a>
<a name="ln2479">	tc = (tc &gt;&gt; 4) &amp; 0x0f;</a>
<a name="ln2480">	tc |= (ip6-&gt;ip6_vfc &lt;&lt; 4);</a>
<a name="ln2481"> </a>
<a name="ln2482">	printf(&quot;Vr TC  Flow Plen Nxt Hlim\n&quot;);</a>
<a name="ln2483">	printf(&quot; %1x %02x %05x %04x  %02x   %02x\n&quot;,</a>
<a name="ln2484">	    (ip6-&gt;ip6_vfc &amp; IPV6_VERSION_MASK) &gt;&gt; 4, tc, (u_int32_t)ntohl(flow),</a>
<a name="ln2485">	    ntohs(ip6-&gt;ip6_plen), ip6-&gt;ip6_nxt, ip6-&gt;ip6_hlim);</a>
<a name="ln2486">	if (!inet_ntop(AF_INET6, &amp;ip6-&gt;ip6_src, ntop_buf, sizeof(ntop_buf)))</a>
<a name="ln2487">		strlcpy(ntop_buf, &quot;?&quot;, sizeof(ntop_buf));</a>
<a name="ln2488">	printf(&quot;%s-&gt;&quot;, ntop_buf);</a>
<a name="ln2489">	if (!inet_ntop(AF_INET6, &amp;ip6-&gt;ip6_dst, ntop_buf, sizeof(ntop_buf)))</a>
<a name="ln2490">		strlcpy(ntop_buf, &quot;?&quot;, sizeof(ntop_buf));</a>
<a name="ln2491">	printf(&quot;%s\n&quot;, ntop_buf);</a>
<a name="ln2492">}</a>
<a name="ln2493"> </a>
<a name="ln2494">/*</a>
<a name="ln2495"> * pr_addr --</a>
<a name="ln2496"> *	Return an ascii host address as a dotted quad and optionally with</a>
<a name="ln2497"> * a hostname.</a>
<a name="ln2498"> */</a>
<a name="ln2499">const char *</a>
<a name="ln2500">pr_addr(addr, addrlen)</a>
<a name="ln2501">	struct sockaddr *addr;</a>
<a name="ln2502">	int addrlen;</a>
<a name="ln2503">{</a>
<a name="ln2504">	static char buf[NI_MAXHOST];</a>
<a name="ln2505">	int flag = 0;</a>
<a name="ln2506"> </a>
<a name="ln2507">	if ((options &amp; F_HOSTNAME) == 0)</a>
<a name="ln2508">		flag |= NI_NUMERICHOST;</a>
<a name="ln2509"> </a>
<a name="ln2510">	if (getnameinfo(addr, addrlen, buf, sizeof(buf), NULL, 0, flag) == 0)</a>
<a name="ln2511">		return (buf);</a>
<a name="ln2512">	else</a>
<a name="ln2513">		return &quot;?&quot;;</a>
<a name="ln2514">}</a>
<a name="ln2515"> </a>
<a name="ln2516">/*</a>
<a name="ln2517"> * pr_retip --</a>
<a name="ln2518"> *	Dump some info on a returned (via ICMPv6) IPv6 packet.</a>
<a name="ln2519"> */</a>
<a name="ln2520">void</a>
<a name="ln2521">pr_retip(ip6, end)</a>
<a name="ln2522">	struct ip6_hdr *ip6;</a>
<a name="ln2523">	u_char *end;</a>
<a name="ln2524">{</a>
<a name="ln2525">	u_char *cp = (u_char *)ip6, nh;</a>
<a name="ln2526">	int hlen;</a>
<a name="ln2527"> </a>
<a name="ln2528">	if (end - (u_char *)ip6 &lt; sizeof(*ip6)) {</a>
<a name="ln2529">		printf(&quot;IP6&quot;);</a>
<a name="ln2530">		goto trunc;</a>
<a name="ln2531">	}</a>
<a name="ln2532">	pr_iph(ip6);</a>
<a name="ln2533">	hlen = sizeof(*ip6);</a>
<a name="ln2534"> </a>
<a name="ln2535">	nh = ip6-&gt;ip6_nxt;</a>
<a name="ln2536">	cp += hlen;</a>
<a name="ln2537">	while (end - cp &gt;= 8) {</a>
<a name="ln2538">		switch (nh) {</a>
<a name="ln2539">		case IPPROTO_HOPOPTS:</a>
<a name="ln2540">			printf(&quot;HBH &quot;);</a>
<a name="ln2541">			hlen = (((struct ip6_hbh *)cp)-&gt;ip6h_len+1) &lt;&lt; 3;</a>
<a name="ln2542">			nh = ((struct ip6_hbh *)cp)-&gt;ip6h_nxt;</a>
<a name="ln2543">			break;</a>
<a name="ln2544">		case IPPROTO_DSTOPTS:</a>
<a name="ln2545">			printf(&quot;DSTOPT &quot;);</a>
<a name="ln2546">			hlen = (((struct ip6_dest *)cp)-&gt;ip6d_len+1) &lt;&lt; 3;</a>
<a name="ln2547">			nh = ((struct ip6_dest *)cp)-&gt;ip6d_nxt;</a>
<a name="ln2548">			break;</a>
<a name="ln2549">		case IPPROTO_FRAGMENT:</a>
<a name="ln2550">			printf(&quot;FRAG &quot;);</a>
<a name="ln2551">			hlen = sizeof(struct ip6_frag);</a>
<a name="ln2552">			nh = ((struct ip6_frag *)cp)-&gt;ip6f_nxt;</a>
<a name="ln2553">			break;</a>
<a name="ln2554">		case IPPROTO_ROUTING:</a>
<a name="ln2555">			printf(&quot;RTHDR &quot;);</a>
<a name="ln2556">			hlen = (((struct ip6_rthdr *)cp)-&gt;ip6r_len+1) &lt;&lt; 3;</a>
<a name="ln2557">			nh = ((struct ip6_rthdr *)cp)-&gt;ip6r_nxt;</a>
<a name="ln2558">			break;</a>
<a name="ln2559">#ifdef IPSEC</a>
<a name="ln2560">		case IPPROTO_AH:</a>
<a name="ln2561">			printf(&quot;AH &quot;);</a>
<a name="ln2562">			hlen = (((struct ah *)cp)-&gt;ah_len+2) &lt;&lt; 2;</a>
<a name="ln2563">			nh = ((struct ah *)cp)-&gt;ah_nxt;</a>
<a name="ln2564">			break;</a>
<a name="ln2565">#endif</a>
<a name="ln2566">		case IPPROTO_ICMPV6:</a>
<a name="ln2567">			printf(&quot;ICMP6: type = %d, code = %d\n&quot;,</a>
<a name="ln2568">			    *cp, *(cp + 1));</a>
<a name="ln2569">			return;</a>
<a name="ln2570">		case IPPROTO_ESP:</a>
<a name="ln2571">			printf(&quot;ESP\n&quot;);</a>
<a name="ln2572">			return;</a>
<a name="ln2573">		case IPPROTO_TCP:</a>
<a name="ln2574">			printf(&quot;TCP: from port %u, to port %u (decimal)\n&quot;,</a>
<a name="ln2575">			    (*cp * 256 + *(cp + 1)),</a>
<a name="ln2576">			    (*(cp + 2) * 256 + *(cp + 3)));</a>
<a name="ln2577">			return;</a>
<a name="ln2578">		case IPPROTO_UDP:</a>
<a name="ln2579">			printf(&quot;UDP: from port %u, to port %u (decimal)\n&quot;,</a>
<a name="ln2580">			    (*cp * 256 + *(cp + 1)),</a>
<a name="ln2581">			    (*(cp + 2) * 256 + *(cp + 3)));</a>
<a name="ln2582">			return;</a>
<a name="ln2583">		default:</a>
<a name="ln2584">			printf(&quot;Unknown Header(%d)\n&quot;, nh);</a>
<a name="ln2585">			return;</a>
<a name="ln2586">		}</a>
<a name="ln2587"> </a>
<a name="ln2588">		if ((cp += hlen) &gt;= end)</a>
<a name="ln2589">			goto trunc;</a>
<a name="ln2590">	}</a>
<a name="ln2591">	if (end - cp &lt; 8)</a>
<a name="ln2592">		goto trunc;</a>
<a name="ln2593"> </a>
<a name="ln2594">	putchar('\n');</a>
<a name="ln2595">	return;</a>
<a name="ln2596"> </a>
<a name="ln2597">  trunc:</a>
<a name="ln2598">	printf(&quot;...\n&quot;);</a>
<a name="ln2599">	return;</a>
<a name="ln2600">}</a>
<a name="ln2601"> </a>
<a name="ln2602">void</a>
<a name="ln2603">fill(bp, patp)</a>
<a name="ln2604">	char *bp, *patp;</a>
<a name="ln2605">{</a>
<a name="ln2606">	int ii, jj, kk;</a>
<a name="ln2607">	int pat[16];</a>
<a name="ln2608">	char *cp;</a>
<a name="ln2609"> </a>
<a name="ln2610">	for (cp = patp; *cp; cp++)</a>
<a name="ln2611">		if (!isxdigit(*cp))</a>
<a name="ln2612">			errx(1, &quot;patterns must be specified as hex digits&quot;);</a>
<a name="ln2613">	ii = sscanf(patp,</a>
<a name="ln2614">	    &quot;%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x&quot;,</a>
<a name="ln2615">	    &amp;pat[0], &amp;pat[1], &amp;pat[2], &amp;pat[3], &amp;pat[4], &amp;pat[5], &amp;pat[6],</a>
<a name="ln2616">	    &amp;pat[7], &amp;pat[8], &amp;pat[9], &amp;pat[10], &amp;pat[11], &amp;pat[12],</a>
<a name="ln2617">	    &amp;pat[13], &amp;pat[14], &amp;pat[15]);</a>
<a name="ln2618"> </a>
<a name="ln2619">/* xxx */</a>
<a name="ln2620">	if (ii &gt; 0)</a>
<a name="ln2621">		for (kk = 0;</a>
<a name="ln2622">		    kk &lt;= MAXDATALEN - (8 + sizeof(struct tv32) + ii);</a>
<a name="ln2623">		    kk += ii)</a>
<a name="ln2624">			for (jj = 0; jj &lt; ii; ++jj)</a>
<a name="ln2625">				bp[jj + kk] = pat[jj];</a>
<a name="ln2626">	if (!(options &amp; F_QUIET)) {</a>
<a name="ln2627">		(void)printf(&quot;PATTERN: 0x&quot;);</a>
<a name="ln2628">		for (jj = 0; jj &lt; ii; ++jj)</a>
<a name="ln2629">			(void)printf(&quot;%02x&quot;, bp[jj] &amp; 0xFF);</a>
<a name="ln2630">		(void)printf(&quot;\n&quot;);</a>
<a name="ln2631">	}</a>
<a name="ln2632">}</a>
<a name="ln2633"> </a>
<a name="ln2634">#ifdef IPSEC</a>
<a name="ln2635">#ifdef IPSEC_POLICY_IPSEC</a>
<a name="ln2636">int</a>
<a name="ln2637">setpolicy(so, policy)</a>
<a name="ln2638">	int so;</a>
<a name="ln2639">	char *policy;</a>
<a name="ln2640">{</a>
<a name="ln2641">	char *buf;</a>
<a name="ln2642"> </a>
<a name="ln2643">	if (policy == NULL)</a>
<a name="ln2644">		return 0;	/* ignore */</a>
<a name="ln2645"> </a>
<a name="ln2646">	buf = ipsec_set_policy(policy, strlen(policy));</a>
<a name="ln2647">	if (buf == NULL)</a>
<a name="ln2648">		errx(1, &quot;%s&quot;, ipsec_strerror());</a>
<a name="ln2649">	if (setsockopt(s, IPPROTO_IPV6, IPV6_IPSEC_POLICY, buf,</a>
<a name="ln2650">	    ipsec_get_policylen(buf)) &lt; 0)</a>
<a name="ln2651">		warnx(&quot;Unable to set IPsec policy&quot;);</a>
<a name="ln2652">	free(buf);</a>
<a name="ln2653"> </a>
<a name="ln2654">	return 0;</a>
<a name="ln2655">}</a>
<a name="ln2656">#endif</a>
<a name="ln2657">#endif</a>
<a name="ln2658"> </a>
<a name="ln2659">void</a>
<a name="ln2660">usage()</a>
<a name="ln2661">{</a>
<a name="ln2662">	(void)fprintf(stderr,</a>
<a name="ln2663">#if defined(IPSEC) &amp;&amp; !defined(IPSEC_POLICY_IPSEC)</a>
<a name="ln2664">	    &quot;A&quot;</a>
<a name="ln2665">#endif</a>
<a name="ln2666">	    &quot;usage: ping6 [-&quot;</a>
<a name="ln2667">	    &quot;d&quot;</a>
<a name="ln2668">#if defined(IPSEC) &amp;&amp; !defined(IPSEC_POLICY_IPSEC)</a>
<a name="ln2669">	    &quot;E&quot;</a>
<a name="ln2670">#endif</a>
<a name="ln2671">	    &quot;fH&quot;</a>
<a name="ln2672">#ifdef IPV6_USE_MIN_MTU</a>
<a name="ln2673">	    &quot;m&quot;</a>
<a name="ln2674">#endif</a>
<a name="ln2675">	    &quot;noqrRtvwW] &quot;</a>
<a name="ln2676">	    &quot;[-a addrtype] [-b bufsiz] [-c count]\n&quot;</a>
<a name="ln2677">	    &quot;             [-h hoplimit] [-I interface] [-i wait] [-l preload]&quot;</a>
<a name="ln2678">#if defined(IPSEC) &amp;&amp; defined(IPSEC_POLICY_IPSEC)</a>
<a name="ln2679">	    &quot; [-P policy]&quot;</a>
<a name="ln2680">#endif</a>
<a name="ln2681">	    &quot;\n&quot;</a>
<a name="ln2682">	    &quot;             [-p pattern] [-S sourceaddr] [-s packetsize] &quot;</a>
<a name="ln2683">	    &quot;[hops ...] host\n&quot;);</a>
<a name="ln2684">	exit(1);</a>
<a name="ln2685">}</a>

</code></pre>
<div class="balloon" rel="1295"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v507/" target="_blank">V507</a> Pointer to local array 'iov' is stored outside the scope of this array. Such a pointer will become invalid.</p></div>
<div class="balloon" rel="998"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v641/" target="_blank">V641</a> The size of the allocated memory buffer is not a multiple of the element size.</p></div>
<div class="balloon" rel="1604"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'i > 0' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
