
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>RAW.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2007-2008, Axel DÃ¶rfler, axeld@pinc-software.de.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Copyright 1997-2007, Dave Coffin, dcoffin a cybercom o net</a>
<a name="ln6"> * This code is based on Dave Coffin's dcraw 8.63 - it's basically the same</a>
<a name="ln7"> * thing in C++, but follows common sense programming rules a bit more :-)</a>
<a name="ln8"> * Except the Fovean functions, dcraw is public domain.</a>
<a name="ln9"> */</a>
<a name="ln10"> </a>
<a name="ln11"> </a>
<a name="ln12">#include &quot;RAW.h&quot;</a>
<a name="ln13">#include &quot;ReadHelper.h&quot;</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;Message.h&gt;</a>
<a name="ln16">#include &lt;TranslationErrors.h&gt;</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;ctype.h&gt;</a>
<a name="ln19">#include &lt;stdio.h&gt;</a>
<a name="ln20">#include &lt;stdlib.h&gt;</a>
<a name="ln21">#include &lt;string.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23"> </a>
<a name="ln24">//#define TRACE(x) printf x</a>
<a name="ln25">#define TRACE(x)</a>
<a name="ln26">//#define TAG(x...) printf(x)</a>
<a name="ln27">#define TAG(x...)</a>
<a name="ln28"> </a>
<a name="ln29">#define ABS(x) (((int)(x) ^ ((int)(x) &gt;&gt; 31)) - ((int)(x) &gt;&gt; 31))</a>
<a name="ln30">#define LIM(x,min,max) MAX(min,MIN(x,max))</a>
<a name="ln31">#define ULIM(x,y,z) ((y) &lt; (z) ? LIM(x,y,z) : LIM(x,z,y))</a>
<a name="ln32">#define CLIP(x) LIM(x,0,65535)</a>
<a name="ln33">#define SWAP(a,b) { a ^= b; a ^= (b ^= a); }</a>
<a name="ln34"> </a>
<a name="ln35">#define FC(row,col) \</a>
<a name="ln36">	(fFilters &gt;&gt; ((((row) &lt;&lt; 1 &amp; 14) + ((col) &amp; 1)) &lt;&lt; 1) &amp; 3)</a>
<a name="ln37"> </a>
<a name="ln38"> </a>
<a name="ln39">static const uint32 kImageBufferCount = 10;</a>
<a name="ln40">static const uint32 kDecodeBufferCount = 2048;</a>
<a name="ln41"> </a>
<a name="ln42">const double xyz_rgb[3][3] = {			/* XYZ from RGB */</a>
<a name="ln43">  { 0.412453, 0.357580, 0.180423 },</a>
<a name="ln44">  { 0.212671, 0.715160, 0.072169 },</a>
<a name="ln45">  { 0.019334, 0.119193, 0.950227 } };</a>
<a name="ln46">const float kD65White[3] = { 0.950456, 1, 1.088754 };</a>
<a name="ln47"> </a>
<a name="ln48">struct decode {</a>
<a name="ln49">	struct decode *branch[2];</a>
<a name="ln50">	int32	leaf;</a>
<a name="ln51">};</a>
<a name="ln52"> </a>
<a name="ln53">struct jhead {</a>
<a name="ln54">	int		bits, high, wide, clrs, restart, vpred[4];</a>
<a name="ln55">	struct decode *huff[4];</a>
<a name="ln56">	uint16*	row;</a>
<a name="ln57">};</a>
<a name="ln58"> </a>
<a name="ln59">struct tiff_header {</a>
<a name="ln60">	uint16	order, magic;</a>
<a name="ln61">	int32	image_file_directory;</a>
<a name="ln62">	uint16	pad, ntag;</a>
<a name="ln63">	struct tiff_tag tag[15];</a>
<a name="ln64">	int32	next_image_file_directory;</a>
<a name="ln65">	uint16	pad2, nexif;</a>
<a name="ln66">	struct tiff_tag exif[4];</a>
<a name="ln67">	int16	bps[4];</a>
<a name="ln68">	int32	rat[6];</a>
<a name="ln69">	char make[64], model[64], soft[32], date[20];</a>
<a name="ln70">};</a>
<a name="ln71"> </a>
<a name="ln72"> </a>
<a name="ln73">template&lt;class T&gt; inline T</a>
<a name="ln74">square(const T&amp; value)</a>
<a name="ln75">{</a>
<a name="ln76">	return value * value;</a>
<a name="ln77">}</a>
<a name="ln78"> </a>
<a name="ln79"> </a>
<a name="ln80">static inline bool</a>
<a name="ln81">x_flipped(int32 orientation)</a>
<a name="ln82">{</a>
<a name="ln83">	return orientation == 2 || orientation == 3</a>
<a name="ln84">		|| orientation == 7 || orientation == 8;</a>
<a name="ln85">}</a>
<a name="ln86"> </a>
<a name="ln87"> </a>
<a name="ln88">static inline bool</a>
<a name="ln89">y_flipped(int32 orientation)</a>
<a name="ln90">{</a>
<a name="ln91">	return orientation == 3 || orientation == 4</a>
<a name="ln92">		|| orientation == 6 || orientation == 7;</a>
<a name="ln93">}</a>
<a name="ln94"> </a>
<a name="ln95"> </a>
<a name="ln96">#if 0</a>
<a name="ln97">void</a>
<a name="ln98">dump_to_disk(void* data, size_t length)</a>
<a name="ln99">{</a>
<a name="ln100">	FILE* file = fopen(&quot;/tmp/RAW.out&quot;, &quot;wb&quot;);</a>
<a name="ln101">	if (file == NULL)</a>
<a name="ln102">		return;</a>
<a name="ln103"> </a>
<a name="ln104">	fwrite(data, length, 1, file);</a>
<a name="ln105">	fclose(file);</a>
<a name="ln106">}</a>
<a name="ln107">#endif</a>
<a name="ln108"> </a>
<a name="ln109"> </a>
<a name="ln110">//	#pragma mark -</a>
<a name="ln111"> </a>
<a name="ln112"> </a>
<a name="ln113">DCRaw::DCRaw(BPositionIO&amp; stream)</a>
<a name="ln114">	:</a>
<a name="ln115">	fRead(stream),</a>
<a name="ln116">	fNumImages(0),</a>
<a name="ln117">	fRawIndex(-1),</a>
<a name="ln118">	fThumbIndex(-1),</a>
<a name="ln119">	fDNGVersion(0),</a>
<a name="ln120">	fIsTIFF(false),</a>
<a name="ln121">	fImageData(NULL),</a>
<a name="ln122">	fThreshold(0.0f),</a>
<a name="ln123">	fHalfSize(false),</a>
<a name="ln124">	fUseCameraWhiteBalance(true),</a>
<a name="ln125">	fUseAutoWhiteBalance(true),</a>
<a name="ln126">	fRawColor(true),</a>
<a name="ln127">	fUseGamma(true),</a>
<a name="ln128">	fBrightness(1.0f),</a>
<a name="ln129">	fOutputColor(1),</a>
<a name="ln130">	fHighlight(0),</a>
<a name="ln131">	fDocumentMode(0),</a>
<a name="ln132">	fOutputWidth(0),</a>
<a name="ln133">	fOutputHeight(0),</a>
<a name="ln134">	fInputWidth(0),</a>
<a name="ln135">	fInputHeight(0),</a>
<a name="ln136">	fTopMargin(0),</a>
<a name="ln137">	fLeftMargin(0),</a>
<a name="ln138">	fColors(3),</a>
<a name="ln139">	fOutputProfile(NULL),</a>
<a name="ln140">	fOutputBitsPerSample(8),</a>
<a name="ln141">	fDecodeLeaf(0),</a>
<a name="ln142">	fDecodeBitsZeroAfterMax(false),</a>
<a name="ln143">	fFilters(~0),</a>
<a name="ln144">	fEXIFOffset(-1),</a>
<a name="ln145">	fProgressMonitor(NULL)</a>
<a name="ln146">{</a>
<a name="ln147">	fImages = new image_data_info[kImageBufferCount];</a>
<a name="ln148">	fDecodeBuffer = new decode[kDecodeBufferCount];</a>
<a name="ln149">	fCurve = new uint16[0x1000];</a>
<a name="ln150">	for (uint32 i = 0; i &lt; 0x1000; i++) {</a>
<a name="ln151">		fCurve[i] = i;</a>
<a name="ln152">	}</a>
<a name="ln153"> </a>
<a name="ln154">	cbrt = new float[0x10000];</a>
<a name="ln155">	fHistogram = (int32 (*)[4])calloc(sizeof(int32) * 0x2000 * 4, 1);</a>
<a name="ln156"> </a>
<a name="ln157">	memset(fImages, 0, sizeof(image_data_info) * kImageBufferCount);</a>
<a name="ln158">	memset(&amp;fMeta, 0, sizeof(image_meta_info));</a>
<a name="ln159">	memset(fUserMultipliers, 0, sizeof(fUserMultipliers));</a>
<a name="ln160">	memset(fWhite, 0, sizeof(fWhite));</a>
<a name="ln161"> </a>
<a name="ln162">	fMeta.camera_multipliers[0] = -1;</a>
<a name="ln163">	fCR2Slice[0] = 0;</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166"> </a>
<a name="ln167">DCRaw::~DCRaw()</a>
<a name="ln168">{</a>
<a name="ln169">	delete[] fImages;</a>
<a name="ln170">	delete[] fDecodeBuffer;</a>
<a name="ln171">	delete[] fCurve;</a>
<a name="ln172"> </a>
<a name="ln173">	delete[] cbrt;</a>
<a name="ln174"> </a>
<a name="ln175">	free(fHistogram);</a>
<a name="ln176">	free(fImageData);</a>
<a name="ln177">}</a>
<a name="ln178"> </a>
<a name="ln179"> </a>
<a name="ln180">int32</a>
<a name="ln181">DCRaw::_AllocateImage()</a>
<a name="ln182">{</a>
<a name="ln183">	if (fNumImages + 1 == kImageBufferCount)</a>
<a name="ln184">		throw (status_t)B_ERROR;</a>
<a name="ln185"> </a>
<a name="ln186">	return fNumImages++;</a>
<a name="ln187">}</a>
<a name="ln188"> </a>
<a name="ln189"> </a>
<a name="ln190">image_data_info&amp;</a>
<a name="ln191">DCRaw::_Raw()</a>
<a name="ln192">{</a>
<a name="ln193">	if (fRawIndex &lt; 0)</a>
<a name="ln194">		fRawIndex = _AllocateImage();</a>
<a name="ln195">	if (fRawIndex &lt; 0)</a>
<a name="ln196">		throw (status_t)B_ERROR;</a>
<a name="ln197"> </a>
<a name="ln198">	return fImages[fRawIndex];</a>
<a name="ln199">}</a>
<a name="ln200"> </a>
<a name="ln201"> </a>
<a name="ln202">image_data_info&amp;</a>
<a name="ln203">DCRaw::_Thumb()</a>
<a name="ln204">{</a>
<a name="ln205">	if (fThumbIndex &lt; 0)</a>
<a name="ln206">		fThumbIndex = _AllocateImage();</a>
<a name="ln207">	if (fThumbIndex &lt; 0)</a>
<a name="ln208">		throw (status_t)B_ERROR;</a>
<a name="ln209"> </a>
<a name="ln210">	return fImages[fThumbIndex];</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213"> </a>
<a name="ln214">//! Make sure that the raw image always comes first</a>
<a name="ln215">void</a>
<a name="ln216">DCRaw::_CorrectIndex(uint32&amp; index) const</a>
<a name="ln217">{</a>
<a name="ln218">	if (fRawIndex &gt; 0) {</a>
<a name="ln219">		if (index == 0)</a>
<a name="ln220">			index = fRawIndex;</a>
<a name="ln221">		else if (index &lt;= (uint32)fRawIndex)</a>
<a name="ln222">			index--;</a>
<a name="ln223">	}</a>
<a name="ln224">}</a>
<a name="ln225"> </a>
<a name="ln226"> </a>
<a name="ln227">inline uint16&amp;</a>
<a name="ln228">DCRaw::_Bayer(int32 column, int32 row)</a>
<a name="ln229">{</a>
<a name="ln230">	return fImageData[((row) &gt;&gt; fShrink) * fOutputWidth</a>
<a name="ln231">		+ ((column) &gt;&gt; fShrink)][FC(row, column)];</a>
<a name="ln232">}</a>
<a name="ln233"> </a>
<a name="ln234"> </a>
<a name="ln235">inline int32</a>
<a name="ln236">DCRaw::_FilterCoefficient(int32 x, int32 y)</a>
<a name="ln237">{</a>
<a name="ln238">	static const char filter[16][16] = {</a>
<a name="ln239">		{ 2,1,1,3,2,3,2,0,3,2,3,0,1,2,1,0 },</a>
<a name="ln240">		{ 0,3,0,2,0,1,3,1,0,1,1,2,0,3,3,2 },</a>
<a name="ln241">		{ 2,3,3,2,3,1,1,3,3,1,2,1,2,0,0,3 },</a>
<a name="ln242">		{ 0,1,0,1,0,2,0,2,2,0,3,0,1,3,2,1 },</a>
<a name="ln243">		{ 3,1,1,2,0,1,0,2,1,3,1,3,0,1,3,0 },</a>
<a name="ln244">		{ 2,0,0,3,3,2,3,1,2,0,2,0,3,2,2,1 },</a>
<a name="ln245">		{ 2,3,3,1,2,1,2,1,2,1,1,2,3,0,0,1 },</a>
<a name="ln246">		{ 1,0,0,2,3,0,0,3,0,3,0,3,2,1,2,3 },</a>
<a name="ln247">		{ 2,3,3,1,1,2,1,0,3,2,3,0,2,3,1,3 },</a>
<a name="ln248">		{ 1,0,2,0,3,0,3,2,0,1,1,2,0,1,0,2 },</a>
<a name="ln249">		{ 0,1,1,3,3,2,2,1,1,3,3,0,2,1,3,2 },</a>
<a name="ln250">		{ 2,3,2,0,0,1,3,0,2,0,1,2,3,0,1,0 },</a>
<a name="ln251">		{ 1,3,1,2,3,2,3,2,0,2,0,1,1,0,3,0 },</a>
<a name="ln252">		{ 0,2,0,3,1,0,0,1,1,3,3,2,3,2,2,1 },</a>
<a name="ln253">		{ 2,1,3,2,3,1,2,1,0,3,0,2,0,2,0,2 },</a>
<a name="ln254">		{ 0,3,1,0,0,2,0,3,2,1,3,1,1,3,1,3 }</a>
<a name="ln255">	};</a>
<a name="ln256"> </a>
<a name="ln257">	if (fFilters != 1)</a>
<a name="ln258">		return FC(y, x);</a>
<a name="ln259"> </a>
<a name="ln260">	return filter[(y + fTopMargin) &amp; 15][(x + fLeftMargin) &amp; 15];</a>
<a name="ln261">}</a>
<a name="ln262"> </a>
<a name="ln263"> </a>
<a name="ln264">inline int32</a>
<a name="ln265">DCRaw::_FlipIndex(uint32 row, uint32 col, uint32 flip)</a>
<a name="ln266">{</a>
<a name="ln267">	if (flip &gt; 4)</a>
<a name="ln268">		SWAP(row, col);</a>
<a name="ln269">	if (y_flipped(flip))</a>
<a name="ln270">		row = fInputHeight - 1 - row;</a>
<a name="ln271">	if (x_flipped(flip))</a>
<a name="ln272">		col = fInputWidth - 1 - col;</a>
<a name="ln273"> </a>
<a name="ln274">	return row * fInputWidth + col;</a>
<a name="ln275">}</a>
<a name="ln276"> </a>
<a name="ln277"> </a>
<a name="ln278">bool</a>
<a name="ln279">DCRaw::_SupportsCompression(image_data_info&amp; image) const</a>
<a name="ln280">{</a>
<a name="ln281">	switch (image.compression) {</a>
<a name="ln282">		//case COMPRESSION_NONE:</a>
<a name="ln283">		case COMPRESSION_OLD_JPEG:</a>
<a name="ln284">		case COMPRESSION_PACKBITS:</a>
<a name="ln285">			return true;</a>
<a name="ln286"> </a>
<a name="ln287">		default:</a>
<a name="ln288">			return false;</a>
<a name="ln289">	}</a>
<a name="ln290">}</a>
<a name="ln291"> </a>
<a name="ln292"> </a>
<a name="ln293">bool</a>
<a name="ln294">DCRaw::_IsCanon() const</a>
<a name="ln295">{</a>
<a name="ln296">	return !strncasecmp(fMeta.manufacturer, &quot;Canon&quot;, 5);</a>
<a name="ln297">}</a>
<a name="ln298"> </a>
<a name="ln299"> </a>
<a name="ln300">bool</a>
<a name="ln301">DCRaw::_IsKodak() const</a>
<a name="ln302">{</a>
<a name="ln303">	return !strncasecmp(fMeta.manufacturer, &quot;Kodak&quot;, 5);</a>
<a name="ln304">}</a>
<a name="ln305"> </a>
<a name="ln306"> </a>
<a name="ln307">bool</a>
<a name="ln308">DCRaw::_IsNikon() const</a>
<a name="ln309">{</a>
<a name="ln310">	return !strncasecmp(fMeta.manufacturer, &quot;Nikon&quot;, 5);</a>
<a name="ln311">}</a>
<a name="ln312"> </a>
<a name="ln313"> </a>
<a name="ln314">bool</a>
<a name="ln315">DCRaw::_IsOlympus() const</a>
<a name="ln316">{</a>
<a name="ln317">	return !strncasecmp(fMeta.manufacturer, &quot;Olympus&quot;, 7);</a>
<a name="ln318">}</a>
<a name="ln319"> </a>
<a name="ln320"> </a>
<a name="ln321">bool</a>
<a name="ln322">DCRaw::_IsPentax() const</a>
<a name="ln323">{</a>
<a name="ln324">	return !strncasecmp(fMeta.manufacturer, &quot;Pentax&quot;, 6);</a>
<a name="ln325">}</a>
<a name="ln326"> </a>
<a name="ln327"> </a>
<a name="ln328">bool</a>
<a name="ln329">DCRaw::_IsSamsung() const</a>
<a name="ln330">{</a>
<a name="ln331">	return !strncasecmp(fMeta.manufacturer, &quot;Samsung&quot;, 7);</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334"> </a>
<a name="ln335">void</a>
<a name="ln336">DCRaw::_ParseThumbTag(off_t baseOffset, uint32 offsetTag, uint32 lengthTag)</a>
<a name="ln337">{</a>
<a name="ln338">	uint16 entries;</a>
<a name="ln339">	fRead(entries);</a>
<a name="ln340"> </a>
<a name="ln341">	while (entries--) {</a>
<a name="ln342">		off_t nextOffset;</a>
<a name="ln343">		tiff_tag tag;</a>
<a name="ln344">		_ParseTIFFTag(baseOffset, tag, nextOffset);</a>
<a name="ln345"> </a>
<a name="ln346">		if (tag.tag == offsetTag)</a>
<a name="ln347">			_Thumb().data_offset = fRead.Next&lt;uint32&gt;();</a>
<a name="ln348">		if (tag.tag == lengthTag)</a>
<a name="ln349">			_Thumb().bytes = fRead.Next&lt;uint32&gt;();</a>
<a name="ln350"> </a>
<a name="ln351">		fRead.Seek(nextOffset, SEEK_SET);</a>
<a name="ln352">	}</a>
<a name="ln353">}</a>
<a name="ln354"> </a>
<a name="ln355"> </a>
<a name="ln356">void</a>
<a name="ln357">DCRaw::_ParseManufacturerTag(off_t baseOffset)</a>
<a name="ln358">{</a>
<a name="ln359">	static const uchar xlat[2][256] = {</a>
<a name="ln360">		{</a>
<a name="ln361">			0xc1,0xbf,0x6d,0x0d,0x59,0xc5,0x13,0x9d,0x83,0x61,0x6b,0x4f,0xc7,0x7f,0x3d,0x3d,</a>
<a name="ln362">			0x53,0x59,0xe3,0xc7,0xe9,0x2f,0x95,0xa7,0x95,0x1f,0xdf,0x7f,0x2b,0x29,0xc7,0x0d,</a>
<a name="ln363">			0xdf,0x07,0xef,0x71,0x89,0x3d,0x13,0x3d,0x3b,0x13,0xfb,0x0d,0x89,0xc1,0x65,0x1f,</a>
<a name="ln364">			0xb3,0x0d,0x6b,0x29,0xe3,0xfb,0xef,0xa3,0x6b,0x47,0x7f,0x95,0x35,0xa7,0x47,0x4f,</a>
<a name="ln365">			0xc7,0xf1,0x59,0x95,0x35,0x11,0x29,0x61,0xf1,0x3d,0xb3,0x2b,0x0d,0x43,0x89,0xc1,</a>
<a name="ln366">			0x9d,0x9d,0x89,0x65,0xf1,0xe9,0xdf,0xbf,0x3d,0x7f,0x53,0x97,0xe5,0xe9,0x95,0x17,</a>
<a name="ln367">			0x1d,0x3d,0x8b,0xfb,0xc7,0xe3,0x67,0xa7,0x07,0xf1,0x71,0xa7,0x53,0xb5,0x29,0x89,</a>
<a name="ln368">			0xe5,0x2b,0xa7,0x17,0x29,0xe9,0x4f,0xc5,0x65,0x6d,0x6b,0xef,0x0d,0x89,0x49,0x2f,</a>
<a name="ln369">			0xb3,0x43,0x53,0x65,0x1d,0x49,0xa3,0x13,0x89,0x59,0xef,0x6b,0xef,0x65,0x1d,0x0b,</a>
<a name="ln370">			0x59,0x13,0xe3,0x4f,0x9d,0xb3,0x29,0x43,0x2b,0x07,0x1d,0x95,0x59,0x59,0x47,0xfb,</a>
<a name="ln371">			0xe5,0xe9,0x61,0x47,0x2f,0x35,0x7f,0x17,0x7f,0xef,0x7f,0x95,0x95,0x71,0xd3,0xa3,</a>
<a name="ln372">			0x0b,0x71,0xa3,0xad,0x0b,0x3b,0xb5,0xfb,0xa3,0xbf,0x4f,0x83,0x1d,0xad,0xe9,0x2f,</a>
<a name="ln373">			0x71,0x65,0xa3,0xe5,0x07,0x35,0x3d,0x0d,0xb5,0xe9,0xe5,0x47,0x3b,0x9d,0xef,0x35,</a>
<a name="ln374">			0xa3,0xbf,0xb3,0xdf,0x53,0xd3,0x97,0x53,0x49,0x71,0x07,0x35,0x61,0x71,0x2f,0x43,</a>
<a name="ln375">			0x2f,0x11,0xdf,0x17,0x97,0xfb,0x95,0x3b,0x7f,0x6b,0xd3,0x25,0xbf,0xad,0xc7,0xc5,</a>
<a name="ln376">			0xc5,0xb5,0x8b,0xef,0x2f,0xd3,0x07,0x6b,0x25,0x49,0x95,0x25,0x49,0x6d,0x71,0xc7</a>
<a name="ln377">		},</a>
<a name="ln378">		{</a>
<a name="ln379">			0xa7,0xbc,0xc9,0xad,0x91,0xdf,0x85,0xe5,0xd4,0x78,0xd5,0x17,0x46,0x7c,0x29,0x4c,</a>
<a name="ln380">			0x4d,0x03,0xe9,0x25,0x68,0x11,0x86,0xb3,0xbd,0xf7,0x6f,0x61,0x22,0xa2,0x26,0x34,</a>
<a name="ln381">			0x2a,0xbe,0x1e,0x46,0x14,0x68,0x9d,0x44,0x18,0xc2,0x40,0xf4,0x7e,0x5f,0x1b,0xad,</a>
<a name="ln382">			0x0b,0x94,0xb6,0x67,0xb4,0x0b,0xe1,0xea,0x95,0x9c,0x66,0xdc,0xe7,0x5d,0x6c,0x05,</a>
<a name="ln383">			0xda,0xd5,0xdf,0x7a,0xef,0xf6,0xdb,0x1f,0x82,0x4c,0xc0,0x68,0x47,0xa1,0xbd,0xee,</a>
<a name="ln384">			0x39,0x50,0x56,0x4a,0xdd,0xdf,0xa5,0xf8,0xc6,0xda,0xca,0x90,0xca,0x01,0x42,0x9d,</a>
<a name="ln385">			0x8b,0x0c,0x73,0x43,0x75,0x05,0x94,0xde,0x24,0xb3,0x80,0x34,0xe5,0x2c,0xdc,0x9b,</a>
<a name="ln386">			0x3f,0xca,0x33,0x45,0xd0,0xdb,0x5f,0xf5,0x52,0xc3,0x21,0xda,0xe2,0x22,0x72,0x6b,</a>
<a name="ln387">			0x3e,0xd0,0x5b,0xa8,0x87,0x8c,0x06,0x5d,0x0f,0xdd,0x09,0x19,0x93,0xd0,0xb9,0xfc,</a>
<a name="ln388">			0x8b,0x0f,0x84,0x60,0x33,0x1c,0x9b,0x45,0xf1,0xf0,0xa3,0x94,0x3a,0x12,0x77,0x33,</a>
<a name="ln389">			0x4d,0x44,0x78,0x28,0x3c,0x9e,0xfd,0x65,0x57,0x16,0x94,0x6b,0xfb,0x59,0xd0,0xc8,</a>
<a name="ln390">			0x22,0x36,0xdb,0xd2,0x63,0x98,0x43,0xa1,0x04,0x87,0x86,0xf7,0xa6,0x26,0xbb,0xd6,</a>
<a name="ln391">			0x59,0x4d,0xbf,0x6a,0x2e,0xaa,0x2b,0xef,0xe6,0x78,0xb6,0x4e,0xe0,0x2f,0xdc,0x7c,</a>
<a name="ln392">			0xbe,0x57,0x19,0x32,0x7e,0x2a,0xd0,0xb8,0xba,0x29,0x00,0x3c,0x52,0x7d,0xa8,0x49,</a>
<a name="ln393">			0x3b,0x2d,0xeb,0x25,0x49,0xfa,0xa3,0xaa,0x39,0xa7,0xc5,0xa7,0x50,0x11,0x36,0xfb,</a>
<a name="ln394">			0xc6,0x67,0x4a,0xf5,0xa5,0x12,0x65,0x7e,0xb0,0xdf,0xaf,0x4e,0xb3,0x61,0x7f,0x2f</a>
<a name="ln395">		}</a>
<a name="ln396">	};</a>
<a name="ln397"> </a>
<a name="ln398">	uint32 ver97 = 0, serial = 0;</a>
<a name="ln399">	uchar buf97[324], ci, cj, ck;</a>
<a name="ln400">	bool originalSwap = fRead.IsSwapping();</a>
<a name="ln401">	image_data_info&amp; image = fImages[fNumImages];</a>
<a name="ln402"> </a>
<a name="ln403">	// The MakerNote might have its own TIFF header (possibly with</a>
<a name="ln404">	// its own byte-order!), or it might just be a table.</a>
<a name="ln405"> </a>
<a name="ln406">	char type[10];</a>
<a name="ln407">	fRead(type, sizeof(type));</a>
<a name="ln408"> </a>
<a name="ln409">	if (!strncmp(type, &quot;KDK&quot;, 3)</a>
<a name="ln410">		|| !strncmp(type, &quot;VER&quot;, 3)</a>
<a name="ln411">		|| !strncmp(type, &quot;IIII&quot;, 4)</a>
<a name="ln412">		|| !strncmp(type, &quot;MMMM&quot;, 4)) {</a>
<a name="ln413">		// these aren't TIFF tables</a>
<a name="ln414">		return;</a>
<a name="ln415">	}</a>
<a name="ln416">	if (!strncmp(type, &quot;KC&quot;, 2)			// Konica KD-400Z, KD-510Z</a>
<a name="ln417">		|| !strncmp(type, &quot;MLY&quot;, 3)) {	// Minolta DiMAGE G series</a>
<a name="ln418">		fRead.SetSwap(B_HOST_IS_LENDIAN != 0);</a>
<a name="ln419">			// this chunk is always in big endian</a>
<a name="ln420"> </a>
<a name="ln421">		uint32 whiteBalance[4] = {0, 0, 0, 0};</a>
<a name="ln422"> </a>
<a name="ln423">		off_t offset;</a>
<a name="ln424">	    while ((offset = fRead.Position()) &lt; image.data_offset</a>
<a name="ln425">	    	&amp;&amp; offset &lt; 16384) {</a>
<a name="ln426">			whiteBalance[0] = whiteBalance[2];</a>
<a name="ln427">			whiteBalance[2] = whiteBalance[1];</a>
<a name="ln428">			whiteBalance[1] = whiteBalance[3];</a>
<a name="ln429"> </a>
<a name="ln430">			whiteBalance[3] = fRead.Next&lt;uint16&gt;();</a>
<a name="ln431">			if (whiteBalance[1] == 256 &amp;&amp; whiteBalance[3] == 256</a>
<a name="ln432">				&amp;&amp; whiteBalance[0] &gt; 256 &amp;&amp; whiteBalance[0] &lt; 640</a>
<a name="ln433">				&amp;&amp; whiteBalance[2] &gt; 256 &amp;&amp; whiteBalance[2] &lt; 640) {</a>
<a name="ln434">				for (uint32 i = 0; i &lt; 4; i++) {</a>
<a name="ln435">					fMeta.camera_multipliers[i] = whiteBalance[i];</a>
<a name="ln436">				}</a>
<a name="ln437">			}</a>
<a name="ln438">		}</a>
<a name="ln439">		goto quit;</a>
<a name="ln440">	}</a>
<a name="ln441">	if (!strcmp(type, &quot;Nikon&quot;)) {</a>
<a name="ln442">		baseOffset = fRead.Position();</a>
<a name="ln443"> </a>
<a name="ln444">		uint16 endian;</a>
<a name="ln445">		fRead(endian);</a>
<a name="ln446"> </a>
<a name="ln447">#if B_HOST_IS_LENDIAN</a>
<a name="ln448">		fRead.SetSwap(endian == 'MM');</a>
<a name="ln449">#else</a>
<a name="ln450">		fRead.SetSwap(endian == 'II');</a>
<a name="ln451">#endif</a>
<a name="ln452"> </a>
<a name="ln453">		if (fRead.Next&lt;uint16&gt;() != 42)</a>
<a name="ln454">			goto quit;</a>
<a name="ln455"> </a>
<a name="ln456">		uint32 offset = fRead.Next&lt;uint32&gt;();</a>
<a name="ln457">		fRead.Seek(offset - 8, SEEK_CUR);</a>
<a name="ln458">	} else if (!strncmp(type, &quot;FUJIFILM&quot;, 8)</a>
<a name="ln459">		|| !strncmp(type, &quot;SONY&quot;, 4)</a>
<a name="ln460">		|| !strcmp(type, &quot;Panasonic&quot;)) {</a>
<a name="ln461">		fRead.SetSwap(B_HOST_IS_BENDIAN != 0);</a>
<a name="ln462">			// this chunk is always in little endian</a>
<a name="ln463">		fRead.Seek(2, SEEK_CUR);</a>
<a name="ln464">	} else if (!strcmp(type, &quot;OLYMP&quot;)</a>
<a name="ln465">		|| !strcmp(type, &quot;LEICA&quot;)</a>
<a name="ln466">		|| !strcmp(type, &quot;Ricoh&quot;)</a>
<a name="ln467">		|| !strcmp(type, &quot;EPSON&quot;))</a>
<a name="ln468">		fRead.Seek(-2, SEEK_CUR);</a>
<a name="ln469">	else if (!strcmp(type, &quot;AOC&quot;) || !strcmp(type, &quot;QVC&quot;))</a>
<a name="ln470">		fRead.Seek(-4, SEEK_CUR);</a>
<a name="ln471">	else</a>
<a name="ln472">		fRead.Seek(-10, SEEK_CUR);</a>
<a name="ln473"> </a>
<a name="ln474">	uint16 entries;</a>
<a name="ln475">	fRead(entries);</a>
<a name="ln476">	if (entries &gt; 1000)</a>
<a name="ln477">		return;</a>
<a name="ln478"> </a>
<a name="ln479">	while (entries--) {</a>
<a name="ln480">		off_t nextOffset;</a>
<a name="ln481">		tiff_tag tag;</a>
<a name="ln482">		_ParseTIFFTag(baseOffset, tag, nextOffset);</a>
<a name="ln483">		TAG(&quot;Manufacturer tag %u (type %u, length %lu)\n&quot;, tag.tag, tag.type,</a>
<a name="ln484">			tag.length);</a>
<a name="ln485"> </a>
<a name="ln486">		if (strstr(fMeta.manufacturer, &quot;PENTAX&quot;)) {</a>
<a name="ln487">			if (tag.tag == 0x1b)</a>
<a name="ln488">				tag.tag = 0x1018;</a>
<a name="ln489">			if (tag.tag == 0x1c)</a>
<a name="ln490">				tag.tag = 0x1017;</a>
<a name="ln491">		} else if (tag.tag == 2 &amp;&amp; strstr(fMeta.manufacturer, &quot;NIKON&quot;)) {</a>
<a name="ln492">			fRead.Next&lt;uint16&gt;();</a>
<a name="ln493">				// ignored</a>
<a name="ln494">			fMeta.iso_speed = fRead.Next&lt;uint16&gt;();</a>
<a name="ln495">		}</a>
<a name="ln496"> </a>
<a name="ln497">		if (tag.tag == 4 &amp;&amp; tag.length == 27) {</a>
<a name="ln498">			fRead.Next&lt;uint32&gt;();</a>
<a name="ln499">				// ignored</a>
<a name="ln500">			fMeta.iso_speed = 50 * pow(2, fRead.Next&lt;uint16&gt;() / 32.0 - 4);</a>
<a name="ln501">			fRead.Next&lt;uint16&gt;();</a>
<a name="ln502">				// ignored</a>
<a name="ln503">			fMeta.aperture = pow(2, fRead.Next&lt;uint16&gt;() / 64.0);</a>
<a name="ln504">			fMeta.shutter = pow(2, fRead.Next&lt;int16&gt;() / -32.0);</a>
<a name="ln505">		}</a>
<a name="ln506">		if (tag.tag == 8 &amp;&amp; tag.type == 4)</a>
<a name="ln507">			fMeta.shot_order = fRead.Next&lt;uint32&gt;();</a>
<a name="ln508">		if (tag.tag == 0xc &amp;&amp; tag.length == 4) {</a>
<a name="ln509">			fMeta.camera_multipliers[0] = fRead.NextDouble(TIFF_FRACTION_TYPE);</a>
<a name="ln510">			fMeta.camera_multipliers[2] = fRead.NextDouble(TIFF_FRACTION_TYPE);</a>
<a name="ln511">		}</a>
<a name="ln512">		if (tag.tag == 0x10 &amp;&amp; tag.type == 4)</a>
<a name="ln513">			fUniqueID = fRead.Next&lt;uint32&gt;();</a>
<a name="ln514">		if (tag.tag == 0x11) {</a>
<a name="ln515">			if (_ParseTIFFImageFileDirectory(baseOffset, fRead.Next&lt;uint32&gt;())</a>
<a name="ln516">					== B_OK)</a>
<a name="ln517">				fNumImages++;</a>
<a name="ln518">		}</a>
<a name="ln519">		if (tag.tag == 0x14 &amp;&amp; tag.length == 2560 &amp;&amp; tag.type == 7) {</a>
<a name="ln520">			fRead.Seek(1248, SEEK_CUR);</a>
<a name="ln521">			goto get2_256;</a>
<a name="ln522">		}</a>
<a name="ln523">		if (tag.tag == 0x1d) {</a>
<a name="ln524">			int c;</a>
<a name="ln525">			while ((c = fRead.Next&lt;uint8&gt;()) &amp;&amp; c != EOF) {</a>
<a name="ln526">				serial = serial * 10 + (isdigit(c) ? c - '0' : c % 10);</a>
<a name="ln527">			}</a>
<a name="ln528">		}</a>
<a name="ln529">		if (tag.tag == 0x81 &amp;&amp; tag.type == 4) {</a>
<a name="ln530">			_Raw().data_offset = fRead.Next&lt;uint32&gt;();</a>
<a name="ln531">			fRead.Seek(_Raw().data_offset + 41, SEEK_SET);</a>
<a name="ln532">			_Raw().height = fRead.Next&lt;uint16&gt;() * 2;</a>
<a name="ln533">			_Raw().width  = fRead.Next&lt;uint16&gt;();</a>
<a name="ln534">			fFilters = 0x61616161;</a>
<a name="ln535">		}</a>
<a name="ln536">		if ((tag.tag == 0x81 &amp;&amp; tag.type == 7)</a>
<a name="ln537">			|| (tag.tag == 0x100 &amp;&amp; tag.type == 7)</a>
<a name="ln538">			|| (tag.tag == 0x280 &amp;&amp; tag.type == 1)) {</a>
<a name="ln539">			_Thumb().data_offset = fRead.Position();</a>
<a name="ln540">			_Thumb().bytes = tag.length;</a>
<a name="ln541">		}</a>
<a name="ln542">		if (tag.tag == 0x88 &amp;&amp; tag.type == 4</a>
<a name="ln543">			&amp;&amp; (_Thumb().data_offset = fRead.Next&lt;uint32&gt;())) {</a>
<a name="ln544">			_Thumb().data_offset += baseOffset;</a>
<a name="ln545">		}</a>
<a name="ln546">		if (tag.tag == 0x89 &amp;&amp; tag.type == 4)</a>
<a name="ln547">			_Thumb().bytes = fRead.Next&lt;uint32&gt;();</a>
<a name="ln548">		if (tag.tag == 0x8c)</a>
<a name="ln549">			fCurveOffset = fRead.Position() + 2112;</a>
<a name="ln550">		if (tag.tag == 0x96)</a>
<a name="ln551">			fCurveOffset = fRead.Position() + 2;</a>
<a name="ln552">		if (tag.tag == 0x97) {</a>
<a name="ln553">			for (uint32 i = 0; i &lt; 4; i++) {</a>
<a name="ln554">				ver97 = (ver97 &lt;&lt; 4) + fRead.Next&lt;uint8&gt;() - '0';</a>
<a name="ln555">			}</a>
<a name="ln556">			switch (ver97) {</a>
<a name="ln557">				case 0x100:</a>
<a name="ln558">					fRead.Seek(68, SEEK_CUR);</a>
<a name="ln559">					for (uint32 i = 0; i &lt; 4; i++) {</a>
<a name="ln560">						fMeta.camera_multipliers[(i &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; 1)]</a>
<a name="ln561">							= fRead.Next&lt;uint16&gt;();</a>
<a name="ln562">					}</a>
<a name="ln563">					break;</a>
<a name="ln564">				case 0x102:</a>
<a name="ln565">					fRead.Seek(6, SEEK_CUR);</a>
<a name="ln566">					goto get2_rggb;</a>
<a name="ln567">				case 0x103:</a>
<a name="ln568">					fRead.Seek(16, SEEK_CUR);</a>
<a name="ln569">					for (uint32 i = 0; i &lt; 4; i++) {</a>
<a name="ln570">						fMeta.camera_multipliers[i] = fRead.Next&lt;uint16&gt;();</a>
<a name="ln571">					}</a>
<a name="ln572">					break;</a>
<a name="ln573">			}</a>
<a name="ln574">			if (ver97 &gt;&gt; 8 == 2) {</a>
<a name="ln575">				if (ver97 != 0x205)</a>
<a name="ln576">					fRead.Seek(280, SEEK_CUR);</a>
<a name="ln577">				fRead(buf97, sizeof(buf97));</a>
<a name="ln578">			}</a>
<a name="ln579">		}</a>
<a name="ln580">		if (tag.tag == 0xa7 &amp;&amp; ver97 &gt;&gt; 8 == 2) {</a>
<a name="ln581">			ci = xlat[0][serial &amp; 0xff];</a>
<a name="ln582">			cj = xlat[1][fRead.Next&lt;uint8&gt;() ^ fRead.Next&lt;uint8&gt;()</a>
<a name="ln583">				^ fRead.Next&lt;uint8&gt;() ^ fRead.Next&lt;uint8&gt;()];</a>
<a name="ln584">			ck = 0x60;</a>
<a name="ln585">			for (uint32 i = 0; i &lt; 324; i++) {</a>
<a name="ln586">				buf97[i] ^= (cj += ci * ck++);</a>
<a name="ln587">			}</a>
<a name="ln588">			for (uint32 i = 0; i &lt; 4; i++) {</a>
<a name="ln589">				uint16* data = (uint16*)(buf97</a>
<a name="ln590">					+ (ver97 == 0x205 ? 14 : 6) + i * 2);</a>
<a name="ln591"> </a>
<a name="ln592">				if (fRead.IsSwapping()) {</a>
<a name="ln593">					fMeta.camera_multipliers[i ^ (i &gt;&gt; 1)]</a>
<a name="ln594">						= __swap_int16(*data);</a>
<a name="ln595">				} else {</a>
<a name="ln596">					fMeta.camera_multipliers[i ^ (i &gt;&gt; 1)] = *data;</a>
<a name="ln597">				}</a>
<a name="ln598">			}</a>
<a name="ln599">		}</a>
<a name="ln600">		if (tag.tag == 0x200 &amp;&amp; tag.length == 4) {</a>
<a name="ln601">			fMeta.black = (fRead.Next&lt;uint16&gt;() + fRead.Next&lt;uint16&gt;()</a>
<a name="ln602">				+ fRead.Next&lt;uint16&gt;() + fRead.Next&lt;uint16&gt;()) / 4;</a>
<a name="ln603">		}</a>
<a name="ln604">		if (tag.tag == 0x201 &amp;&amp; tag.length == 4)</a>
<a name="ln605">			goto get2_rggb;</a>
<a name="ln606">		if (tag.tag == 0x401 &amp;&amp; tag.length == 4) {</a>
<a name="ln607">			fMeta.black = (fRead.Next&lt;uint32&gt;() + fRead.Next&lt;uint32&gt;()</a>
<a name="ln608">				+ fRead.Next&lt;uint32&gt;() + fRead.Next&lt;uint32&gt;()) / 4;</a>
<a name="ln609">		}</a>
<a name="ln610">		if (tag.tag == 0xe01) {</a>
<a name="ln611">			// Nikon Capture Note</a>
<a name="ln612">			bool previousSwap = fRead.IsSwapping();</a>
<a name="ln613">			fRead.SetSwap(B_HOST_IS_BENDIAN != 0);</a>
<a name="ln614">				// this chunk is always in little endian</a>
<a name="ln615"> </a>
<a name="ln616">			off_t offset = 22;</a>
<a name="ln617">			fRead.Seek(offset, SEEK_CUR);</a>
<a name="ln618"> </a>
<a name="ln619">			int32 i = 0;</a>
<a name="ln620"> </a>
<a name="ln621">			for (; offset + 22 &lt; tag.length; offset += 22 + i) {</a>
<a name="ln622">				tag.tag = fRead.Next&lt;uint32&gt;();</a>
<a name="ln623">				fRead.Seek(14, SEEK_CUR);</a>
<a name="ln624">				i = fRead.Next&lt;uint32&gt;() - 4;</a>
<a name="ln625">				if (tag.tag == 0x76a43207)</a>
<a name="ln626">					fMeta.flip = fRead.Next&lt;uint16&gt;();</a>
<a name="ln627">				else</a>
<a name="ln628">					fRead.Seek(i, SEEK_CUR);</a>
<a name="ln629">			}</a>
<a name="ln630"> </a>
<a name="ln631">			fRead.SetSwap(previousSwap);</a>
<a name="ln632">		}</a>
<a name="ln633">		if (tag.tag == 0xe80 &amp;&amp; tag.length == 256 &amp;&amp; tag.type == 7) {</a>
<a name="ln634">			fRead.Seek(48, SEEK_CUR);</a>
<a name="ln635">			fMeta.camera_multipliers[0]</a>
<a name="ln636">				= fRead.Next&lt;uint16&gt;() * 508 * 1.078 / 0x10000;</a>
<a name="ln637">			fMeta.camera_multipliers[2]</a>
<a name="ln638">				= fRead.Next&lt;uint16&gt;() * 382 * 1.173 / 0x10000;</a>
<a name="ln639">		}</a>
<a name="ln640">		if (tag.tag == 0xf00 &amp;&amp; tag.type == 7) {</a>
<a name="ln641">			if (tag.length == 614)</a>
<a name="ln642">				fRead.Seek(176, SEEK_CUR);</a>
<a name="ln643">			else if (tag.length == 734 || tag.length == 1502)</a>
<a name="ln644">				fRead.Seek(148, SEEK_CUR);</a>
<a name="ln645">			else</a>
<a name="ln646">				goto next;</a>
<a name="ln647">			goto get2_256;</a>
<a name="ln648">		}</a>
<a name="ln649">		if (tag.tag == 0x1011 &amp;&amp; tag.length == 9 &amp;&amp; fUseCameraWhiteBalance) {</a>
<a name="ln650">			for (uint32 i = 0; i &lt; 3; i++) {</a>
<a name="ln651">				for (uint32 j = 0; j &lt; 3; j++) {</a>
<a name="ln652">					fMeta.rgb_camera[i][j] = fRead.Next&lt;int16&gt;() / 256.0;</a>
<a name="ln653">				}</a>
<a name="ln654">			}</a>
<a name="ln655">			fRawColor = fMeta.rgb_camera[0][0] &lt; 1;</a>
<a name="ln656">		}</a>
<a name="ln657">		if (tag.tag == 0x1012 &amp;&amp; tag.length == 4) {</a>
<a name="ln658">			fMeta.black = 0;</a>
<a name="ln659">			for (uint32 i = 0; i &lt; 4; i++) {</a>
<a name="ln660">				fMeta.black += fRead.Next&lt;uint16&gt;() &lt;&lt; 2;</a>
<a name="ln661">			}</a>
<a name="ln662">		}</a>
<a name="ln663">		if (tag.tag == 0x1017)</a>
<a name="ln664">			fMeta.camera_multipliers[0] = fRead.Next&lt;uint16&gt;() / 256.0;</a>
<a name="ln665">		if (tag.tag == 0x1018)</a>
<a name="ln666">			fMeta.camera_multipliers[2] = fRead.Next&lt;uint16&gt;() / 256.0;</a>
<a name="ln667"> </a>
<a name="ln668">		if (tag.tag == 0x2011 &amp;&amp; tag.length == 2) {</a>
<a name="ln669">get2_256:</a>
<a name="ln670">			bool previousSwap = fRead.IsSwapping();</a>
<a name="ln671">			fRead.SetSwap(B_HOST_IS_LENDIAN != 0);</a>
<a name="ln672">				// this chunk is always in big endian</a>
<a name="ln673"> </a>
<a name="ln674">			fMeta.camera_multipliers[0] = fRead.Next&lt;uint16&gt;() / 256.0;</a>
<a name="ln675">			fMeta.camera_multipliers[2] = fRead.Next&lt;uint16&gt;() / 256.0;</a>
<a name="ln676"> </a>
<a name="ln677">			fRead.SetSwap(previousSwap);</a>
<a name="ln678">		}</a>
<a name="ln679"> </a>
<a name="ln680">		if (tag.tag == 0x2020)</a>
<a name="ln681">			_ParseThumbTag(baseOffset, 257, 258);</a>
<a name="ln682">		if (tag.tag == 0xb028) {</a>
<a name="ln683">			fRead.Seek(fRead.Next&lt;uint32&gt;(), SEEK_SET);</a>
<a name="ln684">			_ParseThumbTag(baseOffset, 136, 137);</a>
<a name="ln685">		}</a>
<a name="ln686"> </a>
<a name="ln687">		if (tag.tag == 0x4001) {</a>
<a name="ln688">			{</a>
<a name="ln689">				off_t offset = tag.length == 582 ? 50 : tag.length == 653</a>
<a name="ln690">					? 68 : 126;</a>
<a name="ln691">				fRead.Seek(offset, SEEK_CUR);</a>
<a name="ln692">			}</a>
<a name="ln693">get2_rggb:</a>
<a name="ln694">			for (uint32 i = 0; i &lt; 4; i++) {</a>
<a name="ln695">				fMeta.camera_multipliers[i ^ (i &gt;&gt; 1)] = fRead.Next&lt;uint16&gt;();</a>
<a name="ln696">			}</a>
<a name="ln697">		}</a>
<a name="ln698"> </a>
<a name="ln699">next:</a>
<a name="ln700">    	fRead.Seek(nextOffset, SEEK_SET);</a>
<a name="ln701">	}</a>
<a name="ln702"> </a>
<a name="ln703">quit:</a>
<a name="ln704">	fRead.SetSwap(originalSwap);</a>
<a name="ln705">}</a>
<a name="ln706"> </a>
<a name="ln707"> </a>
<a name="ln708">void</a>
<a name="ln709">DCRaw::_ParseEXIF(off_t baseOffset)</a>
<a name="ln710">{</a>
<a name="ln711">	bool kodak = !strncmp(fMeta.manufacturer, &quot;EASTMAN&quot;, 7);</a>
<a name="ln712"> </a>
<a name="ln713">	uint16 entries;</a>
<a name="ln714">	fRead(entries);</a>
<a name="ln715"> </a>
<a name="ln716">	while (entries--) {</a>
<a name="ln717">		off_t nextOffset;</a>
<a name="ln718">		tiff_tag tag;</a>
<a name="ln719">		_ParseTIFFTag(baseOffset, tag, nextOffset);</a>
<a name="ln720">		TAG(&quot;EXIF tag %u (type %u, length %lu)\n&quot;, tag.tag, tag.type,</a>
<a name="ln721">			tag.length);</a>
<a name="ln722"> </a>
<a name="ln723">		switch (tag.tag) {</a>
<a name="ln724">#if 0</a>
<a name="ln725">			default:</a>
<a name="ln726">				printf(&quot;  unhandled EXIF tag %u\n&quot;, tag.tag);</a>
<a name="ln727">				break;</a>
<a name="ln728">#endif</a>
<a name="ln729">			case 33434:</a>
<a name="ln730">				fMeta.shutter = fRead.NextDouble(TIFF_FRACTION_TYPE);</a>
<a name="ln731">				break;</a>
<a name="ln732">			case 33437:</a>
<a name="ln733">				fMeta.aperture = fRead.NextDouble(TIFF_FRACTION_TYPE);</a>
<a name="ln734">				break;</a>
<a name="ln735">			case 34855:</a>
<a name="ln736">				fMeta.iso_speed = fRead.Next&lt;uint16&gt;();</a>
<a name="ln737">				break;</a>
<a name="ln738">			case 36867:</a>
<a name="ln739">			case 36868:</a>
<a name="ln740">				fMeta.timestamp = _ParseTIFFTimestamp(false);</a>
<a name="ln741">				break;</a>
<a name="ln742">			case 37377:</a>
<a name="ln743">			{</a>
<a name="ln744">				double expo;</a>
<a name="ln745">				if ((expo = -fRead.NextDouble(TIFF_FRACTION_TYPE)) &lt; 128)</a>
<a name="ln746">					fMeta.shutter = pow(2, expo);</a>
<a name="ln747">				break;</a>
<a name="ln748">			}</a>
<a name="ln749">			case 37378:</a>
<a name="ln750">				fMeta.aperture</a>
<a name="ln751">					= pow(2, fRead.NextDouble(TIFF_FRACTION_TYPE) / 2);</a>
<a name="ln752">				break;</a>
<a name="ln753">			case 37386:</a>
<a name="ln754">				fMeta.focal_length = fRead.NextDouble(TIFF_FRACTION_TYPE);</a>
<a name="ln755">				break;</a>
<a name="ln756">			case 37500:</a>
<a name="ln757">				_ParseManufacturerTag(baseOffset);</a>
<a name="ln758">				break;</a>
<a name="ln759">			case 40962:</a>
<a name="ln760">				if (kodak)</a>
<a name="ln761">					_Raw().width = fRead.Next&lt;uint32&gt;();</a>
<a name="ln762">				break;</a>
<a name="ln763">			case 40963:</a>
<a name="ln764">				if (kodak)</a>
<a name="ln765">					_Raw().height = fRead.Next&lt;uint32&gt;();</a>
<a name="ln766">				break;</a>
<a name="ln767">			case 41730:</a>
<a name="ln768">				if (fRead.Next&lt;uint32&gt;() == 0x20002) {</a>
<a name="ln769">					fEXIFFilters = 0;</a>
<a name="ln770">					for (uint32 c = 0; c &lt; 8; c += 2) {</a>
<a name="ln771">						fEXIFFilters |= fRead.Next&lt;uint8&gt;() * 0x01010101 &lt;&lt; c;</a>
<a name="ln772">					}</a>
<a name="ln773">				}</a>
<a name="ln774">				break;</a>
<a name="ln775">		}</a>
<a name="ln776"> </a>
<a name="ln777">		fRead.Seek(nextOffset, SEEK_SET);</a>
<a name="ln778">	}</a>
<a name="ln779">}</a>
<a name="ln780"> </a>
<a name="ln781"> </a>
<a name="ln782">void</a>
<a name="ln783">DCRaw::_ParseLinearTable(uint32 length)</a>
<a name="ln784">{</a>
<a name="ln785">	if (length &gt; 0x1000)</a>
<a name="ln786">		length = 0x1000;</a>
<a name="ln787"> </a>
<a name="ln788">	fRead.NextShorts(fCurve, length);</a>
<a name="ln789"> </a>
<a name="ln790">	for (uint32 i = length; i &lt; 0x1000; i++) {</a>
<a name="ln791">		fCurve[i] = fCurve[i - 1];</a>
<a name="ln792">	}</a>
<a name="ln793"> </a>
<a name="ln794">	fMeta.maximum = fCurve[0xfff];</a>
<a name="ln795">}</a>
<a name="ln796"> </a>
<a name="ln797"> </a>
<a name="ln798">/*!	This (lengthy) method contains fixes for the values in the image data to</a>
<a name="ln799">	be able to actually read the image data correctly.</a>
<a name="ln800">*/</a>
<a name="ln801">void</a>
<a name="ln802">DCRaw::_FixupValues()</a>
<a name="ln803">{</a>
<a name="ln804">	// PENTAX and SAMSUNG section</a>
<a name="ln805">	// (Samsung sells rebranded Pentax cameras)</a>
<a name="ln806"> </a>
<a name="ln807">	if (_IsPentax() || _IsSamsung()) {</a>
<a name="ln808">		if (fInputWidth == 3936 &amp;&amp; fInputHeight == 2624) {</a>
<a name="ln809">			// Pentax K10D and Samsumg GX10</a>
<a name="ln810">			fInputWidth = 3896;</a>
<a name="ln811">			fInputHeight = 2616;</a>
<a name="ln812">		}</a>
<a name="ln813">	}</a>
<a name="ln814"> </a>
<a name="ln815">	// CANON</a>
<a name="ln816"> </a>
<a name="ln817">	if (_IsCanon()) {</a>
<a name="ln818">		bool isCR2 = false;</a>
<a name="ln819">		if (strstr(fMeta.model, &quot;EOS D2000C&quot;)) {</a>
<a name="ln820">			fFilters = 0x61616161;</a>
<a name="ln821">			fMeta.black = fCurve[200];</a>
<a name="ln822">		}</a>
<a name="ln823"> </a>
<a name="ln824">		switch (_Raw().width) {</a>
<a name="ln825">			case 2144:</a>
<a name="ln826">				fInputHeight = 1550;</a>
<a name="ln827">				fInputWidth = 2088;</a>
<a name="ln828">				fTopMargin = 8;</a>
<a name="ln829">				fLeftMargin = 4;</a>
<a name="ln830">				if (!strcmp(fMeta.model, &quot;PowerShot G1&quot;)) {</a>
<a name="ln831">					fColors = 4;</a>
<a name="ln832">					fFilters = 0xb4b4b4b4;</a>
<a name="ln833">				}</a>
<a name="ln834">				break;</a>
<a name="ln835"> </a>
<a name="ln836">			case 2224:</a>
<a name="ln837">				fInputHeight = 1448;</a>
<a name="ln838">				fInputWidth = 2176;</a>
<a name="ln839">				fTopMargin = 6;</a>
<a name="ln840">				fLeftMargin = 48;</a>
<a name="ln841">				break;</a>
<a name="ln842"> </a>
<a name="ln843">			case 2376:</a>
<a name="ln844">				fInputHeight = 1720;</a>
<a name="ln845">				fInputWidth = 2312;</a>
<a name="ln846">				fTopMargin = 6;</a>
<a name="ln847">				fLeftMargin = 12;</a>
<a name="ln848">				break;</a>
<a name="ln849"> </a>
<a name="ln850">			case 2672:</a>
<a name="ln851">				fInputHeight = 1960;</a>
<a name="ln852">				fInputWidth = 2616;</a>
<a name="ln853">				fTopMargin = 6;</a>
<a name="ln854">				fLeftMargin = 12;</a>
<a name="ln855">				break;</a>
<a name="ln856"> </a>
<a name="ln857">			case 3152:</a>
<a name="ln858">				fInputHeight = 2056;</a>
<a name="ln859">				fInputWidth = 3088;</a>
<a name="ln860">				fTopMargin = 12;</a>
<a name="ln861">				fLeftMargin = 64;</a>
<a name="ln862">				if (fUniqueID == 0x80000170)</a>
<a name="ln863">					_AdobeCoefficients(&quot;Canon&quot;, &quot;EOS 300D&quot;);</a>
<a name="ln864">				fMeta.maximum = 0xfa0;</a>
<a name="ln865">				break;</a>
<a name="ln866"> </a>
<a name="ln867">			case 3160:</a>
<a name="ln868">				fInputHeight = 2328;</a>
<a name="ln869">				fInputWidth = 3112;</a>
<a name="ln870">				fTopMargin = 12;</a>
<a name="ln871">				fLeftMargin = 44;</a>
<a name="ln872">				break;</a>
<a name="ln873"> </a>
<a name="ln874">			case 3344:</a>
<a name="ln875">				fInputHeight = 2472;</a>
<a name="ln876">				fInputWidth = 3288;</a>
<a name="ln877">				fTopMargin = 6;</a>
<a name="ln878">				fLeftMargin = 4;</a>
<a name="ln879">				break;</a>
<a name="ln880"> </a>
<a name="ln881">			case 3516:</a>
<a name="ln882">				fTopMargin = 14;</a>
<a name="ln883">				fLeftMargin = 42;</a>
<a name="ln884">				if (fUniqueID == 0x80000189)</a>
<a name="ln885">					_AdobeCoefficients(&quot;Canon&quot;, &quot;EOS 350D&quot;);</a>
<a name="ln886">				isCR2 = true;</a>
<a name="ln887">				break;</a>
<a name="ln888"> </a>
<a name="ln889">			case 3596:</a>
<a name="ln890">				fTopMargin = 12;</a>
<a name="ln891">				fLeftMargin = 74;</a>
<a name="ln892">				isCR2 = true;</a>
<a name="ln893">				break;</a>
<a name="ln894"> </a>
<a name="ln895">			case 3948:</a>
<a name="ln896">				fTopMargin = 18;</a>
<a name="ln897">				fLeftMargin = 42;</a>
<a name="ln898">				fInputHeight -= 2;</a>
<a name="ln899">				if (fUniqueID == 0x80000236)</a>
<a name="ln900">					_AdobeCoefficients(&quot;Canon&quot;, &quot;EOS 400D&quot;);</a>
<a name="ln901">				isCR2 = true;</a>
<a name="ln902">				break;</a>
<a name="ln903"> </a>
<a name="ln904">			case 3984:</a>
<a name="ln905">				fTopMargin  = 20;</a>
<a name="ln906">				fLeftMargin = 76;</a>
<a name="ln907">				fInputHeight -= 2;</a>
<a name="ln908">				fMeta.maximum = 0x3bb0;</a>
<a name="ln909">				isCR2 = true;</a>
<a name="ln910">				break;</a>
<a name="ln911"> </a>
<a name="ln912">			case 4476:</a>
<a name="ln913">				fTopMargin  = 34;</a>
<a name="ln914">				fLeftMargin = 90;</a>
<a name="ln915">				fMeta.maximum = 0xe6c;</a>
<a name="ln916">				isCR2 = true;</a>
<a name="ln917">				break;</a>
<a name="ln918"> </a>
<a name="ln919">			case 5108:</a>
<a name="ln920">				fTopMargin  = 13;</a>
<a name="ln921">				fLeftMargin = 98;</a>
<a name="ln922">				fMeta.maximum = 0xe80;</a>
<a name="ln923">				isCR2 = true;</a>
<a name="ln924">				break;</a>
<a name="ln925">		}</a>
<a name="ln926"> </a>
<a name="ln927">		if (isCR2) {</a>
<a name="ln928">			fInputHeight -= fTopMargin;</a>
<a name="ln929">			fInputWidth -= fLeftMargin;</a>
<a name="ln930">		}</a>
<a name="ln931">	}</a>
<a name="ln932"> </a>
<a name="ln933">	// Olympus</a>
<a name="ln934"> </a>
<a name="ln935">	if (_IsOlympus()) {</a>
<a name="ln936">		if (!strcmp(fMeta.model,&quot;E-300&quot;) || !strcmp(fMeta.model,&quot;E-500&quot;)) {</a>
<a name="ln937">			fInputWidth -= 20;</a>
<a name="ln938">			fMeta.maximum = 0xfc30;</a>
<a name="ln939">			//if (load_raw == &amp;CLASS unpacked_load_raw) black = 0;</a>
<a name="ln940">		}</a>
<a name="ln941">	}</a>
<a name="ln942">}</a>
<a name="ln943"> </a>
<a name="ln944"> </a>
<a name="ln945">//	#pragma mark - Image Conversion</a>
<a name="ln946"> </a>
<a name="ln947"> </a>
<a name="ln948">void</a>
<a name="ln949">DCRaw::_ScaleColors()</a>
<a name="ln950">{</a>
<a name="ln951">	if (fProgressMonitor != NULL)</a>
<a name="ln952">		fProgressMonitor(&quot;Scale Colors&quot;, 5, fProgressData);</a>
<a name="ln953"> </a>
<a name="ln954">	int c, val, sum[8];</a>
<a name="ln955">	uint32 row, col, x, y;</a>
<a name="ln956">	double dsum[8], dmin, dmax;</a>
<a name="ln957">	float scale_mul[4];</a>
<a name="ln958"> </a>
<a name="ln959">	if (fUseCameraWhiteBalance &amp;&amp; fMeta.camera_multipliers[0] != -1) {</a>
<a name="ln960">		memset(sum, 0, sizeof(sum));</a>
<a name="ln961">		for (row = 0; row &lt; 8; row++) {</a>
<a name="ln962">			for (col = 0; col &lt; 8; col++) {</a>
<a name="ln963">				c = FC(row, col);</a>
<a name="ln964">				if ((val = fWhite[row][col] - fMeta.black) &gt; 0)</a>
<a name="ln965">					sum[c] += val;</a>
<a name="ln966">				sum[c + 4]++;</a>
<a name="ln967">			}</a>
<a name="ln968">		}</a>
<a name="ln969"> </a>
<a name="ln970">		if (sum[0] &amp;&amp; sum[1] &amp;&amp; sum[2] &amp;&amp; sum[3]) {</a>
<a name="ln971">			for (int c = 0; c &lt; 4; c++) {</a>
<a name="ln972">				fMeta.pre_multipliers[c] = (float)sum[c+4] / sum[c];</a>
<a name="ln973">			}</a>
<a name="ln974">		} else if (fMeta.camera_multipliers[0] &amp;&amp; fMeta.camera_multipliers[2]) {</a>
<a name="ln975">			memcpy(fMeta.pre_multipliers, fMeta.camera_multipliers,</a>
<a name="ln976">				sizeof(fMeta.pre_multipliers));</a>
<a name="ln977">		} else</a>
<a name="ln978">			fprintf(stderr, &quot;Cannot use camera white balance.\n&quot;);</a>
<a name="ln979">	} else if (fUseAutoWhiteBalance) {</a>
<a name="ln980">		memset(dsum, 0, sizeof(dsum));</a>
<a name="ln981">		for (row = 0; row &lt; fOutputHeight - 7; row += 8) {</a>
<a name="ln982">			for (col = 0; col &lt; fOutputWidth - 7; col += 8) {</a>
<a name="ln983">				memset(sum, 0, sizeof(sum));</a>
<a name="ln984">				for (y = row; y &lt; row + 8; y++) {</a>
<a name="ln985">					for (x = col; x &lt; col + 8; x++) {</a>
<a name="ln986">						for (int c = 0; c &lt; 4; c++) {</a>
<a name="ln987">							val = fImageData[y * fOutputWidth + x][c];</a>
<a name="ln988">							if (!val)</a>
<a name="ln989">								continue;</a>
<a name="ln990">							if (val &gt; fMeta.maximum - 25)</a>
<a name="ln991">								goto skip_block;</a>
<a name="ln992">							val -= fMeta.black;</a>
<a name="ln993">							if (val &lt; 0)</a>
<a name="ln994">								val = 0;</a>
<a name="ln995">							sum[c] += val;</a>
<a name="ln996">							sum[c+4]++;</a>
<a name="ln997">						}</a>
<a name="ln998">					}</a>
<a name="ln999">				}</a>
<a name="ln1000"> </a>
<a name="ln1001">				for (c=0; c &lt; 8; c++) {</a>
<a name="ln1002">					dsum[c] += sum[c];</a>
<a name="ln1003">				}</a>
<a name="ln1004"> </a>
<a name="ln1005">			skip_block:</a>
<a name="ln1006">				continue;</a>
<a name="ln1007">			}</a>
<a name="ln1008">		}</a>
<a name="ln1009">		for (int c = 0; c &lt; 4; c++) {</a>
<a name="ln1010">			if (dsum[c])</a>
<a name="ln1011">				fMeta.pre_multipliers[c] = dsum[c + 4] / dsum[c];</a>
<a name="ln1012">		}</a>
<a name="ln1013">	}</a>
<a name="ln1014"> </a>
<a name="ln1015"> </a>
<a name="ln1016">	if (fUserMultipliers[0]) {</a>
<a name="ln1017">		memcpy(fMeta.pre_multipliers, fUserMultipliers,</a>
<a name="ln1018">			sizeof(fMeta.pre_multipliers));</a>
<a name="ln1019">	}</a>
<a name="ln1020">	if (fMeta.pre_multipliers[3] == 0)</a>
<a name="ln1021">		fMeta.pre_multipliers[3] = fColors &lt; 4 ? fMeta.pre_multipliers[1] : 1;</a>
<a name="ln1022"> </a>
<a name="ln1023">#if 0</a>
<a name="ln1024">	int dblack = fMeta.black;</a>
<a name="ln1025">#endif</a>
<a name="ln1026">	if (fThreshold)</a>
<a name="ln1027">		_WaveletDenoise();</a>
<a name="ln1028"> </a>
<a name="ln1029">	fMeta.maximum -= fMeta.black;</a>
<a name="ln1030">	for (dmin = DBL_MAX, dmax = c = 0; c &lt; 4; c++) {</a>
<a name="ln1031">		if (dmin &gt; fMeta.pre_multipliers[c])</a>
<a name="ln1032">			dmin = fMeta.pre_multipliers[c];</a>
<a name="ln1033">		if (dmax &lt; fMeta.pre_multipliers[c])</a>
<a name="ln1034">			dmax = fMeta.pre_multipliers[c];</a>
<a name="ln1035">	}</a>
<a name="ln1036"> </a>
<a name="ln1037">	if (!fHighlight)</a>
<a name="ln1038">		dmax = dmin;</a>
<a name="ln1039"> </a>
<a name="ln1040">	for (int c = 0; c &lt; 4; c++) {</a>
<a name="ln1041">		scale_mul[c] = (fMeta.pre_multipliers[c] /= dmax) * 65535.0</a>
<a name="ln1042">			/ fMeta.maximum;</a>
<a name="ln1043">	}</a>
<a name="ln1044"> </a>
<a name="ln1045">#if 0</a>
<a name="ln1046">	if (1/*verbose*/) {</a>
<a name="ln1047">		fprintf(stderr, &quot;Scaling with black %d, multipliers&quot;, dblack);</a>
<a name="ln1048">		for (int c = 0; c &lt; 4; c++) {</a>
<a name="ln1049">			fprintf(stderr, &quot; %f&quot;, fMeta.pre_multipliers[c]);</a>
<a name="ln1050">		}</a>
<a name="ln1051">		fputc('\n', stderr);</a>
<a name="ln1052">	}</a>
<a name="ln1053">#endif</a>
<a name="ln1054"> </a>
<a name="ln1055">	for (row = 0; row &lt; fOutputHeight; row++) {</a>
<a name="ln1056">		for (col = 0; col &lt; fOutputWidth; col++) {</a>
<a name="ln1057">			for (int c = 0; c &lt; 4; c++) {</a>
<a name="ln1058">				val = fImageData[row * fOutputWidth + col][c];</a>
<a name="ln1059">				if (!val)</a>
<a name="ln1060">					continue;</a>
<a name="ln1061">				val -= fMeta.black;</a>
<a name="ln1062">				val = int(val * scale_mul[c]);</a>
<a name="ln1063">				fImageData[row * fOutputWidth + col][c] = CLIP(val);</a>
<a name="ln1064">			}</a>
<a name="ln1065">		}</a>
<a name="ln1066">	}</a>
<a name="ln1067">}</a>
<a name="ln1068"> </a>
<a name="ln1069"> </a>
<a name="ln1070">void</a>
<a name="ln1071">DCRaw::_WaveletDenoise()</a>
<a name="ln1072">{</a>
<a name="ln1073">	if (fProgressMonitor != NULL)</a>
<a name="ln1074">		fProgressMonitor(&quot;Wavelet Denoise&quot;, 8, fProgressData);</a>
<a name="ln1075"> </a>
<a name="ln1076">	float *fimg, *temp, mul[2], avg, diff;</a>
<a name="ln1077">	int32 scale = 1, sh, c, i, j, k, m, row, col, size, numColors, dim = 0;</a>
<a name="ln1078">	int32 wlast;</a>
<a name="ln1079">	ushort *window[4];</a>
<a name="ln1080">	// Daubechies 9-tap/7-tap filter</a>
<a name="ln1081">	static const float wlet[] =	{ 1.149604398, -1.586134342,</a>
<a name="ln1082">		-0.05298011854, 0.8829110762, 0.4435068522 };</a>
<a name="ln1083"> </a>
<a name="ln1084">	while ((fMeta.maximum &lt;&lt; scale) &lt; 0x10000) {</a>
<a name="ln1085">		scale++;</a>
<a name="ln1086">	}</a>
<a name="ln1087">	fMeta.maximum &lt;&lt;= fMeta.maximum &lt;&lt; --scale;</a>
<a name="ln1088">	fMeta.black &lt;&lt;= scale;</a>
<a name="ln1089"> </a>
<a name="ln1090">	while ((1UL &lt;&lt; dim) &lt; fOutputWidth || (1UL &lt;&lt; dim) &lt; fOutputHeight) {</a>
<a name="ln1091">		dim++;</a>
<a name="ln1092">	}</a>
<a name="ln1093"> </a>
<a name="ln1094">	fimg = (float *)calloc((1UL &lt;&lt; dim*2) + (1UL &lt;&lt; dim) + 2, sizeof *fimg);</a>
<a name="ln1095">	if (fimg == NULL)</a>
<a name="ln1096">		return;</a>
<a name="ln1097"> </a>
<a name="ln1098">	temp = fimg + (1 &lt;&lt; dim * 2) + 1;</a>
<a name="ln1099">	numColors = fColors;</a>
<a name="ln1100">	if (numColors == 3 &amp;&amp; fFilters)</a>
<a name="ln1101">		numColors++;</a>
<a name="ln1102"> </a>
<a name="ln1103">	for (c = 0; c &lt; numColors; c++) {</a>
<a name="ln1104">		// denoise R,G1,B,G3 individually</a>
<a name="ln1105">		for (row = 0; row &lt; (int32)fOutputHeight; row++) {</a>
<a name="ln1106">			for (col = 0; col &lt; (int32)fOutputWidth; col++) {</a>
<a name="ln1107">				fimg[(row &lt;&lt; dim) + col]</a>
<a name="ln1108">					= fImageData[row * fOutputWidth + col][c] &lt;&lt; scale;</a>
<a name="ln1109">			}</a>
<a name="ln1110">		}</a>
<a name="ln1111">		for (size = 1UL &lt;&lt; dim; size &gt; 1; size &gt;&gt;= 1) {</a>
<a name="ln1112">			for (sh = 0; sh &lt;= dim; sh += dim) {</a>
<a name="ln1113">				for (i = 0; i &lt; size; i++) {</a>
<a name="ln1114">					for (j = 0; j &lt; size; j++) {</a>
<a name="ln1115">						temp[j] = fimg[(i &lt;&lt; (dim - sh)) + (j &lt;&lt; sh)];</a>
<a name="ln1116">					}</a>
<a name="ln1117">					for (k = 1; k &lt; 5; k += 2) {</a>
<a name="ln1118">						temp[size] = temp[size - 2];</a>
<a name="ln1119">						for (m = 1; m &lt; size; m += 2) {</a>
<a name="ln1120">							temp[m] += wlet[k] * (temp[m - 1] + temp[m + 1]);</a>
<a name="ln1121">						}</a>
<a name="ln1122">						temp[-1] = temp[1];</a>
<a name="ln1123">						for (m = 0; m &lt; size; m += 2) {</a>
<a name="ln1124">							temp[m] += wlet[k + 1]</a>
<a name="ln1125">								* (temp[m - 1] + temp[m + 1]);</a>
<a name="ln1126">						}</a>
<a name="ln1127">					}</a>
<a name="ln1128">					for (m = 0; m &lt; size; m++) {</a>
<a name="ln1129">						temp[m] *= (m &amp; 1) ? 1 / wlet[0] : wlet[0];</a>
<a name="ln1130">					}</a>
<a name="ln1131">					for (j = k = 0; j &lt; size; j++, k += 2) {</a>
<a name="ln1132">						if (k == size)</a>
<a name="ln1133">							k = 1;</a>
<a name="ln1134">						fimg[(i &lt;&lt; (dim - sh)) + (j &lt;&lt; sh)] = temp[k];</a>
<a name="ln1135">					}</a>
<a name="ln1136">				}</a>
<a name="ln1137">			}</a>
<a name="ln1138">		}</a>
<a name="ln1139"> </a>
<a name="ln1140">		for (i = 0; i &lt; (1 &lt;&lt; dim * 2); i++) {</a>
<a name="ln1141">			if (fimg[i] &lt; -fThreshold)</a>
<a name="ln1142">				fimg[i] += fThreshold;</a>
<a name="ln1143">			else if (fimg[i] &gt; fThreshold)</a>
<a name="ln1144">				fimg[i] -= fThreshold;</a>
<a name="ln1145">			else</a>
<a name="ln1146">				fimg[i] = 0;</a>
<a name="ln1147">		}</a>
<a name="ln1148"> </a>
<a name="ln1149">		for (size = 2; size &lt;= (1 &lt;&lt; dim); size &lt;&lt;= 1) {</a>
<a name="ln1150">			for (sh = dim; sh &gt;= 0; sh -= dim) {</a>
<a name="ln1151">				for (i = 0; i &lt; size; i++) {</a>
<a name="ln1152">					for (j = k = 0; j &lt; size; j++, k += 2) {</a>
<a name="ln1153">						if (k == size)</a>
<a name="ln1154">							k = 1;</a>
<a name="ln1155">						temp[k] = fimg[(i &lt;&lt; (dim - sh)) + (j &lt;&lt; sh)];</a>
<a name="ln1156">					}</a>
<a name="ln1157">					for (m = 0; m &lt; size; m++) {</a>
<a name="ln1158">						temp[m] *= (m &amp; 1) ? wlet[0] : 1 / wlet[0];</a>
<a name="ln1159">					}</a>
<a name="ln1160">					for (k = 3; k &gt; 0; k -= 2) {</a>
<a name="ln1161">						temp[-1] = temp[1];</a>
<a name="ln1162">						for (m = 0; m &lt; size; m += 2) {</a>
<a name="ln1163">							temp[m] -= wlet[k + 1]</a>
<a name="ln1164">								* (temp[m - 1] + temp[m + 1]);</a>
<a name="ln1165">						}</a>
<a name="ln1166">						temp[size] = temp[size - 2];</a>
<a name="ln1167">						for (m = 1; m &lt; size; m += 2) {</a>
<a name="ln1168">							temp[m] -= wlet[k] * (temp[m - 1] + temp[m + 1]);</a>
<a name="ln1169">						}</a>
<a name="ln1170">					}</a>
<a name="ln1171">					for (j = 0; j &lt; size; j++) {</a>
<a name="ln1172">						fimg[(i &lt;&lt; (dim - sh)) + (j &lt;&lt; sh)] = temp[j];</a>
<a name="ln1173">					}</a>
<a name="ln1174">				}</a>
<a name="ln1175">			}</a>
<a name="ln1176">		}</a>
<a name="ln1177"> </a>
<a name="ln1178">		for (row = 0; row &lt; (int32)fOutputHeight; row++) {</a>
<a name="ln1179">			for (col = 0; col &lt; (int32)fOutputWidth; col++) {</a>
<a name="ln1180">				fImageData[row * fOutputWidth + col][c]</a>
<a name="ln1181">					= (uint16)CLIP(fimg[(row &lt;&lt; dim) + col] + 0.5);</a>
<a name="ln1182">			}</a>
<a name="ln1183">		}</a>
<a name="ln1184">	}</a>
<a name="ln1185"> </a>
<a name="ln1186">	if (fFilters &amp;&amp; fColors == 3) {</a>
<a name="ln1187">		// pull G1 and G3 closer together</a>
<a name="ln1188">		for (row = 0; row &lt; 2; row++) {</a>
<a name="ln1189">			mul[row] = 0.125 * fMeta.pre_multipliers[FC(row + 1, 0) | 1]</a>
<a name="ln1190">				/ fMeta.pre_multipliers[FC(row, 0) | 1];</a>
<a name="ln1191">		}</a>
<a name="ln1192">		for (i = 0; i &lt; 4; i++) {</a>
<a name="ln1193">			window[i] = (ushort *)fimg + fInputWidth * i;</a>
<a name="ln1194">		}</a>
<a name="ln1195">		for (wlast = -1, row = 1; row &lt; (int32)fInputHeight - 1; row++) {</a>
<a name="ln1196">			while (wlast &lt; (int32)row + 1) {</a>
<a name="ln1197">				for (wlast++, i = 0; i &lt; 4; i++) {</a>
<a name="ln1198">					window[(i + 3) &amp; 3] = window[i];</a>
<a name="ln1199">				}</a>
<a name="ln1200">				for (col = FC(wlast, 1) &amp; 1; col &lt; (int32)fInputWidth;</a>
<a name="ln1201">						col += 2) {</a>
<a name="ln1202">					window[2][col] = _Bayer(col, wlast);</a>
<a name="ln1203">				}</a>
<a name="ln1204">			}</a>
<a name="ln1205"> </a>
<a name="ln1206">			for (col = (FC(row, 0) &amp; 1) + 1; col &lt; (int32)fInputWidth - 1;</a>
<a name="ln1207">					col += 2) {</a>
<a name="ln1208">				avg = ( window[0][col - 1] + window[0][col + 1]</a>
<a name="ln1209">					+ window[2][col - 1] + window[2][col + 1] - fMeta.black * 4)</a>
<a name="ln1210">					* mul[row &amp; 1] + (window[1][col] - fMeta.black) * 0.5</a>
<a name="ln1211">					+ fMeta.black;</a>
<a name="ln1212">				diff = _Bayer(col, row) - avg;</a>
<a name="ln1213"> </a>
<a name="ln1214">				if (diff &lt; -fThreshold / M_SQRT2)</a>
<a name="ln1215">					diff += fThreshold / M_SQRT2;</a>
<a name="ln1216">				else if (diff &gt; fThreshold / M_SQRT2)</a>
<a name="ln1217">					diff -= fThreshold / M_SQRT2;</a>
<a name="ln1218">				else</a>
<a name="ln1219">					diff = 0;</a>
<a name="ln1220">				_Bayer(col, row) = (uint16)CLIP(avg + diff + 0.5);</a>
<a name="ln1221">			}</a>
<a name="ln1222">		}</a>
<a name="ln1223">	}</a>
<a name="ln1224"> </a>
<a name="ln1225">	free(fimg);</a>
<a name="ln1226">}</a>
<a name="ln1227"> </a>
<a name="ln1228"> </a>
<a name="ln1229">void</a>
<a name="ln1230">DCRaw::_PreInterpolate()</a>
<a name="ln1231">{</a>
<a name="ln1232">	if (fProgressMonitor != NULL)</a>
<a name="ln1233">		fProgressMonitor(&quot;Pre-Interpolate&quot;, 10, fProgressData);</a>
<a name="ln1234"> </a>
<a name="ln1235">	uint32 row, col;</a>
<a name="ln1236"> </a>
<a name="ln1237">	if (fShrink) {</a>
<a name="ln1238">		if (fHalfSize) {</a>
<a name="ln1239">			fInputHeight = fOutputHeight;</a>
<a name="ln1240">			fInputWidth = fOutputWidth;</a>
<a name="ln1241">			fFilters = 0;</a>
<a name="ln1242">		} else {</a>
<a name="ln1243">			uint16 (*data)[4] = (uint16 (*)[4])calloc(fInputHeight</a>
<a name="ln1244">				* fInputWidth, sizeof(*data));</a>
<a name="ln1245">			if (data == NULL)</a>
<a name="ln1246">				throw (status_t)B_NO_MEMORY;</a>
<a name="ln1247"> </a>
<a name="ln1248">			for (row = 0; row &lt; fInputHeight; row++) {</a>
<a name="ln1249">				for (col = 0; col &lt; fInputWidth; col++) {</a>
<a name="ln1250">					data[row * fInputWidth + col][FC(row, col)]</a>
<a name="ln1251">						= _Bayer(col, row);</a>
<a name="ln1252">				}</a>
<a name="ln1253">			}</a>
<a name="ln1254"> </a>
<a name="ln1255">			free(fImageData);</a>
<a name="ln1256">			fImageData = data;</a>
<a name="ln1257">			fShrink = 0;</a>
<a name="ln1258">		}</a>
<a name="ln1259">	}</a>
<a name="ln1260"> </a>
<a name="ln1261">	if (fFilters &amp;&amp; fColors == 3) {</a>
<a name="ln1262">//		if ((mix_green = four_color_rgb))</a>
<a name="ln1263">//			fColors++;</a>
<a name="ln1264">//		else</a>
<a name="ln1265">		{</a>
<a name="ln1266">			for (row = FC(1, 0) &gt;&gt; 1; row &lt; fInputHeight; row += 2) {</a>
<a name="ln1267">				for (col = FC(row, 1) &amp; 1; col &lt; fInputWidth; col += 2) {</a>
<a name="ln1268">					fImageData[row * fInputWidth + col][1]</a>
<a name="ln1269">						= fImageData[row * fInputWidth + col][3];</a>
<a name="ln1270">				}</a>
<a name="ln1271">			}</a>
<a name="ln1272">			fFilters &amp;= ~((fFilters &amp; 0x55555555) &lt;&lt; 1);</a>
<a name="ln1273">		}</a>
<a name="ln1274">	}</a>
<a name="ln1275">}</a>
<a name="ln1276"> </a>
<a name="ln1277"> </a>
<a name="ln1278">void</a>
<a name="ln1279">DCRaw::_CameraToCIELab(ushort cam[4], float lab[3])</a>
<a name="ln1280">{</a>
<a name="ln1281">	if (cam == NULL) {</a>
<a name="ln1282">		for (uint32 i = 0; i &lt; 0x10000; i++) {</a>
<a name="ln1283">			float r = i / 65535.0;</a>
<a name="ln1284">			cbrt[i] = r &gt; 0.008856 ? pow(r, 1 / 3.0) : 7.787 * r + 16 / 116.0;</a>
<a name="ln1285">		}</a>
<a name="ln1286">		for (uint32 i = 0; i &lt; 3; i++) {</a>
<a name="ln1287">			for (uint32 j = 0; j &lt; fColors; j++) {</a>
<a name="ln1288">				xyz_cam[i][j] = 0;</a>
<a name="ln1289">				for (uint32 k = 0; k &lt; 3; k++) {</a>
<a name="ln1290">					xyz_cam[i][j] += xyz_rgb[i][k] * fMeta.rgb_camera[k][j]</a>
<a name="ln1291">						/ kD65White[i];</a>
<a name="ln1292">				}</a>
<a name="ln1293">			}</a>
<a name="ln1294">		}</a>
<a name="ln1295">	} else {</a>
<a name="ln1296">		float xyz[3];</a>
<a name="ln1297">		xyz[0] = xyz[1] = xyz[2] = 0.5;</a>
<a name="ln1298">		for (uint32 c = 0; c &lt; fColors; c++) {</a>
<a name="ln1299">			xyz[0] += xyz_cam[0][c] * cam[c];</a>
<a name="ln1300">			xyz[1] += xyz_cam[1][c] * cam[c];</a>
<a name="ln1301">			xyz[2] += xyz_cam[2][c] * cam[c];</a>
<a name="ln1302">		}</a>
<a name="ln1303">		xyz[0] = cbrt[CLIP((int) xyz[0])];</a>
<a name="ln1304">		xyz[1] = cbrt[CLIP((int) xyz[1])];</a>
<a name="ln1305">		xyz[2] = cbrt[CLIP((int) xyz[2])];</a>
<a name="ln1306">		lab[0] = 116 * xyz[1] - 16;</a>
<a name="ln1307">		lab[1] = 500 * (xyz[0] - xyz[1]);</a>
<a name="ln1308">		lab[2] = 200 * (xyz[1] - xyz[2]);</a>
<a name="ln1309">	}</a>
<a name="ln1310">}</a>
<a name="ln1311"> </a>
<a name="ln1312"> </a>
<a name="ln1313">void</a>
<a name="ln1314">DCRaw::_CameraXYZCoefficients(double cameraXYZ[4][3])</a>
<a name="ln1315">{</a>
<a name="ln1316">	double cam_rgb[4][3], inverse[4][3], num;</a>
<a name="ln1317">	uint32 i, j, k;</a>
<a name="ln1318"> </a>
<a name="ln1319">	// Multiply out XYZ colorspace</a>
<a name="ln1320">	for (i = 0; i &lt; fColors; i++)	{</a>
<a name="ln1321">		for (j = 0; j &lt; 3; j++) {</a>
<a name="ln1322">			for (cam_rgb[i][j] = k = 0; k &lt; 3; k++) {</a>
<a name="ln1323">				cam_rgb[i][j] += cameraXYZ[i][k] * xyz_rgb[k][j];</a>
<a name="ln1324">			}</a>
<a name="ln1325">		}</a>
<a name="ln1326">	}</a>
<a name="ln1327"> </a>
<a name="ln1328">	// Normalize cam_rgb so that cam_rgb * (1,1,1) is (1,1,1,1)</a>
<a name="ln1329">	for (i = 0; i &lt; fColors; i++) {</a>
<a name="ln1330">		for (num = j = 0; j &lt; 3; j++) {</a>
<a name="ln1331">			num += cam_rgb[i][j];</a>
<a name="ln1332">		}</a>
<a name="ln1333">		for (j = 0; j &lt; 3; j++) {</a>
<a name="ln1334">			cam_rgb[i][j] /= num;</a>
<a name="ln1335">		}</a>
<a name="ln1336">		fMeta.pre_multipliers[i] = 1 / num;</a>
<a name="ln1337">	}</a>
<a name="ln1338"> </a>
<a name="ln1339">	_PseudoInverse(cam_rgb, inverse, fColors);</a>
<a name="ln1340"> </a>
<a name="ln1341">	fRawColor = false;</a>
<a name="ln1342">	for (i = 0; i &lt; 3; i++) {</a>
<a name="ln1343">		for (j=0; j &lt; fColors; j++) {</a>
<a name="ln1344">			fMeta.rgb_camera[i][j] = inverse[j][i];</a>
<a name="ln1345">		}</a>
<a name="ln1346">	}</a>
<a name="ln1347">}</a>
<a name="ln1348"> </a>
<a name="ln1349"> </a>
<a name="ln1350">/*!	Thanks to Adobe for providing these excellent CAM -&gt; XYZ matrices!</a>
<a name="ln1351">*/</a>
<a name="ln1352">void</a>
<a name="ln1353">DCRaw::_AdobeCoefficients(const char *make, const char *model)</a>
<a name="ln1354">{</a>
<a name="ln1355">	static const struct {</a>
<a name="ln1356">		const char *prefix;</a>
<a name="ln1357">		short black, trans[12];</a>
<a name="ln1358">	} table[] = {</a>
<a name="ln1359">		{ &quot;Canon EOS D2000&quot;, 0,</a>
<a name="ln1360">			{ 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 }},</a>
<a name="ln1361">		{ &quot;Canon EOS D6000&quot;, 0,</a>
<a name="ln1362">			{ 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 }},</a>
<a name="ln1363">		{ &quot;Canon EOS D30&quot;, 0,</a>
<a name="ln1364">			{ 9805,-2689,-1312,-5803,13064,3068,-2438,3075,8775 }},</a>
<a name="ln1365">		{ &quot;Canon EOS D60&quot;, 0,</a>
<a name="ln1366">			{ 6188,-1341,-890,-7168,14489,2937,-2640,3228,8483 }},</a>
<a name="ln1367">		{ &quot;Canon EOS 5D&quot;, 0,</a>
<a name="ln1368">			{ 6347,-479,-972,-8297,15954,2480,-1968,2131,7649 }},</a>
<a name="ln1369">		{ &quot;Canon EOS 20Da&quot;, 0,</a>
<a name="ln1370">			{ 14155,-5065,-1382,-6550,14633,2039,-1623,1824,6561 }},</a>
<a name="ln1371">		{ &quot;Canon EOS 20D&quot;, 0,</a>
<a name="ln1372">			{ 6599,-537,-891,-8071,15783,2424,-1983,2234,7462 }},</a>
<a name="ln1373">		{ &quot;Canon EOS 30D&quot;, 0,</a>
<a name="ln1374">			{ 6257,-303,-1000,-7880,15621,2396,-1714,1904,7046 }},</a>
<a name="ln1375">		{ &quot;Canon EOS 350D&quot;, 0,</a>
<a name="ln1376">			{ 6018,-617,-965,-8645,15881,2975,-1530,1719,7642 }},</a>
<a name="ln1377">		{ &quot;Canon EOS 400D&quot;, 0,</a>
<a name="ln1378">			{ 7054,-1501,-990,-8156,15544,2812,-1278,1414,7796 }},</a>
<a name="ln1379">		{ &quot;Canon EOS-1Ds Mark II&quot;, 0,</a>
<a name="ln1380">			{ 6517,-602,-867,-8180,15926,2378,-1618,1771,7633 }},</a>
<a name="ln1381">		{ &quot;Canon EOS-1D Mark II N&quot;, 0,</a>
<a name="ln1382">			{ 6240,-466,-822,-8180,15825,2500,-1801,1938,8042 }},</a>
<a name="ln1383">		{ &quot;Canon EOS-1D Mark II&quot;, 0,</a>
<a name="ln1384">			{ 6264,-582,-724,-8312,15948,2504,-1744,1919,8664 }},</a>
<a name="ln1385">		{ &quot;Canon EOS-1DS&quot;, 0,</a>
<a name="ln1386">			{ 4374,3631,-1743,-7520,15212,2472,-2892,3632,8161 }},</a>
<a name="ln1387">		{ &quot;Canon EOS-1D&quot;, 0,</a>
<a name="ln1388">			{ 6806,-179,-1020,-8097,16415,1687,-3267,4236,7690 }},</a>
<a name="ln1389">		{ &quot;Canon EOS&quot;, 0,</a>
<a name="ln1390">			{ 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 }},</a>
<a name="ln1391">		{ &quot;Canon PowerShot A50&quot;, 0,</a>
<a name="ln1392">			{ -5300,9846,1776,3436,684,3939,-5540,9879,6200,-1404,11175,217 }},</a>
<a name="ln1393">		{ &quot;Canon PowerShot A5&quot;, 0,</a>
<a name="ln1394">			{ -4801,9475,1952,2926,1611,4094,-5259,10164,5947,-1554,10883,547 }},</a>
<a name="ln1395">		{ &quot;Canon PowerShot G1&quot;, 0,</a>
<a name="ln1396">			{ -4778,9467,2172,4743,-1141,4344,-5146,9908,6077,-1566,11051,557 }},</a>
<a name="ln1397">		{ &quot;Canon PowerShot G2&quot;, 0,</a>
<a name="ln1398">			{ 9087,-2693,-1049,-6715,14382,2537,-2291,2819,7790 }},</a>
<a name="ln1399">		{ &quot;Canon PowerShot G3&quot;, 0,</a>
<a name="ln1400">			{ 9212,-2781,-1073,-6573,14189,2605,-2300,2844,7664 }},</a>
<a name="ln1401">		{ &quot;Canon PowerShot G5&quot;, 0,</a>
<a name="ln1402">			{ 9757,-2872,-933,-5972,13861,2301,-1622,2328,7212 }},</a>
<a name="ln1403">		{ &quot;Canon PowerShot G6&quot;, 0,</a>
<a name="ln1404">			{ 9877,-3775,-871,-7613,14807,3072,-1448,1305,7485 }},</a>
<a name="ln1405">		{ &quot;Canon PowerShot Pro1&quot;, 0,</a>
<a name="ln1406">			{ 10062,-3522,-999,-7643,15117,2730,-765,817,7323 }},</a>
<a name="ln1407">		{ &quot;Canon PowerShot Pro70&quot;, 34,</a>
<a name="ln1408">			{ -4155,9818,1529,3939,-25,4522,-5521,9870,6610,-2238,10873,1342 }},</a>
<a name="ln1409">		{ &quot;Canon PowerShot Pro90&quot;, 0,</a>
<a name="ln1410">			{ -4963,9896,2235,4642,-987,4294,-5162,10011,5859,-1770,11230,577 }},</a>
<a name="ln1411">		{ &quot;Canon PowerShot S30&quot;, 0,</a>
<a name="ln1412">			{ 10566,-3652,-1129,-6552,14662,2006,-2197,2581,7670 }},</a>
<a name="ln1413">		{ &quot;Canon PowerShot S40&quot;, 0,</a>
<a name="ln1414">			{ 8510,-2487,-940,-6869,14231,2900,-2318,2829,9013 }},</a>
<a name="ln1415">		{ &quot;Canon PowerShot S45&quot;, 0,</a>
<a name="ln1416">			{ 8163,-2333,-955,-6682,14174,2751,-2077,2597,8041 }},</a>
<a name="ln1417">		{ &quot;Canon PowerShot S50&quot;, 0,</a>
<a name="ln1418">			{ 8882,-2571,-863,-6348,14234,2288,-1516,2172,6569 }},</a>
<a name="ln1419">		{ &quot;Canon PowerShot S60&quot;, 0,</a>
<a name="ln1420">			{ 8795,-2482,-797,-7804,15403,2573,-1422,1996,7082 }},</a>
<a name="ln1421">		{ &quot;Canon PowerShot S70&quot;, 0,</a>
<a name="ln1422">			{ 9976,-3810,-832,-7115,14463,2906,-901,989,7889 }},</a>
<a name="ln1423">		{ &quot;Canon PowerShot A610&quot;, 0, /* DJC */</a>
<a name="ln1424">			{ 15591,-6402,-1592,-5365,13198,2168,-1300,1824,5075 }},</a>
<a name="ln1425">		{ &quot;Canon PowerShot A620&quot;, 0, /* DJC */</a>
<a name="ln1426">			{ 15265,-6193,-1558,-4125,12116,2010,-888,1639,5220 }},</a>
<a name="ln1427">		{ &quot;Canon PowerShot S3 IS&quot;, 0, /* DJC */</a>
<a name="ln1428">			{ 14062,-5199,-1446,-4712,12470,2243,-1286,2028,4836 }},</a>
<a name="ln1429">		{ &quot;Contax N Digital&quot;, 0,</a>
<a name="ln1430">			{ 7777,1285,-1053,-9280,16543,2916,-3677,5679,7060 }},</a>
<a name="ln1431">		{ &quot;EPSON R-D1&quot;, 0,</a>
<a name="ln1432">			{ 6827,-1878,-732,-8429,16012,2564,-704,592,7145 }},</a>
<a name="ln1433">		{ &quot;FUJIFILM FinePix E550&quot;, 0,</a>
<a name="ln1434">			{ 11044,-3888,-1120,-7248,15168,2208,-1531,2277,8069 }},</a>
<a name="ln1435">		{ &quot;FUJIFILM FinePix E900&quot;, 0,</a>
<a name="ln1436">			{ 9183,-2526,-1078,-7461,15071,2574,-2022,2440,8639 }},</a>
<a name="ln1437">		{ &quot;FUJIFILM FinePix F8&quot;, 0,</a>
<a name="ln1438">			{ 11044,-3888,-1120,-7248,15168,2208,-1531,2277,8069 }},</a>
<a name="ln1439">		{ &quot;FUJIFILM FinePix F7&quot;, 0,</a>
<a name="ln1440">			{ 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 }},</a>
<a name="ln1441">		{ &quot;FUJIFILM FinePix S20Pro&quot;, 0,</a>
<a name="ln1442">			{ 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 }},</a>
<a name="ln1443">		{ &quot;FUJIFILM FinePix S2Pro&quot;, 128,</a>
<a name="ln1444">			{ 12492,-4690,-1402,-7033,15423,1647,-1507,2111,7697 }},</a>
<a name="ln1445">		{ &quot;FUJIFILM FinePix S3Pro&quot;, 0,</a>
<a name="ln1446">			{ 11807,-4612,-1294,-8927,16968,1988,-2120,2741,8006 }},</a>
<a name="ln1447">		{ &quot;FUJIFILM FinePix S5000&quot;, 0,</a>
<a name="ln1448">			{ 8754,-2732,-1019,-7204,15069,2276,-1702,2334,6982 }},</a>
<a name="ln1449">		{ &quot;FUJIFILM FinePix S5100&quot;, 0,</a>
<a name="ln1450">			{ 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 }},</a>
<a name="ln1451">		{ &quot;FUJIFILM FinePix S5500&quot;, 0,</a>
<a name="ln1452">			{ 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 }},</a>
<a name="ln1453">		{ &quot;FUJIFILM FinePix S5200&quot;, 0,</a>
<a name="ln1454">			{ 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 }},</a>
<a name="ln1455">		{ &quot;FUJIFILM FinePix S5600&quot;, 0,</a>
<a name="ln1456">			{ 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 }},</a>
<a name="ln1457">		{ &quot;FUJIFILM FinePix S6&quot;, 0,</a>
<a name="ln1458">			{ 12628,-4887,-1401,-6861,14996,1962,-2198,2782,7091 }},</a>
<a name="ln1459">		{ &quot;FUJIFILM FinePix S7000&quot;, 0,</a>
<a name="ln1460">			{ 10190,-3506,-1312,-7153,15051,2238,-2003,2399,7505 }},</a>
<a name="ln1461">		{ &quot;FUJIFILM FinePix S9000&quot;, 0,</a>
<a name="ln1462">			{ 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 }},</a>
<a name="ln1463">		{ &quot;FUJIFILM FinePix S9500&quot;, 0,</a>
<a name="ln1464">			{ 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 }},</a>
<a name="ln1465">		{ &quot;FUJIFILM FinePix S9100&quot;, 0,</a>
<a name="ln1466">			{ 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 }},</a>
<a name="ln1467">		{ &quot;FUJIFILM FinePix S9600&quot;, 0,</a>
<a name="ln1468">			{ 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 }},</a>
<a name="ln1469">		{ &quot;Imacon Ixpress&quot;, 0,	/* DJC */</a>
<a name="ln1470">			{ 7025,-1415,-704,-5188,13765,1424,-1248,2742,6038 }},</a>
<a name="ln1471">		{ &quot;KODAK NC2000&quot;, 0,	/* DJC */</a>
<a name="ln1472">			{ 16475,-6903,-1218,-851,10375,477,2505,-7,1020 }},</a>
<a name="ln1473">		{ &quot;Kodak DCS315C&quot;, 8,</a>
<a name="ln1474">			{ 17523,-4827,-2510,756,8546,-137,6113,1649,2250 }},</a>
<a name="ln1475">		{ &quot;Kodak DCS330C&quot;, 8,</a>
<a name="ln1476">			{ 20620,-7572,-2801,-103,10073,-396,3551,-233,2220 }},</a>
<a name="ln1477">		{ &quot;KODAK DCS420&quot;, 0,</a>
<a name="ln1478">			{ 10868,-1852,-644,-1537,11083,484,2343,628,2216 }},</a>
<a name="ln1479">		{ &quot;KODAK DCS460&quot;, 0,</a>
<a name="ln1480">			{ 10592,-2206,-967,-1944,11685,230,2206,670,1273 }},</a>
<a name="ln1481">		{ &quot;KODAK EOSDCS1&quot;, 0,</a>
<a name="ln1482">			{ 10592,-2206,-967,-1944,11685,230,2206,670,1273 }},</a>
<a name="ln1483">		{ &quot;KODAK EOSDCS3B&quot;, 0,</a>
<a name="ln1484">			{ 9898,-2700,-940,-2478,12219,206,1985,634,1031 }},</a>
<a name="ln1485">		{ &quot;Kodak DCS520C&quot;, 180,</a>
<a name="ln1486">			{ 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 }},</a>
<a name="ln1487">		{ &quot;Kodak DCS560C&quot;, 188,</a>
<a name="ln1488">			{ 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 }},</a>
<a name="ln1489">		{ &quot;Kodak DCS620C&quot;, 180,</a>
<a name="ln1490">			{ 23617,-10175,-3149,-2054,11749,-272,2586,-489,3453 }},</a>
<a name="ln1491">		{ &quot;Kodak DCS620X&quot;, 185,</a>
<a name="ln1492">			{ 13095,-6231,154,12221,-21,-2137,895,4602,2258 }},</a>
<a name="ln1493">		{ &quot;Kodak DCS660C&quot;, 214,</a>
<a name="ln1494">			{ 18244,-6351,-2739,-791,11193,-521,3711,-129,2802 }},</a>
<a name="ln1495">		{ &quot;Kodak DCS720X&quot;, 0,</a>
<a name="ln1496">			{ 11775,-5884,950,9556,1846,-1286,-1019,6221,2728 }},</a>
<a name="ln1497">		{ &quot;Kodak DCS760C&quot;, 0,</a>
<a name="ln1498">			{ 16623,-6309,-1411,-4344,13923,323,2285,274,2926 }},</a>
<a name="ln1499">		{ &quot;Kodak DCS Pro SLR&quot;, 0,</a>
<a name="ln1500">			{ 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 }},</a>
<a name="ln1501">		{ &quot;Kodak DCS Pro 14nx&quot;, 0,</a>
<a name="ln1502">			{ 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 }},</a>
<a name="ln1503">		{ &quot;Kodak DCS Pro 14&quot;, 0,</a>
<a name="ln1504">			{ 7791,3128,-776,-8588,16458,2039,-2455,4006,6198 }},</a>
<a name="ln1505">		{ &quot;Kodak ProBack645&quot;, 0,</a>
<a name="ln1506">			{ 16414,-6060,-1470,-3555,13037,473,2545,122,4948 }},</a>
<a name="ln1507">		{ &quot;Kodak ProBack&quot;, 0,</a>
<a name="ln1508">			{ 21179,-8316,-2918,-915,11019,-165,3477,-180,4210 }},</a>
<a name="ln1509">		{ &quot;KODAK P712&quot;, 0,</a>
<a name="ln1510">			{ 9658,-3314,-823,-5163,12695,2768,-1342,1843,6044 }},</a>
<a name="ln1511">		{ &quot;KODAK P850&quot;, 0,</a>
<a name="ln1512">			{ 10511,-3836,-1102,-6946,14587,2558,-1481,1792,6246 }},</a>
<a name="ln1513">		{ &quot;KODAK P880&quot;, 0,</a>
<a name="ln1514">			{ 12805,-4662,-1376,-7480,15267,2360,-1626,2194,7904 }},</a>
<a name="ln1515">		{ &quot;Leaf CMost&quot;, 0,</a>
<a name="ln1516">			{ 3952,2189,449,-6701,14585,2275,-4536,7349,6536 }},</a>
<a name="ln1517">		{ &quot;Leaf Valeo 6&quot;, 0,</a>
<a name="ln1518">			{ 3952,2189,449,-6701,14585,2275,-4536,7349,6536 }},</a>
<a name="ln1519">		{ &quot;Leaf Aptus 65&quot;, 0,</a>
<a name="ln1520">			{ 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 }},</a>
<a name="ln1521">		{ &quot;Leaf Aptus 75&quot;, 0,</a>
<a name="ln1522">			{ 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 }},</a>
<a name="ln1523">		{ &quot;Leaf&quot;, 0,</a>
<a name="ln1524">			{ 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 }},</a>
<a name="ln1525">		{ &quot;Micron 2010&quot;, 110,	/* DJC */</a>
<a name="ln1526">			{ 16695,-3761,-2151,155,9682,163,3433,951,4904 }},</a>
<a name="ln1527">		{ &quot;Minolta DiMAGE 5&quot;, 0,</a>
<a name="ln1528">			{ 8983,-2942,-963,-6556,14476,2237,-2426,2887,8014 }},</a>
<a name="ln1529">		{ &quot;Minolta DiMAGE 7Hi&quot;, 0,</a>
<a name="ln1530">			{ 11368,-3894,-1242,-6521,14358,2339,-2475,3056,7285 }},</a>
<a name="ln1531">		{ &quot;Minolta DiMAGE 7&quot;, 0,</a>
<a name="ln1532">			{ 9144,-2777,-998,-6676,14556,2281,-2470,3019,7744 }},</a>
<a name="ln1533">		{ &quot;Minolta DiMAGE A1&quot;, 0,</a>
<a name="ln1534">			{ 9274,-2547,-1167,-8220,16323,1943,-2273,2720,8340 }},</a>
<a name="ln1535">		{ &quot;MINOLTA DiMAGE A200&quot;, 0,</a>
<a name="ln1536">			{ 8560,-2487,-986,-8112,15535,2771,-1209,1324,7743 }},</a>
<a name="ln1537">		{ &quot;Minolta DiMAGE A2&quot;, 0,</a>
<a name="ln1538">			{ 9097,-2726,-1053,-8073,15506,2762,-966,981,7763 }},</a>
<a name="ln1539">		{ &quot;Minolta DiMAGE Z2&quot;, 0,	/* DJC */</a>
<a name="ln1540">			{ 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 }},</a>
<a name="ln1541">		{ &quot;MINOLTA DYNAX 5&quot;, 0,</a>
<a name="ln1542">			{ 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 }},</a>
<a name="ln1543">		{ &quot;MINOLTA DYNAX 7&quot;, 0,</a>
<a name="ln1544">			{ 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 }},</a>
<a name="ln1545">		{ &quot;NIKON D100&quot;, 0,</a>
<a name="ln1546">			{ 5902,-933,-782,-8983,16719,2354,-1402,1455,6464 }},</a>
<a name="ln1547">		{ &quot;NIKON D1H&quot;, 0,</a>
<a name="ln1548">			{ 7577,-2166,-926,-7454,15592,1934,-2377,2808,8606 }},</a>
<a name="ln1549">		{ &quot;NIKON D1X&quot;, 0,</a>
<a name="ln1550">			{ 7702,-2245,-975,-9114,17242,1875,-2679,3055,8521 }},</a>
<a name="ln1551">		{ &quot;NIKON D1&quot;, 0,	/* multiplied by 2.218750, 1.0, 1.148438 */</a>
<a name="ln1552">			{ 16772,-4726,-2141,-7611,15713,1972,-2846,3494,9521 }},</a>
<a name="ln1553">		{ &quot;NIKON D2H&quot;, 0,</a>
<a name="ln1554">			{ 5710,-901,-615,-8594,16617,2024,-2975,4120,6830 }},</a>
<a name="ln1555">		{ &quot;NIKON D2X&quot;, 0,</a>
<a name="ln1556">			{ 10231,-2769,-1255,-8301,15900,2552,-797,680,7148 }},</a>
<a name="ln1557">		{ &quot;NIKON D40&quot;, 0,</a>
<a name="ln1558">			{ 6992,-1668,-806,-8138,15748,2543,-874,850,7897 }},</a>
<a name="ln1559">		{ &quot;NIKON D50&quot;, 0,</a>
<a name="ln1560">			{ 7732,-2422,-789,-8238,15884,2498,-859,783,7330 }},</a>
<a name="ln1561">		{ &quot;NIKON D70&quot;, 0,</a>
<a name="ln1562">			{ 7732,-2422,-789,-8238,15884,2498,-859,783,7330 }},</a>
<a name="ln1563">		{ &quot;NIKON D80&quot;, 0,</a>
<a name="ln1564">			{ 8629,-2410,-883,-9055,16940,2171,-1490,1363,8520 }},</a>
<a name="ln1565">		{ &quot;NIKON D200&quot;, 0,</a>
<a name="ln1566">			{ 8367,-2248,-763,-8758,16447,2422,-1527,1550,8053 }},</a>
<a name="ln1567">		{ &quot;NIKON E950&quot;, 0,		/* DJC */</a>
<a name="ln1568">			{ -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 }},</a>
<a name="ln1569">		{ &quot;NIKON E995&quot;, 0,	/* copied from E5000 */</a>
<a name="ln1570">			{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 }},</a>
<a name="ln1571">		{ &quot;NIKON E2500&quot;, 0,</a>
<a name="ln1572">			{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 }},</a>
<a name="ln1573">		{ &quot;NIKON E4300&quot;, 0, /* copied from Minolta DiMAGE Z2 */</a>
<a name="ln1574">			{ 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 }},</a>
<a name="ln1575">		{ &quot;NIKON E4500&quot;, 0,</a>
<a name="ln1576">			{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 }},</a>
<a name="ln1577">		{ &quot;NIKON E5000&quot;, 0,</a>
<a name="ln1578">			{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 }},</a>
<a name="ln1579">		{ &quot;NIKON E5400&quot;, 0,</a>
<a name="ln1580">			{ 9349,-2987,-1001,-7919,15766,2266,-2098,2680,6839 }},</a>
<a name="ln1581">		{ &quot;NIKON E5700&quot;, 0,</a>
<a name="ln1582">			{ -5368,11478,2368,5537,-113,3148,-4969,10021,5782,778,9028,211 }},</a>
<a name="ln1583">		{ &quot;NIKON E8400&quot;, 0,</a>
<a name="ln1584">			{ 7842,-2320,-992,-8154,15718,2599,-1098,1342,7560 }},</a>
<a name="ln1585">		{ &quot;NIKON E8700&quot;, 0,</a>
<a name="ln1586">			{ 8489,-2583,-1036,-8051,15583,2643,-1307,1407,7354 }},</a>
<a name="ln1587">		{ &quot;NIKON E8800&quot;, 0,</a>
<a name="ln1588">			{ 7971,-2314,-913,-8451,15762,2894,-1442,1520,7610 }},</a>
<a name="ln1589">		{ &quot;OLYMPUS C5050&quot;, 0,</a>
<a name="ln1590">			{ 10508,-3124,-1273,-6079,14294,1901,-1653,2306,6237 }},</a>
<a name="ln1591">		{ &quot;OLYMPUS C5060&quot;, 0,</a>
<a name="ln1592">			{ 10445,-3362,-1307,-7662,15690,2058,-1135,1176,7602 }},</a>
<a name="ln1593">		{ &quot;OLYMPUS C7070&quot;, 0,</a>
<a name="ln1594">			{ 10252,-3531,-1095,-7114,14850,2436,-1451,1723,6365 }},</a>
<a name="ln1595">		{ &quot;OLYMPUS C70&quot;, 0,</a>
<a name="ln1596">			{ 10793,-3791,-1146,-7498,15177,2488,-1390,1577,7321 }},</a>
<a name="ln1597">		{ &quot;OLYMPUS C80&quot;, 0,</a>
<a name="ln1598">			{ 8606,-2509,-1014,-8238,15714,2703,-942,979,7760 }},</a>
<a name="ln1599">		{ &quot;OLYMPUS E-10&quot;, 0,</a>
<a name="ln1600">			{ 12745,-4500,-1416,-6062,14542,1580,-1934,2256,6603 }},</a>
<a name="ln1601">		{ &quot;OLYMPUS E-1&quot;, 0,</a>
<a name="ln1602">			{ 11846,-4767,-945,-7027,15878,1089,-2699,4122,8311 }},</a>
<a name="ln1603">		{ &quot;OLYMPUS E-20&quot;, 0,</a>
<a name="ln1604">			{ 13173,-4732,-1499,-5807,14036,1895,-2045,2452,7142 }},</a>
<a name="ln1605">		{ &quot;OLYMPUS E-300&quot;, 0,</a>
<a name="ln1606">			{ 7828,-1761,-348,-5788,14071,1830,-2853,4518,6557 }},</a>
<a name="ln1607">		{ &quot;OLYMPUS E-330&quot;, 0,</a>
<a name="ln1608">			{ 8961,-2473,-1084,-7979,15990,2067,-2319,3035,8249 }},</a>
<a name="ln1609">		{ &quot;OLYMPUS E-400&quot;, 0,</a>
<a name="ln1610">			{ 6169,-1483,-21,-7107,14761,2536,-2904,3580,8568 }},</a>
<a name="ln1611">		{ &quot;OLYMPUS E-500&quot;, 0,</a>
<a name="ln1612">			{ 8136,-1968,-299,-5481,13742,1871,-2556,4205,6630 }},</a>
<a name="ln1613">		{ &quot;OLYMPUS SP350&quot;, 0,</a>
<a name="ln1614">			{ 12078,-4836,-1069,-6671,14306,2578,-786,939,7418 }},</a>
<a name="ln1615">		{ &quot;OLYMPUS SP3&quot;, 0,</a>
<a name="ln1616">			{ 11766,-4445,-1067,-6901,14421,2707,-1029,1217,7572 }},</a>
<a name="ln1617">		{ &quot;OLYMPUS SP500UZ&quot;, 0,</a>
<a name="ln1618">			{ 9493,-3415,-666,-5211,12334,3260,-1548,2262,6482 }},</a>
<a name="ln1619">		{ &quot;OLYMPUS SP510UZ&quot;, 0,</a>
<a name="ln1620">			{ 10593,-3607,-1010,-5881,13127,3084,-1200,1805,6721 }},</a>
<a name="ln1621">		{ &quot;PENTAX *ist DL2&quot;, 0,</a>
<a name="ln1622">			{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 }},</a>
<a name="ln1623">		{ &quot;PENTAX *ist DL&quot;, 0,</a>
<a name="ln1624">			{ 10829,-2838,-1115,-8339,15817,2696,-837,680,11939 }},</a>
<a name="ln1625">		{ &quot;PENTAX *ist DS2&quot;, 0,</a>
<a name="ln1626">			{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 }},</a>
<a name="ln1627">		{ &quot;PENTAX *ist DS&quot;, 0,</a>
<a name="ln1628">			{ 10371,-2333,-1206,-8688,16231,2602,-1230,1116,11282 }},</a>
<a name="ln1629">		{ &quot;PENTAX *ist D&quot;, 0,</a>
<a name="ln1630">			{ 9651,-2059,-1189,-8881,16512,2487,-1460,1345,10687 }},</a>
<a name="ln1631">		{ &quot;PENTAX K10D&quot;, 0,</a>
<a name="ln1632">			{ 9566,-2863,-803,-7170,15172,2112,-818,803,9705 }},</a>
<a name="ln1633">		{ &quot;PENTAX K1&quot;, 0,</a>
<a name="ln1634">			{ 11095,-3157,-1324,-8377,15834,2720,-1108,947,11688 }},</a>
<a name="ln1635">		{ &quot;Panasonic DMC-FZ30&quot;, 0,</a>
<a name="ln1636">			{ 10976,-4029,-1141,-7918,15491,2600,-1670,2071,8246 }},</a>
<a name="ln1637">		{ &quot;Panasonic DMC-FZ50&quot;, 0,	/* aka &quot;LEICA V-LUX1&quot; */</a>
<a name="ln1638">			{ 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 }},</a>
<a name="ln1639">		{ &quot;Panasonic DMC-L1&quot;, 0,	/* aka &quot;LEICA DIGILUX 3&quot; */</a>
<a name="ln1640">			{ 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 }},</a>
<a name="ln1641">		{ &quot;Panasonic DMC-LC1&quot;, 0,	/* aka &quot;LEICA DIGILUX 2&quot; */</a>
<a name="ln1642">			{ 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 }},</a>
<a name="ln1643">		{ &quot;Panasonic DMC-LX1&quot;, 0,	/* aka &quot;LEICA D-LUX2&quot; */</a>
<a name="ln1644">			{ 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 }},</a>
<a name="ln1645">		{ &quot;Panasonic DMC-LX2&quot;, 0,	/* aka &quot;LEICA D-LUX3&quot; */</a>
<a name="ln1646">			{ 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 }},</a>
<a name="ln1647">		{ &quot;SAMSUNG GX-1&quot;, 0,</a>
<a name="ln1648">			{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 }},</a>
<a name="ln1649">		{ &quot;Sinar&quot;, 0,		/* DJC */</a>
<a name="ln1650">			{ 16442,-2956,-2422,-2877,12128,750,-1136,6066,4559 }},</a>
<a name="ln1651">		{ &quot;SONY DSC-F828&quot;, 491,</a>
<a name="ln1652">			{ 7924,-1910,-777,-8226,15459,2998,-1517,2199,6818,-7242,11401,3481 }},</a>
<a name="ln1653">		{ &quot;SONY DSC-R1&quot;, 512,</a>
<a name="ln1654">			{ 8512,-2641,-694,-8042,15670,2526,-1821,2117,7414 }},</a>
<a name="ln1655">		{ &quot;SONY DSC-V3&quot;, 0,</a>
<a name="ln1656">			{ 7511,-2571,-692,-7894,15088,3060,-948,1111,8128 }},</a>
<a name="ln1657">		{ &quot;SONY DSLR-A100&quot;, 0,</a>
<a name="ln1658">			{ 9437,-2811,-774,-8405,16215,2290,-710,596,7181 }}</a>
<a name="ln1659">	};</a>
<a name="ln1660">	double cameraXYZ[4][3];</a>
<a name="ln1661"> </a>
<a name="ln1662">	for (uint32 i = 0; i &lt; sizeof table / sizeof *table; i++) {</a>
<a name="ln1663">		if (!strncasecmp(model, table[i].prefix, strlen(table[i].prefix))) {</a>
<a name="ln1664">			if (table[i].black)</a>
<a name="ln1665">				fMeta.black = table[i].black;</a>
<a name="ln1666">			for (uint32 j = 0; j &lt; 12; j++) {</a>
<a name="ln1667">				((double**)cameraXYZ)[0][j] = table[i].trans[j] / 10000.0;</a>
<a name="ln1668">			}</a>
<a name="ln1669">			_CameraXYZCoefficients(cameraXYZ);</a>
<a name="ln1670">			break;</a>
<a name="ln1671">		}</a>
<a name="ln1672">	}</a>
<a name="ln1673">}</a>
<a name="ln1674"> </a>
<a name="ln1675"> </a>
<a name="ln1676">void</a>
<a name="ln1677">DCRaw::_BorderInterpolate(uint32 border)</a>
<a name="ln1678">{</a>
<a name="ln1679">	uint32 row, col, y, x, f, c, sum[8];</a>
<a name="ln1680"> </a>
<a name="ln1681">	for (row = 0; row &lt; fInputHeight; row++) {</a>
<a name="ln1682">		for (col = 0; col &lt; fInputWidth; col++) {</a>
<a name="ln1683">			if (col == border &amp;&amp; row &gt;= border &amp;&amp; row &lt; fInputHeight - border)</a>
<a name="ln1684">				col = fInputWidth - border;</a>
<a name="ln1685"> </a>
<a name="ln1686">			memset(sum, 0, sizeof(sum));</a>
<a name="ln1687"> </a>
<a name="ln1688">			for (y = row - 1; y != row + 2; y++) {</a>
<a name="ln1689">				for (x = col - 1; x != col + 2; x++) {</a>
<a name="ln1690">					if (y &lt; fInputHeight &amp;&amp; x &lt; fInputWidth) {</a>
<a name="ln1691">						f = _FilterCoefficient(x, y);</a>
<a name="ln1692">						sum[f] += fImageData[y * fInputWidth + x][f];</a>
<a name="ln1693">						sum[f + 4]++;</a>
<a name="ln1694">					}</a>
<a name="ln1695">				}</a>
<a name="ln1696">			}</a>
<a name="ln1697"> </a>
<a name="ln1698">			f = _FilterCoefficient(col, row);</a>
<a name="ln1699"> </a>
<a name="ln1700">			for (c = 0; c &lt; fColors; c++) {</a>
<a name="ln1701">				if (c != f &amp;&amp; sum[c + 4]) {</a>
<a name="ln1702">					fImageData[row * fInputWidth + col][c]</a>
<a name="ln1703">						= sum[c] / sum[c + 4];</a>
<a name="ln1704">				}</a>
<a name="ln1705">			}</a>
<a name="ln1706">		}</a>
<a name="ln1707">	}</a>
<a name="ln1708">}</a>
<a name="ln1709"> </a>
<a name="ln1710"> </a>
<a name="ln1711">/*!	Adaptive Homogeneity-Directed interpolation is based on</a>
<a name="ln1712">	the work of Keigo Hirakawa, Thomas Parks, and Paul Lee.</a>
<a name="ln1713">*/</a>
<a name="ln1714">void</a>
<a name="ln1715">DCRaw::_AHDInterpolate()</a>
<a name="ln1716">{</a>
<a name="ln1717">	if (fProgressMonitor != NULL)</a>
<a name="ln1718">		fProgressMonitor(&quot;Interpolate&quot;, 20, fProgressData);</a>
<a name="ln1719"> </a>
<a name="ln1720">#define TS 256		/* Tile Size */</a>
<a name="ln1721"> </a>
<a name="ln1722">	int i, j, tr, tc, fc, c, d, val, hm[2];</a>
<a name="ln1723">	uint32 top, left, row, col;</a>
<a name="ln1724">	ushort (*pix)[4], (*rix)[3];</a>
<a name="ln1725">	static const int dir[4] = { -1, 1, -TS, TS };</a>
<a name="ln1726">	unsigned ldiff[2][4], abdiff[2][4], leps, abeps;</a>
<a name="ln1727">	float flab[3];</a>
<a name="ln1728">	ushort (*rgb)[TS][TS][3];</a>
<a name="ln1729">	short (*lab)[TS][TS][3];</a>
<a name="ln1730">	char (*homo)[TS][TS], *buffer;</a>
<a name="ln1731"> </a>
<a name="ln1732">	_BorderInterpolate(3);</a>
<a name="ln1733">	buffer = (char *)malloc(26 * TS * TS);		/* 1664 kB */</a>
<a name="ln1734">	if (buffer == NULL)</a>
<a name="ln1735">		throw (status_t)B_NO_MEMORY;</a>
<a name="ln1736"> </a>
<a name="ln1737">	rgb = (ushort(*)[TS][TS][3])buffer;</a>
<a name="ln1738">	lab = (short (*)[TS][TS][3])(buffer + 12 * TS * TS);</a>
<a name="ln1739">	homo = (char (*)[TS][TS])(buffer + 24 * TS * TS);</a>
<a name="ln1740">	float percentage = 20;</a>
<a name="ln1741">	float percentageStep = 70.0f / (fInputHeight / (TS - 6));</a>
<a name="ln1742"> </a>
<a name="ln1743">	for (top = 0; top &lt; fInputHeight; top += TS - 6) {</a>
<a name="ln1744">		if (fProgressMonitor) {</a>
<a name="ln1745">			fProgressMonitor(&quot;Interpolate&quot;, percentage, fProgressData);</a>
<a name="ln1746">			percentage += percentageStep;</a>
<a name="ln1747">		}</a>
<a name="ln1748"> </a>
<a name="ln1749">		for (left = 0; left &lt; fInputWidth; left += TS - 6) {</a>
<a name="ln1750">			memset(rgb, 0, 12 * TS * TS);</a>
<a name="ln1751"> </a>
<a name="ln1752">			/* Interpolate green horizontally and vertically: */</a>
<a name="ln1753">			for (row = top &lt; 2 ? 2 : top; row &lt; top + TS</a>
<a name="ln1754">					&amp;&amp; row &lt; fInputHeight - 2; row++) {</a>
<a name="ln1755">				col = left + (FC(row, left) == 1);</a>
<a name="ln1756">				if (col &lt; 2)</a>
<a name="ln1757">					col += 2;</a>
<a name="ln1758">				for (fc = FC(row, col); col &lt; left + TS</a>
<a name="ln1759">						&amp;&amp; col &lt; fInputWidth - 2; col += 2) {</a>
<a name="ln1760">					pix = fImageData + row * fInputWidth + col;</a>
<a name="ln1761">					val = ((pix[-1][1] + pix[0][fc] + pix[1][1]) * 2</a>
<a name="ln1762">						- pix[-2][fc] - pix[2][fc]) &gt;&gt; 2;</a>
<a name="ln1763">					rgb[0][row - top][col - left][1]</a>
<a name="ln1764">						= ULIM(val, pix[-1][1], pix[1][1]);</a>
<a name="ln1765">					val = ((pix[-fInputWidth][1] + pix[0][fc]</a>
<a name="ln1766">							+ pix[fInputWidth][1]) * 2</a>
<a name="ln1767">						- pix[-2 * fInputWidth][fc] - pix[2 * fInputWidth][fc])</a>
<a name="ln1768">							&gt;&gt; 2;</a>
<a name="ln1769">					rgb[1][row - top][col - left][1] = ULIM(val,</a>
<a name="ln1770">						pix[-fInputWidth][1], pix[fInputWidth][1]);</a>
<a name="ln1771">				}</a>
<a name="ln1772">			}</a>
<a name="ln1773"> </a>
<a name="ln1774">			/* Interpolate red and blue, and convert to CIELab: */</a>
<a name="ln1775">			for (d = 0; d &lt; 2; d++) {</a>
<a name="ln1776">				for (row = top + 1; row &lt; top + TS - 1</a>
<a name="ln1777">						&amp;&amp; row &lt; fInputHeight - 1; row++) {</a>
<a name="ln1778">					for (col = left + 1; col &lt; left + TS - 1</a>
<a name="ln1779">							&amp;&amp; col &lt; fInputWidth - 1; col++) {</a>
<a name="ln1780">						pix = fImageData + row * fInputWidth + col;</a>
<a name="ln1781">						rix = &amp;rgb[d][row - top][col - left];</a>
<a name="ln1782">						if ((c = 2 - FC(row, col)) == 1) {</a>
<a name="ln1783">							c = FC(row + 1,col);</a>
<a name="ln1784">							val = pix[0][1] + ((pix[-1][2-c] + pix[1][2 - c]</a>
<a name="ln1785">								- rix[-1][1] - rix[1][1] ) &gt;&gt; 1);</a>
<a name="ln1786">							rix[0][2-c] = CLIP(val);</a>
<a name="ln1787">							val = pix[0][1] + ((pix[-fInputWidth][c]</a>
<a name="ln1788">								+ pix[fInputWidth][c]</a>
<a name="ln1789">								- rix[-TS][1] - rix[TS][1] ) &gt;&gt; 1);</a>
<a name="ln1790">						} else {</a>
<a name="ln1791">							val = rix[0][1] + ((pix[-fInputWidth - 1][c]</a>
<a name="ln1792">								+ pix[-fInputWidth + 1][c]</a>
<a name="ln1793">								+ pix[fInputWidth - 1][c]</a>
<a name="ln1794">								+ pix[fInputWidth + 1][c]</a>
<a name="ln1795">								- rix[-TS - 1][1] - rix[-TS + 1][1]</a>
<a name="ln1796">								- rix[TS - 1][1] - rix[TS + 1][1] + 1) &gt;&gt; 2);</a>
<a name="ln1797">						}</a>
<a name="ln1798">						rix[0][c] = CLIP(val);</a>
<a name="ln1799">						c = FC(row, col);</a>
<a name="ln1800">						rix[0][c] = pix[0][c];</a>
<a name="ln1801">						_CameraToCIELab(rix[0], flab);</a>
<a name="ln1802">						for (c = 0; c &lt; 3; c++) {</a>
<a name="ln1803">							lab[d][row - top][col - left][c]</a>
<a name="ln1804">								= int16(64 * flab[c]);</a>
<a name="ln1805">						}</a>
<a name="ln1806">					}</a>
<a name="ln1807">				}</a>
<a name="ln1808">			}</a>
<a name="ln1809"> </a>
<a name="ln1810">			/* Build homogeneity maps from the CIELab images: */</a>
<a name="ln1811">			memset(homo, 0, 2 * TS * TS);</a>
<a name="ln1812">			for (row = top + 2; row &lt; top+TS-2 &amp;&amp; row &lt; fInputHeight; row++) {</a>
<a name="ln1813">				tr = row - top;</a>
<a name="ln1814">				for (col = left + 2; col &lt; left + TS - 2</a>
<a name="ln1815">						&amp;&amp; col &lt; fInputWidth; col++) {</a>
<a name="ln1816">					tc = col - left;</a>
<a name="ln1817">					for (d = 0; d &lt; 2; d++) {</a>
<a name="ln1818">						for (i = 0; i &lt; 4; i++) {</a>
<a name="ln1819">							ldiff[d][i] = ABS(lab[d][tr][tc][0]</a>
<a name="ln1820">									- lab[d][tr][tc+dir[i]][0]);</a>
<a name="ln1821">						}</a>
<a name="ln1822">					}</a>
<a name="ln1823"> </a>
<a name="ln1824">					leps = MIN(MAX(ldiff[0][0],ldiff[0][1]),</a>
<a name="ln1825">						MAX(ldiff[1][2],ldiff[1][3]));</a>
<a name="ln1826"> </a>
<a name="ln1827">					for (d = 0; d &lt; 2; d++) {</a>
<a name="ln1828">						for (i = 0; i &lt; 4; i++) {</a>
<a name="ln1829">							if (i &gt;&gt; 1 == d || ldiff[d][i] &lt;= leps) {</a>
<a name="ln1830">								abdiff[d][i] = square(lab[d][tr][tc][1]</a>
<a name="ln1831">										- lab[d][tr][tc+dir[i]][1])</a>
<a name="ln1832">									+ square(lab[d][tr][tc][2]</a>
<a name="ln1833">										- lab[d][tr][tc+dir[i]][2]);</a>
<a name="ln1834">							}</a>
<a name="ln1835">						}</a>
<a name="ln1836">					}</a>
<a name="ln1837"> </a>
<a name="ln1838">					abeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),</a>
<a name="ln1839">						MAX(abdiff[1][2],abdiff[1][3]));</a>
<a name="ln1840"> </a>
<a name="ln1841">					for (d=0; d &lt; 2; d++) {</a>
<a name="ln1842">						for (i=0; i &lt; 4; i++) {</a>
<a name="ln1843">							if (ldiff[d][i] &lt;= leps &amp;&amp; abdiff[d][i] &lt;= abeps)</a>
<a name="ln1844">								homo[d][tr][tc]++;</a>
<a name="ln1845">						}</a>
<a name="ln1846">					}</a>
<a name="ln1847">				}</a>
<a name="ln1848">			}</a>
<a name="ln1849"> </a>
<a name="ln1850">			/* Combine the most homogenous pixels for the final result: */</a>
<a name="ln1851">			for (row = top + 3; row &lt; top + TS - 3 &amp;&amp; row &lt; fInputHeight - 3;</a>
<a name="ln1852">					row++) {</a>
<a name="ln1853">				tr = row - top;</a>
<a name="ln1854">				for (col = left + 3; col &lt; left + TS - 3</a>
<a name="ln1855">						&amp;&amp; col &lt; fInputWidth - 3; col++) {</a>
<a name="ln1856">					tc = col - left;</a>
<a name="ln1857">					for (d = 0; d &lt; 2; d++) {</a>
<a name="ln1858">						for (hm[d] = 0, i = tr - 1; i &lt;= tr + 1; i++) {</a>
<a name="ln1859">							for (j = tc - 1; j &lt;= tc + 1; j++) {</a>
<a name="ln1860">								hm[d] += homo[d][i][j];</a>
<a name="ln1861">							}</a>
<a name="ln1862">						}</a>
<a name="ln1863">					}</a>
<a name="ln1864">					if (hm[0] != hm[1]) {</a>
<a name="ln1865">						for (c = 0; c &lt; 3; c++) {</a>
<a name="ln1866">							fImageData[row * fInputWidth + col][c]</a>
<a name="ln1867">								= rgb[hm[1] &gt; hm[0]][tr][tc][c];</a>
<a name="ln1868">						}</a>
<a name="ln1869">					} else {</a>
<a name="ln1870">						for (c = 0; c &lt; 3; c++) {</a>
<a name="ln1871">							fImageData[row * fInputWidth + col][c]</a>
<a name="ln1872">								= (rgb[0][tr][tc][c] + rgb[1][tr][tc][c]) &gt;&gt; 1;</a>
<a name="ln1873">						}</a>
<a name="ln1874">					}</a>
<a name="ln1875">				}</a>
<a name="ln1876">			}</a>
<a name="ln1877">		}</a>
<a name="ln1878">	}</a>
<a name="ln1879">	free(buffer);</a>
<a name="ln1880">#undef TS</a>
<a name="ln1881">}</a>
<a name="ln1882"> </a>
<a name="ln1883"> </a>
<a name="ln1884">void</a>
<a name="ln1885">DCRaw::_PseudoInverse(double (*in)[3], double (*out)[3], uint32 size)</a>
<a name="ln1886">{</a>
<a name="ln1887">	double work[3][6], num;</a>
<a name="ln1888">	uint32 i, j, k;</a>
<a name="ln1889"> </a>
<a name="ln1890">	for (i = 0; i &lt; 3; i++) {</a>
<a name="ln1891">		for (j = 0; j &lt; 6; j++) {</a>
<a name="ln1892">			work[i][j] = j == i + 3;</a>
<a name="ln1893">		}</a>
<a name="ln1894">		for (j = 0; j &lt; 3; j++) {</a>
<a name="ln1895">			for (k = 0; k &lt; size; k++) {</a>
<a name="ln1896">				work[i][j] += in[k][i] * in[k][j];</a>
<a name="ln1897">			}</a>
<a name="ln1898">		}</a>
<a name="ln1899">	}</a>
<a name="ln1900"> </a>
<a name="ln1901">	for (i = 0; i &lt; 3; i++) {</a>
<a name="ln1902">		num = work[i][i];</a>
<a name="ln1903">		for (j = 0; j &lt; 6; j++) {</a>
<a name="ln1904">			work[i][j] /= num;</a>
<a name="ln1905">		}</a>
<a name="ln1906">		for (k = 0; k &lt; 3; k++) {</a>
<a name="ln1907">			if (k == i)</a>
<a name="ln1908">				continue;</a>
<a name="ln1909"> </a>
<a name="ln1910">			num = work[k][i];</a>
<a name="ln1911"> </a>
<a name="ln1912">			for (j = 0; j &lt; 6; j++) {</a>
<a name="ln1913">				work[k][j] -= work[i][j] * num;</a>
<a name="ln1914">			}</a>
<a name="ln1915">		}</a>
<a name="ln1916">	}</a>
<a name="ln1917"> </a>
<a name="ln1918">	for (i = 0; i &lt; size; i++) {</a>
<a name="ln1919">		for (j = 0; j &lt; 3; j++) {</a>
<a name="ln1920">			for (out[i][j] = k =0; k &lt; 3; k++) {</a>
<a name="ln1921">				out[i][j] += work[j][k+3] * in[i][k];</a>
<a name="ln1922">			}</a>
<a name="ln1923">		}</a>
<a name="ln1924">	}</a>
<a name="ln1925">}</a>
<a name="ln1926"> </a>
<a name="ln1927"> </a>
<a name="ln1928">void</a>
<a name="ln1929">DCRaw::_ConvertToRGB()</a>
<a name="ln1930">{</a>
<a name="ln1931">	if (fProgressMonitor != NULL)</a>
<a name="ln1932">		fProgressMonitor(&quot;Convert to RGB&quot;, 90, fProgressData);</a>
<a name="ln1933"> </a>
<a name="ln1934">	uint32 row, col, c, i, j, k;</a>
<a name="ln1935">	float out[3], out_cam[3][4];</a>
<a name="ln1936">	double num, inverse[3][3];</a>
<a name="ln1937">	static const double xyzd50_srgb[3][3] = {</a>
<a name="ln1938">		{ 0.436083, 0.385083, 0.143055 },</a>
<a name="ln1939">		{ 0.222507, 0.716888, 0.060608 },</a>
<a name="ln1940">		{ 0.013930, 0.097097, 0.714022 }};</a>
<a name="ln1941">	static const double rgb_rgb[3][3] = {</a>
<a name="ln1942">		{ 1,0,0 }, { 0,1,0 }, { 0,0,1 }};</a>
<a name="ln1943">	static const double adobe_rgb[3][3] = {</a>
<a name="ln1944">		{ 0.715146, 0.284856, 0.000000 },</a>
<a name="ln1945">		{ 0.000000, 1.000000, 0.000000 },</a>
<a name="ln1946">		{ 0.000000, 0.041166, 0.958839 }};</a>
<a name="ln1947">	static const double wide_rgb[3][3] = {</a>
<a name="ln1948">		{ 0.593087, 0.404710, 0.002206 },</a>
<a name="ln1949">		{ 0.095413, 0.843149, 0.061439 },</a>
<a name="ln1950">		{ 0.011621, 0.069091, 0.919288 }};</a>
<a name="ln1951">	static const double prophoto_rgb[3][3] = {</a>
<a name="ln1952">		{ 0.529317, 0.330092, 0.140588 },</a>
<a name="ln1953">		{ 0.098368, 0.873465, 0.028169 },</a>
<a name="ln1954">		{ 0.016879, 0.117663, 0.865457 }};</a>
<a name="ln1955">	static const double (*out_rgb[])[3]</a>
<a name="ln1956">		= { rgb_rgb, adobe_rgb, wide_rgb, prophoto_rgb, xyz_rgb };</a>
<a name="ln1957">	static const char *name[] = { &quot;sRGB&quot;, &quot;Adobe RGB (1998)&quot;, &quot;WideGamut D65&quot;,</a>
<a name="ln1958">		&quot;ProPhoto D65&quot;, &quot;XYZ&quot; };</a>
<a name="ln1959">	static const unsigned phead[] = { 1024, 0, 0x2100000, 0x6d6e7472,</a>
<a name="ln1960">		0x52474220, 0x58595a20, 0, 0, 0, 0x61637370, 0, 0, 0x6e6f6e65,</a>
<a name="ln1961">		0, 0, 0, 0, 0xf6d6, 0x10000, 0xd32d };</a>
<a name="ln1962">	unsigned pbody[] = { 10,</a>
<a name="ln1963">		0x63707274, 0, 36,	/* cprt */</a>
<a name="ln1964">		0x64657363, 0, 40,	/* desc */</a>
<a name="ln1965">		0x77747074, 0, 20,	/* wtpt */</a>
<a name="ln1966">		0x626b7074, 0, 20,	/* bkpt */</a>
<a name="ln1967">		0x72545243, 0, 14,	/* rTRC */</a>
<a name="ln1968">		0x67545243, 0, 14,	/* gTRC */</a>
<a name="ln1969">		0x62545243, 0, 14,	/* bTRC */</a>
<a name="ln1970">		0x7258595a, 0, 20,	/* rXYZ */</a>
<a name="ln1971">		0x6758595a, 0, 20,	/* gXYZ */</a>
<a name="ln1972">		0x6258595a, 0, 20 };	/* bXYZ */</a>
<a name="ln1973">	static const unsigned pwhite[] = { 0xf351, 0x10000, 0x116cc };</a>
<a name="ln1974">	unsigned pcurve[] = { 0x63757276, 0, 1, 0x1000000 };</a>
<a name="ln1975"> </a>
<a name="ln1976">	memcpy(out_cam, fMeta.rgb_camera, sizeof(out_cam));</a>
<a name="ln1977">	fRawColor |= fColors == 1 || fDocumentMode</a>
<a name="ln1978">		|| fOutputColor &lt; 1 || fOutputColor &gt; 5;</a>
<a name="ln1979">	if (!fRawColor) {</a>
<a name="ln1980">		fOutputProfile = (uint32 *)calloc(phead[0], 1);</a>
<a name="ln1981">		if (fOutputProfile == NULL)</a>
<a name="ln1982">			throw (status_t)B_NO_MEMORY;</a>
<a name="ln1983"> </a>
<a name="ln1984">		memcpy(fOutputProfile, phead, sizeof(phead));</a>
<a name="ln1985">		if (fOutputColor == 5)</a>
<a name="ln1986">			fOutputProfile[4] = fOutputProfile[5];</a>
<a name="ln1987"> </a>
<a name="ln1988">		fOutputProfile[0] = 132 + 12 * pbody[0];</a>
<a name="ln1989">		for (i = 0; i &lt; pbody[0]; i++) {</a>
<a name="ln1990">			fOutputProfile[fOutputProfile[0] / 4]</a>
<a name="ln1991">				= i ? (i &gt; 1 ? 0x58595a20 : 0x64657363) : 0x74657874;</a>
<a name="ln1992">			pbody[i*3+2] = fOutputProfile[0];</a>
<a name="ln1993">			fOutputProfile[0] += (pbody[i*3+3] + 3) &amp; -4;</a>
<a name="ln1994">		}</a>
<a name="ln1995"> </a>
<a name="ln1996">		memcpy(fOutputProfile + 32, pbody, sizeof(pbody));</a>
<a name="ln1997">		fOutputProfile[pbody[5] / 4 + 2] = strlen(name[fOutputColor - 1]) + 1;</a>
<a name="ln1998">		memcpy((char *)fOutputProfile + pbody[8] + 8, pwhite, sizeof(pwhite));</a>
<a name="ln1999">		if (fOutputBitsPerSample == 8) {</a>
<a name="ln2000">#ifdef SRGB_GAMMA</a>
<a name="ln2001">			pcurve[3] = 0x2330000;</a>
<a name="ln2002">#else</a>
<a name="ln2003">			pcurve[3] = 0x1f00000;</a>
<a name="ln2004">#endif</a>
<a name="ln2005">		}</a>
<a name="ln2006"> </a>
<a name="ln2007">		for (i = 4; i &lt; 7; i++) {</a>
<a name="ln2008">			memcpy((char *)fOutputProfile + pbody[i * 3 + 2], pcurve,</a>
<a name="ln2009">				sizeof(pcurve));</a>
<a name="ln2010">		}</a>
<a name="ln2011"> </a>
<a name="ln2012">		_PseudoInverse((double (*)[3])out_rgb[fOutputColor - 1], inverse, 3);</a>
<a name="ln2013"> </a>
<a name="ln2014">		for (i = 0; i &lt; 3; i++) {</a>
<a name="ln2015">			for (j = 0; j &lt; 3; j++) {</a>
<a name="ln2016">				for (num = k=0; k &lt; 3; k++) {</a>
<a name="ln2017">					num += xyzd50_srgb[i][k] * inverse[j][k];</a>
<a name="ln2018">				}</a>
<a name="ln2019">				fOutputProfile[pbody[j * 3 + 23] / 4 + i + 2]</a>
<a name="ln2020">					= uint32(num * 0x10000 + 0.5);</a>
<a name="ln2021">			}</a>
<a name="ln2022">		}</a>
<a name="ln2023">		for (i = 0; i &lt; phead[0]/4; i++) {</a>
<a name="ln2024">			fOutputProfile[i] = B_HOST_TO_BENDIAN_INT32(fOutputProfile[i]);</a>
<a name="ln2025">		}</a>
<a name="ln2026">		strcpy((char *)fOutputProfile + pbody[2] + 8,</a>
<a name="ln2027">			&quot;auto-generated by dcraw&quot;);</a>
<a name="ln2028">		strcpy((char *)fOutputProfile + pbody[5] + 12, name[fOutputColor - 1]);</a>
<a name="ln2029"> </a>
<a name="ln2030">		for (i = 0; i &lt; 3; i++) {</a>
<a name="ln2031">			for (j = 0; j &lt; fColors; j++) {</a>
<a name="ln2032">				for (out_cam[i][j] = k = 0; k &lt; 3; k++) {</a>
<a name="ln2033">					out_cam[i][j] += out_rgb[fOutputColor-1][i][k]</a>
<a name="ln2034">						* fMeta.rgb_camera[k][j];</a>
<a name="ln2035">				}</a>
<a name="ln2036">			}</a>
<a name="ln2037">		}</a>
<a name="ln2038">	}</a>
<a name="ln2039"> </a>
<a name="ln2040">	if (1/*verbose*/) {</a>
<a name="ln2041">		if (fRawColor)</a>
<a name="ln2042">			fprintf(stderr, &quot;Building histograms...\n&quot;);</a>
<a name="ln2043">		else {</a>
<a name="ln2044">			fprintf(stderr, &quot;Converting to %s colorspace...\n&quot;,</a>
<a name="ln2045">				name[fOutputColor - 1]);</a>
<a name="ln2046">		}</a>
<a name="ln2047">	}</a>
<a name="ln2048"> </a>
<a name="ln2049">	ushort* img = fImageData[0];</a>
<a name="ln2050">	memset(fHistogram, 0, sizeof(int32) * 0x2000 * 4);</a>
<a name="ln2051"> </a>
<a name="ln2052">	for (row = 0; row &lt; fInputHeight; row++) {</a>
<a name="ln2053">		for (col = 0; col &lt; fInputWidth; col++, img += 4) {</a>
<a name="ln2054">			if (!fRawColor) {</a>
<a name="ln2055">				out[0] = out[1] = out[2] = 0;</a>
<a name="ln2056">				for (c = 0; c &lt; fColors; c++) {</a>
<a name="ln2057">					out[0] += out_cam[0][c] * img[c];</a>
<a name="ln2058">					out[1] += out_cam[1][c] * img[c];</a>
<a name="ln2059">					out[2] += out_cam[2][c] * img[c];</a>
<a name="ln2060">				}</a>
<a name="ln2061">				for (c = 0; c &lt; 3; c++) {</a>
<a name="ln2062">					img[c] = CLIP((int)out[c]);</a>
<a name="ln2063">				}</a>
<a name="ln2064">			} else if (fDocumentMode)</a>
<a name="ln2065">				img[0] = img[FC(row, col)];</a>
<a name="ln2066"> </a>
<a name="ln2067">			for (c = 0; c &lt; fColors; c++) {</a>
<a name="ln2068">				fHistogram[img[c] &gt;&gt; 3][c]++;</a>
<a name="ln2069">			}</a>
<a name="ln2070">		}</a>
<a name="ln2071">	}</a>
<a name="ln2072"> </a>
<a name="ln2073">	if (fColors == 4 &amp;&amp; fOutputColor)</a>
<a name="ln2074">		fColors = 3;</a>
<a name="ln2075">	if (fDocumentMode &amp;&amp; fFilters)</a>
<a name="ln2076">		fColors = 1;</a>
<a name="ln2077">}</a>
<a name="ln2078"> </a>
<a name="ln2079"> </a>
<a name="ln2080">void</a>
<a name="ln2081">DCRaw::_GammaLookUpTable(uchar* lut)</a>
<a name="ln2082">{</a>
<a name="ln2083">	int32 percent, val, total, i;</a>
<a name="ln2084">	float white = 0, r;</a>
<a name="ln2085"> </a>
<a name="ln2086">	percent = int32(fInputWidth * fInputHeight * 0.01);</a>
<a name="ln2087">		// 99th percentile white point</a>
<a name="ln2088"> </a>
<a name="ln2089">	//  if (fuji_width) perc /= 2;</a>
<a name="ln2090">	if (fHighlight)</a>
<a name="ln2091">		percent = 0;</a>
<a name="ln2092"> </a>
<a name="ln2093">	for (uint32 c = 0; c &lt; fColors; c++) {</a>
<a name="ln2094">		for (val = 0x2000, total = 0; --val &gt; 32;) {</a>
<a name="ln2095">			if ((total += fHistogram[val][c]) &gt; percent)</a>
<a name="ln2096">				break;</a>
<a name="ln2097">		}</a>
<a name="ln2098">		if (white &lt; val)</a>
<a name="ln2099">			white = val;</a>
<a name="ln2100">	}</a>
<a name="ln2101"> </a>
<a name="ln2102">	white *= 8 / fBrightness;</a>
<a name="ln2103"> </a>
<a name="ln2104">	for (i = 0; i &lt; 0x10000; i++) {</a>
<a name="ln2105">		r = i / white;</a>
<a name="ln2106">		val = int32(256 * (!fUseGamma ? r :</a>
<a name="ln2107">#ifdef SRGB_GAMMA</a>
<a name="ln2108">			r &lt;= 0.00304 ? r*12.92 : pow(r,2.5/6)*1.055-0.055));</a>
<a name="ln2109">#else</a>
<a name="ln2110">			r &lt;= 0.018 ? r*4.5 : pow(r,0.45)*1.099-0.099));</a>
<a name="ln2111">#endif</a>
<a name="ln2112">		if (val &gt; 255)</a>
<a name="ln2113">			val = 255;</a>
<a name="ln2114">		lut[i] = val;</a>
<a name="ln2115">	}</a>
<a name="ln2116">}</a>
<a name="ln2117"> </a>
<a name="ln2118"> </a>
<a name="ln2119">//	#pragma mark - Lossless JPEG</a>
<a name="ln2120"> </a>
<a name="ln2121"> </a>
<a name="ln2122">void</a>
<a name="ln2123">DCRaw::_InitDecoder()</a>
<a name="ln2124">{</a>
<a name="ln2125">	memset(fDecodeBuffer, 0, sizeof(decode) * kDecodeBufferCount);</a>
<a name="ln2126">	fFreeDecode = fDecodeBuffer;</a>
<a name="ln2127">}</a>
<a name="ln2128"> </a>
<a name="ln2129"> </a>
<a name="ln2130">/*!	Construct a decode tree according the specification in *source.</a>
<a name="ln2131">	The first 16 bytes specify how many codes should be 1-bit, 2-bit</a>
<a name="ln2132">	3-bit, etc.  Bytes after that are the leaf values.</a>
<a name="ln2133"> </a>
<a name="ln2134">	For example, if the source is</a>
<a name="ln2135"> </a>
<a name="ln2136">	{ 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,</a>
<a name="ln2137">	  0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff  },</a>
<a name="ln2138"> </a>
<a name="ln2139">	then the code is</a>
<a name="ln2140"> </a>
<a name="ln2141">	00		0x04</a>
<a name="ln2142">	010		0x03</a>
<a name="ln2143">	011		0x05</a>
<a name="ln2144">	100		0x06</a>
<a name="ln2145">	101		0x02</a>
<a name="ln2146">	1100		0x07</a>
<a name="ln2147">	1101		0x01</a>
<a name="ln2148">	11100		0x08</a>
<a name="ln2149">	11101		0x09</a>
<a name="ln2150">	11110		0x00</a>
<a name="ln2151">	111110		0x0a</a>
<a name="ln2152">	1111110		0x0b</a>
<a name="ln2153">	1111111		0xff</a>
<a name="ln2154">*/</a>
<a name="ln2155">uchar *</a>
<a name="ln2156">DCRaw::_MakeDecoder(const uchar* source, int level)</a>
<a name="ln2157">{</a>
<a name="ln2158">	if (level == 0)</a>
<a name="ln2159">		fDecodeLeaf = 0;</a>
<a name="ln2160"> </a>
<a name="ln2161">	if ((uint8*)fFreeDecode &gt; (uint8*)fDecodeBuffer</a>
<a name="ln2162">			+ sizeof(decode) * kDecodeBufferCount) {</a>
<a name="ln2163">		fprintf(stderr, &quot;decoder table overflow\n&quot;);</a>
<a name="ln2164">		throw (status_t)B_ERROR;</a>
<a name="ln2165">	}</a>
<a name="ln2166"> </a>
<a name="ln2167">	struct decode* current = fFreeDecode++;</a>
<a name="ln2168"> </a>
<a name="ln2169">	int i, next;</a>
<a name="ln2170">	for (i = next = 0; i &lt;= fDecodeLeaf &amp;&amp; next &lt; 16; ) {</a>
<a name="ln2171">		i += source[next++];</a>
<a name="ln2172">	}</a>
<a name="ln2173"> </a>
<a name="ln2174">	if (i &gt; fDecodeLeaf) {</a>
<a name="ln2175">		if (level &lt; next) {</a>
<a name="ln2176">			current-&gt;branch[0] = fFreeDecode;</a>
<a name="ln2177">			_MakeDecoder(source, level + 1);</a>
<a name="ln2178">			current-&gt;branch[1] = fFreeDecode;</a>
<a name="ln2179">			_MakeDecoder(source, level + 1);</a>
<a name="ln2180">		} else</a>
<a name="ln2181">			current-&gt;leaf = source[16 + fDecodeLeaf++];</a>
<a name="ln2182">	}</a>
<a name="ln2183"> </a>
<a name="ln2184">	return (uchar*)source + 16 + fDecodeLeaf;</a>
<a name="ln2185">}</a>
<a name="ln2186"> </a>
<a name="ln2187"> </a>
<a name="ln2188">/*!	Not a full implementation of Lossless JPEG, just</a>
<a name="ln2189">	enough to decode Canon, Kodak and Adobe DNG images.</a>
<a name="ln2190">*/</a>
<a name="ln2191">void</a>
<a name="ln2192">DCRaw::_InitDecodeBits()</a>
<a name="ln2193">{</a>
<a name="ln2194">	fDecodeBits = fDecodeBitsRead = 0;</a>
<a name="ln2195">	fDecodeBitsReset = false;</a>
<a name="ln2196">}</a>
<a name="ln2197"> </a>
<a name="ln2198"> </a>
<a name="ln2199">/*!	_GetDecodeBits(n) where 0 &lt;= n &lt;= 25 returns an n-bit integer</a>
<a name="ln2200">*/</a>
<a name="ln2201">uint32</a>
<a name="ln2202">DCRaw::_GetDecodeBits(uint32 numBits)</a>
<a name="ln2203">{</a>
<a name="ln2204">	if (numBits == 0 || fDecodeBitsReset)</a>
<a name="ln2205">		return 0;</a>
<a name="ln2206"> </a>
<a name="ln2207">	while (fDecodeBitsRead &lt; numBits) {</a>
<a name="ln2208">		uint8 c = fRead.Next&lt;uint8&gt;();</a>
<a name="ln2209">		if ((fDecodeBitsReset = fDecodeBitsZeroAfterMax</a>
<a name="ln2210">				&amp;&amp; c == 0xff &amp;&amp; fRead.Next&lt;uint8&gt;()))</a>
<a name="ln2211">			return 0;</a>
<a name="ln2212">		fDecodeBits = (fDecodeBits &lt;&lt; 8) + c;</a>
<a name="ln2213">		fDecodeBitsRead += 8;</a>
<a name="ln2214">	}</a>
<a name="ln2215"> </a>
<a name="ln2216">	fDecodeBitsRead -= numBits;</a>
<a name="ln2217"> </a>
<a name="ln2218">	return fDecodeBits &lt;&lt; (32 - numBits - fDecodeBitsRead) &gt;&gt; (32 - numBits);</a>
<a name="ln2219">}</a>
<a name="ln2220"> </a>
<a name="ln2221"> </a>
<a name="ln2222">status_t</a>
<a name="ln2223">DCRaw::_LosslessJPEGInit(struct jhead* jh, bool infoOnly)</a>
<a name="ln2224">{</a>
<a name="ln2225">	int i, tag, len;</a>
<a name="ln2226"> </a>
<a name="ln2227">	_InitDecoder();</a>
<a name="ln2228"> </a>
<a name="ln2229">	for (i = 0; i &lt; 4; i++) {</a>
<a name="ln2230">		jh-&gt;huff[i] = fFreeDecode;</a>
<a name="ln2231">	}</a>
<a name="ln2232"> </a>
<a name="ln2233">	jh-&gt;restart = INT_MAX;</a>
<a name="ln2234"> </a>
<a name="ln2235">	uchar data[0x10000], *dp;</a>
<a name="ln2236">	fRead(data, 2);</a>
<a name="ln2237">	if (data[1] != 0xd8)</a>
<a name="ln2238">		return B_ERROR;</a>
<a name="ln2239"> </a>
<a name="ln2240">	do {</a>
<a name="ln2241">		fRead(data, 4);</a>
<a name="ln2242">		tag = data[0] &lt;&lt; 8 | data[1];</a>
<a name="ln2243">		len = (data[2] &lt;&lt; 8 | data[3]) - 2;</a>
<a name="ln2244">		if (tag &lt;= 0xff00)</a>
<a name="ln2245">			return B_ERROR;</a>
<a name="ln2246"> </a>
<a name="ln2247">		fRead(data, len);</a>
<a name="ln2248">		switch (tag) {</a>
<a name="ln2249">			case 0xffc0:</a>
<a name="ln2250">			case 0xffc3:</a>
<a name="ln2251">				jh-&gt;bits = data[0];</a>
<a name="ln2252">				jh-&gt;high = data[1] &lt;&lt; 8 | data[2];</a>
<a name="ln2253">				jh-&gt;wide = data[3] &lt;&lt; 8 | data[4];</a>
<a name="ln2254">				jh-&gt;clrs = data[5];</a>
<a name="ln2255">				break;</a>
<a name="ln2256">			case 0xffc4:</a>
<a name="ln2257">				if (infoOnly)</a>
<a name="ln2258">					break;</a>
<a name="ln2259"> </a>
<a name="ln2260">				for (dp = data; dp &lt; data+len &amp;&amp; *dp &lt; 4; ) {</a>
<a name="ln2261">					jh-&gt;huff[*dp] = fFreeDecode;</a>
<a name="ln2262">					dp = _MakeDecoder(++dp, 0);</a>
<a name="ln2263">				}</a>
<a name="ln2264">				break;</a>
<a name="ln2265">			case 0xffdd:</a>
<a name="ln2266">				jh-&gt;restart = data[0] &lt;&lt; 8 | data[1];</a>
<a name="ln2267">				break;</a>
<a name="ln2268">		}</a>
<a name="ln2269">	} while (tag != 0xffda);</a>
<a name="ln2270"> </a>
<a name="ln2271">	if (infoOnly)</a>
<a name="ln2272">		return B_OK;</a>
<a name="ln2273"> </a>
<a name="ln2274">	jh-&gt;row = (ushort *)calloc(jh-&gt;wide*jh-&gt;clrs, 2);</a>
<a name="ln2275">	if (jh-&gt;row == NULL)</a>
<a name="ln2276">		throw (status_t)B_NO_MEMORY;</a>
<a name="ln2277"> </a>
<a name="ln2278">	fDecodeBitsZeroAfterMax = true;</a>
<a name="ln2279">	return B_OK;</a>
<a name="ln2280">}</a>
<a name="ln2281"> </a>
<a name="ln2282"> </a>
<a name="ln2283">int</a>
<a name="ln2284">DCRaw::_LosslessJPEGDiff(struct decode *dindex)</a>
<a name="ln2285">{</a>
<a name="ln2286">	while (dindex-&gt;branch[0]) {</a>
<a name="ln2287">		dindex = dindex-&gt;branch[_GetDecodeBits(1)];</a>
<a name="ln2288">	}</a>
<a name="ln2289"> </a>
<a name="ln2290">	int length = dindex-&gt;leaf;</a>
<a name="ln2291">	if (length == 16 &amp;&amp; (!fDNGVersion || fDNGVersion &gt;= 0x1010000))</a>
<a name="ln2292">		return -32768;</a>
<a name="ln2293"> </a>
<a name="ln2294">	int diff = _GetDecodeBits(length);</a>
<a name="ln2295">	if ((diff &amp; (1 &lt;&lt; (length - 1))) == 0)</a>
<a name="ln2296">		diff -= (1 &lt;&lt; length) - 1;</a>
<a name="ln2297"> </a>
<a name="ln2298">	return diff;</a>
<a name="ln2299">}</a>
<a name="ln2300"> </a>
<a name="ln2301"> </a>
<a name="ln2302">void</a>
<a name="ln2303">DCRaw::_LosslessJPEGRow(struct jhead *jh, int jrow)</a>
<a name="ln2304">{</a>
<a name="ln2305">	if (jrow * jh-&gt;wide % jh-&gt;restart == 0) {</a>
<a name="ln2306">		for (uint32 i = 0; i &lt; 4; i++) {</a>
<a name="ln2307">			jh-&gt;vpred[i] = 1 &lt;&lt; (jh-&gt;bits - 1);</a>
<a name="ln2308">		}</a>
<a name="ln2309">		if (jrow) {</a>
<a name="ln2310">			uint16 mark = 0;</a>
<a name="ln2311">			int c;</a>
<a name="ln2312">			do {</a>
<a name="ln2313">				mark = (mark &lt;&lt; 8) + (c = fRead.Next&lt;uint8&gt;());</a>
<a name="ln2314">			} while (c != EOF &amp;&amp; mark &gt;&gt; 4 != 0xffd);</a>
<a name="ln2315">		}</a>
<a name="ln2316">		_InitDecodeBits();</a>
<a name="ln2317">	}</a>
<a name="ln2318"> </a>
<a name="ln2319">	uint16* outp = jh-&gt;row;</a>
<a name="ln2320"> </a>
<a name="ln2321">	for (int32 col = 0; col &lt; jh-&gt;wide; col++) {</a>
<a name="ln2322">		for (int32 c = 0; c &lt; jh-&gt;clrs; c++) {</a>
<a name="ln2323">			int32 diff = _LosslessJPEGDiff(jh-&gt;huff[c]);</a>
<a name="ln2324">			*outp = col ? outp[-jh-&gt;clrs]+diff : (jh-&gt;vpred[c] += diff);</a>
<a name="ln2325">			outp++;</a>
<a name="ln2326">		}</a>
<a name="ln2327">	}</a>
<a name="ln2328">}</a>
<a name="ln2329"> </a>
<a name="ln2330"> </a>
<a name="ln2331">//	#pragma mark - RAW loaders</a>
<a name="ln2332"> </a>
<a name="ln2333"> </a>
<a name="ln2334">void</a>
<a name="ln2335">DCRaw::_LoadRAWUnpacked(const image_data_info&amp; image)</a>
<a name="ln2336">{</a>
<a name="ln2337">	uint32 rawWidth = _Raw().width;</a>
<a name="ln2338"> </a>
<a name="ln2339">	uint16* pixel = (uint16*)calloc(rawWidth, sizeof(uint16));</a>
<a name="ln2340">	if (pixel == NULL)</a>
<a name="ln2341">		return;</a>
<a name="ln2342"> </a>
<a name="ln2343">	fRead.Seek((fTopMargin * rawWidth + fLeftMargin) * sizeof(uint16),</a>
<a name="ln2344">		SEEK_CUR);</a>
<a name="ln2345"> </a>
<a name="ln2346">	for (uint32 row = 0; row &lt; fInputHeight; row++) {</a>
<a name="ln2347">		fRead.NextShorts(pixel, rawWidth);</a>
<a name="ln2348">		for (uint32 column = 0; column &lt; fInputWidth; column++) {</a>
<a name="ln2349">			_Bayer(column, row) = pixel[column];</a>
<a name="ln2350">		}</a>
<a name="ln2351">	}</a>
<a name="ln2352"> </a>
<a name="ln2353">	free(pixel);</a>
<a name="ln2354">}</a>
<a name="ln2355"> </a>
<a name="ln2356"> </a>
<a name="ln2357">/*!	This is, for example, used in PENTAX RAW images</a>
<a name="ln2358">*/</a>
<a name="ln2359">void</a>
<a name="ln2360">DCRaw::_LoadRAWPacked12(const image_data_info&amp; image)</a>
<a name="ln2361">{</a>
<a name="ln2362">	uint32 rawWidth = _Raw().width;</a>
<a name="ln2363"> </a>
<a name="ln2364">	_InitDecodeBits();</a>
<a name="ln2365"> </a>
<a name="ln2366">	for (uint32 row = 0; row &lt; fInputHeight; row++) {</a>
<a name="ln2367">		for (uint32 column = 0; column &lt; fInputWidth; column++) {</a>
<a name="ln2368">			//uint16 bits = _GetDecodeBits(12);</a>
<a name="ln2369">			_Bayer(column, row) = _GetDecodeBits(12);</a>
<a name="ln2370">			//fImageData[((row) &gt;&gt; fShrink)*fOutputWidth + ((column) &gt;&gt; fShrink)][FC(row,column)] = bits;</a>
<a name="ln2371">		}</a>
<a name="ln2372">		for (uint32 column = fInputWidth * 3 / 2; column &lt; rawWidth; column++) {</a>
<a name="ln2373">			_GetDecodeBits(8);</a>
<a name="ln2374">		}</a>
<a name="ln2375">	}</a>
<a name="ln2376">}</a>
<a name="ln2377"> </a>
<a name="ln2378"> </a>
<a name="ln2379">void</a>
<a name="ln2380">DCRaw::_MakeCanonDecoder(uint32 table)</a>
<a name="ln2381">{</a>
<a name="ln2382">	static const uchar kFirstTree[3][29] = {</a>
<a name="ln2383">		{ 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,</a>
<a name="ln2384">			0x04,0x03,0x05,0x06,0x02,0x07,0x01,0x08,0x09,0x00,0x0a,0x0b,0xff },</a>
<a name="ln2385">		{ 0,2,2,3,1,1,1,1,2,0,0,0,0,0,0,0,</a>
<a name="ln2386">			0x03,0x02,0x04,0x01,0x05,0x00,0x06,0x07,0x09,0x08,0x0a,0x0b,0xff },</a>
<a name="ln2387">		{ 0,0,6,3,1,1,2,0,0,0,0,0,0,0,0,0,</a>
<a name="ln2388">			0x06,0x05,0x07,0x04,0x08,0x03,0x09,0x02,0x00,0x0a,0x01,0x0b,0xff },</a>
<a name="ln2389">	};</a>
<a name="ln2390">	static const uchar kSecondTree[3][180] = {</a>
<a name="ln2391">		{ 0,2,2,2,1,4,2,1,2,5,1,1,0,0,0,139,</a>
<a name="ln2392">			0x03,0x04,0x02,0x05,0x01,0x06,0x07,0x08,</a>
<a name="ln2393">			0x12,0x13,0x11,0x14,0x09,0x15,0x22,0x00,0x21,0x16,0x0a,0xf0,</a>
<a name="ln2394">			0x23,0x17,0x24,0x31,0x32,0x18,0x19,0x33,0x25,0x41,0x34,0x42,</a>
<a name="ln2395">			0x35,0x51,0x36,0x37,0x38,0x29,0x79,0x26,0x1a,0x39,0x56,0x57,</a>
<a name="ln2396">			0x28,0x27,0x52,0x55,0x58,0x43,0x76,0x59,0x77,0x54,0x61,0xf9,</a>
<a name="ln2397">			0x71,0x78,0x75,0x96,0x97,0x49,0xb7,0x53,0xd7,0x74,0xb6,0x98,</a>
<a name="ln2398">			0x47,0x48,0x95,0x69,0x99,0x91,0xfa,0xb8,0x68,0xb5,0xb9,0xd6,</a>
<a name="ln2399">			0xf7,0xd8,0x67,0x46,0x45,0x94,0x89,0xf8,0x81,0xd5,0xf6,0xb4,</a>
<a name="ln2400">			0x88,0xb1,0x2a,0x44,0x72,0xd9,0x87,0x66,0xd4,0xf5,0x3a,0xa7,</a>
<a name="ln2401">			0x73,0xa9,0xa8,0x86,0x62,0xc7,0x65,0xc8,0xc9,0xa1,0xf4,0xd1,</a>
<a name="ln2402">			0xe9,0x5a,0x92,0x85,0xa6,0xe7,0x93,0xe8,0xc1,0xc6,0x7a,0x64,</a>
<a name="ln2403">			0xe1,0x4a,0x6a,0xe6,0xb3,0xf1,0xd3,0xa5,0x8a,0xb2,0x9a,0xba,</a>
<a name="ln2404">			0x84,0xa4,0x63,0xe5,0xc5,0xf3,0xd2,0xc4,0x82,0xaa,0xda,0xe4,</a>
<a name="ln2405">			0xf2,0xca,0x83,0xa3,0xa2,0xc3,0xea,0xc2,0xe2,0xe3,0xff,0xff },</a>
<a name="ln2406">		{ 0,2,2,1,4,1,4,1,3,3,1,0,0,0,0,140,</a>
<a name="ln2407">			0x02,0x03,0x01,0x04,0x05,0x12,0x11,0x06,</a>
<a name="ln2408">			0x13,0x07,0x08,0x14,0x22,0x09,0x21,0x00,0x23,0x15,0x31,0x32,</a>
<a name="ln2409">			0x0a,0x16,0xf0,0x24,0x33,0x41,0x42,0x19,0x17,0x25,0x18,0x51,</a>
<a name="ln2410">			0x34,0x43,0x52,0x29,0x35,0x61,0x39,0x71,0x62,0x36,0x53,0x26,</a>
<a name="ln2411">			0x38,0x1a,0x37,0x81,0x27,0x91,0x79,0x55,0x45,0x28,0x72,0x59,</a>
<a name="ln2412">			0xa1,0xb1,0x44,0x69,0x54,0x58,0xd1,0xfa,0x57,0xe1,0xf1,0xb9,</a>
<a name="ln2413">			0x49,0x47,0x63,0x6a,0xf9,0x56,0x46,0xa8,0x2a,0x4a,0x78,0x99,</a>
<a name="ln2414">			0x3a,0x75,0x74,0x86,0x65,0xc1,0x76,0xb6,0x96,0xd6,0x89,0x85,</a>
<a name="ln2415">			0xc9,0xf5,0x95,0xb4,0xc7,0xf7,0x8a,0x97,0xb8,0x73,0xb7,0xd8,</a>
<a name="ln2416">			0xd9,0x87,0xa7,0x7a,0x48,0x82,0x84,0xea,0xf4,0xa6,0xc5,0x5a,</a>
<a name="ln2417">			0x94,0xa4,0xc6,0x92,0xc3,0x68,0xb5,0xc8,0xe4,0xe5,0xe6,0xe9,</a>
<a name="ln2418">			0xa2,0xa3,0xe3,0xc2,0x66,0x67,0x93,0xaa,0xd4,0xd5,0xe7,0xf8,</a>
<a name="ln2419">			0x88,0x9a,0xd7,0x77,0xc4,0x64,0xe2,0x98,0xa5,0xca,0xda,0xe8,</a>
<a name="ln2420">			0xf3,0xf6,0xa9,0xb2,0xb3,0xf2,0xd2,0x83,0xba,0xd3,0xff,0xff },</a>
<a name="ln2421">		{ 0,0,6,2,1,3,3,2,5,1,2,2,8,10,0,117,</a>
<a name="ln2422">			0x04,0x05,0x03,0x06,0x02,0x07,0x01,0x08,</a>
<a name="ln2423">			0x09,0x12,0x13,0x14,0x11,0x15,0x0a,0x16,0x17,0xf0,0x00,0x22,</a>
<a name="ln2424">			0x21,0x18,0x23,0x19,0x24,0x32,0x31,0x25,0x33,0x38,0x37,0x34,</a>
<a name="ln2425">			0x35,0x36,0x39,0x79,0x57,0x58,0x59,0x28,0x56,0x78,0x27,0x41,</a>
<a name="ln2426">			0x29,0x77,0x26,0x42,0x76,0x99,0x1a,0x55,0x98,0x97,0xf9,0x48,</a>
<a name="ln2427">			0x54,0x96,0x89,0x47,0xb7,0x49,0xfa,0x75,0x68,0xb6,0x67,0x69,</a>
<a name="ln2428">			0xb9,0xb8,0xd8,0x52,0xd7,0x88,0xb5,0x74,0x51,0x46,0xd9,0xf8,</a>
<a name="ln2429">			0x3a,0xd6,0x87,0x45,0x7a,0x95,0xd5,0xf6,0x86,0xb4,0xa9,0x94,</a>
<a name="ln2430">			0x53,0x2a,0xa8,0x43,0xf5,0xf7,0xd4,0x66,0xa7,0x5a,0x44,0x8a,</a>
<a name="ln2431">			0xc9,0xe8,0xc8,0xe7,0x9a,0x6a,0x73,0x4a,0x61,0xc7,0xf4,0xc6,</a>
<a name="ln2432">			0x65,0xe9,0x72,0xe6,0x71,0x91,0x93,0xa6,0xda,0x92,0x85,0x62,</a>
<a name="ln2433">			0xf3,0xc5,0xb2,0xa4,0x84,0xba,0x64,0xa5,0xb3,0xd2,0x81,0xe5,</a>
<a name="ln2434">			0xd3,0xaa,0xc4,0xca,0xf2,0xb1,0xe4,0xd1,0x83,0x63,0xea,0xc3,</a>
<a name="ln2435">			0xe2,0x82,0xf1,0xa3,0xc2,0xa1,0xc1,0xe3,0xa2,0xe1,0xff,0xff }</a>
<a name="ln2436">	};</a>
<a name="ln2437"> </a>
<a name="ln2438">	if (table &gt; 2)</a>
<a name="ln2439">		table = 2;</a>
<a name="ln2440"> </a>
<a name="ln2441">	_InitDecoder();</a>
<a name="ln2442"> </a>
<a name="ln2443">	_MakeDecoder(kFirstTree[table], 0);</a>
<a name="ln2444">	fSecondDecode = fFreeDecode;</a>
<a name="ln2445">	_MakeDecoder(kSecondTree[table], 0);</a>
<a name="ln2446">}</a>
<a name="ln2447"> </a>
<a name="ln2448"> </a>
<a name="ln2449">/*!	Return 0 if the image starts with compressed data,</a>
<a name="ln2450">	1 if it starts with uncompressed low-order bits.</a>
<a name="ln2451"> </a>
<a name="ln2452">	In Canon compressed data, 0xff is always followed by 0x00.</a>
<a name="ln2453">*/</a>
<a name="ln2454">bool</a>
<a name="ln2455">DCRaw::_CanonHasLowBits()</a>
<a name="ln2456">{</a>
<a name="ln2457">	bool hasLowBits = true;</a>
<a name="ln2458">	uchar test[0x4000 - 540];</a>
<a name="ln2459"> </a>
<a name="ln2460">	fRead.Seek(540, SEEK_SET);</a>
<a name="ln2461">	fRead(test, sizeof(test));</a>
<a name="ln2462"> </a>
<a name="ln2463">	for (uint32 i = 0; i &lt; sizeof(test) - 1; i++)</a>
<a name="ln2464">		if (test[i] == 0xff) {</a>
<a name="ln2465">			if (test[i + 1])</a>
<a name="ln2466">				return 1;</a>
<a name="ln2467">			hasLowBits = 0;</a>
<a name="ln2468">    }</a>
<a name="ln2469"> </a>
<a name="ln2470">	return hasLowBits;</a>
<a name="ln2471">}</a>
<a name="ln2472"> </a>
<a name="ln2473"> </a>
<a name="ln2474">void</a>
<a name="ln2475">DCRaw::_LoadRAWCanonCompressed(const image_data_info&amp; image)</a>
<a name="ln2476">{</a>
<a name="ln2477">	uint32 rawWidth = _Raw().width;</a>
<a name="ln2478">	int carry = 0, pnum = 0, base[2];</a>
<a name="ln2479"> </a>
<a name="ln2480">	_MakeCanonDecoder(image.compression);</a>
<a name="ln2481"> </a>
<a name="ln2482">	uint16* pixel = (uint16 *)calloc(rawWidth * 8, sizeof(*pixel));</a>
<a name="ln2483">	if (pixel == NULL)</a>
<a name="ln2484">		throw (status_t)B_NO_MEMORY;</a>
<a name="ln2485"> </a>
<a name="ln2486">	bool hasLowBits = _CanonHasLowBits();</a>
<a name="ln2487">	if (!hasLowBits)</a>
<a name="ln2488">		fMeta.maximum = 0x3ff;</a>
<a name="ln2489"> </a>
<a name="ln2490">	fRead.Seek(540 + (hasLowBits ? _Raw().height * rawWidth / 4 : 0),</a>
<a name="ln2491">		SEEK_SET);</a>
<a name="ln2492"> </a>
<a name="ln2493">	fDecodeBitsZeroAfterMax = true;</a>
<a name="ln2494">	_InitDecodeBits();</a>
<a name="ln2495"> </a>
<a name="ln2496">	for (uint32 row = 0; row &lt; _Raw().height; row += 8) {</a>
<a name="ln2497">		for (uint32 block = 0; block &lt; rawWidth &gt;&gt; 3; block++) {</a>
<a name="ln2498">			int diffbuf[64];</a>
<a name="ln2499">			memset(diffbuf, 0, sizeof diffbuf);</a>
<a name="ln2500">			struct decode* decode = fDecodeBuffer;</a>
<a name="ln2501"> </a>
<a name="ln2502">			for (uint32 i = 0; i &lt; 64; i++) {</a>
<a name="ln2503">				struct decode* dindex = decode;</a>
<a name="ln2504">				while (dindex-&gt;branch[0]) {</a>
<a name="ln2505">					dindex = dindex-&gt;branch[_GetDecodeBits(1)];</a>
<a name="ln2506">				}</a>
<a name="ln2507">				int leaf = dindex-&gt;leaf;</a>
<a name="ln2508">				decode = fSecondDecode;</a>
<a name="ln2509">				if (leaf == 0 &amp;&amp; i)</a>
<a name="ln2510">					break;</a>
<a name="ln2511">				if (leaf == 0xff)</a>
<a name="ln2512">					continue;</a>
<a name="ln2513">				i += leaf &gt;&gt; 4;</a>
<a name="ln2514"> </a>
<a name="ln2515">				int len = leaf &amp; 15;</a>
<a name="ln2516">				if (len == 0)</a>
<a name="ln2517">					continue;</a>
<a name="ln2518">				int diff = _GetDecodeBits(len);</a>
<a name="ln2519">				if ((diff &amp; (1 &lt;&lt; (len-1))) == 0)</a>
<a name="ln2520">					diff -= (1 &lt;&lt; len) - 1;</a>
<a name="ln2521">				if (i &lt; 64)</a>
<a name="ln2522">					diffbuf[i] = diff;</a>
<a name="ln2523">			}</a>
<a name="ln2524"> </a>
<a name="ln2525">			diffbuf[0] += carry;</a>
<a name="ln2526">			carry = diffbuf[0];</a>
<a name="ln2527"> </a>
<a name="ln2528">			for (uint32 i = 0; i &lt; 64; i++) {</a>
<a name="ln2529">				if (pnum++ % _Raw().width == 0)</a>
<a name="ln2530">					base[0] = base[1] = 512;</a>
<a name="ln2531">				pixel[(block &lt;&lt; 6) + i] = (base[i &amp; 1] += diffbuf[i]);</a>
<a name="ln2532">			}</a>
<a name="ln2533">		}</a>
<a name="ln2534"> </a>
<a name="ln2535">		if (hasLowBits) {</a>
<a name="ln2536">			off_t savedOffset = fRead.Position();</a>
<a name="ln2537">			fRead.Seek(26 + row * _Raw().width / 4, SEEK_SET);</a>
<a name="ln2538"> </a>
<a name="ln2539">			uint16* pixelRow = pixel;</a>
<a name="ln2540">			for (uint32 i = 0; i &lt; rawWidth * 2; i++) {</a>
<a name="ln2541">				uint8 c = fRead.Next&lt;uint8&gt;();</a>
<a name="ln2542"> </a>
<a name="ln2543">				for (uint32 r = 0; r &lt; 8; r += 2, pixelRow++) {</a>
<a name="ln2544">					uint32 val = (*pixelRow &lt;&lt; 2) + ((c &gt;&gt; r) &amp; 3);</a>
<a name="ln2545">					if (rawWidth == 2672 &amp;&amp; val &lt; 512)</a>
<a name="ln2546">						val += 2;</a>
<a name="ln2547">					*pixelRow = val;</a>
<a name="ln2548">				}</a>
<a name="ln2549">			}</a>
<a name="ln2550"> </a>
<a name="ln2551">			fRead.Seek(savedOffset, SEEK_SET);</a>
<a name="ln2552">		}</a>
<a name="ln2553"> </a>
<a name="ln2554">		for (uint32 r = 0; r &lt; 8; r++) {</a>
<a name="ln2555">			uint32 irow = row - fTopMargin + r;</a>
<a name="ln2556">			if (irow &gt;= fInputHeight)</a>
<a name="ln2557">				continue;</a>
<a name="ln2558"> </a>
<a name="ln2559">			for (uint32 col = 0; col &lt; rawWidth; col++) {</a>
<a name="ln2560">				uint32 icol = col - fLeftMargin;</a>
<a name="ln2561">				if (icol &lt; fInputWidth)</a>
<a name="ln2562">					_Bayer(icol, irow) = pixel[r * rawWidth + col];</a>
<a name="ln2563">				else</a>
<a name="ln2564">					fMeta.black += pixel[r * rawWidth + col];</a>
<a name="ln2565">			}</a>
<a name="ln2566">		}</a>
<a name="ln2567">	}</a>
<a name="ln2568"> </a>
<a name="ln2569">	free(pixel);</a>
<a name="ln2570"> </a>
<a name="ln2571">	if (rawWidth &gt; fInputWidth)</a>
<a name="ln2572">		fMeta.black /= (rawWidth - fInputWidth) * fInputHeight;</a>
<a name="ln2573">}</a>
<a name="ln2574"> </a>
<a name="ln2575"> </a>
<a name="ln2576">void</a>
<a name="ln2577">DCRaw::_LoadRAWLosslessJPEG(const image_data_info&amp; image)</a>
<a name="ln2578">{</a>
<a name="ln2579">	int jwide, jrow, jcol, val, jidx, i, j, row = 0, col = 0;</a>
<a name="ln2580">	uint32 rawWidth = _Raw().width;</a>
<a name="ln2581">	int min = INT_MAX;</a>
<a name="ln2582"> </a>
<a name="ln2583">	struct jhead jh;</a>
<a name="ln2584">	if (_LosslessJPEGInit(&amp;jh, false) != B_OK)</a>
<a name="ln2585">		throw (status_t)B_NO_TRANSLATOR;</a>
<a name="ln2586"> </a>
<a name="ln2587">	jwide = jh.wide * jh.clrs;</a>
<a name="ln2588"> </a>
<a name="ln2589">	for (jrow = 0; jrow &lt; jh.high; jrow++) {</a>
<a name="ln2590">		_LosslessJPEGRow(&amp;jh, jrow);</a>
<a name="ln2591"> </a>
<a name="ln2592">		for (jcol = 0; jcol &lt; jwide; jcol++) {</a>
<a name="ln2593">			val = jh.row[jcol];</a>
<a name="ln2594">			if (jh.bits &lt;= 12)</a>
<a name="ln2595">				val = fCurve[val];</a>
<a name="ln2596"> </a>
<a name="ln2597">			if (fCR2Slice[0]) {</a>
<a name="ln2598">				jidx = jrow * jwide + jcol;</a>
<a name="ln2599">				i = jidx / (fCR2Slice[1] * jh.high);</a>
<a name="ln2600">				if ((j = i &gt;= fCR2Slice[0]))</a>
<a name="ln2601">					i  = fCR2Slice[0];</a>
<a name="ln2602">				jidx -= i * (fCR2Slice[1] * jh.high);</a>
<a name="ln2603">				row = jidx / fCR2Slice[1 + j];</a>
<a name="ln2604">				col = jidx % fCR2Slice[1 + j] + i * fCR2Slice[1];</a>
<a name="ln2605">			}</a>
<a name="ln2606"> </a>
<a name="ln2607">			if (_Raw().width == 3984 &amp;&amp; (col -= 2) &lt; 0) {</a>
<a name="ln2608">				col += rawWidth;</a>
<a name="ln2609">				row--;</a>
<a name="ln2610">			}</a>
<a name="ln2611"> </a>
<a name="ln2612">			if (uint32(row - fTopMargin) &lt; fInputHeight) {</a>
<a name="ln2613">				if (uint32(col - fLeftMargin) &lt; fInputWidth) {</a>
<a name="ln2614">					_Bayer(col - fLeftMargin, row - fTopMargin) = val;</a>
<a name="ln2615">					if (min &gt; val)</a>
<a name="ln2616">						min = val;</a>
<a name="ln2617">				} else</a>
<a name="ln2618">					fMeta.black += val;</a>
<a name="ln2619">			}</a>
<a name="ln2620">			if (++col &gt;= (int32)rawWidth) {</a>
<a name="ln2621">				col = 0;</a>
<a name="ln2622">				row++;</a>
<a name="ln2623">			}</a>
<a name="ln2624">		}</a>
<a name="ln2625">	}</a>
<a name="ln2626"> </a>
<a name="ln2627">	//dump_to_disk(fImageData, fInputWidth * fColors * 100);</a>
<a name="ln2628">	free(jh.row);</a>
<a name="ln2629"> </a>
<a name="ln2630">	if (rawWidth &gt; fInputWidth)</a>
<a name="ln2631">		fMeta.black /= (rawWidth - fInputWidth) * fInputHeight;</a>
<a name="ln2632">	if (_IsKodak())</a>
<a name="ln2633">		fMeta.black = min;</a>
<a name="ln2634">}</a>
<a name="ln2635"> </a>
<a name="ln2636"> </a>
<a name="ln2637">void</a>
<a name="ln2638">DCRaw::_LoadRAW(const image_data_info&amp; image)</a>
<a name="ln2639">{</a>
<a name="ln2640">#if 0</a>
<a name="ln2641">	if (_IsCanon()) {</a>
<a name="ln2642">		if (fIsTIFF)</a>
<a name="ln2643">		else</a>
<a name="ln2644">			_LoadRAWCanonCompressed(image);</a>
<a name="ln2645">	} else</a>
<a name="ln2646">#endif</a>
<a name="ln2647">	{</a>
<a name="ln2648">		switch (image.compression) {</a>
<a name="ln2649">			case COMPRESSION_NONE:</a>
<a name="ln2650">				_LoadRAWUnpacked(image);</a>
<a name="ln2651">				break;</a>
<a name="ln2652">			case COMPRESSION_OLD_JPEG:</a>
<a name="ln2653">				_LoadRAWLosslessJPEG(image);</a>
<a name="ln2654">				//_LoadRAWCanonCompressed(image);</a>
<a name="ln2655">				break;</a>
<a name="ln2656">			case COMPRESSION_PACKBITS:</a>
<a name="ln2657">				_LoadRAWPacked12(image);</a>
<a name="ln2658">				break;</a>
<a name="ln2659"> </a>
<a name="ln2660">			default:</a>
<a name="ln2661">				fprintf(stderr, &quot;DCRaw: unknown compression: %&quot; B_PRId32 &quot;\n&quot;,</a>
<a name="ln2662">					image.compression);</a>
<a name="ln2663">				throw (status_t)B_NO_TRANSLATOR;</a>
<a name="ln2664">				break;</a>
<a name="ln2665">		}</a>
<a name="ln2666">	}</a>
<a name="ln2667">}</a>
<a name="ln2668"> </a>
<a name="ln2669"> </a>
<a name="ln2670">//	#pragma mark - Image writers</a>
<a name="ln2671"> </a>
<a name="ln2672"> </a>
<a name="ln2673">void</a>
<a name="ln2674">DCRaw::_WriteRGB32(image_data_info&amp; image, uint8* outputBuffer)</a>
<a name="ln2675">{</a>
<a name="ln2676">	if (fProgressMonitor != NULL)</a>
<a name="ln2677">		fProgressMonitor(&quot;Write RGB&quot;, 95, fProgressData);</a>
<a name="ln2678"> </a>
<a name="ln2679">	uint8* line, lookUpTable[0x10000];</a>
<a name="ln2680"> </a>
<a name="ln2681">	uint32 width = image.flip &gt; 4 ? fOutputHeight : fOutputWidth;</a>
<a name="ln2682">	uint32 height = image.flip &gt; 4 ? fOutputWidth : fOutputHeight;</a>
<a name="ln2683">	uint32 outputRow = (4 * fOutputBitsPerSample / 8) * width;</a>
<a name="ln2684">	uint32 outputOffset = 0;</a>
<a name="ln2685"> </a>
<a name="ln2686">	line = (uint8 *)malloc(outputRow);</a>
<a name="ln2687">	if (line == NULL)</a>
<a name="ln2688">		throw (status_t)B_NO_MEMORY;</a>
<a name="ln2689"> </a>
<a name="ln2690">	memset(line, 0, outputRow);</a>
<a name="ln2691"> </a>
<a name="ln2692">	if (fOutputBitsPerSample == 8)</a>
<a name="ln2693">		_GammaLookUpTable(lookUpTable);</a>
<a name="ln2694"> </a>
<a name="ln2695">	int32 sourceOffset = _FlipIndex(0, 0, image.flip);</a>
<a name="ln2696">	int32 colStep = _FlipIndex(0, 1, image.flip) - sourceOffset;</a>
<a name="ln2697">	int32 rowStep = _FlipIndex(1, 0, image.flip)</a>
<a name="ln2698">		- _FlipIndex(0, width, image.flip);</a>
<a name="ln2699"> </a>
<a name="ln2700">	TRACE((&quot;flip = %ld, sourceOffset = %ld, colStep = %ld, rowStep = %ld, &quot;</a>
<a name="ln2701">		&quot;input: %lu x %lu, output: %lu x %lu\n&quot;, image.flip, sourceOffset,</a>
<a name="ln2702">		colStep, rowStep, fInputWidth, fInputHeight, width,</a>
<a name="ln2703">		height));</a>
<a name="ln2704"> </a>
<a name="ln2705">	if (fOutputBitsPerSample == 8) {</a>
<a name="ln2706">		for (uint32 row = 0; row &lt; height; row++, sourceOffset += rowStep) {</a>
<a name="ln2707">			for (uint32 col = 0; col &lt; width; col++, sourceOffset += colStep) {</a>
<a name="ln2708">				line[col * 4 + 2] = lookUpTable[fImageData[sourceOffset][0]];</a>
<a name="ln2709">				line[col * 4 + 1] = lookUpTable[fImageData[sourceOffset][1]];</a>
<a name="ln2710">				line[col * 4 + 0] = lookUpTable[fImageData[sourceOffset][2]];</a>
<a name="ln2711">			}</a>
<a name="ln2712"> </a>
<a name="ln2713">			memcpy(&amp;outputBuffer[outputOffset], line, outputRow);</a>
<a name="ln2714">			outputOffset += outputRow;</a>
<a name="ln2715">		}</a>
<a name="ln2716">	} else {</a>
<a name="ln2717">#if 0</a>
<a name="ln2718">		uint16* ppm2 = (uint16*)line;</a>
<a name="ln2719">		for (row = 0; row &lt; fOutputHeight; row++, soff += rstep) {</a>
<a name="ln2720">			for (col = 0; col &lt; fOutputWidth; col++, soff += cstep) {</a>
<a name="ln2721">				FORCC ppm2[col*colors+c] =     image[soff][c];</a>
<a name="ln2722">			}</a>
<a name="ln2723">			if (!output_tiff &amp;&amp; htons(0x55aa) != 0x55aa)</a>
<a name="ln2724">				swab (ppm2, ppm2, width*colors*2);</a>
<a name="ln2725">			fwrite (ppm, colors*output_bps/8, width, ofp);</a>
<a name="ln2726">		}</a>
<a name="ln2727">#endif</a>
<a name="ln2728">	}</a>
<a name="ln2729"> </a>
<a name="ln2730">	free(line);</a>
<a name="ln2731">}</a>
<a name="ln2732"> </a>
<a name="ln2733"> </a>
<a name="ln2734">void</a>
<a name="ln2735">DCRaw::_WriteJPEG(image_data_info&amp; image, uint8* outputBuffer)</a>
<a name="ln2736">{</a>
<a name="ln2737">	fRead(outputBuffer, image.bytes);</a>
<a name="ln2738"> </a>
<a name="ln2739">	if (outputBuffer[0] != 0xff || outputBuffer[1] != 0xd8)</a>
<a name="ln2740">		throw (status_t)B_NO_TRANSLATOR;</a>
<a name="ln2741"> </a>
<a name="ln2742">#if 0</a>
<a name="ln2743">	uint8* thumb = (uint8*)malloc(image.bytes);</a>
<a name="ln2744">	if (thumb == NULL)</a>
<a name="ln2745">		throw (status_t)B_NO_MEMORY;</a>
<a name="ln2746"> </a>
<a name="ln2747">	fRead(thumb, image.bytes);</a>
<a name="ln2748"> </a>
<a name="ln2749">	uint8* data = (uint8*)fImageData;</a>
<a name="ln2750">	data[0] = 0xff;</a>
<a name="ln2751">	data[1] = 0xd8;</a>
<a name="ln2752"> </a>
<a name="ln2753">	if (strcmp((char *)thumb + 6, &quot;Exif&quot;)) {</a>
<a name="ln2754">		// TODO: no EXIF data - write them ourselves</a>
<a name="ln2755">	}</a>
<a name="ln2756"> </a>
<a name="ln2757">	memcpy(&amp;data[2], thumb + 2, image.bytes - 2);</a>
<a name="ln2758">	free(thumb);</a>
<a name="ln2759">#endif</a>
<a name="ln2760">}</a>
<a name="ln2761"> </a>
<a name="ln2762"> </a>
<a name="ln2763">//	#pragma mark - TIFF</a>
<a name="ln2764"> </a>
<a name="ln2765"> </a>
<a name="ln2766">time_t</a>
<a name="ln2767">DCRaw::_ParseTIFFTimestamp(bool reversed)</a>
<a name="ln2768">{</a>
<a name="ln2769">	char str[20];</a>
<a name="ln2770">	str[19] = 0;</a>
<a name="ln2771"> </a>
<a name="ln2772">	if (reversed) {</a>
<a name="ln2773">		for (int i = 19; i--; ) {</a>
<a name="ln2774">			str[i] = fRead.Next&lt;uint8&gt;();</a>
<a name="ln2775">		}</a>
<a name="ln2776">	} else</a>
<a name="ln2777">		fRead(str, 19);</a>
<a name="ln2778"> </a>
<a name="ln2779">	struct tm t;</a>
<a name="ln2780">	memset(&amp;t, 0, sizeof t);</a>
<a name="ln2781"> </a>
<a name="ln2782">	if (sscanf(str, &quot;%d:%d:%d %d:%d:%d&quot;, &amp;t.tm_year, &amp;t.tm_mon,</a>
<a name="ln2783">			&amp;t.tm_mday, &amp;t.tm_hour, &amp;t.tm_min, &amp;t.tm_sec) != 6)</a>
<a name="ln2784">		return 0;</a>
<a name="ln2785"> </a>
<a name="ln2786">	t.tm_year -= 1900;</a>
<a name="ln2787">	t.tm_mon -= 1;</a>
<a name="ln2788"> </a>
<a name="ln2789">	return mktime(&amp;t);</a>
<a name="ln2790">}</a>
<a name="ln2791"> </a>
<a name="ln2792"> </a>
<a name="ln2793">/*!	Reads a TIFF tag and positions the file stream to its data section</a>
<a name="ln2794">*/</a>
<a name="ln2795">void</a>
<a name="ln2796">DCRaw::_ParseTIFFTag(off_t baseOffset, tiff_tag&amp; tag, off_t&amp; offset)</a>
<a name="ln2797">{</a>
<a name="ln2798">	fRead(tag.tag);</a>
<a name="ln2799">	fRead(tag.type);</a>
<a name="ln2800">	fRead(tag.length);</a>
<a name="ln2801"> </a>
<a name="ln2802">	offset = fRead.Position() + 4;</a>
<a name="ln2803"> </a>
<a name="ln2804">	uint32 length = tag.length;</a>
<a name="ln2805"> </a>
<a name="ln2806">	switch (tag.type) {</a>
<a name="ln2807">		case TIFF_UINT16_TYPE:</a>
<a name="ln2808">		case TIFF_INT16_TYPE:</a>
<a name="ln2809">			length *= 2;</a>
<a name="ln2810">			break;</a>
<a name="ln2811"> </a>
<a name="ln2812">		case TIFF_UINT32_TYPE:</a>
<a name="ln2813">		case TIFF_INT32_TYPE:</a>
<a name="ln2814">		case TIFF_FLOAT_TYPE:</a>
<a name="ln2815">			length *= 4;</a>
<a name="ln2816">			break;</a>
<a name="ln2817"> </a>
<a name="ln2818">		case TIFF_UFRACTION_TYPE:</a>
<a name="ln2819">		case TIFF_FRACTION_TYPE:</a>
<a name="ln2820">		case TIFF_DOUBLE_TYPE:</a>
<a name="ln2821">			length *= 8;</a>
<a name="ln2822">			break;</a>
<a name="ln2823"> </a>
<a name="ln2824">		default:</a>
<a name="ln2825">			break;</a>
<a name="ln2826">	}</a>
<a name="ln2827"> </a>
<a name="ln2828">	if (length &gt; 4) {</a>
<a name="ln2829">		uint32 position;</a>
<a name="ln2830">		fRead(position);</a>
<a name="ln2831"> </a>
<a name="ln2832">		fRead.Seek(baseOffset + position, SEEK_SET);</a>
<a name="ln2833">	}</a>
<a name="ln2834">}</a>
<a name="ln2835"> </a>
<a name="ln2836"> </a>
<a name="ln2837">status_t</a>
<a name="ln2838">DCRaw::_ParseTIFFImageFileDirectory(off_t baseOffset, uint32 offset)</a>
<a name="ln2839">{</a>
<a name="ln2840">	double analogBalance[] = {1, 1, 1, 1};</a>
<a name="ln2841">	double xyz[] = {1, 1, 1, 1};</a>
<a name="ln2842">	bool useColorMatrix = false;</a>
<a name="ln2843">	double cameraCalibration[4][4], colorMatrix[4][3], cameraXYZ[4][3];</a>
<a name="ln2844"> </a>
<a name="ln2845">	for (int32 j = 0; j &lt; 4; j++) {</a>
<a name="ln2846">		for (int32 i = 0; i &lt; 4; i++) {</a>
<a name="ln2847">			cameraCalibration[j][i] = i == j;</a>
<a name="ln2848">		}</a>
<a name="ln2849">	}</a>
<a name="ln2850"> </a>
<a name="ln2851">	fRead.Seek(baseOffset + offset, SEEK_SET);</a>
<a name="ln2852"> </a>
<a name="ln2853">	uint16 tags;</a>
<a name="ln2854">	fRead(tags);</a>
<a name="ln2855">	if (tags &gt; 512)</a>
<a name="ln2856">		return B_BAD_DATA;</a>
<a name="ln2857"> </a>
<a name="ln2858">	image_data_info&amp; image = fImages[fNumImages];</a>
<a name="ln2859"> </a>
<a name="ln2860">	while (tags--) {</a>
<a name="ln2861">		off_t nextOffset;</a>
<a name="ln2862">		tiff_tag tag;</a>
<a name="ln2863">		_ParseTIFFTag(baseOffset, tag, nextOffset);</a>
<a name="ln2864">		TAG(&quot;TIFF tag: %u\n&quot;, tag.tag);</a>
<a name="ln2865"> </a>
<a name="ln2866">		switch (tag.tag) {</a>
<a name="ln2867">#if 0</a>
<a name="ln2868">			default:</a>
<a name="ln2869">				printf(&quot;tag %u NOT HANDLED!\n&quot;, tag.tag);</a>
<a name="ln2870">				break;</a>
<a name="ln2871">#endif</a>
<a name="ln2872"> </a>
<a name="ln2873">			case 17:</a>
<a name="ln2874">			case 18:</a>
<a name="ln2875">				if (tag.type == 3 &amp;&amp; tag.length == 1) {</a>
<a name="ln2876">					fMeta.camera_multipliers[(tag.tag - 17) * 2]</a>
<a name="ln2877">						= fRead.Next&lt;uint16&gt;() / 256.0;</a>
<a name="ln2878">				}</a>
<a name="ln2879">				break;</a>
<a name="ln2880"> </a>
<a name="ln2881">			case 23:	// ISO speed</a>
<a name="ln2882">				fMeta.iso_speed = fRead.Next(tag.type);</a>
<a name="ln2883">				break;</a>
<a name="ln2884"> </a>
<a name="ln2885">			case 36:</a>
<a name="ln2886">			case 37:</a>
<a name="ln2887">			case 38:</a>
<a name="ln2888">				fMeta.camera_multipliers[tag.tag - 0x24] = fRead.Next&lt;uint16&gt;();</a>
<a name="ln2889">				break;</a>
<a name="ln2890"> </a>
<a name="ln2891">			case 39:</a>
<a name="ln2892">				if (tag.length &lt; 50 || fMeta.camera_multipliers[0])</a>
<a name="ln2893">					break;</a>
<a name="ln2894"> </a>
<a name="ln2895">				fRead.Stream().Seek(12, SEEK_CUR);</a>
<a name="ln2896">				for (uint32 i = 0; i &lt; 3; i++) {</a>
<a name="ln2897">					fMeta.camera_multipliers[i] = fRead.Next&lt;uint16&gt;();</a>
<a name="ln2898">				}</a>
<a name="ln2899">				break;</a>
<a name="ln2900"> </a>
<a name="ln2901">			case 2:		// image width</a>
<a name="ln2902">			case 256:</a>
<a name="ln2903">				image.width = fRead.Next(tag.type);</a>
<a name="ln2904">				break;</a>
<a name="ln2905"> </a>
<a name="ln2906">			case 3:		// image height</a>
<a name="ln2907">			case 257:</a>
<a name="ln2908">				image.height = fRead.Next(tag.type);</a>
<a name="ln2909">				break;</a>
<a name="ln2910"> </a>
<a name="ln2911">			case 258:	// bits per sample</a>
<a name="ln2912">				image.samples = tag.length;</a>
<a name="ln2913">				image.bits_per_sample = fRead.Next&lt;uint16&gt;();</a>
<a name="ln2914">				break;</a>
<a name="ln2915"> </a>
<a name="ln2916">			case 259:	// compression</a>
<a name="ln2917">				image.compression = fRead.Next&lt;uint16&gt;();</a>
<a name="ln2918">				break;</a>
<a name="ln2919"> </a>
<a name="ln2920">			case 262:	// Photometric Interpretation</a>
<a name="ln2921">				image.photometric_interpretation = fRead.Next&lt;uint16&gt;();</a>
<a name="ln2922">				break;</a>
<a name="ln2923"> </a>
<a name="ln2924">			case 271:	// manufacturer</a>
<a name="ln2925">				fRead(fMeta.manufacturer, 64);</a>
<a name="ln2926">				break;</a>
<a name="ln2927"> </a>
<a name="ln2928">			case 272:	// model</a>
<a name="ln2929">				fRead(fMeta.model, 64);</a>
<a name="ln2930">				break;</a>
<a name="ln2931"> </a>
<a name="ln2932">			case 273:	// Strip Offset</a>
<a name="ln2933">			case 513:</a>
<a name="ln2934">				image.data_offset = baseOffset + fRead.Next&lt;uint32&gt;();</a>
<a name="ln2935">				if (!image.bits_per_sample) {</a>
<a name="ln2936">					fRead.Stream().Seek(image.data_offset, SEEK_SET);</a>
<a name="ln2937">					jhead jh;</a>
<a name="ln2938">					if (_LosslessJPEGInit(&amp;jh, true) == B_OK) {</a>
<a name="ln2939">						image.compression = 6;</a>
<a name="ln2940">						image.width = jh.wide &lt;&lt; (jh.clrs == 2);</a>
<a name="ln2941">						image.height = jh.high;</a>
<a name="ln2942">						image.bits_per_sample = jh.bits;</a>
<a name="ln2943">						image.samples = jh.clrs;</a>
<a name="ln2944">					}</a>
<a name="ln2945">				}</a>
<a name="ln2946">				break;</a>
<a name="ln2947"> </a>
<a name="ln2948">			case 274:	// Orientation</a>
<a name="ln2949">				image.flip = fRead.Next&lt;uint16&gt;();</a>
<a name="ln2950">				break;</a>
<a name="ln2951"> </a>
<a name="ln2952">			case 277:	// Samples Per Pixel</a>
<a name="ln2953">				image.samples = fRead.Next(tag.type);</a>
<a name="ln2954">				break;</a>
<a name="ln2955"> </a>
<a name="ln2956">			case 279:	// Strip Byte Counts</a>
<a name="ln2957">			case 514:</a>
<a name="ln2958">				image.bytes = fRead.Next&lt;uint32&gt;();</a>
<a name="ln2959">				break;</a>
<a name="ln2960"> </a>
<a name="ln2961">			case 305:	// Software</a>
<a name="ln2962">				fRead(fMeta.software, 64);</a>
<a name="ln2963">				if (!strncmp(fMeta.software, &quot;Adobe&quot;, 5)</a>
<a name="ln2964">					|| !strncmp(fMeta.software, &quot;dcraw&quot;, 5)</a>
<a name="ln2965">					|| !strncmp(fMeta.software, &quot;Bibble&quot;, 6)</a>
<a name="ln2966">					|| !strncmp(fMeta.software, &quot;Nikon Scan&quot;, 10)</a>
<a name="ln2967">					|| !strcmp(fMeta.software,&quot;Digital Photo Professional&quot;))</a>
<a name="ln2968">					throw (status_t)B_NO_TRANSLATOR;</a>
<a name="ln2969">				break;</a>
<a name="ln2970"> </a>
<a name="ln2971">			case 306:	// Date/Time</a>
<a name="ln2972">				fMeta.timestamp = _ParseTIFFTimestamp(false);</a>
<a name="ln2973">				break;</a>
<a name="ln2974"> </a>
<a name="ln2975">#if 0</a>
<a name="ln2976">			case 323:	// Tile Length</a>
<a name="ln2977">				tile_length = fRead.Next(type);</a>
<a name="ln2978">				break;</a>
<a name="ln2979"> </a>
<a name="ln2980">			case 324:	// Tile Offsets</a>
<a name="ln2981">				image.data_offset = tag.length &gt; 1</a>
<a name="ln2982">					? fRead.Stream().Position() : fRead.Next&lt;uint32&gt;();</a>
<a name="ln2983">				if (tag.length == 4)</a>
<a name="ln2984">					load_raw = &amp;CLASS sinar_4shot_load_raw;</a>
<a name="ln2985">				break;</a>
<a name="ln2986">#endif</a>
<a name="ln2987"> </a>
<a name="ln2988">			case 330:	// Sub IFDs</a>
<a name="ln2989">				if (!strcmp(fMeta.model, &quot;DSLR-A100&quot;) &amp;&amp; image.width == 3872) {</a>
<a name="ln2990">					// TODO: this might no longer work!</a>
<a name="ln2991">					image.data_offset = fRead.Next&lt;uint32&gt;() + baseOffset;</a>
<a name="ln2992">					break;</a>
<a name="ln2993">				}</a>
<a name="ln2994"> </a>
<a name="ln2995">				while (tag.length--) {</a>
<a name="ln2996">					off_t nextOffset = fRead.Position() + sizeof(uint32);</a>
<a name="ln2997"> </a>
<a name="ln2998">					fRead.Seek(fRead.Next&lt;uint32&gt;() + baseOffset, SEEK_SET);</a>
<a name="ln2999">					if (_ParseTIFFImageFileDirectory(baseOffset) != B_OK)</a>
<a name="ln3000">						break;</a>
<a name="ln3001"> </a>
<a name="ln3002">					fNumImages++;</a>
<a name="ln3003">					fRead.Seek(nextOffset, SEEK_SET);</a>
<a name="ln3004">				}</a>
<a name="ln3005">				break;</a>
<a name="ln3006"> </a>
<a name="ln3007">#if 0</a>
<a name="ln3008">			case 400:</a>
<a name="ln3009">				strcpy(fMeta.manufacturer, &quot;Sarnoff&quot;);</a>
<a name="ln3010">				maximum = 0xfff;</a>
<a name="ln3011">				break;</a>
<a name="ln3012">#endif</a>
<a name="ln3013"> </a>
<a name="ln3014">#if 0</a>
<a name="ln3015">			case 29184:</a>
<a name="ln3016">				sony_offset = get4();</a>
<a name="ln3017">				break;</a>
<a name="ln3018">			case 29185:</a>
<a name="ln3019">				sony_length = get4();</a>
<a name="ln3020">				break;</a>
<a name="ln3021">			case 29217:</a>
<a name="ln3022">				sony_key = get4();</a>
<a name="ln3023">				break;</a>
<a name="ln3024">#endif</a>
<a name="ln3025"> </a>
<a name="ln3026">			case 29443:</a>
<a name="ln3027">				for (uint32 i = 0; i &lt; 4; i++) {</a>
<a name="ln3028">					fMeta.camera_multipliers[i ^ (i &lt; 2)] = fRead.Next&lt;uint16&gt;();</a>
<a name="ln3029">				}</a>
<a name="ln3030">				break;</a>
<a name="ln3031"> </a>
<a name="ln3032">			case 33405:	// Model 2</a>
<a name="ln3033">				fRead(fMeta.model + 64, 64);</a>
<a name="ln3034">				break;</a>
<a name="ln3035"> </a>
<a name="ln3036">#if 0</a>
<a name="ln3037">			case 33422:	// CFA Pattern</a>
<a name="ln3038">			case 64777:	// Kodak P-series</a>
<a name="ln3039">			{</a>
<a name="ln3040">				if ((plen=len) &gt; 16) plen = 16;</a>
<a name="ln3041">				fread (cfa_pat, 1, plen, ifp);</a>
<a name="ln3042">				for (colors=cfa=i=0; i &lt; plen; i++) {</a>
<a name="ln3043">				  colors += !(cfa &amp; (1 &lt;&lt; cfa_pat[i]));</a>
<a name="ln3044">				  cfa |= 1 &lt;&lt; cfa_pat[i];</a>
<a name="ln3045">				}</a>
<a name="ln3046">				if (cfa == 070) memcpy (cfa_pc,&quot;\003\004\005&quot;,3);	/* CMY */</a>
<a name="ln3047">				if (cfa == 072) memcpy (cfa_pc,&quot;\005\003\004\001&quot;,4);	/* GMCY */</a>
<a name="ln3048">				goto guess_cfa_pc;</a>
<a name="ln3049">				break;</a>
<a name="ln3050">			}</a>
<a name="ln3051"> </a>
<a name="ln3052">			case 33424:</a>
<a name="ln3053">				fseek(ifp, get4()+base, SEEK_SET);</a>
<a name="ln3054">				parse_kodak_ifd (base);</a>
<a name="ln3055">				break;</a>
<a name="ln3056">#endif</a>
<a name="ln3057"> </a>
<a name="ln3058">			case 33434:	// Exposure Time</a>
<a name="ln3059">				fMeta.shutter = fRead.NextDouble(TIFF_FRACTION_TYPE);</a>
<a name="ln3060">				break;</a>
<a name="ln3061"> </a>
<a name="ln3062">			case 33437:	// Aperture</a>
<a name="ln3063">				fMeta.aperture = fRead.NextDouble(TIFF_FRACTION_TYPE);</a>
<a name="ln3064">				break;</a>
<a name="ln3065"> </a>
<a name="ln3066">			case 34306:	// Leaf white balance</a>
<a name="ln3067">				for (uint32 i = 0; i &lt; 4; i++) {</a>
<a name="ln3068">					fMeta.camera_multipliers[i ^ 1] = 4096.0 / fRead.Next&lt;uint16&gt;();</a>
<a name="ln3069">				}</a>
<a name="ln3070">				break;</a>
<a name="ln3071"> </a>
<a name="ln3072">#if 0</a>
<a name="ln3073">			case 34307:	// Leaf Catch Light color matrix</a>
<a name="ln3074">				fread (software, 1, 7, ifp);</a>
<a name="ln3075">				if (strncmp(software,&quot;MATRIX&quot;,6))</a>
<a name="ln3076">					break;</a>
<a name="ln3077">				colors = 4;</a>
<a name="ln3078">				for (fRawColor = i=0; i &lt; 3; i++) {</a>
<a name="ln3079">					FORC4 fscanf (ifp, &quot;%f&quot;, &amp;rgb_cam[i][c^1]);</a>
<a name="ln3080">					if (!use_camera_wb)</a>
<a name="ln3081">						continue;</a>
<a name="ln3082">					num = 0;</a>
<a name="ln3083">					FORC4 num += rgb_cam[i][c];</a>
<a name="ln3084">					FORC4 rgb_cam[i][c] /= num;</a>
<a name="ln3085">				}</a>
<a name="ln3086">				break;</a>
<a name="ln3087">			case 34310:	// Leaf metadata</a>
<a name="ln3088">				parse_mos (ftell(ifp));</a>
<a name="ln3089">			case 34303:</a>
<a name="ln3090">				strcpy(image.manufacturer, &quot;Leaf&quot;);</a>
<a name="ln3091">				break;</a>
<a name="ln3092">#endif</a>
<a name="ln3093"> </a>
<a name="ln3094">			case 34665:	// EXIF tag</a>
<a name="ln3095">				fRead.Seek(fRead.Next&lt;uint32&gt;() + baseOffset, SEEK_SET);</a>
<a name="ln3096"> </a>
<a name="ln3097">				fEXIFOffset = fRead.Position();</a>
<a name="ln3098">				fEXIFLength = tag.length;</a>
<a name="ln3099"> </a>
<a name="ln3100">				_ParseEXIF(baseOffset);</a>
<a name="ln3101">				break;</a>
<a name="ln3102"> </a>
<a name="ln3103">#if 0</a>
<a name="ln3104">			case 34675:	// InterColorProfile</a>
<a name="ln3105">			case 50831:	// AsShotICCProfile</a>
<a name="ln3106">				profile_offset = fRead.Stream().Position();</a>
<a name="ln3107">				profile_length = tag.length;</a>
<a name="ln3108">				break;</a>
<a name="ln3109"> </a>
<a name="ln3110">			case 37122:	// Compressed Bits Per Pixel</a>
<a name="ln3111">				kodak_cbpp = fRead.Next&lt;uint32&gt;();</a>
<a name="ln3112">				break;</a>
<a name="ln3113">#endif</a>
<a name="ln3114"> </a>
<a name="ln3115">			case 37386:	// Focal Length</a>
<a name="ln3116">				fMeta.focal_length = fRead.NextDouble(TIFF_FRACTION_TYPE);</a>
<a name="ln3117">				break;</a>
<a name="ln3118"> </a>
<a name="ln3119">			case 37393:	// Image Number</a>
<a name="ln3120">				fMeta.shot_order = fRead.Next(tag.type);</a>
<a name="ln3121">				break;</a>
<a name="ln3122"> </a>
<a name="ln3123">#if 0</a>
<a name="ln3124">			case 37400:	// old Kodak KDC tag</a>
<a name="ln3125">				for (fRawColor = i=0; i &lt; 3; i++) {</a>
<a name="ln3126">					getrat();</a>
<a name="ln3127">					FORC3 rgb_cam[i][c] = getrat();</a>
<a name="ln3128">				}</a>
<a name="ln3129">				break;</a>
<a name="ln3130"> </a>
<a name="ln3131">			case 46275:	// Imacon tags</a>
<a name="ln3132">				strcpy (make, &quot;Imacon&quot;);</a>
<a name="ln3133">				data_offset = ftell(ifp);</a>
<a name="ln3134">				ima_len = len;</a>
<a name="ln3135">				break;</a>
<a name="ln3136">      case 46279:</a>
<a name="ln3137">	fseek (ifp, 78, SEEK_CUR);</a>
<a name="ln3138">	raw_width  = get4();</a>
<a name="ln3139">	raw_height = get4();</a>
<a name="ln3140">	left_margin = get4() &amp; 7;</a>
<a name="ln3141">	width = raw_width - left_margin - (get4() &amp; 7);</a>
<a name="ln3142">	top_margin = get4() &amp; 7;</a>
<a name="ln3143">	height = raw_height - top_margin - (get4() &amp; 7);</a>
<a name="ln3144">	fseek (ifp, 52, SEEK_CUR);</a>
<a name="ln3145">	FORC3 cam_multipliers[c] = getreal(11);</a>
<a name="ln3146">	fseek (ifp, 114, SEEK_CUR);</a>
<a name="ln3147">	flip = (get2() &gt;&gt; 7) * 90;</a>
<a name="ln3148">	if (width * height * 6 == ima_len) {</a>
<a name="ln3149">	  if (flip % 180 == 90) SWAP(width,height);</a>
<a name="ln3150">	  filters = flip = 0;</a>
<a name="ln3151">	}</a>
<a name="ln3152">	break;</a>
<a name="ln3153">      case 50454:			/* Sinar tag */</a>
<a name="ln3154">      case 50455:</a>
<a name="ln3155">	if (!(cbuf = (char *) malloc(len))) break;</a>
<a name="ln3156">	fread (cbuf, 1, len, ifp);</a>
<a name="ln3157">	for (cp = cbuf-1; cp &amp;&amp; cp &lt; cbuf+len; cp = strchr(cp,'\n'))</a>
<a name="ln3158">	  if (!strncmp (++cp,&quot;Neutral &quot;,8))</a>
<a name="ln3159">	    sscanf (cp+8, &quot;%f %f %f&quot;, cam_multipliers, cam_multipliers+1, cam_multipliers+2);</a>
<a name="ln3160">	free (cbuf);</a>
<a name="ln3161">	break;</a>
<a name="ln3162">#endif</a>
<a name="ln3163"> </a>
<a name="ln3164">			case 50706:	// DNG Version</a>
<a name="ln3165">				for (int32 i = 0; i &lt; 4; i++) {</a>
<a name="ln3166">					fDNGVersion = (fDNGVersion &lt;&lt; 8) + fRead.Next&lt;uint8&gt;();</a>
<a name="ln3167">				}</a>
<a name="ln3168">				break;</a>
<a name="ln3169"> </a>
<a name="ln3170">#if 0</a>
<a name="ln3171">			case 50710:	// CFAPlaneColor</a>
<a name="ln3172">				if (len &gt; 4)</a>
<a name="ln3173">					len = 4;</a>
<a name="ln3174">				colors = len;</a>
<a name="ln3175">				fread(cfa_pc, 1, colors, ifp);</a>
<a name="ln3176">			guess_cfa_pc:</a>
<a name="ln3177">				FORCC tab[cfa_pc[c]] = c;</a>
<a name="ln3178">				cdesc[c] = 0;</a>
<a name="ln3179">				for (i=16; i--; )</a>
<a name="ln3180">					filters = filters &lt;&lt; 2 | tab[cfa_pat[i % plen]];</a>
<a name="ln3181">				break;</a>
<a name="ln3182">			case 50711:	// CFALayout</a>
<a name="ln3183">				if (get2() == 2) {</a>
<a name="ln3184">					fuji_width = 1;</a>
<a name="ln3185">					filters = 0x49494949;</a>
<a name="ln3186">				}</a>
<a name="ln3187">				break;</a>
<a name="ln3188">#endif</a>
<a name="ln3189"> </a>
<a name="ln3190">			case 291:	// Linearization Table</a>
<a name="ln3191">			case 50712:</a>
<a name="ln3192">				_ParseLinearTable(tag.length);</a>
<a name="ln3193">				break;</a>
<a name="ln3194"> </a>
<a name="ln3195">			case 50714:			/* BlackLevel */</a>
<a name="ln3196">			case 50715:			/* BlackLevelDeltaH */</a>
<a name="ln3197">			case 50716:			/* BlackLevelDeltaV */</a>
<a name="ln3198">			{</a>
<a name="ln3199">				double black = 0.0;</a>
<a name="ln3200">				for (uint32 i = 0; i &lt; tag.length; i++) {</a>
<a name="ln3201">					black += fRead.NextDouble(tag.type);</a>
<a name="ln3202">				}</a>
<a name="ln3203">				fMeta.black += int32(black / tag.length + 0.5);</a>
<a name="ln3204">				break;</a>
<a name="ln3205">			}</a>
<a name="ln3206"> </a>
<a name="ln3207">			case 50717:	// White Level</a>
<a name="ln3208">				fMeta.maximum = fRead.Next(tag.type);</a>
<a name="ln3209">				break;</a>
<a name="ln3210"> </a>
<a name="ln3211">			case 50718:	// Default Scale</a>
<a name="ln3212">				fMeta.pixel_aspect = fRead.NextDouble(TIFF_FRACTION_TYPE);</a>
<a name="ln3213">				fMeta.pixel_aspect /= fRead.NextDouble(TIFF_FRACTION_TYPE);</a>
<a name="ln3214">				break;</a>
<a name="ln3215"> </a>
<a name="ln3216">			case 50721:	// Color Matrix</a>
<a name="ln3217">			case 50722:</a>
<a name="ln3218">				for (uint32 c = 0; c &lt; fColors; c++) {</a>
<a name="ln3219">					for (uint32 j = 0; j &lt; 3; j++) {</a>
<a name="ln3220">						colorMatrix[c][j] = fRead.NextDouble(TIFF_FRACTION_TYPE);</a>
<a name="ln3221">					}</a>
<a name="ln3222">				}</a>
<a name="ln3223">				useColorMatrix = true;</a>
<a name="ln3224">				break;</a>
<a name="ln3225"> </a>
<a name="ln3226">			case 50723:	// Camera Calibration</a>
<a name="ln3227">			case 50724:</a>
<a name="ln3228">				for (uint32 i = 0; i &lt; fColors; i++) {</a>
<a name="ln3229">					for (uint32 c = 0; c &lt; fColors; c++) {</a>
<a name="ln3230">						cameraCalibration[i][c] = fRead.NextDouble(</a>
<a name="ln3231">							TIFF_FRACTION_TYPE);</a>
<a name="ln3232">					}</a>
<a name="ln3233">				}</a>
<a name="ln3234">				//break;</a>
<a name="ln3235">			case 50727:	// Analog Balance</a>
<a name="ln3236">				for (uint32 c = 0; c &lt; fColors; c++) {</a>
<a name="ln3237">					analogBalance[c] = fRead.NextDouble(TIFF_FRACTION_TYPE);</a>
<a name="ln3238">					//printf(&quot;ab: %g\n&quot;, analogBalance[c]);</a>
<a name="ln3239">				}</a>
<a name="ln3240">				break;</a>
<a name="ln3241">#if 0</a>
<a name="ln3242">      case 50728:			/* AsShotNeutral */</a>
<a name="ln3243">	FORCC asn[c] = getreal(type);</a>
<a name="ln3244">	break;</a>
<a name="ln3245">      case 50729:			/* AsShotWhiteXY */</a>
<a name="ln3246">	xyz[0] = getrat();</a>
<a name="ln3247">	xyz[1] = getrat();</a>
<a name="ln3248">	xyz[2] = 1 - xyz[0] - xyz[1];</a>
<a name="ln3249">	FORC3 xyz[c] /= kD65White[c];</a>
<a name="ln3250">	break;</a>
<a name="ln3251">      case 50740:			/* DNGPrivateData */</a>
<a name="ln3252">	if (dng_version) break;</a>
<a name="ln3253">	i = order;</a>
<a name="ln3254">	parse_minolta (j = get4()+base);</a>
<a name="ln3255">	order = i;</a>
<a name="ln3256">	fseek (ifp, j, SEEK_SET);</a>
<a name="ln3257">	parse_tiff_ifd (base);</a>
<a name="ln3258">	break;</a>
<a name="ln3259">#endif</a>
<a name="ln3260">			case 50752:</a>
<a name="ln3261">				fRead.NextShorts(fCR2Slice, 3);</a>
<a name="ln3262">				break;</a>
<a name="ln3263"> </a>
<a name="ln3264">			case 50829:	// Active Area</a>
<a name="ln3265">				fTopMargin = fRead.Next(tag.type);</a>
<a name="ln3266">				fLeftMargin = fRead.Next(tag.type);</a>
<a name="ln3267">				fInputHeight = fRead.Next(tag.type) - fTopMargin;</a>
<a name="ln3268">				fInputWidth = fRead.Next(tag.type) - fLeftMargin;</a>
<a name="ln3269">				break;</a>
<a name="ln3270">#if 0</a>
<a name="ln3271">      case 64772:			/* Kodak P-series */</a>
<a name="ln3272">	fseek (ifp, 16, SEEK_CUR);</a>
<a name="ln3273">	data_offset = get4();</a>
<a name="ln3274">	fseek (ifp, 28, SEEK_CUR);</a>
<a name="ln3275">	data_offset += get4();</a>
<a name="ln3276">	load_raw = &amp;CLASS packed_12_load_raw;</a>
<a name="ln3277">#endif</a>
<a name="ln3278">		}</a>
<a name="ln3279">		fRead.Seek(nextOffset, SEEK_SET);</a>
<a name="ln3280">	}</a>
<a name="ln3281"> </a>
<a name="ln3282">	// handle SONY tags</a>
<a name="ln3283"> </a>
<a name="ln3284">#if 0</a>
<a name="ln3285">	if (sony_length &amp;&amp; (buf = (unsigned *) malloc(sony_length))) {</a>
<a name="ln3286">		fseek(ifp, sony_offset, SEEK_SET);</a>
<a name="ln3287">		fread(buf, sony_length, 1, ifp);</a>
<a name="ln3288">		sony_decrypt(buf, sony_length / 4, 1, sony_key);</a>
<a name="ln3289">		sfp = ifp;</a>
<a name="ln3290">		if ((ifp = tmpfile())) {</a>
<a name="ln3291">			fwrite(buf, sony_length, 1, ifp);</a>
<a name="ln3292">			fseek(ifp, 0, SEEK_SET);</a>
<a name="ln3293">			parse_tiff_ifd(-sony_offset);</a>
<a name="ln3294">			fclose(ifp);</a>
<a name="ln3295">		}</a>
<a name="ln3296">		ifp = sfp;</a>
<a name="ln3297">		free(buf);</a>
<a name="ln3298">	}</a>
<a name="ln3299">#endif</a>
<a name="ln3300"> </a>
<a name="ln3301">	for (uint32 i = 0; i &lt; fColors; i++) {</a>
<a name="ln3302">		for (uint32 c = 0; c &lt; fColors; c++) {</a>
<a name="ln3303">			cameraCalibration[i][c] *= analogBalance[i];</a>
<a name="ln3304">		}</a>
<a name="ln3305">	}</a>
<a name="ln3306"> </a>
<a name="ln3307">	if (useColorMatrix) {</a>
<a name="ln3308">		for (uint32 c = 0; c &lt; fColors; c++) {</a>
<a name="ln3309">			for (uint32 i = 0; i &lt; 3; i++) {</a>
<a name="ln3310">				cameraXYZ[c][i] = 0;</a>
<a name="ln3311">				for (uint32 j = 0; j &lt; fColors; j++) {</a>
<a name="ln3312">					cameraXYZ[c][i] += cameraCalibration[c][j]</a>
<a name="ln3313">						* colorMatrix[j][i] * xyz[i];</a>
<a name="ln3314">				}</a>
<a name="ln3315">			}</a>
<a name="ln3316">		}</a>
<a name="ln3317">		_CameraXYZCoefficients(cameraXYZ);</a>
<a name="ln3318">	}</a>
<a name="ln3319"> </a>
<a name="ln3320">#if 0</a>
<a name="ln3321">	if (asn[0])</a>
<a name="ln3322">    	FORCC pre_multipliers[c] = 1 / asn[c];</a>
<a name="ln3323">#endif</a>
<a name="ln3324">	if (!useColorMatrix) {</a>
<a name="ln3325">		for (uint32 c = 0; c &lt; fColors; c++) {</a>
<a name="ln3326">			fMeta.pre_multipliers[c] /= cameraCalibration[c][c];</a>
<a name="ln3327">		}</a>
<a name="ln3328">	}</a>
<a name="ln3329"> </a>
<a name="ln3330">	return B_OK;</a>
<a name="ln3331">}</a>
<a name="ln3332"> </a>
<a name="ln3333"> </a>
<a name="ln3334">status_t</a>
<a name="ln3335">DCRaw::_ParseTIFFImageFileDirectory(off_t baseOffset)</a>
<a name="ln3336">{</a>
<a name="ln3337">	while (fNumImages &lt; kImageBufferCount) {</a>
<a name="ln3338">		int32 offset;</a>
<a name="ln3339">		fRead(offset);</a>
<a name="ln3340">		if (offset == 0)</a>
<a name="ln3341">			break;</a>
<a name="ln3342"> </a>
<a name="ln3343">		status_t status = _ParseTIFFImageFileDirectory(baseOffset, offset);</a>
<a name="ln3344">		if (status &lt; B_OK)</a>
<a name="ln3345">			return status;</a>
<a name="ln3346"> </a>
<a name="ln3347">		fNumImages++;</a>
<a name="ln3348">	}</a>
<a name="ln3349"> </a>
<a name="ln3350">	return B_OK;</a>
<a name="ln3351">}</a>
<a name="ln3352"> </a>
<a name="ln3353"> </a>
<a name="ln3354">status_t</a>
<a name="ln3355">DCRaw::_ParseTIFF(off_t baseOffset)</a>
<a name="ln3356">{</a>
<a name="ln3357">	fRead.Stream().Seek(baseOffset, SEEK_SET);</a>
<a name="ln3358"> </a>
<a name="ln3359">	uint16 endian;</a>
<a name="ln3360">	fRead(endian);</a>
<a name="ln3361">	if (endian != 'MM' &amp;&amp; endian != 'II')</a>
<a name="ln3362">		return B_NO_TRANSLATOR;</a>
<a name="ln3363"> </a>
<a name="ln3364">#if B_HOST_IS_LENDIAN</a>
<a name="ln3365">	fRead.SetSwap(endian == 'MM');</a>
<a name="ln3366">#else</a>
<a name="ln3367">	fRead.SetSwap(endian == 'II');</a>
<a name="ln3368">#endif</a>
<a name="ln3369"> </a>
<a name="ln3370">	fRead(endian);</a>
<a name="ln3371">		// dummy, not used, should be 42 for actual TIFF images,</a>
<a name="ln3372">		// but may vary for RAW images</a>
<a name="ln3373"> </a>
<a name="ln3374">	_ParseTIFFImageFileDirectory(baseOffset);</a>
<a name="ln3375">	fIsTIFF = true;</a>
<a name="ln3376"> </a>
<a name="ln3377">	uint32 maxSamples = 0;</a>
<a name="ln3378"> </a>
<a name="ln3379">	if (fThumbIndex &gt;= 0 &amp;&amp; _Thumb().data_offset) {</a>
<a name="ln3380">		fRead.Seek(_Thumb().data_offset, SEEK_SET);</a>
<a name="ln3381"> </a>
<a name="ln3382">		jhead jh;</a>
<a name="ln3383">		if (_LosslessJPEGInit(&amp;jh, true)) {</a>
<a name="ln3384">			_Thumb().bits_per_sample = jh.bits;</a>
<a name="ln3385">			_Thumb().width = jh.wide;</a>
<a name="ln3386">			_Thumb().height = jh.high;</a>
<a name="ln3387">			_Thumb().bits_per_sample = 16;</a>
<a name="ln3388">		}</a>
<a name="ln3389">	}</a>
<a name="ln3390"> </a>
<a name="ln3391">	// identify RAW image in list of images retrieved</a>
<a name="ln3392"> </a>
<a name="ln3393">	for (uint32 i = 0; i &lt; fNumImages; i++) {</a>
<a name="ln3394">		if (maxSamples &lt; fImages[i].samples)</a>
<a name="ln3395">			maxSamples = fImages[i].samples;</a>
<a name="ln3396"> </a>
<a name="ln3397">		if ((fImages[i].compression != COMPRESSION_OLD_JPEG</a>
<a name="ln3398">				|| fImages[i].samples != 3)</a>
<a name="ln3399">			&amp;&amp; _SupportsCompression(fImages[i])) {</a>
<a name="ln3400">			fImages[i].is_raw = true;</a>
<a name="ln3401"> </a>
<a name="ln3402">			if (fRawIndex &lt; 0 || fImages[i].width * fImages[i].height</a>
<a name="ln3403">					&gt; _Raw().width * _Raw().height) {</a>
<a name="ln3404">				fRawIndex = i;</a>
<a name="ln3405">				//fuji_secondary = _Raw().samples == 2;</a>
<a name="ln3406">			}</a>
<a name="ln3407">		}</a>
<a name="ln3408">	}</a>
<a name="ln3409"> </a>
<a name="ln3410">	if (fRawIndex &lt; 0</a>
<a name="ln3411">		|| (!fDNGVersion &amp;&amp; _Raw().samples == 3 &amp;&amp; _Raw().bits_per_sample == 8))</a>
<a name="ln3412">		throw (status_t)B_NO_TRANSLATOR;</a>
<a name="ln3413"> </a>
<a name="ln3414">	if (fRawIndex &gt;= 0) {</a>
<a name="ln3415">		fMeta.raw_width = _Raw().width;</a>
<a name="ln3416">		fMeta.raw_height = _Raw().height;</a>
<a name="ln3417">	}</a>
<a name="ln3418"> </a>
<a name="ln3419">#if 0</a>
<a name="ln3420">  fuji_width *= (raw_width+1)/2;</a>
<a name="ln3421">  if (tiff_ifd[0].flip) tiff_flip = tiff_ifd[0].flip;</a>
<a name="ln3422">  if (raw &gt;= 0 &amp;&amp; !load_raw)</a>
<a name="ln3423">    switch (tiff_compress) {</a>
<a name="ln3424">      case 0:  case 1:</a>
<a name="ln3425">	load_raw = tiff_bps &gt; 8 ?</a>
<a name="ln3426">	  &amp;CLASS unpacked_load_raw : &amp;CLASS eight_bit_load_raw;</a>
<a name="ln3427">	if (tiff_ifd[raw].bytes * 5 == raw_width * raw_height * 8)</a>
<a name="ln3428">	  load_raw = &amp;CLASS olympus_e300_load_raw;</a>
<a name="ln3429">	if (tiff_bps == 12 &amp;&amp; tiff_ifd[raw].phint == 2)</a>
<a name="ln3430">	  load_raw = &amp;CLASS olympus_cseries_load_raw;</a>
<a name="ln3431">	break;</a>
<a name="ln3432">      case 6:  case 7:  case 99:</a>
<a name="ln3433">	load_raw = &amp;CLASS lossless_jpeg_load_raw;		break;</a>
<a name="ln3434">      case 262:</a>
<a name="ln3435">	load_raw = &amp;CLASS kodak_262_load_raw;			break;</a>
<a name="ln3436">      case 32773:</a>
<a name="ln3437">	load_raw = &amp;CLASS packed_12_load_raw;			break;</a>
<a name="ln3438">      case 65535:</a>
<a name="ln3439">	load_raw = &amp;CLASS pentax_k10_load_raw;			break;</a>
<a name="ln3440">      case 65000:</a>
<a name="ln3441">	switch (tiff_ifd[raw].phint) {</a>
<a name="ln3442">	  case 2: load_raw = &amp;CLASS kodak_rgb_load_raw;   fFilters = 0;  break;</a>
<a name="ln3443">	  case 6: load_raw = &amp;CLASS kodak_ycbcr_load_raw; fFilters = 0;  break;</a>
<a name="ln3444">	  case 32803: load_raw = &amp;CLASS kodak_65000_load_raw;</a>
<a name="ln3445">	}</a>
<a name="ln3446">    }</a>
<a name="ln3447">  if (tiff_samples == 3 &amp;&amp; tiff_bps == 8)</a>
<a name="ln3448">    if (!dng_version) is_raw = 0;</a>
<a name="ln3449">#endif</a>
<a name="ln3450"> </a>
<a name="ln3451">#if 0</a>
<a name="ln3452">  if (thm &gt;= 0) {</a>
<a name="ln3453">    thumb_misc |= tiff_ifd[thm].samples &lt;&lt; 5;</a>
<a name="ln3454">    switch (tiff_ifd[thm].comp) {</a>
<a name="ln3455">      case 0:</a>
<a name="ln3456">	write_thumb = &amp;CLASS layer_thumb;</a>
<a name="ln3457">	break;</a>
<a name="ln3458">      case 1:</a>
<a name="ln3459">	if (tiff_ifd[thm].bps &gt; 8)</a>
<a name="ln3460">	  thumb_load_raw = &amp;CLASS kodak_thumb_load_raw;</a>
<a name="ln3461">	else</a>
<a name="ln3462">	  write_thumb = &amp;CLASS ppm_thumb;</a>
<a name="ln3463">	break;</a>
<a name="ln3464">      case 65000:</a>
<a name="ln3465">	thumb_load_raw = tiff_ifd[thm].phint == 6 ?</a>
<a name="ln3466">		&amp;CLASS kodak_ycbcr_load_raw : &amp;CLASS kodak_rgb_load_raw;</a>
<a name="ln3467">    }</a>
<a name="ln3468">  }</a>
<a name="ln3469">#endif</a>
<a name="ln3470">	return B_OK;</a>
<a name="ln3471">}</a>
<a name="ln3472"> </a>
<a name="ln3473"> </a>
<a name="ln3474">//	#pragma mark -</a>
<a name="ln3475"> </a>
<a name="ln3476"> </a>
<a name="ln3477">status_t</a>
<a name="ln3478">DCRaw::Identify()</a>
<a name="ln3479">{</a>
<a name="ln3480">	fRead.Seek(0, SEEK_SET);</a>
<a name="ln3481"> </a>
<a name="ln3482">	status_t status = B_NO_TRANSLATOR;</a>
<a name="ln3483">	char header[32];</a>
<a name="ln3484">	fRead(header, sizeof(header));</a>
<a name="ln3485"> </a>
<a name="ln3486">	// check for TIFF-like files first</a>
<a name="ln3487"> </a>
<a name="ln3488">	uint16 endian = *(uint16*)&amp;header;</a>
<a name="ln3489">	if (endian == 'II' || endian == 'MM')</a>
<a name="ln3490">		status = _ParseTIFF(0);</a>
<a name="ln3491"> </a>
<a name="ln3492">	if (status &lt; B_OK)</a>
<a name="ln3493">		return status;</a>
<a name="ln3494"> </a>
<a name="ln3495">	// brush up some variables for later use</a>
<a name="ln3496"> </a>
<a name="ln3497">	fInputWidth = _Raw().width;</a>
<a name="ln3498">	fInputHeight = _Raw().height;</a>
<a name="ln3499"> </a>
<a name="ln3500">	_FixupValues();</a>
<a name="ln3501"> </a>
<a name="ln3502">	if ((_Raw().width | _Raw().height) &lt; 0)</a>
<a name="ln3503">		_Raw().width = _Raw().height = 0;</a>
<a name="ln3504">	if (fMeta.maximum == 0)</a>
<a name="ln3505">		fMeta.maximum = (1 &lt;&lt; _Raw().bits_per_sample) - 1;</a>
<a name="ln3506"> </a>
<a name="ln3507">	if (fFilters == ~(uint32)0)</a>
<a name="ln3508">		fFilters = 0x94949494;</a>
<a name="ln3509">	if (fFilters &amp;&amp; fColors == 3) {</a>
<a name="ln3510">		for (int32 i = 0; i &lt; 32; i += 4) {</a>
<a name="ln3511">			if ((fFilters &gt;&gt; i &amp; 15) == 9)</a>
<a name="ln3512">				fFilters |= 2 &lt;&lt; i;</a>
<a name="ln3513">			if ((fFilters &gt;&gt; i &amp; 15) == 6)</a>
<a name="ln3514">				fFilters |= 8 &lt;&lt; i;</a>
<a name="ln3515">		}</a>
<a name="ln3516">	}</a>
<a name="ln3517"> </a>
<a name="ln3518">	if (fRawColor)</a>
<a name="ln3519">		_AdobeCoefficients(fMeta.manufacturer, fMeta.model);</a>
<a name="ln3520"> </a>
<a name="ln3521">	// remove invalid images</a>
<a name="ln3522"> </a>
<a name="ln3523">	int32 rawCount = 0;</a>
<a name="ln3524"> </a>
<a name="ln3525">	for (int32 i = 0; i &lt; (int32)fNumImages; i++) {</a>
<a name="ln3526">		if (fImages[i].width == 0 || fImages[i].height == 0</a>
<a name="ln3527">			|| fImages[i].data_offset == 0) {</a>
<a name="ln3528">			fNumImages--;</a>
<a name="ln3529">			if (i == fRawIndex)</a>
<a name="ln3530">				fRawIndex = -1;</a>
<a name="ln3531">			else if (i &lt; fRawIndex)</a>
<a name="ln3532">				fRawIndex--;</a>
<a name="ln3533">			if (i == fThumbIndex)</a>
<a name="ln3534">				fThumbIndex = -1;</a>
<a name="ln3535">			else if (i &lt; fThumbIndex)</a>
<a name="ln3536">				fThumbIndex--;</a>
<a name="ln3537"> </a>
<a name="ln3538">			if (i &lt; (int32)fNumImages) {</a>
<a name="ln3539">				memmove(&amp;fImages[i], &amp;fImages[i + 1],</a>
<a name="ln3540">					sizeof(image_data_info) * (fNumImages - i));</a>
<a name="ln3541">			}</a>
<a name="ln3542">			i--;</a>
<a name="ln3543">		} else if (fImages[i].is_raw)</a>
<a name="ln3544">			rawCount++;</a>
<a name="ln3545">	}</a>
<a name="ln3546"> </a>
<a name="ln3547">	// This is to prevent us from identifying TIFF images</a>
<a name="ln3548">	if (rawCount == 0)</a>
<a name="ln3549">		return B_NO_TRANSLATOR;</a>
<a name="ln3550"> </a>
<a name="ln3551">	fMeta.flip = _Raw().flip;</a>
<a name="ln3552">	return B_OK;</a>
<a name="ln3553">}</a>
<a name="ln3554"> </a>
<a name="ln3555"> </a>
<a name="ln3556">status_t</a>
<a name="ln3557">DCRaw::ReadImageAt(uint32 index, uint8*&amp; outputBuffer, size_t&amp; bufferSize)</a>
<a name="ln3558">{</a>
<a name="ln3559">	if (index &gt;= fNumImages)</a>
<a name="ln3560">		return B_BAD_VALUE;</a>
<a name="ln3561"> </a>
<a name="ln3562">	_CorrectIndex(index);</a>
<a name="ln3563"> </a>
<a name="ln3564">	image_data_info&amp; image = fImages[index];</a>
<a name="ln3565"> </a>
<a name="ln3566">	fShrink = (fHalfSize || fThreshold) &amp;&amp; fFilters;</a>
<a name="ln3567">	fOutputWidth = (fInputWidth + fShrink) &gt;&gt; fShrink;</a>
<a name="ln3568">	fOutputHeight = (fInputHeight + fShrink) &gt;&gt; fShrink;</a>
<a name="ln3569"> </a>
<a name="ln3570">	if (image.flip &gt; 4) {</a>
<a name="ln3571">		// image is rotated</a>
<a name="ln3572">		image.output_width = fOutputHeight;</a>
<a name="ln3573">		image.output_height = fOutputWidth;</a>
<a name="ln3574">	} else {</a>
<a name="ln3575">		image.output_width = fOutputWidth;</a>
<a name="ln3576">		image.output_height = fOutputHeight;</a>
<a name="ln3577">	}</a>
<a name="ln3578"> </a>
<a name="ln3579">	if (image.is_raw) {</a>
<a name="ln3580">		bufferSize = fOutputWidth * 4 * fOutputHeight;</a>
<a name="ln3581"> </a>
<a name="ln3582">		fImageData = (uint16 (*)[4])calloc(fOutputWidth * fOutputHeight</a>
<a name="ln3583">			* sizeof(*fImageData) + 0, 1); //meta_length, 1);</a>
<a name="ln3584">		if (fImageData == NULL)</a>
<a name="ln3585">			throw (status_t)B_NO_MEMORY;</a>
<a name="ln3586">	} else {</a>
<a name="ln3587">		bufferSize = image.bytes + sizeof(tiff_header) + 10;</a>
<a name="ln3588">			// TIFF header plus EXIF identifier</a>
<a name="ln3589">	}</a>
<a name="ln3590"> </a>
<a name="ln3591">	outputBuffer = (uint8*)malloc(bufferSize);</a>
<a name="ln3592">	if (outputBuffer == NULL) {</a>
<a name="ln3593">		free(fImageData);</a>
<a name="ln3594">		fImageData = NULL;</a>
<a name="ln3595">		throw (status_t)B_NO_MEMORY;</a>
<a name="ln3596">	}</a>
<a name="ln3597"> </a>
<a name="ln3598">	fRead.Seek(image.data_offset, SEEK_SET);</a>
<a name="ln3599"> </a>
<a name="ln3600">	if (image.is_raw) {</a>
<a name="ln3601">		_LoadRAW(image);</a>
<a name="ln3602"> </a>
<a name="ln3603">		//bad_pixels();</a>
<a name="ln3604">		//if (dark_frame) subtract (dark_frame);</a>
<a name="ln3605">		//quality = 2 + !fuji_width;</a>
<a name="ln3606"> </a>
<a name="ln3607">		if (fDocumentMode &lt; 2)</a>
<a name="ln3608">			_ScaleColors();</a>
<a name="ln3609">		_PreInterpolate();</a>
<a name="ln3610">		_CameraToCIELab(NULL, NULL);</a>
<a name="ln3611"> </a>
<a name="ln3612">		if (fFilters &amp;&amp; !fDocumentMode) {</a>
<a name="ln3613">#if 0</a>
<a name="ln3614">			if (quality == 0)</a>
<a name="ln3615">				lin_interpolate();</a>
<a name="ln3616">			else if (quality &lt; 3 || colors &gt; 3)</a>
<a name="ln3617">				vng_interpolate();</a>
<a name="ln3618">#endif</a>
<a name="ln3619">			_AHDInterpolate();</a>
<a name="ln3620">		}</a>
<a name="ln3621"> </a>
<a name="ln3622">#if 0</a>
<a name="ln3623">		if (fHightlight &gt; 1)</a>
<a name="ln3624">			_RecoverHighlights();</a>
<a name="ln3625">		if (use_fuji_rotate) fuji_rotate();</a>
<a name="ln3626">		if (mix_green &amp;&amp; (colors = 3))</a>
<a name="ln3627">			for (i=0; i &lt; height*width; i++)</a>
<a name="ln3628">				image[i][1] = (image[i][1] + image[i][3]) &gt;&gt; 1;</a>
<a name="ln3629">#endif</a>
<a name="ln3630"> </a>
<a name="ln3631">		_ConvertToRGB();</a>
<a name="ln3632">		//if (use_fuji_rotate) stretch();</a>
<a name="ln3633"> </a>
<a name="ln3634">		_WriteRGB32(image, outputBuffer);</a>
<a name="ln3635">	} else {</a>
<a name="ln3636">		_WriteJPEG(image, outputBuffer);</a>
<a name="ln3637">	}</a>
<a name="ln3638"> </a>
<a name="ln3639">	free(fImageData);</a>
<a name="ln3640">	fImageData = NULL;</a>
<a name="ln3641"> </a>
<a name="ln3642">	return B_OK;</a>
<a name="ln3643">}</a>
<a name="ln3644"> </a>
<a name="ln3645"> </a>
<a name="ln3646">void</a>
<a name="ln3647">DCRaw::GetMetaInfo(image_meta_info&amp; metaInfo) const</a>
<a name="ln3648">{</a>
<a name="ln3649">	metaInfo = fMeta;</a>
<a name="ln3650">}</a>
<a name="ln3651"> </a>
<a name="ln3652"> </a>
<a name="ln3653">uint32</a>
<a name="ln3654">DCRaw::CountImages() const</a>
<a name="ln3655">{</a>
<a name="ln3656">	return fNumImages;</a>
<a name="ln3657">}</a>
<a name="ln3658"> </a>
<a name="ln3659"> </a>
<a name="ln3660">status_t</a>
<a name="ln3661">DCRaw::ImageAt(uint32 index, image_data_info&amp; info) const</a>
<a name="ln3662">{</a>
<a name="ln3663">	if (index &gt;= fNumImages)</a>
<a name="ln3664">		return B_BAD_VALUE;</a>
<a name="ln3665"> </a>
<a name="ln3666">	_CorrectIndex(index);</a>
<a name="ln3667"> </a>
<a name="ln3668">	info = fImages[index];</a>
<a name="ln3669">	return B_OK;</a>
<a name="ln3670">}</a>
<a name="ln3671"> </a>
<a name="ln3672"> </a>
<a name="ln3673">status_t</a>
<a name="ln3674">DCRaw::GetEXIFTag(off_t&amp; offset, size_t&amp; length, bool&amp; bigEndian) const</a>
<a name="ln3675">{</a>
<a name="ln3676">	if (fEXIFOffset &lt; 0)</a>
<a name="ln3677">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln3678"> </a>
<a name="ln3679">	offset = fEXIFOffset;</a>
<a name="ln3680">	length = fEXIFLength;</a>
<a name="ln3681"> </a>
<a name="ln3682">#if B_HOST_IS_LENDIAN</a>
<a name="ln3683">	bigEndian = fRead.IsSwapping();</a>
<a name="ln3684">#else</a>
<a name="ln3685">	bigEndian = !fRead.IsSwapping();</a>
<a name="ln3686">#endif</a>
<a name="ln3687">	return B_OK;</a>
<a name="ln3688">}</a>
<a name="ln3689"> </a>
<a name="ln3690"> </a>
<a name="ln3691">void</a>
<a name="ln3692">DCRaw::SetProgressMonitor(monitor_hook hook, void* data)</a>
<a name="ln3693">{</a>
<a name="ln3694">	fProgressMonitor = hook;</a>
<a name="ln3695">	fProgressData = data;</a>
<a name="ln3696">}</a>
<a name="ln3697"> </a>
<a name="ln3698"> </a>
<a name="ln3699">void</a>
<a name="ln3700">DCRaw::SetHalfSize(bool half)</a>
<a name="ln3701">{</a>
<a name="ln3702">	fHalfSize = half;</a>
<a name="ln3703">}</a>

</code></pre>
<div class="balloon" rel="1796"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The '256 - 1' index is pointing beyond array bound.</p></div>
<div class="balloon" rel="1796"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The '256 + 1' index is pointing beyond array bound.</p></div>
<div class="balloon" rel="1785"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The '1' index is pointing beyond array bound.</p></div>
<div class="balloon" rel="1667"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v548/" target="_blank">V548</a> Consider reviewing type casting. TYPE X[][] is not equivalent to TYPE **X.</p></div>
<div class="balloon" rel="2600"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v593/" target="_blank">V593</a> Consider reviewing the expression of the 'A = B >= C' kind. The expression is calculated as following: 'A = (B >= C)'.</p></div>
<div class="balloon" rel="3502"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '(_Raw().width | _Raw().height) < 0' is always false. Unsigned type value is never < 0.</p></div>
<div class="balloon" rel="1098"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v634/" target="_blank">V634</a> The priority of the '*' operation is higher than that of the '<<' operation. It's possible that parentheses should be used in the expression.</p></div>
<div class="balloon" rel="1789"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array overrun is possible. The '256' index is pointing beyond array bound.</p></div>
<div class="balloon" rel="1140"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v634/" target="_blank">V634</a> The priority of the '*' operation is higher than that of the '<<' operation. It's possible that parentheses should be used in the expression.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
