
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>MidiStore.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2005-2006, Haiku.</a>
<a name="ln3"> * </a>
<a name="ln4"> * Copyright (c) 2002-2004 Matthijs Hollemans</a>
<a name="ln5"> * Copyright (c) 2002 Jerome Leveque</a>
<a name="ln6"> * Copyright (c) 2002 Paul Stadler</a>
<a name="ln7"> * Distributed under the terms of the MIT License.</a>
<a name="ln8"> *</a>
<a name="ln9"> * Authors:</a>
<a name="ln10"> *		Matthijs Hollemans</a>
<a name="ln11"> *		Jérôme Leveque</a>
<a name="ln12"> *		Paul Stadler</a>
<a name="ln13"> */</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;File.h&gt;</a>
<a name="ln16">#include &lt;List.h&gt;</a>
<a name="ln17">#include &lt;MidiDefs.h&gt;</a>
<a name="ln18">#include &lt;MidiStore.h&gt;</a>
<a name="ln19">#include &lt;stdlib.h&gt;</a>
<a name="ln20">#include &lt;string.h&gt;</a>
<a name="ln21"> </a>
<a name="ln22">#include &quot;debug.h&quot;</a>
<a name="ln23"> </a>
<a name="ln24"> </a>
<a name="ln25">struct BMidiEvent {</a>
<a name="ln26">	BMidiEvent()</a>
<a name="ln27">	{</a>
<a name="ln28">		byte1  = 0;</a>
<a name="ln29">		byte2  = 0;</a>
<a name="ln30">		byte3  = 0;</a>
<a name="ln31">		data   = NULL;</a>
<a name="ln32">		length = 0;</a>
<a name="ln33">	}</a>
<a name="ln34"> </a>
<a name="ln35">	~BMidiEvent()</a>
<a name="ln36">	{</a>
<a name="ln37">		free(data);</a>
<a name="ln38">	}</a>
<a name="ln39"> </a>
<a name="ln40">	uint32 time;    // either ticks or milliseconds</a>
<a name="ln41">	bool   ticks;   // event is from MIDI file</a>
<a name="ln42">	uchar  byte1;</a>
<a name="ln43">	uchar  byte2;</a>
<a name="ln44">	uchar  byte3;</a>
<a name="ln45">	void*  data;    // sysex data</a>
<a name="ln46">	size_t length;  // sysex data size</a>
<a name="ln47">	int32  tempo;   // beats per minute</a>
<a name="ln48">};</a>
<a name="ln49"> </a>
<a name="ln50"> </a>
<a name="ln51">static int</a>
<a name="ln52">compare_events(const void* event1, const void* event2)</a>
<a name="ln53">{</a>
<a name="ln54">	BMidiEvent* e1 = *((BMidiEvent**) event1);</a>
<a name="ln55">	BMidiEvent* e2 = *((BMidiEvent**) event2);</a>
<a name="ln56"> </a>
<a name="ln57">	return (e1-&gt;time - e2-&gt;time);</a>
<a name="ln58">}</a>
<a name="ln59"> </a>
<a name="ln60"> </a>
<a name="ln61">//	#pragma mark -</a>
<a name="ln62"> </a>
<a name="ln63"> </a>
<a name="ln64">BMidiStore::BMidiStore()</a>
<a name="ln65">{</a>
<a name="ln66">	fEvents = new BList;</a>
<a name="ln67">	fCurrentEvent = 0;</a>
<a name="ln68">	fStartTime = 0;</a>
<a name="ln69">	fNeedsSorting = false;</a>
<a name="ln70">	fBeatsPerMinute = 60;</a>
<a name="ln71">	fTicksPerBeat = 240;</a>
<a name="ln72">	fFile = NULL;</a>
<a name="ln73">	fHookFunc = NULL;</a>
<a name="ln74">	fLooping = false;</a>
<a name="ln75">	fPaused = false;</a>
<a name="ln76">	fFinished = false;</a>
<a name="ln77">	fInstruments = new bool[128];</a>
<a name="ln78">}</a>
<a name="ln79"> </a>
<a name="ln80"> </a>
<a name="ln81">BMidiStore::~BMidiStore()</a>
<a name="ln82">{</a>
<a name="ln83">	for (int32 t = 0; t &lt; fEvents-&gt;CountItems(); ++t) {</a>
<a name="ln84">		delete EventAt(t);</a>
<a name="ln85">	}</a>
<a name="ln86"> </a>
<a name="ln87">	delete fEvents;</a>
<a name="ln88">	delete[] fInstruments;</a>
<a name="ln89">}</a>
<a name="ln90"> </a>
<a name="ln91"> </a>
<a name="ln92">void</a>
<a name="ln93">BMidiStore::NoteOff(uchar channel, uchar note, uchar velocity,</a>
<a name="ln94">	uint32 time)</a>
<a name="ln95">{</a>
<a name="ln96">	BMidiEvent* event = new BMidiEvent;</a>
<a name="ln97">	event-&gt;time  = time;</a>
<a name="ln98">	event-&gt;ticks = false;</a>
<a name="ln99">	event-&gt;byte1 = B_NOTE_OFF | (channel - 1);</a>
<a name="ln100">	event-&gt;byte2 = note;</a>
<a name="ln101">	event-&gt;byte3 = velocity;</a>
<a name="ln102">	AddEvent(event);</a>
<a name="ln103">}</a>
<a name="ln104"> </a>
<a name="ln105"> </a>
<a name="ln106">void</a>
<a name="ln107">BMidiStore::NoteOn(uchar channel, uchar note,</a>
<a name="ln108">	uchar velocity, uint32 time)</a>
<a name="ln109">{</a>
<a name="ln110">	BMidiEvent* event = new BMidiEvent;</a>
<a name="ln111">	event-&gt;time  = time;</a>
<a name="ln112">	event-&gt;ticks = false;</a>
<a name="ln113">	event-&gt;byte1 = B_NOTE_ON | (channel - 1);</a>
<a name="ln114">	event-&gt;byte2 = note;</a>
<a name="ln115">	event-&gt;byte3 = velocity;</a>
<a name="ln116">	AddEvent(event);</a>
<a name="ln117">}</a>
<a name="ln118"> </a>
<a name="ln119"> </a>
<a name="ln120">void</a>
<a name="ln121">BMidiStore::KeyPressure(uchar channel, uchar note,</a>
<a name="ln122">	uchar pressure, uint32 time)</a>
<a name="ln123">{</a>
<a name="ln124">	BMidiEvent* event = new BMidiEvent;</a>
<a name="ln125">	event-&gt;time  = time;</a>
<a name="ln126">	event-&gt;ticks = false;</a>
<a name="ln127">	event-&gt;byte1 = B_KEY_PRESSURE | (channel - 1);</a>
<a name="ln128">	event-&gt;byte2 = note;</a>
<a name="ln129">	event-&gt;byte3 = pressure;</a>
<a name="ln130">	AddEvent(event);</a>
<a name="ln131">}</a>
<a name="ln132"> </a>
<a name="ln133"> </a>
<a name="ln134">void</a>
<a name="ln135">BMidiStore::ControlChange(uchar channel, uchar controlNumber,</a>
<a name="ln136">	uchar controlValue, uint32 time)</a>
<a name="ln137">{</a>
<a name="ln138">	BMidiEvent* event = new BMidiEvent;</a>
<a name="ln139">	event-&gt;time  = time;</a>
<a name="ln140">	event-&gt;ticks = false;</a>
<a name="ln141">	event-&gt;byte1 = B_CONTROL_CHANGE | (channel - 1);</a>
<a name="ln142">	event-&gt;byte2 = controlNumber;</a>
<a name="ln143">	event-&gt;byte3 = controlValue;</a>
<a name="ln144">	AddEvent(event);</a>
<a name="ln145">}</a>
<a name="ln146"> </a>
<a name="ln147"> </a>
<a name="ln148">void</a>
<a name="ln149">BMidiStore::ProgramChange(uchar channel, uchar programNumber,</a>
<a name="ln150">	uint32 time)</a>
<a name="ln151">{</a>
<a name="ln152">	BMidiEvent* event = new BMidiEvent;</a>
<a name="ln153">	event-&gt;time  = time;</a>
<a name="ln154">	event-&gt;ticks = false;</a>
<a name="ln155">	event-&gt;byte1 = B_PROGRAM_CHANGE | (channel - 1);</a>
<a name="ln156">	event-&gt;byte2 = programNumber;</a>
<a name="ln157">	AddEvent(event);</a>
<a name="ln158">}</a>
<a name="ln159"> </a>
<a name="ln160"> </a>
<a name="ln161">void</a>
<a name="ln162">BMidiStore::ChannelPressure(uchar channel, uchar pressure, uint32 time)</a>
<a name="ln163">{</a>
<a name="ln164">	BMidiEvent* event = new BMidiEvent;</a>
<a name="ln165">	event-&gt;time  = time;</a>
<a name="ln166">	event-&gt;ticks = false;</a>
<a name="ln167">	event-&gt;byte1 = B_CHANNEL_PRESSURE | (channel - 1);</a>
<a name="ln168">	event-&gt;byte2 = pressure;</a>
<a name="ln169">	AddEvent(event);</a>
<a name="ln170">}</a>
<a name="ln171"> </a>
<a name="ln172"> </a>
<a name="ln173">void</a>
<a name="ln174">BMidiStore::PitchBend(uchar channel, uchar lsb, uchar msb, uint32 time)</a>
<a name="ln175">{</a>
<a name="ln176">	BMidiEvent* event = new BMidiEvent;</a>
<a name="ln177">	event-&gt;time  = time;</a>
<a name="ln178">	event-&gt;ticks = false;</a>
<a name="ln179">	event-&gt;byte1 = B_PITCH_BEND | (channel - 1);</a>
<a name="ln180">	event-&gt;byte2 = lsb;</a>
<a name="ln181">	event-&gt;byte3 = msb;</a>
<a name="ln182">	AddEvent(event);</a>
<a name="ln183">}</a>
<a name="ln184"> </a>
<a name="ln185"> </a>
<a name="ln186">void</a>
<a name="ln187">BMidiStore::SystemExclusive(void* data, size_t length, uint32 time)</a>
<a name="ln188">{</a>
<a name="ln189">	BMidiEvent* event = new BMidiEvent;</a>
<a name="ln190">	event-&gt;time   = time;</a>
<a name="ln191">	event-&gt;ticks  = false;</a>
<a name="ln192">	event-&gt;byte1  = B_SYS_EX_START;</a>
<a name="ln193">	event-&gt;data   = malloc(length);</a>
<a name="ln194">	event-&gt;length = length;</a>
<a name="ln195">	memcpy(event-&gt;data, data, length);</a>
<a name="ln196">	AddEvent(event);</a>
<a name="ln197">}</a>
<a name="ln198"> </a>
<a name="ln199"> </a>
<a name="ln200">void</a>
<a name="ln201">BMidiStore::SystemCommon(uchar status, uchar data1,</a>
<a name="ln202">	uchar data2, uint32 time)</a>
<a name="ln203">{</a>
<a name="ln204">	BMidiEvent* event = new BMidiEvent;</a>
<a name="ln205">	event-&gt;time  = time;</a>
<a name="ln206">	event-&gt;ticks = false;</a>
<a name="ln207">	event-&gt;byte1 = status;</a>
<a name="ln208">	event-&gt;byte2 = data1;</a>
<a name="ln209">	event-&gt;byte3 = data2;</a>
<a name="ln210">	AddEvent(event);</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213"> </a>
<a name="ln214">void</a>
<a name="ln215">BMidiStore::SystemRealTime(uchar status, uint32 time)</a>
<a name="ln216">{</a>
<a name="ln217">	BMidiEvent* event = new BMidiEvent;</a>
<a name="ln218">	event-&gt;time  = time;</a>
<a name="ln219">	event-&gt;ticks = false;</a>
<a name="ln220">	event-&gt;byte1 = status;</a>
<a name="ln221">	AddEvent(event);</a>
<a name="ln222">}</a>
<a name="ln223"> </a>
<a name="ln224"> </a>
<a name="ln225">void</a>
<a name="ln226">BMidiStore::TempoChange(int32 beatsPerMinute, uint32 time)</a>
<a name="ln227">{</a>
<a name="ln228">	BMidiEvent* event = new BMidiEvent;</a>
<a name="ln229">	event-&gt;time  = time;</a>
<a name="ln230">	event-&gt;ticks = false;</a>
<a name="ln231">	event-&gt;byte1 = 0xFF;</a>
<a name="ln232">	event-&gt;byte2 = 0x51;</a>
<a name="ln233">	event-&gt;byte3 = 0x03;</a>
<a name="ln234">	event-&gt;tempo = beatsPerMinute;</a>
<a name="ln235">	AddEvent(event);</a>
<a name="ln236">}</a>
<a name="ln237"> </a>
<a name="ln238"> </a>
<a name="ln239">status_t</a>
<a name="ln240">BMidiStore::Import(const entry_ref* ref)</a>
<a name="ln241">{</a>
<a name="ln242">	memset(fInstruments, 0, 128 * sizeof(bool));</a>
<a name="ln243"> </a>
<a name="ln244">	try {</a>
<a name="ln245">		fFile = new BFile(ref, B_READ_ONLY);</a>
<a name="ln246">		if (fFile-&gt;InitCheck() != B_OK)</a>
<a name="ln247">			throw fFile-&gt;InitCheck();</a>
<a name="ln248"> </a>
<a name="ln249">		char fourcc[4];</a>
<a name="ln250">		ReadFourCC(fourcc);</a>
<a name="ln251">		if (strncmp(fourcc, &quot;MThd&quot;, 4) != 0)</a>
<a name="ln252">			throw (status_t) B_BAD_MIDI_DATA;</a>
<a name="ln253"> </a>
<a name="ln254">		if (Read32Bit() != 6)</a>
<a name="ln255">			throw (status_t) B_BAD_MIDI_DATA;</a>
<a name="ln256"> </a>
<a name="ln257">		fFormat = Read16Bit();</a>
<a name="ln258">		fNumTracks = Read16Bit();</a>
<a name="ln259">		fTicksPerBeat = Read16Bit();</a>
<a name="ln260"> </a>
<a name="ln261">		if (fTicksPerBeat &amp; 0x8000) {</a>
<a name="ln262">			// we don't support SMPTE time codes, </a>
<a name="ln263">			// only ticks per quarter note</a>
<a name="ln264">			fTicksPerBeat = 240;</a>
<a name="ln265">		}</a>
<a name="ln266"> </a>
<a name="ln267">		fCurrTrack = 0;</a>
<a name="ln268">		while (fCurrTrack &lt; fNumTracks) {</a>
<a name="ln269">			ReadChunk(); </a>
<a name="ln270">		}</a>
<a name="ln271">	} catch (status_t e) {</a>
<a name="ln272">		delete fFile;</a>
<a name="ln273">		fFile = NULL;</a>
<a name="ln274">		return e;</a>
<a name="ln275">	}</a>
<a name="ln276"> </a>
<a name="ln277">	SortEvents(true);</a>
<a name="ln278"> </a>
<a name="ln279">	delete fFile;</a>
<a name="ln280">	fFile = NULL;</a>
<a name="ln281">	return B_OK;</a>
<a name="ln282">}</a>
<a name="ln283"> </a>
<a name="ln284"> </a>
<a name="ln285">status_t</a>
<a name="ln286">BMidiStore::Export(const entry_ref* ref, int32 format)</a>
<a name="ln287">{</a>
<a name="ln288">	try {</a>
<a name="ln289">		fFile = new BFile(ref, B_READ_WRITE);</a>
<a name="ln290">		if (fFile-&gt;InitCheck() != B_OK)</a>
<a name="ln291">			throw fFile-&gt;InitCheck();</a>
<a name="ln292"> </a>
<a name="ln293">		SortEvents(true);</a>
<a name="ln294"> </a>
<a name="ln295">		WriteFourCC('M', 'T', 'h', 'd');</a>
<a name="ln296">		Write32Bit(6);</a>
<a name="ln297">		Write16Bit(0);  // we do only format 0</a>
<a name="ln298">		Write16Bit(1);</a>
<a name="ln299">		Write16Bit(fTicksPerBeat);</a>
<a name="ln300"> </a>
<a name="ln301">		WriteTrack();</a>
<a name="ln302">	} catch (status_t e) {</a>
<a name="ln303">		delete fFile;</a>
<a name="ln304">		fFile = NULL;</a>
<a name="ln305">		return e;</a>
<a name="ln306">	}</a>
<a name="ln307"> </a>
<a name="ln308">	delete fFile;</a>
<a name="ln309">	fFile = NULL;	</a>
<a name="ln310">	return B_OK;</a>
<a name="ln311">}</a>
<a name="ln312"> </a>
<a name="ln313"> </a>
<a name="ln314">void</a>
<a name="ln315">BMidiStore::SortEvents(bool force)</a>
<a name="ln316">{</a>
<a name="ln317">	if (force || fNeedsSorting) {</a>
<a name="ln318">		fEvents-&gt;SortItems(compare_events);</a>
<a name="ln319">		fNeedsSorting = false;</a>
<a name="ln320">	}</a>
<a name="ln321">}</a>
<a name="ln322"> </a>
<a name="ln323"> </a>
<a name="ln324">uint32</a>
<a name="ln325">BMidiStore::CountEvents() const</a>
<a name="ln326">{</a>
<a name="ln327">	return fEvents-&gt;CountItems();</a>
<a name="ln328">}</a>
<a name="ln329"> </a>
<a name="ln330"> </a>
<a name="ln331">uint32</a>
<a name="ln332">BMidiStore::CurrentEvent() const</a>
<a name="ln333">{</a>
<a name="ln334">	return fCurrentEvent;</a>
<a name="ln335">}</a>
<a name="ln336"> </a>
<a name="ln337"> </a>
<a name="ln338">void</a>
<a name="ln339">BMidiStore::SetCurrentEvent(uint32 eventNumber)</a>
<a name="ln340">{</a>
<a name="ln341">	fCurrentEvent = eventNumber;</a>
<a name="ln342">}</a>
<a name="ln343"> </a>
<a name="ln344"> </a>
<a name="ln345">uint32</a>
<a name="ln346">BMidiStore::DeltaOfEvent(uint32 eventNumber) const</a>
<a name="ln347">{</a>
<a name="ln348">	// Even though the BeBook says that the delta is the time span between</a>
<a name="ln349">	// an event and the first event in the list, this doesn't appear to be</a>
<a name="ln350">	// true for events that were captured from other BMidi objects such as</a>
<a name="ln351">	// BMidiPort. For those events, we return the absolute timestamp. The</a>
<a name="ln352">	// BeBook is correct for events from MIDI files, though.</a>
<a name="ln353"> </a>
<a name="ln354">	BMidiEvent* event = EventAt(eventNumber);</a>
<a name="ln355">	if (event != NULL)</a>
<a name="ln356">		return GetEventTime(event);</a>
<a name="ln357"> </a>
<a name="ln358">	return 0;</a>
<a name="ln359">}</a>
<a name="ln360"> </a>
<a name="ln361"> </a>
<a name="ln362">uint32</a>
<a name="ln363">BMidiStore::EventAtDelta(uint32 time) const</a>
<a name="ln364">{</a>
<a name="ln365">	for (int32 t = 0; t &lt; fEvents-&gt;CountItems(); ++t) {</a>
<a name="ln366">		if (GetEventTime(EventAt(t)) &gt;= time)</a>
<a name="ln367">			return t;</a>
<a name="ln368">	}</a>
<a name="ln369"> </a>
<a name="ln370">	return 0;</a>
<a name="ln371">}</a>
<a name="ln372"> </a>
<a name="ln373"> </a>
<a name="ln374">uint32</a>
<a name="ln375">BMidiStore::BeginTime() const</a>
<a name="ln376">{</a>
<a name="ln377">	return fStartTime;</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380"> </a>
<a name="ln381">void</a>
<a name="ln382">BMidiStore::SetTempo(int32 beatsPerMinute_)</a>
<a name="ln383">{</a>
<a name="ln384">	fBeatsPerMinute = beatsPerMinute_;</a>
<a name="ln385">}</a>
<a name="ln386"> </a>
<a name="ln387"> </a>
<a name="ln388">int32</a>
<a name="ln389">BMidiStore::Tempo() const</a>
<a name="ln390">{</a>
<a name="ln391">	return fBeatsPerMinute;</a>
<a name="ln392">}</a>
<a name="ln393"> </a>
<a name="ln394"> </a>
<a name="ln395">void BMidiStore::_ReservedMidiStore1() { }</a>
<a name="ln396">void BMidiStore::_ReservedMidiStore2() { }</a>
<a name="ln397">void BMidiStore::_ReservedMidiStore3() { }</a>
<a name="ln398"> </a>
<a name="ln399"> </a>
<a name="ln400">void</a>
<a name="ln401">BMidiStore::Run()</a>
<a name="ln402">{</a>
<a name="ln403">	// This rather compilicated Run() loop is not only used by BMidiStore</a>
<a name="ln404">	// but also by BMidiSynthFile. The &quot;paused&quot;, &quot;finished&quot;, and &quot;looping&quot;</a>
<a name="ln405">	// flags, and the &quot;stop hook&quot; are especially provided for the latter.</a>
<a name="ln406"> </a>
<a name="ln407">	fPaused = false;</a>
<a name="ln408">	fFinished = false;</a>
<a name="ln409"> </a>
<a name="ln410">	int32 timeAdjust = 0;</a>
<a name="ln411">	uint32 baseTime = 0;</a>
<a name="ln412">	bool firstEvent = true;</a>
<a name="ln413">	bool resetTime = false;</a>
<a name="ln414"> </a>
<a name="ln415">	while (KeepRunning()) {</a>
<a name="ln416">		if (fPaused) {</a>
<a name="ln417">			resetTime = true;</a>
<a name="ln418">			snooze(100000);</a>
<a name="ln419">			continue;</a>
<a name="ln420">		}</a>
<a name="ln421"> </a>
<a name="ln422">		BMidiEvent* event = EventAt(fCurrentEvent);</a>
<a name="ln423"> </a>
<a name="ln424">		if (event == NULL) {</a>
<a name="ln425">			// no more events</a>
<a name="ln426">			if (fLooping) {</a>
<a name="ln427">				resetTime = true;</a>
<a name="ln428">				fCurrentEvent = 0;</a>
<a name="ln429">				continue;</a>
<a name="ln430">			}</a>
<a name="ln431">			break;</a>
<a name="ln432">		}</a>
<a name="ln433"> </a>
<a name="ln434">		if (firstEvent) {</a>
<a name="ln435">			fStartTime = B_NOW;</a>
<a name="ln436">			baseTime = fStartTime;</a>
<a name="ln437">		} else if (resetTime)</a>
<a name="ln438">			baseTime = B_NOW;</a>
<a name="ln439"> </a>
<a name="ln440">		if (firstEvent || resetTime) {</a>
<a name="ln441">			timeAdjust = baseTime - GetEventTime(event);</a>
<a name="ln442">			SprayEvent(event, baseTime);</a>
<a name="ln443">			firstEvent = false;</a>
<a name="ln444">			resetTime = false;</a>
<a name="ln445">		} else</a>
<a name="ln446">			SprayEvent(event, GetEventTime(event) + timeAdjust);</a>
<a name="ln447"> </a>
<a name="ln448">		++fCurrentEvent;</a>
<a name="ln449">	}</a>
<a name="ln450"> </a>
<a name="ln451">	fFinished = true;</a>
<a name="ln452">	fPaused = false;</a>
<a name="ln453"> </a>
<a name="ln454">	if (fHookFunc != NULL)</a>
<a name="ln455">		(*fHookFunc)(fHookArg);</a>
<a name="ln456">}</a>
<a name="ln457"> </a>
<a name="ln458"> </a>
<a name="ln459">void</a>
<a name="ln460">BMidiStore::AddEvent(BMidiEvent* event)</a>
<a name="ln461">{</a>
<a name="ln462">	fEvents-&gt;AddItem(event);</a>
<a name="ln463">	fNeedsSorting = true;</a>
<a name="ln464">}</a>
<a name="ln465"> </a>
<a name="ln466"> </a>
<a name="ln467">void</a>
<a name="ln468">BMidiStore::SprayEvent(const BMidiEvent* event, uint32 time)</a>
<a name="ln469">{</a>
<a name="ln470">	uchar byte1 = event-&gt;byte1;</a>
<a name="ln471">	uchar byte2 = event-&gt;byte2;</a>
<a name="ln472">	uchar byte3 = event-&gt;byte3;</a>
<a name="ln473"> </a>
<a name="ln474">	switch (byte1 &amp; 0xF0) {</a>
<a name="ln475">		case B_NOTE_OFF:</a>
<a name="ln476">			SprayNoteOff((byte1 &amp; 0x0F) + 1, byte2, byte3, time);</a>
<a name="ln477">			return;</a>
<a name="ln478"> </a>
<a name="ln479">		case B_NOTE_ON:</a>
<a name="ln480">			SprayNoteOn((byte1 &amp; 0x0F) + 1, byte2, byte3, time);</a>
<a name="ln481">			return;</a>
<a name="ln482"> </a>
<a name="ln483">		case B_KEY_PRESSURE:</a>
<a name="ln484">			SprayKeyPressure((byte1 &amp; 0x0F) + 1, byte2, byte3, time);</a>
<a name="ln485">			return;</a>
<a name="ln486"> </a>
<a name="ln487">		case B_CONTROL_CHANGE:</a>
<a name="ln488">			SprayControlChange((byte1 &amp; 0x0F) + 1, byte2, byte3, time);</a>
<a name="ln489">			return;</a>
<a name="ln490"> </a>
<a name="ln491">		case B_PROGRAM_CHANGE:</a>
<a name="ln492">			SprayProgramChange((byte1 &amp; 0x0F) + 1, byte2, time);</a>
<a name="ln493">			return;</a>
<a name="ln494"> </a>
<a name="ln495">		case B_CHANNEL_PRESSURE:</a>
<a name="ln496">			SprayChannelPressure((byte1 &amp; 0x0F) + 1, byte2, time);</a>
<a name="ln497">			return;</a>
<a name="ln498"> </a>
<a name="ln499">		case B_PITCH_BEND:</a>
<a name="ln500">			SprayPitchBend((byte1 &amp; 0x0F) + 1, byte2, byte3, time);</a>
<a name="ln501">			return;</a>
<a name="ln502"> </a>
<a name="ln503">		case 0xF0:</a>
<a name="ln504">			switch (byte1) {</a>
<a name="ln505">				case B_SYS_EX_START:</a>
<a name="ln506">					SpraySystemExclusive(event-&gt;data, event-&gt;length, time);</a>
<a name="ln507">					return;</a>
<a name="ln508"> </a>
<a name="ln509">				case B_MIDI_TIME_CODE:</a>
<a name="ln510">				case B_SONG_POSITION:</a>
<a name="ln511">				case B_SONG_SELECT:</a>
<a name="ln512">				case B_CABLE_MESSAGE:</a>
<a name="ln513">				case B_TUNE_REQUEST:</a>
<a name="ln514">				case B_SYS_EX_END:</a>
<a name="ln515">					SpraySystemCommon(byte1, byte2, byte3, time);</a>
<a name="ln516">					return;</a>
<a name="ln517"> </a>
<a name="ln518">				case B_TIMING_CLOCK:</a>
<a name="ln519">				case B_START:</a>
<a name="ln520">				case B_CONTINUE:</a>
<a name="ln521">				case B_STOP:</a>
<a name="ln522">				case B_ACTIVE_SENSING:</a>
<a name="ln523">					SpraySystemRealTime(byte1, time);</a>
<a name="ln524">					return;</a>
<a name="ln525"> </a>
<a name="ln526">				case B_SYSTEM_RESET:</a>
<a name="ln527">					if (byte2 == 0x51 &amp;&amp; byte3 == 0x03) {</a>
<a name="ln528">						SprayTempoChange(event-&gt;tempo, time);</a>
<a name="ln529">						fBeatsPerMinute = event-&gt;tempo;</a>
<a name="ln530">					} else</a>
<a name="ln531">						SpraySystemRealTime(byte1, time);</a>
<a name="ln532">					return;</a>
<a name="ln533">			}</a>
<a name="ln534">			return;</a>
<a name="ln535">	}</a>
<a name="ln536">}</a>
<a name="ln537"> </a>
<a name="ln538"> </a>
<a name="ln539">BMidiEvent*</a>
<a name="ln540">BMidiStore::EventAt(int32 index) const</a>
<a name="ln541">{</a>
<a name="ln542">	return (BMidiEvent*)fEvents-&gt;ItemAt(index);</a>
<a name="ln543">}</a>
<a name="ln544"> </a>
<a name="ln545"> </a>
<a name="ln546">uint32</a>
<a name="ln547">BMidiStore::GetEventTime(const BMidiEvent* event) const</a>
<a name="ln548">{</a>
<a name="ln549">	if (event-&gt;ticks)</a>
<a name="ln550">		return TicksToMilliseconds(event-&gt;time);</a>
<a name="ln551"> </a>
<a name="ln552">	return event-&gt;time;</a>
<a name="ln553">}</a>
<a name="ln554"> </a>
<a name="ln555"> </a>
<a name="ln556">uint32</a>
<a name="ln557">BMidiStore::TicksToMilliseconds(uint32 ticks) const</a>
<a name="ln558">{</a>
<a name="ln559">	return ((uint64)ticks * 60000) / (fBeatsPerMinute * fTicksPerBeat);</a>
<a name="ln560">}</a>
<a name="ln561"> </a>
<a name="ln562"> </a>
<a name="ln563">uint32</a>
<a name="ln564">BMidiStore::MillisecondsToTicks(uint32 ms) const</a>
<a name="ln565">{</a>
<a name="ln566">	return ((uint64)ms * fBeatsPerMinute * fTicksPerBeat) / 60000;</a>
<a name="ln567">}</a>
<a name="ln568"> </a>
<a name="ln569"> </a>
<a name="ln570">void</a>
<a name="ln571">BMidiStore::ReadFourCC(char* fourcc)</a>
<a name="ln572">{</a>
<a name="ln573">	if (fFile-&gt;Read(fourcc, 4) != 4)</a>
<a name="ln574">		throw (status_t) B_BAD_MIDI_DATA;</a>
<a name="ln575">}</a>
<a name="ln576"> </a>
<a name="ln577"> </a>
<a name="ln578">void</a>
<a name="ln579">BMidiStore::WriteFourCC(char a, char b, char c, char d)</a>
<a name="ln580">{</a>
<a name="ln581">	char fourcc[4] = { a, b, c, d };</a>
<a name="ln582"> </a>
<a name="ln583">	if (fFile-&gt;Write(fourcc, 4) != 4)</a>
<a name="ln584">		throw (status_t) B_ERROR;</a>
<a name="ln585">}</a>
<a name="ln586"> </a>
<a name="ln587"> </a>
<a name="ln588">uint32</a>
<a name="ln589">BMidiStore::Read32Bit()</a>
<a name="ln590">{</a>
<a name="ln591">	uint8 buf[4];</a>
<a name="ln592">	if (fFile-&gt;Read(buf, 4) != 4)</a>
<a name="ln593">		throw (status_t) B_BAD_MIDI_DATA;</a>
<a name="ln594"> </a>
<a name="ln595">	return (buf[0] &lt;&lt; 24L) | (buf[1] &lt;&lt; 16L) | (buf[2] &lt;&lt; 8L) | buf[3];</a>
<a name="ln596">}</a>
<a name="ln597"> </a>
<a name="ln598"> </a>
<a name="ln599">void</a>
<a name="ln600">BMidiStore::Write32Bit(uint32 val)</a>
<a name="ln601">{</a>
<a name="ln602">	uint8 buf[4];</a>
<a name="ln603">	buf[0] = (val &gt;&gt; 24) &amp; 0xFF;</a>
<a name="ln604">	buf[1] = (val &gt;&gt; 16) &amp; 0xFF;</a>
<a name="ln605">	buf[2] = (val &gt;&gt;  8) &amp; 0xFF;</a>
<a name="ln606">	buf[3] =  val        &amp; 0xFF;</a>
<a name="ln607"> </a>
<a name="ln608">	if (fFile-&gt;Write(buf, 4) != 4)</a>
<a name="ln609">		throw (status_t) B_ERROR;</a>
<a name="ln610">}</a>
<a name="ln611"> </a>
<a name="ln612"> </a>
<a name="ln613">uint16</a>
<a name="ln614">BMidiStore::Read16Bit()</a>
<a name="ln615">{</a>
<a name="ln616">	uint8 buf[2];</a>
<a name="ln617">	if (fFile-&gt;Read(buf, 2) != 2)</a>
<a name="ln618">		throw (status_t) B_BAD_MIDI_DATA;</a>
<a name="ln619"> </a>
<a name="ln620">	return (buf[0] &lt;&lt; 8) | buf[1];</a>
<a name="ln621">}</a>
<a name="ln622"> </a>
<a name="ln623"> </a>
<a name="ln624">void</a>
<a name="ln625">BMidiStore::Write16Bit(uint16 val)</a>
<a name="ln626">{</a>
<a name="ln627">	uint8 buf[2];</a>
<a name="ln628">	buf[0] = (val &gt;&gt; 8) &amp; 0xFF;</a>
<a name="ln629">	buf[1] = val &amp; 0xFF;</a>
<a name="ln630"> </a>
<a name="ln631">	if (fFile-&gt;Write(buf, 2) != 2)</a>
<a name="ln632">		throw (status_t) B_ERROR;</a>
<a name="ln633">}</a>
<a name="ln634"> </a>
<a name="ln635"> </a>
<a name="ln636">uint8</a>
<a name="ln637">BMidiStore::PeekByte()</a>
<a name="ln638">{</a>
<a name="ln639">	uint8 buf;</a>
<a name="ln640">	if (fFile-&gt;Read(&amp;buf, 1) != 1)</a>
<a name="ln641">		throw (status_t) B_BAD_MIDI_DATA;</a>
<a name="ln642"> </a>
<a name="ln643">	if (fFile-&gt;Seek(-1, SEEK_CUR) &lt; 0)</a>
<a name="ln644">		throw (status_t) B_ERROR;</a>
<a name="ln645"> </a>
<a name="ln646">	return buf;</a>
<a name="ln647">}</a>
<a name="ln648"> </a>
<a name="ln649"> </a>
<a name="ln650">uint8</a>
<a name="ln651">BMidiStore::NextByte()</a>
<a name="ln652">{</a>
<a name="ln653">	uint8 buf;</a>
<a name="ln654">	if (fFile-&gt;Read(&amp;buf, 1) != 1)</a>
<a name="ln655">		throw (status_t) B_BAD_MIDI_DATA;</a>
<a name="ln656"> </a>
<a name="ln657">	--fByteCount;</a>
<a name="ln658">	return buf;</a>
<a name="ln659">}</a>
<a name="ln660"> </a>
<a name="ln661"> </a>
<a name="ln662">void</a>
<a name="ln663">BMidiStore::WriteByte(uint8 val)</a>
<a name="ln664">{</a>
<a name="ln665">	if (fFile-&gt;Write(&amp;val, 1) != 1)</a>
<a name="ln666">		throw (status_t) B_ERROR;</a>
<a name="ln667"> </a>
<a name="ln668">	++fByteCount;</a>
<a name="ln669">}</a>
<a name="ln670"> </a>
<a name="ln671"> </a>
<a name="ln672">void</a>
<a name="ln673">BMidiStore::SkipBytes(uint32 length)</a>
<a name="ln674">{</a>
<a name="ln675">	if (fFile-&gt;Seek(length, SEEK_CUR) &lt; 0) {</a>
<a name="ln676">		throw (status_t) B_BAD_MIDI_DATA;</a>
<a name="ln677">	}</a>
<a name="ln678"> </a>
<a name="ln679">	fByteCount -= length;</a>
<a name="ln680">}</a>
<a name="ln681"> </a>
<a name="ln682"> </a>
<a name="ln683">uint32</a>
<a name="ln684">BMidiStore::ReadVarLength()</a>
<a name="ln685">{</a>
<a name="ln686">	uint32 val;</a>
<a name="ln687">	uint8 byte;</a>
<a name="ln688"> </a>
<a name="ln689">	if ((val = NextByte()) &amp; 0x80) {</a>
<a name="ln690">		val &amp;= 0x7F;</a>
<a name="ln691">		do {</a>
<a name="ln692">			val = (val &lt;&lt; 7) + ((byte = NextByte()) &amp; 0x7F);</a>
<a name="ln693">		} while (byte &amp; 0x80);</a>
<a name="ln694">	}</a>
<a name="ln695"> </a>
<a name="ln696">	return val;</a>
<a name="ln697">}</a>
<a name="ln698"> </a>
<a name="ln699"> </a>
<a name="ln700">void</a>
<a name="ln701">BMidiStore::WriteVarLength(uint32 val)</a>
<a name="ln702">{</a>
<a name="ln703">	uint32 buffer = val &amp; 0x7F;</a>
<a name="ln704"> </a>
<a name="ln705">	while ((val &gt;&gt;= 7) != 0) {</a>
<a name="ln706">		buffer &lt;&lt;= 8;</a>
<a name="ln707">		buffer |= ((val &amp; 0x7F) | 0x80);</a>
<a name="ln708">	}</a>
<a name="ln709"> </a>
<a name="ln710">	while (true) {</a>
<a name="ln711">		WriteByte(buffer);</a>
<a name="ln712">		if (buffer &amp; 0x80)</a>
<a name="ln713">			buffer &gt;&gt;= 8;</a>
<a name="ln714">		else</a>
<a name="ln715">			break;</a>
<a name="ln716">	}</a>
<a name="ln717">}</a>
<a name="ln718"> </a>
<a name="ln719"> </a>
<a name="ln720">void</a>
<a name="ln721">BMidiStore::ReadChunk()</a>
<a name="ln722">{</a>
<a name="ln723">	char fourcc[4];</a>
<a name="ln724">	ReadFourCC(fourcc);</a>
<a name="ln725"> </a>
<a name="ln726">	fByteCount = Read32Bit();</a>
<a name="ln727"> </a>
<a name="ln728">	if (strncmp(fourcc, &quot;MTrk&quot;, 4) == 0)</a>
<a name="ln729">		ReadTrack();</a>
<a name="ln730">	else {</a>
<a name="ln731">		TRACE((&quot;Skipping '%c%c%c%c' chunk (%&quot; B_PRIu32 &quot; bytes)&quot;,</a>
<a name="ln732">			fourcc[0], fourcc[1], fourcc[2], fourcc[3], fByteCount))</a>
<a name="ln733"> </a>
<a name="ln734">		SkipBytes(fByteCount);</a>
<a name="ln735">	}</a>
<a name="ln736">}</a>
<a name="ln737"> </a>
<a name="ln738"> </a>
<a name="ln739">void</a>
<a name="ln740">BMidiStore::ReadTrack()</a>
<a name="ln741">{</a>
<a name="ln742">	uint8 status = 0;</a>
<a name="ln743">	uint8 data1;</a>
<a name="ln744">	uint8 data2;</a>
<a name="ln745">	BMidiEvent* event;</a>
<a name="ln746"> </a>
<a name="ln747">	fTotalTicks = 0;</a>
<a name="ln748"> </a>
<a name="ln749">	while (fByteCount &gt; 0) {</a>
<a name="ln750">		uint32 ticks = ReadVarLength();</a>
<a name="ln751">		fTotalTicks += ticks;</a>
<a name="ln752"> </a>
<a name="ln753">		if (PeekByte() &amp; 0x80)</a>
<a name="ln754">			status = NextByte();</a>
<a name="ln755"> </a>
<a name="ln756">		switch (status &amp; 0xF0) {</a>
<a name="ln757">			case B_NOTE_OFF:</a>
<a name="ln758">			case B_NOTE_ON:</a>
<a name="ln759">			case B_KEY_PRESSURE:</a>
<a name="ln760">			case B_CONTROL_CHANGE:</a>
<a name="ln761">			case B_PITCH_BEND:</a>
<a name="ln762">				data1 = NextByte();</a>
<a name="ln763">				data2 = NextByte();</a>
<a name="ln764">				event = new BMidiEvent;</a>
<a name="ln765">				event-&gt;time  = fTotalTicks;</a>
<a name="ln766">				event-&gt;ticks = true;</a>
<a name="ln767">				event-&gt;byte1 = status;</a>
<a name="ln768">				event-&gt;byte2 = data1;</a>
<a name="ln769">				event-&gt;byte3 = data2;</a>
<a name="ln770">				AddEvent(event);</a>
<a name="ln771">				break;</a>
<a name="ln772"> </a>
<a name="ln773">			case B_PROGRAM_CHANGE:</a>
<a name="ln774">			case B_CHANNEL_PRESSURE:</a>
<a name="ln775">				data1 = NextByte();</a>
<a name="ln776">				event = new BMidiEvent;</a>
<a name="ln777">				event-&gt;time  = fTotalTicks;</a>
<a name="ln778">				event-&gt;ticks = true;</a>
<a name="ln779">				event-&gt;byte1 = status;</a>
<a name="ln780">				event-&gt;byte2 = data1;</a>
<a name="ln781">				AddEvent(event);</a>
<a name="ln782"> </a>
<a name="ln783">				if ((status &amp; 0xF0) == B_PROGRAM_CHANGE)</a>
<a name="ln784">					fInstruments[data1] = true;</a>
<a name="ln785">				break;</a>
<a name="ln786"> </a>
<a name="ln787">			case 0xF0:</a>
<a name="ln788">				switch (status) {</a>
<a name="ln789">					case B_SYS_EX_START:</a>
<a name="ln790">						ReadSystemExclusive();</a>
<a name="ln791">						break;</a>
<a name="ln792"> </a>
<a name="ln793">					case B_TUNE_REQUEST:</a>
<a name="ln794">					case B_SYS_EX_END:</a>
<a name="ln795">					case B_TIMING_CLOCK:</a>
<a name="ln796">					case B_START:</a>
<a name="ln797">					case B_CONTINUE:</a>
<a name="ln798">					case B_STOP:</a>
<a name="ln799">					case B_ACTIVE_SENSING:</a>
<a name="ln800">						event = new BMidiEvent;</a>
<a name="ln801">						event-&gt;time  = fTotalTicks;</a>
<a name="ln802">						event-&gt;ticks = true;</a>
<a name="ln803">						event-&gt;byte1 = status;</a>
<a name="ln804">						AddEvent(event);</a>
<a name="ln805">						break;</a>
<a name="ln806"> </a>
<a name="ln807">					case B_MIDI_TIME_CODE:</a>
<a name="ln808">					case B_SONG_SELECT:</a>
<a name="ln809">					case B_CABLE_MESSAGE:</a>
<a name="ln810">						data1 = NextByte();</a>
<a name="ln811">						event = new BMidiEvent;</a>
<a name="ln812">						event-&gt;time  = fTotalTicks;</a>
<a name="ln813">						event-&gt;ticks = true;</a>
<a name="ln814">						event-&gt;byte1 = status;</a>
<a name="ln815">						event-&gt;byte2 = data1;</a>
<a name="ln816">						AddEvent(event);</a>
<a name="ln817">						break;</a>
<a name="ln818"> </a>
<a name="ln819">					case B_SONG_POSITION:</a>
<a name="ln820">						data1 = NextByte();</a>
<a name="ln821">						data2 = NextByte();</a>
<a name="ln822">						event = new BMidiEvent;</a>
<a name="ln823">						event-&gt;time  = fTotalTicks;</a>
<a name="ln824">						event-&gt;ticks = true;</a>
<a name="ln825">						event-&gt;byte1 = status;</a>
<a name="ln826">						event-&gt;byte2 = data1;</a>
<a name="ln827">						event-&gt;byte3 = data2;</a>
<a name="ln828">						AddEvent(event);</a>
<a name="ln829">						break;</a>
<a name="ln830"> </a>
<a name="ln831">					case B_SYSTEM_RESET:</a>
<a name="ln832">						ReadMetaEvent();</a>
<a name="ln833">						break;</a>
<a name="ln834">				}</a>
<a name="ln835">				break;</a>
<a name="ln836">		}</a>
<a name="ln837"> </a>
<a name="ln838">		event = NULL;</a>
<a name="ln839">	}</a>
<a name="ln840">		</a>
<a name="ln841">	++fCurrTrack;</a>
<a name="ln842">}</a>
<a name="ln843"> </a>
<a name="ln844"> </a>
<a name="ln845">void</a>
<a name="ln846">BMidiStore::ReadSystemExclusive()</a>
<a name="ln847">{</a>
<a name="ln848">	// We do not import sysex's from MIDI files.</a>
<a name="ln849"> </a>
<a name="ln850">	SkipBytes(ReadVarLength());</a>
<a name="ln851">}</a>
<a name="ln852"> </a>
<a name="ln853"> </a>
<a name="ln854">void</a>
<a name="ln855">BMidiStore::ReadMetaEvent()</a>
<a name="ln856">{</a>
<a name="ln857">	// We only import the Tempo Change meta event.</a>
<a name="ln858"> </a>
<a name="ln859">	uint8 type = NextByte();	</a>
<a name="ln860">	uint32 length = ReadVarLength();</a>
<a name="ln861"> </a>
<a name="ln862">	if (type == 0x51 &amp;&amp; length == 3) {</a>
<a name="ln863">		uchar data[3];</a>
<a name="ln864">		data[0] = NextByte();</a>
<a name="ln865">		data[1] = NextByte();</a>
<a name="ln866">		data[2] = NextByte();</a>
<a name="ln867">		uint32 val = (data[0] &lt;&lt; 16) | (data[1] &lt;&lt; 8) | data[2];</a>
<a name="ln868"> </a>
<a name="ln869">		BMidiEvent* event = new BMidiEvent;</a>
<a name="ln870">		event-&gt;time  = fTotalTicks;</a>
<a name="ln871">		event-&gt;ticks = true;</a>
<a name="ln872">		event-&gt;byte1 = 0xFF;</a>
<a name="ln873">		event-&gt;byte2 = 0x51;</a>
<a name="ln874">		event-&gt;byte3 = 0x03;</a>
<a name="ln875">		event-&gt;tempo = 60000000 / val;</a>
<a name="ln876">		AddEvent(event);</a>
<a name="ln877">	} else</a>
<a name="ln878">		SkipBytes(length);</a>
<a name="ln879">}</a>
<a name="ln880"> </a>
<a name="ln881"> </a>
<a name="ln882">void</a>
<a name="ln883">BMidiStore::WriteTrack()</a>
<a name="ln884">{</a>
<a name="ln885">	WriteFourCC('M', 'T', 'r', 'k');</a>
<a name="ln886">	off_t lengthPos = fFile-&gt;Position();</a>
<a name="ln887">	Write32Bit(0);</a>
<a name="ln888"> </a>
<a name="ln889">	fByteCount = 0;</a>
<a name="ln890">	uint32 oldTime = 0;</a>
<a name="ln891">	uint32 newTime;</a>
<a name="ln892"> </a>
<a name="ln893">	for (uint32 t = 0; t &lt; CountEvents(); ++t) {</a>
<a name="ln894">		BMidiEvent* event = EventAt(t);</a>
<a name="ln895"> </a>
<a name="ln896">		if (event-&gt;ticks)</a>
<a name="ln897">			newTime = event-&gt;time;</a>
<a name="ln898">		else</a>
<a name="ln899">			newTime = MillisecondsToTicks(event-&gt;time);</a>
<a name="ln900"> </a>
<a name="ln901">		if (t == 0)</a>
<a name="ln902">			WriteVarLength(0);</a>
<a name="ln903">		else</a>
<a name="ln904">			WriteVarLength(newTime - oldTime);</a>
<a name="ln905"> </a>
<a name="ln906">		oldTime = newTime;</a>
<a name="ln907"> </a>
<a name="ln908">		switch (event-&gt;byte1 &amp; 0xF0) {</a>
<a name="ln909">			case B_NOTE_OFF:</a>
<a name="ln910">			case B_NOTE_ON:</a>
<a name="ln911">			case B_KEY_PRESSURE:</a>
<a name="ln912">			case B_CONTROL_CHANGE:</a>
<a name="ln913">			case B_PITCH_BEND:</a>
<a name="ln914">				WriteByte(event-&gt;byte1);</a>
<a name="ln915">				WriteByte(event-&gt;byte2);</a>
<a name="ln916">				WriteByte(event-&gt;byte3);</a>
<a name="ln917">				break;</a>
<a name="ln918"> </a>
<a name="ln919">			case B_PROGRAM_CHANGE:</a>
<a name="ln920">			case B_CHANNEL_PRESSURE:</a>
<a name="ln921">				WriteByte(event-&gt;byte1);</a>
<a name="ln922">				WriteByte(event-&gt;byte2);</a>
<a name="ln923">				break;</a>
<a name="ln924"> </a>
<a name="ln925">			case 0xF0:</a>
<a name="ln926">				switch (event-&gt;byte1) {</a>
<a name="ln927">					case B_SYS_EX_START:</a>
<a name="ln928">						// We do not export sysex's.</a>
<a name="ln929">						break;</a>
<a name="ln930"> </a>
<a name="ln931">					case B_TUNE_REQUEST:</a>
<a name="ln932">					case B_SYS_EX_END:</a>
<a name="ln933">					case B_TIMING_CLOCK:</a>
<a name="ln934">					case B_START:</a>
<a name="ln935">					case B_CONTINUE:</a>
<a name="ln936">					case B_STOP:</a>
<a name="ln937">					case B_ACTIVE_SENSING:</a>
<a name="ln938">						WriteByte(event-&gt;byte1);</a>
<a name="ln939">						break;</a>
<a name="ln940"> </a>
<a name="ln941">					case B_MIDI_TIME_CODE:</a>
<a name="ln942">					case B_SONG_SELECT:</a>
<a name="ln943">					case B_CABLE_MESSAGE:</a>
<a name="ln944">						WriteByte(event-&gt;byte1);</a>
<a name="ln945">						WriteByte(event-&gt;byte2);</a>
<a name="ln946">						break;</a>
<a name="ln947"> </a>
<a name="ln948">					case B_SONG_POSITION:</a>
<a name="ln949">						WriteByte(event-&gt;byte1);</a>
<a name="ln950">						WriteByte(event-&gt;byte2);</a>
<a name="ln951">						WriteByte(event-&gt;byte3);</a>
<a name="ln952">						break;</a>
<a name="ln953"> </a>
<a name="ln954">					case B_SYSTEM_RESET:</a>
<a name="ln955">						WriteMetaEvent(event);</a>
<a name="ln956">						break;</a>
<a name="ln957">				}</a>
<a name="ln958">				break;</a>
<a name="ln959">		}</a>
<a name="ln960">	}</a>
<a name="ln961"> </a>
<a name="ln962">	WriteVarLength(0);</a>
<a name="ln963">	WriteByte(0xFF);   // the end-of-track</a>
<a name="ln964">	WriteByte(0x2F);   // marker is required</a>
<a name="ln965">	WriteByte(0x00);  </a>
<a name="ln966"> </a>
<a name="ln967">	fFile-&gt;Seek(lengthPos, SEEK_SET);</a>
<a name="ln968">	Write32Bit(fByteCount);</a>
<a name="ln969">	fFile-&gt;Seek(0, SEEK_END);</a>
<a name="ln970">}</a>
<a name="ln971"> </a>
<a name="ln972"> </a>
<a name="ln973">void</a>
<a name="ln974">BMidiStore::WriteMetaEvent(BMidiEvent* event)</a>
<a name="ln975">{</a>
<a name="ln976">	// We only export the Tempo Change meta event.</a>
<a name="ln977"> </a>
<a name="ln978">	if (event-&gt;byte2 == 0x51 &amp;&amp; event-&gt;byte3 == 0x03) {</a>
<a name="ln979">		uint32 val = 60000000 / event-&gt;tempo;</a>
<a name="ln980"> </a>
<a name="ln981">		WriteByte(0xFF);</a>
<a name="ln982">		WriteByte(0x51);</a>
<a name="ln983">		WriteByte(0x03);</a>
<a name="ln984">		WriteByte(val &gt;&gt; 16);</a>
<a name="ln985">		WriteByte(val &gt;&gt; 8);</a>
<a name="ln986">		WriteByte(val);</a>
<a name="ln987">	}</a>
<a name="ln988">}</a>
<a name="ln989"> </a>

</code></pre>
<div class="balloon" rel="26"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: time, ticks, tempo.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
