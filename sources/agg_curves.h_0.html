
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>agg_curves.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//----------------------------------------------------------------------------</a>
<a name="ln2">// Anti-Grain Geometry - Version 2.4</a>
<a name="ln3">// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)</a>
<a name="ln4">// Copyright (C) 2005 Tony Juricic (tonygeek@yahoo.com)</a>
<a name="ln5">//</a>
<a name="ln6">// Permission to copy, use, modify, sell and distribute this software </a>
<a name="ln7">// is granted provided this copyright notice appears in all copies. </a>
<a name="ln8">// This software is provided &quot;as is&quot; without express or implied</a>
<a name="ln9">// warranty, and with no claim as to its suitability for any purpose.</a>
<a name="ln10">//</a>
<a name="ln11">//----------------------------------------------------------------------------</a>
<a name="ln12">// Contact: mcseem@antigrain.com</a>
<a name="ln13">//          mcseemagg@yahoo.com</a>
<a name="ln14">//          http://www.antigrain.com</a>
<a name="ln15">//----------------------------------------------------------------------------</a>
<a name="ln16"> </a>
<a name="ln17">#ifndef AGG_CURVES_INCLUDED</a>
<a name="ln18">#define AGG_CURVES_INCLUDED</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;agg_array.h&quot;</a>
<a name="ln21"> </a>
<a name="ln22">namespace agg</a>
<a name="ln23">{</a>
<a name="ln24"> </a>
<a name="ln25">    // See Implementation agg_curves.cpp</a>
<a name="ln26"> </a>
<a name="ln27">    //--------------------------------------------curve_approximation_method_e</a>
<a name="ln28">    enum curve_approximation_method_e</a>
<a name="ln29">    {</a>
<a name="ln30">        curve_inc,</a>
<a name="ln31">        curve_div</a>
<a name="ln32">    };</a>
<a name="ln33">    </a>
<a name="ln34">    //--------------------------------------------------------------curve3_inc</a>
<a name="ln35">    class curve3_inc</a>
<a name="ln36">    {</a>
<a name="ln37">    public:</a>
<a name="ln38">        curve3_inc() :</a>
<a name="ln39">          m_num_steps(0), m_step(0), m_scale(1.0) { }</a>
<a name="ln40"> </a>
<a name="ln41">        curve3_inc(double x1, double y1, </a>
<a name="ln42">                   double x2, double y2, </a>
<a name="ln43">                   double x3, double y3) :</a>
<a name="ln44">            m_num_steps(0), m_step(0), m_scale(1.0) </a>
<a name="ln45">        { </a>
<a name="ln46">            init(x1, y1, x2, y2, x3, y3);</a>
<a name="ln47">        }</a>
<a name="ln48"> </a>
<a name="ln49">        void reset() { m_num_steps = 0; m_step = -1; }</a>
<a name="ln50">        void init(double x1, double y1, </a>
<a name="ln51">                  double x2, double y2, </a>
<a name="ln52">                  double x3, double y3);</a>
<a name="ln53"> </a>
<a name="ln54">        void approximation_method(curve_approximation_method_e) {}</a>
<a name="ln55">        curve_approximation_method_e approximation_method() const { return curve_inc; }</a>
<a name="ln56"> </a>
<a name="ln57">        void approximation_scale(double s);</a>
<a name="ln58">        double approximation_scale() const;</a>
<a name="ln59"> </a>
<a name="ln60">        void angle_tolerance(double) {}</a>
<a name="ln61">        double angle_tolerance() const { return 0.0; }</a>
<a name="ln62"> </a>
<a name="ln63">        void cusp_limit(double) {}</a>
<a name="ln64">        double cusp_limit() const { return 0.0; }</a>
<a name="ln65"> </a>
<a name="ln66">        void     rewind(unsigned path_id);</a>
<a name="ln67">        unsigned vertex(double* x, double* y);</a>
<a name="ln68"> </a>
<a name="ln69">    private:</a>
<a name="ln70">        int      m_num_steps;</a>
<a name="ln71">        int      m_step;</a>
<a name="ln72">        double   m_scale;</a>
<a name="ln73">        double   m_start_x; </a>
<a name="ln74">        double   m_start_y;</a>
<a name="ln75">        double   m_end_x; </a>
<a name="ln76">        double   m_end_y;</a>
<a name="ln77">        double   m_fx; </a>
<a name="ln78">        double   m_fy;</a>
<a name="ln79">        double   m_dfx; </a>
<a name="ln80">        double   m_dfy;</a>
<a name="ln81">        double   m_ddfx; </a>
<a name="ln82">        double   m_ddfy;</a>
<a name="ln83">        double   m_saved_fx; </a>
<a name="ln84">        double   m_saved_fy;</a>
<a name="ln85">        double   m_saved_dfx; </a>
<a name="ln86">        double   m_saved_dfy;</a>
<a name="ln87">    };</a>
<a name="ln88"> </a>
<a name="ln89"> </a>
<a name="ln90"> </a>
<a name="ln91"> </a>
<a name="ln92"> </a>
<a name="ln93">    //-------------------------------------------------------------curve3_div</a>
<a name="ln94">    class curve3_div</a>
<a name="ln95">    {</a>
<a name="ln96">    public:</a>
<a name="ln97">        curve3_div() : </a>
<a name="ln98">            m_approximation_scale(1.0),</a>
<a name="ln99">            m_angle_tolerance(0.0),</a>
<a name="ln100">            m_count(0)</a>
<a name="ln101">        {}</a>
<a name="ln102"> </a>
<a name="ln103">        curve3_div(double x1, double y1, </a>
<a name="ln104">                   double x2, double y2, </a>
<a name="ln105">                   double x3, double y3) :</a>
<a name="ln106">            m_approximation_scale(1.0),</a>
<a name="ln107">            m_angle_tolerance(0.0),</a>
<a name="ln108">            m_count(0)</a>
<a name="ln109">        { </a>
<a name="ln110">            init(x1, y1, x2, y2, x3, y3);</a>
<a name="ln111">        }</a>
<a name="ln112"> </a>
<a name="ln113">        void reset() { m_points.remove_all(); m_count = 0; }</a>
<a name="ln114">        void init(double x1, double y1, </a>
<a name="ln115">                  double x2, double y2, </a>
<a name="ln116">                  double x3, double y3);</a>
<a name="ln117"> </a>
<a name="ln118">        void approximation_method(curve_approximation_method_e) {}</a>
<a name="ln119">        curve_approximation_method_e approximation_method() const { return curve_div; }</a>
<a name="ln120"> </a>
<a name="ln121">        void approximation_scale(double s) { m_approximation_scale = s; }</a>
<a name="ln122">        double approximation_scale() const { return m_approximation_scale;  }</a>
<a name="ln123"> </a>
<a name="ln124">        void angle_tolerance(double a) { m_angle_tolerance = a; }</a>
<a name="ln125">        double angle_tolerance() const { return m_angle_tolerance;  }</a>
<a name="ln126"> </a>
<a name="ln127">        void cusp_limit(double) {}</a>
<a name="ln128">        double cusp_limit() const { return 0.0; }</a>
<a name="ln129"> </a>
<a name="ln130">        void rewind(unsigned)</a>
<a name="ln131">        {</a>
<a name="ln132">            m_count = 0;</a>
<a name="ln133">        }</a>
<a name="ln134"> </a>
<a name="ln135">        unsigned vertex(double* x, double* y)</a>
<a name="ln136">        {</a>
<a name="ln137">            if(m_count &gt;= m_points.size()) return path_cmd_stop;</a>
<a name="ln138">            const point_d&amp; p = m_points[m_count++];</a>
<a name="ln139">            *x = p.x;</a>
<a name="ln140">            *y = p.y;</a>
<a name="ln141">            return (m_count == 1) ? path_cmd_move_to : path_cmd_line_to;</a>
<a name="ln142">        }</a>
<a name="ln143"> </a>
<a name="ln144">    private:</a>
<a name="ln145">        void bezier(double x1, double y1, </a>
<a name="ln146">                    double x2, double y2, </a>
<a name="ln147">                    double x3, double y3);</a>
<a name="ln148">        void recursive_bezier(double x1, double y1, </a>
<a name="ln149">                              double x2, double y2, </a>
<a name="ln150">                              double x3, double y3,</a>
<a name="ln151">                              unsigned level);</a>
<a name="ln152"> </a>
<a name="ln153">        double               m_approximation_scale;</a>
<a name="ln154">        double               m_distance_tolerance_square;</a>
<a name="ln155">        double               m_angle_tolerance;</a>
<a name="ln156">        unsigned             m_count;</a>
<a name="ln157">        pod_bvector&lt;point_d&gt; m_points;</a>
<a name="ln158">    };</a>
<a name="ln159"> </a>
<a name="ln160"> </a>
<a name="ln161"> </a>
<a name="ln162"> </a>
<a name="ln163"> </a>
<a name="ln164"> </a>
<a name="ln165"> </a>
<a name="ln166">    //-------------------------------------------------------------curve4_points</a>
<a name="ln167">    struct curve4_points</a>
<a name="ln168">    {</a>
<a name="ln169">        double cp[8];</a>
<a name="ln170">        curve4_points() {}</a>
<a name="ln171">        curve4_points(double x1, double y1,</a>
<a name="ln172">                      double x2, double y2,</a>
<a name="ln173">                      double x3, double y3,</a>
<a name="ln174">                      double x4, double y4)</a>
<a name="ln175">        {</a>
<a name="ln176">            cp[0] = x1; cp[1] = y1; cp[2] = x2; cp[3] = y2;</a>
<a name="ln177">            cp[4] = x3; cp[5] = y3; cp[6] = x4; cp[7] = y4;</a>
<a name="ln178">        }</a>
<a name="ln179">        void init(double x1, double y1,</a>
<a name="ln180">                  double x2, double y2,</a>
<a name="ln181">                  double x3, double y3,</a>
<a name="ln182">                  double x4, double y4)</a>
<a name="ln183">        {</a>
<a name="ln184">            cp[0] = x1; cp[1] = y1; cp[2] = x2; cp[3] = y2;</a>
<a name="ln185">            cp[4] = x3; cp[5] = y3; cp[6] = x4; cp[7] = y4;</a>
<a name="ln186">        }</a>
<a name="ln187">        double  operator [] (unsigned i) const { return cp[i]; }</a>
<a name="ln188">        double&amp; operator [] (unsigned i)       { return cp[i]; }</a>
<a name="ln189">    };</a>
<a name="ln190"> </a>
<a name="ln191"> </a>
<a name="ln192"> </a>
<a name="ln193">    //-------------------------------------------------------------curve4_inc</a>
<a name="ln194">    class curve4_inc</a>
<a name="ln195">    {</a>
<a name="ln196">    public:</a>
<a name="ln197">        curve4_inc() :</a>
<a name="ln198">            m_num_steps(0), m_step(0), m_scale(1.0) { }</a>
<a name="ln199"> </a>
<a name="ln200">        curve4_inc(double x1, double y1, </a>
<a name="ln201">                   double x2, double y2, </a>
<a name="ln202">                   double x3, double y3,</a>
<a name="ln203">                   double x4, double y4) :</a>
<a name="ln204">            m_num_steps(0), m_step(0), m_scale(1.0) </a>
<a name="ln205">        { </a>
<a name="ln206">            init(x1, y1, x2, y2, x3, y3, x4, y4);</a>
<a name="ln207">        }</a>
<a name="ln208"> </a>
<a name="ln209">        curve4_inc(const curve4_points&amp; cp) :</a>
<a name="ln210">            m_num_steps(0), m_step(0), m_scale(1.0) </a>
<a name="ln211">        { </a>
<a name="ln212">            init(cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);</a>
<a name="ln213">        }</a>
<a name="ln214"> </a>
<a name="ln215">        void reset() { m_num_steps = 0; m_step = -1; }</a>
<a name="ln216">        void init(double x1, double y1, </a>
<a name="ln217">                  double x2, double y2, </a>
<a name="ln218">                  double x3, double y3,</a>
<a name="ln219">                  double x4, double y4);</a>
<a name="ln220"> </a>
<a name="ln221">        void init(const curve4_points&amp; cp)</a>
<a name="ln222">        {</a>
<a name="ln223">            init(cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);</a>
<a name="ln224">        }</a>
<a name="ln225"> </a>
<a name="ln226">        void approximation_method(curve_approximation_method_e) {}</a>
<a name="ln227">        curve_approximation_method_e approximation_method() const { return curve_inc; }</a>
<a name="ln228"> </a>
<a name="ln229">        void approximation_scale(double s);</a>
<a name="ln230">        double approximation_scale() const;</a>
<a name="ln231"> </a>
<a name="ln232">        void angle_tolerance(double) {}</a>
<a name="ln233">        double angle_tolerance() const { return 0.0; }</a>
<a name="ln234"> </a>
<a name="ln235">        void cusp_limit(double) {}</a>
<a name="ln236">        double cusp_limit() const { return 0.0; }</a>
<a name="ln237"> </a>
<a name="ln238">        void     rewind(unsigned path_id);</a>
<a name="ln239">        unsigned vertex(double* x, double* y);</a>
<a name="ln240"> </a>
<a name="ln241">    private:</a>
<a name="ln242">        int      m_num_steps;</a>
<a name="ln243">        int      m_step;</a>
<a name="ln244">        double   m_scale;</a>
<a name="ln245">        double   m_start_x; </a>
<a name="ln246">        double   m_start_y;</a>
<a name="ln247">        double   m_end_x; </a>
<a name="ln248">        double   m_end_y;</a>
<a name="ln249">        double   m_fx; </a>
<a name="ln250">        double   m_fy;</a>
<a name="ln251">        double   m_dfx; </a>
<a name="ln252">        double   m_dfy;</a>
<a name="ln253">        double   m_ddfx; </a>
<a name="ln254">        double   m_ddfy;</a>
<a name="ln255">        double   m_dddfx; </a>
<a name="ln256">        double   m_dddfy;</a>
<a name="ln257">        double   m_saved_fx; </a>
<a name="ln258">        double   m_saved_fy;</a>
<a name="ln259">        double   m_saved_dfx; </a>
<a name="ln260">        double   m_saved_dfy;</a>
<a name="ln261">        double   m_saved_ddfx; </a>
<a name="ln262">        double   m_saved_ddfy;</a>
<a name="ln263">    };</a>
<a name="ln264"> </a>
<a name="ln265"> </a>
<a name="ln266"> </a>
<a name="ln267">    //-------------------------------------------------------catrom_to_bezier</a>
<a name="ln268">    inline curve4_points catrom_to_bezier(double x1, double y1, </a>
<a name="ln269">                                          double x2, double y2, </a>
<a name="ln270">                                          double x3, double y3,</a>
<a name="ln271">                                          double x4, double y4)</a>
<a name="ln272">    {</a>
<a name="ln273">        // Trans. matrix Catmull-Rom to Bezier</a>
<a name="ln274">        //</a>
<a name="ln275">        //  0       1       0       0</a>
<a name="ln276">        //  -1/6    1       1/6     0</a>
<a name="ln277">        //  0       1/6     1       -1/6</a>
<a name="ln278">        //  0       0       1       0</a>
<a name="ln279">        //</a>
<a name="ln280">        return curve4_points(</a>
<a name="ln281">            x2,</a>
<a name="ln282">            y2,</a>
<a name="ln283">            (-x1 + 6*x2 + x3) / 6,</a>
<a name="ln284">            (-y1 + 6*y2 + y3) / 6,</a>
<a name="ln285">            ( x2 + 6*x3 - x4) / 6,</a>
<a name="ln286">            ( y2 + 6*y3 - y4) / 6,</a>
<a name="ln287">            x3,</a>
<a name="ln288">            y3);</a>
<a name="ln289">    }</a>
<a name="ln290"> </a>
<a name="ln291"> </a>
<a name="ln292">    //-----------------------------------------------------------------------</a>
<a name="ln293">    inline curve4_points</a>
<a name="ln294">    catrom_to_bezier(const curve4_points&amp; cp)</a>
<a name="ln295">    {</a>
<a name="ln296">        return catrom_to_bezier(cp[0], cp[1], cp[2], cp[3], </a>
<a name="ln297">                                cp[4], cp[5], cp[6], cp[7]);</a>
<a name="ln298">    }</a>
<a name="ln299"> </a>
<a name="ln300"> </a>
<a name="ln301"> </a>
<a name="ln302">    //-----------------------------------------------------ubspline_to_bezier</a>
<a name="ln303">    inline curve4_points ubspline_to_bezier(double x1, double y1, </a>
<a name="ln304">                                            double x2, double y2, </a>
<a name="ln305">                                            double x3, double y3,</a>
<a name="ln306">                                            double x4, double y4)</a>
<a name="ln307">    {</a>
<a name="ln308">        // Trans. matrix Uniform BSpline to Bezier</a>
<a name="ln309">        //</a>
<a name="ln310">        //  1/6     4/6     1/6     0</a>
<a name="ln311">        //  0       4/6     2/6     0</a>
<a name="ln312">        //  0       2/6     4/6     0</a>
<a name="ln313">        //  0       1/6     4/6     1/6</a>
<a name="ln314">        //</a>
<a name="ln315">        return curve4_points(</a>
<a name="ln316">            (x1 + 4*x2 + x3) / 6,</a>
<a name="ln317">            (y1 + 4*y2 + y3) / 6,</a>
<a name="ln318">            (4*x2 + 2*x3) / 6,</a>
<a name="ln319">            (4*y2 + 2*y3) / 6,</a>
<a name="ln320">            (2*x2 + 4*x3) / 6,</a>
<a name="ln321">            (2*y2 + 4*y3) / 6,</a>
<a name="ln322">            (x2 + 4*x3 + x4) / 6,</a>
<a name="ln323">            (y2 + 4*y3 + y4) / 6);</a>
<a name="ln324">    }</a>
<a name="ln325"> </a>
<a name="ln326"> </a>
<a name="ln327">    //-----------------------------------------------------------------------</a>
<a name="ln328">    inline curve4_points </a>
<a name="ln329">    ubspline_to_bezier(const curve4_points&amp; cp)</a>
<a name="ln330">    {</a>
<a name="ln331">        return ubspline_to_bezier(cp[0], cp[1], cp[2], cp[3], </a>
<a name="ln332">                                  cp[4], cp[5], cp[6], cp[7]);</a>
<a name="ln333">    }</a>
<a name="ln334"> </a>
<a name="ln335"> </a>
<a name="ln336"> </a>
<a name="ln337"> </a>
<a name="ln338">    //------------------------------------------------------hermite_to_bezier</a>
<a name="ln339">    inline curve4_points hermite_to_bezier(double x1, double y1, </a>
<a name="ln340">                                           double x2, double y2, </a>
<a name="ln341">                                           double x3, double y3,</a>
<a name="ln342">                                           double x4, double y4)</a>
<a name="ln343">    {</a>
<a name="ln344">        // Trans. matrix Hermite to Bezier</a>
<a name="ln345">        //</a>
<a name="ln346">        //  1       0       0       0</a>
<a name="ln347">        //  1       0       1/3     0</a>
<a name="ln348">        //  0       1       0       -1/3</a>
<a name="ln349">        //  0       1       0       0</a>
<a name="ln350">        //</a>
<a name="ln351">        return curve4_points(</a>
<a name="ln352">            x1,</a>
<a name="ln353">            y1,</a>
<a name="ln354">            (3*x1 + x3) / 3,</a>
<a name="ln355">            (3*y1 + y3) / 3,</a>
<a name="ln356">            (3*x2 - x4) / 3,</a>
<a name="ln357">            (3*y2 - y4) / 3,</a>
<a name="ln358">            x2,</a>
<a name="ln359">            y2);</a>
<a name="ln360">    }</a>
<a name="ln361"> </a>
<a name="ln362"> </a>
<a name="ln363"> </a>
<a name="ln364">    //-----------------------------------------------------------------------</a>
<a name="ln365">    inline curve4_points </a>
<a name="ln366">    hermite_to_bezier(const curve4_points&amp; cp)</a>
<a name="ln367">    {</a>
<a name="ln368">        return hermite_to_bezier(cp[0], cp[1], cp[2], cp[3], </a>
<a name="ln369">                                 cp[4], cp[5], cp[6], cp[7]);</a>
<a name="ln370">    }</a>
<a name="ln371"> </a>
<a name="ln372"> </a>
<a name="ln373">    //-------------------------------------------------------------curve4_div</a>
<a name="ln374">    class curve4_div</a>
<a name="ln375">    {</a>
<a name="ln376">    public:</a>
<a name="ln377">        curve4_div() : </a>
<a name="ln378">            m_approximation_scale(1.0),</a>
<a name="ln379">            m_angle_tolerance(0.0),</a>
<a name="ln380">            m_cusp_limit(0.0),</a>
<a name="ln381">            m_count(0)</a>
<a name="ln382">        {}</a>
<a name="ln383"> </a>
<a name="ln384">        curve4_div(double x1, double y1, </a>
<a name="ln385">                   double x2, double y2, </a>
<a name="ln386">                   double x3, double y3,</a>
<a name="ln387">                   double x4, double y4) :</a>
<a name="ln388">            m_approximation_scale(1.0),</a>
<a name="ln389">            m_angle_tolerance(0.0),</a>
<a name="ln390">            m_cusp_limit(0.0),</a>
<a name="ln391">            m_count(0)</a>
<a name="ln392">        { </a>
<a name="ln393">            init(x1, y1, x2, y2, x3, y3, x4, y4);</a>
<a name="ln394">        }</a>
<a name="ln395"> </a>
<a name="ln396">        curve4_div(const curve4_points&amp; cp) :</a>
<a name="ln397">            m_approximation_scale(1.0),</a>
<a name="ln398">            m_angle_tolerance(0.0),</a>
<a name="ln399">            m_count(0)</a>
<a name="ln400">        { </a>
<a name="ln401">            init(cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);</a>
<a name="ln402">        }</a>
<a name="ln403"> </a>
<a name="ln404">        void reset() { m_points.remove_all(); m_count = 0; }</a>
<a name="ln405">        void init(double x1, double y1, </a>
<a name="ln406">                  double x2, double y2, </a>
<a name="ln407">                  double x3, double y3,</a>
<a name="ln408">                  double x4, double y4);</a>
<a name="ln409"> </a>
<a name="ln410">        void init(const curve4_points&amp; cp)</a>
<a name="ln411">        {</a>
<a name="ln412">            init(cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);</a>
<a name="ln413">        }</a>
<a name="ln414"> </a>
<a name="ln415">        void approximation_method(curve_approximation_method_e) {}</a>
<a name="ln416"> </a>
<a name="ln417">        curve_approximation_method_e approximation_method() const </a>
<a name="ln418">        { </a>
<a name="ln419">            return curve_div; </a>
<a name="ln420">        }</a>
<a name="ln421"> </a>
<a name="ln422">        void approximation_scale(double s) { m_approximation_scale = s; }</a>
<a name="ln423">        double approximation_scale() const { return m_approximation_scale;  }</a>
<a name="ln424"> </a>
<a name="ln425">        void angle_tolerance(double a) { m_angle_tolerance = a; }</a>
<a name="ln426">        double angle_tolerance() const { return m_angle_tolerance;  }</a>
<a name="ln427"> </a>
<a name="ln428">        void cusp_limit(double v) </a>
<a name="ln429">        { </a>
<a name="ln430">            m_cusp_limit = (v == 0.0) ? 0.0 : pi - v; </a>
<a name="ln431">        }</a>
<a name="ln432"> </a>
<a name="ln433">        double cusp_limit() const </a>
<a name="ln434">        { </a>
<a name="ln435">            return (m_cusp_limit == 0.0) ? 0.0 : pi - m_cusp_limit; </a>
<a name="ln436">        }</a>
<a name="ln437"> </a>
<a name="ln438">        void rewind(unsigned)</a>
<a name="ln439">        {</a>
<a name="ln440">            m_count = 0;</a>
<a name="ln441">        }</a>
<a name="ln442"> </a>
<a name="ln443">        unsigned vertex(double* x, double* y)</a>
<a name="ln444">        {</a>
<a name="ln445">            if(m_count &gt;= m_points.size()) return path_cmd_stop;</a>
<a name="ln446">            const point_d&amp; p = m_points[m_count++];</a>
<a name="ln447">            *x = p.x;</a>
<a name="ln448">            *y = p.y;</a>
<a name="ln449">            return (m_count == 1) ? path_cmd_move_to : path_cmd_line_to;</a>
<a name="ln450">        }</a>
<a name="ln451"> </a>
<a name="ln452">    private:</a>
<a name="ln453">        void bezier(double x1, double y1, </a>
<a name="ln454">                    double x2, double y2, </a>
<a name="ln455">                    double x3, double y3, </a>
<a name="ln456">                    double x4, double y4);</a>
<a name="ln457"> </a>
<a name="ln458">        void recursive_bezier(double x1, double y1, </a>
<a name="ln459">                              double x2, double y2, </a>
<a name="ln460">                              double x3, double y3, </a>
<a name="ln461">                              double x4, double y4,</a>
<a name="ln462">                              unsigned level);</a>
<a name="ln463"> </a>
<a name="ln464">        double               m_approximation_scale;</a>
<a name="ln465">        double               m_distance_tolerance_square;</a>
<a name="ln466">        double               m_angle_tolerance;</a>
<a name="ln467">        double               m_cusp_limit;</a>
<a name="ln468">        unsigned             m_count;</a>
<a name="ln469">        pod_bvector&lt;point_d&gt; m_points;</a>
<a name="ln470">    };</a>
<a name="ln471"> </a>
<a name="ln472"> </a>
<a name="ln473">    //-----------------------------------------------------------------curve3</a>
<a name="ln474">    class curve3</a>
<a name="ln475">    {</a>
<a name="ln476">    public:</a>
<a name="ln477">        curve3() : m_approximation_method(curve_div) {}</a>
<a name="ln478">        curve3(double x1, double y1, </a>
<a name="ln479">               double x2, double y2, </a>
<a name="ln480">               double x3, double y3) :</a>
<a name="ln481">            m_approximation_method(curve_div)</a>
<a name="ln482">        { </a>
<a name="ln483">            init(x1, y1, x2, y2, x3, y3);</a>
<a name="ln484">        }</a>
<a name="ln485"> </a>
<a name="ln486">        void reset() </a>
<a name="ln487">        { </a>
<a name="ln488">            m_curve_inc.reset();</a>
<a name="ln489">            m_curve_div.reset();</a>
<a name="ln490">        }</a>
<a name="ln491"> </a>
<a name="ln492">        void init(double x1, double y1, </a>
<a name="ln493">                  double x2, double y2, </a>
<a name="ln494">                  double x3, double y3)</a>
<a name="ln495">        {</a>
<a name="ln496">            if(m_approximation_method == curve_inc) </a>
<a name="ln497">            {</a>
<a name="ln498">                m_curve_inc.init(x1, y1, x2, y2, x3, y3);</a>
<a name="ln499">            }</a>
<a name="ln500">            else</a>
<a name="ln501">            {</a>
<a name="ln502">                m_curve_div.init(x1, y1, x2, y2, x3, y3);</a>
<a name="ln503">            }</a>
<a name="ln504">        }</a>
<a name="ln505"> </a>
<a name="ln506">        void approximation_method(curve_approximation_method_e v) </a>
<a name="ln507">        { </a>
<a name="ln508">            m_approximation_method = v; </a>
<a name="ln509">        }</a>
<a name="ln510"> </a>
<a name="ln511">        curve_approximation_method_e approximation_method() const </a>
<a name="ln512">        { </a>
<a name="ln513">            return m_approximation_method; </a>
<a name="ln514">        }</a>
<a name="ln515"> </a>
<a name="ln516">        void approximation_scale(double s) </a>
<a name="ln517">        { </a>
<a name="ln518">            m_curve_inc.approximation_scale(s);</a>
<a name="ln519">            m_curve_div.approximation_scale(s);</a>
<a name="ln520">        }</a>
<a name="ln521"> </a>
<a name="ln522">        double approximation_scale() const </a>
<a name="ln523">        { </a>
<a name="ln524">            return m_curve_inc.approximation_scale(); </a>
<a name="ln525">        }</a>
<a name="ln526"> </a>
<a name="ln527">        void angle_tolerance(double a) </a>
<a name="ln528">        { </a>
<a name="ln529">            m_curve_div.angle_tolerance(a); </a>
<a name="ln530">        }</a>
<a name="ln531"> </a>
<a name="ln532">        double angle_tolerance() const </a>
<a name="ln533">        { </a>
<a name="ln534">            return m_curve_div.angle_tolerance(); </a>
<a name="ln535">        }</a>
<a name="ln536"> </a>
<a name="ln537">        void cusp_limit(double v) </a>
<a name="ln538">        { </a>
<a name="ln539">            m_curve_div.cusp_limit(v); </a>
<a name="ln540">        }</a>
<a name="ln541"> </a>
<a name="ln542">        double cusp_limit() const </a>
<a name="ln543">        { </a>
<a name="ln544">            return m_curve_div.cusp_limit();  </a>
<a name="ln545">        }</a>
<a name="ln546"> </a>
<a name="ln547">        void rewind(unsigned path_id)</a>
<a name="ln548">        {</a>
<a name="ln549">            if(m_approximation_method == curve_inc) </a>
<a name="ln550">            {</a>
<a name="ln551">                m_curve_inc.rewind(path_id);</a>
<a name="ln552">            }</a>
<a name="ln553">            else</a>
<a name="ln554">            {</a>
<a name="ln555">                m_curve_div.rewind(path_id);</a>
<a name="ln556">            }</a>
<a name="ln557">        }</a>
<a name="ln558"> </a>
<a name="ln559">        unsigned vertex(double* x, double* y)</a>
<a name="ln560">        {</a>
<a name="ln561">            if(m_approximation_method == curve_inc) </a>
<a name="ln562">            {</a>
<a name="ln563">                return m_curve_inc.vertex(x, y);</a>
<a name="ln564">            }</a>
<a name="ln565">            return m_curve_div.vertex(x, y);</a>
<a name="ln566">        }</a>
<a name="ln567"> </a>
<a name="ln568">    private:</a>
<a name="ln569">        curve3_inc m_curve_inc;</a>
<a name="ln570">        curve3_div m_curve_div;</a>
<a name="ln571">        curve_approximation_method_e m_approximation_method;</a>
<a name="ln572">    };</a>
<a name="ln573"> </a>
<a name="ln574"> </a>
<a name="ln575"> </a>
<a name="ln576"> </a>
<a name="ln577"> </a>
<a name="ln578">    //-----------------------------------------------------------------curve4</a>
<a name="ln579">    class curve4</a>
<a name="ln580">    {</a>
<a name="ln581">    public:</a>
<a name="ln582">        curve4() : m_approximation_method(curve_div) {}</a>
<a name="ln583">        curve4(double x1, double y1, </a>
<a name="ln584">               double x2, double y2, </a>
<a name="ln585">               double x3, double y3,</a>
<a name="ln586">               double x4, double y4) : </a>
<a name="ln587">            m_approximation_method(curve_div)</a>
<a name="ln588">        { </a>
<a name="ln589">            init(x1, y1, x2, y2, x3, y3, x4, y4);</a>
<a name="ln590">        }</a>
<a name="ln591"> </a>
<a name="ln592">        curve4(const curve4_points&amp; cp) :</a>
<a name="ln593">            m_approximation_method(curve_div)</a>
<a name="ln594">        { </a>
<a name="ln595">            init(cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);</a>
<a name="ln596">        }</a>
<a name="ln597"> </a>
<a name="ln598">        void reset() </a>
<a name="ln599">        { </a>
<a name="ln600">            m_curve_inc.reset();</a>
<a name="ln601">            m_curve_div.reset();</a>
<a name="ln602">        }</a>
<a name="ln603"> </a>
<a name="ln604">        void init(double x1, double y1, </a>
<a name="ln605">                  double x2, double y2, </a>
<a name="ln606">                  double x3, double y3,</a>
<a name="ln607">                  double x4, double y4)</a>
<a name="ln608">        {</a>
<a name="ln609">            if(m_approximation_method == curve_inc) </a>
<a name="ln610">            {</a>
<a name="ln611">                m_curve_inc.init(x1, y1, x2, y2, x3, y3, x4, y4);</a>
<a name="ln612">            }</a>
<a name="ln613">            else</a>
<a name="ln614">            {</a>
<a name="ln615">                m_curve_div.init(x1, y1, x2, y2, x3, y3, x4, y4);</a>
<a name="ln616">            }</a>
<a name="ln617">        }</a>
<a name="ln618"> </a>
<a name="ln619">        void init(const curve4_points&amp; cp)</a>
<a name="ln620">        {</a>
<a name="ln621">            init(cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);</a>
<a name="ln622">        }</a>
<a name="ln623"> </a>
<a name="ln624">        void approximation_method(curve_approximation_method_e v) </a>
<a name="ln625">        { </a>
<a name="ln626">            m_approximation_method = v; </a>
<a name="ln627">        }</a>
<a name="ln628"> </a>
<a name="ln629">        curve_approximation_method_e approximation_method() const </a>
<a name="ln630">        { </a>
<a name="ln631">            return m_approximation_method; </a>
<a name="ln632">        }</a>
<a name="ln633"> </a>
<a name="ln634">        void approximation_scale(double s) </a>
<a name="ln635">        { </a>
<a name="ln636">            m_curve_inc.approximation_scale(s);</a>
<a name="ln637">            m_curve_div.approximation_scale(s);</a>
<a name="ln638">        }</a>
<a name="ln639">        double approximation_scale() const { return m_curve_inc.approximation_scale(); }</a>
<a name="ln640"> </a>
<a name="ln641">        void angle_tolerance(double v) </a>
<a name="ln642">        { </a>
<a name="ln643">            m_curve_div.angle_tolerance(v); </a>
<a name="ln644">        }</a>
<a name="ln645"> </a>
<a name="ln646">        double angle_tolerance() const </a>
<a name="ln647">        { </a>
<a name="ln648">            return m_curve_div.angle_tolerance();  </a>
<a name="ln649">        }</a>
<a name="ln650"> </a>
<a name="ln651">        void cusp_limit(double v) </a>
<a name="ln652">        { </a>
<a name="ln653">            m_curve_div.cusp_limit(v); </a>
<a name="ln654">        }</a>
<a name="ln655"> </a>
<a name="ln656">        double cusp_limit() const </a>
<a name="ln657">        { </a>
<a name="ln658">            return m_curve_div.cusp_limit();  </a>
<a name="ln659">        }</a>
<a name="ln660"> </a>
<a name="ln661">        void rewind(unsigned path_id)</a>
<a name="ln662">        {</a>
<a name="ln663">            if(m_approximation_method == curve_inc) </a>
<a name="ln664">            {</a>
<a name="ln665">                m_curve_inc.rewind(path_id);</a>
<a name="ln666">            }</a>
<a name="ln667">            else</a>
<a name="ln668">            {</a>
<a name="ln669">                m_curve_div.rewind(path_id);</a>
<a name="ln670">            }</a>
<a name="ln671">        }</a>
<a name="ln672"> </a>
<a name="ln673">        unsigned vertex(double* x, double* y)</a>
<a name="ln674">        {</a>
<a name="ln675">            if(m_approximation_method == curve_inc) </a>
<a name="ln676">            {</a>
<a name="ln677">                return m_curve_inc.vertex(x, y);</a>
<a name="ln678">            }</a>
<a name="ln679">            return m_curve_div.vertex(x, y);</a>
<a name="ln680">        }</a>
<a name="ln681"> </a>
<a name="ln682">    private:</a>
<a name="ln683">        curve4_inc m_curve_inc;</a>
<a name="ln684">        curve4_div m_curve_div;</a>
<a name="ln685">        curve_approximation_method_e m_approximation_method;</a>
<a name="ln686">    };</a>
<a name="ln687"> </a>
<a name="ln688"> </a>
<a name="ln689"> </a>
<a name="ln690"> </a>
<a name="ln691">}</a>
<a name="ln692"> </a>
<a name="ln693">#endif</a>

</code></pre>
<div class="balloon" rel="377"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: m_distance_tolerance_square.</p></div>
<div class="balloon" rel="97"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: m_distance_tolerance_square.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
