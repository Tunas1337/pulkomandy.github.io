
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>DavicomDevice.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> *	Davicom DM9601 USB 1.1 Ethernet Driver.</a>
<a name="ln3"> *	Copyright (c) 2008, 2011 Siarzhuk Zharski &lt;imker@gmx.li&gt;</a>
<a name="ln4"> *	Copyright (c) 2009 Adrien Destugues &lt;pulkomandy@gmail.com&gt;</a>
<a name="ln5"> *	Distributed under the terms of the MIT license.</a>
<a name="ln6"> *</a>
<a name="ln7"> *	Heavily based on code of the</a>
<a name="ln8"> *	Driver for USB Ethernet Control Model devices</a>
<a name="ln9"> *	Copyright (C) 2008 Michael Lotz &lt;mmlr@mlotz.ch&gt;</a>
<a name="ln10"> *	Distributed under the terms of the MIT license.</a>
<a name="ln11"> */</a>
<a name="ln12"> </a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;DavicomDevice.h&quot;</a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;stdio.h&gt;</a>
<a name="ln17">#include &lt;net/if_media.h&gt;</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;Driver.h&quot;</a>
<a name="ln20">#include &quot;Settings.h&quot;</a>
<a name="ln21"> </a>
<a name="ln22"> </a>
<a name="ln23">const int kFrameSize = 1522;</a>
<a name="ln24"> </a>
<a name="ln25">enum VendorRequests {</a>
<a name="ln26">	ReqReadRegister			= 0,</a>
<a name="ln27">	ReqWriteRegister		= 1,</a>
<a name="ln28">	ReqWriteRegisterByte	= 3,</a>
<a name="ln29">};</a>
<a name="ln30"> </a>
<a name="ln31"> </a>
<a name="ln32">enum DM9601Registers {</a>
<a name="ln33">	RegNCR	= 0x00,	// Network Control Register</a>
<a name="ln34">		NCRExtPHY	= 0x80,	// Select External PHY</a>
<a name="ln35">		NCRFullDX	= 0x08,	// Full duplex</a>
<a name="ln36">		NCRLoopback	= 0x06,	// Internal PHY analog loopback</a>
<a name="ln37"> </a>
<a name="ln38">	RegNSR	= 0x01,	// Network Status Register</a>
<a name="ln39">		NSRSpeed10	= 0x80,	// 0 = 100MBps, 1 = 10MBps (internal PHY)</a>
<a name="ln40">		NSRLinkUp	= 0x40,	// 1 = link up (internal PHY)</a>
<a name="ln41">		NSRTXFull	= 0x10,	// TX FIFO full</a>
<a name="ln42">		NSRRXOver	= 0x08,	// RX FIFO overflow</a>
<a name="ln43"> </a>
<a name="ln44">	RegRCR	= 0x05,	// RX Control Register</a>
<a name="ln45">		RCRDiscardLong	= 0x20,	// Discard long packet (over 1522 bytes)</a>
<a name="ln46">		RCRDiscardCRC	= 0x10,	// Discard CRC error packet</a>
<a name="ln47">		RCRAllMulticast	= 0x08,	// Pass all multicast</a>
<a name="ln48">		RCRPromiscuous	= 0x02,	// Promiscuous</a>
<a name="ln49">		RCRRXEnable		= 0x01,	// RX enable</a>
<a name="ln50"> </a>
<a name="ln51">	RegEPCR	= 0x0b,	// EEPROM &amp; PHY Control Register</a>
<a name="ln52">		EPCROpSelect	= 0x08,	// EEPROM or PHY Operation Select</a>
<a name="ln53">		EPCRRegRead		= 0x04,	// EEPROM or PHY Register Read Command</a>
<a name="ln54">		EPCRRegWrite	= 0x02,	// EEPROM or PHY Register Write Command</a>
<a name="ln55"> </a>
<a name="ln56">	RegEPAR	= 0x0c,	// EEPROM &amp; PHY Address Register</a>
<a name="ln57">		EPARIntPHY		= 0x40,	// [7:6] force to 01 if Internal PHY is selected</a>
<a name="ln58">		EPARMask		= 0x1f,	// mask [0:5]</a>
<a name="ln59"> </a>
<a name="ln60">	RegEPDRL = 0x0d, // EEPROM &amp; PHY Low Byte Data Register</a>
<a name="ln61"> </a>
<a name="ln62">	RegEPDRH = 0x0e, // EEPROM &amp; PHY Low Byte Data Register</a>
<a name="ln63"> </a>
<a name="ln64">	RegPAR	= 0x10,	// [0x10 - 0x15] Physical Address Register</a>
<a name="ln65">	</a>
<a name="ln66">	RegMAR	= 0x16,	// [0x16 - 0x1d] Multicast Address Register</a>
<a name="ln67"> </a>
<a name="ln68">	RegGPCR	= 0x1E,	// General Purpose Control Register</a>
<a name="ln69">		GPCRPowerDown	= 0x01,	// [0:6] Define in/out direction of GPCR</a>
<a name="ln70">								// GPIO0 - is output for Power Down function</a>
<a name="ln71"> </a>
<a name="ln72">	RegGPR	= 0x1F,	// General Purpose Register</a>
<a name="ln73">		GPRPowerDownInPHY = 0x01,	// Power down Internal PHY</a>
<a name="ln74"> </a>
<a name="ln75">	RegUSBC	= 0xf4, // USB Control Register</a>
<a name="ln76">		USBCIntAck		= 0x20,	// ACK with 8-bytes of data on interrupt EP</a>
<a name="ln77">		USBCIntNAck		= 0x10,	// Supress ACK on interrupt EP</a>
<a name="ln78"> </a>
<a name="ln79">};</a>
<a name="ln80"> </a>
<a name="ln81"> </a>
<a name="ln82">enum MIIRegisters {</a>
<a name="ln83">	RegBMCR	= 0x00,</a>
<a name="ln84">		BMCRIsolate	= 0x0400,</a>
<a name="ln85">		BMCRReset	= 0x8000,</a>
<a name="ln86"> </a>
<a name="ln87">	RegBMSR	= 0x01,</a>
<a name="ln88">	RegPHYID1	= 0x02,</a>
<a name="ln89">	RegPHYID2	= 0x03,</a>
<a name="ln90">};</a>
<a name="ln91"> </a>
<a name="ln92">#define MII_OUI(id1, id2)       (((id1) &lt;&lt; 6) | ((id2) &gt;&gt; 10))</a>
<a name="ln93">#define MII_MODEL(id2)          (((id2) &amp; 0x03f0) &gt;&gt; 4)</a>
<a name="ln94">#define MII_REV(id2)             ((id2) &amp; 0x000f)</a>
<a name="ln95"> </a>
<a name="ln96"> </a>
<a name="ln97">DavicomDevice::DavicomDevice(usb_device device, DeviceInfo&amp; deviceInfo)</a>
<a name="ln98">	:	fDevice(device),</a>
<a name="ln99">		fStatus(B_ERROR),</a>
<a name="ln100">		fOpen(false),</a>
<a name="ln101">		fRemoved(false),</a>
<a name="ln102">		fHasConnection(false),</a>
<a name="ln103">		fTXBufferFull(false),</a>
<a name="ln104">		fNonBlocking(false),</a>
<a name="ln105">		fInsideNotify(0),</a>
<a name="ln106">		fNotifyEndpoint(0),</a>
<a name="ln107">		fReadEndpoint(0),</a>
<a name="ln108">		fWriteEndpoint(0),</a>
<a name="ln109">		fMaxTXPacketSize(0),</a>
<a name="ln110">		fActualLengthRead(0),</a>
<a name="ln111">		fActualLengthWrite(0),</a>
<a name="ln112">		fStatusRead(0),</a>
<a name="ln113">		fStatusWrite(0),</a>
<a name="ln114">		fNotifyReadSem(-1),</a>
<a name="ln115">		fNotifyWriteSem(-1),</a>
<a name="ln116">		fLinkStateChangeSem(-1),</a>
<a name="ln117">		fNotifyData(NULL)</a>
<a name="ln118">{</a>
<a name="ln119">	fDeviceInfo = deviceInfo;</a>
<a name="ln120"> </a>
<a name="ln121">	memset(&amp;fMACAddress, 0, sizeof(fMACAddress));</a>
<a name="ln122"> </a>
<a name="ln123">	fNotifyReadSem = create_sem(0, DRIVER_NAME&quot;_notify_read&quot;);</a>
<a name="ln124">	if (fNotifyReadSem &lt; B_OK) {</a>
<a name="ln125">		TRACE_ALWAYS(&quot;Error of creating read notify semaphore:%#010x\n&quot;,</a>
<a name="ln126">															fNotifyReadSem);</a>
<a name="ln127">		return;</a>
<a name="ln128">	}</a>
<a name="ln129"> </a>
<a name="ln130">	fNotifyWriteSem = create_sem(0, DRIVER_NAME&quot;_notify_write&quot;);</a>
<a name="ln131">	if (fNotifyWriteSem &lt; B_OK) {</a>
<a name="ln132">		TRACE_ALWAYS(&quot;Error of creating write notify semaphore:%#010x\n&quot;,</a>
<a name="ln133">															fNotifyWriteSem);</a>
<a name="ln134">		return;</a>
<a name="ln135">	}</a>
<a name="ln136"> </a>
<a name="ln137">	fNotifyData = new DM9601NotifyData();</a>
<a name="ln138">	if (fNotifyData == NULL) {</a>
<a name="ln139">		TRACE_ALWAYS(&quot;Error allocating notify buffer\n&quot;);</a>
<a name="ln140">		return;</a>
<a name="ln141">	}</a>
<a name="ln142"> </a>
<a name="ln143">	if (_SetupEndpoints() != B_OK) {</a>
<a name="ln144">		return;</a>
<a name="ln145">	}</a>
<a name="ln146"> </a>
<a name="ln147">	_InitMII();</a>
<a name="ln148"> </a>
<a name="ln149">	fStatus = B_OK;</a>
<a name="ln150">	TRACE(&quot;Created!\n&quot;);</a>
<a name="ln151">}</a>
<a name="ln152"> </a>
<a name="ln153"> </a>
<a name="ln154">DavicomDevice::~DavicomDevice()</a>
<a name="ln155">{</a>
<a name="ln156">	if (fNotifyReadSem &gt;= B_OK)</a>
<a name="ln157">		delete_sem(fNotifyReadSem);</a>
<a name="ln158">	if (fNotifyWriteSem &gt;= B_OK)</a>
<a name="ln159">		delete_sem(fNotifyWriteSem);</a>
<a name="ln160"> </a>
<a name="ln161">	if (!fRemoved) // ???</a>
<a name="ln162">		gUSBModule-&gt;cancel_queued_transfers(fNotifyEndpoint);</a>
<a name="ln163"> </a>
<a name="ln164">	delete fNotifyData;</a>
<a name="ln165">	TRACE(&quot;Deleted!\n&quot;);</a>
<a name="ln166">}</a>
<a name="ln167"> </a>
<a name="ln168"> </a>
<a name="ln169">status_t</a>
<a name="ln170">DavicomDevice::Open(uint32 flags)</a>
<a name="ln171">{</a>
<a name="ln172">	if (fOpen)</a>
<a name="ln173">		return B_BUSY;</a>
<a name="ln174">	if (fRemoved)</a>
<a name="ln175">		return B_ERROR;</a>
<a name="ln176"> </a>
<a name="ln177">	status_t result = _StartDevice();</a>
<a name="ln178">	if (result != B_OK) {</a>
<a name="ln179">		return result;</a>
<a name="ln180">	}</a>
<a name="ln181"> </a>
<a name="ln182">	// setup state notifications</a>
<a name="ln183">	result = gUSBModule-&gt;queue_interrupt(fNotifyEndpoint, fNotifyData,</a>
<a name="ln184">		sizeof(DM9601NotifyData), _NotifyCallback, this);</a>
<a name="ln185">	if (result != B_OK) {</a>
<a name="ln186">		TRACE_ALWAYS(&quot;Error of requesting notify interrupt:%#010x\n&quot;, result);</a>
<a name="ln187">		return result;</a>
<a name="ln188">	}</a>
<a name="ln189"> </a>
<a name="ln190">	result = _EnableInterrupts(true);</a>
<a name="ln191"> </a>
<a name="ln192">	fNonBlocking = (flags &amp; O_NONBLOCK) == O_NONBLOCK;</a>
<a name="ln193">	fOpen = true;</a>
<a name="ln194">	TRACE(&quot;Opened: %#010x!\n&quot;, result);</a>
<a name="ln195">	return result;</a>
<a name="ln196">}</a>
<a name="ln197"> </a>
<a name="ln198"> </a>
<a name="ln199">status_t</a>
<a name="ln200">DavicomDevice::Close()</a>
<a name="ln201">{</a>
<a name="ln202">	if (fRemoved) {</a>
<a name="ln203">		fOpen = false;</a>
<a name="ln204">		return B_OK;</a>
<a name="ln205">	}</a>
<a name="ln206"> </a>
<a name="ln207">	_EnableInterrupts(false);</a>
<a name="ln208"> </a>
<a name="ln209">	// wait until possible notification handling finished...</a>
<a name="ln210">	while (atomic_add(&amp;fInsideNotify, 0) != 0)</a>
<a name="ln211">		snooze(100);</a>
<a name="ln212">	gUSBModule-&gt;cancel_queued_transfers(fNotifyEndpoint);</a>
<a name="ln213">	gUSBModule-&gt;cancel_queued_transfers(fReadEndpoint);</a>
<a name="ln214">	gUSBModule-&gt;cancel_queued_transfers(fWriteEndpoint);</a>
<a name="ln215"> </a>
<a name="ln216">	fOpen = false;</a>
<a name="ln217"> </a>
<a name="ln218">	status_t result = _StopDevice();</a>
<a name="ln219">	TRACE(&quot;Closed: %#010x!\n&quot;, result);</a>
<a name="ln220">	return result;</a>
<a name="ln221">}</a>
<a name="ln222"> </a>
<a name="ln223"> </a>
<a name="ln224">status_t</a>
<a name="ln225">DavicomDevice::Free()</a>
<a name="ln226">{</a>
<a name="ln227">	TRACE(&quot;Freed!\n&quot;);</a>
<a name="ln228">	return B_OK;</a>
<a name="ln229">}</a>
<a name="ln230"> </a>
<a name="ln231"> </a>
<a name="ln232">status_t</a>
<a name="ln233">DavicomDevice::Read(uint8 *buffer, size_t *numBytes)</a>
<a name="ln234">{</a>
<a name="ln235">	size_t numBytesToRead = *numBytes;</a>
<a name="ln236">	*numBytes = 0;</a>
<a name="ln237"> </a>
<a name="ln238">	if (fRemoved) {</a>
<a name="ln239">		TRACE_ALWAYS(&quot;Error of receiving %d bytes from removed device.\n&quot;,</a>
<a name="ln240">			numBytesToRead);</a>
<a name="ln241">		return B_DEVICE_NOT_FOUND;</a>
<a name="ln242">	}</a>
<a name="ln243"> </a>
<a name="ln244">	TRACE_RX(&quot;Request %d bytes.\n&quot;, numBytesToRead);</a>
<a name="ln245"> </a>
<a name="ln246">	struct _RXHeader {</a>
<a name="ln247">		uint	FOE	:1;</a>
<a name="ln248">		uint	CE	:1;</a>
<a name="ln249">		uint	LE	:1;</a>
<a name="ln250">		uint	PLE	:1;</a>
<a name="ln251">		uint	RWTO:1;</a>
<a name="ln252">		uint	LCS	:1;</a>
<a name="ln253">		uint	MF	:1;</a>
<a name="ln254">		uint	RF	:1;</a>
<a name="ln255">		uint	countLow	:8;</a>
<a name="ln256">		uint	countHigh	:8;</a>
<a name="ln257"> </a>
<a name="ln258">		uint8	Errors() { return 0xbf &amp; *(uint8*)this; }</a>
<a name="ln259">	} __attribute__((__packed__));</a>
<a name="ln260"> </a>
<a name="ln261">	_RXHeader header = { 0 };</a>
<a name="ln262"> </a>
<a name="ln263">	iovec rxData[] = {</a>
<a name="ln264">		{ &amp;header, sizeof(header) },</a>
<a name="ln265">		{ buffer,  numBytesToRead }</a>
<a name="ln266">	};</a>
<a name="ln267"> </a>
<a name="ln268">	status_t result = gUSBModule-&gt;queue_bulk_v(fReadEndpoint,</a>
<a name="ln269">		rxData, 2, _ReadCallback, this);</a>
<a name="ln270">	if (result != B_OK) {</a>
<a name="ln271">		TRACE_ALWAYS(&quot;Error of queue_bulk_v request:%#010x\n&quot;, result);</a>
<a name="ln272">		return result;</a>
<a name="ln273">	}</a>
<a name="ln274"> </a>
<a name="ln275">	uint32 flags = B_CAN_INTERRUPT | (fNonBlocking ? B_TIMEOUT : 0);</a>
<a name="ln276">	result = acquire_sem_etc(fNotifyReadSem, 1, flags, 0);</a>
<a name="ln277">	if (result &lt; B_OK) {</a>
<a name="ln278">		TRACE_ALWAYS(&quot;Error of acquiring notify semaphore:%#010x.\n&quot;, result);</a>
<a name="ln279">		return result;</a>
<a name="ln280">	}</a>
<a name="ln281"> </a>
<a name="ln282">	if (fStatusRead != B_OK &amp;&amp; fStatusRead != B_CANCELED &amp;&amp; !fRemoved) {</a>
<a name="ln283">		TRACE_ALWAYS(&quot;Device status error:%#010x\n&quot;, fStatusRead);</a>
<a name="ln284">		return fStatusRead;</a>
<a name="ln285">	}</a>
<a name="ln286"> </a>
<a name="ln287">	if (fActualLengthRead &lt; sizeof(_RXHeader)) {</a>
<a name="ln288">		TRACE_ALWAYS(&quot;Error: no place for RXHeader: only %d of %d bytes.\n&quot;,</a>
<a name="ln289">			fActualLengthRead, sizeof(_RXHeader));</a>
<a name="ln290">		return B_ERROR;</a>
<a name="ln291">	}</a>
<a name="ln292"> </a>
<a name="ln293">	if (header.Errors() != 0) {</a>
<a name="ln294">		TRACE_ALWAYS(&quot;RX header errors %#04x detected!\n&quot;, header.Errors());</a>
<a name="ln295">	}</a>
<a name="ln296"> </a>
<a name="ln297">	TRACE_STATS(&quot;FOE:%d CE:%d LE:%d PLE:%d rwTO:%d LCS:%d MF:%d RF:%d\n&quot;,</a>
<a name="ln298">			header.FOE, header.CE, header.LE, header.PLE,</a>
<a name="ln299">			header.RWTO, header.LCS, header.MF, header.RF);</a>
<a name="ln300"> </a>
<a name="ln301">	*numBytes = header.countLow | ( header.countHigh &lt;&lt; 8 );</a>
<a name="ln302"> </a>
<a name="ln303">	if (fActualLengthRead - sizeof(_RXHeader) &gt; *numBytes) {</a>
<a name="ln304">		TRACE_ALWAYS(&quot;MISMATCH of the frame length: hdr %d; received:%d\n&quot;,</a>
<a name="ln305">			*numBytes, fActualLengthRead - sizeof(_RXHeader));</a>
<a name="ln306">	}</a>
<a name="ln307"> </a>
<a name="ln308">	TRACE_RX(&quot;Read %d bytes.\n&quot;, *numBytes);</a>
<a name="ln309">	return B_OK;</a>
<a name="ln310">}</a>
<a name="ln311"> </a>
<a name="ln312"> </a>
<a name="ln313">status_t</a>
<a name="ln314">DavicomDevice::Write(const uint8 *buffer, size_t *numBytes)</a>
<a name="ln315">{</a>
<a name="ln316">	size_t numBytesToWrite = *numBytes;</a>
<a name="ln317">	*numBytes = 0;</a>
<a name="ln318"> </a>
<a name="ln319">	if (fRemoved) {</a>
<a name="ln320">		TRACE_ALWAYS(&quot;Error of writing %d bytes to removed device.\n&quot;,</a>
<a name="ln321">			numBytesToWrite);</a>
<a name="ln322">		return B_DEVICE_NOT_FOUND;</a>
<a name="ln323">	}</a>
<a name="ln324"> </a>
<a name="ln325">	if (!fHasConnection) {</a>
<a name="ln326">		TRACE_ALWAYS(&quot;Error of writing %d bytes to device while down.\n&quot;,</a>
<a name="ln327">			numBytesToWrite);</a>
<a name="ln328">		return B_ERROR;</a>
<a name="ln329">	}</a>
<a name="ln330"> </a>
<a name="ln331">	if (fTXBufferFull) {</a>
<a name="ln332">		TRACE_ALWAYS(&quot;Error of writing %d bytes to device: TX buffer full.\n&quot;,</a>
<a name="ln333">			numBytesToWrite);</a>
<a name="ln334">		return B_ERROR;</a>
<a name="ln335">	}</a>
<a name="ln336"> </a>
<a name="ln337">	TRACE_TX(&quot;Write %d bytes.\n&quot;, numBytesToWrite);</a>
<a name="ln338"> </a>
<a name="ln339">	// additional padding byte must be transmitted in case data size</a>
<a name="ln340">	// to be send is multiple of pipe's max packet size</a>
<a name="ln341">	uint16 length = numBytesToWrite;</a>
<a name="ln342">	size_t count = 2;</a>
<a name="ln343">	if (((numBytesToWrite + 2) % fMaxTXPacketSize) == 0) {</a>
<a name="ln344">		length++;</a>
<a name="ln345">		count++;</a>
<a name="ln346">	}</a>
<a name="ln347"> </a>
<a name="ln348">	struct _TXHeader {</a>
<a name="ln349">		uint8	countLow;</a>
<a name="ln350">		uint8	countHigh;</a>
<a name="ln351">	} __attribute__((__packed__));</a>
<a name="ln352"> </a>
<a name="ln353">	_TXHeader header = { (uint8)(length &amp; 0xff),</a>
<a name="ln354">		(uint8)((length &gt;&gt; 8) &amp; 0xff) };</a>
<a name="ln355"> </a>
<a name="ln356">	uint8 padding = 0;</a>
<a name="ln357"> </a>
<a name="ln358">	iovec txData[] = {</a>
<a name="ln359">		{ &amp;header, sizeof(_TXHeader) },</a>
<a name="ln360">		{ (uint8*)buffer, numBytesToWrite },</a>
<a name="ln361">		{ &amp;padding, 1 }</a>
<a name="ln362">	};</a>
<a name="ln363"> </a>
<a name="ln364">	status_t result = gUSBModule-&gt;queue_bulk_v(fWriteEndpoint,</a>
<a name="ln365">		txData, count, _WriteCallback, this);</a>
<a name="ln366">	if (result != B_OK) {</a>
<a name="ln367">		TRACE_ALWAYS(&quot;Error of queue_bulk_v request:%#010x\n&quot;, result);</a>
<a name="ln368">		return result;</a>
<a name="ln369">	}</a>
<a name="ln370"> </a>
<a name="ln371">	result = acquire_sem_etc(fNotifyWriteSem, 1, B_CAN_INTERRUPT, 0);</a>
<a name="ln372"> </a>
<a name="ln373">	if (result &lt; B_OK) {</a>
<a name="ln374">		TRACE_ALWAYS(&quot;Error of acquiring notify semaphore:%#010x.\n&quot;, result);</a>
<a name="ln375">		return result;</a>
<a name="ln376">	}</a>
<a name="ln377"> </a>
<a name="ln378">	if (fStatusWrite != B_OK &amp;&amp; fStatusWrite != B_CANCELED &amp;&amp; !fRemoved) {</a>
<a name="ln379">		TRACE_ALWAYS(&quot;Device status error:%#010x\n&quot;, fStatusWrite);</a>
<a name="ln380">		return fStatusWrite;</a>
<a name="ln381">	}</a>
<a name="ln382"> </a>
<a name="ln383">	*numBytes = fActualLengthWrite - sizeof(_TXHeader);</a>
<a name="ln384"> </a>
<a name="ln385">	TRACE_TX(&quot;Written %d bytes.\n&quot;, *numBytes);</a>
<a name="ln386">	return B_OK;</a>
<a name="ln387">}</a>
<a name="ln388"> </a>
<a name="ln389"> </a>
<a name="ln390">status_t</a>
<a name="ln391">DavicomDevice::Control(uint32 op, void *buffer, size_t length)</a>
<a name="ln392">{</a>
<a name="ln393">	switch (op) {</a>
<a name="ln394">		case ETHER_INIT:</a>
<a name="ln395">			return B_OK;</a>
<a name="ln396"> </a>
<a name="ln397">		case ETHER_GETADDR:</a>
<a name="ln398">			memcpy(buffer, &amp;fMACAddress, sizeof(fMACAddress));</a>
<a name="ln399">			return B_OK;</a>
<a name="ln400"> </a>
<a name="ln401">		case ETHER_GETFRAMESIZE:</a>
<a name="ln402">			*(uint32 *)buffer = kFrameSize;</a>
<a name="ln403">			return B_OK;</a>
<a name="ln404"> </a>
<a name="ln405">		case ETHER_NONBLOCK:</a>
<a name="ln406">			TRACE(&quot;ETHER_NONBLOCK\n&quot;);</a>
<a name="ln407">			fNonBlocking = *((uint8*)buffer);</a>
<a name="ln408">			return B_OK;</a>
<a name="ln409"> </a>
<a name="ln410">		case ETHER_SETPROMISC:</a>
<a name="ln411">			TRACE(&quot;ETHER_SETPROMISC\n&quot;);</a>
<a name="ln412">			return _SetPromiscuousMode(*((uint8*)buffer));</a>
<a name="ln413"> </a>
<a name="ln414">		case ETHER_ADDMULTI:</a>
<a name="ln415">			TRACE(&quot;ETHER_ADDMULTI\n&quot;);</a>
<a name="ln416">			return _ModifyMulticastTable(true, (ether_address_t*)buffer);</a>
<a name="ln417"> </a>
<a name="ln418">		case ETHER_REMMULTI:</a>
<a name="ln419">			TRACE(&quot;ETHER_REMMULTI\n&quot;);</a>
<a name="ln420">			return _ModifyMulticastTable(false, (ether_address_t*)buffer);</a>
<a name="ln421"> </a>
<a name="ln422">		case ETHER_SET_LINK_STATE_SEM:</a>
<a name="ln423">			fLinkStateChangeSem = *(sem_id *)buffer;</a>
<a name="ln424">			return B_OK;</a>
<a name="ln425"> </a>
<a name="ln426">		case ETHER_GET_LINK_STATE:</a>
<a name="ln427">			return _GetLinkState((ether_link_state *)buffer);</a>
<a name="ln428"> </a>
<a name="ln429">		default:</a>
<a name="ln430">			TRACE_ALWAYS(&quot;Unhandled IOCTL catched: %#010x\n&quot;, op);</a>
<a name="ln431">	}</a>
<a name="ln432"> </a>
<a name="ln433">	return B_DEV_INVALID_IOCTL;</a>
<a name="ln434">}</a>
<a name="ln435"> </a>
<a name="ln436"> </a>
<a name="ln437">void</a>
<a name="ln438">DavicomDevice::Removed()</a>
<a name="ln439">{</a>
<a name="ln440">	fRemoved = true;</a>
<a name="ln441">	fHasConnection = false;</a>
<a name="ln442"> </a>
<a name="ln443">	// the notify hook is different from the read and write hooks as it does</a>
<a name="ln444">	// itself schedule traffic (while the other hooks only release a semaphore</a>
<a name="ln445">	// to notify another thread which in turn safly checks for the removed</a>
<a name="ln446">	// case) - so we must ensure that we are not inside the notify hook anymore</a>
<a name="ln447">	// before returning, as we would otherwise violate the promise not to use</a>
<a name="ln448">	// any of the pipes after returning from the removed hook</a>
<a name="ln449">	while (atomic_add(&amp;fInsideNotify, 0) != 0)</a>
<a name="ln450">		snooze(100);</a>
<a name="ln451"> </a>
<a name="ln452">	gUSBModule-&gt;cancel_queued_transfers(fNotifyEndpoint);</a>
<a name="ln453">	gUSBModule-&gt;cancel_queued_transfers(fReadEndpoint);</a>
<a name="ln454">	gUSBModule-&gt;cancel_queued_transfers(fWriteEndpoint);</a>
<a name="ln455"> </a>
<a name="ln456">	if (fLinkStateChangeSem &gt;= B_OK)</a>
<a name="ln457">		release_sem_etc(fLinkStateChangeSem, 1, B_DO_NOT_RESCHEDULE);</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460"> </a>
<a name="ln461">status_t</a>
<a name="ln462">DavicomDevice::SetupDevice(bool deviceReplugged)</a>
<a name="ln463">{</a>
<a name="ln464">	ether_address address;</a>
<a name="ln465">	status_t result = _ReadMACAddress(&amp;address);</a>
<a name="ln466">	if (result != B_OK) {</a>
<a name="ln467">		TRACE_ALWAYS(&quot;Error reading MAC address:%#010x\n&quot;, result);</a>
<a name="ln468">		return result;</a>
<a name="ln469">	}</a>
<a name="ln470"> </a>
<a name="ln471">	TRACE(&quot;MAC address is:%02x:%02x:%02x:%02x:%02x:%02x\n&quot;,</a>
<a name="ln472">				address.ebyte[0], address.ebyte[1], address.ebyte[2],</a>
<a name="ln473">				address.ebyte[3], address.ebyte[4], address.ebyte[5]);</a>
<a name="ln474"> </a>
<a name="ln475">	if (deviceReplugged) {</a>
<a name="ln476">		// this might be the same device that was replugged - read the MAC</a>
<a name="ln477">		// address (which should be at the same index) to make sure</a>
<a name="ln478">		if (memcmp(&amp;address, &amp;fMACAddress, sizeof(address)) != 0) {</a>
<a name="ln479">			TRACE_ALWAYS(&quot;Cannot replace device with MAC address:&quot;</a>
<a name="ln480">				&quot;%02x:%02x:%02x:%02x:%02x:%02x\n&quot;,</a>
<a name="ln481">				fMACAddress.ebyte[0], fMACAddress.ebyte[1],</a>
<a name="ln482">				fMACAddress.ebyte[2], fMACAddress.ebyte[3],</a>
<a name="ln483">				fMACAddress.ebyte[4], fMACAddress.ebyte[5]);</a>
<a name="ln484">			return B_BAD_VALUE; // is not the same</a>
<a name="ln485">		}</a>
<a name="ln486">	} else</a>
<a name="ln487">		fMACAddress = address;</a>
<a name="ln488"> </a>
<a name="ln489">	return B_OK;</a>
<a name="ln490">}</a>
<a name="ln491"> </a>
<a name="ln492"> </a>
<a name="ln493">status_t</a>
<a name="ln494">DavicomDevice::CompareAndReattach(usb_device device)</a>
<a name="ln495">{</a>
<a name="ln496">	const usb_device_descriptor *deviceDescriptor</a>
<a name="ln497">		= gUSBModule-&gt;get_device_descriptor(device);</a>
<a name="ln498"> </a>
<a name="ln499">	if (deviceDescriptor == NULL) {</a>
<a name="ln500">		TRACE_ALWAYS(&quot;Error getting USB device descriptor.\n&quot;);</a>
<a name="ln501">		return B_ERROR;</a>
<a name="ln502">	}</a>
<a name="ln503"> </a>
<a name="ln504">	if (deviceDescriptor-&gt;vendor_id != fDeviceInfo.VendorId()</a>
<a name="ln505">		&amp;&amp; deviceDescriptor-&gt;product_id != fDeviceInfo.ProductId()) {</a>
<a name="ln506">		// this certainly isn't the same device</a>
<a name="ln507">		return B_BAD_VALUE;</a>
<a name="ln508">	}</a>
<a name="ln509"> </a>
<a name="ln510">	// this is the same device that was replugged - clear the removed state,</a>
<a name="ln511">	// re-setup the endpoints and transfers and open the device if it was</a>
<a name="ln512">	// previously opened</a>
<a name="ln513">	fDevice = device;</a>
<a name="ln514">	fRemoved = false;</a>
<a name="ln515">	status_t result = _SetupEndpoints();</a>
<a name="ln516">	if (result != B_OK) {</a>
<a name="ln517">		fRemoved = true;</a>
<a name="ln518">		return result;</a>
<a name="ln519">	}</a>
<a name="ln520"> </a>
<a name="ln521">	// we need to setup hardware on device replug</a>
<a name="ln522">	result = SetupDevice(true);</a>
<a name="ln523">	if (result != B_OK) {</a>
<a name="ln524">		return result;</a>
<a name="ln525">	}</a>
<a name="ln526"> </a>
<a name="ln527">	if (fOpen) {</a>
<a name="ln528">		fOpen = false;</a>
<a name="ln529">		result = Open(fNonBlocking ? O_NONBLOCK : 0);</a>
<a name="ln530">	}</a>
<a name="ln531"> </a>
<a name="ln532">	return result;</a>
<a name="ln533">}</a>
<a name="ln534"> </a>
<a name="ln535"> </a>
<a name="ln536">status_t</a>
<a name="ln537">DavicomDevice::_SetupEndpoints()</a>
<a name="ln538">{</a>
<a name="ln539">	const usb_configuration_info *config</a>
<a name="ln540">		= gUSBModule-&gt;get_nth_configuration(fDevice, 0);</a>
<a name="ln541"> </a>
<a name="ln542">	if (config == NULL) {</a>
<a name="ln543">		TRACE_ALWAYS(&quot;Error of getting USB device configuration.\n&quot;);</a>
<a name="ln544">		return B_ERROR;</a>
<a name="ln545">	}</a>
<a name="ln546"> </a>
<a name="ln547">	if (config-&gt;interface_count &lt;= 0) {</a>
<a name="ln548">		TRACE_ALWAYS(&quot;Error:no interfaces found in USB device configuration\n&quot;);</a>
<a name="ln549">		return B_ERROR;</a>
<a name="ln550">	}</a>
<a name="ln551"> </a>
<a name="ln552">	usb_interface_info *interface = config-&gt;interface[0].active;</a>
<a name="ln553">	if (interface == 0) {</a>
<a name="ln554">		TRACE_ALWAYS(&quot;Error:invalid active interface in &quot;</a>
<a name="ln555">												&quot;USB device configuration\n&quot;);</a>
<a name="ln556">		return B_ERROR;</a>
<a name="ln557">	}</a>
<a name="ln558"> </a>
<a name="ln559">	int notifyEndpoint = -1;</a>
<a name="ln560">	int readEndpoint   = -1;</a>
<a name="ln561">	int writeEndpoint  = -1;</a>
<a name="ln562"> </a>
<a name="ln563">	for (size_t ep = 0; ep &lt; interface-&gt;endpoint_count; ep++) {</a>
<a name="ln564">		usb_endpoint_descriptor *epd = interface-&gt;endpoint[ep].descr;</a>
<a name="ln565">		if ((epd-&gt;attributes &amp; USB_ENDPOINT_ATTR_MASK)</a>
<a name="ln566">				== USB_ENDPOINT_ATTR_INTERRUPT)</a>
<a name="ln567">		{</a>
<a name="ln568">			notifyEndpoint = ep;</a>
<a name="ln569">			continue;</a>
<a name="ln570">		}</a>
<a name="ln571"> </a>
<a name="ln572">		if ((epd-&gt;attributes &amp; USB_ENDPOINT_ATTR_MASK)</a>
<a name="ln573">				!= USB_ENDPOINT_ATTR_BULK)</a>
<a name="ln574">		{</a>
<a name="ln575">			TRACE_ALWAYS(&quot;Error: USB endpoint type %#04x is unknown.\n&quot;,</a>
<a name="ln576">					epd-&gt;attributes);</a>
<a name="ln577">			continue;</a>
<a name="ln578">		}</a>
<a name="ln579"> </a>
<a name="ln580">		if ((epd-&gt;endpoint_address &amp; USB_ENDPOINT_ADDR_DIR_IN)</a>
<a name="ln581">				== USB_ENDPOINT_ADDR_DIR_IN)</a>
<a name="ln582">		{</a>
<a name="ln583">			readEndpoint = ep;</a>
<a name="ln584">			continue;</a>
<a name="ln585">		}</a>
<a name="ln586"> </a>
<a name="ln587">		if ((epd-&gt;endpoint_address &amp; USB_ENDPOINT_ADDR_DIR_OUT)</a>
<a name="ln588">				== USB_ENDPOINT_ADDR_DIR_OUT)</a>
<a name="ln589">		{</a>
<a name="ln590">			writeEndpoint = ep;</a>
<a name="ln591">			continue;</a>
<a name="ln592">		}</a>
<a name="ln593">	}</a>
<a name="ln594"> </a>
<a name="ln595">	if (notifyEndpoint == -1 || readEndpoint == -1 || writeEndpoint == -1) {</a>
<a name="ln596">		TRACE_ALWAYS(&quot;Error: not all USB endpoints were found: notify:%d; &quot;</a>
<a name="ln597">			&quot;read:%d; write:%d\n&quot;, notifyEndpoint, readEndpoint, writeEndpoint);</a>
<a name="ln598">		return B_ERROR;</a>
<a name="ln599">	}</a>
<a name="ln600"> </a>
<a name="ln601">	gUSBModule-&gt;set_configuration(fDevice, config);</a>
<a name="ln602"> </a>
<a name="ln603">	fNotifyEndpoint = interface-&gt;endpoint[notifyEndpoint].handle;</a>
<a name="ln604">	fReadEndpoint   = interface-&gt;endpoint[readEndpoint  ].handle;</a>
<a name="ln605">	fWriteEndpoint  = interface-&gt;endpoint[writeEndpoint ].handle;</a>
<a name="ln606">	fMaxTXPacketSize = interface-&gt;endpoint[writeEndpoint].descr-&gt;max_packet_size;</a>
<a name="ln607"> </a>
<a name="ln608">	return B_OK;</a>
<a name="ln609">}</a>
<a name="ln610"> </a>
<a name="ln611"> </a>
<a name="ln612">status_t</a>
<a name="ln613">DavicomDevice::_ReadMACAddress(ether_address_t *address)</a>
<a name="ln614">{</a>
<a name="ln615">	status_t result = _ReadRegister(RegPAR,</a>
<a name="ln616">							sizeof(ether_address), (uint8*)address);</a>
<a name="ln617">	if (result != B_OK) {</a>
<a name="ln618">		TRACE_ALWAYS(&quot;Error of reading MAC address:%#010x\n&quot;, result);</a>
<a name="ln619">		return result;</a>
<a name="ln620">	}</a>
<a name="ln621"> </a>
<a name="ln622">	return B_OK;</a>
<a name="ln623">}</a>
<a name="ln624"> </a>
<a name="ln625"> </a>
<a name="ln626">status_t</a>
<a name="ln627">DavicomDevice::_StartDevice()</a>
<a name="ln628">{</a>
<a name="ln629">	uint8 control = 0;</a>
<a name="ln630"> </a>
<a name="ln631">	// disable loopback</a>
<a name="ln632">	status_t result = _ReadRegister(RegNCR, 1, &amp;control);</a>
<a name="ln633">	if (result != B_OK) {</a>
<a name="ln634">		TRACE_ALWAYS(&quot;Error reading NCR: %#010x.\n&quot;, result);</a>
<a name="ln635">		return result;</a>
<a name="ln636">	}</a>
<a name="ln637"> </a>
<a name="ln638">	if (control &amp; NCRExtPHY)</a>
<a name="ln639">		TRACE_ALWAYS(&quot;Device uses external PHY\n&quot;);</a>
<a name="ln640"> </a>
<a name="ln641">	control &amp;= ~NCRLoopback;</a>
<a name="ln642">	result = _Write1Register(RegNCR, control);</a>
<a name="ln643">	if (result != B_OK) {</a>
<a name="ln644">		TRACE_ALWAYS(&quot;Error writing %#02X to NCR: %#010x.\n&quot;, control, result);</a>
<a name="ln645">		return result;</a>
<a name="ln646">	}</a>
<a name="ln647"> </a>
<a name="ln648">	// Initialize RX control register, enable RX and activate multicast</a>
<a name="ln649">	result = _ReadRegister(RegRCR, 1, &amp;control);</a>
<a name="ln650">	if (result != B_OK) {</a>
<a name="ln651">		TRACE_ALWAYS(&quot;Error reading RCR: %#010x.\n&quot;, result);</a>
<a name="ln652">		return result;</a>
<a name="ln653">	}</a>
<a name="ln654"> </a>
<a name="ln655">	control &amp;= ~RCRPromiscuous;</a>
<a name="ln656">	control |= RCRDiscardLong | RCRDiscardCRC | RCRRXEnable | RCRAllMulticast;</a>
<a name="ln657">	result = _Write1Register(RegRCR, control);</a>
<a name="ln658">	if (result != B_OK) {</a>
<a name="ln659">		TRACE_ALWAYS(&quot;Error writing %#02X to RCR: %#010x.\n&quot;, control, result);</a>
<a name="ln660">		return result;</a>
<a name="ln661">	}</a>
<a name="ln662"> </a>
<a name="ln663">	// clear POWER_DOWN state of internal PHY</a>
<a name="ln664">	result = _ReadRegister(RegGPCR, 1, &amp;control);</a>
<a name="ln665">	if (result != B_OK) {</a>
<a name="ln666">		TRACE_ALWAYS(&quot;Error reading GPCR: %#010x.\n&quot;, result);</a>
<a name="ln667">		return result;</a>
<a name="ln668">	}</a>
<a name="ln669"> </a>
<a name="ln670">	control |= GPCRPowerDown;</a>
<a name="ln671">	result = _Write1Register(RegGPCR, control);</a>
<a name="ln672">	if (result != B_OK) {</a>
<a name="ln673">		TRACE_ALWAYS(&quot;Error writing %#02X to GPCR: %#010x.\n&quot;, control, result);</a>
<a name="ln674">		return result;</a>
<a name="ln675">	}</a>
<a name="ln676"> </a>
<a name="ln677">	result = _ReadRegister(RegGPR, 1, &amp;control);</a>
<a name="ln678">	if (result != B_OK) {</a>
<a name="ln679">		TRACE_ALWAYS(&quot;Error reading GPR: %#010x.\n&quot;, result);</a>
<a name="ln680">		return result;</a>
<a name="ln681">	}</a>
<a name="ln682"> </a>
<a name="ln683">	control &amp;= ~GPRPowerDownInPHY;</a>
<a name="ln684">	result = _Write1Register(RegGPR, control);</a>
<a name="ln685">	if (result != B_OK) {</a>
<a name="ln686">		TRACE_ALWAYS(&quot;Error writing %#02X to GPR: %#010x.\n&quot;, control, result);</a>
<a name="ln687">		return result;</a>
<a name="ln688">	}</a>
<a name="ln689"> </a>
<a name="ln690">	return B_OK;</a>
<a name="ln691">}</a>
<a name="ln692"> </a>
<a name="ln693"> </a>
<a name="ln694">status_t</a>
<a name="ln695">DavicomDevice::_StopDevice()</a>
<a name="ln696">{</a>
<a name="ln697">	uint8 control = 0;</a>
<a name="ln698"> </a>
<a name="ln699">	// disable RX</a>
<a name="ln700">	status_t result = _ReadRegister(RegRCR, 1, &amp;control);</a>
<a name="ln701">	if (result != B_OK) {</a>
<a name="ln702">		TRACE_ALWAYS(&quot;Error reading RCR: %#010x.\n&quot;, result);</a>
<a name="ln703">		return result;</a>
<a name="ln704">	}</a>
<a name="ln705"> </a>
<a name="ln706">	control &amp;= ~RCRRXEnable;</a>
<a name="ln707">	result = _Write1Register(RegRCR, control);</a>
<a name="ln708">	if (result != B_OK)</a>
<a name="ln709">		TRACE_ALWAYS(&quot;Error writing %#02X to RCR: %#010x.\n&quot;, control, result);</a>
<a name="ln710"> </a>
<a name="ln711">	return result;</a>
<a name="ln712">}</a>
<a name="ln713"> </a>
<a name="ln714"> </a>
<a name="ln715">status_t</a>
<a name="ln716">DavicomDevice::_SetPromiscuousMode(bool on)</a>
<a name="ln717">{</a>
<a name="ln718">	uint8 control = 0;</a>
<a name="ln719"> </a>
<a name="ln720">	status_t result = _ReadRegister(RegRCR, 1, &amp;control);</a>
<a name="ln721">	if (result != B_OK) {</a>
<a name="ln722">		TRACE_ALWAYS(&quot;Error reading RCR: %#010x.\n&quot;, result);</a>
<a name="ln723">		return result;</a>
<a name="ln724">	}</a>
<a name="ln725"> </a>
<a name="ln726">	if (on)</a>
<a name="ln727">		control |= RCRPromiscuous;</a>
<a name="ln728">	else</a>
<a name="ln729">		control &amp;= ~RCRPromiscuous;</a>
<a name="ln730"> </a>
<a name="ln731">	result = _Write1Register(RegRCR, control);</a>
<a name="ln732">	if (result != B_OK)</a>
<a name="ln733">		TRACE_ALWAYS(&quot;Error writing %#02X to RCR: %#010x.\n&quot;, control, result);</a>
<a name="ln734"> </a>
<a name="ln735">	return result;</a>
<a name="ln736">}</a>
<a name="ln737"> </a>
<a name="ln738"> </a>
<a name="ln739">uint32</a>
<a name="ln740">DavicomDevice::_EthernetCRC32(const uint8* buffer, size_t length)</a>
<a name="ln741">{</a>
<a name="ln742">	uint32 result = 0xffffffff;</a>
<a name="ln743">	for (size_t i = 0; i &lt; length; i++) {</a>
<a name="ln744">		uint8 data = *buffer++;</a>
<a name="ln745">		for (int bit = 0; bit &lt; 8; bit++, data &gt;&gt;= 1) {</a>
<a name="ln746">			uint32 carry = ((result &amp; 0x80000000) ? 1 : 0) ^ (data &amp; 0x01);</a>
<a name="ln747">			result &lt;&lt;= 1;</a>
<a name="ln748">			if (carry != 0)</a>
<a name="ln749">				result = (result ^ 0x04c11db6) | carry;</a>
<a name="ln750">		}</a>
<a name="ln751">	}</a>
<a name="ln752">	return result;</a>
<a name="ln753">}</a>
<a name="ln754"> </a>
<a name="ln755"> </a>
<a name="ln756">status_t</a>
<a name="ln757">DavicomDevice::_ModifyMulticastTable(bool join, ether_address_t *group)</a>
<a name="ln758">{</a>
<a name="ln759">	char groupName[6 * 3 + 1] = { 0 };</a>
<a name="ln760">	sprintf(groupName, &quot;%02x:%02x:%02x:%02x:%02x:%02x&quot;,</a>
<a name="ln761">		group-&gt;ebyte[0], group-&gt;ebyte[1], group-&gt;ebyte[2],</a>
<a name="ln762">		group-&gt;ebyte[3], group-&gt;ebyte[4], group-&gt;ebyte[5]);</a>
<a name="ln763">	TRACE(&quot;%s multicast group %s\n&quot;, join ? &quot;Joining&quot; : &quot;Leaving&quot;, groupName);</a>
<a name="ln764"> </a>
<a name="ln765">	uint32 hash = _EthernetCRC32(group-&gt;ebyte, 6);</a>
<a name="ln766">	bool isInTable = fMulticastHashes.Find(hash) != fMulticastHashes.End();</a>
<a name="ln767">	</a>
<a name="ln768">	if (isInTable &amp;&amp; join)</a>
<a name="ln769">		return B_OK; // already listed - nothing to do</a>
<a name="ln770"> </a>
<a name="ln771">	if (!isInTable &amp;&amp; !join) {</a>
<a name="ln772">		TRACE_ALWAYS(&quot;Cannot leave unlisted multicast group %s!\n&quot;, groupName);</a>
<a name="ln773">		return B_ERROR;</a>
<a name="ln774">	}</a>
<a name="ln775"> </a>
<a name="ln776">	const size_t hashLength = 8;</a>
<a name="ln777">	uint8 hashTable[hashLength] = { 0 };</a>
<a name="ln778">	hashTable[hashLength - 1] |= 0x80; // broadcast address</a>
<a name="ln779"> </a>
<a name="ln780">	status_t result = _WriteRegister(RegMAR, hashLength, hashTable);</a>
<a name="ln781">	if (result != B_OK) {</a>
<a name="ln782">		TRACE_ALWAYS(&quot;Error initializing MAR: %#010x.\n&quot;, result);</a>
<a name="ln783">		return result;</a>
<a name="ln784">	}</a>
<a name="ln785">	</a>
<a name="ln786">	if (join)</a>
<a name="ln787">		fMulticastHashes.PushBack(hash);</a>
<a name="ln788">	else</a>
<a name="ln789">		fMulticastHashes.Remove(hash);</a>
<a name="ln790"> </a>
<a name="ln791">	for (int32 i = 0; i &lt; fMulticastHashes.Count(); i++) {</a>
<a name="ln792">		uint32 hash = fMulticastHashes[i] &gt;&gt; 26;</a>
<a name="ln793">		hashTable[hash / 8] |= 1 &lt;&lt; (hash % 8);</a>
<a name="ln794">	}</a>
<a name="ln795"> </a>
<a name="ln796">	// clear/set pass all multicast bit as required</a>
<a name="ln797">	uint8 control = 0;</a>
<a name="ln798">	result = _ReadRegister(RegRCR, 1, &amp;control);</a>
<a name="ln799">	if (result != B_OK) {</a>
<a name="ln800">		TRACE_ALWAYS(&quot;Error reading RCR: %#010x.\n&quot;, result);</a>
<a name="ln801">		return result;</a>
<a name="ln802">	}</a>
<a name="ln803"> </a>
<a name="ln804">	if (fMulticastHashes.Count() &gt; 0)</a>
<a name="ln805">		control &amp;= ~RCRAllMulticast;</a>
<a name="ln806">	else</a>
<a name="ln807">		control |= RCRAllMulticast;</a>
<a name="ln808"> </a>
<a name="ln809">	result = _Write1Register(RegRCR, control);</a>
<a name="ln810">	if (result != B_OK) {</a>
<a name="ln811">		TRACE_ALWAYS(&quot;Error writing %#02X to RCR: %#010x.\n&quot;, control, result);</a>
<a name="ln812">		return result;</a>
<a name="ln813">	}</a>
<a name="ln814"> </a>
<a name="ln815">	result = _WriteRegister(RegMAR, hashLength, hashTable);</a>
<a name="ln816">	if (result != B_OK)</a>
<a name="ln817">		TRACE_ALWAYS(&quot;Error writing hash table in MAR: %#010x.\n&quot;, result);</a>
<a name="ln818"> </a>
<a name="ln819">	return result;</a>
<a name="ln820">}</a>
<a name="ln821"> </a>
<a name="ln822"> </a>
<a name="ln823">void</a>
<a name="ln824">DavicomDevice::_ReadCallback(void *cookie, int32 status, void *data,</a>
<a name="ln825">	size_t actualLength)</a>
<a name="ln826">{</a>
<a name="ln827">	TRACE_RX(&quot;ReadCB: %d bytes; status:%#010x\n&quot;, actualLength, status);</a>
<a name="ln828">	DavicomDevice *device = (DavicomDevice *)cookie;</a>
<a name="ln829">	device-&gt;fActualLengthRead = actualLength;</a>
<a name="ln830">	device-&gt;fStatusRead = status;</a>
<a name="ln831">	device-&gt;fStats.readCount++;</a>
<a name="ln832">	release_sem_etc(device-&gt;fNotifyReadSem, 1, B_DO_NOT_RESCHEDULE);</a>
<a name="ln833">}</a>
<a name="ln834"> </a>
<a name="ln835"> </a>
<a name="ln836">void</a>
<a name="ln837">DavicomDevice::_WriteCallback(void *cookie, int32 status, void *data,</a>
<a name="ln838">	size_t actualLength)</a>
<a name="ln839">{</a>
<a name="ln840">	TRACE_TX(&quot;WriteCB: %d bytes; status:%#010x\n&quot;, actualLength, status);</a>
<a name="ln841">	DavicomDevice *device = (DavicomDevice *)cookie;</a>
<a name="ln842">	device-&gt;fActualLengthWrite = actualLength;</a>
<a name="ln843">	device-&gt;fStatusWrite = status;</a>
<a name="ln844">	device-&gt;fStats.writeCount++;</a>
<a name="ln845">	release_sem_etc(device-&gt;fNotifyWriteSem, 1, B_DO_NOT_RESCHEDULE);</a>
<a name="ln846">}</a>
<a name="ln847"> </a>
<a name="ln848"> </a>
<a name="ln849">void</a>
<a name="ln850">DavicomDevice::_NotifyCallback(void *cookie, int32 status, void *data,</a>
<a name="ln851">	size_t actualLength)</a>
<a name="ln852">{</a>
<a name="ln853">	DavicomDevice *device = (DavicomDevice *)cookie;</a>
<a name="ln854">	atomic_add(&amp;device-&gt;fInsideNotify, 1);</a>
<a name="ln855">	if (status == B_CANCELED || device-&gt;fRemoved) {</a>
<a name="ln856">		atomic_add(&amp;device-&gt;fInsideNotify, -1);</a>
<a name="ln857">		return;</a>
<a name="ln858">	}</a>
<a name="ln859"> </a>
<a name="ln860">	if (status == B_OK)</a>
<a name="ln861">		device-&gt;_OnNotify(actualLength);</a>
<a name="ln862">	else</a>
<a name="ln863">		TRACE_ALWAYS(&quot;Status error:%#010x; length:%d\n&quot;, status, actualLength);</a>
<a name="ln864"> </a>
<a name="ln865">	// schedule next notification buffer</a>
<a name="ln866">	gUSBModule-&gt;queue_interrupt(device-&gt;fNotifyEndpoint, device-&gt;fNotifyData,</a>
<a name="ln867">		sizeof(DM9601NotifyData), _NotifyCallback, device);</a>
<a name="ln868">	atomic_add(&amp;device-&gt;fInsideNotify, -1);</a>
<a name="ln869">}</a>
<a name="ln870"> </a>
<a name="ln871"> </a>
<a name="ln872">status_t</a>
<a name="ln873">DavicomDevice::_OnNotify(uint32 actualLength)</a>
<a name="ln874">{</a>
<a name="ln875">	if (actualLength != sizeof(DM9601NotifyData)) {</a>
<a name="ln876">		TRACE_ALWAYS(&quot;Data underrun error. %d of %d bytes received\n&quot;,</a>
<a name="ln877">			actualLength, sizeof(DM9601NotifyData));</a>
<a name="ln878">		return B_BAD_DATA;</a>
<a name="ln879">	}</a>
<a name="ln880"> </a>
<a name="ln881">	bool linkIsUp = fNotifyData-&gt;LINKST != 0;</a>
<a name="ln882">	fTXBufferFull = fNotifyData-&gt;TXFULL != 0;</a>
<a name="ln883">	bool rxOverflow = fNotifyData-&gt;RXOV != 0;</a>
<a name="ln884"> </a>
<a name="ln885">	bool linkStateChange = (linkIsUp != fHasConnection);</a>
<a name="ln886">	fHasConnection = linkIsUp;</a>
<a name="ln887"> </a>
<a name="ln888">	if (linkStateChange) {</a>
<a name="ln889">		if (fHasConnection) {</a>
<a name="ln890">			TRACE(&quot;Link is now up at %s Mb/s\n&quot;,</a>
<a name="ln891">				fNotifyData-&gt;SPEED ? &quot;10&quot; : &quot;100&quot;);</a>
<a name="ln892">		} else</a>
<a name="ln893">			TRACE(&quot;Link is now down&quot;);</a>
<a name="ln894">	}</a>
<a name="ln895"> </a>
<a name="ln896">#ifdef UDAV_TRACE</a>
<a name="ln897">	if (gTraceStats) {</a>
<a name="ln898">		if (fNotifyData-&gt;TXFULL)</a>
<a name="ln899">			fStats.txFull++;</a>
<a name="ln900">		if (fNotifyData-&gt;RXOV)</a>
<a name="ln901">			fStats.rxOverflow++;</a>
<a name="ln902"> </a>
<a name="ln903">		if (fNotifyData-&gt;ROC)</a>
<a name="ln904">			fStats.rxOvCount += fNotifyData-&gt;ROC;</a>
<a name="ln905"> </a>
<a name="ln906">		if (fNotifyData-&gt;RT)</a>
<a name="ln907">			fStats.runtFrames++;</a>
<a name="ln908">		if (fNotifyData-&gt;LCS)</a>
<a name="ln909">			fStats.lateRXCollisions++;</a>
<a name="ln910">		if (fNotifyData-&gt;RWTO)</a>
<a name="ln911">			fStats.rwTOs++;</a>
<a name="ln912">		if (fNotifyData-&gt;PLE)</a>
<a name="ln913">			fStats.physLayerErros++;</a>
<a name="ln914">		if (fNotifyData-&gt;AE)</a>
<a name="ln915">			fStats.alignmentErros++;</a>
<a name="ln916">		if (fNotifyData-&gt;CE)</a>
<a name="ln917">			fStats.crcErrors++;</a>
<a name="ln918">		if (fNotifyData-&gt;FOE)</a>
<a name="ln919">			fStats.overErrors++;</a>
<a name="ln920"> </a>
<a name="ln921">		if (fNotifyData-&gt;TSR1.LC)</a>
<a name="ln922">			fStats.lateTXCollisions++;</a>
<a name="ln923">		if (fNotifyData-&gt;TSR1.LCR)</a>
<a name="ln924">			fStats.lostOfCarrier++;</a>
<a name="ln925">		if (fNotifyData-&gt;TSR1.NC)</a>
<a name="ln926">			fStats.noCarrier++;</a>
<a name="ln927">		if (fNotifyData-&gt;TSR1.COL)</a>
<a name="ln928">			fStats.txCollisions++;</a>
<a name="ln929">		if (fNotifyData-&gt;TSR1.EC)</a>
<a name="ln930">			fStats.excCollisions++;</a>
<a name="ln931"> </a>
<a name="ln932">		if (fNotifyData-&gt;TSR2.LC)</a>
<a name="ln933">			fStats.lateTXCollisions++;</a>
<a name="ln934">		if (fNotifyData-&gt;TSR2.LCR)</a>
<a name="ln935">			fStats.lostOfCarrier++;</a>
<a name="ln936">		if (fNotifyData-&gt;TSR2.NC)</a>
<a name="ln937">			fStats.noCarrier++;</a>
<a name="ln938">		if (fNotifyData-&gt;TSR2.COL)</a>
<a name="ln939">			fStats.txCollisions++;</a>
<a name="ln940">		if (fNotifyData-&gt;TSR2.EC)</a>
<a name="ln941">			fStats.excCollisions++;</a>
<a name="ln942"> </a>
<a name="ln943">		fStats.notifyCount++;</a>
<a name="ln944">	}</a>
<a name="ln945">#endif</a>
<a name="ln946"> </a>
<a name="ln947">	if (rxOverflow)</a>
<a name="ln948">		TRACE(&quot;RX buffer overflow. %d packets dropped\n&quot;, fNotifyData-&gt;ROC);</a>
<a name="ln949"> </a>
<a name="ln950">	uint8 tsr = 0xfc &amp; *(uint8*)&amp;fNotifyData-&gt;TSR1;</a>
<a name="ln951">	if (tsr != 0)</a>
<a name="ln952">		TRACE(&quot;TX packet 1: Status %#04x is not OK.\n&quot;, tsr);</a>
<a name="ln953"> </a>
<a name="ln954">	tsr = 0xfc &amp; *(uint8*)&amp;fNotifyData-&gt;TSR2;</a>
<a name="ln955">	if (tsr != 0)</a>
<a name="ln956">		TRACE(&quot;TX packet 2: Status %#04x is not OK.\n&quot;, tsr);</a>
<a name="ln957"> </a>
<a name="ln958">	if (linkStateChange &amp;&amp; fLinkStateChangeSem &gt;= B_OK)</a>
<a name="ln959">		release_sem_etc(fLinkStateChangeSem, 1, B_DO_NOT_RESCHEDULE);</a>
<a name="ln960">	return B_OK;</a>
<a name="ln961">}</a>
<a name="ln962"> </a>
<a name="ln963"> </a>
<a name="ln964">status_t</a>
<a name="ln965">DavicomDevice::_GetLinkState(ether_link_state *linkState)</a>
<a name="ln966">{</a>
<a name="ln967">	uint8 registerValue = 0;</a>
<a name="ln968">	status_t result = _ReadRegister(RegNSR, 1, &amp;registerValue);</a>
<a name="ln969">	if (result != B_OK) {</a>
<a name="ln970">		TRACE_ALWAYS(&quot;Error reading NSR register! %x\n&quot;, result);</a>
<a name="ln971">		return result;</a>
<a name="ln972">	}</a>
<a name="ln973"> </a>
<a name="ln974">	if (registerValue &amp; NSRSpeed10)</a>
<a name="ln975">		linkState-&gt;speed = 10000000;</a>
<a name="ln976">	else</a>
<a name="ln977">		linkState-&gt;speed = 100000000;</a>
<a name="ln978"> </a>
<a name="ln979">	linkState-&gt;quality = 1000;</a>
<a name="ln980"> </a>
<a name="ln981">	linkState-&gt;media = IFM_ETHER | IFM_100_TX;</a>
<a name="ln982">	if (fHasConnection) {</a>
<a name="ln983">		linkState-&gt;media |= IFM_ACTIVE;</a>
<a name="ln984">		result = _ReadRegister(RegNCR, 1, &amp;registerValue);</a>
<a name="ln985">		if (result != B_OK) {</a>
<a name="ln986">			TRACE_ALWAYS(&quot;Error reading NCR register! %x\n&quot;, result);</a>
<a name="ln987">			return result;</a>
<a name="ln988">		}</a>
<a name="ln989"> </a>
<a name="ln990">		if (registerValue &amp; NCRFullDX)</a>
<a name="ln991">			linkState-&gt;media |= IFM_FULL_DUPLEX;</a>
<a name="ln992">		else</a>
<a name="ln993">			linkState-&gt;media |= IFM_HALF_DUPLEX;</a>
<a name="ln994"> </a>
<a name="ln995">		if (registerValue &amp; NCRLoopback)</a>
<a name="ln996">			linkState-&gt;media |= IFM_LOOP;</a>
<a name="ln997">	}</a>
<a name="ln998"> </a>
<a name="ln999">	TRACE_STATE(&quot;Medium state: %s, %lld MBit/s, %s duplex.\n&quot;,</a>
<a name="ln1000">						(linkState-&gt;media &amp; IFM_ACTIVE) ? &quot;active&quot; : &quot;inactive&quot;,</a>
<a name="ln1001">						linkState-&gt;speed / 1000000,</a>
<a name="ln1002">						(linkState-&gt;media &amp; IFM_FULL_DUPLEX) ? &quot;full&quot; : &quot;half&quot;);</a>
<a name="ln1003"> </a>
<a name="ln1004">	TRACE_STATS(&quot;tx:%d rx:%d rxCn:%d rtF:%d lRxC:%d rwTO:%d PLE:%d AE:%d CE:%d &quot;</a>
<a name="ln1005">				&quot;oE:%d ltxC:%d lCR:%d nC:%d txC:%d exC:%d r:%d w:%d n:%d\n&quot;,</a>
<a name="ln1006">					fStats.txFull, fStats.rxOverflow, fStats.rxOvCount,</a>
<a name="ln1007">					fStats.runtFrames, fStats.lateRXCollisions, fStats.rwTOs,</a>
<a name="ln1008">					fStats.physLayerErros, fStats.alignmentErros,</a>
<a name="ln1009">					fStats.crcErrors, fStats.overErrors,</a>
<a name="ln1010">					fStats.lateTXCollisions, fStats.lostOfCarrier,</a>
<a name="ln1011">					fStats.noCarrier, fStats.txCollisions, fStats.excCollisions,</a>
<a name="ln1012">					fStats.readCount, fStats.writeCount, fStats.notifyCount);</a>
<a name="ln1013">	return B_OK;</a>
<a name="ln1014">}</a>
<a name="ln1015"> </a>
<a name="ln1016"> </a>
<a name="ln1017">status_t</a>
<a name="ln1018">DavicomDevice::_ReadRegister(uint8 reg, size_t size, uint8* buffer)</a>
<a name="ln1019">{</a>
<a name="ln1020">	if (size &gt; 255)</a>
<a name="ln1021">		return B_BAD_VALUE;</a>
<a name="ln1022"> </a>
<a name="ln1023">	size_t actualLength = 0;</a>
<a name="ln1024">	status_t result = gUSBModule-&gt;send_request(fDevice,</a>
<a name="ln1025">		USB_REQTYPE_VENDOR | USB_REQTYPE_DEVICE_IN,</a>
<a name="ln1026">		ReqReadRegister, 0, reg, size, buffer, &amp;actualLength);</a>
<a name="ln1027"> </a>
<a name="ln1028">	if (size != actualLength) {</a>
<a name="ln1029">		TRACE_ALWAYS(&quot;Size mismatch reading register ! asked %d got %d&quot;,</a>
<a name="ln1030">			size, actualLength);</a>
<a name="ln1031">	}</a>
<a name="ln1032"> </a>
<a name="ln1033">	return result;</a>
<a name="ln1034">}</a>
<a name="ln1035"> </a>
<a name="ln1036"> </a>
<a name="ln1037">status_t</a>
<a name="ln1038">DavicomDevice::_WriteRegister(uint8 reg, size_t size, uint8* buffer)</a>
<a name="ln1039">{</a>
<a name="ln1040">	if (size &gt; 255)</a>
<a name="ln1041">		return B_BAD_VALUE;</a>
<a name="ln1042"> </a>
<a name="ln1043">	size_t actualLength = 0;</a>
<a name="ln1044"> </a>
<a name="ln1045">	status_t result = gUSBModule-&gt;send_request(fDevice,</a>
<a name="ln1046">		USB_REQTYPE_VENDOR | USB_REQTYPE_DEVICE_OUT,</a>
<a name="ln1047">		ReqWriteRegister, 0, reg, size, buffer, &amp;actualLength);</a>
<a name="ln1048"> </a>
<a name="ln1049">	return result;</a>
<a name="ln1050">}</a>
<a name="ln1051"> </a>
<a name="ln1052"> </a>
<a name="ln1053">status_t</a>
<a name="ln1054">DavicomDevice::_Write1Register(uint8 reg, uint8 value)</a>
<a name="ln1055">{</a>
<a name="ln1056">	size_t actualLength = 0;</a>
<a name="ln1057"> </a>
<a name="ln1058">	status_t result = gUSBModule-&gt;send_request(fDevice,</a>
<a name="ln1059">		USB_REQTYPE_VENDOR | USB_REQTYPE_DEVICE_OUT,</a>
<a name="ln1060">		ReqWriteRegisterByte, value, reg, 0, NULL, &amp;actualLength);</a>
<a name="ln1061"> </a>
<a name="ln1062">	return result;</a>
<a name="ln1063">}</a>
<a name="ln1064"> </a>
<a name="ln1065"> </a>
<a name="ln1066">status_t</a>
<a name="ln1067">DavicomDevice::_ReadMII(uint8 reg, uint16* data)</a>
<a name="ln1068">{</a>
<a name="ln1069">	// select PHY and set PHY register address</a>
<a name="ln1070">	status_t result = _Write1Register(RegEPAR, EPARIntPHY | (reg &amp; EPARMask));</a>
<a name="ln1071">	if (result != B_OK) {</a>
<a name="ln1072">		TRACE_ALWAYS(&quot;Failed to set MII address %#x. Error:%#x\n&quot;, reg, result);</a>
<a name="ln1073">		return result;</a>
<a name="ln1074">	}</a>
<a name="ln1075"> </a>
<a name="ln1076">	// select PHY operation and initiate reading</a>
<a name="ln1077">	result = _Write1Register(RegEPCR, EPCROpSelect | EPCRRegRead);</a>
<a name="ln1078">	if (result != B_OK) {</a>
<a name="ln1079">		TRACE_ALWAYS(&quot;Failed to starting MII reading. Error:%#x\n&quot;, result);</a>
<a name="ln1080">		return result;</a>
<a name="ln1081">	}</a>
<a name="ln1082"> </a>
<a name="ln1083">	// finalize writing</a>
<a name="ln1084">	uint8 control = 0;</a>
<a name="ln1085">	result = _ReadRegister(RegEPCR, 1, &amp;control);</a>
<a name="ln1086">	if (result != B_OK) {</a>
<a name="ln1087">		TRACE_ALWAYS(&quot;Failed to read EPCR register. Error:%#x\n&quot;, result);</a>
<a name="ln1088">		return result;</a>
<a name="ln1089">	}</a>
<a name="ln1090"> </a>
<a name="ln1091">	result = _Write1Register(RegEPCR, control &amp; ~EPCRRegRead);</a>
<a name="ln1092">	if (result != B_OK) {</a>
<a name="ln1093">		TRACE_ALWAYS(&quot;Failed to write EPCR register. Error:%#x\n&quot;, result);</a>
<a name="ln1094">		return result;</a>
<a name="ln1095">	}</a>
<a name="ln1096"> </a>
<a name="ln1097">	// retrieve the result from data registers</a>
<a name="ln1098">	uint8 values[2] = { 0 };</a>
<a name="ln1099">	result = _ReadRegister(RegEPDRL, 2, values);</a>
<a name="ln1100">	if (result != B_OK) {</a>
<a name="ln1101">		TRACE_ALWAYS(&quot;Failed to retrieve data %#x. Error:%#x\n&quot;, data, result);</a>
<a name="ln1102">		return result;</a>
<a name="ln1103">	}</a>
<a name="ln1104"> </a>
<a name="ln1105">	*data = values[0] | values[1] &lt;&lt; 8;</a>
<a name="ln1106">	return result;</a>
<a name="ln1107">}</a>
<a name="ln1108"> </a>
<a name="ln1109"> </a>
<a name="ln1110">status_t</a>
<a name="ln1111">DavicomDevice::_WriteMII(uint8 reg, uint16 data)</a>
<a name="ln1112">{</a>
<a name="ln1113">	// select PHY and set PHY register address</a>
<a name="ln1114">	status_t result = _Write1Register(RegEPAR, EPARIntPHY | (reg &amp; EPARMask));</a>
<a name="ln1115">	if (result != B_OK) {</a>
<a name="ln1116">		TRACE_ALWAYS(&quot;Failed to set MII address %#x. Error:%#x\n&quot;, reg, result);</a>
<a name="ln1117">		return result;</a>
<a name="ln1118">	}</a>
<a name="ln1119"> </a>
<a name="ln1120">	// put the value to data register</a>
<a name="ln1121">	uint8 values[] = { (uint8)(data &amp; 0xff), (uint8)((data &gt;&gt; 8) &amp; 0xff) };</a>
<a name="ln1122">	result = _WriteRegister(RegEPDRL, sizeof(uint16), values);</a>
<a name="ln1123">	if (result != B_OK) {</a>
<a name="ln1124">		TRACE_ALWAYS(&quot;Failed to put data %#x. Error:%#x\n&quot;, data, result);</a>
<a name="ln1125">		return result;</a>
<a name="ln1126">	}</a>
<a name="ln1127"> </a>
<a name="ln1128">	// select PHY operation and initiate writing</a>
<a name="ln1129">	result = _Write1Register(RegEPCR, EPCROpSelect | EPCRRegWrite);</a>
<a name="ln1130">	if (result != B_OK) {</a>
<a name="ln1131">		TRACE_ALWAYS(&quot;Failed to starting MII wrintig. Error:%#x\n&quot;, result);</a>
<a name="ln1132">		return result;</a>
<a name="ln1133">	}</a>
<a name="ln1134"> </a>
<a name="ln1135">	// finalize writing</a>
<a name="ln1136">	uint8 control = 0;</a>
<a name="ln1137">	result = _ReadRegister(RegEPCR, 1, &amp;control);</a>
<a name="ln1138">	if (result != B_OK) {</a>
<a name="ln1139">		TRACE_ALWAYS(&quot;Failed to read EPCR register. Error:%#x\n&quot;, result);</a>
<a name="ln1140">		return result;</a>
<a name="ln1141">	}</a>
<a name="ln1142"> </a>
<a name="ln1143">	result = _Write1Register(RegEPCR, control &amp; ~EPCRRegWrite);</a>
<a name="ln1144">	if (result != B_OK)</a>
<a name="ln1145">		TRACE_ALWAYS(&quot;Failed to write EPCR register. Error:%#x\n&quot;, result);</a>
<a name="ln1146"> </a>
<a name="ln1147">	return result;</a>
<a name="ln1148">}</a>
<a name="ln1149"> </a>
<a name="ln1150"> </a>
<a name="ln1151">status_t</a>
<a name="ln1152">DavicomDevice::_InitMII()</a>
<a name="ln1153">{</a>
<a name="ln1154">	uint16 control = 0;</a>
<a name="ln1155">	status_t result = _ReadMII(RegBMCR, &amp;control);</a>
<a name="ln1156">	if (result != B_OK) {</a>
<a name="ln1157">		TRACE_ALWAYS(&quot;Failed to read MII BMCR register. Error:%#x\n&quot;, result);</a>
<a name="ln1158">		return result;</a>
<a name="ln1159">	}</a>
<a name="ln1160"> </a>
<a name="ln1161">	result = _WriteMII(RegBMCR, control &amp; ~BMCRIsolate);</a>
<a name="ln1162">	if (result != B_OK) {</a>
<a name="ln1163">		TRACE_ALWAYS(&quot;Failed to clear isolate PHY. Error:%#x\n&quot;, result);</a>
<a name="ln1164">		return result;</a>
<a name="ln1165">	}</a>
<a name="ln1166"> </a>
<a name="ln1167">	result = _WriteMII(0, BMCRReset);</a>
<a name="ln1168">	if (result != B_OK) {</a>
<a name="ln1169">		TRACE_ALWAYS(&quot;Failed to reset BMCR register. Error:%#x\n&quot;, result);</a>
<a name="ln1170">		return result;</a>
<a name="ln1171">	}</a>
<a name="ln1172"> </a>
<a name="ln1173">	uint16 id01 = 0, id02 = 0;</a>
<a name="ln1174">	result = _ReadMII(RegPHYID1, &amp;id01);</a>
<a name="ln1175">	if (result != B_OK) {</a>
<a name="ln1176">		TRACE_ALWAYS(&quot;Failed to read PHY ID 0. Error:%#x\n&quot;, result);</a>
<a name="ln1177">		return result;</a>
<a name="ln1178">	}</a>
<a name="ln1179"> </a>
<a name="ln1180">	result = _ReadMII(RegPHYID2, &amp;id02);</a>
<a name="ln1181">	if (result != B_OK) {</a>
<a name="ln1182">		TRACE_ALWAYS(&quot;Failed to read PHY ID 1. Error:%#x\n&quot;, result);</a>
<a name="ln1183">		return result;</a>
<a name="ln1184">	}</a>
<a name="ln1185"> </a>
<a name="ln1186">	TRACE_ALWAYS(&quot;MII Info: OUI:%04x; Model:%04x; rev:%02x.\n&quot;,</a>
<a name="ln1187">			MII_OUI(id01, id02), MII_MODEL(id02), MII_REV(id02));</a>
<a name="ln1188"> </a>
<a name="ln1189">	return result;</a>
<a name="ln1190">}</a>
<a name="ln1191"> </a>
<a name="ln1192"> </a>
<a name="ln1193">status_t</a>
<a name="ln1194">DavicomDevice::_EnableInterrupts(bool enable)</a>
<a name="ln1195">{</a>
<a name="ln1196">	uint8 control = 0;</a>
<a name="ln1197">	status_t result = _ReadRegister(RegUSBC, 1, &amp;control);</a>
<a name="ln1198">	if (result != B_OK) {</a>
<a name="ln1199">		TRACE_ALWAYS(&quot;Error of reading USB control register:%#010x\n&quot;, result);</a>
<a name="ln1200">		return result;</a>
<a name="ln1201">	}</a>
<a name="ln1202"> </a>
<a name="ln1203">	if (enable) {</a>
<a name="ln1204">		control |= USBCIntAck;</a>
<a name="ln1205">		control &amp;= ~USBCIntNAck;</a>
<a name="ln1206">	} else {</a>
<a name="ln1207">		control &amp;= ~USBCIntAck;</a>
<a name="ln1208">	}</a>
<a name="ln1209"> </a>
<a name="ln1210">	result = _Write1Register(RegUSBC, control);</a>
<a name="ln1211">	if (result != B_OK)</a>
<a name="ln1212">		TRACE_ALWAYS(&quot;Error of setting USB control register:%#010x\n&quot;, result);</a>
<a name="ln1213"> </a>
<a name="ln1214">	return result;</a>
<a name="ln1215">}</a>
<a name="ln1216"> </a>

</code></pre>
<div class="balloon" rel="587"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '(epd->endpoint_address & 0x00) == 0x00' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
