
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ar5212_misc.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * SPDX-License-Identifier: ISC</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting</a>
<a name="ln5"> * Copyright (c) 2002-2008 Atheros Communications, Inc.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Permission to use, copy, modify, and/or distribute this software for any</a>
<a name="ln8"> * purpose with or without fee is hereby granted, provided that the above</a>
<a name="ln9"> * copyright notice and this permission notice appear in all copies.</a>
<a name="ln10"> *</a>
<a name="ln11"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES</a>
<a name="ln12"> * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</a>
<a name="ln13"> * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR</a>
<a name="ln14"> * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</a>
<a name="ln15"> * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</a>
<a name="ln16"> * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</a>
<a name="ln17"> * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</a>
<a name="ln18"> *</a>
<a name="ln19"> * $FreeBSD: releng/12.0/sys/dev/ath/ath_hal/ar5212/ar5212_misc.c 326695 2017-12-08 15:57:29Z pfg $</a>
<a name="ln20"> */</a>
<a name="ln21">#include &quot;opt_ah.h&quot;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;ah.h&quot;</a>
<a name="ln24">#include &quot;ah_internal.h&quot;</a>
<a name="ln25">#include &quot;ah_devid.h&quot;</a>
<a name="ln26">#include &quot;ah_desc.h&quot;			/* NB: for HAL_PHYERR* */</a>
<a name="ln27"> </a>
<a name="ln28">#include &quot;ar5212/ar5212.h&quot;</a>
<a name="ln29">#include &quot;ar5212/ar5212reg.h&quot;</a>
<a name="ln30">#include &quot;ar5212/ar5212phy.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32">#include &quot;ah_eeprom_v3.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#define	AR_NUM_GPIO	6		/* 6 GPIO pins */</a>
<a name="ln35">#define	AR_GPIOD_MASK	0x0000002F	/* GPIO data reg r/w mask */</a>
<a name="ln36"> </a>
<a name="ln37">void</a>
<a name="ln38">ar5212GetMacAddress(struct ath_hal *ah, uint8_t *mac)</a>
<a name="ln39">{</a>
<a name="ln40">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln41"> </a>
<a name="ln42">	OS_MEMCPY(mac, ahp-&gt;ah_macaddr, IEEE80211_ADDR_LEN);</a>
<a name="ln43">}</a>
<a name="ln44"> </a>
<a name="ln45">HAL_BOOL</a>
<a name="ln46">ar5212SetMacAddress(struct ath_hal *ah, const uint8_t *mac)</a>
<a name="ln47">{</a>
<a name="ln48">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln49"> </a>
<a name="ln50">	OS_MEMCPY(ahp-&gt;ah_macaddr, mac, IEEE80211_ADDR_LEN);</a>
<a name="ln51">	return AH_TRUE;</a>
<a name="ln52">}</a>
<a name="ln53"> </a>
<a name="ln54">void</a>
<a name="ln55">ar5212GetBssIdMask(struct ath_hal *ah, uint8_t *mask)</a>
<a name="ln56">{</a>
<a name="ln57">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln58"> </a>
<a name="ln59">	OS_MEMCPY(mask, ahp-&gt;ah_bssidmask, IEEE80211_ADDR_LEN);</a>
<a name="ln60">}</a>
<a name="ln61"> </a>
<a name="ln62">HAL_BOOL</a>
<a name="ln63">ar5212SetBssIdMask(struct ath_hal *ah, const uint8_t *mask)</a>
<a name="ln64">{</a>
<a name="ln65">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln66"> </a>
<a name="ln67">	/* save it since it must be rewritten on reset */</a>
<a name="ln68">	OS_MEMCPY(ahp-&gt;ah_bssidmask, mask, IEEE80211_ADDR_LEN);</a>
<a name="ln69"> </a>
<a name="ln70">	OS_REG_WRITE(ah, AR_BSSMSKL, LE_READ_4(ahp-&gt;ah_bssidmask));</a>
<a name="ln71">	OS_REG_WRITE(ah, AR_BSSMSKU, LE_READ_2(ahp-&gt;ah_bssidmask + 4));</a>
<a name="ln72">	return AH_TRUE;</a>
<a name="ln73">}</a>
<a name="ln74"> </a>
<a name="ln75">/*</a>
<a name="ln76"> * Attempt to change the cards operating regulatory domain to the given value</a>
<a name="ln77"> */</a>
<a name="ln78">HAL_BOOL</a>
<a name="ln79">ar5212SetRegulatoryDomain(struct ath_hal *ah,</a>
<a name="ln80">	uint16_t regDomain, HAL_STATUS *status)</a>
<a name="ln81">{</a>
<a name="ln82">	HAL_STATUS ecode;</a>
<a name="ln83"> </a>
<a name="ln84">	if (AH_PRIVATE(ah)-&gt;ah_currentRD == regDomain) {</a>
<a name="ln85">		ecode = HAL_EINVAL;</a>
<a name="ln86">		goto bad;</a>
<a name="ln87">	}</a>
<a name="ln88">	if (ath_hal_eepromGetFlag(ah, AR_EEP_WRITEPROTECT)) {</a>
<a name="ln89">		ecode = HAL_EEWRITE;</a>
<a name="ln90">		goto bad;</a>
<a name="ln91">	}</a>
<a name="ln92">#ifdef AH_SUPPORT_WRITE_REGDOMAIN</a>
<a name="ln93">	if (ath_hal_eepromWrite(ah, AR_EEPROM_REG_DOMAIN, regDomain)) {</a>
<a name="ln94">		HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln95">		    &quot;%s: set regulatory domain to %u (0x%x)\n&quot;,</a>
<a name="ln96">		    __func__, regDomain, regDomain);</a>
<a name="ln97">		AH_PRIVATE(ah)-&gt;ah_currentRD = regDomain;</a>
<a name="ln98">		return AH_TRUE;</a>
<a name="ln99">	}</a>
<a name="ln100">#endif</a>
<a name="ln101">	ecode = HAL_EIO;</a>
<a name="ln102">bad:</a>
<a name="ln103">	if (status)</a>
<a name="ln104">		*status = ecode;</a>
<a name="ln105">	return AH_FALSE;</a>
<a name="ln106">}</a>
<a name="ln107"> </a>
<a name="ln108">/*</a>
<a name="ln109"> * Return the wireless modes (a,b,g,t) supported by hardware.</a>
<a name="ln110"> *</a>
<a name="ln111"> * This value is what is actually supported by the hardware</a>
<a name="ln112"> * and is unaffected by regulatory/country code settings.</a>
<a name="ln113"> */</a>
<a name="ln114">u_int</a>
<a name="ln115">ar5212GetWirelessModes(struct ath_hal *ah)</a>
<a name="ln116">{</a>
<a name="ln117">	u_int mode = 0;</a>
<a name="ln118"> </a>
<a name="ln119">	if (ath_hal_eepromGetFlag(ah, AR_EEP_AMODE)) {</a>
<a name="ln120">		mode = HAL_MODE_11A;</a>
<a name="ln121">		if (!ath_hal_eepromGetFlag(ah, AR_EEP_TURBO5DISABLE))</a>
<a name="ln122">			mode |= HAL_MODE_TURBO | HAL_MODE_108A;</a>
<a name="ln123">		if (AH_PRIVATE(ah)-&gt;ah_caps.halChanHalfRate)</a>
<a name="ln124">			mode |= HAL_MODE_11A_HALF_RATE;</a>
<a name="ln125">		if (AH_PRIVATE(ah)-&gt;ah_caps.halChanQuarterRate)</a>
<a name="ln126">			mode |= HAL_MODE_11A_QUARTER_RATE;</a>
<a name="ln127">	}</a>
<a name="ln128">	if (ath_hal_eepromGetFlag(ah, AR_EEP_BMODE))</a>
<a name="ln129">		mode |= HAL_MODE_11B;</a>
<a name="ln130">	if (ath_hal_eepromGetFlag(ah, AR_EEP_GMODE) &amp;&amp;</a>
<a name="ln131">	    AH_PRIVATE(ah)-&gt;ah_subvendorid != AR_SUBVENDOR_ID_NOG) {</a>
<a name="ln132">		mode |= HAL_MODE_11G;</a>
<a name="ln133">		if (!ath_hal_eepromGetFlag(ah, AR_EEP_TURBO2DISABLE))</a>
<a name="ln134">			mode |= HAL_MODE_108G;</a>
<a name="ln135">		if (AH_PRIVATE(ah)-&gt;ah_caps.halChanHalfRate)</a>
<a name="ln136">			mode |= HAL_MODE_11G_HALF_RATE;</a>
<a name="ln137">		if (AH_PRIVATE(ah)-&gt;ah_caps.halChanQuarterRate)</a>
<a name="ln138">			mode |= HAL_MODE_11G_QUARTER_RATE;</a>
<a name="ln139">	}</a>
<a name="ln140">	return mode;</a>
<a name="ln141">}</a>
<a name="ln142"> </a>
<a name="ln143">/*</a>
<a name="ln144"> * Set the interrupt and GPIO values so the ISR can disable RF</a>
<a name="ln145"> * on a switch signal.  Assumes GPIO port and interrupt polarity</a>
<a name="ln146"> * are set prior to call.</a>
<a name="ln147"> */</a>
<a name="ln148">void</a>
<a name="ln149">ar5212EnableRfKill(struct ath_hal *ah)</a>
<a name="ln150">{</a>
<a name="ln151">	uint16_t rfsilent = AH_PRIVATE(ah)-&gt;ah_rfsilent;</a>
<a name="ln152">	int select = MS(rfsilent, AR_EEPROM_RFSILENT_GPIO_SEL);</a>
<a name="ln153">	int polarity = MS(rfsilent, AR_EEPROM_RFSILENT_POLARITY);</a>
<a name="ln154"> </a>
<a name="ln155">	/*</a>
<a name="ln156">	 * Configure the desired GPIO port for input</a>
<a name="ln157">	 * and enable baseband rf silence.</a>
<a name="ln158">	 */</a>
<a name="ln159">	ath_hal_gpioCfgInput(ah, select);</a>
<a name="ln160">	OS_REG_SET_BIT(ah, AR_PHY(0), 0x00002000);</a>
<a name="ln161">	/*</a>
<a name="ln162">	 * If radio disable switch connection to GPIO bit x is enabled</a>
<a name="ln163">	 * program GPIO interrupt.</a>
<a name="ln164">	 * If rfkill bit on eeprom is 1, setupeeprommap routine has already</a>
<a name="ln165">	 * verified that it is a later version of eeprom, it has a place for</a>
<a name="ln166">	 * rfkill bit and it is set to 1, indicating that GPIO bit x hardware</a>
<a name="ln167">	 * connection is present.</a>
<a name="ln168">	 */</a>
<a name="ln169">	ath_hal_gpioSetIntr(ah, select,</a>
<a name="ln170">	    (ath_hal_gpioGet(ah, select) == polarity ? !polarity : polarity));</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">/*</a>
<a name="ln174"> * Change the LED blinking pattern to correspond to the connectivity</a>
<a name="ln175"> */</a>
<a name="ln176">void</a>
<a name="ln177">ar5212SetLedState(struct ath_hal *ah, HAL_LED_STATE state)</a>
<a name="ln178">{</a>
<a name="ln179">	static const uint32_t ledbits[8] = {</a>
<a name="ln180">		AR_PCICFG_LEDCTL_NONE,	/* HAL_LED_INIT */</a>
<a name="ln181">		AR_PCICFG_LEDCTL_PEND,	/* HAL_LED_SCAN */</a>
<a name="ln182">		AR_PCICFG_LEDCTL_PEND,	/* HAL_LED_AUTH */</a>
<a name="ln183">		AR_PCICFG_LEDCTL_ASSOC,	/* HAL_LED_ASSOC*/</a>
<a name="ln184">		AR_PCICFG_LEDCTL_ASSOC,	/* HAL_LED_RUN */</a>
<a name="ln185">		AR_PCICFG_LEDCTL_NONE,</a>
<a name="ln186">		AR_PCICFG_LEDCTL_NONE,</a>
<a name="ln187">		AR_PCICFG_LEDCTL_NONE,</a>
<a name="ln188">	};</a>
<a name="ln189">	uint32_t bits;</a>
<a name="ln190"> </a>
<a name="ln191">	bits = OS_REG_READ(ah, AR_PCICFG);</a>
<a name="ln192">	if (IS_2417(ah)) {</a>
<a name="ln193">		/*</a>
<a name="ln194">		 * Enable LED for Nala. There is a bit marked reserved</a>
<a name="ln195">		 * that must be set and we also turn on the power led.</a>
<a name="ln196">		 * Because we mark s/w LED control setting the control</a>
<a name="ln197">		 * status bits below is meangless (the driver must flash</a>
<a name="ln198">		 * the LED(s) using the GPIO lines).</a>
<a name="ln199">		 */</a>
<a name="ln200">		bits = (bits &amp;~ AR_PCICFG_LEDMODE)</a>
<a name="ln201">		     | SM(AR_PCICFG_LEDMODE_POWON, AR_PCICFG_LEDMODE)</a>
<a name="ln202">#if 0</a>
<a name="ln203">		     | SM(AR_PCICFG_LEDMODE_NETON, AR_PCICFG_LEDMODE)</a>
<a name="ln204">#endif</a>
<a name="ln205">		     | 0x08000000;</a>
<a name="ln206">	}</a>
<a name="ln207">	bits = (bits &amp;~ AR_PCICFG_LEDCTL)</a>
<a name="ln208">	     | SM(ledbits[state &amp; 0x7], AR_PCICFG_LEDCTL);</a>
<a name="ln209">	OS_REG_WRITE(ah, AR_PCICFG, bits);</a>
<a name="ln210">}</a>
<a name="ln211"> </a>
<a name="ln212">/*</a>
<a name="ln213"> * Change association related fields programmed into the hardware.</a>
<a name="ln214"> * Writing a valid BSSID to the hardware effectively enables the hardware</a>
<a name="ln215"> * to synchronize its TSF to the correct beacons and receive frames coming</a>
<a name="ln216"> * from that BSSID. It is called by the SME JOIN operation.</a>
<a name="ln217"> */</a>
<a name="ln218">void</a>
<a name="ln219">ar5212WriteAssocid(struct ath_hal *ah, const uint8_t *bssid, uint16_t assocId)</a>
<a name="ln220">{</a>
<a name="ln221">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln222"> </a>
<a name="ln223">	/* save bssid for possible re-use on reset */</a>
<a name="ln224">	OS_MEMCPY(ahp-&gt;ah_bssid, bssid, IEEE80211_ADDR_LEN);</a>
<a name="ln225">	ahp-&gt;ah_assocId = assocId;</a>
<a name="ln226">	OS_REG_WRITE(ah, AR_BSS_ID0, LE_READ_4(ahp-&gt;ah_bssid));</a>
<a name="ln227">	OS_REG_WRITE(ah, AR_BSS_ID1, LE_READ_2(ahp-&gt;ah_bssid+4) |</a>
<a name="ln228">				     ((assocId &amp; 0x3fff)&lt;&lt;AR_BSS_ID1_AID_S));</a>
<a name="ln229">}</a>
<a name="ln230"> </a>
<a name="ln231">/*</a>
<a name="ln232"> * Get the current hardware tsf for stamlme</a>
<a name="ln233"> */</a>
<a name="ln234">uint64_t</a>
<a name="ln235">ar5212GetTsf64(struct ath_hal *ah)</a>
<a name="ln236">{</a>
<a name="ln237">	uint32_t low1, low2, u32;</a>
<a name="ln238"> </a>
<a name="ln239">	/* sync multi-word read */</a>
<a name="ln240">	low1 = OS_REG_READ(ah, AR_TSF_L32);</a>
<a name="ln241">	u32 = OS_REG_READ(ah, AR_TSF_U32);</a>
<a name="ln242">	low2 = OS_REG_READ(ah, AR_TSF_L32);</a>
<a name="ln243">	if (low2 &lt; low1) {	/* roll over */</a>
<a name="ln244">		/*</a>
<a name="ln245">		 * If we are not preempted this will work.  If we are</a>
<a name="ln246">		 * then we re-reading AR_TSF_U32 does no good as the</a>
<a name="ln247">		 * low bits will be meaningless.  Likewise reading</a>
<a name="ln248">		 * L32, U32, U32, then comparing the last two reads</a>
<a name="ln249">		 * to check for rollover doesn't help if preempted--so</a>
<a name="ln250">		 * we take this approach as it costs one less PCI read</a>
<a name="ln251">		 * which can be noticeable when doing things like</a>
<a name="ln252">		 * timestamping packets in monitor mode.</a>
<a name="ln253">		 */</a>
<a name="ln254">		u32++;</a>
<a name="ln255">	}</a>
<a name="ln256">	return (((uint64_t) u32) &lt;&lt; 32) | ((uint64_t) low2);</a>
<a name="ln257">}</a>
<a name="ln258"> </a>
<a name="ln259">/*</a>
<a name="ln260"> * Get the current hardware tsf for stamlme</a>
<a name="ln261"> */</a>
<a name="ln262">uint32_t</a>
<a name="ln263">ar5212GetTsf32(struct ath_hal *ah)</a>
<a name="ln264">{</a>
<a name="ln265">	return OS_REG_READ(ah, AR_TSF_L32);</a>
<a name="ln266">}</a>
<a name="ln267"> </a>
<a name="ln268">void</a>
<a name="ln269">ar5212SetTsf64(struct ath_hal *ah, uint64_t tsf64)</a>
<a name="ln270">{</a>
<a name="ln271">	OS_REG_WRITE(ah, AR_TSF_L32, tsf64 &amp; 0xffffffff);</a>
<a name="ln272">	OS_REG_WRITE(ah, AR_TSF_U32, (tsf64 &gt;&gt; 32) &amp; 0xffffffff);</a>
<a name="ln273">}</a>
<a name="ln274"> </a>
<a name="ln275">/*</a>
<a name="ln276"> * Reset the current hardware tsf for stamlme.</a>
<a name="ln277"> */</a>
<a name="ln278">void</a>
<a name="ln279">ar5212ResetTsf(struct ath_hal *ah)</a>
<a name="ln280">{</a>
<a name="ln281"> </a>
<a name="ln282">	uint32_t val = OS_REG_READ(ah, AR_BEACON);</a>
<a name="ln283"> </a>
<a name="ln284">	OS_REG_WRITE(ah, AR_BEACON, val | AR_BEACON_RESET_TSF);</a>
<a name="ln285">	/*</a>
<a name="ln286">	 * When resetting the TSF, write twice to the</a>
<a name="ln287">	 * corresponding register; each write to the RESET_TSF bit toggles</a>
<a name="ln288">	 * the internal signal to cause a reset of the TSF - but if the signal</a>
<a name="ln289">	 * is left high, it will reset the TSF on the next chip reset also!</a>
<a name="ln290">	 * writing the bit an even number of times fixes this issue</a>
<a name="ln291">	 */</a>
<a name="ln292">	OS_REG_WRITE(ah, AR_BEACON, val | AR_BEACON_RESET_TSF);</a>
<a name="ln293">}</a>
<a name="ln294"> </a>
<a name="ln295">/*</a>
<a name="ln296"> * Set or clear hardware basic rate bit</a>
<a name="ln297"> * Set hardware basic rate set if basic rate is found</a>
<a name="ln298"> * and basic rate is equal or less than 2Mbps</a>
<a name="ln299"> */</a>
<a name="ln300">void</a>
<a name="ln301">ar5212SetBasicRate(struct ath_hal *ah, HAL_RATE_SET *rs)</a>
<a name="ln302">{</a>
<a name="ln303">	const struct ieee80211_channel *chan = AH_PRIVATE(ah)-&gt;ah_curchan;</a>
<a name="ln304">	uint32_t reg;</a>
<a name="ln305">	uint8_t xset;</a>
<a name="ln306">	int i;</a>
<a name="ln307"> </a>
<a name="ln308">	if (chan == AH_NULL || !IEEE80211_IS_CHAN_CCK(chan))</a>
<a name="ln309">		return;</a>
<a name="ln310">	xset = 0;</a>
<a name="ln311">	for (i = 0; i &lt; rs-&gt;rs_count; i++) {</a>
<a name="ln312">		uint8_t rset = rs-&gt;rs_rates[i];</a>
<a name="ln313">		/* Basic rate defined? */</a>
<a name="ln314">		if ((rset &amp; 0x80) &amp;&amp; (rset &amp;= 0x7f) &gt;= xset)</a>
<a name="ln315">			xset = rset;</a>
<a name="ln316">	}</a>
<a name="ln317">	/*</a>
<a name="ln318">	 * Set the h/w bit to reflect whether or not the basic</a>
<a name="ln319">	 * rate is found to be equal or less than 2Mbps.</a>
<a name="ln320">	 */</a>
<a name="ln321">	reg = OS_REG_READ(ah, AR_STA_ID1);</a>
<a name="ln322">	if (xset &amp;&amp; xset/2 &lt;= 2)</a>
<a name="ln323">		OS_REG_WRITE(ah, AR_STA_ID1, reg | AR_STA_ID1_BASE_RATE_11B);</a>
<a name="ln324">	else</a>
<a name="ln325">		OS_REG_WRITE(ah, AR_STA_ID1, reg &amp;~ AR_STA_ID1_BASE_RATE_11B);</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328">/*</a>
<a name="ln329"> * Grab a semi-random value from hardware registers - may not</a>
<a name="ln330"> * change often</a>
<a name="ln331"> */</a>
<a name="ln332">uint32_t</a>
<a name="ln333">ar5212GetRandomSeed(struct ath_hal *ah)</a>
<a name="ln334">{</a>
<a name="ln335">	uint32_t nf;</a>
<a name="ln336"> </a>
<a name="ln337">	nf = (OS_REG_READ(ah, AR_PHY(25)) &gt;&gt; 19) &amp; 0x1ff;</a>
<a name="ln338">	if (nf &amp; 0x100)</a>
<a name="ln339">		nf = 0 - ((nf ^ 0x1ff) + 1);</a>
<a name="ln340">	return (OS_REG_READ(ah, AR_TSF_U32) ^</a>
<a name="ln341">		OS_REG_READ(ah, AR_TSF_L32) ^ nf);</a>
<a name="ln342">}</a>
<a name="ln343"> </a>
<a name="ln344">/*</a>
<a name="ln345"> * Detect if our card is present</a>
<a name="ln346"> */</a>
<a name="ln347">HAL_BOOL</a>
<a name="ln348">ar5212DetectCardPresent(struct ath_hal *ah)</a>
<a name="ln349">{</a>
<a name="ln350">	uint16_t macVersion, macRev;</a>
<a name="ln351">	uint32_t v;</a>
<a name="ln352"> </a>
<a name="ln353">	/*</a>
<a name="ln354">	 * Read the Silicon Revision register and compare that</a>
<a name="ln355">	 * to what we read at attach time.  If the same, we say</a>
<a name="ln356">	 * a card/device is present.</a>
<a name="ln357">	 */</a>
<a name="ln358">	v = OS_REG_READ(ah, AR_SREV) &amp; AR_SREV_ID;</a>
<a name="ln359">	macVersion = v &gt;&gt; AR_SREV_ID_S;</a>
<a name="ln360">	macRev = v &amp; AR_SREV_REVISION;</a>
<a name="ln361">	return (AH_PRIVATE(ah)-&gt;ah_macVersion == macVersion &amp;&amp;</a>
<a name="ln362">		AH_PRIVATE(ah)-&gt;ah_macRev == macRev);</a>
<a name="ln363">}</a>
<a name="ln364"> </a>
<a name="ln365">void</a>
<a name="ln366">ar5212EnableMibCounters(struct ath_hal *ah)</a>
<a name="ln367">{</a>
<a name="ln368">	/* NB: this just resets the mib counter machinery */</a>
<a name="ln369">	OS_REG_WRITE(ah, AR_MIBC,</a>
<a name="ln370">	    ~(AR_MIBC_COW | AR_MIBC_FMC | AR_MIBC_CMC | AR_MIBC_MCS) &amp; 0x0f);</a>
<a name="ln371">}</a>
<a name="ln372"> </a>
<a name="ln373">void </a>
<a name="ln374">ar5212DisableMibCounters(struct ath_hal *ah)</a>
<a name="ln375">{</a>
<a name="ln376">	OS_REG_WRITE(ah, AR_MIBC,  AR_MIBC | AR_MIBC_CMC);</a>
<a name="ln377">}</a>
<a name="ln378"> </a>
<a name="ln379">/*</a>
<a name="ln380"> * Update MIB Counters</a>
<a name="ln381"> */</a>
<a name="ln382">void</a>
<a name="ln383">ar5212UpdateMibCounters(struct ath_hal *ah, HAL_MIB_STATS* stats)</a>
<a name="ln384">{</a>
<a name="ln385">	stats-&gt;ackrcv_bad += OS_REG_READ(ah, AR_ACK_FAIL);</a>
<a name="ln386">	stats-&gt;rts_bad	  += OS_REG_READ(ah, AR_RTS_FAIL);</a>
<a name="ln387">	stats-&gt;fcs_bad	  += OS_REG_READ(ah, AR_FCS_FAIL);</a>
<a name="ln388">	stats-&gt;rts_good	  += OS_REG_READ(ah, AR_RTS_OK);</a>
<a name="ln389">	stats-&gt;beacons	  += OS_REG_READ(ah, AR_BEACON_CNT);</a>
<a name="ln390">}</a>
<a name="ln391"> </a>
<a name="ln392">/*</a>
<a name="ln393"> * Detect if the HW supports spreading a CCK signal on channel 14</a>
<a name="ln394"> */</a>
<a name="ln395">HAL_BOOL</a>
<a name="ln396">ar5212IsJapanChannelSpreadSupported(struct ath_hal *ah)</a>
<a name="ln397">{</a>
<a name="ln398">	return AH_TRUE;</a>
<a name="ln399">}</a>
<a name="ln400"> </a>
<a name="ln401">/*</a>
<a name="ln402"> * Get the rssi of frame curently being received.</a>
<a name="ln403"> */</a>
<a name="ln404">uint32_t</a>
<a name="ln405">ar5212GetCurRssi(struct ath_hal *ah)</a>
<a name="ln406">{</a>
<a name="ln407">	return (OS_REG_READ(ah, AR_PHY_CURRENT_RSSI) &amp; 0xff);</a>
<a name="ln408">}</a>
<a name="ln409"> </a>
<a name="ln410">u_int</a>
<a name="ln411">ar5212GetDefAntenna(struct ath_hal *ah)</a>
<a name="ln412">{   </a>
<a name="ln413">	return (OS_REG_READ(ah, AR_DEF_ANTENNA) &amp; 0x7);</a>
<a name="ln414">}   </a>
<a name="ln415"> </a>
<a name="ln416">void</a>
<a name="ln417">ar5212SetDefAntenna(struct ath_hal *ah, u_int antenna)</a>
<a name="ln418">{</a>
<a name="ln419">	OS_REG_WRITE(ah, AR_DEF_ANTENNA, (antenna &amp; 0x7));</a>
<a name="ln420">}</a>
<a name="ln421"> </a>
<a name="ln422">HAL_ANT_SETTING</a>
<a name="ln423">ar5212GetAntennaSwitch(struct ath_hal *ah)</a>
<a name="ln424">{</a>
<a name="ln425">	return AH5212(ah)-&gt;ah_antControl;</a>
<a name="ln426">}</a>
<a name="ln427"> </a>
<a name="ln428">HAL_BOOL</a>
<a name="ln429">ar5212SetAntennaSwitch(struct ath_hal *ah, HAL_ANT_SETTING setting)</a>
<a name="ln430">{</a>
<a name="ln431">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln432">	const struct ieee80211_channel *chan = AH_PRIVATE(ah)-&gt;ah_curchan;</a>
<a name="ln433"> </a>
<a name="ln434">	if (!ahp-&gt;ah_phyPowerOn || chan == AH_NULL) {</a>
<a name="ln435">		/* PHY powered off, just stash settings */</a>
<a name="ln436">		ahp-&gt;ah_antControl = setting;</a>
<a name="ln437">		ahp-&gt;ah_diversity = (setting == HAL_ANT_VARIABLE);</a>
<a name="ln438">		return AH_TRUE;</a>
<a name="ln439">	}</a>
<a name="ln440">	return ar5212SetAntennaSwitchInternal(ah, setting, chan);</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443">HAL_BOOL</a>
<a name="ln444">ar5212IsSleepAfterBeaconBroken(struct ath_hal *ah)</a>
<a name="ln445">{</a>
<a name="ln446">	return AH_TRUE;</a>
<a name="ln447">}</a>
<a name="ln448"> </a>
<a name="ln449">HAL_BOOL</a>
<a name="ln450">ar5212SetSifsTime(struct ath_hal *ah, u_int us)</a>
<a name="ln451">{</a>
<a name="ln452">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln453"> </a>
<a name="ln454">	if (us &gt; ath_hal_mac_usec(ah, 0xffff)) {</a>
<a name="ln455">		HALDEBUG(ah, HAL_DEBUG_ANY, &quot;%s: bad SIFS time %u\n&quot;,</a>
<a name="ln456">		    __func__, us);</a>
<a name="ln457">		ahp-&gt;ah_sifstime = (u_int) -1;	/* restore default handling */</a>
<a name="ln458">		return AH_FALSE;</a>
<a name="ln459">	} else {</a>
<a name="ln460">		/* convert to system clocks */</a>
<a name="ln461">		OS_REG_WRITE(ah, AR_D_GBL_IFS_SIFS, ath_hal_mac_clks(ah, us-2));</a>
<a name="ln462">		ahp-&gt;ah_sifstime = us;</a>
<a name="ln463">		return AH_TRUE;</a>
<a name="ln464">	}</a>
<a name="ln465">}</a>
<a name="ln466"> </a>
<a name="ln467">u_int</a>
<a name="ln468">ar5212GetSifsTime(struct ath_hal *ah)</a>
<a name="ln469">{</a>
<a name="ln470">	u_int clks = OS_REG_READ(ah, AR_D_GBL_IFS_SIFS) &amp; 0xffff;</a>
<a name="ln471">	return ath_hal_mac_usec(ah, clks)+2;	/* convert from system clocks */</a>
<a name="ln472">}</a>
<a name="ln473"> </a>
<a name="ln474">HAL_BOOL</a>
<a name="ln475">ar5212SetSlotTime(struct ath_hal *ah, u_int us)</a>
<a name="ln476">{</a>
<a name="ln477">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln478"> </a>
<a name="ln479">	if (us &lt; HAL_SLOT_TIME_6 || us &gt; ath_hal_mac_usec(ah, 0xffff)) {</a>
<a name="ln480">		HALDEBUG(ah, HAL_DEBUG_ANY, &quot;%s: bad slot time %u\n&quot;,</a>
<a name="ln481">		    __func__, us);</a>
<a name="ln482">		ahp-&gt;ah_slottime = (u_int) -1;	/* restore default handling */</a>
<a name="ln483">		return AH_FALSE;</a>
<a name="ln484">	} else {</a>
<a name="ln485">		/* convert to system clocks */</a>
<a name="ln486">		OS_REG_WRITE(ah, AR_D_GBL_IFS_SLOT, ath_hal_mac_clks(ah, us));</a>
<a name="ln487">		ahp-&gt;ah_slottime = us;</a>
<a name="ln488">		return AH_TRUE;</a>
<a name="ln489">	}</a>
<a name="ln490">}</a>
<a name="ln491"> </a>
<a name="ln492">u_int</a>
<a name="ln493">ar5212GetSlotTime(struct ath_hal *ah)</a>
<a name="ln494">{</a>
<a name="ln495">	u_int clks = OS_REG_READ(ah, AR_D_GBL_IFS_SLOT) &amp; 0xffff;</a>
<a name="ln496">	return ath_hal_mac_usec(ah, clks);	/* convert from system clocks */</a>
<a name="ln497">}</a>
<a name="ln498"> </a>
<a name="ln499">HAL_BOOL</a>
<a name="ln500">ar5212SetAckTimeout(struct ath_hal *ah, u_int us)</a>
<a name="ln501">{</a>
<a name="ln502">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln503"> </a>
<a name="ln504">	if (us &gt; ath_hal_mac_usec(ah, MS(0xffffffff, AR_TIME_OUT_ACK))) {</a>
<a name="ln505">		HALDEBUG(ah, HAL_DEBUG_ANY, &quot;%s: bad ack timeout %u\n&quot;,</a>
<a name="ln506">		    __func__, us);</a>
<a name="ln507">		ahp-&gt;ah_acktimeout = (u_int) -1; /* restore default handling */</a>
<a name="ln508">		return AH_FALSE;</a>
<a name="ln509">	} else {</a>
<a name="ln510">		/* convert to system clocks */</a>
<a name="ln511">		OS_REG_RMW_FIELD(ah, AR_TIME_OUT,</a>
<a name="ln512">			AR_TIME_OUT_ACK, ath_hal_mac_clks(ah, us));</a>
<a name="ln513">		ahp-&gt;ah_acktimeout = us;</a>
<a name="ln514">		return AH_TRUE;</a>
<a name="ln515">	}</a>
<a name="ln516">}</a>
<a name="ln517"> </a>
<a name="ln518">u_int</a>
<a name="ln519">ar5212GetAckTimeout(struct ath_hal *ah)</a>
<a name="ln520">{</a>
<a name="ln521">	u_int clks = MS(OS_REG_READ(ah, AR_TIME_OUT), AR_TIME_OUT_ACK);</a>
<a name="ln522">	return ath_hal_mac_usec(ah, clks);	/* convert from system clocks */</a>
<a name="ln523">}</a>
<a name="ln524"> </a>
<a name="ln525">u_int</a>
<a name="ln526">ar5212GetAckCTSRate(struct ath_hal *ah)</a>
<a name="ln527">{</a>
<a name="ln528">	return ((AH5212(ah)-&gt;ah_staId1Defaults &amp; AR_STA_ID1_ACKCTS_6MB) == 0);</a>
<a name="ln529">}</a>
<a name="ln530"> </a>
<a name="ln531">HAL_BOOL</a>
<a name="ln532">ar5212SetAckCTSRate(struct ath_hal *ah, u_int high)</a>
<a name="ln533">{</a>
<a name="ln534">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln535"> </a>
<a name="ln536">	if (high) {</a>
<a name="ln537">		OS_REG_CLR_BIT(ah, AR_STA_ID1, AR_STA_ID1_ACKCTS_6MB);</a>
<a name="ln538">		ahp-&gt;ah_staId1Defaults &amp;= ~AR_STA_ID1_ACKCTS_6MB;</a>
<a name="ln539">	} else {</a>
<a name="ln540">		OS_REG_SET_BIT(ah, AR_STA_ID1, AR_STA_ID1_ACKCTS_6MB);</a>
<a name="ln541">		ahp-&gt;ah_staId1Defaults |= AR_STA_ID1_ACKCTS_6MB;</a>
<a name="ln542">	}</a>
<a name="ln543">	return AH_TRUE;</a>
<a name="ln544">}</a>
<a name="ln545"> </a>
<a name="ln546">HAL_BOOL</a>
<a name="ln547">ar5212SetCTSTimeout(struct ath_hal *ah, u_int us)</a>
<a name="ln548">{</a>
<a name="ln549">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln550"> </a>
<a name="ln551">	if (us &gt; ath_hal_mac_usec(ah, MS(0xffffffff, AR_TIME_OUT_CTS))) {</a>
<a name="ln552">		HALDEBUG(ah, HAL_DEBUG_ANY, &quot;%s: bad cts timeout %u\n&quot;,</a>
<a name="ln553">		    __func__, us);</a>
<a name="ln554">		ahp-&gt;ah_ctstimeout = (u_int) -1; /* restore default handling */</a>
<a name="ln555">		return AH_FALSE;</a>
<a name="ln556">	} else {</a>
<a name="ln557">		/* convert to system clocks */</a>
<a name="ln558">		OS_REG_RMW_FIELD(ah, AR_TIME_OUT,</a>
<a name="ln559">			AR_TIME_OUT_CTS, ath_hal_mac_clks(ah, us));</a>
<a name="ln560">		ahp-&gt;ah_ctstimeout = us;</a>
<a name="ln561">		return AH_TRUE;</a>
<a name="ln562">	}</a>
<a name="ln563">}</a>
<a name="ln564"> </a>
<a name="ln565">u_int</a>
<a name="ln566">ar5212GetCTSTimeout(struct ath_hal *ah)</a>
<a name="ln567">{</a>
<a name="ln568">	u_int clks = MS(OS_REG_READ(ah, AR_TIME_OUT), AR_TIME_OUT_CTS);</a>
<a name="ln569">	return ath_hal_mac_usec(ah, clks);	/* convert from system clocks */</a>
<a name="ln570">}</a>
<a name="ln571"> </a>
<a name="ln572">/* Setup decompression for given key index */</a>
<a name="ln573">HAL_BOOL</a>
<a name="ln574">ar5212SetDecompMask(struct ath_hal *ah, uint16_t keyidx, int en)</a>
<a name="ln575">{</a>
<a name="ln576">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln577"> </a>
<a name="ln578">        if (keyidx &gt;= HAL_DECOMP_MASK_SIZE)</a>
<a name="ln579">                return AH_FALSE;</a>
<a name="ln580">        OS_REG_WRITE(ah, AR_DCM_A, keyidx);</a>
<a name="ln581">        OS_REG_WRITE(ah, AR_DCM_D, en ? AR_DCM_D_EN : 0);</a>
<a name="ln582">        ahp-&gt;ah_decompMask[keyidx] = en;</a>
<a name="ln583"> </a>
<a name="ln584">        return AH_TRUE;</a>
<a name="ln585">}</a>
<a name="ln586"> </a>
<a name="ln587">/* Setup coverage class */</a>
<a name="ln588">void</a>
<a name="ln589">ar5212SetCoverageClass(struct ath_hal *ah, uint8_t coverageclass, int now)</a>
<a name="ln590">{</a>
<a name="ln591">	uint32_t slot, timeout, eifs;</a>
<a name="ln592">	u_int clkRate;</a>
<a name="ln593"> </a>
<a name="ln594">	AH_PRIVATE(ah)-&gt;ah_coverageClass = coverageclass;</a>
<a name="ln595"> </a>
<a name="ln596">	if (now) {</a>
<a name="ln597">		if (AH_PRIVATE(ah)-&gt;ah_coverageClass == 0)</a>
<a name="ln598">			return;</a>
<a name="ln599"> </a>
<a name="ln600">		/* Don't apply coverage class to non A channels */</a>
<a name="ln601">		if (!IEEE80211_IS_CHAN_A(AH_PRIVATE(ah)-&gt;ah_curchan))</a>
<a name="ln602">			return;</a>
<a name="ln603"> </a>
<a name="ln604">		/* Get core clock rate */</a>
<a name="ln605">		clkRate = ath_hal_mac_clks(ah, 1);</a>
<a name="ln606"> </a>
<a name="ln607">		/* Compute EIFS */</a>
<a name="ln608">		slot = coverageclass * 3 * clkRate;</a>
<a name="ln609">		eifs = coverageclass * 6 * clkRate;</a>
<a name="ln610">		if (IEEE80211_IS_CHAN_HALF(AH_PRIVATE(ah)-&gt;ah_curchan)) {</a>
<a name="ln611">			slot += IFS_SLOT_HALF_RATE;</a>
<a name="ln612">			eifs += IFS_EIFS_HALF_RATE;</a>
<a name="ln613">		} else if (IEEE80211_IS_CHAN_QUARTER(AH_PRIVATE(ah)-&gt;ah_curchan)) {</a>
<a name="ln614">			slot += IFS_SLOT_QUARTER_RATE;</a>
<a name="ln615">			eifs += IFS_EIFS_QUARTER_RATE;</a>
<a name="ln616">		} else { /* full rate */</a>
<a name="ln617">			slot += IFS_SLOT_FULL_RATE;</a>
<a name="ln618">			eifs += IFS_EIFS_FULL_RATE;</a>
<a name="ln619">		}</a>
<a name="ln620"> </a>
<a name="ln621">		/*</a>
<a name="ln622">		 * Add additional time for air propagation for ACK and CTS</a>
<a name="ln623">		 * timeouts. This value is in core clocks.</a>
<a name="ln624">  		 */</a>
<a name="ln625">		timeout = ACK_CTS_TIMEOUT_11A + (coverageclass * 3 * clkRate);</a>
<a name="ln626">	</a>
<a name="ln627">		/*</a>
<a name="ln628">		 * Write the values: slot, eifs, ack/cts timeouts.</a>
<a name="ln629">		 */</a>
<a name="ln630">		OS_REG_WRITE(ah, AR_D_GBL_IFS_SLOT, slot);</a>
<a name="ln631">		OS_REG_WRITE(ah, AR_D_GBL_IFS_EIFS, eifs);</a>
<a name="ln632">		OS_REG_WRITE(ah, AR_TIME_OUT,</a>
<a name="ln633">			  SM(timeout, AR_TIME_OUT_CTS)</a>
<a name="ln634">			| SM(timeout, AR_TIME_OUT_ACK));</a>
<a name="ln635">	}</a>
<a name="ln636">}</a>
<a name="ln637"> </a>
<a name="ln638">HAL_STATUS</a>
<a name="ln639">ar5212SetQuiet(struct ath_hal *ah, uint32_t period, uint32_t duration,</a>
<a name="ln640">    uint32_t nextStart, HAL_QUIET_FLAG flag)</a>
<a name="ln641">{</a>
<a name="ln642">	OS_REG_WRITE(ah, AR_QUIET2, period | (duration &lt;&lt; AR_QUIET2_QUIET_DUR_S));</a>
<a name="ln643">	if (flag &amp; HAL_QUIET_ENABLE) {</a>
<a name="ln644">		OS_REG_WRITE(ah, AR_QUIET1, nextStart | (1 &lt;&lt; 16));</a>
<a name="ln645">	}</a>
<a name="ln646">	else {</a>
<a name="ln647">		OS_REG_WRITE(ah, AR_QUIET1, nextStart);</a>
<a name="ln648">	}</a>
<a name="ln649">	return HAL_OK;</a>
<a name="ln650">}</a>
<a name="ln651"> </a>
<a name="ln652">void</a>
<a name="ln653">ar5212SetPCUConfig(struct ath_hal *ah)</a>
<a name="ln654">{</a>
<a name="ln655">	ar5212SetOperatingMode(ah, AH_PRIVATE(ah)-&gt;ah_opmode);</a>
<a name="ln656">}</a>
<a name="ln657"> </a>
<a name="ln658">/*</a>
<a name="ln659"> * Return whether an external 32KHz crystal should be used</a>
<a name="ln660"> * to reduce power consumption when sleeping.  We do so if</a>
<a name="ln661"> * the crystal is present (obtained from EEPROM) and if we</a>
<a name="ln662"> * are not running as an AP and are configured to use it.</a>
<a name="ln663"> */</a>
<a name="ln664">HAL_BOOL</a>
<a name="ln665">ar5212Use32KHzclock(struct ath_hal *ah, HAL_OPMODE opmode)</a>
<a name="ln666">{</a>
<a name="ln667">	if (opmode != HAL_M_HOSTAP) {</a>
<a name="ln668">		struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln669">		return ath_hal_eepromGetFlag(ah, AR_EEP_32KHZCRYSTAL) &amp;&amp;</a>
<a name="ln670">		       (ahp-&gt;ah_enable32kHzClock == USE_32KHZ ||</a>
<a name="ln671">		        ahp-&gt;ah_enable32kHzClock == AUTO_32KHZ);</a>
<a name="ln672">	} else</a>
<a name="ln673">		return AH_FALSE;</a>
<a name="ln674">}</a>
<a name="ln675"> </a>
<a name="ln676">/*</a>
<a name="ln677"> * If 32KHz clock exists, use it to lower power consumption during sleep</a>
<a name="ln678"> *</a>
<a name="ln679"> * Note: If clock is set to 32 KHz, delays on accessing certain</a>
<a name="ln680"> *       baseband registers (27-31, 124-127) are required.</a>
<a name="ln681"> */</a>
<a name="ln682">void</a>
<a name="ln683">ar5212SetupClock(struct ath_hal *ah, HAL_OPMODE opmode)</a>
<a name="ln684">{</a>
<a name="ln685">	if (ar5212Use32KHzclock(ah, opmode)) {</a>
<a name="ln686">		/*</a>
<a name="ln687">		 * Enable clocks to be turned OFF in BB during sleep</a>
<a name="ln688">		 * and also enable turning OFF 32MHz/40MHz Refclk</a>
<a name="ln689">		 * from A2.</a>
<a name="ln690">		 */</a>
<a name="ln691">		OS_REG_WRITE(ah, AR_PHY_SLEEP_CTR_CONTROL, 0x1f);</a>
<a name="ln692">		OS_REG_WRITE(ah, AR_PHY_REFCLKPD,</a>
<a name="ln693">		    IS_RAD5112_ANY(ah) || IS_5413(ah) ? 0x14 : 0x18);</a>
<a name="ln694">		OS_REG_RMW_FIELD(ah, AR_USEC, AR_USEC_USEC32, 1);</a>
<a name="ln695">		OS_REG_WRITE(ah, AR_TSF_PARM, 61);  /* 32 KHz TSF incr */</a>
<a name="ln696">		OS_REG_RMW_FIELD(ah, AR_PCICFG, AR_PCICFG_SCLK_SEL, 1);</a>
<a name="ln697"> </a>
<a name="ln698">		if (IS_2413(ah) || IS_5413(ah) || IS_2417(ah)) {</a>
<a name="ln699">			OS_REG_WRITE(ah, AR_PHY_SLEEP_CTR_LIMIT,   0x26);</a>
<a name="ln700">			OS_REG_WRITE(ah, AR_PHY_SLEEP_SCAL,        0x0d);</a>
<a name="ln701">			OS_REG_WRITE(ah, AR_PHY_M_SLEEP,           0x07);</a>
<a name="ln702">			OS_REG_WRITE(ah, AR_PHY_REFCLKDLY,         0x3f);</a>
<a name="ln703">			/* # Set sleep clock rate to 32 KHz. */</a>
<a name="ln704">			OS_REG_RMW_FIELD(ah, AR_PCICFG, AR_PCICFG_SCLK_RATE_IND, 0x2);</a>
<a name="ln705">		} else {</a>
<a name="ln706">			OS_REG_WRITE(ah, AR_PHY_SLEEP_CTR_LIMIT,   0x0a);</a>
<a name="ln707">			OS_REG_WRITE(ah, AR_PHY_SLEEP_SCAL,        0x0c);</a>
<a name="ln708">			OS_REG_WRITE(ah, AR_PHY_M_SLEEP,           0x03);</a>
<a name="ln709">			OS_REG_WRITE(ah, AR_PHY_REFCLKDLY,         0x20);</a>
<a name="ln710">			OS_REG_RMW_FIELD(ah, AR_PCICFG, AR_PCICFG_SCLK_RATE_IND, 0x3);</a>
<a name="ln711">		}</a>
<a name="ln712">	} else {</a>
<a name="ln713">		OS_REG_RMW_FIELD(ah, AR_PCICFG, AR_PCICFG_SCLK_RATE_IND, 0x0);</a>
<a name="ln714">		OS_REG_RMW_FIELD(ah, AR_PCICFG, AR_PCICFG_SCLK_SEL, 0);</a>
<a name="ln715"> </a>
<a name="ln716">		OS_REG_WRITE(ah, AR_TSF_PARM, 1);	/* 32MHz TSF inc */</a>
<a name="ln717"> </a>
<a name="ln718">		OS_REG_WRITE(ah, AR_PHY_SLEEP_CTR_CONTROL, 0x1f);</a>
<a name="ln719">		OS_REG_WRITE(ah, AR_PHY_SLEEP_CTR_LIMIT,   0x7f);</a>
<a name="ln720"> </a>
<a name="ln721">		if (IS_2417(ah))</a>
<a name="ln722">			OS_REG_WRITE(ah, AR_PHY_SLEEP_SCAL, 0x0a);</a>
<a name="ln723">		else if (IS_HB63(ah))</a>
<a name="ln724">			OS_REG_WRITE(ah, AR_PHY_SLEEP_SCAL, 0x32);</a>
<a name="ln725">		else</a>
<a name="ln726">			OS_REG_WRITE(ah, AR_PHY_SLEEP_SCAL, 0x0e);</a>
<a name="ln727">		OS_REG_WRITE(ah, AR_PHY_M_SLEEP,           0x0c);</a>
<a name="ln728">		OS_REG_WRITE(ah, AR_PHY_REFCLKDLY,         0xff);</a>
<a name="ln729">		OS_REG_WRITE(ah, AR_PHY_REFCLKPD,</a>
<a name="ln730">		    IS_RAD5112_ANY(ah) || IS_5413(ah) || IS_2417(ah) ? 0x14 : 0x18);</a>
<a name="ln731">		OS_REG_RMW_FIELD(ah, AR_USEC, AR_USEC_USEC32,</a>
<a name="ln732">		    IS_RAD5112_ANY(ah) || IS_5413(ah) ? 39 : 31);</a>
<a name="ln733">	}</a>
<a name="ln734">}</a>
<a name="ln735"> </a>
<a name="ln736">/*</a>
<a name="ln737"> * If 32KHz clock exists, turn it off and turn back on the 32Mhz</a>
<a name="ln738"> */</a>
<a name="ln739">void</a>
<a name="ln740">ar5212RestoreClock(struct ath_hal *ah, HAL_OPMODE opmode)</a>
<a name="ln741">{</a>
<a name="ln742">	if (ar5212Use32KHzclock(ah, opmode)) {</a>
<a name="ln743">		/* # Set sleep clock rate back to 32 MHz. */</a>
<a name="ln744">		OS_REG_RMW_FIELD(ah, AR_PCICFG, AR_PCICFG_SCLK_RATE_IND, 0);</a>
<a name="ln745">		OS_REG_RMW_FIELD(ah, AR_PCICFG, AR_PCICFG_SCLK_SEL, 0);</a>
<a name="ln746"> </a>
<a name="ln747">		OS_REG_WRITE(ah, AR_TSF_PARM, 1);	/* 32 MHz TSF incr */</a>
<a name="ln748">		OS_REG_RMW_FIELD(ah, AR_USEC, AR_USEC_USEC32,</a>
<a name="ln749">		    IS_RAD5112_ANY(ah) || IS_5413(ah) ? 39 : 31);</a>
<a name="ln750"> </a>
<a name="ln751">		/*</a>
<a name="ln752">		 * Restore BB registers to power-on defaults</a>
<a name="ln753">		 */</a>
<a name="ln754">		OS_REG_WRITE(ah, AR_PHY_SLEEP_CTR_CONTROL, 0x1f);</a>
<a name="ln755">		OS_REG_WRITE(ah, AR_PHY_SLEEP_CTR_LIMIT,   0x7f);</a>
<a name="ln756">		OS_REG_WRITE(ah, AR_PHY_SLEEP_SCAL,        0x0e);</a>
<a name="ln757">		OS_REG_WRITE(ah, AR_PHY_M_SLEEP,           0x0c);</a>
<a name="ln758">		OS_REG_WRITE(ah, AR_PHY_REFCLKDLY,         0xff);</a>
<a name="ln759">		OS_REG_WRITE(ah, AR_PHY_REFCLKPD,</a>
<a name="ln760">		    IS_RAD5112_ANY(ah) || IS_5413(ah) ?  0x14 : 0x18);</a>
<a name="ln761">	}</a>
<a name="ln762">}</a>
<a name="ln763"> </a>
<a name="ln764">/*</a>
<a name="ln765"> * Adjust NF based on statistical values for 5GHz frequencies.</a>
<a name="ln766"> * Default method: this may be overridden by the rf backend.</a>
<a name="ln767"> */</a>
<a name="ln768">int16_t</a>
<a name="ln769">ar5212GetNfAdjust(struct ath_hal *ah, const HAL_CHANNEL_INTERNAL *c)</a>
<a name="ln770">{</a>
<a name="ln771">	static const struct {</a>
<a name="ln772">		uint16_t freqLow;</a>
<a name="ln773">		int16_t	  adjust;</a>
<a name="ln774">	} adjustDef[] = {</a>
<a name="ln775">		{ 5790,	11 },	/* NB: ordered high -&gt; low */</a>
<a name="ln776">		{ 5730, 10 },</a>
<a name="ln777">		{ 5690,  9 },</a>
<a name="ln778">		{ 5660,  8 },</a>
<a name="ln779">		{ 5610,  7 },</a>
<a name="ln780">		{ 5530,  5 },</a>
<a name="ln781">		{ 5450,  4 },</a>
<a name="ln782">		{ 5379,  2 },</a>
<a name="ln783">		{ 5209,  0 },</a>
<a name="ln784">		{ 3000,  1 },</a>
<a name="ln785">		{    0,  0 },</a>
<a name="ln786">	};</a>
<a name="ln787">	int i;</a>
<a name="ln788"> </a>
<a name="ln789">	for (i = 0; c-&gt;channel &lt;= adjustDef[i].freqLow; i++)</a>
<a name="ln790">		;</a>
<a name="ln791">	return adjustDef[i].adjust;</a>
<a name="ln792">}</a>
<a name="ln793"> </a>
<a name="ln794">HAL_STATUS</a>
<a name="ln795">ar5212GetCapability(struct ath_hal *ah, HAL_CAPABILITY_TYPE type,</a>
<a name="ln796">	uint32_t capability, uint32_t *result)</a>
<a name="ln797">{</a>
<a name="ln798">#define	MACVERSION(ah)	AH_PRIVATE(ah)-&gt;ah_macVersion</a>
<a name="ln799">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln800">	const HAL_CAPABILITIES *pCap = &amp;AH_PRIVATE(ah)-&gt;ah_caps;</a>
<a name="ln801">	const struct ar5212AniState *ani;</a>
<a name="ln802"> </a>
<a name="ln803">	switch (type) {</a>
<a name="ln804">	case HAL_CAP_CIPHER:		/* cipher handled in hardware */</a>
<a name="ln805">		switch (capability) {</a>
<a name="ln806">		case HAL_CIPHER_AES_CCM:</a>
<a name="ln807">			return pCap-&gt;halCipherAesCcmSupport ?</a>
<a name="ln808">				HAL_OK : HAL_ENOTSUPP;</a>
<a name="ln809">		case HAL_CIPHER_AES_OCB:</a>
<a name="ln810">		case HAL_CIPHER_TKIP:</a>
<a name="ln811">		case HAL_CIPHER_WEP:</a>
<a name="ln812">		case HAL_CIPHER_MIC:</a>
<a name="ln813">		case HAL_CIPHER_CLR:</a>
<a name="ln814">			return HAL_OK;</a>
<a name="ln815">		default:</a>
<a name="ln816">			return HAL_ENOTSUPP;</a>
<a name="ln817">		}</a>
<a name="ln818">	case HAL_CAP_TKIP_MIC:		/* handle TKIP MIC in hardware */</a>
<a name="ln819">		switch (capability) {</a>
<a name="ln820">		case 0:			/* hardware capability */</a>
<a name="ln821">			return HAL_OK;</a>
<a name="ln822">		case 1:</a>
<a name="ln823">			return (ahp-&gt;ah_staId1Defaults &amp;</a>
<a name="ln824">			    AR_STA_ID1_CRPT_MIC_ENABLE) ?  HAL_OK : HAL_ENXIO;</a>
<a name="ln825">		}</a>
<a name="ln826">		return HAL_EINVAL;</a>
<a name="ln827">	case HAL_CAP_TKIP_SPLIT:	/* hardware TKIP uses split keys */</a>
<a name="ln828">		switch (capability) {</a>
<a name="ln829">		case 0:			/* hardware capability */</a>
<a name="ln830">			return pCap-&gt;halTkipMicTxRxKeySupport ?</a>
<a name="ln831">				HAL_ENXIO : HAL_OK;</a>
<a name="ln832">		case 1:			/* current setting */</a>
<a name="ln833">			return (ahp-&gt;ah_miscMode &amp;</a>
<a name="ln834">			    AR_MISC_MODE_MIC_NEW_LOC_ENABLE) ? HAL_ENXIO : HAL_OK;</a>
<a name="ln835">		}</a>
<a name="ln836">		return HAL_EINVAL;</a>
<a name="ln837">	case HAL_CAP_WME_TKIPMIC:	/* hardware can do TKIP MIC w/ WMM */</a>
<a name="ln838">		/* XXX move to capability bit */</a>
<a name="ln839">		return MACVERSION(ah) &gt; AR_SREV_VERSION_VENICE ||</a>
<a name="ln840">		    (MACVERSION(ah) == AR_SREV_VERSION_VENICE &amp;&amp;</a>
<a name="ln841">		     AH_PRIVATE(ah)-&gt;ah_macRev &gt;= 8) ? HAL_OK : HAL_ENOTSUPP;</a>
<a name="ln842">	case HAL_CAP_DIVERSITY:		/* hardware supports fast diversity */</a>
<a name="ln843">		switch (capability) {</a>
<a name="ln844">		case 0:			/* hardware capability */</a>
<a name="ln845">			return HAL_OK;</a>
<a name="ln846">		case 1:			/* current setting */</a>
<a name="ln847">			return ahp-&gt;ah_diversity ? HAL_OK : HAL_ENXIO;</a>
<a name="ln848">		case HAL_CAP_STRONG_DIV:</a>
<a name="ln849">			*result = OS_REG_READ(ah, AR_PHY_RESTART);</a>
<a name="ln850">			*result = MS(*result, AR_PHY_RESTART_DIV_GC);</a>
<a name="ln851">			return HAL_OK;</a>
<a name="ln852">		}</a>
<a name="ln853">		return HAL_EINVAL;</a>
<a name="ln854">	case HAL_CAP_DIAG:</a>
<a name="ln855">		*result = AH_PRIVATE(ah)-&gt;ah_diagreg;</a>
<a name="ln856">		return HAL_OK;</a>
<a name="ln857">	case HAL_CAP_TPC:</a>
<a name="ln858">		switch (capability) {</a>
<a name="ln859">		case 0:			/* hardware capability */</a>
<a name="ln860">			return HAL_OK;</a>
<a name="ln861">		case 1:</a>
<a name="ln862">			return ahp-&gt;ah_tpcEnabled ? HAL_OK : HAL_ENXIO;</a>
<a name="ln863">		}</a>
<a name="ln864">		return HAL_OK;</a>
<a name="ln865">	case HAL_CAP_PHYDIAG:		/* radar pulse detection capability */</a>
<a name="ln866">		switch (capability) {</a>
<a name="ln867">		case HAL_CAP_RADAR:</a>
<a name="ln868">			return ath_hal_eepromGetFlag(ah, AR_EEP_AMODE) ?</a>
<a name="ln869">			    HAL_OK: HAL_ENXIO;</a>
<a name="ln870">		case HAL_CAP_AR:</a>
<a name="ln871">			return (ath_hal_eepromGetFlag(ah, AR_EEP_GMODE) ||</a>
<a name="ln872">			    ath_hal_eepromGetFlag(ah, AR_EEP_BMODE)) ?</a>
<a name="ln873">			       HAL_OK: HAL_ENXIO;</a>
<a name="ln874">		}</a>
<a name="ln875">		return HAL_ENXIO;</a>
<a name="ln876">	case HAL_CAP_MCAST_KEYSRCH:	/* multicast frame keycache search */</a>
<a name="ln877">		switch (capability) {</a>
<a name="ln878">		case 0:			/* hardware capability */</a>
<a name="ln879">			return pCap-&gt;halMcastKeySrchSupport ? HAL_OK : HAL_ENXIO;</a>
<a name="ln880">		case 1:</a>
<a name="ln881">			return (ahp-&gt;ah_staId1Defaults &amp;</a>
<a name="ln882">			    AR_STA_ID1_MCAST_KSRCH) ? HAL_OK : HAL_ENXIO;</a>
<a name="ln883">		}</a>
<a name="ln884">		return HAL_EINVAL;</a>
<a name="ln885">	case HAL_CAP_TSF_ADJUST:	/* hardware has beacon tsf adjust */</a>
<a name="ln886">		switch (capability) {</a>
<a name="ln887">		case 0:			/* hardware capability */</a>
<a name="ln888">			return pCap-&gt;halTsfAddSupport ? HAL_OK : HAL_ENOTSUPP;</a>
<a name="ln889">		case 1:</a>
<a name="ln890">			return (ahp-&gt;ah_miscMode &amp; AR_MISC_MODE_TX_ADD_TSF) ?</a>
<a name="ln891">				HAL_OK : HAL_ENXIO;</a>
<a name="ln892">		}</a>
<a name="ln893">		return HAL_EINVAL;</a>
<a name="ln894">	case HAL_CAP_TPC_ACK:</a>
<a name="ln895">		*result = MS(ahp-&gt;ah_macTPC, AR_TPC_ACK);</a>
<a name="ln896">		return HAL_OK;</a>
<a name="ln897">	case HAL_CAP_TPC_CTS:</a>
<a name="ln898">		*result = MS(ahp-&gt;ah_macTPC, AR_TPC_CTS);</a>
<a name="ln899">		return HAL_OK;</a>
<a name="ln900">	case HAL_CAP_INTMIT:		/* interference mitigation */</a>
<a name="ln901">		switch (capability) {</a>
<a name="ln902">		case HAL_CAP_INTMIT_PRESENT:		/* hardware capability */</a>
<a name="ln903">			return HAL_OK;</a>
<a name="ln904">		case HAL_CAP_INTMIT_ENABLE:</a>
<a name="ln905">			return (ahp-&gt;ah_procPhyErr &amp; HAL_ANI_ENA) ?</a>
<a name="ln906">				HAL_OK : HAL_ENXIO;</a>
<a name="ln907">		case HAL_CAP_INTMIT_NOISE_IMMUNITY_LEVEL:</a>
<a name="ln908">		case HAL_CAP_INTMIT_OFDM_WEAK_SIGNAL_LEVEL:</a>
<a name="ln909">		case HAL_CAP_INTMIT_CCK_WEAK_SIGNAL_THR:</a>
<a name="ln910">		case HAL_CAP_INTMIT_FIRSTEP_LEVEL:</a>
<a name="ln911">		case HAL_CAP_INTMIT_SPUR_IMMUNITY_LEVEL:</a>
<a name="ln912">			ani = ar5212AniGetCurrentState(ah);</a>
<a name="ln913">			if (ani == AH_NULL)</a>
<a name="ln914">				return HAL_ENXIO;</a>
<a name="ln915">			switch (capability) {</a>
<a name="ln916">			case 2:	*result = ani-&gt;noiseImmunityLevel; break;</a>
<a name="ln917">			case 3: *result = !ani-&gt;ofdmWeakSigDetectOff; break;</a>
<a name="ln918">			case 4: *result = ani-&gt;cckWeakSigThreshold; break;</a>
<a name="ln919">			case 5: *result = ani-&gt;firstepLevel; break;</a>
<a name="ln920">			case 6: *result = ani-&gt;spurImmunityLevel; break;</a>
<a name="ln921">			}</a>
<a name="ln922">			return HAL_OK;</a>
<a name="ln923">		}</a>
<a name="ln924">		return HAL_EINVAL;</a>
<a name="ln925">	default:</a>
<a name="ln926">		return ath_hal_getcapability(ah, type, capability, result);</a>
<a name="ln927">	}</a>
<a name="ln928">#undef MACVERSION</a>
<a name="ln929">}</a>
<a name="ln930"> </a>
<a name="ln931">HAL_BOOL</a>
<a name="ln932">ar5212SetCapability(struct ath_hal *ah, HAL_CAPABILITY_TYPE type,</a>
<a name="ln933">	uint32_t capability, uint32_t setting, HAL_STATUS *status)</a>
<a name="ln934">{</a>
<a name="ln935">#define	N(a)	(sizeof(a)/sizeof(a[0]))</a>
<a name="ln936">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln937">	const HAL_CAPABILITIES *pCap = &amp;AH_PRIVATE(ah)-&gt;ah_caps;</a>
<a name="ln938">	uint32_t v;</a>
<a name="ln939"> </a>
<a name="ln940">	switch (type) {</a>
<a name="ln941">	case HAL_CAP_TKIP_MIC:		/* handle TKIP MIC in hardware */</a>
<a name="ln942">		if (setting)</a>
<a name="ln943">			ahp-&gt;ah_staId1Defaults |= AR_STA_ID1_CRPT_MIC_ENABLE;</a>
<a name="ln944">		else</a>
<a name="ln945">			ahp-&gt;ah_staId1Defaults &amp;= ~AR_STA_ID1_CRPT_MIC_ENABLE;</a>
<a name="ln946">		return AH_TRUE;</a>
<a name="ln947">	case HAL_CAP_TKIP_SPLIT:	/* hardware TKIP uses split keys */</a>
<a name="ln948">		if (!pCap-&gt;halTkipMicTxRxKeySupport)</a>
<a name="ln949">			return AH_FALSE;</a>
<a name="ln950">		/* NB: true =&gt;'s use split key cache layout */</a>
<a name="ln951">		if (setting)</a>
<a name="ln952">			ahp-&gt;ah_miscMode &amp;= ~AR_MISC_MODE_MIC_NEW_LOC_ENABLE;</a>
<a name="ln953">		else</a>
<a name="ln954">			ahp-&gt;ah_miscMode |= AR_MISC_MODE_MIC_NEW_LOC_ENABLE;</a>
<a name="ln955">		/* NB: write here so keys can be setup w/o a reset */</a>
<a name="ln956">		OS_REG_WRITE(ah, AR_MISC_MODE, OS_REG_READ(ah, AR_MISC_MODE) | ahp-&gt;ah_miscMode);</a>
<a name="ln957">		return AH_TRUE;</a>
<a name="ln958">	case HAL_CAP_DIVERSITY:</a>
<a name="ln959">		switch (capability) {</a>
<a name="ln960">		case 0:</a>
<a name="ln961">			return AH_FALSE;</a>
<a name="ln962">		case 1:	/* setting */</a>
<a name="ln963">			if (ahp-&gt;ah_phyPowerOn) {</a>
<a name="ln964">				if (capability == HAL_CAP_STRONG_DIV) {</a>
<a name="ln965">					v = OS_REG_READ(ah, AR_PHY_CCK_DETECT);</a>
<a name="ln966">					if (setting)</a>
<a name="ln967">						v |= AR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV;</a>
<a name="ln968">					else</a>
<a name="ln969">						v &amp;= ~AR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV;</a>
<a name="ln970">					OS_REG_WRITE(ah, AR_PHY_CCK_DETECT, v);</a>
<a name="ln971">				}</a>
<a name="ln972">			}</a>
<a name="ln973">			ahp-&gt;ah_diversity = (setting != 0);</a>
<a name="ln974">			return AH_TRUE;</a>
<a name="ln975"> </a>
<a name="ln976">		case HAL_CAP_STRONG_DIV:</a>
<a name="ln977">			if (! ahp-&gt;ah_phyPowerOn)</a>
<a name="ln978">				return AH_FALSE;</a>
<a name="ln979">			v = OS_REG_READ(ah, AR_PHY_RESTART);</a>
<a name="ln980">			v &amp;= ~AR_PHY_RESTART_DIV_GC;</a>
<a name="ln981">			v |= SM(setting, AR_PHY_RESTART_DIV_GC);</a>
<a name="ln982">			OS_REG_WRITE(ah, AR_PHY_RESTART, v);</a>
<a name="ln983">			return AH_TRUE;</a>
<a name="ln984">		default:</a>
<a name="ln985">			return AH_FALSE;</a>
<a name="ln986">		}</a>
<a name="ln987">	case HAL_CAP_DIAG:		/* hardware diagnostic support */</a>
<a name="ln988">		/*</a>
<a name="ln989">		 * NB: could split this up into virtual capabilities,</a>
<a name="ln990">		 *     (e.g. 1 =&gt; ACK, 2 =&gt; CTS, etc.) but it hardly</a>
<a name="ln991">		 *     seems worth the additional complexity.</a>
<a name="ln992">		 */</a>
<a name="ln993">		AH_PRIVATE(ah)-&gt;ah_diagreg = setting;</a>
<a name="ln994">		OS_REG_WRITE(ah, AR_DIAG_SW, AH_PRIVATE(ah)-&gt;ah_diagreg);</a>
<a name="ln995">		return AH_TRUE;</a>
<a name="ln996">	case HAL_CAP_TPC:</a>
<a name="ln997">		ahp-&gt;ah_tpcEnabled = (setting != 0);</a>
<a name="ln998">		return AH_TRUE;</a>
<a name="ln999">	case HAL_CAP_MCAST_KEYSRCH:	/* multicast frame keycache search */</a>
<a name="ln1000">		if (setting)</a>
<a name="ln1001">			ahp-&gt;ah_staId1Defaults |= AR_STA_ID1_MCAST_KSRCH;</a>
<a name="ln1002">		else</a>
<a name="ln1003">			ahp-&gt;ah_staId1Defaults &amp;= ~AR_STA_ID1_MCAST_KSRCH;</a>
<a name="ln1004">		return AH_TRUE;</a>
<a name="ln1005">	case HAL_CAP_TPC_ACK:</a>
<a name="ln1006">	case HAL_CAP_TPC_CTS:</a>
<a name="ln1007">		setting += ahp-&gt;ah_txPowerIndexOffset;</a>
<a name="ln1008">		if (setting &gt; 63)</a>
<a name="ln1009">			setting = 63;</a>
<a name="ln1010">		if (type == HAL_CAP_TPC_ACK) {</a>
<a name="ln1011">			ahp-&gt;ah_macTPC &amp;= AR_TPC_ACK;</a>
<a name="ln1012">			ahp-&gt;ah_macTPC |= MS(setting, AR_TPC_ACK);</a>
<a name="ln1013">		} else {</a>
<a name="ln1014">			ahp-&gt;ah_macTPC &amp;= AR_TPC_CTS;</a>
<a name="ln1015">			ahp-&gt;ah_macTPC |= MS(setting, AR_TPC_CTS);</a>
<a name="ln1016">		}</a>
<a name="ln1017">		OS_REG_WRITE(ah, AR_TPC, ahp-&gt;ah_macTPC);</a>
<a name="ln1018">		return AH_TRUE;</a>
<a name="ln1019">	case HAL_CAP_INTMIT: {		/* interference mitigation */</a>
<a name="ln1020">		/* This maps the public ANI commands to the internal ANI commands */</a>
<a name="ln1021">		/* Private: HAL_ANI_CMD; Public: HAL_CAP_INTMIT_CMD */</a>
<a name="ln1022">		static const HAL_ANI_CMD cmds[] = {</a>
<a name="ln1023">			HAL_ANI_PRESENT,</a>
<a name="ln1024">			HAL_ANI_MODE,</a>
<a name="ln1025">			HAL_ANI_NOISE_IMMUNITY_LEVEL,</a>
<a name="ln1026">			HAL_ANI_OFDM_WEAK_SIGNAL_DETECTION,</a>
<a name="ln1027">			HAL_ANI_CCK_WEAK_SIGNAL_THR,</a>
<a name="ln1028">			HAL_ANI_FIRSTEP_LEVEL,</a>
<a name="ln1029">			HAL_ANI_SPUR_IMMUNITY_LEVEL,</a>
<a name="ln1030">		};</a>
<a name="ln1031">		return capability &lt; N(cmds) ?</a>
<a name="ln1032">			AH5212(ah)-&gt;ah_aniControl(ah, cmds[capability], setting) :</a>
<a name="ln1033">			AH_FALSE;</a>
<a name="ln1034">	}</a>
<a name="ln1035">	case HAL_CAP_TSF_ADJUST:	/* hardware has beacon tsf adjust */</a>
<a name="ln1036">		if (pCap-&gt;halTsfAddSupport) {</a>
<a name="ln1037">			if (setting)</a>
<a name="ln1038">				ahp-&gt;ah_miscMode |= AR_MISC_MODE_TX_ADD_TSF;</a>
<a name="ln1039">			else</a>
<a name="ln1040">				ahp-&gt;ah_miscMode &amp;= ~AR_MISC_MODE_TX_ADD_TSF;</a>
<a name="ln1041">			return AH_TRUE;</a>
<a name="ln1042">		}</a>
<a name="ln1043">		/* fall thru... */</a>
<a name="ln1044">	default:</a>
<a name="ln1045">		return ath_hal_setcapability(ah, type, capability,</a>
<a name="ln1046">				setting, status);</a>
<a name="ln1047">	}</a>
<a name="ln1048">#undef N</a>
<a name="ln1049">}</a>
<a name="ln1050"> </a>
<a name="ln1051">HAL_BOOL</a>
<a name="ln1052">ar5212GetDiagState(struct ath_hal *ah, int request,</a>
<a name="ln1053">	const void *args, uint32_t argsize,</a>
<a name="ln1054">	void **result, uint32_t *resultsize)</a>
<a name="ln1055">{</a>
<a name="ln1056">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln1057">	HAL_ANI_STATS *astats;</a>
<a name="ln1058"> </a>
<a name="ln1059">	(void) ahp;</a>
<a name="ln1060">	if (ath_hal_getdiagstate(ah, request, args, argsize, result, resultsize))</a>
<a name="ln1061">		return AH_TRUE;</a>
<a name="ln1062">	switch (request) {</a>
<a name="ln1063">	case HAL_DIAG_EEPROM:</a>
<a name="ln1064">	case HAL_DIAG_EEPROM_EXP_11A:</a>
<a name="ln1065">	case HAL_DIAG_EEPROM_EXP_11B:</a>
<a name="ln1066">	case HAL_DIAG_EEPROM_EXP_11G:</a>
<a name="ln1067">	case HAL_DIAG_RFGAIN:</a>
<a name="ln1068">		return ath_hal_eepromDiag(ah, request,</a>
<a name="ln1069">		    args, argsize, result, resultsize);</a>
<a name="ln1070">	case HAL_DIAG_RFGAIN_CURSTEP:</a>
<a name="ln1071">		*result = __DECONST(void *, ahp-&gt;ah_gainValues.currStep);</a>
<a name="ln1072">		*resultsize = (*result == AH_NULL) ?</a>
<a name="ln1073">			0 : sizeof(GAIN_OPTIMIZATION_STEP);</a>
<a name="ln1074">		return AH_TRUE;</a>
<a name="ln1075">	case HAL_DIAG_PCDAC:</a>
<a name="ln1076">		*result = ahp-&gt;ah_pcdacTable;</a>
<a name="ln1077">		*resultsize = ahp-&gt;ah_pcdacTableSize;</a>
<a name="ln1078">		return AH_TRUE;</a>
<a name="ln1079">	case HAL_DIAG_TXRATES:</a>
<a name="ln1080">		*result = &amp;ahp-&gt;ah_ratesArray[0];</a>
<a name="ln1081">		*resultsize = sizeof(ahp-&gt;ah_ratesArray);</a>
<a name="ln1082">		return AH_TRUE;</a>
<a name="ln1083">	case HAL_DIAG_ANI_CURRENT:</a>
<a name="ln1084">		*result = ar5212AniGetCurrentState(ah);</a>
<a name="ln1085">		*resultsize = (*result == AH_NULL) ?</a>
<a name="ln1086">			0 : sizeof(struct ar5212AniState);</a>
<a name="ln1087">		return AH_TRUE;</a>
<a name="ln1088">	case HAL_DIAG_ANI_STATS:</a>
<a name="ln1089">		OS_MEMZERO(&amp;ahp-&gt;ext_ani_stats, sizeof(ahp-&gt;ext_ani_stats));</a>
<a name="ln1090">		astats = ar5212AniGetCurrentStats(ah);</a>
<a name="ln1091">		if (astats == NULL) {</a>
<a name="ln1092">			*result = NULL;</a>
<a name="ln1093">			*resultsize = 0;</a>
<a name="ln1094">		} else {</a>
<a name="ln1095">			OS_MEMCPY(&amp;ahp-&gt;ext_ani_stats, astats, sizeof(HAL_ANI_STATS));</a>
<a name="ln1096">			*result = &amp;ahp-&gt;ext_ani_stats;</a>
<a name="ln1097">			*resultsize = sizeof(ahp-&gt;ext_ani_stats);</a>
<a name="ln1098">		}</a>
<a name="ln1099">		return AH_TRUE;</a>
<a name="ln1100">	case HAL_DIAG_ANI_CMD:</a>
<a name="ln1101">		if (argsize != 2*sizeof(uint32_t))</a>
<a name="ln1102">			return AH_FALSE;</a>
<a name="ln1103">		AH5212(ah)-&gt;ah_aniControl(ah, ((const uint32_t *)args)[0],</a>
<a name="ln1104">			((const uint32_t *)args)[1]);</a>
<a name="ln1105">		return AH_TRUE;</a>
<a name="ln1106">	case HAL_DIAG_ANI_PARAMS:</a>
<a name="ln1107">		/*</a>
<a name="ln1108">		 * NB: We assume struct ar5212AniParams is identical</a>
<a name="ln1109">		 * to HAL_ANI_PARAMS; if they diverge then we'll need</a>
<a name="ln1110">		 * to handle it here</a>
<a name="ln1111">		 */</a>
<a name="ln1112">		if (argsize == 0 &amp;&amp; args == AH_NULL) {</a>
<a name="ln1113">			struct ar5212AniState *aniState =</a>
<a name="ln1114">			    ar5212AniGetCurrentState(ah);</a>
<a name="ln1115">			if (aniState == AH_NULL)</a>
<a name="ln1116">				return AH_FALSE;</a>
<a name="ln1117">			*result = __DECONST(void *, aniState-&gt;params);</a>
<a name="ln1118">			*resultsize = sizeof(struct ar5212AniParams);</a>
<a name="ln1119">			return AH_TRUE;</a>
<a name="ln1120">		} else {</a>
<a name="ln1121">			if (argsize != sizeof(struct ar5212AniParams))</a>
<a name="ln1122">				return AH_FALSE;</a>
<a name="ln1123">			return ar5212AniSetParams(ah, args, args);</a>
<a name="ln1124">		}</a>
<a name="ln1125">		break;</a>
<a name="ln1126">	}</a>
<a name="ln1127">	return AH_FALSE;</a>
<a name="ln1128">}</a>
<a name="ln1129"> </a>
<a name="ln1130">/*</a>
<a name="ln1131"> * Check whether there's an in-progress NF completion.</a>
<a name="ln1132"> *</a>
<a name="ln1133"> * Returns AH_TRUE if there's a in-progress NF calibration, AH_FALSE</a>
<a name="ln1134"> * otherwise.</a>
<a name="ln1135"> */</a>
<a name="ln1136">HAL_BOOL</a>
<a name="ln1137">ar5212IsNFCalInProgress(struct ath_hal *ah)</a>
<a name="ln1138">{</a>
<a name="ln1139">	if (OS_REG_READ(ah, AR_PHY_AGC_CONTROL) &amp; AR_PHY_AGC_CONTROL_NF)</a>
<a name="ln1140">		return AH_TRUE;</a>
<a name="ln1141">	return AH_FALSE;</a>
<a name="ln1142">}</a>
<a name="ln1143"> </a>
<a name="ln1144">/*</a>
<a name="ln1145"> * Wait for an in-progress NF calibration to complete.</a>
<a name="ln1146"> *</a>
<a name="ln1147"> * The completion function waits &quot;i&quot; times 10uS.</a>
<a name="ln1148"> * It returns AH_TRUE if the NF calibration completed (or was never</a>
<a name="ln1149"> * in progress); AH_FALSE if it was still in progress after &quot;i&quot; checks.</a>
<a name="ln1150"> */</a>
<a name="ln1151">HAL_BOOL</a>
<a name="ln1152">ar5212WaitNFCalComplete(struct ath_hal *ah, int i)</a>
<a name="ln1153">{</a>
<a name="ln1154">	int j;</a>
<a name="ln1155">	if (i &lt;= 0)</a>
<a name="ln1156">		i = 1;	  /* it should run at least once */</a>
<a name="ln1157">	for (j = 0; j &lt; i; j++) {</a>
<a name="ln1158">		if (! ar5212IsNFCalInProgress(ah))</a>
<a name="ln1159">			return AH_TRUE;</a>
<a name="ln1160">		OS_DELAY(10);</a>
<a name="ln1161">	}</a>
<a name="ln1162">	return AH_FALSE;</a>
<a name="ln1163">}</a>
<a name="ln1164"> </a>
<a name="ln1165">void</a>
<a name="ln1166">ar5212EnableDfs(struct ath_hal *ah, HAL_PHYERR_PARAM *pe)</a>
<a name="ln1167">{</a>
<a name="ln1168">	uint32_t val;</a>
<a name="ln1169">	val = OS_REG_READ(ah, AR_PHY_RADAR_0);</a>
<a name="ln1170"> </a>
<a name="ln1171">	if (pe-&gt;pe_firpwr != HAL_PHYERR_PARAM_NOVAL) {</a>
<a name="ln1172">		val &amp;= ~AR_PHY_RADAR_0_FIRPWR;</a>
<a name="ln1173">		val |= SM(pe-&gt;pe_firpwr, AR_PHY_RADAR_0_FIRPWR);</a>
<a name="ln1174">	}</a>
<a name="ln1175">	if (pe-&gt;pe_rrssi != HAL_PHYERR_PARAM_NOVAL) {</a>
<a name="ln1176">		val &amp;= ~AR_PHY_RADAR_0_RRSSI;</a>
<a name="ln1177">		val |= SM(pe-&gt;pe_rrssi, AR_PHY_RADAR_0_RRSSI);</a>
<a name="ln1178">	}</a>
<a name="ln1179">	if (pe-&gt;pe_height != HAL_PHYERR_PARAM_NOVAL) {</a>
<a name="ln1180">		val &amp;= ~AR_PHY_RADAR_0_HEIGHT;</a>
<a name="ln1181">		val |= SM(pe-&gt;pe_height, AR_PHY_RADAR_0_HEIGHT);</a>
<a name="ln1182">	}</a>
<a name="ln1183">	if (pe-&gt;pe_prssi != HAL_PHYERR_PARAM_NOVAL) {</a>
<a name="ln1184">		val &amp;= ~AR_PHY_RADAR_0_PRSSI;</a>
<a name="ln1185">		val |= SM(pe-&gt;pe_prssi, AR_PHY_RADAR_0_PRSSI);</a>
<a name="ln1186">	}</a>
<a name="ln1187">	if (pe-&gt;pe_inband != HAL_PHYERR_PARAM_NOVAL) {</a>
<a name="ln1188">		val &amp;= ~AR_PHY_RADAR_0_INBAND;</a>
<a name="ln1189">		val |= SM(pe-&gt;pe_inband, AR_PHY_RADAR_0_INBAND);</a>
<a name="ln1190">	}</a>
<a name="ln1191">	if (pe-&gt;pe_enabled)</a>
<a name="ln1192">		val |= AR_PHY_RADAR_0_ENA;</a>
<a name="ln1193">	else</a>
<a name="ln1194">		val &amp;= ~ AR_PHY_RADAR_0_ENA;</a>
<a name="ln1195"> </a>
<a name="ln1196">	if (IS_5413(ah)) {</a>
<a name="ln1197"> </a>
<a name="ln1198">		if (pe-&gt;pe_blockradar == 1)</a>
<a name="ln1199">			OS_REG_SET_BIT(ah, AR_PHY_RADAR_2,</a>
<a name="ln1200">			    AR_PHY_RADAR_2_BLOCKOFDMWEAK);</a>
<a name="ln1201">		else</a>
<a name="ln1202">			OS_REG_CLR_BIT(ah, AR_PHY_RADAR_2,</a>
<a name="ln1203">			    AR_PHY_RADAR_2_BLOCKOFDMWEAK);</a>
<a name="ln1204"> </a>
<a name="ln1205">		if (pe-&gt;pe_en_relstep_check == 1)</a>
<a name="ln1206">			OS_REG_SET_BIT(ah, AR_PHY_RADAR_2,</a>
<a name="ln1207">			    AR_PHY_RADAR_2_ENRELSTEPCHK);</a>
<a name="ln1208">		else</a>
<a name="ln1209">			OS_REG_CLR_BIT(ah, AR_PHY_RADAR_2,</a>
<a name="ln1210">			    AR_PHY_RADAR_2_ENRELSTEPCHK);</a>
<a name="ln1211"> </a>
<a name="ln1212">		if (pe-&gt;pe_usefir128 == 1)</a>
<a name="ln1213">			OS_REG_SET_BIT(ah, AR_PHY_RADAR_2,</a>
<a name="ln1214">			    AR_PHY_RADAR_2_USEFIR128);</a>
<a name="ln1215">		else</a>
<a name="ln1216">			OS_REG_CLR_BIT(ah, AR_PHY_RADAR_2,</a>
<a name="ln1217">			    AR_PHY_RADAR_2_USEFIR128);</a>
<a name="ln1218"> </a>
<a name="ln1219">		if (pe-&gt;pe_enmaxrssi == 1)</a>
<a name="ln1220">			OS_REG_SET_BIT(ah, AR_PHY_RADAR_2,</a>
<a name="ln1221">			    AR_PHY_RADAR_2_ENMAXRSSI);</a>
<a name="ln1222">		else</a>
<a name="ln1223">			OS_REG_CLR_BIT(ah, AR_PHY_RADAR_2,</a>
<a name="ln1224">			    AR_PHY_RADAR_2_ENMAXRSSI);</a>
<a name="ln1225"> </a>
<a name="ln1226">		if (pe-&gt;pe_enrelpwr == 1)</a>
<a name="ln1227">			OS_REG_SET_BIT(ah, AR_PHY_RADAR_2,</a>
<a name="ln1228">			    AR_PHY_RADAR_2_ENRELPWRCHK);</a>
<a name="ln1229">		else</a>
<a name="ln1230">			OS_REG_CLR_BIT(ah, AR_PHY_RADAR_2,</a>
<a name="ln1231">			    AR_PHY_RADAR_2_ENRELPWRCHK);</a>
<a name="ln1232"> </a>
<a name="ln1233">		if (pe-&gt;pe_relpwr != HAL_PHYERR_PARAM_NOVAL)</a>
<a name="ln1234">			OS_REG_RMW_FIELD(ah, AR_PHY_RADAR_2,</a>
<a name="ln1235">			    AR_PHY_RADAR_2_RELPWR, pe-&gt;pe_relpwr);</a>
<a name="ln1236"> </a>
<a name="ln1237">		if (pe-&gt;pe_relstep != HAL_PHYERR_PARAM_NOVAL)</a>
<a name="ln1238">			OS_REG_RMW_FIELD(ah, AR_PHY_RADAR_2,</a>
<a name="ln1239">			    AR_PHY_RADAR_2_RELSTEP, pe-&gt;pe_relstep);</a>
<a name="ln1240"> </a>
<a name="ln1241">		if (pe-&gt;pe_maxlen != HAL_PHYERR_PARAM_NOVAL)</a>
<a name="ln1242">			OS_REG_RMW_FIELD(ah, AR_PHY_RADAR_2,</a>
<a name="ln1243">			    AR_PHY_RADAR_2_MAXLEN, pe-&gt;pe_maxlen);</a>
<a name="ln1244">	}</a>
<a name="ln1245"> </a>
<a name="ln1246">	OS_REG_WRITE(ah, AR_PHY_RADAR_0, val);</a>
<a name="ln1247">}</a>
<a name="ln1248"> </a>
<a name="ln1249">/*</a>
<a name="ln1250"> * Parameters for the AR5212 PHY.</a>
<a name="ln1251"> */</a>
<a name="ln1252">#define	AR5212_DFS_FIRPWR	-35</a>
<a name="ln1253">#define	AR5212_DFS_RRSSI	20</a>
<a name="ln1254">#define	AR5212_DFS_HEIGHT	14</a>
<a name="ln1255">#define	AR5212_DFS_PRSSI	6</a>
<a name="ln1256">#define	AR5212_DFS_INBAND	4</a>
<a name="ln1257"> </a>
<a name="ln1258">/*</a>
<a name="ln1259"> * Default parameters for the AR5413 PHY.</a>
<a name="ln1260"> */</a>
<a name="ln1261">#define	AR5413_DFS_FIRPWR	-34</a>
<a name="ln1262">#define	AR5413_DFS_RRSSI	20</a>
<a name="ln1263">#define	AR5413_DFS_HEIGHT	10</a>
<a name="ln1264">#define	AR5413_DFS_PRSSI	15</a>
<a name="ln1265">#define	AR5413_DFS_INBAND	6</a>
<a name="ln1266">#define	AR5413_DFS_RELPWR	8</a>
<a name="ln1267">#define	AR5413_DFS_RELSTEP	31</a>
<a name="ln1268">#define	AR5413_DFS_MAXLEN	255</a>
<a name="ln1269"> </a>
<a name="ln1270">HAL_BOOL</a>
<a name="ln1271">ar5212GetDfsDefaultThresh(struct ath_hal *ah, HAL_PHYERR_PARAM *pe)</a>
<a name="ln1272">{</a>
<a name="ln1273"> </a>
<a name="ln1274">	if (IS_5413(ah)) {</a>
<a name="ln1275">		pe-&gt;pe_firpwr = AR5413_DFS_FIRPWR;</a>
<a name="ln1276">		pe-&gt;pe_rrssi = AR5413_DFS_RRSSI;</a>
<a name="ln1277">		pe-&gt;pe_height = AR5413_DFS_HEIGHT;</a>
<a name="ln1278">		pe-&gt;pe_prssi = AR5413_DFS_PRSSI;</a>
<a name="ln1279">		pe-&gt;pe_inband = AR5413_DFS_INBAND;</a>
<a name="ln1280">		pe-&gt;pe_relpwr = AR5413_DFS_RELPWR;</a>
<a name="ln1281">		pe-&gt;pe_relstep = AR5413_DFS_RELSTEP;</a>
<a name="ln1282">		pe-&gt;pe_maxlen = AR5413_DFS_MAXLEN;</a>
<a name="ln1283">		pe-&gt;pe_usefir128 = 0;</a>
<a name="ln1284">		pe-&gt;pe_blockradar = 1;</a>
<a name="ln1285">		pe-&gt;pe_enmaxrssi = 1;</a>
<a name="ln1286">		pe-&gt;pe_enrelpwr = 1;</a>
<a name="ln1287">		pe-&gt;pe_en_relstep_check = 0;</a>
<a name="ln1288">	} else {</a>
<a name="ln1289">		pe-&gt;pe_firpwr = AR5212_DFS_FIRPWR;</a>
<a name="ln1290">		pe-&gt;pe_rrssi = AR5212_DFS_RRSSI;</a>
<a name="ln1291">		pe-&gt;pe_height = AR5212_DFS_HEIGHT;</a>
<a name="ln1292">		pe-&gt;pe_prssi = AR5212_DFS_PRSSI;</a>
<a name="ln1293">		pe-&gt;pe_inband = AR5212_DFS_INBAND;</a>
<a name="ln1294">		pe-&gt;pe_relpwr = 0;</a>
<a name="ln1295">		pe-&gt;pe_relstep = 0;</a>
<a name="ln1296">		pe-&gt;pe_maxlen = 0;</a>
<a name="ln1297">		pe-&gt;pe_usefir128 = 0;</a>
<a name="ln1298">		pe-&gt;pe_blockradar = 0;</a>
<a name="ln1299">		pe-&gt;pe_enmaxrssi = 0;</a>
<a name="ln1300">		pe-&gt;pe_enrelpwr = 0;</a>
<a name="ln1301">		pe-&gt;pe_en_relstep_check = 0;</a>
<a name="ln1302">	}</a>
<a name="ln1303"> </a>
<a name="ln1304">	return (AH_TRUE);</a>
<a name="ln1305">}</a>
<a name="ln1306"> </a>
<a name="ln1307">void</a>
<a name="ln1308">ar5212GetDfsThresh(struct ath_hal *ah, HAL_PHYERR_PARAM *pe)</a>
<a name="ln1309">{</a>
<a name="ln1310">	uint32_t val,temp;</a>
<a name="ln1311"> </a>
<a name="ln1312">	val = OS_REG_READ(ah, AR_PHY_RADAR_0);</a>
<a name="ln1313"> </a>
<a name="ln1314">	temp = MS(val,AR_PHY_RADAR_0_FIRPWR);</a>
<a name="ln1315">	temp |= 0xFFFFFF80;</a>
<a name="ln1316">	pe-&gt;pe_firpwr = temp;</a>
<a name="ln1317">	pe-&gt;pe_rrssi = MS(val, AR_PHY_RADAR_0_RRSSI);</a>
<a name="ln1318">	pe-&gt;pe_height =  MS(val, AR_PHY_RADAR_0_HEIGHT);</a>
<a name="ln1319">	pe-&gt;pe_prssi = MS(val, AR_PHY_RADAR_0_PRSSI);</a>
<a name="ln1320">	pe-&gt;pe_inband = MS(val, AR_PHY_RADAR_0_INBAND);</a>
<a name="ln1321">	pe-&gt;pe_enabled = !! (val &amp; AR_PHY_RADAR_0_ENA);</a>
<a name="ln1322"> </a>
<a name="ln1323">	pe-&gt;pe_relpwr = 0;</a>
<a name="ln1324">	pe-&gt;pe_relstep = 0;</a>
<a name="ln1325">	pe-&gt;pe_maxlen = 0;</a>
<a name="ln1326">	pe-&gt;pe_usefir128 = 0;</a>
<a name="ln1327">	pe-&gt;pe_blockradar = 0;</a>
<a name="ln1328">	pe-&gt;pe_enmaxrssi = 0;</a>
<a name="ln1329">	pe-&gt;pe_enrelpwr = 0;</a>
<a name="ln1330">	pe-&gt;pe_en_relstep_check = 0;</a>
<a name="ln1331">	pe-&gt;pe_extchannel = AH_FALSE;</a>
<a name="ln1332"> </a>
<a name="ln1333">	if (IS_5413(ah)) {</a>
<a name="ln1334">		val = OS_REG_READ(ah, AR_PHY_RADAR_2);</a>
<a name="ln1335">		pe-&gt;pe_relpwr = !! MS(val, AR_PHY_RADAR_2_RELPWR);</a>
<a name="ln1336">		pe-&gt;pe_relstep = !! MS(val, AR_PHY_RADAR_2_RELSTEP);</a>
<a name="ln1337">		pe-&gt;pe_maxlen = !! MS(val, AR_PHY_RADAR_2_MAXLEN);</a>
<a name="ln1338"> </a>
<a name="ln1339">		pe-&gt;pe_usefir128 = !! (val &amp; AR_PHY_RADAR_2_USEFIR128);</a>
<a name="ln1340">		pe-&gt;pe_blockradar = !! (val &amp; AR_PHY_RADAR_2_BLOCKOFDMWEAK);</a>
<a name="ln1341">		pe-&gt;pe_enmaxrssi = !! (val &amp; AR_PHY_RADAR_2_ENMAXRSSI);</a>
<a name="ln1342">		pe-&gt;pe_enrelpwr = !! (val &amp; AR_PHY_RADAR_2_ENRELPWRCHK);</a>
<a name="ln1343">		pe-&gt;pe_en_relstep_check =</a>
<a name="ln1344">		    !! (val &amp; AR_PHY_RADAR_2_ENRELSTEPCHK);</a>
<a name="ln1345">	}</a>
<a name="ln1346">}</a>
<a name="ln1347"> </a>
<a name="ln1348">/*</a>
<a name="ln1349"> * Process the radar phy error and extract the pulse duration.</a>
<a name="ln1350"> */</a>
<a name="ln1351">HAL_BOOL</a>
<a name="ln1352">ar5212ProcessRadarEvent(struct ath_hal *ah, struct ath_rx_status *rxs,</a>
<a name="ln1353">    uint64_t fulltsf, const char *buf, HAL_DFS_EVENT *event)</a>
<a name="ln1354">{</a>
<a name="ln1355">	uint8_t dur;</a>
<a name="ln1356">	uint8_t rssi;</a>
<a name="ln1357"> </a>
<a name="ln1358">	/* Check whether the given phy error is a radar event */</a>
<a name="ln1359">	if ((rxs-&gt;rs_phyerr != HAL_PHYERR_RADAR) &amp;&amp;</a>
<a name="ln1360">	    (rxs-&gt;rs_phyerr != HAL_PHYERR_FALSE_RADAR_EXT))</a>
<a name="ln1361">		return AH_FALSE;</a>
<a name="ln1362"> </a>
<a name="ln1363">	/*</a>
<a name="ln1364">	 * The first byte is the pulse width - if there's</a>
<a name="ln1365">	 * no data, simply set the duration to 0</a>
<a name="ln1366">	 */</a>
<a name="ln1367">	if (rxs-&gt;rs_datalen &gt;= 1)</a>
<a name="ln1368">		/* The pulse width is byte 0 of the data */</a>
<a name="ln1369">		dur = ((uint8_t) buf[0]) &amp; 0xff;</a>
<a name="ln1370">	else</a>
<a name="ln1371">		dur = 0;</a>
<a name="ln1372"> </a>
<a name="ln1373">	/* Pulse RSSI is the normal reported RSSI */</a>
<a name="ln1374">	rssi = (uint8_t) rxs-&gt;rs_rssi;</a>
<a name="ln1375"> </a>
<a name="ln1376">	/* 0 duration/rssi is not a valid radar event */</a>
<a name="ln1377">	if (dur == 0 &amp;&amp; rssi == 0)</a>
<a name="ln1378">		return AH_FALSE;</a>
<a name="ln1379"> </a>
<a name="ln1380">	HALDEBUG(ah, HAL_DEBUG_DFS, &quot;%s: rssi=%d, dur=%d\n&quot;,</a>
<a name="ln1381">	    __func__, rssi, dur);</a>
<a name="ln1382"> </a>
<a name="ln1383">	/* Record the event */</a>
<a name="ln1384">	event-&gt;re_full_ts = fulltsf;</a>
<a name="ln1385">	event-&gt;re_ts = rxs-&gt;rs_tstamp;</a>
<a name="ln1386">	event-&gt;re_rssi = rssi;</a>
<a name="ln1387">	event-&gt;re_dur = dur;</a>
<a name="ln1388">	event-&gt;re_flags = HAL_DFS_EVENT_PRICH;</a>
<a name="ln1389"> </a>
<a name="ln1390">	return AH_TRUE;</a>
<a name="ln1391">}</a>
<a name="ln1392"> </a>
<a name="ln1393">/*</a>
<a name="ln1394"> * Return whether 5GHz fast-clock (44MHz) is enabled.</a>
<a name="ln1395"> * It's always disabled for AR5212 series NICs.</a>
<a name="ln1396"> */</a>
<a name="ln1397">HAL_BOOL</a>
<a name="ln1398">ar5212IsFastClockEnabled(struct ath_hal *ah)</a>
<a name="ln1399">{</a>
<a name="ln1400">	return AH_FALSE;</a>
<a name="ln1401">}</a>
<a name="ln1402"> </a>
<a name="ln1403">/*</a>
<a name="ln1404"> * Return what percentage of the extension channel is busy.</a>
<a name="ln1405"> * This is always disabled for AR5212 series NICs.</a>
<a name="ln1406"> */</a>
<a name="ln1407">uint32_t</a>
<a name="ln1408">ar5212Get11nExtBusy(struct ath_hal *ah)</a>
<a name="ln1409">{</a>
<a name="ln1410">	return 0;</a>
<a name="ln1411">}</a>
<a name="ln1412"> </a>
<a name="ln1413">/*</a>
<a name="ln1414"> * Channel survey support.</a>
<a name="ln1415"> */</a>
<a name="ln1416">HAL_BOOL</a>
<a name="ln1417">ar5212GetMibCycleCounts(struct ath_hal *ah, HAL_SURVEY_SAMPLE *hsample)</a>
<a name="ln1418">{</a>
<a name="ln1419">	struct ath_hal_5212 *ahp = AH5212(ah);</a>
<a name="ln1420">	u_int32_t good = AH_TRUE;</a>
<a name="ln1421"> </a>
<a name="ln1422">	/* XXX freeze/unfreeze mib counters */</a>
<a name="ln1423">	uint32_t rc = OS_REG_READ(ah, AR_RCCNT);</a>
<a name="ln1424">	uint32_t rf = OS_REG_READ(ah, AR_RFCNT);</a>
<a name="ln1425">	uint32_t tf = OS_REG_READ(ah, AR_TFCNT);</a>
<a name="ln1426">	uint32_t cc = OS_REG_READ(ah, AR_CCCNT); /* read cycles last */</a>
<a name="ln1427"> </a>
<a name="ln1428">	if (ahp-&gt;ah_cycleCount == 0 || ahp-&gt;ah_cycleCount &gt; cc) {</a>
<a name="ln1429">		/*</a>
<a name="ln1430">		 * Cycle counter wrap (or initial call); it's not possible</a>
<a name="ln1431">		 * to accurately calculate a value because the registers</a>
<a name="ln1432">		 * right shift rather than wrap--so punt and return 0.</a>
<a name="ln1433">		 */</a>
<a name="ln1434">		HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln1435">		    &quot;%s: cycle counter wrap. ExtBusy = 0\n&quot;, __func__);</a>
<a name="ln1436">		good = AH_FALSE;</a>
<a name="ln1437">	} else {</a>
<a name="ln1438">		hsample-&gt;cycle_count = cc - ahp-&gt;ah_cycleCount;</a>
<a name="ln1439">		hsample-&gt;chan_busy = rc - ahp-&gt;ah_ctlBusy;</a>
<a name="ln1440">		hsample-&gt;ext_chan_busy = 0;</a>
<a name="ln1441">		hsample-&gt;rx_busy = rf - ahp-&gt;ah_rxBusy;</a>
<a name="ln1442">		hsample-&gt;tx_busy = tf - ahp-&gt;ah_txBusy;</a>
<a name="ln1443">	}</a>
<a name="ln1444"> </a>
<a name="ln1445">	/*</a>
<a name="ln1446">	 * Keep a copy of the MIB results so the next sample has something</a>
<a name="ln1447">	 * to work from.</a>
<a name="ln1448">	 */</a>
<a name="ln1449">	ahp-&gt;ah_cycleCount = cc;</a>
<a name="ln1450">	ahp-&gt;ah_rxBusy = rf;</a>
<a name="ln1451">	ahp-&gt;ah_ctlBusy = rc;</a>
<a name="ln1452">	ahp-&gt;ah_txBusy = tf;</a>
<a name="ln1453"> </a>
<a name="ln1454">	return (good);</a>
<a name="ln1455">}</a>
<a name="ln1456"> </a>
<a name="ln1457">void</a>
<a name="ln1458">ar5212SetChainMasks(struct ath_hal *ah, uint32_t tx_chainmask,</a>
<a name="ln1459">    uint32_t rx_chainmask)</a>
<a name="ln1460">{</a>
<a name="ln1461">}</a>

</code></pre>
<div class="balloon" rel="964"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'capability == 2' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
