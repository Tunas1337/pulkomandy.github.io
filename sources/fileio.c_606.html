
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>fileio.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">  Copyright (c) 1990-2002 Info-ZIP.  All rights reserved.</a>
<a name="ln3"> </a>
<a name="ln4">  See the accompanying file LICENSE, version 2000-Apr-09 or later</a>
<a name="ln5">  (the contents of which are also included in unzip.h) for terms of use.</a>
<a name="ln6">  If, for some reason, all these files are missing, the Info-ZIP license</a>
<a name="ln7">  also may be found at:  ftp://ftp.info-zip.org/pub/infozip/license.html</a>
<a name="ln8">*/</a>
<a name="ln9">/*---------------------------------------------------------------------------</a>
<a name="ln10"> </a>
<a name="ln11">  fileio.c</a>
<a name="ln12"> </a>
<a name="ln13">  This file contains routines for doing direct but relatively generic input/</a>
<a name="ln14">  output, file-related sorts of things, plus some miscellaneous stuff.  Most</a>
<a name="ln15">  of the stuff has to do with opening, closing, reading and/or writing files.</a>
<a name="ln16"> </a>
<a name="ln17">  Contains:  open_input_file()</a>
<a name="ln18">             open_outfile()           (not: VMS, AOS/VS, CMSMVS, MACOS, TANDEM)</a>
<a name="ln19">             undefer_input()</a>
<a name="ln20">             defer_leftover_input()</a>
<a name="ln21">             readbuf()</a>
<a name="ln22">             readbyte()</a>
<a name="ln23">             fillinbuf()</a>
<a name="ln24">             seek_zipf()</a>
<a name="ln25">             flush()                  (non-VMS)</a>
<a name="ln26">             is_vms_varlen_txt()      (non-VMS, VMS_TEXT_CONV only)</a>
<a name="ln27">             disk_error()             (non-VMS)</a>
<a name="ln28">             UzpMessagePrnt()</a>
<a name="ln29">             UzpMessageNull()         (DLL only)</a>
<a name="ln30">             UzpInput()</a>
<a name="ln31">             UzpMorePause()</a>
<a name="ln32">             UzpPassword()            (non-WINDLL)</a>
<a name="ln33">             handler()</a>
<a name="ln34">             dos_to_unix_time()       (non-VMS, non-VM/CMS, non-MVS)</a>
<a name="ln35">             check_for_newer()        (non-VMS, non-OS/2, non-VM/CMS, non-MVS)</a>
<a name="ln36">             do_string()</a>
<a name="ln37">             makeword()</a>
<a name="ln38">             makelong()</a>
<a name="ln39">             str2iso()                (CRYPT &amp;&amp; NEED_STR2ISO, only)</a>
<a name="ln40">             str2oem()                (CRYPT &amp;&amp; NEED_STR2OEM, only)</a>
<a name="ln41">             memset()                 (ZMEM only)</a>
<a name="ln42">             memcpy()                 (ZMEM only)</a>
<a name="ln43">             zstrnicmp()              (NO_STRNICMP only)</a>
<a name="ln44">             zstat()                  (REGULUS only)</a>
<a name="ln45">             plastchar()              (_MBCS only)</a>
<a name="ln46">             uzmbschr()               (_MBCS &amp;&amp; NEED_UZMBSCHR, only)</a>
<a name="ln47">             uzmbsrchr()              (_MBCS &amp;&amp; NEED_UZMBSRCHR, only)</a>
<a name="ln48">             fLoadFarString()         (SMALL_MEM only)</a>
<a name="ln49">             fLoadFarStringSmall()    (SMALL_MEM only)</a>
<a name="ln50">             fLoadFarStringSmall2()   (SMALL_MEM only)</a>
<a name="ln51">             zfstrcpy()               (SMALL_MEM only)</a>
<a name="ln52"> </a>
<a name="ln53">  ---------------------------------------------------------------------------*/</a>
<a name="ln54"> </a>
<a name="ln55"> </a>
<a name="ln56">#define __FILEIO_C      /* identifies this source module */</a>
<a name="ln57">#define UNZIP_INTERNAL</a>
<a name="ln58">#include &quot;unzip.h&quot;</a>
<a name="ln59">#ifdef WINDLL</a>
<a name="ln60">#  include &quot;windll/windll.h&quot;</a>
<a name="ln61">#  include &lt;setjmp.h&gt;</a>
<a name="ln62">#endif</a>
<a name="ln63">#include &quot;crypt.h&quot;</a>
<a name="ln64">#include &quot;ttyio.h&quot;</a>
<a name="ln65"> </a>
<a name="ln66">/* setup of codepage conversion for decryption passwords */</a>
<a name="ln67">#if CRYPT</a>
<a name="ln68">#  if (defined(CRYP_USES_ISO2OEM) &amp;&amp; !defined(IZ_ISO2OEM_ARRAY))</a>
<a name="ln69">#    define IZ_ISO2OEM_ARRAY            /* pull in iso2oem[] table */</a>
<a name="ln70">#  endif</a>
<a name="ln71">#  if (defined(CRYP_USES_OEM2ISO) &amp;&amp; !defined(IZ_OEM2ISO_ARRAY))</a>
<a name="ln72">#    define IZ_OEM2ISO_ARRAY            /* pull in oem2iso[] table */</a>
<a name="ln73">#  endif</a>
<a name="ln74">#endif</a>
<a name="ln75">#include &quot;ebcdic.h&quot;   /* definition/initialization of ebcdic[] */</a>
<a name="ln76"> </a>
<a name="ln77"> </a>
<a name="ln78">/*</a>
<a name="ln79">   Note: Under Windows, the maximum size of the buffer that can be used</a>
<a name="ln80">   with any of the *printf calls is 16,384, so win_fprintf was used to</a>
<a name="ln81">   feed the fprintf clone no more than 16K chunks at a time. This should</a>
<a name="ln82">   be valid for anything up to 64K (and probably beyond, assuming your</a>
<a name="ln83">   buffers are that big).</a>
<a name="ln84">*/</a>
<a name="ln85">#ifdef WINDLL</a>
<a name="ln86">#  define WriteError(buf,len,strm) \</a>
<a name="ln87">   (win_fprintf(pG, strm, (extent)len, (char far *)buf) != (int)(len))</a>
<a name="ln88">#else /* !WINDLL */</a>
<a name="ln89">#  ifdef USE_FWRITE</a>
<a name="ln90">#    define WriteError(buf,len,strm) \</a>
<a name="ln91">     ((extent)fwrite((char *)(buf),1,(extent)(len),strm) != (extent)(len))</a>
<a name="ln92">#  else</a>
<a name="ln93">#    define WriteError(buf,len,strm) \</a>
<a name="ln94">     ((extent)write(fileno(strm),(char *)(buf),(extent)(len)) != (extent)(len))</a>
<a name="ln95">#  endif</a>
<a name="ln96">#endif /* ?WINDLL */</a>
<a name="ln97"> </a>
<a name="ln98">#if (defined(USE_DEFLATE64) &amp;&amp; defined(__16BIT__))</a>
<a name="ln99">static int partflush OF((__GPRO__ uch *rawbuf, ulg size, int unshrink));</a>
<a name="ln100">#endif</a>
<a name="ln101">#ifdef VMS_TEXT_CONV</a>
<a name="ln102">static int is_vms_varlen_txt OF((__GPRO__ uch *ef_buf, unsigned ef_len));</a>
<a name="ln103">#endif</a>
<a name="ln104">static int disk_error OF((__GPRO));</a>
<a name="ln105"> </a>
<a name="ln106"> </a>
<a name="ln107">/****************************/</a>
<a name="ln108">/* Strings used in fileio.c */</a>
<a name="ln109">/****************************/</a>
<a name="ln110"> </a>
<a name="ln111">static ZCONST char Far CannotOpenZipfile[] =</a>
<a name="ln112">  &quot;error:  cannot open zipfile [ %s ]\n&quot;;</a>
<a name="ln113"> </a>
<a name="ln114">#if (!defined(VMS) &amp;&amp; !defined(AOS_VS) &amp;&amp; !defined(CMS_MVS) &amp;&amp; !defined(MACOS))</a>
<a name="ln115">#if (!defined(TANDEM))</a>
<a name="ln116">#if (defined(BEO_THS_UNX) || defined(DOS_FLX_NLM_OS2_W32))</a>
<a name="ln117">   static ZCONST char Far CannotDeleteOldFile[] =</a>
<a name="ln118">     &quot;error:  cannot delete old %s\n&quot;;</a>
<a name="ln119">#ifdef UNIXBACKUP</a>
<a name="ln120">   static ZCONST char Far CannotRenameOldFile[] =</a>
<a name="ln121">     &quot;error:  cannot rename old %s\n&quot;;</a>
<a name="ln122">   static ZCONST char Far BackupSuffix[] = &quot;~&quot;;</a>
<a name="ln123">#endif</a>
<a name="ln124">#endif /* BEO_THS_UNX || DOS_FLX_NLM_OS2_W32 */</a>
<a name="ln125">#ifdef NOVELL_BUG_FAILSAFE</a>
<a name="ln126">   static ZCONST char Far NovellBug[] =</a>
<a name="ln127">     &quot;error:  %s: stat() says does not exist, but fopen() found anyway\n&quot;;</a>
<a name="ln128">#endif</a>
<a name="ln129">   static ZCONST char Far CannotCreateFile[] = &quot;error:  cannot create %s\n&quot;;</a>
<a name="ln130">#endif /* !TANDEM */</a>
<a name="ln131">#endif /* !VMS &amp;&amp; !AOS_VS &amp;&amp; !CMS_MVS &amp;&amp; !MACOS */</a>
<a name="ln132"> </a>
<a name="ln133">static ZCONST char Far ReadError[] = &quot;error:  zipfile read error\n&quot;;</a>
<a name="ln134">static ZCONST char Far FilenameTooLongTrunc[] =</a>
<a name="ln135">  &quot;warning:  filename too long--truncating.\n&quot;;</a>
<a name="ln136">static ZCONST char Far ExtraFieldTooLong[] =</a>
<a name="ln137">  &quot;warning:  extra field too long (%d).  Ignoring...\n&quot;;</a>
<a name="ln138"> </a>
<a name="ln139">#ifdef WINDLL</a>
<a name="ln140">   static ZCONST char Far DiskFullQuery[] =</a>
<a name="ln141">     &quot;%s:  write error (disk full?).\n&quot;;</a>
<a name="ln142">#else</a>
<a name="ln143">   static ZCONST char Far DiskFullQuery[] =</a>
<a name="ln144">     &quot;%s:  write error (disk full?).  Continue? (y/n/^C) &quot;;</a>
<a name="ln145">   static ZCONST char Far ZipfileCorrupt[] =</a>
<a name="ln146">     &quot;error:  zipfile probably corrupt (%s)\n&quot;;</a>
<a name="ln147">#  ifdef SYMLINKS</a>
<a name="ln148">     static ZCONST char Far FileIsSymLink[] =</a>
<a name="ln149">       &quot;%s exists and is a symbolic link%s.\n&quot;;</a>
<a name="ln150">#  endif</a>
<a name="ln151">#  ifdef MORE</a>
<a name="ln152">     static ZCONST char Far MorePrompt[] = &quot;--More--(%lu)&quot;;</a>
<a name="ln153">#  endif</a>
<a name="ln154">   static ZCONST char Far QuitPrompt[] =</a>
<a name="ln155">     &quot;--- Press `Q' to quit, or any other key to continue ---&quot;;</a>
<a name="ln156">   static ZCONST char Far HidePrompt[] = /* &quot;\r                       \r&quot;; */</a>
<a name="ln157">     &quot;\r                                                         \r&quot;;</a>
<a name="ln158">#  if CRYPT</a>
<a name="ln159">#    ifdef MACOS</a>
<a name="ln160">       /* SPC: are names on MacOS REALLY so much longer than elsewhere ??? */</a>
<a name="ln161">       static ZCONST char Far PasswPrompt[] = &quot;[%s]\n %s password: &quot;;</a>
<a name="ln162">#    else</a>
<a name="ln163">       static ZCONST char Far PasswPrompt[] = &quot;[%s] %s password: &quot;;</a>
<a name="ln164">#    endif</a>
<a name="ln165">     static ZCONST char Far PasswPrompt2[] = &quot;Enter password: &quot;;</a>
<a name="ln166">     static ZCONST char Far PasswRetry[] = &quot;password incorrect--reenter: &quot;;</a>
<a name="ln167">#  endif /* CRYPT */</a>
<a name="ln168">#endif /* !WINDLL */</a>
<a name="ln169"> </a>
<a name="ln170"> </a>
<a name="ln171"> </a>
<a name="ln172"> </a>
<a name="ln173"> </a>
<a name="ln174">/******************************/</a>
<a name="ln175">/* Function open_input_file() */</a>
<a name="ln176">/******************************/</a>
<a name="ln177"> </a>
<a name="ln178">int open_input_file(__G)    /* return 1 if open failed */</a>
<a name="ln179">    __GDEF</a>
<a name="ln180">{</a>
<a name="ln181">    /*</a>
<a name="ln182">     *  open the zipfile for reading and in BINARY mode to prevent cr/lf</a>
<a name="ln183">     *  translation, which would corrupt the bitstreams</a>
<a name="ln184">     */</a>
<a name="ln185"> </a>
<a name="ln186">#ifdef VMS</a>
<a name="ln187">    G.zipfd = open(G.zipfn, O_RDONLY, 0, &quot;ctx=stm&quot;);</a>
<a name="ln188">#else /* !VMS */</a>
<a name="ln189">#ifdef MACOS</a>
<a name="ln190">    G.zipfd = open(G.zipfn, 0);</a>
<a name="ln191">#else /* !MACOS */</a>
<a name="ln192">#ifdef CMS_MVS</a>
<a name="ln193">    G.zipfd = vmmvs_open_infile(__G);</a>
<a name="ln194">#else /* !CMS_MVS */</a>
<a name="ln195">#ifdef USE_STRM_INPUT</a>
<a name="ln196">    G.zipfd = fopen(G.zipfn, FOPR);</a>
<a name="ln197">#else /* !USE_STRM_INPUT */</a>
<a name="ln198"># ifdef O_BINARY</a>
<a name="ln199">    G.zipfd = open(G.zipfn, O_RDONLY | O_BINARY);</a>
<a name="ln200"># else</a>
<a name="ln201">    G.zipfd = open(G.zipfn, O_RDONLY);</a>
<a name="ln202"># endif</a>
<a name="ln203">#endif /* ?USE_STRM_INPUT */</a>
<a name="ln204">#endif /* ?CMS_MVS */</a>
<a name="ln205">#endif /* ?MACOS */</a>
<a name="ln206">#endif /* ?VMS */</a>
<a name="ln207"> </a>
<a name="ln208">#ifdef USE_STRM_INPUT</a>
<a name="ln209">    if (G.zipfd == NULL)</a>
<a name="ln210">#else</a>
<a name="ln211">    /* if (G.zipfd &lt; 0) */  /* no good for Windows CE port */</a>
<a name="ln212">    if (G.zipfd == -1)</a>
<a name="ln213">#endif</a>
<a name="ln214">    {</a>
<a name="ln215">        Info(slide, 0x401, ((char *)slide, LoadFarString(CannotOpenZipfile),</a>
<a name="ln216">          G.zipfn));</a>
<a name="ln217">        return 1;</a>
<a name="ln218">    }</a>
<a name="ln219">    return 0;</a>
<a name="ln220"> </a>
<a name="ln221">} /* end function open_input_file() */</a>
<a name="ln222"> </a>
<a name="ln223"> </a>
<a name="ln224"> </a>
<a name="ln225"> </a>
<a name="ln226">#if (!defined(VMS) &amp;&amp; !defined(AOS_VS) &amp;&amp; !defined(CMS_MVS) &amp;&amp; !defined(MACOS))</a>
<a name="ln227">#if (!defined(TANDEM))</a>
<a name="ln228"> </a>
<a name="ln229">/***************************/</a>
<a name="ln230">/* Function open_outfile() */</a>
<a name="ln231">/***************************/</a>
<a name="ln232"> </a>
<a name="ln233">int open_outfile(__G)         /* return 1 if fail */</a>
<a name="ln234">    __GDEF</a>
<a name="ln235">{</a>
<a name="ln236">#ifdef DLL</a>
<a name="ln237">    if (G.redirect_data)</a>
<a name="ln238">        return (redirect_outfile(__G) == FALSE);</a>
<a name="ln239">#endif</a>
<a name="ln240">#ifdef QDOS</a>
<a name="ln241">    QFilename(__G__ G.filename);</a>
<a name="ln242">#endif</a>
<a name="ln243">#if (defined(DOS_FLX_NLM_OS2_W32) || defined(BEO_THS_UNX))</a>
<a name="ln244">#ifdef BORLAND_STAT_BUG</a>
<a name="ln245">    /* Borland 5.0's stat() barfs if the filename has no extension and the</a>
<a name="ln246">     * file doesn't exist. */</a>
<a name="ln247">    if (access(G.filename, 0) == -1) {</a>
<a name="ln248">        FILE *tmp = fopen(G.filename, &quot;wb+&quot;);</a>
<a name="ln249"> </a>
<a name="ln250">        /* file doesn't exist, so create a dummy file to keep stat() from</a>
<a name="ln251">         * failing (will be over-written anyway) */</a>
<a name="ln252">        fputc('0', tmp);  /* just to have something in the file */</a>
<a name="ln253">        fclose(tmp);</a>
<a name="ln254">    }</a>
<a name="ln255">#endif /* BORLAND_STAT_BUG */</a>
<a name="ln256">#ifdef SYMLINKS</a>
<a name="ln257">    if (SSTAT(G.filename, &amp;G.statbuf) == 0 || lstat(G.filename,&amp;G.statbuf) == 0)</a>
<a name="ln258">#else</a>
<a name="ln259">    if (SSTAT(G.filename, &amp;G.statbuf) == 0)</a>
<a name="ln260">#endif /* ?SYMLINKS */</a>
<a name="ln261">    {</a>
<a name="ln262">        Trace((stderr, &quot;open_outfile:  stat(%s) returns 0:  file exists\n&quot;,</a>
<a name="ln263">          FnFilter1(G.filename)));</a>
<a name="ln264">#ifdef UNIXBACKUP</a>
<a name="ln265">        if (uO.B_flag) {    /* do backup */</a>
<a name="ln266">            char *tname;</a>
<a name="ln267">            struct stat tmpstat;</a>
<a name="ln268">            int blen, flen, tlen;</a>
<a name="ln269"> </a>
<a name="ln270">            blen = strlen(BackupSuffix);</a>
<a name="ln271">            flen = strlen(G.filename);</a>
<a name="ln272">            tlen = flen + blen + 6;    /* includes space for 5 digits */</a>
<a name="ln273">            if (tlen &gt;= FILNAMSIZ) {   /* in case name is too long, truncate */</a>
<a name="ln274">                tname = (char *)malloc(FILNAMSIZ);</a>
<a name="ln275">                if (tname == NULL)</a>
<a name="ln276">                    return 1;                 /* in case we run out of space */</a>
<a name="ln277">                tlen = FILNAMSIZ - 1 - blen;</a>
<a name="ln278">                strcpy(tname, G.filename);    /* make backup name */</a>
<a name="ln279">                tname[tlen] = '\0';</a>
<a name="ln280">                if (flen &gt; tlen) flen = tlen;</a>
<a name="ln281">                tlen = FILNAMSIZ;</a>
<a name="ln282">            } else {</a>
<a name="ln283">                tname = (char *)malloc(tlen);</a>
<a name="ln284">                if (tname == NULL)</a>
<a name="ln285">                    return 1;                 /* in case we run out of space */</a>
<a name="ln286">                strcpy(tname, G.filename);    /* make backup name */</a>
<a name="ln287">            }</a>
<a name="ln288">            strcpy(tname+flen, BackupSuffix);</a>
<a name="ln289"> </a>
<a name="ln290">            if (IS_OVERWRT_ALL) {</a>
<a name="ln291">                /* If there is a previous backup file, delete it,</a>
<a name="ln292">                 * otherwise the following rename operation may fail.</a>
<a name="ln293">                 */</a>
<a name="ln294">                if (SSTAT(tname, &amp;tmpstat) == 0)</a>
<a name="ln295">                    unlink(tname);</a>
<a name="ln296">            } else {</a>
<a name="ln297">                /* Check if backupname exists, and, if it's true, try</a>
<a name="ln298">                 * appending numbers of up to 5 digits to the BackupSuffix,</a>
<a name="ln299">                 * until an unused name is found.</a>
<a name="ln300">                 */</a>
<a name="ln301">                unsigned maxtail, i;</a>
<a name="ln302">                char *numtail = tname + flen + blen;</a>
<a name="ln303"> </a>
<a name="ln304">                maxtail = 65535;</a>
<a name="ln305">                switch (tlen - flen - blen - 1) {</a>
<a name="ln306">                    case 4: maxtail = 9999; break;</a>
<a name="ln307">                    case 3: maxtail = 999; break;</a>
<a name="ln308">                    case 2: maxtail = 99; break;</a>
<a name="ln309">                    case 1: maxtail = 9; break;</a>
<a name="ln310">                    case 0: maxtail = 0; break;</a>
<a name="ln311">                }</a>
<a name="ln312">                /* while filename exists */</a>
<a name="ln313">                for (i = 0; (i &lt;= maxtail) &amp;&amp; (SSTAT(tname, &amp;tmpstat) == 0);)</a>
<a name="ln314">                    sprintf(numtail,&quot;%u&quot;, ++i);</a>
<a name="ln315">            }</a>
<a name="ln316"> </a>
<a name="ln317">            if (rename(G.filename, tname) != 0) {   /* move file */</a>
<a name="ln318">                Info(slide, 0x401, ((char *)slide,</a>
<a name="ln319">                  LoadFarString(CannotRenameOldFile), FnFilter1(G.filename)));</a>
<a name="ln320">                free(tname);</a>
<a name="ln321">                return 1;</a>
<a name="ln322">            }</a>
<a name="ln323">            Trace((stderr, &quot;open_outfile:  %s now renamed into %s\n&quot;,</a>
<a name="ln324">              FnFilter1(G.filename), FnFilter2(tname)));</a>
<a name="ln325">            free(tname);</a>
<a name="ln326">        } else</a>
<a name="ln327">#endif /* UNIXBACKUP */</a>
<a name="ln328">        {</a>
<a name="ln329">#ifdef DOS_FLX_OS2_W32</a>
<a name="ln330">            if (!(G.statbuf.st_mode &amp; S_IWRITE)) {</a>
<a name="ln331">                Trace((stderr,</a>
<a name="ln332">                  &quot;open_outfile:  existing file %s is read-only\n&quot;,</a>
<a name="ln333">                  FnFilter1(G.filename)));</a>
<a name="ln334">                chmod(G.filename, S_IREAD | S_IWRITE);</a>
<a name="ln335">                Trace((stderr, &quot;open_outfile:  %s now writable\n&quot;,</a>
<a name="ln336">                  FnFilter1(G.filename)));</a>
<a name="ln337">            }</a>
<a name="ln338">#endif /* DOS_FLX_OS2_W32 */</a>
<a name="ln339">#ifdef NLM</a>
<a name="ln340">            /* Give the file read/write permission (non-POSIX shortcut) */</a>
<a name="ln341">            chmod(G.filename, 0);</a>
<a name="ln342">#endif /* NLM */</a>
<a name="ln343">            if (unlink(G.filename) != 0) {</a>
<a name="ln344">                Info(slide, 0x401, ((char *)slide,</a>
<a name="ln345">                  LoadFarString(CannotDeleteOldFile), FnFilter1(G.filename)));</a>
<a name="ln346">                return 1;</a>
<a name="ln347">            }</a>
<a name="ln348">            Trace((stderr, &quot;open_outfile:  %s now deleted\n&quot;,</a>
<a name="ln349">              FnFilter1(G.filename)));</a>
<a name="ln350">        }</a>
<a name="ln351">    }</a>
<a name="ln352">#endif /* DOS_FLX_NLM_OS2_W32 || BEO_THS_UNX */</a>
<a name="ln353">#ifdef RISCOS</a>
<a name="ln354">    if (SWI_OS_File_7(G.filename,0xDEADDEAD,0xDEADDEAD,G.lrec.ucsize)!=NULL) {</a>
<a name="ln355">        Info(slide, 1, ((char *)slide, LoadFarString(CannotCreateFile),</a>
<a name="ln356">          FnFilter1(G.filename)));</a>
<a name="ln357">        return 1;</a>
<a name="ln358">    }</a>
<a name="ln359">#endif /* RISCOS */</a>
<a name="ln360">#ifdef TOPS20</a>
<a name="ln361">    char *tfilnam;</a>
<a name="ln362"> </a>
<a name="ln363">    if ((tfilnam = (char *)malloc(2*strlen(G.filename)+1)) == (char *)NULL)</a>
<a name="ln364">        return 1;</a>
<a name="ln365">    strcpy(tfilnam, G.filename);</a>
<a name="ln366">    upper(tfilnam);</a>
<a name="ln367">    enquote(tfilnam);</a>
<a name="ln368">    if ((G.outfile = fopen(tfilnam, FOPW)) == (FILE *)NULL) {</a>
<a name="ln369">        Info(slide, 1, ((char *)slide, LoadFarString(CannotCreateFile),</a>
<a name="ln370">          tfilnam));</a>
<a name="ln371">        free(tfilnam);</a>
<a name="ln372">        return 1;</a>
<a name="ln373">    }</a>
<a name="ln374">    free(tfilnam);</a>
<a name="ln375">#else /* !TOPS20 */</a>
<a name="ln376">#ifdef MTS</a>
<a name="ln377">    if (uO.aflag)</a>
<a name="ln378">        G.outfile = fopen(G.filename, FOPWT);</a>
<a name="ln379">    else</a>
<a name="ln380">        G.outfile = fopen(G.filename, FOPW);</a>
<a name="ln381">    if (G.outfile == (FILE *)NULL) {</a>
<a name="ln382">        Info(slide, 1, ((char *)slide, LoadFarString(CannotCreateFile),</a>
<a name="ln383">          FnFilter1(G.filename)));</a>
<a name="ln384">        return 1;</a>
<a name="ln385">    }</a>
<a name="ln386">#else /* !MTS */</a>
<a name="ln387">#ifdef DEBUG</a>
<a name="ln388">    Info(slide, 1, ((char *)slide,</a>
<a name="ln389">      &quot;open_outfile:  doing fopen(%s) for reading\n&quot;, FnFilter1(G.filename)));</a>
<a name="ln390">    if ((G.outfile = fopen(G.filename, FOPR)) == (FILE *)NULL)</a>
<a name="ln391">        Info(slide, 1, ((char *)slide,</a>
<a name="ln392">          &quot;open_outfile:  fopen(%s) for reading failed:  does not exist\n&quot;,</a>
<a name="ln393">          FnFilter1(G.filename)));</a>
<a name="ln394">    else {</a>
<a name="ln395">        Info(slide, 1, ((char *)slide,</a>
<a name="ln396">          &quot;open_outfile:  fopen(%s) for reading succeeded:  file exists\n&quot;,</a>
<a name="ln397">          FnFilter1(G.filename)));</a>
<a name="ln398">        fclose(G.outfile);</a>
<a name="ln399">    }</a>
<a name="ln400">#endif /* DEBUG */</a>
<a name="ln401">#ifdef NOVELL_BUG_FAILSAFE</a>
<a name="ln402">    if (G.dne &amp;&amp; ((G.outfile = fopen(G.filename, FOPR)) != (FILE *)NULL)) {</a>
<a name="ln403">        Info(slide, 0x401, ((char *)slide, LoadFarString(NovellBug),</a>
<a name="ln404">          FnFilter1(G.filename)));</a>
<a name="ln405">        fclose(G.outfile);</a>
<a name="ln406">        return 1;   /* with &quot;./&quot; fix in checkdir(), should never reach here */</a>
<a name="ln407">    }</a>
<a name="ln408">#endif /* NOVELL_BUG_FAILSAFE */</a>
<a name="ln409">    Trace((stderr, &quot;open_outfile:  doing fopen(%s) for writing\n&quot;,</a>
<a name="ln410">      FnFilter1(G.filename)));</a>
<a name="ln411">    if ((G.outfile = fopen(G.filename, FOPW)) == (FILE *)NULL) {</a>
<a name="ln412">        Info(slide, 0x401, ((char *)slide, LoadFarString(CannotCreateFile),</a>
<a name="ln413">          FnFilter1(G.filename)));</a>
<a name="ln414">        return 1;</a>
<a name="ln415">    }</a>
<a name="ln416">    Trace((stderr, &quot;open_outfile:  fopen(%s) for writing succeeded\n&quot;,</a>
<a name="ln417">      FnFilter1(G.filename)));</a>
<a name="ln418">#endif /* !MTS */</a>
<a name="ln419">#endif /* !TOPS20 */</a>
<a name="ln420"> </a>
<a name="ln421">#ifdef USE_FWRITE</a>
<a name="ln422">#ifdef DOS_NLM_OS2_W32</a>
<a name="ln423">    /* 16-bit MSC: buffer size must be strictly LESS than 32K (WSIZE):  bogus */</a>
<a name="ln424">    setbuf(G.outfile, (char *)NULL);   /* make output unbuffered */</a>
<a name="ln425">#else /* !DOS_NLM_OS2_W32 */</a>
<a name="ln426">#ifndef RISCOS</a>
<a name="ln427">#ifdef _IOFBF  /* make output fully buffered (works just about like write()) */</a>
<a name="ln428">    setvbuf(G.outfile, (char *)slide, _IOFBF, WSIZE);</a>
<a name="ln429">#else</a>
<a name="ln430">    setbuf(G.outfile, (char *)slide);</a>
<a name="ln431">#endif</a>
<a name="ln432">#endif /* !RISCOS */</a>
<a name="ln433">#endif /* ?DOS_NLM_OS2_W32 */</a>
<a name="ln434">#endif /* USE_FWRITE */</a>
<a name="ln435">#ifdef OS2_W32</a>
<a name="ln436">    /* preallocate the final file size to prevent file fragmentation */</a>
<a name="ln437">    SetFileSize(G.outfile, G.pInfo-&gt;uncompr_size);</a>
<a name="ln438">#endif</a>
<a name="ln439">    return 0;</a>
<a name="ln440"> </a>
<a name="ln441">} /* end function open_outfile() */</a>
<a name="ln442"> </a>
<a name="ln443">#endif /* !TANDEM */</a>
<a name="ln444">#endif /* !VMS &amp;&amp; !AOS_VS &amp;&amp; !CMS_MVS &amp;&amp; !MACOS */</a>
<a name="ln445"> </a>
<a name="ln446"> </a>
<a name="ln447"> </a>
<a name="ln448"> </a>
<a name="ln449"> </a>
<a name="ln450">/*</a>
<a name="ln451"> * These functions allow NEXTBYTE to function without needing two bounds</a>
<a name="ln452"> * checks.  Call defer_leftover_input() if you ever have filled G.inbuf</a>
<a name="ln453"> * by some means other than readbyte(), and you then want to start using</a>
<a name="ln454"> * NEXTBYTE.  When going back to processing bytes without NEXTBYTE, call</a>
<a name="ln455"> * undefer_input().  For example, extract_or_test_member brackets its</a>
<a name="ln456"> * central section that does the decompression with these two functions.</a>
<a name="ln457"> * If you need to check the number of bytes remaining in the current</a>
<a name="ln458"> * file while using NEXTBYTE, check (G.csize + G.incnt), not G.csize.</a>
<a name="ln459"> */</a>
<a name="ln460"> </a>
<a name="ln461">/****************************/</a>
<a name="ln462">/* function undefer_input() */</a>
<a name="ln463">/****************************/</a>
<a name="ln464"> </a>
<a name="ln465">void undefer_input(__G)</a>
<a name="ln466">    __GDEF</a>
<a name="ln467">{</a>
<a name="ln468">    if (G.incnt &gt; 0)</a>
<a name="ln469">        G.csize += G.incnt;</a>
<a name="ln470">    if (G.incnt_leftover &gt; 0) {</a>
<a name="ln471">        /* We know that &quot;(G.csize &lt; MAXINT)&quot; so we can cast G.csize to int:</a>
<a name="ln472">         * This condition was checked when G.incnt_leftover was set &gt; 0 in</a>
<a name="ln473">         * defer_leftover_input(), and it is NOT allowed to touch G.csize</a>
<a name="ln474">         * before calling undefer_input() when (G.incnt_leftover &gt; 0)</a>
<a name="ln475">         * (single exception: see read_byte()'s  &quot;G.csize &lt;= 0&quot; handling) !!</a>
<a name="ln476">         */</a>
<a name="ln477">        G.incnt = G.incnt_leftover + (int)G.csize;</a>
<a name="ln478">        G.inptr = G.inptr_leftover - (int)G.csize;</a>
<a name="ln479">        G.incnt_leftover = 0;</a>
<a name="ln480">    } else if (G.incnt &lt; 0)</a>
<a name="ln481">        G.incnt = 0;</a>
<a name="ln482">} /* end function undefer_input() */</a>
<a name="ln483"> </a>
<a name="ln484"> </a>
<a name="ln485"> </a>
<a name="ln486"> </a>
<a name="ln487"> </a>
<a name="ln488">/***********************************/</a>
<a name="ln489">/* function defer_leftover_input() */</a>
<a name="ln490">/***********************************/</a>
<a name="ln491"> </a>
<a name="ln492">void defer_leftover_input(__G)</a>
<a name="ln493">    __GDEF</a>
<a name="ln494">{</a>
<a name="ln495">    if ((long)G.incnt &gt; G.csize) {</a>
<a name="ln496">        /* (G.csize &lt; MAXINT), we can safely cast it to int !! */</a>
<a name="ln497">        if (G.csize &lt; 0L)</a>
<a name="ln498">            G.csize = 0L;</a>
<a name="ln499">        G.inptr_leftover = G.inptr + (int)G.csize;</a>
<a name="ln500">        G.incnt_leftover = G.incnt - (int)G.csize;</a>
<a name="ln501">        G.incnt = (int)G.csize;</a>
<a name="ln502">    } else</a>
<a name="ln503">        G.incnt_leftover = 0;</a>
<a name="ln504">    G.csize -= G.incnt;</a>
<a name="ln505">} /* end function defer_leftover_input() */</a>
<a name="ln506"> </a>
<a name="ln507"> </a>
<a name="ln508"> </a>
<a name="ln509"> </a>
<a name="ln510"> </a>
<a name="ln511">/**********************/</a>
<a name="ln512">/* Function readbuf() */</a>
<a name="ln513">/**********************/</a>
<a name="ln514"> </a>
<a name="ln515">unsigned readbuf(__G__ buf, size)   /* return number of bytes read into buf */</a>
<a name="ln516">    __GDEF</a>
<a name="ln517">    char *buf;</a>
<a name="ln518">    register unsigned size;</a>
<a name="ln519">{</a>
<a name="ln520">    register unsigned count;</a>
<a name="ln521">    unsigned n;</a>
<a name="ln522"> </a>
<a name="ln523">    n = size;</a>
<a name="ln524">    while (size) {</a>
<a name="ln525">        if (G.incnt &lt;= 0) {</a>
<a name="ln526">            if ((G.incnt = read(G.zipfd, (char *)G.inbuf, INBUFSIZ)) == 0)</a>
<a name="ln527">                return (n-size);</a>
<a name="ln528">            else if (G.incnt &lt; 0) {</a>
<a name="ln529">                /* another hack, but no real harm copying same thing twice */</a>
<a name="ln530">                (*G.message)((zvoid *)&amp;G,</a>
<a name="ln531">                  (uch *)LoadFarString(ReadError),  /* CANNOT use slide */</a>
<a name="ln532">                  (ulg)strlen(LoadFarString(ReadError)), 0x401);</a>
<a name="ln533">                return 0;  /* discarding some data; better than lock-up */</a>
<a name="ln534">            }</a>
<a name="ln535">            /* buffer ALWAYS starts on a block boundary:  */</a>
<a name="ln536">            G.cur_zipfile_bufstart += INBUFSIZ;</a>
<a name="ln537">            G.inptr = G.inbuf;</a>
<a name="ln538">        }</a>
<a name="ln539">        count = MIN(size, (unsigned)G.incnt);</a>
<a name="ln540">        memcpy(buf, G.inptr, count);</a>
<a name="ln541">        buf += count;</a>
<a name="ln542">        G.inptr += count;</a>
<a name="ln543">        G.incnt -= count;</a>
<a name="ln544">        size -= count;</a>
<a name="ln545">    }</a>
<a name="ln546">    return n;</a>
<a name="ln547"> </a>
<a name="ln548">} /* end function readbuf() */</a>
<a name="ln549"> </a>
<a name="ln550"> </a>
<a name="ln551"> </a>
<a name="ln552"> </a>
<a name="ln553"> </a>
<a name="ln554">/***********************/</a>
<a name="ln555">/* Function readbyte() */</a>
<a name="ln556">/***********************/</a>
<a name="ln557"> </a>
<a name="ln558">int readbyte(__G)   /* refill inbuf and return a byte if available, else EOF */</a>
<a name="ln559">    __GDEF</a>
<a name="ln560">{</a>
<a name="ln561">    if (G.mem_mode)</a>
<a name="ln562">        return EOF;</a>
<a name="ln563">    if (G.csize &lt;= 0) {</a>
<a name="ln564">        G.csize--;             /* for tests done after exploding */</a>
<a name="ln565">        G.incnt = 0;</a>
<a name="ln566">        return EOF;</a>
<a name="ln567">    }</a>
<a name="ln568">    if (G.incnt &lt;= 0) {</a>
<a name="ln569">        if ((G.incnt = read(G.zipfd, (char *)G.inbuf, INBUFSIZ)) == 0) {</a>
<a name="ln570">            G.incnt = 0;       /* do not allow negative value to affect stuff */</a>
<a name="ln571">            return EOF;</a>
<a name="ln572">        } else if (G.incnt &lt; 0) {  /* &quot;fail&quot; (abort, retry, ...) returns this */</a>
<a name="ln573">            /* another hack, but no real harm copying same thing twice */</a>
<a name="ln574">            (*G.message)((zvoid *)&amp;G,</a>
<a name="ln575">              (uch *)LoadFarString(ReadError),</a>
<a name="ln576">              (ulg)strlen(LoadFarString(ReadError)), 0x401);</a>
<a name="ln577">            echon();</a>
<a name="ln578">#ifdef WINDLL</a>
<a name="ln579">            longjmp(dll_error_return, 1);</a>
<a name="ln580">#else</a>
<a name="ln581">            DESTROYGLOBALS();</a>
<a name="ln582">            EXIT(PK_BADERR);    /* totally bailing; better than lock-up */</a>
<a name="ln583">#endif</a>
<a name="ln584">        }</a>
<a name="ln585">        G.cur_zipfile_bufstart += INBUFSIZ; /* always starts on block bndry */</a>
<a name="ln586">        G.inptr = G.inbuf;</a>
<a name="ln587">        defer_leftover_input(__G);           /* decrements G.csize */</a>
<a name="ln588">    }</a>
<a name="ln589"> </a>
<a name="ln590">#if CRYPT</a>
<a name="ln591">    if (G.pInfo-&gt;encrypted) {</a>
<a name="ln592">        uch *p;</a>
<a name="ln593">        int n;</a>
<a name="ln594"> </a>
<a name="ln595">        /* This was previously set to decrypt one byte beyond G.csize, when</a>
<a name="ln596">         * incnt reached that far.  GRR said, &quot;but it's required:  why?&quot;  This</a>
<a name="ln597">         * was a bug in fillinbuf() -- was it also a bug here?</a>
<a name="ln598">         */</a>
<a name="ln599">        for (n = G.incnt, p = G.inptr;  n--;  p++)</a>
<a name="ln600">            zdecode(*p);</a>
<a name="ln601">    }</a>
<a name="ln602">#endif /* CRYPT */</a>
<a name="ln603"> </a>
<a name="ln604">    --G.incnt;</a>
<a name="ln605">    return *G.inptr++;</a>
<a name="ln606"> </a>
<a name="ln607">} /* end function readbyte() */</a>
<a name="ln608"> </a>
<a name="ln609"> </a>
<a name="ln610"> </a>
<a name="ln611"> </a>
<a name="ln612"> </a>
<a name="ln613">#ifdef USE_ZLIB</a>
<a name="ln614"> </a>
<a name="ln615">/************************/</a>
<a name="ln616">/* Function fillinbuf() */</a>
<a name="ln617">/************************/</a>
<a name="ln618"> </a>
<a name="ln619">int fillinbuf(__G) /* like readbyte() except returns number of bytes in inbuf */</a>
<a name="ln620">    __GDEF</a>
<a name="ln621">{</a>
<a name="ln622">    if (G.mem_mode ||</a>
<a name="ln623">                  (G.incnt = read(G.zipfd, (char *)G.inbuf, INBUFSIZ)) &lt;= 0)</a>
<a name="ln624">        return 0;</a>
<a name="ln625">    G.cur_zipfile_bufstart += INBUFSIZ;  /* always starts on a block boundary */</a>
<a name="ln626">    G.inptr = G.inbuf;</a>
<a name="ln627">    defer_leftover_input(__G);           /* decrements G.csize */</a>
<a name="ln628"> </a>
<a name="ln629">#if CRYPT</a>
<a name="ln630">    if (G.pInfo-&gt;encrypted) {</a>
<a name="ln631">        uch *p;</a>
<a name="ln632">        int n;</a>
<a name="ln633"> </a>
<a name="ln634">        for (n = G.incnt, p = G.inptr;  n--;  p++)</a>
<a name="ln635">            zdecode(*p);</a>
<a name="ln636">    }</a>
<a name="ln637">#endif /* CRYPT */</a>
<a name="ln638"> </a>
<a name="ln639">    return G.incnt;</a>
<a name="ln640"> </a>
<a name="ln641">} /* end function fillinbuf() */</a>
<a name="ln642"> </a>
<a name="ln643">#endif /* USE_ZLIB */</a>
<a name="ln644"> </a>
<a name="ln645"> </a>
<a name="ln646"> </a>
<a name="ln647"> </a>
<a name="ln648"> </a>
<a name="ln649">/************************/</a>
<a name="ln650">/* Function seek_zipf() */</a>
<a name="ln651">/************************/</a>
<a name="ln652"> </a>
<a name="ln653">int seek_zipf(__G__ abs_offset)</a>
<a name="ln654">    __GDEF</a>
<a name="ln655">    LONGINT abs_offset;</a>
<a name="ln656">{</a>
<a name="ln657">/*</a>
<a name="ln658"> *  Seek to the block boundary of the block which includes abs_offset,</a>
<a name="ln659"> *  then read block into input buffer and set pointers appropriately.</a>
<a name="ln660"> *  If block is already in the buffer, just set the pointers.  This function</a>
<a name="ln661"> *  is used by do_seekable (process.c), extract_or_test_entrylist (extract.c)</a>
<a name="ln662"> *  and do_string (fileio.c).  Also, a slightly modified version is embedded</a>
<a name="ln663"> *  within extract_or_test_entrylist (extract.c).  readbyte() and readbuf()</a>
<a name="ln664"> *  (fileio.c) are compatible.  NOTE THAT abs_offset is intended to be the</a>
<a name="ln665"> *  &quot;proper offset&quot; (i.e., if there were no extra bytes prepended);</a>
<a name="ln666"> *  cur_zipfile_bufstart contains the corrected offset.</a>
<a name="ln667"> *</a>
<a name="ln668"> *  Since seek_zipf() is never used during decompression, it is safe to</a>
<a name="ln669"> *  use the slide[] buffer for the error message.</a>
<a name="ln670"> *</a>
<a name="ln671"> * returns PK error codes:</a>
<a name="ln672"> *  PK_BADERR if effective offset in zipfile is negative</a>
<a name="ln673"> *  PK_EOF if seeking past end of zipfile</a>
<a name="ln674"> *  PK_OK when seek was successful</a>
<a name="ln675"> */</a>
<a name="ln676">    LONGINT request = abs_offset + G.extra_bytes;</a>
<a name="ln677">    LONGINT inbuf_offset = request % INBUFSIZ;</a>
<a name="ln678">    LONGINT bufstart = request - inbuf_offset;</a>
<a name="ln679"> </a>
<a name="ln680">    if (request &lt; 0) {</a>
<a name="ln681">        Info(slide, 1, ((char *)slide, LoadFarStringSmall(SeekMsg),</a>
<a name="ln682">             G.zipfn, LoadFarString(ReportMsg)));</a>
<a name="ln683">        return(PK_BADERR);</a>
<a name="ln684">    } else if (bufstart != G.cur_zipfile_bufstart) {</a>
<a name="ln685">        Trace((stderr,</a>
<a name="ln686">          &quot;fpos_zip: abs_offset = %ld, G.extra_bytes = %ld\n&quot;,</a>
<a name="ln687">          abs_offset, G.extra_bytes));</a>
<a name="ln688">#ifdef USE_STRM_INPUT</a>
<a name="ln689">        fseek(G.zipfd, (LONGINT)bufstart, SEEK_SET);</a>
<a name="ln690">        G.cur_zipfile_bufstart = ftell(G.zipfd);</a>
<a name="ln691">#else /* !USE_STRM_INPUT */</a>
<a name="ln692">        G.cur_zipfile_bufstart = lseek(G.zipfd, (LONGINT)bufstart, SEEK_SET);</a>
<a name="ln693">#endif /* ?USE_STRM_INPUT */</a>
<a name="ln694">        Trace((stderr,</a>
<a name="ln695">          &quot;       request = %ld, (abs+extra) = %ld, inbuf_offset = %ld\n&quot;,</a>
<a name="ln696">          request, (abs_offset+G.extra_bytes), inbuf_offset));</a>
<a name="ln697">        Trace((stderr, &quot;       bufstart = %ld, cur_zipfile_bufstart = %ld\n&quot;,</a>
<a name="ln698">          bufstart, G.cur_zipfile_bufstart));</a>
<a name="ln699">        if ((G.incnt = read(G.zipfd, (char *)G.inbuf, INBUFSIZ)) &lt;= 0)</a>
<a name="ln700">            return(PK_EOF);</a>
<a name="ln701">        G.incnt -= (int)inbuf_offset;</a>
<a name="ln702">        G.inptr = G.inbuf + (int)inbuf_offset;</a>
<a name="ln703">    } else {</a>
<a name="ln704">        G.incnt += (G.inptr-G.inbuf) - (int)inbuf_offset;</a>
<a name="ln705">        G.inptr = G.inbuf + (int)inbuf_offset;</a>
<a name="ln706">    }</a>
<a name="ln707">    return(PK_OK);</a>
<a name="ln708">} /* end function seek_zipf() */</a>
<a name="ln709"> </a>
<a name="ln710"> </a>
<a name="ln711"> </a>
<a name="ln712"> </a>
<a name="ln713"> </a>
<a name="ln714">#ifndef VMS  /* for VMS use code in vms.c */</a>
<a name="ln715"> </a>
<a name="ln716">/********************/</a>
<a name="ln717">/* Function flush() */   /* returns PK error codes: */</a>
<a name="ln718">/********************/   /* if cflag =&gt; always 0; PK_DISK if write error */</a>
<a name="ln719"> </a>
<a name="ln720">int flush(__G__ rawbuf, size, unshrink)</a>
<a name="ln721">    __GDEF</a>
<a name="ln722">    uch *rawbuf;</a>
<a name="ln723">    ulg size;</a>
<a name="ln724">    int unshrink;</a>
<a name="ln725">#if (defined(USE_DEFLATE64) &amp;&amp; defined(__16BIT__))</a>
<a name="ln726">{</a>
<a name="ln727">    int ret;</a>
<a name="ln728"> </a>
<a name="ln729">    /* On 16-bit systems (MSDOS, OS/2 1.x), the standard C library functions</a>
<a name="ln730">     * cannot handle writes of 64k blocks at once.  For these systems, the</a>
<a name="ln731">     * blocks to flush are split into pieces of 32k or less.</a>
<a name="ln732">     */</a>
<a name="ln733">    while (size &gt; 0x8000L) {</a>
<a name="ln734">        ret = partflush(__G__ rawbuf, 0x8000L, unshrink);</a>
<a name="ln735">        if (ret != PK_OK)</a>
<a name="ln736">            return ret;</a>
<a name="ln737">        size -= 0x8000L;</a>
<a name="ln738">        rawbuf += (unsigned)0x8000;</a>
<a name="ln739">    }</a>
<a name="ln740">    return partflush(__G__ rawbuf, size, unshrink);</a>
<a name="ln741">} /* end function flush() */</a>
<a name="ln742"> </a>
<a name="ln743"> </a>
<a name="ln744">/************************/</a>
<a name="ln745">/* Function partflush() */  /* returns PK error codes: */</a>
<a name="ln746">/************************/  /* if cflag =&gt; always 0; PK_DISK if write error */</a>
<a name="ln747"> </a>
<a name="ln748">static int partflush(__G__ rawbuf, size, unshrink)</a>
<a name="ln749">    __GDEF</a>
<a name="ln750">    uch *rawbuf;        /* cannot be ZCONST, gets passed to (*G.message)() */</a>
<a name="ln751">    ulg size;</a>
<a name="ln752">    int unshrink;</a>
<a name="ln753">#endif /* USE_DEFLATE64 &amp;&amp; __16BIT__ */</a>
<a name="ln754">{</a>
<a name="ln755">    register uch *p;</a>
<a name="ln756">    register uch *q;</a>
<a name="ln757">    uch *transbuf;</a>
<a name="ln758">#if (defined(SMALL_MEM) || defined(MED_MEM) || defined(VMS_TEXT_CONV))</a>
<a name="ln759">    ulg transbufsiz;</a>
<a name="ln760">#endif</a>
<a name="ln761">    /* static int didCRlast = FALSE;    moved to globals.h */</a>
<a name="ln762"> </a>
<a name="ln763"> </a>
<a name="ln764">/*---------------------------------------------------------------------------</a>
<a name="ln765">    Compute the CRC first; if testing or if disk is full, that's it.</a>
<a name="ln766">  ---------------------------------------------------------------------------*/</a>
<a name="ln767"> </a>
<a name="ln768">    G.crc32val = crc32(G.crc32val, rawbuf, (extent)size);</a>
<a name="ln769"> </a>
<a name="ln770">#ifdef DLL</a>
<a name="ln771">    if ((G.statreportcb != NULL) &amp;&amp;</a>
<a name="ln772">        (*G.statreportcb)(__G__ UZ_ST_IN_PROGRESS, G.zipfn, G.filename, NULL))</a>
<a name="ln773">        return IZ_CTRLC;        /* cancel operation by user request */</a>
<a name="ln774">#endif</a>
<a name="ln775"> </a>
<a name="ln776">    if (uO.tflag || size == 0L)  /* testing or nothing to write:  all done */</a>
<a name="ln777">        return PK_OK;</a>
<a name="ln778"> </a>
<a name="ln779">    if (G.disk_full)</a>
<a name="ln780">        return PK_DISK;         /* disk already full:  ignore rest of file */</a>
<a name="ln781"> </a>
<a name="ln782">/*---------------------------------------------------------------------------</a>
<a name="ln783">    Write the bytes rawbuf[0..size-1] to the output device, first converting</a>
<a name="ln784">    end-of-lines and ASCII/EBCDIC as needed.  If SMALL_MEM or MED_MEM are NOT</a>
<a name="ln785">    defined, outbuf is assumed to be at least as large as rawbuf and is not</a>
<a name="ln786">    necessarily checked for overflow.</a>
<a name="ln787">  ---------------------------------------------------------------------------*/</a>
<a name="ln788"> </a>
<a name="ln789">    if (!G.pInfo-&gt;textmode) {   /* write raw binary data */</a>
<a name="ln790">        /* GRR:  note that for standard MS-DOS compilers, size argument to</a>
<a name="ln791">         * fwrite() can never be more than 65534, so WriteError macro will</a>
<a name="ln792">         * have to be rewritten if size can ever be that large.  For now,</a>
<a name="ln793">         * never more than 32K.  Also note that write() returns an int, which</a>
<a name="ln794">         * doesn't necessarily limit size to 32767 bytes if write() is used</a>
<a name="ln795">         * on 16-bit systems but does make it more of a pain; however, because</a>
<a name="ln796">         * at least MSC 5.1 has a lousy implementation of fwrite() (as does</a>
<a name="ln797">         * DEC Ultrix cc), write() is used anyway.</a>
<a name="ln798">         */</a>
<a name="ln799">#ifdef DLL</a>
<a name="ln800">        if (G.redirect_data)</a>
<a name="ln801">            writeToMemory(__G__ rawbuf, (extent)size);</a>
<a name="ln802">        else</a>
<a name="ln803">#endif</a>
<a name="ln804">        if (!uO.cflag &amp;&amp; WriteError(rawbuf, size, G.outfile))</a>
<a name="ln805">            return disk_error(__G);</a>
<a name="ln806">        else if (uO.cflag &amp;&amp; (*G.message)((zvoid *)&amp;G, rawbuf, size, 0))</a>
<a name="ln807">            return PK_OK;</a>
<a name="ln808">    } else {   /* textmode:  aflag is true */</a>
<a name="ln809">        if (unshrink) {</a>
<a name="ln810">            /* rawbuf = outbuf */</a>
<a name="ln811">            transbuf = G.outbuf2;</a>
<a name="ln812">#if (defined(SMALL_MEM) || defined(MED_MEM) || defined(VMS_TEXT_CONV))</a>
<a name="ln813">            transbufsiz = TRANSBUFSIZ;</a>
<a name="ln814">#endif</a>
<a name="ln815">        } else {</a>
<a name="ln816">            /* rawbuf = slide */</a>
<a name="ln817">            transbuf = G.outbuf;</a>
<a name="ln818">#if (defined(SMALL_MEM) || defined(MED_MEM) || defined(VMS_TEXT_CONV))</a>
<a name="ln819">            transbufsiz = OUTBUFSIZ;</a>
<a name="ln820">            Trace((stderr, &quot;\ntransbufsiz = OUTBUFSIZ = %u\n&quot;,</a>
<a name="ln821">                   (unsigned)OUTBUFSIZ));</a>
<a name="ln822">#endif</a>
<a name="ln823">        }</a>
<a name="ln824">        if (G.newfile) {</a>
<a name="ln825">#ifdef VMS_TEXT_CONV</a>
<a name="ln826">            if (G.pInfo-&gt;hostnum == VMS_ &amp;&amp; G.extra_field &amp;&amp;</a>
<a name="ln827">                is_vms_varlen_txt(__G__ G.extra_field,</a>
<a name="ln828">                                  G.lrec.extra_field_length))</a>
<a name="ln829">                G.VMS_line_state = 0;    /* 0: ready to read line length */</a>
<a name="ln830">            else</a>
<a name="ln831">                G.VMS_line_state = -1;   /* -1: don't treat as VMS text */</a>
<a name="ln832">#endif</a>
<a name="ln833">            G.didCRlast = FALSE;         /* no previous buffers written */</a>
<a name="ln834">            G.newfile = FALSE;</a>
<a name="ln835">        }</a>
<a name="ln836"> </a>
<a name="ln837">#ifdef VMS_TEXT_CONV</a>
<a name="ln838">        if (G.VMS_line_state &gt;= 0)</a>
<a name="ln839">        {</a>
<a name="ln840">            /* GRR: really want to check for actual VMS extra field, and</a>
<a name="ln841">             *      ideally for variable-length record format */</a>
<a name="ln842">/*</a>
<a name="ln843">            printf(&quot;\n&gt;&gt;&gt;&gt;&gt;&gt; GRR:  file is VMS text and has an extra field\n&quot;);</a>
<a name="ln844"> */</a>
<a name="ln845"> </a>
<a name="ln846">            p = rawbuf;</a>
<a name="ln847">            q = transbuf;</a>
<a name="ln848">            while (p &lt; rawbuf+(unsigned)size) {</a>
<a name="ln849">                switch (G.VMS_line_state) {</a>
<a name="ln850"> </a>
<a name="ln851">                    /* 0: ready to read line length */</a>
<a name="ln852">                    case 0:</a>
<a name="ln853">                        G.VMS_line_length = 0;</a>
<a name="ln854">                        if (p == rawbuf+(unsigned)size-1) {    /* last char */</a>
<a name="ln855">                            G.VMS_line_length = (unsigned)(*p++);</a>
<a name="ln856">                            G.VMS_line_state = 1;</a>
<a name="ln857">                        } else {</a>
<a name="ln858">                            G.VMS_line_length = makeword(p);</a>
<a name="ln859">                            p += 2;</a>
<a name="ln860">                            G.VMS_line_state = 2;</a>
<a name="ln861">                        }</a>
<a name="ln862">                        G.VMS_line_pad =</a>
<a name="ln863">                               ((G.VMS_line_length &amp; 1) != 0); /* odd */</a>
<a name="ln864">                        break;</a>
<a name="ln865"> </a>
<a name="ln866">                    /* 1: read one byte of length, need second */</a>
<a name="ln867">                    case 1:</a>
<a name="ln868">                        G.VMS_line_length += ((unsigned)(*p++) &lt;&lt; 8);</a>
<a name="ln869">                        G.VMS_line_state = 2;</a>
<a name="ln870">                        break;</a>
<a name="ln871"> </a>
<a name="ln872">                    /* 2: ready to read VMS_line_length chars */</a>
<a name="ln873">                    case 2:</a>
<a name="ln874">                        {</a>
<a name="ln875">                            extent remaining = rawbuf+(unsigned)size-p;</a>
<a name="ln876">                            extent outroom;</a>
<a name="ln877"> </a>
<a name="ln878">                            if (G.VMS_line_length &lt; remaining) {</a>
<a name="ln879">                                remaining = G.VMS_line_length;</a>
<a name="ln880">                                G.VMS_line_state = 3;</a>
<a name="ln881">                            }</a>
<a name="ln882"> </a>
<a name="ln883">                            outroom = transbuf+(unsigned)transbufsiz-q;</a>
<a name="ln884">                            if (remaining &gt;= outroom) {</a>
<a name="ln885">                                remaining -= outroom;</a>
<a name="ln886">                                for (;outroom &gt; 0; p++, outroom--)</a>
<a name="ln887">                                    *q++ = native(*p);</a>
<a name="ln888">#ifdef DLL</a>
<a name="ln889">                                if (G.redirect_data)</a>
<a name="ln890">                                    writeToMemory(__G__ transbuf,</a>
<a name="ln891">                                      (extent)(q-transbuf));</a>
<a name="ln892">                                else</a>
<a name="ln893">#endif</a>
<a name="ln894">                                if (!uO.cflag &amp;&amp; WriteError(transbuf,</a>
<a name="ln895">                                    (extent)(q-transbuf), G.outfile))</a>
<a name="ln896">                                    return disk_error(__G);</a>
<a name="ln897">                                else if (uO.cflag &amp;&amp; (*G.message)((zvoid *)&amp;G,</a>
<a name="ln898">                                         transbuf, (ulg)(q-transbuf), 0))</a>
<a name="ln899">                                    return PK_OK;</a>
<a name="ln900">                                q = transbuf;</a>
<a name="ln901">                                /* fall through to normal case */</a>
<a name="ln902">                            }</a>
<a name="ln903">                            G.VMS_line_length -= remaining;</a>
<a name="ln904">                            for (;remaining &gt; 0; p++, remaining--)</a>
<a name="ln905">                                *q++ = native(*p);</a>
<a name="ln906">                        }</a>
<a name="ln907">                        break;</a>
<a name="ln908"> </a>
<a name="ln909">                    /* 3: ready to PutNativeEOL */</a>
<a name="ln910">                    case 3:</a>
<a name="ln911">                        if (q &gt; transbuf+(unsigned)transbufsiz-lenEOL) {</a>
<a name="ln912">#ifdef DLL</a>
<a name="ln913">                            if (G.redirect_data)</a>
<a name="ln914">                                writeToMemory(__G__ transbuf,</a>
<a name="ln915">                                  (extent)(q-transbuf));</a>
<a name="ln916">                            else</a>
<a name="ln917">#endif</a>
<a name="ln918">                            if (!uO.cflag &amp;&amp;</a>
<a name="ln919">                                WriteError(transbuf, (extent)(q-transbuf),</a>
<a name="ln920">                                  G.outfile))</a>
<a name="ln921">                                return disk_error(__G);</a>
<a name="ln922">                            else if (uO.cflag &amp;&amp; (*G.message)((zvoid *)&amp;G,</a>
<a name="ln923">                                     transbuf, (ulg)(q-transbuf), 0))</a>
<a name="ln924">                                return PK_OK;</a>
<a name="ln925">                            q = transbuf;</a>
<a name="ln926">                        }</a>
<a name="ln927">                        PutNativeEOL</a>
<a name="ln928">                        G.VMS_line_state = G.VMS_line_pad ? 4 : 0;</a>
<a name="ln929">                        break;</a>
<a name="ln930"> </a>
<a name="ln931">                    /* 4: ready to read pad byte */</a>
<a name="ln932">                    case 4:</a>
<a name="ln933">                        ++p;</a>
<a name="ln934">                        G.VMS_line_state = 0;</a>
<a name="ln935">                        break;</a>
<a name="ln936">                }</a>
<a name="ln937">            } /* end while */</a>
<a name="ln938"> </a>
<a name="ln939">        } else</a>
<a name="ln940">#endif /* VMS_TEXT_CONV */</a>
<a name="ln941"> </a>
<a name="ln942">    /*-----------------------------------------------------------------------</a>
<a name="ln943">        Algorithm:  CR/LF =&gt; native; lone CR =&gt; native; lone LF =&gt; native.</a>
<a name="ln944">        This routine is only for non-raw-VMS, non-raw-VM/CMS files (i.e.,</a>
<a name="ln945">        stream-oriented files, not record-oriented).</a>
<a name="ln946">      -----------------------------------------------------------------------*/</a>
<a name="ln947"> </a>
<a name="ln948">        /* else not VMS text */ {</a>
<a name="ln949">            p = rawbuf;</a>
<a name="ln950">            if (*p == LF &amp;&amp; G.didCRlast)</a>
<a name="ln951">                ++p;</a>
<a name="ln952">            G.didCRlast = FALSE;</a>
<a name="ln953">            for (q = transbuf;  p &lt; rawbuf+(unsigned)size;  ++p) {</a>
<a name="ln954">                if (*p == CR) {           /* lone CR or CR/LF: treat as EOL  */</a>
<a name="ln955">                    PutNativeEOL</a>
<a name="ln956">                    if (p == rawbuf+(unsigned)size-1) /* last char in buffer */</a>
<a name="ln957">                        G.didCRlast = TRUE;</a>
<a name="ln958">                    else if (p[1] == LF)  /* get rid of accompanying LF */</a>
<a name="ln959">                        ++p;</a>
<a name="ln960">                } else if (*p == LF)      /* lone LF */</a>
<a name="ln961">                    PutNativeEOL</a>
<a name="ln962">                else</a>
<a name="ln963">#ifndef DOS_FLX_OS2_W32</a>
<a name="ln964">                if (*p != CTRLZ)          /* lose all ^Z's */</a>
<a name="ln965">#endif</a>
<a name="ln966">                    *q++ = native(*p);</a>
<a name="ln967"> </a>
<a name="ln968">#if (defined(SMALL_MEM) || defined(MED_MEM))</a>
<a name="ln969"># if (lenEOL == 1)   /* don't check unshrink:  both buffers small but equal */</a>
<a name="ln970">                if (!unshrink)</a>
<a name="ln971"># endif</a>
<a name="ln972">                    /* check for danger of buffer overflow and flush */</a>
<a name="ln973">                    if (q &gt; transbuf+(unsigned)transbufsiz-lenEOL) {</a>
<a name="ln974">                        Trace((stderr,</a>
<a name="ln975">                          &quot;p - rawbuf = %u   q-transbuf = %u   size = %lu\n&quot;,</a>
<a name="ln976">                          (unsigned)(p-rawbuf), (unsigned)(q-transbuf), size));</a>
<a name="ln977">                        if (!uO.cflag &amp;&amp; WriteError(transbuf,</a>
<a name="ln978">                            (extent)(q-transbuf), G.outfile))</a>
<a name="ln979">                            return disk_error(__G);</a>
<a name="ln980">                        else if (uO.cflag &amp;&amp; (*G.message)((zvoid *)&amp;G,</a>
<a name="ln981">                                 transbuf, (ulg)(q-transbuf), 0))</a>
<a name="ln982">                            return PK_OK;</a>
<a name="ln983">                        q = transbuf;</a>
<a name="ln984">                        continue;</a>
<a name="ln985">                    }</a>
<a name="ln986">#endif /* SMALL_MEM || MED_MEM */</a>
<a name="ln987">            }</a>
<a name="ln988">        }</a>
<a name="ln989"> </a>
<a name="ln990">    /*-----------------------------------------------------------------------</a>
<a name="ln991">        Done translating:  write whatever we've got to file (or screen).</a>
<a name="ln992">      -----------------------------------------------------------------------*/</a>
<a name="ln993"> </a>
<a name="ln994">        Trace((stderr, &quot;p - rawbuf = %u   q-transbuf = %u   size = %lu\n&quot;,</a>
<a name="ln995">          (unsigned)(p-rawbuf), (unsigned)(q-transbuf), size));</a>
<a name="ln996">        if (q &gt; transbuf) {</a>
<a name="ln997">#ifdef DLL</a>
<a name="ln998">            if (G.redirect_data)</a>
<a name="ln999">                writeToMemory(__G__ transbuf, (extent)(q-transbuf));</a>
<a name="ln1000">            else</a>
<a name="ln1001">#endif</a>
<a name="ln1002">            if (!uO.cflag &amp;&amp; WriteError(transbuf, (extent)(q-transbuf),</a>
<a name="ln1003">                G.outfile))</a>
<a name="ln1004">                return disk_error(__G);</a>
<a name="ln1005">            else if (uO.cflag &amp;&amp; (*G.message)((zvoid *)&amp;G, transbuf,</a>
<a name="ln1006">                (ulg)(q-transbuf), 0))</a>
<a name="ln1007">                return PK_OK;</a>
<a name="ln1008">        }</a>
<a name="ln1009">    }</a>
<a name="ln1010"> </a>
<a name="ln1011">    return PK_OK;</a>
<a name="ln1012"> </a>
<a name="ln1013">} /* end function flush() [resp. partflush() for 16-bit Deflate64 support] */</a>
<a name="ln1014"> </a>
<a name="ln1015"> </a>
<a name="ln1016"> </a>
<a name="ln1017"> </a>
<a name="ln1018"> </a>
<a name="ln1019">#ifdef VMS_TEXT_CONV</a>
<a name="ln1020"> </a>
<a name="ln1021">/********************************/</a>
<a name="ln1022">/* Function is_vms_varlen_txt() */</a>
<a name="ln1023">/********************************/</a>
<a name="ln1024"> </a>
<a name="ln1025">static int is_vms_varlen_txt(__G__ ef_buf, ef_len)</a>
<a name="ln1026">    __GDEF</a>
<a name="ln1027">    uch *ef_buf;        /* buffer containing extra field */</a>
<a name="ln1028">    unsigned ef_len;    /* total length of extra field */</a>
<a name="ln1029">{</a>
<a name="ln1030">    unsigned eb_id;</a>
<a name="ln1031">    unsigned eb_len;</a>
<a name="ln1032">    uch *eb_data;</a>
<a name="ln1033">    unsigned eb_datlen;</a>
<a name="ln1034">#define VMSREC_C_UNDEF  0</a>
<a name="ln1035">#define VMSREC_C_VAR    2</a>
<a name="ln1036">    uch vms_rectype = VMSREC_C_UNDEF;</a>
<a name="ln1037">    uch vms_fileorg = 0;</a>
<a name="ln1038"> </a>
<a name="ln1039">#define VMSPK_ITEMID            0</a>
<a name="ln1040">#define VMSPK_ITEMLEN           2</a>
<a name="ln1041">#define VMSPK_ITEMHEADSZ        4</a>
<a name="ln1042"> </a>
<a name="ln1043">#define VMSATR_C_RECATTR        4</a>
<a name="ln1044">#define VMS_FABSIG              0x42414656      /* &quot;VFAB&quot; */</a>
<a name="ln1045">/* offsets of interesting fields in VMS fabdef structure */</a>
<a name="ln1046">#define VMSFAB_B_RFM            31      /* record format byte */</a>
<a name="ln1047">#define VMSFAB_B_ORG            29      /* file organization byte */</a>
<a name="ln1048"> </a>
<a name="ln1049">    if (ef_len == 0 || ef_buf == NULL)</a>
<a name="ln1050">        return FALSE;</a>
<a name="ln1051"> </a>
<a name="ln1052">    while (ef_len &gt;= EB_HEADSIZE) {</a>
<a name="ln1053">        eb_id = makeword(EB_ID + ef_buf);</a>
<a name="ln1054">        eb_len = makeword(EB_LEN + ef_buf);</a>
<a name="ln1055"> </a>
<a name="ln1056">        if (eb_len &gt; (ef_len - EB_HEADSIZE)) {</a>
<a name="ln1057">            /* discovered some extra field inconsistency! */</a>
<a name="ln1058">            Trace((stderr,</a>
<a name="ln1059">              &quot;is_vms_varlen_txt: block length %u &gt; rest ef_size %u\n&quot;, eb_len,</a>
<a name="ln1060">              ef_len - EB_HEADSIZE));</a>
<a name="ln1061">            break;</a>
<a name="ln1062">        }</a>
<a name="ln1063"> </a>
<a name="ln1064">        switch (eb_id) {</a>
<a name="ln1065">          case EF_PKVMS:</a>
<a name="ln1066">            /* The PKVMS e.f. raw data part consists of:</a>
<a name="ln1067">             * a) 4 bytes CRC checksum</a>
<a name="ln1068">             * b) list of uncompressed variable-length data items</a>
<a name="ln1069">             * Each data item is introduced by a fixed header</a>
<a name="ln1070">             *  - 2 bytes data type ID</a>
<a name="ln1071">             *  - 2 bytes &lt;size&gt; of data</a>
<a name="ln1072">             *  - &lt;size&gt; bytes of actual attribute data</a>
<a name="ln1073">             */</a>
<a name="ln1074"> </a>
<a name="ln1075">            /* get pointer to start of data and its total length */</a>
<a name="ln1076">            eb_data = ef_buf+(EB_HEADSIZE+4);</a>
<a name="ln1077">            eb_datlen = eb_len-4;</a>
<a name="ln1078"> </a>
<a name="ln1079">            /* test the CRC checksum */</a>
<a name="ln1080">            if (makelong(ef_buf+EB_HEADSIZE) !=</a>
<a name="ln1081">                crc32(CRCVAL_INITIAL, eb_data, (extent)eb_datlen))</a>
<a name="ln1082">            {</a>
<a name="ln1083">                Info(slide, 1, ((char *)slide,</a>
<a name="ln1084">                  &quot;[Warning: CRC error, discarding PKWARE extra field]\n&quot;));</a>
<a name="ln1085">                /* skip over the data analysis code */</a>
<a name="ln1086">                break;</a>
<a name="ln1087">            }</a>
<a name="ln1088"> </a>
<a name="ln1089">            /* scan through the attribute data items */</a>
<a name="ln1090">            while (eb_datlen &gt; 4)</a>
<a name="ln1091">            {</a>
<a name="ln1092">                unsigned fldsize = makeword(&amp;eb_data[VMSPK_ITEMLEN]);</a>
<a name="ln1093"> </a>
<a name="ln1094">                /* check the item type word */</a>
<a name="ln1095">                switch (makeword(&amp;eb_data[VMSPK_ITEMID])) {</a>
<a name="ln1096">                  case VMSATR_C_RECATTR:</a>
<a name="ln1097">                    /* we have found the (currently only) interesting</a>
<a name="ln1098">                     * data item */</a>
<a name="ln1099">                    if (fldsize &gt;= 1) {</a>
<a name="ln1100">                        vms_rectype = eb_data[VMSPK_ITEMHEADSZ] &amp; 15;</a>
<a name="ln1101">                        vms_fileorg = eb_data[VMSPK_ITEMHEADSZ] &gt;&gt; 4;</a>
<a name="ln1102">                    }</a>
<a name="ln1103">                    break;</a>
<a name="ln1104">                  default:</a>
<a name="ln1105">                    break;</a>
<a name="ln1106">                }</a>
<a name="ln1107">                /* skip to next data item */</a>
<a name="ln1108">                eb_datlen -= fldsize + VMSPK_ITEMHEADSZ;</a>
<a name="ln1109">                eb_data += fldsize + VMSPK_ITEMHEADSZ;</a>
<a name="ln1110">            }</a>
<a name="ln1111">            break;</a>
<a name="ln1112"> </a>
<a name="ln1113">          case EF_IZVMS:</a>
<a name="ln1114">            if (makelong(ef_buf+EB_HEADSIZE) == VMS_FABSIG) {</a>
<a name="ln1115">                if ((eb_data = extract_izvms_block(__G__</a>
<a name="ln1116">                                                   ef_buf+EB_HEADSIZE, eb_len,</a>
<a name="ln1117">                                                   &amp;eb_datlen, NULL, 0))</a>
<a name="ln1118">                    != NULL)</a>
<a name="ln1119">                {</a>
<a name="ln1120">                    if (eb_datlen &gt;= VMSFAB_B_RFM+1) {</a>
<a name="ln1121">                        vms_rectype = eb_data[VMSFAB_B_RFM] &amp; 15;</a>
<a name="ln1122">                        vms_fileorg = eb_data[VMSFAB_B_ORG] &gt;&gt; 4;</a>
<a name="ln1123">                    }</a>
<a name="ln1124">                    free(eb_data);</a>
<a name="ln1125">                }</a>
<a name="ln1126">            }</a>
<a name="ln1127">            break;</a>
<a name="ln1128"> </a>
<a name="ln1129">          default:</a>
<a name="ln1130">            break;</a>
<a name="ln1131">        }</a>
<a name="ln1132"> </a>
<a name="ln1133">        /* Skip this extra field block */</a>
<a name="ln1134">        ef_buf += (eb_len + EB_HEADSIZE);</a>
<a name="ln1135">        ef_len -= (eb_len + EB_HEADSIZE);</a>
<a name="ln1136">    }</a>
<a name="ln1137"> </a>
<a name="ln1138">    return (vms_rectype == VMSREC_C_VAR);</a>
<a name="ln1139"> </a>
<a name="ln1140">} /* end function is_vms_varlen_txtfile() */</a>
<a name="ln1141"> </a>
<a name="ln1142">#endif /* VMS_TEXT_CONV */</a>
<a name="ln1143"> </a>
<a name="ln1144"> </a>
<a name="ln1145"> </a>
<a name="ln1146"> </a>
<a name="ln1147">/*************************/</a>
<a name="ln1148">/* Function disk_error() */</a>
<a name="ln1149">/*************************/</a>
<a name="ln1150"> </a>
<a name="ln1151">static int disk_error(__G)</a>
<a name="ln1152">    __GDEF</a>
<a name="ln1153">{</a>
<a name="ln1154">    /* OK to use slide[] here because this file is finished regardless */</a>
<a name="ln1155">    Info(slide, 0x4a1, ((char *)slide, LoadFarString(DiskFullQuery),</a>
<a name="ln1156">      FnFilter1(G.filename)));</a>
<a name="ln1157"> </a>
<a name="ln1158">#ifndef WINDLL</a>
<a name="ln1159">    fgets(G.answerbuf, 9, stdin);</a>
<a name="ln1160">    if (*G.answerbuf == 'y')   /* stop writing to this file */</a>
<a name="ln1161">        G.disk_full = 1;       /*  (outfile bad?), but new OK */</a>
<a name="ln1162">    else</a>
<a name="ln1163">#endif</a>
<a name="ln1164">        G.disk_full = 2;       /* no:  exit program */</a>
<a name="ln1165"> </a>
<a name="ln1166">    return PK_DISK;</a>
<a name="ln1167"> </a>
<a name="ln1168">} /* end function disk_error() */</a>
<a name="ln1169"> </a>
<a name="ln1170">#endif /* !VMS */</a>
<a name="ln1171"> </a>
<a name="ln1172"> </a>
<a name="ln1173"> </a>
<a name="ln1174"> </a>
<a name="ln1175"> </a>
<a name="ln1176">/*****************************/</a>
<a name="ln1177">/* Function UzpMessagePrnt() */</a>
<a name="ln1178">/*****************************/</a>
<a name="ln1179"> </a>
<a name="ln1180">int UZ_EXP UzpMessagePrnt(pG, buf, size, flag)</a>
<a name="ln1181">    zvoid *pG;   /* globals struct:  always passed */</a>
<a name="ln1182">    uch *buf;    /* preformatted string to be printed */</a>
<a name="ln1183">    ulg size;    /* length of string (may include nulls) */</a>
<a name="ln1184">    int flag;    /* flag bits */</a>
<a name="ln1185">{</a>
<a name="ln1186">    /* IMPORTANT NOTE:</a>
<a name="ln1187">     *    The name of the first parameter of UzpMessagePrnt(), which passes</a>
<a name="ln1188">     *    the &quot;Uz_Globs&quot; address, &gt;&gt;&gt; MUST &lt;&lt;&lt; be identical to the string</a>
<a name="ln1189">     *    expansion of the __G__ macro in the REENTRANT case (see globals.h).</a>
<a name="ln1190">     *    This name identity is mandatory for the LoadFarString() macro</a>
<a name="ln1191">     *    (in the SMALL_MEM case) !!!</a>
<a name="ln1192">     */</a>
<a name="ln1193">    int error;</a>
<a name="ln1194">    uch *q=buf, *endbuf=buf+(unsigned)size;</a>
<a name="ln1195">#ifdef MORE</a>
<a name="ln1196">    uch *p=buf;</a>
<a name="ln1197">#if (defined(SCREENWIDTH) &amp;&amp; defined(SCREENLWRAP))</a>
<a name="ln1198">    int islinefeed = FALSE;</a>
<a name="ln1199">#endif</a>
<a name="ln1200">#endif</a>
<a name="ln1201">    FILE *outfp;</a>
<a name="ln1202"> </a>
<a name="ln1203"> </a>
<a name="ln1204">/*---------------------------------------------------------------------------</a>
<a name="ln1205">    These tests are here to allow fine-tuning of UnZip's output messages,</a>
<a name="ln1206">    but none of them will do anything without setting the appropriate bit</a>
<a name="ln1207">    in the flag argument of every Info() statement which is to be turned</a>
<a name="ln1208">    *off*.  That is, all messages are currently turned on for all ports.</a>
<a name="ln1209">    To turn off *all* messages, use the UzpMessageNull() function instead</a>
<a name="ln1210">    of this one.</a>
<a name="ln1211">  ---------------------------------------------------------------------------*/</a>
<a name="ln1212"> </a>
<a name="ln1213">#if (defined(OS2) &amp;&amp; defined(DLL))</a>
<a name="ln1214">    if (MSG_NO_DLL2(flag))  /* if OS/2 DLL bit is set, do NOT print this msg */</a>
<a name="ln1215">        return 0;</a>
<a name="ln1216">#endif</a>
<a name="ln1217">#ifdef WINDLL</a>
<a name="ln1218">    if (MSG_NO_WDLL(flag))</a>
<a name="ln1219">        return 0;</a>
<a name="ln1220">#endif</a>
<a name="ln1221">#ifdef WINDLL</a>
<a name="ln1222">    if (MSG_NO_WGUI(flag))</a>
<a name="ln1223">        return 0;</a>
<a name="ln1224">#endif</a>
<a name="ln1225">/*</a>
<a name="ln1226">#ifdef ACORN_GUI</a>
<a name="ln1227">    if (MSG_NO_AGUI(flag))</a>
<a name="ln1228">        return 0;</a>
<a name="ln1229">#endif</a>
<a name="ln1230"> */</a>
<a name="ln1231">#ifdef DLL                 /* don't display message if data is redirected */</a>
<a name="ln1232">    if (((Uz_Globs *)pG)-&gt;redirect_data &amp;&amp;</a>
<a name="ln1233">        !((Uz_Globs *)pG)-&gt;redirect_text)</a>
<a name="ln1234">        return 0;</a>
<a name="ln1235">#endif</a>
<a name="ln1236"> </a>
<a name="ln1237">    if (MSG_STDERR(flag) &amp;&amp; !((Uz_Globs *)pG)-&gt;UzO.tflag)</a>
<a name="ln1238">        outfp = (FILE *)stderr;</a>
<a name="ln1239">    else</a>
<a name="ln1240">        outfp = (FILE *)stdout;</a>
<a name="ln1241"> </a>
<a name="ln1242">#ifdef QUERY_TRNEWLN</a>
<a name="ln1243">    /* some systems require termination of query prompts with '\n' to force</a>
<a name="ln1244">     * immediate display */</a>
<a name="ln1245">    if (MSG_MNEWLN(flag)) {   /* assumes writable buffer (e.g., slide[]) */</a>
<a name="ln1246">        *endbuf++ = '\n';     /*  with room for one more char at end of buf */</a>
<a name="ln1247">        ++size;               /*  (safe assumption:  only used for four */</a>
<a name="ln1248">    }                         /*  short queries in extract.c and fileio.c) */</a>
<a name="ln1249">#endif</a>
<a name="ln1250"> </a>
<a name="ln1251">    if (MSG_TNEWLN(flag)) {   /* again assumes writable buffer:  fragile... */</a>
<a name="ln1252">        if ((!size &amp;&amp; !((Uz_Globs *)pG)-&gt;sol) ||</a>
<a name="ln1253">            (size &amp;&amp; (endbuf[-1] != '\n')))</a>
<a name="ln1254">        {</a>
<a name="ln1255">            *endbuf++ = '\n';</a>
<a name="ln1256">            ++size;</a>
<a name="ln1257">        }</a>
<a name="ln1258">    }</a>
<a name="ln1259"> </a>
<a name="ln1260">#ifdef MORE</a>
<a name="ln1261"># ifdef SCREENSIZE</a>
<a name="ln1262">    /* room for --More-- and one line of overlap: */</a>
<a name="ln1263">#  if (defined(SCREENWIDTH) &amp;&amp; defined(SCREENLWRAP))</a>
<a name="ln1264">    SCREENSIZE(&amp;((Uz_Globs *)pG)-&gt;height, &amp;((Uz_Globs *)pG)-&gt;width);</a>
<a name="ln1265">#  else</a>
<a name="ln1266">    SCREENSIZE(&amp;((Uz_Globs *)pG)-&gt;height, (int *)NULL);</a>
<a name="ln1267">#  endif</a>
<a name="ln1268">    ((Uz_Globs *)pG)-&gt;height -= 2;</a>
<a name="ln1269"># else</a>
<a name="ln1270">    /* room for --More-- and one line of overlap: */</a>
<a name="ln1271">    ((Uz_Globs *)pG)-&gt;height = SCREENLINES - 2;</a>
<a name="ln1272">#  if (defined(SCREENWIDTH) &amp;&amp; defined(SCREENLWRAP))</a>
<a name="ln1273">    ((Uz_Globs *)pG)-&gt;width = SCREENWIDTH;</a>
<a name="ln1274">#  endif</a>
<a name="ln1275"># endif</a>
<a name="ln1276">#endif /* MORE */</a>
<a name="ln1277"> </a>
<a name="ln1278">    if (MSG_LNEWLN(flag) &amp;&amp; !((Uz_Globs *)pG)-&gt;sol) {</a>
<a name="ln1279">        /* not at start of line:  want newline */</a>
<a name="ln1280">#ifdef OS2DLL</a>
<a name="ln1281">        if (!((Uz_Globs *)pG)-&gt;redirect_text) {</a>
<a name="ln1282">#endif</a>
<a name="ln1283">            putc('\n', outfp);</a>
<a name="ln1284">            fflush(outfp);</a>
<a name="ln1285">#ifdef MORE</a>
<a name="ln1286">            if (((Uz_Globs *)pG)-&gt;M_flag)</a>
<a name="ln1287">            {</a>
<a name="ln1288">#if (defined(SCREENWIDTH) &amp;&amp; defined(SCREENLWRAP))</a>
<a name="ln1289">                ((Uz_Globs *)pG)-&gt;chars = 0;</a>
<a name="ln1290">#endif</a>
<a name="ln1291">                ++((Uz_Globs *)pG)-&gt;numlines;</a>
<a name="ln1292">                ++((Uz_Globs *)pG)-&gt;lines;</a>
<a name="ln1293">                if (((Uz_Globs *)pG)-&gt;lines &gt;= ((Uz_Globs *)pG)-&gt;height)</a>
<a name="ln1294">                    (*((Uz_Globs *)pG)-&gt;mpause)((zvoid *)pG,</a>
<a name="ln1295">                      LoadFarString(MorePrompt), 1);</a>
<a name="ln1296">            }</a>
<a name="ln1297">#endif /* MORE */</a>
<a name="ln1298">            if (MSG_STDERR(flag) &amp;&amp; ((Uz_Globs *)pG)-&gt;UzO.tflag &amp;&amp;</a>
<a name="ln1299">                !isatty(1) &amp;&amp; isatty(2))</a>
<a name="ln1300">            {</a>
<a name="ln1301">                /* error output from testing redirected:  also send to stderr */</a>
<a name="ln1302">                putc('\n', stderr);</a>
<a name="ln1303">                fflush(stderr);</a>
<a name="ln1304">            }</a>
<a name="ln1305">#ifdef OS2DLL</a>
<a name="ln1306">        } else</a>
<a name="ln1307">           REDIRECTC('\n');</a>
<a name="ln1308">#endif</a>
<a name="ln1309">        ((Uz_Globs *)pG)-&gt;sol = TRUE;</a>
<a name="ln1310">    }</a>
<a name="ln1311"> </a>
<a name="ln1312">    /* put zipfile name, filename and/or error/warning keywords here */</a>
<a name="ln1313"> </a>
<a name="ln1314">#ifdef MORE</a>
<a name="ln1315">    if (((Uz_Globs *)pG)-&gt;M_flag</a>
<a name="ln1316">#ifdef OS2DLL</a>
<a name="ln1317">         &amp;&amp; !((Uz_Globs *)pG)-&gt;redirect_text</a>
<a name="ln1318">#endif</a>
<a name="ln1319">                                                 )</a>
<a name="ln1320">    {</a>
<a name="ln1321">        while (p &lt; endbuf) {</a>
<a name="ln1322">            if (*p == '\n') {</a>
<a name="ln1323">#if (defined(SCREENWIDTH) &amp;&amp; defined(SCREENLWRAP))</a>
<a name="ln1324">                islinefeed = TRUE;</a>
<a name="ln1325">            } else if (SCREENLWRAP) {</a>
<a name="ln1326">                if (*p == '\r') {</a>
<a name="ln1327">                    ((Uz_Globs *)pG)-&gt;chars = 0;</a>
<a name="ln1328">                } else {</a>
<a name="ln1329">#  ifdef TABSIZE</a>
<a name="ln1330">                    if (*p == '\t')</a>
<a name="ln1331">                        ((Uz_Globs *)pG)-&gt;chars +=</a>
<a name="ln1332">                            (TABSIZE - (((Uz_Globs *)pG)-&gt;chars % TABSIZE));</a>
<a name="ln1333">                    else</a>
<a name="ln1334">#  endif</a>
<a name="ln1335">                        ++((Uz_Globs *)pG)-&gt;chars;</a>
<a name="ln1336"> </a>
<a name="ln1337">                    if (((Uz_Globs *)pG)-&gt;chars &gt;= ((Uz_Globs *)pG)-&gt;width)</a>
<a name="ln1338">                        islinefeed = TRUE;</a>
<a name="ln1339">                }</a>
<a name="ln1340">            }</a>
<a name="ln1341">            if (islinefeed) {</a>
<a name="ln1342">                islinefeed = FALSE;</a>
<a name="ln1343">                ((Uz_Globs *)pG)-&gt;chars = 0;</a>
<a name="ln1344">#endif /* (SCREENWIDTH &amp;&amp; SCREEN_LWRAP) */</a>
<a name="ln1345">                ++((Uz_Globs *)pG)-&gt;numlines;</a>
<a name="ln1346">                ++((Uz_Globs *)pG)-&gt;lines;</a>
<a name="ln1347">                if (((Uz_Globs *)pG)-&gt;lines &gt;= ((Uz_Globs *)pG)-&gt;height)</a>
<a name="ln1348">                {</a>
<a name="ln1349">                    if ((error = WriteError(q, p-q+1, outfp)) != 0)</a>
<a name="ln1350">                        return error;</a>
<a name="ln1351">                    fflush(outfp);</a>
<a name="ln1352">                    ((Uz_Globs *)pG)-&gt;sol = TRUE;</a>
<a name="ln1353">                    q = p + 1;</a>
<a name="ln1354">                    (*((Uz_Globs *)pG)-&gt;mpause)((zvoid *)pG,</a>
<a name="ln1355">                      LoadFarString(MorePrompt), 1);</a>
<a name="ln1356">                }</a>
<a name="ln1357">            }</a>
<a name="ln1358">            INCSTR(p);</a>
<a name="ln1359">        } /* end while */</a>
<a name="ln1360">        size = (ulg)(p - q);   /* remaining text */</a>
<a name="ln1361">    }</a>
<a name="ln1362">#endif /* MORE */</a>
<a name="ln1363"> </a>
<a name="ln1364">    if (size) {</a>
<a name="ln1365">#ifdef OS2DLL</a>
<a name="ln1366">        if (!((Uz_Globs *)pG)-&gt;redirect_text) {</a>
<a name="ln1367">#endif</a>
<a name="ln1368">            if ((error = WriteError(q, size, outfp)) != 0)</a>
<a name="ln1369">                return error;</a>
<a name="ln1370">            fflush(outfp);</a>
<a name="ln1371">            if (MSG_STDERR(flag) &amp;&amp; ((Uz_Globs *)pG)-&gt;UzO.tflag &amp;&amp;</a>
<a name="ln1372">                !isatty(1) &amp;&amp; isatty(2))</a>
<a name="ln1373">            {</a>
<a name="ln1374">                /* error output from testing redirected:  also send to stderr */</a>
<a name="ln1375">                if ((error = WriteError(q, size, stderr)) != 0)</a>
<a name="ln1376">                    return error;</a>
<a name="ln1377">                fflush(stderr);</a>
<a name="ln1378">            }</a>
<a name="ln1379">#ifdef OS2DLL</a>
<a name="ln1380">        } else {                /* GRR:  this is ugly:  hide with macro */</a>
<a name="ln1381">            if ((error = REDIRECTPRINT(q, size)) != 0)</a>
<a name="ln1382">                return error;</a>
<a name="ln1383">        }</a>
<a name="ln1384">#endif /* OS2DLL */</a>
<a name="ln1385">        ((Uz_Globs *)pG)-&gt;sol = (endbuf[-1] == '\n');</a>
<a name="ln1386">    }</a>
<a name="ln1387">    return 0;</a>
<a name="ln1388"> </a>
<a name="ln1389">} /* end function UzpMessagePrnt() */</a>
<a name="ln1390"> </a>
<a name="ln1391"> </a>
<a name="ln1392"> </a>
<a name="ln1393"> </a>
<a name="ln1394"> </a>
<a name="ln1395">#ifdef DLL</a>
<a name="ln1396"> </a>
<a name="ln1397">/*****************************/</a>
<a name="ln1398">/* Function UzpMessageNull() */  /* convenience routine for no output at all */</a>
<a name="ln1399">/*****************************/</a>
<a name="ln1400"> </a>
<a name="ln1401">int UZ_EXP UzpMessageNull(pG, buf, size, flag)</a>
<a name="ln1402">    zvoid *pG;    /* globals struct:  always passed */</a>
<a name="ln1403">    uch *buf;     /* preformatted string to be printed */</a>
<a name="ln1404">    ulg size;     /* length of string (may include nulls) */</a>
<a name="ln1405">    int flag;     /* flag bits */</a>
<a name="ln1406">{</a>
<a name="ln1407">    return 0;</a>
<a name="ln1408"> </a>
<a name="ln1409">} /* end function UzpMessageNull() */</a>
<a name="ln1410"> </a>
<a name="ln1411">#endif /* DLL */</a>
<a name="ln1412"> </a>
<a name="ln1413"> </a>
<a name="ln1414"> </a>
<a name="ln1415"> </a>
<a name="ln1416"> </a>
<a name="ln1417">/***********************/</a>
<a name="ln1418">/* Function UzpInput() */   /* GRR:  this is a placeholder for now */</a>
<a name="ln1419">/***********************/</a>
<a name="ln1420"> </a>
<a name="ln1421">int UZ_EXP UzpInput(pG, buf, size, flag)</a>
<a name="ln1422">    zvoid *pG;    /* globals struct:  always passed */</a>
<a name="ln1423">    uch *buf;     /* preformatted string to be printed */</a>
<a name="ln1424">    int *size;    /* (address of) size of buf and of returned string */</a>
<a name="ln1425">    int flag;     /* flag bits (bit 0: no echo) */</a>
<a name="ln1426">{</a>
<a name="ln1427">    /* tell picky compilers to shut up about &quot;unused variable&quot; warnings */</a>
<a name="ln1428">    pG = pG; buf = buf; flag = flag;</a>
<a name="ln1429"> </a>
<a name="ln1430">    *size = 0;</a>
<a name="ln1431">    return 0;</a>
<a name="ln1432"> </a>
<a name="ln1433">} /* end function UzpInput() */</a>
<a name="ln1434"> </a>
<a name="ln1435"> </a>
<a name="ln1436"> </a>
<a name="ln1437"> </a>
<a name="ln1438"> </a>
<a name="ln1439">#if (!defined(WINDLL) &amp;&amp; !defined(MACOS))</a>
<a name="ln1440"> </a>
<a name="ln1441">/***************************/</a>
<a name="ln1442">/* Function UzpMorePause() */</a>
<a name="ln1443">/***************************/</a>
<a name="ln1444"> </a>
<a name="ln1445">void UZ_EXP UzpMorePause(pG, prompt, flag)</a>
<a name="ln1446">    zvoid *pG;            /* globals struct:  always passed */</a>
<a name="ln1447">    ZCONST char *prompt;  /* &quot;--More--&quot; prompt */</a>
<a name="ln1448">    int flag;             /* 0 = any char OK; 1 = accept only '\n', ' ', q */</a>
<a name="ln1449">{</a>
<a name="ln1450">    uch c;</a>
<a name="ln1451"> </a>
<a name="ln1452">/*---------------------------------------------------------------------------</a>
<a name="ln1453">    Print a prompt and wait for the user to press a key, then erase prompt</a>
<a name="ln1454">    if possible.</a>
<a name="ln1455">  ---------------------------------------------------------------------------*/</a>
<a name="ln1456"> </a>
<a name="ln1457">    if (!((Uz_Globs *)pG)-&gt;sol)</a>
<a name="ln1458">        fprintf(stderr, &quot;\n&quot;);</a>
<a name="ln1459">    /* numlines may or may not be used: */</a>
<a name="ln1460">    fprintf(stderr, prompt, ((Uz_Globs *)pG)-&gt;numlines);</a>
<a name="ln1461">    fflush(stderr);</a>
<a name="ln1462">    if (flag &amp; 1) {</a>
<a name="ln1463">        do {</a>
<a name="ln1464">            c = (uch)FGETCH(0);</a>
<a name="ln1465">        } while (</a>
<a name="ln1466">#ifdef THEOS</a>
<a name="ln1467">                 c != 17 &amp;&amp;     /* standard QUIT key */</a>
<a name="ln1468">#endif</a>
<a name="ln1469">                 c != '\r' &amp;&amp; c != '\n' &amp;&amp; c != ' ' &amp;&amp; c != 'q' &amp;&amp; c != 'Q');</a>
<a name="ln1470">    } else</a>
<a name="ln1471">        c = (uch)FGETCH(0);</a>
<a name="ln1472"> </a>
<a name="ln1473">    /* newline was not echoed, so cover up prompt line */</a>
<a name="ln1474">    fprintf(stderr, LoadFarString(HidePrompt));</a>
<a name="ln1475">    fflush(stderr);</a>
<a name="ln1476"> </a>
<a name="ln1477">    if (</a>
<a name="ln1478">#ifdef THEOS</a>
<a name="ln1479">        (c == 17) ||            /* standard QUIT key */</a>
<a name="ln1480">#endif</a>
<a name="ln1481">        (ToLower(c) == 'q')) {</a>
<a name="ln1482">        DESTROYGLOBALS();</a>
<a name="ln1483">        EXIT(PK_COOL);</a>
<a name="ln1484">    }</a>
<a name="ln1485"> </a>
<a name="ln1486">    ((Uz_Globs *)pG)-&gt;sol = TRUE;</a>
<a name="ln1487"> </a>
<a name="ln1488">#ifdef MORE</a>
<a name="ln1489">    /* space for another screen, enter for another line. */</a>
<a name="ln1490">    if ((flag &amp; 1) &amp;&amp; c == ' ')</a>
<a name="ln1491">        ((Uz_Globs *)pG)-&gt;lines = 0;</a>
<a name="ln1492">#endif /* MORE */</a>
<a name="ln1493"> </a>
<a name="ln1494">} /* end function UzpMorePause() */</a>
<a name="ln1495"> </a>
<a name="ln1496">#endif /* !WINDLL &amp;&amp; !MACOS */</a>
<a name="ln1497"> </a>
<a name="ln1498"> </a>
<a name="ln1499"> </a>
<a name="ln1500"> </a>
<a name="ln1501">#ifndef WINDLL</a>
<a name="ln1502"> </a>
<a name="ln1503">/**************************/</a>
<a name="ln1504">/* Function UzpPassword() */</a>
<a name="ln1505">/**************************/</a>
<a name="ln1506"> </a>
<a name="ln1507">int UZ_EXP UzpPassword (pG, rcnt, pwbuf, size, zfn, efn)</a>
<a name="ln1508">    zvoid *pG;         /* pointer to UnZip's internal global vars */</a>
<a name="ln1509">    int *rcnt;         /* retry counter */</a>
<a name="ln1510">    char *pwbuf;       /* buffer for password */</a>
<a name="ln1511">    int size;          /* size of password buffer */</a>
<a name="ln1512">    ZCONST char *zfn;  /* name of zip archive */</a>
<a name="ln1513">    ZCONST char *efn;  /* name of archive entry being processed */</a>
<a name="ln1514">{</a>
<a name="ln1515">#if CRYPT</a>
<a name="ln1516">    int r = IZ_PW_ENTERED;</a>
<a name="ln1517">    char *m;</a>
<a name="ln1518">    char *prompt;</a>
<a name="ln1519"> </a>
<a name="ln1520">#ifndef REENTRANT</a>
<a name="ln1521">    /* tell picky compilers to shut up about &quot;unused variable&quot; warnings */</a>
<a name="ln1522">    pG = pG;</a>
<a name="ln1523">#endif</a>
<a name="ln1524"> </a>
<a name="ln1525">    if (*rcnt == 0) {           /* First call for current entry */</a>
<a name="ln1526">        *rcnt = 2;</a>
<a name="ln1527">        if ((prompt = (char *)malloc(2*FILNAMSIZ + 15)) != (char *)NULL) {</a>
<a name="ln1528">            sprintf(prompt, LoadFarString(PasswPrompt),</a>
<a name="ln1529">                    FnFilter1(zfn), FnFilter2(efn));</a>
<a name="ln1530">            m = prompt;</a>
<a name="ln1531">        } else</a>
<a name="ln1532">            m = (char *)LoadFarString(PasswPrompt2);</a>
<a name="ln1533">    } else {                    /* Retry call, previous password was wrong */</a>
<a name="ln1534">        (*rcnt)--;</a>
<a name="ln1535">        prompt = NULL;</a>
<a name="ln1536">        m = (char *)LoadFarString(PasswRetry);</a>
<a name="ln1537">    }</a>
<a name="ln1538"> </a>
<a name="ln1539">    m = getp(__G__ m, pwbuf, size);</a>
<a name="ln1540">    if (prompt != (char *)NULL) {</a>
<a name="ln1541">        free(prompt);</a>
<a name="ln1542">    }</a>
<a name="ln1543">    if (m == (char *)NULL) {</a>
<a name="ln1544">        r = IZ_PW_ERROR;</a>
<a name="ln1545">    }</a>
<a name="ln1546">    else if (*pwbuf == '\0') {</a>
<a name="ln1547">        r = IZ_PW_CANCELALL;</a>
<a name="ln1548">    }</a>
<a name="ln1549">    return r;</a>
<a name="ln1550"> </a>
<a name="ln1551">#else /* !CRYPT */</a>
<a name="ln1552">    /* tell picky compilers to shut up about &quot;unused variable&quot; warnings */</a>
<a name="ln1553">    pG = pG; rcnt = rcnt; pwbuf = pwbuf; size = size; zfn = zfn; efn = efn;</a>
<a name="ln1554"> </a>
<a name="ln1555">    return IZ_PW_ERROR;  /* internal error; function should never get called */</a>
<a name="ln1556">#endif /* ?CRYPT */</a>
<a name="ln1557"> </a>
<a name="ln1558">} /* end function UzpPassword() */</a>
<a name="ln1559"> </a>
<a name="ln1560"> </a>
<a name="ln1561"> </a>
<a name="ln1562"> </a>
<a name="ln1563"> </a>
<a name="ln1564">/**********************/</a>
<a name="ln1565">/* Function handler() */</a>
<a name="ln1566">/**********************/</a>
<a name="ln1567"> </a>
<a name="ln1568">void handler(signal)   /* upon interrupt, turn on echo and exit cleanly */</a>
<a name="ln1569">    int signal;</a>
<a name="ln1570">{</a>
<a name="ln1571">    GETGLOBALS();</a>
<a name="ln1572"> </a>
<a name="ln1573">#if !(defined(SIGBUS) || defined(SIGSEGV))      /* add a newline if not at */</a>
<a name="ln1574">    (*G.message)((zvoid *)&amp;G, slide, 0L, 0x41); /*  start of line (to stderr; */</a>
<a name="ln1575">#endif                                          /*  slide[] should be safe) */</a>
<a name="ln1576"> </a>
<a name="ln1577">    echon();</a>
<a name="ln1578"> </a>
<a name="ln1579">#ifdef SIGBUS</a>
<a name="ln1580">    if (signal == SIGBUS) {</a>
<a name="ln1581">        Info(slide, 0x421, ((char *)slide, LoadFarString(ZipfileCorrupt),</a>
<a name="ln1582">          &quot;bus error&quot;));</a>
<a name="ln1583">        DESTROYGLOBALS();</a>
<a name="ln1584">        EXIT(PK_BADERR);</a>
<a name="ln1585">    }</a>
<a name="ln1586">#endif /* SIGBUS */</a>
<a name="ln1587"> </a>
<a name="ln1588">#ifdef SIGSEGV</a>
<a name="ln1589">    if (signal == SIGSEGV) {</a>
<a name="ln1590">        Info(slide, 0x421, ((char *)slide, LoadFarString(ZipfileCorrupt),</a>
<a name="ln1591">          &quot;segmentation violation&quot;));</a>
<a name="ln1592">        DESTROYGLOBALS();</a>
<a name="ln1593">        EXIT(PK_BADERR);</a>
<a name="ln1594">    }</a>
<a name="ln1595">#endif /* SIGSEGV */</a>
<a name="ln1596"> </a>
<a name="ln1597">    /* probably ctrl-C */</a>
<a name="ln1598">    DESTROYGLOBALS();</a>
<a name="ln1599">#if defined(AMIGA) &amp;&amp; defined(__SASC)</a>
<a name="ln1600">    _abort();</a>
<a name="ln1601">#endif</a>
<a name="ln1602">    EXIT(IZ_CTRLC);       /* was EXIT(0), then EXIT(PK_ERR) */</a>
<a name="ln1603">}</a>
<a name="ln1604"> </a>
<a name="ln1605">#endif /* !WINDLL */</a>
<a name="ln1606"> </a>
<a name="ln1607"> </a>
<a name="ln1608"> </a>
<a name="ln1609"> </a>
<a name="ln1610">#if (!defined(VMS) &amp;&amp; !defined(CMS_MVS))</a>
<a name="ln1611">#if (!defined(OS2) || defined(TIMESTAMP))</a>
<a name="ln1612"> </a>
<a name="ln1613">#if (!defined(HAVE_MKTIME) || defined(WIN32))</a>
<a name="ln1614">/* also used in amiga/filedate.c and win32/win32.c */</a>
<a name="ln1615">ZCONST ush ydays[] =</a>
<a name="ln1616">    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 };</a>
<a name="ln1617">#endif</a>
<a name="ln1618"> </a>
<a name="ln1619">/*******************************/</a>
<a name="ln1620">/* Function dos_to_unix_time() */ /* used for freshening/updating/timestamps */</a>
<a name="ln1621">/*******************************/</a>
<a name="ln1622"> </a>
<a name="ln1623">time_t dos_to_unix_time(dosdatetime)</a>
<a name="ln1624">    ulg dosdatetime;</a>
<a name="ln1625">{</a>
<a name="ln1626">    time_t m_time;</a>
<a name="ln1627"> </a>
<a name="ln1628">#ifdef HAVE_MKTIME</a>
<a name="ln1629"> </a>
<a name="ln1630">    ZCONST time_t now = time(NULL);</a>
<a name="ln1631">    struct tm *tm;</a>
<a name="ln1632">#   define YRBASE  1900</a>
<a name="ln1633"> </a>
<a name="ln1634">    tm = localtime(&amp;now);</a>
<a name="ln1635">    tm-&gt;tm_isdst = -1;          /* let mktime determine if DST is in effect */</a>
<a name="ln1636"> </a>
<a name="ln1637">    /* dissect date */</a>
<a name="ln1638">    tm-&gt;tm_year = ((int)(dosdatetime &gt;&gt; 25) &amp; 0x7f) + (1980 - YRBASE);</a>
<a name="ln1639">    tm-&gt;tm_mon  = ((int)(dosdatetime &gt;&gt; 21) &amp; 0x0f) - 1;</a>
<a name="ln1640">    tm-&gt;tm_mday = ((int)(dosdatetime &gt;&gt; 16) &amp; 0x1f);</a>
<a name="ln1641"> </a>
<a name="ln1642">    /* dissect time */</a>
<a name="ln1643">    tm-&gt;tm_hour = (int)((unsigned)dosdatetime &gt;&gt; 11) &amp; 0x1f;</a>
<a name="ln1644">    tm-&gt;tm_min  = (int)((unsigned)dosdatetime &gt;&gt; 5) &amp; 0x3f;</a>
<a name="ln1645">    tm-&gt;tm_sec  = (int)((unsigned)dosdatetime &lt;&lt; 1) &amp; 0x3e;</a>
<a name="ln1646"> </a>
<a name="ln1647">    m_time = mktime(tm);</a>
<a name="ln1648">    NATIVE_TO_TIMET(m_time)     /* NOP unless MSC 7.0 or Macintosh */</a>
<a name="ln1649">    TTrace((stderr, &quot;  final m_time  =       %lu\n&quot;, (ulg)m_time));</a>
<a name="ln1650"> </a>
<a name="ln1651">#else /* !HAVE_MKTIME */</a>
<a name="ln1652"> </a>
<a name="ln1653">    int yr, mo, dy, hh, mm, ss;</a>
<a name="ln1654">#ifdef TOPS20</a>
<a name="ln1655">#   define YRBASE  1900</a>
<a name="ln1656">    struct tmx *tmx;</a>
<a name="ln1657">    char temp[20];</a>
<a name="ln1658">#else /* !TOPS20 */</a>
<a name="ln1659">#   define YRBASE  1970</a>
<a name="ln1660">    int leap;</a>
<a name="ln1661">    unsigned days;</a>
<a name="ln1662">    struct tm *tm;</a>
<a name="ln1663">#if (!defined(MACOS) &amp;&amp; !defined(RISCOS) &amp;&amp; !defined(QDOS) &amp;&amp; !defined(TANDEM))</a>
<a name="ln1664">#ifdef WIN32</a>
<a name="ln1665">    TIME_ZONE_INFORMATION tzinfo;</a>
<a name="ln1666">    DWORD res;</a>
<a name="ln1667">#else /* ! WIN32 */</a>
<a name="ln1668">#ifndef BSD4_4   /* GRR:  change to !defined(MODERN) ? */</a>
<a name="ln1669">#if (defined(BSD) || defined(MTS) || defined(__GO32__))</a>
<a name="ln1670">    struct timeb tbp;</a>
<a name="ln1671">#else /* !(BSD || MTS || __GO32__) */</a>
<a name="ln1672">#ifdef DECLARE_TIMEZONE</a>
<a name="ln1673">    extern time_t timezone;</a>
<a name="ln1674">#endif</a>
<a name="ln1675">#endif /* ?(BSD || MTS || __GO32__) */</a>
<a name="ln1676">#endif /* !BSD4_4 */</a>
<a name="ln1677">#endif /* ?WIN32 */</a>
<a name="ln1678">#endif /* !MACOS &amp;&amp; !RISCOS &amp;&amp; !QDOS &amp;&amp; !TANDEM */</a>
<a name="ln1679">#endif /* ?TOPS20 */</a>
<a name="ln1680"> </a>
<a name="ln1681"> </a>
<a name="ln1682">    /* dissect date */</a>
<a name="ln1683">    yr = ((int)(dosdatetime &gt;&gt; 25) &amp; 0x7f) + (1980 - YRBASE);</a>
<a name="ln1684">    mo = ((int)(dosdatetime &gt;&gt; 21) &amp; 0x0f) - 1;</a>
<a name="ln1685">    dy = ((int)(dosdatetime &gt;&gt; 16) &amp; 0x1f) - 1;</a>
<a name="ln1686"> </a>
<a name="ln1687">    /* dissect time */</a>
<a name="ln1688">    hh = (int)((unsigned)dosdatetime &gt;&gt; 11) &amp; 0x1f;</a>
<a name="ln1689">    mm = (int)((unsigned)dosdatetime &gt;&gt; 5) &amp; 0x3f;</a>
<a name="ln1690">    ss = (int)((unsigned)dosdatetime &amp; 0x1f) * 2;</a>
<a name="ln1691"> </a>
<a name="ln1692">#ifdef TOPS20</a>
<a name="ln1693">    tmx = (struct tmx *)malloc(sizeof(struct tmx));</a>
<a name="ln1694">    sprintf (temp, &quot;%02d/%02d/%02d %02d:%02d:%02d&quot;, mo+1, dy+1, yr, hh, mm, ss);</a>
<a name="ln1695">    time_parse(temp, tmx, (char *)0);</a>
<a name="ln1696">    m_time = time_make(tmx);</a>
<a name="ln1697">    free(tmx);</a>
<a name="ln1698"> </a>
<a name="ln1699">#else /* !TOPS20 */</a>
<a name="ln1700"> </a>
<a name="ln1701">/*---------------------------------------------------------------------------</a>
<a name="ln1702">    Calculate the number of seconds since the epoch, usually 1 January 1970.</a>
<a name="ln1703">  ---------------------------------------------------------------------------*/</a>
<a name="ln1704"> </a>
<a name="ln1705">    /* leap = # of leap yrs from YRBASE up to but not including current year */</a>
<a name="ln1706">    leap = ((yr + YRBASE - 1) / 4);   /* leap year base factor */</a>
<a name="ln1707"> </a>
<a name="ln1708">    /* calculate days from BASE to this year and add expired days this year */</a>
<a name="ln1709">    days = (yr * 365) + (leap - 492) + ydays[mo];</a>
<a name="ln1710"> </a>
<a name="ln1711">    /* if year is a leap year and month is after February, add another day */</a>
<a name="ln1712">    if ((mo &gt; 1) &amp;&amp; ((yr+YRBASE)%4 == 0) &amp;&amp; ((yr+YRBASE) != 2100))</a>
<a name="ln1713">        ++days;                 /* OK through 2199 */</a>
<a name="ln1714"> </a>
<a name="ln1715">    /* convert date &amp; time to seconds relative to 00:00:00, 01/01/YRBASE */</a>
<a name="ln1716">    m_time = (time_t)((unsigned long)(days + dy) * 86400L +</a>
<a name="ln1717">                      (unsigned long)hh * 3600L +</a>
<a name="ln1718">                      (unsigned long)(mm * 60 + ss));</a>
<a name="ln1719">      /* - 1;   MS-DOS times always rounded up to nearest even second */</a>
<a name="ln1720">    TTrace((stderr, &quot;dos_to_unix_time:\n&quot;));</a>
<a name="ln1721">    TTrace((stderr, &quot;  m_time before timezone = %lu\n&quot;, (ulg)m_time));</a>
<a name="ln1722"> </a>
<a name="ln1723">/*---------------------------------------------------------------------------</a>
<a name="ln1724">    Adjust for local standard timezone offset.</a>
<a name="ln1725">  ---------------------------------------------------------------------------*/</a>
<a name="ln1726"> </a>
<a name="ln1727">#if (!defined(MACOS) &amp;&amp; !defined(RISCOS) &amp;&amp; !defined(QDOS) &amp;&amp; !defined(TANDEM))</a>
<a name="ln1728">#ifdef WIN32</a>
<a name="ln1729">    /* account for timezone differences */</a>
<a name="ln1730">    res = GetTimeZoneInformation(&amp;tzinfo);</a>
<a name="ln1731">    if (res != TIME_ZONE_ID_INVALID)</a>
<a name="ln1732">    {</a>
<a name="ln1733">    m_time += 60*(tzinfo.Bias);</a>
<a name="ln1734">#else /* !WIN32 */</a>
<a name="ln1735">#if (defined(BSD) || defined(MTS) || defined(__GO32__))</a>
<a name="ln1736">#ifdef BSD4_4</a>
<a name="ln1737">    if ( (dosdatetime &gt;= DOSTIME_2038_01_18) &amp;&amp;</a>
<a name="ln1738">         (m_time &lt; (time_t)0x70000000L) )</a>
<a name="ln1739">        m_time = U_TIME_T_MAX;  /* saturate in case of (unsigned) overflow */</a>
<a name="ln1740">    if (m_time &lt; (time_t)0L)    /* a converted DOS time cannot be negative */</a>
<a name="ln1741">        m_time = S_TIME_T_MAX;  /*  -&gt; saturate at max signed time_t value */</a>
<a name="ln1742">    if ((tm = localtime(&amp;m_time)) != (struct tm *)NULL)</a>
<a name="ln1743">        m_time -= tm-&gt;tm_gmtoff;                /* sec. EAST of GMT: subtr. */</a>
<a name="ln1744">#else /* !(BSD4_4 */</a>
<a name="ln1745">    ftime(&amp;tbp);                                /* get `timezone' */</a>
<a name="ln1746">    m_time += tbp.timezone * 60L;               /* seconds WEST of GMT:  add */</a>
<a name="ln1747">#endif /* ?(BSD4_4 || __EMX__) */</a>
<a name="ln1748">#else /* !(BSD || MTS || __GO32__) */</a>
<a name="ln1749">    /* tzset was already called at start of process_zipfiles() */</a>
<a name="ln1750">    /* tzset(); */              /* set `timezone' variable */</a>
<a name="ln1751">#if (!defined(__BEOS__) &amp;&amp; !defined(__HAIKU__))                /* BeOS DR8 has no timezones... */</a>
<a name="ln1752">    m_time += timezone;         /* seconds WEST of GMT:  add */</a>
<a name="ln1753">#endif</a>
<a name="ln1754">#endif /* ?(BSD || MTS || __GO32__) */</a>
<a name="ln1755">#endif /* ?WIN32 */</a>
<a name="ln1756">    TTrace((stderr, &quot;  m_time after timezone =  %lu\n&quot;, (ulg)m_time));</a>
<a name="ln1757"> </a>
<a name="ln1758">/*---------------------------------------------------------------------------</a>
<a name="ln1759">    Adjust for local daylight savings (summer) time.</a>
<a name="ln1760">  ---------------------------------------------------------------------------*/</a>
<a name="ln1761"> </a>
<a name="ln1762">#ifndef BSD4_4  /* (DST already added to tm_gmtoff, so skip tm_isdst) */</a>
<a name="ln1763">    if ( (dosdatetime &gt;= DOSTIME_2038_01_18) &amp;&amp;</a>
<a name="ln1764">         (m_time &lt; (time_t)0x70000000L) )</a>
<a name="ln1765">        m_time = U_TIME_T_MAX;  /* saturate in case of (unsigned) overflow */</a>
<a name="ln1766">    if (m_time &lt; (time_t)0L)    /* a converted DOS time cannot be negative */</a>
<a name="ln1767">        m_time = S_TIME_T_MAX;  /*  -&gt; saturate at max signed time_t value */</a>
<a name="ln1768">    TIMET_TO_NATIVE(m_time)     /* NOP unless MSC 7.0 or Macintosh */</a>
<a name="ln1769">    if (((tm = localtime((time_t *)&amp;m_time)) != NULL) &amp;&amp; tm-&gt;tm_isdst)</a>
<a name="ln1770">#ifdef WIN32</a>
<a name="ln1771">        m_time += 60L * tzinfo.DaylightBias;    /* adjust with DST bias */</a>
<a name="ln1772">    else</a>
<a name="ln1773">        m_time += 60L * tzinfo.StandardBias;    /* add StdBias (normally 0) */</a>
<a name="ln1774">#else</a>
<a name="ln1775">        m_time -= 60L * 60L;    /* adjust for daylight savings time */</a>
<a name="ln1776">#endif</a>
<a name="ln1777">    NATIVE_TO_TIMET(m_time)     /* NOP unless MSC 7.0 or Macintosh */</a>
<a name="ln1778">    TTrace((stderr, &quot;  m_time after DST =       %lu\n&quot;, (ulg)m_time));</a>
<a name="ln1779">#endif /* !BSD4_4 */</a>
<a name="ln1780">#ifdef WIN32</a>
<a name="ln1781">    }</a>
<a name="ln1782">#endif</a>
<a name="ln1783">#endif /* !MACOS &amp;&amp; !RISCOS &amp;&amp; !QDOS &amp;&amp; !TANDEM */</a>
<a name="ln1784">#endif /* ?TOPS20 */</a>
<a name="ln1785"> </a>
<a name="ln1786">#endif /* ?HAVE_MKTIME */</a>
<a name="ln1787"> </a>
<a name="ln1788">    if ( (dosdatetime &gt;= DOSTIME_2038_01_18) &amp;&amp;</a>
<a name="ln1789">         (m_time &lt; (time_t)0x70000000L) )</a>
<a name="ln1790">        m_time = U_TIME_T_MAX;  /* saturate in case of (unsigned) overflow */</a>
<a name="ln1791">    if (m_time &lt; (time_t)0L)    /* a converted DOS time cannot be negative */</a>
<a name="ln1792">        m_time = S_TIME_T_MAX;  /*  -&gt; saturate at max signed time_t value */</a>
<a name="ln1793"> </a>
<a name="ln1794">    return m_time;</a>
<a name="ln1795"> </a>
<a name="ln1796">} /* end function dos_to_unix_time() */</a>
<a name="ln1797"> </a>
<a name="ln1798">#endif /* !OS2 || TIMESTAMP */</a>
<a name="ln1799">#endif /* !VMS &amp;&amp; !CMS_MVS */</a>
<a name="ln1800"> </a>
<a name="ln1801"> </a>
<a name="ln1802"> </a>
<a name="ln1803">#if (!defined(VMS) &amp;&amp; !defined(OS2) &amp;&amp; !defined(CMS_MVS))</a>
<a name="ln1804"> </a>
<a name="ln1805">/******************************/</a>
<a name="ln1806">/* Function check_for_newer() */  /* used for overwriting/freshening/updating */</a>
<a name="ln1807">/******************************/</a>
<a name="ln1808"> </a>
<a name="ln1809">int check_for_newer(__G__ filename)  /* return 1 if existing file is newer */</a>
<a name="ln1810">    __GDEF                           /*  or equal; 0 if older; -1 if doesn't */</a>
<a name="ln1811">    char *filename;                  /*  exist yet */</a>
<a name="ln1812">{</a>
<a name="ln1813">    time_t existing, archive;</a>
<a name="ln1814">#ifdef USE_EF_UT_TIME</a>
<a name="ln1815">    iztimes z_utime;</a>
<a name="ln1816">#endif</a>
<a name="ln1817">#ifdef AOS_VS</a>
<a name="ln1818">    long    dyy, dmm, ddd, dhh, dmin, dss;</a>
<a name="ln1819"> </a>
<a name="ln1820"> </a>
<a name="ln1821">    dyy = (lrec.last_mod_dos_datetime &gt;&gt; 25) + 1980;</a>
<a name="ln1822">    dmm = (lrec.last_mod_dos_datetime &gt;&gt; 21) &amp; 0x0f;</a>
<a name="ln1823">    ddd = (lrec.last_mod_dos_datetime &gt;&gt; 16) &amp; 0x1f;</a>
<a name="ln1824">    dhh = (lrec.last_mod_dos_datetime &gt;&gt; 11) &amp; 0x1f;</a>
<a name="ln1825">    dmin = (lrec.last_mod_dos_datetime &gt;&gt; 5) &amp; 0x3f;</a>
<a name="ln1826">    dss = (lrec.last_mod_dos_datetime &amp; 0x1f) * 2;</a>
<a name="ln1827"> </a>
<a name="ln1828">    /* under AOS/VS, file times can only be set at creation time,</a>
<a name="ln1829">     * with the info in a special DG format.  Make sure we can create</a>
<a name="ln1830">     * it here - we delete it later &amp; re-create it, whether or not</a>
<a name="ln1831">     * it exists now.</a>
<a name="ln1832">     */</a>
<a name="ln1833">    if (!zvs_create(filename, (((ulg)dgdate(dmm, ddd, dyy)) &lt;&lt; 16) |</a>
<a name="ln1834">        (dhh*1800L + dmin*30L + dss/2L), -1L, -1L, (char *) -1, -1, -1, -1))</a>
<a name="ln1835">        return DOES_NOT_EXIST;</a>
<a name="ln1836">#endif /* AOS_VS */</a>
<a name="ln1837"> </a>
<a name="ln1838">    Trace((stderr, &quot;check_for_newer:  doing stat(%s)\n&quot;, FnFilter1(filename)));</a>
<a name="ln1839">    if (SSTAT(filename, &amp;G.statbuf)) {</a>
<a name="ln1840">        Trace((stderr,</a>
<a name="ln1841">          &quot;check_for_newer:  stat(%s) returns %d:  file does not exist\n&quot;,</a>
<a name="ln1842">          FnFilter1(filename), SSTAT(filename, &amp;G.statbuf)));</a>
<a name="ln1843">#ifdef SYMLINKS</a>
<a name="ln1844">        Trace((stderr, &quot;check_for_newer:  doing lstat(%s)\n&quot;,</a>
<a name="ln1845">          FnFilter1(filename)));</a>
<a name="ln1846">        /* GRR OPTION:  could instead do this test ONLY if G.symlnk is true */</a>
<a name="ln1847">        if (lstat(filename, &amp;G.statbuf) == 0) {</a>
<a name="ln1848">            Trace((stderr,</a>
<a name="ln1849">              &quot;check_for_newer:  lstat(%s) returns 0:  symlink does exist\n&quot;,</a>
<a name="ln1850">              FnFilter1(filename)));</a>
<a name="ln1851">            if (QCOND2 &amp;&amp; !IS_OVERWRT_ALL)</a>
<a name="ln1852">                Info(slide, 0, ((char *)slide, LoadFarString(FileIsSymLink),</a>
<a name="ln1853">                  FnFilter1(filename), &quot; with no real file&quot;));</a>
<a name="ln1854">            return EXISTS_AND_OLDER;   /* symlink dates are meaningless */</a>
<a name="ln1855">        }</a>
<a name="ln1856">#endif /* SYMLINKS */</a>
<a name="ln1857">        return DOES_NOT_EXIST;</a>
<a name="ln1858">    }</a>
<a name="ln1859">    Trace((stderr, &quot;check_for_newer:  stat(%s) returns 0:  file exists\n&quot;,</a>
<a name="ln1860">      FnFilter1(filename)));</a>
<a name="ln1861"> </a>
<a name="ln1862">#ifdef SYMLINKS</a>
<a name="ln1863">    /* GRR OPTION:  could instead do this test ONLY if G.symlnk is true */</a>
<a name="ln1864">    if (lstat(filename, &amp;G.statbuf) == 0 &amp;&amp; S_ISLNK(G.statbuf.st_mode)) {</a>
<a name="ln1865">        Trace((stderr, &quot;check_for_newer:  %s is a symbolic link\n&quot;,</a>
<a name="ln1866">          FnFilter1(filename)));</a>
<a name="ln1867">        if (QCOND2 &amp;&amp; !IS_OVERWRT_ALL)</a>
<a name="ln1868">            Info(slide, 0, ((char *)slide, LoadFarString(FileIsSymLink),</a>
<a name="ln1869">              FnFilter1(filename), &quot;&quot;));</a>
<a name="ln1870">        return EXISTS_AND_OLDER;   /* symlink dates are meaningless */</a>
<a name="ln1871">    }</a>
<a name="ln1872">#endif /* SYMLINKS */</a>
<a name="ln1873"> </a>
<a name="ln1874">    NATIVE_TO_TIMET(G.statbuf.st_mtime)   /* NOP unless MSC 7.0 or Macintosh */</a>
<a name="ln1875"> </a>
<a name="ln1876">#ifdef USE_EF_UT_TIME</a>
<a name="ln1877">    /* The `Unix extra field mtime' should be used for comparison with the</a>
<a name="ln1878">     * time stamp of the existing file &gt;&gt;&gt;ONLY&lt;&lt;&lt; when the EF info is also</a>
<a name="ln1879">     * used to set the modification time of the extracted file.</a>
<a name="ln1880">     */</a>
<a name="ln1881">    if (G.extra_field &amp;&amp;</a>
<a name="ln1882">#ifdef IZ_CHECK_TZ</a>
<a name="ln1883">        G.tz_is_valid &amp;&amp;</a>
<a name="ln1884">#endif</a>
<a name="ln1885">        (ef_scan_for_izux(G.extra_field, G.lrec.extra_field_length, 0,</a>
<a name="ln1886">                          G.lrec.last_mod_dos_datetime, &amp;z_utime, NULL)</a>
<a name="ln1887">         &amp; EB_UT_FL_MTIME))</a>
<a name="ln1888">    {</a>
<a name="ln1889">        TTrace((stderr, &quot;check_for_newer:  using Unix extra field mtime\n&quot;));</a>
<a name="ln1890">        existing = G.statbuf.st_mtime;</a>
<a name="ln1891">        archive  = z_utime.mtime;</a>
<a name="ln1892">    } else {</a>
<a name="ln1893">        /* round up existing filetime to nearest 2 seconds for comparison,</a>
<a name="ln1894">         * but saturate in case of arithmetic overflow</a>
<a name="ln1895">         */</a>
<a name="ln1896">        existing = ((G.statbuf.st_mtime &amp; 1) &amp;&amp;</a>
<a name="ln1897">                    (G.statbuf.st_mtime + 1 &gt; G.statbuf.st_mtime)) ?</a>
<a name="ln1898">                   G.statbuf.st_mtime + 1 : G.statbuf.st_mtime;</a>
<a name="ln1899">        archive  = dos_to_unix_time(G.lrec.last_mod_dos_datetime);</a>
<a name="ln1900">    }</a>
<a name="ln1901">#else /* !USE_EF_UT_TIME */</a>
<a name="ln1902">    /* round up existing filetime to nearest 2 seconds for comparison,</a>
<a name="ln1903">     * but saturate in case of arithmetic overflow</a>
<a name="ln1904">     */</a>
<a name="ln1905">    existing = ((G.statbuf.st_mtime &amp; 1) &amp;&amp;</a>
<a name="ln1906">                (G.statbuf.st_mtime + 1 &gt; G.statbuf.st_mtime)) ?</a>
<a name="ln1907">               G.statbuf.st_mtime + 1 : G.statbuf.st_mtime;</a>
<a name="ln1908">    archive  = dos_to_unix_time(G.lrec.last_mod_dos_datetime);</a>
<a name="ln1909">#endif /* ?USE_EF_UT_TIME */</a>
<a name="ln1910"> </a>
<a name="ln1911">    TTrace((stderr, &quot;check_for_newer:  existing %lu, archive %lu, e-a %ld\n&quot;,</a>
<a name="ln1912">      (ulg)existing, (ulg)archive, (long)(existing-archive)));</a>
<a name="ln1913"> </a>
<a name="ln1914">    return (existing &gt;= archive);</a>
<a name="ln1915"> </a>
<a name="ln1916">} /* end function check_for_newer() */</a>
<a name="ln1917"> </a>
<a name="ln1918">#endif /* !VMS &amp;&amp; !OS2 &amp;&amp; !CMS_MVS */</a>
<a name="ln1919"> </a>
<a name="ln1920"> </a>
<a name="ln1921"> </a>
<a name="ln1922"> </a>
<a name="ln1923"> </a>
<a name="ln1924">/************************/</a>
<a name="ln1925">/* Function do_string() */</a>
<a name="ln1926">/************************/</a>
<a name="ln1927"> </a>
<a name="ln1928">int do_string(__G__ length, option)   /* return PK-type error code */</a>
<a name="ln1929">    __GDEF</a>
<a name="ln1930">    unsigned int length;        /* without prototype, ush converted to this */</a>
<a name="ln1931">    int option;</a>
<a name="ln1932">{</a>
<a name="ln1933">    unsigned comment_bytes_left;</a>
<a name="ln1934">    unsigned int block_len;</a>
<a name="ln1935">    int error=PK_OK;</a>
<a name="ln1936">#ifdef AMIGA</a>
<a name="ln1937">    char tmp_fnote[2 * AMIGA_FILENOTELEN];   /* extra room for squozen chars */</a>
<a name="ln1938">#endif</a>
<a name="ln1939"> </a>
<a name="ln1940"> </a>
<a name="ln1941">/*---------------------------------------------------------------------------</a>
<a name="ln1942">    This function processes arbitrary-length (well, usually) strings.  Four</a>
<a name="ln1943">    major options are allowed:  SKIP, wherein the string is skipped (pretty</a>
<a name="ln1944">    logical, eh?); DISPLAY, wherein the string is printed to standard output</a>
<a name="ln1945">    after undergoing any necessary or unnecessary character conversions;</a>
<a name="ln1946">    DS_FN, wherein the string is put into the filename[] array after under-</a>
<a name="ln1947">    going appropriate conversions (including case-conversion, if that is</a>
<a name="ln1948">    indicated: see the global variable pInfo-&gt;lcflag); and EXTRA_FIELD,</a>
<a name="ln1949">    wherein the `string' is assumed to be an extra field and is copied to</a>
<a name="ln1950">    the (freshly malloced) buffer G.extra_field.  The third option should</a>
<a name="ln1951">    be OK since filename is dimensioned at 1025, but we check anyway.</a>
<a name="ln1952"> </a>
<a name="ln1953">    The string, by the way, is assumed to start at the current file-pointer</a>
<a name="ln1954">    position; its length is given by 'length'.  So start off by checking the</a>
<a name="ln1955">    length of the string:  if zero, we're already done.</a>
<a name="ln1956">  ---------------------------------------------------------------------------*/</a>
<a name="ln1957"> </a>
<a name="ln1958">    if (!length)</a>
<a name="ln1959">        return PK_COOL;</a>
<a name="ln1960"> </a>
<a name="ln1961">    switch (option) {</a>
<a name="ln1962"> </a>
<a name="ln1963">#if (defined(SFX) &amp;&amp; defined(CHEAP_SFX_AUTORUN))</a>
<a name="ln1964">    /*</a>
<a name="ln1965">     * Special case: See if the comment begins with an autorun command line.</a>
<a name="ln1966">     * Save that and display (or skip) the remainder.</a>
<a name="ln1967">     */</a>
<a name="ln1968"> </a>
<a name="ln1969">    case CHECK_AUTORUN:</a>
<a name="ln1970">    case CHECK_AUTORUN_Q:</a>
<a name="ln1971">        comment_bytes_left = length;</a>
<a name="ln1972">        if (length &gt;= 10)</a>
<a name="ln1973">        {</a>
<a name="ln1974">            block_len = readbuf(__G__ (char *)G.outbuf, 10);</a>
<a name="ln1975">            if (block_len == 0)</a>
<a name="ln1976">                return PK_EOF;</a>
<a name="ln1977">            comment_bytes_left -= block_len;</a>
<a name="ln1978">            G.outbuf[block_len] = '\0';</a>
<a name="ln1979">            if (!strcmp((char *)G.outbuf, &quot;$AUTORUN$&gt;&quot;)) {</a>
<a name="ln1980">                char *eol;</a>
<a name="ln1981">                length -= 10;</a>
<a name="ln1982">                block_len = readbuf(__G__ G.autorun_command,</a>
<a name="ln1983">                                    MIN(length, sizeof(G.autorun_command)-1));</a>
<a name="ln1984">                if (block_len == 0)</a>
<a name="ln1985">                    return PK_EOF;</a>
<a name="ln1986">                comment_bytes_left -= block_len;</a>
<a name="ln1987">                G.autorun_command[block_len] = '\0';</a>
<a name="ln1988">                A_TO_N(G.autorun_command);</a>
<a name="ln1989">                eol = strchr(G.autorun_command, '\n');</a>
<a name="ln1990">                if (!eol)</a>
<a name="ln1991">                    eol = G.autorun_command + strlen(G.autorun_command) - 1;</a>
<a name="ln1992">                length -= eol + 1 - G.autorun_command;</a>
<a name="ln1993">                while (eol &gt;= G.autorun_command &amp;&amp; isspace(*eol))</a>
<a name="ln1994">                    *eol-- = '\0';</a>
<a name="ln1995">#ifdef WIN32</a>
<a name="ln1996">                /* Win9x console always uses OEM character coding, and</a>
<a name="ln1997">                   WinNT console is set to OEM charset by default, too */</a>
<a name="ln1998">                INTERN_TO_OEM(G.autorun_command, G.autorun_command);</a>
<a name="ln1999">#endif /* WIN32 */</a>
<a name="ln2000">            }</a>
<a name="ln2001">        }</a>
<a name="ln2002">        if (option == CHECK_AUTORUN_Q)  /* don't display the remainder */</a>
<a name="ln2003">            length = 0;</a>
<a name="ln2004">        /* seek to beginning of remaining part of comment -- rewind if */</a>
<a name="ln2005">        /* displaying entire comment, or skip to end if discarding it  */</a>
<a name="ln2006">        seek_zipf(__G__ G.cur_zipfile_bufstart - G.extra_bytes +</a>
<a name="ln2007">                  (G.inptr - G.inbuf) + comment_bytes_left - length);</a>
<a name="ln2008">        if (!length)</a>
<a name="ln2009">            break;</a>
<a name="ln2010">        /*  FALL THROUGH...  */</a>
<a name="ln2011">#endif /* SFX &amp;&amp; CHEAP_SFX_AUTORUN */</a>
<a name="ln2012"> </a>
<a name="ln2013">    /*</a>
<a name="ln2014">     * First normal case:  print string on standard output.  First set loop</a>
<a name="ln2015">     * variables, then loop through the comment in chunks of OUTBUFSIZ bytes,</a>
<a name="ln2016">     * converting formats and printing as we go.  The second half of the</a>
<a name="ln2017">     * loop conditional was added because the file might be truncated, in</a>
<a name="ln2018">     * which case comment_bytes_left will remain at some non-zero value for</a>
<a name="ln2019">     * all time.  outbuf and slide are used as scratch buffers because they</a>
<a name="ln2020">     * are available (we should be either before or in between any file pro-</a>
<a name="ln2021">     * cessing).</a>
<a name="ln2022">     */</a>
<a name="ln2023"> </a>
<a name="ln2024">    case DISPLAY:</a>
<a name="ln2025">    case DISPL_8:</a>
<a name="ln2026">        comment_bytes_left = length;</a>
<a name="ln2027">        block_len = OUTBUFSIZ;       /* for the while statement, first time */</a>
<a name="ln2028">        while (comment_bytes_left &gt; 0 &amp;&amp; block_len &gt; 0) {</a>
<a name="ln2029">            register uch *p = G.outbuf;</a>
<a name="ln2030">            register uch *q = G.outbuf;</a>
<a name="ln2031"> </a>
<a name="ln2032">            if ((block_len = readbuf(__G__ (char *)G.outbuf,</a>
<a name="ln2033">                   MIN((unsigned)OUTBUFSIZ, comment_bytes_left))) == 0)</a>
<a name="ln2034">                return PK_EOF;</a>
<a name="ln2035">            comment_bytes_left -= block_len;</a>
<a name="ln2036"> </a>
<a name="ln2037">            /* this is why we allocated an extra byte for outbuf:  terminate</a>
<a name="ln2038">             *  with zero (ASCIIZ) */</a>
<a name="ln2039">            G.outbuf[block_len] = '\0';</a>
<a name="ln2040"> </a>
<a name="ln2041">            /* remove all ASCII carriage returns from comment before printing</a>
<a name="ln2042">             * (since used before A_TO_N(), check for CR instead of '\r')</a>
<a name="ln2043">             */</a>
<a name="ln2044">            while (*p) {</a>
<a name="ln2045">                while (*p == CR)</a>
<a name="ln2046">                    ++p;</a>
<a name="ln2047">                *q++ = *p++;</a>
<a name="ln2048">            }</a>
<a name="ln2049">            /* could check whether (p - outbuf) == block_len here */</a>
<a name="ln2050">            *q = '\0';</a>
<a name="ln2051"> </a>
<a name="ln2052">            if (option == DISPL_8) {</a>
<a name="ln2053">                /* translate the text coded in the entry's host-dependent</a>
<a name="ln2054">                   &quot;extended ASCII&quot; charset into the compiler's (system's)</a>
<a name="ln2055">                   internal text code page */</a>
<a name="ln2056">                Ext_ASCII_TO_Native((char *)G.outbuf, G.pInfo-&gt;hostnum,</a>
<a name="ln2057">                                    G.pInfo-&gt;hostver, G.pInfo-&gt;HasUxAtt,</a>
<a name="ln2058">                                    FALSE);</a>
<a name="ln2059">#ifdef WINDLL</a>
<a name="ln2060">                /* translate to ANSI (RTL internal codepage may be OEM) */</a>
<a name="ln2061">                INTERN_TO_ISO((char *)G.outbuf, (char *)G.outbuf);</a>
<a name="ln2062">#else /* !WINDLL */</a>
<a name="ln2063">#ifdef WIN32</a>
<a name="ln2064">                /* Win9x console always uses OEM character coding, and</a>
<a name="ln2065">                   WinNT console is set to OEM charset by default, too */</a>
<a name="ln2066">                INTERN_TO_OEM((char *)G.outbuf, (char *)G.outbuf);</a>
<a name="ln2067">#endif /* WIN32 */</a>
<a name="ln2068">#endif /* ?WINDLL */</a>
<a name="ln2069">            } else {</a>
<a name="ln2070">                A_TO_N(G.outbuf);   /* translate string to native */</a>
<a name="ln2071">            }</a>
<a name="ln2072"> </a>
<a name="ln2073">#ifdef WINDLL</a>
<a name="ln2074">            /* ran out of local mem -- had to cheat */</a>
<a name="ln2075">            win_fprintf((zvoid *)&amp;G, stdout, length, (char *)G.outbuf);</a>
<a name="ln2076">            win_fprintf((zvoid *)&amp;G, stdout, 2, (char *)&quot;\n\n&quot;);</a>
<a name="ln2077">#else /* !WINDLL */</a>
<a name="ln2078">#ifdef NOANSIFILT       /* GRR:  can ANSI be used with EBCDIC? */</a>
<a name="ln2079">            (*G.message)((zvoid *)&amp;G, G.outbuf, (ulg)(q-G.outbuf), 0);</a>
<a name="ln2080">#else /* ASCII, filter out ANSI escape sequences and handle ^S (pause) */</a>
<a name="ln2081">            p = G.outbuf - 1;</a>
<a name="ln2082">            q = slide;</a>
<a name="ln2083">            while (*++p) {</a>
<a name="ln2084">                int pause = FALSE;</a>
<a name="ln2085"> </a>
<a name="ln2086">                if (*p == 0x1B) {          /* ASCII escape char */</a>
<a name="ln2087">                    *q++ = '^';</a>
<a name="ln2088">                    *q++ = '[';</a>
<a name="ln2089">                } else if (*p == 0x13) {   /* ASCII ^S (pause) */</a>
<a name="ln2090">                    pause = TRUE;</a>
<a name="ln2091">                    if (p[1] == LF)        /* ASCII LF */</a>
<a name="ln2092">                        *q++ = *++p;</a>
<a name="ln2093">                    else if (p[1] == CR &amp;&amp; p[2] == LF) {  /* ASCII CR LF */</a>
<a name="ln2094">                        *q++ = *++p;</a>
<a name="ln2095">                        *q++ = *++p;</a>
<a name="ln2096">                    }</a>
<a name="ln2097">                } else</a>
<a name="ln2098">                    *q++ = *p;</a>
<a name="ln2099">                if ((unsigned)(q-slide) &gt; WSIZE-3 || pause) {   /* flush */</a>
<a name="ln2100">                    (*G.message)((zvoid *)&amp;G, slide, (ulg)(q-slide), 0);</a>
<a name="ln2101">                    q = slide;</a>
<a name="ln2102">                    if (pause &amp;&amp; G.extract_flag) /* don't pause for list/test */</a>
<a name="ln2103">                        (*G.mpause)((zvoid *)&amp;G, LoadFarString(QuitPrompt), 0);</a>
<a name="ln2104">                }</a>
<a name="ln2105">            }</a>
<a name="ln2106">            (*G.message)((zvoid *)&amp;G, slide, (ulg)(q-slide), 0);</a>
<a name="ln2107">#endif /* ?NOANSIFILT */</a>
<a name="ln2108">#endif /* ?WINDLL */</a>
<a name="ln2109">        }</a>
<a name="ln2110">        /* add '\n' if not at start of line */</a>
<a name="ln2111">        (*G.message)((zvoid *)&amp;G, slide, 0L, 0x40);</a>
<a name="ln2112">        break;</a>
<a name="ln2113"> </a>
<a name="ln2114">    /*</a>
<a name="ln2115">     * Second case:  read string into filename[] array.  The filename should</a>
<a name="ln2116">     * never ever be longer than FILNAMSIZ-1 (1024), but for now we'll check,</a>
<a name="ln2117">     * just to be sure.</a>
<a name="ln2118">     */</a>
<a name="ln2119"> </a>
<a name="ln2120">    case DS_FN:</a>
<a name="ln2121">    case DS_FN_L:</a>
<a name="ln2122">        if (length &gt;= FILNAMSIZ) {</a>
<a name="ln2123">            Info(slide, 0x401, ((char *)slide,</a>
<a name="ln2124">              LoadFarString(FilenameTooLongTrunc)));</a>
<a name="ln2125">            error = PK_WARN;</a>
<a name="ln2126">            /* remember excess length in block_len */</a>
<a name="ln2127">            block_len = length - (FILNAMSIZ - 1);</a>
<a name="ln2128">            length = FILNAMSIZ - 1;</a>
<a name="ln2129">        } else</a>
<a name="ln2130">            /* no excess size */</a>
<a name="ln2131">            block_len = 0;</a>
<a name="ln2132">        if (readbuf(__G__ G.filename, length) == 0)</a>
<a name="ln2133">            return PK_EOF;</a>
<a name="ln2134">        G.filename[length] = '\0';      /* terminate w/zero:  ASCIIZ */</a>
<a name="ln2135"> </a>
<a name="ln2136">        /* translate the Zip entry filename coded in host-dependent &quot;extended</a>
<a name="ln2137">           ASCII&quot; into the compiler's (system's) internal text code page */</a>
<a name="ln2138">        Ext_ASCII_TO_Native(G.filename, G.pInfo-&gt;hostnum, G.pInfo-&gt;hostver,</a>
<a name="ln2139">                            G.pInfo-&gt;HasUxAtt, (option == DS_FN_L));</a>
<a name="ln2140"> </a>
<a name="ln2141">        if (G.pInfo-&gt;lcflag)      /* replace with lowercase filename */</a>
<a name="ln2142">            STRLOWER(G.filename, G.filename);</a>
<a name="ln2143"> </a>
<a name="ln2144">        if (G.pInfo-&gt;vollabel &amp;&amp; length &gt; 8 &amp;&amp; G.filename[8] == '.') {</a>
<a name="ln2145">            char *p = G.filename+8;</a>
<a name="ln2146">            while (*p++)</a>
<a name="ln2147">                p[-1] = *p;  /* disk label, and 8th char is dot:  remove dot */</a>
<a name="ln2148">        }</a>
<a name="ln2149"> </a>
<a name="ln2150">        if (!block_len)         /* no overflow, we're done here */</a>
<a name="ln2151">            break;</a>
<a name="ln2152"> </a>
<a name="ln2153">        /*</a>
<a name="ln2154">         * We truncated the filename, so print what's left and then fall</a>
<a name="ln2155">         * through to the SKIP routine.</a>
<a name="ln2156">         */</a>
<a name="ln2157">        Info(slide, 0x401, ((char *)slide, &quot;[ %s ]\n&quot;, FnFilter1(G.filename)));</a>
<a name="ln2158">        length = block_len;     /* SKIP the excess bytes... */</a>
<a name="ln2159">        /*  FALL THROUGH...  */</a>
<a name="ln2160"> </a>
<a name="ln2161">    /*</a>
<a name="ln2162">     * Third case:  skip string, adjusting readbuf's internal variables</a>
<a name="ln2163">     * as necessary (and possibly skipping to and reading a new block of</a>
<a name="ln2164">     * data).</a>
<a name="ln2165">     */</a>
<a name="ln2166"> </a>
<a name="ln2167">    case SKIP:</a>
<a name="ln2168">        /* cur_zipfile_bufstart already takes account of extra_bytes, so don't</a>
<a name="ln2169">         * correct for it twice: */</a>
<a name="ln2170">        seek_zipf(__G__ G.cur_zipfile_bufstart - G.extra_bytes +</a>
<a name="ln2171">                  (G.inptr-G.inbuf) + length);</a>
<a name="ln2172">        break;</a>
<a name="ln2173"> </a>
<a name="ln2174">    /*</a>
<a name="ln2175">     * Fourth case:  assume we're at the start of an &quot;extra field&quot;; malloc</a>
<a name="ln2176">     * storage for it and read data into the allocated space.</a>
<a name="ln2177">     */</a>
<a name="ln2178"> </a>
<a name="ln2179">    case EXTRA_FIELD:</a>
<a name="ln2180">        if (G.extra_field != (uch *)NULL)</a>
<a name="ln2181">            free(G.extra_field);</a>
<a name="ln2182">        if ((G.extra_field = (uch *)malloc(length)) == (uch *)NULL) {</a>
<a name="ln2183">            Info(slide, 0x401, ((char *)slide, LoadFarString(ExtraFieldTooLong),</a>
<a name="ln2184">              length));</a>
<a name="ln2185">            /* cur_zipfile_bufstart already takes account of extra_bytes,</a>
<a name="ln2186">             * so don't correct for it twice: */</a>
<a name="ln2187">            seek_zipf(__G__ G.cur_zipfile_bufstart - G.extra_bytes +</a>
<a name="ln2188">                      (G.inptr-G.inbuf) + length);</a>
<a name="ln2189">        } else</a>
<a name="ln2190">            if (readbuf(__G__ (char *)G.extra_field, length) == 0)</a>
<a name="ln2191">                return PK_EOF;</a>
<a name="ln2192">        break;</a>
<a name="ln2193"> </a>
<a name="ln2194">#ifdef AMIGA</a>
<a name="ln2195">    /*</a>
<a name="ln2196">     * Fifth case, for the Amiga only:  take the comment that would ordinarily</a>
<a name="ln2197">     * be skipped over, and turn it into a 79 character string that will be</a>
<a name="ln2198">     * attached to the file as a &quot;filenote&quot; after it is extracted.</a>
<a name="ln2199">     */</a>
<a name="ln2200"> </a>
<a name="ln2201">    case FILENOTE:</a>
<a name="ln2202">        if ((block_len = readbuf(__G__ tmp_fnote, (unsigned)</a>
<a name="ln2203">                                 MIN(length, 2 * AMIGA_FILENOTELEN - 1))) == 0)</a>
<a name="ln2204">            return PK_EOF;</a>
<a name="ln2205">        if ((length -= block_len) &gt; 0)  /* treat remainder as in case SKIP: */</a>
<a name="ln2206">            seek_zipf(__G__ G.cur_zipfile_bufstart - G.extra_bytes</a>
<a name="ln2207">                      + (G.inptr - G.inbuf) + length);</a>
<a name="ln2208">        /* convert multi-line text into single line with no ctl-chars: */</a>
<a name="ln2209">        tmp_fnote[block_len] = '\0';</a>
<a name="ln2210">        while ((short int) --block_len &gt;= 0)</a>
<a name="ln2211">            if ((unsigned) tmp_fnote[block_len] &lt; ' ')</a>
<a name="ln2212">                if (tmp_fnote[block_len+1] == ' ')     /* no excess */</a>
<a name="ln2213">                    strcpy(tmp_fnote+block_len, tmp_fnote+block_len+1);</a>
<a name="ln2214">                else</a>
<a name="ln2215">                    tmp_fnote[block_len] = ' ';</a>
<a name="ln2216">        tmp_fnote[AMIGA_FILENOTELEN - 1] = '\0';</a>
<a name="ln2217">        if (G.filenotes[G.filenote_slot])</a>
<a name="ln2218">            free(G.filenotes[G.filenote_slot]);     /* should not happen */</a>
<a name="ln2219">        G.filenotes[G.filenote_slot] = NULL;</a>
<a name="ln2220">        if (tmp_fnote[0]) {</a>
<a name="ln2221">            if (!(G.filenotes[G.filenote_slot] = malloc(strlen(tmp_fnote)+1)))</a>
<a name="ln2222">                return PK_MEM;</a>
<a name="ln2223">            strcpy(G.filenotes[G.filenote_slot], tmp_fnote);</a>
<a name="ln2224">        }</a>
<a name="ln2225">        break;</a>
<a name="ln2226">#endif /* AMIGA */</a>
<a name="ln2227"> </a>
<a name="ln2228">    } /* end switch (option) */</a>
<a name="ln2229"> </a>
<a name="ln2230">    return error;</a>
<a name="ln2231"> </a>
<a name="ln2232">} /* end function do_string() */</a>
<a name="ln2233"> </a>
<a name="ln2234"> </a>
<a name="ln2235"> </a>
<a name="ln2236"> </a>
<a name="ln2237"> </a>
<a name="ln2238">/***********************/</a>
<a name="ln2239">/* Function makeword() */</a>
<a name="ln2240">/***********************/</a>
<a name="ln2241"> </a>
<a name="ln2242">ush makeword(b)</a>
<a name="ln2243">    ZCONST uch *b;</a>
<a name="ln2244">{</a>
<a name="ln2245">    /*</a>
<a name="ln2246">     * Convert Intel style 'short' integer to non-Intel non-16-bit</a>
<a name="ln2247">     * host format.  This routine also takes care of byte-ordering.</a>
<a name="ln2248">     */</a>
<a name="ln2249">    return (ush)((b[1] &lt;&lt; 8) | b[0]);</a>
<a name="ln2250">}</a>
<a name="ln2251"> </a>
<a name="ln2252"> </a>
<a name="ln2253"> </a>
<a name="ln2254"> </a>
<a name="ln2255"> </a>
<a name="ln2256">/***********************/</a>
<a name="ln2257">/* Function makelong() */</a>
<a name="ln2258">/***********************/</a>
<a name="ln2259"> </a>
<a name="ln2260">ulg makelong(sig)</a>
<a name="ln2261">    ZCONST uch *sig;</a>
<a name="ln2262">{</a>
<a name="ln2263">    /*</a>
<a name="ln2264">     * Convert intel style 'long' variable to non-Intel non-16-bit</a>
<a name="ln2265">     * host format.  This routine also takes care of byte-ordering.</a>
<a name="ln2266">     */</a>
<a name="ln2267">    return (((ulg)sig[3]) &lt;&lt; 24)</a>
<a name="ln2268">        + (((ulg)sig[2]) &lt;&lt; 16)</a>
<a name="ln2269">        + (((ulg)sig[1]) &lt;&lt; 8)</a>
<a name="ln2270">        + ((ulg)sig[0]);</a>
<a name="ln2271">}</a>
<a name="ln2272"> </a>
<a name="ln2273"> </a>
<a name="ln2274"> </a>
<a name="ln2275">#if CRYPT</a>
<a name="ln2276"> </a>
<a name="ln2277">#ifdef NEED_STR2ISO</a>
<a name="ln2278">/**********************/</a>
<a name="ln2279">/* Function str2iso() */</a>
<a name="ln2280">/**********************/</a>
<a name="ln2281"> </a>
<a name="ln2282">char *str2iso(dst, src)</a>
<a name="ln2283">    char *dst;                          /* destination buffer */</a>
<a name="ln2284">    register ZCONST char *src;          /* source string */</a>
<a name="ln2285">{</a>
<a name="ln2286">#ifdef INTERN_TO_ISO</a>
<a name="ln2287">    INTERN_TO_ISO(src, dst);</a>
<a name="ln2288">#else</a>
<a name="ln2289">    register uch c;</a>
<a name="ln2290">    register char *dstp = dst;</a>
<a name="ln2291"> </a>
<a name="ln2292">    do {</a>
<a name="ln2293">        c = (uch)foreign(*src++);</a>
<a name="ln2294">        *dstp++ = (char)ASCII2ISO(c);</a>
<a name="ln2295">    } while (c != '\0');</a>
<a name="ln2296">#endif</a>
<a name="ln2297"> </a>
<a name="ln2298">    return dst;</a>
<a name="ln2299">}</a>
<a name="ln2300">#endif /* NEED_STR2ISO */</a>
<a name="ln2301"> </a>
<a name="ln2302"> </a>
<a name="ln2303">#ifdef NEED_STR2OEM</a>
<a name="ln2304">/**********************/</a>
<a name="ln2305">/* Function str2oem() */</a>
<a name="ln2306">/**********************/</a>
<a name="ln2307"> </a>
<a name="ln2308">char *str2oem(dst, src)</a>
<a name="ln2309">    char *dst;                          /* destination buffer */</a>
<a name="ln2310">    register ZCONST char *src;          /* source string */</a>
<a name="ln2311">{</a>
<a name="ln2312">#ifdef INTERN_TO_OEM</a>
<a name="ln2313">    INTERN_TO_OEM(src, dst);</a>
<a name="ln2314">#else</a>
<a name="ln2315">    register uch c;</a>
<a name="ln2316">    register char *dstp = dst;</a>
<a name="ln2317"> </a>
<a name="ln2318">    do {</a>
<a name="ln2319">        c = (uch)foreign(*src++);</a>
<a name="ln2320">        *dstp++ = (char)ASCII2OEM(c);</a>
<a name="ln2321">    } while (c != '\0');</a>
<a name="ln2322">#endif</a>
<a name="ln2323"> </a>
<a name="ln2324">    return dst;</a>
<a name="ln2325">}</a>
<a name="ln2326">#endif /* NEED_STR2OEM */</a>
<a name="ln2327"> </a>
<a name="ln2328">#endif /* CRYPT */</a>
<a name="ln2329"> </a>
<a name="ln2330"> </a>
<a name="ln2331">#ifdef ZMEM  /* memset/memcmp/memcpy for systems without either them or */</a>
<a name="ln2332">             /* bzero/bcmp/bcopy */</a>
<a name="ln2333">             /* (no known systems as of 960211) */</a>
<a name="ln2334"> </a>
<a name="ln2335">/*********************/</a>
<a name="ln2336">/* Function memset() */</a>
<a name="ln2337">/*********************/</a>
<a name="ln2338"> </a>
<a name="ln2339">zvoid *memset(buf, init, len)</a>
<a name="ln2340">    register zvoid *buf;        /* buffer location */</a>
<a name="ln2341">    register int init;          /* initializer character */</a>
<a name="ln2342">    register unsigned int len;  /* length of the buffer */</a>
<a name="ln2343">{</a>
<a name="ln2344">    zvoid *start;</a>
<a name="ln2345"> </a>
<a name="ln2346">    start = buf;</a>
<a name="ln2347">    while (len--)</a>
<a name="ln2348">        *((char *)buf++) = (char)init;</a>
<a name="ln2349">    return start;</a>
<a name="ln2350">}</a>
<a name="ln2351"> </a>
<a name="ln2352"> </a>
<a name="ln2353"> </a>
<a name="ln2354">/*********************/</a>
<a name="ln2355">/* Function memcmp() */</a>
<a name="ln2356">/*********************/</a>
<a name="ln2357"> </a>
<a name="ln2358">int memcmp(b1, b2, len)</a>
<a name="ln2359">    register ZCONST zvoid *b1;</a>
<a name="ln2360">    register ZCONST zvoid *b2;</a>
<a name="ln2361">    register unsigned int len;</a>
<a name="ln2362">{</a>
<a name="ln2363">    register int c;</a>
<a name="ln2364"> </a>
<a name="ln2365">    if (len &gt; 0) do {</a>
<a name="ln2366">        if ((c = (int)(*((ZCONST unsigned char *)b1)++) -</a>
<a name="ln2367">                 (int)(*((ZCONST unsigned char *)b2)++)) != 0)</a>
<a name="ln2368">           return c;</a>
<a name="ln2369">    } while (--len &gt; 0)</a>
<a name="ln2370">    return 0;</a>
<a name="ln2371">}</a>
<a name="ln2372"> </a>
<a name="ln2373"> </a>
<a name="ln2374"> </a>
<a name="ln2375">/*********************/</a>
<a name="ln2376">/* Function memcpy() */</a>
<a name="ln2377">/*********************/</a>
<a name="ln2378"> </a>
<a name="ln2379">zvoid *memcpy(dst, src, len)</a>
<a name="ln2380">    register zvoid *dst;</a>
<a name="ln2381">    register ZCONST zvoid *src;</a>
<a name="ln2382">    register unsigned int len;</a>
<a name="ln2383">{</a>
<a name="ln2384">    zvoid *start;</a>
<a name="ln2385"> </a>
<a name="ln2386">    start = dst;</a>
<a name="ln2387">    while (len-- &gt; 0)</a>
<a name="ln2388">        *((char *)dst)++ = *((ZCONST char *)src)++;</a>
<a name="ln2389">    return start;</a>
<a name="ln2390">}</a>
<a name="ln2391"> </a>
<a name="ln2392">#endif /* ZMEM */</a>
<a name="ln2393"> </a>
<a name="ln2394"> </a>
<a name="ln2395"> </a>
<a name="ln2396"> </a>
<a name="ln2397">#ifdef NO_STRNICMP</a>
<a name="ln2398"> </a>
<a name="ln2399">/************************/</a>
<a name="ln2400">/* Function zstrnicmp() */</a>
<a name="ln2401">/************************/</a>
<a name="ln2402"> </a>
<a name="ln2403">int zstrnicmp(s1, s2, n)</a>
<a name="ln2404">    register ZCONST char *s1, *s2;</a>
<a name="ln2405">    register unsigned n;</a>
<a name="ln2406">{</a>
<a name="ln2407">    for (; n &gt; 0;  --n, ++s1, ++s2) {</a>
<a name="ln2408"> </a>
<a name="ln2409">        if (ToLower(*s1) != ToLower(*s2))</a>
<a name="ln2410">            /* test includes early termination of one string */</a>
<a name="ln2411">            return (ToLower(*s1) &lt; ToLower(*s2))? -1 : 1;</a>
<a name="ln2412"> </a>
<a name="ln2413">        if (*s1 == '\0')   /* both strings terminate early */</a>
<a name="ln2414">            return 0;</a>
<a name="ln2415">    }</a>
<a name="ln2416">    return 0;</a>
<a name="ln2417">}</a>
<a name="ln2418"> </a>
<a name="ln2419">#endif /* NO_STRNICMP */</a>
<a name="ln2420"> </a>
<a name="ln2421"> </a>
<a name="ln2422"> </a>
<a name="ln2423"> </a>
<a name="ln2424">#ifdef REGULUS  /* returns the inode number on success(!)...argh argh argh */</a>
<a name="ln2425">#  undef stat</a>
<a name="ln2426"> </a>
<a name="ln2427">/********************/</a>
<a name="ln2428">/* Function zstat() */</a>
<a name="ln2429">/********************/</a>
<a name="ln2430"> </a>
<a name="ln2431">int zstat(p, s)</a>
<a name="ln2432">    ZCONST char *p;</a>
<a name="ln2433">    struct stat *s;</a>
<a name="ln2434">{</a>
<a name="ln2435">    return (stat((char *)p,s) &gt;= 0? 0 : (-1));</a>
<a name="ln2436">}</a>
<a name="ln2437"> </a>
<a name="ln2438">#endif /* REGULUS */</a>
<a name="ln2439"> </a>
<a name="ln2440"> </a>
<a name="ln2441"> </a>
<a name="ln2442"> </a>
<a name="ln2443">#ifdef _MBCS</a>
<a name="ln2444"> </a>
<a name="ln2445">/* DBCS support for Info-ZIP's zip  (mainly for japanese (-: )</a>
<a name="ln2446"> * by Yoshioka Tsuneo (QWF00133@nifty.ne.jp,tsuneo-y@is.aist-nara.ac.jp)</a>
<a name="ln2447"> * This code is public domain!   Date: 1998/12/20</a>
<a name="ln2448"> */</a>
<a name="ln2449"> </a>
<a name="ln2450">/************************/</a>
<a name="ln2451">/* Function plastchar() */</a>
<a name="ln2452">/************************/</a>
<a name="ln2453"> </a>
<a name="ln2454">char *plastchar(ptr, len)</a>
<a name="ln2455">    ZCONST char *ptr;</a>
<a name="ln2456">    extent len;</a>
<a name="ln2457">{</a>
<a name="ln2458">    unsigned clen;</a>
<a name="ln2459">    ZCONST char *oldptr = ptr;</a>
<a name="ln2460">    while(*ptr != '\0' &amp;&amp; len &gt; 0){</a>
<a name="ln2461">        oldptr = ptr;</a>
<a name="ln2462">        clen = CLEN(ptr);</a>
<a name="ln2463">        ptr += clen;</a>
<a name="ln2464">        len -= clen;</a>
<a name="ln2465">    }</a>
<a name="ln2466">    return (char *)oldptr;</a>
<a name="ln2467">}</a>
<a name="ln2468"> </a>
<a name="ln2469"> </a>
<a name="ln2470">#ifdef NEED_UZMBSCHR</a>
<a name="ln2471">/***********************/</a>
<a name="ln2472">/* Function uzmbschr() */</a>
<a name="ln2473">/***********************/</a>
<a name="ln2474"> </a>
<a name="ln2475">unsigned char *uzmbschr(str, c)</a>
<a name="ln2476">    ZCONST unsigned char *str;</a>
<a name="ln2477">    unsigned int c;</a>
<a name="ln2478">{</a>
<a name="ln2479">    while(*str != '\0'){</a>
<a name="ln2480">        if (*str == c) {return (unsigned char *)str;}</a>
<a name="ln2481">        INCSTR(str);</a>
<a name="ln2482">    }</a>
<a name="ln2483">    return NULL;</a>
<a name="ln2484">}</a>
<a name="ln2485">#endif /* NEED_UZMBSCHR */</a>
<a name="ln2486"> </a>
<a name="ln2487"> </a>
<a name="ln2488">#ifdef NEED_UZMBSRCHR</a>
<a name="ln2489">/************************/</a>
<a name="ln2490">/* Function uzmbsrchr() */</a>
<a name="ln2491">/************************/</a>
<a name="ln2492"> </a>
<a name="ln2493">unsigned char *uzmbsrchr(str, c)</a>
<a name="ln2494">    ZCONST unsigned char *str;</a>
<a name="ln2495">    unsigned int c;</a>
<a name="ln2496">{</a>
<a name="ln2497">    unsigned char *match = NULL;</a>
<a name="ln2498">    while(*str != '\0'){</a>
<a name="ln2499">        if (*str == c) {match = (unsigned char *)str;}</a>
<a name="ln2500">        INCSTR(str);</a>
<a name="ln2501">    }</a>
<a name="ln2502">    return match;</a>
<a name="ln2503">}</a>
<a name="ln2504">#endif /* NEED_UZMBSRCHR */</a>
<a name="ln2505">#endif /* _MBCS */</a>
<a name="ln2506"> </a>
<a name="ln2507"> </a>
<a name="ln2508"> </a>
<a name="ln2509"> </a>
<a name="ln2510"> </a>
<a name="ln2511">#ifdef SMALL_MEM</a>
<a name="ln2512"> </a>
<a name="ln2513">/*******************************/</a>
<a name="ln2514">/*  Function fLoadFarString()  */   /* (and friends...) */</a>
<a name="ln2515">/*******************************/</a>
<a name="ln2516"> </a>
<a name="ln2517">char *fLoadFarString(__GPRO__ const char Far *sz)</a>
<a name="ln2518">{</a>
<a name="ln2519">    (void)zfstrcpy(G.rgchBigBuffer, sz);</a>
<a name="ln2520">    return G.rgchBigBuffer;</a>
<a name="ln2521">}</a>
<a name="ln2522"> </a>
<a name="ln2523">char *fLoadFarStringSmall(__GPRO__ const char Far *sz)</a>
<a name="ln2524">{</a>
<a name="ln2525">    (void)zfstrcpy(G.rgchSmallBuffer, sz);</a>
<a name="ln2526">    return G.rgchSmallBuffer;</a>
<a name="ln2527">}</a>
<a name="ln2528"> </a>
<a name="ln2529">char *fLoadFarStringSmall2(__GPRO__ const char Far *sz)</a>
<a name="ln2530">{</a>
<a name="ln2531">    (void)zfstrcpy(G.rgchSmallBuffer2, sz);</a>
<a name="ln2532">    return G.rgchSmallBuffer2;</a>
<a name="ln2533">}</a>
<a name="ln2534"> </a>
<a name="ln2535"> </a>
<a name="ln2536"> </a>
<a name="ln2537"> </a>
<a name="ln2538">#if (!defined(_MSC_VER) || (_MSC_VER &lt; 600))</a>
<a name="ln2539">/*************************/</a>
<a name="ln2540">/*  Function zfstrcpy()  */   /* portable clone of _fstrcpy() */</a>
<a name="ln2541">/*************************/</a>
<a name="ln2542"> </a>
<a name="ln2543">char Far * Far zfstrcpy(char Far *s1, const char Far *s2)</a>
<a name="ln2544">{</a>
<a name="ln2545">    char Far *p = s1;</a>
<a name="ln2546"> </a>
<a name="ln2547">    while ((*s1++ = *s2++) != '\0');</a>
<a name="ln2548">    return p;</a>
<a name="ln2549">}</a>
<a name="ln2550">#endif /* !_MSC_VER || (_MSC_VER &lt; 600) */</a>
<a name="ln2551"> </a>
<a name="ln2552">#endif /* SMALL_MEM */</a>

</code></pre>
<div class="balloon" rel="1716"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'days + dy' operator to the 'unsigned long' type, not the result.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
