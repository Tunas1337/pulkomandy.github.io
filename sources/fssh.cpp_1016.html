
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>fssh.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2007-2008, Ingo Weinhold, ingo_weinhold@gmx.de.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> */</a>
<a name="ln5"> </a>
<a name="ln6"> </a>
<a name="ln7">#include &quot;compatibility.h&quot;</a>
<a name="ln8"> </a>
<a name="ln9">#include &quot;fssh.h&quot;</a>
<a name="ln10"> </a>
<a name="ln11">#include &lt;stdarg.h&gt;</a>
<a name="ln12">#include &lt;stdio.h&gt;</a>
<a name="ln13">#include &lt;string.h&gt;</a>
<a name="ln14">#include &lt;time.h&gt;</a>
<a name="ln15">#include &lt;unistd.h&gt;</a>
<a name="ln16">#include &lt;stdlib.h&gt;</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;vector&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;command_cp.h&quot;</a>
<a name="ln21">#include &quot;driver_settings.h&quot;</a>
<a name="ln22">#include &quot;external_commands.h&quot;</a>
<a name="ln23">#include &quot;fd.h&quot;</a>
<a name="ln24">#include &quot;fssh_dirent.h&quot;</a>
<a name="ln25">#include &quot;fssh_errno.h&quot;</a>
<a name="ln26">#include &quot;fssh_errors.h&quot;</a>
<a name="ln27">#include &quot;fssh_fs_info.h&quot;</a>
<a name="ln28">#include &quot;fssh_fcntl.h&quot;</a>
<a name="ln29">#include &quot;fssh_module.h&quot;</a>
<a name="ln30">#include &quot;fssh_node_monitor.h&quot;</a>
<a name="ln31">#include &quot;fssh_stat.h&quot;</a>
<a name="ln32">#include &quot;fssh_string.h&quot;</a>
<a name="ln33">#include &quot;fssh_type_constants.h&quot;</a>
<a name="ln34">#include &quot;module.h&quot;</a>
<a name="ln35">#include &quot;partition_support.h&quot;</a>
<a name="ln36">#include &quot;path_util.h&quot;</a>
<a name="ln37">#include &quot;syscalls.h&quot;</a>
<a name="ln38">#include &quot;vfs.h&quot;</a>
<a name="ln39"> </a>
<a name="ln40"> </a>
<a name="ln41">extern fssh_module_info *modules[];</a>
<a name="ln42"> </a>
<a name="ln43"> </a>
<a name="ln44">extern fssh_file_system_module_info gRootFileSystem;</a>
<a name="ln45"> </a>
<a name="ln46">namespace FSShell {</a>
<a name="ln47"> </a>
<a name="ln48">const char* kMountPoint = &quot;/myfs&quot;;</a>
<a name="ln49"> </a>
<a name="ln50">// command line args</a>
<a name="ln51">static	int					sArgc;</a>
<a name="ln52">static	const char* const*	sArgv;</a>
<a name="ln53"> </a>
<a name="ln54">static mode_t sUmask = 0022;</a>
<a name="ln55"> </a>
<a name="ln56"> </a>
<a name="ln57">static fssh_status_t</a>
<a name="ln58">init_kernel()</a>
<a name="ln59">{</a>
<a name="ln60">	fssh_status_t error;</a>
<a name="ln61"> </a>
<a name="ln62">	// init module subsystem</a>
<a name="ln63">	error = module_init(NULL);</a>
<a name="ln64">	if (error != FSSH_B_OK) {</a>
<a name="ln65">		fprintf(stderr, &quot;module_init() failed: %s\n&quot;, fssh_strerror(error));</a>
<a name="ln66">		return error;</a>
<a name="ln67">	}</a>
<a name="ln68"> </a>
<a name="ln69">	// init driver settings</a>
<a name="ln70">	error = driver_settings_init();</a>
<a name="ln71">	if (error != FSSH_B_OK) {</a>
<a name="ln72">		fprintf(stderr, &quot;initializing driver settings failed: %s\n&quot;,</a>
<a name="ln73">			fssh_strerror(error));</a>
<a name="ln74">		return error;</a>
<a name="ln75">	}</a>
<a name="ln76"> </a>
<a name="ln77">	// register built-in modules, i.e. the rootfs and the client FS</a>
<a name="ln78">	register_builtin_module(&amp;gRootFileSystem.info);</a>
<a name="ln79">	for (int i = 0; modules[i]; i++)</a>
<a name="ln80">		register_builtin_module(modules[i]);</a>
<a name="ln81"> </a>
<a name="ln82">	// init VFS</a>
<a name="ln83">	error = vfs_init(NULL);</a>
<a name="ln84">	if (error != FSSH_B_OK) {</a>
<a name="ln85">		fprintf(stderr, &quot;initializing VFS failed: %s\n&quot;, fssh_strerror(error));</a>
<a name="ln86">		return error;</a>
<a name="ln87">	}</a>
<a name="ln88"> </a>
<a name="ln89">	// init kernel IO context</a>
<a name="ln90">	gKernelIOContext = (io_context*)vfs_new_io_context(NULL);</a>
<a name="ln91">	if (!gKernelIOContext) {</a>
<a name="ln92">		fprintf(stderr, &quot;creating IO context failed!\n&quot;);</a>
<a name="ln93">		return FSSH_B_NO_MEMORY;</a>
<a name="ln94">	}</a>
<a name="ln95"> </a>
<a name="ln96">	// mount root FS</a>
<a name="ln97">	fssh_dev_t rootDev = _kern_mount(&quot;/&quot;, NULL, &quot;rootfs&quot;, 0, NULL, 0);</a>
<a name="ln98">	if (rootDev &lt; 0) {</a>
<a name="ln99">		fprintf(stderr, &quot;mounting rootfs failed: %s\n&quot;, fssh_strerror(rootDev));</a>
<a name="ln100">		return rootDev;</a>
<a name="ln101">	}</a>
<a name="ln102"> </a>
<a name="ln103">	// set cwd to &quot;/&quot;</a>
<a name="ln104">	error = _kern_setcwd(-1, &quot;/&quot;);</a>
<a name="ln105">	if (error != FSSH_B_OK) {</a>
<a name="ln106">		fprintf(stderr, &quot;setting cwd failed: %s\n&quot;, fssh_strerror(error));</a>
<a name="ln107">		return error;</a>
<a name="ln108">	}</a>
<a name="ln109"> </a>
<a name="ln110">	// create mount point for the client FS</a>
<a name="ln111">	error = _kern_create_dir(-1, kMountPoint, 0775);</a>
<a name="ln112">	if (error != FSSH_B_OK) {</a>
<a name="ln113">		fprintf(stderr, &quot;creating mount point failed: %s\n&quot;,</a>
<a name="ln114">			fssh_strerror(error));</a>
<a name="ln115">		return error;</a>
<a name="ln116">	}</a>
<a name="ln117"> </a>
<a name="ln118">	return FSSH_B_OK;</a>
<a name="ln119">}</a>
<a name="ln120"> </a>
<a name="ln121"> </a>
<a name="ln122">// #pragma mark - Command</a>
<a name="ln123"> </a>
<a name="ln124">Command::Command(const char* name, const char* description)</a>
<a name="ln125">	: fName(name),</a>
<a name="ln126">	  fDescription(description)</a>
<a name="ln127">{</a>
<a name="ln128">}</a>
<a name="ln129"> </a>
<a name="ln130"> </a>
<a name="ln131">Command::Command(command_function* function, const char* name,</a>
<a name="ln132">	const char* description)</a>
<a name="ln133">	: fName(name),</a>
<a name="ln134">	  fDescription(description),</a>
<a name="ln135">	  fFunction(function)</a>
<a name="ln136">{</a>
<a name="ln137">}</a>
<a name="ln138"> </a>
<a name="ln139"> </a>
<a name="ln140">Command::~Command()</a>
<a name="ln141">{</a>
<a name="ln142">}</a>
<a name="ln143"> </a>
<a name="ln144"> </a>
<a name="ln145">const char*</a>
<a name="ln146">Command::Name() const</a>
<a name="ln147">{</a>
<a name="ln148">	return fName.c_str();</a>
<a name="ln149">}</a>
<a name="ln150"> </a>
<a name="ln151"> </a>
<a name="ln152">const char*</a>
<a name="ln153">Command::Description() const</a>
<a name="ln154">{</a>
<a name="ln155">	return fDescription.c_str();</a>
<a name="ln156">}</a>
<a name="ln157"> </a>
<a name="ln158"> </a>
<a name="ln159">fssh_status_t</a>
<a name="ln160">Command::Do(int argc, const char* const* argv)</a>
<a name="ln161">{</a>
<a name="ln162">	if (!fFunction) {</a>
<a name="ln163">		fprintf(stderr, &quot;No function given for command \&quot;%s\&quot;\n&quot;, Name());</a>
<a name="ln164">		return FSSH_B_BAD_VALUE;</a>
<a name="ln165">	}</a>
<a name="ln166"> </a>
<a name="ln167">	return (*fFunction)(argc, argv);</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170"> </a>
<a name="ln171">// #pragma mark - CommandManager</a>
<a name="ln172"> </a>
<a name="ln173">CommandManager::CommandManager()</a>
<a name="ln174">{</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177"> </a>
<a name="ln178">CommandManager*</a>
<a name="ln179">CommandManager::Default()</a>
<a name="ln180">{</a>
<a name="ln181">	if (!sManager)</a>
<a name="ln182">		sManager = new CommandManager;</a>
<a name="ln183">	return sManager;</a>
<a name="ln184">}</a>
<a name="ln185"> </a>
<a name="ln186"> </a>
<a name="ln187">void</a>
<a name="ln188">CommandManager::AddCommand(Command* command)</a>
<a name="ln189">{</a>
<a name="ln190">	// The command name may consist of several aliases. Split them and</a>
<a name="ln191">	// register the command for each of them.</a>
<a name="ln192">	char _names[1024];</a>
<a name="ln193">	char* names = _names;</a>
<a name="ln194">	strcpy(names, command-&gt;Name());</a>
<a name="ln195"> </a>
<a name="ln196">	char* cookie;</a>
<a name="ln197">	while (char* name = strtok_r(names, &quot; /&quot;, &amp;cookie)) {</a>
<a name="ln198">		fCommands[name] = command;</a>
<a name="ln199">		names = NULL;</a>
<a name="ln200">	}</a>
<a name="ln201">}</a>
<a name="ln202"> </a>
<a name="ln203"> </a>
<a name="ln204">void</a>
<a name="ln205">CommandManager::AddCommand(command_function* function, const char* name,</a>
<a name="ln206">	const char* description)</a>
<a name="ln207">{</a>
<a name="ln208">	AddCommand(new Command(function, name, description));</a>
<a name="ln209">}</a>
<a name="ln210"> </a>
<a name="ln211"> </a>
<a name="ln212">void</a>
<a name="ln213">CommandManager::AddCommands(command_function* function, const char* name,</a>
<a name="ln214">	const char* description, ...)</a>
<a name="ln215">{</a>
<a name="ln216">	va_list args;</a>
<a name="ln217">	va_start(args, description);</a>
<a name="ln218"> </a>
<a name="ln219">	while (function) {</a>
<a name="ln220">		AddCommand(function, name, description);</a>
<a name="ln221"> </a>
<a name="ln222">		function = va_arg(args, command_function*);</a>
<a name="ln223">		if (function) {</a>
<a name="ln224">			name = va_arg(args, const char*);</a>
<a name="ln225">			description = va_arg(args, const char*);</a>
<a name="ln226">		}</a>
<a name="ln227">	}</a>
<a name="ln228"> </a>
<a name="ln229">	va_end(args);</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232"> </a>
<a name="ln233">Command*</a>
<a name="ln234">CommandManager::FindCommand(const char* name) const</a>
<a name="ln235">{</a>
<a name="ln236">	CommandMap::const_iterator it = fCommands.find(name);</a>
<a name="ln237">	if (it == fCommands.end())</a>
<a name="ln238">		return NULL;</a>
<a name="ln239"> </a>
<a name="ln240">	return it-&gt;second;</a>
<a name="ln241">}</a>
<a name="ln242"> </a>
<a name="ln243"> </a>
<a name="ln244">void</a>
<a name="ln245">CommandManager::ListCommands() const</a>
<a name="ln246">{</a>
<a name="ln247">	for (CommandMap::const_iterator it = fCommands.begin();</a>
<a name="ln248">			it != fCommands.end(); ++it) {</a>
<a name="ln249">		const char* name = it-&gt;first.c_str();</a>
<a name="ln250">		Command* command = it-&gt;second;</a>
<a name="ln251">		printf(&quot;%-16s - %s\n&quot;, name, command-&gt;Description());</a>
<a name="ln252">	}</a>
<a name="ln253">}</a>
<a name="ln254"> </a>
<a name="ln255"> </a>
<a name="ln256">CommandManager*	CommandManager::sManager = NULL;</a>
<a name="ln257"> </a>
<a name="ln258"> </a>
<a name="ln259">// #pragma mark - Command support functions</a>
<a name="ln260"> </a>
<a name="ln261"> </a>
<a name="ln262">static bool</a>
<a name="ln263">get_permissions(const char* modeString, fssh_mode_t&amp; _permissions)</a>
<a name="ln264">{</a>
<a name="ln265">	// currently only octal mode is supported</a>
<a name="ln266">	if (strlen(modeString) != 3)</a>
<a name="ln267">		return false;</a>
<a name="ln268"> </a>
<a name="ln269">	fssh_mode_t permissions = 0;</a>
<a name="ln270">	for (int i = 0; i &lt; 3; i++) {</a>
<a name="ln271">		char c = modeString[i];</a>
<a name="ln272">		if (c &lt; '0' || c &gt; '7')</a>
<a name="ln273">			return false;</a>
<a name="ln274">		permissions = (permissions &lt;&lt; 3) | (c - '0');</a>
<a name="ln275">	}</a>
<a name="ln276"> </a>
<a name="ln277">	_permissions = permissions;</a>
<a name="ln278">	return true;</a>
<a name="ln279">}</a>
<a name="ln280"> </a>
<a name="ln281"> </a>
<a name="ln282">static fssh_dev_t</a>
<a name="ln283">get_volume_id()</a>
<a name="ln284">{</a>
<a name="ln285">	struct fssh_stat st;</a>
<a name="ln286">	fssh_status_t error = _kern_read_stat(-1, kMountPoint, false, &amp;st,</a>
<a name="ln287">		sizeof(st));</a>
<a name="ln288">	if (error != FSSH_B_OK) {</a>
<a name="ln289">		fprintf(stderr, &quot;Error: Failed to stat() mount point: %s\n&quot;,</a>
<a name="ln290">			fssh_strerror(error));</a>
<a name="ln291">		return error;</a>
<a name="ln292">	}</a>
<a name="ln293"> </a>
<a name="ln294">	return st.fssh_st_dev;</a>
<a name="ln295">}</a>
<a name="ln296"> </a>
<a name="ln297"> </a>
<a name="ln298">static const char *</a>
<a name="ln299">byte_string(int64_t numBlocks, int64_t blockSize)</a>
<a name="ln300">{</a>
<a name="ln301">	double blocks = 1. * numBlocks * blockSize;</a>
<a name="ln302">	static char string[64];</a>
<a name="ln303"> </a>
<a name="ln304">	if (blocks &lt; 1024)</a>
<a name="ln305">		sprintf(string, &quot;%&quot; FSSH_B_PRId64, numBlocks * blockSize);</a>
<a name="ln306">	else {</a>
<a name="ln307">		const char* units[] = {&quot;K&quot;, &quot;M&quot;, &quot;G&quot;, NULL};</a>
<a name="ln308">		int i = -1;</a>
<a name="ln309"> </a>
<a name="ln310">		do {</a>
<a name="ln311">			blocks /= 1024.0;</a>
<a name="ln312">			i++;</a>
<a name="ln313">		} while (blocks &gt;= 1024 &amp;&amp; units[i + 1]);</a>
<a name="ln314"> </a>
<a name="ln315">		sprintf(string, &quot;%.1f%s&quot;, blocks, units[i]);</a>
<a name="ln316">	}</a>
<a name="ln317"> </a>
<a name="ln318">	return string;</a>
<a name="ln319">}</a>
<a name="ln320"> </a>
<a name="ln321"> </a>
<a name="ln322">void</a>
<a name="ln323">print_flag(uint32_t deviceFlags, uint32_t testFlag, const char *yes,</a>
<a name="ln324">	const char *no)</a>
<a name="ln325">{</a>
<a name="ln326">	printf(&quot;%s&quot;, (deviceFlags &amp; testFlag) != 0 ? yes : no);</a>
<a name="ln327">}</a>
<a name="ln328"> </a>
<a name="ln329"> </a>
<a name="ln330">static void</a>
<a name="ln331">list_entry(const char* file, const char* name = NULL)</a>
<a name="ln332">{</a>
<a name="ln333">	// construct path, if a leaf name is given</a>
<a name="ln334">	std::string path;</a>
<a name="ln335">	if (name) {</a>
<a name="ln336">		path = file;</a>
<a name="ln337">		path += '/';</a>
<a name="ln338">		path += name;</a>
<a name="ln339">		file = path.c_str();</a>
<a name="ln340">	} else</a>
<a name="ln341">		name = file;</a>
<a name="ln342"> </a>
<a name="ln343">	// stat the file</a>
<a name="ln344">	struct fssh_stat st;</a>
<a name="ln345">	fssh_status_t error = _kern_read_stat(-1, file, false, &amp;st, sizeof(st));</a>
<a name="ln346">	if (error != FSSH_B_OK) {</a>
<a name="ln347">		fprintf(stderr, &quot;Error: Failed to stat() \&quot;%s\&quot;: %s\n&quot;, file,</a>
<a name="ln348">			fssh_strerror(error));</a>
<a name="ln349">		return;</a>
<a name="ln350">	}</a>
<a name="ln351"> </a>
<a name="ln352">	// get time</a>
<a name="ln353">	struct tm time;</a>
<a name="ln354">	time_t fileTime = st.fssh_st_mtime;</a>
<a name="ln355">	localtime_r(&amp;fileTime, &amp;time);</a>
<a name="ln356"> </a>
<a name="ln357">	// get permissions</a>
<a name="ln358">	std::string permissions;</a>
<a name="ln359">	fssh_mode_t mode = st.fssh_st_mode;</a>
<a name="ln360">	// user</a>
<a name="ln361">	permissions += ((mode &amp; FSSH_S_IRUSR) ? 'r' : '-');</a>
<a name="ln362">	permissions += ((mode &amp; FSSH_S_IWUSR) ? 'w' : '-');</a>
<a name="ln363">	if (mode &amp; FSSH_S_ISUID)</a>
<a name="ln364">		permissions += 's';</a>
<a name="ln365">	else</a>
<a name="ln366">		permissions += ((mode &amp; FSSH_S_IXUSR) ? 'x' : '-');</a>
<a name="ln367">	// group</a>
<a name="ln368">	permissions += ((mode &amp; FSSH_S_IRGRP) ? 'r' : '-');</a>
<a name="ln369">	permissions += ((mode &amp; FSSH_S_IWGRP) ? 'w' : '-');</a>
<a name="ln370">	if (mode &amp; FSSH_S_ISGID)</a>
<a name="ln371">		permissions += 's';</a>
<a name="ln372">	else</a>
<a name="ln373">		permissions += ((mode &amp; FSSH_S_IXGRP) ? 'x' : '-');</a>
<a name="ln374">	// others</a>
<a name="ln375">	permissions += ((mode &amp; FSSH_S_IROTH) ? 'r' : '-');</a>
<a name="ln376">	permissions += ((mode &amp; FSSH_S_IWOTH) ? 'w' : '-');</a>
<a name="ln377">	permissions += ((mode &amp; FSSH_S_IXOTH) ? 'x' : '-');</a>
<a name="ln378"> </a>
<a name="ln379">	// get file type</a>
<a name="ln380">	char fileType = '?';</a>
<a name="ln381">	if (FSSH_S_ISREG(mode)) {</a>
<a name="ln382">		fileType = '-';</a>
<a name="ln383">	} else if (FSSH_S_ISLNK(mode)) {</a>
<a name="ln384">		fileType = 'l';</a>
<a name="ln385">	} else if (FSSH_S_ISBLK(mode)) {</a>
<a name="ln386">		fileType = 'b';</a>
<a name="ln387">	} else if (FSSH_S_ISDIR(mode)) {</a>
<a name="ln388">		fileType = 'd';</a>
<a name="ln389">	} else if (FSSH_S_ISCHR(mode)) {</a>
<a name="ln390">		fileType = 'c';</a>
<a name="ln391">	} else if (FSSH_S_ISFIFO(mode)) {</a>
<a name="ln392">		fileType = 'f';</a>
<a name="ln393">	} else if (FSSH_S_ISINDEX(mode)) {</a>
<a name="ln394">		fileType = 'i';</a>
<a name="ln395">	}</a>
<a name="ln396"> </a>
<a name="ln397">	// get link target</a>
<a name="ln398">	std::string nameSuffix;</a>
<a name="ln399">	if (FSSH_S_ISLNK(mode)) {</a>
<a name="ln400">		char buffer[FSSH_B_PATH_NAME_LENGTH];</a>
<a name="ln401">		fssh_size_t size = sizeof(buffer) - 1;</a>
<a name="ln402">		error = _kern_read_link(-1, file, buffer, &amp;size);</a>
<a name="ln403">		if (error != FSSH_B_OK)</a>
<a name="ln404">			snprintf(buffer, sizeof(buffer), &quot;(%s)&quot;, fssh_strerror(error));</a>
<a name="ln405"> </a>
<a name="ln406">		buffer[size] = '\0';</a>
<a name="ln407">		nameSuffix += &quot; -&gt; &quot;;</a>
<a name="ln408">		nameSuffix += buffer;</a>
<a name="ln409">	}</a>
<a name="ln410"> </a>
<a name="ln411">	printf(&quot;%c%s %2d %2d %10&quot; FSSH_B_PRIdOFF</a>
<a name="ln412">		&quot; %d-%02d-%02d %02d:%02d:%02d %s%s\n&quot;,</a>
<a name="ln413">		fileType, permissions.c_str(), (int)st.fssh_st_uid, (int)st.fssh_st_gid,</a>
<a name="ln414">		st.fssh_st_size,</a>
<a name="ln415">		1900 + time.tm_year, 1 + time.tm_mon, time.tm_mday,</a>
<a name="ln416">		time.tm_hour, time.tm_min, time.tm_sec,</a>
<a name="ln417">		name, nameSuffix.c_str());</a>
<a name="ln418">}</a>
<a name="ln419"> </a>
<a name="ln420"> </a>
<a name="ln421">static fssh_status_t</a>
<a name="ln422">create_dir(const char *path, bool createParents)</a>
<a name="ln423">{</a>
<a name="ln424">	// stat the entry</a>
<a name="ln425">	struct fssh_stat st;</a>
<a name="ln426">	fssh_status_t error = _kern_read_stat(-1, path, false, &amp;st, sizeof(st));</a>
<a name="ln427">	if (error == FSSH_B_OK) {</a>
<a name="ln428">		if (createParents &amp;&amp; FSSH_S_ISDIR(st.fssh_st_mode))</a>
<a name="ln429">			return FSSH_B_OK;</a>
<a name="ln430"> </a>
<a name="ln431">		fprintf(stderr, &quot;Error: Cannot make dir, entry \&quot;%s\&quot; is in the way.\n&quot;,</a>
<a name="ln432">			path);</a>
<a name="ln433">		return FSSH_B_FILE_EXISTS;</a>
<a name="ln434">	}</a>
<a name="ln435"> </a>
<a name="ln436">	// the dir doesn't exist yet</a>
<a name="ln437">	// if we shall create all parents, do that first</a>
<a name="ln438">	if (createParents) {</a>
<a name="ln439">		// create the parent dir path</a>
<a name="ln440">		// eat the trailing '/'s</a>
<a name="ln441">		int len = strlen(path);</a>
<a name="ln442">		while (len &gt; 0 &amp;&amp; path[len - 1] == '/')</a>
<a name="ln443">			len--;</a>
<a name="ln444"> </a>
<a name="ln445">		// eat the last path component</a>
<a name="ln446">		while (len &gt; 0 &amp;&amp; path[len - 1] != '/')</a>
<a name="ln447">			len--;</a>
<a name="ln448"> </a>
<a name="ln449">		// eat the trailing '/'s</a>
<a name="ln450">		while (len &gt; 0 &amp;&amp; path[len - 1] == '/')</a>
<a name="ln451">			len--;</a>
<a name="ln452"> </a>
<a name="ln453">		// Now either nothing remains, which means we had a single component,</a>
<a name="ln454">		// a root subdir -- in those cases we can just fall through (we should</a>
<a name="ln455">		// actually never be here in case of the root dir, but anyway) -- or</a>
<a name="ln456">		// there is something left, which we can call a parent directory and</a>
<a name="ln457">		// try to create it.</a>
<a name="ln458">		if (len &gt; 0) {</a>
<a name="ln459">			char *parentPath = (char*)malloc(len + 1);</a>
<a name="ln460">			if (!parentPath) {</a>
<a name="ln461">				fprintf(stderr, &quot;Error: Failed to allocate memory for parent &quot;</a>
<a name="ln462">					&quot;path.\n&quot;);</a>
<a name="ln463">				return FSSH_B_NO_MEMORY;</a>
<a name="ln464">			}</a>
<a name="ln465">			memcpy(parentPath, path, len);</a>
<a name="ln466">			parentPath[len] = '\0';</a>
<a name="ln467"> </a>
<a name="ln468">			error = create_dir(parentPath, createParents);</a>
<a name="ln469"> </a>
<a name="ln470">			free(parentPath);</a>
<a name="ln471"> </a>
<a name="ln472">			if (error != FSSH_B_OK)</a>
<a name="ln473">				return error;</a>
<a name="ln474">		}</a>
<a name="ln475">	}</a>
<a name="ln476"> </a>
<a name="ln477">	// make the directory</a>
<a name="ln478">	error = _kern_create_dir(-1,</a>
<a name="ln479">		path, (FSSH_S_IRWXU | FSSH_S_IRWXG | FSSH_S_IRWXO) &amp; ~sUmask);</a>
<a name="ln480">	if (error != FSSH_B_OK) {</a>
<a name="ln481">		fprintf(stderr, &quot;Error: Failed to make directory \&quot;%s\&quot;: %s\n&quot;, path,</a>
<a name="ln482">			fssh_strerror(error));</a>
<a name="ln483">		return error;</a>
<a name="ln484">	}</a>
<a name="ln485"> </a>
<a name="ln486">	return FSSH_B_OK;</a>
<a name="ln487">}</a>
<a name="ln488"> </a>
<a name="ln489"> </a>
<a name="ln490">static fssh_status_t remove_entry(int dir, const char *entry, bool recursive,</a>
<a name="ln491">	bool force);</a>
<a name="ln492"> </a>
<a name="ln493"> </a>
<a name="ln494">static fssh_status_t</a>
<a name="ln495">remove_dir_contents(int parentDir, const char *name, bool force)</a>
<a name="ln496">{</a>
<a name="ln497">	// open the dir</a>
<a name="ln498">	int dir = _kern_open_dir(parentDir, name);</a>
<a name="ln499">	if (dir &lt; 0) {</a>
<a name="ln500">		fprintf(stderr, &quot;Error: Failed to open dir \&quot;%s\&quot;: %s\n&quot;, name,</a>
<a name="ln501">			fssh_strerror(dir));</a>
<a name="ln502">		return dir;</a>
<a name="ln503">	}</a>
<a name="ln504"> </a>
<a name="ln505">	fssh_status_t error = FSSH_B_OK;</a>
<a name="ln506"> </a>
<a name="ln507">	// iterate through the entries</a>
<a name="ln508">	fssh_ssize_t numRead;</a>
<a name="ln509">	char buffer[sizeof(fssh_dirent) + FSSH_B_FILE_NAME_LENGTH];</a>
<a name="ln510">	fssh_dirent *entry = (fssh_dirent*)buffer;</a>
<a name="ln511">	while ((numRead = _kern_read_dir(dir, entry, sizeof(buffer), 1)) &gt; 0) {</a>
<a name="ln512">		// skip &quot;.&quot; and &quot;..&quot;</a>
<a name="ln513">		if (strcmp(entry-&gt;d_name, &quot;.&quot;) == 0 || strcmp(entry-&gt;d_name, &quot;..&quot;) == 0)</a>
<a name="ln514">			continue;</a>
<a name="ln515"> </a>
<a name="ln516">		error = remove_entry(dir, entry-&gt;d_name, true, force);</a>
<a name="ln517">		if (error != FSSH_B_OK)</a>
<a name="ln518">			break;</a>
<a name="ln519">	}</a>
<a name="ln520"> </a>
<a name="ln521">	if (numRead &lt; 0) {</a>
<a name="ln522">		fprintf(stderr, &quot;Error: Failed to read directory \&quot;%s\&quot;: %s\n&quot;, name,</a>
<a name="ln523">			fssh_strerror(numRead));</a>
<a name="ln524">		error = numRead;</a>
<a name="ln525">	}</a>
<a name="ln526"> </a>
<a name="ln527">	// close</a>
<a name="ln528">	_kern_close(dir);</a>
<a name="ln529"> </a>
<a name="ln530">	return error;</a>
<a name="ln531">}</a>
<a name="ln532"> </a>
<a name="ln533"> </a>
<a name="ln534">static fssh_status_t</a>
<a name="ln535">remove_entry(int dir, const char *entry, bool recursive, bool force)</a>
<a name="ln536">{</a>
<a name="ln537">	// stat the file</a>
<a name="ln538">	struct fssh_stat st;</a>
<a name="ln539">	fssh_status_t error = _kern_read_stat(dir, entry, false, &amp;st, sizeof(st));</a>
<a name="ln540">	if (error != FSSH_B_OK) {</a>
<a name="ln541">		if (force &amp;&amp; error == FSSH_B_ENTRY_NOT_FOUND)</a>
<a name="ln542">			return FSSH_B_OK;</a>
<a name="ln543"> </a>
<a name="ln544">		fprintf(stderr, &quot;Error: Failed to remove \&quot;%s\&quot;: %s\n&quot;, entry,</a>
<a name="ln545">			fssh_strerror(error));</a>
<a name="ln546">		return error;</a>
<a name="ln547">	}</a>
<a name="ln548"> </a>
<a name="ln549">	if (FSSH_S_ISDIR(st.fssh_st_mode)) {</a>
<a name="ln550">		if (!recursive) {</a>
<a name="ln551">			fprintf(stderr, &quot;Error: \&quot;%s\&quot; is a directory.\n&quot;, entry);</a>
<a name="ln552">				// TODO: get the full path</a>
<a name="ln553">			return FSSH_EISDIR;</a>
<a name="ln554">		}</a>
<a name="ln555"> </a>
<a name="ln556">		// remove the contents</a>
<a name="ln557">		error = remove_dir_contents(dir, entry, force);</a>
<a name="ln558">		if (error != FSSH_B_OK)</a>
<a name="ln559">			return error;</a>
<a name="ln560"> </a>
<a name="ln561">		// remove the directory</a>
<a name="ln562">		error = _kern_remove_dir(dir, entry);</a>
<a name="ln563">		if (error != FSSH_B_OK) {</a>
<a name="ln564">			fprintf(stderr, &quot;Error: Failed to remove directory \&quot;%s\&quot;: %s\n&quot;,</a>
<a name="ln565">				entry, fssh_strerror(error));</a>
<a name="ln566">			return error;</a>
<a name="ln567">		}</a>
<a name="ln568">	} else {</a>
<a name="ln569">		// remove the entry</a>
<a name="ln570">		error = _kern_unlink(dir, entry);</a>
<a name="ln571">		if (error != FSSH_B_OK) {</a>
<a name="ln572">			fprintf(stderr, &quot;Error: Failed to remove entry \&quot;%s\&quot;: %s\n&quot;, entry,</a>
<a name="ln573">				fssh_strerror(error));</a>
<a name="ln574">			return error;</a>
<a name="ln575">		}</a>
<a name="ln576">	}</a>
<a name="ln577"> </a>
<a name="ln578">	return FSSH_B_OK;</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581"> </a>
<a name="ln582">static fssh_status_t</a>
<a name="ln583">move_entry(int dir, const char *entry, int targetDir, const char* target,</a>
<a name="ln584">	bool force)</a>
<a name="ln585">{</a>
<a name="ln586">	// stat the file</a>
<a name="ln587">	struct fssh_stat st;</a>
<a name="ln588">	fssh_status_t status = _kern_read_stat(dir, entry, false, &amp;st, sizeof(st));</a>
<a name="ln589">	if (status != FSSH_B_OK) {</a>
<a name="ln590">		if (force &amp;&amp; status == FSSH_B_ENTRY_NOT_FOUND)</a>
<a name="ln591">			return FSSH_B_OK;</a>
<a name="ln592"> </a>
<a name="ln593">		fprintf(stderr, &quot;Error: Failed to move \&quot;%s\&quot;: %s\n&quot;, entry,</a>
<a name="ln594">			fssh_strerror(status));</a>
<a name="ln595">		return status;</a>
<a name="ln596">	}</a>
<a name="ln597"> </a>
<a name="ln598">	return _kern_rename(dir, entry, targetDir, target);</a>
<a name="ln599">}</a>
<a name="ln600"> </a>
<a name="ln601"> </a>
<a name="ln602">// #pragma mark - Commands</a>
<a name="ln603"> </a>
<a name="ln604"> </a>
<a name="ln605">static fssh_status_t</a>
<a name="ln606">command_cd(int argc, const char* const* argv)</a>
<a name="ln607">{</a>
<a name="ln608">	if (argc != 2) {</a>
<a name="ln609">		fprintf(stderr, &quot;Usage: %s &lt;directory&gt;\n&quot;, argv[0]);</a>
<a name="ln610">		return FSSH_B_BAD_VALUE;</a>
<a name="ln611">	}</a>
<a name="ln612">	const char* directory = argv[1];</a>
<a name="ln613"> </a>
<a name="ln614">	fssh_status_t error = FSSH_B_OK;</a>
<a name="ln615">	if (directory[0] == ':') {</a>
<a name="ln616">		if (chdir(directory + 1) &lt; 0)</a>
<a name="ln617">			error = fssh_get_errno();</a>
<a name="ln618">	} else</a>
<a name="ln619">		error = _kern_setcwd(-1, directory);</a>
<a name="ln620"> </a>
<a name="ln621">	if (error != FSSH_B_OK) {</a>
<a name="ln622">		fprintf(stderr, &quot;Error: cd %s: %s\n&quot;, directory, fssh_strerror(error));</a>
<a name="ln623">		return error;</a>
<a name="ln624">	}</a>
<a name="ln625"> </a>
<a name="ln626">	return FSSH_B_OK;</a>
<a name="ln627">}</a>
<a name="ln628"> </a>
<a name="ln629"> </a>
<a name="ln630">static fssh_status_t</a>
<a name="ln631">command_chmod(int argc, const char* const* argv)</a>
<a name="ln632">{</a>
<a name="ln633">	bool recursive = false;</a>
<a name="ln634"> </a>
<a name="ln635">	// parse parameters</a>
<a name="ln636">	int argi = 1;</a>
<a name="ln637">	for (argi = 1; argi &lt; argc; argi++) {</a>
<a name="ln638">		const char *arg = argv[argi];</a>
<a name="ln639">		if (arg[0] != '-')</a>
<a name="ln640">			break;</a>
<a name="ln641"> </a>
<a name="ln642">		if (arg[1] == '\0') {</a>
<a name="ln643">			fprintf(stderr, &quot;Error: Invalid option \&quot;-\&quot;\n&quot;);</a>
<a name="ln644">			return FSSH_B_BAD_VALUE;</a>
<a name="ln645">		}</a>
<a name="ln646"> </a>
<a name="ln647">		for (int i = 1; arg[i]; i++) {</a>
<a name="ln648">			switch (arg[i]) {</a>
<a name="ln649">				case 'R':</a>
<a name="ln650">					recursive = true;</a>
<a name="ln651">					fprintf(stderr, &quot;Sorry, recursive mode not supported &quot;</a>
<a name="ln652">						&quot;yet.\n&quot;);</a>
<a name="ln653">					return FSSH_B_BAD_VALUE;</a>
<a name="ln654">				default:</a>
<a name="ln655">					fprintf(stderr, &quot;Error: Unknown option \&quot;-%c\&quot;\n&quot;, arg[i]);</a>
<a name="ln656">					return FSSH_B_BAD_VALUE;</a>
<a name="ln657">			}</a>
<a name="ln658">		}</a>
<a name="ln659">	}</a>
<a name="ln660"> </a>
<a name="ln661">	// get mode</a>
<a name="ln662">	fssh_mode_t permissions;</a>
<a name="ln663">	if (argi + 1 &gt;= argc || !get_permissions(argv[argi++], permissions)) {</a>
<a name="ln664">		printf(&quot;Usage: %s [ -R ] &lt;octal mode&gt; &lt;file&gt;...\n&quot;, argv[0]);</a>
<a name="ln665">		return FSSH_B_BAD_VALUE;</a>
<a name="ln666">	}</a>
<a name="ln667"> </a>
<a name="ln668">	fssh_struct_stat st;</a>
<a name="ln669">	st.fssh_st_mode = permissions;</a>
<a name="ln670"> </a>
<a name="ln671">	// chmod loop</a>
<a name="ln672">	for (; argi &lt; argc; argi++) {</a>
<a name="ln673">		const char *file = argv[argi];</a>
<a name="ln674">		if (strlen(file) == 0) {</a>
<a name="ln675">			fprintf(stderr, &quot;Error: An empty path is not a valid argument!\n&quot;);</a>
<a name="ln676">			return FSSH_B_BAD_VALUE;</a>
<a name="ln677">		}</a>
<a name="ln678"> </a>
<a name="ln679">		fssh_status_t error = _kern_write_stat(-1, file, false, &amp;st, sizeof(st),</a>
<a name="ln680">			FSSH_B_STAT_MODE);</a>
<a name="ln681">		if (error != FSSH_B_OK) {</a>
<a name="ln682">			fprintf(stderr, &quot;Error: Failed to change mode of \&quot;%s\&quot;!\n&quot;, file);</a>
<a name="ln683">			return error;</a>
<a name="ln684">		}</a>
<a name="ln685">	}</a>
<a name="ln686"> </a>
<a name="ln687">	return FSSH_B_OK;</a>
<a name="ln688">}</a>
<a name="ln689"> </a>
<a name="ln690"> </a>
<a name="ln691">static fssh_status_t</a>
<a name="ln692">command_cat(int argc, const char* const* argv)</a>
<a name="ln693">{</a>
<a name="ln694">	size_t numBytes = 10;</a>
<a name="ln695">	int fileStart = 1;</a>
<a name="ln696">	if (argc &lt; 2 || strcmp(argv[1], &quot;--help&quot;) == 0) {</a>
<a name="ln697">		printf(&quot;Usage: %s [ -n ] [FILE]...\n&quot;</a>
<a name="ln698">			&quot;\t -n\tNumber of bytes to read\n&quot;,</a>
<a name="ln699">			argv[0]);</a>
<a name="ln700">		return FSSH_B_OK;</a>
<a name="ln701">	}</a>
<a name="ln702"> </a>
<a name="ln703">	if (argc &gt; 3 &amp;&amp; strcmp(argv[1], &quot;-n&quot;) == 0) {</a>
<a name="ln704">		fileStart += 2;</a>
<a name="ln705">		numBytes = strtol(argv[2], NULL, 10);</a>
<a name="ln706">	}</a>
<a name="ln707"> </a>
<a name="ln708">	const char* const* files = argv + fileStart;</a>
<a name="ln709">	for (; *files; files++) {</a>
<a name="ln710">		const char* file = *files;</a>
<a name="ln711">		int fd = _kern_open(-1, file, FSSH_O_RDONLY, FSSH_O_RDONLY);</a>
<a name="ln712">		if (fd &lt; 0) {</a>
<a name="ln713">			fprintf(stderr, &quot;error: %s\n&quot;, fssh_strerror(fd));</a>
<a name="ln714">			return FSSH_B_BAD_VALUE;</a>
<a name="ln715">		}</a>
<a name="ln716"> </a>
<a name="ln717">		char buffer[numBytes + 1];</a>
<a name="ln718">		if (buffer == NULL) {</a>
<a name="ln719">			fprintf(stderr, &quot;error: No memory\n&quot;);</a>
<a name="ln720">			_kern_close(fd);</a>
<a name="ln721">			return FSSH_B_NO_MEMORY;</a>
<a name="ln722">		}</a>
<a name="ln723"> </a>
<a name="ln724">		if (_kern_read(fd, 0, buffer, numBytes) != (ssize_t)numBytes) {</a>
<a name="ln725">			fprintf(stderr, &quot;error reading: %s\n&quot;, fssh_strerror(fd));</a>
<a name="ln726">			_kern_close(fd);</a>
<a name="ln727">			return FSSH_B_BAD_VALUE;</a>
<a name="ln728">		}</a>
<a name="ln729"> </a>
<a name="ln730">		_kern_close(fd);</a>
<a name="ln731">		buffer[numBytes] = '\0';</a>
<a name="ln732">		printf(&quot;%s\n&quot;, buffer);</a>
<a name="ln733">	}</a>
<a name="ln734"> </a>
<a name="ln735">	return FSSH_B_OK;</a>
<a name="ln736">}</a>
<a name="ln737"> </a>
<a name="ln738"> </a>
<a name="ln739">static fssh_status_t</a>
<a name="ln740">command_help(int argc, const char* const* argv)</a>
<a name="ln741">{</a>
<a name="ln742">	printf(&quot;supported commands:\n&quot;);</a>
<a name="ln743">	CommandManager::Default()-&gt;ListCommands();</a>
<a name="ln744">	return FSSH_B_OK;</a>
<a name="ln745">}</a>
<a name="ln746"> </a>
<a name="ln747"> </a>
<a name="ln748">static fssh_status_t</a>
<a name="ln749">command_info(int argc, const char* const* argv)</a>
<a name="ln750">{</a>
<a name="ln751">	fssh_dev_t volumeID = get_volume_id();</a>
<a name="ln752">	if (volumeID &lt; 0)</a>
<a name="ln753">		return volumeID;</a>
<a name="ln754"> </a>
<a name="ln755">	fssh_fs_info info;</a>
<a name="ln756">	fssh_status_t status = _kern_read_fs_info(volumeID, &amp;info);</a>
<a name="ln757">	if (status != FSSH_B_OK)</a>
<a name="ln758">		return status;</a>
<a name="ln759"> </a>
<a name="ln760">	printf(&quot;root inode:   %&quot; FSSH_B_PRIdINO &quot;\n&quot;, info.root);</a>
<a name="ln761">	printf(&quot;flags:        &quot;);</a>
<a name="ln762">	print_flag(info.flags, FSSH_B_FS_HAS_QUERY, &quot;Q&quot;, &quot;-&quot;);</a>
<a name="ln763">	print_flag(info.flags, FSSH_B_FS_HAS_ATTR, &quot;A&quot;, &quot;-&quot;);</a>
<a name="ln764">	print_flag(info.flags, FSSH_B_FS_HAS_MIME, &quot;M&quot;, &quot;-&quot;);</a>
<a name="ln765">	print_flag(info.flags, FSSH_B_FS_IS_SHARED, &quot;S&quot;, &quot;-&quot;);</a>
<a name="ln766">	print_flag(info.flags, FSSH_B_FS_IS_PERSISTENT, &quot;P&quot;, &quot;-&quot;);</a>
<a name="ln767">	print_flag(info.flags, FSSH_B_FS_IS_REMOVABLE, &quot;R&quot;, &quot;-&quot;);</a>
<a name="ln768">	print_flag(info.flags, FSSH_B_FS_IS_READONLY, &quot;-&quot;, &quot;W&quot;);</a>
<a name="ln769"> </a>
<a name="ln770">	printf(&quot;\nblock size:   %&quot; FSSH_B_PRIdOFF &quot;\n&quot;, info.block_size);</a>
<a name="ln771">	printf(&quot;I/O size:     %&quot; FSSH_B_PRIdOFF &quot;\n&quot;, info.io_size);</a>
<a name="ln772">	printf(&quot;total size:   %s (%&quot; FSSH_B_PRIdOFF &quot; blocks)\n&quot;,</a>
<a name="ln773">		byte_string(info.total_blocks, info.block_size), info.total_blocks);</a>
<a name="ln774">	printf(&quot;free size:    %s (%&quot; FSSH_B_PRIdOFF &quot; blocks)\n&quot;,</a>
<a name="ln775">		byte_string(info.free_blocks, info.block_size), info.free_blocks);</a>
<a name="ln776">	printf(&quot;total nodes:  %&quot; FSSH_B_PRIdOFF &quot;\n&quot;, info.total_nodes);</a>
<a name="ln777">	printf(&quot;free nodes:   %&quot; FSSH_B_PRIdOFF &quot;\n&quot;, info.free_nodes);</a>
<a name="ln778">	printf(&quot;volume name:  %s\n&quot;, info.volume_name);</a>
<a name="ln779">	printf(&quot;fs name:      %s\n&quot;, info.fsh_name);</a>
<a name="ln780"> </a>
<a name="ln781">	return FSSH_B_OK;</a>
<a name="ln782">}</a>
<a name="ln783"> </a>
<a name="ln784"> </a>
<a name="ln785">static fssh_status_t</a>
<a name="ln786">command_ln(int argc, const char* const* argv)</a>
<a name="ln787">{</a>
<a name="ln788">	bool force = false;</a>
<a name="ln789">	bool symbolic = false;</a>
<a name="ln790">	bool dereference = true;</a>
<a name="ln791"> </a>
<a name="ln792">	// parse parameters</a>
<a name="ln793">	int argi = 1;</a>
<a name="ln794">	for (argi = 1; argi &lt; argc; argi++) {</a>
<a name="ln795">		const char *arg = argv[argi];</a>
<a name="ln796">		if (arg[0] != '-')</a>
<a name="ln797">			break;</a>
<a name="ln798"> </a>
<a name="ln799">		if (arg[1] == '\0') {</a>
<a name="ln800">			fprintf(stderr, &quot;Error: Invalid option \&quot;-\&quot;\n&quot;);</a>
<a name="ln801">			return FSSH_B_BAD_VALUE;</a>
<a name="ln802">		}</a>
<a name="ln803"> </a>
<a name="ln804">		for (int i = 1; arg[i]; i++) {</a>
<a name="ln805">			switch (arg[i]) {</a>
<a name="ln806">				case 'f':</a>
<a name="ln807">					force = true;</a>
<a name="ln808">					break;</a>
<a name="ln809">				case 's':</a>
<a name="ln810">					symbolic = true;</a>
<a name="ln811">					break;</a>
<a name="ln812">				case 'n':</a>
<a name="ln813">					dereference = false;</a>
<a name="ln814">					break;</a>
<a name="ln815">				default:</a>
<a name="ln816">					fprintf(stderr, &quot;Error: Unknown option \&quot;-%c\&quot;\n&quot;, arg[i]);</a>
<a name="ln817">					return FSSH_B_BAD_VALUE;</a>
<a name="ln818">			}</a>
<a name="ln819">		}</a>
<a name="ln820">	}</a>
<a name="ln821"> </a>
<a name="ln822">	if (argc - argi != 2) {</a>
<a name="ln823">		fprintf(stderr, &quot;Usage: %s [Options] &lt;source&gt; &lt;target&gt;\n&quot;, argv[0]);</a>
<a name="ln824">		return FSSH_B_BAD_VALUE;</a>
<a name="ln825">	}</a>
<a name="ln826"> </a>
<a name="ln827">	const char *source = argv[argi];</a>
<a name="ln828">	const char *target = argv[argi + 1];</a>
<a name="ln829"> </a>
<a name="ln830">	// check, if the the target is an existing directory</a>
<a name="ln831">	struct fssh_stat st;</a>
<a name="ln832">	char targetBuffer[FSSH_B_PATH_NAME_LENGTH];</a>
<a name="ln833">	fssh_status_t error = _kern_read_stat(-1, target, dereference, &amp;st,</a>
<a name="ln834">		sizeof(st));</a>
<a name="ln835">	if (error == FSSH_B_OK) {</a>
<a name="ln836">		if (FSSH_S_ISDIR(st.fssh_st_mode)) {</a>
<a name="ln837">			// get source leaf</a>
<a name="ln838">			char leaf[FSSH_B_FILE_NAME_LENGTH];</a>
<a name="ln839">			error = get_last_path_component(source, leaf, sizeof(leaf));</a>
<a name="ln840">			if (error != FSSH_B_OK) {</a>
<a name="ln841">				fprintf(stderr, &quot;Error: Failed to get leaf name of source &quot;</a>
<a name="ln842">					&quot;path: %s\n&quot;, fssh_strerror(error));</a>
<a name="ln843">				return error;</a>
<a name="ln844">			}</a>
<a name="ln845"> </a>
<a name="ln846">			// compose a new path</a>
<a name="ln847">			int len = strlen(target) + 1 + strlen(leaf);</a>
<a name="ln848">			if (len &gt; (int)sizeof(targetBuffer)) {</a>
<a name="ln849">				fprintf(stderr, &quot;Error: Resulting target path is too long.\n&quot;);</a>
<a name="ln850">				return FSSH_B_BAD_VALUE;</a>
<a name="ln851">			}</a>
<a name="ln852"> </a>
<a name="ln853">			strcpy(targetBuffer, target);</a>
<a name="ln854">			strcat(targetBuffer, &quot;/&quot;);</a>
<a name="ln855">			strcat(targetBuffer, leaf);</a>
<a name="ln856">			target = targetBuffer;</a>
<a name="ln857">		}</a>
<a name="ln858">	}</a>
<a name="ln859"> </a>
<a name="ln860">	// check, if the target exists</a>
<a name="ln861">	error = _kern_read_stat(-1, target, false, &amp;st, sizeof(st));</a>
<a name="ln862">	if (error == FSSH_B_OK) {</a>
<a name="ln863">		if (!force) {</a>
<a name="ln864">			fprintf(stderr, &quot;Error: Can't create link. \&quot;%s\&quot; is in the way.\n&quot;,</a>
<a name="ln865">				target);</a>
<a name="ln866">			return FSSH_B_FILE_EXISTS;</a>
<a name="ln867">		}</a>
<a name="ln868"> </a>
<a name="ln869">		// unlink the entry</a>
<a name="ln870">		error = _kern_unlink(-1, target);</a>
<a name="ln871">		if (error != FSSH_B_OK) {</a>
<a name="ln872">			fprintf(stderr, &quot;Error: Failed to remove \&quot;%s\&quot; to make way for &quot;</a>
<a name="ln873">				&quot;link: %s\n&quot;, target, fssh_strerror(error));</a>
<a name="ln874">			return error;</a>
<a name="ln875">		}</a>
<a name="ln876">	}</a>
<a name="ln877"> </a>
<a name="ln878">	// finally create the link</a>
<a name="ln879">	if (symbolic) {</a>
<a name="ln880">		error = _kern_create_symlink(-1, target, source,</a>
<a name="ln881">			FSSH_S_IRWXU | FSSH_S_IRWXG | FSSH_S_IRWXO);</a>
<a name="ln882">	} else</a>
<a name="ln883">		error = _kern_create_link(target, source);</a>
<a name="ln884"> </a>
<a name="ln885">	if (error != FSSH_B_OK) {</a>
<a name="ln886">		fprintf(stderr, &quot;Error: Failed to create link: %s\n&quot;,</a>
<a name="ln887">			fssh_strerror(error));</a>
<a name="ln888">	}</a>
<a name="ln889"> </a>
<a name="ln890">	return error;</a>
<a name="ln891">}</a>
<a name="ln892"> </a>
<a name="ln893"> </a>
<a name="ln894">static fssh_status_t</a>
<a name="ln895">command_ls(int argc, const char* const* argv)</a>
<a name="ln896">{</a>
<a name="ln897">	const char* const currentDirFiles[] = { &quot;.&quot;, NULL };</a>
<a name="ln898">	const char* const* files;</a>
<a name="ln899">	if (argc &gt;= 2)</a>
<a name="ln900">		files = argv + 1;</a>
<a name="ln901">	else</a>
<a name="ln902">		files = currentDirFiles;</a>
<a name="ln903"> </a>
<a name="ln904">	for (; *files; files++) {</a>
<a name="ln905">		const char* file = *files;</a>
<a name="ln906">		// stat file</a>
<a name="ln907">		struct fssh_stat st;</a>
<a name="ln908">		fssh_status_t error = _kern_read_stat(-1, file, false, &amp;st, sizeof(st));</a>
<a name="ln909">		if (error != FSSH_B_OK) {</a>
<a name="ln910">			fprintf(stderr, &quot;Error: Failed to stat() \&quot;%s\&quot;: %s\n&quot;, file,</a>
<a name="ln911">				fssh_strerror(error));</a>
<a name="ln912">			continue;</a>
<a name="ln913">		}</a>
<a name="ln914"> </a>
<a name="ln915">		// if it is a directory, print its entries</a>
<a name="ln916">		if (FSSH_S_ISDIR(st.fssh_st_mode)) {</a>
<a name="ln917">			printf(&quot;%s:\n&quot;, file);</a>
<a name="ln918"> </a>
<a name="ln919">			// open dir</a>
<a name="ln920">			int fd = _kern_open_dir(-1, file);</a>
<a name="ln921">			if (fd &lt; 0) {</a>
<a name="ln922">				fprintf(stderr, &quot;Error: Failed to open dir \&quot;%s\&quot;: %s\n&quot;,</a>
<a name="ln923">					file, fssh_strerror(fd));</a>
<a name="ln924">				continue;</a>
<a name="ln925">			}</a>
<a name="ln926"> </a>
<a name="ln927">			// iterate through the entries</a>
<a name="ln928">			char buffer[sizeof(fssh_dirent) + FSSH_B_FILE_NAME_LENGTH];</a>
<a name="ln929">			fssh_dirent* entry = (fssh_dirent*)buffer;</a>
<a name="ln930">			fssh_ssize_t entriesRead = 0;</a>
<a name="ln931">			while ((entriesRead = _kern_read_dir(fd, entry, sizeof(buffer), 1))</a>
<a name="ln932">					== 1) {</a>
<a name="ln933">				list_entry(file, entry-&gt;d_name);</a>
<a name="ln934">			}</a>
<a name="ln935"> </a>
<a name="ln936">			if (entriesRead &lt; 0) {</a>
<a name="ln937">				fprintf(stderr, &quot;Error: reading dir \&quot;%s\&quot; failed: %s\n&quot;,</a>
<a name="ln938">					file, fssh_strerror(entriesRead));</a>
<a name="ln939">			}</a>
<a name="ln940"> </a>
<a name="ln941">			// close dir</a>
<a name="ln942">			error = _kern_close(fd);</a>
<a name="ln943">			if (error != FSSH_B_OK) {</a>
<a name="ln944">				fprintf(stderr, &quot;Error: Closing dir \&quot;%s\&quot; (fd: %d) failed: &quot;</a>
<a name="ln945">					&quot;%s\n&quot;, file, fd, fssh_strerror(error));</a>
<a name="ln946">				continue;</a>
<a name="ln947">			}</a>
<a name="ln948">		} else</a>
<a name="ln949">			list_entry(file);</a>
<a name="ln950">	}</a>
<a name="ln951"> </a>
<a name="ln952">	return FSSH_B_OK;</a>
<a name="ln953">}</a>
<a name="ln954"> </a>
<a name="ln955"> </a>
<a name="ln956">static fssh_status_t</a>
<a name="ln957">command_mkdir(int argc, const char* const* argv)</a>
<a name="ln958">{</a>
<a name="ln959">	bool createParents = false;</a>
<a name="ln960"> </a>
<a name="ln961">	// parse parameters</a>
<a name="ln962">	int argi = 1;</a>
<a name="ln963">	for (argi = 1; argi &lt; argc; argi++) {</a>
<a name="ln964">		const char *arg = argv[argi];</a>
<a name="ln965">		if (arg[0] != '-')</a>
<a name="ln966">			break;</a>
<a name="ln967"> </a>
<a name="ln968">		if (arg[1] == '\0') {</a>
<a name="ln969">			fprintf(stderr, &quot;Error: Invalid option \&quot;-\&quot;\n&quot;);</a>
<a name="ln970">			return FSSH_B_BAD_VALUE;</a>
<a name="ln971">		}</a>
<a name="ln972"> </a>
<a name="ln973">		for (int i = 1; arg[i]; i++) {</a>
<a name="ln974">			switch (arg[i]) {</a>
<a name="ln975">				case 'p':</a>
<a name="ln976">					createParents = true;</a>
<a name="ln977">					break;</a>
<a name="ln978">				default:</a>
<a name="ln979">					fprintf(stderr, &quot;Error: Unknown option \&quot;-%c\&quot;\n&quot;, arg[i]);</a>
<a name="ln980">					return FSSH_B_BAD_VALUE;</a>
<a name="ln981">			}</a>
<a name="ln982">		}</a>
<a name="ln983">	}</a>
<a name="ln984"> </a>
<a name="ln985">	if (argi &gt;= argc) {</a>
<a name="ln986">		printf(&quot;Usage: %s [ -p ] &lt;dir&gt;...\n&quot;, argv[0]);</a>
<a name="ln987">		return FSSH_B_BAD_VALUE;</a>
<a name="ln988">	}</a>
<a name="ln989"> </a>
<a name="ln990">	// create loop</a>
<a name="ln991">	for (; argi &lt; argc; argi++) {</a>
<a name="ln992">		const char *dir = argv[argi];</a>
<a name="ln993">		if (strlen(dir) == 0) {</a>
<a name="ln994">			fprintf(stderr, &quot;Error: An empty path is not a valid argument!\n&quot;);</a>
<a name="ln995">			return FSSH_B_BAD_VALUE;</a>
<a name="ln996">		}</a>
<a name="ln997"> </a>
<a name="ln998">		fssh_status_t error = create_dir(dir, createParents);</a>
<a name="ln999">		if (error != FSSH_B_OK)</a>
<a name="ln1000">			return error;</a>
<a name="ln1001">	}</a>
<a name="ln1002"> </a>
<a name="ln1003">	return FSSH_B_OK;</a>
<a name="ln1004">}</a>
<a name="ln1005"> </a>
<a name="ln1006"> </a>
<a name="ln1007">static fssh_status_t</a>
<a name="ln1008">command_mkindex(int argc, const char* const* argv)</a>
<a name="ln1009">{</a>
<a name="ln1010">	if (argc != 2) {</a>
<a name="ln1011">		fprintf(stderr, &quot;Usage: %s &lt;index name&gt;\n&quot;, argv[0]);</a>
<a name="ln1012">		return FSSH_B_BAD_VALUE;</a>
<a name="ln1013">	}</a>
<a name="ln1014"> </a>
<a name="ln1015">	const char* indexName = argv[1];</a>
<a name="ln1016"> </a>
<a name="ln1017">	// get the volume ID</a>
<a name="ln1018">	fssh_dev_t volumeID = get_volume_id();</a>
<a name="ln1019">	if (volumeID &lt; 0)</a>
<a name="ln1020">		return volumeID;</a>
<a name="ln1021"> </a>
<a name="ln1022">	// create the index</a>
<a name="ln1023">	fssh_status_t error =_kern_create_index(volumeID, indexName,</a>
<a name="ln1024">		FSSH_B_STRING_TYPE, 0);</a>
<a name="ln1025">	if (error != FSSH_B_OK) {</a>
<a name="ln1026">		fprintf(stderr, &quot;Error: Failed to create index \&quot;%s\&quot;: %s\n&quot;,</a>
<a name="ln1027">			indexName, fssh_strerror(error));</a>
<a name="ln1028">		return error;</a>
<a name="ln1029">	}</a>
<a name="ln1030"> </a>
<a name="ln1031">	return FSSH_B_OK;</a>
<a name="ln1032">}</a>
<a name="ln1033"> </a>
<a name="ln1034"> </a>
<a name="ln1035">static fssh_status_t</a>
<a name="ln1036">command_mv(int argc, const char* const* argv)</a>
<a name="ln1037">{</a>
<a name="ln1038">	bool force = false;</a>
<a name="ln1039"> </a>
<a name="ln1040">	// parse parameters</a>
<a name="ln1041">	int argi = 1;</a>
<a name="ln1042">	for (argi = 1; argi &lt; argc; argi++) {</a>
<a name="ln1043">		const char *arg = argv[argi];</a>
<a name="ln1044">		if (arg[0] != '-')</a>
<a name="ln1045">			break;</a>
<a name="ln1046"> </a>
<a name="ln1047">		if (arg[1] == '\0') {</a>
<a name="ln1048">			fprintf(stderr, &quot;Error: Invalid option \&quot;-\&quot;\n&quot;);</a>
<a name="ln1049">			return FSSH_B_BAD_VALUE;</a>
<a name="ln1050">		}</a>
<a name="ln1051"> </a>
<a name="ln1052">		for (int i = 1; arg[i]; i++) {</a>
<a name="ln1053">			switch (arg[i]) {</a>
<a name="ln1054">				case 'f':</a>
<a name="ln1055">					force = true;</a>
<a name="ln1056">					break;</a>
<a name="ln1057">				default:</a>
<a name="ln1058">					fprintf(stderr, &quot;Error: Unknown option \&quot;-%c\&quot;\n&quot;, arg[i]);</a>
<a name="ln1059">					return FSSH_B_BAD_VALUE;</a>
<a name="ln1060">			}</a>
<a name="ln1061">		}</a>
<a name="ln1062">	}</a>
<a name="ln1063"> </a>
<a name="ln1064">	// check params</a>
<a name="ln1065">	int count = argc - 1 - argi;</a>
<a name="ln1066">	if (count &lt;= 0) {</a>
<a name="ln1067">		fprintf(stderr, &quot;Usage: %s [-f] &lt;file&gt;... &lt;target&gt;\n&quot;, argv[0]);</a>
<a name="ln1068">		return FSSH_B_BAD_VALUE;</a>
<a name="ln1069">	}</a>
<a name="ln1070"> </a>
<a name="ln1071">	const char* target = argv[argc - 1];</a>
<a name="ln1072"> </a>
<a name="ln1073">	// stat the target</a>
<a name="ln1074">	struct fssh_stat st;</a>
<a name="ln1075">	fssh_status_t status = _kern_read_stat(-1, target, true, &amp;st, sizeof(st));</a>
<a name="ln1076">	if (status != FSSH_B_OK &amp;&amp; count != 1) {</a>
<a name="ln1077">		fprintf(stderr, &quot;Error: Failed to stat target \&quot;%s\&quot;: %s\n&quot;, target,</a>
<a name="ln1078">			fssh_strerror(status));</a>
<a name="ln1079">		return status;</a>
<a name="ln1080">	}</a>
<a name="ln1081"> </a>
<a name="ln1082">	if (status == FSSH_B_OK &amp;&amp; FSSH_S_ISDIR(st.fssh_st_mode)) {</a>
<a name="ln1083">		// move several entries</a>
<a name="ln1084">		int targetDir = _kern_open_dir(-1, target);</a>
<a name="ln1085">		if (targetDir &lt; 0) {</a>
<a name="ln1086">			fprintf(stderr, &quot;Error: Failed to open dir \&quot;%s\&quot;: %s\n&quot;, target,</a>
<a name="ln1087">				fssh_strerror(targetDir));</a>
<a name="ln1088">			return targetDir;</a>
<a name="ln1089">		}</a>
<a name="ln1090"> </a>
<a name="ln1091">		// move loop</a>
<a name="ln1092">		for (; argi &lt; argc - 1; argi++) {</a>
<a name="ln1093">			status = move_entry(-1, argv[argi], targetDir, argv[argi], force);</a>
<a name="ln1094">			if (status != FSSH_B_OK) {</a>
<a name="ln1095">				_kern_close(targetDir);</a>
<a name="ln1096">				return status;</a>
<a name="ln1097">			}</a>
<a name="ln1098">		}</a>
<a name="ln1099"> </a>
<a name="ln1100">		_kern_close(targetDir);</a>
<a name="ln1101">		return FSSH_B_OK;</a>
<a name="ln1102">	}</a>
<a name="ln1103"> </a>
<a name="ln1104">	// rename single entry</a>
<a name="ln1105">	return move_entry(-1, argv[argi], -1, target, force);</a>
<a name="ln1106">}</a>
<a name="ln1107"> </a>
<a name="ln1108"> </a>
<a name="ln1109">static fssh_status_t</a>
<a name="ln1110">command_query(int argc, const char* const* argv)</a>
<a name="ln1111">{</a>
<a name="ln1112">	if (argc != 2) {</a>
<a name="ln1113">		fprintf(stderr, &quot;Usage: %s &lt;query string&gt;\n&quot;, argv[0]);</a>
<a name="ln1114">		return FSSH_B_BAD_VALUE;</a>
<a name="ln1115">	}</a>
<a name="ln1116"> </a>
<a name="ln1117">	const char* query = argv[1];</a>
<a name="ln1118"> </a>
<a name="ln1119">	// get the volume ID</a>
<a name="ln1120">	fssh_dev_t volumeID = get_volume_id();</a>
<a name="ln1121">	if (volumeID &lt; 0)</a>
<a name="ln1122">		return volumeID;</a>
<a name="ln1123"> </a>
<a name="ln1124">	// open query</a>
<a name="ln1125">	int fd = _kern_open_query(volumeID, query, strlen(query), 0, -1, -1);</a>
<a name="ln1126">	if (fd &lt; 0) {</a>
<a name="ln1127">		fprintf(stderr, &quot;Error: Failed to open query: %s\n&quot;, fssh_strerror(fd));</a>
<a name="ln1128">		return fd;</a>
<a name="ln1129">	}</a>
<a name="ln1130"> </a>
<a name="ln1131">	// iterate through the entries</a>
<a name="ln1132">	fssh_status_t error = FSSH_B_OK;</a>
<a name="ln1133">	char buffer[sizeof(fssh_dirent) + FSSH_B_FILE_NAME_LENGTH];</a>
<a name="ln1134">	fssh_dirent* entry = (fssh_dirent*)buffer;</a>
<a name="ln1135">	fssh_ssize_t entriesRead = 0;</a>
<a name="ln1136">	while ((entriesRead = _kern_read_dir(fd, entry, sizeof(buffer), 1)) == 1) {</a>
<a name="ln1137">		char path[FSSH_B_PATH_NAME_LENGTH];</a>
<a name="ln1138">		error = _kern_entry_ref_to_path(volumeID, entry-&gt;d_pino, entry-&gt;d_name,</a>
<a name="ln1139">			path, sizeof(path));</a>
<a name="ln1140">		if (error == FSSH_B_OK) {</a>
<a name="ln1141">			printf(&quot;  %s\n&quot;, path);</a>
<a name="ln1142">		} else {</a>
<a name="ln1143">			fprintf(stderr, &quot;  failed to resolve entry (%8&quot; FSSH_B_PRIdINO</a>
<a name="ln1144">				&quot;, \&quot;%s\&quot;)\n&quot;, entry-&gt;d_pino, entry-&gt;d_name);</a>
<a name="ln1145">		}</a>
<a name="ln1146">	}</a>
<a name="ln1147"> </a>
<a name="ln1148">	if (entriesRead &lt; 0) {</a>
<a name="ln1149">		fprintf(stderr, &quot;Error: reading query failed: %s\n&quot;,</a>
<a name="ln1150">			fssh_strerror(entriesRead));</a>
<a name="ln1151">	}</a>
<a name="ln1152"> </a>
<a name="ln1153">	// close query</a>
<a name="ln1154">	error = _kern_close(fd);</a>
<a name="ln1155">	if (error != FSSH_B_OK) {</a>
<a name="ln1156">		fprintf(stderr, &quot;Error: Closing query (fd: %d) failed: %s\n&quot;,</a>
<a name="ln1157">			fd, fssh_strerror(error));</a>
<a name="ln1158">	}</a>
<a name="ln1159"> </a>
<a name="ln1160">	return error;</a>
<a name="ln1161">}</a>
<a name="ln1162"> </a>
<a name="ln1163"> </a>
<a name="ln1164">static fssh_status_t</a>
<a name="ln1165">command_quit(int argc, const char* const* argv)</a>
<a name="ln1166">{</a>
<a name="ln1167">	return COMMAND_RESULT_EXIT;</a>
<a name="ln1168">}</a>
<a name="ln1169"> </a>
<a name="ln1170"> </a>
<a name="ln1171">static fssh_status_t</a>
<a name="ln1172">command_rm(int argc, const char* const* argv)</a>
<a name="ln1173">{</a>
<a name="ln1174">	bool recursive = false;</a>
<a name="ln1175">	bool force = false;</a>
<a name="ln1176"> </a>
<a name="ln1177">	// parse parameters</a>
<a name="ln1178">	int argi = 1;</a>
<a name="ln1179">	for (argi = 1; argi &lt; argc; argi++) {</a>
<a name="ln1180">		const char *arg = argv[argi];</a>
<a name="ln1181">		if (arg[0] != '-')</a>
<a name="ln1182">			break;</a>
<a name="ln1183"> </a>
<a name="ln1184">		if (arg[1] == '\0') {</a>
<a name="ln1185">			fprintf(stderr, &quot;Error: Invalid option \&quot;-\&quot;\n&quot;);</a>
<a name="ln1186">			return FSSH_B_BAD_VALUE;</a>
<a name="ln1187">		}</a>
<a name="ln1188"> </a>
<a name="ln1189">		for (int i = 1; arg[i]; i++) {</a>
<a name="ln1190">			switch (arg[i]) {</a>
<a name="ln1191">				case 'f':</a>
<a name="ln1192">					force = true;</a>
<a name="ln1193">					break;</a>
<a name="ln1194">				case 'r':</a>
<a name="ln1195">					recursive = true;</a>
<a name="ln1196">					break;</a>
<a name="ln1197">				default:</a>
<a name="ln1198">					fprintf(stderr, &quot;Error: Unknown option \&quot;-%c\&quot;\n&quot;, arg[i]);</a>
<a name="ln1199">					return FSSH_B_BAD_VALUE;</a>
<a name="ln1200">			}</a>
<a name="ln1201">		}</a>
<a name="ln1202">	}</a>
<a name="ln1203"> </a>
<a name="ln1204">	// check params</a>
<a name="ln1205">	if (argi &gt;= argc) {</a>
<a name="ln1206">		fprintf(stderr, &quot;Usage: %s [ -r ] &lt;file&gt;...\n&quot;, argv[0]);</a>
<a name="ln1207">		return FSSH_B_BAD_VALUE;</a>
<a name="ln1208">	}</a>
<a name="ln1209"> </a>
<a name="ln1210">	// remove loop</a>
<a name="ln1211">	for (; argi &lt; argc; argi++) {</a>
<a name="ln1212">		fssh_status_t error = remove_entry(-1, argv[argi], recursive, force);</a>
<a name="ln1213">		if (error != FSSH_B_OK)</a>
<a name="ln1214">			return error;</a>
<a name="ln1215">	}</a>
<a name="ln1216"> </a>
<a name="ln1217">	return FSSH_B_OK;</a>
<a name="ln1218">}</a>
<a name="ln1219"> </a>
<a name="ln1220"> </a>
<a name="ln1221">static fssh_status_t</a>
<a name="ln1222">command_sync(int argc, const char* const* argv)</a>
<a name="ln1223">{</a>
<a name="ln1224">	fssh_status_t error = _kern_sync();</a>
<a name="ln1225">	if (error != FSSH_B_OK) {</a>
<a name="ln1226">		fprintf(stderr, &quot;Error: syncing: %s\n&quot;, fssh_strerror(error));</a>
<a name="ln1227">		return error;</a>
<a name="ln1228">	}</a>
<a name="ln1229"> </a>
<a name="ln1230">	return FSSH_B_OK;</a>
<a name="ln1231">}</a>
<a name="ln1232"> </a>
<a name="ln1233"> </a>
<a name="ln1234">static fssh_status_t</a>
<a name="ln1235">command_ioctl(int argc, const char* const* argv)</a>
<a name="ln1236">{</a>
<a name="ln1237">	if (argc != 2) {</a>
<a name="ln1238">		fprintf(stderr, &quot;Usage: %s &lt;opcode&gt;\n&quot;, argv[0]);</a>
<a name="ln1239">		return FSSH_B_BAD_VALUE;</a>
<a name="ln1240">	}</a>
<a name="ln1241"> </a>
<a name="ln1242">	int rootDir = _kern_open_dir(-1, &quot;/myfs&quot;);</a>
<a name="ln1243">	if (rootDir &lt; 0)</a>
<a name="ln1244">		return rootDir;</a>
<a name="ln1245"> </a>
<a name="ln1246">	fssh_status_t status = _kern_ioctl(rootDir, atoi(argv[1]), NULL, 0);</a>
<a name="ln1247"> </a>
<a name="ln1248">	_kern_close(rootDir);</a>
<a name="ln1249"> </a>
<a name="ln1250">	if (status != FSSH_B_OK) {</a>
<a name="ln1251">		fprintf(stderr, &quot;Error: ioctl failed: %s\n&quot;, fssh_strerror(status));</a>
<a name="ln1252">		return status;</a>
<a name="ln1253">	}</a>
<a name="ln1254"> </a>
<a name="ln1255">	return FSSH_B_OK;</a>
<a name="ln1256">}</a>
<a name="ln1257"> </a>
<a name="ln1258"> </a>
<a name="ln1259">static void</a>
<a name="ln1260">register_commands()</a>
<a name="ln1261">{</a>
<a name="ln1262">	CommandManager::Default()-&gt;AddCommands(</a>
<a name="ln1263">		command_cd,			&quot;cd&quot;,			&quot;change current directory&quot;,</a>
<a name="ln1264">		command_chmod,		&quot;chmod&quot;,		&quot;change file permissions&quot;,</a>
<a name="ln1265">		command_cp,			&quot;cp&quot;,			&quot;copy files and directories&quot;,</a>
<a name="ln1266">		command_cat,		&quot;cat&quot;,	&quot;concatenate file(s) to stdout&quot;,</a>
<a name="ln1267">		command_help,		&quot;help&quot;,			&quot;list supported commands&quot;,</a>
<a name="ln1268">		command_info,		&quot;info&quot;,			&quot;prints volume informations&quot;,</a>
<a name="ln1269">		command_ioctl,		&quot;ioctl&quot;,		&quot;ioctl() on root, for FS debugging only&quot;,</a>
<a name="ln1270">		command_ln,			&quot;ln&quot;,			&quot;create a hard or symbolic link&quot;,</a>
<a name="ln1271">		command_ls,			&quot;ls&quot;,			&quot;list files or directories&quot;,</a>
<a name="ln1272">		command_mkdir,		&quot;mkdir&quot;,		&quot;create directories&quot;,</a>
<a name="ln1273">		command_mkindex,	&quot;mkindex&quot;,		&quot;create an index&quot;,</a>
<a name="ln1274">		command_mv,			&quot;mv&quot;,			&quot;move/rename files and directories&quot;,</a>
<a name="ln1275">		command_query,		&quot;query&quot;,		&quot;query for files&quot;,</a>
<a name="ln1276">		command_quit,		&quot;quit/exit&quot;,	&quot;quit the shell&quot;,</a>
<a name="ln1277">		command_rm,			&quot;rm&quot;,			&quot;remove files and directories&quot;,</a>
<a name="ln1278">		command_sync,		&quot;sync&quot;,			&quot;syncs the file system&quot;,</a>
<a name="ln1279">		NULL</a>
<a name="ln1280">	);</a>
<a name="ln1281">}</a>
<a name="ln1282"> </a>
<a name="ln1283"> </a>
<a name="ln1284">// #pragma mark - ArgVector</a>
<a name="ln1285"> </a>
<a name="ln1286"> </a>
<a name="ln1287">class ArgVector {</a>
<a name="ln1288">public:</a>
<a name="ln1289">	ArgVector()</a>
<a name="ln1290">		: fArgc(0),</a>
<a name="ln1291">		  fArgv(NULL)</a>
<a name="ln1292">	{</a>
<a name="ln1293">	}</a>
<a name="ln1294"> </a>
<a name="ln1295">	~ArgVector()</a>
<a name="ln1296">	{</a>
<a name="ln1297">		_Cleanup();</a>
<a name="ln1298">	}</a>
<a name="ln1299"> </a>
<a name="ln1300">	int Argc() const</a>
<a name="ln1301">	{</a>
<a name="ln1302">		return fArgc;</a>
<a name="ln1303">	}</a>
<a name="ln1304"> </a>
<a name="ln1305">	const char* const* Argv() const</a>
<a name="ln1306">	{</a>
<a name="ln1307">		return fArgv;</a>
<a name="ln1308">	}</a>
<a name="ln1309"> </a>
<a name="ln1310">	bool Parse(const char* commandLine)</a>
<a name="ln1311">	{</a>
<a name="ln1312">		_Cleanup();</a>
<a name="ln1313"> </a>
<a name="ln1314">		// init temporary arg/argv storage</a>
<a name="ln1315">		std::string currentArg;</a>
<a name="ln1316">		std::vector&lt;std::string&gt; argVector;</a>
<a name="ln1317"> </a>
<a name="ln1318">		fCurrentArg = &amp;currentArg;</a>
<a name="ln1319">		fCurrentArgStarted = false;</a>
<a name="ln1320">		fArgVector = &amp;argVector;</a>
<a name="ln1321"> </a>
<a name="ln1322">		for (; *commandLine; commandLine++) {</a>
<a name="ln1323">			char c = *commandLine;</a>
<a name="ln1324"> </a>
<a name="ln1325">			// whitespace delimits args and is otherwise ignored</a>
<a name="ln1326">			if (isspace(c)) {</a>
<a name="ln1327">				_PushCurrentArg();</a>
<a name="ln1328">				continue;</a>
<a name="ln1329">			}</a>
<a name="ln1330"> </a>
<a name="ln1331">			switch (c) {</a>
<a name="ln1332">				case '\'':</a>
<a name="ln1333">					// quoted string -- no quoting</a>
<a name="ln1334">					while (*++commandLine != '\'') {</a>
<a name="ln1335">						c = *commandLine;</a>
<a name="ln1336">						if (c == '\0') {</a>
<a name="ln1337">							fprintf(stderr, &quot;Error: Unterminated quoted &quot;</a>
<a name="ln1338">								&quot;string.\n&quot;);</a>
<a name="ln1339">							return false;</a>
<a name="ln1340">						}</a>
<a name="ln1341">						_PushCharacter(c);</a>
<a name="ln1342">					}</a>
<a name="ln1343">					break;</a>
<a name="ln1344"> </a>
<a name="ln1345">				case '&quot;':</a>
<a name="ln1346">					// quoted string -- some quoting</a>
<a name="ln1347">					while (*++commandLine != '&quot;') {</a>
<a name="ln1348">						c = *commandLine;</a>
<a name="ln1349">						if (c == '\0') {</a>
<a name="ln1350">							fprintf(stderr, &quot;Error: Unterminated quoted &quot;</a>
<a name="ln1351">								&quot;string.\n&quot;);</a>
<a name="ln1352">							return false;</a>
<a name="ln1353">						}</a>
<a name="ln1354"> </a>
<a name="ln1355">						if (c == '\\') {</a>
<a name="ln1356">							c = *++commandLine;</a>
<a name="ln1357">							if (c == '\0') {</a>
<a name="ln1358">								fprintf(stderr, &quot;Error: Unterminated quoted &quot;</a>
<a name="ln1359">									&quot;string.\n&quot;);</a>
<a name="ln1360">								return false;</a>
<a name="ln1361">							}</a>
<a name="ln1362"> </a>
<a name="ln1363">							// only '\' and '&quot;' can be quoted, otherwise the</a>
<a name="ln1364">							// the '\' is treated as a normal char</a>
<a name="ln1365">							if (c != '\\' &amp;&amp; c != '&quot;')</a>
<a name="ln1366">								_PushCharacter('\\');</a>
<a name="ln1367">						}</a>
<a name="ln1368"> </a>
<a name="ln1369">						_PushCharacter(c);</a>
<a name="ln1370">					}</a>
<a name="ln1371">					break;</a>
<a name="ln1372"> </a>
<a name="ln1373">				case '\\':</a>
<a name="ln1374">					// quoted char</a>
<a name="ln1375">					c = *++commandLine;</a>
<a name="ln1376">					if (c == '\0') {</a>
<a name="ln1377">						fprintf(stderr, &quot;Error: Command line ends with &quot;</a>
<a name="ln1378">							&quot;'\\'.\n&quot;);</a>
<a name="ln1379">						return false;</a>
<a name="ln1380">					}</a>
<a name="ln1381">					_PushCharacter(c);</a>
<a name="ln1382">					break;</a>
<a name="ln1383"> </a>
<a name="ln1384">				default:</a>
<a name="ln1385">					// normal char</a>
<a name="ln1386">					_PushCharacter(c);</a>
<a name="ln1387">					break;</a>
<a name="ln1388">			}</a>
<a name="ln1389">		}</a>
<a name="ln1390"> </a>
<a name="ln1391">		// commit last arg</a>
<a name="ln1392">		_PushCurrentArg();</a>
<a name="ln1393"> </a>
<a name="ln1394">		// build arg vector</a>
<a name="ln1395">		fArgc = argVector.size();</a>
<a name="ln1396">		fArgv = new char*[fArgc + 1];</a>
<a name="ln1397">		for (int i = 0; i &lt; fArgc; i++) {</a>
<a name="ln1398">			int len = argVector[i].length();</a>
<a name="ln1399">			fArgv[i] = new char[len + 1];</a>
<a name="ln1400">			memcpy(fArgv[i], argVector[i].c_str(), len + 1);</a>
<a name="ln1401">		}</a>
<a name="ln1402">		fArgv[fArgc] = NULL;</a>
<a name="ln1403"> </a>
<a name="ln1404">		return true;</a>
<a name="ln1405">	}</a>
<a name="ln1406"> </a>
<a name="ln1407">private:</a>
<a name="ln1408">	void _Cleanup()</a>
<a name="ln1409">	{</a>
<a name="ln1410">		if (fArgv) {</a>
<a name="ln1411">			for (int i = 0; i &lt; fArgc; i++)</a>
<a name="ln1412">				delete[] fArgv[i];</a>
<a name="ln1413">			delete[] fArgv;</a>
<a name="ln1414">		}</a>
<a name="ln1415">	}</a>
<a name="ln1416"> </a>
<a name="ln1417">	void _PushCurrentArg()</a>
<a name="ln1418">	{</a>
<a name="ln1419">		if (fCurrentArgStarted) {</a>
<a name="ln1420">			fArgVector-&gt;push_back(*fCurrentArg);</a>
<a name="ln1421">			fCurrentArgStarted = false;</a>
<a name="ln1422">		}</a>
<a name="ln1423">	}</a>
<a name="ln1424"> </a>
<a name="ln1425">	void _PushCharacter(char c)</a>
<a name="ln1426">	{</a>
<a name="ln1427">		if (!fCurrentArgStarted) {</a>
<a name="ln1428">			*fCurrentArg = &quot;&quot;;</a>
<a name="ln1429">			fCurrentArgStarted = true;</a>
<a name="ln1430">		}</a>
<a name="ln1431"> </a>
<a name="ln1432">		*fCurrentArg += c;</a>
<a name="ln1433">	}</a>
<a name="ln1434"> </a>
<a name="ln1435">private:</a>
<a name="ln1436">	// temporaries</a>
<a name="ln1437">	std::string*				fCurrentArg;</a>
<a name="ln1438">	bool						fCurrentArgStarted;</a>
<a name="ln1439">	std::vector&lt;std::string&gt;*	fArgVector;</a>
<a name="ln1440"> </a>
<a name="ln1441">	int							fArgc;</a>
<a name="ln1442">	char**						fArgv;</a>
<a name="ln1443">};</a>
<a name="ln1444"> </a>
<a name="ln1445"> </a>
<a name="ln1446">// #pragma mark - input loop</a>
<a name="ln1447"> </a>
<a name="ln1448"> </a>
<a name="ln1449">static char*</a>
<a name="ln1450">read_command_line(char* buffer, int bufferSize)</a>
<a name="ln1451">{</a>
<a name="ln1452">	// print prompt (including cwd, if available)</a>
<a name="ln1453">	char directory[FSSH_B_PATH_NAME_LENGTH];</a>
<a name="ln1454">	if (_kern_getcwd(directory, sizeof(directory)) == FSSH_B_OK)</a>
<a name="ln1455">		printf(&quot;fssh:%s&gt; &quot;, directory);</a>
<a name="ln1456">	else</a>
<a name="ln1457">		printf(&quot;fssh&gt; &quot;);</a>
<a name="ln1458">	fflush(stdout);</a>
<a name="ln1459"> </a>
<a name="ln1460">	// read input line</a>
<a name="ln1461">	return fgets(buffer, bufferSize, stdin);</a>
<a name="ln1462">}</a>
<a name="ln1463"> </a>
<a name="ln1464"> </a>
<a name="ln1465">static void</a>
<a name="ln1466">input_loop(bool interactive)</a>
<a name="ln1467">{</a>
<a name="ln1468">	static const int kInputBufferSize = 100 * 1024;</a>
<a name="ln1469">	char* inputBuffer = new char[kInputBufferSize];</a>
<a name="ln1470"> </a>
<a name="ln1471">	for (;;) {</a>
<a name="ln1472">		// read command line</a>
<a name="ln1473">		if (interactive) {</a>
<a name="ln1474">			if (!read_command_line(inputBuffer, kInputBufferSize))</a>
<a name="ln1475">				break;</a>
<a name="ln1476">		} else {</a>
<a name="ln1477">			if (!get_external_command(inputBuffer, kInputBufferSize))</a>
<a name="ln1478">				break;</a>
<a name="ln1479">		}</a>
<a name="ln1480"> </a>
<a name="ln1481">		// construct argv vector</a>
<a name="ln1482">		int result = FSSH_B_BAD_VALUE;</a>
<a name="ln1483">		ArgVector argVector;</a>
<a name="ln1484">		if (argVector.Parse(inputBuffer) &amp;&amp; argVector.Argc() &gt; 0) {</a>
<a name="ln1485">			int argc = argVector.Argc();</a>
<a name="ln1486">			const char* const* argv = argVector.Argv();</a>
<a name="ln1487"> </a>
<a name="ln1488">			// find command</a>
<a name="ln1489">			Command* command = CommandManager::Default()-&gt;FindCommand(argv[0]);</a>
<a name="ln1490">			if (command) {</a>
<a name="ln1491">				// execute it</a>
<a name="ln1492">				result = command-&gt;Do(argc, argv);</a>
<a name="ln1493">				if (result == COMMAND_RESULT_EXIT) {</a>
<a name="ln1494">					if (!interactive)</a>
<a name="ln1495">						reply_to_external_command(0);</a>
<a name="ln1496">					break;</a>
<a name="ln1497">				}</a>
<a name="ln1498">			} else {</a>
<a name="ln1499">				fprintf(stderr, &quot;Error: Invalid command \&quot;%s\&quot;. Type \&quot;help\&quot; &quot;</a>
<a name="ln1500">					&quot;for a list of supported commands\n&quot;, argv[0]);</a>
<a name="ln1501">			}</a>
<a name="ln1502">		}</a>
<a name="ln1503"> </a>
<a name="ln1504">		if (!interactive)</a>
<a name="ln1505">			reply_to_external_command(fssh_to_host_error(result));</a>
<a name="ln1506">	}</a>
<a name="ln1507"> </a>
<a name="ln1508">	if (!interactive)</a>
<a name="ln1509">		external_command_cleanup();</a>
<a name="ln1510"> </a>
<a name="ln1511">	delete[] inputBuffer;</a>
<a name="ln1512">}</a>
<a name="ln1513"> </a>
<a name="ln1514"> </a>
<a name="ln1515">static int</a>
<a name="ln1516">standard_session(const char* device, const char* fsName, bool interactive)</a>
<a name="ln1517">{</a>
<a name="ln1518">	// mount FS</a>
<a name="ln1519">	fssh_dev_t fsDev = _kern_mount(kMountPoint, device, fsName, 0, NULL, 0);</a>
<a name="ln1520">	if (fsDev &lt; 0) {</a>
<a name="ln1521">		fprintf(stderr, &quot;Error: Mounting FS failed: %s\n&quot;,</a>
<a name="ln1522">			fssh_strerror(fsDev));</a>
<a name="ln1523">		return 1;</a>
<a name="ln1524">	}</a>
<a name="ln1525"> </a>
<a name="ln1526">	// register commands</a>
<a name="ln1527">	register_commands();</a>
<a name="ln1528">	register_additional_commands();</a>
<a name="ln1529"> </a>
<a name="ln1530">	// process commands</a>
<a name="ln1531">	input_loop(interactive);</a>
<a name="ln1532"> </a>
<a name="ln1533">	// unmount FS</a>
<a name="ln1534">	_kern_setcwd(-1, &quot;/&quot;);	// avoid a &quot;busy&quot; vnode</a>
<a name="ln1535">	fssh_status_t error = _kern_unmount(kMountPoint, 0);</a>
<a name="ln1536">	if (error != FSSH_B_OK) {</a>
<a name="ln1537">		fprintf(stderr, &quot;Error: Unmounting FS failed: %s\n&quot;,</a>
<a name="ln1538">			fssh_strerror(error));</a>
<a name="ln1539">		return 1;</a>
<a name="ln1540">	}</a>
<a name="ln1541"> </a>
<a name="ln1542">	return 0;</a>
<a name="ln1543">}</a>
<a name="ln1544"> </a>
<a name="ln1545"> </a>
<a name="ln1546">static int</a>
<a name="ln1547">initialization_session(const char* device, const char* fsName,</a>
<a name="ln1548">	const char* volumeName, const char* initParameters)</a>
<a name="ln1549">{</a>
<a name="ln1550">	fssh_status_t error = _kern_initialize_volume(fsName, device,</a>
<a name="ln1551">		volumeName, initParameters);</a>
<a name="ln1552">	if (error != FSSH_B_OK) {</a>
<a name="ln1553">		fprintf(stderr, &quot;Error: Initializing volume failed: %s\n&quot;,</a>
<a name="ln1554">			fssh_strerror(error));</a>
<a name="ln1555">		return 1;</a>
<a name="ln1556">	}</a>
<a name="ln1557"> </a>
<a name="ln1558">	return 0;</a>
<a name="ln1559">}</a>
<a name="ln1560"> </a>
<a name="ln1561"> </a>
<a name="ln1562">static void</a>
<a name="ln1563">print_usage(bool error)</a>
<a name="ln1564">{</a>
<a name="ln1565">	fprintf((error ? stderr : stdout),</a>
<a name="ln1566">		&quot;Usage: %s [ --start-offset &lt;startOffset&gt;]\n&quot;</a>
<a name="ln1567">		&quot;          [ --end-offset &lt;endOffset&gt;] [-n] &lt;device&gt;\n&quot;</a>
<a name="ln1568">		&quot;       %s [ --start-offset &lt;startOffset&gt;]\n&quot;</a>
<a name="ln1569">		&quot;          [ --end-offset &lt;endOffset&gt;]\n&quot;</a>
<a name="ln1570">		&quot;          --initialize [-n] &lt;device&gt; &lt;volume name&gt; &quot;</a>
<a name="ln1571">			&quot;[ &lt;init parameters&gt; ]\n&quot;,</a>
<a name="ln1572">		sArgv[0], sArgv[0]</a>
<a name="ln1573">	);</a>
<a name="ln1574">}</a>
<a name="ln1575"> </a>
<a name="ln1576"> </a>
<a name="ln1577">static void</a>
<a name="ln1578">print_usage_and_exit(bool error)</a>
<a name="ln1579">{</a>
<a name="ln1580">	print_usage(error);</a>
<a name="ln1581">	exit(error ? 1 : 0);</a>
<a name="ln1582">}</a>
<a name="ln1583"> </a>
<a name="ln1584"> </a>
<a name="ln1585">}	// namespace FSShell</a>
<a name="ln1586"> </a>
<a name="ln1587"> </a>
<a name="ln1588">using namespace FSShell;</a>
<a name="ln1589"> </a>
<a name="ln1590"> </a>
<a name="ln1591">int</a>
<a name="ln1592">main(int argc, const char* const* argv)</a>
<a name="ln1593">{</a>
<a name="ln1594">	sArgc = argc;</a>
<a name="ln1595">	sArgv = argv;</a>
<a name="ln1596"> </a>
<a name="ln1597">	// process arguments</a>
<a name="ln1598">	bool interactive = true;</a>
<a name="ln1599">	bool initialize = false;</a>
<a name="ln1600">	const char* device = NULL;</a>
<a name="ln1601">	const char* volumeName = NULL;</a>
<a name="ln1602">	const char* initParameters = NULL;</a>
<a name="ln1603">	fssh_off_t startOffset = 0;</a>
<a name="ln1604">	fssh_off_t endOffset = -1;</a>
<a name="ln1605"> </a>
<a name="ln1606">	// eat options</a>
<a name="ln1607">	int argi = 1;</a>
<a name="ln1608">	while (argi &lt; argc &amp;&amp; argv[argi][0] == '-') {</a>
<a name="ln1609">		const char* arg = argv[argi++];</a>
<a name="ln1610">		if (strcmp(arg, &quot;--help&quot;) == 0) {</a>
<a name="ln1611">			print_usage_and_exit(false);</a>
<a name="ln1612">		} else if (strcmp(arg, &quot;--initialize&quot;) == 0) {</a>
<a name="ln1613">			initialize = true;</a>
<a name="ln1614">		} else if (strcmp(arg, &quot;-n&quot;) == 0) {</a>
<a name="ln1615">			interactive = false;</a>
<a name="ln1616">		} else if (strcmp(arg, &quot;--start-offset&quot;) == 0) {</a>
<a name="ln1617">			if (argi &gt;= argc)</a>
<a name="ln1618">				print_usage_and_exit(true);</a>
<a name="ln1619">			startOffset = atoll(argv[argi++]);</a>
<a name="ln1620">		} else if (strcmp(arg, &quot;--end-offset&quot;) == 0) {</a>
<a name="ln1621">			if (argi &gt;= argc)</a>
<a name="ln1622">				print_usage_and_exit(true);</a>
<a name="ln1623">			endOffset = atoll(argv[argi++]);</a>
<a name="ln1624">		} else {</a>
<a name="ln1625">			print_usage_and_exit(true);</a>
<a name="ln1626">		}</a>
<a name="ln1627">	}</a>
<a name="ln1628"> </a>
<a name="ln1629">	// get device</a>
<a name="ln1630">	if (argi &gt;= argc)</a>
<a name="ln1631">		print_usage_and_exit(true);</a>
<a name="ln1632">	device = argv[argi++];</a>
<a name="ln1633"> </a>
<a name="ln1634">	// get volume name and init parameters</a>
<a name="ln1635">	if (initialize) {</a>
<a name="ln1636">		// volume name</a>
<a name="ln1637">		if (argi &gt;= argc)</a>
<a name="ln1638">			print_usage_and_exit(true);</a>
<a name="ln1639">		volumeName = argv[argi++];</a>
<a name="ln1640"> </a>
<a name="ln1641">		// (optional) init paramaters</a>
<a name="ln1642">		if (argi &lt; argc)</a>
<a name="ln1643">			initParameters = argv[argi++];</a>
<a name="ln1644">	}</a>
<a name="ln1645"> </a>
<a name="ln1646">	// more parameters are excess</a>
<a name="ln1647">	if (argi &lt; argc)</a>
<a name="ln1648">		print_usage_and_exit(true);</a>
<a name="ln1649"> </a>
<a name="ln1650">	// get FS module</a>
<a name="ln1651">	if (!modules[0]) {</a>
<a name="ln1652">		fprintf(stderr, &quot;Error: Couldn't find FS module!\n&quot;);</a>
<a name="ln1653">		return 1;</a>
<a name="ln1654">	}</a>
<a name="ln1655">	const char* fsName = modules[0]-&gt;name;</a>
<a name="ln1656"> </a>
<a name="ln1657">	fssh_status_t error;</a>
<a name="ln1658"> </a>
<a name="ln1659">	// init kernel</a>
<a name="ln1660">	error = init_kernel();</a>
<a name="ln1661">	if (error != FSSH_B_OK) {</a>
<a name="ln1662">		fprintf(stderr, &quot;Error: Initializing kernel failed: %s\n&quot;,</a>
<a name="ln1663">			fssh_strerror(error));</a>
<a name="ln1664">		return error;</a>
<a name="ln1665">	}</a>
<a name="ln1666"> </a>
<a name="ln1667">	// restrict access if requested</a>
<a name="ln1668">	if (startOffset != 0 || endOffset != -1)</a>
<a name="ln1669">		add_file_restriction(device, startOffset, endOffset);</a>
<a name="ln1670"> </a>
<a name="ln1671">	// start the action</a>
<a name="ln1672">	int result;</a>
<a name="ln1673">	if (initialize) {</a>
<a name="ln1674">		result = initialization_session(device, fsName, volumeName,</a>
<a name="ln1675">			initParameters);</a>
<a name="ln1676">	} else</a>
<a name="ln1677">		result = standard_session(device, fsName, interactive);</a>
<a name="ln1678"> </a>
<a name="ln1679">	return result;</a>
<a name="ln1680">}</a>

</code></pre>
<div class="balloon" rel="770"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'printf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="774"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'printf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="760"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'printf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="411"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the sixth actual argument of the 'printf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="776"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'printf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="772"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'printf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="124"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fFunction.</p></div>
<div class="balloon" rel="771"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'printf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="1143"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'fprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="777"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'printf' function. The memsize type argument is expected.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
