
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>mkdos.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> </a>
<a name="ln3">mkdos shell tool</a>
<a name="ln4"> </a>
<a name="ln5">Initialize FAT16 or FAT32 partitions, FAT12 floppy disks not supported</a>
<a name="ln6"> </a>
<a name="ln7">Copyright (c) 2015, Fran√ßois Revol &lt;revol@free.fr&gt;</a>
<a name="ln8">Copyright (c) 2002 Marcus Overhagen &lt;marcus@overhagen.de&gt;, OpenBeOS project</a>
<a name="ln9"> </a>
<a name="ln10">Permission is hereby granted, free of charge, to any person obtaining a copy of</a>
<a name="ln11">this software and associated documentation files (the &quot;Software&quot;), to deal in</a>
<a name="ln12">the Software without restriction, including without limitation the rights to</a>
<a name="ln13">use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies</a>
<a name="ln14">of the Software, and to permit persons to whom the Software is furnished to do</a>
<a name="ln15">so, subject to the following conditions:</a>
<a name="ln16"> </a>
<a name="ln17">The above copyright notice and this permission notice shall be included in all</a>
<a name="ln18">copies or substantial portions of the Software.</a>
<a name="ln19"> </a>
<a name="ln20">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</a>
<a name="ln21">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</a>
<a name="ln22">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</a>
<a name="ln23">AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</a>
<a name="ln24">LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</a>
<a name="ln25">OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN</a>
<a name="ln26">THE SOFTWARE.</a>
<a name="ln27"> </a>
<a name="ln28">*/</a>
<a name="ln29">#include &lt;ByteOrder.h&gt;</a>
<a name="ln30">#include &lt;Drivers.h&gt;</a>
<a name="ln31">#include &lt;driver_settings.h&gt;</a>
<a name="ln32">#include &lt;KernelExport.h&gt;</a>
<a name="ln33">#include &lt;OS.h&gt;</a>
<a name="ln34">#include &lt;errno.h&gt;</a>
<a name="ln35">#include &lt;getopt.h&gt;</a>
<a name="ln36">#include &lt;stdio.h&gt;</a>
<a name="ln37">#include &lt;stdlib.h&gt;</a>
<a name="ln38">#include &lt;string.h&gt;</a>
<a name="ln39">#include &lt;strings.h&gt;</a>
<a name="ln40">#include &lt;unistd.h&gt;</a>
<a name="ln41">#define MKDOS</a>
<a name="ln42">#include &quot;mkdos.h&quot;</a>
<a name="ln43"> </a>
<a name="ln44">#define WITH_FLOPPY_SUPPORT</a>
<a name="ln45"> </a>
<a name="ln46">void PrintUsage();</a>
<a name="ln47">void CreateVolumeLabel(void *sector, const char *label);</a>
<a name="ln48">status_t Initialize(int fatbits, const char *device, const char *label, bool noprompt, bool testmode);</a>
<a name="ln49">status_t parse_initialize_parameters(const char* parameterString,</a>
<a name="ln50">	initialize_parameters&amp; parameters);</a>
<a name="ln51"> </a>
<a name="ln52"> </a>
<a name="ln53">status_t</a>
<a name="ln54">check_volume_name(const char* name)</a>
<a name="ln55">{</a>
<a name="ln56">	if (name == NULL || strlen(name) &gt;= 11</a>
<a name="ln57">		|| strchr(name, '/') != NULL) {</a>
<a name="ln58">		return B_BAD_VALUE;</a>
<a name="ln59">	}</a>
<a name="ln60"> </a>
<a name="ln61">	return B_OK;</a>
<a name="ln62">}</a>
<a name="ln63"> </a>
<a name="ln64"> </a>
<a name="ln65">status_t</a>
<a name="ln66">parse_initialize_parameters(const char* parameterString,</a>
<a name="ln67">	initialize_parameters&amp; parameters)</a>
<a name="ln68">{</a>
<a name="ln69">	parameters.flags = 0;</a>
<a name="ln70">	parameters.verbose = false;</a>
<a name="ln71"> </a>
<a name="ln72">	void *handle = parse_driver_settings_string(parameterString);</a>
<a name="ln73">	if (handle == NULL)</a>
<a name="ln74">		return B_ERROR;</a>
<a name="ln75"> </a>
<a name="ln76">//	if (get_driver_boolean_parameter(handle, &quot;noindex&quot;, false, true))</a>
<a name="ln77">//		parameters.flags |= VOLUME_NO_INDICES;</a>
<a name="ln78">	if (get_driver_boolean_parameter(handle, &quot;verbose&quot;, false, true))</a>
<a name="ln79">		parameters.verbose = true;</a>
<a name="ln80"> </a>
<a name="ln81">	const char *string = get_driver_parameter(handle, &quot;fat&quot;,</a>
<a name="ln82">		NULL, NULL);</a>
<a name="ln83">	uint32 fatBits = 0;</a>
<a name="ln84">	if (string != NULL)</a>
<a name="ln85">		fatBits = strtoul(string, NULL, 0);</a>
<a name="ln86"> </a>
<a name="ln87">	delete_driver_settings(handle);</a>
<a name="ln88"> </a>
<a name="ln89">	if (fatBits != 0 &amp;&amp; fatBits != 12 &amp;&amp; fatBits != 16 &amp;&amp; fatBits != 32) {</a>
<a name="ln90">		printf(&quot;mkdos error: fat must be 12, 16, or 32 bits\n&quot;);</a>
<a name="ln91">		return B_BAD_VALUE;</a>
<a name="ln92">	}</a>
<a name="ln93"> </a>
<a name="ln94">	parameters.fatBits = fatBits;</a>
<a name="ln95"> </a>
<a name="ln96">	return B_OK;</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99"> </a>
<a name="ln100"> </a>
<a name="ln101">status_t</a>
<a name="ln102">dosfs_initialize(int fd, partition_id partitionID, const char* name,</a>
<a name="ln103">	const char* parameterString, off_t partitionSize, disk_job_id job)</a>
<a name="ln104">{</a>
<a name="ln105">	dprintf(&quot;dosfs_initialize(%d, , '%s', '%s', %lld)\n&quot;, fd, name, parameterString, partitionSize);</a>
<a name="ln106">	if (sizeof(bootsector1216) != 512 || sizeof(bootsector32) != 512 || sizeof(fsinfosector32) != 512) {</a>
<a name="ln107">		dprintf(&quot;dosfs: compilation error: struct alignment wrong\n&quot;);</a>
<a name="ln108">		return B_BAD_VALUE;</a>
<a name="ln109">	}</a>
<a name="ln110"> </a>
<a name="ln111">	// check name</a>
<a name="ln112">	status_t status = check_volume_name(name);</a>
<a name="ln113">	if (status != B_OK)</a>
<a name="ln114">		return status;</a>
<a name="ln115"> </a>
<a name="ln116">	// parse parameters</a>
<a name="ln117">	initialize_parameters parameters;</a>
<a name="ln118">	status = parse_initialize_parameters(parameterString, parameters);</a>
<a name="ln119">	if (status != B_OK)</a>
<a name="ln120">		return status;</a>
<a name="ln121"> </a>
<a name="ln122">	update_disk_device_job_progress(job, 0);</a>
<a name="ln123"> </a>
<a name="ln124">	int fatbits = parameters.fatBits;</a>
<a name="ln125">	const char *label = name;</a>
<a name="ln126"> </a>
<a name="ln127">	// initialize the volume</a>
<a name="ln128">//	Volume volume(NULL);</a>
<a name="ln129">//	status = volume.Initialize(fd, name, parameters.blockSize,</a>
<a name="ln130">//		parameters.flags);</a>
<a name="ln131"> </a>
<a name="ln132">	if (fatbits != 0 &amp;&amp; fatbits != 12 &amp;&amp; fatbits != 16 &amp;&amp; fatbits != 32) {</a>
<a name="ln133">		dprintf(&quot;dosfs Error: don't know how to create a %d bit fat\n&quot;,fatbits);</a>
<a name="ln134">		return B_ERROR;</a>
<a name="ln135">	}</a>
<a name="ln136"> </a>
<a name="ln137"> </a>
<a name="ln138"> </a>
<a name="ln139">	bool isRawDevice;</a>
<a name="ln140">	bool hasBiosGeometry;</a>
<a name="ln141">	bool hasDeviceGeometry;</a>
<a name="ln142">	bool hasPartitionInfo;</a>
<a name="ln143">	device_geometry biosGeometry;</a>
<a name="ln144">	device_geometry deviceGeometry;</a>
<a name="ln145">	partition_info 	partitionInfo;</a>
<a name="ln146"> </a>
<a name="ln147">	isRawDevice = 0;//0 != strstr(device, &quot;/raw&quot;);</a>
<a name="ln148">	hasBiosGeometry = B_OK == ioctl(fd, B_GET_BIOS_GEOMETRY, &amp;biosGeometry, sizeof(biosGeometry));</a>
<a name="ln149">	hasDeviceGeometry = B_OK == ioctl(fd, B_GET_GEOMETRY, &amp;deviceGeometry, sizeof(deviceGeometry));</a>
<a name="ln150">	hasPartitionInfo = B_OK == ioctl(fd, B_GET_PARTITION_INFO, &amp;partitionInfo, sizeof(partitionInfo));</a>
<a name="ln151"> </a>
<a name="ln152">	if (!isRawDevice &amp;&amp; !hasBiosGeometry &amp;&amp; !hasDeviceGeometry &amp;&amp; !hasPartitionInfo)</a>
<a name="ln153">		isRawDevice = true;</a>
<a name="ln154"> </a>
<a name="ln155">	if (hasBiosGeometry) {</a>
<a name="ln156">		dprintf(&quot;dosfs: bios geometry: %ld heads, %ld cylinders, %ld sectors/track, %ld bytes/sector\n&quot;,</a>
<a name="ln157">			biosGeometry.head_count,biosGeometry.cylinder_count,biosGeometry.sectors_per_track,biosGeometry.bytes_per_sector);</a>
<a name="ln158">	}</a>
<a name="ln159">	if (hasBiosGeometry) {</a>
<a name="ln160">		dprintf(&quot;dosfs: device geometry: %ld heads, %ld cylinders, %ld sectors/track, %ld bytes/sector\n&quot;,</a>
<a name="ln161">			deviceGeometry.head_count,deviceGeometry.cylinder_count,deviceGeometry.sectors_per_track,deviceGeometry.bytes_per_sector);</a>
<a name="ln162">	}</a>
<a name="ln163">	if (hasPartitionInfo) {</a>
<a name="ln164">		dprintf(&quot;dosfs: partition info: start at %Ld bytes (%Ld sectors), %Ld KB, %Ld MB, %Ld GB\n&quot;,</a>
<a name="ln165">			partitionInfo.offset,</a>
<a name="ln166">			partitionInfo.offset / 512,</a>
<a name="ln167">			partitionInfo.offset / 1024,</a>
<a name="ln168">			partitionInfo.offset / (1024 * 1024),</a>
<a name="ln169">			partitionInfo.offset / (1024 * 1024 * 1024));</a>
<a name="ln170">		dprintf(&quot;dosfs: partition info: size %Ld bytes, %Ld KB, %Ld MB, %Ld GB\n&quot;,</a>
<a name="ln171">			partitionInfo.size,</a>
<a name="ln172">			partitionInfo.size / 1024,</a>
<a name="ln173">			partitionInfo.size / (1024 * 1024),</a>
<a name="ln174">			partitionInfo.size / (1024 * 1024 * 1024));</a>
<a name="ln175">	}</a>
<a name="ln176"> </a>
<a name="ln177">	if (!isRawDevice &amp;&amp; !hasPartitionInfo) {</a>
<a name="ln178">		dprintf(&quot;dosfs Warning: couldn't get partition information\n&quot;);</a>
<a name="ln179">	}</a>
<a name="ln180">	if ((hasBiosGeometry &amp;&amp; biosGeometry.bytes_per_sector != 512) </a>
<a name="ln181">		||	(hasDeviceGeometry &amp;&amp; deviceGeometry.bytes_per_sector != 512)) {</a>
<a name="ln182">		dprintf(&quot;dosfs Error: geometry block size not 512 bytes\n&quot;);</a>
<a name="ln183">		return B_ERROR;</a>
<a name="ln184">	} else if (hasPartitionInfo &amp;&amp; partitionInfo.logical_block_size != 512) {</a>
<a name="ln185">		dprintf(&quot;dosfs: partition logical block size is not 512, it's %ld bytes\n&quot;,</a>
<a name="ln186">			partitionInfo.logical_block_size);</a>
<a name="ln187">	}</a>
<a name="ln188"> </a>
<a name="ln189">	if (hasDeviceGeometry &amp;&amp; deviceGeometry.read_only) {</a>
<a name="ln190">		dprintf(&quot;dosfs Error: this is a read-only device\n&quot;);</a>
<a name="ln191">		return B_ERROR;</a>
<a name="ln192">	}</a>
<a name="ln193">	if (hasDeviceGeometry &amp;&amp; deviceGeometry.write_once) {</a>
<a name="ln194">		dprintf(&quot;dosfs Error: this is a write-once device\n&quot;);</a>
<a name="ln195">		return B_ERROR;</a>
<a name="ln196">	}</a>
<a name="ln197">	uint64 size = 0;</a>
<a name="ln198"> </a>
<a name="ln199">	if (hasPartitionInfo) {</a>
<a name="ln200">		size = partitionInfo.size;</a>
<a name="ln201">	} else if (hasDeviceGeometry) {</a>
<a name="ln202">		size = uint64(deviceGeometry.bytes_per_sector) * deviceGeometry.sectors_per_track * deviceGeometry.cylinder_count * deviceGeometry.head_count;</a>
<a name="ln203">	} else if (hasBiosGeometry) {</a>
<a name="ln204">		size = uint64(biosGeometry.bytes_per_sector) * biosGeometry.sectors_per_track * biosGeometry.cylinder_count * biosGeometry.head_count;</a>
<a name="ln205">	} else {</a>
<a name="ln206">		// maybe it's just a file</a>
<a name="ln207">		struct stat stat;</a>
<a name="ln208">		if (fstat(fd, &amp;stat) &lt; 0) {</a>
<a name="ln209">			dprintf( &quot;dosfs Error: couldn't get device partition or geometry information, nor size\n&quot;);</a>
<a name="ln210">			return B_ERROR;</a>
<a name="ln211">		}</a>
<a name="ln212">		size = stat.st_size;</a>
<a name="ln213">	}</a>
<a name="ln214"> </a>
<a name="ln215">	// TODO still valid on Haiku ?</a>
<a name="ln216">	/*if (isRawDevice &amp;&amp; size &gt; FLOPPY_MAX_SIZE) {</a>
<a name="ln217">		dprintf(&quot;Error: device too large for floppy, or raw devices not supported\n&quot;);</a>
<a name="ln218">		close(fd);</a>
<a name="ln219">		return B_ERROR;</a>
<a name="ln220">	}*/</a>
<a name="ln221"> </a>
<a name="ln222">	dprintf(&quot;dosfs: size = %Ld bytes (%Ld sectors), %Ld KB, %Ld MB, %Ld GB\n&quot;,</a>
<a name="ln223">		size,</a>
<a name="ln224">		size / 512,</a>
<a name="ln225">		size / 1024,</a>
<a name="ln226">		size / (1024 * 1024),</a>
<a name="ln227">		size / (1024 * 1024 * 1024));</a>
<a name="ln228"> </a>
<a name="ln229">	if (fatbits == 0) {</a>
<a name="ln230">		//auto determine fat type</a>
<a name="ln231">		if (isRawDevice &amp;&amp; size &lt;= FLOPPY_MAX_SIZE &amp;&amp; (size / FAT12_CLUSTER_MAX_SIZE) &lt; FAT12_MAX_CLUSTER_COUNT) {</a>
<a name="ln232">			fatbits = 12;</a>
<a name="ln233">		} else if ((size / CLUSTER_MAX_SIZE) &lt; FAT16_MAX_CLUSTER_COUNT) {</a>
<a name="ln234">			fatbits = 16;</a>
<a name="ln235">		} else if ((size / CLUSTER_MAX_SIZE) &lt; FAT32_MAX_CLUSTER_COUNT) {</a>
<a name="ln236">			fatbits = 32;</a>
<a name="ln237">		}</a>
<a name="ln238">	}</a>
<a name="ln239"> </a>
<a name="ln240">	if (fatbits == 0) {</a>
<a name="ln241">		dprintf(&quot;dosfs Error: device too large for 32 bit fat\n&quot;);</a>
<a name="ln242">		return B_ERROR;</a>
<a name="ln243">	}</a>
<a name="ln244"> </a>
<a name="ln245">	int sectorPerCluster;</a>
<a name="ln246"> </a>
<a name="ln247">	sectorPerCluster = 0;</a>
<a name="ln248">	if (fatbits == 12) {</a>
<a name="ln249">		sectorPerCluster = 0;</a>
<a name="ln250">		if (size &lt;= 4182016LL)</a>
<a name="ln251">			sectorPerCluster = 2;	// XXX don't know the correct value</a>
<a name="ln252">		if (size &lt;= 2091008LL)</a>
<a name="ln253">			sectorPerCluster = 1;	// XXX don't know the correct value</a>
<a name="ln254">	} else if (fatbits == 16) {</a>
<a name="ln255">		// special BAD_CLUSTER value is 0xFFF7, </a>
<a name="ln256">		// but this should work anyway, since space required by </a>
<a name="ln257">		// two FATs will make maximum cluster count smaller.</a>
<a name="ln258">		// at least, this is what I think *should* happen</a>
<a name="ln259">		sectorPerCluster = 0;				//larger than 2 GB must fail</a>
<a name="ln260">		if (size &lt;= (2048 * 1024 * 1024LL))	// up to 2GB, use 32k clusters</a>
<a name="ln261">			sectorPerCluster = 64;</a>
<a name="ln262">		if (size &lt;= (1024 * 1024 * 1024LL))	// up to 1GB, use 16k clusters</a>
<a name="ln263">			sectorPerCluster = 32;</a>
<a name="ln264">		if (size &lt;= (512 * 1024 * 1024LL))	// up to 512MB, use 8k clusters</a>
<a name="ln265">			sectorPerCluster = 16;</a>
<a name="ln266">		if (size &lt;= (256 * 1024 * 1024LL))	// up to 256MB, use 4k clusters</a>
<a name="ln267">			sectorPerCluster = 8;</a>
<a name="ln268">		if (size &lt;= (128 * 1024 * 1024LL))	// up to 128MB, use 2k clusters</a>
<a name="ln269">			sectorPerCluster = 4;</a>
<a name="ln270">		if (size &lt;= (16 * 1024 * 1024LL))	// up to 16MB, use 2k clusters</a>
<a name="ln271">			sectorPerCluster = 2;</a>
<a name="ln272">		if (size &lt;= 4182016LL)				// smaller than fat32 must fail</a>
<a name="ln273">			sectorPerCluster = 0;</a>
<a name="ln274">	} if (fatbits == 32) {</a>
<a name="ln275">		sectorPerCluster = 64;				// default is 32k clusters</a>
<a name="ln276">		if (size &lt;= (32 * 1024 * 1024 * 1024LL))	// up to 32GB, use 16k clusters</a>
<a name="ln277">			sectorPerCluster = 32;</a>
<a name="ln278">		if (size &lt;= (16 * 1024 * 1024 * 1024LL))	// up to 16GB, use 8k clusters</a>
<a name="ln279">			sectorPerCluster = 16;</a>
<a name="ln280">		if (size &lt;= (8 * 1024 * 1024 * 1024LL))		// up to 8GB, use 4k clusters</a>
<a name="ln281">			sectorPerCluster = 8;</a>
<a name="ln282">		if (size &lt;= (532480 * 512LL))				// up to 260 MB, use 0.5k clusters</a>
<a name="ln283">			sectorPerCluster = 1;</a>
<a name="ln284">		if (size &lt;= (66600 * 512LL))		// smaller than 32.5 MB must fail</a>
<a name="ln285">			sectorPerCluster = 0;</a>
<a name="ln286">	}</a>
<a name="ln287"> </a>
<a name="ln288">	if (sectorPerCluster == 0) {</a>
<a name="ln289">		dprintf(&quot;dosfs Error: failed to determine sector per cluster value, partition too large for %d bit fat\n&quot;,fatbits);</a>
<a name="ln290">		return B_ERROR;</a>
<a name="ln291">	}</a>
<a name="ln292"> </a>
<a name="ln293">	int reservedSectorCount = 0; // avoid compiler warning</a>
<a name="ln294">	int rootEntryCount = 0; // avoid compiler warning</a>
<a name="ln295">	int numFATs;</a>
<a name="ln296">	int sectorSize;</a>
<a name="ln297">	uint8 biosDriveId;</a>
<a name="ln298"> </a>
<a name="ln299">	// get bios drive-id, or use 0x80</a>
<a name="ln300">	if (B_OK != ioctl(fd, B_GET_BIOS_DRIVE_ID, &amp;biosDriveId, sizeof(biosDriveId))) {</a>
<a name="ln301">		biosDriveId = 0x80;</a>
<a name="ln302">	} else {</a>
<a name="ln303">		dprintf(&quot;dosfs: bios drive id: 0x%02x\n&quot;, (int)biosDriveId);</a>
<a name="ln304">	}</a>
<a name="ln305"> </a>
<a name="ln306">	// default parameters for the bootsector</a>
<a name="ln307">	numFATs = 2;</a>
<a name="ln308">	sectorSize = 512;</a>
<a name="ln309">	if (fatbits == 12 || fatbits == 16)</a>
<a name="ln310">		reservedSectorCount = 1;</a>
<a name="ln311">	if (fatbits == 32)</a>
<a name="ln312">		reservedSectorCount = 32;</a>
<a name="ln313">	if (fatbits == 12)</a>
<a name="ln314">		rootEntryCount = 128; // XXX don't know the correct value</a>
<a name="ln315">	if (fatbits == 16)</a>
<a name="ln316">		rootEntryCount = 512;</a>
<a name="ln317">	if (fatbits == 32)</a>
<a name="ln318">		rootEntryCount = 0;</a>
<a name="ln319"> </a>
<a name="ln320">	// Determine FATSize</a>
<a name="ln321">	// calculation done as MS recommends</a>
<a name="ln322">	uint64 dskSize = size / sectorSize;</a>
<a name="ln323">	uint32 rootDirSectors = ((rootEntryCount * 32) + (sectorSize - 1)) / sectorSize;</a>
<a name="ln324">	uint64 tmpVal1 = dskSize - (reservedSectorCount + rootDirSectors);</a>
<a name="ln325">	uint64 tmpVal2 = (256 * sectorPerCluster) + numFATs;</a>
<a name="ln326">	if (fatbits == 32)</a>
<a name="ln327">		tmpVal2 = tmpVal2 / 2;</a>
<a name="ln328">	uint32 FATSize = (tmpVal1 + (tmpVal2 - 1)) / tmpVal2;</a>
<a name="ln329">	// FATSize should now contain the size of *one* FAT, measured in sectors</a>
<a name="ln330">	// RootDirSectors should now contain the size of the fat12/16 root directory, measured in sectors</a>
<a name="ln331"> </a>
<a name="ln332">	dprintf(&quot;dosfs: fatbits = %d, clustersize = %d\n&quot;, fatbits, sectorPerCluster * 512);</a>
<a name="ln333">	dprintf(&quot;dosfs: FAT size is %ld sectors\n&quot;, FATSize);</a>
<a name="ln334">	dprintf(&quot;dosfs: disk label: %s\n&quot;, label);</a>
<a name="ln335"> </a>
<a name="ln336"> </a>
<a name="ln337"> </a>
<a name="ln338">	if (status &lt; B_OK) {</a>
<a name="ln339">		dprintf(&quot;dosfs: Initializing volume failed: %s\n&quot;, strerror(status));</a>
<a name="ln340">		return status;</a>
<a name="ln341">	}</a>
<a name="ln342"> </a>
<a name="ln343">	char bootsector[512];</a>
<a name="ln344">	memset(bootsector,0x00,512);</a>
<a name="ln345">	memcpy(bootsector + BOOTJMP_START_OFFSET, bootjmp, sizeof(bootjmp));</a>
<a name="ln346">	memcpy(bootsector + BOOTCODE_START_OFFSET, bootcode, sizeof(bootcode));</a>
<a name="ln347">	</a>
<a name="ln348">	if (fatbits == 32) {</a>
<a name="ln349">		bootsector32 *bs = (bootsector32 *)bootsector;</a>
<a name="ln350">		uint16 temp16;</a>
<a name="ln351">		uint32 temp32;</a>
<a name="ln352">		memcpy(bs-&gt;BS_OEMName,&quot;Haiku   &quot;,8);</a>
<a name="ln353">		bs-&gt;BPB_BytsPerSec = B_HOST_TO_LENDIAN_INT16(sectorSize);</a>
<a name="ln354">		bs-&gt;BPB_SecPerClus = sectorPerCluster;</a>
<a name="ln355">		bs-&gt;BPB_RsvdSecCnt = B_HOST_TO_LENDIAN_INT16(reservedSectorCount);</a>
<a name="ln356">		bs-&gt;BPB_NumFATs = numFATs;</a>
<a name="ln357">		bs-&gt;BPB_RootEntCnt = B_HOST_TO_LENDIAN_INT16(rootEntryCount);</a>
<a name="ln358">		bs-&gt;BPB_TotSec16 = B_HOST_TO_LENDIAN_INT16(0);</a>
<a name="ln359">		bs-&gt;BPB_Media = 0xF8;</a>
<a name="ln360">		bs-&gt;BPB_FATSz16 = B_HOST_TO_LENDIAN_INT16(0);</a>
<a name="ln361">		temp16 = hasBiosGeometry ? biosGeometry.sectors_per_track : 63;</a>
<a name="ln362">		bs-&gt;BPB_SecPerTrk = B_HOST_TO_LENDIAN_INT16(temp16);</a>
<a name="ln363">		temp16 = hasBiosGeometry ? biosGeometry.head_count : 255;</a>
<a name="ln364">		bs-&gt;BPB_NumHeads = B_HOST_TO_LENDIAN_INT16(temp16);</a>
<a name="ln365">		temp32 = hasPartitionInfo ? (partitionInfo.size / 512) : 0;</a>
<a name="ln366">		bs-&gt;BPB_HiddSec = B_HOST_TO_LENDIAN_INT32(temp32);</a>
<a name="ln367">		temp32 = size / 512;</a>
<a name="ln368">		bs-&gt;BPB_TotSec32 = B_HOST_TO_LENDIAN_INT32(temp32);</a>
<a name="ln369">		bs-&gt;BPB_FATSz32 = B_HOST_TO_LENDIAN_INT32(FATSize);</a>
<a name="ln370">		bs-&gt;BPB_ExtFlags = B_HOST_TO_LENDIAN_INT16(0);</a>
<a name="ln371">		bs-&gt;BPB_FSVer = B_HOST_TO_LENDIAN_INT16(0);</a>
<a name="ln372">		bs-&gt;BPB_RootClus = B_HOST_TO_LENDIAN_INT32(FAT32_ROOT_CLUSTER);</a>
<a name="ln373">		bs-&gt;BPB_FSInfo = B_HOST_TO_LENDIAN_INT16(FSINFO_SECTOR_NUM);</a>
<a name="ln374">		bs-&gt;BPB_BkBootSec = B_HOST_TO_LENDIAN_INT16(BACKUP_SECTOR_NUM);</a>
<a name="ln375">		memset(bs-&gt;BPB_Reserved,0,12);</a>
<a name="ln376">		bs-&gt;BS_DrvNum = biosDriveId;</a>
<a name="ln377">		bs-&gt;BS_Reserved1 = 0x00;</a>
<a name="ln378">		bs-&gt;BS_BootSig = 0x29;</a>
<a name="ln379">		*(uint32*)bs-&gt;BS_VolID = (uint32)system_time();</a>
<a name="ln380">		memcpy(bs-&gt;BS_VolLab,&quot;NO NAME    &quot;,11);</a>
<a name="ln381">		memcpy(bs-&gt;BS_FilSysType,&quot;FAT32   &quot;,8);</a>
<a name="ln382">		bs-&gt;signature = B_HOST_TO_LENDIAN_INT16(0xAA55);</a>
<a name="ln383">	} else {</a>
<a name="ln384">		bootsector1216 *bs = (bootsector1216 *)bootsector;</a>
<a name="ln385">		uint16 temp16;</a>
<a name="ln386">		uint32 temp32;</a>
<a name="ln387">		uint32 sectorcount = size / 512;</a>
<a name="ln388">		memcpy(bs-&gt;BS_OEMName, &quot;Haiku   &quot;, 8);</a>
<a name="ln389">		bs-&gt;BPB_BytsPerSec = B_HOST_TO_LENDIAN_INT16(sectorSize);</a>
<a name="ln390">		bs-&gt;BPB_SecPerClus = sectorPerCluster;</a>
<a name="ln391">		bs-&gt;BPB_RsvdSecCnt = B_HOST_TO_LENDIAN_INT16(reservedSectorCount);</a>
<a name="ln392">		bs-&gt;BPB_NumFATs = numFATs;</a>
<a name="ln393">		bs-&gt;BPB_RootEntCnt = B_HOST_TO_LENDIAN_INT16(rootEntryCount);</a>
<a name="ln394">		temp16 = (sectorcount &lt;= 65535) ? sectorcount : 0;</a>
<a name="ln395">		bs-&gt;BPB_TotSec16 = B_HOST_TO_LENDIAN_INT16(temp16);</a>
<a name="ln396">		bs-&gt;BPB_Media = 0xF8;</a>
<a name="ln397">		bs-&gt;BPB_FATSz16 = B_HOST_TO_LENDIAN_INT16(FATSize);</a>
<a name="ln398">		temp16 = hasBiosGeometry ? biosGeometry.sectors_per_track : 63;</a>
<a name="ln399">		bs-&gt;BPB_SecPerTrk = B_HOST_TO_LENDIAN_INT16(temp16);</a>
<a name="ln400">		temp16 = hasBiosGeometry ? biosGeometry.head_count : 255;</a>
<a name="ln401">		bs-&gt;BPB_NumHeads = B_HOST_TO_LENDIAN_INT16(temp16);</a>
<a name="ln402">		temp32 = hasPartitionInfo ? (partitionInfo.size / 512) : 0;</a>
<a name="ln403">		bs-&gt;BPB_HiddSec = B_HOST_TO_LENDIAN_INT32(temp32);</a>
<a name="ln404">		temp32 = (sectorcount &lt;= 65535) ? 0 : sectorcount;</a>
<a name="ln405">		bs-&gt;BPB_TotSec32 = B_HOST_TO_LENDIAN_INT32(temp32);</a>
<a name="ln406">		bs-&gt;BS_DrvNum = biosDriveId;</a>
<a name="ln407">		bs-&gt;BS_Reserved1 = 0x00;</a>
<a name="ln408">		bs-&gt;BS_BootSig = 0x29;</a>
<a name="ln409">		*(uint32*)bs-&gt;BS_VolID = (uint32)system_time();</a>
<a name="ln410">		memcpy(bs-&gt;BS_VolLab,&quot;NO NAME    &quot;,11);</a>
<a name="ln411">		memcpy(bs-&gt;BS_FilSysType,(fatbits == 12) ? &quot;FAT12   &quot; : &quot;FAT16   &quot;,8);</a>
<a name="ln412">		bs-&gt;signature = B_HOST_TO_LENDIAN_INT16(0xAA55);</a>
<a name="ln413">	}</a>
<a name="ln414"> </a>
<a name="ln415">	// Disk layout:</a>
<a name="ln416">	// 0) reserved sectors, this includes the bootsector, fsinfosector and bootsector backup</a>
<a name="ln417">	// 1) FAT</a>
<a name="ln418">	// 2) root directory (not on fat32)</a>
<a name="ln419">	// 3) file &amp; directory data</a>
<a name="ln420"> </a>
<a name="ln421">	ssize_t written;</a>
<a name="ln422"> </a>
<a name="ln423">	// initialize everything with zero first</a>
<a name="ln424">	// avoid doing 512 byte writes here, they are slow</a>
<a name="ln425">	dprintf(&quot;dosfs: Writing FAT\n&quot;);</a>
<a name="ln426">	char * zerobuffer = (char *)malloc(65536);</a>
<a name="ln427">	memset(zerobuffer,0,65536);</a>
<a name="ln428">	int64 bytes_to_write = 512LL * (reservedSectorCount + (numFATs * FATSize) + rootDirSectors);</a>
<a name="ln429">	int64 pos = 0;</a>
<a name="ln430">	while (bytes_to_write &gt; 0) {</a>
<a name="ln431">		ssize_t writesize = min_c(bytes_to_write, 65536);</a>
<a name="ln432">		written = write_pos(fd, pos, zerobuffer, writesize);</a>
<a name="ln433">		if (written != writesize) {</a>
<a name="ln434">			dprintf(&quot;dosfs Error: write error near sector %Ld\n&quot;,pos / 512);</a>
<a name="ln435">			free(zerobuffer);</a>
<a name="ln436">			return B_ERROR;</a>
<a name="ln437">		}</a>
<a name="ln438">		bytes_to_write -= writesize;</a>
<a name="ln439">		pos += writesize;</a>
<a name="ln440">	}</a>
<a name="ln441">	free(zerobuffer);</a>
<a name="ln442"> </a>
<a name="ln443">	//write boot sector</a>
<a name="ln444">	dprintf(&quot;dosfs: Writing boot block\n&quot;);</a>
<a name="ln445">	written = write_pos(fd, BOOT_SECTOR_NUM * 512, bootsector, 512);</a>
<a name="ln446">	if (written != 512) {</a>
<a name="ln447">		dprintf(&quot;dosfs Error: write error at sector %d\n&quot;, BOOT_SECTOR_NUM);</a>
<a name="ln448">		return B_ERROR;</a>
<a name="ln449">	}</a>
<a name="ln450"> </a>
<a name="ln451">	if (fatbits == 32) {</a>
<a name="ln452">		written = write_pos(fd, BACKUP_SECTOR_NUM * 512, bootsector, 512);</a>
<a name="ln453">		if (written != 512) {</a>
<a name="ln454">			dprintf(&quot;dosfs Error: write error at sector %d\n&quot;, BACKUP_SECTOR_NUM);</a>
<a name="ln455">			return B_ERROR;</a>
<a name="ln456">		}</a>
<a name="ln457">	}</a>
<a name="ln458"> </a>
<a name="ln459">	//write first fat sector</a>
<a name="ln460">	dprintf(&quot;dosfs: Writing first FAT sector\n&quot;);</a>
<a name="ln461">	uint8 sec[512];</a>
<a name="ln462">	memset(sec,0,512);</a>
<a name="ln463">	if (fatbits == 12) {</a>
<a name="ln464">		//FAT[0] contains media byte in lower 8 bits, all other bits set to 1</a>
<a name="ln465">		//FAT[1] contains EOF marker</a>
<a name="ln466">		sec[0] = 0xF8;</a>
<a name="ln467">		sec[1] = 0xFF;</a>
<a name="ln468">		sec[2] = 0xFF;</a>
<a name="ln469">	} else if (fatbits == 16) {</a>
<a name="ln470">		//FAT[0] contains media byte in lower 8 bits, all other bits set to 1</a>
<a name="ln471">		sec[0] = 0xF8;</a>
<a name="ln472">		sec[1] = 0xFF;</a>
<a name="ln473">		//FAT[1] contains EOF marker</a>
<a name="ln474">		sec[2] = 0xFF;</a>
<a name="ln475">		sec[3] = 0xFF;</a>
<a name="ln476">	} else if (fatbits == 32) {</a>
<a name="ln477">		//FAT[0] contains media byte in lower 8 bits, all other bits set to 1</a>
<a name="ln478">		sec[0] = 0xF8;</a>
<a name="ln479">		sec[1] = 0xFF;</a>
<a name="ln480">		sec[2] = 0xFF;</a>
<a name="ln481">		sec[3] = 0xFF;</a>
<a name="ln482">		//FAT[1] contains EOF marker</a>
<a name="ln483">		sec[4] = 0xFF;</a>
<a name="ln484">		sec[5] = 0xFF;</a>
<a name="ln485">		sec[6] = 0xFF;</a>
<a name="ln486">		sec[7] = 0x0F;</a>
<a name="ln487">		//FAT[2] contains EOF marker, used to terminate root directory</a>
<a name="ln488">		sec[8] = 0xFF;</a>
<a name="ln489">		sec[9] = 0xFF;</a>
<a name="ln490">		sec[10] = 0xFF;</a>
<a name="ln491">		sec[11] = 0x0F;</a>
<a name="ln492">	}</a>
<a name="ln493">	written = write_pos(fd, reservedSectorCount * 512, sec, 512);</a>
<a name="ln494">	if (written != 512) {</a>
<a name="ln495">		dprintf(&quot;dosfs Error: write error at sector %d\n&quot;, reservedSectorCount);</a>
<a name="ln496">		return B_ERROR;</a>
<a name="ln497">	}</a>
<a name="ln498">	if (numFATs &gt; 1) {</a>
<a name="ln499">		written = write_pos(fd, (reservedSectorCount + FATSize) * 512,sec,512);</a>
<a name="ln500">		if (written != 512) {</a>
<a name="ln501">			dprintf(&quot;dosfs Error: write error at sector %ld\n&quot;, reservedSectorCount + FATSize);</a>
<a name="ln502">			return B_ERROR;</a>
<a name="ln503">		}</a>
<a name="ln504">	}</a>
<a name="ln505"> </a>
<a name="ln506">	//write fsinfo sector</a>
<a name="ln507">	if (fatbits == 32) {</a>
<a name="ln508">		dprintf(&quot;dosfs: Writing boot info\n&quot;);</a>
<a name="ln509">		//calculate total sector count first</a>
<a name="ln510">		uint64 free_count = size / 512;</a>
<a name="ln511">		//now account for already by metadata used sectors</a>
<a name="ln512">		free_count -= reservedSectorCount + (numFATs * FATSize) + rootDirSectors;</a>
<a name="ln513">		//convert from sector to clustercount</a>
<a name="ln514">		free_count /= sectorPerCluster;</a>
<a name="ln515">		//and account for 1 already used cluster of root directory</a>
<a name="ln516">		free_count -= 1; </a>
<a name="ln517">		fsinfosector32 fsinfosector;</a>
<a name="ln518">		memset(&amp;fsinfosector,0x00,512);</a>
<a name="ln519">		fsinfosector.FSI_LeadSig 	= B_HOST_TO_LENDIAN_INT32(0x41615252);</a>
<a name="ln520">		fsinfosector.FSI_StrucSig 	= B_HOST_TO_LENDIAN_INT32(0x61417272);</a>
<a name="ln521">		fsinfosector.FSI_Free_Count = B_HOST_TO_LENDIAN_INT32((uint32)free_count);</a>
<a name="ln522">		fsinfosector.FSI_Nxt_Free 	= B_HOST_TO_LENDIAN_INT32(3);</a>
<a name="ln523">		fsinfosector.FSI_TrailSig 	= B_HOST_TO_LENDIAN_INT32(0xAA550000);</a>
<a name="ln524">		written = write_pos(fd, FSINFO_SECTOR_NUM * 512, &amp;fsinfosector, 512);</a>
<a name="ln525">		if (written != 512) {</a>
<a name="ln526">			dprintf(&quot;dosfs Error: write error at sector %d\n&quot;, FSINFO_SECTOR_NUM);</a>
<a name="ln527">			return B_ERROR;</a>
<a name="ln528">		}</a>
<a name="ln529">	}</a>
<a name="ln530"> </a>
<a name="ln531">	//write volume label into root directory</a>
<a name="ln532">	dprintf(&quot;dosfs: Writing root directory\n&quot;);</a>
<a name="ln533">	if (fatbits == 12 || fatbits == 16) {</a>
<a name="ln534">		uint8 data[512];</a>
<a name="ln535">		memset(data, 0, 512);</a>
<a name="ln536">		CreateVolumeLabel(data, label);</a>
<a name="ln537">		uint32 rootDirSector = reservedSectorCount + (numFATs * FATSize);</a>
<a name="ln538">		written = write_pos(fd, rootDirSector * 512, data, 512);</a>
<a name="ln539">		if (written != 512) {</a>
<a name="ln540">			dprintf(&quot;dosfs Error: write error at sector %ld\n&quot;, rootDirSector);</a>
<a name="ln541">			return B_ERROR;</a>
<a name="ln542">		}</a>
<a name="ln543">	} else if (fatbits == 32) {</a>
<a name="ln544">		int size = 512 * sectorPerCluster;</a>
<a name="ln545">		uint8 *cluster = (uint8*)malloc(size);</a>
<a name="ln546">		memset(cluster, 0, size);</a>
<a name="ln547">		CreateVolumeLabel(cluster, label);</a>
<a name="ln548">		uint32 rootDirSector = reservedSectorCount + (numFATs * FATSize) + rootDirSectors;</a>
<a name="ln549">		written = write_pos(fd, rootDirSector * 512, cluster, size);</a>
<a name="ln550">		free(cluster);</a>
<a name="ln551">		if (written != size) {</a>
<a name="ln552">			dprintf(&quot;dosfs Error: write error at sector %ld\n&quot;, rootDirSector);</a>
<a name="ln553">			return B_ERROR;</a>
<a name="ln554">		}</a>
<a name="ln555">	}</a>
<a name="ln556"> </a>
<a name="ln557">	ioctl(fd, B_FLUSH_DRIVE_CACHE);</a>
<a name="ln558"> </a>
<a name="ln559"> </a>
<a name="ln560"> </a>
<a name="ln561">	// rescan partition</a>
<a name="ln562">	status = scan_partition(partitionID);</a>
<a name="ln563">	if (status != B_OK)</a>
<a name="ln564">		return status;</a>
<a name="ln565"> </a>
<a name="ln566">	update_disk_device_job_progress(job, 1);</a>
<a name="ln567"> </a>
<a name="ln568">	// print some info, if desired</a>
<a name="ln569">	if (parameters.verbose) {</a>
<a name="ln570">//		disk_super_block super = volume.SuperBlock();</a>
<a name="ln571"> </a>
<a name="ln572">		dprintf(&quot;dosfs: Disk was initialized successfully.\n&quot;);</a>
<a name="ln573">/*</a>
<a name="ln574">		dprintf(&quot;\tname: \&quot;%s\&quot;\n&quot;, super.name);</a>
<a name="ln575">		dprintf(&quot;\tnum blocks: %&quot; B_PRIdOFF &quot;\n&quot;, super.NumBlocks());</a>
<a name="ln576">		dprintf(&quot;\tused blocks: %&quot; B_PRIdOFF &quot;\n&quot;, super.UsedBlocks());</a>
<a name="ln577">		dprintf(&quot;\tblock size: %u bytes\n&quot;, (unsigned)super.BlockSize());</a>
<a name="ln578">		dprintf(&quot;\tnum allocation groups: %d\n&quot;,</a>
<a name="ln579">			(int)super.AllocationGroups());</a>
<a name="ln580">		dprintf(&quot;\tallocation group size: %ld blocks\n&quot;,</a>
<a name="ln581">			1L &lt;&lt; super.AllocationGroupShift());</a>
<a name="ln582">		dprintf(&quot;\tlog size: %u blocks\n&quot;, super.log_blocks.Length());</a>
<a name="ln583">*/</a>
<a name="ln584">	}</a>
<a name="ln585"> </a>
<a name="ln586">	return B_OK;</a>
<a name="ln587">}</a>
<a name="ln588"> </a>
<a name="ln589"> </a>
<a name="ln590">status_t</a>
<a name="ln591">dosfs_uninitialize(int fd, partition_id partitionID, off_t partitionSize,</a>
<a name="ln592">	uint32 blockSize, disk_job_id job)</a>
<a name="ln593">{</a>
<a name="ln594">	if (blockSize == 0)</a>
<a name="ln595">		return B_BAD_VALUE;</a>
<a name="ln596"> </a>
<a name="ln597">	update_disk_device_job_progress(job, 0.0);</a>
<a name="ln598"> </a>
<a name="ln599">	// just overwrite the superblock</a>
<a name="ln600">	// XXX: we might want to keep the loader part ?</a>
<a name="ln601">	char bootsector[512];</a>
<a name="ln602">	memset(bootsector,0x00,512);</a>
<a name="ln603"> </a>
<a name="ln604">	if (write_pos(fd, 512, bootsector, sizeof(512)) &lt; 0)</a>
<a name="ln605">		return errno;</a>
<a name="ln606"> </a>
<a name="ln607">	update_disk_device_job_progress(job, 1.0);</a>
<a name="ln608"> </a>
<a name="ln609">	return B_OK;</a>
<a name="ln610">}</a>
<a name="ln611"> </a>
<a name="ln612"> </a>
<a name="ln613">//	#pragma mark -</a>
<a name="ln614"> </a>
<a name="ln615"> </a>
<a name="ln616">#if 0</a>
<a name="ln617">int </a>
<a name="ln618">main(int argc, char *argv[])</a>
<a name="ln619">{</a>
<a name="ln620">	if (sizeof(bootsector1216) != 512 || sizeof(bootsector32) != 512 || sizeof(fsinfosector32) != 512) {</a>
<a name="ln621">		dprintf(&quot;compilation error: struct alignment wrong\n&quot;);</a>
<a name="ln622">		return 1;</a>
<a name="ln623">	}</a>
<a name="ln624">	</a>
<a name="ln625">	const char *device = NULL;</a>
<a name="ln626">	const char *label = NULL;</a>
<a name="ln627">	bool noprompt = false;</a>
<a name="ln628">	bool test = false;</a>
<a name="ln629">	int fat = 0;</a>
<a name="ln630">	</a>
<a name="ln631">	while (1) { </a>
<a name="ln632">		int c;</a>
<a name="ln633">		int option_index = 0; </a>
<a name="ln634">		static struct option long_options[] = </a>
<a name="ln635">		{ </a>
<a name="ln636">		 	{&quot;noprompt&quot;, no_argument, 0, 'n'}, </a>
<a name="ln637">			{&quot;test&quot;, no_argument, 0, 't'}, </a>
<a name="ln638">			{&quot;fat&quot;, required_argument, 0, 'f'}, </a>
<a name="ln639">			{0, 0, 0, 0} </a>
<a name="ln640">		}; </a>
<a name="ln641">		</a>
<a name="ln642">		c = getopt_long (argc, argv, &quot;ntf:&quot;, long_options, &amp;option_index); </a>
<a name="ln643">		if (c == -1) </a>
<a name="ln644">			break; </a>
<a name="ln645"> </a>
<a name="ln646">		switch (c) { </a>
<a name="ln647">			case 'n': </a>
<a name="ln648">				noprompt = true;</a>
<a name="ln649">		 		break; </a>
<a name="ln650"> </a>
<a name="ln651">			case 't':</a>
<a name="ln652">				test = true;</a>
<a name="ln653">				break; </a>
<a name="ln654"> </a>
<a name="ln655">			case 'f':</a>
<a name="ln656">				fat = strtol(optarg, NULL, 10);</a>
<a name="ln657">				if (fat == 0) </a>
<a name="ln658">					fat = -1;</a>
<a name="ln659">				break; </a>
<a name="ln660"> </a>
<a name="ln661">			default: </a>
<a name="ln662">		        printf(&quot;\n&quot;);</a>
<a name="ln663">				PrintUsage();</a>
<a name="ln664">				return 1;</a>
<a name="ln665">		} </a>
<a name="ln666">	} </a>
<a name="ln667"> </a>
<a name="ln668">	if (optind &lt; argc)</a>
<a name="ln669">		device = argv[optind];</a>
<a name="ln670">	if ((optind + 1) &lt; argc)</a>
<a name="ln671">		label = argv[optind + 1];</a>
<a name="ln672"> </a>
<a name="ln673">	if (fat != 0 &amp;&amp; fat != 12 &amp;&amp; fat != 16 &amp;&amp; fat != 32) {</a>
<a name="ln674">		printf(&quot;mkdos error: fat must be 12, 16, or 32 bits\n&quot;);</a>
<a name="ln675">		PrintUsage();</a>
<a name="ln676">		return 1;</a>
<a name="ln677">	}</a>
<a name="ln678"> </a>
<a name="ln679">	if (device == NULL) {</a>
<a name="ln680">		printf(&quot;mkdos error: you must specify a device or partition or image\n&quot;);</a>
<a name="ln681">        printf(&quot;             such as /dev/disk/ide/ata/1/master/0/0_0\n&quot;);</a>
<a name="ln682">		PrintUsage();</a>
<a name="ln683">		return 1;</a>
<a name="ln684">	}</a>
<a name="ln685"> </a>
<a name="ln686">	if (label == NULL) {</a>
<a name="ln687">		label = &quot;no name&quot;;</a>
<a name="ln688">	}</a>
<a name="ln689"> </a>
<a name="ln690">	if (noprompt)</a>
<a name="ln691">		printf(&quot;will not prompt for confirmation\n&quot;);</a>
<a name="ln692"> </a>
<a name="ln693">	if (test)</a>
<a name="ln694">		printf(&quot;test mode enabled (no writes will occur)\n&quot;);</a>
<a name="ln695">		</a>
<a name="ln696">	status_t s;</a>
<a name="ln697">	s = Initialize(fat, device, label, noprompt, test);</a>
<a name="ln698"> </a>
<a name="ln699">	if (s != 0) {</a>
<a name="ln700">		printf(&quot;Initializing failed!\n&quot;);</a>
<a name="ln701">	}</a>
<a name="ln702"> </a>
<a name="ln703">	return (s == B_OK) ? 0 : 1;</a>
<a name="ln704">}</a>
<a name="ln705">#endif</a>
<a name="ln706"> </a>
<a name="ln707"> </a>
<a name="ln708">void CreateVolumeLabel(void *sector, const char *label)</a>
<a name="ln709">{</a>
<a name="ln710">	// create a volume name directory entry in the 512 byte sector</a>
<a name="ln711">	// XXX convert from UTF8, and check for valid characters</a>
<a name="ln712">	// XXX this could be changed to use long file name entrys,</a>
<a name="ln713">	// XXX but the dosfs would have to be updated, too</a>
<a name="ln714">	</a>
<a name="ln715">	dirent *d = (dirent *)sector;</a>
<a name="ln716">	memset(d, 0, sizeof(*d));</a>
<a name="ln717">	memset(d-&gt;Name, 0x20, 11);</a>
<a name="ln718">	memcpy(d-&gt;Name, label, min_c(11, strlen(label)));</a>
<a name="ln719">	d-&gt;Attr = 0x08;</a>
<a name="ln720">}</a>

</code></pre>
<div class="balloon" rel="160"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fifth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="160"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="540"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="160"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="156"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fifth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="156"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="156"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="552"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="160"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="164"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Potentially incorrect format string is passed to the 'dprintf' function. Prefix 'L' is not applicable to conversion specifier 'd'.</p></div>
<div class="balloon" rel="156"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="274"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v646/" target="_blank">V646</a> Consider inspecting the application's logic. It's possible that 'else' keyword is missing.</p></div>
<div class="balloon" rel="170"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Potentially incorrect format string is passed to the 'dprintf' function. Prefix 'L' is not applicable to conversion specifier 'd'.</p></div>
<div class="balloon" rel="185"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="222"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Potentially incorrect format string is passed to the 'dprintf' function. Prefix 'L' is not applicable to conversion specifier 'd'.</p></div>
<div class="balloon" rel="498"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'numFATs > 1' is always true.</p></div>
<div class="balloon" rel="338"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'status < ((int) 0)' is always false.</p></div>
<div class="balloon" rel="501"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="333"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="434"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Potentially incorrect format string is passed to the 'dprintf' function. Prefix 'L' is not applicable to conversion specifier 'd'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
