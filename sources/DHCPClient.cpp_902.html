
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>DHCPClient.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2006-2018, Haiku, Inc. All Rights Reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Axel Dörfler, axeld@pinc-software.de</a>
<a name="ln7"> *		Vegard Wærp, vegarwa@online.no</a>
<a name="ln8"> *		Philippe Houdoin, &lt;phoudoin at haiku-os dot org&gt;</a>
<a name="ln9"> */</a>
<a name="ln10"> </a>
<a name="ln11"> </a>
<a name="ln12">#include &quot;DHCPClient.h&quot;</a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;Message.h&gt;</a>
<a name="ln15">#include &lt;MessageRunner.h&gt;</a>
<a name="ln16">#include &lt;NetworkDevice.h&gt;</a>
<a name="ln17">#include &lt;NetworkInterface.h&gt;</a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;algorithm&gt;</a>
<a name="ln20">#include &lt;arpa/inet.h&gt;</a>
<a name="ln21">#include &lt;errno.h&gt;</a>
<a name="ln22">#include &lt;stdio.h&gt;</a>
<a name="ln23">#include &lt;string.h&gt;</a>
<a name="ln24">#include &lt;stdlib.h&gt;</a>
<a name="ln25">#include &lt;syslog.h&gt;</a>
<a name="ln26">#include &lt;sys/sockio.h&gt;</a>
<a name="ln27">#include &lt;sys/time.h&gt;</a>
<a name="ln28">#include &lt;unistd.h&gt;</a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;Debug.h&gt;</a>
<a name="ln31">#include &lt;Message.h&gt;</a>
<a name="ln32">#include &lt;MessageRunner.h&gt;</a>
<a name="ln33"> </a>
<a name="ln34">#include &quot;NetServer.h&quot;</a>
<a name="ln35"> </a>
<a name="ln36"> </a>
<a name="ln37">// See RFC 2131 for DHCP, see RFC 1533 for BOOTP/DHCP options</a>
<a name="ln38"> </a>
<a name="ln39">#define DHCP_CLIENT_PORT	68</a>
<a name="ln40">#define DHCP_SERVER_PORT	67</a>
<a name="ln41"> </a>
<a name="ln42">#define DEFAULT_TIMEOUT		0.25	// secs</a>
<a name="ln43">#define MAX_TIMEOUT			64		// secs</a>
<a name="ln44"> </a>
<a name="ln45">#define AS_USECS(t) (1000000 * t)</a>
<a name="ln46"> </a>
<a name="ln47">#define MAX_RETRIES			5</a>
<a name="ln48"> </a>
<a name="ln49">enum message_opcode {</a>
<a name="ln50">	BOOT_REQUEST = 1,</a>
<a name="ln51">	BOOT_REPLY</a>
<a name="ln52">};</a>
<a name="ln53"> </a>
<a name="ln54">enum message_option {</a>
<a name="ln55">	OPTION_MAGIC = 0x63825363,</a>
<a name="ln56"> </a>
<a name="ln57">	// generic options</a>
<a name="ln58">	OPTION_PAD = 0,</a>
<a name="ln59">	OPTION_END = 255,</a>
<a name="ln60">	OPTION_SUBNET_MASK = 1,</a>
<a name="ln61">	OPTION_TIME_OFFSET = 2,</a>
<a name="ln62">	OPTION_ROUTER_ADDRESS = 3,</a>
<a name="ln63">	OPTION_DOMAIN_NAME_SERVER = 6,</a>
<a name="ln64">	OPTION_HOST_NAME = 12,</a>
<a name="ln65">	OPTION_DOMAIN_NAME = 15,</a>
<a name="ln66">	OPTION_MAX_DATAGRAM_SIZE = 22,</a>
<a name="ln67">	OPTION_INTERFACE_MTU = 26,</a>
<a name="ln68">	OPTION_BROADCAST_ADDRESS = 28,</a>
<a name="ln69">	OPTION_NETWORK_TIME_PROTOCOL_SERVERS = 42,</a>
<a name="ln70">	OPTION_NETBIOS_NAME_SERVER = 44,</a>
<a name="ln71">	OPTION_NETBIOS_SCOPE = 47,</a>
<a name="ln72"> </a>
<a name="ln73">	// DHCP specific options</a>
<a name="ln74">	OPTION_REQUEST_IP_ADDRESS = 50,</a>
<a name="ln75">	OPTION_ADDRESS_LEASE_TIME = 51,</a>
<a name="ln76">	OPTION_OVERLOAD = 52,</a>
<a name="ln77">	OPTION_MESSAGE_TYPE = 53,</a>
<a name="ln78">	OPTION_SERVER_ADDRESS = 54,</a>
<a name="ln79">	OPTION_REQUEST_PARAMETERS = 55,</a>
<a name="ln80">	OPTION_ERROR_MESSAGE = 56,</a>
<a name="ln81">	OPTION_MAX_MESSAGE_SIZE = 57,</a>
<a name="ln82">	OPTION_RENEWAL_TIME = 58,</a>
<a name="ln83">	OPTION_REBINDING_TIME = 59,</a>
<a name="ln84">	OPTION_CLASS_IDENTIFIER = 60,</a>
<a name="ln85">	OPTION_CLIENT_IDENTIFIER = 61,</a>
<a name="ln86">};</a>
<a name="ln87"> </a>
<a name="ln88">enum message_type {</a>
<a name="ln89">	DHCP_NONE = 0,</a>
<a name="ln90">	DHCP_DISCOVER = 1,</a>
<a name="ln91">	DHCP_OFFER = 2,</a>
<a name="ln92">	DHCP_REQUEST = 3,</a>
<a name="ln93">	DHCP_DECLINE = 4,</a>
<a name="ln94">	DHCP_ACK = 5,</a>
<a name="ln95">	DHCP_NACK = 6,</a>
<a name="ln96">	DHCP_RELEASE = 7,</a>
<a name="ln97">	DHCP_INFORM = 8</a>
<a name="ln98">};</a>
<a name="ln99"> </a>
<a name="ln100">struct dhcp_option_cookie {</a>
<a name="ln101">	dhcp_option_cookie()</a>
<a name="ln102">		:</a>
<a name="ln103">		state(0),</a>
<a name="ln104">		file_has_options(false),</a>
<a name="ln105">		server_name_has_options(false)</a>
<a name="ln106">	{</a>
<a name="ln107">	}</a>
<a name="ln108"> </a>
<a name="ln109">	const uint8* next;</a>
<a name="ln110">	uint8	state;</a>
<a name="ln111">	bool	file_has_options;</a>
<a name="ln112">	bool	server_name_has_options;</a>
<a name="ln113">};</a>
<a name="ln114"> </a>
<a name="ln115">struct dhcp_message {</a>
<a name="ln116">	dhcp_message(message_type type);</a>
<a name="ln117"> </a>
<a name="ln118">	uint8		opcode;</a>
<a name="ln119">	uint8		hardware_type;</a>
<a name="ln120">	uint8		hardware_address_length;</a>
<a name="ln121">	uint8		hop_count;</a>
<a name="ln122">	uint32		transaction_id;</a>
<a name="ln123">	uint16		seconds_since_start;</a>
<a name="ln124">	uint16		flags;</a>
<a name="ln125">	in_addr_t	client_address;</a>
<a name="ln126">	in_addr_t	your_address;</a>
<a name="ln127">	in_addr_t	server_address;</a>
<a name="ln128">	in_addr_t	gateway_address;</a>
<a name="ln129">	uint8		mac_address[16];</a>
<a name="ln130">	uint8		server_name[64];</a>
<a name="ln131">	uint8		file[128];</a>
<a name="ln132">	uint32		options_magic;</a>
<a name="ln133">	uint8		options[1260];</a>
<a name="ln134"> </a>
<a name="ln135">	size_t MinSize() const { return 576; }</a>
<a name="ln136">	size_t Size() const;</a>
<a name="ln137"> </a>
<a name="ln138">	bool HasOptions() const;</a>
<a name="ln139">	bool NextOption(dhcp_option_cookie&amp; cookie, message_option&amp; option,</a>
<a name="ln140">		const uint8*&amp; data, size_t&amp; size) const;</a>
<a name="ln141">	const uint8* FindOption(message_option which) const;</a>
<a name="ln142">	const uint8* LastOption() const;</a>
<a name="ln143">	message_type Type() const;</a>
<a name="ln144"> </a>
<a name="ln145">	uint8* PrepareMessage(uint8 type);</a>
<a name="ln146">	uint8* PutOption(uint8* options, message_option option);</a>
<a name="ln147">	uint8* PutOption(uint8* options, message_option option, uint8 data);</a>
<a name="ln148">	uint8* PutOption(uint8* options, message_option option, uint16 data);</a>
<a name="ln149">	uint8* PutOption(uint8* options, message_option option, uint32 data);</a>
<a name="ln150">	uint8* PutOption(uint8* options, message_option option, const uint8* data,</a>
<a name="ln151">		uint32 size);</a>
<a name="ln152">	uint8* FinishOptions(uint8* options);</a>
<a name="ln153"> </a>
<a name="ln154">	static const char* TypeToString(message_type type);</a>
<a name="ln155">} _PACKED;</a>
<a name="ln156"> </a>
<a name="ln157">struct socket_timeout {</a>
<a name="ln158">	socket_timeout(int socket)</a>
<a name="ln159">		:</a>
<a name="ln160">		timeout(time_t(AS_USECS(DEFAULT_TIMEOUT))),</a>
<a name="ln161">		tries(0)</a>
<a name="ln162">	{</a>
<a name="ln163">		UpdateSocket(socket);</a>
<a name="ln164">	}</a>
<a name="ln165"> </a>
<a name="ln166">	time_t timeout; // in micro secs</a>
<a name="ln167">	uint8 tries;</a>
<a name="ln168"> </a>
<a name="ln169">	bool Shift(int socket, bigtime_t stateMaxTime, const char* device);</a>
<a name="ln170">	void UpdateSocket(int socket) const;</a>
<a name="ln171">};</a>
<a name="ln172"> </a>
<a name="ln173">#define DHCP_FLAG_BROADCAST		0x8000</a>
<a name="ln174"> </a>
<a name="ln175">#define ARP_HARDWARE_TYPE_ETHER	1</a>
<a name="ln176"> </a>
<a name="ln177">const uint32 kMsgLeaseTime = 'lstm';</a>
<a name="ln178"> </a>
<a name="ln179">static const uint8 kRequestParameters[] = {</a>
<a name="ln180">	OPTION_SUBNET_MASK, OPTION_ROUTER_ADDRESS,</a>
<a name="ln181">	OPTION_DOMAIN_NAME_SERVER, OPTION_BROADCAST_ADDRESS,</a>
<a name="ln182">	OPTION_DOMAIN_NAME</a>
<a name="ln183">};</a>
<a name="ln184"> </a>
<a name="ln185"> </a>
<a name="ln186">dhcp_message::dhcp_message(message_type type)</a>
<a name="ln187">{</a>
<a name="ln188">	// ASSERT(this == offsetof(this, opcode));</a>
<a name="ln189">	memset(this, 0, sizeof(*this));</a>
<a name="ln190">	options_magic = htonl(OPTION_MAGIC);</a>
<a name="ln191"> </a>
<a name="ln192">	uint8* next = PrepareMessage(type);</a>
<a name="ln193">	FinishOptions(next);</a>
<a name="ln194">}</a>
<a name="ln195"> </a>
<a name="ln196"> </a>
<a name="ln197">bool</a>
<a name="ln198">dhcp_message::HasOptions() const</a>
<a name="ln199">{</a>
<a name="ln200">	return options_magic == htonl(OPTION_MAGIC);</a>
<a name="ln201">}</a>
<a name="ln202"> </a>
<a name="ln203"> </a>
<a name="ln204">bool</a>
<a name="ln205">dhcp_message::NextOption(dhcp_option_cookie&amp; cookie,</a>
<a name="ln206">	message_option&amp; option, const uint8*&amp; data, size_t&amp; size) const</a>
<a name="ln207">{</a>
<a name="ln208">	if (!HasOptions())</a>
<a name="ln209">		return false;</a>
<a name="ln210"> </a>
<a name="ln211">	if (cookie.state == 0) {</a>
<a name="ln212">		cookie.state++;</a>
<a name="ln213">		cookie.next = options;</a>
<a name="ln214">	}</a>
<a name="ln215"> </a>
<a name="ln216">	uint32 bytesLeft = 0;</a>
<a name="ln217"> </a>
<a name="ln218">	switch (cookie.state) {</a>
<a name="ln219">		case 1:</a>
<a name="ln220">			// options from &quot;options&quot;</a>
<a name="ln221">			bytesLeft = sizeof(options) - (cookie.next - options);</a>
<a name="ln222">			break;</a>
<a name="ln223"> </a>
<a name="ln224">		case 2:</a>
<a name="ln225">			// options from &quot;file&quot;</a>
<a name="ln226">			bytesLeft = sizeof(file) - (cookie.next - file);</a>
<a name="ln227">			break;</a>
<a name="ln228"> </a>
<a name="ln229">		case 3:</a>
<a name="ln230">			// options from &quot;server_name&quot;</a>
<a name="ln231">			bytesLeft = sizeof(server_name) - (cookie.next - server_name);</a>
<a name="ln232">			break;</a>
<a name="ln233">	}</a>
<a name="ln234"> </a>
<a name="ln235">	while (true) {</a>
<a name="ln236">		if (bytesLeft == 0) {</a>
<a name="ln237">			cookie.state++;</a>
<a name="ln238"> </a>
<a name="ln239">			// handle option overload in file and/or server_name fields.</a>
<a name="ln240">			switch (cookie.state) {</a>
<a name="ln241">				case 2:</a>
<a name="ln242">					// options from &quot;file&quot; field</a>
<a name="ln243">					if (cookie.file_has_options) {</a>
<a name="ln244">						bytesLeft = sizeof(file);</a>
<a name="ln245">						cookie.next = file;</a>
<a name="ln246">					}</a>
<a name="ln247">					break;</a>
<a name="ln248"> </a>
<a name="ln249">				case 3:</a>
<a name="ln250">					// options from &quot;server_name&quot; field</a>
<a name="ln251">					if (cookie.server_name_has_options) {</a>
<a name="ln252">						bytesLeft = sizeof(server_name);</a>
<a name="ln253">						cookie.next = server_name;</a>
<a name="ln254">					}</a>
<a name="ln255">					break;</a>
<a name="ln256"> </a>
<a name="ln257">				default:</a>
<a name="ln258">					// no more place to look for options</a>
<a name="ln259">					// if last option is not OPTION_END,</a>
<a name="ln260">					// there is no space left for other option!</a>
<a name="ln261">					if (option != OPTION_END)</a>
<a name="ln262">						cookie.next = NULL;</a>
<a name="ln263">					return false;</a>
<a name="ln264">			}</a>
<a name="ln265"> </a>
<a name="ln266">			if (bytesLeft == 0) {</a>
<a name="ln267">				// no options in this state, try next one</a>
<a name="ln268">				continue;</a>
<a name="ln269">			}</a>
<a name="ln270">		}</a>
<a name="ln271"> </a>
<a name="ln272">		option = (message_option)cookie.next[0];</a>
<a name="ln273">		if (option == OPTION_END) {</a>
<a name="ln274">			bytesLeft = 0;</a>
<a name="ln275">			continue;</a>
<a name="ln276">		} else if (option == OPTION_PAD) {</a>
<a name="ln277">			bytesLeft--;</a>
<a name="ln278">			cookie.next++;</a>
<a name="ln279">			continue;</a>
<a name="ln280">		}</a>
<a name="ln281"> </a>
<a name="ln282">		size = cookie.next[1];</a>
<a name="ln283">		data = &amp;cookie.next[2];</a>
<a name="ln284">		cookie.next += 2 + size;</a>
<a name="ln285">		bytesLeft -= 2 + size;</a>
<a name="ln286"> </a>
<a name="ln287">		if (option == OPTION_OVERLOAD) {</a>
<a name="ln288">			cookie.file_has_options = data[0] &amp; 1;</a>
<a name="ln289">			cookie.server_name_has_options = data[0] &amp; 2;</a>
<a name="ln290">			continue;</a>
<a name="ln291">		}</a>
<a name="ln292"> </a>
<a name="ln293">		return true;</a>
<a name="ln294">	}</a>
<a name="ln295">}</a>
<a name="ln296"> </a>
<a name="ln297"> </a>
<a name="ln298">const uint8*</a>
<a name="ln299">dhcp_message::FindOption(message_option which) const</a>
<a name="ln300">{</a>
<a name="ln301">	dhcp_option_cookie cookie;</a>
<a name="ln302">	message_option option;</a>
<a name="ln303">	const uint8* data;</a>
<a name="ln304">	size_t size;</a>
<a name="ln305">	while (NextOption(cookie, option, data, size)) {</a>
<a name="ln306">		// iterate through all options</a>
<a name="ln307">		if (option == which)</a>
<a name="ln308">			return data;</a>
<a name="ln309">	}</a>
<a name="ln310"> </a>
<a name="ln311">	return NULL;</a>
<a name="ln312">}</a>
<a name="ln313"> </a>
<a name="ln314"> </a>
<a name="ln315">const uint8*</a>
<a name="ln316">dhcp_message::LastOption() const</a>
<a name="ln317">{</a>
<a name="ln318">	dhcp_option_cookie cookie;</a>
<a name="ln319">	message_option option;</a>
<a name="ln320">	const uint8* data;</a>
<a name="ln321">	size_t size;</a>
<a name="ln322">	while (NextOption(cookie, option, data, size)) {</a>
<a name="ln323">		// iterate through all options</a>
<a name="ln324">	}</a>
<a name="ln325"> </a>
<a name="ln326">	return cookie.next;</a>
<a name="ln327">}</a>
<a name="ln328"> </a>
<a name="ln329"> </a>
<a name="ln330">message_type</a>
<a name="ln331">dhcp_message::Type() const</a>
<a name="ln332">{</a>
<a name="ln333">	const uint8* data = FindOption(OPTION_MESSAGE_TYPE);</a>
<a name="ln334">	if (data)</a>
<a name="ln335">		return (message_type)data[0];</a>
<a name="ln336"> </a>
<a name="ln337">	return DHCP_NONE;</a>
<a name="ln338">}</a>
<a name="ln339"> </a>
<a name="ln340"> </a>
<a name="ln341">size_t</a>
<a name="ln342">dhcp_message::Size() const</a>
<a name="ln343">{</a>
<a name="ln344">	const uint8* last = LastOption();</a>
<a name="ln345"> </a>
<a name="ln346">	if (last &lt; options) {</a>
<a name="ln347">		// if last option is stored above &quot;options&quot; field, it means</a>
<a name="ln348">		// the whole options field and message is already filled...</a>
<a name="ln349">		return sizeof(dhcp_message);</a>
<a name="ln350">	}</a>
<a name="ln351"> </a>
<a name="ln352">	return sizeof(dhcp_message) - sizeof(options) + last + 1 - options;</a>
<a name="ln353">}</a>
<a name="ln354"> </a>
<a name="ln355"> </a>
<a name="ln356">uint8*</a>
<a name="ln357">dhcp_message::PrepareMessage(uint8 type)</a>
<a name="ln358">{</a>
<a name="ln359">	uint8* next = options;</a>
<a name="ln360">	next = PutOption(next, OPTION_MESSAGE_TYPE, type);</a>
<a name="ln361">	next = PutOption(next, OPTION_MAX_MESSAGE_SIZE,</a>
<a name="ln362">		(uint16)htons(sizeof(dhcp_message)));</a>
<a name="ln363">	return next;</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366"> </a>
<a name="ln367">uint8*</a>
<a name="ln368">dhcp_message::PutOption(uint8* options, message_option option)</a>
<a name="ln369">{</a>
<a name="ln370">	options[0] = option;</a>
<a name="ln371">	return options + 1;</a>
<a name="ln372">}</a>
<a name="ln373"> </a>
<a name="ln374"> </a>
<a name="ln375">uint8*</a>
<a name="ln376">dhcp_message::PutOption(uint8* options, message_option option, uint8 data)</a>
<a name="ln377">{</a>
<a name="ln378">	return PutOption(options, option, &amp;data, 1);</a>
<a name="ln379">}</a>
<a name="ln380"> </a>
<a name="ln381"> </a>
<a name="ln382">uint8*</a>
<a name="ln383">dhcp_message::PutOption(uint8* options, message_option option, uint16 data)</a>
<a name="ln384">{</a>
<a name="ln385">	return PutOption(options, option, (uint8*)&amp;data, sizeof(data));</a>
<a name="ln386">}</a>
<a name="ln387"> </a>
<a name="ln388"> </a>
<a name="ln389">uint8*</a>
<a name="ln390">dhcp_message::PutOption(uint8* options, message_option option, uint32 data)</a>
<a name="ln391">{</a>
<a name="ln392">	return PutOption(options, option, (uint8*)&amp;data, sizeof(data));</a>
<a name="ln393">}</a>
<a name="ln394"> </a>
<a name="ln395"> </a>
<a name="ln396">uint8*</a>
<a name="ln397">dhcp_message::PutOption(uint8* options, message_option option,</a>
<a name="ln398">	const uint8* data, uint32 size)</a>
<a name="ln399">{</a>
<a name="ln400">	// TODO: check enough space is available</a>
<a name="ln401"> </a>
<a name="ln402">	options[0] = option;</a>
<a name="ln403">	options[1] = size;</a>
<a name="ln404">	memcpy(&amp;options[2], data, size);</a>
<a name="ln405"> </a>
<a name="ln406">	return options + 2 + size;</a>
<a name="ln407">}</a>
<a name="ln408"> </a>
<a name="ln409"> </a>
<a name="ln410">uint8*</a>
<a name="ln411">dhcp_message::FinishOptions(uint8* options)</a>
<a name="ln412">{</a>
<a name="ln413">	return PutOption(options, OPTION_END);</a>
<a name="ln414">}</a>
<a name="ln415"> </a>
<a name="ln416"> </a>
<a name="ln417">/*static*/ const char*</a>
<a name="ln418">dhcp_message::TypeToString(message_type type)</a>
<a name="ln419">{</a>
<a name="ln420">	switch (type) {</a>
<a name="ln421">#define CASE(x) case x: return #x;</a>
<a name="ln422">		CASE(DHCP_NONE)</a>
<a name="ln423">		CASE(DHCP_DISCOVER)</a>
<a name="ln424">		CASE(DHCP_OFFER)</a>
<a name="ln425">		CASE(DHCP_REQUEST)</a>
<a name="ln426">		CASE(DHCP_DECLINE)</a>
<a name="ln427">		CASE(DHCP_ACK)</a>
<a name="ln428">		CASE(DHCP_NACK)</a>
<a name="ln429">		CASE(DHCP_RELEASE)</a>
<a name="ln430">		CASE(DHCP_INFORM)</a>
<a name="ln431">#undef CASE</a>
<a name="ln432">	}</a>
<a name="ln433"> </a>
<a name="ln434">	return &quot;&lt;unknown&gt;&quot;;</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437"> </a>
<a name="ln438">void</a>
<a name="ln439">socket_timeout::UpdateSocket(int socket) const</a>
<a name="ln440">{</a>
<a name="ln441">	struct timeval value;</a>
<a name="ln442">	value.tv_sec = timeout / 1000000;</a>
<a name="ln443">	value.tv_usec = timeout % 1000000;</a>
<a name="ln444">	setsockopt(socket, SOL_SOCKET, SO_RCVTIMEO, &amp;value, sizeof(value));</a>
<a name="ln445">}</a>
<a name="ln446"> </a>
<a name="ln447"> </a>
<a name="ln448">bool</a>
<a name="ln449">socket_timeout::Shift(int socket, bigtime_t stateMaxTime, const char* device)</a>
<a name="ln450">{</a>
<a name="ln451">	tries++;</a>
<a name="ln452">	timeout += timeout;</a>
<a name="ln453">	if (timeout &gt; AS_USECS(MAX_TIMEOUT))</a>
<a name="ln454">		timeout = AS_USECS(MAX_TIMEOUT);</a>
<a name="ln455"> </a>
<a name="ln456">	if (tries &gt; MAX_RETRIES) {</a>
<a name="ln457">		if (stateMaxTime == -1)</a>
<a name="ln458">			return false;</a>
<a name="ln459">		bigtime_t remaining = (stateMaxTime - system_time()) / 2 + 1;</a>
<a name="ln460">		timeout = std::max(remaining, bigtime_t(60));</a>
<a name="ln461">	}</a>
<a name="ln462"> </a>
<a name="ln463">	syslog(LOG_DEBUG, &quot;%s: Timeout shift: %lu msecs (try %lu)\n&quot;,</a>
<a name="ln464">		device, timeout / 1000, tries);</a>
<a name="ln465"> </a>
<a name="ln466">	UpdateSocket(socket);</a>
<a name="ln467">	return true;</a>
<a name="ln468">}</a>
<a name="ln469"> </a>
<a name="ln470"> </a>
<a name="ln471">//	#pragma mark -</a>
<a name="ln472"> </a>
<a name="ln473"> </a>
<a name="ln474">DHCPClient::DHCPClient(BMessenger target, const char* device)</a>
<a name="ln475">	:</a>
<a name="ln476">	AutoconfigClient(&quot;dhcp&quot;, target, device),</a>
<a name="ln477">	fConfiguration(kMsgConfigureInterface),</a>
<a name="ln478">	fResolverConfiguration(kMsgConfigureResolver),</a>
<a name="ln479">	fRunner(NULL),</a>
<a name="ln480">	fAssignedAddress(0),</a>
<a name="ln481">	fServer(AF_INET, NULL, DHCP_SERVER_PORT, B_UNCONFIGURED_ADDRESS_FAMILIES),</a>
<a name="ln482">	fLeaseTime(0)</a>
<a name="ln483">{</a>
<a name="ln484">	fTransactionID = (uint32)system_time() ^ rand();</a>
<a name="ln485"> </a>
<a name="ln486">	BNetworkAddress link;</a>
<a name="ln487">	BNetworkInterface interface(device);</a>
<a name="ln488">	fStatus = interface.GetHardwareAddress(link);</a>
<a name="ln489">	if (fStatus != B_OK)</a>
<a name="ln490">		return;</a>
<a name="ln491"> </a>
<a name="ln492">	memcpy(fMAC, link.LinkLevelAddress(), sizeof(fMAC));</a>
<a name="ln493"> </a>
<a name="ln494">	if ((interface.Flags() &amp; IFF_AUTO_CONFIGURED) != 0) {</a>
<a name="ln495">		// Check for interface previous auto-configured address, if any.</a>
<a name="ln496">		BNetworkInterfaceAddress interfaceAddress;</a>
<a name="ln497">		int index = interface.FindFirstAddress(AF_INET);</a>
<a name="ln498">		if (index &gt;= 0</a>
<a name="ln499">			&amp;&amp; interface.GetAddressAt(index, interfaceAddress) == B_OK) {</a>
<a name="ln500">			BNetworkAddress address = interfaceAddress.Address();</a>
<a name="ln501">			const sockaddr_in&amp; addr = (sockaddr_in&amp;)address.SockAddr();</a>
<a name="ln502">			fAssignedAddress = addr.sin_addr.s_addr;</a>
<a name="ln503"> </a>
<a name="ln504">			if ((ntohl(fAssignedAddress) &amp; IN_CLASSB_NET) == 0xa9fe0000) {</a>
<a name="ln505">				// previous auto-configured address is a link-local one:</a>
<a name="ln506">				// there is no point asking a DHCP server to renew such</a>
<a name="ln507">				// server-less assigned address...</a>
<a name="ln508">				fAssignedAddress = 0;</a>
<a name="ln509">			}</a>
<a name="ln510">		}</a>
<a name="ln511">	}</a>
<a name="ln512"> </a>
<a name="ln513">	openlog_thread(&quot;DHCP&quot;, 0, LOG_DAEMON);</a>
<a name="ln514">}</a>
<a name="ln515"> </a>
<a name="ln516"> </a>
<a name="ln517">DHCPClient::~DHCPClient()</a>
<a name="ln518">{</a>
<a name="ln519">	if (fStatus != B_OK)</a>
<a name="ln520">		return;</a>
<a name="ln521"> </a>
<a name="ln522">	delete fRunner;</a>
<a name="ln523"> </a>
<a name="ln524">	int socket = ::socket(AF_INET, SOCK_DGRAM, 0);</a>
<a name="ln525">	if (socket &lt; 0)</a>
<a name="ln526">		return;</a>
<a name="ln527"> </a>
<a name="ln528">	// release lease</a>
<a name="ln529"> </a>
<a name="ln530">	dhcp_message release(DHCP_RELEASE);</a>
<a name="ln531">	_PrepareMessage(release, BOUND);</a>
<a name="ln532"> </a>
<a name="ln533">	_SendMessage(socket, release, fServer);</a>
<a name="ln534">	close(socket);</a>
<a name="ln535"> </a>
<a name="ln536">	closelog_thread();</a>
<a name="ln537">}</a>
<a name="ln538"> </a>
<a name="ln539"> </a>
<a name="ln540">status_t</a>
<a name="ln541">DHCPClient::Initialize()</a>
<a name="ln542">{</a>
<a name="ln543">	fStatus = _Negotiate(fAssignedAddress == 0 ? INIT : INIT_REBOOT);</a>
<a name="ln544">	syslog(LOG_DEBUG, &quot;%s: DHCP status = %s\n&quot;, Device(), strerror(fStatus));</a>
<a name="ln545">	return fStatus;</a>
<a name="ln546">}</a>
<a name="ln547"> </a>
<a name="ln548"> </a>
<a name="ln549">status_t</a>
<a name="ln550">DHCPClient::_Negotiate(dhcp_state state)</a>
<a name="ln551">{</a>
<a name="ln552">	if (state == BOUND)</a>
<a name="ln553">		return B_OK;</a>
<a name="ln554"> </a>
<a name="ln555">	fStartTime = system_time();</a>
<a name="ln556">	fTransactionID++;</a>
<a name="ln557"> </a>
<a name="ln558">	char hostName[MAXHOSTNAMELEN];</a>
<a name="ln559">	if (gethostname(hostName, MAXHOSTNAMELEN) == 0)</a>
<a name="ln560">		fHostName.SetTo(hostName, MAXHOSTNAMELEN);</a>
<a name="ln561">	else</a>
<a name="ln562">		fHostName.Truncate(0);</a>
<a name="ln563"> </a>
<a name="ln564">	int socket = ::socket(AF_INET, SOCK_DGRAM, 0);</a>
<a name="ln565">	if (socket &lt; 0)</a>
<a name="ln566">		return errno;</a>
<a name="ln567"> </a>
<a name="ln568">	// Enable reusing the port. This is needed in case there is more</a>
<a name="ln569">	// than 1 interface that needs to be configured. Note that the only reason</a>
<a name="ln570">	// this works is because there is code below to bind to a specific</a>
<a name="ln571">	// interface.</a>
<a name="ln572">	int option = 1;</a>
<a name="ln573">	setsockopt(socket, SOL_SOCKET, SO_REUSEPORT, &amp;option, sizeof(option));</a>
<a name="ln574"> </a>
<a name="ln575">	BNetworkAddress local;</a>
<a name="ln576">	local.SetToWildcard(AF_INET, DHCP_CLIENT_PORT);</a>
<a name="ln577"> </a>
<a name="ln578">	option = 1;</a>
<a name="ln579">	setsockopt(socket, SOL_SOCKET, SO_BROADCAST, &amp;option, sizeof(option));</a>
<a name="ln580"> </a>
<a name="ln581">	if (bind(socket, local, local.Length()) &lt; 0) {</a>
<a name="ln582">		close(socket);</a>
<a name="ln583">		return errno;</a>
<a name="ln584">	}</a>
<a name="ln585"> </a>
<a name="ln586">	bigtime_t previousLeaseTime = fLeaseTime;</a>
<a name="ln587"> </a>
<a name="ln588">	status_t status = B_OK;</a>
<a name="ln589">	while (state != BOUND) {</a>
<a name="ln590">		status = _StateTransition(socket, state);</a>
<a name="ln591">		if (status != B_OK &amp;&amp; (state == SELECTING || state == REBOOTING))</a>
<a name="ln592">			break;</a>
<a name="ln593">	}</a>
<a name="ln594"> </a>
<a name="ln595">	close(socket);</a>
<a name="ln596"> </a>
<a name="ln597">	if (fLeaseTime == 0)</a>
<a name="ln598">		fLeaseTime = previousLeaseTime;</a>
<a name="ln599">	if (fLeaseTime == 0)</a>
<a name="ln600">		fLeaseTime = 60;</a>
<a name="ln601"> </a>
<a name="ln602">	if (fRenewalTime == 0)</a>
<a name="ln603">		fRenewalTime = fLeaseTime / 2;</a>
<a name="ln604">	if (fRebindingTime == 0)</a>
<a name="ln605">		fRebindingTime = fLeaseTime * 7 / 8;</a>
<a name="ln606">	fLeaseTime += fRequestTime;</a>
<a name="ln607">	fRenewalTime += fRequestTime;</a>
<a name="ln608">	fRebindingTime += fRequestTime;</a>
<a name="ln609">	_RestartLease(fRenewalTime);</a>
<a name="ln610"> </a>
<a name="ln611">	fStatus = status;</a>
<a name="ln612">	if (status)</a>
<a name="ln613">		return status;</a>
<a name="ln614"> </a>
<a name="ln615">	// configure interface</a>
<a name="ln616">	BMessage reply;</a>
<a name="ln617">	status = Target().SendMessage(&amp;fConfiguration, &amp;reply);</a>
<a name="ln618">	if (status == B_OK)</a>
<a name="ln619">		status = reply.FindInt32(&quot;status&quot;, &amp;fStatus);</a>
<a name="ln620"> </a>
<a name="ln621">	// configure resolver</a>
<a name="ln622">	reply.MakeEmpty();</a>
<a name="ln623">	fResolverConfiguration.AddString(&quot;device&quot;, Device());</a>
<a name="ln624">	status = Target().SendMessage(&amp;fResolverConfiguration, &amp;reply);</a>
<a name="ln625">	if (status == B_OK)</a>
<a name="ln626">		status = reply.FindInt32(&quot;status&quot;, &amp;fStatus);</a>
<a name="ln627">	return status;</a>
<a name="ln628">}</a>
<a name="ln629"> </a>
<a name="ln630"> </a>
<a name="ln631">status_t</a>
<a name="ln632">DHCPClient::_GotMessage(dhcp_state&amp; state, dhcp_message* message)</a>
<a name="ln633">{</a>
<a name="ln634">	switch (state) {</a>
<a name="ln635">		case SELECTING:</a>
<a name="ln636">			if (message-&gt;Type() == DHCP_OFFER) {</a>
<a name="ln637">				state = REQUESTING;</a>
<a name="ln638"> </a>
<a name="ln639">				fAssignedAddress = message-&gt;your_address;</a>
<a name="ln640">				syslog(LOG_INFO, &quot;  your_address: %s\n&quot;,</a>
<a name="ln641">						_AddressToString(fAssignedAddress).String());</a>
<a name="ln642"> </a>
<a name="ln643">				fConfiguration.MakeEmpty();</a>
<a name="ln644">				fConfiguration.AddString(&quot;device&quot;, Device());</a>
<a name="ln645">				fConfiguration.AddBool(&quot;auto_configured&quot;, true);</a>
<a name="ln646"> </a>
<a name="ln647">				BMessage address;</a>
<a name="ln648">				address.AddString(&quot;family&quot;, &quot;inet&quot;);</a>
<a name="ln649">				address.AddString(&quot;address&quot;, _AddressToString(fAssignedAddress));</a>
<a name="ln650">				fResolverConfiguration.MakeEmpty();</a>
<a name="ln651">				_ParseOptions(*message, address, fResolverConfiguration);</a>
<a name="ln652"> </a>
<a name="ln653">				fConfiguration.AddMessage(&quot;address&quot;, &amp;address);</a>
<a name="ln654">				return B_OK;</a>
<a name="ln655">			}</a>
<a name="ln656"> </a>
<a name="ln657">			return B_BAD_VALUE;</a>
<a name="ln658"> </a>
<a name="ln659">		case REBOOTING:</a>
<a name="ln660">		case REBINDING:</a>
<a name="ln661">		case RENEWING:</a>
<a name="ln662">		case REQUESTING:</a>
<a name="ln663">			if (message-&gt;Type() == DHCP_ACK) {</a>
<a name="ln664">				// TODO: we might want to configure the stuff, don't we?</a>
<a name="ln665">				BMessage address;</a>
<a name="ln666">				fResolverConfiguration.MakeEmpty();</a>
<a name="ln667">				_ParseOptions(*message, address, fResolverConfiguration);</a>
<a name="ln668">					// TODO: currently, only lease time and DNS is updated this</a>
<a name="ln669">					// way</a>
<a name="ln670"> </a>
<a name="ln671">				// our address request has been acknowledged</a>
<a name="ln672">				state = BOUND;</a>
<a name="ln673"> </a>
<a name="ln674">				return B_OK;</a>
<a name="ln675">			}</a>
<a name="ln676"> </a>
<a name="ln677">			if (message-&gt;Type() == DHCP_NACK) {</a>
<a name="ln678">				// server reject our request on previous assigned address</a>
<a name="ln679">				// back to square one...</a>
<a name="ln680">				fAssignedAddress = 0;</a>
<a name="ln681">				state = INIT;</a>
<a name="ln682">				return B_OK;</a>
<a name="ln683">			}</a>
<a name="ln684"> </a>
<a name="ln685">		default:</a>
<a name="ln686">			return B_BAD_VALUE;</a>
<a name="ln687">	}</a>
<a name="ln688">}</a>
<a name="ln689"> </a>
<a name="ln690"> </a>
<a name="ln691">status_t</a>
<a name="ln692">DHCPClient::_StateTransition(int socket, dhcp_state&amp; state)</a>
<a name="ln693">{</a>
<a name="ln694">	if (state == INIT) {</a>
<a name="ln695">		// The local interface does not have an address yet, bind the socket</a>
<a name="ln696">		// to the device directly.</a>
<a name="ln697">		BNetworkDevice device(Device());</a>
<a name="ln698">		int index = device.Index();</a>
<a name="ln699"> </a>
<a name="ln700">		setsockopt(socket, SOL_SOCKET, SO_BINDTODEVICE, &amp;index, sizeof(int));</a>
<a name="ln701">	}</a>
<a name="ln702"> </a>
<a name="ln703">	BNetworkAddress broadcast;</a>
<a name="ln704">	broadcast.SetToBroadcast(AF_INET, DHCP_SERVER_PORT);</a>
<a name="ln705"> </a>
<a name="ln706">	socket_timeout timeout(socket);</a>
<a name="ln707"> </a>
<a name="ln708">	dhcp_message discover(DHCP_DISCOVER);</a>
<a name="ln709">	_PrepareMessage(discover, state);</a>
<a name="ln710"> </a>
<a name="ln711">	dhcp_message request(DHCP_REQUEST);</a>
<a name="ln712">	_PrepareMessage(request, state);</a>
<a name="ln713"> </a>
<a name="ln714">	bool skipRequest = false;</a>
<a name="ln715">	dhcp_state originalState = state;</a>
<a name="ln716">	fRequestTime = system_time();</a>
<a name="ln717">	while (true) {</a>
<a name="ln718">		if (!skipRequest) {</a>
<a name="ln719">			_SendMessage(socket, originalState == INIT ? discover : request,</a>
<a name="ln720">				originalState == RENEWING ? fServer : broadcast);</a>
<a name="ln721"> </a>
<a name="ln722">			if (originalState == INIT)</a>
<a name="ln723">				state = SELECTING;</a>
<a name="ln724">			else if (originalState == INIT_REBOOT)</a>
<a name="ln725">				state = REBOOTING;</a>
<a name="ln726">		}</a>
<a name="ln727"> </a>
<a name="ln728">		char buffer[2048];</a>
<a name="ln729">		struct sockaddr_in from;</a>
<a name="ln730">		socklen_t fromLength = sizeof(from);</a>
<a name="ln731">		ssize_t bytesReceived = recvfrom(socket, buffer, sizeof(buffer),</a>
<a name="ln732">			0, (struct sockaddr*)&amp;from, &amp;fromLength);</a>
<a name="ln733">		if (bytesReceived &lt; 0 &amp;&amp; errno == B_TIMED_OUT) {</a>
<a name="ln734">			// depending on the state, we'll just try again</a>
<a name="ln735">			if (!_TimeoutShift(socket, state, timeout))</a>
<a name="ln736">				return B_TIMED_OUT;</a>
<a name="ln737">			skipRequest = false;</a>
<a name="ln738">			continue;</a>
<a name="ln739">		} else if (bytesReceived &lt; 0)</a>
<a name="ln740">			return errno;</a>
<a name="ln741"> </a>
<a name="ln742">		skipRequest = true;</a>
<a name="ln743">		dhcp_message* message = (dhcp_message*)buffer;</a>
<a name="ln744">		if (message-&gt;transaction_id != htonl(fTransactionID)</a>
<a name="ln745">			|| !message-&gt;HasOptions()</a>
<a name="ln746">			|| memcmp(message-&gt;mac_address, discover.mac_address,</a>
<a name="ln747">				discover.hardware_address_length)) {</a>
<a name="ln748">			// this message is not for us</a>
<a name="ln749">			syslog(LOG_DEBUG, &quot;%s: Ignoring %s not for us from %s\n&quot;,</a>
<a name="ln750">				Device(), dhcp_message::TypeToString(message-&gt;Type()),</a>
<a name="ln751">				_AddressToString(from.sin_addr.s_addr).String());</a>
<a name="ln752">			continue;</a>
<a name="ln753">		}</a>
<a name="ln754"> </a>
<a name="ln755">		syslog(LOG_DEBUG, &quot;%s: Received %s from %s\n&quot;,</a>
<a name="ln756">			Device(), dhcp_message::TypeToString(message-&gt;Type()),</a>
<a name="ln757">			_AddressToString(from.sin_addr.s_addr).String());</a>
<a name="ln758"> </a>
<a name="ln759">		if (_GotMessage(state, message) == B_OK)</a>
<a name="ln760">			break;</a>
<a name="ln761">	}</a>
<a name="ln762"> </a>
<a name="ln763">	return B_OK;</a>
<a name="ln764">}</a>
<a name="ln765"> </a>
<a name="ln766"> </a>
<a name="ln767">void</a>
<a name="ln768">DHCPClient::_RestartLease(bigtime_t leaseTime)</a>
<a name="ln769">{</a>
<a name="ln770">	if (leaseTime == 0)</a>
<a name="ln771">		return;</a>
<a name="ln772"> </a>
<a name="ln773">	BMessage lease(kMsgLeaseTime);</a>
<a name="ln774">	fRunner = new BMessageRunner(this, &amp;lease, leaseTime - system_time(), 1);</a>
<a name="ln775">}</a>
<a name="ln776"> </a>
<a name="ln777"> </a>
<a name="ln778">void</a>
<a name="ln779">DHCPClient::_ParseOptions(dhcp_message&amp; message, BMessage&amp; address,</a>
<a name="ln780">	BMessage&amp; resolverConfiguration)</a>
<a name="ln781">{</a>
<a name="ln782">	dhcp_option_cookie cookie;</a>
<a name="ln783">	message_option option;</a>
<a name="ln784">	const uint8* data;</a>
<a name="ln785">	size_t size;</a>
<a name="ln786">	while (message.NextOption(cookie, option, data, size)) {</a>
<a name="ln787">		// iterate through all options</a>
<a name="ln788">		switch (option) {</a>
<a name="ln789">			case OPTION_ROUTER_ADDRESS:</a>
<a name="ln790">				syslog(LOG_DEBUG, &quot;  gateway: %s\n&quot;,</a>
<a name="ln791">					_AddressToString(data).String());</a>
<a name="ln792">				address.AddString(&quot;gateway&quot;, _AddressToString(data));</a>
<a name="ln793">				break;</a>
<a name="ln794">			case OPTION_SUBNET_MASK:</a>
<a name="ln795">				syslog(LOG_DEBUG, &quot;  subnet: %s\n&quot;,</a>
<a name="ln796">					_AddressToString(data).String());</a>
<a name="ln797">				address.AddString(&quot;mask&quot;, _AddressToString(data));</a>
<a name="ln798">				break;</a>
<a name="ln799">			case OPTION_BROADCAST_ADDRESS:</a>
<a name="ln800">				syslog(LOG_DEBUG, &quot;  broadcast: %s\n&quot;,</a>
<a name="ln801">					_AddressToString(data).String());</a>
<a name="ln802">				address.AddString(&quot;broadcast&quot;, _AddressToString(data));</a>
<a name="ln803">				break;</a>
<a name="ln804">			case OPTION_DOMAIN_NAME_SERVER:</a>
<a name="ln805">			{</a>
<a name="ln806">				for (uint32 i = 0; i &lt; size / 4; i++) {</a>
<a name="ln807">					syslog(LOG_DEBUG, &quot;  nameserver[%d]: %s\n&quot;, i,</a>
<a name="ln808">						_AddressToString(&amp;data[i * 4]).String());</a>
<a name="ln809">					resolverConfiguration.AddString(&quot;nameserver&quot;,</a>
<a name="ln810">						_AddressToString(&amp;data[i * 4]).String());</a>
<a name="ln811">				}</a>
<a name="ln812">				resolverConfiguration.AddInt32(&quot;nameserver_count&quot;,</a>
<a name="ln813">					size / 4);</a>
<a name="ln814">				break;</a>
<a name="ln815">			}</a>
<a name="ln816">			case OPTION_SERVER_ADDRESS:</a>
<a name="ln817">			{</a>
<a name="ln818">				syslog(LOG_DEBUG, &quot;  server: %s\n&quot;,</a>
<a name="ln819">					_AddressToString(data).String());</a>
<a name="ln820">				status_t status = fServer.SetAddress(*(in_addr_t*)data);</a>
<a name="ln821">				if (status != B_OK) {</a>
<a name="ln822">					syslog(LOG_ERR, &quot;   BNetworkAddress::SetAddress failed with %s!\n&quot;,</a>
<a name="ln823">						strerror(status));</a>
<a name="ln824">					fServer.Unset();</a>
<a name="ln825">				}</a>
<a name="ln826">				break;</a>
<a name="ln827">			}</a>
<a name="ln828"> </a>
<a name="ln829">			case OPTION_ADDRESS_LEASE_TIME:</a>
<a name="ln830">				syslog(LOG_DEBUG, &quot;  lease time: %lu seconds\n&quot;,</a>
<a name="ln831">					ntohl(*(uint32*)data));</a>
<a name="ln832">				fLeaseTime = ntohl(*(uint32*)data) * 1000000LL;</a>
<a name="ln833">				break;</a>
<a name="ln834">			case OPTION_RENEWAL_TIME:</a>
<a name="ln835">				syslog(LOG_DEBUG, &quot;  renewal time: %lu seconds\n&quot;,</a>
<a name="ln836">					ntohl(*(uint32*)data));</a>
<a name="ln837">				fRenewalTime = ntohl(*(uint32*)data) * 1000000LL;</a>
<a name="ln838">				break;</a>
<a name="ln839">			case OPTION_REBINDING_TIME:</a>
<a name="ln840">				syslog(LOG_DEBUG, &quot;  rebinding time: %lu seconds\n&quot;,</a>
<a name="ln841">					ntohl(*(uint32*)data));</a>
<a name="ln842">				fRebindingTime = ntohl(*(uint32*)data) * 1000000LL;</a>
<a name="ln843">				break;</a>
<a name="ln844"> </a>
<a name="ln845">			case OPTION_HOST_NAME:</a>
<a name="ln846">				syslog(LOG_DEBUG, &quot;  host name: \&quot;%.*s\&quot;\n&quot;, (int)size,</a>
<a name="ln847">					(const char*)data);</a>
<a name="ln848">				break;</a>
<a name="ln849"> </a>
<a name="ln850">			case OPTION_DOMAIN_NAME:</a>
<a name="ln851">			{</a>
<a name="ln852">				char domain[256];</a>
<a name="ln853">				strlcpy(domain, (const char*)data,</a>
<a name="ln854">					min_c(size + 1, sizeof(domain)));</a>
<a name="ln855"> </a>
<a name="ln856">				syslog(LOG_DEBUG, &quot;  domain name: \&quot;%s\&quot;\n&quot;, domain);</a>
<a name="ln857"> </a>
<a name="ln858">				resolverConfiguration.AddString(&quot;domain&quot;, domain);</a>
<a name="ln859">				break;</a>
<a name="ln860">			}</a>
<a name="ln861"> </a>
<a name="ln862">			case OPTION_MESSAGE_TYPE:</a>
<a name="ln863">				break;</a>
<a name="ln864"> </a>
<a name="ln865">			case OPTION_ERROR_MESSAGE:</a>
<a name="ln866">				syslog(LOG_INFO, &quot;  error message: \&quot;%.*s\&quot;\n&quot;, (int)size,</a>
<a name="ln867">					(const char*)data);</a>
<a name="ln868">				break;</a>
<a name="ln869"> </a>
<a name="ln870">			default:</a>
<a name="ln871">				syslog(LOG_DEBUG, &quot;  UNKNOWN OPTION %lu (0x%x)\n&quot;,</a>
<a name="ln872">					(uint32)option, (uint32)option);</a>
<a name="ln873">				break;</a>
<a name="ln874">		}</a>
<a name="ln875">	}</a>
<a name="ln876">}</a>
<a name="ln877"> </a>
<a name="ln878"> </a>
<a name="ln879">void</a>
<a name="ln880">DHCPClient::_PrepareMessage(dhcp_message&amp; message, dhcp_state state)</a>
<a name="ln881">{</a>
<a name="ln882">	message.opcode = BOOT_REQUEST;</a>
<a name="ln883">	message.hardware_type = ARP_HARDWARE_TYPE_ETHER;</a>
<a name="ln884">	message.hardware_address_length = 6;</a>
<a name="ln885">	message.transaction_id = htonl(fTransactionID);</a>
<a name="ln886">	message.seconds_since_start = htons(min_c((system_time() - fStartTime)</a>
<a name="ln887">		/ 1000000LL, 65535));</a>
<a name="ln888">	memcpy(message.mac_address, fMAC, 6);</a>
<a name="ln889"> </a>
<a name="ln890">	message_type type = message.Type();</a>
<a name="ln891"> </a>
<a name="ln892">	uint8 *next = message.PrepareMessage(type);</a>
<a name="ln893"> </a>
<a name="ln894">	switch (type) {</a>
<a name="ln895">		case DHCP_DISCOVER:</a>
<a name="ln896">			next = message.PutOption(next, OPTION_REQUEST_PARAMETERS,</a>
<a name="ln897">				kRequestParameters, sizeof(kRequestParameters));</a>
<a name="ln898"> </a>
<a name="ln899">			if (fHostName.Length() &gt; 0) {</a>
<a name="ln900">				next = message.PutOption(next, OPTION_HOST_NAME,</a>
<a name="ln901">					reinterpret_cast&lt;const uint8*&gt;(fHostName.String()),</a>
<a name="ln902">					fHostName.Length());</a>
<a name="ln903">			}</a>
<a name="ln904">			break;</a>
<a name="ln905"> </a>
<a name="ln906">		case DHCP_REQUEST:</a>
<a name="ln907">			next = message.PutOption(next, OPTION_REQUEST_PARAMETERS,</a>
<a name="ln908">				kRequestParameters, sizeof(kRequestParameters));</a>
<a name="ln909"> </a>
<a name="ln910">			if (fHostName.Length() &gt; 0) {</a>
<a name="ln911">				next = message.PutOption(next, OPTION_HOST_NAME,</a>
<a name="ln912">					reinterpret_cast&lt;const uint8*&gt;(fHostName.String()),</a>
<a name="ln913">					fHostName.Length());</a>
<a name="ln914">			}</a>
<a name="ln915"> </a>
<a name="ln916">			if (state == REQUESTING) {</a>
<a name="ln917">				const sockaddr_in&amp; server = (sockaddr_in&amp;)fServer.SockAddr();</a>
<a name="ln918">				next = message.PutOption(next, OPTION_SERVER_ADDRESS,</a>
<a name="ln919">					(uint32)server.sin_addr.s_addr);</a>
<a name="ln920">			}</a>
<a name="ln921"> </a>
<a name="ln922">			if (state == INIT || state == INIT_REBOOT</a>
<a name="ln923">				|| state == REQUESTING) {</a>
<a name="ln924">				next = message.PutOption(next, OPTION_REQUEST_IP_ADDRESS,</a>
<a name="ln925">					(uint32)fAssignedAddress);</a>
<a name="ln926">			} else</a>
<a name="ln927">				message.client_address = fAssignedAddress;</a>
<a name="ln928">			break;</a>
<a name="ln929"> </a>
<a name="ln930">		case DHCP_RELEASE: {</a>
<a name="ln931">			const sockaddr_in&amp; server = (sockaddr_in&amp;)fServer.SockAddr();</a>
<a name="ln932">			next = message.PutOption(next, OPTION_SERVER_ADDRESS,</a>
<a name="ln933">				(uint32)server.sin_addr.s_addr);</a>
<a name="ln934"> </a>
<a name="ln935">			message.client_address = fAssignedAddress;</a>
<a name="ln936">			break;</a>
<a name="ln937">		}</a>
<a name="ln938"> </a>
<a name="ln939">		default:</a>
<a name="ln940">			break;</a>
<a name="ln941">	}</a>
<a name="ln942"> </a>
<a name="ln943">	message.FinishOptions(next);</a>
<a name="ln944">}</a>
<a name="ln945"> </a>
<a name="ln946"> </a>
<a name="ln947">bool</a>
<a name="ln948">DHCPClient::_TimeoutShift(int socket, dhcp_state&amp; state,</a>
<a name="ln949">	socket_timeout&amp; timeout)</a>
<a name="ln950">{</a>
<a name="ln951">	bigtime_t stateMaxTime = -1;</a>
<a name="ln952"> </a>
<a name="ln953">	// Compute the date at which we must consider the DHCP negociation failed.</a>
<a name="ln954">	// This varies depending on the current state. In renewing and rebinding</a>
<a name="ln955">	// states, it is based on the lease expiration.</a>
<a name="ln956">	// We can stay for up to 1 minute in the selecting and requesting states</a>
<a name="ln957">	// (these correspond to sending DHCP_DISCOVER and DHCP_REQUEST,</a>
<a name="ln958">	// respectively).</a>
<a name="ln959">	// All other states time out immediately after a single try.</a>
<a name="ln960">	// If this timeout expires, the DHCP negociation is aborted and starts</a>
<a name="ln961">	// over. As long as the timeout is not expired, we repeat the message with</a>
<a name="ln962">	// increasing delays (the delay is computed in timeout.shift below, and is</a>
<a name="ln963">	// at most equal to the timeout, but usually much shorter).</a>
<a name="ln964">	if (state == RENEWING)</a>
<a name="ln965">		stateMaxTime = fRebindingTime;</a>
<a name="ln966">	else if (state == REBINDING)</a>
<a name="ln967">		stateMaxTime = fLeaseTime;</a>
<a name="ln968">	else if (state == SELECTING || state == REQUESTING)</a>
<a name="ln969">		stateMaxTime = fRequestTime + AS_USECS(MAX_TIMEOUT);</a>
<a name="ln970"> </a>
<a name="ln971">	if (system_time() &gt; stateMaxTime) {</a>
<a name="ln972">		state = state == REBINDING ? INIT : REBINDING;</a>
<a name="ln973">		return false;</a>
<a name="ln974">	}</a>
<a name="ln975"> </a>
<a name="ln976">	return timeout.Shift(socket, stateMaxTime, Device());</a>
<a name="ln977">}</a>
<a name="ln978"> </a>
<a name="ln979"> </a>
<a name="ln980">/*static*/ BString</a>
<a name="ln981">DHCPClient::_AddressToString(const uint8* data)</a>
<a name="ln982">{</a>
<a name="ln983">	BString target = inet_ntoa(*(in_addr*)data);</a>
<a name="ln984">	return target;</a>
<a name="ln985">}</a>
<a name="ln986"> </a>
<a name="ln987"> </a>
<a name="ln988">/*static*/ BString</a>
<a name="ln989">DHCPClient::_AddressToString(in_addr_t address)</a>
<a name="ln990">{</a>
<a name="ln991">	BString target = inet_ntoa(*(in_addr*)&amp;address);</a>
<a name="ln992">	return target;</a>
<a name="ln993">}</a>
<a name="ln994"> </a>
<a name="ln995"> </a>
<a name="ln996">status_t</a>
<a name="ln997">DHCPClient::_SendMessage(int socket, dhcp_message&amp; message,</a>
<a name="ln998">	const BNetworkAddress&amp; address) const</a>
<a name="ln999">{</a>
<a name="ln1000">	message_type type = message.Type();</a>
<a name="ln1001">	BString text;</a>
<a name="ln1002">	text &lt;&lt; dhcp_message::TypeToString(type);</a>
<a name="ln1003"> </a>
<a name="ln1004">	const uint8* requestAddress = message.FindOption(OPTION_REQUEST_IP_ADDRESS);</a>
<a name="ln1005">	if (type == DHCP_REQUEST &amp;&amp; requestAddress != NULL)</a>
<a name="ln1006">		text &lt;&lt; &quot; for &quot; &lt;&lt; _AddressToString(requestAddress).String();</a>
<a name="ln1007"> </a>
<a name="ln1008">	syslog(LOG_DEBUG, &quot;%s: Send %s to %s\n&quot;, Device(), text.String(),</a>
<a name="ln1009">		address.ToString().String());</a>
<a name="ln1010"> </a>
<a name="ln1011">	ssize_t bytesSent = sendto(socket, &amp;message, message.Size(),</a>
<a name="ln1012">		address.IsBroadcast() ? MSG_BCAST : 0, address, address.Length());</a>
<a name="ln1013">	if (bytesSent &lt; 0)</a>
<a name="ln1014">		return errno;</a>
<a name="ln1015"> </a>
<a name="ln1016">	return B_OK;</a>
<a name="ln1017">}</a>
<a name="ln1018"> </a>
<a name="ln1019"> </a>
<a name="ln1020">dhcp_state</a>
<a name="ln1021">DHCPClient::_CurrentState() const</a>
<a name="ln1022">{</a>
<a name="ln1023">	bigtime_t now = system_time();</a>
<a name="ln1024"> </a>
<a name="ln1025">	if (now &gt; fLeaseTime || fStatus != B_OK)</a>
<a name="ln1026">		return INIT;</a>
<a name="ln1027">	if (now &gt;= fRebindingTime)</a>
<a name="ln1028">		return REBINDING;</a>
<a name="ln1029">	if (now &gt;= fRenewalTime)</a>
<a name="ln1030">		return RENEWING;</a>
<a name="ln1031">	return BOUND;</a>
<a name="ln1032">}</a>
<a name="ln1033"> </a>
<a name="ln1034"> </a>
<a name="ln1035">void</a>
<a name="ln1036">DHCPClient::MessageReceived(BMessage* message)</a>
<a name="ln1037">{</a>
<a name="ln1038">	switch (message-&gt;what) {</a>
<a name="ln1039">		case kMsgLeaseTime:</a>
<a name="ln1040">			_Negotiate(_CurrentState());</a>
<a name="ln1041">			break;</a>
<a name="ln1042"> </a>
<a name="ln1043">		default:</a>
<a name="ln1044">			BHandler::MessageReceived(message);</a>
<a name="ln1045">			break;</a>
<a name="ln1046">	}</a>
<a name="ln1047">}</a>

</code></pre>
<div class="balloon" rel="830"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'syslog' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="835"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'syslog' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="463"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fifth actual argument of the 'syslog' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="840"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'syslog' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="871"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'syslog' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="474"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fStartTime, fRequestTime, fRenewalTime, fRebindingTime.</p></div>
<div class="balloon" rel="101"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: next.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
