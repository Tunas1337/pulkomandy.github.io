
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>if_re.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * SPDX-License-Identifier: BSD-4-Clause</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 1997, 1998-2003</a>
<a name="ln5"> *	Bill Paul &lt;wpaul@windriver.com&gt;.  All rights reserved.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln8"> * modification, are permitted provided that the following conditions</a>
<a name="ln9"> * are met:</a>
<a name="ln10"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln11"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln12"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln13"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln14"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln15"> * 3. All advertising materials mentioning features or use of this software</a>
<a name="ln16"> *    must display the following acknowledgement:</a>
<a name="ln17"> *	This product includes software developed by Bill Paul.</a>
<a name="ln18"> * 4. Neither the name of the author nor the names of any co-contributors</a>
<a name="ln19"> *    may be used to endorse or promote products derived from this software</a>
<a name="ln20"> *    without specific prior written permission.</a>
<a name="ln21"> *</a>
<a name="ln22"> * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln23"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln24"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln25"> * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD</a>
<a name="ln26"> * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</a>
<a name="ln27"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</a>
<a name="ln28"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</a>
<a name="ln29"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</a>
<a name="ln30"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</a>
<a name="ln31"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF</a>
<a name="ln32"> * THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln33"> */</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln36">__FBSDID(&quot;$FreeBSD: releng/12.0/sys/dev/re/if_re.c 333813 2018-05-18 20:13:34Z mmacy $&quot;);</a>
<a name="ln37"> </a>
<a name="ln38">/*</a>
<a name="ln39"> * RealTek 8139C+/8169/8169S/8110S/8168/8111/8101E PCI NIC driver</a>
<a name="ln40"> *</a>
<a name="ln41"> * Written by Bill Paul &lt;wpaul@windriver.com&gt;</a>
<a name="ln42"> * Senior Networking Software Engineer</a>
<a name="ln43"> * Wind River Systems</a>
<a name="ln44"> */</a>
<a name="ln45"> </a>
<a name="ln46">/*</a>
<a name="ln47"> * This driver is designed to support RealTek's next generation of</a>
<a name="ln48"> * 10/100 and 10/100/1000 PCI ethernet controllers. There are currently</a>
<a name="ln49"> * seven devices in this family: the RTL8139C+, the RTL8169, the RTL8169S,</a>
<a name="ln50"> * RTL8110S, the RTL8168, the RTL8111 and the RTL8101E.</a>
<a name="ln51"> *</a>
<a name="ln52"> * The 8139C+ is a 10/100 ethernet chip. It is backwards compatible</a>
<a name="ln53"> * with the older 8139 family, however it also supports a special</a>
<a name="ln54"> * C+ mode of operation that provides several new performance enhancing</a>
<a name="ln55"> * features. These include:</a>
<a name="ln56"> *</a>
<a name="ln57"> *	o Descriptor based DMA mechanism. Each descriptor represents</a>
<a name="ln58"> *	  a single packet fragment. Data buffers may be aligned on</a>
<a name="ln59"> *	  any byte boundary.</a>
<a name="ln60"> *</a>
<a name="ln61"> *	o 64-bit DMA</a>
<a name="ln62"> *</a>
<a name="ln63"> *	o TCP/IP checksum offload for both RX and TX</a>
<a name="ln64"> *</a>
<a name="ln65"> *	o High and normal priority transmit DMA rings</a>
<a name="ln66"> *</a>
<a name="ln67"> *	o VLAN tag insertion and extraction</a>
<a name="ln68"> *</a>
<a name="ln69"> *	o TCP large send (segmentation offload)</a>
<a name="ln70"> *</a>
<a name="ln71"> * Like the 8139, the 8139C+ also has a built-in 10/100 PHY. The C+</a>
<a name="ln72"> * programming API is fairly straightforward. The RX filtering, EEPROM</a>
<a name="ln73"> * access and PHY access is the same as it is on the older 8139 series</a>
<a name="ln74"> * chips.</a>
<a name="ln75"> *</a>
<a name="ln76"> * The 8169 is a 64-bit 10/100/1000 gigabit ethernet MAC. It has almost the</a>
<a name="ln77"> * same programming API and feature set as the 8139C+ with the following</a>
<a name="ln78"> * differences and additions:</a>
<a name="ln79"> *</a>
<a name="ln80"> *	o 1000Mbps mode</a>
<a name="ln81"> *</a>
<a name="ln82"> *	o Jumbo frames</a>
<a name="ln83"> *</a>
<a name="ln84"> *	o GMII and TBI ports/registers for interfacing with copper</a>
<a name="ln85"> *	  or fiber PHYs</a>
<a name="ln86"> *</a>
<a name="ln87"> *	o RX and TX DMA rings can have up to 1024 descriptors</a>
<a name="ln88"> *	  (the 8139C+ allows a maximum of 64)</a>
<a name="ln89"> *</a>
<a name="ln90"> *	o Slight differences in register layout from the 8139C+</a>
<a name="ln91"> *</a>
<a name="ln92"> * The TX start and timer interrupt registers are at different locations</a>
<a name="ln93"> * on the 8169 than they are on the 8139C+. Also, the status word in the</a>
<a name="ln94"> * RX descriptor has a slightly different bit layout. The 8169 does not</a>
<a name="ln95"> * have a built-in PHY. Most reference boards use a Marvell 88E1000 'Alaska'</a>
<a name="ln96"> * copper gigE PHY.</a>
<a name="ln97"> *</a>
<a name="ln98"> * The 8169S/8110S 10/100/1000 devices have built-in copper gigE PHYs</a>
<a name="ln99"> * (the 'S' stands for 'single-chip'). These devices have the same</a>
<a name="ln100"> * programming API as the older 8169, but also have some vendor-specific</a>
<a name="ln101"> * registers for the on-board PHY. The 8110S is a LAN-on-motherboard</a>
<a name="ln102"> * part designed to be pin-compatible with the RealTek 8100 10/100 chip.</a>
<a name="ln103"> *</a>
<a name="ln104"> * This driver takes advantage of the RX and TX checksum offload and</a>
<a name="ln105"> * VLAN tag insertion/extraction features. It also implements TX</a>
<a name="ln106"> * interrupt moderation using the timer interrupt registers, which</a>
<a name="ln107"> * significantly reduces TX interrupt load. There is also support</a>
<a name="ln108"> * for jumbo frames, however the 8169/8169S/8110S can not transmit</a>
<a name="ln109"> * jumbo frames larger than 7440, so the max MTU possible with this</a>
<a name="ln110"> * driver is 7422 bytes.</a>
<a name="ln111"> */</a>
<a name="ln112"> </a>
<a name="ln113">#ifdef HAVE_KERNEL_OPTION_HEADERS</a>
<a name="ln114">#include &quot;opt_device_polling.h&quot;</a>
<a name="ln115">#endif</a>
<a name="ln116"> </a>
<a name="ln117">#include &lt;sys/param.h&gt;</a>
<a name="ln118">#include &lt;sys/endian.h&gt;</a>
<a name="ln119">#include &lt;sys/systm.h&gt;</a>
<a name="ln120">#include &lt;sys/sockio.h&gt;</a>
<a name="ln121">#include &lt;sys/mbuf.h&gt;</a>
<a name="ln122">#include &lt;sys/malloc.h&gt;</a>
<a name="ln123">#include &lt;sys/module.h&gt;</a>
<a name="ln124">#include &lt;sys/kernel.h&gt;</a>
<a name="ln125">#include &lt;sys/socket.h&gt;</a>
<a name="ln126">#include &lt;sys/lock.h&gt;</a>
<a name="ln127">#include &lt;sys/mutex.h&gt;</a>
<a name="ln128">#include &lt;sys/sysctl.h&gt;</a>
<a name="ln129">#include &lt;sys/taskqueue.h&gt;</a>
<a name="ln130"> </a>
<a name="ln131">#include &lt;net/if.h&gt;</a>
<a name="ln132">#include &lt;net/if_var.h&gt;</a>
<a name="ln133">#include &lt;net/if_arp.h&gt;</a>
<a name="ln134">#include &lt;net/ethernet.h&gt;</a>
<a name="ln135">#include &lt;net/if_dl.h&gt;</a>
<a name="ln136">#include &lt;net/if_media.h&gt;</a>
<a name="ln137">#include &lt;net/if_types.h&gt;</a>
<a name="ln138">#include &lt;net/if_vlan_var.h&gt;</a>
<a name="ln139"> </a>
<a name="ln140">#include &lt;net/bpf.h&gt;</a>
<a name="ln141"> </a>
<a name="ln142">#include &lt;netinet/netdump/netdump.h&gt;</a>
<a name="ln143"> </a>
<a name="ln144">#include &lt;machine/bus.h&gt;</a>
<a name="ln145">#include &lt;machine/resource.h&gt;</a>
<a name="ln146">#include &lt;sys/bus.h&gt;</a>
<a name="ln147">#include &lt;sys/rman.h&gt;</a>
<a name="ln148"> </a>
<a name="ln149">#include &lt;dev/mii/mii.h&gt;</a>
<a name="ln150">#include &lt;dev/mii/miivar.h&gt;</a>
<a name="ln151"> </a>
<a name="ln152">#include &lt;dev/pci/pcireg.h&gt;</a>
<a name="ln153">#include &lt;dev/pci/pcivar.h&gt;</a>
<a name="ln154"> </a>
<a name="ln155">#include &lt;dev/rl/if_rlreg.h&gt;</a>
<a name="ln156"> </a>
<a name="ln157">MODULE_DEPEND(re, pci, 1, 1, 1);</a>
<a name="ln158">MODULE_DEPEND(re, ether, 1, 1, 1);</a>
<a name="ln159">MODULE_DEPEND(re, miibus, 1, 1, 1);</a>
<a name="ln160"> </a>
<a name="ln161">/* &quot;device miibus&quot; required.  See GENERIC if you get errors here. */</a>
<a name="ln162">#include &quot;miibus_if.h&quot;</a>
<a name="ln163"> </a>
<a name="ln164">/* Tunables. */</a>
<a name="ln165">static int intr_filter = 0;</a>
<a name="ln166">TUNABLE_INT(&quot;hw.re.intr_filter&quot;, &amp;intr_filter);</a>
<a name="ln167">static int msi_disable = 0;</a>
<a name="ln168">TUNABLE_INT(&quot;hw.re.msi_disable&quot;, &amp;msi_disable);</a>
<a name="ln169">static int msix_disable = 0;</a>
<a name="ln170">TUNABLE_INT(&quot;hw.re.msix_disable&quot;, &amp;msix_disable);</a>
<a name="ln171">static int prefer_iomap = 0;</a>
<a name="ln172">TUNABLE_INT(&quot;hw.re.prefer_iomap&quot;, &amp;prefer_iomap);</a>
<a name="ln173"> </a>
<a name="ln174">#define RE_CSUM_FEATURES    (CSUM_IP | CSUM_TCP | CSUM_UDP)</a>
<a name="ln175"> </a>
<a name="ln176">/*</a>
<a name="ln177"> * Various supported device vendors/types and their names.</a>
<a name="ln178"> */</a>
<a name="ln179">static const struct rl_type re_devs[] = {</a>
<a name="ln180">	{ DLINK_VENDORID, DLINK_DEVICEID_528T, 0,</a>
<a name="ln181">	    &quot;D-Link DGE-528(T) Gigabit Ethernet Adapter&quot; },</a>
<a name="ln182">	{ DLINK_VENDORID, DLINK_DEVICEID_530T_REVC, 0,</a>
<a name="ln183">	    &quot;D-Link DGE-530(T) Gigabit Ethernet Adapter&quot; },</a>
<a name="ln184">	{ RT_VENDORID, RT_DEVICEID_8139, 0,</a>
<a name="ln185">	    &quot;RealTek 8139C+ 10/100BaseTX&quot; },</a>
<a name="ln186">	{ RT_VENDORID, RT_DEVICEID_8101E, 0,</a>
<a name="ln187">	    &quot;RealTek 810xE PCIe 10/100baseTX&quot; },</a>
<a name="ln188">	{ RT_VENDORID, RT_DEVICEID_8168, 0,</a>
<a name="ln189">	    &quot;RealTek 8168/8111 B/C/CP/D/DP/E/F/G PCIe Gigabit Ethernet&quot; },</a>
<a name="ln190">	{ NCUBE_VENDORID, RT_DEVICEID_8168, 0,</a>
<a name="ln191">	    &quot;TP-Link TG-3468 v2 (RTL8168) Gigabit Ethernet&quot; },</a>
<a name="ln192">	{ RT_VENDORID, RT_DEVICEID_8169, 0,</a>
<a name="ln193">	    &quot;RealTek 8169/8169S/8169SB(L)/8110S/8110SB(L) Gigabit Ethernet&quot; },</a>
<a name="ln194">	{ RT_VENDORID, RT_DEVICEID_8169SC, 0,</a>
<a name="ln195">	    &quot;RealTek 8169SC/8110SC Single-chip Gigabit Ethernet&quot; },</a>
<a name="ln196">	{ COREGA_VENDORID, COREGA_DEVICEID_CGLAPCIGT, 0,</a>
<a name="ln197">	    &quot;Corega CG-LAPCIGT (RTL8169S) Gigabit Ethernet&quot; },</a>
<a name="ln198">	{ LINKSYS_VENDORID, LINKSYS_DEVICEID_EG1032, 0,</a>
<a name="ln199">	    &quot;Linksys EG1032 (RTL8169S) Gigabit Ethernet&quot; },</a>
<a name="ln200">	{ USR_VENDORID, USR_DEVICEID_997902, 0,</a>
<a name="ln201">	    &quot;US Robotics 997902 (RTL8169S) Gigabit Ethernet&quot; }</a>
<a name="ln202">};</a>
<a name="ln203"> </a>
<a name="ln204">static const struct rl_hwrev re_hwrevs[] = {</a>
<a name="ln205">	{ RL_HWREV_8139, RL_8139, &quot;&quot;, RL_MTU },</a>
<a name="ln206">	{ RL_HWREV_8139A, RL_8139, &quot;A&quot;, RL_MTU },</a>
<a name="ln207">	{ RL_HWREV_8139AG, RL_8139, &quot;A-G&quot;, RL_MTU },</a>
<a name="ln208">	{ RL_HWREV_8139B, RL_8139, &quot;B&quot;, RL_MTU },</a>
<a name="ln209">	{ RL_HWREV_8130, RL_8139, &quot;8130&quot;, RL_MTU },</a>
<a name="ln210">	{ RL_HWREV_8139C, RL_8139, &quot;C&quot;, RL_MTU },</a>
<a name="ln211">	{ RL_HWREV_8139D, RL_8139, &quot;8139D/8100B/8100C&quot;, RL_MTU },</a>
<a name="ln212">	{ RL_HWREV_8139CPLUS, RL_8139CPLUS, &quot;C+&quot;, RL_MTU },</a>
<a name="ln213">	{ RL_HWREV_8168B_SPIN1, RL_8169, &quot;8168&quot;, RL_JUMBO_MTU },</a>
<a name="ln214">	{ RL_HWREV_8169, RL_8169, &quot;8169&quot;, RL_JUMBO_MTU },</a>
<a name="ln215">	{ RL_HWREV_8169S, RL_8169, &quot;8169S&quot;, RL_JUMBO_MTU },</a>
<a name="ln216">	{ RL_HWREV_8110S, RL_8169, &quot;8110S&quot;, RL_JUMBO_MTU },</a>
<a name="ln217">	{ RL_HWREV_8169_8110SB, RL_8169, &quot;8169SB/8110SB&quot;, RL_JUMBO_MTU },</a>
<a name="ln218">	{ RL_HWREV_8169_8110SC, RL_8169, &quot;8169SC/8110SC&quot;, RL_JUMBO_MTU },</a>
<a name="ln219">	{ RL_HWREV_8169_8110SBL, RL_8169, &quot;8169SBL/8110SBL&quot;, RL_JUMBO_MTU },</a>
<a name="ln220">	{ RL_HWREV_8169_8110SCE, RL_8169, &quot;8169SC/8110SC&quot;, RL_JUMBO_MTU },</a>
<a name="ln221">	{ RL_HWREV_8100, RL_8139, &quot;8100&quot;, RL_MTU },</a>
<a name="ln222">	{ RL_HWREV_8101, RL_8139, &quot;8101&quot;, RL_MTU },</a>
<a name="ln223">	{ RL_HWREV_8100E, RL_8169, &quot;8100E&quot;, RL_MTU },</a>
<a name="ln224">	{ RL_HWREV_8101E, RL_8169, &quot;8101E&quot;, RL_MTU },</a>
<a name="ln225">	{ RL_HWREV_8102E, RL_8169, &quot;8102E&quot;, RL_MTU },</a>
<a name="ln226">	{ RL_HWREV_8102EL, RL_8169, &quot;8102EL&quot;, RL_MTU },</a>
<a name="ln227">	{ RL_HWREV_8102EL_SPIN1, RL_8169, &quot;8102EL&quot;, RL_MTU },</a>
<a name="ln228">	{ RL_HWREV_8103E, RL_8169, &quot;8103E&quot;, RL_MTU },</a>
<a name="ln229">	{ RL_HWREV_8401E, RL_8169, &quot;8401E&quot;, RL_MTU },</a>
<a name="ln230">	{ RL_HWREV_8402, RL_8169, &quot;8402&quot;, RL_MTU },</a>
<a name="ln231">	{ RL_HWREV_8105E, RL_8169, &quot;8105E&quot;, RL_MTU },</a>
<a name="ln232">	{ RL_HWREV_8105E_SPIN1, RL_8169, &quot;8105E&quot;, RL_MTU },</a>
<a name="ln233">	{ RL_HWREV_8106E, RL_8169, &quot;8106E&quot;, RL_MTU },</a>
<a name="ln234">	{ RL_HWREV_8168B_SPIN2, RL_8169, &quot;8168&quot;, RL_JUMBO_MTU },</a>
<a name="ln235">	{ RL_HWREV_8168B_SPIN3, RL_8169, &quot;8168&quot;, RL_JUMBO_MTU },</a>
<a name="ln236">	{ RL_HWREV_8168C, RL_8169, &quot;8168C/8111C&quot;, RL_JUMBO_MTU_6K },</a>
<a name="ln237">	{ RL_HWREV_8168C_SPIN2, RL_8169, &quot;8168C/8111C&quot;, RL_JUMBO_MTU_6K },</a>
<a name="ln238">	{ RL_HWREV_8168CP, RL_8169, &quot;8168CP/8111CP&quot;, RL_JUMBO_MTU_6K },</a>
<a name="ln239">	{ RL_HWREV_8168D, RL_8169, &quot;8168D/8111D&quot;, RL_JUMBO_MTU_9K },</a>
<a name="ln240">	{ RL_HWREV_8168DP, RL_8169, &quot;8168DP/8111DP&quot;, RL_JUMBO_MTU_9K },</a>
<a name="ln241">	{ RL_HWREV_8168E, RL_8169, &quot;8168E/8111E&quot;, RL_JUMBO_MTU_9K},</a>
<a name="ln242">	{ RL_HWREV_8168E_VL, RL_8169, &quot;8168E/8111E-VL&quot;, RL_JUMBO_MTU_6K},</a>
<a name="ln243">	{ RL_HWREV_8168EP, RL_8169, &quot;8168EP/8111EP&quot;, RL_JUMBO_MTU_9K},</a>
<a name="ln244">	{ RL_HWREV_8168F, RL_8169, &quot;8168F/8111F&quot;, RL_JUMBO_MTU_9K},</a>
<a name="ln245">	{ RL_HWREV_8168G, RL_8169, &quot;8168G/8111G&quot;, RL_JUMBO_MTU_9K},</a>
<a name="ln246">	{ RL_HWREV_8168GU, RL_8169, &quot;8168GU/8111GU&quot;, RL_JUMBO_MTU_9K},</a>
<a name="ln247">	{ RL_HWREV_8168H, RL_8169, &quot;8168H/8111H&quot;, RL_JUMBO_MTU_9K},</a>
<a name="ln248">	{ RL_HWREV_8411, RL_8169, &quot;8411&quot;, RL_JUMBO_MTU_9K},</a>
<a name="ln249">	{ RL_HWREV_8411B, RL_8169, &quot;8411B&quot;, RL_JUMBO_MTU_9K},</a>
<a name="ln250">	{ 0, 0, NULL, 0 }</a>
<a name="ln251">};</a>
<a name="ln252"> </a>
<a name="ln253">static int re_probe		(device_t);</a>
<a name="ln254">static int re_attach		(device_t);</a>
<a name="ln255">static int re_detach		(device_t);</a>
<a name="ln256"> </a>
<a name="ln257">static int re_encap		(struct rl_softc *, struct mbuf **);</a>
<a name="ln258"> </a>
<a name="ln259">static void re_dma_map_addr	(void *, bus_dma_segment_t *, int, int);</a>
<a name="ln260">static int re_allocmem		(device_t, struct rl_softc *);</a>
<a name="ln261">static __inline void re_discard_rxbuf</a>
<a name="ln262">				(struct rl_softc *, int);</a>
<a name="ln263">static int re_newbuf		(struct rl_softc *, int);</a>
<a name="ln264">static int re_jumbo_newbuf	(struct rl_softc *, int);</a>
<a name="ln265">static int re_rx_list_init	(struct rl_softc *);</a>
<a name="ln266">static int re_jrx_list_init	(struct rl_softc *);</a>
<a name="ln267">static int re_tx_list_init	(struct rl_softc *);</a>
<a name="ln268">#ifdef RE_FIXUP_RX</a>
<a name="ln269">static __inline void re_fixup_rx</a>
<a name="ln270">				(struct mbuf *);</a>
<a name="ln271">#endif</a>
<a name="ln272">static int re_rxeof		(struct rl_softc *, int *);</a>
<a name="ln273">static void re_txeof		(struct rl_softc *);</a>
<a name="ln274">#ifdef DEVICE_POLLING</a>
<a name="ln275">static int re_poll		(struct ifnet *, enum poll_cmd, int);</a>
<a name="ln276">static int re_poll_locked	(struct ifnet *, enum poll_cmd, int);</a>
<a name="ln277">#endif</a>
<a name="ln278">static int re_intr		(void *);</a>
<a name="ln279">static void re_intr_msi		(void *);</a>
<a name="ln280">static void re_tick		(void *);</a>
<a name="ln281">static void re_int_task		(void *, int);</a>
<a name="ln282">static void re_start		(struct ifnet *);</a>
<a name="ln283">static void re_start_locked	(struct ifnet *);</a>
<a name="ln284">static void re_start_tx		(struct rl_softc *);</a>
<a name="ln285">static int re_ioctl		(struct ifnet *, u_long, caddr_t);</a>
<a name="ln286">static void re_init		(void *);</a>
<a name="ln287">static void re_init_locked	(struct rl_softc *);</a>
<a name="ln288">static void re_stop		(struct rl_softc *);</a>
<a name="ln289">static void re_watchdog		(struct rl_softc *);</a>
<a name="ln290">static int re_suspend		(device_t);</a>
<a name="ln291">static int re_resume		(device_t);</a>
<a name="ln292">static int re_shutdown		(device_t);</a>
<a name="ln293">static int re_ifmedia_upd	(struct ifnet *);</a>
<a name="ln294">static void re_ifmedia_sts	(struct ifnet *, struct ifmediareq *);</a>
<a name="ln295"> </a>
<a name="ln296">static void re_eeprom_putbyte	(struct rl_softc *, int);</a>
<a name="ln297">static void re_eeprom_getword	(struct rl_softc *, int, u_int16_t *);</a>
<a name="ln298">static void re_read_eeprom	(struct rl_softc *, caddr_t, int, int);</a>
<a name="ln299">static int re_gmii_readreg	(device_t, int, int);</a>
<a name="ln300">static int re_gmii_writereg	(device_t, int, int, int);</a>
<a name="ln301"> </a>
<a name="ln302">static int re_miibus_readreg	(device_t, int, int);</a>
<a name="ln303">static int re_miibus_writereg	(device_t, int, int, int);</a>
<a name="ln304">static void re_miibus_statchg	(device_t);</a>
<a name="ln305"> </a>
<a name="ln306">static void re_set_jumbo	(struct rl_softc *, int);</a>
<a name="ln307">static void re_set_rxmode		(struct rl_softc *);</a>
<a name="ln308">static void re_reset		(struct rl_softc *);</a>
<a name="ln309">static void re_setwol		(struct rl_softc *);</a>
<a name="ln310">static void re_clrwol		(struct rl_softc *);</a>
<a name="ln311">static void re_set_linkspeed	(struct rl_softc *);</a>
<a name="ln312"> </a>
<a name="ln313">NETDUMP_DEFINE(re);</a>
<a name="ln314"> </a>
<a name="ln315">#ifdef DEV_NETMAP	/* see ixgbe.c for details */</a>
<a name="ln316">#include &lt;dev/netmap/if_re_netmap.h&gt;</a>
<a name="ln317">MODULE_DEPEND(re, netmap, 1, 1, 1);</a>
<a name="ln318">#endif /* !DEV_NETMAP */</a>
<a name="ln319"> </a>
<a name="ln320">#ifdef RE_DIAG</a>
<a name="ln321">static int re_diag		(struct rl_softc *);</a>
<a name="ln322">#endif</a>
<a name="ln323"> </a>
<a name="ln324">static void re_add_sysctls	(struct rl_softc *);</a>
<a name="ln325">static int re_sysctl_stats	(SYSCTL_HANDLER_ARGS);</a>
<a name="ln326">static int sysctl_int_range	(SYSCTL_HANDLER_ARGS, int, int);</a>
<a name="ln327">static int sysctl_hw_re_int_mod	(SYSCTL_HANDLER_ARGS);</a>
<a name="ln328"> </a>
<a name="ln329">static device_method_t re_methods[] = {</a>
<a name="ln330">	/* Device interface */</a>
<a name="ln331">	DEVMETHOD(device_probe,		re_probe),</a>
<a name="ln332">	DEVMETHOD(device_attach,	re_attach),</a>
<a name="ln333">	DEVMETHOD(device_detach,	re_detach),</a>
<a name="ln334">	DEVMETHOD(device_suspend,	re_suspend),</a>
<a name="ln335">	DEVMETHOD(device_resume,	re_resume),</a>
<a name="ln336">	DEVMETHOD(device_shutdown,	re_shutdown),</a>
<a name="ln337"> </a>
<a name="ln338">	/* MII interface */</a>
<a name="ln339">	DEVMETHOD(miibus_readreg,	re_miibus_readreg),</a>
<a name="ln340">	DEVMETHOD(miibus_writereg,	re_miibus_writereg),</a>
<a name="ln341">	DEVMETHOD(miibus_statchg,	re_miibus_statchg),</a>
<a name="ln342"> </a>
<a name="ln343">	DEVMETHOD_END</a>
<a name="ln344">};</a>
<a name="ln345"> </a>
<a name="ln346">static driver_t re_driver = {</a>
<a name="ln347">	&quot;re&quot;,</a>
<a name="ln348">	re_methods,</a>
<a name="ln349">	sizeof(struct rl_softc)</a>
<a name="ln350">};</a>
<a name="ln351"> </a>
<a name="ln352">static devclass_t re_devclass;</a>
<a name="ln353"> </a>
<a name="ln354">DRIVER_MODULE(re, pci, re_driver, re_devclass, 0, 0);</a>
<a name="ln355">DRIVER_MODULE(miibus, re, miibus_driver, miibus_devclass, 0, 0);</a>
<a name="ln356"> </a>
<a name="ln357">#define EE_SET(x)					\</a>
<a name="ln358">	CSR_WRITE_1(sc, RL_EECMD,			\</a>
<a name="ln359">		CSR_READ_1(sc, RL_EECMD) | x)</a>
<a name="ln360"> </a>
<a name="ln361">#define EE_CLR(x)					\</a>
<a name="ln362">	CSR_WRITE_1(sc, RL_EECMD,			\</a>
<a name="ln363">		CSR_READ_1(sc, RL_EECMD) &amp; ~x)</a>
<a name="ln364"> </a>
<a name="ln365">/*</a>
<a name="ln366"> * Send a read command and address to the EEPROM, check for ACK.</a>
<a name="ln367"> */</a>
<a name="ln368">static void</a>
<a name="ln369">re_eeprom_putbyte(struct rl_softc *sc, int addr)</a>
<a name="ln370">{</a>
<a name="ln371">	int			d, i;</a>
<a name="ln372"> </a>
<a name="ln373">	d = addr | (RL_9346_READ &lt;&lt; sc-&gt;rl_eewidth);</a>
<a name="ln374"> </a>
<a name="ln375">	/*</a>
<a name="ln376">	 * Feed in each bit and strobe the clock.</a>
<a name="ln377">	 */</a>
<a name="ln378"> </a>
<a name="ln379">	for (i = 1 &lt;&lt; (sc-&gt;rl_eewidth + 3); i; i &gt;&gt;= 1) {</a>
<a name="ln380">		if (d &amp; i) {</a>
<a name="ln381">			EE_SET(RL_EE_DATAIN);</a>
<a name="ln382">		} else {</a>
<a name="ln383">			EE_CLR(RL_EE_DATAIN);</a>
<a name="ln384">		}</a>
<a name="ln385">		DELAY(100);</a>
<a name="ln386">		EE_SET(RL_EE_CLK);</a>
<a name="ln387">		DELAY(150);</a>
<a name="ln388">		EE_CLR(RL_EE_CLK);</a>
<a name="ln389">		DELAY(100);</a>
<a name="ln390">	}</a>
<a name="ln391">}</a>
<a name="ln392"> </a>
<a name="ln393">/*</a>
<a name="ln394"> * Read a word of data stored in the EEPROM at address 'addr.'</a>
<a name="ln395"> */</a>
<a name="ln396">static void</a>
<a name="ln397">re_eeprom_getword(struct rl_softc *sc, int addr, u_int16_t *dest)</a>
<a name="ln398">{</a>
<a name="ln399">	int			i;</a>
<a name="ln400">	u_int16_t		word = 0;</a>
<a name="ln401"> </a>
<a name="ln402">	/*</a>
<a name="ln403">	 * Send address of word we want to read.</a>
<a name="ln404">	 */</a>
<a name="ln405">	re_eeprom_putbyte(sc, addr);</a>
<a name="ln406"> </a>
<a name="ln407">	/*</a>
<a name="ln408">	 * Start reading bits from EEPROM.</a>
<a name="ln409">	 */</a>
<a name="ln410">	for (i = 0x8000; i; i &gt;&gt;= 1) {</a>
<a name="ln411">		EE_SET(RL_EE_CLK);</a>
<a name="ln412">		DELAY(100);</a>
<a name="ln413">		if (CSR_READ_1(sc, RL_EECMD) &amp; RL_EE_DATAOUT)</a>
<a name="ln414">			word |= i;</a>
<a name="ln415">		EE_CLR(RL_EE_CLK);</a>
<a name="ln416">		DELAY(100);</a>
<a name="ln417">	}</a>
<a name="ln418"> </a>
<a name="ln419">	*dest = word;</a>
<a name="ln420">}</a>
<a name="ln421"> </a>
<a name="ln422">/*</a>
<a name="ln423"> * Read a sequence of words from the EEPROM.</a>
<a name="ln424"> */</a>
<a name="ln425">static void</a>
<a name="ln426">re_read_eeprom(struct rl_softc *sc, caddr_t dest, int off, int cnt)</a>
<a name="ln427">{</a>
<a name="ln428">	int			i;</a>
<a name="ln429">	u_int16_t		word = 0, *ptr;</a>
<a name="ln430"> </a>
<a name="ln431">	CSR_SETBIT_1(sc, RL_EECMD, RL_EEMODE_PROGRAM);</a>
<a name="ln432"> </a>
<a name="ln433">        DELAY(100);</a>
<a name="ln434"> </a>
<a name="ln435">	for (i = 0; i &lt; cnt; i++) {</a>
<a name="ln436">		CSR_SETBIT_1(sc, RL_EECMD, RL_EE_SEL);</a>
<a name="ln437">		re_eeprom_getword(sc, off + i, &amp;word);</a>
<a name="ln438">		CSR_CLRBIT_1(sc, RL_EECMD, RL_EE_SEL);</a>
<a name="ln439">		ptr = (u_int16_t *)(dest + (i * 2));</a>
<a name="ln440">                *ptr = word;</a>
<a name="ln441">	}</a>
<a name="ln442"> </a>
<a name="ln443">	CSR_CLRBIT_1(sc, RL_EECMD, RL_EEMODE_PROGRAM);</a>
<a name="ln444">}</a>
<a name="ln445"> </a>
<a name="ln446">static int</a>
<a name="ln447">re_gmii_readreg(device_t dev, int phy, int reg)</a>
<a name="ln448">{</a>
<a name="ln449">	struct rl_softc		*sc;</a>
<a name="ln450">	u_int32_t		rval;</a>
<a name="ln451">	int			i;</a>
<a name="ln452"> </a>
<a name="ln453">	sc = device_get_softc(dev);</a>
<a name="ln454"> </a>
<a name="ln455">	/* Let the rgephy driver read the GMEDIASTAT register */</a>
<a name="ln456"> </a>
<a name="ln457">	if (reg == RL_GMEDIASTAT) {</a>
<a name="ln458">		rval = CSR_READ_1(sc, RL_GMEDIASTAT);</a>
<a name="ln459">		return (rval);</a>
<a name="ln460">	}</a>
<a name="ln461"> </a>
<a name="ln462">	CSR_WRITE_4(sc, RL_PHYAR, reg &lt;&lt; 16);</a>
<a name="ln463"> </a>
<a name="ln464">	for (i = 0; i &lt; RL_PHY_TIMEOUT; i++) {</a>
<a name="ln465">		rval = CSR_READ_4(sc, RL_PHYAR);</a>
<a name="ln466">		if (rval &amp; RL_PHYAR_BUSY)</a>
<a name="ln467">			break;</a>
<a name="ln468">		DELAY(25);</a>
<a name="ln469">	}</a>
<a name="ln470"> </a>
<a name="ln471">	if (i == RL_PHY_TIMEOUT) {</a>
<a name="ln472">		device_printf(sc-&gt;rl_dev, &quot;PHY read failed\n&quot;);</a>
<a name="ln473">		return (0);</a>
<a name="ln474">	}</a>
<a name="ln475"> </a>
<a name="ln476">	/*</a>
<a name="ln477">	 * Controller requires a 20us delay to process next MDIO request.</a>
<a name="ln478">	 */</a>
<a name="ln479">	DELAY(20);</a>
<a name="ln480"> </a>
<a name="ln481">	return (rval &amp; RL_PHYAR_PHYDATA);</a>
<a name="ln482">}</a>
<a name="ln483"> </a>
<a name="ln484">static int</a>
<a name="ln485">re_gmii_writereg(device_t dev, int phy, int reg, int data)</a>
<a name="ln486">{</a>
<a name="ln487">	struct rl_softc		*sc;</a>
<a name="ln488">	u_int32_t		rval;</a>
<a name="ln489">	int			i;</a>
<a name="ln490"> </a>
<a name="ln491">	sc = device_get_softc(dev);</a>
<a name="ln492"> </a>
<a name="ln493">	CSR_WRITE_4(sc, RL_PHYAR, (reg &lt;&lt; 16) |</a>
<a name="ln494">	    (data &amp; RL_PHYAR_PHYDATA) | RL_PHYAR_BUSY);</a>
<a name="ln495"> </a>
<a name="ln496">	for (i = 0; i &lt; RL_PHY_TIMEOUT; i++) {</a>
<a name="ln497">		rval = CSR_READ_4(sc, RL_PHYAR);</a>
<a name="ln498">		if (!(rval &amp; RL_PHYAR_BUSY))</a>
<a name="ln499">			break;</a>
<a name="ln500">		DELAY(25);</a>
<a name="ln501">	}</a>
<a name="ln502"> </a>
<a name="ln503">	if (i == RL_PHY_TIMEOUT) {</a>
<a name="ln504">		device_printf(sc-&gt;rl_dev, &quot;PHY write failed\n&quot;);</a>
<a name="ln505">		return (0);</a>
<a name="ln506">	}</a>
<a name="ln507"> </a>
<a name="ln508">	/*</a>
<a name="ln509">	 * Controller requires a 20us delay to process next MDIO request.</a>
<a name="ln510">	 */</a>
<a name="ln511">	DELAY(20);</a>
<a name="ln512"> </a>
<a name="ln513">	return (0);</a>
<a name="ln514">}</a>
<a name="ln515"> </a>
<a name="ln516">static int</a>
<a name="ln517">re_miibus_readreg(device_t dev, int phy, int reg)</a>
<a name="ln518">{</a>
<a name="ln519">	struct rl_softc		*sc;</a>
<a name="ln520">	u_int16_t		rval = 0;</a>
<a name="ln521">	u_int16_t		re8139_reg = 0;</a>
<a name="ln522"> </a>
<a name="ln523">	sc = device_get_softc(dev);</a>
<a name="ln524"> </a>
<a name="ln525">	if (sc-&gt;rl_type == RL_8169) {</a>
<a name="ln526">		rval = re_gmii_readreg(dev, phy, reg);</a>
<a name="ln527">		return (rval);</a>
<a name="ln528">	}</a>
<a name="ln529"> </a>
<a name="ln530">	switch (reg) {</a>
<a name="ln531">	case MII_BMCR:</a>
<a name="ln532">		re8139_reg = RL_BMCR;</a>
<a name="ln533">		break;</a>
<a name="ln534">	case MII_BMSR:</a>
<a name="ln535">		re8139_reg = RL_BMSR;</a>
<a name="ln536">		break;</a>
<a name="ln537">	case MII_ANAR:</a>
<a name="ln538">		re8139_reg = RL_ANAR;</a>
<a name="ln539">		break;</a>
<a name="ln540">	case MII_ANER:</a>
<a name="ln541">		re8139_reg = RL_ANER;</a>
<a name="ln542">		break;</a>
<a name="ln543">	case MII_ANLPAR:</a>
<a name="ln544">		re8139_reg = RL_LPAR;</a>
<a name="ln545">		break;</a>
<a name="ln546">	case MII_PHYIDR1:</a>
<a name="ln547">	case MII_PHYIDR2:</a>
<a name="ln548">		return (0);</a>
<a name="ln549">	/*</a>
<a name="ln550">	 * Allow the rlphy driver to read the media status</a>
<a name="ln551">	 * register. If we have a link partner which does not</a>
<a name="ln552">	 * support NWAY, this is the register which will tell</a>
<a name="ln553">	 * us the results of parallel detection.</a>
<a name="ln554">	 */</a>
<a name="ln555">	case RL_MEDIASTAT:</a>
<a name="ln556">		rval = CSR_READ_1(sc, RL_MEDIASTAT);</a>
<a name="ln557">		return (rval);</a>
<a name="ln558">	default:</a>
<a name="ln559">		device_printf(sc-&gt;rl_dev, &quot;bad phy register\n&quot;);</a>
<a name="ln560">		return (0);</a>
<a name="ln561">	}</a>
<a name="ln562">	rval = CSR_READ_2(sc, re8139_reg);</a>
<a name="ln563">	if (sc-&gt;rl_type == RL_8139CPLUS &amp;&amp; re8139_reg == RL_BMCR) {</a>
<a name="ln564">		/* 8139C+ has different bit layout. */</a>
<a name="ln565">		rval &amp;= ~(BMCR_LOOP | BMCR_ISO);</a>
<a name="ln566">	}</a>
<a name="ln567">	return (rval);</a>
<a name="ln568">}</a>
<a name="ln569"> </a>
<a name="ln570">static int</a>
<a name="ln571">re_miibus_writereg(device_t dev, int phy, int reg, int data)</a>
<a name="ln572">{</a>
<a name="ln573">	struct rl_softc		*sc;</a>
<a name="ln574">	u_int16_t		re8139_reg = 0;</a>
<a name="ln575">	int			rval = 0;</a>
<a name="ln576"> </a>
<a name="ln577">	sc = device_get_softc(dev);</a>
<a name="ln578"> </a>
<a name="ln579">	if (sc-&gt;rl_type == RL_8169) {</a>
<a name="ln580">		rval = re_gmii_writereg(dev, phy, reg, data);</a>
<a name="ln581">		return (rval);</a>
<a name="ln582">	}</a>
<a name="ln583"> </a>
<a name="ln584">	switch (reg) {</a>
<a name="ln585">	case MII_BMCR:</a>
<a name="ln586">		re8139_reg = RL_BMCR;</a>
<a name="ln587">		if (sc-&gt;rl_type == RL_8139CPLUS) {</a>
<a name="ln588">			/* 8139C+ has different bit layout. */</a>
<a name="ln589">			data &amp;= ~(BMCR_LOOP | BMCR_ISO);</a>
<a name="ln590">		}</a>
<a name="ln591">		break;</a>
<a name="ln592">	case MII_BMSR:</a>
<a name="ln593">		re8139_reg = RL_BMSR;</a>
<a name="ln594">		break;</a>
<a name="ln595">	case MII_ANAR:</a>
<a name="ln596">		re8139_reg = RL_ANAR;</a>
<a name="ln597">		break;</a>
<a name="ln598">	case MII_ANER:</a>
<a name="ln599">		re8139_reg = RL_ANER;</a>
<a name="ln600">		break;</a>
<a name="ln601">	case MII_ANLPAR:</a>
<a name="ln602">		re8139_reg = RL_LPAR;</a>
<a name="ln603">		break;</a>
<a name="ln604">	case MII_PHYIDR1:</a>
<a name="ln605">	case MII_PHYIDR2:</a>
<a name="ln606">		return (0);</a>
<a name="ln607">		break;</a>
<a name="ln608">	default:</a>
<a name="ln609">		device_printf(sc-&gt;rl_dev, &quot;bad phy register\n&quot;);</a>
<a name="ln610">		return (0);</a>
<a name="ln611">	}</a>
<a name="ln612">	CSR_WRITE_2(sc, re8139_reg, data);</a>
<a name="ln613">	return (0);</a>
<a name="ln614">}</a>
<a name="ln615"> </a>
<a name="ln616">static void</a>
<a name="ln617">re_miibus_statchg(device_t dev)</a>
<a name="ln618">{</a>
<a name="ln619">	struct rl_softc		*sc;</a>
<a name="ln620">	struct ifnet		*ifp;</a>
<a name="ln621">	struct mii_data		*mii;</a>
<a name="ln622"> </a>
<a name="ln623">	sc = device_get_softc(dev);</a>
<a name="ln624">	mii = device_get_softc(sc-&gt;rl_miibus);</a>
<a name="ln625">	ifp = sc-&gt;rl_ifp;</a>
<a name="ln626">	if (mii == NULL || ifp == NULL ||</a>
<a name="ln627">	    (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) == 0)</a>
<a name="ln628">		return;</a>
<a name="ln629"> </a>
<a name="ln630">	sc-&gt;rl_flags &amp;= ~RL_FLAG_LINK;</a>
<a name="ln631">	if ((mii-&gt;mii_media_status &amp; (IFM_ACTIVE | IFM_AVALID)) ==</a>
<a name="ln632">	    (IFM_ACTIVE | IFM_AVALID)) {</a>
<a name="ln633">		switch (IFM_SUBTYPE(mii-&gt;mii_media_active)) {</a>
<a name="ln634">		case IFM_10_T:</a>
<a name="ln635">		case IFM_100_TX:</a>
<a name="ln636">			sc-&gt;rl_flags |= RL_FLAG_LINK;</a>
<a name="ln637">			break;</a>
<a name="ln638">		case IFM_1000_T:</a>
<a name="ln639">			if ((sc-&gt;rl_flags &amp; RL_FLAG_FASTETHER) != 0)</a>
<a name="ln640">				break;</a>
<a name="ln641">			sc-&gt;rl_flags |= RL_FLAG_LINK;</a>
<a name="ln642">			break;</a>
<a name="ln643">		default:</a>
<a name="ln644">			break;</a>
<a name="ln645">		}</a>
<a name="ln646">	}</a>
<a name="ln647">	/*</a>
<a name="ln648">	 * RealTek controllers do not provide any interface to the RX/TX</a>
<a name="ln649">	 * MACs for resolved speed, duplex and flow-control parameters.</a>
<a name="ln650">	 */</a>
<a name="ln651">}</a>
<a name="ln652"> </a>
<a name="ln653">/*</a>
<a name="ln654"> * Set the RX configuration and 64-bit multicast hash filter.</a>
<a name="ln655"> */</a>
<a name="ln656">static void</a>
<a name="ln657">re_set_rxmode(struct rl_softc *sc)</a>
<a name="ln658">{</a>
<a name="ln659">	struct ifnet		*ifp;</a>
<a name="ln660">	struct ifmultiaddr	*ifma;</a>
<a name="ln661">	uint32_t		hashes[2] = { 0, 0 };</a>
<a name="ln662">	uint32_t		h, rxfilt;</a>
<a name="ln663"> </a>
<a name="ln664">	RL_LOCK_ASSERT(sc);</a>
<a name="ln665"> </a>
<a name="ln666">	ifp = sc-&gt;rl_ifp;</a>
<a name="ln667"> </a>
<a name="ln668">	rxfilt = RL_RXCFG_CONFIG | RL_RXCFG_RX_INDIV | RL_RXCFG_RX_BROAD;</a>
<a name="ln669">	if ((sc-&gt;rl_flags &amp; RL_FLAG_EARLYOFF) != 0)</a>
<a name="ln670">		rxfilt |= RL_RXCFG_EARLYOFF;</a>
<a name="ln671">	else if ((sc-&gt;rl_flags &amp; RL_FLAG_8168G_PLUS) != 0)</a>
<a name="ln672">		rxfilt |= RL_RXCFG_EARLYOFFV2;</a>
<a name="ln673"> </a>
<a name="ln674">	if (ifp-&gt;if_flags &amp; (IFF_ALLMULTI | IFF_PROMISC)) {</a>
<a name="ln675">		if (ifp-&gt;if_flags &amp; IFF_PROMISC)</a>
<a name="ln676">			rxfilt |= RL_RXCFG_RX_ALLPHYS;</a>
<a name="ln677">		/*</a>
<a name="ln678">		 * Unlike other hardwares, we have to explicitly set</a>
<a name="ln679">		 * RL_RXCFG_RX_MULTI to receive multicast frames in</a>
<a name="ln680">		 * promiscuous mode.</a>
<a name="ln681">		 */</a>
<a name="ln682">		rxfilt |= RL_RXCFG_RX_MULTI;</a>
<a name="ln683">		hashes[0] = hashes[1] = 0xffffffff;</a>
<a name="ln684">		goto done;</a>
<a name="ln685">	}</a>
<a name="ln686"> </a>
<a name="ln687">	if_maddr_rlock(ifp);</a>
<a name="ln688">	TAILQ_FOREACH(ifma, &amp;ifp-&gt;if_multiaddrs, ifma_link) {</a>
<a name="ln689">		if (ifma-&gt;ifma_addr-&gt;sa_family != AF_LINK)</a>
<a name="ln690">			continue;</a>
<a name="ln691">		h = ether_crc32_be(LLADDR((struct sockaddr_dl *)</a>
<a name="ln692">		    ifma-&gt;ifma_addr), ETHER_ADDR_LEN) &gt;&gt; 26;</a>
<a name="ln693">		if (h &lt; 32)</a>
<a name="ln694">			hashes[0] |= (1 &lt;&lt; h);</a>
<a name="ln695">		else</a>
<a name="ln696">			hashes[1] |= (1 &lt;&lt; (h - 32));</a>
<a name="ln697">	}</a>
<a name="ln698">	if_maddr_runlock(ifp);</a>
<a name="ln699"> </a>
<a name="ln700">	if (hashes[0] != 0 || hashes[1] != 0) {</a>
<a name="ln701">		/*</a>
<a name="ln702">		 * For some unfathomable reason, RealTek decided to</a>
<a name="ln703">		 * reverse the order of the multicast hash registers</a>
<a name="ln704">		 * in the PCI Express parts.  This means we have to</a>
<a name="ln705">		 * write the hash pattern in reverse order for those</a>
<a name="ln706">		 * devices.</a>
<a name="ln707">		 */</a>
<a name="ln708">		if ((sc-&gt;rl_flags &amp; RL_FLAG_PCIE) != 0) {</a>
<a name="ln709">			h = bswap32(hashes[0]);</a>
<a name="ln710">			hashes[0] = bswap32(hashes[1]);</a>
<a name="ln711">			hashes[1] = h;</a>
<a name="ln712">		}</a>
<a name="ln713">		rxfilt |= RL_RXCFG_RX_MULTI;</a>
<a name="ln714">	}</a>
<a name="ln715"> </a>
<a name="ln716">	if  (sc-&gt;rl_hwrev-&gt;rl_rev == RL_HWREV_8168F) {</a>
<a name="ln717">		/* Disable multicast filtering due to silicon bug. */</a>
<a name="ln718">		hashes[0] = 0xffffffff;</a>
<a name="ln719">		hashes[1] = 0xffffffff;</a>
<a name="ln720">	}</a>
<a name="ln721"> </a>
<a name="ln722">done:</a>
<a name="ln723">	CSR_WRITE_4(sc, RL_MAR0, hashes[0]);</a>
<a name="ln724">	CSR_WRITE_4(sc, RL_MAR4, hashes[1]);</a>
<a name="ln725">	CSR_WRITE_4(sc, RL_RXCFG, rxfilt);</a>
<a name="ln726">}</a>
<a name="ln727"> </a>
<a name="ln728">static void</a>
<a name="ln729">re_reset(struct rl_softc *sc)</a>
<a name="ln730">{</a>
<a name="ln731">	int			i;</a>
<a name="ln732"> </a>
<a name="ln733">	RL_LOCK_ASSERT(sc);</a>
<a name="ln734"> </a>
<a name="ln735">	CSR_WRITE_1(sc, RL_COMMAND, RL_CMD_RESET);</a>
<a name="ln736"> </a>
<a name="ln737">	for (i = 0; i &lt; RL_TIMEOUT; i++) {</a>
<a name="ln738">		DELAY(10);</a>
<a name="ln739">		if (!(CSR_READ_1(sc, RL_COMMAND) &amp; RL_CMD_RESET))</a>
<a name="ln740">			break;</a>
<a name="ln741">	}</a>
<a name="ln742">	if (i == RL_TIMEOUT)</a>
<a name="ln743">		device_printf(sc-&gt;rl_dev, &quot;reset never completed!\n&quot;);</a>
<a name="ln744"> </a>
<a name="ln745">	if ((sc-&gt;rl_flags &amp; RL_FLAG_MACRESET) != 0)</a>
<a name="ln746">		CSR_WRITE_1(sc, 0x82, 1);</a>
<a name="ln747">	if (sc-&gt;rl_hwrev-&gt;rl_rev == RL_HWREV_8169S)</a>
<a name="ln748">		re_gmii_writereg(sc-&gt;rl_dev, 1, 0x0b, 0);</a>
<a name="ln749">}</a>
<a name="ln750"> </a>
<a name="ln751">#ifdef RE_DIAG</a>
<a name="ln752"> </a>
<a name="ln753">/*</a>
<a name="ln754"> * The following routine is designed to test for a defect on some</a>
<a name="ln755"> * 32-bit 8169 cards. Some of these NICs have the REQ64# and ACK64#</a>
<a name="ln756"> * lines connected to the bus, however for a 32-bit only card, they</a>
<a name="ln757"> * should be pulled high. The result of this defect is that the</a>
<a name="ln758"> * NIC will not work right if you plug it into a 64-bit slot: DMA</a>
<a name="ln759"> * operations will be done with 64-bit transfers, which will fail</a>
<a name="ln760"> * because the 64-bit data lines aren't connected.</a>
<a name="ln761"> *</a>
<a name="ln762"> * There's no way to work around this (short of talking a soldering</a>
<a name="ln763"> * iron to the board), however we can detect it. The method we use</a>
<a name="ln764"> * here is to put the NIC into digital loopback mode, set the receiver</a>
<a name="ln765"> * to promiscuous mode, and then try to send a frame. We then compare</a>
<a name="ln766"> * the frame data we sent to what was received. If the data matches,</a>
<a name="ln767"> * then the NIC is working correctly, otherwise we know the user has</a>
<a name="ln768"> * a defective NIC which has been mistakenly plugged into a 64-bit PCI</a>
<a name="ln769"> * slot. In the latter case, there's no way the NIC can work correctly,</a>
<a name="ln770"> * so we print out a message on the console and abort the device attach.</a>
<a name="ln771"> */</a>
<a name="ln772"> </a>
<a name="ln773">static int</a>
<a name="ln774">re_diag(struct rl_softc *sc)</a>
<a name="ln775">{</a>
<a name="ln776">	struct ifnet		*ifp = sc-&gt;rl_ifp;</a>
<a name="ln777">	struct mbuf		*m0;</a>
<a name="ln778">	struct ether_header	*eh;</a>
<a name="ln779">	struct rl_desc		*cur_rx;</a>
<a name="ln780">	u_int16_t		status;</a>
<a name="ln781">	u_int32_t		rxstat;</a>
<a name="ln782">	int			total_len, i, error = 0, phyaddr;</a>
<a name="ln783">	u_int8_t		dst[] = { 0x00, 'h', 'e', 'l', 'l', 'o' };</a>
<a name="ln784">	u_int8_t		src[] = { 0x00, 'w', 'o', 'r', 'l', 'd' };</a>
<a name="ln785"> </a>
<a name="ln786">	/* Allocate a single mbuf */</a>
<a name="ln787">	MGETHDR(m0, M_NOWAIT, MT_DATA);</a>
<a name="ln788">	if (m0 == NULL)</a>
<a name="ln789">		return (ENOBUFS);</a>
<a name="ln790"> </a>
<a name="ln791">	RL_LOCK(sc);</a>
<a name="ln792"> </a>
<a name="ln793">	/*</a>
<a name="ln794">	 * Initialize the NIC in test mode. This sets the chip up</a>
<a name="ln795">	 * so that it can send and receive frames, but performs the</a>
<a name="ln796">	 * following special functions:</a>
<a name="ln797">	 * - Puts receiver in promiscuous mode</a>
<a name="ln798">	 * - Enables digital loopback mode</a>
<a name="ln799">	 * - Leaves interrupts turned off</a>
<a name="ln800">	 */</a>
<a name="ln801"> </a>
<a name="ln802">	ifp-&gt;if_flags |= IFF_PROMISC;</a>
<a name="ln803">	sc-&gt;rl_testmode = 1;</a>
<a name="ln804">	ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_RUNNING;</a>
<a name="ln805">	re_init_locked(sc);</a>
<a name="ln806">	sc-&gt;rl_flags |= RL_FLAG_LINK;</a>
<a name="ln807">	if (sc-&gt;rl_type == RL_8169)</a>
<a name="ln808">		phyaddr = 1;</a>
<a name="ln809">	else</a>
<a name="ln810">		phyaddr = 0;</a>
<a name="ln811"> </a>
<a name="ln812">	re_miibus_writereg(sc-&gt;rl_dev, phyaddr, MII_BMCR, BMCR_RESET);</a>
<a name="ln813">	for (i = 0; i &lt; RL_TIMEOUT; i++) {</a>
<a name="ln814">		status = re_miibus_readreg(sc-&gt;rl_dev, phyaddr, MII_BMCR);</a>
<a name="ln815">		if (!(status &amp; BMCR_RESET))</a>
<a name="ln816">			break;</a>
<a name="ln817">	}</a>
<a name="ln818"> </a>
<a name="ln819">	re_miibus_writereg(sc-&gt;rl_dev, phyaddr, MII_BMCR, BMCR_LOOP);</a>
<a name="ln820">	CSR_WRITE_2(sc, RL_ISR, RL_INTRS);</a>
<a name="ln821"> </a>
<a name="ln822">	DELAY(100000);</a>
<a name="ln823"> </a>
<a name="ln824">	/* Put some data in the mbuf */</a>
<a name="ln825"> </a>
<a name="ln826">	eh = mtod(m0, struct ether_header *);</a>
<a name="ln827">	bcopy ((char *)&amp;dst, eh-&gt;ether_dhost, ETHER_ADDR_LEN);</a>
<a name="ln828">	bcopy ((char *)&amp;src, eh-&gt;ether_shost, ETHER_ADDR_LEN);</a>
<a name="ln829">	eh-&gt;ether_type = htons(ETHERTYPE_IP);</a>
<a name="ln830">	m0-&gt;m_pkthdr.len = m0-&gt;m_len = ETHER_MIN_LEN - ETHER_CRC_LEN;</a>
<a name="ln831"> </a>
<a name="ln832">	/*</a>
<a name="ln833">	 * Queue the packet, start transmission.</a>
<a name="ln834">	 * Note: IF_HANDOFF() ultimately calls re_start() for us.</a>
<a name="ln835">	 */</a>
<a name="ln836"> </a>
<a name="ln837">	CSR_WRITE_2(sc, RL_ISR, 0xFFFF);</a>
<a name="ln838">	RL_UNLOCK(sc);</a>
<a name="ln839">	/* XXX: re_diag must not be called when in ALTQ mode */</a>
<a name="ln840">	IF_HANDOFF(&amp;ifp-&gt;if_snd, m0, ifp);</a>
<a name="ln841">	RL_LOCK(sc);</a>
<a name="ln842">	m0 = NULL;</a>
<a name="ln843"> </a>
<a name="ln844">	/* Wait for it to propagate through the chip */</a>
<a name="ln845"> </a>
<a name="ln846">	DELAY(100000);</a>
<a name="ln847">	for (i = 0; i &lt; RL_TIMEOUT; i++) {</a>
<a name="ln848">		status = CSR_READ_2(sc, RL_ISR);</a>
<a name="ln849">		CSR_WRITE_2(sc, RL_ISR, status);</a>
<a name="ln850">		if ((status &amp; (RL_ISR_TIMEOUT_EXPIRED|RL_ISR_RX_OK)) ==</a>
<a name="ln851">		    (RL_ISR_TIMEOUT_EXPIRED|RL_ISR_RX_OK))</a>
<a name="ln852">			break;</a>
<a name="ln853">		DELAY(10);</a>
<a name="ln854">	}</a>
<a name="ln855"> </a>
<a name="ln856">	if (i == RL_TIMEOUT) {</a>
<a name="ln857">		device_printf(sc-&gt;rl_dev,</a>
<a name="ln858">		    &quot;diagnostic failed, failed to receive packet in&quot;</a>
<a name="ln859">		    &quot; loopback mode\n&quot;);</a>
<a name="ln860">		error = EIO;</a>
<a name="ln861">		goto done;</a>
<a name="ln862">	}</a>
<a name="ln863"> </a>
<a name="ln864">	/*</a>
<a name="ln865">	 * The packet should have been dumped into the first</a>
<a name="ln866">	 * entry in the RX DMA ring. Grab it from there.</a>
<a name="ln867">	 */</a>
<a name="ln868"> </a>
<a name="ln869">	bus_dmamap_sync(sc-&gt;rl_ldata.rl_rx_list_tag,</a>
<a name="ln870">	    sc-&gt;rl_ldata.rl_rx_list_map,</a>
<a name="ln871">	    BUS_DMASYNC_POSTREAD);</a>
<a name="ln872">	bus_dmamap_sync(sc-&gt;rl_ldata.rl_rx_mtag,</a>
<a name="ln873">	    sc-&gt;rl_ldata.rl_rx_desc[0].rx_dmamap,</a>
<a name="ln874">	    BUS_DMASYNC_POSTREAD);</a>
<a name="ln875">	bus_dmamap_unload(sc-&gt;rl_ldata.rl_rx_mtag,</a>
<a name="ln876">	    sc-&gt;rl_ldata.rl_rx_desc[0].rx_dmamap);</a>
<a name="ln877"> </a>
<a name="ln878">	m0 = sc-&gt;rl_ldata.rl_rx_desc[0].rx_m;</a>
<a name="ln879">	sc-&gt;rl_ldata.rl_rx_desc[0].rx_m = NULL;</a>
<a name="ln880">	eh = mtod(m0, struct ether_header *);</a>
<a name="ln881"> </a>
<a name="ln882">	cur_rx = &amp;sc-&gt;rl_ldata.rl_rx_list[0];</a>
<a name="ln883">	total_len = RL_RXBYTES(cur_rx);</a>
<a name="ln884">	rxstat = le32toh(cur_rx-&gt;rl_cmdstat);</a>
<a name="ln885"> </a>
<a name="ln886">	if (total_len != ETHER_MIN_LEN) {</a>
<a name="ln887">		device_printf(sc-&gt;rl_dev,</a>
<a name="ln888">		    &quot;diagnostic failed, received short packet\n&quot;);</a>
<a name="ln889">		error = EIO;</a>
<a name="ln890">		goto done;</a>
<a name="ln891">	}</a>
<a name="ln892"> </a>
<a name="ln893">	/* Test that the received packet data matches what we sent. */</a>
<a name="ln894"> </a>
<a name="ln895">	if (bcmp((char *)&amp;eh-&gt;ether_dhost, (char *)&amp;dst, ETHER_ADDR_LEN) ||</a>
<a name="ln896">	    bcmp((char *)&amp;eh-&gt;ether_shost, (char *)&amp;src, ETHER_ADDR_LEN) ||</a>
<a name="ln897">	    ntohs(eh-&gt;ether_type) != ETHERTYPE_IP) {</a>
<a name="ln898">		device_printf(sc-&gt;rl_dev, &quot;WARNING, DMA FAILURE!\n&quot;);</a>
<a name="ln899">		device_printf(sc-&gt;rl_dev, &quot;expected TX data: %6D/%6D/0x%x\n&quot;,</a>
<a name="ln900">		    dst, &quot;:&quot;, src, &quot;:&quot;, ETHERTYPE_IP);</a>
<a name="ln901">		device_printf(sc-&gt;rl_dev, &quot;received RX data: %6D/%6D/0x%x\n&quot;,</a>
<a name="ln902">		    eh-&gt;ether_dhost, &quot;:&quot;, eh-&gt;ether_shost, &quot;:&quot;,</a>
<a name="ln903">		    ntohs(eh-&gt;ether_type));</a>
<a name="ln904">		device_printf(sc-&gt;rl_dev, &quot;You may have a defective 32-bit &quot;</a>
<a name="ln905">		    &quot;NIC plugged into a 64-bit PCI slot.\n&quot;);</a>
<a name="ln906">		device_printf(sc-&gt;rl_dev, &quot;Please re-install the NIC in a &quot;</a>
<a name="ln907">		    &quot;32-bit slot for proper operation.\n&quot;);</a>
<a name="ln908">		device_printf(sc-&gt;rl_dev, &quot;Read the re(4) man page for more &quot;</a>
<a name="ln909">		    &quot;details.\n&quot;);</a>
<a name="ln910">		error = EIO;</a>
<a name="ln911">	}</a>
<a name="ln912"> </a>
<a name="ln913">done:</a>
<a name="ln914">	/* Turn interface off, release resources */</a>
<a name="ln915"> </a>
<a name="ln916">	sc-&gt;rl_testmode = 0;</a>
<a name="ln917">	sc-&gt;rl_flags &amp;= ~RL_FLAG_LINK;</a>
<a name="ln918">	ifp-&gt;if_flags &amp;= ~IFF_PROMISC;</a>
<a name="ln919">	re_stop(sc);</a>
<a name="ln920">	if (m0 != NULL)</a>
<a name="ln921">		m_freem(m0);</a>
<a name="ln922"> </a>
<a name="ln923">	RL_UNLOCK(sc);</a>
<a name="ln924"> </a>
<a name="ln925">	return (error);</a>
<a name="ln926">}</a>
<a name="ln927"> </a>
<a name="ln928">#endif</a>
<a name="ln929"> </a>
<a name="ln930">/*</a>
<a name="ln931"> * Probe for a RealTek 8139C+/8169/8110 chip. Check the PCI vendor and device</a>
<a name="ln932"> * IDs against our list and return a device name if we find a match.</a>
<a name="ln933"> */</a>
<a name="ln934">static int</a>
<a name="ln935">re_probe(device_t dev)</a>
<a name="ln936">{</a>
<a name="ln937">	const struct rl_type	*t;</a>
<a name="ln938">	uint16_t		devid, vendor;</a>
<a name="ln939">	uint16_t		revid, sdevid;</a>
<a name="ln940">	int			i;</a>
<a name="ln941"> </a>
<a name="ln942">	vendor = pci_get_vendor(dev);</a>
<a name="ln943">	devid = pci_get_device(dev);</a>
<a name="ln944">	revid = pci_get_revid(dev);</a>
<a name="ln945">	sdevid = pci_get_subdevice(dev);</a>
<a name="ln946"> </a>
<a name="ln947">	if (vendor == LINKSYS_VENDORID &amp;&amp; devid == LINKSYS_DEVICEID_EG1032) {</a>
<a name="ln948">		if (sdevid != LINKSYS_SUBDEVICE_EG1032_REV3) {</a>
<a name="ln949">			/*</a>
<a name="ln950">			 * Only attach to rev. 3 of the Linksys EG1032 adapter.</a>
<a name="ln951">			 * Rev. 2 is supported by sk(4).</a>
<a name="ln952">			 */</a>
<a name="ln953">			return (ENXIO);</a>
<a name="ln954">		}</a>
<a name="ln955">	}</a>
<a name="ln956"> </a>
<a name="ln957">	if (vendor == RT_VENDORID &amp;&amp; devid == RT_DEVICEID_8139) {</a>
<a name="ln958">		if (revid != 0x20) {</a>
<a name="ln959">			/* 8139, let rl(4) take care of this device. */</a>
<a name="ln960">			return (ENXIO);</a>
<a name="ln961">		}</a>
<a name="ln962">	}</a>
<a name="ln963"> </a>
<a name="ln964">	t = re_devs;</a>
<a name="ln965">	for (i = 0; i &lt; nitems(re_devs); i++, t++) {</a>
<a name="ln966">		if (vendor == t-&gt;rl_vid &amp;&amp; devid == t-&gt;rl_did) {</a>
<a name="ln967">			device_set_desc(dev, t-&gt;rl_name);</a>
<a name="ln968">			return (BUS_PROBE_DEFAULT);</a>
<a name="ln969">		}</a>
<a name="ln970">	}</a>
<a name="ln971"> </a>
<a name="ln972">	return (ENXIO);</a>
<a name="ln973">}</a>
<a name="ln974"> </a>
<a name="ln975">/*</a>
<a name="ln976"> * Map a single buffer address.</a>
<a name="ln977"> */</a>
<a name="ln978"> </a>
<a name="ln979">static void</a>
<a name="ln980">re_dma_map_addr(void *arg, bus_dma_segment_t *segs, int nseg, int error)</a>
<a name="ln981">{</a>
<a name="ln982">	bus_addr_t		*addr;</a>
<a name="ln983"> </a>
<a name="ln984">	if (error)</a>
<a name="ln985">		return;</a>
<a name="ln986"> </a>
<a name="ln987">	KASSERT(nseg == 1, (&quot;too many DMA segments, %d should be 1&quot;, nseg));</a>
<a name="ln988">	addr = arg;</a>
<a name="ln989">	*addr = segs-&gt;ds_addr;</a>
<a name="ln990">}</a>
<a name="ln991"> </a>
<a name="ln992">static int</a>
<a name="ln993">re_allocmem(device_t dev, struct rl_softc *sc)</a>
<a name="ln994">{</a>
<a name="ln995">	bus_addr_t		lowaddr;</a>
<a name="ln996">	bus_size_t		rx_list_size, tx_list_size;</a>
<a name="ln997">	int			error;</a>
<a name="ln998">	int			i;</a>
<a name="ln999"> </a>
<a name="ln1000">	rx_list_size = sc-&gt;rl_ldata.rl_rx_desc_cnt * sizeof(struct rl_desc);</a>
<a name="ln1001">	tx_list_size = sc-&gt;rl_ldata.rl_tx_desc_cnt * sizeof(struct rl_desc);</a>
<a name="ln1002"> </a>
<a name="ln1003">	/*</a>
<a name="ln1004">	 * Allocate the parent bus DMA tag appropriate for PCI.</a>
<a name="ln1005">	 * In order to use DAC, RL_CPLUSCMD_PCI_DAC bit of RL_CPLUS_CMD</a>
<a name="ln1006">	 * register should be set. However some RealTek chips are known</a>
<a name="ln1007">	 * to be buggy on DAC handling, therefore disable DAC by limiting</a>
<a name="ln1008">	 * DMA address space to 32bit. PCIe variants of RealTek chips</a>
<a name="ln1009">	 * may not have the limitation.</a>
<a name="ln1010">	 */</a>
<a name="ln1011">	lowaddr = BUS_SPACE_MAXADDR;</a>
<a name="ln1012">	if ((sc-&gt;rl_flags &amp; RL_FLAG_PCIE) == 0)</a>
<a name="ln1013">		lowaddr = BUS_SPACE_MAXADDR_32BIT;</a>
<a name="ln1014">	error = bus_dma_tag_create(bus_get_dma_tag(dev), 1, 0,</a>
<a name="ln1015">	    lowaddr, BUS_SPACE_MAXADDR, NULL, NULL,</a>
<a name="ln1016">	    BUS_SPACE_MAXSIZE_32BIT, 0, BUS_SPACE_MAXSIZE_32BIT, 0,</a>
<a name="ln1017">	    NULL, NULL, &amp;sc-&gt;rl_parent_tag);</a>
<a name="ln1018">	if (error) {</a>
<a name="ln1019">		device_printf(dev, &quot;could not allocate parent DMA tag\n&quot;);</a>
<a name="ln1020">		return (error);</a>
<a name="ln1021">	}</a>
<a name="ln1022"> </a>
<a name="ln1023">	/*</a>
<a name="ln1024">	 * Allocate map for TX mbufs.</a>
<a name="ln1025">	 */</a>
<a name="ln1026">	error = bus_dma_tag_create(sc-&gt;rl_parent_tag, 1, 0,</a>
<a name="ln1027">	    BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR, NULL,</a>
<a name="ln1028">	    NULL, MCLBYTES * RL_NTXSEGS, RL_NTXSEGS, 4096, 0,</a>
<a name="ln1029">	    NULL, NULL, &amp;sc-&gt;rl_ldata.rl_tx_mtag);</a>
<a name="ln1030">	if (error) {</a>
<a name="ln1031">		device_printf(dev, &quot;could not allocate TX DMA tag\n&quot;);</a>
<a name="ln1032">		return (error);</a>
<a name="ln1033">	}</a>
<a name="ln1034"> </a>
<a name="ln1035">	/*</a>
<a name="ln1036">	 * Allocate map for RX mbufs.</a>
<a name="ln1037">	 */</a>
<a name="ln1038"> </a>
<a name="ln1039">	if ((sc-&gt;rl_flags &amp; RL_FLAG_JUMBOV2) != 0) {</a>
<a name="ln1040">		error = bus_dma_tag_create(sc-&gt;rl_parent_tag, sizeof(uint64_t),</a>
<a name="ln1041">		    0, BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR, NULL, NULL,</a>
<a name="ln1042">		    MJUM9BYTES, 1, MJUM9BYTES, 0, NULL, NULL,</a>
<a name="ln1043">		    &amp;sc-&gt;rl_ldata.rl_jrx_mtag);</a>
<a name="ln1044">		if (error) {</a>
<a name="ln1045">			device_printf(dev,</a>
<a name="ln1046">			    &quot;could not allocate jumbo RX DMA tag\n&quot;);</a>
<a name="ln1047">			return (error);</a>
<a name="ln1048">		}</a>
<a name="ln1049">	}</a>
<a name="ln1050">	error = bus_dma_tag_create(sc-&gt;rl_parent_tag, sizeof(uint64_t), 0,</a>
<a name="ln1051">	    BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR, NULL, NULL,</a>
<a name="ln1052">	    MCLBYTES, 1, MCLBYTES, 0, NULL, NULL, &amp;sc-&gt;rl_ldata.rl_rx_mtag);</a>
<a name="ln1053">	if (error) {</a>
<a name="ln1054">		device_printf(dev, &quot;could not allocate RX DMA tag\n&quot;);</a>
<a name="ln1055">		return (error);</a>
<a name="ln1056">	}</a>
<a name="ln1057"> </a>
<a name="ln1058">	/*</a>
<a name="ln1059">	 * Allocate map for TX descriptor list.</a>
<a name="ln1060">	 */</a>
<a name="ln1061">	error = bus_dma_tag_create(sc-&gt;rl_parent_tag, RL_RING_ALIGN,</a>
<a name="ln1062">	    0, BUS_SPACE_MAXADDR_32BIT, BUS_SPACE_MAXADDR, NULL,</a>
<a name="ln1063">	    NULL, tx_list_size, 1, tx_list_size, 0,</a>
<a name="ln1064">	    NULL, NULL, &amp;sc-&gt;rl_ldata.rl_tx_list_tag);</a>
<a name="ln1065">	if (error) {</a>
<a name="ln1066">		device_printf(dev, &quot;could not allocate TX DMA ring tag\n&quot;);</a>
<a name="ln1067">		return (error);</a>
<a name="ln1068">	}</a>
<a name="ln1069"> </a>
<a name="ln1070">	/* Allocate DMA'able memory for the TX ring */</a>
<a name="ln1071"> </a>
<a name="ln1072">	error = bus_dmamem_alloc(sc-&gt;rl_ldata.rl_tx_list_tag,</a>
<a name="ln1073">	    (void **)&amp;sc-&gt;rl_ldata.rl_tx_list,</a>
<a name="ln1074">	    BUS_DMA_WAITOK | BUS_DMA_COHERENT | BUS_DMA_ZERO,</a>
<a name="ln1075">	    &amp;sc-&gt;rl_ldata.rl_tx_list_map);</a>
<a name="ln1076">	if (error) {</a>
<a name="ln1077">		device_printf(dev, &quot;could not allocate TX DMA ring\n&quot;);</a>
<a name="ln1078">		return (error);</a>
<a name="ln1079">	}</a>
<a name="ln1080"> </a>
<a name="ln1081">	/* Load the map for the TX ring. */</a>
<a name="ln1082"> </a>
<a name="ln1083">	sc-&gt;rl_ldata.rl_tx_list_addr = 0;</a>
<a name="ln1084">	error = bus_dmamap_load(sc-&gt;rl_ldata.rl_tx_list_tag,</a>
<a name="ln1085">	     sc-&gt;rl_ldata.rl_tx_list_map, sc-&gt;rl_ldata.rl_tx_list,</a>
<a name="ln1086">	     tx_list_size, re_dma_map_addr,</a>
<a name="ln1087">	     &amp;sc-&gt;rl_ldata.rl_tx_list_addr, BUS_DMA_NOWAIT);</a>
<a name="ln1088">	if (error != 0 || sc-&gt;rl_ldata.rl_tx_list_addr == 0) {</a>
<a name="ln1089">		device_printf(dev, &quot;could not load TX DMA ring\n&quot;);</a>
<a name="ln1090">		return (ENOMEM);</a>
<a name="ln1091">	}</a>
<a name="ln1092"> </a>
<a name="ln1093">	/* Create DMA maps for TX buffers */</a>
<a name="ln1094"> </a>
<a name="ln1095">	for (i = 0; i &lt; sc-&gt;rl_ldata.rl_tx_desc_cnt; i++) {</a>
<a name="ln1096">		error = bus_dmamap_create(sc-&gt;rl_ldata.rl_tx_mtag, 0,</a>
<a name="ln1097">		    &amp;sc-&gt;rl_ldata.rl_tx_desc[i].tx_dmamap);</a>
<a name="ln1098">		if (error) {</a>
<a name="ln1099">			device_printf(dev, &quot;could not create DMA map for TX\n&quot;);</a>
<a name="ln1100">			return (error);</a>
<a name="ln1101">		}</a>
<a name="ln1102">	}</a>
<a name="ln1103"> </a>
<a name="ln1104">	/*</a>
<a name="ln1105">	 * Allocate map for RX descriptor list.</a>
<a name="ln1106">	 */</a>
<a name="ln1107">	error = bus_dma_tag_create(sc-&gt;rl_parent_tag, RL_RING_ALIGN,</a>
<a name="ln1108">	    0, BUS_SPACE_MAXADDR_32BIT, BUS_SPACE_MAXADDR, NULL,</a>
<a name="ln1109">	    NULL, rx_list_size, 1, rx_list_size, 0,</a>
<a name="ln1110">	    NULL, NULL, &amp;sc-&gt;rl_ldata.rl_rx_list_tag);</a>
<a name="ln1111">	if (error) {</a>
<a name="ln1112">		device_printf(dev, &quot;could not create RX DMA ring tag\n&quot;);</a>
<a name="ln1113">		return (error);</a>
<a name="ln1114">	}</a>
<a name="ln1115"> </a>
<a name="ln1116">	/* Allocate DMA'able memory for the RX ring */</a>
<a name="ln1117"> </a>
<a name="ln1118">	error = bus_dmamem_alloc(sc-&gt;rl_ldata.rl_rx_list_tag,</a>
<a name="ln1119">	    (void **)&amp;sc-&gt;rl_ldata.rl_rx_list,</a>
<a name="ln1120">	    BUS_DMA_WAITOK | BUS_DMA_COHERENT | BUS_DMA_ZERO,</a>
<a name="ln1121">	    &amp;sc-&gt;rl_ldata.rl_rx_list_map);</a>
<a name="ln1122">	if (error) {</a>
<a name="ln1123">		device_printf(dev, &quot;could not allocate RX DMA ring\n&quot;);</a>
<a name="ln1124">		return (error);</a>
<a name="ln1125">	}</a>
<a name="ln1126"> </a>
<a name="ln1127">	/* Load the map for the RX ring. */</a>
<a name="ln1128"> </a>
<a name="ln1129">	sc-&gt;rl_ldata.rl_rx_list_addr = 0;</a>
<a name="ln1130">	error = bus_dmamap_load(sc-&gt;rl_ldata.rl_rx_list_tag,</a>
<a name="ln1131">	     sc-&gt;rl_ldata.rl_rx_list_map, sc-&gt;rl_ldata.rl_rx_list,</a>
<a name="ln1132">	     rx_list_size, re_dma_map_addr,</a>
<a name="ln1133">	     &amp;sc-&gt;rl_ldata.rl_rx_list_addr, BUS_DMA_NOWAIT);</a>
<a name="ln1134">	if (error != 0 || sc-&gt;rl_ldata.rl_rx_list_addr == 0) {</a>
<a name="ln1135">		device_printf(dev, &quot;could not load RX DMA ring\n&quot;);</a>
<a name="ln1136">		return (ENOMEM);</a>
<a name="ln1137">	}</a>
<a name="ln1138"> </a>
<a name="ln1139">	/* Create DMA maps for RX buffers */</a>
<a name="ln1140"> </a>
<a name="ln1141">	if ((sc-&gt;rl_flags &amp; RL_FLAG_JUMBOV2) != 0) {</a>
<a name="ln1142">		error = bus_dmamap_create(sc-&gt;rl_ldata.rl_jrx_mtag, 0,</a>
<a name="ln1143">		    &amp;sc-&gt;rl_ldata.rl_jrx_sparemap);</a>
<a name="ln1144">		if (error) {</a>
<a name="ln1145">			device_printf(dev,</a>
<a name="ln1146">			    &quot;could not create spare DMA map for jumbo RX\n&quot;);</a>
<a name="ln1147">			return (error);</a>
<a name="ln1148">		}</a>
<a name="ln1149">		for (i = 0; i &lt; sc-&gt;rl_ldata.rl_rx_desc_cnt; i++) {</a>
<a name="ln1150">			error = bus_dmamap_create(sc-&gt;rl_ldata.rl_jrx_mtag, 0,</a>
<a name="ln1151">			    &amp;sc-&gt;rl_ldata.rl_jrx_desc[i].rx_dmamap);</a>
<a name="ln1152">			if (error) {</a>
<a name="ln1153">				device_printf(dev,</a>
<a name="ln1154">				    &quot;could not create DMA map for jumbo RX\n&quot;);</a>
<a name="ln1155">				return (error);</a>
<a name="ln1156">			}</a>
<a name="ln1157">		}</a>
<a name="ln1158">	}</a>
<a name="ln1159">	error = bus_dmamap_create(sc-&gt;rl_ldata.rl_rx_mtag, 0,</a>
<a name="ln1160">	    &amp;sc-&gt;rl_ldata.rl_rx_sparemap);</a>
<a name="ln1161">	if (error) {</a>
<a name="ln1162">		device_printf(dev, &quot;could not create spare DMA map for RX\n&quot;);</a>
<a name="ln1163">		return (error);</a>
<a name="ln1164">	}</a>
<a name="ln1165">	for (i = 0; i &lt; sc-&gt;rl_ldata.rl_rx_desc_cnt; i++) {</a>
<a name="ln1166">		error = bus_dmamap_create(sc-&gt;rl_ldata.rl_rx_mtag, 0,</a>
<a name="ln1167">		    &amp;sc-&gt;rl_ldata.rl_rx_desc[i].rx_dmamap);</a>
<a name="ln1168">		if (error) {</a>
<a name="ln1169">			device_printf(dev, &quot;could not create DMA map for RX\n&quot;);</a>
<a name="ln1170">			return (error);</a>
<a name="ln1171">		}</a>
<a name="ln1172">	}</a>
<a name="ln1173"> </a>
<a name="ln1174">	/* Create DMA map for statistics. */</a>
<a name="ln1175">	error = bus_dma_tag_create(sc-&gt;rl_parent_tag, RL_DUMP_ALIGN, 0,</a>
<a name="ln1176">	    BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR, NULL, NULL,</a>
<a name="ln1177">	    sizeof(struct rl_stats), 1, sizeof(struct rl_stats), 0, NULL, NULL,</a>
<a name="ln1178">	    &amp;sc-&gt;rl_ldata.rl_stag);</a>
<a name="ln1179">	if (error) {</a>
<a name="ln1180">		device_printf(dev, &quot;could not create statistics DMA tag\n&quot;);</a>
<a name="ln1181">		return (error);</a>
<a name="ln1182">	}</a>
<a name="ln1183">	/* Allocate DMA'able memory for statistics. */</a>
<a name="ln1184">	error = bus_dmamem_alloc(sc-&gt;rl_ldata.rl_stag,</a>
<a name="ln1185">	    (void **)&amp;sc-&gt;rl_ldata.rl_stats,</a>
<a name="ln1186">	    BUS_DMA_WAITOK | BUS_DMA_COHERENT | BUS_DMA_ZERO,</a>
<a name="ln1187">	    &amp;sc-&gt;rl_ldata.rl_smap);</a>
<a name="ln1188">	if (error) {</a>
<a name="ln1189">		device_printf(dev,</a>
<a name="ln1190">		    &quot;could not allocate statistics DMA memory\n&quot;);</a>
<a name="ln1191">		return (error);</a>
<a name="ln1192">	}</a>
<a name="ln1193">	/* Load the map for statistics. */</a>
<a name="ln1194">	sc-&gt;rl_ldata.rl_stats_addr = 0;</a>
<a name="ln1195">	error = bus_dmamap_load(sc-&gt;rl_ldata.rl_stag, sc-&gt;rl_ldata.rl_smap,</a>
<a name="ln1196">	    sc-&gt;rl_ldata.rl_stats, sizeof(struct rl_stats), re_dma_map_addr,</a>
<a name="ln1197">	     &amp;sc-&gt;rl_ldata.rl_stats_addr, BUS_DMA_NOWAIT);</a>
<a name="ln1198">	if (error != 0 || sc-&gt;rl_ldata.rl_stats_addr == 0) {</a>
<a name="ln1199">		device_printf(dev, &quot;could not load statistics DMA memory\n&quot;);</a>
<a name="ln1200">		return (ENOMEM);</a>
<a name="ln1201">	}</a>
<a name="ln1202"> </a>
<a name="ln1203">	return (0);</a>
<a name="ln1204">}</a>
<a name="ln1205"> </a>
<a name="ln1206">/*</a>
<a name="ln1207"> * Attach the interface. Allocate softc structures, do ifmedia</a>
<a name="ln1208"> * setup and ethernet/BPF attach.</a>
<a name="ln1209"> */</a>
<a name="ln1210">static int</a>
<a name="ln1211">re_attach(device_t dev)</a>
<a name="ln1212">{</a>
<a name="ln1213">	u_char			eaddr[ETHER_ADDR_LEN];</a>
<a name="ln1214">	u_int16_t		as[ETHER_ADDR_LEN / 2];</a>
<a name="ln1215">	struct rl_softc		*sc;</a>
<a name="ln1216">	struct ifnet		*ifp;</a>
<a name="ln1217">	const struct rl_hwrev	*hw_rev;</a>
<a name="ln1218">	int			capmask, error = 0, hwrev, i, msic, msixc,</a>
<a name="ln1219">				phy, reg, rid;</a>
<a name="ln1220">	u_int32_t		cap, ctl;</a>
<a name="ln1221">	u_int16_t		devid, re_did = 0;</a>
<a name="ln1222">	uint8_t			cfg;</a>
<a name="ln1223"> </a>
<a name="ln1224">	sc = device_get_softc(dev);</a>
<a name="ln1225">	sc-&gt;rl_dev = dev;</a>
<a name="ln1226"> </a>
<a name="ln1227">	mtx_init(&amp;sc-&gt;rl_mtx, device_get_nameunit(dev), MTX_NETWORK_LOCK,</a>
<a name="ln1228">	    MTX_DEF);</a>
<a name="ln1229">	callout_init_mtx(&amp;sc-&gt;rl_stat_callout, &amp;sc-&gt;rl_mtx, 0);</a>
<a name="ln1230"> </a>
<a name="ln1231">	/*</a>
<a name="ln1232">	 * Map control/status registers.</a>
<a name="ln1233">	 */</a>
<a name="ln1234">	pci_enable_busmaster(dev);</a>
<a name="ln1235"> </a>
<a name="ln1236">	devid = pci_get_device(dev);</a>
<a name="ln1237">	/*</a>
<a name="ln1238">	 * Prefer memory space register mapping over IO space.</a>
<a name="ln1239">	 * Because RTL8169SC does not seem to work when memory mapping</a>
<a name="ln1240">	 * is used always activate io mapping.</a>
<a name="ln1241">	 */</a>
<a name="ln1242">	if (devid == RT_DEVICEID_8169SC)</a>
<a name="ln1243">		prefer_iomap = 1;</a>
<a name="ln1244">	if (prefer_iomap == 0) {</a>
<a name="ln1245">		sc-&gt;rl_res_id = PCIR_BAR(1);</a>
<a name="ln1246">		sc-&gt;rl_res_type = SYS_RES_MEMORY;</a>
<a name="ln1247">		/* RTL8168/8101E seems to use different BARs. */</a>
<a name="ln1248">		if (devid == RT_DEVICEID_8168 || devid == RT_DEVICEID_8101E)</a>
<a name="ln1249">			sc-&gt;rl_res_id = PCIR_BAR(2);</a>
<a name="ln1250">	} else {</a>
<a name="ln1251">		sc-&gt;rl_res_id = PCIR_BAR(0);</a>
<a name="ln1252">		sc-&gt;rl_res_type = SYS_RES_IOPORT;</a>
<a name="ln1253">	}</a>
<a name="ln1254">	sc-&gt;rl_res = bus_alloc_resource_any(dev, sc-&gt;rl_res_type,</a>
<a name="ln1255">	    &amp;sc-&gt;rl_res_id, RF_ACTIVE);</a>
<a name="ln1256">	if (sc-&gt;rl_res == NULL &amp;&amp; prefer_iomap == 0) {</a>
<a name="ln1257">		sc-&gt;rl_res_id = PCIR_BAR(0);</a>
<a name="ln1258">		sc-&gt;rl_res_type = SYS_RES_IOPORT;</a>
<a name="ln1259">		sc-&gt;rl_res = bus_alloc_resource_any(dev, sc-&gt;rl_res_type,</a>
<a name="ln1260">		    &amp;sc-&gt;rl_res_id, RF_ACTIVE);</a>
<a name="ln1261">	}</a>
<a name="ln1262">	if (sc-&gt;rl_res == NULL) {</a>
<a name="ln1263">		device_printf(dev, &quot;couldn't map ports/memory\n&quot;);</a>
<a name="ln1264">		error = ENXIO;</a>
<a name="ln1265">		goto fail;</a>
<a name="ln1266">	}</a>
<a name="ln1267"> </a>
<a name="ln1268">	sc-&gt;rl_btag = rman_get_bustag(sc-&gt;rl_res);</a>
<a name="ln1269">	sc-&gt;rl_bhandle = rman_get_bushandle(sc-&gt;rl_res);</a>
<a name="ln1270"> </a>
<a name="ln1271">	msic = pci_msi_count(dev);</a>
<a name="ln1272">	msixc = pci_msix_count(dev);</a>
<a name="ln1273">	if (pci_find_cap(dev, PCIY_EXPRESS, &amp;reg) == 0) {</a>
<a name="ln1274">		sc-&gt;rl_flags |= RL_FLAG_PCIE;</a>
<a name="ln1275">		sc-&gt;rl_expcap = reg;</a>
<a name="ln1276">	}</a>
<a name="ln1277">	if (bootverbose) {</a>
<a name="ln1278">		device_printf(dev, &quot;MSI count : %d\n&quot;, msic);</a>
<a name="ln1279">		device_printf(dev, &quot;MSI-X count : %d\n&quot;, msixc);</a>
<a name="ln1280">	}</a>
<a name="ln1281">	if (msix_disable &gt; 0)</a>
<a name="ln1282">		msixc = 0;</a>
<a name="ln1283">	if (msi_disable &gt; 0)</a>
<a name="ln1284">		msic = 0;</a>
<a name="ln1285">	/* Prefer MSI-X to MSI. */</a>
<a name="ln1286">	if (msixc &gt; 0) {</a>
<a name="ln1287">		msixc = RL_MSI_MESSAGES;</a>
<a name="ln1288">		rid = PCIR_BAR(4);</a>
<a name="ln1289">		sc-&gt;rl_res_pba = bus_alloc_resource_any(dev, SYS_RES_MEMORY,</a>
<a name="ln1290">		    &amp;rid, RF_ACTIVE);</a>
<a name="ln1291">		if (sc-&gt;rl_res_pba == NULL) {</a>
<a name="ln1292">			device_printf(sc-&gt;rl_dev,</a>
<a name="ln1293">			    &quot;could not allocate MSI-X PBA resource\n&quot;);</a>
<a name="ln1294">		}</a>
<a name="ln1295">		if (sc-&gt;rl_res_pba != NULL &amp;&amp;</a>
<a name="ln1296">		    pci_alloc_msix(dev, &amp;msixc) == 0) {</a>
<a name="ln1297">			if (msixc == RL_MSI_MESSAGES) {</a>
<a name="ln1298">				device_printf(dev, &quot;Using %d MSI-X message\n&quot;,</a>
<a name="ln1299">				    msixc);</a>
<a name="ln1300">				sc-&gt;rl_flags |= RL_FLAG_MSIX;</a>
<a name="ln1301">			} else</a>
<a name="ln1302">				pci_release_msi(dev);</a>
<a name="ln1303">		}</a>
<a name="ln1304">		if ((sc-&gt;rl_flags &amp; RL_FLAG_MSIX) == 0) {</a>
<a name="ln1305">			if (sc-&gt;rl_res_pba != NULL)</a>
<a name="ln1306">				bus_release_resource(dev, SYS_RES_MEMORY, rid,</a>
<a name="ln1307">				    sc-&gt;rl_res_pba);</a>
<a name="ln1308">			sc-&gt;rl_res_pba = NULL;</a>
<a name="ln1309">			msixc = 0;</a>
<a name="ln1310">		}</a>
<a name="ln1311">	}</a>
<a name="ln1312">	/* Prefer MSI to INTx. */</a>
<a name="ln1313">	if (msixc == 0 &amp;&amp; msic &gt; 0) {</a>
<a name="ln1314">		msic = RL_MSI_MESSAGES;</a>
<a name="ln1315">		if (pci_alloc_msi(dev, &amp;msic) == 0) {</a>
<a name="ln1316">			if (msic == RL_MSI_MESSAGES) {</a>
<a name="ln1317">				device_printf(dev, &quot;Using %d MSI message\n&quot;,</a>
<a name="ln1318">				    msic);</a>
<a name="ln1319">				sc-&gt;rl_flags |= RL_FLAG_MSI;</a>
<a name="ln1320">				/* Explicitly set MSI enable bit. */</a>
<a name="ln1321">				CSR_WRITE_1(sc, RL_EECMD, RL_EE_MODE);</a>
<a name="ln1322">				cfg = CSR_READ_1(sc, RL_CFG2);</a>
<a name="ln1323">				cfg |= RL_CFG2_MSI;</a>
<a name="ln1324">				CSR_WRITE_1(sc, RL_CFG2, cfg);</a>
<a name="ln1325">				CSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_OFF);</a>
<a name="ln1326">			} else</a>
<a name="ln1327">				pci_release_msi(dev);</a>
<a name="ln1328">		}</a>
<a name="ln1329">		if ((sc-&gt;rl_flags &amp; RL_FLAG_MSI) == 0)</a>
<a name="ln1330">			msic = 0;</a>
<a name="ln1331">	}</a>
<a name="ln1332"> </a>
<a name="ln1333">	/* Allocate interrupt */</a>
<a name="ln1334">	if ((sc-&gt;rl_flags &amp; (RL_FLAG_MSI | RL_FLAG_MSIX)) == 0) {</a>
<a name="ln1335">		rid = 0;</a>
<a name="ln1336">		sc-&gt;rl_irq[0] = bus_alloc_resource_any(dev, SYS_RES_IRQ, &amp;rid,</a>
<a name="ln1337">		    RF_SHAREABLE | RF_ACTIVE);</a>
<a name="ln1338">		if (sc-&gt;rl_irq[0] == NULL) {</a>
<a name="ln1339">			device_printf(dev, &quot;couldn't allocate IRQ resources\n&quot;);</a>
<a name="ln1340">			error = ENXIO;</a>
<a name="ln1341">			goto fail;</a>
<a name="ln1342">		}</a>
<a name="ln1343">	} else {</a>
<a name="ln1344">		for (i = 0, rid = 1; i &lt; RL_MSI_MESSAGES; i++, rid++) {</a>
<a name="ln1345">			sc-&gt;rl_irq[i] = bus_alloc_resource_any(dev,</a>
<a name="ln1346">			    SYS_RES_IRQ, &amp;rid, RF_ACTIVE);</a>
<a name="ln1347">			if (sc-&gt;rl_irq[i] == NULL) {</a>
<a name="ln1348">				device_printf(dev,</a>
<a name="ln1349">				    &quot;couldn't allocate IRQ resources for &quot;</a>
<a name="ln1350">				    &quot;message %d\n&quot;, rid);</a>
<a name="ln1351">				error = ENXIO;</a>
<a name="ln1352">				goto fail;</a>
<a name="ln1353">			}</a>
<a name="ln1354">		}</a>
<a name="ln1355">	}</a>
<a name="ln1356"> </a>
<a name="ln1357">	if ((sc-&gt;rl_flags &amp; RL_FLAG_MSI) == 0) {</a>
<a name="ln1358">		CSR_WRITE_1(sc, RL_EECMD, RL_EE_MODE);</a>
<a name="ln1359">		cfg = CSR_READ_1(sc, RL_CFG2);</a>
<a name="ln1360">		if ((cfg &amp; RL_CFG2_MSI) != 0) {</a>
<a name="ln1361">			device_printf(dev, &quot;turning off MSI enable bit.\n&quot;);</a>
<a name="ln1362">			cfg &amp;= ~RL_CFG2_MSI;</a>
<a name="ln1363">			CSR_WRITE_1(sc, RL_CFG2, cfg);</a>
<a name="ln1364">		}</a>
<a name="ln1365">		CSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_OFF);</a>
<a name="ln1366">	}</a>
<a name="ln1367"> </a>
<a name="ln1368">	/* Disable ASPM L0S/L1 and CLKREQ. */</a>
<a name="ln1369">	if (sc-&gt;rl_expcap != 0) {</a>
<a name="ln1370">		cap = pci_read_config(dev, sc-&gt;rl_expcap +</a>
<a name="ln1371">		    PCIER_LINK_CAP, 2);</a>
<a name="ln1372">		if ((cap &amp; PCIEM_LINK_CAP_ASPM) != 0) {</a>
<a name="ln1373">			ctl = pci_read_config(dev, sc-&gt;rl_expcap +</a>
<a name="ln1374">			    PCIER_LINK_CTL, 2);</a>
<a name="ln1375">			if ((ctl &amp; (PCIEM_LINK_CTL_ECPM |</a>
<a name="ln1376">			    PCIEM_LINK_CTL_ASPMC))!= 0) {</a>
<a name="ln1377">				ctl &amp;= ~(PCIEM_LINK_CTL_ECPM |</a>
<a name="ln1378">				    PCIEM_LINK_CTL_ASPMC);</a>
<a name="ln1379">				pci_write_config(dev, sc-&gt;rl_expcap +</a>
<a name="ln1380">				    PCIER_LINK_CTL, ctl, 2);</a>
<a name="ln1381">				device_printf(dev, &quot;ASPM disabled\n&quot;);</a>
<a name="ln1382">			}</a>
<a name="ln1383">		} else</a>
<a name="ln1384">			device_printf(dev, &quot;no ASPM capability\n&quot;);</a>
<a name="ln1385">	}</a>
<a name="ln1386"> </a>
<a name="ln1387">	hw_rev = re_hwrevs;</a>
<a name="ln1388">	hwrev = CSR_READ_4(sc, RL_TXCFG);</a>
<a name="ln1389">	switch (hwrev &amp; 0x70000000) {</a>
<a name="ln1390">	case 0x00000000:</a>
<a name="ln1391">	case 0x10000000:</a>
<a name="ln1392">		device_printf(dev, &quot;Chip rev. 0x%08x\n&quot;, hwrev &amp; 0xfc800000);</a>
<a name="ln1393">		hwrev &amp;= (RL_TXCFG_HWREV | 0x80000000);</a>
<a name="ln1394">		break;</a>
<a name="ln1395">	default:</a>
<a name="ln1396">		device_printf(dev, &quot;Chip rev. 0x%08x\n&quot;, hwrev &amp; 0x7c800000);</a>
<a name="ln1397">		sc-&gt;rl_macrev = hwrev &amp; 0x00700000;</a>
<a name="ln1398">		hwrev &amp;= RL_TXCFG_HWREV;</a>
<a name="ln1399">		break;</a>
<a name="ln1400">	}</a>
<a name="ln1401">	device_printf(dev, &quot;MAC rev. 0x%08x\n&quot;, sc-&gt;rl_macrev);</a>
<a name="ln1402">	while (hw_rev-&gt;rl_desc != NULL) {</a>
<a name="ln1403">		if (hw_rev-&gt;rl_rev == hwrev) {</a>
<a name="ln1404">			sc-&gt;rl_type = hw_rev-&gt;rl_type;</a>
<a name="ln1405">			sc-&gt;rl_hwrev = hw_rev;</a>
<a name="ln1406">			break;</a>
<a name="ln1407">		}</a>
<a name="ln1408">		hw_rev++;</a>
<a name="ln1409">	}</a>
<a name="ln1410">	if (hw_rev-&gt;rl_desc == NULL) {</a>
<a name="ln1411">		device_printf(dev, &quot;Unknown H/W revision: 0x%08x\n&quot;, hwrev);</a>
<a name="ln1412">		error = ENXIO;</a>
<a name="ln1413">		goto fail;</a>
<a name="ln1414">	}</a>
<a name="ln1415"> </a>
<a name="ln1416">	switch (hw_rev-&gt;rl_rev) {</a>
<a name="ln1417">	case RL_HWREV_8139CPLUS:</a>
<a name="ln1418">		sc-&gt;rl_flags |= RL_FLAG_FASTETHER | RL_FLAG_AUTOPAD;</a>
<a name="ln1419">		break;</a>
<a name="ln1420">	case RL_HWREV_8100E:</a>
<a name="ln1421">	case RL_HWREV_8101E:</a>
<a name="ln1422">		sc-&gt;rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_FASTETHER;</a>
<a name="ln1423">		break;</a>
<a name="ln1424">	case RL_HWREV_8102E:</a>
<a name="ln1425">	case RL_HWREV_8102EL:</a>
<a name="ln1426">	case RL_HWREV_8102EL_SPIN1:</a>
<a name="ln1427">		sc-&gt;rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_PAR | RL_FLAG_DESCV2 |</a>
<a name="ln1428">		    RL_FLAG_MACSTAT | RL_FLAG_FASTETHER | RL_FLAG_CMDSTOP |</a>
<a name="ln1429">		    RL_FLAG_AUTOPAD;</a>
<a name="ln1430">		break;</a>
<a name="ln1431">	case RL_HWREV_8103E:</a>
<a name="ln1432">		sc-&gt;rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_PAR | RL_FLAG_DESCV2 |</a>
<a name="ln1433">		    RL_FLAG_MACSTAT | RL_FLAG_FASTETHER | RL_FLAG_CMDSTOP |</a>
<a name="ln1434">		    RL_FLAG_AUTOPAD | RL_FLAG_MACSLEEP;</a>
<a name="ln1435">		break;</a>
<a name="ln1436">	case RL_HWREV_8401E:</a>
<a name="ln1437">	case RL_HWREV_8105E:</a>
<a name="ln1438">	case RL_HWREV_8105E_SPIN1:</a>
<a name="ln1439">	case RL_HWREV_8106E:</a>
<a name="ln1440">		sc-&gt;rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_PHYWAKE_PM |</a>
<a name="ln1441">		    RL_FLAG_PAR | RL_FLAG_DESCV2 | RL_FLAG_MACSTAT |</a>
<a name="ln1442">		    RL_FLAG_FASTETHER | RL_FLAG_CMDSTOP | RL_FLAG_AUTOPAD;</a>
<a name="ln1443">		break;</a>
<a name="ln1444">	case RL_HWREV_8402:</a>
<a name="ln1445">		sc-&gt;rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_PHYWAKE_PM |</a>
<a name="ln1446">		    RL_FLAG_PAR | RL_FLAG_DESCV2 | RL_FLAG_MACSTAT |</a>
<a name="ln1447">		    RL_FLAG_FASTETHER | RL_FLAG_CMDSTOP | RL_FLAG_AUTOPAD |</a>
<a name="ln1448">		    RL_FLAG_CMDSTOP_WAIT_TXQ;</a>
<a name="ln1449">		break;</a>
<a name="ln1450">	case RL_HWREV_8168B_SPIN1:</a>
<a name="ln1451">	case RL_HWREV_8168B_SPIN2:</a>
<a name="ln1452">		sc-&gt;rl_flags |= RL_FLAG_WOLRXENB;</a>
<a name="ln1453">		/* FALLTHROUGH */</a>
<a name="ln1454">	case RL_HWREV_8168B_SPIN3:</a>
<a name="ln1455">		sc-&gt;rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_MACSTAT;</a>
<a name="ln1456">		break;</a>
<a name="ln1457">	case RL_HWREV_8168C_SPIN2:</a>
<a name="ln1458">		sc-&gt;rl_flags |= RL_FLAG_MACSLEEP;</a>
<a name="ln1459">		/* FALLTHROUGH */</a>
<a name="ln1460">	case RL_HWREV_8168C:</a>
<a name="ln1461">		if (sc-&gt;rl_macrev == 0x00200000)</a>
<a name="ln1462">			sc-&gt;rl_flags |= RL_FLAG_MACSLEEP;</a>
<a name="ln1463">		/* FALLTHROUGH */</a>
<a name="ln1464">	case RL_HWREV_8168CP:</a>
<a name="ln1465">		sc-&gt;rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_PAR |</a>
<a name="ln1466">		    RL_FLAG_DESCV2 | RL_FLAG_MACSTAT | RL_FLAG_CMDSTOP |</a>
<a name="ln1467">		    RL_FLAG_AUTOPAD | RL_FLAG_JUMBOV2 | RL_FLAG_WOL_MANLINK;</a>
<a name="ln1468">		break;</a>
<a name="ln1469">	case RL_HWREV_8168D:</a>
<a name="ln1470">		sc-&gt;rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_PHYWAKE_PM |</a>
<a name="ln1471">		    RL_FLAG_PAR | RL_FLAG_DESCV2 | RL_FLAG_MACSTAT |</a>
<a name="ln1472">		    RL_FLAG_CMDSTOP | RL_FLAG_AUTOPAD | RL_FLAG_JUMBOV2 |</a>
<a name="ln1473">		    RL_FLAG_WOL_MANLINK;</a>
<a name="ln1474">		break;</a>
<a name="ln1475">	case RL_HWREV_8168DP:</a>
<a name="ln1476">		sc-&gt;rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_PAR |</a>
<a name="ln1477">		    RL_FLAG_DESCV2 | RL_FLAG_MACSTAT | RL_FLAG_AUTOPAD |</a>
<a name="ln1478">		    RL_FLAG_JUMBOV2 | RL_FLAG_WAIT_TXPOLL | RL_FLAG_WOL_MANLINK;</a>
<a name="ln1479">		break;</a>
<a name="ln1480">	case RL_HWREV_8168E:</a>
<a name="ln1481">		sc-&gt;rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_PHYWAKE_PM |</a>
<a name="ln1482">		    RL_FLAG_PAR | RL_FLAG_DESCV2 | RL_FLAG_MACSTAT |</a>
<a name="ln1483">		    RL_FLAG_CMDSTOP | RL_FLAG_AUTOPAD | RL_FLAG_JUMBOV2 |</a>
<a name="ln1484">		    RL_FLAG_WOL_MANLINK;</a>
<a name="ln1485">		break;</a>
<a name="ln1486">	case RL_HWREV_8168E_VL:</a>
<a name="ln1487">	case RL_HWREV_8168F:</a>
<a name="ln1488">		sc-&gt;rl_flags |= RL_FLAG_EARLYOFF;</a>
<a name="ln1489">		/* FALLTHROUGH */</a>
<a name="ln1490">	case RL_HWREV_8411:</a>
<a name="ln1491">		sc-&gt;rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_PAR |</a>
<a name="ln1492">		    RL_FLAG_DESCV2 | RL_FLAG_MACSTAT | RL_FLAG_CMDSTOP |</a>
<a name="ln1493">		    RL_FLAG_AUTOPAD | RL_FLAG_JUMBOV2 |</a>
<a name="ln1494">		    RL_FLAG_CMDSTOP_WAIT_TXQ | RL_FLAG_WOL_MANLINK;</a>
<a name="ln1495">		break;</a>
<a name="ln1496">	case RL_HWREV_8168EP:</a>
<a name="ln1497">	case RL_HWREV_8168G:</a>
<a name="ln1498">	case RL_HWREV_8411B:</a>
<a name="ln1499">		sc-&gt;rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_PAR |</a>
<a name="ln1500">		    RL_FLAG_DESCV2 | RL_FLAG_MACSTAT | RL_FLAG_CMDSTOP |</a>
<a name="ln1501">		    RL_FLAG_AUTOPAD | RL_FLAG_JUMBOV2 |</a>
<a name="ln1502">		    RL_FLAG_CMDSTOP_WAIT_TXQ | RL_FLAG_WOL_MANLINK |</a>
<a name="ln1503">		    RL_FLAG_8168G_PLUS;</a>
<a name="ln1504">		break;</a>
<a name="ln1505">	case RL_HWREV_8168GU:</a>
<a name="ln1506">	case RL_HWREV_8168H:</a>
<a name="ln1507">		if (pci_get_device(dev) == RT_DEVICEID_8101E) {</a>
<a name="ln1508">			/* RTL8106E(US), RTL8107E */</a>
<a name="ln1509">			sc-&gt;rl_flags |= RL_FLAG_FASTETHER;</a>
<a name="ln1510">		} else</a>
<a name="ln1511">			sc-&gt;rl_flags |= RL_FLAG_JUMBOV2 | RL_FLAG_WOL_MANLINK;</a>
<a name="ln1512"> </a>
<a name="ln1513">		sc-&gt;rl_flags |= RL_FLAG_PHYWAKE | RL_FLAG_PAR |</a>
<a name="ln1514">		    RL_FLAG_DESCV2 | RL_FLAG_MACSTAT | RL_FLAG_CMDSTOP |</a>
<a name="ln1515">		    RL_FLAG_AUTOPAD | RL_FLAG_CMDSTOP_WAIT_TXQ |</a>
<a name="ln1516">		    RL_FLAG_8168G_PLUS;</a>
<a name="ln1517">		break;</a>
<a name="ln1518">	case RL_HWREV_8169_8110SB:</a>
<a name="ln1519">	case RL_HWREV_8169_8110SBL:</a>
<a name="ln1520">	case RL_HWREV_8169_8110SC:</a>
<a name="ln1521">	case RL_HWREV_8169_8110SCE:</a>
<a name="ln1522">		sc-&gt;rl_flags |= RL_FLAG_PHYWAKE;</a>
<a name="ln1523">		/* FALLTHROUGH */</a>
<a name="ln1524">	case RL_HWREV_8169:</a>
<a name="ln1525">	case RL_HWREV_8169S:</a>
<a name="ln1526">	case RL_HWREV_8110S:</a>
<a name="ln1527">		sc-&gt;rl_flags |= RL_FLAG_MACRESET;</a>
<a name="ln1528">		break;</a>
<a name="ln1529">	default:</a>
<a name="ln1530">		break;</a>
<a name="ln1531">	}</a>
<a name="ln1532"> </a>
<a name="ln1533">	if (sc-&gt;rl_hwrev-&gt;rl_rev == RL_HWREV_8139CPLUS) {</a>
<a name="ln1534">		sc-&gt;rl_cfg0 = RL_8139_CFG0;</a>
<a name="ln1535">		sc-&gt;rl_cfg1 = RL_8139_CFG1;</a>
<a name="ln1536">		sc-&gt;rl_cfg2 = 0;</a>
<a name="ln1537">		sc-&gt;rl_cfg3 = RL_8139_CFG3;</a>
<a name="ln1538">		sc-&gt;rl_cfg4 = RL_8139_CFG4;</a>
<a name="ln1539">		sc-&gt;rl_cfg5 = RL_8139_CFG5;</a>
<a name="ln1540">	} else {</a>
<a name="ln1541">		sc-&gt;rl_cfg0 = RL_CFG0;</a>
<a name="ln1542">		sc-&gt;rl_cfg1 = RL_CFG1;</a>
<a name="ln1543">		sc-&gt;rl_cfg2 = RL_CFG2;</a>
<a name="ln1544">		sc-&gt;rl_cfg3 = RL_CFG3;</a>
<a name="ln1545">		sc-&gt;rl_cfg4 = RL_CFG4;</a>
<a name="ln1546">		sc-&gt;rl_cfg5 = RL_CFG5;</a>
<a name="ln1547">	}</a>
<a name="ln1548"> </a>
<a name="ln1549">	/* Reset the adapter. */</a>
<a name="ln1550">	RL_LOCK(sc);</a>
<a name="ln1551">	re_reset(sc);</a>
<a name="ln1552">	RL_UNLOCK(sc);</a>
<a name="ln1553"> </a>
<a name="ln1554">	/* Enable PME. */</a>
<a name="ln1555">	CSR_WRITE_1(sc, RL_EECMD, RL_EE_MODE);</a>
<a name="ln1556">	cfg = CSR_READ_1(sc, sc-&gt;rl_cfg1);</a>
<a name="ln1557">	cfg |= RL_CFG1_PME;</a>
<a name="ln1558">	CSR_WRITE_1(sc, sc-&gt;rl_cfg1, cfg);</a>
<a name="ln1559">	cfg = CSR_READ_1(sc, sc-&gt;rl_cfg5);</a>
<a name="ln1560">	cfg &amp;= RL_CFG5_PME_STS;</a>
<a name="ln1561">	CSR_WRITE_1(sc, sc-&gt;rl_cfg5, cfg);</a>
<a name="ln1562">	CSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_OFF);</a>
<a name="ln1563"> </a>
<a name="ln1564">	if ((sc-&gt;rl_flags &amp; RL_FLAG_PAR) != 0) {</a>
<a name="ln1565">		/*</a>
<a name="ln1566">		 * XXX Should have a better way to extract station</a>
<a name="ln1567">		 * address from EEPROM.</a>
<a name="ln1568">		 */</a>
<a name="ln1569">		for (i = 0; i &lt; ETHER_ADDR_LEN; i++)</a>
<a name="ln1570">			eaddr[i] = CSR_READ_1(sc, RL_IDR0 + i);</a>
<a name="ln1571">	} else {</a>
<a name="ln1572">		sc-&gt;rl_eewidth = RL_9356_ADDR_LEN;</a>
<a name="ln1573">		re_read_eeprom(sc, (caddr_t)&amp;re_did, 0, 1);</a>
<a name="ln1574">		if (re_did != 0x8129)</a>
<a name="ln1575">			sc-&gt;rl_eewidth = RL_9346_ADDR_LEN;</a>
<a name="ln1576"> </a>
<a name="ln1577">		/*</a>
<a name="ln1578">		 * Get station address from the EEPROM.</a>
<a name="ln1579">		 */</a>
<a name="ln1580">		re_read_eeprom(sc, (caddr_t)as, RL_EE_EADDR, 3);</a>
<a name="ln1581">		for (i = 0; i &lt; ETHER_ADDR_LEN / 2; i++)</a>
<a name="ln1582">			as[i] = le16toh(as[i]);</a>
<a name="ln1583">		bcopy(as, eaddr, ETHER_ADDR_LEN);</a>
<a name="ln1584">	}</a>
<a name="ln1585"> </a>
<a name="ln1586">	if (sc-&gt;rl_type == RL_8169) {</a>
<a name="ln1587">		/* Set RX length mask and number of descriptors. */</a>
<a name="ln1588">		sc-&gt;rl_rxlenmask = RL_RDESC_STAT_GFRAGLEN;</a>
<a name="ln1589">		sc-&gt;rl_txstart = RL_GTXSTART;</a>
<a name="ln1590">		sc-&gt;rl_ldata.rl_tx_desc_cnt = RL_8169_TX_DESC_CNT;</a>
<a name="ln1591">		sc-&gt;rl_ldata.rl_rx_desc_cnt = RL_8169_RX_DESC_CNT;</a>
<a name="ln1592">	} else {</a>
<a name="ln1593">		/* Set RX length mask and number of descriptors. */</a>
<a name="ln1594">		sc-&gt;rl_rxlenmask = RL_RDESC_STAT_FRAGLEN;</a>
<a name="ln1595">		sc-&gt;rl_txstart = RL_TXSTART;</a>
<a name="ln1596">		sc-&gt;rl_ldata.rl_tx_desc_cnt = RL_8139_TX_DESC_CNT;</a>
<a name="ln1597">		sc-&gt;rl_ldata.rl_rx_desc_cnt = RL_8139_RX_DESC_CNT;</a>
<a name="ln1598">	}</a>
<a name="ln1599"> </a>
<a name="ln1600">	error = re_allocmem(dev, sc);</a>
<a name="ln1601">	if (error)</a>
<a name="ln1602">		goto fail;</a>
<a name="ln1603">	re_add_sysctls(sc);</a>
<a name="ln1604"> </a>
<a name="ln1605">	ifp = sc-&gt;rl_ifp = if_alloc(IFT_ETHER);</a>
<a name="ln1606">	if (ifp == NULL) {</a>
<a name="ln1607">		device_printf(dev, &quot;can not if_alloc()\n&quot;);</a>
<a name="ln1608">		error = ENOSPC;</a>
<a name="ln1609">		goto fail;</a>
<a name="ln1610">	}</a>
<a name="ln1611"> </a>
<a name="ln1612">	/* Take controller out of deep sleep mode. */</a>
<a name="ln1613">	if ((sc-&gt;rl_flags &amp; RL_FLAG_MACSLEEP) != 0) {</a>
<a name="ln1614">		if ((CSR_READ_1(sc, RL_MACDBG) &amp; 0x80) == 0x80)</a>
<a name="ln1615">			CSR_WRITE_1(sc, RL_GPIO,</a>
<a name="ln1616">			    CSR_READ_1(sc, RL_GPIO) | 0x01);</a>
<a name="ln1617">		else</a>
<a name="ln1618">			CSR_WRITE_1(sc, RL_GPIO,</a>
<a name="ln1619">			    CSR_READ_1(sc, RL_GPIO) &amp; ~0x01);</a>
<a name="ln1620">	}</a>
<a name="ln1621"> </a>
<a name="ln1622">	/* Take PHY out of power down mode. */</a>
<a name="ln1623">	if ((sc-&gt;rl_flags &amp; RL_FLAG_PHYWAKE_PM) != 0) {</a>
<a name="ln1624">		CSR_WRITE_1(sc, RL_PMCH, CSR_READ_1(sc, RL_PMCH) | 0x80);</a>
<a name="ln1625">		if (hw_rev-&gt;rl_rev == RL_HWREV_8401E)</a>
<a name="ln1626">			CSR_WRITE_1(sc, 0xD1, CSR_READ_1(sc, 0xD1) &amp; ~0x08);</a>
<a name="ln1627">	}</a>
<a name="ln1628">	if ((sc-&gt;rl_flags &amp; RL_FLAG_PHYWAKE) != 0) {</a>
<a name="ln1629">		re_gmii_writereg(dev, 1, 0x1f, 0);</a>
<a name="ln1630">		re_gmii_writereg(dev, 1, 0x0e, 0);</a>
<a name="ln1631">	}</a>
<a name="ln1632"> </a>
<a name="ln1633">	ifp-&gt;if_softc = sc;</a>
<a name="ln1634">	if_initname(ifp, device_get_name(dev), device_get_unit(dev));</a>
<a name="ln1635">	ifp-&gt;if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;</a>
<a name="ln1636">	ifp-&gt;if_ioctl = re_ioctl;</a>
<a name="ln1637">	ifp-&gt;if_start = re_start;</a>
<a name="ln1638">	/*</a>
<a name="ln1639">	 * RTL8168/8111C generates wrong IP checksummed frame if the</a>
<a name="ln1640">	 * packet has IP options so disable TX checksum offloading.</a>
<a name="ln1641">	 */</a>
<a name="ln1642">	if (sc-&gt;rl_hwrev-&gt;rl_rev == RL_HWREV_8168C ||</a>
<a name="ln1643">	    sc-&gt;rl_hwrev-&gt;rl_rev == RL_HWREV_8168C_SPIN2 ||</a>
<a name="ln1644">	    sc-&gt;rl_hwrev-&gt;rl_rev == RL_HWREV_8168CP) {</a>
<a name="ln1645">		ifp-&gt;if_hwassist = 0;</a>
<a name="ln1646">		ifp-&gt;if_capabilities = IFCAP_RXCSUM | IFCAP_TSO4;</a>
<a name="ln1647">	} else {</a>
<a name="ln1648">		ifp-&gt;if_hwassist = CSUM_IP | CSUM_TCP | CSUM_UDP;</a>
<a name="ln1649">		ifp-&gt;if_capabilities = IFCAP_HWCSUM | IFCAP_TSO4;</a>
<a name="ln1650">	}</a>
<a name="ln1651">	ifp-&gt;if_hwassist |= CSUM_TSO;</a>
<a name="ln1652">	ifp-&gt;if_capenable = ifp-&gt;if_capabilities;</a>
<a name="ln1653">	ifp-&gt;if_init = re_init;</a>
<a name="ln1654">	IFQ_SET_MAXLEN(&amp;ifp-&gt;if_snd, RL_IFQ_MAXLEN);</a>
<a name="ln1655">	ifp-&gt;if_snd.ifq_drv_maxlen = RL_IFQ_MAXLEN;</a>
<a name="ln1656">	IFQ_SET_READY(&amp;ifp-&gt;if_snd);</a>
<a name="ln1657"> </a>
<a name="ln1658">	TASK_INIT(&amp;sc-&gt;rl_inttask, 0, re_int_task, sc);</a>
<a name="ln1659"> </a>
<a name="ln1660">#define	RE_PHYAD_INTERNAL	 0</a>
<a name="ln1661"> </a>
<a name="ln1662">	/* Do MII setup. */</a>
<a name="ln1663">	phy = RE_PHYAD_INTERNAL;</a>
<a name="ln1664">	if (sc-&gt;rl_type == RL_8169)</a>
<a name="ln1665">		phy = 1;</a>
<a name="ln1666">	capmask = BMSR_DEFCAPMASK;</a>
<a name="ln1667">	if ((sc-&gt;rl_flags &amp; RL_FLAG_FASTETHER) != 0)</a>
<a name="ln1668">		 capmask &amp;= ~BMSR_EXTSTAT;</a>
<a name="ln1669">	error = mii_attach(dev, &amp;sc-&gt;rl_miibus, ifp, re_ifmedia_upd,</a>
<a name="ln1670">	    re_ifmedia_sts, capmask, phy, MII_OFFSET_ANY, MIIF_DOPAUSE);</a>
<a name="ln1671">	if (error != 0) {</a>
<a name="ln1672">		device_printf(dev, &quot;attaching PHYs failed\n&quot;);</a>
<a name="ln1673">		goto fail;</a>
<a name="ln1674">	}</a>
<a name="ln1675"> </a>
<a name="ln1676">	/*</a>
<a name="ln1677">	 * Call MI attach routine.</a>
<a name="ln1678">	 */</a>
<a name="ln1679">	ether_ifattach(ifp, eaddr);</a>
<a name="ln1680"> </a>
<a name="ln1681">	/* VLAN capability setup */</a>
<a name="ln1682">	ifp-&gt;if_capabilities |= IFCAP_VLAN_MTU | IFCAP_VLAN_HWTAGGING;</a>
<a name="ln1683">	if (ifp-&gt;if_capabilities &amp; IFCAP_HWCSUM)</a>
<a name="ln1684">		ifp-&gt;if_capabilities |= IFCAP_VLAN_HWCSUM;</a>
<a name="ln1685">	/* Enable WOL if PM is supported. */</a>
<a name="ln1686">	if (pci_find_cap(sc-&gt;rl_dev, PCIY_PMG, &amp;reg) == 0)</a>
<a name="ln1687">		ifp-&gt;if_capabilities |= IFCAP_WOL;</a>
<a name="ln1688">	ifp-&gt;if_capenable = ifp-&gt;if_capabilities;</a>
<a name="ln1689">	ifp-&gt;if_capenable &amp;= ~(IFCAP_WOL_UCAST | IFCAP_WOL_MCAST);</a>
<a name="ln1690">	/*</a>
<a name="ln1691">	 * Don't enable TSO by default.  It is known to generate</a>
<a name="ln1692">	 * corrupted TCP segments(bad TCP options) under certain</a>
<a name="ln1693">	 * circumstances.</a>
<a name="ln1694">	 */</a>
<a name="ln1695">	ifp-&gt;if_hwassist &amp;= ~CSUM_TSO;</a>
<a name="ln1696">	ifp-&gt;if_capenable &amp;= ~(IFCAP_TSO4 | IFCAP_VLAN_HWTSO);</a>
<a name="ln1697">#ifdef DEVICE_POLLING</a>
<a name="ln1698">	ifp-&gt;if_capabilities |= IFCAP_POLLING;</a>
<a name="ln1699">#endif</a>
<a name="ln1700">	/*</a>
<a name="ln1701">	 * Tell the upper layer(s) we support long frames.</a>
<a name="ln1702">	 * Must appear after the call to ether_ifattach() because</a>
<a name="ln1703">	 * ether_ifattach() sets ifi_hdrlen to the default value.</a>
<a name="ln1704">	 */</a>
<a name="ln1705">	ifp-&gt;if_hdrlen = sizeof(struct ether_vlan_header);</a>
<a name="ln1706"> </a>
<a name="ln1707">#ifdef DEV_NETMAP</a>
<a name="ln1708">	re_netmap_attach(sc);</a>
<a name="ln1709">#endif /* DEV_NETMAP */</a>
<a name="ln1710"> </a>
<a name="ln1711">#ifdef RE_DIAG</a>
<a name="ln1712">	/*</a>
<a name="ln1713">	 * Perform hardware diagnostic on the original RTL8169.</a>
<a name="ln1714">	 * Some 32-bit cards were incorrectly wired and would</a>
<a name="ln1715">	 * malfunction if plugged into a 64-bit slot.</a>
<a name="ln1716">	 */</a>
<a name="ln1717">	if (hwrev == RL_HWREV_8169) {</a>
<a name="ln1718">		error = re_diag(sc);</a>
<a name="ln1719">		if (error) {</a>
<a name="ln1720">			device_printf(dev,</a>
<a name="ln1721">		    	&quot;attach aborted due to hardware diag failure\n&quot;);</a>
<a name="ln1722">			ether_ifdetach(ifp);</a>
<a name="ln1723">			goto fail;</a>
<a name="ln1724">		}</a>
<a name="ln1725">	}</a>
<a name="ln1726">#endif</a>
<a name="ln1727"> </a>
<a name="ln1728">#ifdef RE_TX_MODERATION</a>
<a name="ln1729">	intr_filter = 1;</a>
<a name="ln1730">#endif</a>
<a name="ln1731">	/* Hook interrupt last to avoid having to lock softc */</a>
<a name="ln1732">	if ((sc-&gt;rl_flags &amp; (RL_FLAG_MSI | RL_FLAG_MSIX)) != 0 &amp;&amp;</a>
<a name="ln1733">	    intr_filter == 0) {</a>
<a name="ln1734">		error = bus_setup_intr(dev, sc-&gt;rl_irq[0],</a>
<a name="ln1735">		    INTR_TYPE_NET | INTR_MPSAFE, NULL, re_intr_msi, sc,</a>
<a name="ln1736">		    &amp;sc-&gt;rl_intrhand[0]);</a>
<a name="ln1737">	} else {</a>
<a name="ln1738">		error = bus_setup_intr(dev, sc-&gt;rl_irq[0],</a>
<a name="ln1739">		    INTR_TYPE_NET | INTR_MPSAFE, re_intr, NULL, sc,</a>
<a name="ln1740">		    &amp;sc-&gt;rl_intrhand[0]);</a>
<a name="ln1741">	}</a>
<a name="ln1742">	if (error) {</a>
<a name="ln1743">		device_printf(dev, &quot;couldn't set up irq\n&quot;);</a>
<a name="ln1744">		ether_ifdetach(ifp);</a>
<a name="ln1745">		goto fail;</a>
<a name="ln1746">	}</a>
<a name="ln1747"> </a>
<a name="ln1748">	NETDUMP_SET(ifp, re);</a>
<a name="ln1749"> </a>
<a name="ln1750">fail:</a>
<a name="ln1751">	if (error)</a>
<a name="ln1752">		re_detach(dev);</a>
<a name="ln1753"> </a>
<a name="ln1754">	return (error);</a>
<a name="ln1755">}</a>
<a name="ln1756"> </a>
<a name="ln1757">/*</a>
<a name="ln1758"> * Shutdown hardware and free up resources. This can be called any</a>
<a name="ln1759"> * time after the mutex has been initialized. It is called in both</a>
<a name="ln1760"> * the error case in attach and the normal detach case so it needs</a>
<a name="ln1761"> * to be careful about only freeing resources that have actually been</a>
<a name="ln1762"> * allocated.</a>
<a name="ln1763"> */</a>
<a name="ln1764">static int</a>
<a name="ln1765">re_detach(device_t dev)</a>
<a name="ln1766">{</a>
<a name="ln1767">	struct rl_softc		*sc;</a>
<a name="ln1768">	struct ifnet		*ifp;</a>
<a name="ln1769">	int			i, rid;</a>
<a name="ln1770"> </a>
<a name="ln1771">	sc = device_get_softc(dev);</a>
<a name="ln1772">	ifp = sc-&gt;rl_ifp;</a>
<a name="ln1773">	KASSERT(mtx_initialized(&amp;sc-&gt;rl_mtx), (&quot;re mutex not initialized&quot;));</a>
<a name="ln1774"> </a>
<a name="ln1775">	/* These should only be active if attach succeeded */</a>
<a name="ln1776">	if (device_is_attached(dev)) {</a>
<a name="ln1777">#ifdef DEVICE_POLLING</a>
<a name="ln1778">		if (ifp-&gt;if_capenable &amp; IFCAP_POLLING)</a>
<a name="ln1779">			ether_poll_deregister(ifp);</a>
<a name="ln1780">#endif</a>
<a name="ln1781">		RL_LOCK(sc);</a>
<a name="ln1782">#if 0</a>
<a name="ln1783">		sc-&gt;suspended = 1;</a>
<a name="ln1784">#endif</a>
<a name="ln1785">		re_stop(sc);</a>
<a name="ln1786">		RL_UNLOCK(sc);</a>
<a name="ln1787">		callout_drain(&amp;sc-&gt;rl_stat_callout);</a>
<a name="ln1788">		taskqueue_drain(taskqueue_fast, &amp;sc-&gt;rl_inttask);</a>
<a name="ln1789">		/*</a>
<a name="ln1790">		 * Force off the IFF_UP flag here, in case someone</a>
<a name="ln1791">		 * still had a BPF descriptor attached to this</a>
<a name="ln1792">		 * interface. If they do, ether_ifdetach() will cause</a>
<a name="ln1793">		 * the BPF code to try and clear the promisc mode</a>
<a name="ln1794">		 * flag, which will bubble down to re_ioctl(),</a>
<a name="ln1795">		 * which will try to call re_init() again. This will</a>
<a name="ln1796">		 * turn the NIC back on and restart the MII ticker,</a>
<a name="ln1797">		 * which will panic the system when the kernel tries</a>
<a name="ln1798">		 * to invoke the re_tick() function that isn't there</a>
<a name="ln1799">		 * anymore.</a>
<a name="ln1800">		 */</a>
<a name="ln1801">		ifp-&gt;if_flags &amp;= ~IFF_UP;</a>
<a name="ln1802">		ether_ifdetach(ifp);</a>
<a name="ln1803">	}</a>
<a name="ln1804">	if (sc-&gt;rl_miibus)</a>
<a name="ln1805">		device_delete_child(dev, sc-&gt;rl_miibus);</a>
<a name="ln1806">	bus_generic_detach(dev);</a>
<a name="ln1807"> </a>
<a name="ln1808">	/*</a>
<a name="ln1809">	 * The rest is resource deallocation, so we should already be</a>
<a name="ln1810">	 * stopped here.</a>
<a name="ln1811">	 */</a>
<a name="ln1812"> </a>
<a name="ln1813">	if (sc-&gt;rl_intrhand[0] != NULL) {</a>
<a name="ln1814">		bus_teardown_intr(dev, sc-&gt;rl_irq[0], sc-&gt;rl_intrhand[0]);</a>
<a name="ln1815">		sc-&gt;rl_intrhand[0] = NULL;</a>
<a name="ln1816">	}</a>
<a name="ln1817">	if (ifp != NULL) {</a>
<a name="ln1818">#ifdef DEV_NETMAP</a>
<a name="ln1819">		netmap_detach(ifp);</a>
<a name="ln1820">#endif /* DEV_NETMAP */</a>
<a name="ln1821">		if_free(ifp);</a>
<a name="ln1822">	}</a>
<a name="ln1823">	if ((sc-&gt;rl_flags &amp; (RL_FLAG_MSI | RL_FLAG_MSIX)) == 0)</a>
<a name="ln1824">		rid = 0;</a>
<a name="ln1825">	else</a>
<a name="ln1826">		rid = 1;</a>
<a name="ln1827">	if (sc-&gt;rl_irq[0] != NULL) {</a>
<a name="ln1828">		bus_release_resource(dev, SYS_RES_IRQ, rid, sc-&gt;rl_irq[0]);</a>
<a name="ln1829">		sc-&gt;rl_irq[0] = NULL;</a>
<a name="ln1830">	}</a>
<a name="ln1831">	if ((sc-&gt;rl_flags &amp; (RL_FLAG_MSI | RL_FLAG_MSIX)) != 0)</a>
<a name="ln1832">		pci_release_msi(dev);</a>
<a name="ln1833">	if (sc-&gt;rl_res_pba) {</a>
<a name="ln1834">		rid = PCIR_BAR(4);</a>
<a name="ln1835">		bus_release_resource(dev, SYS_RES_MEMORY, rid, sc-&gt;rl_res_pba);</a>
<a name="ln1836">	}</a>
<a name="ln1837">	if (sc-&gt;rl_res)</a>
<a name="ln1838">		bus_release_resource(dev, sc-&gt;rl_res_type, sc-&gt;rl_res_id,</a>
<a name="ln1839">		    sc-&gt;rl_res);</a>
<a name="ln1840"> </a>
<a name="ln1841">	/* Unload and free the RX DMA ring memory and map */</a>
<a name="ln1842"> </a>
<a name="ln1843">	if (sc-&gt;rl_ldata.rl_rx_list_tag) {</a>
<a name="ln1844">		if (sc-&gt;rl_ldata.rl_rx_list_addr)</a>
<a name="ln1845">			bus_dmamap_unload(sc-&gt;rl_ldata.rl_rx_list_tag,</a>
<a name="ln1846">			    sc-&gt;rl_ldata.rl_rx_list_map);</a>
<a name="ln1847">		if (sc-&gt;rl_ldata.rl_rx_list)</a>
<a name="ln1848">			bus_dmamem_free(sc-&gt;rl_ldata.rl_rx_list_tag,</a>
<a name="ln1849">			    sc-&gt;rl_ldata.rl_rx_list,</a>
<a name="ln1850">			    sc-&gt;rl_ldata.rl_rx_list_map);</a>
<a name="ln1851">		bus_dma_tag_destroy(sc-&gt;rl_ldata.rl_rx_list_tag);</a>
<a name="ln1852">	}</a>
<a name="ln1853"> </a>
<a name="ln1854">	/* Unload and free the TX DMA ring memory and map */</a>
<a name="ln1855"> </a>
<a name="ln1856">	if (sc-&gt;rl_ldata.rl_tx_list_tag) {</a>
<a name="ln1857">		if (sc-&gt;rl_ldata.rl_tx_list_addr)</a>
<a name="ln1858">			bus_dmamap_unload(sc-&gt;rl_ldata.rl_tx_list_tag,</a>
<a name="ln1859">			    sc-&gt;rl_ldata.rl_tx_list_map);</a>
<a name="ln1860">		if (sc-&gt;rl_ldata.rl_tx_list)</a>
<a name="ln1861">			bus_dmamem_free(sc-&gt;rl_ldata.rl_tx_list_tag,</a>
<a name="ln1862">			    sc-&gt;rl_ldata.rl_tx_list,</a>
<a name="ln1863">			    sc-&gt;rl_ldata.rl_tx_list_map);</a>
<a name="ln1864">		bus_dma_tag_destroy(sc-&gt;rl_ldata.rl_tx_list_tag);</a>
<a name="ln1865">	}</a>
<a name="ln1866"> </a>
<a name="ln1867">	/* Destroy all the RX and TX buffer maps */</a>
<a name="ln1868"> </a>
<a name="ln1869">	if (sc-&gt;rl_ldata.rl_tx_mtag) {</a>
<a name="ln1870">		for (i = 0; i &lt; sc-&gt;rl_ldata.rl_tx_desc_cnt; i++) {</a>
<a name="ln1871">			if (sc-&gt;rl_ldata.rl_tx_desc[i].tx_dmamap)</a>
<a name="ln1872">				bus_dmamap_destroy(sc-&gt;rl_ldata.rl_tx_mtag,</a>
<a name="ln1873">				    sc-&gt;rl_ldata.rl_tx_desc[i].tx_dmamap);</a>
<a name="ln1874">		}</a>
<a name="ln1875">		bus_dma_tag_destroy(sc-&gt;rl_ldata.rl_tx_mtag);</a>
<a name="ln1876">	}</a>
<a name="ln1877">	if (sc-&gt;rl_ldata.rl_rx_mtag) {</a>
<a name="ln1878">		for (i = 0; i &lt; sc-&gt;rl_ldata.rl_rx_desc_cnt; i++) {</a>
<a name="ln1879">			if (sc-&gt;rl_ldata.rl_rx_desc[i].rx_dmamap)</a>
<a name="ln1880">				bus_dmamap_destroy(sc-&gt;rl_ldata.rl_rx_mtag,</a>
<a name="ln1881">				    sc-&gt;rl_ldata.rl_rx_desc[i].rx_dmamap);</a>
<a name="ln1882">		}</a>
<a name="ln1883">		if (sc-&gt;rl_ldata.rl_rx_sparemap)</a>
<a name="ln1884">			bus_dmamap_destroy(sc-&gt;rl_ldata.rl_rx_mtag,</a>
<a name="ln1885">			    sc-&gt;rl_ldata.rl_rx_sparemap);</a>
<a name="ln1886">		bus_dma_tag_destroy(sc-&gt;rl_ldata.rl_rx_mtag);</a>
<a name="ln1887">	}</a>
<a name="ln1888">	if (sc-&gt;rl_ldata.rl_jrx_mtag) {</a>
<a name="ln1889">		for (i = 0; i &lt; sc-&gt;rl_ldata.rl_rx_desc_cnt; i++) {</a>
<a name="ln1890">			if (sc-&gt;rl_ldata.rl_jrx_desc[i].rx_dmamap)</a>
<a name="ln1891">				bus_dmamap_destroy(sc-&gt;rl_ldata.rl_jrx_mtag,</a>
<a name="ln1892">				    sc-&gt;rl_ldata.rl_jrx_desc[i].rx_dmamap);</a>
<a name="ln1893">		}</a>
<a name="ln1894">		if (sc-&gt;rl_ldata.rl_jrx_sparemap)</a>
<a name="ln1895">			bus_dmamap_destroy(sc-&gt;rl_ldata.rl_jrx_mtag,</a>
<a name="ln1896">			    sc-&gt;rl_ldata.rl_jrx_sparemap);</a>
<a name="ln1897">		bus_dma_tag_destroy(sc-&gt;rl_ldata.rl_jrx_mtag);</a>
<a name="ln1898">	}</a>
<a name="ln1899">	/* Unload and free the stats buffer and map */</a>
<a name="ln1900"> </a>
<a name="ln1901">	if (sc-&gt;rl_ldata.rl_stag) {</a>
<a name="ln1902">		if (sc-&gt;rl_ldata.rl_stats_addr)</a>
<a name="ln1903">			bus_dmamap_unload(sc-&gt;rl_ldata.rl_stag,</a>
<a name="ln1904">			    sc-&gt;rl_ldata.rl_smap);</a>
<a name="ln1905">		if (sc-&gt;rl_ldata.rl_stats)</a>
<a name="ln1906">			bus_dmamem_free(sc-&gt;rl_ldata.rl_stag,</a>
<a name="ln1907">			    sc-&gt;rl_ldata.rl_stats, sc-&gt;rl_ldata.rl_smap);</a>
<a name="ln1908">		bus_dma_tag_destroy(sc-&gt;rl_ldata.rl_stag);</a>
<a name="ln1909">	}</a>
<a name="ln1910"> </a>
<a name="ln1911">	if (sc-&gt;rl_parent_tag)</a>
<a name="ln1912">		bus_dma_tag_destroy(sc-&gt;rl_parent_tag);</a>
<a name="ln1913"> </a>
<a name="ln1914">	mtx_destroy(&amp;sc-&gt;rl_mtx);</a>
<a name="ln1915"> </a>
<a name="ln1916">	return (0);</a>
<a name="ln1917">}</a>
<a name="ln1918"> </a>
<a name="ln1919">static __inline void</a>
<a name="ln1920">re_discard_rxbuf(struct rl_softc *sc, int idx)</a>
<a name="ln1921">{</a>
<a name="ln1922">	struct rl_desc		*desc;</a>
<a name="ln1923">	struct rl_rxdesc	*rxd;</a>
<a name="ln1924">	uint32_t		cmdstat;</a>
<a name="ln1925"> </a>
<a name="ln1926">	if (sc-&gt;rl_ifp-&gt;if_mtu &gt; RL_MTU &amp;&amp;</a>
<a name="ln1927">	    (sc-&gt;rl_flags &amp; RL_FLAG_JUMBOV2) != 0)</a>
<a name="ln1928">		rxd = &amp;sc-&gt;rl_ldata.rl_jrx_desc[idx];</a>
<a name="ln1929">	else</a>
<a name="ln1930">		rxd = &amp;sc-&gt;rl_ldata.rl_rx_desc[idx];</a>
<a name="ln1931">	desc = &amp;sc-&gt;rl_ldata.rl_rx_list[idx];</a>
<a name="ln1932">	desc-&gt;rl_vlanctl = 0;</a>
<a name="ln1933">	cmdstat = rxd-&gt;rx_size;</a>
<a name="ln1934">	if (idx == sc-&gt;rl_ldata.rl_rx_desc_cnt - 1)</a>
<a name="ln1935">		cmdstat |= RL_RDESC_CMD_EOR;</a>
<a name="ln1936">	desc-&gt;rl_cmdstat = htole32(cmdstat | RL_RDESC_CMD_OWN);</a>
<a name="ln1937">}</a>
<a name="ln1938"> </a>
<a name="ln1939">static int</a>
<a name="ln1940">re_newbuf(struct rl_softc *sc, int idx)</a>
<a name="ln1941">{</a>
<a name="ln1942">	struct mbuf		*m;</a>
<a name="ln1943">	struct rl_rxdesc	*rxd;</a>
<a name="ln1944">	bus_dma_segment_t	segs[1];</a>
<a name="ln1945">	bus_dmamap_t		map;</a>
<a name="ln1946">	struct rl_desc		*desc;</a>
<a name="ln1947">	uint32_t		cmdstat;</a>
<a name="ln1948">	int			error, nsegs;</a>
<a name="ln1949"> </a>
<a name="ln1950">	m = m_getcl(M_NOWAIT, MT_DATA, M_PKTHDR);</a>
<a name="ln1951">	if (m == NULL)</a>
<a name="ln1952">		return (ENOBUFS);</a>
<a name="ln1953"> </a>
<a name="ln1954">	m-&gt;m_len = m-&gt;m_pkthdr.len = MCLBYTES;</a>
<a name="ln1955">#ifdef RE_FIXUP_RX</a>
<a name="ln1956">	/*</a>
<a name="ln1957">	 * This is part of an evil trick to deal with non-x86 platforms.</a>
<a name="ln1958">	 * The RealTek chip requires RX buffers to be aligned on 64-bit</a>
<a name="ln1959">	 * boundaries, but that will hose non-x86 machines. To get around</a>
<a name="ln1960">	 * this, we leave some empty space at the start of each buffer</a>
<a name="ln1961">	 * and for non-x86 hosts, we copy the buffer back six bytes</a>
<a name="ln1962">	 * to achieve word alignment. This is slightly more efficient</a>
<a name="ln1963">	 * than allocating a new buffer, copying the contents, and</a>
<a name="ln1964">	 * discarding the old buffer.</a>
<a name="ln1965">	 */</a>
<a name="ln1966">	m_adj(m, RE_ETHER_ALIGN);</a>
<a name="ln1967">#endif</a>
<a name="ln1968">	error = bus_dmamap_load_mbuf_sg(sc-&gt;rl_ldata.rl_rx_mtag,</a>
<a name="ln1969">	    sc-&gt;rl_ldata.rl_rx_sparemap, m, segs, &amp;nsegs, BUS_DMA_NOWAIT);</a>
<a name="ln1970">	if (error != 0) {</a>
<a name="ln1971">		m_freem(m);</a>
<a name="ln1972">		return (ENOBUFS);</a>
<a name="ln1973">	}</a>
<a name="ln1974">	KASSERT(nsegs == 1, (&quot;%s: %d segment returned!&quot;, __func__, nsegs));</a>
<a name="ln1975"> </a>
<a name="ln1976">	rxd = &amp;sc-&gt;rl_ldata.rl_rx_desc[idx];</a>
<a name="ln1977">	if (rxd-&gt;rx_m != NULL) {</a>
<a name="ln1978">		bus_dmamap_sync(sc-&gt;rl_ldata.rl_rx_mtag, rxd-&gt;rx_dmamap,</a>
<a name="ln1979">		    BUS_DMASYNC_POSTREAD);</a>
<a name="ln1980">		bus_dmamap_unload(sc-&gt;rl_ldata.rl_rx_mtag, rxd-&gt;rx_dmamap);</a>
<a name="ln1981">	}</a>
<a name="ln1982"> </a>
<a name="ln1983">	rxd-&gt;rx_m = m;</a>
<a name="ln1984">	map = rxd-&gt;rx_dmamap;</a>
<a name="ln1985">	rxd-&gt;rx_dmamap = sc-&gt;rl_ldata.rl_rx_sparemap;</a>
<a name="ln1986">	rxd-&gt;rx_size = segs[0].ds_len;</a>
<a name="ln1987">	sc-&gt;rl_ldata.rl_rx_sparemap = map;</a>
<a name="ln1988">	bus_dmamap_sync(sc-&gt;rl_ldata.rl_rx_mtag, rxd-&gt;rx_dmamap,</a>
<a name="ln1989">	    BUS_DMASYNC_PREREAD);</a>
<a name="ln1990"> </a>
<a name="ln1991">	desc = &amp;sc-&gt;rl_ldata.rl_rx_list[idx];</a>
<a name="ln1992">	desc-&gt;rl_vlanctl = 0;</a>
<a name="ln1993">	desc-&gt;rl_bufaddr_lo = htole32(RL_ADDR_LO(segs[0].ds_addr));</a>
<a name="ln1994">	desc-&gt;rl_bufaddr_hi = htole32(RL_ADDR_HI(segs[0].ds_addr));</a>
<a name="ln1995">	cmdstat = segs[0].ds_len;</a>
<a name="ln1996">	if (idx == sc-&gt;rl_ldata.rl_rx_desc_cnt - 1)</a>
<a name="ln1997">		cmdstat |= RL_RDESC_CMD_EOR;</a>
<a name="ln1998">	desc-&gt;rl_cmdstat = htole32(cmdstat | RL_RDESC_CMD_OWN);</a>
<a name="ln1999"> </a>
<a name="ln2000">	return (0);</a>
<a name="ln2001">}</a>
<a name="ln2002"> </a>
<a name="ln2003">static int</a>
<a name="ln2004">re_jumbo_newbuf(struct rl_softc *sc, int idx)</a>
<a name="ln2005">{</a>
<a name="ln2006">	struct mbuf		*m;</a>
<a name="ln2007">	struct rl_rxdesc	*rxd;</a>
<a name="ln2008">	bus_dma_segment_t	segs[1];</a>
<a name="ln2009">	bus_dmamap_t		map;</a>
<a name="ln2010">	struct rl_desc		*desc;</a>
<a name="ln2011">	uint32_t		cmdstat;</a>
<a name="ln2012">	int			error, nsegs;</a>
<a name="ln2013"> </a>
<a name="ln2014">	m = m_getjcl(M_NOWAIT, MT_DATA, M_PKTHDR, MJUM9BYTES);</a>
<a name="ln2015">	if (m == NULL)</a>
<a name="ln2016">		return (ENOBUFS);</a>
<a name="ln2017">	m-&gt;m_len = m-&gt;m_pkthdr.len = MJUM9BYTES;</a>
<a name="ln2018">#ifdef RE_FIXUP_RX</a>
<a name="ln2019">	m_adj(m, RE_ETHER_ALIGN);</a>
<a name="ln2020">#endif</a>
<a name="ln2021">	error = bus_dmamap_load_mbuf_sg(sc-&gt;rl_ldata.rl_jrx_mtag,</a>
<a name="ln2022">	    sc-&gt;rl_ldata.rl_jrx_sparemap, m, segs, &amp;nsegs, BUS_DMA_NOWAIT);</a>
<a name="ln2023">	if (error != 0) {</a>
<a name="ln2024">		m_freem(m);</a>
<a name="ln2025">		return (ENOBUFS);</a>
<a name="ln2026">	}</a>
<a name="ln2027">	KASSERT(nsegs == 1, (&quot;%s: %d segment returned!&quot;, __func__, nsegs));</a>
<a name="ln2028"> </a>
<a name="ln2029">	rxd = &amp;sc-&gt;rl_ldata.rl_jrx_desc[idx];</a>
<a name="ln2030">	if (rxd-&gt;rx_m != NULL) {</a>
<a name="ln2031">		bus_dmamap_sync(sc-&gt;rl_ldata.rl_jrx_mtag, rxd-&gt;rx_dmamap,</a>
<a name="ln2032">		    BUS_DMASYNC_POSTREAD);</a>
<a name="ln2033">		bus_dmamap_unload(sc-&gt;rl_ldata.rl_jrx_mtag, rxd-&gt;rx_dmamap);</a>
<a name="ln2034">	}</a>
<a name="ln2035"> </a>
<a name="ln2036">	rxd-&gt;rx_m = m;</a>
<a name="ln2037">	map = rxd-&gt;rx_dmamap;</a>
<a name="ln2038">	rxd-&gt;rx_dmamap = sc-&gt;rl_ldata.rl_jrx_sparemap;</a>
<a name="ln2039">	rxd-&gt;rx_size = segs[0].ds_len;</a>
<a name="ln2040">	sc-&gt;rl_ldata.rl_jrx_sparemap = map;</a>
<a name="ln2041">	bus_dmamap_sync(sc-&gt;rl_ldata.rl_jrx_mtag, rxd-&gt;rx_dmamap,</a>
<a name="ln2042">	    BUS_DMASYNC_PREREAD);</a>
<a name="ln2043"> </a>
<a name="ln2044">	desc = &amp;sc-&gt;rl_ldata.rl_rx_list[idx];</a>
<a name="ln2045">	desc-&gt;rl_vlanctl = 0;</a>
<a name="ln2046">	desc-&gt;rl_bufaddr_lo = htole32(RL_ADDR_LO(segs[0].ds_addr));</a>
<a name="ln2047">	desc-&gt;rl_bufaddr_hi = htole32(RL_ADDR_HI(segs[0].ds_addr));</a>
<a name="ln2048">	cmdstat = segs[0].ds_len;</a>
<a name="ln2049">	if (idx == sc-&gt;rl_ldata.rl_rx_desc_cnt - 1)</a>
<a name="ln2050">		cmdstat |= RL_RDESC_CMD_EOR;</a>
<a name="ln2051">	desc-&gt;rl_cmdstat = htole32(cmdstat | RL_RDESC_CMD_OWN);</a>
<a name="ln2052"> </a>
<a name="ln2053">	return (0);</a>
<a name="ln2054">}</a>
<a name="ln2055"> </a>
<a name="ln2056">#ifdef RE_FIXUP_RX</a>
<a name="ln2057">static __inline void</a>
<a name="ln2058">re_fixup_rx(struct mbuf *m)</a>
<a name="ln2059">{</a>
<a name="ln2060">	int                     i;</a>
<a name="ln2061">	uint16_t                *src, *dst;</a>
<a name="ln2062"> </a>
<a name="ln2063">	src = mtod(m, uint16_t *);</a>
<a name="ln2064">	dst = src - (RE_ETHER_ALIGN - ETHER_ALIGN) / sizeof *src;</a>
<a name="ln2065"> </a>
<a name="ln2066">	for (i = 0; i &lt; (m-&gt;m_len / sizeof(uint16_t) + 1); i++)</a>
<a name="ln2067">		*dst++ = *src++;</a>
<a name="ln2068"> </a>
<a name="ln2069">	m-&gt;m_data -= RE_ETHER_ALIGN - ETHER_ALIGN;</a>
<a name="ln2070">}</a>
<a name="ln2071">#endif</a>
<a name="ln2072"> </a>
<a name="ln2073">static int</a>
<a name="ln2074">re_tx_list_init(struct rl_softc *sc)</a>
<a name="ln2075">{</a>
<a name="ln2076">	struct rl_desc		*desc;</a>
<a name="ln2077">	int			i;</a>
<a name="ln2078"> </a>
<a name="ln2079">	RL_LOCK_ASSERT(sc);</a>
<a name="ln2080"> </a>
<a name="ln2081">	bzero(sc-&gt;rl_ldata.rl_tx_list,</a>
<a name="ln2082">	    sc-&gt;rl_ldata.rl_tx_desc_cnt * sizeof(struct rl_desc));</a>
<a name="ln2083">	for (i = 0; i &lt; sc-&gt;rl_ldata.rl_tx_desc_cnt; i++)</a>
<a name="ln2084">		sc-&gt;rl_ldata.rl_tx_desc[i].tx_m = NULL;</a>
<a name="ln2085">#ifdef DEV_NETMAP</a>
<a name="ln2086">	re_netmap_tx_init(sc);</a>
<a name="ln2087">#endif /* DEV_NETMAP */</a>
<a name="ln2088">	/* Set EOR. */</a>
<a name="ln2089">	desc = &amp;sc-&gt;rl_ldata.rl_tx_list[sc-&gt;rl_ldata.rl_tx_desc_cnt - 1];</a>
<a name="ln2090">	desc-&gt;rl_cmdstat |= htole32(RL_TDESC_CMD_EOR);</a>
<a name="ln2091"> </a>
<a name="ln2092">	bus_dmamap_sync(sc-&gt;rl_ldata.rl_tx_list_tag,</a>
<a name="ln2093">	    sc-&gt;rl_ldata.rl_tx_list_map,</a>
<a name="ln2094">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln2095"> </a>
<a name="ln2096">	sc-&gt;rl_ldata.rl_tx_prodidx = 0;</a>
<a name="ln2097">	sc-&gt;rl_ldata.rl_tx_considx = 0;</a>
<a name="ln2098">	sc-&gt;rl_ldata.rl_tx_free = sc-&gt;rl_ldata.rl_tx_desc_cnt;</a>
<a name="ln2099"> </a>
<a name="ln2100">	return (0);</a>
<a name="ln2101">}</a>
<a name="ln2102"> </a>
<a name="ln2103">static int</a>
<a name="ln2104">re_rx_list_init(struct rl_softc *sc)</a>
<a name="ln2105">{</a>
<a name="ln2106">	int			error, i;</a>
<a name="ln2107"> </a>
<a name="ln2108">	bzero(sc-&gt;rl_ldata.rl_rx_list,</a>
<a name="ln2109">	    sc-&gt;rl_ldata.rl_rx_desc_cnt * sizeof(struct rl_desc));</a>
<a name="ln2110">	for (i = 0; i &lt; sc-&gt;rl_ldata.rl_rx_desc_cnt; i++) {</a>
<a name="ln2111">		sc-&gt;rl_ldata.rl_rx_desc[i].rx_m = NULL;</a>
<a name="ln2112">		if ((error = re_newbuf(sc, i)) != 0)</a>
<a name="ln2113">			return (error);</a>
<a name="ln2114">	}</a>
<a name="ln2115">#ifdef DEV_NETMAP</a>
<a name="ln2116">	re_netmap_rx_init(sc);</a>
<a name="ln2117">#endif /* DEV_NETMAP */</a>
<a name="ln2118"> </a>
<a name="ln2119">	/* Flush the RX descriptors */</a>
<a name="ln2120"> </a>
<a name="ln2121">	bus_dmamap_sync(sc-&gt;rl_ldata.rl_rx_list_tag,</a>
<a name="ln2122">	    sc-&gt;rl_ldata.rl_rx_list_map,</a>
<a name="ln2123">	    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);</a>
<a name="ln2124"> </a>
<a name="ln2125">	sc-&gt;rl_ldata.rl_rx_prodidx = 0;</a>
<a name="ln2126">	sc-&gt;rl_head = sc-&gt;rl_tail = NULL;</a>
<a name="ln2127">	sc-&gt;rl_int_rx_act = 0;</a>
<a name="ln2128"> </a>
<a name="ln2129">	return (0);</a>
<a name="ln2130">}</a>
<a name="ln2131"> </a>
<a name="ln2132">static int</a>
<a name="ln2133">re_jrx_list_init(struct rl_softc *sc)</a>
<a name="ln2134">{</a>
<a name="ln2135">	int			error, i;</a>
<a name="ln2136"> </a>
<a name="ln2137">	bzero(sc-&gt;rl_ldata.rl_rx_list,</a>
<a name="ln2138">	    sc-&gt;rl_ldata.rl_rx_desc_cnt * sizeof(struct rl_desc));</a>
<a name="ln2139">	for (i = 0; i &lt; sc-&gt;rl_ldata.rl_rx_desc_cnt; i++) {</a>
<a name="ln2140">		sc-&gt;rl_ldata.rl_jrx_desc[i].rx_m = NULL;</a>
<a name="ln2141">		if ((error = re_jumbo_newbuf(sc, i)) != 0)</a>
<a name="ln2142">			return (error);</a>
<a name="ln2143">	}</a>
<a name="ln2144"> </a>
<a name="ln2145">	bus_dmamap_sync(sc-&gt;rl_ldata.rl_rx_list_tag,</a>
<a name="ln2146">	    sc-&gt;rl_ldata.rl_rx_list_map,</a>
<a name="ln2147">	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);</a>
<a name="ln2148"> </a>
<a name="ln2149">	sc-&gt;rl_ldata.rl_rx_prodidx = 0;</a>
<a name="ln2150">	sc-&gt;rl_head = sc-&gt;rl_tail = NULL;</a>
<a name="ln2151">	sc-&gt;rl_int_rx_act = 0;</a>
<a name="ln2152"> </a>
<a name="ln2153">	return (0);</a>
<a name="ln2154">}</a>
<a name="ln2155"> </a>
<a name="ln2156">/*</a>
<a name="ln2157"> * RX handler for C+ and 8169. For the gigE chips, we support</a>
<a name="ln2158"> * the reception of jumbo frames that have been fragmented</a>
<a name="ln2159"> * across multiple 2K mbuf cluster buffers.</a>
<a name="ln2160"> */</a>
<a name="ln2161">static int</a>
<a name="ln2162">re_rxeof(struct rl_softc *sc, int *rx_npktsp)</a>
<a name="ln2163">{</a>
<a name="ln2164">	struct mbuf		*m;</a>
<a name="ln2165">	struct ifnet		*ifp;</a>
<a name="ln2166">	int			i, rxerr, total_len;</a>
<a name="ln2167">	struct rl_desc		*cur_rx;</a>
<a name="ln2168">	u_int32_t		rxstat, rxvlan;</a>
<a name="ln2169">	int			jumbo, maxpkt = 16, rx_npkts = 0;</a>
<a name="ln2170"> </a>
<a name="ln2171">	RL_LOCK_ASSERT(sc);</a>
<a name="ln2172"> </a>
<a name="ln2173">	ifp = sc-&gt;rl_ifp;</a>
<a name="ln2174">#ifdef DEV_NETMAP</a>
<a name="ln2175">	if (netmap_rx_irq(ifp, 0, &amp;rx_npkts))</a>
<a name="ln2176">		return 0;</a>
<a name="ln2177">#endif /* DEV_NETMAP */</a>
<a name="ln2178">	if (ifp-&gt;if_mtu &gt; RL_MTU &amp;&amp; (sc-&gt;rl_flags &amp; RL_FLAG_JUMBOV2) != 0)</a>
<a name="ln2179">		jumbo = 1;</a>
<a name="ln2180">	else</a>
<a name="ln2181">		jumbo = 0;</a>
<a name="ln2182"> </a>
<a name="ln2183">	/* Invalidate the descriptor memory */</a>
<a name="ln2184"> </a>
<a name="ln2185">	bus_dmamap_sync(sc-&gt;rl_ldata.rl_rx_list_tag,</a>
<a name="ln2186">	    sc-&gt;rl_ldata.rl_rx_list_map,</a>
<a name="ln2187">	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);</a>
<a name="ln2188"> </a>
<a name="ln2189">	for (i = sc-&gt;rl_ldata.rl_rx_prodidx; maxpkt &gt; 0;</a>
<a name="ln2190">	    i = RL_RX_DESC_NXT(sc, i)) {</a>
<a name="ln2191">		if ((ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) == 0)</a>
<a name="ln2192">			break;</a>
<a name="ln2193">		cur_rx = &amp;sc-&gt;rl_ldata.rl_rx_list[i];</a>
<a name="ln2194">		rxstat = le32toh(cur_rx-&gt;rl_cmdstat);</a>
<a name="ln2195">		if ((rxstat &amp; RL_RDESC_STAT_OWN) != 0)</a>
<a name="ln2196">			break;</a>
<a name="ln2197">		total_len = rxstat &amp; sc-&gt;rl_rxlenmask;</a>
<a name="ln2198">		rxvlan = le32toh(cur_rx-&gt;rl_vlanctl);</a>
<a name="ln2199">		if (jumbo != 0)</a>
<a name="ln2200">			m = sc-&gt;rl_ldata.rl_jrx_desc[i].rx_m;</a>
<a name="ln2201">		else</a>
<a name="ln2202">			m = sc-&gt;rl_ldata.rl_rx_desc[i].rx_m;</a>
<a name="ln2203"> </a>
<a name="ln2204">		if ((sc-&gt;rl_flags &amp; RL_FLAG_JUMBOV2) != 0 &amp;&amp;</a>
<a name="ln2205">		    (rxstat &amp; (RL_RDESC_STAT_SOF | RL_RDESC_STAT_EOF)) !=</a>
<a name="ln2206">		    (RL_RDESC_STAT_SOF | RL_RDESC_STAT_EOF)) {</a>
<a name="ln2207">			/*</a>
<a name="ln2208">			 * RTL8168C or later controllers do not</a>
<a name="ln2209">			 * support multi-fragment packet.</a>
<a name="ln2210">			 */</a>
<a name="ln2211">			re_discard_rxbuf(sc, i);</a>
<a name="ln2212">			continue;</a>
<a name="ln2213">		} else if ((rxstat &amp; RL_RDESC_STAT_EOF) == 0) {</a>
<a name="ln2214">			if (re_newbuf(sc, i) != 0) {</a>
<a name="ln2215">				/*</a>
<a name="ln2216">				 * If this is part of a multi-fragment packet,</a>
<a name="ln2217">				 * discard all the pieces.</a>
<a name="ln2218">				 */</a>
<a name="ln2219">				if (sc-&gt;rl_head != NULL) {</a>
<a name="ln2220">					m_freem(sc-&gt;rl_head);</a>
<a name="ln2221">					sc-&gt;rl_head = sc-&gt;rl_tail = NULL;</a>
<a name="ln2222">				}</a>
<a name="ln2223">				re_discard_rxbuf(sc, i);</a>
<a name="ln2224">				continue;</a>
<a name="ln2225">			}</a>
<a name="ln2226">			m-&gt;m_len = RE_RX_DESC_BUFLEN;</a>
<a name="ln2227">			if (sc-&gt;rl_head == NULL)</a>
<a name="ln2228">				sc-&gt;rl_head = sc-&gt;rl_tail = m;</a>
<a name="ln2229">			else {</a>
<a name="ln2230">				m-&gt;m_flags &amp;= ~M_PKTHDR;</a>
<a name="ln2231">				sc-&gt;rl_tail-&gt;m_next = m;</a>
<a name="ln2232">				sc-&gt;rl_tail = m;</a>
<a name="ln2233">			}</a>
<a name="ln2234">			continue;</a>
<a name="ln2235">		}</a>
<a name="ln2236"> </a>
<a name="ln2237">		/*</a>
<a name="ln2238">		 * NOTE: for the 8139C+, the frame length field</a>
<a name="ln2239">		 * is always 12 bits in size, but for the gigE chips,</a>
<a name="ln2240">		 * it is 13 bits (since the max RX frame length is 16K).</a>
<a name="ln2241">		 * Unfortunately, all 32 bits in the status word</a>
<a name="ln2242">		 * were already used, so to make room for the extra</a>
<a name="ln2243">		 * length bit, RealTek took out the 'frame alignment</a>
<a name="ln2244">		 * error' bit and shifted the other status bits</a>
<a name="ln2245">		 * over one slot. The OWN, EOR, FS and LS bits are</a>
<a name="ln2246">		 * still in the same places. We have already extracted</a>
<a name="ln2247">		 * the frame length and checked the OWN bit, so rather</a>
<a name="ln2248">		 * than using an alternate bit mapping, we shift the</a>
<a name="ln2249">		 * status bits one space to the right so we can evaluate</a>
<a name="ln2250">		 * them using the 8169 status as though it was in the</a>
<a name="ln2251">		 * same format as that of the 8139C+.</a>
<a name="ln2252">		 */</a>
<a name="ln2253">		if (sc-&gt;rl_type == RL_8169)</a>
<a name="ln2254">			rxstat &gt;&gt;= 1;</a>
<a name="ln2255"> </a>
<a name="ln2256">		/*</a>
<a name="ln2257">		 * if total_len &gt; 2^13-1, both _RXERRSUM and _GIANT will be</a>
<a name="ln2258">		 * set, but if CRC is clear, it will still be a valid frame.</a>
<a name="ln2259">		 */</a>
<a name="ln2260">		if ((rxstat &amp; RL_RDESC_STAT_RXERRSUM) != 0) {</a>
<a name="ln2261">			rxerr = 1;</a>
<a name="ln2262">			if ((sc-&gt;rl_flags &amp; RL_FLAG_JUMBOV2) == 0 &amp;&amp;</a>
<a name="ln2263">			    total_len &gt; 8191 &amp;&amp;</a>
<a name="ln2264">			    (rxstat &amp; RL_RDESC_STAT_ERRS) == RL_RDESC_STAT_GIANT)</a>
<a name="ln2265">				rxerr = 0;</a>
<a name="ln2266">			if (rxerr != 0) {</a>
<a name="ln2267">				if_inc_counter(ifp, IFCOUNTER_IERRORS, 1);</a>
<a name="ln2268">				/*</a>
<a name="ln2269">				 * If this is part of a multi-fragment packet,</a>
<a name="ln2270">				 * discard all the pieces.</a>
<a name="ln2271">				 */</a>
<a name="ln2272">				if (sc-&gt;rl_head != NULL) {</a>
<a name="ln2273">					m_freem(sc-&gt;rl_head);</a>
<a name="ln2274">					sc-&gt;rl_head = sc-&gt;rl_tail = NULL;</a>
<a name="ln2275">				}</a>
<a name="ln2276">				re_discard_rxbuf(sc, i);</a>
<a name="ln2277">				continue;</a>
<a name="ln2278">			}</a>
<a name="ln2279">		}</a>
<a name="ln2280"> </a>
<a name="ln2281">		/*</a>
<a name="ln2282">		 * If allocating a replacement mbuf fails,</a>
<a name="ln2283">		 * reload the current one.</a>
<a name="ln2284">		 */</a>
<a name="ln2285">		if (jumbo != 0)</a>
<a name="ln2286">			rxerr = re_jumbo_newbuf(sc, i);</a>
<a name="ln2287">		else</a>
<a name="ln2288">			rxerr = re_newbuf(sc, i);</a>
<a name="ln2289">		if (rxerr != 0) {</a>
<a name="ln2290">			if_inc_counter(ifp, IFCOUNTER_IQDROPS, 1);</a>
<a name="ln2291">			if (sc-&gt;rl_head != NULL) {</a>
<a name="ln2292">				m_freem(sc-&gt;rl_head);</a>
<a name="ln2293">				sc-&gt;rl_head = sc-&gt;rl_tail = NULL;</a>
<a name="ln2294">			}</a>
<a name="ln2295">			re_discard_rxbuf(sc, i);</a>
<a name="ln2296">			continue;</a>
<a name="ln2297">		}</a>
<a name="ln2298"> </a>
<a name="ln2299">		if (sc-&gt;rl_head != NULL) {</a>
<a name="ln2300">			if (jumbo != 0)</a>
<a name="ln2301">				m-&gt;m_len = total_len;</a>
<a name="ln2302">			else {</a>
<a name="ln2303">				m-&gt;m_len = total_len % RE_RX_DESC_BUFLEN;</a>
<a name="ln2304">				if (m-&gt;m_len == 0)</a>
<a name="ln2305">					m-&gt;m_len = RE_RX_DESC_BUFLEN;</a>
<a name="ln2306">			}</a>
<a name="ln2307">			/*</a>
<a name="ln2308">			 * Special case: if there's 4 bytes or less</a>
<a name="ln2309">			 * in this buffer, the mbuf can be discarded:</a>
<a name="ln2310">			 * the last 4 bytes is the CRC, which we don't</a>
<a name="ln2311">			 * care about anyway.</a>
<a name="ln2312">			 */</a>
<a name="ln2313">			if (m-&gt;m_len &lt;= ETHER_CRC_LEN) {</a>
<a name="ln2314">				sc-&gt;rl_tail-&gt;m_len -=</a>
<a name="ln2315">				    (ETHER_CRC_LEN - m-&gt;m_len);</a>
<a name="ln2316">				m_freem(m);</a>
<a name="ln2317">			} else {</a>
<a name="ln2318">				m-&gt;m_len -= ETHER_CRC_LEN;</a>
<a name="ln2319">				m-&gt;m_flags &amp;= ~M_PKTHDR;</a>
<a name="ln2320">				sc-&gt;rl_tail-&gt;m_next = m;</a>
<a name="ln2321">			}</a>
<a name="ln2322">			m = sc-&gt;rl_head;</a>
<a name="ln2323">			sc-&gt;rl_head = sc-&gt;rl_tail = NULL;</a>
<a name="ln2324">			m-&gt;m_pkthdr.len = total_len - ETHER_CRC_LEN;</a>
<a name="ln2325">		} else</a>
<a name="ln2326">			m-&gt;m_pkthdr.len = m-&gt;m_len =</a>
<a name="ln2327">			    (total_len - ETHER_CRC_LEN);</a>
<a name="ln2328"> </a>
<a name="ln2329">#ifdef RE_FIXUP_RX</a>
<a name="ln2330">		re_fixup_rx(m);</a>
<a name="ln2331">#endif</a>
<a name="ln2332">		if_inc_counter(ifp, IFCOUNTER_IPACKETS, 1);</a>
<a name="ln2333">		m-&gt;m_pkthdr.rcvif = ifp;</a>
<a name="ln2334"> </a>
<a name="ln2335">		/* Do RX checksumming if enabled */</a>
<a name="ln2336"> </a>
<a name="ln2337">		if (ifp-&gt;if_capenable &amp; IFCAP_RXCSUM) {</a>
<a name="ln2338">			if ((sc-&gt;rl_flags &amp; RL_FLAG_DESCV2) == 0) {</a>
<a name="ln2339">				/* Check IP header checksum */</a>
<a name="ln2340">				if (rxstat &amp; RL_RDESC_STAT_PROTOID)</a>
<a name="ln2341">					m-&gt;m_pkthdr.csum_flags |=</a>
<a name="ln2342">					    CSUM_IP_CHECKED;</a>
<a name="ln2343">				if (!(rxstat &amp; RL_RDESC_STAT_IPSUMBAD))</a>
<a name="ln2344">					m-&gt;m_pkthdr.csum_flags |=</a>
<a name="ln2345">					    CSUM_IP_VALID;</a>
<a name="ln2346"> </a>
<a name="ln2347">				/* Check TCP/UDP checksum */</a>
<a name="ln2348">				if ((RL_TCPPKT(rxstat) &amp;&amp;</a>
<a name="ln2349">				    !(rxstat &amp; RL_RDESC_STAT_TCPSUMBAD)) ||</a>
<a name="ln2350">				    (RL_UDPPKT(rxstat) &amp;&amp;</a>
<a name="ln2351">				     !(rxstat &amp; RL_RDESC_STAT_UDPSUMBAD))) {</a>
<a name="ln2352">					m-&gt;m_pkthdr.csum_flags |=</a>
<a name="ln2353">						CSUM_DATA_VALID|CSUM_PSEUDO_HDR;</a>
<a name="ln2354">					m-&gt;m_pkthdr.csum_data = 0xffff;</a>
<a name="ln2355">				}</a>
<a name="ln2356">			} else {</a>
<a name="ln2357">				/*</a>
<a name="ln2358">				 * RTL8168C/RTL816CP/RTL8111C/RTL8111CP</a>
<a name="ln2359">				 */</a>
<a name="ln2360">				if ((rxstat &amp; RL_RDESC_STAT_PROTOID) &amp;&amp;</a>
<a name="ln2361">				    (rxvlan &amp; RL_RDESC_IPV4))</a>
<a name="ln2362">					m-&gt;m_pkthdr.csum_flags |=</a>
<a name="ln2363">					    CSUM_IP_CHECKED;</a>
<a name="ln2364">				if (!(rxstat &amp; RL_RDESC_STAT_IPSUMBAD) &amp;&amp;</a>
<a name="ln2365">				    (rxvlan &amp; RL_RDESC_IPV4))</a>
<a name="ln2366">					m-&gt;m_pkthdr.csum_flags |=</a>
<a name="ln2367">					    CSUM_IP_VALID;</a>
<a name="ln2368">				if (((rxstat &amp; RL_RDESC_STAT_TCP) &amp;&amp;</a>
<a name="ln2369">				    !(rxstat &amp; RL_RDESC_STAT_TCPSUMBAD)) ||</a>
<a name="ln2370">				    ((rxstat &amp; RL_RDESC_STAT_UDP) &amp;&amp;</a>
<a name="ln2371">				    !(rxstat &amp; RL_RDESC_STAT_UDPSUMBAD))) {</a>
<a name="ln2372">					m-&gt;m_pkthdr.csum_flags |=</a>
<a name="ln2373">						CSUM_DATA_VALID|CSUM_PSEUDO_HDR;</a>
<a name="ln2374">					m-&gt;m_pkthdr.csum_data = 0xffff;</a>
<a name="ln2375">				}</a>
<a name="ln2376">			}</a>
<a name="ln2377">		}</a>
<a name="ln2378">		maxpkt--;</a>
<a name="ln2379">		if (rxvlan &amp; RL_RDESC_VLANCTL_TAG) {</a>
<a name="ln2380">			m-&gt;m_pkthdr.ether_vtag =</a>
<a name="ln2381">			    bswap16((rxvlan &amp; RL_RDESC_VLANCTL_DATA));</a>
<a name="ln2382">			m-&gt;m_flags |= M_VLANTAG;</a>
<a name="ln2383">		}</a>
<a name="ln2384">		RL_UNLOCK(sc);</a>
<a name="ln2385">		(*ifp-&gt;if_input)(ifp, m);</a>
<a name="ln2386">		RL_LOCK(sc);</a>
<a name="ln2387">		rx_npkts++;</a>
<a name="ln2388">	}</a>
<a name="ln2389"> </a>
<a name="ln2390">	/* Flush the RX DMA ring */</a>
<a name="ln2391"> </a>
<a name="ln2392">	bus_dmamap_sync(sc-&gt;rl_ldata.rl_rx_list_tag,</a>
<a name="ln2393">	    sc-&gt;rl_ldata.rl_rx_list_map,</a>
<a name="ln2394">	    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);</a>
<a name="ln2395"> </a>
<a name="ln2396">	sc-&gt;rl_ldata.rl_rx_prodidx = i;</a>
<a name="ln2397"> </a>
<a name="ln2398">	if (rx_npktsp != NULL)</a>
<a name="ln2399">		*rx_npktsp = rx_npkts;</a>
<a name="ln2400">	if (maxpkt)</a>
<a name="ln2401">		return (EAGAIN);</a>
<a name="ln2402"> </a>
<a name="ln2403">	return (0);</a>
<a name="ln2404">}</a>
<a name="ln2405"> </a>
<a name="ln2406">static void</a>
<a name="ln2407">re_txeof(struct rl_softc *sc)</a>
<a name="ln2408">{</a>
<a name="ln2409">	struct ifnet		*ifp;</a>
<a name="ln2410">	struct rl_txdesc	*txd;</a>
<a name="ln2411">	u_int32_t		txstat;</a>
<a name="ln2412">	int			cons;</a>
<a name="ln2413"> </a>
<a name="ln2414">	cons = sc-&gt;rl_ldata.rl_tx_considx;</a>
<a name="ln2415">	if (cons == sc-&gt;rl_ldata.rl_tx_prodidx)</a>
<a name="ln2416">		return;</a>
<a name="ln2417"> </a>
<a name="ln2418">	ifp = sc-&gt;rl_ifp;</a>
<a name="ln2419">#ifdef DEV_NETMAP</a>
<a name="ln2420">	if (netmap_tx_irq(ifp, 0))</a>
<a name="ln2421">		return;</a>
<a name="ln2422">#endif /* DEV_NETMAP */</a>
<a name="ln2423">	/* Invalidate the TX descriptor list */</a>
<a name="ln2424">	bus_dmamap_sync(sc-&gt;rl_ldata.rl_tx_list_tag,</a>
<a name="ln2425">	    sc-&gt;rl_ldata.rl_tx_list_map,</a>
<a name="ln2426">	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);</a>
<a name="ln2427"> </a>
<a name="ln2428">	for (; cons != sc-&gt;rl_ldata.rl_tx_prodidx;</a>
<a name="ln2429">	    cons = RL_TX_DESC_NXT(sc, cons)) {</a>
<a name="ln2430">		txstat = le32toh(sc-&gt;rl_ldata.rl_tx_list[cons].rl_cmdstat);</a>
<a name="ln2431">		if (txstat &amp; RL_TDESC_STAT_OWN)</a>
<a name="ln2432">			break;</a>
<a name="ln2433">		/*</a>
<a name="ln2434">		 * We only stash mbufs in the last descriptor</a>
<a name="ln2435">		 * in a fragment chain, which also happens to</a>
<a name="ln2436">		 * be the only place where the TX status bits</a>
<a name="ln2437">		 * are valid.</a>
<a name="ln2438">		 */</a>
<a name="ln2439">		if (txstat &amp; RL_TDESC_CMD_EOF) {</a>
<a name="ln2440">			txd = &amp;sc-&gt;rl_ldata.rl_tx_desc[cons];</a>
<a name="ln2441">			bus_dmamap_sync(sc-&gt;rl_ldata.rl_tx_mtag,</a>
<a name="ln2442">			    txd-&gt;tx_dmamap, BUS_DMASYNC_POSTWRITE);</a>
<a name="ln2443">			bus_dmamap_unload(sc-&gt;rl_ldata.rl_tx_mtag,</a>
<a name="ln2444">			    txd-&gt;tx_dmamap);</a>
<a name="ln2445">			KASSERT(txd-&gt;tx_m != NULL,</a>
<a name="ln2446">			    (&quot;%s: freeing NULL mbufs!&quot;, __func__));</a>
<a name="ln2447">			m_freem(txd-&gt;tx_m);</a>
<a name="ln2448">			txd-&gt;tx_m = NULL;</a>
<a name="ln2449">			if (txstat &amp; (RL_TDESC_STAT_EXCESSCOL|</a>
<a name="ln2450">			    RL_TDESC_STAT_COLCNT))</a>
<a name="ln2451">				if_inc_counter(ifp, IFCOUNTER_COLLISIONS, 1);</a>
<a name="ln2452">			if (txstat &amp; RL_TDESC_STAT_TXERRSUM)</a>
<a name="ln2453">				if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln2454">			else</a>
<a name="ln2455">				if_inc_counter(ifp, IFCOUNTER_OPACKETS, 1);</a>
<a name="ln2456">		}</a>
<a name="ln2457">		sc-&gt;rl_ldata.rl_tx_free++;</a>
<a name="ln2458">		ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_OACTIVE;</a>
<a name="ln2459">	}</a>
<a name="ln2460">	sc-&gt;rl_ldata.rl_tx_considx = cons;</a>
<a name="ln2461"> </a>
<a name="ln2462">	/* No changes made to the TX ring, so no flush needed */</a>
<a name="ln2463"> </a>
<a name="ln2464">	if (sc-&gt;rl_ldata.rl_tx_free != sc-&gt;rl_ldata.rl_tx_desc_cnt) {</a>
<a name="ln2465">#ifdef RE_TX_MODERATION</a>
<a name="ln2466">		/*</a>
<a name="ln2467">		 * If not all descriptors have been reaped yet, reload</a>
<a name="ln2468">		 * the timer so that we will eventually get another</a>
<a name="ln2469">		 * interrupt that will cause us to re-enter this routine.</a>
<a name="ln2470">		 * This is done in case the transmitter has gone idle.</a>
<a name="ln2471">		 */</a>
<a name="ln2472">		CSR_WRITE_4(sc, RL_TIMERCNT, 1);</a>
<a name="ln2473">#endif</a>
<a name="ln2474">	} else</a>
<a name="ln2475">		sc-&gt;rl_watchdog_timer = 0;</a>
<a name="ln2476">}</a>
<a name="ln2477"> </a>
<a name="ln2478">static void</a>
<a name="ln2479">re_tick(void *xsc)</a>
<a name="ln2480">{</a>
<a name="ln2481">	struct rl_softc		*sc;</a>
<a name="ln2482">	struct mii_data		*mii;</a>
<a name="ln2483"> </a>
<a name="ln2484">	sc = xsc;</a>
<a name="ln2485"> </a>
<a name="ln2486">	RL_LOCK_ASSERT(sc);</a>
<a name="ln2487"> </a>
<a name="ln2488">	mii = device_get_softc(sc-&gt;rl_miibus);</a>
<a name="ln2489">	mii_tick(mii);</a>
<a name="ln2490">	if ((sc-&gt;rl_flags &amp; RL_FLAG_LINK) == 0)</a>
<a name="ln2491">		re_miibus_statchg(sc-&gt;rl_dev);</a>
<a name="ln2492">	/*</a>
<a name="ln2493">	 * Reclaim transmitted frames here. Technically it is not</a>
<a name="ln2494">	 * necessary to do here but it ensures periodic reclamation</a>
<a name="ln2495">	 * regardless of Tx completion interrupt which seems to be</a>
<a name="ln2496">	 * lost on PCIe based controllers under certain situations.</a>
<a name="ln2497">	 */</a>
<a name="ln2498">	re_txeof(sc);</a>
<a name="ln2499">	re_watchdog(sc);</a>
<a name="ln2500">	callout_reset(&amp;sc-&gt;rl_stat_callout, hz, re_tick, sc);</a>
<a name="ln2501">}</a>
<a name="ln2502"> </a>
<a name="ln2503">#ifdef DEVICE_POLLING</a>
<a name="ln2504">static int</a>
<a name="ln2505">re_poll(struct ifnet *ifp, enum poll_cmd cmd, int count)</a>
<a name="ln2506">{</a>
<a name="ln2507">	struct rl_softc *sc = ifp-&gt;if_softc;</a>
<a name="ln2508">	int rx_npkts = 0;</a>
<a name="ln2509"> </a>
<a name="ln2510">	RL_LOCK(sc);</a>
<a name="ln2511">	if (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING)</a>
<a name="ln2512">		rx_npkts = re_poll_locked(ifp, cmd, count);</a>
<a name="ln2513">	RL_UNLOCK(sc);</a>
<a name="ln2514">	return (rx_npkts);</a>
<a name="ln2515">}</a>
<a name="ln2516"> </a>
<a name="ln2517">static int</a>
<a name="ln2518">re_poll_locked(struct ifnet *ifp, enum poll_cmd cmd, int count)</a>
<a name="ln2519">{</a>
<a name="ln2520">	struct rl_softc *sc = ifp-&gt;if_softc;</a>
<a name="ln2521">	int rx_npkts;</a>
<a name="ln2522"> </a>
<a name="ln2523">	RL_LOCK_ASSERT(sc);</a>
<a name="ln2524"> </a>
<a name="ln2525">	sc-&gt;rxcycles = count;</a>
<a name="ln2526">	re_rxeof(sc, &amp;rx_npkts);</a>
<a name="ln2527">	re_txeof(sc);</a>
<a name="ln2528"> </a>
<a name="ln2529">	if (!IFQ_DRV_IS_EMPTY(&amp;ifp-&gt;if_snd))</a>
<a name="ln2530">		re_start_locked(ifp);</a>
<a name="ln2531"> </a>
<a name="ln2532">	if (cmd == POLL_AND_CHECK_STATUS) { /* also check status register */</a>
<a name="ln2533">		u_int16_t       status;</a>
<a name="ln2534"> </a>
<a name="ln2535">		status = CSR_READ_2(sc, RL_ISR);</a>
<a name="ln2536">		if (status == 0xffff)</a>
<a name="ln2537">			return (rx_npkts);</a>
<a name="ln2538">		if (status)</a>
<a name="ln2539">			CSR_WRITE_2(sc, RL_ISR, status);</a>
<a name="ln2540">		if ((status &amp; (RL_ISR_TX_OK | RL_ISR_TX_DESC_UNAVAIL)) &amp;&amp;</a>
<a name="ln2541">		    (sc-&gt;rl_flags &amp; RL_FLAG_PCIE))</a>
<a name="ln2542">			CSR_WRITE_1(sc, sc-&gt;rl_txstart, RL_TXSTART_START);</a>
<a name="ln2543"> </a>
<a name="ln2544">		/*</a>
<a name="ln2545">		 * XXX check behaviour on receiver stalls.</a>
<a name="ln2546">		 */</a>
<a name="ln2547"> </a>
<a name="ln2548">		if (status &amp; RL_ISR_SYSTEM_ERR) {</a>
<a name="ln2549">			ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_RUNNING;</a>
<a name="ln2550">			re_init_locked(sc);</a>
<a name="ln2551">		}</a>
<a name="ln2552">	}</a>
<a name="ln2553">	return (rx_npkts);</a>
<a name="ln2554">}</a>
<a name="ln2555">#endif /* DEVICE_POLLING */</a>
<a name="ln2556"> </a>
<a name="ln2557">static int</a>
<a name="ln2558">re_intr(void *arg)</a>
<a name="ln2559">{</a>
<a name="ln2560">	struct rl_softc		*sc;</a>
<a name="ln2561">	uint16_t		status;</a>
<a name="ln2562"> </a>
<a name="ln2563">	sc = arg;</a>
<a name="ln2564"> </a>
<a name="ln2565">	status = CSR_READ_2(sc, RL_ISR);</a>
<a name="ln2566">	if (status == 0xFFFF || (status &amp; RL_INTRS_CPLUS) == 0)</a>
<a name="ln2567">                return (FILTER_STRAY);</a>
<a name="ln2568">	CSR_WRITE_2(sc, RL_IMR, 0);</a>
<a name="ln2569"> </a>
<a name="ln2570">	taskqueue_enqueue(taskqueue_fast, &amp;sc-&gt;rl_inttask);</a>
<a name="ln2571"> </a>
<a name="ln2572">	return (FILTER_HANDLED);</a>
<a name="ln2573">}</a>
<a name="ln2574"> </a>
<a name="ln2575">static void</a>
<a name="ln2576">re_int_task(void *arg, int npending)</a>
<a name="ln2577">{</a>
<a name="ln2578">	struct rl_softc		*sc;</a>
<a name="ln2579">	struct ifnet		*ifp;</a>
<a name="ln2580">	u_int16_t		status;</a>
<a name="ln2581">	int			rval = 0;</a>
<a name="ln2582"> </a>
<a name="ln2583">	sc = arg;</a>
<a name="ln2584">	ifp = sc-&gt;rl_ifp;</a>
<a name="ln2585"> </a>
<a name="ln2586">	RL_LOCK(sc);</a>
<a name="ln2587"> </a>
<a name="ln2588">	status = CSR_READ_2(sc, RL_ISR);</a>
<a name="ln2589">        CSR_WRITE_2(sc, RL_ISR, status);</a>
<a name="ln2590"> </a>
<a name="ln2591">	if (sc-&gt;suspended ||</a>
<a name="ln2592">	    (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) == 0) {</a>
<a name="ln2593">		RL_UNLOCK(sc);</a>
<a name="ln2594">		return;</a>
<a name="ln2595">	}</a>
<a name="ln2596"> </a>
<a name="ln2597">#ifdef DEVICE_POLLING</a>
<a name="ln2598">	if  (ifp-&gt;if_capenable &amp; IFCAP_POLLING) {</a>
<a name="ln2599">		RL_UNLOCK(sc);</a>
<a name="ln2600">		return;</a>
<a name="ln2601">	}</a>
<a name="ln2602">#endif</a>
<a name="ln2603"> </a>
<a name="ln2604">	if (status &amp; (RL_ISR_RX_OK|RL_ISR_RX_ERR|RL_ISR_FIFO_OFLOW))</a>
<a name="ln2605">		rval = re_rxeof(sc, NULL);</a>
<a name="ln2606"> </a>
<a name="ln2607">	/*</a>
<a name="ln2608">	 * Some chips will ignore a second TX request issued</a>
<a name="ln2609">	 * while an existing transmission is in progress. If</a>
<a name="ln2610">	 * the transmitter goes idle but there are still</a>
<a name="ln2611">	 * packets waiting to be sent, we need to restart the</a>
<a name="ln2612">	 * channel here to flush them out. This only seems to</a>
<a name="ln2613">	 * be required with the PCIe devices.</a>
<a name="ln2614">	 */</a>
<a name="ln2615">	if ((status &amp; (RL_ISR_TX_OK | RL_ISR_TX_DESC_UNAVAIL)) &amp;&amp;</a>
<a name="ln2616">	    (sc-&gt;rl_flags &amp; RL_FLAG_PCIE))</a>
<a name="ln2617">		CSR_WRITE_1(sc, sc-&gt;rl_txstart, RL_TXSTART_START);</a>
<a name="ln2618">	if (status &amp; (</a>
<a name="ln2619">#ifdef RE_TX_MODERATION</a>
<a name="ln2620">	    RL_ISR_TIMEOUT_EXPIRED|</a>
<a name="ln2621">#else</a>
<a name="ln2622">	    RL_ISR_TX_OK|</a>
<a name="ln2623">#endif</a>
<a name="ln2624">	    RL_ISR_TX_ERR|RL_ISR_TX_DESC_UNAVAIL))</a>
<a name="ln2625">		re_txeof(sc);</a>
<a name="ln2626"> </a>
<a name="ln2627">	if (status &amp; RL_ISR_SYSTEM_ERR) {</a>
<a name="ln2628">		ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_RUNNING;</a>
<a name="ln2629">		re_init_locked(sc);</a>
<a name="ln2630">	}</a>
<a name="ln2631"> </a>
<a name="ln2632">	if (!IFQ_DRV_IS_EMPTY(&amp;ifp-&gt;if_snd))</a>
<a name="ln2633">		re_start_locked(ifp);</a>
<a name="ln2634"> </a>
<a name="ln2635">	RL_UNLOCK(sc);</a>
<a name="ln2636"> </a>
<a name="ln2637">        if ((CSR_READ_2(sc, RL_ISR) &amp; RL_INTRS_CPLUS) || rval) {</a>
<a name="ln2638">		taskqueue_enqueue(taskqueue_fast, &amp;sc-&gt;rl_inttask);</a>
<a name="ln2639">		return;</a>
<a name="ln2640">	}</a>
<a name="ln2641"> </a>
<a name="ln2642">	CSR_WRITE_2(sc, RL_IMR, RL_INTRS_CPLUS);</a>
<a name="ln2643">}</a>
<a name="ln2644"> </a>
<a name="ln2645">static void</a>
<a name="ln2646">re_intr_msi(void *xsc)</a>
<a name="ln2647">{</a>
<a name="ln2648">	struct rl_softc		*sc;</a>
<a name="ln2649">	struct ifnet		*ifp;</a>
<a name="ln2650">	uint16_t		intrs, status;</a>
<a name="ln2651"> </a>
<a name="ln2652">	sc = xsc;</a>
<a name="ln2653">	RL_LOCK(sc);</a>
<a name="ln2654"> </a>
<a name="ln2655">	ifp = sc-&gt;rl_ifp;</a>
<a name="ln2656">#ifdef DEVICE_POLLING</a>
<a name="ln2657">	if (ifp-&gt;if_capenable &amp; IFCAP_POLLING) {</a>
<a name="ln2658">		RL_UNLOCK(sc);</a>
<a name="ln2659">		return;</a>
<a name="ln2660">	}</a>
<a name="ln2661">#endif</a>
<a name="ln2662">	/* Disable interrupts. */</a>
<a name="ln2663">	CSR_WRITE_2(sc, RL_IMR, 0);</a>
<a name="ln2664">	if ((ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) == 0) {</a>
<a name="ln2665">		RL_UNLOCK(sc);</a>
<a name="ln2666">		return;</a>
<a name="ln2667">	}</a>
<a name="ln2668"> </a>
<a name="ln2669">	intrs = RL_INTRS_CPLUS;</a>
<a name="ln2670">	status = CSR_READ_2(sc, RL_ISR);</a>
<a name="ln2671">        CSR_WRITE_2(sc, RL_ISR, status);</a>
<a name="ln2672">	if (sc-&gt;rl_int_rx_act &gt; 0) {</a>
<a name="ln2673">		intrs &amp;= ~(RL_ISR_RX_OK | RL_ISR_RX_ERR | RL_ISR_FIFO_OFLOW |</a>
<a name="ln2674">		    RL_ISR_RX_OVERRUN);</a>
<a name="ln2675">		status &amp;= ~(RL_ISR_RX_OK | RL_ISR_RX_ERR | RL_ISR_FIFO_OFLOW |</a>
<a name="ln2676">		    RL_ISR_RX_OVERRUN);</a>
<a name="ln2677">	}</a>
<a name="ln2678"> </a>
<a name="ln2679">	if (status &amp; (RL_ISR_TIMEOUT_EXPIRED | RL_ISR_RX_OK | RL_ISR_RX_ERR |</a>
<a name="ln2680">	    RL_ISR_FIFO_OFLOW | RL_ISR_RX_OVERRUN)) {</a>
<a name="ln2681">		re_rxeof(sc, NULL);</a>
<a name="ln2682">		if ((ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) != 0) {</a>
<a name="ln2683">			if (sc-&gt;rl_int_rx_mod != 0 &amp;&amp;</a>
<a name="ln2684">			    (status &amp; (RL_ISR_RX_OK | RL_ISR_RX_ERR |</a>
<a name="ln2685">			    RL_ISR_FIFO_OFLOW | RL_ISR_RX_OVERRUN)) != 0) {</a>
<a name="ln2686">				/* Rearm one-shot timer. */</a>
<a name="ln2687">				CSR_WRITE_4(sc, RL_TIMERCNT, 1);</a>
<a name="ln2688">				intrs &amp;= ~(RL_ISR_RX_OK | RL_ISR_RX_ERR |</a>
<a name="ln2689">				    RL_ISR_FIFO_OFLOW | RL_ISR_RX_OVERRUN);</a>
<a name="ln2690">				sc-&gt;rl_int_rx_act = 1;</a>
<a name="ln2691">			} else {</a>
<a name="ln2692">				intrs |= RL_ISR_RX_OK | RL_ISR_RX_ERR |</a>
<a name="ln2693">				    RL_ISR_FIFO_OFLOW | RL_ISR_RX_OVERRUN;</a>
<a name="ln2694">				sc-&gt;rl_int_rx_act = 0;</a>
<a name="ln2695">			}</a>
<a name="ln2696">		}</a>
<a name="ln2697">	}</a>
<a name="ln2698"> </a>
<a name="ln2699">	/*</a>
<a name="ln2700">	 * Some chips will ignore a second TX request issued</a>
<a name="ln2701">	 * while an existing transmission is in progress. If</a>
<a name="ln2702">	 * the transmitter goes idle but there are still</a>
<a name="ln2703">	 * packets waiting to be sent, we need to restart the</a>
<a name="ln2704">	 * channel here to flush them out. This only seems to</a>
<a name="ln2705">	 * be required with the PCIe devices.</a>
<a name="ln2706">	 */</a>
<a name="ln2707">	if ((status &amp; (RL_ISR_TX_OK | RL_ISR_TX_DESC_UNAVAIL)) &amp;&amp;</a>
<a name="ln2708">	    (sc-&gt;rl_flags &amp; RL_FLAG_PCIE))</a>
<a name="ln2709">		CSR_WRITE_1(sc, sc-&gt;rl_txstart, RL_TXSTART_START);</a>
<a name="ln2710">	if (status &amp; (RL_ISR_TX_OK | RL_ISR_TX_ERR | RL_ISR_TX_DESC_UNAVAIL))</a>
<a name="ln2711">		re_txeof(sc);</a>
<a name="ln2712"> </a>
<a name="ln2713">	if (status &amp; RL_ISR_SYSTEM_ERR) {</a>
<a name="ln2714">		ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_RUNNING;</a>
<a name="ln2715">		re_init_locked(sc);</a>
<a name="ln2716">	}</a>
<a name="ln2717"> </a>
<a name="ln2718">	if ((ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) != 0) {</a>
<a name="ln2719">		if (!IFQ_DRV_IS_EMPTY(&amp;ifp-&gt;if_snd))</a>
<a name="ln2720">			re_start_locked(ifp);</a>
<a name="ln2721">		CSR_WRITE_2(sc, RL_IMR, intrs);</a>
<a name="ln2722">	}</a>
<a name="ln2723">	RL_UNLOCK(sc);</a>
<a name="ln2724">}</a>
<a name="ln2725"> </a>
<a name="ln2726">static int</a>
<a name="ln2727">re_encap(struct rl_softc *sc, struct mbuf **m_head)</a>
<a name="ln2728">{</a>
<a name="ln2729">	struct rl_txdesc	*txd, *txd_last;</a>
<a name="ln2730">	bus_dma_segment_t	segs[RL_NTXSEGS];</a>
<a name="ln2731">	bus_dmamap_t		map;</a>
<a name="ln2732">	struct mbuf		*m_new;</a>
<a name="ln2733">	struct rl_desc		*desc;</a>
<a name="ln2734">	int			nsegs, prod;</a>
<a name="ln2735">	int			i, error, ei, si;</a>
<a name="ln2736">	int			padlen;</a>
<a name="ln2737">	uint32_t		cmdstat, csum_flags, vlanctl;</a>
<a name="ln2738"> </a>
<a name="ln2739">	RL_LOCK_ASSERT(sc);</a>
<a name="ln2740">	M_ASSERTPKTHDR((*m_head));</a>
<a name="ln2741"> </a>
<a name="ln2742">	/*</a>
<a name="ln2743">	 * With some of the RealTek chips, using the checksum offload</a>
<a name="ln2744">	 * support in conjunction with the autopadding feature results</a>
<a name="ln2745">	 * in the transmission of corrupt frames. For example, if we</a>
<a name="ln2746">	 * need to send a really small IP fragment that's less than 60</a>
<a name="ln2747">	 * bytes in size, and IP header checksumming is enabled, the</a>
<a name="ln2748">	 * resulting ethernet frame that appears on the wire will</a>
<a name="ln2749">	 * have garbled payload. To work around this, if TX IP checksum</a>
<a name="ln2750">	 * offload is enabled, we always manually pad short frames out</a>
<a name="ln2751">	 * to the minimum ethernet frame size.</a>
<a name="ln2752">	 */</a>
<a name="ln2753">	if ((sc-&gt;rl_flags &amp; RL_FLAG_AUTOPAD) == 0 &amp;&amp;</a>
<a name="ln2754">	    (*m_head)-&gt;m_pkthdr.len &lt; RL_IP4CSUMTX_PADLEN &amp;&amp;</a>
<a name="ln2755">	    ((*m_head)-&gt;m_pkthdr.csum_flags &amp; CSUM_IP) != 0) {</a>
<a name="ln2756">		padlen = RL_MIN_FRAMELEN - (*m_head)-&gt;m_pkthdr.len;</a>
<a name="ln2757">		if (M_WRITABLE(*m_head) == 0) {</a>
<a name="ln2758">			/* Get a writable copy. */</a>
<a name="ln2759">			m_new = m_dup(*m_head, M_NOWAIT);</a>
<a name="ln2760">			m_freem(*m_head);</a>
<a name="ln2761">			if (m_new == NULL) {</a>
<a name="ln2762">				*m_head = NULL;</a>
<a name="ln2763">				return (ENOBUFS);</a>
<a name="ln2764">			}</a>
<a name="ln2765">			*m_head = m_new;</a>
<a name="ln2766">		}</a>
<a name="ln2767">		if ((*m_head)-&gt;m_next != NULL ||</a>
<a name="ln2768">		    M_TRAILINGSPACE(*m_head) &lt; padlen) {</a>
<a name="ln2769">			m_new = m_defrag(*m_head, M_NOWAIT);</a>
<a name="ln2770">			if (m_new == NULL) {</a>
<a name="ln2771">				m_freem(*m_head);</a>
<a name="ln2772">				*m_head = NULL;</a>
<a name="ln2773">				return (ENOBUFS);</a>
<a name="ln2774">			}</a>
<a name="ln2775">		} else</a>
<a name="ln2776">			m_new = *m_head;</a>
<a name="ln2777"> </a>
<a name="ln2778">		/*</a>
<a name="ln2779">		 * Manually pad short frames, and zero the pad space</a>
<a name="ln2780">		 * to avoid leaking data.</a>
<a name="ln2781">		 */</a>
<a name="ln2782">		bzero(mtod(m_new, char *) + m_new-&gt;m_pkthdr.len, padlen);</a>
<a name="ln2783">		m_new-&gt;m_pkthdr.len += padlen;</a>
<a name="ln2784">		m_new-&gt;m_len = m_new-&gt;m_pkthdr.len;</a>
<a name="ln2785">		*m_head = m_new;</a>
<a name="ln2786">	}</a>
<a name="ln2787"> </a>
<a name="ln2788">	prod = sc-&gt;rl_ldata.rl_tx_prodidx;</a>
<a name="ln2789">	txd = &amp;sc-&gt;rl_ldata.rl_tx_desc[prod];</a>
<a name="ln2790">	error = bus_dmamap_load_mbuf_sg(sc-&gt;rl_ldata.rl_tx_mtag, txd-&gt;tx_dmamap,</a>
<a name="ln2791">	    *m_head, segs, &amp;nsegs, BUS_DMA_NOWAIT);</a>
<a name="ln2792">	if (error == EFBIG) {</a>
<a name="ln2793">		m_new = m_collapse(*m_head, M_NOWAIT, RL_NTXSEGS);</a>
<a name="ln2794">		if (m_new == NULL) {</a>
<a name="ln2795">			m_freem(*m_head);</a>
<a name="ln2796">			*m_head = NULL;</a>
<a name="ln2797">			return (ENOBUFS);</a>
<a name="ln2798">		}</a>
<a name="ln2799">		*m_head = m_new;</a>
<a name="ln2800">		error = bus_dmamap_load_mbuf_sg(sc-&gt;rl_ldata.rl_tx_mtag,</a>
<a name="ln2801">		    txd-&gt;tx_dmamap, *m_head, segs, &amp;nsegs, BUS_DMA_NOWAIT);</a>
<a name="ln2802">		if (error != 0) {</a>
<a name="ln2803">			m_freem(*m_head);</a>
<a name="ln2804">			*m_head = NULL;</a>
<a name="ln2805">			return (error);</a>
<a name="ln2806">		}</a>
<a name="ln2807">	} else if (error != 0)</a>
<a name="ln2808">		return (error);</a>
<a name="ln2809">	if (nsegs == 0) {</a>
<a name="ln2810">		m_freem(*m_head);</a>
<a name="ln2811">		*m_head = NULL;</a>
<a name="ln2812">		return (EIO);</a>
<a name="ln2813">	}</a>
<a name="ln2814"> </a>
<a name="ln2815">	/* Check for number of available descriptors. */</a>
<a name="ln2816">	if (sc-&gt;rl_ldata.rl_tx_free - nsegs &lt;= 1) {</a>
<a name="ln2817">		bus_dmamap_unload(sc-&gt;rl_ldata.rl_tx_mtag, txd-&gt;tx_dmamap);</a>
<a name="ln2818">		return (ENOBUFS);</a>
<a name="ln2819">	}</a>
<a name="ln2820"> </a>
<a name="ln2821">	bus_dmamap_sync(sc-&gt;rl_ldata.rl_tx_mtag, txd-&gt;tx_dmamap,</a>
<a name="ln2822">	    BUS_DMASYNC_PREWRITE);</a>
<a name="ln2823"> </a>
<a name="ln2824">	/*</a>
<a name="ln2825">	 * Set up checksum offload. Note: checksum offload bits must</a>
<a name="ln2826">	 * appear in all descriptors of a multi-descriptor transmit</a>
<a name="ln2827">	 * attempt. This is according to testing done with an 8169</a>
<a name="ln2828">	 * chip. This is a requirement.</a>
<a name="ln2829">	 */</a>
<a name="ln2830">	vlanctl = 0;</a>
<a name="ln2831">	csum_flags = 0;</a>
<a name="ln2832">	if (((*m_head)-&gt;m_pkthdr.csum_flags &amp; CSUM_TSO) != 0) {</a>
<a name="ln2833">		if ((sc-&gt;rl_flags &amp; RL_FLAG_DESCV2) != 0) {</a>
<a name="ln2834">			csum_flags |= RL_TDESC_CMD_LGSEND;</a>
<a name="ln2835">			vlanctl |= ((uint32_t)(*m_head)-&gt;m_pkthdr.tso_segsz &lt;&lt;</a>
<a name="ln2836">			    RL_TDESC_CMD_MSSVALV2_SHIFT);</a>
<a name="ln2837">		} else {</a>
<a name="ln2838">			csum_flags |= RL_TDESC_CMD_LGSEND |</a>
<a name="ln2839">			    ((uint32_t)(*m_head)-&gt;m_pkthdr.tso_segsz &lt;&lt;</a>
<a name="ln2840">			    RL_TDESC_CMD_MSSVAL_SHIFT);</a>
<a name="ln2841">		}</a>
<a name="ln2842">	} else {</a>
<a name="ln2843">		/*</a>
<a name="ln2844">		 * Unconditionally enable IP checksum if TCP or UDP</a>
<a name="ln2845">		 * checksum is required. Otherwise, TCP/UDP checksum</a>
<a name="ln2846">		 * doesn't make effects.</a>
<a name="ln2847">		 */</a>
<a name="ln2848">		if (((*m_head)-&gt;m_pkthdr.csum_flags &amp; RE_CSUM_FEATURES) != 0) {</a>
<a name="ln2849">			if ((sc-&gt;rl_flags &amp; RL_FLAG_DESCV2) == 0) {</a>
<a name="ln2850">				csum_flags |= RL_TDESC_CMD_IPCSUM;</a>
<a name="ln2851">				if (((*m_head)-&gt;m_pkthdr.csum_flags &amp;</a>
<a name="ln2852">				    CSUM_TCP) != 0)</a>
<a name="ln2853">					csum_flags |= RL_TDESC_CMD_TCPCSUM;</a>
<a name="ln2854">				if (((*m_head)-&gt;m_pkthdr.csum_flags &amp;</a>
<a name="ln2855">				    CSUM_UDP) != 0)</a>
<a name="ln2856">					csum_flags |= RL_TDESC_CMD_UDPCSUM;</a>
<a name="ln2857">			} else {</a>
<a name="ln2858">				vlanctl |= RL_TDESC_CMD_IPCSUMV2;</a>
<a name="ln2859">				if (((*m_head)-&gt;m_pkthdr.csum_flags &amp;</a>
<a name="ln2860">				    CSUM_TCP) != 0)</a>
<a name="ln2861">					vlanctl |= RL_TDESC_CMD_TCPCSUMV2;</a>
<a name="ln2862">				if (((*m_head)-&gt;m_pkthdr.csum_flags &amp;</a>
<a name="ln2863">				    CSUM_UDP) != 0)</a>
<a name="ln2864">					vlanctl |= RL_TDESC_CMD_UDPCSUMV2;</a>
<a name="ln2865">			}</a>
<a name="ln2866">		}</a>
<a name="ln2867">	}</a>
<a name="ln2868"> </a>
<a name="ln2869">	/*</a>
<a name="ln2870">	 * Set up hardware VLAN tagging. Note: vlan tag info must</a>
<a name="ln2871">	 * appear in all descriptors of a multi-descriptor</a>
<a name="ln2872">	 * transmission attempt.</a>
<a name="ln2873">	 */</a>
<a name="ln2874">	if ((*m_head)-&gt;m_flags &amp; M_VLANTAG)</a>
<a name="ln2875">		vlanctl |= bswap16((*m_head)-&gt;m_pkthdr.ether_vtag) |</a>
<a name="ln2876">		    RL_TDESC_VLANCTL_TAG;</a>
<a name="ln2877"> </a>
<a name="ln2878">	si = prod;</a>
<a name="ln2879">	for (i = 0; i &lt; nsegs; i++, prod = RL_TX_DESC_NXT(sc, prod)) {</a>
<a name="ln2880">		desc = &amp;sc-&gt;rl_ldata.rl_tx_list[prod];</a>
<a name="ln2881">		desc-&gt;rl_vlanctl = htole32(vlanctl);</a>
<a name="ln2882">		desc-&gt;rl_bufaddr_lo = htole32(RL_ADDR_LO(segs[i].ds_addr));</a>
<a name="ln2883">		desc-&gt;rl_bufaddr_hi = htole32(RL_ADDR_HI(segs[i].ds_addr));</a>
<a name="ln2884">		cmdstat = segs[i].ds_len;</a>
<a name="ln2885">		if (i != 0)</a>
<a name="ln2886">			cmdstat |= RL_TDESC_CMD_OWN;</a>
<a name="ln2887">		if (prod == sc-&gt;rl_ldata.rl_tx_desc_cnt - 1)</a>
<a name="ln2888">			cmdstat |= RL_TDESC_CMD_EOR;</a>
<a name="ln2889">		desc-&gt;rl_cmdstat = htole32(cmdstat | csum_flags);</a>
<a name="ln2890">		sc-&gt;rl_ldata.rl_tx_free--;</a>
<a name="ln2891">	}</a>
<a name="ln2892">	/* Update producer index. */</a>
<a name="ln2893">	sc-&gt;rl_ldata.rl_tx_prodidx = prod;</a>
<a name="ln2894"> </a>
<a name="ln2895">	/* Set EOF on the last descriptor. */</a>
<a name="ln2896">	ei = RL_TX_DESC_PRV(sc, prod);</a>
<a name="ln2897">	desc = &amp;sc-&gt;rl_ldata.rl_tx_list[ei];</a>
<a name="ln2898">	desc-&gt;rl_cmdstat |= htole32(RL_TDESC_CMD_EOF);</a>
<a name="ln2899"> </a>
<a name="ln2900">	desc = &amp;sc-&gt;rl_ldata.rl_tx_list[si];</a>
<a name="ln2901">	/* Set SOF and transfer ownership of packet to the chip. */</a>
<a name="ln2902">	desc-&gt;rl_cmdstat |= htole32(RL_TDESC_CMD_OWN | RL_TDESC_CMD_SOF);</a>
<a name="ln2903"> </a>
<a name="ln2904">	/*</a>
<a name="ln2905">	 * Insure that the map for this transmission</a>
<a name="ln2906">	 * is placed at the array index of the last descriptor</a>
<a name="ln2907">	 * in this chain.  (Swap last and first dmamaps.)</a>
<a name="ln2908">	 */</a>
<a name="ln2909">	txd_last = &amp;sc-&gt;rl_ldata.rl_tx_desc[ei];</a>
<a name="ln2910">	map = txd-&gt;tx_dmamap;</a>
<a name="ln2911">	txd-&gt;tx_dmamap = txd_last-&gt;tx_dmamap;</a>
<a name="ln2912">	txd_last-&gt;tx_dmamap = map;</a>
<a name="ln2913">	txd_last-&gt;tx_m = *m_head;</a>
<a name="ln2914"> </a>
<a name="ln2915">	return (0);</a>
<a name="ln2916">}</a>
<a name="ln2917"> </a>
<a name="ln2918">static void</a>
<a name="ln2919">re_start(struct ifnet *ifp)</a>
<a name="ln2920">{</a>
<a name="ln2921">	struct rl_softc		*sc;</a>
<a name="ln2922"> </a>
<a name="ln2923">	sc = ifp-&gt;if_softc;</a>
<a name="ln2924">	RL_LOCK(sc);</a>
<a name="ln2925">	re_start_locked(ifp);</a>
<a name="ln2926">	RL_UNLOCK(sc);</a>
<a name="ln2927">}</a>
<a name="ln2928"> </a>
<a name="ln2929">/*</a>
<a name="ln2930"> * Main transmit routine for C+ and gigE NICs.</a>
<a name="ln2931"> */</a>
<a name="ln2932">static void</a>
<a name="ln2933">re_start_locked(struct ifnet *ifp)</a>
<a name="ln2934">{</a>
<a name="ln2935">	struct rl_softc		*sc;</a>
<a name="ln2936">	struct mbuf		*m_head;</a>
<a name="ln2937">	int			queued;</a>
<a name="ln2938"> </a>
<a name="ln2939">	sc = ifp-&gt;if_softc;</a>
<a name="ln2940"> </a>
<a name="ln2941">#ifdef DEV_NETMAP</a>
<a name="ln2942">	/* XXX is this necessary ? */</a>
<a name="ln2943">	if (ifp-&gt;if_capenable &amp; IFCAP_NETMAP) {</a>
<a name="ln2944">		struct netmap_kring *kring = NA(ifp)-&gt;tx_rings[0];</a>
<a name="ln2945">		if (sc-&gt;rl_ldata.rl_tx_prodidx != kring-&gt;nr_hwcur) {</a>
<a name="ln2946">			/* kick the tx unit */</a>
<a name="ln2947">			CSR_WRITE_1(sc, sc-&gt;rl_txstart, RL_TXSTART_START);</a>
<a name="ln2948">#ifdef RE_TX_MODERATION</a>
<a name="ln2949">			CSR_WRITE_4(sc, RL_TIMERCNT, 1);</a>
<a name="ln2950">#endif</a>
<a name="ln2951">			sc-&gt;rl_watchdog_timer = 5;</a>
<a name="ln2952">		}</a>
<a name="ln2953">		return;</a>
<a name="ln2954">	}</a>
<a name="ln2955">#endif /* DEV_NETMAP */</a>
<a name="ln2956"> </a>
<a name="ln2957">	if ((ifp-&gt;if_drv_flags &amp; (IFF_DRV_RUNNING | IFF_DRV_OACTIVE)) !=</a>
<a name="ln2958">	    IFF_DRV_RUNNING || (sc-&gt;rl_flags &amp; RL_FLAG_LINK) == 0)</a>
<a name="ln2959">		return;</a>
<a name="ln2960"> </a>
<a name="ln2961">	for (queued = 0; !IFQ_DRV_IS_EMPTY(&amp;ifp-&gt;if_snd) &amp;&amp;</a>
<a name="ln2962">	    sc-&gt;rl_ldata.rl_tx_free &gt; 1;) {</a>
<a name="ln2963">		IFQ_DRV_DEQUEUE(&amp;ifp-&gt;if_snd, m_head);</a>
<a name="ln2964">		if (m_head == NULL)</a>
<a name="ln2965">			break;</a>
<a name="ln2966"> </a>
<a name="ln2967">		if (re_encap(sc, &amp;m_head) != 0) {</a>
<a name="ln2968">			if (m_head == NULL)</a>
<a name="ln2969">				break;</a>
<a name="ln2970">			IFQ_DRV_PREPEND(&amp;ifp-&gt;if_snd, m_head);</a>
<a name="ln2971">			ifp-&gt;if_drv_flags |= IFF_DRV_OACTIVE;</a>
<a name="ln2972">			break;</a>
<a name="ln2973">		}</a>
<a name="ln2974"> </a>
<a name="ln2975">		/*</a>
<a name="ln2976">		 * If there's a BPF listener, bounce a copy of this frame</a>
<a name="ln2977">		 * to him.</a>
<a name="ln2978">		 */</a>
<a name="ln2979">		ETHER_BPF_MTAP(ifp, m_head);</a>
<a name="ln2980"> </a>
<a name="ln2981">		queued++;</a>
<a name="ln2982">	}</a>
<a name="ln2983"> </a>
<a name="ln2984">	if (queued == 0) {</a>
<a name="ln2985">#ifdef RE_TX_MODERATION</a>
<a name="ln2986">		if (sc-&gt;rl_ldata.rl_tx_free != sc-&gt;rl_ldata.rl_tx_desc_cnt)</a>
<a name="ln2987">			CSR_WRITE_4(sc, RL_TIMERCNT, 1);</a>
<a name="ln2988">#endif</a>
<a name="ln2989">		return;</a>
<a name="ln2990">	}</a>
<a name="ln2991"> </a>
<a name="ln2992">	re_start_tx(sc);</a>
<a name="ln2993">}</a>
<a name="ln2994"> </a>
<a name="ln2995">static void</a>
<a name="ln2996">re_start_tx(struct rl_softc *sc)</a>
<a name="ln2997">{</a>
<a name="ln2998"> </a>
<a name="ln2999">	/* Flush the TX descriptors */</a>
<a name="ln3000">	bus_dmamap_sync(sc-&gt;rl_ldata.rl_tx_list_tag,</a>
<a name="ln3001">	    sc-&gt;rl_ldata.rl_tx_list_map,</a>
<a name="ln3002">	    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);</a>
<a name="ln3003"> </a>
<a name="ln3004">	CSR_WRITE_1(sc, sc-&gt;rl_txstart, RL_TXSTART_START);</a>
<a name="ln3005"> </a>
<a name="ln3006">#ifdef RE_TX_MODERATION</a>
<a name="ln3007">	/*</a>
<a name="ln3008">	 * Use the countdown timer for interrupt moderation.</a>
<a name="ln3009">	 * 'TX done' interrupts are disabled. Instead, we reset the</a>
<a name="ln3010">	 * countdown timer, which will begin counting until it hits</a>
<a name="ln3011">	 * the value in the TIMERINT register, and then trigger an</a>
<a name="ln3012">	 * interrupt. Each time we write to the TIMERCNT register,</a>
<a name="ln3013">	 * the timer count is reset to 0.</a>
<a name="ln3014">	 */</a>
<a name="ln3015">	CSR_WRITE_4(sc, RL_TIMERCNT, 1);</a>
<a name="ln3016">#endif</a>
<a name="ln3017"> </a>
<a name="ln3018">	/*</a>
<a name="ln3019">	 * Set a timeout in case the chip goes out to lunch.</a>
<a name="ln3020">	 */</a>
<a name="ln3021">	sc-&gt;rl_watchdog_timer = 5;</a>
<a name="ln3022">}</a>
<a name="ln3023"> </a>
<a name="ln3024">static void</a>
<a name="ln3025">re_set_jumbo(struct rl_softc *sc, int jumbo)</a>
<a name="ln3026">{</a>
<a name="ln3027"> </a>
<a name="ln3028">	if (sc-&gt;rl_hwrev-&gt;rl_rev == RL_HWREV_8168E_VL) {</a>
<a name="ln3029">		pci_set_max_read_req(sc-&gt;rl_dev, 4096);</a>
<a name="ln3030">		return;</a>
<a name="ln3031">	}</a>
<a name="ln3032"> </a>
<a name="ln3033">	CSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_WRITECFG);</a>
<a name="ln3034">	if (jumbo != 0) {</a>
<a name="ln3035">		CSR_WRITE_1(sc, sc-&gt;rl_cfg3, CSR_READ_1(sc, sc-&gt;rl_cfg3) |</a>
<a name="ln3036">		    RL_CFG3_JUMBO_EN0);</a>
<a name="ln3037">		switch (sc-&gt;rl_hwrev-&gt;rl_rev) {</a>
<a name="ln3038">		case RL_HWREV_8168DP:</a>
<a name="ln3039">			break;</a>
<a name="ln3040">		case RL_HWREV_8168E:</a>
<a name="ln3041">			CSR_WRITE_1(sc, sc-&gt;rl_cfg4,</a>
<a name="ln3042">			    CSR_READ_1(sc, sc-&gt;rl_cfg4) | 0x01);</a>
<a name="ln3043">			break;</a>
<a name="ln3044">		default:</a>
<a name="ln3045">			CSR_WRITE_1(sc, sc-&gt;rl_cfg4,</a>
<a name="ln3046">			    CSR_READ_1(sc, sc-&gt;rl_cfg4) | RL_CFG4_JUMBO_EN1);</a>
<a name="ln3047">		}</a>
<a name="ln3048">	} else {</a>
<a name="ln3049">		CSR_WRITE_1(sc, sc-&gt;rl_cfg3, CSR_READ_1(sc, sc-&gt;rl_cfg3) &amp;</a>
<a name="ln3050">		    ~RL_CFG3_JUMBO_EN0);</a>
<a name="ln3051">		switch (sc-&gt;rl_hwrev-&gt;rl_rev) {</a>
<a name="ln3052">		case RL_HWREV_8168DP:</a>
<a name="ln3053">			break;</a>
<a name="ln3054">		case RL_HWREV_8168E:</a>
<a name="ln3055">			CSR_WRITE_1(sc, sc-&gt;rl_cfg4,</a>
<a name="ln3056">			    CSR_READ_1(sc, sc-&gt;rl_cfg4) &amp; ~0x01);</a>
<a name="ln3057">			break;</a>
<a name="ln3058">		default:</a>
<a name="ln3059">			CSR_WRITE_1(sc, sc-&gt;rl_cfg4,</a>
<a name="ln3060">			    CSR_READ_1(sc, sc-&gt;rl_cfg4) &amp; ~RL_CFG4_JUMBO_EN1);</a>
<a name="ln3061">		}</a>
<a name="ln3062">	}</a>
<a name="ln3063">	CSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_OFF);</a>
<a name="ln3064"> </a>
<a name="ln3065">	switch (sc-&gt;rl_hwrev-&gt;rl_rev) {</a>
<a name="ln3066">	case RL_HWREV_8168DP:</a>
<a name="ln3067">		pci_set_max_read_req(sc-&gt;rl_dev, 4096);</a>
<a name="ln3068">		break;</a>
<a name="ln3069">	default:</a>
<a name="ln3070">		if (jumbo != 0)</a>
<a name="ln3071">			pci_set_max_read_req(sc-&gt;rl_dev, 512);</a>
<a name="ln3072">		else</a>
<a name="ln3073">			pci_set_max_read_req(sc-&gt;rl_dev, 4096);</a>
<a name="ln3074">	}</a>
<a name="ln3075">}</a>
<a name="ln3076"> </a>
<a name="ln3077">static void</a>
<a name="ln3078">re_init(void *xsc)</a>
<a name="ln3079">{</a>
<a name="ln3080">	struct rl_softc		*sc = xsc;</a>
<a name="ln3081"> </a>
<a name="ln3082">	RL_LOCK(sc);</a>
<a name="ln3083">	re_init_locked(sc);</a>
<a name="ln3084">	RL_UNLOCK(sc);</a>
<a name="ln3085">}</a>
<a name="ln3086"> </a>
<a name="ln3087">static void</a>
<a name="ln3088">re_init_locked(struct rl_softc *sc)</a>
<a name="ln3089">{</a>
<a name="ln3090">	struct ifnet		*ifp = sc-&gt;rl_ifp;</a>
<a name="ln3091">	struct mii_data		*mii;</a>
<a name="ln3092">	uint32_t		reg;</a>
<a name="ln3093">	uint16_t		cfg;</a>
<a name="ln3094">	union {</a>
<a name="ln3095">		uint32_t align_dummy;</a>
<a name="ln3096">		u_char eaddr[ETHER_ADDR_LEN];</a>
<a name="ln3097">        } eaddr;</a>
<a name="ln3098"> </a>
<a name="ln3099">	RL_LOCK_ASSERT(sc);</a>
<a name="ln3100"> </a>
<a name="ln3101">	mii = device_get_softc(sc-&gt;rl_miibus);</a>
<a name="ln3102"> </a>
<a name="ln3103">	if ((ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) != 0)</a>
<a name="ln3104">		return;</a>
<a name="ln3105"> </a>
<a name="ln3106">	/*</a>
<a name="ln3107">	 * Cancel pending I/O and free all RX/TX buffers.</a>
<a name="ln3108">	 */</a>
<a name="ln3109">	re_stop(sc);</a>
<a name="ln3110"> </a>
<a name="ln3111">	/* Put controller into known state. */</a>
<a name="ln3112">	re_reset(sc);</a>
<a name="ln3113"> </a>
<a name="ln3114">	/*</a>
<a name="ln3115">	 * For C+ mode, initialize the RX descriptors and mbufs.</a>
<a name="ln3116">	 */</a>
<a name="ln3117">	if ((sc-&gt;rl_flags &amp; RL_FLAG_JUMBOV2) != 0) {</a>
<a name="ln3118">		if (ifp-&gt;if_mtu &gt; RL_MTU) {</a>
<a name="ln3119">			if (re_jrx_list_init(sc) != 0) {</a>
<a name="ln3120">				device_printf(sc-&gt;rl_dev,</a>
<a name="ln3121">				    &quot;no memory for jumbo RX buffers\n&quot;);</a>
<a name="ln3122">				re_stop(sc);</a>
<a name="ln3123">				return;</a>
<a name="ln3124">			}</a>
<a name="ln3125">			/* Disable checksum offloading for jumbo frames. */</a>
<a name="ln3126">			ifp-&gt;if_capenable &amp;= ~(IFCAP_HWCSUM | IFCAP_TSO4);</a>
<a name="ln3127">			ifp-&gt;if_hwassist &amp;= ~(RE_CSUM_FEATURES | CSUM_TSO);</a>
<a name="ln3128">		} else {</a>
<a name="ln3129">			if (re_rx_list_init(sc) != 0) {</a>
<a name="ln3130">				device_printf(sc-&gt;rl_dev,</a>
<a name="ln3131">				    &quot;no memory for RX buffers\n&quot;);</a>
<a name="ln3132">				re_stop(sc);</a>
<a name="ln3133">				return;</a>
<a name="ln3134">			}</a>
<a name="ln3135">		}</a>
<a name="ln3136">		re_set_jumbo(sc, ifp-&gt;if_mtu &gt; RL_MTU);</a>
<a name="ln3137">	} else {</a>
<a name="ln3138">		if (re_rx_list_init(sc) != 0) {</a>
<a name="ln3139">			device_printf(sc-&gt;rl_dev, &quot;no memory for RX buffers\n&quot;);</a>
<a name="ln3140">			re_stop(sc);</a>
<a name="ln3141">			return;</a>
<a name="ln3142">		}</a>
<a name="ln3143">		if ((sc-&gt;rl_flags &amp; RL_FLAG_PCIE) != 0 &amp;&amp;</a>
<a name="ln3144">		    pci_get_device(sc-&gt;rl_dev) != RT_DEVICEID_8101E) {</a>
<a name="ln3145">			if (ifp-&gt;if_mtu &gt; RL_MTU)</a>
<a name="ln3146">				pci_set_max_read_req(sc-&gt;rl_dev, 512);</a>
<a name="ln3147">			else</a>
<a name="ln3148">				pci_set_max_read_req(sc-&gt;rl_dev, 4096);</a>
<a name="ln3149">		}</a>
<a name="ln3150">	}</a>
<a name="ln3151">	re_tx_list_init(sc);</a>
<a name="ln3152"> </a>
<a name="ln3153">	/*</a>
<a name="ln3154">	 * Enable C+ RX and TX mode, as well as VLAN stripping and</a>
<a name="ln3155">	 * RX checksum offload. We must configure the C+ register</a>
<a name="ln3156">	 * before all others.</a>
<a name="ln3157">	 */</a>
<a name="ln3158">	cfg = RL_CPLUSCMD_PCI_MRW;</a>
<a name="ln3159">	if ((ifp-&gt;if_capenable &amp; IFCAP_RXCSUM) != 0)</a>
<a name="ln3160">		cfg |= RL_CPLUSCMD_RXCSUM_ENB;</a>
<a name="ln3161">	if ((ifp-&gt;if_capenable &amp; IFCAP_VLAN_HWTAGGING) != 0)</a>
<a name="ln3162">		cfg |= RL_CPLUSCMD_VLANSTRIP;</a>
<a name="ln3163">	if ((sc-&gt;rl_flags &amp; RL_FLAG_MACSTAT) != 0) {</a>
<a name="ln3164">		cfg |= RL_CPLUSCMD_MACSTAT_DIS;</a>
<a name="ln3165">		/* XXX magic. */</a>
<a name="ln3166">		cfg |= 0x0001;</a>
<a name="ln3167">	} else</a>
<a name="ln3168">		cfg |= RL_CPLUSCMD_RXENB | RL_CPLUSCMD_TXENB;</a>
<a name="ln3169">	CSR_WRITE_2(sc, RL_CPLUS_CMD, cfg);</a>
<a name="ln3170">	if (sc-&gt;rl_hwrev-&gt;rl_rev == RL_HWREV_8169_8110SC ||</a>
<a name="ln3171">	    sc-&gt;rl_hwrev-&gt;rl_rev == RL_HWREV_8169_8110SCE) {</a>
<a name="ln3172">		reg = 0x000fff00;</a>
<a name="ln3173">		if ((CSR_READ_1(sc, sc-&gt;rl_cfg2) &amp; RL_CFG2_PCI66MHZ) != 0)</a>
<a name="ln3174">			reg |= 0x000000ff;</a>
<a name="ln3175">		if (sc-&gt;rl_hwrev-&gt;rl_rev == RL_HWREV_8169_8110SCE)</a>
<a name="ln3176">			reg |= 0x00f00000;</a>
<a name="ln3177">		CSR_WRITE_4(sc, 0x7c, reg);</a>
<a name="ln3178">		/* Disable interrupt mitigation. */</a>
<a name="ln3179">		CSR_WRITE_2(sc, 0xe2, 0);</a>
<a name="ln3180">	}</a>
<a name="ln3181">	/*</a>
<a name="ln3182">	 * Disable TSO if interface MTU size is greater than MSS</a>
<a name="ln3183">	 * allowed in controller.</a>
<a name="ln3184">	 */</a>
<a name="ln3185">	if (ifp-&gt;if_mtu &gt; RL_TSO_MTU &amp;&amp; (ifp-&gt;if_capenable &amp; IFCAP_TSO4) != 0) {</a>
<a name="ln3186">		ifp-&gt;if_capenable &amp;= ~IFCAP_TSO4;</a>
<a name="ln3187">		ifp-&gt;if_hwassist &amp;= ~CSUM_TSO;</a>
<a name="ln3188">	}</a>
<a name="ln3189"> </a>
<a name="ln3190">	/*</a>
<a name="ln3191">	 * Init our MAC address.  Even though the chipset</a>
<a name="ln3192">	 * documentation doesn't mention it, we need to enter &quot;Config</a>
<a name="ln3193">	 * register write enable&quot; mode to modify the ID registers.</a>
<a name="ln3194">	 */</a>
<a name="ln3195">	/* Copy MAC address on stack to align. */</a>
<a name="ln3196">	bcopy(IF_LLADDR(ifp), eaddr.eaddr, ETHER_ADDR_LEN);</a>
<a name="ln3197">	CSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_WRITECFG);</a>
<a name="ln3198">	CSR_WRITE_4(sc, RL_IDR0,</a>
<a name="ln3199">	    htole32(*(u_int32_t *)(&amp;eaddr.eaddr[0])));</a>
<a name="ln3200">	CSR_WRITE_4(sc, RL_IDR4,</a>
<a name="ln3201">	    htole32(*(u_int32_t *)(&amp;eaddr.eaddr[4])));</a>
<a name="ln3202">	CSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_OFF);</a>
<a name="ln3203"> </a>
<a name="ln3204">	/*</a>
<a name="ln3205">	 * Load the addresses of the RX and TX lists into the chip.</a>
<a name="ln3206">	 */</a>
<a name="ln3207"> </a>
<a name="ln3208">	CSR_WRITE_4(sc, RL_RXLIST_ADDR_HI,</a>
<a name="ln3209">	    RL_ADDR_HI(sc-&gt;rl_ldata.rl_rx_list_addr));</a>
<a name="ln3210">	CSR_WRITE_4(sc, RL_RXLIST_ADDR_LO,</a>
<a name="ln3211">	    RL_ADDR_LO(sc-&gt;rl_ldata.rl_rx_list_addr));</a>
<a name="ln3212"> </a>
<a name="ln3213">	CSR_WRITE_4(sc, RL_TXLIST_ADDR_HI,</a>
<a name="ln3214">	    RL_ADDR_HI(sc-&gt;rl_ldata.rl_tx_list_addr));</a>
<a name="ln3215">	CSR_WRITE_4(sc, RL_TXLIST_ADDR_LO,</a>
<a name="ln3216">	    RL_ADDR_LO(sc-&gt;rl_ldata.rl_tx_list_addr));</a>
<a name="ln3217"> </a>
<a name="ln3218">	if ((sc-&gt;rl_flags &amp; RL_FLAG_8168G_PLUS) != 0) {</a>
<a name="ln3219">		/* Disable RXDV gate. */</a>
<a name="ln3220">		CSR_WRITE_4(sc, RL_MISC, CSR_READ_4(sc, RL_MISC) &amp;</a>
<a name="ln3221">		    ~0x00080000);</a>
<a name="ln3222">	}</a>
<a name="ln3223"> </a>
<a name="ln3224">	/*</a>
<a name="ln3225">	 * Enable transmit and receive for pre-RTL8168G controllers.</a>
<a name="ln3226">	 * RX/TX MACs should be enabled before RX/TX configuration.</a>
<a name="ln3227">	 */</a>
<a name="ln3228">	if ((sc-&gt;rl_flags &amp; RL_FLAG_8168G_PLUS) == 0)</a>
<a name="ln3229">		CSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB | RL_CMD_RX_ENB);</a>
<a name="ln3230"> </a>
<a name="ln3231">	/*</a>
<a name="ln3232">	 * Set the initial TX configuration.</a>
<a name="ln3233">	 */</a>
<a name="ln3234">	if (sc-&gt;rl_testmode) {</a>
<a name="ln3235">		if (sc-&gt;rl_type == RL_8169)</a>
<a name="ln3236">			CSR_WRITE_4(sc, RL_TXCFG,</a>
<a name="ln3237">			    RL_TXCFG_CONFIG|RL_LOOPTEST_ON);</a>
<a name="ln3238">		else</a>
<a name="ln3239">			CSR_WRITE_4(sc, RL_TXCFG,</a>
<a name="ln3240">			    RL_TXCFG_CONFIG|RL_LOOPTEST_ON_CPLUS);</a>
<a name="ln3241">	} else</a>
<a name="ln3242">		CSR_WRITE_4(sc, RL_TXCFG, RL_TXCFG_CONFIG);</a>
<a name="ln3243"> </a>
<a name="ln3244">	CSR_WRITE_1(sc, RL_EARLY_TX_THRESH, 16);</a>
<a name="ln3245"> </a>
<a name="ln3246">	/*</a>
<a name="ln3247">	 * Set the initial RX configuration.</a>
<a name="ln3248">	 */</a>
<a name="ln3249">	re_set_rxmode(sc);</a>
<a name="ln3250"> </a>
<a name="ln3251">	/* Configure interrupt moderation. */</a>
<a name="ln3252">	if (sc-&gt;rl_type == RL_8169) {</a>
<a name="ln3253">		/* Magic from vendor. */</a>
<a name="ln3254">		CSR_WRITE_2(sc, RL_INTRMOD, 0x5100);</a>
<a name="ln3255">	}</a>
<a name="ln3256"> </a>
<a name="ln3257">	/*</a>
<a name="ln3258">	 * Enable transmit and receive for RTL8168G and later controllers.</a>
<a name="ln3259">	 * RX/TX MACs should be enabled after RX/TX configuration.</a>
<a name="ln3260">	 */</a>
<a name="ln3261">	if ((sc-&gt;rl_flags &amp; RL_FLAG_8168G_PLUS) != 0)</a>
<a name="ln3262">		CSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB | RL_CMD_RX_ENB);</a>
<a name="ln3263"> </a>
<a name="ln3264">#ifdef DEVICE_POLLING</a>
<a name="ln3265">	/*</a>
<a name="ln3266">	 * Disable interrupts if we are polling.</a>
<a name="ln3267">	 */</a>
<a name="ln3268">	if (ifp-&gt;if_capenable &amp; IFCAP_POLLING)</a>
<a name="ln3269">		CSR_WRITE_2(sc, RL_IMR, 0);</a>
<a name="ln3270">	else	/* otherwise ... */</a>
<a name="ln3271">#endif</a>
<a name="ln3272"> </a>
<a name="ln3273">	/*</a>
<a name="ln3274">	 * Enable interrupts.</a>
<a name="ln3275">	 */</a>
<a name="ln3276">	if (sc-&gt;rl_testmode)</a>
<a name="ln3277">		CSR_WRITE_2(sc, RL_IMR, 0);</a>
<a name="ln3278">	else</a>
<a name="ln3279">		CSR_WRITE_2(sc, RL_IMR, RL_INTRS_CPLUS);</a>
<a name="ln3280">	CSR_WRITE_2(sc, RL_ISR, RL_INTRS_CPLUS);</a>
<a name="ln3281"> </a>
<a name="ln3282">	/* Set initial TX threshold */</a>
<a name="ln3283">	sc-&gt;rl_txthresh = RL_TX_THRESH_INIT;</a>
<a name="ln3284"> </a>
<a name="ln3285">	/* Start RX/TX process. */</a>
<a name="ln3286">	CSR_WRITE_4(sc, RL_MISSEDPKT, 0);</a>
<a name="ln3287"> </a>
<a name="ln3288">	/*</a>
<a name="ln3289">	 * Initialize the timer interrupt register so that</a>
<a name="ln3290">	 * a timer interrupt will be generated once the timer</a>
<a name="ln3291">	 * reaches a certain number of ticks. The timer is</a>
<a name="ln3292">	 * reloaded on each transmit.</a>
<a name="ln3293">	 */</a>
<a name="ln3294">#ifdef RE_TX_MODERATION</a>
<a name="ln3295">	/*</a>
<a name="ln3296">	 * Use timer interrupt register to moderate TX interrupt</a>
<a name="ln3297">	 * moderation, which dramatically improves TX frame rate.</a>
<a name="ln3298">	 */</a>
<a name="ln3299">	if (sc-&gt;rl_type == RL_8169)</a>
<a name="ln3300">		CSR_WRITE_4(sc, RL_TIMERINT_8169, 0x800);</a>
<a name="ln3301">	else</a>
<a name="ln3302">		CSR_WRITE_4(sc, RL_TIMERINT, 0x400);</a>
<a name="ln3303">#else</a>
<a name="ln3304">	/*</a>
<a name="ln3305">	 * Use timer interrupt register to moderate RX interrupt</a>
<a name="ln3306">	 * moderation.</a>
<a name="ln3307">	 */</a>
<a name="ln3308">	if ((sc-&gt;rl_flags &amp; (RL_FLAG_MSI | RL_FLAG_MSIX)) != 0 &amp;&amp;</a>
<a name="ln3309">	    intr_filter == 0) {</a>
<a name="ln3310">		if (sc-&gt;rl_type == RL_8169)</a>
<a name="ln3311">			CSR_WRITE_4(sc, RL_TIMERINT_8169,</a>
<a name="ln3312">			    RL_USECS(sc-&gt;rl_int_rx_mod));</a>
<a name="ln3313">	} else {</a>
<a name="ln3314">		if (sc-&gt;rl_type == RL_8169)</a>
<a name="ln3315">			CSR_WRITE_4(sc, RL_TIMERINT_8169, RL_USECS(0));</a>
<a name="ln3316">	}</a>
<a name="ln3317">#endif</a>
<a name="ln3318"> </a>
<a name="ln3319">	/*</a>
<a name="ln3320">	 * For 8169 gigE NICs, set the max allowed RX packet</a>
<a name="ln3321">	 * size so we can receive jumbo frames.</a>
<a name="ln3322">	 */</a>
<a name="ln3323">	if (sc-&gt;rl_type == RL_8169) {</a>
<a name="ln3324">		if ((sc-&gt;rl_flags &amp; RL_FLAG_JUMBOV2) != 0) {</a>
<a name="ln3325">			/*</a>
<a name="ln3326">			 * For controllers that use new jumbo frame scheme,</a>
<a name="ln3327">			 * set maximum size of jumbo frame depending on</a>
<a name="ln3328">			 * controller revisions.</a>
<a name="ln3329">			 */</a>
<a name="ln3330">			if (ifp-&gt;if_mtu &gt; RL_MTU)</a>
<a name="ln3331">				CSR_WRITE_2(sc, RL_MAXRXPKTLEN,</a>
<a name="ln3332">				    sc-&gt;rl_hwrev-&gt;rl_max_mtu +</a>
<a name="ln3333">				    ETHER_VLAN_ENCAP_LEN + ETHER_HDR_LEN +</a>
<a name="ln3334">				    ETHER_CRC_LEN);</a>
<a name="ln3335">			else</a>
<a name="ln3336">				CSR_WRITE_2(sc, RL_MAXRXPKTLEN,</a>
<a name="ln3337">				    RE_RX_DESC_BUFLEN);</a>
<a name="ln3338">		} else if ((sc-&gt;rl_flags &amp; RL_FLAG_PCIE) != 0 &amp;&amp;</a>
<a name="ln3339">		    sc-&gt;rl_hwrev-&gt;rl_max_mtu == RL_MTU) {</a>
<a name="ln3340">			/* RTL810x has no jumbo frame support. */</a>
<a name="ln3341">			CSR_WRITE_2(sc, RL_MAXRXPKTLEN, RE_RX_DESC_BUFLEN);</a>
<a name="ln3342">		} else</a>
<a name="ln3343">			CSR_WRITE_2(sc, RL_MAXRXPKTLEN, 16383);</a>
<a name="ln3344">	}</a>
<a name="ln3345"> </a>
<a name="ln3346">	if (sc-&gt;rl_testmode)</a>
<a name="ln3347">		return;</a>
<a name="ln3348"> </a>
<a name="ln3349">	CSR_WRITE_1(sc, sc-&gt;rl_cfg1, CSR_READ_1(sc, sc-&gt;rl_cfg1) |</a>
<a name="ln3350">	    RL_CFG1_DRVLOAD);</a>
<a name="ln3351"> </a>
<a name="ln3352">	ifp-&gt;if_drv_flags |= IFF_DRV_RUNNING;</a>
<a name="ln3353">	ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_OACTIVE;</a>
<a name="ln3354"> </a>
<a name="ln3355">	sc-&gt;rl_flags &amp;= ~RL_FLAG_LINK;</a>
<a name="ln3356">	mii_mediachg(mii);</a>
<a name="ln3357"> </a>
<a name="ln3358">	sc-&gt;rl_watchdog_timer = 0;</a>
<a name="ln3359">	callout_reset(&amp;sc-&gt;rl_stat_callout, hz, re_tick, sc);</a>
<a name="ln3360">}</a>
<a name="ln3361"> </a>
<a name="ln3362">/*</a>
<a name="ln3363"> * Set media options.</a>
<a name="ln3364"> */</a>
<a name="ln3365">static int</a>
<a name="ln3366">re_ifmedia_upd(struct ifnet *ifp)</a>
<a name="ln3367">{</a>
<a name="ln3368">	struct rl_softc		*sc;</a>
<a name="ln3369">	struct mii_data		*mii;</a>
<a name="ln3370">	int			error;</a>
<a name="ln3371"> </a>
<a name="ln3372">	sc = ifp-&gt;if_softc;</a>
<a name="ln3373">	mii = device_get_softc(sc-&gt;rl_miibus);</a>
<a name="ln3374">	RL_LOCK(sc);</a>
<a name="ln3375">	error = mii_mediachg(mii);</a>
<a name="ln3376">	RL_UNLOCK(sc);</a>
<a name="ln3377"> </a>
<a name="ln3378">	return (error);</a>
<a name="ln3379">}</a>
<a name="ln3380"> </a>
<a name="ln3381">/*</a>
<a name="ln3382"> * Report current media status.</a>
<a name="ln3383"> */</a>
<a name="ln3384">static void</a>
<a name="ln3385">re_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)</a>
<a name="ln3386">{</a>
<a name="ln3387">	struct rl_softc		*sc;</a>
<a name="ln3388">	struct mii_data		*mii;</a>
<a name="ln3389"> </a>
<a name="ln3390">	sc = ifp-&gt;if_softc;</a>
<a name="ln3391">	mii = device_get_softc(sc-&gt;rl_miibus);</a>
<a name="ln3392"> </a>
<a name="ln3393">	RL_LOCK(sc);</a>
<a name="ln3394">	mii_pollstat(mii);</a>
<a name="ln3395">	ifmr-&gt;ifm_active = mii-&gt;mii_media_active;</a>
<a name="ln3396">	ifmr-&gt;ifm_status = mii-&gt;mii_media_status;</a>
<a name="ln3397">	RL_UNLOCK(sc);</a>
<a name="ln3398">}</a>
<a name="ln3399"> </a>
<a name="ln3400">static int</a>
<a name="ln3401">re_ioctl(struct ifnet *ifp, u_long command, caddr_t data)</a>
<a name="ln3402">{</a>
<a name="ln3403">	struct rl_softc		*sc = ifp-&gt;if_softc;</a>
<a name="ln3404">	struct ifreq		*ifr = (struct ifreq *) data;</a>
<a name="ln3405">	struct mii_data		*mii;</a>
<a name="ln3406">	int			error = 0;</a>
<a name="ln3407"> </a>
<a name="ln3408">	switch (command) {</a>
<a name="ln3409">	case SIOCSIFMTU:</a>
<a name="ln3410">		if (ifr-&gt;ifr_mtu &lt; ETHERMIN ||</a>
<a name="ln3411">		    ifr-&gt;ifr_mtu &gt; sc-&gt;rl_hwrev-&gt;rl_max_mtu ||</a>
<a name="ln3412">		    ((sc-&gt;rl_flags &amp; RL_FLAG_FASTETHER) != 0 &amp;&amp;</a>
<a name="ln3413">		    ifr-&gt;ifr_mtu &gt; RL_MTU)) {</a>
<a name="ln3414">			error = EINVAL;</a>
<a name="ln3415">			break;</a>
<a name="ln3416">		}</a>
<a name="ln3417">		RL_LOCK(sc);</a>
<a name="ln3418">		if (ifp-&gt;if_mtu != ifr-&gt;ifr_mtu) {</a>
<a name="ln3419">			ifp-&gt;if_mtu = ifr-&gt;ifr_mtu;</a>
<a name="ln3420">			if ((sc-&gt;rl_flags &amp; RL_FLAG_JUMBOV2) != 0 &amp;&amp;</a>
<a name="ln3421">			    (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) != 0) {</a>
<a name="ln3422">				ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_RUNNING;</a>
<a name="ln3423">				re_init_locked(sc);</a>
<a name="ln3424">			}</a>
<a name="ln3425">			if (ifp-&gt;if_mtu &gt; RL_TSO_MTU &amp;&amp;</a>
<a name="ln3426">			    (ifp-&gt;if_capenable &amp; IFCAP_TSO4) != 0) {</a>
<a name="ln3427">				ifp-&gt;if_capenable &amp;= ~(IFCAP_TSO4 |</a>
<a name="ln3428">				    IFCAP_VLAN_HWTSO);</a>
<a name="ln3429">				ifp-&gt;if_hwassist &amp;= ~CSUM_TSO;</a>
<a name="ln3430">			}</a>
<a name="ln3431">			VLAN_CAPABILITIES(ifp);</a>
<a name="ln3432">		}</a>
<a name="ln3433">		RL_UNLOCK(sc);</a>
<a name="ln3434">		break;</a>
<a name="ln3435">	case SIOCSIFFLAGS:</a>
<a name="ln3436">		RL_LOCK(sc);</a>
<a name="ln3437">		if ((ifp-&gt;if_flags &amp; IFF_UP) != 0) {</a>
<a name="ln3438">			if ((ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) != 0) {</a>
<a name="ln3439">				if (((ifp-&gt;if_flags ^ sc-&gt;rl_if_flags)</a>
<a name="ln3440">				    &amp; (IFF_PROMISC | IFF_ALLMULTI)) != 0)</a>
<a name="ln3441">					re_set_rxmode(sc);</a>
<a name="ln3442">			} else</a>
<a name="ln3443">				re_init_locked(sc);</a>
<a name="ln3444">		} else {</a>
<a name="ln3445">			if ((ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) != 0)</a>
<a name="ln3446">				re_stop(sc);</a>
<a name="ln3447">		}</a>
<a name="ln3448">		sc-&gt;rl_if_flags = ifp-&gt;if_flags;</a>
<a name="ln3449">		RL_UNLOCK(sc);</a>
<a name="ln3450">		break;</a>
<a name="ln3451">	case SIOCADDMULTI:</a>
<a name="ln3452">	case SIOCDELMULTI:</a>
<a name="ln3453">		RL_LOCK(sc);</a>
<a name="ln3454">		if ((ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) != 0)</a>
<a name="ln3455">			re_set_rxmode(sc);</a>
<a name="ln3456">		RL_UNLOCK(sc);</a>
<a name="ln3457">		break;</a>
<a name="ln3458">	case SIOCGIFMEDIA:</a>
<a name="ln3459">	case SIOCSIFMEDIA:</a>
<a name="ln3460">		mii = device_get_softc(sc-&gt;rl_miibus);</a>
<a name="ln3461">		error = ifmedia_ioctl(ifp, ifr, &amp;mii-&gt;mii_media, command);</a>
<a name="ln3462">		break;</a>
<a name="ln3463">	case SIOCSIFCAP:</a>
<a name="ln3464">	    {</a>
<a name="ln3465">		int mask, reinit;</a>
<a name="ln3466"> </a>
<a name="ln3467">		mask = ifr-&gt;ifr_reqcap ^ ifp-&gt;if_capenable;</a>
<a name="ln3468">		reinit = 0;</a>
<a name="ln3469">#ifdef DEVICE_POLLING</a>
<a name="ln3470">		if (mask &amp; IFCAP_POLLING) {</a>
<a name="ln3471">			if (ifr-&gt;ifr_reqcap &amp; IFCAP_POLLING) {</a>
<a name="ln3472">				error = ether_poll_register(re_poll, ifp);</a>
<a name="ln3473">				if (error)</a>
<a name="ln3474">					return (error);</a>
<a name="ln3475">				RL_LOCK(sc);</a>
<a name="ln3476">				/* Disable interrupts */</a>
<a name="ln3477">				CSR_WRITE_2(sc, RL_IMR, 0x0000);</a>
<a name="ln3478">				ifp-&gt;if_capenable |= IFCAP_POLLING;</a>
<a name="ln3479">				RL_UNLOCK(sc);</a>
<a name="ln3480">			} else {</a>
<a name="ln3481">				error = ether_poll_deregister(ifp);</a>
<a name="ln3482">				/* Enable interrupts. */</a>
<a name="ln3483">				RL_LOCK(sc);</a>
<a name="ln3484">				CSR_WRITE_2(sc, RL_IMR, RL_INTRS_CPLUS);</a>
<a name="ln3485">				ifp-&gt;if_capenable &amp;= ~IFCAP_POLLING;</a>
<a name="ln3486">				RL_UNLOCK(sc);</a>
<a name="ln3487">			}</a>
<a name="ln3488">		}</a>
<a name="ln3489">#endif /* DEVICE_POLLING */</a>
<a name="ln3490">		RL_LOCK(sc);</a>
<a name="ln3491">		if ((mask &amp; IFCAP_TXCSUM) != 0 &amp;&amp;</a>
<a name="ln3492">		    (ifp-&gt;if_capabilities &amp; IFCAP_TXCSUM) != 0) {</a>
<a name="ln3493">			ifp-&gt;if_capenable ^= IFCAP_TXCSUM;</a>
<a name="ln3494">			if ((ifp-&gt;if_capenable &amp; IFCAP_TXCSUM) != 0)</a>
<a name="ln3495">				ifp-&gt;if_hwassist |= RE_CSUM_FEATURES;</a>
<a name="ln3496">			else</a>
<a name="ln3497">				ifp-&gt;if_hwassist &amp;= ~RE_CSUM_FEATURES;</a>
<a name="ln3498">			reinit = 1;</a>
<a name="ln3499">		}</a>
<a name="ln3500">		if ((mask &amp; IFCAP_RXCSUM) != 0 &amp;&amp;</a>
<a name="ln3501">		    (ifp-&gt;if_capabilities &amp; IFCAP_RXCSUM) != 0) {</a>
<a name="ln3502">			ifp-&gt;if_capenable ^= IFCAP_RXCSUM;</a>
<a name="ln3503">			reinit = 1;</a>
<a name="ln3504">		}</a>
<a name="ln3505">		if ((mask &amp; IFCAP_TSO4) != 0 &amp;&amp;</a>
<a name="ln3506">		    (ifp-&gt;if_capabilities &amp; IFCAP_TSO4) != 0) {</a>
<a name="ln3507">			ifp-&gt;if_capenable ^= IFCAP_TSO4;</a>
<a name="ln3508">			if ((IFCAP_TSO4 &amp; ifp-&gt;if_capenable) != 0)</a>
<a name="ln3509">				ifp-&gt;if_hwassist |= CSUM_TSO;</a>
<a name="ln3510">			else</a>
<a name="ln3511">				ifp-&gt;if_hwassist &amp;= ~CSUM_TSO;</a>
<a name="ln3512">			if (ifp-&gt;if_mtu &gt; RL_TSO_MTU &amp;&amp;</a>
<a name="ln3513">			    (ifp-&gt;if_capenable &amp; IFCAP_TSO4) != 0) {</a>
<a name="ln3514">				ifp-&gt;if_capenable &amp;= ~IFCAP_TSO4;</a>
<a name="ln3515">				ifp-&gt;if_hwassist &amp;= ~CSUM_TSO;</a>
<a name="ln3516">			}</a>
<a name="ln3517">		}</a>
<a name="ln3518">		if ((mask &amp; IFCAP_VLAN_HWTSO) != 0 &amp;&amp;</a>
<a name="ln3519">		    (ifp-&gt;if_capabilities &amp; IFCAP_VLAN_HWTSO) != 0)</a>
<a name="ln3520">			ifp-&gt;if_capenable ^= IFCAP_VLAN_HWTSO;</a>
<a name="ln3521">		if ((mask &amp; IFCAP_VLAN_HWTAGGING) != 0 &amp;&amp;</a>
<a name="ln3522">		    (ifp-&gt;if_capabilities &amp; IFCAP_VLAN_HWTAGGING) != 0) {</a>
<a name="ln3523">			ifp-&gt;if_capenable ^= IFCAP_VLAN_HWTAGGING;</a>
<a name="ln3524">			/* TSO over VLAN requires VLAN hardware tagging. */</a>
<a name="ln3525">			if ((ifp-&gt;if_capenable &amp; IFCAP_VLAN_HWTAGGING) == 0)</a>
<a name="ln3526">				ifp-&gt;if_capenable &amp;= ~IFCAP_VLAN_HWTSO;</a>
<a name="ln3527">			reinit = 1;</a>
<a name="ln3528">		}</a>
<a name="ln3529">		if ((sc-&gt;rl_flags &amp; RL_FLAG_JUMBOV2) != 0 &amp;&amp;</a>
<a name="ln3530">		    (mask &amp; (IFCAP_HWCSUM | IFCAP_TSO4 |</a>
<a name="ln3531">		    IFCAP_VLAN_HWTSO)) != 0)</a>
<a name="ln3532">				reinit = 1;</a>
<a name="ln3533">		if ((mask &amp; IFCAP_WOL) != 0 &amp;&amp;</a>
<a name="ln3534">		    (ifp-&gt;if_capabilities &amp; IFCAP_WOL) != 0) {</a>
<a name="ln3535">			if ((mask &amp; IFCAP_WOL_UCAST) != 0)</a>
<a name="ln3536">				ifp-&gt;if_capenable ^= IFCAP_WOL_UCAST;</a>
<a name="ln3537">			if ((mask &amp; IFCAP_WOL_MCAST) != 0)</a>
<a name="ln3538">				ifp-&gt;if_capenable ^= IFCAP_WOL_MCAST;</a>
<a name="ln3539">			if ((mask &amp; IFCAP_WOL_MAGIC) != 0)</a>
<a name="ln3540">				ifp-&gt;if_capenable ^= IFCAP_WOL_MAGIC;</a>
<a name="ln3541">		}</a>
<a name="ln3542">		if (reinit &amp;&amp; ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) {</a>
<a name="ln3543">			ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_RUNNING;</a>
<a name="ln3544">			re_init_locked(sc);</a>
<a name="ln3545">		}</a>
<a name="ln3546">		RL_UNLOCK(sc);</a>
<a name="ln3547">		VLAN_CAPABILITIES(ifp);</a>
<a name="ln3548">	    }</a>
<a name="ln3549">		break;</a>
<a name="ln3550">	default:</a>
<a name="ln3551">		error = ether_ioctl(ifp, command, data);</a>
<a name="ln3552">		break;</a>
<a name="ln3553">	}</a>
<a name="ln3554"> </a>
<a name="ln3555">	return (error);</a>
<a name="ln3556">}</a>
<a name="ln3557"> </a>
<a name="ln3558">static void</a>
<a name="ln3559">re_watchdog(struct rl_softc *sc)</a>
<a name="ln3560">{</a>
<a name="ln3561">	struct ifnet		*ifp;</a>
<a name="ln3562"> </a>
<a name="ln3563">	RL_LOCK_ASSERT(sc);</a>
<a name="ln3564"> </a>
<a name="ln3565">	if (sc-&gt;rl_watchdog_timer == 0 || --sc-&gt;rl_watchdog_timer != 0)</a>
<a name="ln3566">		return;</a>
<a name="ln3567"> </a>
<a name="ln3568">	ifp = sc-&gt;rl_ifp;</a>
<a name="ln3569">	re_txeof(sc);</a>
<a name="ln3570">	if (sc-&gt;rl_ldata.rl_tx_free == sc-&gt;rl_ldata.rl_tx_desc_cnt) {</a>
<a name="ln3571">		if_printf(ifp, &quot;watchdog timeout (missed Tx interrupts) &quot;</a>
<a name="ln3572">		    &quot;-- recovering\n&quot;);</a>
<a name="ln3573">		if (!IFQ_DRV_IS_EMPTY(&amp;ifp-&gt;if_snd))</a>
<a name="ln3574">			re_start_locked(ifp);</a>
<a name="ln3575">		return;</a>
<a name="ln3576">	}</a>
<a name="ln3577"> </a>
<a name="ln3578">	if_printf(ifp, &quot;watchdog timeout\n&quot;);</a>
<a name="ln3579">	if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln3580"> </a>
<a name="ln3581">	re_rxeof(sc, NULL);</a>
<a name="ln3582">	ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_RUNNING;</a>
<a name="ln3583">	re_init_locked(sc);</a>
<a name="ln3584">	if (!IFQ_DRV_IS_EMPTY(&amp;ifp-&gt;if_snd))</a>
<a name="ln3585">		re_start_locked(ifp);</a>
<a name="ln3586">}</a>
<a name="ln3587"> </a>
<a name="ln3588">/*</a>
<a name="ln3589"> * Stop the adapter and free any mbufs allocated to the</a>
<a name="ln3590"> * RX and TX lists.</a>
<a name="ln3591"> */</a>
<a name="ln3592">static void</a>
<a name="ln3593">re_stop(struct rl_softc *sc)</a>
<a name="ln3594">{</a>
<a name="ln3595">	int			i;</a>
<a name="ln3596">	struct ifnet		*ifp;</a>
<a name="ln3597">	struct rl_txdesc	*txd;</a>
<a name="ln3598">	struct rl_rxdesc	*rxd;</a>
<a name="ln3599"> </a>
<a name="ln3600">	RL_LOCK_ASSERT(sc);</a>
<a name="ln3601"> </a>
<a name="ln3602">	ifp = sc-&gt;rl_ifp;</a>
<a name="ln3603"> </a>
<a name="ln3604">	sc-&gt;rl_watchdog_timer = 0;</a>
<a name="ln3605">	callout_stop(&amp;sc-&gt;rl_stat_callout);</a>
<a name="ln3606">	ifp-&gt;if_drv_flags &amp;= ~(IFF_DRV_RUNNING | IFF_DRV_OACTIVE);</a>
<a name="ln3607"> </a>
<a name="ln3608">	/*</a>
<a name="ln3609">	 * Disable accepting frames to put RX MAC into idle state.</a>
<a name="ln3610">	 * Otherwise it's possible to get frames while stop command</a>
<a name="ln3611">	 * execution is in progress and controller can DMA the frame</a>
<a name="ln3612">	 * to already freed RX buffer during that period.</a>
<a name="ln3613">	 */</a>
<a name="ln3614">	CSR_WRITE_4(sc, RL_RXCFG, CSR_READ_4(sc, RL_RXCFG) &amp;</a>
<a name="ln3615">	    ~(RL_RXCFG_RX_ALLPHYS | RL_RXCFG_RX_INDIV | RL_RXCFG_RX_MULTI |</a>
<a name="ln3616">	    RL_RXCFG_RX_BROAD));</a>
<a name="ln3617"> </a>
<a name="ln3618">	if ((sc-&gt;rl_flags &amp; RL_FLAG_8168G_PLUS) != 0) {</a>
<a name="ln3619">		/* Enable RXDV gate. */</a>
<a name="ln3620">		CSR_WRITE_4(sc, RL_MISC, CSR_READ_4(sc, RL_MISC) |</a>
<a name="ln3621">		    0x00080000);</a>
<a name="ln3622">	}</a>
<a name="ln3623"> </a>
<a name="ln3624">	if ((sc-&gt;rl_flags &amp; RL_FLAG_WAIT_TXPOLL) != 0) {</a>
<a name="ln3625">		for (i = RL_TIMEOUT; i &gt; 0; i--) {</a>
<a name="ln3626">			if ((CSR_READ_1(sc, sc-&gt;rl_txstart) &amp;</a>
<a name="ln3627">			    RL_TXSTART_START) == 0)</a>
<a name="ln3628">				break;</a>
<a name="ln3629">			DELAY(20);</a>
<a name="ln3630">		}</a>
<a name="ln3631">		if (i == 0)</a>
<a name="ln3632">			device_printf(sc-&gt;rl_dev,</a>
<a name="ln3633">			    &quot;stopping TX poll timed out!\n&quot;);</a>
<a name="ln3634">		CSR_WRITE_1(sc, RL_COMMAND, 0x00);</a>
<a name="ln3635">	} else if ((sc-&gt;rl_flags &amp; RL_FLAG_CMDSTOP) != 0) {</a>
<a name="ln3636">		CSR_WRITE_1(sc, RL_COMMAND, RL_CMD_STOPREQ | RL_CMD_TX_ENB |</a>
<a name="ln3637">		    RL_CMD_RX_ENB);</a>
<a name="ln3638">		if ((sc-&gt;rl_flags &amp; RL_FLAG_CMDSTOP_WAIT_TXQ) != 0) {</a>
<a name="ln3639">			for (i = RL_TIMEOUT; i &gt; 0; i--) {</a>
<a name="ln3640">				if ((CSR_READ_4(sc, RL_TXCFG) &amp;</a>
<a name="ln3641">				    RL_TXCFG_QUEUE_EMPTY) != 0)</a>
<a name="ln3642">					break;</a>
<a name="ln3643">				DELAY(100);</a>
<a name="ln3644">			}</a>
<a name="ln3645">			if (i == 0)</a>
<a name="ln3646">				device_printf(sc-&gt;rl_dev,</a>
<a name="ln3647">				   &quot;stopping TXQ timed out!\n&quot;);</a>
<a name="ln3648">		}</a>
<a name="ln3649">	} else</a>
<a name="ln3650">		CSR_WRITE_1(sc, RL_COMMAND, 0x00);</a>
<a name="ln3651">	DELAY(1000);</a>
<a name="ln3652">	CSR_WRITE_2(sc, RL_IMR, 0x0000);</a>
<a name="ln3653">	CSR_WRITE_2(sc, RL_ISR, 0xFFFF);</a>
<a name="ln3654"> </a>
<a name="ln3655">	if (sc-&gt;rl_head != NULL) {</a>
<a name="ln3656">		m_freem(sc-&gt;rl_head);</a>
<a name="ln3657">		sc-&gt;rl_head = sc-&gt;rl_tail = NULL;</a>
<a name="ln3658">	}</a>
<a name="ln3659"> </a>
<a name="ln3660">	/* Free the TX list buffers. */</a>
<a name="ln3661">	for (i = 0; i &lt; sc-&gt;rl_ldata.rl_tx_desc_cnt; i++) {</a>
<a name="ln3662">		txd = &amp;sc-&gt;rl_ldata.rl_tx_desc[i];</a>
<a name="ln3663">		if (txd-&gt;tx_m != NULL) {</a>
<a name="ln3664">			bus_dmamap_sync(sc-&gt;rl_ldata.rl_tx_mtag,</a>
<a name="ln3665">			    txd-&gt;tx_dmamap, BUS_DMASYNC_POSTWRITE);</a>
<a name="ln3666">			bus_dmamap_unload(sc-&gt;rl_ldata.rl_tx_mtag,</a>
<a name="ln3667">			    txd-&gt;tx_dmamap);</a>
<a name="ln3668">			m_freem(txd-&gt;tx_m);</a>
<a name="ln3669">			txd-&gt;tx_m = NULL;</a>
<a name="ln3670">		}</a>
<a name="ln3671">	}</a>
<a name="ln3672"> </a>
<a name="ln3673">	/* Free the RX list buffers. */</a>
<a name="ln3674">	for (i = 0; i &lt; sc-&gt;rl_ldata.rl_rx_desc_cnt; i++) {</a>
<a name="ln3675">		rxd = &amp;sc-&gt;rl_ldata.rl_rx_desc[i];</a>
<a name="ln3676">		if (rxd-&gt;rx_m != NULL) {</a>
<a name="ln3677">			bus_dmamap_sync(sc-&gt;rl_ldata.rl_rx_mtag,</a>
<a name="ln3678">			    rxd-&gt;rx_dmamap, BUS_DMASYNC_POSTREAD);</a>
<a name="ln3679">			bus_dmamap_unload(sc-&gt;rl_ldata.rl_rx_mtag,</a>
<a name="ln3680">			    rxd-&gt;rx_dmamap);</a>
<a name="ln3681">			m_freem(rxd-&gt;rx_m);</a>
<a name="ln3682">			rxd-&gt;rx_m = NULL;</a>
<a name="ln3683">		}</a>
<a name="ln3684">	}</a>
<a name="ln3685"> </a>
<a name="ln3686">	if ((sc-&gt;rl_flags &amp; RL_FLAG_JUMBOV2) != 0) {</a>
<a name="ln3687">		for (i = 0; i &lt; sc-&gt;rl_ldata.rl_rx_desc_cnt; i++) {</a>
<a name="ln3688">			rxd = &amp;sc-&gt;rl_ldata.rl_jrx_desc[i];</a>
<a name="ln3689">			if (rxd-&gt;rx_m != NULL) {</a>
<a name="ln3690">				bus_dmamap_sync(sc-&gt;rl_ldata.rl_jrx_mtag,</a>
<a name="ln3691">				    rxd-&gt;rx_dmamap, BUS_DMASYNC_POSTREAD);</a>
<a name="ln3692">				bus_dmamap_unload(sc-&gt;rl_ldata.rl_jrx_mtag,</a>
<a name="ln3693">				    rxd-&gt;rx_dmamap);</a>
<a name="ln3694">				m_freem(rxd-&gt;rx_m);</a>
<a name="ln3695">				rxd-&gt;rx_m = NULL;</a>
<a name="ln3696">			}</a>
<a name="ln3697">		}</a>
<a name="ln3698">	}</a>
<a name="ln3699">}</a>
<a name="ln3700"> </a>
<a name="ln3701">/*</a>
<a name="ln3702"> * Device suspend routine.  Stop the interface and save some PCI</a>
<a name="ln3703"> * settings in case the BIOS doesn't restore them properly on</a>
<a name="ln3704"> * resume.</a>
<a name="ln3705"> */</a>
<a name="ln3706">static int</a>
<a name="ln3707">re_suspend(device_t dev)</a>
<a name="ln3708">{</a>
<a name="ln3709">	struct rl_softc		*sc;</a>
<a name="ln3710"> </a>
<a name="ln3711">	sc = device_get_softc(dev);</a>
<a name="ln3712"> </a>
<a name="ln3713">	RL_LOCK(sc);</a>
<a name="ln3714">	re_stop(sc);</a>
<a name="ln3715">	re_setwol(sc);</a>
<a name="ln3716">	sc-&gt;suspended = 1;</a>
<a name="ln3717">	RL_UNLOCK(sc);</a>
<a name="ln3718"> </a>
<a name="ln3719">	return (0);</a>
<a name="ln3720">}</a>
<a name="ln3721"> </a>
<a name="ln3722">/*</a>
<a name="ln3723"> * Device resume routine.  Restore some PCI settings in case the BIOS</a>
<a name="ln3724"> * doesn't, re-enable busmastering, and restart the interface if</a>
<a name="ln3725"> * appropriate.</a>
<a name="ln3726"> */</a>
<a name="ln3727">static int</a>
<a name="ln3728">re_resume(device_t dev)</a>
<a name="ln3729">{</a>
<a name="ln3730">	struct rl_softc		*sc;</a>
<a name="ln3731">	struct ifnet		*ifp;</a>
<a name="ln3732"> </a>
<a name="ln3733">	sc = device_get_softc(dev);</a>
<a name="ln3734"> </a>
<a name="ln3735">	RL_LOCK(sc);</a>
<a name="ln3736"> </a>
<a name="ln3737">	ifp = sc-&gt;rl_ifp;</a>
<a name="ln3738">	/* Take controller out of sleep mode. */</a>
<a name="ln3739">	if ((sc-&gt;rl_flags &amp; RL_FLAG_MACSLEEP) != 0) {</a>
<a name="ln3740">		if ((CSR_READ_1(sc, RL_MACDBG) &amp; 0x80) == 0x80)</a>
<a name="ln3741">			CSR_WRITE_1(sc, RL_GPIO,</a>
<a name="ln3742">			    CSR_READ_1(sc, RL_GPIO) | 0x01);</a>
<a name="ln3743">	}</a>
<a name="ln3744"> </a>
<a name="ln3745">	/*</a>
<a name="ln3746">	 * Clear WOL matching such that normal Rx filtering</a>
<a name="ln3747">	 * wouldn't interfere with WOL patterns.</a>
<a name="ln3748">	 */</a>
<a name="ln3749">	re_clrwol(sc);</a>
<a name="ln3750"> </a>
<a name="ln3751">	/* reinitialize interface if necessary */</a>
<a name="ln3752">	if (ifp-&gt;if_flags &amp; IFF_UP)</a>
<a name="ln3753">		re_init_locked(sc);</a>
<a name="ln3754"> </a>
<a name="ln3755">	sc-&gt;suspended = 0;</a>
<a name="ln3756">	RL_UNLOCK(sc);</a>
<a name="ln3757"> </a>
<a name="ln3758">	return (0);</a>
<a name="ln3759">}</a>
<a name="ln3760"> </a>
<a name="ln3761">/*</a>
<a name="ln3762"> * Stop all chip I/O so that the kernel's probe routines don't</a>
<a name="ln3763"> * get confused by errant DMAs when rebooting.</a>
<a name="ln3764"> */</a>
<a name="ln3765">static int</a>
<a name="ln3766">re_shutdown(device_t dev)</a>
<a name="ln3767">{</a>
<a name="ln3768">	struct rl_softc		*sc;</a>
<a name="ln3769"> </a>
<a name="ln3770">	sc = device_get_softc(dev);</a>
<a name="ln3771"> </a>
<a name="ln3772">	RL_LOCK(sc);</a>
<a name="ln3773">	re_stop(sc);</a>
<a name="ln3774">	/*</a>
<a name="ln3775">	 * Mark interface as down since otherwise we will panic if</a>
<a name="ln3776">	 * interrupt comes in later on, which can happen in some</a>
<a name="ln3777">	 * cases.</a>
<a name="ln3778">	 */</a>
<a name="ln3779">	sc-&gt;rl_ifp-&gt;if_flags &amp;= ~IFF_UP;</a>
<a name="ln3780">	re_setwol(sc);</a>
<a name="ln3781">	RL_UNLOCK(sc);</a>
<a name="ln3782"> </a>
<a name="ln3783">	return (0);</a>
<a name="ln3784">}</a>
<a name="ln3785"> </a>
<a name="ln3786">static void</a>
<a name="ln3787">re_set_linkspeed(struct rl_softc *sc)</a>
<a name="ln3788">{</a>
<a name="ln3789">	struct mii_softc *miisc;</a>
<a name="ln3790">	struct mii_data *mii;</a>
<a name="ln3791">	int aneg, i, phyno;</a>
<a name="ln3792"> </a>
<a name="ln3793">	RL_LOCK_ASSERT(sc);</a>
<a name="ln3794"> </a>
<a name="ln3795">	mii = device_get_softc(sc-&gt;rl_miibus);</a>
<a name="ln3796">	mii_pollstat(mii);</a>
<a name="ln3797">	aneg = 0;</a>
<a name="ln3798">	if ((mii-&gt;mii_media_status &amp; (IFM_ACTIVE | IFM_AVALID)) ==</a>
<a name="ln3799">	    (IFM_ACTIVE | IFM_AVALID)) {</a>
<a name="ln3800">		switch IFM_SUBTYPE(mii-&gt;mii_media_active) {</a>
<a name="ln3801">		case IFM_10_T:</a>
<a name="ln3802">		case IFM_100_TX:</a>
<a name="ln3803">			return;</a>
<a name="ln3804">		case IFM_1000_T:</a>
<a name="ln3805">			aneg++;</a>
<a name="ln3806">			break;</a>
<a name="ln3807">		default:</a>
<a name="ln3808">			break;</a>
<a name="ln3809">		}</a>
<a name="ln3810">	}</a>
<a name="ln3811">	miisc = LIST_FIRST(&amp;mii-&gt;mii_phys);</a>
<a name="ln3812">	phyno = miisc-&gt;mii_phy;</a>
<a name="ln3813">	LIST_FOREACH(miisc, &amp;mii-&gt;mii_phys, mii_list)</a>
<a name="ln3814">		PHY_RESET(miisc);</a>
<a name="ln3815">	re_miibus_writereg(sc-&gt;rl_dev, phyno, MII_100T2CR, 0);</a>
<a name="ln3816">	re_miibus_writereg(sc-&gt;rl_dev, phyno,</a>
<a name="ln3817">	    MII_ANAR, ANAR_TX_FD | ANAR_TX | ANAR_10_FD | ANAR_10 | ANAR_CSMA);</a>
<a name="ln3818">	re_miibus_writereg(sc-&gt;rl_dev, phyno,</a>
<a name="ln3819">	    MII_BMCR, BMCR_AUTOEN | BMCR_STARTNEG);</a>
<a name="ln3820">	DELAY(1000);</a>
<a name="ln3821">	if (aneg != 0) {</a>
<a name="ln3822">		/*</a>
<a name="ln3823">		 * Poll link state until re(4) get a 10/100Mbps link.</a>
<a name="ln3824">		 */</a>
<a name="ln3825">		for (i = 0; i &lt; MII_ANEGTICKS_GIGE; i++) {</a>
<a name="ln3826">			mii_pollstat(mii);</a>
<a name="ln3827">			if ((mii-&gt;mii_media_status &amp; (IFM_ACTIVE | IFM_AVALID))</a>
<a name="ln3828">			    == (IFM_ACTIVE | IFM_AVALID)) {</a>
<a name="ln3829">				switch (IFM_SUBTYPE(mii-&gt;mii_media_active)) {</a>
<a name="ln3830">				case IFM_10_T:</a>
<a name="ln3831">				case IFM_100_TX:</a>
<a name="ln3832">					return;</a>
<a name="ln3833">				default:</a>
<a name="ln3834">					break;</a>
<a name="ln3835">				}</a>
<a name="ln3836">			}</a>
<a name="ln3837">			RL_UNLOCK(sc);</a>
<a name="ln3838">			pause(&quot;relnk&quot;, hz);</a>
<a name="ln3839">			RL_LOCK(sc);</a>
<a name="ln3840">		}</a>
<a name="ln3841">		if (i == MII_ANEGTICKS_GIGE)</a>
<a name="ln3842">			device_printf(sc-&gt;rl_dev,</a>
<a name="ln3843">			    &quot;establishing a link failed, WOL may not work!&quot;);</a>
<a name="ln3844">	}</a>
<a name="ln3845">	/*</a>
<a name="ln3846">	 * No link, force MAC to have 100Mbps, full-duplex link.</a>
<a name="ln3847">	 * MAC does not require reprogramming on resolved speed/duplex,</a>
<a name="ln3848">	 * so this is just for completeness.</a>
<a name="ln3849">	 */</a>
<a name="ln3850">	mii-&gt;mii_media_status = IFM_AVALID | IFM_ACTIVE;</a>
<a name="ln3851">	mii-&gt;mii_media_active = IFM_ETHER | IFM_100_TX | IFM_FDX;</a>
<a name="ln3852">}</a>
<a name="ln3853"> </a>
<a name="ln3854">static void</a>
<a name="ln3855">re_setwol(struct rl_softc *sc)</a>
<a name="ln3856">{</a>
<a name="ln3857">	struct ifnet		*ifp;</a>
<a name="ln3858">	int			pmc;</a>
<a name="ln3859">	uint16_t		pmstat;</a>
<a name="ln3860">	uint8_t			v;</a>
<a name="ln3861"> </a>
<a name="ln3862">	RL_LOCK_ASSERT(sc);</a>
<a name="ln3863"> </a>
<a name="ln3864">	if (pci_find_cap(sc-&gt;rl_dev, PCIY_PMG, &amp;pmc) != 0)</a>
<a name="ln3865">		return;</a>
<a name="ln3866"> </a>
<a name="ln3867">	ifp = sc-&gt;rl_ifp;</a>
<a name="ln3868">	/* Put controller into sleep mode. */</a>
<a name="ln3869">	if ((sc-&gt;rl_flags &amp; RL_FLAG_MACSLEEP) != 0) {</a>
<a name="ln3870">		if ((CSR_READ_1(sc, RL_MACDBG) &amp; 0x80) == 0x80)</a>
<a name="ln3871">			CSR_WRITE_1(sc, RL_GPIO,</a>
<a name="ln3872">			    CSR_READ_1(sc, RL_GPIO) &amp; ~0x01);</a>
<a name="ln3873">	}</a>
<a name="ln3874">	if ((ifp-&gt;if_capenable &amp; IFCAP_WOL) != 0) {</a>
<a name="ln3875">		if ((sc-&gt;rl_flags &amp; RL_FLAG_8168G_PLUS) != 0) {</a>
<a name="ln3876">			/* Disable RXDV gate. */</a>
<a name="ln3877">			CSR_WRITE_4(sc, RL_MISC, CSR_READ_4(sc, RL_MISC) &amp;</a>
<a name="ln3878">			    ~0x00080000);</a>
<a name="ln3879">		}</a>
<a name="ln3880">		re_set_rxmode(sc);</a>
<a name="ln3881">		if ((sc-&gt;rl_flags &amp; RL_FLAG_WOL_MANLINK) != 0)</a>
<a name="ln3882">			re_set_linkspeed(sc);</a>
<a name="ln3883">		if ((sc-&gt;rl_flags &amp; RL_FLAG_WOLRXENB) != 0)</a>
<a name="ln3884">			CSR_WRITE_1(sc, RL_COMMAND, RL_CMD_RX_ENB);</a>
<a name="ln3885">	}</a>
<a name="ln3886">	/* Enable config register write. */</a>
<a name="ln3887">	CSR_WRITE_1(sc, RL_EECMD, RL_EE_MODE);</a>
<a name="ln3888"> </a>
<a name="ln3889">	/* Enable PME. */</a>
<a name="ln3890">	v = CSR_READ_1(sc, sc-&gt;rl_cfg1);</a>
<a name="ln3891">	v &amp;= ~RL_CFG1_PME;</a>
<a name="ln3892">	if ((ifp-&gt;if_capenable &amp; IFCAP_WOL) != 0)</a>
<a name="ln3893">		v |= RL_CFG1_PME;</a>
<a name="ln3894">	CSR_WRITE_1(sc, sc-&gt;rl_cfg1, v);</a>
<a name="ln3895"> </a>
<a name="ln3896">	v = CSR_READ_1(sc, sc-&gt;rl_cfg3);</a>
<a name="ln3897">	v &amp;= ~(RL_CFG3_WOL_LINK | RL_CFG3_WOL_MAGIC);</a>
<a name="ln3898">	if ((ifp-&gt;if_capenable &amp; IFCAP_WOL_MAGIC) != 0)</a>
<a name="ln3899">		v |= RL_CFG3_WOL_MAGIC;</a>
<a name="ln3900">	CSR_WRITE_1(sc, sc-&gt;rl_cfg3, v);</a>
<a name="ln3901"> </a>
<a name="ln3902">	v = CSR_READ_1(sc, sc-&gt;rl_cfg5);</a>
<a name="ln3903">	v &amp;= ~(RL_CFG5_WOL_BCAST | RL_CFG5_WOL_MCAST | RL_CFG5_WOL_UCAST |</a>
<a name="ln3904">	    RL_CFG5_WOL_LANWAKE);</a>
<a name="ln3905">	if ((ifp-&gt;if_capenable &amp; IFCAP_WOL_UCAST) != 0)</a>
<a name="ln3906">		v |= RL_CFG5_WOL_UCAST;</a>
<a name="ln3907">	if ((ifp-&gt;if_capenable &amp; IFCAP_WOL_MCAST) != 0)</a>
<a name="ln3908">		v |= RL_CFG5_WOL_MCAST | RL_CFG5_WOL_BCAST;</a>
<a name="ln3909">	if ((ifp-&gt;if_capenable &amp; IFCAP_WOL) != 0)</a>
<a name="ln3910">		v |= RL_CFG5_WOL_LANWAKE;</a>
<a name="ln3911">	CSR_WRITE_1(sc, sc-&gt;rl_cfg5, v);</a>
<a name="ln3912"> </a>
<a name="ln3913">	/* Config register write done. */</a>
<a name="ln3914">	CSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_OFF);</a>
<a name="ln3915"> </a>
<a name="ln3916">	if ((ifp-&gt;if_capenable &amp; IFCAP_WOL) == 0 &amp;&amp;</a>
<a name="ln3917">	    (sc-&gt;rl_flags &amp; RL_FLAG_PHYWAKE_PM) != 0)</a>
<a name="ln3918">		CSR_WRITE_1(sc, RL_PMCH, CSR_READ_1(sc, RL_PMCH) &amp; ~0x80);</a>
<a name="ln3919">	/*</a>
<a name="ln3920">	 * It seems that hardware resets its link speed to 100Mbps in</a>
<a name="ln3921">	 * power down mode so switching to 100Mbps in driver is not</a>
<a name="ln3922">	 * needed.</a>
<a name="ln3923">	 */</a>
<a name="ln3924"> </a>
<a name="ln3925">	/* Request PME if WOL is requested. */</a>
<a name="ln3926">	pmstat = pci_read_config(sc-&gt;rl_dev, pmc + PCIR_POWER_STATUS, 2);</a>
<a name="ln3927">	pmstat &amp;= ~(PCIM_PSTAT_PME | PCIM_PSTAT_PMEENABLE);</a>
<a name="ln3928">	if ((ifp-&gt;if_capenable &amp; IFCAP_WOL) != 0)</a>
<a name="ln3929">		pmstat |= PCIM_PSTAT_PME | PCIM_PSTAT_PMEENABLE;</a>
<a name="ln3930">	pci_write_config(sc-&gt;rl_dev, pmc + PCIR_POWER_STATUS, pmstat, 2);</a>
<a name="ln3931">}</a>
<a name="ln3932"> </a>
<a name="ln3933">static void</a>
<a name="ln3934">re_clrwol(struct rl_softc *sc)</a>
<a name="ln3935">{</a>
<a name="ln3936">	int			pmc;</a>
<a name="ln3937">	uint8_t			v;</a>
<a name="ln3938"> </a>
<a name="ln3939">	RL_LOCK_ASSERT(sc);</a>
<a name="ln3940"> </a>
<a name="ln3941">	if (pci_find_cap(sc-&gt;rl_dev, PCIY_PMG, &amp;pmc) != 0)</a>
<a name="ln3942">		return;</a>
<a name="ln3943"> </a>
<a name="ln3944">	/* Enable config register write. */</a>
<a name="ln3945">	CSR_WRITE_1(sc, RL_EECMD, RL_EE_MODE);</a>
<a name="ln3946"> </a>
<a name="ln3947">	v = CSR_READ_1(sc, sc-&gt;rl_cfg3);</a>
<a name="ln3948">	v &amp;= ~(RL_CFG3_WOL_LINK | RL_CFG3_WOL_MAGIC);</a>
<a name="ln3949">	CSR_WRITE_1(sc, sc-&gt;rl_cfg3, v);</a>
<a name="ln3950"> </a>
<a name="ln3951">	/* Config register write done. */</a>
<a name="ln3952">	CSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_OFF);</a>
<a name="ln3953"> </a>
<a name="ln3954">	v = CSR_READ_1(sc, sc-&gt;rl_cfg5);</a>
<a name="ln3955">	v &amp;= ~(RL_CFG5_WOL_BCAST | RL_CFG5_WOL_MCAST | RL_CFG5_WOL_UCAST);</a>
<a name="ln3956">	v &amp;= ~RL_CFG5_WOL_LANWAKE;</a>
<a name="ln3957">	CSR_WRITE_1(sc, sc-&gt;rl_cfg5, v);</a>
<a name="ln3958">}</a>
<a name="ln3959"> </a>
<a name="ln3960">static void</a>
<a name="ln3961">re_add_sysctls(struct rl_softc *sc)</a>
<a name="ln3962">{</a>
<a name="ln3963">	struct sysctl_ctx_list	*ctx;</a>
<a name="ln3964">	struct sysctl_oid_list	*children;</a>
<a name="ln3965">	int			error;</a>
<a name="ln3966"> </a>
<a name="ln3967">	ctx = device_get_sysctl_ctx(sc-&gt;rl_dev);</a>
<a name="ln3968">	children = SYSCTL_CHILDREN(device_get_sysctl_tree(sc-&gt;rl_dev));</a>
<a name="ln3969"> </a>
<a name="ln3970">	SYSCTL_ADD_PROC(ctx, children, OID_AUTO, &quot;stats&quot;,</a>
<a name="ln3971">	    CTLTYPE_INT | CTLFLAG_RW, sc, 0, re_sysctl_stats, &quot;I&quot;,</a>
<a name="ln3972">	    &quot;Statistics Information&quot;);</a>
<a name="ln3973">	if ((sc-&gt;rl_flags &amp; (RL_FLAG_MSI | RL_FLAG_MSIX)) == 0)</a>
<a name="ln3974">		return;</a>
<a name="ln3975"> </a>
<a name="ln3976">	SYSCTL_ADD_PROC(ctx, children, OID_AUTO, &quot;int_rx_mod&quot;,</a>
<a name="ln3977">	    CTLTYPE_INT | CTLFLAG_RW, &amp;sc-&gt;rl_int_rx_mod, 0,</a>
<a name="ln3978">	    sysctl_hw_re_int_mod, &quot;I&quot;, &quot;re RX interrupt moderation&quot;);</a>
<a name="ln3979">	/* Pull in device tunables. */</a>
<a name="ln3980">	sc-&gt;rl_int_rx_mod = RL_TIMER_DEFAULT;</a>
<a name="ln3981">	error = resource_int_value(device_get_name(sc-&gt;rl_dev),</a>
<a name="ln3982">	    device_get_unit(sc-&gt;rl_dev), &quot;int_rx_mod&quot;, &amp;sc-&gt;rl_int_rx_mod);</a>
<a name="ln3983">	if (error == 0) {</a>
<a name="ln3984">		if (sc-&gt;rl_int_rx_mod &lt; RL_TIMER_MIN ||</a>
<a name="ln3985">		    sc-&gt;rl_int_rx_mod &gt; RL_TIMER_MAX) {</a>
<a name="ln3986">			device_printf(sc-&gt;rl_dev, &quot;int_rx_mod value out of &quot;</a>
<a name="ln3987">			    &quot;range; using default: %d\n&quot;,</a>
<a name="ln3988">			    RL_TIMER_DEFAULT);</a>
<a name="ln3989">			sc-&gt;rl_int_rx_mod = RL_TIMER_DEFAULT;</a>
<a name="ln3990">		}</a>
<a name="ln3991">	}</a>
<a name="ln3992">}</a>
<a name="ln3993"> </a>
<a name="ln3994">static int</a>
<a name="ln3995">re_sysctl_stats(SYSCTL_HANDLER_ARGS)</a>
<a name="ln3996">{</a>
<a name="ln3997">	struct rl_softc		*sc;</a>
<a name="ln3998">	struct rl_stats		*stats;</a>
<a name="ln3999">	int			error, i, result;</a>
<a name="ln4000"> </a>
<a name="ln4001">	result = -1;</a>
<a name="ln4002">	error = sysctl_handle_int(oidp, &amp;result, 0, req);</a>
<a name="ln4003">	if (error || req-&gt;newptr == NULL)</a>
<a name="ln4004">		return (error);</a>
<a name="ln4005"> </a>
<a name="ln4006">	if (result == 1) {</a>
<a name="ln4007">		sc = (struct rl_softc *)arg1;</a>
<a name="ln4008">		RL_LOCK(sc);</a>
<a name="ln4009">		if ((sc-&gt;rl_ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) == 0) {</a>
<a name="ln4010">			RL_UNLOCK(sc);</a>
<a name="ln4011">			goto done;</a>
<a name="ln4012">		}</a>
<a name="ln4013">		bus_dmamap_sync(sc-&gt;rl_ldata.rl_stag,</a>
<a name="ln4014">		    sc-&gt;rl_ldata.rl_smap, BUS_DMASYNC_PREREAD);</a>
<a name="ln4015">		CSR_WRITE_4(sc, RL_DUMPSTATS_HI,</a>
<a name="ln4016">		    RL_ADDR_HI(sc-&gt;rl_ldata.rl_stats_addr));</a>
<a name="ln4017">		CSR_WRITE_4(sc, RL_DUMPSTATS_LO,</a>
<a name="ln4018">		    RL_ADDR_LO(sc-&gt;rl_ldata.rl_stats_addr));</a>
<a name="ln4019">		CSR_WRITE_4(sc, RL_DUMPSTATS_LO,</a>
<a name="ln4020">		    RL_ADDR_LO(sc-&gt;rl_ldata.rl_stats_addr |</a>
<a name="ln4021">		    RL_DUMPSTATS_START));</a>
<a name="ln4022">		for (i = RL_TIMEOUT; i &gt; 0; i--) {</a>
<a name="ln4023">			if ((CSR_READ_4(sc, RL_DUMPSTATS_LO) &amp;</a>
<a name="ln4024">			    RL_DUMPSTATS_START) == 0)</a>
<a name="ln4025">				break;</a>
<a name="ln4026">			DELAY(1000);</a>
<a name="ln4027">		}</a>
<a name="ln4028">		bus_dmamap_sync(sc-&gt;rl_ldata.rl_stag,</a>
<a name="ln4029">		    sc-&gt;rl_ldata.rl_smap, BUS_DMASYNC_POSTREAD);</a>
<a name="ln4030">		RL_UNLOCK(sc);</a>
<a name="ln4031">		if (i == 0) {</a>
<a name="ln4032">			device_printf(sc-&gt;rl_dev,</a>
<a name="ln4033">			    &quot;DUMP statistics request timed out\n&quot;);</a>
<a name="ln4034">			return (ETIMEDOUT);</a>
<a name="ln4035">		}</a>
<a name="ln4036">done:</a>
<a name="ln4037">		stats = sc-&gt;rl_ldata.rl_stats;</a>
<a name="ln4038">		printf(&quot;%s statistics:\n&quot;, device_get_nameunit(sc-&gt;rl_dev));</a>
<a name="ln4039">		printf(&quot;Tx frames : %ju\n&quot;,</a>
<a name="ln4040">		    (uintmax_t)le64toh(stats-&gt;rl_tx_pkts));</a>
<a name="ln4041">		printf(&quot;Rx frames : %ju\n&quot;,</a>
<a name="ln4042">		    (uintmax_t)le64toh(stats-&gt;rl_rx_pkts));</a>
<a name="ln4043">		printf(&quot;Tx errors : %ju\n&quot;,</a>
<a name="ln4044">		    (uintmax_t)le64toh(stats-&gt;rl_tx_errs));</a>
<a name="ln4045">		printf(&quot;Rx errors : %u\n&quot;,</a>
<a name="ln4046">		    le32toh(stats-&gt;rl_rx_errs));</a>
<a name="ln4047">		printf(&quot;Rx missed frames : %u\n&quot;,</a>
<a name="ln4048">		    (uint32_t)le16toh(stats-&gt;rl_missed_pkts));</a>
<a name="ln4049">		printf(&quot;Rx frame alignment errs : %u\n&quot;,</a>
<a name="ln4050">		    (uint32_t)le16toh(stats-&gt;rl_rx_framealign_errs));</a>
<a name="ln4051">		printf(&quot;Tx single collisions : %u\n&quot;,</a>
<a name="ln4052">		    le32toh(stats-&gt;rl_tx_onecoll));</a>
<a name="ln4053">		printf(&quot;Tx multiple collisions : %u\n&quot;,</a>
<a name="ln4054">		    le32toh(stats-&gt;rl_tx_multicolls));</a>
<a name="ln4055">		printf(&quot;Rx unicast frames : %ju\n&quot;,</a>
<a name="ln4056">		    (uintmax_t)le64toh(stats-&gt;rl_rx_ucasts));</a>
<a name="ln4057">		printf(&quot;Rx broadcast frames : %ju\n&quot;,</a>
<a name="ln4058">		    (uintmax_t)le64toh(stats-&gt;rl_rx_bcasts));</a>
<a name="ln4059">		printf(&quot;Rx multicast frames : %u\n&quot;,</a>
<a name="ln4060">		    le32toh(stats-&gt;rl_rx_mcasts));</a>
<a name="ln4061">		printf(&quot;Tx aborts : %u\n&quot;,</a>
<a name="ln4062">		    (uint32_t)le16toh(stats-&gt;rl_tx_aborts));</a>
<a name="ln4063">		printf(&quot;Tx underruns : %u\n&quot;,</a>
<a name="ln4064">		    (uint32_t)le16toh(stats-&gt;rl_rx_underruns));</a>
<a name="ln4065">	}</a>
<a name="ln4066"> </a>
<a name="ln4067">	return (error);</a>
<a name="ln4068">}</a>
<a name="ln4069"> </a>
<a name="ln4070">static int</a>
<a name="ln4071">sysctl_int_range(SYSCTL_HANDLER_ARGS, int low, int high)</a>
<a name="ln4072">{</a>
<a name="ln4073">	int error, value;</a>
<a name="ln4074"> </a>
<a name="ln4075">	if (arg1 == NULL)</a>
<a name="ln4076">		return (EINVAL);</a>
<a name="ln4077">	value = *(int *)arg1;</a>
<a name="ln4078">	error = sysctl_handle_int(oidp, &amp;value, 0, req);</a>
<a name="ln4079">	if (error || req-&gt;newptr == NULL)</a>
<a name="ln4080">		return (error);</a>
<a name="ln4081">	if (value &lt; low || value &gt; high)</a>
<a name="ln4082">		return (EINVAL);</a>
<a name="ln4083">	*(int *)arg1 = value;</a>
<a name="ln4084"> </a>
<a name="ln4085">	return (0);</a>
<a name="ln4086">}</a>
<a name="ln4087"> </a>
<a name="ln4088">static int</a>
<a name="ln4089">sysctl_hw_re_int_mod(SYSCTL_HANDLER_ARGS)</a>
<a name="ln4090">{</a>
<a name="ln4091"> </a>
<a name="ln4092">	return (sysctl_int_range(oidp, arg1, arg2, req, RL_TIMER_MIN,</a>
<a name="ln4093">	    RL_TIMER_MAX));</a>
<a name="ln4094">}</a>
<a name="ln4095"> </a>
<a name="ln4096">#ifdef NETDUMP</a>
<a name="ln4097">static void</a>
<a name="ln4098">re_netdump_init(struct ifnet *ifp, int *nrxr, int *ncl, int *clsize)</a>
<a name="ln4099">{</a>
<a name="ln4100">	struct rl_softc *sc;</a>
<a name="ln4101"> </a>
<a name="ln4102">	sc = if_getsoftc(ifp);</a>
<a name="ln4103">	RL_LOCK(sc);</a>
<a name="ln4104">	*nrxr = sc-&gt;rl_ldata.rl_rx_desc_cnt;</a>
<a name="ln4105">	*ncl = NETDUMP_MAX_IN_FLIGHT;</a>
<a name="ln4106">	*clsize = (ifp-&gt;if_mtu &gt; RL_MTU &amp;&amp;</a>
<a name="ln4107">	    (sc-&gt;rl_flags &amp; RL_FLAG_JUMBOV2) != 0) ? MJUM9BYTES : MCLBYTES;</a>
<a name="ln4108">	RL_UNLOCK(sc);</a>
<a name="ln4109">}</a>
<a name="ln4110"> </a>
<a name="ln4111">static void</a>
<a name="ln4112">re_netdump_event(struct ifnet *ifp __unused, enum netdump_ev event __unused)</a>
<a name="ln4113">{</a>
<a name="ln4114">}</a>
<a name="ln4115"> </a>
<a name="ln4116">static int</a>
<a name="ln4117">re_netdump_transmit(struct ifnet *ifp, struct mbuf *m)</a>
<a name="ln4118">{</a>
<a name="ln4119">	struct rl_softc *sc;</a>
<a name="ln4120">	int error;</a>
<a name="ln4121"> </a>
<a name="ln4122">	sc = if_getsoftc(ifp);</a>
<a name="ln4123">	if ((if_getdrvflags(ifp) &amp; (IFF_DRV_RUNNING | IFF_DRV_OACTIVE)) !=</a>
<a name="ln4124">	    IFF_DRV_RUNNING || (sc-&gt;rl_flags &amp; RL_FLAG_LINK) == 0)</a>
<a name="ln4125">		return (EBUSY);</a>
<a name="ln4126"> </a>
<a name="ln4127">	error = re_encap(sc, &amp;m);</a>
<a name="ln4128">	if (error == 0)</a>
<a name="ln4129">		re_start_tx(sc);</a>
<a name="ln4130">	return (error);</a>
<a name="ln4131">}</a>
<a name="ln4132"> </a>
<a name="ln4133">static int</a>
<a name="ln4134">re_netdump_poll(struct ifnet *ifp, int count)</a>
<a name="ln4135">{</a>
<a name="ln4136">	struct rl_softc *sc;</a>
<a name="ln4137">	int error;</a>
<a name="ln4138"> </a>
<a name="ln4139">	sc = if_getsoftc(ifp);</a>
<a name="ln4140">	if ((if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING) == 0 ||</a>
<a name="ln4141">	    (sc-&gt;rl_flags &amp; RL_FLAG_LINK) == 0)</a>
<a name="ln4142">		return (EBUSY);</a>
<a name="ln4143"> </a>
<a name="ln4144">	re_txeof(sc);</a>
<a name="ln4145">	error = re_rxeof(sc, NULL);</a>
<a name="ln4146">	if (error != 0 &amp;&amp; error != EAGAIN)</a>
<a name="ln4147">		return (error);</a>
<a name="ln4148">	return (0);</a>
<a name="ln4149">}</a>
<a name="ln4150">#endif /* NETDUMP */</a>

</code></pre>
<div class="balloon" rel="1801"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'ifp' pointer was utilized before it was verified against nullptr. Check lines: 1801, 1817.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
