
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>STXTTranslator.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2002-2009, Haiku, Inc. All rights reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Michael Wilber</a>
<a name="ln7"> *		Axel DÃ¶rfler, axeld@pinc-software.de</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10"> </a>
<a name="ln11">#include &quot;STXTTranslator.h&quot;</a>
<a name="ln12">#include &quot;STXTView.h&quot;</a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;Catalog.h&gt;</a>
<a name="ln15">#include &lt;CharacterSet.h&gt;</a>
<a name="ln16">#include &lt;CharacterSetRoster.h&gt;</a>
<a name="ln17">#include &lt;MimeType.h&gt;</a>
<a name="ln18">#include &lt;String.h&gt;</a>
<a name="ln19">#include &lt;TextEncoding.h&gt;</a>
<a name="ln20">#include &lt;UTF8.h&gt;</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;algorithm&gt;</a>
<a name="ln23">#include &lt;new&gt;</a>
<a name="ln24">#include &lt;string.h&gt;</a>
<a name="ln25">#include &lt;stdio.h&gt;</a>
<a name="ln26">#include &lt;stdint.h&gt;</a>
<a name="ln27"> </a>
<a name="ln28"> </a>
<a name="ln29">using namespace BPrivate;</a>
<a name="ln30">using namespace std;</a>
<a name="ln31"> </a>
<a name="ln32">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln33">#define B_TRANSLATION_CONTEXT &quot;STXTTranslator&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#define READ_BUFFER_SIZE 32768</a>
<a name="ln36">#define DATA_BUFFER_SIZE 2048</a>
<a name="ln37"> </a>
<a name="ln38">// The input formats that this translator supports.</a>
<a name="ln39">static const translation_format sInputFormats[] = {</a>
<a name="ln40">	{</a>
<a name="ln41">		B_TRANSLATOR_TEXT,</a>
<a name="ln42">		B_TRANSLATOR_TEXT,</a>
<a name="ln43">		TEXT_IN_QUALITY,</a>
<a name="ln44">		TEXT_IN_CAPABILITY,</a>
<a name="ln45">		&quot;text/plain&quot;,</a>
<a name="ln46">		&quot;Plain text file&quot;</a>
<a name="ln47">	},</a>
<a name="ln48">	{</a>
<a name="ln49">		B_STYLED_TEXT_FORMAT,</a>
<a name="ln50">		B_TRANSLATOR_TEXT,</a>
<a name="ln51">		STXT_IN_QUALITY,</a>
<a name="ln52">		STXT_IN_CAPABILITY,</a>
<a name="ln53">		&quot;text/x-vnd.Be-stxt&quot;,</a>
<a name="ln54">		&quot;Be styled text file&quot;</a>
<a name="ln55">	}</a>
<a name="ln56">};</a>
<a name="ln57"> </a>
<a name="ln58">// The output formats that this translator supports.</a>
<a name="ln59">static const translation_format sOutputFormats[] = {</a>
<a name="ln60">	{</a>
<a name="ln61">		B_TRANSLATOR_TEXT,</a>
<a name="ln62">		B_TRANSLATOR_TEXT,</a>
<a name="ln63">		TEXT_OUT_QUALITY,</a>
<a name="ln64">		TEXT_OUT_CAPABILITY,</a>
<a name="ln65">		&quot;text/plain&quot;,</a>
<a name="ln66">		&quot;Plain text file&quot;</a>
<a name="ln67">	},</a>
<a name="ln68">	{</a>
<a name="ln69">		B_STYLED_TEXT_FORMAT,</a>
<a name="ln70">		B_TRANSLATOR_TEXT,</a>
<a name="ln71">		STXT_OUT_QUALITY,</a>
<a name="ln72">		STXT_OUT_CAPABILITY,</a>
<a name="ln73">		&quot;text/x-vnd.Be-stxt&quot;,</a>
<a name="ln74">		&quot;Be styled text file&quot;</a>
<a name="ln75">	}</a>
<a name="ln76">};</a>
<a name="ln77"> </a>
<a name="ln78">// Default settings for the Translator</a>
<a name="ln79">static const TranSetting sDefaultSettings[] = {</a>
<a name="ln80">	{B_TRANSLATOR_EXT_HEADER_ONLY, TRAN_SETTING_BOOL, false},</a>
<a name="ln81">	{B_TRANSLATOR_EXT_DATA_ONLY, TRAN_SETTING_BOOL, false}</a>
<a name="ln82">};</a>
<a name="ln83"> </a>
<a name="ln84">const uint32 kNumInputFormats = sizeof(sInputFormats) / sizeof(translation_format);</a>
<a name="ln85">const uint32 kNumOutputFormats = sizeof(sOutputFormats) / sizeof(translation_format);</a>
<a name="ln86">const uint32 kNumDefaultSettings = sizeof(sDefaultSettings) / sizeof(TranSetting);</a>
<a name="ln87"> </a>
<a name="ln88">// ---------------------------------------------------------------</a>
<a name="ln89">// make_nth_translator</a>
<a name="ln90">//</a>
<a name="ln91">// Creates a STXTTranslator object to be used by BTranslatorRoster</a>
<a name="ln92">//</a>
<a name="ln93">// Preconditions:</a>
<a name="ln94">//</a>
<a name="ln95">// Parameters: n,		The translator to return. Since</a>
<a name="ln96">//						STXTTranslator only publishes one</a>
<a name="ln97">//						translator, it only returns a</a>
<a name="ln98">//						STXTTranslator if n == 0</a>
<a name="ln99">//</a>
<a name="ln100">//             you, 	The image_id of the add-on that</a>
<a name="ln101">//						contains code (not used).</a>
<a name="ln102">//</a>
<a name="ln103">//             flags,	Has no meaning yet, should be 0.</a>
<a name="ln104">//</a>
<a name="ln105">// Postconditions:</a>
<a name="ln106">//</a>
<a name="ln107">// Returns: NULL if n is not zero,</a>
<a name="ln108">//          a new STXTTranslator if n is zero</a>
<a name="ln109">// ---------------------------------------------------------------</a>
<a name="ln110">BTranslator *</a>
<a name="ln111">make_nth_translator(int32 n, image_id you, uint32 flags, ...)</a>
<a name="ln112">{</a>
<a name="ln113">	if (!n)</a>
<a name="ln114">		return new (std::nothrow) STXTTranslator();</a>
<a name="ln115"> </a>
<a name="ln116">	return NULL;</a>
<a name="ln117">}</a>
<a name="ln118"> </a>
<a name="ln119"> </a>
<a name="ln120">//	#pragma mark -</a>
<a name="ln121"> </a>
<a name="ln122"> </a>
<a name="ln123">/*!</a>
<a name="ln124">	Determines if the data in inSource is of the STXT format.</a>
<a name="ln125"> </a>
<a name="ln126">	\param header the STXT stream header read in by Identify() or Translate()</a>
<a name="ln127">	\param inSource the stream with the STXT data</a>
<a name="ln128">	\param outInfo information about the type of data from inSource is stored here</a>
<a name="ln129">	\param outType the desired output type for the data in inSource</a>
<a name="ln130">	\param ptxtheader if this is not NULL, the TEXT header from</a>
<a name="ln131">		inSource is copied to it</a>
<a name="ln132">*/</a>
<a name="ln133">status_t</a>
<a name="ln134">identify_stxt_header(const TranslatorStyledTextStreamHeader &amp;header,</a>
<a name="ln135">	BPositionIO *inSource, translator_info *outInfo, uint32 outType,</a>
<a name="ln136">	TranslatorStyledTextTextHeader *ptxtheader = NULL)</a>
<a name="ln137">{</a>
<a name="ln138">	const ssize_t ktxtsize = sizeof(TranslatorStyledTextTextHeader);</a>
<a name="ln139">	const ssize_t kstylsize = sizeof(TranslatorStyledTextStyleHeader);</a>
<a name="ln140"> </a>
<a name="ln141">	uint8 buffer[max(ktxtsize, kstylsize)];</a>
<a name="ln142"> </a>
<a name="ln143">	// Check the TEXT header</a>
<a name="ln144">	TranslatorStyledTextTextHeader txtheader;</a>
<a name="ln145">	if (inSource-&gt;Read(buffer, ktxtsize) != ktxtsize)</a>
<a name="ln146">		return B_NO_TRANSLATOR;</a>
<a name="ln147"> </a>
<a name="ln148">	memcpy(&amp;txtheader, buffer, ktxtsize);</a>
<a name="ln149">	if (swap_data(B_UINT32_TYPE, &amp;txtheader, ktxtsize,</a>
<a name="ln150">		B_SWAP_BENDIAN_TO_HOST) != B_OK)</a>
<a name="ln151">		return B_ERROR;</a>
<a name="ln152"> </a>
<a name="ln153">	if (txtheader.header.magic != 'TEXT'</a>
<a name="ln154">		|| txtheader.header.header_size != sizeof(TranslatorStyledTextTextHeader)</a>
<a name="ln155">		|| txtheader.charset != B_UNICODE_UTF8)</a>
<a name="ln156">		return B_NO_TRANSLATOR;</a>
<a name="ln157"> </a>
<a name="ln158">	// skip the text data</a>
<a name="ln159">	off_t seekresult, pos;</a>
<a name="ln160">	pos = header.header.header_size + txtheader.header.header_size</a>
<a name="ln161">		+ txtheader.header.data_size;</a>
<a name="ln162">	seekresult = inSource-&gt;Seek(txtheader.header.data_size,</a>
<a name="ln163">		SEEK_CUR);</a>
<a name="ln164">	if (seekresult &lt; pos)</a>
<a name="ln165">		return B_NO_TRANSLATOR;</a>
<a name="ln166">	if (seekresult &gt; pos)</a>
<a name="ln167">		return B_ERROR;</a>
<a name="ln168"> </a>
<a name="ln169">	// check the STYL header (not all STXT files have this)</a>
<a name="ln170">	ssize_t read = 0;</a>
<a name="ln171">	TranslatorStyledTextStyleHeader stylheader;</a>
<a name="ln172">	read = inSource-&gt;Read(buffer, kstylsize);</a>
<a name="ln173">	if (read &lt; 0)</a>
<a name="ln174">		return read;</a>
<a name="ln175">	if (read != kstylsize &amp;&amp; read != 0)</a>
<a name="ln176">		return B_NO_TRANSLATOR;</a>
<a name="ln177"> </a>
<a name="ln178">	// If there is a STYL header</a>
<a name="ln179">	if (read == kstylsize) {</a>
<a name="ln180">		memcpy(&amp;stylheader, buffer, kstylsize);</a>
<a name="ln181">		if (swap_data(B_UINT32_TYPE, &amp;stylheader, kstylsize,</a>
<a name="ln182">			B_SWAP_BENDIAN_TO_HOST) != B_OK)</a>
<a name="ln183">			return B_ERROR;</a>
<a name="ln184"> </a>
<a name="ln185">		if (stylheader.header.magic != 'STYL'</a>
<a name="ln186">			|| stylheader.header.header_size !=</a>
<a name="ln187">				sizeof(TranslatorStyledTextStyleHeader))</a>
<a name="ln188">			return B_NO_TRANSLATOR;</a>
<a name="ln189">	}</a>
<a name="ln190"> </a>
<a name="ln191">	// if output TEXT header is supplied, fill it with data</a>
<a name="ln192">	if (ptxtheader) {</a>
<a name="ln193">		ptxtheader-&gt;header.magic = txtheader.header.magic;</a>
<a name="ln194">		ptxtheader-&gt;header.header_size = txtheader.header.header_size;</a>
<a name="ln195">		ptxtheader-&gt;header.data_size = txtheader.header.data_size;</a>
<a name="ln196">		ptxtheader-&gt;charset = txtheader.charset;</a>
<a name="ln197">	}</a>
<a name="ln198"> </a>
<a name="ln199">	// return information about the data in the stream</a>
<a name="ln200">	outInfo-&gt;type = B_STYLED_TEXT_FORMAT;</a>
<a name="ln201">	outInfo-&gt;group = B_TRANSLATOR_TEXT;</a>
<a name="ln202">	outInfo-&gt;quality = STXT_IN_QUALITY;</a>
<a name="ln203">	outInfo-&gt;capability = STXT_IN_CAPABILITY;</a>
<a name="ln204">	strlcpy(outInfo-&gt;name, B_TRANSLATE(&quot;Be styled text file&quot;),</a>
<a name="ln205">		sizeof(outInfo-&gt;name));</a>
<a name="ln206">	strcpy(outInfo-&gt;MIME, &quot;text/x-vnd.Be-stxt&quot;);</a>
<a name="ln207"> </a>
<a name="ln208">	return B_OK;</a>
<a name="ln209">}</a>
<a name="ln210"> </a>
<a name="ln211"> </a>
<a name="ln212">/*!</a>
<a name="ln213">	Determines if the data in \a inSource is of the UTF8 plain</a>
<a name="ln214"> </a>
<a name="ln215">	\param data buffer containing data already read (must be at</a>
<a name="ln216">		least DATA_BUFFER_SIZE bytes large)</a>
<a name="ln217">	\param nread number of bytes that have already been read from the stream</a>
<a name="ln218">	\param header the STXT stream header read in by Identify() or Translate()</a>
<a name="ln219">	\param inSource the stream with the STXT data</a>
<a name="ln220">	\param outInfo information about the type of data from inSource is stored here</a>
<a name="ln221">	\param outType the desired output type for the data in inSource</a>
<a name="ln222">*/</a>
<a name="ln223">status_t</a>
<a name="ln224">identify_text(uint8* data, int32 bytesRead, BPositionIO* source,</a>
<a name="ln225">	translator_info* outInfo, uint32 outType, const char*&amp; encoding)</a>
<a name="ln226">{</a>
<a name="ln227">	ssize_t readLater = source-&gt;Read(data + bytesRead, DATA_BUFFER_SIZE - bytesRead);</a>
<a name="ln228">	if (readLater &lt; B_OK)</a>
<a name="ln229">		return B_NO_TRANSLATOR;</a>
<a name="ln230"> </a>
<a name="ln231">	bytesRead += readLater;</a>
<a name="ln232"> </a>
<a name="ln233">	BPrivate::BTextEncoding textEncoding((char*)data, (size_t)bytesRead);</a>
<a name="ln234">	encoding = textEncoding.GetName();</a>
<a name="ln235">	if (strlen(encoding) == 0) {</a>
<a name="ln236">		/* No valid character encoding found! */</a>
<a name="ln237">		return B_NO_TRANSLATOR;</a>
<a name="ln238">	}</a>
<a name="ln239"> </a>
<a name="ln240">	float capability = TEXT_IN_CAPABILITY;</a>
<a name="ln241">	if (bytesRead &lt; 20)</a>
<a name="ln242">		capability = .1f;</a>
<a name="ln243"> </a>
<a name="ln244">	// return information about the data in the stream</a>
<a name="ln245">	outInfo-&gt;type = B_TRANSLATOR_TEXT;</a>
<a name="ln246">	outInfo-&gt;group = B_TRANSLATOR_TEXT;</a>
<a name="ln247">	outInfo-&gt;quality = TEXT_IN_QUALITY;</a>
<a name="ln248">	outInfo-&gt;capability = capability;</a>
<a name="ln249"> </a>
<a name="ln250">	strlcpy(outInfo-&gt;name, B_TRANSLATE(&quot;Plain text file&quot;),</a>
<a name="ln251">		sizeof(outInfo-&gt;name));</a>
<a name="ln252"> </a>
<a name="ln253">	//strlcpy(outInfo-&gt;MIME, type.Type(), sizeof(outInfo-&gt;MIME));</a>
<a name="ln254">	strcpy(outInfo-&gt;MIME, &quot;text/plain&quot;);</a>
<a name="ln255">	return B_OK;</a>
<a name="ln256">}</a>
<a name="ln257"> </a>
<a name="ln258"> </a>
<a name="ln259">// ---------------------------------------------------------------</a>
<a name="ln260">// translate_from_stxt</a>
<a name="ln261">//</a>
<a name="ln262">// Translates the data in inSource to the type outType and stores</a>
<a name="ln263">// the translated data in outDestination.</a>
<a name="ln264">//</a>
<a name="ln265">// Preconditions:</a>
<a name="ln266">//</a>
<a name="ln267">// Parameters:	inSource,	the data to be translated</a>
<a name="ln268">//</a>
<a name="ln269">//				outDestination,	where the translated data is</a>
<a name="ln270">//								put</a>
<a name="ln271">//</a>
<a name="ln272">//				outType,	the type to convert inSource to</a>
<a name="ln273">//</a>
<a name="ln274">//				txtheader, 	the TEXT header from inSource</a>
<a name="ln275">//</a>
<a name="ln276">//</a>
<a name="ln277">// Postconditions:</a>
<a name="ln278">//</a>
<a name="ln279">// Returns: B_BAD_VALUE, if outType is invalid</a>
<a name="ln280">//</a>
<a name="ln281">// B_NO_TRANSLATOR, if this translator doesn't understand the data</a>
<a name="ln282">//</a>
<a name="ln283">// B_ERROR, if there was an error allocating memory or converting</a>
<a name="ln284">//          data</a>
<a name="ln285">//</a>
<a name="ln286">// B_OK, if all went well</a>
<a name="ln287">// ---------------------------------------------------------------</a>
<a name="ln288">status_t</a>
<a name="ln289">translate_from_stxt(BPositionIO *inSource, BPositionIO *outDestination,</a>
<a name="ln290">		uint32 outType, const TranslatorStyledTextTextHeader &amp;txtheader)</a>
<a name="ln291">{</a>
<a name="ln292">	if (inSource-&gt;Seek(0, SEEK_SET) != 0)</a>
<a name="ln293">		return B_ERROR;</a>
<a name="ln294"> </a>
<a name="ln295">	const ssize_t kstxtsize = sizeof(TranslatorStyledTextStreamHeader);</a>
<a name="ln296">	const ssize_t ktxtsize = sizeof(TranslatorStyledTextTextHeader);</a>
<a name="ln297"> </a>
<a name="ln298">	bool btoplain;</a>
<a name="ln299">	if (outType == B_TRANSLATOR_TEXT)</a>
<a name="ln300">		btoplain = true;</a>
<a name="ln301">	else if (outType == B_STYLED_TEXT_FORMAT)</a>
<a name="ln302">		btoplain = false;</a>
<a name="ln303">	else</a>
<a name="ln304">		return B_BAD_VALUE;</a>
<a name="ln305"> </a>
<a name="ln306">	uint8 buffer[READ_BUFFER_SIZE];</a>
<a name="ln307">	ssize_t nread = 0, nwritten = 0, nreed = 0, ntotalread = 0;</a>
<a name="ln308"> </a>
<a name="ln309">	// skip to the actual text data when outputting a</a>
<a name="ln310">	// plain text file</a>
<a name="ln311">	if (btoplain) {</a>
<a name="ln312">		if (inSource-&gt;Seek(kstxtsize + ktxtsize, SEEK_CUR) !=</a>
<a name="ln313">			kstxtsize + ktxtsize)</a>
<a name="ln314">			return B_ERROR;</a>
<a name="ln315">	}</a>
<a name="ln316"> </a>
<a name="ln317">	// Read data from inSource</a>
<a name="ln318">	// When outputing B_TRANSLATOR_TEXT, the loop stops when all of</a>
<a name="ln319">	// the text data has been read and written.</a>
<a name="ln320">	// When outputting B_STYLED_TEXT_FORMAT, the loop stops when all</a>
<a name="ln321">	// of the data from inSource has been read and written.</a>
<a name="ln322">	if (btoplain)</a>
<a name="ln323">		nreed = min((size_t)READ_BUFFER_SIZE,</a>
<a name="ln324">			(size_t)txtheader.header.data_size - ntotalread);</a>
<a name="ln325">	else</a>
<a name="ln326">		nreed = READ_BUFFER_SIZE;</a>
<a name="ln327">	nread = inSource-&gt;Read(buffer, nreed);</a>
<a name="ln328">	while (nread &gt; 0) {</a>
<a name="ln329">		nwritten = outDestination-&gt;Write(buffer, nread);</a>
<a name="ln330">		if (nwritten != nread)</a>
<a name="ln331">			return B_ERROR;</a>
<a name="ln332"> </a>
<a name="ln333">		if (btoplain) {</a>
<a name="ln334">			ntotalread += nread;</a>
<a name="ln335">			nreed = min((size_t)READ_BUFFER_SIZE,</a>
<a name="ln336">				(size_t)txtheader.header.data_size - ntotalread);</a>
<a name="ln337">		} else</a>
<a name="ln338">			nreed = READ_BUFFER_SIZE;</a>
<a name="ln339">		nread = inSource-&gt;Read(buffer, nreed);</a>
<a name="ln340">	}</a>
<a name="ln341"> </a>
<a name="ln342">	if (btoplain &amp;&amp; static_cast&lt;ssize_t&gt;(txtheader.header.data_size) !=</a>
<a name="ln343">		ntotalread)</a>
<a name="ln344">		// If not all of the text data was able to be read...</a>
<a name="ln345">		return B_NO_TRANSLATOR;</a>
<a name="ln346">	else</a>
<a name="ln347">		return B_OK;</a>
<a name="ln348">}</a>
<a name="ln349"> </a>
<a name="ln350">// ---------------------------------------------------------------</a>
<a name="ln351">// output_headers</a>
<a name="ln352">//</a>
<a name="ln353">// Outputs the Stream and Text headers from the B_STYLED_TEXT_FORMAT</a>
<a name="ln354">// to outDestination, setting the data_size member of the text header</a>
<a name="ln355">// to text_data_size</a>
<a name="ln356">//</a>
<a name="ln357">// Preconditions:</a>
<a name="ln358">//</a>
<a name="ln359">// Parameters:	outDestination,	where the translated data is</a>
<a name="ln360">//								put</a>
<a name="ln361">//</a>
<a name="ln362">//				text_data_size, number of bytes in data section</a>
<a name="ln363">//							    of the TEXT header</a>
<a name="ln364">//</a>
<a name="ln365">//</a>
<a name="ln366">// Postconditions:</a>
<a name="ln367">//</a>
<a name="ln368">// Returns:</a>
<a name="ln369">//</a>
<a name="ln370">// B_ERROR, if there was an error writing to outDestination or</a>
<a name="ln371">// 	an error with converting the byte order</a>
<a name="ln372">//</a>
<a name="ln373">// B_OK, if all went well</a>
<a name="ln374">// ---------------------------------------------------------------</a>
<a name="ln375">status_t</a>
<a name="ln376">output_headers(BPositionIO *outDestination, uint32 text_data_size)</a>
<a name="ln377">{</a>
<a name="ln378">	const int32 kHeadersSize = sizeof(TranslatorStyledTextStreamHeader) +</a>
<a name="ln379">		sizeof(TranslatorStyledTextTextHeader);</a>
<a name="ln380">	status_t result;</a>
<a name="ln381">	TranslatorStyledTextStreamHeader stxtheader;</a>
<a name="ln382">	TranslatorStyledTextTextHeader txtheader;</a>
<a name="ln383"> </a>
<a name="ln384">	uint8 buffer[kHeadersSize];</a>
<a name="ln385"> </a>
<a name="ln386">	stxtheader.header.magic = 'STXT';</a>
<a name="ln387">	stxtheader.header.header_size = sizeof(TranslatorStyledTextStreamHeader);</a>
<a name="ln388">	stxtheader.header.data_size = 0;</a>
<a name="ln389">	stxtheader.version = 100;</a>
<a name="ln390">	memcpy(buffer, &amp;stxtheader, stxtheader.header.header_size);</a>
<a name="ln391"> </a>
<a name="ln392">	txtheader.header.magic = 'TEXT';</a>
<a name="ln393">	txtheader.header.header_size = sizeof(TranslatorStyledTextTextHeader);</a>
<a name="ln394">	txtheader.header.data_size = text_data_size;</a>
<a name="ln395">	txtheader.charset = B_UNICODE_UTF8;</a>
<a name="ln396">	memcpy(buffer + stxtheader.header.header_size, &amp;txtheader,</a>
<a name="ln397">		txtheader.header.header_size);</a>
<a name="ln398"> </a>
<a name="ln399">	// write out headers in Big Endian byte order</a>
<a name="ln400">	result = swap_data(B_UINT32_TYPE, buffer, kHeadersSize,</a>
<a name="ln401">		B_SWAP_HOST_TO_BENDIAN);</a>
<a name="ln402">	if (result == B_OK) {</a>
<a name="ln403">		ssize_t nwritten = 0;</a>
<a name="ln404">		nwritten = outDestination-&gt;Write(buffer, kHeadersSize);</a>
<a name="ln405">		if (nwritten != kHeadersSize)</a>
<a name="ln406">			return B_ERROR;</a>
<a name="ln407">		else</a>
<a name="ln408">			return B_OK;</a>
<a name="ln409">	}</a>
<a name="ln410"> </a>
<a name="ln411">	return result;</a>
<a name="ln412">}</a>
<a name="ln413"> </a>
<a name="ln414">// ---------------------------------------------------------------</a>
<a name="ln415">// output_styles</a>
<a name="ln416">//</a>
<a name="ln417">// Writes out the actual style information into outDestination</a>
<a name="ln418">// using the data from pflatRunArray</a>
<a name="ln419">//</a>
<a name="ln420">// Preconditions:</a>
<a name="ln421">//</a>
<a name="ln422">// Parameters:	outDestination,	where the translated data is</a>
<a name="ln423">//								put</a>
<a name="ln424">//</a>
<a name="ln425">//				text_size,		size in bytes of the text in</a>
<a name="ln426">//								outDestination</a>
<a name="ln427">//</a>
<a name="ln428">//				data_size,		size of pflatRunArray</a>
<a name="ln429">//</a>
<a name="ln430">// Postconditions:</a>
<a name="ln431">//</a>
<a name="ln432">// Returns:</a>
<a name="ln433">//</a>
<a name="ln434">// B_ERROR, if there was an error writing to outDestination or</a>
<a name="ln435">// 	an error with converting the byte order</a>
<a name="ln436">//</a>
<a name="ln437">// B_OK, if all went well</a>
<a name="ln438">// ---------------------------------------------------------------</a>
<a name="ln439">status_t</a>
<a name="ln440">output_styles(BPositionIO *outDestination, uint32 text_size,</a>
<a name="ln441">	uint8 *pflatRunArray, ssize_t data_size)</a>
<a name="ln442">{</a>
<a name="ln443">	const ssize_t kstylsize = sizeof(TranslatorStyledTextStyleHeader);</a>
<a name="ln444"> </a>
<a name="ln445">	uint8 buffer[kstylsize];</a>
<a name="ln446"> </a>
<a name="ln447">	// output STYL header</a>
<a name="ln448">	TranslatorStyledTextStyleHeader stylheader;</a>
<a name="ln449">	stylheader.header.magic = 'STYL';</a>
<a name="ln450">	stylheader.header.header_size =</a>
<a name="ln451">		sizeof(TranslatorStyledTextStyleHeader);</a>
<a name="ln452">	stylheader.header.data_size = data_size;</a>
<a name="ln453">	stylheader.apply_offset = 0;</a>
<a name="ln454">	stylheader.apply_length = text_size;</a>
<a name="ln455"> </a>
<a name="ln456">	memcpy(buffer, &amp;stylheader, kstylsize);</a>
<a name="ln457">	if (swap_data(B_UINT32_TYPE, buffer, kstylsize,</a>
<a name="ln458">		B_SWAP_HOST_TO_BENDIAN) != B_OK)</a>
<a name="ln459">		return B_ERROR;</a>
<a name="ln460">	if (outDestination-&gt;Write(buffer, kstylsize) != kstylsize)</a>
<a name="ln461">		return B_ERROR;</a>
<a name="ln462"> </a>
<a name="ln463">	// output actual style information</a>
<a name="ln464">	if (outDestination-&gt;Write(pflatRunArray,</a>
<a name="ln465">		data_size) != data_size)</a>
<a name="ln466">		return B_ERROR;</a>
<a name="ln467"> </a>
<a name="ln468">	return B_OK;</a>
<a name="ln469">}</a>
<a name="ln470"> </a>
<a name="ln471"> </a>
<a name="ln472">/*!</a>
<a name="ln473">	Convert the plain text (UTF8) from inSource to plain or</a>
<a name="ln474">	styled text in outDestination</a>
<a name="ln475">*/</a>
<a name="ln476">status_t</a>
<a name="ln477">translate_from_text(BPositionIO* source, const char* outEncoding, bool forceEncoding,</a>
<a name="ln478">	BPositionIO* destination, uint32 outType)</a>
<a name="ln479">{</a>
<a name="ln480">	if (outType != B_TRANSLATOR_TEXT &amp;&amp; outType != B_STYLED_TEXT_FORMAT)</a>
<a name="ln481">		return B_BAD_VALUE;</a>
<a name="ln482"> </a>
<a name="ln483">	// find the length of the text</a>
<a name="ln484">	off_t size = source-&gt;Seek(0, SEEK_END);</a>
<a name="ln485">	if (size &lt; 0)</a>
<a name="ln486">		return (status_t)size;</a>
<a name="ln487">	if (size &gt; UINT32_MAX &amp;&amp; outType == B_STYLED_TEXT_FORMAT)</a>
<a name="ln488">		return B_NOT_SUPPORTED;</a>
<a name="ln489"> </a>
<a name="ln490">	status_t status = source-&gt;Seek(0, SEEK_SET);</a>
<a name="ln491">	if (status &lt; B_OK)</a>
<a name="ln492">		return status;</a>
<a name="ln493"> </a>
<a name="ln494">	if (outType == B_STYLED_TEXT_FORMAT) {</a>
<a name="ln495">		// output styled text headers</a>
<a name="ln496">		status = output_headers(destination, (uint32)size);</a>
<a name="ln497">		if (status != B_OK)</a>
<a name="ln498">			return status;</a>
<a name="ln499">	}</a>
<a name="ln500"> </a>
<a name="ln501">	class MallocBuffer {</a>
<a name="ln502">		public:</a>
<a name="ln503">			MallocBuffer() : fBuffer(NULL), fSize(0) {}</a>
<a name="ln504">			~MallocBuffer() { free(fBuffer); }</a>
<a name="ln505"> </a>
<a name="ln506">			void* Buffer() { return fBuffer; }</a>
<a name="ln507">			size_t Size() const { return fSize; }</a>
<a name="ln508"> </a>
<a name="ln509">			status_t</a>
<a name="ln510">			Allocate(size_t size)</a>
<a name="ln511">			{</a>
<a name="ln512">				fBuffer = malloc(size);</a>
<a name="ln513">				if (fBuffer != NULL) {</a>
<a name="ln514">					fSize = size;</a>
<a name="ln515">					return B_OK;</a>
<a name="ln516">				}</a>
<a name="ln517">				return B_NO_MEMORY;</a>
<a name="ln518">			}</a>
<a name="ln519"> </a>
<a name="ln520">		private:</a>
<a name="ln521">			void*	fBuffer;</a>
<a name="ln522">			size_t	fSize;</a>
<a name="ln523">	} encodingBuffer;</a>
<a name="ln524"> </a>
<a name="ln525">	BNode* node = dynamic_cast&lt;BNode*&gt;(source);</a>
<a name="ln526">	BString encoding(outEncoding);</a>
<a name="ln527">	if (node != NULL) {</a>
<a name="ln528">		// determine encoding, if available</a>
<a name="ln529">		bool hasAttribute = false;</a>
<a name="ln530">		if (encoding.String() &amp;&amp; !forceEncoding) {</a>
<a name="ln531">			attr_info info;</a>
<a name="ln532">			node-&gt;GetAttrInfo(&quot;be:encoding&quot;, &amp;info);</a>
<a name="ln533"> </a>
<a name="ln534">			if ((info.type == B_STRING_TYPE) &amp;&amp; (node-&gt;ReadAttrString(</a>
<a name="ln535">					&quot;be:encoding&quot;, &amp;encoding) == B_OK)) {</a>
<a name="ln536">				hasAttribute = true;</a>
<a name="ln537">			} else if (info.type == B_INT32_TYPE) {</a>
<a name="ln538">				// Try the BeOS version of the atribute, which used an int32</a>
<a name="ln539">				// and a well-known list of encodings.</a>
<a name="ln540">				int32 value;</a>
<a name="ln541">				ssize_t bytesRead = node-&gt;ReadAttr(&quot;be:encoding&quot;, B_INT32_TYPE, 0,</a>
<a name="ln542">					&amp;value, sizeof(value));</a>
<a name="ln543">				if (bytesRead == (ssize_t)sizeof(value)) {</a>
<a name="ln544">					if (value != 65535) {</a>
<a name="ln545">						const BCharacterSet* characterSet</a>
<a name="ln546">							= BCharacterSetRoster::GetCharacterSetByConversionID(value);</a>
<a name="ln547">						if (characterSet != NULL)</a>
<a name="ln548">							encoding = characterSet-&gt;GetName();</a>
<a name="ln549">					}</a>
<a name="ln550">				}</a>
<a name="ln551">			}</a>
<a name="ln552">		} else {</a>
<a name="ln553">			hasAttribute = true;</a>
<a name="ln554">				// we don't write the encoding in this case</a>
<a name="ln555">		}</a>
<a name="ln556"> </a>
<a name="ln557">		if (!encoding.IsEmpty())</a>
<a name="ln558">			encodingBuffer.Allocate(READ_BUFFER_SIZE * 4);</a>
<a name="ln559"> </a>
<a name="ln560">		if (!hasAttribute &amp;&amp; !encoding.IsEmpty()) {</a>
<a name="ln561">			// add encoding attribute, so that someone opening the file can</a>
<a name="ln562">			// retrieve it for persistance</a>
<a name="ln563">			node-&gt;WriteAttrString(&quot;be:encoding&quot;, &amp;encoding);</a>
<a name="ln564">		}</a>
<a name="ln565">	}</a>
<a name="ln566"> </a>
<a name="ln567">	off_t outputSize = 0;</a>
<a name="ln568">	ssize_t bytesRead;</a>
<a name="ln569"> </a>
<a name="ln570">	BPrivate::BTextEncoding codec(encoding.String());</a>
<a name="ln571"> </a>
<a name="ln572">	// output the actual text part of the data</a>
<a name="ln573">	do {</a>
<a name="ln574">		uint8 buffer[READ_BUFFER_SIZE];</a>
<a name="ln575">		bytesRead = source-&gt;Read(buffer, READ_BUFFER_SIZE);</a>
<a name="ln576">		if (bytesRead &lt; B_OK)</a>
<a name="ln577">			return bytesRead;</a>
<a name="ln578">		if (bytesRead == 0)</a>
<a name="ln579">			break;</a>
<a name="ln580"> </a>
<a name="ln581">		if (encodingBuffer.Size() == 0) {</a>
<a name="ln582">			// default, no encoding</a>
<a name="ln583">			ssize_t bytesWritten = destination-&gt;Write(buffer, bytesRead);</a>
<a name="ln584">			if (bytesWritten != bytesRead) {</a>
<a name="ln585">				if (bytesWritten &lt; B_OK)</a>
<a name="ln586">					return bytesWritten;</a>
<a name="ln587"> </a>
<a name="ln588">				return B_ERROR;</a>
<a name="ln589">			}</a>
<a name="ln590"> </a>
<a name="ln591">			outputSize += bytesRead;</a>
<a name="ln592">		} else {</a>
<a name="ln593">			// decode text file to UTF-8</a>
<a name="ln594">			const char* pos = (char*)buffer;</a>
<a name="ln595">			size_t encodingLength;</a>
<a name="ln596">			int32 bytesLeft = bytesRead;</a>
<a name="ln597">			size_t bytes;</a>
<a name="ln598">			do {</a>
<a name="ln599">				encodingLength = READ_BUFFER_SIZE * 4;</a>
<a name="ln600">				bytes = bytesLeft;</a>
<a name="ln601"> </a>
<a name="ln602">				status = codec.Decode(pos, bytes,</a>
<a name="ln603">					(char*)encodingBuffer.Buffer(), encodingLength);</a>
<a name="ln604">				if (status &lt; B_OK) {</a>
<a name="ln605">					return status;</a>
<a name="ln606">				}</a>
<a name="ln607"> </a>
<a name="ln608">				ssize_t bytesWritten = destination-&gt;Write(encodingBuffer.Buffer(),</a>
<a name="ln609">					encodingLength);</a>
<a name="ln610">				if (bytesWritten &lt; (ssize_t)encodingLength) {</a>
<a name="ln611">					if (bytesWritten &lt; B_OK)</a>
<a name="ln612">						return bytesWritten;</a>
<a name="ln613"> </a>
<a name="ln614">					return B_ERROR;</a>
<a name="ln615">				}</a>
<a name="ln616"> </a>
<a name="ln617">				pos += bytes;</a>
<a name="ln618">				bytesLeft -= bytes;</a>
<a name="ln619">				outputSize += encodingLength;</a>
<a name="ln620">			} while (encodingLength &gt; 0 &amp;&amp; bytesLeft &gt; 0);</a>
<a name="ln621">		}</a>
<a name="ln622">	} while (bytesRead &gt; 0);</a>
<a name="ln623"> </a>
<a name="ln624">	if (outType != B_STYLED_TEXT_FORMAT)</a>
<a name="ln625">		return B_OK;</a>
<a name="ln626"> </a>
<a name="ln627">	if (encodingBuffer.Size() != 0 &amp;&amp; size != outputSize) {</a>
<a name="ln628">		if (outputSize &gt; UINT32_MAX)</a>
<a name="ln629">			return B_NOT_SUPPORTED;</a>
<a name="ln630"> </a>
<a name="ln631">		// we need to update the header as the decoded text size has changed</a>
<a name="ln632">		status = destination-&gt;Seek(0, SEEK_SET);</a>
<a name="ln633">		if (status == B_OK)</a>
<a name="ln634">			status = output_headers(destination, (uint32)outputSize);</a>
<a name="ln635">		if (status == B_OK)</a>
<a name="ln636">			status = destination-&gt;Seek(0, SEEK_END);</a>
<a name="ln637"> </a>
<a name="ln638">		if (status &lt; B_OK)</a>
<a name="ln639">			return status;</a>
<a name="ln640">	}</a>
<a name="ln641"> </a>
<a name="ln642">	// Read file attributes if outputting styled data</a>
<a name="ln643">	// and source is a BNode object</a>
<a name="ln644"> </a>
<a name="ln645">	if (node == NULL)</a>
<a name="ln646">		return B_OK;</a>
<a name="ln647"> </a>
<a name="ln648">	// Try to read styles - we only propagate an error if the actual on-disk</a>
<a name="ln649">	// data is likely to be okay</a>
<a name="ln650"> </a>
<a name="ln651">	const char *kAttrName = &quot;styles&quot;;</a>
<a name="ln652">	attr_info info;</a>
<a name="ln653">	if (node-&gt;GetAttrInfo(kAttrName, &amp;info) != B_OK)</a>
<a name="ln654">		return B_OK;</a>
<a name="ln655"> </a>
<a name="ln656">	if (info.type != B_RAW_TYPE || info.size &lt; 160) {</a>
<a name="ln657">		// styles seem to be broken, but since we got the text,</a>
<a name="ln658">		// we don't propagate the error</a>
<a name="ln659">		return B_OK;</a>
<a name="ln660">	}</a>
<a name="ln661"> </a>
<a name="ln662">	uint8* flatRunArray = new (std::nothrow) uint8[info.size];</a>
<a name="ln663">	if (flatRunArray == NULL)</a>
<a name="ln664">		return B_NO_MEMORY;</a>
<a name="ln665"> </a>
<a name="ln666">	bytesRead = node-&gt;ReadAttr(kAttrName, B_RAW_TYPE, 0, flatRunArray, info.size);</a>
<a name="ln667">	if (bytesRead != info.size)</a>
<a name="ln668">		return B_OK;</a>
<a name="ln669"> </a>
<a name="ln670">	output_styles(destination, size, flatRunArray, info.size);</a>
<a name="ln671"> </a>
<a name="ln672">	delete[] flatRunArray;</a>
<a name="ln673">	return B_OK;</a>
<a name="ln674">}</a>
<a name="ln675"> </a>
<a name="ln676"> </a>
<a name="ln677">//	#pragma mark -</a>
<a name="ln678"> </a>
<a name="ln679"> </a>
<a name="ln680">STXTTranslator::STXTTranslator()</a>
<a name="ln681">	: BaseTranslator(B_TRANSLATE(&quot;StyledEdit files&quot;),</a>
<a name="ln682">		B_TRANSLATE(&quot;StyledEdit file translator&quot;),</a>
<a name="ln683">		STXT_TRANSLATOR_VERSION,</a>
<a name="ln684">		sInputFormats, kNumInputFormats,</a>
<a name="ln685">		sOutputFormats, kNumOutputFormats,</a>
<a name="ln686">		&quot;STXTTranslator_Settings&quot;,</a>
<a name="ln687">		sDefaultSettings, kNumDefaultSettings,</a>
<a name="ln688">		B_TRANSLATOR_TEXT, B_STYLED_TEXT_FORMAT)</a>
<a name="ln689">{</a>
<a name="ln690">}</a>
<a name="ln691"> </a>
<a name="ln692"> </a>
<a name="ln693">STXTTranslator::~STXTTranslator()</a>
<a name="ln694">{</a>
<a name="ln695">}</a>
<a name="ln696"> </a>
<a name="ln697"> </a>
<a name="ln698">status_t</a>
<a name="ln699">STXTTranslator::Identify(BPositionIO *inSource,</a>
<a name="ln700">	const translation_format *inFormat, BMessage *ioExtension,</a>
<a name="ln701">	translator_info *outInfo, uint32 outType)</a>
<a name="ln702">{</a>
<a name="ln703">	if (!outType)</a>
<a name="ln704">		outType = B_TRANSLATOR_TEXT;</a>
<a name="ln705">	if (outType != B_TRANSLATOR_TEXT &amp;&amp; outType != B_STYLED_TEXT_FORMAT)</a>
<a name="ln706">		return B_NO_TRANSLATOR;</a>
<a name="ln707"> </a>
<a name="ln708">	const ssize_t kstxtsize = sizeof(TranslatorStyledTextStreamHeader);</a>
<a name="ln709"> </a>
<a name="ln710">	uint8 buffer[DATA_BUFFER_SIZE];</a>
<a name="ln711">	status_t nread = 0;</a>
<a name="ln712">	// Read in the header to determine</a>
<a name="ln713">	// if the data is supported</a>
<a name="ln714">	nread = inSource-&gt;Read(buffer, kstxtsize);</a>
<a name="ln715">	if (nread &lt; 0)</a>
<a name="ln716">		return nread;</a>
<a name="ln717"> </a>
<a name="ln718">	// read in enough data to fill the stream header</a>
<a name="ln719">	if (nread == kstxtsize) {</a>
<a name="ln720">		TranslatorStyledTextStreamHeader header;</a>
<a name="ln721">		memcpy(&amp;header, buffer, kstxtsize);</a>
<a name="ln722">		if (swap_data(B_UINT32_TYPE, &amp;header, kstxtsize,</a>
<a name="ln723">				B_SWAP_BENDIAN_TO_HOST) != B_OK)</a>
<a name="ln724">			return B_ERROR;</a>
<a name="ln725"> </a>
<a name="ln726">		if (header.header.magic == B_STYLED_TEXT_FORMAT</a>
<a name="ln727">			&amp;&amp; header.header.header_size == (int32)kstxtsize</a>
<a name="ln728">			&amp;&amp; header.header.data_size == 0</a>
<a name="ln729">			&amp;&amp; header.version == 100)</a>
<a name="ln730">			return identify_stxt_header(header, inSource, outInfo, outType);</a>
<a name="ln731">	}</a>
<a name="ln732"> </a>
<a name="ln733">	// if the data is not styled text, check if it is plain text</a>
<a name="ln734">	const char* encoding;</a>
<a name="ln735">	return identify_text(buffer, nread, inSource, outInfo, outType, encoding);</a>
<a name="ln736">}</a>
<a name="ln737"> </a>
<a name="ln738"> </a>
<a name="ln739">status_t</a>
<a name="ln740">STXTTranslator::Translate(BPositionIO* source, const translator_info* info,</a>
<a name="ln741">	BMessage* ioExtension, uint32 outType, BPositionIO* outDestination)</a>
<a name="ln742">{</a>
<a name="ln743">	if (!outType)</a>
<a name="ln744">		outType = B_TRANSLATOR_TEXT;</a>
<a name="ln745">	if (outType != B_TRANSLATOR_TEXT &amp;&amp; outType != B_STYLED_TEXT_FORMAT)</a>
<a name="ln746">		return B_NO_TRANSLATOR;</a>
<a name="ln747"> </a>
<a name="ln748">	const ssize_t headerSize = sizeof(TranslatorStyledTextStreamHeader);</a>
<a name="ln749">	uint8 buffer[DATA_BUFFER_SIZE];</a>
<a name="ln750">	status_t result;</a>
<a name="ln751">	translator_info outInfo;</a>
<a name="ln752">	// Read in the header to determine</a>
<a name="ln753">	// if the data is supported</a>
<a name="ln754">	ssize_t bytesRead = source-&gt;Read(buffer, headerSize);</a>
<a name="ln755">	if (bytesRead &lt; 0)</a>
<a name="ln756">		return bytesRead;</a>
<a name="ln757"> </a>
<a name="ln758">	// read in enough data to fill the stream header</a>
<a name="ln759">	if (bytesRead == headerSize) {</a>
<a name="ln760">		TranslatorStyledTextStreamHeader header;</a>
<a name="ln761">		memcpy(&amp;header, buffer, headerSize);</a>
<a name="ln762">		if (swap_data(B_UINT32_TYPE, &amp;header, headerSize,</a>
<a name="ln763">				B_SWAP_BENDIAN_TO_HOST) != B_OK)</a>
<a name="ln764">			return B_ERROR;</a>
<a name="ln765"> </a>
<a name="ln766">		if (header.header.magic == B_STYLED_TEXT_FORMAT</a>
<a name="ln767">			&amp;&amp; header.header.header_size == sizeof(TranslatorStyledTextStreamHeader)</a>
<a name="ln768">			&amp;&amp; header.header.data_size == 0</a>
<a name="ln769">			&amp;&amp; header.version == 100) {</a>
<a name="ln770">			TranslatorStyledTextTextHeader textHeader;</a>
<a name="ln771">			result = identify_stxt_header(header, source, &amp;outInfo, outType,</a>
<a name="ln772">				&amp;textHeader);</a>
<a name="ln773">			if (result != B_OK)</a>
<a name="ln774">				return result;</a>
<a name="ln775"> </a>
<a name="ln776">			return translate_from_stxt(source, outDestination, outType, textHeader);</a>
<a name="ln777">		}</a>
<a name="ln778">	}</a>
<a name="ln779"> </a>
<a name="ln780">	// if the data is not styled text, check if it is ASCII text</a>
<a name="ln781">	bool forceEncoding = false;</a>
<a name="ln782">	const char* encoding = NULL;</a>
<a name="ln783">	result = identify_text(buffer, bytesRead, source, &amp;outInfo, outType, encoding);</a>
<a name="ln784">	if (result != B_OK)</a>
<a name="ln785">		return result;</a>
<a name="ln786"> </a>
<a name="ln787">	if (ioExtension != NULL) {</a>
<a name="ln788">		const char* value;</a>
<a name="ln789">		if (ioExtension-&gt;FindString(&quot;be:encoding&quot;, &amp;value) == B_OK</a>
<a name="ln790">			&amp;&amp; value[0]) {</a>
<a name="ln791">			// override encoding</a>
<a name="ln792">			encoding = value;</a>
<a name="ln793">			forceEncoding = true;</a>
<a name="ln794">		}</a>
<a name="ln795">	}</a>
<a name="ln796"> </a>
<a name="ln797">	return translate_from_text(source, encoding, forceEncoding, outDestination, outType);</a>
<a name="ln798">}</a>
<a name="ln799"> </a>
<a name="ln800"> </a>
<a name="ln801">BView *</a>
<a name="ln802">STXTTranslator::NewConfigView(TranslatorSettings *settings)</a>
<a name="ln803">{</a>
<a name="ln804">	return new STXTView(BRect(0, 0, 225, 175),</a>
<a name="ln805">		B_TRANSLATE(&quot;STXTTranslator Settings&quot;),</a>
<a name="ln806">		B_FOLLOW_ALL, B_WILL_DRAW, settings);</a>
<a name="ln807">}</a>
<a name="ln808"> </a>

</code></pre>
<div class="balloon" rel="622"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v654/" target="_blank">V654</a> The condition 'bytesRead > 0' of loop is always true.</p></div>
<div class="balloon" rel="390"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memcpy' function will lead to underflow of the buffer 'buffer'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
