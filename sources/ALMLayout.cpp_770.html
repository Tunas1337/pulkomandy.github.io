
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ALMLayout.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2007-2008, Christof Lutteroth, lutteroth@cs.auckland.ac.nz</a>
<a name="ln3"> * Copyright 2007-2008, James Kim, jkim202@ec.auckland.ac.nz</a>
<a name="ln4"> * Copyright 2010, Clemens Zeidler &lt;haiku@clemens-zeidler.de&gt;</a>
<a name="ln5"> * Distributed under the terms of the MIT License.</a>
<a name="ln6"> */</a>
<a name="ln7"> </a>
<a name="ln8"> </a>
<a name="ln9">#include &quot;ALMLayout.h&quot;</a>
<a name="ln10"> </a>
<a name="ln11"> </a>
<a name="ln12">#include &lt;stdio.h&gt;</a>
<a name="ln13">#include &lt;vector&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;AutoDeleter.h&gt;</a>
<a name="ln16">#include &lt;ControlLook.h&gt;</a>
<a name="ln17"> </a>
<a name="ln18">#include &quot;RowColumnManager.h&quot;</a>
<a name="ln19">#include &quot;SharedSolver.h&quot;</a>
<a name="ln20">#include &quot;ViewLayoutItem.h&quot;</a>
<a name="ln21"> </a>
<a name="ln22"> </a>
<a name="ln23">using BPrivate::AutoDeleter;</a>
<a name="ln24">using namespace LinearProgramming;</a>
<a name="ln25"> </a>
<a name="ln26"> </a>
<a name="ln27">const BSize kUnsetSize(B_SIZE_UNSET, B_SIZE_UNSET);</a>
<a name="ln28"> </a>
<a name="ln29"> </a>
<a name="ln30">namespace {</a>
<a name="ln31"> </a>
<a name="ln32">const char* kSolverField = &quot;BALMLayout:solver&quot;;</a>
<a name="ln33">const char* kBadLayoutPolicyField = &quot;BALMLayout:policy&quot;;</a>
<a name="ln34">const char* kXTabsField = &quot;BALMLayout:xtabs&quot;;</a>
<a name="ln35">const char* kYTabsField = &quot;BALMLayout:ytabs&quot;;</a>
<a name="ln36">const char* kMyTabsField = &quot;BALMLayout:tabs&quot;;</a>
<a name="ln37">const char* kInsetsField = &quot;BALMLayout:insets&quot;;</a>
<a name="ln38">const char* kSpacingField = &quot;BALMLayout:spacing&quot;;</a>
<a name="ln39"> </a>
<a name="ln40">const char* kTabsField = &quot;BALMLayout:item:tabs&quot;;</a>
<a name="ln41">const char* kItemAspectRatio = &quot;BALMLayout:item:aspect&quot;;</a>
<a name="ln42">const char* kItemPenalties = &quot;BALMLayout:item:penalties&quot;;</a>
<a name="ln43">const char* kItemInsets = &quot;BALMLayout:item:insets&quot;;</a>
<a name="ln44"> </a>
<a name="ln45">int CompareXTabFunc(const XTab* tab1, const XTab* tab2);</a>
<a name="ln46">int CompareYTabFunc(const YTab* tab1, const YTab* tab2);</a>
<a name="ln47"> </a>
<a name="ln48">};</a>
<a name="ln49"> </a>
<a name="ln50"> </a>
<a name="ln51">namespace BALM {</a>
<a name="ln52"> </a>
<a name="ln53"> </a>
<a name="ln54">template &lt;class T&gt;</a>
<a name="ln55">struct BALMLayout::TabAddTransaction {</a>
<a name="ln56">	~TabAddTransaction()</a>
<a name="ln57">	{</a>
<a name="ln58">		if (fTab)</a>
<a name="ln59">			fLayout-&gt;_RemoveSelfFromTab(fTab);</a>
<a name="ln60">		if (fIndex &gt; 0)</a>
<a name="ln61">			_TabList()-&gt;RemoveItemAt(fIndex);</a>
<a name="ln62">	}</a>
<a name="ln63"> </a>
<a name="ln64">	TabAddTransaction(BALMLayout* layout)</a>
<a name="ln65">		:</a>
<a name="ln66">		fTab(NULL),</a>
<a name="ln67">		fLayout(layout),</a>
<a name="ln68">		fIndex(-1)</a>
<a name="ln69">	{</a>
<a name="ln70">	}</a>
<a name="ln71"> </a>
<a name="ln72">	bool AttempAdd(T* tab)</a>
<a name="ln73">	{</a>
<a name="ln74">		if (fLayout-&gt;_HasTabInLayout(tab))</a>
<a name="ln75">			return true;</a>
<a name="ln76">		if (!fLayout-&gt;_AddedTab(tab))</a>
<a name="ln77">			return false;</a>
<a name="ln78">		fTab = tab;</a>
<a name="ln79"> </a>
<a name="ln80">		BObjectList&lt;T&gt;* tabList = _TabList();</a>
<a name="ln81">		int32 index = tabList-&gt;CountItems();</a>
<a name="ln82">		if (!tabList-&gt;AddItem(tab, index))</a>
<a name="ln83">			return false;</a>
<a name="ln84">		fIndex = index;</a>
<a name="ln85">		return true;</a>
<a name="ln86">	}</a>
<a name="ln87"> </a>
<a name="ln88">	void Commit()</a>
<a name="ln89">	{</a>
<a name="ln90">		fTab = NULL;</a>
<a name="ln91">		fIndex = -1;</a>
<a name="ln92">	}</a>
<a name="ln93"> </a>
<a name="ln94">private:</a>
<a name="ln95">	BObjectList&lt;T&gt;* _TabList();</a>
<a name="ln96"> </a>
<a name="ln97">	T*				fTab;</a>
<a name="ln98">	BALMLayout*		fLayout;</a>
<a name="ln99">	int32			fIndex;</a>
<a name="ln100">};</a>
<a name="ln101"> </a>
<a name="ln102"> </a>
<a name="ln103">template &lt;&gt;</a>
<a name="ln104">BObjectList&lt;XTab&gt;*</a>
<a name="ln105">BALMLayout::TabAddTransaction&lt;XTab&gt;::_TabList()</a>
<a name="ln106">{</a>
<a name="ln107">	return &amp;fLayout-&gt;fXTabList;</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110"> </a>
<a name="ln111">template &lt;&gt;</a>
<a name="ln112">BObjectList&lt;YTab&gt;*</a>
<a name="ln113">BALMLayout::TabAddTransaction&lt;YTab&gt;::_TabList()</a>
<a name="ln114">{</a>
<a name="ln115">	return &amp;fLayout-&gt;fYTabList;</a>
<a name="ln116">}</a>
<a name="ln117"> </a>
<a name="ln118"> </a>
<a name="ln119">}; // end namespace BALM</a>
<a name="ln120"> </a>
<a name="ln121"> </a>
<a name="ln122">BALM::BALMLayout::BadLayoutPolicy::BadLayoutPolicy()</a>
<a name="ln123">{</a>
<a name="ln124">}</a>
<a name="ln125"> </a>
<a name="ln126"> </a>
<a name="ln127">BALM::BALMLayout::BadLayoutPolicy::BadLayoutPolicy(BMessage* archive)</a>
<a name="ln128">	:</a>
<a name="ln129">	BArchivable(archive)</a>
<a name="ln130">{</a>
<a name="ln131">}</a>
<a name="ln132"> </a>
<a name="ln133"> </a>
<a name="ln134">BALM::BALMLayout::BadLayoutPolicy::~BadLayoutPolicy()</a>
<a name="ln135">{</a>
<a name="ln136">}</a>
<a name="ln137"> </a>
<a name="ln138"> </a>
<a name="ln139">BALM::BALMLayout::DefaultPolicy::DefaultPolicy()</a>
<a name="ln140">{</a>
<a name="ln141">}</a>
<a name="ln142"> </a>
<a name="ln143"> </a>
<a name="ln144">BALM::BALMLayout::DefaultPolicy::DefaultPolicy(BMessage* archive)</a>
<a name="ln145">	:</a>
<a name="ln146">	BadLayoutPolicy(archive)</a>
<a name="ln147">{</a>
<a name="ln148">}</a>
<a name="ln149"> </a>
<a name="ln150"> </a>
<a name="ln151">BALM::BALMLayout::DefaultPolicy::~DefaultPolicy()</a>
<a name="ln152">{</a>
<a name="ln153">}</a>
<a name="ln154"> </a>
<a name="ln155"> </a>
<a name="ln156">bool</a>
<a name="ln157">BALM::BALMLayout::DefaultPolicy::OnBadLayout(BALMLayout* layout,</a>
<a name="ln158">	ResultType result, BLayoutContext* context)</a>
<a name="ln159">{</a>
<a name="ln160">	if (!context)</a>
<a name="ln161">		return true;</a>
<a name="ln162"> </a>
<a name="ln163">	if (result == kInfeasible) {</a>
<a name="ln164">		printf(&quot;BALMLayout failed to solve your layout!\n&quot;);</a>
<a name="ln165">		return false;</a>
<a name="ln166">	} else</a>
<a name="ln167">		return true;</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170"> </a>
<a name="ln171">status_t</a>
<a name="ln172">BALM::BALMLayout::DefaultPolicy::Archive(BMessage* archive, bool deep) const</a>
<a name="ln173">{</a>
<a name="ln174">	return BadLayoutPolicy::Archive(archive, deep);</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177"> </a>
<a name="ln178">BArchivable*</a>
<a name="ln179">BALM::BALMLayout::DefaultPolicy::Instantiate(BMessage* archive)</a>
<a name="ln180">{</a>
<a name="ln181">	if (validate_instantiation(archive, &quot;BALM::BALMLayout::DefaultPolicy&quot;))</a>
<a name="ln182">		return new DefaultPolicy(archive);</a>
<a name="ln183">	return NULL;</a>
<a name="ln184">}</a>
<a name="ln185"> </a>
<a name="ln186"> </a>
<a name="ln187">class BALMLayout::BALMLayoutSpecListener </a>
<a name="ln188">	: public LinearProgramming::SpecificationListener {</a>
<a name="ln189">public:</a>
<a name="ln190">	BALMLayoutSpecListener(BALMLayout* layout)</a>
<a name="ln191">		:</a>
<a name="ln192">		fLayout(layout)</a>
<a name="ln193">	{		</a>
<a name="ln194">	}</a>
<a name="ln195"> </a>
<a name="ln196">	void ConstraintRemoved(Constraint* constraint)</a>
<a name="ln197">	{</a>
<a name="ln198">		fLayout-&gt;fConstraints.RemoveItem(constraint);</a>
<a name="ln199">	}</a>
<a name="ln200"> </a>
<a name="ln201">private:</a>
<a name="ln202">			BALMLayout*			fLayout;</a>
<a name="ln203">};</a>
<a name="ln204"> </a>
<a name="ln205"> </a>
<a name="ln206">/*!</a>
<a name="ln207"> * Constructor.</a>
<a name="ln208"> * Creates new layout engine.</a>
<a name="ln209"> *</a>
<a name="ln210"> * If friendLayout is not NULL the solver of the friend layout is used.</a>
<a name="ln211"> */</a>
<a name="ln212">BALMLayout::BALMLayout(float hSpacing, float vSpacing, BALMLayout* friendLayout)</a>
<a name="ln213">	:</a>
<a name="ln214">	fLeftInset(0),</a>
<a name="ln215">	fRightInset(0),</a>
<a name="ln216">	fTopInset(0),</a>
<a name="ln217">	fBottomInset(0),</a>
<a name="ln218">	fHSpacing(BControlLook::ComposeSpacing(hSpacing)),</a>
<a name="ln219">	fVSpacing(BControlLook::ComposeSpacing(vSpacing)),</a>
<a name="ln220">	fXTabsSorted(false),</a>
<a name="ln221">	fYTabsSorted(false),</a>
<a name="ln222">	fBadLayoutPolicy(new DefaultPolicy())</a>
<a name="ln223">{</a>
<a name="ln224">	_SetSolver(friendLayout ? friendLayout-&gt;fSolver : new SharedSolver());</a>
<a name="ln225"> </a>
<a name="ln226">	fSpecListener = new BALMLayoutSpecListener(this);</a>
<a name="ln227">	Solver()-&gt;AddListener(fSpecListener);</a>
<a name="ln228"> </a>
<a name="ln229">	fLeft = AddXTab();</a>
<a name="ln230">	fRight = AddXTab();</a>
<a name="ln231">	fTop = AddYTab();</a>
<a name="ln232">	fBottom = AddYTab();</a>
<a name="ln233"> </a>
<a name="ln234">	// the Left tab is always at x-position 0, and the Top tab is always at</a>
<a name="ln235">	// y-position 0</a>
<a name="ln236">	fLeft-&gt;SetRange(0, 0);</a>
<a name="ln237">	fTop-&gt;SetRange(0, 0);</a>
<a name="ln238"> </a>
<a name="ln239">	// cached layout values</a>
<a name="ln240">	// need to be invalidated whenever the layout specification is changed</a>
<a name="ln241">	fMinSize = kUnsetSize;</a>
<a name="ln242">	fMaxSize = kUnsetSize;</a>
<a name="ln243">	fPreferredSize = kUnsetSize;</a>
<a name="ln244">}</a>
<a name="ln245"> </a>
<a name="ln246"> </a>
<a name="ln247">BALMLayout::BALMLayout(BMessage* archive)</a>
<a name="ln248">	:</a>
<a name="ln249">	BAbstractLayout(BUnarchiver::PrepareArchive(archive)),</a>
<a name="ln250">	fSolver(NULL),</a>
<a name="ln251">	fLeft(NULL),</a>
<a name="ln252">	fRight(NULL),</a>
<a name="ln253">	fTop(NULL),</a>
<a name="ln254">	fBottom(NULL),</a>
<a name="ln255">	fMinSize(kUnsetSize),</a>
<a name="ln256">	fMaxSize(kUnsetSize),</a>
<a name="ln257">	fPreferredSize(kUnsetSize),</a>
<a name="ln258">	fXTabsSorted(false),</a>
<a name="ln259">	fYTabsSorted(false),</a>
<a name="ln260">	fBadLayoutPolicy(new DefaultPolicy())</a>
<a name="ln261">{</a>
<a name="ln262">	BUnarchiver unarchiver(archive);</a>
<a name="ln263"> </a>
<a name="ln264">	BRect insets;</a>
<a name="ln265">	status_t err = archive-&gt;FindRect(kInsetsField, &amp;insets);</a>
<a name="ln266">	if (err != B_OK) {</a>
<a name="ln267">		unarchiver.Finish(err);</a>
<a name="ln268">		return;</a>
<a name="ln269">	}</a>
<a name="ln270"> </a>
<a name="ln271">	fLeftInset = insets.left;</a>
<a name="ln272">	fRightInset = insets.right;</a>
<a name="ln273">	fTopInset = insets.top;</a>
<a name="ln274">	fBottomInset = insets.bottom;</a>
<a name="ln275"> </a>
<a name="ln276"> </a>
<a name="ln277">	BSize spacing;</a>
<a name="ln278">	err = archive-&gt;FindSize(kSpacingField, &amp;spacing);</a>
<a name="ln279">	if (err != B_OK) {</a>
<a name="ln280">		unarchiver.Finish(err);</a>
<a name="ln281">		return;</a>
<a name="ln282">	}</a>
<a name="ln283"> </a>
<a name="ln284">	fHSpacing = spacing.width;</a>
<a name="ln285">	fVSpacing = spacing.height;</a>
<a name="ln286"> </a>
<a name="ln287">	int32 tabCount = 0;</a>
<a name="ln288">	archive-&gt;GetInfo(kXTabsField, NULL, &amp;tabCount);</a>
<a name="ln289">	for (int32 i = 0; i &lt; tabCount &amp;&amp; err == B_OK; i++)</a>
<a name="ln290">		err = unarchiver.EnsureUnarchived(kXTabsField, i);</a>
<a name="ln291"> </a>
<a name="ln292">	archive-&gt;GetInfo(kYTabsField, NULL, &amp;tabCount);</a>
<a name="ln293">	for (int32 i = 0; i &lt; tabCount &amp;&amp; err == B_OK; i++)</a>
<a name="ln294">		err = unarchiver.EnsureUnarchived(kYTabsField, i);</a>
<a name="ln295"> </a>
<a name="ln296">	if (err == B_OK &amp;&amp; archive-&gt;GetInfo(kBadLayoutPolicyField, NULL) == B_OK)</a>
<a name="ln297">		err = unarchiver.EnsureUnarchived(kBadLayoutPolicyField);</a>
<a name="ln298"> </a>
<a name="ln299">	if (err == B_OK)</a>
<a name="ln300">		err = unarchiver.EnsureUnarchived(kSolverField);</a>
<a name="ln301"> </a>
<a name="ln302">	unarchiver.Finish(err);</a>
<a name="ln303"> </a>
<a name="ln304">	fSpecListener = new BALMLayoutSpecListener(this);</a>
<a name="ln305">	Solver()-&gt;AddListener(fSpecListener);</a>
<a name="ln306">}</a>
<a name="ln307"> </a>
<a name="ln308"> </a>
<a name="ln309">BALMLayout::~BALMLayout()</a>
<a name="ln310">{</a>
<a name="ln311">	Solver()-&gt;RemoveListener(fSpecListener);</a>
<a name="ln312">	delete fSpecListener;</a>
<a name="ln313"> </a>
<a name="ln314">	delete fRowColumnManager;</a>
<a name="ln315">	delete fBadLayoutPolicy;</a>
<a name="ln316"> </a>
<a name="ln317">	for (int32 i = 0; i &lt; fConstraints.CountItems(); i++)</a>
<a name="ln318">		Solver()-&gt;RemoveConstraint(fConstraints.ItemAt(i), true);</a>
<a name="ln319"> </a>
<a name="ln320">	if (fSolver) {</a>
<a name="ln321">		fSolver-&gt;LayoutLeaving(this);</a>
<a name="ln322">		fSolver-&gt;ReleaseReference();</a>
<a name="ln323">	}</a>
<a name="ln324">}</a>
<a name="ln325"> </a>
<a name="ln326"> </a>
<a name="ln327">/**</a>
<a name="ln328"> * Adds a new x-tab to the specification.</a>
<a name="ln329"> *</a>
<a name="ln330"> * @return the new x-tab</a>
<a name="ln331"> */</a>
<a name="ln332">BReference&lt;XTab&gt;</a>
<a name="ln333">BALMLayout::AddXTab()</a>
<a name="ln334">{</a>
<a name="ln335">	BReference&lt;XTab&gt; tab(new(std::nothrow) XTab(this), true);</a>
<a name="ln336">	if (!tab)</a>
<a name="ln337">		return NULL;</a>
<a name="ln338">	if (!Solver()-&gt;AddVariable(tab))</a>
<a name="ln339">		return NULL;</a>
<a name="ln340"> </a>
<a name="ln341">	fXTabList.AddItem(tab);</a>
<a name="ln342">	if (!tab-&gt;AddedToLayout(this)) {</a>
<a name="ln343">		fXTabList.RemoveItem(tab);</a>
<a name="ln344">		return NULL;</a>
<a name="ln345">	}</a>
<a name="ln346">	fXTabsSorted = false;</a>
<a name="ln347">	return tab;</a>
<a name="ln348">}</a>
<a name="ln349"> </a>
<a name="ln350"> </a>
<a name="ln351">void</a>
<a name="ln352">BALMLayout::AddXTabs(BReference&lt;XTab&gt;* tabs, uint32 count)</a>
<a name="ln353">{</a>
<a name="ln354">	for (uint32 i = 0; i &lt; count; i++)</a>
<a name="ln355">		tabs[i] = AddXTab();</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358"> </a>
<a name="ln359">void</a>
<a name="ln360">BALMLayout::AddYTabs(BReference&lt;YTab&gt;* tabs, uint32 count)</a>
<a name="ln361">{</a>
<a name="ln362">	for (uint32 i = 0; i &lt; count; i++)</a>
<a name="ln363">		tabs[i] = AddYTab();</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366"> </a>
<a name="ln367">/**</a>
<a name="ln368"> * Adds a new y-tab to the specification.</a>
<a name="ln369"> *</a>
<a name="ln370"> * @return the new y-tab</a>
<a name="ln371"> */</a>
<a name="ln372">BReference&lt;YTab&gt;</a>
<a name="ln373">BALMLayout::AddYTab()</a>
<a name="ln374">{</a>
<a name="ln375">	BReference&lt;YTab&gt; tab(new(std::nothrow) YTab(this), true);</a>
<a name="ln376">	if (tab.Get() == NULL)</a>
<a name="ln377">		return NULL;</a>
<a name="ln378">	if (!Solver()-&gt;AddVariable(tab))</a>
<a name="ln379">		return NULL;</a>
<a name="ln380"> </a>
<a name="ln381">	fYTabList.AddItem(tab);</a>
<a name="ln382">	if (!tab-&gt;AddedToLayout(this)) {</a>
<a name="ln383">		fYTabList.RemoveItem(tab);</a>
<a name="ln384">		return NULL;</a>
<a name="ln385">	}</a>
<a name="ln386">	fYTabsSorted = false;</a>
<a name="ln387">	return tab;</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390"> </a>
<a name="ln391">int32</a>
<a name="ln392">BALMLayout::CountXTabs() const</a>
<a name="ln393">{</a>
<a name="ln394">	return fXTabList.CountItems();</a>
<a name="ln395">}</a>
<a name="ln396"> </a>
<a name="ln397"> </a>
<a name="ln398">int32</a>
<a name="ln399">BALMLayout::CountYTabs() const</a>
<a name="ln400">{</a>
<a name="ln401">	return fYTabList.CountItems();</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404"> </a>
<a name="ln405">XTab*</a>
<a name="ln406">BALMLayout::XTabAt(int32 index, bool ordered)</a>
<a name="ln407">{</a>
<a name="ln408">	if (ordered &amp;&amp; !fXTabsSorted) {</a>
<a name="ln409">		Layout();</a>
<a name="ln410">		fXTabList.SortItems(CompareXTabFunc);</a>
<a name="ln411">		fXTabsSorted = true;</a>
<a name="ln412">	}</a>
<a name="ln413">	return fXTabList.ItemAt(index);</a>
<a name="ln414">}</a>
<a name="ln415"> </a>
<a name="ln416"> </a>
<a name="ln417">XTab*</a>
<a name="ln418">BALMLayout::XTabAt(int32 index) const</a>
<a name="ln419">{</a>
<a name="ln420">	return fXTabList.ItemAt(index);</a>
<a name="ln421">}</a>
<a name="ln422"> </a>
<a name="ln423"> </a>
<a name="ln424">YTab*</a>
<a name="ln425">BALMLayout::YTabAt(int32 index, bool ordered)</a>
<a name="ln426">{</a>
<a name="ln427">	if (ordered &amp;&amp; !fYTabsSorted) {</a>
<a name="ln428">		Layout();</a>
<a name="ln429">		fYTabList.SortItems(CompareYTabFunc);</a>
<a name="ln430">		fYTabsSorted = true;</a>
<a name="ln431">	}</a>
<a name="ln432">	return fYTabList.ItemAt(index);</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435"> </a>
<a name="ln436">YTab*</a>
<a name="ln437">BALMLayout::YTabAt(int32 index) const </a>
<a name="ln438">{</a>
<a name="ln439">	return fYTabList.ItemAt(index);</a>
<a name="ln440">}</a>
<a name="ln441"> </a>
<a name="ln442"> </a>
<a name="ln443">const XTabList</a>
<a name="ln444">BALMLayout::GetXTabs() const</a>
<a name="ln445">{</a>
<a name="ln446">	return fXTabList;</a>
<a name="ln447">}</a>
<a name="ln448"> </a>
<a name="ln449"> </a>
<a name="ln450">const YTabList</a>
<a name="ln451">BALMLayout::GetYTabs() const</a>
<a name="ln452">{</a>
<a name="ln453">	return fYTabList;</a>
<a name="ln454">}</a>
<a name="ln455"> </a>
<a name="ln456"> </a>
<a name="ln457">int32</a>
<a name="ln458">BALMLayout::IndexOf(XTab* tab, bool ordered)</a>
<a name="ln459">{</a>
<a name="ln460">	if (ordered &amp;&amp; !fXTabsSorted) {</a>
<a name="ln461">		Layout();</a>
<a name="ln462">		fXTabList.SortItems(CompareXTabFunc);</a>
<a name="ln463">		fXTabsSorted = true;</a>
<a name="ln464">	}</a>
<a name="ln465">	return fXTabList.IndexOf(tab);</a>
<a name="ln466">}</a>
<a name="ln467"> </a>
<a name="ln468"> </a>
<a name="ln469">int32</a>
<a name="ln470">BALMLayout::IndexOf(YTab* tab, bool ordered)</a>
<a name="ln471">{</a>
<a name="ln472">	if (ordered &amp;&amp; !fYTabsSorted) {</a>
<a name="ln473">		Layout();</a>
<a name="ln474">		fYTabList.SortItems(CompareYTabFunc);</a>
<a name="ln475">		fYTabsSorted = true;</a>
<a name="ln476">	}</a>
<a name="ln477">	return fYTabList.IndexOf(tab);</a>
<a name="ln478">}</a>
<a name="ln479"> </a>
<a name="ln480"> </a>
<a name="ln481">int32</a>
<a name="ln482">BALMLayout::CountConstraints() const</a>
<a name="ln483">{</a>
<a name="ln484">	return fConstraints.CountItems();</a>
<a name="ln485">}</a>
<a name="ln486"> </a>
<a name="ln487"> </a>
<a name="ln488">Constraint*</a>
<a name="ln489">BALMLayout::ConstraintAt(int32 index) const</a>
<a name="ln490">{</a>
<a name="ln491">	return fConstraints.ItemAt(index);</a>
<a name="ln492">}</a>
<a name="ln493"> </a>
<a name="ln494"> </a>
<a name="ln495">bool</a>
<a name="ln496">BALMLayout::AddConstraint(Constraint* constraint)</a>
<a name="ln497">{</a>
<a name="ln498">	fConstraints.AddItem(constraint);</a>
<a name="ln499">	return Solver()-&gt;AddConstraint(constraint);</a>
<a name="ln500">}</a>
<a name="ln501"> </a>
<a name="ln502"> </a>
<a name="ln503">bool</a>
<a name="ln504">BALMLayout::RemoveConstraint(Constraint* constraint,</a>
<a name="ln505">	bool deleteConstraint)</a>
<a name="ln506">{</a>
<a name="ln507">	if (!fConstraints.RemoveItem(constraint))</a>
<a name="ln508">		return false;</a>
<a name="ln509">	return Solver()-&gt;RemoveConstraint(constraint, deleteConstraint);</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512"> </a>
<a name="ln513">Constraint*</a>
<a name="ln514">BALMLayout::AddConstraint(double coeff1, Variable* var1, OperatorType op,</a>
<a name="ln515">	double rightSide, double penaltyNeg, double penaltyPos)</a>
<a name="ln516">{</a>
<a name="ln517">	Constraint* constraint = Solver()-&gt;AddConstraint(coeff1, var1, op,</a>
<a name="ln518">		rightSide, penaltyNeg, penaltyPos);</a>
<a name="ln519">	fConstraints.AddItem(constraint);</a>
<a name="ln520">	return constraint;</a>
<a name="ln521">}</a>
<a name="ln522"> </a>
<a name="ln523"> </a>
<a name="ln524">Constraint*</a>
<a name="ln525">BALMLayout::AddConstraint(double coeff1, Variable* var1, double coeff2,</a>
<a name="ln526">	Variable* var2,	OperatorType op, double rightSide, double penaltyNeg,</a>
<a name="ln527">	double penaltyPos)</a>
<a name="ln528">{</a>
<a name="ln529">	Constraint* constraint = Solver()-&gt;AddConstraint(coeff1, var1, coeff2, var2,</a>
<a name="ln530">		op, rightSide, penaltyNeg, penaltyPos);</a>
<a name="ln531">	fConstraints.AddItem(constraint);</a>
<a name="ln532">	return constraint;</a>
<a name="ln533">}</a>
<a name="ln534"> </a>
<a name="ln535">Constraint*</a>
<a name="ln536">BALMLayout::AddConstraint(double coeff1, Variable* var1, double coeff2,</a>
<a name="ln537">	Variable* var2, double coeff3, Variable* var3, OperatorType op,</a>
<a name="ln538">	double rightSide, double penaltyNeg, double penaltyPos)</a>
<a name="ln539">{</a>
<a name="ln540">	Constraint* constraint = Solver()-&gt;AddConstraint(coeff1, var1, coeff2, var2,</a>
<a name="ln541">		coeff3, var3, op, rightSide, penaltyNeg, penaltyPos);</a>
<a name="ln542">	fConstraints.AddItem(constraint);</a>
<a name="ln543">	return constraint;</a>
<a name="ln544">}</a>
<a name="ln545"> </a>
<a name="ln546"> </a>
<a name="ln547">Constraint*</a>
<a name="ln548">BALMLayout::AddConstraint(double coeff1, Variable* var1, double coeff2,</a>
<a name="ln549">	Variable* var2, double coeff3, Variable* var3, double coeff4,</a>
<a name="ln550">	Variable* var4, OperatorType op, double rightSide, double penaltyNeg,</a>
<a name="ln551">	double penaltyPos)</a>
<a name="ln552">{</a>
<a name="ln553">	Constraint* constraint = Solver()-&gt;AddConstraint(coeff1, var1, coeff2, var2,</a>
<a name="ln554">		coeff3, var3, coeff4, var4, op, rightSide, penaltyNeg, penaltyPos);</a>
<a name="ln555">	fConstraints.AddItem(constraint);</a>
<a name="ln556">	return constraint;</a>
<a name="ln557">}</a>
<a name="ln558"> </a>
<a name="ln559"> </a>
<a name="ln560">namespace {</a>
<a name="ln561"> </a>
<a name="ln562"> </a>
<a name="ln563">int</a>
<a name="ln564">CompareXTabFunc(const XTab* tab1, const XTab* tab2)</a>
<a name="ln565">{</a>
<a name="ln566">	if (tab1-&gt;Value() &lt; tab2-&gt;Value())</a>
<a name="ln567">		return -1;</a>
<a name="ln568">	else if (tab1-&gt;Value() == tab2-&gt;Value())</a>
<a name="ln569">		return 0;</a>
<a name="ln570">	return 1;</a>
<a name="ln571">}</a>
<a name="ln572"> </a>
<a name="ln573"> </a>
<a name="ln574">int</a>
<a name="ln575">CompareYTabFunc(const YTab* tab1, const YTab* tab2)</a>
<a name="ln576">{</a>
<a name="ln577">	if (tab1-&gt;Value() &lt; tab2-&gt;Value())</a>
<a name="ln578">		return -1;</a>
<a name="ln579">	else if (tab1-&gt;Value() == tab2-&gt;Value())</a>
<a name="ln580">		return 0;</a>
<a name="ln581">	return 1;</a>
<a name="ln582">}</a>
<a name="ln583"> </a>
<a name="ln584"> </a>
<a name="ln585">}; // end anonymous namespace</a>
<a name="ln586"> </a>
<a name="ln587"> </a>
<a name="ln588">/**</a>
<a name="ln589"> * Adds a new row to the specification that is glued to the given y-tabs.</a>
<a name="ln590"> *</a>
<a name="ln591"> * @param top</a>
<a name="ln592"> * @param bottom</a>
<a name="ln593"> * @return the new row</a>
<a name="ln594"> */</a>
<a name="ln595">Row*</a>
<a name="ln596">BALMLayout::AddRow(YTab* _top, YTab* _bottom)</a>
<a name="ln597">{</a>
<a name="ln598">	BReference&lt;YTab&gt; top = _top;</a>
<a name="ln599">	BReference&lt;YTab&gt; bottom = _bottom;</a>
<a name="ln600">	if (_top == NULL)</a>
<a name="ln601">		top = AddYTab();</a>
<a name="ln602">	if (_bottom == NULL)</a>
<a name="ln603">		bottom = AddYTab();</a>
<a name="ln604">	return new(std::nothrow) Row(Solver(), top, bottom);</a>
<a name="ln605">}</a>
<a name="ln606"> </a>
<a name="ln607"> </a>
<a name="ln608">/**</a>
<a name="ln609"> * Adds a new column to the specification that is glued to the given x-tabs.</a>
<a name="ln610"> *</a>
<a name="ln611"> * @param left</a>
<a name="ln612"> * @param right</a>
<a name="ln613"> * @return the new column</a>
<a name="ln614"> */</a>
<a name="ln615">Column*</a>
<a name="ln616">BALMLayout::AddColumn(XTab* _left, XTab* _right)</a>
<a name="ln617">{</a>
<a name="ln618">	BReference&lt;XTab&gt; left = _left;</a>
<a name="ln619">	BReference&lt;XTab&gt; right = _right;</a>
<a name="ln620">	if (_left == NULL)</a>
<a name="ln621">		left = AddXTab();</a>
<a name="ln622">	if (_right == NULL)</a>
<a name="ln623">		right = AddXTab();</a>
<a name="ln624">	return new(std::nothrow) Column(Solver(), left, right);</a>
<a name="ln625">}</a>
<a name="ln626"> </a>
<a name="ln627"> </a>
<a name="ln628">Area*</a>
<a name="ln629">BALMLayout::AreaFor(int32 id) const</a>
<a name="ln630">{</a>
<a name="ln631">	int32 areaCount = CountAreas();</a>
<a name="ln632">	for (int32 i = 0; i &lt; areaCount; i++) {</a>
<a name="ln633">		Area* area = AreaAt(i);</a>
<a name="ln634">		if (area-&gt;ID() == id)</a>
<a name="ln635">			return area;</a>
<a name="ln636">	}</a>
<a name="ln637">	return NULL;</a>
<a name="ln638">}</a>
<a name="ln639"> </a>
<a name="ln640"> </a>
<a name="ln641">/**</a>
<a name="ln642"> * Finds the area that contains the given control.</a>
<a name="ln643"> *</a>
<a name="ln644"> * @param control	the control to look for</a>
<a name="ln645"> * @return the area that contains the control</a>
<a name="ln646"> */</a>
<a name="ln647">Area*</a>
<a name="ln648">BALMLayout::AreaFor(const BView* control) const</a>
<a name="ln649">{</a>
<a name="ln650">	return AreaFor(ItemAt(IndexOfView(const_cast&lt;BView*&gt;(control))));</a>
<a name="ln651">}</a>
<a name="ln652"> </a>
<a name="ln653"> </a>
<a name="ln654">Area*</a>
<a name="ln655">BALMLayout::AreaFor(const BLayoutItem* item) const</a>
<a name="ln656">{</a>
<a name="ln657">	if (!item)</a>
<a name="ln658">		return NULL;</a>
<a name="ln659">	return static_cast&lt;Area*&gt;(item-&gt;LayoutData());</a>
<a name="ln660">}</a>
<a name="ln661"> </a>
<a name="ln662"> </a>
<a name="ln663">int32</a>
<a name="ln664">BALMLayout::CountAreas() const</a>
<a name="ln665">{</a>
<a name="ln666">	return CountItems();</a>
<a name="ln667">}</a>
<a name="ln668"> </a>
<a name="ln669"> </a>
<a name="ln670">Area*</a>
<a name="ln671">BALMLayout::AreaAt(int32 index) const</a>
<a name="ln672">{</a>
<a name="ln673">	return AreaFor(ItemAt(index));</a>
<a name="ln674">}</a>
<a name="ln675"> </a>
<a name="ln676"> </a>
<a name="ln677">XTab*</a>
<a name="ln678">BALMLayout::LeftOf(const BView* view) const</a>
<a name="ln679">{</a>
<a name="ln680">	Area* area = AreaFor(view);</a>
<a name="ln681">	if (!area)</a>
<a name="ln682">		return NULL;</a>
<a name="ln683">	return area-&gt;Left();</a>
<a name="ln684">}</a>
<a name="ln685"> </a>
<a name="ln686"> </a>
<a name="ln687">XTab*</a>
<a name="ln688">BALMLayout::LeftOf(const BLayoutItem* item) const</a>
<a name="ln689">{</a>
<a name="ln690">	Area* area = AreaFor(item);</a>
<a name="ln691">	if (!area)</a>
<a name="ln692">		return NULL;</a>
<a name="ln693">	return area-&gt;Left();</a>
<a name="ln694">}</a>
<a name="ln695"> </a>
<a name="ln696"> </a>
<a name="ln697">XTab*</a>
<a name="ln698">BALMLayout::RightOf(const BView* view) const</a>
<a name="ln699">{</a>
<a name="ln700">	Area* area = AreaFor(view);</a>
<a name="ln701">	if (!area)</a>
<a name="ln702">		return NULL;</a>
<a name="ln703">	return area-&gt;Right();</a>
<a name="ln704">}</a>
<a name="ln705"> </a>
<a name="ln706"> </a>
<a name="ln707">XTab*</a>
<a name="ln708">BALMLayout::RightOf(const BLayoutItem* item) const</a>
<a name="ln709">{</a>
<a name="ln710">	Area* area = AreaFor(item);</a>
<a name="ln711">	if (!area)</a>
<a name="ln712">		return NULL;</a>
<a name="ln713">	return area-&gt;Right();</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716"> </a>
<a name="ln717">YTab*</a>
<a name="ln718">BALMLayout::TopOf(const BView* view) const</a>
<a name="ln719">{</a>
<a name="ln720">	Area* area = AreaFor(view);</a>
<a name="ln721">	if (!area)</a>
<a name="ln722">		return NULL;</a>
<a name="ln723">	return area-&gt;Top();</a>
<a name="ln724">}</a>
<a name="ln725"> </a>
<a name="ln726"> </a>
<a name="ln727">YTab*</a>
<a name="ln728">BALMLayout::TopOf(const BLayoutItem* item) const</a>
<a name="ln729">{</a>
<a name="ln730">	Area* area = AreaFor(item);</a>
<a name="ln731">	if (!area)</a>
<a name="ln732">		return NULL;</a>
<a name="ln733">	return area-&gt;Top();</a>
<a name="ln734">}</a>
<a name="ln735"> </a>
<a name="ln736"> </a>
<a name="ln737">YTab*</a>
<a name="ln738">BALMLayout::BottomOf(const BView* view) const</a>
<a name="ln739">{</a>
<a name="ln740">	Area* area = AreaFor(view);</a>
<a name="ln741">	if (!area)</a>
<a name="ln742">		return NULL;</a>
<a name="ln743">	return area-&gt;Bottom();</a>
<a name="ln744">}</a>
<a name="ln745"> </a>
<a name="ln746"> </a>
<a name="ln747">YTab*</a>
<a name="ln748">BALMLayout::BottomOf(const BLayoutItem* item) const</a>
<a name="ln749">{</a>
<a name="ln750">	Area* area = AreaFor(item);</a>
<a name="ln751">	if (!area)</a>
<a name="ln752">		return NULL;</a>
<a name="ln753">	return area-&gt;Bottom();</a>
<a name="ln754">}</a>
<a name="ln755"> </a>
<a name="ln756"> </a>
<a name="ln757">BLayoutItem*</a>
<a name="ln758">BALMLayout::AddView(BView* child)</a>
<a name="ln759">{</a>
<a name="ln760">	return AddView(-1, child);</a>
<a name="ln761">}</a>
<a name="ln762"> </a>
<a name="ln763"> </a>
<a name="ln764">BLayoutItem*</a>
<a name="ln765">BALMLayout::AddView(int32 index, BView* child)</a>
<a name="ln766">{</a>
<a name="ln767">	return BAbstractLayout::AddView(index, child);</a>
<a name="ln768">}</a>
<a name="ln769"> </a>
<a name="ln770"> </a>
<a name="ln771">/**</a>
<a name="ln772"> * Adds a new area to the specification, automatically setting preferred size constraints.</a>
<a name="ln773"> *</a>
<a name="ln774"> * @param left			left border</a>
<a name="ln775"> * @param top			top border</a>
<a name="ln776"> * @param right		right border</a>
<a name="ln777"> * @param bottom		bottom border</a>
<a name="ln778"> * @param content		the control which is the area content</a>
<a name="ln779"> * @return the new area</a>
<a name="ln780"> */</a>
<a name="ln781">Area*</a>
<a name="ln782">BALMLayout::AddView(BView* view, XTab* left, YTab* top, XTab* right,</a>
<a name="ln783">	YTab* bottom)</a>
<a name="ln784">{</a>
<a name="ln785">	BLayoutItem* item = _LayoutItemToAdd(view);</a>
<a name="ln786">	Area* area = AddItem(item, left, top, right, bottom);</a>
<a name="ln787">	if (!area) {</a>
<a name="ln788">		if (item != view-&gt;GetLayout())</a>
<a name="ln789">			delete item;</a>
<a name="ln790">		return NULL;</a>
<a name="ln791">	}</a>
<a name="ln792">	return area;</a>
<a name="ln793">}</a>
<a name="ln794"> </a>
<a name="ln795"> </a>
<a name="ln796">/**</a>
<a name="ln797"> * Adds a new area to the specification, automatically setting preferred size constraints.</a>
<a name="ln798"> *</a>
<a name="ln799"> * @param row			the row that defines the top and bottom border</a>
<a name="ln800"> * @param column		the column that defines the left and right border</a>
<a name="ln801"> * @param content		the control which is the area content</a>
<a name="ln802"> * @return the new area</a>
<a name="ln803"> */</a>
<a name="ln804">Area*</a>
<a name="ln805">BALMLayout::AddView(BView* view, Row* row, Column* column)</a>
<a name="ln806">{</a>
<a name="ln807">	BLayoutItem* item = _LayoutItemToAdd(view);</a>
<a name="ln808">	Area* area = AddItem(item, row, column);</a>
<a name="ln809">	if (!area) {</a>
<a name="ln810">		if (item != view-&gt;GetLayout())</a>
<a name="ln811">			delete item;</a>
<a name="ln812">		return NULL;</a>
<a name="ln813">	}</a>
<a name="ln814">	return area;</a>
<a name="ln815">}</a>
<a name="ln816"> </a>
<a name="ln817"> </a>
<a name="ln818">bool</a>
<a name="ln819">BALMLayout::AddItem(BLayoutItem* item)</a>
<a name="ln820">{</a>
<a name="ln821">	return AddItem(-1, item);</a>
<a name="ln822">}</a>
<a name="ln823"> </a>
<a name="ln824"> </a>
<a name="ln825">bool</a>
<a name="ln826">BALMLayout::AddItem(int32 index, BLayoutItem* item)</a>
<a name="ln827">{</a>
<a name="ln828">	if (!item)</a>
<a name="ln829">		return false;</a>
<a name="ln830"> </a>
<a name="ln831">	// simply add the item at the upper right corner of the previous item</a>
<a name="ln832">	// TODO maybe find a more elegant solution</a>
<a name="ln833">	XTab* left = Left();</a>
<a name="ln834">	YTab* top = Top();</a>
<a name="ln835"> </a>
<a name="ln836">	// check range</a>
<a name="ln837">	if (index &lt; 0 || index &gt; CountItems())</a>
<a name="ln838">		index = CountItems();</a>
<a name="ln839"> </a>
<a name="ln840">	// for index = 0 we already have set the right tabs</a>
<a name="ln841">	if (index != 0) {</a>
<a name="ln842">		BLayoutItem* prevItem = ItemAt(index - 1);</a>
<a name="ln843">		Area* area = AreaFor(prevItem);</a>
<a name="ln844">		if (area) {</a>
<a name="ln845">			left = area-&gt;Right();</a>
<a name="ln846">			top = area-&gt;Top();</a>
<a name="ln847">		}</a>
<a name="ln848">	}</a>
<a name="ln849">	Area* area = AddItem(item, left, top);</a>
<a name="ln850">	return area ? true : false;</a>
<a name="ln851">}</a>
<a name="ln852"> </a>
<a name="ln853"> </a>
<a name="ln854">Area*</a>
<a name="ln855">BALMLayout::AddItem(BLayoutItem* item, XTab* _left, YTab* _top, XTab* _right,</a>
<a name="ln856">	YTab* _bottom)</a>
<a name="ln857">{</a>
<a name="ln858">	if ((_left &amp;&amp; !_left-&gt;IsSuitableFor(this))</a>
<a name="ln859">			|| (_top &amp;&amp; !_top-&gt;IsSuitableFor(this))</a>
<a name="ln860">			|| (_right &amp;&amp; !_right-&gt;IsSuitableFor(this))</a>
<a name="ln861">			|| (_bottom &amp;&amp; !_bottom-&gt;IsSuitableFor(this)))</a>
<a name="ln862">		debugger(&quot;Tab added to unfriendly layout!&quot;);</a>
<a name="ln863"> </a>
<a name="ln864">	BReference&lt;XTab&gt; right = _right;</a>
<a name="ln865">	if (right.Get() == NULL)</a>
<a name="ln866">		right = AddXTab();</a>
<a name="ln867">	BReference&lt;YTab&gt; bottom = _bottom;</a>
<a name="ln868">	if (bottom.Get() == NULL)</a>
<a name="ln869">		bottom = AddYTab();</a>
<a name="ln870">	BReference&lt;XTab&gt; left = _left;</a>
<a name="ln871">	if (left.Get() == NULL)</a>
<a name="ln872">		left = AddXTab();</a>
<a name="ln873">	BReference&lt;YTab&gt; top = _top;</a>
<a name="ln874">	if (top.Get() == NULL)</a>
<a name="ln875">		top = AddYTab();</a>
<a name="ln876"> </a>
<a name="ln877">	TabAddTransaction&lt;XTab&gt; leftTabAdd(this);</a>
<a name="ln878">	if (!leftTabAdd.AttempAdd(left))</a>
<a name="ln879">		return NULL;</a>
<a name="ln880"> </a>
<a name="ln881">	TabAddTransaction&lt;YTab&gt; topTabAdd(this);</a>
<a name="ln882">	if (!topTabAdd.AttempAdd(top))</a>
<a name="ln883">		return NULL;</a>
<a name="ln884"> </a>
<a name="ln885">	TabAddTransaction&lt;XTab&gt; rightTabAdd(this);</a>
<a name="ln886">	if (!rightTabAdd.AttempAdd(right))</a>
<a name="ln887">		return NULL;</a>
<a name="ln888"> </a>
<a name="ln889">	TabAddTransaction&lt;YTab&gt; bottomTabAdd(this);</a>
<a name="ln890">	if (!bottomTabAdd.AttempAdd(bottom))</a>
<a name="ln891">		return NULL;</a>
<a name="ln892"> </a>
<a name="ln893">	// Area is added in ItemAdded</a>
<a name="ln894">	if (!BAbstractLayout::AddItem(-1, item))</a>
<a name="ln895">		return NULL;</a>
<a name="ln896">	Area* area = AreaFor(item);</a>
<a name="ln897">	if (!area) {</a>
<a name="ln898">		RemoveItem(item);</a>
<a name="ln899">		return NULL;</a>
<a name="ln900">	}</a>
<a name="ln901"> </a>
<a name="ln902">	fSolver-&gt;Invalidate(true);</a>
<a name="ln903">	area-&gt;_Init(Solver(), left, top, right, bottom, fRowColumnManager);</a>
<a name="ln904">	fRowColumnManager-&gt;AddArea(area);</a>
<a name="ln905"> </a>
<a name="ln906">	leftTabAdd.Commit();</a>
<a name="ln907">	topTabAdd.Commit();</a>
<a name="ln908">	rightTabAdd.Commit();</a>
<a name="ln909">	bottomTabAdd.Commit();</a>
<a name="ln910">	return area;</a>
<a name="ln911">}</a>
<a name="ln912"> </a>
<a name="ln913"> </a>
<a name="ln914">Area*</a>
<a name="ln915">BALMLayout::AddItem(BLayoutItem* item, Row* row, Column* column)</a>
<a name="ln916">{</a>
<a name="ln917">	if (!BAbstractLayout::AddItem(-1, item))</a>
<a name="ln918">		return NULL;</a>
<a name="ln919">	Area* area = AreaFor(item);</a>
<a name="ln920">	if (!area)</a>
<a name="ln921">		return NULL;</a>
<a name="ln922"> </a>
<a name="ln923">	fSolver-&gt;Invalidate(true);</a>
<a name="ln924">	area-&gt;_Init(Solver(), row, column, fRowColumnManager);</a>
<a name="ln925"> </a>
<a name="ln926">	fRowColumnManager-&gt;AddArea(area);</a>
<a name="ln927">	return area;</a>
<a name="ln928">}</a>
<a name="ln929"> </a>
<a name="ln930"> </a>
<a name="ln931">/**</a>
<a name="ln932"> * Gets the left variable.</a>
<a name="ln933"> */</a>
<a name="ln934">XTab*</a>
<a name="ln935">BALMLayout::Left() const</a>
<a name="ln936">{</a>
<a name="ln937">	return fLeft;</a>
<a name="ln938">}</a>
<a name="ln939"> </a>
<a name="ln940"> </a>
<a name="ln941">/**</a>
<a name="ln942"> * Gets the right variable.</a>
<a name="ln943"> */</a>
<a name="ln944">XTab*</a>
<a name="ln945">BALMLayout::Right() const</a>
<a name="ln946">{</a>
<a name="ln947">	return fRight;</a>
<a name="ln948">}</a>
<a name="ln949"> </a>
<a name="ln950"> </a>
<a name="ln951">/**</a>
<a name="ln952"> * Gets the top variable.</a>
<a name="ln953"> */</a>
<a name="ln954">YTab*</a>
<a name="ln955">BALMLayout::Top() const</a>
<a name="ln956">{</a>
<a name="ln957">	return fTop;</a>
<a name="ln958">}</a>
<a name="ln959"> </a>
<a name="ln960"> </a>
<a name="ln961">/**</a>
<a name="ln962"> * Gets the bottom variable.</a>
<a name="ln963"> */</a>
<a name="ln964">YTab*</a>
<a name="ln965">BALMLayout::Bottom() const</a>
<a name="ln966">{</a>
<a name="ln967">	return fBottom;</a>
<a name="ln968">}</a>
<a name="ln969"> </a>
<a name="ln970"> </a>
<a name="ln971">void</a>
<a name="ln972">BALMLayout::SetBadLayoutPolicy(BadLayoutPolicy* policy)</a>
<a name="ln973">{</a>
<a name="ln974">	if (fBadLayoutPolicy != policy)</a>
<a name="ln975">		delete fBadLayoutPolicy;</a>
<a name="ln976">	if (policy == NULL)</a>
<a name="ln977">		policy = new DefaultPolicy();</a>
<a name="ln978">	fBadLayoutPolicy = policy;</a>
<a name="ln979">}</a>
<a name="ln980"> </a>
<a name="ln981"> </a>
<a name="ln982">struct BALMLayout::BadLayoutPolicy*</a>
<a name="ln983">BALMLayout::GetBadLayoutPolicy() const</a>
<a name="ln984">{</a>
<a name="ln985">	return fBadLayoutPolicy;</a>
<a name="ln986">}</a>
<a name="ln987"> </a>
<a name="ln988"> </a>
<a name="ln989">/**</a>
<a name="ln990"> * Gets minimum size.</a>
<a name="ln991"> */</a>
<a name="ln992">BSize</a>
<a name="ln993">BALMLayout::BaseMinSize()</a>
<a name="ln994">{</a>
<a name="ln995">	ResultType result = fSolver-&gt;ValidateMinSize();</a>
<a name="ln996">	if (result != kOptimal &amp;&amp; result != kUnbounded)</a>
<a name="ln997">		fBadLayoutPolicy-&gt;OnBadLayout(this, result, NULL);</a>
<a name="ln998">	return fMinSize;</a>
<a name="ln999">}</a>
<a name="ln1000"> </a>
<a name="ln1001"> </a>
<a name="ln1002">/**</a>
<a name="ln1003"> * Gets maximum size.</a>
<a name="ln1004"> */</a>
<a name="ln1005">BSize</a>
<a name="ln1006">BALMLayout::BaseMaxSize()</a>
<a name="ln1007">{</a>
<a name="ln1008">	ResultType result = fSolver-&gt;ValidateMaxSize();</a>
<a name="ln1009">	if (result != kOptimal &amp;&amp; result != kUnbounded)</a>
<a name="ln1010">		fBadLayoutPolicy-&gt;OnBadLayout(this, result, NULL);</a>
<a name="ln1011">	return fMaxSize;</a>
<a name="ln1012">}</a>
<a name="ln1013"> </a>
<a name="ln1014"> </a>
<a name="ln1015">/**</a>
<a name="ln1016"> * Gets preferred size.</a>
<a name="ln1017"> */</a>
<a name="ln1018">BSize</a>
<a name="ln1019">BALMLayout::BasePreferredSize()</a>
<a name="ln1020">{</a>
<a name="ln1021">	ResultType result = fSolver-&gt;ValidatePreferredSize();</a>
<a name="ln1022">	if (result != kOptimal)</a>
<a name="ln1023">		fBadLayoutPolicy-&gt;OnBadLayout(this, result, NULL);</a>
<a name="ln1024"> </a>
<a name="ln1025">	return fPreferredSize;</a>
<a name="ln1026">}</a>
<a name="ln1027"> </a>
<a name="ln1028"> </a>
<a name="ln1029">/**</a>
<a name="ln1030"> * Gets the alignment.</a>
<a name="ln1031"> */</a>
<a name="ln1032">BAlignment</a>
<a name="ln1033">BALMLayout::BaseAlignment()</a>
<a name="ln1034">{</a>
<a name="ln1035">	BAlignment alignment;</a>
<a name="ln1036">	alignment.SetHorizontal(B_ALIGN_HORIZONTAL_CENTER);</a>
<a name="ln1037">	alignment.SetVertical(B_ALIGN_VERTICAL_CENTER);</a>
<a name="ln1038">	return alignment;</a>
<a name="ln1039">}</a>
<a name="ln1040"> </a>
<a name="ln1041"> </a>
<a name="ln1042">status_t</a>
<a name="ln1043">BALMLayout::Archive(BMessage* into, bool deep) const</a>
<a name="ln1044">{</a>
<a name="ln1045">	BArchiver archiver(into);</a>
<a name="ln1046">	status_t err = BAbstractLayout::Archive(into, deep);</a>
<a name="ln1047">	if (err != B_OK)</a>
<a name="ln1048">		return archiver.Finish(err);</a>
<a name="ln1049"> </a>
<a name="ln1050">	BRect insets(fLeftInset, fTopInset, fRightInset, fBottomInset);</a>
<a name="ln1051">	err = into-&gt;AddRect(kInsetsField, insets);</a>
<a name="ln1052">	if (err != B_OK)</a>
<a name="ln1053">		return archiver.Finish(err);</a>
<a name="ln1054"> </a>
<a name="ln1055">	BSize spacing(fHSpacing, fVSpacing);</a>
<a name="ln1056">	err = into-&gt;AddSize(kSpacingField, spacing);</a>
<a name="ln1057">	if (err != B_OK)</a>
<a name="ln1058">		return archiver.Finish(err);</a>
<a name="ln1059"> </a>
<a name="ln1060">	if (deep) {</a>
<a name="ln1061">		for (int32 i = CountXTabs() - 1; i &gt;= 0 &amp;&amp; err == B_OK; i--)</a>
<a name="ln1062">			err = archiver.AddArchivable(kXTabsField, XTabAt(i));</a>
<a name="ln1063"> </a>
<a name="ln1064">		for (int32 i = CountYTabs() - 1; i &gt;= 0 &amp;&amp; err == B_OK; i--)</a>
<a name="ln1065">			err = archiver.AddArchivable(kYTabsField, YTabAt(i));</a>
<a name="ln1066"> </a>
<a name="ln1067">		err = archiver.AddArchivable(kBadLayoutPolicyField, fBadLayoutPolicy);</a>
<a name="ln1068">	}</a>
<a name="ln1069"> </a>
<a name="ln1070">	if (err == B_OK)</a>
<a name="ln1071">		err = archiver.AddArchivable(kSolverField, fSolver);</a>
<a name="ln1072"> </a>
<a name="ln1073">	if (err == B_OK)</a>
<a name="ln1074">		err = archiver.AddArchivable(kMyTabsField, fLeft);</a>
<a name="ln1075">	if (err == B_OK)</a>
<a name="ln1076">		err = archiver.AddArchivable(kMyTabsField, fTop);</a>
<a name="ln1077">	if (err == B_OK)</a>
<a name="ln1078">		err = archiver.AddArchivable(kMyTabsField, fRight);</a>
<a name="ln1079">	if (err == B_OK)</a>
<a name="ln1080">		err = archiver.AddArchivable(kMyTabsField, fBottom);</a>
<a name="ln1081"> </a>
<a name="ln1082">	return archiver.Finish(err);</a>
<a name="ln1083">}</a>
<a name="ln1084"> </a>
<a name="ln1085"> </a>
<a name="ln1086">BArchivable*</a>
<a name="ln1087">BALMLayout::Instantiate(BMessage* from)</a>
<a name="ln1088">{</a>
<a name="ln1089">	if (validate_instantiation(from, &quot;BALM::BALMLayout&quot;))</a>
<a name="ln1090">		return new BALMLayout(from);</a>
<a name="ln1091">	return NULL;</a>
<a name="ln1092">}</a>
<a name="ln1093"> </a>
<a name="ln1094"> </a>
<a name="ln1095">status_t</a>
<a name="ln1096">BALMLayout::ItemArchived(BMessage* into, BLayoutItem* item, int32 index) const</a>
<a name="ln1097">{</a>
<a name="ln1098">	BArchiver archiver(into);</a>
<a name="ln1099">	status_t err = BAbstractLayout::ItemArchived(into, item, index);</a>
<a name="ln1100">	if (err != B_OK)</a>
<a name="ln1101">		return err;</a>
<a name="ln1102"> </a>
<a name="ln1103">	Area* area = AreaFor(item);</a>
<a name="ln1104">	err = into-&gt;AddSize(kItemPenalties, area-&gt;fShrinkPenalties);</a>
<a name="ln1105">	if (err == B_OK)</a>
<a name="ln1106">		err = into-&gt;AddSize(kItemPenalties, area-&gt;fGrowPenalties);</a>
<a name="ln1107">	if (err == B_OK)</a>
<a name="ln1108">		err = into-&gt;AddSize(kItemInsets, area-&gt;fLeftTopInset);</a>
<a name="ln1109">	if (err == B_OK)</a>
<a name="ln1110">		err = into-&gt;AddSize(kItemInsets, area-&gt;fRightBottomInset);</a>
<a name="ln1111">	if (err == B_OK)</a>
<a name="ln1112">		err = into-&gt;AddDouble(kItemAspectRatio, area-&gt;fContentAspectRatio);</a>
<a name="ln1113"> </a>
<a name="ln1114">	err = archiver.AddArchivable(kTabsField, area-&gt;Left());</a>
<a name="ln1115">	if (err == B_OK)</a>
<a name="ln1116">		archiver.AddArchivable(kTabsField, area-&gt;Top());</a>
<a name="ln1117">	if (err == B_OK)</a>
<a name="ln1118">		archiver.AddArchivable(kTabsField, area-&gt;Right());</a>
<a name="ln1119">	if (err == B_OK)</a>
<a name="ln1120">		archiver.AddArchivable(kTabsField, area-&gt;Bottom());</a>
<a name="ln1121"> </a>
<a name="ln1122">	return err;</a>
<a name="ln1123">}</a>
<a name="ln1124"> </a>
<a name="ln1125"> </a>
<a name="ln1126">status_t</a>
<a name="ln1127">BALMLayout::ItemUnarchived(const BMessage* from, BLayoutItem* item,</a>
<a name="ln1128">	int32 index)</a>
<a name="ln1129">{</a>
<a name="ln1130">	BUnarchiver unarchiver(from);</a>
<a name="ln1131">	status_t err = BAbstractLayout::ItemUnarchived(from, item, index);</a>
<a name="ln1132">	if (err != B_OK)</a>
<a name="ln1133">		return err;</a>
<a name="ln1134"> </a>
<a name="ln1135">	Area* area = AreaFor(item);</a>
<a name="ln1136">	XTab* left;</a>
<a name="ln1137">	XTab* right;</a>
<a name="ln1138">	YTab* bottom;</a>
<a name="ln1139">	YTab* top;</a>
<a name="ln1140">	err = unarchiver.FindObject(kTabsField, index * 4, left);</a>
<a name="ln1141">	if (err == B_OK)</a>
<a name="ln1142">		err = unarchiver.FindObject(kTabsField, index * 4 + 1, top);</a>
<a name="ln1143">	if (err == B_OK)</a>
<a name="ln1144">		err = unarchiver.FindObject(kTabsField, index * 4 + 2, right);</a>
<a name="ln1145">	if (err == B_OK)</a>
<a name="ln1146">		err = unarchiver.FindObject(kTabsField, index * 4 + 3, bottom);</a>
<a name="ln1147">	</a>
<a name="ln1148">	if (err != B_OK)</a>
<a name="ln1149">		return err;</a>
<a name="ln1150"> </a>
<a name="ln1151">	area-&gt;_Init(Solver(), left, top, right, bottom, fRowColumnManager);</a>
<a name="ln1152">	fRowColumnManager-&gt;AddArea(area);</a>
<a name="ln1153"> </a>
<a name="ln1154">	err = from-&gt;FindSize(kItemPenalties, index * 2, &amp;area-&gt;fShrinkPenalties);</a>
<a name="ln1155">	if (err != B_OK)</a>
<a name="ln1156">		return err;</a>
<a name="ln1157"> </a>
<a name="ln1158">	err = from-&gt;FindSize(kItemPenalties, index * 2 + 1, &amp;area-&gt;fGrowPenalties);</a>
<a name="ln1159">	if (err != B_OK)</a>
<a name="ln1160">		return err;</a>
<a name="ln1161"> </a>
<a name="ln1162">	err = from-&gt;FindSize(kItemInsets, index * 2, &amp;area-&gt;fLeftTopInset);</a>
<a name="ln1163">	if (err != B_OK)</a>
<a name="ln1164">		return err;</a>
<a name="ln1165"> </a>
<a name="ln1166">	err = from-&gt;FindSize(kItemInsets, index * 2 + 1, &amp;area-&gt;fRightBottomInset);</a>
<a name="ln1167"> </a>
<a name="ln1168">	if (err == B_OK) {</a>
<a name="ln1169">		double contentAspectRatio;</a>
<a name="ln1170">		err = from-&gt;FindDouble(kItemAspectRatio, index, &amp;contentAspectRatio);</a>
<a name="ln1171">		if (err == B_OK)</a>
<a name="ln1172">			area-&gt;SetContentAspectRatio(contentAspectRatio);</a>
<a name="ln1173">	}</a>
<a name="ln1174"> </a>
<a name="ln1175">	return err;</a>
<a name="ln1176">}</a>
<a name="ln1177"> </a>
<a name="ln1178"> </a>
<a name="ln1179">status_t</a>
<a name="ln1180">BALMLayout::AllUnarchived(const BMessage* archive)</a>
<a name="ln1181">{</a>
<a name="ln1182">	BUnarchiver unarchiver(archive);</a>
<a name="ln1183"> </a>
<a name="ln1184">	SharedSolver* solver;</a>
<a name="ln1185">	status_t err = unarchiver.FindObject(kSolverField, solver);</a>
<a name="ln1186"> </a>
<a name="ln1187">	if (err != B_OK)</a>
<a name="ln1188">		return err;</a>
<a name="ln1189"> </a>
<a name="ln1190">	_SetSolver(solver);</a>
<a name="ln1191"> </a>
<a name="ln1192">	if (archive-&gt;GetInfo(kBadLayoutPolicyField, NULL) == B_OK) {</a>
<a name="ln1193">		BadLayoutPolicy* policy;</a>
<a name="ln1194">		err = unarchiver.FindObject(kBadLayoutPolicyField, policy);</a>
<a name="ln1195">		if (err == B_OK)</a>
<a name="ln1196">			SetBadLayoutPolicy(policy);</a>
<a name="ln1197">	}</a>
<a name="ln1198"> </a>
<a name="ln1199">	LinearSpec* spec = Solver();</a>
<a name="ln1200">	int32 tabCount = 0;</a>
<a name="ln1201">	archive-&gt;GetInfo(kXTabsField, NULL, &amp;tabCount);</a>
<a name="ln1202">	for (int32 i = 0; i &lt; tabCount &amp;&amp; err == B_OK; i++) {</a>
<a name="ln1203">		XTab* tab;</a>
<a name="ln1204">		err = unarchiver.FindObject(kXTabsField, i,</a>
<a name="ln1205">			BUnarchiver::B_DONT_ASSUME_OWNERSHIP, tab);</a>
<a name="ln1206">		spec-&gt;AddVariable(tab);</a>
<a name="ln1207">		TabAddTransaction&lt;XTab&gt; adder(this);</a>
<a name="ln1208">		if (adder.AttempAdd(tab))</a>
<a name="ln1209">			adder.Commit();</a>
<a name="ln1210">		else</a>
<a name="ln1211">			err = B_NO_MEMORY;</a>
<a name="ln1212">	}</a>
<a name="ln1213"> </a>
<a name="ln1214">	archive-&gt;GetInfo(kYTabsField, NULL, &amp;tabCount);</a>
<a name="ln1215">	for (int32 i = 0; i &lt; tabCount; i++) {</a>
<a name="ln1216">		YTab* tab;</a>
<a name="ln1217">		unarchiver.FindObject(kYTabsField, i,</a>
<a name="ln1218">			BUnarchiver::B_DONT_ASSUME_OWNERSHIP, tab);</a>
<a name="ln1219">		spec-&gt;AddVariable(tab);</a>
<a name="ln1220">		TabAddTransaction&lt;YTab&gt; adder(this);</a>
<a name="ln1221">		if (adder.AttempAdd(tab))</a>
<a name="ln1222">			adder.Commit();</a>
<a name="ln1223">		else</a>
<a name="ln1224">			err = B_NO_MEMORY;</a>
<a name="ln1225">	}</a>
<a name="ln1226"> </a>
<a name="ln1227"> </a>
<a name="ln1228">	if (err == B_OK) {</a>
<a name="ln1229">		XTab* leftTab = NULL;</a>
<a name="ln1230">		err = unarchiver.FindObject(kMyTabsField, 0, leftTab);</a>
<a name="ln1231">		fLeft = leftTab;</a>
<a name="ln1232">	}</a>
<a name="ln1233"> </a>
<a name="ln1234">	if (err == B_OK) {</a>
<a name="ln1235">		YTab* topTab = NULL;</a>
<a name="ln1236">		err = unarchiver.FindObject(kMyTabsField, 1, topTab);</a>
<a name="ln1237">		fTop = topTab;</a>
<a name="ln1238">	}</a>
<a name="ln1239"> </a>
<a name="ln1240">	if (err == B_OK) {</a>
<a name="ln1241">		XTab* rightTab = NULL;</a>
<a name="ln1242">		err = unarchiver.FindObject(kMyTabsField, 2, rightTab);</a>
<a name="ln1243">		fRight = rightTab;</a>
<a name="ln1244">	}</a>
<a name="ln1245"> </a>
<a name="ln1246">	if (err == B_OK) {</a>
<a name="ln1247">		YTab* bottomTab = NULL;</a>
<a name="ln1248">		err = unarchiver.FindObject(kMyTabsField, 3, bottomTab);</a>
<a name="ln1249">		fBottom = bottomTab;</a>
<a name="ln1250">	}</a>
<a name="ln1251"> </a>
<a name="ln1252">	if (err == B_OK) {</a>
<a name="ln1253">		fLeft-&gt;SetRange(0, 0);</a>
<a name="ln1254">		fTop-&gt;SetRange(0, 0);</a>
<a name="ln1255"> </a>
<a name="ln1256">   		err = BAbstractLayout::AllUnarchived(archive);</a>
<a name="ln1257">	}</a>
<a name="ln1258">	return err;</a>
<a name="ln1259">}</a>
<a name="ln1260"> </a>
<a name="ln1261"> </a>
<a name="ln1262">status_t</a>
<a name="ln1263">BALMLayout::AllArchived(BMessage* archive) const</a>
<a name="ln1264">{</a>
<a name="ln1265">	status_t err = BAbstractLayout::AllArchived(archive);</a>
<a name="ln1266"> </a>
<a name="ln1267">	return err;</a>
<a name="ln1268">}</a>
<a name="ln1269"> </a>
<a name="ln1270"> </a>
<a name="ln1271">/**</a>
<a name="ln1272"> * Invalidates the layout.</a>
<a name="ln1273"> * Resets minimum/maximum/preferred size.</a>
<a name="ln1274"> */</a>
<a name="ln1275">void</a>
<a name="ln1276">BALMLayout::LayoutInvalidated(bool children)</a>
<a name="ln1277">{</a>
<a name="ln1278">	fMinSize = kUnsetSize;</a>
<a name="ln1279">	fMaxSize = kUnsetSize;</a>
<a name="ln1280">	fPreferredSize = kUnsetSize;</a>
<a name="ln1281">	fXTabsSorted = false;</a>
<a name="ln1282">	fYTabsSorted = false;</a>
<a name="ln1283"> </a>
<a name="ln1284">	if (fSolver)</a>
<a name="ln1285">		fSolver-&gt;Invalidate(children);</a>
<a name="ln1286">}</a>
<a name="ln1287"> </a>
<a name="ln1288"> </a>
<a name="ln1289">bool</a>
<a name="ln1290">BALMLayout::ItemAdded(BLayoutItem* item, int32 atIndex)</a>
<a name="ln1291">{</a>
<a name="ln1292">	item-&gt;SetLayoutData(new(std::nothrow) Area(item));</a>
<a name="ln1293">	return item-&gt;LayoutData() != NULL;</a>
<a name="ln1294">}</a>
<a name="ln1295"> </a>
<a name="ln1296"> </a>
<a name="ln1297">void</a>
<a name="ln1298">BALMLayout::ItemRemoved(BLayoutItem* item, int32 fromIndex)</a>
<a name="ln1299">{</a>
<a name="ln1300">	if (Area* area = AreaFor(item)) {</a>
<a name="ln1301">		fRowColumnManager-&gt;RemoveArea(area);</a>
<a name="ln1302">		item-&gt;SetLayoutData(NULL);</a>
<a name="ln1303">		delete area;</a>
<a name="ln1304">	}</a>
<a name="ln1305">}</a>
<a name="ln1306"> </a>
<a name="ln1307"> </a>
<a name="ln1308">/**</a>
<a name="ln1309"> * Calculate and set the layout.</a>
<a name="ln1310"> * If no layout specification is given, a specification is reverse engineered automatically.</a>
<a name="ln1311"> */</a>
<a name="ln1312">void</a>
<a name="ln1313">BALMLayout::DoLayout()</a>
<a name="ln1314">{</a>
<a name="ln1315">	BLayoutContext* context = LayoutContext();</a>
<a name="ln1316">	ResultType result = fSolver-&gt;ValidateLayout(context);</a>
<a name="ln1317">	if (result != kOptimal</a>
<a name="ln1318">			&amp;&amp; !fBadLayoutPolicy-&gt;OnBadLayout(this, result, context)) {</a>
<a name="ln1319">		return;</a>
<a name="ln1320">	}</a>
<a name="ln1321"> </a>
<a name="ln1322">	// set the calculated positions and sizes for every area</a>
<a name="ln1323">	for (int32 i = 0; i &lt; CountItems(); i++)</a>
<a name="ln1324">		AreaFor(ItemAt(i))-&gt;_DoLayout(LayoutArea().LeftTop());</a>
<a name="ln1325"> </a>
<a name="ln1326">	fXTabsSorted = false;</a>
<a name="ln1327">	fYTabsSorted = false;</a>
<a name="ln1328">}</a>
<a name="ln1329"> </a>
<a name="ln1330"> </a>
<a name="ln1331">LinearSpec*</a>
<a name="ln1332">BALMLayout::Solver() const</a>
<a name="ln1333">{</a>
<a name="ln1334">	return fSolver-&gt;Solver();</a>
<a name="ln1335">}</a>
<a name="ln1336"> </a>
<a name="ln1337"> </a>
<a name="ln1338">ResultType</a>
<a name="ln1339">BALMLayout::ValidateLayout()</a>
<a name="ln1340">{</a>
<a name="ln1341">	// we explicitly recaluclate the layout so set the invalidate flag first</a>
<a name="ln1342">	fSolver-&gt;Invalidate(true);</a>
<a name="ln1343"> </a>
<a name="ln1344">	BLayoutContext* context = LayoutContext();</a>
<a name="ln1345">	return fSolver-&gt;ValidateLayout(context);</a>
<a name="ln1346">}</a>
<a name="ln1347"> </a>
<a name="ln1348"> </a>
<a name="ln1349">void</a>
<a name="ln1350">BALMLayout::SetInsets(float left, float top, float right,</a>
<a name="ln1351">	float bottom)</a>
<a name="ln1352">{</a>
<a name="ln1353">	fLeftInset = BControlLook::ComposeSpacing(left);</a>
<a name="ln1354">	fTopInset = BControlLook::ComposeSpacing(top);</a>
<a name="ln1355">	fRightInset = BControlLook::ComposeSpacing(right);</a>
<a name="ln1356">	fBottomInset = BControlLook::ComposeSpacing(bottom);</a>
<a name="ln1357"> </a>
<a name="ln1358">	InvalidateLayout();</a>
<a name="ln1359">}</a>
<a name="ln1360"> </a>
<a name="ln1361"> </a>
<a name="ln1362">void</a>
<a name="ln1363">BALMLayout::SetInsets(float horizontal, float vertical)</a>
<a name="ln1364">{</a>
<a name="ln1365">	fLeftInset = BControlLook::ComposeSpacing(horizontal);</a>
<a name="ln1366">	fRightInset = fLeftInset;</a>
<a name="ln1367"> </a>
<a name="ln1368">	fTopInset = BControlLook::ComposeSpacing(vertical);</a>
<a name="ln1369">	fBottomInset = fTopInset;</a>
<a name="ln1370"> </a>
<a name="ln1371">	InvalidateLayout();</a>
<a name="ln1372">}</a>
<a name="ln1373"> </a>
<a name="ln1374"> </a>
<a name="ln1375">void</a>
<a name="ln1376">BALMLayout::SetInsets(float insets)</a>
<a name="ln1377">{</a>
<a name="ln1378">	fLeftInset = BControlLook::ComposeSpacing(insets);</a>
<a name="ln1379">	fRightInset = fLeftInset;</a>
<a name="ln1380">	fTopInset = fLeftInset;</a>
<a name="ln1381">	fBottomInset = fLeftInset;</a>
<a name="ln1382"> </a>
<a name="ln1383">	InvalidateLayout();</a>
<a name="ln1384">}</a>
<a name="ln1385"> </a>
<a name="ln1386"> </a>
<a name="ln1387">void</a>
<a name="ln1388">BALMLayout::GetInsets(float* left, float* top, float* right,</a>
<a name="ln1389">	float* bottom) const</a>
<a name="ln1390">{</a>
<a name="ln1391">	if (left)</a>
<a name="ln1392">		*left = fLeftInset;</a>
<a name="ln1393">	if (top)</a>
<a name="ln1394">		*top = fTopInset;</a>
<a name="ln1395">	if (right)</a>
<a name="ln1396">		*right = fRightInset;</a>
<a name="ln1397">	if (bottom)</a>
<a name="ln1398">		*bottom = fBottomInset;</a>
<a name="ln1399">}</a>
<a name="ln1400"> </a>
<a name="ln1401"> </a>
<a name="ln1402">void</a>
<a name="ln1403">BALMLayout::SetSpacing(float hSpacing, float vSpacing)</a>
<a name="ln1404">{</a>
<a name="ln1405">	fHSpacing = BControlLook::ComposeSpacing(hSpacing);</a>
<a name="ln1406">	fVSpacing = BControlLook::ComposeSpacing(vSpacing);</a>
<a name="ln1407">}</a>
<a name="ln1408"> </a>
<a name="ln1409"> </a>
<a name="ln1410">void</a>
<a name="ln1411">BALMLayout::GetSpacing(float *_hSpacing, float *_vSpacing) const</a>
<a name="ln1412">{</a>
<a name="ln1413">	if (_hSpacing)</a>
<a name="ln1414">		*_hSpacing = fHSpacing;</a>
<a name="ln1415">	if (_vSpacing)</a>
<a name="ln1416">		*_vSpacing = fVSpacing;</a>
<a name="ln1417">}</a>
<a name="ln1418"> </a>
<a name="ln1419"> </a>
<a name="ln1420">float</a>
<a name="ln1421">BALMLayout::InsetForTab(XTab* tab) const</a>
<a name="ln1422">{</a>
<a name="ln1423">	if (tab == fLeft.Get())</a>
<a name="ln1424">		return fLeftInset;</a>
<a name="ln1425">	if (tab == fRight.Get())</a>
<a name="ln1426">		return fRightInset;</a>
<a name="ln1427">	return fHSpacing / 2;</a>
<a name="ln1428">}</a>
<a name="ln1429"> </a>
<a name="ln1430"> </a>
<a name="ln1431">float</a>
<a name="ln1432">BALMLayout::InsetForTab(YTab* tab) const</a>
<a name="ln1433">{</a>
<a name="ln1434">	if (tab == fTop.Get())</a>
<a name="ln1435">		return fTopInset;</a>
<a name="ln1436">	if (tab == fBottom.Get())</a>
<a name="ln1437">		return fBottomInset;</a>
<a name="ln1438">	return fVSpacing / 2;</a>
<a name="ln1439">}</a>
<a name="ln1440"> </a>
<a name="ln1441"> </a>
<a name="ln1442">void</a>
<a name="ln1443">BALMLayout::UpdateConstraints(BLayoutContext* context)</a>
<a name="ln1444">{</a>
<a name="ln1445">	for (int i = 0; i &lt; CountItems(); i++)</a>
<a name="ln1446">		AreaFor(ItemAt(i))-&gt;InvalidateSizeConstraints();</a>
<a name="ln1447">	fRowColumnManager-&gt;UpdateConstraints();</a>
<a name="ln1448">}</a>
<a name="ln1449"> </a>
<a name="ln1450"> </a>
<a name="ln1451">void BALMLayout::_RemoveSelfFromTab(XTab* tab) { tab-&gt;LayoutLeaving(this); }</a>
<a name="ln1452">void BALMLayout::_RemoveSelfFromTab(YTab* tab) { tab-&gt;LayoutLeaving(this); }</a>
<a name="ln1453"> </a>
<a name="ln1454">bool BALMLayout::_HasTabInLayout(XTab* tab) { return tab-&gt;IsInLayout(this); }</a>
<a name="ln1455">bool BALMLayout::_HasTabInLayout(YTab* tab) { return tab-&gt;IsInLayout(this); }</a>
<a name="ln1456"> </a>
<a name="ln1457">bool BALMLayout::_AddedTab(XTab* tab) { return tab-&gt;AddedToLayout(this); }</a>
<a name="ln1458">bool BALMLayout::_AddedTab(YTab* tab) { return tab-&gt;AddedToLayout(this); }</a>
<a name="ln1459"> </a>
<a name="ln1460"> </a>
<a name="ln1461">BLayoutItem*</a>
<a name="ln1462">BALMLayout::_LayoutItemToAdd(BView* view)</a>
<a name="ln1463">{</a>
<a name="ln1464">	if (view-&gt;GetLayout())</a>
<a name="ln1465">		return view-&gt;GetLayout();</a>
<a name="ln1466">	return new(std::nothrow) BViewLayoutItem(view);</a>
<a name="ln1467">}</a>
<a name="ln1468"> </a>
<a name="ln1469"> </a>
<a name="ln1470">void</a>
<a name="ln1471">BALMLayout::_SetSolver(SharedSolver* solver)</a>
<a name="ln1472">{</a>
<a name="ln1473">	fSolver = solver;</a>
<a name="ln1474">	fSolver-&gt;AcquireReference();</a>
<a name="ln1475">	fSolver-&gt;RegisterLayout(this);</a>
<a name="ln1476">	fRowColumnManager = new RowColumnManager(Solver());</a>
<a name="ln1477">}</a>
<a name="ln1478"> </a>
<a name="ln1479"> </a>
<a name="ln1480">status_t</a>
<a name="ln1481">BALMLayout::Perform(perform_code d, void* arg)</a>
<a name="ln1482">{</a>
<a name="ln1483">	return BAbstractLayout::Perform(d, arg);</a>
<a name="ln1484">}</a>
<a name="ln1485"> </a>
<a name="ln1486"> </a>
<a name="ln1487">void BALMLayout::_ReservedALMLayout1() {}</a>
<a name="ln1488">void BALMLayout::_ReservedALMLayout2() {}</a>
<a name="ln1489">void BALMLayout::_ReservedALMLayout3() {}</a>
<a name="ln1490">void BALMLayout::_ReservedALMLayout4() {}</a>
<a name="ln1491">void BALMLayout::_ReservedALMLayout5() {}</a>
<a name="ln1492">void BALMLayout::_ReservedALMLayout6() {}</a>
<a name="ln1493">void BALMLayout::_ReservedALMLayout7() {}</a>
<a name="ln1494">void BALMLayout::_ReservedALMLayout8() {}</a>
<a name="ln1495">void BALMLayout::_ReservedALMLayout9() {}</a>
<a name="ln1496">void BALMLayout::_ReservedALMLayout10() {}</a>
<a name="ln1497"> </a>

</code></pre>
<div class="balloon" rel="247"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fRowColumnManager, _reserved.</p></div>
<div class="balloon" rel="1151"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized pointer 'bottom' used. Consider checking the fifth actual argument of the '_Init' function.</p></div>
<div class="balloon" rel="1151"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized pointer 'top' used. Consider checking the third actual argument of the '_Init' function.</p></div>
<div class="balloon" rel="1151"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Potentially uninitialized pointer 'right' used. Consider checking the fourth actual argument of the '_Init' function.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
