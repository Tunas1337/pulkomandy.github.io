
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>media_server.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright (c) 2002, 2003 Marcus Overhagen &lt;Marcus@Overhagen.de&gt;</a>
<a name="ln3"> *</a>
<a name="ln4"> * Permission is hereby granted, free of charge, to any person obtaining</a>
<a name="ln5"> * a copy of this software and associated documentation files or portions</a>
<a name="ln6"> * thereof (the &quot;Software&quot;), to deal in the Software without restriction,</a>
<a name="ln7"> * including without limitation the rights to use, copy, modify, merge,</a>
<a name="ln8"> * publish, distribute, sublicense, and/or sell copies of the Software,</a>
<a name="ln9"> * and to permit persons to whom the Software is furnished to do so, subject</a>
<a name="ln10"> * to the following conditions:</a>
<a name="ln11"> *</a>
<a name="ln12"> *  * Redistributions of source code must retain the above copyright notice,</a>
<a name="ln13"> *    this list of conditions and the following disclaimer.</a>
<a name="ln14"> *</a>
<a name="ln15"> *  * Redistributions in binary form must reproduce the above copyright notice</a>
<a name="ln16"> *    in the  binary, as well as this list of conditions and the following</a>
<a name="ln17"> *    disclaimer in the documentation and/or other materials provided with</a>
<a name="ln18"> *    the distribution.</a>
<a name="ln19"> *</a>
<a name="ln20"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS</a>
<a name="ln21"> * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</a>
<a name="ln22"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL</a>
<a name="ln23"> * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</a>
<a name="ln24"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</a>
<a name="ln25"> * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN</a>
<a name="ln26"> * THE SOFTWARE.</a>
<a name="ln27"> *</a>
<a name="ln28"> */</a>
<a name="ln29"> </a>
<a name="ln30"> </a>
<a name="ln31">/* to comply with the license above, do not remove the following line */</a>
<a name="ln32">char __dont_remove_copyright_from_binary[] = &quot;Copyright (c) 2002, 2003 &quot;</a>
<a name="ln33">	&quot;Marcus Overhagen &lt;Marcus@Overhagen.de&gt;&quot;;</a>
<a name="ln34"> </a>
<a name="ln35"> </a>
<a name="ln36">#include &lt;stdio.h&gt;</a>
<a name="ln37">#include &lt;string.h&gt;</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;Alert.h&gt;</a>
<a name="ln40">#include &lt;Autolock.h&gt;</a>
<a name="ln41">#include &lt;Directory.h&gt;</a>
<a name="ln42">#include &lt;Roster.h&gt;</a>
<a name="ln43">#include &lt;MediaDefs.h&gt;</a>
<a name="ln44">#include &lt;MediaFormats.h&gt;</a>
<a name="ln45">#include &lt;Messenger.h&gt;</a>
<a name="ln46">#include &lt;Server.h&gt;</a>
<a name="ln47"> </a>
<a name="ln48">#include &lt;syscalls.h&gt;</a>
<a name="ln49"> </a>
<a name="ln50">#include &quot;AppManager.h&quot;</a>
<a name="ln51">#include &quot;BufferManager.h&quot;</a>
<a name="ln52">#include &quot;DataExchange.h&quot;</a>
<a name="ln53">#include &quot;MediaDebug.h&quot;</a>
<a name="ln54">#include &quot;MediaFilesManager.h&quot;</a>
<a name="ln55">#include &quot;MediaMisc.h&quot;</a>
<a name="ln56">#include &quot;NodeManager.h&quot;</a>
<a name="ln57">#include &quot;NotificationManager.h&quot;</a>
<a name="ln58">#include &quot;ServerInterface.h&quot;</a>
<a name="ln59">#include &quot;media_server.h&quot;</a>
<a name="ln60"> </a>
<a name="ln61"> </a>
<a name="ln62">AppManager* gAppManager;</a>
<a name="ln63">BufferManager* gBufferManager;</a>
<a name="ln64">MediaFilesManager* gMediaFilesManager;</a>
<a name="ln65">NodeManager* gNodeManager;</a>
<a name="ln66">NotificationManager* gNotificationManager;</a>
<a name="ln67"> </a>
<a name="ln68"> </a>
<a name="ln69">#define REPLY_TIMEOUT ((bigtime_t)500000)</a>
<a name="ln70"> </a>
<a name="ln71"> </a>
<a name="ln72">class ServerApp : public BServer {</a>
<a name="ln73">public:</a>
<a name="ln74">								ServerApp(status_t&amp; error);</a>
<a name="ln75">	virtual						~ServerApp();</a>
<a name="ln76"> </a>
<a name="ln77">protected:</a>
<a name="ln78">	virtual void				ArgvReceived(int32 argc, char** argv);</a>
<a name="ln79">	virtual void				ReadyToRun();</a>
<a name="ln80">	virtual bool				QuitRequested();</a>
<a name="ln81">	virtual void				MessageReceived(BMessage* message);</a>
<a name="ln82"> </a>
<a name="ln83">private:</a>
<a name="ln84">			void				_HandleMessage(int32 code, const void* data,</a>
<a name="ln85">									size_t size);</a>
<a name="ln86">			void				_LaunchAddOnServer();</a>
<a name="ln87">			void				_QuitAddOnServer();</a>
<a name="ln88"> </a>
<a name="ln89">private:</a>
<a name="ln90">			port_id				_ControlPort() const { return fControlPort; }</a>
<a name="ln91"> </a>
<a name="ln92">			static	int32		_ControlThread(void* arg);</a>
<a name="ln93"> </a>
<a name="ln94">			BLocker				fLocker;</a>
<a name="ln95">			port_id				fControlPort;</a>
<a name="ln96">			thread_id			fControlThread;</a>
<a name="ln97">};</a>
<a name="ln98"> </a>
<a name="ln99"> </a>
<a name="ln100">ServerApp::ServerApp(status_t&amp; error)</a>
<a name="ln101"> 	:</a>
<a name="ln102">	BServer(B_MEDIA_SERVER_SIGNATURE, true, &amp;error),</a>
<a name="ln103">	fLocker(&quot;media server locker&quot;)</a>
<a name="ln104">{</a>
<a name="ln105"> 	gNotificationManager = new NotificationManager;</a>
<a name="ln106"> 	gBufferManager = new BufferManager;</a>
<a name="ln107">	gAppManager = new AppManager;</a>
<a name="ln108">	gNodeManager = new NodeManager;</a>
<a name="ln109">	gMediaFilesManager = new MediaFilesManager;</a>
<a name="ln110"> </a>
<a name="ln111">	fControlPort = create_port(64, MEDIA_SERVER_PORT_NAME);</a>
<a name="ln112">	fControlThread = spawn_thread(_ControlThread, &quot;media_server control&quot;, 105,</a>
<a name="ln113">		this);</a>
<a name="ln114">	resume_thread(fControlThread);</a>
<a name="ln115"> </a>
<a name="ln116">	if (be_roster-&gt;StartWatching(BMessenger(this, this),</a>
<a name="ln117">			B_REQUEST_QUIT) != B_OK) {</a>
<a name="ln118">		TRACE(&quot;ServerApp: Can't find the registrar.&quot;);</a>
<a name="ln119">	}</a>
<a name="ln120">}</a>
<a name="ln121"> </a>
<a name="ln122"> </a>
<a name="ln123">ServerApp::~ServerApp()</a>
<a name="ln124">{</a>
<a name="ln125">	TRACE(&quot;ServerApp::~ServerApp()\n&quot;);</a>
<a name="ln126"> </a>
<a name="ln127">	delete_port(fControlPort);</a>
<a name="ln128">	wait_for_thread(fControlThread, NULL);</a>
<a name="ln129"> </a>
<a name="ln130">	if (be_roster-&gt;StopWatching(BMessenger(this, this)) != B_OK)</a>
<a name="ln131">		TRACE(&quot;ServerApp: Can't unregister roster notifications.&quot;);</a>
<a name="ln132"> </a>
<a name="ln133">	delete gNotificationManager;</a>
<a name="ln134">	delete gBufferManager;</a>
<a name="ln135">	delete gAppManager;</a>
<a name="ln136">	delete gNodeManager;</a>
<a name="ln137">	delete gMediaFilesManager;</a>
<a name="ln138">}</a>
<a name="ln139"> </a>
<a name="ln140"> </a>
<a name="ln141">void</a>
<a name="ln142">ServerApp::ReadyToRun()</a>
<a name="ln143">{</a>
<a name="ln144">	gNodeManager-&gt;LoadState();</a>
<a name="ln145"> </a>
<a name="ln146">	// make sure any previous media_addon_server is gone</a>
<a name="ln147">	_QuitAddOnServer();</a>
<a name="ln148">	// and start a new one</a>
<a name="ln149">	_LaunchAddOnServer();</a>
<a name="ln150"> </a>
<a name="ln151">}</a>
<a name="ln152"> </a>
<a name="ln153"> </a>
<a name="ln154">bool</a>
<a name="ln155">ServerApp::QuitRequested()</a>
<a name="ln156">{</a>
<a name="ln157">	TRACE(&quot;ServerApp::QuitRequested()\n&quot;);</a>
<a name="ln158">	gMediaFilesManager-&gt;SaveState();</a>
<a name="ln159">	gNodeManager-&gt;SaveState();</a>
<a name="ln160"> </a>
<a name="ln161">	_QuitAddOnServer();</a>
<a name="ln162"> </a>
<a name="ln163">	return true;</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166"> </a>
<a name="ln167">void</a>
<a name="ln168">ServerApp::ArgvReceived(int32 argc, char **argv)</a>
<a name="ln169">{</a>
<a name="ln170">	for (int arg = 1; arg &lt; argc; arg++) {</a>
<a name="ln171">		if (strstr(argv[arg], &quot;dump&quot;) != NULL) {</a>
<a name="ln172">			gAppManager-&gt;Dump();</a>
<a name="ln173">			gNodeManager-&gt;Dump();</a>
<a name="ln174">			gBufferManager-&gt;Dump();</a>
<a name="ln175">			gNotificationManager-&gt;Dump();</a>
<a name="ln176">			gMediaFilesManager-&gt;Dump();</a>
<a name="ln177">		}</a>
<a name="ln178">		if (strstr(argv[arg], &quot;buffer&quot;) != NULL)</a>
<a name="ln179">			gBufferManager-&gt;Dump();</a>
<a name="ln180">		if (strstr(argv[arg], &quot;node&quot;) != NULL)</a>
<a name="ln181">			gNodeManager-&gt;Dump();</a>
<a name="ln182">		if (strstr(argv[arg], &quot;files&quot;) != NULL)</a>
<a name="ln183">			gMediaFilesManager-&gt;Dump();</a>
<a name="ln184">		if (strstr(argv[arg], &quot;quit&quot;) != NULL)</a>
<a name="ln185">			PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln186">	}</a>
<a name="ln187">}</a>
<a name="ln188"> </a>
<a name="ln189"> </a>
<a name="ln190">void</a>
<a name="ln191">ServerApp::_LaunchAddOnServer()</a>
<a name="ln192">{</a>
<a name="ln193">	// Try to launch media_addon_server by mime signature.</a>
<a name="ln194">	// If it fails (for example on the Live CD, where the executable</a>
<a name="ln195">	// hasn't yet been mimesetted), try from this application's</a>
<a name="ln196">	// directory</a>
<a name="ln197">	status_t err = be_roster-&gt;Launch(B_MEDIA_ADDON_SERVER_SIGNATURE);</a>
<a name="ln198">	if (err == B_OK)</a>
<a name="ln199">		return;</a>
<a name="ln200"> </a>
<a name="ln201">	app_info info;</a>
<a name="ln202">	BEntry entry;</a>
<a name="ln203">	BDirectory dir;</a>
<a name="ln204">	entry_ref ref;</a>
<a name="ln205"> </a>
<a name="ln206">	err = GetAppInfo(&amp;info);</a>
<a name="ln207">	err |= entry.SetTo(&amp;info.ref);</a>
<a name="ln208">	err |= entry.GetParent(&amp;entry);</a>
<a name="ln209">	err |= dir.SetTo(&amp;entry);</a>
<a name="ln210">	err |= entry.SetTo(&amp;dir, &quot;media_addon_server&quot;);</a>
<a name="ln211">	err |= entry.GetRef(&amp;ref);</a>
<a name="ln212"> </a>
<a name="ln213">	if (err == B_OK)</a>
<a name="ln214">		be_roster-&gt;Launch(&amp;ref);</a>
<a name="ln215">	if (err == B_OK)</a>
<a name="ln216">		return;</a>
<a name="ln217"> </a>
<a name="ln218">	BAlert* alert = new BAlert(&quot;media_server&quot;, &quot;Launching media_addon_server &quot;</a>
<a name="ln219">		&quot;failed.\n\nmedia_server will terminate&quot;, &quot;OK&quot;);</a>
<a name="ln220">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln221">		alert-&gt;Go();</a>
<a name="ln222">	fprintf(stderr, &quot;Launching media_addon_server (%s) failed: %s\n&quot;,</a>
<a name="ln223">		B_MEDIA_ADDON_SERVER_SIGNATURE, strerror(err));</a>
<a name="ln224">	exit(1);</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227"> </a>
<a name="ln228">void</a>
<a name="ln229">ServerApp::_QuitAddOnServer()</a>
<a name="ln230">{</a>
<a name="ln231">	// nothing to do if it's already terminated</a>
<a name="ln232">	if (!be_roster-&gt;IsRunning(B_MEDIA_ADDON_SERVER_SIGNATURE))</a>
<a name="ln233">		return;</a>
<a name="ln234"> </a>
<a name="ln235">	// send a quit request to the media_addon_server</a>
<a name="ln236">	BMessenger msger(B_MEDIA_ADDON_SERVER_SIGNATURE);</a>
<a name="ln237">	if (!msger.IsValid()) {</a>
<a name="ln238">		ERROR(&quot;Trouble terminating media_addon_server. Messenger invalid\n&quot;);</a>
<a name="ln239">	} else {</a>
<a name="ln240">		BMessage msg(B_QUIT_REQUESTED);</a>
<a name="ln241">		status_t err = msger.SendMessage(&amp;msg, (BHandler *)NULL, 2000000);</a>
<a name="ln242">			// 2 sec timeout</a>
<a name="ln243">		if (err != B_OK) {</a>
<a name="ln244">			ERROR(&quot;Trouble terminating media_addon_server (2): %s\n&quot;,</a>
<a name="ln245">				strerror(err));</a>
<a name="ln246">		}</a>
<a name="ln247">	}</a>
<a name="ln248"> </a>
<a name="ln249">	// wait 5 seconds for it to terminate</a>
<a name="ln250">	for (int i = 0; i &lt; 50; i++) {</a>
<a name="ln251">		if (!be_roster-&gt;IsRunning(B_MEDIA_ADDON_SERVER_SIGNATURE))</a>
<a name="ln252">			return;</a>
<a name="ln253">		snooze(100000); // 100 ms</a>
<a name="ln254">	}</a>
<a name="ln255"> </a>
<a name="ln256">	// try to kill it (or many of them), up to 10 seconds</a>
<a name="ln257">	for (int i = 0; i &lt; 50; i++) {</a>
<a name="ln258">		team_id id = be_roster-&gt;TeamFor(B_MEDIA_ADDON_SERVER_SIGNATURE);</a>
<a name="ln259">		if (id &lt; 0)</a>
<a name="ln260">			break;</a>
<a name="ln261">		kill_team(id);</a>
<a name="ln262">		snooze(200000); // 200 ms</a>
<a name="ln263">	}</a>
<a name="ln264"> </a>
<a name="ln265">	if (be_roster-&gt;IsRunning(B_MEDIA_ADDON_SERVER_SIGNATURE)) {</a>
<a name="ln266">		ERROR(&quot;Trouble terminating media_addon_server, it's still running\n&quot;);</a>
<a name="ln267">	}</a>
<a name="ln268">}</a>
<a name="ln269"> </a>
<a name="ln270"> </a>
<a name="ln271">void</a>
<a name="ln272">ServerApp::_HandleMessage(int32 code, const void* data, size_t size)</a>
<a name="ln273">{</a>
<a name="ln274">	TRACE(&quot;ServerApp::HandleMessage %#&quot; B_PRIx32 &quot; enter\n&quot;, code);</a>
<a name="ln275">	switch (code) {</a>
<a name="ln276">		case SERVER_CHANGE_FLAVOR_INSTANCES_COUNT:</a>
<a name="ln277">		{</a>
<a name="ln278">			const server_change_flavor_instances_count_request&amp; request</a>
<a name="ln279">				= *static_cast&lt;</a>
<a name="ln280">					const server_change_flavor_instances_count_request*&gt;(data);</a>
<a name="ln281">			server_change_flavor_instances_count_reply reply;</a>
<a name="ln282">			status_t status = B_BAD_VALUE;</a>
<a name="ln283"> </a>
<a name="ln284">			if (request.delta == 1) {</a>
<a name="ln285">				status = gNodeManager-&gt;IncrementFlavorInstancesCount(</a>
<a name="ln286">					request.add_on_id, request.flavor_id, request.team);</a>
<a name="ln287">			} else if (request.delta == -1) {</a>
<a name="ln288">				status = gNodeManager-&gt;DecrementFlavorInstancesCount(</a>
<a name="ln289">					request.add_on_id, request.flavor_id, request.team);</a>
<a name="ln290">			}</a>
<a name="ln291">			request.SendReply(status, &amp;reply, sizeof(reply));</a>
<a name="ln292">			break;</a>
<a name="ln293">		}</a>
<a name="ln294"> </a>
<a name="ln295">		case SERVER_RESCAN_DEFAULTS:</a>
<a name="ln296">		{</a>
<a name="ln297">			gNodeManager-&gt;RescanDefaultNodes();</a>
<a name="ln298">			break;</a>
<a name="ln299">		}</a>
<a name="ln300"> </a>
<a name="ln301">		case SERVER_REGISTER_APP:</a>
<a name="ln302">		{</a>
<a name="ln303">			const server_register_app_request&amp; request = *static_cast&lt;</a>
<a name="ln304">				const server_register_app_request*&gt;(data);</a>
<a name="ln305">			server_register_app_reply reply;</a>
<a name="ln306"> </a>
<a name="ln307">			status_t status = gAppManager-&gt;RegisterTeam(request.team,</a>
<a name="ln308">				request.messenger);</a>
<a name="ln309">			request.SendReply(status, &amp;reply, sizeof(reply));</a>
<a name="ln310">			break;</a>
<a name="ln311">		}</a>
<a name="ln312"> </a>
<a name="ln313">		case SERVER_UNREGISTER_APP:</a>
<a name="ln314">		{</a>
<a name="ln315">			const server_unregister_app_request&amp; request = *static_cast&lt;</a>
<a name="ln316">				const server_unregister_app_request*&gt;(data);</a>
<a name="ln317">			server_unregister_app_reply reply;</a>
<a name="ln318"> </a>
<a name="ln319">			status_t status = gAppManager-&gt;UnregisterTeam(request.team);</a>
<a name="ln320">			request.SendReply(status, &amp;reply, sizeof(reply));</a>
<a name="ln321">			break;</a>
<a name="ln322">		}</a>
<a name="ln323"> </a>
<a name="ln324">		case SERVER_GET_ADD_ON_REF:</a>
<a name="ln325">		{</a>
<a name="ln326">			const server_get_add_on_ref_request&amp; request = *static_cast&lt;</a>
<a name="ln327">				const server_get_add_on_ref_request*&gt;(data);</a>
<a name="ln328">			server_get_add_on_ref_reply reply;</a>
<a name="ln329"> </a>
<a name="ln330">			entry_ref ref;</a>
<a name="ln331">			reply.result = gNodeManager-&gt;GetAddOnRef(request.add_on_id, &amp;ref);</a>
<a name="ln332">			reply.ref = ref;</a>
<a name="ln333"> </a>
<a name="ln334">			request.SendReply(reply.result, &amp;reply, sizeof(reply));</a>
<a name="ln335">			break;</a>
<a name="ln336">		}</a>
<a name="ln337"> </a>
<a name="ln338">		case SERVER_NODE_ID_FOR:</a>
<a name="ln339">		{</a>
<a name="ln340">			const server_node_id_for_request&amp; request</a>
<a name="ln341">				= *static_cast&lt;const server_node_id_for_request*&gt;(data);</a>
<a name="ln342">			server_node_id_for_reply reply;</a>
<a name="ln343"> </a>
<a name="ln344">			status_t status = gNodeManager-&gt;FindNodeID(request.port,</a>
<a name="ln345">				&amp;reply.node_id);</a>
<a name="ln346">			request.SendReply(status, &amp;reply, sizeof(reply));</a>
<a name="ln347">			break;</a>
<a name="ln348">		}</a>
<a name="ln349"> </a>
<a name="ln350">		case SERVER_GET_LIVE_NODE_INFO:</a>
<a name="ln351">		{</a>
<a name="ln352">			const server_get_live_node_info_request&amp; request = *static_cast&lt;</a>
<a name="ln353">				const server_get_live_node_info_request*&gt;(data);</a>
<a name="ln354">			server_get_live_node_info_reply reply;</a>
<a name="ln355"> </a>
<a name="ln356">			status_t status = gNodeManager-&gt;GetLiveNodeInfo(request.node,</a>
<a name="ln357">				&amp;reply.live_info);</a>
<a name="ln358">			request.SendReply(status, &amp;reply, sizeof(reply));</a>
<a name="ln359">			break;</a>
<a name="ln360">		}</a>
<a name="ln361"> </a>
<a name="ln362">		case SERVER_GET_LIVE_NODES:</a>
<a name="ln363">		{</a>
<a name="ln364">			const server_get_live_nodes_request&amp; request</a>
<a name="ln365">				= *static_cast&lt;const server_get_live_nodes_request*&gt;(data);</a>
<a name="ln366">			server_get_live_nodes_reply reply;</a>
<a name="ln367">			LiveNodeList nodes;</a>
<a name="ln368"> </a>
<a name="ln369">			status_t status = gNodeManager-&gt;GetLiveNodes(nodes,</a>
<a name="ln370">				request.max_count,</a>
<a name="ln371">				request.has_input ? &amp;request.input_format : NULL,</a>
<a name="ln372">				request.has_output ? &amp;request.output_format : NULL,</a>
<a name="ln373">				request.has_name ? request.name : NULL, request.require_kinds);</a>
<a name="ln374"> </a>
<a name="ln375">			reply.count = nodes.size();</a>
<a name="ln376">			reply.area = -1;</a>
<a name="ln377"> </a>
<a name="ln378">			live_node_info* infos = reply.live_info;</a>
<a name="ln379">			area_id area = -1;</a>
<a name="ln380"> </a>
<a name="ln381">			if (reply.count &gt; MAX_LIVE_INFO) {</a>
<a name="ln382">				// We create an area here, and transfer it to the client</a>
<a name="ln383">				size_t size = (reply.count * sizeof(live_node_info)</a>
<a name="ln384">					+ B_PAGE_SIZE - 1) &amp; ~(B_PAGE_SIZE - 1);</a>
<a name="ln385"> </a>
<a name="ln386">				area = create_area(&quot;get live nodes&quot;, (void**)&amp;infos,</a>
<a name="ln387">					B_ANY_ADDRESS, size, B_NO_LOCK, B_READ_AREA | B_WRITE_AREA);</a>
<a name="ln388">				if (area &lt; 0) {</a>
<a name="ln389">					reply.area = area;</a>
<a name="ln390">					reply.count = 0;</a>
<a name="ln391">				}</a>
<a name="ln392">			}</a>
<a name="ln393"> </a>
<a name="ln394">			for (int32 index = 0; index &lt; reply.count; index++)</a>
<a name="ln395">				infos[index] = nodes[index];</a>
<a name="ln396"> </a>
<a name="ln397">			if (area &gt;= 0) {</a>
<a name="ln398">				// transfer the area to the target team</a>
<a name="ln399">				reply.area = _kern_transfer_area(area, &amp;reply.address,</a>
<a name="ln400">					B_ANY_ADDRESS, request.team);</a>
<a name="ln401">				if (reply.area &lt; 0) {</a>
<a name="ln402">					delete_area(area);</a>
<a name="ln403">					reply.count = 0;</a>
<a name="ln404">				}</a>
<a name="ln405">			}</a>
<a name="ln406"> </a>
<a name="ln407">			status = request.SendReply(status, &amp;reply, sizeof(reply));</a>
<a name="ln408">			if (status != B_OK &amp;&amp; reply.area &gt;= 0) {</a>
<a name="ln409">				// if we couldn't send the message, delete the area</a>
<a name="ln410">				delete_area(reply.area);</a>
<a name="ln411">			}</a>
<a name="ln412">			break;</a>
<a name="ln413">		}</a>
<a name="ln414"> </a>
<a name="ln415">		case SERVER_GET_NODE_FOR:</a>
<a name="ln416">		{</a>
<a name="ln417">			const server_get_node_for_request&amp; request</a>
<a name="ln418">				= *static_cast&lt;const server_get_node_for_request*&gt;(data);</a>
<a name="ln419">			server_get_node_for_reply reply;</a>
<a name="ln420"> </a>
<a name="ln421">			status_t status = gNodeManager-&gt;GetCloneForID(request.node_id,</a>
<a name="ln422">				request.team, &amp;reply.clone);</a>
<a name="ln423">			request.SendReply(status, &amp;reply, sizeof(reply));</a>
<a name="ln424">			break;</a>
<a name="ln425">		}</a>
<a name="ln426"> </a>
<a name="ln427">		case SERVER_RELEASE_NODE:</a>
<a name="ln428">		{</a>
<a name="ln429">			const server_release_node_request&amp; request</a>
<a name="ln430">				= *static_cast&lt;const server_release_node_request*&gt;(data);</a>
<a name="ln431">			server_release_node_reply reply;</a>
<a name="ln432"> </a>
<a name="ln433">			status_t status = gNodeManager-&gt;ReleaseNode(request.node,</a>
<a name="ln434">				request.team);</a>
<a name="ln435">			request.SendReply(status, &amp;reply, sizeof(reply));</a>
<a name="ln436">			break;</a>
<a name="ln437">		}</a>
<a name="ln438">		</a>
<a name="ln439">		case SERVER_RELEASE_NODE_ALL:</a>
<a name="ln440">		{</a>
<a name="ln441">			const server_release_node_request&amp; request</a>
<a name="ln442">				= *static_cast&lt;const server_release_node_request*&gt;(data);</a>
<a name="ln443">			server_release_node_reply reply;</a>
<a name="ln444"> </a>
<a name="ln445">			status_t status = gNodeManager-&gt;ReleaseNodeAll(request.node.node);</a>
<a name="ln446">			request.SendReply(status, &amp;reply, sizeof(reply));</a>
<a name="ln447">			break;</a>
<a name="ln448">		}</a>
<a name="ln449"> </a>
<a name="ln450">		case SERVER_REGISTER_NODE:</a>
<a name="ln451">		{</a>
<a name="ln452">			const server_register_node_request&amp; request</a>
<a name="ln453">				= *static_cast&lt;const server_register_node_request*&gt;(data);</a>
<a name="ln454">			server_register_node_reply reply;</a>
<a name="ln455"> </a>
<a name="ln456">			status_t status = gNodeManager-&gt;RegisterNode(request.add_on_id,</a>
<a name="ln457">				request.flavor_id, request.name, request.kinds, request.port,</a>
<a name="ln458">				request.team, request.timesource_id, &amp;reply.node_id);</a>
<a name="ln459">			request.SendReply(status, &amp;reply, sizeof(reply));</a>
<a name="ln460">			break;</a>
<a name="ln461">		}</a>
<a name="ln462"> </a>
<a name="ln463">		case SERVER_UNREGISTER_NODE:</a>
<a name="ln464">		{</a>
<a name="ln465">			const server_unregister_node_request&amp; request</a>
<a name="ln466">				= *static_cast&lt;const server_unregister_node_request*&gt;(data);</a>
<a name="ln467">			server_unregister_node_reply reply;</a>
<a name="ln468"> </a>
<a name="ln469">			status_t status = gNodeManager-&gt;UnregisterNode(request.node_id,</a>
<a name="ln470">				request.team, &amp;reply.add_on_id, &amp;reply.flavor_id);</a>
<a name="ln471">			request.SendReply(status, &amp;reply, sizeof(reply));</a>
<a name="ln472">			break;</a>
<a name="ln473">		}</a>
<a name="ln474"> </a>
<a name="ln475">		case SERVER_PUBLISH_INPUTS:</a>
<a name="ln476">		{</a>
<a name="ln477">			const server_publish_inputs_request&amp; request</a>
<a name="ln478">				= *static_cast&lt;const server_publish_inputs_request*&gt;(data);</a>
<a name="ln479">			server_publish_inputs_reply reply;</a>
<a name="ln480">			status_t status;</a>
<a name="ln481"> </a>
<a name="ln482">			if (request.count &lt;= MAX_INPUTS) {</a>
<a name="ln483">				status = gNodeManager-&gt;PublishInputs(request.node,</a>
<a name="ln484">					request.inputs, request.count);</a>
<a name="ln485">			} else {</a>
<a name="ln486">				media_input* inputs;</a>
<a name="ln487">				area_id clone;</a>
<a name="ln488">				clone = clone_area(&quot;media_inputs clone&quot;, (void**)&amp;inputs,</a>
<a name="ln489">					B_ANY_ADDRESS, B_READ_AREA | B_WRITE_AREA, request.area);</a>
<a name="ln490">				if (clone &lt; B_OK) {</a>
<a name="ln491">					ERROR(&quot;SERVER_PUBLISH_INPUTS: failed to clone area, &quot;</a>
<a name="ln492">						&quot;error %#&quot; B_PRIx32 &quot;\n&quot;, clone);</a>
<a name="ln493">					status = clone;</a>
<a name="ln494">				} else {</a>
<a name="ln495">					status = gNodeManager-&gt;PublishInputs(request.node, inputs,</a>
<a name="ln496">						request.count);</a>
<a name="ln497">					delete_area(clone);</a>
<a name="ln498">				}</a>
<a name="ln499">			}</a>
<a name="ln500">			request.SendReply(status, &amp;reply, sizeof(reply));</a>
<a name="ln501">			break;</a>
<a name="ln502">		}</a>
<a name="ln503"> </a>
<a name="ln504">		case SERVER_PUBLISH_OUTPUTS:</a>
<a name="ln505">		{</a>
<a name="ln506">			const server_publish_outputs_request&amp; request</a>
<a name="ln507">				= *static_cast&lt;const server_publish_outputs_request*&gt;(data);</a>
<a name="ln508">			server_publish_outputs_reply reply;</a>
<a name="ln509">			status_t status;</a>
<a name="ln510"> </a>
<a name="ln511">			if (request.count &lt;= MAX_OUTPUTS) {</a>
<a name="ln512">				status = gNodeManager-&gt;PublishOutputs(request.node,</a>
<a name="ln513">					request.outputs, request.count);</a>
<a name="ln514">			} else {</a>
<a name="ln515">				media_output* outputs;</a>
<a name="ln516">				area_id clone;</a>
<a name="ln517">				clone = clone_area(&quot;media_outputs clone&quot;, (void**)&amp;outputs,</a>
<a name="ln518">					B_ANY_ADDRESS, B_READ_AREA | B_WRITE_AREA, request.area);</a>
<a name="ln519">				if (clone &lt; B_OK) {</a>
<a name="ln520">					ERROR(&quot;SERVER_PUBLISH_OUTPUTS: failed to clone area, &quot;</a>
<a name="ln521">						&quot;error %#&quot; B_PRIx32 &quot;\n&quot;, clone);</a>
<a name="ln522">					status = clone;</a>
<a name="ln523">				} else {</a>
<a name="ln524">					status = gNodeManager-&gt;PublishOutputs(request.node, outputs,</a>
<a name="ln525">						request.count);</a>
<a name="ln526">					delete_area(clone);</a>
<a name="ln527">				}</a>
<a name="ln528">			}</a>
<a name="ln529">			request.SendReply(status, &amp;reply, sizeof(reply));</a>
<a name="ln530">			break;</a>
<a name="ln531">		}</a>
<a name="ln532"> </a>
<a name="ln533">		case SERVER_GET_NODE:</a>
<a name="ln534">		{</a>
<a name="ln535">			const server_get_node_request&amp; request</a>
<a name="ln536">				= *static_cast&lt;const server_get_node_request*&gt;(data);</a>
<a name="ln537">			server_get_node_reply reply;</a>
<a name="ln538"> </a>
<a name="ln539">			status_t status = gNodeManager-&gt;GetClone(request.type, request.team,</a>
<a name="ln540">				&amp;reply.node, reply.input_name, &amp;reply.input_id);</a>
<a name="ln541">			request.SendReply(status, &amp;reply, sizeof(reply));</a>
<a name="ln542">			break;</a>
<a name="ln543">		}</a>
<a name="ln544"> </a>
<a name="ln545">		case SERVER_SET_NODE:</a>
<a name="ln546">		{</a>
<a name="ln547">			const server_set_node_request&amp; request</a>
<a name="ln548">				= *static_cast&lt;const server_set_node_request*&gt;(data);</a>
<a name="ln549">			server_set_node_reply reply;</a>
<a name="ln550"> </a>
<a name="ln551">			status_t status = gNodeManager-&gt;SetDefaultNode(request.type,</a>
<a name="ln552">				request.use_node ? &amp;request.node : NULL,</a>
<a name="ln553">				request.use_dni ? &amp;request.dni : NULL,</a>
<a name="ln554">				request.use_input ?  &amp;request.input : NULL);</a>
<a name="ln555">			request.SendReply(status, &amp;reply, sizeof(reply));</a>
<a name="ln556">			break;</a>
<a name="ln557">		}</a>
<a name="ln558"> </a>
<a name="ln559">		case SERVER_GET_DORMANT_NODE_FOR:</a>
<a name="ln560">		{</a>
<a name="ln561">			const server_get_dormant_node_for_request&amp; request</a>
<a name="ln562">				= *static_cast&lt;const server_get_dormant_node_for_request*&gt;(</a>
<a name="ln563">					data);</a>
<a name="ln564">			server_get_dormant_node_for_reply reply;</a>
<a name="ln565"> </a>
<a name="ln566">			status_t status = gNodeManager-&gt;GetDormantNodeInfo(request.node,</a>
<a name="ln567">				&amp;reply.node_info);</a>
<a name="ln568">			request.SendReply(status, &amp;reply, sizeof(reply));</a>
<a name="ln569">			break;</a>
<a name="ln570">		}</a>
<a name="ln571"> </a>
<a name="ln572">		case SERVER_GET_INSTANCES_FOR:</a>
<a name="ln573">		{</a>
<a name="ln574">			const server_get_instances_for_request&amp; request</a>
<a name="ln575">				= *static_cast&lt;const server_get_instances_for_request*&gt;(data);</a>
<a name="ln576">			server_get_instances_for_reply reply;</a>
<a name="ln577"> </a>
<a name="ln578">			status_t status = gNodeManager-&gt;GetInstances(request.add_on_id,</a>
<a name="ln579">				request.flavor_id, reply.node_id, &amp;reply.count,</a>
<a name="ln580">				min_c(request.max_count, MAX_NODE_ID));</a>
<a name="ln581">			if (reply.count == MAX_NODE_ID</a>
<a name="ln582">				&amp;&amp; request.max_count &gt; MAX_NODE_ID) {</a>
<a name="ln583">				// TODO: might be fixed by using an area</a>
<a name="ln584">				PRINT(1, &quot;Warning: SERVER_GET_INSTANCES_FOR: returning &quot;</a>
<a name="ln585">					&quot;possibly truncated list of node id's\n&quot;);</a>
<a name="ln586">			}</a>
<a name="ln587">			request.SendReply(status, &amp;reply, sizeof(reply));</a>
<a name="ln588">			break;</a>
<a name="ln589">		}</a>
<a name="ln590"> </a>
<a name="ln591">		case SERVER_SET_NODE_TIMESOURCE:</a>
<a name="ln592">		{</a>
<a name="ln593">			const server_set_node_timesource_request&amp; request</a>
<a name="ln594">				= *static_cast&lt;const server_set_node_timesource_request*&gt;(data);</a>
<a name="ln595">			server_set_node_timesource_reply reply;</a>
<a name="ln596">			status_t result = gNodeManager-&gt;SetNodeTimeSource(request.node_id,</a>
<a name="ln597">				request.timesource_id);</a>
<a name="ln598">			request.SendReply(result, &amp;reply, sizeof(reply));</a>
<a name="ln599">			break;</a>
<a name="ln600">		}</a>
<a name="ln601"> </a>
<a name="ln602">		case SERVER_REGISTER_ADD_ON:</a>
<a name="ln603">		{</a>
<a name="ln604">			const server_register_add_on_request&amp; request = *static_cast&lt;</a>
<a name="ln605">				const server_register_add_on_request*&gt;(data);</a>
<a name="ln606">			server_register_add_on_reply reply;</a>
<a name="ln607"> </a>
<a name="ln608">			gNodeManager-&gt;RegisterAddOn(request.ref, &amp;reply.add_on_id);</a>
<a name="ln609">			request.SendReply(B_OK, &amp;reply, sizeof(reply));</a>
<a name="ln610">			break;</a>
<a name="ln611">		}</a>
<a name="ln612"> </a>
<a name="ln613">		case SERVER_UNREGISTER_ADD_ON:</a>
<a name="ln614">		{</a>
<a name="ln615">			const server_unregister_add_on_command&amp; request = *static_cast&lt;</a>
<a name="ln616">				const server_unregister_add_on_command*&gt;(data);</a>
<a name="ln617">			gNodeManager-&gt;UnregisterAddOn(request.add_on_id);</a>
<a name="ln618">			break;</a>
<a name="ln619">		}</a>
<a name="ln620"> </a>
<a name="ln621">		case SERVER_REGISTER_DORMANT_NODE:</a>
<a name="ln622">		{</a>
<a name="ln623">			const server_register_dormant_node_command&amp; command</a>
<a name="ln624">				= *static_cast&lt;const server_register_dormant_node_command*&gt;(</a>
<a name="ln625">					data);</a>
<a name="ln626">			if (command.purge_id &gt; 0)</a>
<a name="ln627">				gNodeManager-&gt;InvalidateDormantFlavorInfo(command.purge_id);</a>
<a name="ln628"> </a>
<a name="ln629">			dormant_flavor_info dormantFlavorInfo;</a>
<a name="ln630">			status_t status = dormantFlavorInfo.Unflatten(command.type,</a>
<a name="ln631">				command.flattened_data, command.flattened_size);</a>
<a name="ln632">			if (status == B_OK)</a>
<a name="ln633">				gNodeManager-&gt;AddDormantFlavorInfo(dormantFlavorInfo);</a>
<a name="ln634">			break;</a>
<a name="ln635">		}</a>
<a name="ln636"> </a>
<a name="ln637">		case SERVER_GET_DORMANT_NODES:</a>
<a name="ln638">		{</a>
<a name="ln639">			const server_get_dormant_nodes_request&amp; request</a>
<a name="ln640">				= *static_cast&lt;const server_get_dormant_nodes_request*&gt;(data);</a>
<a name="ln641"> </a>
<a name="ln642">			server_get_dormant_nodes_reply reply;</a>
<a name="ln643">			reply.count = request.max_count;</a>
<a name="ln644"> </a>
<a name="ln645">			dormant_node_info* infos</a>
<a name="ln646">				= new(std::nothrow) dormant_node_info[reply.count];</a>
<a name="ln647">			if (infos != NULL) {</a>
<a name="ln648">				reply.result = gNodeManager-&gt;GetDormantNodes(infos,</a>
<a name="ln649">					&amp;reply.count,</a>
<a name="ln650">					request.has_input ? &amp;request.input_format : NULL,</a>
<a name="ln651">					request.has_output ? &amp;request.output_format : NULL,</a>
<a name="ln652">					request.has_name ? request.name : NULL,</a>
<a name="ln653">					request.require_kinds, request.deny_kinds);</a>
<a name="ln654">			} else</a>
<a name="ln655">				reply.result = B_NO_MEMORY;</a>
<a name="ln656"> </a>
<a name="ln657">			if (reply.result != B_OK)</a>
<a name="ln658">				reply.count = 0;</a>
<a name="ln659"> </a>
<a name="ln660">			request.SendReply(reply.result, &amp;reply, sizeof(reply));</a>
<a name="ln661">			if (reply.count &gt; 0) {</a>
<a name="ln662">				write_port(request.reply_port, 0, infos,</a>
<a name="ln663">					reply.count * sizeof(dormant_node_info));</a>
<a name="ln664">			}</a>
<a name="ln665">			delete[] infos;</a>
<a name="ln666">			break;</a>
<a name="ln667">		}</a>
<a name="ln668"> </a>
<a name="ln669">		case SERVER_GET_DORMANT_FLAVOR_INFO:</a>
<a name="ln670">		{</a>
<a name="ln671">			const server_get_dormant_flavor_info_request&amp; request</a>
<a name="ln672">				= *static_cast&lt;const server_get_dormant_flavor_info_request*&gt;(</a>
<a name="ln673">					data);</a>
<a name="ln674">			dormant_flavor_info dormantFlavorInfo;</a>
<a name="ln675"> </a>
<a name="ln676">			status_t status = gNodeManager-&gt;GetDormantFlavorInfoFor(</a>
<a name="ln677">				request.add_on_id, request.flavor_id, &amp;dormantFlavorInfo);</a>
<a name="ln678">			if (status != B_OK) {</a>
<a name="ln679">				server_get_dormant_flavor_info_reply reply;</a>
<a name="ln680">				reply.result = status;</a>
<a name="ln681">				request.SendReply(reply.result, &amp;reply, sizeof(reply));</a>
<a name="ln682">			} else {</a>
<a name="ln683">				size_t replySize</a>
<a name="ln684">					= sizeof(server_get_dormant_flavor_info_reply)</a>
<a name="ln685">						+ dormantFlavorInfo.FlattenedSize();</a>
<a name="ln686">				server_get_dormant_flavor_info_reply* reply</a>
<a name="ln687">					= (server_get_dormant_flavor_info_reply*)malloc(</a>
<a name="ln688">						replySize);</a>
<a name="ln689">				if (reply != NULL) {</a>
<a name="ln690">					reply-&gt;type = dormantFlavorInfo.TypeCode();</a>
<a name="ln691">					reply-&gt;flattened_size = dormantFlavorInfo.FlattenedSize();</a>
<a name="ln692">					reply-&gt;result = dormantFlavorInfo.Flatten(</a>
<a name="ln693">						reply-&gt;flattened_data, reply-&gt;flattened_size);</a>
<a name="ln694"> </a>
<a name="ln695">					request.SendReply(reply-&gt;result, reply, replySize);</a>
<a name="ln696">					free(reply);</a>
<a name="ln697">				} else {</a>
<a name="ln698">					server_get_dormant_flavor_info_reply reply;</a>
<a name="ln699">					reply.result = B_NO_MEMORY;</a>
<a name="ln700">					request.SendReply(reply.result, &amp;reply, sizeof(reply));</a>
<a name="ln701">				}</a>
<a name="ln702">			}</a>
<a name="ln703">			break;</a>
<a name="ln704">		}</a>
<a name="ln705"> </a>
<a name="ln706">		case SERVER_SET_NODE_CREATOR:</a>
<a name="ln707">		{</a>
<a name="ln708">			const server_set_node_creator_request&amp; request</a>
<a name="ln709">				= *static_cast&lt;const server_set_node_creator_request*&gt;(data);</a>
<a name="ln710">			server_set_node_creator_reply reply;</a>
<a name="ln711">			status_t status = gNodeManager-&gt;SetNodeCreator(request.node,</a>
<a name="ln712">				request.creator);</a>
<a name="ln713">			request.SendReply(status, &amp;reply, sizeof(reply));</a>
<a name="ln714">			break;</a>
<a name="ln715">		}</a>
<a name="ln716"> </a>
<a name="ln717">		case SERVER_GET_SHARED_BUFFER_AREA:</a>
<a name="ln718">		{</a>
<a name="ln719">			const server_get_shared_buffer_area_request&amp; request</a>
<a name="ln720">				= *static_cast&lt;const server_get_shared_buffer_area_request*&gt;(</a>
<a name="ln721">					data);</a>
<a name="ln722">			server_get_shared_buffer_area_reply reply;</a>
<a name="ln723"> </a>
<a name="ln724">			reply.area = gBufferManager-&gt;SharedBufferListArea();</a>
<a name="ln725">			request.SendReply(reply.area &gt;= 0 ? B_OK : reply.area, &amp;reply,</a>
<a name="ln726">				sizeof(reply));</a>
<a name="ln727">			break;</a>
<a name="ln728">		}</a>
<a name="ln729"> </a>
<a name="ln730">		case SERVER_REGISTER_BUFFER:</a>
<a name="ln731">		{</a>
<a name="ln732">			const server_register_buffer_request&amp; request</a>
<a name="ln733">				= *static_cast&lt;const server_register_buffer_request*&gt;(data);</a>
<a name="ln734">			server_register_buffer_reply reply;</a>
<a name="ln735">			status_t status;</a>
<a name="ln736"> </a>
<a name="ln737">			if (request.info.buffer == 0) {</a>
<a name="ln738">				reply.info = request.info;</a>
<a name="ln739">				// size, offset, flags, area is kept</a>
<a name="ln740">				// get a new beuffer id into reply.info.buffer</a>
<a name="ln741">				status = gBufferManager-&gt;RegisterBuffer(request.team,</a>
<a name="ln742">					request.info.size, request.info.flags,</a>
<a name="ln743">					request.info.offset, request.info.area,</a>
<a name="ln744">					&amp;reply.info.buffer);</a>
<a name="ln745">			} else {</a>
<a name="ln746">				reply.info = request.info; // buffer id is kept</a>
<a name="ln747">				status = gBufferManager-&gt;RegisterBuffer(request.team,</a>
<a name="ln748">					request.info.buffer, &amp;reply.info.size, &amp;reply.info.flags,</a>
<a name="ln749">					&amp;reply.info.offset, &amp;reply.info.area);</a>
<a name="ln750">			}</a>
<a name="ln751">			request.SendReply(status, &amp;reply, sizeof(reply));</a>
<a name="ln752">			break;</a>
<a name="ln753">		}</a>
<a name="ln754"> </a>
<a name="ln755">		case SERVER_UNREGISTER_BUFFER:</a>
<a name="ln756">		{</a>
<a name="ln757">			const server_unregister_buffer_command&amp; request = *static_cast&lt;</a>
<a name="ln758">				const server_unregister_buffer_command*&gt;(data);</a>
<a name="ln759"> </a>
<a name="ln760">			gBufferManager-&gt;UnregisterBuffer(request.team, request.buffer_id);</a>
<a name="ln761">			break;</a>
<a name="ln762">		}</a>
<a name="ln763"> </a>
<a name="ln764">		case SERVER_GET_MEDIA_FILE_TYPES:</a>
<a name="ln765">		{</a>
<a name="ln766">			const server_get_media_types_request&amp; request</a>
<a name="ln767">				= *static_cast&lt;const server_get_media_types_request*&gt;(data);</a>
<a name="ln768"> </a>
<a name="ln769">			server_get_media_types_reply reply;</a>
<a name="ln770">			area_id area = gMediaFilesManager-&gt;GetTypesArea(reply.count);</a>
<a name="ln771">			if (area &gt;= 0) {</a>
<a name="ln772">				// transfer the area to the target team</a>
<a name="ln773">				reply.area = _kern_transfer_area(area, &amp;reply.address,</a>
<a name="ln774">					B_ANY_ADDRESS, request.team);</a>
<a name="ln775">				if (reply.area &lt; 0) {</a>
<a name="ln776">					delete_area(area);</a>
<a name="ln777">					reply.area = B_ERROR;</a>
<a name="ln778">					reply.count = 0;</a>
<a name="ln779">				}</a>
<a name="ln780">			}</a>
<a name="ln781"> </a>
<a name="ln782">			status_t status = request.SendReply(</a>
<a name="ln783">				reply.area &lt; 0 ? reply.area : B_OK, &amp;reply, sizeof(reply));</a>
<a name="ln784">			if (status != B_OK) {</a>
<a name="ln785">				// if we couldn't send the message, delete the area</a>
<a name="ln786">				delete_area(reply.area);</a>
<a name="ln787">			}</a>
<a name="ln788">			break;</a>
<a name="ln789">		}</a>
<a name="ln790"> </a>
<a name="ln791">		case SERVER_GET_MEDIA_FILE_ITEMS:</a>
<a name="ln792">		{</a>
<a name="ln793">			const server_get_media_items_request&amp; request</a>
<a name="ln794">				= *static_cast&lt;const server_get_media_items_request*&gt;(data);</a>
<a name="ln795"> </a>
<a name="ln796">			server_get_media_items_reply reply;</a>
<a name="ln797">			area_id area = gMediaFilesManager-&gt;GetItemsArea(request.type,</a>
<a name="ln798">				reply.count);</a>
<a name="ln799">			if (area &gt;= 0) {</a>
<a name="ln800">				// transfer the area to the target team</a>
<a name="ln801">				reply.area = _kern_transfer_area(area, &amp;reply.address,</a>
<a name="ln802">					B_ANY_ADDRESS, request.team);</a>
<a name="ln803">				if (reply.area &lt; 0) {</a>
<a name="ln804">					delete_area(area);</a>
<a name="ln805">					reply.area = B_ERROR;</a>
<a name="ln806">					reply.count = 0;</a>
<a name="ln807">				}</a>
<a name="ln808">			} else</a>
<a name="ln809">				reply.area = area;</a>
<a name="ln810"> </a>
<a name="ln811">			status_t status = request.SendReply(</a>
<a name="ln812">				reply.area &lt; 0 ? reply.area : B_OK, &amp;reply, sizeof(reply));</a>
<a name="ln813">			if (status != B_OK) {</a>
<a name="ln814">				// if we couldn't send the message, delete the area</a>
<a name="ln815">				delete_area(reply.area);</a>
<a name="ln816">			}</a>
<a name="ln817">			break;</a>
<a name="ln818">		}</a>
<a name="ln819"> </a>
<a name="ln820">		case SERVER_GET_REF_FOR:</a>
<a name="ln821">		{</a>
<a name="ln822">			const server_get_ref_for_request&amp; request</a>
<a name="ln823">				= *static_cast&lt;const server_get_ref_for_request*&gt;(data);</a>
<a name="ln824">			server_get_ref_for_reply reply;</a>
<a name="ln825">			entry_ref* ref;</a>
<a name="ln826"> </a>
<a name="ln827">			status_t status = gMediaFilesManager-&gt;GetRefFor(request.type,</a>
<a name="ln828">				request.item, &amp;ref);</a>
<a name="ln829">			if (status == B_OK)</a>
<a name="ln830">				reply.ref = *ref;</a>
<a name="ln831"> </a>
<a name="ln832">			request.SendReply(status, &amp;reply, sizeof(reply));</a>
<a name="ln833">			break;</a>
<a name="ln834">		}</a>
<a name="ln835"> </a>
<a name="ln836">		case SERVER_SET_REF_FOR:</a>
<a name="ln837">		{</a>
<a name="ln838">			const server_set_ref_for_request&amp; request</a>
<a name="ln839">				= *static_cast&lt;const server_set_ref_for_request*&gt;(data);</a>
<a name="ln840">			server_set_ref_for_reply reply;</a>
<a name="ln841">			entry_ref ref = request.ref;</a>
<a name="ln842"> </a>
<a name="ln843">			status_t status = gMediaFilesManager-&gt;SetRefFor(request.type,</a>
<a name="ln844">				request.item, ref);</a>
<a name="ln845">			request.SendReply(status, &amp;reply, sizeof(reply));</a>
<a name="ln846">			break;</a>
<a name="ln847">		}</a>
<a name="ln848"> </a>
<a name="ln849">		case SERVER_INVALIDATE_MEDIA_ITEM:</a>
<a name="ln850">		{</a>
<a name="ln851">			const server_invalidate_item_request&amp; request</a>
<a name="ln852">				= *static_cast&lt;const server_invalidate_item_request*&gt;(data);</a>
<a name="ln853">			server_invalidate_item_reply reply;</a>
<a name="ln854"> </a>
<a name="ln855">			status_t status = gMediaFilesManager-&gt;InvalidateItem(request.type,</a>
<a name="ln856">				request.item);</a>
<a name="ln857">			request.SendReply(status, &amp;reply, sizeof(reply));</a>
<a name="ln858">			break;</a>
<a name="ln859">		}</a>
<a name="ln860"> </a>
<a name="ln861">		case SERVER_REMOVE_MEDIA_ITEM:</a>
<a name="ln862">		{</a>
<a name="ln863">			const server_remove_media_item_request&amp; request</a>
<a name="ln864">				= *static_cast&lt;const server_remove_media_item_request*&gt;(data);</a>
<a name="ln865">			server_remove_media_item_reply reply;</a>
<a name="ln866"> </a>
<a name="ln867">			status_t status = gMediaFilesManager-&gt;RemoveItem(request.type,</a>
<a name="ln868">				request.item);</a>
<a name="ln869">			request.SendReply(status, &amp;reply, sizeof(reply));</a>
<a name="ln870">			break;</a>
<a name="ln871">		}</a>
<a name="ln872"> </a>
<a name="ln873">		case SERVER_GET_ITEM_AUDIO_GAIN:</a>
<a name="ln874">		{</a>
<a name="ln875">			const server_get_item_audio_gain_request&amp; request</a>
<a name="ln876">				= *static_cast&lt;const server_get_item_audio_gain_request*&gt;(data);</a>
<a name="ln877">			server_get_item_audio_gain_reply reply;</a>
<a name="ln878"> </a>
<a name="ln879">			status_t status = gMediaFilesManager-&gt;GetAudioGainFor(request.type,</a>
<a name="ln880">				request.item, &amp;reply.gain);</a>
<a name="ln881">			request.SendReply(status, &amp;reply, sizeof(reply));</a>
<a name="ln882">			break;</a>
<a name="ln883">		}</a>
<a name="ln884"> </a>
<a name="ln885">		case SERVER_SET_ITEM_AUDIO_GAIN:</a>
<a name="ln886">		{</a>
<a name="ln887">			const server_set_item_audio_gain_request&amp; request</a>
<a name="ln888">				= *static_cast&lt;const server_set_item_audio_gain_request*&gt;(data);</a>
<a name="ln889">			server_set_ref_for_reply reply;</a>
<a name="ln890"> </a>
<a name="ln891">			status_t status = gMediaFilesManager-&gt;SetAudioGainFor(request.type,</a>
<a name="ln892">				request.item, request.gain);</a>
<a name="ln893">			request.SendReply(status, &amp;reply, sizeof(reply));</a>
<a name="ln894">			break;</a>
<a name="ln895">		}</a>
<a name="ln896"> </a>
<a name="ln897">		default:</a>
<a name="ln898">			printf(&quot;media_server: received unknown message code %#08&quot; B_PRIx32</a>
<a name="ln899">				&quot;\n&quot;, code);</a>
<a name="ln900">	}</a>
<a name="ln901">	TRACE(&quot;ServerApp::HandleMessage %#&quot; B_PRIx32 &quot; leave\n&quot;, code);</a>
<a name="ln902">}</a>
<a name="ln903"> </a>
<a name="ln904"> </a>
<a name="ln905">status_t</a>
<a name="ln906">ServerApp::_ControlThread(void* _server)</a>
<a name="ln907">{</a>
<a name="ln908">	ServerApp* server = (ServerApp*)_server;</a>
<a name="ln909"> </a>
<a name="ln910">	char data[B_MEDIA_MESSAGE_SIZE];</a>
<a name="ln911">	ssize_t size;</a>
<a name="ln912">	int32 code;</a>
<a name="ln913">	while ((size = read_port_etc(server-&gt;_ControlPort(), &amp;code, data,</a>
<a name="ln914">			sizeof(data), 0, 0)) &gt; 0) {</a>
<a name="ln915">		server-&gt;_HandleMessage(code, data, size);</a>
<a name="ln916">	}</a>
<a name="ln917"> </a>
<a name="ln918">	return B_OK;</a>
<a name="ln919">}</a>
<a name="ln920"> </a>
<a name="ln921"> </a>
<a name="ln922">void</a>
<a name="ln923">ServerApp::MessageReceived(BMessage* msg)</a>
<a name="ln924">{</a>
<a name="ln925">	TRACE(&quot;ServerApp::MessageReceived %&quot; B_PRIu32 &quot; enter\n&quot;, msg-&gt;what);</a>
<a name="ln926">	switch (msg-&gt;what) {</a>
<a name="ln927">		case MEDIA_SERVER_REQUEST_NOTIFICATIONS:</a>
<a name="ln928">		case MEDIA_SERVER_CANCEL_NOTIFICATIONS:</a>
<a name="ln929">		case MEDIA_SERVER_SEND_NOTIFICATIONS:</a>
<a name="ln930">			gNotificationManager-&gt;EnqueueMessage(msg);</a>
<a name="ln931">			break;</a>
<a name="ln932"> </a>
<a name="ln933">		case MEDIA_FILES_MANAGER_SAVE_TIMER:</a>
<a name="ln934">			gMediaFilesManager-&gt;TimerMessage();</a>
<a name="ln935">			break;</a>
<a name="ln936"> </a>
<a name="ln937">		case MEDIA_SERVER_ADD_SYSTEM_BEEP_EVENT:</a>
<a name="ln938">			gMediaFilesManager-&gt;HandleAddSystemBeepEvent(msg);</a>
<a name="ln939">			break;</a>
<a name="ln940"> </a>
<a name="ln941">		case MEDIA_SERVER_RESCAN_COMPLETED:</a>
<a name="ln942">			gAppManager-&gt;NotifyRosters();</a>
<a name="ln943">			break;</a>
<a name="ln944"> </a>
<a name="ln945">		case B_SOME_APP_QUIT:</a>
<a name="ln946">		{</a>
<a name="ln947">			BString mimeSig;</a>
<a name="ln948">			if (msg-&gt;FindString(&quot;be:signature&quot;, &amp;mimeSig) != B_OK)</a>
<a name="ln949">				return;</a>
<a name="ln950"> </a>
<a name="ln951">			if (mimeSig == B_MEDIA_ADDON_SERVER_SIGNATURE)</a>
<a name="ln952">				gNodeManager-&gt;CleanupDormantFlavorInfos();</a>
<a name="ln953"> </a>
<a name="ln954">			team_id id;</a>
<a name="ln955">			if (msg-&gt;FindInt32(&quot;team&quot;, &amp;id) == B_OK</a>
<a name="ln956">					&amp;&amp; gAppManager-&gt;HasTeam(id)) {</a>
<a name="ln957">				gAppManager-&gt;UnregisterTeam(id);</a>
<a name="ln958">			}</a>
<a name="ln959">			break;</a>
<a name="ln960">		}</a>
<a name="ln961"> </a>
<a name="ln962">		default:</a>
<a name="ln963">			BApplication::MessageReceived(msg);</a>
<a name="ln964">			TRACE(&quot;\nmedia_server: unknown message received!\n&quot;);</a>
<a name="ln965">			break;</a>
<a name="ln966">	}</a>
<a name="ln967">	TRACE(&quot;ServerApp::MessageReceived %&quot; B_PRIu32 &quot; leave\n&quot;, msg-&gt;what);</a>
<a name="ln968">}</a>
<a name="ln969"> </a>
<a name="ln970"> </a>
<a name="ln971">//	#pragma mark -</a>
<a name="ln972"> </a>
<a name="ln973"> </a>
<a name="ln974">int</a>
<a name="ln975">main()</a>
<a name="ln976">{</a>
<a name="ln977">	status_t status;</a>
<a name="ln978">	ServerApp app(status);</a>
<a name="ln979"> </a>
<a name="ln980">	if (status == B_OK)</a>
<a name="ln981">		app.Run();</a>
<a name="ln982"> </a>
<a name="ln983">	return status == B_OK ? EXIT_SUCCESS : EXIT_FAILURE;</a>
<a name="ln984">}</a>

</code></pre>
<div class="balloon" rel="978"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v614/" target="_blank">V614</a> Uninitialized variable 'status' used.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
