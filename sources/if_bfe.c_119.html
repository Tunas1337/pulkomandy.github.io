
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>if_bfe.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2003 Stuart Walsh&lt;stu@ipng.org.uk&gt;</a>
<a name="ln5"> * and Duncan Barclay&lt;dmlb@dmlb.org&gt;</a>
<a name="ln6"> *</a>
<a name="ln7"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln8"> * modification, are permitted provided that the following conditions</a>
<a name="ln9"> * are met:</a>
<a name="ln10"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln11"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln12"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln13"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln14"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln15"> *</a>
<a name="ln16"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS 'AS IS' AND</a>
<a name="ln17"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln18"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln19"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</a>
<a name="ln20"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln21"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln22"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln23"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln24"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln25"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln26"> * SUCH DAMAGE.</a>
<a name="ln27"> */</a>
<a name="ln28"> </a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln31">__FBSDID(&quot;$FreeBSD: releng/12.0/sys/dev/bfe/if_bfe.c 338948 2018-09-26 17:12:14Z imp $&quot;);</a>
<a name="ln32"> </a>
<a name="ln33">#include &lt;sys/param.h&gt;</a>
<a name="ln34">#include &lt;sys/systm.h&gt;</a>
<a name="ln35">#include &lt;sys/bus.h&gt;</a>
<a name="ln36">#include &lt;sys/endian.h&gt;</a>
<a name="ln37">#include &lt;sys/kernel.h&gt;</a>
<a name="ln38">#include &lt;sys/malloc.h&gt;</a>
<a name="ln39">#include &lt;sys/mbuf.h&gt;</a>
<a name="ln40">#include &lt;sys/module.h&gt;</a>
<a name="ln41">#include &lt;sys/rman.h&gt;</a>
<a name="ln42">#include &lt;sys/socket.h&gt;</a>
<a name="ln43">#include &lt;sys/sockio.h&gt;</a>
<a name="ln44">#include &lt;sys/sysctl.h&gt;</a>
<a name="ln45"> </a>
<a name="ln46">#include &lt;net/bpf.h&gt;</a>
<a name="ln47">#include &lt;net/if.h&gt;</a>
<a name="ln48">#include &lt;net/if_var.h&gt;</a>
<a name="ln49">#include &lt;net/ethernet.h&gt;</a>
<a name="ln50">#include &lt;net/if_dl.h&gt;</a>
<a name="ln51">#include &lt;net/if_media.h&gt;</a>
<a name="ln52">#include &lt;net/if_types.h&gt;</a>
<a name="ln53">#include &lt;net/if_vlan_var.h&gt;</a>
<a name="ln54"> </a>
<a name="ln55">#include &lt;dev/mii/mii.h&gt;</a>
<a name="ln56">#include &lt;dev/mii/miivar.h&gt;</a>
<a name="ln57"> </a>
<a name="ln58">#include &lt;dev/pci/pcireg.h&gt;</a>
<a name="ln59">#include &lt;dev/pci/pcivar.h&gt;</a>
<a name="ln60"> </a>
<a name="ln61">#include &lt;machine/bus.h&gt;</a>
<a name="ln62"> </a>
<a name="ln63">#include &lt;dev/bfe/if_bfereg.h&gt;</a>
<a name="ln64"> </a>
<a name="ln65">MODULE_DEPEND(bfe, pci, 1, 1, 1);</a>
<a name="ln66">MODULE_DEPEND(bfe, ether, 1, 1, 1);</a>
<a name="ln67">MODULE_DEPEND(bfe, miibus, 1, 1, 1);</a>
<a name="ln68"> </a>
<a name="ln69">/* &quot;device miibus&quot; required.  See GENERIC if you get errors here. */</a>
<a name="ln70">#include &quot;miibus_if.h&quot;</a>
<a name="ln71"> </a>
<a name="ln72">#define BFE_DEVDESC_MAX		64	/* Maximum device description length */</a>
<a name="ln73"> </a>
<a name="ln74">static struct bfe_type bfe_devs[] = {</a>
<a name="ln75">	{ BCOM_VENDORID, BCOM_DEVICEID_BCM4401,</a>
<a name="ln76">		&quot;Broadcom BCM4401 Fast Ethernet&quot; },</a>
<a name="ln77">	{ BCOM_VENDORID, BCOM_DEVICEID_BCM4401B0,</a>
<a name="ln78">		&quot;Broadcom BCM4401-B0 Fast Ethernet&quot; },</a>
<a name="ln79">		{ 0, 0, NULL }</a>
<a name="ln80">};</a>
<a name="ln81"> </a>
<a name="ln82">static int  bfe_probe				(device_t);</a>
<a name="ln83">static int  bfe_attach				(device_t);</a>
<a name="ln84">static int  bfe_detach				(device_t);</a>
<a name="ln85">static int  bfe_suspend				(device_t);</a>
<a name="ln86">static int  bfe_resume				(device_t);</a>
<a name="ln87">static void bfe_release_resources	(struct bfe_softc *);</a>
<a name="ln88">static void bfe_intr				(void *);</a>
<a name="ln89">static int  bfe_encap				(struct bfe_softc *, struct mbuf **);</a>
<a name="ln90">static void bfe_start				(struct ifnet *);</a>
<a name="ln91">static void bfe_start_locked			(struct ifnet *);</a>
<a name="ln92">static int  bfe_ioctl				(struct ifnet *, u_long, caddr_t);</a>
<a name="ln93">static void bfe_init				(void *);</a>
<a name="ln94">static void bfe_init_locked			(void *);</a>
<a name="ln95">static void bfe_stop				(struct bfe_softc *);</a>
<a name="ln96">static void bfe_watchdog			(struct bfe_softc *);</a>
<a name="ln97">static int  bfe_shutdown			(device_t);</a>
<a name="ln98">static void bfe_tick				(void *);</a>
<a name="ln99">static void bfe_txeof				(struct bfe_softc *);</a>
<a name="ln100">static void bfe_rxeof				(struct bfe_softc *);</a>
<a name="ln101">static void bfe_set_rx_mode			(struct bfe_softc *);</a>
<a name="ln102">static int  bfe_list_rx_init		(struct bfe_softc *);</a>
<a name="ln103">static void bfe_list_tx_init		(struct bfe_softc *);</a>
<a name="ln104">static void bfe_discard_buf		(struct bfe_softc *, int);</a>
<a name="ln105">static int  bfe_list_newbuf			(struct bfe_softc *, int);</a>
<a name="ln106">static void bfe_rx_ring_free		(struct bfe_softc *);</a>
<a name="ln107"> </a>
<a name="ln108">static void bfe_pci_setup			(struct bfe_softc *, u_int32_t);</a>
<a name="ln109">static int  bfe_ifmedia_upd			(struct ifnet *);</a>
<a name="ln110">static void bfe_ifmedia_sts			(struct ifnet *, struct ifmediareq *);</a>
<a name="ln111">static int  bfe_miibus_readreg		(device_t, int, int);</a>
<a name="ln112">static int  bfe_miibus_writereg		(device_t, int, int, int);</a>
<a name="ln113">static void bfe_miibus_statchg		(device_t);</a>
<a name="ln114">static int  bfe_wait_bit			(struct bfe_softc *, u_int32_t, u_int32_t,</a>
<a name="ln115">		u_long, const int);</a>
<a name="ln116">static void bfe_get_config			(struct bfe_softc *sc);</a>
<a name="ln117">static void bfe_read_eeprom			(struct bfe_softc *, u_int8_t *);</a>
<a name="ln118">static void bfe_stats_update		(struct bfe_softc *);</a>
<a name="ln119">static void bfe_clear_stats			(struct bfe_softc *);</a>
<a name="ln120">static int  bfe_readphy				(struct bfe_softc *, u_int32_t, u_int32_t*);</a>
<a name="ln121">static int  bfe_writephy			(struct bfe_softc *, u_int32_t, u_int32_t);</a>
<a name="ln122">static int  bfe_resetphy			(struct bfe_softc *);</a>
<a name="ln123">static int  bfe_setupphy			(struct bfe_softc *);</a>
<a name="ln124">static void bfe_chip_reset			(struct bfe_softc *);</a>
<a name="ln125">static void bfe_chip_halt			(struct bfe_softc *);</a>
<a name="ln126">static void bfe_core_reset			(struct bfe_softc *);</a>
<a name="ln127">static void bfe_core_disable		(struct bfe_softc *);</a>
<a name="ln128">static int  bfe_dma_alloc			(struct bfe_softc *);</a>
<a name="ln129">static void bfe_dma_free		(struct bfe_softc *sc);</a>
<a name="ln130">static void bfe_dma_map				(void *, bus_dma_segment_t *, int, int);</a>
<a name="ln131">static void bfe_cam_write			(struct bfe_softc *, u_char *, int);</a>
<a name="ln132">static int  sysctl_bfe_stats		(SYSCTL_HANDLER_ARGS);</a>
<a name="ln133"> </a>
<a name="ln134">static device_method_t bfe_methods[] = {</a>
<a name="ln135">	/* Device interface */</a>
<a name="ln136">	DEVMETHOD(device_probe,		bfe_probe),</a>
<a name="ln137">	DEVMETHOD(device_attach,	bfe_attach),</a>
<a name="ln138">	DEVMETHOD(device_detach,	bfe_detach),</a>
<a name="ln139">	DEVMETHOD(device_shutdown,	bfe_shutdown),</a>
<a name="ln140">	DEVMETHOD(device_suspend,	bfe_suspend),</a>
<a name="ln141">	DEVMETHOD(device_resume,	bfe_resume),</a>
<a name="ln142"> </a>
<a name="ln143">	/* MII interface */</a>
<a name="ln144">	DEVMETHOD(miibus_readreg,	bfe_miibus_readreg),</a>
<a name="ln145">	DEVMETHOD(miibus_writereg,	bfe_miibus_writereg),</a>
<a name="ln146">	DEVMETHOD(miibus_statchg,	bfe_miibus_statchg),</a>
<a name="ln147"> </a>
<a name="ln148">	DEVMETHOD_END</a>
<a name="ln149">};</a>
<a name="ln150"> </a>
<a name="ln151">static driver_t bfe_driver = {</a>
<a name="ln152">	&quot;bfe&quot;,</a>
<a name="ln153">	bfe_methods,</a>
<a name="ln154">	sizeof(struct bfe_softc)</a>
<a name="ln155">};</a>
<a name="ln156"> </a>
<a name="ln157">static devclass_t bfe_devclass;</a>
<a name="ln158"> </a>
<a name="ln159">DRIVER_MODULE(bfe, pci, bfe_driver, bfe_devclass, 0, 0);</a>
<a name="ln160">MODULE_PNP_INFO(&quot;U16:vendor;U16:device;D:#&quot;, pci, bfe, bfe_devs,</a>
<a name="ln161">    nitems(bfe_devs) - 1);</a>
<a name="ln162">DRIVER_MODULE(miibus, bfe, miibus_driver, miibus_devclass, 0, 0);</a>
<a name="ln163"> </a>
<a name="ln164">/*</a>
<a name="ln165"> * Probe for a Broadcom 4401 chip.</a>
<a name="ln166"> */</a>
<a name="ln167">static int</a>
<a name="ln168">bfe_probe(device_t dev)</a>
<a name="ln169">{</a>
<a name="ln170">	struct bfe_type *t;</a>
<a name="ln171"> </a>
<a name="ln172">	t = bfe_devs;</a>
<a name="ln173"> </a>
<a name="ln174">	while (t-&gt;bfe_name != NULL) {</a>
<a name="ln175">		if (pci_get_vendor(dev) == t-&gt;bfe_vid &amp;&amp;</a>
<a name="ln176">		    pci_get_device(dev) == t-&gt;bfe_did) {</a>
<a name="ln177">			device_set_desc(dev, t-&gt;bfe_name);</a>
<a name="ln178">			return (BUS_PROBE_DEFAULT);</a>
<a name="ln179">		}</a>
<a name="ln180">		t++;</a>
<a name="ln181">	}</a>
<a name="ln182"> </a>
<a name="ln183">	return (ENXIO);</a>
<a name="ln184">}</a>
<a name="ln185"> </a>
<a name="ln186">struct bfe_dmamap_arg {</a>
<a name="ln187">	bus_addr_t	bfe_busaddr;</a>
<a name="ln188">};</a>
<a name="ln189"> </a>
<a name="ln190">static int</a>
<a name="ln191">bfe_dma_alloc(struct bfe_softc *sc)</a>
<a name="ln192">{</a>
<a name="ln193">	struct bfe_dmamap_arg ctx;</a>
<a name="ln194">	struct bfe_rx_data *rd;</a>
<a name="ln195">	struct bfe_tx_data *td;</a>
<a name="ln196">	int error, i;</a>
<a name="ln197"> </a>
<a name="ln198">	/*</a>
<a name="ln199">	 * parent tag.  Apparently the chip cannot handle any DMA address</a>
<a name="ln200">	 * greater than 1GB.</a>
<a name="ln201">	 */</a>
<a name="ln202">	error = bus_dma_tag_create(bus_get_dma_tag(sc-&gt;bfe_dev), /* parent */</a>
<a name="ln203">	    1, 0,			/* alignment, boundary */</a>
<a name="ln204">	    BFE_DMA_MAXADDR, 		/* lowaddr */</a>
<a name="ln205">	    BUS_SPACE_MAXADDR,		/* highaddr */</a>
<a name="ln206">	    NULL, NULL,			/* filter, filterarg */</a>
<a name="ln207">	    BUS_SPACE_MAXSIZE_32BIT,	/* maxsize */</a>
<a name="ln208">	    0,				/* nsegments */</a>
<a name="ln209">	    BUS_SPACE_MAXSIZE_32BIT,	/* maxsegsize */</a>
<a name="ln210">	    0,				/* flags */</a>
<a name="ln211">	    NULL, NULL,			/* lockfunc, lockarg */</a>
<a name="ln212">	    &amp;sc-&gt;bfe_parent_tag);</a>
<a name="ln213">	if (error != 0) {</a>
<a name="ln214">		device_printf(sc-&gt;bfe_dev, &quot;cannot create parent DMA tag.\n&quot;);</a>
<a name="ln215">		goto fail;</a>
<a name="ln216">	}</a>
<a name="ln217"> </a>
<a name="ln218">	/* Create tag for Tx ring. */</a>
<a name="ln219">	error = bus_dma_tag_create(sc-&gt;bfe_parent_tag, /* parent */</a>
<a name="ln220">	    BFE_TX_RING_ALIGN, 0,	/* alignment, boundary */</a>
<a name="ln221">	    BUS_SPACE_MAXADDR, 		/* lowaddr */</a>
<a name="ln222">	    BUS_SPACE_MAXADDR,		/* highaddr */</a>
<a name="ln223">	    NULL, NULL,			/* filter, filterarg */</a>
<a name="ln224">	    BFE_TX_LIST_SIZE,		/* maxsize */</a>
<a name="ln225">	    1,				/* nsegments */</a>
<a name="ln226">	    BFE_TX_LIST_SIZE,		/* maxsegsize */</a>
<a name="ln227">	    0,				/* flags */</a>
<a name="ln228">	    NULL, NULL,			/* lockfunc, lockarg */</a>
<a name="ln229">	    &amp;sc-&gt;bfe_tx_tag);</a>
<a name="ln230">	if (error != 0) {</a>
<a name="ln231">		device_printf(sc-&gt;bfe_dev, &quot;cannot create Tx ring DMA tag.\n&quot;);</a>
<a name="ln232">		goto fail;</a>
<a name="ln233">	}</a>
<a name="ln234"> </a>
<a name="ln235">	/* Create tag for Rx ring. */</a>
<a name="ln236">	error = bus_dma_tag_create(sc-&gt;bfe_parent_tag, /* parent */</a>
<a name="ln237">	    BFE_RX_RING_ALIGN, 0,	/* alignment, boundary */</a>
<a name="ln238">	    BUS_SPACE_MAXADDR, 		/* lowaddr */</a>
<a name="ln239">	    BUS_SPACE_MAXADDR,		/* highaddr */</a>
<a name="ln240">	    NULL, NULL,			/* filter, filterarg */</a>
<a name="ln241">	    BFE_RX_LIST_SIZE,		/* maxsize */</a>
<a name="ln242">	    1,				/* nsegments */</a>
<a name="ln243">	    BFE_RX_LIST_SIZE,		/* maxsegsize */</a>
<a name="ln244">	    0,				/* flags */</a>
<a name="ln245">	    NULL, NULL,			/* lockfunc, lockarg */</a>
<a name="ln246">	    &amp;sc-&gt;bfe_rx_tag);</a>
<a name="ln247">	if (error != 0) {</a>
<a name="ln248">		device_printf(sc-&gt;bfe_dev, &quot;cannot create Rx ring DMA tag.\n&quot;);</a>
<a name="ln249">		goto fail;</a>
<a name="ln250">	}</a>
<a name="ln251"> </a>
<a name="ln252">	/* Create tag for Tx buffers. */</a>
<a name="ln253">	error = bus_dma_tag_create(sc-&gt;bfe_parent_tag, /* parent */</a>
<a name="ln254">	    1, 0,			/* alignment, boundary */</a>
<a name="ln255">	    BUS_SPACE_MAXADDR, 		/* lowaddr */</a>
<a name="ln256">	    BUS_SPACE_MAXADDR,		/* highaddr */</a>
<a name="ln257">	    NULL, NULL,			/* filter, filterarg */</a>
<a name="ln258">	    MCLBYTES * BFE_MAXTXSEGS,	/* maxsize */</a>
<a name="ln259">	    BFE_MAXTXSEGS,		/* nsegments */</a>
<a name="ln260">	    MCLBYTES,			/* maxsegsize */</a>
<a name="ln261">	    0,				/* flags */</a>
<a name="ln262">	    NULL, NULL,			/* lockfunc, lockarg */</a>
<a name="ln263">	    &amp;sc-&gt;bfe_txmbuf_tag);</a>
<a name="ln264">	if (error != 0) {</a>
<a name="ln265">		device_printf(sc-&gt;bfe_dev,</a>
<a name="ln266">		    &quot;cannot create Tx buffer DMA tag.\n&quot;);</a>
<a name="ln267">		goto fail;</a>
<a name="ln268">	}</a>
<a name="ln269"> </a>
<a name="ln270">	/* Create tag for Rx buffers. */</a>
<a name="ln271">	error = bus_dma_tag_create(sc-&gt;bfe_parent_tag, /* parent */</a>
<a name="ln272">	    1, 0,			/* alignment, boundary */</a>
<a name="ln273">	    BUS_SPACE_MAXADDR, 		/* lowaddr */</a>
<a name="ln274">	    BUS_SPACE_MAXADDR,		/* highaddr */</a>
<a name="ln275">	    NULL, NULL,			/* filter, filterarg */</a>
<a name="ln276">	    MCLBYTES,			/* maxsize */</a>
<a name="ln277">	    1,				/* nsegments */</a>
<a name="ln278">	    MCLBYTES,			/* maxsegsize */</a>
<a name="ln279">	    0,				/* flags */</a>
<a name="ln280">	    NULL, NULL,			/* lockfunc, lockarg */</a>
<a name="ln281">	    &amp;sc-&gt;bfe_rxmbuf_tag);</a>
<a name="ln282">	if (error != 0) {</a>
<a name="ln283">		device_printf(sc-&gt;bfe_dev,</a>
<a name="ln284">		    &quot;cannot create Rx buffer DMA tag.\n&quot;);</a>
<a name="ln285">		goto fail;</a>
<a name="ln286">	}</a>
<a name="ln287"> </a>
<a name="ln288">	/* Allocate DMA'able memory and load DMA map. */</a>
<a name="ln289">	error = bus_dmamem_alloc(sc-&gt;bfe_tx_tag, (void *)&amp;sc-&gt;bfe_tx_list,</a>
<a name="ln290">	  BUS_DMA_WAITOK | BUS_DMA_ZERO | BUS_DMA_COHERENT, &amp;sc-&gt;bfe_tx_map);</a>
<a name="ln291">	if (error != 0) {</a>
<a name="ln292">		device_printf(sc-&gt;bfe_dev,</a>
<a name="ln293">		    &quot;cannot allocate DMA'able memory for Tx ring.\n&quot;);</a>
<a name="ln294">		goto fail;</a>
<a name="ln295">	}</a>
<a name="ln296">	ctx.bfe_busaddr = 0;</a>
<a name="ln297">	error = bus_dmamap_load(sc-&gt;bfe_tx_tag, sc-&gt;bfe_tx_map,</a>
<a name="ln298">	    sc-&gt;bfe_tx_list, BFE_TX_LIST_SIZE, bfe_dma_map, &amp;ctx,</a>
<a name="ln299">	    BUS_DMA_NOWAIT);</a>
<a name="ln300">	if (error != 0 || ctx.bfe_busaddr == 0) {</a>
<a name="ln301">		device_printf(sc-&gt;bfe_dev,</a>
<a name="ln302">		    &quot;cannot load DMA'able memory for Tx ring.\n&quot;);</a>
<a name="ln303">		goto fail;</a>
<a name="ln304">	}</a>
<a name="ln305">	sc-&gt;bfe_tx_dma = BFE_ADDR_LO(ctx.bfe_busaddr);</a>
<a name="ln306"> </a>
<a name="ln307">	error = bus_dmamem_alloc(sc-&gt;bfe_rx_tag, (void *)&amp;sc-&gt;bfe_rx_list,</a>
<a name="ln308">	  BUS_DMA_WAITOK | BUS_DMA_ZERO | BUS_DMA_COHERENT, &amp;sc-&gt;bfe_rx_map);</a>
<a name="ln309">	if (error != 0) {</a>
<a name="ln310">		device_printf(sc-&gt;bfe_dev,</a>
<a name="ln311">		    &quot;cannot allocate DMA'able memory for Rx ring.\n&quot;);</a>
<a name="ln312">		goto fail;</a>
<a name="ln313">	}</a>
<a name="ln314">	ctx.bfe_busaddr = 0;</a>
<a name="ln315">	error = bus_dmamap_load(sc-&gt;bfe_rx_tag, sc-&gt;bfe_rx_map,</a>
<a name="ln316">	    sc-&gt;bfe_rx_list, BFE_RX_LIST_SIZE, bfe_dma_map, &amp;ctx,</a>
<a name="ln317">	    BUS_DMA_NOWAIT);</a>
<a name="ln318">	if (error != 0 || ctx.bfe_busaddr == 0) {</a>
<a name="ln319">		device_printf(sc-&gt;bfe_dev,</a>
<a name="ln320">		    &quot;cannot load DMA'able memory for Rx ring.\n&quot;);</a>
<a name="ln321">		goto fail;</a>
<a name="ln322">	}</a>
<a name="ln323">	sc-&gt;bfe_rx_dma = BFE_ADDR_LO(ctx.bfe_busaddr);</a>
<a name="ln324"> </a>
<a name="ln325">	/* Create DMA maps for Tx buffers. */</a>
<a name="ln326">	for (i = 0; i &lt; BFE_TX_LIST_CNT; i++) {</a>
<a name="ln327">		td = &amp;sc-&gt;bfe_tx_ring[i];</a>
<a name="ln328">		td-&gt;bfe_mbuf = NULL;</a>
<a name="ln329">		td-&gt;bfe_map = NULL;</a>
<a name="ln330">		error = bus_dmamap_create(sc-&gt;bfe_txmbuf_tag, 0, &amp;td-&gt;bfe_map);</a>
<a name="ln331">		if (error != 0) {</a>
<a name="ln332">			device_printf(sc-&gt;bfe_dev,</a>
<a name="ln333">			    &quot;cannot create DMA map for Tx.\n&quot;);</a>
<a name="ln334">			goto fail;</a>
<a name="ln335">		}</a>
<a name="ln336">	}</a>
<a name="ln337"> </a>
<a name="ln338">	/* Create spare DMA map for Rx buffers. */</a>
<a name="ln339">	error = bus_dmamap_create(sc-&gt;bfe_rxmbuf_tag, 0, &amp;sc-&gt;bfe_rx_sparemap);</a>
<a name="ln340">	if (error != 0) {</a>
<a name="ln341">		device_printf(sc-&gt;bfe_dev, &quot;cannot create spare DMA map for Rx.\n&quot;);</a>
<a name="ln342">		goto fail;</a>
<a name="ln343">	}</a>
<a name="ln344">	/* Create DMA maps for Rx buffers. */</a>
<a name="ln345">	for (i = 0; i &lt; BFE_RX_LIST_CNT; i++) {</a>
<a name="ln346">		rd = &amp;sc-&gt;bfe_rx_ring[i];</a>
<a name="ln347">		rd-&gt;bfe_mbuf = NULL;</a>
<a name="ln348">		rd-&gt;bfe_map = NULL;</a>
<a name="ln349">		rd-&gt;bfe_ctrl = 0;</a>
<a name="ln350">		error = bus_dmamap_create(sc-&gt;bfe_rxmbuf_tag, 0, &amp;rd-&gt;bfe_map);</a>
<a name="ln351">		if (error != 0) {</a>
<a name="ln352">			device_printf(sc-&gt;bfe_dev,</a>
<a name="ln353">			    &quot;cannot create DMA map for Rx.\n&quot;);</a>
<a name="ln354">			goto fail;</a>
<a name="ln355">		}</a>
<a name="ln356">	}</a>
<a name="ln357"> </a>
<a name="ln358">fail:</a>
<a name="ln359">	return (error);</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362">static void</a>
<a name="ln363">bfe_dma_free(struct bfe_softc *sc)</a>
<a name="ln364">{</a>
<a name="ln365">	struct bfe_tx_data *td;</a>
<a name="ln366">	struct bfe_rx_data *rd;</a>
<a name="ln367">	int i;</a>
<a name="ln368"> </a>
<a name="ln369">	/* Tx ring. */</a>
<a name="ln370">	if (sc-&gt;bfe_tx_tag != NULL) {</a>
<a name="ln371">		if (sc-&gt;bfe_tx_dma != 0)</a>
<a name="ln372">			bus_dmamap_unload(sc-&gt;bfe_tx_tag, sc-&gt;bfe_tx_map);</a>
<a name="ln373">		if (sc-&gt;bfe_tx_list != NULL)</a>
<a name="ln374">			bus_dmamem_free(sc-&gt;bfe_tx_tag, sc-&gt;bfe_tx_list,</a>
<a name="ln375">			    sc-&gt;bfe_tx_map);</a>
<a name="ln376">		sc-&gt;bfe_tx_dma = 0;</a>
<a name="ln377">		sc-&gt;bfe_tx_list = NULL;</a>
<a name="ln378">		bus_dma_tag_destroy(sc-&gt;bfe_tx_tag);</a>
<a name="ln379">		sc-&gt;bfe_tx_tag = NULL;</a>
<a name="ln380">	}</a>
<a name="ln381"> </a>
<a name="ln382">	/* Rx ring. */</a>
<a name="ln383">	if (sc-&gt;bfe_rx_tag != NULL) {</a>
<a name="ln384">		if (sc-&gt;bfe_rx_dma != 0)</a>
<a name="ln385">			bus_dmamap_unload(sc-&gt;bfe_rx_tag, sc-&gt;bfe_rx_map);</a>
<a name="ln386">		if (sc-&gt;bfe_rx_list != NULL)</a>
<a name="ln387">			bus_dmamem_free(sc-&gt;bfe_rx_tag, sc-&gt;bfe_rx_list,</a>
<a name="ln388">			    sc-&gt;bfe_rx_map);</a>
<a name="ln389">		sc-&gt;bfe_rx_dma = 0;</a>
<a name="ln390">		sc-&gt;bfe_rx_list = NULL;</a>
<a name="ln391">		bus_dma_tag_destroy(sc-&gt;bfe_rx_tag);</a>
<a name="ln392">		sc-&gt;bfe_rx_tag = NULL;</a>
<a name="ln393">	}</a>
<a name="ln394"> </a>
<a name="ln395">	/* Tx buffers. */</a>
<a name="ln396">	if (sc-&gt;bfe_txmbuf_tag != NULL) {</a>
<a name="ln397">		for (i = 0; i &lt; BFE_TX_LIST_CNT; i++) {</a>
<a name="ln398">			td = &amp;sc-&gt;bfe_tx_ring[i];</a>
<a name="ln399">			if (td-&gt;bfe_map != NULL) {</a>
<a name="ln400">				bus_dmamap_destroy(sc-&gt;bfe_txmbuf_tag,</a>
<a name="ln401">				    td-&gt;bfe_map);</a>
<a name="ln402">				td-&gt;bfe_map = NULL;</a>
<a name="ln403">			}</a>
<a name="ln404">		}</a>
<a name="ln405">		bus_dma_tag_destroy(sc-&gt;bfe_txmbuf_tag);</a>
<a name="ln406">		sc-&gt;bfe_txmbuf_tag = NULL;</a>
<a name="ln407">	}</a>
<a name="ln408"> </a>
<a name="ln409">	/* Rx buffers. */</a>
<a name="ln410">	if (sc-&gt;bfe_rxmbuf_tag != NULL) {</a>
<a name="ln411">		for (i = 0; i &lt; BFE_RX_LIST_CNT; i++) {</a>
<a name="ln412">			rd = &amp;sc-&gt;bfe_rx_ring[i];</a>
<a name="ln413">			if (rd-&gt;bfe_map != NULL) {</a>
<a name="ln414">				bus_dmamap_destroy(sc-&gt;bfe_rxmbuf_tag,</a>
<a name="ln415">				    rd-&gt;bfe_map);</a>
<a name="ln416">				rd-&gt;bfe_map = NULL;</a>
<a name="ln417">			}</a>
<a name="ln418">		}</a>
<a name="ln419">		if (sc-&gt;bfe_rx_sparemap != NULL) {</a>
<a name="ln420">			bus_dmamap_destroy(sc-&gt;bfe_rxmbuf_tag,</a>
<a name="ln421">			    sc-&gt;bfe_rx_sparemap);</a>
<a name="ln422">			sc-&gt;bfe_rx_sparemap = NULL;</a>
<a name="ln423">		}</a>
<a name="ln424">		bus_dma_tag_destroy(sc-&gt;bfe_rxmbuf_tag);</a>
<a name="ln425">		sc-&gt;bfe_rxmbuf_tag = NULL;</a>
<a name="ln426">	}</a>
<a name="ln427"> </a>
<a name="ln428">	if (sc-&gt;bfe_parent_tag != NULL) {</a>
<a name="ln429">		bus_dma_tag_destroy(sc-&gt;bfe_parent_tag);</a>
<a name="ln430">		sc-&gt;bfe_parent_tag = NULL;</a>
<a name="ln431">	}</a>
<a name="ln432">}</a>
<a name="ln433"> </a>
<a name="ln434">static int</a>
<a name="ln435">bfe_attach(device_t dev)</a>
<a name="ln436">{</a>
<a name="ln437">	struct ifnet *ifp = NULL;</a>
<a name="ln438">	struct bfe_softc *sc;</a>
<a name="ln439">	int error = 0, rid;</a>
<a name="ln440"> </a>
<a name="ln441">	sc = device_get_softc(dev);</a>
<a name="ln442">	mtx_init(&amp;sc-&gt;bfe_mtx, device_get_nameunit(dev), MTX_NETWORK_LOCK,</a>
<a name="ln443">			MTX_DEF);</a>
<a name="ln444">	callout_init_mtx(&amp;sc-&gt;bfe_stat_co, &amp;sc-&gt;bfe_mtx, 0);</a>
<a name="ln445"> </a>
<a name="ln446">	sc-&gt;bfe_dev = dev;</a>
<a name="ln447"> </a>
<a name="ln448">	/*</a>
<a name="ln449">	 * Map control/status registers.</a>
<a name="ln450">	 */</a>
<a name="ln451">	pci_enable_busmaster(dev);</a>
<a name="ln452"> </a>
<a name="ln453">	rid = PCIR_BAR(0);</a>
<a name="ln454">	sc-&gt;bfe_res = bus_alloc_resource_any(dev, SYS_RES_MEMORY, &amp;rid,</a>
<a name="ln455">			RF_ACTIVE);</a>
<a name="ln456">	if (sc-&gt;bfe_res == NULL) {</a>
<a name="ln457">		device_printf(dev, &quot;couldn't map memory\n&quot;);</a>
<a name="ln458">		error = ENXIO;</a>
<a name="ln459">		goto fail;</a>
<a name="ln460">	}</a>
<a name="ln461"> </a>
<a name="ln462">	/* Allocate interrupt */</a>
<a name="ln463">	rid = 0;</a>
<a name="ln464"> </a>
<a name="ln465">	sc-&gt;bfe_irq = bus_alloc_resource_any(dev, SYS_RES_IRQ, &amp;rid,</a>
<a name="ln466">			RF_SHAREABLE | RF_ACTIVE);</a>
<a name="ln467">	if (sc-&gt;bfe_irq == NULL) {</a>
<a name="ln468">		device_printf(dev, &quot;couldn't map interrupt\n&quot;);</a>
<a name="ln469">		error = ENXIO;</a>
<a name="ln470">		goto fail;</a>
<a name="ln471">	}</a>
<a name="ln472"> </a>
<a name="ln473">	if (bfe_dma_alloc(sc) != 0) {</a>
<a name="ln474">		device_printf(dev, &quot;failed to allocate DMA resources\n&quot;);</a>
<a name="ln475">		error = ENXIO;</a>
<a name="ln476">		goto fail;</a>
<a name="ln477">	}</a>
<a name="ln478"> </a>
<a name="ln479">	SYSCTL_ADD_PROC(device_get_sysctl_ctx(dev),</a>
<a name="ln480">	    SYSCTL_CHILDREN(device_get_sysctl_tree(dev)), OID_AUTO,</a>
<a name="ln481">	    &quot;stats&quot;, CTLTYPE_INT | CTLFLAG_RW, sc, 0, sysctl_bfe_stats,</a>
<a name="ln482">	    &quot;I&quot;, &quot;Statistics&quot;);</a>
<a name="ln483"> </a>
<a name="ln484">	/* Set up ifnet structure */</a>
<a name="ln485">	ifp = sc-&gt;bfe_ifp = if_alloc(IFT_ETHER);</a>
<a name="ln486">	if (ifp == NULL) {</a>
<a name="ln487">		device_printf(dev, &quot;failed to if_alloc()\n&quot;);</a>
<a name="ln488">		error = ENOSPC;</a>
<a name="ln489">		goto fail;</a>
<a name="ln490">	}</a>
<a name="ln491">	ifp-&gt;if_softc = sc;</a>
<a name="ln492">	if_initname(ifp, device_get_name(dev), device_get_unit(dev));</a>
<a name="ln493">	ifp-&gt;if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;</a>
<a name="ln494">	ifp-&gt;if_ioctl = bfe_ioctl;</a>
<a name="ln495">	ifp-&gt;if_start = bfe_start;</a>
<a name="ln496">	ifp-&gt;if_init = bfe_init;</a>
<a name="ln497">	IFQ_SET_MAXLEN(&amp;ifp-&gt;if_snd, BFE_TX_QLEN);</a>
<a name="ln498">	ifp-&gt;if_snd.ifq_drv_maxlen = BFE_TX_QLEN;</a>
<a name="ln499">	IFQ_SET_READY(&amp;ifp-&gt;if_snd);</a>
<a name="ln500"> </a>
<a name="ln501">	bfe_get_config(sc);</a>
<a name="ln502"> </a>
<a name="ln503">	/* Reset the chip and turn on the PHY */</a>
<a name="ln504">	BFE_LOCK(sc);</a>
<a name="ln505">	bfe_chip_reset(sc);</a>
<a name="ln506">	BFE_UNLOCK(sc);</a>
<a name="ln507"> </a>
<a name="ln508">	error = mii_attach(dev, &amp;sc-&gt;bfe_miibus, ifp, bfe_ifmedia_upd,</a>
<a name="ln509">	    bfe_ifmedia_sts, BMSR_DEFCAPMASK, sc-&gt;bfe_phyaddr, MII_OFFSET_ANY,</a>
<a name="ln510">	    0);</a>
<a name="ln511">	if (error != 0) {</a>
<a name="ln512">		device_printf(dev, &quot;attaching PHYs failed\n&quot;);</a>
<a name="ln513">		goto fail;</a>
<a name="ln514">	}</a>
<a name="ln515"> </a>
<a name="ln516">	ether_ifattach(ifp, sc-&gt;bfe_enaddr);</a>
<a name="ln517"> </a>
<a name="ln518">	/*</a>
<a name="ln519">	 * Tell the upper layer(s) we support long frames.</a>
<a name="ln520">	 */</a>
<a name="ln521">	ifp-&gt;if_hdrlen = sizeof(struct ether_vlan_header);</a>
<a name="ln522">	ifp-&gt;if_capabilities |= IFCAP_VLAN_MTU;</a>
<a name="ln523">	ifp-&gt;if_capenable |= IFCAP_VLAN_MTU;</a>
<a name="ln524"> </a>
<a name="ln525">	/*</a>
<a name="ln526">	 * Hook interrupt last to avoid having to lock softc</a>
<a name="ln527">	 */</a>
<a name="ln528">	error = bus_setup_intr(dev, sc-&gt;bfe_irq, INTR_TYPE_NET | INTR_MPSAFE,</a>
<a name="ln529">			NULL, bfe_intr, sc, &amp;sc-&gt;bfe_intrhand);</a>
<a name="ln530"> </a>
<a name="ln531">	if (error) {</a>
<a name="ln532">		device_printf(dev, &quot;couldn't set up irq\n&quot;);</a>
<a name="ln533">		goto fail;</a>
<a name="ln534">	}</a>
<a name="ln535">fail:</a>
<a name="ln536">	if (error != 0)</a>
<a name="ln537">		bfe_detach(dev);</a>
<a name="ln538">	return (error);</a>
<a name="ln539">}</a>
<a name="ln540"> </a>
<a name="ln541">static int</a>
<a name="ln542">bfe_detach(device_t dev)</a>
<a name="ln543">{</a>
<a name="ln544">	struct bfe_softc *sc;</a>
<a name="ln545">	struct ifnet *ifp;</a>
<a name="ln546"> </a>
<a name="ln547">	sc = device_get_softc(dev);</a>
<a name="ln548"> </a>
<a name="ln549">	ifp = sc-&gt;bfe_ifp;</a>
<a name="ln550"> </a>
<a name="ln551">	if (device_is_attached(dev)) {</a>
<a name="ln552">		BFE_LOCK(sc);</a>
<a name="ln553">		sc-&gt;bfe_flags |= BFE_FLAG_DETACH;</a>
<a name="ln554">		bfe_stop(sc);</a>
<a name="ln555">		BFE_UNLOCK(sc);</a>
<a name="ln556">		callout_drain(&amp;sc-&gt;bfe_stat_co);</a>
<a name="ln557">		if (ifp != NULL)</a>
<a name="ln558">			ether_ifdetach(ifp);</a>
<a name="ln559">	}</a>
<a name="ln560"> </a>
<a name="ln561">	BFE_LOCK(sc);</a>
<a name="ln562">	bfe_chip_reset(sc);</a>
<a name="ln563">	BFE_UNLOCK(sc);</a>
<a name="ln564"> </a>
<a name="ln565">	bus_generic_detach(dev);</a>
<a name="ln566">	if (sc-&gt;bfe_miibus != NULL)</a>
<a name="ln567">		device_delete_child(dev, sc-&gt;bfe_miibus);</a>
<a name="ln568"> </a>
<a name="ln569">	bfe_release_resources(sc);</a>
<a name="ln570">	bfe_dma_free(sc);</a>
<a name="ln571">	mtx_destroy(&amp;sc-&gt;bfe_mtx);</a>
<a name="ln572"> </a>
<a name="ln573">	return (0);</a>
<a name="ln574">}</a>
<a name="ln575"> </a>
<a name="ln576">/*</a>
<a name="ln577"> * Stop all chip I/O so that the kernel's probe routines don't</a>
<a name="ln578"> * get confused by errant DMAs when rebooting.</a>
<a name="ln579"> */</a>
<a name="ln580">static int</a>
<a name="ln581">bfe_shutdown(device_t dev)</a>
<a name="ln582">{</a>
<a name="ln583">	struct bfe_softc *sc;</a>
<a name="ln584"> </a>
<a name="ln585">	sc = device_get_softc(dev);</a>
<a name="ln586">	BFE_LOCK(sc);</a>
<a name="ln587">	bfe_stop(sc);</a>
<a name="ln588"> </a>
<a name="ln589">	BFE_UNLOCK(sc);</a>
<a name="ln590"> </a>
<a name="ln591">	return (0);</a>
<a name="ln592">}</a>
<a name="ln593"> </a>
<a name="ln594">static int</a>
<a name="ln595">bfe_suspend(device_t dev)</a>
<a name="ln596">{</a>
<a name="ln597">	struct bfe_softc *sc;</a>
<a name="ln598"> </a>
<a name="ln599">	sc = device_get_softc(dev);</a>
<a name="ln600">	BFE_LOCK(sc);</a>
<a name="ln601">	bfe_stop(sc);</a>
<a name="ln602">	BFE_UNLOCK(sc);</a>
<a name="ln603"> </a>
<a name="ln604">	return (0);</a>
<a name="ln605">}</a>
<a name="ln606"> </a>
<a name="ln607">static int</a>
<a name="ln608">bfe_resume(device_t dev)</a>
<a name="ln609">{</a>
<a name="ln610">	struct bfe_softc *sc;</a>
<a name="ln611">	struct ifnet *ifp;</a>
<a name="ln612"> </a>
<a name="ln613">	sc = device_get_softc(dev);</a>
<a name="ln614">	ifp = sc-&gt;bfe_ifp;</a>
<a name="ln615">	BFE_LOCK(sc);</a>
<a name="ln616">	bfe_chip_reset(sc);</a>
<a name="ln617">	if (ifp-&gt;if_flags &amp; IFF_UP) {</a>
<a name="ln618">		bfe_init_locked(sc);</a>
<a name="ln619">		if (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING &amp;&amp;</a>
<a name="ln620">		    !IFQ_DRV_IS_EMPTY(&amp;ifp-&gt;if_snd))</a>
<a name="ln621">			bfe_start_locked(ifp);</a>
<a name="ln622">	}</a>
<a name="ln623">	BFE_UNLOCK(sc);</a>
<a name="ln624"> </a>
<a name="ln625">	return (0);</a>
<a name="ln626">}</a>
<a name="ln627"> </a>
<a name="ln628">static int</a>
<a name="ln629">bfe_miibus_readreg(device_t dev, int phy, int reg)</a>
<a name="ln630">{</a>
<a name="ln631">	struct bfe_softc *sc;</a>
<a name="ln632">	u_int32_t ret;</a>
<a name="ln633"> </a>
<a name="ln634">	sc = device_get_softc(dev);</a>
<a name="ln635">	bfe_readphy(sc, reg, &amp;ret);</a>
<a name="ln636"> </a>
<a name="ln637">	return (ret);</a>
<a name="ln638">}</a>
<a name="ln639"> </a>
<a name="ln640">static int</a>
<a name="ln641">bfe_miibus_writereg(device_t dev, int phy, int reg, int val)</a>
<a name="ln642">{</a>
<a name="ln643">	struct bfe_softc *sc;</a>
<a name="ln644"> </a>
<a name="ln645">	sc = device_get_softc(dev);</a>
<a name="ln646">	bfe_writephy(sc, reg, val);</a>
<a name="ln647"> </a>
<a name="ln648">	return (0);</a>
<a name="ln649">}</a>
<a name="ln650"> </a>
<a name="ln651">static void</a>
<a name="ln652">bfe_miibus_statchg(device_t dev)</a>
<a name="ln653">{</a>
<a name="ln654">	struct bfe_softc *sc;</a>
<a name="ln655">	struct mii_data *mii;</a>
<a name="ln656">	u_int32_t val, flow;</a>
<a name="ln657"> </a>
<a name="ln658">	sc = device_get_softc(dev);</a>
<a name="ln659">	mii = device_get_softc(sc-&gt;bfe_miibus);</a>
<a name="ln660"> </a>
<a name="ln661">	sc-&gt;bfe_flags &amp;= ~BFE_FLAG_LINK;</a>
<a name="ln662">	if ((mii-&gt;mii_media_status &amp; (IFM_ACTIVE | IFM_AVALID)) ==</a>
<a name="ln663">	    (IFM_ACTIVE | IFM_AVALID)) {</a>
<a name="ln664">		switch (IFM_SUBTYPE(mii-&gt;mii_media_active)) {</a>
<a name="ln665">		case IFM_10_T:</a>
<a name="ln666">		case IFM_100_TX:</a>
<a name="ln667">			sc-&gt;bfe_flags |= BFE_FLAG_LINK;</a>
<a name="ln668">			break;</a>
<a name="ln669">		default:</a>
<a name="ln670">			break;</a>
<a name="ln671">		}</a>
<a name="ln672">	}</a>
<a name="ln673"> </a>
<a name="ln674">	/* XXX Should stop Rx/Tx engine prior to touching MAC. */</a>
<a name="ln675">	val = CSR_READ_4(sc, BFE_TX_CTRL);</a>
<a name="ln676">	val &amp;= ~BFE_TX_DUPLEX;</a>
<a name="ln677">	if ((IFM_OPTIONS(mii-&gt;mii_media_active) &amp; IFM_FDX) != 0) {</a>
<a name="ln678">		val |= BFE_TX_DUPLEX;</a>
<a name="ln679">		flow = 0;</a>
<a name="ln680">#ifdef notyet</a>
<a name="ln681">		flow = CSR_READ_4(sc, BFE_RXCONF);</a>
<a name="ln682">		flow &amp;= ~BFE_RXCONF_FLOW;</a>
<a name="ln683">		if ((IFM_OPTIONS(sc-&gt;sc_mii-&gt;mii_media_active) &amp;</a>
<a name="ln684">		    IFM_ETH_RXPAUSE) != 0)</a>
<a name="ln685">			flow |= BFE_RXCONF_FLOW;</a>
<a name="ln686">		CSR_WRITE_4(sc, BFE_RXCONF, flow);</a>
<a name="ln687">		/*</a>
<a name="ln688">		 * It seems that the hardware has Tx pause issues</a>
<a name="ln689">		 * so enable only Rx pause.</a>
<a name="ln690">		 */</a>
<a name="ln691">		flow = CSR_READ_4(sc, BFE_MAC_FLOW);</a>
<a name="ln692">		flow &amp;= ~BFE_FLOW_PAUSE_ENAB;</a>
<a name="ln693">		CSR_WRITE_4(sc, BFE_MAC_FLOW, flow);</a>
<a name="ln694">#endif</a>
<a name="ln695">	}</a>
<a name="ln696">	CSR_WRITE_4(sc, BFE_TX_CTRL, val);</a>
<a name="ln697">}</a>
<a name="ln698"> </a>
<a name="ln699">static void</a>
<a name="ln700">bfe_tx_ring_free(struct bfe_softc *sc)</a>
<a name="ln701">{</a>
<a name="ln702">	int i;</a>
<a name="ln703"> </a>
<a name="ln704">	for(i = 0; i &lt; BFE_TX_LIST_CNT; i++) {</a>
<a name="ln705">		if (sc-&gt;bfe_tx_ring[i].bfe_mbuf != NULL) {</a>
<a name="ln706">			bus_dmamap_sync(sc-&gt;bfe_txmbuf_tag,</a>
<a name="ln707">			    sc-&gt;bfe_tx_ring[i].bfe_map, BUS_DMASYNC_POSTWRITE);</a>
<a name="ln708">			bus_dmamap_unload(sc-&gt;bfe_txmbuf_tag,</a>
<a name="ln709">			    sc-&gt;bfe_tx_ring[i].bfe_map);</a>
<a name="ln710">			m_freem(sc-&gt;bfe_tx_ring[i].bfe_mbuf);</a>
<a name="ln711">			sc-&gt;bfe_tx_ring[i].bfe_mbuf = NULL;</a>
<a name="ln712">		}</a>
<a name="ln713">	}</a>
<a name="ln714">	bzero(sc-&gt;bfe_tx_list, BFE_TX_LIST_SIZE);</a>
<a name="ln715">	bus_dmamap_sync(sc-&gt;bfe_tx_tag, sc-&gt;bfe_tx_map,</a>
<a name="ln716">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln717">}</a>
<a name="ln718"> </a>
<a name="ln719">static void</a>
<a name="ln720">bfe_rx_ring_free(struct bfe_softc *sc)</a>
<a name="ln721">{</a>
<a name="ln722">	int i;</a>
<a name="ln723"> </a>
<a name="ln724">	for (i = 0; i &lt; BFE_RX_LIST_CNT; i++) {</a>
<a name="ln725">		if (sc-&gt;bfe_rx_ring[i].bfe_mbuf != NULL) {</a>
<a name="ln726">			bus_dmamap_sync(sc-&gt;bfe_rxmbuf_tag,</a>
<a name="ln727">			    sc-&gt;bfe_rx_ring[i].bfe_map, BUS_DMASYNC_POSTREAD);</a>
<a name="ln728">			bus_dmamap_unload(sc-&gt;bfe_rxmbuf_tag,</a>
<a name="ln729">			    sc-&gt;bfe_rx_ring[i].bfe_map);</a>
<a name="ln730">			m_freem(sc-&gt;bfe_rx_ring[i].bfe_mbuf);</a>
<a name="ln731">			sc-&gt;bfe_rx_ring[i].bfe_mbuf = NULL;</a>
<a name="ln732">		}</a>
<a name="ln733">	}</a>
<a name="ln734">	bzero(sc-&gt;bfe_rx_list, BFE_RX_LIST_SIZE);</a>
<a name="ln735">	bus_dmamap_sync(sc-&gt;bfe_rx_tag, sc-&gt;bfe_rx_map,</a>
<a name="ln736">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln737">}</a>
<a name="ln738"> </a>
<a name="ln739">static int</a>
<a name="ln740">bfe_list_rx_init(struct bfe_softc *sc)</a>
<a name="ln741">{</a>
<a name="ln742">	struct bfe_rx_data *rd;</a>
<a name="ln743">	int i;</a>
<a name="ln744"> </a>
<a name="ln745">	sc-&gt;bfe_rx_prod = sc-&gt;bfe_rx_cons = 0;</a>
<a name="ln746">	bzero(sc-&gt;bfe_rx_list, BFE_RX_LIST_SIZE);</a>
<a name="ln747">	for (i = 0; i &lt; BFE_RX_LIST_CNT; i++) {</a>
<a name="ln748">		rd = &amp;sc-&gt;bfe_rx_ring[i];</a>
<a name="ln749">		rd-&gt;bfe_mbuf = NULL;</a>
<a name="ln750">		rd-&gt;bfe_ctrl = 0;</a>
<a name="ln751">		if (bfe_list_newbuf(sc, i) != 0)</a>
<a name="ln752">			return (ENOBUFS);</a>
<a name="ln753">	}</a>
<a name="ln754"> </a>
<a name="ln755">	bus_dmamap_sync(sc-&gt;bfe_rx_tag, sc-&gt;bfe_rx_map,</a>
<a name="ln756">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln757">	CSR_WRITE_4(sc, BFE_DMARX_PTR, (i * sizeof(struct bfe_desc)));</a>
<a name="ln758"> </a>
<a name="ln759">	return (0);</a>
<a name="ln760">}</a>
<a name="ln761"> </a>
<a name="ln762">static void</a>
<a name="ln763">bfe_list_tx_init(struct bfe_softc *sc)</a>
<a name="ln764">{</a>
<a name="ln765">	int i;</a>
<a name="ln766"> </a>
<a name="ln767">	sc-&gt;bfe_tx_cnt = sc-&gt;bfe_tx_prod = sc-&gt;bfe_tx_cons = 0;</a>
<a name="ln768">	bzero(sc-&gt;bfe_tx_list, BFE_TX_LIST_SIZE);</a>
<a name="ln769">	for (i = 0; i &lt; BFE_TX_LIST_CNT; i++)</a>
<a name="ln770">		sc-&gt;bfe_tx_ring[i].bfe_mbuf = NULL;</a>
<a name="ln771"> </a>
<a name="ln772">	bus_dmamap_sync(sc-&gt;bfe_tx_tag, sc-&gt;bfe_tx_map,</a>
<a name="ln773">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln774">}</a>
<a name="ln775"> </a>
<a name="ln776">static void</a>
<a name="ln777">bfe_discard_buf(struct bfe_softc *sc, int c)</a>
<a name="ln778">{</a>
<a name="ln779">	struct bfe_rx_data *r;</a>
<a name="ln780">	struct bfe_desc *d;</a>
<a name="ln781"> </a>
<a name="ln782">	r = &amp;sc-&gt;bfe_rx_ring[c];</a>
<a name="ln783">	d = &amp;sc-&gt;bfe_rx_list[c];</a>
<a name="ln784">	d-&gt;bfe_ctrl = htole32(r-&gt;bfe_ctrl);</a>
<a name="ln785">}</a>
<a name="ln786"> </a>
<a name="ln787">static int</a>
<a name="ln788">bfe_list_newbuf(struct bfe_softc *sc, int c)</a>
<a name="ln789">{</a>
<a name="ln790">	struct bfe_rxheader *rx_header;</a>
<a name="ln791">	struct bfe_desc *d;</a>
<a name="ln792">	struct bfe_rx_data *r;</a>
<a name="ln793">	struct mbuf *m;</a>
<a name="ln794">	bus_dma_segment_t segs[1];</a>
<a name="ln795">	bus_dmamap_t map;</a>
<a name="ln796">	u_int32_t ctrl;</a>
<a name="ln797">	int nsegs;</a>
<a name="ln798"> </a>
<a name="ln799">	m = m_getcl(M_NOWAIT, MT_DATA, M_PKTHDR);</a>
<a name="ln800">	if (m == NULL)</a>
<a name="ln801">		return (ENOBUFS);</a>
<a name="ln802">	m-&gt;m_len = m-&gt;m_pkthdr.len = MCLBYTES;</a>
<a name="ln803"> </a>
<a name="ln804">	if (bus_dmamap_load_mbuf_sg(sc-&gt;bfe_rxmbuf_tag, sc-&gt;bfe_rx_sparemap,</a>
<a name="ln805">	    m, segs, &amp;nsegs, 0) != 0) {</a>
<a name="ln806">		m_freem(m);</a>
<a name="ln807">		return (ENOBUFS);</a>
<a name="ln808">	}</a>
<a name="ln809"> </a>
<a name="ln810">	KASSERT(nsegs == 1, (&quot;%s: %d segments returned!&quot;, __func__, nsegs));</a>
<a name="ln811">	r = &amp;sc-&gt;bfe_rx_ring[c];</a>
<a name="ln812">	if (r-&gt;bfe_mbuf != NULL) {</a>
<a name="ln813">		bus_dmamap_sync(sc-&gt;bfe_rxmbuf_tag, r-&gt;bfe_map,</a>
<a name="ln814">		    BUS_DMASYNC_POSTREAD);</a>
<a name="ln815">		bus_dmamap_unload(sc-&gt;bfe_rxmbuf_tag, r-&gt;bfe_map);</a>
<a name="ln816">	}</a>
<a name="ln817">	map = r-&gt;bfe_map;</a>
<a name="ln818">	r-&gt;bfe_map = sc-&gt;bfe_rx_sparemap;</a>
<a name="ln819">	sc-&gt;bfe_rx_sparemap = map;</a>
<a name="ln820">	r-&gt;bfe_mbuf = m;</a>
<a name="ln821"> </a>
<a name="ln822">	rx_header = mtod(m, struct bfe_rxheader *);</a>
<a name="ln823">	rx_header-&gt;len = 0;</a>
<a name="ln824">	rx_header-&gt;flags = 0;</a>
<a name="ln825">	bus_dmamap_sync(sc-&gt;bfe_rxmbuf_tag, r-&gt;bfe_map, BUS_DMASYNC_PREREAD);</a>
<a name="ln826">	</a>
<a name="ln827">	ctrl = segs[0].ds_len &amp; BFE_DESC_LEN;</a>
<a name="ln828">	KASSERT(ctrl &gt; ETHER_MAX_LEN + 32, (&quot;%s: buffer size too small(%d)!&quot;,</a>
<a name="ln829">	    __func__, ctrl));</a>
<a name="ln830">	if (c == BFE_RX_LIST_CNT - 1)</a>
<a name="ln831">		ctrl |= BFE_DESC_EOT;</a>
<a name="ln832">	r-&gt;bfe_ctrl = ctrl;</a>
<a name="ln833"> </a>
<a name="ln834">	d = &amp;sc-&gt;bfe_rx_list[c];</a>
<a name="ln835">	d-&gt;bfe_ctrl = htole32(ctrl);</a>
<a name="ln836">	/* The chip needs all addresses to be added to BFE_PCI_DMA. */</a>
<a name="ln837">	d-&gt;bfe_addr = htole32(BFE_ADDR_LO(segs[0].ds_addr) + BFE_PCI_DMA);</a>
<a name="ln838"> </a>
<a name="ln839">	return (0);</a>
<a name="ln840">}</a>
<a name="ln841"> </a>
<a name="ln842">static void</a>
<a name="ln843">bfe_get_config(struct bfe_softc *sc)</a>
<a name="ln844">{</a>
<a name="ln845">	u_int8_t eeprom[128];</a>
<a name="ln846"> </a>
<a name="ln847">	bfe_read_eeprom(sc, eeprom);</a>
<a name="ln848"> </a>
<a name="ln849">	sc-&gt;bfe_enaddr[0] = eeprom[79];</a>
<a name="ln850">	sc-&gt;bfe_enaddr[1] = eeprom[78];</a>
<a name="ln851">	sc-&gt;bfe_enaddr[2] = eeprom[81];</a>
<a name="ln852">	sc-&gt;bfe_enaddr[3] = eeprom[80];</a>
<a name="ln853">	sc-&gt;bfe_enaddr[4] = eeprom[83];</a>
<a name="ln854">	sc-&gt;bfe_enaddr[5] = eeprom[82];</a>
<a name="ln855"> </a>
<a name="ln856">	sc-&gt;bfe_phyaddr = eeprom[90] &amp; 0x1f;</a>
<a name="ln857">	sc-&gt;bfe_mdc_port = (eeprom[90] &gt;&gt; 14) &amp; 0x1;</a>
<a name="ln858"> </a>
<a name="ln859">	sc-&gt;bfe_core_unit = 0;</a>
<a name="ln860">	sc-&gt;bfe_dma_offset = BFE_PCI_DMA;</a>
<a name="ln861">}</a>
<a name="ln862"> </a>
<a name="ln863">static void</a>
<a name="ln864">bfe_pci_setup(struct bfe_softc *sc, u_int32_t cores)</a>
<a name="ln865">{</a>
<a name="ln866">	u_int32_t bar_orig, pci_rev, val;</a>
<a name="ln867"> </a>
<a name="ln868">	bar_orig = pci_read_config(sc-&gt;bfe_dev, BFE_BAR0_WIN, 4);</a>
<a name="ln869">	pci_write_config(sc-&gt;bfe_dev, BFE_BAR0_WIN, BFE_REG_PCI, 4);</a>
<a name="ln870">	pci_rev = CSR_READ_4(sc, BFE_SBIDHIGH) &amp; BFE_RC_MASK;</a>
<a name="ln871"> </a>
<a name="ln872">	val = CSR_READ_4(sc, BFE_SBINTVEC);</a>
<a name="ln873">	val |= cores;</a>
<a name="ln874">	CSR_WRITE_4(sc, BFE_SBINTVEC, val);</a>
<a name="ln875"> </a>
<a name="ln876">	val = CSR_READ_4(sc, BFE_SSB_PCI_TRANS_2);</a>
<a name="ln877">	val |= BFE_SSB_PCI_PREF | BFE_SSB_PCI_BURST;</a>
<a name="ln878">	CSR_WRITE_4(sc, BFE_SSB_PCI_TRANS_2, val);</a>
<a name="ln879"> </a>
<a name="ln880">	pci_write_config(sc-&gt;bfe_dev, BFE_BAR0_WIN, bar_orig, 4);</a>
<a name="ln881">}</a>
<a name="ln882"> </a>
<a name="ln883">static void</a>
<a name="ln884">bfe_clear_stats(struct bfe_softc *sc)</a>
<a name="ln885">{</a>
<a name="ln886">	uint32_t reg;</a>
<a name="ln887"> </a>
<a name="ln888">	BFE_LOCK_ASSERT(sc);</a>
<a name="ln889"> </a>
<a name="ln890">	CSR_WRITE_4(sc, BFE_MIB_CTRL, BFE_MIB_CLR_ON_READ);</a>
<a name="ln891">	for (reg = BFE_TX_GOOD_O; reg &lt;= BFE_TX_PAUSE; reg += 4)</a>
<a name="ln892">		CSR_READ_4(sc, reg);</a>
<a name="ln893">	for (reg = BFE_RX_GOOD_O; reg &lt;= BFE_RX_NPAUSE; reg += 4)</a>
<a name="ln894">		CSR_READ_4(sc, reg);</a>
<a name="ln895">}</a>
<a name="ln896"> </a>
<a name="ln897">static int</a>
<a name="ln898">bfe_resetphy(struct bfe_softc *sc)</a>
<a name="ln899">{</a>
<a name="ln900">	u_int32_t val;</a>
<a name="ln901"> </a>
<a name="ln902">	bfe_writephy(sc, 0, BMCR_RESET);</a>
<a name="ln903">	DELAY(100);</a>
<a name="ln904">	bfe_readphy(sc, 0, &amp;val);</a>
<a name="ln905">	if (val &amp; BMCR_RESET) {</a>
<a name="ln906">		device_printf(sc-&gt;bfe_dev, &quot;PHY Reset would not complete.\n&quot;);</a>
<a name="ln907">		return (ENXIO);</a>
<a name="ln908">	}</a>
<a name="ln909">	return (0);</a>
<a name="ln910">}</a>
<a name="ln911"> </a>
<a name="ln912">static void</a>
<a name="ln913">bfe_chip_halt(struct bfe_softc *sc)</a>
<a name="ln914">{</a>
<a name="ln915">	BFE_LOCK_ASSERT(sc);</a>
<a name="ln916">	/* disable interrupts - not that it actually does..*/</a>
<a name="ln917">	CSR_WRITE_4(sc, BFE_IMASK, 0);</a>
<a name="ln918">	CSR_READ_4(sc, BFE_IMASK);</a>
<a name="ln919"> </a>
<a name="ln920">	CSR_WRITE_4(sc, BFE_ENET_CTRL, BFE_ENET_DISABLE);</a>
<a name="ln921">	bfe_wait_bit(sc, BFE_ENET_CTRL, BFE_ENET_DISABLE, 200, 1);</a>
<a name="ln922"> </a>
<a name="ln923">	CSR_WRITE_4(sc, BFE_DMARX_CTRL, 0);</a>
<a name="ln924">	CSR_WRITE_4(sc, BFE_DMATX_CTRL, 0);</a>
<a name="ln925">	DELAY(10);</a>
<a name="ln926">}</a>
<a name="ln927"> </a>
<a name="ln928">static void</a>
<a name="ln929">bfe_chip_reset(struct bfe_softc *sc)</a>
<a name="ln930">{</a>
<a name="ln931">	u_int32_t val;</a>
<a name="ln932"> </a>
<a name="ln933">	BFE_LOCK_ASSERT(sc);</a>
<a name="ln934"> </a>
<a name="ln935">	/* Set the interrupt vector for the enet core */</a>
<a name="ln936">	bfe_pci_setup(sc, BFE_INTVEC_ENET0);</a>
<a name="ln937"> </a>
<a name="ln938">	/* is core up? */</a>
<a name="ln939">	val = CSR_READ_4(sc, BFE_SBTMSLOW) &amp;</a>
<a name="ln940">	    (BFE_RESET | BFE_REJECT | BFE_CLOCK);</a>
<a name="ln941">	if (val == BFE_CLOCK) {</a>
<a name="ln942">		/* It is, so shut it down */</a>
<a name="ln943">		CSR_WRITE_4(sc, BFE_RCV_LAZY, 0);</a>
<a name="ln944">		CSR_WRITE_4(sc, BFE_ENET_CTRL, BFE_ENET_DISABLE);</a>
<a name="ln945">		bfe_wait_bit(sc, BFE_ENET_CTRL, BFE_ENET_DISABLE, 100, 1);</a>
<a name="ln946">		CSR_WRITE_4(sc, BFE_DMATX_CTRL, 0);</a>
<a name="ln947">		if (CSR_READ_4(sc, BFE_DMARX_STAT) &amp; BFE_STAT_EMASK)</a>
<a name="ln948">			bfe_wait_bit(sc, BFE_DMARX_STAT, BFE_STAT_SIDLE,</a>
<a name="ln949">			    100, 0);</a>
<a name="ln950">		CSR_WRITE_4(sc, BFE_DMARX_CTRL, 0);</a>
<a name="ln951">	}</a>
<a name="ln952"> </a>
<a name="ln953">	bfe_core_reset(sc);</a>
<a name="ln954">	bfe_clear_stats(sc);</a>
<a name="ln955"> </a>
<a name="ln956">	/*</a>
<a name="ln957">	 * We want the phy registers to be accessible even when</a>
<a name="ln958">	 * the driver is &quot;downed&quot; so initialize MDC preamble, frequency,</a>
<a name="ln959">	 * and whether internal or external phy here.</a>
<a name="ln960">	 */</a>
<a name="ln961"> </a>
<a name="ln962">	/* 4402 has 62.5Mhz SB clock and internal phy */</a>
<a name="ln963">	CSR_WRITE_4(sc, BFE_MDIO_CTRL, 0x8d);</a>
<a name="ln964"> </a>
<a name="ln965">	/* Internal or external PHY? */</a>
<a name="ln966">	val = CSR_READ_4(sc, BFE_DEVCTRL);</a>
<a name="ln967">	if (!(val &amp; BFE_IPP))</a>
<a name="ln968">		CSR_WRITE_4(sc, BFE_ENET_CTRL, BFE_ENET_EPSEL);</a>
<a name="ln969">	else if (CSR_READ_4(sc, BFE_DEVCTRL) &amp; BFE_EPR) {</a>
<a name="ln970">		BFE_AND(sc, BFE_DEVCTRL, ~BFE_EPR);</a>
<a name="ln971">		DELAY(100);</a>
<a name="ln972">	}</a>
<a name="ln973"> </a>
<a name="ln974">	/* Enable CRC32 generation and set proper LED modes */</a>
<a name="ln975">	BFE_OR(sc, BFE_MAC_CTRL, BFE_CTRL_CRC32_ENAB | BFE_CTRL_LED);</a>
<a name="ln976"> </a>
<a name="ln977">	/* Reset or clear powerdown control bit  */</a>
<a name="ln978">	BFE_AND(sc, BFE_MAC_CTRL, ~BFE_CTRL_PDOWN);</a>
<a name="ln979"> </a>
<a name="ln980">	CSR_WRITE_4(sc, BFE_RCV_LAZY, ((1 &lt;&lt; BFE_LAZY_FC_SHIFT) &amp;</a>
<a name="ln981">				BFE_LAZY_FC_MASK));</a>
<a name="ln982"> </a>
<a name="ln983">	/*</a>
<a name="ln984">	 * We don't want lazy interrupts, so just send them at</a>
<a name="ln985">	 * the end of a frame, please</a>
<a name="ln986">	 */</a>
<a name="ln987">	BFE_OR(sc, BFE_RCV_LAZY, 0);</a>
<a name="ln988"> </a>
<a name="ln989">	/* Set max lengths, accounting for VLAN tags */</a>
<a name="ln990">	CSR_WRITE_4(sc, BFE_RXMAXLEN, ETHER_MAX_LEN+32);</a>
<a name="ln991">	CSR_WRITE_4(sc, BFE_TXMAXLEN, ETHER_MAX_LEN+32);</a>
<a name="ln992"> </a>
<a name="ln993">	/* Set watermark XXX - magic */</a>
<a name="ln994">	CSR_WRITE_4(sc, BFE_TX_WMARK, 56);</a>
<a name="ln995"> </a>
<a name="ln996">	/*</a>
<a name="ln997">	 * Initialise DMA channels</a>
<a name="ln998">	 * - not forgetting dma addresses need to be added to BFE_PCI_DMA</a>
<a name="ln999">	 */</a>
<a name="ln1000">	CSR_WRITE_4(sc, BFE_DMATX_CTRL, BFE_TX_CTRL_ENABLE);</a>
<a name="ln1001">	CSR_WRITE_4(sc, BFE_DMATX_ADDR, sc-&gt;bfe_tx_dma + BFE_PCI_DMA);</a>
<a name="ln1002"> </a>
<a name="ln1003">	CSR_WRITE_4(sc, BFE_DMARX_CTRL, (BFE_RX_OFFSET &lt;&lt; BFE_RX_CTRL_ROSHIFT) |</a>
<a name="ln1004">			BFE_RX_CTRL_ENABLE);</a>
<a name="ln1005">	CSR_WRITE_4(sc, BFE_DMARX_ADDR, sc-&gt;bfe_rx_dma + BFE_PCI_DMA);</a>
<a name="ln1006"> </a>
<a name="ln1007">	bfe_resetphy(sc);</a>
<a name="ln1008">	bfe_setupphy(sc);</a>
<a name="ln1009">}</a>
<a name="ln1010"> </a>
<a name="ln1011">static void</a>
<a name="ln1012">bfe_core_disable(struct bfe_softc *sc)</a>
<a name="ln1013">{</a>
<a name="ln1014">	if ((CSR_READ_4(sc, BFE_SBTMSLOW)) &amp; BFE_RESET)</a>
<a name="ln1015">		return;</a>
<a name="ln1016"> </a>
<a name="ln1017">	/*</a>
<a name="ln1018">	 * Set reject, wait for it set, then wait for the core to stop</a>
<a name="ln1019">	 * being busy, then set reset and reject and enable the clocks.</a>
<a name="ln1020">	 */</a>
<a name="ln1021">	CSR_WRITE_4(sc, BFE_SBTMSLOW, (BFE_REJECT | BFE_CLOCK));</a>
<a name="ln1022">	bfe_wait_bit(sc, BFE_SBTMSLOW, BFE_REJECT, 1000, 0);</a>
<a name="ln1023">	bfe_wait_bit(sc, BFE_SBTMSHIGH, BFE_BUSY, 1000, 1);</a>
<a name="ln1024">	CSR_WRITE_4(sc, BFE_SBTMSLOW, (BFE_FGC | BFE_CLOCK | BFE_REJECT |</a>
<a name="ln1025">				BFE_RESET));</a>
<a name="ln1026">	CSR_READ_4(sc, BFE_SBTMSLOW);</a>
<a name="ln1027">	DELAY(10);</a>
<a name="ln1028">	/* Leave reset and reject set */</a>
<a name="ln1029">	CSR_WRITE_4(sc, BFE_SBTMSLOW, (BFE_REJECT | BFE_RESET));</a>
<a name="ln1030">	DELAY(10);</a>
<a name="ln1031">}</a>
<a name="ln1032"> </a>
<a name="ln1033">static void</a>
<a name="ln1034">bfe_core_reset(struct bfe_softc *sc)</a>
<a name="ln1035">{</a>
<a name="ln1036">	u_int32_t val;</a>
<a name="ln1037"> </a>
<a name="ln1038">	/* Disable the core */</a>
<a name="ln1039">	bfe_core_disable(sc);</a>
<a name="ln1040"> </a>
<a name="ln1041">	/* and bring it back up */</a>
<a name="ln1042">	CSR_WRITE_4(sc, BFE_SBTMSLOW, (BFE_RESET | BFE_CLOCK | BFE_FGC));</a>
<a name="ln1043">	CSR_READ_4(sc, BFE_SBTMSLOW);</a>
<a name="ln1044">	DELAY(10);</a>
<a name="ln1045"> </a>
<a name="ln1046">	/* Chip bug, clear SERR, IB and TO if they are set. */</a>
<a name="ln1047">	if (CSR_READ_4(sc, BFE_SBTMSHIGH) &amp; BFE_SERR)</a>
<a name="ln1048">		CSR_WRITE_4(sc, BFE_SBTMSHIGH, 0);</a>
<a name="ln1049">	val = CSR_READ_4(sc, BFE_SBIMSTATE);</a>
<a name="ln1050">	if (val &amp; (BFE_IBE | BFE_TO))</a>
<a name="ln1051">		CSR_WRITE_4(sc, BFE_SBIMSTATE, val &amp; ~(BFE_IBE | BFE_TO));</a>
<a name="ln1052"> </a>
<a name="ln1053">	/* Clear reset and allow it to move through the core */</a>
<a name="ln1054">	CSR_WRITE_4(sc, BFE_SBTMSLOW, (BFE_CLOCK | BFE_FGC));</a>
<a name="ln1055">	CSR_READ_4(sc, BFE_SBTMSLOW);</a>
<a name="ln1056">	DELAY(10);</a>
<a name="ln1057"> </a>
<a name="ln1058">	/* Leave the clock set */</a>
<a name="ln1059">	CSR_WRITE_4(sc, BFE_SBTMSLOW, BFE_CLOCK);</a>
<a name="ln1060">	CSR_READ_4(sc, BFE_SBTMSLOW);</a>
<a name="ln1061">	DELAY(10);</a>
<a name="ln1062">}</a>
<a name="ln1063"> </a>
<a name="ln1064">static void</a>
<a name="ln1065">bfe_cam_write(struct bfe_softc *sc, u_char *data, int index)</a>
<a name="ln1066">{</a>
<a name="ln1067">	u_int32_t val;</a>
<a name="ln1068"> </a>
<a name="ln1069">	val  = ((u_int32_t) data[2]) &lt;&lt; 24;</a>
<a name="ln1070">	val |= ((u_int32_t) data[3]) &lt;&lt; 16;</a>
<a name="ln1071">	val |= ((u_int32_t) data[4]) &lt;&lt;  8;</a>
<a name="ln1072">	val |= ((u_int32_t) data[5]);</a>
<a name="ln1073">	CSR_WRITE_4(sc, BFE_CAM_DATA_LO, val);</a>
<a name="ln1074">	val = (BFE_CAM_HI_VALID |</a>
<a name="ln1075">			(((u_int32_t) data[0]) &lt;&lt; 8) |</a>
<a name="ln1076">			(((u_int32_t) data[1])));</a>
<a name="ln1077">	CSR_WRITE_4(sc, BFE_CAM_DATA_HI, val);</a>
<a name="ln1078">	CSR_WRITE_4(sc, BFE_CAM_CTRL, (BFE_CAM_WRITE |</a>
<a name="ln1079">				((u_int32_t) index &lt;&lt; BFE_CAM_INDEX_SHIFT)));</a>
<a name="ln1080">	bfe_wait_bit(sc, BFE_CAM_CTRL, BFE_CAM_BUSY, 10000, 1);</a>
<a name="ln1081">}</a>
<a name="ln1082"> </a>
<a name="ln1083">static void</a>
<a name="ln1084">bfe_set_rx_mode(struct bfe_softc *sc)</a>
<a name="ln1085">{</a>
<a name="ln1086">	struct ifnet *ifp = sc-&gt;bfe_ifp;</a>
<a name="ln1087">	struct ifmultiaddr  *ifma;</a>
<a name="ln1088">	u_int32_t val;</a>
<a name="ln1089">	int i = 0;</a>
<a name="ln1090"> </a>
<a name="ln1091">	BFE_LOCK_ASSERT(sc);</a>
<a name="ln1092"> </a>
<a name="ln1093">	val = CSR_READ_4(sc, BFE_RXCONF);</a>
<a name="ln1094"> </a>
<a name="ln1095">	if (ifp-&gt;if_flags &amp; IFF_PROMISC)</a>
<a name="ln1096">		val |= BFE_RXCONF_PROMISC;</a>
<a name="ln1097">	else</a>
<a name="ln1098">		val &amp;= ~BFE_RXCONF_PROMISC;</a>
<a name="ln1099"> </a>
<a name="ln1100">	if (ifp-&gt;if_flags &amp; IFF_BROADCAST)</a>
<a name="ln1101">		val &amp;= ~BFE_RXCONF_DBCAST;</a>
<a name="ln1102">	else</a>
<a name="ln1103">		val |= BFE_RXCONF_DBCAST;</a>
<a name="ln1104"> </a>
<a name="ln1105"> </a>
<a name="ln1106">	CSR_WRITE_4(sc, BFE_CAM_CTRL, 0);</a>
<a name="ln1107">	bfe_cam_write(sc, IF_LLADDR(sc-&gt;bfe_ifp), i++);</a>
<a name="ln1108"> </a>
<a name="ln1109">	if (ifp-&gt;if_flags &amp; IFF_ALLMULTI)</a>
<a name="ln1110">		val |= BFE_RXCONF_ALLMULTI;</a>
<a name="ln1111">	else {</a>
<a name="ln1112">		val &amp;= ~BFE_RXCONF_ALLMULTI;</a>
<a name="ln1113">		if_maddr_rlock(ifp);</a>
<a name="ln1114">		TAILQ_FOREACH(ifma, &amp;ifp-&gt;if_multiaddrs, ifma_link) {</a>
<a name="ln1115">			if (ifma-&gt;ifma_addr-&gt;sa_family != AF_LINK)</a>
<a name="ln1116">				continue;</a>
<a name="ln1117">			bfe_cam_write(sc,</a>
<a name="ln1118">			    LLADDR((struct sockaddr_dl *)ifma-&gt;ifma_addr), i++);</a>
<a name="ln1119">		}</a>
<a name="ln1120">		if_maddr_runlock(ifp);</a>
<a name="ln1121">	}</a>
<a name="ln1122"> </a>
<a name="ln1123">	CSR_WRITE_4(sc, BFE_RXCONF, val);</a>
<a name="ln1124">	BFE_OR(sc, BFE_CAM_CTRL, BFE_CAM_ENABLE);</a>
<a name="ln1125">}</a>
<a name="ln1126"> </a>
<a name="ln1127">static void</a>
<a name="ln1128">bfe_dma_map(void *arg, bus_dma_segment_t *segs, int nseg, int error)</a>
<a name="ln1129">{</a>
<a name="ln1130">	struct bfe_dmamap_arg *ctx;</a>
<a name="ln1131"> </a>
<a name="ln1132">	if (error != 0)</a>
<a name="ln1133">		return;</a>
<a name="ln1134"> </a>
<a name="ln1135">	KASSERT(nseg == 1, (&quot;%s : %d segments returned!&quot;, __func__, nseg));</a>
<a name="ln1136"> </a>
<a name="ln1137">	ctx = (struct bfe_dmamap_arg *)arg;</a>
<a name="ln1138">	ctx-&gt;bfe_busaddr = segs[0].ds_addr;</a>
<a name="ln1139">}</a>
<a name="ln1140"> </a>
<a name="ln1141">static void</a>
<a name="ln1142">bfe_release_resources(struct bfe_softc *sc)</a>
<a name="ln1143">{</a>
<a name="ln1144"> </a>
<a name="ln1145">	if (sc-&gt;bfe_intrhand != NULL)</a>
<a name="ln1146">		bus_teardown_intr(sc-&gt;bfe_dev, sc-&gt;bfe_irq, sc-&gt;bfe_intrhand);</a>
<a name="ln1147"> </a>
<a name="ln1148">	if (sc-&gt;bfe_irq != NULL)</a>
<a name="ln1149">		bus_release_resource(sc-&gt;bfe_dev, SYS_RES_IRQ, 0, sc-&gt;bfe_irq);</a>
<a name="ln1150"> </a>
<a name="ln1151">	if (sc-&gt;bfe_res != NULL)</a>
<a name="ln1152">		bus_release_resource(sc-&gt;bfe_dev, SYS_RES_MEMORY, PCIR_BAR(0),</a>
<a name="ln1153">		    sc-&gt;bfe_res);</a>
<a name="ln1154"> </a>
<a name="ln1155">	if (sc-&gt;bfe_ifp != NULL)</a>
<a name="ln1156">		if_free(sc-&gt;bfe_ifp);</a>
<a name="ln1157">}</a>
<a name="ln1158"> </a>
<a name="ln1159">static void</a>
<a name="ln1160">bfe_read_eeprom(struct bfe_softc *sc, u_int8_t *data)</a>
<a name="ln1161">{</a>
<a name="ln1162">	long i;</a>
<a name="ln1163">	u_int16_t *ptr = (u_int16_t *)data;</a>
<a name="ln1164"> </a>
<a name="ln1165">	for(i = 0; i &lt; 128; i += 2)</a>
<a name="ln1166">		ptr[i/2] = CSR_READ_4(sc, 4096 + i);</a>
<a name="ln1167">}</a>
<a name="ln1168"> </a>
<a name="ln1169">static int</a>
<a name="ln1170">bfe_wait_bit(struct bfe_softc *sc, u_int32_t reg, u_int32_t bit,</a>
<a name="ln1171">		u_long timeout, const int clear)</a>
<a name="ln1172">{</a>
<a name="ln1173">	u_long i;</a>
<a name="ln1174"> </a>
<a name="ln1175">	for (i = 0; i &lt; timeout; i++) {</a>
<a name="ln1176">		u_int32_t val = CSR_READ_4(sc, reg);</a>
<a name="ln1177"> </a>
<a name="ln1178">		if (clear &amp;&amp; !(val &amp; bit))</a>
<a name="ln1179">			break;</a>
<a name="ln1180">		if (!clear &amp;&amp; (val &amp; bit))</a>
<a name="ln1181">			break;</a>
<a name="ln1182">		DELAY(10);</a>
<a name="ln1183">	}</a>
<a name="ln1184">	if (i == timeout) {</a>
<a name="ln1185">		device_printf(sc-&gt;bfe_dev,</a>
<a name="ln1186">		    &quot;BUG!  Timeout waiting for bit %08x of register &quot;</a>
<a name="ln1187">		    &quot;%x to %s.\n&quot;, bit, reg, (clear ? &quot;clear&quot; : &quot;set&quot;));</a>
<a name="ln1188">		return (-1);</a>
<a name="ln1189">	}</a>
<a name="ln1190">	return (0);</a>
<a name="ln1191">}</a>
<a name="ln1192"> </a>
<a name="ln1193">static int</a>
<a name="ln1194">bfe_readphy(struct bfe_softc *sc, u_int32_t reg, u_int32_t *val)</a>
<a name="ln1195">{</a>
<a name="ln1196">	int err;</a>
<a name="ln1197"> </a>
<a name="ln1198">	/* Clear MII ISR */</a>
<a name="ln1199">	CSR_WRITE_4(sc, BFE_EMAC_ISTAT, BFE_EMAC_INT_MII);</a>
<a name="ln1200">	CSR_WRITE_4(sc, BFE_MDIO_DATA, (BFE_MDIO_SB_START |</a>
<a name="ln1201">				(BFE_MDIO_OP_READ &lt;&lt; BFE_MDIO_OP_SHIFT) |</a>
<a name="ln1202">				(sc-&gt;bfe_phyaddr &lt;&lt; BFE_MDIO_PMD_SHIFT) |</a>
<a name="ln1203">				(reg &lt;&lt; BFE_MDIO_RA_SHIFT) |</a>
<a name="ln1204">				(BFE_MDIO_TA_VALID &lt;&lt; BFE_MDIO_TA_SHIFT)));</a>
<a name="ln1205">	err = bfe_wait_bit(sc, BFE_EMAC_ISTAT, BFE_EMAC_INT_MII, 100, 0);</a>
<a name="ln1206">	*val = CSR_READ_4(sc, BFE_MDIO_DATA) &amp; BFE_MDIO_DATA_DATA;</a>
<a name="ln1207"> </a>
<a name="ln1208">	return (err);</a>
<a name="ln1209">}</a>
<a name="ln1210"> </a>
<a name="ln1211">static int</a>
<a name="ln1212">bfe_writephy(struct bfe_softc *sc, u_int32_t reg, u_int32_t val)</a>
<a name="ln1213">{</a>
<a name="ln1214">	int status;</a>
<a name="ln1215"> </a>
<a name="ln1216">	CSR_WRITE_4(sc, BFE_EMAC_ISTAT, BFE_EMAC_INT_MII);</a>
<a name="ln1217">	CSR_WRITE_4(sc, BFE_MDIO_DATA, (BFE_MDIO_SB_START |</a>
<a name="ln1218">				(BFE_MDIO_OP_WRITE &lt;&lt; BFE_MDIO_OP_SHIFT) |</a>
<a name="ln1219">				(sc-&gt;bfe_phyaddr &lt;&lt; BFE_MDIO_PMD_SHIFT) |</a>
<a name="ln1220">				(reg &lt;&lt; BFE_MDIO_RA_SHIFT) |</a>
<a name="ln1221">				(BFE_MDIO_TA_VALID &lt;&lt; BFE_MDIO_TA_SHIFT) |</a>
<a name="ln1222">				(val &amp; BFE_MDIO_DATA_DATA)));</a>
<a name="ln1223">	status = bfe_wait_bit(sc, BFE_EMAC_ISTAT, BFE_EMAC_INT_MII, 100, 0);</a>
<a name="ln1224"> </a>
<a name="ln1225">	return (status);</a>
<a name="ln1226">}</a>
<a name="ln1227"> </a>
<a name="ln1228">/*</a>
<a name="ln1229"> * XXX - I think this is handled by the PHY driver, but it can't hurt to do it</a>
<a name="ln1230"> * twice</a>
<a name="ln1231"> */</a>
<a name="ln1232">static int</a>
<a name="ln1233">bfe_setupphy(struct bfe_softc *sc)</a>
<a name="ln1234">{</a>
<a name="ln1235">	u_int32_t val;</a>
<a name="ln1236"> </a>
<a name="ln1237">	/* Enable activity LED */</a>
<a name="ln1238">	bfe_readphy(sc, 26, &amp;val);</a>
<a name="ln1239">	bfe_writephy(sc, 26, val &amp; 0x7fff);</a>
<a name="ln1240">	bfe_readphy(sc, 26, &amp;val);</a>
<a name="ln1241"> </a>
<a name="ln1242">	/* Enable traffic meter LED mode */</a>
<a name="ln1243">	bfe_readphy(sc, 27, &amp;val);</a>
<a name="ln1244">	bfe_writephy(sc, 27, val | (1 &lt;&lt; 6));</a>
<a name="ln1245"> </a>
<a name="ln1246">	return (0);</a>
<a name="ln1247">}</a>
<a name="ln1248"> </a>
<a name="ln1249">static void</a>
<a name="ln1250">bfe_stats_update(struct bfe_softc *sc)</a>
<a name="ln1251">{</a>
<a name="ln1252">	struct bfe_hw_stats *stats;</a>
<a name="ln1253">	struct ifnet *ifp;</a>
<a name="ln1254">	uint32_t mib[BFE_MIB_CNT];</a>
<a name="ln1255">	uint32_t reg, *val;</a>
<a name="ln1256"> </a>
<a name="ln1257">	BFE_LOCK_ASSERT(sc);</a>
<a name="ln1258"> </a>
<a name="ln1259">	val = mib;</a>
<a name="ln1260">	CSR_WRITE_4(sc, BFE_MIB_CTRL, BFE_MIB_CLR_ON_READ);</a>
<a name="ln1261">	for (reg = BFE_TX_GOOD_O; reg &lt;= BFE_TX_PAUSE; reg += 4)</a>
<a name="ln1262">		*val++ = CSR_READ_4(sc, reg);</a>
<a name="ln1263">	for (reg = BFE_RX_GOOD_O; reg &lt;= BFE_RX_NPAUSE; reg += 4)</a>
<a name="ln1264">		*val++ = CSR_READ_4(sc, reg);</a>
<a name="ln1265"> </a>
<a name="ln1266">	ifp = sc-&gt;bfe_ifp;</a>
<a name="ln1267">	stats = &amp;sc-&gt;bfe_stats;</a>
<a name="ln1268">	/* Tx stat. */</a>
<a name="ln1269">	stats-&gt;tx_good_octets += mib[MIB_TX_GOOD_O];</a>
<a name="ln1270">	stats-&gt;tx_good_frames += mib[MIB_TX_GOOD_P];</a>
<a name="ln1271">	stats-&gt;tx_octets += mib[MIB_TX_O];</a>
<a name="ln1272">	stats-&gt;tx_frames += mib[MIB_TX_P];</a>
<a name="ln1273">	stats-&gt;tx_bcast_frames += mib[MIB_TX_BCAST];</a>
<a name="ln1274">	stats-&gt;tx_mcast_frames += mib[MIB_TX_MCAST];</a>
<a name="ln1275">	stats-&gt;tx_pkts_64 += mib[MIB_TX_64];</a>
<a name="ln1276">	stats-&gt;tx_pkts_65_127 += mib[MIB_TX_65_127];</a>
<a name="ln1277">	stats-&gt;tx_pkts_128_255 += mib[MIB_TX_128_255];</a>
<a name="ln1278">	stats-&gt;tx_pkts_256_511 += mib[MIB_TX_256_511];</a>
<a name="ln1279">	stats-&gt;tx_pkts_512_1023 += mib[MIB_TX_512_1023];</a>
<a name="ln1280">	stats-&gt;tx_pkts_1024_max += mib[MIB_TX_1024_MAX];</a>
<a name="ln1281">	stats-&gt;tx_jabbers += mib[MIB_TX_JABBER];</a>
<a name="ln1282">	stats-&gt;tx_oversize_frames += mib[MIB_TX_OSIZE];</a>
<a name="ln1283">	stats-&gt;tx_frag_frames += mib[MIB_TX_FRAG];</a>
<a name="ln1284">	stats-&gt;tx_underruns += mib[MIB_TX_URUNS];</a>
<a name="ln1285">	stats-&gt;tx_colls += mib[MIB_TX_TCOLS];</a>
<a name="ln1286">	stats-&gt;tx_single_colls += mib[MIB_TX_SCOLS];</a>
<a name="ln1287">	stats-&gt;tx_multi_colls += mib[MIB_TX_MCOLS];</a>
<a name="ln1288">	stats-&gt;tx_excess_colls += mib[MIB_TX_ECOLS];</a>
<a name="ln1289">	stats-&gt;tx_late_colls += mib[MIB_TX_LCOLS];</a>
<a name="ln1290">	stats-&gt;tx_deferrals += mib[MIB_TX_DEFERED];</a>
<a name="ln1291">	stats-&gt;tx_carrier_losts += mib[MIB_TX_CLOST];</a>
<a name="ln1292">	stats-&gt;tx_pause_frames += mib[MIB_TX_PAUSE];</a>
<a name="ln1293">	/* Rx stat. */</a>
<a name="ln1294">	stats-&gt;rx_good_octets += mib[MIB_RX_GOOD_O];</a>
<a name="ln1295">	stats-&gt;rx_good_frames += mib[MIB_RX_GOOD_P];</a>
<a name="ln1296">	stats-&gt;rx_octets += mib[MIB_RX_O];</a>
<a name="ln1297">	stats-&gt;rx_frames += mib[MIB_RX_P];</a>
<a name="ln1298">	stats-&gt;rx_bcast_frames += mib[MIB_RX_BCAST];</a>
<a name="ln1299">	stats-&gt;rx_mcast_frames += mib[MIB_RX_MCAST];</a>
<a name="ln1300">	stats-&gt;rx_pkts_64 += mib[MIB_RX_64];</a>
<a name="ln1301">	stats-&gt;rx_pkts_65_127 += mib[MIB_RX_65_127];</a>
<a name="ln1302">	stats-&gt;rx_pkts_128_255 += mib[MIB_RX_128_255];</a>
<a name="ln1303">	stats-&gt;rx_pkts_256_511 += mib[MIB_RX_256_511];</a>
<a name="ln1304">	stats-&gt;rx_pkts_512_1023 += mib[MIB_RX_512_1023];</a>
<a name="ln1305">	stats-&gt;rx_pkts_1024_max += mib[MIB_RX_1024_MAX];</a>
<a name="ln1306">	stats-&gt;rx_jabbers += mib[MIB_RX_JABBER];</a>
<a name="ln1307">	stats-&gt;rx_oversize_frames += mib[MIB_RX_OSIZE];</a>
<a name="ln1308">	stats-&gt;rx_frag_frames += mib[MIB_RX_FRAG];</a>
<a name="ln1309">	stats-&gt;rx_missed_frames += mib[MIB_RX_MISS];</a>
<a name="ln1310">	stats-&gt;rx_crc_align_errs += mib[MIB_RX_CRCA];</a>
<a name="ln1311">	stats-&gt;rx_runts += mib[MIB_RX_USIZE];</a>
<a name="ln1312">	stats-&gt;rx_crc_errs += mib[MIB_RX_CRC];</a>
<a name="ln1313">	stats-&gt;rx_align_errs += mib[MIB_RX_ALIGN];</a>
<a name="ln1314">	stats-&gt;rx_symbol_errs += mib[MIB_RX_SYM];</a>
<a name="ln1315">	stats-&gt;rx_pause_frames += mib[MIB_RX_PAUSE];</a>
<a name="ln1316">	stats-&gt;rx_control_frames += mib[MIB_RX_NPAUSE];</a>
<a name="ln1317"> </a>
<a name="ln1318">	/* Update counters in ifnet. */</a>
<a name="ln1319">	if_inc_counter(ifp, IFCOUNTER_OPACKETS, (u_long)mib[MIB_TX_GOOD_P]);</a>
<a name="ln1320">	if_inc_counter(ifp, IFCOUNTER_COLLISIONS, (u_long)mib[MIB_TX_TCOLS]);</a>
<a name="ln1321">	if_inc_counter(ifp, IFCOUNTER_OERRORS, (u_long)mib[MIB_TX_URUNS] +</a>
<a name="ln1322">	    (u_long)mib[MIB_TX_ECOLS] +</a>
<a name="ln1323">	    (u_long)mib[MIB_TX_DEFERED] +</a>
<a name="ln1324">	    (u_long)mib[MIB_TX_CLOST]);</a>
<a name="ln1325"> </a>
<a name="ln1326">	if_inc_counter(ifp, IFCOUNTER_IPACKETS, (u_long)mib[MIB_RX_GOOD_P]);</a>
<a name="ln1327"> </a>
<a name="ln1328">	if_inc_counter(ifp, IFCOUNTER_IERRORS, mib[MIB_RX_JABBER] +</a>
<a name="ln1329">	    mib[MIB_RX_MISS] +</a>
<a name="ln1330">	    mib[MIB_RX_CRCA] +</a>
<a name="ln1331">	    mib[MIB_RX_USIZE] +</a>
<a name="ln1332">	    mib[MIB_RX_CRC] +</a>
<a name="ln1333">	    mib[MIB_RX_ALIGN] +</a>
<a name="ln1334">	    mib[MIB_RX_SYM]);</a>
<a name="ln1335">}</a>
<a name="ln1336"> </a>
<a name="ln1337">static void</a>
<a name="ln1338">bfe_txeof(struct bfe_softc *sc)</a>
<a name="ln1339">{</a>
<a name="ln1340">	struct bfe_tx_data *r;</a>
<a name="ln1341">	struct ifnet *ifp;</a>
<a name="ln1342">	int i, chipidx;</a>
<a name="ln1343"> </a>
<a name="ln1344">	BFE_LOCK_ASSERT(sc);</a>
<a name="ln1345"> </a>
<a name="ln1346">	ifp = sc-&gt;bfe_ifp;</a>
<a name="ln1347"> </a>
<a name="ln1348">	chipidx = CSR_READ_4(sc, BFE_DMATX_STAT) &amp; BFE_STAT_CDMASK;</a>
<a name="ln1349">	chipidx /= sizeof(struct bfe_desc);</a>
<a name="ln1350"> </a>
<a name="ln1351">	i = sc-&gt;bfe_tx_cons;</a>
<a name="ln1352">	if (i == chipidx)</a>
<a name="ln1353">		return;</a>
<a name="ln1354">	bus_dmamap_sync(sc-&gt;bfe_tx_tag, sc-&gt;bfe_tx_map,</a>
<a name="ln1355">	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);</a>
<a name="ln1356">	/* Go through the mbufs and free those that have been transmitted */</a>
<a name="ln1357">	for (; i != chipidx; BFE_INC(i, BFE_TX_LIST_CNT)) {</a>
<a name="ln1358">		r = &amp;sc-&gt;bfe_tx_ring[i];</a>
<a name="ln1359">		sc-&gt;bfe_tx_cnt--;</a>
<a name="ln1360">		if (r-&gt;bfe_mbuf == NULL)</a>
<a name="ln1361">			continue;</a>
<a name="ln1362">		bus_dmamap_sync(sc-&gt;bfe_txmbuf_tag, r-&gt;bfe_map,</a>
<a name="ln1363">		    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln1364">		bus_dmamap_unload(sc-&gt;bfe_txmbuf_tag, r-&gt;bfe_map);</a>
<a name="ln1365"> </a>
<a name="ln1366">		m_freem(r-&gt;bfe_mbuf);</a>
<a name="ln1367">		r-&gt;bfe_mbuf = NULL;</a>
<a name="ln1368">	}</a>
<a name="ln1369"> </a>
<a name="ln1370">	if (i != sc-&gt;bfe_tx_cons) {</a>
<a name="ln1371">		/* we freed up some mbufs */</a>
<a name="ln1372">		sc-&gt;bfe_tx_cons = i;</a>
<a name="ln1373">		ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_OACTIVE;</a>
<a name="ln1374">	}</a>
<a name="ln1375"> </a>
<a name="ln1376">	if (sc-&gt;bfe_tx_cnt == 0)</a>
<a name="ln1377">		sc-&gt;bfe_watchdog_timer = 0;</a>
<a name="ln1378">}</a>
<a name="ln1379"> </a>
<a name="ln1380">/* Pass a received packet up the stack */</a>
<a name="ln1381">static void</a>
<a name="ln1382">bfe_rxeof(struct bfe_softc *sc)</a>
<a name="ln1383">{</a>
<a name="ln1384">	struct mbuf *m;</a>
<a name="ln1385">	struct ifnet *ifp;</a>
<a name="ln1386">	struct bfe_rxheader *rxheader;</a>
<a name="ln1387">	struct bfe_rx_data *r;</a>
<a name="ln1388">	int cons, prog;</a>
<a name="ln1389">	u_int32_t status, current, len, flags;</a>
<a name="ln1390"> </a>
<a name="ln1391">	BFE_LOCK_ASSERT(sc);</a>
<a name="ln1392">	cons = sc-&gt;bfe_rx_cons;</a>
<a name="ln1393">	status = CSR_READ_4(sc, BFE_DMARX_STAT);</a>
<a name="ln1394">	current = (status &amp; BFE_STAT_CDMASK) / sizeof(struct bfe_desc);</a>
<a name="ln1395"> </a>
<a name="ln1396">	ifp = sc-&gt;bfe_ifp;</a>
<a name="ln1397"> </a>
<a name="ln1398">	bus_dmamap_sync(sc-&gt;bfe_rx_tag, sc-&gt;bfe_rx_map,</a>
<a name="ln1399">	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);</a>
<a name="ln1400"> </a>
<a name="ln1401">	for (prog = 0; current != cons; prog++,</a>
<a name="ln1402">	    BFE_INC(cons, BFE_RX_LIST_CNT)) {</a>
<a name="ln1403">		r = &amp;sc-&gt;bfe_rx_ring[cons];</a>
<a name="ln1404">		m = r-&gt;bfe_mbuf;</a>
<a name="ln1405">		/*</a>
<a name="ln1406">		 * Rx status should be read from mbuf such that we can't</a>
<a name="ln1407">		 * delay bus_dmamap_sync(9). This hardware limiation</a>
<a name="ln1408">		 * results in inefficent mbuf usage as bfe(4) couldn't</a>
<a name="ln1409">		 * reuse mapped buffer from errored frame. </a>
<a name="ln1410">		 */</a>
<a name="ln1411">		if (bfe_list_newbuf(sc, cons) != 0) {</a>
<a name="ln1412">			if_inc_counter(ifp, IFCOUNTER_IQDROPS, 1);</a>
<a name="ln1413">			bfe_discard_buf(sc, cons);</a>
<a name="ln1414">			continue;</a>
<a name="ln1415">		}</a>
<a name="ln1416">		rxheader = mtod(m, struct bfe_rxheader*);</a>
<a name="ln1417">		len = le16toh(rxheader-&gt;len);</a>
<a name="ln1418">		flags = le16toh(rxheader-&gt;flags);</a>
<a name="ln1419"> </a>
<a name="ln1420">		/* Remove CRC bytes. */</a>
<a name="ln1421">		len -= ETHER_CRC_LEN;</a>
<a name="ln1422"> </a>
<a name="ln1423">		/* flag an error and try again */</a>
<a name="ln1424">		if ((len &gt; ETHER_MAX_LEN+32) || (flags &amp; BFE_RX_FLAG_ERRORS)) {</a>
<a name="ln1425">			m_freem(m);</a>
<a name="ln1426">			continue;</a>
<a name="ln1427">		}</a>
<a name="ln1428"> </a>
<a name="ln1429">		/* Make sure to skip header bytes written by hardware. */</a>
<a name="ln1430">		m_adj(m, BFE_RX_OFFSET);</a>
<a name="ln1431">		m-&gt;m_len = m-&gt;m_pkthdr.len = len;</a>
<a name="ln1432"> </a>
<a name="ln1433">		m-&gt;m_pkthdr.rcvif = ifp;</a>
<a name="ln1434">		BFE_UNLOCK(sc);</a>
<a name="ln1435">		(*ifp-&gt;if_input)(ifp, m);</a>
<a name="ln1436">		BFE_LOCK(sc);</a>
<a name="ln1437">	}</a>
<a name="ln1438"> </a>
<a name="ln1439">	if (prog &gt; 0) {</a>
<a name="ln1440">		sc-&gt;bfe_rx_cons = cons;</a>
<a name="ln1441">		bus_dmamap_sync(sc-&gt;bfe_rx_tag, sc-&gt;bfe_rx_map,</a>
<a name="ln1442">		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln1443">	}</a>
<a name="ln1444">}</a>
<a name="ln1445"> </a>
<a name="ln1446">static void</a>
<a name="ln1447">bfe_intr(void *xsc)</a>
<a name="ln1448">{</a>
<a name="ln1449">	struct bfe_softc *sc = xsc;</a>
<a name="ln1450">	struct ifnet *ifp;</a>
<a name="ln1451">	u_int32_t istat;</a>
<a name="ln1452"> </a>
<a name="ln1453">	ifp = sc-&gt;bfe_ifp;</a>
<a name="ln1454"> </a>
<a name="ln1455">	BFE_LOCK(sc);</a>
<a name="ln1456"> </a>
<a name="ln1457">	istat = CSR_READ_4(sc, BFE_ISTAT);</a>
<a name="ln1458"> </a>
<a name="ln1459">	/*</a>
<a name="ln1460">	 * Defer unsolicited interrupts - This is necessary because setting the</a>
<a name="ln1461">	 * chips interrupt mask register to 0 doesn't actually stop the</a>
<a name="ln1462">	 * interrupts</a>
<a name="ln1463">	 */</a>
<a name="ln1464">	istat &amp;= BFE_IMASK_DEF;</a>
<a name="ln1465">	CSR_WRITE_4(sc, BFE_ISTAT, istat);</a>
<a name="ln1466">	CSR_READ_4(sc, BFE_ISTAT);</a>
<a name="ln1467"> </a>
<a name="ln1468">	/* not expecting this interrupt, disregard it */</a>
<a name="ln1469">	if (istat == 0 || (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) == 0) {</a>
<a name="ln1470">		BFE_UNLOCK(sc);</a>
<a name="ln1471">		return;</a>
<a name="ln1472">	}</a>
<a name="ln1473"> </a>
<a name="ln1474">	/* A packet was received */</a>
<a name="ln1475">	if (istat &amp; BFE_ISTAT_RX)</a>
<a name="ln1476">		bfe_rxeof(sc);</a>
<a name="ln1477"> </a>
<a name="ln1478">	/* A packet was sent */</a>
<a name="ln1479">	if (istat &amp; BFE_ISTAT_TX)</a>
<a name="ln1480">		bfe_txeof(sc);</a>
<a name="ln1481"> </a>
<a name="ln1482">	if (istat &amp; BFE_ISTAT_ERRORS) {</a>
<a name="ln1483"> </a>
<a name="ln1484">		if (istat &amp; BFE_ISTAT_DSCE) {</a>
<a name="ln1485">			device_printf(sc-&gt;bfe_dev, &quot;Descriptor Error\n&quot;);</a>
<a name="ln1486">			bfe_stop(sc);</a>
<a name="ln1487">			BFE_UNLOCK(sc);</a>
<a name="ln1488">			return;</a>
<a name="ln1489">		}</a>
<a name="ln1490"> </a>
<a name="ln1491">		if (istat &amp; BFE_ISTAT_DPE) {</a>
<a name="ln1492">			device_printf(sc-&gt;bfe_dev,</a>
<a name="ln1493">			    &quot;Descriptor Protocol Error\n&quot;);</a>
<a name="ln1494">			bfe_stop(sc);</a>
<a name="ln1495">			BFE_UNLOCK(sc);</a>
<a name="ln1496">			return;</a>
<a name="ln1497">		}</a>
<a name="ln1498">		ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_RUNNING;</a>
<a name="ln1499">		bfe_init_locked(sc);</a>
<a name="ln1500">	}</a>
<a name="ln1501"> </a>
<a name="ln1502">	/* We have packets pending, fire them out */</a>
<a name="ln1503">	if (!IFQ_DRV_IS_EMPTY(&amp;ifp-&gt;if_snd))</a>
<a name="ln1504">		bfe_start_locked(ifp);</a>
<a name="ln1505"> </a>
<a name="ln1506">	BFE_UNLOCK(sc);</a>
<a name="ln1507">}</a>
<a name="ln1508"> </a>
<a name="ln1509">static int</a>
<a name="ln1510">bfe_encap(struct bfe_softc *sc, struct mbuf **m_head)</a>
<a name="ln1511">{</a>
<a name="ln1512">	struct bfe_desc *d;</a>
<a name="ln1513">	struct bfe_tx_data *r, *r1;</a>
<a name="ln1514">	struct mbuf *m;</a>
<a name="ln1515">	bus_dmamap_t map;</a>
<a name="ln1516">	bus_dma_segment_t txsegs[BFE_MAXTXSEGS];</a>
<a name="ln1517">	uint32_t cur, si;</a>
<a name="ln1518">	int error, i, nsegs;</a>
<a name="ln1519"> </a>
<a name="ln1520">	BFE_LOCK_ASSERT(sc);</a>
<a name="ln1521"> </a>
<a name="ln1522">	M_ASSERTPKTHDR((*m_head));</a>
<a name="ln1523"> </a>
<a name="ln1524">	si = cur = sc-&gt;bfe_tx_prod;</a>
<a name="ln1525">	r = &amp;sc-&gt;bfe_tx_ring[cur];</a>
<a name="ln1526">	error = bus_dmamap_load_mbuf_sg(sc-&gt;bfe_txmbuf_tag, r-&gt;bfe_map, *m_head,</a>
<a name="ln1527">	    txsegs, &amp;nsegs, 0);</a>
<a name="ln1528">	if (error == EFBIG) {</a>
<a name="ln1529">		m = m_collapse(*m_head, M_NOWAIT, BFE_MAXTXSEGS);</a>
<a name="ln1530">		if (m == NULL) {</a>
<a name="ln1531">			m_freem(*m_head);</a>
<a name="ln1532">			*m_head = NULL;</a>
<a name="ln1533">			return (ENOMEM);</a>
<a name="ln1534">		}</a>
<a name="ln1535">		*m_head = m;</a>
<a name="ln1536">		error = bus_dmamap_load_mbuf_sg(sc-&gt;bfe_txmbuf_tag, r-&gt;bfe_map,</a>
<a name="ln1537">		    *m_head, txsegs, &amp;nsegs, 0);</a>
<a name="ln1538">		if (error != 0) {</a>
<a name="ln1539">			m_freem(*m_head);</a>
<a name="ln1540">			*m_head = NULL;</a>
<a name="ln1541">			return (error);</a>
<a name="ln1542">		}</a>
<a name="ln1543">	} else if (error != 0)</a>
<a name="ln1544">		return (error);</a>
<a name="ln1545">	if (nsegs == 0) {</a>
<a name="ln1546">		m_freem(*m_head);</a>
<a name="ln1547">		*m_head = NULL;</a>
<a name="ln1548">		return (EIO);</a>
<a name="ln1549">	}</a>
<a name="ln1550"> </a>
<a name="ln1551">	if (sc-&gt;bfe_tx_cnt + nsegs &gt; BFE_TX_LIST_CNT - 1) {</a>
<a name="ln1552">		bus_dmamap_unload(sc-&gt;bfe_txmbuf_tag, r-&gt;bfe_map);</a>
<a name="ln1553">		return (ENOBUFS);</a>
<a name="ln1554">	}</a>
<a name="ln1555"> </a>
<a name="ln1556">	for (i = 0; i &lt; nsegs; i++) {</a>
<a name="ln1557">		d = &amp;sc-&gt;bfe_tx_list[cur];</a>
<a name="ln1558">		d-&gt;bfe_ctrl = htole32(txsegs[i].ds_len &amp; BFE_DESC_LEN);</a>
<a name="ln1559">		d-&gt;bfe_ctrl |= htole32(BFE_DESC_IOC);</a>
<a name="ln1560">		if (cur == BFE_TX_LIST_CNT - 1)</a>
<a name="ln1561">			/*</a>
<a name="ln1562">			 * Tell the chip to wrap to the start of</a>
<a name="ln1563">			 * the descriptor list.</a>
<a name="ln1564">			 */</a>
<a name="ln1565">			d-&gt;bfe_ctrl |= htole32(BFE_DESC_EOT);</a>
<a name="ln1566">		/* The chip needs all addresses to be added to BFE_PCI_DMA. */</a>
<a name="ln1567">		d-&gt;bfe_addr = htole32(BFE_ADDR_LO(txsegs[i].ds_addr) +</a>
<a name="ln1568">		    BFE_PCI_DMA);</a>
<a name="ln1569">		BFE_INC(cur, BFE_TX_LIST_CNT);</a>
<a name="ln1570">	}</a>
<a name="ln1571"> </a>
<a name="ln1572">	/* Update producer index. */</a>
<a name="ln1573">	sc-&gt;bfe_tx_prod = cur;</a>
<a name="ln1574"> </a>
<a name="ln1575">	/* Set EOF on the last descriptor. */</a>
<a name="ln1576">	cur = (cur + BFE_TX_LIST_CNT - 1) % BFE_TX_LIST_CNT;</a>
<a name="ln1577">	d = &amp;sc-&gt;bfe_tx_list[cur];</a>
<a name="ln1578">	d-&gt;bfe_ctrl |= htole32(BFE_DESC_EOF);</a>
<a name="ln1579"> </a>
<a name="ln1580">	/* Lastly set SOF on the first descriptor to avoid races. */</a>
<a name="ln1581">	d = &amp;sc-&gt;bfe_tx_list[si];</a>
<a name="ln1582">	d-&gt;bfe_ctrl |= htole32(BFE_DESC_SOF);</a>
<a name="ln1583"> </a>
<a name="ln1584">	r1 = &amp;sc-&gt;bfe_tx_ring[cur];</a>
<a name="ln1585">	map = r-&gt;bfe_map;</a>
<a name="ln1586">	r-&gt;bfe_map = r1-&gt;bfe_map;</a>
<a name="ln1587">	r1-&gt;bfe_map = map;</a>
<a name="ln1588">	r1-&gt;bfe_mbuf = *m_head;</a>
<a name="ln1589">	sc-&gt;bfe_tx_cnt += nsegs;</a>
<a name="ln1590"> </a>
<a name="ln1591">	bus_dmamap_sync(sc-&gt;bfe_txmbuf_tag, map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln1592"> </a>
<a name="ln1593">	return (0);</a>
<a name="ln1594">}</a>
<a name="ln1595"> </a>
<a name="ln1596">/*</a>
<a name="ln1597"> * Set up to transmit a packet.</a>
<a name="ln1598"> */</a>
<a name="ln1599">static void</a>
<a name="ln1600">bfe_start(struct ifnet *ifp)</a>
<a name="ln1601">{</a>
<a name="ln1602">	BFE_LOCK((struct bfe_softc *)ifp-&gt;if_softc);</a>
<a name="ln1603">	bfe_start_locked(ifp);</a>
<a name="ln1604">	BFE_UNLOCK((struct bfe_softc *)ifp-&gt;if_softc);</a>
<a name="ln1605">}</a>
<a name="ln1606"> </a>
<a name="ln1607">/*</a>
<a name="ln1608"> * Set up to transmit a packet. The softc is already locked.</a>
<a name="ln1609"> */</a>
<a name="ln1610">static void</a>
<a name="ln1611">bfe_start_locked(struct ifnet *ifp)</a>
<a name="ln1612">{</a>
<a name="ln1613">	struct bfe_softc *sc;</a>
<a name="ln1614">	struct mbuf *m_head;</a>
<a name="ln1615">	int queued;</a>
<a name="ln1616"> </a>
<a name="ln1617">	sc = ifp-&gt;if_softc;</a>
<a name="ln1618"> </a>
<a name="ln1619">	BFE_LOCK_ASSERT(sc);</a>
<a name="ln1620"> </a>
<a name="ln1621">	/*</a>
<a name="ln1622">	 * Not much point trying to send if the link is down</a>
<a name="ln1623">	 * or we have nothing to send.</a>
<a name="ln1624">	 */</a>
<a name="ln1625">	if ((ifp-&gt;if_drv_flags &amp; (IFF_DRV_RUNNING | IFF_DRV_OACTIVE)) !=</a>
<a name="ln1626">	    IFF_DRV_RUNNING || (sc-&gt;bfe_flags &amp; BFE_FLAG_LINK) == 0)</a>
<a name="ln1627">		return;</a>
<a name="ln1628"> </a>
<a name="ln1629">	for (queued = 0; !IFQ_DRV_IS_EMPTY(&amp;ifp-&gt;if_snd) &amp;&amp;</a>
<a name="ln1630">	    sc-&gt;bfe_tx_cnt &lt; BFE_TX_LIST_CNT - 1;) {</a>
<a name="ln1631">		IFQ_DRV_DEQUEUE(&amp;ifp-&gt;if_snd, m_head);</a>
<a name="ln1632">		if (m_head == NULL)</a>
<a name="ln1633">			break;</a>
<a name="ln1634"> </a>
<a name="ln1635">		/*</a>
<a name="ln1636">		 * Pack the data into the tx ring.  If we dont have</a>
<a name="ln1637">		 * enough room, let the chip drain the ring.</a>
<a name="ln1638">		 */</a>
<a name="ln1639">		if (bfe_encap(sc, &amp;m_head)) {</a>
<a name="ln1640">			if (m_head == NULL)</a>
<a name="ln1641">				break;</a>
<a name="ln1642">			IFQ_DRV_PREPEND(&amp;ifp-&gt;if_snd, m_head);</a>
<a name="ln1643">			ifp-&gt;if_drv_flags |= IFF_DRV_OACTIVE;</a>
<a name="ln1644">			break;</a>
<a name="ln1645">		}</a>
<a name="ln1646"> </a>
<a name="ln1647">		queued++;</a>
<a name="ln1648"> </a>
<a name="ln1649">		/*</a>
<a name="ln1650">		 * If there's a BPF listener, bounce a copy of this frame</a>
<a name="ln1651">		 * to him.</a>
<a name="ln1652">		 */</a>
<a name="ln1653">		BPF_MTAP(ifp, m_head);</a>
<a name="ln1654">	}</a>
<a name="ln1655"> </a>
<a name="ln1656">	if (queued) {</a>
<a name="ln1657">		bus_dmamap_sync(sc-&gt;bfe_tx_tag, sc-&gt;bfe_tx_map,</a>
<a name="ln1658">		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln1659">		/* Transmit - twice due to apparent hardware bug */</a>
<a name="ln1660">		CSR_WRITE_4(sc, BFE_DMATX_PTR,</a>
<a name="ln1661">		    sc-&gt;bfe_tx_prod * sizeof(struct bfe_desc));</a>
<a name="ln1662">		/*</a>
<a name="ln1663">		 * XXX It seems the following write is not necessary</a>
<a name="ln1664">		 * to kick Tx command. What might be required would be</a>
<a name="ln1665">		 * a way flushing PCI posted write. Reading the register</a>
<a name="ln1666">		 * back ensures the flush operation. In addition,</a>
<a name="ln1667">		 * hardware will execute PCI posted write in the long</a>
<a name="ln1668">		 * run and watchdog timer for the kick command was set</a>
<a name="ln1669">		 * to 5 seconds. Therefore I think the second write</a>
<a name="ln1670">		 * access is not necessary or could be replaced with</a>
<a name="ln1671">		 * read operation.</a>
<a name="ln1672">		 */</a>
<a name="ln1673">		CSR_WRITE_4(sc, BFE_DMATX_PTR,</a>
<a name="ln1674">		    sc-&gt;bfe_tx_prod * sizeof(struct bfe_desc));</a>
<a name="ln1675"> </a>
<a name="ln1676">		/*</a>
<a name="ln1677">		 * Set a timeout in case the chip goes out to lunch.</a>
<a name="ln1678">		 */</a>
<a name="ln1679">		sc-&gt;bfe_watchdog_timer = 5;</a>
<a name="ln1680">	}</a>
<a name="ln1681">}</a>
<a name="ln1682"> </a>
<a name="ln1683">static void</a>
<a name="ln1684">bfe_init(void *xsc)</a>
<a name="ln1685">{</a>
<a name="ln1686">	BFE_LOCK((struct bfe_softc *)xsc);</a>
<a name="ln1687">	bfe_init_locked(xsc);</a>
<a name="ln1688">	BFE_UNLOCK((struct bfe_softc *)xsc);</a>
<a name="ln1689">}</a>
<a name="ln1690"> </a>
<a name="ln1691">static void</a>
<a name="ln1692">bfe_init_locked(void *xsc)</a>
<a name="ln1693">{</a>
<a name="ln1694">	struct bfe_softc *sc = (struct bfe_softc*)xsc;</a>
<a name="ln1695">	struct ifnet *ifp = sc-&gt;bfe_ifp;</a>
<a name="ln1696">	struct mii_data *mii;</a>
<a name="ln1697"> </a>
<a name="ln1698">	BFE_LOCK_ASSERT(sc);</a>
<a name="ln1699"> </a>
<a name="ln1700">	mii = device_get_softc(sc-&gt;bfe_miibus);</a>
<a name="ln1701"> </a>
<a name="ln1702">	if (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING)</a>
<a name="ln1703">		return;</a>
<a name="ln1704"> </a>
<a name="ln1705">	bfe_stop(sc);</a>
<a name="ln1706">	bfe_chip_reset(sc);</a>
<a name="ln1707"> </a>
<a name="ln1708">	if (bfe_list_rx_init(sc) == ENOBUFS) {</a>
<a name="ln1709">		device_printf(sc-&gt;bfe_dev,</a>
<a name="ln1710">		    &quot;%s: Not enough memory for list buffers\n&quot;, __func__);</a>
<a name="ln1711">		bfe_stop(sc);</a>
<a name="ln1712">		return;</a>
<a name="ln1713">	}</a>
<a name="ln1714">	bfe_list_tx_init(sc);</a>
<a name="ln1715"> </a>
<a name="ln1716">	bfe_set_rx_mode(sc);</a>
<a name="ln1717"> </a>
<a name="ln1718">	/* Enable the chip and core */</a>
<a name="ln1719">	BFE_OR(sc, BFE_ENET_CTRL, BFE_ENET_ENABLE);</a>
<a name="ln1720">	/* Enable interrupts */</a>
<a name="ln1721">	CSR_WRITE_4(sc, BFE_IMASK, BFE_IMASK_DEF);</a>
<a name="ln1722"> </a>
<a name="ln1723">	/* Clear link state and change media. */</a>
<a name="ln1724">	sc-&gt;bfe_flags &amp;= ~BFE_FLAG_LINK;</a>
<a name="ln1725">	mii_mediachg(mii);</a>
<a name="ln1726"> </a>
<a name="ln1727">	ifp-&gt;if_drv_flags |= IFF_DRV_RUNNING;</a>
<a name="ln1728">	ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_OACTIVE;</a>
<a name="ln1729"> </a>
<a name="ln1730">	callout_reset(&amp;sc-&gt;bfe_stat_co, hz, bfe_tick, sc);</a>
<a name="ln1731">}</a>
<a name="ln1732"> </a>
<a name="ln1733">/*</a>
<a name="ln1734"> * Set media options.</a>
<a name="ln1735"> */</a>
<a name="ln1736">static int</a>
<a name="ln1737">bfe_ifmedia_upd(struct ifnet *ifp)</a>
<a name="ln1738">{</a>
<a name="ln1739">	struct bfe_softc *sc;</a>
<a name="ln1740">	struct mii_data *mii;</a>
<a name="ln1741">	struct mii_softc *miisc;</a>
<a name="ln1742">	int error;</a>
<a name="ln1743"> </a>
<a name="ln1744">	sc = ifp-&gt;if_softc;</a>
<a name="ln1745">	BFE_LOCK(sc);</a>
<a name="ln1746"> </a>
<a name="ln1747">	mii = device_get_softc(sc-&gt;bfe_miibus);</a>
<a name="ln1748">	LIST_FOREACH(miisc, &amp;mii-&gt;mii_phys, mii_list)</a>
<a name="ln1749">		PHY_RESET(miisc);</a>
<a name="ln1750">	error = mii_mediachg(mii);</a>
<a name="ln1751">	BFE_UNLOCK(sc);</a>
<a name="ln1752"> </a>
<a name="ln1753">	return (error);</a>
<a name="ln1754">}</a>
<a name="ln1755"> </a>
<a name="ln1756">/*</a>
<a name="ln1757"> * Report current media status.</a>
<a name="ln1758"> */</a>
<a name="ln1759">static void</a>
<a name="ln1760">bfe_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)</a>
<a name="ln1761">{</a>
<a name="ln1762">	struct bfe_softc *sc = ifp-&gt;if_softc;</a>
<a name="ln1763">	struct mii_data *mii;</a>
<a name="ln1764"> </a>
<a name="ln1765">	BFE_LOCK(sc);</a>
<a name="ln1766">	mii = device_get_softc(sc-&gt;bfe_miibus);</a>
<a name="ln1767">	mii_pollstat(mii);</a>
<a name="ln1768">	ifmr-&gt;ifm_active = mii-&gt;mii_media_active;</a>
<a name="ln1769">	ifmr-&gt;ifm_status = mii-&gt;mii_media_status;</a>
<a name="ln1770">	BFE_UNLOCK(sc);</a>
<a name="ln1771">}</a>
<a name="ln1772"> </a>
<a name="ln1773">static int</a>
<a name="ln1774">bfe_ioctl(struct ifnet *ifp, u_long command, caddr_t data)</a>
<a name="ln1775">{</a>
<a name="ln1776">	struct bfe_softc *sc = ifp-&gt;if_softc;</a>
<a name="ln1777">	struct ifreq *ifr = (struct ifreq *) data;</a>
<a name="ln1778">	struct mii_data *mii;</a>
<a name="ln1779">	int error = 0;</a>
<a name="ln1780"> </a>
<a name="ln1781">	switch (command) {</a>
<a name="ln1782">	case SIOCSIFFLAGS:</a>
<a name="ln1783">		BFE_LOCK(sc);</a>
<a name="ln1784">		if (ifp-&gt;if_flags &amp; IFF_UP) {</a>
<a name="ln1785">			if (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING)</a>
<a name="ln1786">				bfe_set_rx_mode(sc);</a>
<a name="ln1787">			else if ((sc-&gt;bfe_flags &amp; BFE_FLAG_DETACH) == 0)</a>
<a name="ln1788">				bfe_init_locked(sc);</a>
<a name="ln1789">		} else if (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING)</a>
<a name="ln1790">			bfe_stop(sc);</a>
<a name="ln1791">		BFE_UNLOCK(sc);</a>
<a name="ln1792">		break;</a>
<a name="ln1793">	case SIOCADDMULTI:</a>
<a name="ln1794">	case SIOCDELMULTI:</a>
<a name="ln1795">		BFE_LOCK(sc);</a>
<a name="ln1796">		if (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING)</a>
<a name="ln1797">			bfe_set_rx_mode(sc);</a>
<a name="ln1798">		BFE_UNLOCK(sc);</a>
<a name="ln1799">		break;</a>
<a name="ln1800">	case SIOCGIFMEDIA:</a>
<a name="ln1801">	case SIOCSIFMEDIA:</a>
<a name="ln1802">		mii = device_get_softc(sc-&gt;bfe_miibus);</a>
<a name="ln1803">		error = ifmedia_ioctl(ifp, ifr, &amp;mii-&gt;mii_media, command);</a>
<a name="ln1804">		break;</a>
<a name="ln1805">	default:</a>
<a name="ln1806">		error = ether_ioctl(ifp, command, data);</a>
<a name="ln1807">		break;</a>
<a name="ln1808">	}</a>
<a name="ln1809"> </a>
<a name="ln1810">	return (error);</a>
<a name="ln1811">}</a>
<a name="ln1812"> </a>
<a name="ln1813">static void</a>
<a name="ln1814">bfe_watchdog(struct bfe_softc *sc)</a>
<a name="ln1815">{</a>
<a name="ln1816">	struct ifnet *ifp;</a>
<a name="ln1817"> </a>
<a name="ln1818">	BFE_LOCK_ASSERT(sc);</a>
<a name="ln1819"> </a>
<a name="ln1820">	if (sc-&gt;bfe_watchdog_timer == 0 || --sc-&gt;bfe_watchdog_timer)</a>
<a name="ln1821">		return;</a>
<a name="ln1822"> </a>
<a name="ln1823">	ifp = sc-&gt;bfe_ifp;</a>
<a name="ln1824"> </a>
<a name="ln1825">	device_printf(sc-&gt;bfe_dev, &quot;watchdog timeout -- resetting\n&quot;);</a>
<a name="ln1826"> </a>
<a name="ln1827">	if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln1828">	ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_RUNNING;</a>
<a name="ln1829">	bfe_init_locked(sc);</a>
<a name="ln1830"> </a>
<a name="ln1831">	if (!IFQ_DRV_IS_EMPTY(&amp;ifp-&gt;if_snd))</a>
<a name="ln1832">		bfe_start_locked(ifp);</a>
<a name="ln1833">}</a>
<a name="ln1834"> </a>
<a name="ln1835">static void</a>
<a name="ln1836">bfe_tick(void *xsc)</a>
<a name="ln1837">{</a>
<a name="ln1838">	struct bfe_softc *sc = xsc;</a>
<a name="ln1839">	struct mii_data *mii;</a>
<a name="ln1840"> </a>
<a name="ln1841">	BFE_LOCK_ASSERT(sc);</a>
<a name="ln1842"> </a>
<a name="ln1843">	mii = device_get_softc(sc-&gt;bfe_miibus);</a>
<a name="ln1844">	mii_tick(mii);</a>
<a name="ln1845">	bfe_stats_update(sc);</a>
<a name="ln1846">	bfe_watchdog(sc);</a>
<a name="ln1847">	callout_reset(&amp;sc-&gt;bfe_stat_co, hz, bfe_tick, sc);</a>
<a name="ln1848">}</a>
<a name="ln1849"> </a>
<a name="ln1850">/*</a>
<a name="ln1851"> * Stop the adapter and free any mbufs allocated to the</a>
<a name="ln1852"> * RX and TX lists.</a>
<a name="ln1853"> */</a>
<a name="ln1854">static void</a>
<a name="ln1855">bfe_stop(struct bfe_softc *sc)</a>
<a name="ln1856">{</a>
<a name="ln1857">	struct ifnet *ifp;</a>
<a name="ln1858"> </a>
<a name="ln1859">	BFE_LOCK_ASSERT(sc);</a>
<a name="ln1860"> </a>
<a name="ln1861">	ifp = sc-&gt;bfe_ifp;</a>
<a name="ln1862">	ifp-&gt;if_drv_flags &amp;= ~(IFF_DRV_RUNNING | IFF_DRV_OACTIVE);</a>
<a name="ln1863">	sc-&gt;bfe_flags &amp;= ~BFE_FLAG_LINK;</a>
<a name="ln1864">	callout_stop(&amp;sc-&gt;bfe_stat_co);</a>
<a name="ln1865">	sc-&gt;bfe_watchdog_timer = 0;</a>
<a name="ln1866"> </a>
<a name="ln1867">	bfe_chip_halt(sc);</a>
<a name="ln1868">	bfe_tx_ring_free(sc);</a>
<a name="ln1869">	bfe_rx_ring_free(sc);</a>
<a name="ln1870">}</a>
<a name="ln1871"> </a>
<a name="ln1872">static int</a>
<a name="ln1873">sysctl_bfe_stats(SYSCTL_HANDLER_ARGS)</a>
<a name="ln1874">{</a>
<a name="ln1875">	struct bfe_softc *sc;</a>
<a name="ln1876">	struct bfe_hw_stats *stats;</a>
<a name="ln1877">	int error, result;</a>
<a name="ln1878"> </a>
<a name="ln1879">	result = -1;</a>
<a name="ln1880">	error = sysctl_handle_int(oidp, &amp;result, 0, req);</a>
<a name="ln1881"> </a>
<a name="ln1882">	if (error != 0 || req-&gt;newptr == NULL)</a>
<a name="ln1883">		return (error);</a>
<a name="ln1884"> </a>
<a name="ln1885">	if (result != 1)</a>
<a name="ln1886">		return (error);</a>
<a name="ln1887"> </a>
<a name="ln1888">	sc = (struct bfe_softc *)arg1;</a>
<a name="ln1889">	stats = &amp;sc-&gt;bfe_stats;</a>
<a name="ln1890"> </a>
<a name="ln1891">	printf(&quot;%s statistics:\n&quot;, device_get_nameunit(sc-&gt;bfe_dev));</a>
<a name="ln1892">	printf(&quot;Transmit good octets : %ju\n&quot;,</a>
<a name="ln1893">	    (uintmax_t)stats-&gt;tx_good_octets);</a>
<a name="ln1894">	printf(&quot;Transmit good frames : %ju\n&quot;,</a>
<a name="ln1895">	    (uintmax_t)stats-&gt;tx_good_frames);</a>
<a name="ln1896">	printf(&quot;Transmit octets : %ju\n&quot;,</a>
<a name="ln1897">	    (uintmax_t)stats-&gt;tx_octets);</a>
<a name="ln1898">	printf(&quot;Transmit frames : %ju\n&quot;,</a>
<a name="ln1899">	    (uintmax_t)stats-&gt;tx_frames);</a>
<a name="ln1900">	printf(&quot;Transmit broadcast frames : %ju\n&quot;,</a>
<a name="ln1901">	    (uintmax_t)stats-&gt;tx_bcast_frames);</a>
<a name="ln1902">	printf(&quot;Transmit multicast frames : %ju\n&quot;,</a>
<a name="ln1903">	    (uintmax_t)stats-&gt;tx_mcast_frames);</a>
<a name="ln1904">	printf(&quot;Transmit frames 64 bytes : %ju\n&quot;,</a>
<a name="ln1905">	    (uint64_t)stats-&gt;tx_pkts_64);</a>
<a name="ln1906">	printf(&quot;Transmit frames 65 to 127 bytes : %ju\n&quot;,</a>
<a name="ln1907">	    (uint64_t)stats-&gt;tx_pkts_65_127);</a>
<a name="ln1908">	printf(&quot;Transmit frames 128 to 255 bytes : %ju\n&quot;,</a>
<a name="ln1909">	    (uint64_t)stats-&gt;tx_pkts_128_255);</a>
<a name="ln1910">	printf(&quot;Transmit frames 256 to 511 bytes : %ju\n&quot;,</a>
<a name="ln1911">	    (uint64_t)stats-&gt;tx_pkts_256_511);</a>
<a name="ln1912">	printf(&quot;Transmit frames 512 to 1023 bytes : %ju\n&quot;,</a>
<a name="ln1913">	    (uint64_t)stats-&gt;tx_pkts_512_1023);</a>
<a name="ln1914">	printf(&quot;Transmit frames 1024 to max bytes : %ju\n&quot;,</a>
<a name="ln1915">	    (uint64_t)stats-&gt;tx_pkts_1024_max);</a>
<a name="ln1916">	printf(&quot;Transmit jabber errors : %u\n&quot;, stats-&gt;tx_jabbers);</a>
<a name="ln1917">	printf(&quot;Transmit oversized frames : %ju\n&quot;,</a>
<a name="ln1918">	    (uint64_t)stats-&gt;tx_oversize_frames);</a>
<a name="ln1919">	printf(&quot;Transmit fragmented frames : %ju\n&quot;,</a>
<a name="ln1920">	    (uint64_t)stats-&gt;tx_frag_frames);</a>
<a name="ln1921">	printf(&quot;Transmit underruns : %u\n&quot;, stats-&gt;tx_colls);</a>
<a name="ln1922">	printf(&quot;Transmit total collisions : %u\n&quot;, stats-&gt;tx_single_colls);</a>
<a name="ln1923">	printf(&quot;Transmit single collisions : %u\n&quot;, stats-&gt;tx_single_colls);</a>
<a name="ln1924">	printf(&quot;Transmit multiple collisions : %u\n&quot;, stats-&gt;tx_multi_colls);</a>
<a name="ln1925">	printf(&quot;Transmit excess collisions : %u\n&quot;, stats-&gt;tx_excess_colls);</a>
<a name="ln1926">	printf(&quot;Transmit late collisions : %u\n&quot;, stats-&gt;tx_late_colls);</a>
<a name="ln1927">	printf(&quot;Transmit deferrals : %u\n&quot;, stats-&gt;tx_deferrals);</a>
<a name="ln1928">	printf(&quot;Transmit carrier losts : %u\n&quot;, stats-&gt;tx_carrier_losts);</a>
<a name="ln1929">	printf(&quot;Transmit pause frames : %u\n&quot;, stats-&gt;tx_pause_frames);</a>
<a name="ln1930"> </a>
<a name="ln1931">	printf(&quot;Receive good octets : %ju\n&quot;,</a>
<a name="ln1932">	    (uintmax_t)stats-&gt;rx_good_octets);</a>
<a name="ln1933">	printf(&quot;Receive good frames : %ju\n&quot;,</a>
<a name="ln1934">	    (uintmax_t)stats-&gt;rx_good_frames);</a>
<a name="ln1935">	printf(&quot;Receive octets : %ju\n&quot;,</a>
<a name="ln1936">	    (uintmax_t)stats-&gt;rx_octets);</a>
<a name="ln1937">	printf(&quot;Receive frames : %ju\n&quot;,</a>
<a name="ln1938">	    (uintmax_t)stats-&gt;rx_frames);</a>
<a name="ln1939">	printf(&quot;Receive broadcast frames : %ju\n&quot;,</a>
<a name="ln1940">	    (uintmax_t)stats-&gt;rx_bcast_frames);</a>
<a name="ln1941">	printf(&quot;Receive multicast frames : %ju\n&quot;,</a>
<a name="ln1942">	    (uintmax_t)stats-&gt;rx_mcast_frames);</a>
<a name="ln1943">	printf(&quot;Receive frames 64 bytes : %ju\n&quot;,</a>
<a name="ln1944">	    (uint64_t)stats-&gt;rx_pkts_64);</a>
<a name="ln1945">	printf(&quot;Receive frames 65 to 127 bytes : %ju\n&quot;,</a>
<a name="ln1946">	    (uint64_t)stats-&gt;rx_pkts_65_127);</a>
<a name="ln1947">	printf(&quot;Receive frames 128 to 255 bytes : %ju\n&quot;,</a>
<a name="ln1948">	    (uint64_t)stats-&gt;rx_pkts_128_255);</a>
<a name="ln1949">	printf(&quot;Receive frames 256 to 511 bytes : %ju\n&quot;,</a>
<a name="ln1950">	    (uint64_t)stats-&gt;rx_pkts_256_511);</a>
<a name="ln1951">	printf(&quot;Receive frames 512 to 1023 bytes : %ju\n&quot;,</a>
<a name="ln1952">	    (uint64_t)stats-&gt;rx_pkts_512_1023);</a>
<a name="ln1953">	printf(&quot;Receive frames 1024 to max bytes : %ju\n&quot;,</a>
<a name="ln1954">	    (uint64_t)stats-&gt;rx_pkts_1024_max);</a>
<a name="ln1955">	printf(&quot;Receive jabber errors : %u\n&quot;, stats-&gt;rx_jabbers);</a>
<a name="ln1956">	printf(&quot;Receive oversized frames : %ju\n&quot;,</a>
<a name="ln1957">	    (uint64_t)stats-&gt;rx_oversize_frames);</a>
<a name="ln1958">	printf(&quot;Receive fragmented frames : %ju\n&quot;,</a>
<a name="ln1959">	    (uint64_t)stats-&gt;rx_frag_frames);</a>
<a name="ln1960">	printf(&quot;Receive missed frames : %u\n&quot;, stats-&gt;rx_missed_frames);</a>
<a name="ln1961">	printf(&quot;Receive CRC align errors : %u\n&quot;, stats-&gt;rx_crc_align_errs);</a>
<a name="ln1962">	printf(&quot;Receive undersized frames : %u\n&quot;, stats-&gt;rx_runts);</a>
<a name="ln1963">	printf(&quot;Receive CRC errors : %u\n&quot;, stats-&gt;rx_crc_errs);</a>
<a name="ln1964">	printf(&quot;Receive align errors : %u\n&quot;, stats-&gt;rx_align_errs);</a>
<a name="ln1965">	printf(&quot;Receive symbol errors : %u\n&quot;, stats-&gt;rx_symbol_errs);</a>
<a name="ln1966">	printf(&quot;Receive pause frames : %u\n&quot;, stats-&gt;rx_pause_frames);</a>
<a name="ln1967">	printf(&quot;Receive control frames : %u\n&quot;, stats-&gt;rx_control_frames);</a>
<a name="ln1968"> </a>
<a name="ln1969">	return (error);</a>
<a name="ln1970">}</a>

</code></pre>
<div class="balloon" rel="1949"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'freebsd_printf' function. The intmax_t/uintmax_t type argument is expected.</p></div>
<div class="balloon" rel="1943"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'freebsd_printf' function. The intmax_t/uintmax_t type argument is expected.</p></div>
<div class="balloon" rel="1919"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'freebsd_printf' function. The intmax_t/uintmax_t type argument is expected.</p></div>
<div class="balloon" rel="1917"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'freebsd_printf' function. The intmax_t/uintmax_t type argument is expected.</p></div>
<div class="balloon" rel="1914"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'freebsd_printf' function. The intmax_t/uintmax_t type argument is expected.</p></div>
<div class="balloon" rel="1912"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'freebsd_printf' function. The intmax_t/uintmax_t type argument is expected.</p></div>
<div class="balloon" rel="1945"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'freebsd_printf' function. The intmax_t/uintmax_t type argument is expected.</p></div>
<div class="balloon" rel="1947"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'freebsd_printf' function. The intmax_t/uintmax_t type argument is expected.</p></div>
<div class="balloon" rel="1951"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'freebsd_printf' function. The intmax_t/uintmax_t type argument is expected.</p></div>
<div class="balloon" rel="1953"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'freebsd_printf' function. The intmax_t/uintmax_t type argument is expected.</p></div>
<div class="balloon" rel="1956"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'freebsd_printf' function. The intmax_t/uintmax_t type argument is expected.</p></div>
<div class="balloon" rel="1958"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'freebsd_printf' function. The intmax_t/uintmax_t type argument is expected.</p></div>
<div class="balloon" rel="1904"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'freebsd_printf' function. The intmax_t/uintmax_t type argument is expected.</p></div>
<div class="balloon" rel="1910"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'freebsd_printf' function. The intmax_t/uintmax_t type argument is expected.</p></div>
<div class="balloon" rel="1906"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'freebsd_printf' function. The intmax_t/uintmax_t type argument is expected.</p></div>
<div class="balloon" rel="1908"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'freebsd_printf' function. The intmax_t/uintmax_t type argument is expected.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
