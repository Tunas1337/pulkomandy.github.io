
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>UdfStructures.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2012, Jérôme Duval, korli@users.berlios.de.</a>
<a name="ln3"> * Copyright (c) 2003 Tyler Dauwalder, tyler@dauwalder.net</a>
<a name="ln4"> * This file may be used under the terms of the MIT License.</a>
<a name="ln5"> */</a>
<a name="ln6">#ifndef _UDF_DISK_STRUCTURES_H</a>
<a name="ln7">#define _UDF_DISK_STRUCTURES_H</a>
<a name="ln8"> </a>
<a name="ln9">#include &lt;string.h&gt;</a>
<a name="ln10"> </a>
<a name="ln11">#include &lt;ByteOrder.h&gt;</a>
<a name="ln12">#include &lt;SupportDefs.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;UdfDebug.h&quot;</a>
<a name="ln15">#include &quot;Utils.h&quot;</a>
<a name="ln16"> </a>
<a name="ln17">#include &quot;Array.h&quot;</a>
<a name="ln18"> </a>
<a name="ln19">/*! \file UdfStructures.h</a>
<a name="ln20"> </a>
<a name="ln21">	\brief UDF on-disk data structure declarations</a>
<a name="ln22">	</a>
<a name="ln23">	UDF is a specialization of the ECMA-167 standard. For the most part,</a>
<a name="ln24">	ECMA-167 structures are used by UDF with special restrictions. In a</a>
<a name="ln25">	few instances, UDF introduces its own structures to augment those</a>
<a name="ln26">	supplied by ECMA-167; those structures are clearly marked.</a>
<a name="ln27">	</a>
<a name="ln28">	For UDF info: &lt;a href='http://www.osta.org'&gt;http://www.osta.org&lt;/a&gt;</a>
<a name="ln29">	For ECMA info: &lt;a href='http://www.ecma-international.org'&gt;http://www.ecma-international.org&lt;/a&gt;</a>
<a name="ln30"> </a>
<a name="ln31">	For lack of a better place to store this info, the structures that</a>
<a name="ln32">	are allowed to have length greater than the logical block size are</a>
<a name="ln33">	as follows (other length restrictions may be found in UDF-2.01 5.1):</a>
<a name="ln34">	- \c logical_volume_descriptor</a>
<a name="ln35">	- \c unallocated_space_descriptor</a>
<a name="ln36">	- \c logical_volume_integrity_descriptor</a>
<a name="ln37">	- \c space_bitmap_descriptor</a>
<a name="ln38"> </a>
<a name="ln39">	Other links of interest:</a>
<a name="ln40">	- &lt;a href='http://www.extra.research.philips.com/udf/'&gt;Philips UDF verifier&lt;/a&gt;</a>
<a name="ln41">	- &lt;a href='http://www.hi-ho.ne.jp/y-komachi/committees/fpro/fpro.htm'&gt;Possible test disc image generator (?)&lt;/a&gt;</a>
<a name="ln42">*/</a>
<a name="ln43"> </a>
<a name="ln44">//----------------------------------------------------------------------</a>
<a name="ln45">// ECMA-167 Part 1</a>
<a name="ln46">//----------------------------------------------------------------------</a>
<a name="ln47"> </a>
<a name="ln48">/*! \brief Character set specifications</a>
<a name="ln49"> </a>
<a name="ln50">	The character_set_info field shall be set to the ASCII string</a>
<a name="ln51">	&quot;OSTA Compressed Unicode&quot; (padded right with NULL chars).</a>
<a name="ln52">	</a>
<a name="ln53">	See also: ECMA 167 1/7.2.1, UDF-2.01 2.1.2</a>
<a name="ln54">*/</a>
<a name="ln55">struct charspec {</a>
<a name="ln56">public:</a>
<a name="ln57">	charspec(uint8 type = 0, const char *info = NULL);</a>
<a name="ln58"> </a>
<a name="ln59">	void dump() const;</a>
<a name="ln60"> </a>
<a name="ln61">	uint8 character_set_type() const { return _character_set_type; } </a>
<a name="ln62">	const char* character_set_info() const { return _character_set_info; }</a>
<a name="ln63">	char* character_set_info() { return _character_set_info; }</a>
<a name="ln64">	</a>
<a name="ln65">	void set_character_set_type(uint8 type) { _character_set_type = type; }</a>
<a name="ln66">	void set_character_set_info(const char *info);</a>
<a name="ln67">private:</a>
<a name="ln68">	uint8 _character_set_type;	//!&lt; to be set to 0 to indicate CS0</a>
<a name="ln69">	char _character_set_info[63];	//!&lt; &quot;OSTA Compressed Unicode&quot;</a>
<a name="ln70">} __attribute__((packed));</a>
<a name="ln71"> </a>
<a name="ln72">extern const charspec kCs0CharacterSet;</a>
<a name="ln73"> </a>
<a name="ln74">/*! \brief Date and time stamp </a>
<a name="ln75"> </a>
<a name="ln76">	See also: ECMA 167 1/7.3, UDF-2.01 2.1.4</a>
<a name="ln77">*/</a>
<a name="ln78">class timestamp {</a>
<a name="ln79">private:</a>
<a name="ln80">	union type_and_timezone_accessor {</a>
<a name="ln81">		uint16 type_and_timezone;</a>
<a name="ln82">		struct {</a>
<a name="ln83">			uint16 timezone:12,</a>
<a name="ln84">			       type:4;</a>
<a name="ln85">		} bits;</a>
<a name="ln86">	};</a>
<a name="ln87"> </a>
<a name="ln88">public:</a>
<a name="ln89">	timestamp() { _clear(); }</a>
<a name="ln90">	timestamp(time_t time);	</a>
<a name="ln91"> </a>
<a name="ln92">	void dump() const;</a>
<a name="ln93"> </a>
<a name="ln94">	// Get functions</a>
<a name="ln95">	uint16 type_and_timezone() const { return B_LENDIAN_TO_HOST_INT16(_type_and_timezone); }</a>
<a name="ln96">	uint8 type() const {</a>
<a name="ln97">		type_and_timezone_accessor t;</a>
<a name="ln98">		t.type_and_timezone = type_and_timezone();</a>
<a name="ln99">		return t.bits.type;</a>
<a name="ln100">	}</a>
<a name="ln101">	int16 timezone() const {</a>
<a name="ln102">		type_and_timezone_accessor t;</a>
<a name="ln103">		t.type_and_timezone = type_and_timezone();</a>
<a name="ln104">		int16 result = t.bits.timezone;</a>
<a name="ln105">		// Fill the lefmost bits with ones if timezone is negative</a>
<a name="ln106">		result &lt;&lt;= 4;</a>
<a name="ln107">		result &gt;&gt;= 4;	</a>
<a name="ln108">		return result;</a>
<a name="ln109">	}</a>
<a name="ln110">	uint16 year() const { return B_LENDIAN_TO_HOST_INT16(_year); }</a>
<a name="ln111">	uint8 month() const { return _month; }</a>
<a name="ln112">	uint8 day() const { return _day; }</a>
<a name="ln113">	uint8 hour() const { return _hour; }</a>
<a name="ln114">	uint8 minute() const { return _minute; }</a>
<a name="ln115">	uint8 second() const { return _second; }</a>
<a name="ln116">	uint8 centisecond() const { return _centisecond; }</a>
<a name="ln117">	uint8 hundred_microsecond() const { return _hundred_microsecond; }</a>
<a name="ln118">	uint8 microsecond() const { return _microsecond; }</a>
<a name="ln119">	</a>
<a name="ln120">	// Set functions</a>
<a name="ln121">	void set_type_and_timezone(uint16 type_and_timezone) { </a>
<a name="ln122">		_type_and_timezone = B_HOST_TO_LENDIAN_INT16(type_and_timezone); }</a>
<a name="ln123">	void set_type(uint8 type) {</a>
<a name="ln124">		type_and_timezone_accessor t;</a>
<a name="ln125">		t.type_and_timezone = type_and_timezone();</a>
<a name="ln126">		t.bits.type = type;</a>
<a name="ln127">		set_type_and_timezone(t.type_and_timezone);</a>
<a name="ln128">	}</a>
<a name="ln129">	void set_timezone(int16 tz) {</a>
<a name="ln130">		type_and_timezone_accessor t;</a>
<a name="ln131">		t.type_and_timezone = type_and_timezone();</a>
<a name="ln132">		t.bits.timezone = tz;</a>
<a name="ln133">		set_type_and_timezone(t.type_and_timezone);</a>
<a name="ln134">	}</a>
<a name="ln135">	void set_year(uint16 year) { _year = B_HOST_TO_LENDIAN_INT16(year); }</a>
<a name="ln136">	void set_month(uint8 month) { _month = month; }</a>
<a name="ln137">	void set_day(uint8 day) { _day = day; }</a>
<a name="ln138">	void set_hour(uint8 hour) { _hour = hour; }</a>
<a name="ln139">	void set_minute(uint8 minute) { _minute = minute; }</a>
<a name="ln140">	void set_second(uint8 second) { _second = second; }</a>
<a name="ln141">	void set_centisecond(uint8 centisecond) { _centisecond = centisecond; }</a>
<a name="ln142">	void set_hundred_microsecond(uint8 hundred_microsecond) { </a>
<a name="ln143">		_hundred_microsecond = hundred_microsecond; }</a>
<a name="ln144">	void set_microsecond(uint8 microsecond) { _microsecond = microsecond; }</a>
<a name="ln145">private:</a>
<a name="ln146">	void _clear();</a>
<a name="ln147">	</a>
<a name="ln148">	uint16 _type_and_timezone;</a>
<a name="ln149">	uint16 _year;</a>
<a name="ln150">	uint8 _month;</a>
<a name="ln151">	uint8 _day;</a>
<a name="ln152">	uint8 _hour;</a>
<a name="ln153">	uint8 _minute;</a>
<a name="ln154">	uint8 _second;</a>
<a name="ln155">	uint8 _centisecond;</a>
<a name="ln156">	uint8 _hundred_microsecond;</a>
<a name="ln157">	uint8 _microsecond;</a>
<a name="ln158"> </a>
<a name="ln159">} __attribute__((packed));</a>
<a name="ln160"> </a>
<a name="ln161"> </a>
<a name="ln162">/*! \brief UDF ID Identify Suffix</a>
<a name="ln163"> </a>
<a name="ln164">	See also: UDF 2.50 2.1.5.3</a>
<a name="ln165">*/</a>
<a name="ln166">struct udf_id_suffix {</a>
<a name="ln167">public:</a>
<a name="ln168">	udf_id_suffix(uint16 udfRevision, uint8 os_class, uint8 os_identifier);</a>
<a name="ln169"> </a>
<a name="ln170">	//! Note that revision 2.50 is denoted by 0x0250.</a>
<a name="ln171">	uint16 udf_revision() const { return _udf_revision; }</a>
<a name="ln172">	uint8 os_class() const { return _os_class; }</a>
<a name="ln173">	uint8 os_identifier() const { return _os_identifier; }</a>
<a name="ln174"> </a>
<a name="ln175">	void set_os_class(uint8 os_class) { _os_class = os_class; }</a>
<a name="ln176">	void set_os_identifier(uint8 identifier) { _os_identifier = identifier; }</a>
<a name="ln177">private:</a>
<a name="ln178">	uint16 _udf_revision;</a>
<a name="ln179">	uint8 _os_class;</a>
<a name="ln180">	uint8 _os_identifier;</a>
<a name="ln181">	array&lt;uint8, 4&gt; _reserved;</a>
<a name="ln182">};</a>
<a name="ln183"> </a>
<a name="ln184">/*! \brief Implementation ID Identify Suffix</a>
<a name="ln185"> </a>
<a name="ln186">	See also: UDF 2.50 2.1.5.3</a>
<a name="ln187">*/</a>
<a name="ln188">struct implementation_id_suffix {</a>
<a name="ln189">public:</a>
<a name="ln190">	implementation_id_suffix(uint8 os_class, uint8 os_identifier);</a>
<a name="ln191"> </a>
<a name="ln192">	uint8 os_class() const { return _os_class; }</a>
<a name="ln193">	uint8 os_identifier() const { return _os_identifier; }</a>
<a name="ln194"> </a>
<a name="ln195">	void set_os_class(uint8 os_class) { _os_class = os_class; }</a>
<a name="ln196">	void set_os_identifier(uint8 identifier) { _os_identifier = identifier; }</a>
<a name="ln197">private:</a>
<a name="ln198">	uint8 _os_class;</a>
<a name="ln199">	uint8 _os_identifier;</a>
<a name="ln200">	array&lt;uint8, 6&gt; _implementation_use;</a>
<a name="ln201">};</a>
<a name="ln202"> </a>
<a name="ln203">/*! \brief Operating system classes for implementation_id_suffixes</a>
<a name="ln204"> </a>
<a name="ln205">	See also: Udf 2.50 6.3</a>
<a name="ln206">*/</a>
<a name="ln207">enum {</a>
<a name="ln208">	OS_UNDEFINED = 0,</a>
<a name="ln209">	OS_DOS,</a>
<a name="ln210">	OS_OS2,</a>
<a name="ln211">	OS_MACOS,</a>
<a name="ln212">	OS_UNIX,</a>
<a name="ln213">	OS_WIN9X,</a>
<a name="ln214">	OS_WINNT,</a>
<a name="ln215">	OS_OS400,</a>
<a name="ln216">	OS_BEOS,</a>
<a name="ln217">	OS_WINCE</a>
<a name="ln218">};</a>
<a name="ln219">	</a>
<a name="ln220">/*! \brief BeOS operating system classes identifiers for implementation_id_suffixes</a>
<a name="ln221"> </a>
<a name="ln222">	See also: Udf 2.50 6.3</a>
<a name="ln223">*/</a>
<a name="ln224">enum {</a>
<a name="ln225">	BEOS_GENERIC = 0,</a>
<a name="ln226">	BEOS_OPENBEOS = 1	// not part of the standard, but perhaps someday. :-)</a>
<a name="ln227">};</a>
<a name="ln228"> </a>
<a name="ln229">/*! \brief Domain ID Identify Suffix</a>
<a name="ln230"> </a>
<a name="ln231">	See also: UDF 2.50 2.1.5.3</a>
<a name="ln232">*/</a>
<a name="ln233">struct domain_id_suffix {</a>
<a name="ln234">public:</a>
<a name="ln235">	domain_id_suffix(uint16 udfRevision, uint8 domainFlags);</a>
<a name="ln236"> </a>
<a name="ln237">	//! Note that revision 2.50 is denoted by 0x0250.</a>
<a name="ln238">	uint16 udf_revision() const { return _udf_revision; }</a>
<a name="ln239">	uint8 domain_flags() const { return _domain_flags; }</a>
<a name="ln240"> </a>
<a name="ln241">	void set_udf_revision(uint16 revision) { _udf_revision = B_HOST_TO_LENDIAN_INT16(revision); }</a>
<a name="ln242">	void set_domain_flags(uint8 flags) { _domain_flags = flags; }</a>
<a name="ln243">private:</a>
<a name="ln244">	uint16 _udf_revision;</a>
<a name="ln245">	uint8 _domain_flags;</a>
<a name="ln246">	array&lt;uint8, 5&gt; _reserved;</a>
<a name="ln247">};</a>
<a name="ln248"> </a>
<a name="ln249">/*! \brief Domain flags</a>
<a name="ln250"> </a>
<a name="ln251">	See also: UDF 2.50 2.1.5.3</a>
<a name="ln252">*/</a>
<a name="ln253">enum {</a>
<a name="ln254">	DF_HARD_WRITE_PROTECT = 0x01,</a>
<a name="ln255">	DF_SOFT_WRITE_PROTECT = 0x02</a>
<a name="ln256">};</a>
<a name="ln257">	</a>
<a name="ln258">/*! \brief Identifier used to designate the implementation responsible</a>
<a name="ln259">	for writing associated data structures on the medium.</a>
<a name="ln260">	</a>
<a name="ln261">	See also: ECMA 167 1/7.4, UDF 2.01 2.1.5</a>
<a name="ln262">*/</a>
<a name="ln263">struct entity_id {</a>
<a name="ln264">public:</a>
<a name="ln265">	static const int kIdentifierLength = 23;</a>
<a name="ln266">	static const int kIdentifierSuffixLength = 8;</a>
<a name="ln267"> </a>
<a name="ln268">	entity_id(uint8 flags = 0, const char *identifier = NULL,</a>
<a name="ln269">	          uint8 *identifier_suffix = NULL);</a>
<a name="ln270">	entity_id(uint8 flags, const char *identifier,</a>
<a name="ln271">	          const udf_id_suffix &amp;suffix);</a>
<a name="ln272">	entity_id(uint8 flags, const char *identifier,</a>
<a name="ln273">	          const implementation_id_suffix &amp;suffix);</a>
<a name="ln274">	entity_id(uint8 flags, const char *identifier,</a>
<a name="ln275">	          const domain_id_suffix &amp;suffix);</a>
<a name="ln276">	</a>
<a name="ln277">	void dump() const;</a>
<a name="ln278">	bool matches(const entity_id &amp;id) const;</a>
<a name="ln279"> </a>
<a name="ln280">	// Get functions</a>
<a name="ln281">	uint8 flags() const { return _flags; }</a>
<a name="ln282">	const char* identifier() const { return _identifier; }</a>
<a name="ln283">	char* identifier() { return _identifier; }</a>
<a name="ln284">	const array&lt;uint8, kIdentifierSuffixLength&gt;&amp; identifier_suffix() const { return _identifier_suffix; }</a>
<a name="ln285">	array&lt;uint8, kIdentifierSuffixLength&gt;&amp; identifier_suffix() { return _identifier_suffix; }</a>
<a name="ln286"> </a>
<a name="ln287">	// Set functions</a>
<a name="ln288">	void set_flags(uint8 flags) { _flags = flags; }</a>
<a name="ln289">private:</a>
<a name="ln290">	uint8 _flags;</a>
<a name="ln291">	char _identifier[kIdentifierLength];</a>
<a name="ln292">	array&lt;uint8, kIdentifierSuffixLength&gt; _identifier_suffix;</a>
<a name="ln293">} __attribute__((packed));</a>
<a name="ln294"> </a>
<a name="ln295">extern entity_id kMetadataPartitionMapId;</a>
<a name="ln296">extern entity_id kSparablePartitionMapId;</a>
<a name="ln297">extern entity_id kVirtualPartitionMapId;</a>
<a name="ln298">extern entity_id kImplementationId;</a>
<a name="ln299">extern entity_id kPartitionContentsId1xx;</a>
<a name="ln300">extern entity_id kPartitionContentsId2xx;</a>
<a name="ln301">extern entity_id kUdfId;</a>
<a name="ln302">extern entity_id kLogicalVolumeInfoId150;</a>
<a name="ln303">extern entity_id kLogicalVolumeInfoId201;</a>
<a name="ln304">extern entity_id kDomainId150;</a>
<a name="ln305">extern entity_id kDomainId201;</a>
<a name="ln306">extern void init_entities(void);</a>
<a name="ln307"> </a>
<a name="ln308">//----------------------------------------------------------------------</a>
<a name="ln309">// ECMA-167 Part 2</a>
<a name="ln310">//----------------------------------------------------------------------</a>
<a name="ln311"> </a>
<a name="ln312"> </a>
<a name="ln313">/*! \brief Header for volume structure descriptors</a>
<a name="ln314"> </a>
<a name="ln315">	Each descriptor consumes an entire block. All unused trailing</a>
<a name="ln316">	bytes in the descriptor should be set to 0.</a>
<a name="ln317">	</a>
<a name="ln318">	The following descriptors contain no more information than</a>
<a name="ln319">	that contained in the header:</a>
<a name="ln320">	</a>
<a name="ln321">	- BEA01:</a>
<a name="ln322">	  - type: 0</a>
<a name="ln323">	  - id: &quot;BEA01&quot;</a>
<a name="ln324">	  - version: 1</a>
<a name="ln325"> </a>
<a name="ln326">	- TEA01:</a>
<a name="ln327">	  - type: 0</a>
<a name="ln328">	  - id: &quot;TEA01&quot;</a>
<a name="ln329">	  - version: 1</a>
<a name="ln330">	</a>
<a name="ln331">	- NSR03:</a>
<a name="ln332">	  - type: 0</a>
<a name="ln333">	  - id: &quot;NSR03&quot;</a>
<a name="ln334">	  - version: 1</a>
<a name="ln335"> </a>
<a name="ln336">	See also: ECMA 167 2/9.1</a>
<a name="ln337">*/	</a>
<a name="ln338">struct volume_structure_descriptor_header {</a>
<a name="ln339">public:</a>
<a name="ln340">	volume_structure_descriptor_header(uint8 type, const char *id, uint8 version);</a>
<a name="ln341">	</a>
<a name="ln342">	uint8 type;</a>
<a name="ln343">	char id[5];</a>
<a name="ln344">	uint8 version;</a>
<a name="ln345">	</a>
<a name="ln346">	bool id_matches(const char *id);</a>
<a name="ln347">} __attribute__((packed));</a>
<a name="ln348"> </a>
<a name="ln349">// Volume structure descriptor ids </a>
<a name="ln350">extern const char* kVSDID_BEA;</a>
<a name="ln351">extern const char* kVSDID_TEA;</a>
<a name="ln352">extern const char* kVSDID_BOOT;</a>
<a name="ln353">extern const char* kVSDID_ISO;</a>
<a name="ln354">extern const char* kVSDID_ECMA167_2;</a>
<a name="ln355">extern const char* kVSDID_ECMA167_3;</a>
<a name="ln356">extern const char* kVSDID_ECMA168;</a>
<a name="ln357"> </a>
<a name="ln358">//----------------------------------------------------------------------</a>
<a name="ln359">// ECMA-167 Part 3</a>
<a name="ln360">//----------------------------------------------------------------------</a>
<a name="ln361"> </a>
<a name="ln362"> </a>
<a name="ln363">/*! \brief Location and length of a contiguous chunk of data on the volume.</a>
<a name="ln364"> </a>
<a name="ln365">	\c _location is an absolute block address.</a>
<a name="ln366"> </a>
<a name="ln367">	See also: ECMA 167 3/7.1</a>
<a name="ln368">*/</a>
<a name="ln369">struct extent_address {</a>
<a name="ln370">public:</a>
<a name="ln371">	extent_address(uint32 location = 0, uint32 length = 0);</a>
<a name="ln372"> </a>
<a name="ln373">	void dump() const;</a>
<a name="ln374"> </a>
<a name="ln375">	uint32 length() const { return B_LENDIAN_TO_HOST_INT32(_length); }	</a>
<a name="ln376">	uint32 location() const { return B_LENDIAN_TO_HOST_INT32(_location); }</a>
<a name="ln377">	</a>
<a name="ln378">	void set_length(int32 length) { _length = B_HOST_TO_LENDIAN_INT32(length); }</a>
<a name="ln379">	void set_location(int32 location) { _location = B_HOST_TO_LENDIAN_INT32(location); }</a>
<a name="ln380">private:</a>
<a name="ln381">	uint32 _length;</a>
<a name="ln382">	uint32 _location;</a>
<a name="ln383">} __attribute__((packed));</a>
<a name="ln384"> </a>
<a name="ln385"> </a>
<a name="ln386">/*! \brief Location of a logical block within a logical volume.</a>
<a name="ln387"> </a>
<a name="ln388">	See also: ECMA 167 4/7.1</a>
<a name="ln389">*/</a>
<a name="ln390">struct logical_block_address {</a>
<a name="ln391">public:</a>
<a name="ln392">	void dump() const;</a>
<a name="ln393">	logical_block_address(uint16 partition = 0, uint32 block = 0);</a>
<a name="ln394"> </a>
<a name="ln395">	uint32 block() const { return B_LENDIAN_TO_HOST_INT32(_block); }</a>
<a name="ln396">	uint16 partition() const { return B_LENDIAN_TO_HOST_INT16(_partition); }</a>
<a name="ln397">	</a>
<a name="ln398">	void set_block(uint32 block) { _block = B_HOST_TO_LENDIAN_INT32(block); }</a>
<a name="ln399">	void set_partition(uint16 partition) { _partition = B_HOST_TO_LENDIAN_INT16(partition); }</a>
<a name="ln400">	</a>
<a name="ln401">private:</a>
<a name="ln402">	uint32 _block;	//!&lt; Block location relative to start of corresponding partition</a>
<a name="ln403">	uint16 _partition;	//!&lt; Numeric partition id within logical volume</a>
<a name="ln404">} __attribute__((packed));</a>
<a name="ln405"> </a>
<a name="ln406">/*! \brief Extent types used in short_address, long_address,</a>
<a name="ln407">	and extended_address.</a>
<a name="ln408">	</a>
<a name="ln409">	See also: ECMA-167 4/14.14.1.1</a>
<a name="ln410">*/</a>
<a name="ln411">enum extent_type {</a>
<a name="ln412">	EXTENT_TYPE_RECORDED = 0,	//!&lt; Allocated and recorded</a>
<a name="ln413">	EXTENT_TYPE_ALLOCATED,		//!&lt; Allocated but unrecorded</a>
<a name="ln414">	EXTENT_TYPE_UNALLOCATED,	//!&lt; Unallocated and unrecorded</a>
<a name="ln415">	EXTENT_TYPE_CONTINUATION,	//!&lt; Specifies next extent of descriptors</a>
<a name="ln416">};</a>
<a name="ln417"> </a>
<a name="ln418"> </a>
<a name="ln419">/*! \brief Allocation descriptor.</a>
<a name="ln420"> </a>
<a name="ln421">	See also: ECMA 167 4/14.14.1</a>
<a name="ln422">*/</a>
<a name="ln423">struct short_address {</a>
<a name="ln424">private:</a>
<a name="ln425">	union type_and_length_accessor {</a>
<a name="ln426">		uint32 type_and_length;</a>
<a name="ln427">		struct {</a>
<a name="ln428">			uint32 length:30,</a>
<a name="ln429">			       type:2;</a>
<a name="ln430">//			uint32 type:2,</a>
<a name="ln431">//			       length:30;</a>
<a name="ln432">		} bits;</a>
<a name="ln433">	};</a>
<a name="ln434">	</a>
<a name="ln435">public:</a>
<a name="ln436">	void dump() const;</a>
<a name="ln437"> </a>
<a name="ln438">	uint8 type() const {</a>
<a name="ln439">		type_and_length_accessor t;</a>
<a name="ln440">		t.type_and_length = type_and_length();</a>
<a name="ln441">		return t.bits.type;</a>
<a name="ln442">	}</a>
<a name="ln443">	uint32 length() const {</a>
<a name="ln444">		type_and_length_accessor t;</a>
<a name="ln445">		t.type_and_length = type_and_length();</a>
<a name="ln446">		return t.bits.length;</a>
<a name="ln447">	}</a>
<a name="ln448">	uint32 block() const { return B_LENDIAN_TO_HOST_INT32(_block); }</a>
<a name="ln449"> </a>
<a name="ln450">	void set_type(uint8 type) {</a>
<a name="ln451">		type_and_length_accessor t;</a>
<a name="ln452">		t.type_and_length = type_and_length();</a>
<a name="ln453">		t.bits.type = type;</a>
<a name="ln454">		set_type_and_length(t.type_and_length);</a>
<a name="ln455">	}</a>
<a name="ln456">	void set_length(uint32 length) {</a>
<a name="ln457">		type_and_length_accessor t;</a>
<a name="ln458">		t.type_and_length = type_and_length();</a>
<a name="ln459">		t.bits.length = length;</a>
<a name="ln460">		set_type_and_length(t.type_and_length);</a>
<a name="ln461">	}</a>
<a name="ln462">	void set_block(uint32 block) { _block = B_HOST_TO_LENDIAN_INT32(block); }</a>
<a name="ln463">private:</a>
<a name="ln464">	uint32 type_and_length() const { return B_LENDIAN_TO_HOST_INT32(_type_and_length); }</a>
<a name="ln465">	void set_type_and_length(uint32 value) { _type_and_length = B_HOST_TO_LENDIAN_INT32(value); }</a>
<a name="ln466"> </a>
<a name="ln467">	uint32 _type_and_length;</a>
<a name="ln468">	uint32 _block;</a>
<a name="ln469">} __attribute__((packed));</a>
<a name="ln470"> </a>
<a name="ln471"> </a>
<a name="ln472">/*! \brief Allocation descriptor w/ 6 byte implementation use field.</a>
<a name="ln473"> </a>
<a name="ln474">	See also: ECMA 167 4/14.14.2</a>
<a name="ln475">*/</a>
<a name="ln476">struct long_address {</a>
<a name="ln477">private:</a>
<a name="ln478">	union type_and_length_accessor {</a>
<a name="ln479">		uint32 type_and_length;</a>
<a name="ln480">		struct {</a>
<a name="ln481">			uint32 length:30,</a>
<a name="ln482">			       type:2;</a>
<a name="ln483">		} bits;</a>
<a name="ln484">	};</a>
<a name="ln485">	</a>
<a name="ln486">public:</a>
<a name="ln487">	long_address(uint16 partition = 0, uint32 block = 0, uint32 length = 0,</a>
<a name="ln488">	             uint8 type = 0);</a>
<a name="ln489"> </a>
<a name="ln490">	void dump() const;</a>
<a name="ln491"> </a>
<a name="ln492">	uint8 type() const {</a>
<a name="ln493">		type_and_length_accessor t;</a>
<a name="ln494">		t.type_and_length = type_and_length();</a>
<a name="ln495">		return t.bits.type;</a>
<a name="ln496">	}</a>
<a name="ln497">	uint32 length() const {</a>
<a name="ln498">		type_and_length_accessor t;</a>
<a name="ln499">		t.type_and_length = type_and_length();</a>
<a name="ln500">		return t.bits.length;</a>
<a name="ln501">	}</a>
<a name="ln502">	</a>
<a name="ln503">	uint32 block() const { return _location.block(); }</a>
<a name="ln504">	uint16 partition() const { return _location.partition(); }</a>
<a name="ln505">	</a>
<a name="ln506">	const array&lt;uint8, 6&gt;&amp; implementation_use() const { return _implementation_use; }</a>
<a name="ln507">	array&lt;uint8, 6&gt;&amp; implementation_use() { return _implementation_use; }</a>
<a name="ln508">	</a>
<a name="ln509">	uint16 flags() const { return B_LENDIAN_TO_HOST_INT16(_accessor().flags); }</a>
<a name="ln510">	uint32 unique_id() const { return B_LENDIAN_TO_HOST_INT32(_accessor().unique_id); }</a>
<a name="ln511"> </a>
<a name="ln512">	void set_type(uint8 type) {</a>
<a name="ln513">		type_and_length_accessor t;</a>
<a name="ln514">		t.type_and_length = type_and_length();</a>
<a name="ln515">		t.bits.type = type;</a>
<a name="ln516">		set_type_and_length(t.type_and_length);</a>
<a name="ln517">	}</a>
<a name="ln518">	void set_length(uint32 length) {</a>
<a name="ln519">		type_and_length_accessor t;</a>
<a name="ln520">		t.type_and_length = type_and_length();</a>
<a name="ln521">		t.bits.length = length;</a>
<a name="ln522">		set_type_and_length(t.type_and_length);</a>
<a name="ln523">	}</a>
<a name="ln524">	void set_block(uint32 block) { _location.set_block(block); }</a>
<a name="ln525">	void set_partition(uint16 partition) { _location.set_partition(partition); }</a>
<a name="ln526">	</a>
<a name="ln527">	void set_flags(uint16 flags) { _accessor().flags = B_HOST_TO_LENDIAN_INT16(flags); }</a>
<a name="ln528">	void set_unique_id(uint32 id) { _accessor().unique_id = B_HOST_TO_LENDIAN_INT32(id); }</a>
<a name="ln529"> </a>
<a name="ln530">	void set_to(uint32 block, uint16 partition, uint32 length = 1,</a>
<a name="ln531">	       uint8 type = EXTENT_TYPE_RECORDED, uint16 flags = 0, uint32 unique_id = 0)</a>
<a name="ln532">	{</a>
<a name="ln533">		set_block(block);</a>
<a name="ln534">		set_partition(partition);</a>
<a name="ln535">		set_length(length);</a>
<a name="ln536">		set_type(type);</a>
<a name="ln537">		set_flags(flags);</a>
<a name="ln538">		set_unique_id(unique_id);</a>
<a name="ln539">	}</a>
<a name="ln540"> </a>
<a name="ln541">private:</a>
<a name="ln542">	//! See UDF-2.50 2.3.4.3</a>
<a name="ln543">	struct _implementation_use_accessor {</a>
<a name="ln544">		uint16 flags;</a>
<a name="ln545">		uint32 unique_id;</a>
<a name="ln546">	} __attribute__((packed));</a>
<a name="ln547">	</a>
<a name="ln548">	_implementation_use_accessor&amp; _accessor() { return</a>
<a name="ln549">		*reinterpret_cast&lt;_implementation_use_accessor*&gt;(implementation_use().data); }</a>
<a name="ln550">	const _implementation_use_accessor&amp; _accessor() const { return</a>
<a name="ln551">		*reinterpret_cast&lt;const _implementation_use_accessor*&gt;(implementation_use().data); }</a>
<a name="ln552">	</a>
<a name="ln553">	uint32 type_and_length() const { return B_LENDIAN_TO_HOST_INT32(_type_and_length); }</a>
<a name="ln554">	void set_type_and_length(uint32 value) { _type_and_length = B_HOST_TO_LENDIAN_INT32(value); }</a>
<a name="ln555"> </a>
<a name="ln556">	uint32 _type_and_length;</a>
<a name="ln557">	logical_block_address _location;</a>
<a name="ln558">	array&lt;uint8, 6&gt; _implementation_use;</a>
<a name="ln559">} __attribute__((packed));</a>
<a name="ln560"> </a>
<a name="ln561">/*! \brief Common tag found at the beginning of most udf descriptor structures.</a>
<a name="ln562"> </a>
<a name="ln563">	For error checking, \c descriptor_tag  structures have:</a>
<a name="ln564">	- The disk location of the tag redundantly stored in the tag itself</a>
<a name="ln565">	- A checksum value for the tag</a>
<a name="ln566">	- A CRC value and length</a>
<a name="ln567"> </a>
<a name="ln568">	See also: ECMA 167 1/7.2, UDF 2.01 2.2.1, UDF 2.01 2.3.1</a>
<a name="ln569">*/</a>
<a name="ln570">struct descriptor_tag {</a>
<a name="ln571">public:</a>
<a name="ln572">	void dump() const;	</a>
<a name="ln573"> </a>
<a name="ln574">	status_t init_check(uint32 block, bool calculateCrc = true);	</a>
<a name="ln575"> </a>
<a name="ln576">	uint16 id() const { return B_LENDIAN_TO_HOST_INT16(_id); }</a>
<a name="ln577">	uint16 version() const { return B_LENDIAN_TO_HOST_INT16(_version); }</a>
<a name="ln578">	uint8 checksum() const { return _checksum; }</a>
<a name="ln579">	uint16 serial_number() const { return B_LENDIAN_TO_HOST_INT16(_serial_number); }</a>
<a name="ln580">	uint16 crc() const { return B_LENDIAN_TO_HOST_INT16(_crc); }</a>
<a name="ln581">	uint16 crc_length() const { return B_LENDIAN_TO_HOST_INT16(_crc_length); }</a>
<a name="ln582">	uint32 location() const { return B_LENDIAN_TO_HOST_INT32(_location); }</a>
<a name="ln583"> </a>
<a name="ln584">	void set_id(uint16 id) { _id = B_HOST_TO_LENDIAN_INT16(id); }</a>
<a name="ln585">	void set_version(uint16 version) { _version = B_HOST_TO_LENDIAN_INT16(version); }</a>
<a name="ln586">	void set_checksum(uint8 checksum) { _checksum = checksum; }</a>
<a name="ln587">	void set_serial_number(uint16 serial_number) { _serial_number = B_HOST_TO_LENDIAN_INT16(serial_number); }</a>
<a name="ln588">	void set_crc(uint16 crc) { _crc = B_HOST_TO_LENDIAN_INT16(crc); }</a>
<a name="ln589">	void set_crc_length(uint16 crc_length) { _crc_length = B_HOST_TO_LENDIAN_INT16(crc_length); }</a>
<a name="ln590">	void set_location(uint32 location) { _location = B_HOST_TO_LENDIAN_INT32(location); }</a>
<a name="ln591">	</a>
<a name="ln592">	/*! \brief Calculates and sets the crc length, crc checksumm, and</a>
<a name="ln593">		checksum for the tag.</a>
<a name="ln594">		</a>
<a name="ln595">		This function should not be called until all member variables in</a>
<a name="ln596">		the descriptor_tag's enclosing descriptor and all member variables</a>
<a name="ln597">		in the descriptor_tag itself other than crc_length, crc, and checksum</a>
<a name="ln598">		have been set (since the checksum is based off of values in the</a>
<a name="ln599">		descriptor_tag, and the crc is based off the values in and the</a>
<a name="ln600">		size of the	enclosing descriptor).</a>
<a name="ln601">	</a>
<a name="ln602">		\param The tag's enclosing descriptor.</a>
<a name="ln603">		\param The size of the tag's enclosing descriptor (including the</a>
<a name="ln604">		       tag); only necessary if different from sizeof(Descriptor).</a>
<a name="ln605">	*/</a>
<a name="ln606">	template &lt;class Descriptor&gt;</a>
<a name="ln607">	void</a>
<a name="ln608">	set_checksums(Descriptor &amp;descriptor, uint16 size = sizeof(Descriptor))</a>
<a name="ln609">	{</a>
<a name="ln610"> </a>
<a name="ln611">		// check that this tag is actually owned by</a>
<a name="ln612">		// the given descriptor</a>
<a name="ln613">		if (this == &amp;descriptor.tag())</a>
<a name="ln614">		{</a>
<a name="ln615">			// crc_length, based off provided descriptor</a>
<a name="ln616">			set_crc_length(size - sizeof(descriptor_tag));</a>
<a name="ln617">			// crc</a>
<a name="ln618">			uint16 crc = calculate_crc(reinterpret_cast&lt;uint8*&gt;(this)</a>
<a name="ln619">			               + sizeof(descriptor_tag), crc_length());</a>
<a name="ln620">			set_crc(crc);</a>
<a name="ln621">			// checksum (which depends on the other two values)</a>
<a name="ln622">			uint32 sum = 0;</a>
<a name="ln623">			for (int i = 0; i &lt;= 3; i++)</a>
<a name="ln624">				sum += reinterpret_cast&lt;uint8*&gt;(this)[i];</a>
<a name="ln625">			for (int i = 5; i &lt;= 15; i++)</a>
<a name="ln626">				sum += reinterpret_cast&lt;uint8*&gt;(this)[i];</a>
<a name="ln627">			set_checksum(sum % 256);</a>
<a name="ln628">		}</a>
<a name="ln629">	}</a>
<a name="ln630">private:</a>
<a name="ln631">	uint16 _id;</a>
<a name="ln632">	uint16 _version;</a>
<a name="ln633">	uint8 _checksum;			//!&lt; Sum modulo 256 of bytes 0-3 and 5-15 of this struct.</a>
<a name="ln634">	uint8 _reserved;			//!&lt; Set to #00.</a>
<a name="ln635">	uint16 _serial_number;</a>
<a name="ln636">	uint16 _crc;				//!&lt; May be 0 if \c crc_length field is 0.</a>
<a name="ln637">	/*! \brief Length of the data chunk used to calculate CRC.</a>
<a name="ln638">	</a>
<a name="ln639">		If 0, no CRC was calculated, and the \c crc field must be 0.</a>
<a name="ln640">		</a>
<a name="ln641">		According to UDF-2.01 2.3.1.2, the CRC shall be calculated for all descriptors</a>
<a name="ln642">		unless otherwise noted, and this field shall be set to:</a>
<a name="ln643">		</a>
<a name="ln644">		&lt;code&gt;(descriptor length) - (descriptor tag length)&lt;/code&gt;</a>
<a name="ln645">	*/</a>
<a name="ln646">	uint16 _crc_length;</a>
<a name="ln647">	/*! \brief Address of this tag within its partition (for error checking).</a>
<a name="ln648">	</a>
<a name="ln649">		For virtually addressed structures (i.e. those accessed thru a VAT), this</a>
<a name="ln650">		shall be the virtual address, not the physical or logical address.</a>
<a name="ln651">	*/</a>
<a name="ln652">	uint32 _location;		</a>
<a name="ln653">	</a>
<a name="ln654">} __attribute__((packed));</a>
<a name="ln655"> </a>
<a name="ln656"> </a>
<a name="ln657">/*! \c descriptor_tag ::id values</a>
<a name="ln658">*/</a>
<a name="ln659">enum tag_id {</a>
<a name="ln660">	TAGID_UNDEFINED	= 0,</a>
<a name="ln661"> </a>
<a name="ln662">	// ECMA 167, PART 3</a>
<a name="ln663">	TAGID_PRIMARY_VOLUME_DESCRIPTOR,</a>
<a name="ln664">	TAGID_ANCHOR_VOLUME_DESCRIPTOR_POINTER,</a>
<a name="ln665">	TAGID_VOLUME_DESCRIPTOR_POINTER,</a>
<a name="ln666">	TAGID_IMPLEMENTATION_USE_VOLUME_DESCRIPTOR,</a>
<a name="ln667">	TAGID_PARTITION_DESCRIPTOR,</a>
<a name="ln668">	TAGID_LOGICAL_VOLUME_DESCRIPTOR,</a>
<a name="ln669">	TAGID_UNALLOCATED_SPACE_DESCRIPTOR,</a>
<a name="ln670">	TAGID_TERMINATING_DESCRIPTOR,</a>
<a name="ln671">	TAGID_LOGICAL_VOLUME_INTEGRITY_DESCRIPTOR,</a>
<a name="ln672">	</a>
<a name="ln673">	TAGID_CUSTOM_START = 65280,</a>
<a name="ln674">	TAGID_CUSTOM_END = 65535,</a>
<a name="ln675">	</a>
<a name="ln676">	// ECMA 167, PART 4</a>
<a name="ln677">	TAGID_FILE_SET_DESCRIPTOR = 256,</a>
<a name="ln678">	TAGID_FILE_ID_DESCRIPTOR,</a>
<a name="ln679">	TAGID_ALLOCATION_EXTENT_DESCRIPTOR,</a>
<a name="ln680">	TAGID_INDIRECT_ENTRY,</a>
<a name="ln681">	TAGID_TERMINAL_ENTRY,</a>
<a name="ln682">	TAGID_FILE_ENTRY,</a>
<a name="ln683">	TAGID_EXTENDED_ATTRIBUTE_HEADER_DESCRIPTOR,</a>
<a name="ln684">	TAGID_UNALLOCATED_SPACE_ENTRY,</a>
<a name="ln685">	TAGID_SPACE_BITMAP_DESCRIPTOR,</a>
<a name="ln686">	TAGID_PARTITION_INTEGRITY_ENTRY,</a>
<a name="ln687">	TAGID_EXTENDED_FILE_ENTRY,</a>
<a name="ln688">};</a>
<a name="ln689"> </a>
<a name="ln690">const char *tag_id_to_string(tag_id id);</a>
<a name="ln691"> </a>
<a name="ln692">extern const uint16 kCrcTable[256];</a>
<a name="ln693"> </a>
<a name="ln694">/*! \brief Primary volume descriptor</a>
<a name="ln695">*/</a>
<a name="ln696">struct primary_volume_descriptor {</a>
<a name="ln697">public:</a>
<a name="ln698">	void dump() const;	</a>
<a name="ln699"> </a>
<a name="ln700">	// Get functions</a>
<a name="ln701">	const descriptor_tag &amp; tag() const { return _tag; }</a>
<a name="ln702">	descriptor_tag &amp; tag() { return _tag; }</a>
<a name="ln703"> </a>
<a name="ln704">	uint32 vds_number() const { return B_LENDIAN_TO_HOST_INT32(_vds_number); }</a>
<a name="ln705">	uint32 primary_volume_descriptor_number() const { return B_LENDIAN_TO_HOST_INT32(_primary_volume_descriptor_number); }</a>
<a name="ln706"> </a>
<a name="ln707">	const array&lt;char, 32&gt;&amp; volume_identifier() const { return _volume_identifier; }</a>
<a name="ln708">	array&lt;char, 32&gt;&amp; volume_identifier() { return _volume_identifier; }</a>
<a name="ln709">	</a>
<a name="ln710">	uint16 volume_sequence_number() const { return B_LENDIAN_TO_HOST_INT16(_volume_sequence_number); }</a>
<a name="ln711">	uint16 max_volume_sequence_number() const { return B_LENDIAN_TO_HOST_INT16(_max_volume_sequence_number); }</a>
<a name="ln712">	uint16 interchange_level() const { return B_LENDIAN_TO_HOST_INT16(_interchange_level); }</a>
<a name="ln713">	uint16 max_interchange_level() const { return B_LENDIAN_TO_HOST_INT16(_max_interchange_level); }</a>
<a name="ln714">	uint32 character_set_list() const { return B_LENDIAN_TO_HOST_INT32(_character_set_list); }</a>
<a name="ln715">	uint32 max_character_set_list() const { return B_LENDIAN_TO_HOST_INT32(_max_character_set_list); }</a>
<a name="ln716"> </a>
<a name="ln717">	const array&lt;char, 128&gt;&amp; volume_set_identifier() const { return _volume_set_identifier; }</a>
<a name="ln718">	array&lt;char, 128&gt;&amp; volume_set_identifier() { return _volume_set_identifier; }</a>
<a name="ln719">	</a>
<a name="ln720">	const charspec&amp; descriptor_character_set() const { return _descriptor_character_set; }</a>
<a name="ln721">	charspec&amp; descriptor_character_set() { return _descriptor_character_set; }</a>
<a name="ln722"> </a>
<a name="ln723">	const charspec&amp; explanatory_character_set() const { return _explanatory_character_set; }</a>
<a name="ln724">	charspec&amp; explanatory_character_set() { return _explanatory_character_set; }</a>
<a name="ln725"> </a>
<a name="ln726">	const extent_address&amp; volume_abstract() const { return _volume_abstract; }</a>
<a name="ln727">	extent_address&amp; volume_abstract() { return _volume_abstract; }</a>
<a name="ln728">	const extent_address&amp; volume_copyright_notice() const { return _volume_copyright_notice; }</a>
<a name="ln729">	extent_address&amp; volume_copyright_notice() { return _volume_copyright_notice; }</a>
<a name="ln730"> </a>
<a name="ln731">	const entity_id&amp; application_id() const { return _application_id; }</a>
<a name="ln732">	entity_id&amp; application_id() { return _application_id; }</a>
<a name="ln733">	</a>
<a name="ln734">	const timestamp&amp; recording_date_and_time() const { return _recording_date_and_time; }</a>
<a name="ln735">	timestamp&amp; recording_date_and_time() { return _recording_date_and_time; }</a>
<a name="ln736"> </a>
<a name="ln737">	const entity_id&amp; implementation_id() const { return _implementation_id; }</a>
<a name="ln738">	entity_id&amp; implementation_id() { return _implementation_id; }</a>
<a name="ln739"> </a>
<a name="ln740">	const array&lt;uint8, 64&gt;&amp; implementation_use() const { return _implementation_use; }</a>
<a name="ln741">	array&lt;uint8, 64&gt;&amp; implementation_use() { return _implementation_use; }</a>
<a name="ln742"> </a>
<a name="ln743">	uint32 predecessor_volume_descriptor_sequence_location() const</a>
<a name="ln744">	  { return B_LENDIAN_TO_HOST_INT32(_predecessor_volume_descriptor_sequence_location); }</a>
<a name="ln745">	uint16 flags() const { return B_LENDIAN_TO_HOST_INT16(_flags); }</a>
<a name="ln746">	</a>
<a name="ln747">	const array&lt;uint8, 22&gt;&amp; reserved() const { return _reserved; }</a>
<a name="ln748">	array&lt;uint8, 22&gt;&amp; reserved() { return _reserved; }</a>
<a name="ln749"> </a>
<a name="ln750">	// Set functions</a>
<a name="ln751">	void set_vds_number(uint32 number)</a>
<a name="ln752">	  { _vds_number = B_HOST_TO_LENDIAN_INT32(number); }</a>
<a name="ln753">	void set_primary_volume_descriptor_number(uint32 number)</a>
<a name="ln754">	  { _primary_volume_descriptor_number = B_HOST_TO_LENDIAN_INT32(number); }</a>
<a name="ln755">	void set_volume_sequence_number(uint16 number)</a>
<a name="ln756">	  { _volume_sequence_number = B_HOST_TO_LENDIAN_INT16(number); }</a>
<a name="ln757">	void set_max_volume_sequence_number(uint16 number)</a>
<a name="ln758">	  { _max_volume_sequence_number = B_HOST_TO_LENDIAN_INT16(number); }</a>
<a name="ln759">	void set_interchange_level(uint16 level)</a>
<a name="ln760">	  { _interchange_level = B_HOST_TO_LENDIAN_INT16(level); }</a>
<a name="ln761">	void set_max_interchange_level(uint16 level)</a>
<a name="ln762">	  { _max_interchange_level = B_HOST_TO_LENDIAN_INT16(level); }</a>
<a name="ln763">	void set_character_set_list(uint32 list)</a>
<a name="ln764">	  { _character_set_list = B_HOST_TO_LENDIAN_INT32(list); }</a>
<a name="ln765">	void set_max_character_set_list(uint32 list)</a>
<a name="ln766">	  { _max_character_set_list = B_HOST_TO_LENDIAN_INT32(list); }</a>
<a name="ln767">	void set_predecessor_volume_descriptor_sequence_location(uint32 location)</a>
<a name="ln768">	  { _predecessor_volume_descriptor_sequence_location = B_HOST_TO_LENDIAN_INT32(location); }</a>
<a name="ln769">	void set_flags(uint16 flags)</a>
<a name="ln770">	  { _flags = B_HOST_TO_LENDIAN_INT16(flags); }</a>
<a name="ln771"> </a>
<a name="ln772">private:</a>
<a name="ln773">	descriptor_tag  _tag;</a>
<a name="ln774">	uint32 _vds_number;</a>
<a name="ln775">	uint32 _primary_volume_descriptor_number;</a>
<a name="ln776">	array&lt;char, 32&gt; _volume_identifier;</a>
<a name="ln777">	uint16 _volume_sequence_number;</a>
<a name="ln778">	uint16 _max_volume_sequence_number;</a>
<a name="ln779">	uint16 _interchange_level; //!&lt; to be set to 3 if part of multivolume set, 2 otherwise</a>
<a name="ln780">	uint16 _max_interchange_level; //!&lt; to be set to 3 unless otherwise directed by user</a>
<a name="ln781">	uint32 _character_set_list;</a>
<a name="ln782">	uint32 _max_character_set_list;</a>
<a name="ln783">	array&lt;char, 128&gt; _volume_set_identifier;</a>
<a name="ln784"> </a>
<a name="ln785">	/*! \brief Identifies the character set for the \c volume_identifier</a>
<a name="ln786">		and \c volume_set_identifier fields.</a>
<a name="ln787">		</a>
<a name="ln788">		To be set to CS0.</a>
<a name="ln789">	*/</a>
<a name="ln790">	charspec _descriptor_character_set;	</a>
<a name="ln791"> </a>
<a name="ln792">	/*! \brief Identifies the character set used in the \c volume_abstract</a>
<a name="ln793">		and \c volume_copyright_notice extents.</a>
<a name="ln794">		</a>
<a name="ln795">		To be set to CS0.</a>
<a name="ln796">	*/</a>
<a name="ln797">	charspec _explanatory_character_set;</a>
<a name="ln798">	</a>
<a name="ln799">	extent_address _volume_abstract;</a>
<a name="ln800">	extent_address _volume_copyright_notice;</a>
<a name="ln801">	</a>
<a name="ln802">	entity_id _application_id;</a>
<a name="ln803">	timestamp _recording_date_and_time;</a>
<a name="ln804">	entity_id _implementation_id;</a>
<a name="ln805">	array&lt;uint8, 64&gt; _implementation_use;</a>
<a name="ln806">	uint32 _predecessor_volume_descriptor_sequence_location;</a>
<a name="ln807">	uint16 _flags;</a>
<a name="ln808">	array&lt;uint8, 22&gt; _reserved;</a>
<a name="ln809"> </a>
<a name="ln810">} __attribute__((packed));</a>
<a name="ln811"> </a>
<a name="ln812"> </a>
<a name="ln813">/*! \brief Anchor Volume Descriptor Pointer</a>
<a name="ln814"> </a>
<a name="ln815">	vd recorded at preset locations in the partition, used as a reference</a>
<a name="ln816">	point to the main vd sequences</a>
<a name="ln817">	</a>
<a name="ln818">	According to UDF 2.01, an avdp shall be recorded in at least 2 of</a>
<a name="ln819">	the 3 following locations, where N is the last recordable sector</a>
<a name="ln820">	of the partition:</a>
<a name="ln821">	- 256</a>
<a name="ln822">	- (N - 256)</a>
<a name="ln823">	- N	</a>
<a name="ln824">	</a>
<a name="ln825">	See also: ECMA 167 3/10.2, UDF-2.01 2.2.3</a>
<a name="ln826">*/</a>
<a name="ln827">struct anchor_volume_descriptor {</a>
<a name="ln828">public:</a>
<a name="ln829">	anchor_volume_descriptor() { memset(_reserved.data, 0, _reserved.size()); }</a>
<a name="ln830">	void dump() const;</a>
<a name="ln831">	</a>
<a name="ln832">	descriptor_tag &amp; tag() { return _tag; }</a>
<a name="ln833">	const descriptor_tag &amp; tag() const { return _tag; }</a>
<a name="ln834"> </a>
<a name="ln835">	extent_address&amp; main_vds() { return _main_vds; }</a>
<a name="ln836">	const extent_address&amp; main_vds() const { return _main_vds; }</a>
<a name="ln837"> </a>
<a name="ln838">	extent_address&amp; reserve_vds() { return _reserve_vds; }</a>
<a name="ln839">	const extent_address&amp; reserve_vds() const { return _reserve_vds; }</a>
<a name="ln840">private:</a>
<a name="ln841">	descriptor_tag  _tag;</a>
<a name="ln842">	extent_address _main_vds;	//!&lt; min length of 16 sectors</a>
<a name="ln843">	extent_address _reserve_vds;	//!&lt; min length of 16 sectors</a>
<a name="ln844">	array&lt;uint8, 480&gt; _reserved;	</a>
<a name="ln845">} __attribute__((packed));</a>
<a name="ln846"> </a>
<a name="ln847"> </a>
<a name="ln848">/*! \brief Volume Descriptor Pointer</a>
<a name="ln849"> </a>
<a name="ln850">	Used to chain extents of volume descriptor sequences together.</a>
<a name="ln851">	</a>
<a name="ln852">	See also: ECMA 167 3/10.3</a>
<a name="ln853">*/</a>
<a name="ln854">struct descriptor_pointer {</a>
<a name="ln855">	descriptor_tag  tag;</a>
<a name="ln856">	uint32 vds_number;</a>
<a name="ln857">	extent_address next;</a>
<a name="ln858">} __attribute__((packed));</a>
<a name="ln859"> </a>
<a name="ln860"> </a>
<a name="ln861">/*! \brief UDF Implementation Use Volume Descriptor struct found in</a>
<a name="ln862">	implementation_use() field of implementation_use_descriptor when</a>
<a name="ln863">	said descriptor's implementation_id() field specifies &quot;*UDF LV Info&quot;</a>
<a name="ln864">	</a>
<a name="ln865">	See also: UDF 2.50 2.2.7</a>
<a name="ln866">*/</a>
<a name="ln867">struct logical_volume_info {</a>
<a name="ln868">public:</a>
<a name="ln869">	void dump() const;</a>
<a name="ln870"> </a>
<a name="ln871">	charspec&amp; character_set() { return _character_set; }</a>
<a name="ln872">	const charspec&amp; character_set() const { return _character_set; }</a>
<a name="ln873"> </a>
<a name="ln874">	array&lt;char, 128&gt;&amp; logical_volume_id() { return _logical_volume_id; }</a>
<a name="ln875">	const array&lt;char, 128&gt;&amp; logical_volume_id() const { return _logical_volume_id; }</a>
<a name="ln876"> </a>
<a name="ln877">	array&lt;char, 36&gt;&amp; logical_volume_info_1() { return _logical_volume_info.data[0]; }</a>
<a name="ln878">	const array&lt;char, 36&gt;&amp; logical_volume_info_1() const { return _logical_volume_info.data[0]; }</a>
<a name="ln879"> </a>
<a name="ln880">	array&lt;char, 36&gt;&amp; logical_volume_info_2() { return _logical_volume_info.data[1]; }</a>
<a name="ln881">	const array&lt;char, 36&gt;&amp; logical_volume_info_2() const { return _logical_volume_info.data[1]; }</a>
<a name="ln882"> </a>
<a name="ln883">	array&lt;char, 36&gt;&amp; logical_volume_info_3() { return _logical_volume_info.data[2]; }</a>
<a name="ln884">	const array&lt;char, 36&gt;&amp; logical_volume_info_3() const { return _logical_volume_info.data[2]; }</a>
<a name="ln885"> </a>
<a name="ln886">	entity_id&amp; implementation_id() { return _implementation_id; }</a>
<a name="ln887">	const entity_id&amp; implementation_id() const { return _implementation_id; }</a>
<a name="ln888"> </a>
<a name="ln889">	array&lt;uint8, 128&gt;&amp; implementation_use() { return _implementation_use; }</a>
<a name="ln890">	const array&lt;uint8, 128&gt;&amp; implementation_use() const { return _implementation_use; }</a>
<a name="ln891">private:</a>
<a name="ln892">	charspec _character_set;</a>
<a name="ln893">	array&lt;char, 128&gt; _logical_volume_id;				// d-string</a>
<a name="ln894">	array&lt;array&lt;char, 36&gt;, 3&gt; _logical_volume_info;	// d-strings</a>
<a name="ln895">	entity_id _implementation_id;</a>
<a name="ln896">	array&lt;uint8, 128&gt; _implementation_use;	</a>
<a name="ln897">} __attribute__((packed));</a>
<a name="ln898"> </a>
<a name="ln899">/*! \brief Implementation Use Volume Descriptor</a>
<a name="ln900"> </a>
<a name="ln901">	See also: ECMA 167 3/10.4</a>
<a name="ln902">*/</a>
<a name="ln903">struct implementation_use_descriptor {</a>
<a name="ln904">public:</a>
<a name="ln905">	void dump() const;</a>
<a name="ln906"> </a>
<a name="ln907">	// Get functions</a>
<a name="ln908">	const descriptor_tag &amp; tag() const { return _tag; }</a>
<a name="ln909">	descriptor_tag &amp; tag() { return _tag; }</a>
<a name="ln910">	</a>
<a name="ln911">	uint32 vds_number() const { return B_LENDIAN_TO_HOST_INT32(_vds_number); }</a>
<a name="ln912"> </a>
<a name="ln913">	const entity_id&amp; implementation_id() const { return _implementation_id; }</a>
<a name="ln914">	entity_id&amp; implementation_id() { return _implementation_id; }</a>
<a name="ln915"> </a>
<a name="ln916">	const array&lt;uint8, 460&gt;&amp; implementation_use() const { return _implementation_use; }</a>
<a name="ln917">	array&lt;uint8, 460&gt;&amp; implementation_use() { return _implementation_use; }</a>
<a name="ln918">	</a>
<a name="ln919">	// Only valid if implementation_id() returns Udf::kLogicalVolumeInfoId.</a>
<a name="ln920">	logical_volume_info&amp; info() { return *reinterpret_cast&lt;logical_volume_info*&gt;(_implementation_use.data); }</a>
<a name="ln921">	const logical_volume_info&amp; info() const { return *reinterpret_cast&lt;const logical_volume_info*&gt;(_implementation_use.data); }</a>
<a name="ln922">	</a>
<a name="ln923">	// Set functions</a>
<a name="ln924">	void set_vds_number(uint32 number) { _vds_number = B_HOST_TO_LENDIAN_INT32(number); }</a>
<a name="ln925">private:</a>
<a name="ln926">	descriptor_tag  _tag;</a>
<a name="ln927">	uint32 _vds_number;</a>
<a name="ln928">	entity_id _implementation_id;</a>
<a name="ln929">	array&lt;uint8, 460&gt; _implementation_use;</a>
<a name="ln930">} __attribute__((packed));</a>
<a name="ln931"> </a>
<a name="ln932"> </a>
<a name="ln933">/*! \brief Maximum number of partition descriptors to be found in volume</a>
<a name="ln934">	descriptor sequence, per UDF-2.50</a>
<a name="ln935">*/</a>
<a name="ln936">const uint8 kMaxPartitionDescriptors = 2;</a>
<a name="ln937">#define UDF_MAX_PARTITION_MAPS 2</a>
<a name="ln938">#define UDF_MAX_PARTITION_MAP_SIZE 64</a>
<a name="ln939"> </a>
<a name="ln940">/*! \brief Partition Descriptor</a>
<a name="ln941"> </a>
<a name="ln942">	See also: ECMA 167 3/10.5</a>
<a name="ln943">*/</a>
<a name="ln944">struct partition_descriptor {</a>
<a name="ln945">private:</a>
<a name="ln946">	union partition_flags_accessor {</a>
<a name="ln947">		uint16 partition_flags;</a>
<a name="ln948">		struct {</a>
<a name="ln949">			uint16 allocated:1,</a>
<a name="ln950">			       reserved:15;</a>
<a name="ln951">		} bits;</a>
<a name="ln952">	};</a>
<a name="ln953"> </a>
<a name="ln954">public:</a>
<a name="ln955">	void dump() const;</a>
<a name="ln956">	</a>
<a name="ln957">	// Get functions</a>
<a name="ln958">	const descriptor_tag &amp; tag() const { return _tag; }</a>
<a name="ln959">	descriptor_tag &amp; tag() { return _tag; }</a>
<a name="ln960">	</a>
<a name="ln961">	uint32 vds_number() const { return B_LENDIAN_TO_HOST_INT32(_vds_number); }</a>
<a name="ln962">	uint16 partition_flags() const { return B_LENDIAN_TO_HOST_INT16(_partition_flags); }</a>
<a name="ln963">	bool allocated() const {</a>
<a name="ln964">		partition_flags_accessor f;</a>
<a name="ln965">		f.partition_flags = partition_flags();</a>
<a name="ln966">		return f.bits.allocated;</a>
<a name="ln967">	}</a>
<a name="ln968">	uint16 partition_number() const { return B_LENDIAN_TO_HOST_INT16(_partition_number); }</a>
<a name="ln969">		</a>
<a name="ln970">	const entity_id&amp; partition_contents() const { return _partition_contents; }</a>
<a name="ln971">	entity_id&amp; partition_contents() { return _partition_contents; }</a>
<a name="ln972">	</a>
<a name="ln973">	const array&lt;uint8, 128&gt;&amp; partition_contents_use() const { return _partition_contents_use; }</a>
<a name="ln974">	array&lt;uint8, 128&gt;&amp; partition_contents_use() { return _partition_contents_use; }</a>
<a name="ln975">	</a>
<a name="ln976">	uint32 access_type() const { return B_LENDIAN_TO_HOST_INT32(_access_type); }</a>
<a name="ln977">	uint32 start() const { return B_LENDIAN_TO_HOST_INT32(_start); }</a>
<a name="ln978">	uint32 length() const { return B_LENDIAN_TO_HOST_INT32(_length); }</a>
<a name="ln979"> </a>
<a name="ln980">	const entity_id&amp; implementation_id() const { return _implementation_id; }</a>
<a name="ln981">	entity_id&amp; implementation_id() { return _implementation_id; }</a>
<a name="ln982"> </a>
<a name="ln983">	const array&lt;uint8, 128&gt;&amp; implementation_use() const { return _implementation_use; }</a>
<a name="ln984">	array&lt;uint8, 128&gt;&amp; implementation_use() { return _implementation_use; }</a>
<a name="ln985">	</a>
<a name="ln986">	const array&lt;uint8, 156&gt;&amp; reserved() const { return _reserved; }</a>
<a name="ln987">	array&lt;uint8, 156&gt;&amp; reserved() { return _reserved; }</a>
<a name="ln988">	</a>
<a name="ln989">	// Set functions</a>
<a name="ln990">	void set_vds_number(uint32 number) { _vds_number = B_HOST_TO_LENDIAN_INT32(number); }</a>
<a name="ln991">	void set_partition_flags(uint16 flags) { _partition_flags = B_HOST_TO_LENDIAN_INT16(flags); }</a>
<a name="ln992">	void set_allocated(bool allocated) {</a>
<a name="ln993">		partition_flags_accessor f;</a>
<a name="ln994">		f.partition_flags = partition_flags();</a>
<a name="ln995">		f.bits.allocated = allocated;</a>
<a name="ln996">		set_partition_flags(f.partition_flags);</a>
<a name="ln997">	}</a>
<a name="ln998">	void set_partition_number(uint16 number) { _partition_number = B_HOST_TO_LENDIAN_INT16(number); }</a>
<a name="ln999">	void set_access_type(uint32 type) { _access_type = B_HOST_TO_LENDIAN_INT32(type); }</a>
<a name="ln1000">	void set_start(uint32 start) { _start = B_HOST_TO_LENDIAN_INT32(start); }</a>
<a name="ln1001">	void set_length(uint32 length) { _length = B_HOST_TO_LENDIAN_INT32(length); }</a>
<a name="ln1002"> </a>
<a name="ln1003">private:</a>
<a name="ln1004">	descriptor_tag  _tag;</a>
<a name="ln1005">	uint32 _vds_number;</a>
<a name="ln1006">	/*! Bit 0: If 0, shall mean volume space has not been allocated. If 1,</a>
<a name="ln1007">	    shall mean volume space has been allocated.</a>
<a name="ln1008">	*/</a>
<a name="ln1009">	uint16 _partition_flags;</a>
<a name="ln1010">	uint16 _partition_number;</a>
<a name="ln1011">	</a>
<a name="ln1012">	/*! - &quot;+NSR03&quot; Volume recorded according to ECMA-167, i.e. UDF</a>
<a name="ln1013">		- &quot;+CD001&quot; Volume recorded according to ECMA-119, i.e. iso9660</a>
<a name="ln1014">		- &quot;+FDC01&quot; Volume recorded according to ECMA-107</a>
<a name="ln1015">		- &quot;+CDW02&quot; Volume recorded according to ECMA-168</a>
<a name="ln1016">	*/		</a>
<a name="ln1017">	entity_id _partition_contents;</a>
<a name="ln1018">	array&lt;uint8, 128&gt; _partition_contents_use;</a>
<a name="ln1019"> </a>
<a name="ln1020">	/*! See \c partition_access_type enum</a>
<a name="ln1021">	*/</a>
<a name="ln1022">	uint32 _access_type;</a>
<a name="ln1023">	uint32 _start;</a>
<a name="ln1024">	uint32 _length;</a>
<a name="ln1025">	entity_id _implementation_id;</a>
<a name="ln1026">	array&lt;uint8, 128&gt; _implementation_use;</a>
<a name="ln1027">	array&lt;uint8, 156&gt; _reserved;</a>
<a name="ln1028">} __attribute__((packed));</a>
<a name="ln1029"> </a>
<a name="ln1030"> </a>
<a name="ln1031">enum partition_access_type {</a>
<a name="ln1032">	ACCESS_UNSPECIFIED,</a>
<a name="ln1033">	ACCESS_READ_ONLY,</a>
<a name="ln1034">	ACCESS_WRITE_ONCE,</a>
<a name="ln1035">	ACCESS_REWRITABLE,</a>
<a name="ln1036">	ACCESS_OVERWRITABLE,</a>
<a name="ln1037">};</a>
<a name="ln1038"> </a>
<a name="ln1039"> </a>
<a name="ln1040">/*! \brief Logical volume descriptor</a>
<a name="ln1041"> </a>
<a name="ln1042">	See also: ECMA 167 3/10.6, UDF-2.01 2.2.4</a>
<a name="ln1043">*/</a>
<a name="ln1044">struct logical_volume_descriptor {</a>
<a name="ln1045">	void dump() const;</a>
<a name="ln1046">	</a>
<a name="ln1047">	// Get functions</a>
<a name="ln1048">	const descriptor_tag &amp; tag() const { return _tag; }</a>
<a name="ln1049">	descriptor_tag &amp; tag() { return _tag; }</a>
<a name="ln1050"> </a>
<a name="ln1051">	uint32 vds_number() const { return B_LENDIAN_TO_HOST_INT32(_vds_number); }</a>
<a name="ln1052"> </a>
<a name="ln1053">	const charspec&amp; character_set() const { return _character_set; }</a>
<a name="ln1054">	charspec&amp; character_set() { return _character_set; }</a>
<a name="ln1055">	</a>
<a name="ln1056">	const array&lt;char, 128&gt;&amp; logical_volume_identifier() const { return _logical_volume_identifier; }</a>
<a name="ln1057">	array&lt;char, 128&gt;&amp; logical_volume_identifier() { return _logical_volume_identifier; }</a>
<a name="ln1058">	</a>
<a name="ln1059">	uint32 logical_block_size() const { return B_LENDIAN_TO_HOST_INT32(_logical_block_size); }</a>
<a name="ln1060"> </a>
<a name="ln1061">	const entity_id&amp; domain_id() const { return _domain_id; }</a>
<a name="ln1062">	entity_id&amp; domain_id() { return _domain_id; }</a>
<a name="ln1063"> </a>
<a name="ln1064">	const array&lt;uint8, 16&gt;&amp; logical_volume_contents_use() const { return _logical_volume_contents_use; }</a>
<a name="ln1065">	array&lt;uint8, 16&gt;&amp; logical_volume_contents_use() { return _logical_volume_contents_use; }</a>
<a name="ln1066"> </a>
<a name="ln1067">	const long_address&amp; file_set_address() const { return *reinterpret_cast&lt;const long_address*&gt;(&amp;_logical_volume_contents_use); }</a>
<a name="ln1068">	long_address&amp; file_set_address() { return *reinterpret_cast&lt;long_address*&gt;(&amp;_logical_volume_contents_use); }</a>
<a name="ln1069"> </a>
<a name="ln1070">	uint32 map_table_length() const { return B_LENDIAN_TO_HOST_INT32(_map_table_length); }</a>
<a name="ln1071">	uint32 partition_map_count() const { return B_LENDIAN_TO_HOST_INT32(_partition_map_count); }</a>
<a name="ln1072"> </a>
<a name="ln1073">	const entity_id&amp; implementation_id() const { return _implementation_id; }</a>
<a name="ln1074">	entity_id&amp; implementation_id() { return _implementation_id; }</a>
<a name="ln1075"> </a>
<a name="ln1076">	const array&lt;uint8, 128&gt;&amp; implementation_use() const { return _implementation_use; }</a>
<a name="ln1077">	array&lt;uint8, 128&gt;&amp; implementation_use() { return _implementation_use; }</a>
<a name="ln1078"> </a>
<a name="ln1079">	const extent_address&amp; integrity_sequence_extent() const { return _integrity_sequence_extent; }</a>
<a name="ln1080">	extent_address&amp; integrity_sequence_extent() { return _integrity_sequence_extent; }</a>
<a name="ln1081"> </a>
<a name="ln1082">	const uint8* partition_maps() const { return _partition_maps; }</a>
<a name="ln1083">	uint8* partition_maps() { return _partition_maps; }</a>
<a name="ln1084"> </a>
<a name="ln1085">	// Set functions</a>
<a name="ln1086">	void set_vds_number(uint32 number) { _vds_number = B_HOST_TO_LENDIAN_INT32(number); }</a>
<a name="ln1087">	void set_logical_block_size(uint32 size) { _logical_block_size = B_HOST_TO_LENDIAN_INT32(size); }</a>
<a name="ln1088">		</a>
<a name="ln1089">	void set_map_table_length(uint32 length) { _map_table_length = B_HOST_TO_LENDIAN_INT32(length); }</a>
<a name="ln1090">	void set_partition_map_count(uint32 count) { _partition_map_count = B_HOST_TO_LENDIAN_INT32(count); }</a>
<a name="ln1091"> </a>
<a name="ln1092">	// Other functions</a>
<a name="ln1093">	logical_volume_descriptor&amp; operator=(const logical_volume_descriptor &amp;rhs);</a>
<a name="ln1094">	</a>
<a name="ln1095">private:</a>
<a name="ln1096">	descriptor_tag  _tag;</a>
<a name="ln1097">	uint32 _vds_number;</a>
<a name="ln1098">	</a>
<a name="ln1099">	/*! \brief Identifies the character set for the</a>
<a name="ln1100">		\c logical_volume_identifier field.</a>
<a name="ln1101">		</a>
<a name="ln1102">		To be set to CS0.</a>
<a name="ln1103">	*/</a>
<a name="ln1104">	charspec _character_set;</a>
<a name="ln1105">	array&lt;char, 128&gt; _logical_volume_identifier;</a>
<a name="ln1106">	uint32 _logical_block_size;</a>
<a name="ln1107">	</a>
<a name="ln1108">	/*! \brief To be set to 0 or &quot;*OSTA UDF Compliant&quot;. See UDF specs.</a>
<a name="ln1109">	*/</a>
<a name="ln1110">	entity_id _domain_id;</a>
<a name="ln1111">	</a>
<a name="ln1112">	/*! \brief For UDF, shall contain a \c long_address which identifies</a>
<a name="ln1113">		the location of the logical volume's first file set.</a>
<a name="ln1114">	*/</a>
<a name="ln1115">	array&lt;uint8, 16&gt; _logical_volume_contents_use;</a>
<a name="ln1116"> </a>
<a name="ln1117">	uint32 _map_table_length;</a>
<a name="ln1118">	uint32 _partition_map_count;</a>
<a name="ln1119">	entity_id _implementation_id;</a>
<a name="ln1120">	array&lt;uint8, 128&gt; _implementation_use;</a>
<a name="ln1121">	</a>
<a name="ln1122">	/*! \brief Logical volume integrity sequence location.</a>
<a name="ln1123">	</a>
<a name="ln1124">		For re/overwritable media, shall be a min of 8KB in length.</a>
<a name="ln1125">		For WORM media, shall be quite frickin large, as a new volume</a>
<a name="ln1126">		must be added to the set if the extent fills up (since you</a>
<a name="ln1127">		can't chain lvis's I guess).</a>
<a name="ln1128">	*/</a>
<a name="ln1129">	extent_address _integrity_sequence_extent;</a>
<a name="ln1130">	</a>
<a name="ln1131">	/*! \brief Restricted to maps of type 1 for normal maps and</a>
<a name="ln1132">		UDF type 2 for virtual maps or maps on systems not supporting</a>
<a name="ln1133">		defect management.</a>
<a name="ln1134">		</a>
<a name="ln1135">		Note that we actually allocate memory for the partition maps</a>
<a name="ln1136">		here due to the fact that we allocate logical_volume_descriptor</a>
<a name="ln1137">		objects on the stack sometimes.</a>
<a name="ln1138">		</a>
<a name="ln1139">		See UDF-2.01 2.2.8, 2.2.9</a>
<a name="ln1140">	*/</a>
<a name="ln1141">	uint8 _partition_maps[UDF_MAX_PARTITION_MAPS * UDF_MAX_PARTITION_MAP_SIZE];</a>
<a name="ln1142">} __attribute__((packed));</a>
<a name="ln1143"> </a>
<a name="ln1144">//! Base size (excluding partition maps) of lvd</a>
<a name="ln1145">extern const uint32 kLogicalVolumeDescriptorBaseSize;</a>
<a name="ln1146"> </a>
<a name="ln1147">/*! \brief (Mostly) common portion of various partition maps</a>
<a name="ln1148"> </a>
<a name="ln1149">	See also: ECMA-167 3/10.7.1</a>
<a name="ln1150">*/</a>
<a name="ln1151">struct partition_map_header {</a>
<a name="ln1152">public:</a>
<a name="ln1153">	uint8 type() const { return _type; }</a>
<a name="ln1154">	uint8 length() const { return _length; }</a>
<a name="ln1155">	uint8 *map_data() { return _map_data; }</a>
<a name="ln1156">	const uint8 *map_data() const { return _map_data; }</a>
<a name="ln1157">	</a>
<a name="ln1158">	entity_id&amp; partition_type_id()</a>
<a name="ln1159">		{ return *reinterpret_cast&lt;entity_id*&gt;(&amp;_map_data[2]); }</a>
<a name="ln1160">	const entity_id&amp; partition_type_id() const</a>
<a name="ln1161">		{ return *reinterpret_cast&lt;const entity_id*&gt;(&amp;_map_data[2]); }</a>
<a name="ln1162"> </a>
<a name="ln1163">	void set_type(uint8 type) { _type = type; }</a>
<a name="ln1164">	void set_length(uint8 length) { _length = length; }</a>
<a name="ln1165">private:</a>
<a name="ln1166">	uint8 _type;</a>
<a name="ln1167">	uint8 _length;</a>
<a name="ln1168">	uint8 _map_data[0];</a>
<a name="ln1169">};// __attribute__((packed));</a>
<a name="ln1170"> </a>
<a name="ln1171"> </a>
<a name="ln1172">/*! \brief Physical partition map (i.e. ECMA-167 Type 1 partition map)</a>
<a name="ln1173"> </a>
<a name="ln1174">	See also: ECMA-167 3/10.7.2</a>
<a name="ln1175">*/</a>
<a name="ln1176">struct physical_partition_map {</a>
<a name="ln1177">public:</a>
<a name="ln1178">	void dump();</a>
<a name="ln1179"> </a>
<a name="ln1180">	uint8 type() const { return _type; }</a>
<a name="ln1181">	uint8 length() const { return _length; }</a>
<a name="ln1182"> </a>
<a name="ln1183">	uint16 volume_sequence_number() const {</a>
<a name="ln1184">		return B_LENDIAN_TO_HOST_INT16(_volume_sequence_number); }</a>
<a name="ln1185">	uint16 partition_number() const {</a>
<a name="ln1186">		return B_LENDIAN_TO_HOST_INT16(_partition_number); }</a>
<a name="ln1187"> </a>
<a name="ln1188">	void set_type(uint8 type) { _type = type; }</a>
<a name="ln1189">	void set_length(uint8 length) { _length = length; }</a>
<a name="ln1190">	void set_volume_sequence_number(uint16 number) {</a>
<a name="ln1191">		_volume_sequence_number = B_HOST_TO_LENDIAN_INT16(number); }</a>
<a name="ln1192">	void set_partition_number(uint16 number) {</a>
<a name="ln1193">		_partition_number = B_HOST_TO_LENDIAN_INT16(number); }</a>
<a name="ln1194">private:</a>
<a name="ln1195">	uint8 _type;</a>
<a name="ln1196">	uint8 _length;</a>
<a name="ln1197">	uint16 _volume_sequence_number;</a>
<a name="ln1198">	uint16 _partition_number;	</a>
<a name="ln1199">} __attribute__((packed));</a>
<a name="ln1200"> </a>
<a name="ln1201"> </a>
<a name="ln1202">/* ----UDF Specific---- */</a>
<a name="ln1203">/*! \brief Virtual partition map </a>
<a name="ln1204"> </a>
<a name="ln1205">	Note that this map is a customization of the ECMA-167</a>
<a name="ln1206">	type 2 partition map.</a>
<a name="ln1207">	</a>
<a name="ln1208">	See also: UDF-2.01 2.2.8</a>
<a name="ln1209">*/</a>
<a name="ln1210">struct virtual_partition_map {</a>
<a name="ln1211">	uint8 type;</a>
<a name="ln1212">	uint8 length;</a>
<a name="ln1213">	uint8 reserved1[2];</a>
<a name="ln1214">	</a>
<a name="ln1215">	/*! - flags: 0</a>
<a name="ln1216">	    - identifier: &quot;*UDF Virtual Partition&quot;</a>
<a name="ln1217">	    - identifier_suffix: per UDF-2.01 2.1.5.3</a>
<a name="ln1218">	*/</a>
<a name="ln1219">	entity_id partition_type_id;</a>
<a name="ln1220">	uint16 volume_sequence_number;</a>
<a name="ln1221">	</a>
<a name="ln1222">	/*! corresponding type 1 partition map in same logical volume</a>
<a name="ln1223">	*/</a>
<a name="ln1224">	uint16 partition_number;	</a>
<a name="ln1225">	uint8 reserved2[24];</a>
<a name="ln1226">} __attribute__((packed));</a>
<a name="ln1227"> </a>
<a name="ln1228"> </a>
<a name="ln1229">/*! \brief Maximum number of redundant sparing tables found in</a>
<a name="ln1230">	sparable_partition_map structures.</a>
<a name="ln1231">*/</a>
<a name="ln1232">#define UDF_MAX_SPARING_TABLE_COUNT 4</a>
<a name="ln1233"> </a>
<a name="ln1234">/* ----UDF Specific---- */</a>
<a name="ln1235">/*! \brief Sparable partition map </a>
<a name="ln1236"> </a>
<a name="ln1237">	Note that this map is a customization of the ECMA-167</a>
<a name="ln1238">	type 2 partition map.</a>
<a name="ln1239">	</a>
<a name="ln1240">	See also: UDF-2.01 2.2.9</a>
<a name="ln1241">*/</a>
<a name="ln1242">struct sparable_partition_map {</a>
<a name="ln1243">public:</a>
<a name="ln1244">	void dump();</a>
<a name="ln1245"> </a>
<a name="ln1246">	uint8 type() const { return _type; }</a>
<a name="ln1247">	uint8 length() const { return _length; }</a>
<a name="ln1248"> </a>
<a name="ln1249">	entity_id&amp; partition_type_id() { return _partition_type_id; }</a>
<a name="ln1250">	const entity_id&amp; partition_type_id() const { return _partition_type_id; }</a>
<a name="ln1251"> </a>
<a name="ln1252">	uint16 volume_sequence_number() const {</a>
<a name="ln1253">		return B_LENDIAN_TO_HOST_INT16(_volume_sequence_number); }</a>
<a name="ln1254">	uint16 partition_number() const {</a>
<a name="ln1255">		return B_LENDIAN_TO_HOST_INT16(_partition_number); }</a>
<a name="ln1256">	uint16 packet_length() const {</a>
<a name="ln1257">		return B_LENDIAN_TO_HOST_INT16(_packet_length); }</a>
<a name="ln1258">	uint8 sparing_table_count() const { return _sparing_table_count; }</a>
<a name="ln1259">	uint32 sparing_table_size() const {</a>
<a name="ln1260">		return B_LENDIAN_TO_HOST_INT32(_sparing_table_size); }</a>
<a name="ln1261">	uint32 sparing_table_location(uint8 index) const {</a>
<a name="ln1262">		return B_LENDIAN_TO_HOST_INT32(_sparing_table_locations[index]); }</a>
<a name="ln1263">		</a>
<a name="ln1264"> </a>
<a name="ln1265">	void set_type(uint8 type) { _type = type; }</a>
<a name="ln1266">	void set_length(uint8 length) { _length = length; }</a>
<a name="ln1267">	void set_volume_sequence_number(uint16 number) {</a>
<a name="ln1268">		_volume_sequence_number = B_HOST_TO_LENDIAN_INT16(number); }</a>
<a name="ln1269">	void set_partition_number(uint16 number) {</a>
<a name="ln1270">		_partition_number = B_HOST_TO_LENDIAN_INT16(number); }</a>
<a name="ln1271">	void set_packet_length(uint16 length) {</a>
<a name="ln1272">		_packet_length = B_HOST_TO_LENDIAN_INT16(length); }</a>
<a name="ln1273">	void set_sparing_table_count(uint8 count) {</a>
<a name="ln1274">		_sparing_table_count = count; }</a>
<a name="ln1275">	void set_sparing_table_size(uint32 size) {</a>
<a name="ln1276">		_sparing_table_size = B_HOST_TO_LENDIAN_INT32(size); }</a>
<a name="ln1277">	void set_sparing_table_location(uint8 index, uint32 location) {</a>
<a name="ln1278">		_sparing_table_locations[index] = B_HOST_TO_LENDIAN_INT32(location); }</a>
<a name="ln1279">private:</a>
<a name="ln1280">	uint8 _type;</a>
<a name="ln1281">	uint8 _length;</a>
<a name="ln1282">	uint8 _reserved1[2];</a>
<a name="ln1283">	</a>
<a name="ln1284">	/*! - flags: 0</a>
<a name="ln1285">	    - identifier: &quot;*UDF Sparable Partition&quot;</a>
<a name="ln1286">	    - identifier_suffix: per UDF-2.01 2.1.5.3</a>
<a name="ln1287">	*/</a>
<a name="ln1288">	entity_id _partition_type_id;</a>
<a name="ln1289">	uint16 _volume_sequence_number;</a>
<a name="ln1290">	</a>
<a name="ln1291">	//! partition number of corresponding partition descriptor</a>
<a name="ln1292">	uint16 _partition_number;</a>
<a name="ln1293">	uint16 _packet_length;</a>
<a name="ln1294">	uint8 _sparing_table_count;</a>
<a name="ln1295">	uint8 _reserved2;</a>
<a name="ln1296">	uint32 _sparing_table_size;</a>
<a name="ln1297">	uint32 _sparing_table_locations[UDF_MAX_SPARING_TABLE_COUNT];</a>
<a name="ln1298">} __attribute__((packed));</a>
<a name="ln1299"> </a>
<a name="ln1300"> </a>
<a name="ln1301">/* ----UDF Specific---- */</a>
<a name="ln1302">/*! \brief Metadata partition map </a>
<a name="ln1303"> </a>
<a name="ln1304">	Note that this map is a customization of the ECMA-167</a>
<a name="ln1305">	type 2 partition map.</a>
<a name="ln1306">	</a>
<a name="ln1307">	See also: UDF-2.50 2.2.10</a>
<a name="ln1308">*/</a>
<a name="ln1309">struct metadata_partition_map {</a>
<a name="ln1310">public:</a>
<a name="ln1311">	entity_id&amp; partition_type_id() { return _partition_type_id; }</a>
<a name="ln1312">	const entity_id&amp; partition_type_id() const { return _partition_type_id; }</a>
<a name="ln1313"> </a>
<a name="ln1314">	uint16 volume_sequence_number() const {</a>
<a name="ln1315">		return B_LENDIAN_TO_HOST_INT16(_volume_sequence_number); }</a>
<a name="ln1316">	void set_volume_sequence_number(uint16 number) {</a>
<a name="ln1317">		_volume_sequence_number = B_HOST_TO_LENDIAN_INT16(number); }</a>
<a name="ln1318"> </a>
<a name="ln1319">	uint16 partition_number() const {</a>
<a name="ln1320">		return B_LENDIAN_TO_HOST_INT16(_partition_number); }</a>
<a name="ln1321">	void set_partition_number(uint16 number) {</a>
<a name="ln1322">		_partition_number = B_HOST_TO_LENDIAN_INT16(number); }</a>
<a name="ln1323"> </a>
<a name="ln1324">	uint32 metadata_file_location() const {</a>
<a name="ln1325">		return B_LENDIAN_TO_HOST_INT32(_metadata_file_location); }</a>
<a name="ln1326">	void set_metadata_file_location(uint32 location) {</a>
<a name="ln1327">		_metadata_file_location = B_HOST_TO_LENDIAN_INT32(location); }</a>
<a name="ln1328"> </a>
<a name="ln1329">	uint32 metadata_mirror_file_location() const {</a>
<a name="ln1330">		return B_LENDIAN_TO_HOST_INT32(_metadata_mirror_file_location); }</a>
<a name="ln1331">	void set_metadata_mirror_file_location(uint32 location) {</a>
<a name="ln1332">		_metadata_mirror_file_location = B_HOST_TO_LENDIAN_INT32(location); }</a>
<a name="ln1333"> </a>
<a name="ln1334">	uint32 metadata_bitmap_file_location() const {</a>
<a name="ln1335">		return B_LENDIAN_TO_HOST_INT32(_metadata_bitmap_file_location); }</a>
<a name="ln1336">	void set_metadata_bitmap_file_location(uint32 location) {</a>
<a name="ln1337">		_metadata_bitmap_file_location = B_HOST_TO_LENDIAN_INT32(location); }</a>
<a name="ln1338"> </a>
<a name="ln1339">	uint32 allocation_unit_size() const {</a>
<a name="ln1340">		return B_LENDIAN_TO_HOST_INT32(_allocation_unit_size); }</a>
<a name="ln1341">	void set_allocation_unit_size(uint32 size) {</a>
<a name="ln1342">		_allocation_unit_size = B_HOST_TO_LENDIAN_INT32(size); }</a>
<a name="ln1343"> </a>
<a name="ln1344">	uint32 alignment_unit_size() const {</a>
<a name="ln1345">		return B_LENDIAN_TO_HOST_INT32(_alignment_unit_size); }</a>
<a name="ln1346">	void set_alignment_unit_size(uint32 size) {</a>
<a name="ln1347">		_alignment_unit_size = B_HOST_TO_LENDIAN_INT32(size); }</a>
<a name="ln1348"> </a>
<a name="ln1349">	uint8 flags() const { return _flags; }</a>
<a name="ln1350">	void set_flags(uint8 flags) { _flags = flags; }</a>
<a name="ln1351">	</a>
<a name="ln1352">private:</a>
<a name="ln1353">	uint8 type;</a>
<a name="ln1354">	uint8 length;</a>
<a name="ln1355">	uint8 reserved1[2];</a>
<a name="ln1356">	</a>
<a name="ln1357">	/*! - flags: 0</a>
<a name="ln1358">	    - identifier: &quot;*UDF Metadata Partition&quot;</a>
<a name="ln1359">	    - identifier_suffix: per UDF-2.50 2.1.5</a>
<a name="ln1360">	*/</a>
<a name="ln1361">	entity_id _partition_type_id;</a>
<a name="ln1362">	uint16 _volume_sequence_number;</a>
<a name="ln1363">	</a>
<a name="ln1364">	/*! corresponding type 1 or type 2 sparable partition</a>
<a name="ln1365">	    map in same logical volume</a>
<a name="ln1366">	*/</a>
<a name="ln1367">	uint16 _partition_number;	</a>
<a name="ln1368">	uint32 _metadata_file_location;</a>
<a name="ln1369">	uint32 _metadata_mirror_file_location;</a>
<a name="ln1370">	uint32 _metadata_bitmap_file_location;</a>
<a name="ln1371">	uint32 _allocation_unit_size;</a>
<a name="ln1372">	uint16 _alignment_unit_size;</a>
<a name="ln1373">	uint8 _flags;</a>
<a name="ln1374">	uint8 reserved2[5];</a>
<a name="ln1375">} __attribute__((packed));</a>
<a name="ln1376"> </a>
<a name="ln1377"> </a>
<a name="ln1378">/*! \brief Unallocated space descriptor</a>
<a name="ln1379"> </a>
<a name="ln1380">	See also: ECMA-167 3/10.8</a>
<a name="ln1381">*/</a>
<a name="ln1382">struct unallocated_space_descriptor {</a>
<a name="ln1383">	void dump() const;</a>
<a name="ln1384"> </a>
<a name="ln1385">	// Get functions</a>
<a name="ln1386">	const descriptor_tag &amp; tag() const { return _tag; }</a>
<a name="ln1387">	descriptor_tag &amp; tag() { return _tag; }</a>
<a name="ln1388">	uint32 vds_number() const { return B_LENDIAN_TO_HOST_INT32(_vds_number); }</a>
<a name="ln1389">	uint32 allocation_descriptor_count() const { return B_LENDIAN_TO_HOST_INT32(_allocation_descriptor_count); }</a>
<a name="ln1390">	extent_address* allocation_descriptors() { return _allocation_descriptors; }</a>
<a name="ln1391"> </a>
<a name="ln1392">	// Set functions</a>
<a name="ln1393">	void set_vds_number(uint32 number) { _vds_number = B_HOST_TO_LENDIAN_INT32(number); }</a>
<a name="ln1394">	void set_allocation_descriptor_count(uint32 count) { _allocation_descriptor_count = B_HOST_TO_LENDIAN_INT32(count); }</a>
<a name="ln1395">private:</a>
<a name="ln1396">	descriptor_tag  _tag;</a>
<a name="ln1397">	uint32 _vds_number;</a>
<a name="ln1398">	uint32 _allocation_descriptor_count;</a>
<a name="ln1399">	extent_address _allocation_descriptors[0];</a>
<a name="ln1400">} __attribute__((packed));</a>
<a name="ln1401"> </a>
<a name="ln1402"> </a>
<a name="ln1403">/*! \brief Terminating descriptor</a>
<a name="ln1404"> </a>
<a name="ln1405">	See also: ECMA-167 3/10.9</a>
<a name="ln1406">*/</a>
<a name="ln1407">struct terminating_descriptor {</a>
<a name="ln1408">	terminating_descriptor() { memset(_reserved.data, 0, _reserved.size()); }</a>
<a name="ln1409">	void dump() const;</a>
<a name="ln1410"> </a>
<a name="ln1411">	// Get functions</a>
<a name="ln1412">	const descriptor_tag &amp; tag() const { return _tag; }</a>
<a name="ln1413">	descriptor_tag &amp; tag() { return _tag; }</a>
<a name="ln1414">private:</a>
<a name="ln1415">	descriptor_tag  _tag;</a>
<a name="ln1416">	array&lt;uint8, 496&gt; _reserved;	</a>
<a name="ln1417">} __attribute__((packed));</a>
<a name="ln1418"> </a>
<a name="ln1419"> </a>
<a name="ln1420">/*! \brief Logical volume integrity descriptor</a>
<a name="ln1421"> </a>
<a name="ln1422">	See also: ECMA-167 3/10.10, UDF-2.50 2.2.6</a>
<a name="ln1423">*/</a>
<a name="ln1424">struct logical_volume_integrity_descriptor {</a>
<a name="ln1425">public:</a>
<a name="ln1426">	static const uint32 minimum_implementation_use_length = 46;</a>
<a name="ln1427"> </a>
<a name="ln1428">	void dump() const;</a>
<a name="ln1429">	uint32 descriptor_size() const { return sizeof(*this)+implementation_use_length()</a>
<a name="ln1430">	                                 + partition_count()*sizeof(uint32)*2; }</a>
<a name="ln1431"> </a>
<a name="ln1432">	descriptor_tag&amp; tag() { return _tag; }</a>
<a name="ln1433">	const descriptor_tag&amp; tag() const { return _tag; }</a>
<a name="ln1434"> </a>
<a name="ln1435">	timestamp&amp; recording_time() { return _recording_time; }</a>
<a name="ln1436">	const timestamp&amp; recording_time() const { return _recording_time; }</a>
<a name="ln1437">	</a>
<a name="ln1438">	uint32 integrity_type() const { return B_LENDIAN_TO_HOST_INT32(_integrity_type); }</a>
<a name="ln1439"> </a>
<a name="ln1440">	extent_address&amp; next_integrity_extent() { return _next_integrity_extent; }</a>
<a name="ln1441">	const extent_address&amp; next_integrity_extent() const { return _next_integrity_extent; }</a>
<a name="ln1442"> </a>
<a name="ln1443">	array&lt;uint8, 32&gt;&amp; logical_volume_contents_use() { return _logical_volume_contents_use; }</a>
<a name="ln1444">	const array&lt;uint8, 32&gt;&amp; logical_volume_contents_use() const { return _logical_volume_contents_use; }</a>
<a name="ln1445">	</a>
<a name="ln1446">	// next_unique_id() field is actually stored in the logical_volume_contents_use()</a>
<a name="ln1447">	// field, per UDF-2.50 3.2.1</a>
<a name="ln1448">	uint64 next_unique_id() const { return B_LENDIAN_TO_HOST_INT64(_next_unique_id()); }</a>
<a name="ln1449">	</a>
<a name="ln1450">	uint32 partition_count() const { return B_LENDIAN_TO_HOST_INT32(_partition_count); }</a>
<a name="ln1451">	uint32 implementation_use_length() const { return B_LENDIAN_TO_HOST_INT32(_implementation_use_length); }</a>
<a name="ln1452"> </a>
<a name="ln1453">	/*! \todo double-check the pointer arithmetic here. */</a>
<a name="ln1454">	uint32* free_space_table() { return reinterpret_cast&lt;uint32*&gt;(reinterpret_cast&lt;uint8*&gt;(this)+80); }</a>
<a name="ln1455">	const uint32* free_space_table() const { return reinterpret_cast&lt;const uint32*&gt;(reinterpret_cast&lt;const uint8*&gt;(this)+80); }</a>
<a name="ln1456">	uint32* size_table() { return reinterpret_cast&lt;uint32*&gt;(reinterpret_cast&lt;uint8*&gt;(free_space_table())+partition_count()*sizeof(uint32)); }</a>
<a name="ln1457">	const uint32* size_table() const { return reinterpret_cast&lt;const uint32*&gt;(reinterpret_cast&lt;const uint8*&gt;(free_space_table())+partition_count()*sizeof(uint32)); }</a>
<a name="ln1458">	uint8* implementation_use() { return reinterpret_cast&lt;uint8*&gt;(reinterpret_cast&lt;uint8*&gt;(size_table())+partition_count()*sizeof(uint32)); }	</a>
<a name="ln1459">	const uint8* implementation_use() const { return reinterpret_cast&lt;const uint8*&gt;(reinterpret_cast&lt;const uint8*&gt;(size_table())+partition_count()*sizeof(uint32)); }	</a>
<a name="ln1460"> </a>
<a name="ln1461">	// accessors for fields stored in implementation_use() field per UDF-2.50 2.2.6.4</a>
<a name="ln1462">	entity_id&amp; implementation_id() { return _accessor().id; }</a>
<a name="ln1463">	const entity_id&amp; implementation_id() const { return _accessor().id; }</a>
<a name="ln1464">	uint32 file_count() const { return B_LENDIAN_TO_HOST_INT32(_accessor().file_count); }</a>
<a name="ln1465">	uint32 directory_count() const { return B_LENDIAN_TO_HOST_INT32(_accessor().directory_count); }</a>
<a name="ln1466">	uint16 minimum_udf_read_revision() const { return B_LENDIAN_TO_HOST_INT16(_accessor().minimum_udf_read_revision); }</a>
<a name="ln1467">	uint16 minimum_udf_write_revision() const { return B_LENDIAN_TO_HOST_INT16(_accessor().minimum_udf_write_revision); }</a>
<a name="ln1468">	uint16 maximum_udf_write_revision() const { return B_LENDIAN_TO_HOST_INT16(_accessor().maximum_udf_write_revision); }</a>
<a name="ln1469">		</a>
<a name="ln1470">	// set functions</a>
<a name="ln1471">	void set_integrity_type(uint32 type) { _integrity_type = B_HOST_TO_LENDIAN_INT32(type); }</a>
<a name="ln1472">	void set_next_unique_id(uint64 id) { _next_unique_id() = B_HOST_TO_LENDIAN_INT64(id); }</a>
<a name="ln1473">	void set_partition_count(uint32 count) { _partition_count = B_HOST_TO_LENDIAN_INT32(count); }</a>
<a name="ln1474">	void set_implementation_use_length(uint32 length) { _implementation_use_length = B_HOST_TO_LENDIAN_INT32(length); }</a>
<a name="ln1475">	</a>
<a name="ln1476">	// set functions for fields stored in implementation_use() field per UDF-2.50 2.2.6.4</a>
<a name="ln1477">	void set_file_count(uint32 count) { _accessor().file_count = B_HOST_TO_LENDIAN_INT32(count); }</a>
<a name="ln1478">	void set_directory_count(uint32 count) { _accessor().directory_count = B_HOST_TO_LENDIAN_INT32(count); }</a>
<a name="ln1479">	void set_minimum_udf_read_revision(uint16 revision) { _accessor().minimum_udf_read_revision = B_HOST_TO_LENDIAN_INT16(revision); }</a>
<a name="ln1480">	void set_minimum_udf_write_revision(uint16 revision) { _accessor().minimum_udf_write_revision = B_HOST_TO_LENDIAN_INT16(revision); }</a>
<a name="ln1481">	void set_maximum_udf_write_revision(uint16 revision) { _accessor().maximum_udf_write_revision = B_HOST_TO_LENDIAN_INT16(revision); }</a>
<a name="ln1482">		</a>
<a name="ln1483">private:</a>
<a name="ln1484">	struct _lvid_implementation_use_accessor {</a>
<a name="ln1485">		entity_id id;</a>
<a name="ln1486">		uint32 file_count;</a>
<a name="ln1487">		uint32 directory_count;</a>
<a name="ln1488">		uint16 minimum_udf_read_revision;</a>
<a name="ln1489">		uint16 minimum_udf_write_revision;</a>
<a name="ln1490">		uint16 maximum_udf_write_revision;</a>
<a name="ln1491">	};</a>
<a name="ln1492">	</a>
<a name="ln1493">	_lvid_implementation_use_accessor&amp; _accessor() {</a>
<a name="ln1494">		return *reinterpret_cast&lt;_lvid_implementation_use_accessor*&gt;(implementation_use());</a>
<a name="ln1495">	}</a>
<a name="ln1496">	const _lvid_implementation_use_accessor&amp; _accessor() const {</a>
<a name="ln1497">		return *reinterpret_cast&lt;const _lvid_implementation_use_accessor*&gt;(implementation_use());</a>
<a name="ln1498">	}</a>
<a name="ln1499">	</a>
<a name="ln1500">	uint64&amp; _next_unique_id() { return *reinterpret_cast&lt;uint64*&gt;(logical_volume_contents_use().data); }</a>
<a name="ln1501">	const uint64&amp; _next_unique_id() const { return *reinterpret_cast&lt;const uint64*&gt;(logical_volume_contents_use().data); }</a>
<a name="ln1502"> </a>
<a name="ln1503">	descriptor_tag  _tag;</a>
<a name="ln1504">	timestamp _recording_time;</a>
<a name="ln1505">	uint32 _integrity_type;</a>
<a name="ln1506">	extent_address _next_integrity_extent;</a>
<a name="ln1507">	array&lt;uint8, 32&gt; _logical_volume_contents_use;</a>
<a name="ln1508">	uint32 _partition_count;</a>
<a name="ln1509">	uint32 _implementation_use_length;</a>
<a name="ln1510"> </a>
<a name="ln1511">} __attribute__((packed));</a>
<a name="ln1512"> </a>
<a name="ln1513">/*! \brief Logical volume integrity types</a>
<a name="ln1514">*/</a>
<a name="ln1515">enum {</a>
<a name="ln1516">	INTEGRITY_OPEN = 0,</a>
<a name="ln1517">	INTEGRITY_CLOSED = 1,</a>
<a name="ln1518">};</a>
<a name="ln1519"> </a>
<a name="ln1520">/*! \brief Highest currently supported UDF read revision.</a>
<a name="ln1521">*/</a>
<a name="ln1522">#define UDF_MAX_READ_REVISION 0x0250</a>
<a name="ln1523"> </a>
<a name="ln1524">//----------------------------------------------------------------------</a>
<a name="ln1525">// ECMA-167 Part 4</a>
<a name="ln1526">//----------------------------------------------------------------------</a>
<a name="ln1527"> </a>
<a name="ln1528"> </a>
<a name="ln1529"> </a>
<a name="ln1530">/*! \brief File set descriptor</a>
<a name="ln1531"> </a>
<a name="ln1532">	Contains all the pertinent info about a file set (i.e. a hierarchy of files)</a>
<a name="ln1533">	</a>
<a name="ln1534">	According to UDF-2.01, only one file set descriptor shall be recorded,</a>
<a name="ln1535">	except on WORM media, where the following rules apply:</a>
<a name="ln1536">	- Multiple file sets are allowed only on WORM media</a>
<a name="ln1537">	- The default file set shall be the one with highest value \c file_set_number field.</a>
<a name="ln1538">	- Only the default file set may be flagged as writeable. All others shall be</a>
<a name="ln1539">	  flagged as &quot;hard write protect&quot;.</a>
<a name="ln1540">	- No writeable file set may reference metadata structures which are referenced</a>
<a name="ln1541">	  (directly or indirectly) by any other file set. Writeable file sets may, however,</a>
<a name="ln1542">	  reference actual file data extents that are also referenced by other file sets.</a>
<a name="ln1543">*/</a>
<a name="ln1544">struct file_set_descriptor {</a>
<a name="ln1545">	void dump() const;</a>
<a name="ln1546"> </a>
<a name="ln1547">	// Get functions</a>
<a name="ln1548">	const descriptor_tag &amp; tag() const { return _tag; }</a>
<a name="ln1549">	descriptor_tag &amp; tag() { return _tag; }</a>
<a name="ln1550"> </a>
<a name="ln1551">	const timestamp&amp; recording_date_and_time() const { return _recording_date_and_time; }</a>
<a name="ln1552">	timestamp&amp; recording_date_and_time() { return _recording_date_and_time; }</a>
<a name="ln1553"> </a>
<a name="ln1554">	uint16 interchange_level() const { return B_LENDIAN_TO_HOST_INT16(_interchange_level); }</a>
<a name="ln1555">	uint16 max_interchange_level() const { return B_LENDIAN_TO_HOST_INT16(_max_interchange_level); }</a>
<a name="ln1556">	uint32 character_set_list() const { return B_LENDIAN_TO_HOST_INT32(_character_set_list); }</a>
<a name="ln1557">	uint32 max_character_set_list() const { return B_LENDIAN_TO_HOST_INT32(_max_character_set_list); }</a>
<a name="ln1558">	uint32 file_set_number() const { return B_LENDIAN_TO_HOST_INT32(_file_set_number); }</a>
<a name="ln1559">	uint32 file_set_descriptor_number() const { return B_LENDIAN_TO_HOST_INT32(_file_set_descriptor_number); }</a>
<a name="ln1560"> </a>
<a name="ln1561">	const charspec&amp; logical_volume_id_character_set() const { return _logical_volume_id_character_set; }</a>
<a name="ln1562">	charspec&amp; logical_volume_id_character_set() { return _logical_volume_id_character_set; }</a>
<a name="ln1563"> </a>
<a name="ln1564">	const array&lt;char, 128&gt;&amp; logical_volume_id() const { return _logical_volume_id; }</a>
<a name="ln1565">	array&lt;char, 128&gt;&amp; logical_volume_id() { return _logical_volume_id; }</a>
<a name="ln1566"> </a>
<a name="ln1567">	const charspec&amp; file_set_id_character_set() const { return _file_set_id_character_set; }</a>
<a name="ln1568">	charspec&amp; file_set_id_character_set() { return _file_set_id_character_set; }</a>
<a name="ln1569"> </a>
<a name="ln1570">	const array&lt;char, 32&gt;&amp; file_set_id() const { return _file_set_id; }</a>
<a name="ln1571">	array&lt;char, 32&gt;&amp; file_set_id() { return _file_set_id; }</a>
<a name="ln1572"> </a>
<a name="ln1573">	const array&lt;char, 32&gt;&amp; copyright_file_id() const { return _copyright_file_id; }</a>
<a name="ln1574">	array&lt;char, 32&gt;&amp; copyright_file_id() { return _copyright_file_id; }</a>
<a name="ln1575"> </a>
<a name="ln1576">	const array&lt;char, 32&gt;&amp; abstract_file_id() const { return _abstract_file_id; }</a>
<a name="ln1577">	array&lt;char, 32&gt;&amp; abstract_file_id() { return _abstract_file_id; }</a>
<a name="ln1578"> </a>
<a name="ln1579">	const long_address&amp; root_directory_icb() const { return _root_directory_icb; }</a>
<a name="ln1580">	long_address&amp; root_directory_icb() { return _root_directory_icb; }</a>
<a name="ln1581"> </a>
<a name="ln1582">	const entity_id&amp; domain_id() const { return _domain_id; }</a>
<a name="ln1583">	entity_id&amp; domain_id() { return _domain_id; }</a>
<a name="ln1584"> </a>
<a name="ln1585">	const long_address&amp; next_extent() const { return _next_extent; }</a>
<a name="ln1586">	long_address&amp; next_extent() { return _next_extent; }</a>
<a name="ln1587"> </a>
<a name="ln1588">	const long_address&amp; system_stream_directory_icb() const { return _system_stream_directory_icb; }</a>
<a name="ln1589">	long_address&amp; system_stream_directory_icb() { return _system_stream_directory_icb; }</a>
<a name="ln1590"> </a>
<a name="ln1591">	const array&lt;uint8, 32&gt;&amp; reserved() const { return _reserved; }</a>
<a name="ln1592">	array&lt;uint8, 32&gt;&amp; reserved() { return _reserved; }</a>
<a name="ln1593"> </a>
<a name="ln1594">	// Set functions</a>
<a name="ln1595">	void set_interchange_level(uint16 level) { _interchange_level = B_HOST_TO_LENDIAN_INT16(level); }</a>
<a name="ln1596">	void set_max_interchange_level(uint16 level) { _max_interchange_level = B_HOST_TO_LENDIAN_INT16(level); }</a>
<a name="ln1597">	void set_character_set_list(uint32 list) { _character_set_list = B_HOST_TO_LENDIAN_INT32(list); }</a>
<a name="ln1598">	void set_max_character_set_list(uint32 list) { _max_character_set_list = B_HOST_TO_LENDIAN_INT32(list); }</a>
<a name="ln1599">	void set_file_set_number(uint32 number) { _file_set_number = B_HOST_TO_LENDIAN_INT32(number); }</a>
<a name="ln1600">	void set_file_set_descriptor_number(uint32 number) { _file_set_descriptor_number = B_HOST_TO_LENDIAN_INT32(number); }</a>
<a name="ln1601">private:</a>
<a name="ln1602">	descriptor_tag  _tag;</a>
<a name="ln1603">	timestamp _recording_date_and_time;</a>
<a name="ln1604">	uint16 _interchange_level;			//!&lt; To be set to 3 (see UDF-2.01 2.3.2.1)</a>
<a name="ln1605">	uint16 _max_interchange_level;		//!&lt; To be set to 3 (see UDF-2.01 2.3.2.2)</a>
<a name="ln1606">	uint32 _character_set_list;</a>
<a name="ln1607">	uint32 _max_character_set_list;</a>
<a name="ln1608">	uint32 _file_set_number;</a>
<a name="ln1609">	uint32 _file_set_descriptor_number;</a>
<a name="ln1610">	charspec _logical_volume_id_character_set;	//!&lt; To be set to kCSOCharspec</a>
<a name="ln1611">	array&lt;char, 128&gt; _logical_volume_id;</a>
<a name="ln1612">	charspec _file_set_id_character_set;</a>
<a name="ln1613">	array&lt;char, 32&gt; _file_set_id;</a>
<a name="ln1614">	array&lt;char, 32&gt; _copyright_file_id;</a>
<a name="ln1615">	array&lt;char, 32&gt; _abstract_file_id;</a>
<a name="ln1616">	long_address _root_directory_icb;</a>
<a name="ln1617">	entity_id _domain_id;	</a>
<a name="ln1618">	long_address _next_extent;</a>
<a name="ln1619">	long_address _system_stream_directory_icb;</a>
<a name="ln1620">	array&lt;uint8, 32&gt; _reserved;</a>
<a name="ln1621">} __attribute__((packed));</a>
<a name="ln1622"> </a>
<a name="ln1623"> </a>
<a name="ln1624">/*! \brief Partition header descriptor</a>
<a name="ln1625">	</a>
<a name="ln1626">	Contains references to unallocated and freed space data structures.</a>
<a name="ln1627">	</a>
<a name="ln1628">	Note that unallocated space is space ready to be written with no</a>
<a name="ln1629">	preprocessing. Freed space is space needing preprocessing (i.e.</a>
<a name="ln1630">	a special write pass) before use.</a>
<a name="ln1631">	</a>
<a name="ln1632">	Per UDF-2.01 2.3.3, the use of tables or bitmaps shall be consistent,</a>
<a name="ln1633">	i.e. only one type or the other shall be used, not both.</a>
<a name="ln1634">	</a>
<a name="ln1635">	To indicate disuse of a certain field, the fields of the allocation</a>
<a name="ln1636">	descriptor shall all be set to 0.</a>
<a name="ln1637">	</a>
<a name="ln1638">	See also: ECMA-167 4/14.3, UDF-2.01 2.2.3</a>
<a name="ln1639">*/</a>
<a name="ln1640">struct partition_header_descriptor {</a>
<a name="ln1641">	long_address unallocated_space_table;</a>
<a name="ln1642">	long_address unallocated_space_bitmap;</a>
<a name="ln1643">	/*! Unused, per UDF-2.01 2.2.3 */</a>
<a name="ln1644">	long_address partition_integrity_table;</a>
<a name="ln1645">	long_address freed_space_table;</a>
<a name="ln1646">	long_address freed_space_bitmap;</a>
<a name="ln1647">	uint8 reserved[88];</a>
<a name="ln1648">} __attribute__((packed));</a>
<a name="ln1649"> </a>
<a name="ln1650">#define kMaxFileIdSize (sizeof(file_id_descriptor)+512+3)</a>
<a name="ln1651"> </a>
<a name="ln1652">/*! \brief File identifier descriptor</a>
<a name="ln1653"> </a>
<a name="ln1654">	Identifies the name of a file entry, and the location of its corresponding</a>
<a name="ln1655">	ICB.</a>
<a name="ln1656">	</a>
<a name="ln1657">	See also: ECMA-167 4/14.4, UDF-2.01 2.3.4</a>
<a name="ln1658">	</a>
<a name="ln1659">	\todo Check pointer arithmetic</a>
<a name="ln1660">*/</a>
<a name="ln1661">struct file_id_descriptor {</a>
<a name="ln1662">public:</a>
<a name="ln1663">	uint32 descriptor_size() const { return total_length(); }</a>
<a name="ln1664">	void dump() const;</a>
<a name="ln1665"> </a>
<a name="ln1666">	descriptor_tag &amp; tag() { return _tag; }</a>
<a name="ln1667">	const descriptor_tag &amp; tag() const { return _tag; }</a>
<a name="ln1668"> </a>
<a name="ln1669">	uint16 version_number() const { return B_LENDIAN_TO_HOST_INT16(_version_number); }</a>
<a name="ln1670"> </a>
<a name="ln1671">	uint8 characteristics() const { return _characteristics; }</a>
<a name="ln1672">	</a>
<a name="ln1673">	bool may_be_hidden() const {</a>
<a name="ln1674">		characteristics_accessor c;</a>
<a name="ln1675">		c.all = characteristics();</a>
<a name="ln1676">		return c.bits.may_be_hidden;</a>
<a name="ln1677">	}</a>
<a name="ln1678">	</a>
<a name="ln1679">	bool is_directory() const {</a>
<a name="ln1680">		characteristics_accessor c;</a>
<a name="ln1681">		c.all = characteristics();</a>
<a name="ln1682">		return c.bits.is_directory;</a>
<a name="ln1683">	}</a>
<a name="ln1684">	</a>
<a name="ln1685">	bool is_deleted() const {</a>
<a name="ln1686">		characteristics_accessor c;</a>
<a name="ln1687">		c.all = characteristics();</a>
<a name="ln1688">		return c.bits.is_deleted;</a>
<a name="ln1689">	}</a>
<a name="ln1690">	</a>
<a name="ln1691">	bool is_parent() const {</a>
<a name="ln1692">		characteristics_accessor c;</a>
<a name="ln1693">		c.all = characteristics();</a>
<a name="ln1694">		return c.bits.is_parent;</a>
<a name="ln1695">	}</a>
<a name="ln1696">	</a>
<a name="ln1697">	bool is_metadata_stream() const {</a>
<a name="ln1698">		characteristics_accessor c;</a>
<a name="ln1699">		c.all = characteristics();</a>
<a name="ln1700">		return c.bits.is_metadata_stream;</a>
<a name="ln1701">	}</a>
<a name="ln1702">	</a>
<a name="ln1703">	uint8 id_length() const { return _id_length; }</a>
<a name="ln1704"> </a>
<a name="ln1705">	long_address&amp; icb() { return _icb; }</a>
<a name="ln1706">	const long_address&amp; icb() const { return _icb; }</a>
<a name="ln1707"> </a>
<a name="ln1708">	uint16 implementation_use_length() const { return B_LENDIAN_TO_HOST_INT16(_implementation_use_length); }</a>
<a name="ln1709">	</a>
<a name="ln1710">	/*! If implementation_use_length is greater than 0, the first 32</a>
<a name="ln1711">		bytes of implementation_use() shall be an entity_id identifying</a>
<a name="ln1712">		the implementation that generated the rest of the data in the</a>
<a name="ln1713">		implementation_use() field.</a>
<a name="ln1714">	*/</a>
<a name="ln1715">	uint8* implementation_use() { return ((uint8*)this)+(38); }</a>
<a name="ln1716">	char* id() { return ((char*)this)+(38)+implementation_use_length(); }	</a>
<a name="ln1717">	const char* id() const { return ((const char*)this)+(38)+implementation_use_length(); }	</a>
<a name="ln1718">	</a>
<a name="ln1719">	uint16 structure_length() const { return (38) + id_length() + implementation_use_length(); }</a>
<a name="ln1720">	uint16 padding_length() const { return ((structure_length()+3)/4)*4 - structure_length(); }</a>
<a name="ln1721">	uint16 total_length() const { return structure_length() + padding_length(); }</a>
<a name="ln1722">	</a>
<a name="ln1723">	// Set functions</a>
<a name="ln1724">	void set_version_number(uint16 number) { _version_number = B_HOST_TO_LENDIAN_INT16(number); }</a>
<a name="ln1725"> </a>
<a name="ln1726">	void set_characteristics(uint8 characteristics) { _characteristics = characteristics; }</a>
<a name="ln1727"> </a>
<a name="ln1728">	void set_may_be_hidden(bool how) {</a>
<a name="ln1729">		characteristics_accessor c;</a>
<a name="ln1730">		c.all = characteristics();</a>
<a name="ln1731">		c.bits.may_be_hidden = how;</a>
<a name="ln1732">		set_characteristics(c.all);</a>
<a name="ln1733">	}</a>
<a name="ln1734">	</a>
<a name="ln1735">	void set_is_directory(bool how) {</a>
<a name="ln1736">		characteristics_accessor c;</a>
<a name="ln1737">		c.all = characteristics();</a>
<a name="ln1738">		c.bits.is_directory = how;</a>
<a name="ln1739">		set_characteristics(c.all);</a>
<a name="ln1740">	}</a>
<a name="ln1741">	</a>
<a name="ln1742">	void set_is_deleted(bool how) {</a>
<a name="ln1743">		characteristics_accessor c;</a>
<a name="ln1744">		c.all = characteristics();</a>
<a name="ln1745">		c.bits.is_deleted = how;</a>
<a name="ln1746">		set_characteristics(c.all);</a>
<a name="ln1747">	}</a>
<a name="ln1748">	</a>
<a name="ln1749">	void set_is_parent(bool how) {</a>
<a name="ln1750">		characteristics_accessor c;</a>
<a name="ln1751">		c.all = characteristics();</a>
<a name="ln1752">		c.bits.is_parent = how;</a>
<a name="ln1753">		set_characteristics(c.all);</a>
<a name="ln1754">	}</a>
<a name="ln1755">	</a>
<a name="ln1756">	void set_is_metadata_stream(bool how) {</a>
<a name="ln1757">		characteristics_accessor c;</a>
<a name="ln1758">		c.all = characteristics();</a>
<a name="ln1759">		c.bits.is_metadata_stream = how;</a>
<a name="ln1760">		set_characteristics(c.all);</a>
<a name="ln1761">	}</a>
<a name="ln1762">	</a>
<a name="ln1763"> </a>
<a name="ln1764">	void set_id_length(uint8 id_length) { _id_length = id_length; }</a>
<a name="ln1765">	void set_implementation_use_length(uint16 implementation_use_length) { _implementation_use_length = B_HOST_TO_LENDIAN_INT16(implementation_use_length); }</a>
<a name="ln1766">	</a>
<a name="ln1767">	</a>
<a name="ln1768">	</a>
<a name="ln1769">private:</a>
<a name="ln1770">	union characteristics_accessor {</a>
<a name="ln1771">		uint8 all;</a>
<a name="ln1772">		struct { </a>
<a name="ln1773">			uint8	may_be_hidden:1,</a>
<a name="ln1774">					is_directory:1,</a>
<a name="ln1775">					is_deleted:1,</a>
<a name="ln1776">					is_parent:1,</a>
<a name="ln1777">					is_metadata_stream:1,</a>
<a name="ln1778">					reserved_characteristics:3;</a>
<a name="ln1779">		} bits;</a>
<a name="ln1780">	};	</a>
<a name="ln1781">	</a>
<a name="ln1782">	descriptor_tag  _tag;</a>
<a name="ln1783">	/*! According to ECMA-167: 1 &lt;= valid version_number &lt;= 32767, 32768 &lt;= reserved &lt;= 65535.</a>
<a name="ln1784">		</a>
<a name="ln1785">		However, according to UDF-2.01, there shall be exactly one version of</a>
<a name="ln1786">		a file, and it shall be 1.</a>
<a name="ln1787">	 */</a>
<a name="ln1788">	uint16 _version_number;</a>
<a name="ln1789">	/*! \todo Check UDF-2.01 2.3.4.2 for some more restrictions. */</a>
<a name="ln1790">	uint8 _characteristics;</a>
<a name="ln1791">	uint8 _id_length;</a>
<a name="ln1792">	long_address _icb;</a>
<a name="ln1793">	uint16 _implementation_use_length;	</a>
<a name="ln1794">} __attribute__((packed));</a>
<a name="ln1795"> </a>
<a name="ln1796"> </a>
<a name="ln1797">/*! \brief Allocation extent descriptor</a>
<a name="ln1798"> </a>
<a name="ln1799">	See also: ECMA-167 4/14.5</a>
<a name="ln1800">*/</a>
<a name="ln1801">struct allocation_extent_descriptor {</a>
<a name="ln1802">	descriptor_tag  tag;</a>
<a name="ln1803">	uint32 previous_allocation_extent_location;</a>
<a name="ln1804">	uint32 length_of_allocation_descriptors;</a>
<a name="ln1805">	</a>
<a name="ln1806">	/*! \todo Check that this is really how things work: */</a>
<a name="ln1807">	uint8* allocation_descriptors() { return (uint8*)(reinterpret_cast&lt;uint8*&gt;(this)+sizeof(allocation_extent_descriptor)); }</a>
<a name="ln1808">} __attribute__((packed));</a>
<a name="ln1809"> </a>
<a name="ln1810"> </a>
<a name="ln1811">/*! \brief icb_tag::file_type values</a>
<a name="ln1812"> </a>
<a name="ln1813">	See also ECMA-167 4/14.6.6</a>
<a name="ln1814">*/</a>
<a name="ln1815">enum icb_file_types {</a>
<a name="ln1816">	ICB_TYPE_UNSPECIFIED = 0,</a>
<a name="ln1817">	ICB_TYPE_UNALLOCATED_SPACE_ENTRY,</a>
<a name="ln1818">	ICB_TYPE_PARTITION_INTEGRITY_ENTRY,</a>
<a name="ln1819">	ICB_TYPE_INDIRECT_ENTRY,</a>
<a name="ln1820">	ICB_TYPE_DIRECTORY,</a>
<a name="ln1821">	ICB_TYPE_REGULAR_FILE,</a>
<a name="ln1822">	ICB_TYPE_BLOCK_SPECIAL_DEVICE,</a>
<a name="ln1823">	ICB_TYPE_CHARACTER_SPECIAL_DEVICE,</a>
<a name="ln1824">	ICB_TYPE_EXTENDED_ATTRIBUTES_FILE,</a>
<a name="ln1825">	ICB_TYPE_FIFO,</a>
<a name="ln1826">	ICB_TYPE_ISSOCK,</a>
<a name="ln1827">	ICB_TYPE_TERMINAL,</a>
<a name="ln1828">	ICB_TYPE_SYMLINK,</a>
<a name="ln1829">	ICB_TYPE_STREAM_DIRECTORY,</a>
<a name="ln1830"> </a>
<a name="ln1831">	ICB_TYPE_RESERVED_START = 14,</a>
<a name="ln1832">	ICB_TYPE_RESERVED_END = 247,</a>
<a name="ln1833">	</a>
<a name="ln1834">	ICB_TYPE_CUSTOM_START = 248,</a>
<a name="ln1835">	ICB_TYPE_CUSTOM_END = 255,</a>
<a name="ln1836">};</a>
<a name="ln1837"> </a>
<a name="ln1838">/*!	\brief idb_entry_tag::_flags::descriptor_flags() values</a>
<a name="ln1839"> </a>
<a name="ln1840">	See also ECMA-167 4/14.6.8</a>
<a name="ln1841">*/</a>
<a name="ln1842">enum icb_descriptor_types {</a>
<a name="ln1843">	ICB_DESCRIPTOR_TYPE_SHORT = 0,</a>
<a name="ln1844">	ICB_DESCRIPTOR_TYPE_LONG,</a>
<a name="ln1845">	ICB_DESCRIPTOR_TYPE_EXTENDED,</a>
<a name="ln1846">	ICB_DESCRIPTOR_TYPE_EMBEDDED,</a>
<a name="ln1847">};</a>
<a name="ln1848"> </a>
<a name="ln1849">/*!	\brief idb_entry_tag::strategy_type() values</a>
<a name="ln1850"> </a>
<a name="ln1851">	See also UDF-2.50 2.3.5.1</a>
<a name="ln1852">*/</a>
<a name="ln1853">enum icb_strategy_types {</a>
<a name="ln1854">	ICB_STRATEGY_SINGLE = 4,</a>
<a name="ln1855">	ICB_STRATEGY_LINKED_LIST = 4096</a>
<a name="ln1856">};</a>
<a name="ln1857"> </a>
<a name="ln1858">/*! \brief ICB entry tag</a>
<a name="ln1859"> </a>
<a name="ln1860">	Common tag found in all ICB entries (in addition to, and immediately following,</a>
<a name="ln1861">	the descriptor tag).</a>
<a name="ln1862"> </a>
<a name="ln1863">	See also: ECMA-167 4/14.6, UDF-2.01 2.3.5</a>
<a name="ln1864">*/</a>
<a name="ln1865">struct icb_entry_tag {</a>
<a name="ln1866">public:</a>
<a name="ln1867">	union flags_accessor {</a>
<a name="ln1868">		uint16 all_flags;</a>
<a name="ln1869">		struct {</a>
<a name="ln1870">			uint16	descriptor_flags:3,			</a>
<a name="ln1871">					if_directory_then_sort:1,	//!&lt; To be set to 0 per UDF-2.01 2.3.5.4</a>
<a name="ln1872">					non_relocatable:1,</a>
<a name="ln1873">					archive:1,</a>
<a name="ln1874">					setuid:1,</a>
<a name="ln1875">					setgid:1,</a>
<a name="ln1876">					sticky:1,</a>
<a name="ln1877">					contiguous:1,</a>
<a name="ln1878">					system:1,</a>
<a name="ln1879">					transformed:1,</a>
<a name="ln1880">					multi_version:1,			//!&lt; To be set to 0 per UDF-2.01 2.3.5.4</a>
<a name="ln1881">					is_stream:1,</a>
<a name="ln1882">					reserved_icb_entry_flags:2;</a>
<a name="ln1883">		} flags;</a>
<a name="ln1884">	};</a>
<a name="ln1885">	</a>
<a name="ln1886">public:</a>
<a name="ln1887">	void dump() const;</a>
<a name="ln1888"> </a>
<a name="ln1889">	uint32 prior_recorded_number_of_direct_entries() const { return B_LENDIAN_TO_HOST_INT32(_prior_recorded_number_of_direct_entries); }</a>
<a name="ln1890">	uint16 strategy_type() const { return B_LENDIAN_TO_HOST_INT16(_strategy_type); }</a>
<a name="ln1891"> </a>
<a name="ln1892">	array&lt;uint8, 2&gt;&amp; strategy_parameters() { return _strategy_parameters; }</a>
<a name="ln1893">	const array&lt;uint8, 2&gt;&amp; strategy_parameters() const { return _strategy_parameters; }</a>
<a name="ln1894"> </a>
<a name="ln1895">	uint16 entry_count() const { return B_LENDIAN_TO_HOST_INT16(_entry_count); }</a>
<a name="ln1896">	uint8&amp; reserved() { return _reserved; }</a>
<a name="ln1897">	uint8 file_type() const { return _file_type; }</a>
<a name="ln1898">	logical_block_address&amp; parent_icb_location() { return _parent_icb_location; }</a>
<a name="ln1899">	const logical_block_address&amp; parent_icb_location() const { return _parent_icb_location; }</a>
<a name="ln1900"> </a>
<a name="ln1901">	uint16 flags() const { return B_LENDIAN_TO_HOST_INT16(_flags); }</a>
<a name="ln1902">	flags_accessor&amp; flags_access() { return *reinterpret_cast&lt;flags_accessor*&gt;(&amp;_flags); }</a>
<a name="ln1903">	</a>
<a name="ln1904">	// flags accessor functions</a>
<a name="ln1905">	uint8 descriptor_flags() const {</a>
<a name="ln1906">		flags_accessor f;</a>
<a name="ln1907">		f.all_flags = flags();</a>
<a name="ln1908">		return f.flags.descriptor_flags;</a>
<a name="ln1909">	}</a>
<a name="ln1910">/*	void set_descriptor_flags(uint8 value) {</a>
<a name="ln1911">		flags_accessor f;</a>
<a name="ln1912">		f.all_flags = flags();</a>
<a name="ln1913">		f.flags.descriptor_flags = value;</a>
<a name="ln1914">		set_flags</a>
<a name="ln1915">*/		</a>
<a name="ln1916">	</a>
<a name="ln1917">	void set_prior_recorded_number_of_direct_entries(uint32 entries) { _prior_recorded_number_of_direct_entries = B_LENDIAN_TO_HOST_INT32(entries); }</a>
<a name="ln1918">	void set_strategy_type(uint16 type) { _strategy_type = B_HOST_TO_LENDIAN_INT16(type); }</a>
<a name="ln1919"> </a>
<a name="ln1920">	void set_entry_count(uint16 count) { _entry_count = B_LENDIAN_TO_HOST_INT16(count); }</a>
<a name="ln1921">	void set_file_type(uint8 type) { _file_type = type; }</a>
<a name="ln1922"> </a>
<a name="ln1923">	void set_flags(uint16 flags) { _flags = B_LENDIAN_TO_HOST_INT16(flags); }</a>
<a name="ln1924">	</a>
<a name="ln1925">private:</a>
<a name="ln1926">	uint32 _prior_recorded_number_of_direct_entries;</a>
<a name="ln1927">	/*! Per UDF-2.01 2.3.5.1, only strategy types 4 and 4096 shall be supported.</a>
<a name="ln1928">	</a>
<a name="ln1929">		\todo Describe strategy types here.</a>
<a name="ln1930">	*/</a>
<a name="ln1931">	uint16 _strategy_type;</a>
<a name="ln1932">	array&lt;uint8, 2&gt; _strategy_parameters;</a>
<a name="ln1933">	uint16 _entry_count;</a>
<a name="ln1934">	uint8 _reserved;</a>
<a name="ln1935">	/*! \brief icb_file_type value identifying the type of this icb entry */</a>
<a name="ln1936">	uint8 _file_type;</a>
<a name="ln1937">	logical_block_address _parent_icb_location;</a>
<a name="ln1938">	uint16 _flags;</a>
<a name="ln1939">} __attribute__((packed));</a>
<a name="ln1940"> </a>
<a name="ln1941">/*! \brief Header portion of an ICB entry.</a>
<a name="ln1942">*/</a>
<a name="ln1943">struct icb_header {</a>
<a name="ln1944">public:</a>
<a name="ln1945">	void dump() const;</a>
<a name="ln1946">	</a>
<a name="ln1947">	descriptor_tag  &amp;tag() { return _tag; }</a>
<a name="ln1948">	const descriptor_tag  &amp;tag() const { return _tag; }</a>
<a name="ln1949">	</a>
<a name="ln1950">	icb_entry_tag &amp;icb_tag() { return _icb_tag; }</a>
<a name="ln1951">	const icb_entry_tag &amp;icb_tag() const { return _icb_tag; }</a>
<a name="ln1952">private:</a>
<a name="ln1953">	descriptor_tag  _tag;</a>
<a name="ln1954">	icb_entry_tag _icb_tag;</a>
<a name="ln1955">};</a>
<a name="ln1956"> </a>
<a name="ln1957">/*! \brief Indirect ICB entry</a>
<a name="ln1958">*/</a>
<a name="ln1959">struct indirect_icb_entry {</a>
<a name="ln1960">	descriptor_tag  tag;</a>
<a name="ln1961">	icb_entry_tag icb_tag;</a>
<a name="ln1962">	long_address indirect_icb;</a>
<a name="ln1963">} __attribute__((packed));</a>
<a name="ln1964"> </a>
<a name="ln1965"> </a>
<a name="ln1966">/*! \brief Terminal ICB entry</a>
<a name="ln1967">*/</a>
<a name="ln1968">struct terminal_icb_entry {</a>
<a name="ln1969">	descriptor_tag  tag;</a>
<a name="ln1970">	icb_entry_tag icb_tag;</a>
<a name="ln1971">} __attribute__((packed));</a>
<a name="ln1972"> </a>
<a name="ln1973">enum permissions {</a>
<a name="ln1974">	OTHER_EXECUTE	 	= 0x0001,</a>
<a name="ln1975">	OTHER_WRITE			= 0x0002,</a>
<a name="ln1976">	OTHER_READ			= 0x0004,</a>
<a name="ln1977">	OTHER_ATTRIBUTES	= 0x0008,</a>
<a name="ln1978">	OTHER_DELETE		= 0x0010,</a>
<a name="ln1979">	GROUP_EXECUTE	 	= 0x0020,</a>
<a name="ln1980">	GROUP_WRITE			= 0x0040,</a>
<a name="ln1981">	GROUP_READ			= 0x0080,</a>
<a name="ln1982">	GROUP_ATTRIBUTES	= 0x0100,</a>
<a name="ln1983">	GROUP_DELETE		= 0x0200,</a>
<a name="ln1984">	USER_EXECUTE	 	= 0x0400,</a>
<a name="ln1985">	USER_WRITE			= 0x0800,</a>
<a name="ln1986">	USER_READ			= 0x1000,</a>
<a name="ln1987">	USER_ATTRIBUTES		= 0x2000,</a>
<a name="ln1988">	USER_DELETE			= 0x4000,</a>
<a name="ln1989">};</a>
<a name="ln1990"> </a>
<a name="ln1991">/*! \brief File ICB entry</a>
<a name="ln1992"> </a>
<a name="ln1993">	See also: ECMA-167 4/14.9</a>
<a name="ln1994"> </a>
<a name="ln1995">	\todo Check pointer math.</a>
<a name="ln1996">*/</a>
<a name="ln1997">struct file_icb_entry {</a>
<a name="ln1998">	void dump() const;</a>
<a name="ln1999">	uint32 descriptor_size() const { return sizeof(*this)+extended_attributes_length()</a>
<a name="ln2000">	                                 +allocation_descriptors_length(); }</a>
<a name="ln2001">	const char* descriptor_name() const { return &quot;file_icb_entry&quot;; }</a>
<a name="ln2002"> </a>
<a name="ln2003">	// get functions</a>
<a name="ln2004">	descriptor_tag &amp; tag() { return _tag; }</a>
<a name="ln2005">	const descriptor_tag &amp; tag() const { return _tag; }</a>
<a name="ln2006">	</a>
<a name="ln2007">	icb_entry_tag&amp; icb_tag() { return _icb_tag; }</a>
<a name="ln2008">	const icb_entry_tag&amp; icb_tag() const { return _icb_tag; }</a>
<a name="ln2009">	</a>
<a name="ln2010">	uint32 uid() const { return B_LENDIAN_TO_HOST_INT32(_uid); }</a>
<a name="ln2011">	uint32 gid() const { return B_LENDIAN_TO_HOST_INT32(_gid); }</a>
<a name="ln2012">	uint32 permissions() const { return B_LENDIAN_TO_HOST_INT32(_permissions); }</a>
<a name="ln2013">	uint16 file_link_count() const { return B_LENDIAN_TO_HOST_INT16(_file_link_count); }</a>
<a name="ln2014">	uint8 record_format() const { return _record_format; }</a>
<a name="ln2015">	uint8 record_display_attributes() const { return _record_display_attributes; }</a>
<a name="ln2016">	uint8 record_length() const { return _record_length; }</a>
<a name="ln2017">	uint64 information_length() const { return B_LENDIAN_TO_HOST_INT64(_information_length); }</a>
<a name="ln2018">	uint64 logical_blocks_recorded() const { return B_LENDIAN_TO_HOST_INT64(_logical_blocks_recorded); }</a>
<a name="ln2019"> </a>
<a name="ln2020">	timestamp&amp; access_date_and_time() { return _access_date_and_time; }</a>
<a name="ln2021">	const timestamp&amp; access_date_and_time() const { return _access_date_and_time; }</a>
<a name="ln2022"> </a>
<a name="ln2023">	timestamp&amp; modification_date_and_time() { return _modification_date_and_time; }</a>
<a name="ln2024">	const timestamp&amp; modification_date_and_time() const { return _modification_date_and_time; }</a>
<a name="ln2025"> </a>
<a name="ln2026">	timestamp&amp; attribute_date_and_time() { return _attribute_date_and_time; }</a>
<a name="ln2027">	const timestamp&amp; attribute_date_and_time() const { return _attribute_date_and_time; }</a>
<a name="ln2028"> </a>
<a name="ln2029">	uint32 checkpoint() const { return B_LENDIAN_TO_HOST_INT32(_checkpoint); }</a>
<a name="ln2030"> </a>
<a name="ln2031">	long_address&amp; extended_attribute_icb() { return _extended_attribute_icb; }</a>
<a name="ln2032">	const long_address&amp; extended_attribute_icb() const { return _extended_attribute_icb; }</a>
<a name="ln2033"> </a>
<a name="ln2034">	entity_id&amp; implementation_id() { return _implementation_id; }</a>
<a name="ln2035">	const entity_id&amp; implementation_id() const { return _implementation_id; }</a>
<a name="ln2036"> </a>
<a name="ln2037">	uint64 unique_id() const { return B_LENDIAN_TO_HOST_INT64(_unique_id); }</a>
<a name="ln2038">	uint32 extended_attributes_length() const { return B_LENDIAN_TO_HOST_INT32(_extended_attributes_length); }</a>
<a name="ln2039">	uint32 allocation_descriptors_length() const { return B_LENDIAN_TO_HOST_INT32(_allocation_descriptors_length); }</a>
<a name="ln2040"> </a>
<a name="ln2041">	uint8* extended_attributes() { return _end(); }</a>
<a name="ln2042">	const uint8* extended_attributes() const { return _end(); }</a>
<a name="ln2043">	uint8* allocation_descriptors() { return _end()+extended_attributes_length(); }</a>
<a name="ln2044">	const uint8* allocation_descriptors() const { return _end()+extended_attributes_length(); }</a>
<a name="ln2045">	</a>
<a name="ln2046">	// set functions</a>
<a name="ln2047">	void set_uid(uint32 uid) { _uid = B_HOST_TO_LENDIAN_INT32(uid); }</a>
<a name="ln2048">	void set_gid(uint32 gid) { _gid = B_HOST_TO_LENDIAN_INT32(gid); }</a>
<a name="ln2049">	void set_permissions(uint32 permissions) { _permissions = B_HOST_TO_LENDIAN_INT32(permissions); }</a>
<a name="ln2050"> </a>
<a name="ln2051">	void set_file_link_count(uint16 count) { _file_link_count = B_HOST_TO_LENDIAN_INT16(count); }</a>
<a name="ln2052">	void set_record_format(uint8 format) { _record_format = format; }</a>
<a name="ln2053">	void set_record_display_attributes(uint8 attributes) { _record_display_attributes = attributes; }</a>
<a name="ln2054">	void set_record_length(uint8 length) { _record_length = length; }</a>
<a name="ln2055"> </a>
<a name="ln2056">	void set_information_length(uint64 length) { _information_length = B_HOST_TO_LENDIAN_INT64(length); }</a>
<a name="ln2057">	void set_logical_blocks_recorded(uint64 blocks) { _logical_blocks_recorded = B_HOST_TO_LENDIAN_INT64(blocks); }</a>
<a name="ln2058"> </a>
<a name="ln2059">	void set_checkpoint(uint32 checkpoint) { _checkpoint = B_HOST_TO_LENDIAN_INT32(checkpoint); }</a>
<a name="ln2060"> </a>
<a name="ln2061">	void set_unique_id(uint64 id) { _unique_id = B_HOST_TO_LENDIAN_INT64(id); }</a>
<a name="ln2062"> </a>
<a name="ln2063">	void set_extended_attributes_length(uint32 length) { _extended_attributes_length = B_HOST_TO_LENDIAN_INT32(length); }</a>
<a name="ln2064">	void set_allocation_descriptors_length(uint32 length) { _allocation_descriptors_length = B_HOST_TO_LENDIAN_INT32(length); }</a>
<a name="ln2065"> </a>
<a name="ln2066">	// extended_file_icb_entry compatability functions</a>
<a name="ln2067">	timestamp&amp; creation_date_and_time() { return _attribute_date_and_time; }</a>
<a name="ln2068">	const timestamp&amp; creation_date_and_time() const { return _attribute_date_and_time; }</a>
<a name="ln2069">	</a>
<a name="ln2070">	</a>
<a name="ln2071">	void set_object_size(uint64 size) { }</a>
<a name="ln2072">	void set_reserved(uint32 reserved) { }</a>
<a name="ln2073">	long_address&amp; stream_directory_icb() { return _dummy_stream_directory_icb; }</a>
<a name="ln2074">	const long_address&amp; stream_directory_icb() const { return _dummy_stream_directory_icb; }</a>
<a name="ln2075"> </a>
<a name="ln2076"> </a>
<a name="ln2077">private:</a>
<a name="ln2078">	static const uint32 _descriptor_length = 176;</a>
<a name="ln2079">	static long_address _dummy_stream_directory_icb;</a>
<a name="ln2080">	uint8* _end() { return reinterpret_cast&lt;uint8*&gt;(this)+_descriptor_length; }</a>
<a name="ln2081">	const uint8* _end() const { return reinterpret_cast&lt;const uint8*&gt;(this)+_descriptor_length; }</a>
<a name="ln2082"> </a>
<a name="ln2083">	descriptor_tag  _tag;</a>
<a name="ln2084">	icb_entry_tag _icb_tag;</a>
<a name="ln2085">	uint32 _uid;</a>
<a name="ln2086">	uint32 _gid;</a>
<a name="ln2087">	/*! \todo List perms in comment and add handy union thingy */</a>
<a name="ln2088">	uint32 _permissions;</a>
<a name="ln2089">	/*! Identifies the number of file identifier descriptors referencing</a>
<a name="ln2090">		this icb.</a>
<a name="ln2091">	*/</a>
<a name="ln2092">	uint16 _file_link_count;</a>
<a name="ln2093">	uint8 _record_format;				//!&lt; To be set to 0 per UDF-2.01 2.3.6.1</a>
<a name="ln2094">	uint8 _record_display_attributes;	//!&lt; To be set to 0 per UDF-2.01 2.3.6.2</a>
<a name="ln2095">	uint8 _record_length;				//!&lt; To be set to 0 per UDF-2.01 2.3.6.3</a>
<a name="ln2096">	uint64 _information_length;</a>
<a name="ln2097">	uint64 _logical_blocks_recorded;		//!&lt; To be 0 for files and dirs with embedded data</a>
<a name="ln2098">	timestamp _access_date_and_time;</a>
<a name="ln2099">	timestamp _modification_date_and_time;</a>
<a name="ln2100">	</a>
<a name="ln2101">	// NOTE: data members following this point in the descriptor are in</a>
<a name="ln2102">	// different locations in extended file entries</a>
<a name="ln2103">	</a>
<a name="ln2104">	timestamp _attribute_date_and_time;</a>
<a name="ln2105">	/*! \brief Initially 1, may be incremented upon user request. */</a>
<a name="ln2106">	uint32 _checkpoint;</a>
<a name="ln2107">	long_address _extended_attribute_icb;</a>
<a name="ln2108">	entity_id _implementation_id;</a>
<a name="ln2109">	/*! \brief The unique id identifying this file entry</a>
<a name="ln2110">	</a>
<a name="ln2111">		The id of the root directory of a file set shall be 0.</a>
<a name="ln2112">		</a>
<a name="ln2113">		\todo Detail the system specific requirements for unique ids from UDF-2.01</a>
<a name="ln2114">	*/</a>
<a name="ln2115">	uint64 _unique_id;</a>
<a name="ln2116">	uint32 _extended_attributes_length;</a>
<a name="ln2117">	uint32 _allocation_descriptors_length;</a>
<a name="ln2118">	</a>
<a name="ln2119">};</a>
<a name="ln2120">		</a>
<a name="ln2121"> </a>
<a name="ln2122">/*! \brief Extended file ICB entry</a>
<a name="ln2123"> </a>
<a name="ln2124">	See also: ECMA-167 4/14.17</a>
<a name="ln2125">	</a>
<a name="ln2126">	\todo Check pointer math.</a>
<a name="ln2127">*/</a>
<a name="ln2128">struct extended_file_icb_entry {</a>
<a name="ln2129">	void dump() const;</a>
<a name="ln2130">	uint32 descriptor_size() const { return sizeof(*this)+extended_attributes_length()</a>
<a name="ln2131">	                                 +allocation_descriptors_length(); }</a>
<a name="ln2132">	const char* descriptor_name() const { return &quot;extended_file_icb_entry&quot;; }</a>
<a name="ln2133"> </a>
<a name="ln2134">	// get functions</a>
<a name="ln2135">	descriptor_tag &amp; tag() { return _tag; }</a>
<a name="ln2136">	const descriptor_tag &amp; tag() const { return _tag; }</a>
<a name="ln2137">	</a>
<a name="ln2138">	icb_entry_tag&amp; icb_tag() { return _icb_tag; }</a>
<a name="ln2139">	const icb_entry_tag&amp; icb_tag() const { return _icb_tag; }</a>
<a name="ln2140">	</a>
<a name="ln2141">	uint32 uid() const { return B_LENDIAN_TO_HOST_INT32(_uid); }</a>
<a name="ln2142">	uint32 gid() const { return B_LENDIAN_TO_HOST_INT32(_gid); }</a>
<a name="ln2143">	uint32 permissions() const { return B_LENDIAN_TO_HOST_INT32(_permissions); }</a>
<a name="ln2144">	uint16 file_link_count() const { return B_LENDIAN_TO_HOST_INT16(_file_link_count); }</a>
<a name="ln2145">	uint8 record_format() const { return _record_format; }</a>
<a name="ln2146">	uint8 record_display_attributes() const { return _record_display_attributes; }</a>
<a name="ln2147">	uint32 record_length() const { return _record_length; }</a>
<a name="ln2148">	uint64 information_length() const { return B_LENDIAN_TO_HOST_INT64(_information_length); }</a>
<a name="ln2149">	uint64 object_size() const { return B_LENDIAN_TO_HOST_INT64(_object_size); }</a>
<a name="ln2150">	uint64 logical_blocks_recorded() const { return B_LENDIAN_TO_HOST_INT64(_logical_blocks_recorded); }</a>
<a name="ln2151"> </a>
<a name="ln2152">	timestamp&amp; access_date_and_time() { return _access_date_and_time; }</a>
<a name="ln2153">	const timestamp&amp; access_date_and_time() const { return _access_date_and_time; }</a>
<a name="ln2154"> </a>
<a name="ln2155">	timestamp&amp; modification_date_and_time() { return _modification_date_and_time; }</a>
<a name="ln2156">	const timestamp&amp; modification_date_and_time() const { return _modification_date_and_time; }</a>
<a name="ln2157"> </a>
<a name="ln2158">	timestamp&amp; creation_date_and_time() { return _creation_date_and_time; }</a>
<a name="ln2159">	const timestamp&amp; creation_date_and_time() const { return _creation_date_and_time; }</a>
<a name="ln2160"> </a>
<a name="ln2161">	timestamp&amp; attribute_date_and_time() { return _attribute_date_and_time; }</a>
<a name="ln2162">	const timestamp&amp; attribute_date_and_time() const { return _attribute_date_and_time; }</a>
<a name="ln2163"> </a>
<a name="ln2164">	uint32 checkpoint() const { return B_LENDIAN_TO_HOST_INT32(_checkpoint); }</a>
<a name="ln2165"> </a>
<a name="ln2166">	long_address&amp; extended_attribute_icb() { return _extended_attribute_icb; }</a>
<a name="ln2167">	const long_address&amp; extended_attribute_icb() const { return _extended_attribute_icb; }</a>
<a name="ln2168"> </a>
<a name="ln2169">	long_address&amp; stream_directory_icb() { return _stream_directory_icb; }</a>
<a name="ln2170">	const long_address&amp; stream_directory_icb() const { return _stream_directory_icb; }</a>
<a name="ln2171"> </a>
<a name="ln2172">	entity_id&amp; implementation_id() { return _implementation_id; }</a>
<a name="ln2173">	const entity_id&amp; implementation_id() const { return _implementation_id; }</a>
<a name="ln2174"> </a>
<a name="ln2175">	uint64 unique_id() const { return B_LENDIAN_TO_HOST_INT64(_unique_id); }</a>
<a name="ln2176">	uint32 extended_attributes_length() const { return B_LENDIAN_TO_HOST_INT32(_extended_attributes_length); }</a>
<a name="ln2177">	uint32 allocation_descriptors_length() const { return B_LENDIAN_TO_HOST_INT32(_allocation_descriptors_length); }</a>
<a name="ln2178"> </a>
<a name="ln2179">	uint8* extended_attributes() { return _end(); }</a>
<a name="ln2180">	const uint8* extended_attributes() const { return _end(); }</a>
<a name="ln2181">	uint8* allocation_descriptors() { return _end()+extended_attributes_length(); }</a>
<a name="ln2182">	const uint8* allocation_descriptors() const { return _end()+extended_attributes_length(); }</a>
<a name="ln2183">	</a>
<a name="ln2184">	// set functions</a>
<a name="ln2185">	void set_uid(uint32 uid) { _uid = B_HOST_TO_LENDIAN_INT32(uid); }</a>
<a name="ln2186">	void set_gid(uint32 gid) { _gid = B_HOST_TO_LENDIAN_INT32(gid); }</a>
<a name="ln2187">	void set_permissions(uint32 permissions) { _permissions = B_HOST_TO_LENDIAN_INT32(permissions); }</a>
<a name="ln2188"> </a>
<a name="ln2189">	void set_file_link_count(uint16 count) { _file_link_count = B_HOST_TO_LENDIAN_INT16(count); }</a>
<a name="ln2190">	void set_record_format(uint8 format) { _record_format = format; }</a>
<a name="ln2191">	void set_record_display_attributes(uint8 attributes) { _record_display_attributes = attributes; }</a>
<a name="ln2192">	void set_record_length(uint32 length) { _record_length = B_HOST_TO_LENDIAN_INT32(length); }</a>
<a name="ln2193"> </a>
<a name="ln2194">	void set_information_length(uint64 length) { _information_length = B_HOST_TO_LENDIAN_INT64(length); }</a>
<a name="ln2195">	void set_object_size(uint64 size) { _object_size = B_HOST_TO_LENDIAN_INT64(size); }</a>
<a name="ln2196">	void set_logical_blocks_recorded(uint64 blocks) { _logical_blocks_recorded = B_HOST_TO_LENDIAN_INT64(blocks); }</a>
<a name="ln2197"> </a>
<a name="ln2198">	void set_checkpoint(uint32 checkpoint) { _checkpoint = B_HOST_TO_LENDIAN_INT32(checkpoint); }</a>
<a name="ln2199">	void set_reserved(uint32 reserved) { _reserved = B_HOST_TO_LENDIAN_INT32(reserved); }</a>
<a name="ln2200"> </a>
<a name="ln2201">	void set_unique_id(uint64 id) { _unique_id = B_HOST_TO_LENDIAN_INT64(id); }</a>
<a name="ln2202"> </a>
<a name="ln2203">	void set_extended_attributes_length(uint32 length) { _extended_attributes_length = B_HOST_TO_LENDIAN_INT32(length); }</a>
<a name="ln2204">	void set_allocation_descriptors_length(uint32 length) { _allocation_descriptors_length = B_HOST_TO_LENDIAN_INT32(length); }</a>
<a name="ln2205"> </a>
<a name="ln2206">private:</a>
<a name="ln2207">	static const uint32 _descriptor_length = 216;</a>
<a name="ln2208">	uint8* _end() { return reinterpret_cast&lt;uint8*&gt;(this)+_descriptor_length; }</a>
<a name="ln2209">	const uint8* _end() const { return reinterpret_cast&lt;const uint8*&gt;(this)+_descriptor_length; }</a>
<a name="ln2210"> </a>
<a name="ln2211">	descriptor_tag  _tag;</a>
<a name="ln2212">	icb_entry_tag _icb_tag;</a>
<a name="ln2213">	uint32 _uid;</a>
<a name="ln2214">	uint32 _gid;</a>
<a name="ln2215">	/*! \todo List perms in comment and add handy union thingy */</a>
<a name="ln2216">	uint32 _permissions;</a>
<a name="ln2217">	/*! Identifies the number of file identifier descriptors referencing</a>
<a name="ln2218">		this icb.</a>
<a name="ln2219">	*/</a>
<a name="ln2220">	uint16 _file_link_count;</a>
<a name="ln2221">	uint8 _record_format;				//!&lt; To be set to 0 per UDF-2.01 2.3.6.1</a>
<a name="ln2222">	uint8 _record_display_attributes;	//!&lt; To be set to 0 per UDF-2.01 2.3.6.2</a>
<a name="ln2223">	uint32 _record_length;				//!&lt; To be set to 0 per UDF-2.01 2.3.6.3</a>
<a name="ln2224">	uint64 _information_length;</a>
<a name="ln2225">	uint64 _object_size;</a>
<a name="ln2226">	uint64 _logical_blocks_recorded;		//!&lt; To be 0 for files and dirs with embedded data</a>
<a name="ln2227">	timestamp _access_date_and_time;</a>
<a name="ln2228">	timestamp _modification_date_and_time;</a>
<a name="ln2229">	timestamp _creation_date_and_time;	// &lt;== EXTENDED FILE ENTRY ONLY</a>
<a name="ln2230">	timestamp _attribute_date_and_time;</a>
<a name="ln2231">	/*! \brief Initially 1, may be incremented upon user request. */</a>
<a name="ln2232">	uint32 _checkpoint;</a>
<a name="ln2233">	uint32 _reserved;	// &lt;== EXTENDED FILE ENTRY ONLY</a>
<a name="ln2234">	long_address _extended_attribute_icb;</a>
<a name="ln2235">	long_address _stream_directory_icb;	// &lt;== EXTENDED FILE ENTRY ONLY</a>
<a name="ln2236">	entity_id _implementation_id;</a>
<a name="ln2237">	/*! \brief The unique id identifying this file entry</a>
<a name="ln2238">	</a>
<a name="ln2239">		The id of the root directory of a file set shall be 0.</a>
<a name="ln2240">		</a>
<a name="ln2241">		\todo Detail the system specific requirements for unique ids from UDF-2.01 3.2.1.1</a>
<a name="ln2242">	*/</a>
<a name="ln2243">	uint64 _unique_id;</a>
<a name="ln2244">	uint32 _extended_attributes_length;</a>
<a name="ln2245">	uint32 _allocation_descriptors_length;</a>
<a name="ln2246"> </a>
<a name="ln2247">};</a>
<a name="ln2248">		</a>
<a name="ln2249"> </a>
<a name="ln2250">#endif	// _UDF_DISK_STRUCTURES_H</a>
<a name="ln2251"> </a>

</code></pre>
<div class="balloon" rel="1408"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: _tag.</p></div>
<div class="balloon" rel="829"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: _tag.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
