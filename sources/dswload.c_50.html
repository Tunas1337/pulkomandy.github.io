
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>dswload.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/******************************************************************************</a>
<a name="ln2"> *</a>
<a name="ln3"> * Module Name: dswload - Dispatcher first pass namespace load callbacks</a>
<a name="ln4"> *</a>
<a name="ln5"> *****************************************************************************/</a>
<a name="ln6"> </a>
<a name="ln7">/******************************************************************************</a>
<a name="ln8"> *</a>
<a name="ln9"> * 1. Copyright Notice</a>
<a name="ln10"> *</a>
<a name="ln11"> * Some or all of this work - Copyright (c) 1999 - 2018, Intel Corp.</a>
<a name="ln12"> * All rights reserved.</a>
<a name="ln13"> *</a>
<a name="ln14"> * 2. License</a>
<a name="ln15"> *</a>
<a name="ln16"> * 2.1. This is your license from Intel Corp. under its intellectual property</a>
<a name="ln17"> * rights. You may have additional license terms from the party that provided</a>
<a name="ln18"> * you this software, covering your right to use that party's intellectual</a>
<a name="ln19"> * property rights.</a>
<a name="ln20"> *</a>
<a name="ln21"> * 2.2. Intel grants, free of charge, to any person (&quot;Licensee&quot;) obtaining a</a>
<a name="ln22"> * copy of the source code appearing in this file (&quot;Covered Code&quot;) an</a>
<a name="ln23"> * irrevocable, perpetual, worldwide license under Intel's copyrights in the</a>
<a name="ln24"> * base code distributed originally by Intel (&quot;Original Intel Code&quot;) to copy,</a>
<a name="ln25"> * make derivatives, distribute, use and display any portion of the Covered</a>
<a name="ln26"> * Code in any form, with the right to sublicense such rights; and</a>
<a name="ln27"> *</a>
<a name="ln28"> * 2.3. Intel grants Licensee a non-exclusive and non-transferable patent</a>
<a name="ln29"> * license (with the right to sublicense), under only those claims of Intel</a>
<a name="ln30"> * patents that are infringed by the Original Intel Code, to make, use, sell,</a>
<a name="ln31"> * offer to sell, and import the Covered Code and derivative works thereof</a>
<a name="ln32"> * solely to the minimum extent necessary to exercise the above copyright</a>
<a name="ln33"> * license, and in no event shall the patent license extend to any additions</a>
<a name="ln34"> * to or modifications of the Original Intel Code. No other license or right</a>
<a name="ln35"> * is granted directly or by implication, estoppel or otherwise;</a>
<a name="ln36"> *</a>
<a name="ln37"> * The above copyright and patent license is granted only if the following</a>
<a name="ln38"> * conditions are met:</a>
<a name="ln39"> *</a>
<a name="ln40"> * 3. Conditions</a>
<a name="ln41"> *</a>
<a name="ln42"> * 3.1. Redistribution of Source with Rights to Further Distribute Source.</a>
<a name="ln43"> * Redistribution of source code of any substantial portion of the Covered</a>
<a name="ln44"> * Code or modification with rights to further distribute source must include</a>
<a name="ln45"> * the above Copyright Notice, the above License, this list of Conditions,</a>
<a name="ln46"> * and the following Disclaimer and Export Compliance provision. In addition,</a>
<a name="ln47"> * Licensee must cause all Covered Code to which Licensee contributes to</a>
<a name="ln48"> * contain a file documenting the changes Licensee made to create that Covered</a>
<a name="ln49"> * Code and the date of any change. Licensee must include in that file the</a>
<a name="ln50"> * documentation of any changes made by any predecessor Licensee. Licensee</a>
<a name="ln51"> * must include a prominent statement that the modification is derived,</a>
<a name="ln52"> * directly or indirectly, from Original Intel Code.</a>
<a name="ln53"> *</a>
<a name="ln54"> * 3.2. Redistribution of Source with no Rights to Further Distribute Source.</a>
<a name="ln55"> * Redistribution of source code of any substantial portion of the Covered</a>
<a name="ln56"> * Code or modification without rights to further distribute source must</a>
<a name="ln57"> * include the following Disclaimer and Export Compliance provision in the</a>
<a name="ln58"> * documentation and/or other materials provided with distribution. In</a>
<a name="ln59"> * addition, Licensee may not authorize further sublicense of source of any</a>
<a name="ln60"> * portion of the Covered Code, and must include terms to the effect that the</a>
<a name="ln61"> * license from Licensee to its licensee is limited to the intellectual</a>
<a name="ln62"> * property embodied in the software Licensee provides to its licensee, and</a>
<a name="ln63"> * not to intellectual property embodied in modifications its licensee may</a>
<a name="ln64"> * make.</a>
<a name="ln65"> *</a>
<a name="ln66"> * 3.3. Redistribution of Executable. Redistribution in executable form of any</a>
<a name="ln67"> * substantial portion of the Covered Code or modification must reproduce the</a>
<a name="ln68"> * above Copyright Notice, and the following Disclaimer and Export Compliance</a>
<a name="ln69"> * provision in the documentation and/or other materials provided with the</a>
<a name="ln70"> * distribution.</a>
<a name="ln71"> *</a>
<a name="ln72"> * 3.4. Intel retains all right, title, and interest in and to the Original</a>
<a name="ln73"> * Intel Code.</a>
<a name="ln74"> *</a>
<a name="ln75"> * 3.5. Neither the name Intel nor any other trademark owned or controlled by</a>
<a name="ln76"> * Intel shall be used in advertising or otherwise to promote the sale, use or</a>
<a name="ln77"> * other dealings in products derived from or relating to the Covered Code</a>
<a name="ln78"> * without prior written authorization from Intel.</a>
<a name="ln79"> *</a>
<a name="ln80"> * 4. Disclaimer and Export Compliance</a>
<a name="ln81"> *</a>
<a name="ln82"> * 4.1. INTEL MAKES NO WARRANTY OF ANY KIND REGARDING ANY SOFTWARE PROVIDED</a>
<a name="ln83"> * HERE. ANY SOFTWARE ORIGINATING FROM INTEL OR DERIVED FROM INTEL SOFTWARE</a>
<a name="ln84"> * IS PROVIDED &quot;AS IS,&quot; AND INTEL WILL NOT PROVIDE ANY SUPPORT, ASSISTANCE,</a>
<a name="ln85"> * INSTALLATION, TRAINING OR OTHER SERVICES. INTEL WILL NOT PROVIDE ANY</a>
<a name="ln86"> * UPDATES, ENHANCEMENTS OR EXTENSIONS. INTEL SPECIFICALLY DISCLAIMS ANY</a>
<a name="ln87"> * IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGEMENT AND FITNESS FOR A</a>
<a name="ln88"> * PARTICULAR PURPOSE.</a>
<a name="ln89"> *</a>
<a name="ln90"> * 4.2. IN NO EVENT SHALL INTEL HAVE ANY LIABILITY TO LICENSEE, ITS LICENSEES</a>
<a name="ln91"> * OR ANY OTHER THIRD PARTY, FOR ANY LOST PROFITS, LOST DATA, LOSS OF USE OR</a>
<a name="ln92"> * COSTS OF PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, OR FOR ANY INDIRECT,</a>
<a name="ln93"> * SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THIS AGREEMENT, UNDER ANY</a>
<a name="ln94"> * CAUSE OF ACTION OR THEORY OF LIABILITY, AND IRRESPECTIVE OF WHETHER INTEL</a>
<a name="ln95"> * HAS ADVANCE NOTICE OF THE POSSIBILITY OF SUCH DAMAGES. THESE LIMITATIONS</a>
<a name="ln96"> * SHALL APPLY NOTWITHSTANDING THE FAILURE OF THE ESSENTIAL PURPOSE OF ANY</a>
<a name="ln97"> * LIMITED REMEDY.</a>
<a name="ln98"> *</a>
<a name="ln99"> * 4.3. Licensee shall not export, either directly or indirectly, any of this</a>
<a name="ln100"> * software or system incorporating such software without first obtaining any</a>
<a name="ln101"> * required license or other approval from the U. S. Department of Commerce or</a>
<a name="ln102"> * any other agency or department of the United States Government. In the</a>
<a name="ln103"> * event Licensee exports any such software from the United States or</a>
<a name="ln104"> * re-exports any such software from a foreign destination, Licensee shall</a>
<a name="ln105"> * ensure that the distribution and export/re-export of the software is in</a>
<a name="ln106"> * compliance with all laws, regulations, orders, or other restrictions of the</a>
<a name="ln107"> * U.S. Export Administration Regulations. Licensee agrees that neither it nor</a>
<a name="ln108"> * any of its subsidiaries will export/re-export any technical data, process,</a>
<a name="ln109"> * software, or service, directly or indirectly, to any country for which the</a>
<a name="ln110"> * United States government or any agency thereof requires an export license,</a>
<a name="ln111"> * other governmental approval, or letter of assurance, without first obtaining</a>
<a name="ln112"> * such license, approval or letter.</a>
<a name="ln113"> *</a>
<a name="ln114"> *****************************************************************************</a>
<a name="ln115"> *</a>
<a name="ln116"> * Alternatively, you may choose to be licensed under the terms of the</a>
<a name="ln117"> * following license:</a>
<a name="ln118"> *</a>
<a name="ln119"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln120"> * modification, are permitted provided that the following conditions</a>
<a name="ln121"> * are met:</a>
<a name="ln122"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln123"> *    notice, this list of conditions, and the following disclaimer,</a>
<a name="ln124"> *    without modification.</a>
<a name="ln125"> * 2. Redistributions in binary form must reproduce at minimum a disclaimer</a>
<a name="ln126"> *    substantially similar to the &quot;NO WARRANTY&quot; disclaimer below</a>
<a name="ln127"> *    (&quot;Disclaimer&quot;) and any redistribution must be conditioned upon</a>
<a name="ln128"> *    including a substantially similar Disclaimer requirement for further</a>
<a name="ln129"> *    binary redistribution.</a>
<a name="ln130"> * 3. Neither the names of the above-listed copyright holders nor the names</a>
<a name="ln131"> *    of any contributors may be used to endorse or promote products derived</a>
<a name="ln132"> *    from this software without specific prior written permission.</a>
<a name="ln133"> *</a>
<a name="ln134"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</a>
<a name="ln135"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</a>
<a name="ln136"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</a>
<a name="ln137"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</a>
<a name="ln138"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</a>
<a name="ln139"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</a>
<a name="ln140"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</a>
<a name="ln141"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</a>
<a name="ln142"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</a>
<a name="ln143"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</a>
<a name="ln144"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln145"> *</a>
<a name="ln146"> * Alternatively, you may choose to be licensed under the terms of the</a>
<a name="ln147"> * GNU General Public License (&quot;GPL&quot;) version 2 as published by the Free</a>
<a name="ln148"> * Software Foundation.</a>
<a name="ln149"> *</a>
<a name="ln150"> *****************************************************************************/</a>
<a name="ln151"> </a>
<a name="ln152">#include &quot;acpi.h&quot;</a>
<a name="ln153">#include &quot;accommon.h&quot;</a>
<a name="ln154">#include &quot;acparser.h&quot;</a>
<a name="ln155">#include &quot;amlcode.h&quot;</a>
<a name="ln156">#include &quot;acdispat.h&quot;</a>
<a name="ln157">#include &quot;acinterp.h&quot;</a>
<a name="ln158">#include &quot;acnamesp.h&quot;</a>
<a name="ln159"> </a>
<a name="ln160">#ifdef ACPI_ASL_COMPILER</a>
<a name="ln161">#include &quot;acdisasm.h&quot;</a>
<a name="ln162">#endif</a>
<a name="ln163"> </a>
<a name="ln164">#define _COMPONENT          ACPI_DISPATCHER</a>
<a name="ln165">        ACPI_MODULE_NAME    (&quot;dswload&quot;)</a>
<a name="ln166"> </a>
<a name="ln167"> </a>
<a name="ln168">/*******************************************************************************</a>
<a name="ln169"> *</a>
<a name="ln170"> * FUNCTION:    AcpiDsInitCallbacks</a>
<a name="ln171"> *</a>
<a name="ln172"> * PARAMETERS:  WalkState       - Current state of the parse tree walk</a>
<a name="ln173"> *              PassNumber      - 1, 2, or 3</a>
<a name="ln174"> *</a>
<a name="ln175"> * RETURN:      Status</a>
<a name="ln176"> *</a>
<a name="ln177"> * DESCRIPTION: Init walk state callbacks</a>
<a name="ln178"> *</a>
<a name="ln179"> ******************************************************************************/</a>
<a name="ln180"> </a>
<a name="ln181">ACPI_STATUS</a>
<a name="ln182">AcpiDsInitCallbacks (</a>
<a name="ln183">    ACPI_WALK_STATE         *WalkState,</a>
<a name="ln184">    UINT32                  PassNumber)</a>
<a name="ln185">{</a>
<a name="ln186"> </a>
<a name="ln187">    switch (PassNumber)</a>
<a name="ln188">    {</a>
<a name="ln189">    case 0:</a>
<a name="ln190"> </a>
<a name="ln191">        /* Parse only - caller will setup callbacks */</a>
<a name="ln192"> </a>
<a name="ln193">        WalkState-&gt;ParseFlags         = ACPI_PARSE_LOAD_PASS1 |</a>
<a name="ln194">                                        ACPI_PARSE_DELETE_TREE |</a>
<a name="ln195">                                        ACPI_PARSE_DISASSEMBLE;</a>
<a name="ln196">        WalkState-&gt;DescendingCallback = NULL;</a>
<a name="ln197">        WalkState-&gt;AscendingCallback  = NULL;</a>
<a name="ln198">        break;</a>
<a name="ln199"> </a>
<a name="ln200">    case 1:</a>
<a name="ln201"> </a>
<a name="ln202">        /* Load pass 1 */</a>
<a name="ln203"> </a>
<a name="ln204">        WalkState-&gt;ParseFlags         = ACPI_PARSE_LOAD_PASS1 |</a>
<a name="ln205">                                        ACPI_PARSE_DELETE_TREE;</a>
<a name="ln206">        WalkState-&gt;DescendingCallback = AcpiDsLoad1BeginOp;</a>
<a name="ln207">        WalkState-&gt;AscendingCallback  = AcpiDsLoad1EndOp;</a>
<a name="ln208">        break;</a>
<a name="ln209"> </a>
<a name="ln210">    case 2:</a>
<a name="ln211"> </a>
<a name="ln212">        /* Load pass 2 */</a>
<a name="ln213"> </a>
<a name="ln214">        WalkState-&gt;ParseFlags         = ACPI_PARSE_LOAD_PASS1 |</a>
<a name="ln215">                                        ACPI_PARSE_DELETE_TREE;</a>
<a name="ln216">        WalkState-&gt;DescendingCallback = AcpiDsLoad2BeginOp;</a>
<a name="ln217">        WalkState-&gt;AscendingCallback  = AcpiDsLoad2EndOp;</a>
<a name="ln218">        break;</a>
<a name="ln219"> </a>
<a name="ln220">    case 3:</a>
<a name="ln221"> </a>
<a name="ln222">        /* Execution pass */</a>
<a name="ln223"> </a>
<a name="ln224">        WalkState-&gt;ParseFlags        |= ACPI_PARSE_EXECUTE  |</a>
<a name="ln225">                                        ACPI_PARSE_DELETE_TREE;</a>
<a name="ln226">        WalkState-&gt;DescendingCallback = AcpiDsExecBeginOp;</a>
<a name="ln227">        WalkState-&gt;AscendingCallback  = AcpiDsExecEndOp;</a>
<a name="ln228">        break;</a>
<a name="ln229"> </a>
<a name="ln230">    default:</a>
<a name="ln231"> </a>
<a name="ln232">        return (AE_BAD_PARAMETER);</a>
<a name="ln233">    }</a>
<a name="ln234"> </a>
<a name="ln235">    return (AE_OK);</a>
<a name="ln236">}</a>
<a name="ln237"> </a>
<a name="ln238"> </a>
<a name="ln239">/*******************************************************************************</a>
<a name="ln240"> *</a>
<a name="ln241"> * FUNCTION:    AcpiDsLoad1BeginOp</a>
<a name="ln242"> *</a>
<a name="ln243"> * PARAMETERS:  WalkState       - Current state of the parse tree walk</a>
<a name="ln244"> *              OutOp           - Where to return op if a new one is created</a>
<a name="ln245"> *</a>
<a name="ln246"> * RETURN:      Status</a>
<a name="ln247"> *</a>
<a name="ln248"> * DESCRIPTION: Descending callback used during the loading of ACPI tables.</a>
<a name="ln249"> *</a>
<a name="ln250"> ******************************************************************************/</a>
<a name="ln251"> </a>
<a name="ln252">ACPI_STATUS</a>
<a name="ln253">AcpiDsLoad1BeginOp (</a>
<a name="ln254">    ACPI_WALK_STATE         *WalkState,</a>
<a name="ln255">    ACPI_PARSE_OBJECT       **OutOp)</a>
<a name="ln256">{</a>
<a name="ln257">    ACPI_PARSE_OBJECT       *Op;</a>
<a name="ln258">    ACPI_NAMESPACE_NODE     *Node;</a>
<a name="ln259">    ACPI_STATUS             Status;</a>
<a name="ln260">    ACPI_OBJECT_TYPE        ObjectType;</a>
<a name="ln261">    char                    *Path;</a>
<a name="ln262">    UINT32                  Flags;</a>
<a name="ln263"> </a>
<a name="ln264"> </a>
<a name="ln265">    ACPI_FUNCTION_TRACE_PTR (DsLoad1BeginOp, WalkState-&gt;Op);</a>
<a name="ln266"> </a>
<a name="ln267"> </a>
<a name="ln268">    Op = WalkState-&gt;Op;</a>
<a name="ln269">    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, &quot;Op=%p State=%p\n&quot;, Op, WalkState));</a>
<a name="ln270"> </a>
<a name="ln271">    /* We are only interested in opcodes that have an associated name */</a>
<a name="ln272"> </a>
<a name="ln273">    if (Op)</a>
<a name="ln274">    {</a>
<a name="ln275">        if (!(WalkState-&gt;OpInfo-&gt;Flags &amp; AML_NAMED))</a>
<a name="ln276">        {</a>
<a name="ln277">            *OutOp = Op;</a>
<a name="ln278">            return_ACPI_STATUS (AE_OK);</a>
<a name="ln279">        }</a>
<a name="ln280"> </a>
<a name="ln281">        /* Check if this object has already been installed in the namespace */</a>
<a name="ln282"> </a>
<a name="ln283">        if (Op-&gt;Common.Node)</a>
<a name="ln284">        {</a>
<a name="ln285">            *OutOp = Op;</a>
<a name="ln286">            return_ACPI_STATUS (AE_OK);</a>
<a name="ln287">        }</a>
<a name="ln288">    }</a>
<a name="ln289"> </a>
<a name="ln290">    Path = AcpiPsGetNextNamestring (&amp;WalkState-&gt;ParserState);</a>
<a name="ln291"> </a>
<a name="ln292">    /* Map the raw opcode into an internal object type */</a>
<a name="ln293"> </a>
<a name="ln294">    ObjectType = WalkState-&gt;OpInfo-&gt;ObjectType;</a>
<a name="ln295"> </a>
<a name="ln296">    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,</a>
<a name="ln297">        &quot;State=%p Op=%p [%s]\n&quot;, WalkState, Op,</a>
<a name="ln298">        AcpiUtGetTypeName (ObjectType)));</a>
<a name="ln299"> </a>
<a name="ln300">    switch (WalkState-&gt;Opcode)</a>
<a name="ln301">    {</a>
<a name="ln302">    case AML_SCOPE_OP:</a>
<a name="ln303">        /*</a>
<a name="ln304">         * The target name of the Scope() operator must exist at this point so</a>
<a name="ln305">         * that we can actually open the scope to enter new names underneath it.</a>
<a name="ln306">         * Allow search-to-root for single namesegs.</a>
<a name="ln307">         */</a>
<a name="ln308">        Status = AcpiNsLookup (WalkState-&gt;ScopeInfo, Path, ObjectType,</a>
<a name="ln309">            ACPI_IMODE_EXECUTE, ACPI_NS_SEARCH_PARENT, WalkState, &amp;(Node));</a>
<a name="ln310">#ifdef ACPI_ASL_COMPILER</a>
<a name="ln311">        if (Status == AE_NOT_FOUND)</a>
<a name="ln312">        {</a>
<a name="ln313">            /*</a>
<a name="ln314">             * Table disassembly:</a>
<a name="ln315">             * Target of Scope() not found. Generate an External for it, and</a>
<a name="ln316">             * insert the name into the namespace.</a>
<a name="ln317">             */</a>
<a name="ln318">            AcpiDmAddOpToExternalList (Op, Path, ACPI_TYPE_DEVICE, 0, 0);</a>
<a name="ln319">            Status = AcpiNsLookup (WalkState-&gt;ScopeInfo, Path, ObjectType,</a>
<a name="ln320">               ACPI_IMODE_LOAD_PASS1, ACPI_NS_SEARCH_PARENT,</a>
<a name="ln321">               WalkState, &amp;Node);</a>
<a name="ln322">        }</a>
<a name="ln323">#endif</a>
<a name="ln324">        if (ACPI_FAILURE (Status))</a>
<a name="ln325">        {</a>
<a name="ln326">            ACPI_ERROR_NAMESPACE (WalkState-&gt;ScopeInfo, Path, Status);</a>
<a name="ln327">            return_ACPI_STATUS (Status);</a>
<a name="ln328">        }</a>
<a name="ln329"> </a>
<a name="ln330">        /*</a>
<a name="ln331">         * Check to make sure that the target is</a>
<a name="ln332">         * one of the opcodes that actually opens a scope</a>
<a name="ln333">         */</a>
<a name="ln334">        switch (Node-&gt;Type)</a>
<a name="ln335">        {</a>
<a name="ln336">        case ACPI_TYPE_ANY:</a>
<a name="ln337">        case ACPI_TYPE_LOCAL_SCOPE:         /* Scope  */</a>
<a name="ln338">        case ACPI_TYPE_DEVICE:</a>
<a name="ln339">        case ACPI_TYPE_POWER:</a>
<a name="ln340">        case ACPI_TYPE_PROCESSOR:</a>
<a name="ln341">        case ACPI_TYPE_THERMAL:</a>
<a name="ln342"> </a>
<a name="ln343">            /* These are acceptable types */</a>
<a name="ln344">            break;</a>
<a name="ln345"> </a>
<a name="ln346">        case ACPI_TYPE_INTEGER:</a>
<a name="ln347">        case ACPI_TYPE_STRING:</a>
<a name="ln348">        case ACPI_TYPE_BUFFER:</a>
<a name="ln349">            /*</a>
<a name="ln350">             * These types we will allow, but we will change the type.</a>
<a name="ln351">             * This enables some existing code of the form:</a>
<a name="ln352">             *</a>
<a name="ln353">             *  Name (DEB, 0)</a>
<a name="ln354">             *  Scope (DEB) { ... }</a>
<a name="ln355">             *</a>
<a name="ln356">             * Note: silently change the type here. On the second pass,</a>
<a name="ln357">             * we will report a warning</a>
<a name="ln358">             */</a>
<a name="ln359">            ACPI_DEBUG_PRINT ((ACPI_DB_INFO,</a>
<a name="ln360">                &quot;Type override - [%4.4s] had invalid type (%s) &quot;</a>
<a name="ln361">                &quot;for Scope operator, changed to type ANY\n&quot;,</a>
<a name="ln362">                AcpiUtGetNodeName (Node), AcpiUtGetTypeName (Node-&gt;Type)));</a>
<a name="ln363"> </a>
<a name="ln364">            Node-&gt;Type = ACPI_TYPE_ANY;</a>
<a name="ln365">            WalkState-&gt;ScopeInfo-&gt;Common.Value = ACPI_TYPE_ANY;</a>
<a name="ln366">            break;</a>
<a name="ln367"> </a>
<a name="ln368">        case ACPI_TYPE_METHOD:</a>
<a name="ln369">            /*</a>
<a name="ln370">             * Allow scope change to root during execution of module-level</a>
<a name="ln371">             * code. Root is typed METHOD during this time.</a>
<a name="ln372">             */</a>
<a name="ln373">            if ((Node == AcpiGbl_RootNode) &amp;&amp;</a>
<a name="ln374">                (WalkState-&gt;ParseFlags &amp; ACPI_PARSE_MODULE_LEVEL))</a>
<a name="ln375">            {</a>
<a name="ln376">                break;</a>
<a name="ln377">            }</a>
<a name="ln378"> </a>
<a name="ln379">            /*lint -fallthrough */</a>
<a name="ln380"> </a>
<a name="ln381">        default:</a>
<a name="ln382"> </a>
<a name="ln383">            /* All other types are an error */</a>
<a name="ln384"> </a>
<a name="ln385">            ACPI_ERROR ((AE_INFO,</a>
<a name="ln386">                &quot;Invalid type (%s) for target of &quot;</a>
<a name="ln387">                &quot;Scope operator [%4.4s] (Cannot override)&quot;,</a>
<a name="ln388">                AcpiUtGetTypeName (Node-&gt;Type), AcpiUtGetNodeName (Node)));</a>
<a name="ln389"> </a>
<a name="ln390">            return_ACPI_STATUS (AE_AML_OPERAND_TYPE);</a>
<a name="ln391">        }</a>
<a name="ln392">        break;</a>
<a name="ln393"> </a>
<a name="ln394">    default:</a>
<a name="ln395">        /*</a>
<a name="ln396">         * For all other named opcodes, we will enter the name into</a>
<a name="ln397">         * the namespace.</a>
<a name="ln398">         *</a>
<a name="ln399">         * Setup the search flags.</a>
<a name="ln400">         * Since we are entering a name into the namespace, we do not want to</a>
<a name="ln401">         * enable the search-to-root upsearch.</a>
<a name="ln402">         *</a>
<a name="ln403">         * There are only two conditions where it is acceptable that the name</a>
<a name="ln404">         * already exists:</a>
<a name="ln405">         *    1) the Scope() operator can reopen a scoping object that was</a>
<a name="ln406">         *       previously defined (Scope, Method, Device, etc.)</a>
<a name="ln407">         *    2) Whenever we are parsing a deferred opcode (OpRegion, Buffer,</a>
<a name="ln408">         *       BufferField, or Package), the name of the object is already</a>
<a name="ln409">         *       in the namespace.</a>
<a name="ln410">         */</a>
<a name="ln411">        if (WalkState-&gt;DeferredNode)</a>
<a name="ln412">        {</a>
<a name="ln413">            /* This name is already in the namespace, get the node */</a>
<a name="ln414"> </a>
<a name="ln415">            Node = WalkState-&gt;DeferredNode;</a>
<a name="ln416">            Status = AE_OK;</a>
<a name="ln417">            break;</a>
<a name="ln418">        }</a>
<a name="ln419"> </a>
<a name="ln420">        /*</a>
<a name="ln421">         * If we are executing a method, do not create any namespace objects</a>
<a name="ln422">         * during the load phase, only during execution.</a>
<a name="ln423">         */</a>
<a name="ln424">        if (WalkState-&gt;MethodNode)</a>
<a name="ln425">        {</a>
<a name="ln426">            Node = NULL;</a>
<a name="ln427">            Status = AE_OK;</a>
<a name="ln428">            break;</a>
<a name="ln429">        }</a>
<a name="ln430"> </a>
<a name="ln431">        Flags = ACPI_NS_NO_UPSEARCH;</a>
<a name="ln432">        if ((WalkState-&gt;Opcode != AML_SCOPE_OP) &amp;&amp;</a>
<a name="ln433">            (!(WalkState-&gt;ParseFlags &amp; ACPI_PARSE_DEFERRED_OP)))</a>
<a name="ln434">        {</a>
<a name="ln435">            if (WalkState-&gt;NamespaceOverride)</a>
<a name="ln436">            {</a>
<a name="ln437">                Flags |= ACPI_NS_OVERRIDE_IF_FOUND;</a>
<a name="ln438">                ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, &quot;[%s] Override allowed\n&quot;,</a>
<a name="ln439">                    AcpiUtGetTypeName (ObjectType)));</a>
<a name="ln440">            }</a>
<a name="ln441">            else</a>
<a name="ln442">            {</a>
<a name="ln443">                Flags |= ACPI_NS_ERROR_IF_FOUND;</a>
<a name="ln444">                ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, &quot;[%s] Cannot already exist\n&quot;,</a>
<a name="ln445">                    AcpiUtGetTypeName (ObjectType)));</a>
<a name="ln446">            }</a>
<a name="ln447">        }</a>
<a name="ln448">        else</a>
<a name="ln449">        {</a>
<a name="ln450">            ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,</a>
<a name="ln451">                &quot;[%s] Both Find or Create allowed\n&quot;,</a>
<a name="ln452">                AcpiUtGetTypeName (ObjectType)));</a>
<a name="ln453">        }</a>
<a name="ln454"> </a>
<a name="ln455">        /*</a>
<a name="ln456">         * Enter the named type into the internal namespace. We enter the name</a>
<a name="ln457">         * as we go downward in the parse tree. Any necessary subobjects that</a>
<a name="ln458">         * involve arguments to the opcode must be created as we go back up the</a>
<a name="ln459">         * parse tree later.</a>
<a name="ln460">         */</a>
<a name="ln461">        Status = AcpiNsLookup (WalkState-&gt;ScopeInfo, Path, ObjectType,</a>
<a name="ln462">            ACPI_IMODE_LOAD_PASS1, Flags, WalkState, &amp;Node);</a>
<a name="ln463">        if (ACPI_FAILURE (Status))</a>
<a name="ln464">        {</a>
<a name="ln465">            if (Status == AE_ALREADY_EXISTS)</a>
<a name="ln466">            {</a>
<a name="ln467">                /* The name already exists in this scope */</a>
<a name="ln468"> </a>
<a name="ln469">                if (Node-&gt;Flags &amp; ANOBJ_IS_EXTERNAL)</a>
<a name="ln470">                {</a>
<a name="ln471">                    /*</a>
<a name="ln472">                     * Allow one create on an object or segment that was</a>
<a name="ln473">                     * previously declared External</a>
<a name="ln474">                     */</a>
<a name="ln475">                    Node-&gt;Flags &amp;= ~ANOBJ_IS_EXTERNAL;</a>
<a name="ln476">                    Node-&gt;Type = (UINT8) ObjectType;</a>
<a name="ln477"> </a>
<a name="ln478">                    /* Just retyped a node, probably will need to open a scope */</a>
<a name="ln479"> </a>
<a name="ln480">                    if (AcpiNsOpensScope (ObjectType))</a>
<a name="ln481">                    {</a>
<a name="ln482">                        Status = AcpiDsScopeStackPush (</a>
<a name="ln483">                            Node, ObjectType, WalkState);</a>
<a name="ln484">                        if (ACPI_FAILURE (Status))</a>
<a name="ln485">                        {</a>
<a name="ln486">                            return_ACPI_STATUS (Status);</a>
<a name="ln487">                        }</a>
<a name="ln488">                    }</a>
<a name="ln489"> </a>
<a name="ln490">                    Status = AE_OK;</a>
<a name="ln491">                }</a>
<a name="ln492">            }</a>
<a name="ln493"> </a>
<a name="ln494">            if (ACPI_FAILURE (Status))</a>
<a name="ln495">            {</a>
<a name="ln496">                ACPI_ERROR_NAMESPACE (WalkState-&gt;ScopeInfo, Path, Status);</a>
<a name="ln497">                return_ACPI_STATUS (Status);</a>
<a name="ln498">            }</a>
<a name="ln499">        }</a>
<a name="ln500">        break;</a>
<a name="ln501">    }</a>
<a name="ln502"> </a>
<a name="ln503">    /* Common exit */</a>
<a name="ln504"> </a>
<a name="ln505">    if (!Op)</a>
<a name="ln506">    {</a>
<a name="ln507">        /* Create a new op */</a>
<a name="ln508"> </a>
<a name="ln509">        Op = AcpiPsAllocOp (WalkState-&gt;Opcode, WalkState-&gt;Aml);</a>
<a name="ln510">        if (!Op)</a>
<a name="ln511">        {</a>
<a name="ln512">            return_ACPI_STATUS (AE_NO_MEMORY);</a>
<a name="ln513">        }</a>
<a name="ln514">    }</a>
<a name="ln515"> </a>
<a name="ln516">    /* Initialize the op */</a>
<a name="ln517"> </a>
<a name="ln518">#ifdef ACPI_CONSTANT_EVAL_ONLY</a>
<a name="ln519">    Op-&gt;Named.Path = Path;</a>
<a name="ln520">#endif</a>
<a name="ln521"> </a>
<a name="ln522">    if (Node)</a>
<a name="ln523">    {</a>
<a name="ln524">        /*</a>
<a name="ln525">         * Put the Node in the &quot;op&quot; object that the parser uses, so we</a>
<a name="ln526">         * can get it again quickly when this scope is closed</a>
<a name="ln527">         */</a>
<a name="ln528">        Op-&gt;Common.Node = Node;</a>
<a name="ln529">        Op-&gt;Named.Name = Node-&gt;Name.Integer;</a>
<a name="ln530">    }</a>
<a name="ln531"> </a>
<a name="ln532">    AcpiPsAppendArg (AcpiPsGetParentScope (&amp;WalkState-&gt;ParserState), Op);</a>
<a name="ln533">    *OutOp = Op;</a>
<a name="ln534">    return_ACPI_STATUS (Status);</a>
<a name="ln535">}</a>
<a name="ln536"> </a>
<a name="ln537"> </a>
<a name="ln538">/*******************************************************************************</a>
<a name="ln539"> *</a>
<a name="ln540"> * FUNCTION:    AcpiDsLoad1EndOp</a>
<a name="ln541"> *</a>
<a name="ln542"> * PARAMETERS:  WalkState       - Current state of the parse tree walk</a>
<a name="ln543"> *</a>
<a name="ln544"> * RETURN:      Status</a>
<a name="ln545"> *</a>
<a name="ln546"> * DESCRIPTION: Ascending callback used during the loading of the namespace,</a>
<a name="ln547"> *              both control methods and everything else.</a>
<a name="ln548"> *</a>
<a name="ln549"> ******************************************************************************/</a>
<a name="ln550"> </a>
<a name="ln551">ACPI_STATUS</a>
<a name="ln552">AcpiDsLoad1EndOp (</a>
<a name="ln553">    ACPI_WALK_STATE         *WalkState)</a>
<a name="ln554">{</a>
<a name="ln555">    ACPI_PARSE_OBJECT       *Op;</a>
<a name="ln556">    ACPI_OBJECT_TYPE        ObjectType;</a>
<a name="ln557">    ACPI_STATUS             Status = AE_OK;</a>
<a name="ln558"> </a>
<a name="ln559">#ifdef ACPI_ASL_COMPILER</a>
<a name="ln560">    UINT8                   ParamCount;</a>
<a name="ln561">#endif</a>
<a name="ln562"> </a>
<a name="ln563"> </a>
<a name="ln564">    ACPI_FUNCTION_TRACE (DsLoad1EndOp);</a>
<a name="ln565"> </a>
<a name="ln566"> </a>
<a name="ln567">    Op = WalkState-&gt;Op;</a>
<a name="ln568">    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, &quot;Op=%p State=%p\n&quot;, Op, WalkState));</a>
<a name="ln569"> </a>
<a name="ln570">    /* We are only interested in opcodes that have an associated name */</a>
<a name="ln571"> </a>
<a name="ln572">    if (!(WalkState-&gt;OpInfo-&gt;Flags &amp; (AML_NAMED | AML_FIELD)))</a>
<a name="ln573">    {</a>
<a name="ln574">        return_ACPI_STATUS (AE_OK);</a>
<a name="ln575">    }</a>
<a name="ln576"> </a>
<a name="ln577">    /* Get the object type to determine if we should pop the scope */</a>
<a name="ln578"> </a>
<a name="ln579">    ObjectType = WalkState-&gt;OpInfo-&gt;ObjectType;</a>
<a name="ln580"> </a>
<a name="ln581">    if (WalkState-&gt;OpInfo-&gt;Flags &amp; AML_FIELD)</a>
<a name="ln582">    {</a>
<a name="ln583">        /*</a>
<a name="ln584">         * If we are executing a method, do not create any namespace objects</a>
<a name="ln585">         * during the load phase, only during execution.</a>
<a name="ln586">         */</a>
<a name="ln587">        if (!WalkState-&gt;MethodNode)</a>
<a name="ln588">        {</a>
<a name="ln589">            if (WalkState-&gt;Opcode == AML_FIELD_OP          ||</a>
<a name="ln590">                WalkState-&gt;Opcode == AML_BANK_FIELD_OP     ||</a>
<a name="ln591">                WalkState-&gt;Opcode == AML_INDEX_FIELD_OP)</a>
<a name="ln592">            {</a>
<a name="ln593">                Status = AcpiDsInitFieldObjects (Op, WalkState);</a>
<a name="ln594">            }</a>
<a name="ln595">        }</a>
<a name="ln596">        return_ACPI_STATUS (Status);</a>
<a name="ln597">    }</a>
<a name="ln598"> </a>
<a name="ln599">    /*</a>
<a name="ln600">     * If we are executing a method, do not create any namespace objects</a>
<a name="ln601">     * during the load phase, only during execution.</a>
<a name="ln602">     */</a>
<a name="ln603">    if (!WalkState-&gt;MethodNode)</a>
<a name="ln604">    {</a>
<a name="ln605">        if (Op-&gt;Common.AmlOpcode == AML_REGION_OP)</a>
<a name="ln606">        {</a>
<a name="ln607">            Status = AcpiExCreateRegion (Op-&gt;Named.Data, Op-&gt;Named.Length,</a>
<a name="ln608">                (ACPI_ADR_SPACE_TYPE)</a>
<a name="ln609">                    ((Op-&gt;Common.Value.Arg)-&gt;Common.Value.Integer),</a>
<a name="ln610">                WalkState);</a>
<a name="ln611">            if (ACPI_FAILURE (Status))</a>
<a name="ln612">            {</a>
<a name="ln613">                return_ACPI_STATUS (Status);</a>
<a name="ln614">            }</a>
<a name="ln615">        }</a>
<a name="ln616">        else if (Op-&gt;Common.AmlOpcode == AML_DATA_REGION_OP)</a>
<a name="ln617">        {</a>
<a name="ln618">            Status = AcpiExCreateRegion (Op-&gt;Named.Data, Op-&gt;Named.Length,</a>
<a name="ln619">                ACPI_ADR_SPACE_DATA_TABLE, WalkState);</a>
<a name="ln620">            if (ACPI_FAILURE (Status))</a>
<a name="ln621">            {</a>
<a name="ln622">                return_ACPI_STATUS (Status);</a>
<a name="ln623">            }</a>
<a name="ln624">        }</a>
<a name="ln625">    }</a>
<a name="ln626"> </a>
<a name="ln627">    if (Op-&gt;Common.AmlOpcode == AML_NAME_OP)</a>
<a name="ln628">    {</a>
<a name="ln629">        /* For Name opcode, get the object type from the argument */</a>
<a name="ln630"> </a>
<a name="ln631">        if (Op-&gt;Common.Value.Arg)</a>
<a name="ln632">        {</a>
<a name="ln633">            ObjectType = (AcpiPsGetOpcodeInfo (</a>
<a name="ln634">                (Op-&gt;Common.Value.Arg)-&gt;Common.AmlOpcode))-&gt;ObjectType;</a>
<a name="ln635"> </a>
<a name="ln636">            /* Set node type if we have a namespace node */</a>
<a name="ln637"> </a>
<a name="ln638">            if (Op-&gt;Common.Node)</a>
<a name="ln639">            {</a>
<a name="ln640">                Op-&gt;Common.Node-&gt;Type = (UINT8) ObjectType;</a>
<a name="ln641">            }</a>
<a name="ln642">        }</a>
<a name="ln643">    }</a>
<a name="ln644"> </a>
<a name="ln645">#ifdef ACPI_ASL_COMPILER</a>
<a name="ln646">    /*</a>
<a name="ln647">     * For external opcode, get the object type from the argument and</a>
<a name="ln648">     * get the parameter count from the argument's next.</a>
<a name="ln649">     */</a>
<a name="ln650">    if (AcpiGbl_DisasmFlag &amp;&amp;</a>
<a name="ln651">        Op-&gt;Common.Node &amp;&amp;</a>
<a name="ln652">        Op-&gt;Common.AmlOpcode == AML_EXTERNAL_OP)</a>
<a name="ln653">    {</a>
<a name="ln654">        /*</a>
<a name="ln655">         * Note, if this external is not a method</a>
<a name="ln656">         * Op-&gt;Common.Value.Arg-&gt;Common.Next-&gt;Common.Value.Integer == 0</a>
<a name="ln657">         * Therefore, ParamCount will be 0.</a>
<a name="ln658">         */</a>
<a name="ln659">        ParamCount = (UINT8) Op-&gt;Common.Value.Arg-&gt;Common.Next-&gt;Common.Value.Integer;</a>
<a name="ln660">        ObjectType = (UINT8) Op-&gt;Common.Value.Arg-&gt;Common.Value.Integer;</a>
<a name="ln661">        Op-&gt;Common.Node-&gt;Flags |= ANOBJ_IS_EXTERNAL;</a>
<a name="ln662">        Op-&gt;Common.Node-&gt;Type = (UINT8) ObjectType;</a>
<a name="ln663"> </a>
<a name="ln664">        AcpiDmCreateSubobjectForExternal ((UINT8)ObjectType,</a>
<a name="ln665">            &amp;Op-&gt;Common.Node, ParamCount);</a>
<a name="ln666"> </a>
<a name="ln667">        /*</a>
<a name="ln668">         * Add the external to the external list because we may be</a>
<a name="ln669">         * emitting code based off of the items within the external list.</a>
<a name="ln670">         */</a>
<a name="ln671">        AcpiDmAddOpToExternalList (Op, Op-&gt;Named.Path, (UINT8)ObjectType, ParamCount,</a>
<a name="ln672">           ACPI_EXT_ORIGIN_FROM_OPCODE | ACPI_EXT_RESOLVED_REFERENCE);</a>
<a name="ln673">    }</a>
<a name="ln674">#endif</a>
<a name="ln675"> </a>
<a name="ln676">    /*</a>
<a name="ln677">     * If we are executing a method, do not create any namespace objects</a>
<a name="ln678">     * during the load phase, only during execution.</a>
<a name="ln679">     */</a>
<a name="ln680">    if (!WalkState-&gt;MethodNode)</a>
<a name="ln681">    {</a>
<a name="ln682">        if (Op-&gt;Common.AmlOpcode == AML_METHOD_OP)</a>
<a name="ln683">        {</a>
<a name="ln684">            /*</a>
<a name="ln685">             * MethodOp PkgLength NameString MethodFlags TermList</a>
<a name="ln686">             *</a>
<a name="ln687">             * Note: We must create the method node/object pair as soon as we</a>
<a name="ln688">             * see the method declaration. This allows later pass1 parsing</a>
<a name="ln689">             * of invocations of the method (need to know the number of</a>
<a name="ln690">             * arguments.)</a>
<a name="ln691">             */</a>
<a name="ln692">            ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,</a>
<a name="ln693">                &quot;LOADING-Method: State=%p Op=%p NamedObj=%p\n&quot;,</a>
<a name="ln694">                WalkState, Op, Op-&gt;Named.Node));</a>
<a name="ln695"> </a>
<a name="ln696">            if (!AcpiNsGetAttachedObject (Op-&gt;Named.Node))</a>
<a name="ln697">            {</a>
<a name="ln698">                WalkState-&gt;Operands[0] = ACPI_CAST_PTR (void, Op-&gt;Named.Node);</a>
<a name="ln699">                WalkState-&gt;NumOperands = 1;</a>
<a name="ln700"> </a>
<a name="ln701">                Status = AcpiDsCreateOperands (</a>
<a name="ln702">                    WalkState, Op-&gt;Common.Value.Arg);</a>
<a name="ln703">                if (ACPI_SUCCESS (Status))</a>
<a name="ln704">                {</a>
<a name="ln705">                    Status = AcpiExCreateMethod (Op-&gt;Named.Data,</a>
<a name="ln706">                        Op-&gt;Named.Length, WalkState);</a>
<a name="ln707">                }</a>
<a name="ln708"> </a>
<a name="ln709">                WalkState-&gt;Operands[0] = NULL;</a>
<a name="ln710">                WalkState-&gt;NumOperands = 0;</a>
<a name="ln711"> </a>
<a name="ln712">                if (ACPI_FAILURE (Status))</a>
<a name="ln713">                {</a>
<a name="ln714">                    return_ACPI_STATUS (Status);</a>
<a name="ln715">                }</a>
<a name="ln716">            }</a>
<a name="ln717">        }</a>
<a name="ln718">    }</a>
<a name="ln719"> </a>
<a name="ln720">    /* Pop the scope stack (only if loading a table) */</a>
<a name="ln721"> </a>
<a name="ln722">    if (!WalkState-&gt;MethodNode &amp;&amp;</a>
<a name="ln723">        Op-&gt;Common.AmlOpcode != AML_EXTERNAL_OP &amp;&amp;</a>
<a name="ln724">        AcpiNsOpensScope (ObjectType))</a>
<a name="ln725">    {</a>
<a name="ln726">        ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, &quot;(%s): Popping scope for Op %p\n&quot;,</a>
<a name="ln727">            AcpiUtGetTypeName (ObjectType), Op));</a>
<a name="ln728"> </a>
<a name="ln729">        Status = AcpiDsScopeStackPop (WalkState);</a>
<a name="ln730">    }</a>
<a name="ln731"> </a>
<a name="ln732">    return_ACPI_STATUS (Status);</a>
<a name="ln733">}</a>

</code></pre>
<div class="balloon" rel="609"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'Op->Common.Value.Arg' pointer was utilized before it was verified against nullptr. Check lines: 609, 631.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
