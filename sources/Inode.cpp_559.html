
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>Inode.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2001-2008 pinc Software. All Rights Reserved.</a>
<a name="ln3"> * Released under the terms of the MIT license.</a>
<a name="ln4"> */</a>
<a name="ln5"> </a>
<a name="ln6">//!	BFS Inode classes</a>
<a name="ln7"> </a>
<a name="ln8"> </a>
<a name="ln9">#include &quot;Inode.h&quot;</a>
<a name="ln10">#include &quot;BPlusTree.h&quot;</a>
<a name="ln11"> </a>
<a name="ln12">#include &lt;Directory.h&gt;</a>
<a name="ln13">#include &lt;SymLink.h&gt;</a>
<a name="ln14">#include &lt;Entry.h&gt;</a>
<a name="ln15">#include &lt;Path.h&gt;</a>
<a name="ln16">#include &lt;String.h&gt;</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;new&gt;</a>
<a name="ln19">#include &lt;stdlib.h&gt;</a>
<a name="ln20">#include &lt;stdio.h&gt;</a>
<a name="ln21">#include &lt;string.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23"> </a>
<a name="ln24">class NodeGetter {</a>
<a name="ln25">	public:</a>
<a name="ln26">		NodeGetter(Inode* inode)</a>
<a name="ln27">			:</a>
<a name="ln28">			fInode(inode)</a>
<a name="ln29">		{</a>
<a name="ln30">			fInode-&gt;AcquireBuffer();</a>
<a name="ln31">		}</a>
<a name="ln32"> </a>
<a name="ln33">		~NodeGetter()</a>
<a name="ln34">		{</a>
<a name="ln35">			fInode-&gt;ReleaseBuffer();</a>
<a name="ln36">		}</a>
<a name="ln37"> </a>
<a name="ln38">	private:</a>
<a name="ln39">		Inode*	fInode;</a>
<a name="ln40">};</a>
<a name="ln41"> </a>
<a name="ln42"> </a>
<a name="ln43">//	#pragma mark -</a>
<a name="ln44"> </a>
<a name="ln45"> </a>
<a name="ln46">Inode::Inode(Disk* disk, bfs_inode* inode, bool ownBuffer)</a>
<a name="ln47">	:</a>
<a name="ln48">	fDisk(disk),</a>
<a name="ln49">	fInode(inode),</a>
<a name="ln50">	fOwnBuffer(ownBuffer),</a>
<a name="ln51">	fPath(NULL),</a>
<a name="ln52">	fRefCount(1),</a>
<a name="ln53">	fCurrentSmallData(NULL),</a>
<a name="ln54">	fAttributes(NULL),</a>
<a name="ln55">	fAttributeBuffer(NULL)</a>
<a name="ln56">{</a>
<a name="ln57">	if (inode != NULL)</a>
<a name="ln58">		fBlockRun = inode-&gt;inode_num;</a>
<a name="ln59">}</a>
<a name="ln60"> </a>
<a name="ln61"> </a>
<a name="ln62">Inode::Inode(const Inode&amp; inode)</a>
<a name="ln63">	:</a>
<a name="ln64">	fDisk(inode.fDisk),</a>
<a name="ln65">	fInode(inode.fInode),</a>
<a name="ln66">	fOwnBuffer(false),</a>
<a name="ln67">	fPath(NULL),</a>
<a name="ln68">	fBlockRun(inode.fBlockRun),</a>
<a name="ln69">	fRefCount(1),</a>
<a name="ln70">	fCurrentSmallData(NULL),</a>
<a name="ln71">	fAttributes(NULL),</a>
<a name="ln72">	fAttributeBuffer(NULL)</a>
<a name="ln73">{</a>
<a name="ln74">}</a>
<a name="ln75"> </a>
<a name="ln76"> </a>
<a name="ln77">Inode::~Inode()</a>
<a name="ln78">{</a>
<a name="ln79">	_Unset();</a>
<a name="ln80">}</a>
<a name="ln81"> </a>
<a name="ln82"> </a>
<a name="ln83">void</a>
<a name="ln84">Inode::_Unset()</a>
<a name="ln85">{</a>
<a name="ln86">	if (fOwnBuffer)</a>
<a name="ln87">		free(fInode);</a>
<a name="ln88"> </a>
<a name="ln89">	fInode = NULL;</a>
<a name="ln90">	fBlockRun.SetTo(0, 0, 0);</a>
<a name="ln91"> </a>
<a name="ln92">	free(fPath);</a>
<a name="ln93">	fPath = NULL;</a>
<a name="ln94"> </a>
<a name="ln95">	delete fAttributes;</a>
<a name="ln96">	fAttributes = NULL;</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99"> </a>
<a name="ln100">status_t</a>
<a name="ln101">Inode::SetTo(bfs_inode *inode)</a>
<a name="ln102">{</a>
<a name="ln103">	_Unset();</a>
<a name="ln104"> </a>
<a name="ln105">	fInode = inode;</a>
<a name="ln106">	fBlockRun = inode-&gt;inode_num;</a>
<a name="ln107">	return B_OK;</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110"> </a>
<a name="ln111">status_t</a>
<a name="ln112">Inode::InitCheck() const</a>
<a name="ln113">{</a>
<a name="ln114">	if (!fInode)</a>
<a name="ln115">		return B_ERROR;</a>
<a name="ln116"> </a>
<a name="ln117">	// test inode magic and flags</a>
<a name="ln118">	if (fInode-&gt;magic1 != INODE_MAGIC1</a>
<a name="ln119">		|| !(fInode-&gt;flags &amp; INODE_IN_USE)</a>
<a name="ln120">		|| fInode-&gt;inode_num.length != 1)</a>
<a name="ln121">		return B_ERROR;</a>
<a name="ln122"> </a>
<a name="ln123">	if (fDisk-&gt;BlockSize()) {</a>
<a name="ln124">			// matches known block size?</a>
<a name="ln125">		if (fInode-&gt;inode_size != fDisk-&gt;SuperBlock()-&gt;inode_size</a>
<a name="ln126">			// parent resides on disk?</a>
<a name="ln127">			|| fInode-&gt;parent.allocation_group &gt; fDisk-&gt;SuperBlock()-&gt;num_ags</a>
<a name="ln128">			|| fInode-&gt;parent.allocation_group &lt; 0</a>
<a name="ln129">			|| fInode-&gt;parent.start &gt; (1L &lt;&lt; fDisk-&gt;SuperBlock()-&gt;ag_shift)</a>
<a name="ln130">			|| fInode-&gt;parent.length != 1</a>
<a name="ln131">			// attributes, too?</a>
<a name="ln132">			|| fInode-&gt;attributes.allocation_group &gt; fDisk-&gt;SuperBlock()-&gt;num_ags</a>
<a name="ln133">			|| fInode-&gt;attributes.allocation_group &lt; 0</a>
<a name="ln134">			|| fInode-&gt;attributes.start &gt; (1L &lt;&lt; fDisk-&gt;SuperBlock()-&gt;ag_shift))</a>
<a name="ln135">			return B_ERROR;</a>
<a name="ln136">	} else {</a>
<a name="ln137">		// is inode size one of the valid values?</a>
<a name="ln138">		switch (fInode-&gt;inode_size) {</a>
<a name="ln139">			case 1024:</a>
<a name="ln140">			case 2048:</a>
<a name="ln141">			case 4096:</a>
<a name="ln142">			case 8192:</a>
<a name="ln143">				break;</a>
<a name="ln144">			default:</a>
<a name="ln145">				return B_ERROR;</a>
<a name="ln146">		}</a>
<a name="ln147">	}</a>
<a name="ln148">	return B_OK;</a>
<a name="ln149">	// is inode on a boundary matching it's size?</a>
<a name="ln150">	//return (Offset() % fInode-&gt;inode_size) == 0 ? B_OK : B_ERROR;</a>
<a name="ln151">}</a>
<a name="ln152"> </a>
<a name="ln153"> </a>
<a name="ln154">status_t</a>
<a name="ln155">Inode::CopyBuffer()</a>
<a name="ln156">{</a>
<a name="ln157">	if (!fInode)</a>
<a name="ln158">		return B_ERROR;</a>
<a name="ln159"> </a>
<a name="ln160">	bfs_inode *buffer = (bfs_inode *)malloc(fInode-&gt;inode_size);</a>
<a name="ln161">	if (!buffer)</a>
<a name="ln162">		return B_NO_MEMORY;</a>
<a name="ln163"> </a>
<a name="ln164">	memcpy(buffer, fInode, fInode-&gt;inode_size);</a>
<a name="ln165">	fInode = buffer;</a>
<a name="ln166">	fOwnBuffer = true;</a>
<a name="ln167">	BufferClobbered();</a>
<a name="ln168">		// this must not be deleted anymore</a>
<a name="ln169"> </a>
<a name="ln170">	return B_OK;</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173"> </a>
<a name="ln174">/*static*/ bool</a>
<a name="ln175">Inode::_LowMemory()</a>
<a name="ln176">{</a>
<a name="ln177">	static bigtime_t lastChecked;</a>
<a name="ln178">	static int32 percentUsed;</a>
<a name="ln179"> </a>
<a name="ln180">	if (system_time() &gt; lastChecked + 1000000LL) {</a>
<a name="ln181">		system_info info;</a>
<a name="ln182">		get_system_info(&amp;info);</a>
<a name="ln183">		percentUsed = 100 * info.used_pages / info.max_pages;</a>
<a name="ln184">	}</a>
<a name="ln185"> </a>
<a name="ln186">	return percentUsed &gt; 75;</a>
<a name="ln187">}</a>
<a name="ln188"> </a>
<a name="ln189"> </a>
<a name="ln190">void</a>
<a name="ln191">Inode::ReleaseBuffer()</a>
<a name="ln192">{</a>
<a name="ln193">	if (atomic_add(&amp;fRefCount, -1) != 1)</a>
<a name="ln194">		return;</a>
<a name="ln195"> </a>
<a name="ln196">	if (fOwnBuffer) {</a>
<a name="ln197">		if (!_LowMemory())</a>
<a name="ln198">			return;</a>
<a name="ln199"> </a>
<a name="ln200">		free(fInode);</a>
<a name="ln201">		fInode = NULL;</a>
<a name="ln202">	}</a>
<a name="ln203">}</a>
<a name="ln204"> </a>
<a name="ln205"> </a>
<a name="ln206">status_t</a>
<a name="ln207">Inode::AcquireBuffer()</a>
<a name="ln208">{</a>
<a name="ln209">	if (atomic_add(&amp;fRefCount, 1) != 0)</a>
<a name="ln210">		return B_OK;</a>
<a name="ln211"> </a>
<a name="ln212">	if (!fOwnBuffer || fInode != NULL)</a>
<a name="ln213">		return B_OK;</a>
<a name="ln214"> </a>
<a name="ln215">	fInode = (bfs_inode*)malloc(fDisk-&gt;BlockSize());</a>
<a name="ln216">	if (fInode == NULL)</a>
<a name="ln217">		return B_NO_MEMORY;</a>
<a name="ln218"> </a>
<a name="ln219">	ssize_t bytesRead = fDisk-&gt;ReadAt(Offset(), fInode, fDisk-&gt;BlockSize());</a>
<a name="ln220">	if (bytesRead &lt; B_OK)</a>
<a name="ln221">		return bytesRead;</a>
<a name="ln222"> </a>
<a name="ln223">	return B_OK;</a>
<a name="ln224">}</a>
<a name="ln225"> </a>
<a name="ln226"> </a>
<a name="ln227">void</a>
<a name="ln228">Inode::BufferClobbered()</a>
<a name="ln229">{</a>
<a name="ln230">	AcquireBuffer();</a>
<a name="ln231">}</a>
<a name="ln232"> </a>
<a name="ln233"> </a>
<a name="ln234">void</a>
<a name="ln235">Inode::SetParent(const block_run&amp; run)</a>
<a name="ln236">{</a>
<a name="ln237">	fInode-&gt;parent = run;</a>
<a name="ln238">	BufferClobbered();</a>
<a name="ln239">}</a>
<a name="ln240"> </a>
<a name="ln241"> </a>
<a name="ln242">void</a>
<a name="ln243">Inode::SetBlockRun(const block_run&amp; run)</a>
<a name="ln244">{</a>
<a name="ln245">	fInode-&gt;inode_num = run;</a>
<a name="ln246">	fBlockRun = run;</a>
<a name="ln247">	BufferClobbered();</a>
<a name="ln248">}</a>
<a name="ln249"> </a>
<a name="ln250"> </a>
<a name="ln251">void</a>
<a name="ln252">Inode::SetMode(uint32 mode)</a>
<a name="ln253">{</a>
<a name="ln254">	fInode-&gt;mode = mode;</a>
<a name="ln255">	BufferClobbered();</a>
<a name="ln256">}</a>
<a name="ln257"> </a>
<a name="ln258"> </a>
<a name="ln259">status_t</a>
<a name="ln260">Inode::SetName(const char *name)</a>
<a name="ln261">{</a>
<a name="ln262">	if (name == NULL || *name == '\0')</a>
<a name="ln263">		return B_BAD_VALUE;</a>
<a name="ln264"> </a>
<a name="ln265">	small_data *data = fInode-&gt;small_data_start, *nameData = NULL;</a>
<a name="ln266">	BufferClobbered();</a>
<a name="ln267"> </a>
<a name="ln268">	while (!data-&gt;IsLast(fInode)) {</a>
<a name="ln269">		if (data-&gt;type == FILE_NAME_TYPE</a>
<a name="ln270">			&amp;&amp; data-&gt;name_size == FILE_NAME_NAME_LENGTH</a>
<a name="ln271">			&amp;&amp; *data-&gt;Name() == FILE_NAME_NAME)</a>
<a name="ln272">			nameData = data;</a>
<a name="ln273"> </a>
<a name="ln274">		data = data-&gt;Next();</a>
<a name="ln275">	}</a>
<a name="ln276"> </a>
<a name="ln277">	int32 oldLength = nameData == NULL ? 0 : nameData-&gt;data_size;</a>
<a name="ln278">	int32 newLength = strlen(name) + (nameData == NULL ? sizeof(small_data) + 5 : 0);</a>
<a name="ln279"> </a>
<a name="ln280">	if ((addr_t)data + newLength - oldLength &gt;= (addr_t)(fInode</a>
<a name="ln281">			+ fDisk-&gt;BlockSize()))</a>
<a name="ln282">		return B_NO_MEMORY;</a>
<a name="ln283"> </a>
<a name="ln284">	if (nameData == NULL) {</a>
<a name="ln285">		memmove(newLength + (uint8 *)fInode-&gt;small_data_start,</a>
<a name="ln286">			fInode-&gt;small_data_start,</a>
<a name="ln287">			(addr_t)data - (addr_t)fInode-&gt;small_data_start);</a>
<a name="ln288">		nameData = fInode-&gt;small_data_start;</a>
<a name="ln289">	} else {</a>
<a name="ln290">		memmove(newLength + (uint8 *)nameData, nameData,</a>
<a name="ln291">			(addr_t)data - (addr_t)fInode-&gt;small_data_start);</a>
<a name="ln292">	}</a>
<a name="ln293"> </a>
<a name="ln294">	memset(nameData, 0, sizeof(small_data) + 5 + strlen(name));</a>
<a name="ln295">	nameData-&gt;type = FILE_NAME_TYPE;</a>
<a name="ln296">	nameData-&gt;name_size = FILE_NAME_NAME_LENGTH;</a>
<a name="ln297">	nameData-&gt;data_size = strlen(name);</a>
<a name="ln298">	*nameData-&gt;Name() = FILE_NAME_NAME;</a>
<a name="ln299">	strcpy((char *)nameData-&gt;Data(),name);</a>
<a name="ln300"> </a>
<a name="ln301">	return B_OK;</a>
<a name="ln302">}</a>
<a name="ln303"> </a>
<a name="ln304"> </a>
<a name="ln305">const char *</a>
<a name="ln306">Inode::Name() const</a>
<a name="ln307">{</a>
<a name="ln308">	if (InitCheck() != B_OK) {</a>
<a name="ln309">		puts(&quot;Not getting name because node is invalid&quot;);</a>
<a name="ln310">		return NULL;</a>
<a name="ln311">	}</a>
<a name="ln312">	small_data *data = fInode-&gt;small_data_start;</a>
<a name="ln313">	while (!data-&gt;IsLast(fInode)) {</a>
<a name="ln314">		if (data-&gt;type == FILE_NAME_TYPE</a>
<a name="ln315">			&amp;&amp; data-&gt;name_size == FILE_NAME_NAME_LENGTH</a>
<a name="ln316">			&amp;&amp; *data-&gt;Name() == FILE_NAME_NAME)</a>
<a name="ln317">			return (const char *)data-&gt;Data();</a>
<a name="ln318"> </a>
<a name="ln319">		data = data-&gt;Next();</a>
<a name="ln320">	}</a>
<a name="ln321">	return NULL;</a>
<a name="ln322">}</a>
<a name="ln323"> </a>
<a name="ln324"> </a>
<a name="ln325">status_t</a>
<a name="ln326">Inode::GetNextSmallData(small_data **smallData)</a>
<a name="ln327">{</a>
<a name="ln328">	if (!fInode)</a>
<a name="ln329">		return B_ERROR;</a>
<a name="ln330"> </a>
<a name="ln331">	small_data *data = *smallData;</a>
<a name="ln332"> </a>
<a name="ln333">	// begin from the start?</a>
<a name="ln334">	if (data == NULL)</a>
<a name="ln335">		data = fInode-&gt;small_data_start;</a>
<a name="ln336">	else</a>
<a name="ln337">		data = data-&gt;Next();</a>
<a name="ln338"> </a>
<a name="ln339">	// is already last item?</a>
<a name="ln340">	if (data-&gt;IsLast(fInode))</a>
<a name="ln341">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln342"> </a>
<a name="ln343">	*smallData = data;</a>
<a name="ln344">	return B_OK;</a>
<a name="ln345">}</a>
<a name="ln346"> </a>
<a name="ln347"> </a>
<a name="ln348">status_t</a>
<a name="ln349">Inode::RewindAttributes()</a>
<a name="ln350">{</a>
<a name="ln351">	fCurrentSmallData = NULL;</a>
<a name="ln352"> </a>
<a name="ln353">	if (fAttributes != NULL)</a>
<a name="ln354">		fAttributes-&gt;Rewind();</a>
<a name="ln355"> </a>
<a name="ln356">	return B_OK;</a>
<a name="ln357">}</a>
<a name="ln358"> </a>
<a name="ln359"> </a>
<a name="ln360">status_t</a>
<a name="ln361">Inode::GetNextAttribute(char *name, uint32 *type, void **data, size_t *length)</a>
<a name="ln362">{</a>
<a name="ln363">	// read attributes out of the small data section</a>
<a name="ln364"> </a>
<a name="ln365">	if (fCurrentSmallData == NULL || !fCurrentSmallData-&gt;IsLast(fInode)) {</a>
<a name="ln366">		if (fCurrentSmallData == NULL)</a>
<a name="ln367">			fCurrentSmallData = fInode-&gt;small_data_start;</a>
<a name="ln368">		else</a>
<a name="ln369">			fCurrentSmallData = fCurrentSmallData-&gt;Next();</a>
<a name="ln370"> </a>
<a name="ln371">		// skip name attribute</a>
<a name="ln372">		if (!fCurrentSmallData-&gt;IsLast(fInode)</a>
<a name="ln373">			&amp;&amp; fCurrentSmallData-&gt;name_size == FILE_NAME_NAME_LENGTH</a>
<a name="ln374">			&amp;&amp; *fCurrentSmallData-&gt;Name() == FILE_NAME_NAME)</a>
<a name="ln375">			fCurrentSmallData = fCurrentSmallData-&gt;Next();</a>
<a name="ln376"> </a>
<a name="ln377">		if (!fCurrentSmallData-&gt;IsLast(fInode)) {</a>
<a name="ln378">			strncpy(name,fCurrentSmallData-&gt;Name(), B_FILE_NAME_LENGTH);</a>
<a name="ln379">			*type = fCurrentSmallData-&gt;type;</a>
<a name="ln380">			*data = fCurrentSmallData-&gt;Data();</a>
<a name="ln381">			*length = fCurrentSmallData-&gt;data_size;</a>
<a name="ln382"> </a>
<a name="ln383">			return B_OK;</a>
<a name="ln384">		}</a>
<a name="ln385">	}</a>
<a name="ln386"> </a>
<a name="ln387">	// read attributes out of the attribute directory</a>
<a name="ln388"> </a>
<a name="ln389">	if (Attributes().IsZero())</a>
<a name="ln390">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln391"> </a>
<a name="ln392">	if (fAttributes == NULL)</a>
<a name="ln393">		fAttributes = (Directory *)Inode::Factory(fDisk, Attributes());</a>
<a name="ln394"> </a>
<a name="ln395">	status_t status = fAttributes ? fAttributes-&gt;InitCheck() : B_ERROR;</a>
<a name="ln396">	if (status &lt; B_OK)</a>
<a name="ln397">		return status;</a>
<a name="ln398"> </a>
<a name="ln399">	block_run run;</a>
<a name="ln400">	status = fAttributes-&gt;GetNextEntry(name, &amp;run);</a>
<a name="ln401">	if (status &lt; B_OK) {</a>
<a name="ln402">		free(fAttributeBuffer);</a>
<a name="ln403">		fAttributeBuffer = NULL;</a>
<a name="ln404">		return status;</a>
<a name="ln405">	}</a>
<a name="ln406"> </a>
<a name="ln407">	Attribute *attribute = (Attribute *)Inode::Factory(fDisk, run);</a>
<a name="ln408">	if (attribute == NULL || attribute-&gt;InitCheck() &lt; B_OK)</a>
<a name="ln409">		return B_IO_ERROR;</a>
<a name="ln410"> </a>
<a name="ln411">	*type = attribute-&gt;Type();</a>
<a name="ln412"> </a>
<a name="ln413">	void *buffer = realloc(fAttributeBuffer, attribute-&gt;Size());</a>
<a name="ln414">	if (buffer == NULL) {</a>
<a name="ln415">		free(fAttributeBuffer);</a>
<a name="ln416">		fAttributeBuffer = NULL;</a>
<a name="ln417">		delete attribute;</a>
<a name="ln418">		return B_NO_MEMORY;</a>
<a name="ln419">	}</a>
<a name="ln420">	fAttributeBuffer = buffer;</a>
<a name="ln421"> </a>
<a name="ln422">	ssize_t size =  attribute-&gt;Read(fAttributeBuffer, attribute-&gt;Size());</a>
<a name="ln423">	delete attribute;</a>
<a name="ln424"> </a>
<a name="ln425">	*length = size;</a>
<a name="ln426">	*data = fAttributeBuffer;</a>
<a name="ln427"> </a>
<a name="ln428">	return size &lt; B_OK ? size : B_OK;</a>
<a name="ln429">}</a>
<a name="ln430"> </a>
<a name="ln431"> </a>
<a name="ln432">status_t</a>
<a name="ln433">Inode::_FindPath(Inode::Source *source)</a>
<a name="ln434">{</a>
<a name="ln435">	BString path;</a>
<a name="ln436"> </a>
<a name="ln437">	block_run parent = Parent();</a>
<a name="ln438">	while (!parent.IsZero() &amp;&amp; parent != fDisk-&gt;Root()) {</a>
<a name="ln439">		Inode *inode;</a>
<a name="ln440">		if (source)</a>
<a name="ln441">			inode = source-&gt;InodeAt(parent);</a>
<a name="ln442">		else</a>
<a name="ln443">			inode = Inode::Factory(fDisk, parent);</a>
<a name="ln444"> </a>
<a name="ln445">		if (inode == NULL</a>
<a name="ln446">			|| inode-&gt;InitCheck() &lt; B_OK</a>
<a name="ln447">			|| inode-&gt;Name() == NULL</a>
<a name="ln448">			|| !*inode-&gt;Name()) {</a>
<a name="ln449">			BString sub;</a>
<a name="ln450">			sub &lt;&lt; &quot;__recovered &quot; &lt;&lt; parent.allocation_group &lt;&lt; &quot;:&quot;</a>
<a name="ln451">				&lt;&lt; (int32)parent.start &lt;&lt; &quot;/&quot;;</a>
<a name="ln452">			path.Prepend(sub);</a>
<a name="ln453"> </a>
<a name="ln454">			delete inode;</a>
<a name="ln455">			break;</a>
<a name="ln456">		}</a>
<a name="ln457">		parent = inode-&gt;Parent();</a>
<a name="ln458">		path.Prepend(&quot;/&quot;);</a>
<a name="ln459">		path.Prepend(inode-&gt;Name());</a>
<a name="ln460"> </a>
<a name="ln461">		delete inode;</a>
<a name="ln462">	}</a>
<a name="ln463">	fPath = strdup(path.String());</a>
<a name="ln464"> </a>
<a name="ln465">	return B_OK;</a>
<a name="ln466">}</a>
<a name="ln467"> </a>
<a name="ln468"> </a>
<a name="ln469">const char *</a>
<a name="ln470">Inode::Path(Inode::Source *source)</a>
<a name="ln471">{</a>
<a name="ln472">	if (fPath == NULL)</a>
<a name="ln473">		_FindPath(source);</a>
<a name="ln474"> </a>
<a name="ln475">	return fPath;</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478"> </a>
<a name="ln479">status_t</a>
<a name="ln480">Inode::CopyTo(const char *root, bool fullPath, Inode::Source *source)</a>
<a name="ln481">{</a>
<a name="ln482">	if (root == NULL)</a>
<a name="ln483">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln484"> </a>
<a name="ln485">	BString path;</a>
<a name="ln486"> </a>
<a name="ln487">	if (fullPath)</a>
<a name="ln488">		path.Append(Path(source));</a>
<a name="ln489"> </a>
<a name="ln490">	if (*(root + strlen(root) - 1) != '/')</a>
<a name="ln491">		path.Prepend(&quot;/&quot;);</a>
<a name="ln492">	path.Prepend(root);</a>
<a name="ln493"> </a>
<a name="ln494">	return create_directory(path.String(), 0777);</a>
<a name="ln495">}</a>
<a name="ln496"> </a>
<a name="ln497"> </a>
<a name="ln498">status_t</a>
<a name="ln499">Inode::CopyAttributesTo(BNode *node)</a>
<a name="ln500">{</a>
<a name="ln501">	// copy attributes</a>
<a name="ln502"> </a>
<a name="ln503">	RewindAttributes();</a>
<a name="ln504"> </a>
<a name="ln505">	char name[B_FILE_NAME_LENGTH];</a>
<a name="ln506">	const uint32 kMaxBrokenAttributes = 64;</a>
<a name="ln507">		// sanity max value</a>
<a name="ln508">	uint32 count = 0;</a>
<a name="ln509">	uint32 type;</a>
<a name="ln510">	void *data;</a>
<a name="ln511">	size_t size;</a>
<a name="ln512"> </a>
<a name="ln513">	status_t status;</a>
<a name="ln514">	while ((status = GetNextAttribute(name, &amp;type, &amp;data, &amp;size))</a>
<a name="ln515">			!= B_ENTRY_NOT_FOUND) {</a>
<a name="ln516">		if (status != B_OK) {</a>
<a name="ln517">			printf(&quot;could not open attribute (possibly: %s): %s!\n&quot;,</a>
<a name="ln518">				name, strerror(status));</a>
<a name="ln519">			if (count++ &gt; kMaxBrokenAttributes)</a>
<a name="ln520">				break;</a>
<a name="ln521"> </a>
<a name="ln522">			continue;</a>
<a name="ln523">		}</a>
<a name="ln524"> </a>
<a name="ln525">		ssize_t written = node-&gt;WriteAttr(name, type, 0, data, size);</a>
<a name="ln526">		if (written &lt; B_OK) {</a>
<a name="ln527">			printf(&quot;could not write attribute \&quot;%s\&quot;: %s\n&quot;, name,</a>
<a name="ln528">				strerror(written));</a>
<a name="ln529">		} else if ((size_t)written &lt; size) {</a>
<a name="ln530">			printf(&quot;could only write %ld bytes (from %ld) at attribute \&quot;%s\&quot;\n&quot;,</a>
<a name="ln531">				written, size, name);</a>
<a name="ln532">		}</a>
<a name="ln533">	}</a>
<a name="ln534"> </a>
<a name="ln535">	// copy stats</a>
<a name="ln536"> </a>
<a name="ln537">	node-&gt;SetPermissions(fInode-&gt;mode);</a>
<a name="ln538">	node-&gt;SetOwner(fInode-&gt;uid);</a>
<a name="ln539">	node-&gt;SetGroup(fInode-&gt;gid);</a>
<a name="ln540">	node-&gt;SetModificationTime(fInode-&gt;last_modified_time &gt;&gt; 16);</a>
<a name="ln541">	node-&gt;SetCreationTime(fInode-&gt;create_time &gt;&gt; 16);</a>
<a name="ln542"> </a>
<a name="ln543">	return B_OK;</a>
<a name="ln544">}</a>
<a name="ln545"> </a>
<a name="ln546"> </a>
<a name="ln547">Inode *</a>
<a name="ln548">Inode::Factory(Disk *disk, bfs_inode *inode, bool ownBuffer)</a>
<a name="ln549">{</a>
<a name="ln550">	// attributes (of a file)</a>
<a name="ln551">	if ((inode-&gt;mode &amp; (S_ATTR | S_ATTR_DIR)) == S_ATTR)</a>
<a name="ln552">		return new Attribute(disk, inode, ownBuffer);</a>
<a name="ln553"> </a>
<a name="ln554">	// directories, attribute directories, indices</a>
<a name="ln555">	if (S_ISDIR(inode-&gt;mode) || inode-&gt;mode &amp; S_ATTR_DIR)</a>
<a name="ln556">		return new Directory(disk, inode, ownBuffer);</a>
<a name="ln557"> </a>
<a name="ln558">	// regular files</a>
<a name="ln559">	if (S_ISREG(inode-&gt;mode))</a>
<a name="ln560">		return new File(disk, inode, ownBuffer);</a>
<a name="ln561"> </a>
<a name="ln562">	// symlinks (short and link in data-stream)</a>
<a name="ln563">	if (S_ISLNK(inode-&gt;mode))</a>
<a name="ln564">		return new Symlink(disk, inode, ownBuffer);</a>
<a name="ln565"> </a>
<a name="ln566">	return NULL;</a>
<a name="ln567">}</a>
<a name="ln568"> </a>
<a name="ln569"> </a>
<a name="ln570">Inode *</a>
<a name="ln571">Inode::Factory(Disk *disk, block_run run)</a>
<a name="ln572">{</a>
<a name="ln573">	bfs_inode *inode = (bfs_inode *)malloc(disk-&gt;BlockSize());</a>
<a name="ln574">	if (!inode)</a>
<a name="ln575">		return NULL;</a>
<a name="ln576"> </a>
<a name="ln577">	if (disk-&gt;ReadAt(disk-&gt;ToOffset(run), inode, disk-&gt;BlockSize()) &lt;= 0)</a>
<a name="ln578">		return NULL;</a>
<a name="ln579"> </a>
<a name="ln580">	Inode *object = Factory(disk, inode);</a>
<a name="ln581">	if (object == NULL)</a>
<a name="ln582">		free(inode);</a>
<a name="ln583"> </a>
<a name="ln584">	return object;</a>
<a name="ln585">}</a>
<a name="ln586"> </a>
<a name="ln587"> </a>
<a name="ln588">Inode *</a>
<a name="ln589">Inode::Factory(Disk *disk, Inode *inode, bool copyBuffer)</a>
<a name="ln590">{</a>
<a name="ln591">	bfs_inode *inodeBuffer = inode-&gt;fInode;</a>
<a name="ln592"> </a>
<a name="ln593">	if (copyBuffer) {</a>
<a name="ln594">		bfs_inode *inodeCopy = (bfs_inode *)malloc(inodeBuffer-&gt;inode_size);</a>
<a name="ln595">		if (!inodeCopy)</a>
<a name="ln596">			return NULL;</a>
<a name="ln597"> </a>
<a name="ln598">		memcpy(inodeCopy, inodeBuffer, inodeBuffer-&gt;inode_size);</a>
<a name="ln599">		inodeBuffer = inodeCopy;</a>
<a name="ln600">	}</a>
<a name="ln601">	return Factory(disk, inodeBuffer, copyBuffer);</a>
<a name="ln602">}</a>
<a name="ln603"> </a>
<a name="ln604"> </a>
<a name="ln605">Inode *</a>
<a name="ln606">Inode::EmptyInode(Disk *disk, const char *name, int32 mode)</a>
<a name="ln607">{</a>
<a name="ln608">	bfs_inode *inode = (bfs_inode *)malloc(disk-&gt;BlockSize());</a>
<a name="ln609">	if (!inode)</a>
<a name="ln610">		return NULL;</a>
<a name="ln611"> </a>
<a name="ln612">	memset(inode, 0, sizeof(bfs_inode));</a>
<a name="ln613"> </a>
<a name="ln614">	inode-&gt;magic1 = INODE_MAGIC1;</a>
<a name="ln615">	inode-&gt;inode_size = disk-&gt;BlockSize();</a>
<a name="ln616">	inode-&gt;mode = mode;</a>
<a name="ln617">	inode-&gt;flags = INODE_IN_USE | (mode &amp; S_IFDIR ? INODE_LOGGED : 0);</a>
<a name="ln618"> </a>
<a name="ln619">	if (name) {</a>
<a name="ln620">		small_data *data = inode-&gt;small_data_start;</a>
<a name="ln621">		data-&gt;type = FILE_NAME_TYPE;</a>
<a name="ln622">		data-&gt;name_size = FILE_NAME_NAME_LENGTH;</a>
<a name="ln623">		*data-&gt;Name() = FILE_NAME_NAME;</a>
<a name="ln624">		data-&gt;data_size = strlen(name);</a>
<a name="ln625">		strcpy((char *)data-&gt;Data(), name);</a>
<a name="ln626">	}</a>
<a name="ln627"> </a>
<a name="ln628">	Inode *object = new (std::nothrow) Inode(disk, inode);</a>
<a name="ln629">	if (object == NULL) {</a>
<a name="ln630">		free(inode);</a>
<a name="ln631">		return NULL;</a>
<a name="ln632">	}</a>
<a name="ln633"> </a>
<a name="ln634">	object-&gt;AcquireBuffer();</a>
<a name="ln635">		// this must not be deleted anymore!</a>
<a name="ln636">	return object;</a>
<a name="ln637">}</a>
<a name="ln638"> </a>
<a name="ln639"> </a>
<a name="ln640">//	#pragma mark -</a>
<a name="ln641"> </a>
<a name="ln642"> </a>
<a name="ln643">DataStream::DataStream(Disk *disk, bfs_inode *inode, bool ownBuffer)</a>
<a name="ln644">	: Inode(disk,inode,ownBuffer),</a>
<a name="ln645">	fCurrent(-1),</a>
<a name="ln646">	fPosition(0LL)</a>
<a name="ln647">{</a>
<a name="ln648">}</a>
<a name="ln649"> </a>
<a name="ln650"> </a>
<a name="ln651">DataStream::DataStream(const Inode &amp;inode)</a>
<a name="ln652">	: Inode(inode),</a>
<a name="ln653">	fCurrent(-1),</a>
<a name="ln654">	fPosition(0LL)</a>
<a name="ln655">{</a>
<a name="ln656">}</a>
<a name="ln657"> </a>
<a name="ln658"> </a>
<a name="ln659">DataStream::~DataStream()</a>
<a name="ln660">{</a>
<a name="ln661">}</a>
<a name="ln662"> </a>
<a name="ln663"> </a>
<a name="ln664">status_t</a>
<a name="ln665">DataStream::FindBlockRun(off_t pos)</a>
<a name="ln666">{</a>
<a name="ln667">	NodeGetter _(this);</a>
<a name="ln668"> </a>
<a name="ln669">	if (pos &gt; fInode-&gt;data.size)</a>
<a name="ln670">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln671"> </a>
<a name="ln672">	if (fCurrent &lt; 0)</a>
<a name="ln673">		fLevel = 0;</a>
<a name="ln674"> </a>
<a name="ln675">	fRunBlockEnd = fCurrent &gt;= 0</a>
<a name="ln676">		? fRunFileOffset + (fRun.length &lt;&lt; fDisk-&gt;BlockShift()) : 0LL;</a>
<a name="ln677"> </a>
<a name="ln678">	// access in current block run?</a>
<a name="ln679"> </a>
<a name="ln680">	if (fCurrent &gt;= 0 &amp;&amp; pos &gt;= fRunFileOffset &amp;&amp; pos &lt; fRunBlockEnd)</a>
<a name="ln681">		return B_OK;</a>
<a name="ln682"> </a>
<a name="ln683">	// find matching block run</a>
<a name="ln684"> </a>
<a name="ln685">	if (fInode-&gt;data.max_direct_range &gt; 0</a>
<a name="ln686">		&amp;&amp; pos &gt;= fInode-&gt;data.max_direct_range) {</a>
<a name="ln687">		if (fInode-&gt;data.max_double_indirect_range &gt; 0</a>
<a name="ln688">			&amp;&amp; pos &gt;= fInode-&gt;data.max_indirect_range) {</a>
<a name="ln689">			// read from double indirect blocks</a>
<a name="ln690"> </a>
<a name="ln691">			//printf(&quot;find double indirect block: %ld,%d!\n&quot;,fInode-&gt;data.double_indirect.allocation_group,fInode-&gt;data.double_indirect.start);</a>
<a name="ln692">			block_run *indirect = (block_run *)fDisk-&gt;ReadBlockRun(fInode-&gt;data.double_indirect);</a>
<a name="ln693">			if (indirect == NULL)</a>
<a name="ln694">				return B_ERROR;</a>
<a name="ln695"> </a>
<a name="ln696">			off_t start = pos - fInode-&gt;data.max_indirect_range;</a>
<a name="ln697">			int32 indirectSize = fDisk-&gt;BlockSize() * 16 * (fDisk-&gt;BlockSize() / sizeof(block_run));</a>
<a name="ln698">			int32 directSize = fDisk-&gt;BlockSize() * 4;</a>
<a name="ln699">			int32 index = start / indirectSize;</a>
<a name="ln700"> </a>
<a name="ln701">			//printf(&quot;\tstart = %Ld, indirectSize = %ld, directSize = %ld, index = %ld\n&quot;,start,indirectSize,directSize,index);</a>
<a name="ln702">			//printf(&quot;\tlook for indirect block at %ld,%d\n&quot;,indirect[index].allocation_group,indirect[index].start);</a>
<a name="ln703">			indirect = (block_run *)fDisk-&gt;ReadBlockRun(indirect[index]);</a>
<a name="ln704">			if (indirect == NULL)</a>
<a name="ln705">				return B_ERROR;</a>
<a name="ln706"> </a>
<a name="ln707">			fCurrent = (start % indirectSize) / directSize;</a>
<a name="ln708">			fRunFileOffset = fInode-&gt;data.max_indirect_range + (index * indirectSize) + (fCurrent * directSize);</a>
<a name="ln709">			fRunBlockEnd = fRunFileOffset + directSize;</a>
<a name="ln710">			fRun = indirect[fCurrent];</a>
<a name="ln711">			//printf(&quot;\tfCurrent = %ld, fRunFileOffset = %Ld, fRunBlockEnd = %Ld, fRun = %ld,%d\n&quot;,fCurrent,fRunFileOffset,fRunBlockEnd,fRun.allocation_group,fRun.start);</a>
<a name="ln712">		} else {</a>
<a name="ln713">			// access from indirect blocks</a>
<a name="ln714"> </a>
<a name="ln715">			block_run *indirect = (block_run *)fDisk-&gt;ReadBlockRun(fInode-&gt;data.indirect);</a>
<a name="ln716">			if (!indirect)</a>
<a name="ln717">				return B_ERROR;</a>
<a name="ln718"> </a>
<a name="ln719">			int32 indirectRuns = (fInode-&gt;data.indirect.length &lt;&lt; fDisk-&gt;BlockShift()) / sizeof(block_run);</a>
<a name="ln720"> </a>
<a name="ln721">			if (fLevel != 1 || pos &lt; fRunFileOffset) {</a>
<a name="ln722">				fRunBlockEnd = fInode-&gt;data.max_direct_range;</a>
<a name="ln723">				fCurrent = -1;</a>
<a name="ln724">				fLevel = 1;</a>
<a name="ln725">			}</a>
<a name="ln726"> </a>
<a name="ln727">			while (++fCurrent &lt; indirectRuns) {</a>
<a name="ln728">				if (indirect[fCurrent].IsZero())</a>
<a name="ln729">					break;</a>
<a name="ln730"> </a>
<a name="ln731">				fRunFileOffset = fRunBlockEnd;</a>
<a name="ln732">				fRunBlockEnd += indirect[fCurrent].length &lt;&lt; fDisk-&gt;BlockShift();</a>
<a name="ln733">				if (fRunBlockEnd &gt; pos)</a>
<a name="ln734">					break;</a>
<a name="ln735">			}</a>
<a name="ln736">			if (fCurrent == indirectRuns || indirect[fCurrent].IsZero())</a>
<a name="ln737">				return B_ERROR;</a>
<a name="ln738"> </a>
<a name="ln739">			fRun = indirect[fCurrent];</a>
<a name="ln740">			//printf(&quot;reading from indirect block: %ld,%d\n&quot;,fRun.allocation_group,fRun.start);</a>
<a name="ln741">			//printf(&quot;### indirect-run[%ld] = (%ld,%d,%d), offset = %Ld\n&quot;,fCurrent,fRun.allocation_group,fRun.start,fRun.length,fRunFileOffset);</a>
<a name="ln742">		}</a>
<a name="ln743">	} else {</a>
<a name="ln744">		// access from direct blocks</a>
<a name="ln745">		if (fRunFileOffset &gt; pos) {</a>
<a name="ln746">			fRunBlockEnd = 0LL;</a>
<a name="ln747">			fCurrent = -1;</a>
<a name="ln748">		}</a>
<a name="ln749">		fLevel = 0;</a>
<a name="ln750"> </a>
<a name="ln751">		while (++fCurrent &lt; NUM_DIRECT_BLOCKS) {</a>
<a name="ln752">			if (fInode-&gt;data.direct[fCurrent].IsZero())</a>
<a name="ln753">				break;</a>
<a name="ln754"> </a>
<a name="ln755">			fRunFileOffset = fRunBlockEnd;</a>
<a name="ln756">			fRunBlockEnd += fInode-&gt;data.direct[fCurrent].length &lt;&lt; fDisk-&gt;BlockShift();</a>
<a name="ln757">			if (fRunBlockEnd &gt; pos)</a>
<a name="ln758">				break;</a>
<a name="ln759">		}</a>
<a name="ln760">		if (fCurrent == NUM_DIRECT_BLOCKS || fInode-&gt;data.direct[fCurrent].IsZero())</a>
<a name="ln761">			return B_ERROR;</a>
<a name="ln762"> </a>
<a name="ln763">		fRun = fInode-&gt;data.direct[fCurrent];</a>
<a name="ln764">		//printf(&quot;### run[%ld] = (%ld,%d,%d), offset = %Ld\n&quot;,fCurrent,fRun.allocation_group,fRun.start,fRun.length,fRunFileOffset);</a>
<a name="ln765">	}</a>
<a name="ln766">	return B_OK;</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769"> </a>
<a name="ln770">ssize_t</a>
<a name="ln771">DataStream::ReadAt(off_t pos, void *buffer, size_t size)</a>
<a name="ln772">{</a>
<a name="ln773">	NodeGetter _(this);</a>
<a name="ln774"> </a>
<a name="ln775">	//printf(&quot;DataStream::ReadAt(pos = %Ld,buffer = %p,size = %ld);\n&quot;,pos,buffer,size);</a>
<a name="ln776">	// truncate size to read</a>
<a name="ln777">	if (pos + (off_t)size &gt; fInode-&gt;data.size) {</a>
<a name="ln778">		if (pos &gt; fInode-&gt;data.size)	// reading outside the file</a>
<a name="ln779">			return B_ERROR;</a>
<a name="ln780"> </a>
<a name="ln781">		size = fInode-&gt;data.size - pos;</a>
<a name="ln782">		if (!size)	// there is nothing left to read</a>
<a name="ln783">			return 0;</a>
<a name="ln784">	}</a>
<a name="ln785">	ssize_t read = 0;</a>
<a name="ln786"> </a>
<a name="ln787">	//printf(&quot;### read %ld bytes at %Ld\n&quot;,size,pos);</a>
<a name="ln788">	while (size &gt; 0) {</a>
<a name="ln789">		status_t status = FindBlockRun(pos);</a>
<a name="ln790">		if (status &lt; B_OK)</a>
<a name="ln791">			return status;</a>
<a name="ln792"> </a>
<a name="ln793">		ssize_t bytes = min_c((off_t)size, fRunBlockEnd - pos);</a>
<a name="ln794"> </a>
<a name="ln795">		//printf(&quot;### read %ld bytes from %Ld\n### --\n&quot;,bytes,fDisk-&gt;ToOffset(fRun) + pos - fRunFileOffset);</a>
<a name="ln796">		bytes = fDisk-&gt;ReadAt(fDisk-&gt;ToOffset(fRun) + pos - fRunFileOffset,</a>
<a name="ln797">			buffer, bytes);</a>
<a name="ln798">		if (bytes &lt;= 0) {</a>
<a name="ln799">			if (bytes == 0) {</a>
<a name="ln800">				printf(&quot;could not read bytes at: %&quot; B_PRId32 &quot;,%d\n&quot;,</a>
<a name="ln801">					fRun.allocation_group, fRun.start);</a>
<a name="ln802">			}</a>
<a name="ln803">			return bytes &lt; 0 ? bytes : B_BAD_DATA;</a>
<a name="ln804">		}</a>
<a name="ln805"> </a>
<a name="ln806">		buffer = (void *)((uint8 *)buffer + bytes);</a>
<a name="ln807">		size -= bytes;</a>
<a name="ln808">		pos += bytes;</a>
<a name="ln809">		read += bytes;</a>
<a name="ln810">	}</a>
<a name="ln811">	if (read &gt;= 0)</a>
<a name="ln812">		return read;</a>
<a name="ln813"> </a>
<a name="ln814">	return B_IO_ERROR;</a>
<a name="ln815">}</a>
<a name="ln816"> </a>
<a name="ln817"> </a>
<a name="ln818">ssize_t</a>
<a name="ln819">DataStream::WriteAt(off_t pos, const void *buffer, size_t size)</a>
<a name="ln820">{</a>
<a name="ln821">	NodeGetter _(this);</a>
<a name="ln822"> </a>
<a name="ln823">	// FIXME: truncate size -&gt; should enlargen the file</a>
<a name="ln824">	if (pos + (off_t)size &gt; fInode-&gt;data.size) {</a>
<a name="ln825">		if (pos &gt; fInode-&gt;data.size)	// writing outside the file</a>
<a name="ln826">			return B_ERROR;</a>
<a name="ln827"> </a>
<a name="ln828">		size = fInode-&gt;data.size - pos;</a>
<a name="ln829">		if (!size)	// there is nothing left to write</a>
<a name="ln830">			return 0;</a>
<a name="ln831">	}</a>
<a name="ln832">	ssize_t written = 0;</a>
<a name="ln833"> </a>
<a name="ln834">	//printf(&quot;### write %ld bytes at %Ld\n&quot;,size,pos);</a>
<a name="ln835">	while (size &gt; 0) {</a>
<a name="ln836">		status_t status = FindBlockRun(pos);</a>
<a name="ln837">		if (status &lt; B_OK)</a>
<a name="ln838">			return status;</a>
<a name="ln839"> </a>
<a name="ln840">		ssize_t bytes = min_c((off_t)size, fRunBlockEnd - pos);</a>
<a name="ln841"> </a>
<a name="ln842">		//printf(&quot;### write %ld bytes to %Ld\n### --\n&quot;,bytes,fDisk-&gt;ToOffset(fRun) + pos - fRunFileOffset);</a>
<a name="ln843">		bytes = fDisk-&gt;WriteAt(fDisk-&gt;ToOffset(fRun) + pos - fRunFileOffset,buffer,bytes);</a>
<a name="ln844">		if (bytes &lt; 0)</a>
<a name="ln845">			return bytes;</a>
<a name="ln846"> </a>
<a name="ln847">		buffer = (void *)((uint8 *)buffer + bytes);</a>
<a name="ln848">		size -= bytes;</a>
<a name="ln849">		pos += bytes;</a>
<a name="ln850">		written += bytes;</a>
<a name="ln851">	}</a>
<a name="ln852">	if (written &gt;= 0)</a>
<a name="ln853">		return written;</a>
<a name="ln854"> </a>
<a name="ln855">	return B_IO_ERROR;</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858"> </a>
<a name="ln859">off_t</a>
<a name="ln860">DataStream::Seek(off_t position, uint32 seekMode)</a>
<a name="ln861">{</a>
<a name="ln862">	NodeGetter _(this);</a>
<a name="ln863"> </a>
<a name="ln864">	if (seekMode == SEEK_SET)</a>
<a name="ln865">		fPosition = position;</a>
<a name="ln866">	else if (seekMode == SEEK_END)</a>
<a name="ln867">		fPosition = fInode-&gt;data.size + position;</a>
<a name="ln868">	else</a>
<a name="ln869">		fPosition += position;</a>
<a name="ln870"> </a>
<a name="ln871">	return fPosition;</a>
<a name="ln872">}</a>
<a name="ln873"> </a>
<a name="ln874"> </a>
<a name="ln875">off_t</a>
<a name="ln876">DataStream::Position() const</a>
<a name="ln877">{</a>
<a name="ln878">	return fPosition;</a>
<a name="ln879">}</a>
<a name="ln880"> </a>
<a name="ln881"> </a>
<a name="ln882">status_t</a>
<a name="ln883">DataStream::SetSize(off_t size)</a>
<a name="ln884">{</a>
<a name="ln885">	NodeGetter _(this);</a>
<a name="ln886"> </a>
<a name="ln887">	// FIXME: not yet supported</a>
<a name="ln888">	if (size &gt; fInode-&gt;data.size || size &gt; fInode-&gt;data.max_direct_range)</a>
<a name="ln889">		return B_ERROR;</a>
<a name="ln890"> </a>
<a name="ln891">	if (size == fInode-&gt;data.size)</a>
<a name="ln892">		return B_OK;</a>
<a name="ln893"> </a>
<a name="ln894">	BufferClobbered();</a>
<a name="ln895"> </a>
<a name="ln896">	fInode-&gt;data.size = size;</a>
<a name="ln897">	fInode-&gt;data.max_direct_range = size;</a>
<a name="ln898">	fInode-&gt;data.max_indirect_range = 0;</a>
<a name="ln899">	fInode-&gt;data.max_double_indirect_range = 0;</a>
<a name="ln900"> </a>
<a name="ln901">	for (int32 i = 0;i &lt; NUM_DIRECT_BLOCKS;i++) {</a>
<a name="ln902">		if (size &lt;= 0)</a>
<a name="ln903">			fInode-&gt;data.direct[i].SetTo(0, 0, 0);</a>
<a name="ln904">		else if ((fInode-&gt;data.direct[i].length &lt;&lt; fDisk-&gt;BlockShift()) &gt;= size) {</a>
<a name="ln905">			off_t blocks = (size + fDisk-&gt;BlockSize() - 1) / fDisk-&gt;BlockSize();</a>
<a name="ln906">			fInode-&gt;data.direct[i].length = blocks;</a>
<a name="ln907">			size = 0;</a>
<a name="ln908">		} else</a>
<a name="ln909">			size -= fInode-&gt;data.direct[i].length &lt;&lt; fDisk-&gt;BlockShift();</a>
<a name="ln910">	}</a>
<a name="ln911"> </a>
<a name="ln912">	return B_OK;</a>
<a name="ln913">}</a>
<a name="ln914"> </a>
<a name="ln915"> </a>
<a name="ln916">//	#pragma mark -</a>
<a name="ln917"> </a>
<a name="ln918"> </a>
<a name="ln919">File::File(Disk *disk, bfs_inode *inode,bool ownBuffer)</a>
<a name="ln920">	: DataStream(disk,inode,ownBuffer)</a>
<a name="ln921">{</a>
<a name="ln922">}</a>
<a name="ln923"> </a>
<a name="ln924"> </a>
<a name="ln925">File::File(const Inode &amp;inode)</a>
<a name="ln926">	: DataStream(inode)</a>
<a name="ln927">{</a>
<a name="ln928">}</a>
<a name="ln929"> </a>
<a name="ln930"> </a>
<a name="ln931">File::~File()</a>
<a name="ln932">{</a>
<a name="ln933">}</a>
<a name="ln934"> </a>
<a name="ln935"> </a>
<a name="ln936">status_t</a>
<a name="ln937">File::InitCheck() const</a>
<a name="ln938">{</a>
<a name="ln939">	status_t status = DataStream::InitCheck();</a>
<a name="ln940">	if (status == B_OK)</a>
<a name="ln941">		return IsFile() ? B_OK : B_ERROR;</a>
<a name="ln942"> </a>
<a name="ln943">	return status;</a>
<a name="ln944">}</a>
<a name="ln945"> </a>
<a name="ln946"> </a>
<a name="ln947">status_t</a>
<a name="ln948">File::CopyTo(const char *root, bool fullPath, Inode::Source *source)</a>
<a name="ln949">{</a>
<a name="ln950">	status_t status = Inode::CopyTo(root, fullPath, source);</a>
<a name="ln951">	if (status &lt; B_OK)</a>
<a name="ln952">		return status;</a>
<a name="ln953"> </a>
<a name="ln954">	BPath path(root);</a>
<a name="ln955">	if (fullPath &amp;&amp; Path(source))</a>
<a name="ln956">		path.Append(Path(source));</a>
<a name="ln957"> </a>
<a name="ln958">	char *name = (char *)Name();</a>
<a name="ln959">	if (name != NULL) {</a>
<a name="ln960">		// changes the filename in the inode buffer (for deleted entries)</a>
<a name="ln961">		if (!*name)</a>
<a name="ln962">			*name = '_';</a>
<a name="ln963">		path.Append(name);</a>
<a name="ln964">	} else {</a>
<a name="ln965">		BString sub;</a>
<a name="ln966">		sub &lt;&lt; &quot;__untitled &quot; &lt;&lt; BlockRun().allocation_group &lt;&lt; &quot;:&quot;</a>
<a name="ln967">			&lt;&lt; (int32)BlockRun().start;</a>
<a name="ln968">		path.Append(sub.String());</a>
<a name="ln969">	}</a>
<a name="ln970">	printf(&quot;%&quot; B_PRId32 &quot;,%d -&gt; %s\n&quot;, BlockRun().allocation_group,</a>
<a name="ln971">		BlockRun().start, path.Path());</a>
<a name="ln972"> </a>
<a name="ln973">	BFile file;</a>
<a name="ln974">	status = file.SetTo(path.Path(),</a>
<a name="ln975">		B_WRITE_ONLY | B_CREATE_FILE | B_FAIL_IF_EXISTS);</a>
<a name="ln976">	if (status &lt; B_OK)</a>
<a name="ln977">		return status;</a>
<a name="ln978"> </a>
<a name="ln979">	char buffer[fDisk-&gt;BlockSize()];</a>
<a name="ln980">	ssize_t size;</a>
<a name="ln981">	Seek(0, SEEK_SET);</a>
<a name="ln982"> </a>
<a name="ln983">	while ((size = Read(buffer, sizeof(buffer))) &gt; B_OK) {</a>
<a name="ln984">		ssize_t written = file.Write(buffer, size);</a>
<a name="ln985">		if (written &lt; B_OK)</a>
<a name="ln986">			return written;</a>
<a name="ln987">	}</a>
<a name="ln988"> </a>
<a name="ln989">	return CopyAttributesTo(&amp;file);</a>
<a name="ln990">}</a>
<a name="ln991"> </a>
<a name="ln992"> </a>
<a name="ln993">//	#pragma mark -</a>
<a name="ln994"> </a>
<a name="ln995"> </a>
<a name="ln996">Attribute::Attribute(Disk *disk, bfs_inode *inode, bool ownBuffer)</a>
<a name="ln997">	: File(disk, inode, ownBuffer)</a>
<a name="ln998">{</a>
<a name="ln999">}</a>
<a name="ln1000"> </a>
<a name="ln1001"> </a>
<a name="ln1002">Attribute::Attribute(const Inode &amp;inode)</a>
<a name="ln1003">	: File(inode)</a>
<a name="ln1004">{</a>
<a name="ln1005">}</a>
<a name="ln1006"> </a>
<a name="ln1007"> </a>
<a name="ln1008">Attribute::~Attribute()</a>
<a name="ln1009">{</a>
<a name="ln1010">}</a>
<a name="ln1011"> </a>
<a name="ln1012"> </a>
<a name="ln1013">status_t</a>
<a name="ln1014">Attribute::InitCheck() const</a>
<a name="ln1015">{</a>
<a name="ln1016">	status_t status = DataStream::InitCheck();</a>
<a name="ln1017">	if (status == B_OK)</a>
<a name="ln1018">		return IsAttribute() ? B_OK : B_ERROR;</a>
<a name="ln1019"> </a>
<a name="ln1020">	return status;</a>
<a name="ln1021">}</a>
<a name="ln1022"> </a>
<a name="ln1023"> </a>
<a name="ln1024">status_t</a>
<a name="ln1025">Attribute::CopyTo(const char */*path*/, bool /*fullPath*/,</a>
<a name="ln1026">	Inode::Source */*source*/)</a>
<a name="ln1027">{</a>
<a name="ln1028">	// files and directories already copy all attributes</a>
<a name="ln1029"> </a>
<a name="ln1030">	// eventually, this method should be implemented to recover lost</a>
<a name="ln1031">	// attributes on the disk</a>
<a name="ln1032"> </a>
<a name="ln1033">	return B_OK;</a>
<a name="ln1034">}</a>
<a name="ln1035"> </a>
<a name="ln1036"> </a>
<a name="ln1037">//	#pragma mark -</a>
<a name="ln1038"> </a>
<a name="ln1039"> </a>
<a name="ln1040">Directory::Directory(Disk *disk, bfs_inode *inode, bool ownBuffer)</a>
<a name="ln1041">	: DataStream(disk, inode, ownBuffer),</a>
<a name="ln1042">	fTree(NULL)</a>
<a name="ln1043">{</a>
<a name="ln1044">}</a>
<a name="ln1045"> </a>
<a name="ln1046"> </a>
<a name="ln1047">Directory::Directory(const Inode &amp;inode)</a>
<a name="ln1048">	: DataStream(inode),</a>
<a name="ln1049">	fTree(NULL)</a>
<a name="ln1050">{</a>
<a name="ln1051">}</a>
<a name="ln1052"> </a>
<a name="ln1053"> </a>
<a name="ln1054">Directory::~Directory()</a>
<a name="ln1055">{</a>
<a name="ln1056">	delete fTree;</a>
<a name="ln1057">}</a>
<a name="ln1058"> </a>
<a name="ln1059"> </a>
<a name="ln1060">status_t</a>
<a name="ln1061">Directory::InitCheck() const</a>
<a name="ln1062">{</a>
<a name="ln1063">	status_t status = DataStream::InitCheck();</a>
<a name="ln1064">	if (status == B_OK)</a>
<a name="ln1065">		return (IsDirectory() || IsAttributeDirectory()) ? B_OK : B_ERROR;</a>
<a name="ln1066"> </a>
<a name="ln1067">	return status;</a>
<a name="ln1068">}</a>
<a name="ln1069"> </a>
<a name="ln1070"> </a>
<a name="ln1071">status_t</a>
<a name="ln1072">Directory::CopyTo(const char *root, bool fullPath, Inode::Source *source)</a>
<a name="ln1073">{</a>
<a name="ln1074">	// don't copy attributes or indices</a>
<a name="ln1075">	// the recovery program should make empty files to recover lost attributes</a>
<a name="ln1076">	if (IsAttributeDirectory() || IsIndex())</a>
<a name="ln1077">		return B_OK;</a>
<a name="ln1078"> </a>
<a name="ln1079">	status_t status = Inode::CopyTo(root, fullPath, source);</a>
<a name="ln1080">	if (status &lt; B_OK)</a>
<a name="ln1081">		return status;</a>
<a name="ln1082"> </a>
<a name="ln1083">	BPath path(root);</a>
<a name="ln1084">	if (fullPath &amp;&amp; Path(source))</a>
<a name="ln1085">		path.Append(Path(source));</a>
<a name="ln1086"> </a>
<a name="ln1087">	char *name = (char *)Name();</a>
<a name="ln1088">	if (name != NULL) {</a>
<a name="ln1089">		// changes the filename in the inode buffer (for deleted entries)</a>
<a name="ln1090">		if (!*name)</a>
<a name="ln1091">			*name = '_';</a>
<a name="ln1092">		path.Append(name);</a>
<a name="ln1093">	} else {</a>
<a name="ln1094">		// create unique name</a>
<a name="ln1095">		BString sub;</a>
<a name="ln1096">		sub &lt;&lt; &quot;__untitled &quot; &lt;&lt; BlockRun().allocation_group &lt;&lt; &quot;:&quot;</a>
<a name="ln1097">			&lt;&lt; (int32)BlockRun().start;</a>
<a name="ln1098">		path.Append(sub.String());</a>
<a name="ln1099">	}</a>
<a name="ln1100"> </a>
<a name="ln1101">	BEntry entry(path.Path());</a>
<a name="ln1102">	BDirectory directory;</a>
<a name="ln1103">	if ((status = entry.GetParent(&amp;directory)) &lt; B_OK)</a>
<a name="ln1104">		return status;</a>
<a name="ln1105"> </a>
<a name="ln1106">	status = directory.CreateDirectory(path.Leaf(), NULL);</a>
<a name="ln1107">	if (status &lt; B_OK &amp;&amp; status != B_FILE_EXISTS)</a>
<a name="ln1108">		return status;</a>
<a name="ln1109"> </a>
<a name="ln1110">	if ((status = directory.SetTo(&amp;entry)) &lt; B_OK)</a>
<a name="ln1111">		return status;</a>
<a name="ln1112"> </a>
<a name="ln1113">	return CopyAttributesTo(&amp;directory);</a>
<a name="ln1114">}</a>
<a name="ln1115"> </a>
<a name="ln1116"> </a>
<a name="ln1117">status_t</a>
<a name="ln1118">Directory::Rewind()</a>
<a name="ln1119">{</a>
<a name="ln1120">	if (!fTree) {</a>
<a name="ln1121">		status_t status = CreateTree();</a>
<a name="ln1122">		if (status &lt; B_OK)</a>
<a name="ln1123">			return status;</a>
<a name="ln1124">	}</a>
<a name="ln1125">	return fTree-&gt;Rewind();</a>
<a name="ln1126">}</a>
<a name="ln1127"> </a>
<a name="ln1128"> </a>
<a name="ln1129">status_t</a>
<a name="ln1130">Directory::GetNextEntry(char *name, block_run *run)</a>
<a name="ln1131">{</a>
<a name="ln1132">	status_t status;</a>
<a name="ln1133"> </a>
<a name="ln1134">	if (!fTree) {</a>
<a name="ln1135">		if ((status = Rewind()) &lt; B_OK)</a>
<a name="ln1136">			return status;</a>
<a name="ln1137">	}</a>
<a name="ln1138">	uint16 length;</a>
<a name="ln1139">	off_t offset;</a>
<a name="ln1140"> </a>
<a name="ln1141">	if ((status = fTree-&gt;GetNextEntry(name, &amp;length, B_FILE_NAME_LENGTH - 1,</a>
<a name="ln1142">			&amp;offset)) &lt; B_OK)</a>
<a name="ln1143">		return status;</a>
<a name="ln1144"> </a>
<a name="ln1145">	*run = fDisk-&gt;ToBlockRun(offset);</a>
<a name="ln1146"> </a>
<a name="ln1147">	return B_OK;</a>
<a name="ln1148">}</a>
<a name="ln1149"> </a>
<a name="ln1150"> </a>
<a name="ln1151">status_t</a>
<a name="ln1152">Directory::GetNextEntry(block_run *run)</a>
<a name="ln1153">{</a>
<a name="ln1154">	char name[B_FILE_NAME_LENGTH];</a>
<a name="ln1155"> </a>
<a name="ln1156">	return GetNextEntry(name, run);</a>
<a name="ln1157">}</a>
<a name="ln1158"> </a>
<a name="ln1159"> </a>
<a name="ln1160">status_t</a>
<a name="ln1161">Directory::Contains(const block_run *run)</a>
<a name="ln1162">{</a>
<a name="ln1163">	status_t status;</a>
<a name="ln1164"> </a>
<a name="ln1165">	if (!fTree) {</a>
<a name="ln1166">		if ((status = Rewind()) &lt; B_OK)</a>
<a name="ln1167">			return status;</a>
<a name="ln1168">	}</a>
<a name="ln1169"> </a>
<a name="ln1170">	block_run searchRun;</a>
<a name="ln1171">	while (GetNextEntry(&amp;searchRun) == B_OK) {</a>
<a name="ln1172">		if (searchRun == *run)</a>
<a name="ln1173">			return B_OK;</a>
<a name="ln1174">	}</a>
<a name="ln1175"> </a>
<a name="ln1176">	return B_ENTRY_NOT_FOUND;</a>
<a name="ln1177">}</a>
<a name="ln1178"> </a>
<a name="ln1179"> </a>
<a name="ln1180">status_t</a>
<a name="ln1181">Directory::Contains(const Inode *inode)</a>
<a name="ln1182">{</a>
<a name="ln1183">	status_t status;</a>
<a name="ln1184"> </a>
<a name="ln1185">	if (!fTree) {</a>
<a name="ln1186">		if ((status = CreateTree()) &lt; B_OK)</a>
<a name="ln1187">			return status;</a>
<a name="ln1188">	}</a>
<a name="ln1189"> </a>
<a name="ln1190">	off_t value;</a>
<a name="ln1191">	const char *name = inode-&gt;Name();</a>
<a name="ln1192">	status = B_ENTRY_NOT_FOUND;</a>
<a name="ln1193"> </a>
<a name="ln1194">	if (name &amp;&amp; (status = fTree-&gt;Find((uint8 *)name, (uint16)strlen(name),</a>
<a name="ln1195">			&amp;value)) == B_OK) {</a>
<a name="ln1196">		if (fDisk-&gt;ToBlockRun(value) == inode-&gt;InodeBuffer()-&gt;inode_num)</a>
<a name="ln1197">			return B_OK;</a>
<a name="ln1198"> </a>
<a name="ln1199">		printf(&quot;inode address do not match (%s)!\n&quot;, inode-&gt;Name());</a>
<a name="ln1200">	}</a>
<a name="ln1201"> </a>
<a name="ln1202">	if (status != B_OK &amp;&amp; status != B_ENTRY_NOT_FOUND)</a>
<a name="ln1203">		return status;</a>
<a name="ln1204"> </a>
<a name="ln1205">	return Contains(&amp;inode-&gt;InodeBuffer()-&gt;inode_num);</a>
<a name="ln1206">}</a>
<a name="ln1207"> </a>
<a name="ln1208"> </a>
<a name="ln1209">status_t</a>
<a name="ln1210">Directory::FindEntry(const char *name, block_run *run)</a>
<a name="ln1211">{</a>
<a name="ln1212">	status_t status;</a>
<a name="ln1213"> </a>
<a name="ln1214">	if (!name)</a>
<a name="ln1215">		return B_BAD_VALUE;</a>
<a name="ln1216"> </a>
<a name="ln1217">	if (!fTree) {</a>
<a name="ln1218">		if ((status = CreateTree()) &lt; B_OK)</a>
<a name="ln1219">			return status;</a>
<a name="ln1220">	}</a>
<a name="ln1221"> </a>
<a name="ln1222">	off_t value;</a>
<a name="ln1223"> </a>
<a name="ln1224">	if ((status = fTree-&gt;Find((uint8 *)name, (uint16)strlen(name),</a>
<a name="ln1225">			&amp;value)) &gt;= B_OK) {</a>
<a name="ln1226">		if (run)</a>
<a name="ln1227">			*run = fDisk-&gt;ToBlockRun(value);</a>
<a name="ln1228">		return B_OK;</a>
<a name="ln1229">	}</a>
<a name="ln1230">	return status;</a>
<a name="ln1231">}</a>
<a name="ln1232"> </a>
<a name="ln1233"> </a>
<a name="ln1234">status_t</a>
<a name="ln1235">Directory::AddEntry(Inode *inode)</a>
<a name="ln1236">{</a>
<a name="ln1237">	status_t status;</a>
<a name="ln1238">	bool created = false;</a>
<a name="ln1239"> </a>
<a name="ln1240">	if (!fTree) {</a>
<a name="ln1241">		status = CreateTree();</a>
<a name="ln1242">		if (status == B_OK)</a>
<a name="ln1243">			status = fTree-&gt;Validate();</a>
<a name="ln1244"> </a>
<a name="ln1245">		if (status == B_BAD_DATA) {</a>
<a name="ln1246">			//puts(&quot;bplustree corrupted!&quot;);</a>
<a name="ln1247">			fTree = new BPlusTree(BPLUSTREE_STRING_TYPE, BPLUSTREE_NODE_SIZE,</a>
<a name="ln1248">				false);</a>
<a name="ln1249">			if ((status = fTree-&gt;InitCheck()) &lt; B_OK) {</a>
<a name="ln1250">				delete fTree;</a>
<a name="ln1251">				fTree = NULL;</a>
<a name="ln1252">			} else</a>
<a name="ln1253">				created = true;</a>
<a name="ln1254">		}</a>
<a name="ln1255"> </a>
<a name="ln1256">		if (status &lt; B_OK)</a>
<a name="ln1257">			return status;</a>
<a name="ln1258">	}</a>
<a name="ln1259">	// keep all changes in memory</a>
<a name="ln1260">	fTree-&gt;SetHoldChanges(true);</a>
<a name="ln1261"> </a>
<a name="ln1262">	if (created) {</a>
<a name="ln1263">		// add . and ..</a>
<a name="ln1264">		fTree-&gt;Insert(&quot;.&quot;, Block());</a>
<a name="ln1265">		fTree-&gt;Insert(&quot;..&quot;, fDisk-&gt;ToBlock(Parent()));</a>
<a name="ln1266">	}</a>
<a name="ln1267"> </a>
<a name="ln1268">	if (inode-&gt;Flags() &amp; INODE_DELETED)</a>
<a name="ln1269">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln1270"> </a>
<a name="ln1271">	BString name = inode-&gt;Name();</a>
<a name="ln1272">	if (name == &quot;&quot;) {</a>
<a name="ln1273">		name &lt;&lt; &quot;__file &quot; &lt;&lt; inode-&gt;BlockRun().allocation_group &lt;&lt; &quot;:&quot;</a>
<a name="ln1274">			&lt;&lt; (int32)inode-&gt;BlockRun().start;</a>
<a name="ln1275">	}</a>
<a name="ln1276"> </a>
<a name="ln1277">	return fTree-&gt;Insert(name.String(), inode-&gt;Block());</a>
<a name="ln1278">}</a>
<a name="ln1279"> </a>
<a name="ln1280"> </a>
<a name="ln1281">status_t</a>
<a name="ln1282">Directory::CreateTree()</a>
<a name="ln1283">{</a>
<a name="ln1284">	fTree = new BPlusTree(this);</a>
<a name="ln1285"> </a>
<a name="ln1286">	status_t status = fTree-&gt;InitCheck();</a>
<a name="ln1287">	if (status &lt; B_OK) {</a>
<a name="ln1288">		delete fTree;</a>
<a name="ln1289">		fTree = NULL;</a>
<a name="ln1290">		return status;</a>
<a name="ln1291">	}</a>
<a name="ln1292">	return B_OK;</a>
<a name="ln1293">}</a>
<a name="ln1294"> </a>
<a name="ln1295"> </a>
<a name="ln1296">status_t</a>
<a name="ln1297">Directory::GetTree(BPlusTree **tree)</a>
<a name="ln1298">{</a>
<a name="ln1299">	if (!fTree) {</a>
<a name="ln1300">		status_t status = CreateTree();</a>
<a name="ln1301">		if (status &lt; B_OK)</a>
<a name="ln1302">			return status;</a>
<a name="ln1303">	}</a>
<a name="ln1304">	*tree = fTree;</a>
<a name="ln1305">	return B_OK;</a>
<a name="ln1306">}</a>
<a name="ln1307"> </a>
<a name="ln1308"> </a>
<a name="ln1309">//	#pragma mark -</a>
<a name="ln1310"> </a>
<a name="ln1311"> </a>
<a name="ln1312">Symlink::Symlink(Disk *disk, bfs_inode *inode,bool ownBuffer)</a>
<a name="ln1313">	: Inode(disk,inode,ownBuffer)</a>
<a name="ln1314">{</a>
<a name="ln1315">}</a>
<a name="ln1316"> </a>
<a name="ln1317"> </a>
<a name="ln1318">Symlink::Symlink(const Inode &amp;inode)</a>
<a name="ln1319">	: Inode(inode)</a>
<a name="ln1320">{</a>
<a name="ln1321">}</a>
<a name="ln1322"> </a>
<a name="ln1323"> </a>
<a name="ln1324">Symlink::~Symlink()</a>
<a name="ln1325">{</a>
<a name="ln1326">}</a>
<a name="ln1327"> </a>
<a name="ln1328"> </a>
<a name="ln1329">status_t</a>
<a name="ln1330">Symlink::InitCheck() const</a>
<a name="ln1331">{</a>
<a name="ln1332">	status_t status = Inode::InitCheck();</a>
<a name="ln1333">	if (status == B_OK)</a>
<a name="ln1334">		return IsSymlink() ? B_OK : B_ERROR;</a>
<a name="ln1335"> </a>
<a name="ln1336">	return status;</a>
<a name="ln1337">}</a>
<a name="ln1338"> </a>
<a name="ln1339"> </a>
<a name="ln1340">status_t</a>
<a name="ln1341">Symlink::CopyTo(const char *root, bool fullPath,Inode::Source *source)</a>
<a name="ln1342">{</a>
<a name="ln1343">	status_t status = Inode::CopyTo(root,fullPath,source);</a>
<a name="ln1344">	if (status &lt; B_OK)</a>
<a name="ln1345">		return status;</a>
<a name="ln1346"> </a>
<a name="ln1347">	BPath path(root);</a>
<a name="ln1348">	if (fullPath &amp;&amp; Path(source))</a>
<a name="ln1349">		path.Append(Path(source));</a>
<a name="ln1350"> </a>
<a name="ln1351">	char *name = (char *)Name();</a>
<a name="ln1352">	if (name != NULL) {</a>
<a name="ln1353">		// changes the filename in the inode buffer (for deleted entries)</a>
<a name="ln1354">		if (!*name)</a>
<a name="ln1355">			*name = '_';</a>
<a name="ln1356">		path.Append(name);</a>
<a name="ln1357">	} else {</a>
<a name="ln1358">		// create unique name</a>
<a name="ln1359">		BString sub;</a>
<a name="ln1360">		sub &lt;&lt; &quot;__symlink &quot; &lt;&lt; BlockRun().allocation_group &lt;&lt; &quot;:&quot;</a>
<a name="ln1361">			&lt;&lt; (int32)BlockRun().start;</a>
<a name="ln1362">		path.Append(sub.String());</a>
<a name="ln1363">	}</a>
<a name="ln1364"> </a>
<a name="ln1365">	BEntry entry(path.Path());</a>
<a name="ln1366">	BDirectory directory;</a>
<a name="ln1367">	if ((status = entry.GetParent(&amp;directory)) &lt; B_OK)</a>
<a name="ln1368">		return status;</a>
<a name="ln1369"> </a>
<a name="ln1370">	char to[2048];</a>
<a name="ln1371">	if (LinksTo(to,sizeof(to)) &lt; B_OK)</a>
<a name="ln1372">		return B_ERROR;</a>
<a name="ln1373"> </a>
<a name="ln1374">	BSymLink link;</a>
<a name="ln1375">	status = directory.CreateSymLink(path.Leaf(),to,&amp;link);</a>
<a name="ln1376">	if (status &lt; B_OK &amp;&amp; status != B_FILE_EXISTS)</a>
<a name="ln1377">		return status;</a>
<a name="ln1378"> </a>
<a name="ln1379">	if ((status = link.SetTo(&amp;entry)) &lt; B_OK)</a>
<a name="ln1380">		return status;</a>
<a name="ln1381"> </a>
<a name="ln1382">	return CopyAttributesTo(&amp;link);</a>
<a name="ln1383">}</a>
<a name="ln1384"> </a>
<a name="ln1385"> </a>
<a name="ln1386">status_t</a>
<a name="ln1387">Symlink::LinksTo(char *to,size_t maxLength)</a>
<a name="ln1388">{</a>
<a name="ln1389">	if ((fInode-&gt;flags &amp; INODE_LONG_SYMLINK) == 0) {</a>
<a name="ln1390">		strcpy(to,fInode-&gt;short_symlink);</a>
<a name="ln1391">		return B_OK;</a>
<a name="ln1392">	}</a>
<a name="ln1393"> </a>
<a name="ln1394">	DataStream stream(*this);</a>
<a name="ln1395">	status_t status = stream.InitCheck();</a>
<a name="ln1396">	if (status &lt; B_OK)</a>
<a name="ln1397">		return status;</a>
<a name="ln1398"> </a>
<a name="ln1399">	status = stream.Read(to,maxLength);</a>
<a name="ln1400"> </a>
<a name="ln1401">	return status &lt; B_OK ? status : B_OK;</a>
<a name="ln1402">}</a>
<a name="ln1403"> </a>

</code></pre>
<div class="balloon" rel="676"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v629/" target="_blank">V629</a> Consider inspecting the 'fRun.length << fDisk->BlockShift()' expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type.</p></div>
<div class="balloon" rel="1312"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fTo.</p></div>
<div class="balloon" rel="1318"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fTo.</p></div>
<div class="balloon" rel="732"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v629/" target="_blank">V629</a> Consider inspecting the expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type.</p></div>
<div class="balloon" rel="756"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v629/" target="_blank">V629</a> Consider inspecting the expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type.</p></div>
<div class="balloon" rel="909"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v629/" target="_blank">V629</a> Consider inspecting the expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
