
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>PathManipulator.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2006-2009, Stephan AÃŸmus &lt;superstippi@gmx.de&gt;.</a>
<a name="ln3"> * All rights reserved. Distributed under the terms of the MIT License.</a>
<a name="ln4"> */</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;PathManipulator.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;float.h&gt;</a>
<a name="ln9">#include &lt;stdio.h&gt;</a>
<a name="ln10"> </a>
<a name="ln11">#include &lt;Catalog.h&gt;</a>
<a name="ln12">#include &lt;Cursor.h&gt;</a>
<a name="ln13">#include &lt;Locale.h&gt;</a>
<a name="ln14">#include &lt;Message.h&gt;</a>
<a name="ln15">#include &lt;MenuItem.h&gt;</a>
<a name="ln16">#include &lt;PopUpMenu.h&gt;</a>
<a name="ln17">#include &lt;StackOrHeapArray.h&gt;</a>
<a name="ln18">#include &lt;Window.h&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;cursors.h&quot;</a>
<a name="ln21">#include &quot;support.h&quot;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;CanvasView.h&quot;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;AddPointCommand.h&quot;</a>
<a name="ln26">#include &quot;ChangePointCommand.h&quot;</a>
<a name="ln27">//#include &quot;CloseCommand.h&quot;</a>
<a name="ln28">#include &quot;InsertPointCommand.h&quot;</a>
<a name="ln29">#include &quot;FlipPointsCommand.h&quot;</a>
<a name="ln30">//#include &quot;NewPathCommand.h&quot;</a>
<a name="ln31">#include &quot;NudgePointsCommand.h&quot;</a>
<a name="ln32">//#include &quot;RemovePathCommand.h&quot;</a>
<a name="ln33">#include &quot;RemovePointsCommand.h&quot;</a>
<a name="ln34">//#include &quot;ReversePathCommand.h&quot;</a>
<a name="ln35">//#include &quot;SelectPathCommand.h&quot;</a>
<a name="ln36">//#include &quot;SelectPointsCommand.h&quot;</a>
<a name="ln37">#include &quot;SplitPointsCommand.h&quot;</a>
<a name="ln38">#include &quot;TransformPointsBox.h&quot;</a>
<a name="ln39"> </a>
<a name="ln40"> </a>
<a name="ln41">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln42">#define B_TRANSLATION_CONTEXT &quot;Icon-O-Matic-PathManipulator&quot;</a>
<a name="ln43">#define POINT_EXTEND 3.0</a>
<a name="ln44">#define CONTROL_POINT_EXTEND 2.0</a>
<a name="ln45">#define INSERT_DIST_THRESHOLD 7.0</a>
<a name="ln46">#define MOVE_THRESHOLD 9.0</a>
<a name="ln47"> </a>
<a name="ln48"> </a>
<a name="ln49">enum {</a>
<a name="ln50">	UNDEFINED,</a>
<a name="ln51"> </a>
<a name="ln52">	NEW_PATH,</a>
<a name="ln53"> </a>
<a name="ln54">	ADD_POINT,</a>
<a name="ln55">	INSERT_POINT,</a>
<a name="ln56">	MOVE_POINT,</a>
<a name="ln57">	MOVE_POINT_IN,</a>
<a name="ln58">	MOVE_POINT_OUT,</a>
<a name="ln59">	CLOSE_PATH,</a>
<a name="ln60"> </a>
<a name="ln61">	TOGGLE_SHARP,</a>
<a name="ln62">	TOGGLE_SHARP_IN,</a>
<a name="ln63">	TOGGLE_SHARP_OUT,</a>
<a name="ln64"> </a>
<a name="ln65">	REMOVE_POINT,</a>
<a name="ln66">	REMOVE_POINT_IN,</a>
<a name="ln67">	REMOVE_POINT_OUT,</a>
<a name="ln68"> </a>
<a name="ln69">	SELECT_POINTS,</a>
<a name="ln70">	TRANSFORM_POINTS,</a>
<a name="ln71">	TRANSLATE_POINTS,</a>
<a name="ln72"> </a>
<a name="ln73">	SELECT_SUB_PATH,</a>
<a name="ln74">};</a>
<a name="ln75"> </a>
<a name="ln76">enum {</a>
<a name="ln77">	MSG_TRANSFORM				= 'strn',</a>
<a name="ln78">	MSG_REMOVE_POINTS			= 'srmp',</a>
<a name="ln79">	MSG_UPDATE_SHAPE_UI			= 'udsi',</a>
<a name="ln80"> </a>
<a name="ln81">	MSG_SPLIT_POINTS			= 'splt',</a>
<a name="ln82">	MSG_FLIP_POINTS				= 'flip',</a>
<a name="ln83">};</a>
<a name="ln84"> </a>
<a name="ln85">inline const char*</a>
<a name="ln86">string_for_mode(uint32 mode)</a>
<a name="ln87">{</a>
<a name="ln88">	switch (mode) {</a>
<a name="ln89">		case UNDEFINED:</a>
<a name="ln90">			return &quot;UNDEFINED&quot;;</a>
<a name="ln91">		case NEW_PATH:</a>
<a name="ln92">			return &quot;NEW_PATH&quot;;</a>
<a name="ln93">		case ADD_POINT:</a>
<a name="ln94">			return &quot;ADD_POINT&quot;;</a>
<a name="ln95">		case INSERT_POINT:</a>
<a name="ln96">			return &quot;INSERT_POINT&quot;;</a>
<a name="ln97">		case MOVE_POINT:</a>
<a name="ln98">			return &quot;MOVE_POINT&quot;;</a>
<a name="ln99">		case MOVE_POINT_IN:</a>
<a name="ln100">			return &quot;MOVE_POINT_IN&quot;;</a>
<a name="ln101">		case MOVE_POINT_OUT:</a>
<a name="ln102">			return &quot;MOVE_POINT_OUT&quot;;</a>
<a name="ln103">		case CLOSE_PATH:</a>
<a name="ln104">			return &quot;CLOSE_PATH&quot;;</a>
<a name="ln105">		case TOGGLE_SHARP:</a>
<a name="ln106">			return &quot;TOGGLE_SHARP&quot;;</a>
<a name="ln107">		case TOGGLE_SHARP_IN:</a>
<a name="ln108">			return &quot;TOGGLE_SHARP_IN&quot;;</a>
<a name="ln109">		case TOGGLE_SHARP_OUT:</a>
<a name="ln110">			return &quot;TOGGLE_SHARP_OUT&quot;;</a>
<a name="ln111">		case REMOVE_POINT:</a>
<a name="ln112">			return &quot;REMOVE_POINT&quot;;</a>
<a name="ln113">		case REMOVE_POINT_IN:</a>
<a name="ln114">			return &quot;REMOVE_POINT_IN&quot;;</a>
<a name="ln115">		case REMOVE_POINT_OUT:</a>
<a name="ln116">			return &quot;REMOVE_POINT_OUT&quot;;</a>
<a name="ln117">		case SELECT_POINTS:</a>
<a name="ln118">			return &quot;SELECT_POINTS&quot;;</a>
<a name="ln119">		case TRANSFORM_POINTS:</a>
<a name="ln120">			return &quot;TRANSFORM_POINTS&quot;;</a>
<a name="ln121">		case TRANSLATE_POINTS:</a>
<a name="ln122">			return &quot;TRANSLATE_POINTS&quot;;</a>
<a name="ln123">		case SELECT_SUB_PATH:</a>
<a name="ln124">			return &quot;SELECT_SUB_PATH&quot;;</a>
<a name="ln125">	}</a>
<a name="ln126">	return &quot;&lt;unknown mode&gt;&quot;;</a>
<a name="ln127">}</a>
<a name="ln128"> </a>
<a name="ln129">class PathManipulator::Selection : protected BList</a>
<a name="ln130">{</a>
<a name="ln131">public:</a>
<a name="ln132">	inline Selection(int32 count = 20)</a>
<a name="ln133">		: BList(count) {}</a>
<a name="ln134">	inline ~Selection() {}</a>
<a name="ln135"> </a>
<a name="ln136">	inline void Add(int32 value)</a>
<a name="ln137">		{</a>
<a name="ln138">			if (value &gt;= 0) {</a>
<a name="ln139">				// keep the list sorted</a>
<a name="ln140">				int32 count = CountItems();</a>
<a name="ln141">				int32 index = 0;</a>
<a name="ln142">				for (; index &lt; count; index++) {</a>
<a name="ln143">					if (IndexAt(index) &gt; value) {</a>
<a name="ln144">						break;</a>
<a name="ln145">					}</a>
<a name="ln146">				}</a>
<a name="ln147">				BList::AddItem((void*)(long)value, index);</a>
<a name="ln148">			}</a>
<a name="ln149">		}</a>
<a name="ln150"> </a>
<a name="ln151">	inline bool Remove(int32 value)</a>
<a name="ln152">		{ return BList::RemoveItem((void*)(long)value); }</a>
<a name="ln153"> </a>
<a name="ln154">	inline bool Contains(int32 value) const</a>
<a name="ln155">		{ return BList::HasItem((void*)(long)value); }</a>
<a name="ln156"> </a>
<a name="ln157">	inline bool IsEmpty() const</a>
<a name="ln158">		{ return BList::IsEmpty(); }</a>
<a name="ln159"> </a>
<a name="ln160">	inline int32 IndexAt(int32 index) const</a>
<a name="ln161">		{ return (int32)(long)BList::ItemAt(index); }</a>
<a name="ln162"> </a>
<a name="ln163">	inline void MakeEmpty()</a>
<a name="ln164">		{ BList::MakeEmpty(); }</a>
<a name="ln165"> </a>
<a name="ln166">	inline int32* Items() const</a>
<a name="ln167">		{ return (int32*)BList::Items(); }</a>
<a name="ln168"> </a>
<a name="ln169">	inline const int32 CountItems() const</a>
<a name="ln170">		{ return BList::CountItems(); }</a>
<a name="ln171"> </a>
<a name="ln172">	inline Selection&amp; operator =(const Selection&amp; other)</a>
<a name="ln173">		{</a>
<a name="ln174">			MakeEmpty();</a>
<a name="ln175">			int32 count = other.CountItems();</a>
<a name="ln176">			int32* items = other.Items();</a>
<a name="ln177">			for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln178">				Add(items[i]);</a>
<a name="ln179">			}</a>
<a name="ln180">			return *this;</a>
<a name="ln181">		}</a>
<a name="ln182"> </a>
<a name="ln183">	inline bool operator ==(const Selection&amp; other)</a>
<a name="ln184">		{</a>
<a name="ln185">			if (other.CountItems() == CountItems()) {</a>
<a name="ln186">				int32* items = Items();</a>
<a name="ln187">				int32* otherItems = other.Items();</a>
<a name="ln188">				for (int32 i = 0; i &lt; CountItems(); i++) {</a>
<a name="ln189">					if (items[i] != otherItems[i])</a>
<a name="ln190">						return false;</a>
<a name="ln191">					items++;</a>
<a name="ln192">					otherItems++;</a>
<a name="ln193">				}</a>
<a name="ln194">				return true;</a>
<a name="ln195">			} else</a>
<a name="ln196">				return false;</a>
<a name="ln197">		}</a>
<a name="ln198"> </a>
<a name="ln199">	inline bool operator !=(const Selection&amp; other)</a>
<a name="ln200">	{</a>
<a name="ln201">		return !(*this == other);</a>
<a name="ln202">	}</a>
<a name="ln203">};</a>
<a name="ln204"> </a>
<a name="ln205"> </a>
<a name="ln206">// constructor</a>
<a name="ln207">PathManipulator::PathManipulator(VectorPath* path)</a>
<a name="ln208">	: Manipulator(NULL),</a>
<a name="ln209">	  fCanvasView(NULL),</a>
<a name="ln210"> </a>
<a name="ln211">	  fCommandDown(false),</a>
<a name="ln212">	  fOptionDown(false),</a>
<a name="ln213">	  fShiftDown(false),</a>
<a name="ln214">	  fAltDown(false),</a>
<a name="ln215"> </a>
<a name="ln216">	  fClickToClose(false),</a>
<a name="ln217"> </a>
<a name="ln218">	  fMode(NEW_PATH),</a>
<a name="ln219">	  fFallBackMode(SELECT_POINTS),</a>
<a name="ln220"> </a>
<a name="ln221">	  fMouseDown(false),</a>
<a name="ln222"> </a>
<a name="ln223">	  fPath(path),</a>
<a name="ln224">	  fCurrentPathPoint(-1),</a>
<a name="ln225"> </a>
<a name="ln226">	  fChangePointCommand(NULL),</a>
<a name="ln227">	  fInsertPointCommand(NULL),</a>
<a name="ln228">	  fAddPointCommand(NULL),</a>
<a name="ln229"> </a>
<a name="ln230">	  fSelection(new Selection()),</a>
<a name="ln231">	  fOldSelection(new Selection()),</a>
<a name="ln232">	  fTransformBox(NULL),</a>
<a name="ln233"> </a>
<a name="ln234">	  fNudgeOffset(0.0, 0.0),</a>
<a name="ln235">	  fLastNudgeTime(system_time()),</a>
<a name="ln236">	  fNudgeCommand(NULL)</a>
<a name="ln237">{</a>
<a name="ln238">	fPath-&gt;AcquireReference();</a>
<a name="ln239">	fPath-&gt;AddListener(this);</a>
<a name="ln240">	fPath-&gt;AddObserver(this);</a>
<a name="ln241">}</a>
<a name="ln242"> </a>
<a name="ln243">// destructor</a>
<a name="ln244">PathManipulator::~PathManipulator()</a>
<a name="ln245">{</a>
<a name="ln246">	delete fChangePointCommand;</a>
<a name="ln247">	delete fInsertPointCommand;</a>
<a name="ln248">	delete fAddPointCommand;</a>
<a name="ln249"> </a>
<a name="ln250">	delete fSelection;</a>
<a name="ln251">	delete fOldSelection;</a>
<a name="ln252">	delete fTransformBox;</a>
<a name="ln253"> </a>
<a name="ln254">	delete fNudgeCommand;</a>
<a name="ln255"> </a>
<a name="ln256">	fPath-&gt;RemoveObserver(this);</a>
<a name="ln257">	fPath-&gt;RemoveListener(this);</a>
<a name="ln258">	fPath-&gt;ReleaseReference();</a>
<a name="ln259">}</a>
<a name="ln260"> </a>
<a name="ln261"> </a>
<a name="ln262">// #pragma mark -</a>
<a name="ln263"> </a>
<a name="ln264">class StrokePathIterator : public VectorPath::Iterator {</a>
<a name="ln265"> public:</a>
<a name="ln266">					StrokePathIterator(CanvasView* canvasView,</a>
<a name="ln267">									   BView* drawingView)</a>
<a name="ln268">						: fCanvasView(canvasView),</a>
<a name="ln269">						  fDrawingView(drawingView)</a>
<a name="ln270">					{</a>
<a name="ln271">						fDrawingView-&gt;SetHighColor(0, 0, 0, 255);</a>
<a name="ln272">						fDrawingView-&gt;SetDrawingMode(B_OP_OVER);</a>
<a name="ln273">					}</a>
<a name="ln274">	virtual			~StrokePathIterator()</a>
<a name="ln275">					{}</a>
<a name="ln276"> </a>
<a name="ln277">	virtual	void	MoveTo(BPoint point)</a>
<a name="ln278">					{</a>
<a name="ln279">						fBlack = true;</a>
<a name="ln280">						fSkip = false;</a>
<a name="ln281">						fDrawingView-&gt;SetHighColor(0, 0, 0, 255);</a>
<a name="ln282"> </a>
<a name="ln283">						fCanvasView-&gt;ConvertFromCanvas(&amp;point);</a>
<a name="ln284">						fDrawingView-&gt;MovePenTo(point);</a>
<a name="ln285">					}</a>
<a name="ln286">	virtual	void	LineTo(BPoint point)</a>
<a name="ln287">					{</a>
<a name="ln288">						fCanvasView-&gt;ConvertFromCanvas(&amp;point);</a>
<a name="ln289">						if (!fSkip) {</a>
<a name="ln290">							if (fBlack)</a>
<a name="ln291">								fDrawingView-&gt;SetHighColor(255, 255, 255, 255);</a>
<a name="ln292">							else</a>
<a name="ln293">								fDrawingView-&gt;SetHighColor(0, 0, 0, 255);</a>
<a name="ln294">							fBlack = !fBlack;</a>
<a name="ln295">	</a>
<a name="ln296">							fDrawingView-&gt;StrokeLine(point);</a>
<a name="ln297">						} else {</a>
<a name="ln298">							fDrawingView-&gt;MovePenTo(point);</a>
<a name="ln299">						}</a>
<a name="ln300">						fSkip = !fSkip;</a>
<a name="ln301">					}</a>
<a name="ln302"> </a>
<a name="ln303"> private:</a>
<a name="ln304">	CanvasView*		fCanvasView;</a>
<a name="ln305">	BView*			fDrawingView;</a>
<a name="ln306">	bool			fBlack;</a>
<a name="ln307">	bool			fSkip;</a>
<a name="ln308">};</a>
<a name="ln309"> </a>
<a name="ln310">// Draw</a>
<a name="ln311">void</a>
<a name="ln312">PathManipulator::Draw(BView* into, BRect updateRect)</a>
<a name="ln313">{</a>
<a name="ln314">	// draw the Bezier curve, but only if not &quot;editing&quot;,</a>
<a name="ln315">	// the path is actually on top all other modifiers</a>
<a name="ln316">	// TODO: make this customizable in the GUI</a>
<a name="ln317"> </a>
<a name="ln318">	#if __HAIKU__</a>
<a name="ln319">	uint32 flags = into-&gt;Flags();</a>
<a name="ln320">	into-&gt;SetFlags(flags | B_SUBPIXEL_PRECISE);</a>
<a name="ln321">	#endif // __HAIKU__</a>
<a name="ln322"> </a>
<a name="ln323">	StrokePathIterator iterator(fCanvasView, into);</a>
<a name="ln324">	fPath-&gt;Iterate(&amp;iterator, fCanvasView-&gt;ZoomLevel());</a>
<a name="ln325"> </a>
<a name="ln326">	#if __HAIKU__</a>
<a name="ln327">	into-&gt;SetFlags(flags);</a>
<a name="ln328">	#endif // __HAIKU__</a>
<a name="ln329"> </a>
<a name="ln330">	into-&gt;SetLowColor(0, 0, 0, 255);</a>
<a name="ln331">	BPoint point;</a>
<a name="ln332">	BPoint pointIn;</a>
<a name="ln333">	BPoint pointOut;</a>
<a name="ln334">	rgb_color focusColor = (rgb_color){ 255, 0, 0, 255 };</a>
<a name="ln335">	rgb_color highlightColor = (rgb_color){ 60, 60, 255, 255 };</a>
<a name="ln336">	for (int32 i = 0; fPath-&gt;GetPointsAt(i, point, pointIn, pointOut); i++) {</a>
<a name="ln337">		bool highlight = fCurrentPathPoint == i;</a>
<a name="ln338">		bool selected = fSelection-&gt;Contains(i);</a>
<a name="ln339">		rgb_color normal = selected ? focusColor : (rgb_color){ 0, 0, 0, 255 };</a>
<a name="ln340">		into-&gt;SetLowColor(normal);</a>
<a name="ln341">		into-&gt;SetHighColor(255, 255, 255, 255);</a>
<a name="ln342">		// convert to view coordinate space</a>
<a name="ln343">		fCanvasView-&gt;ConvertFromCanvas(&amp;point);</a>
<a name="ln344">		fCanvasView-&gt;ConvertFromCanvas(&amp;pointIn);</a>
<a name="ln345">		fCanvasView-&gt;ConvertFromCanvas(&amp;pointOut);</a>
<a name="ln346">		// connect the points belonging to one control point</a>
<a name="ln347">		into-&gt;SetDrawingMode(B_OP_INVERT);</a>
<a name="ln348">		into-&gt;StrokeLine(point, pointIn);</a>
<a name="ln349">		into-&gt;StrokeLine(point, pointOut);</a>
<a name="ln350">		// draw main control point</a>
<a name="ln351">		if (highlight &amp;&amp; (fMode == MOVE_POINT ||</a>
<a name="ln352">						  fMode == TOGGLE_SHARP ||</a>
<a name="ln353">						  fMode == REMOVE_POINT ||</a>
<a name="ln354">						  fMode == SELECT_POINTS ||</a>
<a name="ln355">						  fMode == CLOSE_PATH)) {</a>
<a name="ln356"> </a>
<a name="ln357">			into-&gt;SetLowColor(highlightColor);</a>
<a name="ln358">		}</a>
<a name="ln359"> </a>
<a name="ln360">		into-&gt;SetDrawingMode(B_OP_COPY);</a>
<a name="ln361">		BRect r(point, point);</a>
<a name="ln362">		r.InsetBy(-POINT_EXTEND, -POINT_EXTEND);</a>
<a name="ln363">		into-&gt;StrokeRect(r, B_SOLID_LOW);</a>
<a name="ln364">		r.InsetBy(1.0, 1.0);</a>
<a name="ln365">		into-&gt;FillRect(r, B_SOLID_HIGH);</a>
<a name="ln366">		// draw in control point</a>
<a name="ln367">		if (highlight &amp;&amp; (fMode == MOVE_POINT_IN ||</a>
<a name="ln368">						  fMode == TOGGLE_SHARP_IN ||</a>
<a name="ln369">						  fMode == REMOVE_POINT_IN ||</a>
<a name="ln370">						  fMode == SELECT_POINTS))</a>
<a name="ln371">			into-&gt;SetLowColor(highlightColor);</a>
<a name="ln372">		else</a>
<a name="ln373">			into-&gt;SetLowColor(normal);</a>
<a name="ln374">		if (selected) {</a>
<a name="ln375">			into-&gt;SetHighColor(220, 220, 220, 255);</a>
<a name="ln376">		} else {</a>
<a name="ln377">			into-&gt;SetHighColor(170, 170, 170, 255);</a>
<a name="ln378">		}</a>
<a name="ln379">		if (pointIn != point) {</a>
<a name="ln380">			r.Set(pointIn.x - CONTROL_POINT_EXTEND, pointIn.y - CONTROL_POINT_EXTEND,</a>
<a name="ln381">				  pointIn.x + CONTROL_POINT_EXTEND, pointIn.y + CONTROL_POINT_EXTEND);</a>
<a name="ln382">			into-&gt;StrokeRect(r, B_SOLID_LOW);</a>
<a name="ln383">			r.InsetBy(1.0, 1.0);</a>
<a name="ln384">			into-&gt;FillRect(r, B_SOLID_HIGH);</a>
<a name="ln385">		}</a>
<a name="ln386">		// draw out control point</a>
<a name="ln387">		if (highlight &amp;&amp; (fMode == MOVE_POINT_OUT ||</a>
<a name="ln388">						  fMode == TOGGLE_SHARP_OUT ||</a>
<a name="ln389">						  fMode == REMOVE_POINT_OUT ||</a>
<a name="ln390">						  fMode == SELECT_POINTS))</a>
<a name="ln391">			into-&gt;SetLowColor(highlightColor);</a>
<a name="ln392">		else</a>
<a name="ln393">			into-&gt;SetLowColor(normal);</a>
<a name="ln394">		if (pointOut != point) {</a>
<a name="ln395">			r.Set(pointOut.x - CONTROL_POINT_EXTEND, pointOut.y - CONTROL_POINT_EXTEND,</a>
<a name="ln396">				  pointOut.x + CONTROL_POINT_EXTEND, pointOut.y + CONTROL_POINT_EXTEND);</a>
<a name="ln397">			into-&gt;StrokeRect(r, B_SOLID_LOW);</a>
<a name="ln398">			r.InsetBy(1.0, 1.0);</a>
<a name="ln399">			into-&gt;FillRect(r, B_SOLID_HIGH);</a>
<a name="ln400">		}</a>
<a name="ln401">	}</a>
<a name="ln402"> </a>
<a name="ln403">	if (fTransformBox) {</a>
<a name="ln404">		fTransformBox-&gt;Draw(into, updateRect);</a>
<a name="ln405">	}</a>
<a name="ln406">}</a>
<a name="ln407"> </a>
<a name="ln408">// #pragma mark -</a>
<a name="ln409"> </a>
<a name="ln410">// MouseDown</a>
<a name="ln411">bool</a>
<a name="ln412">PathManipulator::MouseDown(BPoint where)</a>
<a name="ln413">{</a>
<a name="ln414">	fMouseDown = true;</a>
<a name="ln415"> </a>
<a name="ln416">	if (fMode == TRANSFORM_POINTS) {</a>
<a name="ln417">		if (fTransformBox) {</a>
<a name="ln418">			fTransformBox-&gt;MouseDown(where);</a>
<a name="ln419"> </a>
<a name="ln420">//			if (!fTransformBox-&gt;IsRotating())</a>
<a name="ln421">//				fCanvasView-&gt;SetAutoScrolling(true);</a>
<a name="ln422">		}</a>
<a name="ln423">		return true;</a>
<a name="ln424">	}</a>
<a name="ln425"> </a>
<a name="ln426">	if (fMode == MOVE_POINT &amp;&amp;</a>
<a name="ln427">		fSelection-&gt;CountItems() &gt; 1 &amp;&amp;</a>
<a name="ln428">		fSelection-&gt;Contains(fCurrentPathPoint)) {</a>
<a name="ln429">		fMode = TRANSLATE_POINTS;</a>
<a name="ln430">	}</a>
<a name="ln431"> </a>
<a name="ln432">	// apply the canvas view mouse filter depending on current mode</a>
<a name="ln433">	if (fMode == ADD_POINT || fMode == TRANSLATE_POINTS)</a>
<a name="ln434">		fCanvasView-&gt;FilterMouse(&amp;where);</a>
<a name="ln435"> </a>
<a name="ln436">	BPoint canvasWhere = where;</a>
<a name="ln437">	fCanvasView-&gt;ConvertToCanvas(&amp;canvasWhere);</a>
<a name="ln438"> </a>
<a name="ln439">	// maybe we're changing some point, so we construct the</a>
<a name="ln440">	// &quot;ChangePointCommand&quot; here so that the point is remembered</a>
<a name="ln441">	// in its current state</a>
<a name="ln442">	// apply the canvas view mouse filter depending on current mode</a>
<a name="ln443">	delete fChangePointCommand;</a>
<a name="ln444">	fChangePointCommand = NULL;</a>
<a name="ln445">	switch (fMode) {</a>
<a name="ln446">		case TOGGLE_SHARP:</a>
<a name="ln447">		case TOGGLE_SHARP_IN:</a>
<a name="ln448">		case TOGGLE_SHARP_OUT:</a>
<a name="ln449">		case MOVE_POINT:</a>
<a name="ln450">		case MOVE_POINT_IN:</a>
<a name="ln451">		case MOVE_POINT_OUT:</a>
<a name="ln452">		case REMOVE_POINT_IN:</a>
<a name="ln453">		case REMOVE_POINT_OUT:</a>
<a name="ln454">			fChangePointCommand = new ChangePointCommand(fPath,</a>
<a name="ln455">														 fCurrentPathPoint,</a>
<a name="ln456">														 fSelection-&gt;Items(),</a>
<a name="ln457">														 fSelection-&gt;CountItems());</a>
<a name="ln458">			_Select(fCurrentPathPoint, fShiftDown);</a>
<a name="ln459">			break;</a>
<a name="ln460">	}</a>
<a name="ln461"> </a>
<a name="ln462">	// at this point we init doing something</a>
<a name="ln463">	switch (fMode) {</a>
<a name="ln464">		case ADD_POINT:</a>
<a name="ln465">			_AddPoint(canvasWhere);</a>
<a name="ln466">			break;</a>
<a name="ln467">		case INSERT_POINT:</a>
<a name="ln468">			_InsertPoint(canvasWhere, fCurrentPathPoint);</a>
<a name="ln469">			break;</a>
<a name="ln470"> </a>
<a name="ln471">		case TOGGLE_SHARP:</a>
<a name="ln472">			_SetSharp(fCurrentPathPoint);</a>
<a name="ln473">			// continue by dragging out the _connected_ in/out points</a>
<a name="ln474">			break;</a>
<a name="ln475">		case TOGGLE_SHARP_IN:</a>
<a name="ln476">			_SetInOutConnected(fCurrentPathPoint, false);</a>
<a name="ln477">			// continue by moving the &quot;in&quot; point</a>
<a name="ln478">			_SetMode(MOVE_POINT_IN);</a>
<a name="ln479">			break;</a>
<a name="ln480">		case TOGGLE_SHARP_OUT:</a>
<a name="ln481">			_SetInOutConnected(fCurrentPathPoint, false);</a>
<a name="ln482">			// continue by moving the &quot;out&quot; point</a>
<a name="ln483">			_SetMode(MOVE_POINT_OUT);</a>
<a name="ln484">			break;</a>
<a name="ln485"> </a>
<a name="ln486">		case MOVE_POINT:</a>
<a name="ln487">		case MOVE_POINT_IN:</a>
<a name="ln488">		case MOVE_POINT_OUT:</a>
<a name="ln489">			// the right thing happens since &quot;fCurrentPathPoint&quot;</a>
<a name="ln490">			// points to the correct index</a>
<a name="ln491">			break;</a>
<a name="ln492"> </a>
<a name="ln493">		case CLOSE_PATH:</a>
<a name="ln494">//			SetClosed(true, true);</a>
<a name="ln495">			break;</a>
<a name="ln496"> </a>
<a name="ln497">		case REMOVE_POINT:</a>
<a name="ln498">			if (fPath-&gt;CountPoints() == 1) {</a>
<a name="ln499">//				fCanvasView-&gt;Perform(new RemovePathCommand(this, fPath));</a>
<a name="ln500">			} else {</a>
<a name="ln501">				fCanvasView-&gt;Perform(new RemovePointsCommand(fPath,</a>
<a name="ln502">															 fCurrentPathPoint,</a>
<a name="ln503">															 fSelection-&gt;Items(),</a>
<a name="ln504">															 fSelection-&gt;CountItems()));</a>
<a name="ln505">				_RemovePoint(fCurrentPathPoint);</a>
<a name="ln506">			}</a>
<a name="ln507">			break;</a>
<a name="ln508">		case REMOVE_POINT_IN:</a>
<a name="ln509">			_RemovePointIn(fCurrentPathPoint);</a>
<a name="ln510">			break;</a>
<a name="ln511">		case REMOVE_POINT_OUT:</a>
<a name="ln512">			_RemovePointOut(fCurrentPathPoint);</a>
<a name="ln513">			break;</a>
<a name="ln514"> </a>
<a name="ln515">		case SELECT_POINTS: {</a>
<a name="ln516">			// TODO: this works so that you can deselect all points</a>
<a name="ln517">			// when clicking outside the path even if pressing shift</a>
<a name="ln518">			// in case the path is open... a better way would be</a>
<a name="ln519">			// to deselect all on mouse up, if the mouse has not moved</a>
<a name="ln520">			bool appendSelection;</a>
<a name="ln521">			if (fPath-&gt;IsClosed())</a>
<a name="ln522">				appendSelection = fShiftDown;</a>
<a name="ln523">			else</a>
<a name="ln524">				appendSelection = fShiftDown &amp;&amp; fCurrentPathPoint &gt;= 0;</a>
<a name="ln525"> </a>
<a name="ln526">			if (!appendSelection) {</a>
<a name="ln527">				fSelection-&gt;MakeEmpty();</a>
<a name="ln528">				_UpdateSelection();</a>
<a name="ln529">			}</a>
<a name="ln530">			*fOldSelection = *fSelection;</a>
<a name="ln531">			if (fCurrentPathPoint &gt;= 0) {</a>
<a name="ln532">				_Select(fCurrentPathPoint, appendSelection);</a>
<a name="ln533">			}</a>
<a name="ln534">			fCanvasView-&gt;BeginRectTracking(BRect(where, where),</a>
<a name="ln535">				B_TRACK_RECT_CORNER);</a>
<a name="ln536">			break;</a>
<a name="ln537">		}</a>
<a name="ln538">	}</a>
<a name="ln539"> </a>
<a name="ln540">	fTrackingStart = canvasWhere;</a>
<a name="ln541">	// remember the subpixel position</a>
<a name="ln542">	// so that MouseMoved() will work even before</a>
<a name="ln543">	// the integer position becomes different</a>
<a name="ln544">	fLastCanvasPos = where;</a>
<a name="ln545">	fCanvasView-&gt;ConvertToCanvas(&amp;fLastCanvasPos);</a>
<a name="ln546"> </a>
<a name="ln547">	// the reason to exclude the select mode</a>
<a name="ln548">	// is that the BView rect tracking does not</a>
<a name="ln549">	// scroll the rect starting point along with us</a>
<a name="ln550">	// (since we're doing no real scrolling)</a>
<a name="ln551">//	if (fMode != SELECT_POINTS)</a>
<a name="ln552">//		fCanvasView-&gt;SetAutoScrolling(true);</a>
<a name="ln553"> </a>
<a name="ln554">	UpdateCursor();</a>
<a name="ln555"> </a>
<a name="ln556">	return true;</a>
<a name="ln557">}</a>
<a name="ln558"> </a>
<a name="ln559">// MouseMoved</a>
<a name="ln560">void</a>
<a name="ln561">PathManipulator::MouseMoved(BPoint where)</a>
<a name="ln562">{</a>
<a name="ln563">	fCanvasView-&gt;FilterMouse(&amp;where);</a>
<a name="ln564">		// NOTE: only filter mouse coords in mouse moved, no other</a>
<a name="ln565">		// mouse function</a>
<a name="ln566">	BPoint canvasWhere = where;</a>
<a name="ln567">	fCanvasView-&gt;ConvertToCanvas(&amp;canvasWhere);</a>
<a name="ln568"> </a>
<a name="ln569">	// since the tablet is generating mouse moved messages</a>
<a name="ln570">	// even if only the pressure changes (and not the actual mouse position)</a>
<a name="ln571">	// we insert this additional check to prevent too much calculation</a>
<a name="ln572">	if (fLastCanvasPos == canvasWhere)</a>
<a name="ln573">		return;</a>
<a name="ln574"> </a>
<a name="ln575">	fLastCanvasPos = canvasWhere;</a>
<a name="ln576"> </a>
<a name="ln577">	if (fMode == TRANSFORM_POINTS) {</a>
<a name="ln578">		if (fTransformBox) {</a>
<a name="ln579">			fTransformBox-&gt;MouseMoved(where);</a>
<a name="ln580">		}</a>
<a name="ln581">		return;</a>
<a name="ln582">	}</a>
<a name="ln583"> </a>
<a name="ln584">	if (fMode == CLOSE_PATH) {</a>
<a name="ln585">		// continue by moving the point</a>
<a name="ln586">		_SetMode(MOVE_POINT);</a>
<a name="ln587">		delete fChangePointCommand;</a>
<a name="ln588">		fChangePointCommand = new ChangePointCommand(fPath,</a>
<a name="ln589">													 fCurrentPathPoint,</a>
<a name="ln590">													 fSelection-&gt;Items(),</a>
<a name="ln591">													 fSelection-&gt;CountItems());</a>
<a name="ln592">	}</a>
<a name="ln593"> </a>
<a name="ln594">//	if (!fPrecise) {</a>
<a name="ln595">//		float offset = fmod(fOutlineWidth, 2.0) / 2.0;</a>
<a name="ln596">//		canvasWhere.point += BPoint(offset, offset);</a>
<a name="ln597">//	}</a>
<a name="ln598"> </a>
<a name="ln599">	switch (fMode) {</a>
<a name="ln600">		case ADD_POINT:</a>
<a name="ln601">		case INSERT_POINT:</a>
<a name="ln602">		case TOGGLE_SHARP:</a>
<a name="ln603">			// drag the &quot;out&quot; control point, mirror the &quot;in&quot; control point</a>
<a name="ln604">			fPath-&gt;SetPointOut(fCurrentPathPoint, canvasWhere, true);</a>
<a name="ln605">			break;</a>
<a name="ln606">		case MOVE_POINT:</a>
<a name="ln607">			// drag all three control points at once</a>
<a name="ln608">			fPath-&gt;SetPoint(fCurrentPathPoint, canvasWhere);</a>
<a name="ln609">			break;</a>
<a name="ln610">		case MOVE_POINT_IN:</a>
<a name="ln611">			// drag in control point</a>
<a name="ln612">			fPath-&gt;SetPointIn(fCurrentPathPoint, canvasWhere);</a>
<a name="ln613">			break;</a>
<a name="ln614">		case MOVE_POINT_OUT:</a>
<a name="ln615">			// drag out control point</a>
<a name="ln616">			fPath-&gt;SetPointOut(fCurrentPathPoint, canvasWhere);</a>
<a name="ln617">			break;</a>
<a name="ln618">		</a>
<a name="ln619">		case SELECT_POINTS: {</a>
<a name="ln620">			// change the selection</a>
<a name="ln621">			BRect r;</a>
<a name="ln622">			r.left = min_c(fTrackingStart.x, canvasWhere.x);</a>
<a name="ln623">			r.top = min_c(fTrackingStart.y, canvasWhere.y);</a>
<a name="ln624">			r.right = max_c(fTrackingStart.x, canvasWhere.x);</a>
<a name="ln625">			r.bottom = max_c(fTrackingStart.y, canvasWhere.y);</a>
<a name="ln626">			_Select(r);</a>
<a name="ln627">			break;</a>
<a name="ln628">		}</a>
<a name="ln629"> </a>
<a name="ln630">		case TRANSLATE_POINTS: {</a>
<a name="ln631">			BPoint offset = canvasWhere - fTrackingStart;</a>
<a name="ln632">			_Nudge(offset);</a>
<a name="ln633">			fTrackingStart = canvasWhere;</a>
<a name="ln634">			break;</a>
<a name="ln635">		}</a>
<a name="ln636">	}</a>
<a name="ln637">}</a>
<a name="ln638"> </a>
<a name="ln639">// MouseUp</a>
<a name="ln640">Command*</a>
<a name="ln641">PathManipulator::MouseUp()</a>
<a name="ln642">{</a>
<a name="ln643">	// prevent carrying out actions more than once by only</a>
<a name="ln644">	// doing it if &quot;fMouseDown&quot; is true at the point of</a>
<a name="ln645">	// entering this function</a>
<a name="ln646">	if (!fMouseDown)</a>
<a name="ln647">		return NULL;</a>
<a name="ln648">	fMouseDown = false;</a>
<a name="ln649"> </a>
<a name="ln650">	if (fMode == TRANSFORM_POINTS) {</a>
<a name="ln651">		if (fTransformBox) {</a>
<a name="ln652">			return fTransformBox-&gt;MouseUp();</a>
<a name="ln653">		}</a>
<a name="ln654">		return NULL;</a>
<a name="ln655">	}</a>
<a name="ln656"> </a>
<a name="ln657">	Command* command = NULL;</a>
<a name="ln658"> </a>
<a name="ln659">	switch (fMode) {</a>
<a name="ln660"> </a>
<a name="ln661">		case ADD_POINT:</a>
<a name="ln662">			command = fAddPointCommand;</a>
<a name="ln663">			fAddPointCommand = NULL;</a>
<a name="ln664">			_SetMode(MOVE_POINT_OUT);</a>
<a name="ln665">			break;</a>
<a name="ln666"> </a>
<a name="ln667">		case INSERT_POINT:</a>
<a name="ln668">			command = fInsertPointCommand;</a>
<a name="ln669">			fInsertPointCommand = NULL;</a>
<a name="ln670">			break;</a>
<a name="ln671"> </a>
<a name="ln672">		case SELECT_POINTS:</a>
<a name="ln673">			if (*fSelection != *fOldSelection) {</a>
<a name="ln674">//				command = new SelectPointsCommand(this, fPath,</a>
<a name="ln675">//												  fOldSelection-&gt;Items(),</a>
<a name="ln676">//												  fOldSelection-&gt;CountItems(),</a>
<a name="ln677">//												  fSelection-&gt;Items(),</a>
<a name="ln678">//												  fSelection-&gt;CountItems()));</a>
<a name="ln679">			}</a>
<a name="ln680">			fCanvasView-&gt;EndRectTracking();</a>
<a name="ln681">			break;</a>
<a name="ln682"> </a>
<a name="ln683">		case TOGGLE_SHARP:</a>
<a name="ln684">		case TOGGLE_SHARP_IN:</a>
<a name="ln685">		case TOGGLE_SHARP_OUT:</a>
<a name="ln686">		case MOVE_POINT:</a>
<a name="ln687">		case MOVE_POINT_IN:</a>
<a name="ln688">		case MOVE_POINT_OUT:</a>
<a name="ln689">		case REMOVE_POINT_IN:</a>
<a name="ln690">		case REMOVE_POINT_OUT:</a>
<a name="ln691">			command = fChangePointCommand;</a>
<a name="ln692">			fChangePointCommand = NULL;</a>
<a name="ln693">			break;</a>
<a name="ln694"> </a>
<a name="ln695">		case TRANSLATE_POINTS:</a>
<a name="ln696">			if (!fNudgeCommand) {</a>
<a name="ln697">				// select just the point that was clicked</a>
<a name="ln698">				*fOldSelection = *fSelection;</a>
<a name="ln699">				if (fCurrentPathPoint &gt;= 0) {</a>
<a name="ln700">					_Select(fCurrentPathPoint, fShiftDown);</a>
<a name="ln701">				}</a>
<a name="ln702">				if (*fSelection != *fOldSelection) {</a>
<a name="ln703">//					command = new SelectPointsCommand(this, fPath,</a>
<a name="ln704">//													  fOldSelection-&gt;Items(),</a>
<a name="ln705">//													  fOldSelection-&gt;CountItems(),</a>
<a name="ln706">//													  fSelection-&gt;Items(),</a>
<a name="ln707">//													  fSelection-&gt;CountItems()));</a>
<a name="ln708">				}</a>
<a name="ln709">			} else {</a>
<a name="ln710">				command = _FinishNudging();</a>
<a name="ln711">			}</a>
<a name="ln712">			break;</a>
<a name="ln713">	}</a>
<a name="ln714"> </a>
<a name="ln715">	return command;</a>
<a name="ln716">}</a>
<a name="ln717"> </a>
<a name="ln718">// MouseOver</a>
<a name="ln719">bool</a>
<a name="ln720">PathManipulator::MouseOver(BPoint where)</a>
<a name="ln721">{</a>
<a name="ln722">	if (fMode == TRANSFORM_POINTS) {</a>
<a name="ln723">		if (fTransformBox) {</a>
<a name="ln724">			return fTransformBox-&gt;MouseOver(where);</a>
<a name="ln725">		}</a>
<a name="ln726">		return false;</a>
<a name="ln727">	}</a>
<a name="ln728"> </a>
<a name="ln729">	BPoint canvasWhere = where;</a>
<a name="ln730">	fCanvasView-&gt;ConvertToCanvas(&amp;canvasWhere);</a>
<a name="ln731"> </a>
<a name="ln732">	// since the tablet is generating mouse moved messages</a>
<a name="ln733">	// even if only the pressure changes (and not the actual mouse position)</a>
<a name="ln734">	// we insert this additional check to prevent too much calculation</a>
<a name="ln735">	if (fMouseDown &amp;&amp; fLastCanvasPos == canvasWhere)</a>
<a name="ln736">		return false;</a>
<a name="ln737"> </a>
<a name="ln738">	fLastCanvasPos = canvasWhere;</a>
<a name="ln739"> </a>
<a name="ln740">	// hit testing</a>
<a name="ln741">	// (use a subpixel mouse pos)</a>
<a name="ln742">	fCanvasView-&gt;ConvertToCanvas(&amp;where);</a>
<a name="ln743">	_SetModeForMousePos(where);</a>
<a name="ln744"> </a>
<a name="ln745">	// TODO: always true?</a>
<a name="ln746">	return true;</a>
<a name="ln747">}</a>
<a name="ln748"> </a>
<a name="ln749">// DoubleClicked</a>
<a name="ln750">bool</a>
<a name="ln751">PathManipulator::DoubleClicked(BPoint where)</a>
<a name="ln752">{</a>
<a name="ln753">	return false;</a>
<a name="ln754">}</a>
<a name="ln755"> </a>
<a name="ln756">// ShowContextMenu</a>
<a name="ln757">bool</a>
<a name="ln758">PathManipulator::ShowContextMenu(BPoint where)</a>
<a name="ln759">{</a>
<a name="ln760">	// Change the selection to the current point if it isn't currently</a>
<a name="ln761">	// selected. This could will only be chosen if the user right-clicked</a>
<a name="ln762">	// a path point directly. </a>
<a name="ln763">	if (fCurrentPathPoint &gt;= 0 &amp;&amp; !fSelection-&gt;Contains(fCurrentPathPoint)) {</a>
<a name="ln764">		fSelection-&gt;MakeEmpty();</a>
<a name="ln765">		_UpdateSelection();</a>
<a name="ln766">		*fOldSelection = *fSelection;</a>
<a name="ln767">		_Select(fCurrentPathPoint, false);</a>
<a name="ln768">	}</a>
<a name="ln769"> </a>
<a name="ln770">	BPopUpMenu* menu = new BPopUpMenu(&quot;context menu&quot;, false, false);</a>
<a name="ln771">	BMessage* message;</a>
<a name="ln772">	BMenuItem* item;</a>
<a name="ln773"> </a>
<a name="ln774">	bool hasSelection = fSelection-&gt;CountItems() &gt; 0;</a>
<a name="ln775"> </a>
<a name="ln776">	if (fCurrentPathPoint &lt; 0) {</a>
<a name="ln777">		message = new BMessage(B_SELECT_ALL);</a>
<a name="ln778">		item = new BMenuItem(B_TRANSLATE(&quot;Select All&quot;), message, 'A');</a>
<a name="ln779">		menu-&gt;AddItem(item);</a>
<a name="ln780">	</a>
<a name="ln781">		menu-&gt;AddSeparatorItem();</a>
<a name="ln782">	}</a>
<a name="ln783"> </a>
<a name="ln784">	message = new BMessage(MSG_TRANSFORM);</a>
<a name="ln785">	item = new BMenuItem(B_TRANSLATE(&quot;Transform&quot;), message, 'T');</a>
<a name="ln786">	item-&gt;SetEnabled(hasSelection);</a>
<a name="ln787">	menu-&gt;AddItem(item);</a>
<a name="ln788"> </a>
<a name="ln789">	message = new BMessage(MSG_SPLIT_POINTS);</a>
<a name="ln790">	item = new BMenuItem(B_TRANSLATE(&quot;Split&quot;), message);</a>
<a name="ln791">	item-&gt;SetEnabled(hasSelection);</a>
<a name="ln792">	menu-&gt;AddItem(item);</a>
<a name="ln793"> </a>
<a name="ln794">	message = new BMessage(MSG_FLIP_POINTS);</a>
<a name="ln795">	item = new BMenuItem(B_TRANSLATE(&quot;Flip&quot;), message);</a>
<a name="ln796">	item-&gt;SetEnabled(hasSelection);</a>
<a name="ln797">	menu-&gt;AddItem(item);</a>
<a name="ln798"> </a>
<a name="ln799">	message = new BMessage(MSG_REMOVE_POINTS);</a>
<a name="ln800">	item = new BMenuItem(B_TRANSLATE(&quot;Remove&quot;), message);</a>
<a name="ln801">	item-&gt;SetEnabled(hasSelection);</a>
<a name="ln802">	menu-&gt;AddItem(item);</a>
<a name="ln803"> </a>
<a name="ln804">	// go</a>
<a name="ln805">	menu-&gt;SetTargetForItems(fCanvasView);</a>
<a name="ln806">	menu-&gt;SetAsyncAutoDestruct(true);</a>
<a name="ln807">	menu-&gt;SetFont(be_plain_font);</a>
<a name="ln808">	where = fCanvasView-&gt;ConvertToScreen(where);</a>
<a name="ln809">	BRect mouseRect(where, where);</a>
<a name="ln810">	mouseRect.InsetBy(-10.0, -10.0);</a>
<a name="ln811">	where += BPoint(5.0, 5.0);</a>
<a name="ln812">	menu-&gt;Go(where, true, false, mouseRect, true);</a>
<a name="ln813"> </a>
<a name="ln814">	return true;</a>
<a name="ln815">}</a>
<a name="ln816"> </a>
<a name="ln817">// #pragma mark -</a>
<a name="ln818"> </a>
<a name="ln819">// Bounds</a>
<a name="ln820">BRect</a>
<a name="ln821">PathManipulator::Bounds()</a>
<a name="ln822">{</a>
<a name="ln823">	BRect r = _ControlPointRect();</a>
<a name="ln824">	fCanvasView-&gt;ConvertFromCanvas(&amp;r);</a>
<a name="ln825">	return r;</a>
<a name="ln826">}</a>
<a name="ln827"> </a>
<a name="ln828">// TrackingBounds</a>
<a name="ln829">BRect</a>
<a name="ln830">PathManipulator::TrackingBounds(BView* withinView)</a>
<a name="ln831">{</a>
<a name="ln832">	return withinView-&gt;Bounds();</a>
<a name="ln833">}</a>
<a name="ln834"> </a>
<a name="ln835">// #pragma mark -</a>
<a name="ln836"> </a>
<a name="ln837">// MessageReceived</a>
<a name="ln838">bool</a>
<a name="ln839">PathManipulator::MessageReceived(BMessage* message, Command** _command)</a>
<a name="ln840">{</a>
<a name="ln841">	bool result = true;</a>
<a name="ln842">	switch (message-&gt;what) {</a>
<a name="ln843">		case MSG_TRANSFORM:</a>
<a name="ln844">			if (!fSelection-&gt;IsEmpty())</a>
<a name="ln845">				_SetMode(TRANSFORM_POINTS);</a>
<a name="ln846">			break;</a>
<a name="ln847">		case MSG_REMOVE_POINTS:</a>
<a name="ln848">			*_command = _Delete();</a>
<a name="ln849">			break;</a>
<a name="ln850">		case MSG_SPLIT_POINTS:</a>
<a name="ln851">			*_command = new SplitPointsCommand(fPath,</a>
<a name="ln852">											   fSelection-&gt;Items(),</a>
<a name="ln853">											   fSelection-&gt;CountItems());</a>
<a name="ln854">			break;</a>
<a name="ln855">		case MSG_FLIP_POINTS:</a>
<a name="ln856">			*_command = new FlipPointsCommand(fPath,</a>
<a name="ln857">											  fSelection-&gt;Items(),</a>
<a name="ln858">											  fSelection-&gt;CountItems());</a>
<a name="ln859">			break;</a>
<a name="ln860">		case B_SELECT_ALL: {</a>
<a name="ln861">			*fOldSelection = *fSelection;</a>
<a name="ln862">			fSelection-&gt;MakeEmpty();</a>
<a name="ln863">			int32 count = fPath-&gt;CountPoints();</a>
<a name="ln864">			for (int32 i = 0; i &lt; count; i++)</a>
<a name="ln865">				fSelection-&gt;Add(i);</a>
<a name="ln866">			if (*fOldSelection != *fSelection) {</a>
<a name="ln867">//				*_command = new SelectPointsCommand(this, fPath,</a>
<a name="ln868">//												   fOldSelection-&gt;Items(),</a>
<a name="ln869">//												   fOldSelection-&gt;CountItems(),</a>
<a name="ln870">//												   fSelection-&gt;Items(),</a>
<a name="ln871">//												   fSelection-&gt;CountItems()));</a>
<a name="ln872">				count = fSelection-&gt;CountItems();</a>
<a name="ln873">				int32 indices[count];</a>
<a name="ln874">				memcpy(indices, fSelection-&gt;Items(), count * sizeof(int32));</a>
<a name="ln875">				_Select(indices, count);</a>
<a name="ln876">			}</a>
<a name="ln877">			break;</a>
<a name="ln878">		}</a>
<a name="ln879">		default:</a>
<a name="ln880">			result = false;</a>
<a name="ln881">			break;</a>
<a name="ln882">	}</a>
<a name="ln883">	return result;</a>
<a name="ln884">}</a>
<a name="ln885"> </a>
<a name="ln886"> </a>
<a name="ln887">// ModifiersChanged</a>
<a name="ln888">void</a>
<a name="ln889">PathManipulator::ModifiersChanged(uint32 modifiers)</a>
<a name="ln890">{</a>
<a name="ln891">	fCommandDown = modifiers &amp; B_COMMAND_KEY;</a>
<a name="ln892">	fOptionDown = modifiers &amp; B_CONTROL_KEY;</a>
<a name="ln893">	fShiftDown = modifiers &amp; B_SHIFT_KEY;</a>
<a name="ln894">	fAltDown = modifiers &amp; B_OPTION_KEY;</a>
<a name="ln895"> </a>
<a name="ln896">	if (fTransformBox) {</a>
<a name="ln897">		fTransformBox-&gt;ModifiersChanged(modifiers);</a>
<a name="ln898">		return;</a>
<a name="ln899">	}</a>
<a name="ln900">	// reevaluate mode</a>
<a name="ln901">	if (!fMouseDown)</a>
<a name="ln902">		_SetModeForMousePos(fLastCanvasPos);</a>
<a name="ln903">}</a>
<a name="ln904"> </a>
<a name="ln905">// HandleKeyDown</a>
<a name="ln906">bool</a>
<a name="ln907">PathManipulator::HandleKeyDown(uint32 key, uint32 modifiers, Command** _command)</a>
<a name="ln908">{</a>
<a name="ln909">	bool result = true;</a>
<a name="ln910"> </a>
<a name="ln911">	float nudgeDist = 1.0;</a>
<a name="ln912">	if (modifiers &amp; B_SHIFT_KEY)</a>
<a name="ln913">		nudgeDist /= fCanvasView-&gt;ZoomLevel();</a>
<a name="ln914"> </a>
<a name="ln915">	switch (key) {</a>
<a name="ln916">		// commit</a>
<a name="ln917">		case B_RETURN:</a>
<a name="ln918">			if (fTransformBox) {</a>
<a name="ln919">				_SetTransformBox(NULL);</a>
<a name="ln920">			}// else</a>
<a name="ln921">//				_Perform();</a>
<a name="ln922">			break;</a>
<a name="ln923">		// cancel</a>
<a name="ln924">		case B_ESCAPE:</a>
<a name="ln925">			if (fTransformBox) {</a>
<a name="ln926">				fTransformBox-&gt;Cancel();</a>
<a name="ln927">				_SetTransformBox(NULL);</a>
<a name="ln928">			} else if (fFallBackMode == NEW_PATH) {</a>
<a name="ln929">				fFallBackMode = SELECT_POINTS;</a>
<a name="ln930">				_SetTransformBox(NULL);</a>
<a name="ln931">			}// else</a>
<a name="ln932">//				_Cancel();</a>
<a name="ln933">			break;</a>
<a name="ln934">		case 't':</a>
<a name="ln935">		case 'T':</a>
<a name="ln936">			if (!fSelection-&gt;IsEmpty())</a>
<a name="ln937">				_SetMode(TRANSFORM_POINTS);</a>
<a name="ln938">			else</a>
<a name="ln939">				result = false;</a>
<a name="ln940">			break;</a>
<a name="ln941">		// nudging</a>
<a name="ln942">		case B_UP_ARROW:</a>
<a name="ln943">			_Nudge(BPoint(0.0, -nudgeDist));</a>
<a name="ln944">			break;</a>
<a name="ln945">		case B_DOWN_ARROW:</a>
<a name="ln946">			_Nudge(BPoint(0.0, nudgeDist));</a>
<a name="ln947">			break;</a>
<a name="ln948">		case B_LEFT_ARROW:</a>
<a name="ln949">			_Nudge(BPoint(-nudgeDist, 0.0));</a>
<a name="ln950">			break;</a>
<a name="ln951">		case B_RIGHT_ARROW:</a>
<a name="ln952">			_Nudge(BPoint(nudgeDist, 0.0));</a>
<a name="ln953">			break;</a>
<a name="ln954"> </a>
<a name="ln955">		case B_DELETE:</a>
<a name="ln956">			if (!fSelection-&gt;IsEmpty())</a>
<a name="ln957">				*_command = _Delete();</a>
<a name="ln958">			else</a>
<a name="ln959">				result = false;</a>
<a name="ln960">			break;</a>
<a name="ln961"> </a>
<a name="ln962">		default:</a>
<a name="ln963">			result = false;</a>
<a name="ln964">	}</a>
<a name="ln965">	return result;</a>
<a name="ln966">}</a>
<a name="ln967"> </a>
<a name="ln968">// HandleKeyUp</a>
<a name="ln969">bool</a>
<a name="ln970">PathManipulator::HandleKeyUp(uint32 key, uint32 modifiers, Command** _command)</a>
<a name="ln971">{</a>
<a name="ln972">	bool handled = true;</a>
<a name="ln973">	switch (key) {</a>
<a name="ln974">		// nudging</a>
<a name="ln975">		case B_UP_ARROW:</a>
<a name="ln976">		case B_DOWN_ARROW:</a>
<a name="ln977">		case B_LEFT_ARROW:</a>
<a name="ln978">		case B_RIGHT_ARROW:</a>
<a name="ln979">			*_command = _FinishNudging();</a>
<a name="ln980">			break;</a>
<a name="ln981">		default:</a>
<a name="ln982">			handled = false;</a>
<a name="ln983">			break;</a>
<a name="ln984">	}</a>
<a name="ln985">	return handled;</a>
<a name="ln986">}</a>
<a name="ln987"> </a>
<a name="ln988">// UpdateCursor</a>
<a name="ln989">bool</a>
<a name="ln990">PathManipulator::UpdateCursor()</a>
<a name="ln991">{</a>
<a name="ln992">	if (fTransformBox)</a>
<a name="ln993">		return fTransformBox-&gt;UpdateCursor();</a>
<a name="ln994"> </a>
<a name="ln995">	const uchar* cursorData;</a>
<a name="ln996">	switch (fMode) {</a>
<a name="ln997">		case ADD_POINT:</a>
<a name="ln998">			cursorData = kPathAddCursor;</a>
<a name="ln999">			break;</a>
<a name="ln1000">		case INSERT_POINT:</a>
<a name="ln1001">			cursorData = kPathInsertCursor;</a>
<a name="ln1002">			break;</a>
<a name="ln1003">		case MOVE_POINT:</a>
<a name="ln1004">		case MOVE_POINT_IN:</a>
<a name="ln1005">		case MOVE_POINT_OUT:</a>
<a name="ln1006">		case TRANSLATE_POINTS:</a>
<a name="ln1007">			cursorData = kPathMoveCursor;</a>
<a name="ln1008">			break;</a>
<a name="ln1009">		case CLOSE_PATH:</a>
<a name="ln1010">			cursorData = kPathCloseCursor;</a>
<a name="ln1011">			break;</a>
<a name="ln1012">		case TOGGLE_SHARP:</a>
<a name="ln1013">		case TOGGLE_SHARP_IN:</a>
<a name="ln1014">		case TOGGLE_SHARP_OUT:</a>
<a name="ln1015">			cursorData = kPathSharpCursor;</a>
<a name="ln1016">			break;</a>
<a name="ln1017">		case REMOVE_POINT:</a>
<a name="ln1018">		case REMOVE_POINT_IN:</a>
<a name="ln1019">		case REMOVE_POINT_OUT:</a>
<a name="ln1020">			cursorData = kPathRemoveCursor;</a>
<a name="ln1021">			break;</a>
<a name="ln1022">		case SELECT_POINTS:</a>
<a name="ln1023">			cursorData = kPathSelectCursor;</a>
<a name="ln1024">			break;</a>
<a name="ln1025"> </a>
<a name="ln1026">		case SELECT_SUB_PATH:</a>
<a name="ln1027">			cursorData = B_HAND_CURSOR;</a>
<a name="ln1028">			break;</a>
<a name="ln1029"> </a>
<a name="ln1030">		case UNDEFINED:</a>
<a name="ln1031">		default:</a>
<a name="ln1032">			cursorData = kStopCursor;</a>
<a name="ln1033">			break;</a>
<a name="ln1034">	}</a>
<a name="ln1035">	BCursor cursor(cursorData);</a>
<a name="ln1036">	fCanvasView-&gt;SetViewCursor(&amp;cursor, true);</a>
<a name="ln1037">	fCanvasView-&gt;Sync();</a>
<a name="ln1038"> </a>
<a name="ln1039">	return true;</a>
<a name="ln1040">}</a>
<a name="ln1041"> </a>
<a name="ln1042">// AttachedToView</a>
<a name="ln1043">void</a>
<a name="ln1044">PathManipulator::AttachedToView(BView* view)</a>
<a name="ln1045">{</a>
<a name="ln1046">	fCanvasView = dynamic_cast&lt;CanvasView*&gt;(view);</a>
<a name="ln1047">}</a>
<a name="ln1048"> </a>
<a name="ln1049">// DetachedFromView</a>
<a name="ln1050">void</a>
<a name="ln1051">PathManipulator::DetachedFromView(BView* view)</a>
<a name="ln1052">{</a>
<a name="ln1053">	fCanvasView = NULL;</a>
<a name="ln1054">}</a>
<a name="ln1055"> </a>
<a name="ln1056">// #pragma mark -</a>
<a name="ln1057"> </a>
<a name="ln1058">// ObjectChanged</a>
<a name="ln1059">void</a>
<a name="ln1060">PathManipulator::ObjectChanged(const Observable* object)</a>
<a name="ln1061">{</a>
<a name="ln1062">	// TODO: refine VectorPath listener interface and</a>
<a name="ln1063">	// implement more efficiently</a>
<a name="ln1064">	BRect currentBounds = _ControlPointRect();</a>
<a name="ln1065">	_InvalidateCanvas(currentBounds | fPreviousBounds);</a>
<a name="ln1066">	fPreviousBounds = currentBounds;</a>
<a name="ln1067"> </a>
<a name="ln1068">	// reevaluate mode</a>
<a name="ln1069">	if (!fMouseDown &amp;&amp; !fTransformBox)</a>
<a name="ln1070">		_SetModeForMousePos(fLastCanvasPos);</a>
<a name="ln1071">}</a>
<a name="ln1072"> </a>
<a name="ln1073">// #pragma mark -</a>
<a name="ln1074"> </a>
<a name="ln1075">// PointAdded</a>
<a name="ln1076">void</a>
<a name="ln1077">PathManipulator::PointAdded(int32 index)</a>
<a name="ln1078">{</a>
<a name="ln1079">	ObjectChanged(fPath);</a>
<a name="ln1080">}</a>
<a name="ln1081"> </a>
<a name="ln1082">// PointRemoved</a>
<a name="ln1083">void</a>
<a name="ln1084">PathManipulator::PointRemoved(int32 index)</a>
<a name="ln1085">{</a>
<a name="ln1086">	fSelection-&gt;Remove(index);</a>
<a name="ln1087">	ObjectChanged(fPath);</a>
<a name="ln1088">}</a>
<a name="ln1089"> </a>
<a name="ln1090">// PointChanged</a>
<a name="ln1091">void</a>
<a name="ln1092">PathManipulator::PointChanged(int32 index)</a>
<a name="ln1093">{</a>
<a name="ln1094">	ObjectChanged(fPath);</a>
<a name="ln1095">}</a>
<a name="ln1096"> </a>
<a name="ln1097">// PathChanged</a>
<a name="ln1098">void</a>
<a name="ln1099">PathManipulator::PathChanged()</a>
<a name="ln1100">{</a>
<a name="ln1101">	ObjectChanged(fPath);</a>
<a name="ln1102">}</a>
<a name="ln1103"> </a>
<a name="ln1104">// PathClosedChanged</a>
<a name="ln1105">void</a>
<a name="ln1106">PathManipulator::PathClosedChanged()</a>
<a name="ln1107">{</a>
<a name="ln1108">	ObjectChanged(fPath);</a>
<a name="ln1109">}</a>
<a name="ln1110"> </a>
<a name="ln1111">// PathReversed</a>
<a name="ln1112">void</a>
<a name="ln1113">PathManipulator::PathReversed()</a>
<a name="ln1114">{</a>
<a name="ln1115">	// reverse selection along with path</a>
<a name="ln1116">	int32 count = fSelection-&gt;CountItems();</a>
<a name="ln1117">	int32 pointCount = fPath-&gt;CountPoints();</a>
<a name="ln1118">	if (count &gt; 0) {</a>
<a name="ln1119">		Selection temp;</a>
<a name="ln1120">		for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln1121">			temp.Add((pointCount - 1) - fSelection-&gt;IndexAt(i));</a>
<a name="ln1122">		}</a>
<a name="ln1123">		*fSelection = temp;</a>
<a name="ln1124">	}</a>
<a name="ln1125"> </a>
<a name="ln1126">	ObjectChanged(fPath);</a>
<a name="ln1127">}</a>
<a name="ln1128"> </a>
<a name="ln1129">// #pragma mark -</a>
<a name="ln1130"> </a>
<a name="ln1131">// ControlFlags</a>
<a name="ln1132">uint32</a>
<a name="ln1133">PathManipulator::ControlFlags() const</a>
<a name="ln1134">{</a>
<a name="ln1135">	uint32 flags = 0;</a>
<a name="ln1136"> </a>
<a name="ln1137">//	flags |= SHAPE_UI_FLAGS_CAN_REVERSE_PATH;</a>
<a name="ln1138">//</a>
<a name="ln1139">//	if (!fSelection-&gt;IsEmpty())</a>
<a name="ln1140">//		flags |= SHAPE_UI_FLAGS_HAS_SELECTION;</a>
<a name="ln1141">//	if (fPath-&gt;CountPoints() &gt; 1)</a>
<a name="ln1142">//		flags |= SHAPE_UI_FLAGS_CAN_CLOSE_PATH;</a>
<a name="ln1143">//	if (fPath-&gt;IsClosed())</a>
<a name="ln1144">//		flags |= SHAPE_UI_FLAGS_PATH_IS_CLOSED;</a>
<a name="ln1145">//	if (fTransformBox)</a>
<a name="ln1146">//		flags |= SHAPE_UI_FLAGS_IS_TRANSFORMING;</a>
<a name="ln1147"> </a>
<a name="ln1148">	return flags;</a>
<a name="ln1149">}</a>
<a name="ln1150"> </a>
<a name="ln1151">// ReversePath</a>
<a name="ln1152">void</a>
<a name="ln1153">PathManipulator::ReversePath()</a>
<a name="ln1154">{</a>
<a name="ln1155">	int32 count = fSelection-&gt;CountItems();</a>
<a name="ln1156">	int32 pointCount = fPath-&gt;CountPoints();</a>
<a name="ln1157">	if (count &gt; 0) {</a>
<a name="ln1158">		Selection temp;</a>
<a name="ln1159">		for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln1160">			temp.Add((pointCount - 1) - fSelection-&gt;IndexAt(i));</a>
<a name="ln1161">		}</a>
<a name="ln1162">		*fSelection = temp;</a>
<a name="ln1163">	}</a>
<a name="ln1164">	fPath-&gt;Reverse();</a>
<a name="ln1165">}</a>
<a name="ln1166"> </a>
<a name="ln1167">// #pragma mark -</a>
<a name="ln1168"> </a>
<a name="ln1169">// _SetMode</a>
<a name="ln1170">void</a>
<a name="ln1171">PathManipulator::_SetMode(uint32 mode)</a>
<a name="ln1172">{</a>
<a name="ln1173">	if (fMode != mode) {</a>
<a name="ln1174">//printf(&quot;switching mode: %s -&gt; %s\n&quot;, string_for_mode(fMode), string_for_mode(mode));</a>
<a name="ln1175">		fMode = mode;</a>
<a name="ln1176"> </a>
<a name="ln1177">		if (fMode == TRANSFORM_POINTS) {</a>
<a name="ln1178">			_SetTransformBox(new TransformPointsBox(fCanvasView,</a>
<a name="ln1179">													this,</a>
<a name="ln1180">													fPath,</a>
<a name="ln1181">													fSelection-&gt;Items(),</a>
<a name="ln1182">													fSelection-&gt;CountItems()));</a>
<a name="ln1183">//			fCanvasView-&gt;Perform(new EnterTransformPointsCommand(this,</a>
<a name="ln1184">//														  fSelection-&gt;Items(),</a>
<a name="ln1185">//														  fSelection-&gt;CountItems()));</a>
<a name="ln1186">		} else {</a>
<a name="ln1187">			if (fTransformBox)</a>
<a name="ln1188">				_SetTransformBox(NULL);</a>
<a name="ln1189">		}</a>
<a name="ln1190"> </a>
<a name="ln1191">		if (BWindow* window = fCanvasView-&gt;Window()) {</a>
<a name="ln1192">			window-&gt;PostMessage(MSG_UPDATE_SHAPE_UI);</a>
<a name="ln1193">		}</a>
<a name="ln1194">		UpdateCursor();</a>
<a name="ln1195">	}</a>
<a name="ln1196">}</a>
<a name="ln1197"> </a>
<a name="ln1198"> </a>
<a name="ln1199">// _SetTransformBox</a>
<a name="ln1200">void</a>
<a name="ln1201">PathManipulator::_SetTransformBox(TransformPointsBox* transformBox)</a>
<a name="ln1202">{</a>
<a name="ln1203">	if (fTransformBox == transformBox)</a>
<a name="ln1204">		return;</a>
<a name="ln1205"> </a>
<a name="ln1206">	BRect dirty(LONG_MAX, LONG_MAX, LONG_MIN, LONG_MIN);</a>
<a name="ln1207">	if (fTransformBox) {</a>
<a name="ln1208">		// get rid of transform box display</a>
<a name="ln1209">		dirty = fTransformBox-&gt;Bounds();</a>
<a name="ln1210">		delete fTransformBox;</a>
<a name="ln1211">	}</a>
<a name="ln1212"> </a>
<a name="ln1213">	fTransformBox = transformBox;</a>
<a name="ln1214"> </a>
<a name="ln1215">	// TODO: this is weird, fMode should only be set in _SetMode, not</a>
<a name="ln1216">	// here as well, also this method could be called this way</a>
<a name="ln1217">	// _SetModeForMousePos -&gt; _SetMode -&gt; _SetTransformBox</a>
<a name="ln1218">	// and then below it does _SetModeForMousePos again...</a>
<a name="ln1219">	if (fTransformBox) {</a>
<a name="ln1220">		fTransformBox-&gt;MouseMoved(fLastCanvasPos);</a>
<a name="ln1221">		if (fMode != TRANSFORM_POINTS) {</a>
<a name="ln1222">			fMode = TRANSFORM_POINTS;</a>
<a name="ln1223">		}</a>
<a name="ln1224">		dirty = dirty | fTransformBox-&gt;Bounds();</a>
<a name="ln1225">	} else {</a>
<a name="ln1226">		if (fMode == TRANSFORM_POINTS) {</a>
<a name="ln1227">			_SetModeForMousePos(fLastCanvasPos);</a>
<a name="ln1228">		}</a>
<a name="ln1229">	}</a>
<a name="ln1230"> </a>
<a name="ln1231">	if (dirty.IsValid()) {</a>
<a name="ln1232">		dirty.InsetBy(-8, -8);</a>
<a name="ln1233">		fCanvasView-&gt;Invalidate(dirty);</a>
<a name="ln1234">	}</a>
<a name="ln1235">}</a>
<a name="ln1236"> </a>
<a name="ln1237">// _AddPoint</a>
<a name="ln1238">void</a>
<a name="ln1239">PathManipulator::_AddPoint(BPoint where)</a>
<a name="ln1240">{</a>
<a name="ln1241">	if (fPath-&gt;AddPoint(where)) {</a>
<a name="ln1242">		fCurrentPathPoint = fPath-&gt;CountPoints() - 1;</a>
<a name="ln1243"> </a>
<a name="ln1244">		delete fAddPointCommand;</a>
<a name="ln1245">		fAddPointCommand = new AddPointCommand(fPath, fCurrentPathPoint,</a>
<a name="ln1246">											   fSelection-&gt;Items(),</a>
<a name="ln1247">											   fSelection-&gt;CountItems());</a>
<a name="ln1248"> </a>
<a name="ln1249">		_Select(fCurrentPathPoint, fShiftDown);</a>
<a name="ln1250">	}</a>
<a name="ln1251">}</a>
<a name="ln1252"> </a>
<a name="ln1253">// scale_point</a>
<a name="ln1254">BPoint</a>
<a name="ln1255">scale_point(BPoint a, BPoint b, float scale)</a>
<a name="ln1256">{</a>
<a name="ln1257">	return BPoint(a.x + (b.x - a.x) * scale,</a>
<a name="ln1258">				  a.y + (b.y - a.y) * scale);</a>
<a name="ln1259">}</a>
<a name="ln1260"> </a>
<a name="ln1261">// _InsertPoint</a>
<a name="ln1262">void</a>
<a name="ln1263">PathManipulator::_InsertPoint(BPoint where, int32 index)</a>
<a name="ln1264">{</a>
<a name="ln1265">	double scale;</a>
<a name="ln1266"> </a>
<a name="ln1267">	BPoint point;</a>
<a name="ln1268">	BPoint pointIn;</a>
<a name="ln1269">	BPoint pointOut;</a>
<a name="ln1270"> </a>
<a name="ln1271">	BPoint previous;</a>
<a name="ln1272">	BPoint previousOut;</a>
<a name="ln1273">	BPoint next;</a>
<a name="ln1274">	BPoint nextIn;</a>
<a name="ln1275"> </a>
<a name="ln1276">	if (fPath-&gt;FindBezierScale(index - 1, where, &amp;scale)</a>
<a name="ln1277">		&amp;&amp; scale &gt;= 0.0 &amp;&amp; scale &lt;= 1.0</a>
<a name="ln1278">		&amp;&amp; fPath-&gt;GetPoint(index - 1, scale, point)) {</a>
<a name="ln1279"> </a>
<a name="ln1280">		fPath-&gt;GetPointAt(index - 1, previous);</a>
<a name="ln1281">		fPath-&gt;GetPointOutAt(index - 1, previousOut);</a>
<a name="ln1282">		fPath-&gt;GetPointAt(index, next);</a>
<a name="ln1283">		fPath-&gt;GetPointInAt(index, nextIn);</a>
<a name="ln1284"> </a>
<a name="ln1285">		where = scale_point(previousOut, nextIn, scale);</a>
<a name="ln1286"> </a>
<a name="ln1287">		previousOut = scale_point(previous, previousOut, scale);</a>
<a name="ln1288">		nextIn = scale_point(next, nextIn, 1 - scale);</a>
<a name="ln1289">		pointIn = scale_point(previousOut, where, scale);</a>
<a name="ln1290">		pointOut = scale_point(nextIn, where, 1 - scale);</a>
<a name="ln1291">		</a>
<a name="ln1292">		if (fPath-&gt;AddPoint(point, index)) {</a>
<a name="ln1293"> </a>
<a name="ln1294">			fPath-&gt;SetPointIn(index, pointIn);</a>
<a name="ln1295">			fPath-&gt;SetPointOut(index, pointOut);</a>
<a name="ln1296"> </a>
<a name="ln1297">			delete fInsertPointCommand;</a>
<a name="ln1298">			fInsertPointCommand = new InsertPointCommand(fPath, index,</a>
<a name="ln1299">														 fSelection-&gt;Items(),</a>
<a name="ln1300">														 fSelection-&gt;CountItems());</a>
<a name="ln1301"> </a>
<a name="ln1302">			fPath-&gt;SetPointOut(index - 1, previousOut);</a>
<a name="ln1303">			fPath-&gt;SetPointIn(index + 1, nextIn);</a>
<a name="ln1304"> </a>
<a name="ln1305">			fCurrentPathPoint = index;</a>
<a name="ln1306">			_ShiftSelection(fCurrentPathPoint, 1);</a>
<a name="ln1307">			_Select(fCurrentPathPoint, fShiftDown);</a>
<a name="ln1308">		}</a>
<a name="ln1309">	}</a>
<a name="ln1310">}</a>
<a name="ln1311"> </a>
<a name="ln1312">// _SetInOutConnected</a>
<a name="ln1313">void</a>
<a name="ln1314">PathManipulator::_SetInOutConnected(int32 index, bool connected)</a>
<a name="ln1315">{</a>
<a name="ln1316">	fPath-&gt;SetInOutConnected(index, connected);</a>
<a name="ln1317">}</a>
<a name="ln1318"> </a>
<a name="ln1319">// _SetSharp</a>
<a name="ln1320">void</a>
<a name="ln1321">PathManipulator::_SetSharp(int32 index)</a>
<a name="ln1322">{</a>
<a name="ln1323">	BPoint p;</a>
<a name="ln1324">	fPath-&gt;GetPointAt(index, p);</a>
<a name="ln1325">	fPath-&gt;SetPoint(index, p, p, p, true);</a>
<a name="ln1326">}</a>
<a name="ln1327"> </a>
<a name="ln1328">// _RemoveSelection</a>
<a name="ln1329">void</a>
<a name="ln1330">PathManipulator::_RemoveSelection()</a>
<a name="ln1331">{</a>
<a name="ln1332">	// NOTE: copy selection since removing points will</a>
<a name="ln1333">	// trigger notifications, and that will influence the</a>
<a name="ln1334">	// selection</a>
<a name="ln1335">	Selection selection = *fSelection;</a>
<a name="ln1336">	int32 count = selection.CountItems();</a>
<a name="ln1337">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln1338">		if (!fPath-&gt;RemovePoint(selection.IndexAt(i) - i))</a>
<a name="ln1339">			break;</a>
<a name="ln1340">	}</a>
<a name="ln1341"> </a>
<a name="ln1342">	fPath-&gt;SetClosed(fPath-&gt;IsClosed() &amp;&amp; fPath-&gt;CountPoints() &gt; 1);</a>
<a name="ln1343"> </a>
<a name="ln1344">	fSelection-&gt;MakeEmpty();</a>
<a name="ln1345">}</a>
<a name="ln1346"> </a>
<a name="ln1347"> </a>
<a name="ln1348">// _RemovePoint</a>
<a name="ln1349">void</a>
<a name="ln1350">PathManipulator::_RemovePoint(int32 index)</a>
<a name="ln1351">{</a>
<a name="ln1352">	if (fPath-&gt;RemovePoint(index)) {</a>
<a name="ln1353">		_Deselect(index);</a>
<a name="ln1354">		_ShiftSelection(index + 1, -1);</a>
<a name="ln1355">	}</a>
<a name="ln1356">}</a>
<a name="ln1357"> </a>
<a name="ln1358">// _RemovePointIn</a>
<a name="ln1359">void</a>
<a name="ln1360">PathManipulator::_RemovePointIn(int32 index)</a>
<a name="ln1361">{</a>
<a name="ln1362">	BPoint p;</a>
<a name="ln1363">	if (fPath-&gt;GetPointAt(index, p)) {</a>
<a name="ln1364">		fPath-&gt;SetPointIn(index, p);</a>
<a name="ln1365">		fPath-&gt;SetInOutConnected(index, false);</a>
<a name="ln1366">	}</a>
<a name="ln1367">}</a>
<a name="ln1368"> </a>
<a name="ln1369">// _RemovePointOut</a>
<a name="ln1370">void</a>
<a name="ln1371">PathManipulator::_RemovePointOut(int32 index)</a>
<a name="ln1372">{</a>
<a name="ln1373">	BPoint p;</a>
<a name="ln1374">	if (fPath-&gt;GetPointAt(index, p)) {</a>
<a name="ln1375">		fPath-&gt;SetPointOut(index, p);</a>
<a name="ln1376">		fPath-&gt;SetInOutConnected(index, false);</a>
<a name="ln1377">	}</a>
<a name="ln1378">}</a>
<a name="ln1379"> </a>
<a name="ln1380">// _Delete</a>
<a name="ln1381">Command*</a>
<a name="ln1382">PathManipulator::_Delete()</a>
<a name="ln1383">{</a>
<a name="ln1384">	Command* command = NULL;</a>
<a name="ln1385">	if (!fMouseDown) {</a>
<a name="ln1386">		// make sure we apply an on-going transformation before we proceed</a>
<a name="ln1387">		if (fTransformBox) {</a>
<a name="ln1388">			_SetTransformBox(NULL);</a>
<a name="ln1389">		}</a>
<a name="ln1390"> </a>
<a name="ln1391">		if (fSelection-&gt;CountItems() == fPath-&gt;CountPoints()) {</a>
<a name="ln1392">//			command = new RemovePathCommand(fPath);</a>
<a name="ln1393">		} else {</a>
<a name="ln1394">			command = new RemovePointsCommand(fPath,</a>
<a name="ln1395">											  fSelection-&gt;Items(),</a>
<a name="ln1396">											  fSelection-&gt;CountItems());</a>
<a name="ln1397">			_RemoveSelection();</a>
<a name="ln1398">		}</a>
<a name="ln1399"> </a>
<a name="ln1400">		_SetModeForMousePos(fLastCanvasPos);</a>
<a name="ln1401">	}</a>
<a name="ln1402"> </a>
<a name="ln1403">	return command;</a>
<a name="ln1404">}</a>
<a name="ln1405"> </a>
<a name="ln1406">// #pragma mark -</a>
<a name="ln1407"> </a>
<a name="ln1408">// _Select</a>
<a name="ln1409">void</a>
<a name="ln1410">PathManipulator::_Select(BRect r)</a>
<a name="ln1411">{</a>
<a name="ln1412">	BPoint p;</a>
<a name="ln1413">	BPoint pIn;</a>
<a name="ln1414">	BPoint pOut;</a>
<a name="ln1415">	int32 count = fPath-&gt;CountPoints();</a>
<a name="ln1416">	Selection temp;</a>
<a name="ln1417">	for (int32 i = 0; i &lt; count &amp;&amp; fPath-&gt;GetPointsAt(i, p, pIn, pOut); i++) {</a>
<a name="ln1418">		if (r.Contains(p) || r.Contains(pIn) || r.Contains(pOut)) {</a>
<a name="ln1419">			temp.Add(i);</a>
<a name="ln1420">		}</a>
<a name="ln1421">	}</a>
<a name="ln1422">	// merge old and new selection</a>
<a name="ln1423">	count = fOldSelection-&gt;CountItems();</a>
<a name="ln1424">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln1425">		int32 index = fOldSelection-&gt;IndexAt(i);</a>
<a name="ln1426">		if (temp.Contains(index))</a>
<a name="ln1427">			temp.Remove(index);</a>
<a name="ln1428">		else</a>
<a name="ln1429">			temp.Add(index);</a>
<a name="ln1430">	}</a>
<a name="ln1431">	if (temp != *fSelection) {</a>
<a name="ln1432">		*fSelection = temp;</a>
<a name="ln1433">		_UpdateSelection();</a>
<a name="ln1434">	}</a>
<a name="ln1435">}</a>
<a name="ln1436"> </a>
<a name="ln1437">// _Select</a>
<a name="ln1438">void</a>
<a name="ln1439">PathManipulator::_Select(int32 index, bool extend)</a>
<a name="ln1440">{</a>
<a name="ln1441">	if (!extend)</a>
<a name="ln1442">		fSelection-&gt;MakeEmpty();</a>
<a name="ln1443">	if (fSelection-&gt;Contains(index))</a>
<a name="ln1444">		fSelection-&gt;Remove(index);</a>
<a name="ln1445">	else</a>
<a name="ln1446">		fSelection-&gt;Add(index);</a>
<a name="ln1447">	// TODO: this can lead to unnecessary invalidation (maybe need to investigate)</a>
<a name="ln1448">	_UpdateSelection();</a>
<a name="ln1449">}</a>
<a name="ln1450"> </a>
<a name="ln1451">// _Select</a>
<a name="ln1452">void</a>
<a name="ln1453">PathManipulator::_Select(const int32* indices, int32 count, bool extend)</a>
<a name="ln1454">{</a>
<a name="ln1455">	if (extend) {</a>
<a name="ln1456">		for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln1457">			if (!fSelection-&gt;Contains(indices[i]))</a>
<a name="ln1458">				fSelection-&gt;Add(indices[i]);</a>
<a name="ln1459">		}</a>
<a name="ln1460">	} else {</a>
<a name="ln1461">		fSelection-&gt;MakeEmpty();</a>
<a name="ln1462">		for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln1463">			fSelection-&gt;Add(indices[i]);</a>
<a name="ln1464">		}</a>
<a name="ln1465">	}</a>
<a name="ln1466">	_UpdateSelection();</a>
<a name="ln1467">}</a>
<a name="ln1468"> </a>
<a name="ln1469">// _Deselect</a>
<a name="ln1470">void</a>
<a name="ln1471">PathManipulator::_Deselect(int32 index)</a>
<a name="ln1472">{</a>
<a name="ln1473">	if (fSelection-&gt;Contains(index)) {</a>
<a name="ln1474">		fSelection-&gt;Remove(index);</a>
<a name="ln1475">		_UpdateSelection();</a>
<a name="ln1476">	}</a>
<a name="ln1477">}</a>
<a name="ln1478"> </a>
<a name="ln1479">// _ShiftSelection</a>
<a name="ln1480">void</a>
<a name="ln1481">PathManipulator::_ShiftSelection(int32 startIndex, int32 direction)</a>
<a name="ln1482">{</a>
<a name="ln1483">	int32 count = fSelection-&gt;CountItems();</a>
<a name="ln1484">	if (count &gt; 0) {</a>
<a name="ln1485">		int32* selection = fSelection-&gt;Items();</a>
<a name="ln1486">		for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln1487">			if (selection[i] &gt;= startIndex) {</a>
<a name="ln1488">				selection[i] += direction;</a>
<a name="ln1489">			}</a>
<a name="ln1490">		}</a>
<a name="ln1491">	}</a>
<a name="ln1492">	_UpdateSelection();</a>
<a name="ln1493">}</a>
<a name="ln1494"> </a>
<a name="ln1495">// _IsSelected</a>
<a name="ln1496">bool</a>
<a name="ln1497">PathManipulator::_IsSelected(int32 index) const</a>
<a name="ln1498">{</a>
<a name="ln1499">	return fSelection-&gt;Contains(index);</a>
<a name="ln1500">}</a>
<a name="ln1501"> </a>
<a name="ln1502">// #pragma mark -</a>
<a name="ln1503"> </a>
<a name="ln1504">// _InvalidateCanvas</a>
<a name="ln1505">void</a>
<a name="ln1506">PathManipulator::_InvalidateCanvas(BRect rect) const</a>
<a name="ln1507">{</a>
<a name="ln1508">	// convert from canvas to view space</a>
<a name="ln1509">	fCanvasView-&gt;ConvertFromCanvas(&amp;rect);</a>
<a name="ln1510">	fCanvasView-&gt;Invalidate(rect);</a>
<a name="ln1511">}</a>
<a name="ln1512"> </a>
<a name="ln1513">// _InvalidateHighlightPoints</a>
<a name="ln1514">void</a>
<a name="ln1515">PathManipulator::_InvalidateHighlightPoints(int32 newIndex, uint32 newMode)</a>
<a name="ln1516">{</a>
<a name="ln1517">	BRect oldRect = _ControlPointRect(fCurrentPathPoint, fMode);</a>
<a name="ln1518">	BRect newRect = _ControlPointRect(newIndex, newMode);</a>
<a name="ln1519">	if (oldRect.IsValid())</a>
<a name="ln1520">		_InvalidateCanvas(oldRect);</a>
<a name="ln1521">	if (newRect.IsValid())</a>
<a name="ln1522">		_InvalidateCanvas(newRect);</a>
<a name="ln1523">}</a>
<a name="ln1524"> </a>
<a name="ln1525">// _UpdateSelection</a>
<a name="ln1526">void</a>
<a name="ln1527">PathManipulator::_UpdateSelection() const</a>
<a name="ln1528">{</a>
<a name="ln1529">	_InvalidateCanvas(_ControlPointRect());</a>
<a name="ln1530">	if (BWindow* window = fCanvasView-&gt;Window()) {</a>
<a name="ln1531">		window-&gt;PostMessage(MSG_UPDATE_SHAPE_UI);</a>
<a name="ln1532">	}</a>
<a name="ln1533">}</a>
<a name="ln1534"> </a>
<a name="ln1535">// _ControlPointRect</a>
<a name="ln1536">BRect</a>
<a name="ln1537">PathManipulator::_ControlPointRect() const</a>
<a name="ln1538">{</a>
<a name="ln1539">	BRect r = fPath-&gt;ControlPointBounds();</a>
<a name="ln1540">	r.InsetBy(-POINT_EXTEND, -POINT_EXTEND);</a>
<a name="ln1541">	return r; </a>
<a name="ln1542">}</a>
<a name="ln1543"> </a>
<a name="ln1544">// _ControlPointRect</a>
<a name="ln1545">BRect</a>
<a name="ln1546">PathManipulator::_ControlPointRect(int32 index, uint32 mode) const</a>
<a name="ln1547">{</a>
<a name="ln1548">	BRect rect(0.0, 0.0, -1.0, -1.0);</a>
<a name="ln1549">	if (index &gt;= 0) {</a>
<a name="ln1550">		BPoint p, pIn, pOut;</a>
<a name="ln1551">		fPath-&gt;GetPointsAt(index, p, pIn, pOut);</a>
<a name="ln1552">		switch (mode) {</a>
<a name="ln1553">			case MOVE_POINT:</a>
<a name="ln1554">			case TOGGLE_SHARP:</a>
<a name="ln1555">			case REMOVE_POINT:</a>
<a name="ln1556">			case CLOSE_PATH:</a>
<a name="ln1557">				rect.Set(p.x, p.y, p.x, p.y);</a>
<a name="ln1558">				rect.InsetBy(-POINT_EXTEND, -POINT_EXTEND);</a>
<a name="ln1559">				break;</a>
<a name="ln1560">			case MOVE_POINT_IN:</a>
<a name="ln1561">			case TOGGLE_SHARP_IN:</a>
<a name="ln1562">			case REMOVE_POINT_IN:</a>
<a name="ln1563">				rect.Set(pIn.x, pIn.y, pIn.x, pIn.y);</a>
<a name="ln1564">				rect.InsetBy(-CONTROL_POINT_EXTEND, -CONTROL_POINT_EXTEND);</a>
<a name="ln1565">				break;</a>
<a name="ln1566">			case MOVE_POINT_OUT:</a>
<a name="ln1567">			case TOGGLE_SHARP_OUT:</a>
<a name="ln1568">			case REMOVE_POINT_OUT:</a>
<a name="ln1569">				rect.Set(pOut.x, pOut.y, pOut.x, pOut.y);</a>
<a name="ln1570">				rect.InsetBy(-CONTROL_POINT_EXTEND, -CONTROL_POINT_EXTEND);</a>
<a name="ln1571">				break;</a>
<a name="ln1572">			case SELECT_POINTS:</a>
<a name="ln1573">				rect.Set(min4(p.x, pIn.x, pOut.x, pOut.x),</a>
<a name="ln1574">						 min4(p.y, pIn.y, pOut.y, pOut.y),</a>
<a name="ln1575">						 max4(p.x, pIn.x, pOut.x, pOut.x),</a>
<a name="ln1576">						 max4(p.y, pIn.y, pOut.y, pOut.y));</a>
<a name="ln1577">				rect.InsetBy(-POINT_EXTEND, -POINT_EXTEND);</a>
<a name="ln1578">				break;</a>
<a name="ln1579">		}</a>
<a name="ln1580">	}</a>
<a name="ln1581">	return rect;</a>
<a name="ln1582">}</a>
<a name="ln1583"> </a>
<a name="ln1584">// #pragma mark -</a>
<a name="ln1585"> </a>
<a name="ln1586">// _SetModeForMousePos</a>
<a name="ln1587">void</a>
<a name="ln1588">PathManipulator::_SetModeForMousePos(BPoint where)</a>
<a name="ln1589">{</a>
<a name="ln1590">	uint32 mode = UNDEFINED;</a>
<a name="ln1591">	int32 index = -1;</a>
<a name="ln1592"> </a>
<a name="ln1593">	float zoomLevel = fCanvasView-&gt;ZoomLevel();</a>
<a name="ln1594"> </a>
<a name="ln1595">	// see if we're close enough at a control point</a>
<a name="ln1596">	BPoint point;</a>
<a name="ln1597">	BPoint pointIn;</a>
<a name="ln1598">	BPoint pointOut;</a>
<a name="ln1599">	for (int32 i = 0; fPath-&gt;GetPointsAt(i, point, pointIn, pointOut)</a>
<a name="ln1600">					  &amp;&amp; mode == UNDEFINED; i++) {</a>
<a name="ln1601"> </a>
<a name="ln1602">		float distM = point_point_distance(point, where) * zoomLevel;</a>
<a name="ln1603">		float distIn = point_point_distance(pointIn, where) * zoomLevel;</a>
<a name="ln1604">		float distOut = point_point_distance(pointOut, where) * zoomLevel;</a>
<a name="ln1605">		</a>
<a name="ln1606">		if (distM &lt; MOVE_THRESHOLD) {</a>
<a name="ln1607">			if (i == 0 &amp;&amp; fClickToClose</a>
<a name="ln1608">				&amp;&amp; !fPath-&gt;IsClosed() &amp;&amp; fPath-&gt;CountPoints() &gt; 1) {</a>
<a name="ln1609">				mode = fCommandDown ? TOGGLE_SHARP :</a>
<a name="ln1610">							(fOptionDown ? REMOVE_POINT : CLOSE_PATH);</a>
<a name="ln1611">				index = i;</a>
<a name="ln1612">			} else {</a>
<a name="ln1613">				mode = fCommandDown ? TOGGLE_SHARP :</a>
<a name="ln1614">							(fOptionDown ? REMOVE_POINT : MOVE_POINT);</a>
<a name="ln1615">				index = i;</a>
<a name="ln1616">			}</a>
<a name="ln1617">		}</a>
<a name="ln1618">		if (distM - distIn &gt; 0.00001</a>
<a name="ln1619">			&amp;&amp; distIn &lt; MOVE_THRESHOLD) {</a>
<a name="ln1620">			mode = fCommandDown ? TOGGLE_SHARP_IN : </a>
<a name="ln1621">						(fOptionDown ? REMOVE_POINT_IN : MOVE_POINT_IN);</a>
<a name="ln1622">			index = i;</a>
<a name="ln1623">		}</a>
<a name="ln1624">		if (distIn - distOut &gt; 0.00001</a>
<a name="ln1625">			&amp;&amp; distOut &lt; distM &amp;&amp; distOut &lt; MOVE_THRESHOLD) {</a>
<a name="ln1626">			mode = fCommandDown ? TOGGLE_SHARP_OUT :</a>
<a name="ln1627">						(fOptionDown ? REMOVE_POINT_OUT : MOVE_POINT_OUT);</a>
<a name="ln1628">			index = i;</a>
<a name="ln1629">		}</a>
<a name="ln1630">	}</a>
<a name="ln1631">	// selection mode overrides any other mode,</a>
<a name="ln1632">	// but we need to check for it after we know</a>
<a name="ln1633">	// the index of the point under the mouse (code above)</a>
<a name="ln1634">	int32 pointCount = fPath-&gt;CountPoints();</a>
<a name="ln1635">	if (fShiftDown &amp;&amp; pointCount &gt; 0) {</a>
<a name="ln1636">		mode = SELECT_POINTS;</a>
<a name="ln1637">	}</a>
<a name="ln1638"> </a>
<a name="ln1639">	// see if user wants to start new sub path</a>
<a name="ln1640">	if (fAltDown) {</a>
<a name="ln1641">		mode = NEW_PATH;</a>
<a name="ln1642">		index = -1;</a>
<a name="ln1643">	}</a>
<a name="ln1644"> </a>
<a name="ln1645">	// see if we're close enough at a line</a>
<a name="ln1646">	if (mode == UNDEFINED) {</a>
<a name="ln1647">		float distance;</a>
<a name="ln1648">		if (fPath-&gt;GetDistance(where, &amp;distance, &amp;index)) {</a>
<a name="ln1649">			if (distance &lt; (INSERT_DIST_THRESHOLD / zoomLevel)) {</a>
<a name="ln1650">				mode = INSERT_POINT;</a>
<a name="ln1651">			}</a>
<a name="ln1652">		} else {</a>
<a name="ln1653">			// restore index, since it was changed by call above</a>
<a name="ln1654">			index = fCurrentPathPoint;</a>
<a name="ln1655">		}</a>
<a name="ln1656">	}</a>
<a name="ln1657"> </a>
<a name="ln1658">	// nope, still undefined mode, last fall back</a>
<a name="ln1659">	if (mode == UNDEFINED) {</a>
<a name="ln1660">		if (fFallBackMode == SELECT_POINTS) {</a>
<a name="ln1661">			if (fPath-&gt;IsClosed() &amp;&amp; pointCount &gt; 0) {</a>
<a name="ln1662">				mode = SELECT_POINTS;</a>
<a name="ln1663">				index = -1;</a>
<a name="ln1664">			} else {</a>
<a name="ln1665">				mode = ADD_POINT;</a>
<a name="ln1666">				index = pointCount - 1;</a>
<a name="ln1667">			}</a>
<a name="ln1668">		} else {</a>
<a name="ln1669">			// user had clicked &quot;New Path&quot; icon</a>
<a name="ln1670">			mode = fFallBackMode;</a>
<a name="ln1671">		}</a>
<a name="ln1672">	}</a>
<a name="ln1673">	// switch mode if necessary</a>
<a name="ln1674">	if (mode != fMode || index != fCurrentPathPoint) {</a>
<a name="ln1675">		// invalidate path display (to highlight the respective point)</a>
<a name="ln1676">		_InvalidateHighlightPoints(index, mode);</a>
<a name="ln1677">		_SetMode(mode);</a>
<a name="ln1678">		fCurrentPathPoint = index;</a>
<a name="ln1679">	}</a>
<a name="ln1680">}</a>
<a name="ln1681"> </a>
<a name="ln1682">// #pragma mark -</a>
<a name="ln1683"> </a>
<a name="ln1684">// _Nudge</a>
<a name="ln1685">void</a>
<a name="ln1686">PathManipulator::_Nudge(BPoint direction)</a>
<a name="ln1687">{</a>
<a name="ln1688">	bigtime_t now = system_time();</a>
<a name="ln1689">	if (now - fLastNudgeTime &gt; 500000) {</a>
<a name="ln1690">		fCanvasView-&gt;Perform(_FinishNudging());</a>
<a name="ln1691">	}</a>
<a name="ln1692">	fLastNudgeTime = now;</a>
<a name="ln1693">	fNudgeOffset += direction;</a>
<a name="ln1694"> </a>
<a name="ln1695">	if (fTransformBox) {</a>
<a name="ln1696">		fTransformBox-&gt;NudgeBy(direction);</a>
<a name="ln1697">		return;</a>
<a name="ln1698">	}</a>
<a name="ln1699"> </a>
<a name="ln1700">	if (!fNudgeCommand) {</a>
<a name="ln1701"> </a>
<a name="ln1702">		bool fromSelection = !fSelection-&gt;IsEmpty();</a>
<a name="ln1703"> </a>
<a name="ln1704">		int32 count = fromSelection ? fSelection-&gt;CountItems()</a>
<a name="ln1705">									: fPath-&gt;CountPoints();</a>
<a name="ln1706">		int32 indices[count];</a>
<a name="ln1707">		BStackOrHeapArray&lt;control_point, 64&gt; points(count);</a>
<a name="ln1708"> </a>
<a name="ln1709">		// init indices and points</a>
<a name="ln1710">		for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln1711">			indices[i] = fromSelection ? fSelection-&gt;IndexAt(i) : i;</a>
<a name="ln1712">			fPath-&gt;GetPointsAt(indices[i],</a>
<a name="ln1713">							   points[i].point,</a>
<a name="ln1714">							   points[i].point_in,</a>
<a name="ln1715">							   points[i].point_out,</a>
<a name="ln1716">							   &amp;points[i].connected);</a>
<a name="ln1717">		}</a>
<a name="ln1718"> </a>
<a name="ln1719">		fNudgeCommand = new NudgePointsCommand(fPath, indices, points, count);</a>
<a name="ln1720"> </a>
<a name="ln1721">		fNudgeCommand-&gt;SetNewTranslation(fNudgeOffset);</a>
<a name="ln1722">		fNudgeCommand-&gt;Redo();</a>
<a name="ln1723"> </a>
<a name="ln1724">	} else {</a>
<a name="ln1725">		fNudgeCommand-&gt;SetNewTranslation(fNudgeOffset);</a>
<a name="ln1726">		fNudgeCommand-&gt;Redo();</a>
<a name="ln1727">	}</a>
<a name="ln1728"> </a>
<a name="ln1729">	if (!fMouseDown)</a>
<a name="ln1730">		_SetModeForMousePos(fLastCanvasPos);</a>
<a name="ln1731">}</a>
<a name="ln1732"> </a>
<a name="ln1733">// _FinishNudging</a>
<a name="ln1734">Command*</a>
<a name="ln1735">PathManipulator::_FinishNudging()</a>
<a name="ln1736">{</a>
<a name="ln1737">	fNudgeOffset = BPoint(0.0, 0.0);</a>
<a name="ln1738"> </a>
<a name="ln1739">	Command* command;</a>
<a name="ln1740"> </a>
<a name="ln1741">	if (fTransformBox) {</a>
<a name="ln1742">		command = fTransformBox-&gt;FinishNudging();</a>
<a name="ln1743">	} else {</a>
<a name="ln1744">		command = fNudgeCommand;</a>
<a name="ln1745">		fNudgeCommand = NULL;</a>
<a name="ln1746">	}</a>
<a name="ln1747"> </a>
<a name="ln1748">	return command;</a>
<a name="ln1749">}</a>
<a name="ln1750"> </a>
<a name="ln1751"> </a>

</code></pre>
<div class="balloon" rel="266"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fBlack, fSkip.</p></div>
<div class="balloon" rel="814"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'menu' pointer. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
