
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>if_an.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * SPDX-License-Identifier: BSD-4-Clause</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 1997, 1998, 1999</a>
<a name="ln5"> *	Bill Paul &lt;wpaul@ctr.columbia.edu&gt;.  All rights reserved.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln8"> * modification, are permitted provided that the following conditions</a>
<a name="ln9"> * are met:</a>
<a name="ln10"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln11"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln12"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln13"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln14"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln15"> * 3. All advertising materials mentioning features or use of this software</a>
<a name="ln16"> *    must display the following acknowledgement:</a>
<a name="ln17"> *	This product includes software developed by Bill Paul.</a>
<a name="ln18"> * 4. Neither the name of the author nor the names of any co-contributors</a>
<a name="ln19"> *    may be used to endorse or promote products derived from this software</a>
<a name="ln20"> *    without specific prior written permission.</a>
<a name="ln21"> *</a>
<a name="ln22"> * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln23"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln24"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln25"> * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD</a>
<a name="ln26"> * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</a>
<a name="ln27"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</a>
<a name="ln28"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</a>
<a name="ln29"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</a>
<a name="ln30"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</a>
<a name="ln31"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF</a>
<a name="ln32"> * THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln33"> */</a>
<a name="ln34">/*</a>
<a name="ln35"> * Aironet 4500/4800 802.11 PCMCIA/ISA/PCI driver for FreeBSD.</a>
<a name="ln36"> *</a>
<a name="ln37"> * Written by Bill Paul &lt;wpaul@ctr.columbia.edu&gt;</a>
<a name="ln38"> * Electrical Engineering Department</a>
<a name="ln39"> * Columbia University, New York City</a>
<a name="ln40"> */</a>
<a name="ln41"> </a>
<a name="ln42">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln43">__FBSDID(&quot;$FreeBSD: releng/12.0/sys/dev/an/if_an.c 331797 2018-03-30 18:50:13Z brooks $&quot;);</a>
<a name="ln44"> </a>
<a name="ln45">/*</a>
<a name="ln46"> * The Aironet 4500/4800 series cards come in PCMCIA, ISA and PCI form.</a>
<a name="ln47"> * This driver supports all three device types (PCI devices are supported</a>
<a name="ln48"> * through an extra PCI shim: /sys/dev/an/if_an_pci.c). ISA devices can be</a>
<a name="ln49"> * supported either using hard-coded IO port/IRQ settings or via Plug</a>
<a name="ln50"> * and Play. The 4500 series devices support 1Mbps and 2Mbps data rates.</a>
<a name="ln51"> * The 4800 devices support 1, 2, 5.5 and 11Mbps rates.</a>
<a name="ln52"> *</a>
<a name="ln53"> * Like the WaveLAN/IEEE cards, the Aironet NICs are all essentially</a>
<a name="ln54"> * PCMCIA devices. The ISA and PCI cards are a combination of a PCMCIA</a>
<a name="ln55"> * device and a PCMCIA to ISA or PCMCIA to PCI adapter card. There are</a>
<a name="ln56"> * a couple of important differences though:</a>
<a name="ln57"> *</a>
<a name="ln58"> * - Lucent ISA card looks to the host like a PCMCIA controller with</a>
<a name="ln59"> *   a PCMCIA WaveLAN card inserted. This means that even desktop</a>
<a name="ln60"> *   machines need to be configured with PCMCIA support in order to</a>
<a name="ln61"> *   use WaveLAN/IEEE ISA cards. The Aironet cards on the other hand</a>
<a name="ln62"> *   actually look like normal ISA and PCI devices to the host, so</a>
<a name="ln63"> *   no PCMCIA controller support is needed</a>
<a name="ln64"> *</a>
<a name="ln65"> * The latter point results in a small gotcha. The Aironet PCMCIA</a>
<a name="ln66"> * cards can be configured for one of two operating modes depending</a>
<a name="ln67"> * on how the Vpp1 and Vpp2 programming voltages are set when the</a>
<a name="ln68"> * card is activated. In order to put the card in proper PCMCIA</a>
<a name="ln69"> * operation (where the CIS table is visible and the interface is</a>
<a name="ln70"> * programmed for PCMCIA operation), both Vpp1 and Vpp2 have to be</a>
<a name="ln71"> * set to 5 volts. FreeBSD by default doesn't set the Vpp voltages,</a>
<a name="ln72"> * which leaves the card in ISA/PCI mode, which prevents it from</a>
<a name="ln73"> * being activated as an PCMCIA device.</a>
<a name="ln74"> *</a>
<a name="ln75"> * Note that some PCMCIA controller software packages for Windows NT</a>
<a name="ln76"> * fail to set the voltages as well.</a>
<a name="ln77"> *</a>
<a name="ln78"> * The Aironet devices can operate in both station mode and access point</a>
<a name="ln79"> * mode. Typically, when programmed for station mode, the card can be set</a>
<a name="ln80"> * to automatically perform encapsulation/decapsulation of Ethernet II</a>
<a name="ln81"> * and 802.3 frames within 802.11 frames so that the host doesn't have</a>
<a name="ln82"> * to do it itself. This driver doesn't program the card that way: the</a>
<a name="ln83"> * driver handles all of the encapsulation/decapsulation itself.</a>
<a name="ln84"> */</a>
<a name="ln85"> </a>
<a name="ln86">#include &quot;opt_inet.h&quot;</a>
<a name="ln87"> </a>
<a name="ln88">#ifdef INET</a>
<a name="ln89">#define ANCACHE			/* enable signal strength cache */</a>
<a name="ln90">#endif</a>
<a name="ln91"> </a>
<a name="ln92">#include &lt;sys/param.h&gt;</a>
<a name="ln93">#include &lt;sys/ctype.h&gt;</a>
<a name="ln94">#include &lt;sys/systm.h&gt;</a>
<a name="ln95">#include &lt;sys/sockio.h&gt;</a>
<a name="ln96">#include &lt;sys/mbuf.h&gt;</a>
<a name="ln97">#include &lt;sys/priv.h&gt;</a>
<a name="ln98">#include &lt;sys/proc.h&gt;</a>
<a name="ln99">#include &lt;sys/kernel.h&gt;</a>
<a name="ln100">#include &lt;sys/socket.h&gt;</a>
<a name="ln101">#ifdef ANCACHE</a>
<a name="ln102">#include &lt;sys/syslog.h&gt;</a>
<a name="ln103">#endif</a>
<a name="ln104">#include &lt;sys/sysctl.h&gt;</a>
<a name="ln105"> </a>
<a name="ln106">#include &lt;sys/module.h&gt;</a>
<a name="ln107">#include &lt;sys/bus.h&gt;</a>
<a name="ln108">#include &lt;machine/bus.h&gt;</a>
<a name="ln109">#include &lt;sys/rman.h&gt;</a>
<a name="ln110">#include &lt;sys/lock.h&gt;</a>
<a name="ln111">#include &lt;sys/mutex.h&gt;</a>
<a name="ln112">#include &lt;machine/resource.h&gt;</a>
<a name="ln113">#include &lt;sys/malloc.h&gt;</a>
<a name="ln114"> </a>
<a name="ln115">#include &lt;net/if.h&gt;</a>
<a name="ln116">#include &lt;net/if_var.h&gt;</a>
<a name="ln117">#include &lt;net/if_arp.h&gt;</a>
<a name="ln118">#include &lt;net/if_dl.h&gt;</a>
<a name="ln119">#include &lt;net/ethernet.h&gt;</a>
<a name="ln120">#include &lt;net/if_types.h&gt;</a>
<a name="ln121">#include &lt;net/if_media.h&gt;</a>
<a name="ln122"> </a>
<a name="ln123">#include &lt;net80211/ieee80211_var.h&gt;</a>
<a name="ln124">#include &lt;net80211/ieee80211_ioctl.h&gt;</a>
<a name="ln125"> </a>
<a name="ln126">#ifdef INET</a>
<a name="ln127">#include &lt;netinet/in.h&gt;</a>
<a name="ln128">#include &lt;netinet/in_systm.h&gt;</a>
<a name="ln129">#include &lt;netinet/in_var.h&gt;</a>
<a name="ln130">#include &lt;netinet/ip.h&gt;</a>
<a name="ln131">#endif</a>
<a name="ln132"> </a>
<a name="ln133">#include &lt;net/bpf.h&gt;</a>
<a name="ln134"> </a>
<a name="ln135">#include &lt;machine/md_var.h&gt;</a>
<a name="ln136"> </a>
<a name="ln137">#include &lt;dev/an/if_aironet_ieee.h&gt;</a>
<a name="ln138">#include &lt;dev/an/if_anreg.h&gt;</a>
<a name="ln139"> </a>
<a name="ln140">/* These are global because we need them in sys/pci/if_an_p.c. */</a>
<a name="ln141">static void an_reset(struct an_softc *);</a>
<a name="ln142">static int an_init_mpi350_desc(struct an_softc *);</a>
<a name="ln143">static int an_ioctl(struct ifnet *, u_long, caddr_t);</a>
<a name="ln144">static void an_init(void *);</a>
<a name="ln145">static void an_init_locked(struct an_softc *);</a>
<a name="ln146">static int an_init_tx_ring(struct an_softc *);</a>
<a name="ln147">static void an_start(struct ifnet *);</a>
<a name="ln148">static void an_start_locked(struct ifnet *);</a>
<a name="ln149">static void an_watchdog(struct an_softc *);</a>
<a name="ln150">static void an_rxeof(struct an_softc *);</a>
<a name="ln151">static void an_txeof(struct an_softc *, int);</a>
<a name="ln152"> </a>
<a name="ln153">static void an_promisc(struct an_softc *, int);</a>
<a name="ln154">static int an_cmd(struct an_softc *, int, int);</a>
<a name="ln155">static int an_cmd_struct(struct an_softc *, struct an_command *,</a>
<a name="ln156">    struct an_reply *);</a>
<a name="ln157">static int an_read_record(struct an_softc *, struct an_ltv_gen *);</a>
<a name="ln158">static int an_write_record(struct an_softc *, struct an_ltv_gen *);</a>
<a name="ln159">static int an_read_data(struct an_softc *, int, int, caddr_t, int);</a>
<a name="ln160">static int an_write_data(struct an_softc *, int, int, caddr_t, int);</a>
<a name="ln161">static int an_seek(struct an_softc *, int, int, int);</a>
<a name="ln162">static int an_alloc_nicmem(struct an_softc *, int, int *);</a>
<a name="ln163">static int an_dma_malloc(struct an_softc *, bus_size_t, struct an_dma_alloc *,</a>
<a name="ln164">    int);</a>
<a name="ln165">static void an_dma_free(struct an_softc *, struct an_dma_alloc *);</a>
<a name="ln166">static void an_dma_malloc_cb(void *, bus_dma_segment_t *, int, int);</a>
<a name="ln167">static void an_stats_update(void *);</a>
<a name="ln168">static void an_setdef(struct an_softc *, struct an_req *);</a>
<a name="ln169">#ifdef ANCACHE</a>
<a name="ln170">static void an_cache_store(struct an_softc *, struct ether_header *,</a>
<a name="ln171">    struct mbuf *, u_int8_t, u_int8_t);</a>
<a name="ln172">#endif</a>
<a name="ln173"> </a>
<a name="ln174">/* function definitions for use with the Cisco's Linux configuration</a>
<a name="ln175">   utilities</a>
<a name="ln176">*/</a>
<a name="ln177"> </a>
<a name="ln178">static int readrids(struct ifnet*, struct aironet_ioctl*);</a>
<a name="ln179">static int writerids(struct ifnet*, struct aironet_ioctl*);</a>
<a name="ln180">static int flashcard(struct ifnet*, struct aironet_ioctl*);</a>
<a name="ln181"> </a>
<a name="ln182">static int cmdreset(struct ifnet *);</a>
<a name="ln183">static int setflashmode(struct ifnet *);</a>
<a name="ln184">static int flashgchar(struct ifnet *,int,int);</a>
<a name="ln185">static int flashpchar(struct ifnet *,int,int);</a>
<a name="ln186">static int flashputbuf(struct ifnet *);</a>
<a name="ln187">static int flashrestart(struct ifnet *);</a>
<a name="ln188">static int WaitBusy(struct ifnet *, int);</a>
<a name="ln189">static int unstickbusy(struct ifnet *);</a>
<a name="ln190"> </a>
<a name="ln191">static void an_dump_record	(struct an_softc *,struct an_ltv_gen *,</a>
<a name="ln192">				    char *);</a>
<a name="ln193"> </a>
<a name="ln194">static int an_media_change	(struct ifnet *);</a>
<a name="ln195">static void an_media_status	(struct ifnet *, struct ifmediareq *);</a>
<a name="ln196"> </a>
<a name="ln197">static int	an_dump = 0;</a>
<a name="ln198">static int	an_cache_mode = 0;</a>
<a name="ln199"> </a>
<a name="ln200">#define DBM 0</a>
<a name="ln201">#define PERCENT 1</a>
<a name="ln202">#define RAW 2</a>
<a name="ln203"> </a>
<a name="ln204">static char an_conf[256];</a>
<a name="ln205">static char an_conf_cache[256];</a>
<a name="ln206"> </a>
<a name="ln207">/* sysctl vars */</a>
<a name="ln208"> </a>
<a name="ln209">static SYSCTL_NODE(_hw, OID_AUTO, an, CTLFLAG_RD, 0,</a>
<a name="ln210">    &quot;Wireless driver parameters&quot;);</a>
<a name="ln211"> </a>
<a name="ln212">/* XXX violate ethernet/netgraph callback hooks */</a>
<a name="ln213">extern	void	(*ng_ether_attach_p)(struct ifnet *ifp);</a>
<a name="ln214">extern	void	(*ng_ether_detach_p)(struct ifnet *ifp);</a>
<a name="ln215"> </a>
<a name="ln216">static int</a>
<a name="ln217">sysctl_an_dump(SYSCTL_HANDLER_ARGS)</a>
<a name="ln218">{</a>
<a name="ln219">	int	error, r, last;</a>
<a name="ln220">	char 	*s = an_conf;</a>
<a name="ln221"> </a>
<a name="ln222">	last = an_dump;</a>
<a name="ln223"> </a>
<a name="ln224">	switch (an_dump) {</a>
<a name="ln225">	case 0:</a>
<a name="ln226">		strcpy(an_conf, &quot;off&quot;);</a>
<a name="ln227">		break;</a>
<a name="ln228">	case 1:</a>
<a name="ln229">		strcpy(an_conf, &quot;type&quot;);</a>
<a name="ln230">		break;</a>
<a name="ln231">	case 2:</a>
<a name="ln232">		strcpy(an_conf, &quot;dump&quot;);</a>
<a name="ln233">		break;</a>
<a name="ln234">	default:</a>
<a name="ln235">		snprintf(an_conf, 5, &quot;%x&quot;, an_dump);</a>
<a name="ln236">		break;</a>
<a name="ln237">	}</a>
<a name="ln238"> </a>
<a name="ln239">	error = sysctl_handle_string(oidp, an_conf, sizeof(an_conf), req);</a>
<a name="ln240"> </a>
<a name="ln241">	if (strncmp(an_conf,&quot;off&quot;, 3) == 0) {</a>
<a name="ln242">		an_dump = 0;</a>
<a name="ln243"> 	}</a>
<a name="ln244">	if (strncmp(an_conf,&quot;dump&quot;, 4) == 0) {</a>
<a name="ln245">		an_dump = 1;</a>
<a name="ln246">	}</a>
<a name="ln247">	if (strncmp(an_conf,&quot;type&quot;, 4) == 0) {</a>
<a name="ln248">		an_dump = 2;</a>
<a name="ln249">	}</a>
<a name="ln250">	if (*s == 'f') {</a>
<a name="ln251">		r = 0;</a>
<a name="ln252">		for (;;s++) {</a>
<a name="ln253">			if ((*s &gt;= '0') &amp;&amp; (*s &lt;= '9')) {</a>
<a name="ln254">				r = r * 16 + (*s - '0');</a>
<a name="ln255">			} else if ((*s &gt;= 'a') &amp;&amp; (*s &lt;= 'f')) {</a>
<a name="ln256">				r = r * 16 + (*s - 'a' + 10);</a>
<a name="ln257">			} else {</a>
<a name="ln258">				break;</a>
<a name="ln259">			}</a>
<a name="ln260">		}</a>
<a name="ln261">		an_dump = r;</a>
<a name="ln262">	}</a>
<a name="ln263">	if (an_dump != last)</a>
<a name="ln264">		printf(&quot;Sysctl changed for Aironet driver\n&quot;);</a>
<a name="ln265"> </a>
<a name="ln266">	return error;</a>
<a name="ln267">}</a>
<a name="ln268"> </a>
<a name="ln269">SYSCTL_PROC(_hw_an, OID_AUTO, an_dump, CTLTYPE_STRING | CTLFLAG_RW,</a>
<a name="ln270">	    0, sizeof(an_conf), sysctl_an_dump, &quot;A&quot;, &quot;&quot;);</a>
<a name="ln271"> </a>
<a name="ln272">static int</a>
<a name="ln273">sysctl_an_cache_mode(SYSCTL_HANDLER_ARGS)</a>
<a name="ln274">{</a>
<a name="ln275">	int	error;</a>
<a name="ln276"> </a>
<a name="ln277">	switch (an_cache_mode) {</a>
<a name="ln278">	case 1:</a>
<a name="ln279">		strcpy(an_conf_cache, &quot;per&quot;);</a>
<a name="ln280">		break;</a>
<a name="ln281">	case 2:</a>
<a name="ln282">		strcpy(an_conf_cache, &quot;raw&quot;);</a>
<a name="ln283">		break;</a>
<a name="ln284">	default:</a>
<a name="ln285">		strcpy(an_conf_cache, &quot;dbm&quot;);</a>
<a name="ln286">		break;</a>
<a name="ln287">	}</a>
<a name="ln288"> </a>
<a name="ln289">	error = sysctl_handle_string(oidp, an_conf_cache,</a>
<a name="ln290">			sizeof(an_conf_cache), req);</a>
<a name="ln291"> </a>
<a name="ln292">	if (strncmp(an_conf_cache,&quot;dbm&quot;, 3) == 0) {</a>
<a name="ln293">		an_cache_mode = 0;</a>
<a name="ln294">	}</a>
<a name="ln295">	if (strncmp(an_conf_cache,&quot;per&quot;, 3) == 0) {</a>
<a name="ln296">		an_cache_mode = 1;</a>
<a name="ln297"> 	}</a>
<a name="ln298">	if (strncmp(an_conf_cache,&quot;raw&quot;, 3) == 0) {</a>
<a name="ln299">		an_cache_mode = 2;</a>
<a name="ln300">	}</a>
<a name="ln301"> </a>
<a name="ln302">	return error;</a>
<a name="ln303">}</a>
<a name="ln304"> </a>
<a name="ln305">SYSCTL_PROC(_hw_an, OID_AUTO, an_cache_mode, CTLTYPE_STRING | CTLFLAG_RW,</a>
<a name="ln306">	    0, sizeof(an_conf_cache), sysctl_an_cache_mode, &quot;A&quot;, &quot;&quot;);</a>
<a name="ln307"> </a>
<a name="ln308">/*</a>
<a name="ln309"> * We probe for an Aironet 4500/4800 card by attempting to</a>
<a name="ln310"> * read the default SSID list. On reset, the first entry in</a>
<a name="ln311"> * the SSID list will contain the name &quot;tsunami.&quot; If we don't</a>
<a name="ln312"> * find this, then there's no card present.</a>
<a name="ln313"> */</a>
<a name="ln314">int</a>
<a name="ln315">an_probe(device_t dev)</a>
<a name="ln316">{</a>
<a name="ln317">	struct an_softc *sc = device_get_softc(dev);</a>
<a name="ln318">	struct an_ltv_ssidlist_new	ssid;</a>
<a name="ln319">	int	error;</a>
<a name="ln320"> </a>
<a name="ln321">	bzero((char *)&amp;ssid, sizeof(ssid));</a>
<a name="ln322"> </a>
<a name="ln323">	error = an_alloc_port(dev, 0, AN_IOSIZ);</a>
<a name="ln324">	if (error != 0)</a>
<a name="ln325">		return (0);</a>
<a name="ln326"> </a>
<a name="ln327">	/* can't do autoprobing */</a>
<a name="ln328">	if (rman_get_start(sc-&gt;port_res) == -1)</a>
<a name="ln329">		return(0);</a>
<a name="ln330"> </a>
<a name="ln331">	/*</a>
<a name="ln332">	 * We need to fake up a softc structure long enough</a>
<a name="ln333">	 * to be able to issue commands and call some of the</a>
<a name="ln334">	 * other routines.</a>
<a name="ln335">	 */</a>
<a name="ln336">	ssid.an_len = sizeof(ssid);</a>
<a name="ln337">	ssid.an_type = AN_RID_SSIDLIST;</a>
<a name="ln338"> </a>
<a name="ln339">	/* Make sure interrupts are disabled. */</a>
<a name="ln340">	sc-&gt;mpi350 = 0;</a>
<a name="ln341">	CSR_WRITE_2(sc, AN_INT_EN(sc-&gt;mpi350), 0);</a>
<a name="ln342">	CSR_WRITE_2(sc, AN_EVENT_ACK(sc-&gt;mpi350), 0xFFFF);</a>
<a name="ln343"> </a>
<a name="ln344">	sc-&gt;an_dev = dev;</a>
<a name="ln345">	mtx_init(&amp;sc-&gt;an_mtx, device_get_nameunit(dev), MTX_NETWORK_LOCK,</a>
<a name="ln346">	    MTX_DEF);</a>
<a name="ln347">	AN_LOCK(sc);</a>
<a name="ln348">	an_reset(sc);</a>
<a name="ln349"> </a>
<a name="ln350">	if (an_cmd(sc, AN_CMD_READCFG, 0)) {</a>
<a name="ln351">		AN_UNLOCK(sc);</a>
<a name="ln352">		goto fail;</a>
<a name="ln353">	}</a>
<a name="ln354"> </a>
<a name="ln355">	if (an_read_record(sc, (struct an_ltv_gen *)&amp;ssid)) {</a>
<a name="ln356">		AN_UNLOCK(sc);</a>
<a name="ln357">		goto fail;</a>
<a name="ln358">	}</a>
<a name="ln359"> </a>
<a name="ln360">	/* See if the ssid matches what we expect ... but doesn't have to */</a>
<a name="ln361">	if (strcmp(ssid.an_entry[0].an_ssid, AN_DEF_SSID)) {</a>
<a name="ln362">		AN_UNLOCK(sc);</a>
<a name="ln363">		goto fail;</a>
<a name="ln364">	}</a>
<a name="ln365"> </a>
<a name="ln366">	AN_UNLOCK(sc);</a>
<a name="ln367">	return(AN_IOSIZ);</a>
<a name="ln368">fail:</a>
<a name="ln369">	mtx_destroy(&amp;sc-&gt;an_mtx);</a>
<a name="ln370">	return(0);</a>
<a name="ln371">}</a>
<a name="ln372"> </a>
<a name="ln373">/*</a>
<a name="ln374"> * Allocate a port resource with the given resource id.</a>
<a name="ln375"> */</a>
<a name="ln376">int</a>
<a name="ln377">an_alloc_port(device_t dev, int rid, int size)</a>
<a name="ln378">{</a>
<a name="ln379">	struct an_softc *sc = device_get_softc(dev);</a>
<a name="ln380">	struct resource *res;</a>
<a name="ln381"> </a>
<a name="ln382">	res = bus_alloc_resource_anywhere(dev, SYS_RES_IOPORT, &amp;rid,</a>
<a name="ln383">					  size, RF_ACTIVE);</a>
<a name="ln384">	if (res) {</a>
<a name="ln385">		sc-&gt;port_rid = rid;</a>
<a name="ln386">		sc-&gt;port_res = res;</a>
<a name="ln387">		return (0);</a>
<a name="ln388">	} else {</a>
<a name="ln389">		return (ENOENT);</a>
<a name="ln390">	}</a>
<a name="ln391">}</a>
<a name="ln392"> </a>
<a name="ln393">/*</a>
<a name="ln394"> * Allocate a memory resource with the given resource id.</a>
<a name="ln395"> */</a>
<a name="ln396">int an_alloc_memory(device_t dev, int rid, int size)</a>
<a name="ln397">{</a>
<a name="ln398">	struct an_softc *sc = device_get_softc(dev);</a>
<a name="ln399">	struct resource *res;</a>
<a name="ln400"> </a>
<a name="ln401">	res = bus_alloc_resource_anywhere(dev, SYS_RES_MEMORY, &amp;rid,</a>
<a name="ln402">					  size, RF_ACTIVE);</a>
<a name="ln403">	if (res) {</a>
<a name="ln404">		sc-&gt;mem_rid = rid;</a>
<a name="ln405">		sc-&gt;mem_res = res;</a>
<a name="ln406">		sc-&gt;mem_used = size;</a>
<a name="ln407">		return (0);</a>
<a name="ln408">	} else {</a>
<a name="ln409">		return (ENOENT);</a>
<a name="ln410">	}</a>
<a name="ln411">}</a>
<a name="ln412"> </a>
<a name="ln413">/*</a>
<a name="ln414"> * Allocate a auxiliary memory resource with the given resource id.</a>
<a name="ln415"> */</a>
<a name="ln416">int an_alloc_aux_memory(device_t dev, int rid, int size)</a>
<a name="ln417">{</a>
<a name="ln418">	struct an_softc *sc = device_get_softc(dev);</a>
<a name="ln419">	struct resource *res;</a>
<a name="ln420"> </a>
<a name="ln421">	res = bus_alloc_resource_anywhere(dev, SYS_RES_MEMORY, &amp;rid,</a>
<a name="ln422">					  size, RF_ACTIVE);</a>
<a name="ln423">	if (res) {</a>
<a name="ln424">		sc-&gt;mem_aux_rid = rid;</a>
<a name="ln425">		sc-&gt;mem_aux_res = res;</a>
<a name="ln426">		sc-&gt;mem_aux_used = size;</a>
<a name="ln427">		return (0);</a>
<a name="ln428">	} else {</a>
<a name="ln429">		return (ENOENT);</a>
<a name="ln430">	}</a>
<a name="ln431">}</a>
<a name="ln432"> </a>
<a name="ln433">/*</a>
<a name="ln434"> * Allocate an irq resource with the given resource id.</a>
<a name="ln435"> */</a>
<a name="ln436">int</a>
<a name="ln437">an_alloc_irq(device_t dev, int rid, int flags)</a>
<a name="ln438">{</a>
<a name="ln439">	struct an_softc *sc = device_get_softc(dev);</a>
<a name="ln440">	struct resource *res;</a>
<a name="ln441"> </a>
<a name="ln442">	res = bus_alloc_resource_any(dev, SYS_RES_IRQ, &amp;rid,</a>
<a name="ln443">				     (RF_ACTIVE | flags));</a>
<a name="ln444">	if (res) {</a>
<a name="ln445">		sc-&gt;irq_rid = rid;</a>
<a name="ln446">		sc-&gt;irq_res = res;</a>
<a name="ln447">		return (0);</a>
<a name="ln448">	} else {</a>
<a name="ln449">		return (ENOENT);</a>
<a name="ln450">	}</a>
<a name="ln451">}</a>
<a name="ln452"> </a>
<a name="ln453">static void</a>
<a name="ln454">an_dma_malloc_cb(void *arg, bus_dma_segment_t *segs, int nseg, int error)</a>
<a name="ln455">{</a>
<a name="ln456">	bus_addr_t *paddr = (bus_addr_t*) arg;</a>
<a name="ln457">	*paddr = segs-&gt;ds_addr;</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460">/*</a>
<a name="ln461"> * Alloc DMA memory and set the pointer to it</a>
<a name="ln462"> */</a>
<a name="ln463">static int</a>
<a name="ln464">an_dma_malloc(struct an_softc *sc, bus_size_t size, struct an_dma_alloc *dma,</a>
<a name="ln465">    int mapflags)</a>
<a name="ln466">{</a>
<a name="ln467">	int r;</a>
<a name="ln468"> </a>
<a name="ln469">	r = bus_dmamem_alloc(sc-&gt;an_dtag, (void**) &amp;dma-&gt;an_dma_vaddr,</a>
<a name="ln470">			     BUS_DMA_NOWAIT, &amp;dma-&gt;an_dma_map);</a>
<a name="ln471">	if (r != 0)</a>
<a name="ln472">		goto fail_1;</a>
<a name="ln473"> </a>
<a name="ln474">	r = bus_dmamap_load(sc-&gt;an_dtag, dma-&gt;an_dma_map, dma-&gt;an_dma_vaddr,</a>
<a name="ln475">			    size,</a>
<a name="ln476">			    an_dma_malloc_cb,</a>
<a name="ln477">			    &amp;dma-&gt;an_dma_paddr,</a>
<a name="ln478">			    mapflags | BUS_DMA_NOWAIT);</a>
<a name="ln479">	if (r != 0)</a>
<a name="ln480">		goto fail_2;</a>
<a name="ln481"> </a>
<a name="ln482">	dma-&gt;an_dma_size = size;</a>
<a name="ln483">	return (0);</a>
<a name="ln484"> </a>
<a name="ln485">fail_2:</a>
<a name="ln486">	bus_dmamap_unload(sc-&gt;an_dtag, dma-&gt;an_dma_map);</a>
<a name="ln487">fail_1:</a>
<a name="ln488">	bus_dmamem_free(sc-&gt;an_dtag, dma-&gt;an_dma_vaddr, dma-&gt;an_dma_map);</a>
<a name="ln489">	return (r);</a>
<a name="ln490">}</a>
<a name="ln491"> </a>
<a name="ln492">static void</a>
<a name="ln493">an_dma_free(struct an_softc *sc, struct an_dma_alloc *dma)</a>
<a name="ln494">{</a>
<a name="ln495">	bus_dmamap_unload(sc-&gt;an_dtag, dma-&gt;an_dma_map);</a>
<a name="ln496">	bus_dmamem_free(sc-&gt;an_dtag, dma-&gt;an_dma_vaddr, dma-&gt;an_dma_map);</a>
<a name="ln497">	dma-&gt;an_dma_vaddr = 0;</a>
<a name="ln498">}</a>
<a name="ln499"> </a>
<a name="ln500">/*</a>
<a name="ln501"> * Release all resources</a>
<a name="ln502"> */</a>
<a name="ln503">void</a>
<a name="ln504">an_release_resources(device_t dev)</a>
<a name="ln505">{</a>
<a name="ln506">	struct an_softc *sc = device_get_softc(dev);</a>
<a name="ln507">	int i;</a>
<a name="ln508"> </a>
<a name="ln509">	if (sc-&gt;port_res) {</a>
<a name="ln510">		bus_release_resource(dev, SYS_RES_IOPORT,</a>
<a name="ln511">				     sc-&gt;port_rid, sc-&gt;port_res);</a>
<a name="ln512">		sc-&gt;port_res = 0;</a>
<a name="ln513">	}</a>
<a name="ln514">	if (sc-&gt;mem_res) {</a>
<a name="ln515">		bus_release_resource(dev, SYS_RES_MEMORY,</a>
<a name="ln516">				     sc-&gt;mem_rid, sc-&gt;mem_res);</a>
<a name="ln517">		sc-&gt;mem_res = 0;</a>
<a name="ln518">	}</a>
<a name="ln519">	if (sc-&gt;mem_aux_res) {</a>
<a name="ln520">		bus_release_resource(dev, SYS_RES_MEMORY,</a>
<a name="ln521">				     sc-&gt;mem_aux_rid, sc-&gt;mem_aux_res);</a>
<a name="ln522">		sc-&gt;mem_aux_res = 0;</a>
<a name="ln523">	}</a>
<a name="ln524">	if (sc-&gt;irq_res) {</a>
<a name="ln525">		bus_release_resource(dev, SYS_RES_IRQ,</a>
<a name="ln526">				     sc-&gt;irq_rid, sc-&gt;irq_res);</a>
<a name="ln527">		sc-&gt;irq_res = 0;</a>
<a name="ln528">	}</a>
<a name="ln529">	if (sc-&gt;an_rid_buffer.an_dma_paddr) {</a>
<a name="ln530">		an_dma_free(sc, &amp;sc-&gt;an_rid_buffer);</a>
<a name="ln531">	}</a>
<a name="ln532">	for (i = 0; i &lt; AN_MAX_RX_DESC; i++)</a>
<a name="ln533">		if (sc-&gt;an_rx_buffer[i].an_dma_paddr) {</a>
<a name="ln534">			an_dma_free(sc, &amp;sc-&gt;an_rx_buffer[i]);</a>
<a name="ln535">		}</a>
<a name="ln536">	for (i = 0; i &lt; AN_MAX_TX_DESC; i++)</a>
<a name="ln537">		if (sc-&gt;an_tx_buffer[i].an_dma_paddr) {</a>
<a name="ln538">			an_dma_free(sc, &amp;sc-&gt;an_tx_buffer[i]);</a>
<a name="ln539">		}</a>
<a name="ln540">	if (sc-&gt;an_dtag) {</a>
<a name="ln541">		bus_dma_tag_destroy(sc-&gt;an_dtag);</a>
<a name="ln542">	}</a>
<a name="ln543"> </a>
<a name="ln544">}</a>
<a name="ln545"> </a>
<a name="ln546">int</a>
<a name="ln547">an_init_mpi350_desc(struct an_softc *sc)</a>
<a name="ln548">{</a>
<a name="ln549">	struct an_command	cmd_struct;</a>
<a name="ln550">	struct an_reply		reply;</a>
<a name="ln551">	struct an_card_rid_desc an_rid_desc;</a>
<a name="ln552">	struct an_card_rx_desc	an_rx_desc;</a>
<a name="ln553">	struct an_card_tx_desc	an_tx_desc;</a>
<a name="ln554">	int			i, desc;</a>
<a name="ln555"> </a>
<a name="ln556">	AN_LOCK_ASSERT(sc);</a>
<a name="ln557">	if(!sc-&gt;an_rid_buffer.an_dma_paddr)</a>
<a name="ln558">		an_dma_malloc(sc, AN_RID_BUFFER_SIZE,</a>
<a name="ln559">				 &amp;sc-&gt;an_rid_buffer, 0);</a>
<a name="ln560">	for (i = 0; i &lt; AN_MAX_RX_DESC; i++)</a>
<a name="ln561">		if(!sc-&gt;an_rx_buffer[i].an_dma_paddr)</a>
<a name="ln562">			an_dma_malloc(sc, AN_RX_BUFFER_SIZE,</a>
<a name="ln563">				      &amp;sc-&gt;an_rx_buffer[i], 0);</a>
<a name="ln564">	for (i = 0; i &lt; AN_MAX_TX_DESC; i++)</a>
<a name="ln565">		if(!sc-&gt;an_tx_buffer[i].an_dma_paddr)</a>
<a name="ln566">			an_dma_malloc(sc, AN_TX_BUFFER_SIZE,</a>
<a name="ln567">				      &amp;sc-&gt;an_tx_buffer[i], 0);</a>
<a name="ln568"> </a>
<a name="ln569">	/*</a>
<a name="ln570">	 * Allocate RX descriptor</a>
<a name="ln571">	 */</a>
<a name="ln572">	bzero(&amp;reply,sizeof(reply));</a>
<a name="ln573">	cmd_struct.an_cmd   = AN_CMD_ALLOC_DESC;</a>
<a name="ln574">	cmd_struct.an_parm0 = AN_DESCRIPTOR_RX;</a>
<a name="ln575">	cmd_struct.an_parm1 = AN_RX_DESC_OFFSET;</a>
<a name="ln576">	cmd_struct.an_parm2 = AN_MAX_RX_DESC;</a>
<a name="ln577">	if (an_cmd_struct(sc, &amp;cmd_struct, &amp;reply)) {</a>
<a name="ln578">		if_printf(sc-&gt;an_ifp, &quot;failed to allocate RX descriptor\n&quot;);</a>
<a name="ln579">		return(EIO);</a>
<a name="ln580">	}</a>
<a name="ln581"> </a>
<a name="ln582">	for (desc = 0; desc &lt; AN_MAX_RX_DESC; desc++) {</a>
<a name="ln583">		bzero(&amp;an_rx_desc, sizeof(an_rx_desc));</a>
<a name="ln584">		an_rx_desc.an_valid = 1;</a>
<a name="ln585">		an_rx_desc.an_len = AN_RX_BUFFER_SIZE;</a>
<a name="ln586">		an_rx_desc.an_done = 0;</a>
<a name="ln587">		an_rx_desc.an_phys = sc-&gt;an_rx_buffer[desc].an_dma_paddr;</a>
<a name="ln588"> </a>
<a name="ln589">		for (i = 0; i &lt; sizeof(an_rx_desc) / 4; i++)</a>
<a name="ln590">			CSR_MEM_AUX_WRITE_4(sc, AN_RX_DESC_OFFSET</a>
<a name="ln591">			    + (desc * sizeof(an_rx_desc))</a>
<a name="ln592">			    + (i * 4),</a>
<a name="ln593">			    ((u_int32_t *)(void *)&amp;an_rx_desc)[i]);</a>
<a name="ln594">	}</a>
<a name="ln595"> </a>
<a name="ln596">	/*</a>
<a name="ln597">	 * Allocate TX descriptor</a>
<a name="ln598">	 */</a>
<a name="ln599"> </a>
<a name="ln600">	bzero(&amp;reply,sizeof(reply));</a>
<a name="ln601">	cmd_struct.an_cmd   = AN_CMD_ALLOC_DESC;</a>
<a name="ln602">	cmd_struct.an_parm0 = AN_DESCRIPTOR_TX;</a>
<a name="ln603">	cmd_struct.an_parm1 = AN_TX_DESC_OFFSET;</a>
<a name="ln604">	cmd_struct.an_parm2 = AN_MAX_TX_DESC;</a>
<a name="ln605">	if (an_cmd_struct(sc, &amp;cmd_struct, &amp;reply)) {</a>
<a name="ln606">		if_printf(sc-&gt;an_ifp, &quot;failed to allocate TX descriptor\n&quot;);</a>
<a name="ln607">		return(EIO);</a>
<a name="ln608">	}</a>
<a name="ln609"> </a>
<a name="ln610">	for (desc = 0; desc &lt; AN_MAX_TX_DESC; desc++) {</a>
<a name="ln611">		bzero(&amp;an_tx_desc, sizeof(an_tx_desc));</a>
<a name="ln612">		an_tx_desc.an_offset = 0;</a>
<a name="ln613">		an_tx_desc.an_eoc = 0;</a>
<a name="ln614">		an_tx_desc.an_valid = 0;</a>
<a name="ln615">		an_tx_desc.an_len = 0;</a>
<a name="ln616">		an_tx_desc.an_phys = sc-&gt;an_tx_buffer[desc].an_dma_paddr;</a>
<a name="ln617"> </a>
<a name="ln618">		for (i = 0; i &lt; sizeof(an_tx_desc) / 4; i++)</a>
<a name="ln619">			CSR_MEM_AUX_WRITE_4(sc, AN_TX_DESC_OFFSET</a>
<a name="ln620">			    + (desc * sizeof(an_tx_desc))</a>
<a name="ln621">			    + (i * 4),</a>
<a name="ln622">			    ((u_int32_t *)(void *)&amp;an_tx_desc)[i]);</a>
<a name="ln623">	}</a>
<a name="ln624"> </a>
<a name="ln625">	/*</a>
<a name="ln626">	 * Allocate RID descriptor</a>
<a name="ln627">	 */</a>
<a name="ln628"> </a>
<a name="ln629">	bzero(&amp;reply,sizeof(reply));</a>
<a name="ln630">	cmd_struct.an_cmd   = AN_CMD_ALLOC_DESC;</a>
<a name="ln631">	cmd_struct.an_parm0 = AN_DESCRIPTOR_HOSTRW;</a>
<a name="ln632">	cmd_struct.an_parm1 = AN_HOST_DESC_OFFSET;</a>
<a name="ln633">	cmd_struct.an_parm2 = 1;</a>
<a name="ln634">	if (an_cmd_struct(sc, &amp;cmd_struct, &amp;reply)) {</a>
<a name="ln635">		if_printf(sc-&gt;an_ifp, &quot;failed to allocate host descriptor\n&quot;);</a>
<a name="ln636">		return(EIO);</a>
<a name="ln637">	}</a>
<a name="ln638"> </a>
<a name="ln639">	bzero(&amp;an_rid_desc, sizeof(an_rid_desc));</a>
<a name="ln640">	an_rid_desc.an_valid = 1;</a>
<a name="ln641">	an_rid_desc.an_len = AN_RID_BUFFER_SIZE;</a>
<a name="ln642">	an_rid_desc.an_rid = 0;</a>
<a name="ln643">	an_rid_desc.an_phys = sc-&gt;an_rid_buffer.an_dma_paddr;</a>
<a name="ln644"> </a>
<a name="ln645">	for (i = 0; i &lt; sizeof(an_rid_desc) / 4; i++)</a>
<a name="ln646">		CSR_MEM_AUX_WRITE_4(sc, AN_HOST_DESC_OFFSET + i * 4,</a>
<a name="ln647">				    ((u_int32_t *)(void *)&amp;an_rid_desc)[i]);</a>
<a name="ln648"> </a>
<a name="ln649">	return(0);</a>
<a name="ln650">}</a>
<a name="ln651"> </a>
<a name="ln652">int</a>
<a name="ln653">an_attach(struct an_softc *sc, int flags)</a>
<a name="ln654">{</a>
<a name="ln655">	struct ifnet		*ifp;</a>
<a name="ln656">	int			error = EIO;</a>
<a name="ln657">	int			i, nrate, mword;</a>
<a name="ln658">	u_int8_t		r;</a>
<a name="ln659"> </a>
<a name="ln660">	ifp = sc-&gt;an_ifp = if_alloc(IFT_ETHER);</a>
<a name="ln661">	if (ifp == NULL) {</a>
<a name="ln662">		device_printf(sc-&gt;an_dev, &quot;can not if_alloc()\n&quot;);</a>
<a name="ln663">		goto fail;</a>
<a name="ln664">	}</a>
<a name="ln665">	ifp-&gt;if_softc = sc;</a>
<a name="ln666">	if_initname(ifp, device_get_name(sc-&gt;an_dev),</a>
<a name="ln667">	    device_get_unit(sc-&gt;an_dev));</a>
<a name="ln668"> </a>
<a name="ln669">	sc-&gt;an_gone = 0;</a>
<a name="ln670">	sc-&gt;an_associated = 0;</a>
<a name="ln671">	sc-&gt;an_monitor = 0;</a>
<a name="ln672">	sc-&gt;an_was_monitor = 0;</a>
<a name="ln673">	sc-&gt;an_flash_buffer = NULL;</a>
<a name="ln674"> </a>
<a name="ln675">	/* Reset the NIC. */</a>
<a name="ln676">	AN_LOCK(sc);</a>
<a name="ln677">	an_reset(sc);</a>
<a name="ln678">	if (sc-&gt;mpi350) {</a>
<a name="ln679">		error = an_init_mpi350_desc(sc);</a>
<a name="ln680">		if (error)</a>
<a name="ln681">			goto fail;</a>
<a name="ln682">	}</a>
<a name="ln683"> </a>
<a name="ln684">	/* Load factory config */</a>
<a name="ln685">	if (an_cmd(sc, AN_CMD_READCFG, 0)) {</a>
<a name="ln686">		device_printf(sc-&gt;an_dev, &quot;failed to load config data\n&quot;);</a>
<a name="ln687">		goto fail;</a>
<a name="ln688">	}</a>
<a name="ln689"> </a>
<a name="ln690">	/* Read the current configuration */</a>
<a name="ln691">	sc-&gt;an_config.an_type = AN_RID_GENCONFIG;</a>
<a name="ln692">	sc-&gt;an_config.an_len = sizeof(struct an_ltv_genconfig);</a>
<a name="ln693">	if (an_read_record(sc, (struct an_ltv_gen *)&amp;sc-&gt;an_config)) {</a>
<a name="ln694">		device_printf(sc-&gt;an_dev, &quot;read record failed\n&quot;);</a>
<a name="ln695">		goto fail;</a>
<a name="ln696">	}</a>
<a name="ln697"> </a>
<a name="ln698">	/* Read the card capabilities */</a>
<a name="ln699">	sc-&gt;an_caps.an_type = AN_RID_CAPABILITIES;</a>
<a name="ln700">	sc-&gt;an_caps.an_len = sizeof(struct an_ltv_caps);</a>
<a name="ln701">	if (an_read_record(sc, (struct an_ltv_gen *)&amp;sc-&gt;an_caps)) {</a>
<a name="ln702">		device_printf(sc-&gt;an_dev, &quot;read record failed\n&quot;);</a>
<a name="ln703">		goto fail;</a>
<a name="ln704">	}</a>
<a name="ln705"> </a>
<a name="ln706">	/* Read ssid list */</a>
<a name="ln707">	sc-&gt;an_ssidlist.an_type = AN_RID_SSIDLIST;</a>
<a name="ln708">	sc-&gt;an_ssidlist.an_len = sizeof(struct an_ltv_ssidlist_new);</a>
<a name="ln709">	if (an_read_record(sc, (struct an_ltv_gen *)&amp;sc-&gt;an_ssidlist)) {</a>
<a name="ln710">		device_printf(sc-&gt;an_dev, &quot;read record failed\n&quot;);</a>
<a name="ln711">		goto fail;</a>
<a name="ln712">	}</a>
<a name="ln713"> </a>
<a name="ln714">	/* Read AP list */</a>
<a name="ln715">	sc-&gt;an_aplist.an_type = AN_RID_APLIST;</a>
<a name="ln716">	sc-&gt;an_aplist.an_len = sizeof(struct an_ltv_aplist);</a>
<a name="ln717">	if (an_read_record(sc, (struct an_ltv_gen *)&amp;sc-&gt;an_aplist)) {</a>
<a name="ln718">		device_printf(sc-&gt;an_dev, &quot;read record failed\n&quot;);</a>
<a name="ln719">		goto fail;</a>
<a name="ln720">	}</a>
<a name="ln721"> </a>
<a name="ln722">#ifdef ANCACHE</a>
<a name="ln723">	/* Read the RSSI &lt;-&gt; dBm map */</a>
<a name="ln724">	sc-&gt;an_have_rssimap = 0;</a>
<a name="ln725">	if (sc-&gt;an_caps.an_softcaps &amp; 8) {</a>
<a name="ln726">		sc-&gt;an_rssimap.an_type = AN_RID_RSSI_MAP;</a>
<a name="ln727">		sc-&gt;an_rssimap.an_len = sizeof(struct an_ltv_rssi_map);</a>
<a name="ln728">		if (an_read_record(sc, (struct an_ltv_gen *)&amp;sc-&gt;an_rssimap)) {</a>
<a name="ln729">			device_printf(sc-&gt;an_dev,</a>
<a name="ln730">			    &quot;unable to get RSSI &lt;-&gt; dBM map\n&quot;);</a>
<a name="ln731">		} else {</a>
<a name="ln732">			device_printf(sc-&gt;an_dev, &quot;got RSSI &lt;-&gt; dBM map\n&quot;);</a>
<a name="ln733">			sc-&gt;an_have_rssimap = 1;</a>
<a name="ln734">		}</a>
<a name="ln735">	} else {</a>
<a name="ln736">		device_printf(sc-&gt;an_dev, &quot;no RSSI &lt;-&gt; dBM map\n&quot;);</a>
<a name="ln737">	}</a>
<a name="ln738">#endif</a>
<a name="ln739">	AN_UNLOCK(sc);</a>
<a name="ln740"> </a>
<a name="ln741">	ifp-&gt;if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;</a>
<a name="ln742">	ifp-&gt;if_ioctl = an_ioctl;</a>
<a name="ln743">	ifp-&gt;if_start = an_start;</a>
<a name="ln744">	ifp-&gt;if_init = an_init;</a>
<a name="ln745">	ifp-&gt;if_baudrate = 10000000;</a>
<a name="ln746">	IFQ_SET_MAXLEN(&amp;ifp-&gt;if_snd, ifqmaxlen);</a>
<a name="ln747">	ifp-&gt;if_snd.ifq_drv_maxlen = ifqmaxlen;</a>
<a name="ln748">	IFQ_SET_READY(&amp;ifp-&gt;if_snd);</a>
<a name="ln749"> </a>
<a name="ln750">	bzero(sc-&gt;an_config.an_nodename, sizeof(sc-&gt;an_config.an_nodename));</a>
<a name="ln751">	bcopy(AN_DEFAULT_NODENAME, sc-&gt;an_config.an_nodename,</a>
<a name="ln752">	    sizeof(AN_DEFAULT_NODENAME) - 1);</a>
<a name="ln753"> </a>
<a name="ln754">	bzero(sc-&gt;an_ssidlist.an_entry[0].an_ssid,</a>
<a name="ln755">	      sizeof(sc-&gt;an_ssidlist.an_entry[0].an_ssid));</a>
<a name="ln756">	bcopy(AN_DEFAULT_NETNAME, sc-&gt;an_ssidlist.an_entry[0].an_ssid,</a>
<a name="ln757">	    sizeof(AN_DEFAULT_NETNAME) - 1);</a>
<a name="ln758">	sc-&gt;an_ssidlist.an_entry[0].an_len = strlen(AN_DEFAULT_NETNAME);</a>
<a name="ln759"> </a>
<a name="ln760">	sc-&gt;an_config.an_opmode =</a>
<a name="ln761">	    AN_OPMODE_INFRASTRUCTURE_STATION;</a>
<a name="ln762"> </a>
<a name="ln763">	sc-&gt;an_tx_rate = 0;</a>
<a name="ln764">	bzero((char *)&amp;sc-&gt;an_stats, sizeof(sc-&gt;an_stats));</a>
<a name="ln765"> </a>
<a name="ln766">	nrate = 8;</a>
<a name="ln767"> </a>
<a name="ln768">	ifmedia_init(&amp;sc-&gt;an_ifmedia, 0, an_media_change, an_media_status);</a>
<a name="ln769">	if_printf(ifp, &quot;supported rates: &quot;);</a>
<a name="ln770">#define	ADD(s, o)	ifmedia_add(&amp;sc-&gt;an_ifmedia, \</a>
<a name="ln771">	IFM_MAKEWORD(IFM_IEEE80211, (s), (o), 0), 0, NULL)</a>
<a name="ln772">	ADD(IFM_AUTO, 0);</a>
<a name="ln773">	ADD(IFM_AUTO, IFM_IEEE80211_ADHOC);</a>
<a name="ln774">	for (i = 0; i &lt; nrate; i++) {</a>
<a name="ln775">		r = sc-&gt;an_caps.an_rates[i];</a>
<a name="ln776">		mword = ieee80211_rate2media(NULL, r, IEEE80211_MODE_AUTO);</a>
<a name="ln777">		if (mword == 0)</a>
<a name="ln778">			continue;</a>
<a name="ln779">		printf(&quot;%s%d%sMbps&quot;, (i != 0 ? &quot; &quot; : &quot;&quot;),</a>
<a name="ln780">		    (r &amp; IEEE80211_RATE_VAL) / 2, ((r &amp; 0x1) != 0 ? &quot;.5&quot; : &quot;&quot;));</a>
<a name="ln781">		ADD(mword, 0);</a>
<a name="ln782">		ADD(mword, IFM_IEEE80211_ADHOC);</a>
<a name="ln783">	}</a>
<a name="ln784">	printf(&quot;\n&quot;);</a>
<a name="ln785">	ifmedia_set(&amp;sc-&gt;an_ifmedia, IFM_MAKEWORD(IFM_IEEE80211,</a>
<a name="ln786">	    IFM_AUTO, 0, 0));</a>
<a name="ln787">#undef ADD</a>
<a name="ln788"> </a>
<a name="ln789">	/*</a>
<a name="ln790">	 * Call MI attach routine.</a>
<a name="ln791">	 */</a>
<a name="ln792"> </a>
<a name="ln793">	ether_ifattach(ifp, sc-&gt;an_caps.an_oemaddr);</a>
<a name="ln794">	callout_init_mtx(&amp;sc-&gt;an_stat_ch, &amp;sc-&gt;an_mtx, 0);</a>
<a name="ln795"> </a>
<a name="ln796">	return(0);</a>
<a name="ln797">fail:</a>
<a name="ln798">	AN_UNLOCK(sc);</a>
<a name="ln799">	mtx_destroy(&amp;sc-&gt;an_mtx);</a>
<a name="ln800">	if (ifp != NULL)</a>
<a name="ln801">		if_free(ifp);</a>
<a name="ln802">	return(error);</a>
<a name="ln803">}</a>
<a name="ln804"> </a>
<a name="ln805">int</a>
<a name="ln806">an_detach(device_t dev)</a>
<a name="ln807">{</a>
<a name="ln808">	struct an_softc		*sc = device_get_softc(dev);</a>
<a name="ln809">	struct ifnet		*ifp = sc-&gt;an_ifp;</a>
<a name="ln810"> </a>
<a name="ln811">	if (sc-&gt;an_gone) {</a>
<a name="ln812">		device_printf(dev,&quot;already unloaded\n&quot;);</a>
<a name="ln813">		return(0);</a>
<a name="ln814">	}</a>
<a name="ln815">	AN_LOCK(sc);</a>
<a name="ln816">	an_stop(sc);</a>
<a name="ln817">	sc-&gt;an_gone = 1;</a>
<a name="ln818">	ifmedia_removeall(&amp;sc-&gt;an_ifmedia);</a>
<a name="ln819">	ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_RUNNING;</a>
<a name="ln820">	AN_UNLOCK(sc);</a>
<a name="ln821">	ether_ifdetach(ifp);</a>
<a name="ln822">	bus_teardown_intr(dev, sc-&gt;irq_res, sc-&gt;irq_handle);</a>
<a name="ln823">	callout_drain(&amp;sc-&gt;an_stat_ch);</a>
<a name="ln824">	if_free(ifp);</a>
<a name="ln825">	an_release_resources(dev);</a>
<a name="ln826">	mtx_destroy(&amp;sc-&gt;an_mtx);</a>
<a name="ln827">	return (0);</a>
<a name="ln828">}</a>
<a name="ln829"> </a>
<a name="ln830">static void</a>
<a name="ln831">an_rxeof(struct an_softc *sc)</a>
<a name="ln832">{</a>
<a name="ln833">	struct ifnet   *ifp;</a>
<a name="ln834">	struct ether_header *eh;</a>
<a name="ln835">	struct ieee80211_frame *ih;</a>
<a name="ln836">	struct an_rxframe rx_frame;</a>
<a name="ln837">	struct an_rxframe_802_3 rx_frame_802_3;</a>
<a name="ln838">	struct mbuf    *m;</a>
<a name="ln839">	int		len, id, error = 0, i, count = 0;</a>
<a name="ln840">	int		ieee80211_header_len;</a>
<a name="ln841">	u_char		*bpf_buf;</a>
<a name="ln842">	u_short		fc1;</a>
<a name="ln843">	struct an_card_rx_desc an_rx_desc;</a>
<a name="ln844">	u_int8_t	*buf;</a>
<a name="ln845"> </a>
<a name="ln846">	AN_LOCK_ASSERT(sc);</a>
<a name="ln847"> </a>
<a name="ln848">	ifp = sc-&gt;an_ifp;</a>
<a name="ln849"> </a>
<a name="ln850">	if (!sc-&gt;mpi350) {</a>
<a name="ln851">		id = CSR_READ_2(sc, AN_RX_FID);</a>
<a name="ln852"> </a>
<a name="ln853">		if (sc-&gt;an_monitor &amp;&amp; (ifp-&gt;if_flags &amp; IFF_PROMISC)) {</a>
<a name="ln854">			/* read raw 802.11 packet */</a>
<a name="ln855">			bpf_buf = sc-&gt;buf_802_11;</a>
<a name="ln856"> </a>
<a name="ln857">			/* read header */</a>
<a name="ln858">			if (an_read_data(sc, id, 0x0, (caddr_t)&amp;rx_frame,</a>
<a name="ln859">					 sizeof(rx_frame))) {</a>
<a name="ln860">				if_inc_counter(ifp, IFCOUNTER_IERRORS, 1);</a>
<a name="ln861">				return;</a>
<a name="ln862">			}</a>
<a name="ln863"> </a>
<a name="ln864">			/*</a>
<a name="ln865">			 * skip beacon by default since this increases the</a>
<a name="ln866">			 * system load a lot</a>
<a name="ln867">			 */</a>
<a name="ln868"> </a>
<a name="ln869">			if (!(sc-&gt;an_monitor &amp; AN_MONITOR_INCLUDE_BEACON) &amp;&amp;</a>
<a name="ln870">			    (rx_frame.an_frame_ctl &amp; </a>
<a name="ln871">			     IEEE80211_FC0_SUBTYPE_BEACON)) {</a>
<a name="ln872">				return;</a>
<a name="ln873">			}</a>
<a name="ln874"> </a>
<a name="ln875">			if (sc-&gt;an_monitor &amp; AN_MONITOR_AIRONET_HEADER) {</a>
<a name="ln876">				len = rx_frame.an_rx_payload_len</a>
<a name="ln877">					+ sizeof(rx_frame);</a>
<a name="ln878">				/* Check for insane frame length */</a>
<a name="ln879">				if (len &gt; sizeof(sc-&gt;buf_802_11)) {</a>
<a name="ln880">					if_printf(ifp, &quot;oversized packet &quot;</a>
<a name="ln881">					       &quot;received (%d, %d)\n&quot;,</a>
<a name="ln882">					       len, MCLBYTES);</a>
<a name="ln883">					if_inc_counter(ifp, IFCOUNTER_IERRORS, 1);</a>
<a name="ln884">					return;</a>
<a name="ln885">				}</a>
<a name="ln886"> </a>
<a name="ln887">				bcopy((char *)&amp;rx_frame,</a>
<a name="ln888">				      bpf_buf, sizeof(rx_frame));</a>
<a name="ln889"> </a>
<a name="ln890">				error = an_read_data(sc, id, sizeof(rx_frame),</a>
<a name="ln891">					    (caddr_t)bpf_buf+sizeof(rx_frame),</a>
<a name="ln892">					    rx_frame.an_rx_payload_len);</a>
<a name="ln893">			} else {</a>
<a name="ln894">				fc1=rx_frame.an_frame_ctl &gt;&gt; 8;</a>
<a name="ln895">				ieee80211_header_len =</a>
<a name="ln896">					sizeof(struct ieee80211_frame);</a>
<a name="ln897">				if ((fc1 &amp; IEEE80211_FC1_DIR_TODS) &amp;&amp;</a>
<a name="ln898">				    (fc1 &amp; IEEE80211_FC1_DIR_FROMDS)) {</a>
<a name="ln899">					ieee80211_header_len += ETHER_ADDR_LEN;</a>
<a name="ln900">				}</a>
<a name="ln901"> </a>
<a name="ln902">				len = rx_frame.an_rx_payload_len</a>
<a name="ln903">					+ ieee80211_header_len;</a>
<a name="ln904">				/* Check for insane frame length */</a>
<a name="ln905">				if (len &gt; sizeof(sc-&gt;buf_802_11)) {</a>
<a name="ln906">					if_printf(ifp, &quot;oversized packet &quot;</a>
<a name="ln907">					       &quot;received (%d, %d)\n&quot;,</a>
<a name="ln908">					       len, MCLBYTES);</a>
<a name="ln909">					if_inc_counter(ifp, IFCOUNTER_IERRORS, 1);</a>
<a name="ln910">					return;</a>
<a name="ln911">				}</a>
<a name="ln912"> </a>
<a name="ln913">				ih = (struct ieee80211_frame *)bpf_buf;</a>
<a name="ln914"> </a>
<a name="ln915">				bcopy((char *)&amp;rx_frame.an_frame_ctl,</a>
<a name="ln916">				      (char *)ih, ieee80211_header_len);</a>
<a name="ln917"> </a>
<a name="ln918">				error = an_read_data(sc, id, sizeof(rx_frame) +</a>
<a name="ln919">					    rx_frame.an_gaplen,</a>
<a name="ln920">					    (caddr_t)ih +ieee80211_header_len,</a>
<a name="ln921">					    rx_frame.an_rx_payload_len);</a>
<a name="ln922">			}</a>
<a name="ln923">			/* dump raw 802.11 packet to bpf and skip ip stack */</a>
<a name="ln924">			BPF_TAP(ifp, bpf_buf, len);</a>
<a name="ln925">		} else {</a>
<a name="ln926">			MGETHDR(m, M_NOWAIT, MT_DATA);</a>
<a name="ln927">			if (m == NULL) {</a>
<a name="ln928">				if_inc_counter(ifp, IFCOUNTER_IERRORS, 1);</a>
<a name="ln929">				return;</a>
<a name="ln930">			}</a>
<a name="ln931">			if (!(MCLGET(m, M_NOWAIT))) {</a>
<a name="ln932">				m_freem(m);</a>
<a name="ln933">				if_inc_counter(ifp, IFCOUNTER_IERRORS, 1);</a>
<a name="ln934">				return;</a>
<a name="ln935">			}</a>
<a name="ln936">			m-&gt;m_pkthdr.rcvif = ifp;</a>
<a name="ln937">			/* Read Ethernet encapsulated packet */</a>
<a name="ln938"> </a>
<a name="ln939">#ifdef ANCACHE</a>
<a name="ln940">			/* Read NIC frame header */</a>
<a name="ln941">			if (an_read_data(sc, id, 0, (caddr_t)&amp;rx_frame,</a>
<a name="ln942">					 sizeof(rx_frame))) {</a>
<a name="ln943">				m_freem(m);</a>
<a name="ln944">				if_inc_counter(ifp, IFCOUNTER_IERRORS, 1);</a>
<a name="ln945">				return;</a>
<a name="ln946">			}</a>
<a name="ln947">#endif</a>
<a name="ln948">			/* Read in the 802_3 frame header */</a>
<a name="ln949">			if (an_read_data(sc, id, 0x34,</a>
<a name="ln950">					 (caddr_t)&amp;rx_frame_802_3,</a>
<a name="ln951">					 sizeof(rx_frame_802_3))) {</a>
<a name="ln952">				m_freem(m);</a>
<a name="ln953">				if_inc_counter(ifp, IFCOUNTER_IERRORS, 1);</a>
<a name="ln954">				return;</a>
<a name="ln955">			}</a>
<a name="ln956">			if (rx_frame_802_3.an_rx_802_3_status != 0) {</a>
<a name="ln957">				m_freem(m);</a>
<a name="ln958">				if_inc_counter(ifp, IFCOUNTER_IERRORS, 1);</a>
<a name="ln959">				return;</a>
<a name="ln960">			}</a>
<a name="ln961">			/* Check for insane frame length */</a>
<a name="ln962">			len = rx_frame_802_3.an_rx_802_3_payload_len;</a>
<a name="ln963">			if (len &gt; sizeof(sc-&gt;buf_802_11)) {</a>
<a name="ln964">				m_freem(m);</a>
<a name="ln965">				if_printf(ifp, &quot;oversized packet &quot;</a>
<a name="ln966">				       &quot;received (%d, %d)\n&quot;,</a>
<a name="ln967">				       len, MCLBYTES);</a>
<a name="ln968">				if_inc_counter(ifp, IFCOUNTER_IERRORS, 1);</a>
<a name="ln969">				return;</a>
<a name="ln970">			}</a>
<a name="ln971">			m-&gt;m_pkthdr.len = m-&gt;m_len =</a>
<a name="ln972">				rx_frame_802_3.an_rx_802_3_payload_len + 12;</a>
<a name="ln973"> </a>
<a name="ln974">			eh = mtod(m, struct ether_header *);</a>
<a name="ln975"> </a>
<a name="ln976">			bcopy((char *)&amp;rx_frame_802_3.an_rx_dst_addr,</a>
<a name="ln977">			      (char *)&amp;eh-&gt;ether_dhost, ETHER_ADDR_LEN);</a>
<a name="ln978">			bcopy((char *)&amp;rx_frame_802_3.an_rx_src_addr,</a>
<a name="ln979">			      (char *)&amp;eh-&gt;ether_shost, ETHER_ADDR_LEN);</a>
<a name="ln980"> </a>
<a name="ln981">			/* in mbuf header type is just before payload */</a>
<a name="ln982">			error = an_read_data(sc, id, 0x44,</a>
<a name="ln983">				    (caddr_t)&amp;(eh-&gt;ether_type),</a>
<a name="ln984">				    rx_frame_802_3.an_rx_802_3_payload_len);</a>
<a name="ln985"> </a>
<a name="ln986">			if (error) {</a>
<a name="ln987">				m_freem(m);</a>
<a name="ln988">				if_inc_counter(ifp, IFCOUNTER_IERRORS, 1);</a>
<a name="ln989">				return;</a>
<a name="ln990">			}</a>
<a name="ln991">			if_inc_counter(ifp, IFCOUNTER_IPACKETS, 1);</a>
<a name="ln992"> </a>
<a name="ln993">			/* Receive packet. */</a>
<a name="ln994">#ifdef ANCACHE</a>
<a name="ln995">			an_cache_store(sc, eh, m,</a>
<a name="ln996">				rx_frame.an_rx_signal_strength,</a>
<a name="ln997">				rx_frame.an_rsvd0);</a>
<a name="ln998">#endif</a>
<a name="ln999">			AN_UNLOCK(sc);</a>
<a name="ln1000">			(*ifp-&gt;if_input)(ifp, m);</a>
<a name="ln1001">			AN_LOCK(sc);</a>
<a name="ln1002">		}</a>
<a name="ln1003"> </a>
<a name="ln1004">	} else { /* MPI-350 */</a>
<a name="ln1005">		for (count = 0; count &lt; AN_MAX_RX_DESC; count++){</a>
<a name="ln1006">			for (i = 0; i &lt; sizeof(an_rx_desc) / 4; i++)</a>
<a name="ln1007">				((u_int32_t *)(void *)&amp;an_rx_desc)[i]</a>
<a name="ln1008">					= CSR_MEM_AUX_READ_4(sc,</a>
<a name="ln1009">						AN_RX_DESC_OFFSET</a>
<a name="ln1010">						+ (count * sizeof(an_rx_desc))</a>
<a name="ln1011">						+ (i * 4));</a>
<a name="ln1012"> </a>
<a name="ln1013">			if (an_rx_desc.an_done &amp;&amp; !an_rx_desc.an_valid) {</a>
<a name="ln1014">				buf = sc-&gt;an_rx_buffer[count].an_dma_vaddr;</a>
<a name="ln1015"> </a>
<a name="ln1016">				MGETHDR(m, M_NOWAIT, MT_DATA);</a>
<a name="ln1017">				if (m == NULL) {</a>
<a name="ln1018">					if_inc_counter(ifp, IFCOUNTER_IERRORS, 1);</a>
<a name="ln1019">					return;</a>
<a name="ln1020">				}</a>
<a name="ln1021">				if (!(MCLGET(m, M_NOWAIT))) {</a>
<a name="ln1022">					m_freem(m);</a>
<a name="ln1023">					if_inc_counter(ifp, IFCOUNTER_IERRORS, 1);</a>
<a name="ln1024">					return;</a>
<a name="ln1025">				}</a>
<a name="ln1026">				m-&gt;m_pkthdr.rcvif = ifp;</a>
<a name="ln1027">				/* Read Ethernet encapsulated packet */</a>
<a name="ln1028"> </a>
<a name="ln1029">				/*</a>
<a name="ln1030">				 * No ANCACHE support since we just get back</a>
<a name="ln1031">				 * an Ethernet packet no 802.11 info</a>
<a name="ln1032">				 */</a>
<a name="ln1033">#if 0</a>
<a name="ln1034">#ifdef ANCACHE</a>
<a name="ln1035">				/* Read NIC frame header */</a>
<a name="ln1036">				bcopy(buf, (caddr_t)&amp;rx_frame,</a>
<a name="ln1037">				      sizeof(rx_frame));</a>
<a name="ln1038">#endif</a>
<a name="ln1039">#endif</a>
<a name="ln1040">				/* Check for insane frame length */</a>
<a name="ln1041">				len = an_rx_desc.an_len + 12;</a>
<a name="ln1042">				if (len &gt; MCLBYTES) {</a>
<a name="ln1043">					m_freem(m);</a>
<a name="ln1044">					if_printf(ifp, &quot;oversized packet &quot;</a>
<a name="ln1045">					       &quot;received (%d, %d)\n&quot;,</a>
<a name="ln1046">					       len, MCLBYTES);</a>
<a name="ln1047">					if_inc_counter(ifp, IFCOUNTER_IERRORS, 1);</a>
<a name="ln1048">					return;</a>
<a name="ln1049">				}</a>
<a name="ln1050"> </a>
<a name="ln1051">				m-&gt;m_pkthdr.len = m-&gt;m_len =</a>
<a name="ln1052">					an_rx_desc.an_len + 12;</a>
<a name="ln1053"> </a>
<a name="ln1054">				eh = mtod(m, struct ether_header *);</a>
<a name="ln1055"> </a>
<a name="ln1056">				bcopy(buf, (char *)eh,</a>
<a name="ln1057">				      m-&gt;m_pkthdr.len);</a>
<a name="ln1058"> </a>
<a name="ln1059">				if_inc_counter(ifp, IFCOUNTER_IPACKETS, 1);</a>
<a name="ln1060"> </a>
<a name="ln1061">				/* Receive packet. */</a>
<a name="ln1062">#if 0</a>
<a name="ln1063">#ifdef ANCACHE</a>
<a name="ln1064">				an_cache_store(sc, eh, m,</a>
<a name="ln1065">					rx_frame.an_rx_signal_strength,</a>
<a name="ln1066">					rx_frame.an_rsvd0);</a>
<a name="ln1067">#endif</a>
<a name="ln1068">#endif</a>
<a name="ln1069">				AN_UNLOCK(sc);</a>
<a name="ln1070">				(*ifp-&gt;if_input)(ifp, m);</a>
<a name="ln1071">				AN_LOCK(sc);</a>
<a name="ln1072"> </a>
<a name="ln1073">				an_rx_desc.an_valid = 1;</a>
<a name="ln1074">				an_rx_desc.an_len = AN_RX_BUFFER_SIZE;</a>
<a name="ln1075">				an_rx_desc.an_done = 0;</a>
<a name="ln1076">				an_rx_desc.an_phys =</a>
<a name="ln1077">					sc-&gt;an_rx_buffer[count].an_dma_paddr;</a>
<a name="ln1078"> </a>
<a name="ln1079">				for (i = 0; i &lt; sizeof(an_rx_desc) / 4; i++)</a>
<a name="ln1080">					CSR_MEM_AUX_WRITE_4(sc,</a>
<a name="ln1081">					    AN_RX_DESC_OFFSET</a>
<a name="ln1082">					    + (count * sizeof(an_rx_desc))</a>
<a name="ln1083">					    + (i * 4),</a>
<a name="ln1084">					    ((u_int32_t *)(void *)&amp;an_rx_desc)[i]);</a>
<a name="ln1085"> </a>
<a name="ln1086">			} else {</a>
<a name="ln1087">				if_printf(ifp, &quot;Didn't get valid RX packet &quot;</a>
<a name="ln1088">				       &quot;%x %x %d\n&quot;,</a>
<a name="ln1089">				       an_rx_desc.an_done,</a>
<a name="ln1090">				       an_rx_desc.an_valid, an_rx_desc.an_len);</a>
<a name="ln1091">			}</a>
<a name="ln1092">		}</a>
<a name="ln1093">	}</a>
<a name="ln1094">}</a>
<a name="ln1095"> </a>
<a name="ln1096">static void</a>
<a name="ln1097">an_txeof(struct an_softc *sc, int status)</a>
<a name="ln1098">{</a>
<a name="ln1099">	struct ifnet		*ifp;</a>
<a name="ln1100">	int			id, i;</a>
<a name="ln1101"> </a>
<a name="ln1102">	AN_LOCK_ASSERT(sc);</a>
<a name="ln1103">	ifp = sc-&gt;an_ifp;</a>
<a name="ln1104"> </a>
<a name="ln1105">	sc-&gt;an_timer = 0;</a>
<a name="ln1106">	ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_OACTIVE;</a>
<a name="ln1107"> </a>
<a name="ln1108">	if (!sc-&gt;mpi350) {</a>
<a name="ln1109">		id = CSR_READ_2(sc, AN_TX_CMP_FID(sc-&gt;mpi350));</a>
<a name="ln1110"> </a>
<a name="ln1111">		if (status &amp; AN_EV_TX_EXC) {</a>
<a name="ln1112">			if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln1113">		} else</a>
<a name="ln1114">			if_inc_counter(ifp, IFCOUNTER_OPACKETS, 1);</a>
<a name="ln1115"> </a>
<a name="ln1116">		for (i = 0; i &lt; AN_TX_RING_CNT; i++) {</a>
<a name="ln1117">			if (id == sc-&gt;an_rdata.an_tx_ring[i]) {</a>
<a name="ln1118">				sc-&gt;an_rdata.an_tx_ring[i] = 0;</a>
<a name="ln1119">				break;</a>
<a name="ln1120">			}</a>
<a name="ln1121">		}</a>
<a name="ln1122"> </a>
<a name="ln1123">		AN_INC(sc-&gt;an_rdata.an_tx_cons, AN_TX_RING_CNT);</a>
<a name="ln1124">	} else { /* MPI 350 */</a>
<a name="ln1125">		id = CSR_READ_2(sc, AN_TX_CMP_FID(sc-&gt;mpi350));</a>
<a name="ln1126">		if (!sc-&gt;an_rdata.an_tx_empty){</a>
<a name="ln1127">			if (status &amp; AN_EV_TX_EXC) {</a>
<a name="ln1128">				if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln1129">			} else</a>
<a name="ln1130">				if_inc_counter(ifp, IFCOUNTER_OPACKETS, 1);</a>
<a name="ln1131">			AN_INC(sc-&gt;an_rdata.an_tx_cons, AN_MAX_TX_DESC);</a>
<a name="ln1132">			if (sc-&gt;an_rdata.an_tx_prod ==</a>
<a name="ln1133">			    sc-&gt;an_rdata.an_tx_cons)</a>
<a name="ln1134">				sc-&gt;an_rdata.an_tx_empty = 1;</a>
<a name="ln1135">		}</a>
<a name="ln1136">	}</a>
<a name="ln1137"> </a>
<a name="ln1138">	return;</a>
<a name="ln1139">}</a>
<a name="ln1140"> </a>
<a name="ln1141">/*</a>
<a name="ln1142"> * We abuse the stats updater to check the current NIC status. This</a>
<a name="ln1143"> * is important because we don't want to allow transmissions until</a>
<a name="ln1144"> * the NIC has synchronized to the current cell (either as the master</a>
<a name="ln1145"> * in an ad-hoc group, or as a station connected to an access point).</a>
<a name="ln1146"> *</a>
<a name="ln1147"> * Note that this function will be called via callout(9) with a lock held.</a>
<a name="ln1148"> */</a>
<a name="ln1149">static void</a>
<a name="ln1150">an_stats_update(void *xsc)</a>
<a name="ln1151">{</a>
<a name="ln1152">	struct an_softc		*sc;</a>
<a name="ln1153">	struct ifnet		*ifp;</a>
<a name="ln1154"> </a>
<a name="ln1155">	sc = xsc;</a>
<a name="ln1156">	AN_LOCK_ASSERT(sc);</a>
<a name="ln1157">	ifp = sc-&gt;an_ifp;</a>
<a name="ln1158">	if (sc-&gt;an_timer &gt; 0 &amp;&amp; --sc-&gt;an_timer == 0)</a>
<a name="ln1159">		an_watchdog(sc);</a>
<a name="ln1160"> </a>
<a name="ln1161">	sc-&gt;an_status.an_type = AN_RID_STATUS;</a>
<a name="ln1162">	sc-&gt;an_status.an_len = sizeof(struct an_ltv_status);</a>
<a name="ln1163">	if (an_read_record(sc, (struct an_ltv_gen *)&amp;sc-&gt;an_status))</a>
<a name="ln1164">		return;</a>
<a name="ln1165"> </a>
<a name="ln1166">	if (sc-&gt;an_status.an_opmode &amp; AN_STATUS_OPMODE_IN_SYNC)</a>
<a name="ln1167">		sc-&gt;an_associated = 1;</a>
<a name="ln1168">	else</a>
<a name="ln1169">		sc-&gt;an_associated = 0;</a>
<a name="ln1170"> </a>
<a name="ln1171">	/* Don't do this while we're transmitting */</a>
<a name="ln1172">	if (ifp-&gt;if_drv_flags &amp; IFF_DRV_OACTIVE) {</a>
<a name="ln1173">		callout_reset(&amp;sc-&gt;an_stat_ch, hz, an_stats_update, sc);</a>
<a name="ln1174">		return;</a>
<a name="ln1175">	}</a>
<a name="ln1176"> </a>
<a name="ln1177">	sc-&gt;an_stats.an_len = sizeof(struct an_ltv_stats);</a>
<a name="ln1178">	sc-&gt;an_stats.an_type = AN_RID_32BITS_CUM;</a>
<a name="ln1179">	if (an_read_record(sc, (struct an_ltv_gen *)&amp;sc-&gt;an_stats.an_len))</a>
<a name="ln1180">		return;</a>
<a name="ln1181"> </a>
<a name="ln1182">	callout_reset(&amp;sc-&gt;an_stat_ch, hz, an_stats_update, sc);</a>
<a name="ln1183"> </a>
<a name="ln1184">	return;</a>
<a name="ln1185">}</a>
<a name="ln1186"> </a>
<a name="ln1187">void</a>
<a name="ln1188">an_intr(void *xsc)</a>
<a name="ln1189">{</a>
<a name="ln1190">	struct an_softc		*sc;</a>
<a name="ln1191">	struct ifnet		*ifp;</a>
<a name="ln1192">	u_int16_t		status;</a>
<a name="ln1193"> </a>
<a name="ln1194">	sc = (struct an_softc*)xsc;</a>
<a name="ln1195"> </a>
<a name="ln1196">	AN_LOCK(sc);</a>
<a name="ln1197"> </a>
<a name="ln1198">	if (sc-&gt;an_gone) {</a>
<a name="ln1199">		AN_UNLOCK(sc);</a>
<a name="ln1200">		return;</a>
<a name="ln1201">	}</a>
<a name="ln1202"> </a>
<a name="ln1203">	ifp = sc-&gt;an_ifp;</a>
<a name="ln1204"> </a>
<a name="ln1205">	/* Disable interrupts. */</a>
<a name="ln1206">	CSR_WRITE_2(sc, AN_INT_EN(sc-&gt;mpi350), 0);</a>
<a name="ln1207"> </a>
<a name="ln1208">	status = CSR_READ_2(sc, AN_EVENT_STAT(sc-&gt;mpi350));</a>
<a name="ln1209">	CSR_WRITE_2(sc, AN_EVENT_ACK(sc-&gt;mpi350), ~AN_INTRS(sc-&gt;mpi350));</a>
<a name="ln1210"> </a>
<a name="ln1211">	if (status &amp; AN_EV_MIC) {</a>
<a name="ln1212">		CSR_WRITE_2(sc, AN_EVENT_ACK(sc-&gt;mpi350), AN_EV_MIC);</a>
<a name="ln1213">	}</a>
<a name="ln1214"> </a>
<a name="ln1215">	if (status &amp; AN_EV_LINKSTAT) {</a>
<a name="ln1216">		if (CSR_READ_2(sc, AN_LINKSTAT(sc-&gt;mpi350))</a>
<a name="ln1217">		    == AN_LINKSTAT_ASSOCIATED)</a>
<a name="ln1218">			sc-&gt;an_associated = 1;</a>
<a name="ln1219">		else</a>
<a name="ln1220">			sc-&gt;an_associated = 0;</a>
<a name="ln1221">		CSR_WRITE_2(sc, AN_EVENT_ACK(sc-&gt;mpi350), AN_EV_LINKSTAT);</a>
<a name="ln1222">	}</a>
<a name="ln1223"> </a>
<a name="ln1224">	if (status &amp; AN_EV_RX) {</a>
<a name="ln1225">		an_rxeof(sc);</a>
<a name="ln1226">		CSR_WRITE_2(sc, AN_EVENT_ACK(sc-&gt;mpi350), AN_EV_RX);</a>
<a name="ln1227">	}</a>
<a name="ln1228"> </a>
<a name="ln1229">	if (sc-&gt;mpi350 &amp;&amp; status &amp; AN_EV_TX_CPY) {</a>
<a name="ln1230">		an_txeof(sc, status);</a>
<a name="ln1231">		CSR_WRITE_2(sc, AN_EVENT_ACK(sc-&gt;mpi350), AN_EV_TX_CPY);</a>
<a name="ln1232">	}</a>
<a name="ln1233"> </a>
<a name="ln1234">	if (status &amp; AN_EV_TX) {</a>
<a name="ln1235">		an_txeof(sc, status);</a>
<a name="ln1236">		CSR_WRITE_2(sc, AN_EVENT_ACK(sc-&gt;mpi350), AN_EV_TX);</a>
<a name="ln1237">	}</a>
<a name="ln1238"> </a>
<a name="ln1239">	if (status &amp; AN_EV_TX_EXC) {</a>
<a name="ln1240">		an_txeof(sc, status);</a>
<a name="ln1241">		CSR_WRITE_2(sc, AN_EVENT_ACK(sc-&gt;mpi350), AN_EV_TX_EXC);</a>
<a name="ln1242">	}</a>
<a name="ln1243"> </a>
<a name="ln1244">	if (status &amp; AN_EV_ALLOC)</a>
<a name="ln1245">		CSR_WRITE_2(sc, AN_EVENT_ACK(sc-&gt;mpi350), AN_EV_ALLOC);</a>
<a name="ln1246"> </a>
<a name="ln1247">	/* Re-enable interrupts. */</a>
<a name="ln1248">	CSR_WRITE_2(sc, AN_INT_EN(sc-&gt;mpi350), AN_INTRS(sc-&gt;mpi350));</a>
<a name="ln1249"> </a>
<a name="ln1250">	if ((ifp-&gt;if_flags &amp; IFF_UP) &amp;&amp; !IFQ_DRV_IS_EMPTY(&amp;ifp-&gt;if_snd))</a>
<a name="ln1251">		an_start_locked(ifp);</a>
<a name="ln1252"> </a>
<a name="ln1253">	AN_UNLOCK(sc);</a>
<a name="ln1254"> </a>
<a name="ln1255">	return;</a>
<a name="ln1256">}</a>
<a name="ln1257"> </a>
<a name="ln1258"> </a>
<a name="ln1259">static int</a>
<a name="ln1260">an_cmd_struct(struct an_softc *sc, struct an_command *cmd,</a>
<a name="ln1261">    struct an_reply *reply)</a>
<a name="ln1262">{</a>
<a name="ln1263">	int			i;</a>
<a name="ln1264"> </a>
<a name="ln1265">	AN_LOCK_ASSERT(sc);</a>
<a name="ln1266">	for (i = 0; i != AN_TIMEOUT; i++) {</a>
<a name="ln1267">		if (CSR_READ_2(sc, AN_COMMAND(sc-&gt;mpi350)) &amp; AN_CMD_BUSY) {</a>
<a name="ln1268">			DELAY(1000);</a>
<a name="ln1269">		} else</a>
<a name="ln1270">			break;</a>
<a name="ln1271">	}</a>
<a name="ln1272"> </a>
<a name="ln1273">	if( i == AN_TIMEOUT) {</a>
<a name="ln1274">		printf(&quot;BUSY\n&quot;);</a>
<a name="ln1275">		return(ETIMEDOUT);</a>
<a name="ln1276">	}</a>
<a name="ln1277"> </a>
<a name="ln1278">	CSR_WRITE_2(sc, AN_PARAM0(sc-&gt;mpi350), cmd-&gt;an_parm0);</a>
<a name="ln1279">	CSR_WRITE_2(sc, AN_PARAM1(sc-&gt;mpi350), cmd-&gt;an_parm1);</a>
<a name="ln1280">	CSR_WRITE_2(sc, AN_PARAM2(sc-&gt;mpi350), cmd-&gt;an_parm2);</a>
<a name="ln1281">	CSR_WRITE_2(sc, AN_COMMAND(sc-&gt;mpi350), cmd-&gt;an_cmd);</a>
<a name="ln1282"> </a>
<a name="ln1283">	for (i = 0; i &lt; AN_TIMEOUT; i++) {</a>
<a name="ln1284">		if (CSR_READ_2(sc, AN_EVENT_STAT(sc-&gt;mpi350)) &amp; AN_EV_CMD)</a>
<a name="ln1285">			break;</a>
<a name="ln1286">		DELAY(1000);</a>
<a name="ln1287">	}</a>
<a name="ln1288"> </a>
<a name="ln1289">	reply-&gt;an_resp0 = CSR_READ_2(sc, AN_RESP0(sc-&gt;mpi350));</a>
<a name="ln1290">	reply-&gt;an_resp1 = CSR_READ_2(sc, AN_RESP1(sc-&gt;mpi350));</a>
<a name="ln1291">	reply-&gt;an_resp2 = CSR_READ_2(sc, AN_RESP2(sc-&gt;mpi350));</a>
<a name="ln1292">	reply-&gt;an_status = CSR_READ_2(sc, AN_STATUS(sc-&gt;mpi350));</a>
<a name="ln1293"> </a>
<a name="ln1294">	if (CSR_READ_2(sc, AN_COMMAND(sc-&gt;mpi350)) &amp; AN_CMD_BUSY)</a>
<a name="ln1295">		CSR_WRITE_2(sc, AN_EVENT_ACK(sc-&gt;mpi350),</a>
<a name="ln1296">		    AN_EV_CLR_STUCK_BUSY);</a>
<a name="ln1297"> </a>
<a name="ln1298">	/* Ack the command */</a>
<a name="ln1299">	CSR_WRITE_2(sc, AN_EVENT_ACK(sc-&gt;mpi350), AN_EV_CMD);</a>
<a name="ln1300"> </a>
<a name="ln1301">	if (i == AN_TIMEOUT)</a>
<a name="ln1302">		return(ETIMEDOUT);</a>
<a name="ln1303"> </a>
<a name="ln1304">	return(0);</a>
<a name="ln1305">}</a>
<a name="ln1306"> </a>
<a name="ln1307">static int</a>
<a name="ln1308">an_cmd(struct an_softc *sc, int cmd, int val)</a>
<a name="ln1309">{</a>
<a name="ln1310">	int			i, s = 0;</a>
<a name="ln1311"> </a>
<a name="ln1312">	AN_LOCK_ASSERT(sc);</a>
<a name="ln1313">	CSR_WRITE_2(sc, AN_PARAM0(sc-&gt;mpi350), val);</a>
<a name="ln1314">	CSR_WRITE_2(sc, AN_PARAM1(sc-&gt;mpi350), 0);</a>
<a name="ln1315">	CSR_WRITE_2(sc, AN_PARAM2(sc-&gt;mpi350), 0);</a>
<a name="ln1316">	CSR_WRITE_2(sc, AN_COMMAND(sc-&gt;mpi350), cmd);</a>
<a name="ln1317"> </a>
<a name="ln1318">	for (i = 0; i &lt; AN_TIMEOUT; i++) {</a>
<a name="ln1319">		if (CSR_READ_2(sc, AN_EVENT_STAT(sc-&gt;mpi350)) &amp; AN_EV_CMD)</a>
<a name="ln1320">			break;</a>
<a name="ln1321">		else {</a>
<a name="ln1322">			if (CSR_READ_2(sc, AN_COMMAND(sc-&gt;mpi350)) == cmd)</a>
<a name="ln1323">				CSR_WRITE_2(sc, AN_COMMAND(sc-&gt;mpi350), cmd);</a>
<a name="ln1324">		}</a>
<a name="ln1325">	}</a>
<a name="ln1326"> </a>
<a name="ln1327">	for (i = 0; i &lt; AN_TIMEOUT; i++) {</a>
<a name="ln1328">		CSR_READ_2(sc, AN_RESP0(sc-&gt;mpi350));</a>
<a name="ln1329">		CSR_READ_2(sc, AN_RESP1(sc-&gt;mpi350));</a>
<a name="ln1330">		CSR_READ_2(sc, AN_RESP2(sc-&gt;mpi350));</a>
<a name="ln1331">		s = CSR_READ_2(sc, AN_STATUS(sc-&gt;mpi350));</a>
<a name="ln1332">		if ((s &amp; AN_STAT_CMD_CODE) == (cmd &amp; AN_STAT_CMD_CODE))</a>
<a name="ln1333">			break;</a>
<a name="ln1334">	}</a>
<a name="ln1335"> </a>
<a name="ln1336">	/* Ack the command */</a>
<a name="ln1337">	CSR_WRITE_2(sc, AN_EVENT_ACK(sc-&gt;mpi350), AN_EV_CMD);</a>
<a name="ln1338"> </a>
<a name="ln1339">	if (CSR_READ_2(sc, AN_COMMAND(sc-&gt;mpi350)) &amp; AN_CMD_BUSY)</a>
<a name="ln1340">		CSR_WRITE_2(sc, AN_EVENT_ACK(sc-&gt;mpi350), AN_EV_CLR_STUCK_BUSY);</a>
<a name="ln1341"> </a>
<a name="ln1342">	if (i == AN_TIMEOUT)</a>
<a name="ln1343">		return(ETIMEDOUT);</a>
<a name="ln1344"> </a>
<a name="ln1345">	return(0);</a>
<a name="ln1346">}</a>
<a name="ln1347"> </a>
<a name="ln1348">/*</a>
<a name="ln1349"> * This reset sequence may look a little strange, but this is the</a>
<a name="ln1350"> * most reliable method I've found to really kick the NIC in the</a>
<a name="ln1351"> * head and force it to reboot correctly.</a>
<a name="ln1352"> */</a>
<a name="ln1353">static void</a>
<a name="ln1354">an_reset(struct an_softc *sc)</a>
<a name="ln1355">{</a>
<a name="ln1356">	if (sc-&gt;an_gone)</a>
<a name="ln1357">		return;</a>
<a name="ln1358"> </a>
<a name="ln1359">	AN_LOCK_ASSERT(sc);</a>
<a name="ln1360">	an_cmd(sc, AN_CMD_ENABLE, 0);</a>
<a name="ln1361">	an_cmd(sc, AN_CMD_FW_RESTART, 0);</a>
<a name="ln1362">	an_cmd(sc, AN_CMD_NOOP2, 0);</a>
<a name="ln1363"> </a>
<a name="ln1364">	if (an_cmd(sc, AN_CMD_FORCE_SYNCLOSS, 0) == ETIMEDOUT)</a>
<a name="ln1365">		device_printf(sc-&gt;an_dev, &quot;reset failed\n&quot;);</a>
<a name="ln1366"> </a>
<a name="ln1367">	an_cmd(sc, AN_CMD_DISABLE, 0);</a>
<a name="ln1368"> </a>
<a name="ln1369">	return;</a>
<a name="ln1370">}</a>
<a name="ln1371"> </a>
<a name="ln1372">/*</a>
<a name="ln1373"> * Read an LTV record from the NIC.</a>
<a name="ln1374"> */</a>
<a name="ln1375">static int</a>
<a name="ln1376">an_read_record(struct an_softc *sc, struct an_ltv_gen *ltv)</a>
<a name="ln1377">{</a>
<a name="ln1378">	struct an_ltv_gen	*an_ltv;</a>
<a name="ln1379">	struct an_card_rid_desc an_rid_desc;</a>
<a name="ln1380">	struct an_command	cmd;</a>
<a name="ln1381">	struct an_reply		reply;</a>
<a name="ln1382">	struct ifnet		*ifp;</a>
<a name="ln1383">	u_int16_t		*ptr;</a>
<a name="ln1384">	u_int8_t		*ptr2;</a>
<a name="ln1385">	int			i, len;</a>
<a name="ln1386"> </a>
<a name="ln1387">	AN_LOCK_ASSERT(sc);</a>
<a name="ln1388">	if (ltv-&gt;an_len &lt; 4 || ltv-&gt;an_type == 0)</a>
<a name="ln1389">		return(EINVAL);</a>
<a name="ln1390"> </a>
<a name="ln1391">	ifp = sc-&gt;an_ifp;</a>
<a name="ln1392">	if (!sc-&gt;mpi350){</a>
<a name="ln1393">		/* Tell the NIC to enter record read mode. */</a>
<a name="ln1394">		if (an_cmd(sc, AN_CMD_ACCESS|AN_ACCESS_READ, ltv-&gt;an_type)) {</a>
<a name="ln1395">			if_printf(ifp, &quot;RID access failed\n&quot;);</a>
<a name="ln1396">			return(EIO);</a>
<a name="ln1397">		}</a>
<a name="ln1398"> </a>
<a name="ln1399">		/* Seek to the record. */</a>
<a name="ln1400">		if (an_seek(sc, ltv-&gt;an_type, 0, AN_BAP1)) {</a>
<a name="ln1401">			if_printf(ifp, &quot;seek to record failed\n&quot;);</a>
<a name="ln1402">			return(EIO);</a>
<a name="ln1403">		}</a>
<a name="ln1404"> </a>
<a name="ln1405">		/*</a>
<a name="ln1406">		 * Read the length and record type and make sure they</a>
<a name="ln1407">		 * match what we expect (this verifies that we have enough</a>
<a name="ln1408">		 * room to hold all of the returned data).</a>
<a name="ln1409">		 * Length includes type but not length.</a>
<a name="ln1410">		 */</a>
<a name="ln1411">		len = CSR_READ_2(sc, AN_DATA1);</a>
<a name="ln1412">		if (len &gt; (ltv-&gt;an_len - 2)) {</a>
<a name="ln1413">			if_printf(ifp, &quot;record length mismatch -- expected %d, &quot;</a>
<a name="ln1414">			       &quot;got %d for Rid %x\n&quot;,</a>
<a name="ln1415">			       ltv-&gt;an_len - 2, len, ltv-&gt;an_type);</a>
<a name="ln1416">			len = ltv-&gt;an_len - 2;</a>
<a name="ln1417">		} else {</a>
<a name="ln1418">			ltv-&gt;an_len = len + 2;</a>
<a name="ln1419">		}</a>
<a name="ln1420"> </a>
<a name="ln1421">		/* Now read the data. */</a>
<a name="ln1422">		len -= 2;	/* skip the type */</a>
<a name="ln1423">		ptr = &amp;ltv-&gt;an_val;</a>
<a name="ln1424">		for (i = len; i &gt; 1; i -= 2)</a>
<a name="ln1425">			*ptr++ = CSR_READ_2(sc, AN_DATA1);</a>
<a name="ln1426">		if (i) {</a>
<a name="ln1427">			ptr2 = (u_int8_t *)ptr;</a>
<a name="ln1428">			*ptr2 = CSR_READ_1(sc, AN_DATA1);</a>
<a name="ln1429">		}</a>
<a name="ln1430">	} else { /* MPI-350 */</a>
<a name="ln1431">		if (!sc-&gt;an_rid_buffer.an_dma_vaddr)</a>
<a name="ln1432">			return(EIO);</a>
<a name="ln1433">		an_rid_desc.an_valid = 1;</a>
<a name="ln1434">		an_rid_desc.an_len = AN_RID_BUFFER_SIZE;</a>
<a name="ln1435">		an_rid_desc.an_rid = 0;</a>
<a name="ln1436">		an_rid_desc.an_phys = sc-&gt;an_rid_buffer.an_dma_paddr;</a>
<a name="ln1437">		bzero(sc-&gt;an_rid_buffer.an_dma_vaddr, AN_RID_BUFFER_SIZE);</a>
<a name="ln1438"> </a>
<a name="ln1439">		bzero(&amp;cmd, sizeof(cmd));</a>
<a name="ln1440">		bzero(&amp;reply, sizeof(reply));</a>
<a name="ln1441">		cmd.an_cmd = AN_CMD_ACCESS|AN_ACCESS_READ;</a>
<a name="ln1442">		cmd.an_parm0 = ltv-&gt;an_type;</a>
<a name="ln1443"> </a>
<a name="ln1444">		for (i = 0; i &lt; sizeof(an_rid_desc) / 4; i++)</a>
<a name="ln1445">			CSR_MEM_AUX_WRITE_4(sc, AN_HOST_DESC_OFFSET + i * 4,</a>
<a name="ln1446">			    ((u_int32_t *)(void *)&amp;an_rid_desc)[i]);</a>
<a name="ln1447"> </a>
<a name="ln1448">		if (an_cmd_struct(sc, &amp;cmd, &amp;reply)</a>
<a name="ln1449">		    || reply.an_status &amp; AN_CMD_QUAL_MASK) {</a>
<a name="ln1450">			if_printf(ifp, &quot;failed to read RID %x %x %x %x %x, %d\n&quot;,</a>
<a name="ln1451">			       ltv-&gt;an_type,</a>
<a name="ln1452">			       reply.an_status,</a>
<a name="ln1453">			       reply.an_resp0,</a>
<a name="ln1454">			       reply.an_resp1,</a>
<a name="ln1455">			       reply.an_resp2,</a>
<a name="ln1456">			       i);</a>
<a name="ln1457">			return(EIO);</a>
<a name="ln1458">		}</a>
<a name="ln1459"> </a>
<a name="ln1460">		an_ltv = (struct an_ltv_gen *)sc-&gt;an_rid_buffer.an_dma_vaddr;</a>
<a name="ln1461">		if (an_ltv-&gt;an_len + 2 &lt; an_rid_desc.an_len) {</a>
<a name="ln1462">			an_rid_desc.an_len = an_ltv-&gt;an_len;</a>
<a name="ln1463">		}</a>
<a name="ln1464"> </a>
<a name="ln1465">		len = an_rid_desc.an_len;</a>
<a name="ln1466">		if (len &gt; (ltv-&gt;an_len - 2)) {</a>
<a name="ln1467">			if_printf(ifp, &quot;record length mismatch -- expected %d, &quot;</a>
<a name="ln1468">			       &quot;got %d for Rid %x\n&quot;,</a>
<a name="ln1469">			       ltv-&gt;an_len - 2, len, ltv-&gt;an_type);</a>
<a name="ln1470">			len = ltv-&gt;an_len - 2;</a>
<a name="ln1471">		} else {</a>
<a name="ln1472">			ltv-&gt;an_len = len + 2;</a>
<a name="ln1473">		}</a>
<a name="ln1474">		bcopy(&amp;an_ltv-&gt;an_type,</a>
<a name="ln1475">		    &amp;ltv-&gt;an_val,</a>
<a name="ln1476">		    len);</a>
<a name="ln1477">	}</a>
<a name="ln1478"> </a>
<a name="ln1479">	if (an_dump)</a>
<a name="ln1480">		an_dump_record(sc, ltv, &quot;Read&quot;);</a>
<a name="ln1481"> </a>
<a name="ln1482">	return(0);</a>
<a name="ln1483">}</a>
<a name="ln1484"> </a>
<a name="ln1485">/*</a>
<a name="ln1486"> * Same as read, except we inject data instead of reading it.</a>
<a name="ln1487"> */</a>
<a name="ln1488">static int</a>
<a name="ln1489">an_write_record(struct an_softc *sc, struct an_ltv_gen *ltv)</a>
<a name="ln1490">{</a>
<a name="ln1491">	struct an_card_rid_desc an_rid_desc;</a>
<a name="ln1492">	struct an_command	cmd;</a>
<a name="ln1493">	struct an_reply		reply;</a>
<a name="ln1494">	u_int16_t		*ptr;</a>
<a name="ln1495">	u_int8_t		*ptr2;</a>
<a name="ln1496">	int			i, len;</a>
<a name="ln1497"> </a>
<a name="ln1498">	AN_LOCK_ASSERT(sc);</a>
<a name="ln1499">	if (an_dump)</a>
<a name="ln1500">		an_dump_record(sc, ltv, &quot;Write&quot;);</a>
<a name="ln1501"> </a>
<a name="ln1502">	if (!sc-&gt;mpi350){</a>
<a name="ln1503">		if (an_cmd(sc, AN_CMD_ACCESS|AN_ACCESS_READ, ltv-&gt;an_type))</a>
<a name="ln1504">			return(EIO);</a>
<a name="ln1505"> </a>
<a name="ln1506">		if (an_seek(sc, ltv-&gt;an_type, 0, AN_BAP1))</a>
<a name="ln1507">			return(EIO);</a>
<a name="ln1508"> </a>
<a name="ln1509">		/*</a>
<a name="ln1510">		 * Length includes type but not length.</a>
<a name="ln1511">		 */</a>
<a name="ln1512">		len = ltv-&gt;an_len - 2;</a>
<a name="ln1513">		CSR_WRITE_2(sc, AN_DATA1, len);</a>
<a name="ln1514"> </a>
<a name="ln1515">		len -= 2;	/* skip the type */</a>
<a name="ln1516">		ptr = &amp;ltv-&gt;an_val;</a>
<a name="ln1517">		for (i = len; i &gt; 1; i -= 2)</a>
<a name="ln1518">			CSR_WRITE_2(sc, AN_DATA1, *ptr++);</a>
<a name="ln1519">		if (i) {</a>
<a name="ln1520">			ptr2 = (u_int8_t *)ptr;</a>
<a name="ln1521">			CSR_WRITE_1(sc, AN_DATA0, *ptr2);</a>
<a name="ln1522">		}</a>
<a name="ln1523"> </a>
<a name="ln1524">		if (an_cmd(sc, AN_CMD_ACCESS|AN_ACCESS_WRITE, ltv-&gt;an_type))</a>
<a name="ln1525">			return(EIO);</a>
<a name="ln1526">	} else {</a>
<a name="ln1527">		/* MPI-350 */</a>
<a name="ln1528"> </a>
<a name="ln1529">		for (i = 0; i != AN_TIMEOUT; i++) {</a>
<a name="ln1530">			if (CSR_READ_2(sc, AN_COMMAND(sc-&gt;mpi350))</a>
<a name="ln1531">			    &amp; AN_CMD_BUSY) {</a>
<a name="ln1532">				DELAY(10);</a>
<a name="ln1533">			} else</a>
<a name="ln1534">				break;</a>
<a name="ln1535">		}</a>
<a name="ln1536">		if (i == AN_TIMEOUT) {</a>
<a name="ln1537">			printf(&quot;BUSY\n&quot;);</a>
<a name="ln1538">		}</a>
<a name="ln1539"> </a>
<a name="ln1540">		an_rid_desc.an_valid = 1;</a>
<a name="ln1541">		an_rid_desc.an_len = ltv-&gt;an_len - 2;</a>
<a name="ln1542">		an_rid_desc.an_rid = ltv-&gt;an_type;</a>
<a name="ln1543">		an_rid_desc.an_phys = sc-&gt;an_rid_buffer.an_dma_paddr;</a>
<a name="ln1544"> </a>
<a name="ln1545">		bcopy(&amp;ltv-&gt;an_type, sc-&gt;an_rid_buffer.an_dma_vaddr,</a>
<a name="ln1546">		      an_rid_desc.an_len);</a>
<a name="ln1547"> </a>
<a name="ln1548">		bzero(&amp;cmd,sizeof(cmd));</a>
<a name="ln1549">		bzero(&amp;reply,sizeof(reply));</a>
<a name="ln1550">		cmd.an_cmd = AN_CMD_ACCESS|AN_ACCESS_WRITE;</a>
<a name="ln1551">		cmd.an_parm0 = ltv-&gt;an_type;</a>
<a name="ln1552"> </a>
<a name="ln1553">		for (i = 0; i &lt; sizeof(an_rid_desc) / 4; i++)</a>
<a name="ln1554">			CSR_MEM_AUX_WRITE_4(sc, AN_HOST_DESC_OFFSET + i * 4,</a>
<a name="ln1555">			    ((u_int32_t *)(void *)&amp;an_rid_desc)[i]);</a>
<a name="ln1556"> </a>
<a name="ln1557">		DELAY(100000);</a>
<a name="ln1558"> </a>
<a name="ln1559">		if ((i = an_cmd_struct(sc, &amp;cmd, &amp;reply))) {</a>
<a name="ln1560">			if_printf(sc-&gt;an_ifp,</a>
<a name="ln1561">			    &quot;failed to write RID 1 %x %x %x %x %x, %d\n&quot;,</a>
<a name="ln1562">			    ltv-&gt;an_type,</a>
<a name="ln1563">			    reply.an_status,</a>
<a name="ln1564">			    reply.an_resp0,</a>
<a name="ln1565">			    reply.an_resp1,</a>
<a name="ln1566">			    reply.an_resp2,</a>
<a name="ln1567">			    i);</a>
<a name="ln1568">			return(EIO);</a>
<a name="ln1569">		}</a>
<a name="ln1570"> </a>
<a name="ln1571"> </a>
<a name="ln1572">		if (reply.an_status &amp; AN_CMD_QUAL_MASK) {</a>
<a name="ln1573">			if_printf(sc-&gt;an_ifp,</a>
<a name="ln1574">			    &quot;failed to write RID 2 %x %x %x %x %x, %d\n&quot;,</a>
<a name="ln1575">			    ltv-&gt;an_type,</a>
<a name="ln1576">			    reply.an_status,</a>
<a name="ln1577">			    reply.an_resp0,</a>
<a name="ln1578">			    reply.an_resp1,</a>
<a name="ln1579">			    reply.an_resp2,</a>
<a name="ln1580">			    i);</a>
<a name="ln1581">			return(EIO);</a>
<a name="ln1582">		}</a>
<a name="ln1583">		DELAY(100000);</a>
<a name="ln1584">	}</a>
<a name="ln1585"> </a>
<a name="ln1586">	return(0);</a>
<a name="ln1587">}</a>
<a name="ln1588"> </a>
<a name="ln1589">static void</a>
<a name="ln1590">an_dump_record(struct an_softc *sc, struct an_ltv_gen *ltv, char *string)</a>
<a name="ln1591">{</a>
<a name="ln1592">	u_int8_t		*ptr2;</a>
<a name="ln1593">	int			len;</a>
<a name="ln1594">	int			i;</a>
<a name="ln1595">	int			count = 0;</a>
<a name="ln1596">	char			buf[17], temp;</a>
<a name="ln1597"> </a>
<a name="ln1598">	len = ltv-&gt;an_len - 4;</a>
<a name="ln1599">	if_printf(sc-&gt;an_ifp, &quot;RID %4x, Length %4d, Mode %s\n&quot;,</a>
<a name="ln1600">		ltv-&gt;an_type, ltv-&gt;an_len - 4, string);</a>
<a name="ln1601"> </a>
<a name="ln1602">	if (an_dump == 1 || (an_dump == ltv-&gt;an_type)) {</a>
<a name="ln1603">		if_printf(sc-&gt;an_ifp, &quot;\t&quot;);</a>
<a name="ln1604">		bzero(buf,sizeof(buf));</a>
<a name="ln1605"> </a>
<a name="ln1606">		ptr2 = (u_int8_t *)&amp;ltv-&gt;an_val;</a>
<a name="ln1607">		for (i = len; i &gt; 0; i--) {</a>
<a name="ln1608">			printf(&quot;%02x &quot;, *ptr2);</a>
<a name="ln1609"> </a>
<a name="ln1610">			temp = *ptr2++;</a>
<a name="ln1611">			if (isprint(temp))</a>
<a name="ln1612">				buf[count] = temp;</a>
<a name="ln1613">			else</a>
<a name="ln1614">				buf[count] = '.';</a>
<a name="ln1615">			if (++count == 16) {</a>
<a name="ln1616">				count = 0;</a>
<a name="ln1617">				printf(&quot;%s\n&quot;,buf);</a>
<a name="ln1618">				if_printf(sc-&gt;an_ifp, &quot;\t&quot;);</a>
<a name="ln1619">				bzero(buf,sizeof(buf));</a>
<a name="ln1620">			}</a>
<a name="ln1621">		}</a>
<a name="ln1622">		for (; count != 16; count++) {</a>
<a name="ln1623">			printf(&quot;   &quot;);</a>
<a name="ln1624">		}</a>
<a name="ln1625">		printf(&quot; %s\n&quot;,buf);</a>
<a name="ln1626">	}</a>
<a name="ln1627">}</a>
<a name="ln1628"> </a>
<a name="ln1629">static int</a>
<a name="ln1630">an_seek(struct an_softc *sc, int id, int off, int chan)</a>
<a name="ln1631">{</a>
<a name="ln1632">	int			i;</a>
<a name="ln1633">	int			selreg, offreg;</a>
<a name="ln1634"> </a>
<a name="ln1635">	switch (chan) {</a>
<a name="ln1636">	case AN_BAP0:</a>
<a name="ln1637">		selreg = AN_SEL0;</a>
<a name="ln1638">		offreg = AN_OFF0;</a>
<a name="ln1639">		break;</a>
<a name="ln1640">	case AN_BAP1:</a>
<a name="ln1641">		selreg = AN_SEL1;</a>
<a name="ln1642">		offreg = AN_OFF1;</a>
<a name="ln1643">		break;</a>
<a name="ln1644">	default:</a>
<a name="ln1645">		if_printf(sc-&gt;an_ifp, &quot;invalid data path: %x\n&quot;, chan);</a>
<a name="ln1646">		return(EIO);</a>
<a name="ln1647">	}</a>
<a name="ln1648"> </a>
<a name="ln1649">	CSR_WRITE_2(sc, selreg, id);</a>
<a name="ln1650">	CSR_WRITE_2(sc, offreg, off);</a>
<a name="ln1651"> </a>
<a name="ln1652">	for (i = 0; i &lt; AN_TIMEOUT; i++) {</a>
<a name="ln1653">		if (!(CSR_READ_2(sc, offreg) &amp; (AN_OFF_BUSY|AN_OFF_ERR)))</a>
<a name="ln1654">			break;</a>
<a name="ln1655">	}</a>
<a name="ln1656"> </a>
<a name="ln1657">	if (i == AN_TIMEOUT)</a>
<a name="ln1658">		return(ETIMEDOUT);</a>
<a name="ln1659"> </a>
<a name="ln1660">	return(0);</a>
<a name="ln1661">}</a>
<a name="ln1662"> </a>
<a name="ln1663">static int</a>
<a name="ln1664">an_read_data(struct an_softc *sc, int id, int off, caddr_t buf, int len)</a>
<a name="ln1665">{</a>
<a name="ln1666">	int			i;</a>
<a name="ln1667">	u_int16_t		*ptr;</a>
<a name="ln1668">	u_int8_t		*ptr2;</a>
<a name="ln1669"> </a>
<a name="ln1670">	if (off != -1) {</a>
<a name="ln1671">		if (an_seek(sc, id, off, AN_BAP1))</a>
<a name="ln1672">			return(EIO);</a>
<a name="ln1673">	}</a>
<a name="ln1674"> </a>
<a name="ln1675">	ptr = (u_int16_t *)buf;</a>
<a name="ln1676">	for (i = len; i &gt; 1; i -= 2)</a>
<a name="ln1677">		*ptr++ = CSR_READ_2(sc, AN_DATA1);</a>
<a name="ln1678">	if (i) {</a>
<a name="ln1679">		ptr2 = (u_int8_t *)ptr;</a>
<a name="ln1680">		*ptr2 = CSR_READ_1(sc, AN_DATA1);</a>
<a name="ln1681">	}</a>
<a name="ln1682"> </a>
<a name="ln1683">	return(0);</a>
<a name="ln1684">}</a>
<a name="ln1685"> </a>
<a name="ln1686">static int</a>
<a name="ln1687">an_write_data(struct an_softc *sc, int id, int off, caddr_t buf, int len)</a>
<a name="ln1688">{</a>
<a name="ln1689">	int			i;</a>
<a name="ln1690">	u_int16_t		*ptr;</a>
<a name="ln1691">	u_int8_t		*ptr2;</a>
<a name="ln1692"> </a>
<a name="ln1693">	if (off != -1) {</a>
<a name="ln1694">		if (an_seek(sc, id, off, AN_BAP0))</a>
<a name="ln1695">			return(EIO);</a>
<a name="ln1696">	}</a>
<a name="ln1697"> </a>
<a name="ln1698">	ptr = (u_int16_t *)buf;</a>
<a name="ln1699">	for (i = len; i &gt; 1; i -= 2)</a>
<a name="ln1700">		CSR_WRITE_2(sc, AN_DATA0, *ptr++);</a>
<a name="ln1701">	if (i) {</a>
<a name="ln1702">		ptr2 = (u_int8_t *)ptr;</a>
<a name="ln1703">		CSR_WRITE_1(sc, AN_DATA0, *ptr2);</a>
<a name="ln1704">	}</a>
<a name="ln1705"> </a>
<a name="ln1706">	return(0);</a>
<a name="ln1707">}</a>
<a name="ln1708"> </a>
<a name="ln1709">/*</a>
<a name="ln1710"> * Allocate a region of memory inside the NIC and zero</a>
<a name="ln1711"> * it out.</a>
<a name="ln1712"> */</a>
<a name="ln1713">static int</a>
<a name="ln1714">an_alloc_nicmem(struct an_softc *sc, int len, int *id)</a>
<a name="ln1715">{</a>
<a name="ln1716">	int			i;</a>
<a name="ln1717"> </a>
<a name="ln1718">	if (an_cmd(sc, AN_CMD_ALLOC_MEM, len)) {</a>
<a name="ln1719">		if_printf(sc-&gt;an_ifp, &quot;failed to allocate %d bytes on NIC\n&quot;,</a>
<a name="ln1720">		    len);</a>
<a name="ln1721">		return(ENOMEM);</a>
<a name="ln1722">	}</a>
<a name="ln1723"> </a>
<a name="ln1724">	for (i = 0; i &lt; AN_TIMEOUT; i++) {</a>
<a name="ln1725">		if (CSR_READ_2(sc, AN_EVENT_STAT(sc-&gt;mpi350)) &amp; AN_EV_ALLOC)</a>
<a name="ln1726">			break;</a>
<a name="ln1727">	}</a>
<a name="ln1728"> </a>
<a name="ln1729">	if (i == AN_TIMEOUT)</a>
<a name="ln1730">		return(ETIMEDOUT);</a>
<a name="ln1731"> </a>
<a name="ln1732">	CSR_WRITE_2(sc, AN_EVENT_ACK(sc-&gt;mpi350), AN_EV_ALLOC);</a>
<a name="ln1733">	*id = CSR_READ_2(sc, AN_ALLOC_FID);</a>
<a name="ln1734"> </a>
<a name="ln1735">	if (an_seek(sc, *id, 0, AN_BAP0))</a>
<a name="ln1736">		return(EIO);</a>
<a name="ln1737"> </a>
<a name="ln1738">	for (i = 0; i &lt; len / 2; i++)</a>
<a name="ln1739">		CSR_WRITE_2(sc, AN_DATA0, 0);</a>
<a name="ln1740"> </a>
<a name="ln1741">	return(0);</a>
<a name="ln1742">}</a>
<a name="ln1743"> </a>
<a name="ln1744">static void</a>
<a name="ln1745">an_setdef(struct an_softc *sc, struct an_req *areq)</a>
<a name="ln1746">{</a>
<a name="ln1747">	struct ifnet		*ifp;</a>
<a name="ln1748">	struct an_ltv_genconfig	*cfg;</a>
<a name="ln1749">	struct an_ltv_ssidlist_new	*ssid;</a>
<a name="ln1750">	struct an_ltv_aplist	*ap;</a>
<a name="ln1751">	struct an_ltv_gen	*sp;</a>
<a name="ln1752"> </a>
<a name="ln1753">	ifp = sc-&gt;an_ifp;</a>
<a name="ln1754"> </a>
<a name="ln1755">	AN_LOCK_ASSERT(sc);</a>
<a name="ln1756">	switch (areq-&gt;an_type) {</a>
<a name="ln1757">	case AN_RID_GENCONFIG:</a>
<a name="ln1758">		cfg = (struct an_ltv_genconfig *)areq;</a>
<a name="ln1759"> </a>
<a name="ln1760">		bcopy((char *)&amp;cfg-&gt;an_macaddr, IF_LLADDR(sc-&gt;an_ifp),</a>
<a name="ln1761">		    ETHER_ADDR_LEN);</a>
<a name="ln1762"> </a>
<a name="ln1763">		bcopy((char *)cfg, (char *)&amp;sc-&gt;an_config,</a>
<a name="ln1764">			sizeof(struct an_ltv_genconfig));</a>
<a name="ln1765">		break;</a>
<a name="ln1766">	case AN_RID_SSIDLIST:</a>
<a name="ln1767">		ssid = (struct an_ltv_ssidlist_new *)areq;</a>
<a name="ln1768">		bcopy((char *)ssid, (char *)&amp;sc-&gt;an_ssidlist,</a>
<a name="ln1769">			sizeof(struct an_ltv_ssidlist_new));</a>
<a name="ln1770">		break;</a>
<a name="ln1771">	case AN_RID_APLIST:</a>
<a name="ln1772">		ap = (struct an_ltv_aplist *)areq;</a>
<a name="ln1773">		bcopy((char *)ap, (char *)&amp;sc-&gt;an_aplist,</a>
<a name="ln1774">			sizeof(struct an_ltv_aplist));</a>
<a name="ln1775">		break;</a>
<a name="ln1776">	case AN_RID_TX_SPEED:</a>
<a name="ln1777">		sp = (struct an_ltv_gen *)areq;</a>
<a name="ln1778">		sc-&gt;an_tx_rate = sp-&gt;an_val;</a>
<a name="ln1779"> </a>
<a name="ln1780">		/* Read the current configuration */</a>
<a name="ln1781">		sc-&gt;an_config.an_type = AN_RID_GENCONFIG;</a>
<a name="ln1782">		sc-&gt;an_config.an_len = sizeof(struct an_ltv_genconfig);</a>
<a name="ln1783">		an_read_record(sc, (struct an_ltv_gen *)&amp;sc-&gt;an_config);</a>
<a name="ln1784">		cfg = &amp;sc-&gt;an_config;</a>
<a name="ln1785"> </a>
<a name="ln1786">		/* clear other rates and set the only one we want */</a>
<a name="ln1787">		bzero(cfg-&gt;an_rates, sizeof(cfg-&gt;an_rates));</a>
<a name="ln1788">		cfg-&gt;an_rates[0] = sc-&gt;an_tx_rate;</a>
<a name="ln1789"> </a>
<a name="ln1790">		/* Save the new rate */</a>
<a name="ln1791">		sc-&gt;an_config.an_type = AN_RID_GENCONFIG;</a>
<a name="ln1792">		sc-&gt;an_config.an_len = sizeof(struct an_ltv_genconfig);</a>
<a name="ln1793">		break;</a>
<a name="ln1794">	case AN_RID_WEP_TEMP:</a>
<a name="ln1795">		/* Cache the temp keys */</a>
<a name="ln1796">		bcopy(areq,</a>
<a name="ln1797">		    &amp;sc-&gt;an_temp_keys[((struct an_ltv_key *)areq)-&gt;kindex],</a>
<a name="ln1798">		    sizeof(struct an_ltv_key));</a>
<a name="ln1799">	case AN_RID_WEP_PERM:</a>
<a name="ln1800">	case AN_RID_LEAPUSERNAME:</a>
<a name="ln1801">	case AN_RID_LEAPPASSWORD:</a>
<a name="ln1802">		an_init_locked(sc);</a>
<a name="ln1803"> </a>
<a name="ln1804">		/* Disable the MAC. */</a>
<a name="ln1805">		an_cmd(sc, AN_CMD_DISABLE, 0);</a>
<a name="ln1806"> </a>
<a name="ln1807">		/* Write the key */</a>
<a name="ln1808">		an_write_record(sc, (struct an_ltv_gen *)areq);</a>
<a name="ln1809"> </a>
<a name="ln1810">		/* Turn the MAC back on. */</a>
<a name="ln1811">		an_cmd(sc, AN_CMD_ENABLE, 0);</a>
<a name="ln1812"> </a>
<a name="ln1813">		break;</a>
<a name="ln1814">	case AN_RID_MONITOR_MODE:</a>
<a name="ln1815">		cfg = (struct an_ltv_genconfig *)areq;</a>
<a name="ln1816">		bpfdetach(ifp);</a>
<a name="ln1817">		if (ng_ether_detach_p != NULL)</a>
<a name="ln1818">			(*ng_ether_detach_p) (ifp);</a>
<a name="ln1819">		sc-&gt;an_monitor = cfg-&gt;an_len;</a>
<a name="ln1820"> </a>
<a name="ln1821">		if (sc-&gt;an_monitor &amp; AN_MONITOR) {</a>
<a name="ln1822">			if (sc-&gt;an_monitor &amp; AN_MONITOR_AIRONET_HEADER) {</a>
<a name="ln1823">				bpfattach(ifp, DLT_AIRONET_HEADER,</a>
<a name="ln1824">					sizeof(struct ether_header));</a>
<a name="ln1825">			} else {</a>
<a name="ln1826">				bpfattach(ifp, DLT_IEEE802_11,</a>
<a name="ln1827">					sizeof(struct ether_header));</a>
<a name="ln1828">			}</a>
<a name="ln1829">		} else {</a>
<a name="ln1830">			bpfattach(ifp, DLT_EN10MB,</a>
<a name="ln1831">				  sizeof(struct ether_header));</a>
<a name="ln1832">			if (ng_ether_attach_p != NULL)</a>
<a name="ln1833">				(*ng_ether_attach_p) (ifp);</a>
<a name="ln1834">		}</a>
<a name="ln1835">		break;</a>
<a name="ln1836">	default:</a>
<a name="ln1837">		if_printf(ifp, &quot;unknown RID: %x\n&quot;, areq-&gt;an_type);</a>
<a name="ln1838">		return;</a>
<a name="ln1839">	}</a>
<a name="ln1840"> </a>
<a name="ln1841"> </a>
<a name="ln1842">	/* Reinitialize the card. */</a>
<a name="ln1843">	if (ifp-&gt;if_flags)</a>
<a name="ln1844">		an_init_locked(sc);</a>
<a name="ln1845"> </a>
<a name="ln1846">	return;</a>
<a name="ln1847">}</a>
<a name="ln1848"> </a>
<a name="ln1849">/*</a>
<a name="ln1850"> * Derived from Linux driver to enable promiscious mode.</a>
<a name="ln1851"> */</a>
<a name="ln1852"> </a>
<a name="ln1853">static void</a>
<a name="ln1854">an_promisc(struct an_softc *sc, int promisc)</a>
<a name="ln1855">{</a>
<a name="ln1856">	AN_LOCK_ASSERT(sc);</a>
<a name="ln1857">	if (sc-&gt;an_was_monitor) {</a>
<a name="ln1858">		an_reset(sc);</a>
<a name="ln1859">		if (sc-&gt;mpi350)</a>
<a name="ln1860">			an_init_mpi350_desc(sc);</a>
<a name="ln1861">	}</a>
<a name="ln1862">	if (sc-&gt;an_monitor || sc-&gt;an_was_monitor)</a>
<a name="ln1863">		an_init_locked(sc);</a>
<a name="ln1864"> </a>
<a name="ln1865">	sc-&gt;an_was_monitor = sc-&gt;an_monitor;</a>
<a name="ln1866">	an_cmd(sc, AN_CMD_SET_MODE, promisc ? 0xffff : 0);</a>
<a name="ln1867"> </a>
<a name="ln1868">	return;</a>
<a name="ln1869">}</a>
<a name="ln1870"> </a>
<a name="ln1871">static int</a>
<a name="ln1872">an_ioctl(struct ifnet *ifp, u_long command, caddr_t data)</a>
<a name="ln1873">{</a>
<a name="ln1874">	int			error = 0;</a>
<a name="ln1875">	int			len;</a>
<a name="ln1876">	int			i, max;</a>
<a name="ln1877">	struct an_softc		*sc;</a>
<a name="ln1878">	struct ifreq		*ifr;</a>
<a name="ln1879">	struct thread		*td = curthread;</a>
<a name="ln1880">	struct ieee80211req	*ireq;</a>
<a name="ln1881">	struct ieee80211_channel	ch;</a>
<a name="ln1882">	u_int8_t		tmpstr[IEEE80211_NWID_LEN*2];</a>
<a name="ln1883">	u_int8_t		*tmpptr;</a>
<a name="ln1884">	struct an_ltv_genconfig	*config;</a>
<a name="ln1885">	struct an_ltv_key	*key;</a>
<a name="ln1886">	struct an_ltv_status	*status;</a>
<a name="ln1887">	struct an_ltv_ssidlist_new	*ssids;</a>
<a name="ln1888">	int			mode;</a>
<a name="ln1889">	struct aironet_ioctl	l_ioctl;</a>
<a name="ln1890"> </a>
<a name="ln1891">	sc = ifp-&gt;if_softc;</a>
<a name="ln1892">	ifr = (struct ifreq *)data;</a>
<a name="ln1893">	ireq = (struct ieee80211req *)data;</a>
<a name="ln1894"> </a>
<a name="ln1895">	config = (struct an_ltv_genconfig *)&amp;sc-&gt;areq;</a>
<a name="ln1896">	key = (struct an_ltv_key *)&amp;sc-&gt;areq;</a>
<a name="ln1897">	status = (struct an_ltv_status *)&amp;sc-&gt;areq;</a>
<a name="ln1898">	ssids = (struct an_ltv_ssidlist_new *)&amp;sc-&gt;areq;</a>
<a name="ln1899"> </a>
<a name="ln1900">	if (sc-&gt;an_gone) {</a>
<a name="ln1901">		error = ENODEV;</a>
<a name="ln1902">		goto out;</a>
<a name="ln1903">	}</a>
<a name="ln1904"> </a>
<a name="ln1905">	switch (command) {</a>
<a name="ln1906">	case SIOCSIFFLAGS:</a>
<a name="ln1907">		AN_LOCK(sc);</a>
<a name="ln1908">		if (ifp-&gt;if_flags &amp; IFF_UP) {</a>
<a name="ln1909">			if (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING &amp;&amp;</a>
<a name="ln1910">			    ifp-&gt;if_flags &amp; IFF_PROMISC &amp;&amp;</a>
<a name="ln1911">			    !(sc-&gt;an_if_flags &amp; IFF_PROMISC)) {</a>
<a name="ln1912">				an_promisc(sc, 1);</a>
<a name="ln1913">			} else if (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING &amp;&amp;</a>
<a name="ln1914">			    !(ifp-&gt;if_flags &amp; IFF_PROMISC) &amp;&amp;</a>
<a name="ln1915">			    sc-&gt;an_if_flags &amp; IFF_PROMISC) {</a>
<a name="ln1916">				an_promisc(sc, 0);</a>
<a name="ln1917">			} else</a>
<a name="ln1918">				an_init_locked(sc);</a>
<a name="ln1919">		} else {</a>
<a name="ln1920">			if (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING)</a>
<a name="ln1921">				an_stop(sc);</a>
<a name="ln1922">		}</a>
<a name="ln1923">		sc-&gt;an_if_flags = ifp-&gt;if_flags;</a>
<a name="ln1924">		AN_UNLOCK(sc);</a>
<a name="ln1925">		error = 0;</a>
<a name="ln1926">		break;</a>
<a name="ln1927">	case SIOCSIFMEDIA:</a>
<a name="ln1928">	case SIOCGIFMEDIA:</a>
<a name="ln1929">		error = ifmedia_ioctl(ifp, ifr, &amp;sc-&gt;an_ifmedia, command);</a>
<a name="ln1930">		break;</a>
<a name="ln1931">	case SIOCADDMULTI:</a>
<a name="ln1932">	case SIOCDELMULTI:</a>
<a name="ln1933">		/* The Aironet has no multicast filter. */</a>
<a name="ln1934">		error = 0;</a>
<a name="ln1935">		break;</a>
<a name="ln1936">	case SIOCGAIRONET:</a>
<a name="ln1937">		error = copyin(ifr_data_get_ptr(ifr), &amp;sc-&gt;areq,</a>
<a name="ln1938">		    sizeof(sc-&gt;areq));</a>
<a name="ln1939">		if (error != 0)</a>
<a name="ln1940">			break;</a>
<a name="ln1941">		AN_LOCK(sc);</a>
<a name="ln1942">#ifdef ANCACHE</a>
<a name="ln1943">		if (sc-&gt;areq.an_type == AN_RID_ZERO_CACHE) {</a>
<a name="ln1944">			error = priv_check(td, PRIV_DRIVER);</a>
<a name="ln1945">			if (error)</a>
<a name="ln1946">				break;</a>
<a name="ln1947">			sc-&gt;an_sigitems = sc-&gt;an_nextitem = 0;</a>
<a name="ln1948">			break;</a>
<a name="ln1949">		} else if (sc-&gt;areq.an_type == AN_RID_READ_CACHE) {</a>
<a name="ln1950">			char *pt = (char *)&amp;sc-&gt;areq.an_val;</a>
<a name="ln1951">			bcopy((char *)&amp;sc-&gt;an_sigitems, (char *)pt,</a>
<a name="ln1952">			    sizeof(int));</a>
<a name="ln1953">			pt += sizeof(int);</a>
<a name="ln1954">			sc-&gt;areq.an_len = sizeof(int) / 2;</a>
<a name="ln1955">			bcopy((char *)&amp;sc-&gt;an_sigcache, (char *)pt,</a>
<a name="ln1956">			    sizeof(struct an_sigcache) * sc-&gt;an_sigitems);</a>
<a name="ln1957">			sc-&gt;areq.an_len += ((sizeof(struct an_sigcache) *</a>
<a name="ln1958">			    sc-&gt;an_sigitems) / 2) + 1;</a>
<a name="ln1959">		} else</a>
<a name="ln1960">#endif</a>
<a name="ln1961">		if (an_read_record(sc, (struct an_ltv_gen *)&amp;sc-&gt;areq)) {</a>
<a name="ln1962">			AN_UNLOCK(sc);</a>
<a name="ln1963">			error = EINVAL;</a>
<a name="ln1964">			break;</a>
<a name="ln1965">		}</a>
<a name="ln1966">		AN_UNLOCK(sc);</a>
<a name="ln1967">		error = copyout(&amp;sc-&gt;areq, ifr_data_get_ptr(ifr),</a>
<a name="ln1968">		    sizeof(sc-&gt;areq));</a>
<a name="ln1969">		break;</a>
<a name="ln1970">	case SIOCSAIRONET:</a>
<a name="ln1971">		if ((error = priv_check(td, PRIV_DRIVER)))</a>
<a name="ln1972">			goto out;</a>
<a name="ln1973">		AN_LOCK(sc);</a>
<a name="ln1974">		error = copyin(ifr_data_get_ptr(ifr), &amp;sc-&gt;areq,</a>
<a name="ln1975">		    sizeof(sc-&gt;areq));</a>
<a name="ln1976">		if (error != 0)</a>
<a name="ln1977">			break;</a>
<a name="ln1978">		an_setdef(sc, &amp;sc-&gt;areq);</a>
<a name="ln1979">		AN_UNLOCK(sc);</a>
<a name="ln1980">		break;</a>
<a name="ln1981">	case SIOCGPRIVATE_0:		/* used by Cisco client utility */</a>
<a name="ln1982">		if ((error = priv_check(td, PRIV_DRIVER)))</a>
<a name="ln1983">			goto out;</a>
<a name="ln1984">		error = copyin(ifr_data_get_ptr(ifr), &amp;l_ioctl,</a>
<a name="ln1985">		    sizeof(l_ioctl));</a>
<a name="ln1986">		if (error)</a>
<a name="ln1987">			goto out;</a>
<a name="ln1988">		mode = l_ioctl.command;</a>
<a name="ln1989"> </a>
<a name="ln1990">		AN_LOCK(sc);</a>
<a name="ln1991">		if (mode &gt;= AIROGCAP &amp;&amp; mode &lt;= AIROGSTATSD32) {</a>
<a name="ln1992">			error = readrids(ifp, &amp;l_ioctl);</a>
<a name="ln1993">		} else if (mode &gt;= AIROPCAP &amp;&amp; mode &lt;= AIROPLEAPUSR) {</a>
<a name="ln1994">			error = writerids(ifp, &amp;l_ioctl);</a>
<a name="ln1995">		} else if (mode &gt;= AIROFLSHRST &amp;&amp; mode &lt;= AIRORESTART) {</a>
<a name="ln1996">			error = flashcard(ifp, &amp;l_ioctl);</a>
<a name="ln1997">		} else {</a>
<a name="ln1998">			error =-1;</a>
<a name="ln1999">		}</a>
<a name="ln2000">		AN_UNLOCK(sc);</a>
<a name="ln2001">		if (!error) {</a>
<a name="ln2002">			/* copy out the updated command info */</a>
<a name="ln2003">			error = copyout(&amp;l_ioctl, ifr_data_get_ptr(ifr),</a>
<a name="ln2004">			    sizeof(l_ioctl));</a>
<a name="ln2005">		}</a>
<a name="ln2006">		break;</a>
<a name="ln2007">	case SIOCGPRIVATE_1:		/* used by Cisco client utility */</a>
<a name="ln2008">		if ((error = priv_check(td, PRIV_DRIVER)))</a>
<a name="ln2009">			goto out;</a>
<a name="ln2010">		error = copyin(ifr_data_get_ptr(ifr), &amp;l_ioctl,</a>
<a name="ln2011">		    sizeof(l_ioctl));</a>
<a name="ln2012">		if (error)</a>
<a name="ln2013">			goto out;</a>
<a name="ln2014">		l_ioctl.command = 0;</a>
<a name="ln2015">		error = AIROMAGIC;</a>
<a name="ln2016">		(void) copyout(&amp;error, l_ioctl.data, sizeof(error));</a>
<a name="ln2017">		error = 0;</a>
<a name="ln2018">		break;</a>
<a name="ln2019">	case SIOCG80211:</a>
<a name="ln2020">		sc-&gt;areq.an_len = sizeof(sc-&gt;areq);</a>
<a name="ln2021">		/* was that a good idea DJA we are doing a short-cut */</a>
<a name="ln2022">		switch (ireq-&gt;i_type) {</a>
<a name="ln2023">		case IEEE80211_IOC_SSID:</a>
<a name="ln2024">			AN_LOCK(sc);</a>
<a name="ln2025">			if (ireq-&gt;i_val == -1) {</a>
<a name="ln2026">				sc-&gt;areq.an_type = AN_RID_STATUS;</a>
<a name="ln2027">				if (an_read_record(sc,</a>
<a name="ln2028">				    (struct an_ltv_gen *)&amp;sc-&gt;areq)) {</a>
<a name="ln2029">					error = EINVAL;</a>
<a name="ln2030">					AN_UNLOCK(sc);</a>
<a name="ln2031">					break;</a>
<a name="ln2032">				}</a>
<a name="ln2033">				len = status-&gt;an_ssidlen;</a>
<a name="ln2034">				tmpptr = status-&gt;an_ssid;</a>
<a name="ln2035">			} else if (ireq-&gt;i_val &gt;= 0) {</a>
<a name="ln2036">				sc-&gt;areq.an_type = AN_RID_SSIDLIST;</a>
<a name="ln2037">				if (an_read_record(sc,</a>
<a name="ln2038">				    (struct an_ltv_gen *)&amp;sc-&gt;areq)) {</a>
<a name="ln2039">					error = EINVAL;</a>
<a name="ln2040">					AN_UNLOCK(sc);</a>
<a name="ln2041">					break;</a>
<a name="ln2042">				}</a>
<a name="ln2043">				max = (sc-&gt;areq.an_len - 4)</a>
<a name="ln2044">				    / sizeof(struct an_ltv_ssid_entry);</a>
<a name="ln2045">				if ( max &gt; MAX_SSIDS ) {</a>
<a name="ln2046">					printf(&quot;To many SSIDs only using &quot;</a>
<a name="ln2047">					    &quot;%d of %d\n&quot;,</a>
<a name="ln2048">					    MAX_SSIDS, max);</a>
<a name="ln2049">					max = MAX_SSIDS;</a>
<a name="ln2050">				}</a>
<a name="ln2051">				if (ireq-&gt;i_val &gt; max) {</a>
<a name="ln2052">					error = EINVAL;</a>
<a name="ln2053">					AN_UNLOCK(sc);</a>
<a name="ln2054">					break;</a>
<a name="ln2055">				} else {</a>
<a name="ln2056">					len = ssids-&gt;an_entry[ireq-&gt;i_val].an_len;</a>
<a name="ln2057">					tmpptr = ssids-&gt;an_entry[ireq-&gt;i_val].an_ssid;</a>
<a name="ln2058">				}</a>
<a name="ln2059">			} else {</a>
<a name="ln2060">				error = EINVAL;</a>
<a name="ln2061">				AN_UNLOCK(sc);</a>
<a name="ln2062">				break;</a>
<a name="ln2063">			}</a>
<a name="ln2064">			if (len &gt; IEEE80211_NWID_LEN) {</a>
<a name="ln2065">				error = EINVAL;</a>
<a name="ln2066">				AN_UNLOCK(sc);</a>
<a name="ln2067">				break;</a>
<a name="ln2068">			}</a>
<a name="ln2069">			AN_UNLOCK(sc);</a>
<a name="ln2070">			ireq-&gt;i_len = len;</a>
<a name="ln2071">			bzero(tmpstr, IEEE80211_NWID_LEN);</a>
<a name="ln2072">			bcopy(tmpptr, tmpstr, len);</a>
<a name="ln2073">			error = copyout(tmpstr, ireq-&gt;i_data,</a>
<a name="ln2074">			    IEEE80211_NWID_LEN);</a>
<a name="ln2075">			break;</a>
<a name="ln2076">		case IEEE80211_IOC_NUMSSIDS:</a>
<a name="ln2077">			AN_LOCK(sc);</a>
<a name="ln2078">			sc-&gt;areq.an_len = sizeof(sc-&gt;areq);</a>
<a name="ln2079">			sc-&gt;areq.an_type = AN_RID_SSIDLIST;</a>
<a name="ln2080">			if (an_read_record(sc,</a>
<a name="ln2081">			    (struct an_ltv_gen *)&amp;sc-&gt;areq)) {</a>
<a name="ln2082">				AN_UNLOCK(sc);</a>
<a name="ln2083">				error = EINVAL;</a>
<a name="ln2084">				break;</a>
<a name="ln2085">			}</a>
<a name="ln2086">			max = (sc-&gt;areq.an_len - 4)</a>
<a name="ln2087">			    / sizeof(struct an_ltv_ssid_entry);</a>
<a name="ln2088">			AN_UNLOCK(sc);</a>
<a name="ln2089">			if ( max &gt; MAX_SSIDS ) {</a>
<a name="ln2090">				printf(&quot;To many SSIDs only using &quot;</a>
<a name="ln2091">				    &quot;%d of %d\n&quot;,</a>
<a name="ln2092">				    MAX_SSIDS, max);</a>
<a name="ln2093">				max = MAX_SSIDS;</a>
<a name="ln2094">			}</a>
<a name="ln2095">			ireq-&gt;i_val = max;</a>
<a name="ln2096">			break;</a>
<a name="ln2097">		case IEEE80211_IOC_WEP:</a>
<a name="ln2098">			AN_LOCK(sc);</a>
<a name="ln2099">			sc-&gt;areq.an_type = AN_RID_ACTUALCFG;</a>
<a name="ln2100">			if (an_read_record(sc,</a>
<a name="ln2101">			    (struct an_ltv_gen *)&amp;sc-&gt;areq)) {</a>
<a name="ln2102">				error = EINVAL;</a>
<a name="ln2103">				AN_UNLOCK(sc);</a>
<a name="ln2104">				break;</a>
<a name="ln2105">			}</a>
<a name="ln2106">			AN_UNLOCK(sc);</a>
<a name="ln2107">			if (config-&gt;an_authtype &amp; AN_AUTHTYPE_PRIVACY_IN_USE) {</a>
<a name="ln2108">				if (config-&gt;an_authtype &amp;</a>
<a name="ln2109">				    AN_AUTHTYPE_ALLOW_UNENCRYPTED)</a>
<a name="ln2110">					ireq-&gt;i_val = IEEE80211_WEP_MIXED;</a>
<a name="ln2111">				else</a>
<a name="ln2112">					ireq-&gt;i_val = IEEE80211_WEP_ON;</a>
<a name="ln2113">			} else {</a>
<a name="ln2114">				ireq-&gt;i_val = IEEE80211_WEP_OFF;</a>
<a name="ln2115">			}</a>
<a name="ln2116">			break;</a>
<a name="ln2117">		case IEEE80211_IOC_WEPKEY:</a>
<a name="ln2118">			/*</a>
<a name="ln2119">			 * XXX: I'm not entierly convinced this is</a>
<a name="ln2120">			 * correct, but it's what is implemented in</a>
<a name="ln2121">			 * ancontrol so it will have to do until we get</a>
<a name="ln2122">			 * access to actual Cisco code.</a>
<a name="ln2123">			 */</a>
<a name="ln2124">			if (ireq-&gt;i_val &lt; 0 || ireq-&gt;i_val &gt; 8) {</a>
<a name="ln2125">				error = EINVAL;</a>
<a name="ln2126">				break;</a>
<a name="ln2127">			}</a>
<a name="ln2128">			len = 0;</a>
<a name="ln2129">			if (ireq-&gt;i_val &lt; 5) {</a>
<a name="ln2130">				AN_LOCK(sc);</a>
<a name="ln2131">				sc-&gt;areq.an_type = AN_RID_WEP_TEMP;</a>
<a name="ln2132">				for (i = 0; i &lt; 5; i++) {</a>
<a name="ln2133">					if (an_read_record(sc,</a>
<a name="ln2134">					    (struct an_ltv_gen *)&amp;sc-&gt;areq)) {</a>
<a name="ln2135">						error = EINVAL;</a>
<a name="ln2136">						break;</a>
<a name="ln2137">					}</a>
<a name="ln2138">					if (key-&gt;kindex == 0xffff)</a>
<a name="ln2139">						break;</a>
<a name="ln2140">					if (key-&gt;kindex == ireq-&gt;i_val)</a>
<a name="ln2141">						len = key-&gt;klen;</a>
<a name="ln2142">					/* Required to get next entry */</a>
<a name="ln2143">					sc-&gt;areq.an_type = AN_RID_WEP_PERM;</a>
<a name="ln2144">				}</a>
<a name="ln2145">				AN_UNLOCK(sc);</a>
<a name="ln2146">				if (error != 0) {</a>
<a name="ln2147">					break;</a>
<a name="ln2148">				}</a>
<a name="ln2149">			}</a>
<a name="ln2150">			/* We aren't allowed to read the value of the</a>
<a name="ln2151">			 * key from the card so we just output zeros</a>
<a name="ln2152">			 * like we would if we could read the card, but</a>
<a name="ln2153">			 * denied the user access.</a>
<a name="ln2154">			 */</a>
<a name="ln2155">			bzero(tmpstr, len);</a>
<a name="ln2156">			ireq-&gt;i_len = len;</a>
<a name="ln2157">			error = copyout(tmpstr, ireq-&gt;i_data, len);</a>
<a name="ln2158">			break;</a>
<a name="ln2159">		case IEEE80211_IOC_NUMWEPKEYS:</a>
<a name="ln2160">			ireq-&gt;i_val = 9; /* include home key */</a>
<a name="ln2161">			break;</a>
<a name="ln2162">		case IEEE80211_IOC_WEPTXKEY:</a>
<a name="ln2163">			/*</a>
<a name="ln2164">			 * For some strange reason, you have to read all</a>
<a name="ln2165">			 * keys before you can read the txkey.</a>
<a name="ln2166">			 */</a>
<a name="ln2167">			AN_LOCK(sc);</a>
<a name="ln2168">			sc-&gt;areq.an_type = AN_RID_WEP_TEMP;</a>
<a name="ln2169">			for (i = 0; i &lt; 5; i++) {</a>
<a name="ln2170">				if (an_read_record(sc,</a>
<a name="ln2171">				    (struct an_ltv_gen *) &amp;sc-&gt;areq)) {</a>
<a name="ln2172">					error = EINVAL;</a>
<a name="ln2173">					break;</a>
<a name="ln2174">				}</a>
<a name="ln2175">				if (key-&gt;kindex == 0xffff) {</a>
<a name="ln2176">					break;</a>
<a name="ln2177">				}</a>
<a name="ln2178">				/* Required to get next entry */</a>
<a name="ln2179">				sc-&gt;areq.an_type = AN_RID_WEP_PERM;</a>
<a name="ln2180">			}</a>
<a name="ln2181">			if (error != 0) {</a>
<a name="ln2182">				AN_UNLOCK(sc);</a>
<a name="ln2183">				break;</a>
<a name="ln2184">			}</a>
<a name="ln2185"> </a>
<a name="ln2186">			sc-&gt;areq.an_type = AN_RID_WEP_PERM;</a>
<a name="ln2187">			key-&gt;kindex = 0xffff;</a>
<a name="ln2188">			if (an_read_record(sc,</a>
<a name="ln2189">			    (struct an_ltv_gen *)&amp;sc-&gt;areq)) {</a>
<a name="ln2190">				error = EINVAL;</a>
<a name="ln2191">				AN_UNLOCK(sc);</a>
<a name="ln2192">				break;</a>
<a name="ln2193">			}</a>
<a name="ln2194">			ireq-&gt;i_val = key-&gt;mac[0];</a>
<a name="ln2195">			/*</a>
<a name="ln2196">			 * Check for home mode.  Map home mode into</a>
<a name="ln2197">			 * 5th key since that is how it is stored on</a>
<a name="ln2198">			 * the card</a>
<a name="ln2199">			 */</a>
<a name="ln2200">			sc-&gt;areq.an_len  = sizeof(struct an_ltv_genconfig);</a>
<a name="ln2201">			sc-&gt;areq.an_type = AN_RID_GENCONFIG;</a>
<a name="ln2202">			if (an_read_record(sc,</a>
<a name="ln2203">			    (struct an_ltv_gen *)&amp;sc-&gt;areq)) {</a>
<a name="ln2204">				error = EINVAL;</a>
<a name="ln2205">				AN_UNLOCK(sc);</a>
<a name="ln2206">				break;</a>
<a name="ln2207">			}</a>
<a name="ln2208">			if (config-&gt;an_home_product &amp; AN_HOME_NETWORK)</a>
<a name="ln2209">				ireq-&gt;i_val = 4;</a>
<a name="ln2210">			AN_UNLOCK(sc);</a>
<a name="ln2211">			break;</a>
<a name="ln2212">		case IEEE80211_IOC_AUTHMODE:</a>
<a name="ln2213">			AN_LOCK(sc);</a>
<a name="ln2214">			sc-&gt;areq.an_type = AN_RID_ACTUALCFG;</a>
<a name="ln2215">			if (an_read_record(sc,</a>
<a name="ln2216">			    (struct an_ltv_gen *)&amp;sc-&gt;areq)) {</a>
<a name="ln2217">				error = EINVAL;</a>
<a name="ln2218">				AN_UNLOCK(sc);</a>
<a name="ln2219">				break;</a>
<a name="ln2220">			}</a>
<a name="ln2221">			AN_UNLOCK(sc);</a>
<a name="ln2222">			if ((config-&gt;an_authtype &amp; AN_AUTHTYPE_MASK) ==</a>
<a name="ln2223">			    AN_AUTHTYPE_NONE) {</a>
<a name="ln2224">			    ireq-&gt;i_val = IEEE80211_AUTH_NONE;</a>
<a name="ln2225">			} else if ((config-&gt;an_authtype &amp; AN_AUTHTYPE_MASK) ==</a>
<a name="ln2226">			    AN_AUTHTYPE_OPEN) {</a>
<a name="ln2227">			    ireq-&gt;i_val = IEEE80211_AUTH_OPEN;</a>
<a name="ln2228">			} else if ((config-&gt;an_authtype &amp; AN_AUTHTYPE_MASK) ==</a>
<a name="ln2229">			    AN_AUTHTYPE_SHAREDKEY) {</a>
<a name="ln2230">			    ireq-&gt;i_val = IEEE80211_AUTH_SHARED;</a>
<a name="ln2231">			} else</a>
<a name="ln2232">				error = EINVAL;</a>
<a name="ln2233">			break;</a>
<a name="ln2234">		case IEEE80211_IOC_STATIONNAME:</a>
<a name="ln2235">			AN_LOCK(sc);</a>
<a name="ln2236">			sc-&gt;areq.an_type = AN_RID_ACTUALCFG;</a>
<a name="ln2237">			if (an_read_record(sc,</a>
<a name="ln2238">			    (struct an_ltv_gen *)&amp;sc-&gt;areq)) {</a>
<a name="ln2239">				error = EINVAL;</a>
<a name="ln2240">				AN_UNLOCK(sc);</a>
<a name="ln2241">				break;</a>
<a name="ln2242">			}</a>
<a name="ln2243">			AN_UNLOCK(sc);</a>
<a name="ln2244">			ireq-&gt;i_len = sizeof(config-&gt;an_nodename);</a>
<a name="ln2245">			tmpptr = config-&gt;an_nodename;</a>
<a name="ln2246">			bzero(tmpstr, IEEE80211_NWID_LEN);</a>
<a name="ln2247">			bcopy(tmpptr, tmpstr, ireq-&gt;i_len);</a>
<a name="ln2248">			error = copyout(tmpstr, ireq-&gt;i_data,</a>
<a name="ln2249">			    IEEE80211_NWID_LEN);</a>
<a name="ln2250">			break;</a>
<a name="ln2251">		case IEEE80211_IOC_CHANNEL:</a>
<a name="ln2252">			AN_LOCK(sc);</a>
<a name="ln2253">			sc-&gt;areq.an_type = AN_RID_STATUS;</a>
<a name="ln2254">			if (an_read_record(sc,</a>
<a name="ln2255">			    (struct an_ltv_gen *)&amp;sc-&gt;areq)) {</a>
<a name="ln2256">				error = EINVAL;</a>
<a name="ln2257">				AN_UNLOCK(sc);</a>
<a name="ln2258">				break;</a>
<a name="ln2259">			}</a>
<a name="ln2260">			AN_UNLOCK(sc);</a>
<a name="ln2261">			ireq-&gt;i_val = status-&gt;an_cur_channel;</a>
<a name="ln2262">			break;</a>
<a name="ln2263">		case IEEE80211_IOC_CURCHAN:</a>
<a name="ln2264">			AN_LOCK(sc);</a>
<a name="ln2265">			sc-&gt;areq.an_type = AN_RID_STATUS;</a>
<a name="ln2266">			if (an_read_record(sc,</a>
<a name="ln2267">			    (struct an_ltv_gen *)&amp;sc-&gt;areq)) {</a>
<a name="ln2268">				error = EINVAL;</a>
<a name="ln2269">				AN_UNLOCK(sc);</a>
<a name="ln2270">				break;</a>
<a name="ln2271">			}</a>
<a name="ln2272">			AN_UNLOCK(sc);</a>
<a name="ln2273">			bzero(&amp;ch, sizeof(ch));</a>
<a name="ln2274">			ch.ic_freq = ieee80211_ieee2mhz(status-&gt;an_cur_channel,</a>
<a name="ln2275">			    IEEE80211_CHAN_B);</a>
<a name="ln2276">			ch.ic_flags = IEEE80211_CHAN_B;</a>
<a name="ln2277">			ch.ic_ieee = status-&gt;an_cur_channel;</a>
<a name="ln2278">			error = copyout(&amp;ch, ireq-&gt;i_data, sizeof(ch));</a>
<a name="ln2279">			break;</a>
<a name="ln2280">		case IEEE80211_IOC_POWERSAVE:</a>
<a name="ln2281">			AN_LOCK(sc);</a>
<a name="ln2282">			sc-&gt;areq.an_type = AN_RID_ACTUALCFG;</a>
<a name="ln2283">			if (an_read_record(sc,</a>
<a name="ln2284">			    (struct an_ltv_gen *)&amp;sc-&gt;areq)) {</a>
<a name="ln2285">				error = EINVAL;</a>
<a name="ln2286">				AN_UNLOCK(sc);</a>
<a name="ln2287">				break;</a>
<a name="ln2288">			}</a>
<a name="ln2289">			AN_UNLOCK(sc);</a>
<a name="ln2290">			if (config-&gt;an_psave_mode == AN_PSAVE_NONE) {</a>
<a name="ln2291">				ireq-&gt;i_val = IEEE80211_POWERSAVE_OFF;</a>
<a name="ln2292">			} else if (config-&gt;an_psave_mode == AN_PSAVE_CAM) {</a>
<a name="ln2293">				ireq-&gt;i_val = IEEE80211_POWERSAVE_CAM;</a>
<a name="ln2294">			} else if (config-&gt;an_psave_mode == AN_PSAVE_PSP) {</a>
<a name="ln2295">				ireq-&gt;i_val = IEEE80211_POWERSAVE_PSP;</a>
<a name="ln2296">			} else if (config-&gt;an_psave_mode == AN_PSAVE_PSP_CAM) {</a>
<a name="ln2297">				ireq-&gt;i_val = IEEE80211_POWERSAVE_PSP_CAM;</a>
<a name="ln2298">			} else</a>
<a name="ln2299">				error = EINVAL;</a>
<a name="ln2300">			break;</a>
<a name="ln2301">		case IEEE80211_IOC_POWERSAVESLEEP:</a>
<a name="ln2302">			AN_LOCK(sc);</a>
<a name="ln2303">			sc-&gt;areq.an_type = AN_RID_ACTUALCFG;</a>
<a name="ln2304">			if (an_read_record(sc,</a>
<a name="ln2305">			    (struct an_ltv_gen *)&amp;sc-&gt;areq)) {</a>
<a name="ln2306">				error = EINVAL;</a>
<a name="ln2307">				AN_UNLOCK(sc);</a>
<a name="ln2308">				break;</a>
<a name="ln2309">			}</a>
<a name="ln2310">			AN_UNLOCK(sc);</a>
<a name="ln2311">			ireq-&gt;i_val = config-&gt;an_listen_interval;</a>
<a name="ln2312">			break;</a>
<a name="ln2313">		}</a>
<a name="ln2314">		break;</a>
<a name="ln2315">	case SIOCS80211:</a>
<a name="ln2316">		if ((error = priv_check(td, PRIV_NET80211_MANAGE)))</a>
<a name="ln2317">			goto out;</a>
<a name="ln2318">		AN_LOCK(sc);</a>
<a name="ln2319">		sc-&gt;areq.an_len = sizeof(sc-&gt;areq);</a>
<a name="ln2320">		/*</a>
<a name="ln2321">		 * We need a config structure for everything but the WEP</a>
<a name="ln2322">		 * key management and SSIDs so we get it now so avoid</a>
<a name="ln2323">		 * duplicating this code every time.</a>
<a name="ln2324">		 */</a>
<a name="ln2325">		if (ireq-&gt;i_type != IEEE80211_IOC_SSID &amp;&amp;</a>
<a name="ln2326">		    ireq-&gt;i_type != IEEE80211_IOC_WEPKEY &amp;&amp;</a>
<a name="ln2327">		    ireq-&gt;i_type != IEEE80211_IOC_WEPTXKEY) {</a>
<a name="ln2328">			sc-&gt;areq.an_type = AN_RID_GENCONFIG;</a>
<a name="ln2329">			if (an_read_record(sc,</a>
<a name="ln2330">			    (struct an_ltv_gen *)&amp;sc-&gt;areq)) {</a>
<a name="ln2331">				error = EINVAL;</a>
<a name="ln2332">				AN_UNLOCK(sc);</a>
<a name="ln2333">				break;</a>
<a name="ln2334">			}</a>
<a name="ln2335">		}</a>
<a name="ln2336">		switch (ireq-&gt;i_type) {</a>
<a name="ln2337">		case IEEE80211_IOC_SSID:</a>
<a name="ln2338">			sc-&gt;areq.an_len = sizeof(sc-&gt;areq);</a>
<a name="ln2339">			sc-&gt;areq.an_type = AN_RID_SSIDLIST;</a>
<a name="ln2340">			if (an_read_record(sc,</a>
<a name="ln2341">			    (struct an_ltv_gen *)&amp;sc-&gt;areq)) {</a>
<a name="ln2342">				error = EINVAL;</a>
<a name="ln2343">				AN_UNLOCK(sc);</a>
<a name="ln2344">				break;</a>
<a name="ln2345">			}</a>
<a name="ln2346">			if (ireq-&gt;i_len &gt; IEEE80211_NWID_LEN) {</a>
<a name="ln2347">				error = EINVAL;</a>
<a name="ln2348">				AN_UNLOCK(sc);</a>
<a name="ln2349">				break;</a>
<a name="ln2350">			}</a>
<a name="ln2351">			max = (sc-&gt;areq.an_len - 4)</a>
<a name="ln2352">			    / sizeof(struct an_ltv_ssid_entry);</a>
<a name="ln2353">			if ( max &gt; MAX_SSIDS ) {</a>
<a name="ln2354">				printf(&quot;To many SSIDs only using &quot;</a>
<a name="ln2355">				    &quot;%d of %d\n&quot;,</a>
<a name="ln2356">				    MAX_SSIDS, max);</a>
<a name="ln2357">				max = MAX_SSIDS;</a>
<a name="ln2358">			}</a>
<a name="ln2359">			if (ireq-&gt;i_val &gt; max) {</a>
<a name="ln2360">				error = EINVAL;</a>
<a name="ln2361">				AN_UNLOCK(sc);</a>
<a name="ln2362">				break;</a>
<a name="ln2363">			} else {</a>
<a name="ln2364">				error = copyin(ireq-&gt;i_data,</a>
<a name="ln2365">				    ssids-&gt;an_entry[ireq-&gt;i_val].an_ssid,</a>
<a name="ln2366">				    ireq-&gt;i_len);</a>
<a name="ln2367">				ssids-&gt;an_entry[ireq-&gt;i_val].an_len</a>
<a name="ln2368">				    = ireq-&gt;i_len;</a>
<a name="ln2369">				sc-&gt;areq.an_len = sizeof(sc-&gt;areq);</a>
<a name="ln2370">				sc-&gt;areq.an_type = AN_RID_SSIDLIST;</a>
<a name="ln2371">				an_setdef(sc, &amp;sc-&gt;areq);</a>
<a name="ln2372">				AN_UNLOCK(sc);</a>
<a name="ln2373">				break;</a>
<a name="ln2374">			}</a>
<a name="ln2375">			break;</a>
<a name="ln2376">		case IEEE80211_IOC_WEP:</a>
<a name="ln2377">			switch (ireq-&gt;i_val) {</a>
<a name="ln2378">			case IEEE80211_WEP_OFF:</a>
<a name="ln2379">				config-&gt;an_authtype &amp;=</a>
<a name="ln2380">				    ~(AN_AUTHTYPE_PRIVACY_IN_USE |</a>
<a name="ln2381">				    AN_AUTHTYPE_ALLOW_UNENCRYPTED);</a>
<a name="ln2382">				break;</a>
<a name="ln2383">			case IEEE80211_WEP_ON:</a>
<a name="ln2384">				config-&gt;an_authtype |=</a>
<a name="ln2385">				    AN_AUTHTYPE_PRIVACY_IN_USE;</a>
<a name="ln2386">				config-&gt;an_authtype &amp;=</a>
<a name="ln2387">				    ~AN_AUTHTYPE_ALLOW_UNENCRYPTED;</a>
<a name="ln2388">				break;</a>
<a name="ln2389">			case IEEE80211_WEP_MIXED:</a>
<a name="ln2390">				config-&gt;an_authtype |=</a>
<a name="ln2391">				    AN_AUTHTYPE_PRIVACY_IN_USE |</a>
<a name="ln2392">				    AN_AUTHTYPE_ALLOW_UNENCRYPTED;</a>
<a name="ln2393">				break;</a>
<a name="ln2394">			default:</a>
<a name="ln2395">				error = EINVAL;</a>
<a name="ln2396">				break;</a>
<a name="ln2397">			}</a>
<a name="ln2398">			if (error != EINVAL)</a>
<a name="ln2399">				an_setdef(sc, &amp;sc-&gt;areq);</a>
<a name="ln2400">			AN_UNLOCK(sc);</a>
<a name="ln2401">			break;</a>
<a name="ln2402">		case IEEE80211_IOC_WEPKEY:</a>
<a name="ln2403">			if (ireq-&gt;i_val &lt; 0 || ireq-&gt;i_val &gt; 8 ||</a>
<a name="ln2404">			    ireq-&gt;i_len &gt; 13) {</a>
<a name="ln2405">				error = EINVAL;</a>
<a name="ln2406">				AN_UNLOCK(sc);</a>
<a name="ln2407">				break;</a>
<a name="ln2408">			}</a>
<a name="ln2409">			error = copyin(ireq-&gt;i_data, tmpstr, 13);</a>
<a name="ln2410">			if (error != 0) {</a>
<a name="ln2411">				AN_UNLOCK(sc);</a>
<a name="ln2412">				break;</a>
<a name="ln2413">			}</a>
<a name="ln2414">			/*</a>
<a name="ln2415">			 * Map the 9th key into the home mode</a>
<a name="ln2416">			 * since that is how it is stored on</a>
<a name="ln2417">			 * the card</a>
<a name="ln2418">			 */</a>
<a name="ln2419">			bzero(&amp;sc-&gt;areq, sizeof(struct an_ltv_key));</a>
<a name="ln2420">			sc-&gt;areq.an_len = sizeof(struct an_ltv_key);</a>
<a name="ln2421">			key-&gt;mac[0] = 1;	/* The others are 0. */</a>
<a name="ln2422">			if (ireq-&gt;i_val &lt; 4) {</a>
<a name="ln2423">				sc-&gt;areq.an_type = AN_RID_WEP_TEMP;</a>
<a name="ln2424">				key-&gt;kindex = ireq-&gt;i_val;</a>
<a name="ln2425">			} else {</a>
<a name="ln2426">				sc-&gt;areq.an_type = AN_RID_WEP_PERM;</a>
<a name="ln2427">				key-&gt;kindex = ireq-&gt;i_val - 4;</a>
<a name="ln2428">			}</a>
<a name="ln2429">			key-&gt;klen = ireq-&gt;i_len;</a>
<a name="ln2430">			bcopy(tmpstr, key-&gt;key, key-&gt;klen);</a>
<a name="ln2431">			an_setdef(sc, &amp;sc-&gt;areq);</a>
<a name="ln2432">			AN_UNLOCK(sc);</a>
<a name="ln2433">			break;</a>
<a name="ln2434">		case IEEE80211_IOC_WEPTXKEY:</a>
<a name="ln2435">			if (ireq-&gt;i_val &lt; 0 || ireq-&gt;i_val &gt; 4) {</a>
<a name="ln2436">				error = EINVAL;</a>
<a name="ln2437">				AN_UNLOCK(sc);</a>
<a name="ln2438">				break;</a>
<a name="ln2439">			}</a>
<a name="ln2440"> </a>
<a name="ln2441">			/*</a>
<a name="ln2442">			 * Map the 5th key into the home mode</a>
<a name="ln2443">			 * since that is how it is stored on</a>
<a name="ln2444">			 * the card</a>
<a name="ln2445">			 */</a>
<a name="ln2446">			sc-&gt;areq.an_len  = sizeof(struct an_ltv_genconfig);</a>
<a name="ln2447">			sc-&gt;areq.an_type = AN_RID_ACTUALCFG;</a>
<a name="ln2448">			if (an_read_record(sc,</a>
<a name="ln2449">			    (struct an_ltv_gen *)&amp;sc-&gt;areq)) {</a>
<a name="ln2450">				error = EINVAL;</a>
<a name="ln2451">				AN_UNLOCK(sc);</a>
<a name="ln2452">				break;</a>
<a name="ln2453">			}</a>
<a name="ln2454">			if (ireq-&gt;i_val ==  4) {</a>
<a name="ln2455">				config-&gt;an_home_product |= AN_HOME_NETWORK;</a>
<a name="ln2456">				ireq-&gt;i_val = 0;</a>
<a name="ln2457">			} else {</a>
<a name="ln2458">				config-&gt;an_home_product &amp;= ~AN_HOME_NETWORK;</a>
<a name="ln2459">			}</a>
<a name="ln2460"> </a>
<a name="ln2461">			sc-&gt;an_config.an_home_product</a>
<a name="ln2462">				= config-&gt;an_home_product;</a>
<a name="ln2463"> </a>
<a name="ln2464">			/* update configuration */</a>
<a name="ln2465">			an_init_locked(sc);</a>
<a name="ln2466"> </a>
<a name="ln2467">			bzero(&amp;sc-&gt;areq, sizeof(struct an_ltv_key));</a>
<a name="ln2468">			sc-&gt;areq.an_len = sizeof(struct an_ltv_key);</a>
<a name="ln2469">			sc-&gt;areq.an_type = AN_RID_WEP_PERM;</a>
<a name="ln2470">			key-&gt;kindex = 0xffff;</a>
<a name="ln2471">			key-&gt;mac[0] = ireq-&gt;i_val;</a>
<a name="ln2472">			an_setdef(sc, &amp;sc-&gt;areq);</a>
<a name="ln2473">			AN_UNLOCK(sc);</a>
<a name="ln2474">			break;</a>
<a name="ln2475">		case IEEE80211_IOC_AUTHMODE:</a>
<a name="ln2476">			switch (ireq-&gt;i_val) {</a>
<a name="ln2477">			case IEEE80211_AUTH_NONE:</a>
<a name="ln2478">				config-&gt;an_authtype = AN_AUTHTYPE_NONE |</a>
<a name="ln2479">				    (config-&gt;an_authtype &amp; ~AN_AUTHTYPE_MASK);</a>
<a name="ln2480">				break;</a>
<a name="ln2481">			case IEEE80211_AUTH_OPEN:</a>
<a name="ln2482">				config-&gt;an_authtype = AN_AUTHTYPE_OPEN |</a>
<a name="ln2483">				    (config-&gt;an_authtype &amp; ~AN_AUTHTYPE_MASK);</a>
<a name="ln2484">				break;</a>
<a name="ln2485">			case IEEE80211_AUTH_SHARED:</a>
<a name="ln2486">				config-&gt;an_authtype = AN_AUTHTYPE_SHAREDKEY |</a>
<a name="ln2487">				    (config-&gt;an_authtype &amp; ~AN_AUTHTYPE_MASK);</a>
<a name="ln2488">				break;</a>
<a name="ln2489">			default:</a>
<a name="ln2490">				error = EINVAL;</a>
<a name="ln2491">			}</a>
<a name="ln2492">			if (error != EINVAL) {</a>
<a name="ln2493">				an_setdef(sc, &amp;sc-&gt;areq);</a>
<a name="ln2494">			}</a>
<a name="ln2495">			AN_UNLOCK(sc);</a>
<a name="ln2496">			break;</a>
<a name="ln2497">		case IEEE80211_IOC_STATIONNAME:</a>
<a name="ln2498">			if (ireq-&gt;i_len &gt; 16) {</a>
<a name="ln2499">				error = EINVAL;</a>
<a name="ln2500">				AN_UNLOCK(sc);</a>
<a name="ln2501">				break;</a>
<a name="ln2502">			}</a>
<a name="ln2503">			bzero(config-&gt;an_nodename, 16);</a>
<a name="ln2504">			error = copyin(ireq-&gt;i_data,</a>
<a name="ln2505">			    config-&gt;an_nodename, ireq-&gt;i_len);</a>
<a name="ln2506">			an_setdef(sc, &amp;sc-&gt;areq);</a>
<a name="ln2507">			AN_UNLOCK(sc);</a>
<a name="ln2508">			break;</a>
<a name="ln2509">		case IEEE80211_IOC_CHANNEL:</a>
<a name="ln2510">			/*</a>
<a name="ln2511">			 * The actual range is 1-14, but if you set it</a>
<a name="ln2512">			 * to 0 you get the default so we let that work</a>
<a name="ln2513">			 * too.</a>
<a name="ln2514">			 */</a>
<a name="ln2515">			if (ireq-&gt;i_val &lt; 0 || ireq-&gt;i_val &gt;14) {</a>
<a name="ln2516">				error = EINVAL;</a>
<a name="ln2517">				AN_UNLOCK(sc);</a>
<a name="ln2518">				break;</a>
<a name="ln2519">			}</a>
<a name="ln2520">			config-&gt;an_ds_channel = ireq-&gt;i_val;</a>
<a name="ln2521">			an_setdef(sc, &amp;sc-&gt;areq);</a>
<a name="ln2522">			AN_UNLOCK(sc);</a>
<a name="ln2523">			break;</a>
<a name="ln2524">		case IEEE80211_IOC_POWERSAVE:</a>
<a name="ln2525">			switch (ireq-&gt;i_val) {</a>
<a name="ln2526">			case IEEE80211_POWERSAVE_OFF:</a>
<a name="ln2527">				config-&gt;an_psave_mode = AN_PSAVE_NONE;</a>
<a name="ln2528">				break;</a>
<a name="ln2529">			case IEEE80211_POWERSAVE_CAM:</a>
<a name="ln2530">				config-&gt;an_psave_mode = AN_PSAVE_CAM;</a>
<a name="ln2531">				break;</a>
<a name="ln2532">			case IEEE80211_POWERSAVE_PSP:</a>
<a name="ln2533">				config-&gt;an_psave_mode = AN_PSAVE_PSP;</a>
<a name="ln2534">				break;</a>
<a name="ln2535">			case IEEE80211_POWERSAVE_PSP_CAM:</a>
<a name="ln2536">				config-&gt;an_psave_mode = AN_PSAVE_PSP_CAM;</a>
<a name="ln2537">				break;</a>
<a name="ln2538">			default:</a>
<a name="ln2539">				error = EINVAL;</a>
<a name="ln2540">				break;</a>
<a name="ln2541">			}</a>
<a name="ln2542">			an_setdef(sc, &amp;sc-&gt;areq);</a>
<a name="ln2543">			AN_UNLOCK(sc);</a>
<a name="ln2544">			break;</a>
<a name="ln2545">		case IEEE80211_IOC_POWERSAVESLEEP:</a>
<a name="ln2546">			config-&gt;an_listen_interval = ireq-&gt;i_val;</a>
<a name="ln2547">			an_setdef(sc, &amp;sc-&gt;areq);</a>
<a name="ln2548">			AN_UNLOCK(sc);</a>
<a name="ln2549">			break;</a>
<a name="ln2550">		default:</a>
<a name="ln2551">			AN_UNLOCK(sc);</a>
<a name="ln2552">			break;</a>
<a name="ln2553">		}</a>
<a name="ln2554"> </a>
<a name="ln2555">		/*</a>
<a name="ln2556">		if (!error) {</a>
<a name="ln2557">			AN_LOCK(sc);</a>
<a name="ln2558">			an_setdef(sc, &amp;sc-&gt;areq);</a>
<a name="ln2559">			AN_UNLOCK(sc);</a>
<a name="ln2560">		}</a>
<a name="ln2561">		*/</a>
<a name="ln2562">		break;</a>
<a name="ln2563">	default:</a>
<a name="ln2564">		error = ether_ioctl(ifp, command, data);</a>
<a name="ln2565">		break;</a>
<a name="ln2566">	}</a>
<a name="ln2567">out:</a>
<a name="ln2568"> </a>
<a name="ln2569">	return(error != 0);</a>
<a name="ln2570">}</a>
<a name="ln2571"> </a>
<a name="ln2572">static int</a>
<a name="ln2573">an_init_tx_ring(struct an_softc *sc)</a>
<a name="ln2574">{</a>
<a name="ln2575">	int			i;</a>
<a name="ln2576">	int			id;</a>
<a name="ln2577"> </a>
<a name="ln2578">	if (sc-&gt;an_gone)</a>
<a name="ln2579">		return (0);</a>
<a name="ln2580"> </a>
<a name="ln2581">	if (!sc-&gt;mpi350) {</a>
<a name="ln2582">		for (i = 0; i &lt; AN_TX_RING_CNT; i++) {</a>
<a name="ln2583">			if (an_alloc_nicmem(sc, 1518 +</a>
<a name="ln2584">			    0x44, &amp;id))</a>
<a name="ln2585">				return(ENOMEM);</a>
<a name="ln2586">			sc-&gt;an_rdata.an_tx_fids[i] = id;</a>
<a name="ln2587">			sc-&gt;an_rdata.an_tx_ring[i] = 0;</a>
<a name="ln2588">		}</a>
<a name="ln2589">	}</a>
<a name="ln2590"> </a>
<a name="ln2591">	sc-&gt;an_rdata.an_tx_prod = 0;</a>
<a name="ln2592">	sc-&gt;an_rdata.an_tx_cons = 0;</a>
<a name="ln2593">	sc-&gt;an_rdata.an_tx_empty = 1;</a>
<a name="ln2594"> </a>
<a name="ln2595">	return(0);</a>
<a name="ln2596">}</a>
<a name="ln2597"> </a>
<a name="ln2598">static void</a>
<a name="ln2599">an_init(void *xsc)</a>
<a name="ln2600">{</a>
<a name="ln2601">	struct an_softc		*sc = xsc;</a>
<a name="ln2602"> </a>
<a name="ln2603">	AN_LOCK(sc);</a>
<a name="ln2604">	an_init_locked(sc);</a>
<a name="ln2605">	AN_UNLOCK(sc);</a>
<a name="ln2606">}</a>
<a name="ln2607"> </a>
<a name="ln2608">static void</a>
<a name="ln2609">an_init_locked(struct an_softc *sc)</a>
<a name="ln2610">{</a>
<a name="ln2611">	struct ifnet *ifp;</a>
<a name="ln2612"> </a>
<a name="ln2613">	AN_LOCK_ASSERT(sc);</a>
<a name="ln2614">	ifp = sc-&gt;an_ifp;</a>
<a name="ln2615">	if (sc-&gt;an_gone)</a>
<a name="ln2616">		return;</a>
<a name="ln2617"> </a>
<a name="ln2618">	if (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING)</a>
<a name="ln2619">		an_stop(sc);</a>
<a name="ln2620"> </a>
<a name="ln2621">	sc-&gt;an_associated = 0;</a>
<a name="ln2622"> </a>
<a name="ln2623">	/* Allocate the TX buffers */</a>
<a name="ln2624">	if (an_init_tx_ring(sc)) {</a>
<a name="ln2625">		an_reset(sc);</a>
<a name="ln2626">		if (sc-&gt;mpi350)</a>
<a name="ln2627">			an_init_mpi350_desc(sc);</a>
<a name="ln2628">		if (an_init_tx_ring(sc)) {</a>
<a name="ln2629">			if_printf(ifp, &quot;tx buffer allocation failed\n&quot;);</a>
<a name="ln2630">			return;</a>
<a name="ln2631">		}</a>
<a name="ln2632">	}</a>
<a name="ln2633"> </a>
<a name="ln2634">	/* Set our MAC address. */</a>
<a name="ln2635">	bcopy((char *)IF_LLADDR(sc-&gt;an_ifp),</a>
<a name="ln2636">	    (char *)&amp;sc-&gt;an_config.an_macaddr, ETHER_ADDR_LEN);</a>
<a name="ln2637"> </a>
<a name="ln2638">	if (ifp-&gt;if_flags &amp; IFF_BROADCAST)</a>
<a name="ln2639">		sc-&gt;an_config.an_rxmode = AN_RXMODE_BC_ADDR;</a>
<a name="ln2640">	else</a>
<a name="ln2641">		sc-&gt;an_config.an_rxmode = AN_RXMODE_ADDR;</a>
<a name="ln2642"> </a>
<a name="ln2643">	if (ifp-&gt;if_flags &amp; IFF_MULTICAST)</a>
<a name="ln2644">		sc-&gt;an_config.an_rxmode = AN_RXMODE_BC_MC_ADDR;</a>
<a name="ln2645"> </a>
<a name="ln2646">	if (ifp-&gt;if_flags &amp; IFF_PROMISC) {</a>
<a name="ln2647">		if (sc-&gt;an_monitor &amp; AN_MONITOR) {</a>
<a name="ln2648">			if (sc-&gt;an_monitor &amp; AN_MONITOR_ANY_BSS) {</a>
<a name="ln2649">				sc-&gt;an_config.an_rxmode |=</a>
<a name="ln2650">				    AN_RXMODE_80211_MONITOR_ANYBSS |</a>
<a name="ln2651">				    AN_RXMODE_NO_8023_HEADER;</a>
<a name="ln2652">			} else {</a>
<a name="ln2653">				sc-&gt;an_config.an_rxmode |=</a>
<a name="ln2654">				    AN_RXMODE_80211_MONITOR_CURBSS |</a>
<a name="ln2655">				    AN_RXMODE_NO_8023_HEADER;</a>
<a name="ln2656">			}</a>
<a name="ln2657">		}</a>
<a name="ln2658">	}</a>
<a name="ln2659"> </a>
<a name="ln2660">#ifdef ANCACHE</a>
<a name="ln2661">	if (sc-&gt;an_have_rssimap)</a>
<a name="ln2662">		sc-&gt;an_config.an_rxmode |= AN_RXMODE_NORMALIZED_RSSI;</a>
<a name="ln2663">#endif</a>
<a name="ln2664"> </a>
<a name="ln2665">	/* Set the ssid list */</a>
<a name="ln2666">	sc-&gt;an_ssidlist.an_type = AN_RID_SSIDLIST;</a>
<a name="ln2667">	sc-&gt;an_ssidlist.an_len = sizeof(struct an_ltv_ssidlist_new);</a>
<a name="ln2668">	if (an_write_record(sc, (struct an_ltv_gen *)&amp;sc-&gt;an_ssidlist)) {</a>
<a name="ln2669">		if_printf(ifp, &quot;failed to set ssid list\n&quot;);</a>
<a name="ln2670">		return;</a>
<a name="ln2671">	}</a>
<a name="ln2672"> </a>
<a name="ln2673">	/* Set the AP list */</a>
<a name="ln2674">	sc-&gt;an_aplist.an_type = AN_RID_APLIST;</a>
<a name="ln2675">	sc-&gt;an_aplist.an_len = sizeof(struct an_ltv_aplist);</a>
<a name="ln2676">	if (an_write_record(sc, (struct an_ltv_gen *)&amp;sc-&gt;an_aplist)) {</a>
<a name="ln2677">		if_printf(ifp, &quot;failed to set AP list\n&quot;);</a>
<a name="ln2678">		return;</a>
<a name="ln2679">	}</a>
<a name="ln2680"> </a>
<a name="ln2681">	/* Set the configuration in the NIC */</a>
<a name="ln2682">	sc-&gt;an_config.an_len = sizeof(struct an_ltv_genconfig);</a>
<a name="ln2683">	sc-&gt;an_config.an_type = AN_RID_GENCONFIG;</a>
<a name="ln2684">	if (an_write_record(sc, (struct an_ltv_gen *)&amp;sc-&gt;an_config)) {</a>
<a name="ln2685">		if_printf(ifp, &quot;failed to set configuration\n&quot;);</a>
<a name="ln2686">		return;</a>
<a name="ln2687">	}</a>
<a name="ln2688"> </a>
<a name="ln2689">	/* Enable the MAC */</a>
<a name="ln2690">	if (an_cmd(sc, AN_CMD_ENABLE, 0)) {</a>
<a name="ln2691">		if_printf(ifp, &quot;failed to enable MAC\n&quot;);</a>
<a name="ln2692">		return;</a>
<a name="ln2693">	}</a>
<a name="ln2694"> </a>
<a name="ln2695">	if (ifp-&gt;if_flags &amp; IFF_PROMISC)</a>
<a name="ln2696">		an_cmd(sc, AN_CMD_SET_MODE, 0xffff);</a>
<a name="ln2697"> </a>
<a name="ln2698">	/* enable interrupts */</a>
<a name="ln2699">	CSR_WRITE_2(sc, AN_INT_EN(sc-&gt;mpi350), AN_INTRS(sc-&gt;mpi350));</a>
<a name="ln2700"> </a>
<a name="ln2701">	ifp-&gt;if_drv_flags |= IFF_DRV_RUNNING;</a>
<a name="ln2702">	ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_OACTIVE;</a>
<a name="ln2703"> </a>
<a name="ln2704">	callout_reset(&amp;sc-&gt;an_stat_ch, hz, an_stats_update, sc);</a>
<a name="ln2705"> </a>
<a name="ln2706">	return;</a>
<a name="ln2707">}</a>
<a name="ln2708"> </a>
<a name="ln2709">static void</a>
<a name="ln2710">an_start(struct ifnet *ifp)</a>
<a name="ln2711">{</a>
<a name="ln2712">	struct an_softc		*sc;</a>
<a name="ln2713"> </a>
<a name="ln2714">	sc = ifp-&gt;if_softc;</a>
<a name="ln2715">	AN_LOCK(sc);</a>
<a name="ln2716">	an_start_locked(ifp);</a>
<a name="ln2717">	AN_UNLOCK(sc);</a>
<a name="ln2718">}</a>
<a name="ln2719"> </a>
<a name="ln2720">static void</a>
<a name="ln2721">an_start_locked(struct ifnet *ifp)</a>
<a name="ln2722">{</a>
<a name="ln2723">	struct an_softc		*sc;</a>
<a name="ln2724">	struct mbuf		*m0 = NULL;</a>
<a name="ln2725">	struct an_txframe_802_3	tx_frame_802_3;</a>
<a name="ln2726">	struct ether_header	*eh;</a>
<a name="ln2727">	int			id, idx, i;</a>
<a name="ln2728">	unsigned char		txcontrol;</a>
<a name="ln2729">	struct an_card_tx_desc an_tx_desc;</a>
<a name="ln2730">	u_int8_t		*buf;</a>
<a name="ln2731"> </a>
<a name="ln2732">	sc = ifp-&gt;if_softc;</a>
<a name="ln2733"> </a>
<a name="ln2734">	AN_LOCK_ASSERT(sc);</a>
<a name="ln2735">	if (sc-&gt;an_gone)</a>
<a name="ln2736">		return;</a>
<a name="ln2737"> </a>
<a name="ln2738">	if (ifp-&gt;if_drv_flags &amp; IFF_DRV_OACTIVE)</a>
<a name="ln2739">		return;</a>
<a name="ln2740"> </a>
<a name="ln2741">	if (!sc-&gt;an_associated)</a>
<a name="ln2742">		return;</a>
<a name="ln2743"> </a>
<a name="ln2744">	/* We can't send in monitor mode so toss any attempts. */</a>
<a name="ln2745">	if (sc-&gt;an_monitor &amp;&amp; (ifp-&gt;if_flags &amp; IFF_PROMISC)) {</a>
<a name="ln2746">		for (;;) {</a>
<a name="ln2747">			IFQ_DRV_DEQUEUE(&amp;ifp-&gt;if_snd, m0);</a>
<a name="ln2748">			if (m0 == NULL)</a>
<a name="ln2749">				break;</a>
<a name="ln2750">			m_freem(m0);</a>
<a name="ln2751">		}</a>
<a name="ln2752">		return;</a>
<a name="ln2753">	}</a>
<a name="ln2754"> </a>
<a name="ln2755">	idx = sc-&gt;an_rdata.an_tx_prod;</a>
<a name="ln2756"> </a>
<a name="ln2757">	if (!sc-&gt;mpi350) {</a>
<a name="ln2758">		bzero((char *)&amp;tx_frame_802_3, sizeof(tx_frame_802_3));</a>
<a name="ln2759"> </a>
<a name="ln2760">		while (sc-&gt;an_rdata.an_tx_ring[idx] == 0) {</a>
<a name="ln2761">			IFQ_DRV_DEQUEUE(&amp;ifp-&gt;if_snd, m0);</a>
<a name="ln2762">			if (m0 == NULL)</a>
<a name="ln2763">				break;</a>
<a name="ln2764"> </a>
<a name="ln2765">			id = sc-&gt;an_rdata.an_tx_fids[idx];</a>
<a name="ln2766">			eh = mtod(m0, struct ether_header *);</a>
<a name="ln2767"> </a>
<a name="ln2768">			bcopy((char *)&amp;eh-&gt;ether_dhost,</a>
<a name="ln2769">			      (char *)&amp;tx_frame_802_3.an_tx_dst_addr,</a>
<a name="ln2770">			      ETHER_ADDR_LEN);</a>
<a name="ln2771">			bcopy((char *)&amp;eh-&gt;ether_shost,</a>
<a name="ln2772">			      (char *)&amp;tx_frame_802_3.an_tx_src_addr,</a>
<a name="ln2773">			      ETHER_ADDR_LEN);</a>
<a name="ln2774"> </a>
<a name="ln2775">			/* minus src/dest mac &amp; type */</a>
<a name="ln2776">			tx_frame_802_3.an_tx_802_3_payload_len =</a>
<a name="ln2777">				m0-&gt;m_pkthdr.len - 12;</a>
<a name="ln2778"> </a>
<a name="ln2779">			m_copydata(m0, sizeof(struct ether_header) - 2 ,</a>
<a name="ln2780">				   tx_frame_802_3.an_tx_802_3_payload_len,</a>
<a name="ln2781">				   (caddr_t)&amp;sc-&gt;an_txbuf);</a>
<a name="ln2782"> </a>
<a name="ln2783">			txcontrol = AN_TXCTL_8023 | AN_TXCTL_HW(sc-&gt;mpi350);</a>
<a name="ln2784">			/* write the txcontrol only */</a>
<a name="ln2785">			an_write_data(sc, id, 0x08, (caddr_t)&amp;txcontrol,</a>
<a name="ln2786">				      sizeof(txcontrol));</a>
<a name="ln2787"> </a>
<a name="ln2788">			/* 802_3 header */</a>
<a name="ln2789">			an_write_data(sc, id, 0x34, (caddr_t)&amp;tx_frame_802_3,</a>
<a name="ln2790">				      sizeof(struct an_txframe_802_3));</a>
<a name="ln2791"> </a>
<a name="ln2792">			/* in mbuf header type is just before payload */</a>
<a name="ln2793">			an_write_data(sc, id, 0x44, (caddr_t)&amp;sc-&gt;an_txbuf,</a>
<a name="ln2794">				      tx_frame_802_3.an_tx_802_3_payload_len);</a>
<a name="ln2795"> </a>
<a name="ln2796">			/*</a>
<a name="ln2797">			 * If there's a BPF listner, bounce a copy of</a>
<a name="ln2798">			 * this frame to him.</a>
<a name="ln2799">			 */</a>
<a name="ln2800">			BPF_MTAP(ifp, m0);</a>
<a name="ln2801"> </a>
<a name="ln2802">			m_freem(m0);</a>
<a name="ln2803">			m0 = NULL;</a>
<a name="ln2804"> </a>
<a name="ln2805">			sc-&gt;an_rdata.an_tx_ring[idx] = id;</a>
<a name="ln2806">			if (an_cmd(sc, AN_CMD_TX, id))</a>
<a name="ln2807">				if_printf(ifp, &quot;xmit failed\n&quot;);</a>
<a name="ln2808"> </a>
<a name="ln2809">			AN_INC(idx, AN_TX_RING_CNT);</a>
<a name="ln2810"> </a>
<a name="ln2811">			/*</a>
<a name="ln2812">			 * Set a timeout in case the chip goes out to lunch.</a>
<a name="ln2813">			 */</a>
<a name="ln2814">			sc-&gt;an_timer = 5;</a>
<a name="ln2815">		}</a>
<a name="ln2816">	} else { /* MPI-350 */</a>
<a name="ln2817">		/* Disable interrupts. */</a>
<a name="ln2818">		CSR_WRITE_2(sc, AN_INT_EN(sc-&gt;mpi350), 0);</a>
<a name="ln2819"> </a>
<a name="ln2820">		while (sc-&gt;an_rdata.an_tx_empty ||</a>
<a name="ln2821">		    idx != sc-&gt;an_rdata.an_tx_cons) {</a>
<a name="ln2822">			IFQ_DRV_DEQUEUE(&amp;ifp-&gt;if_snd, m0);</a>
<a name="ln2823">			if (m0 == NULL) {</a>
<a name="ln2824">				break;</a>
<a name="ln2825">			}</a>
<a name="ln2826">			buf = sc-&gt;an_tx_buffer[idx].an_dma_vaddr;</a>
<a name="ln2827"> </a>
<a name="ln2828">			eh = mtod(m0, struct ether_header *);</a>
<a name="ln2829"> </a>
<a name="ln2830">			/* DJA optimize this to limit bcopy */</a>
<a name="ln2831">			bcopy((char *)&amp;eh-&gt;ether_dhost,</a>
<a name="ln2832">			      (char *)&amp;tx_frame_802_3.an_tx_dst_addr,</a>
<a name="ln2833">			      ETHER_ADDR_LEN);</a>
<a name="ln2834">			bcopy((char *)&amp;eh-&gt;ether_shost,</a>
<a name="ln2835">			      (char *)&amp;tx_frame_802_3.an_tx_src_addr,</a>
<a name="ln2836">			      ETHER_ADDR_LEN);</a>
<a name="ln2837"> </a>
<a name="ln2838">			/* minus src/dest mac &amp; type */</a>
<a name="ln2839">			tx_frame_802_3.an_tx_802_3_payload_len =</a>
<a name="ln2840">				m0-&gt;m_pkthdr.len - 12;</a>
<a name="ln2841"> </a>
<a name="ln2842">			m_copydata(m0, sizeof(struct ether_header) - 2 ,</a>
<a name="ln2843">				   tx_frame_802_3.an_tx_802_3_payload_len,</a>
<a name="ln2844">				   (caddr_t)&amp;sc-&gt;an_txbuf);</a>
<a name="ln2845"> </a>
<a name="ln2846">			txcontrol = AN_TXCTL_8023 | AN_TXCTL_HW(sc-&gt;mpi350);</a>
<a name="ln2847">			/* write the txcontrol only */</a>
<a name="ln2848">			bcopy((caddr_t)&amp;txcontrol, &amp;buf[0x08],</a>
<a name="ln2849">			      sizeof(txcontrol));</a>
<a name="ln2850"> </a>
<a name="ln2851">			/* 802_3 header */</a>
<a name="ln2852">			bcopy((caddr_t)&amp;tx_frame_802_3, &amp;buf[0x34],</a>
<a name="ln2853">			      sizeof(struct an_txframe_802_3));</a>
<a name="ln2854"> </a>
<a name="ln2855">			/* in mbuf header type is just before payload */</a>
<a name="ln2856">			bcopy((caddr_t)&amp;sc-&gt;an_txbuf, &amp;buf[0x44],</a>
<a name="ln2857">			      tx_frame_802_3.an_tx_802_3_payload_len);</a>
<a name="ln2858"> </a>
<a name="ln2859"> </a>
<a name="ln2860">			bzero(&amp;an_tx_desc, sizeof(an_tx_desc));</a>
<a name="ln2861">			an_tx_desc.an_offset = 0;</a>
<a name="ln2862">			an_tx_desc.an_eoc = 1;</a>
<a name="ln2863">			an_tx_desc.an_valid = 1;</a>
<a name="ln2864">			an_tx_desc.an_len =  0x44 +</a>
<a name="ln2865">			    tx_frame_802_3.an_tx_802_3_payload_len;</a>
<a name="ln2866">			an_tx_desc.an_phys</a>
<a name="ln2867">			    = sc-&gt;an_tx_buffer[idx].an_dma_paddr;</a>
<a name="ln2868">			for (i = sizeof(an_tx_desc) / 4 - 1; i &gt;= 0; i--) {</a>
<a name="ln2869">				CSR_MEM_AUX_WRITE_4(sc, AN_TX_DESC_OFFSET</a>
<a name="ln2870">				    /* zero for now */</a>
<a name="ln2871">				    + (0 * sizeof(an_tx_desc))</a>
<a name="ln2872">				    + (i * 4),</a>
<a name="ln2873">				    ((u_int32_t *)(void *)&amp;an_tx_desc)[i]);</a>
<a name="ln2874">			}</a>
<a name="ln2875"> </a>
<a name="ln2876">			/*</a>
<a name="ln2877">			 * If there's a BPF listner, bounce a copy of</a>
<a name="ln2878">			 * this frame to him.</a>
<a name="ln2879">			 */</a>
<a name="ln2880">			BPF_MTAP(ifp, m0);</a>
<a name="ln2881"> </a>
<a name="ln2882">			m_freem(m0);</a>
<a name="ln2883">			m0 = NULL;</a>
<a name="ln2884">			AN_INC(idx, AN_MAX_TX_DESC);</a>
<a name="ln2885">			sc-&gt;an_rdata.an_tx_empty = 0;</a>
<a name="ln2886">			CSR_WRITE_2(sc, AN_EVENT_ACK(sc-&gt;mpi350), AN_EV_ALLOC);</a>
<a name="ln2887"> </a>
<a name="ln2888">			/*</a>
<a name="ln2889">			 * Set a timeout in case the chip goes out to lunch.</a>
<a name="ln2890">			 */</a>
<a name="ln2891">			sc-&gt;an_timer = 5;</a>
<a name="ln2892">		}</a>
<a name="ln2893"> </a>
<a name="ln2894">		/* Re-enable interrupts. */</a>
<a name="ln2895">		CSR_WRITE_2(sc, AN_INT_EN(sc-&gt;mpi350), AN_INTRS(sc-&gt;mpi350));</a>
<a name="ln2896">	}</a>
<a name="ln2897"> </a>
<a name="ln2898">	if (m0 != NULL)</a>
<a name="ln2899">		ifp-&gt;if_drv_flags |= IFF_DRV_OACTIVE;</a>
<a name="ln2900"> </a>
<a name="ln2901">	sc-&gt;an_rdata.an_tx_prod = idx;</a>
<a name="ln2902"> </a>
<a name="ln2903">	return;</a>
<a name="ln2904">}</a>
<a name="ln2905"> </a>
<a name="ln2906">void</a>
<a name="ln2907">an_stop(struct an_softc *sc)</a>
<a name="ln2908">{</a>
<a name="ln2909">	struct ifnet		*ifp;</a>
<a name="ln2910">	int			i;</a>
<a name="ln2911"> </a>
<a name="ln2912">	AN_LOCK_ASSERT(sc);</a>
<a name="ln2913"> </a>
<a name="ln2914">	if (sc-&gt;an_gone)</a>
<a name="ln2915">		return;</a>
<a name="ln2916"> </a>
<a name="ln2917">	ifp = sc-&gt;an_ifp;</a>
<a name="ln2918"> </a>
<a name="ln2919">	an_cmd(sc, AN_CMD_FORCE_SYNCLOSS, 0);</a>
<a name="ln2920">	CSR_WRITE_2(sc, AN_INT_EN(sc-&gt;mpi350), 0);</a>
<a name="ln2921">	an_cmd(sc, AN_CMD_DISABLE, 0);</a>
<a name="ln2922"> </a>
<a name="ln2923">	for (i = 0; i &lt; AN_TX_RING_CNT; i++)</a>
<a name="ln2924">		an_cmd(sc, AN_CMD_DEALLOC_MEM, sc-&gt;an_rdata.an_tx_fids[i]);</a>
<a name="ln2925"> </a>
<a name="ln2926">	callout_stop(&amp;sc-&gt;an_stat_ch);</a>
<a name="ln2927"> </a>
<a name="ln2928">	ifp-&gt;if_drv_flags &amp;= ~(IFF_DRV_RUNNING|IFF_DRV_OACTIVE);</a>
<a name="ln2929"> </a>
<a name="ln2930">	if (sc-&gt;an_flash_buffer) {</a>
<a name="ln2931">		free(sc-&gt;an_flash_buffer, M_DEVBUF);</a>
<a name="ln2932">		sc-&gt;an_flash_buffer = NULL;</a>
<a name="ln2933">	}</a>
<a name="ln2934">}</a>
<a name="ln2935"> </a>
<a name="ln2936">static void</a>
<a name="ln2937">an_watchdog(struct an_softc *sc)</a>
<a name="ln2938">{</a>
<a name="ln2939">	struct ifnet *ifp;</a>
<a name="ln2940"> </a>
<a name="ln2941">	AN_LOCK_ASSERT(sc);</a>
<a name="ln2942"> </a>
<a name="ln2943">	if (sc-&gt;an_gone)</a>
<a name="ln2944">		return;</a>
<a name="ln2945"> </a>
<a name="ln2946">	ifp = sc-&gt;an_ifp;</a>
<a name="ln2947">	if_printf(ifp, &quot;device timeout\n&quot;);</a>
<a name="ln2948"> </a>
<a name="ln2949">	an_reset(sc);</a>
<a name="ln2950">	if (sc-&gt;mpi350)</a>
<a name="ln2951">		an_init_mpi350_desc(sc);</a>
<a name="ln2952">	an_init_locked(sc);</a>
<a name="ln2953"> </a>
<a name="ln2954">	if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln2955">}</a>
<a name="ln2956"> </a>
<a name="ln2957">int</a>
<a name="ln2958">an_shutdown(device_t dev)</a>
<a name="ln2959">{</a>
<a name="ln2960">	struct an_softc		*sc;</a>
<a name="ln2961"> </a>
<a name="ln2962">	sc = device_get_softc(dev);</a>
<a name="ln2963">	AN_LOCK(sc);</a>
<a name="ln2964">	an_stop(sc);</a>
<a name="ln2965">	sc-&gt;an_gone = 1;</a>
<a name="ln2966">	AN_UNLOCK(sc);</a>
<a name="ln2967"> </a>
<a name="ln2968">	return (0);</a>
<a name="ln2969">}</a>
<a name="ln2970"> </a>
<a name="ln2971">void</a>
<a name="ln2972">an_resume(device_t dev)</a>
<a name="ln2973">{</a>
<a name="ln2974">	struct an_softc		*sc;</a>
<a name="ln2975">	struct ifnet		*ifp;</a>
<a name="ln2976">	int			i;</a>
<a name="ln2977"> </a>
<a name="ln2978">	sc = device_get_softc(dev);</a>
<a name="ln2979">	AN_LOCK(sc);</a>
<a name="ln2980">	ifp = sc-&gt;an_ifp;</a>
<a name="ln2981"> </a>
<a name="ln2982">	sc-&gt;an_gone = 0;</a>
<a name="ln2983">	an_reset(sc);</a>
<a name="ln2984">	if (sc-&gt;mpi350)</a>
<a name="ln2985">		an_init_mpi350_desc(sc);</a>
<a name="ln2986">	an_init_locked(sc);</a>
<a name="ln2987"> </a>
<a name="ln2988">	/* Recovery temporary keys */</a>
<a name="ln2989">	for (i = 0; i &lt; 4; i++) {</a>
<a name="ln2990">		sc-&gt;areq.an_type = AN_RID_WEP_TEMP;</a>
<a name="ln2991">		sc-&gt;areq.an_len = sizeof(struct an_ltv_key);</a>
<a name="ln2992">		bcopy(&amp;sc-&gt;an_temp_keys[i],</a>
<a name="ln2993">		    &amp;sc-&gt;areq, sizeof(struct an_ltv_key));</a>
<a name="ln2994">		an_setdef(sc, &amp;sc-&gt;areq);</a>
<a name="ln2995">	}</a>
<a name="ln2996"> </a>
<a name="ln2997">	if (ifp-&gt;if_flags &amp; IFF_UP)</a>
<a name="ln2998">		an_start_locked(ifp);</a>
<a name="ln2999">	AN_UNLOCK(sc);</a>
<a name="ln3000"> </a>
<a name="ln3001">	return;</a>
<a name="ln3002">}</a>
<a name="ln3003"> </a>
<a name="ln3004">#ifdef ANCACHE</a>
<a name="ln3005">/* Aironet signal strength cache code.</a>
<a name="ln3006"> * store signal/noise/quality on per MAC src basis in</a>
<a name="ln3007"> * a small fixed cache.  The cache wraps if &gt; MAX slots</a>
<a name="ln3008"> * used.  The cache may be zeroed out to start over.</a>
<a name="ln3009"> * Two simple filters exist to reduce computation:</a>
<a name="ln3010"> * 1. ip only (literally 0x800, ETHERTYPE_IP) which may be used</a>
<a name="ln3011"> * to ignore some packets.  It defaults to ip only.</a>
<a name="ln3012"> * it could be used to focus on broadcast, non-IP 802.11 beacons.</a>
<a name="ln3013"> * 2. multicast/broadcast only.  This may be used to</a>
<a name="ln3014"> * ignore unicast packets and only cache signal strength</a>
<a name="ln3015"> * for multicast/broadcast packets (beacons); e.g., Mobile-IP</a>
<a name="ln3016"> * beacons and not unicast traffic.</a>
<a name="ln3017"> *</a>
<a name="ln3018"> * The cache stores (MAC src(index), IP src (major clue), signal,</a>
<a name="ln3019"> *	quality, noise)</a>
<a name="ln3020"> *</a>
<a name="ln3021"> * No apologies for storing IP src here.  It's easy and saves much</a>
<a name="ln3022"> * trouble elsewhere.  The cache is assumed to be INET dependent,</a>
<a name="ln3023"> * although it need not be.</a>
<a name="ln3024"> *</a>
<a name="ln3025"> * Note: the Aironet only has a single byte of signal strength value</a>
<a name="ln3026"> * in the rx frame header, and it's not scaled to anything sensible.</a>
<a name="ln3027"> * This is kind of lame, but it's all we've got.</a>
<a name="ln3028"> */</a>
<a name="ln3029"> </a>
<a name="ln3030">#ifdef documentation</a>
<a name="ln3031"> </a>
<a name="ln3032">int an_sigitems;				/* number of cached entries */</a>
<a name="ln3033">struct an_sigcache an_sigcache[MAXANCACHE];	/* array of cache entries */</a>
<a name="ln3034">int an_nextitem;				/* index/# of entries */</a>
<a name="ln3035"> </a>
<a name="ln3036"> </a>
<a name="ln3037">#endif</a>
<a name="ln3038"> </a>
<a name="ln3039">/* control variables for cache filtering.  Basic idea is</a>
<a name="ln3040"> * to reduce cost (e.g., to only Mobile-IP agent beacons</a>
<a name="ln3041"> * which are broadcast or multicast).  Still you might</a>
<a name="ln3042"> * want to measure signal strength anth unicast ping packets</a>
<a name="ln3043"> * on a pt. to pt. ant. setup.</a>
<a name="ln3044"> */</a>
<a name="ln3045">/* set true if you want to limit cache items to broadcast/mcast</a>
<a name="ln3046"> * only packets (not unicast).  Useful for mobile-ip beacons which</a>
<a name="ln3047"> * are broadcast/multicast at network layer.  Default is all packets</a>
<a name="ln3048"> * so ping/unicast anll work say anth pt. to pt. antennae setup.</a>
<a name="ln3049"> */</a>
<a name="ln3050">static int an_cache_mcastonly = 0;</a>
<a name="ln3051">SYSCTL_INT(_hw_an, OID_AUTO, an_cache_mcastonly, CTLFLAG_RW,</a>
<a name="ln3052">	&amp;an_cache_mcastonly, 0, &quot;&quot;);</a>
<a name="ln3053"> </a>
<a name="ln3054">/* set true if you want to limit cache items to IP packets only</a>
<a name="ln3055">*/</a>
<a name="ln3056">static int an_cache_iponly = 1;</a>
<a name="ln3057">SYSCTL_INT(_hw_an, OID_AUTO, an_cache_iponly, CTLFLAG_RW,</a>
<a name="ln3058">	&amp;an_cache_iponly, 0, &quot;&quot;);</a>
<a name="ln3059"> </a>
<a name="ln3060">/*</a>
<a name="ln3061"> * an_cache_store, per rx packet store signal</a>
<a name="ln3062"> * strength in MAC (src) indexed cache.</a>
<a name="ln3063"> */</a>
<a name="ln3064">static void</a>
<a name="ln3065">an_cache_store(struct an_softc *sc, struct ether_header *eh, struct mbuf *m,</a>
<a name="ln3066">    u_int8_t rx_rssi, u_int8_t rx_quality)</a>
<a name="ln3067">{</a>
<a name="ln3068">	struct ip *ip = NULL;</a>
<a name="ln3069">	int i;</a>
<a name="ln3070">	static int cache_slot = 0; 	/* use this cache entry */</a>
<a name="ln3071">	static int wrapindex = 0;	/* next &quot;free&quot; cache entry */</a>
<a name="ln3072">	int type_ipv4 = 0;</a>
<a name="ln3073"> </a>
<a name="ln3074">	/* filters:</a>
<a name="ln3075">	 * 1. ip only</a>
<a name="ln3076">	 * 2. configurable filter to throw out unicast packets,</a>
<a name="ln3077">	 * keep multicast only.</a>
<a name="ln3078">	 */</a>
<a name="ln3079"> </a>
<a name="ln3080">	if ((ntohs(eh-&gt;ether_type) == ETHERTYPE_IP)) {</a>
<a name="ln3081">		type_ipv4 = 1;</a>
<a name="ln3082">	}</a>
<a name="ln3083"> </a>
<a name="ln3084">	/* filter for ip packets only</a>
<a name="ln3085">	*/</a>
<a name="ln3086">	if ( an_cache_iponly &amp;&amp; !type_ipv4) {</a>
<a name="ln3087">		return;</a>
<a name="ln3088">	}</a>
<a name="ln3089"> </a>
<a name="ln3090">	/* filter for broadcast/multicast only</a>
<a name="ln3091">	 */</a>
<a name="ln3092">	if (an_cache_mcastonly &amp;&amp; ((eh-&gt;ether_dhost[0] &amp; 1) == 0)) {</a>
<a name="ln3093">		return;</a>
<a name="ln3094">	}</a>
<a name="ln3095"> </a>
<a name="ln3096">#ifdef SIGDEBUG</a>
<a name="ln3097">	if_printf(sc-&gt;an_ifp, &quot;q value %x (MSB=0x%x, LSB=0x%x) \n&quot;,</a>
<a name="ln3098">		rx_rssi &amp; 0xffff, rx_rssi &gt;&gt; 8, rx_rssi &amp; 0xff);</a>
<a name="ln3099">#endif</a>
<a name="ln3100"> </a>
<a name="ln3101">	/* find the ip header.  we want to store the ip_src</a>
<a name="ln3102">	 * address.</a>
<a name="ln3103">	 */</a>
<a name="ln3104">	if (type_ipv4) {</a>
<a name="ln3105">		ip = mtod(m, struct ip *);</a>
<a name="ln3106">	}</a>
<a name="ln3107"> </a>
<a name="ln3108">	/* do a linear search for a matching MAC address</a>
<a name="ln3109">	 * in the cache table</a>
<a name="ln3110">	 * . MAC address is 6 bytes,</a>
<a name="ln3111">	 * . var w_nextitem holds total number of entries already cached</a>
<a name="ln3112">	 */</a>
<a name="ln3113">	for (i = 0; i &lt; sc-&gt;an_nextitem; i++) {</a>
<a name="ln3114">		if (! bcmp(eh-&gt;ether_shost , sc-&gt;an_sigcache[i].macsrc,  6 )) {</a>
<a name="ln3115">			/* Match!,</a>
<a name="ln3116">			 * so we already have this entry,</a>
<a name="ln3117">			 * update the data</a>
<a name="ln3118">			 */</a>
<a name="ln3119">			break;</a>
<a name="ln3120">		}</a>
<a name="ln3121">	}</a>
<a name="ln3122"> </a>
<a name="ln3123">	/* did we find a matching mac address?</a>
<a name="ln3124">	 * if yes, then overwrite a previously existing cache entry</a>
<a name="ln3125">	 */</a>
<a name="ln3126">	if (i &lt; sc-&gt;an_nextitem )   {</a>
<a name="ln3127">		cache_slot = i;</a>
<a name="ln3128">	}</a>
<a name="ln3129">	/* else, have a new address entry,so</a>
<a name="ln3130">	 * add this new entry,</a>
<a name="ln3131">	 * if table full, then we need to replace LRU entry</a>
<a name="ln3132">	 */</a>
<a name="ln3133">	else    {</a>
<a name="ln3134"> </a>
<a name="ln3135">		/* check for space in cache table</a>
<a name="ln3136">		 * note: an_nextitem also holds number of entries</a>
<a name="ln3137">		 * added in the cache table</a>
<a name="ln3138">		 */</a>
<a name="ln3139">		if ( sc-&gt;an_nextitem &lt; MAXANCACHE ) {</a>
<a name="ln3140">			cache_slot = sc-&gt;an_nextitem;</a>
<a name="ln3141">			sc-&gt;an_nextitem++;</a>
<a name="ln3142">			sc-&gt;an_sigitems = sc-&gt;an_nextitem;</a>
<a name="ln3143">		}</a>
<a name="ln3144">		/* no space found, so simply wrap anth wrap index</a>
<a name="ln3145">		 * and &quot;zap&quot; the next entry</a>
<a name="ln3146">		 */</a>
<a name="ln3147">		else {</a>
<a name="ln3148">			if (wrapindex == MAXANCACHE) {</a>
<a name="ln3149">				wrapindex = 0;</a>
<a name="ln3150">			}</a>
<a name="ln3151">			cache_slot = wrapindex++;</a>
<a name="ln3152">		}</a>
<a name="ln3153">	}</a>
<a name="ln3154"> </a>
<a name="ln3155">	/* invariant: cache_slot now points at some slot</a>
<a name="ln3156">	 * in cache.</a>
<a name="ln3157">	 */</a>
<a name="ln3158">	if (cache_slot &lt; 0 || cache_slot &gt;= MAXANCACHE) {</a>
<a name="ln3159">		log(LOG_ERR, &quot;an_cache_store, bad index: %d of &quot;</a>
<a name="ln3160">		    &quot;[0..%d], gross cache error\n&quot;,</a>
<a name="ln3161">		    cache_slot, MAXANCACHE);</a>
<a name="ln3162">		return;</a>
<a name="ln3163">	}</a>
<a name="ln3164"> </a>
<a name="ln3165">	/*  store items in cache</a>
<a name="ln3166">	 *  .ip source address</a>
<a name="ln3167">	 *  .mac src</a>
<a name="ln3168">	 *  .signal, etc.</a>
<a name="ln3169">	 */</a>
<a name="ln3170">	if (type_ipv4) {</a>
<a name="ln3171">		sc-&gt;an_sigcache[cache_slot].ipsrc = ip-&gt;ip_src.s_addr;</a>
<a name="ln3172">	}</a>
<a name="ln3173">	bcopy( eh-&gt;ether_shost, sc-&gt;an_sigcache[cache_slot].macsrc,  6);</a>
<a name="ln3174"> </a>
<a name="ln3175"> </a>
<a name="ln3176">	switch (an_cache_mode) {</a>
<a name="ln3177">	case DBM:</a>
<a name="ln3178">		if (sc-&gt;an_have_rssimap) {</a>
<a name="ln3179">			sc-&gt;an_sigcache[cache_slot].signal =</a>
<a name="ln3180">				- sc-&gt;an_rssimap.an_entries[rx_rssi].an_rss_dbm;</a>
<a name="ln3181">			sc-&gt;an_sigcache[cache_slot].quality =</a>
<a name="ln3182">				- sc-&gt;an_rssimap.an_entries[rx_quality].an_rss_dbm;</a>
<a name="ln3183">		} else {</a>
<a name="ln3184">			sc-&gt;an_sigcache[cache_slot].signal = rx_rssi - 100;</a>
<a name="ln3185">			sc-&gt;an_sigcache[cache_slot].quality = rx_quality - 100;</a>
<a name="ln3186">		}</a>
<a name="ln3187">		break;</a>
<a name="ln3188">	case PERCENT:</a>
<a name="ln3189">		if (sc-&gt;an_have_rssimap) {</a>
<a name="ln3190">			sc-&gt;an_sigcache[cache_slot].signal =</a>
<a name="ln3191">				sc-&gt;an_rssimap.an_entries[rx_rssi].an_rss_pct;</a>
<a name="ln3192">			sc-&gt;an_sigcache[cache_slot].quality =</a>
<a name="ln3193">				sc-&gt;an_rssimap.an_entries[rx_quality].an_rss_pct;</a>
<a name="ln3194">		} else {</a>
<a name="ln3195">			if (rx_rssi &gt; 100)</a>
<a name="ln3196">				rx_rssi = 100;</a>
<a name="ln3197">			if (rx_quality &gt; 100)</a>
<a name="ln3198">				rx_quality = 100;</a>
<a name="ln3199">			sc-&gt;an_sigcache[cache_slot].signal = rx_rssi;</a>
<a name="ln3200">			sc-&gt;an_sigcache[cache_slot].quality = rx_quality;</a>
<a name="ln3201">		}</a>
<a name="ln3202">		break;</a>
<a name="ln3203">	case RAW:</a>
<a name="ln3204">		sc-&gt;an_sigcache[cache_slot].signal = rx_rssi;</a>
<a name="ln3205">		sc-&gt;an_sigcache[cache_slot].quality = rx_quality;</a>
<a name="ln3206">		break;</a>
<a name="ln3207">	}</a>
<a name="ln3208"> </a>
<a name="ln3209">	sc-&gt;an_sigcache[cache_slot].noise = 0;</a>
<a name="ln3210"> </a>
<a name="ln3211">	return;</a>
<a name="ln3212">}</a>
<a name="ln3213">#endif</a>
<a name="ln3214"> </a>
<a name="ln3215">static int</a>
<a name="ln3216">an_media_change(struct ifnet *ifp)</a>
<a name="ln3217">{</a>
<a name="ln3218">	struct an_softc *sc = ifp-&gt;if_softc;</a>
<a name="ln3219">	struct an_ltv_genconfig	*cfg;</a>
<a name="ln3220">	int otype = sc-&gt;an_config.an_opmode;</a>
<a name="ln3221">	int orate = sc-&gt;an_tx_rate;</a>
<a name="ln3222"> </a>
<a name="ln3223">	AN_LOCK(sc);</a>
<a name="ln3224">	sc-&gt;an_tx_rate = ieee80211_media2rate(</a>
<a name="ln3225">		IFM_SUBTYPE(sc-&gt;an_ifmedia.ifm_cur-&gt;ifm_media));</a>
<a name="ln3226">	if (sc-&gt;an_tx_rate &lt; 0)</a>
<a name="ln3227">		sc-&gt;an_tx_rate = 0;</a>
<a name="ln3228"> </a>
<a name="ln3229">	if (orate != sc-&gt;an_tx_rate) {</a>
<a name="ln3230">		/* Read the current configuration */</a>
<a name="ln3231">		sc-&gt;an_config.an_type = AN_RID_GENCONFIG;</a>
<a name="ln3232">		sc-&gt;an_config.an_len = sizeof(struct an_ltv_genconfig);</a>
<a name="ln3233">		an_read_record(sc, (struct an_ltv_gen *)&amp;sc-&gt;an_config);</a>
<a name="ln3234">		cfg = &amp;sc-&gt;an_config;</a>
<a name="ln3235"> </a>
<a name="ln3236">		/* clear other rates and set the only one we want */</a>
<a name="ln3237">		bzero(cfg-&gt;an_rates, sizeof(cfg-&gt;an_rates));</a>
<a name="ln3238">		cfg-&gt;an_rates[0] = sc-&gt;an_tx_rate;</a>
<a name="ln3239"> </a>
<a name="ln3240">		/* Save the new rate */</a>
<a name="ln3241">		sc-&gt;an_config.an_type = AN_RID_GENCONFIG;</a>
<a name="ln3242">		sc-&gt;an_config.an_len = sizeof(struct an_ltv_genconfig);</a>
<a name="ln3243">	}</a>
<a name="ln3244"> </a>
<a name="ln3245">	if ((sc-&gt;an_ifmedia.ifm_cur-&gt;ifm_media &amp; IFM_IEEE80211_ADHOC) != 0)</a>
<a name="ln3246">		sc-&gt;an_config.an_opmode &amp;= ~AN_OPMODE_INFRASTRUCTURE_STATION;</a>
<a name="ln3247">	else</a>
<a name="ln3248">		sc-&gt;an_config.an_opmode |= AN_OPMODE_INFRASTRUCTURE_STATION;</a>
<a name="ln3249"> </a>
<a name="ln3250">	if (otype != sc-&gt;an_config.an_opmode ||</a>
<a name="ln3251">	    orate != sc-&gt;an_tx_rate)</a>
<a name="ln3252">		an_init_locked(sc);</a>
<a name="ln3253">	AN_UNLOCK(sc);</a>
<a name="ln3254"> </a>
<a name="ln3255">	return(0);</a>
<a name="ln3256">}</a>
<a name="ln3257"> </a>
<a name="ln3258">static void</a>
<a name="ln3259">an_media_status(struct ifnet *ifp, struct ifmediareq *imr)</a>
<a name="ln3260">{</a>
<a name="ln3261">	struct an_ltv_status	status;</a>
<a name="ln3262">	struct an_softc		*sc = ifp-&gt;if_softc;</a>
<a name="ln3263"> </a>
<a name="ln3264">	imr-&gt;ifm_active = IFM_IEEE80211;</a>
<a name="ln3265"> </a>
<a name="ln3266">	AN_LOCK(sc);</a>
<a name="ln3267">	status.an_len = sizeof(status);</a>
<a name="ln3268">	status.an_type = AN_RID_STATUS;</a>
<a name="ln3269">	if (an_read_record(sc, (struct an_ltv_gen *)&amp;status)) {</a>
<a name="ln3270">		/* If the status read fails, just lie. */</a>
<a name="ln3271">		imr-&gt;ifm_active = sc-&gt;an_ifmedia.ifm_cur-&gt;ifm_media;</a>
<a name="ln3272">		imr-&gt;ifm_status = IFM_AVALID|IFM_ACTIVE;</a>
<a name="ln3273">	}</a>
<a name="ln3274"> </a>
<a name="ln3275">	if (sc-&gt;an_tx_rate == 0) {</a>
<a name="ln3276">		imr-&gt;ifm_active = IFM_IEEE80211|IFM_AUTO;</a>
<a name="ln3277">	}</a>
<a name="ln3278"> </a>
<a name="ln3279">	if (sc-&gt;an_config.an_opmode == AN_OPMODE_IBSS_ADHOC)</a>
<a name="ln3280">		imr-&gt;ifm_active |= IFM_IEEE80211_ADHOC;</a>
<a name="ln3281">	imr-&gt;ifm_active |= ieee80211_rate2media(NULL,</a>
<a name="ln3282">		status.an_current_tx_rate, IEEE80211_MODE_AUTO);</a>
<a name="ln3283">	imr-&gt;ifm_status = IFM_AVALID;</a>
<a name="ln3284">	if (status.an_opmode &amp; AN_STATUS_OPMODE_ASSOCIATED)</a>
<a name="ln3285">		imr-&gt;ifm_status |= IFM_ACTIVE;</a>
<a name="ln3286">	AN_UNLOCK(sc);</a>
<a name="ln3287">}</a>
<a name="ln3288"> </a>
<a name="ln3289">/********************** Cisco utility support routines *************/</a>
<a name="ln3290"> </a>
<a name="ln3291">/*</a>
<a name="ln3292"> * ReadRids &amp; WriteRids derived from Cisco driver additions to Ben Reed's</a>
<a name="ln3293"> * Linux driver</a>
<a name="ln3294"> */</a>
<a name="ln3295"> </a>
<a name="ln3296">static int</a>
<a name="ln3297">readrids(struct ifnet *ifp, struct aironet_ioctl *l_ioctl)</a>
<a name="ln3298">{</a>
<a name="ln3299">	unsigned short  rid;</a>
<a name="ln3300">	struct an_softc *sc;</a>
<a name="ln3301">	int error;</a>
<a name="ln3302"> </a>
<a name="ln3303">	switch (l_ioctl-&gt;command) {</a>
<a name="ln3304">	case AIROGCAP:</a>
<a name="ln3305">		rid = AN_RID_CAPABILITIES;</a>
<a name="ln3306">		break;</a>
<a name="ln3307">	case AIROGCFG:</a>
<a name="ln3308">		rid = AN_RID_GENCONFIG;</a>
<a name="ln3309">		break;</a>
<a name="ln3310">	case AIROGSLIST:</a>
<a name="ln3311">		rid = AN_RID_SSIDLIST;</a>
<a name="ln3312">		break;</a>
<a name="ln3313">	case AIROGVLIST:</a>
<a name="ln3314">		rid = AN_RID_APLIST;</a>
<a name="ln3315">		break;</a>
<a name="ln3316">	case AIROGDRVNAM:</a>
<a name="ln3317">		rid = AN_RID_DRVNAME;</a>
<a name="ln3318">		break;</a>
<a name="ln3319">	case AIROGEHTENC:</a>
<a name="ln3320">		rid = AN_RID_ENCAPPROTO;</a>
<a name="ln3321">		break;</a>
<a name="ln3322">	case AIROGWEPKTMP:</a>
<a name="ln3323">		rid = AN_RID_WEP_TEMP;</a>
<a name="ln3324">		break;</a>
<a name="ln3325">	case AIROGWEPKNV:</a>
<a name="ln3326">		rid = AN_RID_WEP_PERM;</a>
<a name="ln3327">		break;</a>
<a name="ln3328">	case AIROGSTAT:</a>
<a name="ln3329">		rid = AN_RID_STATUS;</a>
<a name="ln3330">		break;</a>
<a name="ln3331">	case AIROGSTATSD32:</a>
<a name="ln3332">		rid = AN_RID_32BITS_DELTA;</a>
<a name="ln3333">		break;</a>
<a name="ln3334">	case AIROGSTATSC32:</a>
<a name="ln3335">		rid = AN_RID_32BITS_CUM;</a>
<a name="ln3336">		break;</a>
<a name="ln3337">	default:</a>
<a name="ln3338">		rid = 999;</a>
<a name="ln3339">		break;</a>
<a name="ln3340">	}</a>
<a name="ln3341"> </a>
<a name="ln3342">	if (rid == 999)	/* Is bad command */</a>
<a name="ln3343">		return -EINVAL;</a>
<a name="ln3344"> </a>
<a name="ln3345">	sc = ifp-&gt;if_softc;</a>
<a name="ln3346">	sc-&gt;areq.an_len  = AN_MAX_DATALEN;</a>
<a name="ln3347">	sc-&gt;areq.an_type = rid;</a>
<a name="ln3348"> </a>
<a name="ln3349">	an_read_record(sc, (struct an_ltv_gen *)&amp;sc-&gt;areq);</a>
<a name="ln3350"> </a>
<a name="ln3351">	l_ioctl-&gt;len = sc-&gt;areq.an_len - 4;	/* just data */</a>
<a name="ln3352"> </a>
<a name="ln3353">	AN_UNLOCK(sc);</a>
<a name="ln3354">	/* the data contains the length at first */</a>
<a name="ln3355">	if (copyout(&amp;(sc-&gt;areq.an_len), l_ioctl-&gt;data,</a>
<a name="ln3356">		    sizeof(sc-&gt;areq.an_len))) {</a>
<a name="ln3357">		error = -EFAULT;</a>
<a name="ln3358">		goto lock_exit;</a>
<a name="ln3359">	}</a>
<a name="ln3360">	/* Just copy the data back */</a>
<a name="ln3361">	if (copyout(&amp;(sc-&gt;areq.an_val), l_ioctl-&gt;data + 2,</a>
<a name="ln3362">		    l_ioctl-&gt;len)) {</a>
<a name="ln3363">		error = -EFAULT;</a>
<a name="ln3364">		goto lock_exit;</a>
<a name="ln3365">	}</a>
<a name="ln3366">	error = 0;</a>
<a name="ln3367">lock_exit:</a>
<a name="ln3368">	AN_LOCK(sc);</a>
<a name="ln3369">	return (error);</a>
<a name="ln3370">}</a>
<a name="ln3371"> </a>
<a name="ln3372">static int</a>
<a name="ln3373">writerids(struct ifnet *ifp, struct aironet_ioctl *l_ioctl)</a>
<a name="ln3374">{</a>
<a name="ln3375">	struct an_softc *sc;</a>
<a name="ln3376">	int		rid, command, error;</a>
<a name="ln3377"> </a>
<a name="ln3378">	sc = ifp-&gt;if_softc;</a>
<a name="ln3379">	AN_LOCK_ASSERT(sc);</a>
<a name="ln3380">	rid = 0;</a>
<a name="ln3381">	command = l_ioctl-&gt;command;</a>
<a name="ln3382"> </a>
<a name="ln3383">	switch (command) {</a>
<a name="ln3384">	case AIROPSIDS:</a>
<a name="ln3385">		rid = AN_RID_SSIDLIST;</a>
<a name="ln3386">		break;</a>
<a name="ln3387">	case AIROPCAP:</a>
<a name="ln3388">		rid = AN_RID_CAPABILITIES;</a>
<a name="ln3389">		break;</a>
<a name="ln3390">	case AIROPAPLIST:</a>
<a name="ln3391">		rid = AN_RID_APLIST;</a>
<a name="ln3392">		break;</a>
<a name="ln3393">	case AIROPCFG:</a>
<a name="ln3394">		rid = AN_RID_GENCONFIG;</a>
<a name="ln3395">		break;</a>
<a name="ln3396">	case AIROPMACON:</a>
<a name="ln3397">		an_cmd(sc, AN_CMD_ENABLE, 0);</a>
<a name="ln3398">		return 0;</a>
<a name="ln3399">		break;</a>
<a name="ln3400">	case AIROPMACOFF:</a>
<a name="ln3401">		an_cmd(sc, AN_CMD_DISABLE, 0);</a>
<a name="ln3402">		return 0;</a>
<a name="ln3403">		break;</a>
<a name="ln3404">	case AIROPSTCLR:</a>
<a name="ln3405">		/*</a>
<a name="ln3406">		 * This command merely clears the counts does not actually</a>
<a name="ln3407">		 * store any data only reads rid. But as it changes the cards</a>
<a name="ln3408">		 * state, I put it in the writerid routines.</a>
<a name="ln3409">		 */</a>
<a name="ln3410"> </a>
<a name="ln3411">		rid = AN_RID_32BITS_DELTACLR;</a>
<a name="ln3412">		sc = ifp-&gt;if_softc;</a>
<a name="ln3413">		sc-&gt;areq.an_len = AN_MAX_DATALEN;</a>
<a name="ln3414">		sc-&gt;areq.an_type = rid;</a>
<a name="ln3415"> </a>
<a name="ln3416">		an_read_record(sc, (struct an_ltv_gen *)&amp;sc-&gt;areq);</a>
<a name="ln3417">		l_ioctl-&gt;len = sc-&gt;areq.an_len - 4;	/* just data */</a>
<a name="ln3418"> </a>
<a name="ln3419">		AN_UNLOCK(sc);</a>
<a name="ln3420">		/* the data contains the length at first */</a>
<a name="ln3421">		error = copyout(&amp;(sc-&gt;areq.an_len), l_ioctl-&gt;data,</a>
<a name="ln3422">			    sizeof(sc-&gt;areq.an_len));</a>
<a name="ln3423">		if (error) {</a>
<a name="ln3424">			AN_LOCK(sc);</a>
<a name="ln3425">			return -EFAULT;</a>
<a name="ln3426">		}</a>
<a name="ln3427">		/* Just copy the data */</a>
<a name="ln3428">		error = copyout(&amp;(sc-&gt;areq.an_val), l_ioctl-&gt;data + 2,</a>
<a name="ln3429">			    l_ioctl-&gt;len);</a>
<a name="ln3430">		AN_LOCK(sc);</a>
<a name="ln3431">		if (error)</a>
<a name="ln3432">			return -EFAULT;</a>
<a name="ln3433">		return 0;</a>
<a name="ln3434">		break;</a>
<a name="ln3435">	case AIROPWEPKEY:</a>
<a name="ln3436">		rid = AN_RID_WEP_TEMP;</a>
<a name="ln3437">		break;</a>
<a name="ln3438">	case AIROPWEPKEYNV:</a>
<a name="ln3439">		rid = AN_RID_WEP_PERM;</a>
<a name="ln3440">		break;</a>
<a name="ln3441">	case AIROPLEAPUSR:</a>
<a name="ln3442">		rid = AN_RID_LEAPUSERNAME;</a>
<a name="ln3443">		break;</a>
<a name="ln3444">	case AIROPLEAPPWD:</a>
<a name="ln3445">		rid = AN_RID_LEAPPASSWORD;</a>
<a name="ln3446">		break;</a>
<a name="ln3447">	default:</a>
<a name="ln3448">		return -EOPNOTSUPP;</a>
<a name="ln3449">	}</a>
<a name="ln3450"> </a>
<a name="ln3451">	if (rid) {</a>
<a name="ln3452">		if (l_ioctl-&gt;len &gt; sizeof(sc-&gt;areq.an_val) + 4)</a>
<a name="ln3453">			return -EINVAL;</a>
<a name="ln3454">		sc-&gt;areq.an_len = l_ioctl-&gt;len + 4;	/* add type &amp; length */</a>
<a name="ln3455">		sc-&gt;areq.an_type = rid;</a>
<a name="ln3456"> </a>
<a name="ln3457">		/* Just copy the data back */</a>
<a name="ln3458">		AN_UNLOCK(sc);</a>
<a name="ln3459">		error = copyin((l_ioctl-&gt;data) + 2, &amp;sc-&gt;areq.an_val,</a>
<a name="ln3460">		       l_ioctl-&gt;len);</a>
<a name="ln3461">		AN_LOCK(sc);</a>
<a name="ln3462">		if (error)</a>
<a name="ln3463">			return -EFAULT;</a>
<a name="ln3464"> </a>
<a name="ln3465">		an_cmd(sc, AN_CMD_DISABLE, 0);</a>
<a name="ln3466">		an_write_record(sc, (struct an_ltv_gen *)&amp;sc-&gt;areq);</a>
<a name="ln3467">		an_cmd(sc, AN_CMD_ENABLE, 0);</a>
<a name="ln3468">		return 0;</a>
<a name="ln3469">	}</a>
<a name="ln3470">	return -EOPNOTSUPP;</a>
<a name="ln3471">}</a>
<a name="ln3472"> </a>
<a name="ln3473">/*</a>
<a name="ln3474"> * General Flash utilities derived from Cisco driver additions to Ben Reed's</a>
<a name="ln3475"> * Linux driver</a>
<a name="ln3476"> */</a>
<a name="ln3477"> </a>
<a name="ln3478">#define FLASH_DELAY(_sc, x)	msleep(ifp, &amp;(_sc)-&gt;an_mtx, PZERO, \</a>
<a name="ln3479">	&quot;flash&quot;, ((x) / hz) + 1);</a>
<a name="ln3480">#define FLASH_COMMAND	0x7e7e</a>
<a name="ln3481">#define FLASH_SIZE	32 * 1024</a>
<a name="ln3482"> </a>
<a name="ln3483">static int</a>
<a name="ln3484">unstickbusy(struct ifnet *ifp)</a>
<a name="ln3485">{</a>
<a name="ln3486">	struct an_softc *sc = ifp-&gt;if_softc;</a>
<a name="ln3487"> </a>
<a name="ln3488">	if (CSR_READ_2(sc, AN_COMMAND(sc-&gt;mpi350)) &amp; AN_CMD_BUSY) {</a>
<a name="ln3489">		CSR_WRITE_2(sc, AN_EVENT_ACK(sc-&gt;mpi350),</a>
<a name="ln3490">			    AN_EV_CLR_STUCK_BUSY);</a>
<a name="ln3491">		return 1;</a>
<a name="ln3492">	}</a>
<a name="ln3493">	return 0;</a>
<a name="ln3494">}</a>
<a name="ln3495"> </a>
<a name="ln3496">/*</a>
<a name="ln3497"> * Wait for busy completion from card wait for delay uSec's Return true for</a>
<a name="ln3498"> * success meaning command reg is clear</a>
<a name="ln3499"> */</a>
<a name="ln3500"> </a>
<a name="ln3501">static int</a>
<a name="ln3502">WaitBusy(struct ifnet *ifp, int uSec)</a>
<a name="ln3503">{</a>
<a name="ln3504">	int		statword = 0xffff;</a>
<a name="ln3505">	int		delay = 0;</a>
<a name="ln3506">	struct an_softc	*sc = ifp-&gt;if_softc;</a>
<a name="ln3507"> </a>
<a name="ln3508">	while ((statword &amp; AN_CMD_BUSY) &amp;&amp; delay &lt;= (1000 * 100)) {</a>
<a name="ln3509">		FLASH_DELAY(sc, 10);</a>
<a name="ln3510">		delay += 10;</a>
<a name="ln3511">		statword = CSR_READ_2(sc, AN_COMMAND(sc-&gt;mpi350));</a>
<a name="ln3512"> </a>
<a name="ln3513">		if ((AN_CMD_BUSY &amp; statword) &amp;&amp; (delay % 200)) {</a>
<a name="ln3514">			unstickbusy(ifp);</a>
<a name="ln3515">		}</a>
<a name="ln3516">	}</a>
<a name="ln3517"> </a>
<a name="ln3518">	return 0 == (AN_CMD_BUSY &amp; statword);</a>
<a name="ln3519">}</a>
<a name="ln3520"> </a>
<a name="ln3521">/*</a>
<a name="ln3522"> * STEP 1) Disable MAC and do soft reset on card.</a>
<a name="ln3523"> */</a>
<a name="ln3524"> </a>
<a name="ln3525">static int</a>
<a name="ln3526">cmdreset(struct ifnet *ifp)</a>
<a name="ln3527">{</a>
<a name="ln3528">	int		status;</a>
<a name="ln3529">	struct an_softc	*sc = ifp-&gt;if_softc;</a>
<a name="ln3530"> </a>
<a name="ln3531">	AN_LOCK(sc);</a>
<a name="ln3532">	an_stop(sc);</a>
<a name="ln3533"> </a>
<a name="ln3534">	an_cmd(sc, AN_CMD_DISABLE, 0);</a>
<a name="ln3535"> </a>
<a name="ln3536">	if (!(status = WaitBusy(ifp, AN_TIMEOUT))) {</a>
<a name="ln3537">		if_printf(ifp, &quot;Waitbusy hang b4 RESET =%d\n&quot;, status);</a>
<a name="ln3538">		AN_UNLOCK(sc);</a>
<a name="ln3539">		return -EBUSY;</a>
<a name="ln3540">	}</a>
<a name="ln3541">	CSR_WRITE_2(sc, AN_COMMAND(sc-&gt;mpi350), AN_CMD_FW_RESTART);</a>
<a name="ln3542"> </a>
<a name="ln3543">	FLASH_DELAY(sc, 1000);	/* WAS 600 12/7/00 */</a>
<a name="ln3544"> </a>
<a name="ln3545"> </a>
<a name="ln3546">	if (!(status = WaitBusy(ifp, 100))) {</a>
<a name="ln3547">		if_printf(ifp, &quot;Waitbusy hang AFTER RESET =%d\n&quot;, status);</a>
<a name="ln3548">		AN_UNLOCK(sc);</a>
<a name="ln3549">		return -EBUSY;</a>
<a name="ln3550">	}</a>
<a name="ln3551">	AN_UNLOCK(sc);</a>
<a name="ln3552">	return 0;</a>
<a name="ln3553">}</a>
<a name="ln3554"> </a>
<a name="ln3555">/*</a>
<a name="ln3556"> * STEP 2) Put the card in legendary flash mode</a>
<a name="ln3557"> */</a>
<a name="ln3558"> </a>
<a name="ln3559">static int</a>
<a name="ln3560">setflashmode(struct ifnet *ifp)</a>
<a name="ln3561">{</a>
<a name="ln3562">	int		status;</a>
<a name="ln3563">	struct an_softc	*sc = ifp-&gt;if_softc;</a>
<a name="ln3564"> </a>
<a name="ln3565">	CSR_WRITE_2(sc, AN_SW0(sc-&gt;mpi350), FLASH_COMMAND);</a>
<a name="ln3566">	CSR_WRITE_2(sc, AN_SW1(sc-&gt;mpi350), FLASH_COMMAND);</a>
<a name="ln3567">	CSR_WRITE_2(sc, AN_SW0(sc-&gt;mpi350), FLASH_COMMAND);</a>
<a name="ln3568">	CSR_WRITE_2(sc, AN_COMMAND(sc-&gt;mpi350), FLASH_COMMAND);</a>
<a name="ln3569"> </a>
<a name="ln3570">	/*</a>
<a name="ln3571">	 * mdelay(500); // 500ms delay</a>
<a name="ln3572">	 */</a>
<a name="ln3573"> </a>
<a name="ln3574">	FLASH_DELAY(sc, 500);</a>
<a name="ln3575"> </a>
<a name="ln3576">	if (!(status = WaitBusy(ifp, AN_TIMEOUT))) {</a>
<a name="ln3577">		printf(&quot;Waitbusy hang after setflash mode\n&quot;);</a>
<a name="ln3578">		return -EIO;</a>
<a name="ln3579">	}</a>
<a name="ln3580">	return 0;</a>
<a name="ln3581">}</a>
<a name="ln3582"> </a>
<a name="ln3583">/*</a>
<a name="ln3584"> * Get a character from the card matching matchbyte Step 3)</a>
<a name="ln3585"> */</a>
<a name="ln3586"> </a>
<a name="ln3587">static int</a>
<a name="ln3588">flashgchar(struct ifnet *ifp, int matchbyte, int dwelltime)</a>
<a name="ln3589">{</a>
<a name="ln3590">	int		rchar;</a>
<a name="ln3591">	unsigned char	rbyte = 0;</a>
<a name="ln3592">	int		success = -1;</a>
<a name="ln3593">	struct an_softc	*sc = ifp-&gt;if_softc;</a>
<a name="ln3594"> </a>
<a name="ln3595"> </a>
<a name="ln3596">	do {</a>
<a name="ln3597">		rchar = CSR_READ_2(sc, AN_SW1(sc-&gt;mpi350));</a>
<a name="ln3598"> </a>
<a name="ln3599">		if (dwelltime &amp;&amp; !(0x8000 &amp; rchar)) {</a>
<a name="ln3600">			dwelltime -= 10;</a>
<a name="ln3601">			FLASH_DELAY(sc, 10);</a>
<a name="ln3602">			continue;</a>
<a name="ln3603">		}</a>
<a name="ln3604">		rbyte = 0xff &amp; rchar;</a>
<a name="ln3605"> </a>
<a name="ln3606">		if ((rbyte == matchbyte) &amp;&amp; (0x8000 &amp; rchar)) {</a>
<a name="ln3607">			CSR_WRITE_2(sc, AN_SW1(sc-&gt;mpi350), 0);</a>
<a name="ln3608">			success = 1;</a>
<a name="ln3609">			break;</a>
<a name="ln3610">		}</a>
<a name="ln3611">		if (rbyte == 0x81 || rbyte == 0x82 || rbyte == 0x83 || rbyte == 0x1a || 0xffff == rchar)</a>
<a name="ln3612">			break;</a>
<a name="ln3613">		CSR_WRITE_2(sc, AN_SW1(sc-&gt;mpi350), 0);</a>
<a name="ln3614"> </a>
<a name="ln3615">	} while (dwelltime &gt; 0);</a>
<a name="ln3616">	return success;</a>
<a name="ln3617">}</a>
<a name="ln3618"> </a>
<a name="ln3619">/*</a>
<a name="ln3620"> * Put character to SWS0 wait for dwelltime x 50us for  echo .</a>
<a name="ln3621"> */</a>
<a name="ln3622"> </a>
<a name="ln3623">static int</a>
<a name="ln3624">flashpchar(struct ifnet *ifp, int byte, int dwelltime)</a>
<a name="ln3625">{</a>
<a name="ln3626">	int		echo;</a>
<a name="ln3627">	int		pollbusy, waittime;</a>
<a name="ln3628">	struct an_softc	*sc = ifp-&gt;if_softc;</a>
<a name="ln3629"> </a>
<a name="ln3630">	byte |= 0x8000;</a>
<a name="ln3631"> </a>
<a name="ln3632">	if (dwelltime == 0)</a>
<a name="ln3633">		dwelltime = 200;</a>
<a name="ln3634"> </a>
<a name="ln3635">	waittime = dwelltime;</a>
<a name="ln3636"> </a>
<a name="ln3637">	/*</a>
<a name="ln3638">	 * Wait for busy bit d15 to go false indicating buffer empty</a>
<a name="ln3639">	 */</a>
<a name="ln3640">	do {</a>
<a name="ln3641">		pollbusy = CSR_READ_2(sc, AN_SW0(sc-&gt;mpi350));</a>
<a name="ln3642"> </a>
<a name="ln3643">		if (pollbusy &amp; 0x8000) {</a>
<a name="ln3644">			FLASH_DELAY(sc, 50);</a>
<a name="ln3645">			waittime -= 50;</a>
<a name="ln3646">			continue;</a>
<a name="ln3647">		} else</a>
<a name="ln3648">			break;</a>
<a name="ln3649">	}</a>
<a name="ln3650">	while (waittime &gt;= 0);</a>
<a name="ln3651"> </a>
<a name="ln3652">	/* timeout for busy clear wait */</a>
<a name="ln3653"> </a>
<a name="ln3654">	if (waittime &lt;= 0) {</a>
<a name="ln3655">		if_printf(ifp, &quot;flash putchar busywait timeout!\n&quot;);</a>
<a name="ln3656">		return -1;</a>
<a name="ln3657">	}</a>
<a name="ln3658">	/*</a>
<a name="ln3659">	 * Port is clear now write byte and wait for it to echo back</a>
<a name="ln3660">	 */</a>
<a name="ln3661">	do {</a>
<a name="ln3662">		CSR_WRITE_2(sc, AN_SW0(sc-&gt;mpi350), byte);</a>
<a name="ln3663">		FLASH_DELAY(sc, 50);</a>
<a name="ln3664">		dwelltime -= 50;</a>
<a name="ln3665">		echo = CSR_READ_2(sc, AN_SW1(sc-&gt;mpi350));</a>
<a name="ln3666">	} while (dwelltime &gt;= 0 &amp;&amp; echo != byte);</a>
<a name="ln3667"> </a>
<a name="ln3668"> </a>
<a name="ln3669">	CSR_WRITE_2(sc, AN_SW1(sc-&gt;mpi350), 0);</a>
<a name="ln3670"> </a>
<a name="ln3671">	return echo == byte;</a>
<a name="ln3672">}</a>
<a name="ln3673"> </a>
<a name="ln3674">/*</a>
<a name="ln3675"> * Transfer 32k of firmware data from user buffer to our buffer and send to</a>
<a name="ln3676"> * the card</a>
<a name="ln3677"> */</a>
<a name="ln3678"> </a>
<a name="ln3679">static int</a>
<a name="ln3680">flashputbuf(struct ifnet *ifp)</a>
<a name="ln3681">{</a>
<a name="ln3682">	unsigned short *bufp;</a>
<a name="ln3683">	int		nwords;</a>
<a name="ln3684">	struct an_softc	*sc = ifp-&gt;if_softc;</a>
<a name="ln3685"> </a>
<a name="ln3686">	/* Write stuff */</a>
<a name="ln3687"> </a>
<a name="ln3688">	bufp = sc-&gt;an_flash_buffer;</a>
<a name="ln3689"> </a>
<a name="ln3690">	if (!sc-&gt;mpi350) {</a>
<a name="ln3691">		CSR_WRITE_2(sc, AN_AUX_PAGE, 0x100);</a>
<a name="ln3692">		CSR_WRITE_2(sc, AN_AUX_OFFSET, 0);</a>
<a name="ln3693"> </a>
<a name="ln3694">		for (nwords = 0; nwords != FLASH_SIZE / 2; nwords++) {</a>
<a name="ln3695">			CSR_WRITE_2(sc, AN_AUX_DATA, bufp[nwords] &amp; 0xffff);</a>
<a name="ln3696">		}</a>
<a name="ln3697">	} else {</a>
<a name="ln3698">		for (nwords = 0; nwords != FLASH_SIZE / 4; nwords++) {</a>
<a name="ln3699">			CSR_MEM_AUX_WRITE_4(sc, 0x8000,</a>
<a name="ln3700">				((u_int32_t *)bufp)[nwords] &amp; 0xffff);</a>
<a name="ln3701">		}</a>
<a name="ln3702">	}</a>
<a name="ln3703"> </a>
<a name="ln3704">	CSR_WRITE_2(sc, AN_SW0(sc-&gt;mpi350), 0x8000);</a>
<a name="ln3705"> </a>
<a name="ln3706">	return 0;</a>
<a name="ln3707">}</a>
<a name="ln3708"> </a>
<a name="ln3709">/*</a>
<a name="ln3710"> * After flashing restart the card.</a>
<a name="ln3711"> */</a>
<a name="ln3712"> </a>
<a name="ln3713">static int</a>
<a name="ln3714">flashrestart(struct ifnet *ifp)</a>
<a name="ln3715">{</a>
<a name="ln3716">	int		status = 0;</a>
<a name="ln3717">	struct an_softc	*sc = ifp-&gt;if_softc;</a>
<a name="ln3718"> </a>
<a name="ln3719">	FLASH_DELAY(sc, 1024);		/* Added 12/7/00 */</a>
<a name="ln3720"> </a>
<a name="ln3721">	an_init_locked(sc);</a>
<a name="ln3722"> </a>
<a name="ln3723">	FLASH_DELAY(sc, 1024);		/* Added 12/7/00 */</a>
<a name="ln3724">	return status;</a>
<a name="ln3725">}</a>
<a name="ln3726"> </a>
<a name="ln3727">/*</a>
<a name="ln3728"> * Entry point for flash ioclt.</a>
<a name="ln3729"> */</a>
<a name="ln3730"> </a>
<a name="ln3731">static int</a>
<a name="ln3732">flashcard(struct ifnet *ifp, struct aironet_ioctl *l_ioctl)</a>
<a name="ln3733">{</a>
<a name="ln3734">	int		z = 0, status;</a>
<a name="ln3735">	struct an_softc	*sc;</a>
<a name="ln3736"> </a>
<a name="ln3737">	sc = ifp-&gt;if_softc;</a>
<a name="ln3738">	if (sc-&gt;mpi350) {</a>
<a name="ln3739">		if_printf(ifp, &quot;flashing not supported on MPI 350 yet\n&quot;);</a>
<a name="ln3740">		return(-1);</a>
<a name="ln3741">	}</a>
<a name="ln3742">	status = l_ioctl-&gt;command;</a>
<a name="ln3743"> </a>
<a name="ln3744">	switch (l_ioctl-&gt;command) {</a>
<a name="ln3745">	case AIROFLSHRST:</a>
<a name="ln3746">		return cmdreset(ifp);</a>
<a name="ln3747">		break;</a>
<a name="ln3748">	case AIROFLSHSTFL:</a>
<a name="ln3749">		if (sc-&gt;an_flash_buffer) {</a>
<a name="ln3750">			free(sc-&gt;an_flash_buffer, M_DEVBUF);</a>
<a name="ln3751">			sc-&gt;an_flash_buffer = NULL;</a>
<a name="ln3752">		}</a>
<a name="ln3753">		sc-&gt;an_flash_buffer = malloc(FLASH_SIZE, M_DEVBUF, M_WAITOK);</a>
<a name="ln3754">		if (sc-&gt;an_flash_buffer)</a>
<a name="ln3755">			return setflashmode(ifp);</a>
<a name="ln3756">		else</a>
<a name="ln3757">			return ENOBUFS;</a>
<a name="ln3758">		break;</a>
<a name="ln3759">	case AIROFLSHGCHR:	/* Get char from aux */</a>
<a name="ln3760">		if (l_ioctl-&gt;len &gt; sizeof(sc-&gt;areq)) {</a>
<a name="ln3761">			return -EINVAL;</a>
<a name="ln3762">		}</a>
<a name="ln3763">		AN_UNLOCK(sc);</a>
<a name="ln3764">		status = copyin(l_ioctl-&gt;data, &amp;sc-&gt;areq, l_ioctl-&gt;len);</a>
<a name="ln3765">		AN_LOCK(sc);</a>
<a name="ln3766">		if (status)</a>
<a name="ln3767">			return status;</a>
<a name="ln3768">		z = *(int *)&amp;sc-&gt;areq;</a>
<a name="ln3769">		if ((status = flashgchar(ifp, z, 8000)) == 1)</a>
<a name="ln3770">			return 0;</a>
<a name="ln3771">		else</a>
<a name="ln3772">			return -1;</a>
<a name="ln3773">	case AIROFLSHPCHR:	/* Send char to card. */</a>
<a name="ln3774">		if (l_ioctl-&gt;len &gt; sizeof(sc-&gt;areq)) {</a>
<a name="ln3775">			return -EINVAL;</a>
<a name="ln3776">		}</a>
<a name="ln3777">		AN_UNLOCK(sc);</a>
<a name="ln3778">		status = copyin(l_ioctl-&gt;data, &amp;sc-&gt;areq, l_ioctl-&gt;len);</a>
<a name="ln3779">		AN_LOCK(sc);</a>
<a name="ln3780">		if (status)</a>
<a name="ln3781">			return status;</a>
<a name="ln3782">		z = *(int *)&amp;sc-&gt;areq;</a>
<a name="ln3783">		if ((status = flashpchar(ifp, z, 8000)) == -1)</a>
<a name="ln3784">			return -EIO;</a>
<a name="ln3785">		else</a>
<a name="ln3786">			return 0;</a>
<a name="ln3787">		break;</a>
<a name="ln3788">	case AIROFLPUTBUF:	/* Send 32k to card */</a>
<a name="ln3789">		if (l_ioctl-&gt;len &gt; FLASH_SIZE) {</a>
<a name="ln3790">			if_printf(ifp, &quot;Buffer to big, %x %x\n&quot;,</a>
<a name="ln3791">			       l_ioctl-&gt;len, FLASH_SIZE);</a>
<a name="ln3792">			return -EINVAL;</a>
<a name="ln3793">		}</a>
<a name="ln3794">		AN_UNLOCK(sc);</a>
<a name="ln3795">		status = copyin(l_ioctl-&gt;data, sc-&gt;an_flash_buffer, l_ioctl-&gt;len);</a>
<a name="ln3796">		AN_LOCK(sc);</a>
<a name="ln3797">		if (status)</a>
<a name="ln3798">			return status;</a>
<a name="ln3799"> </a>
<a name="ln3800">		if ((status = flashputbuf(ifp)) != 0)</a>
<a name="ln3801">			return -EIO;</a>
<a name="ln3802">		else</a>
<a name="ln3803">			return 0;</a>
<a name="ln3804">		break;</a>
<a name="ln3805">	case AIRORESTART:</a>
<a name="ln3806">		if ((status = flashrestart(ifp)) != 0) {</a>
<a name="ln3807">			if_printf(ifp, &quot;FLASHRESTART returned %d\n&quot;, status);</a>
<a name="ln3808">			return -EIO;</a>
<a name="ln3809">		} else</a>
<a name="ln3810">			return 0;</a>
<a name="ln3811"> </a>
<a name="ln3812">		break;</a>
<a name="ln3813">	default:</a>
<a name="ln3814">		return -EINVAL;</a>
<a name="ln3815">	}</a>
<a name="ln3816"> </a>
<a name="ln3817">	return -EINVAL;</a>
<a name="ln3818">}</a>

</code></pre>
<div class="balloon" rel="756"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The 'memmove' function processes '0' elements. Inspect the third argument.</p></div>
<div class="balloon" rel="887"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memmove' function will lead to underflow of the buffer 'bpf_buf'.</p></div>
<div class="balloon" rel="2071"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memset' function will lead to underflow of the buffer 'tmpstr'.</p></div>
<div class="balloon" rel="2246"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memset' function will lead to underflow of the buffer 'tmpstr'.</p></div>
<div class="balloon" rel="2467"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memset' function will lead to underflow of the buffer '& sc->areq'.</p></div>
<div class="balloon" rel="2992"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memmove' function will lead to underflow of the buffer '& sc->areq'.</p></div>
<div class="balloon" rel="2419"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memset' function will lead to underflow of the buffer '& sc->areq'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
