
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>if_fxp.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * SPDX-License-Identifier: BSD-2-Clause-NetBSD</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 1995, David Greenman</a>
<a name="ln5"> * Copyright (c) 2001 Jonathan Lemon &lt;jlemon@freebsd.org&gt;</a>
<a name="ln6"> * All rights reserved.</a>
<a name="ln7"> *</a>
<a name="ln8"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln9"> * modification, are permitted provided that the following conditions</a>
<a name="ln10"> * are met:</a>
<a name="ln11"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln12"> *    notice unmodified, this list of conditions, and the following</a>
<a name="ln13"> *    disclaimer.</a>
<a name="ln14"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln15"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln16"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln17"> *</a>
<a name="ln18"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln19"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln20"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln21"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</a>
<a name="ln22"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln23"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln24"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln25"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln26"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln27"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln28"> * SUCH DAMAGE.</a>
<a name="ln29"> *</a>
<a name="ln30"> */</a>
<a name="ln31"> </a>
<a name="ln32">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln33">__FBSDID(&quot;$FreeBSD: releng/12.0/sys/dev/fxp/if_fxp.c 338948 2018-09-26 17:12:14Z imp $&quot;);</a>
<a name="ln34"> </a>
<a name="ln35">/*</a>
<a name="ln36"> * Intel EtherExpress Pro/100B PCI Fast Ethernet driver</a>
<a name="ln37"> */</a>
<a name="ln38"> </a>
<a name="ln39">#ifdef HAVE_KERNEL_OPTION_HEADERS</a>
<a name="ln40">#include &quot;opt_device_polling.h&quot;</a>
<a name="ln41">#endif</a>
<a name="ln42"> </a>
<a name="ln43">#include &lt;sys/param.h&gt;</a>
<a name="ln44">#include &lt;sys/systm.h&gt;</a>
<a name="ln45">#include &lt;sys/bus.h&gt;</a>
<a name="ln46">#include &lt;sys/endian.h&gt;</a>
<a name="ln47">#include &lt;sys/kernel.h&gt;</a>
<a name="ln48">#include &lt;sys/mbuf.h&gt;</a>
<a name="ln49">#include &lt;sys/lock.h&gt;</a>
<a name="ln50">#include &lt;sys/malloc.h&gt;</a>
<a name="ln51">#include &lt;sys/module.h&gt;</a>
<a name="ln52">#include &lt;sys/mutex.h&gt;</a>
<a name="ln53">#include &lt;sys/rman.h&gt;</a>
<a name="ln54">#include &lt;sys/socket.h&gt;</a>
<a name="ln55">#include &lt;sys/sockio.h&gt;</a>
<a name="ln56">#include &lt;sys/sysctl.h&gt;</a>
<a name="ln57"> </a>
<a name="ln58">#include &lt;net/bpf.h&gt;</a>
<a name="ln59">#include &lt;net/ethernet.h&gt;</a>
<a name="ln60">#include &lt;net/if.h&gt;</a>
<a name="ln61">#include &lt;net/if_var.h&gt;</a>
<a name="ln62">#include &lt;net/if_arp.h&gt;</a>
<a name="ln63">#include &lt;net/if_dl.h&gt;</a>
<a name="ln64">#include &lt;net/if_media.h&gt;</a>
<a name="ln65">#include &lt;net/if_types.h&gt;</a>
<a name="ln66">#include &lt;net/if_vlan_var.h&gt;</a>
<a name="ln67"> </a>
<a name="ln68">#include &lt;netinet/in.h&gt;</a>
<a name="ln69">#include &lt;netinet/in_systm.h&gt;</a>
<a name="ln70">#include &lt;netinet/ip.h&gt;</a>
<a name="ln71">#include &lt;netinet/tcp.h&gt;</a>
<a name="ln72">#include &lt;netinet/udp.h&gt;</a>
<a name="ln73"> </a>
<a name="ln74">#include &lt;machine/bus.h&gt;</a>
<a name="ln75">#include &lt;machine/in_cksum.h&gt;</a>
<a name="ln76">#include &lt;machine/resource.h&gt;</a>
<a name="ln77"> </a>
<a name="ln78">#include &lt;dev/pci/pcivar.h&gt;</a>
<a name="ln79">#include &lt;dev/pci/pcireg.h&gt;		/* for PCIM_CMD_xxx */</a>
<a name="ln80"> </a>
<a name="ln81">#include &lt;dev/mii/mii.h&gt;</a>
<a name="ln82">#include &lt;dev/mii/miivar.h&gt;</a>
<a name="ln83"> </a>
<a name="ln84">#include &lt;dev/fxp/if_fxpreg.h&gt;</a>
<a name="ln85">#include &lt;dev/fxp/if_fxpvar.h&gt;</a>
<a name="ln86">#include &lt;dev/fxp/rcvbundl.h&gt;</a>
<a name="ln87"> </a>
<a name="ln88">MODULE_DEPEND(fxp, pci, 1, 1, 1);</a>
<a name="ln89">MODULE_DEPEND(fxp, ether, 1, 1, 1);</a>
<a name="ln90">MODULE_DEPEND(fxp, miibus, 1, 1, 1);</a>
<a name="ln91">#include &quot;miibus_if.h&quot;</a>
<a name="ln92"> </a>
<a name="ln93">/*</a>
<a name="ln94"> * NOTE!  On !x86 we typically have an alignment constraint.  The</a>
<a name="ln95"> * card DMAs the packet immediately following the RFA.  However,</a>
<a name="ln96"> * the first thing in the packet is a 14-byte Ethernet header.</a>
<a name="ln97"> * This means that the packet is misaligned.  To compensate,</a>
<a name="ln98"> * we actually offset the RFA 2 bytes into the cluster.  This</a>
<a name="ln99"> * alignes the packet after the Ethernet header at a 32-bit</a>
<a name="ln100"> * boundary.  HOWEVER!  This means that the RFA is misaligned!</a>
<a name="ln101"> */</a>
<a name="ln102">#define	RFA_ALIGNMENT_FUDGE	2</a>
<a name="ln103"> </a>
<a name="ln104">/*</a>
<a name="ln105"> * Set initial transmit threshold at 64 (512 bytes). This is</a>
<a name="ln106"> * increased by 64 (512 bytes) at a time, to maximum of 192</a>
<a name="ln107"> * (1536 bytes), if an underrun occurs.</a>
<a name="ln108"> */</a>
<a name="ln109">static int tx_threshold = 64;</a>
<a name="ln110"> </a>
<a name="ln111">/*</a>
<a name="ln112"> * The configuration byte map has several undefined fields which</a>
<a name="ln113"> * must be one or must be zero.  Set up a template for these bits.</a>
<a name="ln114"> * The actual configuration is performed in fxp_init_body.</a>
<a name="ln115"> *</a>
<a name="ln116"> * See struct fxp_cb_config for the bit definitions.</a>
<a name="ln117"> */</a>
<a name="ln118">static const u_char fxp_cb_config_template[] = {</a>
<a name="ln119">	0x0, 0x0,		/* cb_status */</a>
<a name="ln120">	0x0, 0x0,		/* cb_command */</a>
<a name="ln121">	0x0, 0x0, 0x0, 0x0,	/* link_addr */</a>
<a name="ln122">	0x0,	/*  0 */</a>
<a name="ln123">	0x0,	/*  1 */</a>
<a name="ln124">	0x0,	/*  2 */</a>
<a name="ln125">	0x0,	/*  3 */</a>
<a name="ln126">	0x0,	/*  4 */</a>
<a name="ln127">	0x0,	/*  5 */</a>
<a name="ln128">	0x32,	/*  6 */</a>
<a name="ln129">	0x0,	/*  7 */</a>
<a name="ln130">	0x0,	/*  8 */</a>
<a name="ln131">	0x0,	/*  9 */</a>
<a name="ln132">	0x6,	/* 10 */</a>
<a name="ln133">	0x0,	/* 11 */</a>
<a name="ln134">	0x0,	/* 12 */</a>
<a name="ln135">	0x0,	/* 13 */</a>
<a name="ln136">	0xf2,	/* 14 */</a>
<a name="ln137">	0x48,	/* 15 */</a>
<a name="ln138">	0x0,	/* 16 */</a>
<a name="ln139">	0x40,	/* 17 */</a>
<a name="ln140">	0xf0,	/* 18 */</a>
<a name="ln141">	0x0,	/* 19 */</a>
<a name="ln142">	0x3f,	/* 20 */</a>
<a name="ln143">	0x5,	/* 21 */</a>
<a name="ln144">	0x0,	/* 22 */</a>
<a name="ln145">	0x0,	/* 23 */</a>
<a name="ln146">	0x0,	/* 24 */</a>
<a name="ln147">	0x0,	/* 25 */</a>
<a name="ln148">	0x0,	/* 26 */</a>
<a name="ln149">	0x0,	/* 27 */</a>
<a name="ln150">	0x0,	/* 28 */</a>
<a name="ln151">	0x0,	/* 29 */</a>
<a name="ln152">	0x0,	/* 30 */</a>
<a name="ln153">	0x0	/* 31 */</a>
<a name="ln154">};</a>
<a name="ln155"> </a>
<a name="ln156">/*</a>
<a name="ln157"> * Claim various Intel PCI device identifiers for this driver.  The</a>
<a name="ln158"> * sub-vendor and sub-device field are extensively used to identify</a>
<a name="ln159"> * particular variants, but we don't currently differentiate between</a>
<a name="ln160"> * them.</a>
<a name="ln161"> */</a>
<a name="ln162">static const struct fxp_ident fxp_ident_table[] = {</a>
<a name="ln163">    { 0x8086, 0x1029,	-1,	0, &quot;Intel 82559 PCI/CardBus Pro/100&quot; },</a>
<a name="ln164">    { 0x8086, 0x1030,	-1,	0, &quot;Intel 82559 Pro/100 Ethernet&quot; },</a>
<a name="ln165">    { 0x8086, 0x1031,	-1,	3, &quot;Intel 82801CAM (ICH3) Pro/100 VE Ethernet&quot; },</a>
<a name="ln166">    { 0x8086, 0x1032,	-1,	3, &quot;Intel 82801CAM (ICH3) Pro/100 VE Ethernet&quot; },</a>
<a name="ln167">    { 0x8086, 0x1033,	-1,	3, &quot;Intel 82801CAM (ICH3) Pro/100 VM Ethernet&quot; },</a>
<a name="ln168">    { 0x8086, 0x1034,	-1,	3, &quot;Intel 82801CAM (ICH3) Pro/100 VM Ethernet&quot; },</a>
<a name="ln169">    { 0x8086, 0x1035,	-1,	3, &quot;Intel 82801CAM (ICH3) Pro/100 Ethernet&quot; },</a>
<a name="ln170">    { 0x8086, 0x1036,	-1,	3, &quot;Intel 82801CAM (ICH3) Pro/100 Ethernet&quot; },</a>
<a name="ln171">    { 0x8086, 0x1037,	-1,	3, &quot;Intel 82801CAM (ICH3) Pro/100 Ethernet&quot; },</a>
<a name="ln172">    { 0x8086, 0x1038,	-1,	3, &quot;Intel 82801CAM (ICH3) Pro/100 VM Ethernet&quot; },</a>
<a name="ln173">    { 0x8086, 0x1039,	-1,	4, &quot;Intel 82801DB (ICH4) Pro/100 VE Ethernet&quot; },</a>
<a name="ln174">    { 0x8086, 0x103A,	-1,	4, &quot;Intel 82801DB (ICH4) Pro/100 Ethernet&quot; },</a>
<a name="ln175">    { 0x8086, 0x103B,	-1,	4, &quot;Intel 82801DB (ICH4) Pro/100 VM Ethernet&quot; },</a>
<a name="ln176">    { 0x8086, 0x103C,	-1,	4, &quot;Intel 82801DB (ICH4) Pro/100 Ethernet&quot; },</a>
<a name="ln177">    { 0x8086, 0x103D,	-1,	4, &quot;Intel 82801DB (ICH4) Pro/100 VE Ethernet&quot; },</a>
<a name="ln178">    { 0x8086, 0x103E,	-1,	4, &quot;Intel 82801DB (ICH4) Pro/100 VM Ethernet&quot; },</a>
<a name="ln179">    { 0x8086, 0x1050,	-1,	5, &quot;Intel 82801BA (D865) Pro/100 VE Ethernet&quot; },</a>
<a name="ln180">    { 0x8086, 0x1051,	-1,	5, &quot;Intel 82562ET (ICH5/ICH5R) Pro/100 VE Ethernet&quot; },</a>
<a name="ln181">    { 0x8086, 0x1059,	-1,	0, &quot;Intel 82551QM Pro/100 M Mobile Connection&quot; },</a>
<a name="ln182">    { 0x8086, 0x1064,	-1,	6, &quot;Intel 82562EZ (ICH6)&quot; },</a>
<a name="ln183">    { 0x8086, 0x1065,	-1,	6, &quot;Intel 82562ET/EZ/GT/GZ PRO/100 VE Ethernet&quot; },</a>
<a name="ln184">    { 0x8086, 0x1068,	-1,	6, &quot;Intel 82801FBM (ICH6-M) Pro/100 VE Ethernet&quot; },</a>
<a name="ln185">    { 0x8086, 0x1069,	-1,	6, &quot;Intel 82562EM/EX/GX Pro/100 Ethernet&quot; },</a>
<a name="ln186">    { 0x8086, 0x1091,	-1,	7, &quot;Intel 82562GX Pro/100 Ethernet&quot; },</a>
<a name="ln187">    { 0x8086, 0x1092,	-1,	7, &quot;Intel Pro/100 VE Network Connection&quot; },</a>
<a name="ln188">    { 0x8086, 0x1093,	-1,	7, &quot;Intel Pro/100 VM Network Connection&quot; },</a>
<a name="ln189">    { 0x8086, 0x1094,	-1,	7, &quot;Intel Pro/100 946GZ (ICH7) Network Connection&quot; },</a>
<a name="ln190">    { 0x8086, 0x1209,	-1,	0, &quot;Intel 82559ER Embedded 10/100 Ethernet&quot; },</a>
<a name="ln191">    { 0x8086, 0x1229,	0x01,	0, &quot;Intel 82557 Pro/100 Ethernet&quot; },</a>
<a name="ln192">    { 0x8086, 0x1229,	0x02,	0, &quot;Intel 82557 Pro/100 Ethernet&quot; },</a>
<a name="ln193">    { 0x8086, 0x1229,	0x03,	0, &quot;Intel 82557 Pro/100 Ethernet&quot; },</a>
<a name="ln194">    { 0x8086, 0x1229,	0x04,	0, &quot;Intel 82558 Pro/100 Ethernet&quot; },</a>
<a name="ln195">    { 0x8086, 0x1229,	0x05,	0, &quot;Intel 82558 Pro/100 Ethernet&quot; },</a>
<a name="ln196">    { 0x8086, 0x1229,	0x06,	0, &quot;Intel 82559 Pro/100 Ethernet&quot; },</a>
<a name="ln197">    { 0x8086, 0x1229,	0x07,	0, &quot;Intel 82559 Pro/100 Ethernet&quot; },</a>
<a name="ln198">    { 0x8086, 0x1229,	0x08,	0, &quot;Intel 82559 Pro/100 Ethernet&quot; },</a>
<a name="ln199">    { 0x8086, 0x1229,	0x09,	0, &quot;Intel 82559ER Pro/100 Ethernet&quot; },</a>
<a name="ln200">    { 0x8086, 0x1229,	0x0c,	0, &quot;Intel 82550 Pro/100 Ethernet&quot; },</a>
<a name="ln201">    { 0x8086, 0x1229,	0x0d,	0, &quot;Intel 82550C Pro/100 Ethernet&quot; },</a>
<a name="ln202">    { 0x8086, 0x1229,	0x0e,	0, &quot;Intel 82550 Pro/100 Ethernet&quot; },</a>
<a name="ln203">    { 0x8086, 0x1229,	0x0f,	0, &quot;Intel 82551 Pro/100 Ethernet&quot; },</a>
<a name="ln204">    { 0x8086, 0x1229,	0x10,	0, &quot;Intel 82551 Pro/100 Ethernet&quot; },</a>
<a name="ln205">    { 0x8086, 0x1229,	-1,	0, &quot;Intel 82557/8/9 Pro/100 Ethernet&quot; },</a>
<a name="ln206">    { 0x8086, 0x2449,	-1,	2, &quot;Intel 82801BA/CAM (ICH2/3) Pro/100 Ethernet&quot; },</a>
<a name="ln207">    { 0x8086, 0x27dc,	-1,	7, &quot;Intel 82801GB (ICH7) 10/100 Ethernet&quot; },</a>
<a name="ln208">    { 0,      0,	-1,	0, NULL },</a>
<a name="ln209">};</a>
<a name="ln210"> </a>
<a name="ln211">#ifdef FXP_IP_CSUM_WAR</a>
<a name="ln212">#define FXP_CSUM_FEATURES    (CSUM_IP | CSUM_TCP | CSUM_UDP)</a>
<a name="ln213">#else</a>
<a name="ln214">#define FXP_CSUM_FEATURES    (CSUM_TCP | CSUM_UDP)</a>
<a name="ln215">#endif</a>
<a name="ln216"> </a>
<a name="ln217">static int		fxp_probe(device_t dev);</a>
<a name="ln218">static int		fxp_attach(device_t dev);</a>
<a name="ln219">static int		fxp_detach(device_t dev);</a>
<a name="ln220">static int		fxp_shutdown(device_t dev);</a>
<a name="ln221">static int		fxp_suspend(device_t dev);</a>
<a name="ln222">static int		fxp_resume(device_t dev);</a>
<a name="ln223"> </a>
<a name="ln224">static const struct fxp_ident *fxp_find_ident(device_t dev);</a>
<a name="ln225">static void		fxp_intr(void *xsc);</a>
<a name="ln226">static void		fxp_rxcsum(struct fxp_softc *sc, if_t ifp,</a>
<a name="ln227">			    struct mbuf *m, uint16_t status, int pos);</a>
<a name="ln228">static int		fxp_intr_body(struct fxp_softc *sc, if_t ifp,</a>
<a name="ln229">			    uint8_t statack, int count);</a>
<a name="ln230">static void 		fxp_init(void *xsc);</a>
<a name="ln231">static void 		fxp_init_body(struct fxp_softc *sc, int);</a>
<a name="ln232">static void 		fxp_tick(void *xsc);</a>
<a name="ln233">static void 		fxp_start(if_t ifp);</a>
<a name="ln234">static void 		fxp_start_body(if_t ifp);</a>
<a name="ln235">static int		fxp_encap(struct fxp_softc *sc, struct mbuf **m_head);</a>
<a name="ln236">static void		fxp_txeof(struct fxp_softc *sc);</a>
<a name="ln237">static void		fxp_stop(struct fxp_softc *sc);</a>
<a name="ln238">static void 		fxp_release(struct fxp_softc *sc);</a>
<a name="ln239">static int		fxp_ioctl(if_t ifp, u_long command,</a>
<a name="ln240">			    caddr_t data);</a>
<a name="ln241">static void 		fxp_watchdog(struct fxp_softc *sc);</a>
<a name="ln242">static void		fxp_add_rfabuf(struct fxp_softc *sc,</a>
<a name="ln243">			    struct fxp_rx *rxp);</a>
<a name="ln244">static void		fxp_discard_rfabuf(struct fxp_softc *sc,</a>
<a name="ln245">			    struct fxp_rx *rxp);</a>
<a name="ln246">static int		fxp_new_rfabuf(struct fxp_softc *sc,</a>
<a name="ln247">			    struct fxp_rx *rxp);</a>
<a name="ln248">static int		fxp_mc_addrs(struct fxp_softc *sc);</a>
<a name="ln249">static void		fxp_mc_setup(struct fxp_softc *sc);</a>
<a name="ln250">static uint16_t		fxp_eeprom_getword(struct fxp_softc *sc, int offset,</a>
<a name="ln251">			    int autosize);</a>
<a name="ln252">static void 		fxp_eeprom_putword(struct fxp_softc *sc, int offset,</a>
<a name="ln253">			    uint16_t data);</a>
<a name="ln254">static void		fxp_autosize_eeprom(struct fxp_softc *sc);</a>
<a name="ln255">static void		fxp_load_eeprom(struct fxp_softc *sc);</a>
<a name="ln256">static void		fxp_read_eeprom(struct fxp_softc *sc, u_short *data,</a>
<a name="ln257">			    int offset, int words);</a>
<a name="ln258">static void		fxp_write_eeprom(struct fxp_softc *sc, u_short *data,</a>
<a name="ln259">			    int offset, int words);</a>
<a name="ln260">static int		fxp_ifmedia_upd(if_t ifp);</a>
<a name="ln261">static void		fxp_ifmedia_sts(if_t ifp,</a>
<a name="ln262">			    struct ifmediareq *ifmr);</a>
<a name="ln263">static int		fxp_serial_ifmedia_upd(if_t ifp);</a>
<a name="ln264">static void		fxp_serial_ifmedia_sts(if_t ifp,</a>
<a name="ln265">			    struct ifmediareq *ifmr);</a>
<a name="ln266">static int		fxp_miibus_readreg(device_t dev, int phy, int reg);</a>
<a name="ln267">static int		fxp_miibus_writereg(device_t dev, int phy, int reg,</a>
<a name="ln268">			    int value);</a>
<a name="ln269">static void		fxp_miibus_statchg(device_t dev);</a>
<a name="ln270">static void		fxp_load_ucode(struct fxp_softc *sc);</a>
<a name="ln271">static void		fxp_update_stats(struct fxp_softc *sc);</a>
<a name="ln272">static void		fxp_sysctl_node(struct fxp_softc *sc);</a>
<a name="ln273">static int		sysctl_int_range(SYSCTL_HANDLER_ARGS,</a>
<a name="ln274">			    int low, int high);</a>
<a name="ln275">static int		sysctl_hw_fxp_bundle_max(SYSCTL_HANDLER_ARGS);</a>
<a name="ln276">static int		sysctl_hw_fxp_int_delay(SYSCTL_HANDLER_ARGS);</a>
<a name="ln277">static void 		fxp_scb_wait(struct fxp_softc *sc);</a>
<a name="ln278">static void		fxp_scb_cmd(struct fxp_softc *sc, int cmd);</a>
<a name="ln279">static void		fxp_dma_wait(struct fxp_softc *sc,</a>
<a name="ln280">			    volatile uint16_t *status, bus_dma_tag_t dmat,</a>
<a name="ln281">			    bus_dmamap_t map);</a>
<a name="ln282"> </a>
<a name="ln283">static device_method_t fxp_methods[] = {</a>
<a name="ln284">	/* Device interface */</a>
<a name="ln285">	DEVMETHOD(device_probe,		fxp_probe),</a>
<a name="ln286">	DEVMETHOD(device_attach,	fxp_attach),</a>
<a name="ln287">	DEVMETHOD(device_detach,	fxp_detach),</a>
<a name="ln288">	DEVMETHOD(device_shutdown,	fxp_shutdown),</a>
<a name="ln289">	DEVMETHOD(device_suspend,	fxp_suspend),</a>
<a name="ln290">	DEVMETHOD(device_resume,	fxp_resume),</a>
<a name="ln291"> </a>
<a name="ln292">	/* MII interface */</a>
<a name="ln293">	DEVMETHOD(miibus_readreg,	fxp_miibus_readreg),</a>
<a name="ln294">	DEVMETHOD(miibus_writereg,	fxp_miibus_writereg),</a>
<a name="ln295">	DEVMETHOD(miibus_statchg,	fxp_miibus_statchg),</a>
<a name="ln296"> </a>
<a name="ln297">	DEVMETHOD_END</a>
<a name="ln298">};</a>
<a name="ln299"> </a>
<a name="ln300">static driver_t fxp_driver = {</a>
<a name="ln301">	&quot;fxp&quot;,</a>
<a name="ln302">	fxp_methods,</a>
<a name="ln303">	sizeof(struct fxp_softc),</a>
<a name="ln304">};</a>
<a name="ln305"> </a>
<a name="ln306">static devclass_t fxp_devclass;</a>
<a name="ln307"> </a>
<a name="ln308">DRIVER_MODULE_ORDERED(fxp, pci, fxp_driver, fxp_devclass, NULL, NULL,</a>
<a name="ln309">    SI_ORDER_ANY);</a>
<a name="ln310">MODULE_PNP_INFO(&quot;U16:vendor;U16:device&quot;, pci, fxp, fxp_ident_table,</a>
<a name="ln311">    nitems(fxp_ident_table) - 1);</a>
<a name="ln312">DRIVER_MODULE(miibus, fxp, miibus_driver, miibus_devclass, NULL, NULL);</a>
<a name="ln313"> </a>
<a name="ln314">static struct resource_spec fxp_res_spec_mem[] = {</a>
<a name="ln315">	{ SYS_RES_MEMORY,	FXP_PCI_MMBA,	RF_ACTIVE },</a>
<a name="ln316">	{ SYS_RES_IRQ,		0,		RF_ACTIVE | RF_SHAREABLE },</a>
<a name="ln317">	{ -1, 0 }</a>
<a name="ln318">};</a>
<a name="ln319"> </a>
<a name="ln320">static struct resource_spec fxp_res_spec_io[] = {</a>
<a name="ln321">	{ SYS_RES_IOPORT,	FXP_PCI_IOBA,	RF_ACTIVE },</a>
<a name="ln322">	{ SYS_RES_IRQ,		0,		RF_ACTIVE | RF_SHAREABLE },</a>
<a name="ln323">	{ -1, 0 }</a>
<a name="ln324">};</a>
<a name="ln325"> </a>
<a name="ln326">/*</a>
<a name="ln327"> * Wait for the previous command to be accepted (but not necessarily</a>
<a name="ln328"> * completed).</a>
<a name="ln329"> */</a>
<a name="ln330">static void</a>
<a name="ln331">fxp_scb_wait(struct fxp_softc *sc)</a>
<a name="ln332">{</a>
<a name="ln333">	union {</a>
<a name="ln334">		uint16_t w;</a>
<a name="ln335">		uint8_t b[2];</a>
<a name="ln336">	} flowctl;</a>
<a name="ln337">	int i = 10000;</a>
<a name="ln338"> </a>
<a name="ln339">	while (CSR_READ_1(sc, FXP_CSR_SCB_COMMAND) &amp;&amp; --i)</a>
<a name="ln340">		DELAY(2);</a>
<a name="ln341">	if (i == 0) {</a>
<a name="ln342">		flowctl.b[0] = CSR_READ_1(sc, FXP_CSR_FC_THRESH);</a>
<a name="ln343">		flowctl.b[1] = CSR_READ_1(sc, FXP_CSR_FC_STATUS);</a>
<a name="ln344">		device_printf(sc-&gt;dev, &quot;SCB timeout: 0x%x 0x%x 0x%x 0x%x\n&quot;,</a>
<a name="ln345">		    CSR_READ_1(sc, FXP_CSR_SCB_COMMAND),</a>
<a name="ln346">		    CSR_READ_1(sc, FXP_CSR_SCB_STATACK),</a>
<a name="ln347">		    CSR_READ_1(sc, FXP_CSR_SCB_RUSCUS), flowctl.w);</a>
<a name="ln348">	}</a>
<a name="ln349">}</a>
<a name="ln350"> </a>
<a name="ln351">static void</a>
<a name="ln352">fxp_scb_cmd(struct fxp_softc *sc, int cmd)</a>
<a name="ln353">{</a>
<a name="ln354"> </a>
<a name="ln355">	if (cmd == FXP_SCB_COMMAND_CU_RESUME &amp;&amp; sc-&gt;cu_resume_bug) {</a>
<a name="ln356">		CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_CB_COMMAND_NOP);</a>
<a name="ln357">		fxp_scb_wait(sc);</a>
<a name="ln358">	}</a>
<a name="ln359">	CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, cmd);</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362">static void</a>
<a name="ln363">fxp_dma_wait(struct fxp_softc *sc, volatile uint16_t *status,</a>
<a name="ln364">    bus_dma_tag_t dmat, bus_dmamap_t map)</a>
<a name="ln365">{</a>
<a name="ln366">	int i;</a>
<a name="ln367"> </a>
<a name="ln368">	for (i = 10000; i &gt; 0; i--) {</a>
<a name="ln369">		DELAY(2);</a>
<a name="ln370">		bus_dmamap_sync(dmat, map,</a>
<a name="ln371">		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);</a>
<a name="ln372">		if ((le16toh(*status) &amp; FXP_CB_STATUS_C) != 0)</a>
<a name="ln373">			break;</a>
<a name="ln374">	}</a>
<a name="ln375">	if (i == 0)</a>
<a name="ln376">		device_printf(sc-&gt;dev, &quot;DMA timeout\n&quot;);</a>
<a name="ln377">}</a>
<a name="ln378"> </a>
<a name="ln379">static const struct fxp_ident *</a>
<a name="ln380">fxp_find_ident(device_t dev)</a>
<a name="ln381">{</a>
<a name="ln382">	uint16_t vendor;</a>
<a name="ln383">	uint16_t device;</a>
<a name="ln384">	uint8_t revid;</a>
<a name="ln385">	const struct fxp_ident *ident;</a>
<a name="ln386"> </a>
<a name="ln387">	vendor = pci_get_vendor(dev);</a>
<a name="ln388">	device = pci_get_device(dev);</a>
<a name="ln389">	revid = pci_get_revid(dev);</a>
<a name="ln390">	for (ident = fxp_ident_table; ident-&gt;name != NULL; ident++) {</a>
<a name="ln391">		if (ident-&gt;vendor == vendor &amp;&amp; ident-&gt;device == device &amp;&amp;</a>
<a name="ln392">		    (ident-&gt;revid == revid || ident-&gt;revid == -1)) {</a>
<a name="ln393">			return (ident);</a>
<a name="ln394">		}</a>
<a name="ln395">	}</a>
<a name="ln396">	return (NULL);</a>
<a name="ln397">}</a>
<a name="ln398"> </a>
<a name="ln399">/*</a>
<a name="ln400"> * Return identification string if this device is ours.</a>
<a name="ln401"> */</a>
<a name="ln402">static int</a>
<a name="ln403">fxp_probe(device_t dev)</a>
<a name="ln404">{</a>
<a name="ln405">	const struct fxp_ident *ident;</a>
<a name="ln406"> </a>
<a name="ln407">	ident = fxp_find_ident(dev);</a>
<a name="ln408">	if (ident != NULL) {</a>
<a name="ln409">		device_set_desc(dev, ident-&gt;name);</a>
<a name="ln410">		return (BUS_PROBE_DEFAULT);</a>
<a name="ln411">	}</a>
<a name="ln412">	return (ENXIO);</a>
<a name="ln413">}</a>
<a name="ln414"> </a>
<a name="ln415">static void</a>
<a name="ln416">fxp_dma_map_addr(void *arg, bus_dma_segment_t *segs, int nseg, int error)</a>
<a name="ln417">{</a>
<a name="ln418">	uint32_t *addr;</a>
<a name="ln419"> </a>
<a name="ln420">	if (error)</a>
<a name="ln421">		return;</a>
<a name="ln422"> </a>
<a name="ln423">	KASSERT(nseg == 1, (&quot;too many DMA segments, %d should be 1&quot;, nseg));</a>
<a name="ln424">	addr = arg;</a>
<a name="ln425">	*addr = segs-&gt;ds_addr;</a>
<a name="ln426">}</a>
<a name="ln427"> </a>
<a name="ln428">static int</a>
<a name="ln429">fxp_attach(device_t dev)</a>
<a name="ln430">{</a>
<a name="ln431">	struct fxp_softc *sc;</a>
<a name="ln432">	struct fxp_cb_tx *tcbp;</a>
<a name="ln433">	struct fxp_tx *txp;</a>
<a name="ln434">	struct fxp_rx *rxp;</a>
<a name="ln435">	if_t ifp;</a>
<a name="ln436">	uint32_t val;</a>
<a name="ln437">	uint16_t data;</a>
<a name="ln438">	u_char eaddr[ETHER_ADDR_LEN];</a>
<a name="ln439">	int error, flags, i, pmc, prefer_iomap;</a>
<a name="ln440"> </a>
<a name="ln441">	error = 0;</a>
<a name="ln442">	sc = device_get_softc(dev);</a>
<a name="ln443">	sc-&gt;dev = dev;</a>
<a name="ln444">	mtx_init(&amp;sc-&gt;sc_mtx, device_get_nameunit(dev), MTX_NETWORK_LOCK,</a>
<a name="ln445">	    MTX_DEF);</a>
<a name="ln446">	callout_init_mtx(&amp;sc-&gt;stat_ch, &amp;sc-&gt;sc_mtx, 0);</a>
<a name="ln447">	ifmedia_init(&amp;sc-&gt;sc_media, 0, fxp_serial_ifmedia_upd,</a>
<a name="ln448">	    fxp_serial_ifmedia_sts);</a>
<a name="ln449"> </a>
<a name="ln450">	ifp = sc-&gt;ifp = if_gethandle(IFT_ETHER);</a>
<a name="ln451">	if (ifp == (void *)NULL) {</a>
<a name="ln452">		device_printf(dev, &quot;can not if_alloc()\n&quot;);</a>
<a name="ln453">		error = ENOSPC;</a>
<a name="ln454">		goto fail;</a>
<a name="ln455">	}</a>
<a name="ln456"> </a>
<a name="ln457">	/*</a>
<a name="ln458">	 * Enable bus mastering.</a>
<a name="ln459">	 */</a>
<a name="ln460">	pci_enable_busmaster(dev);</a>
<a name="ln461"> </a>
<a name="ln462">	/*</a>
<a name="ln463">	 * Figure out which we should try first - memory mapping or i/o mapping?</a>
<a name="ln464">	 * We default to memory mapping. Then we accept an override from the</a>
<a name="ln465">	 * command line. Then we check to see which one is enabled.</a>
<a name="ln466">	 */</a>
<a name="ln467">	prefer_iomap = 0;</a>
<a name="ln468">	resource_int_value(device_get_name(dev), device_get_unit(dev),</a>
<a name="ln469">	    &quot;prefer_iomap&quot;, &amp;prefer_iomap);</a>
<a name="ln470">	if (prefer_iomap)</a>
<a name="ln471">		sc-&gt;fxp_spec = fxp_res_spec_io;</a>
<a name="ln472">	else</a>
<a name="ln473">		sc-&gt;fxp_spec = fxp_res_spec_mem;</a>
<a name="ln474"> </a>
<a name="ln475">	error = bus_alloc_resources(dev, sc-&gt;fxp_spec, sc-&gt;fxp_res);</a>
<a name="ln476">	if (error) {</a>
<a name="ln477">		if (sc-&gt;fxp_spec == fxp_res_spec_mem)</a>
<a name="ln478">			sc-&gt;fxp_spec = fxp_res_spec_io;</a>
<a name="ln479">		else</a>
<a name="ln480">			sc-&gt;fxp_spec = fxp_res_spec_mem;</a>
<a name="ln481">		error = bus_alloc_resources(dev, sc-&gt;fxp_spec, sc-&gt;fxp_res);</a>
<a name="ln482">	}</a>
<a name="ln483">	if (error) {</a>
<a name="ln484">		device_printf(dev, &quot;could not allocate resources\n&quot;);</a>
<a name="ln485">		error = ENXIO;</a>
<a name="ln486">		goto fail;</a>
<a name="ln487">	}</a>
<a name="ln488"> </a>
<a name="ln489">	if (bootverbose) {</a>
<a name="ln490">		device_printf(dev, &quot;using %s space register mapping\n&quot;,</a>
<a name="ln491">		   sc-&gt;fxp_spec == fxp_res_spec_mem ? &quot;memory&quot; : &quot;I/O&quot;);</a>
<a name="ln492">	}</a>
<a name="ln493"> </a>
<a name="ln494">	/*</a>
<a name="ln495">	 * Put CU/RU idle state and prepare full reset.</a>
<a name="ln496">	 */</a>
<a name="ln497">	CSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SELECTIVE_RESET);</a>
<a name="ln498">	DELAY(10);</a>
<a name="ln499">	/* Full reset and disable interrupts. */</a>
<a name="ln500">	CSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SOFTWARE_RESET);</a>
<a name="ln501">	DELAY(10);</a>
<a name="ln502">	CSR_WRITE_1(sc, FXP_CSR_SCB_INTRCNTL, FXP_SCB_INTR_DISABLE);</a>
<a name="ln503"> </a>
<a name="ln504">	/*</a>
<a name="ln505">	 * Find out how large of an SEEPROM we have.</a>
<a name="ln506">	 */</a>
<a name="ln507">	fxp_autosize_eeprom(sc);</a>
<a name="ln508">	fxp_load_eeprom(sc);</a>
<a name="ln509"> </a>
<a name="ln510">	/*</a>
<a name="ln511">	 * Find out the chip revision; lump all 82557 revs together.</a>
<a name="ln512">	 */</a>
<a name="ln513">	sc-&gt;ident = fxp_find_ident(dev);</a>
<a name="ln514">	if (sc-&gt;ident-&gt;ich &gt; 0) {</a>
<a name="ln515">		/* Assume ICH controllers are 82559. */</a>
<a name="ln516">		sc-&gt;revision = FXP_REV_82559_A0;</a>
<a name="ln517">	} else {</a>
<a name="ln518">		data = sc-&gt;eeprom[FXP_EEPROM_MAP_CNTR];</a>
<a name="ln519">		if ((data &gt;&gt; 8) == 1)</a>
<a name="ln520">			sc-&gt;revision = FXP_REV_82557;</a>
<a name="ln521">		else</a>
<a name="ln522">			sc-&gt;revision = pci_get_revid(dev);</a>
<a name="ln523">	}</a>
<a name="ln524"> </a>
<a name="ln525">	/*</a>
<a name="ln526">	 * Check availability of WOL. 82559ER does not support WOL.</a>
<a name="ln527">	 */</a>
<a name="ln528">	if (sc-&gt;revision &gt;= FXP_REV_82558_A4 &amp;&amp;</a>
<a name="ln529">	    sc-&gt;revision != FXP_REV_82559S_A) {</a>
<a name="ln530">		data = sc-&gt;eeprom[FXP_EEPROM_MAP_ID];</a>
<a name="ln531">		if ((data &amp; 0x20) != 0 &amp;&amp;</a>
<a name="ln532">		    pci_find_cap(sc-&gt;dev, PCIY_PMG, &amp;pmc) == 0)</a>
<a name="ln533">			sc-&gt;flags |= FXP_FLAG_WOLCAP;</a>
<a name="ln534">	}</a>
<a name="ln535"> </a>
<a name="ln536">	if (sc-&gt;revision == FXP_REV_82550_C) {</a>
<a name="ln537">		/*</a>
<a name="ln538">		 * 82550C with server extension requires microcode to</a>
<a name="ln539">		 * receive fragmented UDP datagrams.  However if the</a>
<a name="ln540">		 * microcode is used for client-only featured 82550C</a>
<a name="ln541">		 * it locks up controller.</a>
<a name="ln542">		 */</a>
<a name="ln543">		data = sc-&gt;eeprom[FXP_EEPROM_MAP_COMPAT];</a>
<a name="ln544">		if ((data &amp; 0x0400) == 0)</a>
<a name="ln545">			sc-&gt;flags |= FXP_FLAG_NO_UCODE;</a>
<a name="ln546">	}</a>
<a name="ln547"> </a>
<a name="ln548">	/* Receiver lock-up workaround detection. */</a>
<a name="ln549">	if (sc-&gt;revision &lt; FXP_REV_82558_A4) {</a>
<a name="ln550">		data = sc-&gt;eeprom[FXP_EEPROM_MAP_COMPAT];</a>
<a name="ln551">		if ((data &amp; 0x03) != 0x03) {</a>
<a name="ln552">			sc-&gt;flags |= FXP_FLAG_RXBUG;</a>
<a name="ln553">			device_printf(dev, &quot;Enabling Rx lock-up workaround\n&quot;);</a>
<a name="ln554">		}</a>
<a name="ln555">	}</a>
<a name="ln556"> </a>
<a name="ln557">	/*</a>
<a name="ln558">	 * Determine whether we must use the 503 serial interface.</a>
<a name="ln559">	 */</a>
<a name="ln560">	data = sc-&gt;eeprom[FXP_EEPROM_MAP_PRI_PHY];</a>
<a name="ln561">	if (sc-&gt;revision == FXP_REV_82557 &amp;&amp; (data &amp; FXP_PHY_DEVICE_MASK) != 0</a>
<a name="ln562">	    &amp;&amp; (data &amp; FXP_PHY_SERIAL_ONLY))</a>
<a name="ln563">		sc-&gt;flags |= FXP_FLAG_SERIAL_MEDIA;</a>
<a name="ln564"> </a>
<a name="ln565">	fxp_sysctl_node(sc);</a>
<a name="ln566">	/*</a>
<a name="ln567">	 * Enable workarounds for certain chip revision deficiencies.</a>
<a name="ln568">	 *</a>
<a name="ln569">	 * Systems based on the ICH2/ICH2-M chip from Intel, and possibly</a>
<a name="ln570">	 * some systems based a normal 82559 design, have a defect where</a>
<a name="ln571">	 * the chip can cause a PCI protocol violation if it receives</a>
<a name="ln572">	 * a CU_RESUME command when it is entering the IDLE state.  The</a>
<a name="ln573">	 * workaround is to disable Dynamic Standby Mode, so the chip never</a>
<a name="ln574">	 * deasserts CLKRUN#, and always remains in an active state.</a>
<a name="ln575">	 *</a>
<a name="ln576">	 * See Intel 82801BA/82801BAM Specification Update, Errata #30.</a>
<a name="ln577">	 */</a>
<a name="ln578">	if ((sc-&gt;ident-&gt;ich &gt;= 2 &amp;&amp; sc-&gt;ident-&gt;ich &lt;= 3) ||</a>
<a name="ln579">	    (sc-&gt;ident-&gt;ich == 0 &amp;&amp; sc-&gt;revision &gt;= FXP_REV_82559_A0)) {</a>
<a name="ln580">		data = sc-&gt;eeprom[FXP_EEPROM_MAP_ID];</a>
<a name="ln581">		if (data &amp; 0x02) {			/* STB enable */</a>
<a name="ln582">			uint16_t cksum;</a>
<a name="ln583">			int i;</a>
<a name="ln584"> </a>
<a name="ln585">			device_printf(dev,</a>
<a name="ln586">			    &quot;Disabling dynamic standby mode in EEPROM\n&quot;);</a>
<a name="ln587">			data &amp;= ~0x02;</a>
<a name="ln588">			sc-&gt;eeprom[FXP_EEPROM_MAP_ID] = data;</a>
<a name="ln589">			fxp_write_eeprom(sc, &amp;data, FXP_EEPROM_MAP_ID, 1);</a>
<a name="ln590">			device_printf(dev, &quot;New EEPROM ID: 0x%x\n&quot;, data);</a>
<a name="ln591">			cksum = 0;</a>
<a name="ln592">			for (i = 0; i &lt; (1 &lt;&lt; sc-&gt;eeprom_size) - 1; i++)</a>
<a name="ln593">				cksum += sc-&gt;eeprom[i];</a>
<a name="ln594">			i = (1 &lt;&lt; sc-&gt;eeprom_size) - 1;</a>
<a name="ln595">			cksum = 0xBABA - cksum;</a>
<a name="ln596">			fxp_write_eeprom(sc, &amp;cksum, i, 1);</a>
<a name="ln597">			device_printf(dev,</a>
<a name="ln598">			    &quot;EEPROM checksum @ 0x%x: 0x%x -&gt; 0x%x\n&quot;,</a>
<a name="ln599">			    i, sc-&gt;eeprom[i], cksum);</a>
<a name="ln600">			sc-&gt;eeprom[i] = cksum;</a>
<a name="ln601">			/*</a>
<a name="ln602">			 * If the user elects to continue, try the software</a>
<a name="ln603">			 * workaround, as it is better than nothing.</a>
<a name="ln604">			 */</a>
<a name="ln605">			sc-&gt;flags |= FXP_FLAG_CU_RESUME_BUG;</a>
<a name="ln606">		}</a>
<a name="ln607">	}</a>
<a name="ln608"> </a>
<a name="ln609">	/*</a>
<a name="ln610">	 * If we are not a 82557 chip, we can enable extended features.</a>
<a name="ln611">	 */</a>
<a name="ln612">	if (sc-&gt;revision != FXP_REV_82557) {</a>
<a name="ln613">		/*</a>
<a name="ln614">		 * If MWI is enabled in the PCI configuration, and there</a>
<a name="ln615">		 * is a valid cacheline size (8 or 16 dwords), then tell</a>
<a name="ln616">		 * the board to turn on MWI.</a>
<a name="ln617">		 */</a>
<a name="ln618">		val = pci_read_config(dev, PCIR_COMMAND, 2);</a>
<a name="ln619">		if (val &amp; PCIM_CMD_MWRICEN &amp;&amp;</a>
<a name="ln620">		    pci_read_config(dev, PCIR_CACHELNSZ, 1) != 0)</a>
<a name="ln621">			sc-&gt;flags |= FXP_FLAG_MWI_ENABLE;</a>
<a name="ln622"> </a>
<a name="ln623">		/* turn on the extended TxCB feature */</a>
<a name="ln624">		sc-&gt;flags |= FXP_FLAG_EXT_TXCB;</a>
<a name="ln625"> </a>
<a name="ln626">		/* enable reception of long frames for VLAN */</a>
<a name="ln627">		sc-&gt;flags |= FXP_FLAG_LONG_PKT_EN;</a>
<a name="ln628">	} else {</a>
<a name="ln629">		/* a hack to get long VLAN frames on a 82557 */</a>
<a name="ln630">		sc-&gt;flags |= FXP_FLAG_SAVE_BAD;</a>
<a name="ln631">	}</a>
<a name="ln632"> </a>
<a name="ln633">	/* For 82559 or later chips, Rx checksum offload is supported. */</a>
<a name="ln634">	if (sc-&gt;revision &gt;= FXP_REV_82559_A0) {</a>
<a name="ln635">		/* 82559ER does not support Rx checksum offloading. */</a>
<a name="ln636">		if (sc-&gt;ident-&gt;device != 0x1209)</a>
<a name="ln637">			sc-&gt;flags |= FXP_FLAG_82559_RXCSUM;</a>
<a name="ln638">	}</a>
<a name="ln639">	/*</a>
<a name="ln640">	 * Enable use of extended RFDs and TCBs for 82550</a>
<a name="ln641">	 * and later chips. Note: we need extended TXCB support</a>
<a name="ln642">	 * too, but that's already enabled by the code above.</a>
<a name="ln643">	 * Be careful to do this only on the right devices.</a>
<a name="ln644">	 */</a>
<a name="ln645">	if (sc-&gt;revision == FXP_REV_82550 || sc-&gt;revision == FXP_REV_82550_C ||</a>
<a name="ln646">	    sc-&gt;revision == FXP_REV_82551_E || sc-&gt;revision == FXP_REV_82551_F</a>
<a name="ln647">	    || sc-&gt;revision == FXP_REV_82551_10) {</a>
<a name="ln648">		sc-&gt;rfa_size = sizeof (struct fxp_rfa);</a>
<a name="ln649">		sc-&gt;tx_cmd = FXP_CB_COMMAND_IPCBXMIT;</a>
<a name="ln650">		sc-&gt;flags |= FXP_FLAG_EXT_RFA;</a>
<a name="ln651">		/* Use extended RFA instead of 82559 checksum mode. */</a>
<a name="ln652">		sc-&gt;flags &amp;= ~FXP_FLAG_82559_RXCSUM;</a>
<a name="ln653">	} else {</a>
<a name="ln654">		sc-&gt;rfa_size = sizeof (struct fxp_rfa) - FXP_RFAX_LEN;</a>
<a name="ln655">		sc-&gt;tx_cmd = FXP_CB_COMMAND_XMIT;</a>
<a name="ln656">	}</a>
<a name="ln657"> </a>
<a name="ln658">	/*</a>
<a name="ln659">	 * Allocate DMA tags and DMA safe memory.</a>
<a name="ln660">	 */</a>
<a name="ln661">	sc-&gt;maxtxseg = FXP_NTXSEG;</a>
<a name="ln662">	sc-&gt;maxsegsize = MCLBYTES;</a>
<a name="ln663">	if (sc-&gt;flags &amp; FXP_FLAG_EXT_RFA) {</a>
<a name="ln664">		sc-&gt;maxtxseg--;</a>
<a name="ln665">		sc-&gt;maxsegsize = FXP_TSO_SEGSIZE;</a>
<a name="ln666">	}</a>
<a name="ln667">	error = bus_dma_tag_create(bus_get_dma_tag(dev), 2, 0,</a>
<a name="ln668">	    BUS_SPACE_MAXADDR_32BIT, BUS_SPACE_MAXADDR, NULL, NULL,</a>
<a name="ln669">	    sc-&gt;maxsegsize * sc-&gt;maxtxseg + sizeof(struct ether_vlan_header),</a>
<a name="ln670">	    sc-&gt;maxtxseg, sc-&gt;maxsegsize, 0,</a>
<a name="ln671">	    busdma_lock_mutex, &amp;Giant, &amp;sc-&gt;fxp_txmtag);</a>
<a name="ln672">	if (error) {</a>
<a name="ln673">		device_printf(dev, &quot;could not create TX DMA tag\n&quot;);</a>
<a name="ln674">		goto fail;</a>
<a name="ln675">	}</a>
<a name="ln676"> </a>
<a name="ln677">	error = bus_dma_tag_create(bus_get_dma_tag(dev), 2, 0,</a>
<a name="ln678">	    BUS_SPACE_MAXADDR_32BIT, BUS_SPACE_MAXADDR, NULL, NULL,</a>
<a name="ln679">	    MCLBYTES, 1, MCLBYTES, 0,</a>
<a name="ln680">	    busdma_lock_mutex, &amp;Giant, &amp;sc-&gt;fxp_rxmtag);</a>
<a name="ln681">	if (error) {</a>
<a name="ln682">		device_printf(dev, &quot;could not create RX DMA tag\n&quot;);</a>
<a name="ln683">		goto fail;</a>
<a name="ln684">	}</a>
<a name="ln685"> </a>
<a name="ln686">	error = bus_dma_tag_create(bus_get_dma_tag(dev), 4, 0,</a>
<a name="ln687">	    BUS_SPACE_MAXADDR_32BIT, BUS_SPACE_MAXADDR, NULL, NULL,</a>
<a name="ln688">	    sizeof(struct fxp_stats), 1, sizeof(struct fxp_stats), 0,</a>
<a name="ln689">	    busdma_lock_mutex, &amp;Giant, &amp;sc-&gt;fxp_stag);</a>
<a name="ln690">	if (error) {</a>
<a name="ln691">		device_printf(dev, &quot;could not create stats DMA tag\n&quot;);</a>
<a name="ln692">		goto fail;</a>
<a name="ln693">	}</a>
<a name="ln694"> </a>
<a name="ln695">	error = bus_dmamem_alloc(sc-&gt;fxp_stag, (void **)&amp;sc-&gt;fxp_stats,</a>
<a name="ln696">	    BUS_DMA_NOWAIT | BUS_DMA_COHERENT | BUS_DMA_ZERO, &amp;sc-&gt;fxp_smap);</a>
<a name="ln697">	if (error) {</a>
<a name="ln698">		device_printf(dev, &quot;could not allocate stats DMA memory\n&quot;);</a>
<a name="ln699">		goto fail;</a>
<a name="ln700">	}</a>
<a name="ln701">	error = bus_dmamap_load(sc-&gt;fxp_stag, sc-&gt;fxp_smap, sc-&gt;fxp_stats,</a>
<a name="ln702">	    sizeof(struct fxp_stats), fxp_dma_map_addr, &amp;sc-&gt;stats_addr,</a>
<a name="ln703">	    BUS_DMA_NOWAIT);</a>
<a name="ln704">	if (error) {</a>
<a name="ln705">		device_printf(dev, &quot;could not load the stats DMA buffer\n&quot;);</a>
<a name="ln706">		goto fail;</a>
<a name="ln707">	}</a>
<a name="ln708"> </a>
<a name="ln709">	error = bus_dma_tag_create(bus_get_dma_tag(dev), 4, 0,</a>
<a name="ln710">	    BUS_SPACE_MAXADDR_32BIT, BUS_SPACE_MAXADDR, NULL, NULL,</a>
<a name="ln711">	    FXP_TXCB_SZ, 1, FXP_TXCB_SZ, 0,</a>
<a name="ln712">	    busdma_lock_mutex, &amp;Giant, &amp;sc-&gt;cbl_tag);</a>
<a name="ln713">	if (error) {</a>
<a name="ln714">		device_printf(dev, &quot;could not create TxCB DMA tag\n&quot;);</a>
<a name="ln715">		goto fail;</a>
<a name="ln716">	}</a>
<a name="ln717"> </a>
<a name="ln718">	error = bus_dmamem_alloc(sc-&gt;cbl_tag, (void **)&amp;sc-&gt;fxp_desc.cbl_list,</a>
<a name="ln719">	    BUS_DMA_NOWAIT | BUS_DMA_COHERENT | BUS_DMA_ZERO, &amp;sc-&gt;cbl_map);</a>
<a name="ln720">	if (error) {</a>
<a name="ln721">		device_printf(dev, &quot;could not allocate TxCB DMA memory\n&quot;);</a>
<a name="ln722">		goto fail;</a>
<a name="ln723">	}</a>
<a name="ln724"> </a>
<a name="ln725">	error = bus_dmamap_load(sc-&gt;cbl_tag, sc-&gt;cbl_map,</a>
<a name="ln726">	    sc-&gt;fxp_desc.cbl_list, FXP_TXCB_SZ, fxp_dma_map_addr,</a>
<a name="ln727">	    &amp;sc-&gt;fxp_desc.cbl_addr, BUS_DMA_NOWAIT);</a>
<a name="ln728">	if (error) {</a>
<a name="ln729">		device_printf(dev, &quot;could not load TxCB DMA buffer\n&quot;);</a>
<a name="ln730">		goto fail;</a>
<a name="ln731">	}</a>
<a name="ln732"> </a>
<a name="ln733">	error = bus_dma_tag_create(bus_get_dma_tag(dev), 4, 0,</a>
<a name="ln734">	    BUS_SPACE_MAXADDR_32BIT, BUS_SPACE_MAXADDR, NULL, NULL,</a>
<a name="ln735">	    sizeof(struct fxp_cb_mcs), 1, sizeof(struct fxp_cb_mcs), 0,</a>
<a name="ln736">	    busdma_lock_mutex, &amp;Giant, &amp;sc-&gt;mcs_tag);</a>
<a name="ln737">	if (error) {</a>
<a name="ln738">		device_printf(dev,</a>
<a name="ln739">		    &quot;could not create multicast setup DMA tag\n&quot;);</a>
<a name="ln740">		goto fail;</a>
<a name="ln741">	}</a>
<a name="ln742"> </a>
<a name="ln743">	error = bus_dmamem_alloc(sc-&gt;mcs_tag, (void **)&amp;sc-&gt;mcsp,</a>
<a name="ln744">	    BUS_DMA_NOWAIT | BUS_DMA_COHERENT | BUS_DMA_ZERO, &amp;sc-&gt;mcs_map);</a>
<a name="ln745">	if (error) {</a>
<a name="ln746">		device_printf(dev,</a>
<a name="ln747">		    &quot;could not allocate multicast setup DMA memory\n&quot;);</a>
<a name="ln748">		goto fail;</a>
<a name="ln749">	}</a>
<a name="ln750">	error = bus_dmamap_load(sc-&gt;mcs_tag, sc-&gt;mcs_map, sc-&gt;mcsp,</a>
<a name="ln751">	    sizeof(struct fxp_cb_mcs), fxp_dma_map_addr, &amp;sc-&gt;mcs_addr,</a>
<a name="ln752">	    BUS_DMA_NOWAIT);</a>
<a name="ln753">	if (error) {</a>
<a name="ln754">		device_printf(dev,</a>
<a name="ln755">		    &quot;can't load the multicast setup DMA buffer\n&quot;);</a>
<a name="ln756">		goto fail;</a>
<a name="ln757">	}</a>
<a name="ln758"> </a>
<a name="ln759">	/*</a>
<a name="ln760">	 * Pre-allocate the TX DMA maps and setup the pointers to</a>
<a name="ln761">	 * the TX command blocks.</a>
<a name="ln762">	 */</a>
<a name="ln763">	txp = sc-&gt;fxp_desc.tx_list;</a>
<a name="ln764">	tcbp = sc-&gt;fxp_desc.cbl_list;</a>
<a name="ln765">	for (i = 0; i &lt; FXP_NTXCB; i++) {</a>
<a name="ln766">		txp[i].tx_cb = tcbp + i;</a>
<a name="ln767">		error = bus_dmamap_create(sc-&gt;fxp_txmtag, 0, &amp;txp[i].tx_map);</a>
<a name="ln768">		if (error) {</a>
<a name="ln769">			device_printf(dev, &quot;can't create DMA map for TX\n&quot;);</a>
<a name="ln770">			goto fail;</a>
<a name="ln771">		}</a>
<a name="ln772">	}</a>
<a name="ln773">	error = bus_dmamap_create(sc-&gt;fxp_rxmtag, 0, &amp;sc-&gt;spare_map);</a>
<a name="ln774">	if (error) {</a>
<a name="ln775">		device_printf(dev, &quot;can't create spare DMA map\n&quot;);</a>
<a name="ln776">		goto fail;</a>
<a name="ln777">	}</a>
<a name="ln778"> </a>
<a name="ln779">	/*</a>
<a name="ln780">	 * Pre-allocate our receive buffers.</a>
<a name="ln781">	 */</a>
<a name="ln782">	sc-&gt;fxp_desc.rx_head = sc-&gt;fxp_desc.rx_tail = NULL;</a>
<a name="ln783">	for (i = 0; i &lt; FXP_NRFABUFS; i++) {</a>
<a name="ln784">		rxp = &amp;sc-&gt;fxp_desc.rx_list[i];</a>
<a name="ln785">		error = bus_dmamap_create(sc-&gt;fxp_rxmtag, 0, &amp;rxp-&gt;rx_map);</a>
<a name="ln786">		if (error) {</a>
<a name="ln787">			device_printf(dev, &quot;can't create DMA map for RX\n&quot;);</a>
<a name="ln788">			goto fail;</a>
<a name="ln789">		}</a>
<a name="ln790">		if (fxp_new_rfabuf(sc, rxp) != 0) {</a>
<a name="ln791">			error = ENOMEM;</a>
<a name="ln792">			goto fail;</a>
<a name="ln793">		}</a>
<a name="ln794">		fxp_add_rfabuf(sc, rxp);</a>
<a name="ln795">	}</a>
<a name="ln796"> </a>
<a name="ln797">	/*</a>
<a name="ln798">	 * Read MAC address.</a>
<a name="ln799">	 */</a>
<a name="ln800">	eaddr[0] = sc-&gt;eeprom[FXP_EEPROM_MAP_IA0] &amp; 0xff;</a>
<a name="ln801">	eaddr[1] = sc-&gt;eeprom[FXP_EEPROM_MAP_IA0] &gt;&gt; 8;</a>
<a name="ln802">	eaddr[2] = sc-&gt;eeprom[FXP_EEPROM_MAP_IA1] &amp; 0xff;</a>
<a name="ln803">	eaddr[3] = sc-&gt;eeprom[FXP_EEPROM_MAP_IA1] &gt;&gt; 8;</a>
<a name="ln804">	eaddr[4] = sc-&gt;eeprom[FXP_EEPROM_MAP_IA2] &amp; 0xff;</a>
<a name="ln805">	eaddr[5] = sc-&gt;eeprom[FXP_EEPROM_MAP_IA2] &gt;&gt; 8;</a>
<a name="ln806">	if (bootverbose) {</a>
<a name="ln807">		device_printf(dev, &quot;PCI IDs: %04x %04x %04x %04x %04x\n&quot;,</a>
<a name="ln808">		    pci_get_vendor(dev), pci_get_device(dev),</a>
<a name="ln809">		    pci_get_subvendor(dev), pci_get_subdevice(dev),</a>
<a name="ln810">		    pci_get_revid(dev));</a>
<a name="ln811">		device_printf(dev, &quot;Dynamic Standby mode is %s\n&quot;,</a>
<a name="ln812">		    sc-&gt;eeprom[FXP_EEPROM_MAP_ID] &amp; 0x02 ? &quot;enabled&quot; :</a>
<a name="ln813">		    &quot;disabled&quot;);</a>
<a name="ln814">	}</a>
<a name="ln815"> </a>
<a name="ln816">	/*</a>
<a name="ln817">	 * If this is only a 10Mbps device, then there is no MII, and</a>
<a name="ln818">	 * the PHY will use a serial interface instead.</a>
<a name="ln819">	 *</a>
<a name="ln820">	 * The Seeq 80c24 AutoDUPLEX(tm) Ethernet Interface Adapter</a>
<a name="ln821">	 * doesn't have a programming interface of any sort.  The</a>
<a name="ln822">	 * media is sensed automatically based on how the link partner</a>
<a name="ln823">	 * is configured.  This is, in essence, manual configuration.</a>
<a name="ln824">	 */</a>
<a name="ln825">	if (sc-&gt;flags &amp; FXP_FLAG_SERIAL_MEDIA) {</a>
<a name="ln826">		ifmedia_add(&amp;sc-&gt;sc_media, IFM_ETHER|IFM_MANUAL, 0, NULL);</a>
<a name="ln827">		ifmedia_set(&amp;sc-&gt;sc_media, IFM_ETHER|IFM_MANUAL);</a>
<a name="ln828">	} else {</a>
<a name="ln829">		/*</a>
<a name="ln830">		 * i82557 wedge when isolating all of their PHYs.</a>
<a name="ln831">		 */</a>
<a name="ln832">		flags = MIIF_NOISOLATE;</a>
<a name="ln833">		if (sc-&gt;revision &gt;= FXP_REV_82558_A4)</a>
<a name="ln834">			flags |= MIIF_DOPAUSE;</a>
<a name="ln835">		error = mii_attach(dev, &amp;sc-&gt;miibus, ifp,</a>
<a name="ln836">		    (ifm_change_cb_t)fxp_ifmedia_upd,</a>
<a name="ln837">		    (ifm_stat_cb_t)fxp_ifmedia_sts, BMSR_DEFCAPMASK,</a>
<a name="ln838">		    MII_PHY_ANY, MII_OFFSET_ANY, flags);</a>
<a name="ln839">		if (error != 0) {</a>
<a name="ln840">			device_printf(dev, &quot;attaching PHYs failed\n&quot;);</a>
<a name="ln841">			goto fail;</a>
<a name="ln842">		}</a>
<a name="ln843">	}</a>
<a name="ln844"> </a>
<a name="ln845">	if_initname(ifp, device_get_name(dev), device_get_unit(dev));</a>
<a name="ln846">	if_setdev(ifp, dev);</a>
<a name="ln847">	if_setinitfn(ifp, fxp_init);</a>
<a name="ln848">	if_setsoftc(ifp, sc);</a>
<a name="ln849">	if_setflags(ifp, IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST);</a>
<a name="ln850">	if_setioctlfn(ifp, fxp_ioctl);</a>
<a name="ln851">	if_setstartfn(ifp, fxp_start);</a>
<a name="ln852"> </a>
<a name="ln853">	if_setcapabilities(ifp, 0);</a>
<a name="ln854">	if_setcapenable(ifp, 0);</a>
<a name="ln855"> </a>
<a name="ln856">	/* Enable checksum offload/TSO for 82550 or better chips */</a>
<a name="ln857">	if (sc-&gt;flags &amp; FXP_FLAG_EXT_RFA) {</a>
<a name="ln858">		if_sethwassist(ifp, FXP_CSUM_FEATURES | CSUM_TSO);</a>
<a name="ln859">		if_setcapabilitiesbit(ifp, IFCAP_HWCSUM | IFCAP_TSO4, 0);</a>
<a name="ln860">		if_setcapenablebit(ifp, IFCAP_HWCSUM | IFCAP_TSO4, 0);</a>
<a name="ln861">	}</a>
<a name="ln862"> </a>
<a name="ln863">	if (sc-&gt;flags &amp; FXP_FLAG_82559_RXCSUM) {</a>
<a name="ln864">		if_setcapabilitiesbit(ifp, IFCAP_RXCSUM, 0);</a>
<a name="ln865">		if_setcapenablebit(ifp, IFCAP_RXCSUM, 0);</a>
<a name="ln866">	}</a>
<a name="ln867"> </a>
<a name="ln868">	if (sc-&gt;flags &amp; FXP_FLAG_WOLCAP) {</a>
<a name="ln869">		if_setcapabilitiesbit(ifp, IFCAP_WOL_MAGIC, 0);</a>
<a name="ln870">		if_setcapenablebit(ifp, IFCAP_WOL_MAGIC, 0);</a>
<a name="ln871">	}</a>
<a name="ln872"> </a>
<a name="ln873">#ifdef DEVICE_POLLING</a>
<a name="ln874">	/* Inform the world we support polling. */</a>
<a name="ln875">	if_setcapabilitiesbit(ifp, IFCAP_POLLING, 0);</a>
<a name="ln876">#endif</a>
<a name="ln877"> </a>
<a name="ln878">	/*</a>
<a name="ln879">	 * Attach the interface.</a>
<a name="ln880">	 */</a>
<a name="ln881">	ether_ifattach(ifp, eaddr);</a>
<a name="ln882"> </a>
<a name="ln883">	/*</a>
<a name="ln884">	 * Tell the upper layer(s) we support long frames.</a>
<a name="ln885">	 * Must appear after the call to ether_ifattach() because</a>
<a name="ln886">	 * ether_ifattach() sets ifi_hdrlen to the default value.</a>
<a name="ln887">	 */</a>
<a name="ln888">	if_setifheaderlen(ifp, sizeof(struct ether_vlan_header));</a>
<a name="ln889">	if_setcapabilitiesbit(ifp, IFCAP_VLAN_MTU, 0);</a>
<a name="ln890">	if_setcapenablebit(ifp, IFCAP_VLAN_MTU, 0);</a>
<a name="ln891">	if ((sc-&gt;flags &amp; FXP_FLAG_EXT_RFA) != 0) {</a>
<a name="ln892">		if_setcapabilitiesbit(ifp, IFCAP_VLAN_HWTAGGING |</a>
<a name="ln893">		    IFCAP_VLAN_HWCSUM | IFCAP_VLAN_HWTSO, 0);</a>
<a name="ln894">		if_setcapenablebit(ifp, IFCAP_VLAN_HWTAGGING |</a>
<a name="ln895">		    IFCAP_VLAN_HWCSUM | IFCAP_VLAN_HWTSO, 0);</a>
<a name="ln896">	}</a>
<a name="ln897"> </a>
<a name="ln898">	/*</a>
<a name="ln899">	 * Let the system queue as many packets as we have available</a>
<a name="ln900">	 * TX descriptors.</a>
<a name="ln901">	 */</a>
<a name="ln902">	if_setsendqlen(ifp, FXP_NTXCB - 1);</a>
<a name="ln903">	if_setsendqready(ifp);</a>
<a name="ln904"> </a>
<a name="ln905">	/*</a>
<a name="ln906">	 * Hook our interrupt after all initialization is complete.</a>
<a name="ln907">	 */</a>
<a name="ln908">	error = bus_setup_intr(dev, sc-&gt;fxp_res[1], INTR_TYPE_NET | INTR_MPSAFE,</a>
<a name="ln909">			       NULL, fxp_intr, sc, &amp;sc-&gt;ih);</a>
<a name="ln910">	if (error) {</a>
<a name="ln911">		device_printf(dev, &quot;could not setup irq\n&quot;);</a>
<a name="ln912">		ether_ifdetach(sc-&gt;ifp);</a>
<a name="ln913">		goto fail;</a>
<a name="ln914">	}</a>
<a name="ln915"> </a>
<a name="ln916">	/*</a>
<a name="ln917">	 * Configure hardware to reject magic frames otherwise</a>
<a name="ln918">	 * system will hang on recipt of magic frames.</a>
<a name="ln919">	 */</a>
<a name="ln920">	if ((sc-&gt;flags &amp; FXP_FLAG_WOLCAP) != 0) {</a>
<a name="ln921">		FXP_LOCK(sc);</a>
<a name="ln922">		/* Clear wakeup events. */</a>
<a name="ln923">		CSR_WRITE_1(sc, FXP_CSR_PMDR, CSR_READ_1(sc, FXP_CSR_PMDR));</a>
<a name="ln924">		fxp_init_body(sc, 0);</a>
<a name="ln925">		fxp_stop(sc);</a>
<a name="ln926">		FXP_UNLOCK(sc);</a>
<a name="ln927">	}</a>
<a name="ln928"> </a>
<a name="ln929">fail:</a>
<a name="ln930">	if (error)</a>
<a name="ln931">		fxp_release(sc);</a>
<a name="ln932">	return (error);</a>
<a name="ln933">}</a>
<a name="ln934"> </a>
<a name="ln935">/*</a>
<a name="ln936"> * Release all resources.  The softc lock should not be held and the</a>
<a name="ln937"> * interrupt should already be torn down.</a>
<a name="ln938"> */</a>
<a name="ln939">static void</a>
<a name="ln940">fxp_release(struct fxp_softc *sc)</a>
<a name="ln941">{</a>
<a name="ln942">	struct fxp_rx *rxp;</a>
<a name="ln943">	struct fxp_tx *txp;</a>
<a name="ln944">	int i;</a>
<a name="ln945"> </a>
<a name="ln946">	FXP_LOCK_ASSERT(sc, MA_NOTOWNED);</a>
<a name="ln947">	KASSERT(sc-&gt;ih == NULL,</a>
<a name="ln948">	    (&quot;fxp_release() called with intr handle still active&quot;));</a>
<a name="ln949">	if (sc-&gt;miibus)</a>
<a name="ln950">		device_delete_child(sc-&gt;dev, sc-&gt;miibus);</a>
<a name="ln951">	bus_generic_detach(sc-&gt;dev);</a>
<a name="ln952">	ifmedia_removeall(&amp;sc-&gt;sc_media);</a>
<a name="ln953">	if (sc-&gt;fxp_desc.cbl_list) {</a>
<a name="ln954">		bus_dmamap_unload(sc-&gt;cbl_tag, sc-&gt;cbl_map);</a>
<a name="ln955">		bus_dmamem_free(sc-&gt;cbl_tag, sc-&gt;fxp_desc.cbl_list,</a>
<a name="ln956">		    sc-&gt;cbl_map);</a>
<a name="ln957">	}</a>
<a name="ln958">	if (sc-&gt;fxp_stats) {</a>
<a name="ln959">		bus_dmamap_unload(sc-&gt;fxp_stag, sc-&gt;fxp_smap);</a>
<a name="ln960">		bus_dmamem_free(sc-&gt;fxp_stag, sc-&gt;fxp_stats, sc-&gt;fxp_smap);</a>
<a name="ln961">	}</a>
<a name="ln962">	if (sc-&gt;mcsp) {</a>
<a name="ln963">		bus_dmamap_unload(sc-&gt;mcs_tag, sc-&gt;mcs_map);</a>
<a name="ln964">		bus_dmamem_free(sc-&gt;mcs_tag, sc-&gt;mcsp, sc-&gt;mcs_map);</a>
<a name="ln965">	}</a>
<a name="ln966">	bus_release_resources(sc-&gt;dev, sc-&gt;fxp_spec, sc-&gt;fxp_res);</a>
<a name="ln967">	if (sc-&gt;fxp_rxmtag) {</a>
<a name="ln968">		for (i = 0; i &lt; FXP_NRFABUFS; i++) {</a>
<a name="ln969">			rxp = &amp;sc-&gt;fxp_desc.rx_list[i];</a>
<a name="ln970">			if (rxp-&gt;rx_mbuf != NULL) {</a>
<a name="ln971">				bus_dmamap_sync(sc-&gt;fxp_rxmtag, rxp-&gt;rx_map,</a>
<a name="ln972">				    BUS_DMASYNC_POSTREAD);</a>
<a name="ln973">				bus_dmamap_unload(sc-&gt;fxp_rxmtag, rxp-&gt;rx_map);</a>
<a name="ln974">				m_freem(rxp-&gt;rx_mbuf);</a>
<a name="ln975">			}</a>
<a name="ln976">			bus_dmamap_destroy(sc-&gt;fxp_rxmtag, rxp-&gt;rx_map);</a>
<a name="ln977">		}</a>
<a name="ln978">		bus_dmamap_destroy(sc-&gt;fxp_rxmtag, sc-&gt;spare_map);</a>
<a name="ln979">		bus_dma_tag_destroy(sc-&gt;fxp_rxmtag);</a>
<a name="ln980">	}</a>
<a name="ln981">	if (sc-&gt;fxp_txmtag) {</a>
<a name="ln982">		for (i = 0; i &lt; FXP_NTXCB; i++) {</a>
<a name="ln983">			txp = &amp;sc-&gt;fxp_desc.tx_list[i];</a>
<a name="ln984">			if (txp-&gt;tx_mbuf != NULL) {</a>
<a name="ln985">				bus_dmamap_sync(sc-&gt;fxp_txmtag, txp-&gt;tx_map,</a>
<a name="ln986">				    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln987">				bus_dmamap_unload(sc-&gt;fxp_txmtag, txp-&gt;tx_map);</a>
<a name="ln988">				m_freem(txp-&gt;tx_mbuf);</a>
<a name="ln989">			}</a>
<a name="ln990">			bus_dmamap_destroy(sc-&gt;fxp_txmtag, txp-&gt;tx_map);</a>
<a name="ln991">		}</a>
<a name="ln992">		bus_dma_tag_destroy(sc-&gt;fxp_txmtag);</a>
<a name="ln993">	}</a>
<a name="ln994">	if (sc-&gt;fxp_stag)</a>
<a name="ln995">		bus_dma_tag_destroy(sc-&gt;fxp_stag);</a>
<a name="ln996">	if (sc-&gt;cbl_tag)</a>
<a name="ln997">		bus_dma_tag_destroy(sc-&gt;cbl_tag);</a>
<a name="ln998">	if (sc-&gt;mcs_tag)</a>
<a name="ln999">		bus_dma_tag_destroy(sc-&gt;mcs_tag);</a>
<a name="ln1000">	if (sc-&gt;ifp)</a>
<a name="ln1001">		if_free(sc-&gt;ifp);</a>
<a name="ln1002"> </a>
<a name="ln1003">	mtx_destroy(&amp;sc-&gt;sc_mtx);</a>
<a name="ln1004">}</a>
<a name="ln1005"> </a>
<a name="ln1006">/*</a>
<a name="ln1007"> * Detach interface.</a>
<a name="ln1008"> */</a>
<a name="ln1009">static int</a>
<a name="ln1010">fxp_detach(device_t dev)</a>
<a name="ln1011">{</a>
<a name="ln1012">	struct fxp_softc *sc = device_get_softc(dev);</a>
<a name="ln1013"> </a>
<a name="ln1014">#ifdef DEVICE_POLLING</a>
<a name="ln1015">	if (if_getcapenable(sc-&gt;ifp) &amp; IFCAP_POLLING)</a>
<a name="ln1016">		ether_poll_deregister(sc-&gt;ifp);</a>
<a name="ln1017">#endif</a>
<a name="ln1018"> </a>
<a name="ln1019">	FXP_LOCK(sc);</a>
<a name="ln1020">	/*</a>
<a name="ln1021">	 * Stop DMA and drop transmit queue, but disable interrupts first.</a>
<a name="ln1022">	 */</a>
<a name="ln1023">	CSR_WRITE_1(sc, FXP_CSR_SCB_INTRCNTL, FXP_SCB_INTR_DISABLE);</a>
<a name="ln1024">	fxp_stop(sc);</a>
<a name="ln1025">	FXP_UNLOCK(sc);</a>
<a name="ln1026">	callout_drain(&amp;sc-&gt;stat_ch);</a>
<a name="ln1027"> </a>
<a name="ln1028">	/*</a>
<a name="ln1029">	 * Close down routes etc.</a>
<a name="ln1030">	 */</a>
<a name="ln1031">	ether_ifdetach(sc-&gt;ifp);</a>
<a name="ln1032"> </a>
<a name="ln1033">	/*</a>
<a name="ln1034">	 * Unhook interrupt before dropping lock. This is to prevent</a>
<a name="ln1035">	 * races with fxp_intr().</a>
<a name="ln1036">	 */</a>
<a name="ln1037">	bus_teardown_intr(sc-&gt;dev, sc-&gt;fxp_res[1], sc-&gt;ih);</a>
<a name="ln1038">	sc-&gt;ih = NULL;</a>
<a name="ln1039"> </a>
<a name="ln1040">	/* Release our allocated resources. */</a>
<a name="ln1041">	fxp_release(sc);</a>
<a name="ln1042">	return (0);</a>
<a name="ln1043">}</a>
<a name="ln1044"> </a>
<a name="ln1045">/*</a>
<a name="ln1046"> * Device shutdown routine. Called at system shutdown after sync. The</a>
<a name="ln1047"> * main purpose of this routine is to shut off receiver DMA so that</a>
<a name="ln1048"> * kernel memory doesn't get clobbered during warmboot.</a>
<a name="ln1049"> */</a>
<a name="ln1050">static int</a>
<a name="ln1051">fxp_shutdown(device_t dev)</a>
<a name="ln1052">{</a>
<a name="ln1053"> </a>
<a name="ln1054">	/*</a>
<a name="ln1055">	 * Make sure that DMA is disabled prior to reboot. Not doing</a>
<a name="ln1056">	 * do could allow DMA to corrupt kernel memory during the</a>
<a name="ln1057">	 * reboot before the driver initializes.</a>
<a name="ln1058">	 */</a>
<a name="ln1059">	return (fxp_suspend(dev));</a>
<a name="ln1060">}</a>
<a name="ln1061"> </a>
<a name="ln1062">/*</a>
<a name="ln1063"> * Device suspend routine.  Stop the interface and save some PCI</a>
<a name="ln1064"> * settings in case the BIOS doesn't restore them properly on</a>
<a name="ln1065"> * resume.</a>
<a name="ln1066"> */</a>
<a name="ln1067">static int</a>
<a name="ln1068">fxp_suspend(device_t dev)</a>
<a name="ln1069">{</a>
<a name="ln1070">	struct fxp_softc *sc = device_get_softc(dev);</a>
<a name="ln1071">	if_t ifp;</a>
<a name="ln1072">	int pmc;</a>
<a name="ln1073">	uint16_t pmstat;</a>
<a name="ln1074"> </a>
<a name="ln1075">	FXP_LOCK(sc);</a>
<a name="ln1076"> </a>
<a name="ln1077">	ifp = sc-&gt;ifp;</a>
<a name="ln1078">	if (pci_find_cap(sc-&gt;dev, PCIY_PMG, &amp;pmc) == 0) {</a>
<a name="ln1079">		pmstat = pci_read_config(sc-&gt;dev, pmc + PCIR_POWER_STATUS, 2);</a>
<a name="ln1080">		pmstat &amp;= ~(PCIM_PSTAT_PME | PCIM_PSTAT_PMEENABLE);</a>
<a name="ln1081">		if ((if_getcapenable(ifp) &amp; IFCAP_WOL_MAGIC) != 0) {</a>
<a name="ln1082">			/* Request PME. */</a>
<a name="ln1083">			pmstat |= PCIM_PSTAT_PME | PCIM_PSTAT_PMEENABLE;</a>
<a name="ln1084">			sc-&gt;flags |= FXP_FLAG_WOL;</a>
<a name="ln1085">			/* Reconfigure hardware to accept magic frames. */</a>
<a name="ln1086">			if_setdrvflagbits(ifp, 0, IFF_DRV_RUNNING);</a>
<a name="ln1087">			fxp_init_body(sc, 0);</a>
<a name="ln1088">		}</a>
<a name="ln1089">		pci_write_config(sc-&gt;dev, pmc + PCIR_POWER_STATUS, pmstat, 2);</a>
<a name="ln1090">	}</a>
<a name="ln1091">	fxp_stop(sc);</a>
<a name="ln1092"> </a>
<a name="ln1093">	sc-&gt;suspended = 1;</a>
<a name="ln1094"> </a>
<a name="ln1095">	FXP_UNLOCK(sc);</a>
<a name="ln1096">	return (0);</a>
<a name="ln1097">}</a>
<a name="ln1098"> </a>
<a name="ln1099">/*</a>
<a name="ln1100"> * Device resume routine. re-enable busmastering, and restart the interface if</a>
<a name="ln1101"> * appropriate.</a>
<a name="ln1102"> */</a>
<a name="ln1103">static int</a>
<a name="ln1104">fxp_resume(device_t dev)</a>
<a name="ln1105">{</a>
<a name="ln1106">	struct fxp_softc *sc = device_get_softc(dev);</a>
<a name="ln1107">	if_t ifp = sc-&gt;ifp;</a>
<a name="ln1108">	int pmc;</a>
<a name="ln1109">	uint16_t pmstat;</a>
<a name="ln1110"> </a>
<a name="ln1111">	FXP_LOCK(sc);</a>
<a name="ln1112"> </a>
<a name="ln1113">	if (pci_find_cap(sc-&gt;dev, PCIY_PMG, &amp;pmc) == 0) {</a>
<a name="ln1114">		sc-&gt;flags &amp;= ~FXP_FLAG_WOL;</a>
<a name="ln1115">		pmstat = pci_read_config(sc-&gt;dev, pmc + PCIR_POWER_STATUS, 2);</a>
<a name="ln1116">		/* Disable PME and clear PME status. */</a>
<a name="ln1117">		pmstat &amp;= ~PCIM_PSTAT_PMEENABLE;</a>
<a name="ln1118">		pci_write_config(sc-&gt;dev, pmc + PCIR_POWER_STATUS, pmstat, 2);</a>
<a name="ln1119">		if ((sc-&gt;flags &amp; FXP_FLAG_WOLCAP) != 0)</a>
<a name="ln1120">			CSR_WRITE_1(sc, FXP_CSR_PMDR,</a>
<a name="ln1121">			    CSR_READ_1(sc, FXP_CSR_PMDR));</a>
<a name="ln1122">	}</a>
<a name="ln1123"> </a>
<a name="ln1124">	CSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SELECTIVE_RESET);</a>
<a name="ln1125">	DELAY(10);</a>
<a name="ln1126"> </a>
<a name="ln1127">	/* reinitialize interface if necessary */</a>
<a name="ln1128">	if (if_getflags(ifp) &amp; IFF_UP)</a>
<a name="ln1129">		fxp_init_body(sc, 1);</a>
<a name="ln1130"> </a>
<a name="ln1131">	sc-&gt;suspended = 0;</a>
<a name="ln1132"> </a>
<a name="ln1133">	FXP_UNLOCK(sc);</a>
<a name="ln1134">	return (0);</a>
<a name="ln1135">}</a>
<a name="ln1136"> </a>
<a name="ln1137">static void</a>
<a name="ln1138">fxp_eeprom_shiftin(struct fxp_softc *sc, int data, int length)</a>
<a name="ln1139">{</a>
<a name="ln1140">	uint16_t reg;</a>
<a name="ln1141">	int x;</a>
<a name="ln1142"> </a>
<a name="ln1143">	/*</a>
<a name="ln1144">	 * Shift in data.</a>
<a name="ln1145">	 */</a>
<a name="ln1146">	for (x = 1 &lt;&lt; (length - 1); x; x &gt;&gt;= 1) {</a>
<a name="ln1147">		if (data &amp; x)</a>
<a name="ln1148">			reg = FXP_EEPROM_EECS | FXP_EEPROM_EEDI;</a>
<a name="ln1149">		else</a>
<a name="ln1150">			reg = FXP_EEPROM_EECS;</a>
<a name="ln1151">		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);</a>
<a name="ln1152">		DELAY(1);</a>
<a name="ln1153">		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg | FXP_EEPROM_EESK);</a>
<a name="ln1154">		DELAY(1);</a>
<a name="ln1155">		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);</a>
<a name="ln1156">		DELAY(1);</a>
<a name="ln1157">	}</a>
<a name="ln1158">}</a>
<a name="ln1159"> </a>
<a name="ln1160">/*</a>
<a name="ln1161"> * Read from the serial EEPROM. Basically, you manually shift in</a>
<a name="ln1162"> * the read opcode (one bit at a time) and then shift in the address,</a>
<a name="ln1163"> * and then you shift out the data (all of this one bit at a time).</a>
<a name="ln1164"> * The word size is 16 bits, so you have to provide the address for</a>
<a name="ln1165"> * every 16 bits of data.</a>
<a name="ln1166"> */</a>
<a name="ln1167">static uint16_t</a>
<a name="ln1168">fxp_eeprom_getword(struct fxp_softc *sc, int offset, int autosize)</a>
<a name="ln1169">{</a>
<a name="ln1170">	uint16_t reg, data;</a>
<a name="ln1171">	int x;</a>
<a name="ln1172"> </a>
<a name="ln1173">	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);</a>
<a name="ln1174">	/*</a>
<a name="ln1175">	 * Shift in read opcode.</a>
<a name="ln1176">	 */</a>
<a name="ln1177">	fxp_eeprom_shiftin(sc, FXP_EEPROM_OPC_READ, 3);</a>
<a name="ln1178">	/*</a>
<a name="ln1179">	 * Shift in address.</a>
<a name="ln1180">	 */</a>
<a name="ln1181">	data = 0;</a>
<a name="ln1182">	for (x = 1 &lt;&lt; (sc-&gt;eeprom_size - 1); x; x &gt;&gt;= 1) {</a>
<a name="ln1183">		if (offset &amp; x)</a>
<a name="ln1184">			reg = FXP_EEPROM_EECS | FXP_EEPROM_EEDI;</a>
<a name="ln1185">		else</a>
<a name="ln1186">			reg = FXP_EEPROM_EECS;</a>
<a name="ln1187">		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);</a>
<a name="ln1188">		DELAY(1);</a>
<a name="ln1189">		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg | FXP_EEPROM_EESK);</a>
<a name="ln1190">		DELAY(1);</a>
<a name="ln1191">		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);</a>
<a name="ln1192">		DELAY(1);</a>
<a name="ln1193">		reg = CSR_READ_2(sc, FXP_CSR_EEPROMCONTROL) &amp; FXP_EEPROM_EEDO;</a>
<a name="ln1194">		data++;</a>
<a name="ln1195">		if (autosize &amp;&amp; reg == 0) {</a>
<a name="ln1196">			sc-&gt;eeprom_size = data;</a>
<a name="ln1197">			break;</a>
<a name="ln1198">		}</a>
<a name="ln1199">	}</a>
<a name="ln1200">	/*</a>
<a name="ln1201">	 * Shift out data.</a>
<a name="ln1202">	 */</a>
<a name="ln1203">	data = 0;</a>
<a name="ln1204">	reg = FXP_EEPROM_EECS;</a>
<a name="ln1205">	for (x = 1 &lt;&lt; 15; x; x &gt;&gt;= 1) {</a>
<a name="ln1206">		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg | FXP_EEPROM_EESK);</a>
<a name="ln1207">		DELAY(1);</a>
<a name="ln1208">		if (CSR_READ_2(sc, FXP_CSR_EEPROMCONTROL) &amp; FXP_EEPROM_EEDO)</a>
<a name="ln1209">			data |= x;</a>
<a name="ln1210">		CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, reg);</a>
<a name="ln1211">		DELAY(1);</a>
<a name="ln1212">	}</a>
<a name="ln1213">	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, 0);</a>
<a name="ln1214">	DELAY(1);</a>
<a name="ln1215"> </a>
<a name="ln1216">	return (data);</a>
<a name="ln1217">}</a>
<a name="ln1218"> </a>
<a name="ln1219">static void</a>
<a name="ln1220">fxp_eeprom_putword(struct fxp_softc *sc, int offset, uint16_t data)</a>
<a name="ln1221">{</a>
<a name="ln1222">	int i;</a>
<a name="ln1223"> </a>
<a name="ln1224">	/*</a>
<a name="ln1225">	 * Erase/write enable.</a>
<a name="ln1226">	 */</a>
<a name="ln1227">	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);</a>
<a name="ln1228">	fxp_eeprom_shiftin(sc, 0x4, 3);</a>
<a name="ln1229">	fxp_eeprom_shiftin(sc, 0x03 &lt;&lt; (sc-&gt;eeprom_size - 2), sc-&gt;eeprom_size);</a>
<a name="ln1230">	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, 0);</a>
<a name="ln1231">	DELAY(1);</a>
<a name="ln1232">	/*</a>
<a name="ln1233">	 * Shift in write opcode, address, data.</a>
<a name="ln1234">	 */</a>
<a name="ln1235">	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);</a>
<a name="ln1236">	fxp_eeprom_shiftin(sc, FXP_EEPROM_OPC_WRITE, 3);</a>
<a name="ln1237">	fxp_eeprom_shiftin(sc, offset, sc-&gt;eeprom_size);</a>
<a name="ln1238">	fxp_eeprom_shiftin(sc, data, 16);</a>
<a name="ln1239">	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, 0);</a>
<a name="ln1240">	DELAY(1);</a>
<a name="ln1241">	/*</a>
<a name="ln1242">	 * Wait for EEPROM to finish up.</a>
<a name="ln1243">	 */</a>
<a name="ln1244">	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);</a>
<a name="ln1245">	DELAY(1);</a>
<a name="ln1246">	for (i = 0; i &lt; 1000; i++) {</a>
<a name="ln1247">		if (CSR_READ_2(sc, FXP_CSR_EEPROMCONTROL) &amp; FXP_EEPROM_EEDO)</a>
<a name="ln1248">			break;</a>
<a name="ln1249">		DELAY(50);</a>
<a name="ln1250">	}</a>
<a name="ln1251">	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, 0);</a>
<a name="ln1252">	DELAY(1);</a>
<a name="ln1253">	/*</a>
<a name="ln1254">	 * Erase/write disable.</a>
<a name="ln1255">	 */</a>
<a name="ln1256">	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, FXP_EEPROM_EECS);</a>
<a name="ln1257">	fxp_eeprom_shiftin(sc, 0x4, 3);</a>
<a name="ln1258">	fxp_eeprom_shiftin(sc, 0, sc-&gt;eeprom_size);</a>
<a name="ln1259">	CSR_WRITE_2(sc, FXP_CSR_EEPROMCONTROL, 0);</a>
<a name="ln1260">	DELAY(1);</a>
<a name="ln1261">}</a>
<a name="ln1262"> </a>
<a name="ln1263">/*</a>
<a name="ln1264"> * From NetBSD:</a>
<a name="ln1265"> *</a>
<a name="ln1266"> * Figure out EEPROM size.</a>
<a name="ln1267"> *</a>
<a name="ln1268"> * 559's can have either 64-word or 256-word EEPROMs, the 558</a>
<a name="ln1269"> * datasheet only talks about 64-word EEPROMs, and the 557 datasheet</a>
<a name="ln1270"> * talks about the existence of 16 to 256 word EEPROMs.</a>
<a name="ln1271"> *</a>
<a name="ln1272"> * The only known sizes are 64 and 256, where the 256 version is used</a>
<a name="ln1273"> * by CardBus cards to store CIS information.</a>
<a name="ln1274"> *</a>
<a name="ln1275"> * The address is shifted in msb-to-lsb, and after the last</a>
<a name="ln1276"> * address-bit the EEPROM is supposed to output a `dummy zero' bit,</a>
<a name="ln1277"> * after which follows the actual data. We try to detect this zero, by</a>
<a name="ln1278"> * probing the data-out bit in the EEPROM control register just after</a>
<a name="ln1279"> * having shifted in a bit. If the bit is zero, we assume we've</a>
<a name="ln1280"> * shifted enough address bits. The data-out should be tri-state,</a>
<a name="ln1281"> * before this, which should translate to a logical one.</a>
<a name="ln1282"> */</a>
<a name="ln1283">static void</a>
<a name="ln1284">fxp_autosize_eeprom(struct fxp_softc *sc)</a>
<a name="ln1285">{</a>
<a name="ln1286"> </a>
<a name="ln1287">	/* guess maximum size of 256 words */</a>
<a name="ln1288">	sc-&gt;eeprom_size = 8;</a>
<a name="ln1289"> </a>
<a name="ln1290">	/* autosize */</a>
<a name="ln1291">	(void) fxp_eeprom_getword(sc, 0, 1);</a>
<a name="ln1292">}</a>
<a name="ln1293"> </a>
<a name="ln1294">static void</a>
<a name="ln1295">fxp_read_eeprom(struct fxp_softc *sc, u_short *data, int offset, int words)</a>
<a name="ln1296">{</a>
<a name="ln1297">	int i;</a>
<a name="ln1298"> </a>
<a name="ln1299">	for (i = 0; i &lt; words; i++)</a>
<a name="ln1300">		data[i] = fxp_eeprom_getword(sc, offset + i, 0);</a>
<a name="ln1301">}</a>
<a name="ln1302"> </a>
<a name="ln1303">static void</a>
<a name="ln1304">fxp_write_eeprom(struct fxp_softc *sc, u_short *data, int offset, int words)</a>
<a name="ln1305">{</a>
<a name="ln1306">	int i;</a>
<a name="ln1307"> </a>
<a name="ln1308">	for (i = 0; i &lt; words; i++)</a>
<a name="ln1309">		fxp_eeprom_putword(sc, offset + i, data[i]);</a>
<a name="ln1310">}</a>
<a name="ln1311"> </a>
<a name="ln1312">static void</a>
<a name="ln1313">fxp_load_eeprom(struct fxp_softc *sc)</a>
<a name="ln1314">{</a>
<a name="ln1315">	int i;</a>
<a name="ln1316">	uint16_t cksum;</a>
<a name="ln1317"> </a>
<a name="ln1318">	fxp_read_eeprom(sc, sc-&gt;eeprom, 0, 1 &lt;&lt; sc-&gt;eeprom_size);</a>
<a name="ln1319">	cksum = 0;</a>
<a name="ln1320">	for (i = 0; i &lt; (1 &lt;&lt; sc-&gt;eeprom_size) - 1; i++)</a>
<a name="ln1321">		cksum += sc-&gt;eeprom[i];</a>
<a name="ln1322">	cksum = 0xBABA - cksum;</a>
<a name="ln1323">	if (cksum != sc-&gt;eeprom[(1 &lt;&lt; sc-&gt;eeprom_size) - 1])</a>
<a name="ln1324">		device_printf(sc-&gt;dev,</a>
<a name="ln1325">		    &quot;EEPROM checksum mismatch! (0x%04x -&gt; 0x%04x)\n&quot;,</a>
<a name="ln1326">		    cksum, sc-&gt;eeprom[(1 &lt;&lt; sc-&gt;eeprom_size) - 1]);</a>
<a name="ln1327">}</a>
<a name="ln1328"> </a>
<a name="ln1329">/*</a>
<a name="ln1330"> * Grab the softc lock and call the real fxp_start_body() routine</a>
<a name="ln1331"> */</a>
<a name="ln1332">static void</a>
<a name="ln1333">fxp_start(if_t ifp)</a>
<a name="ln1334">{</a>
<a name="ln1335">	struct fxp_softc *sc = if_getsoftc(ifp);</a>
<a name="ln1336"> </a>
<a name="ln1337">	FXP_LOCK(sc);</a>
<a name="ln1338">	fxp_start_body(ifp);</a>
<a name="ln1339">	FXP_UNLOCK(sc);</a>
<a name="ln1340">}</a>
<a name="ln1341"> </a>
<a name="ln1342">/*</a>
<a name="ln1343"> * Start packet transmission on the interface.</a>
<a name="ln1344"> * This routine must be called with the softc lock held, and is an</a>
<a name="ln1345"> * internal entry point only.</a>
<a name="ln1346"> */</a>
<a name="ln1347">static void</a>
<a name="ln1348">fxp_start_body(if_t ifp)</a>
<a name="ln1349">{</a>
<a name="ln1350">	struct fxp_softc *sc = if_getsoftc(ifp);</a>
<a name="ln1351">	struct mbuf *mb_head;</a>
<a name="ln1352">	int txqueued;</a>
<a name="ln1353"> </a>
<a name="ln1354">	FXP_LOCK_ASSERT(sc, MA_OWNED);</a>
<a name="ln1355"> </a>
<a name="ln1356">	if ((if_getdrvflags(ifp) &amp; (IFF_DRV_RUNNING | IFF_DRV_OACTIVE)) !=</a>
<a name="ln1357">	    IFF_DRV_RUNNING)</a>
<a name="ln1358">		return;</a>
<a name="ln1359"> </a>
<a name="ln1360">	if (sc-&gt;tx_queued &gt; FXP_NTXCB_HIWAT)</a>
<a name="ln1361">		fxp_txeof(sc);</a>
<a name="ln1362">	/*</a>
<a name="ln1363">	 * We're finished if there is nothing more to add to the list or if</a>
<a name="ln1364">	 * we're all filled up with buffers to transmit.</a>
<a name="ln1365">	 * NOTE: One TxCB is reserved to guarantee that fxp_mc_setup() can add</a>
<a name="ln1366">	 *       a NOP command when needed.</a>
<a name="ln1367">	 */</a>
<a name="ln1368">	txqueued = 0;</a>
<a name="ln1369">	while (!if_sendq_empty(ifp) &amp;&amp; sc-&gt;tx_queued &lt; FXP_NTXCB - 1) {</a>
<a name="ln1370"> </a>
<a name="ln1371">		/*</a>
<a name="ln1372">		 * Grab a packet to transmit.</a>
<a name="ln1373">		 */</a>
<a name="ln1374">		mb_head = if_dequeue(ifp);</a>
<a name="ln1375">		if (mb_head == NULL)</a>
<a name="ln1376">			break;</a>
<a name="ln1377"> </a>
<a name="ln1378">		if (fxp_encap(sc, &amp;mb_head)) {</a>
<a name="ln1379">			if (mb_head == NULL)</a>
<a name="ln1380">				break;</a>
<a name="ln1381">			if_sendq_prepend(ifp, mb_head);</a>
<a name="ln1382">			if_setdrvflagbits(ifp, IFF_DRV_OACTIVE, 0);</a>
<a name="ln1383">		}</a>
<a name="ln1384">		txqueued++;</a>
<a name="ln1385">		/*</a>
<a name="ln1386">		 * Pass packet to bpf if there is a listener.</a>
<a name="ln1387">		 */</a>
<a name="ln1388">		if_bpfmtap(ifp, mb_head);</a>
<a name="ln1389">	}</a>
<a name="ln1390"> </a>
<a name="ln1391">	/*</a>
<a name="ln1392">	 * We're finished. If we added to the list, issue a RESUME to get DMA</a>
<a name="ln1393">	 * going again if suspended.</a>
<a name="ln1394">	 */</a>
<a name="ln1395">	if (txqueued &gt; 0) {</a>
<a name="ln1396">		bus_dmamap_sync(sc-&gt;cbl_tag, sc-&gt;cbl_map,</a>
<a name="ln1397">		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln1398">		fxp_scb_wait(sc);</a>
<a name="ln1399">		fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_RESUME);</a>
<a name="ln1400">		/*</a>
<a name="ln1401">		 * Set a 5 second timer just in case we don't hear</a>
<a name="ln1402">		 * from the card again.</a>
<a name="ln1403">		 */</a>
<a name="ln1404">		sc-&gt;watchdog_timer = 5;</a>
<a name="ln1405">	}</a>
<a name="ln1406">}</a>
<a name="ln1407"> </a>
<a name="ln1408">static int</a>
<a name="ln1409">fxp_encap(struct fxp_softc *sc, struct mbuf **m_head)</a>
<a name="ln1410">{</a>
<a name="ln1411">	if_t ifp;</a>
<a name="ln1412">	struct mbuf *m;</a>
<a name="ln1413">	struct fxp_tx *txp;</a>
<a name="ln1414">	struct fxp_cb_tx *cbp;</a>
<a name="ln1415">	struct tcphdr *tcp;</a>
<a name="ln1416">	bus_dma_segment_t segs[FXP_NTXSEG];</a>
<a name="ln1417">	int error, i, nseg, tcp_payload;</a>
<a name="ln1418"> </a>
<a name="ln1419">	FXP_LOCK_ASSERT(sc, MA_OWNED);</a>
<a name="ln1420">	ifp = sc-&gt;ifp;</a>
<a name="ln1421"> </a>
<a name="ln1422">	tcp_payload = 0;</a>
<a name="ln1423">	tcp = NULL;</a>
<a name="ln1424">	/*</a>
<a name="ln1425">	 * Get pointer to next available tx desc.</a>
<a name="ln1426">	 */</a>
<a name="ln1427">	txp = sc-&gt;fxp_desc.tx_last-&gt;tx_next;</a>
<a name="ln1428"> </a>
<a name="ln1429">	/*</a>
<a name="ln1430">	 * A note in Appendix B of the Intel 8255x 10/100 Mbps</a>
<a name="ln1431">	 * Ethernet Controller Family Open Source Software</a>
<a name="ln1432">	 * Developer Manual says:</a>
<a name="ln1433">	 *   Using software parsing is only allowed with legal</a>
<a name="ln1434">	 *   TCP/IP or UDP/IP packets.</a>
<a name="ln1435">	 *   ...</a>
<a name="ln1436">	 *   For all other datagrams, hardware parsing must</a>
<a name="ln1437">	 *   be used.</a>
<a name="ln1438">	 * Software parsing appears to truncate ICMP and</a>
<a name="ln1439">	 * fragmented UDP packets that contain one to three</a>
<a name="ln1440">	 * bytes in the second (and final) mbuf of the packet.</a>
<a name="ln1441">	 */</a>
<a name="ln1442">	if (sc-&gt;flags &amp; FXP_FLAG_EXT_RFA)</a>
<a name="ln1443">		txp-&gt;tx_cb-&gt;ipcb_ip_activation_high =</a>
<a name="ln1444">		    FXP_IPCB_HARDWAREPARSING_ENABLE;</a>
<a name="ln1445"> </a>
<a name="ln1446">	m = *m_head;</a>
<a name="ln1447">	if (m-&gt;m_pkthdr.csum_flags &amp; CSUM_TSO) {</a>
<a name="ln1448">		/*</a>
<a name="ln1449">		 * 82550/82551 requires ethernet/IP/TCP headers must be</a>
<a name="ln1450">		 * contained in the first active transmit buffer.</a>
<a name="ln1451">		 */</a>
<a name="ln1452">		struct ether_header *eh;</a>
<a name="ln1453">		struct ip *ip;</a>
<a name="ln1454">		uint32_t ip_off, poff;</a>
<a name="ln1455"> </a>
<a name="ln1456">		if (M_WRITABLE(*m_head) == 0) {</a>
<a name="ln1457">			/* Get a writable copy. */</a>
<a name="ln1458">			m = m_dup(*m_head, M_NOWAIT);</a>
<a name="ln1459">			m_freem(*m_head);</a>
<a name="ln1460">			if (m == NULL) {</a>
<a name="ln1461">				*m_head = NULL;</a>
<a name="ln1462">				return (ENOBUFS);</a>
<a name="ln1463">			}</a>
<a name="ln1464">			*m_head = m;</a>
<a name="ln1465">		}</a>
<a name="ln1466">		ip_off = sizeof(struct ether_header);</a>
<a name="ln1467">		m = m_pullup(*m_head, ip_off);</a>
<a name="ln1468">		if (m == NULL) {</a>
<a name="ln1469">			*m_head = NULL;</a>
<a name="ln1470">			return (ENOBUFS);</a>
<a name="ln1471">		}</a>
<a name="ln1472">		eh = mtod(m, struct ether_header *);</a>
<a name="ln1473">		/* Check the existence of VLAN tag. */</a>
<a name="ln1474">		if (eh-&gt;ether_type == htons(ETHERTYPE_VLAN)) {</a>
<a name="ln1475">			ip_off = sizeof(struct ether_vlan_header);</a>
<a name="ln1476">			m = m_pullup(m, ip_off);</a>
<a name="ln1477">			if (m == NULL) {</a>
<a name="ln1478">				*m_head = NULL;</a>
<a name="ln1479">				return (ENOBUFS);</a>
<a name="ln1480">			}</a>
<a name="ln1481">		}</a>
<a name="ln1482">		m = m_pullup(m, ip_off + sizeof(struct ip));</a>
<a name="ln1483">		if (m == NULL) {</a>
<a name="ln1484">			*m_head = NULL;</a>
<a name="ln1485">			return (ENOBUFS);</a>
<a name="ln1486">		}</a>
<a name="ln1487">		ip = (struct ip *)(mtod(m, char *) + ip_off);</a>
<a name="ln1488">		poff = ip_off + (ip-&gt;ip_hl &lt;&lt; 2);</a>
<a name="ln1489">		m = m_pullup(m, poff + sizeof(struct tcphdr));</a>
<a name="ln1490">		if (m == NULL) {</a>
<a name="ln1491">			*m_head = NULL;</a>
<a name="ln1492">			return (ENOBUFS);</a>
<a name="ln1493">		}</a>
<a name="ln1494">		tcp = (struct tcphdr *)(mtod(m, char *) + poff);</a>
<a name="ln1495">		m = m_pullup(m, poff + (tcp-&gt;th_off &lt;&lt; 2));</a>
<a name="ln1496">		if (m == NULL) {</a>
<a name="ln1497">			*m_head = NULL;</a>
<a name="ln1498">			return (ENOBUFS);</a>
<a name="ln1499">		}</a>
<a name="ln1500"> </a>
<a name="ln1501">		/*</a>
<a name="ln1502">		 * Since 82550/82551 doesn't modify IP length and pseudo</a>
<a name="ln1503">		 * checksum in the first frame driver should compute it.</a>
<a name="ln1504">		 */</a>
<a name="ln1505">		ip = (struct ip *)(mtod(m, char *) + ip_off);</a>
<a name="ln1506">		tcp = (struct tcphdr *)(mtod(m, char *) + poff);</a>
<a name="ln1507">		ip-&gt;ip_sum = 0;</a>
<a name="ln1508">		ip-&gt;ip_len = htons(m-&gt;m_pkthdr.tso_segsz + (ip-&gt;ip_hl &lt;&lt; 2) +</a>
<a name="ln1509">		    (tcp-&gt;th_off &lt;&lt; 2));</a>
<a name="ln1510">		tcp-&gt;th_sum = in_pseudo(ip-&gt;ip_src.s_addr, ip-&gt;ip_dst.s_addr,</a>
<a name="ln1511">		    htons(IPPROTO_TCP + (tcp-&gt;th_off &lt;&lt; 2) +</a>
<a name="ln1512">		    m-&gt;m_pkthdr.tso_segsz));</a>
<a name="ln1513">		/* Compute total TCP payload. */</a>
<a name="ln1514">		tcp_payload = m-&gt;m_pkthdr.len - ip_off - (ip-&gt;ip_hl &lt;&lt; 2);</a>
<a name="ln1515">		tcp_payload -= tcp-&gt;th_off &lt;&lt; 2;</a>
<a name="ln1516">		*m_head = m;</a>
<a name="ln1517">	} else if (m-&gt;m_pkthdr.csum_flags &amp; FXP_CSUM_FEATURES) {</a>
<a name="ln1518">		/*</a>
<a name="ln1519">		 * Deal with TCP/IP checksum offload. Note that</a>
<a name="ln1520">		 * in order for TCP checksum offload to work,</a>
<a name="ln1521">		 * the pseudo header checksum must have already</a>
<a name="ln1522">		 * been computed and stored in the checksum field</a>
<a name="ln1523">		 * in the TCP header. The stack should have</a>
<a name="ln1524">		 * already done this for us.</a>
<a name="ln1525">		 */</a>
<a name="ln1526">		txp-&gt;tx_cb-&gt;ipcb_ip_schedule = FXP_IPCB_TCPUDP_CHECKSUM_ENABLE;</a>
<a name="ln1527">		if (m-&gt;m_pkthdr.csum_flags &amp; CSUM_TCP)</a>
<a name="ln1528">			txp-&gt;tx_cb-&gt;ipcb_ip_schedule |= FXP_IPCB_TCP_PACKET;</a>
<a name="ln1529"> </a>
<a name="ln1530">#ifdef FXP_IP_CSUM_WAR</a>
<a name="ln1531">		/*</a>
<a name="ln1532">		 * XXX The 82550 chip appears to have trouble</a>
<a name="ln1533">		 * dealing with IP header checksums in very small</a>
<a name="ln1534">		 * datagrams, namely fragments from 1 to 3 bytes</a>
<a name="ln1535">		 * in size. For example, say you want to transmit</a>
<a name="ln1536">		 * a UDP packet of 1473 bytes. The packet will be</a>
<a name="ln1537">		 * fragmented over two IP datagrams, the latter</a>
<a name="ln1538">		 * containing only one byte of data. The 82550 will</a>
<a name="ln1539">		 * botch the header checksum on the 1-byte fragment.</a>
<a name="ln1540">		 * As long as the datagram contains 4 or more bytes</a>
<a name="ln1541">		 * of data, you're ok.</a>
<a name="ln1542">		 *</a>
<a name="ln1543">                 * The following code attempts to work around this</a>
<a name="ln1544">		 * problem: if the datagram is less than 38 bytes</a>
<a name="ln1545">		 * in size (14 bytes ether header, 20 bytes IP header,</a>
<a name="ln1546">		 * plus 4 bytes of data), we punt and compute the IP</a>
<a name="ln1547">		 * header checksum by hand. This workaround doesn't</a>
<a name="ln1548">		 * work very well, however, since it can be fooled</a>
<a name="ln1549">		 * by things like VLAN tags and IP options that make</a>
<a name="ln1550">		 * the header sizes/offsets vary.</a>
<a name="ln1551">		 */</a>
<a name="ln1552"> </a>
<a name="ln1553">		if (m-&gt;m_pkthdr.csum_flags &amp; CSUM_IP) {</a>
<a name="ln1554">			if (m-&gt;m_pkthdr.len &lt; 38) {</a>
<a name="ln1555">				struct ip *ip;</a>
<a name="ln1556">				m-&gt;m_data += ETHER_HDR_LEN;</a>
<a name="ln1557">				ip = mtod(m, struct ip *);</a>
<a name="ln1558">				ip-&gt;ip_sum = in_cksum(m, ip-&gt;ip_hl &lt;&lt; 2);</a>
<a name="ln1559">				m-&gt;m_data -= ETHER_HDR_LEN;</a>
<a name="ln1560">				m-&gt;m_pkthdr.csum_flags &amp;= ~CSUM_IP;</a>
<a name="ln1561">			} else {</a>
<a name="ln1562">				txp-&gt;tx_cb-&gt;ipcb_ip_activation_high =</a>
<a name="ln1563">				    FXP_IPCB_HARDWAREPARSING_ENABLE;</a>
<a name="ln1564">				txp-&gt;tx_cb-&gt;ipcb_ip_schedule |=</a>
<a name="ln1565">				    FXP_IPCB_IP_CHECKSUM_ENABLE;</a>
<a name="ln1566">			}</a>
<a name="ln1567">		}</a>
<a name="ln1568">#endif</a>
<a name="ln1569">	}</a>
<a name="ln1570"> </a>
<a name="ln1571">	error = bus_dmamap_load_mbuf_sg(sc-&gt;fxp_txmtag, txp-&gt;tx_map, *m_head,</a>
<a name="ln1572">	    segs, &amp;nseg, 0);</a>
<a name="ln1573">	if (error == EFBIG) {</a>
<a name="ln1574">		m = m_collapse(*m_head, M_NOWAIT, sc-&gt;maxtxseg);</a>
<a name="ln1575">		if (m == NULL) {</a>
<a name="ln1576">			m_freem(*m_head);</a>
<a name="ln1577">			*m_head = NULL;</a>
<a name="ln1578">			return (ENOMEM);</a>
<a name="ln1579">		}</a>
<a name="ln1580">		*m_head = m;</a>
<a name="ln1581">		error = bus_dmamap_load_mbuf_sg(sc-&gt;fxp_txmtag, txp-&gt;tx_map,</a>
<a name="ln1582">		    *m_head, segs, &amp;nseg, 0);</a>
<a name="ln1583">		if (error != 0) {</a>
<a name="ln1584">			m_freem(*m_head);</a>
<a name="ln1585">			*m_head = NULL;</a>
<a name="ln1586">			return (ENOMEM);</a>
<a name="ln1587">		}</a>
<a name="ln1588">	} else if (error != 0)</a>
<a name="ln1589">		return (error);</a>
<a name="ln1590">	if (nseg == 0) {</a>
<a name="ln1591">		m_freem(*m_head);</a>
<a name="ln1592">		*m_head = NULL;</a>
<a name="ln1593">		return (EIO);</a>
<a name="ln1594">	}</a>
<a name="ln1595"> </a>
<a name="ln1596">	KASSERT(nseg &lt;= sc-&gt;maxtxseg, (&quot;too many DMA segments&quot;));</a>
<a name="ln1597">	bus_dmamap_sync(sc-&gt;fxp_txmtag, txp-&gt;tx_map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln1598"> </a>
<a name="ln1599">	cbp = txp-&gt;tx_cb;</a>
<a name="ln1600">	for (i = 0; i &lt; nseg; i++) {</a>
<a name="ln1601">		/*</a>
<a name="ln1602">		 * If this is an 82550/82551, then we're using extended</a>
<a name="ln1603">		 * TxCBs _and_ we're using checksum offload. This means</a>
<a name="ln1604">		 * that the TxCB is really an IPCB. One major difference</a>
<a name="ln1605">		 * between the two is that with plain extended TxCBs,</a>
<a name="ln1606">		 * the bottom half of the TxCB contains two entries from</a>
<a name="ln1607">		 * the TBD array, whereas IPCBs contain just one entry:</a>
<a name="ln1608">		 * one entry (8 bytes) has been sacrificed for the TCP/IP</a>
<a name="ln1609">		 * checksum offload control bits. So to make things work</a>
<a name="ln1610">		 * right, we have to start filling in the TBD array</a>
<a name="ln1611">		 * starting from a different place depending on whether</a>
<a name="ln1612">		 * the chip is an 82550/82551 or not.</a>
<a name="ln1613">		 */</a>
<a name="ln1614">		if (sc-&gt;flags &amp; FXP_FLAG_EXT_RFA) {</a>
<a name="ln1615">			cbp-&gt;tbd[i + 1].tb_addr = htole32(segs[i].ds_addr);</a>
<a name="ln1616">			cbp-&gt;tbd[i + 1].tb_size = htole32(segs[i].ds_len);</a>
<a name="ln1617">		} else {</a>
<a name="ln1618">			cbp-&gt;tbd[i].tb_addr = htole32(segs[i].ds_addr);</a>
<a name="ln1619">			cbp-&gt;tbd[i].tb_size = htole32(segs[i].ds_len);</a>
<a name="ln1620">		}</a>
<a name="ln1621">	}</a>
<a name="ln1622">	if (sc-&gt;flags &amp; FXP_FLAG_EXT_RFA) {</a>
<a name="ln1623">		/* Configure dynamic TBD for 82550/82551. */</a>
<a name="ln1624">		cbp-&gt;tbd_number = 0xFF;</a>
<a name="ln1625">		cbp-&gt;tbd[nseg].tb_size |= htole32(0x8000);</a>
<a name="ln1626">	} else</a>
<a name="ln1627">		cbp-&gt;tbd_number = nseg;</a>
<a name="ln1628">	/* Configure TSO. */</a>
<a name="ln1629">	if (m-&gt;m_pkthdr.csum_flags &amp; CSUM_TSO) {</a>
<a name="ln1630">		cbp-&gt;tbd[-1].tb_size = htole32(m-&gt;m_pkthdr.tso_segsz &lt;&lt; 16);</a>
<a name="ln1631">		cbp-&gt;tbd[1].tb_size |= htole32(tcp_payload &lt;&lt; 16);</a>
<a name="ln1632">		cbp-&gt;ipcb_ip_schedule |= FXP_IPCB_LARGESEND_ENABLE |</a>
<a name="ln1633">		    FXP_IPCB_IP_CHECKSUM_ENABLE |</a>
<a name="ln1634">		    FXP_IPCB_TCP_PACKET |</a>
<a name="ln1635">		    FXP_IPCB_TCPUDP_CHECKSUM_ENABLE;</a>
<a name="ln1636">	}</a>
<a name="ln1637">	/* Configure VLAN hardware tag insertion. */</a>
<a name="ln1638">	if ((m-&gt;m_flags &amp; M_VLANTAG) != 0) {</a>
<a name="ln1639">		cbp-&gt;ipcb_vlan_id = htons(m-&gt;m_pkthdr.ether_vtag);</a>
<a name="ln1640">		txp-&gt;tx_cb-&gt;ipcb_ip_activation_high |=</a>
<a name="ln1641">		    FXP_IPCB_INSERTVLAN_ENABLE;</a>
<a name="ln1642">	}</a>
<a name="ln1643"> </a>
<a name="ln1644">	txp-&gt;tx_mbuf = m;</a>
<a name="ln1645">	txp-&gt;tx_cb-&gt;cb_status = 0;</a>
<a name="ln1646">	txp-&gt;tx_cb-&gt;byte_count = 0;</a>
<a name="ln1647">	if (sc-&gt;tx_queued != FXP_CXINT_THRESH - 1)</a>
<a name="ln1648">		txp-&gt;tx_cb-&gt;cb_command =</a>
<a name="ln1649">		    htole16(sc-&gt;tx_cmd | FXP_CB_COMMAND_SF |</a>
<a name="ln1650">		    FXP_CB_COMMAND_S);</a>
<a name="ln1651">	else</a>
<a name="ln1652">		txp-&gt;tx_cb-&gt;cb_command =</a>
<a name="ln1653">		    htole16(sc-&gt;tx_cmd | FXP_CB_COMMAND_SF |</a>
<a name="ln1654">		    FXP_CB_COMMAND_S | FXP_CB_COMMAND_I);</a>
<a name="ln1655">	if ((m-&gt;m_pkthdr.csum_flags &amp; CSUM_TSO) == 0)</a>
<a name="ln1656">		txp-&gt;tx_cb-&gt;tx_threshold = tx_threshold;</a>
<a name="ln1657"> </a>
<a name="ln1658">	/*</a>
<a name="ln1659">	 * Advance the end of list forward.</a>
<a name="ln1660">	 */</a>
<a name="ln1661">	sc-&gt;fxp_desc.tx_last-&gt;tx_cb-&gt;cb_command &amp;= htole16(~FXP_CB_COMMAND_S);</a>
<a name="ln1662">	sc-&gt;fxp_desc.tx_last = txp;</a>
<a name="ln1663"> </a>
<a name="ln1664">	/*</a>
<a name="ln1665">	 * Advance the beginning of the list forward if there are</a>
<a name="ln1666">	 * no other packets queued (when nothing is queued, tx_first</a>
<a name="ln1667">	 * sits on the last TxCB that was sent out).</a>
<a name="ln1668">	 */</a>
<a name="ln1669">	if (sc-&gt;tx_queued == 0)</a>
<a name="ln1670">		sc-&gt;fxp_desc.tx_first = txp;</a>
<a name="ln1671"> </a>
<a name="ln1672">	sc-&gt;tx_queued++;</a>
<a name="ln1673"> </a>
<a name="ln1674">	return (0);</a>
<a name="ln1675">}</a>
<a name="ln1676"> </a>
<a name="ln1677">#ifdef DEVICE_POLLING</a>
<a name="ln1678">static poll_handler_t fxp_poll;</a>
<a name="ln1679"> </a>
<a name="ln1680">static int</a>
<a name="ln1681">fxp_poll(if_t ifp, enum poll_cmd cmd, int count)</a>
<a name="ln1682">{</a>
<a name="ln1683">	struct fxp_softc *sc = if_getsoftc(ifp);</a>
<a name="ln1684">	uint8_t statack;</a>
<a name="ln1685">	int rx_npkts = 0;</a>
<a name="ln1686"> </a>
<a name="ln1687">	FXP_LOCK(sc);</a>
<a name="ln1688">	if (!(if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING)) {</a>
<a name="ln1689">		FXP_UNLOCK(sc);</a>
<a name="ln1690">		return (rx_npkts);</a>
<a name="ln1691">	}</a>
<a name="ln1692"> </a>
<a name="ln1693">	statack = FXP_SCB_STATACK_CXTNO | FXP_SCB_STATACK_CNA |</a>
<a name="ln1694">	    FXP_SCB_STATACK_FR;</a>
<a name="ln1695">	if (cmd == POLL_AND_CHECK_STATUS) {</a>
<a name="ln1696">		uint8_t tmp;</a>
<a name="ln1697"> </a>
<a name="ln1698">		tmp = CSR_READ_1(sc, FXP_CSR_SCB_STATACK);</a>
<a name="ln1699">		if (tmp == 0xff || tmp == 0) {</a>
<a name="ln1700">			FXP_UNLOCK(sc);</a>
<a name="ln1701">			return (rx_npkts); /* nothing to do */</a>
<a name="ln1702">		}</a>
<a name="ln1703">		tmp &amp;= ~statack;</a>
<a name="ln1704">		/* ack what we can */</a>
<a name="ln1705">		if (tmp != 0)</a>
<a name="ln1706">			CSR_WRITE_1(sc, FXP_CSR_SCB_STATACK, tmp);</a>
<a name="ln1707">		statack |= tmp;</a>
<a name="ln1708">	}</a>
<a name="ln1709">	rx_npkts = fxp_intr_body(sc, ifp, statack, count);</a>
<a name="ln1710">	FXP_UNLOCK(sc);</a>
<a name="ln1711">	return (rx_npkts);</a>
<a name="ln1712">}</a>
<a name="ln1713">#endif /* DEVICE_POLLING */</a>
<a name="ln1714"> </a>
<a name="ln1715">/*</a>
<a name="ln1716"> * Process interface interrupts.</a>
<a name="ln1717"> */</a>
<a name="ln1718">static void</a>
<a name="ln1719">fxp_intr(void *xsc)</a>
<a name="ln1720">{</a>
<a name="ln1721">	struct fxp_softc *sc = xsc;</a>
<a name="ln1722">	if_t ifp = sc-&gt;ifp;</a>
<a name="ln1723">	uint8_t statack;</a>
<a name="ln1724"> </a>
<a name="ln1725">	FXP_LOCK(sc);</a>
<a name="ln1726">	if (sc-&gt;suspended) {</a>
<a name="ln1727">		FXP_UNLOCK(sc);</a>
<a name="ln1728">		return;</a>
<a name="ln1729">	}</a>
<a name="ln1730"> </a>
<a name="ln1731">#ifdef DEVICE_POLLING</a>
<a name="ln1732">	if (if_getcapenable(ifp) &amp; IFCAP_POLLING) {</a>
<a name="ln1733">		FXP_UNLOCK(sc);</a>
<a name="ln1734">		return;</a>
<a name="ln1735">	}</a>
<a name="ln1736">#endif</a>
<a name="ln1737">	while ((statack = CSR_READ_1(sc, FXP_CSR_SCB_STATACK)) != 0) {</a>
<a name="ln1738">		/*</a>
<a name="ln1739">		 * It should not be possible to have all bits set; the</a>
<a name="ln1740">		 * FXP_SCB_INTR_SWI bit always returns 0 on a read.  If</a>
<a name="ln1741">		 * all bits are set, this may indicate that the card has</a>
<a name="ln1742">		 * been physically ejected, so ignore it.</a>
<a name="ln1743">		 */</a>
<a name="ln1744">		if (statack == 0xff) {</a>
<a name="ln1745">			FXP_UNLOCK(sc);</a>
<a name="ln1746">			return;</a>
<a name="ln1747">		}</a>
<a name="ln1748"> </a>
<a name="ln1749">		/*</a>
<a name="ln1750">		 * First ACK all the interrupts in this pass.</a>
<a name="ln1751">		 */</a>
<a name="ln1752">		CSR_WRITE_1(sc, FXP_CSR_SCB_STATACK, statack);</a>
<a name="ln1753">		if ((if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING) != 0)</a>
<a name="ln1754">			fxp_intr_body(sc, ifp, statack, -1);</a>
<a name="ln1755">	}</a>
<a name="ln1756">	FXP_UNLOCK(sc);</a>
<a name="ln1757">}</a>
<a name="ln1758"> </a>
<a name="ln1759">static void</a>
<a name="ln1760">fxp_txeof(struct fxp_softc *sc)</a>
<a name="ln1761">{</a>
<a name="ln1762">	if_t ifp;</a>
<a name="ln1763">	struct fxp_tx *txp;</a>
<a name="ln1764"> </a>
<a name="ln1765">	ifp = sc-&gt;ifp;</a>
<a name="ln1766">	bus_dmamap_sync(sc-&gt;cbl_tag, sc-&gt;cbl_map,</a>
<a name="ln1767">	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);</a>
<a name="ln1768">	for (txp = sc-&gt;fxp_desc.tx_first; sc-&gt;tx_queued &amp;&amp;</a>
<a name="ln1769">	    (le16toh(txp-&gt;tx_cb-&gt;cb_status) &amp; FXP_CB_STATUS_C) != 0;</a>
<a name="ln1770">	    txp = txp-&gt;tx_next) {</a>
<a name="ln1771">		if (txp-&gt;tx_mbuf != NULL) {</a>
<a name="ln1772">			bus_dmamap_sync(sc-&gt;fxp_txmtag, txp-&gt;tx_map,</a>
<a name="ln1773">			    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln1774">			bus_dmamap_unload(sc-&gt;fxp_txmtag, txp-&gt;tx_map);</a>
<a name="ln1775">			m_freem(txp-&gt;tx_mbuf);</a>
<a name="ln1776">			txp-&gt;tx_mbuf = NULL;</a>
<a name="ln1777">			/* clear this to reset csum offload bits */</a>
<a name="ln1778">			txp-&gt;tx_cb-&gt;tbd[0].tb_addr = 0;</a>
<a name="ln1779">		}</a>
<a name="ln1780">		sc-&gt;tx_queued--;</a>
<a name="ln1781">		if_setdrvflagbits(ifp, 0, IFF_DRV_OACTIVE);</a>
<a name="ln1782">	}</a>
<a name="ln1783">	sc-&gt;fxp_desc.tx_first = txp;</a>
<a name="ln1784">	bus_dmamap_sync(sc-&gt;cbl_tag, sc-&gt;cbl_map,</a>
<a name="ln1785">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln1786">	if (sc-&gt;tx_queued == 0)</a>
<a name="ln1787">		sc-&gt;watchdog_timer = 0;</a>
<a name="ln1788">}</a>
<a name="ln1789"> </a>
<a name="ln1790">static void</a>
<a name="ln1791">fxp_rxcsum(struct fxp_softc *sc, if_t ifp, struct mbuf *m,</a>
<a name="ln1792">    uint16_t status, int pos)</a>
<a name="ln1793">{</a>
<a name="ln1794">	struct ether_header *eh;</a>
<a name="ln1795">	struct ip *ip;</a>
<a name="ln1796">	struct udphdr *uh;</a>
<a name="ln1797">	int32_t hlen, len, pktlen, temp32;</a>
<a name="ln1798">	uint16_t csum, *opts;</a>
<a name="ln1799"> </a>
<a name="ln1800">	if ((sc-&gt;flags &amp; FXP_FLAG_82559_RXCSUM) == 0) {</a>
<a name="ln1801">		if ((status &amp; FXP_RFA_STATUS_PARSE) != 0) {</a>
<a name="ln1802">			if (status &amp; FXP_RFDX_CS_IP_CSUM_BIT_VALID)</a>
<a name="ln1803">				m-&gt;m_pkthdr.csum_flags |= CSUM_IP_CHECKED;</a>
<a name="ln1804">			if (status &amp; FXP_RFDX_CS_IP_CSUM_VALID)</a>
<a name="ln1805">				m-&gt;m_pkthdr.csum_flags |= CSUM_IP_VALID;</a>
<a name="ln1806">			if ((status &amp; FXP_RFDX_CS_TCPUDP_CSUM_BIT_VALID) &amp;&amp;</a>
<a name="ln1807">			    (status &amp; FXP_RFDX_CS_TCPUDP_CSUM_VALID)) {</a>
<a name="ln1808">				m-&gt;m_pkthdr.csum_flags |= CSUM_DATA_VALID |</a>
<a name="ln1809">				    CSUM_PSEUDO_HDR;</a>
<a name="ln1810">				m-&gt;m_pkthdr.csum_data = 0xffff;</a>
<a name="ln1811">			}</a>
<a name="ln1812">		}</a>
<a name="ln1813">		return;</a>
<a name="ln1814">	}</a>
<a name="ln1815"> </a>
<a name="ln1816">	pktlen = m-&gt;m_pkthdr.len;</a>
<a name="ln1817">	if (pktlen &lt; sizeof(struct ether_header) + sizeof(struct ip))</a>
<a name="ln1818">		return;</a>
<a name="ln1819">	eh = mtod(m, struct ether_header *);</a>
<a name="ln1820">	if (eh-&gt;ether_type != htons(ETHERTYPE_IP))</a>
<a name="ln1821">		return;</a>
<a name="ln1822">	ip = (struct ip *)(eh + 1);</a>
<a name="ln1823">	if (ip-&gt;ip_v != IPVERSION)</a>
<a name="ln1824">		return;</a>
<a name="ln1825"> </a>
<a name="ln1826">	hlen = ip-&gt;ip_hl &lt;&lt; 2;</a>
<a name="ln1827">	pktlen -= sizeof(struct ether_header);</a>
<a name="ln1828">	if (hlen &lt; sizeof(struct ip))</a>
<a name="ln1829">		return;</a>
<a name="ln1830">	if (ntohs(ip-&gt;ip_len) &lt; hlen)</a>
<a name="ln1831">		return;</a>
<a name="ln1832">	if (ntohs(ip-&gt;ip_len) != pktlen)</a>
<a name="ln1833">		return;</a>
<a name="ln1834">	if (ip-&gt;ip_off &amp; htons(IP_MF | IP_OFFMASK))</a>
<a name="ln1835">		return;	/* can't handle fragmented packet */</a>
<a name="ln1836"> </a>
<a name="ln1837">	switch (ip-&gt;ip_p) {</a>
<a name="ln1838">	case IPPROTO_TCP:</a>
<a name="ln1839">		if (pktlen &lt; (hlen + sizeof(struct tcphdr)))</a>
<a name="ln1840">			return;</a>
<a name="ln1841">		break;</a>
<a name="ln1842">	case IPPROTO_UDP:</a>
<a name="ln1843">		if (pktlen &lt; (hlen + sizeof(struct udphdr)))</a>
<a name="ln1844">			return;</a>
<a name="ln1845">		uh = (struct udphdr *)((caddr_t)ip + hlen);</a>
<a name="ln1846">		if (uh-&gt;uh_sum == 0)</a>
<a name="ln1847">			return; /* no checksum */</a>
<a name="ln1848">		break;</a>
<a name="ln1849">	default:</a>
<a name="ln1850">		return;</a>
<a name="ln1851">	}</a>
<a name="ln1852">	/* Extract computed checksum. */</a>
<a name="ln1853">	csum = be16dec(mtod(m, char *) + pos);</a>
<a name="ln1854">	/* checksum fixup for IP options */</a>
<a name="ln1855">	len = hlen - sizeof(struct ip);</a>
<a name="ln1856">	if (len &gt; 0) {</a>
<a name="ln1857">		opts = (uint16_t *)(ip + 1);</a>
<a name="ln1858">		for (; len &gt; 0; len -= sizeof(uint16_t), opts++) {</a>
<a name="ln1859">			temp32 = csum - *opts;</a>
<a name="ln1860">			temp32 = (temp32 &gt;&gt; 16) + (temp32 &amp; 65535);</a>
<a name="ln1861">			csum = temp32 &amp; 65535;</a>
<a name="ln1862">		}</a>
<a name="ln1863">	}</a>
<a name="ln1864">	m-&gt;m_pkthdr.csum_flags |= CSUM_DATA_VALID;</a>
<a name="ln1865">	m-&gt;m_pkthdr.csum_data = csum;</a>
<a name="ln1866">}</a>
<a name="ln1867"> </a>
<a name="ln1868">static int</a>
<a name="ln1869">fxp_intr_body(struct fxp_softc *sc, if_t ifp, uint8_t statack,</a>
<a name="ln1870">    int count)</a>
<a name="ln1871">{</a>
<a name="ln1872">	struct mbuf *m;</a>
<a name="ln1873">	struct fxp_rx *rxp;</a>
<a name="ln1874">	struct fxp_rfa *rfa;</a>
<a name="ln1875">	int rnr = (statack &amp; FXP_SCB_STATACK_RNR) ? 1 : 0;</a>
<a name="ln1876">	int rx_npkts;</a>
<a name="ln1877">	uint16_t status;</a>
<a name="ln1878"> </a>
<a name="ln1879">	rx_npkts = 0;</a>
<a name="ln1880">	FXP_LOCK_ASSERT(sc, MA_OWNED);</a>
<a name="ln1881"> </a>
<a name="ln1882">	if (rnr)</a>
<a name="ln1883">		sc-&gt;rnr++;</a>
<a name="ln1884">#ifdef DEVICE_POLLING</a>
<a name="ln1885">	/* Pick up a deferred RNR condition if `count' ran out last time. */</a>
<a name="ln1886">	if (sc-&gt;flags &amp; FXP_FLAG_DEFERRED_RNR) {</a>
<a name="ln1887">		sc-&gt;flags &amp;= ~FXP_FLAG_DEFERRED_RNR;</a>
<a name="ln1888">		rnr = 1;</a>
<a name="ln1889">	}</a>
<a name="ln1890">#endif</a>
<a name="ln1891"> </a>
<a name="ln1892">	/*</a>
<a name="ln1893">	 * Free any finished transmit mbuf chains.</a>
<a name="ln1894">	 *</a>
<a name="ln1895">	 * Handle the CNA event likt a CXTNO event. It used to</a>
<a name="ln1896">	 * be that this event (control unit not ready) was not</a>
<a name="ln1897">	 * encountered, but it is now with the SMPng modifications.</a>
<a name="ln1898">	 * The exact sequence of events that occur when the interface</a>
<a name="ln1899">	 * is brought up are different now, and if this event</a>
<a name="ln1900">	 * goes unhandled, the configuration/rxfilter setup sequence</a>
<a name="ln1901">	 * can stall for several seconds. The result is that no</a>
<a name="ln1902">	 * packets go out onto the wire for about 5 to 10 seconds</a>
<a name="ln1903">	 * after the interface is ifconfig'ed for the first time.</a>
<a name="ln1904">	 */</a>
<a name="ln1905">	if (statack &amp; (FXP_SCB_STATACK_CXTNO | FXP_SCB_STATACK_CNA))</a>
<a name="ln1906">		fxp_txeof(sc);</a>
<a name="ln1907"> </a>
<a name="ln1908">	/*</a>
<a name="ln1909">	 * Try to start more packets transmitting.</a>
<a name="ln1910">	 */</a>
<a name="ln1911">	if (!if_sendq_empty(ifp))</a>
<a name="ln1912">		fxp_start_body(ifp);</a>
<a name="ln1913"> </a>
<a name="ln1914">	/*</a>
<a name="ln1915">	 * Just return if nothing happened on the receive side.</a>
<a name="ln1916">	 */</a>
<a name="ln1917">	if (!rnr &amp;&amp; (statack &amp; FXP_SCB_STATACK_FR) == 0)</a>
<a name="ln1918">		return (rx_npkts);</a>
<a name="ln1919"> </a>
<a name="ln1920">	/*</a>
<a name="ln1921">	 * Process receiver interrupts. If a no-resource (RNR)</a>
<a name="ln1922">	 * condition exists, get whatever packets we can and</a>
<a name="ln1923">	 * re-start the receiver.</a>
<a name="ln1924">	 *</a>
<a name="ln1925">	 * When using polling, we do not process the list to completion,</a>
<a name="ln1926">	 * so when we get an RNR interrupt we must defer the restart</a>
<a name="ln1927">	 * until we hit the last buffer with the C bit set.</a>
<a name="ln1928">	 * If we run out of cycles and rfa_headm has the C bit set,</a>
<a name="ln1929">	 * record the pending RNR in the FXP_FLAG_DEFERRED_RNR flag so</a>
<a name="ln1930">	 * that the info will be used in the subsequent polling cycle.</a>
<a name="ln1931">	 */</a>
<a name="ln1932">	for (;;) {</a>
<a name="ln1933">		rxp = sc-&gt;fxp_desc.rx_head;</a>
<a name="ln1934">		m = rxp-&gt;rx_mbuf;</a>
<a name="ln1935">		rfa = (struct fxp_rfa *)(m-&gt;m_ext.ext_buf +</a>
<a name="ln1936">		    RFA_ALIGNMENT_FUDGE);</a>
<a name="ln1937">		bus_dmamap_sync(sc-&gt;fxp_rxmtag, rxp-&gt;rx_map,</a>
<a name="ln1938">		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);</a>
<a name="ln1939"> </a>
<a name="ln1940">#ifdef DEVICE_POLLING /* loop at most count times if count &gt;=0 */</a>
<a name="ln1941">		if (count &gt;= 0 &amp;&amp; count-- == 0) {</a>
<a name="ln1942">			if (rnr) {</a>
<a name="ln1943">				/* Defer RNR processing until the next time. */</a>
<a name="ln1944">				sc-&gt;flags |= FXP_FLAG_DEFERRED_RNR;</a>
<a name="ln1945">				rnr = 0;</a>
<a name="ln1946">			}</a>
<a name="ln1947">			break;</a>
<a name="ln1948">		}</a>
<a name="ln1949">#endif /* DEVICE_POLLING */</a>
<a name="ln1950"> </a>
<a name="ln1951">		status = le16toh(rfa-&gt;rfa_status);</a>
<a name="ln1952">		if ((status &amp; FXP_RFA_STATUS_C) == 0)</a>
<a name="ln1953">			break;</a>
<a name="ln1954"> </a>
<a name="ln1955">		if ((status &amp; FXP_RFA_STATUS_RNR) != 0)</a>
<a name="ln1956">			rnr++;</a>
<a name="ln1957">		/*</a>
<a name="ln1958">		 * Advance head forward.</a>
<a name="ln1959">		 */</a>
<a name="ln1960">		sc-&gt;fxp_desc.rx_head = rxp-&gt;rx_next;</a>
<a name="ln1961"> </a>
<a name="ln1962">		/*</a>
<a name="ln1963">		 * Add a new buffer to the receive chain.</a>
<a name="ln1964">		 * If this fails, the old buffer is recycled</a>
<a name="ln1965">		 * instead.</a>
<a name="ln1966">		 */</a>
<a name="ln1967">		if (fxp_new_rfabuf(sc, rxp) == 0) {</a>
<a name="ln1968">			int total_len;</a>
<a name="ln1969"> </a>
<a name="ln1970">			/*</a>
<a name="ln1971">			 * Fetch packet length (the top 2 bits of</a>
<a name="ln1972">			 * actual_size are flags set by the controller</a>
<a name="ln1973">			 * upon completion), and drop the packet in case</a>
<a name="ln1974">			 * of bogus length or CRC errors.</a>
<a name="ln1975">			 */</a>
<a name="ln1976">			total_len = le16toh(rfa-&gt;actual_size) &amp; 0x3fff;</a>
<a name="ln1977">			if ((sc-&gt;flags &amp; FXP_FLAG_82559_RXCSUM) != 0 &amp;&amp;</a>
<a name="ln1978">			    (if_getcapenable(ifp) &amp; IFCAP_RXCSUM) != 0) {</a>
<a name="ln1979">				/* Adjust for appended checksum bytes. */</a>
<a name="ln1980">				total_len -= 2;</a>
<a name="ln1981">			}</a>
<a name="ln1982">			if (total_len &lt; (int)sizeof(struct ether_header) ||</a>
<a name="ln1983">			    total_len &gt; (MCLBYTES - RFA_ALIGNMENT_FUDGE -</a>
<a name="ln1984">			    sc-&gt;rfa_size) ||</a>
<a name="ln1985">			    status &amp; (FXP_RFA_STATUS_CRC |</a>
<a name="ln1986">			    FXP_RFA_STATUS_ALIGN | FXP_RFA_STATUS_OVERRUN)) {</a>
<a name="ln1987">				m_freem(m);</a>
<a name="ln1988">				fxp_add_rfabuf(sc, rxp);</a>
<a name="ln1989">				continue;</a>
<a name="ln1990">			}</a>
<a name="ln1991"> </a>
<a name="ln1992">			m-&gt;m_pkthdr.len = m-&gt;m_len = total_len;</a>
<a name="ln1993">			if_setrcvif(m, ifp);</a>
<a name="ln1994"> </a>
<a name="ln1995">                        /* Do IP checksum checking. */</a>
<a name="ln1996">			if ((if_getcapenable(ifp) &amp; IFCAP_RXCSUM) != 0)</a>
<a name="ln1997">				fxp_rxcsum(sc, ifp, m, status, total_len);</a>
<a name="ln1998">			if ((if_getcapenable(ifp) &amp; IFCAP_VLAN_HWTAGGING) != 0 &amp;&amp;</a>
<a name="ln1999">			    (status &amp; FXP_RFA_STATUS_VLAN) != 0) {</a>
<a name="ln2000">				m-&gt;m_pkthdr.ether_vtag =</a>
<a name="ln2001">				    ntohs(rfa-&gt;rfax_vlan_id);</a>
<a name="ln2002">				m-&gt;m_flags |= M_VLANTAG;</a>
<a name="ln2003">			}</a>
<a name="ln2004">			/*</a>
<a name="ln2005">			 * Drop locks before calling if_input() since it</a>
<a name="ln2006">			 * may re-enter fxp_start() in the netisr case.</a>
<a name="ln2007">			 * This would result in a lock reversal.  Better</a>
<a name="ln2008">			 * performance might be obtained by chaining all</a>
<a name="ln2009">			 * packets received, dropping the lock, and then</a>
<a name="ln2010">			 * calling if_input() on each one.</a>
<a name="ln2011">			 */</a>
<a name="ln2012">			FXP_UNLOCK(sc);</a>
<a name="ln2013">			if_input(ifp, m);</a>
<a name="ln2014">			FXP_LOCK(sc);</a>
<a name="ln2015">			rx_npkts++;</a>
<a name="ln2016">			if ((if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING) == 0)</a>
<a name="ln2017">				return (rx_npkts);</a>
<a name="ln2018">		} else {</a>
<a name="ln2019">			/* Reuse RFA and loaded DMA map. */</a>
<a name="ln2020">			if_inc_counter(ifp, IFCOUNTER_IQDROPS, 1);</a>
<a name="ln2021">			fxp_discard_rfabuf(sc, rxp);</a>
<a name="ln2022">		}</a>
<a name="ln2023">		fxp_add_rfabuf(sc, rxp);</a>
<a name="ln2024">	}</a>
<a name="ln2025">	if (rnr) {</a>
<a name="ln2026">		fxp_scb_wait(sc);</a>
<a name="ln2027">		CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL,</a>
<a name="ln2028">		    sc-&gt;fxp_desc.rx_head-&gt;rx_addr);</a>
<a name="ln2029">		fxp_scb_cmd(sc, FXP_SCB_COMMAND_RU_START);</a>
<a name="ln2030">	}</a>
<a name="ln2031">	return (rx_npkts);</a>
<a name="ln2032">}</a>
<a name="ln2033"> </a>
<a name="ln2034">static void</a>
<a name="ln2035">fxp_update_stats(struct fxp_softc *sc)</a>
<a name="ln2036">{</a>
<a name="ln2037">	if_t ifp = sc-&gt;ifp;</a>
<a name="ln2038">	struct fxp_stats *sp = sc-&gt;fxp_stats;</a>
<a name="ln2039">	struct fxp_hwstats *hsp;</a>
<a name="ln2040">	uint32_t *status;</a>
<a name="ln2041"> </a>
<a name="ln2042">	FXP_LOCK_ASSERT(sc, MA_OWNED);</a>
<a name="ln2043"> </a>
<a name="ln2044">	bus_dmamap_sync(sc-&gt;fxp_stag, sc-&gt;fxp_smap,</a>
<a name="ln2045">	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);</a>
<a name="ln2046">	/* Update statistical counters. */</a>
<a name="ln2047">	if (sc-&gt;revision &gt;= FXP_REV_82559_A0)</a>
<a name="ln2048">		status = &amp;sp-&gt;completion_status;</a>
<a name="ln2049">	else if (sc-&gt;revision &gt;= FXP_REV_82558_A4)</a>
<a name="ln2050">		status = (uint32_t *)&amp;sp-&gt;tx_tco;</a>
<a name="ln2051">	else</a>
<a name="ln2052">		status = &amp;sp-&gt;tx_pause;</a>
<a name="ln2053">	if (*status == htole32(FXP_STATS_DR_COMPLETE)) {</a>
<a name="ln2054">		hsp = &amp;sc-&gt;fxp_hwstats;</a>
<a name="ln2055">		hsp-&gt;tx_good += le32toh(sp-&gt;tx_good);</a>
<a name="ln2056">		hsp-&gt;tx_maxcols += le32toh(sp-&gt;tx_maxcols);</a>
<a name="ln2057">		hsp-&gt;tx_latecols += le32toh(sp-&gt;tx_latecols);</a>
<a name="ln2058">		hsp-&gt;tx_underruns += le32toh(sp-&gt;tx_underruns);</a>
<a name="ln2059">		hsp-&gt;tx_lostcrs += le32toh(sp-&gt;tx_lostcrs);</a>
<a name="ln2060">		hsp-&gt;tx_deffered += le32toh(sp-&gt;tx_deffered);</a>
<a name="ln2061">		hsp-&gt;tx_single_collisions += le32toh(sp-&gt;tx_single_collisions);</a>
<a name="ln2062">		hsp-&gt;tx_multiple_collisions +=</a>
<a name="ln2063">		    le32toh(sp-&gt;tx_multiple_collisions);</a>
<a name="ln2064">		hsp-&gt;tx_total_collisions += le32toh(sp-&gt;tx_total_collisions);</a>
<a name="ln2065">		hsp-&gt;rx_good += le32toh(sp-&gt;rx_good);</a>
<a name="ln2066">		hsp-&gt;rx_crc_errors += le32toh(sp-&gt;rx_crc_errors);</a>
<a name="ln2067">		hsp-&gt;rx_alignment_errors += le32toh(sp-&gt;rx_alignment_errors);</a>
<a name="ln2068">		hsp-&gt;rx_rnr_errors += le32toh(sp-&gt;rx_rnr_errors);</a>
<a name="ln2069">		hsp-&gt;rx_overrun_errors += le32toh(sp-&gt;rx_overrun_errors);</a>
<a name="ln2070">		hsp-&gt;rx_cdt_errors += le32toh(sp-&gt;rx_cdt_errors);</a>
<a name="ln2071">		hsp-&gt;rx_shortframes += le32toh(sp-&gt;rx_shortframes);</a>
<a name="ln2072">		hsp-&gt;tx_pause += le32toh(sp-&gt;tx_pause);</a>
<a name="ln2073">		hsp-&gt;rx_pause += le32toh(sp-&gt;rx_pause);</a>
<a name="ln2074">		hsp-&gt;rx_controls += le32toh(sp-&gt;rx_controls);</a>
<a name="ln2075">		hsp-&gt;tx_tco += le16toh(sp-&gt;tx_tco);</a>
<a name="ln2076">		hsp-&gt;rx_tco += le16toh(sp-&gt;rx_tco);</a>
<a name="ln2077"> </a>
<a name="ln2078">		if_inc_counter(ifp, IFCOUNTER_OPACKETS, le32toh(sp-&gt;tx_good));</a>
<a name="ln2079">		if_inc_counter(ifp, IFCOUNTER_COLLISIONS,</a>
<a name="ln2080">		    le32toh(sp-&gt;tx_total_collisions));</a>
<a name="ln2081">		if (sp-&gt;rx_good) {</a>
<a name="ln2082">			if_inc_counter(ifp, IFCOUNTER_IPACKETS,</a>
<a name="ln2083">			    le32toh(sp-&gt;rx_good));</a>
<a name="ln2084">			sc-&gt;rx_idle_secs = 0;</a>
<a name="ln2085">		} else if (sc-&gt;flags &amp; FXP_FLAG_RXBUG) {</a>
<a name="ln2086">			/*</a>
<a name="ln2087">			 * Receiver's been idle for another second.</a>
<a name="ln2088">			 */</a>
<a name="ln2089">			sc-&gt;rx_idle_secs++;</a>
<a name="ln2090">		}</a>
<a name="ln2091">		if_inc_counter(ifp, IFCOUNTER_IERRORS,</a>
<a name="ln2092">		    le32toh(sp-&gt;rx_crc_errors) +</a>
<a name="ln2093">		    le32toh(sp-&gt;rx_alignment_errors) +</a>
<a name="ln2094">		    le32toh(sp-&gt;rx_rnr_errors) +</a>
<a name="ln2095">		    le32toh(sp-&gt;rx_overrun_errors));</a>
<a name="ln2096">		/*</a>
<a name="ln2097">		 * If any transmit underruns occurred, bump up the transmit</a>
<a name="ln2098">		 * threshold by another 512 bytes (64 * 8).</a>
<a name="ln2099">		 */</a>
<a name="ln2100">		if (sp-&gt;tx_underruns) {</a>
<a name="ln2101">			if_inc_counter(ifp, IFCOUNTER_OERRORS,</a>
<a name="ln2102">			    le32toh(sp-&gt;tx_underruns));</a>
<a name="ln2103">			if (tx_threshold &lt; 192)</a>
<a name="ln2104">				tx_threshold += 64;</a>
<a name="ln2105">		}</a>
<a name="ln2106">		*status = 0;</a>
<a name="ln2107">		bus_dmamap_sync(sc-&gt;fxp_stag, sc-&gt;fxp_smap,</a>
<a name="ln2108">		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln2109">	}</a>
<a name="ln2110">}</a>
<a name="ln2111"> </a>
<a name="ln2112">/*</a>
<a name="ln2113"> * Update packet in/out/collision statistics. The i82557 doesn't</a>
<a name="ln2114"> * allow you to access these counters without doing a fairly</a>
<a name="ln2115"> * expensive DMA to get _all_ of the statistics it maintains, so</a>
<a name="ln2116"> * we do this operation here only once per second. The statistics</a>
<a name="ln2117"> * counters in the kernel are updated from the previous dump-stats</a>
<a name="ln2118"> * DMA and then a new dump-stats DMA is started. The on-chip</a>
<a name="ln2119"> * counters are zeroed when the DMA completes. If we can't start</a>
<a name="ln2120"> * the DMA immediately, we don't wait - we just prepare to read</a>
<a name="ln2121"> * them again next time.</a>
<a name="ln2122"> */</a>
<a name="ln2123">static void</a>
<a name="ln2124">fxp_tick(void *xsc)</a>
<a name="ln2125">{</a>
<a name="ln2126">	struct fxp_softc *sc = xsc;</a>
<a name="ln2127">	if_t ifp = sc-&gt;ifp;</a>
<a name="ln2128"> </a>
<a name="ln2129">	FXP_LOCK_ASSERT(sc, MA_OWNED);</a>
<a name="ln2130"> </a>
<a name="ln2131">	/* Update statistical counters. */</a>
<a name="ln2132">	fxp_update_stats(sc);</a>
<a name="ln2133"> </a>
<a name="ln2134">	/*</a>
<a name="ln2135">	 * Release any xmit buffers that have completed DMA. This isn't</a>
<a name="ln2136">	 * strictly necessary to do here, but it's advantagous for mbufs</a>
<a name="ln2137">	 * with external storage to be released in a timely manner rather</a>
<a name="ln2138">	 * than being defered for a potentially long time. This limits</a>
<a name="ln2139">	 * the delay to a maximum of one second.</a>
<a name="ln2140">	 */</a>
<a name="ln2141">	fxp_txeof(sc);</a>
<a name="ln2142"> </a>
<a name="ln2143">	/*</a>
<a name="ln2144">	 * If we haven't received any packets in FXP_MAC_RX_IDLE seconds,</a>
<a name="ln2145">	 * then assume the receiver has locked up and attempt to clear</a>
<a name="ln2146">	 * the condition by reprogramming the multicast filter. This is</a>
<a name="ln2147">	 * a work-around for a bug in the 82557 where the receiver locks</a>
<a name="ln2148">	 * up if it gets certain types of garbage in the synchronization</a>
<a name="ln2149">	 * bits prior to the packet header. This bug is supposed to only</a>
<a name="ln2150">	 * occur in 10Mbps mode, but has been seen to occur in 100Mbps</a>
<a name="ln2151">	 * mode as well (perhaps due to a 10/100 speed transition).</a>
<a name="ln2152">	 */</a>
<a name="ln2153">	if (sc-&gt;rx_idle_secs &gt; FXP_MAX_RX_IDLE) {</a>
<a name="ln2154">		sc-&gt;rx_idle_secs = 0;</a>
<a name="ln2155">		if ((if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING) != 0) {</a>
<a name="ln2156">			if_setdrvflagbits(ifp, 0, IFF_DRV_RUNNING);</a>
<a name="ln2157">			fxp_init_body(sc, 1);</a>
<a name="ln2158">		}</a>
<a name="ln2159">		return;</a>
<a name="ln2160">	}</a>
<a name="ln2161">	/*</a>
<a name="ln2162">	 * If there is no pending command, start another stats</a>
<a name="ln2163">	 * dump. Otherwise punt for now.</a>
<a name="ln2164">	 */</a>
<a name="ln2165">	if (CSR_READ_1(sc, FXP_CSR_SCB_COMMAND) == 0) {</a>
<a name="ln2166">		/*</a>
<a name="ln2167">		 * Start another stats dump.</a>
<a name="ln2168">		 */</a>
<a name="ln2169">		fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_DUMPRESET);</a>
<a name="ln2170">	}</a>
<a name="ln2171">	if (sc-&gt;miibus != NULL)</a>
<a name="ln2172">		mii_tick(device_get_softc(sc-&gt;miibus));</a>
<a name="ln2173"> </a>
<a name="ln2174">	/*</a>
<a name="ln2175">	 * Check that chip hasn't hung.</a>
<a name="ln2176">	 */</a>
<a name="ln2177">	fxp_watchdog(sc);</a>
<a name="ln2178"> </a>
<a name="ln2179">	/*</a>
<a name="ln2180">	 * Schedule another timeout one second from now.</a>
<a name="ln2181">	 */</a>
<a name="ln2182">	callout_reset(&amp;sc-&gt;stat_ch, hz, fxp_tick, sc);</a>
<a name="ln2183">}</a>
<a name="ln2184"> </a>
<a name="ln2185">/*</a>
<a name="ln2186"> * Stop the interface. Cancels the statistics updater and resets</a>
<a name="ln2187"> * the interface.</a>
<a name="ln2188"> */</a>
<a name="ln2189">static void</a>
<a name="ln2190">fxp_stop(struct fxp_softc *sc)</a>
<a name="ln2191">{</a>
<a name="ln2192">	if_t ifp = sc-&gt;ifp;</a>
<a name="ln2193">	struct fxp_tx *txp;</a>
<a name="ln2194">	int i;</a>
<a name="ln2195"> </a>
<a name="ln2196">	if_setdrvflagbits(ifp, 0, (IFF_DRV_RUNNING | IFF_DRV_OACTIVE));</a>
<a name="ln2197">	sc-&gt;watchdog_timer = 0;</a>
<a name="ln2198"> </a>
<a name="ln2199">	/*</a>
<a name="ln2200">	 * Cancel stats updater.</a>
<a name="ln2201">	 */</a>
<a name="ln2202">	callout_stop(&amp;sc-&gt;stat_ch);</a>
<a name="ln2203"> </a>
<a name="ln2204">	/*</a>
<a name="ln2205">	 * Preserve PCI configuration, configure, IA/multicast</a>
<a name="ln2206">	 * setup and put RU and CU into idle state.</a>
<a name="ln2207">	 */</a>
<a name="ln2208">	CSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SELECTIVE_RESET);</a>
<a name="ln2209">	DELAY(50);</a>
<a name="ln2210">	/* Disable interrupts. */</a>
<a name="ln2211">	CSR_WRITE_1(sc, FXP_CSR_SCB_INTRCNTL, FXP_SCB_INTR_DISABLE);</a>
<a name="ln2212"> </a>
<a name="ln2213">	fxp_update_stats(sc);</a>
<a name="ln2214"> </a>
<a name="ln2215">	/*</a>
<a name="ln2216">	 * Release any xmit buffers.</a>
<a name="ln2217">	 */</a>
<a name="ln2218">	txp = sc-&gt;fxp_desc.tx_list;</a>
<a name="ln2219">	for (i = 0; i &lt; FXP_NTXCB; i++) {</a>
<a name="ln2220">		if (txp[i].tx_mbuf != NULL) {</a>
<a name="ln2221">			bus_dmamap_sync(sc-&gt;fxp_txmtag, txp[i].tx_map,</a>
<a name="ln2222">			    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln2223">			bus_dmamap_unload(sc-&gt;fxp_txmtag, txp[i].tx_map);</a>
<a name="ln2224">			m_freem(txp[i].tx_mbuf);</a>
<a name="ln2225">			txp[i].tx_mbuf = NULL;</a>
<a name="ln2226">			/* clear this to reset csum offload bits */</a>
<a name="ln2227">			txp[i].tx_cb-&gt;tbd[0].tb_addr = 0;</a>
<a name="ln2228">		}</a>
<a name="ln2229">	}</a>
<a name="ln2230">	bus_dmamap_sync(sc-&gt;cbl_tag, sc-&gt;cbl_map,</a>
<a name="ln2231">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln2232">	sc-&gt;tx_queued = 0;</a>
<a name="ln2233">}</a>
<a name="ln2234"> </a>
<a name="ln2235">/*</a>
<a name="ln2236"> * Watchdog/transmission transmit timeout handler. Called when a</a>
<a name="ln2237"> * transmission is started on the interface, but no interrupt is</a>
<a name="ln2238"> * received before the timeout. This usually indicates that the</a>
<a name="ln2239"> * card has wedged for some reason.</a>
<a name="ln2240"> */</a>
<a name="ln2241">static void</a>
<a name="ln2242">fxp_watchdog(struct fxp_softc *sc)</a>
<a name="ln2243">{</a>
<a name="ln2244">	if_t ifp = sc-&gt;ifp;</a>
<a name="ln2245"> </a>
<a name="ln2246">	FXP_LOCK_ASSERT(sc, MA_OWNED);</a>
<a name="ln2247"> </a>
<a name="ln2248">	if (sc-&gt;watchdog_timer == 0 || --sc-&gt;watchdog_timer)</a>
<a name="ln2249">		return;</a>
<a name="ln2250"> </a>
<a name="ln2251">	device_printf(sc-&gt;dev, &quot;device timeout\n&quot;);</a>
<a name="ln2252">	if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln2253"> </a>
<a name="ln2254">	if_setdrvflagbits(ifp, 0, IFF_DRV_RUNNING);</a>
<a name="ln2255">	fxp_init_body(sc, 1);</a>
<a name="ln2256">}</a>
<a name="ln2257"> </a>
<a name="ln2258">/*</a>
<a name="ln2259"> * Acquire locks and then call the real initialization function.  This</a>
<a name="ln2260"> * is necessary because ether_ioctl() calls if_init() and this would</a>
<a name="ln2261"> * result in mutex recursion if the mutex was held.</a>
<a name="ln2262"> */</a>
<a name="ln2263">static void</a>
<a name="ln2264">fxp_init(void *xsc)</a>
<a name="ln2265">{</a>
<a name="ln2266">	struct fxp_softc *sc = xsc;</a>
<a name="ln2267"> </a>
<a name="ln2268">	FXP_LOCK(sc);</a>
<a name="ln2269">	fxp_init_body(sc, 1);</a>
<a name="ln2270">	FXP_UNLOCK(sc);</a>
<a name="ln2271">}</a>
<a name="ln2272"> </a>
<a name="ln2273">/*</a>
<a name="ln2274"> * Perform device initialization. This routine must be called with the</a>
<a name="ln2275"> * softc lock held.</a>
<a name="ln2276"> */</a>
<a name="ln2277">static void</a>
<a name="ln2278">fxp_init_body(struct fxp_softc *sc, int setmedia)</a>
<a name="ln2279">{</a>
<a name="ln2280">	if_t ifp = sc-&gt;ifp;</a>
<a name="ln2281">	struct mii_data *mii;</a>
<a name="ln2282">	struct fxp_cb_config *cbp;</a>
<a name="ln2283">	struct fxp_cb_ias *cb_ias;</a>
<a name="ln2284">	struct fxp_cb_tx *tcbp;</a>
<a name="ln2285">	struct fxp_tx *txp;</a>
<a name="ln2286">	int i, prm;</a>
<a name="ln2287"> </a>
<a name="ln2288">	FXP_LOCK_ASSERT(sc, MA_OWNED);</a>
<a name="ln2289"> </a>
<a name="ln2290">	if (if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING)</a>
<a name="ln2291">		return;</a>
<a name="ln2292"> </a>
<a name="ln2293">	/*</a>
<a name="ln2294">	 * Cancel any pending I/O</a>
<a name="ln2295">	 */</a>
<a name="ln2296">	fxp_stop(sc);</a>
<a name="ln2297"> </a>
<a name="ln2298">	/*</a>
<a name="ln2299">	 * Issue software reset, which also unloads the microcode.</a>
<a name="ln2300">	 */</a>
<a name="ln2301">	sc-&gt;flags &amp;= ~FXP_FLAG_UCODE;</a>
<a name="ln2302">	CSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SOFTWARE_RESET);</a>
<a name="ln2303">	DELAY(50);</a>
<a name="ln2304"> </a>
<a name="ln2305">	prm = (if_getflags(ifp) &amp; IFF_PROMISC) ? 1 : 0;</a>
<a name="ln2306"> </a>
<a name="ln2307">	/*</a>
<a name="ln2308">	 * Initialize base of CBL and RFA memory. Loading with zero</a>
<a name="ln2309">	 * sets it up for regular linear addressing.</a>
<a name="ln2310">	 */</a>
<a name="ln2311">	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, 0);</a>
<a name="ln2312">	fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_BASE);</a>
<a name="ln2313"> </a>
<a name="ln2314">	fxp_scb_wait(sc);</a>
<a name="ln2315">	fxp_scb_cmd(sc, FXP_SCB_COMMAND_RU_BASE);</a>
<a name="ln2316"> </a>
<a name="ln2317">	/*</a>
<a name="ln2318">	 * Initialize base of dump-stats buffer.</a>
<a name="ln2319">	 */</a>
<a name="ln2320">	fxp_scb_wait(sc);</a>
<a name="ln2321">	bzero(sc-&gt;fxp_stats, sizeof(struct fxp_stats));</a>
<a name="ln2322">	bus_dmamap_sync(sc-&gt;fxp_stag, sc-&gt;fxp_smap,</a>
<a name="ln2323">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln2324">	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, sc-&gt;stats_addr);</a>
<a name="ln2325">	fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_DUMP_ADR);</a>
<a name="ln2326"> </a>
<a name="ln2327">	/*</a>
<a name="ln2328">	 * Attempt to load microcode if requested.</a>
<a name="ln2329">	 * For ICH based controllers do not load microcode.</a>
<a name="ln2330">	 */</a>
<a name="ln2331">	if (sc-&gt;ident-&gt;ich == 0) {</a>
<a name="ln2332">		if (if_getflags(ifp) &amp; IFF_LINK0 &amp;&amp;</a>
<a name="ln2333">		    (sc-&gt;flags &amp; FXP_FLAG_UCODE) == 0)</a>
<a name="ln2334">			fxp_load_ucode(sc);</a>
<a name="ln2335">	}</a>
<a name="ln2336"> </a>
<a name="ln2337">	/*</a>
<a name="ln2338">	 * Set IFF_ALLMULTI status. It's needed in configure action</a>
<a name="ln2339">	 * command.</a>
<a name="ln2340">	 */</a>
<a name="ln2341">	fxp_mc_addrs(sc);</a>
<a name="ln2342"> </a>
<a name="ln2343">	/*</a>
<a name="ln2344">	 * We temporarily use memory that contains the TxCB list to</a>
<a name="ln2345">	 * construct the config CB. The TxCB list memory is rebuilt</a>
<a name="ln2346">	 * later.</a>
<a name="ln2347">	 */</a>
<a name="ln2348">	cbp = (struct fxp_cb_config *)sc-&gt;fxp_desc.cbl_list;</a>
<a name="ln2349"> </a>
<a name="ln2350">	/*</a>
<a name="ln2351">	 * This bcopy is kind of disgusting, but there are a bunch of must be</a>
<a name="ln2352">	 * zero and must be one bits in this structure and this is the easiest</a>
<a name="ln2353">	 * way to initialize them all to proper values.</a>
<a name="ln2354">	 */</a>
<a name="ln2355">	bcopy(fxp_cb_config_template, cbp, sizeof(fxp_cb_config_template));</a>
<a name="ln2356"> </a>
<a name="ln2357">	cbp-&gt;cb_status =	0;</a>
<a name="ln2358">	cbp-&gt;cb_command =	htole16(FXP_CB_COMMAND_CONFIG |</a>
<a name="ln2359">	    FXP_CB_COMMAND_EL);</a>
<a name="ln2360">	cbp-&gt;link_addr =	0xffffffff;	/* (no) next command */</a>
<a name="ln2361">	cbp-&gt;byte_count =	sc-&gt;flags &amp; FXP_FLAG_EXT_RFA ? 32 : 22;</a>
<a name="ln2362">	cbp-&gt;rx_fifo_limit =	8;	/* rx fifo threshold (32 bytes) */</a>
<a name="ln2363">	cbp-&gt;tx_fifo_limit =	0;	/* tx fifo threshold (0 bytes) */</a>
<a name="ln2364">	cbp-&gt;adaptive_ifs =	0;	/* (no) adaptive interframe spacing */</a>
<a name="ln2365">	cbp-&gt;mwi_enable =	sc-&gt;flags &amp; FXP_FLAG_MWI_ENABLE ? 1 : 0;</a>
<a name="ln2366">	cbp-&gt;type_enable =	0;	/* actually reserved */</a>
<a name="ln2367">	cbp-&gt;read_align_en =	sc-&gt;flags &amp; FXP_FLAG_READ_ALIGN ? 1 : 0;</a>
<a name="ln2368">	cbp-&gt;end_wr_on_cl =	sc-&gt;flags &amp; FXP_FLAG_WRITE_ALIGN ? 1 : 0;</a>
<a name="ln2369">	cbp-&gt;rx_dma_bytecount =	0;	/* (no) rx DMA max */</a>
<a name="ln2370">	cbp-&gt;tx_dma_bytecount =	0;	/* (no) tx DMA max */</a>
<a name="ln2371">	cbp-&gt;dma_mbce =		0;	/* (disable) dma max counters */</a>
<a name="ln2372">	cbp-&gt;late_scb =		0;	/* (don't) defer SCB update */</a>
<a name="ln2373">	cbp-&gt;direct_dma_dis =	1;	/* disable direct rcv dma mode */</a>
<a name="ln2374">	cbp-&gt;tno_int_or_tco_en =0;	/* (disable) tx not okay interrupt */</a>
<a name="ln2375">	cbp-&gt;ci_int =		1;	/* interrupt on CU idle */</a>
<a name="ln2376">	cbp-&gt;ext_txcb_dis = 	sc-&gt;flags &amp; FXP_FLAG_EXT_TXCB ? 0 : 1;</a>
<a name="ln2377">	cbp-&gt;ext_stats_dis = 	1;	/* disable extended counters */</a>
<a name="ln2378">	cbp-&gt;keep_overrun_rx = 	0;	/* don't pass overrun frames to host */</a>
<a name="ln2379">	cbp-&gt;save_bf =		sc-&gt;flags &amp; FXP_FLAG_SAVE_BAD ? 1 : prm;</a>
<a name="ln2380">	cbp-&gt;disc_short_rx =	!prm;	/* discard short packets */</a>
<a name="ln2381">	cbp-&gt;underrun_retry =	1;	/* retry mode (once) on DMA underrun */</a>
<a name="ln2382">	cbp-&gt;two_frames =	0;	/* do not limit FIFO to 2 frames */</a>
<a name="ln2383">	cbp-&gt;dyn_tbd =		sc-&gt;flags &amp; FXP_FLAG_EXT_RFA ? 1 : 0;</a>
<a name="ln2384">	cbp-&gt;ext_rfa =		sc-&gt;flags &amp; FXP_FLAG_EXT_RFA ? 1 : 0;</a>
<a name="ln2385">	cbp-&gt;mediatype =	sc-&gt;flags &amp; FXP_FLAG_SERIAL_MEDIA ? 0 : 1;</a>
<a name="ln2386">	cbp-&gt;csma_dis =		0;	/* (don't) disable link */</a>
<a name="ln2387">	cbp-&gt;tcp_udp_cksum =	((sc-&gt;flags &amp; FXP_FLAG_82559_RXCSUM) != 0 &amp;&amp;</a>
<a name="ln2388">	    (if_getcapenable(ifp) &amp; IFCAP_RXCSUM) != 0) ? 1 : 0;</a>
<a name="ln2389">	cbp-&gt;vlan_tco =		0;	/* (don't) enable vlan wakeup */</a>
<a name="ln2390">	cbp-&gt;link_wake_en =	0;	/* (don't) assert PME# on link change */</a>
<a name="ln2391">	cbp-&gt;arp_wake_en =	0;	/* (don't) assert PME# on arp */</a>
<a name="ln2392">	cbp-&gt;mc_wake_en =	0;	/* (don't) enable PME# on mcmatch */</a>
<a name="ln2393">	cbp-&gt;nsai =		1;	/* (don't) disable source addr insert */</a>
<a name="ln2394">	cbp-&gt;preamble_length =	2;	/* (7 byte) preamble */</a>
<a name="ln2395">	cbp-&gt;loopback =		0;	/* (don't) loopback */</a>
<a name="ln2396">	cbp-&gt;linear_priority =	0;	/* (normal CSMA/CD operation) */</a>
<a name="ln2397">	cbp-&gt;linear_pri_mode =	0;	/* (wait after xmit only) */</a>
<a name="ln2398">	cbp-&gt;interfrm_spacing =	6;	/* (96 bits of) interframe spacing */</a>
<a name="ln2399">	cbp-&gt;promiscuous =	prm;	/* promiscuous mode */</a>
<a name="ln2400">	cbp-&gt;bcast_disable =	0;	/* (don't) disable broadcasts */</a>
<a name="ln2401">	cbp-&gt;wait_after_win =	0;	/* (don't) enable modified backoff alg*/</a>
<a name="ln2402">	cbp-&gt;ignore_ul =	0;	/* consider U/L bit in IA matching */</a>
<a name="ln2403">	cbp-&gt;crc16_en =		0;	/* (don't) enable crc-16 algorithm */</a>
<a name="ln2404">	cbp-&gt;crscdt =		sc-&gt;flags &amp; FXP_FLAG_SERIAL_MEDIA ? 1 : 0;</a>
<a name="ln2405"> </a>
<a name="ln2406">	cbp-&gt;stripping =	!prm;	/* truncate rx packet to byte count */</a>
<a name="ln2407">	cbp-&gt;padding =		1;	/* (do) pad short tx packets */</a>
<a name="ln2408">	cbp-&gt;rcv_crc_xfer =	0;	/* (don't) xfer CRC to host */</a>
<a name="ln2409">	cbp-&gt;long_rx_en =	sc-&gt;flags &amp; FXP_FLAG_LONG_PKT_EN ? 1 : 0;</a>
<a name="ln2410">	cbp-&gt;ia_wake_en =	0;	/* (don't) wake up on address match */</a>
<a name="ln2411">	cbp-&gt;magic_pkt_dis =	sc-&gt;flags &amp; FXP_FLAG_WOL ? 0 : 1;</a>
<a name="ln2412">	cbp-&gt;force_fdx =	0;	/* (don't) force full duplex */</a>
<a name="ln2413">	cbp-&gt;fdx_pin_en =	1;	/* (enable) FDX# pin */</a>
<a name="ln2414">	cbp-&gt;multi_ia =		0;	/* (don't) accept multiple IAs */</a>
<a name="ln2415">	cbp-&gt;mc_all =		if_getflags(ifp) &amp; IFF_ALLMULTI ? 1 : prm;</a>
<a name="ln2416">	cbp-&gt;gamla_rx =		sc-&gt;flags &amp; FXP_FLAG_EXT_RFA ? 1 : 0;</a>
<a name="ln2417">	cbp-&gt;vlan_strip_en =	((sc-&gt;flags &amp; FXP_FLAG_EXT_RFA) != 0 &amp;&amp;</a>
<a name="ln2418">	    (if_getcapenable(ifp) &amp; IFCAP_VLAN_HWTAGGING) != 0) ? 1 : 0;</a>
<a name="ln2419"> </a>
<a name="ln2420">	if (sc-&gt;revision == FXP_REV_82557) {</a>
<a name="ln2421">		/*</a>
<a name="ln2422">		 * The 82557 has no hardware flow control, the values</a>
<a name="ln2423">		 * below are the defaults for the chip.</a>
<a name="ln2424">		 */</a>
<a name="ln2425">		cbp-&gt;fc_delay_lsb =	0;</a>
<a name="ln2426">		cbp-&gt;fc_delay_msb =	0x40;</a>
<a name="ln2427">		cbp-&gt;pri_fc_thresh =	3;</a>
<a name="ln2428">		cbp-&gt;tx_fc_dis =	0;</a>
<a name="ln2429">		cbp-&gt;rx_fc_restop =	0;</a>
<a name="ln2430">		cbp-&gt;rx_fc_restart =	0;</a>
<a name="ln2431">		cbp-&gt;fc_filter =	0;</a>
<a name="ln2432">		cbp-&gt;pri_fc_loc =	1;</a>
<a name="ln2433">	} else {</a>
<a name="ln2434">		/* Set pause RX FIFO threshold to 1KB. */</a>
<a name="ln2435">		CSR_WRITE_1(sc, FXP_CSR_FC_THRESH, 1);</a>
<a name="ln2436">		/* Set pause time. */</a>
<a name="ln2437">		cbp-&gt;fc_delay_lsb =	0xff;</a>
<a name="ln2438">		cbp-&gt;fc_delay_msb =	0xff;</a>
<a name="ln2439">		cbp-&gt;pri_fc_thresh =	3;</a>
<a name="ln2440">		mii = device_get_softc(sc-&gt;miibus);</a>
<a name="ln2441">		if ((IFM_OPTIONS(mii-&gt;mii_media_active) &amp;</a>
<a name="ln2442">		    IFM_ETH_TXPAUSE) != 0)</a>
<a name="ln2443">			/* enable transmit FC */</a>
<a name="ln2444">			cbp-&gt;tx_fc_dis = 0;</a>
<a name="ln2445">		else</a>
<a name="ln2446">			/* disable transmit FC */</a>
<a name="ln2447">			cbp-&gt;tx_fc_dis = 1;</a>
<a name="ln2448">		if ((IFM_OPTIONS(mii-&gt;mii_media_active) &amp;</a>
<a name="ln2449">		    IFM_ETH_RXPAUSE) != 0) {</a>
<a name="ln2450">			/* enable FC restart/restop frames */</a>
<a name="ln2451">			cbp-&gt;rx_fc_restart = 1;</a>
<a name="ln2452">			cbp-&gt;rx_fc_restop = 1;</a>
<a name="ln2453">		} else {</a>
<a name="ln2454">			/* disable FC restart/restop frames */</a>
<a name="ln2455">			cbp-&gt;rx_fc_restart = 0;</a>
<a name="ln2456">			cbp-&gt;rx_fc_restop = 0;</a>
<a name="ln2457">		}</a>
<a name="ln2458">		cbp-&gt;fc_filter =	!prm;	/* drop FC frames to host */</a>
<a name="ln2459">		cbp-&gt;pri_fc_loc =	1;	/* FC pri location (byte31) */</a>
<a name="ln2460">	}</a>
<a name="ln2461"> </a>
<a name="ln2462">	/* Enable 82558 and 82559 extended statistics functionality. */</a>
<a name="ln2463">	if (sc-&gt;revision &gt;= FXP_REV_82558_A4) {</a>
<a name="ln2464">		if (sc-&gt;revision &gt;= FXP_REV_82559_A0) {</a>
<a name="ln2465">			/*</a>
<a name="ln2466">			 * Extend configuration table size to 32</a>
<a name="ln2467">			 * to include TCO configuration.</a>
<a name="ln2468">			 */</a>
<a name="ln2469">			cbp-&gt;byte_count = 32;</a>
<a name="ln2470">			cbp-&gt;ext_stats_dis = 1;</a>
<a name="ln2471">			/* Enable TCO stats. */</a>
<a name="ln2472">			cbp-&gt;tno_int_or_tco_en = 1;</a>
<a name="ln2473">			cbp-&gt;gamla_rx = 1;</a>
<a name="ln2474">		} else</a>
<a name="ln2475">			cbp-&gt;ext_stats_dis = 0;</a>
<a name="ln2476">	}</a>
<a name="ln2477"> </a>
<a name="ln2478">	/*</a>
<a name="ln2479">	 * Start the config command/DMA.</a>
<a name="ln2480">	 */</a>
<a name="ln2481">	fxp_scb_wait(sc);</a>
<a name="ln2482">	bus_dmamap_sync(sc-&gt;cbl_tag, sc-&gt;cbl_map,</a>
<a name="ln2483">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln2484">	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, sc-&gt;fxp_desc.cbl_addr);</a>
<a name="ln2485">	fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_START);</a>
<a name="ln2486">	/* ...and wait for it to complete. */</a>
<a name="ln2487">	fxp_dma_wait(sc, &amp;cbp-&gt;cb_status, sc-&gt;cbl_tag, sc-&gt;cbl_map);</a>
<a name="ln2488"> </a>
<a name="ln2489">	/*</a>
<a name="ln2490">	 * Now initialize the station address. Temporarily use the TxCB</a>
<a name="ln2491">	 * memory area like we did above for the config CB.</a>
<a name="ln2492">	 */</a>
<a name="ln2493">	cb_ias = (struct fxp_cb_ias *)sc-&gt;fxp_desc.cbl_list;</a>
<a name="ln2494">	cb_ias-&gt;cb_status = 0;</a>
<a name="ln2495">	cb_ias-&gt;cb_command = htole16(FXP_CB_COMMAND_IAS | FXP_CB_COMMAND_EL);</a>
<a name="ln2496">	cb_ias-&gt;link_addr = 0xffffffff;</a>
<a name="ln2497">	bcopy(if_getlladdr(sc-&gt;ifp), cb_ias-&gt;macaddr, ETHER_ADDR_LEN);</a>
<a name="ln2498"> </a>
<a name="ln2499">	/*</a>
<a name="ln2500">	 * Start the IAS (Individual Address Setup) command/DMA.</a>
<a name="ln2501">	 */</a>
<a name="ln2502">	fxp_scb_wait(sc);</a>
<a name="ln2503">	bus_dmamap_sync(sc-&gt;cbl_tag, sc-&gt;cbl_map,</a>
<a name="ln2504">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln2505">	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, sc-&gt;fxp_desc.cbl_addr);</a>
<a name="ln2506">	fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_START);</a>
<a name="ln2507">	/* ...and wait for it to complete. */</a>
<a name="ln2508">	fxp_dma_wait(sc, &amp;cb_ias-&gt;cb_status, sc-&gt;cbl_tag, sc-&gt;cbl_map);</a>
<a name="ln2509"> </a>
<a name="ln2510">	/*</a>
<a name="ln2511">	 * Initialize the multicast address list.</a>
<a name="ln2512">	 */</a>
<a name="ln2513">	fxp_mc_setup(sc);</a>
<a name="ln2514"> </a>
<a name="ln2515">	/*</a>
<a name="ln2516">	 * Initialize transmit control block (TxCB) list.</a>
<a name="ln2517">	 */</a>
<a name="ln2518">	txp = sc-&gt;fxp_desc.tx_list;</a>
<a name="ln2519">	tcbp = sc-&gt;fxp_desc.cbl_list;</a>
<a name="ln2520">	bzero(tcbp, FXP_TXCB_SZ);</a>
<a name="ln2521">	for (i = 0; i &lt; FXP_NTXCB; i++) {</a>
<a name="ln2522">		txp[i].tx_mbuf = NULL;</a>
<a name="ln2523">		tcbp[i].cb_status = htole16(FXP_CB_STATUS_C | FXP_CB_STATUS_OK);</a>
<a name="ln2524">		tcbp[i].cb_command = htole16(FXP_CB_COMMAND_NOP);</a>
<a name="ln2525">		tcbp[i].link_addr = htole32(sc-&gt;fxp_desc.cbl_addr +</a>
<a name="ln2526">		    (((i + 1) &amp; FXP_TXCB_MASK) * sizeof(struct fxp_cb_tx)));</a>
<a name="ln2527">		if (sc-&gt;flags &amp; FXP_FLAG_EXT_TXCB)</a>
<a name="ln2528">			tcbp[i].tbd_array_addr =</a>
<a name="ln2529">			    htole32(FXP_TXCB_DMA_ADDR(sc, &amp;tcbp[i].tbd[2]));</a>
<a name="ln2530">		else</a>
<a name="ln2531">			tcbp[i].tbd_array_addr =</a>
<a name="ln2532">			    htole32(FXP_TXCB_DMA_ADDR(sc, &amp;tcbp[i].tbd[0]));</a>
<a name="ln2533">		txp[i].tx_next = &amp;txp[(i + 1) &amp; FXP_TXCB_MASK];</a>
<a name="ln2534">	}</a>
<a name="ln2535">	/*</a>
<a name="ln2536">	 * Set the suspend flag on the first TxCB and start the control</a>
<a name="ln2537">	 * unit. It will execute the NOP and then suspend.</a>
<a name="ln2538">	 */</a>
<a name="ln2539">	tcbp-&gt;cb_command = htole16(FXP_CB_COMMAND_NOP | FXP_CB_COMMAND_S);</a>
<a name="ln2540">	bus_dmamap_sync(sc-&gt;cbl_tag, sc-&gt;cbl_map,</a>
<a name="ln2541">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln2542">	sc-&gt;fxp_desc.tx_first = sc-&gt;fxp_desc.tx_last = txp;</a>
<a name="ln2543">	sc-&gt;tx_queued = 1;</a>
<a name="ln2544"> </a>
<a name="ln2545">	fxp_scb_wait(sc);</a>
<a name="ln2546">	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, sc-&gt;fxp_desc.cbl_addr);</a>
<a name="ln2547">	fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_START);</a>
<a name="ln2548"> </a>
<a name="ln2549">	/*</a>
<a name="ln2550">	 * Initialize receiver buffer area - RFA.</a>
<a name="ln2551">	 */</a>
<a name="ln2552">	fxp_scb_wait(sc);</a>
<a name="ln2553">	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, sc-&gt;fxp_desc.rx_head-&gt;rx_addr);</a>
<a name="ln2554">	fxp_scb_cmd(sc, FXP_SCB_COMMAND_RU_START);</a>
<a name="ln2555"> </a>
<a name="ln2556">	if (sc-&gt;miibus != NULL &amp;&amp; setmedia != 0)</a>
<a name="ln2557">		mii_mediachg(device_get_softc(sc-&gt;miibus));</a>
<a name="ln2558"> </a>
<a name="ln2559">	if_setdrvflagbits(ifp, IFF_DRV_RUNNING, IFF_DRV_OACTIVE);</a>
<a name="ln2560"> </a>
<a name="ln2561">	/*</a>
<a name="ln2562">	 * Enable interrupts.</a>
<a name="ln2563">	 */</a>
<a name="ln2564">#ifdef DEVICE_POLLING</a>
<a name="ln2565">	/*</a>
<a name="ln2566">	 * ... but only do that if we are not polling. And because (presumably)</a>
<a name="ln2567">	 * the default is interrupts on, we need to disable them explicitly!</a>
<a name="ln2568">	 */</a>
<a name="ln2569">	if (if_getcapenable(ifp) &amp; IFCAP_POLLING )</a>
<a name="ln2570">		CSR_WRITE_1(sc, FXP_CSR_SCB_INTRCNTL, FXP_SCB_INTR_DISABLE);</a>
<a name="ln2571">	else</a>
<a name="ln2572">#endif /* DEVICE_POLLING */</a>
<a name="ln2573">	CSR_WRITE_1(sc, FXP_CSR_SCB_INTRCNTL, 0);</a>
<a name="ln2574"> </a>
<a name="ln2575">	/*</a>
<a name="ln2576">	 * Start stats updater.</a>
<a name="ln2577">	 */</a>
<a name="ln2578">	callout_reset(&amp;sc-&gt;stat_ch, hz, fxp_tick, sc);</a>
<a name="ln2579">}</a>
<a name="ln2580"> </a>
<a name="ln2581">static int</a>
<a name="ln2582">fxp_serial_ifmedia_upd(if_t ifp)</a>
<a name="ln2583">{</a>
<a name="ln2584"> </a>
<a name="ln2585">	return (0);</a>
<a name="ln2586">}</a>
<a name="ln2587"> </a>
<a name="ln2588">static void</a>
<a name="ln2589">fxp_serial_ifmedia_sts(if_t ifp, struct ifmediareq *ifmr)</a>
<a name="ln2590">{</a>
<a name="ln2591"> </a>
<a name="ln2592">	ifmr-&gt;ifm_active = IFM_ETHER|IFM_MANUAL;</a>
<a name="ln2593">}</a>
<a name="ln2594"> </a>
<a name="ln2595">/*</a>
<a name="ln2596"> * Change media according to request.</a>
<a name="ln2597"> */</a>
<a name="ln2598">static int</a>
<a name="ln2599">fxp_ifmedia_upd(if_t ifp)</a>
<a name="ln2600">{</a>
<a name="ln2601">	struct fxp_softc *sc = if_getsoftc(ifp);</a>
<a name="ln2602">	struct mii_data *mii;</a>
<a name="ln2603">	struct mii_softc	*miisc;</a>
<a name="ln2604"> </a>
<a name="ln2605">	mii = device_get_softc(sc-&gt;miibus);</a>
<a name="ln2606">	FXP_LOCK(sc);</a>
<a name="ln2607">	LIST_FOREACH(miisc, &amp;mii-&gt;mii_phys, mii_list)</a>
<a name="ln2608">		PHY_RESET(miisc);</a>
<a name="ln2609">	mii_mediachg(mii);</a>
<a name="ln2610">	FXP_UNLOCK(sc);</a>
<a name="ln2611">	return (0);</a>
<a name="ln2612">}</a>
<a name="ln2613"> </a>
<a name="ln2614">/*</a>
<a name="ln2615"> * Notify the world which media we're using.</a>
<a name="ln2616"> */</a>
<a name="ln2617">static void</a>
<a name="ln2618">fxp_ifmedia_sts(if_t ifp, struct ifmediareq *ifmr)</a>
<a name="ln2619">{</a>
<a name="ln2620">	struct fxp_softc *sc = if_getsoftc(ifp);</a>
<a name="ln2621">	struct mii_data *mii;</a>
<a name="ln2622"> </a>
<a name="ln2623">	mii = device_get_softc(sc-&gt;miibus);</a>
<a name="ln2624">	FXP_LOCK(sc);</a>
<a name="ln2625">	mii_pollstat(mii);</a>
<a name="ln2626">	ifmr-&gt;ifm_active = mii-&gt;mii_media_active;</a>
<a name="ln2627">	ifmr-&gt;ifm_status = mii-&gt;mii_media_status;</a>
<a name="ln2628">	FXP_UNLOCK(sc);</a>
<a name="ln2629">}</a>
<a name="ln2630"> </a>
<a name="ln2631">/*</a>
<a name="ln2632"> * Add a buffer to the end of the RFA buffer list.</a>
<a name="ln2633"> * Return 0 if successful, 1 for failure. A failure results in</a>
<a name="ln2634"> * reusing the RFA buffer.</a>
<a name="ln2635"> * The RFA struct is stuck at the beginning of mbuf cluster and the</a>
<a name="ln2636"> * data pointer is fixed up to point just past it.</a>
<a name="ln2637"> */</a>
<a name="ln2638">static int</a>
<a name="ln2639">fxp_new_rfabuf(struct fxp_softc *sc, struct fxp_rx *rxp)</a>
<a name="ln2640">{</a>
<a name="ln2641">	struct mbuf *m;</a>
<a name="ln2642">	struct fxp_rfa *rfa;</a>
<a name="ln2643">	bus_dmamap_t tmp_map;</a>
<a name="ln2644">	int error;</a>
<a name="ln2645"> </a>
<a name="ln2646">	m = m_getcl(M_NOWAIT, MT_DATA, M_PKTHDR);</a>
<a name="ln2647">	if (m == NULL)</a>
<a name="ln2648">		return (ENOBUFS);</a>
<a name="ln2649"> </a>
<a name="ln2650">	/*</a>
<a name="ln2651">	 * Move the data pointer up so that the incoming data packet</a>
<a name="ln2652">	 * will be 32-bit aligned.</a>
<a name="ln2653">	 */</a>
<a name="ln2654">	m-&gt;m_data += RFA_ALIGNMENT_FUDGE;</a>
<a name="ln2655"> </a>
<a name="ln2656">	/*</a>
<a name="ln2657">	 * Get a pointer to the base of the mbuf cluster and move</a>
<a name="ln2658">	 * data start past it.</a>
<a name="ln2659">	 */</a>
<a name="ln2660">	rfa = mtod(m, struct fxp_rfa *);</a>
<a name="ln2661">	m-&gt;m_data += sc-&gt;rfa_size;</a>
<a name="ln2662">	rfa-&gt;size = htole16(MCLBYTES - sc-&gt;rfa_size - RFA_ALIGNMENT_FUDGE);</a>
<a name="ln2663"> </a>
<a name="ln2664">	rfa-&gt;rfa_status = 0;</a>
<a name="ln2665">	rfa-&gt;rfa_control = htole16(FXP_RFA_CONTROL_EL);</a>
<a name="ln2666">	rfa-&gt;actual_size = 0;</a>
<a name="ln2667">	m-&gt;m_len = m-&gt;m_pkthdr.len = MCLBYTES - RFA_ALIGNMENT_FUDGE -</a>
<a name="ln2668">	    sc-&gt;rfa_size;</a>
<a name="ln2669"> </a>
<a name="ln2670">	/*</a>
<a name="ln2671">	 * Initialize the rest of the RFA.  Note that since the RFA</a>
<a name="ln2672">	 * is misaligned, we cannot store values directly.  We're thus</a>
<a name="ln2673">	 * using the le32enc() function which handles endianness and</a>
<a name="ln2674">	 * is also alignment-safe.</a>
<a name="ln2675">	 */</a>
<a name="ln2676">	le32enc(&amp;rfa-&gt;link_addr, 0xffffffff);</a>
<a name="ln2677">	le32enc(&amp;rfa-&gt;rbd_addr, 0xffffffff);</a>
<a name="ln2678"> </a>
<a name="ln2679">	/* Map the RFA into DMA memory. */</a>
<a name="ln2680">	error = bus_dmamap_load(sc-&gt;fxp_rxmtag, sc-&gt;spare_map, rfa,</a>
<a name="ln2681">	    MCLBYTES - RFA_ALIGNMENT_FUDGE, fxp_dma_map_addr,</a>
<a name="ln2682">	    &amp;rxp-&gt;rx_addr, BUS_DMA_NOWAIT);</a>
<a name="ln2683">	if (error) {</a>
<a name="ln2684">		m_freem(m);</a>
<a name="ln2685">		return (error);</a>
<a name="ln2686">	}</a>
<a name="ln2687"> </a>
<a name="ln2688">	if (rxp-&gt;rx_mbuf != NULL)</a>
<a name="ln2689">		bus_dmamap_unload(sc-&gt;fxp_rxmtag, rxp-&gt;rx_map);</a>
<a name="ln2690">	tmp_map = sc-&gt;spare_map;</a>
<a name="ln2691">	sc-&gt;spare_map = rxp-&gt;rx_map;</a>
<a name="ln2692">	rxp-&gt;rx_map = tmp_map;</a>
<a name="ln2693">	rxp-&gt;rx_mbuf = m;</a>
<a name="ln2694"> </a>
<a name="ln2695">	bus_dmamap_sync(sc-&gt;fxp_rxmtag, rxp-&gt;rx_map,</a>
<a name="ln2696">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln2697">	return (0);</a>
<a name="ln2698">}</a>
<a name="ln2699"> </a>
<a name="ln2700">static void</a>
<a name="ln2701">fxp_add_rfabuf(struct fxp_softc *sc, struct fxp_rx *rxp)</a>
<a name="ln2702">{</a>
<a name="ln2703">	struct fxp_rfa *p_rfa;</a>
<a name="ln2704">	struct fxp_rx *p_rx;</a>
<a name="ln2705"> </a>
<a name="ln2706">	/*</a>
<a name="ln2707">	 * If there are other buffers already on the list, attach this</a>
<a name="ln2708">	 * one to the end by fixing up the tail to point to this one.</a>
<a name="ln2709">	 */</a>
<a name="ln2710">	if (sc-&gt;fxp_desc.rx_head != NULL) {</a>
<a name="ln2711">		p_rx = sc-&gt;fxp_desc.rx_tail;</a>
<a name="ln2712">		p_rfa = (struct fxp_rfa *)</a>
<a name="ln2713">		    (p_rx-&gt;rx_mbuf-&gt;m_ext.ext_buf + RFA_ALIGNMENT_FUDGE);</a>
<a name="ln2714">		p_rx-&gt;rx_next = rxp;</a>
<a name="ln2715">		le32enc(&amp;p_rfa-&gt;link_addr, rxp-&gt;rx_addr);</a>
<a name="ln2716">		p_rfa-&gt;rfa_control = 0;</a>
<a name="ln2717">		bus_dmamap_sync(sc-&gt;fxp_rxmtag, p_rx-&gt;rx_map,</a>
<a name="ln2718">		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln2719">	} else {</a>
<a name="ln2720">		rxp-&gt;rx_next = NULL;</a>
<a name="ln2721">		sc-&gt;fxp_desc.rx_head = rxp;</a>
<a name="ln2722">	}</a>
<a name="ln2723">	sc-&gt;fxp_desc.rx_tail = rxp;</a>
<a name="ln2724">}</a>
<a name="ln2725"> </a>
<a name="ln2726">static void</a>
<a name="ln2727">fxp_discard_rfabuf(struct fxp_softc *sc, struct fxp_rx *rxp)</a>
<a name="ln2728">{</a>
<a name="ln2729">	struct mbuf *m;</a>
<a name="ln2730">	struct fxp_rfa *rfa;</a>
<a name="ln2731"> </a>
<a name="ln2732">	m = rxp-&gt;rx_mbuf;</a>
<a name="ln2733">	m-&gt;m_data = m-&gt;m_ext.ext_buf;</a>
<a name="ln2734">	/*</a>
<a name="ln2735">	 * Move the data pointer up so that the incoming data packet</a>
<a name="ln2736">	 * will be 32-bit aligned.</a>
<a name="ln2737">	 */</a>
<a name="ln2738">	m-&gt;m_data += RFA_ALIGNMENT_FUDGE;</a>
<a name="ln2739"> </a>
<a name="ln2740">	/*</a>
<a name="ln2741">	 * Get a pointer to the base of the mbuf cluster and move</a>
<a name="ln2742">	 * data start past it.</a>
<a name="ln2743">	 */</a>
<a name="ln2744">	rfa = mtod(m, struct fxp_rfa *);</a>
<a name="ln2745">	m-&gt;m_data += sc-&gt;rfa_size;</a>
<a name="ln2746">	rfa-&gt;size = htole16(MCLBYTES - sc-&gt;rfa_size - RFA_ALIGNMENT_FUDGE);</a>
<a name="ln2747"> </a>
<a name="ln2748">	rfa-&gt;rfa_status = 0;</a>
<a name="ln2749">	rfa-&gt;rfa_control = htole16(FXP_RFA_CONTROL_EL);</a>
<a name="ln2750">	rfa-&gt;actual_size = 0;</a>
<a name="ln2751"> </a>
<a name="ln2752">	/*</a>
<a name="ln2753">	 * Initialize the rest of the RFA.  Note that since the RFA</a>
<a name="ln2754">	 * is misaligned, we cannot store values directly.  We're thus</a>
<a name="ln2755">	 * using the le32enc() function which handles endianness and</a>
<a name="ln2756">	 * is also alignment-safe.</a>
<a name="ln2757">	 */</a>
<a name="ln2758">	le32enc(&amp;rfa-&gt;link_addr, 0xffffffff);</a>
<a name="ln2759">	le32enc(&amp;rfa-&gt;rbd_addr, 0xffffffff);</a>
<a name="ln2760"> </a>
<a name="ln2761">	bus_dmamap_sync(sc-&gt;fxp_rxmtag, rxp-&gt;rx_map,</a>
<a name="ln2762">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln2763">}</a>
<a name="ln2764"> </a>
<a name="ln2765">static int</a>
<a name="ln2766">fxp_miibus_readreg(device_t dev, int phy, int reg)</a>
<a name="ln2767">{</a>
<a name="ln2768">	struct fxp_softc *sc = device_get_softc(dev);</a>
<a name="ln2769">	int count = 10000;</a>
<a name="ln2770">	int value;</a>
<a name="ln2771"> </a>
<a name="ln2772">	CSR_WRITE_4(sc, FXP_CSR_MDICONTROL,</a>
<a name="ln2773">	    (FXP_MDI_READ &lt;&lt; 26) | (reg &lt;&lt; 16) | (phy &lt;&lt; 21));</a>
<a name="ln2774"> </a>
<a name="ln2775">	while (((value = CSR_READ_4(sc, FXP_CSR_MDICONTROL)) &amp; 0x10000000) == 0</a>
<a name="ln2776">	    &amp;&amp; count--)</a>
<a name="ln2777">		DELAY(10);</a>
<a name="ln2778"> </a>
<a name="ln2779">	if (count &lt;= 0)</a>
<a name="ln2780">		device_printf(dev, &quot;fxp_miibus_readreg: timed out\n&quot;);</a>
<a name="ln2781"> </a>
<a name="ln2782">	return (value &amp; 0xffff);</a>
<a name="ln2783">}</a>
<a name="ln2784"> </a>
<a name="ln2785">static int</a>
<a name="ln2786">fxp_miibus_writereg(device_t dev, int phy, int reg, int value)</a>
<a name="ln2787">{</a>
<a name="ln2788">	struct fxp_softc *sc = device_get_softc(dev);</a>
<a name="ln2789">	int count = 10000;</a>
<a name="ln2790"> </a>
<a name="ln2791">	CSR_WRITE_4(sc, FXP_CSR_MDICONTROL,</a>
<a name="ln2792">	    (FXP_MDI_WRITE &lt;&lt; 26) | (reg &lt;&lt; 16) | (phy &lt;&lt; 21) |</a>
<a name="ln2793">	    (value &amp; 0xffff));</a>
<a name="ln2794"> </a>
<a name="ln2795">	while ((CSR_READ_4(sc, FXP_CSR_MDICONTROL) &amp; 0x10000000) == 0 &amp;&amp;</a>
<a name="ln2796">	    count--)</a>
<a name="ln2797">		DELAY(10);</a>
<a name="ln2798"> </a>
<a name="ln2799">	if (count &lt;= 0)</a>
<a name="ln2800">		device_printf(dev, &quot;fxp_miibus_writereg: timed out\n&quot;);</a>
<a name="ln2801">	return (0);</a>
<a name="ln2802">}</a>
<a name="ln2803"> </a>
<a name="ln2804">static void</a>
<a name="ln2805">fxp_miibus_statchg(device_t dev)</a>
<a name="ln2806">{</a>
<a name="ln2807">	struct fxp_softc *sc;</a>
<a name="ln2808">	struct mii_data *mii;</a>
<a name="ln2809">	if_t ifp;</a>
<a name="ln2810"> </a>
<a name="ln2811">	sc = device_get_softc(dev);</a>
<a name="ln2812">	mii = device_get_softc(sc-&gt;miibus);</a>
<a name="ln2813">	ifp = sc-&gt;ifp;</a>
<a name="ln2814">	if (mii == NULL || ifp == (void *)NULL ||</a>
<a name="ln2815">	    (if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING) == 0 ||</a>
<a name="ln2816">	    (mii-&gt;mii_media_status &amp; (IFM_AVALID | IFM_ACTIVE)) !=</a>
<a name="ln2817">	    (IFM_AVALID | IFM_ACTIVE))</a>
<a name="ln2818">		return;</a>
<a name="ln2819"> </a>
<a name="ln2820">	if (IFM_SUBTYPE(mii-&gt;mii_media_active) == IFM_10_T &amp;&amp;</a>
<a name="ln2821">	    sc-&gt;flags &amp; FXP_FLAG_CU_RESUME_BUG)</a>
<a name="ln2822">		sc-&gt;cu_resume_bug = 1;</a>
<a name="ln2823">	else</a>
<a name="ln2824">		sc-&gt;cu_resume_bug = 0;</a>
<a name="ln2825">	/*</a>
<a name="ln2826">	 * Call fxp_init_body in order to adjust the flow control settings.</a>
<a name="ln2827">	 * Note that the 82557 doesn't support hardware flow control.</a>
<a name="ln2828">	 */</a>
<a name="ln2829">	if (sc-&gt;revision == FXP_REV_82557)</a>
<a name="ln2830">		return;</a>
<a name="ln2831">	if_setdrvflagbits(ifp, 0, IFF_DRV_RUNNING);</a>
<a name="ln2832">	fxp_init_body(sc, 0);</a>
<a name="ln2833">}</a>
<a name="ln2834"> </a>
<a name="ln2835">static int</a>
<a name="ln2836">fxp_ioctl(if_t ifp, u_long command, caddr_t data)</a>
<a name="ln2837">{</a>
<a name="ln2838">	struct fxp_softc *sc = if_getsoftc(ifp);</a>
<a name="ln2839">	struct ifreq *ifr = (struct ifreq *)data;</a>
<a name="ln2840">	struct mii_data *mii;</a>
<a name="ln2841">	int flag, mask, error = 0, reinit;</a>
<a name="ln2842"> </a>
<a name="ln2843">	switch (command) {</a>
<a name="ln2844">	case SIOCSIFFLAGS:</a>
<a name="ln2845">		FXP_LOCK(sc);</a>
<a name="ln2846">		/*</a>
<a name="ln2847">		 * If interface is marked up and not running, then start it.</a>
<a name="ln2848">		 * If it is marked down and running, stop it.</a>
<a name="ln2849">		 * XXX If it's up then re-initialize it. This is so flags</a>
<a name="ln2850">		 * such as IFF_PROMISC are handled.</a>
<a name="ln2851">		 */</a>
<a name="ln2852">		if (if_getflags(ifp) &amp; IFF_UP) {</a>
<a name="ln2853">			if (((if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING) != 0) &amp;&amp;</a>
<a name="ln2854">			    ((if_getflags(ifp) ^ sc-&gt;if_flags) &amp;</a>
<a name="ln2855">			    (IFF_PROMISC | IFF_ALLMULTI | IFF_LINK0)) != 0) {</a>
<a name="ln2856">				if_setdrvflagbits(ifp, 0, IFF_DRV_RUNNING);</a>
<a name="ln2857">				fxp_init_body(sc, 0);</a>
<a name="ln2858">			} else if ((if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING) == 0)</a>
<a name="ln2859">				fxp_init_body(sc, 1);</a>
<a name="ln2860">		} else {</a>
<a name="ln2861">			if ((if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING) != 0)</a>
<a name="ln2862">				fxp_stop(sc);</a>
<a name="ln2863">		}</a>
<a name="ln2864">		sc-&gt;if_flags = if_getflags(ifp);</a>
<a name="ln2865">		FXP_UNLOCK(sc);</a>
<a name="ln2866">		break;</a>
<a name="ln2867"> </a>
<a name="ln2868">	case SIOCADDMULTI:</a>
<a name="ln2869">	case SIOCDELMULTI:</a>
<a name="ln2870">		FXP_LOCK(sc);</a>
<a name="ln2871">		if ((if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING) != 0) {</a>
<a name="ln2872">			if_setdrvflagbits(ifp, 0, IFF_DRV_RUNNING);</a>
<a name="ln2873">			fxp_init_body(sc, 0);</a>
<a name="ln2874">		}</a>
<a name="ln2875">		FXP_UNLOCK(sc);</a>
<a name="ln2876">		break;</a>
<a name="ln2877"> </a>
<a name="ln2878">	case SIOCSIFMEDIA:</a>
<a name="ln2879">	case SIOCGIFMEDIA:</a>
<a name="ln2880">		if (sc-&gt;miibus != NULL) {</a>
<a name="ln2881">			mii = device_get_softc(sc-&gt;miibus);</a>
<a name="ln2882">                        error = ifmedia_ioctl(ifp, ifr,</a>
<a name="ln2883">                            &amp;mii-&gt;mii_media, command);</a>
<a name="ln2884">		} else {</a>
<a name="ln2885">                        error = ifmedia_ioctl(ifp, ifr, &amp;sc-&gt;sc_media, command);</a>
<a name="ln2886">		}</a>
<a name="ln2887">		break;</a>
<a name="ln2888"> </a>
<a name="ln2889">	case SIOCSIFCAP:</a>
<a name="ln2890">		reinit = 0;</a>
<a name="ln2891">		mask = if_getcapenable(ifp) ^ ifr-&gt;ifr_reqcap;</a>
<a name="ln2892">#ifdef DEVICE_POLLING</a>
<a name="ln2893">		if (mask &amp; IFCAP_POLLING) {</a>
<a name="ln2894">			if (ifr-&gt;ifr_reqcap &amp; IFCAP_POLLING) {</a>
<a name="ln2895">				error = ether_poll_register(fxp_poll, ifp);</a>
<a name="ln2896">				if (error)</a>
<a name="ln2897">					return(error);</a>
<a name="ln2898">				FXP_LOCK(sc);</a>
<a name="ln2899">				CSR_WRITE_1(sc, FXP_CSR_SCB_INTRCNTL,</a>
<a name="ln2900">				    FXP_SCB_INTR_DISABLE);</a>
<a name="ln2901">				if_setcapenablebit(ifp, IFCAP_POLLING, 0);</a>
<a name="ln2902">				FXP_UNLOCK(sc);</a>
<a name="ln2903">			} else {</a>
<a name="ln2904">				error = ether_poll_deregister(ifp);</a>
<a name="ln2905">				/* Enable interrupts in any case */</a>
<a name="ln2906">				FXP_LOCK(sc);</a>
<a name="ln2907">				CSR_WRITE_1(sc, FXP_CSR_SCB_INTRCNTL, 0);</a>
<a name="ln2908">				if_setcapenablebit(ifp, 0, IFCAP_POLLING);</a>
<a name="ln2909">				FXP_UNLOCK(sc);</a>
<a name="ln2910">			}</a>
<a name="ln2911">		}</a>
<a name="ln2912">#endif</a>
<a name="ln2913">		FXP_LOCK(sc);</a>
<a name="ln2914">		if ((mask &amp; IFCAP_TXCSUM) != 0 &amp;&amp;</a>
<a name="ln2915">		    (if_getcapabilities(ifp) &amp; IFCAP_TXCSUM) != 0) {</a>
<a name="ln2916">			if_togglecapenable(ifp, IFCAP_TXCSUM);</a>
<a name="ln2917">			if ((if_getcapenable(ifp) &amp; IFCAP_TXCSUM) != 0)</a>
<a name="ln2918">				if_sethwassistbits(ifp, FXP_CSUM_FEATURES, 0);</a>
<a name="ln2919">			else</a>
<a name="ln2920">				if_sethwassistbits(ifp, 0, FXP_CSUM_FEATURES);</a>
<a name="ln2921">		}</a>
<a name="ln2922">		if ((mask &amp; IFCAP_RXCSUM) != 0 &amp;&amp;</a>
<a name="ln2923">		    (if_getcapabilities(ifp) &amp; IFCAP_RXCSUM) != 0) {</a>
<a name="ln2924">			if_togglecapenable(ifp, IFCAP_RXCSUM);</a>
<a name="ln2925">			if ((sc-&gt;flags &amp; FXP_FLAG_82559_RXCSUM) != 0)</a>
<a name="ln2926">				reinit++;</a>
<a name="ln2927">		}</a>
<a name="ln2928">		if ((mask &amp; IFCAP_TSO4) != 0 &amp;&amp;</a>
<a name="ln2929">		    (if_getcapabilities(ifp) &amp; IFCAP_TSO4) != 0) {</a>
<a name="ln2930">			if_togglecapenable(ifp, IFCAP_TSO4);</a>
<a name="ln2931">			if ((if_getcapenable(ifp) &amp; IFCAP_TSO4) != 0)</a>
<a name="ln2932">				if_sethwassistbits(ifp, CSUM_TSO, 0);</a>
<a name="ln2933">			else</a>
<a name="ln2934">				if_sethwassistbits(ifp, 0, CSUM_TSO);</a>
<a name="ln2935">		}</a>
<a name="ln2936">		if ((mask &amp; IFCAP_WOL_MAGIC) != 0 &amp;&amp;</a>
<a name="ln2937">		    (if_getcapabilities(ifp) &amp; IFCAP_WOL_MAGIC) != 0)</a>
<a name="ln2938">			if_togglecapenable(ifp, IFCAP_WOL_MAGIC);</a>
<a name="ln2939">		if ((mask &amp; IFCAP_VLAN_MTU) != 0 &amp;&amp;</a>
<a name="ln2940">		    (if_getcapabilities(ifp) &amp; IFCAP_VLAN_MTU) != 0) {</a>
<a name="ln2941">			if_togglecapenable(ifp, IFCAP_VLAN_MTU);</a>
<a name="ln2942">			if (sc-&gt;revision != FXP_REV_82557)</a>
<a name="ln2943">				flag = FXP_FLAG_LONG_PKT_EN;</a>
<a name="ln2944">			else /* a hack to get long frames on the old chip */</a>
<a name="ln2945">				flag = FXP_FLAG_SAVE_BAD;</a>
<a name="ln2946">			sc-&gt;flags ^= flag;</a>
<a name="ln2947">			if (if_getflags(ifp) &amp; IFF_UP)</a>
<a name="ln2948">				reinit++;</a>
<a name="ln2949">		}</a>
<a name="ln2950">		if ((mask &amp; IFCAP_VLAN_HWCSUM) != 0 &amp;&amp;</a>
<a name="ln2951">		    (if_getcapabilities(ifp) &amp; IFCAP_VLAN_HWCSUM) != 0)</a>
<a name="ln2952">			if_togglecapenable(ifp, IFCAP_VLAN_HWCSUM);</a>
<a name="ln2953">		if ((mask &amp; IFCAP_VLAN_HWTSO) != 0 &amp;&amp;</a>
<a name="ln2954">		    (if_getcapabilities(ifp) &amp; IFCAP_VLAN_HWTSO) != 0)</a>
<a name="ln2955">			if_togglecapenable(ifp, IFCAP_VLAN_HWTSO);</a>
<a name="ln2956">		if ((mask &amp; IFCAP_VLAN_HWTAGGING) != 0 &amp;&amp;</a>
<a name="ln2957">		    (if_getcapabilities(ifp) &amp; IFCAP_VLAN_HWTAGGING) != 0) {</a>
<a name="ln2958">			if_togglecapenable(ifp, IFCAP_VLAN_HWTAGGING);</a>
<a name="ln2959">			if ((if_getcapenable(ifp) &amp; IFCAP_VLAN_HWTAGGING) == 0)</a>
<a name="ln2960">				if_setcapenablebit(ifp, 0, IFCAP_VLAN_HWTSO |</a>
<a name="ln2961">				    IFCAP_VLAN_HWCSUM);</a>
<a name="ln2962">			reinit++;</a>
<a name="ln2963">		}</a>
<a name="ln2964">		if (reinit &gt; 0 &amp;&amp;</a>
<a name="ln2965">		    (if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING) != 0) {</a>
<a name="ln2966">			if_setdrvflagbits(ifp, 0, IFF_DRV_RUNNING);</a>
<a name="ln2967">			fxp_init_body(sc, 0);</a>
<a name="ln2968">		}</a>
<a name="ln2969">		FXP_UNLOCK(sc);</a>
<a name="ln2970">		if_vlancap(ifp);</a>
<a name="ln2971">		break;</a>
<a name="ln2972"> </a>
<a name="ln2973">	default:</a>
<a name="ln2974">		error = ether_ioctl(ifp, command, data);</a>
<a name="ln2975">	}</a>
<a name="ln2976">	return (error);</a>
<a name="ln2977">}</a>
<a name="ln2978"> </a>
<a name="ln2979">/*</a>
<a name="ln2980"> * Fill in the multicast address list and return number of entries.</a>
<a name="ln2981"> */</a>
<a name="ln2982">static int</a>
<a name="ln2983">fxp_mc_addrs(struct fxp_softc *sc)</a>
<a name="ln2984">{</a>
<a name="ln2985">	struct fxp_cb_mcs *mcsp = sc-&gt;mcsp;</a>
<a name="ln2986">	if_t ifp = sc-&gt;ifp;</a>
<a name="ln2987">	int nmcasts = 0;</a>
<a name="ln2988"> </a>
<a name="ln2989">	if ((if_getflags(ifp) &amp; IFF_ALLMULTI) == 0) {</a>
<a name="ln2990">		if_maddr_rlock(ifp);</a>
<a name="ln2991">		if_setupmultiaddr(ifp, mcsp-&gt;mc_addr, &amp;nmcasts, MAXMCADDR);</a>
<a name="ln2992">		if (nmcasts &gt;= MAXMCADDR) {</a>
<a name="ln2993">			if_setflagbits(ifp, IFF_ALLMULTI, 0);</a>
<a name="ln2994">			nmcasts = 0;</a>
<a name="ln2995">		}</a>
<a name="ln2996">		if_maddr_runlock(ifp);</a>
<a name="ln2997">	}</a>
<a name="ln2998">	mcsp-&gt;mc_cnt = htole16(nmcasts * ETHER_ADDR_LEN);</a>
<a name="ln2999">	return (nmcasts);</a>
<a name="ln3000">}</a>
<a name="ln3001"> </a>
<a name="ln3002">/*</a>
<a name="ln3003"> * Program the multicast filter.</a>
<a name="ln3004"> *</a>
<a name="ln3005"> * We have an artificial restriction that the multicast setup command</a>
<a name="ln3006"> * must be the first command in the chain, so we take steps to ensure</a>
<a name="ln3007"> * this. By requiring this, it allows us to keep up the performance of</a>
<a name="ln3008"> * the pre-initialized command ring (esp. link pointers) by not actually</a>
<a name="ln3009"> * inserting the mcsetup command in the ring - i.e. its link pointer</a>
<a name="ln3010"> * points to the TxCB ring, but the mcsetup descriptor itself is not part</a>
<a name="ln3011"> * of it. We then can do 'CU_START' on the mcsetup descriptor and have it</a>
<a name="ln3012"> * lead into the regular TxCB ring when it completes.</a>
<a name="ln3013"> */</a>
<a name="ln3014">static void</a>
<a name="ln3015">fxp_mc_setup(struct fxp_softc *sc)</a>
<a name="ln3016">{</a>
<a name="ln3017">	struct fxp_cb_mcs *mcsp;</a>
<a name="ln3018">	int count;</a>
<a name="ln3019"> </a>
<a name="ln3020">	FXP_LOCK_ASSERT(sc, MA_OWNED);</a>
<a name="ln3021"> </a>
<a name="ln3022">	mcsp = sc-&gt;mcsp;</a>
<a name="ln3023">	mcsp-&gt;cb_status = 0;</a>
<a name="ln3024">	mcsp-&gt;cb_command = htole16(FXP_CB_COMMAND_MCAS | FXP_CB_COMMAND_EL);</a>
<a name="ln3025">	mcsp-&gt;link_addr = 0xffffffff;</a>
<a name="ln3026">	fxp_mc_addrs(sc);</a>
<a name="ln3027"> </a>
<a name="ln3028">	/*</a>
<a name="ln3029">	 * Wait until command unit is idle. This should never be the</a>
<a name="ln3030">	 * case when nothing is queued, but make sure anyway.</a>
<a name="ln3031">	 */</a>
<a name="ln3032">	count = 100;</a>
<a name="ln3033">	while ((CSR_READ_1(sc, FXP_CSR_SCB_RUSCUS) &gt;&gt; 6) !=</a>
<a name="ln3034">	    FXP_SCB_CUS_IDLE &amp;&amp; --count)</a>
<a name="ln3035">		DELAY(10);</a>
<a name="ln3036">	if (count == 0) {</a>
<a name="ln3037">		device_printf(sc-&gt;dev, &quot;command queue timeout\n&quot;);</a>
<a name="ln3038">		return;</a>
<a name="ln3039">	}</a>
<a name="ln3040"> </a>
<a name="ln3041">	/*</a>
<a name="ln3042">	 * Start the multicast setup command.</a>
<a name="ln3043">	 */</a>
<a name="ln3044">	fxp_scb_wait(sc);</a>
<a name="ln3045">	bus_dmamap_sync(sc-&gt;mcs_tag, sc-&gt;mcs_map,</a>
<a name="ln3046">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln3047">	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, sc-&gt;mcs_addr);</a>
<a name="ln3048">	fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_START);</a>
<a name="ln3049">	/* ...and wait for it to complete. */</a>
<a name="ln3050">	fxp_dma_wait(sc, &amp;mcsp-&gt;cb_status, sc-&gt;mcs_tag, sc-&gt;mcs_map);</a>
<a name="ln3051">}</a>
<a name="ln3052"> </a>
<a name="ln3053">static uint32_t fxp_ucode_d101a[] = D101_A_RCVBUNDLE_UCODE;</a>
<a name="ln3054">static uint32_t fxp_ucode_d101b0[] = D101_B0_RCVBUNDLE_UCODE;</a>
<a name="ln3055">static uint32_t fxp_ucode_d101ma[] = D101M_B_RCVBUNDLE_UCODE;</a>
<a name="ln3056">static uint32_t fxp_ucode_d101s[] = D101S_RCVBUNDLE_UCODE;</a>
<a name="ln3057">static uint32_t fxp_ucode_d102[] = D102_B_RCVBUNDLE_UCODE;</a>
<a name="ln3058">static uint32_t fxp_ucode_d102c[] = D102_C_RCVBUNDLE_UCODE;</a>
<a name="ln3059">static uint32_t fxp_ucode_d102e[] = D102_E_RCVBUNDLE_UCODE;</a>
<a name="ln3060"> </a>
<a name="ln3061">#define UCODE(x)	x, sizeof(x)/sizeof(uint32_t)</a>
<a name="ln3062"> </a>
<a name="ln3063">static const struct ucode {</a>
<a name="ln3064">	uint32_t	revision;</a>
<a name="ln3065">	uint32_t	*ucode;</a>
<a name="ln3066">	int		length;</a>
<a name="ln3067">	u_short		int_delay_offset;</a>
<a name="ln3068">	u_short		bundle_max_offset;</a>
<a name="ln3069">} ucode_table[] = {</a>
<a name="ln3070">	{ FXP_REV_82558_A4, UCODE(fxp_ucode_d101a), D101_CPUSAVER_DWORD, 0 },</a>
<a name="ln3071">	{ FXP_REV_82558_B0, UCODE(fxp_ucode_d101b0), D101_CPUSAVER_DWORD, 0 },</a>
<a name="ln3072">	{ FXP_REV_82559_A0, UCODE(fxp_ucode_d101ma),</a>
<a name="ln3073">	    D101M_CPUSAVER_DWORD, D101M_CPUSAVER_BUNDLE_MAX_DWORD },</a>
<a name="ln3074">	{ FXP_REV_82559S_A, UCODE(fxp_ucode_d101s),</a>
<a name="ln3075">	    D101S_CPUSAVER_DWORD, D101S_CPUSAVER_BUNDLE_MAX_DWORD },</a>
<a name="ln3076">	{ FXP_REV_82550, UCODE(fxp_ucode_d102),</a>
<a name="ln3077">	    D102_B_CPUSAVER_DWORD, D102_B_CPUSAVER_BUNDLE_MAX_DWORD },</a>
<a name="ln3078">	{ FXP_REV_82550_C, UCODE(fxp_ucode_d102c),</a>
<a name="ln3079">	    D102_C_CPUSAVER_DWORD, D102_C_CPUSAVER_BUNDLE_MAX_DWORD },</a>
<a name="ln3080">	{ FXP_REV_82551_F, UCODE(fxp_ucode_d102e),</a>
<a name="ln3081">	    D102_E_CPUSAVER_DWORD, D102_E_CPUSAVER_BUNDLE_MAX_DWORD },</a>
<a name="ln3082">	{ FXP_REV_82551_10, UCODE(fxp_ucode_d102e),</a>
<a name="ln3083">	    D102_E_CPUSAVER_DWORD, D102_E_CPUSAVER_BUNDLE_MAX_DWORD },</a>
<a name="ln3084">	{ 0, NULL, 0, 0, 0 }</a>
<a name="ln3085">};</a>
<a name="ln3086"> </a>
<a name="ln3087">static void</a>
<a name="ln3088">fxp_load_ucode(struct fxp_softc *sc)</a>
<a name="ln3089">{</a>
<a name="ln3090">	const struct ucode *uc;</a>
<a name="ln3091">	struct fxp_cb_ucode *cbp;</a>
<a name="ln3092">	int i;</a>
<a name="ln3093"> </a>
<a name="ln3094">	if (sc-&gt;flags &amp; FXP_FLAG_NO_UCODE)</a>
<a name="ln3095">		return;</a>
<a name="ln3096"> </a>
<a name="ln3097">	for (uc = ucode_table; uc-&gt;ucode != NULL; uc++)</a>
<a name="ln3098">		if (sc-&gt;revision == uc-&gt;revision)</a>
<a name="ln3099">			break;</a>
<a name="ln3100">	if (uc-&gt;ucode == NULL)</a>
<a name="ln3101">		return;</a>
<a name="ln3102">	cbp = (struct fxp_cb_ucode *)sc-&gt;fxp_desc.cbl_list;</a>
<a name="ln3103">	cbp-&gt;cb_status = 0;</a>
<a name="ln3104">	cbp-&gt;cb_command = htole16(FXP_CB_COMMAND_UCODE | FXP_CB_COMMAND_EL);</a>
<a name="ln3105">	cbp-&gt;link_addr = 0xffffffff;    	/* (no) next command */</a>
<a name="ln3106">	for (i = 0; i &lt; uc-&gt;length; i++)</a>
<a name="ln3107">		cbp-&gt;ucode[i] = htole32(uc-&gt;ucode[i]);</a>
<a name="ln3108">	if (uc-&gt;int_delay_offset)</a>
<a name="ln3109">		*(uint16_t *)&amp;cbp-&gt;ucode[uc-&gt;int_delay_offset] =</a>
<a name="ln3110">		    htole16(sc-&gt;tunable_int_delay + sc-&gt;tunable_int_delay / 2);</a>
<a name="ln3111">	if (uc-&gt;bundle_max_offset)</a>
<a name="ln3112">		*(uint16_t *)&amp;cbp-&gt;ucode[uc-&gt;bundle_max_offset] =</a>
<a name="ln3113">		    htole16(sc-&gt;tunable_bundle_max);</a>
<a name="ln3114">	/*</a>
<a name="ln3115">	 * Download the ucode to the chip.</a>
<a name="ln3116">	 */</a>
<a name="ln3117">	fxp_scb_wait(sc);</a>
<a name="ln3118">	bus_dmamap_sync(sc-&gt;cbl_tag, sc-&gt;cbl_map,</a>
<a name="ln3119">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln3120">	CSR_WRITE_4(sc, FXP_CSR_SCB_GENERAL, sc-&gt;fxp_desc.cbl_addr);</a>
<a name="ln3121">	fxp_scb_cmd(sc, FXP_SCB_COMMAND_CU_START);</a>
<a name="ln3122">	/* ...and wait for it to complete. */</a>
<a name="ln3123">	fxp_dma_wait(sc, &amp;cbp-&gt;cb_status, sc-&gt;cbl_tag, sc-&gt;cbl_map);</a>
<a name="ln3124">	device_printf(sc-&gt;dev,</a>
<a name="ln3125">	    &quot;Microcode loaded, int_delay: %d usec  bundle_max: %d\n&quot;,</a>
<a name="ln3126">	    sc-&gt;tunable_int_delay,</a>
<a name="ln3127">	    uc-&gt;bundle_max_offset == 0 ? 0 : sc-&gt;tunable_bundle_max);</a>
<a name="ln3128">	sc-&gt;flags |= FXP_FLAG_UCODE;</a>
<a name="ln3129">	bzero(cbp, FXP_TXCB_SZ);</a>
<a name="ln3130">}</a>
<a name="ln3131"> </a>
<a name="ln3132">#define FXP_SYSCTL_STAT_ADD(c, h, n, p, d)	\</a>
<a name="ln3133">	SYSCTL_ADD_UINT(c, h, OID_AUTO, n, CTLFLAG_RD, p, 0, d)</a>
<a name="ln3134"> </a>
<a name="ln3135">static void</a>
<a name="ln3136">fxp_sysctl_node(struct fxp_softc *sc)</a>
<a name="ln3137">{</a>
<a name="ln3138">	struct sysctl_ctx_list *ctx;</a>
<a name="ln3139">	struct sysctl_oid_list *child, *parent;</a>
<a name="ln3140">	struct sysctl_oid *tree;</a>
<a name="ln3141">	struct fxp_hwstats *hsp;</a>
<a name="ln3142"> </a>
<a name="ln3143">	ctx = device_get_sysctl_ctx(sc-&gt;dev);</a>
<a name="ln3144">	child = SYSCTL_CHILDREN(device_get_sysctl_tree(sc-&gt;dev));</a>
<a name="ln3145"> </a>
<a name="ln3146">	SYSCTL_ADD_PROC(ctx, child,</a>
<a name="ln3147">	    OID_AUTO, &quot;int_delay&quot;, CTLTYPE_INT | CTLFLAG_RW,</a>
<a name="ln3148">	    &amp;sc-&gt;tunable_int_delay, 0, sysctl_hw_fxp_int_delay, &quot;I&quot;,</a>
<a name="ln3149">	    &quot;FXP driver receive interrupt microcode bundling delay&quot;);</a>
<a name="ln3150">	SYSCTL_ADD_PROC(ctx, child,</a>
<a name="ln3151">	    OID_AUTO, &quot;bundle_max&quot;, CTLTYPE_INT | CTLFLAG_RW,</a>
<a name="ln3152">	    &amp;sc-&gt;tunable_bundle_max, 0, sysctl_hw_fxp_bundle_max, &quot;I&quot;,</a>
<a name="ln3153">	    &quot;FXP driver receive interrupt microcode bundle size limit&quot;);</a>
<a name="ln3154">	SYSCTL_ADD_INT(ctx, child,OID_AUTO, &quot;rnr&quot;, CTLFLAG_RD, &amp;sc-&gt;rnr, 0,</a>
<a name="ln3155">	    &quot;FXP RNR events&quot;);</a>
<a name="ln3156"> </a>
<a name="ln3157">	/*</a>
<a name="ln3158">	 * Pull in device tunables.</a>
<a name="ln3159">	 */</a>
<a name="ln3160">	sc-&gt;tunable_int_delay = TUNABLE_INT_DELAY;</a>
<a name="ln3161">	sc-&gt;tunable_bundle_max = TUNABLE_BUNDLE_MAX;</a>
<a name="ln3162">	(void) resource_int_value(device_get_name(sc-&gt;dev),</a>
<a name="ln3163">	    device_get_unit(sc-&gt;dev), &quot;int_delay&quot;, &amp;sc-&gt;tunable_int_delay);</a>
<a name="ln3164">	(void) resource_int_value(device_get_name(sc-&gt;dev),</a>
<a name="ln3165">	    device_get_unit(sc-&gt;dev), &quot;bundle_max&quot;, &amp;sc-&gt;tunable_bundle_max);</a>
<a name="ln3166">	sc-&gt;rnr = 0;</a>
<a name="ln3167"> </a>
<a name="ln3168">	hsp = &amp;sc-&gt;fxp_hwstats;</a>
<a name="ln3169">	tree = SYSCTL_ADD_NODE(ctx, child, OID_AUTO, &quot;stats&quot;, CTLFLAG_RD,</a>
<a name="ln3170">	    NULL, &quot;FXP statistics&quot;);</a>
<a name="ln3171">	parent = SYSCTL_CHILDREN(tree);</a>
<a name="ln3172"> </a>
<a name="ln3173">	/* Rx MAC statistics. */</a>
<a name="ln3174">	tree = SYSCTL_ADD_NODE(ctx, parent, OID_AUTO, &quot;rx&quot;, CTLFLAG_RD,</a>
<a name="ln3175">	    NULL, &quot;Rx MAC statistics&quot;);</a>
<a name="ln3176">	child = SYSCTL_CHILDREN(tree);</a>
<a name="ln3177">	FXP_SYSCTL_STAT_ADD(ctx, child, &quot;good_frames&quot;,</a>
<a name="ln3178">	    &amp;hsp-&gt;rx_good, &quot;Good frames&quot;);</a>
<a name="ln3179">	FXP_SYSCTL_STAT_ADD(ctx, child, &quot;crc_errors&quot;,</a>
<a name="ln3180">	    &amp;hsp-&gt;rx_crc_errors, &quot;CRC errors&quot;);</a>
<a name="ln3181">	FXP_SYSCTL_STAT_ADD(ctx, child, &quot;alignment_errors&quot;,</a>
<a name="ln3182">	    &amp;hsp-&gt;rx_alignment_errors, &quot;Alignment errors&quot;);</a>
<a name="ln3183">	FXP_SYSCTL_STAT_ADD(ctx, child, &quot;rnr_errors&quot;,</a>
<a name="ln3184">	    &amp;hsp-&gt;rx_rnr_errors, &quot;RNR errors&quot;);</a>
<a name="ln3185">	FXP_SYSCTL_STAT_ADD(ctx, child, &quot;overrun_errors&quot;,</a>
<a name="ln3186">	    &amp;hsp-&gt;rx_overrun_errors, &quot;Overrun errors&quot;);</a>
<a name="ln3187">	FXP_SYSCTL_STAT_ADD(ctx, child, &quot;cdt_errors&quot;,</a>
<a name="ln3188">	    &amp;hsp-&gt;rx_cdt_errors, &quot;Collision detect errors&quot;);</a>
<a name="ln3189">	FXP_SYSCTL_STAT_ADD(ctx, child, &quot;shortframes&quot;,</a>
<a name="ln3190">	    &amp;hsp-&gt;rx_shortframes, &quot;Short frame errors&quot;);</a>
<a name="ln3191">	if (sc-&gt;revision &gt;= FXP_REV_82558_A4) {</a>
<a name="ln3192">		FXP_SYSCTL_STAT_ADD(ctx, child, &quot;pause&quot;,</a>
<a name="ln3193">		    &amp;hsp-&gt;rx_pause, &quot;Pause frames&quot;);</a>
<a name="ln3194">		FXP_SYSCTL_STAT_ADD(ctx, child, &quot;controls&quot;,</a>
<a name="ln3195">		    &amp;hsp-&gt;rx_controls, &quot;Unsupported control frames&quot;);</a>
<a name="ln3196">	}</a>
<a name="ln3197">	if (sc-&gt;revision &gt;= FXP_REV_82559_A0)</a>
<a name="ln3198">		FXP_SYSCTL_STAT_ADD(ctx, child, &quot;tco&quot;,</a>
<a name="ln3199">		    &amp;hsp-&gt;rx_tco, &quot;TCO frames&quot;);</a>
<a name="ln3200"> </a>
<a name="ln3201">	/* Tx MAC statistics. */</a>
<a name="ln3202">	tree = SYSCTL_ADD_NODE(ctx, parent, OID_AUTO, &quot;tx&quot;, CTLFLAG_RD,</a>
<a name="ln3203">	    NULL, &quot;Tx MAC statistics&quot;);</a>
<a name="ln3204">	child = SYSCTL_CHILDREN(tree);</a>
<a name="ln3205">	FXP_SYSCTL_STAT_ADD(ctx, child, &quot;good_frames&quot;,</a>
<a name="ln3206">	    &amp;hsp-&gt;tx_good, &quot;Good frames&quot;);</a>
<a name="ln3207">	FXP_SYSCTL_STAT_ADD(ctx, child, &quot;maxcols&quot;,</a>
<a name="ln3208">	    &amp;hsp-&gt;tx_maxcols, &quot;Maximum collisions errors&quot;);</a>
<a name="ln3209">	FXP_SYSCTL_STAT_ADD(ctx, child, &quot;latecols&quot;,</a>
<a name="ln3210">	    &amp;hsp-&gt;tx_latecols, &quot;Late collisions errors&quot;);</a>
<a name="ln3211">	FXP_SYSCTL_STAT_ADD(ctx, child, &quot;underruns&quot;,</a>
<a name="ln3212">	    &amp;hsp-&gt;tx_underruns, &quot;Underrun errors&quot;);</a>
<a name="ln3213">	FXP_SYSCTL_STAT_ADD(ctx, child, &quot;lostcrs&quot;,</a>
<a name="ln3214">	    &amp;hsp-&gt;tx_lostcrs, &quot;Lost carrier sense&quot;);</a>
<a name="ln3215">	FXP_SYSCTL_STAT_ADD(ctx, child, &quot;deffered&quot;,</a>
<a name="ln3216">	    &amp;hsp-&gt;tx_deffered, &quot;Deferred&quot;);</a>
<a name="ln3217">	FXP_SYSCTL_STAT_ADD(ctx, child, &quot;single_collisions&quot;,</a>
<a name="ln3218">	    &amp;hsp-&gt;tx_single_collisions, &quot;Single collisions&quot;);</a>
<a name="ln3219">	FXP_SYSCTL_STAT_ADD(ctx, child, &quot;multiple_collisions&quot;,</a>
<a name="ln3220">	    &amp;hsp-&gt;tx_multiple_collisions, &quot;Multiple collisions&quot;);</a>
<a name="ln3221">	FXP_SYSCTL_STAT_ADD(ctx, child, &quot;total_collisions&quot;,</a>
<a name="ln3222">	    &amp;hsp-&gt;tx_total_collisions, &quot;Total collisions&quot;);</a>
<a name="ln3223">	if (sc-&gt;revision &gt;= FXP_REV_82558_A4)</a>
<a name="ln3224">		FXP_SYSCTL_STAT_ADD(ctx, child, &quot;pause&quot;,</a>
<a name="ln3225">		    &amp;hsp-&gt;tx_pause, &quot;Pause frames&quot;);</a>
<a name="ln3226">	if (sc-&gt;revision &gt;= FXP_REV_82559_A0)</a>
<a name="ln3227">		FXP_SYSCTL_STAT_ADD(ctx, child, &quot;tco&quot;,</a>
<a name="ln3228">		    &amp;hsp-&gt;tx_tco, &quot;TCO frames&quot;);</a>
<a name="ln3229">}</a>
<a name="ln3230"> </a>
<a name="ln3231">#undef FXP_SYSCTL_STAT_ADD</a>
<a name="ln3232"> </a>
<a name="ln3233">static int</a>
<a name="ln3234">sysctl_int_range(SYSCTL_HANDLER_ARGS, int low, int high)</a>
<a name="ln3235">{</a>
<a name="ln3236">	int error, value;</a>
<a name="ln3237"> </a>
<a name="ln3238">	value = *(int *)arg1;</a>
<a name="ln3239">	error = sysctl_handle_int(oidp, &amp;value, 0, req);</a>
<a name="ln3240">	if (error || !req-&gt;newptr)</a>
<a name="ln3241">		return (error);</a>
<a name="ln3242">	if (value &lt; low || value &gt; high)</a>
<a name="ln3243">		return (EINVAL);</a>
<a name="ln3244">	*(int *)arg1 = value;</a>
<a name="ln3245">	return (0);</a>
<a name="ln3246">}</a>
<a name="ln3247"> </a>
<a name="ln3248">/*</a>
<a name="ln3249"> * Interrupt delay is expressed in microseconds, a multiplier is used</a>
<a name="ln3250"> * to convert this to the appropriate clock ticks before using.</a>
<a name="ln3251"> */</a>
<a name="ln3252">static int</a>
<a name="ln3253">sysctl_hw_fxp_int_delay(SYSCTL_HANDLER_ARGS)</a>
<a name="ln3254">{</a>
<a name="ln3255"> </a>
<a name="ln3256">	return (sysctl_int_range(oidp, arg1, arg2, req, 300, 3000));</a>
<a name="ln3257">}</a>
<a name="ln3258"> </a>
<a name="ln3259">static int</a>
<a name="ln3260">sysctl_hw_fxp_bundle_max(SYSCTL_HANDLER_ARGS)</a>
<a name="ln3261">{</a>
<a name="ln3262"> </a>
<a name="ln3263">	return (sysctl_int_range(oidp, arg1, arg2, req, 1, 0xffff));</a>
<a name="ln3264">}</a>

</code></pre>
<div class="balloon" rel="3129"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memset' function will lead to overflow of the buffer 'cbp'.</p></div>
<div class="balloon" rel="1630"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array underrun is possible. The '-1' index is pointing beyond array bound.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
