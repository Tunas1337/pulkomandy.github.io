
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>dir.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2"> * dir.c - Directory handling code. Originated from the Linux-NTFS project.</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2002-2005 Anton Altaparmakov</a>
<a name="ln5"> * Copyright (c) 2004-2005 Richard Russon</a>
<a name="ln6"> * Copyright (c) 2004-2008 Szabolcs Szakacsits</a>
<a name="ln7"> * Copyright (c) 2005-2007 Yura Pakhuchiy</a>
<a name="ln8"> * Copyright (c) 2008-2014 Jean-Pierre Andre</a>
<a name="ln9"> *</a>
<a name="ln10"> * This program/include file is free software; you can redistribute it and/or</a>
<a name="ln11"> * modify it under the terms of the GNU General Public License as published</a>
<a name="ln12"> * by the Free Software Foundation; either version 2 of the License, or</a>
<a name="ln13"> * (at your option) any later version.</a>
<a name="ln14"> *</a>
<a name="ln15"> * This program/include file is distributed in the hope that it will be</a>
<a name="ln16"> * useful, but WITHOUT ANY WARRANTY; without even the implied warranty</a>
<a name="ln17"> * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln18"> * GNU General Public License for more details.</a>
<a name="ln19"> *</a>
<a name="ln20"> * You should have received a copy of the GNU General Public License</a>
<a name="ln21"> * along with this program (in the main directory of the NTFS-3G</a>
<a name="ln22"> * distribution in the file COPYING); if not, write to the Free Software</a>
<a name="ln23"> * Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</a>
<a name="ln24"> */</a>
<a name="ln25"> </a>
<a name="ln26">#ifdef HAVE_CONFIG_H</a>
<a name="ln27">#include &quot;config.h&quot;</a>
<a name="ln28">#endif</a>
<a name="ln29"> </a>
<a name="ln30">#ifdef HAVE_STDLIB_H</a>
<a name="ln31">#include &lt;stdlib.h&gt;</a>
<a name="ln32">#endif</a>
<a name="ln33">#ifdef HAVE_ERRNO_H</a>
<a name="ln34">#include &lt;errno.h&gt;</a>
<a name="ln35">#endif</a>
<a name="ln36">#ifdef HAVE_STRING_H</a>
<a name="ln37">#include &lt;string.h&gt;</a>
<a name="ln38">#endif</a>
<a name="ln39">#ifdef HAVE_SYS_STAT_H</a>
<a name="ln40">#include &lt;sys/stat.h&gt;</a>
<a name="ln41">#endif</a>
<a name="ln42"> </a>
<a name="ln43">#ifdef HAVE_SYS_TYPES_H</a>
<a name="ln44">#include &lt;sys/types.h&gt;</a>
<a name="ln45">#endif</a>
<a name="ln46">#ifdef MAJOR_IN_MKDEV</a>
<a name="ln47">#include &lt;sys/mkdev.h&gt;</a>
<a name="ln48">#endif</a>
<a name="ln49">#ifdef MAJOR_IN_SYSMACROS</a>
<a name="ln50">#include &lt;sys/sysmacros.h&gt;</a>
<a name="ln51">#endif</a>
<a name="ln52"> </a>
<a name="ln53">#include &quot;param.h&quot;</a>
<a name="ln54">#include &quot;types.h&quot;</a>
<a name="ln55">#include &quot;debug.h&quot;</a>
<a name="ln56">#include &quot;attrib.h&quot;</a>
<a name="ln57">#include &quot;inode.h&quot;</a>
<a name="ln58">#include &quot;dir.h&quot;</a>
<a name="ln59">#include &quot;volume.h&quot;</a>
<a name="ln60">#include &quot;mft.h&quot;</a>
<a name="ln61">#include &quot;index.h&quot;</a>
<a name="ln62">#include &quot;ntfstime.h&quot;</a>
<a name="ln63">#include &quot;lcnalloc.h&quot;</a>
<a name="ln64">#include &quot;logging.h&quot;</a>
<a name="ln65">#include &quot;cache.h&quot;</a>
<a name="ln66">#include &quot;misc.h&quot;</a>
<a name="ln67">#include &quot;security.h&quot;</a>
<a name="ln68">#include &quot;reparse.h&quot;</a>
<a name="ln69">#include &quot;object_id.h&quot;</a>
<a name="ln70">#include &quot;xattrs.h&quot;</a>
<a name="ln71"> </a>
<a name="ln72">/*</a>
<a name="ln73"> * The little endian Unicode strings &quot;$I30&quot;, &quot;$SII&quot;, &quot;$SDH&quot;, &quot;$O&quot;</a>
<a name="ln74"> *  and &quot;$Q&quot; as global constants.</a>
<a name="ln75"> */</a>
<a name="ln76">ntfschar NTFS_INDEX_I30[5] = { const_cpu_to_le16('$'), const_cpu_to_le16('I'),</a>
<a name="ln77">		const_cpu_to_le16('3'), const_cpu_to_le16('0'),</a>
<a name="ln78">		const_cpu_to_le16('\0') };</a>
<a name="ln79">ntfschar NTFS_INDEX_SII[5] = { const_cpu_to_le16('$'), const_cpu_to_le16('S'),</a>
<a name="ln80">		const_cpu_to_le16('I'), const_cpu_to_le16('I'),</a>
<a name="ln81">		const_cpu_to_le16('\0') };</a>
<a name="ln82">ntfschar NTFS_INDEX_SDH[5] = { const_cpu_to_le16('$'), const_cpu_to_le16('S'),</a>
<a name="ln83">		const_cpu_to_le16('D'), const_cpu_to_le16('H'),</a>
<a name="ln84">		const_cpu_to_le16('\0') };</a>
<a name="ln85">ntfschar NTFS_INDEX_O[3] = { const_cpu_to_le16('$'), const_cpu_to_le16('O'),</a>
<a name="ln86">		const_cpu_to_le16('\0') };</a>
<a name="ln87">ntfschar NTFS_INDEX_Q[3] = { const_cpu_to_le16('$'), const_cpu_to_le16('Q'),</a>
<a name="ln88">		const_cpu_to_le16('\0') };</a>
<a name="ln89">ntfschar NTFS_INDEX_R[3] = { const_cpu_to_le16('$'), const_cpu_to_le16('R'),</a>
<a name="ln90">		const_cpu_to_le16('\0') };</a>
<a name="ln91"> </a>
<a name="ln92">#if CACHE_INODE_SIZE</a>
<a name="ln93"> </a>
<a name="ln94">/*</a>
<a name="ln95"> *		Pathname hashing</a>
<a name="ln96"> *</a>
<a name="ln97"> *	Based on first char and second char (which may be '\0')</a>
<a name="ln98"> */</a>
<a name="ln99"> </a>
<a name="ln100">int ntfs_dir_inode_hash(const struct CACHED_GENERIC *cached)</a>
<a name="ln101">{</a>
<a name="ln102">	const char *path;</a>
<a name="ln103">	const unsigned char *name;</a>
<a name="ln104"> </a>
<a name="ln105">	path = (const char*)cached-&gt;variable;</a>
<a name="ln106">	if (!path) {</a>
<a name="ln107">		ntfs_log_error(&quot;Bad inode cache entry\n&quot;);</a>
<a name="ln108">		return (-1);</a>
<a name="ln109">	}</a>
<a name="ln110">	name = (const unsigned char*)strrchr(path,'/');</a>
<a name="ln111">	if (!name)</a>
<a name="ln112">		name = (const unsigned char*)path;</a>
<a name="ln113">	return (((name[0] &lt;&lt; 1) + name[1] + strlen((const char*)name))</a>
<a name="ln114">				% (2*CACHE_INODE_SIZE));</a>
<a name="ln115">}</a>
<a name="ln116"> </a>
<a name="ln117">/*</a>
<a name="ln118"> *		Pathname comparing for entering/fetching from cache</a>
<a name="ln119"> */</a>
<a name="ln120"> </a>
<a name="ln121">static int inode_cache_compare(const struct CACHED_GENERIC *cached,</a>
<a name="ln122">			const struct CACHED_GENERIC *wanted)</a>
<a name="ln123">{</a>
<a name="ln124">	return (!cached-&gt;variable</a>
<a name="ln125">		    || strcmp(cached-&gt;variable, wanted-&gt;variable));</a>
<a name="ln126">}</a>
<a name="ln127"> </a>
<a name="ln128">/*</a>
<a name="ln129"> *		Pathname comparing for invalidating entries in cache</a>
<a name="ln130"> *</a>
<a name="ln131"> *	A partial path is compared in order to invalidate all paths</a>
<a name="ln132"> *	related to a renamed directory</a>
<a name="ln133"> *	inode numbers are also checked, as deleting a long name may</a>
<a name="ln134"> *	imply deleting a short name and conversely</a>
<a name="ln135"> *</a>
<a name="ln136"> *	Only use associated with a CACHE_NOHASH flag</a>
<a name="ln137"> */</a>
<a name="ln138"> </a>
<a name="ln139">static int inode_cache_inv_compare(const struct CACHED_GENERIC *cached,</a>
<a name="ln140">			const struct CACHED_GENERIC *wanted)</a>
<a name="ln141">{</a>
<a name="ln142">	int len;</a>
<a name="ln143">	BOOL different;</a>
<a name="ln144">	const struct CACHED_INODE *w;</a>
<a name="ln145">	const struct CACHED_INODE *c;</a>
<a name="ln146"> </a>
<a name="ln147">	w = (const struct CACHED_INODE*)wanted;</a>
<a name="ln148">	c = (const struct CACHED_INODE*)cached;</a>
<a name="ln149">	if (w-&gt;pathname) {</a>
<a name="ln150">		len = strlen(w-&gt;pathname);</a>
<a name="ln151">		different = !cached-&gt;variable</a>
<a name="ln152">			|| ((w-&gt;inum != MREF(c-&gt;inum))</a>
<a name="ln153">			   &amp;&amp; (strncmp(c-&gt;pathname, w-&gt;pathname, len)</a>
<a name="ln154">				|| ((c-&gt;pathname[len] != '\0')</a>
<a name="ln155">				   &amp;&amp; (c-&gt;pathname[len] != '/'))));</a>
<a name="ln156">	} else</a>
<a name="ln157">		different = !c-&gt;pathname</a>
<a name="ln158">			|| (w-&gt;inum != MREF(c-&gt;inum));</a>
<a name="ln159">	return (different);</a>
<a name="ln160">}</a>
<a name="ln161"> </a>
<a name="ln162">#endif</a>
<a name="ln163"> </a>
<a name="ln164">#if CACHE_LOOKUP_SIZE</a>
<a name="ln165"> </a>
<a name="ln166">/*</a>
<a name="ln167"> *		File name comparing for entering/fetching from lookup cache</a>
<a name="ln168"> */</a>
<a name="ln169"> </a>
<a name="ln170">static int lookup_cache_compare(const struct CACHED_GENERIC *cached,</a>
<a name="ln171">			const struct CACHED_GENERIC *wanted)</a>
<a name="ln172">{</a>
<a name="ln173">	const struct CACHED_LOOKUP *c = (const struct CACHED_LOOKUP*) cached;</a>
<a name="ln174">	const struct CACHED_LOOKUP *w = (const struct CACHED_LOOKUP*) wanted;</a>
<a name="ln175">	return (!c-&gt;name</a>
<a name="ln176">		    || (c-&gt;parent != w-&gt;parent)</a>
<a name="ln177">		    || (c-&gt;namesize != w-&gt;namesize)</a>
<a name="ln178">		    || memcmp(c-&gt;name, w-&gt;name, c-&gt;namesize));</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181">/*</a>
<a name="ln182"> *		Inode number comparing for invalidating lookup cache</a>
<a name="ln183"> *</a>
<a name="ln184"> *	All entries with designated inode number are invalidated</a>
<a name="ln185"> *</a>
<a name="ln186"> *	Only use associated with a CACHE_NOHASH flag</a>
<a name="ln187"> */</a>
<a name="ln188"> </a>
<a name="ln189">static int lookup_cache_inv_compare(const struct CACHED_GENERIC *cached,</a>
<a name="ln190">			const struct CACHED_GENERIC *wanted)</a>
<a name="ln191">{</a>
<a name="ln192">	const struct CACHED_LOOKUP *c = (const struct CACHED_LOOKUP*) cached;</a>
<a name="ln193">	const struct CACHED_LOOKUP *w = (const struct CACHED_LOOKUP*) wanted;</a>
<a name="ln194">	return (!c-&gt;name</a>
<a name="ln195">		    || (c-&gt;parent != w-&gt;parent)</a>
<a name="ln196">		    || (MREF(c-&gt;inum) != MREF(w-&gt;inum)));</a>
<a name="ln197">}</a>
<a name="ln198"> </a>
<a name="ln199">/*</a>
<a name="ln200"> *		Lookup hashing</a>
<a name="ln201"> *</a>
<a name="ln202"> *	Based on first, second and and last char</a>
<a name="ln203"> */</a>
<a name="ln204"> </a>
<a name="ln205">int ntfs_dir_lookup_hash(const struct CACHED_GENERIC *cached)</a>
<a name="ln206">{</a>
<a name="ln207">	const unsigned char *name;</a>
<a name="ln208">	int count;</a>
<a name="ln209">	unsigned int val;</a>
<a name="ln210"> </a>
<a name="ln211">	name = (const unsigned char*)cached-&gt;variable;</a>
<a name="ln212">	count = cached-&gt;varsize;</a>
<a name="ln213">	if (!name || !count) {</a>
<a name="ln214">		ntfs_log_error(&quot;Bad lookup cache entry\n&quot;);</a>
<a name="ln215">		return (-1);</a>
<a name="ln216">	}</a>
<a name="ln217">	val = (name[0] &lt;&lt; 2) + (name[1] &lt;&lt; 1) + name[count - 1] + count;</a>
<a name="ln218">	return (val % (2*CACHE_LOOKUP_SIZE));</a>
<a name="ln219">}</a>
<a name="ln220"> </a>
<a name="ln221">#endif</a>
<a name="ln222"> </a>
<a name="ln223">/**</a>
<a name="ln224"> * ntfs_inode_lookup_by_name - find an inode in a directory given its name</a>
<a name="ln225"> * @dir_ni:	ntfs inode of the directory in which to search for the name</a>
<a name="ln226"> * @uname:	Unicode name for which to search in the directory</a>
<a name="ln227"> * @uname_len:	length of the name @uname in Unicode characters</a>
<a name="ln228"> *</a>
<a name="ln229"> * Look for an inode with name @uname in the directory with inode @dir_ni.</a>
<a name="ln230"> * ntfs_inode_lookup_by_name() walks the contents of the directory looking for</a>
<a name="ln231"> * the Unicode name. If the name is found in the directory, the corresponding</a>
<a name="ln232"> * inode number (&gt;= 0) is returned as a mft reference in cpu format, i.e. it</a>
<a name="ln233"> * is a 64-bit number containing the sequence number.</a>
<a name="ln234"> *</a>
<a name="ln235"> * On error, return -1 with errno set to the error code. If the inode is is not</a>
<a name="ln236"> * found errno is ENOENT.</a>
<a name="ln237"> *</a>
<a name="ln238"> * Note, @uname_len does not include the (optional) terminating NULL character.</a>
<a name="ln239"> *</a>
<a name="ln240"> * Note, we look for a case sensitive match first but we also look for a case</a>
<a name="ln241"> * insensitive match at the same time. If we find a case insensitive match, we</a>
<a name="ln242"> * save that for the case that we don't find an exact match, where we return</a>
<a name="ln243"> * the mft reference of the case insensitive match.</a>
<a name="ln244"> *</a>
<a name="ln245"> * If the volume is mounted with the case sensitive flag set, then we only</a>
<a name="ln246"> * allow exact matches.</a>
<a name="ln247"> */</a>
<a name="ln248">u64 ntfs_inode_lookup_by_name(ntfs_inode *dir_ni,</a>
<a name="ln249">		const ntfschar *uname, const int uname_len)</a>
<a name="ln250">{</a>
<a name="ln251">	VCN vcn;</a>
<a name="ln252">	u64 mref = 0;</a>
<a name="ln253">	s64 br;</a>
<a name="ln254">	ntfs_volume *vol = dir_ni-&gt;vol;</a>
<a name="ln255">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln256">	INDEX_ROOT *ir;</a>
<a name="ln257">	INDEX_ENTRY *ie;</a>
<a name="ln258">	INDEX_ALLOCATION *ia;</a>
<a name="ln259">	IGNORE_CASE_BOOL case_sensitivity;</a>
<a name="ln260">	u8 *index_end;</a>
<a name="ln261">	ntfs_attr *ia_na;</a>
<a name="ln262">	int eo, rc;</a>
<a name="ln263">	u32 index_block_size;</a>
<a name="ln264">	u8 index_vcn_size_bits;</a>
<a name="ln265"> </a>
<a name="ln266">	ntfs_log_trace(&quot;Entering\n&quot;);</a>
<a name="ln267"> </a>
<a name="ln268">	if (!dir_ni || !dir_ni-&gt;mrec || !uname || uname_len &lt;= 0) {</a>
<a name="ln269">		errno = EINVAL;</a>
<a name="ln270">		return -1;</a>
<a name="ln271">	}</a>
<a name="ln272"> </a>
<a name="ln273">	ctx = ntfs_attr_get_search_ctx(dir_ni, NULL);</a>
<a name="ln274">	if (!ctx)</a>
<a name="ln275">		return -1;</a>
<a name="ln276"> </a>
<a name="ln277">	/* Find the index root attribute in the mft record. */</a>
<a name="ln278">	if (ntfs_attr_lookup(AT_INDEX_ROOT, NTFS_INDEX_I30, 4, CASE_SENSITIVE, 0, NULL,</a>
<a name="ln279">			0, ctx)) {</a>
<a name="ln280">		ntfs_log_perror(&quot;Index root attribute missing in directory inode &quot;</a>
<a name="ln281">				&quot;%lld&quot;, (unsigned long long)dir_ni-&gt;mft_no);</a>
<a name="ln282">		goto put_err_out;</a>
<a name="ln283">	}</a>
<a name="ln284">	case_sensitivity = (NVolCaseSensitive(vol) ? CASE_SENSITIVE : IGNORE_CASE);</a>
<a name="ln285">	/* Get to the index root value. */</a>
<a name="ln286">	ir = (INDEX_ROOT*)((u8*)ctx-&gt;attr +</a>
<a name="ln287">			le16_to_cpu(ctx-&gt;attr-&gt;value_offset));</a>
<a name="ln288">	index_block_size = le32_to_cpu(ir-&gt;index_block_size);</a>
<a name="ln289">	if (index_block_size &lt; NTFS_BLOCK_SIZE ||</a>
<a name="ln290">			index_block_size &amp; (index_block_size - 1)) {</a>
<a name="ln291">		ntfs_log_error(&quot;Index block size %u is invalid.\n&quot;,</a>
<a name="ln292">				(unsigned)index_block_size);</a>
<a name="ln293">		goto put_err_out;</a>
<a name="ln294">	}</a>
<a name="ln295">	index_end = (u8*)&amp;ir-&gt;index + le32_to_cpu(ir-&gt;index.index_length);</a>
<a name="ln296">	/* The first index entry. */</a>
<a name="ln297">	ie = (INDEX_ENTRY*)((u8*)&amp;ir-&gt;index +</a>
<a name="ln298">			le32_to_cpu(ir-&gt;index.entries_offset));</a>
<a name="ln299">	/*</a>
<a name="ln300">	 * Loop until we exceed valid memory (corruption case) or until we</a>
<a name="ln301">	 * reach the last entry.</a>
<a name="ln302">	 */</a>
<a name="ln303">	for (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie-&gt;length))) {</a>
<a name="ln304">		/* Bounds checks. */</a>
<a name="ln305">		if ((u8*)ie &lt; (u8*)ctx-&gt;mrec || (u8*)ie +</a>
<a name="ln306">				sizeof(INDEX_ENTRY_HEADER) &gt; index_end ||</a>
<a name="ln307">				(u8*)ie + le16_to_cpu(ie-&gt;key_length) &gt;</a>
<a name="ln308">				index_end) {</a>
<a name="ln309">			ntfs_log_error(&quot;Index entry out of bounds in inode %lld&quot;</a>
<a name="ln310">				       &quot;\n&quot;, (unsigned long long)dir_ni-&gt;mft_no);</a>
<a name="ln311">			goto put_err_out;</a>
<a name="ln312">		}</a>
<a name="ln313">		/*</a>
<a name="ln314">		 * The last entry cannot contain a name. It can however contain</a>
<a name="ln315">		 * a pointer to a child node in the B+tree so we just break out.</a>
<a name="ln316">		 */</a>
<a name="ln317">		if (ie-&gt;ie_flags &amp; INDEX_ENTRY_END)</a>
<a name="ln318">			break;</a>
<a name="ln319"> </a>
<a name="ln320">		if (!le16_to_cpu(ie-&gt;length)) {</a>
<a name="ln321">			ntfs_log_error(&quot;Zero length index entry in inode %lld&quot;</a>
<a name="ln322">				       &quot;\n&quot;, (unsigned long long)dir_ni-&gt;mft_no);</a>
<a name="ln323">			goto put_err_out;</a>
<a name="ln324">		}</a>
<a name="ln325">		/*</a>
<a name="ln326">		 * Not a perfect match, need to do full blown collation so we</a>
<a name="ln327">		 * know which way in the B+tree we have to go.</a>
<a name="ln328">		 */</a>
<a name="ln329">		rc = ntfs_names_full_collate(uname, uname_len,</a>
<a name="ln330">				(ntfschar*)&amp;ie-&gt;key.file_name.file_name,</a>
<a name="ln331">				ie-&gt;key.file_name.file_name_length,</a>
<a name="ln332">				case_sensitivity, vol-&gt;upcase, vol-&gt;upcase_len);</a>
<a name="ln333">		/*</a>
<a name="ln334">		 * If uname collates before the name of the current entry, there</a>
<a name="ln335">		 * is definitely no such name in this index but we might need to</a>
<a name="ln336">		 * descend into the B+tree so we just break out of the loop.</a>
<a name="ln337">		 */</a>
<a name="ln338">		if (rc == -1)</a>
<a name="ln339">			break;</a>
<a name="ln340">		/* The names are not equal, continue the search. */</a>
<a name="ln341">		if (rc)</a>
<a name="ln342">			continue;</a>
<a name="ln343">		/*</a>
<a name="ln344">		 * Perfect match, this will never happen as the</a>
<a name="ln345">		 * ntfs_are_names_equal() call will have gotten a match but we</a>
<a name="ln346">		 * still treat it correctly.</a>
<a name="ln347">		 */</a>
<a name="ln348">		mref = le64_to_cpu(ie-&gt;indexed_file);</a>
<a name="ln349">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln350">		return mref;</a>
<a name="ln351">	}</a>
<a name="ln352">	/*</a>
<a name="ln353">	 * We have finished with this index without success. Check for the</a>
<a name="ln354">	 * presence of a child node and if not present return error code</a>
<a name="ln355">	 * ENOENT, unless we have got the mft reference of a matching name</a>
<a name="ln356">	 * cached in mref in which case return mref.</a>
<a name="ln357">	 */</a>
<a name="ln358">	if (!(ie-&gt;ie_flags &amp; INDEX_ENTRY_NODE)) {</a>
<a name="ln359">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln360">		if (mref)</a>
<a name="ln361">			return mref;</a>
<a name="ln362">		ntfs_log_debug(&quot;Entry not found - between root entries.\n&quot;);</a>
<a name="ln363">		errno = ENOENT;</a>
<a name="ln364">		return -1;</a>
<a name="ln365">	} /* Child node present, descend into it. */</a>
<a name="ln366"> </a>
<a name="ln367">	/* Open the index allocation attribute. */</a>
<a name="ln368">	ia_na = ntfs_attr_open(dir_ni, AT_INDEX_ALLOCATION, NTFS_INDEX_I30, 4);</a>
<a name="ln369">	if (!ia_na) {</a>
<a name="ln370">		ntfs_log_perror(&quot;Failed to open index allocation (inode %lld)&quot;,</a>
<a name="ln371">				(unsigned long long)dir_ni-&gt;mft_no);</a>
<a name="ln372">		goto put_err_out;</a>
<a name="ln373">	}</a>
<a name="ln374"> </a>
<a name="ln375">	/* Allocate a buffer for the current index block. */</a>
<a name="ln376">	ia = ntfs_malloc(index_block_size);</a>
<a name="ln377">	if (!ia) {</a>
<a name="ln378">		ntfs_attr_close(ia_na);</a>
<a name="ln379">		goto put_err_out;</a>
<a name="ln380">	}</a>
<a name="ln381"> </a>
<a name="ln382">	/* Determine the size of a vcn in the directory index. */</a>
<a name="ln383">	if (vol-&gt;cluster_size &lt;= index_block_size) {</a>
<a name="ln384">		index_vcn_size_bits = vol-&gt;cluster_size_bits;</a>
<a name="ln385">	} else {</a>
<a name="ln386">		index_vcn_size_bits = NTFS_BLOCK_SIZE_BITS;</a>
<a name="ln387">	}</a>
<a name="ln388"> </a>
<a name="ln389">	/* Get the starting vcn of the index_block holding the child node. */</a>
<a name="ln390">	vcn = sle64_to_cpup((sle64*)((u8*)ie + le16_to_cpu(ie-&gt;length) - 8));</a>
<a name="ln391"> </a>
<a name="ln392">descend_into_child_node:</a>
<a name="ln393"> </a>
<a name="ln394">	/* Read the index block starting at vcn. */</a>
<a name="ln395">	br = ntfs_attr_mst_pread(ia_na, vcn &lt;&lt; index_vcn_size_bits, 1,</a>
<a name="ln396">			index_block_size, ia);</a>
<a name="ln397">	if (br != 1) {</a>
<a name="ln398">		if (br != -1)</a>
<a name="ln399">			errno = EIO;</a>
<a name="ln400">		ntfs_log_perror(&quot;Failed to read vcn 0x%llx&quot;,</a>
<a name="ln401">			       	(unsigned long long)vcn);</a>
<a name="ln402">		goto close_err_out;</a>
<a name="ln403">	}</a>
<a name="ln404"> </a>
<a name="ln405">	if (sle64_to_cpu(ia-&gt;index_block_vcn) != vcn) {</a>
<a name="ln406">		ntfs_log_error(&quot;Actual VCN (0x%llx) of index buffer is different &quot;</a>
<a name="ln407">				&quot;from expected VCN (0x%llx).\n&quot;,</a>
<a name="ln408">				(long long)sle64_to_cpu(ia-&gt;index_block_vcn),</a>
<a name="ln409">				(long long)vcn);</a>
<a name="ln410">		errno = EIO;</a>
<a name="ln411">		goto close_err_out;</a>
<a name="ln412">	}</a>
<a name="ln413">	if (le32_to_cpu(ia-&gt;index.allocated_size) + 0x18 != index_block_size) {</a>
<a name="ln414">		ntfs_log_error(&quot;Index buffer (VCN 0x%llx) of directory inode 0x%llx &quot;</a>
<a name="ln415">				&quot;has a size (%u) differing from the directory &quot;</a>
<a name="ln416">				&quot;specified size (%u).\n&quot;, (long long)vcn,</a>
<a name="ln417">				(unsigned long long)dir_ni-&gt;mft_no,</a>
<a name="ln418">				(unsigned) le32_to_cpu(ia-&gt;index.allocated_size) + 0x18,</a>
<a name="ln419">				(unsigned)index_block_size);</a>
<a name="ln420">		errno = EIO;</a>
<a name="ln421">		goto close_err_out;</a>
<a name="ln422">	}</a>
<a name="ln423">	index_end = (u8*)&amp;ia-&gt;index + le32_to_cpu(ia-&gt;index.index_length);</a>
<a name="ln424">	if (index_end &gt; (u8*)ia + index_block_size) {</a>
<a name="ln425">		ntfs_log_error(&quot;Size of index buffer (VCN 0x%llx) of directory inode &quot;</a>
<a name="ln426">				&quot;0x%llx exceeds maximum size.\n&quot;,</a>
<a name="ln427">				(long long)vcn, (unsigned long long)dir_ni-&gt;mft_no);</a>
<a name="ln428">		errno = EIO;</a>
<a name="ln429">		goto close_err_out;</a>
<a name="ln430">	}</a>
<a name="ln431"> </a>
<a name="ln432">	/* The first index entry. */</a>
<a name="ln433">	ie = (INDEX_ENTRY*)((u8*)&amp;ia-&gt;index +</a>
<a name="ln434">			le32_to_cpu(ia-&gt;index.entries_offset));</a>
<a name="ln435">	/*</a>
<a name="ln436">	 * Iterate similar to above big loop but applied to index buffer, thus</a>
<a name="ln437">	 * loop until we exceed valid memory (corruption case) or until we</a>
<a name="ln438">	 * reach the last entry.</a>
<a name="ln439">	 */</a>
<a name="ln440">	for (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie-&gt;length))) {</a>
<a name="ln441">		/* Bounds check. */</a>
<a name="ln442">		if ((u8*)ie &lt; (u8*)ia || (u8*)ie +</a>
<a name="ln443">				sizeof(INDEX_ENTRY_HEADER) &gt; index_end ||</a>
<a name="ln444">				(u8*)ie + le16_to_cpu(ie-&gt;key_length) &gt;</a>
<a name="ln445">				index_end) {</a>
<a name="ln446">			ntfs_log_error(&quot;Index entry out of bounds in directory &quot;</a>
<a name="ln447">				       &quot;inode %lld.\n&quot;,</a>
<a name="ln448">				       (unsigned long long)dir_ni-&gt;mft_no);</a>
<a name="ln449">			errno = EIO;</a>
<a name="ln450">			goto close_err_out;</a>
<a name="ln451">		}</a>
<a name="ln452">		/*</a>
<a name="ln453">		 * The last entry cannot contain a name. It can however contain</a>
<a name="ln454">		 * a pointer to a child node in the B+tree so we just break out.</a>
<a name="ln455">		 */</a>
<a name="ln456">		if (ie-&gt;ie_flags &amp; INDEX_ENTRY_END)</a>
<a name="ln457">			break;</a>
<a name="ln458"> </a>
<a name="ln459">		if (!le16_to_cpu(ie-&gt;length)) {</a>
<a name="ln460">			errno = EIO;</a>
<a name="ln461">			ntfs_log_error(&quot;Zero length index entry in inode %lld&quot;</a>
<a name="ln462">				       &quot;\n&quot;, (unsigned long long)dir_ni-&gt;mft_no);</a>
<a name="ln463">			goto close_err_out;</a>
<a name="ln464">		}</a>
<a name="ln465">		/*</a>
<a name="ln466">		 * Not a perfect match, need to do full blown collation so we</a>
<a name="ln467">		 * know which way in the B+tree we have to go.</a>
<a name="ln468">		 */</a>
<a name="ln469">		rc = ntfs_names_full_collate(uname, uname_len,</a>
<a name="ln470">				(ntfschar*)&amp;ie-&gt;key.file_name.file_name,</a>
<a name="ln471">				ie-&gt;key.file_name.file_name_length,</a>
<a name="ln472">				case_sensitivity, vol-&gt;upcase, vol-&gt;upcase_len);</a>
<a name="ln473">		/*</a>
<a name="ln474">		 * If uname collates before the name of the current entry, there</a>
<a name="ln475">		 * is definitely no such name in this index but we might need to</a>
<a name="ln476">		 * descend into the B+tree so we just break out of the loop.</a>
<a name="ln477">		 */</a>
<a name="ln478">		if (rc == -1)</a>
<a name="ln479">			break;</a>
<a name="ln480">		/* The names are not equal, continue the search. */</a>
<a name="ln481">		if (rc)</a>
<a name="ln482">			continue;</a>
<a name="ln483">		mref = le64_to_cpu(ie-&gt;indexed_file);</a>
<a name="ln484">		free(ia);</a>
<a name="ln485">		ntfs_attr_close(ia_na);</a>
<a name="ln486">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln487">		return mref;</a>
<a name="ln488">	}</a>
<a name="ln489">	/*</a>
<a name="ln490">	 * We have finished with this index buffer without success. Check for</a>
<a name="ln491">	 * the presence of a child node.</a>
<a name="ln492">	 */</a>
<a name="ln493">	if (ie-&gt;ie_flags &amp; INDEX_ENTRY_NODE) {</a>
<a name="ln494">		if ((ia-&gt;index.ih_flags &amp; NODE_MASK) == LEAF_NODE) {</a>
<a name="ln495">			ntfs_log_error(&quot;Index entry with child node found in a leaf &quot;</a>
<a name="ln496">					&quot;node in directory inode %lld.\n&quot;,</a>
<a name="ln497">					(unsigned long long)dir_ni-&gt;mft_no);</a>
<a name="ln498">			errno = EIO;</a>
<a name="ln499">			goto close_err_out;</a>
<a name="ln500">		}</a>
<a name="ln501">		/* Child node present, descend into it. */</a>
<a name="ln502">		vcn = sle64_to_cpup((sle64*)((u8*)ie + le16_to_cpu(ie-&gt;length) - 8));</a>
<a name="ln503">		if (vcn &gt;= 0)</a>
<a name="ln504">			goto descend_into_child_node;</a>
<a name="ln505">		ntfs_log_error(&quot;Negative child node vcn in directory inode &quot;</a>
<a name="ln506">			       &quot;0x%llx.\n&quot;, (unsigned long long)dir_ni-&gt;mft_no);</a>
<a name="ln507">		errno = EIO;</a>
<a name="ln508">		goto close_err_out;</a>
<a name="ln509">	}</a>
<a name="ln510">	free(ia);</a>
<a name="ln511">	ntfs_attr_close(ia_na);</a>
<a name="ln512">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln513">	/*</a>
<a name="ln514">	 * No child node present, return error code ENOENT, unless we have got</a>
<a name="ln515">	 * the mft reference of a matching name cached in mref in which case</a>
<a name="ln516">	 * return mref.</a>
<a name="ln517">	 */</a>
<a name="ln518">	if (mref)</a>
<a name="ln519">		return mref;</a>
<a name="ln520">	ntfs_log_debug(&quot;Entry not found.\n&quot;);</a>
<a name="ln521">	errno = ENOENT;</a>
<a name="ln522">	return -1;</a>
<a name="ln523">put_err_out:</a>
<a name="ln524">	eo = EIO;</a>
<a name="ln525">	ntfs_log_debug(&quot;Corrupt directory. Aborting lookup.\n&quot;);</a>
<a name="ln526">eo_put_err_out:</a>
<a name="ln527">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln528">	errno = eo;</a>
<a name="ln529">	return -1;</a>
<a name="ln530">close_err_out:</a>
<a name="ln531">	eo = errno;</a>
<a name="ln532">	free(ia);</a>
<a name="ln533">	ntfs_attr_close(ia_na);</a>
<a name="ln534">	goto eo_put_err_out;</a>
<a name="ln535">}</a>
<a name="ln536"> </a>
<a name="ln537">/*</a>
<a name="ln538"> *		Lookup a file in a directory from its UTF-8 name</a>
<a name="ln539"> *</a>
<a name="ln540"> *	The name is first fetched from cache if one is defined</a>
<a name="ln541"> *</a>
<a name="ln542"> *	Returns the inode number</a>
<a name="ln543"> *		or -1 if not possible (errno tells why)</a>
<a name="ln544"> */</a>
<a name="ln545"> </a>
<a name="ln546">u64 ntfs_inode_lookup_by_mbsname(ntfs_inode *dir_ni, const char *name)</a>
<a name="ln547">{</a>
<a name="ln548">	int uname_len;</a>
<a name="ln549">	ntfschar *uname = (ntfschar*)NULL;</a>
<a name="ln550">	u64 inum;</a>
<a name="ln551">	char *cached_name;</a>
<a name="ln552">	const char *const_name;</a>
<a name="ln553"> </a>
<a name="ln554">	if (!NVolCaseSensitive(dir_ni-&gt;vol)) {</a>
<a name="ln555">		cached_name = ntfs_uppercase_mbs(name,</a>
<a name="ln556">			dir_ni-&gt;vol-&gt;upcase, dir_ni-&gt;vol-&gt;upcase_len);</a>
<a name="ln557">		const_name = cached_name;</a>
<a name="ln558">	} else {</a>
<a name="ln559">		cached_name = (char*)NULL;</a>
<a name="ln560">		const_name = name;</a>
<a name="ln561">	}</a>
<a name="ln562">	if (const_name) {</a>
<a name="ln563">#if CACHE_LOOKUP_SIZE</a>
<a name="ln564"> </a>
<a name="ln565">		/*</a>
<a name="ln566">		 * fetch inode from cache</a>
<a name="ln567">		 */</a>
<a name="ln568"> </a>
<a name="ln569">		if (dir_ni-&gt;vol-&gt;lookup_cache) {</a>
<a name="ln570">			struct CACHED_LOOKUP item;</a>
<a name="ln571">			struct CACHED_LOOKUP *cached;</a>
<a name="ln572"> </a>
<a name="ln573">			item.name = const_name;</a>
<a name="ln574">			item.namesize = strlen(const_name) + 1;</a>
<a name="ln575">			item.parent = dir_ni-&gt;mft_no;</a>
<a name="ln576">			cached = (struct CACHED_LOOKUP*)ntfs_fetch_cache(</a>
<a name="ln577">					dir_ni-&gt;vol-&gt;lookup_cache,</a>
<a name="ln578">					GENERIC(&amp;item), lookup_cache_compare);</a>
<a name="ln579">			if (cached) {</a>
<a name="ln580">				inum = cached-&gt;inum;</a>
<a name="ln581">				if (inum == (u64)-1)</a>
<a name="ln582">					errno = ENOENT;</a>
<a name="ln583">			} else {</a>
<a name="ln584">				/* Generate unicode name. */</a>
<a name="ln585">				uname_len = ntfs_mbstoucs(name, &amp;uname);</a>
<a name="ln586">				if (uname_len &gt;= 0) {</a>
<a name="ln587">					inum = ntfs_inode_lookup_by_name(dir_ni,</a>
<a name="ln588">							uname, uname_len);</a>
<a name="ln589">					item.inum = inum;</a>
<a name="ln590">				/* enter into cache, even if not found */</a>
<a name="ln591">					ntfs_enter_cache(dir_ni-&gt;vol-&gt;lookup_cache,</a>
<a name="ln592">							GENERIC(&amp;item),</a>
<a name="ln593">							lookup_cache_compare);</a>
<a name="ln594">					free(uname);</a>
<a name="ln595">				} else</a>
<a name="ln596">					inum = (s64)-1;</a>
<a name="ln597">			}</a>
<a name="ln598">		} else</a>
<a name="ln599">#endif</a>
<a name="ln600">			{</a>
<a name="ln601">				/* Generate unicode name. */</a>
<a name="ln602">			uname_len = ntfs_mbstoucs(cached_name, &amp;uname);</a>
<a name="ln603">			if (uname_len &gt;= 0)</a>
<a name="ln604">				inum = ntfs_inode_lookup_by_name(dir_ni,</a>
<a name="ln605">						uname, uname_len);</a>
<a name="ln606">			else</a>
<a name="ln607">				inum = (s64)-1;</a>
<a name="ln608">		}</a>
<a name="ln609">		if (cached_name)</a>
<a name="ln610">			free(cached_name);</a>
<a name="ln611">	} else</a>
<a name="ln612">		inum = (s64)-1;</a>
<a name="ln613">	return (inum);</a>
<a name="ln614">}</a>
<a name="ln615"> </a>
<a name="ln616">/*</a>
<a name="ln617"> *		Update a cache lookup record when a name has been defined</a>
<a name="ln618"> *</a>
<a name="ln619"> *	The UTF-8 name is required</a>
<a name="ln620"> */</a>
<a name="ln621"> </a>
<a name="ln622">void ntfs_inode_update_mbsname(ntfs_inode *dir_ni, const char *name, u64 inum)</a>
<a name="ln623">{</a>
<a name="ln624">#if CACHE_LOOKUP_SIZE</a>
<a name="ln625">	struct CACHED_LOOKUP item;</a>
<a name="ln626">	struct CACHED_LOOKUP *cached;</a>
<a name="ln627">	char *cached_name;</a>
<a name="ln628"> </a>
<a name="ln629">	if (dir_ni-&gt;vol-&gt;lookup_cache) {</a>
<a name="ln630">		if (!NVolCaseSensitive(dir_ni-&gt;vol)) {</a>
<a name="ln631">			cached_name = ntfs_uppercase_mbs(name,</a>
<a name="ln632">				dir_ni-&gt;vol-&gt;upcase, dir_ni-&gt;vol-&gt;upcase_len);</a>
<a name="ln633">			item.name = cached_name;</a>
<a name="ln634">		} else {</a>
<a name="ln635">			cached_name = (char*)NULL;</a>
<a name="ln636">			item.name = name;</a>
<a name="ln637">		}</a>
<a name="ln638">		if (item.name) {</a>
<a name="ln639">			item.namesize = strlen(item.name) + 1;</a>
<a name="ln640">			item.parent = dir_ni-&gt;mft_no;</a>
<a name="ln641">			item.inum = inum;</a>
<a name="ln642">			cached = (struct CACHED_LOOKUP*)ntfs_enter_cache(</a>
<a name="ln643">					dir_ni-&gt;vol-&gt;lookup_cache,</a>
<a name="ln644">					GENERIC(&amp;item), lookup_cache_compare);</a>
<a name="ln645">			if (cached)</a>
<a name="ln646">				cached-&gt;inum = inum;</a>
<a name="ln647">			if (cached_name)</a>
<a name="ln648">				free(cached_name);</a>
<a name="ln649">		}</a>
<a name="ln650">	}</a>
<a name="ln651">#endif</a>
<a name="ln652">}</a>
<a name="ln653"> </a>
<a name="ln654">/**</a>
<a name="ln655"> * ntfs_pathname_to_inode - Find the inode which represents the given pathname</a>
<a name="ln656"> * @vol:       An ntfs volume obtained from ntfs_mount</a>
<a name="ln657"> * @parent:    A directory inode to begin the search (may be NULL)</a>
<a name="ln658"> * @pathname:  Pathname to be located</a>
<a name="ln659"> *</a>
<a name="ln660"> * Take an ASCII pathname and find the inode that represents it.  The function</a>
<a name="ln661"> * splits the path and then descends the directory tree.  If @parent is NULL,</a>
<a name="ln662"> * then the root directory '.' will be used as the base for the search.</a>
<a name="ln663"> *</a>
<a name="ln664"> * Return:  inode  Success, the pathname was valid</a>
<a name="ln665"> *	    NULL   Error, the pathname was invalid, or some other error occurred</a>
<a name="ln666"> */</a>
<a name="ln667">ntfs_inode *ntfs_pathname_to_inode(ntfs_volume *vol, ntfs_inode *parent,</a>
<a name="ln668">		const char *pathname)</a>
<a name="ln669">{</a>
<a name="ln670">	u64 inum;</a>
<a name="ln671">	int len, err = 0;</a>
<a name="ln672">	char *p, *q;</a>
<a name="ln673">	ntfs_inode *ni;</a>
<a name="ln674">	ntfs_inode *result = NULL;</a>
<a name="ln675">	ntfschar *unicode = NULL;</a>
<a name="ln676">	char *ascii = NULL;</a>
<a name="ln677">#if CACHE_INODE_SIZE</a>
<a name="ln678">	struct CACHED_INODE item;</a>
<a name="ln679">	struct CACHED_INODE *cached;</a>
<a name="ln680">	char *fullname;</a>
<a name="ln681">#endif</a>
<a name="ln682"> </a>
<a name="ln683">	if (!vol || !pathname) {</a>
<a name="ln684">		errno = EINVAL;</a>
<a name="ln685">		return NULL;</a>
<a name="ln686">	}</a>
<a name="ln687"> </a>
<a name="ln688">	ntfs_log_trace(&quot;path: '%s'\n&quot;, pathname);</a>
<a name="ln689"> </a>
<a name="ln690">	ascii = strdup(pathname);</a>
<a name="ln691">	if (!ascii) {</a>
<a name="ln692">		ntfs_log_error(&quot;Out of memory.\n&quot;);</a>
<a name="ln693">		err = ENOMEM;</a>
<a name="ln694">		goto out;</a>
<a name="ln695">	}</a>
<a name="ln696"> </a>
<a name="ln697">	p = ascii;</a>
<a name="ln698">	/* Remove leading /'s. */</a>
<a name="ln699">	while (p &amp;&amp; *p &amp;&amp; *p == PATH_SEP)</a>
<a name="ln700">		p++;</a>
<a name="ln701">#if CACHE_INODE_SIZE</a>
<a name="ln702">	fullname = p;</a>
<a name="ln703">	if (p[0] &amp;&amp; (p[strlen(p)-1] == PATH_SEP))</a>
<a name="ln704">		ntfs_log_error(&quot;Unnormalized path %s\n&quot;,ascii);</a>
<a name="ln705">#endif</a>
<a name="ln706">	if (parent) {</a>
<a name="ln707">		ni = parent;</a>
<a name="ln708">	} else {</a>
<a name="ln709">#if CACHE_INODE_SIZE</a>
<a name="ln710">			/*</a>
<a name="ln711">			 * fetch inode for full path from cache</a>
<a name="ln712">			 */</a>
<a name="ln713">		if (*fullname) {</a>
<a name="ln714">			item.pathname = fullname;</a>
<a name="ln715">			item.varsize = strlen(fullname) + 1;</a>
<a name="ln716">			cached = (struct CACHED_INODE*)ntfs_fetch_cache(</a>
<a name="ln717">				vol-&gt;xinode_cache, GENERIC(&amp;item),</a>
<a name="ln718">				inode_cache_compare);</a>
<a name="ln719">		} else</a>
<a name="ln720">			cached = (struct CACHED_INODE*)NULL;</a>
<a name="ln721">		if (cached) {</a>
<a name="ln722">			/*</a>
<a name="ln723">			 * return opened inode if found in cache</a>
<a name="ln724">			 */</a>
<a name="ln725">			inum = MREF(cached-&gt;inum);</a>
<a name="ln726">			ni = ntfs_inode_open(vol, inum);</a>
<a name="ln727">			if (!ni) {</a>
<a name="ln728">				ntfs_log_debug(&quot;Cannot open inode %llu: %s.\n&quot;,</a>
<a name="ln729">						(unsigned long long)inum, p);</a>
<a name="ln730">				err = EIO;</a>
<a name="ln731">			}</a>
<a name="ln732">			result = ni;</a>
<a name="ln733">			goto out;</a>
<a name="ln734">		}</a>
<a name="ln735">#endif</a>
<a name="ln736">		ni = ntfs_inode_open(vol, FILE_root);</a>
<a name="ln737">		if (!ni) {</a>
<a name="ln738">			ntfs_log_debug(&quot;Couldn't open the inode of the root &quot;</a>
<a name="ln739">					&quot;directory.\n&quot;);</a>
<a name="ln740">			err = EIO;</a>
<a name="ln741">			result = (ntfs_inode*)NULL;</a>
<a name="ln742">			goto out;</a>
<a name="ln743">		}</a>
<a name="ln744">	}</a>
<a name="ln745"> </a>
<a name="ln746">	while (p &amp;&amp; *p) {</a>
<a name="ln747">		/* Find the end of the first token. */</a>
<a name="ln748">		q = strchr(p, PATH_SEP);</a>
<a name="ln749">		if (q != NULL) {</a>
<a name="ln750">			*q = '\0';</a>
<a name="ln751">		}</a>
<a name="ln752">#if CACHE_INODE_SIZE</a>
<a name="ln753">			/*</a>
<a name="ln754">			 * fetch inode for partial path from cache</a>
<a name="ln755">			 */</a>
<a name="ln756">		cached = (struct CACHED_INODE*)NULL;</a>
<a name="ln757">		if (!parent) {</a>
<a name="ln758">			item.pathname = fullname;</a>
<a name="ln759">			item.varsize = strlen(fullname) + 1;</a>
<a name="ln760">			cached = (struct CACHED_INODE*)ntfs_fetch_cache(</a>
<a name="ln761">					vol-&gt;xinode_cache, GENERIC(&amp;item),</a>
<a name="ln762">					inode_cache_compare);</a>
<a name="ln763">			if (cached) {</a>
<a name="ln764">				inum = cached-&gt;inum;</a>
<a name="ln765">			}</a>
<a name="ln766">		}</a>
<a name="ln767">			/*</a>
<a name="ln768">			 * if not in cache, translate, search, then</a>
<a name="ln769">			 * insert into cache if found</a>
<a name="ln770">			 */</a>
<a name="ln771">		if (!cached) {</a>
<a name="ln772">			len = ntfs_mbstoucs(p, &amp;unicode);</a>
<a name="ln773">			if (len &lt; 0) {</a>
<a name="ln774">				ntfs_log_perror(&quot;Could not convert filename to Unicode:&quot;</a>
<a name="ln775">					&quot; '%s'&quot;, p);</a>
<a name="ln776">				err = errno;</a>
<a name="ln777">				goto close;</a>
<a name="ln778">			} else if (len &gt; NTFS_MAX_NAME_LEN) {</a>
<a name="ln779">				err = ENAMETOOLONG;</a>
<a name="ln780">				goto close;</a>
<a name="ln781">			}</a>
<a name="ln782">			inum = ntfs_inode_lookup_by_name(ni, unicode, len);</a>
<a name="ln783">			if (!parent &amp;&amp; (inum != (u64) -1)) {</a>
<a name="ln784">				item.inum = inum;</a>
<a name="ln785">				ntfs_enter_cache(vol-&gt;xinode_cache,</a>
<a name="ln786">						GENERIC(&amp;item),</a>
<a name="ln787">						inode_cache_compare);</a>
<a name="ln788">			}</a>
<a name="ln789">		}</a>
<a name="ln790">#else</a>
<a name="ln791">		len = ntfs_mbstoucs(p, &amp;unicode);</a>
<a name="ln792">		if (len &lt; 0) {</a>
<a name="ln793">			ntfs_log_perror(&quot;Could not convert filename to Unicode:&quot;</a>
<a name="ln794">					&quot; '%s'&quot;, p);</a>
<a name="ln795">			err = errno;</a>
<a name="ln796">			goto close;</a>
<a name="ln797">		} else if (len &gt; NTFS_MAX_NAME_LEN) {</a>
<a name="ln798">			err = ENAMETOOLONG;</a>
<a name="ln799">			goto close;</a>
<a name="ln800">		}</a>
<a name="ln801">		inum = ntfs_inode_lookup_by_name(ni, unicode, len);</a>
<a name="ln802">#endif</a>
<a name="ln803">		if (inum == (u64) -1) {</a>
<a name="ln804">			ntfs_log_debug(&quot;Couldn't find name '%s' in pathname &quot;</a>
<a name="ln805">					&quot;'%s'.\n&quot;, p, pathname);</a>
<a name="ln806">			err = ENOENT;</a>
<a name="ln807">			goto close;</a>
<a name="ln808">		}</a>
<a name="ln809"> </a>
<a name="ln810">		if (ni != parent)</a>
<a name="ln811">			if (ntfs_inode_close(ni)) {</a>
<a name="ln812">				err = errno;</a>
<a name="ln813">				goto out;</a>
<a name="ln814">			}</a>
<a name="ln815"> </a>
<a name="ln816">		inum = MREF(inum);</a>
<a name="ln817">		ni = ntfs_inode_open(vol, inum);</a>
<a name="ln818">		if (!ni) {</a>
<a name="ln819">			ntfs_log_debug(&quot;Cannot open inode %llu: %s.\n&quot;,</a>
<a name="ln820">					(unsigned long long)inum, p);</a>
<a name="ln821">			err = EIO;</a>
<a name="ln822">			goto close;</a>
<a name="ln823">		}</a>
<a name="ln824"> </a>
<a name="ln825">		free(unicode);</a>
<a name="ln826">		unicode = NULL;</a>
<a name="ln827"> </a>
<a name="ln828">		if (q) *q++ = PATH_SEP; /* JPA */</a>
<a name="ln829">		p = q;</a>
<a name="ln830">		while (p &amp;&amp; *p &amp;&amp; *p == PATH_SEP)</a>
<a name="ln831">			p++;</a>
<a name="ln832">	}</a>
<a name="ln833"> </a>
<a name="ln834">	result = ni;</a>
<a name="ln835">	ni = NULL;</a>
<a name="ln836">close:</a>
<a name="ln837">	if (ni &amp;&amp; (ni != parent))</a>
<a name="ln838">		if (ntfs_inode_close(ni) &amp;&amp; !err)</a>
<a name="ln839">			err = errno;</a>
<a name="ln840">out:</a>
<a name="ln841">	free(ascii);</a>
<a name="ln842">	free(unicode);</a>
<a name="ln843">	if (err)</a>
<a name="ln844">		errno = err;</a>
<a name="ln845">	return result;</a>
<a name="ln846">}</a>
<a name="ln847"> </a>
<a name="ln848">/*</a>
<a name="ln849"> * The little endian Unicode string &quot;..&quot; for ntfs_readdir().</a>
<a name="ln850"> */</a>
<a name="ln851">static const ntfschar dotdot[3] = { const_cpu_to_le16('.'),</a>
<a name="ln852">				   const_cpu_to_le16('.'),</a>
<a name="ln853">				   const_cpu_to_le16('\0') };</a>
<a name="ln854"> </a>
<a name="ln855">/*</a>
<a name="ln856"> * union index_union -</a>
<a name="ln857"> * More helpers for ntfs_readdir().</a>
<a name="ln858"> */</a>
<a name="ln859">typedef union {</a>
<a name="ln860">	INDEX_ROOT *ir;</a>
<a name="ln861">	INDEX_ALLOCATION *ia;</a>
<a name="ln862">} index_union __attribute__((__transparent_union__));</a>
<a name="ln863"> </a>
<a name="ln864">/**</a>
<a name="ln865"> * enum INDEX_TYPE -</a>
<a name="ln866"> * More helpers for ntfs_readdir().</a>
<a name="ln867"> */</a>
<a name="ln868">typedef enum {</a>
<a name="ln869">	INDEX_TYPE_ROOT,	/* index root */</a>
<a name="ln870">	INDEX_TYPE_ALLOCATION,	/* index allocation */</a>
<a name="ln871">} INDEX_TYPE;</a>
<a name="ln872"> </a>
<a name="ln873">/*</a>
<a name="ln874"> *		Decode Interix file types</a>
<a name="ln875"> *</a>
<a name="ln876"> *	Non-Interix types are returned as plain files, because a</a>
<a name="ln877"> *	Windows user may force patterns very similar to Interix,</a>
<a name="ln878"> *	and most metadata files have such similar patters.</a>
<a name="ln879"> */</a>
<a name="ln880"> </a>
<a name="ln881">u32 ntfs_interix_types(ntfs_inode *ni)</a>
<a name="ln882">{</a>
<a name="ln883">	ntfs_attr *na;</a>
<a name="ln884">	u32 dt_type;</a>
<a name="ln885">	le64 magic;</a>
<a name="ln886"> </a>
<a name="ln887">	dt_type = NTFS_DT_UNKNOWN;</a>
<a name="ln888">	na = ntfs_attr_open(ni, AT_DATA, NULL, 0);</a>
<a name="ln889">	if (na) {</a>
<a name="ln890">		/*</a>
<a name="ln891">		 * Unrecognized patterns (eg HID + SYST for metadata)</a>
<a name="ln892">		 * are plain files or directories</a>
<a name="ln893">		 */</a>
<a name="ln894">		if (ni-&gt;mrec-&gt;flags &amp; MFT_RECORD_IS_DIRECTORY)</a>
<a name="ln895">			dt_type = NTFS_DT_DIR;</a>
<a name="ln896">		else</a>
<a name="ln897">			dt_type = NTFS_DT_REG;</a>
<a name="ln898">		if (na-&gt;data_size &lt;= 1) {</a>
<a name="ln899">			if (!(ni-&gt;flags &amp; FILE_ATTR_HIDDEN))</a>
<a name="ln900">				dt_type = (na-&gt;data_size ?</a>
<a name="ln901">						NTFS_DT_SOCK : NTFS_DT_FIFO);</a>
<a name="ln902">		} else {</a>
<a name="ln903">			if ((na-&gt;data_size &gt;= (s64)sizeof(magic))</a>
<a name="ln904">			    &amp;&amp; (ntfs_attr_pread(na, 0, sizeof(magic), &amp;magic)</a>
<a name="ln905">				== sizeof(magic))) {</a>
<a name="ln906">				if (magic == INTX_SYMBOLIC_LINK)</a>
<a name="ln907">					dt_type = NTFS_DT_LNK;</a>
<a name="ln908">				else if (magic == INTX_BLOCK_DEVICE)</a>
<a name="ln909">					dt_type = NTFS_DT_BLK;</a>
<a name="ln910">				else if (magic == INTX_CHARACTER_DEVICE)</a>
<a name="ln911">					dt_type = NTFS_DT_CHR;</a>
<a name="ln912">			}</a>
<a name="ln913">		}</a>
<a name="ln914">		ntfs_attr_close(na);</a>
<a name="ln915">	}</a>
<a name="ln916">	return (dt_type);</a>
<a name="ln917">}</a>
<a name="ln918"> </a>
<a name="ln919">/*</a>
<a name="ln920"> *		Decode file types</a>
<a name="ln921"> *</a>
<a name="ln922"> *	Better only use for Interix types and junctions,</a>
<a name="ln923"> *	unneeded complexity when used for plain files or directories</a>
<a name="ln924"> *</a>
<a name="ln925"> *	Error cases are logged and returned as unknown.</a>
<a name="ln926"> */</a>
<a name="ln927"> </a>
<a name="ln928">static u32 ntfs_dir_entry_type(ntfs_inode *dir_ni, MFT_REF mref,</a>
<a name="ln929">					FILE_ATTR_FLAGS attributes)</a>
<a name="ln930">{</a>
<a name="ln931">	ntfs_inode *ni;</a>
<a name="ln932">	u32 dt_type;</a>
<a name="ln933"> </a>
<a name="ln934">	dt_type = NTFS_DT_UNKNOWN;</a>
<a name="ln935">	ni = ntfs_inode_open(dir_ni-&gt;vol, mref);</a>
<a name="ln936">	if (ni) {</a>
<a name="ln937">		if ((attributes &amp; FILE_ATTR_REPARSE_POINT)</a>
<a name="ln938">		    &amp;&amp; ntfs_possible_symlink(ni))</a>
<a name="ln939">			dt_type = NTFS_DT_LNK;</a>
<a name="ln940">		else</a>
<a name="ln941">			if ((attributes &amp; FILE_ATTR_SYSTEM)</a>
<a name="ln942">			   &amp;&amp; !(attributes &amp; FILE_ATTR_I30_INDEX_PRESENT))</a>
<a name="ln943">				dt_type = ntfs_interix_types(ni);</a>
<a name="ln944">			else</a>
<a name="ln945">				dt_type = (attributes</a>
<a name="ln946">						&amp; FILE_ATTR_I30_INDEX_PRESENT</a>
<a name="ln947">					? NTFS_DT_DIR : NTFS_DT_REG);</a>
<a name="ln948">		if (ntfs_inode_close(ni)) {</a>
<a name="ln949">				 /* anything special worth doing ? */</a>
<a name="ln950">			ntfs_log_error(&quot;Failed to close inode %lld\n&quot;,</a>
<a name="ln951">				(long long)MREF(mref));</a>
<a name="ln952">		}</a>
<a name="ln953">	}</a>
<a name="ln954">	if (dt_type == NTFS_DT_UNKNOWN)</a>
<a name="ln955">		ntfs_log_error(&quot;Could not decode the type of inode %lld\n&quot;,</a>
<a name="ln956">				(long long)MREF(mref));</a>
<a name="ln957">	return (dt_type);</a>
<a name="ln958">}</a>
<a name="ln959"> </a>
<a name="ln960">/**</a>
<a name="ln961"> * ntfs_filldir - ntfs specific filldir method</a>
<a name="ln962"> * @dir_ni:	ntfs inode of current directory</a>
<a name="ln963"> * @pos:	current position in directory</a>
<a name="ln964"> * @ivcn_bits:	log(2) of index vcn size</a>
<a name="ln965"> * @index_type:	specifies whether @iu is an index root or an index allocation</a>
<a name="ln966"> * @iu:		index root or index block to which @ie belongs</a>
<a name="ln967"> * @ie:		current index entry</a>
<a name="ln968"> * @dirent:	context for filldir callback supplied by the caller</a>
<a name="ln969"> * @filldir:	filldir callback supplied by the caller</a>
<a name="ln970"> *</a>
<a name="ln971"> * Pass information specifying the current directory entry @ie to the @filldir</a>
<a name="ln972"> * callback.</a>
<a name="ln973"> */</a>
<a name="ln974">static int ntfs_filldir(ntfs_inode *dir_ni, s64 *pos, u8 ivcn_bits,</a>
<a name="ln975">		const INDEX_TYPE index_type, index_union iu, INDEX_ENTRY *ie,</a>
<a name="ln976">		void *dirent, ntfs_filldir_t filldir)</a>
<a name="ln977">{</a>
<a name="ln978">	FILE_NAME_ATTR *fn = &amp;ie-&gt;key.file_name;</a>
<a name="ln979">	unsigned dt_type;</a>
<a name="ln980">	BOOL metadata;</a>
<a name="ln981">	ntfschar *loname;</a>
<a name="ln982">	int res;</a>
<a name="ln983">	MFT_REF mref;</a>
<a name="ln984"> </a>
<a name="ln985">	ntfs_log_trace(&quot;Entering.\n&quot;);</a>
<a name="ln986"> </a>
<a name="ln987">	/* Advance the position even if going to skip the entry. */</a>
<a name="ln988">	if (index_type == INDEX_TYPE_ALLOCATION)</a>
<a name="ln989">		*pos = (u8*)ie - (u8*)iu.ia + (sle64_to_cpu(</a>
<a name="ln990">				iu.ia-&gt;index_block_vcn) &lt;&lt; ivcn_bits) +</a>
<a name="ln991">				dir_ni-&gt;vol-&gt;mft_record_size;</a>
<a name="ln992">	else /* if (index_type == INDEX_TYPE_ROOT) */</a>
<a name="ln993">		*pos = (u8*)ie - (u8*)iu.ir;</a>
<a name="ln994">	mref = le64_to_cpu(ie-&gt;indexed_file);</a>
<a name="ln995">	metadata = (MREF(mref) != FILE_root) &amp;&amp; (MREF(mref) &lt; FILE_first_user);</a>
<a name="ln996">	/* Skip root directory self reference entry. */</a>
<a name="ln997">	if (MREF_LE(ie-&gt;indexed_file) == FILE_root)</a>
<a name="ln998">		return 0;</a>
<a name="ln999">	if ((ie-&gt;key.file_name.file_attributes</a>
<a name="ln1000">		     &amp; (FILE_ATTR_REPARSE_POINT | FILE_ATTR_SYSTEM))</a>
<a name="ln1001">	    &amp;&amp; !metadata)</a>
<a name="ln1002">		dt_type = ntfs_dir_entry_type(dir_ni, mref,</a>
<a name="ln1003">					ie-&gt;key.file_name.file_attributes);</a>
<a name="ln1004">	else if (ie-&gt;key.file_name.file_attributes</a>
<a name="ln1005">		     &amp; FILE_ATTR_I30_INDEX_PRESENT)</a>
<a name="ln1006">		dt_type = NTFS_DT_DIR;</a>
<a name="ln1007">	else</a>
<a name="ln1008">		dt_type = NTFS_DT_REG;</a>
<a name="ln1009"> </a>
<a name="ln1010">		/* return metadata files and hidden files if requested */</a>
<a name="ln1011">        if ((!metadata &amp;&amp; (NVolShowHidFiles(dir_ni-&gt;vol)</a>
<a name="ln1012">				|| !(fn-&gt;file_attributes &amp; FILE_ATTR_HIDDEN)))</a>
<a name="ln1013">            || (NVolShowSysFiles(dir_ni-&gt;vol) &amp;&amp; (NVolShowHidFiles(dir_ni-&gt;vol)</a>
<a name="ln1014">				|| metadata))) {</a>
<a name="ln1015">		if (NVolCaseSensitive(dir_ni-&gt;vol)) {</a>
<a name="ln1016">			res = filldir(dirent, fn-&gt;file_name,</a>
<a name="ln1017">					fn-&gt;file_name_length,</a>
<a name="ln1018">					fn-&gt;file_name_type, *pos,</a>
<a name="ln1019">					mref, dt_type);</a>
<a name="ln1020">		} else {</a>
<a name="ln1021">			loname = (ntfschar*)ntfs_malloc(2*fn-&gt;file_name_length);</a>
<a name="ln1022">			if (loname) {</a>
<a name="ln1023">				memcpy(loname, fn-&gt;file_name,</a>
<a name="ln1024">					2*fn-&gt;file_name_length);</a>
<a name="ln1025">				ntfs_name_locase(loname, fn-&gt;file_name_length,</a>
<a name="ln1026">					dir_ni-&gt;vol-&gt;locase,</a>
<a name="ln1027">					dir_ni-&gt;vol-&gt;upcase_len);</a>
<a name="ln1028">				res = filldir(dirent, loname,</a>
<a name="ln1029">					fn-&gt;file_name_length,</a>
<a name="ln1030">					fn-&gt;file_name_type, *pos,</a>
<a name="ln1031">					mref, dt_type);</a>
<a name="ln1032">				free(loname);</a>
<a name="ln1033">			} else</a>
<a name="ln1034">				res = -1;</a>
<a name="ln1035">		}</a>
<a name="ln1036">	} else</a>
<a name="ln1037">		res = 0;</a>
<a name="ln1038">	return (res);</a>
<a name="ln1039">}</a>
<a name="ln1040"> </a>
<a name="ln1041">/**</a>
<a name="ln1042"> * ntfs_mft_get_parent_ref - find mft reference of parent directory of an inode</a>
<a name="ln1043"> * @ni:		ntfs inode whose parent directory to find</a>
<a name="ln1044"> *</a>
<a name="ln1045"> * Find the parent directory of the ntfs inode @ni. To do this, find the first</a>
<a name="ln1046"> * file name attribute in the mft record of @ni and return the parent mft</a>
<a name="ln1047"> * reference from that.</a>
<a name="ln1048"> *</a>
<a name="ln1049"> * Note this only makes sense for directories, since files can be hard linked</a>
<a name="ln1050"> * from multiple directories and there is no way for us to tell which one is</a>
<a name="ln1051"> * being looked for.</a>
<a name="ln1052"> *</a>
<a name="ln1053"> * Technically directories can have hard links, too, but we consider that as</a>
<a name="ln1054"> * illegal as Linux/UNIX do not support directory hard links.</a>
<a name="ln1055"> *</a>
<a name="ln1056"> * Return the mft reference of the parent directory on success or -1 on error</a>
<a name="ln1057"> * with errno set to the error code.</a>
<a name="ln1058"> */</a>
<a name="ln1059">#ifndef __HAIKU__</a>
<a name="ln1060">static</a>
<a name="ln1061">#endif</a>
<a name="ln1062">MFT_REF ntfs_mft_get_parent_ref(ntfs_inode *ni)</a>
<a name="ln1063">{</a>
<a name="ln1064">	MFT_REF mref;</a>
<a name="ln1065">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln1066">	FILE_NAME_ATTR *fn;</a>
<a name="ln1067">	int eo;</a>
<a name="ln1068"> </a>
<a name="ln1069">	ntfs_log_trace(&quot;Entering.\n&quot;);</a>
<a name="ln1070"> </a>
<a name="ln1071">	if (!ni) {</a>
<a name="ln1072">		errno = EINVAL;</a>
<a name="ln1073">		return ERR_MREF(-1);</a>
<a name="ln1074">	}</a>
<a name="ln1075"> </a>
<a name="ln1076">	ctx = ntfs_attr_get_search_ctx(ni, NULL);</a>
<a name="ln1077">	if (!ctx)</a>
<a name="ln1078">		return ERR_MREF(-1);</a>
<a name="ln1079">	if (ntfs_attr_lookup(AT_FILE_NAME, AT_UNNAMED, 0, 0, 0, NULL, 0, ctx)) {</a>
<a name="ln1080">		ntfs_log_error(&quot;No file name found in inode %lld\n&quot;,</a>
<a name="ln1081">			       (unsigned long long)ni-&gt;mft_no);</a>
<a name="ln1082">		goto err_out;</a>
<a name="ln1083">	}</a>
<a name="ln1084">	if (ctx-&gt;attr-&gt;non_resident) {</a>
<a name="ln1085">		ntfs_log_error(&quot;File name attribute must be resident (inode &quot;</a>
<a name="ln1086">			       &quot;%lld)\n&quot;, (unsigned long long)ni-&gt;mft_no);</a>
<a name="ln1087">		goto io_err_out;</a>
<a name="ln1088">	}</a>
<a name="ln1089">	fn = (FILE_NAME_ATTR*)((u8*)ctx-&gt;attr +</a>
<a name="ln1090">			le16_to_cpu(ctx-&gt;attr-&gt;value_offset));</a>
<a name="ln1091">	if ((u8*)fn +	le32_to_cpu(ctx-&gt;attr-&gt;value_length) &gt;</a>
<a name="ln1092">			(u8*)ctx-&gt;attr + le32_to_cpu(ctx-&gt;attr-&gt;length)) {</a>
<a name="ln1093">		ntfs_log_error(&quot;Corrupt file name attribute in inode %lld.\n&quot;,</a>
<a name="ln1094">			       (unsigned long long)ni-&gt;mft_no);</a>
<a name="ln1095">		goto io_err_out;</a>
<a name="ln1096">	}</a>
<a name="ln1097">	mref = le64_to_cpu(fn-&gt;parent_directory);</a>
<a name="ln1098">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1099">	return mref;</a>
<a name="ln1100">io_err_out:</a>
<a name="ln1101">	errno = EIO;</a>
<a name="ln1102">err_out:</a>
<a name="ln1103">	eo = errno;</a>
<a name="ln1104">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1105">	errno = eo;</a>
<a name="ln1106">	return ERR_MREF(-1);</a>
<a name="ln1107">}</a>
<a name="ln1108"> </a>
<a name="ln1109">/**</a>
<a name="ln1110"> * ntfs_readdir - read the contents of an ntfs directory</a>
<a name="ln1111"> * @dir_ni:	ntfs inode of current directory</a>
<a name="ln1112"> * @pos:	current position in directory</a>
<a name="ln1113"> * @dirent:	context for filldir callback supplied by the caller</a>
<a name="ln1114"> * @filldir:	filldir callback supplied by the caller</a>
<a name="ln1115"> *</a>
<a name="ln1116"> * Parse the index root and the index blocks that are marked in use in the</a>
<a name="ln1117"> * index bitmap and hand each found directory entry to the @filldir callback</a>
<a name="ln1118"> * supplied by the caller.</a>
<a name="ln1119"> *</a>
<a name="ln1120"> * Return 0 on success or -1 on error with errno set to the error code.</a>
<a name="ln1121"> *</a>
<a name="ln1122"> * Note: Index blocks are parsed in ascending vcn order, from which follows</a>
<a name="ln1123"> * that the directory entries are not returned sorted.</a>
<a name="ln1124"> */</a>
<a name="ln1125">int ntfs_readdir(ntfs_inode *dir_ni, s64 *pos,</a>
<a name="ln1126">		void *dirent, ntfs_filldir_t filldir)</a>
<a name="ln1127">{</a>
<a name="ln1128">	s64 i_size, br, ia_pos, bmp_pos, ia_start;</a>
<a name="ln1129">	ntfs_volume *vol;</a>
<a name="ln1130">	ntfs_attr *ia_na, *bmp_na = NULL;</a>
<a name="ln1131">	ntfs_attr_search_ctx *ctx = NULL;</a>
<a name="ln1132">	u8 *index_end, *bmp = NULL;</a>
<a name="ln1133">	INDEX_ROOT *ir;</a>
<a name="ln1134">	INDEX_ENTRY *ie;</a>
<a name="ln1135">	INDEX_ALLOCATION *ia = NULL;</a>
<a name="ln1136">	int rc, ir_pos, bmp_buf_size, bmp_buf_pos, eo;</a>
<a name="ln1137">	u32 index_block_size;</a>
<a name="ln1138">	u8 index_block_size_bits, index_vcn_size_bits;</a>
<a name="ln1139"> </a>
<a name="ln1140">	ntfs_log_trace(&quot;Entering.\n&quot;);</a>
<a name="ln1141"> </a>
<a name="ln1142">	if (!dir_ni || !pos || !filldir) {</a>
<a name="ln1143">		errno = EINVAL;</a>
<a name="ln1144">		return -1;</a>
<a name="ln1145">	}</a>
<a name="ln1146"> </a>
<a name="ln1147">	if (!(dir_ni-&gt;mrec-&gt;flags &amp; MFT_RECORD_IS_DIRECTORY)) {</a>
<a name="ln1148">		errno = ENOTDIR;</a>
<a name="ln1149">		return -1;</a>
<a name="ln1150">	}</a>
<a name="ln1151"> </a>
<a name="ln1152">	vol = dir_ni-&gt;vol;</a>
<a name="ln1153"> </a>
<a name="ln1154">	ntfs_log_trace(&quot;Entering for inode %lld, *pos 0x%llx.\n&quot;,</a>
<a name="ln1155">			(unsigned long long)dir_ni-&gt;mft_no, (long long)*pos);</a>
<a name="ln1156"> </a>
<a name="ln1157">	/* Open the index allocation attribute. */</a>
<a name="ln1158">	ia_na = ntfs_attr_open(dir_ni, AT_INDEX_ALLOCATION, NTFS_INDEX_I30, 4);</a>
<a name="ln1159">	if (!ia_na) {</a>
<a name="ln1160">		if (errno != ENOENT) {</a>
<a name="ln1161">			ntfs_log_perror(&quot;Failed to open index allocation attribute. &quot;</a>
<a name="ln1162">				&quot;Directory inode %lld is corrupt or bug&quot;,</a>
<a name="ln1163">				(unsigned long long)dir_ni-&gt;mft_no);</a>
<a name="ln1164">			return -1;</a>
<a name="ln1165">		}</a>
<a name="ln1166">		i_size = 0;</a>
<a name="ln1167">	} else</a>
<a name="ln1168">		i_size = ia_na-&gt;data_size;</a>
<a name="ln1169"> </a>
<a name="ln1170">	rc = 0;</a>
<a name="ln1171"> </a>
<a name="ln1172">	/* Are we at end of dir yet? */</a>
<a name="ln1173">	if (*pos &gt;= i_size + vol-&gt;mft_record_size)</a>
<a name="ln1174">		goto done;</a>
<a name="ln1175"> </a>
<a name="ln1176">	/* Emulate . and .. for all directories. */</a>
<a name="ln1177">	if (!*pos) {</a>
<a name="ln1178">		rc = filldir(dirent, dotdot, 1, FILE_NAME_POSIX, *pos,</a>
<a name="ln1179">				MK_MREF(dir_ni-&gt;mft_no,</a>
<a name="ln1180">				le16_to_cpu(dir_ni-&gt;mrec-&gt;sequence_number)),</a>
<a name="ln1181">				NTFS_DT_DIR);</a>
<a name="ln1182">		if (rc)</a>
<a name="ln1183">			goto err_out;</a>
<a name="ln1184">		++*pos;</a>
<a name="ln1185">	}</a>
<a name="ln1186">	if (*pos == 1) {</a>
<a name="ln1187">		MFT_REF parent_mref;</a>
<a name="ln1188"> </a>
<a name="ln1189">		parent_mref = ntfs_mft_get_parent_ref(dir_ni);</a>
<a name="ln1190">		if (parent_mref == ERR_MREF(-1)) {</a>
<a name="ln1191">			ntfs_log_perror(&quot;Parent directory not found&quot;);</a>
<a name="ln1192">			goto dir_err_out;</a>
<a name="ln1193">		}</a>
<a name="ln1194"> </a>
<a name="ln1195">		rc = filldir(dirent, dotdot, 2, FILE_NAME_POSIX, *pos,</a>
<a name="ln1196">				parent_mref, NTFS_DT_DIR);</a>
<a name="ln1197">		if (rc)</a>
<a name="ln1198">			goto err_out;</a>
<a name="ln1199">		++*pos;</a>
<a name="ln1200">	}</a>
<a name="ln1201"> </a>
<a name="ln1202">	ctx = ntfs_attr_get_search_ctx(dir_ni, NULL);</a>
<a name="ln1203">	if (!ctx)</a>
<a name="ln1204">		goto err_out;</a>
<a name="ln1205"> </a>
<a name="ln1206">	/* Get the offset into the index root attribute. */</a>
<a name="ln1207">	ir_pos = (int)*pos;</a>
<a name="ln1208">	/* Find the index root attribute in the mft record. */</a>
<a name="ln1209">	if (ntfs_attr_lookup(AT_INDEX_ROOT, NTFS_INDEX_I30, 4, CASE_SENSITIVE, 0, NULL,</a>
<a name="ln1210">			0, ctx)) {</a>
<a name="ln1211">		ntfs_log_perror(&quot;Index root attribute missing in directory inode &quot;</a>
<a name="ln1212">				&quot;%lld&quot;, (unsigned long long)dir_ni-&gt;mft_no);</a>
<a name="ln1213">		goto dir_err_out;</a>
<a name="ln1214">	}</a>
<a name="ln1215">	/* Get to the index root value. */</a>
<a name="ln1216">	ir = (INDEX_ROOT*)((u8*)ctx-&gt;attr +</a>
<a name="ln1217">			le16_to_cpu(ctx-&gt;attr-&gt;value_offset));</a>
<a name="ln1218"> </a>
<a name="ln1219">	/* Determine the size of a vcn in the directory index. */</a>
<a name="ln1220">	index_block_size = le32_to_cpu(ir-&gt;index_block_size);</a>
<a name="ln1221">	if (index_block_size &lt; NTFS_BLOCK_SIZE ||</a>
<a name="ln1222">			index_block_size &amp; (index_block_size - 1)) {</a>
<a name="ln1223">		ntfs_log_error(&quot;Index block size %u is invalid.\n&quot;,</a>
<a name="ln1224">				(unsigned)index_block_size);</a>
<a name="ln1225">		goto dir_err_out;</a>
<a name="ln1226">	}</a>
<a name="ln1227">	index_block_size_bits = ffs(index_block_size) - 1;</a>
<a name="ln1228">	if (vol-&gt;cluster_size &lt;= index_block_size) {</a>
<a name="ln1229">		index_vcn_size_bits = vol-&gt;cluster_size_bits;</a>
<a name="ln1230">	} else {</a>
<a name="ln1231">		index_vcn_size_bits = NTFS_BLOCK_SIZE_BITS;</a>
<a name="ln1232">	}</a>
<a name="ln1233"> </a>
<a name="ln1234">	/* Are we jumping straight into the index allocation attribute? */</a>
<a name="ln1235">	if (*pos &gt;= vol-&gt;mft_record_size) {</a>
<a name="ln1236">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1237">		ctx = NULL;</a>
<a name="ln1238">		goto skip_index_root;</a>
<a name="ln1239">	}</a>
<a name="ln1240"> </a>
<a name="ln1241">	index_end = (u8*)&amp;ir-&gt;index + le32_to_cpu(ir-&gt;index.index_length);</a>
<a name="ln1242">	/* The first index entry. */</a>
<a name="ln1243">	ie = (INDEX_ENTRY*)((u8*)&amp;ir-&gt;index +</a>
<a name="ln1244">			le32_to_cpu(ir-&gt;index.entries_offset));</a>
<a name="ln1245">	/*</a>
<a name="ln1246">	 * Loop until we exceed valid memory (corruption case) or until we</a>
<a name="ln1247">	 * reach the last entry or until filldir tells us it has had enough</a>
<a name="ln1248">	 * or signals an error (both covered by the rc test).</a>
<a name="ln1249">	 */</a>
<a name="ln1250">	for (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie-&gt;length))) {</a>
<a name="ln1251">		ntfs_log_debug(&quot;In index root, offset %d.\n&quot;, (int)((u8*)ie - (u8*)ir));</a>
<a name="ln1252">		/* Bounds checks. */</a>
<a name="ln1253">		if ((u8*)ie &lt; (u8*)ctx-&gt;mrec || (u8*)ie +</a>
<a name="ln1254">				sizeof(INDEX_ENTRY_HEADER) &gt; index_end ||</a>
<a name="ln1255">				(u8*)ie + le16_to_cpu(ie-&gt;key_length) &gt;</a>
<a name="ln1256">				index_end)</a>
<a name="ln1257">			goto dir_err_out;</a>
<a name="ln1258">		/* The last entry cannot contain a name. */</a>
<a name="ln1259">		if (ie-&gt;ie_flags &amp; INDEX_ENTRY_END)</a>
<a name="ln1260">			break;</a>
<a name="ln1261"> </a>
<a name="ln1262">		if (!le16_to_cpu(ie-&gt;length))</a>
<a name="ln1263">			goto dir_err_out;</a>
<a name="ln1264"> </a>
<a name="ln1265">		/* Skip index root entry if continuing previous readdir. */</a>
<a name="ln1266">		if (ir_pos &gt; (u8*)ie - (u8*)ir)</a>
<a name="ln1267">			continue;</a>
<a name="ln1268">		/*</a>
<a name="ln1269">		 * Submit the directory entry to ntfs_filldir(), which will</a>
<a name="ln1270">		 * invoke the filldir() callback as appropriate.</a>
<a name="ln1271">		 */</a>
<a name="ln1272">		rc = ntfs_filldir(dir_ni, pos, index_vcn_size_bits,</a>
<a name="ln1273">				INDEX_TYPE_ROOT, ir, ie, dirent, filldir);</a>
<a name="ln1274">		if (rc) {</a>
<a name="ln1275">			ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1276">			ctx = NULL;</a>
<a name="ln1277">			goto err_out;</a>
<a name="ln1278">		}</a>
<a name="ln1279">	}</a>
<a name="ln1280">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1281">	ctx = NULL;</a>
<a name="ln1282"> </a>
<a name="ln1283">	/* If there is no index allocation attribute we are finished. */</a>
<a name="ln1284">	if (!ia_na)</a>
<a name="ln1285">		goto EOD;</a>
<a name="ln1286"> </a>
<a name="ln1287">	/* Advance *pos to the beginning of the index allocation. */</a>
<a name="ln1288">	*pos = vol-&gt;mft_record_size;</a>
<a name="ln1289"> </a>
<a name="ln1290">skip_index_root:</a>
<a name="ln1291"> </a>
<a name="ln1292">	if (!ia_na)</a>
<a name="ln1293">		goto done;</a>
<a name="ln1294"> </a>
<a name="ln1295">	/* Allocate a buffer for the current index block. */</a>
<a name="ln1296">	ia = ntfs_malloc(index_block_size);</a>
<a name="ln1297">	if (!ia)</a>
<a name="ln1298">		goto err_out;</a>
<a name="ln1299"> </a>
<a name="ln1300">	bmp_na = ntfs_attr_open(dir_ni, AT_BITMAP, NTFS_INDEX_I30, 4);</a>
<a name="ln1301">	if (!bmp_na) {</a>
<a name="ln1302">		ntfs_log_perror(&quot;Failed to open index bitmap attribute&quot;);</a>
<a name="ln1303">		goto dir_err_out;</a>
<a name="ln1304">	}</a>
<a name="ln1305"> </a>
<a name="ln1306">	/* Get the offset into the index allocation attribute. */</a>
<a name="ln1307">	ia_pos = *pos - vol-&gt;mft_record_size;</a>
<a name="ln1308"> </a>
<a name="ln1309">	bmp_pos = ia_pos &gt;&gt; index_block_size_bits;</a>
<a name="ln1310">	if (bmp_pos &gt;&gt; 3 &gt;= bmp_na-&gt;data_size) {</a>
<a name="ln1311">		ntfs_log_error(&quot;Current index position exceeds index bitmap &quot;</a>
<a name="ln1312">				&quot;size.\n&quot;);</a>
<a name="ln1313">		goto dir_err_out;</a>
<a name="ln1314">	}</a>
<a name="ln1315"> </a>
<a name="ln1316">	bmp_buf_size = min(bmp_na-&gt;data_size - (bmp_pos &gt;&gt; 3), 4096);</a>
<a name="ln1317">	bmp = ntfs_malloc(bmp_buf_size);</a>
<a name="ln1318">	if (!bmp)</a>
<a name="ln1319">		goto err_out;</a>
<a name="ln1320"> </a>
<a name="ln1321">	br = ntfs_attr_pread(bmp_na, bmp_pos &gt;&gt; 3, bmp_buf_size, bmp);</a>
<a name="ln1322">	if (br != bmp_buf_size) {</a>
<a name="ln1323">		if (br != -1)</a>
<a name="ln1324">			errno = EIO;</a>
<a name="ln1325">		ntfs_log_perror(&quot;Failed to read from index bitmap attribute&quot;);</a>
<a name="ln1326">		goto err_out;</a>
<a name="ln1327">	}</a>
<a name="ln1328"> </a>
<a name="ln1329">	bmp_buf_pos = 0;</a>
<a name="ln1330">	/* If the index block is not in use find the next one that is. */</a>
<a name="ln1331">	while (!(bmp[bmp_buf_pos &gt;&gt; 3] &amp; (1 &lt;&lt; (bmp_buf_pos &amp; 7)))) {</a>
<a name="ln1332">find_next_index_buffer:</a>
<a name="ln1333">		bmp_pos++;</a>
<a name="ln1334">		bmp_buf_pos++;</a>
<a name="ln1335">		/* If we have reached the end of the bitmap, we are done. */</a>
<a name="ln1336">		if (bmp_pos &gt;&gt; 3 &gt;= bmp_na-&gt;data_size)</a>
<a name="ln1337">			goto EOD;</a>
<a name="ln1338">		ia_pos = bmp_pos &lt;&lt; index_block_size_bits;</a>
<a name="ln1339">		if (bmp_buf_pos &gt;&gt; 3 &lt; bmp_buf_size)</a>
<a name="ln1340">			continue;</a>
<a name="ln1341">		/* Read next chunk from the index bitmap. */</a>
<a name="ln1342">		bmp_buf_pos = 0;</a>
<a name="ln1343">		if ((bmp_pos &gt;&gt; 3) + bmp_buf_size &gt; bmp_na-&gt;data_size)</a>
<a name="ln1344">			bmp_buf_size = bmp_na-&gt;data_size - (bmp_pos &gt;&gt; 3);</a>
<a name="ln1345">		br = ntfs_attr_pread(bmp_na, bmp_pos &gt;&gt; 3, bmp_buf_size, bmp);</a>
<a name="ln1346">		if (br != bmp_buf_size) {</a>
<a name="ln1347">			if (br != -1)</a>
<a name="ln1348">				errno = EIO;</a>
<a name="ln1349">			ntfs_log_perror(&quot;Failed to read from index bitmap attribute&quot;);</a>
<a name="ln1350">			goto err_out;</a>
<a name="ln1351">		}</a>
<a name="ln1352">	}</a>
<a name="ln1353"> </a>
<a name="ln1354">	ntfs_log_debug(&quot;Handling index block 0x%llx.\n&quot;, (long long)bmp_pos);</a>
<a name="ln1355"> </a>
<a name="ln1356">	/* Read the index block starting at bmp_pos. */</a>
<a name="ln1357">	br = ntfs_attr_mst_pread(ia_na, bmp_pos &lt;&lt; index_block_size_bits, 1,</a>
<a name="ln1358">			index_block_size, ia);</a>
<a name="ln1359">	if (br != 1) {</a>
<a name="ln1360">		if (br != -1)</a>
<a name="ln1361">			errno = EIO;</a>
<a name="ln1362">		ntfs_log_perror(&quot;Failed to read index block&quot;);</a>
<a name="ln1363">		goto err_out;</a>
<a name="ln1364">	}</a>
<a name="ln1365"> </a>
<a name="ln1366">	ia_start = ia_pos &amp; ~(s64)(index_block_size - 1);</a>
<a name="ln1367">	if (sle64_to_cpu(ia-&gt;index_block_vcn) != ia_start &gt;&gt;</a>
<a name="ln1368">			index_vcn_size_bits) {</a>
<a name="ln1369">		ntfs_log_error(&quot;Actual VCN (0x%llx) of index buffer is different &quot;</a>
<a name="ln1370">				&quot;from expected VCN (0x%llx) in inode 0x%llx.\n&quot;,</a>
<a name="ln1371">				(long long)sle64_to_cpu(ia-&gt;index_block_vcn),</a>
<a name="ln1372">				(long long)ia_start &gt;&gt; index_vcn_size_bits,</a>
<a name="ln1373">				(unsigned long long)dir_ni-&gt;mft_no);</a>
<a name="ln1374">		goto dir_err_out;</a>
<a name="ln1375">	}</a>
<a name="ln1376">	if (le32_to_cpu(ia-&gt;index.allocated_size) + 0x18 != index_block_size) {</a>
<a name="ln1377">		ntfs_log_error(&quot;Index buffer (VCN 0x%llx) of directory inode %lld &quot;</a>
<a name="ln1378">				&quot;has a size (%u) differing from the directory &quot;</a>
<a name="ln1379">				&quot;specified size (%u).\n&quot;, (long long)ia_start &gt;&gt;</a>
<a name="ln1380">				index_vcn_size_bits,</a>
<a name="ln1381">				(unsigned long long)dir_ni-&gt;mft_no,</a>
<a name="ln1382">				(unsigned) le32_to_cpu(ia-&gt;index.allocated_size)</a>
<a name="ln1383">				+ 0x18, (unsigned)index_block_size);</a>
<a name="ln1384">		goto dir_err_out;</a>
<a name="ln1385">	}</a>
<a name="ln1386">	index_end = (u8*)&amp;ia-&gt;index + le32_to_cpu(ia-&gt;index.index_length);</a>
<a name="ln1387">	if (index_end &gt; (u8*)ia + index_block_size) {</a>
<a name="ln1388">		ntfs_log_error(&quot;Size of index buffer (VCN 0x%llx) of directory inode &quot;</a>
<a name="ln1389">				&quot;%lld exceeds maximum size.\n&quot;,</a>
<a name="ln1390">				(long long)ia_start &gt;&gt; index_vcn_size_bits,</a>
<a name="ln1391">				(unsigned long long)dir_ni-&gt;mft_no);</a>
<a name="ln1392">		goto dir_err_out;</a>
<a name="ln1393">	}</a>
<a name="ln1394">	/* The first index entry. */</a>
<a name="ln1395">	ie = (INDEX_ENTRY*)((u8*)&amp;ia-&gt;index +</a>
<a name="ln1396">			le32_to_cpu(ia-&gt;index.entries_offset));</a>
<a name="ln1397">	/*</a>
<a name="ln1398">	 * Loop until we exceed valid memory (corruption case) or until we</a>
<a name="ln1399">	 * reach the last entry or until ntfs_filldir tells us it has had</a>
<a name="ln1400">	 * enough or signals an error (both covered by the rc test).</a>
<a name="ln1401">	 */</a>
<a name="ln1402">	for (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie-&gt;length))) {</a>
<a name="ln1403">		ntfs_log_debug(&quot;In index allocation, offset 0x%llx.\n&quot;,</a>
<a name="ln1404">				(long long)ia_start + ((u8*)ie - (u8*)ia));</a>
<a name="ln1405">		/* Bounds checks. */</a>
<a name="ln1406">		if ((u8*)ie &lt; (u8*)ia || (u8*)ie +</a>
<a name="ln1407">				sizeof(INDEX_ENTRY_HEADER) &gt; index_end ||</a>
<a name="ln1408">				(u8*)ie + le16_to_cpu(ie-&gt;key_length) &gt;</a>
<a name="ln1409">				index_end) {</a>
<a name="ln1410">			ntfs_log_error(&quot;Index entry out of bounds in directory inode &quot;</a>
<a name="ln1411">				&quot;%lld.\n&quot;, (unsigned long long)dir_ni-&gt;mft_no);</a>
<a name="ln1412">			goto dir_err_out;</a>
<a name="ln1413">		}</a>
<a name="ln1414">		/* The last entry cannot contain a name. */</a>
<a name="ln1415">		if (ie-&gt;ie_flags &amp; INDEX_ENTRY_END)</a>
<a name="ln1416">			break;</a>
<a name="ln1417"> </a>
<a name="ln1418">		if (!le16_to_cpu(ie-&gt;length))</a>
<a name="ln1419">			goto dir_err_out;</a>
<a name="ln1420"> </a>
<a name="ln1421">		/* Skip index entry if continuing previous readdir. */</a>
<a name="ln1422">		if (ia_pos - ia_start &gt; (u8*)ie - (u8*)ia)</a>
<a name="ln1423">			continue;</a>
<a name="ln1424">		/*</a>
<a name="ln1425">		 * Submit the directory entry to ntfs_filldir(), which will</a>
<a name="ln1426">		 * invoke the filldir() callback as appropriate.</a>
<a name="ln1427">		 */</a>
<a name="ln1428">		rc = ntfs_filldir(dir_ni, pos, index_vcn_size_bits,</a>
<a name="ln1429">				INDEX_TYPE_ALLOCATION, ia, ie, dirent, filldir);</a>
<a name="ln1430">		if (rc)</a>
<a name="ln1431">			goto err_out;</a>
<a name="ln1432">	}</a>
<a name="ln1433">	goto find_next_index_buffer;</a>
<a name="ln1434">EOD:</a>
<a name="ln1435">	/* We are finished, set *pos to EOD. */</a>
<a name="ln1436">	*pos = i_size + vol-&gt;mft_record_size;</a>
<a name="ln1437">done:</a>
<a name="ln1438">	free(ia);</a>
<a name="ln1439">	free(bmp);</a>
<a name="ln1440">	if (bmp_na)</a>
<a name="ln1441">		ntfs_attr_close(bmp_na);</a>
<a name="ln1442">	if (ia_na)</a>
<a name="ln1443">		ntfs_attr_close(ia_na);</a>
<a name="ln1444">	ntfs_log_debug(&quot;EOD, *pos 0x%llx, returning 0.\n&quot;, (long long)*pos);</a>
<a name="ln1445">	return 0;</a>
<a name="ln1446">dir_err_out:</a>
<a name="ln1447">	errno = EIO;</a>
<a name="ln1448">err_out:</a>
<a name="ln1449">	eo = errno;</a>
<a name="ln1450">	ntfs_log_trace(&quot;failed.\n&quot;);</a>
<a name="ln1451">	if (ctx)</a>
<a name="ln1452">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln1453">	free(ia);</a>
<a name="ln1454">	free(bmp);</a>
<a name="ln1455">	if (bmp_na)</a>
<a name="ln1456">		ntfs_attr_close(bmp_na);</a>
<a name="ln1457">	if (ia_na)</a>
<a name="ln1458">		ntfs_attr_close(ia_na);</a>
<a name="ln1459">	errno = eo;</a>
<a name="ln1460">	return -1;</a>
<a name="ln1461">}</a>
<a name="ln1462"> </a>
<a name="ln1463"> </a>
<a name="ln1464">/**</a>
<a name="ln1465"> * __ntfs_create - create object on ntfs volume</a>
<a name="ln1466"> * @dir_ni:	ntfs inode for directory in which create new object</a>
<a name="ln1467"> * @securid:	id of inheritable security descriptor, 0 if none</a>
<a name="ln1468"> * @name:	unicode name of new object</a>
<a name="ln1469"> * @name_len:	length of the name in unicode characters</a>
<a name="ln1470"> * @type:	type of the object to create</a>
<a name="ln1471"> * @dev:	major and minor device numbers (obtained from makedev())</a>
<a name="ln1472"> * @target:	target in unicode (only for symlinks)</a>
<a name="ln1473"> * @target_len:	length of target in unicode characters</a>
<a name="ln1474"> *</a>
<a name="ln1475"> * Internal, use ntfs_create{,_device,_symlink} wrappers instead.</a>
<a name="ln1476"> *</a>
<a name="ln1477"> * @type can be:</a>
<a name="ln1478"> *	S_IFREG		to create regular file</a>
<a name="ln1479"> *	S_IFDIR		to create directory</a>
<a name="ln1480"> *	S_IFBLK		to create block device</a>
<a name="ln1481"> *	S_IFCHR		to create character device</a>
<a name="ln1482"> *	S_IFLNK		to create symbolic link</a>
<a name="ln1483"> *	S_IFIFO		to create FIFO</a>
<a name="ln1484"> *	S_IFSOCK	to create socket</a>
<a name="ln1485"> * other values are invalid.</a>
<a name="ln1486"> *</a>
<a name="ln1487"> * @dev is used only if @type is S_IFBLK or S_IFCHR, in other cases its value</a>
<a name="ln1488"> * ignored.</a>
<a name="ln1489"> *</a>
<a name="ln1490"> * @target and @target_len are used only if @type is S_IFLNK, in other cases</a>
<a name="ln1491"> * their value ignored.</a>
<a name="ln1492"> *</a>
<a name="ln1493"> * Return opened ntfs inode that describes created object on success or NULL</a>
<a name="ln1494"> * on error with errno set to the error code.</a>
<a name="ln1495"> */</a>
<a name="ln1496">static ntfs_inode *__ntfs_create(ntfs_inode *dir_ni, le32 securid,</a>
<a name="ln1497">		const ntfschar *name, u8 name_len, mode_t type, dev_t dev,</a>
<a name="ln1498">		const ntfschar *target, int target_len)</a>
<a name="ln1499">{</a>
<a name="ln1500">	ntfs_inode *ni;</a>
<a name="ln1501">	int rollback_data = 0, rollback_sd = 0;</a>
<a name="ln1502">	FILE_NAME_ATTR *fn = NULL;</a>
<a name="ln1503">	STANDARD_INFORMATION *si = NULL;</a>
<a name="ln1504">	int err, fn_len, si_len;</a>
<a name="ln1505"> </a>
<a name="ln1506">	ntfs_log_trace(&quot;Entering.\n&quot;);</a>
<a name="ln1507"> </a>
<a name="ln1508">	/* Sanity checks. */</a>
<a name="ln1509">	if (!dir_ni || !name || !name_len) {</a>
<a name="ln1510">		ntfs_log_error(&quot;Invalid arguments.\n&quot;);</a>
<a name="ln1511">		errno = EINVAL;</a>
<a name="ln1512">		return NULL;</a>
<a name="ln1513">	}</a>
<a name="ln1514"> </a>
<a name="ln1515">	if (dir_ni-&gt;flags &amp; FILE_ATTR_REPARSE_POINT) {</a>
<a name="ln1516">		errno = EOPNOTSUPP;</a>
<a name="ln1517">		return NULL;</a>
<a name="ln1518">	}</a>
<a name="ln1519"> </a>
<a name="ln1520">	ni = ntfs_mft_record_alloc(dir_ni-&gt;vol, NULL);</a>
<a name="ln1521">	if (!ni)</a>
<a name="ln1522">		return NULL;</a>
<a name="ln1523">#if CACHE_NIDATA_SIZE</a>
<a name="ln1524">	ntfs_inode_invalidate(dir_ni-&gt;vol, ni-&gt;mft_no);</a>
<a name="ln1525">#endif</a>
<a name="ln1526">	/*</a>
<a name="ln1527">	 * Create STANDARD_INFORMATION attribute.</a>
<a name="ln1528">	 * JPA Depending on available inherited security descriptor,</a>
<a name="ln1529">	 * Write STANDARD_INFORMATION v1.2 (no inheritance) or v3</a>
<a name="ln1530">	 */</a>
<a name="ln1531">	if (securid)</a>
<a name="ln1532">		si_len = sizeof(STANDARD_INFORMATION);</a>
<a name="ln1533">	else</a>
<a name="ln1534">		si_len = offsetof(STANDARD_INFORMATION, v1_end);</a>
<a name="ln1535">	si = ntfs_calloc(si_len);</a>
<a name="ln1536">	if (!si) {</a>
<a name="ln1537">		err = errno;</a>
<a name="ln1538">		goto err_out;</a>
<a name="ln1539">	}</a>
<a name="ln1540">	si-&gt;creation_time = ni-&gt;creation_time;</a>
<a name="ln1541">	si-&gt;last_data_change_time = ni-&gt;last_data_change_time;</a>
<a name="ln1542">	si-&gt;last_mft_change_time = ni-&gt;last_mft_change_time;</a>
<a name="ln1543">	si-&gt;last_access_time = ni-&gt;last_access_time;</a>
<a name="ln1544">	if (securid) {</a>
<a name="ln1545">		set_nino_flag(ni, v3_Extensions);</a>
<a name="ln1546">		ni-&gt;owner_id = si-&gt;owner_id = const_cpu_to_le32(0);</a>
<a name="ln1547">		ni-&gt;security_id = si-&gt;security_id = securid;</a>
<a name="ln1548">		ni-&gt;quota_charged = si-&gt;quota_charged = const_cpu_to_le64(0);</a>
<a name="ln1549">		ni-&gt;usn = si-&gt;usn = const_cpu_to_le64(0);</a>
<a name="ln1550">	} else</a>
<a name="ln1551">		clear_nino_flag(ni, v3_Extensions);</a>
<a name="ln1552">	if (!S_ISREG(type) &amp;&amp; !S_ISDIR(type)) {</a>
<a name="ln1553">		si-&gt;file_attributes = FILE_ATTR_SYSTEM;</a>
<a name="ln1554">		ni-&gt;flags = FILE_ATTR_SYSTEM;</a>
<a name="ln1555">	}</a>
<a name="ln1556">	ni-&gt;flags |= FILE_ATTR_ARCHIVE;</a>
<a name="ln1557">	if (NVolHideDotFiles(dir_ni-&gt;vol)</a>
<a name="ln1558">	    &amp;&amp; (name_len &gt; 1)</a>
<a name="ln1559">	    &amp;&amp; (name[0] == const_cpu_to_le16('.'))</a>
<a name="ln1560">	    &amp;&amp; (name[1] != const_cpu_to_le16('.')))</a>
<a name="ln1561">		ni-&gt;flags |= FILE_ATTR_HIDDEN;</a>
<a name="ln1562">		/*</a>
<a name="ln1563">		 * Set compression flag according to parent directory</a>
<a name="ln1564">		 * unless NTFS version &lt; 3.0 or cluster size &gt; 4K</a>
<a name="ln1565">		 * or compression has been disabled</a>
<a name="ln1566">		 */</a>
<a name="ln1567">	if ((dir_ni-&gt;flags &amp; FILE_ATTR_COMPRESSED)</a>
<a name="ln1568">	   &amp;&amp; (dir_ni-&gt;vol-&gt;major_ver &gt;= 3)</a>
<a name="ln1569">	   &amp;&amp; NVolCompression(dir_ni-&gt;vol)</a>
<a name="ln1570">	   &amp;&amp; (dir_ni-&gt;vol-&gt;cluster_size &lt;= MAX_COMPRESSION_CLUSTER_SIZE)</a>
<a name="ln1571">	   &amp;&amp; (S_ISREG(type) || S_ISDIR(type)))</a>
<a name="ln1572">		ni-&gt;flags |= FILE_ATTR_COMPRESSED;</a>
<a name="ln1573">	/* Add STANDARD_INFORMATION to inode. */</a>
<a name="ln1574">	if (ntfs_attr_add(ni, AT_STANDARD_INFORMATION, AT_UNNAMED, 0,</a>
<a name="ln1575">			(u8*)si, si_len)) {</a>
<a name="ln1576">		err = errno;</a>
<a name="ln1577">		ntfs_log_error(&quot;Failed to add STANDARD_INFORMATION &quot;</a>
<a name="ln1578">				&quot;attribute.\n&quot;);</a>
<a name="ln1579">		goto err_out;</a>
<a name="ln1580">	}</a>
<a name="ln1581"> </a>
<a name="ln1582">	if (!securid) {</a>
<a name="ln1583">		if (ntfs_sd_add_everyone(ni)) {</a>
<a name="ln1584">			err = errno;</a>
<a name="ln1585">			goto err_out;</a>
<a name="ln1586">		}</a>
<a name="ln1587">	}</a>
<a name="ln1588">	rollback_sd = 1;</a>
<a name="ln1589"> </a>
<a name="ln1590">	if (S_ISDIR(type)) {</a>
<a name="ln1591">		INDEX_ROOT *ir = NULL;</a>
<a name="ln1592">		INDEX_ENTRY *ie;</a>
<a name="ln1593">		int ir_len, index_len;</a>
<a name="ln1594"> </a>
<a name="ln1595">		/* Create INDEX_ROOT attribute. */</a>
<a name="ln1596">		index_len = sizeof(INDEX_HEADER) + sizeof(INDEX_ENTRY_HEADER);</a>
<a name="ln1597">		ir_len = offsetof(INDEX_ROOT, index) + index_len;</a>
<a name="ln1598">		ir = ntfs_calloc(ir_len);</a>
<a name="ln1599">		if (!ir) {</a>
<a name="ln1600">			err = errno;</a>
<a name="ln1601">			goto err_out;</a>
<a name="ln1602">		}</a>
<a name="ln1603">		ir-&gt;type = AT_FILE_NAME;</a>
<a name="ln1604">		ir-&gt;collation_rule = COLLATION_FILE_NAME;</a>
<a name="ln1605">		ir-&gt;index_block_size = cpu_to_le32(ni-&gt;vol-&gt;indx_record_size);</a>
<a name="ln1606">		if (ni-&gt;vol-&gt;cluster_size &lt;= ni-&gt;vol-&gt;indx_record_size)</a>
<a name="ln1607">			ir-&gt;clusters_per_index_block =</a>
<a name="ln1608">					ni-&gt;vol-&gt;indx_record_size &gt;&gt;</a>
<a name="ln1609">					ni-&gt;vol-&gt;cluster_size_bits;</a>
<a name="ln1610">		else</a>
<a name="ln1611">			ir-&gt;clusters_per_index_block =</a>
<a name="ln1612">					ni-&gt;vol-&gt;indx_record_size &gt;&gt;</a>
<a name="ln1613">					NTFS_BLOCK_SIZE_BITS;</a>
<a name="ln1614">		ir-&gt;index.entries_offset = const_cpu_to_le32(sizeof(INDEX_HEADER));</a>
<a name="ln1615">		ir-&gt;index.index_length = cpu_to_le32(index_len);</a>
<a name="ln1616">		ir-&gt;index.allocated_size = cpu_to_le32(index_len);</a>
<a name="ln1617">		ie = (INDEX_ENTRY*)((u8*)ir + sizeof(INDEX_ROOT));</a>
<a name="ln1618">		ie-&gt;length = const_cpu_to_le16(sizeof(INDEX_ENTRY_HEADER));</a>
<a name="ln1619">		ie-&gt;key_length = const_cpu_to_le16(0);</a>
<a name="ln1620">		ie-&gt;ie_flags = INDEX_ENTRY_END;</a>
<a name="ln1621">		/* Add INDEX_ROOT attribute to inode. */</a>
<a name="ln1622">		if (ntfs_attr_add(ni, AT_INDEX_ROOT, NTFS_INDEX_I30, 4,</a>
<a name="ln1623">				(u8*)ir, ir_len)) {</a>
<a name="ln1624">			err = errno;</a>
<a name="ln1625">			free(ir);</a>
<a name="ln1626">			ntfs_log_error(&quot;Failed to add INDEX_ROOT attribute.\n&quot;);</a>
<a name="ln1627">			goto err_out;</a>
<a name="ln1628">		}</a>
<a name="ln1629">		free(ir);</a>
<a name="ln1630">	} else {</a>
<a name="ln1631">		INTX_FILE *data;</a>
<a name="ln1632">		int data_len;</a>
<a name="ln1633"> </a>
<a name="ln1634">		switch (type) {</a>
<a name="ln1635">			case S_IFBLK:</a>
<a name="ln1636">			case S_IFCHR:</a>
<a name="ln1637">				data_len = offsetof(INTX_FILE, device_end);</a>
<a name="ln1638">				data = ntfs_malloc(data_len);</a>
<a name="ln1639">				if (!data) {</a>
<a name="ln1640">					err = errno;</a>
<a name="ln1641">					goto err_out;</a>
<a name="ln1642">				}</a>
<a name="ln1643">				data-&gt;major = cpu_to_le64(major(dev));</a>
<a name="ln1644">				data-&gt;minor = cpu_to_le64(minor(dev));</a>
<a name="ln1645">				if (type == S_IFBLK)</a>
<a name="ln1646">					data-&gt;magic = INTX_BLOCK_DEVICE;</a>
<a name="ln1647">				if (type == S_IFCHR)</a>
<a name="ln1648">					data-&gt;magic = INTX_CHARACTER_DEVICE;</a>
<a name="ln1649">				break;</a>
<a name="ln1650">			case S_IFLNK:</a>
<a name="ln1651">				data_len = sizeof(INTX_FILE_TYPES) +</a>
<a name="ln1652">						target_len * sizeof(ntfschar);</a>
<a name="ln1653">				data = ntfs_malloc(data_len);</a>
<a name="ln1654">				if (!data) {</a>
<a name="ln1655">					err = errno;</a>
<a name="ln1656">					goto err_out;</a>
<a name="ln1657">				}</a>
<a name="ln1658">				data-&gt;magic = INTX_SYMBOLIC_LINK;</a>
<a name="ln1659">				memcpy(data-&gt;target, target,</a>
<a name="ln1660">						target_len * sizeof(ntfschar));</a>
<a name="ln1661">				break;</a>
<a name="ln1662">			case S_IFSOCK:</a>
<a name="ln1663">				data = NULL;</a>
<a name="ln1664">				data_len = 1;</a>
<a name="ln1665">				break;</a>
<a name="ln1666">			default: /* FIFO or regular file. */</a>
<a name="ln1667">				data = NULL;</a>
<a name="ln1668">				data_len = 0;</a>
<a name="ln1669">				break;</a>
<a name="ln1670">		}</a>
<a name="ln1671">		/* Add DATA attribute to inode. */</a>
<a name="ln1672">		if (ntfs_attr_add(ni, AT_DATA, AT_UNNAMED, 0, (u8*)data,</a>
<a name="ln1673">				data_len)) {</a>
<a name="ln1674">			err = errno;</a>
<a name="ln1675">			ntfs_log_error(&quot;Failed to add DATA attribute.\n&quot;);</a>
<a name="ln1676">			free(data);</a>
<a name="ln1677">			goto err_out;</a>
<a name="ln1678">		}</a>
<a name="ln1679">		rollback_data = 1;</a>
<a name="ln1680">		free(data);</a>
<a name="ln1681">	}</a>
<a name="ln1682">	/* Create FILE_NAME attribute. */</a>
<a name="ln1683">	fn_len = sizeof(FILE_NAME_ATTR) + name_len * sizeof(ntfschar);</a>
<a name="ln1684">	fn = ntfs_calloc(fn_len);</a>
<a name="ln1685">	if (!fn) {</a>
<a name="ln1686">		err = errno;</a>
<a name="ln1687">		goto err_out;</a>
<a name="ln1688">	}</a>
<a name="ln1689">	fn-&gt;parent_directory = MK_LE_MREF(dir_ni-&gt;mft_no,</a>
<a name="ln1690">			le16_to_cpu(dir_ni-&gt;mrec-&gt;sequence_number));</a>
<a name="ln1691">	fn-&gt;file_name_length = name_len;</a>
<a name="ln1692">	fn-&gt;file_name_type = FILE_NAME_POSIX;</a>
<a name="ln1693">	if (S_ISDIR(type))</a>
<a name="ln1694">		fn-&gt;file_attributes = FILE_ATTR_I30_INDEX_PRESENT;</a>
<a name="ln1695">	if (!S_ISREG(type) &amp;&amp; !S_ISDIR(type))</a>
<a name="ln1696">		fn-&gt;file_attributes = FILE_ATTR_SYSTEM;</a>
<a name="ln1697">	else</a>
<a name="ln1698">		fn-&gt;file_attributes |= ni-&gt;flags &amp; FILE_ATTR_COMPRESSED;</a>
<a name="ln1699">	fn-&gt;file_attributes |= FILE_ATTR_ARCHIVE;</a>
<a name="ln1700">	fn-&gt;file_attributes |= ni-&gt;flags &amp; FILE_ATTR_HIDDEN;</a>
<a name="ln1701">	fn-&gt;creation_time = ni-&gt;creation_time;</a>
<a name="ln1702">	fn-&gt;last_data_change_time = ni-&gt;last_data_change_time;</a>
<a name="ln1703">	fn-&gt;last_mft_change_time = ni-&gt;last_mft_change_time;</a>
<a name="ln1704">	fn-&gt;last_access_time = ni-&gt;last_access_time;</a>
<a name="ln1705">	if (ni-&gt;mrec-&gt;flags &amp; MFT_RECORD_IS_DIRECTORY)</a>
<a name="ln1706">		fn-&gt;data_size = fn-&gt;allocated_size = const_cpu_to_sle64(0);</a>
<a name="ln1707">	else {</a>
<a name="ln1708">		fn-&gt;data_size = cpu_to_sle64(ni-&gt;data_size);</a>
<a name="ln1709">		fn-&gt;allocated_size = cpu_to_sle64(ni-&gt;allocated_size);</a>
<a name="ln1710">	}</a>
<a name="ln1711">	memcpy(fn-&gt;file_name, name, name_len * sizeof(ntfschar));</a>
<a name="ln1712">	/* Add FILE_NAME attribute to inode. */</a>
<a name="ln1713">	if (ntfs_attr_add(ni, AT_FILE_NAME, AT_UNNAMED, 0, (u8*)fn, fn_len)) {</a>
<a name="ln1714">		err = errno;</a>
<a name="ln1715">		ntfs_log_error(&quot;Failed to add FILE_NAME attribute.\n&quot;);</a>
<a name="ln1716">		goto err_out;</a>
<a name="ln1717">	}</a>
<a name="ln1718">	/* Add FILE_NAME attribute to index. */</a>
<a name="ln1719">	if (ntfs_index_add_filename(dir_ni, fn, MK_MREF(ni-&gt;mft_no,</a>
<a name="ln1720">			le16_to_cpu(ni-&gt;mrec-&gt;sequence_number)))) {</a>
<a name="ln1721">		err = errno;</a>
<a name="ln1722">		ntfs_log_perror(&quot;Failed to add entry to the index&quot;);</a>
<a name="ln1723">		goto err_out;</a>
<a name="ln1724">	}</a>
<a name="ln1725">	/* Set hard links count and directory flag. */</a>
<a name="ln1726">	ni-&gt;mrec-&gt;link_count = const_cpu_to_le16(1);</a>
<a name="ln1727">	if (S_ISDIR(type))</a>
<a name="ln1728">		ni-&gt;mrec-&gt;flags |= MFT_RECORD_IS_DIRECTORY;</a>
<a name="ln1729">	ntfs_inode_mark_dirty(ni);</a>
<a name="ln1730">	/* Done! */</a>
<a name="ln1731">	free(fn);</a>
<a name="ln1732">	free(si);</a>
<a name="ln1733">	ntfs_log_trace(&quot;Done.\n&quot;);</a>
<a name="ln1734">	return ni;</a>
<a name="ln1735">err_out:</a>
<a name="ln1736">	ntfs_log_trace(&quot;Failed.\n&quot;);</a>
<a name="ln1737"> </a>
<a name="ln1738">	if (rollback_sd)</a>
<a name="ln1739">		ntfs_attr_remove(ni, AT_SECURITY_DESCRIPTOR, AT_UNNAMED, 0);</a>
<a name="ln1740"> </a>
<a name="ln1741">	if (rollback_data)</a>
<a name="ln1742">		ntfs_attr_remove(ni, AT_DATA, AT_UNNAMED, 0);</a>
<a name="ln1743">	/*</a>
<a name="ln1744">	 * Free extent MFT records (should not exist any with current</a>
<a name="ln1745">	 * ntfs_create implementation, but for any case if something will be</a>
<a name="ln1746">	 * changed in the future).</a>
<a name="ln1747">	 */</a>
<a name="ln1748">	while (ni-&gt;nr_extents)</a>
<a name="ln1749">		if (ntfs_mft_record_free(ni-&gt;vol, *(ni-&gt;extent_nis))) {</a>
<a name="ln1750">			err = errno;</a>
<a name="ln1751">			ntfs_log_error(&quot;Failed to free extent MFT record.  &quot;</a>
<a name="ln1752">					&quot;Leaving inconsistent metadata.\n&quot;);</a>
<a name="ln1753">		}</a>
<a name="ln1754">	if (ntfs_mft_record_free(ni-&gt;vol, ni))</a>
<a name="ln1755">		ntfs_log_error(&quot;Failed to free MFT record.  &quot;</a>
<a name="ln1756">				&quot;Leaving inconsistent metadata. Run chkdsk.\n&quot;);</a>
<a name="ln1757">	free(fn);</a>
<a name="ln1758">	free(si);</a>
<a name="ln1759">	errno = err;</a>
<a name="ln1760">	return NULL;</a>
<a name="ln1761">}</a>
<a name="ln1762"> </a>
<a name="ln1763">/**</a>
<a name="ln1764"> * Some wrappers around __ntfs_create() ...</a>
<a name="ln1765"> */</a>
<a name="ln1766"> </a>
<a name="ln1767">ntfs_inode *ntfs_create(ntfs_inode *dir_ni, le32 securid, const ntfschar *name,</a>
<a name="ln1768">		u8 name_len, mode_t type)</a>
<a name="ln1769">{</a>
<a name="ln1770">	if (type != S_IFREG &amp;&amp; type != S_IFDIR &amp;&amp; type != S_IFIFO &amp;&amp;</a>
<a name="ln1771">			type != S_IFSOCK) {</a>
<a name="ln1772">		ntfs_log_error(&quot;Invalid arguments.\n&quot;);</a>
<a name="ln1773">		return NULL;</a>
<a name="ln1774">	}</a>
<a name="ln1775">	return __ntfs_create(dir_ni, securid, name, name_len, type, 0, NULL, 0);</a>
<a name="ln1776">}</a>
<a name="ln1777"> </a>
<a name="ln1778">ntfs_inode *ntfs_create_device(ntfs_inode *dir_ni, le32 securid,</a>
<a name="ln1779">		const ntfschar *name, u8 name_len, mode_t type, dev_t dev)</a>
<a name="ln1780">{</a>
<a name="ln1781">	if (type != S_IFCHR &amp;&amp; type != S_IFBLK) {</a>
<a name="ln1782">		ntfs_log_error(&quot;Invalid arguments.\n&quot;);</a>
<a name="ln1783">		return NULL;</a>
<a name="ln1784">	}</a>
<a name="ln1785">	return __ntfs_create(dir_ni, securid, name, name_len, type, dev, NULL, 0);</a>
<a name="ln1786">}</a>
<a name="ln1787"> </a>
<a name="ln1788">ntfs_inode *ntfs_create_symlink(ntfs_inode *dir_ni, le32 securid,</a>
<a name="ln1789">		const ntfschar *name, u8 name_len, const ntfschar *target,</a>
<a name="ln1790">		int target_len)</a>
<a name="ln1791">{</a>
<a name="ln1792">	if (!target || !target_len) {</a>
<a name="ln1793">		ntfs_log_error(&quot;%s: Invalid argument (%p, %d)\n&quot;, __FUNCTION__,</a>
<a name="ln1794">			       target, target_len);</a>
<a name="ln1795">		return NULL;</a>
<a name="ln1796">	}</a>
<a name="ln1797">	return __ntfs_create(dir_ni, securid, name, name_len, S_IFLNK, 0,</a>
<a name="ln1798">			target, target_len);</a>
<a name="ln1799">}</a>
<a name="ln1800"> </a>
<a name="ln1801">int ntfs_check_empty_dir(ntfs_inode *ni)</a>
<a name="ln1802">{</a>
<a name="ln1803">	ntfs_attr *na;</a>
<a name="ln1804">	int ret = 0;</a>
<a name="ln1805"> </a>
<a name="ln1806">	if (!(ni-&gt;mrec-&gt;flags &amp; MFT_RECORD_IS_DIRECTORY))</a>
<a name="ln1807">		return 0;</a>
<a name="ln1808"> </a>
<a name="ln1809">	na = ntfs_attr_open(ni, AT_INDEX_ROOT, NTFS_INDEX_I30, 4);</a>
<a name="ln1810">	if (!na) {</a>
<a name="ln1811">		errno = EIO;</a>
<a name="ln1812">		ntfs_log_perror(&quot;Failed to open directory&quot;);</a>
<a name="ln1813">		return -1;</a>
<a name="ln1814">	}</a>
<a name="ln1815"> </a>
<a name="ln1816">	/* Non-empty directory? */</a>
<a name="ln1817">	if ((na-&gt;data_size != sizeof(INDEX_ROOT) + sizeof(INDEX_ENTRY_HEADER))){</a>
<a name="ln1818">		/* Both ENOTEMPTY and EEXIST are ok. We use the more common. */</a>
<a name="ln1819">		errno = ENOTEMPTY;</a>
<a name="ln1820">		ntfs_log_debug(&quot;Directory is not empty\n&quot;);</a>
<a name="ln1821">		ret = -1;</a>
<a name="ln1822">	}</a>
<a name="ln1823"> </a>
<a name="ln1824">	ntfs_attr_close(na);</a>
<a name="ln1825">	return ret;</a>
<a name="ln1826">}</a>
<a name="ln1827"> </a>
<a name="ln1828">static int ntfs_check_unlinkable_dir(ntfs_inode *ni, FILE_NAME_ATTR *fn)</a>
<a name="ln1829">{</a>
<a name="ln1830">	int link_count = le16_to_cpu(ni-&gt;mrec-&gt;link_count);</a>
<a name="ln1831">	int ret;</a>
<a name="ln1832"> </a>
<a name="ln1833">	ret = ntfs_check_empty_dir(ni);</a>
<a name="ln1834">	if (!ret || errno != ENOTEMPTY)</a>
<a name="ln1835">		return ret;</a>
<a name="ln1836">	/*</a>
<a name="ln1837">	 * Directory is non-empty, so we can unlink only if there is more than</a>
<a name="ln1838">	 * one &quot;real&quot; hard link, i.e. links aren't different DOS and WIN32 names</a>
<a name="ln1839">	 */</a>
<a name="ln1840">	if ((link_count == 1) ||</a>
<a name="ln1841">	    (link_count == 2 &amp;&amp; fn-&gt;file_name_type == FILE_NAME_DOS)) {</a>
<a name="ln1842">		errno = ENOTEMPTY;</a>
<a name="ln1843">		ntfs_log_debug(&quot;Non-empty directory without hard links\n&quot;);</a>
<a name="ln1844">		goto no_hardlink;</a>
<a name="ln1845">	}</a>
<a name="ln1846"> </a>
<a name="ln1847">	ret = 0;</a>
<a name="ln1848">no_hardlink:</a>
<a name="ln1849">	return ret;</a>
<a name="ln1850">}</a>
<a name="ln1851"> </a>
<a name="ln1852">/**</a>
<a name="ln1853"> * ntfs_delete - delete file or directory from ntfs volume</a>
<a name="ln1854"> * @ni:		ntfs inode for object to delte</a>
<a name="ln1855"> * @dir_ni:	ntfs inode for directory in which delete object</a>
<a name="ln1856"> * @name:	unicode name of the object to delete</a>
<a name="ln1857"> * @name_len:	length of the name in unicode characters</a>
<a name="ln1858"> *</a>
<a name="ln1859"> * @ni is always closed after the call to this function (even if it failed),</a>
<a name="ln1860"> * user does not need to call ntfs_inode_close himself.</a>
<a name="ln1861"> *</a>
<a name="ln1862"> * Return 0 on success or -1 on error with errno set to the error code.</a>
<a name="ln1863"> */</a>
<a name="ln1864">int ntfs_delete(ntfs_volume *vol, const char *pathname,</a>
<a name="ln1865">		ntfs_inode *ni, ntfs_inode *dir_ni, const ntfschar *name,</a>
<a name="ln1866">		u8 name_len)</a>
<a name="ln1867">{</a>
<a name="ln1868">	ntfs_attr_search_ctx *actx = NULL;</a>
<a name="ln1869">	FILE_NAME_ATTR *fn = NULL;</a>
<a name="ln1870">	BOOL looking_for_dos_name = FALSE, looking_for_win32_name = FALSE;</a>
<a name="ln1871">	BOOL case_sensitive_match = TRUE;</a>
<a name="ln1872">	int err = 0;</a>
<a name="ln1873">#if CACHE_NIDATA_SIZE</a>
<a name="ln1874">	int i;</a>
<a name="ln1875">#endif</a>
<a name="ln1876">#if CACHE_INODE_SIZE</a>
<a name="ln1877">	struct CACHED_INODE item;</a>
<a name="ln1878">	const char *p;</a>
<a name="ln1879">	u64 inum = (u64)-1;</a>
<a name="ln1880">	int count;</a>
<a name="ln1881">#endif</a>
<a name="ln1882">#if CACHE_LOOKUP_SIZE</a>
<a name="ln1883">	struct CACHED_LOOKUP lkitem;</a>
<a name="ln1884">#endif</a>
<a name="ln1885"> </a>
<a name="ln1886">	ntfs_log_trace(&quot;Entering.\n&quot;);</a>
<a name="ln1887"> </a>
<a name="ln1888">	if (!ni || !dir_ni || !name || !name_len) {</a>
<a name="ln1889">		ntfs_log_error(&quot;Invalid arguments.\n&quot;);</a>
<a name="ln1890">		errno = EINVAL;</a>
<a name="ln1891">		goto err_out;</a>
<a name="ln1892">	}</a>
<a name="ln1893">	if (ni-&gt;nr_extents == -1)</a>
<a name="ln1894">		ni = ni-&gt;base_ni;</a>
<a name="ln1895">	if (dir_ni-&gt;nr_extents == -1)</a>
<a name="ln1896">		dir_ni = dir_ni-&gt;base_ni;</a>
<a name="ln1897">	/*</a>
<a name="ln1898">	 * Search for FILE_NAME attribute with such name. If it's in POSIX or</a>
<a name="ln1899">	 * WIN32_AND_DOS namespace, then simply remove it from index and inode.</a>
<a name="ln1900">	 * If filename in DOS or in WIN32 namespace, then remove DOS name first,</a>
<a name="ln1901">	 * only then remove WIN32 name.</a>
<a name="ln1902">	 */</a>
<a name="ln1903">	actx = ntfs_attr_get_search_ctx(ni, NULL);</a>
<a name="ln1904">	if (!actx)</a>
<a name="ln1905">		goto err_out;</a>
<a name="ln1906">search:</a>
<a name="ln1907">	while (!(err = ntfs_attr_lookup(AT_FILE_NAME, AT_UNNAMED, 0,</a>
<a name="ln1908">					CASE_SENSITIVE, 0, NULL, 0, actx))) {</a>
<a name="ln1909">	#ifdef DEBUG</a>
<a name="ln1910">		char *s;</a>
<a name="ln1911">	#endif</a>
<a name="ln1912">		IGNORE_CASE_BOOL case_sensitive = IGNORE_CASE;</a>
<a name="ln1913"> </a>
<a name="ln1914">		fn = (FILE_NAME_ATTR*)((u8*)actx-&gt;attr +</a>
<a name="ln1915">				le16_to_cpu(actx-&gt;attr-&gt;value_offset));</a>
<a name="ln1916">	#ifdef DEBUG</a>
<a name="ln1917">		s = ntfs_attr_name_get(fn-&gt;file_name, fn-&gt;file_name_length);</a>
<a name="ln1918">		ntfs_log_trace(&quot;name: '%s'  type: %d  dos: %d  win32: %d  &quot;</a>
<a name="ln1919">			       &quot;case: %d\n&quot;, s, fn-&gt;file_name_type,</a>
<a name="ln1920">			       looking_for_dos_name, looking_for_win32_name,</a>
<a name="ln1921">			       case_sensitive_match);</a>
<a name="ln1922">		ntfs_attr_name_free(&amp;s);</a>
<a name="ln1923">	#endif</a>
<a name="ln1924">		if (looking_for_dos_name) {</a>
<a name="ln1925">			if (fn-&gt;file_name_type == FILE_NAME_DOS)</a>
<a name="ln1926">				break;</a>
<a name="ln1927">			else</a>
<a name="ln1928">				continue;</a>
<a name="ln1929">		}</a>
<a name="ln1930">		if (looking_for_win32_name) {</a>
<a name="ln1931">			if  (fn-&gt;file_name_type == FILE_NAME_WIN32)</a>
<a name="ln1932">				break;</a>
<a name="ln1933">			else</a>
<a name="ln1934">				continue;</a>
<a name="ln1935">		}</a>
<a name="ln1936"> </a>
<a name="ln1937">		/* Ignore hard links from other directories */</a>
<a name="ln1938">		if (dir_ni-&gt;mft_no != MREF_LE(fn-&gt;parent_directory)) {</a>
<a name="ln1939">			ntfs_log_debug(&quot;MFT record numbers don't match &quot;</a>
<a name="ln1940">				       &quot;(%llu != %llu)\n&quot;,</a>
<a name="ln1941">				       (long long unsigned)dir_ni-&gt;mft_no,</a>
<a name="ln1942">				       (long long unsigned)MREF_LE(fn-&gt;parent_directory));</a>
<a name="ln1943">			continue;</a>
<a name="ln1944">		}</a>
<a name="ln1945">		if (case_sensitive_match</a>
<a name="ln1946">		    || ((fn-&gt;file_name_type == FILE_NAME_POSIX)</a>
<a name="ln1947">			&amp;&amp; NVolCaseSensitive(ni-&gt;vol)))</a>
<a name="ln1948">			case_sensitive = CASE_SENSITIVE;</a>
<a name="ln1949"> </a>
<a name="ln1950">		if (ntfs_names_are_equal(fn-&gt;file_name, fn-&gt;file_name_length,</a>
<a name="ln1951">					 name, name_len, case_sensitive,</a>
<a name="ln1952">					 ni-&gt;vol-&gt;upcase, ni-&gt;vol-&gt;upcase_len)){</a>
<a name="ln1953"> </a>
<a name="ln1954">			if (fn-&gt;file_name_type == FILE_NAME_WIN32) {</a>
<a name="ln1955">				looking_for_dos_name = TRUE;</a>
<a name="ln1956">				ntfs_attr_reinit_search_ctx(actx);</a>
<a name="ln1957">				continue;</a>
<a name="ln1958">			}</a>
<a name="ln1959">			if (fn-&gt;file_name_type == FILE_NAME_DOS)</a>
<a name="ln1960">				looking_for_dos_name = TRUE;</a>
<a name="ln1961">			break;</a>
<a name="ln1962">		}</a>
<a name="ln1963">	}</a>
<a name="ln1964">	if (err) {</a>
<a name="ln1965">		/*</a>
<a name="ln1966">		 * If case sensitive search failed, then try once again</a>
<a name="ln1967">		 * ignoring case.</a>
<a name="ln1968">		 */</a>
<a name="ln1969">		if (errno == ENOENT &amp;&amp; case_sensitive_match) {</a>
<a name="ln1970">			case_sensitive_match = FALSE;</a>
<a name="ln1971">			ntfs_attr_reinit_search_ctx(actx);</a>
<a name="ln1972">			goto search;</a>
<a name="ln1973">		}</a>
<a name="ln1974">		goto err_out;</a>
<a name="ln1975">	}</a>
<a name="ln1976"> </a>
<a name="ln1977">	if (ntfs_check_unlinkable_dir(ni, fn) &lt; 0)</a>
<a name="ln1978">		goto err_out;</a>
<a name="ln1979"> </a>
<a name="ln1980">	if (ntfs_index_remove(dir_ni, ni, fn, le32_to_cpu(actx-&gt;attr-&gt;value_length)))</a>
<a name="ln1981">		goto err_out;</a>
<a name="ln1982"> </a>
<a name="ln1983">	/*</a>
<a name="ln1984">	 * Keep the last name in place, this is useful for undeletion</a>
<a name="ln1985">	 * (Windows also does so), however delete the name if it were</a>
<a name="ln1986">	 * in an extent, to avoid leaving an attribute list.</a>
<a name="ln1987">	 */</a>
<a name="ln1988">	if ((ni-&gt;mrec-&gt;link_count == const_cpu_to_le16(1)) &amp;&amp; !actx-&gt;base_ntfs_ino) {</a>
<a name="ln1989">			/* make sure to not loop to another search */</a>
<a name="ln1990">		looking_for_dos_name = FALSE;</a>
<a name="ln1991">	} else {</a>
<a name="ln1992">		if (ntfs_attr_record_rm(actx))</a>
<a name="ln1993">			goto err_out;</a>
<a name="ln1994">	}</a>
<a name="ln1995"> </a>
<a name="ln1996">	ni-&gt;mrec-&gt;link_count = cpu_to_le16(le16_to_cpu(</a>
<a name="ln1997">			ni-&gt;mrec-&gt;link_count) - 1);</a>
<a name="ln1998"> </a>
<a name="ln1999">	ntfs_inode_mark_dirty(ni);</a>
<a name="ln2000">	if (looking_for_dos_name) {</a>
<a name="ln2001">		looking_for_dos_name = FALSE;</a>
<a name="ln2002">		looking_for_win32_name = TRUE;</a>
<a name="ln2003">		ntfs_attr_reinit_search_ctx(actx);</a>
<a name="ln2004">		goto search;</a>
<a name="ln2005">	}</a>
<a name="ln2006">	/* TODO: Update object id, quota and securiry indexes if required. */</a>
<a name="ln2007">	/*</a>
<a name="ln2008">	 * If hard link count is not equal to zero then we are done. In other</a>
<a name="ln2009">	 * case there are no reference to this inode left, so we should free all</a>
<a name="ln2010">	 * non-resident attributes and mark all MFT record as not in use.</a>
<a name="ln2011">	 */</a>
<a name="ln2012">#if CACHE_LOOKUP_SIZE</a>
<a name="ln2013">			/* invalidate entry in lookup cache */</a>
<a name="ln2014">	lkitem.name = (const char*)NULL;</a>
<a name="ln2015">	lkitem.namesize = 0;</a>
<a name="ln2016">	lkitem.inum = ni-&gt;mft_no;</a>
<a name="ln2017">	lkitem.parent = dir_ni-&gt;mft_no;</a>
<a name="ln2018">	ntfs_invalidate_cache(vol-&gt;lookup_cache, GENERIC(&amp;lkitem),</a>
<a name="ln2019">			lookup_cache_inv_compare, CACHE_NOHASH);</a>
<a name="ln2020">#endif</a>
<a name="ln2021">#if CACHE_INODE_SIZE</a>
<a name="ln2022">	inum = ni-&gt;mft_no;</a>
<a name="ln2023">	if (pathname) {</a>
<a name="ln2024">			/* invalide cache entry, even if there was an error */</a>
<a name="ln2025">		/* Remove leading /'s. */</a>
<a name="ln2026">		p = pathname;</a>
<a name="ln2027">		while (*p == PATH_SEP)</a>
<a name="ln2028">			p++;</a>
<a name="ln2029">		if (p[0] &amp;&amp; (p[strlen(p)-1] == PATH_SEP))</a>
<a name="ln2030">			ntfs_log_error(&quot;Unnormalized path %s\n&quot;,pathname);</a>
<a name="ln2031">		item.pathname = p;</a>
<a name="ln2032">		item.varsize = strlen(p);</a>
<a name="ln2033">	} else {</a>
<a name="ln2034">		item.pathname = (const char*)NULL;</a>
<a name="ln2035">		item.varsize = 0;</a>
<a name="ln2036">	}</a>
<a name="ln2037">	item.inum = inum;</a>
<a name="ln2038">	count = ntfs_invalidate_cache(vol-&gt;xinode_cache, GENERIC(&amp;item),</a>
<a name="ln2039">				inode_cache_inv_compare, CACHE_NOHASH);</a>
<a name="ln2040">	if (pathname &amp;&amp; !count)</a>
<a name="ln2041">		ntfs_log_error(&quot;Could not delete inode cache entry for %s\n&quot;,</a>
<a name="ln2042">			pathname);</a>
<a name="ln2043">#endif</a>
<a name="ln2044">	if (ni-&gt;mrec-&gt;link_count) {</a>
<a name="ln2045">		ntfs_inode_update_times(ni, NTFS_UPDATE_CTIME);</a>
<a name="ln2046">		goto ok;</a>
<a name="ln2047">	}</a>
<a name="ln2048">	if (ntfs_delete_reparse_index(ni)) {</a>
<a name="ln2049">		/*</a>
<a name="ln2050">		 * Failed to remove the reparse index : proceed anyway</a>
<a name="ln2051">		 * This is not a critical error, the entry is useless</a>
<a name="ln2052">		 * because of sequence_number, and stopping file deletion</a>
<a name="ln2053">		 * would be much worse as the file is not referenced now.</a>
<a name="ln2054">		 */</a>
<a name="ln2055">		err = errno;</a>
<a name="ln2056">	}</a>
<a name="ln2057">	if (ntfs_delete_object_id_index(ni)) {</a>
<a name="ln2058">		/*</a>
<a name="ln2059">		 * Failed to remove the object id index : proceed anyway</a>
<a name="ln2060">		 * This is not a critical error.</a>
<a name="ln2061">		 */</a>
<a name="ln2062">		err = errno;</a>
<a name="ln2063">	}</a>
<a name="ln2064">	ntfs_attr_reinit_search_ctx(actx);</a>
<a name="ln2065">	while (!ntfs_attrs_walk(actx)) {</a>
<a name="ln2066">		if (actx-&gt;attr-&gt;non_resident) {</a>
<a name="ln2067">			runlist *rl;</a>
<a name="ln2068"> </a>
<a name="ln2069">			rl = ntfs_mapping_pairs_decompress(ni-&gt;vol, actx-&gt;attr,</a>
<a name="ln2070">					NULL);</a>
<a name="ln2071">			if (!rl) {</a>
<a name="ln2072">				err = errno;</a>
<a name="ln2073">				ntfs_log_error(&quot;Failed to decompress runlist.  &quot;</a>
<a name="ln2074">						&quot;Leaving inconsistent metadata.\n&quot;);</a>
<a name="ln2075">				continue;</a>
<a name="ln2076">			}</a>
<a name="ln2077">			if (ntfs_cluster_free_from_rl(ni-&gt;vol, rl)) {</a>
<a name="ln2078">				err = errno;</a>
<a name="ln2079">				ntfs_log_error(&quot;Failed to free clusters.  &quot;</a>
<a name="ln2080">						&quot;Leaving inconsistent metadata.\n&quot;);</a>
<a name="ln2081">				continue;</a>
<a name="ln2082">			}</a>
<a name="ln2083">			free(rl);</a>
<a name="ln2084">		}</a>
<a name="ln2085">	}</a>
<a name="ln2086">	if (errno != ENOENT) {</a>
<a name="ln2087">		err = errno;</a>
<a name="ln2088">		ntfs_log_error(&quot;Attribute enumeration failed.  &quot;</a>
<a name="ln2089">				&quot;Probably leaving inconsistent metadata.\n&quot;);</a>
<a name="ln2090">	}</a>
<a name="ln2091">	/* All extents should be attached after attribute walk. */</a>
<a name="ln2092">#if CACHE_NIDATA_SIZE</a>
<a name="ln2093">		/*</a>
<a name="ln2094">		 * Disconnect extents before deleting them, so they are</a>
<a name="ln2095">		 * not wrongly moved to cache through the chainings</a>
<a name="ln2096">		 */</a>
<a name="ln2097">	for (i=ni-&gt;nr_extents-1; i&gt;=0; i--) {</a>
<a name="ln2098">		ni-&gt;extent_nis[i]-&gt;base_ni = (ntfs_inode*)NULL;</a>
<a name="ln2099">		ni-&gt;extent_nis[i]-&gt;nr_extents = 0;</a>
<a name="ln2100">		if (ntfs_mft_record_free(ni-&gt;vol, ni-&gt;extent_nis[i])) {</a>
<a name="ln2101">			err = errno;</a>
<a name="ln2102">			ntfs_log_error(&quot;Failed to free extent MFT record.  &quot;</a>
<a name="ln2103">					&quot;Leaving inconsistent metadata.\n&quot;);</a>
<a name="ln2104">		}</a>
<a name="ln2105">	}</a>
<a name="ln2106">	free(ni-&gt;extent_nis);</a>
<a name="ln2107">	ni-&gt;nr_extents = 0;</a>
<a name="ln2108">	ni-&gt;extent_nis = (ntfs_inode**)NULL;</a>
<a name="ln2109">#else</a>
<a name="ln2110">	while (ni-&gt;nr_extents)</a>
<a name="ln2111">		if (ntfs_mft_record_free(ni-&gt;vol, *(ni-&gt;extent_nis))) {</a>
<a name="ln2112">			err = errno;</a>
<a name="ln2113">			ntfs_log_error(&quot;Failed to free extent MFT record.  &quot;</a>
<a name="ln2114">					&quot;Leaving inconsistent metadata.\n&quot;);</a>
<a name="ln2115">		}</a>
<a name="ln2116">#endif</a>
<a name="ln2117">	debug_double_inode(ni-&gt;mft_no,0);</a>
<a name="ln2118">	if (ntfs_mft_record_free(ni-&gt;vol, ni)) {</a>
<a name="ln2119">		err = errno;</a>
<a name="ln2120">		ntfs_log_error(&quot;Failed to free base MFT record.  &quot;</a>
<a name="ln2121">				&quot;Leaving inconsistent metadata.\n&quot;);</a>
<a name="ln2122">	}</a>
<a name="ln2123">	ni = NULL;</a>
<a name="ln2124">ok:</a>
<a name="ln2125">	ntfs_inode_update_times(dir_ni, NTFS_UPDATE_MCTIME);</a>
<a name="ln2126">out:</a>
<a name="ln2127">	if (actx)</a>
<a name="ln2128">		ntfs_attr_put_search_ctx(actx);</a>
<a name="ln2129">	if (ntfs_inode_close(dir_ni) &amp;&amp; !err)</a>
<a name="ln2130">		err = errno;</a>
<a name="ln2131">	if (ntfs_inode_close(ni) &amp;&amp; !err)</a>
<a name="ln2132">		err = errno;</a>
<a name="ln2133">	if (err) {</a>
<a name="ln2134">		errno = err;</a>
<a name="ln2135">		ntfs_log_debug(&quot;Could not delete file: %s\n&quot;, strerror(errno));</a>
<a name="ln2136">		return -1;</a>
<a name="ln2137">	}</a>
<a name="ln2138">	ntfs_log_trace(&quot;Done.\n&quot;);</a>
<a name="ln2139">	return 0;</a>
<a name="ln2140">err_out:</a>
<a name="ln2141">	err = errno;</a>
<a name="ln2142">	goto out;</a>
<a name="ln2143">}</a>
<a name="ln2144"> </a>
<a name="ln2145">/**</a>
<a name="ln2146"> * ntfs_link - create hard link for file or directory</a>
<a name="ln2147"> * @ni:		ntfs inode for object to create hard link</a>
<a name="ln2148"> * @dir_ni:	ntfs inode for directory in which new link should be placed</a>
<a name="ln2149"> * @name:	unicode name of the new link</a>
<a name="ln2150"> * @name_len:	length of the name in unicode characters</a>
<a name="ln2151"> *</a>
<a name="ln2152"> * NOTE: At present we allow creating hardlinks to directories, we use them</a>
<a name="ln2153"> * in a temporary state during rename. But it's defenitely bad idea to have</a>
<a name="ln2154"> * hard links to directories as a result of operation.</a>
<a name="ln2155"> * FIXME: Create internal  __ntfs_link that allows hard links to a directories</a>
<a name="ln2156"> * and external ntfs_link that do not. Write ntfs_rename that uses __ntfs_link.</a>
<a name="ln2157"> *</a>
<a name="ln2158"> * Return 0 on success or -1 on error with errno set to the error code.</a>
<a name="ln2159"> */</a>
<a name="ln2160">static int ntfs_link_i(ntfs_inode *ni, ntfs_inode *dir_ni, const ntfschar *name,</a>
<a name="ln2161">			 u8 name_len, FILE_NAME_TYPE_FLAGS nametype)</a>
<a name="ln2162">{</a>
<a name="ln2163">	FILE_NAME_ATTR *fn = NULL;</a>
<a name="ln2164">	int fn_len, err;</a>
<a name="ln2165"> </a>
<a name="ln2166">	ntfs_log_trace(&quot;Entering.\n&quot;);</a>
<a name="ln2167"> </a>
<a name="ln2168">	if (!ni || !dir_ni || !name || !name_len ||</a>
<a name="ln2169">			ni-&gt;mft_no == dir_ni-&gt;mft_no) {</a>
<a name="ln2170">		err = EINVAL;</a>
<a name="ln2171">		ntfs_log_perror(&quot;ntfs_link wrong arguments&quot;);</a>
<a name="ln2172">		goto err_out;</a>
<a name="ln2173">	}</a>
<a name="ln2174"> </a>
<a name="ln2175">	if (NVolHideDotFiles(dir_ni-&gt;vol)) {</a>
<a name="ln2176">		/* Set hidden flag according to the latest name */</a>
<a name="ln2177">		if ((name_len &gt; 1)</a>
<a name="ln2178">		    &amp;&amp; (name[0] == const_cpu_to_le16('.'))</a>
<a name="ln2179">		    &amp;&amp; (name[1] != const_cpu_to_le16('.')))</a>
<a name="ln2180">			ni-&gt;flags |= FILE_ATTR_HIDDEN;</a>
<a name="ln2181">		else</a>
<a name="ln2182">			ni-&gt;flags &amp;= ~FILE_ATTR_HIDDEN;</a>
<a name="ln2183">	}</a>
<a name="ln2184"> </a>
<a name="ln2185">	/* Create FILE_NAME attribute. */</a>
<a name="ln2186">	fn_len = sizeof(FILE_NAME_ATTR) + name_len * sizeof(ntfschar);</a>
<a name="ln2187">	fn = ntfs_calloc(fn_len);</a>
<a name="ln2188">	if (!fn) {</a>
<a name="ln2189">		err = errno;</a>
<a name="ln2190">		goto err_out;</a>
<a name="ln2191">	}</a>
<a name="ln2192">	fn-&gt;parent_directory = MK_LE_MREF(dir_ni-&gt;mft_no,</a>
<a name="ln2193">			le16_to_cpu(dir_ni-&gt;mrec-&gt;sequence_number));</a>
<a name="ln2194">	fn-&gt;file_name_length = name_len;</a>
<a name="ln2195">	fn-&gt;file_name_type = nametype;</a>
<a name="ln2196">	fn-&gt;file_attributes = ni-&gt;flags;</a>
<a name="ln2197">	if (ni-&gt;mrec-&gt;flags &amp; MFT_RECORD_IS_DIRECTORY) {</a>
<a name="ln2198">		fn-&gt;file_attributes |= FILE_ATTR_I30_INDEX_PRESENT;</a>
<a name="ln2199">		fn-&gt;data_size = fn-&gt;allocated_size = const_cpu_to_sle64(0);</a>
<a name="ln2200">	} else {</a>
<a name="ln2201">		fn-&gt;allocated_size = cpu_to_sle64(ni-&gt;allocated_size);</a>
<a name="ln2202">		fn-&gt;data_size = cpu_to_sle64(ni-&gt;data_size);</a>
<a name="ln2203">	}</a>
<a name="ln2204">	fn-&gt;creation_time = ni-&gt;creation_time;</a>
<a name="ln2205">	fn-&gt;last_data_change_time = ni-&gt;last_data_change_time;</a>
<a name="ln2206">	fn-&gt;last_mft_change_time = ni-&gt;last_mft_change_time;</a>
<a name="ln2207">	fn-&gt;last_access_time = ni-&gt;last_access_time;</a>
<a name="ln2208">	memcpy(fn-&gt;file_name, name, name_len * sizeof(ntfschar));</a>
<a name="ln2209">	/* Add FILE_NAME attribute to index. */</a>
<a name="ln2210">	if (ntfs_index_add_filename(dir_ni, fn, MK_MREF(ni-&gt;mft_no,</a>
<a name="ln2211">			le16_to_cpu(ni-&gt;mrec-&gt;sequence_number)))) {</a>
<a name="ln2212">		err = errno;</a>
<a name="ln2213">		ntfs_log_perror(&quot;Failed to add filename to the index&quot;);</a>
<a name="ln2214">		goto err_out;</a>
<a name="ln2215">	}</a>
<a name="ln2216">	/* Add FILE_NAME attribute to inode. */</a>
<a name="ln2217">	if (ntfs_attr_add(ni, AT_FILE_NAME, AT_UNNAMED, 0, (u8*)fn, fn_len)) {</a>
<a name="ln2218">		ntfs_log_error(&quot;Failed to add FILE_NAME attribute.\n&quot;);</a>
<a name="ln2219">		err = errno;</a>
<a name="ln2220">		/* Try to remove just added attribute from index. */</a>
<a name="ln2221">		if (ntfs_index_remove(dir_ni, ni, fn, fn_len))</a>
<a name="ln2222">			goto rollback_failed;</a>
<a name="ln2223">		goto err_out;</a>
<a name="ln2224">	}</a>
<a name="ln2225">	/* Increment hard links count. */</a>
<a name="ln2226">	ni-&gt;mrec-&gt;link_count = cpu_to_le16(le16_to_cpu(</a>
<a name="ln2227">			ni-&gt;mrec-&gt;link_count) + 1);</a>
<a name="ln2228">	/* Done! */</a>
<a name="ln2229">	ntfs_inode_mark_dirty(ni);</a>
<a name="ln2230">	free(fn);</a>
<a name="ln2231">	ntfs_log_trace(&quot;Done.\n&quot;);</a>
<a name="ln2232">	return 0;</a>
<a name="ln2233">rollback_failed:</a>
<a name="ln2234">	ntfs_log_error(&quot;Rollback failed. Leaving inconsistent metadata.\n&quot;);</a>
<a name="ln2235">err_out:</a>
<a name="ln2236">	free(fn);</a>
<a name="ln2237">	errno = err;</a>
<a name="ln2238">	return -1;</a>
<a name="ln2239">}</a>
<a name="ln2240"> </a>
<a name="ln2241">int ntfs_link(ntfs_inode *ni, ntfs_inode *dir_ni, const ntfschar *name,</a>
<a name="ln2242">		u8 name_len)</a>
<a name="ln2243">{</a>
<a name="ln2244">	return (ntfs_link_i(ni, dir_ni, name, name_len, FILE_NAME_POSIX));</a>
<a name="ln2245">}</a>
<a name="ln2246"> </a>
<a name="ln2247">/*</a>
<a name="ln2248"> *		Get a parent directory from an inode entry</a>
<a name="ln2249"> *</a>
<a name="ln2250"> *	This is only used in situations where the path used to access</a>
<a name="ln2251"> *	the current file is not known for sure. The result may be different</a>
<a name="ln2252"> *	from the path when the file is linked in several parent directories.</a>
<a name="ln2253"> *</a>
<a name="ln2254"> *	Currently this is only used for translating &quot;..&quot; in the target</a>
<a name="ln2255"> *	of a Vista relative symbolic link</a>
<a name="ln2256"> */</a>
<a name="ln2257"> </a>
<a name="ln2258">ntfs_inode *ntfs_dir_parent_inode(ntfs_inode *ni)</a>
<a name="ln2259">{</a>
<a name="ln2260">	ntfs_inode *dir_ni = (ntfs_inode*)NULL;</a>
<a name="ln2261">	u64 inum;</a>
<a name="ln2262">	FILE_NAME_ATTR *fn;</a>
<a name="ln2263">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln2264"> </a>
<a name="ln2265">	if (ni-&gt;mft_no != FILE_root) {</a>
<a name="ln2266">			/* find the name in the attributes */</a>
<a name="ln2267">		ctx = ntfs_attr_get_search_ctx(ni, NULL);</a>
<a name="ln2268">		if (!ctx)</a>
<a name="ln2269">			return ((ntfs_inode*)NULL);</a>
<a name="ln2270"> </a>
<a name="ln2271">		if (!ntfs_attr_lookup(AT_FILE_NAME, AT_UNNAMED, 0,</a>
<a name="ln2272">				CASE_SENSITIVE,	0, NULL, 0, ctx)) {</a>
<a name="ln2273">			/* We know this will always be resident. */</a>
<a name="ln2274">			fn = (FILE_NAME_ATTR*)((u8*)ctx-&gt;attr +</a>
<a name="ln2275">					le16_to_cpu(ctx-&gt;attr-&gt;value_offset));</a>
<a name="ln2276">			inum = le64_to_cpu(fn-&gt;parent_directory);</a>
<a name="ln2277">			if (inum != (u64)-1) {</a>
<a name="ln2278">				dir_ni = ntfs_inode_open(ni-&gt;vol, MREF(inum));</a>
<a name="ln2279">			}</a>
<a name="ln2280">		}</a>
<a name="ln2281">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln2282">	}</a>
<a name="ln2283">	return (dir_ni);</a>
<a name="ln2284">}</a>
<a name="ln2285"> </a>
<a name="ln2286">#define MAX_DOS_NAME_LENGTH	 12</a>
<a name="ln2287"> </a>
<a name="ln2288">/*</a>
<a name="ln2289"> *		Get a DOS name for a file in designated directory</a>
<a name="ln2290"> *</a>
<a name="ln2291"> *	Not allowed if there are several non-dos names (EMLINK)</a>
<a name="ln2292"> *</a>
<a name="ln2293"> *	Returns size if found</a>
<a name="ln2294"> *		0 if not found</a>
<a name="ln2295"> *		-1 if there was an error (described by errno)</a>
<a name="ln2296"> */</a>
<a name="ln2297"> </a>
<a name="ln2298">static int get_dos_name(ntfs_inode *ni, u64 dnum, ntfschar *dosname)</a>
<a name="ln2299">{</a>
<a name="ln2300">	size_t outsize = 0;</a>
<a name="ln2301">	int namecount = 0;</a>
<a name="ln2302">	FILE_NAME_ATTR *fn;</a>
<a name="ln2303">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln2304"> </a>
<a name="ln2305">		/* find the name in the attributes */</a>
<a name="ln2306">	ctx = ntfs_attr_get_search_ctx(ni, NULL);</a>
<a name="ln2307">	if (!ctx)</a>
<a name="ln2308">		return -1;</a>
<a name="ln2309"> </a>
<a name="ln2310">	while (!ntfs_attr_lookup(AT_FILE_NAME, AT_UNNAMED, 0, CASE_SENSITIVE,</a>
<a name="ln2311">			0, NULL, 0, ctx)) {</a>
<a name="ln2312">		/* We know this will always be resident. */</a>
<a name="ln2313">		fn = (FILE_NAME_ATTR*)((u8*)ctx-&gt;attr +</a>
<a name="ln2314">				le16_to_cpu(ctx-&gt;attr-&gt;value_offset));</a>
<a name="ln2315"> </a>
<a name="ln2316">		if (fn-&gt;file_name_type != FILE_NAME_DOS)</a>
<a name="ln2317">			namecount++;</a>
<a name="ln2318">		if ((fn-&gt;file_name_type &amp; FILE_NAME_DOS)</a>
<a name="ln2319">		    &amp;&amp; (MREF_LE(fn-&gt;parent_directory) == dnum)) {</a>
<a name="ln2320">				/*</a>
<a name="ln2321">				 * Found a DOS or WIN32+DOS name for the entry</a>
<a name="ln2322">				 * copy name, after truncation for safety</a>
<a name="ln2323">				 */</a>
<a name="ln2324">			outsize = fn-&gt;file_name_length;</a>
<a name="ln2325">/* TODO : reject if name is too long ? */</a>
<a name="ln2326">			if (outsize &gt; MAX_DOS_NAME_LENGTH)</a>
<a name="ln2327">				outsize = MAX_DOS_NAME_LENGTH;</a>
<a name="ln2328">			memcpy(dosname,fn-&gt;file_name,outsize*sizeof(ntfschar));</a>
<a name="ln2329">		}</a>
<a name="ln2330">	}</a>
<a name="ln2331">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln2332">	if ((outsize &gt; 0) &amp;&amp; (namecount &gt; 1)) {</a>
<a name="ln2333">		outsize = -1;</a>
<a name="ln2334">		errno = EMLINK; /* this error implies there is a dos name */</a>
<a name="ln2335">	}</a>
<a name="ln2336">	return (outsize);</a>
<a name="ln2337">}</a>
<a name="ln2338"> </a>
<a name="ln2339"> </a>
<a name="ln2340">/*</a>
<a name="ln2341"> *		Get a long name for a file in designated directory</a>
<a name="ln2342"> *</a>
<a name="ln2343"> *	Not allowed if there are several non-dos names (EMLINK)</a>
<a name="ln2344"> *</a>
<a name="ln2345"> *	Returns size if found</a>
<a name="ln2346"> *		0 if not found</a>
<a name="ln2347"> *		-1 if there was an error (described by errno)</a>
<a name="ln2348"> */</a>
<a name="ln2349"> </a>
<a name="ln2350">static int get_long_name(ntfs_inode *ni, u64 dnum, ntfschar *longname)</a>
<a name="ln2351">{</a>
<a name="ln2352">	size_t outsize = 0;</a>
<a name="ln2353">	int namecount = 0;</a>
<a name="ln2354">	FILE_NAME_ATTR *fn;</a>
<a name="ln2355">	ntfs_attr_search_ctx *ctx;</a>
<a name="ln2356"> </a>
<a name="ln2357">		/* find the name in the attributes */</a>
<a name="ln2358">	ctx = ntfs_attr_get_search_ctx(ni, NULL);</a>
<a name="ln2359">	if (!ctx)</a>
<a name="ln2360">		return -1;</a>
<a name="ln2361"> </a>
<a name="ln2362">		/* first search for WIN32 or DOS+WIN32 names */</a>
<a name="ln2363">	while (!ntfs_attr_lookup(AT_FILE_NAME, AT_UNNAMED, 0, CASE_SENSITIVE,</a>
<a name="ln2364">			0, NULL, 0, ctx)) {</a>
<a name="ln2365">		/* We know this will always be resident. */</a>
<a name="ln2366">		fn = (FILE_NAME_ATTR*)((u8*)ctx-&gt;attr +</a>
<a name="ln2367">				le16_to_cpu(ctx-&gt;attr-&gt;value_offset));</a>
<a name="ln2368"> </a>
<a name="ln2369">		if (fn-&gt;file_name_type != FILE_NAME_DOS)</a>
<a name="ln2370">			namecount++;</a>
<a name="ln2371">		if ((fn-&gt;file_name_type &amp; FILE_NAME_WIN32)</a>
<a name="ln2372">		    &amp;&amp; (MREF_LE(fn-&gt;parent_directory) == dnum)) {</a>
<a name="ln2373">				/*</a>
<a name="ln2374">				 * Found a WIN32 or WIN32+DOS name for the entry</a>
<a name="ln2375">				 * copy name</a>
<a name="ln2376">				 */</a>
<a name="ln2377">			outsize = fn-&gt;file_name_length;</a>
<a name="ln2378">			memcpy(longname,fn-&gt;file_name,outsize*sizeof(ntfschar));</a>
<a name="ln2379">		}</a>
<a name="ln2380">	}</a>
<a name="ln2381">	if (namecount &gt; 1) {</a>
<a name="ln2382">		ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln2383">		errno = EMLINK;</a>
<a name="ln2384">		return -1;</a>
<a name="ln2385">	}</a>
<a name="ln2386">		/* if not found search for POSIX names */</a>
<a name="ln2387">	if (!outsize) {</a>
<a name="ln2388">		ntfs_attr_reinit_search_ctx(ctx);</a>
<a name="ln2389">	while (!ntfs_attr_lookup(AT_FILE_NAME, AT_UNNAMED, 0, CASE_SENSITIVE,</a>
<a name="ln2390">			0, NULL, 0, ctx)) {</a>
<a name="ln2391">		/* We know this will always be resident. */</a>
<a name="ln2392">		fn = (FILE_NAME_ATTR*)((u8*)ctx-&gt;attr +</a>
<a name="ln2393">				le16_to_cpu(ctx-&gt;attr-&gt;value_offset));</a>
<a name="ln2394"> </a>
<a name="ln2395">		if ((fn-&gt;file_name_type == FILE_NAME_POSIX)</a>
<a name="ln2396">		    &amp;&amp; (MREF_LE(fn-&gt;parent_directory) == dnum)) {</a>
<a name="ln2397">				/*</a>
<a name="ln2398">				 * Found a POSIX name for the entry</a>
<a name="ln2399">				 * copy name</a>
<a name="ln2400">				 */</a>
<a name="ln2401">			outsize = fn-&gt;file_name_length;</a>
<a name="ln2402">			memcpy(longname,fn-&gt;file_name,outsize*sizeof(ntfschar));</a>
<a name="ln2403">		}</a>
<a name="ln2404">	}</a>
<a name="ln2405">	}</a>
<a name="ln2406">	ntfs_attr_put_search_ctx(ctx);</a>
<a name="ln2407">	return (outsize);</a>
<a name="ln2408">}</a>
<a name="ln2409"> </a>
<a name="ln2410"> </a>
<a name="ln2411">/*</a>
<a name="ln2412"> *		Get the ntfs DOS name into an extended attribute</a>
<a name="ln2413"> */</a>
<a name="ln2414"> </a>
<a name="ln2415">int ntfs_get_ntfs_dos_name(ntfs_inode *ni, ntfs_inode *dir_ni,</a>
<a name="ln2416">			char *value, size_t size)</a>
<a name="ln2417">{</a>
<a name="ln2418">	int outsize = 0;</a>
<a name="ln2419">	char *outname = (char*)NULL;</a>
<a name="ln2420">	u64 dnum;</a>
<a name="ln2421">	int doslen;</a>
<a name="ln2422">	ntfschar dosname[MAX_DOS_NAME_LENGTH];</a>
<a name="ln2423"> </a>
<a name="ln2424">	dnum = dir_ni-&gt;mft_no;</a>
<a name="ln2425">	doslen = get_dos_name(ni, dnum, dosname);</a>
<a name="ln2426">	if (doslen &gt; 0) {</a>
<a name="ln2427">			/*</a>
<a name="ln2428">			 * Found a DOS name for the entry, make</a>
<a name="ln2429">			 * uppercase and encode into the buffer</a>
<a name="ln2430">			 * if there is enough space</a>
<a name="ln2431">			 */</a>
<a name="ln2432">		ntfs_name_upcase(dosname, doslen,</a>
<a name="ln2433">				ni-&gt;vol-&gt;upcase, ni-&gt;vol-&gt;upcase_len);</a>
<a name="ln2434">		outsize = ntfs_ucstombs(dosname, doslen, &amp;outname, 0);</a>
<a name="ln2435">		if (outsize &lt; 0) {</a>
<a name="ln2436">			ntfs_log_error(&quot;Cannot represent dosname in current locale.\n&quot;);</a>
<a name="ln2437">			outsize = -errno;</a>
<a name="ln2438">		} else {</a>
<a name="ln2439">			if (value &amp;&amp; (outsize &lt;= (int)size))</a>
<a name="ln2440">				memcpy(value, outname, outsize);</a>
<a name="ln2441">			else</a>
<a name="ln2442">				if (size &amp;&amp; (outsize &gt; (int)size))</a>
<a name="ln2443">					outsize = -ERANGE;</a>
<a name="ln2444">			free(outname);</a>
<a name="ln2445">		}</a>
<a name="ln2446">	} else {</a>
<a name="ln2447">		if (doslen == 0)</a>
<a name="ln2448">			errno = ENODATA;</a>
<a name="ln2449">		outsize = -errno;</a>
<a name="ln2450">	}</a>
<a name="ln2451">	return (outsize);</a>
<a name="ln2452">}</a>
<a name="ln2453"> </a>
<a name="ln2454">/*</a>
<a name="ln2455"> *		Change the name space of an existing file or directory</a>
<a name="ln2456"> *</a>
<a name="ln2457"> *	Returns the old namespace if successful</a>
<a name="ln2458"> *		-1 if an error occurred (described by errno)</a>
<a name="ln2459"> */</a>
<a name="ln2460"> </a>
<a name="ln2461">static int set_namespace(ntfs_inode *ni, ntfs_inode *dir_ni,</a>
<a name="ln2462">			const ntfschar *name, int len,</a>
<a name="ln2463">			FILE_NAME_TYPE_FLAGS nametype)</a>
<a name="ln2464">{</a>
<a name="ln2465">	ntfs_attr_search_ctx *actx;</a>
<a name="ln2466">	ntfs_index_context *icx;</a>
<a name="ln2467">	FILE_NAME_ATTR *fnx;</a>
<a name="ln2468">	FILE_NAME_ATTR *fn = NULL;</a>
<a name="ln2469">	BOOL found;</a>
<a name="ln2470">	int lkup;</a>
<a name="ln2471">	int ret;</a>
<a name="ln2472"> </a>
<a name="ln2473">	ret = -1;</a>
<a name="ln2474">	actx = ntfs_attr_get_search_ctx(ni, NULL);</a>
<a name="ln2475">	if (actx) {</a>
<a name="ln2476">		found = FALSE;</a>
<a name="ln2477">		do {</a>
<a name="ln2478">			lkup = ntfs_attr_lookup(AT_FILE_NAME, AT_UNNAMED, 0,</a>
<a name="ln2479">	                        CASE_SENSITIVE, 0, NULL, 0, actx);</a>
<a name="ln2480">			if (!lkup) {</a>
<a name="ln2481">				fn = (FILE_NAME_ATTR*)((u8*)actx-&gt;attr +</a>
<a name="ln2482">				     le16_to_cpu(actx-&gt;attr-&gt;value_offset));</a>
<a name="ln2483">				found = (MREF_LE(fn-&gt;parent_directory)</a>
<a name="ln2484">						== dir_ni-&gt;mft_no)</a>
<a name="ln2485">					&amp;&amp; !memcmp(fn-&gt;file_name, name,</a>
<a name="ln2486">						len*sizeof(ntfschar));</a>
<a name="ln2487">			}</a>
<a name="ln2488">		} while (!lkup &amp;&amp; !found);</a>
<a name="ln2489">		if (found) {</a>
<a name="ln2490">			icx = ntfs_index_ctx_get(dir_ni, NTFS_INDEX_I30, 4);</a>
<a name="ln2491">			if (icx) {</a>
<a name="ln2492">				lkup = ntfs_index_lookup((char*)fn, len, icx);</a>
<a name="ln2493">				if (!lkup &amp;&amp; icx-&gt;data &amp;&amp; icx-&gt;data_len) {</a>
<a name="ln2494">					fnx = (FILE_NAME_ATTR*)icx-&gt;data;</a>
<a name="ln2495">					ret = fn-&gt;file_name_type;</a>
<a name="ln2496">					fn-&gt;file_name_type = nametype;</a>
<a name="ln2497">					fnx-&gt;file_name_type = nametype;</a>
<a name="ln2498">					ntfs_inode_mark_dirty(ni);</a>
<a name="ln2499">					ntfs_index_entry_mark_dirty(icx);</a>
<a name="ln2500">				}</a>
<a name="ln2501">			ntfs_index_ctx_put(icx);</a>
<a name="ln2502">			}</a>
<a name="ln2503">		}</a>
<a name="ln2504">		ntfs_attr_put_search_ctx(actx);</a>
<a name="ln2505">	}</a>
<a name="ln2506">	return (ret);</a>
<a name="ln2507">}</a>
<a name="ln2508"> </a>
<a name="ln2509">/*</a>
<a name="ln2510"> *		Set a DOS name to a file and adjust name spaces</a>
<a name="ln2511"> *</a>
<a name="ln2512"> *	If the new names are collapsible (same uppercased chars) :</a>
<a name="ln2513"> *</a>
<a name="ln2514"> * - the existing DOS name or DOS+Win32 name is made Posix</a>
<a name="ln2515"> * - if it was a real DOS name, the existing long name is made DOS+Win32</a>
<a name="ln2516"> *        and the existing DOS name is deleted</a>
<a name="ln2517"> * - finally the existing long name is made DOS+Win32 unless already done</a>
<a name="ln2518"> *</a>
<a name="ln2519"> *	If the new names are not collapsible :</a>
<a name="ln2520"> *</a>
<a name="ln2521"> * - insert the short name as a DOS name</a>
<a name="ln2522"> * - delete the old long name or existing short name</a>
<a name="ln2523"> * - insert the new long name (as a Win32 or DOS+Win32 name)</a>
<a name="ln2524"> *</a>
<a name="ln2525"> * Deleting the old long name will not delete the file</a>
<a name="ln2526"> * provided the old name was in the Posix name space,</a>
<a name="ln2527"> * because the alternate name has been set before.</a>
<a name="ln2528"> *</a>
<a name="ln2529"> * The inodes of file and parent directory are always closed</a>
<a name="ln2530"> *</a>
<a name="ln2531"> * Returns 0 if successful</a>
<a name="ln2532"> *	   -1 if failed</a>
<a name="ln2533"> */</a>
<a name="ln2534"> </a>
<a name="ln2535">static int set_dos_name(ntfs_inode *ni, ntfs_inode *dir_ni,</a>
<a name="ln2536">			const ntfschar *shortname, int shortlen,</a>
<a name="ln2537">			const ntfschar *longname, int longlen,</a>
<a name="ln2538">			const ntfschar *deletename, int deletelen, BOOL existed)</a>
<a name="ln2539">{</a>
<a name="ln2540">	unsigned int linkcount;</a>
<a name="ln2541">	ntfs_volume *vol;</a>
<a name="ln2542">	BOOL collapsible;</a>
<a name="ln2543">	BOOL deleted;</a>
<a name="ln2544">	BOOL done;</a>
<a name="ln2545">	FILE_NAME_TYPE_FLAGS oldnametype;</a>
<a name="ln2546">	u64 dnum;</a>
<a name="ln2547">	u64 fnum;</a>
<a name="ln2548">	int res;</a>
<a name="ln2549"> </a>
<a name="ln2550">	res = -1;</a>
<a name="ln2551">	vol = ni-&gt;vol;</a>
<a name="ln2552">	dnum = dir_ni-&gt;mft_no;</a>
<a name="ln2553">	fnum = ni-&gt;mft_no;</a>
<a name="ln2554">				/* save initial link count */</a>
<a name="ln2555">	linkcount = le16_to_cpu(ni-&gt;mrec-&gt;link_count);</a>
<a name="ln2556"> </a>
<a name="ln2557">		/* check whether the same name may be used as DOS and WIN32 */</a>
<a name="ln2558">	collapsible = ntfs_collapsible_chars(ni-&gt;vol, shortname, shortlen,</a>
<a name="ln2559">						longname, longlen);</a>
<a name="ln2560">	if (collapsible) {</a>
<a name="ln2561">		deleted = FALSE;</a>
<a name="ln2562">		done = FALSE;</a>
<a name="ln2563">		if (existed) {</a>
<a name="ln2564">			oldnametype = set_namespace(ni, dir_ni, deletename,</a>
<a name="ln2565">					deletelen, FILE_NAME_POSIX);</a>
<a name="ln2566">			if (oldnametype == FILE_NAME_DOS) {</a>
<a name="ln2567">				if (set_namespace(ni, dir_ni, longname, longlen,</a>
<a name="ln2568">						FILE_NAME_WIN32_AND_DOS) &gt;= 0) {</a>
<a name="ln2569">					if (!ntfs_delete(vol,</a>
<a name="ln2570">						(const char*)NULL, ni, dir_ni,</a>
<a name="ln2571">						deletename, deletelen))</a>
<a name="ln2572">						res = 0;</a>
<a name="ln2573">					deleted = TRUE;</a>
<a name="ln2574">				} else</a>
<a name="ln2575">					done = TRUE;</a>
<a name="ln2576">			}</a>
<a name="ln2577">		}</a>
<a name="ln2578">		if (!deleted) {</a>
<a name="ln2579">			if (!done &amp;&amp; (set_namespace(ni, dir_ni,</a>
<a name="ln2580">					longname, longlen,</a>
<a name="ln2581">					FILE_NAME_WIN32_AND_DOS) &gt;= 0))</a>
<a name="ln2582">				res = 0;</a>
<a name="ln2583">			ntfs_inode_update_times(ni, NTFS_UPDATE_CTIME);</a>
<a name="ln2584">			ntfs_inode_update_times(dir_ni, NTFS_UPDATE_MCTIME);</a>
<a name="ln2585">			if (ntfs_inode_close_in_dir(ni,dir_ni) &amp;&amp; !res)</a>
<a name="ln2586">				res = -1;</a>
<a name="ln2587">			if (ntfs_inode_close(dir_ni) &amp;&amp; !res)</a>
<a name="ln2588">				res = -1;</a>
<a name="ln2589">		}</a>
<a name="ln2590">	} else {</a>
<a name="ln2591">		if (!ntfs_link_i(ni, dir_ni, shortname, shortlen,</a>
<a name="ln2592">				FILE_NAME_DOS)</a>
<a name="ln2593">			/* make sure a new link was recorded */</a>
<a name="ln2594">		    &amp;&amp; (le16_to_cpu(ni-&gt;mrec-&gt;link_count) &gt; linkcount)) {</a>
<a name="ln2595">			/* delete the existing long name or short name */</a>
<a name="ln2596">// is it ok to not provide the path ?</a>
<a name="ln2597">			if (!ntfs_delete(vol, (char*)NULL, ni, dir_ni,</a>
<a name="ln2598">				 deletename, deletelen)) {</a>
<a name="ln2599">			/* delete closes the inodes, so have to open again */</a>
<a name="ln2600">				dir_ni = ntfs_inode_open(vol, dnum);</a>
<a name="ln2601">				if (dir_ni) {</a>
<a name="ln2602">					ni = ntfs_inode_open(vol, fnum);</a>
<a name="ln2603">					if (ni) {</a>
<a name="ln2604">						if (!ntfs_link_i(ni, dir_ni,</a>
<a name="ln2605">							longname, longlen,</a>
<a name="ln2606">							FILE_NAME_WIN32))</a>
<a name="ln2607">							res = 0;</a>
<a name="ln2608">						if (ntfs_inode_close_in_dir(ni,</a>
<a name="ln2609">							dir_ni)</a>
<a name="ln2610">						    &amp;&amp; !res)</a>
<a name="ln2611">							res = -1;</a>
<a name="ln2612">					}</a>
<a name="ln2613">				if (ntfs_inode_close(dir_ni) &amp;&amp; !res)</a>
<a name="ln2614">					res = -1;</a>
<a name="ln2615">				}</a>
<a name="ln2616">			}</a>
<a name="ln2617">		} else {</a>
<a name="ln2618">			ntfs_inode_close_in_dir(ni,dir_ni);</a>
<a name="ln2619">			ntfs_inode_close(dir_ni);</a>
<a name="ln2620">		}</a>
<a name="ln2621">	}</a>
<a name="ln2622">	return (res);</a>
<a name="ln2623">}</a>
<a name="ln2624"> </a>
<a name="ln2625"> </a>
<a name="ln2626">/*</a>
<a name="ln2627"> *		Set the ntfs DOS name into an extended attribute</a>
<a name="ln2628"> *</a>
<a name="ln2629"> *  The DOS name will be added as another file name attribute</a>
<a name="ln2630"> *  using the existing file name information from the original</a>
<a name="ln2631"> *  name or overwriting the DOS Name if one exists.</a>
<a name="ln2632"> *</a>
<a name="ln2633"> *  	The inode of the file is always closed</a>
<a name="ln2634"> */</a>
<a name="ln2635"> </a>
<a name="ln2636">int ntfs_set_ntfs_dos_name(ntfs_inode *ni, ntfs_inode *dir_ni,</a>
<a name="ln2637">			const char *value, size_t size,	int flags)</a>
<a name="ln2638">{</a>
<a name="ln2639">	int res = 0;</a>
<a name="ln2640">	int longlen = 0;</a>
<a name="ln2641">	int shortlen = 0;</a>
<a name="ln2642">	char newname[3*MAX_DOS_NAME_LENGTH + 1];</a>
<a name="ln2643">	ntfschar oldname[MAX_DOS_NAME_LENGTH];</a>
<a name="ln2644">	int oldlen;</a>
<a name="ln2645">	u64 dnum;</a>
<a name="ln2646">	BOOL closed = FALSE;</a>
<a name="ln2647">	ntfschar *shortname = NULL;</a>
<a name="ln2648">	ntfschar longname[NTFS_MAX_NAME_LEN];</a>
<a name="ln2649"> </a>
<a name="ln2650">		/* copy the string to insert a null char, and truncate */</a>
<a name="ln2651">	if (size &gt; 3*MAX_DOS_NAME_LENGTH)</a>
<a name="ln2652">		size = 3*MAX_DOS_NAME_LENGTH;</a>
<a name="ln2653">	strncpy(newname, value, size);</a>
<a name="ln2654">		/* a long name may be truncated badly and be untranslatable */</a>
<a name="ln2655">	newname[size] = 0;</a>
<a name="ln2656">		/* convert the string to the NTFS wide chars, and truncate */</a>
<a name="ln2657">	shortlen = ntfs_mbstoucs(newname, &amp;shortname);</a>
<a name="ln2658">	if (shortlen &gt; MAX_DOS_NAME_LENGTH)</a>
<a name="ln2659">		shortlen = MAX_DOS_NAME_LENGTH;</a>
<a name="ln2660"> </a>
<a name="ln2661">	/* Make sure the short name has valid chars.</a>
<a name="ln2662">	 * Note: the short name cannot end with dot or space, but the</a>
<a name="ln2663">	 * corresponding long name can. */</a>
<a name="ln2664">	if ((shortlen &lt; 0)</a>
<a name="ln2665">	    || ntfs_forbidden_names(ni-&gt;vol,shortname,shortlen,TRUE)) {</a>
<a name="ln2666">		ntfs_inode_close_in_dir(ni,dir_ni);</a>
<a name="ln2667">		ntfs_inode_close(dir_ni);</a>
<a name="ln2668">		res = -errno;</a>
<a name="ln2669">		return res;</a>
<a name="ln2670">	}</a>
<a name="ln2671">	dnum = dir_ni-&gt;mft_no;</a>
<a name="ln2672">	longlen = get_long_name(ni, dnum, longname);</a>
<a name="ln2673">	if (longlen &gt; 0) {</a>
<a name="ln2674">		oldlen = get_dos_name(ni, dnum, oldname);</a>
<a name="ln2675">		if ((oldlen &gt;= 0)</a>
<a name="ln2676">		    &amp;&amp; !ntfs_forbidden_names(ni-&gt;vol, longname, longlen,</a>
<a name="ln2677">					     FALSE)) {</a>
<a name="ln2678">			if (oldlen &gt; 0) {</a>
<a name="ln2679">				if (flags &amp; XATTR_CREATE) {</a>
<a name="ln2680">					res = -1;</a>
<a name="ln2681">					errno = EEXIST;</a>
<a name="ln2682">				} else</a>
<a name="ln2683">					if ((shortlen == oldlen)</a>
<a name="ln2684">					    &amp;&amp; !memcmp(shortname,oldname,</a>
<a name="ln2685">						     oldlen*sizeof(ntfschar)))</a>
<a name="ln2686">						/* already set, done */</a>
<a name="ln2687">						res = 0;</a>
<a name="ln2688">					else {</a>
<a name="ln2689">						res = set_dos_name(ni, dir_ni,</a>
<a name="ln2690">							shortname, shortlen,</a>
<a name="ln2691">							longname, longlen,</a>
<a name="ln2692">							oldname, oldlen, TRUE);</a>
<a name="ln2693">						closed = TRUE;</a>
<a name="ln2694">					}</a>
<a name="ln2695">			} else {</a>
<a name="ln2696">				if (flags &amp; XATTR_REPLACE) {</a>
<a name="ln2697">					res = -1;</a>
<a name="ln2698">					errno = ENODATA;</a>
<a name="ln2699">				} else {</a>
<a name="ln2700">					res = set_dos_name(ni, dir_ni,</a>
<a name="ln2701">						shortname, shortlen,</a>
<a name="ln2702">						longname, longlen,</a>
<a name="ln2703">						longname, longlen, FALSE);</a>
<a name="ln2704">					closed = TRUE;</a>
<a name="ln2705">				}</a>
<a name="ln2706">			}</a>
<a name="ln2707">		} else</a>
<a name="ln2708">			res = -1;</a>
<a name="ln2709">	} else {</a>
<a name="ln2710">		res = -1;</a>
<a name="ln2711">		if (!longlen)</a>
<a name="ln2712">			errno = ENOENT;</a>
<a name="ln2713">	}</a>
<a name="ln2714">	free(shortname);</a>
<a name="ln2715">	if (!closed) {</a>
<a name="ln2716">		ntfs_inode_close_in_dir(ni,dir_ni);</a>
<a name="ln2717">		ntfs_inode_close(dir_ni);</a>
<a name="ln2718">	}</a>
<a name="ln2719">	return (res ? -1 : 0);</a>
<a name="ln2720">}</a>
<a name="ln2721"> </a>
<a name="ln2722">/*</a>
<a name="ln2723"> *		Delete the ntfs DOS name</a>
<a name="ln2724"> */</a>
<a name="ln2725"> </a>
<a name="ln2726">int ntfs_remove_ntfs_dos_name(ntfs_inode *ni, ntfs_inode *dir_ni)</a>
<a name="ln2727">{</a>
<a name="ln2728">	int res;</a>
<a name="ln2729">	int oldnametype;</a>
<a name="ln2730">	int longlen = 0;</a>
<a name="ln2731">	int shortlen;</a>
<a name="ln2732">	u64 dnum;</a>
<a name="ln2733">	ntfs_volume *vol;</a>
<a name="ln2734">	BOOL deleted = FALSE;</a>
<a name="ln2735">	ntfschar shortname[MAX_DOS_NAME_LENGTH];</a>
<a name="ln2736">	ntfschar longname[NTFS_MAX_NAME_LEN];</a>
<a name="ln2737"> </a>
<a name="ln2738">	res = -1;</a>
<a name="ln2739">	vol = ni-&gt;vol;</a>
<a name="ln2740">	dnum = dir_ni-&gt;mft_no;</a>
<a name="ln2741">	longlen = get_long_name(ni, dnum, longname);</a>
<a name="ln2742">	if (longlen &gt; 0) {</a>
<a name="ln2743">		shortlen = get_dos_name(ni, dnum, shortname);</a>
<a name="ln2744">		if (shortlen &gt;= 0) {</a>
<a name="ln2745">				/* migrate the long name as Posix */</a>
<a name="ln2746">			oldnametype = set_namespace(ni,dir_ni,longname,longlen,</a>
<a name="ln2747">					FILE_NAME_POSIX);</a>
<a name="ln2748">			switch (oldnametype) {</a>
<a name="ln2749">			case FILE_NAME_WIN32_AND_DOS :</a>
<a name="ln2750">				/* name was Win32+DOS : done */</a>
<a name="ln2751">				res = 0;</a>
<a name="ln2752">				break;</a>
<a name="ln2753">			case FILE_NAME_DOS :</a>
<a name="ln2754">				/* name was DOS, make it back to DOS */</a>
<a name="ln2755">				set_namespace(ni,dir_ni,longname,longlen,</a>
<a name="ln2756">						FILE_NAME_DOS);</a>
<a name="ln2757">				errno = ENOENT;</a>
<a name="ln2758">				break;</a>
<a name="ln2759">			case FILE_NAME_WIN32 :</a>
<a name="ln2760">				/* name was Win32, make it Posix and delete */</a>
<a name="ln2761">				if (set_namespace(ni,dir_ni,shortname,shortlen,</a>
<a name="ln2762">						FILE_NAME_POSIX) &gt;= 0) {</a>
<a name="ln2763">					if (!ntfs_delete(vol,</a>
<a name="ln2764">							(const char*)NULL, ni,</a>
<a name="ln2765">							dir_ni, shortname,</a>
<a name="ln2766">							shortlen))</a>
<a name="ln2767">						res = 0;</a>
<a name="ln2768">					deleted = TRUE;</a>
<a name="ln2769">				} else {</a>
<a name="ln2770">					/*</a>
<a name="ln2771">					 * DOS name has been found, but cannot</a>
<a name="ln2772">					 * migrate to Posix : something bad</a>
<a name="ln2773">					 * has happened</a>
<a name="ln2774">					 */</a>
<a name="ln2775">					errno = EIO;</a>
<a name="ln2776">					ntfs_log_error(&quot;Could not change&quot;</a>
<a name="ln2777">						&quot; DOS name of inode %lld to Posix\n&quot;,</a>
<a name="ln2778">						(long long)ni-&gt;mft_no);</a>
<a name="ln2779">				}</a>
<a name="ln2780">				break;</a>
<a name="ln2781">			default :</a>
<a name="ln2782">				/* name was Posix or not found : error */</a>
<a name="ln2783">				errno = ENOENT;</a>
<a name="ln2784">				break;</a>
<a name="ln2785">			}</a>
<a name="ln2786">		}</a>
<a name="ln2787">	} else {</a>
<a name="ln2788">		if (!longlen)</a>
<a name="ln2789">			errno = ENOENT;</a>
<a name="ln2790">		res = -1;</a>
<a name="ln2791">	}</a>
<a name="ln2792">	if (!deleted) {</a>
<a name="ln2793">		ntfs_inode_close_in_dir(ni,dir_ni);</a>
<a name="ln2794">		ntfs_inode_close(dir_ni);</a>
<a name="ln2795">	}</a>
<a name="ln2796">	return (res);</a>
<a name="ln2797">}</a>

</code></pre>
<div class="balloon" rel="254"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'dir_ni' pointer was utilized before it was verified against nullptr. Check lines: 254, 268.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
