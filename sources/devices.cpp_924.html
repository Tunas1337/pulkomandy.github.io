
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>devices.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2003-2006, Axel DÃ¶rfler, axeld@pinc-software.de.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> */</a>
<a name="ln5"> </a>
<a name="ln6"> </a>
<a name="ln7">#include &quot;bios.h&quot;</a>
<a name="ln8"> </a>
<a name="ln9">#include &lt;KernelExport.h&gt;</a>
<a name="ln10">#include &lt;boot/platform.h&gt;</a>
<a name="ln11">#include &lt;boot/partitions.h&gt;</a>
<a name="ln12">#include &lt;boot/stdio.h&gt;</a>
<a name="ln13">#include &lt;boot/stage2.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;string.h&gt;</a>
<a name="ln16"> </a>
<a name="ln17">//#define TRACE_DEVICES</a>
<a name="ln18">#ifdef TRACE_DEVICES</a>
<a name="ln19">#	define TRACE(x) dprintf x</a>
<a name="ln20">#else</a>
<a name="ln21">#	define TRACE(x) ;</a>
<a name="ln22">#endif</a>
<a name="ln23"> </a>
<a name="ln24"> </a>
<a name="ln25">// exported from shell.S</a>
<a name="ln26">extern uint8 gBootedFromImage;</a>
<a name="ln27">extern uint8 gBootDriveID;</a>
<a name="ln28">extern uint32 gBootPartitionOffset;</a>
<a name="ln29"> </a>
<a name="ln30">// int 0x13 definitions</a>
<a name="ln31">#define BIOS_RESET_DISK_SYSTEM			0x0000</a>
<a name="ln32">#define BIOS_READ						0x0200</a>
<a name="ln33">#define BIOS_GET_DRIVE_PARAMETERS		0x0800</a>
<a name="ln34">#define BIOS_IS_EXT_PRESENT				0x4100</a>
<a name="ln35">#define BIOS_EXT_READ					0x4200</a>
<a name="ln36">#define BIOS_EXT_WRITE					0x4300</a>
<a name="ln37">#define BIOS_GET_EXT_DRIVE_PARAMETERS	0x4800</a>
<a name="ln38">#define BIOS_BOOT_CD_GET_STATUS			0x4b01</a>
<a name="ln39"> </a>
<a name="ln40">struct real_addr {</a>
<a name="ln41">	uint16	offset;</a>
<a name="ln42">	uint16	segment;</a>
<a name="ln43">};</a>
<a name="ln44"> </a>
<a name="ln45">struct disk_address_packet {</a>
<a name="ln46">	uint8		size;</a>
<a name="ln47">	uint8		reserved;</a>
<a name="ln48">	uint16		number_of_blocks;</a>
<a name="ln49">	uint32		buffer;</a>
<a name="ln50">	uint64		lba;</a>
<a name="ln51">} _PACKED;</a>
<a name="ln52"> </a>
<a name="ln53">static const uint16 kParametersSizeVersion1 = 0x1a;</a>
<a name="ln54">static const uint16 kParametersSizeVersion2 = 0x1e;</a>
<a name="ln55">static const uint16 kParametersSizeVersion3 = 0x42;</a>
<a name="ln56"> </a>
<a name="ln57">static const uint16 kDevicePathSignature = 0xbedd;</a>
<a name="ln58"> </a>
<a name="ln59">struct drive_parameters {</a>
<a name="ln60">	uint16		parameters_size;</a>
<a name="ln61">	uint16		flags;</a>
<a name="ln62">	uint32		cylinders;</a>
<a name="ln63">	uint32		heads;</a>
<a name="ln64">	uint32		sectors_per_track;</a>
<a name="ln65">	uint64		sectors;</a>
<a name="ln66">	uint16		bytes_per_sector;</a>
<a name="ln67">	/* edd 2.0 */</a>
<a name="ln68">	real_addr	device_table;</a>
<a name="ln69">	/* edd 3.0 */</a>
<a name="ln70">	uint16		device_path_signature;</a>
<a name="ln71">	uint8		device_path_size;</a>
<a name="ln72">	uint8		reserved1[3];</a>
<a name="ln73">	char		host_bus[4];</a>
<a name="ln74">	char		interface_type[8];</a>
<a name="ln75">	union {</a>
<a name="ln76">		struct {</a>
<a name="ln77">			uint16	base_address;</a>
<a name="ln78">		} legacy;</a>
<a name="ln79">		struct {</a>
<a name="ln80">			uint8	bus;</a>
<a name="ln81">			uint8	slot;</a>
<a name="ln82">			uint8	function;</a>
<a name="ln83">		} pci;</a>
<a name="ln84">		uint8		reserved[8];</a>
<a name="ln85">	} interface;</a>
<a name="ln86">	union {</a>
<a name="ln87">		struct {</a>
<a name="ln88">			uint8	slave;</a>
<a name="ln89">		} ata;</a>
<a name="ln90">		struct {</a>
<a name="ln91">			uint8	slave;</a>
<a name="ln92">			uint8	logical_unit;</a>
<a name="ln93">		} atapi;</a>
<a name="ln94">		struct {</a>
<a name="ln95">			uint8	logical_unit;</a>
<a name="ln96">		} scsi;</a>
<a name="ln97">		struct {</a>
<a name="ln98">			uint8	tbd;</a>
<a name="ln99">		} usb;</a>
<a name="ln100">		struct {</a>
<a name="ln101">			uint64	guid;</a>
<a name="ln102">		} firewire;</a>
<a name="ln103">		struct {</a>
<a name="ln104">			uint64	wwd;</a>
<a name="ln105">		} fibre;</a>
<a name="ln106">	} device;</a>
<a name="ln107">	uint8		reserved2;</a>
<a name="ln108">	uint8		checksum;</a>
<a name="ln109">} _PACKED;</a>
<a name="ln110"> </a>
<a name="ln111">struct device_table {</a>
<a name="ln112">	uint16	base_address;</a>
<a name="ln113">	uint16	control_port_address;</a>
<a name="ln114">	uint8	_reserved1 : 4;</a>
<a name="ln115">	uint8	is_slave : 1;</a>
<a name="ln116">	uint8	_reserved2 : 1;</a>
<a name="ln117">	uint8	lba_enabled : 1;</a>
<a name="ln118">} _PACKED;</a>
<a name="ln119"> </a>
<a name="ln120">struct specification_packet {</a>
<a name="ln121">	uint8	size;</a>
<a name="ln122">	uint8	media_type;</a>
<a name="ln123">	uint8	drive_number;</a>
<a name="ln124">	uint8	controller_index;</a>
<a name="ln125">	uint32	start_emulation;</a>
<a name="ln126">	uint16	device_specification;</a>
<a name="ln127">	uint8	_more_[9];</a>
<a name="ln128">} _PACKED;</a>
<a name="ln129"> </a>
<a name="ln130">class BIOSDrive : public Node {</a>
<a name="ln131">	public:</a>
<a name="ln132">		BIOSDrive(uint8 driveID);</a>
<a name="ln133">		virtual ~BIOSDrive();</a>
<a name="ln134"> </a>
<a name="ln135">		status_t InitCheck() const;</a>
<a name="ln136"> </a>
<a name="ln137">		virtual ssize_t ReadAt(void *cookie, off_t pos, void *buffer, size_t bufferSize);</a>
<a name="ln138">		virtual ssize_t WriteAt(void *cookie, off_t pos, const void *buffer, size_t bufferSize);</a>
<a name="ln139"> </a>
<a name="ln140">		virtual off_t Size() const;</a>
<a name="ln141"> </a>
<a name="ln142">		uint32 BlockSize() const { return fBlockSize; }</a>
<a name="ln143"> </a>
<a name="ln144">		status_t FillIdentifier();</a>
<a name="ln145"> </a>
<a name="ln146">		bool HasParameters() const { return fHasParameters; }</a>
<a name="ln147">		const drive_parameters &amp;Parameters() const { return fParameters; }</a>
<a name="ln148"> </a>
<a name="ln149">		disk_identifier &amp;Identifier() { return fIdentifier; }</a>
<a name="ln150">		uint8 DriveID() const { return fDriveID; }</a>
<a name="ln151"> </a>
<a name="ln152">	protected:</a>
<a name="ln153">		uint8	fDriveID;</a>
<a name="ln154">		bool	fLBA;</a>
<a name="ln155">		uint64	fSize;</a>
<a name="ln156">		uint32	fBlockSize;</a>
<a name="ln157">		bool	fHasParameters;</a>
<a name="ln158">		drive_parameters fParameters;</a>
<a name="ln159">		disk_identifier fIdentifier;</a>
<a name="ln160">};</a>
<a name="ln161"> </a>
<a name="ln162"> </a>
<a name="ln163">static bool sBlockDevicesAdded = false;</a>
<a name="ln164"> </a>
<a name="ln165"> </a>
<a name="ln166">static void</a>
<a name="ln167">check_cd_boot(BIOSDrive *drive)</a>
<a name="ln168">{</a>
<a name="ln169">	gBootVolume.SetInt32(BOOT_METHOD, BOOT_METHOD_HARD_DISK);</a>
<a name="ln170"> </a>
<a name="ln171">	if (drive-&gt;DriveID() != 0)</a>
<a name="ln172">		return;</a>
<a name="ln173"> </a>
<a name="ln174">	struct bios_regs regs;</a>
<a name="ln175">	regs.eax = BIOS_BOOT_CD_GET_STATUS;</a>
<a name="ln176">	regs.edx = 0;</a>
<a name="ln177">	regs.esi = kDataSegmentScratch;</a>
<a name="ln178">	call_bios(0x13, &amp;regs);</a>
<a name="ln179"> </a>
<a name="ln180">	if ((regs.flags &amp; CARRY_FLAG) != 0)</a>
<a name="ln181">		return;</a>
<a name="ln182"> </a>
<a name="ln183">	// we obviously were booted from CD!</a>
<a name="ln184"> </a>
<a name="ln185">	specification_packet *packet = (specification_packet *)kDataSegmentScratch;</a>
<a name="ln186">	if (packet-&gt;media_type != 0)</a>
<a name="ln187">		gBootVolume.SetInt32(BOOT_METHOD, BOOT_METHOD_CD);</a>
<a name="ln188"> </a>
<a name="ln189">#if 0</a>
<a name="ln190">	dprintf(&quot;got CD boot spec:\n&quot;);</a>
<a name="ln191">	dprintf(&quot;  size: %#x\n&quot;, packet-&gt;size);</a>
<a name="ln192">	dprintf(&quot;  media type: %u\n&quot;, packet-&gt;media_type);</a>
<a name="ln193">	dprintf(&quot;  drive_number: %u\n&quot;, packet-&gt;drive_number);</a>
<a name="ln194">	dprintf(&quot;  controller index: %u\n&quot;, packet-&gt;controller_index);</a>
<a name="ln195">	dprintf(&quot;  start emulation: %lu\n&quot;, packet-&gt;start_emulation);</a>
<a name="ln196">	dprintf(&quot;  device_specification: %u\n&quot;, packet-&gt;device_specification);</a>
<a name="ln197">#endif</a>
<a name="ln198">}</a>
<a name="ln199"> </a>
<a name="ln200"> </a>
<a name="ln201">static bool</a>
<a name="ln202">are_extensions_available(uint8 drive)</a>
<a name="ln203">{</a>
<a name="ln204">	struct bios_regs regs;</a>
<a name="ln205">	regs.eax = BIOS_IS_EXT_PRESENT;</a>
<a name="ln206">	regs.ebx = 0x55aa;</a>
<a name="ln207">	regs.edx = drive;</a>
<a name="ln208">	call_bios(0x13, &amp;regs);</a>
<a name="ln209"> </a>
<a name="ln210">	TRACE((&quot;checking extensions: carry: %u; ebx: 0x%08lx; ecx: 0x%08lx\n&quot;,</a>
<a name="ln211">		regs.flags &amp; CARRY_FLAG, regs.ebx, regs.ecx));</a>
<a name="ln212">	return (regs.flags &amp; CARRY_FLAG) == 0 &amp;&amp; regs.ebx == 0xaa55</a>
<a name="ln213">		&amp;&amp; (regs.ecx &amp; 0x01 /* supports device access using packet */) != 0;</a>
<a name="ln214">}</a>
<a name="ln215"> </a>
<a name="ln216"> </a>
<a name="ln217">static status_t</a>
<a name="ln218">get_ext_drive_parameters(uint8 drive, drive_parameters *targetParameters)</a>
<a name="ln219">{</a>
<a name="ln220">	drive_parameters *parameter = (drive_parameters *)kDataSegmentScratch;</a>
<a name="ln221"> </a>
<a name="ln222">	memset(parameter, 0, sizeof(drive_parameters));</a>
<a name="ln223">	parameter-&gt;parameters_size = sizeof(drive_parameters);</a>
<a name="ln224"> </a>
<a name="ln225">	struct bios_regs regs;</a>
<a name="ln226">	regs.eax = BIOS_GET_EXT_DRIVE_PARAMETERS;</a>
<a name="ln227">	regs.edx = drive;</a>
<a name="ln228">	regs.esi = (addr_t)parameter - kDataSegmentBase;</a>
<a name="ln229">	call_bios(0x13, &amp;regs);</a>
<a name="ln230"> </a>
<a name="ln231">	// filter out faulty BIOS return codes</a>
<a name="ln232">	if ((regs.flags &amp; CARRY_FLAG) != 0</a>
<a name="ln233">		|| parameter-&gt;sectors == 0)</a>
<a name="ln234">		return B_ERROR;</a>
<a name="ln235"> </a>
<a name="ln236">	memcpy(targetParameters, parameter, sizeof(drive_parameters));</a>
<a name="ln237">	return B_OK;</a>
<a name="ln238">}</a>
<a name="ln239"> </a>
<a name="ln240"> </a>
<a name="ln241">static status_t</a>
<a name="ln242">get_drive_parameters(uint8 drive, drive_parameters *parameters)</a>
<a name="ln243">{</a>
<a name="ln244">	struct bios_regs regs;</a>
<a name="ln245">	regs.eax = BIOS_GET_DRIVE_PARAMETERS;</a>
<a name="ln246">	regs.edx = drive;</a>
<a name="ln247">	regs.es = 0;</a>
<a name="ln248">	regs.edi = 0;	// guard against faulty BIOS, see Ralf Brown's interrupt list</a>
<a name="ln249">	call_bios(0x13, &amp;regs);</a>
<a name="ln250"> </a>
<a name="ln251">	if ((regs.flags &amp; CARRY_FLAG) != 0 || (regs.ecx &amp; 0x3f) == 0)</a>
<a name="ln252">		return B_ERROR;</a>
<a name="ln253"> </a>
<a name="ln254">	// fill drive_parameters structure with useful values</a>
<a name="ln255">	parameters-&gt;parameters_size = kParametersSizeVersion1;</a>
<a name="ln256">	parameters-&gt;flags = 0;</a>
<a name="ln257">	parameters-&gt;cylinders = (((regs.ecx &amp; 0xc0) &lt;&lt; 2) | ((regs.ecx &gt;&gt; 8) &amp; 0xff)) + 1;</a>
<a name="ln258">	parameters-&gt;heads = ((regs.edx &gt;&gt; 8) &amp; 0xff) + 1;</a>
<a name="ln259">		// heads and cylinders start counting from 0</a>
<a name="ln260">	parameters-&gt;sectors_per_track = regs.ecx &amp; 0x3f;</a>
<a name="ln261">	parameters-&gt;sectors = parameters-&gt;cylinders * parameters-&gt;heads</a>
<a name="ln262">		* parameters-&gt;sectors_per_track;</a>
<a name="ln263">	parameters-&gt;bytes_per_sector = 512;</a>
<a name="ln264"> </a>
<a name="ln265">	return B_OK;</a>
<a name="ln266">}</a>
<a name="ln267"> </a>
<a name="ln268"> </a>
<a name="ln269">static status_t</a>
<a name="ln270">get_number_of_drives(uint8 *_count)</a>
<a name="ln271">{</a>
<a name="ln272">	struct bios_regs regs;</a>
<a name="ln273">	regs.eax = BIOS_GET_DRIVE_PARAMETERS;</a>
<a name="ln274">	regs.edx = 0x80;</a>
<a name="ln275">	regs.es = 0;</a>
<a name="ln276">	regs.edi = 0;</a>
<a name="ln277">	call_bios(0x13, &amp;regs);</a>
<a name="ln278"> </a>
<a name="ln279">	if (regs.flags &amp; CARRY_FLAG)</a>
<a name="ln280">		return B_ERROR;</a>
<a name="ln281"> </a>
<a name="ln282">	*_count = regs.edx &amp; 0xff;</a>
<a name="ln283">	return B_OK;</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286"> </a>
<a name="ln287">/** parse EDD 3.0 drive path information */</a>
<a name="ln288"> </a>
<a name="ln289">static status_t</a>
<a name="ln290">fill_disk_identifier_v3(disk_identifier &amp;disk, const drive_parameters &amp;parameters)</a>
<a name="ln291">{</a>
<a name="ln292">	if (parameters.parameters_size &lt; kParametersSizeVersion3</a>
<a name="ln293">		|| parameters.device_path_signature != kDevicePathSignature)</a>
<a name="ln294">		return B_BAD_TYPE;</a>
<a name="ln295"> </a>
<a name="ln296">	// parse host bus</a>
<a name="ln297"> </a>
<a name="ln298">	if (!strncmp(parameters.host_bus, &quot;PCI&quot;, 3)) {</a>
<a name="ln299">		disk.bus_type = PCI_BUS;</a>
<a name="ln300"> </a>
<a name="ln301">		disk.bus.pci.bus = parameters.interface.pci.bus;</a>
<a name="ln302">		disk.bus.pci.slot = parameters.interface.pci.slot;</a>
<a name="ln303">		disk.bus.pci.function = parameters.interface.pci.function;</a>
<a name="ln304">	} else if (!strncmp(parameters.host_bus, &quot;ISA&quot;, 3)) {</a>
<a name="ln305">		disk.bus_type = LEGACY_BUS;</a>
<a name="ln306"> </a>
<a name="ln307">		disk.bus.legacy.base_address = parameters.interface.legacy.base_address;</a>
<a name="ln308">		dprintf(&quot;legacy base address %x\n&quot;, disk.bus.legacy.base_address);</a>
<a name="ln309">	} else {</a>
<a name="ln310">		dprintf(&quot;unknown host bus \&quot;%s\&quot;\n&quot;, parameters.host_bus);</a>
<a name="ln311">		return B_BAD_DATA;</a>
<a name="ln312">	}</a>
<a name="ln313"> </a>
<a name="ln314">	// parse interface</a>
<a name="ln315"> </a>
<a name="ln316">	if (!strncmp(parameters.interface_type, &quot;ATA&quot;, 3)) {</a>
<a name="ln317">		disk.device_type = ATA_DEVICE;</a>
<a name="ln318">		disk.device.ata.master = !parameters.device.ata.slave;</a>
<a name="ln319">		dprintf(&quot;ATA device, %s\n&quot;, disk.device.ata.master ? &quot;master&quot; : &quot;slave&quot;);</a>
<a name="ln320">	} else if (!strncmp(parameters.interface_type, &quot;ATAPI&quot;, 3)) {</a>
<a name="ln321">		disk.device_type = ATAPI_DEVICE;</a>
<a name="ln322">		disk.device.atapi.master = !parameters.device.ata.slave;</a>
<a name="ln323">		disk.device.atapi.logical_unit = parameters.device.atapi.logical_unit;</a>
<a name="ln324">	} else if (!strncmp(parameters.interface_type, &quot;SCSI&quot;, 3)) {</a>
<a name="ln325">		disk.device_type = SCSI_DEVICE;</a>
<a name="ln326">		disk.device.scsi.logical_unit = parameters.device.scsi.logical_unit;</a>
<a name="ln327">	} else if (!strncmp(parameters.interface_type, &quot;USB&quot;, 3)) {</a>
<a name="ln328">		disk.device_type = USB_DEVICE;</a>
<a name="ln329">		disk.device.usb.tbd = parameters.device.usb.tbd;</a>
<a name="ln330">	} else if (!strncmp(parameters.interface_type, &quot;1394&quot;, 3)) {</a>
<a name="ln331">		disk.device_type = FIREWIRE_DEVICE;</a>
<a name="ln332">		disk.device.firewire.guid = parameters.device.firewire.guid;</a>
<a name="ln333">	} else if (!strncmp(parameters.interface_type, &quot;FIBRE&quot;, 3)) {</a>
<a name="ln334">		disk.device_type = FIBRE_DEVICE;</a>
<a name="ln335">		disk.device.fibre.wwd = parameters.device.fibre.wwd;</a>
<a name="ln336">	} else {</a>
<a name="ln337">		dprintf(&quot;unknown interface type \&quot;%s\&quot;\n&quot;, parameters.interface_type);</a>
<a name="ln338">		return B_BAD_DATA;</a>
<a name="ln339">	}</a>
<a name="ln340"> </a>
<a name="ln341">	return B_OK;</a>
<a name="ln342">}</a>
<a name="ln343"> </a>
<a name="ln344"> </a>
<a name="ln345">/** EDD 2.0 drive table information */</a>
<a name="ln346"> </a>
<a name="ln347">static status_t</a>
<a name="ln348">fill_disk_identifier_v2(disk_identifier &amp;disk, const drive_parameters &amp;parameters)</a>
<a name="ln349">{</a>
<a name="ln350">	if (parameters.device_table.segment == 0xffff</a>
<a name="ln351">		&amp;&amp; parameters.device_table.offset == 0xffff)</a>
<a name="ln352">		return B_BAD_TYPE;</a>
<a name="ln353"> </a>
<a name="ln354">	device_table *table = (device_table *)LINEAR_ADDRESS(parameters.device_table.segment,</a>
<a name="ln355">		parameters.device_table.offset);</a>
<a name="ln356"> </a>
<a name="ln357">	disk.bus_type = LEGACY_BUS;</a>
<a name="ln358">	disk.bus.legacy.base_address = table-&gt;base_address;</a>
<a name="ln359"> </a>
<a name="ln360">	disk.device_type = ATA_DEVICE;</a>
<a name="ln361">	disk.device.ata.master = !table-&gt;is_slave;</a>
<a name="ln362"> </a>
<a name="ln363">	return B_OK;</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366"> </a>
<a name="ln367">static off_t</a>
<a name="ln368">get_next_check_sum_offset(int32 index, off_t maxSize)</a>
<a name="ln369">{</a>
<a name="ln370">	// The boot block often contains the disk superblock, and should be</a>
<a name="ln371">	// unique enough for most cases</a>
<a name="ln372">	if (index &lt; 2)</a>
<a name="ln373">		return index * 512;</a>
<a name="ln374"> </a>
<a name="ln375">	// Try some data in the first part of the drive</a>
<a name="ln376">	if (index &lt; 4)</a>
<a name="ln377">		return (maxSize &gt;&gt; 10) + index * 2048;</a>
<a name="ln378"> </a>
<a name="ln379">	// Some random value might do</a>
<a name="ln380">	return ((system_time() + index) % (maxSize &gt;&gt; 9)) * 512;</a>
<a name="ln381">}</a>
<a name="ln382"> </a>
<a name="ln383"> </a>
<a name="ln384">/**	Computes a check sum for the specified block.</a>
<a name="ln385"> *	The check sum is the sum of all data in that block interpreted as an</a>
<a name="ln386"> *	array of uint32 values.</a>
<a name="ln387"> *	Note, this must use the same method as the one used in kernel/fs/vfs_boot.cpp.</a>
<a name="ln388"> */</a>
<a name="ln389"> </a>
<a name="ln390">static uint32</a>
<a name="ln391">compute_check_sum(BIOSDrive *drive, off_t offset)</a>
<a name="ln392">{</a>
<a name="ln393">	char buffer[512];</a>
<a name="ln394">	ssize_t bytesRead = drive-&gt;ReadAt(NULL, offset, buffer, sizeof(buffer));</a>
<a name="ln395">	if (bytesRead &lt; B_OK)</a>
<a name="ln396">		return 0;</a>
<a name="ln397"> </a>
<a name="ln398">	if (bytesRead &lt; (ssize_t)sizeof(buffer))</a>
<a name="ln399">		memset(buffer + bytesRead, 0, sizeof(buffer) - bytesRead);</a>
<a name="ln400"> </a>
<a name="ln401">	uint32 *array = (uint32 *)buffer;</a>
<a name="ln402">	uint32 sum = 0;</a>
<a name="ln403"> </a>
<a name="ln404">	for (uint32 i = 0; i &lt; (bytesRead + sizeof(uint32) - 1) / sizeof(uint32); i++) {</a>
<a name="ln405">		sum += array[i];</a>
<a name="ln406">	}</a>
<a name="ln407"> </a>
<a name="ln408">	return sum;</a>
<a name="ln409">}</a>
<a name="ln410"> </a>
<a name="ln411">/**	Checks if the specified drive is usable for reading.</a>
<a name="ln412"> */</a>
<a name="ln413"> </a>
<a name="ln414">static bool</a>
<a name="ln415">is_drive_readable(BIOSDrive *drive)</a>
<a name="ln416">{</a>
<a name="ln417">	char buffer;</a>
<a name="ln418">	return drive-&gt;ReadAt(NULL, 0, &amp;buffer, sizeof(buffer)) &gt; 0;</a>
<a name="ln419">}</a>
<a name="ln420"> </a>
<a name="ln421"> </a>
<a name="ln422">static void</a>
<a name="ln423">find_unique_check_sums(NodeList *devices)</a>
<a name="ln424">{</a>
<a name="ln425">	NodeIterator iterator = devices-&gt;GetIterator();</a>
<a name="ln426">	Node *device;</a>
<a name="ln427">	int32 index = 0;</a>
<a name="ln428">	off_t minSize = 0;</a>
<a name="ln429">	const int32 kMaxTries = 200;</a>
<a name="ln430"> </a>
<a name="ln431">	while (index &lt; kMaxTries) {</a>
<a name="ln432">		bool clash = false;</a>
<a name="ln433"> </a>
<a name="ln434">		iterator.Rewind();</a>
<a name="ln435"> </a>
<a name="ln436">		while ((device = iterator.Next()) != NULL) {</a>
<a name="ln437">			BIOSDrive *drive = (BIOSDrive *)device;</a>
<a name="ln438">#if 0</a>
<a name="ln439">			// there is no RTTI in the boot loader...</a>
<a name="ln440">			BIOSDrive *drive = dynamic_cast&lt;BIOSDrive *&gt;(device);</a>
<a name="ln441">			if (drive == NULL)</a>
<a name="ln442">				continue;</a>
<a name="ln443">#endif</a>
<a name="ln444"> </a>
<a name="ln445">			// TODO: currently, we assume that the BIOS provided us with unique</a>
<a name="ln446">			//	disk identifiers... hopefully this is a good idea</a>
<a name="ln447">			if (drive-&gt;Identifier().device_type != UNKNOWN_DEVICE)</a>
<a name="ln448">				continue;</a>
<a name="ln449"> </a>
<a name="ln450">			if (minSize == 0 || drive-&gt;Size() &lt; minSize)</a>
<a name="ln451">				minSize = drive-&gt;Size();</a>
<a name="ln452"> </a>
<a name="ln453">			// check for clashes</a>
<a name="ln454"> </a>
<a name="ln455">			NodeIterator compareIterator = devices-&gt;GetIterator();</a>
<a name="ln456">			while ((device = compareIterator.Next()) != NULL) {</a>
<a name="ln457">				BIOSDrive *compareDrive = (BIOSDrive *)device;</a>
<a name="ln458"> </a>
<a name="ln459">				if (compareDrive == drive</a>
<a name="ln460">					|| compareDrive-&gt;Identifier().device_type != UNKNOWN_DEVICE)</a>
<a name="ln461">					continue;</a>
<a name="ln462"> </a>
<a name="ln463">// TODO: Until we can actually get and compare *all* fields of the disk</a>
<a name="ln464">// identifier in the kernel, we cannot compare the whole structure (we also</a>
<a name="ln465">// should be more careful zeroing the structure before we fill it).</a>
<a name="ln466">#if 0</a>
<a name="ln467">				if (!memcmp(&amp;drive-&gt;Identifier(), &amp;compareDrive-&gt;Identifier(),</a>
<a name="ln468">						sizeof(disk_identifier))) {</a>
<a name="ln469">					clash = true;</a>
<a name="ln470">					break;</a>
<a name="ln471">				}</a>
<a name="ln472">#else</a>
<a name="ln473">				const disk_identifier&amp; ourId = drive-&gt;Identifier();</a>
<a name="ln474">				const disk_identifier&amp; otherId = compareDrive-&gt;Identifier();</a>
<a name="ln475">				if (memcmp(&amp;ourId.device.unknown.check_sums,</a>
<a name="ln476">						&amp;otherId.device.unknown.check_sums,</a>
<a name="ln477">						sizeof(ourId.device.unknown.check_sums)) == 0) {</a>
<a name="ln478">					clash = true;</a>
<a name="ln479">				}</a>
<a name="ln480">#endif</a>
<a name="ln481">			}</a>
<a name="ln482"> </a>
<a name="ln483">			if (clash)</a>
<a name="ln484">				break;</a>
<a name="ln485">		}</a>
<a name="ln486"> </a>
<a name="ln487">		if (!clash) {</a>
<a name="ln488">			// our work here is done.</a>
<a name="ln489">			return;</a>
<a name="ln490">		}</a>
<a name="ln491"> </a>
<a name="ln492">		// add a new block to the check sums</a>
<a name="ln493"> </a>
<a name="ln494">		off_t offset = get_next_check_sum_offset(index, minSize);</a>
<a name="ln495">		int32 i = index % NUM_DISK_CHECK_SUMS;</a>
<a name="ln496">		iterator.Rewind();</a>
<a name="ln497"> </a>
<a name="ln498">		while ((device = iterator.Next()) != NULL) {</a>
<a name="ln499">			BIOSDrive *drive = (BIOSDrive *)device;</a>
<a name="ln500"> </a>
<a name="ln501">			disk_identifier&amp; disk = drive-&gt;Identifier();</a>
<a name="ln502">			disk.device.unknown.check_sums[i].offset = offset;</a>
<a name="ln503">			disk.device.unknown.check_sums[i].sum = compute_check_sum(drive, offset);</a>
<a name="ln504"> </a>
<a name="ln505">			TRACE((&quot;disk %x, offset %Ld, sum %lu\n&quot;, drive-&gt;DriveID(), offset,</a>
<a name="ln506">				disk.device.unknown.check_sums[i].sum));</a>
<a name="ln507">		}</a>
<a name="ln508"> </a>
<a name="ln509">		index++;</a>
<a name="ln510">	}</a>
<a name="ln511"> </a>
<a name="ln512">	// If we get here, we couldn't find a way to differentiate all disks from each other.</a>
<a name="ln513">	// It's very likely that one disk is an exact copy of the other, so there is nothing</a>
<a name="ln514">	// we could do, anyway.</a>
<a name="ln515"> </a>
<a name="ln516">	dprintf(&quot;Could not make BIOS drives unique! Might boot from the wrong disk...\n&quot;);</a>
<a name="ln517">}</a>
<a name="ln518"> </a>
<a name="ln519"> </a>
<a name="ln520">static status_t</a>
<a name="ln521">add_block_devices(NodeList *devicesList, bool identifierMissing)</a>
<a name="ln522">{</a>
<a name="ln523">	if (sBlockDevicesAdded)</a>
<a name="ln524">		return B_OK;</a>
<a name="ln525"> </a>
<a name="ln526">	uint8 driveCount;</a>
<a name="ln527">	if (get_number_of_drives(&amp;driveCount) != B_OK)</a>
<a name="ln528">		return B_ERROR;</a>
<a name="ln529"> </a>
<a name="ln530">	dprintf(&quot;number of drives: %d\n&quot;, driveCount);</a>
<a name="ln531"> </a>
<a name="ln532">	for (int32 i = 0; i &lt; driveCount; i++) {</a>
<a name="ln533">		uint8 driveID = i + 0x80;</a>
<a name="ln534">		if (driveID == gBootDriveID)</a>
<a name="ln535">			continue;</a>
<a name="ln536"> </a>
<a name="ln537">		BIOSDrive *drive = new(nothrow) BIOSDrive(driveID);</a>
<a name="ln538">		if (drive-&gt;InitCheck() != B_OK) {</a>
<a name="ln539">			dprintf(&quot;could not add drive %u\n&quot;, driveID);</a>
<a name="ln540">			delete drive;</a>
<a name="ln541">			continue;</a>
<a name="ln542">		}</a>
<a name="ln543"> </a>
<a name="ln544">		// Only add usable drives</a>
<a name="ln545">		if (is_drive_readable(drive))</a>
<a name="ln546">			devicesList-&gt;Add(drive);</a>
<a name="ln547">		else {</a>
<a name="ln548">			dprintf(&quot;could not read from drive %&quot; B_PRIu8 &quot;, not adding\n&quot;, driveID);</a>
<a name="ln549">			delete drive;</a>
<a name="ln550">			continue;</a>
<a name="ln551">		}</a>
<a name="ln552"> </a>
<a name="ln553">		if (drive-&gt;FillIdentifier() != B_OK)</a>
<a name="ln554">			identifierMissing = true;</a>
<a name="ln555">	}</a>
<a name="ln556"> </a>
<a name="ln557">	if (identifierMissing) {</a>
<a name="ln558">		// we cannot distinguish between all drives by identifier, we need</a>
<a name="ln559">		// compute checksums for them</a>
<a name="ln560">		find_unique_check_sums(devicesList);</a>
<a name="ln561">	}</a>
<a name="ln562"> </a>
<a name="ln563">	sBlockDevicesAdded = true;</a>
<a name="ln564">	return B_OK;</a>
<a name="ln565">}</a>
<a name="ln566"> </a>
<a name="ln567"> </a>
<a name="ln568">//	#pragma mark -</a>
<a name="ln569"> </a>
<a name="ln570"> </a>
<a name="ln571">BIOSDrive::BIOSDrive(uint8 driveID)</a>
<a name="ln572">	:</a>
<a name="ln573">	fDriveID(driveID),</a>
<a name="ln574">	fSize(0)</a>
<a name="ln575">{</a>
<a name="ln576">	TRACE((&quot;drive ID %u\n&quot;, driveID));</a>
<a name="ln577"> </a>
<a name="ln578">	if (driveID &lt; 0x80 || !are_extensions_available(driveID)</a>
<a name="ln579">		|| get_ext_drive_parameters(driveID, &amp;fParameters) != B_OK) {</a>
<a name="ln580">		// old style CHS support</a>
<a name="ln581"> </a>
<a name="ln582">		if (get_drive_parameters(driveID, &amp;fParameters) != B_OK) {</a>
<a name="ln583">			dprintf(&quot;getting drive parameters for: %u failed!\n&quot;, fDriveID);</a>
<a name="ln584">			return;</a>
<a name="ln585">		}</a>
<a name="ln586"> </a>
<a name="ln587">		TRACE((&quot;  cylinders: %lu, heads: %lu, sectors: %lu, bytes_per_sector: %u\n&quot;,</a>
<a name="ln588">			fParameters.cylinders, fParameters.heads, fParameters.sectors_per_track,</a>
<a name="ln589">			fParameters.bytes_per_sector));</a>
<a name="ln590">		TRACE((&quot;  total sectors: %Ld\n&quot;, fParameters.sectors));</a>
<a name="ln591"> </a>
<a name="ln592">		fBlockSize = 512;</a>
<a name="ln593">		fSize = fParameters.sectors * fBlockSize;</a>
<a name="ln594">		fLBA = false;</a>
<a name="ln595">		fHasParameters = false;</a>
<a name="ln596">	} else {</a>
<a name="ln597">		TRACE((&quot;size: %x\n&quot;, fParameters.parameters_size));</a>
<a name="ln598">		TRACE((&quot;drive_path_signature: %x\n&quot;, fParameters.device_path_signature));</a>
<a name="ln599">		TRACE((&quot;host bus: \&quot;%s\&quot;, interface: \&quot;%s\&quot;\n&quot;, fParameters.host_bus,</a>
<a name="ln600">			fParameters.interface_type));</a>
<a name="ln601">		TRACE((&quot;cylinders: %lu, heads: %lu, sectors: %lu, bytes_per_sector: %u\n&quot;,</a>
<a name="ln602">			fParameters.cylinders, fParameters.heads, fParameters.sectors_per_track,</a>
<a name="ln603">			fParameters.bytes_per_sector));</a>
<a name="ln604">		TRACE((&quot;total sectors: %Ld\n&quot;, fParameters.sectors));</a>
<a name="ln605"> </a>
<a name="ln606">		fBlockSize = fParameters.bytes_per_sector;</a>
<a name="ln607">		fSize = fParameters.sectors * fBlockSize;</a>
<a name="ln608">		fLBA = true;</a>
<a name="ln609">		fHasParameters = true;</a>
<a name="ln610">	}</a>
<a name="ln611">}</a>
<a name="ln612"> </a>
<a name="ln613"> </a>
<a name="ln614">BIOSDrive::~BIOSDrive()</a>
<a name="ln615">{</a>
<a name="ln616">}</a>
<a name="ln617"> </a>
<a name="ln618"> </a>
<a name="ln619">status_t</a>
<a name="ln620">BIOSDrive::InitCheck() const</a>
<a name="ln621">{</a>
<a name="ln622">	return fSize &gt; 0 ? B_OK : B_ERROR;</a>
<a name="ln623">}</a>
<a name="ln624"> </a>
<a name="ln625"> </a>
<a name="ln626">ssize_t</a>
<a name="ln627">BIOSDrive::ReadAt(void *cookie, off_t pos, void *buffer, size_t bufferSize)</a>
<a name="ln628">{</a>
<a name="ln629">	uint32 offset = pos % fBlockSize;</a>
<a name="ln630">	pos /= fBlockSize;</a>
<a name="ln631"> </a>
<a name="ln632">	uint32 blocksLeft = (bufferSize + offset + fBlockSize - 1) / fBlockSize;</a>
<a name="ln633">	int32 totalBytesRead = 0;</a>
<a name="ln634"> </a>
<a name="ln635">	//TRACE((&quot;BIOS reads %lu bytes from %Ld (offset = %lu), drive %u\n&quot;,</a>
<a name="ln636">	//	blocksLeft * fBlockSize, pos * fBlockSize, offset, fDriveID));</a>
<a name="ln637"> </a>
<a name="ln638">	uint32 scratchSize = 24 * 1024 / fBlockSize;</a>
<a name="ln639">		// maximum value allowed by Phoenix BIOS is 0x7f</a>
<a name="ln640"> </a>
<a name="ln641">	while (blocksLeft &gt; 0) {</a>
<a name="ln642">		uint32 blocksRead = blocksLeft;</a>
<a name="ln643">		if (blocksRead &gt; scratchSize)</a>
<a name="ln644">			blocksRead = scratchSize;</a>
<a name="ln645"> </a>
<a name="ln646">		if (fLBA) {</a>
<a name="ln647">			struct disk_address_packet *packet = (disk_address_packet *)kDataSegmentScratch;</a>
<a name="ln648">			memset(packet, 0, sizeof(disk_address_packet));</a>
<a name="ln649"> </a>
<a name="ln650">			packet-&gt;size = sizeof(disk_address_packet);</a>
<a name="ln651">			packet-&gt;number_of_blocks = blocksRead;</a>
<a name="ln652">			packet-&gt;buffer = kExtraSegmentScratch;</a>
<a name="ln653">			packet-&gt;lba = pos;</a>
<a name="ln654"> </a>
<a name="ln655">			struct bios_regs regs;</a>
<a name="ln656">			regs.eax = BIOS_EXT_READ;</a>
<a name="ln657">			regs.edx = fDriveID;</a>
<a name="ln658">			regs.esi = (addr_t)packet - kDataSegmentBase;</a>
<a name="ln659">			call_bios(0x13, &amp;regs);</a>
<a name="ln660"> </a>
<a name="ln661">			if (regs.flags &amp; CARRY_FLAG)</a>
<a name="ln662">				goto chs_read;</a>
<a name="ln663">		} else {</a>
<a name="ln664">	chs_read:</a>
<a name="ln665">			// Old style CHS read routine</a>
<a name="ln666"> </a>
<a name="ln667">			// We can only read up to 64 kB this way, but since scratchSize</a>
<a name="ln668">			// is actually lower than this value, we don't have to take care</a>
<a name="ln669">			// of this here.</a>
<a name="ln670"> </a>
<a name="ln671">			uint32 sector = pos % fParameters.sectors_per_track + 1;</a>
<a name="ln672">				// sectors start countint at 1 (unlike head and cylinder)</a>
<a name="ln673">			uint32 head = pos / fParameters.sectors_per_track;</a>
<a name="ln674">			uint32 cylinder = head / fParameters.heads;</a>
<a name="ln675">			head %= fParameters.heads;</a>
<a name="ln676"> </a>
<a name="ln677">			if (cylinder &gt;= fParameters.cylinders) {</a>
<a name="ln678">				TRACE((&quot;cylinder value %lu bigger than available %lu\n&quot;,</a>
<a name="ln679">					cylinder, fParameters.cylinders));</a>
<a name="ln680">				return B_BAD_VALUE;</a>
<a name="ln681">			}</a>
<a name="ln682"> </a>
<a name="ln683">			// try to read from the device more than once, just to make sure it'll work</a>
<a name="ln684">			struct bios_regs regs;</a>
<a name="ln685">			int32 tries = 3;</a>
<a name="ln686">			bool readWorked = false;</a>
<a name="ln687"> </a>
<a name="ln688">			while (tries-- &gt; 0) {</a>
<a name="ln689">				regs.eax = BIOS_READ | blocksRead;</a>
<a name="ln690">				regs.edx = fDriveID | (head &lt;&lt; 8);</a>
<a name="ln691">				regs.ecx = sector | ((cylinder &gt;&gt; 2) &amp; 0xc0) | ((cylinder &amp; 0xff) &lt;&lt; 8);</a>
<a name="ln692">				regs.es = 0;</a>
<a name="ln693">				regs.ebx = kExtraSegmentScratch;</a>
<a name="ln694">				call_bios(0x13, &amp;regs);</a>
<a name="ln695"> </a>
<a name="ln696">				if ((regs.flags &amp; CARRY_FLAG) == 0) {</a>
<a name="ln697">					readWorked = true;</a>
<a name="ln698">					break;</a>
<a name="ln699">				}</a>
<a name="ln700"> </a>
<a name="ln701">				TRACE((&quot;read failed\n&quot;));</a>
<a name="ln702"> </a>
<a name="ln703">				if (tries &lt; 2) {</a>
<a name="ln704">					// reset disk system</a>
<a name="ln705">					TRACE((&quot;reset disk system\n&quot;));</a>
<a name="ln706">					regs.eax = BIOS_RESET_DISK_SYSTEM;</a>
<a name="ln707">					regs.edx = fDriveID;</a>
<a name="ln708">					call_bios(0x13, &amp;regs);</a>
<a name="ln709">				}</a>
<a name="ln710"> </a>
<a name="ln711">				// wait a bit between the retries (1/20 sec)</a>
<a name="ln712">				spin(50000);</a>
<a name="ln713">			}</a>
<a name="ln714"> </a>
<a name="ln715">			if (!readWorked) {</a>
<a name="ln716">				dprintf(&quot;reading %ld bytes from drive %u failed at %Ld\n&quot;,</a>
<a name="ln717">					blocksRead, fDriveID, pos);</a>
<a name="ln718">				return B_ERROR;</a>
<a name="ln719">			}</a>
<a name="ln720">		}</a>
<a name="ln721"> </a>
<a name="ln722">		uint32 bytesRead = fBlockSize * blocksRead - offset;</a>
<a name="ln723">		// copy no more than bufferSize bytes</a>
<a name="ln724">		if (bytesRead &gt; bufferSize)</a>
<a name="ln725">			bytesRead = bufferSize;</a>
<a name="ln726"> </a>
<a name="ln727">		memcpy(buffer, (void *)(kExtraSegmentScratch + offset), bytesRead);</a>
<a name="ln728">		pos += blocksRead;</a>
<a name="ln729">		offset = 0;</a>
<a name="ln730">		blocksLeft -= blocksRead;</a>
<a name="ln731">		bufferSize -= bytesRead;</a>
<a name="ln732">		buffer = (void *)((addr_t)buffer + bytesRead);</a>
<a name="ln733">		totalBytesRead += bytesRead;</a>
<a name="ln734">	}</a>
<a name="ln735"> </a>
<a name="ln736">	return totalBytesRead;</a>
<a name="ln737">}</a>
<a name="ln738"> </a>
<a name="ln739"> </a>
<a name="ln740">ssize_t</a>
<a name="ln741">BIOSDrive::WriteAt(void* cookie, off_t pos, const void* buffer,</a>
<a name="ln742">	size_t bufferSize)</a>
<a name="ln743">{</a>
<a name="ln744">	// we support only LBA addressing</a>
<a name="ln745">	if (!fLBA) {</a>
<a name="ln746">		dprintf(&quot;BIOSDrive::WriteAt(): CHS addressing not supported\n&quot;);</a>
<a name="ln747">		return B_UNSUPPORTED;</a>
<a name="ln748">	}</a>
<a name="ln749"> </a>
<a name="ln750">	// we support only block-aligned writes</a>
<a name="ln751">	if (pos % fBlockSize != 0 || bufferSize % fBlockSize != 0) {</a>
<a name="ln752">		dprintf(&quot;BIOSDrive::WriteAt(pos: %&quot; B_PRIdOFF &quot;, size: %&quot; B_PRIuSIZE</a>
<a name="ln753">			&quot;): Block-unaligned write not supported.\n&quot;, pos, bufferSize);</a>
<a name="ln754">		return B_UNSUPPORTED;</a>
<a name="ln755">	}</a>
<a name="ln756"> </a>
<a name="ln757">	pos /= fBlockSize;</a>
<a name="ln758"> </a>
<a name="ln759">	uint32 blocksLeft = bufferSize / fBlockSize;</a>
<a name="ln760">	int32 totalBytesWritten = 0;</a>
<a name="ln761"> </a>
<a name="ln762">	uint32 scratchSize = 24 * 1024 / fBlockSize;</a>
<a name="ln763">		// maximum value allowed by Phoenix BIOS is 0x7f</a>
<a name="ln764"> </a>
<a name="ln765">	while (blocksLeft &gt; 0) {</a>
<a name="ln766">		uint32 blocksToWrite = blocksLeft;</a>
<a name="ln767">		if (blocksToWrite &gt; scratchSize)</a>
<a name="ln768">			blocksToWrite = scratchSize;</a>
<a name="ln769"> </a>
<a name="ln770">		uint32 bytesToWrite = blocksToWrite * fBlockSize;</a>
<a name="ln771"> </a>
<a name="ln772">		memcpy((void*)kExtraSegmentScratch, buffer, bytesToWrite);</a>
<a name="ln773"> </a>
<a name="ln774">		struct disk_address_packet* packet</a>
<a name="ln775">			= (disk_address_packet*)kDataSegmentScratch;</a>
<a name="ln776">		memset(packet, 0, sizeof(disk_address_packet));</a>
<a name="ln777"> </a>
<a name="ln778">		packet-&gt;size = sizeof(disk_address_packet);</a>
<a name="ln779">		packet-&gt;number_of_blocks = blocksToWrite;</a>
<a name="ln780">		packet-&gt;buffer = kExtraSegmentScratch;</a>
<a name="ln781">		packet-&gt;lba = pos;</a>
<a name="ln782"> </a>
<a name="ln783">		struct bios_regs regs;</a>
<a name="ln784">		regs.eax = BIOS_EXT_WRITE;	// al = 0x00 -- no write verify</a>
<a name="ln785">		regs.edx = fDriveID;</a>
<a name="ln786">		regs.esi = (addr_t)packet - kDataSegmentBase;</a>
<a name="ln787">		call_bios(0x13, &amp;regs);</a>
<a name="ln788"> </a>
<a name="ln789">		if (regs.flags &amp; CARRY_FLAG)</a>
<a name="ln790">			return B_ERROR;</a>
<a name="ln791"> </a>
<a name="ln792">		pos += blocksToWrite;</a>
<a name="ln793">		blocksLeft -= blocksToWrite;</a>
<a name="ln794">		bufferSize -= bytesToWrite;</a>
<a name="ln795">		buffer = (void*)((addr_t)buffer + bytesToWrite);</a>
<a name="ln796">		totalBytesWritten += bytesToWrite;</a>
<a name="ln797">	}</a>
<a name="ln798"> </a>
<a name="ln799">	return totalBytesWritten;</a>
<a name="ln800">}</a>
<a name="ln801"> </a>
<a name="ln802"> </a>
<a name="ln803">off_t</a>
<a name="ln804">BIOSDrive::Size() const</a>
<a name="ln805">{</a>
<a name="ln806">	return fSize;</a>
<a name="ln807">}</a>
<a name="ln808"> </a>
<a name="ln809"> </a>
<a name="ln810">status_t</a>
<a name="ln811">BIOSDrive::FillIdentifier()</a>
<a name="ln812">{</a>
<a name="ln813">	if (HasParameters()) {</a>
<a name="ln814">		// try all drive_parameters versions, beginning from the most informative</a>
<a name="ln815"> </a>
<a name="ln816">#if 0</a>
<a name="ln817">		if (fill_disk_identifier_v3(fIdentifier, fParameters) == B_OK)</a>
<a name="ln818">			return B_OK;</a>
<a name="ln819"> </a>
<a name="ln820">		if (fill_disk_identifier_v2(fIdentifier, fParameters) == B_OK)</a>
<a name="ln821">			return B_OK;</a>
<a name="ln822">#else</a>
<a name="ln823">		// TODO: the above version is the correct one - it's currently</a>
<a name="ln824">		//		disabled, as the kernel boot code only supports the</a>
<a name="ln825">		//		UNKNOWN_BUS/UNKNOWN_DEVICE way to find the correct boot</a>
<a name="ln826">		//		device.</a>
<a name="ln827">		if (fill_disk_identifier_v3(fIdentifier, fParameters) != B_OK)</a>
<a name="ln828">			fill_disk_identifier_v2(fIdentifier, fParameters);</a>
<a name="ln829"> </a>
<a name="ln830">#endif</a>
<a name="ln831"> </a>
<a name="ln832">		// no interesting information, we have to fall back to the default</a>
<a name="ln833">		// unknown interface/device type identifier</a>
<a name="ln834">	}</a>
<a name="ln835"> </a>
<a name="ln836">	fIdentifier.bus_type = UNKNOWN_BUS;</a>
<a name="ln837">	fIdentifier.device_type = UNKNOWN_DEVICE;</a>
<a name="ln838">	fIdentifier.device.unknown.size = Size();</a>
<a name="ln839"> </a>
<a name="ln840">	for (int32 i = 0; i &lt; NUM_DISK_CHECK_SUMS; i++) {</a>
<a name="ln841">		fIdentifier.device.unknown.check_sums[i].offset = -1;</a>
<a name="ln842">		fIdentifier.device.unknown.check_sums[i].sum = 0;</a>
<a name="ln843">	}</a>
<a name="ln844"> </a>
<a name="ln845">	return B_ERROR;</a>
<a name="ln846">}</a>
<a name="ln847"> </a>
<a name="ln848"> </a>
<a name="ln849">//	#pragma mark -</a>
<a name="ln850"> </a>
<a name="ln851"> </a>
<a name="ln852">status_t</a>
<a name="ln853">platform_add_boot_device(struct stage2_args *args, NodeList *devicesList)</a>
<a name="ln854">{</a>
<a name="ln855">	TRACE((&quot;boot drive ID: %x\n&quot;, gBootDriveID));</a>
<a name="ln856"> </a>
<a name="ln857">	BIOSDrive *drive = new(nothrow) BIOSDrive(gBootDriveID);</a>
<a name="ln858">	if (drive-&gt;InitCheck() != B_OK) {</a>
<a name="ln859">		dprintf(&quot;no boot drive!\n&quot;);</a>
<a name="ln860">		delete drive;</a>
<a name="ln861">		return B_ERROR;</a>
<a name="ln862">	}</a>
<a name="ln863"> </a>
<a name="ln864">	devicesList-&gt;Add(drive);</a>
<a name="ln865"> </a>
<a name="ln866">	if (drive-&gt;FillIdentifier() != B_OK) {</a>
<a name="ln867">		// We need to add all block devices to give the kernel the possibility</a>
<a name="ln868">		// to find the right boot volume</a>
<a name="ln869">		add_block_devices(devicesList, true);</a>
<a name="ln870">	}</a>
<a name="ln871"> </a>
<a name="ln872">	TRACE((&quot;boot drive size: %Ld bytes\n&quot;, drive-&gt;Size()));</a>
<a name="ln873">	gBootVolume.SetBool(BOOT_VOLUME_BOOTED_FROM_IMAGE, gBootedFromImage);</a>
<a name="ln874"> </a>
<a name="ln875">	return B_OK;</a>
<a name="ln876">}</a>
<a name="ln877"> </a>
<a name="ln878"> </a>
<a name="ln879">status_t</a>
<a name="ln880">platform_get_boot_partitions(struct stage2_args *args, Node *bootDevice,</a>
<a name="ln881">	NodeList *list, NodeList *bootList)</a>
<a name="ln882">{</a>
<a name="ln883">	BIOSDrive *drive = static_cast&lt;BIOSDrive *&gt;(bootDevice);</a>
<a name="ln884">	off_t offset = (off_t)gBootPartitionOffset * drive-&gt;BlockSize();</a>
<a name="ln885"> </a>
<a name="ln886">	dprintf(&quot;boot partition offset: %Ld\n&quot;, offset);</a>
<a name="ln887"> </a>
<a name="ln888">	NodeIterator iterator = list-&gt;GetIterator();</a>
<a name="ln889">	boot::Partition *partition = NULL;</a>
<a name="ln890">	while ((partition = (boot::Partition *)iterator.Next()) != NULL) {</a>
<a name="ln891">		TRACE((&quot;partition offset = %Ld, size = %Ld\n&quot;, partition-&gt;offset, partition-&gt;size));</a>
<a name="ln892">		// search for the partition that contains the partition</a>
<a name="ln893">		// offset as reported by the BFS boot block</a>
<a name="ln894">		if (offset &gt;= partition-&gt;offset</a>
<a name="ln895">			&amp;&amp; offset &lt; partition-&gt;offset + partition-&gt;size) {</a>
<a name="ln896">			bootList-&gt;Insert(partition);</a>
<a name="ln897">			return B_OK;</a>
<a name="ln898">		}</a>
<a name="ln899">	}</a>
<a name="ln900"> </a>
<a name="ln901">	return B_ENTRY_NOT_FOUND;</a>
<a name="ln902">}</a>
<a name="ln903"> </a>
<a name="ln904"> </a>
<a name="ln905">status_t</a>
<a name="ln906">platform_add_block_devices(stage2_args *args, NodeList *devicesList)</a>
<a name="ln907">{</a>
<a name="ln908">	return add_block_devices(devicesList, false);</a>
<a name="ln909">}</a>
<a name="ln910"> </a>
<a name="ln911"> </a>
<a name="ln912">status_t</a>
<a name="ln913">platform_register_boot_device(Node *device)</a>
<a name="ln914">{</a>
<a name="ln915">	BIOSDrive *drive = (BIOSDrive *)device;</a>
<a name="ln916"> </a>
<a name="ln917">	check_cd_boot(drive);</a>
<a name="ln918"> </a>
<a name="ln919">	gBootVolume.SetInt64(&quot;boot drive number&quot;, drive-&gt;DriveID());</a>
<a name="ln920">	gBootVolume.SetData(BOOT_VOLUME_DISK_IDENTIFIER, B_RAW_TYPE,</a>
<a name="ln921">		&amp;drive-&gt;Identifier(), sizeof(disk_identifier));</a>
<a name="ln922"> </a>
<a name="ln923">	return B_OK;</a>
<a name="ln924">}</a>
<a name="ln925"> </a>
<a name="ln926"> </a>
<a name="ln927">void</a>
<a name="ln928">platform_cleanup_devices()</a>
<a name="ln929">{</a>
<a name="ln930">}</a>

</code></pre>
<div class="balloon" rel="571"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fIdentifier.</p></div>
<div class="balloon" rel="886"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Potentially incorrect format string is passed to the 'dprintf' function. Prefix 'L' is not applicable to conversion specifier 'd'.</p></div>
<div class="balloon" rel="716"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Potentially incorrect format string is passed to the 'dprintf' function. Prefix 'L' is not applicable to conversion specifier 'd'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
