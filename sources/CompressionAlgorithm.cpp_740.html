
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>CompressionAlgorithm.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2014, Ingo Weinhold, ingo_weinhold@gmx.de.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> */</a>
<a name="ln5"> </a>
<a name="ln6"> </a>
<a name="ln7">#include &lt;CompressionAlgorithm.h&gt;</a>
<a name="ln8"> </a>
<a name="ln9">#include &lt;stdlib.h&gt;</a>
<a name="ln10">#include &lt;string.h&gt;</a>
<a name="ln11"> </a>
<a name="ln12">#include &lt;Errors.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14"> </a>
<a name="ln15">// #pragma mark - BCompressionParameters</a>
<a name="ln16"> </a>
<a name="ln17"> </a>
<a name="ln18">BCompressionParameters::BCompressionParameters()</a>
<a name="ln19">{</a>
<a name="ln20">}</a>
<a name="ln21"> </a>
<a name="ln22"> </a>
<a name="ln23">BCompressionParameters::~BCompressionParameters()</a>
<a name="ln24">{</a>
<a name="ln25">}</a>
<a name="ln26"> </a>
<a name="ln27"> </a>
<a name="ln28">// #pragma mark - BDecompressionParameters</a>
<a name="ln29"> </a>
<a name="ln30"> </a>
<a name="ln31">BDecompressionParameters::BDecompressionParameters()</a>
<a name="ln32">{</a>
<a name="ln33">}</a>
<a name="ln34"> </a>
<a name="ln35"> </a>
<a name="ln36">BDecompressionParameters::~BDecompressionParameters()</a>
<a name="ln37">{</a>
<a name="ln38">}</a>
<a name="ln39"> </a>
<a name="ln40"> </a>
<a name="ln41">// #pragma mark - BCompressionAlgorithm</a>
<a name="ln42"> </a>
<a name="ln43"> </a>
<a name="ln44">BCompressionAlgorithm::BCompressionAlgorithm()</a>
<a name="ln45">{</a>
<a name="ln46">}</a>
<a name="ln47"> </a>
<a name="ln48"> </a>
<a name="ln49">BCompressionAlgorithm::~BCompressionAlgorithm()</a>
<a name="ln50">{</a>
<a name="ln51">}</a>
<a name="ln52"> </a>
<a name="ln53"> </a>
<a name="ln54">status_t</a>
<a name="ln55">BCompressionAlgorithm::CreateCompressingInputStream(BDataIO* input,</a>
<a name="ln56">	const BCompressionParameters* parameters, BDataIO*&amp; _stream)</a>
<a name="ln57">{</a>
<a name="ln58">	return B_NOT_SUPPORTED;</a>
<a name="ln59">}</a>
<a name="ln60"> </a>
<a name="ln61"> </a>
<a name="ln62">status_t</a>
<a name="ln63">BCompressionAlgorithm::CreateCompressingOutputStream(BDataIO* output,</a>
<a name="ln64">	const BCompressionParameters* parameters, BDataIO*&amp; _stream)</a>
<a name="ln65">{</a>
<a name="ln66">	return B_NOT_SUPPORTED;</a>
<a name="ln67">}</a>
<a name="ln68"> </a>
<a name="ln69"> </a>
<a name="ln70">status_t</a>
<a name="ln71">BCompressionAlgorithm::CreateDecompressingInputStream(BDataIO* input,</a>
<a name="ln72">	const BDecompressionParameters* parameters, BDataIO*&amp; _stream)</a>
<a name="ln73">{</a>
<a name="ln74">	return B_NOT_SUPPORTED;</a>
<a name="ln75">}</a>
<a name="ln76"> </a>
<a name="ln77"> </a>
<a name="ln78">status_t</a>
<a name="ln79">BCompressionAlgorithm::CreateDecompressingOutputStream(BDataIO* output,</a>
<a name="ln80">	const BDecompressionParameters* parameters, BDataIO*&amp; _stream)</a>
<a name="ln81">{</a>
<a name="ln82">	return B_NOT_SUPPORTED;</a>
<a name="ln83">}</a>
<a name="ln84"> </a>
<a name="ln85"> </a>
<a name="ln86">status_t</a>
<a name="ln87">BCompressionAlgorithm::CompressBuffer(const void* input, size_t inputSize,</a>
<a name="ln88">	void* output, size_t outputSize, size_t&amp; _compressedSize,</a>
<a name="ln89">	const BCompressionParameters* parameters)</a>
<a name="ln90">{</a>
<a name="ln91">	return B_NOT_SUPPORTED;</a>
<a name="ln92">}</a>
<a name="ln93"> </a>
<a name="ln94"> </a>
<a name="ln95">status_t</a>
<a name="ln96">BCompressionAlgorithm::DecompressBuffer(const void* input,</a>
<a name="ln97">	size_t inputSize, void* output, size_t outputSize,</a>
<a name="ln98">	size_t&amp; _uncompressedSize, const BDecompressionParameters* parameters)</a>
<a name="ln99">{</a>
<a name="ln100">	return B_NOT_SUPPORTED;</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103"> </a>
<a name="ln104">// #pragma mark - BAbstractStream</a>
<a name="ln105"> </a>
<a name="ln106"> </a>
<a name="ln107">BCompressionAlgorithm::BAbstractStream::BAbstractStream()</a>
<a name="ln108">	:</a>
<a name="ln109">	BDataIO(),</a>
<a name="ln110">	fBuffer(NULL),</a>
<a name="ln111">	fBufferCapacity(0),</a>
<a name="ln112">	fBufferOffset(0),</a>
<a name="ln113">	fBufferSize(0)</a>
<a name="ln114">{</a>
<a name="ln115">}</a>
<a name="ln116"> </a>
<a name="ln117"> </a>
<a name="ln118">BCompressionAlgorithm::BAbstractStream::~BAbstractStream()</a>
<a name="ln119">{</a>
<a name="ln120">	free(fBuffer);</a>
<a name="ln121">}</a>
<a name="ln122"> </a>
<a name="ln123"> </a>
<a name="ln124">status_t</a>
<a name="ln125">BCompressionAlgorithm::BAbstractStream::Init(size_t bufferSize)</a>
<a name="ln126">{</a>
<a name="ln127">	fBuffer = (uint8*)malloc(bufferSize);</a>
<a name="ln128">	fBufferCapacity = bufferSize;</a>
<a name="ln129"> </a>
<a name="ln130">	return fBuffer != NULL ? B_OK : B_NO_MEMORY;</a>
<a name="ln131">}</a>
<a name="ln132"> </a>
<a name="ln133"> </a>
<a name="ln134">// #pragma mark - BAbstractInputStream</a>
<a name="ln135"> </a>
<a name="ln136"> </a>
<a name="ln137">BCompressionAlgorithm::BAbstractInputStream::BAbstractInputStream(</a>
<a name="ln138">		BDataIO* input)</a>
<a name="ln139">	:</a>
<a name="ln140">	BAbstractStream(),</a>
<a name="ln141">	fInput(input),</a>
<a name="ln142">	fEndOfInput(false),</a>
<a name="ln143">	fNoMorePendingData(false)</a>
<a name="ln144">{</a>
<a name="ln145">}</a>
<a name="ln146"> </a>
<a name="ln147"> </a>
<a name="ln148">BCompressionAlgorithm::BAbstractInputStream::~BAbstractInputStream()</a>
<a name="ln149">{</a>
<a name="ln150">}</a>
<a name="ln151"> </a>
<a name="ln152"> </a>
<a name="ln153">ssize_t</a>
<a name="ln154">BCompressionAlgorithm::BAbstractInputStream::Read(void* buffer, size_t size)</a>
<a name="ln155">{</a>
<a name="ln156">	if (size == 0)</a>
<a name="ln157">		return 0;</a>
<a name="ln158"> </a>
<a name="ln159">	size_t bytesRemaining = size;</a>
<a name="ln160">	uint8* output = (uint8*)buffer;</a>
<a name="ln161"> </a>
<a name="ln162">	while (bytesRemaining &gt; 0) {</a>
<a name="ln163">		// process the data still in the input buffer</a>
<a name="ln164">		if (fBufferSize &gt; 0) {</a>
<a name="ln165">			size_t bytesConsumed;</a>
<a name="ln166">			size_t bytesProduced;</a>
<a name="ln167">			status_t error = ProcessData(fBuffer + fBufferOffset, fBufferSize,</a>
<a name="ln168">				output, bytesRemaining, bytesConsumed, bytesProduced);</a>
<a name="ln169">			if (error != B_OK)</a>
<a name="ln170">				return error;</a>
<a name="ln171"> </a>
<a name="ln172">			fBufferOffset += bytesConsumed;</a>
<a name="ln173">			fBufferSize -= bytesConsumed;</a>
<a name="ln174">			output += bytesProduced;</a>
<a name="ln175">			bytesRemaining -= bytesProduced;</a>
<a name="ln176">			continue;</a>
<a name="ln177">		}</a>
<a name="ln178"> </a>
<a name="ln179">		// We couldn't process anything, because we don't have any or not enough</a>
<a name="ln180">		// bytes in the input buffer.</a>
<a name="ln181"> </a>
<a name="ln182">		if (fEndOfInput)</a>
<a name="ln183">			break;</a>
<a name="ln184"> </a>
<a name="ln185">		// Move any remaining data to the start of the buffer.</a>
<a name="ln186">		if (fBufferSize &gt; 0) {</a>
<a name="ln187">			if (fBufferSize == fBufferCapacity)</a>
<a name="ln188">				return B_ERROR;</a>
<a name="ln189"> </a>
<a name="ln190">			if (fBufferOffset &gt; 0)</a>
<a name="ln191">				memmove(fBuffer, fBuffer + fBufferOffset, fBufferSize);</a>
<a name="ln192">		}</a>
<a name="ln193"> </a>
<a name="ln194">		fBufferOffset = 0;</a>
<a name="ln195"> </a>
<a name="ln196">		// read from the source</a>
<a name="ln197">		ssize_t bytesRead = fInput-&gt;Read(fBuffer + fBufferSize,</a>
<a name="ln198">			fBufferCapacity - fBufferSize);</a>
<a name="ln199">		if (bytesRead &lt; 0)</a>
<a name="ln200">			return bytesRead;</a>
<a name="ln201">		if (bytesRead == 0) {</a>
<a name="ln202">			fEndOfInput = true;</a>
<a name="ln203">			break;</a>
<a name="ln204">		}</a>
<a name="ln205"> </a>
<a name="ln206">		fBufferSize += bytesRead;</a>
<a name="ln207">	}</a>
<a name="ln208"> </a>
<a name="ln209">	// If we've reached the end of the input and still have room in the output</a>
<a name="ln210">	// buffer, we have consumed all input data and want to flush all pending</a>
<a name="ln211">	// data, now.</a>
<a name="ln212">	if (fEndOfInput &amp;&amp; bytesRemaining &gt; 0 &amp;&amp; !fNoMorePendingData) {</a>
<a name="ln213">		size_t bytesProduced;</a>
<a name="ln214">		status_t error = FlushPendingData(output, bytesRemaining,</a>
<a name="ln215">			bytesProduced);</a>
<a name="ln216">		if (error != B_OK)</a>
<a name="ln217">			return error;</a>
<a name="ln218"> </a>
<a name="ln219">		if (bytesProduced &lt; bytesRemaining)</a>
<a name="ln220">			fNoMorePendingData = true;</a>
<a name="ln221"> </a>
<a name="ln222">		output += bytesProduced;</a>
<a name="ln223">		bytesRemaining -= bytesProduced;</a>
<a name="ln224">	}</a>
<a name="ln225"> </a>
<a name="ln226">	return size - bytesRemaining;</a>
<a name="ln227">}</a>
<a name="ln228"> </a>
<a name="ln229"> </a>
<a name="ln230">// #pragma mark - BAbstractOutputStream</a>
<a name="ln231"> </a>
<a name="ln232"> </a>
<a name="ln233">BCompressionAlgorithm::BAbstractOutputStream::BAbstractOutputStream(</a>
<a name="ln234">		BDataIO* output)</a>
<a name="ln235">	:</a>
<a name="ln236">	BAbstractStream(),</a>
<a name="ln237">	fOutput(output)</a>
<a name="ln238">{</a>
<a name="ln239">}</a>
<a name="ln240"> </a>
<a name="ln241"> </a>
<a name="ln242">BCompressionAlgorithm::BAbstractOutputStream::~BAbstractOutputStream()</a>
<a name="ln243">{</a>
<a name="ln244">}</a>
<a name="ln245"> </a>
<a name="ln246"> </a>
<a name="ln247">ssize_t</a>
<a name="ln248">BCompressionAlgorithm::BAbstractOutputStream::Write(const void* buffer,</a>
<a name="ln249">	size_t size)</a>
<a name="ln250">{</a>
<a name="ln251">	if (size == 0)</a>
<a name="ln252">		return 0;</a>
<a name="ln253"> </a>
<a name="ln254">	size_t bytesRemaining = size;</a>
<a name="ln255">	uint8* input = (uint8*)buffer;</a>
<a name="ln256"> </a>
<a name="ln257">	while (bytesRemaining &gt; 0) {</a>
<a name="ln258">		// try to process more data</a>
<a name="ln259">		if (fBufferSize &lt; fBufferCapacity) {</a>
<a name="ln260">			size_t bytesConsumed;</a>
<a name="ln261">			size_t bytesProduced;</a>
<a name="ln262">			status_t error = ProcessData(input, bytesRemaining,</a>
<a name="ln263">				fBuffer + fBufferSize, fBufferCapacity - fBufferSize,</a>
<a name="ln264">				bytesConsumed, bytesProduced);</a>
<a name="ln265">			if (error != B_OK)</a>
<a name="ln266">				return error;</a>
<a name="ln267"> </a>
<a name="ln268">			input += bytesConsumed;</a>
<a name="ln269">			bytesRemaining -= bytesConsumed;</a>
<a name="ln270">			fBufferSize += bytesProduced;</a>
<a name="ln271">			continue;</a>
<a name="ln272">		}</a>
<a name="ln273"> </a>
<a name="ln274">		// We couldn't process anything, because we don't have any or not enough</a>
<a name="ln275">		// room in the output buffer.</a>
<a name="ln276"> </a>
<a name="ln277">		if (fBufferSize == 0)</a>
<a name="ln278">			return B_ERROR;</a>
<a name="ln279"> </a>
<a name="ln280">		// write to the target</a>
<a name="ln281">		ssize_t bytesWritten = fOutput-&gt;Write(fBuffer, fBufferSize);</a>
<a name="ln282">		if (bytesWritten &lt; 0)</a>
<a name="ln283">			return bytesWritten;</a>
<a name="ln284">		if (bytesWritten == 0)</a>
<a name="ln285">			break;</a>
<a name="ln286"> </a>
<a name="ln287">		// Move any remaining data to the start of the buffer.</a>
<a name="ln288">		fBufferSize -= bytesWritten;</a>
<a name="ln289">		if (fBufferSize &gt; 0)</a>
<a name="ln290">			memmove(fBuffer, fBuffer + bytesWritten, fBufferSize);</a>
<a name="ln291">	}</a>
<a name="ln292"> </a>
<a name="ln293">	return size - bytesRemaining;</a>
<a name="ln294">}</a>
<a name="ln295"> </a>
<a name="ln296"> </a>
<a name="ln297">status_t</a>
<a name="ln298">BCompressionAlgorithm::BAbstractOutputStream::Flush()</a>
<a name="ln299">{</a>
<a name="ln300">	bool noMorePendingData = false;</a>
<a name="ln301"> </a>
<a name="ln302">	for (;;) {</a>
<a name="ln303">		// let the derived class flush all pending data</a>
<a name="ln304">		if (fBufferSize &lt; fBufferCapacity &amp;&amp; !noMorePendingData) {</a>
<a name="ln305">			size_t bytesProduced;</a>
<a name="ln306">			status_t error = FlushPendingData(fBuffer + fBufferSize,</a>
<a name="ln307">				fBufferCapacity - fBufferSize, bytesProduced);</a>
<a name="ln308">			if (error != B_OK)</a>
<a name="ln309">				return error;</a>
<a name="ln310"> </a>
<a name="ln311">			noMorePendingData = bytesProduced &lt; fBufferCapacity - fBufferSize;</a>
<a name="ln312"> </a>
<a name="ln313">			fBufferSize += bytesProduced;</a>
<a name="ln314">		}</a>
<a name="ln315"> </a>
<a name="ln316">		// write buffered data to output</a>
<a name="ln317">		if (fBufferSize == 0)</a>
<a name="ln318">			break;</a>
<a name="ln319"> </a>
<a name="ln320">		status_t error = fOutput-&gt;WriteExactly(fBuffer, fBufferSize);</a>
<a name="ln321">		if (error != B_OK)</a>
<a name="ln322">			return error;</a>
<a name="ln323"> </a>
<a name="ln324">		fBufferSize = 0;</a>
<a name="ln325">	}</a>
<a name="ln326"> </a>
<a name="ln327">	return fOutput-&gt;Flush();</a>
<a name="ln328">}</a>

</code></pre>
<div class="balloon" rel="186"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'fBufferSize > 0' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
