
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>agg_span_image_filter_rgba.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//----------------------------------------------------------------------------</a>
<a name="ln2">// Anti-Grain Geometry - Version 2.4</a>
<a name="ln3">// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)</a>
<a name="ln4">//</a>
<a name="ln5">// Permission to copy, use, modify, sell and distribute this software </a>
<a name="ln6">// is granted provided this copyright notice appears in all copies. </a>
<a name="ln7">// This software is provided &quot;as is&quot; without express or implied</a>
<a name="ln8">// warranty, and with no claim as to its suitability for any purpose.</a>
<a name="ln9">//</a>
<a name="ln10">//----------------------------------------------------------------------------</a>
<a name="ln11">// Contact: mcseem@antigrain.com</a>
<a name="ln12">//          mcseemagg@yahoo.com</a>
<a name="ln13">//          http://www.antigrain.com</a>
<a name="ln14">//----------------------------------------------------------------------------</a>
<a name="ln15">//</a>
<a name="ln16">// Adaptation for high precision colors has been sponsored by </a>
<a name="ln17">// Liberty Technology Systems, Inc., visit http://lib-sys.com</a>
<a name="ln18">//</a>
<a name="ln19">// Liberty Technology Systems, Inc. is the provider of</a>
<a name="ln20">// PostScript and PDF technology for software developers.</a>
<a name="ln21">// </a>
<a name="ln22">//----------------------------------------------------------------------------</a>
<a name="ln23">#ifndef AGG_SPAN_IMAGE_FILTER_RGBA_INCLUDED</a>
<a name="ln24">#define AGG_SPAN_IMAGE_FILTER_RGBA_INCLUDED</a>
<a name="ln25"> </a>
<a name="ln26">#include &quot;agg_basics.h&quot;</a>
<a name="ln27">#include &quot;agg_color_rgba.h&quot;</a>
<a name="ln28">#include &quot;agg_span_image_filter.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30"> </a>
<a name="ln31">namespace agg</a>
<a name="ln32">{</a>
<a name="ln33"> </a>
<a name="ln34">    //==============================================span_image_filter_rgba_nn</a>
<a name="ln35">    template&lt;class Source, class Interpolator&gt; </a>
<a name="ln36">    class span_image_filter_rgba_nn : </a>
<a name="ln37">    public span_image_filter&lt;Source, Interpolator&gt;</a>
<a name="ln38">    {</a>
<a name="ln39">    public:</a>
<a name="ln40">        typedef Source source_type;</a>
<a name="ln41">        typedef typename source_type::color_type color_type;</a>
<a name="ln42">        typedef typename source_type::order_type order_type;</a>
<a name="ln43">        typedef Interpolator interpolator_type;</a>
<a name="ln44">        typedef span_image_filter&lt;source_type, interpolator_type&gt; base_type;</a>
<a name="ln45">        typedef typename color_type::value_type value_type;</a>
<a name="ln46">        typedef typename color_type::calc_type calc_type;</a>
<a name="ln47">        enum base_scale_e</a>
<a name="ln48">        {</a>
<a name="ln49">            base_shift = color_type::base_shift,</a>
<a name="ln50">            base_mask  = color_type::base_mask</a>
<a name="ln51">        };</a>
<a name="ln52"> </a>
<a name="ln53">        //--------------------------------------------------------------------</a>
<a name="ln54">        span_image_filter_rgba_nn() {}</a>
<a name="ln55">        span_image_filter_rgba_nn(source_type&amp; src, </a>
<a name="ln56">                                  interpolator_type&amp; inter) :</a>
<a name="ln57">            base_type(src, inter, 0) </a>
<a name="ln58">        {}</a>
<a name="ln59"> </a>
<a name="ln60">        //--------------------------------------------------------------------</a>
<a name="ln61">        void generate(color_type* span, int x, int y, unsigned len)</a>
<a name="ln62">        {</a>
<a name="ln63">            base_type::interpolator().begin(x + base_type::filter_dx_dbl(), </a>
<a name="ln64">                                            y + base_type::filter_dy_dbl(), len);</a>
<a name="ln65">            do</a>
<a name="ln66">            {</a>
<a name="ln67">                base_type::interpolator().coordinates(&amp;x, &amp;y);</a>
<a name="ln68">                const value_type* fg_ptr = (const value_type*)</a>
<a name="ln69">                    base_type::source().span(x &gt;&gt; image_subpixel_shift, </a>
<a name="ln70">                                             y &gt;&gt; image_subpixel_shift, </a>
<a name="ln71">                                             1);</a>
<a name="ln72">                span-&gt;r = fg_ptr[order_type::R];</a>
<a name="ln73">                span-&gt;g = fg_ptr[order_type::G];</a>
<a name="ln74">                span-&gt;b = fg_ptr[order_type::B];</a>
<a name="ln75">                span-&gt;a = fg_ptr[order_type::A];</a>
<a name="ln76">                ++span;</a>
<a name="ln77">                ++base_type::interpolator();</a>
<a name="ln78"> </a>
<a name="ln79">            } while(--len);</a>
<a name="ln80">        }</a>
<a name="ln81">    };</a>
<a name="ln82"> </a>
<a name="ln83"> </a>
<a name="ln84"> </a>
<a name="ln85">    //=========================================span_image_filter_rgba_bilinear</a>
<a name="ln86">    template&lt;class Source, class Interpolator&gt; </a>
<a name="ln87">    class span_image_filter_rgba_bilinear : </a>
<a name="ln88">    public span_image_filter&lt;Source, Interpolator&gt;</a>
<a name="ln89">    {</a>
<a name="ln90">    public:</a>
<a name="ln91">        typedef Source source_type;</a>
<a name="ln92">        typedef typename source_type::color_type color_type;</a>
<a name="ln93">        typedef typename source_type::order_type order_type;</a>
<a name="ln94">        typedef Interpolator interpolator_type;</a>
<a name="ln95">        typedef span_image_filter&lt;source_type, interpolator_type&gt; base_type;</a>
<a name="ln96">        typedef typename color_type::value_type value_type;</a>
<a name="ln97">        typedef typename color_type::calc_type calc_type;</a>
<a name="ln98">        enum base_scale_e</a>
<a name="ln99">        {</a>
<a name="ln100">            base_shift = color_type::base_shift,</a>
<a name="ln101">            base_mask  = color_type::base_mask</a>
<a name="ln102">        };</a>
<a name="ln103"> </a>
<a name="ln104">        //--------------------------------------------------------------------</a>
<a name="ln105">        span_image_filter_rgba_bilinear() {}</a>
<a name="ln106">        span_image_filter_rgba_bilinear(source_type&amp; src, </a>
<a name="ln107">                                        interpolator_type&amp; inter) :</a>
<a name="ln108">            base_type(src, inter, 0) </a>
<a name="ln109">        {}</a>
<a name="ln110"> </a>
<a name="ln111"> </a>
<a name="ln112">        //--------------------------------------------------------------------</a>
<a name="ln113">        void generate(color_type* span, int x, int y, unsigned len)</a>
<a name="ln114">        {</a>
<a name="ln115">            base_type::interpolator().begin(x + base_type::filter_dx_dbl(), </a>
<a name="ln116">                                            y + base_type::filter_dy_dbl(), len);</a>
<a name="ln117"> </a>
<a name="ln118">            calc_type fg[4];</a>
<a name="ln119">            const value_type *fg_ptr;</a>
<a name="ln120"> </a>
<a name="ln121">            do</a>
<a name="ln122">            {</a>
<a name="ln123">                int x_hr;</a>
<a name="ln124">                int y_hr;</a>
<a name="ln125"> </a>
<a name="ln126">                base_type::interpolator().coordinates(&amp;x_hr, &amp;y_hr);</a>
<a name="ln127"> </a>
<a name="ln128">                x_hr -= base_type::filter_dx_int();</a>
<a name="ln129">                y_hr -= base_type::filter_dy_int();</a>
<a name="ln130"> </a>
<a name="ln131">                int x_lr = x_hr &gt;&gt; image_subpixel_shift;</a>
<a name="ln132">                int y_lr = y_hr &gt;&gt; image_subpixel_shift;</a>
<a name="ln133"> </a>
<a name="ln134">                unsigned weight;</a>
<a name="ln135"> </a>
<a name="ln136">                fg[0] = </a>
<a name="ln137">                fg[1] = </a>
<a name="ln138">                fg[2] = </a>
<a name="ln139">                fg[3] = image_subpixel_scale * image_subpixel_scale / 2;</a>
<a name="ln140"> </a>
<a name="ln141">                x_hr &amp;= image_subpixel_mask;</a>
<a name="ln142">                y_hr &amp;= image_subpixel_mask;</a>
<a name="ln143"> </a>
<a name="ln144">                fg_ptr = (const value_type*)base_type::source().span(x_lr, y_lr, 2);</a>
<a name="ln145">                weight = (image_subpixel_scale - x_hr) * </a>
<a name="ln146">                         (image_subpixel_scale - y_hr);</a>
<a name="ln147">                fg[0] += weight * *fg_ptr++;</a>
<a name="ln148">                fg[1] += weight * *fg_ptr++;</a>
<a name="ln149">                fg[2] += weight * *fg_ptr++;</a>
<a name="ln150">                fg[3] += weight * *fg_ptr;</a>
<a name="ln151"> </a>
<a name="ln152">                fg_ptr = (const value_type*)base_type::source().next_x();</a>
<a name="ln153">                weight = x_hr * (image_subpixel_scale - y_hr);</a>
<a name="ln154">                fg[0] += weight * *fg_ptr++;</a>
<a name="ln155">                fg[1] += weight * *fg_ptr++;</a>
<a name="ln156">                fg[2] += weight * *fg_ptr++;</a>
<a name="ln157">                fg[3] += weight * *fg_ptr;</a>
<a name="ln158"> </a>
<a name="ln159">                fg_ptr = (const value_type*)base_type::source().next_y();</a>
<a name="ln160">                weight = (image_subpixel_scale - x_hr) * y_hr;</a>
<a name="ln161">                fg[0] += weight * *fg_ptr++;</a>
<a name="ln162">                fg[1] += weight * *fg_ptr++;</a>
<a name="ln163">                fg[2] += weight * *fg_ptr++;</a>
<a name="ln164">                fg[3] += weight * *fg_ptr;</a>
<a name="ln165"> </a>
<a name="ln166">                fg_ptr = (const value_type*)base_type::source().next_x();</a>
<a name="ln167">                weight = x_hr * y_hr;</a>
<a name="ln168">                fg[0] += weight * *fg_ptr++;</a>
<a name="ln169">                fg[1] += weight * *fg_ptr++;</a>
<a name="ln170">                fg[2] += weight * *fg_ptr++;</a>
<a name="ln171">                fg[3] += weight * *fg_ptr;</a>
<a name="ln172"> </a>
<a name="ln173">                span-&gt;r = value_type(fg[order_type::R] &gt;&gt; (image_subpixel_shift * 2));</a>
<a name="ln174">                span-&gt;g = value_type(fg[order_type::G] &gt;&gt; (image_subpixel_shift * 2));</a>
<a name="ln175">                span-&gt;b = value_type(fg[order_type::B] &gt;&gt; (image_subpixel_shift * 2));</a>
<a name="ln176">                span-&gt;a = value_type(fg[order_type::A] &gt;&gt; (image_subpixel_shift * 2));</a>
<a name="ln177"> </a>
<a name="ln178">                ++span;</a>
<a name="ln179">                ++base_type::interpolator();</a>
<a name="ln180"> </a>
<a name="ln181">            } while(--len);</a>
<a name="ln182">        }</a>
<a name="ln183">    };</a>
<a name="ln184"> </a>
<a name="ln185"> </a>
<a name="ln186">    //====================================span_image_filter_rgba_bilinear_clip</a>
<a name="ln187">    template&lt;class Source, class Interpolator&gt; </a>
<a name="ln188">    class span_image_filter_rgba_bilinear_clip : </a>
<a name="ln189">    public span_image_filter&lt;Source, Interpolator&gt;</a>
<a name="ln190">    {</a>
<a name="ln191">    public:</a>
<a name="ln192">        typedef Source source_type;</a>
<a name="ln193">        typedef typename source_type::color_type color_type;</a>
<a name="ln194">        typedef typename source_type::order_type order_type;</a>
<a name="ln195">        typedef Interpolator interpolator_type;</a>
<a name="ln196">        typedef span_image_filter&lt;source_type, interpolator_type&gt; base_type;</a>
<a name="ln197">        typedef typename color_type::value_type value_type;</a>
<a name="ln198">        typedef typename color_type::calc_type calc_type;</a>
<a name="ln199">        enum base_scale_e</a>
<a name="ln200">        {</a>
<a name="ln201">            base_shift = color_type::base_shift,</a>
<a name="ln202">            base_mask  = color_type::base_mask</a>
<a name="ln203">        };</a>
<a name="ln204"> </a>
<a name="ln205">        //--------------------------------------------------------------------</a>
<a name="ln206">        span_image_filter_rgba_bilinear_clip() {}</a>
<a name="ln207">        span_image_filter_rgba_bilinear_clip(source_type&amp; src, </a>
<a name="ln208">                                             const color_type&amp; back_color,</a>
<a name="ln209">                                             interpolator_type&amp; inter) :</a>
<a name="ln210">            base_type(src, inter, 0),</a>
<a name="ln211">            m_back_color(back_color)</a>
<a name="ln212">        {}</a>
<a name="ln213">        const color_type&amp; background_color() const { return m_back_color; }</a>
<a name="ln214">        void background_color(const color_type&amp; v)   { m_back_color = v; }</a>
<a name="ln215"> </a>
<a name="ln216"> </a>
<a name="ln217">        //--------------------------------------------------------------------</a>
<a name="ln218">        void generate(color_type* span, int x, int y, unsigned len)</a>
<a name="ln219">        {</a>
<a name="ln220">            base_type::interpolator().begin(x + base_type::filter_dx_dbl(), </a>
<a name="ln221">                                            y + base_type::filter_dy_dbl(), len);</a>
<a name="ln222"> </a>
<a name="ln223">            calc_type fg[4];</a>
<a name="ln224">            value_type back_r = m_back_color.r;</a>
<a name="ln225">            value_type back_g = m_back_color.g;</a>
<a name="ln226">            value_type back_b = m_back_color.b;</a>
<a name="ln227">            value_type back_a = m_back_color.a;</a>
<a name="ln228"> </a>
<a name="ln229">            const value_type *fg_ptr = NULL;</a>
<a name="ln230">            int maxx = base_type::source().width() - 1;</a>
<a name="ln231">            int maxy = base_type::source().height() - 1;</a>
<a name="ln232"> </a>
<a name="ln233">            do</a>
<a name="ln234">            {</a>
<a name="ln235">                int x_hr;</a>
<a name="ln236">                int y_hr;</a>
<a name="ln237"> </a>
<a name="ln238">                base_type::interpolator().coordinates(&amp;x_hr, &amp;y_hr);</a>
<a name="ln239"> </a>
<a name="ln240">                x_hr -= base_type::filter_dx_int();</a>
<a name="ln241">                y_hr -= base_type::filter_dy_int();</a>
<a name="ln242"> </a>
<a name="ln243">                int x_lr = x_hr &gt;&gt; image_subpixel_shift;</a>
<a name="ln244">                int y_lr = y_hr &gt;&gt; image_subpixel_shift;</a>
<a name="ln245"> </a>
<a name="ln246">                unsigned weight;</a>
<a name="ln247"> </a>
<a name="ln248">                if(x_lr &gt;= 0    &amp;&amp; y_lr &gt;= 0 &amp;&amp;</a>
<a name="ln249">                   x_lr &lt;  maxx &amp;&amp; y_lr &lt;  maxy) </a>
<a name="ln250">                {</a>
<a name="ln251">                    fg[0] = </a>
<a name="ln252">                    fg[1] = </a>
<a name="ln253">                    fg[2] = </a>
<a name="ln254">                    fg[3] = image_subpixel_scale * image_subpixel_scale / 2;</a>
<a name="ln255"> </a>
<a name="ln256">                    x_hr &amp;= image_subpixel_mask;</a>
<a name="ln257">                    y_hr &amp;= image_subpixel_mask;</a>
<a name="ln258"> </a>
<a name="ln259">                    fg_ptr = (const value_type*)</a>
<a name="ln260">                        base_type::source().row_ptr(y_lr) + (x_lr &lt;&lt; 2);</a>
<a name="ln261"> </a>
<a name="ln262">                    weight = (image_subpixel_scale - x_hr) * </a>
<a name="ln263">                             (image_subpixel_scale - y_hr);</a>
<a name="ln264">                    fg[0] += weight * *fg_ptr++;</a>
<a name="ln265">                    fg[1] += weight * *fg_ptr++;</a>
<a name="ln266">                    fg[2] += weight * *fg_ptr++;</a>
<a name="ln267">                    fg[3] += weight * *fg_ptr++;</a>
<a name="ln268"> </a>
<a name="ln269">                    weight = x_hr * (image_subpixel_scale - y_hr);</a>
<a name="ln270">                    fg[0] += weight * *fg_ptr++;</a>
<a name="ln271">                    fg[1] += weight * *fg_ptr++;</a>
<a name="ln272">                    fg[2] += weight * *fg_ptr++;</a>
<a name="ln273">                    fg[3] += weight * *fg_ptr++;</a>
<a name="ln274"> </a>
<a name="ln275">                    ++y_lr;</a>
<a name="ln276">                    fg_ptr = (const value_type*)</a>
<a name="ln277">                        base_type::source().row_ptr(y_lr) + (x_lr &lt;&lt; 2);</a>
<a name="ln278"> </a>
<a name="ln279">                    weight = (image_subpixel_scale - x_hr) * y_hr;</a>
<a name="ln280">                    fg[0] += weight * *fg_ptr++;</a>
<a name="ln281">                    fg[1] += weight * *fg_ptr++;</a>
<a name="ln282">                    fg[2] += weight * *fg_ptr++;</a>
<a name="ln283">                    fg[3] += weight * *fg_ptr++;</a>
<a name="ln284"> </a>
<a name="ln285">                    weight = x_hr * y_hr;</a>
<a name="ln286">                    fg[0] += weight * *fg_ptr++;</a>
<a name="ln287">                    fg[1] += weight * *fg_ptr++;</a>
<a name="ln288">                    fg[2] += weight * *fg_ptr++;</a>
<a name="ln289">                    fg[3] += weight * *fg_ptr++;</a>
<a name="ln290"> </a>
<a name="ln291">                    fg[0] &gt;&gt;= image_subpixel_shift * 2;</a>
<a name="ln292">                    fg[1] &gt;&gt;= image_subpixel_shift * 2;</a>
<a name="ln293">                    fg[2] &gt;&gt;= image_subpixel_shift * 2;</a>
<a name="ln294">                    fg[3] &gt;&gt;= image_subpixel_shift * 2;</a>
<a name="ln295">                }</a>
<a name="ln296">                else</a>
<a name="ln297">                {</a>
<a name="ln298">                    if(x_lr &lt; -1   || y_lr &lt; -1 ||</a>
<a name="ln299">                       x_lr &gt; maxx || y_lr &gt; maxy)</a>
<a name="ln300">                    {</a>
<a name="ln301">                        fg[order_type::R] = back_r;</a>
<a name="ln302">                        fg[order_type::G] = back_g;</a>
<a name="ln303">                        fg[order_type::B] = back_b;</a>
<a name="ln304">                        fg[order_type::A] = back_a;</a>
<a name="ln305">                    }</a>
<a name="ln306">                    else</a>
<a name="ln307">                    {</a>
<a name="ln308">                        fg[0] = </a>
<a name="ln309">                        fg[1] = </a>
<a name="ln310">                        fg[2] = </a>
<a name="ln311">                        fg[3] = image_subpixel_scale * image_subpixel_scale / 2;</a>
<a name="ln312"> </a>
<a name="ln313">                        x_hr &amp;= image_subpixel_mask;</a>
<a name="ln314">                        y_hr &amp;= image_subpixel_mask;</a>
<a name="ln315"> </a>
<a name="ln316">                        weight = (image_subpixel_scale - x_hr) * </a>
<a name="ln317">                                 (image_subpixel_scale - y_hr);</a>
<a name="ln318">                        if(x_lr &gt;= 0    &amp;&amp; y_lr &gt;= 0 &amp;&amp;</a>
<a name="ln319">                           x_lr &lt;= maxx &amp;&amp; y_lr &lt;= maxy)</a>
<a name="ln320">                        {</a>
<a name="ln321">                            fg_ptr = (const value_type*)</a>
<a name="ln322">                                base_type::source().row_ptr(y_lr) + (x_lr &lt;&lt; 2);</a>
<a name="ln323"> </a>
<a name="ln324">                            fg[0] += weight * *fg_ptr++;</a>
<a name="ln325">                            fg[1] += weight * *fg_ptr++;</a>
<a name="ln326">                            fg[2] += weight * *fg_ptr++;</a>
<a name="ln327">                            fg[3] += weight * *fg_ptr++;</a>
<a name="ln328">                        }</a>
<a name="ln329">                        else</a>
<a name="ln330">                        {</a>
<a name="ln331">                            fg[order_type::R] += back_r * weight;</a>
<a name="ln332">                            fg[order_type::G] += back_g * weight;</a>
<a name="ln333">                            fg[order_type::B] += back_b * weight;</a>
<a name="ln334">                            fg[order_type::A] += back_a * weight;</a>
<a name="ln335">                        }</a>
<a name="ln336"> </a>
<a name="ln337">                        x_lr++;</a>
<a name="ln338"> </a>
<a name="ln339">                        weight = x_hr * (image_subpixel_scale - y_hr);</a>
<a name="ln340">                        if(x_lr &gt;= 0    &amp;&amp; y_lr &gt;= 0 &amp;&amp;</a>
<a name="ln341">                           x_lr &lt;= maxx &amp;&amp; y_lr &lt;= maxy)</a>
<a name="ln342">                        {</a>
<a name="ln343">                            fg_ptr = (const value_type*)</a>
<a name="ln344">                                base_type::source().row_ptr(y_lr) + (x_lr &lt;&lt; 2);</a>
<a name="ln345"> </a>
<a name="ln346">                            fg[0] += weight * *fg_ptr++;</a>
<a name="ln347">                            fg[1] += weight * *fg_ptr++;</a>
<a name="ln348">                            fg[2] += weight * *fg_ptr++;</a>
<a name="ln349">                            fg[3] += weight * *fg_ptr++;</a>
<a name="ln350">                        }</a>
<a name="ln351">                        else</a>
<a name="ln352">                        {</a>
<a name="ln353">                            fg[order_type::R] += back_r * weight;</a>
<a name="ln354">                            fg[order_type::G] += back_g * weight;</a>
<a name="ln355">                            fg[order_type::B] += back_b * weight;</a>
<a name="ln356">                            fg[order_type::A] += back_a * weight;</a>
<a name="ln357">                        }</a>
<a name="ln358"> </a>
<a name="ln359">                        x_lr--;</a>
<a name="ln360">                        y_lr++;</a>
<a name="ln361"> </a>
<a name="ln362">                        weight = (image_subpixel_scale - x_hr) * y_hr;</a>
<a name="ln363">                        if(x_lr &gt;= 0    &amp;&amp; y_lr &gt;= 0 &amp;&amp;</a>
<a name="ln364">                           x_lr &lt;= maxx &amp;&amp; y_lr &lt;= maxy)</a>
<a name="ln365">                        {</a>
<a name="ln366">                            fg_ptr = (const value_type*)</a>
<a name="ln367">                                base_type::source().row_ptr(y_lr) + (x_lr &lt;&lt; 2);</a>
<a name="ln368"> </a>
<a name="ln369">                            fg[0] += weight * *fg_ptr++;</a>
<a name="ln370">                            fg[1] += weight * *fg_ptr++;</a>
<a name="ln371">                            fg[2] += weight * *fg_ptr++;</a>
<a name="ln372">                            fg[3] += weight * *fg_ptr++;</a>
<a name="ln373">                        }</a>
<a name="ln374">                        else</a>
<a name="ln375">                        {</a>
<a name="ln376">                            fg[order_type::R] += back_r * weight;</a>
<a name="ln377">                            fg[order_type::G] += back_g * weight;</a>
<a name="ln378">                            fg[order_type::B] += back_b * weight;</a>
<a name="ln379">                            fg[order_type::A] += back_a * weight;</a>
<a name="ln380">                        }</a>
<a name="ln381"> </a>
<a name="ln382">                        x_lr++;</a>
<a name="ln383"> </a>
<a name="ln384">                        weight = x_hr * y_hr;</a>
<a name="ln385">                        if(x_lr &gt;= 0    &amp;&amp; y_lr &gt;= 0 &amp;&amp;</a>
<a name="ln386">                           x_lr &lt;= maxx &amp;&amp; y_lr &lt;= maxy)</a>
<a name="ln387">                        {</a>
<a name="ln388">                            fg_ptr = (const value_type*)</a>
<a name="ln389">                                base_type::source().row_ptr(y_lr) + (x_lr &lt;&lt; 2);</a>
<a name="ln390"> </a>
<a name="ln391">                            fg[0] += weight * *fg_ptr++;</a>
<a name="ln392">                            fg[1] += weight * *fg_ptr++;</a>
<a name="ln393">                            fg[2] += weight * *fg_ptr++;</a>
<a name="ln394">                            fg[3] += weight * *fg_ptr++;</a>
<a name="ln395">                        }</a>
<a name="ln396">                        else</a>
<a name="ln397">                        {</a>
<a name="ln398">                            fg[order_type::R] += back_r * weight;</a>
<a name="ln399">                            fg[order_type::G] += back_g * weight;</a>
<a name="ln400">                            fg[order_type::B] += back_b * weight;</a>
<a name="ln401">                            fg[order_type::A] += back_a * weight;</a>
<a name="ln402">                        }</a>
<a name="ln403"> </a>
<a name="ln404">                        fg[0] &gt;&gt;= image_subpixel_shift * 2;</a>
<a name="ln405">                        fg[1] &gt;&gt;= image_subpixel_shift * 2;</a>
<a name="ln406">                        fg[2] &gt;&gt;= image_subpixel_shift * 2;</a>
<a name="ln407">                        fg[3] &gt;&gt;= image_subpixel_shift * 2;</a>
<a name="ln408">                    }</a>
<a name="ln409">                }</a>
<a name="ln410"> </a>
<a name="ln411">                span-&gt;r = (value_type)fg[order_type::R];</a>
<a name="ln412">                span-&gt;g = (value_type)fg[order_type::G];</a>
<a name="ln413">                span-&gt;b = (value_type)fg[order_type::B];</a>
<a name="ln414">                span-&gt;a = (value_type)fg[order_type::A];</a>
<a name="ln415">                ++span;</a>
<a name="ln416">                ++base_type::interpolator();</a>
<a name="ln417"> </a>
<a name="ln418">            } while(--len);</a>
<a name="ln419">        }</a>
<a name="ln420">    private:</a>
<a name="ln421">        color_type m_back_color;</a>
<a name="ln422">    };</a>
<a name="ln423"> </a>
<a name="ln424"> </a>
<a name="ln425">    //==============================================span_image_filter_rgba_2x2</a>
<a name="ln426">    template&lt;class Source, class Interpolator&gt; </a>
<a name="ln427">    class span_image_filter_rgba_2x2 : </a>
<a name="ln428">    public span_image_filter&lt;Source, Interpolator&gt;</a>
<a name="ln429">    {</a>
<a name="ln430">    public:</a>
<a name="ln431">        typedef Source source_type;</a>
<a name="ln432">        typedef typename source_type::color_type color_type;</a>
<a name="ln433">        typedef typename source_type::order_type order_type;</a>
<a name="ln434">        typedef Interpolator interpolator_type;</a>
<a name="ln435">        typedef span_image_filter&lt;source_type, interpolator_type&gt; base_type;</a>
<a name="ln436">        typedef typename color_type::value_type value_type;</a>
<a name="ln437">        typedef typename color_type::calc_type calc_type;</a>
<a name="ln438">        enum base_scale_e</a>
<a name="ln439">        {</a>
<a name="ln440">            base_shift = color_type::base_shift,</a>
<a name="ln441">            base_mask  = color_type::base_mask</a>
<a name="ln442">        };</a>
<a name="ln443"> </a>
<a name="ln444">        //--------------------------------------------------------------------</a>
<a name="ln445">        span_image_filter_rgba_2x2() {}</a>
<a name="ln446">        span_image_filter_rgba_2x2(source_type&amp; src, </a>
<a name="ln447">                                   interpolator_type&amp; inter,</a>
<a name="ln448">                                   const image_filter_lut&amp; filter) :</a>
<a name="ln449">            base_type(src, inter, &amp;filter) </a>
<a name="ln450">        {}</a>
<a name="ln451"> </a>
<a name="ln452"> </a>
<a name="ln453">        //--------------------------------------------------------------------</a>
<a name="ln454">        void generate(color_type* span, int x, int y, unsigned len)</a>
<a name="ln455">        {</a>
<a name="ln456">            base_type::interpolator().begin(x + base_type::filter_dx_dbl(), </a>
<a name="ln457">                                            y + base_type::filter_dy_dbl(), len);</a>
<a name="ln458"> </a>
<a name="ln459">            calc_type fg[4];</a>
<a name="ln460"> </a>
<a name="ln461">            const value_type *fg_ptr;</a>
<a name="ln462">            const int16* weight_array = base_type::filter().weight_array() + </a>
<a name="ln463">                                        ((base_type::filter().diameter()/2 - 1) &lt;&lt; </a>
<a name="ln464">                                          image_subpixel_shift);</a>
<a name="ln465"> </a>
<a name="ln466">            do</a>
<a name="ln467">            {</a>
<a name="ln468">                int x_hr;</a>
<a name="ln469">                int y_hr;</a>
<a name="ln470"> </a>
<a name="ln471">                base_type::interpolator().coordinates(&amp;x_hr, &amp;y_hr);</a>
<a name="ln472"> </a>
<a name="ln473">                x_hr -= base_type::filter_dx_int();</a>
<a name="ln474">                y_hr -= base_type::filter_dy_int();</a>
<a name="ln475"> </a>
<a name="ln476">                int x_lr = x_hr &gt;&gt; image_subpixel_shift;</a>
<a name="ln477">                int y_lr = y_hr &gt;&gt; image_subpixel_shift;</a>
<a name="ln478"> </a>
<a name="ln479">                unsigned weight;</a>
<a name="ln480">                fg[0] = fg[1] = fg[2] = fg[3] = image_filter_scale / 2;</a>
<a name="ln481"> </a>
<a name="ln482">                x_hr &amp;= image_subpixel_mask;</a>
<a name="ln483">                y_hr &amp;= image_subpixel_mask;</a>
<a name="ln484"> </a>
<a name="ln485">                fg_ptr = (const value_type*)base_type::source().span(x_lr, y_lr, 2);</a>
<a name="ln486">                weight = (weight_array[x_hr + image_subpixel_scale] * </a>
<a name="ln487">                          weight_array[y_hr + image_subpixel_scale] + </a>
<a name="ln488">                          image_filter_scale / 2) &gt;&gt; </a>
<a name="ln489">                          image_filter_shift;</a>
<a name="ln490">                fg[0] += weight * *fg_ptr++;</a>
<a name="ln491">                fg[1] += weight * *fg_ptr++;</a>
<a name="ln492">                fg[2] += weight * *fg_ptr++;</a>
<a name="ln493">                fg[3] += weight * *fg_ptr;</a>
<a name="ln494"> </a>
<a name="ln495">                fg_ptr = (const value_type*)base_type::source().next_x();</a>
<a name="ln496">                weight = (weight_array[x_hr] * </a>
<a name="ln497">                          weight_array[y_hr + image_subpixel_scale] + </a>
<a name="ln498">                          image_filter_scale / 2) &gt;&gt; </a>
<a name="ln499">                          image_filter_shift;</a>
<a name="ln500">                fg[0] += weight * *fg_ptr++;</a>
<a name="ln501">                fg[1] += weight * *fg_ptr++;</a>
<a name="ln502">                fg[2] += weight * *fg_ptr++;</a>
<a name="ln503">                fg[3] += weight * *fg_ptr;</a>
<a name="ln504"> </a>
<a name="ln505">                fg_ptr = (const value_type*)base_type::source().next_y();</a>
<a name="ln506">                weight = (weight_array[x_hr + image_subpixel_scale] * </a>
<a name="ln507">                          weight_array[y_hr] + </a>
<a name="ln508">                          image_filter_scale / 2) &gt;&gt; </a>
<a name="ln509">                          image_filter_shift;</a>
<a name="ln510">                fg[0] += weight * *fg_ptr++;</a>
<a name="ln511">                fg[1] += weight * *fg_ptr++;</a>
<a name="ln512">                fg[2] += weight * *fg_ptr++;</a>
<a name="ln513">                fg[3] += weight * *fg_ptr;</a>
<a name="ln514"> </a>
<a name="ln515">                fg_ptr = (const value_type*)base_type::source().next_x();</a>
<a name="ln516">                weight = (weight_array[x_hr] * </a>
<a name="ln517">                          weight_array[y_hr] + </a>
<a name="ln518">                          image_filter_scale / 2) &gt;&gt; </a>
<a name="ln519">                          image_filter_shift;</a>
<a name="ln520">                fg[0] += weight * *fg_ptr++;</a>
<a name="ln521">                fg[1] += weight * *fg_ptr++;</a>
<a name="ln522">                fg[2] += weight * *fg_ptr++;</a>
<a name="ln523">                fg[3] += weight * *fg_ptr;</a>
<a name="ln524"> </a>
<a name="ln525">                fg[0] &gt;&gt;= image_filter_shift;</a>
<a name="ln526">                fg[1] &gt;&gt;= image_filter_shift;</a>
<a name="ln527">                fg[2] &gt;&gt;= image_filter_shift;</a>
<a name="ln528">                fg[3] &gt;&gt;= image_filter_shift;</a>
<a name="ln529"> </a>
<a name="ln530">                if(fg[order_type::A] &gt; base_mask)         fg[order_type::A] = base_mask;</a>
<a name="ln531">                if(fg[order_type::R] &gt; fg[order_type::A]) fg[order_type::R] = fg[order_type::A];</a>
<a name="ln532">                if(fg[order_type::G] &gt; fg[order_type::A]) fg[order_type::G] = fg[order_type::A];</a>
<a name="ln533">                if(fg[order_type::B] &gt; fg[order_type::A]) fg[order_type::B] = fg[order_type::A];</a>
<a name="ln534"> </a>
<a name="ln535">                span-&gt;r = (value_type)fg[order_type::R];</a>
<a name="ln536">                span-&gt;g = (value_type)fg[order_type::G];</a>
<a name="ln537">                span-&gt;b = (value_type)fg[order_type::B];</a>
<a name="ln538">                span-&gt;a = (value_type)fg[order_type::A];</a>
<a name="ln539">                ++span;</a>
<a name="ln540">                ++base_type::interpolator();</a>
<a name="ln541"> </a>
<a name="ln542">            } while(--len);</a>
<a name="ln543">        }</a>
<a name="ln544">    };</a>
<a name="ln545"> </a>
<a name="ln546"> </a>
<a name="ln547"> </a>
<a name="ln548">    //==================================================span_image_filter_rgba</a>
<a name="ln549">    template&lt;class Source, class Interpolator&gt; </a>
<a name="ln550">    class span_image_filter_rgba : </a>
<a name="ln551">    public span_image_filter&lt;Source, Interpolator&gt;</a>
<a name="ln552">    {</a>
<a name="ln553">    public:</a>
<a name="ln554">        typedef Source source_type;</a>
<a name="ln555">        typedef typename source_type::color_type color_type;</a>
<a name="ln556">        typedef typename source_type::order_type order_type;</a>
<a name="ln557">        typedef Interpolator interpolator_type;</a>
<a name="ln558">        typedef span_image_filter&lt;source_type, interpolator_type&gt; base_type;</a>
<a name="ln559">        typedef typename color_type::value_type value_type;</a>
<a name="ln560">        typedef typename color_type::calc_type calc_type;</a>
<a name="ln561">        enum base_scale_e</a>
<a name="ln562">        {</a>
<a name="ln563">            base_shift = color_type::base_shift,</a>
<a name="ln564">            base_mask  = color_type::base_mask</a>
<a name="ln565">        };</a>
<a name="ln566"> </a>
<a name="ln567">        //--------------------------------------------------------------------</a>
<a name="ln568">        span_image_filter_rgba() {}</a>
<a name="ln569">        span_image_filter_rgba(source_type&amp; src, </a>
<a name="ln570">                               interpolator_type&amp; inter,</a>
<a name="ln571">                               const image_filter_lut&amp; filter) :</a>
<a name="ln572">            base_type(src, inter, &amp;filter) </a>
<a name="ln573">        {}</a>
<a name="ln574"> </a>
<a name="ln575">        //--------------------------------------------------------------------</a>
<a name="ln576">        void generate(color_type* span, int x, int y, unsigned len)</a>
<a name="ln577">        {</a>
<a name="ln578">            base_type::interpolator().begin(x + base_type::filter_dx_dbl(), </a>
<a name="ln579">                                            y + base_type::filter_dy_dbl(), len);</a>
<a name="ln580"> </a>
<a name="ln581">            int fg[4];</a>
<a name="ln582">            const value_type *fg_ptr;</a>
<a name="ln583"> </a>
<a name="ln584">            unsigned     diameter     = base_type::filter().diameter();</a>
<a name="ln585">            int          start        = base_type::filter().start();</a>
<a name="ln586">            const int16* weight_array = base_type::filter().weight_array();</a>
<a name="ln587"> </a>
<a name="ln588">            int x_count; </a>
<a name="ln589">            int weight_y;</a>
<a name="ln590"> </a>
<a name="ln591">            do</a>
<a name="ln592">            {</a>
<a name="ln593">                base_type::interpolator().coordinates(&amp;x, &amp;y);</a>
<a name="ln594"> </a>
<a name="ln595">                x -= base_type::filter_dx_int();</a>
<a name="ln596">                y -= base_type::filter_dy_int();</a>
<a name="ln597"> </a>
<a name="ln598">                int x_hr = x; </a>
<a name="ln599">                int y_hr = y; </a>
<a name="ln600"> </a>
<a name="ln601">                int x_lr = x_hr &gt;&gt; image_subpixel_shift;</a>
<a name="ln602">                int y_lr = y_hr &gt;&gt; image_subpixel_shift;</a>
<a name="ln603"> </a>
<a name="ln604">                fg[0] = fg[1] = fg[2] = fg[3] = image_filter_scale / 2;</a>
<a name="ln605"> </a>
<a name="ln606">                int x_fract = x_hr &amp; image_subpixel_mask;</a>
<a name="ln607">                unsigned y_count = diameter;</a>
<a name="ln608"> </a>
<a name="ln609">                y_hr = image_subpixel_mask - (y_hr &amp; image_subpixel_mask);</a>
<a name="ln610">                fg_ptr = (const value_type*)base_type::source().span(x_lr + start, </a>
<a name="ln611">                                                                     y_lr + start, </a>
<a name="ln612">                                                                     diameter);</a>
<a name="ln613">                for(;;)</a>
<a name="ln614">                {</a>
<a name="ln615">                    x_count  = diameter;</a>
<a name="ln616">                    weight_y = weight_array[y_hr];</a>
<a name="ln617">                    x_hr = image_subpixel_mask - x_fract;</a>
<a name="ln618">                    for(;;)</a>
<a name="ln619">                    {</a>
<a name="ln620">                        int weight = (weight_y * weight_array[x_hr] + </a>
<a name="ln621">                                     image_filter_scale / 2) &gt;&gt; </a>
<a name="ln622">                                     image_filter_shift;</a>
<a name="ln623"> </a>
<a name="ln624">                        fg[0] += weight * *fg_ptr++;</a>
<a name="ln625">                        fg[1] += weight * *fg_ptr++;</a>
<a name="ln626">                        fg[2] += weight * *fg_ptr++;</a>
<a name="ln627">                        fg[3] += weight * *fg_ptr;</a>
<a name="ln628"> </a>
<a name="ln629">                        if(--x_count == 0) break;</a>
<a name="ln630">                        x_hr  += image_subpixel_scale;</a>
<a name="ln631">                        fg_ptr = (const value_type*)base_type::source().next_x();</a>
<a name="ln632">                    }</a>
<a name="ln633"> </a>
<a name="ln634">                    if(--y_count == 0) break;</a>
<a name="ln635">                    y_hr  += image_subpixel_scale;</a>
<a name="ln636">                    fg_ptr = (const value_type*)base_type::source().next_y();</a>
<a name="ln637">                }</a>
<a name="ln638"> </a>
<a name="ln639">                fg[0] &gt;&gt;= image_filter_shift;</a>
<a name="ln640">                fg[1] &gt;&gt;= image_filter_shift;</a>
<a name="ln641">                fg[2] &gt;&gt;= image_filter_shift;</a>
<a name="ln642">                fg[3] &gt;&gt;= image_filter_shift;</a>
<a name="ln643"> </a>
<a name="ln644">                if(fg[0] &lt; 0) fg[0] = 0;</a>
<a name="ln645">                if(fg[1] &lt; 0) fg[1] = 0;</a>
<a name="ln646">                if(fg[2] &lt; 0) fg[2] = 0;</a>
<a name="ln647">                if(fg[3] &lt; 0) fg[3] = 0;</a>
<a name="ln648"> </a>
<a name="ln649">                if(fg[order_type::A] &gt; base_mask)         fg[order_type::A] = base_mask;</a>
<a name="ln650">                if(fg[order_type::R] &gt; fg[order_type::A]) fg[order_type::R] = fg[order_type::A];</a>
<a name="ln651">                if(fg[order_type::G] &gt; fg[order_type::A]) fg[order_type::G] = fg[order_type::A];</a>
<a name="ln652">                if(fg[order_type::B] &gt; fg[order_type::A]) fg[order_type::B] = fg[order_type::A];</a>
<a name="ln653"> </a>
<a name="ln654">                span-&gt;r = (value_type)fg[order_type::R];</a>
<a name="ln655">                span-&gt;g = (value_type)fg[order_type::G];</a>
<a name="ln656">                span-&gt;b = (value_type)fg[order_type::B];</a>
<a name="ln657">                span-&gt;a = (value_type)fg[order_type::A];</a>
<a name="ln658">                ++span;</a>
<a name="ln659">                ++base_type::interpolator();</a>
<a name="ln660"> </a>
<a name="ln661">            } while(--len);</a>
<a name="ln662">        }</a>
<a name="ln663">    };</a>
<a name="ln664"> </a>
<a name="ln665"> </a>
<a name="ln666"> </a>
<a name="ln667">    //========================================span_image_resample_rgba_affine</a>
<a name="ln668">    template&lt;class Source&gt; </a>
<a name="ln669">    class span_image_resample_rgba_affine : </a>
<a name="ln670">    public span_image_resample_affine&lt;Source&gt;</a>
<a name="ln671">    {</a>
<a name="ln672">    public:</a>
<a name="ln673">        typedef Source source_type;</a>
<a name="ln674">        typedef typename source_type::color_type color_type;</a>
<a name="ln675">        typedef typename source_type::order_type order_type;</a>
<a name="ln676">        typedef span_image_resample_affine&lt;source_type&gt; base_type;</a>
<a name="ln677">        typedef typename base_type::interpolator_type interpolator_type;</a>
<a name="ln678">        typedef typename color_type::value_type value_type;</a>
<a name="ln679">        typedef typename color_type::long_type long_type;</a>
<a name="ln680">        enum base_scale_e</a>
<a name="ln681">        {</a>
<a name="ln682">            base_shift      = color_type::base_shift,</a>
<a name="ln683">            base_mask       = color_type::base_mask,</a>
<a name="ln684">            downscale_shift = image_filter_shift</a>
<a name="ln685">        };</a>
<a name="ln686"> </a>
<a name="ln687">        //--------------------------------------------------------------------</a>
<a name="ln688">        span_image_resample_rgba_affine() {}</a>
<a name="ln689">        span_image_resample_rgba_affine(source_type&amp; src, </a>
<a name="ln690">                                        interpolator_type&amp; inter,</a>
<a name="ln691">                                        const image_filter_lut&amp; filter) :</a>
<a name="ln692">            base_type(src, inter, filter) </a>
<a name="ln693">        {}</a>
<a name="ln694"> </a>
<a name="ln695"> </a>
<a name="ln696">        //--------------------------------------------------------------------</a>
<a name="ln697">        void generate(color_type* span, int x, int y, unsigned len)</a>
<a name="ln698">        {</a>
<a name="ln699">            base_type::interpolator().begin(x + base_type::filter_dx_dbl(), </a>
<a name="ln700">                                            y + base_type::filter_dy_dbl(), len);</a>
<a name="ln701"> </a>
<a name="ln702">            long_type fg[4];</a>
<a name="ln703"> </a>
<a name="ln704">            int diameter     = base_type::filter().diameter();</a>
<a name="ln705">            int filter_scale = diameter &lt;&lt; image_subpixel_shift;</a>
<a name="ln706">            int radius_x     = (diameter * base_type::m_rx) &gt;&gt; 1;</a>
<a name="ln707">            int radius_y     = (diameter * base_type::m_ry) &gt;&gt; 1;</a>
<a name="ln708">            int len_x_lr     = </a>
<a name="ln709">                (diameter * base_type::m_rx + image_subpixel_mask) &gt;&gt; </a>
<a name="ln710">                    image_subpixel_shift;</a>
<a name="ln711"> </a>
<a name="ln712">            const int16* weight_array = base_type::filter().weight_array();</a>
<a name="ln713"> </a>
<a name="ln714">            do</a>
<a name="ln715">            {</a>
<a name="ln716">                base_type::interpolator().coordinates(&amp;x, &amp;y);</a>
<a name="ln717"> </a>
<a name="ln718">                x += base_type::filter_dx_int() - radius_x;</a>
<a name="ln719">                y += base_type::filter_dy_int() - radius_y;</a>
<a name="ln720"> </a>
<a name="ln721">                fg[0] = fg[1] = fg[2] = fg[3] = image_filter_scale / 2;</a>
<a name="ln722"> </a>
<a name="ln723">                int y_lr = y &gt;&gt; image_subpixel_shift;</a>
<a name="ln724">                int y_hr = ((image_subpixel_mask - (y &amp; image_subpixel_mask)) * </a>
<a name="ln725">                                base_type::m_ry_inv) &gt;&gt; </a>
<a name="ln726">                                    image_subpixel_shift;</a>
<a name="ln727">                int total_weight = 0;</a>
<a name="ln728">                int x_lr = x &gt;&gt; image_subpixel_shift;</a>
<a name="ln729">                int x_hr = ((image_subpixel_mask - (x &amp; image_subpixel_mask)) * </a>
<a name="ln730">                                base_type::m_rx_inv) &gt;&gt; </a>
<a name="ln731">                                    image_subpixel_shift;</a>
<a name="ln732"> </a>
<a name="ln733">                int x_hr2 = x_hr;</a>
<a name="ln734">                const value_type* fg_ptr = </a>
<a name="ln735">                    (const value_type*)base_type::source().span(x_lr, y_lr, len_x_lr);</a>
<a name="ln736">                for(;;)</a>
<a name="ln737">                {</a>
<a name="ln738">                    int weight_y = weight_array[y_hr];</a>
<a name="ln739">                    x_hr = x_hr2;</a>
<a name="ln740">                    for(;;)</a>
<a name="ln741">                    {</a>
<a name="ln742">                        int weight = (weight_y * weight_array[x_hr] + </a>
<a name="ln743">                                     image_filter_scale / 2) &gt;&gt; </a>
<a name="ln744">                                     downscale_shift;</a>
<a name="ln745"> </a>
<a name="ln746">                        fg[0] += *fg_ptr++ * weight;</a>
<a name="ln747">                        fg[1] += *fg_ptr++ * weight;</a>
<a name="ln748">                        fg[2] += *fg_ptr++ * weight;</a>
<a name="ln749">                        fg[3] += *fg_ptr++ * weight;</a>
<a name="ln750">                        total_weight += weight;</a>
<a name="ln751">                        x_hr  += base_type::m_rx_inv;</a>
<a name="ln752">                        if(x_hr &gt;= filter_scale) break;</a>
<a name="ln753">                        fg_ptr = (const value_type*)base_type::source().next_x();</a>
<a name="ln754">                    }</a>
<a name="ln755">                    y_hr += base_type::m_ry_inv;</a>
<a name="ln756">                    if(y_hr &gt;= filter_scale) break;</a>
<a name="ln757">                    fg_ptr = (const value_type*)base_type::source().next_y();</a>
<a name="ln758">                }</a>
<a name="ln759"> </a>
<a name="ln760">                fg[0] /= total_weight;</a>
<a name="ln761">                fg[1] /= total_weight;</a>
<a name="ln762">                fg[2] /= total_weight;</a>
<a name="ln763">                fg[3] /= total_weight;</a>
<a name="ln764"> </a>
<a name="ln765">                if(fg[0] &lt; 0) fg[0] = 0;</a>
<a name="ln766">                if(fg[1] &lt; 0) fg[1] = 0;</a>
<a name="ln767">                if(fg[2] &lt; 0) fg[2] = 0;</a>
<a name="ln768">                if(fg[3] &lt; 0) fg[3] = 0;</a>
<a name="ln769"> </a>
<a name="ln770">                if(fg[order_type::A] &gt; base_mask)         fg[order_type::A] = base_mask;</a>
<a name="ln771">                if(fg[order_type::R] &gt; fg[order_type::A]) fg[order_type::R] = fg[order_type::A];</a>
<a name="ln772">                if(fg[order_type::G] &gt; fg[order_type::A]) fg[order_type::G] = fg[order_type::A];</a>
<a name="ln773">                if(fg[order_type::B] &gt; fg[order_type::A]) fg[order_type::B] = fg[order_type::A];</a>
<a name="ln774"> </a>
<a name="ln775">                span-&gt;r = (value_type)fg[order_type::R];</a>
<a name="ln776">                span-&gt;g = (value_type)fg[order_type::G];</a>
<a name="ln777">                span-&gt;b = (value_type)fg[order_type::B];</a>
<a name="ln778">                span-&gt;a = (value_type)fg[order_type::A];</a>
<a name="ln779"> </a>
<a name="ln780">                ++span;</a>
<a name="ln781">                ++base_type::interpolator();</a>
<a name="ln782">            } while(--len);</a>
<a name="ln783">        }</a>
<a name="ln784">    };</a>
<a name="ln785"> </a>
<a name="ln786"> </a>
<a name="ln787"> </a>
<a name="ln788">    //==============================================span_image_resample_rgba</a>
<a name="ln789">    template&lt;class Source, class Interpolator&gt;</a>
<a name="ln790">    class span_image_resample_rgba : </a>
<a name="ln791">    public span_image_resample&lt;Source, Interpolator&gt;</a>
<a name="ln792">    {</a>
<a name="ln793">    public:</a>
<a name="ln794">        typedef Source source_type;</a>
<a name="ln795">        typedef typename source_type::color_type color_type;</a>
<a name="ln796">        typedef typename source_type::order_type order_type;</a>
<a name="ln797">        typedef Interpolator interpolator_type;</a>
<a name="ln798">        typedef span_image_resample&lt;source_type, interpolator_type&gt; base_type;</a>
<a name="ln799">        typedef typename color_type::value_type value_type;</a>
<a name="ln800">        typedef typename color_type::long_type long_type;</a>
<a name="ln801">        enum base_scale_e</a>
<a name="ln802">        {</a>
<a name="ln803">            base_shift = color_type::base_shift,</a>
<a name="ln804">            base_mask  = color_type::base_mask,</a>
<a name="ln805">            downscale_shift = image_filter_shift</a>
<a name="ln806">        };</a>
<a name="ln807"> </a>
<a name="ln808">        //--------------------------------------------------------------------</a>
<a name="ln809">        span_image_resample_rgba() {}</a>
<a name="ln810">        span_image_resample_rgba(source_type&amp; src, </a>
<a name="ln811">                                 interpolator_type&amp; inter,</a>
<a name="ln812">                                 const image_filter_lut&amp; filter) :</a>
<a name="ln813">            base_type(src, inter, filter)</a>
<a name="ln814">        {}</a>
<a name="ln815"> </a>
<a name="ln816">        //--------------------------------------------------------------------</a>
<a name="ln817">        void generate(color_type* span, int x, int y, unsigned len)</a>
<a name="ln818">        {</a>
<a name="ln819">            base_type::interpolator().begin(x + base_type::filter_dx_dbl(), </a>
<a name="ln820">                                            y + base_type::filter_dy_dbl(), len);</a>
<a name="ln821">            long_type fg[4];</a>
<a name="ln822"> </a>
<a name="ln823">            int diameter = base_type::filter().diameter();</a>
<a name="ln824">            int filter_scale = diameter &lt;&lt; image_subpixel_shift;</a>
<a name="ln825"> </a>
<a name="ln826">            const int16* weight_array = base_type::filter().weight_array();</a>
<a name="ln827">            do</a>
<a name="ln828">            {</a>
<a name="ln829">                int rx;</a>
<a name="ln830">                int ry;</a>
<a name="ln831">                int rx_inv = image_subpixel_scale;</a>
<a name="ln832">                int ry_inv = image_subpixel_scale;</a>
<a name="ln833">                base_type::interpolator().coordinates(&amp;x,  &amp;y);</a>
<a name="ln834">                base_type::interpolator().local_scale(&amp;rx, &amp;ry);</a>
<a name="ln835">                base_type::adjust_scale(&amp;rx, &amp;ry);</a>
<a name="ln836"> </a>
<a name="ln837">                rx_inv = image_subpixel_scale * image_subpixel_scale / rx;</a>
<a name="ln838">                ry_inv = image_subpixel_scale * image_subpixel_scale / ry;</a>
<a name="ln839"> </a>
<a name="ln840">                int radius_x = (diameter * rx) &gt;&gt; 1;</a>
<a name="ln841">                int radius_y = (diameter * ry) &gt;&gt; 1;</a>
<a name="ln842">                int len_x_lr = </a>
<a name="ln843">                    (diameter * rx + image_subpixel_mask) &gt;&gt; </a>
<a name="ln844">                        image_subpixel_shift;</a>
<a name="ln845"> </a>
<a name="ln846">                x += base_type::filter_dx_int() - radius_x;</a>
<a name="ln847">                y += base_type::filter_dy_int() - radius_y;</a>
<a name="ln848"> </a>
<a name="ln849">                fg[0] = fg[1] = fg[2] = fg[3] = image_filter_scale / 2;</a>
<a name="ln850"> </a>
<a name="ln851">                int y_lr = y &gt;&gt; image_subpixel_shift;</a>
<a name="ln852">                int y_hr = ((image_subpixel_mask - (y &amp; image_subpixel_mask)) * </a>
<a name="ln853">                               ry_inv) &gt;&gt; </a>
<a name="ln854">                                   image_subpixel_shift;</a>
<a name="ln855">                int total_weight = 0;</a>
<a name="ln856">                int x_lr = x &gt;&gt; image_subpixel_shift;</a>
<a name="ln857">                int x_hr = ((image_subpixel_mask - (x &amp; image_subpixel_mask)) * </a>
<a name="ln858">                               rx_inv) &gt;&gt; </a>
<a name="ln859">                                   image_subpixel_shift;</a>
<a name="ln860">                int x_hr2 = x_hr;</a>
<a name="ln861">                const value_type* fg_ptr = </a>
<a name="ln862">                    (const value_type*)base_type::source().span(x_lr, y_lr, len_x_lr);</a>
<a name="ln863"> </a>
<a name="ln864">                for(;;)</a>
<a name="ln865">                {</a>
<a name="ln866">                    int weight_y = weight_array[y_hr];</a>
<a name="ln867">                    x_hr = x_hr2;</a>
<a name="ln868">                    for(;;)</a>
<a name="ln869">                    {</a>
<a name="ln870">                        int weight = (weight_y * weight_array[x_hr] + </a>
<a name="ln871">                                     image_filter_scale / 2) &gt;&gt; </a>
<a name="ln872">                                     downscale_shift;</a>
<a name="ln873">                        fg[0] += *fg_ptr++ * weight;</a>
<a name="ln874">                        fg[1] += *fg_ptr++ * weight;</a>
<a name="ln875">                        fg[2] += *fg_ptr++ * weight;</a>
<a name="ln876">                        fg[3] += *fg_ptr++ * weight;</a>
<a name="ln877">                        total_weight += weight;</a>
<a name="ln878">                        x_hr  += rx_inv;</a>
<a name="ln879">                        if(x_hr &gt;= filter_scale) break;</a>
<a name="ln880">                        fg_ptr = (const value_type*)base_type::source().next_x();</a>
<a name="ln881">                    }</a>
<a name="ln882">                    y_hr += ry_inv;</a>
<a name="ln883">                    if(y_hr &gt;= filter_scale) break;</a>
<a name="ln884">                    fg_ptr = (const value_type*)base_type::source().next_y();</a>
<a name="ln885">                }</a>
<a name="ln886"> </a>
<a name="ln887">                fg[0] /= total_weight;</a>
<a name="ln888">                fg[1] /= total_weight;</a>
<a name="ln889">                fg[2] /= total_weight;</a>
<a name="ln890">                fg[3] /= total_weight;</a>
<a name="ln891"> </a>
<a name="ln892">                if(fg[0] &lt; 0) fg[0] = 0;</a>
<a name="ln893">                if(fg[1] &lt; 0) fg[1] = 0;</a>
<a name="ln894">                if(fg[2] &lt; 0) fg[2] = 0;</a>
<a name="ln895">                if(fg[3] &lt; 0) fg[3] = 0;</a>
<a name="ln896"> </a>
<a name="ln897">                if(fg[order_type::A] &gt; base_mask)         fg[order_type::A] = base_mask;</a>
<a name="ln898">                if(fg[order_type::R] &gt; fg[order_type::R]) fg[order_type::R] = fg[order_type::R];</a>
<a name="ln899">                if(fg[order_type::G] &gt; fg[order_type::G]) fg[order_type::G] = fg[order_type::G];</a>
<a name="ln900">                if(fg[order_type::B] &gt; fg[order_type::B]) fg[order_type::B] = fg[order_type::B];</a>
<a name="ln901"> </a>
<a name="ln902">                span-&gt;r = (value_type)fg[order_type::R];</a>
<a name="ln903">                span-&gt;g = (value_type)fg[order_type::G];</a>
<a name="ln904">                span-&gt;b = (value_type)fg[order_type::B];</a>
<a name="ln905">                span-&gt;a = (value_type)fg[order_type::A];</a>
<a name="ln906"> </a>
<a name="ln907">                ++span;</a>
<a name="ln908">                ++base_type::interpolator();</a>
<a name="ln909">            } while(--len);</a>
<a name="ln910">        }</a>
<a name="ln911">    };</a>
<a name="ln912"> </a>
<a name="ln913"> </a>
<a name="ln914">}</a>
<a name="ln915"> </a>
<a name="ln916"> </a>
<a name="ln917">#endif</a>
<a name="ln918"> </a>
<a name="ln919"> </a>
<a name="ln920"> </a>

</code></pre>
<div class="balloon" rel="898"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v570/" target="_blank">V570</a> The 'fg[order_type::R]' variable is assigned to itself.</p></div>
<div class="balloon" rel="898"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v501/" target="_blank">V501</a> There are identical sub-expressions to the left and to the right of the '>' operator: fg[order_type::R] > fg[order_type::R]</p></div>
<div class="balloon" rel="899"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v501/" target="_blank">V501</a> There are identical sub-expressions to the left and to the right of the '>' operator: fg[order_type::G] > fg[order_type::G]</p></div>
<div class="balloon" rel="900"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v501/" target="_blank">V501</a> There are identical sub-expressions to the left and to the right of the '>' operator: fg[order_type::B] > fg[order_type::B]</p></div>
<div class="balloon" rel="899"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v570/" target="_blank">V570</a> The 'fg[order_type::G]' variable is assigned to itself.</p></div>
<div class="balloon" rel="900"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v570/" target="_blank">V570</a> The 'fg[order_type::B]' variable is assigned to itself.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
