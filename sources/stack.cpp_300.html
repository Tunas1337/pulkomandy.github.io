
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>stack.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2006-2010, Haiku, Inc. All Rights Reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Axel DÃ¶rfler, axeld@pinc-software.de</a>
<a name="ln7"> */</a>
<a name="ln8"> </a>
<a name="ln9"> </a>
<a name="ln10">#include &quot;ancillary_data.h&quot;</a>
<a name="ln11">#include &quot;device_interfaces.h&quot;</a>
<a name="ln12">#include &quot;domains.h&quot;</a>
<a name="ln13">#include &quot;interfaces.h&quot;</a>
<a name="ln14">#include &quot;link.h&quot;</a>
<a name="ln15">#include &quot;stack_private.h&quot;</a>
<a name="ln16">#include &quot;utility.h&quot;</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;net_datalink_protocol.h&gt;</a>
<a name="ln19">#include &lt;net_device.h&gt;</a>
<a name="ln20">#include &lt;net_protocol.h&gt;</a>
<a name="ln21">#include &lt;net_stack.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;lock.h&gt;</a>
<a name="ln24">#include &lt;util/AutoLock.h&gt;</a>
<a name="ln25"> </a>
<a name="ln26">#include &lt;KernelExport.h&gt;</a>
<a name="ln27"> </a>
<a name="ln28">#include &lt;net/if_types.h&gt;</a>
<a name="ln29">#include &lt;new&gt;</a>
<a name="ln30">#include &lt;stdarg.h&gt;</a>
<a name="ln31">#include &lt;stdlib.h&gt;</a>
<a name="ln32">#include &lt;string.h&gt;</a>
<a name="ln33"> </a>
<a name="ln34"> </a>
<a name="ln35">//#define TRACE_STACK</a>
<a name="ln36">#ifdef TRACE_STACK</a>
<a name="ln37">#	define TRACE(x) dprintf x</a>
<a name="ln38">#else</a>
<a name="ln39">#	define TRACE(x) ;</a>
<a name="ln40">#endif</a>
<a name="ln41"> </a>
<a name="ln42">#define MAX_CHAIN_MODULES 5</a>
<a name="ln43"> </a>
<a name="ln44">struct chain;</a>
<a name="ln45">typedef DoublyLinkedList&lt;chain&gt; ChainList;</a>
<a name="ln46"> </a>
<a name="ln47">struct chain_key {</a>
<a name="ln48">	int		family;</a>
<a name="ln49">	int		type;</a>
<a name="ln50">	int		protocol;</a>
<a name="ln51">};</a>
<a name="ln52"> </a>
<a name="ln53">struct family {</a>
<a name="ln54">	family(int type);</a>
<a name="ln55"> </a>
<a name="ln56">	void Acquire();</a>
<a name="ln57">	void Release();</a>
<a name="ln58"> </a>
<a name="ln59">	static int Compare(void* _family, const void* _key);</a>
<a name="ln60">	static uint32 Hash(void* _family, const void* _key, uint32 range);</a>
<a name="ln61">	static struct family* Lookup(int type);</a>
<a name="ln62">	static struct family* Add(int type);</a>
<a name="ln63"> </a>
<a name="ln64">	struct family*	next;</a>
<a name="ln65">	int				type;</a>
<a name="ln66">	int32			ref_count;</a>
<a name="ln67">	ChainList		chains;</a>
<a name="ln68">};</a>
<a name="ln69"> </a>
<a name="ln70">struct ChainHash;</a>
<a name="ln71"> </a>
<a name="ln72">struct chain : DoublyLinkedListLinkImpl&lt;chain&gt; {</a>
<a name="ln73">	chain(int family, int type, int protocol);</a>
<a name="ln74">	~chain();</a>
<a name="ln75"> </a>
<a name="ln76">	status_t Acquire();</a>
<a name="ln77">	void Release();</a>
<a name="ln78">	void Uninitialize();</a>
<a name="ln79"> </a>
<a name="ln80">	static struct chain* Lookup(BOpenHashTable&lt;ChainHash&gt;* chains,</a>
<a name="ln81">		int family, int type, int protocol);</a>
<a name="ln82">	static struct chain* Add(BOpenHashTable&lt;ChainHash&gt;* chains,</a>
<a name="ln83">		int family, int type, int protocol, va_list modules);</a>
<a name="ln84">	static struct chain* Add(BOpenHashTable&lt;ChainHash&gt;* chains,</a>
<a name="ln85">		int family, int type, int protocol, ...);</a>
<a name="ln86">	static void DeleteChains(BOpenHashTable&lt;ChainHash&gt;* chains);</a>
<a name="ln87"> </a>
<a name="ln88">	chain*			next;</a>
<a name="ln89">	struct family*	parent;</a>
<a name="ln90"> </a>
<a name="ln91">	int 			family;</a>
<a name="ln92">	int				type;</a>
<a name="ln93">	int				protocol;</a>
<a name="ln94"> </a>
<a name="ln95">	int32			ref_count;</a>
<a name="ln96">	uint32			flags;</a>
<a name="ln97">	const char*		modules[MAX_CHAIN_MODULES + 1];</a>
<a name="ln98">	module_info*	infos[MAX_CHAIN_MODULES + 1];</a>
<a name="ln99">};</a>
<a name="ln100"> </a>
<a name="ln101">struct ChainHash {</a>
<a name="ln102">	typedef chain_key	KeyType;</a>
<a name="ln103">	typedef	chain		ValueType;</a>
<a name="ln104"> </a>
<a name="ln105">// TODO: check if this makes a good hash...</a>
<a name="ln106">#define HASH(o) ((uint32)(((o)-&gt;family) ^ ((o)-&gt;type) ^ ((o)-&gt;protocol)))</a>
<a name="ln107"> </a>
<a name="ln108">	size_t HashKey(KeyType key) const</a>
<a name="ln109">	{</a>
<a name="ln110">		return HASH(&amp;key);</a>
<a name="ln111">	}</a>
<a name="ln112"> </a>
<a name="ln113">	size_t Hash(ValueType* value) const</a>
<a name="ln114">	{</a>
<a name="ln115">		return HASH(value);</a>
<a name="ln116">	}</a>
<a name="ln117"> </a>
<a name="ln118">#undef HASH</a>
<a name="ln119"> </a>
<a name="ln120">	bool Compare(KeyType key, ValueType* chain) const</a>
<a name="ln121">	{</a>
<a name="ln122">		if (chain-&gt;family == key.family</a>
<a name="ln123">			&amp;&amp; chain-&gt;type == key.type</a>
<a name="ln124">			&amp;&amp; chain-&gt;protocol == key.protocol)</a>
<a name="ln125">			return true;</a>
<a name="ln126"> </a>
<a name="ln127">		return false;</a>
<a name="ln128">	}</a>
<a name="ln129"> </a>
<a name="ln130">	ValueType*&amp; GetLink(ValueType* value) const</a>
<a name="ln131">	{</a>
<a name="ln132">		return value-&gt;next;</a>
<a name="ln133">	}</a>
<a name="ln134">};</a>
<a name="ln135"> </a>
<a name="ln136">struct FamilyHash {</a>
<a name="ln137">	typedef int			KeyType;</a>
<a name="ln138">	typedef	family		ValueType;</a>
<a name="ln139"> </a>
<a name="ln140">	size_t HashKey(KeyType key) const</a>
<a name="ln141">	{</a>
<a name="ln142">		return key;</a>
<a name="ln143">	}</a>
<a name="ln144"> </a>
<a name="ln145">	size_t Hash(ValueType* value) const</a>
<a name="ln146">	{</a>
<a name="ln147">		return value-&gt;type;</a>
<a name="ln148">	}</a>
<a name="ln149"> </a>
<a name="ln150">	bool Compare(KeyType key, ValueType* family) const</a>
<a name="ln151">	{</a>
<a name="ln152">		return family-&gt;type == key;</a>
<a name="ln153">	}</a>
<a name="ln154"> </a>
<a name="ln155">	ValueType*&amp; GetLink(ValueType* value) const</a>
<a name="ln156">	{</a>
<a name="ln157">		return value-&gt;next;</a>
<a name="ln158">	}</a>
<a name="ln159">};</a>
<a name="ln160"> </a>
<a name="ln161">typedef BOpenHashTable&lt;ChainHash&gt; ChainTable;</a>
<a name="ln162">typedef BOpenHashTable&lt;FamilyHash&gt; FamilyTable;</a>
<a name="ln163"> </a>
<a name="ln164">#define CHAIN_MISSING_MODULE	0x02</a>
<a name="ln165">#define CHAIN_INITIALIZED		0x01</a>
<a name="ln166"> </a>
<a name="ln167">static mutex sChainLock;</a>
<a name="ln168">static mutex sInitializeChainLock;</a>
<a name="ln169">static ChainTable* sProtocolChains;</a>
<a name="ln170">static ChainTable* sDatalinkProtocolChains;</a>
<a name="ln171">static ChainTable* sReceivingProtocolChains;</a>
<a name="ln172">static FamilyTable* sFamilies;</a>
<a name="ln173">static bool sInitialized;</a>
<a name="ln174"> </a>
<a name="ln175"> </a>
<a name="ln176">family::family(int _type)</a>
<a name="ln177">	:</a>
<a name="ln178">	type(_type),</a>
<a name="ln179">	ref_count(0)</a>
<a name="ln180">{</a>
<a name="ln181">}</a>
<a name="ln182"> </a>
<a name="ln183"> </a>
<a name="ln184">void</a>
<a name="ln185">family::Acquire()</a>
<a name="ln186">{</a>
<a name="ln187">	atomic_add(&amp;ref_count, 1);</a>
<a name="ln188">}</a>
<a name="ln189"> </a>
<a name="ln190"> </a>
<a name="ln191">void</a>
<a name="ln192">family::Release()</a>
<a name="ln193">{</a>
<a name="ln194">	if (atomic_add(&amp;ref_count, -1) &gt; 1)</a>
<a name="ln195">		return;</a>
<a name="ln196"> </a>
<a name="ln197">	TRACE((&quot;family %d unused, uninit chains\n&quot;, type));</a>
<a name="ln198">	MutexLocker _(sChainLock);</a>
<a name="ln199"> </a>
<a name="ln200">	ChainList::Iterator iterator = chains.GetIterator();</a>
<a name="ln201">	while (struct chain* chain = iterator.Next()) {</a>
<a name="ln202">		chain-&gt;Uninitialize();</a>
<a name="ln203">	}</a>
<a name="ln204">}</a>
<a name="ln205"> </a>
<a name="ln206"> </a>
<a name="ln207">/*static*/ struct family*</a>
<a name="ln208">family::Lookup(int type)</a>
<a name="ln209">{</a>
<a name="ln210">	return sFamilies-&gt;Lookup(type);</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213"> </a>
<a name="ln214">/*static*/ struct family*</a>
<a name="ln215">family::Add(int type)</a>
<a name="ln216">{</a>
<a name="ln217">	struct family* family = new (std::nothrow) ::family(type);</a>
<a name="ln218">	if (family == NULL)</a>
<a name="ln219">		return NULL;</a>
<a name="ln220"> </a>
<a name="ln221">	if (sFamilies-&gt;Insert(family) != B_OK) {</a>
<a name="ln222">		delete family;</a>
<a name="ln223">		return NULL;</a>
<a name="ln224">	}</a>
<a name="ln225"> </a>
<a name="ln226">	return family;</a>
<a name="ln227">}</a>
<a name="ln228"> </a>
<a name="ln229"> </a>
<a name="ln230">//	#pragma mark -</a>
<a name="ln231"> </a>
<a name="ln232"> </a>
<a name="ln233">chain::chain(int _family, int _type, int _protocol)</a>
<a name="ln234">	:</a>
<a name="ln235">	family(_family),</a>
<a name="ln236">	type(_type),</a>
<a name="ln237">	protocol(_protocol),</a>
<a name="ln238">	ref_count(0),</a>
<a name="ln239">	flags(0)</a>
<a name="ln240">{</a>
<a name="ln241">	parent = ::family::Lookup(family);</a>
<a name="ln242">	if (parent == NULL)</a>
<a name="ln243">		parent = ::family::Add(family);</a>
<a name="ln244"> </a>
<a name="ln245">	//parent-&gt;chains.Add(this);</a>
<a name="ln246"> </a>
<a name="ln247">	for (int32 i = 0; i &lt; MAX_CHAIN_MODULES; i++) {</a>
<a name="ln248">		modules[i] = NULL;</a>
<a name="ln249">		infos[i] = NULL;</a>
<a name="ln250">	}</a>
<a name="ln251">}</a>
<a name="ln252"> </a>
<a name="ln253"> </a>
<a name="ln254">chain::~chain()</a>
<a name="ln255">{</a>
<a name="ln256">	for (int32 i = 0; i &lt; MAX_CHAIN_MODULES; i++) {</a>
<a name="ln257">		free((char*)modules[i]);</a>
<a name="ln258">	}</a>
<a name="ln259"> </a>
<a name="ln260">	//parent-&gt;chains.Remove(this);</a>
<a name="ln261">}</a>
<a name="ln262"> </a>
<a name="ln263"> </a>
<a name="ln264">status_t</a>
<a name="ln265">chain::Acquire()</a>
<a name="ln266">{</a>
<a name="ln267">	if (atomic_add(&amp;ref_count, 1) &gt; 0) {</a>
<a name="ln268">		if ((flags &amp; CHAIN_MISSING_MODULE) != 0) {</a>
<a name="ln269">			atomic_add(&amp;ref_count, -1);</a>
<a name="ln270">			return EAFNOSUPPORT;</a>
<a name="ln271">		}</a>
<a name="ln272"> </a>
<a name="ln273">		while ((flags &amp; CHAIN_INITIALIZED) == 0) {</a>
<a name="ln274">			mutex_lock(&amp;sInitializeChainLock);</a>
<a name="ln275">			mutex_unlock(&amp;sInitializeChainLock);</a>
<a name="ln276">		}</a>
<a name="ln277">		return B_OK;</a>
<a name="ln278">	}</a>
<a name="ln279"> </a>
<a name="ln280">	parent-&gt;Acquire();</a>
<a name="ln281"> </a>
<a name="ln282">	if ((flags &amp; CHAIN_INITIALIZED) != 0)</a>
<a name="ln283">		return B_OK;</a>
<a name="ln284"> </a>
<a name="ln285">	TRACE((&quot;initializing chain %d.%d.%d\n&quot;, family, type, protocol));</a>
<a name="ln286">	MutexLocker locker(&amp;sInitializeChainLock);</a>
<a name="ln287"> </a>
<a name="ln288">	for (int32 i = 0; modules[i] != NULL; i++) {</a>
<a name="ln289">		if (get_module(modules[i], &amp;infos[i]) &lt; B_OK) {</a>
<a name="ln290">			flags |= CHAIN_MISSING_MODULE;</a>
<a name="ln291"> </a>
<a name="ln292">			// put already opened modules</a>
<a name="ln293">			while (i-- &gt; 0) {</a>
<a name="ln294">				put_module(modules[i]);</a>
<a name="ln295">			}</a>
<a name="ln296">			return EAFNOSUPPORT;</a>
<a name="ln297">		}</a>
<a name="ln298">	}</a>
<a name="ln299"> </a>
<a name="ln300">	flags |= CHAIN_INITIALIZED;</a>
<a name="ln301">	return B_OK;</a>
<a name="ln302">}</a>
<a name="ln303"> </a>
<a name="ln304"> </a>
<a name="ln305">void</a>
<a name="ln306">chain::Release()</a>
<a name="ln307">{</a>
<a name="ln308">	if (atomic_add(&amp;ref_count, -1) &gt; 1)</a>
<a name="ln309">		return;</a>
<a name="ln310"> </a>
<a name="ln311">	TRACE((&quot;chain %d.%d.%d unused\n&quot;, family, type, protocol));</a>
<a name="ln312">	parent-&gt;Release();</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315"> </a>
<a name="ln316">void</a>
<a name="ln317">chain::Uninitialize()</a>
<a name="ln318">{</a>
<a name="ln319">	if ((flags &amp; CHAIN_INITIALIZED) == 0)</a>
<a name="ln320">		return;</a>
<a name="ln321"> </a>
<a name="ln322">	TRACE((&quot;uninit chain %d.%d.%d\n&quot;, family, type, protocol));</a>
<a name="ln323">	MutexLocker _(sInitializeChainLock);</a>
<a name="ln324"> </a>
<a name="ln325">	for (int32 i = 0; modules[i] != NULL; i++) {</a>
<a name="ln326">		put_module(modules[i]);</a>
<a name="ln327">	}</a>
<a name="ln328"> </a>
<a name="ln329">	flags &amp;= ~CHAIN_INITIALIZED;</a>
<a name="ln330">}</a>
<a name="ln331"> </a>
<a name="ln332"> </a>
<a name="ln333">/*static*/ struct chain*</a>
<a name="ln334">chain::Lookup(ChainTable* chains, int family, int type, int protocol)</a>
<a name="ln335">{</a>
<a name="ln336">	struct chain_key key = { family, type, protocol };</a>
<a name="ln337">	return chains-&gt;Lookup(key);</a>
<a name="ln338">}</a>
<a name="ln339"> </a>
<a name="ln340"> </a>
<a name="ln341">/*static*/ struct chain*</a>
<a name="ln342">chain::Add(ChainTable* chains, int family, int type, int protocol,</a>
<a name="ln343">	va_list modules)</a>
<a name="ln344">{</a>
<a name="ln345">	struct chain* chain = new (std::nothrow) ::chain(family, type, protocol);</a>
<a name="ln346">	if (chain == NULL)</a>
<a name="ln347">		return NULL;</a>
<a name="ln348"> </a>
<a name="ln349">	if (chain-&gt;parent == NULL || chains-&gt;Insert(chain) != B_OK) {</a>
<a name="ln350">		delete chain;</a>
<a name="ln351">		return NULL;</a>
<a name="ln352">	}</a>
<a name="ln353"> </a>
<a name="ln354">	TRACE((&quot;Add chain %d.%d.%d:\n&quot;, family, type, protocol));</a>
<a name="ln355">	const char* module;</a>
<a name="ln356">	int32 count = 0;</a>
<a name="ln357"> </a>
<a name="ln358">	while (true) {</a>
<a name="ln359">		module = va_arg(modules, const char*);</a>
<a name="ln360">		if (module == NULL)</a>
<a name="ln361">			break;</a>
<a name="ln362"> </a>
<a name="ln363">		TRACE((&quot;  [%ld] %s\n&quot;, count, module));</a>
<a name="ln364">		chain-&gt;modules[count] = strdup(module);</a>
<a name="ln365">		if (chain-&gt;modules[count] == NULL</a>
<a name="ln366">			|| ++count &gt;= MAX_CHAIN_MODULES) {</a>
<a name="ln367">			chains-&gt;Remove(chain);</a>
<a name="ln368">			delete chain;</a>
<a name="ln369">			return NULL;</a>
<a name="ln370">		}</a>
<a name="ln371">	}</a>
<a name="ln372"> </a>
<a name="ln373">	if (chains == sProtocolChains &amp;&amp; count == 0) {</a>
<a name="ln374">		chains-&gt;Remove(chain);</a>
<a name="ln375">		delete chain;</a>
<a name="ln376">		return NULL;</a>
<a name="ln377">	}</a>
<a name="ln378"> </a>
<a name="ln379">	return chain;</a>
<a name="ln380">}</a>
<a name="ln381"> </a>
<a name="ln382"> </a>
<a name="ln383">/*static*/ struct chain*</a>
<a name="ln384">chain::Add(ChainTable* chains, int family, int type, int protocol, ...)</a>
<a name="ln385">{</a>
<a name="ln386">	va_list modules;</a>
<a name="ln387">	va_start(modules, protocol);</a>
<a name="ln388"> </a>
<a name="ln389">	struct chain* chain = Add(chains, family, type, 0, modules);</a>
<a name="ln390"> </a>
<a name="ln391">	va_end(modules);</a>
<a name="ln392">	return chain;</a>
<a name="ln393">}</a>
<a name="ln394"> </a>
<a name="ln395"> </a>
<a name="ln396">/*static*/ void</a>
<a name="ln397">chain::DeleteChains(ChainTable* chains)</a>
<a name="ln398">{</a>
<a name="ln399">	struct chain* current;</a>
<a name="ln400">	current = chains-&gt;Clear(true);</a>
<a name="ln401">	while (current) {</a>
<a name="ln402">		struct chain* next = current-&gt;next;</a>
<a name="ln403"> </a>
<a name="ln404">		current-&gt;Uninitialize();</a>
<a name="ln405">		delete current;</a>
<a name="ln406">		current = next;</a>
<a name="ln407">	}</a>
<a name="ln408">}</a>
<a name="ln409"> </a>
<a name="ln410"> </a>
<a name="ln411">//	#pragma mark -</a>
<a name="ln412"> </a>
<a name="ln413"> </a>
<a name="ln414">static void</a>
<a name="ln415">uninit_domain_protocols(net_socket* socket)</a>
<a name="ln416">{</a>
<a name="ln417">	net_protocol* protocol = socket-&gt;first_protocol;</a>
<a name="ln418">	while (protocol != NULL) {</a>
<a name="ln419">		net_protocol* next = protocol-&gt;next;</a>
<a name="ln420">		protocol-&gt;module-&gt;uninit_protocol(protocol);</a>
<a name="ln421"> </a>
<a name="ln422">		protocol = next;</a>
<a name="ln423">	}</a>
<a name="ln424"> </a>
<a name="ln425">	socket-&gt;first_protocol = NULL;</a>
<a name="ln426">	socket-&gt;first_info = NULL;</a>
<a name="ln427">}</a>
<a name="ln428"> </a>
<a name="ln429"> </a>
<a name="ln430">status_t</a>
<a name="ln431">get_domain_protocols(net_socket* socket)</a>
<a name="ln432">{</a>
<a name="ln433">	struct chain* chain;</a>
<a name="ln434"> </a>
<a name="ln435">	{</a>
<a name="ln436">		MutexLocker _(sChainLock);</a>
<a name="ln437"> </a>
<a name="ln438">		chain = chain::Lookup(sProtocolChains, socket-&gt;family, socket-&gt;type,</a>
<a name="ln439">			socket-&gt;type == SOCK_RAW ? 0 : socket-&gt;protocol);</a>
<a name="ln440">			// in SOCK_RAW mode, we ignore the protocol information</a>
<a name="ln441">		if (chain == NULL) {</a>
<a name="ln442">			// TODO: if we want to be POSIX compatible, we should also support</a>
<a name="ln443">			//	the error codes EPROTONOSUPPORT and EPROTOTYPE.</a>
<a name="ln444">			return EAFNOSUPPORT;</a>
<a name="ln445">		}</a>
<a name="ln446">	}</a>
<a name="ln447"> </a>
<a name="ln448">	// create net_protocol objects for the protocols in the chain</a>
<a name="ln449"> </a>
<a name="ln450">	status_t status = chain-&gt;Acquire();</a>
<a name="ln451">	if (status != B_OK)</a>
<a name="ln452">		return status;</a>
<a name="ln453"> </a>
<a name="ln454">	net_protocol* last = NULL;</a>
<a name="ln455"> </a>
<a name="ln456">	for (int32 i = 0; chain-&gt;infos[i] != NULL; i++) {</a>
<a name="ln457">		net_protocol* protocol =</a>
<a name="ln458">			((net_protocol_module_info*)chain-&gt;infos[i])-&gt;init_protocol(socket);</a>
<a name="ln459">		if (protocol == NULL) {</a>
<a name="ln460">			// free protocols we already initialized</a>
<a name="ln461">			uninit_domain_protocols(socket);</a>
<a name="ln462">			chain-&gt;Release();</a>
<a name="ln463">			return B_NO_MEMORY;</a>
<a name="ln464">		}</a>
<a name="ln465"> </a>
<a name="ln466">		protocol-&gt;module = (net_protocol_module_info*)chain-&gt;infos[i];</a>
<a name="ln467">		protocol-&gt;socket = socket;</a>
<a name="ln468">		protocol-&gt;next = NULL;</a>
<a name="ln469"> </a>
<a name="ln470">		if (last == NULL) {</a>
<a name="ln471">			socket-&gt;first_protocol = protocol;</a>
<a name="ln472">			socket-&gt;first_info = protocol-&gt;module;</a>
<a name="ln473">		} else</a>
<a name="ln474">			last-&gt;next = protocol;</a>
<a name="ln475"> </a>
<a name="ln476">		last = protocol;</a>
<a name="ln477">	}</a>
<a name="ln478"> </a>
<a name="ln479">	return B_OK;</a>
<a name="ln480">}</a>
<a name="ln481"> </a>
<a name="ln482"> </a>
<a name="ln483">status_t</a>
<a name="ln484">put_domain_protocols(net_socket* socket)</a>
<a name="ln485">{</a>
<a name="ln486">	struct chain* chain;</a>
<a name="ln487"> </a>
<a name="ln488">	{</a>
<a name="ln489">		MutexLocker _(sChainLock);</a>
<a name="ln490"> </a>
<a name="ln491">		chain = chain::Lookup(sProtocolChains, socket-&gt;family, socket-&gt;type,</a>
<a name="ln492">			socket-&gt;protocol);</a>
<a name="ln493">		if (chain == NULL)</a>
<a name="ln494">			return B_ERROR;</a>
<a name="ln495">	}</a>
<a name="ln496"> </a>
<a name="ln497">	uninit_domain_protocols(socket);</a>
<a name="ln498">	chain-&gt;Release();</a>
<a name="ln499">	return B_OK;</a>
<a name="ln500">}</a>
<a name="ln501"> </a>
<a name="ln502"> </a>
<a name="ln503">static void</a>
<a name="ln504">uninit_domain_datalink_protocols(domain_datalink* datalink)</a>
<a name="ln505">{</a>
<a name="ln506">	TRACE((&quot;%s(datalink %p)\n&quot;, __FUNCTION__, datalink));</a>
<a name="ln507"> </a>
<a name="ln508">	if (datalink == NULL)</a>
<a name="ln509">		return;</a>
<a name="ln510"> </a>
<a name="ln511">	net_datalink_protocol* protocol = datalink-&gt;first_protocol;</a>
<a name="ln512">	while (protocol != NULL) {</a>
<a name="ln513">		net_datalink_protocol* next = protocol-&gt;next;</a>
<a name="ln514">		protocol-&gt;module-&gt;uninit_protocol(protocol);</a>
<a name="ln515"> </a>
<a name="ln516">		protocol = next;</a>
<a name="ln517">	}</a>
<a name="ln518"> </a>
<a name="ln519">	datalink-&gt;first_protocol = NULL;</a>
<a name="ln520">	datalink-&gt;first_info = NULL;</a>
<a name="ln521">}</a>
<a name="ln522"> </a>
<a name="ln523"> </a>
<a name="ln524">status_t</a>
<a name="ln525">get_domain_datalink_protocols(Interface* interface, net_domain* domain)</a>
<a name="ln526">{</a>
<a name="ln527">	TRACE((&quot;%s(interface %p, domain %d)\n&quot;, __FUNCTION__, interface,</a>
<a name="ln528">		domain-&gt;family));</a>
<a name="ln529"> </a>
<a name="ln530">	struct chain* chain;</a>
<a name="ln531"> </a>
<a name="ln532">	{</a>
<a name="ln533">		MutexLocker _(sChainLock);</a>
<a name="ln534"> </a>
<a name="ln535">		chain = chain::Lookup(sDatalinkProtocolChains, domain-&gt;family,</a>
<a name="ln536">			interface-&gt;DeviceInterface()-&gt;device-&gt;type, 0);</a>
<a name="ln537">		if (chain == NULL)</a>
<a name="ln538">			return EAFNOSUPPORT;</a>
<a name="ln539">	}</a>
<a name="ln540"> </a>
<a name="ln541">	domain_datalink* datalink = interface-&gt;DomainDatalink(domain-&gt;family);</a>
<a name="ln542">	if (datalink == NULL)</a>
<a name="ln543">		return B_BAD_VALUE;</a>
<a name="ln544">	if (datalink-&gt;first_protocol != NULL)</a>
<a name="ln545">		return B_NAME_IN_USE;</a>
<a name="ln546"> </a>
<a name="ln547">	// create net_protocol objects for the protocols in the chain</a>
<a name="ln548"> </a>
<a name="ln549">	status_t status = chain-&gt;Acquire();</a>
<a name="ln550">	if (status != B_OK)</a>
<a name="ln551">		return status;</a>
<a name="ln552"> </a>
<a name="ln553">	net_datalink_protocol* last = NULL;</a>
<a name="ln554"> </a>
<a name="ln555">	for (int32 i = 0; chain-&gt;infos[i] != NULL; i++) {</a>
<a name="ln556">		net_datalink_protocol* protocol;</a>
<a name="ln557">		status_t status = ((net_datalink_protocol_module_info*)</a>
<a name="ln558">			chain-&gt;infos[i])-&gt;init_protocol(interface, domain, &amp;protocol);</a>
<a name="ln559">		if (status != B_OK) {</a>
<a name="ln560">			// free protocols we already initialized</a>
<a name="ln561">			uninit_domain_datalink_protocols(datalink);</a>
<a name="ln562">			chain-&gt;Release();</a>
<a name="ln563">			return status;</a>
<a name="ln564">		}</a>
<a name="ln565"> </a>
<a name="ln566">		protocol-&gt;module = (net_datalink_protocol_module_info*)chain-&gt;infos[i];</a>
<a name="ln567">		protocol-&gt;interface = interface;</a>
<a name="ln568">		protocol-&gt;domain = domain;</a>
<a name="ln569">		protocol-&gt;next = NULL;</a>
<a name="ln570"> </a>
<a name="ln571">		if (last == NULL) {</a>
<a name="ln572">			datalink-&gt;first_protocol = protocol;</a>
<a name="ln573">			datalink-&gt;first_info = protocol-&gt;module;</a>
<a name="ln574">		} else</a>
<a name="ln575">			last-&gt;next = protocol;</a>
<a name="ln576"> </a>
<a name="ln577">		last = protocol;</a>
<a name="ln578">	}</a>
<a name="ln579"> </a>
<a name="ln580">	return B_OK;</a>
<a name="ln581">}</a>
<a name="ln582"> </a>
<a name="ln583"> </a>
<a name="ln584">status_t</a>
<a name="ln585">put_domain_datalink_protocols(Interface* interface, net_domain* domain)</a>
<a name="ln586">{</a>
<a name="ln587">	TRACE((&quot;%s(interface %p, domain %d)\n&quot;, __FUNCTION__, interface,</a>
<a name="ln588">		domain-&gt;family));</a>
<a name="ln589"> </a>
<a name="ln590">	struct chain* chain;</a>
<a name="ln591"> </a>
<a name="ln592">	{</a>
<a name="ln593">		MutexLocker _(sChainLock);</a>
<a name="ln594"> </a>
<a name="ln595">		chain = chain::Lookup(sDatalinkProtocolChains, domain-&gt;family,</a>
<a name="ln596">			interface-&gt;DeviceInterface()-&gt;device-&gt;type, 0);</a>
<a name="ln597">		if (chain == NULL)</a>
<a name="ln598">			return B_ERROR;</a>
<a name="ln599">	}</a>
<a name="ln600"> </a>
<a name="ln601">	uninit_domain_datalink_protocols(interface-&gt;DomainDatalink(domain-&gt;family));</a>
<a name="ln602">	chain-&gt;Release();</a>
<a name="ln603">	return B_OK;</a>
<a name="ln604">}</a>
<a name="ln605"> </a>
<a name="ln606"> </a>
<a name="ln607">status_t</a>
<a name="ln608">get_domain_receiving_protocol(net_domain* _domain, uint32 type,</a>
<a name="ln609">	net_protocol_module_info** _module)</a>
<a name="ln610">{</a>
<a name="ln611">	struct net_domain_private* domain = (net_domain_private*)_domain;</a>
<a name="ln612">	struct chain* chain;</a>
<a name="ln613"> </a>
<a name="ln614">	TRACE((&quot;get_domain_receiving_protocol(family %d, type %lu)\n&quot;,</a>
<a name="ln615">		domain-&gt;family, type));</a>
<a name="ln616"> </a>
<a name="ln617">	{</a>
<a name="ln618">		MutexLocker _(sChainLock);</a>
<a name="ln619"> </a>
<a name="ln620">		chain = chain::Lookup(sReceivingProtocolChains, domain-&gt;family,</a>
<a name="ln621">			type, 0);</a>
<a name="ln622">		if (chain == NULL)</a>
<a name="ln623">			return EAFNOSUPPORT;</a>
<a name="ln624">	}</a>
<a name="ln625"> </a>
<a name="ln626">	status_t status = chain-&gt;Acquire();</a>
<a name="ln627">	if (status != B_OK)</a>
<a name="ln628">		return status;</a>
<a name="ln629"> </a>
<a name="ln630">	*_module = (net_protocol_module_info*)chain-&gt;infos[0];</a>
<a name="ln631">	return B_OK;</a>
<a name="ln632">}</a>
<a name="ln633"> </a>
<a name="ln634"> </a>
<a name="ln635">status_t</a>
<a name="ln636">put_domain_receiving_protocol(net_domain* _domain, uint32 type)</a>
<a name="ln637">{</a>
<a name="ln638">	struct net_domain_private* domain = (net_domain_private*)_domain;</a>
<a name="ln639">	struct chain* chain;</a>
<a name="ln640"> </a>
<a name="ln641">	{</a>
<a name="ln642">		MutexLocker _(sChainLock);</a>
<a name="ln643"> </a>
<a name="ln644">		chain = chain::Lookup(sReceivingProtocolChains, domain-&gt;family,</a>
<a name="ln645">			type, 0);</a>
<a name="ln646">		if (chain == NULL)</a>
<a name="ln647">			return B_ERROR;</a>
<a name="ln648">	}</a>
<a name="ln649"> </a>
<a name="ln650">	chain-&gt;Release();</a>
<a name="ln651">	return B_OK;</a>
<a name="ln652">}</a>
<a name="ln653"> </a>
<a name="ln654"> </a>
<a name="ln655">status_t</a>
<a name="ln656">register_domain_protocols(int family, int type, int protocol, ...)</a>
<a name="ln657">{</a>
<a name="ln658">	if (type == SOCK_RAW) {</a>
<a name="ln659">		// in SOCK_RAW mode, we ignore the protocol information</a>
<a name="ln660">		protocol = 0;</a>
<a name="ln661">	}</a>
<a name="ln662"> </a>
<a name="ln663">	MutexLocker locker(&amp;sChainLock);</a>
<a name="ln664"> </a>
<a name="ln665">	struct chain* chain = chain::Lookup(sProtocolChains, family, type, protocol);</a>
<a name="ln666">	if (chain != NULL)</a>
<a name="ln667">		return B_OK;</a>
<a name="ln668"> </a>
<a name="ln669">	va_list modules;</a>
<a name="ln670">	va_start(modules, protocol);</a>
<a name="ln671"> </a>
<a name="ln672">	chain = chain::Add(sProtocolChains, family, type, protocol, modules);</a>
<a name="ln673"> </a>
<a name="ln674">	va_end(modules);</a>
<a name="ln675"> </a>
<a name="ln676">	if (chain == NULL)</a>
<a name="ln677">		return B_NO_MEMORY;</a>
<a name="ln678"> </a>
<a name="ln679">	return B_OK;</a>
<a name="ln680">}</a>
<a name="ln681"> </a>
<a name="ln682"> </a>
<a name="ln683">status_t</a>
<a name="ln684">register_domain_datalink_protocols(int family, int type, ...)</a>
<a name="ln685">{</a>
<a name="ln686">	TRACE((&quot;register_domain_datalink_protocol(%d.%d)\n&quot;, family, type));</a>
<a name="ln687">	MutexLocker locker(&amp;sChainLock);</a>
<a name="ln688"> </a>
<a name="ln689">	struct chain* chain</a>
<a name="ln690">		= chain::Lookup(sDatalinkProtocolChains, family, type, 0);</a>
<a name="ln691">	if (chain != NULL)</a>
<a name="ln692">		return B_OK;</a>
<a name="ln693"> </a>
<a name="ln694">	va_list modules;</a>
<a name="ln695">	va_start(modules, type);</a>
<a name="ln696"> </a>
<a name="ln697">	chain = chain::Add(sDatalinkProtocolChains, family, type, 0, modules);</a>
<a name="ln698"> </a>
<a name="ln699">	va_end(modules);</a>
<a name="ln700"> </a>
<a name="ln701">	if (chain == NULL)</a>
<a name="ln702">		return B_NO_MEMORY;</a>
<a name="ln703"> </a>
<a name="ln704">	// Add datalink interface protocol as the last protocol in the chain; it's</a>
<a name="ln705">	// name stays unset, so that it won't be part of the release/acquire process.</a>
<a name="ln706"> </a>
<a name="ln707">	uint32 count = 0;</a>
<a name="ln708">	while (chain-&gt;modules[count] != NULL) {</a>
<a name="ln709">		count++;</a>
<a name="ln710">	}</a>
<a name="ln711"> </a>
<a name="ln712">	chain-&gt;infos[count] = (module_info*)&amp;gDatalinkInterfaceProtocolModule;</a>
<a name="ln713">	return B_OK;</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716"> </a>
<a name="ln717">static status_t</a>
<a name="ln718">register_domain_receiving_protocol(int family, int type, const char* moduleName)</a>
<a name="ln719">{</a>
<a name="ln720">	TRACE((&quot;register_domain_receiving_protocol(%d.%d, %s)\n&quot;, family, type,</a>
<a name="ln721">		moduleName));</a>
<a name="ln722"> </a>
<a name="ln723">	MutexLocker _(sChainLock);</a>
<a name="ln724"> </a>
<a name="ln725">	struct chain* chain</a>
<a name="ln726">		= chain::Lookup(sReceivingProtocolChains, family, type, 0);</a>
<a name="ln727">	if (chain != NULL)</a>
<a name="ln728">		return B_OK;</a>
<a name="ln729"> </a>
<a name="ln730">	chain = chain::Add(sReceivingProtocolChains, family, type, 0, moduleName,</a>
<a name="ln731">		NULL);</a>
<a name="ln732">	if (chain == NULL)</a>
<a name="ln733">		return B_NO_MEMORY;</a>
<a name="ln734"> </a>
<a name="ln735">	return B_OK;</a>
<a name="ln736">}</a>
<a name="ln737"> </a>
<a name="ln738"> </a>
<a name="ln739">static void</a>
<a name="ln740">scan_modules(const char* path)</a>
<a name="ln741">{</a>
<a name="ln742">	void* cookie = open_module_list(path);</a>
<a name="ln743">	if (cookie == NULL)</a>
<a name="ln744">		return;</a>
<a name="ln745"> </a>
<a name="ln746">	while (true) {</a>
<a name="ln747">		char name[B_FILE_NAME_LENGTH];</a>
<a name="ln748">		size_t length = sizeof(name);</a>
<a name="ln749">		if (read_next_module_name(cookie, name, &amp;length) != B_OK)</a>
<a name="ln750">			break;</a>
<a name="ln751"> </a>
<a name="ln752">		TRACE((&quot;scan %s\n&quot;, name));</a>
<a name="ln753"> </a>
<a name="ln754">		module_info* module;</a>
<a name="ln755">		if (get_module(name, &amp;module) == B_OK) {</a>
<a name="ln756">			// we don't need the module right now, but we give it a chance</a>
<a name="ln757">			// to register itself</a>
<a name="ln758">			put_module(name);</a>
<a name="ln759">		}</a>
<a name="ln760">	}</a>
<a name="ln761"> </a>
<a name="ln762">	close_module_list(cookie);</a>
<a name="ln763">}</a>
<a name="ln764"> </a>
<a name="ln765"> </a>
<a name="ln766">status_t</a>
<a name="ln767">init_stack()</a>
<a name="ln768">{</a>
<a name="ln769">	status_t status = init_domains();</a>
<a name="ln770">	if (status != B_OK)</a>
<a name="ln771">		return status;</a>
<a name="ln772"> </a>
<a name="ln773">	status = init_interfaces();</a>
<a name="ln774">	if (status != B_OK)</a>
<a name="ln775">		goto err1;</a>
<a name="ln776"> </a>
<a name="ln777">	status = init_device_interfaces();</a>
<a name="ln778">	if (status != B_OK)</a>
<a name="ln779">		goto err2;</a>
<a name="ln780"> </a>
<a name="ln781">	status = init_timers();</a>
<a name="ln782">	if (status != B_OK)</a>
<a name="ln783">		goto err3;</a>
<a name="ln784"> </a>
<a name="ln785">	status = init_notifications();</a>
<a name="ln786">	if (status &lt; B_OK) {</a>
<a name="ln787">		// If this fails, it just means there won't be any notifications,</a>
<a name="ln788">		// it's not a fatal error.</a>
<a name="ln789">		dprintf(&quot;networking stack notifications could not be initialized: %s\n&quot;,</a>
<a name="ln790">			strerror(status));</a>
<a name="ln791">	}</a>
<a name="ln792"> </a>
<a name="ln793">	module_info* dummy;</a>
<a name="ln794">	status = get_module(NET_SOCKET_MODULE_NAME, &amp;dummy);</a>
<a name="ln795">	if (status != B_OK)</a>
<a name="ln796">		goto err4;</a>
<a name="ln797"> </a>
<a name="ln798">	mutex_init(&amp;sChainLock, &quot;net chains&quot;);</a>
<a name="ln799">	mutex_init(&amp;sInitializeChainLock, &quot;net intialize chains&quot;);</a>
<a name="ln800"> </a>
<a name="ln801">	sFamilies = new(std::nothrow) FamilyTable();</a>
<a name="ln802">	if (sFamilies == NULL || sFamilies-&gt;Init(10) != B_OK) {</a>
<a name="ln803">		status = B_NO_MEMORY;</a>
<a name="ln804">		goto err5;</a>
<a name="ln805">	}</a>
<a name="ln806"> </a>
<a name="ln807">	sProtocolChains = new(std::nothrow) ChainTable();</a>
<a name="ln808">	if (sProtocolChains == NULL || sProtocolChains-&gt;Init(10) != B_OK) {</a>
<a name="ln809">		status = B_NO_MEMORY;</a>
<a name="ln810">		goto err6;</a>
<a name="ln811">	}</a>
<a name="ln812"> </a>
<a name="ln813">	sDatalinkProtocolChains = new(std::nothrow) ChainTable();</a>
<a name="ln814">	if (sDatalinkProtocolChains == NULL</a>
<a name="ln815">			|| sDatalinkProtocolChains-&gt;Init(10) != B_OK) {</a>
<a name="ln816">		status = B_NO_MEMORY;</a>
<a name="ln817">		goto err7;</a>
<a name="ln818">	}</a>
<a name="ln819"> </a>
<a name="ln820">	sReceivingProtocolChains = new(std::nothrow) ChainTable();</a>
<a name="ln821">	if (sReceivingProtocolChains == NULL</a>
<a name="ln822">			|| sReceivingProtocolChains-&gt;Init(10) != B_OK) {</a>
<a name="ln823">		status = B_NO_MEMORY;</a>
<a name="ln824">		goto err8;</a>
<a name="ln825">	}</a>
<a name="ln826"> </a>
<a name="ln827">	sInitialized = true;</a>
<a name="ln828"> </a>
<a name="ln829">	link_init();</a>
<a name="ln830">	scan_modules(&quot;network/protocols&quot;);</a>
<a name="ln831">	scan_modules(&quot;network/datalink_protocols&quot;);</a>
<a name="ln832"> </a>
<a name="ln833">	// TODO: for now!</a>
<a name="ln834">	register_domain_datalink_protocols(AF_INET, IFT_LOOP,</a>
<a name="ln835">		&quot;network/datalink_protocols/loopback_frame/v1&quot;, NULL);</a>
<a name="ln836">#if 0 // PPP is not (currently) included in the build</a>
<a name="ln837">	register_domain_datalink_protocols(AF_INET, IFT_PPP,</a>
<a name="ln838">		&quot;network/datalink_protocols/ppp_frame/v1&quot;, NULL);</a>
<a name="ln839">#endif</a>
<a name="ln840">	register_domain_datalink_protocols(AF_INET6, IFT_LOOP,</a>
<a name="ln841">		&quot;network/datalink_protocols/loopback_frame/v1&quot;, NULL);</a>
<a name="ln842">	register_domain_datalink_protocols(AF_INET, IFT_ETHER,</a>
<a name="ln843">		&quot;network/datalink_protocols/arp/v1&quot;,</a>
<a name="ln844">		&quot;network/datalink_protocols/ethernet_frame/v1&quot;,</a>
<a name="ln845">		NULL);</a>
<a name="ln846">	register_domain_datalink_protocols(AF_INET6, IFT_ETHER,</a>
<a name="ln847">		&quot;network/datalink_protocols/ipv6_datagram/v1&quot;,</a>
<a name="ln848">		&quot;network/datalink_protocols/ethernet_frame/v1&quot;,</a>
<a name="ln849">		NULL);</a>
<a name="ln850"> </a>
<a name="ln851">	return B_OK;</a>
<a name="ln852"> </a>
<a name="ln853">err8:</a>
<a name="ln854">	delete sDatalinkProtocolChains;</a>
<a name="ln855">err7:</a>
<a name="ln856">	delete sProtocolChains;</a>
<a name="ln857">err6:</a>
<a name="ln858">	delete sFamilies;</a>
<a name="ln859">err5:</a>
<a name="ln860">	mutex_destroy(&amp;sInitializeChainLock);</a>
<a name="ln861">	mutex_destroy(&amp;sChainLock);</a>
<a name="ln862">err4:</a>
<a name="ln863">	uninit_timers();</a>
<a name="ln864">err3:</a>
<a name="ln865">	uninit_device_interfaces();</a>
<a name="ln866">err2:</a>
<a name="ln867">	uninit_interfaces();</a>
<a name="ln868">err1:</a>
<a name="ln869">	uninit_domains();</a>
<a name="ln870">	return status;</a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873"> </a>
<a name="ln874">status_t</a>
<a name="ln875">uninit_stack()</a>
<a name="ln876">{</a>
<a name="ln877">	TRACE((&quot;Unloading network stack\n&quot;));</a>
<a name="ln878"> </a>
<a name="ln879">	put_module(NET_SOCKET_MODULE_NAME);</a>
<a name="ln880">	uninit_notifications();</a>
<a name="ln881"> </a>
<a name="ln882">	// remove chains and families</a>
<a name="ln883"> </a>
<a name="ln884">	chain::DeleteChains(sProtocolChains);</a>
<a name="ln885">	chain::DeleteChains(sDatalinkProtocolChains);</a>
<a name="ln886">	chain::DeleteChains(sReceivingProtocolChains);</a>
<a name="ln887"> </a>
<a name="ln888">	mutex_destroy(&amp;sChainLock);</a>
<a name="ln889">	mutex_destroy(&amp;sInitializeChainLock);</a>
<a name="ln890"> </a>
<a name="ln891">	uninit_timers();</a>
<a name="ln892">	uninit_device_interfaces();</a>
<a name="ln893">	uninit_interfaces();</a>
<a name="ln894">	uninit_domains();</a>
<a name="ln895"> </a>
<a name="ln896">	struct family* current;</a>
<a name="ln897">	current = sFamilies-&gt;Clear(true);</a>
<a name="ln898">	while (current) {</a>
<a name="ln899">		struct family* next = current-&gt;next;</a>
<a name="ln900"> </a>
<a name="ln901">		delete current;</a>
<a name="ln902">		current = next;</a>
<a name="ln903">	}</a>
<a name="ln904"> </a>
<a name="ln905">	delete sProtocolChains;</a>
<a name="ln906">	delete sDatalinkProtocolChains;</a>
<a name="ln907">	delete sReceivingProtocolChains;</a>
<a name="ln908">	delete sFamilies;</a>
<a name="ln909"> </a>
<a name="ln910">	return B_OK;</a>
<a name="ln911">}</a>
<a name="ln912"> </a>
<a name="ln913"> </a>
<a name="ln914">static status_t</a>
<a name="ln915">stack_std_ops(int32 op, ...)</a>
<a name="ln916">{</a>
<a name="ln917">	switch (op) {</a>
<a name="ln918">		case B_MODULE_INIT:</a>
<a name="ln919">			return sInitialized ? B_OK : B_BUSY;</a>
<a name="ln920">		case B_MODULE_UNINIT:</a>
<a name="ln921">			return B_OK;</a>
<a name="ln922"> </a>
<a name="ln923">		default:</a>
<a name="ln924">			return B_ERROR;</a>
<a name="ln925">	}</a>
<a name="ln926">}</a>
<a name="ln927"> </a>
<a name="ln928"> </a>
<a name="ln929">net_stack_module_info gNetStackModule = {</a>
<a name="ln930">	{</a>
<a name="ln931">		NET_STACK_MODULE_NAME,</a>
<a name="ln932">		0,</a>
<a name="ln933">		stack_std_ops</a>
<a name="ln934">	},</a>
<a name="ln935"> </a>
<a name="ln936">	register_domain,</a>
<a name="ln937">	unregister_domain,</a>
<a name="ln938">	get_domain,</a>
<a name="ln939"> </a>
<a name="ln940">	register_domain_protocols,</a>
<a name="ln941">	register_domain_datalink_protocols,</a>
<a name="ln942">	register_domain_receiving_protocol,</a>
<a name="ln943"> </a>
<a name="ln944">	get_domain_receiving_protocol,</a>
<a name="ln945">	put_domain_receiving_protocol,</a>
<a name="ln946"> </a>
<a name="ln947">	register_device_deframer,</a>
<a name="ln948">	unregister_device_deframer,</a>
<a name="ln949">	register_domain_device_handler,</a>
<a name="ln950">	register_device_handler,</a>
<a name="ln951">	unregister_device_handler,</a>
<a name="ln952">	register_device_monitor,</a>
<a name="ln953">	unregister_device_monitor,</a>
<a name="ln954">	device_link_changed,</a>
<a name="ln955">	device_removed,</a>
<a name="ln956">	device_enqueue_buffer,</a>
<a name="ln957"> </a>
<a name="ln958">	notify_socket,</a>
<a name="ln959"> </a>
<a name="ln960">	checksum,</a>
<a name="ln961"> </a>
<a name="ln962">	init_fifo,</a>
<a name="ln963">	uninit_fifo,</a>
<a name="ln964">	fifo_enqueue_buffer,</a>
<a name="ln965">	fifo_dequeue_buffer,</a>
<a name="ln966">	clear_fifo,</a>
<a name="ln967">	fifo_socket_enqueue_buffer,</a>
<a name="ln968"> </a>
<a name="ln969">	init_timer,</a>
<a name="ln970">	set_timer,</a>
<a name="ln971">	cancel_timer,</a>
<a name="ln972">	wait_for_timer,</a>
<a name="ln973">	is_timer_active,</a>
<a name="ln974">	is_timer_running,</a>
<a name="ln975"> </a>
<a name="ln976">	is_syscall,</a>
<a name="ln977">	is_restarted_syscall,</a>
<a name="ln978">	store_syscall_restart_timeout,</a>
<a name="ln979">	restore_syscall_restart_timeout,</a>
<a name="ln980"> </a>
<a name="ln981">	create_ancillary_data_container,</a>
<a name="ln982">	delete_ancillary_data_container,</a>
<a name="ln983">	add_ancillary_data,</a>
<a name="ln984">	remove_ancillary_data,</a>
<a name="ln985">	move_ancillary_data,</a>
<a name="ln986">	next_ancillary_data</a>
<a name="ln987">};</a>
<a name="ln988"> </a>
<a name="ln989">module_info* modules[] = {</a>
<a name="ln990">	(module_info*)&amp;gNetStackModule,</a>
<a name="ln991">	(module_info*)&amp;gNetBufferModule,</a>
<a name="ln992">	(module_info*)&amp;gNetSocketModule,</a>
<a name="ln993">	(module_info*)&amp;gNetDatalinkModule,</a>
<a name="ln994">	(module_info*)&amp;gLinkModule,</a>
<a name="ln995">	(module_info*)&amp;gNetStackInterfaceModule,</a>
<a name="ln996">	NULL</a>
<a name="ln997">};</a>

</code></pre>
<div class="balloon" rel="176"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: next.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
