
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>if_bge.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * SPDX-License-Identifier: BSD-4-Clause</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2001 Wind River Systems</a>
<a name="ln5"> * Copyright (c) 1997, 1998, 1999, 2001</a>
<a name="ln6"> *	Bill Paul &lt;wpaul@windriver.com&gt;.  All rights reserved.</a>
<a name="ln7"> *</a>
<a name="ln8"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln9"> * modification, are permitted provided that the following conditions</a>
<a name="ln10"> * are met:</a>
<a name="ln11"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln12"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln13"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln14"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln15"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln16"> * 3. All advertising materials mentioning features or use of this software</a>
<a name="ln17"> *    must display the following acknowledgement:</a>
<a name="ln18"> *	This product includes software developed by Bill Paul.</a>
<a name="ln19"> * 4. Neither the name of the author nor the names of any co-contributors</a>
<a name="ln20"> *    may be used to endorse or promote products derived from this software</a>
<a name="ln21"> *    without specific prior written permission.</a>
<a name="ln22"> *</a>
<a name="ln23"> * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln24"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln25"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln26"> * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD</a>
<a name="ln27"> * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</a>
<a name="ln28"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</a>
<a name="ln29"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</a>
<a name="ln30"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</a>
<a name="ln31"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</a>
<a name="ln32"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF</a>
<a name="ln33"> * THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln34"> */</a>
<a name="ln35"> </a>
<a name="ln36">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln37">__FBSDID(&quot;$FreeBSD: releng/12.0/sys/dev/bge/if_bge.c 338948 2018-09-26 17:12:14Z imp $&quot;);</a>
<a name="ln38"> </a>
<a name="ln39">/*</a>
<a name="ln40"> * Broadcom BCM57xx(x)/BCM590x NetXtreme and NetLink family Ethernet driver</a>
<a name="ln41"> *</a>
<a name="ln42"> * The Broadcom BCM5700 is based on technology originally developed by</a>
<a name="ln43"> * Alteon Networks as part of the Tigon I and Tigon II Gigabit Ethernet</a>
<a name="ln44"> * MAC chips. The BCM5700, sometimes referred to as the Tigon III, has</a>
<a name="ln45"> * two on-board MIPS R4000 CPUs and can have as much as 16MB of external</a>
<a name="ln46"> * SSRAM. The BCM5700 supports TCP, UDP and IP checksum offload, jumbo</a>
<a name="ln47"> * frames, highly configurable RX filtering, and 16 RX and TX queues</a>
<a name="ln48"> * (which, along with RX filter rules, can be used for QOS applications).</a>
<a name="ln49"> * Other features, such as TCP segmentation, may be available as part</a>
<a name="ln50"> * of value-added firmware updates. Unlike the Tigon I and Tigon II,</a>
<a name="ln51"> * firmware images can be stored in hardware and need not be compiled</a>
<a name="ln52"> * into the driver.</a>
<a name="ln53"> *</a>
<a name="ln54"> * The BCM5700 supports the PCI v2.2 and PCI-X v1.0 standards, and will</a>
<a name="ln55"> * function in a 32-bit/64-bit 33/66Mhz bus, or a 64-bit/133Mhz bus.</a>
<a name="ln56"> *</a>
<a name="ln57"> * The BCM5701 is a single-chip solution incorporating both the BCM5700</a>
<a name="ln58"> * MAC and a BCM5401 10/100/1000 PHY. Unlike the BCM5700, the BCM5701</a>
<a name="ln59"> * does not support external SSRAM.</a>
<a name="ln60"> *</a>
<a name="ln61"> * Broadcom also produces a variation of the BCM5700 under the &quot;Altima&quot;</a>
<a name="ln62"> * brand name, which is functionally similar but lacks PCI-X support.</a>
<a name="ln63"> *</a>
<a name="ln64"> * Without external SSRAM, you can only have at most 4 TX rings,</a>
<a name="ln65"> * and the use of the mini RX ring is disabled. This seems to imply</a>
<a name="ln66"> * that these features are simply not available on the BCM5701. As a</a>
<a name="ln67"> * result, this driver does not implement any support for the mini RX</a>
<a name="ln68"> * ring.</a>
<a name="ln69"> */</a>
<a name="ln70"> </a>
<a name="ln71">#ifdef HAVE_KERNEL_OPTION_HEADERS</a>
<a name="ln72">#include &quot;opt_device_polling.h&quot;</a>
<a name="ln73">#endif</a>
<a name="ln74"> </a>
<a name="ln75">#include &lt;sys/param.h&gt;</a>
<a name="ln76">#include &lt;sys/endian.h&gt;</a>
<a name="ln77">#include &lt;sys/systm.h&gt;</a>
<a name="ln78">#include &lt;sys/sockio.h&gt;</a>
<a name="ln79">#include &lt;sys/mbuf.h&gt;</a>
<a name="ln80">#include &lt;sys/malloc.h&gt;</a>
<a name="ln81">#include &lt;sys/kernel.h&gt;</a>
<a name="ln82">#include &lt;sys/module.h&gt;</a>
<a name="ln83">#include &lt;sys/socket.h&gt;</a>
<a name="ln84">#include &lt;sys/sysctl.h&gt;</a>
<a name="ln85">#include &lt;sys/taskqueue.h&gt;</a>
<a name="ln86"> </a>
<a name="ln87">#include &lt;net/if.h&gt;</a>
<a name="ln88">#include &lt;net/if_var.h&gt;</a>
<a name="ln89">#include &lt;net/if_arp.h&gt;</a>
<a name="ln90">#include &lt;net/ethernet.h&gt;</a>
<a name="ln91">#include &lt;net/if_dl.h&gt;</a>
<a name="ln92">#include &lt;net/if_media.h&gt;</a>
<a name="ln93"> </a>
<a name="ln94">#include &lt;net/bpf.h&gt;</a>
<a name="ln95"> </a>
<a name="ln96">#include &lt;net/if_types.h&gt;</a>
<a name="ln97">#include &lt;net/if_vlan_var.h&gt;</a>
<a name="ln98"> </a>
<a name="ln99">#include &lt;netinet/in_systm.h&gt;</a>
<a name="ln100">#include &lt;netinet/in.h&gt;</a>
<a name="ln101">#include &lt;netinet/ip.h&gt;</a>
<a name="ln102">#include &lt;netinet/tcp.h&gt;</a>
<a name="ln103">#include &lt;netinet/netdump/netdump.h&gt;</a>
<a name="ln104"> </a>
<a name="ln105">#include &lt;machine/bus.h&gt;</a>
<a name="ln106">#include &lt;machine/resource.h&gt;</a>
<a name="ln107">#include &lt;sys/bus.h&gt;</a>
<a name="ln108">#include &lt;sys/rman.h&gt;</a>
<a name="ln109"> </a>
<a name="ln110">#include &lt;dev/mii/mii.h&gt;</a>
<a name="ln111">#include &lt;dev/mii/miivar.h&gt;</a>
<a name="ln112">#include &quot;miidevs.h&quot;</a>
<a name="ln113">#include &lt;dev/mii/brgphyreg.h&gt;</a>
<a name="ln114"> </a>
<a name="ln115">#ifdef __sparc64__</a>
<a name="ln116">#include &lt;dev/ofw/ofw_bus.h&gt;</a>
<a name="ln117">#include &lt;dev/ofw/openfirm.h&gt;</a>
<a name="ln118">#include &lt;machine/ofw_machdep.h&gt;</a>
<a name="ln119">#include &lt;machine/ver.h&gt;</a>
<a name="ln120">#endif</a>
<a name="ln121"> </a>
<a name="ln122">#include &lt;dev/pci/pcireg.h&gt;</a>
<a name="ln123">#include &lt;dev/pci/pcivar.h&gt;</a>
<a name="ln124"> </a>
<a name="ln125">#include &lt;dev/bge/if_bgereg.h&gt;</a>
<a name="ln126"> </a>
<a name="ln127">#define	BGE_CSUM_FEATURES	(CSUM_IP | CSUM_TCP)</a>
<a name="ln128">#define	ETHER_MIN_NOPAD		(ETHER_MIN_LEN - ETHER_CRC_LEN) /* i.e., 60 */</a>
<a name="ln129"> </a>
<a name="ln130">MODULE_DEPEND(bge, pci, 1, 1, 1);</a>
<a name="ln131">MODULE_DEPEND(bge, ether, 1, 1, 1);</a>
<a name="ln132">MODULE_DEPEND(bge, miibus, 1, 1, 1);</a>
<a name="ln133"> </a>
<a name="ln134">/* &quot;device miibus&quot; required.  See GENERIC if you get errors here. */</a>
<a name="ln135">#include &quot;miibus_if.h&quot;</a>
<a name="ln136"> </a>
<a name="ln137">/*</a>
<a name="ln138"> * Various supported device vendors/types and their names. Note: the</a>
<a name="ln139"> * spec seems to indicate that the hardware still has Alteon's vendor</a>
<a name="ln140"> * ID burned into it, though it will always be overriden by the vendor</a>
<a name="ln141"> * ID in the EEPROM. Just to be safe, we cover all possibilities.</a>
<a name="ln142"> */</a>
<a name="ln143">static const struct bge_type {</a>
<a name="ln144">	uint16_t	bge_vid;</a>
<a name="ln145">	uint16_t	bge_did;</a>
<a name="ln146">} bge_devs[] = {</a>
<a name="ln147">	{ ALTEON_VENDORID,	ALTEON_DEVICEID_BCM5700 },</a>
<a name="ln148">	{ ALTEON_VENDORID,	ALTEON_DEVICEID_BCM5701 },</a>
<a name="ln149"> </a>
<a name="ln150">	{ ALTIMA_VENDORID,	ALTIMA_DEVICE_AC1000 },</a>
<a name="ln151">	{ ALTIMA_VENDORID,	ALTIMA_DEVICE_AC1002 },</a>
<a name="ln152">	{ ALTIMA_VENDORID,	ALTIMA_DEVICE_AC9100 },</a>
<a name="ln153"> </a>
<a name="ln154">	{ APPLE_VENDORID,	APPLE_DEVICE_BCM5701 },</a>
<a name="ln155"> </a>
<a name="ln156">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5700 },</a>
<a name="ln157">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5701 },</a>
<a name="ln158">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5702 },</a>
<a name="ln159">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5702_ALT },</a>
<a name="ln160">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5702X },</a>
<a name="ln161">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5703 },</a>
<a name="ln162">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5703_ALT },</a>
<a name="ln163">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5703X },</a>
<a name="ln164">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5704C },</a>
<a name="ln165">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5704S },</a>
<a name="ln166">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5704S_ALT },</a>
<a name="ln167">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5705 },</a>
<a name="ln168">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5705F },</a>
<a name="ln169">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5705K },</a>
<a name="ln170">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5705M },</a>
<a name="ln171">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5705M_ALT },</a>
<a name="ln172">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5714C },</a>
<a name="ln173">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5714S },</a>
<a name="ln174">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5715 },</a>
<a name="ln175">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5715S },</a>
<a name="ln176">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5717 },</a>
<a name="ln177">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5717C },</a>
<a name="ln178">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5718 },</a>
<a name="ln179">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5719 },</a>
<a name="ln180">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5720 },</a>
<a name="ln181">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5721 },</a>
<a name="ln182">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5722 },</a>
<a name="ln183">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5723 },</a>
<a name="ln184">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5725 },</a>
<a name="ln185">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5727 },</a>
<a name="ln186">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5750 },</a>
<a name="ln187">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5750M },</a>
<a name="ln188">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5751 },</a>
<a name="ln189">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5751F },</a>
<a name="ln190">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5751M },</a>
<a name="ln191">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5752 },</a>
<a name="ln192">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5752M },</a>
<a name="ln193">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5753 },</a>
<a name="ln194">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5753F },</a>
<a name="ln195">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5753M },</a>
<a name="ln196">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5754 },</a>
<a name="ln197">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5754M },</a>
<a name="ln198">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5755 },</a>
<a name="ln199">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5755M },</a>
<a name="ln200">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5756 },</a>
<a name="ln201">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5761 },</a>
<a name="ln202">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5761E },</a>
<a name="ln203">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5761S },</a>
<a name="ln204">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5761SE },</a>
<a name="ln205">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5762 },</a>
<a name="ln206">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5764 },</a>
<a name="ln207">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5780 },</a>
<a name="ln208">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5780S },</a>
<a name="ln209">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5781 },</a>
<a name="ln210">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5782 },</a>
<a name="ln211">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5784 },</a>
<a name="ln212">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5785F },</a>
<a name="ln213">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5785G },</a>
<a name="ln214">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5786 },</a>
<a name="ln215">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5787 },</a>
<a name="ln216">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5787F },</a>
<a name="ln217">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5787M },</a>
<a name="ln218">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5788 },</a>
<a name="ln219">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5789 },</a>
<a name="ln220">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5901 },</a>
<a name="ln221">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5901A2 },</a>
<a name="ln222">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5903M },</a>
<a name="ln223">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5906 },</a>
<a name="ln224">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5906M },</a>
<a name="ln225">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM57760 },</a>
<a name="ln226">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM57761 },</a>
<a name="ln227">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM57762 },</a>
<a name="ln228">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM57764 },</a>
<a name="ln229">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM57765 },</a>
<a name="ln230">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM57766 },</a>
<a name="ln231">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM57767 },</a>
<a name="ln232">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM57780 },</a>
<a name="ln233">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM57781 },</a>
<a name="ln234">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM57782 },</a>
<a name="ln235">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM57785 },</a>
<a name="ln236">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM57786 },</a>
<a name="ln237">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM57787 },</a>
<a name="ln238">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM57788 },</a>
<a name="ln239">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM57790 },</a>
<a name="ln240">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM57791 },</a>
<a name="ln241">	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM57795 },</a>
<a name="ln242"> </a>
<a name="ln243">	{ SK_VENDORID,		SK_DEVICEID_ALTIMA },</a>
<a name="ln244"> </a>
<a name="ln245">	{ TC_VENDORID,		TC_DEVICEID_3C996 },</a>
<a name="ln246"> </a>
<a name="ln247">	{ FJTSU_VENDORID,	FJTSU_DEVICEID_PW008GE4 },</a>
<a name="ln248">	{ FJTSU_VENDORID,	FJTSU_DEVICEID_PW008GE5 },</a>
<a name="ln249">	{ FJTSU_VENDORID,	FJTSU_DEVICEID_PP250450 },</a>
<a name="ln250"> </a>
<a name="ln251">	{ 0, 0 }</a>
<a name="ln252">};</a>
<a name="ln253"> </a>
<a name="ln254">static const struct bge_vendor {</a>
<a name="ln255">	uint16_t	v_id;</a>
<a name="ln256">	const char	*v_name;</a>
<a name="ln257">} bge_vendors[] = {</a>
<a name="ln258">	{ ALTEON_VENDORID,	&quot;Alteon&quot; },</a>
<a name="ln259">	{ ALTIMA_VENDORID,	&quot;Altima&quot; },</a>
<a name="ln260">	{ APPLE_VENDORID,	&quot;Apple&quot; },</a>
<a name="ln261">	{ BCOM_VENDORID,	&quot;Broadcom&quot; },</a>
<a name="ln262">	{ SK_VENDORID,		&quot;SysKonnect&quot; },</a>
<a name="ln263">	{ TC_VENDORID,		&quot;3Com&quot; },</a>
<a name="ln264">	{ FJTSU_VENDORID,	&quot;Fujitsu&quot; },</a>
<a name="ln265"> </a>
<a name="ln266">	{ 0, NULL }</a>
<a name="ln267">};</a>
<a name="ln268"> </a>
<a name="ln269">static const struct bge_revision {</a>
<a name="ln270">	uint32_t	br_chipid;</a>
<a name="ln271">	const char	*br_name;</a>
<a name="ln272">} bge_revisions[] = {</a>
<a name="ln273">	{ BGE_CHIPID_BCM5700_A0,	&quot;BCM5700 A0&quot; },</a>
<a name="ln274">	{ BGE_CHIPID_BCM5700_A1,	&quot;BCM5700 A1&quot; },</a>
<a name="ln275">	{ BGE_CHIPID_BCM5700_B0,	&quot;BCM5700 B0&quot; },</a>
<a name="ln276">	{ BGE_CHIPID_BCM5700_B1,	&quot;BCM5700 B1&quot; },</a>
<a name="ln277">	{ BGE_CHIPID_BCM5700_B2,	&quot;BCM5700 B2&quot; },</a>
<a name="ln278">	{ BGE_CHIPID_BCM5700_B3,	&quot;BCM5700 B3&quot; },</a>
<a name="ln279">	{ BGE_CHIPID_BCM5700_ALTIMA,	&quot;BCM5700 Altima&quot; },</a>
<a name="ln280">	{ BGE_CHIPID_BCM5700_C0,	&quot;BCM5700 C0&quot; },</a>
<a name="ln281">	{ BGE_CHIPID_BCM5701_A0,	&quot;BCM5701 A0&quot; },</a>
<a name="ln282">	{ BGE_CHIPID_BCM5701_B0,	&quot;BCM5701 B0&quot; },</a>
<a name="ln283">	{ BGE_CHIPID_BCM5701_B2,	&quot;BCM5701 B2&quot; },</a>
<a name="ln284">	{ BGE_CHIPID_BCM5701_B5,	&quot;BCM5701 B5&quot; },</a>
<a name="ln285">	{ BGE_CHIPID_BCM5703_A0,	&quot;BCM5703 A0&quot; },</a>
<a name="ln286">	{ BGE_CHIPID_BCM5703_A1,	&quot;BCM5703 A1&quot; },</a>
<a name="ln287">	{ BGE_CHIPID_BCM5703_A2,	&quot;BCM5703 A2&quot; },</a>
<a name="ln288">	{ BGE_CHIPID_BCM5703_A3,	&quot;BCM5703 A3&quot; },</a>
<a name="ln289">	{ BGE_CHIPID_BCM5703_B0,	&quot;BCM5703 B0&quot; },</a>
<a name="ln290">	{ BGE_CHIPID_BCM5704_A0,	&quot;BCM5704 A0&quot; },</a>
<a name="ln291">	{ BGE_CHIPID_BCM5704_A1,	&quot;BCM5704 A1&quot; },</a>
<a name="ln292">	{ BGE_CHIPID_BCM5704_A2,	&quot;BCM5704 A2&quot; },</a>
<a name="ln293">	{ BGE_CHIPID_BCM5704_A3,	&quot;BCM5704 A3&quot; },</a>
<a name="ln294">	{ BGE_CHIPID_BCM5704_B0,	&quot;BCM5704 B0&quot; },</a>
<a name="ln295">	{ BGE_CHIPID_BCM5705_A0,	&quot;BCM5705 A0&quot; },</a>
<a name="ln296">	{ BGE_CHIPID_BCM5705_A1,	&quot;BCM5705 A1&quot; },</a>
<a name="ln297">	{ BGE_CHIPID_BCM5705_A2,	&quot;BCM5705 A2&quot; },</a>
<a name="ln298">	{ BGE_CHIPID_BCM5705_A3,	&quot;BCM5705 A3&quot; },</a>
<a name="ln299">	{ BGE_CHIPID_BCM5750_A0,	&quot;BCM5750 A0&quot; },</a>
<a name="ln300">	{ BGE_CHIPID_BCM5750_A1,	&quot;BCM5750 A1&quot; },</a>
<a name="ln301">	{ BGE_CHIPID_BCM5750_A3,	&quot;BCM5750 A3&quot; },</a>
<a name="ln302">	{ BGE_CHIPID_BCM5750_B0,	&quot;BCM5750 B0&quot; },</a>
<a name="ln303">	{ BGE_CHIPID_BCM5750_B1,	&quot;BCM5750 B1&quot; },</a>
<a name="ln304">	{ BGE_CHIPID_BCM5750_C0,	&quot;BCM5750 C0&quot; },</a>
<a name="ln305">	{ BGE_CHIPID_BCM5750_C1,	&quot;BCM5750 C1&quot; },</a>
<a name="ln306">	{ BGE_CHIPID_BCM5750_C2,	&quot;BCM5750 C2&quot; },</a>
<a name="ln307">	{ BGE_CHIPID_BCM5714_A0,	&quot;BCM5714 A0&quot; },</a>
<a name="ln308">	{ BGE_CHIPID_BCM5752_A0,	&quot;BCM5752 A0&quot; },</a>
<a name="ln309">	{ BGE_CHIPID_BCM5752_A1,	&quot;BCM5752 A1&quot; },</a>
<a name="ln310">	{ BGE_CHIPID_BCM5752_A2,	&quot;BCM5752 A2&quot; },</a>
<a name="ln311">	{ BGE_CHIPID_BCM5714_B0,	&quot;BCM5714 B0&quot; },</a>
<a name="ln312">	{ BGE_CHIPID_BCM5714_B3,	&quot;BCM5714 B3&quot; },</a>
<a name="ln313">	{ BGE_CHIPID_BCM5715_A0,	&quot;BCM5715 A0&quot; },</a>
<a name="ln314">	{ BGE_CHIPID_BCM5715_A1,	&quot;BCM5715 A1&quot; },</a>
<a name="ln315">	{ BGE_CHIPID_BCM5715_A3,	&quot;BCM5715 A3&quot; },</a>
<a name="ln316">	{ BGE_CHIPID_BCM5717_A0,	&quot;BCM5717 A0&quot; },</a>
<a name="ln317">	{ BGE_CHIPID_BCM5717_B0,	&quot;BCM5717 B0&quot; },</a>
<a name="ln318">	{ BGE_CHIPID_BCM5717_C0,	&quot;BCM5717 C0&quot; },</a>
<a name="ln319">	{ BGE_CHIPID_BCM5719_A0,	&quot;BCM5719 A0&quot; },</a>
<a name="ln320">	{ BGE_CHIPID_BCM5720_A0,	&quot;BCM5720 A0&quot; },</a>
<a name="ln321">	{ BGE_CHIPID_BCM5755_A0,	&quot;BCM5755 A0&quot; },</a>
<a name="ln322">	{ BGE_CHIPID_BCM5755_A1,	&quot;BCM5755 A1&quot; },</a>
<a name="ln323">	{ BGE_CHIPID_BCM5755_A2,	&quot;BCM5755 A2&quot; },</a>
<a name="ln324">	{ BGE_CHIPID_BCM5722_A0,	&quot;BCM5722 A0&quot; },</a>
<a name="ln325">	{ BGE_CHIPID_BCM5761_A0,	&quot;BCM5761 A0&quot; },</a>
<a name="ln326">	{ BGE_CHIPID_BCM5761_A1,	&quot;BCM5761 A1&quot; },</a>
<a name="ln327">	{ BGE_CHIPID_BCM5762_A0,	&quot;BCM5762 A0&quot; },</a>
<a name="ln328">	{ BGE_CHIPID_BCM5784_A0,	&quot;BCM5784 A0&quot; },</a>
<a name="ln329">	{ BGE_CHIPID_BCM5784_A1,	&quot;BCM5784 A1&quot; },</a>
<a name="ln330">	/* 5754 and 5787 share the same ASIC ID */</a>
<a name="ln331">	{ BGE_CHIPID_BCM5787_A0,	&quot;BCM5754/5787 A0&quot; },</a>
<a name="ln332">	{ BGE_CHIPID_BCM5787_A1,	&quot;BCM5754/5787 A1&quot; },</a>
<a name="ln333">	{ BGE_CHIPID_BCM5787_A2,	&quot;BCM5754/5787 A2&quot; },</a>
<a name="ln334">	{ BGE_CHIPID_BCM5906_A1,	&quot;BCM5906 A1&quot; },</a>
<a name="ln335">	{ BGE_CHIPID_BCM5906_A2,	&quot;BCM5906 A2&quot; },</a>
<a name="ln336">	{ BGE_CHIPID_BCM57765_A0,	&quot;BCM57765 A0&quot; },</a>
<a name="ln337">	{ BGE_CHIPID_BCM57765_B0,	&quot;BCM57765 B0&quot; },</a>
<a name="ln338">	{ BGE_CHIPID_BCM57780_A0,	&quot;BCM57780 A0&quot; },</a>
<a name="ln339">	{ BGE_CHIPID_BCM57780_A1,	&quot;BCM57780 A1&quot; },</a>
<a name="ln340"> </a>
<a name="ln341">	{ 0, NULL }</a>
<a name="ln342">};</a>
<a name="ln343"> </a>
<a name="ln344">/*</a>
<a name="ln345"> * Some defaults for major revisions, so that newer steppings</a>
<a name="ln346"> * that we don't know about have a shot at working.</a>
<a name="ln347"> */</a>
<a name="ln348">static const struct bge_revision bge_majorrevs[] = {</a>
<a name="ln349">	{ BGE_ASICREV_BCM5700,		&quot;unknown BCM5700&quot; },</a>
<a name="ln350">	{ BGE_ASICREV_BCM5701,		&quot;unknown BCM5701&quot; },</a>
<a name="ln351">	{ BGE_ASICREV_BCM5703,		&quot;unknown BCM5703&quot; },</a>
<a name="ln352">	{ BGE_ASICREV_BCM5704,		&quot;unknown BCM5704&quot; },</a>
<a name="ln353">	{ BGE_ASICREV_BCM5705,		&quot;unknown BCM5705&quot; },</a>
<a name="ln354">	{ BGE_ASICREV_BCM5750,		&quot;unknown BCM5750&quot; },</a>
<a name="ln355">	{ BGE_ASICREV_BCM5714_A0,	&quot;unknown BCM5714&quot; },</a>
<a name="ln356">	{ BGE_ASICREV_BCM5752,		&quot;unknown BCM5752&quot; },</a>
<a name="ln357">	{ BGE_ASICREV_BCM5780,		&quot;unknown BCM5780&quot; },</a>
<a name="ln358">	{ BGE_ASICREV_BCM5714,		&quot;unknown BCM5714&quot; },</a>
<a name="ln359">	{ BGE_ASICREV_BCM5755,		&quot;unknown BCM5755&quot; },</a>
<a name="ln360">	{ BGE_ASICREV_BCM5761,		&quot;unknown BCM5761&quot; },</a>
<a name="ln361">	{ BGE_ASICREV_BCM5784,		&quot;unknown BCM5784&quot; },</a>
<a name="ln362">	{ BGE_ASICREV_BCM5785,		&quot;unknown BCM5785&quot; },</a>
<a name="ln363">	/* 5754 and 5787 share the same ASIC ID */</a>
<a name="ln364">	{ BGE_ASICREV_BCM5787,		&quot;unknown BCM5754/5787&quot; },</a>
<a name="ln365">	{ BGE_ASICREV_BCM5906,		&quot;unknown BCM5906&quot; },</a>
<a name="ln366">	{ BGE_ASICREV_BCM57765,		&quot;unknown BCM57765&quot; },</a>
<a name="ln367">	{ BGE_ASICREV_BCM57766,		&quot;unknown BCM57766&quot; },</a>
<a name="ln368">	{ BGE_ASICREV_BCM57780,		&quot;unknown BCM57780&quot; },</a>
<a name="ln369">	{ BGE_ASICREV_BCM5717,		&quot;unknown BCM5717&quot; },</a>
<a name="ln370">	{ BGE_ASICREV_BCM5719,		&quot;unknown BCM5719&quot; },</a>
<a name="ln371">	{ BGE_ASICREV_BCM5720,		&quot;unknown BCM5720&quot; },</a>
<a name="ln372">	{ BGE_ASICREV_BCM5762,		&quot;unknown BCM5762&quot; },</a>
<a name="ln373"> </a>
<a name="ln374">	{ 0, NULL }</a>
<a name="ln375">};</a>
<a name="ln376"> </a>
<a name="ln377">#define	BGE_IS_JUMBO_CAPABLE(sc)	((sc)-&gt;bge_flags &amp; BGE_FLAG_JUMBO)</a>
<a name="ln378">#define	BGE_IS_5700_FAMILY(sc)		((sc)-&gt;bge_flags &amp; BGE_FLAG_5700_FAMILY)</a>
<a name="ln379">#define	BGE_IS_5705_PLUS(sc)		((sc)-&gt;bge_flags &amp; BGE_FLAG_5705_PLUS)</a>
<a name="ln380">#define	BGE_IS_5714_FAMILY(sc)		((sc)-&gt;bge_flags &amp; BGE_FLAG_5714_FAMILY)</a>
<a name="ln381">#define	BGE_IS_575X_PLUS(sc)		((sc)-&gt;bge_flags &amp; BGE_FLAG_575X_PLUS)</a>
<a name="ln382">#define	BGE_IS_5755_PLUS(sc)		((sc)-&gt;bge_flags &amp; BGE_FLAG_5755_PLUS)</a>
<a name="ln383">#define	BGE_IS_5717_PLUS(sc)		((sc)-&gt;bge_flags &amp; BGE_FLAG_5717_PLUS)</a>
<a name="ln384">#define	BGE_IS_57765_PLUS(sc)		((sc)-&gt;bge_flags &amp; BGE_FLAG_57765_PLUS)</a>
<a name="ln385"> </a>
<a name="ln386">static uint32_t bge_chipid(device_t);</a>
<a name="ln387">static const struct bge_vendor * bge_lookup_vendor(uint16_t);</a>
<a name="ln388">static const struct bge_revision * bge_lookup_rev(uint32_t);</a>
<a name="ln389"> </a>
<a name="ln390">typedef int	(*bge_eaddr_fcn_t)(struct bge_softc *, uint8_t[]);</a>
<a name="ln391"> </a>
<a name="ln392">static int bge_probe(device_t);</a>
<a name="ln393">static int bge_attach(device_t);</a>
<a name="ln394">static int bge_detach(device_t);</a>
<a name="ln395">static int bge_suspend(device_t);</a>
<a name="ln396">static int bge_resume(device_t);</a>
<a name="ln397">static void bge_release_resources(struct bge_softc *);</a>
<a name="ln398">static void bge_dma_map_addr(void *, bus_dma_segment_t *, int, int);</a>
<a name="ln399">static int bge_dma_alloc(struct bge_softc *);</a>
<a name="ln400">static void bge_dma_free(struct bge_softc *);</a>
<a name="ln401">static int bge_dma_ring_alloc(struct bge_softc *, bus_size_t, bus_size_t,</a>
<a name="ln402">    bus_dma_tag_t *, uint8_t **, bus_dmamap_t *, bus_addr_t *, const char *);</a>
<a name="ln403"> </a>
<a name="ln404">static void bge_devinfo(struct bge_softc *);</a>
<a name="ln405">static int bge_mbox_reorder(struct bge_softc *);</a>
<a name="ln406"> </a>
<a name="ln407">static int bge_get_eaddr_fw(struct bge_softc *sc, uint8_t ether_addr[]);</a>
<a name="ln408">static int bge_get_eaddr_mem(struct bge_softc *, uint8_t[]);</a>
<a name="ln409">static int bge_get_eaddr_nvram(struct bge_softc *, uint8_t[]);</a>
<a name="ln410">static int bge_get_eaddr_eeprom(struct bge_softc *, uint8_t[]);</a>
<a name="ln411">static int bge_get_eaddr(struct bge_softc *, uint8_t[]);</a>
<a name="ln412"> </a>
<a name="ln413">static void bge_txeof(struct bge_softc *, uint16_t);</a>
<a name="ln414">static void bge_rxcsum(struct bge_softc *, struct bge_rx_bd *, struct mbuf *);</a>
<a name="ln415">static int bge_rxeof(struct bge_softc *, uint16_t, int);</a>
<a name="ln416"> </a>
<a name="ln417">static void bge_asf_driver_up (struct bge_softc *);</a>
<a name="ln418">static void bge_tick(void *);</a>
<a name="ln419">static void bge_stats_clear_regs(struct bge_softc *);</a>
<a name="ln420">static void bge_stats_update(struct bge_softc *);</a>
<a name="ln421">static void bge_stats_update_regs(struct bge_softc *);</a>
<a name="ln422">static struct mbuf *bge_check_short_dma(struct mbuf *);</a>
<a name="ln423">static struct mbuf *bge_setup_tso(struct bge_softc *, struct mbuf *,</a>
<a name="ln424">    uint16_t *, uint16_t *);</a>
<a name="ln425">static int bge_encap(struct bge_softc *, struct mbuf **, uint32_t *);</a>
<a name="ln426"> </a>
<a name="ln427">static void bge_intr(void *);</a>
<a name="ln428">static int bge_msi_intr(void *);</a>
<a name="ln429">static void bge_intr_task(void *, int);</a>
<a name="ln430">static void bge_start(if_t);</a>
<a name="ln431">static void bge_start_locked(if_t);</a>
<a name="ln432">static void bge_start_tx(struct bge_softc *, uint32_t);</a>
<a name="ln433">static int bge_ioctl(if_t, u_long, caddr_t);</a>
<a name="ln434">static void bge_init_locked(struct bge_softc *);</a>
<a name="ln435">static void bge_init(void *);</a>
<a name="ln436">static void bge_stop_block(struct bge_softc *, bus_size_t, uint32_t);</a>
<a name="ln437">static void bge_stop(struct bge_softc *);</a>
<a name="ln438">static void bge_watchdog(struct bge_softc *);</a>
<a name="ln439">static int bge_shutdown(device_t);</a>
<a name="ln440">static int bge_ifmedia_upd_locked(if_t);</a>
<a name="ln441">static int bge_ifmedia_upd(if_t);</a>
<a name="ln442">static void bge_ifmedia_sts(if_t, struct ifmediareq *);</a>
<a name="ln443">static uint64_t bge_get_counter(if_t, ift_counter);</a>
<a name="ln444"> </a>
<a name="ln445">static uint8_t bge_nvram_getbyte(struct bge_softc *, int, uint8_t *);</a>
<a name="ln446">static int bge_read_nvram(struct bge_softc *, caddr_t, int, int);</a>
<a name="ln447"> </a>
<a name="ln448">static uint8_t bge_eeprom_getbyte(struct bge_softc *, int, uint8_t *);</a>
<a name="ln449">static int bge_read_eeprom(struct bge_softc *, caddr_t, int, int);</a>
<a name="ln450"> </a>
<a name="ln451">static void bge_setpromisc(struct bge_softc *);</a>
<a name="ln452">static void bge_setmulti(struct bge_softc *);</a>
<a name="ln453">static void bge_setvlan(struct bge_softc *);</a>
<a name="ln454"> </a>
<a name="ln455">static __inline void bge_rxreuse_std(struct bge_softc *, int);</a>
<a name="ln456">static __inline void bge_rxreuse_jumbo(struct bge_softc *, int);</a>
<a name="ln457">static int bge_newbuf_std(struct bge_softc *, int);</a>
<a name="ln458">static int bge_newbuf_jumbo(struct bge_softc *, int);</a>
<a name="ln459">static int bge_init_rx_ring_std(struct bge_softc *);</a>
<a name="ln460">static void bge_free_rx_ring_std(struct bge_softc *);</a>
<a name="ln461">static int bge_init_rx_ring_jumbo(struct bge_softc *);</a>
<a name="ln462">static void bge_free_rx_ring_jumbo(struct bge_softc *);</a>
<a name="ln463">static void bge_free_tx_ring(struct bge_softc *);</a>
<a name="ln464">static int bge_init_tx_ring(struct bge_softc *);</a>
<a name="ln465"> </a>
<a name="ln466">static int bge_chipinit(struct bge_softc *);</a>
<a name="ln467">static int bge_blockinit(struct bge_softc *);</a>
<a name="ln468">static uint32_t bge_dma_swap_options(struct bge_softc *);</a>
<a name="ln469"> </a>
<a name="ln470">static int bge_has_eaddr(struct bge_softc *);</a>
<a name="ln471">static uint32_t bge_readmem_ind(struct bge_softc *, int);</a>
<a name="ln472">static void bge_writemem_ind(struct bge_softc *, int, int);</a>
<a name="ln473">#ifndef __HAIKU__</a>
<a name="ln474">static void bge_writembx(struct bge_softc *, int, int);</a>
<a name="ln475">#endif</a>
<a name="ln476">#ifdef notdef</a>
<a name="ln477">static uint32_t bge_readreg_ind(struct bge_softc *, int);</a>
<a name="ln478">#endif</a>
<a name="ln479">static void bge_writemem_direct(struct bge_softc *, int, int);</a>
<a name="ln480">static void bge_writereg_ind(struct bge_softc *, int, int);</a>
<a name="ln481"> </a>
<a name="ln482">static int bge_miibus_readreg(device_t, int, int);</a>
<a name="ln483">static int bge_miibus_writereg(device_t, int, int, int);</a>
<a name="ln484">static void bge_miibus_statchg(device_t);</a>
<a name="ln485">#ifdef DEVICE_POLLING</a>
<a name="ln486">static int bge_poll(if_t ifp, enum poll_cmd cmd, int count);</a>
<a name="ln487">#endif</a>
<a name="ln488"> </a>
<a name="ln489">#define	BGE_RESET_SHUTDOWN	0</a>
<a name="ln490">#define	BGE_RESET_START		1</a>
<a name="ln491">#define	BGE_RESET_SUSPEND	2</a>
<a name="ln492">static void bge_sig_post_reset(struct bge_softc *, int);</a>
<a name="ln493">static void bge_sig_legacy(struct bge_softc *, int);</a>
<a name="ln494">static void bge_sig_pre_reset(struct bge_softc *, int);</a>
<a name="ln495">static void bge_stop_fw(struct bge_softc *);</a>
<a name="ln496">static int bge_reset(struct bge_softc *);</a>
<a name="ln497">static void bge_link_upd(struct bge_softc *);</a>
<a name="ln498"> </a>
<a name="ln499">static void bge_ape_lock_init(struct bge_softc *);</a>
<a name="ln500">static void bge_ape_read_fw_ver(struct bge_softc *);</a>
<a name="ln501">static int bge_ape_lock(struct bge_softc *, int);</a>
<a name="ln502">static void bge_ape_unlock(struct bge_softc *, int);</a>
<a name="ln503">static void bge_ape_send_event(struct bge_softc *, uint32_t);</a>
<a name="ln504">static void bge_ape_driver_state_change(struct bge_softc *, int);</a>
<a name="ln505"> </a>
<a name="ln506">/*</a>
<a name="ln507"> * The BGE_REGISTER_DEBUG option is only for low-level debugging.  It may</a>
<a name="ln508"> * leak information to untrusted users.  It is also known to cause alignment</a>
<a name="ln509"> * traps on certain architectures.</a>
<a name="ln510"> */</a>
<a name="ln511">#ifdef BGE_REGISTER_DEBUG</a>
<a name="ln512">static int bge_sysctl_debug_info(SYSCTL_HANDLER_ARGS);</a>
<a name="ln513">static int bge_sysctl_reg_read(SYSCTL_HANDLER_ARGS);</a>
<a name="ln514">static int bge_sysctl_ape_read(SYSCTL_HANDLER_ARGS);</a>
<a name="ln515">static int bge_sysctl_mem_read(SYSCTL_HANDLER_ARGS);</a>
<a name="ln516">#endif</a>
<a name="ln517">static void bge_add_sysctls(struct bge_softc *);</a>
<a name="ln518">static void bge_add_sysctl_stats_regs(struct bge_softc *,</a>
<a name="ln519">    struct sysctl_ctx_list *, struct sysctl_oid_list *);</a>
<a name="ln520">static void bge_add_sysctl_stats(struct bge_softc *, struct sysctl_ctx_list *,</a>
<a name="ln521">    struct sysctl_oid_list *);</a>
<a name="ln522">static int bge_sysctl_stats(SYSCTL_HANDLER_ARGS);</a>
<a name="ln523"> </a>
<a name="ln524">NETDUMP_DEFINE(bge);</a>
<a name="ln525"> </a>
<a name="ln526">static device_method_t bge_methods[] = {</a>
<a name="ln527">	/* Device interface */</a>
<a name="ln528">	DEVMETHOD(device_probe,		bge_probe),</a>
<a name="ln529">	DEVMETHOD(device_attach,	bge_attach),</a>
<a name="ln530">	DEVMETHOD(device_detach,	bge_detach),</a>
<a name="ln531">	DEVMETHOD(device_shutdown,	bge_shutdown),</a>
<a name="ln532">	DEVMETHOD(device_suspend,	bge_suspend),</a>
<a name="ln533">	DEVMETHOD(device_resume,	bge_resume),</a>
<a name="ln534"> </a>
<a name="ln535">	/* MII interface */</a>
<a name="ln536">	DEVMETHOD(miibus_readreg,	bge_miibus_readreg),</a>
<a name="ln537">	DEVMETHOD(miibus_writereg,	bge_miibus_writereg),</a>
<a name="ln538">	DEVMETHOD(miibus_statchg,	bge_miibus_statchg),</a>
<a name="ln539"> </a>
<a name="ln540">	DEVMETHOD_END</a>
<a name="ln541">};</a>
<a name="ln542"> </a>
<a name="ln543">static driver_t bge_driver = {</a>
<a name="ln544">	&quot;bge&quot;,</a>
<a name="ln545">	bge_methods,</a>
<a name="ln546">	sizeof(struct bge_softc)</a>
<a name="ln547">};</a>
<a name="ln548"> </a>
<a name="ln549">static devclass_t bge_devclass;</a>
<a name="ln550"> </a>
<a name="ln551">DRIVER_MODULE(bge, pci, bge_driver, bge_devclass, 0, 0);</a>
<a name="ln552">MODULE_PNP_INFO(&quot;U16:vendor;U16:device&quot;, pci, bge, bge_devs,</a>
<a name="ln553">    nitems(bge_devs) - 1);</a>
<a name="ln554">DRIVER_MODULE(miibus, bge, miibus_driver, miibus_devclass, 0, 0);</a>
<a name="ln555"> </a>
<a name="ln556">static int bge_allow_asf = 1;</a>
<a name="ln557"> </a>
<a name="ln558">static SYSCTL_NODE(_hw, OID_AUTO, bge, CTLFLAG_RD, 0, &quot;BGE driver parameters&quot;);</a>
<a name="ln559">SYSCTL_INT(_hw_bge, OID_AUTO, allow_asf, CTLFLAG_RDTUN, &amp;bge_allow_asf, 0,</a>
<a name="ln560">	&quot;Allow ASF mode if available&quot;);</a>
<a name="ln561"> </a>
<a name="ln562">#define	SPARC64_BLADE_1500_MODEL	&quot;SUNW,Sun-Blade-1500&quot;</a>
<a name="ln563">#define	SPARC64_BLADE_1500_PATH_BGE	&quot;/pci@1f,700000/network@2&quot;</a>
<a name="ln564">#define	SPARC64_BLADE_2500_MODEL	&quot;SUNW,Sun-Blade-2500&quot;</a>
<a name="ln565">#define	SPARC64_BLADE_2500_PATH_BGE	&quot;/pci@1c,600000/network@3&quot;</a>
<a name="ln566">#define	SPARC64_OFW_SUBVENDOR		&quot;subsystem-vendor-id&quot;</a>
<a name="ln567"> </a>
<a name="ln568">static int</a>
<a name="ln569">bge_has_eaddr(struct bge_softc *sc)</a>
<a name="ln570">{</a>
<a name="ln571">#ifdef __sparc64__</a>
<a name="ln572">	char buf[sizeof(SPARC64_BLADE_1500_PATH_BGE)];</a>
<a name="ln573">	device_t dev;</a>
<a name="ln574">	uint32_t subvendor;</a>
<a name="ln575"> </a>
<a name="ln576">	dev = sc-&gt;bge_dev;</a>
<a name="ln577"> </a>
<a name="ln578">	/*</a>
<a name="ln579">	 * The on-board BGEs found in sun4u machines aren't fitted with</a>
<a name="ln580">	 * an EEPROM which means that we have to obtain the MAC address</a>
<a name="ln581">	 * via OFW and that some tests will always fail.  We distinguish</a>
<a name="ln582">	 * such BGEs by the subvendor ID, which also has to be obtained</a>
<a name="ln583">	 * from OFW instead of the PCI configuration space as the latter</a>
<a name="ln584">	 * indicates Broadcom as the subvendor of the netboot interface.</a>
<a name="ln585">	 * For early Blade 1500 and 2500 we even have to check the OFW</a>
<a name="ln586">	 * device path as the subvendor ID always defaults to Broadcom</a>
<a name="ln587">	 * there.</a>
<a name="ln588">	 */</a>
<a name="ln589">	if (OF_getprop(ofw_bus_get_node(dev), SPARC64_OFW_SUBVENDOR,</a>
<a name="ln590">	    &amp;subvendor, sizeof(subvendor)) == sizeof(subvendor) &amp;&amp;</a>
<a name="ln591">	    (subvendor == FJTSU_VENDORID || subvendor == SUN_VENDORID))</a>
<a name="ln592">		return (0);</a>
<a name="ln593">	memset(buf, 0, sizeof(buf));</a>
<a name="ln594">	if (OF_package_to_path(ofw_bus_get_node(dev), buf, sizeof(buf)) &gt; 0) {</a>
<a name="ln595">		if (strcmp(sparc64_model, SPARC64_BLADE_1500_MODEL) == 0 &amp;&amp;</a>
<a name="ln596">		    strcmp(buf, SPARC64_BLADE_1500_PATH_BGE) == 0)</a>
<a name="ln597">			return (0);</a>
<a name="ln598">		if (strcmp(sparc64_model, SPARC64_BLADE_2500_MODEL) == 0 &amp;&amp;</a>
<a name="ln599">		    strcmp(buf, SPARC64_BLADE_2500_PATH_BGE) == 0)</a>
<a name="ln600">			return (0);</a>
<a name="ln601">	}</a>
<a name="ln602">#endif</a>
<a name="ln603">	return (1);</a>
<a name="ln604">}</a>
<a name="ln605"> </a>
<a name="ln606">static uint32_t</a>
<a name="ln607">bge_readmem_ind(struct bge_softc *sc, int off)</a>
<a name="ln608">{</a>
<a name="ln609">	device_t dev;</a>
<a name="ln610">	uint32_t val;</a>
<a name="ln611"> </a>
<a name="ln612">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5906 &amp;&amp;</a>
<a name="ln613">	    off &gt;= BGE_STATS_BLOCK &amp;&amp; off &lt; BGE_SEND_RING_1_TO_4)</a>
<a name="ln614">		return (0);</a>
<a name="ln615"> </a>
<a name="ln616">	dev = sc-&gt;bge_dev;</a>
<a name="ln617"> </a>
<a name="ln618">	pci_write_config(dev, BGE_PCI_MEMWIN_BASEADDR, off, 4);</a>
<a name="ln619">	val = pci_read_config(dev, BGE_PCI_MEMWIN_DATA, 4);</a>
<a name="ln620">	pci_write_config(dev, BGE_PCI_MEMWIN_BASEADDR, 0, 4);</a>
<a name="ln621">	return (val);</a>
<a name="ln622">}</a>
<a name="ln623"> </a>
<a name="ln624">static void</a>
<a name="ln625">bge_writemem_ind(struct bge_softc *sc, int off, int val)</a>
<a name="ln626">{</a>
<a name="ln627">	device_t dev;</a>
<a name="ln628"> </a>
<a name="ln629">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5906 &amp;&amp;</a>
<a name="ln630">	    off &gt;= BGE_STATS_BLOCK &amp;&amp; off &lt; BGE_SEND_RING_1_TO_4)</a>
<a name="ln631">		return;</a>
<a name="ln632"> </a>
<a name="ln633">	dev = sc-&gt;bge_dev;</a>
<a name="ln634"> </a>
<a name="ln635">	pci_write_config(dev, BGE_PCI_MEMWIN_BASEADDR, off, 4);</a>
<a name="ln636">	pci_write_config(dev, BGE_PCI_MEMWIN_DATA, val, 4);</a>
<a name="ln637">	pci_write_config(dev, BGE_PCI_MEMWIN_BASEADDR, 0, 4);</a>
<a name="ln638">}</a>
<a name="ln639"> </a>
<a name="ln640">#ifdef notdef</a>
<a name="ln641">static uint32_t</a>
<a name="ln642">bge_readreg_ind(struct bge_softc *sc, int off)</a>
<a name="ln643">{</a>
<a name="ln644">	device_t dev;</a>
<a name="ln645"> </a>
<a name="ln646">	dev = sc-&gt;bge_dev;</a>
<a name="ln647"> </a>
<a name="ln648">	pci_write_config(dev, BGE_PCI_REG_BASEADDR, off, 4);</a>
<a name="ln649">	return (pci_read_config(dev, BGE_PCI_REG_DATA, 4));</a>
<a name="ln650">}</a>
<a name="ln651">#endif</a>
<a name="ln652"> </a>
<a name="ln653">static void</a>
<a name="ln654">bge_writereg_ind(struct bge_softc *sc, int off, int val)</a>
<a name="ln655">{</a>
<a name="ln656">	device_t dev;</a>
<a name="ln657"> </a>
<a name="ln658">	dev = sc-&gt;bge_dev;</a>
<a name="ln659"> </a>
<a name="ln660">	pci_write_config(dev, BGE_PCI_REG_BASEADDR, off, 4);</a>
<a name="ln661">	pci_write_config(dev, BGE_PCI_REG_DATA, val, 4);</a>
<a name="ln662">}</a>
<a name="ln663"> </a>
<a name="ln664">static void</a>
<a name="ln665">bge_writemem_direct(struct bge_softc *sc, int off, int val)</a>
<a name="ln666">{</a>
<a name="ln667">	CSR_WRITE_4(sc, off, val);</a>
<a name="ln668">}</a>
<a name="ln669"> </a>
<a name="ln670">#ifndef __HAIKU__</a>
<a name="ln671">static void</a>
<a name="ln672">#else</a>
<a name="ln673">void</a>
<a name="ln674">#endif</a>
<a name="ln675">bge_writembx(struct bge_softc *sc, int off, int val)</a>
<a name="ln676">{</a>
<a name="ln677">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5906)</a>
<a name="ln678">		off += BGE_LPMBX_IRQ0_HI - BGE_MBX_IRQ0_HI;</a>
<a name="ln679"> </a>
<a name="ln680">	CSR_WRITE_4(sc, off, val);</a>
<a name="ln681">	if ((sc-&gt;bge_flags &amp; BGE_FLAG_MBOX_REORDER) != 0)</a>
<a name="ln682">		CSR_READ_4(sc, off);</a>
<a name="ln683">}</a>
<a name="ln684"> </a>
<a name="ln685">/*</a>
<a name="ln686"> * Clear all stale locks and select the lock for this driver instance.</a>
<a name="ln687"> */</a>
<a name="ln688">static void</a>
<a name="ln689">bge_ape_lock_init(struct bge_softc *sc)</a>
<a name="ln690">{</a>
<a name="ln691">	uint32_t bit, regbase;</a>
<a name="ln692">	int i;</a>
<a name="ln693"> </a>
<a name="ln694">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5761)</a>
<a name="ln695">		regbase = BGE_APE_LOCK_GRANT;</a>
<a name="ln696">	else</a>
<a name="ln697">		regbase = BGE_APE_PER_LOCK_GRANT;</a>
<a name="ln698"> </a>
<a name="ln699">	/* Clear any stale locks. */</a>
<a name="ln700">	for (i = BGE_APE_LOCK_PHY0; i &lt;= BGE_APE_LOCK_GPIO; i++) {</a>
<a name="ln701">		switch (i) {</a>
<a name="ln702">		case BGE_APE_LOCK_PHY0:</a>
<a name="ln703">		case BGE_APE_LOCK_PHY1:</a>
<a name="ln704">		case BGE_APE_LOCK_PHY2:</a>
<a name="ln705">		case BGE_APE_LOCK_PHY3:</a>
<a name="ln706">			bit = BGE_APE_LOCK_GRANT_DRIVER0;</a>
<a name="ln707">			break;</a>
<a name="ln708">		default:</a>
<a name="ln709">			if (sc-&gt;bge_func_addr == 0)</a>
<a name="ln710">				bit = BGE_APE_LOCK_GRANT_DRIVER0;</a>
<a name="ln711">			else</a>
<a name="ln712">				bit = (1 &lt;&lt; sc-&gt;bge_func_addr);</a>
<a name="ln713">		}</a>
<a name="ln714">		APE_WRITE_4(sc, regbase + 4 * i, bit);</a>
<a name="ln715">	}</a>
<a name="ln716"> </a>
<a name="ln717">	/* Select the PHY lock based on the device's function number. */</a>
<a name="ln718">	switch (sc-&gt;bge_func_addr) {</a>
<a name="ln719">	case 0:</a>
<a name="ln720">		sc-&gt;bge_phy_ape_lock = BGE_APE_LOCK_PHY0;</a>
<a name="ln721">		break;</a>
<a name="ln722">	case 1:</a>
<a name="ln723">		sc-&gt;bge_phy_ape_lock = BGE_APE_LOCK_PHY1;</a>
<a name="ln724">		break;</a>
<a name="ln725">	case 2:</a>
<a name="ln726">		sc-&gt;bge_phy_ape_lock = BGE_APE_LOCK_PHY2;</a>
<a name="ln727">		break;</a>
<a name="ln728">	case 3:</a>
<a name="ln729">		sc-&gt;bge_phy_ape_lock = BGE_APE_LOCK_PHY3;</a>
<a name="ln730">		break;</a>
<a name="ln731">	default:</a>
<a name="ln732">		device_printf(sc-&gt;bge_dev,</a>
<a name="ln733">		    &quot;PHY lock not supported on this function\n&quot;);</a>
<a name="ln734">	}</a>
<a name="ln735">}</a>
<a name="ln736"> </a>
<a name="ln737">/*</a>
<a name="ln738"> * Check for APE firmware, set flags, and print version info.</a>
<a name="ln739"> */</a>
<a name="ln740">static void</a>
<a name="ln741">bge_ape_read_fw_ver(struct bge_softc *sc)</a>
<a name="ln742">{</a>
<a name="ln743">	const char *fwtype;</a>
<a name="ln744">	uint32_t apedata, features;</a>
<a name="ln745"> </a>
<a name="ln746">	/* Check for a valid APE signature in shared memory. */</a>
<a name="ln747">	apedata = APE_READ_4(sc, BGE_APE_SEG_SIG);</a>
<a name="ln748">	if (apedata != BGE_APE_SEG_SIG_MAGIC) {</a>
<a name="ln749">		sc-&gt;bge_mfw_flags &amp;= ~ BGE_MFW_ON_APE;</a>
<a name="ln750">		return;</a>
<a name="ln751">	}</a>
<a name="ln752"> </a>
<a name="ln753">	/* Check if APE firmware is running. */</a>
<a name="ln754">	apedata = APE_READ_4(sc, BGE_APE_FW_STATUS);</a>
<a name="ln755">	if ((apedata &amp; BGE_APE_FW_STATUS_READY) == 0) {</a>
<a name="ln756">		device_printf(sc-&gt;bge_dev, &quot;APE signature found &quot;</a>
<a name="ln757">		    &quot;but FW status not ready! 0x%08x\n&quot;, apedata);</a>
<a name="ln758">		return;</a>
<a name="ln759">	}</a>
<a name="ln760"> </a>
<a name="ln761">	sc-&gt;bge_mfw_flags |= BGE_MFW_ON_APE;</a>
<a name="ln762"> </a>
<a name="ln763">	/* Fetch the APE firwmare type and version. */</a>
<a name="ln764">	apedata = APE_READ_4(sc, BGE_APE_FW_VERSION);</a>
<a name="ln765">	features = APE_READ_4(sc, BGE_APE_FW_FEATURES);</a>
<a name="ln766">	if ((features &amp; BGE_APE_FW_FEATURE_NCSI) != 0) {</a>
<a name="ln767">		sc-&gt;bge_mfw_flags |= BGE_MFW_TYPE_NCSI;</a>
<a name="ln768">		fwtype = &quot;NCSI&quot;;</a>
<a name="ln769">	} else if ((features &amp; BGE_APE_FW_FEATURE_DASH) != 0) {</a>
<a name="ln770">		sc-&gt;bge_mfw_flags |= BGE_MFW_TYPE_DASH;</a>
<a name="ln771">		fwtype = &quot;DASH&quot;;</a>
<a name="ln772">	} else</a>
<a name="ln773">		fwtype = &quot;UNKN&quot;;</a>
<a name="ln774"> </a>
<a name="ln775">	/* Print the APE firmware version. */</a>
<a name="ln776">	device_printf(sc-&gt;bge_dev, &quot;APE FW version: %s v%d.%d.%d.%d\n&quot;,</a>
<a name="ln777">	    fwtype,</a>
<a name="ln778">	    (apedata &amp; BGE_APE_FW_VERSION_MAJMSK) &gt;&gt; BGE_APE_FW_VERSION_MAJSFT,</a>
<a name="ln779">	    (apedata &amp; BGE_APE_FW_VERSION_MINMSK) &gt;&gt; BGE_APE_FW_VERSION_MINSFT,</a>
<a name="ln780">	    (apedata &amp; BGE_APE_FW_VERSION_REVMSK) &gt;&gt; BGE_APE_FW_VERSION_REVSFT,</a>
<a name="ln781">	    (apedata &amp; BGE_APE_FW_VERSION_BLDMSK));</a>
<a name="ln782">}</a>
<a name="ln783"> </a>
<a name="ln784">static int</a>
<a name="ln785">bge_ape_lock(struct bge_softc *sc, int locknum)</a>
<a name="ln786">{</a>
<a name="ln787">	uint32_t bit, gnt, req, status;</a>
<a name="ln788">	int i, off;</a>
<a name="ln789"> </a>
<a name="ln790">	if ((sc-&gt;bge_mfw_flags &amp; BGE_MFW_ON_APE) == 0)</a>
<a name="ln791">		return (0);</a>
<a name="ln792"> </a>
<a name="ln793">	/* Lock request/grant registers have different bases. */</a>
<a name="ln794">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5761) {</a>
<a name="ln795">		req = BGE_APE_LOCK_REQ;</a>
<a name="ln796">		gnt = BGE_APE_LOCK_GRANT;</a>
<a name="ln797">	} else {</a>
<a name="ln798">		req = BGE_APE_PER_LOCK_REQ;</a>
<a name="ln799">		gnt = BGE_APE_PER_LOCK_GRANT;</a>
<a name="ln800">	}</a>
<a name="ln801"> </a>
<a name="ln802">	off = 4 * locknum;</a>
<a name="ln803"> </a>
<a name="ln804">	switch (locknum) {</a>
<a name="ln805">	case BGE_APE_LOCK_GPIO:</a>
<a name="ln806">		/* Lock required when using GPIO. */</a>
<a name="ln807">		if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5761)</a>
<a name="ln808">			return (0);</a>
<a name="ln809">		if (sc-&gt;bge_func_addr == 0)</a>
<a name="ln810">			bit = BGE_APE_LOCK_REQ_DRIVER0;</a>
<a name="ln811">		else</a>
<a name="ln812">			bit = (1 &lt;&lt; sc-&gt;bge_func_addr);</a>
<a name="ln813">		break;</a>
<a name="ln814">	case BGE_APE_LOCK_GRC:</a>
<a name="ln815">		/* Lock required to reset the device. */</a>
<a name="ln816">		if (sc-&gt;bge_func_addr == 0)</a>
<a name="ln817">			bit = BGE_APE_LOCK_REQ_DRIVER0;</a>
<a name="ln818">		else</a>
<a name="ln819">			bit = (1 &lt;&lt; sc-&gt;bge_func_addr);</a>
<a name="ln820">		break;</a>
<a name="ln821">	case BGE_APE_LOCK_MEM:</a>
<a name="ln822">		/* Lock required when accessing certain APE memory. */</a>
<a name="ln823">		if (sc-&gt;bge_func_addr == 0)</a>
<a name="ln824">			bit = BGE_APE_LOCK_REQ_DRIVER0;</a>
<a name="ln825">		else</a>
<a name="ln826">			bit = (1 &lt;&lt; sc-&gt;bge_func_addr);</a>
<a name="ln827">		break;</a>
<a name="ln828">	case BGE_APE_LOCK_PHY0:</a>
<a name="ln829">	case BGE_APE_LOCK_PHY1:</a>
<a name="ln830">	case BGE_APE_LOCK_PHY2:</a>
<a name="ln831">	case BGE_APE_LOCK_PHY3:</a>
<a name="ln832">		/* Lock required when accessing PHYs. */</a>
<a name="ln833">		bit = BGE_APE_LOCK_REQ_DRIVER0;</a>
<a name="ln834">		break;</a>
<a name="ln835">	default:</a>
<a name="ln836">		return (EINVAL);</a>
<a name="ln837">	}</a>
<a name="ln838"> </a>
<a name="ln839">	/* Request a lock. */</a>
<a name="ln840">	APE_WRITE_4(sc, req + off, bit);</a>
<a name="ln841"> </a>
<a name="ln842">	/* Wait up to 1 second to acquire lock. */</a>
<a name="ln843">	for (i = 0; i &lt; 20000; i++) {</a>
<a name="ln844">		status = APE_READ_4(sc, gnt + off);</a>
<a name="ln845">		if (status == bit)</a>
<a name="ln846">			break;</a>
<a name="ln847">		DELAY(50);</a>
<a name="ln848">	}</a>
<a name="ln849"> </a>
<a name="ln850">	/* Handle any errors. */</a>
<a name="ln851">	if (status != bit) {</a>
<a name="ln852">		device_printf(sc-&gt;bge_dev, &quot;APE lock %d request failed! &quot;</a>
<a name="ln853">		    &quot;request = 0x%04x[0x%04x], status = 0x%04x[0x%04x]\n&quot;,</a>
<a name="ln854">		    locknum, req + off, bit &amp; 0xFFFF, gnt + off,</a>
<a name="ln855">		    status &amp; 0xFFFF);</a>
<a name="ln856">		/* Revoke the lock request. */</a>
<a name="ln857">		APE_WRITE_4(sc, gnt + off, bit);</a>
<a name="ln858">		return (EBUSY);</a>
<a name="ln859">	}</a>
<a name="ln860"> </a>
<a name="ln861">	return (0);</a>
<a name="ln862">}</a>
<a name="ln863"> </a>
<a name="ln864">static void</a>
<a name="ln865">bge_ape_unlock(struct bge_softc *sc, int locknum)</a>
<a name="ln866">{</a>
<a name="ln867">	uint32_t bit, gnt;</a>
<a name="ln868">	int off;</a>
<a name="ln869"> </a>
<a name="ln870">	if ((sc-&gt;bge_mfw_flags &amp; BGE_MFW_ON_APE) == 0)</a>
<a name="ln871">		return;</a>
<a name="ln872"> </a>
<a name="ln873">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5761)</a>
<a name="ln874">		gnt = BGE_APE_LOCK_GRANT;</a>
<a name="ln875">	else</a>
<a name="ln876">		gnt = BGE_APE_PER_LOCK_GRANT;</a>
<a name="ln877"> </a>
<a name="ln878">	off = 4 * locknum;</a>
<a name="ln879"> </a>
<a name="ln880">	switch (locknum) {</a>
<a name="ln881">	case BGE_APE_LOCK_GPIO:</a>
<a name="ln882">		if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5761)</a>
<a name="ln883">			return;</a>
<a name="ln884">		if (sc-&gt;bge_func_addr == 0)</a>
<a name="ln885">			bit = BGE_APE_LOCK_GRANT_DRIVER0;</a>
<a name="ln886">		else</a>
<a name="ln887">			bit = (1 &lt;&lt; sc-&gt;bge_func_addr);</a>
<a name="ln888">		break;</a>
<a name="ln889">	case BGE_APE_LOCK_GRC:</a>
<a name="ln890">		if (sc-&gt;bge_func_addr == 0)</a>
<a name="ln891">			bit = BGE_APE_LOCK_GRANT_DRIVER0;</a>
<a name="ln892">		else</a>
<a name="ln893">			bit = (1 &lt;&lt; sc-&gt;bge_func_addr);</a>
<a name="ln894">		break;</a>
<a name="ln895">	case BGE_APE_LOCK_MEM:</a>
<a name="ln896">		if (sc-&gt;bge_func_addr == 0)</a>
<a name="ln897">			bit = BGE_APE_LOCK_GRANT_DRIVER0;</a>
<a name="ln898">		else</a>
<a name="ln899">			bit = (1 &lt;&lt; sc-&gt;bge_func_addr);</a>
<a name="ln900">		break;</a>
<a name="ln901">	case BGE_APE_LOCK_PHY0:</a>
<a name="ln902">	case BGE_APE_LOCK_PHY1:</a>
<a name="ln903">	case BGE_APE_LOCK_PHY2:</a>
<a name="ln904">	case BGE_APE_LOCK_PHY3:</a>
<a name="ln905">		bit = BGE_APE_LOCK_GRANT_DRIVER0;</a>
<a name="ln906">		break;</a>
<a name="ln907">	default:</a>
<a name="ln908">		return;</a>
<a name="ln909">	}</a>
<a name="ln910"> </a>
<a name="ln911">	APE_WRITE_4(sc, gnt + off, bit);</a>
<a name="ln912">}</a>
<a name="ln913"> </a>
<a name="ln914">/*</a>
<a name="ln915"> * Send an event to the APE firmware.</a>
<a name="ln916"> */</a>
<a name="ln917">static void</a>
<a name="ln918">bge_ape_send_event(struct bge_softc *sc, uint32_t event)</a>
<a name="ln919">{</a>
<a name="ln920">	uint32_t apedata;</a>
<a name="ln921">	int i;</a>
<a name="ln922"> </a>
<a name="ln923">	/* NCSI does not support APE events. */</a>
<a name="ln924">	if ((sc-&gt;bge_mfw_flags &amp; BGE_MFW_ON_APE) == 0)</a>
<a name="ln925">		return;</a>
<a name="ln926"> </a>
<a name="ln927">	/* Wait up to 1ms for APE to service previous event. */</a>
<a name="ln928">	for (i = 10; i &gt; 0; i--) {</a>
<a name="ln929">		if (bge_ape_lock(sc, BGE_APE_LOCK_MEM) != 0)</a>
<a name="ln930">			break;</a>
<a name="ln931">		apedata = APE_READ_4(sc, BGE_APE_EVENT_STATUS);</a>
<a name="ln932">		if ((apedata &amp; BGE_APE_EVENT_STATUS_EVENT_PENDING) == 0) {</a>
<a name="ln933">			APE_WRITE_4(sc, BGE_APE_EVENT_STATUS, event |</a>
<a name="ln934">			    BGE_APE_EVENT_STATUS_EVENT_PENDING);</a>
<a name="ln935">			bge_ape_unlock(sc, BGE_APE_LOCK_MEM);</a>
<a name="ln936">			APE_WRITE_4(sc, BGE_APE_EVENT, BGE_APE_EVENT_1);</a>
<a name="ln937">			break;</a>
<a name="ln938">		}</a>
<a name="ln939">		bge_ape_unlock(sc, BGE_APE_LOCK_MEM);</a>
<a name="ln940">		DELAY(100);</a>
<a name="ln941">	}</a>
<a name="ln942">	if (i == 0)</a>
<a name="ln943">		device_printf(sc-&gt;bge_dev, &quot;APE event 0x%08x send timed out\n&quot;,</a>
<a name="ln944">		    event);</a>
<a name="ln945">}</a>
<a name="ln946"> </a>
<a name="ln947">static void</a>
<a name="ln948">bge_ape_driver_state_change(struct bge_softc *sc, int kind)</a>
<a name="ln949">{</a>
<a name="ln950">	uint32_t apedata, event;</a>
<a name="ln951"> </a>
<a name="ln952">	if ((sc-&gt;bge_mfw_flags &amp; BGE_MFW_ON_APE) == 0)</a>
<a name="ln953">		return;</a>
<a name="ln954"> </a>
<a name="ln955">	switch (kind) {</a>
<a name="ln956">	case BGE_RESET_START:</a>
<a name="ln957">		/* If this is the first load, clear the load counter. */</a>
<a name="ln958">		apedata = APE_READ_4(sc, BGE_APE_HOST_SEG_SIG);</a>
<a name="ln959">		if (apedata != BGE_APE_HOST_SEG_SIG_MAGIC)</a>
<a name="ln960">			APE_WRITE_4(sc, BGE_APE_HOST_INIT_COUNT, 0);</a>
<a name="ln961">		else {</a>
<a name="ln962">			apedata = APE_READ_4(sc, BGE_APE_HOST_INIT_COUNT);</a>
<a name="ln963">			APE_WRITE_4(sc, BGE_APE_HOST_INIT_COUNT, ++apedata);</a>
<a name="ln964">		}</a>
<a name="ln965">		APE_WRITE_4(sc, BGE_APE_HOST_SEG_SIG,</a>
<a name="ln966">		    BGE_APE_HOST_SEG_SIG_MAGIC);</a>
<a name="ln967">		APE_WRITE_4(sc, BGE_APE_HOST_SEG_LEN,</a>
<a name="ln968">		    BGE_APE_HOST_SEG_LEN_MAGIC);</a>
<a name="ln969"> </a>
<a name="ln970">		/* Add some version info if bge(4) supports it. */</a>
<a name="ln971">		APE_WRITE_4(sc, BGE_APE_HOST_DRIVER_ID,</a>
<a name="ln972">		    BGE_APE_HOST_DRIVER_ID_MAGIC(1, 0));</a>
<a name="ln973">		APE_WRITE_4(sc, BGE_APE_HOST_BEHAVIOR,</a>
<a name="ln974">		    BGE_APE_HOST_BEHAV_NO_PHYLOCK);</a>
<a name="ln975">		APE_WRITE_4(sc, BGE_APE_HOST_HEARTBEAT_INT_MS,</a>
<a name="ln976">		    BGE_APE_HOST_HEARTBEAT_INT_DISABLE);</a>
<a name="ln977">		APE_WRITE_4(sc, BGE_APE_HOST_DRVR_STATE,</a>
<a name="ln978">		    BGE_APE_HOST_DRVR_STATE_START);</a>
<a name="ln979">		event = BGE_APE_EVENT_STATUS_STATE_START;</a>
<a name="ln980">		break;</a>
<a name="ln981">	case BGE_RESET_SHUTDOWN:</a>
<a name="ln982">		APE_WRITE_4(sc, BGE_APE_HOST_DRVR_STATE,</a>
<a name="ln983">		    BGE_APE_HOST_DRVR_STATE_UNLOAD);</a>
<a name="ln984">		event = BGE_APE_EVENT_STATUS_STATE_UNLOAD;</a>
<a name="ln985">		break;</a>
<a name="ln986">	case BGE_RESET_SUSPEND:</a>
<a name="ln987">		event = BGE_APE_EVENT_STATUS_STATE_SUSPEND;</a>
<a name="ln988">		break;</a>
<a name="ln989">	default:</a>
<a name="ln990">		return;</a>
<a name="ln991">	}</a>
<a name="ln992"> </a>
<a name="ln993">	bge_ape_send_event(sc, event | BGE_APE_EVENT_STATUS_DRIVER_EVNT |</a>
<a name="ln994">	    BGE_APE_EVENT_STATUS_STATE_CHNGE);</a>
<a name="ln995">}</a>
<a name="ln996"> </a>
<a name="ln997">/*</a>
<a name="ln998"> * Map a single buffer address.</a>
<a name="ln999"> */</a>
<a name="ln1000"> </a>
<a name="ln1001">static void</a>
<a name="ln1002">bge_dma_map_addr(void *arg, bus_dma_segment_t *segs, int nseg, int error)</a>
<a name="ln1003">{</a>
<a name="ln1004">	struct bge_dmamap_arg *ctx;</a>
<a name="ln1005"> </a>
<a name="ln1006">	if (error)</a>
<a name="ln1007">		return;</a>
<a name="ln1008"> </a>
<a name="ln1009">	KASSERT(nseg == 1, (&quot;%s: %d segments returned!&quot;, __func__, nseg));</a>
<a name="ln1010"> </a>
<a name="ln1011">	ctx = arg;</a>
<a name="ln1012">	ctx-&gt;bge_busaddr = segs-&gt;ds_addr;</a>
<a name="ln1013">}</a>
<a name="ln1014"> </a>
<a name="ln1015">static uint8_t</a>
<a name="ln1016">bge_nvram_getbyte(struct bge_softc *sc, int addr, uint8_t *dest)</a>
<a name="ln1017">{</a>
<a name="ln1018">	uint32_t access, byte = 0;</a>
<a name="ln1019">	int i;</a>
<a name="ln1020"> </a>
<a name="ln1021">	/* Lock. */</a>
<a name="ln1022">	CSR_WRITE_4(sc, BGE_NVRAM_SWARB, BGE_NVRAMSWARB_SET1);</a>
<a name="ln1023">	for (i = 0; i &lt; 8000; i++) {</a>
<a name="ln1024">		if (CSR_READ_4(sc, BGE_NVRAM_SWARB) &amp; BGE_NVRAMSWARB_GNT1)</a>
<a name="ln1025">			break;</a>
<a name="ln1026">		DELAY(20);</a>
<a name="ln1027">	}</a>
<a name="ln1028">	if (i == 8000)</a>
<a name="ln1029">		return (1);</a>
<a name="ln1030"> </a>
<a name="ln1031">	/* Enable access. */</a>
<a name="ln1032">	access = CSR_READ_4(sc, BGE_NVRAM_ACCESS);</a>
<a name="ln1033">	CSR_WRITE_4(sc, BGE_NVRAM_ACCESS, access | BGE_NVRAMACC_ENABLE);</a>
<a name="ln1034"> </a>
<a name="ln1035">	CSR_WRITE_4(sc, BGE_NVRAM_ADDR, addr &amp; 0xfffffffc);</a>
<a name="ln1036">	CSR_WRITE_4(sc, BGE_NVRAM_CMD, BGE_NVRAM_READCMD);</a>
<a name="ln1037">	for (i = 0; i &lt; BGE_TIMEOUT * 10; i++) {</a>
<a name="ln1038">		DELAY(10);</a>
<a name="ln1039">		if (CSR_READ_4(sc, BGE_NVRAM_CMD) &amp; BGE_NVRAMCMD_DONE) {</a>
<a name="ln1040">			DELAY(10);</a>
<a name="ln1041">			break;</a>
<a name="ln1042">		}</a>
<a name="ln1043">	}</a>
<a name="ln1044"> </a>
<a name="ln1045">	if (i == BGE_TIMEOUT * 10) {</a>
<a name="ln1046">		if_printf(sc-&gt;bge_ifp, &quot;nvram read timed out\n&quot;);</a>
<a name="ln1047">		return (1);</a>
<a name="ln1048">	}</a>
<a name="ln1049"> </a>
<a name="ln1050">	/* Get result. */</a>
<a name="ln1051">	byte = CSR_READ_4(sc, BGE_NVRAM_RDDATA);</a>
<a name="ln1052"> </a>
<a name="ln1053">	*dest = (bswap32(byte) &gt;&gt; ((addr % 4) * 8)) &amp; 0xFF;</a>
<a name="ln1054"> </a>
<a name="ln1055">	/* Disable access. */</a>
<a name="ln1056">	CSR_WRITE_4(sc, BGE_NVRAM_ACCESS, access);</a>
<a name="ln1057"> </a>
<a name="ln1058">	/* Unlock. */</a>
<a name="ln1059">	CSR_WRITE_4(sc, BGE_NVRAM_SWARB, BGE_NVRAMSWARB_CLR1);</a>
<a name="ln1060">	CSR_READ_4(sc, BGE_NVRAM_SWARB);</a>
<a name="ln1061"> </a>
<a name="ln1062">	return (0);</a>
<a name="ln1063">}</a>
<a name="ln1064"> </a>
<a name="ln1065">/*</a>
<a name="ln1066"> * Read a sequence of bytes from NVRAM.</a>
<a name="ln1067"> */</a>
<a name="ln1068">static int</a>
<a name="ln1069">bge_read_nvram(struct bge_softc *sc, caddr_t dest, int off, int cnt)</a>
<a name="ln1070">{</a>
<a name="ln1071">	int err = 0, i;</a>
<a name="ln1072">	uint8_t byte = 0;</a>
<a name="ln1073"> </a>
<a name="ln1074">	if (sc-&gt;bge_asicrev != BGE_ASICREV_BCM5906)</a>
<a name="ln1075">		return (1);</a>
<a name="ln1076"> </a>
<a name="ln1077">	for (i = 0; i &lt; cnt; i++) {</a>
<a name="ln1078">		err = bge_nvram_getbyte(sc, off + i, &amp;byte);</a>
<a name="ln1079">		if (err)</a>
<a name="ln1080">			break;</a>
<a name="ln1081">		*(dest + i) = byte;</a>
<a name="ln1082">	}</a>
<a name="ln1083"> </a>
<a name="ln1084">	return (err ? 1 : 0);</a>
<a name="ln1085">}</a>
<a name="ln1086"> </a>
<a name="ln1087">/*</a>
<a name="ln1088"> * Read a byte of data stored in the EEPROM at address 'addr.' The</a>
<a name="ln1089"> * BCM570x supports both the traditional bitbang interface and an</a>
<a name="ln1090"> * auto access interface for reading the EEPROM. We use the auto</a>
<a name="ln1091"> * access method.</a>
<a name="ln1092"> */</a>
<a name="ln1093">static uint8_t</a>
<a name="ln1094">bge_eeprom_getbyte(struct bge_softc *sc, int addr, uint8_t *dest)</a>
<a name="ln1095">{</a>
<a name="ln1096">	int i;</a>
<a name="ln1097">	uint32_t byte = 0;</a>
<a name="ln1098"> </a>
<a name="ln1099">	/*</a>
<a name="ln1100">	 * Enable use of auto EEPROM access so we can avoid</a>
<a name="ln1101">	 * having to use the bitbang method.</a>
<a name="ln1102">	 */</a>
<a name="ln1103">	BGE_SETBIT(sc, BGE_MISC_LOCAL_CTL, BGE_MLC_AUTO_EEPROM);</a>
<a name="ln1104"> </a>
<a name="ln1105">	/* Reset the EEPROM, load the clock period. */</a>
<a name="ln1106">	CSR_WRITE_4(sc, BGE_EE_ADDR,</a>
<a name="ln1107">	    BGE_EEADDR_RESET | BGE_EEHALFCLK(BGE_HALFCLK_384SCL));</a>
<a name="ln1108">	DELAY(20);</a>
<a name="ln1109"> </a>
<a name="ln1110">	/* Issue the read EEPROM command. */</a>
<a name="ln1111">	CSR_WRITE_4(sc, BGE_EE_ADDR, BGE_EE_READCMD | addr);</a>
<a name="ln1112"> </a>
<a name="ln1113">	/* Wait for completion */</a>
<a name="ln1114">	for(i = 0; i &lt; BGE_TIMEOUT * 10; i++) {</a>
<a name="ln1115">		DELAY(10);</a>
<a name="ln1116">		if (CSR_READ_4(sc, BGE_EE_ADDR) &amp; BGE_EEADDR_DONE)</a>
<a name="ln1117">			break;</a>
<a name="ln1118">	}</a>
<a name="ln1119"> </a>
<a name="ln1120">	if (i == BGE_TIMEOUT * 10) {</a>
<a name="ln1121">		device_printf(sc-&gt;bge_dev, &quot;EEPROM read timed out\n&quot;);</a>
<a name="ln1122">		return (1);</a>
<a name="ln1123">	}</a>
<a name="ln1124"> </a>
<a name="ln1125">	/* Get result. */</a>
<a name="ln1126">	byte = CSR_READ_4(sc, BGE_EE_DATA);</a>
<a name="ln1127"> </a>
<a name="ln1128">	*dest = (byte &gt;&gt; ((addr % 4) * 8)) &amp; 0xFF;</a>
<a name="ln1129"> </a>
<a name="ln1130">	return (0);</a>
<a name="ln1131">}</a>
<a name="ln1132"> </a>
<a name="ln1133">/*</a>
<a name="ln1134"> * Read a sequence of bytes from the EEPROM.</a>
<a name="ln1135"> */</a>
<a name="ln1136">static int</a>
<a name="ln1137">bge_read_eeprom(struct bge_softc *sc, caddr_t dest, int off, int cnt)</a>
<a name="ln1138">{</a>
<a name="ln1139">	int i, error = 0;</a>
<a name="ln1140">	uint8_t byte = 0;</a>
<a name="ln1141"> </a>
<a name="ln1142">	for (i = 0; i &lt; cnt; i++) {</a>
<a name="ln1143">		error = bge_eeprom_getbyte(sc, off + i, &amp;byte);</a>
<a name="ln1144">		if (error)</a>
<a name="ln1145">			break;</a>
<a name="ln1146">		*(dest + i) = byte;</a>
<a name="ln1147">	}</a>
<a name="ln1148"> </a>
<a name="ln1149">	return (error ? 1 : 0);</a>
<a name="ln1150">}</a>
<a name="ln1151"> </a>
<a name="ln1152">static int</a>
<a name="ln1153">bge_miibus_readreg(device_t dev, int phy, int reg)</a>
<a name="ln1154">{</a>
<a name="ln1155">	struct bge_softc *sc;</a>
<a name="ln1156">	uint32_t val;</a>
<a name="ln1157">	int i;</a>
<a name="ln1158"> </a>
<a name="ln1159">	sc = device_get_softc(dev);</a>
<a name="ln1160"> </a>
<a name="ln1161">	if (bge_ape_lock(sc, sc-&gt;bge_phy_ape_lock) != 0)</a>
<a name="ln1162">		return (0);</a>
<a name="ln1163"> </a>
<a name="ln1164">	/* Clear the autopoll bit if set, otherwise may trigger PCI errors. */</a>
<a name="ln1165">	if ((sc-&gt;bge_mi_mode &amp; BGE_MIMODE_AUTOPOLL) != 0) {</a>
<a name="ln1166">		CSR_WRITE_4(sc, BGE_MI_MODE,</a>
<a name="ln1167">		    sc-&gt;bge_mi_mode &amp; ~BGE_MIMODE_AUTOPOLL);</a>
<a name="ln1168">		DELAY(80);</a>
<a name="ln1169">	}</a>
<a name="ln1170"> </a>
<a name="ln1171">	CSR_WRITE_4(sc, BGE_MI_COMM, BGE_MICMD_READ | BGE_MICOMM_BUSY |</a>
<a name="ln1172">	    BGE_MIPHY(phy) | BGE_MIREG(reg));</a>
<a name="ln1173"> </a>
<a name="ln1174">	/* Poll for the PHY register access to complete. */</a>
<a name="ln1175">	for (i = 0; i &lt; BGE_TIMEOUT; i++) {</a>
<a name="ln1176">		DELAY(10);</a>
<a name="ln1177">		val = CSR_READ_4(sc, BGE_MI_COMM);</a>
<a name="ln1178">		if ((val &amp; BGE_MICOMM_BUSY) == 0) {</a>
<a name="ln1179">			DELAY(5);</a>
<a name="ln1180">			val = CSR_READ_4(sc, BGE_MI_COMM);</a>
<a name="ln1181">			break;</a>
<a name="ln1182">		}</a>
<a name="ln1183">	}</a>
<a name="ln1184"> </a>
<a name="ln1185">	if (i == BGE_TIMEOUT) {</a>
<a name="ln1186">		device_printf(sc-&gt;bge_dev,</a>
<a name="ln1187">		    &quot;PHY read timed out (phy %d, reg %d, val 0x%08x)\n&quot;,</a>
<a name="ln1188">		    phy, reg, val);</a>
<a name="ln1189">		val = 0;</a>
<a name="ln1190">	}</a>
<a name="ln1191"> </a>
<a name="ln1192">	/* Restore the autopoll bit if necessary. */</a>
<a name="ln1193">	if ((sc-&gt;bge_mi_mode &amp; BGE_MIMODE_AUTOPOLL) != 0) {</a>
<a name="ln1194">		CSR_WRITE_4(sc, BGE_MI_MODE, sc-&gt;bge_mi_mode);</a>
<a name="ln1195">		DELAY(80);</a>
<a name="ln1196">	}</a>
<a name="ln1197"> </a>
<a name="ln1198">	bge_ape_unlock(sc, sc-&gt;bge_phy_ape_lock);</a>
<a name="ln1199"> </a>
<a name="ln1200">	if (val &amp; BGE_MICOMM_READFAIL)</a>
<a name="ln1201">		return (0);</a>
<a name="ln1202"> </a>
<a name="ln1203">	return (val &amp; 0xFFFF);</a>
<a name="ln1204">}</a>
<a name="ln1205"> </a>
<a name="ln1206">static int</a>
<a name="ln1207">bge_miibus_writereg(device_t dev, int phy, int reg, int val)</a>
<a name="ln1208">{</a>
<a name="ln1209">	struct bge_softc *sc;</a>
<a name="ln1210">	int i;</a>
<a name="ln1211"> </a>
<a name="ln1212">	sc = device_get_softc(dev);</a>
<a name="ln1213"> </a>
<a name="ln1214">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5906 &amp;&amp;</a>
<a name="ln1215">	    (reg == BRGPHY_MII_1000CTL || reg == BRGPHY_MII_AUXCTL))</a>
<a name="ln1216">		return (0);</a>
<a name="ln1217"> </a>
<a name="ln1218">	if (bge_ape_lock(sc, sc-&gt;bge_phy_ape_lock) != 0)</a>
<a name="ln1219">		return (0);</a>
<a name="ln1220"> </a>
<a name="ln1221">	/* Clear the autopoll bit if set, otherwise may trigger PCI errors. */</a>
<a name="ln1222">	if ((sc-&gt;bge_mi_mode &amp; BGE_MIMODE_AUTOPOLL) != 0) {</a>
<a name="ln1223">		CSR_WRITE_4(sc, BGE_MI_MODE,</a>
<a name="ln1224">		    sc-&gt;bge_mi_mode &amp; ~BGE_MIMODE_AUTOPOLL);</a>
<a name="ln1225">		DELAY(80);</a>
<a name="ln1226">	}</a>
<a name="ln1227"> </a>
<a name="ln1228">	CSR_WRITE_4(sc, BGE_MI_COMM, BGE_MICMD_WRITE | BGE_MICOMM_BUSY |</a>
<a name="ln1229">	    BGE_MIPHY(phy) | BGE_MIREG(reg) | val);</a>
<a name="ln1230"> </a>
<a name="ln1231">	for (i = 0; i &lt; BGE_TIMEOUT; i++) {</a>
<a name="ln1232">		DELAY(10);</a>
<a name="ln1233">		if (!(CSR_READ_4(sc, BGE_MI_COMM) &amp; BGE_MICOMM_BUSY)) {</a>
<a name="ln1234">			DELAY(5);</a>
<a name="ln1235">			CSR_READ_4(sc, BGE_MI_COMM); /* dummy read */</a>
<a name="ln1236">			break;</a>
<a name="ln1237">		}</a>
<a name="ln1238">	}</a>
<a name="ln1239"> </a>
<a name="ln1240">	/* Restore the autopoll bit if necessary. */</a>
<a name="ln1241">	if ((sc-&gt;bge_mi_mode &amp; BGE_MIMODE_AUTOPOLL) != 0) {</a>
<a name="ln1242">		CSR_WRITE_4(sc, BGE_MI_MODE, sc-&gt;bge_mi_mode);</a>
<a name="ln1243">		DELAY(80);</a>
<a name="ln1244">	}</a>
<a name="ln1245"> </a>
<a name="ln1246">	bge_ape_unlock(sc, sc-&gt;bge_phy_ape_lock);</a>
<a name="ln1247"> </a>
<a name="ln1248">	if (i == BGE_TIMEOUT)</a>
<a name="ln1249">		device_printf(sc-&gt;bge_dev,</a>
<a name="ln1250">		    &quot;PHY write timed out (phy %d, reg %d, val 0x%04x)\n&quot;,</a>
<a name="ln1251">		    phy, reg, val);</a>
<a name="ln1252"> </a>
<a name="ln1253">	return (0);</a>
<a name="ln1254">}</a>
<a name="ln1255"> </a>
<a name="ln1256">static void</a>
<a name="ln1257">bge_miibus_statchg(device_t dev)</a>
<a name="ln1258">{</a>
<a name="ln1259">	struct bge_softc *sc;</a>
<a name="ln1260">	struct mii_data *mii;</a>
<a name="ln1261">	uint32_t mac_mode, rx_mode, tx_mode;</a>
<a name="ln1262"> </a>
<a name="ln1263">	sc = device_get_softc(dev);</a>
<a name="ln1264">	if ((if_getdrvflags(sc-&gt;bge_ifp) &amp; IFF_DRV_RUNNING) == 0)</a>
<a name="ln1265">		return;</a>
<a name="ln1266">	mii = device_get_softc(sc-&gt;bge_miibus);</a>
<a name="ln1267"> </a>
<a name="ln1268">	if ((mii-&gt;mii_media_status &amp; (IFM_ACTIVE | IFM_AVALID)) ==</a>
<a name="ln1269">	    (IFM_ACTIVE | IFM_AVALID)) {</a>
<a name="ln1270">		switch (IFM_SUBTYPE(mii-&gt;mii_media_active)) {</a>
<a name="ln1271">		case IFM_10_T:</a>
<a name="ln1272">		case IFM_100_TX:</a>
<a name="ln1273">			sc-&gt;bge_link = 1;</a>
<a name="ln1274">			break;</a>
<a name="ln1275">		case IFM_1000_T:</a>
<a name="ln1276">		case IFM_1000_SX:</a>
<a name="ln1277">		case IFM_2500_SX:</a>
<a name="ln1278">			if (sc-&gt;bge_asicrev != BGE_ASICREV_BCM5906)</a>
<a name="ln1279">				sc-&gt;bge_link = 1;</a>
<a name="ln1280">			else</a>
<a name="ln1281">				sc-&gt;bge_link = 0;</a>
<a name="ln1282">			break;</a>
<a name="ln1283">		default:</a>
<a name="ln1284">			sc-&gt;bge_link = 0;</a>
<a name="ln1285">			break;</a>
<a name="ln1286">		}</a>
<a name="ln1287">	} else</a>
<a name="ln1288">		sc-&gt;bge_link = 0;</a>
<a name="ln1289">	if (sc-&gt;bge_link == 0)</a>
<a name="ln1290">		return;</a>
<a name="ln1291"> </a>
<a name="ln1292">	/*</a>
<a name="ln1293">	 * APE firmware touches these registers to keep the MAC</a>
<a name="ln1294">	 * connected to the outside world.  Try to keep the</a>
<a name="ln1295">	 * accesses atomic.</a>
<a name="ln1296">	 */</a>
<a name="ln1297"> </a>
<a name="ln1298">	/* Set the port mode (MII/GMII) to match the link speed. */</a>
<a name="ln1299">	mac_mode = CSR_READ_4(sc, BGE_MAC_MODE) &amp;</a>
<a name="ln1300">	    ~(BGE_MACMODE_PORTMODE | BGE_MACMODE_HALF_DUPLEX);</a>
<a name="ln1301">	tx_mode = CSR_READ_4(sc, BGE_TX_MODE);</a>
<a name="ln1302">	rx_mode = CSR_READ_4(sc, BGE_RX_MODE);</a>
<a name="ln1303"> </a>
<a name="ln1304">	if (IFM_SUBTYPE(mii-&gt;mii_media_active) == IFM_1000_T ||</a>
<a name="ln1305">	    IFM_SUBTYPE(mii-&gt;mii_media_active) == IFM_1000_SX)</a>
<a name="ln1306">		mac_mode |= BGE_PORTMODE_GMII;</a>
<a name="ln1307">	else</a>
<a name="ln1308">		mac_mode |= BGE_PORTMODE_MII;</a>
<a name="ln1309"> </a>
<a name="ln1310">	/* Set MAC flow control behavior to match link flow control settings. */</a>
<a name="ln1311">	tx_mode &amp;= ~BGE_TXMODE_FLOWCTL_ENABLE;</a>
<a name="ln1312">	rx_mode &amp;= ~BGE_RXMODE_FLOWCTL_ENABLE;</a>
<a name="ln1313">	if ((IFM_OPTIONS(mii-&gt;mii_media_active) &amp; IFM_FDX) != 0) {</a>
<a name="ln1314">		if ((IFM_OPTIONS(mii-&gt;mii_media_active) &amp; IFM_ETH_TXPAUSE) != 0)</a>
<a name="ln1315">			tx_mode |= BGE_TXMODE_FLOWCTL_ENABLE;</a>
<a name="ln1316">		if ((IFM_OPTIONS(mii-&gt;mii_media_active) &amp; IFM_ETH_RXPAUSE) != 0)</a>
<a name="ln1317">			rx_mode |= BGE_RXMODE_FLOWCTL_ENABLE;</a>
<a name="ln1318">	} else</a>
<a name="ln1319">		mac_mode |= BGE_MACMODE_HALF_DUPLEX;</a>
<a name="ln1320"> </a>
<a name="ln1321">	CSR_WRITE_4(sc, BGE_MAC_MODE, mac_mode);</a>
<a name="ln1322">	DELAY(40);</a>
<a name="ln1323">	CSR_WRITE_4(sc, BGE_TX_MODE, tx_mode);</a>
<a name="ln1324">	CSR_WRITE_4(sc, BGE_RX_MODE, rx_mode);</a>
<a name="ln1325">}</a>
<a name="ln1326"> </a>
<a name="ln1327">/*</a>
<a name="ln1328"> * Intialize a standard receive ring descriptor.</a>
<a name="ln1329"> */</a>
<a name="ln1330">static int</a>
<a name="ln1331">bge_newbuf_std(struct bge_softc *sc, int i)</a>
<a name="ln1332">{</a>
<a name="ln1333">	struct mbuf *m;</a>
<a name="ln1334">	struct bge_rx_bd *r;</a>
<a name="ln1335">	bus_dma_segment_t segs[1];</a>
<a name="ln1336">	bus_dmamap_t map;</a>
<a name="ln1337">	int error, nsegs;</a>
<a name="ln1338"> </a>
<a name="ln1339">	if (sc-&gt;bge_flags &amp; BGE_FLAG_JUMBO_STD &amp;&amp;</a>
<a name="ln1340">	    (if_getmtu(sc-&gt;bge_ifp) + ETHER_HDR_LEN + ETHER_CRC_LEN +</a>
<a name="ln1341">	    ETHER_VLAN_ENCAP_LEN &gt; (MCLBYTES - ETHER_ALIGN))) {</a>
<a name="ln1342">		m = m_getjcl(M_NOWAIT, MT_DATA, M_PKTHDR, MJUM9BYTES);</a>
<a name="ln1343">		if (m == NULL)</a>
<a name="ln1344">			return (ENOBUFS);</a>
<a name="ln1345">		m-&gt;m_len = m-&gt;m_pkthdr.len = MJUM9BYTES;</a>
<a name="ln1346">	} else {</a>
<a name="ln1347">		m = m_getcl(M_NOWAIT, MT_DATA, M_PKTHDR);</a>
<a name="ln1348">		if (m == NULL)</a>
<a name="ln1349">			return (ENOBUFS);</a>
<a name="ln1350">		m-&gt;m_len = m-&gt;m_pkthdr.len = MCLBYTES;</a>
<a name="ln1351">	}</a>
<a name="ln1352">	if ((sc-&gt;bge_flags &amp; BGE_FLAG_RX_ALIGNBUG) == 0)</a>
<a name="ln1353">		m_adj(m, ETHER_ALIGN);</a>
<a name="ln1354"> </a>
<a name="ln1355">	error = bus_dmamap_load_mbuf_sg(sc-&gt;bge_cdata.bge_rx_mtag,</a>
<a name="ln1356">	    sc-&gt;bge_cdata.bge_rx_std_sparemap, m, segs, &amp;nsegs, 0);</a>
<a name="ln1357">	if (error != 0) {</a>
<a name="ln1358">		m_freem(m);</a>
<a name="ln1359">		return (error);</a>
<a name="ln1360">	}</a>
<a name="ln1361">	if (sc-&gt;bge_cdata.bge_rx_std_chain[i] != NULL) {</a>
<a name="ln1362">		bus_dmamap_sync(sc-&gt;bge_cdata.bge_rx_mtag,</a>
<a name="ln1363">		    sc-&gt;bge_cdata.bge_rx_std_dmamap[i], BUS_DMASYNC_POSTREAD);</a>
<a name="ln1364">		bus_dmamap_unload(sc-&gt;bge_cdata.bge_rx_mtag,</a>
<a name="ln1365">		    sc-&gt;bge_cdata.bge_rx_std_dmamap[i]);</a>
<a name="ln1366">	}</a>
<a name="ln1367">	map = sc-&gt;bge_cdata.bge_rx_std_dmamap[i];</a>
<a name="ln1368">	sc-&gt;bge_cdata.bge_rx_std_dmamap[i] = sc-&gt;bge_cdata.bge_rx_std_sparemap;</a>
<a name="ln1369">	sc-&gt;bge_cdata.bge_rx_std_sparemap = map;</a>
<a name="ln1370">	sc-&gt;bge_cdata.bge_rx_std_chain[i] = m;</a>
<a name="ln1371">	sc-&gt;bge_cdata.bge_rx_std_seglen[i] = segs[0].ds_len;</a>
<a name="ln1372">	r = &amp;sc-&gt;bge_ldata.bge_rx_std_ring[sc-&gt;bge_std];</a>
<a name="ln1373">	r-&gt;bge_addr.bge_addr_lo = BGE_ADDR_LO(segs[0].ds_addr);</a>
<a name="ln1374">	r-&gt;bge_addr.bge_addr_hi = BGE_ADDR_HI(segs[0].ds_addr);</a>
<a name="ln1375">	r-&gt;bge_flags = BGE_RXBDFLAG_END;</a>
<a name="ln1376">	r-&gt;bge_len = segs[0].ds_len;</a>
<a name="ln1377">	r-&gt;bge_idx = i;</a>
<a name="ln1378"> </a>
<a name="ln1379">	bus_dmamap_sync(sc-&gt;bge_cdata.bge_rx_mtag,</a>
<a name="ln1380">	    sc-&gt;bge_cdata.bge_rx_std_dmamap[i], BUS_DMASYNC_PREREAD);</a>
<a name="ln1381"> </a>
<a name="ln1382">	return (0);</a>
<a name="ln1383">}</a>
<a name="ln1384"> </a>
<a name="ln1385">/*</a>
<a name="ln1386"> * Initialize a jumbo receive ring descriptor. This allocates</a>
<a name="ln1387"> * a jumbo buffer from the pool managed internally by the driver.</a>
<a name="ln1388"> */</a>
<a name="ln1389">static int</a>
<a name="ln1390">bge_newbuf_jumbo(struct bge_softc *sc, int i)</a>
<a name="ln1391">{</a>
<a name="ln1392">	bus_dma_segment_t segs[BGE_NSEG_JUMBO];</a>
<a name="ln1393">	bus_dmamap_t map;</a>
<a name="ln1394">	struct bge_extrx_bd *r;</a>
<a name="ln1395">	struct mbuf *m;</a>
<a name="ln1396">	int error, nsegs;</a>
<a name="ln1397"> </a>
<a name="ln1398">	MGETHDR(m, M_NOWAIT, MT_DATA);</a>
<a name="ln1399">	if (m == NULL)</a>
<a name="ln1400">		return (ENOBUFS);</a>
<a name="ln1401"> </a>
<a name="ln1402">	if (m_cljget(m, M_NOWAIT, MJUM9BYTES) == NULL) {</a>
<a name="ln1403">		m_freem(m);</a>
<a name="ln1404">		return (ENOBUFS);</a>
<a name="ln1405">	}</a>
<a name="ln1406">	m-&gt;m_len = m-&gt;m_pkthdr.len = MJUM9BYTES;</a>
<a name="ln1407">	if ((sc-&gt;bge_flags &amp; BGE_FLAG_RX_ALIGNBUG) == 0)</a>
<a name="ln1408">		m_adj(m, ETHER_ALIGN);</a>
<a name="ln1409"> </a>
<a name="ln1410">	error = bus_dmamap_load_mbuf_sg(sc-&gt;bge_cdata.bge_mtag_jumbo,</a>
<a name="ln1411">	    sc-&gt;bge_cdata.bge_rx_jumbo_sparemap, m, segs, &amp;nsegs, 0);</a>
<a name="ln1412">	if (error != 0) {</a>
<a name="ln1413">		m_freem(m);</a>
<a name="ln1414">		return (error);</a>
<a name="ln1415">	}</a>
<a name="ln1416"> </a>
<a name="ln1417">	if (sc-&gt;bge_cdata.bge_rx_jumbo_chain[i] != NULL) {</a>
<a name="ln1418">		bus_dmamap_sync(sc-&gt;bge_cdata.bge_mtag_jumbo,</a>
<a name="ln1419">		    sc-&gt;bge_cdata.bge_rx_jumbo_dmamap[i], BUS_DMASYNC_POSTREAD);</a>
<a name="ln1420">		bus_dmamap_unload(sc-&gt;bge_cdata.bge_mtag_jumbo,</a>
<a name="ln1421">		    sc-&gt;bge_cdata.bge_rx_jumbo_dmamap[i]);</a>
<a name="ln1422">	}</a>
<a name="ln1423">	map = sc-&gt;bge_cdata.bge_rx_jumbo_dmamap[i];</a>
<a name="ln1424">	sc-&gt;bge_cdata.bge_rx_jumbo_dmamap[i] =</a>
<a name="ln1425">	    sc-&gt;bge_cdata.bge_rx_jumbo_sparemap;</a>
<a name="ln1426">	sc-&gt;bge_cdata.bge_rx_jumbo_sparemap = map;</a>
<a name="ln1427">	sc-&gt;bge_cdata.bge_rx_jumbo_chain[i] = m;</a>
<a name="ln1428">	sc-&gt;bge_cdata.bge_rx_jumbo_seglen[i][0] = 0;</a>
<a name="ln1429">	sc-&gt;bge_cdata.bge_rx_jumbo_seglen[i][1] = 0;</a>
<a name="ln1430">	sc-&gt;bge_cdata.bge_rx_jumbo_seglen[i][2] = 0;</a>
<a name="ln1431">	sc-&gt;bge_cdata.bge_rx_jumbo_seglen[i][3] = 0;</a>
<a name="ln1432"> </a>
<a name="ln1433">	/*</a>
<a name="ln1434">	 * Fill in the extended RX buffer descriptor.</a>
<a name="ln1435">	 */</a>
<a name="ln1436">	r = &amp;sc-&gt;bge_ldata.bge_rx_jumbo_ring[sc-&gt;bge_jumbo];</a>
<a name="ln1437">	r-&gt;bge_flags = BGE_RXBDFLAG_JUMBO_RING | BGE_RXBDFLAG_END;</a>
<a name="ln1438">	r-&gt;bge_idx = i;</a>
<a name="ln1439">	r-&gt;bge_len3 = r-&gt;bge_len2 = r-&gt;bge_len1 = 0;</a>
<a name="ln1440">	switch (nsegs) {</a>
<a name="ln1441">	case 4:</a>
<a name="ln1442">		r-&gt;bge_addr3.bge_addr_lo = BGE_ADDR_LO(segs[3].ds_addr);</a>
<a name="ln1443">		r-&gt;bge_addr3.bge_addr_hi = BGE_ADDR_HI(segs[3].ds_addr);</a>
<a name="ln1444">		r-&gt;bge_len3 = segs[3].ds_len;</a>
<a name="ln1445">		sc-&gt;bge_cdata.bge_rx_jumbo_seglen[i][3] = segs[3].ds_len;</a>
<a name="ln1446">	case 3:</a>
<a name="ln1447">		r-&gt;bge_addr2.bge_addr_lo = BGE_ADDR_LO(segs[2].ds_addr);</a>
<a name="ln1448">		r-&gt;bge_addr2.bge_addr_hi = BGE_ADDR_HI(segs[2].ds_addr);</a>
<a name="ln1449">		r-&gt;bge_len2 = segs[2].ds_len;</a>
<a name="ln1450">		sc-&gt;bge_cdata.bge_rx_jumbo_seglen[i][2] = segs[2].ds_len;</a>
<a name="ln1451">	case 2:</a>
<a name="ln1452">		r-&gt;bge_addr1.bge_addr_lo = BGE_ADDR_LO(segs[1].ds_addr);</a>
<a name="ln1453">		r-&gt;bge_addr1.bge_addr_hi = BGE_ADDR_HI(segs[1].ds_addr);</a>
<a name="ln1454">		r-&gt;bge_len1 = segs[1].ds_len;</a>
<a name="ln1455">		sc-&gt;bge_cdata.bge_rx_jumbo_seglen[i][1] = segs[1].ds_len;</a>
<a name="ln1456">	case 1:</a>
<a name="ln1457">		r-&gt;bge_addr0.bge_addr_lo = BGE_ADDR_LO(segs[0].ds_addr);</a>
<a name="ln1458">		r-&gt;bge_addr0.bge_addr_hi = BGE_ADDR_HI(segs[0].ds_addr);</a>
<a name="ln1459">		r-&gt;bge_len0 = segs[0].ds_len;</a>
<a name="ln1460">		sc-&gt;bge_cdata.bge_rx_jumbo_seglen[i][0] = segs[0].ds_len;</a>
<a name="ln1461">		break;</a>
<a name="ln1462">	default:</a>
<a name="ln1463">		panic(&quot;%s: %d segments\n&quot;, __func__, nsegs);</a>
<a name="ln1464">	}</a>
<a name="ln1465"> </a>
<a name="ln1466">	bus_dmamap_sync(sc-&gt;bge_cdata.bge_mtag_jumbo,</a>
<a name="ln1467">	    sc-&gt;bge_cdata.bge_rx_jumbo_dmamap[i], BUS_DMASYNC_PREREAD);</a>
<a name="ln1468"> </a>
<a name="ln1469">	return (0);</a>
<a name="ln1470">}</a>
<a name="ln1471"> </a>
<a name="ln1472">static int</a>
<a name="ln1473">bge_init_rx_ring_std(struct bge_softc *sc)</a>
<a name="ln1474">{</a>
<a name="ln1475">	int error, i;</a>
<a name="ln1476"> </a>
<a name="ln1477">	bzero(sc-&gt;bge_ldata.bge_rx_std_ring, BGE_STD_RX_RING_SZ);</a>
<a name="ln1478">	sc-&gt;bge_std = 0;</a>
<a name="ln1479">	for (i = 0; i &lt; BGE_STD_RX_RING_CNT; i++) {</a>
<a name="ln1480">		if ((error = bge_newbuf_std(sc, i)) != 0)</a>
<a name="ln1481">			return (error);</a>
<a name="ln1482">		BGE_INC(sc-&gt;bge_std, BGE_STD_RX_RING_CNT);</a>
<a name="ln1483">	}</a>
<a name="ln1484"> </a>
<a name="ln1485">	bus_dmamap_sync(sc-&gt;bge_cdata.bge_rx_std_ring_tag,</a>
<a name="ln1486">	    sc-&gt;bge_cdata.bge_rx_std_ring_map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln1487"> </a>
<a name="ln1488">	sc-&gt;bge_std = 0;</a>
<a name="ln1489">	bge_writembx(sc, BGE_MBX_RX_STD_PROD_LO, BGE_STD_RX_RING_CNT - 1);</a>
<a name="ln1490"> </a>
<a name="ln1491">	return (0);</a>
<a name="ln1492">}</a>
<a name="ln1493"> </a>
<a name="ln1494">static void</a>
<a name="ln1495">bge_free_rx_ring_std(struct bge_softc *sc)</a>
<a name="ln1496">{</a>
<a name="ln1497">	int i;</a>
<a name="ln1498"> </a>
<a name="ln1499">	for (i = 0; i &lt; BGE_STD_RX_RING_CNT; i++) {</a>
<a name="ln1500">		if (sc-&gt;bge_cdata.bge_rx_std_chain[i] != NULL) {</a>
<a name="ln1501">			bus_dmamap_sync(sc-&gt;bge_cdata.bge_rx_mtag,</a>
<a name="ln1502">			    sc-&gt;bge_cdata.bge_rx_std_dmamap[i],</a>
<a name="ln1503">			    BUS_DMASYNC_POSTREAD);</a>
<a name="ln1504">			bus_dmamap_unload(sc-&gt;bge_cdata.bge_rx_mtag,</a>
<a name="ln1505">			    sc-&gt;bge_cdata.bge_rx_std_dmamap[i]);</a>
<a name="ln1506">			m_freem(sc-&gt;bge_cdata.bge_rx_std_chain[i]);</a>
<a name="ln1507">			sc-&gt;bge_cdata.bge_rx_std_chain[i] = NULL;</a>
<a name="ln1508">		}</a>
<a name="ln1509">		bzero((char *)&amp;sc-&gt;bge_ldata.bge_rx_std_ring[i],</a>
<a name="ln1510">		    sizeof(struct bge_rx_bd));</a>
<a name="ln1511">	}</a>
<a name="ln1512">}</a>
<a name="ln1513"> </a>
<a name="ln1514">static int</a>
<a name="ln1515">bge_init_rx_ring_jumbo(struct bge_softc *sc)</a>
<a name="ln1516">{</a>
<a name="ln1517">	struct bge_rcb *rcb;</a>
<a name="ln1518">	int error, i;</a>
<a name="ln1519"> </a>
<a name="ln1520">	bzero(sc-&gt;bge_ldata.bge_rx_jumbo_ring, BGE_JUMBO_RX_RING_SZ);</a>
<a name="ln1521">	sc-&gt;bge_jumbo = 0;</a>
<a name="ln1522">	for (i = 0; i &lt; BGE_JUMBO_RX_RING_CNT; i++) {</a>
<a name="ln1523">		if ((error = bge_newbuf_jumbo(sc, i)) != 0)</a>
<a name="ln1524">			return (error);</a>
<a name="ln1525">		BGE_INC(sc-&gt;bge_jumbo, BGE_JUMBO_RX_RING_CNT);</a>
<a name="ln1526">	}</a>
<a name="ln1527"> </a>
<a name="ln1528">	bus_dmamap_sync(sc-&gt;bge_cdata.bge_rx_jumbo_ring_tag,</a>
<a name="ln1529">	    sc-&gt;bge_cdata.bge_rx_jumbo_ring_map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln1530"> </a>
<a name="ln1531">	sc-&gt;bge_jumbo = 0;</a>
<a name="ln1532"> </a>
<a name="ln1533">	/* Enable the jumbo receive producer ring. */</a>
<a name="ln1534">	rcb = &amp;sc-&gt;bge_ldata.bge_info.bge_jumbo_rx_rcb;</a>
<a name="ln1535">	rcb-&gt;bge_maxlen_flags =</a>
<a name="ln1536">	    BGE_RCB_MAXLEN_FLAGS(0, BGE_RCB_FLAG_USE_EXT_RX_BD);</a>
<a name="ln1537">	CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_MAXLEN_FLAGS, rcb-&gt;bge_maxlen_flags);</a>
<a name="ln1538"> </a>
<a name="ln1539">	bge_writembx(sc, BGE_MBX_RX_JUMBO_PROD_LO, BGE_JUMBO_RX_RING_CNT - 1);</a>
<a name="ln1540"> </a>
<a name="ln1541">	return (0);</a>
<a name="ln1542">}</a>
<a name="ln1543"> </a>
<a name="ln1544">static void</a>
<a name="ln1545">bge_free_rx_ring_jumbo(struct bge_softc *sc)</a>
<a name="ln1546">{</a>
<a name="ln1547">	int i;</a>
<a name="ln1548"> </a>
<a name="ln1549">	for (i = 0; i &lt; BGE_JUMBO_RX_RING_CNT; i++) {</a>
<a name="ln1550">		if (sc-&gt;bge_cdata.bge_rx_jumbo_chain[i] != NULL) {</a>
<a name="ln1551">			bus_dmamap_sync(sc-&gt;bge_cdata.bge_mtag_jumbo,</a>
<a name="ln1552">			    sc-&gt;bge_cdata.bge_rx_jumbo_dmamap[i],</a>
<a name="ln1553">			    BUS_DMASYNC_POSTREAD);</a>
<a name="ln1554">			bus_dmamap_unload(sc-&gt;bge_cdata.bge_mtag_jumbo,</a>
<a name="ln1555">			    sc-&gt;bge_cdata.bge_rx_jumbo_dmamap[i]);</a>
<a name="ln1556">			m_freem(sc-&gt;bge_cdata.bge_rx_jumbo_chain[i]);</a>
<a name="ln1557">			sc-&gt;bge_cdata.bge_rx_jumbo_chain[i] = NULL;</a>
<a name="ln1558">		}</a>
<a name="ln1559">		bzero((char *)&amp;sc-&gt;bge_ldata.bge_rx_jumbo_ring[i],</a>
<a name="ln1560">		    sizeof(struct bge_extrx_bd));</a>
<a name="ln1561">	}</a>
<a name="ln1562">}</a>
<a name="ln1563"> </a>
<a name="ln1564">static void</a>
<a name="ln1565">bge_free_tx_ring(struct bge_softc *sc)</a>
<a name="ln1566">{</a>
<a name="ln1567">	int i;</a>
<a name="ln1568"> </a>
<a name="ln1569">	if (sc-&gt;bge_ldata.bge_tx_ring == NULL)</a>
<a name="ln1570">		return;</a>
<a name="ln1571"> </a>
<a name="ln1572">	for (i = 0; i &lt; BGE_TX_RING_CNT; i++) {</a>
<a name="ln1573">		if (sc-&gt;bge_cdata.bge_tx_chain[i] != NULL) {</a>
<a name="ln1574">			bus_dmamap_sync(sc-&gt;bge_cdata.bge_tx_mtag,</a>
<a name="ln1575">			    sc-&gt;bge_cdata.bge_tx_dmamap[i],</a>
<a name="ln1576">			    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln1577">			bus_dmamap_unload(sc-&gt;bge_cdata.bge_tx_mtag,</a>
<a name="ln1578">			    sc-&gt;bge_cdata.bge_tx_dmamap[i]);</a>
<a name="ln1579">			m_freem(sc-&gt;bge_cdata.bge_tx_chain[i]);</a>
<a name="ln1580">			sc-&gt;bge_cdata.bge_tx_chain[i] = NULL;</a>
<a name="ln1581">		}</a>
<a name="ln1582">		bzero((char *)&amp;sc-&gt;bge_ldata.bge_tx_ring[i],</a>
<a name="ln1583">		    sizeof(struct bge_tx_bd));</a>
<a name="ln1584">	}</a>
<a name="ln1585">}</a>
<a name="ln1586"> </a>
<a name="ln1587">static int</a>
<a name="ln1588">bge_init_tx_ring(struct bge_softc *sc)</a>
<a name="ln1589">{</a>
<a name="ln1590">	sc-&gt;bge_txcnt = 0;</a>
<a name="ln1591">	sc-&gt;bge_tx_saved_considx = 0;</a>
<a name="ln1592"> </a>
<a name="ln1593">	bzero(sc-&gt;bge_ldata.bge_tx_ring, BGE_TX_RING_SZ);</a>
<a name="ln1594">	bus_dmamap_sync(sc-&gt;bge_cdata.bge_tx_ring_tag,</a>
<a name="ln1595">	    sc-&gt;bge_cdata.bge_tx_ring_map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln1596"> </a>
<a name="ln1597">	/* Initialize transmit producer index for host-memory send ring. */</a>
<a name="ln1598">	sc-&gt;bge_tx_prodidx = 0;</a>
<a name="ln1599">	bge_writembx(sc, BGE_MBX_TX_HOST_PROD0_LO, sc-&gt;bge_tx_prodidx);</a>
<a name="ln1600"> </a>
<a name="ln1601">	/* 5700 b2 errata */</a>
<a name="ln1602">	if (sc-&gt;bge_chiprev == BGE_CHIPREV_5700_BX)</a>
<a name="ln1603">		bge_writembx(sc, BGE_MBX_TX_HOST_PROD0_LO, sc-&gt;bge_tx_prodidx);</a>
<a name="ln1604"> </a>
<a name="ln1605">	/* NIC-memory send ring not used; initialize to zero. */</a>
<a name="ln1606">	bge_writembx(sc, BGE_MBX_TX_NIC_PROD0_LO, 0);</a>
<a name="ln1607">	/* 5700 b2 errata */</a>
<a name="ln1608">	if (sc-&gt;bge_chiprev == BGE_CHIPREV_5700_BX)</a>
<a name="ln1609">		bge_writembx(sc, BGE_MBX_TX_NIC_PROD0_LO, 0);</a>
<a name="ln1610"> </a>
<a name="ln1611">	return (0);</a>
<a name="ln1612">}</a>
<a name="ln1613"> </a>
<a name="ln1614">static void</a>
<a name="ln1615">bge_setpromisc(struct bge_softc *sc)</a>
<a name="ln1616">{</a>
<a name="ln1617">	if_t ifp;</a>
<a name="ln1618"> </a>
<a name="ln1619">	BGE_LOCK_ASSERT(sc);</a>
<a name="ln1620"> </a>
<a name="ln1621">	ifp = sc-&gt;bge_ifp;</a>
<a name="ln1622"> </a>
<a name="ln1623">	/* Enable or disable promiscuous mode as needed. */</a>
<a name="ln1624">	if (if_getflags(ifp) &amp; IFF_PROMISC)</a>
<a name="ln1625">		BGE_SETBIT(sc, BGE_RX_MODE, BGE_RXMODE_RX_PROMISC);</a>
<a name="ln1626">	else</a>
<a name="ln1627">		BGE_CLRBIT(sc, BGE_RX_MODE, BGE_RXMODE_RX_PROMISC);</a>
<a name="ln1628">}</a>
<a name="ln1629"> </a>
<a name="ln1630">static void</a>
<a name="ln1631">bge_setmulti(struct bge_softc *sc)</a>
<a name="ln1632">{</a>
<a name="ln1633">	if_t ifp;</a>
<a name="ln1634">	int mc_count = 0;</a>
<a name="ln1635">	uint32_t hashes[4] = { 0, 0, 0, 0 };</a>
<a name="ln1636">	int h, i, mcnt;</a>
<a name="ln1637">	unsigned char *mta;</a>
<a name="ln1638"> </a>
<a name="ln1639">	BGE_LOCK_ASSERT(sc);</a>
<a name="ln1640"> </a>
<a name="ln1641">	ifp = sc-&gt;bge_ifp;</a>
<a name="ln1642"> </a>
<a name="ln1643">	mc_count = if_multiaddr_count(ifp, -1);</a>
<a name="ln1644">	mta = malloc(sizeof(unsigned char) *  ETHER_ADDR_LEN *</a>
<a name="ln1645">	    mc_count, M_DEVBUF, M_NOWAIT);</a>
<a name="ln1646"> </a>
<a name="ln1647">	if(mta == NULL) {</a>
<a name="ln1648">		device_printf(sc-&gt;bge_dev, </a>
<a name="ln1649">		    &quot;Failed to allocated temp mcast list\n&quot;);</a>
<a name="ln1650">		return;</a>
<a name="ln1651">	}</a>
<a name="ln1652"> </a>
<a name="ln1653">	if (if_getflags(ifp) &amp; IFF_ALLMULTI || if_getflags(ifp) &amp; IFF_PROMISC) {</a>
<a name="ln1654">		for (i = 0; i &lt; 4; i++)</a>
<a name="ln1655">			CSR_WRITE_4(sc, BGE_MAR0 + (i * 4), 0xFFFFFFFF);</a>
<a name="ln1656">		free(mta, M_DEVBUF);</a>
<a name="ln1657">		return;</a>
<a name="ln1658">	}</a>
<a name="ln1659"> </a>
<a name="ln1660">	/* First, zot all the existing filters. */</a>
<a name="ln1661">	for (i = 0; i &lt; 4; i++)</a>
<a name="ln1662">		CSR_WRITE_4(sc, BGE_MAR0 + (i * 4), 0);</a>
<a name="ln1663"> </a>
<a name="ln1664">	if_multiaddr_array(ifp, mta, &amp;mcnt, mc_count);</a>
<a name="ln1665">	for(i = 0; i &lt; mcnt; i++) {</a>
<a name="ln1666">		h = ether_crc32_le(mta + (i * ETHER_ADDR_LEN),</a>
<a name="ln1667">		    ETHER_ADDR_LEN) &amp; 0x7F;</a>
<a name="ln1668">		hashes[(h &amp; 0x60) &gt;&gt; 5] |= 1 &lt;&lt; (h &amp; 0x1F);</a>
<a name="ln1669">	}</a>
<a name="ln1670"> </a>
<a name="ln1671">	for (i = 0; i &lt; 4; i++)</a>
<a name="ln1672">		CSR_WRITE_4(sc, BGE_MAR0 + (i * 4), hashes[i]);</a>
<a name="ln1673"> </a>
<a name="ln1674">	free(mta, M_DEVBUF);</a>
<a name="ln1675">}</a>
<a name="ln1676"> </a>
<a name="ln1677">static void</a>
<a name="ln1678">bge_setvlan(struct bge_softc *sc)</a>
<a name="ln1679">{</a>
<a name="ln1680">	if_t ifp;</a>
<a name="ln1681"> </a>
<a name="ln1682">	BGE_LOCK_ASSERT(sc);</a>
<a name="ln1683"> </a>
<a name="ln1684">	ifp = sc-&gt;bge_ifp;</a>
<a name="ln1685"> </a>
<a name="ln1686">	/* Enable or disable VLAN tag stripping as needed. */</a>
<a name="ln1687">	if (if_getcapenable(ifp) &amp; IFCAP_VLAN_HWTAGGING)</a>
<a name="ln1688">		BGE_CLRBIT(sc, BGE_RX_MODE, BGE_RXMODE_RX_KEEP_VLAN_DIAG);</a>
<a name="ln1689">	else</a>
<a name="ln1690">		BGE_SETBIT(sc, BGE_RX_MODE, BGE_RXMODE_RX_KEEP_VLAN_DIAG);</a>
<a name="ln1691">}</a>
<a name="ln1692"> </a>
<a name="ln1693">static void</a>
<a name="ln1694">bge_sig_pre_reset(struct bge_softc *sc, int type)</a>
<a name="ln1695">{</a>
<a name="ln1696"> </a>
<a name="ln1697">	/*</a>
<a name="ln1698">	 * Some chips don't like this so only do this if ASF is enabled</a>
<a name="ln1699">	 */</a>
<a name="ln1700">	if (sc-&gt;bge_asf_mode)</a>
<a name="ln1701">		bge_writemem_ind(sc, BGE_SRAM_FW_MB, BGE_SRAM_FW_MB_MAGIC);</a>
<a name="ln1702"> </a>
<a name="ln1703">	if (sc-&gt;bge_asf_mode &amp; ASF_NEW_HANDSHAKE) {</a>
<a name="ln1704">		switch (type) {</a>
<a name="ln1705">		case BGE_RESET_START:</a>
<a name="ln1706">			bge_writemem_ind(sc, BGE_SRAM_FW_DRV_STATE_MB,</a>
<a name="ln1707">			    BGE_FW_DRV_STATE_START);</a>
<a name="ln1708">			break;</a>
<a name="ln1709">		case BGE_RESET_SHUTDOWN:</a>
<a name="ln1710">			bge_writemem_ind(sc, BGE_SRAM_FW_DRV_STATE_MB,</a>
<a name="ln1711">			    BGE_FW_DRV_STATE_UNLOAD);</a>
<a name="ln1712">			break;</a>
<a name="ln1713">		case BGE_RESET_SUSPEND:</a>
<a name="ln1714">			bge_writemem_ind(sc, BGE_SRAM_FW_DRV_STATE_MB,</a>
<a name="ln1715">			    BGE_FW_DRV_STATE_SUSPEND);</a>
<a name="ln1716">			break;</a>
<a name="ln1717">		}</a>
<a name="ln1718">	}</a>
<a name="ln1719"> </a>
<a name="ln1720">	if (type == BGE_RESET_START || type == BGE_RESET_SUSPEND)</a>
<a name="ln1721">		bge_ape_driver_state_change(sc, type);</a>
<a name="ln1722">}</a>
<a name="ln1723"> </a>
<a name="ln1724">static void</a>
<a name="ln1725">bge_sig_post_reset(struct bge_softc *sc, int type)</a>
<a name="ln1726">{</a>
<a name="ln1727"> </a>
<a name="ln1728">	if (sc-&gt;bge_asf_mode &amp; ASF_NEW_HANDSHAKE) {</a>
<a name="ln1729">		switch (type) {</a>
<a name="ln1730">		case BGE_RESET_START:</a>
<a name="ln1731">			bge_writemem_ind(sc, BGE_SRAM_FW_DRV_STATE_MB,</a>
<a name="ln1732">			    BGE_FW_DRV_STATE_START_DONE);</a>
<a name="ln1733">			/* START DONE */</a>
<a name="ln1734">			break;</a>
<a name="ln1735">		case BGE_RESET_SHUTDOWN:</a>
<a name="ln1736">			bge_writemem_ind(sc, BGE_SRAM_FW_DRV_STATE_MB,</a>
<a name="ln1737">			    BGE_FW_DRV_STATE_UNLOAD_DONE);</a>
<a name="ln1738">			break;</a>
<a name="ln1739">		}</a>
<a name="ln1740">	}</a>
<a name="ln1741">	if (type == BGE_RESET_SHUTDOWN)</a>
<a name="ln1742">		bge_ape_driver_state_change(sc, type);</a>
<a name="ln1743">}</a>
<a name="ln1744"> </a>
<a name="ln1745">static void</a>
<a name="ln1746">bge_sig_legacy(struct bge_softc *sc, int type)</a>
<a name="ln1747">{</a>
<a name="ln1748"> </a>
<a name="ln1749">	if (sc-&gt;bge_asf_mode) {</a>
<a name="ln1750">		switch (type) {</a>
<a name="ln1751">		case BGE_RESET_START:</a>
<a name="ln1752">			bge_writemem_ind(sc, BGE_SRAM_FW_DRV_STATE_MB,</a>
<a name="ln1753">			    BGE_FW_DRV_STATE_START);</a>
<a name="ln1754">			break;</a>
<a name="ln1755">		case BGE_RESET_SHUTDOWN:</a>
<a name="ln1756">			bge_writemem_ind(sc, BGE_SRAM_FW_DRV_STATE_MB,</a>
<a name="ln1757">			    BGE_FW_DRV_STATE_UNLOAD);</a>
<a name="ln1758">			break;</a>
<a name="ln1759">		}</a>
<a name="ln1760">	}</a>
<a name="ln1761">}</a>
<a name="ln1762"> </a>
<a name="ln1763">static void</a>
<a name="ln1764">bge_stop_fw(struct bge_softc *sc)</a>
<a name="ln1765">{</a>
<a name="ln1766">	int i;</a>
<a name="ln1767"> </a>
<a name="ln1768">	if (sc-&gt;bge_asf_mode) {</a>
<a name="ln1769">		bge_writemem_ind(sc, BGE_SRAM_FW_CMD_MB, BGE_FW_CMD_PAUSE);</a>
<a name="ln1770">		CSR_WRITE_4(sc, BGE_RX_CPU_EVENT,</a>
<a name="ln1771">		    CSR_READ_4(sc, BGE_RX_CPU_EVENT) | BGE_RX_CPU_DRV_EVENT);</a>
<a name="ln1772"> </a>
<a name="ln1773">		for (i = 0; i &lt; 100; i++ ) {</a>
<a name="ln1774">			if (!(CSR_READ_4(sc, BGE_RX_CPU_EVENT) &amp;</a>
<a name="ln1775">			    BGE_RX_CPU_DRV_EVENT))</a>
<a name="ln1776">				break;</a>
<a name="ln1777">			DELAY(10);</a>
<a name="ln1778">		}</a>
<a name="ln1779">	}</a>
<a name="ln1780">}</a>
<a name="ln1781"> </a>
<a name="ln1782">static uint32_t</a>
<a name="ln1783">bge_dma_swap_options(struct bge_softc *sc)</a>
<a name="ln1784">{</a>
<a name="ln1785">	uint32_t dma_options;</a>
<a name="ln1786"> </a>
<a name="ln1787">	dma_options = BGE_MODECTL_WORDSWAP_NONFRAME |</a>
<a name="ln1788">	    BGE_MODECTL_BYTESWAP_DATA | BGE_MODECTL_WORDSWAP_DATA;</a>
<a name="ln1789">#if BYTE_ORDER == BIG_ENDIAN</a>
<a name="ln1790">	dma_options |= BGE_MODECTL_BYTESWAP_NONFRAME;</a>
<a name="ln1791">#endif</a>
<a name="ln1792">	return (dma_options);</a>
<a name="ln1793">}</a>
<a name="ln1794"> </a>
<a name="ln1795">/*</a>
<a name="ln1796"> * Do endian, PCI and DMA initialization.</a>
<a name="ln1797"> */</a>
<a name="ln1798">static int</a>
<a name="ln1799">bge_chipinit(struct bge_softc *sc)</a>
<a name="ln1800">{</a>
<a name="ln1801">	uint32_t dma_rw_ctl, misc_ctl, mode_ctl;</a>
<a name="ln1802">	uint16_t val;</a>
<a name="ln1803">	int i;</a>
<a name="ln1804"> </a>
<a name="ln1805">	/* Set endianness before we access any non-PCI registers. */</a>
<a name="ln1806">	misc_ctl = BGE_INIT;</a>
<a name="ln1807">	if (sc-&gt;bge_flags &amp; BGE_FLAG_TAGGED_STATUS)</a>
<a name="ln1808">		misc_ctl |= BGE_PCIMISCCTL_TAGGED_STATUS;</a>
<a name="ln1809">	pci_write_config(sc-&gt;bge_dev, BGE_PCI_MISC_CTL, misc_ctl, 4);</a>
<a name="ln1810"> </a>
<a name="ln1811">	/*</a>
<a name="ln1812">	 * Clear the MAC statistics block in the NIC's</a>
<a name="ln1813">	 * internal memory.</a>
<a name="ln1814">	 */</a>
<a name="ln1815">	for (i = BGE_STATS_BLOCK;</a>
<a name="ln1816">	    i &lt; BGE_STATS_BLOCK_END + 1; i += sizeof(uint32_t))</a>
<a name="ln1817">		BGE_MEMWIN_WRITE(sc, i, 0);</a>
<a name="ln1818"> </a>
<a name="ln1819">	for (i = BGE_STATUS_BLOCK;</a>
<a name="ln1820">	    i &lt; BGE_STATUS_BLOCK_END + 1; i += sizeof(uint32_t))</a>
<a name="ln1821">		BGE_MEMWIN_WRITE(sc, i, 0);</a>
<a name="ln1822"> </a>
<a name="ln1823">	if (sc-&gt;bge_chiprev == BGE_CHIPREV_5704_BX) {</a>
<a name="ln1824">		/*</a>
<a name="ln1825">		 *  Fix data corruption caused by non-qword write with WB.</a>
<a name="ln1826">		 *  Fix master abort in PCI mode.</a>
<a name="ln1827">		 *  Fix PCI latency timer.</a>
<a name="ln1828">		 */</a>
<a name="ln1829">		val = pci_read_config(sc-&gt;bge_dev, BGE_PCI_MSI_DATA + 2, 2);</a>
<a name="ln1830">		val |= (1 &lt;&lt; 10) | (1 &lt;&lt; 12) | (1 &lt;&lt; 13);</a>
<a name="ln1831">		pci_write_config(sc-&gt;bge_dev, BGE_PCI_MSI_DATA + 2, val, 2);</a>
<a name="ln1832">	}</a>
<a name="ln1833"> </a>
<a name="ln1834">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM57765 ||</a>
<a name="ln1835">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM57766) {</a>
<a name="ln1836">		/*</a>
<a name="ln1837">		 * For the 57766 and non Ax versions of 57765, bootcode</a>
<a name="ln1838">		 * needs to setup the PCIE Fast Training Sequence (FTS)</a>
<a name="ln1839">		 * value to prevent transmit hangs.</a>
<a name="ln1840">		 */</a>
<a name="ln1841">		if (sc-&gt;bge_chiprev != BGE_CHIPREV_57765_AX) {</a>
<a name="ln1842">			CSR_WRITE_4(sc, BGE_CPMU_PADRNG_CTL,</a>
<a name="ln1843">			    CSR_READ_4(sc, BGE_CPMU_PADRNG_CTL) |</a>
<a name="ln1844">			    BGE_CPMU_PADRNG_CTL_RDIV2);</a>
<a name="ln1845">		}</a>
<a name="ln1846">	}</a>
<a name="ln1847"> </a>
<a name="ln1848">	/*</a>
<a name="ln1849">	 * Set up the PCI DMA control register.</a>
<a name="ln1850">	 */</a>
<a name="ln1851">	dma_rw_ctl = BGE_PCIDMARWCTL_RD_CMD_SHIFT(6) |</a>
<a name="ln1852">	    BGE_PCIDMARWCTL_WR_CMD_SHIFT(7);</a>
<a name="ln1853">	if (sc-&gt;bge_flags &amp; BGE_FLAG_PCIE) {</a>
<a name="ln1854">		if (sc-&gt;bge_mps &gt;= 256)</a>
<a name="ln1855">			dma_rw_ctl |= BGE_PCIDMARWCTL_WR_WAT_SHIFT(7);</a>
<a name="ln1856">		else</a>
<a name="ln1857">			dma_rw_ctl |= BGE_PCIDMARWCTL_WR_WAT_SHIFT(3);</a>
<a name="ln1858">	} else if (sc-&gt;bge_flags &amp; BGE_FLAG_PCIX) {</a>
<a name="ln1859">		if (BGE_IS_5714_FAMILY(sc)) {</a>
<a name="ln1860">			/* 256 bytes for read and write. */</a>
<a name="ln1861">			dma_rw_ctl |= BGE_PCIDMARWCTL_RD_WAT_SHIFT(2) |</a>
<a name="ln1862">			    BGE_PCIDMARWCTL_WR_WAT_SHIFT(2);</a>
<a name="ln1863">			dma_rw_ctl |= (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5780) ?</a>
<a name="ln1864">			    BGE_PCIDMARWCTL_ONEDMA_ATONCE_GLOBAL :</a>
<a name="ln1865">			    BGE_PCIDMARWCTL_ONEDMA_ATONCE_LOCAL;</a>
<a name="ln1866">		} else if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5703) {</a>
<a name="ln1867">			/*</a>
<a name="ln1868">			 * In the BCM5703, the DMA read watermark should</a>
<a name="ln1869">			 * be set to less than or equal to the maximum</a>
<a name="ln1870">			 * memory read byte count of the PCI-X command</a>
<a name="ln1871">			 * register.</a>
<a name="ln1872">			 */</a>
<a name="ln1873">			dma_rw_ctl |= BGE_PCIDMARWCTL_RD_WAT_SHIFT(4) |</a>
<a name="ln1874">			    BGE_PCIDMARWCTL_WR_WAT_SHIFT(3);</a>
<a name="ln1875">		} else if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5704) {</a>
<a name="ln1876">			/* 1536 bytes for read, 384 bytes for write. */</a>
<a name="ln1877">			dma_rw_ctl |= BGE_PCIDMARWCTL_RD_WAT_SHIFT(7) |</a>
<a name="ln1878">			    BGE_PCIDMARWCTL_WR_WAT_SHIFT(3);</a>
<a name="ln1879">		} else {</a>
<a name="ln1880">			/* 384 bytes for read and write. */</a>
<a name="ln1881">			dma_rw_ctl |= BGE_PCIDMARWCTL_RD_WAT_SHIFT(3) |</a>
<a name="ln1882">			    BGE_PCIDMARWCTL_WR_WAT_SHIFT(3) |</a>
<a name="ln1883">			    0x0F;</a>
<a name="ln1884">		}</a>
<a name="ln1885">		if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5703 ||</a>
<a name="ln1886">		    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5704) {</a>
<a name="ln1887">			uint32_t tmp;</a>
<a name="ln1888"> </a>
<a name="ln1889">			/* Set ONE_DMA_AT_ONCE for hardware workaround. */</a>
<a name="ln1890">			tmp = CSR_READ_4(sc, BGE_PCI_CLKCTL) &amp; 0x1F;</a>
<a name="ln1891">			if (tmp == 6 || tmp == 7)</a>
<a name="ln1892">				dma_rw_ctl |=</a>
<a name="ln1893">				    BGE_PCIDMARWCTL_ONEDMA_ATONCE_GLOBAL;</a>
<a name="ln1894"> </a>
<a name="ln1895">			/* Set PCI-X DMA write workaround. */</a>
<a name="ln1896">			dma_rw_ctl |= BGE_PCIDMARWCTL_ASRT_ALL_BE;</a>
<a name="ln1897">		}</a>
<a name="ln1898">	} else {</a>
<a name="ln1899">		/* Conventional PCI bus: 256 bytes for read and write. */</a>
<a name="ln1900">		dma_rw_ctl |= BGE_PCIDMARWCTL_RD_WAT_SHIFT(7) |</a>
<a name="ln1901">		    BGE_PCIDMARWCTL_WR_WAT_SHIFT(7);</a>
<a name="ln1902"> </a>
<a name="ln1903">		if (sc-&gt;bge_asicrev != BGE_ASICREV_BCM5705 &amp;&amp;</a>
<a name="ln1904">		    sc-&gt;bge_asicrev != BGE_ASICREV_BCM5750)</a>
<a name="ln1905">			dma_rw_ctl |= 0x0F;</a>
<a name="ln1906">	}</a>
<a name="ln1907">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5700 ||</a>
<a name="ln1908">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5701)</a>
<a name="ln1909">		dma_rw_ctl |= BGE_PCIDMARWCTL_USE_MRM |</a>
<a name="ln1910">		    BGE_PCIDMARWCTL_ASRT_ALL_BE;</a>
<a name="ln1911">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5703 ||</a>
<a name="ln1912">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5704)</a>
<a name="ln1913">		dma_rw_ctl &amp;= ~BGE_PCIDMARWCTL_MINDMA;</a>
<a name="ln1914">	if (BGE_IS_5717_PLUS(sc)) {</a>
<a name="ln1915">		dma_rw_ctl &amp;= ~BGE_PCIDMARWCTL_DIS_CACHE_ALIGNMENT;</a>
<a name="ln1916">		if (sc-&gt;bge_chipid == BGE_CHIPID_BCM57765_A0)</a>
<a name="ln1917">			dma_rw_ctl &amp;= ~BGE_PCIDMARWCTL_CRDRDR_RDMA_MRRS_MSK;</a>
<a name="ln1918">		/*</a>
<a name="ln1919">		 * Enable HW workaround for controllers that misinterpret</a>
<a name="ln1920">		 * a status tag update and leave interrupts permanently</a>
<a name="ln1921">		 * disabled.</a>
<a name="ln1922">		 */</a>
<a name="ln1923">		if (!BGE_IS_57765_PLUS(sc) &amp;&amp;</a>
<a name="ln1924">		    sc-&gt;bge_asicrev != BGE_ASICREV_BCM5717 &amp;&amp;</a>
<a name="ln1925">		    sc-&gt;bge_asicrev != BGE_ASICREV_BCM5762)</a>
<a name="ln1926">			dma_rw_ctl |= BGE_PCIDMARWCTL_TAGGED_STATUS_WA;</a>
<a name="ln1927">	}</a>
<a name="ln1928">	pci_write_config(sc-&gt;bge_dev, BGE_PCI_DMA_RW_CTL, dma_rw_ctl, 4);</a>
<a name="ln1929"> </a>
<a name="ln1930">	/*</a>
<a name="ln1931">	 * Set up general mode register.</a>
<a name="ln1932">	 */</a>
<a name="ln1933">	mode_ctl = bge_dma_swap_options(sc);</a>
<a name="ln1934">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5720 ||</a>
<a name="ln1935">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5762) {</a>
<a name="ln1936">		/* Retain Host-2-BMC settings written by APE firmware. */</a>
<a name="ln1937">		mode_ctl |= CSR_READ_4(sc, BGE_MODE_CTL) &amp;</a>
<a name="ln1938">		    (BGE_MODECTL_BYTESWAP_B2HRX_DATA |</a>
<a name="ln1939">		    BGE_MODECTL_WORDSWAP_B2HRX_DATA |</a>
<a name="ln1940">		    BGE_MODECTL_B2HRX_ENABLE | BGE_MODECTL_HTX2B_ENABLE);</a>
<a name="ln1941">	}</a>
<a name="ln1942">	mode_ctl |= BGE_MODECTL_MAC_ATTN_INTR | BGE_MODECTL_HOST_SEND_BDS |</a>
<a name="ln1943">	    BGE_MODECTL_TX_NO_PHDR_CSUM;</a>
<a name="ln1944"> </a>
<a name="ln1945">	/*</a>
<a name="ln1946">	 * BCM5701 B5 have a bug causing data corruption when using</a>
<a name="ln1947">	 * 64-bit DMA reads, which can be terminated early and then</a>
<a name="ln1948">	 * completed later as 32-bit accesses, in combination with</a>
<a name="ln1949">	 * certain bridges.</a>
<a name="ln1950">	 */</a>
<a name="ln1951">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5701 &amp;&amp;</a>
<a name="ln1952">	    sc-&gt;bge_chipid == BGE_CHIPID_BCM5701_B5)</a>
<a name="ln1953">		mode_ctl |= BGE_MODECTL_FORCE_PCI32;</a>
<a name="ln1954"> </a>
<a name="ln1955">	/*</a>
<a name="ln1956">	 * Tell the firmware the driver is running</a>
<a name="ln1957">	 */</a>
<a name="ln1958">	if (sc-&gt;bge_asf_mode &amp; ASF_STACKUP)</a>
<a name="ln1959">		mode_ctl |= BGE_MODECTL_STACKUP;</a>
<a name="ln1960"> </a>
<a name="ln1961">	CSR_WRITE_4(sc, BGE_MODE_CTL, mode_ctl);</a>
<a name="ln1962"> </a>
<a name="ln1963">	/*</a>
<a name="ln1964">	 * Disable memory write invalidate.  Apparently it is not supported</a>
<a name="ln1965">	 * properly by these devices.</a>
<a name="ln1966">	 */</a>
<a name="ln1967">	PCI_CLRBIT(sc-&gt;bge_dev, BGE_PCI_CMD, PCIM_CMD_MWIEN, 4);</a>
<a name="ln1968"> </a>
<a name="ln1969">	/* Set the timer prescaler (always 66 MHz). */</a>
<a name="ln1970">	CSR_WRITE_4(sc, BGE_MISC_CFG, BGE_32BITTIME_66MHZ);</a>
<a name="ln1971"> </a>
<a name="ln1972">	/* XXX: The Linux tg3 driver does this at the start of brgphy_reset. */</a>
<a name="ln1973">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5906) {</a>
<a name="ln1974">		DELAY(40);	/* XXX */</a>
<a name="ln1975"> </a>
<a name="ln1976">		/* Put PHY into ready state */</a>
<a name="ln1977">		BGE_CLRBIT(sc, BGE_MISC_CFG, BGE_MISCCFG_EPHY_IDDQ);</a>
<a name="ln1978">		CSR_READ_4(sc, BGE_MISC_CFG); /* Flush */</a>
<a name="ln1979">		DELAY(40);</a>
<a name="ln1980">	}</a>
<a name="ln1981"> </a>
<a name="ln1982">	return (0);</a>
<a name="ln1983">}</a>
<a name="ln1984"> </a>
<a name="ln1985">static int</a>
<a name="ln1986">bge_blockinit(struct bge_softc *sc)</a>
<a name="ln1987">{</a>
<a name="ln1988">	struct bge_rcb *rcb;</a>
<a name="ln1989">	bus_size_t vrcb;</a>
<a name="ln1990">	bge_hostaddr taddr;</a>
<a name="ln1991">	uint32_t dmactl, rdmareg, val;</a>
<a name="ln1992">	int i, limit;</a>
<a name="ln1993"> </a>
<a name="ln1994">	/*</a>
<a name="ln1995">	 * Initialize the memory window pointer register so that</a>
<a name="ln1996">	 * we can access the first 32K of internal NIC RAM. This will</a>
<a name="ln1997">	 * allow us to set up the TX send ring RCBs and the RX return</a>
<a name="ln1998">	 * ring RCBs, plus other things which live in NIC memory.</a>
<a name="ln1999">	 */</a>
<a name="ln2000">	CSR_WRITE_4(sc, BGE_PCI_MEMWIN_BASEADDR, 0);</a>
<a name="ln2001"> </a>
<a name="ln2002">	/* Note: the BCM5704 has a smaller mbuf space than other chips. */</a>
<a name="ln2003"> </a>
<a name="ln2004">	if (!(BGE_IS_5705_PLUS(sc))) {</a>
<a name="ln2005">		/* Configure mbuf memory pool */</a>
<a name="ln2006">		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_BASEADDR, BGE_BUFFPOOL_1);</a>
<a name="ln2007">		if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5704)</a>
<a name="ln2008">			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_LEN, 0x10000);</a>
<a name="ln2009">		else</a>
<a name="ln2010">			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_LEN, 0x18000);</a>
<a name="ln2011"> </a>
<a name="ln2012">		/* Configure DMA resource pool */</a>
<a name="ln2013">		CSR_WRITE_4(sc, BGE_BMAN_DMA_DESCPOOL_BASEADDR,</a>
<a name="ln2014">		    BGE_DMA_DESCRIPTORS);</a>
<a name="ln2015">		CSR_WRITE_4(sc, BGE_BMAN_DMA_DESCPOOL_LEN, 0x2000);</a>
<a name="ln2016">	}</a>
<a name="ln2017"> </a>
<a name="ln2018">	/* Configure mbuf pool watermarks */</a>
<a name="ln2019">	if (BGE_IS_5717_PLUS(sc)) {</a>
<a name="ln2020">		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_READDMA_LOWAT, 0x0);</a>
<a name="ln2021">		if (if_getmtu(sc-&gt;bge_ifp) &gt; ETHERMTU) {</a>
<a name="ln2022">			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x7e);</a>
<a name="ln2023">			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0xea);</a>
<a name="ln2024">		} else {</a>
<a name="ln2025">			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x2a);</a>
<a name="ln2026">			CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0xa0);</a>
<a name="ln2027">		}</a>
<a name="ln2028">	} else if (!BGE_IS_5705_PLUS(sc)) {</a>
<a name="ln2029">		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_READDMA_LOWAT, 0x50);</a>
<a name="ln2030">		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x20);</a>
<a name="ln2031">		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0x60);</a>
<a name="ln2032">	} else if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5906) {</a>
<a name="ln2033">		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_READDMA_LOWAT, 0x0);</a>
<a name="ln2034">		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x04);</a>
<a name="ln2035">		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0x10);</a>
<a name="ln2036">	} else {</a>
<a name="ln2037">		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_READDMA_LOWAT, 0x0);</a>
<a name="ln2038">		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_MACRX_LOWAT, 0x10);</a>
<a name="ln2039">		CSR_WRITE_4(sc, BGE_BMAN_MBUFPOOL_HIWAT, 0x60);</a>
<a name="ln2040">	}</a>
<a name="ln2041"> </a>
<a name="ln2042">	/* Configure DMA resource watermarks */</a>
<a name="ln2043">	CSR_WRITE_4(sc, BGE_BMAN_DMA_DESCPOOL_LOWAT, 5);</a>
<a name="ln2044">	CSR_WRITE_4(sc, BGE_BMAN_DMA_DESCPOOL_HIWAT, 10);</a>
<a name="ln2045"> </a>
<a name="ln2046">	/* Enable buffer manager */</a>
<a name="ln2047">	val = BGE_BMANMODE_ENABLE | BGE_BMANMODE_LOMBUF_ATTN;</a>
<a name="ln2048">	/*</a>
<a name="ln2049">	 * Change the arbitration algorithm of TXMBUF read request to</a>
<a name="ln2050">	 * round-robin instead of priority based for BCM5719.  When</a>
<a name="ln2051">	 * TXFIFO is almost empty, RDMA will hold its request until</a>
<a name="ln2052">	 * TXFIFO is not almost empty.</a>
<a name="ln2053">	 */</a>
<a name="ln2054">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5719)</a>
<a name="ln2055">		val |= BGE_BMANMODE_NO_TX_UNDERRUN;</a>
<a name="ln2056">	CSR_WRITE_4(sc, BGE_BMAN_MODE, val);</a>
<a name="ln2057"> </a>
<a name="ln2058">	/* Poll for buffer manager start indication */</a>
<a name="ln2059">	for (i = 0; i &lt; BGE_TIMEOUT; i++) {</a>
<a name="ln2060">		DELAY(10);</a>
<a name="ln2061">		if (CSR_READ_4(sc, BGE_BMAN_MODE) &amp; BGE_BMANMODE_ENABLE)</a>
<a name="ln2062">			break;</a>
<a name="ln2063">	}</a>
<a name="ln2064"> </a>
<a name="ln2065">	if (i == BGE_TIMEOUT) {</a>
<a name="ln2066">		device_printf(sc-&gt;bge_dev, &quot;buffer manager failed to start\n&quot;);</a>
<a name="ln2067">		return (ENXIO);</a>
<a name="ln2068">	}</a>
<a name="ln2069"> </a>
<a name="ln2070">	/* Enable flow-through queues */</a>
<a name="ln2071">	CSR_WRITE_4(sc, BGE_FTQ_RESET, 0xFFFFFFFF);</a>
<a name="ln2072">	CSR_WRITE_4(sc, BGE_FTQ_RESET, 0);</a>
<a name="ln2073"> </a>
<a name="ln2074">	/* Wait until queue initialization is complete */</a>
<a name="ln2075">	for (i = 0; i &lt; BGE_TIMEOUT; i++) {</a>
<a name="ln2076">		DELAY(10);</a>
<a name="ln2077">		if (CSR_READ_4(sc, BGE_FTQ_RESET) == 0)</a>
<a name="ln2078">			break;</a>
<a name="ln2079">	}</a>
<a name="ln2080"> </a>
<a name="ln2081">	if (i == BGE_TIMEOUT) {</a>
<a name="ln2082">		device_printf(sc-&gt;bge_dev, &quot;flow-through queue init failed\n&quot;);</a>
<a name="ln2083">		return (ENXIO);</a>
<a name="ln2084">	}</a>
<a name="ln2085"> </a>
<a name="ln2086">	/*</a>
<a name="ln2087">	 * Summary of rings supported by the controller:</a>
<a name="ln2088">	 *</a>
<a name="ln2089">	 * Standard Receive Producer Ring</a>
<a name="ln2090">	 * - This ring is used to feed receive buffers for &quot;standard&quot;</a>
<a name="ln2091">	 *   sized frames (typically 1536 bytes) to the controller.</a>
<a name="ln2092">	 *</a>
<a name="ln2093">	 * Jumbo Receive Producer Ring</a>
<a name="ln2094">	 * - This ring is used to feed receive buffers for jumbo sized</a>
<a name="ln2095">	 *   frames (i.e. anything bigger than the &quot;standard&quot; frames)</a>
<a name="ln2096">	 *   to the controller.</a>
<a name="ln2097">	 *</a>
<a name="ln2098">	 * Mini Receive Producer Ring</a>
<a name="ln2099">	 * - This ring is used to feed receive buffers for &quot;mini&quot;</a>
<a name="ln2100">	 *   sized frames to the controller.</a>
<a name="ln2101">	 * - This feature required external memory for the controller</a>
<a name="ln2102">	 *   but was never used in a production system.  Should always</a>
<a name="ln2103">	 *   be disabled.</a>
<a name="ln2104">	 *</a>
<a name="ln2105">	 * Receive Return Ring</a>
<a name="ln2106">	 * - After the controller has placed an incoming frame into a</a>
<a name="ln2107">	 *   receive buffer that buffer is moved into a receive return</a>
<a name="ln2108">	 *   ring.  The driver is then responsible to passing the</a>
<a name="ln2109">	 *   buffer up to the stack.  Many versions of the controller</a>
<a name="ln2110">	 *   support multiple RR rings.</a>
<a name="ln2111">	 *</a>
<a name="ln2112">	 * Send Ring</a>
<a name="ln2113">	 * - This ring is used for outgoing frames.  Many versions of</a>
<a name="ln2114">	 *   the controller support multiple send rings.</a>
<a name="ln2115">	 */</a>
<a name="ln2116"> </a>
<a name="ln2117">	/* Initialize the standard receive producer ring control block. */</a>
<a name="ln2118">	rcb = &amp;sc-&gt;bge_ldata.bge_info.bge_std_rx_rcb;</a>
<a name="ln2119">	rcb-&gt;bge_hostaddr.bge_addr_lo =</a>
<a name="ln2120">	    BGE_ADDR_LO(sc-&gt;bge_ldata.bge_rx_std_ring_paddr);</a>
<a name="ln2121">	rcb-&gt;bge_hostaddr.bge_addr_hi =</a>
<a name="ln2122">	    BGE_ADDR_HI(sc-&gt;bge_ldata.bge_rx_std_ring_paddr);</a>
<a name="ln2123">	bus_dmamap_sync(sc-&gt;bge_cdata.bge_rx_std_ring_tag,</a>
<a name="ln2124">	    sc-&gt;bge_cdata.bge_rx_std_ring_map, BUS_DMASYNC_PREREAD);</a>
<a name="ln2125">	if (BGE_IS_5717_PLUS(sc)) {</a>
<a name="ln2126">		/*</a>
<a name="ln2127">		 * Bits 31-16: Programmable ring size (2048, 1024, 512, .., 32)</a>
<a name="ln2128">		 * Bits 15-2 : Maximum RX frame size</a>
<a name="ln2129">		 * Bit 1     : 1 = Ring Disabled, 0 = Ring ENabled</a>
<a name="ln2130">		 * Bit 0     : Reserved</a>
<a name="ln2131">		 */</a>
<a name="ln2132">		rcb-&gt;bge_maxlen_flags =</a>
<a name="ln2133">		    BGE_RCB_MAXLEN_FLAGS(512, BGE_MAX_FRAMELEN &lt;&lt; 2);</a>
<a name="ln2134">	} else if (BGE_IS_5705_PLUS(sc)) {</a>
<a name="ln2135">		/*</a>
<a name="ln2136">		 * Bits 31-16: Programmable ring size (512, 256, 128, 64, 32)</a>
<a name="ln2137">		 * Bits 15-2 : Reserved (should be 0)</a>
<a name="ln2138">		 * Bit 1     : 1 = Ring Disabled, 0 = Ring Enabled</a>
<a name="ln2139">		 * Bit 0     : Reserved</a>
<a name="ln2140">		 */</a>
<a name="ln2141">		rcb-&gt;bge_maxlen_flags = BGE_RCB_MAXLEN_FLAGS(512, 0);</a>
<a name="ln2142">	} else {</a>
<a name="ln2143">		/*</a>
<a name="ln2144">		 * Ring size is always XXX entries</a>
<a name="ln2145">		 * Bits 31-16: Maximum RX frame size</a>
<a name="ln2146">		 * Bits 15-2 : Reserved (should be 0)</a>
<a name="ln2147">		 * Bit 1     : 1 = Ring Disabled, 0 = Ring Enabled</a>
<a name="ln2148">		 * Bit 0     : Reserved</a>
<a name="ln2149">		 */</a>
<a name="ln2150">		rcb-&gt;bge_maxlen_flags =</a>
<a name="ln2151">		    BGE_RCB_MAXLEN_FLAGS(BGE_MAX_FRAMELEN, 0);</a>
<a name="ln2152">	}</a>
<a name="ln2153">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5717 ||</a>
<a name="ln2154">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5719 ||</a>
<a name="ln2155">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5720)</a>
<a name="ln2156">		rcb-&gt;bge_nicaddr = BGE_STD_RX_RINGS_5717;</a>
<a name="ln2157">	else</a>
<a name="ln2158">		rcb-&gt;bge_nicaddr = BGE_STD_RX_RINGS;</a>
<a name="ln2159">	/* Write the standard receive producer ring control block. */</a>
<a name="ln2160">	CSR_WRITE_4(sc, BGE_RX_STD_RCB_HADDR_HI, rcb-&gt;bge_hostaddr.bge_addr_hi);</a>
<a name="ln2161">	CSR_WRITE_4(sc, BGE_RX_STD_RCB_HADDR_LO, rcb-&gt;bge_hostaddr.bge_addr_lo);</a>
<a name="ln2162">	CSR_WRITE_4(sc, BGE_RX_STD_RCB_MAXLEN_FLAGS, rcb-&gt;bge_maxlen_flags);</a>
<a name="ln2163">	CSR_WRITE_4(sc, BGE_RX_STD_RCB_NICADDR, rcb-&gt;bge_nicaddr);</a>
<a name="ln2164"> </a>
<a name="ln2165">	/* Reset the standard receive producer ring producer index. */</a>
<a name="ln2166">	bge_writembx(sc, BGE_MBX_RX_STD_PROD_LO, 0);</a>
<a name="ln2167"> </a>
<a name="ln2168">	/*</a>
<a name="ln2169">	 * Initialize the jumbo RX producer ring control</a>
<a name="ln2170">	 * block.  We set the 'ring disabled' bit in the</a>
<a name="ln2171">	 * flags field until we're actually ready to start</a>
<a name="ln2172">	 * using this ring (i.e. once we set the MTU</a>
<a name="ln2173">	 * high enough to require it).</a>
<a name="ln2174">	 */</a>
<a name="ln2175">	if (BGE_IS_JUMBO_CAPABLE(sc)) {</a>
<a name="ln2176">		rcb = &amp;sc-&gt;bge_ldata.bge_info.bge_jumbo_rx_rcb;</a>
<a name="ln2177">		/* Get the jumbo receive producer ring RCB parameters. */</a>
<a name="ln2178">		rcb-&gt;bge_hostaddr.bge_addr_lo =</a>
<a name="ln2179">		    BGE_ADDR_LO(sc-&gt;bge_ldata.bge_rx_jumbo_ring_paddr);</a>
<a name="ln2180">		rcb-&gt;bge_hostaddr.bge_addr_hi =</a>
<a name="ln2181">		    BGE_ADDR_HI(sc-&gt;bge_ldata.bge_rx_jumbo_ring_paddr);</a>
<a name="ln2182">		bus_dmamap_sync(sc-&gt;bge_cdata.bge_rx_jumbo_ring_tag,</a>
<a name="ln2183">		    sc-&gt;bge_cdata.bge_rx_jumbo_ring_map,</a>
<a name="ln2184">		    BUS_DMASYNC_PREREAD);</a>
<a name="ln2185">		rcb-&gt;bge_maxlen_flags = BGE_RCB_MAXLEN_FLAGS(0,</a>
<a name="ln2186">		    BGE_RCB_FLAG_USE_EXT_RX_BD | BGE_RCB_FLAG_RING_DISABLED);</a>
<a name="ln2187">		if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5717 ||</a>
<a name="ln2188">		    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5719 ||</a>
<a name="ln2189">		    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5720)</a>
<a name="ln2190">			rcb-&gt;bge_nicaddr = BGE_JUMBO_RX_RINGS_5717;</a>
<a name="ln2191">		else</a>
<a name="ln2192">			rcb-&gt;bge_nicaddr = BGE_JUMBO_RX_RINGS;</a>
<a name="ln2193">		CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_HADDR_HI,</a>
<a name="ln2194">		    rcb-&gt;bge_hostaddr.bge_addr_hi);</a>
<a name="ln2195">		CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_HADDR_LO,</a>
<a name="ln2196">		    rcb-&gt;bge_hostaddr.bge_addr_lo);</a>
<a name="ln2197">		/* Program the jumbo receive producer ring RCB parameters. */</a>
<a name="ln2198">		CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_MAXLEN_FLAGS,</a>
<a name="ln2199">		    rcb-&gt;bge_maxlen_flags);</a>
<a name="ln2200">		CSR_WRITE_4(sc, BGE_RX_JUMBO_RCB_NICADDR, rcb-&gt;bge_nicaddr);</a>
<a name="ln2201">		/* Reset the jumbo receive producer ring producer index. */</a>
<a name="ln2202">		bge_writembx(sc, BGE_MBX_RX_JUMBO_PROD_LO, 0);</a>
<a name="ln2203">	}</a>
<a name="ln2204"> </a>
<a name="ln2205">	/* Disable the mini receive producer ring RCB. */</a>
<a name="ln2206">	if (BGE_IS_5700_FAMILY(sc)) {</a>
<a name="ln2207">		rcb = &amp;sc-&gt;bge_ldata.bge_info.bge_mini_rx_rcb;</a>
<a name="ln2208">		rcb-&gt;bge_maxlen_flags =</a>
<a name="ln2209">		    BGE_RCB_MAXLEN_FLAGS(0, BGE_RCB_FLAG_RING_DISABLED);</a>
<a name="ln2210">		CSR_WRITE_4(sc, BGE_RX_MINI_RCB_MAXLEN_FLAGS,</a>
<a name="ln2211">		    rcb-&gt;bge_maxlen_flags);</a>
<a name="ln2212">		/* Reset the mini receive producer ring producer index. */</a>
<a name="ln2213">		bge_writembx(sc, BGE_MBX_RX_MINI_PROD_LO, 0);</a>
<a name="ln2214">	}</a>
<a name="ln2215"> </a>
<a name="ln2216">	/* Choose de-pipeline mode for BCM5906 A0, A1 and A2. */</a>
<a name="ln2217">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5906) {</a>
<a name="ln2218">		if (sc-&gt;bge_chipid == BGE_CHIPID_BCM5906_A0 ||</a>
<a name="ln2219">		    sc-&gt;bge_chipid == BGE_CHIPID_BCM5906_A1 ||</a>
<a name="ln2220">		    sc-&gt;bge_chipid == BGE_CHIPID_BCM5906_A2)</a>
<a name="ln2221">			CSR_WRITE_4(sc, BGE_ISO_PKT_TX,</a>
<a name="ln2222">			    (CSR_READ_4(sc, BGE_ISO_PKT_TX) &amp; ~3) | 2);</a>
<a name="ln2223">	}</a>
<a name="ln2224">	/*</a>
<a name="ln2225">	 * The BD ring replenish thresholds control how often the</a>
<a name="ln2226">	 * hardware fetches new BD's from the producer rings in host</a>
<a name="ln2227">	 * memory.  Setting the value too low on a busy system can</a>
<a name="ln2228">	 * starve the hardware and recue the throughpout.</a>
<a name="ln2229">	 *</a>
<a name="ln2230">	 * Set the BD ring replentish thresholds. The recommended</a>
<a name="ln2231">	 * values are 1/8th the number of descriptors allocated to</a>
<a name="ln2232">	 * each ring.</a>
<a name="ln2233">	 * XXX The 5754 requires a lower threshold, so it might be a</a>
<a name="ln2234">	 * requirement of all 575x family chips.  The Linux driver sets</a>
<a name="ln2235">	 * the lower threshold for all 5705 family chips as well, but there</a>
<a name="ln2236">	 * are reports that it might not need to be so strict.</a>
<a name="ln2237">	 *</a>
<a name="ln2238">	 * XXX Linux does some extra fiddling here for the 5906 parts as</a>
<a name="ln2239">	 * well.</a>
<a name="ln2240">	 */</a>
<a name="ln2241">	if (BGE_IS_5705_PLUS(sc))</a>
<a name="ln2242">		val = 8;</a>
<a name="ln2243">	else</a>
<a name="ln2244">		val = BGE_STD_RX_RING_CNT / 8;</a>
<a name="ln2245">	CSR_WRITE_4(sc, BGE_RBDI_STD_REPL_THRESH, val);</a>
<a name="ln2246">	if (BGE_IS_JUMBO_CAPABLE(sc))</a>
<a name="ln2247">		CSR_WRITE_4(sc, BGE_RBDI_JUMBO_REPL_THRESH,</a>
<a name="ln2248">		    BGE_JUMBO_RX_RING_CNT/8);</a>
<a name="ln2249">	if (BGE_IS_5717_PLUS(sc)) {</a>
<a name="ln2250">		CSR_WRITE_4(sc, BGE_STD_REPLENISH_LWM, 32);</a>
<a name="ln2251">		CSR_WRITE_4(sc, BGE_JMB_REPLENISH_LWM, 16);</a>
<a name="ln2252">	}</a>
<a name="ln2253"> </a>
<a name="ln2254">	/*</a>
<a name="ln2255">	 * Disable all send rings by setting the 'ring disabled' bit</a>
<a name="ln2256">	 * in the flags field of all the TX send ring control blocks,</a>
<a name="ln2257">	 * located in NIC memory.</a>
<a name="ln2258">	 */</a>
<a name="ln2259">	if (!BGE_IS_5705_PLUS(sc))</a>
<a name="ln2260">		/* 5700 to 5704 had 16 send rings. */</a>
<a name="ln2261">		limit = BGE_TX_RINGS_EXTSSRAM_MAX;</a>
<a name="ln2262">	else if (BGE_IS_57765_PLUS(sc) ||</a>
<a name="ln2263">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5762)</a>
<a name="ln2264">		limit = 2;</a>
<a name="ln2265">	else if (BGE_IS_5717_PLUS(sc))</a>
<a name="ln2266">		limit = 4;</a>
<a name="ln2267">	else</a>
<a name="ln2268">		limit = 1;</a>
<a name="ln2269">	vrcb = BGE_MEMWIN_START + BGE_SEND_RING_RCB;</a>
<a name="ln2270">	for (i = 0; i &lt; limit; i++) {</a>
<a name="ln2271">		RCB_WRITE_4(sc, vrcb, bge_maxlen_flags,</a>
<a name="ln2272">		    BGE_RCB_MAXLEN_FLAGS(0, BGE_RCB_FLAG_RING_DISABLED));</a>
<a name="ln2273">		RCB_WRITE_4(sc, vrcb, bge_nicaddr, 0);</a>
<a name="ln2274">		vrcb += sizeof(struct bge_rcb);</a>
<a name="ln2275">	}</a>
<a name="ln2276"> </a>
<a name="ln2277">	/* Configure send ring RCB 0 (we use only the first ring) */</a>
<a name="ln2278">	vrcb = BGE_MEMWIN_START + BGE_SEND_RING_RCB;</a>
<a name="ln2279">	BGE_HOSTADDR(taddr, sc-&gt;bge_ldata.bge_tx_ring_paddr);</a>
<a name="ln2280">	RCB_WRITE_4(sc, vrcb, bge_hostaddr.bge_addr_hi, taddr.bge_addr_hi);</a>
<a name="ln2281">	RCB_WRITE_4(sc, vrcb, bge_hostaddr.bge_addr_lo, taddr.bge_addr_lo);</a>
<a name="ln2282">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5717 ||</a>
<a name="ln2283">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5719 ||</a>
<a name="ln2284">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5720)</a>
<a name="ln2285">		RCB_WRITE_4(sc, vrcb, bge_nicaddr, BGE_SEND_RING_5717);</a>
<a name="ln2286">	else</a>
<a name="ln2287">		RCB_WRITE_4(sc, vrcb, bge_nicaddr,</a>
<a name="ln2288">		    BGE_NIC_TXRING_ADDR(0, BGE_TX_RING_CNT));</a>
<a name="ln2289">	RCB_WRITE_4(sc, vrcb, bge_maxlen_flags,</a>
<a name="ln2290">	    BGE_RCB_MAXLEN_FLAGS(BGE_TX_RING_CNT, 0));</a>
<a name="ln2291"> </a>
<a name="ln2292">	/*</a>
<a name="ln2293">	 * Disable all receive return rings by setting the</a>
<a name="ln2294">	 * 'ring diabled' bit in the flags field of all the receive</a>
<a name="ln2295">	 * return ring control blocks, located in NIC memory.</a>
<a name="ln2296">	 */</a>
<a name="ln2297">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5717 ||</a>
<a name="ln2298">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5719 ||</a>
<a name="ln2299">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5720) {</a>
<a name="ln2300">		/* Should be 17, use 16 until we get an SRAM map. */</a>
<a name="ln2301">		limit = 16;</a>
<a name="ln2302">	} else if (!BGE_IS_5705_PLUS(sc))</a>
<a name="ln2303">		limit = BGE_RX_RINGS_MAX;</a>
<a name="ln2304">	else if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5755 ||</a>
<a name="ln2305">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5762 ||</a>
<a name="ln2306">	    BGE_IS_57765_PLUS(sc))</a>
<a name="ln2307">		limit = 4;</a>
<a name="ln2308">	else</a>
<a name="ln2309">		limit = 1;</a>
<a name="ln2310">	/* Disable all receive return rings. */</a>
<a name="ln2311">	vrcb = BGE_MEMWIN_START + BGE_RX_RETURN_RING_RCB;</a>
<a name="ln2312">	for (i = 0; i &lt; limit; i++) {</a>
<a name="ln2313">		RCB_WRITE_4(sc, vrcb, bge_hostaddr.bge_addr_hi, 0);</a>
<a name="ln2314">		RCB_WRITE_4(sc, vrcb, bge_hostaddr.bge_addr_lo, 0);</a>
<a name="ln2315">		RCB_WRITE_4(sc, vrcb, bge_maxlen_flags,</a>
<a name="ln2316">		    BGE_RCB_FLAG_RING_DISABLED);</a>
<a name="ln2317">		RCB_WRITE_4(sc, vrcb, bge_nicaddr, 0);</a>
<a name="ln2318">		bge_writembx(sc, BGE_MBX_RX_CONS0_LO +</a>
<a name="ln2319">		    (i * (sizeof(uint64_t))), 0);</a>
<a name="ln2320">		vrcb += sizeof(struct bge_rcb);</a>
<a name="ln2321">	}</a>
<a name="ln2322"> </a>
<a name="ln2323">	/*</a>
<a name="ln2324">	 * Set up receive return ring 0.  Note that the NIC address</a>
<a name="ln2325">	 * for RX return rings is 0x0.  The return rings live entirely</a>
<a name="ln2326">	 * within the host, so the nicaddr field in the RCB isn't used.</a>
<a name="ln2327">	 */</a>
<a name="ln2328">	vrcb = BGE_MEMWIN_START + BGE_RX_RETURN_RING_RCB;</a>
<a name="ln2329">	BGE_HOSTADDR(taddr, sc-&gt;bge_ldata.bge_rx_return_ring_paddr);</a>
<a name="ln2330">	RCB_WRITE_4(sc, vrcb, bge_hostaddr.bge_addr_hi, taddr.bge_addr_hi);</a>
<a name="ln2331">	RCB_WRITE_4(sc, vrcb, bge_hostaddr.bge_addr_lo, taddr.bge_addr_lo);</a>
<a name="ln2332">	RCB_WRITE_4(sc, vrcb, bge_nicaddr, 0);</a>
<a name="ln2333">	RCB_WRITE_4(sc, vrcb, bge_maxlen_flags,</a>
<a name="ln2334">	    BGE_RCB_MAXLEN_FLAGS(sc-&gt;bge_return_ring_cnt, 0));</a>
<a name="ln2335"> </a>
<a name="ln2336">	/* Set random backoff seed for TX */</a>
<a name="ln2337">	CSR_WRITE_4(sc, BGE_TX_RANDOM_BACKOFF,</a>
<a name="ln2338">	    (IF_LLADDR(sc-&gt;bge_ifp)[0] + IF_LLADDR(sc-&gt;bge_ifp)[1] +</a>
<a name="ln2339">	    IF_LLADDR(sc-&gt;bge_ifp)[2] + IF_LLADDR(sc-&gt;bge_ifp)[3] +</a>
<a name="ln2340">	    IF_LLADDR(sc-&gt;bge_ifp)[4] + IF_LLADDR(sc-&gt;bge_ifp)[5]) &amp;</a>
<a name="ln2341">	    BGE_TX_BACKOFF_SEED_MASK);</a>
<a name="ln2342"> </a>
<a name="ln2343">	/* Set inter-packet gap */</a>
<a name="ln2344">	val = 0x2620;</a>
<a name="ln2345">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5720 ||</a>
<a name="ln2346">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5762)</a>
<a name="ln2347">		val |= CSR_READ_4(sc, BGE_TX_LENGTHS) &amp;</a>
<a name="ln2348">		    (BGE_TXLEN_JMB_FRM_LEN_MSK | BGE_TXLEN_CNT_DN_VAL_MSK);</a>
<a name="ln2349">	CSR_WRITE_4(sc, BGE_TX_LENGTHS, val);</a>
<a name="ln2350"> </a>
<a name="ln2351">	/*</a>
<a name="ln2352">	 * Specify which ring to use for packets that don't match</a>
<a name="ln2353">	 * any RX rules.</a>
<a name="ln2354">	 */</a>
<a name="ln2355">	CSR_WRITE_4(sc, BGE_RX_RULES_CFG, 0x08);</a>
<a name="ln2356"> </a>
<a name="ln2357">	/*</a>
<a name="ln2358">	 * Configure number of RX lists. One interrupt distribution</a>
<a name="ln2359">	 * list, sixteen active lists, one bad frames class.</a>
<a name="ln2360">	 */</a>
<a name="ln2361">	CSR_WRITE_4(sc, BGE_RXLP_CFG, 0x181);</a>
<a name="ln2362"> </a>
<a name="ln2363">	/* Inialize RX list placement stats mask. */</a>
<a name="ln2364">	CSR_WRITE_4(sc, BGE_RXLP_STATS_ENABLE_MASK, 0x007FFFFF);</a>
<a name="ln2365">	CSR_WRITE_4(sc, BGE_RXLP_STATS_CTL, 0x1);</a>
<a name="ln2366"> </a>
<a name="ln2367">	/* Disable host coalescing until we get it set up */</a>
<a name="ln2368">	CSR_WRITE_4(sc, BGE_HCC_MODE, 0x00000000);</a>
<a name="ln2369"> </a>
<a name="ln2370">	/* Poll to make sure it's shut down. */</a>
<a name="ln2371">	for (i = 0; i &lt; BGE_TIMEOUT; i++) {</a>
<a name="ln2372">		DELAY(10);</a>
<a name="ln2373">		if (!(CSR_READ_4(sc, BGE_HCC_MODE) &amp; BGE_HCCMODE_ENABLE))</a>
<a name="ln2374">			break;</a>
<a name="ln2375">	}</a>
<a name="ln2376"> </a>
<a name="ln2377">	if (i == BGE_TIMEOUT) {</a>
<a name="ln2378">		device_printf(sc-&gt;bge_dev,</a>
<a name="ln2379">		    &quot;host coalescing engine failed to idle\n&quot;);</a>
<a name="ln2380">		return (ENXIO);</a>
<a name="ln2381">	}</a>
<a name="ln2382"> </a>
<a name="ln2383">	/* Set up host coalescing defaults */</a>
<a name="ln2384">	CSR_WRITE_4(sc, BGE_HCC_RX_COAL_TICKS, sc-&gt;bge_rx_coal_ticks);</a>
<a name="ln2385">	CSR_WRITE_4(sc, BGE_HCC_TX_COAL_TICKS, sc-&gt;bge_tx_coal_ticks);</a>
<a name="ln2386">	CSR_WRITE_4(sc, BGE_HCC_RX_MAX_COAL_BDS, sc-&gt;bge_rx_max_coal_bds);</a>
<a name="ln2387">	CSR_WRITE_4(sc, BGE_HCC_TX_MAX_COAL_BDS, sc-&gt;bge_tx_max_coal_bds);</a>
<a name="ln2388">	if (!(BGE_IS_5705_PLUS(sc))) {</a>
<a name="ln2389">		CSR_WRITE_4(sc, BGE_HCC_RX_COAL_TICKS_INT, 0);</a>
<a name="ln2390">		CSR_WRITE_4(sc, BGE_HCC_TX_COAL_TICKS_INT, 0);</a>
<a name="ln2391">	}</a>
<a name="ln2392">	CSR_WRITE_4(sc, BGE_HCC_RX_MAX_COAL_BDS_INT, 1);</a>
<a name="ln2393">	CSR_WRITE_4(sc, BGE_HCC_TX_MAX_COAL_BDS_INT, 1);</a>
<a name="ln2394"> </a>
<a name="ln2395">	/* Set up address of statistics block */</a>
<a name="ln2396">	if (!(BGE_IS_5705_PLUS(sc))) {</a>
<a name="ln2397">		CSR_WRITE_4(sc, BGE_HCC_STATS_ADDR_HI,</a>
<a name="ln2398">		    BGE_ADDR_HI(sc-&gt;bge_ldata.bge_stats_paddr));</a>
<a name="ln2399">		CSR_WRITE_4(sc, BGE_HCC_STATS_ADDR_LO,</a>
<a name="ln2400">		    BGE_ADDR_LO(sc-&gt;bge_ldata.bge_stats_paddr));</a>
<a name="ln2401">		CSR_WRITE_4(sc, BGE_HCC_STATS_BASEADDR, BGE_STATS_BLOCK);</a>
<a name="ln2402">		CSR_WRITE_4(sc, BGE_HCC_STATUSBLK_BASEADDR, BGE_STATUS_BLOCK);</a>
<a name="ln2403">		CSR_WRITE_4(sc, BGE_HCC_STATS_TICKS, sc-&gt;bge_stat_ticks);</a>
<a name="ln2404">	}</a>
<a name="ln2405"> </a>
<a name="ln2406">	/* Set up address of status block */</a>
<a name="ln2407">	CSR_WRITE_4(sc, BGE_HCC_STATUSBLK_ADDR_HI,</a>
<a name="ln2408">	    BGE_ADDR_HI(sc-&gt;bge_ldata.bge_status_block_paddr));</a>
<a name="ln2409">	CSR_WRITE_4(sc, BGE_HCC_STATUSBLK_ADDR_LO,</a>
<a name="ln2410">	    BGE_ADDR_LO(sc-&gt;bge_ldata.bge_status_block_paddr));</a>
<a name="ln2411"> </a>
<a name="ln2412">	/* Set up status block size. */</a>
<a name="ln2413">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5700 &amp;&amp;</a>
<a name="ln2414">	    sc-&gt;bge_chipid != BGE_CHIPID_BCM5700_C0) {</a>
<a name="ln2415">		val = BGE_STATBLKSZ_FULL;</a>
<a name="ln2416">		bzero(sc-&gt;bge_ldata.bge_status_block, BGE_STATUS_BLK_SZ);</a>
<a name="ln2417">	} else {</a>
<a name="ln2418">		val = BGE_STATBLKSZ_32BYTE;</a>
<a name="ln2419">		bzero(sc-&gt;bge_ldata.bge_status_block, 32);</a>
<a name="ln2420">	}</a>
<a name="ln2421">	bus_dmamap_sync(sc-&gt;bge_cdata.bge_status_tag,</a>
<a name="ln2422">	    sc-&gt;bge_cdata.bge_status_map,</a>
<a name="ln2423">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln2424"> </a>
<a name="ln2425">	/* Turn on host coalescing state machine */</a>
<a name="ln2426">	CSR_WRITE_4(sc, BGE_HCC_MODE, val | BGE_HCCMODE_ENABLE);</a>
<a name="ln2427"> </a>
<a name="ln2428">	/* Turn on RX BD completion state machine and enable attentions */</a>
<a name="ln2429">	CSR_WRITE_4(sc, BGE_RBDC_MODE,</a>
<a name="ln2430">	    BGE_RBDCMODE_ENABLE | BGE_RBDCMODE_ATTN);</a>
<a name="ln2431"> </a>
<a name="ln2432">	/* Turn on RX list placement state machine */</a>
<a name="ln2433">	CSR_WRITE_4(sc, BGE_RXLP_MODE, BGE_RXLPMODE_ENABLE);</a>
<a name="ln2434"> </a>
<a name="ln2435">	/* Turn on RX list selector state machine. */</a>
<a name="ln2436">	if (!(BGE_IS_5705_PLUS(sc)))</a>
<a name="ln2437">		CSR_WRITE_4(sc, BGE_RXLS_MODE, BGE_RXLSMODE_ENABLE);</a>
<a name="ln2438"> </a>
<a name="ln2439">	/* Turn on DMA, clear stats. */</a>
<a name="ln2440">	val = BGE_MACMODE_TXDMA_ENB | BGE_MACMODE_RXDMA_ENB |</a>
<a name="ln2441">	    BGE_MACMODE_RX_STATS_CLEAR | BGE_MACMODE_TX_STATS_CLEAR |</a>
<a name="ln2442">	    BGE_MACMODE_RX_STATS_ENB | BGE_MACMODE_TX_STATS_ENB |</a>
<a name="ln2443">	    BGE_MACMODE_FRMHDR_DMA_ENB;</a>
<a name="ln2444"> </a>
<a name="ln2445">	if (sc-&gt;bge_flags &amp; BGE_FLAG_TBI)</a>
<a name="ln2446">		val |= BGE_PORTMODE_TBI;</a>
<a name="ln2447">	else if (sc-&gt;bge_flags &amp; BGE_FLAG_MII_SERDES)</a>
<a name="ln2448">		val |= BGE_PORTMODE_GMII;</a>
<a name="ln2449">	else</a>
<a name="ln2450">		val |= BGE_PORTMODE_MII;</a>
<a name="ln2451"> </a>
<a name="ln2452">	/* Allow APE to send/receive frames. */</a>
<a name="ln2453">	if ((sc-&gt;bge_mfw_flags &amp; BGE_MFW_ON_APE) != 0)</a>
<a name="ln2454">		val |= BGE_MACMODE_APE_RX_EN | BGE_MACMODE_APE_TX_EN;</a>
<a name="ln2455"> </a>
<a name="ln2456">	CSR_WRITE_4(sc, BGE_MAC_MODE, val);</a>
<a name="ln2457">	DELAY(40);</a>
<a name="ln2458"> </a>
<a name="ln2459">	/* Set misc. local control, enable interrupts on attentions */</a>
<a name="ln2460">	BGE_SETBIT(sc, BGE_MISC_LOCAL_CTL, BGE_MLC_INTR_ONATTN);</a>
<a name="ln2461"> </a>
<a name="ln2462">#ifdef notdef</a>
<a name="ln2463">	/* Assert GPIO pins for PHY reset */</a>
<a name="ln2464">	BGE_SETBIT(sc, BGE_MISC_LOCAL_CTL, BGE_MLC_MISCIO_OUT0 |</a>
<a name="ln2465">	    BGE_MLC_MISCIO_OUT1 | BGE_MLC_MISCIO_OUT2);</a>
<a name="ln2466">	BGE_SETBIT(sc, BGE_MISC_LOCAL_CTL, BGE_MLC_MISCIO_OUTEN0 |</a>
<a name="ln2467">	    BGE_MLC_MISCIO_OUTEN1 | BGE_MLC_MISCIO_OUTEN2);</a>
<a name="ln2468">#endif</a>
<a name="ln2469"> </a>
<a name="ln2470">	/* Turn on DMA completion state machine */</a>
<a name="ln2471">	if (!(BGE_IS_5705_PLUS(sc)))</a>
<a name="ln2472">		CSR_WRITE_4(sc, BGE_DMAC_MODE, BGE_DMACMODE_ENABLE);</a>
<a name="ln2473"> </a>
<a name="ln2474">	val = BGE_WDMAMODE_ENABLE | BGE_WDMAMODE_ALL_ATTNS;</a>
<a name="ln2475"> </a>
<a name="ln2476">	/* Enable host coalescing bug fix. */</a>
<a name="ln2477">	if (BGE_IS_5755_PLUS(sc))</a>
<a name="ln2478">		val |= BGE_WDMAMODE_STATUS_TAG_FIX;</a>
<a name="ln2479"> </a>
<a name="ln2480">	/* Request larger DMA burst size to get better performance. */</a>
<a name="ln2481">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5785)</a>
<a name="ln2482">		val |= BGE_WDMAMODE_BURST_ALL_DATA;</a>
<a name="ln2483"> </a>
<a name="ln2484">	/* Turn on write DMA state machine */</a>
<a name="ln2485">	CSR_WRITE_4(sc, BGE_WDMA_MODE, val);</a>
<a name="ln2486">	DELAY(40);</a>
<a name="ln2487"> </a>
<a name="ln2488">	/* Turn on read DMA state machine */</a>
<a name="ln2489">	val = BGE_RDMAMODE_ENABLE | BGE_RDMAMODE_ALL_ATTNS;</a>
<a name="ln2490"> </a>
<a name="ln2491">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5717)</a>
<a name="ln2492">		val |= BGE_RDMAMODE_MULT_DMA_RD_DIS;</a>
<a name="ln2493"> </a>
<a name="ln2494">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5784 ||</a>
<a name="ln2495">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5785 ||</a>
<a name="ln2496">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM57780)</a>
<a name="ln2497">		val |= BGE_RDMAMODE_BD_SBD_CRPT_ATTN |</a>
<a name="ln2498">		    BGE_RDMAMODE_MBUF_RBD_CRPT_ATTN |</a>
<a name="ln2499">		    BGE_RDMAMODE_MBUF_SBD_CRPT_ATTN;</a>
<a name="ln2500">	if (sc-&gt;bge_flags &amp; BGE_FLAG_PCIE)</a>
<a name="ln2501">		val |= BGE_RDMAMODE_FIFO_LONG_BURST;</a>
<a name="ln2502">	if (sc-&gt;bge_flags &amp; (BGE_FLAG_TSO | BGE_FLAG_TSO3)) {</a>
<a name="ln2503">		val |= BGE_RDMAMODE_TSO4_ENABLE;</a>
<a name="ln2504">		if (sc-&gt;bge_flags &amp; BGE_FLAG_TSO3 ||</a>
<a name="ln2505">		    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5785 ||</a>
<a name="ln2506">		    sc-&gt;bge_asicrev == BGE_ASICREV_BCM57780)</a>
<a name="ln2507">			val |= BGE_RDMAMODE_TSO6_ENABLE;</a>
<a name="ln2508">	}</a>
<a name="ln2509"> </a>
<a name="ln2510">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5720 ||</a>
<a name="ln2511">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5762) {</a>
<a name="ln2512">		val |= CSR_READ_4(sc, BGE_RDMA_MODE) &amp;</a>
<a name="ln2513">			BGE_RDMAMODE_H2BNC_VLAN_DET;</a>
<a name="ln2514">		/*</a>
<a name="ln2515">		 * Allow multiple outstanding read requests from</a>
<a name="ln2516">		 * non-LSO read DMA engine.</a>
<a name="ln2517">		 */</a>
<a name="ln2518">		val &amp;= ~BGE_RDMAMODE_MULT_DMA_RD_DIS;</a>
<a name="ln2519">	}</a>
<a name="ln2520"> </a>
<a name="ln2521">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5761 ||</a>
<a name="ln2522">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5784 ||</a>
<a name="ln2523">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5785 ||</a>
<a name="ln2524">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM57780 ||</a>
<a name="ln2525">	    BGE_IS_5717_PLUS(sc) || BGE_IS_57765_PLUS(sc)) {</a>
<a name="ln2526">		if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5762)</a>
<a name="ln2527">			rdmareg = BGE_RDMA_RSRVCTRL_REG2;</a>
<a name="ln2528">		else</a>
<a name="ln2529">			rdmareg = BGE_RDMA_RSRVCTRL;</a>
<a name="ln2530">		dmactl = CSR_READ_4(sc, rdmareg);</a>
<a name="ln2531">		/*</a>
<a name="ln2532">		 * Adjust tx margin to prevent TX data corruption and</a>
<a name="ln2533">		 * fix internal FIFO overflow.</a>
<a name="ln2534">		 */</a>
<a name="ln2535">		if (sc-&gt;bge_chipid == BGE_CHIPID_BCM5719_A0 ||</a>
<a name="ln2536">		    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5762) {</a>
<a name="ln2537">			dmactl &amp;= ~(BGE_RDMA_RSRVCTRL_FIFO_LWM_MASK |</a>
<a name="ln2538">			    BGE_RDMA_RSRVCTRL_FIFO_HWM_MASK |</a>
<a name="ln2539">			    BGE_RDMA_RSRVCTRL_TXMRGN_MASK);</a>
<a name="ln2540">			dmactl |= BGE_RDMA_RSRVCTRL_FIFO_LWM_1_5K |</a>
<a name="ln2541">			    BGE_RDMA_RSRVCTRL_FIFO_HWM_1_5K |</a>
<a name="ln2542">			    BGE_RDMA_RSRVCTRL_TXMRGN_320B;</a>
<a name="ln2543">		}</a>
<a name="ln2544">		/*</a>
<a name="ln2545">		 * Enable fix for read DMA FIFO overruns.</a>
<a name="ln2546">		 * The fix is to limit the number of RX BDs</a>
<a name="ln2547">		 * the hardware would fetch at a fime.</a>
<a name="ln2548">		 */</a>
<a name="ln2549">		CSR_WRITE_4(sc, rdmareg, dmactl |</a>
<a name="ln2550">		    BGE_RDMA_RSRVCTRL_FIFO_OFLW_FIX);</a>
<a name="ln2551">	}</a>
<a name="ln2552"> </a>
<a name="ln2553">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5719) {</a>
<a name="ln2554">		CSR_WRITE_4(sc, BGE_RDMA_LSO_CRPTEN_CTRL,</a>
<a name="ln2555">		    CSR_READ_4(sc, BGE_RDMA_LSO_CRPTEN_CTRL) |</a>
<a name="ln2556">		    BGE_RDMA_LSO_CRPTEN_CTRL_BLEN_BD_4K |</a>
<a name="ln2557">		    BGE_RDMA_LSO_CRPTEN_CTRL_BLEN_LSO_4K);</a>
<a name="ln2558">	} else if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5720) {</a>
<a name="ln2559">		/*</a>
<a name="ln2560">		 * Allow 4KB burst length reads for non-LSO frames.</a>
<a name="ln2561">		 * Enable 512B burst length reads for buffer descriptors.</a>
<a name="ln2562">		 */</a>
<a name="ln2563">		CSR_WRITE_4(sc, BGE_RDMA_LSO_CRPTEN_CTRL,</a>
<a name="ln2564">		    CSR_READ_4(sc, BGE_RDMA_LSO_CRPTEN_CTRL) |</a>
<a name="ln2565">		    BGE_RDMA_LSO_CRPTEN_CTRL_BLEN_BD_512 |</a>
<a name="ln2566">		    BGE_RDMA_LSO_CRPTEN_CTRL_BLEN_LSO_4K);</a>
<a name="ln2567">	} else if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5762) {</a>
<a name="ln2568">		CSR_WRITE_4(sc, BGE_RDMA_LSO_CRPTEN_CTRL_REG2,</a>
<a name="ln2569">		    CSR_READ_4(sc, BGE_RDMA_LSO_CRPTEN_CTRL_REG2) |</a>
<a name="ln2570">		    BGE_RDMA_LSO_CRPTEN_CTRL_BLEN_BD_4K |</a>
<a name="ln2571">		    BGE_RDMA_LSO_CRPTEN_CTRL_BLEN_LSO_4K);</a>
<a name="ln2572">	}</a>
<a name="ln2573"> </a>
<a name="ln2574">	CSR_WRITE_4(sc, BGE_RDMA_MODE, val);</a>
<a name="ln2575">	DELAY(40);</a>
<a name="ln2576"> </a>
<a name="ln2577">	if (sc-&gt;bge_flags &amp; BGE_FLAG_RDMA_BUG) {</a>
<a name="ln2578">		for (i = 0; i &lt; BGE_NUM_RDMA_CHANNELS / 2; i++) {</a>
<a name="ln2579">			val = CSR_READ_4(sc, BGE_RDMA_LENGTH + i * 4);</a>
<a name="ln2580">			if ((val &amp; 0xFFFF) &gt; BGE_FRAMELEN)</a>
<a name="ln2581">				break;</a>
<a name="ln2582">			if (((val &gt;&gt; 16) &amp; 0xFFFF) &gt; BGE_FRAMELEN)</a>
<a name="ln2583">				break;</a>
<a name="ln2584">		}</a>
<a name="ln2585">		if (i != BGE_NUM_RDMA_CHANNELS / 2) {</a>
<a name="ln2586">			val = CSR_READ_4(sc, BGE_RDMA_LSO_CRPTEN_CTRL);</a>
<a name="ln2587">			if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5719)</a>
<a name="ln2588">				val |= BGE_RDMA_TX_LENGTH_WA_5719;</a>
<a name="ln2589">			else</a>
<a name="ln2590">				val |= BGE_RDMA_TX_LENGTH_WA_5720;</a>
<a name="ln2591">			CSR_WRITE_4(sc, BGE_RDMA_LSO_CRPTEN_CTRL, val);</a>
<a name="ln2592">		}</a>
<a name="ln2593">	}</a>
<a name="ln2594"> </a>
<a name="ln2595">	/* Turn on RX data completion state machine */</a>
<a name="ln2596">	CSR_WRITE_4(sc, BGE_RDC_MODE, BGE_RDCMODE_ENABLE);</a>
<a name="ln2597"> </a>
<a name="ln2598">	/* Turn on RX BD initiator state machine */</a>
<a name="ln2599">	CSR_WRITE_4(sc, BGE_RBDI_MODE, BGE_RBDIMODE_ENABLE);</a>
<a name="ln2600"> </a>
<a name="ln2601">	/* Turn on RX data and RX BD initiator state machine */</a>
<a name="ln2602">	CSR_WRITE_4(sc, BGE_RDBDI_MODE, BGE_RDBDIMODE_ENABLE);</a>
<a name="ln2603"> </a>
<a name="ln2604">	/* Turn on Mbuf cluster free state machine */</a>
<a name="ln2605">	if (!(BGE_IS_5705_PLUS(sc)))</a>
<a name="ln2606">		CSR_WRITE_4(sc, BGE_MBCF_MODE, BGE_MBCFMODE_ENABLE);</a>
<a name="ln2607"> </a>
<a name="ln2608">	/* Turn on send BD completion state machine */</a>
<a name="ln2609">	CSR_WRITE_4(sc, BGE_SBDC_MODE, BGE_SBDCMODE_ENABLE);</a>
<a name="ln2610"> </a>
<a name="ln2611">	/* Turn on send data completion state machine */</a>
<a name="ln2612">	val = BGE_SDCMODE_ENABLE;</a>
<a name="ln2613">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5761)</a>
<a name="ln2614">		val |= BGE_SDCMODE_CDELAY;</a>
<a name="ln2615">	CSR_WRITE_4(sc, BGE_SDC_MODE, val);</a>
<a name="ln2616"> </a>
<a name="ln2617">	/* Turn on send data initiator state machine */</a>
<a name="ln2618">	if (sc-&gt;bge_flags &amp; (BGE_FLAG_TSO | BGE_FLAG_TSO3))</a>
<a name="ln2619">		CSR_WRITE_4(sc, BGE_SDI_MODE, BGE_SDIMODE_ENABLE |</a>
<a name="ln2620">		    BGE_SDIMODE_HW_LSO_PRE_DMA);</a>
<a name="ln2621">	else</a>
<a name="ln2622">		CSR_WRITE_4(sc, BGE_SDI_MODE, BGE_SDIMODE_ENABLE);</a>
<a name="ln2623"> </a>
<a name="ln2624">	/* Turn on send BD initiator state machine */</a>
<a name="ln2625">	CSR_WRITE_4(sc, BGE_SBDI_MODE, BGE_SBDIMODE_ENABLE);</a>
<a name="ln2626"> </a>
<a name="ln2627">	/* Turn on send BD selector state machine */</a>
<a name="ln2628">	CSR_WRITE_4(sc, BGE_SRS_MODE, BGE_SRSMODE_ENABLE);</a>
<a name="ln2629"> </a>
<a name="ln2630">	CSR_WRITE_4(sc, BGE_SDI_STATS_ENABLE_MASK, 0x007FFFFF);</a>
<a name="ln2631">	CSR_WRITE_4(sc, BGE_SDI_STATS_CTL,</a>
<a name="ln2632">	    BGE_SDISTATSCTL_ENABLE | BGE_SDISTATSCTL_FASTER);</a>
<a name="ln2633"> </a>
<a name="ln2634">	/* ack/clear link change events */</a>
<a name="ln2635">	CSR_WRITE_4(sc, BGE_MAC_STS, BGE_MACSTAT_SYNC_CHANGED |</a>
<a name="ln2636">	    BGE_MACSTAT_CFG_CHANGED | BGE_MACSTAT_MI_COMPLETE |</a>
<a name="ln2637">	    BGE_MACSTAT_LINK_CHANGED);</a>
<a name="ln2638">	CSR_WRITE_4(sc, BGE_MI_STS, 0);</a>
<a name="ln2639"> </a>
<a name="ln2640">	/*</a>
<a name="ln2641">	 * Enable attention when the link has changed state for</a>
<a name="ln2642">	 * devices that use auto polling.</a>
<a name="ln2643">	 */</a>
<a name="ln2644">	if (sc-&gt;bge_flags &amp; BGE_FLAG_TBI) {</a>
<a name="ln2645">		CSR_WRITE_4(sc, BGE_MI_STS, BGE_MISTS_LINK);</a>
<a name="ln2646">	} else {</a>
<a name="ln2647">		if (sc-&gt;bge_mi_mode &amp; BGE_MIMODE_AUTOPOLL) {</a>
<a name="ln2648">			CSR_WRITE_4(sc, BGE_MI_MODE, sc-&gt;bge_mi_mode);</a>
<a name="ln2649">			DELAY(80);</a>
<a name="ln2650">		}</a>
<a name="ln2651">		if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5700 &amp;&amp;</a>
<a name="ln2652">		    sc-&gt;bge_chipid != BGE_CHIPID_BCM5700_B2)</a>
<a name="ln2653">			CSR_WRITE_4(sc, BGE_MAC_EVT_ENB,</a>
<a name="ln2654">			    BGE_EVTENB_MI_INTERRUPT);</a>
<a name="ln2655">	}</a>
<a name="ln2656"> </a>
<a name="ln2657">	/*</a>
<a name="ln2658">	 * Clear any pending link state attention.</a>
<a name="ln2659">	 * Otherwise some link state change events may be lost until attention</a>
<a name="ln2660">	 * is cleared by bge_intr() -&gt; bge_link_upd() sequence.</a>
<a name="ln2661">	 * It's not necessary on newer BCM chips - perhaps enabling link</a>
<a name="ln2662">	 * state change attentions implies clearing pending attention.</a>
<a name="ln2663">	 */</a>
<a name="ln2664">	CSR_WRITE_4(sc, BGE_MAC_STS, BGE_MACSTAT_SYNC_CHANGED |</a>
<a name="ln2665">	    BGE_MACSTAT_CFG_CHANGED | BGE_MACSTAT_MI_COMPLETE |</a>
<a name="ln2666">	    BGE_MACSTAT_LINK_CHANGED);</a>
<a name="ln2667"> </a>
<a name="ln2668">	/* Enable link state change attentions. */</a>
<a name="ln2669">	BGE_SETBIT(sc, BGE_MAC_EVT_ENB, BGE_EVTENB_LINK_CHANGED);</a>
<a name="ln2670"> </a>
<a name="ln2671">	return (0);</a>
<a name="ln2672">}</a>
<a name="ln2673"> </a>
<a name="ln2674">static const struct bge_revision *</a>
<a name="ln2675">bge_lookup_rev(uint32_t chipid)</a>
<a name="ln2676">{</a>
<a name="ln2677">	const struct bge_revision *br;</a>
<a name="ln2678"> </a>
<a name="ln2679">	for (br = bge_revisions; br-&gt;br_name != NULL; br++) {</a>
<a name="ln2680">		if (br-&gt;br_chipid == chipid)</a>
<a name="ln2681">			return (br);</a>
<a name="ln2682">	}</a>
<a name="ln2683"> </a>
<a name="ln2684">	for (br = bge_majorrevs; br-&gt;br_name != NULL; br++) {</a>
<a name="ln2685">		if (br-&gt;br_chipid == BGE_ASICREV(chipid))</a>
<a name="ln2686">			return (br);</a>
<a name="ln2687">	}</a>
<a name="ln2688"> </a>
<a name="ln2689">	return (NULL);</a>
<a name="ln2690">}</a>
<a name="ln2691"> </a>
<a name="ln2692">static const struct bge_vendor *</a>
<a name="ln2693">bge_lookup_vendor(uint16_t vid)</a>
<a name="ln2694">{</a>
<a name="ln2695">	const struct bge_vendor *v;</a>
<a name="ln2696"> </a>
<a name="ln2697">	for (v = bge_vendors; v-&gt;v_name != NULL; v++)</a>
<a name="ln2698">		if (v-&gt;v_id == vid)</a>
<a name="ln2699">			return (v);</a>
<a name="ln2700"> </a>
<a name="ln2701">	return (NULL);</a>
<a name="ln2702">}</a>
<a name="ln2703"> </a>
<a name="ln2704">static uint32_t</a>
<a name="ln2705">bge_chipid(device_t dev)</a>
<a name="ln2706">{</a>
<a name="ln2707">	uint32_t id;</a>
<a name="ln2708"> </a>
<a name="ln2709">	id = pci_read_config(dev, BGE_PCI_MISC_CTL, 4) &gt;&gt;</a>
<a name="ln2710">	    BGE_PCIMISCCTL_ASICREV_SHIFT;</a>
<a name="ln2711">	if (BGE_ASICREV(id) == BGE_ASICREV_USE_PRODID_REG) {</a>
<a name="ln2712">		/*</a>
<a name="ln2713">		 * Find the ASCI revision.  Different chips use different</a>
<a name="ln2714">		 * registers.</a>
<a name="ln2715">		 */</a>
<a name="ln2716">		switch (pci_get_device(dev)) {</a>
<a name="ln2717">		case BCOM_DEVICEID_BCM5717C:</a>
<a name="ln2718">			/* 5717 C0 seems to belong to 5720 line. */</a>
<a name="ln2719">			id = BGE_CHIPID_BCM5720_A0;</a>
<a name="ln2720">			break;</a>
<a name="ln2721">		case BCOM_DEVICEID_BCM5717:</a>
<a name="ln2722">		case BCOM_DEVICEID_BCM5718:</a>
<a name="ln2723">		case BCOM_DEVICEID_BCM5719:</a>
<a name="ln2724">		case BCOM_DEVICEID_BCM5720:</a>
<a name="ln2725">		case BCOM_DEVICEID_BCM5725:</a>
<a name="ln2726">		case BCOM_DEVICEID_BCM5727:</a>
<a name="ln2727">		case BCOM_DEVICEID_BCM5762:</a>
<a name="ln2728">		case BCOM_DEVICEID_BCM57764:</a>
<a name="ln2729">		case BCOM_DEVICEID_BCM57767:</a>
<a name="ln2730">		case BCOM_DEVICEID_BCM57787:</a>
<a name="ln2731">			id = pci_read_config(dev,</a>
<a name="ln2732">			    BGE_PCI_GEN2_PRODID_ASICREV, 4);</a>
<a name="ln2733">			break;</a>
<a name="ln2734">		case BCOM_DEVICEID_BCM57761:</a>
<a name="ln2735">		case BCOM_DEVICEID_BCM57762:</a>
<a name="ln2736">		case BCOM_DEVICEID_BCM57765:</a>
<a name="ln2737">		case BCOM_DEVICEID_BCM57766:</a>
<a name="ln2738">		case BCOM_DEVICEID_BCM57781:</a>
<a name="ln2739">		case BCOM_DEVICEID_BCM57782:</a>
<a name="ln2740">		case BCOM_DEVICEID_BCM57785:</a>
<a name="ln2741">		case BCOM_DEVICEID_BCM57786:</a>
<a name="ln2742">		case BCOM_DEVICEID_BCM57791:</a>
<a name="ln2743">		case BCOM_DEVICEID_BCM57795:</a>
<a name="ln2744">			id = pci_read_config(dev,</a>
<a name="ln2745">			    BGE_PCI_GEN15_PRODID_ASICREV, 4);</a>
<a name="ln2746">			break;</a>
<a name="ln2747">		default:</a>
<a name="ln2748">			id = pci_read_config(dev, BGE_PCI_PRODID_ASICREV, 4);</a>
<a name="ln2749">		}</a>
<a name="ln2750">	}</a>
<a name="ln2751">	return (id);</a>
<a name="ln2752">}</a>
<a name="ln2753"> </a>
<a name="ln2754">/*</a>
<a name="ln2755"> * Probe for a Broadcom chip. Check the PCI vendor and device IDs</a>
<a name="ln2756"> * against our list and return its name if we find a match.</a>
<a name="ln2757"> *</a>
<a name="ln2758"> * Note that since the Broadcom controller contains VPD support, we</a>
<a name="ln2759"> * try to get the device name string from the controller itself instead</a>
<a name="ln2760"> * of the compiled-in string. It guarantees we'll always announce the</a>
<a name="ln2761"> * right product name. We fall back to the compiled-in string when</a>
<a name="ln2762"> * VPD is unavailable or corrupt.</a>
<a name="ln2763"> */</a>
<a name="ln2764">static int</a>
<a name="ln2765">bge_probe(device_t dev)</a>
<a name="ln2766">{</a>
<a name="ln2767">	char buf[96];</a>
<a name="ln2768">	char model[64];</a>
<a name="ln2769">	const struct bge_revision *br;</a>
<a name="ln2770">	const char *pname;</a>
<a name="ln2771">	struct bge_softc *sc;</a>
<a name="ln2772">	const struct bge_type *t = bge_devs;</a>
<a name="ln2773">	const struct bge_vendor *v;</a>
<a name="ln2774">	uint32_t id;</a>
<a name="ln2775">	uint16_t did, vid;</a>
<a name="ln2776"> </a>
<a name="ln2777">	sc = device_get_softc(dev);</a>
<a name="ln2778">	sc-&gt;bge_dev = dev;</a>
<a name="ln2779">	vid = pci_get_vendor(dev);</a>
<a name="ln2780">	did = pci_get_device(dev);</a>
<a name="ln2781">	while(t-&gt;bge_vid != 0) {</a>
<a name="ln2782">		if ((vid == t-&gt;bge_vid) &amp;&amp; (did == t-&gt;bge_did)) {</a>
<a name="ln2783">			id = bge_chipid(dev);</a>
<a name="ln2784">			br = bge_lookup_rev(id);</a>
<a name="ln2785">			if (bge_has_eaddr(sc) &amp;&amp;</a>
<a name="ln2786">			    pci_get_vpd_ident(dev, &amp;pname) == 0)</a>
<a name="ln2787">				snprintf(model, sizeof(model), &quot;%s&quot;, pname);</a>
<a name="ln2788">			else {</a>
<a name="ln2789">				v = bge_lookup_vendor(vid);</a>
<a name="ln2790">				snprintf(model, sizeof(model), &quot;%s %s&quot;,</a>
<a name="ln2791">				    v != NULL ? v-&gt;v_name : &quot;Unknown&quot;,</a>
<a name="ln2792">				    br != NULL ? br-&gt;br_name :</a>
<a name="ln2793">				    &quot;NetXtreme/NetLink Ethernet Controller&quot;);</a>
<a name="ln2794">			}</a>
<a name="ln2795">			snprintf(buf, sizeof(buf), &quot;%s, %sASIC rev. %#08x&quot;,</a>
<a name="ln2796">			    model, br != NULL ? &quot;&quot; : &quot;unknown &quot;, id);</a>
<a name="ln2797">			device_set_desc_copy(dev, buf);</a>
<a name="ln2798">			return (BUS_PROBE_DEFAULT);</a>
<a name="ln2799">		}</a>
<a name="ln2800">		t++;</a>
<a name="ln2801">	}</a>
<a name="ln2802"> </a>
<a name="ln2803">	return (ENXIO);</a>
<a name="ln2804">}</a>
<a name="ln2805"> </a>
<a name="ln2806">static void</a>
<a name="ln2807">bge_dma_free(struct bge_softc *sc)</a>
<a name="ln2808">{</a>
<a name="ln2809">	int i;</a>
<a name="ln2810"> </a>
<a name="ln2811">	/* Destroy DMA maps for RX buffers. */</a>
<a name="ln2812">	for (i = 0; i &lt; BGE_STD_RX_RING_CNT; i++) {</a>
<a name="ln2813">		if (sc-&gt;bge_cdata.bge_rx_std_dmamap[i])</a>
<a name="ln2814">			bus_dmamap_destroy(sc-&gt;bge_cdata.bge_rx_mtag,</a>
<a name="ln2815">			    sc-&gt;bge_cdata.bge_rx_std_dmamap[i]);</a>
<a name="ln2816">	}</a>
<a name="ln2817">	if (sc-&gt;bge_cdata.bge_rx_std_sparemap)</a>
<a name="ln2818">		bus_dmamap_destroy(sc-&gt;bge_cdata.bge_rx_mtag,</a>
<a name="ln2819">		    sc-&gt;bge_cdata.bge_rx_std_sparemap);</a>
<a name="ln2820"> </a>
<a name="ln2821">	/* Destroy DMA maps for jumbo RX buffers. */</a>
<a name="ln2822">	for (i = 0; i &lt; BGE_JUMBO_RX_RING_CNT; i++) {</a>
<a name="ln2823">		if (sc-&gt;bge_cdata.bge_rx_jumbo_dmamap[i])</a>
<a name="ln2824">			bus_dmamap_destroy(sc-&gt;bge_cdata.bge_mtag_jumbo,</a>
<a name="ln2825">			    sc-&gt;bge_cdata.bge_rx_jumbo_dmamap[i]);</a>
<a name="ln2826">	}</a>
<a name="ln2827">	if (sc-&gt;bge_cdata.bge_rx_jumbo_sparemap)</a>
<a name="ln2828">		bus_dmamap_destroy(sc-&gt;bge_cdata.bge_mtag_jumbo,</a>
<a name="ln2829">		    sc-&gt;bge_cdata.bge_rx_jumbo_sparemap);</a>
<a name="ln2830"> </a>
<a name="ln2831">	/* Destroy DMA maps for TX buffers. */</a>
<a name="ln2832">	for (i = 0; i &lt; BGE_TX_RING_CNT; i++) {</a>
<a name="ln2833">		if (sc-&gt;bge_cdata.bge_tx_dmamap[i])</a>
<a name="ln2834">			bus_dmamap_destroy(sc-&gt;bge_cdata.bge_tx_mtag,</a>
<a name="ln2835">			    sc-&gt;bge_cdata.bge_tx_dmamap[i]);</a>
<a name="ln2836">	}</a>
<a name="ln2837"> </a>
<a name="ln2838">	if (sc-&gt;bge_cdata.bge_rx_mtag)</a>
<a name="ln2839">		bus_dma_tag_destroy(sc-&gt;bge_cdata.bge_rx_mtag);</a>
<a name="ln2840">	if (sc-&gt;bge_cdata.bge_mtag_jumbo)</a>
<a name="ln2841">		bus_dma_tag_destroy(sc-&gt;bge_cdata.bge_mtag_jumbo);</a>
<a name="ln2842">	if (sc-&gt;bge_cdata.bge_tx_mtag)</a>
<a name="ln2843">		bus_dma_tag_destroy(sc-&gt;bge_cdata.bge_tx_mtag);</a>
<a name="ln2844"> </a>
<a name="ln2845">	/* Destroy standard RX ring. */</a>
<a name="ln2846">	if (sc-&gt;bge_ldata.bge_rx_std_ring_paddr)</a>
<a name="ln2847">		bus_dmamap_unload(sc-&gt;bge_cdata.bge_rx_std_ring_tag,</a>
<a name="ln2848">		    sc-&gt;bge_cdata.bge_rx_std_ring_map);</a>
<a name="ln2849">	if (sc-&gt;bge_ldata.bge_rx_std_ring)</a>
<a name="ln2850">		bus_dmamem_free(sc-&gt;bge_cdata.bge_rx_std_ring_tag,</a>
<a name="ln2851">		    sc-&gt;bge_ldata.bge_rx_std_ring,</a>
<a name="ln2852">		    sc-&gt;bge_cdata.bge_rx_std_ring_map);</a>
<a name="ln2853"> </a>
<a name="ln2854">	if (sc-&gt;bge_cdata.bge_rx_std_ring_tag)</a>
<a name="ln2855">		bus_dma_tag_destroy(sc-&gt;bge_cdata.bge_rx_std_ring_tag);</a>
<a name="ln2856"> </a>
<a name="ln2857">	/* Destroy jumbo RX ring. */</a>
<a name="ln2858">	if (sc-&gt;bge_ldata.bge_rx_jumbo_ring_paddr)</a>
<a name="ln2859">		bus_dmamap_unload(sc-&gt;bge_cdata.bge_rx_jumbo_ring_tag,</a>
<a name="ln2860">		    sc-&gt;bge_cdata.bge_rx_jumbo_ring_map);</a>
<a name="ln2861"> </a>
<a name="ln2862">	if (sc-&gt;bge_ldata.bge_rx_jumbo_ring)</a>
<a name="ln2863">		bus_dmamem_free(sc-&gt;bge_cdata.bge_rx_jumbo_ring_tag,</a>
<a name="ln2864">		    sc-&gt;bge_ldata.bge_rx_jumbo_ring,</a>
<a name="ln2865">		    sc-&gt;bge_cdata.bge_rx_jumbo_ring_map);</a>
<a name="ln2866"> </a>
<a name="ln2867">	if (sc-&gt;bge_cdata.bge_rx_jumbo_ring_tag)</a>
<a name="ln2868">		bus_dma_tag_destroy(sc-&gt;bge_cdata.bge_rx_jumbo_ring_tag);</a>
<a name="ln2869"> </a>
<a name="ln2870">	/* Destroy RX return ring. */</a>
<a name="ln2871">	if (sc-&gt;bge_ldata.bge_rx_return_ring_paddr)</a>
<a name="ln2872">		bus_dmamap_unload(sc-&gt;bge_cdata.bge_rx_return_ring_tag,</a>
<a name="ln2873">		    sc-&gt;bge_cdata.bge_rx_return_ring_map);</a>
<a name="ln2874"> </a>
<a name="ln2875">	if (sc-&gt;bge_ldata.bge_rx_return_ring)</a>
<a name="ln2876">		bus_dmamem_free(sc-&gt;bge_cdata.bge_rx_return_ring_tag,</a>
<a name="ln2877">		    sc-&gt;bge_ldata.bge_rx_return_ring,</a>
<a name="ln2878">		    sc-&gt;bge_cdata.bge_rx_return_ring_map);</a>
<a name="ln2879"> </a>
<a name="ln2880">	if (sc-&gt;bge_cdata.bge_rx_return_ring_tag)</a>
<a name="ln2881">		bus_dma_tag_destroy(sc-&gt;bge_cdata.bge_rx_return_ring_tag);</a>
<a name="ln2882"> </a>
<a name="ln2883">	/* Destroy TX ring. */</a>
<a name="ln2884">	if (sc-&gt;bge_ldata.bge_tx_ring_paddr)</a>
<a name="ln2885">		bus_dmamap_unload(sc-&gt;bge_cdata.bge_tx_ring_tag,</a>
<a name="ln2886">		    sc-&gt;bge_cdata.bge_tx_ring_map);</a>
<a name="ln2887"> </a>
<a name="ln2888">	if (sc-&gt;bge_ldata.bge_tx_ring)</a>
<a name="ln2889">		bus_dmamem_free(sc-&gt;bge_cdata.bge_tx_ring_tag,</a>
<a name="ln2890">		    sc-&gt;bge_ldata.bge_tx_ring,</a>
<a name="ln2891">		    sc-&gt;bge_cdata.bge_tx_ring_map);</a>
<a name="ln2892"> </a>
<a name="ln2893">	if (sc-&gt;bge_cdata.bge_tx_ring_tag)</a>
<a name="ln2894">		bus_dma_tag_destroy(sc-&gt;bge_cdata.bge_tx_ring_tag);</a>
<a name="ln2895"> </a>
<a name="ln2896">	/* Destroy status block. */</a>
<a name="ln2897">	if (sc-&gt;bge_ldata.bge_status_block_paddr)</a>
<a name="ln2898">		bus_dmamap_unload(sc-&gt;bge_cdata.bge_status_tag,</a>
<a name="ln2899">		    sc-&gt;bge_cdata.bge_status_map);</a>
<a name="ln2900"> </a>
<a name="ln2901">	if (sc-&gt;bge_ldata.bge_status_block)</a>
<a name="ln2902">		bus_dmamem_free(sc-&gt;bge_cdata.bge_status_tag,</a>
<a name="ln2903">		    sc-&gt;bge_ldata.bge_status_block,</a>
<a name="ln2904">		    sc-&gt;bge_cdata.bge_status_map);</a>
<a name="ln2905"> </a>
<a name="ln2906">	if (sc-&gt;bge_cdata.bge_status_tag)</a>
<a name="ln2907">		bus_dma_tag_destroy(sc-&gt;bge_cdata.bge_status_tag);</a>
<a name="ln2908"> </a>
<a name="ln2909">	/* Destroy statistics block. */</a>
<a name="ln2910">	if (sc-&gt;bge_ldata.bge_stats_paddr)</a>
<a name="ln2911">		bus_dmamap_unload(sc-&gt;bge_cdata.bge_stats_tag,</a>
<a name="ln2912">		    sc-&gt;bge_cdata.bge_stats_map);</a>
<a name="ln2913"> </a>
<a name="ln2914">	if (sc-&gt;bge_ldata.bge_stats)</a>
<a name="ln2915">		bus_dmamem_free(sc-&gt;bge_cdata.bge_stats_tag,</a>
<a name="ln2916">		    sc-&gt;bge_ldata.bge_stats,</a>
<a name="ln2917">		    sc-&gt;bge_cdata.bge_stats_map);</a>
<a name="ln2918"> </a>
<a name="ln2919">	if (sc-&gt;bge_cdata.bge_stats_tag)</a>
<a name="ln2920">		bus_dma_tag_destroy(sc-&gt;bge_cdata.bge_stats_tag);</a>
<a name="ln2921"> </a>
<a name="ln2922">	if (sc-&gt;bge_cdata.bge_buffer_tag)</a>
<a name="ln2923">		bus_dma_tag_destroy(sc-&gt;bge_cdata.bge_buffer_tag);</a>
<a name="ln2924"> </a>
<a name="ln2925">	/* Destroy the parent tag. */</a>
<a name="ln2926">	if (sc-&gt;bge_cdata.bge_parent_tag)</a>
<a name="ln2927">		bus_dma_tag_destroy(sc-&gt;bge_cdata.bge_parent_tag);</a>
<a name="ln2928">}</a>
<a name="ln2929"> </a>
<a name="ln2930">static int</a>
<a name="ln2931">bge_dma_ring_alloc(struct bge_softc *sc, bus_size_t alignment,</a>
<a name="ln2932">    bus_size_t maxsize, bus_dma_tag_t *tag, uint8_t **ring, bus_dmamap_t *map,</a>
<a name="ln2933">    bus_addr_t *paddr, const char *msg)</a>
<a name="ln2934">{</a>
<a name="ln2935">	struct bge_dmamap_arg ctx;</a>
<a name="ln2936">	int error;</a>
<a name="ln2937"> </a>
<a name="ln2938">	error = bus_dma_tag_create(sc-&gt;bge_cdata.bge_parent_tag,</a>
<a name="ln2939">	    alignment, 0, BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR, NULL,</a>
<a name="ln2940">	    NULL, maxsize, 1, maxsize, 0, NULL, NULL, tag);</a>
<a name="ln2941">	if (error != 0) {</a>
<a name="ln2942">		device_printf(sc-&gt;bge_dev,</a>
<a name="ln2943">		    &quot;could not create %s dma tag\n&quot;, msg);</a>
<a name="ln2944">		return (ENOMEM);</a>
<a name="ln2945">	}</a>
<a name="ln2946">	/* Allocate DMA'able memory for ring. */</a>
<a name="ln2947">	error = bus_dmamem_alloc(*tag, (void **)ring,</a>
<a name="ln2948">	    BUS_DMA_NOWAIT | BUS_DMA_ZERO | BUS_DMA_COHERENT, map);</a>
<a name="ln2949">	if (error != 0) {</a>
<a name="ln2950">		device_printf(sc-&gt;bge_dev,</a>
<a name="ln2951">		    &quot;could not allocate DMA'able memory for %s\n&quot;, msg);</a>
<a name="ln2952">		return (ENOMEM);</a>
<a name="ln2953">	}</a>
<a name="ln2954">	/* Load the address of the ring. */</a>
<a name="ln2955">	ctx.bge_busaddr = 0;</a>
<a name="ln2956">	error = bus_dmamap_load(*tag, *map, *ring, maxsize, bge_dma_map_addr,</a>
<a name="ln2957">	    &amp;ctx, BUS_DMA_NOWAIT);</a>
<a name="ln2958">	if (error != 0) {</a>
<a name="ln2959">		device_printf(sc-&gt;bge_dev,</a>
<a name="ln2960">		    &quot;could not load DMA'able memory for %s\n&quot;, msg);</a>
<a name="ln2961">		return (ENOMEM);</a>
<a name="ln2962">	}</a>
<a name="ln2963">	*paddr = ctx.bge_busaddr;</a>
<a name="ln2964">	return (0);</a>
<a name="ln2965">}</a>
<a name="ln2966"> </a>
<a name="ln2967">static int</a>
<a name="ln2968">bge_dma_alloc(struct bge_softc *sc)</a>
<a name="ln2969">{</a>
<a name="ln2970">	bus_addr_t lowaddr;</a>
<a name="ln2971">	bus_size_t rxmaxsegsz, sbsz, txsegsz, txmaxsegsz;</a>
<a name="ln2972">	int i, error;</a>
<a name="ln2973"> </a>
<a name="ln2974">	lowaddr = BUS_SPACE_MAXADDR;</a>
<a name="ln2975">	if ((sc-&gt;bge_flags &amp; BGE_FLAG_40BIT_BUG) != 0)</a>
<a name="ln2976">		lowaddr = BGE_DMA_MAXADDR;</a>
<a name="ln2977">	/*</a>
<a name="ln2978">	 * Allocate the parent bus DMA tag appropriate for PCI.</a>
<a name="ln2979">	 */</a>
<a name="ln2980">	error = bus_dma_tag_create(bus_get_dma_tag(sc-&gt;bge_dev),</a>
<a name="ln2981">	    1, 0, lowaddr, BUS_SPACE_MAXADDR, NULL,</a>
<a name="ln2982">	    NULL, BUS_SPACE_MAXSIZE_32BIT, 0, BUS_SPACE_MAXSIZE_32BIT,</a>
<a name="ln2983">	    0, NULL, NULL, &amp;sc-&gt;bge_cdata.bge_parent_tag);</a>
<a name="ln2984">	if (error != 0) {</a>
<a name="ln2985">		device_printf(sc-&gt;bge_dev,</a>
<a name="ln2986">		    &quot;could not allocate parent dma tag\n&quot;);</a>
<a name="ln2987">		return (ENOMEM);</a>
<a name="ln2988">	}</a>
<a name="ln2989"> </a>
<a name="ln2990">	/* Create tag for standard RX ring. */</a>
<a name="ln2991">	error = bge_dma_ring_alloc(sc, PAGE_SIZE, BGE_STD_RX_RING_SZ,</a>
<a name="ln2992">	    &amp;sc-&gt;bge_cdata.bge_rx_std_ring_tag,</a>
<a name="ln2993">	    (uint8_t **)&amp;sc-&gt;bge_ldata.bge_rx_std_ring,</a>
<a name="ln2994">	    &amp;sc-&gt;bge_cdata.bge_rx_std_ring_map,</a>
<a name="ln2995">	    &amp;sc-&gt;bge_ldata.bge_rx_std_ring_paddr, &quot;RX ring&quot;);</a>
<a name="ln2996">	if (error)</a>
<a name="ln2997">		return (error);</a>
<a name="ln2998"> </a>
<a name="ln2999">	/* Create tag for RX return ring. */</a>
<a name="ln3000">	error = bge_dma_ring_alloc(sc, PAGE_SIZE, BGE_RX_RTN_RING_SZ(sc),</a>
<a name="ln3001">	    &amp;sc-&gt;bge_cdata.bge_rx_return_ring_tag,</a>
<a name="ln3002">	    (uint8_t **)&amp;sc-&gt;bge_ldata.bge_rx_return_ring,</a>
<a name="ln3003">	    &amp;sc-&gt;bge_cdata.bge_rx_return_ring_map,</a>
<a name="ln3004">	    &amp;sc-&gt;bge_ldata.bge_rx_return_ring_paddr, &quot;RX return ring&quot;);</a>
<a name="ln3005">	if (error)</a>
<a name="ln3006">		return (error);</a>
<a name="ln3007"> </a>
<a name="ln3008">	/* Create tag for TX ring. */</a>
<a name="ln3009">	error = bge_dma_ring_alloc(sc, PAGE_SIZE, BGE_TX_RING_SZ,</a>
<a name="ln3010">	    &amp;sc-&gt;bge_cdata.bge_tx_ring_tag,</a>
<a name="ln3011">	    (uint8_t **)&amp;sc-&gt;bge_ldata.bge_tx_ring,</a>
<a name="ln3012">	    &amp;sc-&gt;bge_cdata.bge_tx_ring_map,</a>
<a name="ln3013">	    &amp;sc-&gt;bge_ldata.bge_tx_ring_paddr, &quot;TX ring&quot;);</a>
<a name="ln3014">	if (error)</a>
<a name="ln3015">		return (error);</a>
<a name="ln3016"> </a>
<a name="ln3017">	/*</a>
<a name="ln3018">	 * Create tag for status block.</a>
<a name="ln3019">	 * Because we only use single Tx/Rx/Rx return ring, use</a>
<a name="ln3020">	 * minimum status block size except BCM5700 AX/BX which</a>
<a name="ln3021">	 * seems to want to see full status block size regardless</a>
<a name="ln3022">	 * of configured number of ring.</a>
<a name="ln3023">	 */</a>
<a name="ln3024">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5700 &amp;&amp;</a>
<a name="ln3025">	    sc-&gt;bge_chipid != BGE_CHIPID_BCM5700_C0)</a>
<a name="ln3026">		sbsz = BGE_STATUS_BLK_SZ;</a>
<a name="ln3027">	else</a>
<a name="ln3028">		sbsz = 32;</a>
<a name="ln3029">	error = bge_dma_ring_alloc(sc, PAGE_SIZE, sbsz,</a>
<a name="ln3030">	    &amp;sc-&gt;bge_cdata.bge_status_tag,</a>
<a name="ln3031">	    (uint8_t **)&amp;sc-&gt;bge_ldata.bge_status_block,</a>
<a name="ln3032">	    &amp;sc-&gt;bge_cdata.bge_status_map,</a>
<a name="ln3033">	    &amp;sc-&gt;bge_ldata.bge_status_block_paddr, &quot;status block&quot;);</a>
<a name="ln3034">	if (error)</a>
<a name="ln3035">		return (error);</a>
<a name="ln3036"> </a>
<a name="ln3037">	/* Create tag for statistics block. */</a>
<a name="ln3038">	error = bge_dma_ring_alloc(sc, PAGE_SIZE, BGE_STATS_SZ,</a>
<a name="ln3039">	    &amp;sc-&gt;bge_cdata.bge_stats_tag,</a>
<a name="ln3040">	    (uint8_t **)&amp;sc-&gt;bge_ldata.bge_stats,</a>
<a name="ln3041">	    &amp;sc-&gt;bge_cdata.bge_stats_map,</a>
<a name="ln3042">	    &amp;sc-&gt;bge_ldata.bge_stats_paddr, &quot;statistics block&quot;);</a>
<a name="ln3043">	if (error)</a>
<a name="ln3044">		return (error);</a>
<a name="ln3045"> </a>
<a name="ln3046">	/* Create tag for jumbo RX ring. */</a>
<a name="ln3047">	if (BGE_IS_JUMBO_CAPABLE(sc)) {</a>
<a name="ln3048">		error = bge_dma_ring_alloc(sc, PAGE_SIZE, BGE_JUMBO_RX_RING_SZ,</a>
<a name="ln3049">		    &amp;sc-&gt;bge_cdata.bge_rx_jumbo_ring_tag,</a>
<a name="ln3050">		    (uint8_t **)&amp;sc-&gt;bge_ldata.bge_rx_jumbo_ring,</a>
<a name="ln3051">		    &amp;sc-&gt;bge_cdata.bge_rx_jumbo_ring_map,</a>
<a name="ln3052">		    &amp;sc-&gt;bge_ldata.bge_rx_jumbo_ring_paddr, &quot;jumbo RX ring&quot;);</a>
<a name="ln3053">		if (error)</a>
<a name="ln3054">			return (error);</a>
<a name="ln3055">	}</a>
<a name="ln3056"> </a>
<a name="ln3057">	/* Create parent tag for buffers. */</a>
<a name="ln3058">	if ((sc-&gt;bge_flags &amp; BGE_FLAG_4G_BNDRY_BUG) != 0) {</a>
<a name="ln3059">		/*</a>
<a name="ln3060">		 * XXX</a>
<a name="ln3061">		 * watchdog timeout issue was observed on BCM5704 which</a>
<a name="ln3062">		 * lives behind PCI-X bridge(e.g AMD 8131 PCI-X bridge).</a>
<a name="ln3063">		 * Both limiting DMA address space to 32bits and flushing</a>
<a name="ln3064">		 * mailbox write seem to address the issue.</a>
<a name="ln3065">		 */</a>
<a name="ln3066">		if (sc-&gt;bge_pcixcap != 0)</a>
<a name="ln3067">			lowaddr = BUS_SPACE_MAXADDR_32BIT;</a>
<a name="ln3068">	}</a>
<a name="ln3069">	error = bus_dma_tag_create(bus_get_dma_tag(sc-&gt;bge_dev), 1, 0, lowaddr,</a>
<a name="ln3070">	    BUS_SPACE_MAXADDR, NULL, NULL, BUS_SPACE_MAXSIZE_32BIT, 0,</a>
<a name="ln3071">	    BUS_SPACE_MAXSIZE_32BIT, 0, NULL, NULL,</a>
<a name="ln3072">	    &amp;sc-&gt;bge_cdata.bge_buffer_tag);</a>
<a name="ln3073">	if (error != 0) {</a>
<a name="ln3074">		device_printf(sc-&gt;bge_dev,</a>
<a name="ln3075">		    &quot;could not allocate buffer dma tag\n&quot;);</a>
<a name="ln3076">		return (ENOMEM);</a>
<a name="ln3077">	}</a>
<a name="ln3078">	/* Create tag for Tx mbufs. */</a>
<a name="ln3079">	if (sc-&gt;bge_flags &amp; (BGE_FLAG_TSO | BGE_FLAG_TSO3)) {</a>
<a name="ln3080">		txsegsz = BGE_TSOSEG_SZ;</a>
<a name="ln3081">		txmaxsegsz = 65535 + sizeof(struct ether_vlan_header);</a>
<a name="ln3082">	} else {</a>
<a name="ln3083">		txsegsz = MCLBYTES;</a>
<a name="ln3084">		txmaxsegsz = MCLBYTES * BGE_NSEG_NEW;</a>
<a name="ln3085">	}</a>
<a name="ln3086">	error = bus_dma_tag_create(sc-&gt;bge_cdata.bge_buffer_tag, 1,</a>
<a name="ln3087">	    0, BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR, NULL, NULL,</a>
<a name="ln3088">	    txmaxsegsz, BGE_NSEG_NEW, txsegsz, 0, NULL, NULL,</a>
<a name="ln3089">	    &amp;sc-&gt;bge_cdata.bge_tx_mtag);</a>
<a name="ln3090"> </a>
<a name="ln3091">	if (error) {</a>
<a name="ln3092">		device_printf(sc-&gt;bge_dev, &quot;could not allocate TX dma tag\n&quot;);</a>
<a name="ln3093">		return (ENOMEM);</a>
<a name="ln3094">	}</a>
<a name="ln3095"> </a>
<a name="ln3096">	/* Create tag for Rx mbufs. */</a>
<a name="ln3097">	if (sc-&gt;bge_flags &amp; BGE_FLAG_JUMBO_STD)</a>
<a name="ln3098">		rxmaxsegsz = MJUM9BYTES;</a>
<a name="ln3099">	else</a>
<a name="ln3100">		rxmaxsegsz = MCLBYTES;</a>
<a name="ln3101">	error = bus_dma_tag_create(sc-&gt;bge_cdata.bge_buffer_tag, 1, 0,</a>
<a name="ln3102">	    BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR, NULL, NULL, rxmaxsegsz, 1,</a>
<a name="ln3103">	    rxmaxsegsz, 0, NULL, NULL, &amp;sc-&gt;bge_cdata.bge_rx_mtag);</a>
<a name="ln3104"> </a>
<a name="ln3105">	if (error) {</a>
<a name="ln3106">		device_printf(sc-&gt;bge_dev, &quot;could not allocate RX dma tag\n&quot;);</a>
<a name="ln3107">		return (ENOMEM);</a>
<a name="ln3108">	}</a>
<a name="ln3109"> </a>
<a name="ln3110">	/* Create DMA maps for RX buffers. */</a>
<a name="ln3111">	error = bus_dmamap_create(sc-&gt;bge_cdata.bge_rx_mtag, 0,</a>
<a name="ln3112">	    &amp;sc-&gt;bge_cdata.bge_rx_std_sparemap);</a>
<a name="ln3113">	if (error) {</a>
<a name="ln3114">		device_printf(sc-&gt;bge_dev,</a>
<a name="ln3115">		    &quot;can't create spare DMA map for RX\n&quot;);</a>
<a name="ln3116">		return (ENOMEM);</a>
<a name="ln3117">	}</a>
<a name="ln3118">	for (i = 0; i &lt; BGE_STD_RX_RING_CNT; i++) {</a>
<a name="ln3119">		error = bus_dmamap_create(sc-&gt;bge_cdata.bge_rx_mtag, 0,</a>
<a name="ln3120">			    &amp;sc-&gt;bge_cdata.bge_rx_std_dmamap[i]);</a>
<a name="ln3121">		if (error) {</a>
<a name="ln3122">			device_printf(sc-&gt;bge_dev,</a>
<a name="ln3123">			    &quot;can't create DMA map for RX\n&quot;);</a>
<a name="ln3124">			return (ENOMEM);</a>
<a name="ln3125">		}</a>
<a name="ln3126">	}</a>
<a name="ln3127"> </a>
<a name="ln3128">	/* Create DMA maps for TX buffers. */</a>
<a name="ln3129">	for (i = 0; i &lt; BGE_TX_RING_CNT; i++) {</a>
<a name="ln3130">		error = bus_dmamap_create(sc-&gt;bge_cdata.bge_tx_mtag, 0,</a>
<a name="ln3131">			    &amp;sc-&gt;bge_cdata.bge_tx_dmamap[i]);</a>
<a name="ln3132">		if (error) {</a>
<a name="ln3133">			device_printf(sc-&gt;bge_dev,</a>
<a name="ln3134">			    &quot;can't create DMA map for TX\n&quot;);</a>
<a name="ln3135">			return (ENOMEM);</a>
<a name="ln3136">		}</a>
<a name="ln3137">	}</a>
<a name="ln3138"> </a>
<a name="ln3139">	/* Create tags for jumbo RX buffers. */</a>
<a name="ln3140">	if (BGE_IS_JUMBO_CAPABLE(sc)) {</a>
<a name="ln3141">		error = bus_dma_tag_create(sc-&gt;bge_cdata.bge_buffer_tag,</a>
<a name="ln3142">		    1, 0, BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR, NULL,</a>
<a name="ln3143">		    NULL, MJUM9BYTES, BGE_NSEG_JUMBO, PAGE_SIZE,</a>
<a name="ln3144">		    0, NULL, NULL, &amp;sc-&gt;bge_cdata.bge_mtag_jumbo);</a>
<a name="ln3145">		if (error) {</a>
<a name="ln3146">			device_printf(sc-&gt;bge_dev,</a>
<a name="ln3147">			    &quot;could not allocate jumbo dma tag\n&quot;);</a>
<a name="ln3148">			return (ENOMEM);</a>
<a name="ln3149">		}</a>
<a name="ln3150">		/* Create DMA maps for jumbo RX buffers. */</a>
<a name="ln3151">		error = bus_dmamap_create(sc-&gt;bge_cdata.bge_mtag_jumbo,</a>
<a name="ln3152">		    0, &amp;sc-&gt;bge_cdata.bge_rx_jumbo_sparemap);</a>
<a name="ln3153">		if (error) {</a>
<a name="ln3154">			device_printf(sc-&gt;bge_dev,</a>
<a name="ln3155">			    &quot;can't create spare DMA map for jumbo RX\n&quot;);</a>
<a name="ln3156">			return (ENOMEM);</a>
<a name="ln3157">		}</a>
<a name="ln3158">		for (i = 0; i &lt; BGE_JUMBO_RX_RING_CNT; i++) {</a>
<a name="ln3159">			error = bus_dmamap_create(sc-&gt;bge_cdata.bge_mtag_jumbo,</a>
<a name="ln3160">				    0, &amp;sc-&gt;bge_cdata.bge_rx_jumbo_dmamap[i]);</a>
<a name="ln3161">			if (error) {</a>
<a name="ln3162">				device_printf(sc-&gt;bge_dev,</a>
<a name="ln3163">				    &quot;can't create DMA map for jumbo RX\n&quot;);</a>
<a name="ln3164">				return (ENOMEM);</a>
<a name="ln3165">			}</a>
<a name="ln3166">		}</a>
<a name="ln3167">	}</a>
<a name="ln3168"> </a>
<a name="ln3169">	return (0);</a>
<a name="ln3170">}</a>
<a name="ln3171"> </a>
<a name="ln3172">/*</a>
<a name="ln3173"> * Return true if this device has more than one port.</a>
<a name="ln3174"> */</a>
<a name="ln3175">static int</a>
<a name="ln3176">bge_has_multiple_ports(struct bge_softc *sc)</a>
<a name="ln3177">{</a>
<a name="ln3178">	device_t dev = sc-&gt;bge_dev;</a>
<a name="ln3179">	u_int b, d, f, fscan, s;</a>
<a name="ln3180"> </a>
<a name="ln3181">	d = pci_get_domain(dev);</a>
<a name="ln3182">	b = pci_get_bus(dev);</a>
<a name="ln3183">	s = pci_get_slot(dev);</a>
<a name="ln3184">	f = pci_get_function(dev);</a>
<a name="ln3185">	for (fscan = 0; fscan &lt;= PCI_FUNCMAX; fscan++)</a>
<a name="ln3186">		if (fscan != f &amp;&amp; pci_find_dbsf(d, b, s, fscan) != NULL)</a>
<a name="ln3187">			return (1);</a>
<a name="ln3188">	return (0);</a>
<a name="ln3189">}</a>
<a name="ln3190"> </a>
<a name="ln3191">/*</a>
<a name="ln3192"> * Return true if MSI can be used with this device.</a>
<a name="ln3193"> */</a>
<a name="ln3194">static int</a>
<a name="ln3195">bge_can_use_msi(struct bge_softc *sc)</a>
<a name="ln3196">{</a>
<a name="ln3197">	int can_use_msi = 0;</a>
<a name="ln3198"> </a>
<a name="ln3199">#ifdef __HAIKU__</a>
<a name="ln3200">	// temporary workaround, the int disable happens in msi enable through</a>
<a name="ln3201">	// setup intr in our case which undoes the re-enabling done by the driver</a>
<a name="ln3202">	return 0;</a>
<a name="ln3203">#endif</a>
<a name="ln3204"> </a>
<a name="ln3205">	if (sc-&gt;bge_msi == 0)</a>
<a name="ln3206">		return (0);</a>
<a name="ln3207"> </a>
<a name="ln3208">	/* Disable MSI for polling(4). */</a>
<a name="ln3209">#ifdef DEVICE_POLLING</a>
<a name="ln3210">	return (0);</a>
<a name="ln3211">#endif</a>
<a name="ln3212">	switch (sc-&gt;bge_asicrev) {</a>
<a name="ln3213">	case BGE_ASICREV_BCM5714_A0:</a>
<a name="ln3214">	case BGE_ASICREV_BCM5714:</a>
<a name="ln3215">		/*</a>
<a name="ln3216">		 * Apparently, MSI doesn't work when these chips are</a>
<a name="ln3217">		 * configured in single-port mode.</a>
<a name="ln3218">		 */</a>
<a name="ln3219">		if (bge_has_multiple_ports(sc))</a>
<a name="ln3220">			can_use_msi = 1;</a>
<a name="ln3221">		break;</a>
<a name="ln3222">	case BGE_ASICREV_BCM5750:</a>
<a name="ln3223">		if (sc-&gt;bge_chiprev != BGE_CHIPREV_5750_AX &amp;&amp;</a>
<a name="ln3224">		    sc-&gt;bge_chiprev != BGE_CHIPREV_5750_BX)</a>
<a name="ln3225">			can_use_msi = 1;</a>
<a name="ln3226">		break;</a>
<a name="ln3227">	case BGE_ASICREV_BCM5784:</a>
<a name="ln3228">		/*</a>
<a name="ln3229">		 * Prevent infinite &quot;watchdog timeout&quot; errors</a>
<a name="ln3230">		 * in some MacBook Pro and make it work out-of-the-box.</a>
<a name="ln3231">		 */</a>
<a name="ln3232">		if (sc-&gt;bge_chiprev == BGE_CHIPREV_5784_AX)</a>
<a name="ln3233">			break;</a>
<a name="ln3234">		/* FALLTHROUGH */</a>
<a name="ln3235">	default:</a>
<a name="ln3236">		if (BGE_IS_575X_PLUS(sc))</a>
<a name="ln3237">			can_use_msi = 1;</a>
<a name="ln3238">	}</a>
<a name="ln3239">	return (can_use_msi);</a>
<a name="ln3240">}</a>
<a name="ln3241"> </a>
<a name="ln3242">static int</a>
<a name="ln3243">bge_mbox_reorder(struct bge_softc *sc)</a>
<a name="ln3244">{</a>
<a name="ln3245">#ifndef __HAIKU__</a>
<a name="ln3246">	/* Lists of PCI bridges that are known to reorder mailbox writes. */</a>
<a name="ln3247">	static const struct mbox_reorder {</a>
<a name="ln3248">		const uint16_t vendor;</a>
<a name="ln3249">		const uint16_t device;</a>
<a name="ln3250">		const char *desc;</a>
<a name="ln3251">	} mbox_reorder_lists[] = {</a>
<a name="ln3252">		{ 0x1022, 0x7450, &quot;AMD-8131 PCI-X Bridge&quot; },</a>
<a name="ln3253">	};</a>
<a name="ln3254">	devclass_t pci, pcib;</a>
<a name="ln3255">	device_t bus, dev;</a>
<a name="ln3256">	int i;</a>
<a name="ln3257"> </a>
<a name="ln3258">	pci = devclass_find(&quot;pci&quot;);</a>
<a name="ln3259">	pcib = devclass_find(&quot;pcib&quot;);</a>
<a name="ln3260">	dev = sc-&gt;bge_dev;</a>
<a name="ln3261">	bus = device_get_parent(dev);</a>
<a name="ln3262">	for (;;) {</a>
<a name="ln3263">		dev = device_get_parent(bus);</a>
<a name="ln3264">		bus = device_get_parent(dev);</a>
<a name="ln3265">		if (device_get_devclass(dev) != pcib)</a>
<a name="ln3266">			break;</a>
<a name="ln3267">		for (i = 0; i &lt; nitems(mbox_reorder_lists); i++) {</a>
<a name="ln3268">			if (pci_get_vendor(dev) ==</a>
<a name="ln3269">			    mbox_reorder_lists[i].vendor &amp;&amp;</a>
<a name="ln3270">			    pci_get_device(dev) ==</a>
<a name="ln3271">			    mbox_reorder_lists[i].device) {</a>
<a name="ln3272">				device_printf(sc-&gt;bge_dev,</a>
<a name="ln3273">				    &quot;enabling MBOX workaround for %s\n&quot;,</a>
<a name="ln3274">				    mbox_reorder_lists[i].desc);</a>
<a name="ln3275">				return (1);</a>
<a name="ln3276">			}</a>
<a name="ln3277">		}</a>
<a name="ln3278">		if (device_get_devclass(bus) != pci)</a>
<a name="ln3279">			break;</a>
<a name="ln3280">	}</a>
<a name="ln3281">#endif</a>
<a name="ln3282">	return (0);</a>
<a name="ln3283">}</a>
<a name="ln3284"> </a>
<a name="ln3285">static void</a>
<a name="ln3286">bge_devinfo(struct bge_softc *sc)</a>
<a name="ln3287">{</a>
<a name="ln3288">	uint32_t cfg, clk;</a>
<a name="ln3289"> </a>
<a name="ln3290">	device_printf(sc-&gt;bge_dev,</a>
<a name="ln3291">	    &quot;CHIP ID 0x%08x; ASIC REV 0x%02x; CHIP REV 0x%02x; &quot;,</a>
<a name="ln3292">	    sc-&gt;bge_chipid, sc-&gt;bge_asicrev, sc-&gt;bge_chiprev);</a>
<a name="ln3293">	if (sc-&gt;bge_flags &amp; BGE_FLAG_PCIE)</a>
<a name="ln3294">		printf(&quot;PCI-E\n&quot;);</a>
<a name="ln3295">	else if (sc-&gt;bge_flags &amp; BGE_FLAG_PCIX) {</a>
<a name="ln3296">		printf(&quot;PCI-X &quot;);</a>
<a name="ln3297">		cfg = CSR_READ_4(sc, BGE_MISC_CFG) &amp; BGE_MISCCFG_BOARD_ID_MASK;</a>
<a name="ln3298">		if (cfg == BGE_MISCCFG_BOARD_ID_5704CIOBE)</a>
<a name="ln3299">			clk = 133;</a>
<a name="ln3300">		else {</a>
<a name="ln3301">			clk = CSR_READ_4(sc, BGE_PCI_CLKCTL) &amp; 0x1F;</a>
<a name="ln3302">			switch (clk) {</a>
<a name="ln3303">			case 0:</a>
<a name="ln3304">				clk = 33;</a>
<a name="ln3305">				break;</a>
<a name="ln3306">			case 2:</a>
<a name="ln3307">				clk = 50;</a>
<a name="ln3308">				break;</a>
<a name="ln3309">			case 4:</a>
<a name="ln3310">				clk = 66;</a>
<a name="ln3311">				break;</a>
<a name="ln3312">			case 6:</a>
<a name="ln3313">				clk = 100;</a>
<a name="ln3314">				break;</a>
<a name="ln3315">			case 7:</a>
<a name="ln3316">				clk = 133;</a>
<a name="ln3317">				break;</a>
<a name="ln3318">			}</a>
<a name="ln3319">		}</a>
<a name="ln3320">		printf(&quot;%u MHz\n&quot;, clk);</a>
<a name="ln3321">	} else {</a>
<a name="ln3322">		if (sc-&gt;bge_pcixcap != 0)</a>
<a name="ln3323">			printf(&quot;PCI on PCI-X &quot;);</a>
<a name="ln3324">		else</a>
<a name="ln3325">			printf(&quot;PCI &quot;);</a>
<a name="ln3326">		cfg = pci_read_config(sc-&gt;bge_dev, BGE_PCI_PCISTATE, 4);</a>
<a name="ln3327">		if (cfg &amp; BGE_PCISTATE_PCI_BUSSPEED)</a>
<a name="ln3328">			clk = 66;</a>
<a name="ln3329">		else</a>
<a name="ln3330">			clk = 33;</a>
<a name="ln3331">		if (cfg &amp; BGE_PCISTATE_32BIT_BUS)</a>
<a name="ln3332">			printf(&quot;%u MHz; 32bit\n&quot;, clk);</a>
<a name="ln3333">		else</a>
<a name="ln3334">			printf(&quot;%u MHz; 64bit\n&quot;, clk);</a>
<a name="ln3335">	}</a>
<a name="ln3336">}</a>
<a name="ln3337"> </a>
<a name="ln3338">static int</a>
<a name="ln3339">bge_attach(device_t dev)</a>
<a name="ln3340">{</a>
<a name="ln3341">	if_t ifp;</a>
<a name="ln3342">	struct bge_softc *sc;</a>
<a name="ln3343">	uint32_t hwcfg = 0, misccfg, pcistate;</a>
<a name="ln3344">	u_char eaddr[ETHER_ADDR_LEN];</a>
<a name="ln3345">	int capmask, error, reg, rid, trys;</a>
<a name="ln3346"> </a>
<a name="ln3347">	sc = device_get_softc(dev);</a>
<a name="ln3348">	sc-&gt;bge_dev = dev;</a>
<a name="ln3349"> </a>
<a name="ln3350">	BGE_LOCK_INIT(sc, device_get_nameunit(dev));</a>
<a name="ln3351">	TASK_INIT(&amp;sc-&gt;bge_intr_task, 0, bge_intr_task, sc);</a>
<a name="ln3352">	callout_init_mtx(&amp;sc-&gt;bge_stat_ch, &amp;sc-&gt;bge_mtx, 0);</a>
<a name="ln3353"> </a>
<a name="ln3354">	pci_enable_busmaster(dev);</a>
<a name="ln3355"> </a>
<a name="ln3356">	/*</a>
<a name="ln3357">	 * Allocate control/status registers.</a>
<a name="ln3358">	 */</a>
<a name="ln3359">	rid = PCIR_BAR(0);</a>
<a name="ln3360">	sc-&gt;bge_res = bus_alloc_resource_any(dev, SYS_RES_MEMORY, &amp;rid,</a>
<a name="ln3361">	    RF_ACTIVE);</a>
<a name="ln3362"> </a>
<a name="ln3363">	if (sc-&gt;bge_res == NULL) {</a>
<a name="ln3364">		device_printf (sc-&gt;bge_dev, &quot;couldn't map BAR0 memory\n&quot;);</a>
<a name="ln3365">		error = ENXIO;</a>
<a name="ln3366">		goto fail;</a>
<a name="ln3367">	}</a>
<a name="ln3368"> </a>
<a name="ln3369">	/* Save various chip information. */</a>
<a name="ln3370">	sc-&gt;bge_func_addr = pci_get_function(dev);</a>
<a name="ln3371">	sc-&gt;bge_chipid = bge_chipid(dev);</a>
<a name="ln3372">	sc-&gt;bge_asicrev = BGE_ASICREV(sc-&gt;bge_chipid);</a>
<a name="ln3373">	sc-&gt;bge_chiprev = BGE_CHIPREV(sc-&gt;bge_chipid);</a>
<a name="ln3374"> </a>
<a name="ln3375">	/* Set default PHY address. */</a>
<a name="ln3376">	sc-&gt;bge_phy_addr = 1;</a>
<a name="ln3377">	 /*</a>
<a name="ln3378">	  * PHY address mapping for various devices.</a>
<a name="ln3379">	  *</a>
<a name="ln3380">	  *          | F0 Cu | F0 Sr | F1 Cu | F1 Sr |</a>
<a name="ln3381">	  * ---------+-------+-------+-------+-------+</a>
<a name="ln3382">	  * BCM57XX  |   1   |   X   |   X   |   X   |</a>
<a name="ln3383">	  * BCM5704  |   1   |   X   |   1   |   X   |</a>
<a name="ln3384">	  * BCM5717  |   1   |   8   |   2   |   9   |</a>
<a name="ln3385">	  * BCM5719  |   1   |   8   |   2   |   9   |</a>
<a name="ln3386">	  * BCM5720  |   1   |   8   |   2   |   9   |</a>
<a name="ln3387">	  *</a>
<a name="ln3388">	  *          | F2 Cu | F2 Sr | F3 Cu | F3 Sr |</a>
<a name="ln3389">	  * ---------+-------+-------+-------+-------+</a>
<a name="ln3390">	  * BCM57XX  |   X   |   X   |   X   |   X   |</a>
<a name="ln3391">	  * BCM5704  |   X   |   X   |   X   |   X   |</a>
<a name="ln3392">	  * BCM5717  |   X   |   X   |   X   |   X   |</a>
<a name="ln3393">	  * BCM5719  |   3   |   10  |   4   |   11  |</a>
<a name="ln3394">	  * BCM5720  |   X   |   X   |   X   |   X   |</a>
<a name="ln3395">	  *</a>
<a name="ln3396">	  * Other addresses may respond but they are not</a>
<a name="ln3397">	  * IEEE compliant PHYs and should be ignored.</a>
<a name="ln3398">	  */</a>
<a name="ln3399">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5717 ||</a>
<a name="ln3400">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5719 ||</a>
<a name="ln3401">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5720) {</a>
<a name="ln3402">		if (sc-&gt;bge_chipid != BGE_CHIPID_BCM5717_A0) {</a>
<a name="ln3403">			if (CSR_READ_4(sc, BGE_SGDIG_STS) &amp;</a>
<a name="ln3404">			    BGE_SGDIGSTS_IS_SERDES)</a>
<a name="ln3405">				sc-&gt;bge_phy_addr = sc-&gt;bge_func_addr + 8;</a>
<a name="ln3406">			else</a>
<a name="ln3407">				sc-&gt;bge_phy_addr = sc-&gt;bge_func_addr + 1;</a>
<a name="ln3408">		} else {</a>
<a name="ln3409">			if (CSR_READ_4(sc, BGE_CPMU_PHY_STRAP) &amp;</a>
<a name="ln3410">			    BGE_CPMU_PHY_STRAP_IS_SERDES)</a>
<a name="ln3411">				sc-&gt;bge_phy_addr = sc-&gt;bge_func_addr + 8;</a>
<a name="ln3412">			else</a>
<a name="ln3413">				sc-&gt;bge_phy_addr = sc-&gt;bge_func_addr + 1;</a>
<a name="ln3414">		}</a>
<a name="ln3415">	}</a>
<a name="ln3416"> </a>
<a name="ln3417">	if (bge_has_eaddr(sc))</a>
<a name="ln3418">		sc-&gt;bge_flags |= BGE_FLAG_EADDR;</a>
<a name="ln3419"> </a>
<a name="ln3420">	/* Save chipset family. */</a>
<a name="ln3421">	switch (sc-&gt;bge_asicrev) {</a>
<a name="ln3422">	case BGE_ASICREV_BCM5762:</a>
<a name="ln3423">	case BGE_ASICREV_BCM57765:</a>
<a name="ln3424">	case BGE_ASICREV_BCM57766:</a>
<a name="ln3425">		sc-&gt;bge_flags |= BGE_FLAG_57765_PLUS;</a>
<a name="ln3426">		/* FALLTHROUGH */</a>
<a name="ln3427">	case BGE_ASICREV_BCM5717:</a>
<a name="ln3428">	case BGE_ASICREV_BCM5719:</a>
<a name="ln3429">	case BGE_ASICREV_BCM5720:</a>
<a name="ln3430">		sc-&gt;bge_flags |= BGE_FLAG_5717_PLUS | BGE_FLAG_5755_PLUS |</a>
<a name="ln3431">		    BGE_FLAG_575X_PLUS | BGE_FLAG_5705_PLUS | BGE_FLAG_JUMBO |</a>
<a name="ln3432">		    BGE_FLAG_JUMBO_FRAME;</a>
<a name="ln3433">		if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5719 ||</a>
<a name="ln3434">		    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5720) {</a>
<a name="ln3435">			/*</a>
<a name="ln3436">			 * Enable work around for DMA engine miscalculation</a>
<a name="ln3437">			 * of TXMBUF available space.</a>
<a name="ln3438">			 */</a>
<a name="ln3439">			sc-&gt;bge_flags |= BGE_FLAG_RDMA_BUG;</a>
<a name="ln3440">			if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5719 &amp;&amp;</a>
<a name="ln3441">			    sc-&gt;bge_chipid == BGE_CHIPID_BCM5719_A0) {</a>
<a name="ln3442">				/* Jumbo frame on BCM5719 A0 does not work. */</a>
<a name="ln3443">				sc-&gt;bge_flags &amp;= ~BGE_FLAG_JUMBO;</a>
<a name="ln3444">			}</a>
<a name="ln3445">		}</a>
<a name="ln3446">		break;</a>
<a name="ln3447">	case BGE_ASICREV_BCM5755:</a>
<a name="ln3448">	case BGE_ASICREV_BCM5761:</a>
<a name="ln3449">	case BGE_ASICREV_BCM5784:</a>
<a name="ln3450">	case BGE_ASICREV_BCM5785:</a>
<a name="ln3451">	case BGE_ASICREV_BCM5787:</a>
<a name="ln3452">	case BGE_ASICREV_BCM57780:</a>
<a name="ln3453">		sc-&gt;bge_flags |= BGE_FLAG_5755_PLUS | BGE_FLAG_575X_PLUS |</a>
<a name="ln3454">		    BGE_FLAG_5705_PLUS;</a>
<a name="ln3455">		break;</a>
<a name="ln3456">	case BGE_ASICREV_BCM5700:</a>
<a name="ln3457">	case BGE_ASICREV_BCM5701:</a>
<a name="ln3458">	case BGE_ASICREV_BCM5703:</a>
<a name="ln3459">	case BGE_ASICREV_BCM5704:</a>
<a name="ln3460">		sc-&gt;bge_flags |= BGE_FLAG_5700_FAMILY | BGE_FLAG_JUMBO;</a>
<a name="ln3461">		break;</a>
<a name="ln3462">	case BGE_ASICREV_BCM5714_A0:</a>
<a name="ln3463">	case BGE_ASICREV_BCM5780:</a>
<a name="ln3464">	case BGE_ASICREV_BCM5714:</a>
<a name="ln3465">		sc-&gt;bge_flags |= BGE_FLAG_5714_FAMILY | BGE_FLAG_JUMBO_STD;</a>
<a name="ln3466">		/* FALLTHROUGH */</a>
<a name="ln3467">	case BGE_ASICREV_BCM5750:</a>
<a name="ln3468">	case BGE_ASICREV_BCM5752:</a>
<a name="ln3469">	case BGE_ASICREV_BCM5906:</a>
<a name="ln3470">		sc-&gt;bge_flags |= BGE_FLAG_575X_PLUS;</a>
<a name="ln3471">		/* FALLTHROUGH */</a>
<a name="ln3472">	case BGE_ASICREV_BCM5705:</a>
<a name="ln3473">		sc-&gt;bge_flags |= BGE_FLAG_5705_PLUS;</a>
<a name="ln3474">		break;</a>
<a name="ln3475">	}</a>
<a name="ln3476"> </a>
<a name="ln3477">	/* Identify chips with APE processor. */</a>
<a name="ln3478">	switch (sc-&gt;bge_asicrev) {</a>
<a name="ln3479">	case BGE_ASICREV_BCM5717:</a>
<a name="ln3480">	case BGE_ASICREV_BCM5719:</a>
<a name="ln3481">	case BGE_ASICREV_BCM5720:</a>
<a name="ln3482">	case BGE_ASICREV_BCM5761:</a>
<a name="ln3483">	case BGE_ASICREV_BCM5762:</a>
<a name="ln3484">		sc-&gt;bge_flags |= BGE_FLAG_APE;</a>
<a name="ln3485">		break;</a>
<a name="ln3486">	}</a>
<a name="ln3487"> </a>
<a name="ln3488">	/* Chips with APE need BAR2 access for APE registers/memory. */</a>
<a name="ln3489">	if ((sc-&gt;bge_flags &amp; BGE_FLAG_APE) != 0) {</a>
<a name="ln3490">		rid = PCIR_BAR(2);</a>
<a name="ln3491">		sc-&gt;bge_res2 = bus_alloc_resource_any(dev, SYS_RES_MEMORY, &amp;rid,</a>
<a name="ln3492">		    RF_ACTIVE);</a>
<a name="ln3493">		if (sc-&gt;bge_res2 == NULL) {</a>
<a name="ln3494">			device_printf (sc-&gt;bge_dev,</a>
<a name="ln3495">			    &quot;couldn't map BAR2 memory\n&quot;);</a>
<a name="ln3496">			error = ENXIO;</a>
<a name="ln3497">			goto fail;</a>
<a name="ln3498">		}</a>
<a name="ln3499"> </a>
<a name="ln3500">		/* Enable APE register/memory access by host driver. */</a>
<a name="ln3501">		pcistate = pci_read_config(dev, BGE_PCI_PCISTATE, 4);</a>
<a name="ln3502">		pcistate |= BGE_PCISTATE_ALLOW_APE_CTLSPC_WR |</a>
<a name="ln3503">		    BGE_PCISTATE_ALLOW_APE_SHMEM_WR |</a>
<a name="ln3504">		    BGE_PCISTATE_ALLOW_APE_PSPACE_WR;</a>
<a name="ln3505">		pci_write_config(dev, BGE_PCI_PCISTATE, pcistate, 4);</a>
<a name="ln3506"> </a>
<a name="ln3507">		bge_ape_lock_init(sc);</a>
<a name="ln3508">		bge_ape_read_fw_ver(sc);</a>
<a name="ln3509">	}</a>
<a name="ln3510"> </a>
<a name="ln3511">	/* Add SYSCTLs, requires the chipset family to be set. */</a>
<a name="ln3512">	bge_add_sysctls(sc);</a>
<a name="ln3513"> </a>
<a name="ln3514">	/* Identify the chips that use an CPMU. */</a>
<a name="ln3515">	if (BGE_IS_5717_PLUS(sc) ||</a>
<a name="ln3516">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5784 ||</a>
<a name="ln3517">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5761 ||</a>
<a name="ln3518">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5785 ||</a>
<a name="ln3519">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM57780)</a>
<a name="ln3520">		sc-&gt;bge_flags |= BGE_FLAG_CPMU_PRESENT;</a>
<a name="ln3521">	if ((sc-&gt;bge_flags &amp; BGE_FLAG_CPMU_PRESENT) != 0)</a>
<a name="ln3522">		sc-&gt;bge_mi_mode = BGE_MIMODE_500KHZ_CONST;</a>
<a name="ln3523">	else</a>
<a name="ln3524">		sc-&gt;bge_mi_mode = BGE_MIMODE_BASE;</a>
<a name="ln3525">	/* Enable auto polling for BCM570[0-5]. */</a>
<a name="ln3526">	if (BGE_IS_5700_FAMILY(sc) || sc-&gt;bge_asicrev == BGE_ASICREV_BCM5705)</a>
<a name="ln3527">		sc-&gt;bge_mi_mode |= BGE_MIMODE_AUTOPOLL;</a>
<a name="ln3528"> </a>
<a name="ln3529">	/*</a>
<a name="ln3530">	 * All Broadcom controllers have 4GB boundary DMA bug.</a>
<a name="ln3531">	 * Whenever an address crosses a multiple of the 4GB boundary</a>
<a name="ln3532">	 * (including 4GB, 8Gb, 12Gb, etc.) and makes the transition</a>
<a name="ln3533">	 * from 0xX_FFFF_FFFF to 0x(X+1)_0000_0000 an internal DMA</a>
<a name="ln3534">	 * state machine will lockup and cause the device to hang.</a>
<a name="ln3535">	 */</a>
<a name="ln3536">	sc-&gt;bge_flags |= BGE_FLAG_4G_BNDRY_BUG;</a>
<a name="ln3537"> </a>
<a name="ln3538">	/* BCM5755 or higher and BCM5906 have short DMA bug. */</a>
<a name="ln3539">	if (BGE_IS_5755_PLUS(sc) || sc-&gt;bge_asicrev == BGE_ASICREV_BCM5906)</a>
<a name="ln3540">		sc-&gt;bge_flags |= BGE_FLAG_SHORT_DMA_BUG;</a>
<a name="ln3541"> </a>
<a name="ln3542">	/*</a>
<a name="ln3543">	 * BCM5719 cannot handle DMA requests for DMA segments that</a>
<a name="ln3544">	 * have larger than 4KB in size.  However the maximum DMA</a>
<a name="ln3545">	 * segment size created in DMA tag is 4KB for TSO, so we</a>
<a name="ln3546">	 * wouldn't encounter the issue here.</a>
<a name="ln3547">	 */</a>
<a name="ln3548">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5719)</a>
<a name="ln3549">		sc-&gt;bge_flags |= BGE_FLAG_4K_RDMA_BUG;</a>
<a name="ln3550"> </a>
<a name="ln3551">	misccfg = CSR_READ_4(sc, BGE_MISC_CFG) &amp; BGE_MISCCFG_BOARD_ID_MASK;</a>
<a name="ln3552">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5705) {</a>
<a name="ln3553">		if (misccfg == BGE_MISCCFG_BOARD_ID_5788 ||</a>
<a name="ln3554">		    misccfg == BGE_MISCCFG_BOARD_ID_5788M)</a>
<a name="ln3555">			sc-&gt;bge_flags |= BGE_FLAG_5788;</a>
<a name="ln3556">	}</a>
<a name="ln3557"> </a>
<a name="ln3558">	capmask = BMSR_DEFCAPMASK;</a>
<a name="ln3559">	if ((sc-&gt;bge_asicrev == BGE_ASICREV_BCM5703 &amp;&amp;</a>
<a name="ln3560">	    (misccfg == 0x4000 || misccfg == 0x8000)) ||</a>
<a name="ln3561">	    (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5705 &amp;&amp;</a>
<a name="ln3562">	    pci_get_vendor(dev) == BCOM_VENDORID &amp;&amp;</a>
<a name="ln3563">	    (pci_get_device(dev) == BCOM_DEVICEID_BCM5901 ||</a>
<a name="ln3564">	    pci_get_device(dev) == BCOM_DEVICEID_BCM5901A2 ||</a>
<a name="ln3565">	    pci_get_device(dev) == BCOM_DEVICEID_BCM5705F)) ||</a>
<a name="ln3566">	    (pci_get_vendor(dev) == BCOM_VENDORID &amp;&amp;</a>
<a name="ln3567">	    (pci_get_device(dev) == BCOM_DEVICEID_BCM5751F ||</a>
<a name="ln3568">	    pci_get_device(dev) == BCOM_DEVICEID_BCM5753F ||</a>
<a name="ln3569">	    pci_get_device(dev) == BCOM_DEVICEID_BCM5787F)) ||</a>
<a name="ln3570">	    pci_get_device(dev) == BCOM_DEVICEID_BCM57790 ||</a>
<a name="ln3571">	    pci_get_device(dev) == BCOM_DEVICEID_BCM57791 ||</a>
<a name="ln3572">	    pci_get_device(dev) == BCOM_DEVICEID_BCM57795 ||</a>
<a name="ln3573">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5906) {</a>
<a name="ln3574">		/* These chips are 10/100 only. */</a>
<a name="ln3575">		capmask &amp;= ~BMSR_EXTSTAT;</a>
<a name="ln3576">		sc-&gt;bge_phy_flags |= BGE_PHY_NO_WIRESPEED;</a>
<a name="ln3577">	}</a>
<a name="ln3578"> </a>
<a name="ln3579">	/*</a>
<a name="ln3580">	 * Some controllers seem to require a special firmware to use</a>
<a name="ln3581">	 * TSO. But the firmware is not available to FreeBSD and Linux</a>
<a name="ln3582">	 * claims that the TSO performed by the firmware is slower than</a>
<a name="ln3583">	 * hardware based TSO. Moreover the firmware based TSO has one</a>
<a name="ln3584">	 * known bug which can't handle TSO if Ethernet header + IP/TCP</a>
<a name="ln3585">	 * header is greater than 80 bytes. A workaround for the TSO</a>
<a name="ln3586">	 * bug exist but it seems it's too expensive than not using</a>
<a name="ln3587">	 * TSO at all. Some hardwares also have the TSO bug so limit</a>
<a name="ln3588">	 * the TSO to the controllers that are not affected TSO issues</a>
<a name="ln3589">	 * (e.g. 5755 or higher).</a>
<a name="ln3590">	 */</a>
<a name="ln3591">	if (BGE_IS_5717_PLUS(sc)) {</a>
<a name="ln3592">		/* BCM5717 requires different TSO configuration. */</a>
<a name="ln3593">		sc-&gt;bge_flags |= BGE_FLAG_TSO3;</a>
<a name="ln3594">		if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5719 &amp;&amp;</a>
<a name="ln3595">		    sc-&gt;bge_chipid == BGE_CHIPID_BCM5719_A0) {</a>
<a name="ln3596">			/* TSO on BCM5719 A0 does not work. */</a>
<a name="ln3597">			sc-&gt;bge_flags &amp;= ~BGE_FLAG_TSO3;</a>
<a name="ln3598">		}</a>
<a name="ln3599">	} else if (BGE_IS_5755_PLUS(sc)) {</a>
<a name="ln3600">		/*</a>
<a name="ln3601">		 * BCM5754 and BCM5787 shares the same ASIC id so</a>
<a name="ln3602">		 * explicit device id check is required.</a>
<a name="ln3603">		 * Due to unknown reason TSO does not work on BCM5755M.</a>
<a name="ln3604">		 */</a>
<a name="ln3605">		if (pci_get_device(dev) != BCOM_DEVICEID_BCM5754 &amp;&amp;</a>
<a name="ln3606">		    pci_get_device(dev) != BCOM_DEVICEID_BCM5754M &amp;&amp;</a>
<a name="ln3607">		    pci_get_device(dev) != BCOM_DEVICEID_BCM5755M)</a>
<a name="ln3608">			sc-&gt;bge_flags |= BGE_FLAG_TSO;</a>
<a name="ln3609">	}</a>
<a name="ln3610"> </a>
<a name="ln3611">	/*</a>
<a name="ln3612">	 * Check if this is a PCI-X or PCI Express device.</a>
<a name="ln3613">	 */</a>
<a name="ln3614">	if (pci_find_cap(dev, PCIY_EXPRESS, &amp;reg) == 0) {</a>
<a name="ln3615">		/*</a>
<a name="ln3616">		 * Found a PCI Express capabilities register, this</a>
<a name="ln3617">		 * must be a PCI Express device.</a>
<a name="ln3618">		 */</a>
<a name="ln3619">		sc-&gt;bge_flags |= BGE_FLAG_PCIE;</a>
<a name="ln3620">		sc-&gt;bge_expcap = reg;</a>
<a name="ln3621">		/* Extract supported maximum payload size. */</a>
<a name="ln3622">		sc-&gt;bge_mps = pci_read_config(dev, sc-&gt;bge_expcap +</a>
<a name="ln3623">		    PCIER_DEVICE_CAP, 2);</a>
<a name="ln3624">		sc-&gt;bge_mps = 128 &lt;&lt; (sc-&gt;bge_mps &amp; PCIEM_CAP_MAX_PAYLOAD);</a>
<a name="ln3625">		if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5719 ||</a>
<a name="ln3626">		    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5720)</a>
<a name="ln3627">			sc-&gt;bge_expmrq = 2048;</a>
<a name="ln3628">		else</a>
<a name="ln3629">			sc-&gt;bge_expmrq = 4096;</a>
<a name="ln3630">		pci_set_max_read_req(dev, sc-&gt;bge_expmrq);</a>
<a name="ln3631">	} else {</a>
<a name="ln3632">		/*</a>
<a name="ln3633">		 * Check if the device is in PCI-X Mode.</a>
<a name="ln3634">		 * (This bit is not valid on PCI Express controllers.)</a>
<a name="ln3635">		 */</a>
<a name="ln3636">		if (pci_find_cap(dev, PCIY_PCIX, &amp;reg) == 0)</a>
<a name="ln3637">			sc-&gt;bge_pcixcap = reg;</a>
<a name="ln3638">		if ((pci_read_config(dev, BGE_PCI_PCISTATE, 4) &amp;</a>
<a name="ln3639">		    BGE_PCISTATE_PCI_BUSMODE) == 0)</a>
<a name="ln3640">			sc-&gt;bge_flags |= BGE_FLAG_PCIX;</a>
<a name="ln3641">	}</a>
<a name="ln3642"> </a>
<a name="ln3643">	/*</a>
<a name="ln3644">	 * The 40bit DMA bug applies to the 5714/5715 controllers and is</a>
<a name="ln3645">	 * not actually a MAC controller bug but an issue with the embedded</a>
<a name="ln3646">	 * PCIe to PCI-X bridge in the device. Use 40bit DMA workaround.</a>
<a name="ln3647">	 */</a>
<a name="ln3648">	if (BGE_IS_5714_FAMILY(sc) &amp;&amp; (sc-&gt;bge_flags &amp; BGE_FLAG_PCIX))</a>
<a name="ln3649">		sc-&gt;bge_flags |= BGE_FLAG_40BIT_BUG;</a>
<a name="ln3650">	/*</a>
<a name="ln3651">	 * Some PCI-X bridges are known to trigger write reordering to</a>
<a name="ln3652">	 * the mailbox registers. Typical phenomena is watchdog timeouts</a>
<a name="ln3653">	 * caused by out-of-order TX completions.  Enable workaround for</a>
<a name="ln3654">	 * PCI-X devices that live behind these bridges.</a>
<a name="ln3655">	 * Note, PCI-X controllers can run in PCI mode so we can't use</a>
<a name="ln3656">	 * BGE_FLAG_PCIX flag to detect PCI-X controllers.</a>
<a name="ln3657">	 */</a>
<a name="ln3658">	if (sc-&gt;bge_pcixcap != 0 &amp;&amp; bge_mbox_reorder(sc) != 0)</a>
<a name="ln3659">		sc-&gt;bge_flags |= BGE_FLAG_MBOX_REORDER;</a>
<a name="ln3660">	/*</a>
<a name="ln3661">	 * Allocate the interrupt, using MSI if possible.  These devices</a>
<a name="ln3662">	 * support 8 MSI messages, but only the first one is used in</a>
<a name="ln3663">	 * normal operation.</a>
<a name="ln3664">	 */</a>
<a name="ln3665">	rid = 0;</a>
<a name="ln3666">	if (pci_find_cap(sc-&gt;bge_dev, PCIY_MSI, &amp;reg) == 0) {</a>
<a name="ln3667">		sc-&gt;bge_msicap = reg;</a>
<a name="ln3668">		reg = 1;</a>
<a name="ln3669">		if (bge_can_use_msi(sc) &amp;&amp; pci_alloc_msi(dev, &amp;reg) == 0) {</a>
<a name="ln3670">			rid = 1;</a>
<a name="ln3671">			sc-&gt;bge_flags |= BGE_FLAG_MSI;</a>
<a name="ln3672">		}</a>
<a name="ln3673">	}</a>
<a name="ln3674"> </a>
<a name="ln3675">	/*</a>
<a name="ln3676">	 * All controllers except BCM5700 supports tagged status but</a>
<a name="ln3677">	 * we use tagged status only for MSI case on BCM5717. Otherwise</a>
<a name="ln3678">	 * MSI on BCM5717 does not work.</a>
<a name="ln3679">	 */</a>
<a name="ln3680">#ifndef DEVICE_POLLING</a>
<a name="ln3681">	if (sc-&gt;bge_flags &amp; BGE_FLAG_MSI &amp;&amp; BGE_IS_5717_PLUS(sc))</a>
<a name="ln3682">		sc-&gt;bge_flags |= BGE_FLAG_TAGGED_STATUS;</a>
<a name="ln3683">#endif</a>
<a name="ln3684"> </a>
<a name="ln3685">	sc-&gt;bge_irq = bus_alloc_resource_any(dev, SYS_RES_IRQ, &amp;rid,</a>
<a name="ln3686">	    RF_ACTIVE | (rid != 0 ? 0 : RF_SHAREABLE));</a>
<a name="ln3687"> </a>
<a name="ln3688">	if (sc-&gt;bge_irq == NULL) {</a>
<a name="ln3689">		device_printf(sc-&gt;bge_dev, &quot;couldn't map interrupt\n&quot;);</a>
<a name="ln3690">		error = ENXIO;</a>
<a name="ln3691">		goto fail;</a>
<a name="ln3692">	}</a>
<a name="ln3693"> </a>
<a name="ln3694">	bge_devinfo(sc);</a>
<a name="ln3695"> </a>
<a name="ln3696">	sc-&gt;bge_asf_mode = 0;</a>
<a name="ln3697">	/* No ASF if APE present. */</a>
<a name="ln3698">	if ((sc-&gt;bge_flags &amp; BGE_FLAG_APE) == 0) {</a>
<a name="ln3699">		if (bge_allow_asf &amp;&amp; (bge_readmem_ind(sc, BGE_SRAM_DATA_SIG) ==</a>
<a name="ln3700">		    BGE_SRAM_DATA_SIG_MAGIC)) {</a>
<a name="ln3701">			if (bge_readmem_ind(sc, BGE_SRAM_DATA_CFG) &amp;</a>
<a name="ln3702">			    BGE_HWCFG_ASF) {</a>
<a name="ln3703">				sc-&gt;bge_asf_mode |= ASF_ENABLE;</a>
<a name="ln3704">				sc-&gt;bge_asf_mode |= ASF_STACKUP;</a>
<a name="ln3705">				if (BGE_IS_575X_PLUS(sc))</a>
<a name="ln3706">					sc-&gt;bge_asf_mode |= ASF_NEW_HANDSHAKE;</a>
<a name="ln3707">			}</a>
<a name="ln3708">		}</a>
<a name="ln3709">	}</a>
<a name="ln3710"> </a>
<a name="ln3711">	bge_stop_fw(sc);</a>
<a name="ln3712">	bge_sig_pre_reset(sc, BGE_RESET_SHUTDOWN);</a>
<a name="ln3713">	if (bge_reset(sc)) {</a>
<a name="ln3714">		device_printf(sc-&gt;bge_dev, &quot;chip reset failed\n&quot;);</a>
<a name="ln3715">		error = ENXIO;</a>
<a name="ln3716">		goto fail;</a>
<a name="ln3717">	}</a>
<a name="ln3718"> </a>
<a name="ln3719">	bge_sig_legacy(sc, BGE_RESET_SHUTDOWN);</a>
<a name="ln3720">	bge_sig_post_reset(sc, BGE_RESET_SHUTDOWN);</a>
<a name="ln3721"> </a>
<a name="ln3722">	if (bge_chipinit(sc)) {</a>
<a name="ln3723">		device_printf(sc-&gt;bge_dev, &quot;chip initialization failed\n&quot;);</a>
<a name="ln3724">		error = ENXIO;</a>
<a name="ln3725">		goto fail;</a>
<a name="ln3726">	}</a>
<a name="ln3727"> </a>
<a name="ln3728">	error = bge_get_eaddr(sc, eaddr);</a>
<a name="ln3729">	if (error) {</a>
<a name="ln3730">		device_printf(sc-&gt;bge_dev,</a>
<a name="ln3731">		    &quot;failed to read station address\n&quot;);</a>
<a name="ln3732">		error = ENXIO;</a>
<a name="ln3733">		goto fail;</a>
<a name="ln3734">	}</a>
<a name="ln3735"> </a>
<a name="ln3736">	/* 5705 limits RX return ring to 512 entries. */</a>
<a name="ln3737">	if (BGE_IS_5717_PLUS(sc))</a>
<a name="ln3738">		sc-&gt;bge_return_ring_cnt = BGE_RETURN_RING_CNT;</a>
<a name="ln3739">	else if (BGE_IS_5705_PLUS(sc))</a>
<a name="ln3740">		sc-&gt;bge_return_ring_cnt = BGE_RETURN_RING_CNT_5705;</a>
<a name="ln3741">	else</a>
<a name="ln3742">		sc-&gt;bge_return_ring_cnt = BGE_RETURN_RING_CNT;</a>
<a name="ln3743"> </a>
<a name="ln3744">	if (bge_dma_alloc(sc)) {</a>
<a name="ln3745">		device_printf(sc-&gt;bge_dev,</a>
<a name="ln3746">		    &quot;failed to allocate DMA resources\n&quot;);</a>
<a name="ln3747">		error = ENXIO;</a>
<a name="ln3748">		goto fail;</a>
<a name="ln3749">	}</a>
<a name="ln3750"> </a>
<a name="ln3751">	/* Set default tuneable values. */</a>
<a name="ln3752">	sc-&gt;bge_stat_ticks = BGE_TICKS_PER_SEC;</a>
<a name="ln3753">	sc-&gt;bge_rx_coal_ticks = 150;</a>
<a name="ln3754">	sc-&gt;bge_tx_coal_ticks = 150;</a>
<a name="ln3755">	sc-&gt;bge_rx_max_coal_bds = 10;</a>
<a name="ln3756">	sc-&gt;bge_tx_max_coal_bds = 10;</a>
<a name="ln3757"> </a>
<a name="ln3758">	/* Initialize checksum features to use. */</a>
<a name="ln3759">	sc-&gt;bge_csum_features = BGE_CSUM_FEATURES;</a>
<a name="ln3760">	if (sc-&gt;bge_forced_udpcsum != 0)</a>
<a name="ln3761">		sc-&gt;bge_csum_features |= CSUM_UDP;</a>
<a name="ln3762"> </a>
<a name="ln3763">	/* Set up ifnet structure */</a>
<a name="ln3764">	ifp = sc-&gt;bge_ifp = if_alloc(IFT_ETHER);</a>
<a name="ln3765">	if (ifp == NULL) {</a>
<a name="ln3766">		device_printf(sc-&gt;bge_dev, &quot;failed to if_alloc()\n&quot;);</a>
<a name="ln3767">		error = ENXIO;</a>
<a name="ln3768">		goto fail;</a>
<a name="ln3769">	}</a>
<a name="ln3770">	if_setsoftc(ifp, sc);</a>
<a name="ln3771">	if_initname(ifp, device_get_name(dev), device_get_unit(dev));</a>
<a name="ln3772">	if_setflags(ifp, IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST);</a>
<a name="ln3773">	if_setioctlfn(ifp, bge_ioctl);</a>
<a name="ln3774">	if_setstartfn(ifp, bge_start);</a>
<a name="ln3775">	if_setinitfn(ifp, bge_init);</a>
<a name="ln3776">	if_setgetcounterfn(ifp, bge_get_counter);</a>
<a name="ln3777">	if_setsendqlen(ifp, BGE_TX_RING_CNT - 1);</a>
<a name="ln3778">	if_setsendqready(ifp);</a>
<a name="ln3779">	if_sethwassist(ifp, sc-&gt;bge_csum_features);</a>
<a name="ln3780">	if_setcapabilities(ifp, IFCAP_HWCSUM | IFCAP_VLAN_HWTAGGING |</a>
<a name="ln3781">	    IFCAP_VLAN_MTU);</a>
<a name="ln3782">	if ((sc-&gt;bge_flags &amp; (BGE_FLAG_TSO | BGE_FLAG_TSO3)) != 0) {</a>
<a name="ln3783">		if_sethwassistbits(ifp, CSUM_TSO, 0);</a>
<a name="ln3784">		if_setcapabilitiesbit(ifp, IFCAP_TSO4 | IFCAP_VLAN_HWTSO, 0);</a>
<a name="ln3785">	}</a>
<a name="ln3786">#ifdef IFCAP_VLAN_HWCSUM</a>
<a name="ln3787">	if_setcapabilitiesbit(ifp, IFCAP_VLAN_HWCSUM, 0);</a>
<a name="ln3788">#endif</a>
<a name="ln3789">	if_setcapenable(ifp, if_getcapabilities(ifp));</a>
<a name="ln3790">#ifdef DEVICE_POLLING</a>
<a name="ln3791">	if_setcapabilitiesbit(ifp, IFCAP_POLLING, 0);</a>
<a name="ln3792">#endif</a>
<a name="ln3793"> </a>
<a name="ln3794">	/*</a>
<a name="ln3795">	 * 5700 B0 chips do not support checksumming correctly due</a>
<a name="ln3796">	 * to hardware bugs.</a>
<a name="ln3797">	 */</a>
<a name="ln3798">	if (sc-&gt;bge_chipid == BGE_CHIPID_BCM5700_B0) {</a>
<a name="ln3799">		if_setcapabilitiesbit(ifp, 0, IFCAP_HWCSUM);</a>
<a name="ln3800">		if_setcapenablebit(ifp, 0, IFCAP_HWCSUM);</a>
<a name="ln3801">		if_sethwassist(ifp, 0);</a>
<a name="ln3802">	}</a>
<a name="ln3803"> </a>
<a name="ln3804">	/*</a>
<a name="ln3805">	 * Figure out what sort of media we have by checking the</a>
<a name="ln3806">	 * hardware config word in the first 32k of NIC internal memory,</a>
<a name="ln3807">	 * or fall back to examining the EEPROM if necessary.</a>
<a name="ln3808">	 * Note: on some BCM5700 cards, this value appears to be unset.</a>
<a name="ln3809">	 * If that's the case, we have to rely on identifying the NIC</a>
<a name="ln3810">	 * by its PCI subsystem ID, as we do below for the SysKonnect</a>
<a name="ln3811">	 * SK-9D41.</a>
<a name="ln3812">	 */</a>
<a name="ln3813">	if (bge_readmem_ind(sc, BGE_SRAM_DATA_SIG) == BGE_SRAM_DATA_SIG_MAGIC)</a>
<a name="ln3814">		hwcfg = bge_readmem_ind(sc, BGE_SRAM_DATA_CFG);</a>
<a name="ln3815">	else if ((sc-&gt;bge_flags &amp; BGE_FLAG_EADDR) &amp;&amp;</a>
<a name="ln3816">	    (sc-&gt;bge_asicrev != BGE_ASICREV_BCM5906)) {</a>
<a name="ln3817">		if (bge_read_eeprom(sc, (caddr_t)&amp;hwcfg, BGE_EE_HWCFG_OFFSET,</a>
<a name="ln3818">		    sizeof(hwcfg))) {</a>
<a name="ln3819">			device_printf(sc-&gt;bge_dev, &quot;failed to read EEPROM\n&quot;);</a>
<a name="ln3820">			error = ENXIO;</a>
<a name="ln3821">			goto fail;</a>
<a name="ln3822">		}</a>
<a name="ln3823">		hwcfg = ntohl(hwcfg);</a>
<a name="ln3824">	}</a>
<a name="ln3825"> </a>
<a name="ln3826">	/* The SysKonnect SK-9D41 is a 1000baseSX card. */</a>
<a name="ln3827">	if ((pci_read_config(dev, BGE_PCI_SUBSYS, 4) &gt;&gt; 16) ==</a>
<a name="ln3828">	    SK_SUBSYSID_9D41 || (hwcfg &amp; BGE_HWCFG_MEDIA) == BGE_MEDIA_FIBER) {</a>
<a name="ln3829">		if (BGE_IS_5705_PLUS(sc)) {</a>
<a name="ln3830">			sc-&gt;bge_flags |= BGE_FLAG_MII_SERDES;</a>
<a name="ln3831">			sc-&gt;bge_phy_flags |= BGE_PHY_NO_WIRESPEED;</a>
<a name="ln3832">		} else</a>
<a name="ln3833">			sc-&gt;bge_flags |= BGE_FLAG_TBI;</a>
<a name="ln3834">	}</a>
<a name="ln3835"> </a>
<a name="ln3836">	/* Set various PHY bug flags. */</a>
<a name="ln3837">	if (sc-&gt;bge_chipid == BGE_CHIPID_BCM5701_A0 ||</a>
<a name="ln3838">	    sc-&gt;bge_chipid == BGE_CHIPID_BCM5701_B0)</a>
<a name="ln3839">		sc-&gt;bge_phy_flags |= BGE_PHY_CRC_BUG;</a>
<a name="ln3840">	if (sc-&gt;bge_chiprev == BGE_CHIPREV_5703_AX ||</a>
<a name="ln3841">	    sc-&gt;bge_chiprev == BGE_CHIPREV_5704_AX)</a>
<a name="ln3842">		sc-&gt;bge_phy_flags |= BGE_PHY_ADC_BUG;</a>
<a name="ln3843">	if (sc-&gt;bge_chipid == BGE_CHIPID_BCM5704_A0)</a>
<a name="ln3844">		sc-&gt;bge_phy_flags |= BGE_PHY_5704_A0_BUG;</a>
<a name="ln3845">	if (pci_get_subvendor(dev) == DELL_VENDORID)</a>
<a name="ln3846">		sc-&gt;bge_phy_flags |= BGE_PHY_NO_3LED;</a>
<a name="ln3847">	if ((BGE_IS_5705_PLUS(sc)) &amp;&amp;</a>
<a name="ln3848">	    sc-&gt;bge_asicrev != BGE_ASICREV_BCM5906 &amp;&amp;</a>
<a name="ln3849">	    sc-&gt;bge_asicrev != BGE_ASICREV_BCM5785 &amp;&amp;</a>
<a name="ln3850">	    sc-&gt;bge_asicrev != BGE_ASICREV_BCM57780 &amp;&amp;</a>
<a name="ln3851">	    !BGE_IS_5717_PLUS(sc)) {</a>
<a name="ln3852">		if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5755 ||</a>
<a name="ln3853">		    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5761 ||</a>
<a name="ln3854">		    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5784 ||</a>
<a name="ln3855">		    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5787) {</a>
<a name="ln3856">			if (pci_get_device(dev) != BCOM_DEVICEID_BCM5722 &amp;&amp;</a>
<a name="ln3857">			    pci_get_device(dev) != BCOM_DEVICEID_BCM5756)</a>
<a name="ln3858">				sc-&gt;bge_phy_flags |= BGE_PHY_JITTER_BUG;</a>
<a name="ln3859">			if (pci_get_device(dev) == BCOM_DEVICEID_BCM5755M)</a>
<a name="ln3860">				sc-&gt;bge_phy_flags |= BGE_PHY_ADJUST_TRIM;</a>
<a name="ln3861">		} else</a>
<a name="ln3862">			sc-&gt;bge_phy_flags |= BGE_PHY_BER_BUG;</a>
<a name="ln3863">	}</a>
<a name="ln3864"> </a>
<a name="ln3865">	/*</a>
<a name="ln3866">	 * Don't enable Ethernet@WireSpeed for the 5700 or the</a>
<a name="ln3867">	 * 5705 A0 and A1 chips.</a>
<a name="ln3868">	 */</a>
<a name="ln3869">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5700 ||</a>
<a name="ln3870">	    (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5705 &amp;&amp;</a>
<a name="ln3871">	    (sc-&gt;bge_chipid != BGE_CHIPID_BCM5705_A0 &amp;&amp;</a>
<a name="ln3872">	    sc-&gt;bge_chipid != BGE_CHIPID_BCM5705_A1)))</a>
<a name="ln3873">		sc-&gt;bge_phy_flags |= BGE_PHY_NO_WIRESPEED;</a>
<a name="ln3874"> </a>
<a name="ln3875">	if (sc-&gt;bge_flags &amp; BGE_FLAG_TBI) {</a>
<a name="ln3876">		ifmedia_init(&amp;sc-&gt;bge_ifmedia, IFM_IMASK, bge_ifmedia_upd,</a>
<a name="ln3877">		    bge_ifmedia_sts);</a>
<a name="ln3878">		ifmedia_add(&amp;sc-&gt;bge_ifmedia, IFM_ETHER | IFM_1000_SX, 0, NULL);</a>
<a name="ln3879">		ifmedia_add(&amp;sc-&gt;bge_ifmedia, IFM_ETHER | IFM_1000_SX | IFM_FDX,</a>
<a name="ln3880">		    0, NULL);</a>
<a name="ln3881">		ifmedia_add(&amp;sc-&gt;bge_ifmedia, IFM_ETHER | IFM_AUTO, 0, NULL);</a>
<a name="ln3882">		ifmedia_set(&amp;sc-&gt;bge_ifmedia, IFM_ETHER | IFM_AUTO);</a>
<a name="ln3883">		sc-&gt;bge_ifmedia.ifm_media = sc-&gt;bge_ifmedia.ifm_cur-&gt;ifm_media;</a>
<a name="ln3884">	} else {</a>
<a name="ln3885">		/*</a>
<a name="ln3886">		 * Do transceiver setup and tell the firmware the</a>
<a name="ln3887">		 * driver is down so we can try to get access the</a>
<a name="ln3888">		 * probe if ASF is running.  Retry a couple of times</a>
<a name="ln3889">		 * if we get a conflict with the ASF firmware accessing</a>
<a name="ln3890">		 * the PHY.</a>
<a name="ln3891">		 */</a>
<a name="ln3892">		trys = 0;</a>
<a name="ln3893">		BGE_CLRBIT(sc, BGE_MODE_CTL, BGE_MODECTL_STACKUP);</a>
<a name="ln3894">again:</a>
<a name="ln3895">		bge_asf_driver_up(sc);</a>
<a name="ln3896"> </a>
<a name="ln3897">		error = mii_attach(dev, &amp;sc-&gt;bge_miibus, ifp, </a>
<a name="ln3898">		    (ifm_change_cb_t)bge_ifmedia_upd,</a>
<a name="ln3899">		    (ifm_stat_cb_t)bge_ifmedia_sts, capmask, sc-&gt;bge_phy_addr, </a>
<a name="ln3900">		    MII_OFFSET_ANY, MIIF_DOPAUSE);</a>
<a name="ln3901">		if (error != 0) {</a>
<a name="ln3902">			if (trys++ &lt; 4) {</a>
<a name="ln3903">				device_printf(sc-&gt;bge_dev, &quot;Try again\n&quot;);</a>
<a name="ln3904">				bge_miibus_writereg(sc-&gt;bge_dev,</a>
<a name="ln3905">				    sc-&gt;bge_phy_addr, MII_BMCR, BMCR_RESET);</a>
<a name="ln3906">				goto again;</a>
<a name="ln3907">			}</a>
<a name="ln3908">			device_printf(sc-&gt;bge_dev, &quot;attaching PHYs failed\n&quot;);</a>
<a name="ln3909">			goto fail;</a>
<a name="ln3910">		}</a>
<a name="ln3911"> </a>
<a name="ln3912">		/*</a>
<a name="ln3913">		 * Now tell the firmware we are going up after probing the PHY</a>
<a name="ln3914">		 */</a>
<a name="ln3915">		if (sc-&gt;bge_asf_mode &amp; ASF_STACKUP)</a>
<a name="ln3916">			BGE_SETBIT(sc, BGE_MODE_CTL, BGE_MODECTL_STACKUP);</a>
<a name="ln3917">	}</a>
<a name="ln3918"> </a>
<a name="ln3919">	/*</a>
<a name="ln3920">	 * When using the BCM5701 in PCI-X mode, data corruption has</a>
<a name="ln3921">	 * been observed in the first few bytes of some received packets.</a>
<a name="ln3922">	 * Aligning the packet buffer in memory eliminates the corruption.</a>
<a name="ln3923">	 * Unfortunately, this misaligns the packet payloads.  On platforms</a>
<a name="ln3924">	 * which do not support unaligned accesses, we will realign the</a>
<a name="ln3925">	 * payloads by copying the received packets.</a>
<a name="ln3926">	 */</a>
<a name="ln3927">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5701 &amp;&amp;</a>
<a name="ln3928">	    sc-&gt;bge_flags &amp; BGE_FLAG_PCIX)</a>
<a name="ln3929">                sc-&gt;bge_flags |= BGE_FLAG_RX_ALIGNBUG;</a>
<a name="ln3930"> </a>
<a name="ln3931">	/*</a>
<a name="ln3932">	 * Call MI attach routine.</a>
<a name="ln3933">	 */</a>
<a name="ln3934">	ether_ifattach(ifp, eaddr);</a>
<a name="ln3935"> </a>
<a name="ln3936">	/* Tell upper layer we support long frames. */</a>
<a name="ln3937">	if_setifheaderlen(ifp, sizeof(struct ether_vlan_header));</a>
<a name="ln3938"> </a>
<a name="ln3939">	/*</a>
<a name="ln3940">	 * Hookup IRQ last.</a>
<a name="ln3941">	 */</a>
<a name="ln3942">	if (BGE_IS_5755_PLUS(sc) &amp;&amp; sc-&gt;bge_flags &amp; BGE_FLAG_MSI) {</a>
<a name="ln3943">		/* Take advantage of single-shot MSI. */</a>
<a name="ln3944">		CSR_WRITE_4(sc, BGE_MSI_MODE, CSR_READ_4(sc, BGE_MSI_MODE) &amp;</a>
<a name="ln3945">		    ~BGE_MSIMODE_ONE_SHOT_DISABLE);</a>
<a name="ln3946">		sc-&gt;bge_tq = taskqueue_create_fast(&quot;bge_taskq&quot;, M_WAITOK,</a>
<a name="ln3947">		    taskqueue_thread_enqueue, &amp;sc-&gt;bge_tq);</a>
<a name="ln3948">		if (sc-&gt;bge_tq == NULL) {</a>
<a name="ln3949">			device_printf(dev, &quot;could not create taskqueue.\n&quot;);</a>
<a name="ln3950">			ether_ifdetach(ifp);</a>
<a name="ln3951">			error = ENOMEM;</a>
<a name="ln3952">			goto fail;</a>
<a name="ln3953">		}</a>
<a name="ln3954">		error = taskqueue_start_threads(&amp;sc-&gt;bge_tq, 1, PI_NET,</a>
<a name="ln3955">		    &quot;%s taskq&quot;, device_get_nameunit(sc-&gt;bge_dev));</a>
<a name="ln3956">		if (error != 0) {</a>
<a name="ln3957">			device_printf(dev, &quot;could not start threads.\n&quot;);</a>
<a name="ln3958">			ether_ifdetach(ifp);</a>
<a name="ln3959">			goto fail;</a>
<a name="ln3960">		}</a>
<a name="ln3961">		error = bus_setup_intr(dev, sc-&gt;bge_irq,</a>
<a name="ln3962">		    INTR_TYPE_NET | INTR_MPSAFE, bge_msi_intr, NULL, sc,</a>
<a name="ln3963">		    &amp;sc-&gt;bge_intrhand);</a>
<a name="ln3964">	} else</a>
<a name="ln3965">		error = bus_setup_intr(dev, sc-&gt;bge_irq,</a>
<a name="ln3966">		    INTR_TYPE_NET | INTR_MPSAFE, NULL, bge_intr, sc,</a>
<a name="ln3967">		    &amp;sc-&gt;bge_intrhand);</a>
<a name="ln3968"> </a>
<a name="ln3969">	if (error) {</a>
<a name="ln3970">		ether_ifdetach(ifp);</a>
<a name="ln3971">		device_printf(sc-&gt;bge_dev, &quot;couldn't set up irq\n&quot;);</a>
<a name="ln3972">		goto fail;</a>
<a name="ln3973">	}</a>
<a name="ln3974"> </a>
<a name="ln3975">	/* Attach driver netdump methods. */</a>
<a name="ln3976">	NETDUMP_SET(ifp, bge);</a>
<a name="ln3977"> </a>
<a name="ln3978">fail:</a>
<a name="ln3979">	if (error)</a>
<a name="ln3980">		bge_detach(dev);</a>
<a name="ln3981">	return (error);</a>
<a name="ln3982">}</a>
<a name="ln3983"> </a>
<a name="ln3984">static int</a>
<a name="ln3985">bge_detach(device_t dev)</a>
<a name="ln3986">{</a>
<a name="ln3987">	struct bge_softc *sc;</a>
<a name="ln3988">	if_t ifp;</a>
<a name="ln3989"> </a>
<a name="ln3990">	sc = device_get_softc(dev);</a>
<a name="ln3991">	ifp = sc-&gt;bge_ifp;</a>
<a name="ln3992"> </a>
<a name="ln3993">#ifdef DEVICE_POLLING</a>
<a name="ln3994">	if (if_getcapenable(ifp) &amp; IFCAP_POLLING)</a>
<a name="ln3995">		ether_poll_deregister(ifp);</a>
<a name="ln3996">#endif</a>
<a name="ln3997"> </a>
<a name="ln3998">	if (device_is_attached(dev)) {</a>
<a name="ln3999">		ether_ifdetach(ifp);</a>
<a name="ln4000">		BGE_LOCK(sc);</a>
<a name="ln4001">		bge_stop(sc);</a>
<a name="ln4002">		BGE_UNLOCK(sc);</a>
<a name="ln4003">		callout_drain(&amp;sc-&gt;bge_stat_ch);</a>
<a name="ln4004">	}</a>
<a name="ln4005"> </a>
<a name="ln4006">	if (sc-&gt;bge_tq)</a>
<a name="ln4007">		taskqueue_drain(sc-&gt;bge_tq, &amp;sc-&gt;bge_intr_task);</a>
<a name="ln4008"> </a>
<a name="ln4009">	if (sc-&gt;bge_flags &amp; BGE_FLAG_TBI)</a>
<a name="ln4010">		ifmedia_removeall(&amp;sc-&gt;bge_ifmedia);</a>
<a name="ln4011">	else if (sc-&gt;bge_miibus != NULL) {</a>
<a name="ln4012">		bus_generic_detach(dev);</a>
<a name="ln4013">		device_delete_child(dev, sc-&gt;bge_miibus);</a>
<a name="ln4014">	}</a>
<a name="ln4015"> </a>
<a name="ln4016">	bge_release_resources(sc);</a>
<a name="ln4017"> </a>
<a name="ln4018">	return (0);</a>
<a name="ln4019">}</a>
<a name="ln4020"> </a>
<a name="ln4021">static void</a>
<a name="ln4022">bge_release_resources(struct bge_softc *sc)</a>
<a name="ln4023">{</a>
<a name="ln4024">	device_t dev;</a>
<a name="ln4025"> </a>
<a name="ln4026">	dev = sc-&gt;bge_dev;</a>
<a name="ln4027"> </a>
<a name="ln4028">	if (sc-&gt;bge_tq != NULL)</a>
<a name="ln4029">		taskqueue_free(sc-&gt;bge_tq);</a>
<a name="ln4030"> </a>
<a name="ln4031">	if (sc-&gt;bge_intrhand != NULL)</a>
<a name="ln4032">		bus_teardown_intr(dev, sc-&gt;bge_irq, sc-&gt;bge_intrhand);</a>
<a name="ln4033"> </a>
<a name="ln4034">	if (sc-&gt;bge_irq != NULL) {</a>
<a name="ln4035">		bus_release_resource(dev, SYS_RES_IRQ,</a>
<a name="ln4036">		    rman_get_rid(sc-&gt;bge_irq), sc-&gt;bge_irq);</a>
<a name="ln4037">		pci_release_msi(dev);</a>
<a name="ln4038">	}</a>
<a name="ln4039"> </a>
<a name="ln4040">	if (sc-&gt;bge_res != NULL)</a>
<a name="ln4041">		bus_release_resource(dev, SYS_RES_MEMORY,</a>
<a name="ln4042">		    rman_get_rid(sc-&gt;bge_res), sc-&gt;bge_res);</a>
<a name="ln4043"> </a>
<a name="ln4044">	if (sc-&gt;bge_res2 != NULL)</a>
<a name="ln4045">		bus_release_resource(dev, SYS_RES_MEMORY,</a>
<a name="ln4046">		    rman_get_rid(sc-&gt;bge_res2), sc-&gt;bge_res2);</a>
<a name="ln4047"> </a>
<a name="ln4048">	if (sc-&gt;bge_ifp != NULL)</a>
<a name="ln4049">		if_free(sc-&gt;bge_ifp);</a>
<a name="ln4050"> </a>
<a name="ln4051">	bge_dma_free(sc);</a>
<a name="ln4052"> </a>
<a name="ln4053">	if (mtx_initialized(&amp;sc-&gt;bge_mtx))	/* XXX */</a>
<a name="ln4054">		BGE_LOCK_DESTROY(sc);</a>
<a name="ln4055">}</a>
<a name="ln4056"> </a>
<a name="ln4057">static int</a>
<a name="ln4058">bge_reset(struct bge_softc *sc)</a>
<a name="ln4059">{</a>
<a name="ln4060">	device_t dev;</a>
<a name="ln4061">	uint32_t cachesize, command, mac_mode, mac_mode_mask, reset, val;</a>
<a name="ln4062">	void (*write_op)(struct bge_softc *, int, int);</a>
<a name="ln4063">	uint16_t devctl;</a>
<a name="ln4064">	int i;</a>
<a name="ln4065"> </a>
<a name="ln4066">	dev = sc-&gt;bge_dev;</a>
<a name="ln4067"> </a>
<a name="ln4068">	mac_mode_mask = BGE_MACMODE_HALF_DUPLEX | BGE_MACMODE_PORTMODE;</a>
<a name="ln4069">	if ((sc-&gt;bge_mfw_flags &amp; BGE_MFW_ON_APE) != 0)</a>
<a name="ln4070">		mac_mode_mask |= BGE_MACMODE_APE_RX_EN | BGE_MACMODE_APE_TX_EN;</a>
<a name="ln4071">	mac_mode = CSR_READ_4(sc, BGE_MAC_MODE) &amp; mac_mode_mask;</a>
<a name="ln4072"> </a>
<a name="ln4073">	if (BGE_IS_575X_PLUS(sc) &amp;&amp; !BGE_IS_5714_FAMILY(sc) &amp;&amp;</a>
<a name="ln4074">	    (sc-&gt;bge_asicrev != BGE_ASICREV_BCM5906)) {</a>
<a name="ln4075">		if (sc-&gt;bge_flags &amp; BGE_FLAG_PCIE)</a>
<a name="ln4076">			write_op = bge_writemem_direct;</a>
<a name="ln4077">		else</a>
<a name="ln4078">			write_op = bge_writemem_ind;</a>
<a name="ln4079">	} else</a>
<a name="ln4080">		write_op = bge_writereg_ind;</a>
<a name="ln4081"> </a>
<a name="ln4082">	if (sc-&gt;bge_asicrev != BGE_ASICREV_BCM5700 &amp;&amp;</a>
<a name="ln4083">	    sc-&gt;bge_asicrev != BGE_ASICREV_BCM5701) {</a>
<a name="ln4084">		CSR_WRITE_4(sc, BGE_NVRAM_SWARB, BGE_NVRAMSWARB_SET1);</a>
<a name="ln4085">		for (i = 0; i &lt; 8000; i++) {</a>
<a name="ln4086">			if (CSR_READ_4(sc, BGE_NVRAM_SWARB) &amp;</a>
<a name="ln4087">			    BGE_NVRAMSWARB_GNT1)</a>
<a name="ln4088">				break;</a>
<a name="ln4089">			DELAY(20);</a>
<a name="ln4090">		}</a>
<a name="ln4091">		if (i == 8000) {</a>
<a name="ln4092">			if (bootverbose)</a>
<a name="ln4093">				device_printf(dev, &quot;NVRAM lock timedout!\n&quot;);</a>
<a name="ln4094">		}</a>
<a name="ln4095">	}</a>
<a name="ln4096">	/* Take APE lock when performing reset. */</a>
<a name="ln4097">	bge_ape_lock(sc, BGE_APE_LOCK_GRC);</a>
<a name="ln4098"> </a>
<a name="ln4099">	/* Save some important PCI state. */</a>
<a name="ln4100">	cachesize = pci_read_config(dev, BGE_PCI_CACHESZ, 4);</a>
<a name="ln4101">	command = pci_read_config(dev, BGE_PCI_CMD, 4);</a>
<a name="ln4102"> </a>
<a name="ln4103">	pci_write_config(dev, BGE_PCI_MISC_CTL,</a>
<a name="ln4104">	    BGE_PCIMISCCTL_INDIRECT_ACCESS | BGE_PCIMISCCTL_MASK_PCI_INTR |</a>
<a name="ln4105">	    BGE_HIF_SWAP_OPTIONS | BGE_PCIMISCCTL_PCISTATE_RW, 4);</a>
<a name="ln4106"> </a>
<a name="ln4107">	/* Disable fastboot on controllers that support it. */</a>
<a name="ln4108">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5752 ||</a>
<a name="ln4109">	    BGE_IS_5755_PLUS(sc)) {</a>
<a name="ln4110">		if (bootverbose)</a>
<a name="ln4111">			device_printf(dev, &quot;Disabling fastboot\n&quot;);</a>
<a name="ln4112">		CSR_WRITE_4(sc, BGE_FASTBOOT_PC, 0x0);</a>
<a name="ln4113">	}</a>
<a name="ln4114"> </a>
<a name="ln4115">	/*</a>
<a name="ln4116">	 * Write the magic number to SRAM at offset 0xB50.</a>
<a name="ln4117">	 * When firmware finishes its initialization it will</a>
<a name="ln4118">	 * write ~BGE_SRAM_FW_MB_MAGIC to the same location.</a>
<a name="ln4119">	 */</a>
<a name="ln4120">	bge_writemem_ind(sc, BGE_SRAM_FW_MB, BGE_SRAM_FW_MB_MAGIC);</a>
<a name="ln4121"> </a>
<a name="ln4122">	reset = BGE_MISCCFG_RESET_CORE_CLOCKS | BGE_32BITTIME_66MHZ;</a>
<a name="ln4123"> </a>
<a name="ln4124">	/* XXX: Broadcom Linux driver. */</a>
<a name="ln4125">	if (sc-&gt;bge_flags &amp; BGE_FLAG_PCIE) {</a>
<a name="ln4126">		if (sc-&gt;bge_asicrev != BGE_ASICREV_BCM5785 &amp;&amp;</a>
<a name="ln4127">		    (sc-&gt;bge_flags &amp; BGE_FLAG_5717_PLUS) == 0) {</a>
<a name="ln4128">			if (CSR_READ_4(sc, 0x7E2C) == 0x60)	/* PCIE 1.0 */</a>
<a name="ln4129">				CSR_WRITE_4(sc, 0x7E2C, 0x20);</a>
<a name="ln4130">		}</a>
<a name="ln4131">		if (sc-&gt;bge_chipid != BGE_CHIPID_BCM5750_A0) {</a>
<a name="ln4132">			/* Prevent PCIE link training during global reset */</a>
<a name="ln4133">			CSR_WRITE_4(sc, BGE_MISC_CFG, 1 &lt;&lt; 29);</a>
<a name="ln4134">			reset |= 1 &lt;&lt; 29;</a>
<a name="ln4135">		}</a>
<a name="ln4136">	}</a>
<a name="ln4137"> </a>
<a name="ln4138">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5906) {</a>
<a name="ln4139">		val = CSR_READ_4(sc, BGE_VCPU_STATUS);</a>
<a name="ln4140">		CSR_WRITE_4(sc, BGE_VCPU_STATUS,</a>
<a name="ln4141">		    val | BGE_VCPU_STATUS_DRV_RESET);</a>
<a name="ln4142">		val = CSR_READ_4(sc, BGE_VCPU_EXT_CTRL);</a>
<a name="ln4143">		CSR_WRITE_4(sc, BGE_VCPU_EXT_CTRL,</a>
<a name="ln4144">		    val &amp; ~BGE_VCPU_EXT_CTRL_HALT_CPU);</a>
<a name="ln4145">	}</a>
<a name="ln4146"> </a>
<a name="ln4147">	/*</a>
<a name="ln4148">	 * Set GPHY Power Down Override to leave GPHY</a>
<a name="ln4149">	 * powered up in D0 uninitialized.</a>
<a name="ln4150">	 */</a>
<a name="ln4151">	if (BGE_IS_5705_PLUS(sc) &amp;&amp;</a>
<a name="ln4152">	    (sc-&gt;bge_flags &amp; BGE_FLAG_CPMU_PRESENT) == 0)</a>
<a name="ln4153">		reset |= BGE_MISCCFG_GPHY_PD_OVERRIDE;</a>
<a name="ln4154"> </a>
<a name="ln4155">	/* Issue global reset */</a>
<a name="ln4156">	write_op(sc, BGE_MISC_CFG, reset);</a>
<a name="ln4157"> </a>
<a name="ln4158">	if (sc-&gt;bge_flags &amp; BGE_FLAG_PCIE)</a>
<a name="ln4159">		DELAY(100 * 1000);</a>
<a name="ln4160">	else</a>
<a name="ln4161">		DELAY(1000);</a>
<a name="ln4162"> </a>
<a name="ln4163">	/* XXX: Broadcom Linux driver. */</a>
<a name="ln4164">	if (sc-&gt;bge_flags &amp; BGE_FLAG_PCIE) {</a>
<a name="ln4165">		if (sc-&gt;bge_chipid == BGE_CHIPID_BCM5750_A0) {</a>
<a name="ln4166">			DELAY(500000); /* wait for link training to complete */</a>
<a name="ln4167">			val = pci_read_config(dev, 0xC4, 4);</a>
<a name="ln4168">			pci_write_config(dev, 0xC4, val | (1 &lt;&lt; 15), 4);</a>
<a name="ln4169">		}</a>
<a name="ln4170">		devctl = pci_read_config(dev,</a>
<a name="ln4171">		    sc-&gt;bge_expcap + PCIER_DEVICE_CTL, 2);</a>
<a name="ln4172">		/* Clear enable no snoop and disable relaxed ordering. */</a>
<a name="ln4173">		devctl &amp;= ~(PCIEM_CTL_RELAXED_ORD_ENABLE |</a>
<a name="ln4174">		    PCIEM_CTL_NOSNOOP_ENABLE);</a>
<a name="ln4175">		pci_write_config(dev, sc-&gt;bge_expcap + PCIER_DEVICE_CTL,</a>
<a name="ln4176">		    devctl, 2);</a>
<a name="ln4177">		pci_set_max_read_req(dev, sc-&gt;bge_expmrq);</a>
<a name="ln4178">		/* Clear error status. */</a>
<a name="ln4179">		pci_write_config(dev, sc-&gt;bge_expcap + PCIER_DEVICE_STA,</a>
<a name="ln4180">		    PCIEM_STA_CORRECTABLE_ERROR |</a>
<a name="ln4181">		    PCIEM_STA_NON_FATAL_ERROR | PCIEM_STA_FATAL_ERROR |</a>
<a name="ln4182">		    PCIEM_STA_UNSUPPORTED_REQ, 2);</a>
<a name="ln4183">	}</a>
<a name="ln4184"> </a>
<a name="ln4185">	/* Reset some of the PCI state that got zapped by reset. */</a>
<a name="ln4186">	pci_write_config(dev, BGE_PCI_MISC_CTL,</a>
<a name="ln4187">	    BGE_PCIMISCCTL_INDIRECT_ACCESS | BGE_PCIMISCCTL_MASK_PCI_INTR |</a>
<a name="ln4188">	    BGE_HIF_SWAP_OPTIONS | BGE_PCIMISCCTL_PCISTATE_RW, 4);</a>
<a name="ln4189">	val = BGE_PCISTATE_ROM_ENABLE | BGE_PCISTATE_ROM_RETRY_ENABLE;</a>
<a name="ln4190">	if (sc-&gt;bge_chipid == BGE_CHIPID_BCM5704_A0 &amp;&amp;</a>
<a name="ln4191">	    (sc-&gt;bge_flags &amp; BGE_FLAG_PCIX) != 0)</a>
<a name="ln4192">		val |= BGE_PCISTATE_RETRY_SAME_DMA;</a>
<a name="ln4193">	if ((sc-&gt;bge_mfw_flags &amp; BGE_MFW_ON_APE) != 0)</a>
<a name="ln4194">		val |= BGE_PCISTATE_ALLOW_APE_CTLSPC_WR |</a>
<a name="ln4195">		    BGE_PCISTATE_ALLOW_APE_SHMEM_WR |</a>
<a name="ln4196">		    BGE_PCISTATE_ALLOW_APE_PSPACE_WR;</a>
<a name="ln4197">	pci_write_config(dev, BGE_PCI_PCISTATE, val, 4);</a>
<a name="ln4198">	pci_write_config(dev, BGE_PCI_CACHESZ, cachesize, 4);</a>
<a name="ln4199">	pci_write_config(dev, BGE_PCI_CMD, command, 4);</a>
<a name="ln4200">	/*</a>
<a name="ln4201">	 * Disable PCI-X relaxed ordering to ensure status block update</a>
<a name="ln4202">	 * comes first then packet buffer DMA. Otherwise driver may</a>
<a name="ln4203">	 * read stale status block.</a>
<a name="ln4204">	 */</a>
<a name="ln4205">	if (sc-&gt;bge_flags &amp; BGE_FLAG_PCIX) {</a>
<a name="ln4206">		devctl = pci_read_config(dev,</a>
<a name="ln4207">		    sc-&gt;bge_pcixcap + PCIXR_COMMAND, 2);</a>
<a name="ln4208">		devctl &amp;= ~PCIXM_COMMAND_ERO;</a>
<a name="ln4209">		if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5703) {</a>
<a name="ln4210">			devctl &amp;= ~PCIXM_COMMAND_MAX_READ;</a>
<a name="ln4211">			devctl |= PCIXM_COMMAND_MAX_READ_2048;</a>
<a name="ln4212">		} else if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5704) {</a>
<a name="ln4213">			devctl &amp;= ~(PCIXM_COMMAND_MAX_SPLITS |</a>
<a name="ln4214">			    PCIXM_COMMAND_MAX_READ);</a>
<a name="ln4215">			devctl |= PCIXM_COMMAND_MAX_READ_2048;</a>
<a name="ln4216">		}</a>
<a name="ln4217">		pci_write_config(dev, sc-&gt;bge_pcixcap + PCIXR_COMMAND,</a>
<a name="ln4218">		    devctl, 2);</a>
<a name="ln4219">	}</a>
<a name="ln4220">	/* Re-enable MSI, if necessary, and enable the memory arbiter. */</a>
<a name="ln4221">	if (BGE_IS_5714_FAMILY(sc)) {</a>
<a name="ln4222">		/* This chip disables MSI on reset. */</a>
<a name="ln4223">		if (sc-&gt;bge_flags &amp; BGE_FLAG_MSI) {</a>
<a name="ln4224">			val = pci_read_config(dev,</a>
<a name="ln4225">			    sc-&gt;bge_msicap + PCIR_MSI_CTRL, 2);</a>
<a name="ln4226">			pci_write_config(dev,</a>
<a name="ln4227">			    sc-&gt;bge_msicap + PCIR_MSI_CTRL,</a>
<a name="ln4228">			    val | PCIM_MSICTRL_MSI_ENABLE, 2);</a>
<a name="ln4229">			val = CSR_READ_4(sc, BGE_MSI_MODE);</a>
<a name="ln4230">			CSR_WRITE_4(sc, BGE_MSI_MODE,</a>
<a name="ln4231">			    val | BGE_MSIMODE_ENABLE);</a>
<a name="ln4232">		}</a>
<a name="ln4233">		val = CSR_READ_4(sc, BGE_MARB_MODE);</a>
<a name="ln4234">		CSR_WRITE_4(sc, BGE_MARB_MODE, BGE_MARBMODE_ENABLE | val);</a>
<a name="ln4235">	} else</a>
<a name="ln4236">		CSR_WRITE_4(sc, BGE_MARB_MODE, BGE_MARBMODE_ENABLE);</a>
<a name="ln4237"> </a>
<a name="ln4238">	/* Fix up byte swapping. */</a>
<a name="ln4239">	CSR_WRITE_4(sc, BGE_MODE_CTL, bge_dma_swap_options(sc));</a>
<a name="ln4240"> </a>
<a name="ln4241">	val = CSR_READ_4(sc, BGE_MAC_MODE);</a>
<a name="ln4242">	val = (val &amp; ~mac_mode_mask) | mac_mode;</a>
<a name="ln4243">	CSR_WRITE_4(sc, BGE_MAC_MODE, val);</a>
<a name="ln4244">	DELAY(40);</a>
<a name="ln4245"> </a>
<a name="ln4246">	bge_ape_unlock(sc, BGE_APE_LOCK_GRC);</a>
<a name="ln4247"> </a>
<a name="ln4248">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5906) {</a>
<a name="ln4249">		for (i = 0; i &lt; BGE_TIMEOUT; i++) {</a>
<a name="ln4250">			val = CSR_READ_4(sc, BGE_VCPU_STATUS);</a>
<a name="ln4251">			if (val &amp; BGE_VCPU_STATUS_INIT_DONE)</a>
<a name="ln4252">				break;</a>
<a name="ln4253">			DELAY(100);</a>
<a name="ln4254">		}</a>
<a name="ln4255">		if (i == BGE_TIMEOUT) {</a>
<a name="ln4256">			device_printf(dev, &quot;reset timed out\n&quot;);</a>
<a name="ln4257">			return (1);</a>
<a name="ln4258">		}</a>
<a name="ln4259">	} else {</a>
<a name="ln4260">		/*</a>
<a name="ln4261">		 * Poll until we see the 1's complement of the magic number.</a>
<a name="ln4262">		 * This indicates that the firmware initialization is complete.</a>
<a name="ln4263">		 * We expect this to fail if no chip containing the Ethernet</a>
<a name="ln4264">		 * address is fitted though.</a>
<a name="ln4265">		 */</a>
<a name="ln4266">		for (i = 0; i &lt; BGE_TIMEOUT; i++) {</a>
<a name="ln4267">			DELAY(10);</a>
<a name="ln4268">			val = bge_readmem_ind(sc, BGE_SRAM_FW_MB);</a>
<a name="ln4269">			if (val == ~BGE_SRAM_FW_MB_MAGIC)</a>
<a name="ln4270">				break;</a>
<a name="ln4271">		}</a>
<a name="ln4272"> </a>
<a name="ln4273">		if ((sc-&gt;bge_flags &amp; BGE_FLAG_EADDR) &amp;&amp; i == BGE_TIMEOUT)</a>
<a name="ln4274">			device_printf(dev,</a>
<a name="ln4275">			    &quot;firmware handshake timed out, found 0x%08x\n&quot;,</a>
<a name="ln4276">			    val);</a>
<a name="ln4277">		/* BCM57765 A0 needs additional time before accessing. */</a>
<a name="ln4278">		if (sc-&gt;bge_chipid == BGE_CHIPID_BCM57765_A0)</a>
<a name="ln4279">			DELAY(10 * 1000);	/* XXX */</a>
<a name="ln4280">	}</a>
<a name="ln4281"> </a>
<a name="ln4282">	/*</a>
<a name="ln4283">	 * The 5704 in TBI mode apparently needs some special</a>
<a name="ln4284">	 * adjustment to insure the SERDES drive level is set</a>
<a name="ln4285">	 * to 1.2V.</a>
<a name="ln4286">	 */</a>
<a name="ln4287">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5704 &amp;&amp;</a>
<a name="ln4288">	    sc-&gt;bge_flags &amp; BGE_FLAG_TBI) {</a>
<a name="ln4289">		val = CSR_READ_4(sc, BGE_SERDES_CFG);</a>
<a name="ln4290">		val = (val &amp; ~0xFFF) | 0x880;</a>
<a name="ln4291">		CSR_WRITE_4(sc, BGE_SERDES_CFG, val);</a>
<a name="ln4292">	}</a>
<a name="ln4293"> </a>
<a name="ln4294">	/* XXX: Broadcom Linux driver. */</a>
<a name="ln4295">	if (sc-&gt;bge_flags &amp; BGE_FLAG_PCIE &amp;&amp;</a>
<a name="ln4296">	    !BGE_IS_5717_PLUS(sc) &amp;&amp;</a>
<a name="ln4297">	    sc-&gt;bge_chipid != BGE_CHIPID_BCM5750_A0 &amp;&amp;</a>
<a name="ln4298">	    sc-&gt;bge_asicrev != BGE_ASICREV_BCM5785) {</a>
<a name="ln4299">		/* Enable Data FIFO protection. */</a>
<a name="ln4300">		val = CSR_READ_4(sc, 0x7C00);</a>
<a name="ln4301">		CSR_WRITE_4(sc, 0x7C00, val | (1 &lt;&lt; 25));</a>
<a name="ln4302">	}</a>
<a name="ln4303"> </a>
<a name="ln4304">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5720)</a>
<a name="ln4305">		BGE_CLRBIT(sc, BGE_CPMU_CLCK_ORIDE,</a>
<a name="ln4306">		    CPMU_CLCK_ORIDE_MAC_ORIDE_EN);</a>
<a name="ln4307"> </a>
<a name="ln4308">	return (0);</a>
<a name="ln4309">}</a>
<a name="ln4310"> </a>
<a name="ln4311">static __inline void</a>
<a name="ln4312">bge_rxreuse_std(struct bge_softc *sc, int i)</a>
<a name="ln4313">{</a>
<a name="ln4314">	struct bge_rx_bd *r;</a>
<a name="ln4315"> </a>
<a name="ln4316">	r = &amp;sc-&gt;bge_ldata.bge_rx_std_ring[sc-&gt;bge_std];</a>
<a name="ln4317">	r-&gt;bge_flags = BGE_RXBDFLAG_END;</a>
<a name="ln4318">	r-&gt;bge_len = sc-&gt;bge_cdata.bge_rx_std_seglen[i];</a>
<a name="ln4319">	r-&gt;bge_idx = i;</a>
<a name="ln4320">	BGE_INC(sc-&gt;bge_std, BGE_STD_RX_RING_CNT);</a>
<a name="ln4321">}</a>
<a name="ln4322"> </a>
<a name="ln4323">static __inline void</a>
<a name="ln4324">bge_rxreuse_jumbo(struct bge_softc *sc, int i)</a>
<a name="ln4325">{</a>
<a name="ln4326">	struct bge_extrx_bd *r;</a>
<a name="ln4327"> </a>
<a name="ln4328">	r = &amp;sc-&gt;bge_ldata.bge_rx_jumbo_ring[sc-&gt;bge_jumbo];</a>
<a name="ln4329">	r-&gt;bge_flags = BGE_RXBDFLAG_JUMBO_RING | BGE_RXBDFLAG_END;</a>
<a name="ln4330">	r-&gt;bge_len0 = sc-&gt;bge_cdata.bge_rx_jumbo_seglen[i][0];</a>
<a name="ln4331">	r-&gt;bge_len1 = sc-&gt;bge_cdata.bge_rx_jumbo_seglen[i][1];</a>
<a name="ln4332">	r-&gt;bge_len2 = sc-&gt;bge_cdata.bge_rx_jumbo_seglen[i][2];</a>
<a name="ln4333">	r-&gt;bge_len3 = sc-&gt;bge_cdata.bge_rx_jumbo_seglen[i][3];</a>
<a name="ln4334">	r-&gt;bge_idx = i;</a>
<a name="ln4335">	BGE_INC(sc-&gt;bge_jumbo, BGE_JUMBO_RX_RING_CNT);</a>
<a name="ln4336">}</a>
<a name="ln4337"> </a>
<a name="ln4338">/*</a>
<a name="ln4339"> * Frame reception handling. This is called if there's a frame</a>
<a name="ln4340"> * on the receive return list.</a>
<a name="ln4341"> *</a>
<a name="ln4342"> * Note: we have to be able to handle two possibilities here:</a>
<a name="ln4343"> * 1) the frame is from the jumbo receive ring</a>
<a name="ln4344"> * 2) the frame is from the standard receive ring</a>
<a name="ln4345"> */</a>
<a name="ln4346"> </a>
<a name="ln4347">static int</a>
<a name="ln4348">bge_rxeof(struct bge_softc *sc, uint16_t rx_prod, int holdlck)</a>
<a name="ln4349">{</a>
<a name="ln4350">	if_t ifp;</a>
<a name="ln4351">	int rx_npkts = 0, stdcnt = 0, jumbocnt = 0;</a>
<a name="ln4352">	uint16_t rx_cons;</a>
<a name="ln4353"> </a>
<a name="ln4354">	rx_cons = sc-&gt;bge_rx_saved_considx;</a>
<a name="ln4355"> </a>
<a name="ln4356">	/* Nothing to do. */</a>
<a name="ln4357">	if (rx_cons == rx_prod)</a>
<a name="ln4358">		return (rx_npkts);</a>
<a name="ln4359"> </a>
<a name="ln4360">	ifp = sc-&gt;bge_ifp;</a>
<a name="ln4361"> </a>
<a name="ln4362">	bus_dmamap_sync(sc-&gt;bge_cdata.bge_rx_return_ring_tag,</a>
<a name="ln4363">	    sc-&gt;bge_cdata.bge_rx_return_ring_map, BUS_DMASYNC_POSTREAD);</a>
<a name="ln4364">	bus_dmamap_sync(sc-&gt;bge_cdata.bge_rx_std_ring_tag,</a>
<a name="ln4365">	    sc-&gt;bge_cdata.bge_rx_std_ring_map, BUS_DMASYNC_POSTWRITE);</a>
<a name="ln4366">	if (BGE_IS_JUMBO_CAPABLE(sc) &amp;&amp;</a>
<a name="ln4367">	    if_getmtu(ifp) + ETHER_HDR_LEN + ETHER_CRC_LEN + </a>
<a name="ln4368">	    ETHER_VLAN_ENCAP_LEN &gt; (MCLBYTES - ETHER_ALIGN))</a>
<a name="ln4369">		bus_dmamap_sync(sc-&gt;bge_cdata.bge_rx_jumbo_ring_tag,</a>
<a name="ln4370">		    sc-&gt;bge_cdata.bge_rx_jumbo_ring_map, BUS_DMASYNC_POSTWRITE);</a>
<a name="ln4371"> </a>
<a name="ln4372">	while (rx_cons != rx_prod) {</a>
<a name="ln4373">		struct bge_rx_bd	*cur_rx;</a>
<a name="ln4374">		uint32_t		rxidx;</a>
<a name="ln4375">		struct mbuf		*m = NULL;</a>
<a name="ln4376">		uint16_t		vlan_tag = 0;</a>
<a name="ln4377">		int			have_tag = 0;</a>
<a name="ln4378"> </a>
<a name="ln4379">#ifdef DEVICE_POLLING</a>
<a name="ln4380">		if (if_getcapenable(ifp) &amp; IFCAP_POLLING) {</a>
<a name="ln4381">			if (sc-&gt;rxcycles &lt;= 0)</a>
<a name="ln4382">				break;</a>
<a name="ln4383">			sc-&gt;rxcycles--;</a>
<a name="ln4384">		}</a>
<a name="ln4385">#endif</a>
<a name="ln4386"> </a>
<a name="ln4387">		cur_rx = &amp;sc-&gt;bge_ldata.bge_rx_return_ring[rx_cons];</a>
<a name="ln4388"> </a>
<a name="ln4389">		rxidx = cur_rx-&gt;bge_idx;</a>
<a name="ln4390">		BGE_INC(rx_cons, sc-&gt;bge_return_ring_cnt);</a>
<a name="ln4391"> </a>
<a name="ln4392">		if (if_getcapenable(ifp) &amp; IFCAP_VLAN_HWTAGGING &amp;&amp;</a>
<a name="ln4393">		    cur_rx-&gt;bge_flags &amp; BGE_RXBDFLAG_VLAN_TAG) {</a>
<a name="ln4394">			have_tag = 1;</a>
<a name="ln4395">			vlan_tag = cur_rx-&gt;bge_vlan_tag;</a>
<a name="ln4396">		}</a>
<a name="ln4397"> </a>
<a name="ln4398">		if (cur_rx-&gt;bge_flags &amp; BGE_RXBDFLAG_JUMBO_RING) {</a>
<a name="ln4399">			jumbocnt++;</a>
<a name="ln4400">			m = sc-&gt;bge_cdata.bge_rx_jumbo_chain[rxidx];</a>
<a name="ln4401">			if (cur_rx-&gt;bge_flags &amp; BGE_RXBDFLAG_ERROR) {</a>
<a name="ln4402">				bge_rxreuse_jumbo(sc, rxidx);</a>
<a name="ln4403">				continue;</a>
<a name="ln4404">			}</a>
<a name="ln4405">			if (bge_newbuf_jumbo(sc, rxidx) != 0) {</a>
<a name="ln4406">				bge_rxreuse_jumbo(sc, rxidx);</a>
<a name="ln4407">				if_inc_counter(ifp, IFCOUNTER_IQDROPS, 1);</a>
<a name="ln4408">				continue;</a>
<a name="ln4409">			}</a>
<a name="ln4410">			BGE_INC(sc-&gt;bge_jumbo, BGE_JUMBO_RX_RING_CNT);</a>
<a name="ln4411">		} else {</a>
<a name="ln4412">			stdcnt++;</a>
<a name="ln4413">			m = sc-&gt;bge_cdata.bge_rx_std_chain[rxidx];</a>
<a name="ln4414">			if (cur_rx-&gt;bge_flags &amp; BGE_RXBDFLAG_ERROR) {</a>
<a name="ln4415">				bge_rxreuse_std(sc, rxidx);</a>
<a name="ln4416">				continue;</a>
<a name="ln4417">			}</a>
<a name="ln4418">			if (bge_newbuf_std(sc, rxidx) != 0) {</a>
<a name="ln4419">				bge_rxreuse_std(sc, rxidx);</a>
<a name="ln4420">				if_inc_counter(ifp, IFCOUNTER_IQDROPS, 1);</a>
<a name="ln4421">				continue;</a>
<a name="ln4422">			}</a>
<a name="ln4423">			BGE_INC(sc-&gt;bge_std, BGE_STD_RX_RING_CNT);</a>
<a name="ln4424">		}</a>
<a name="ln4425"> </a>
<a name="ln4426">		if_inc_counter(ifp, IFCOUNTER_IPACKETS, 1);</a>
<a name="ln4427">#ifndef __NO_STRICT_ALIGNMENT</a>
<a name="ln4428">		/*</a>
<a name="ln4429">		 * For architectures with strict alignment we must make sure</a>
<a name="ln4430">		 * the payload is aligned.</a>
<a name="ln4431">		 */</a>
<a name="ln4432">		if (sc-&gt;bge_flags &amp; BGE_FLAG_RX_ALIGNBUG) {</a>
<a name="ln4433">			bcopy(m-&gt;m_data, m-&gt;m_data + ETHER_ALIGN,</a>
<a name="ln4434">			    cur_rx-&gt;bge_len);</a>
<a name="ln4435">			m-&gt;m_data += ETHER_ALIGN;</a>
<a name="ln4436">		}</a>
<a name="ln4437">#endif</a>
<a name="ln4438">		m-&gt;m_pkthdr.len = m-&gt;m_len = cur_rx-&gt;bge_len - ETHER_CRC_LEN;</a>
<a name="ln4439">		m-&gt;m_pkthdr.rcvif = ifp;</a>
<a name="ln4440"> </a>
<a name="ln4441">		if (if_getcapenable(ifp) &amp; IFCAP_RXCSUM)</a>
<a name="ln4442">			bge_rxcsum(sc, cur_rx, m);</a>
<a name="ln4443"> </a>
<a name="ln4444">		/*</a>
<a name="ln4445">		 * If we received a packet with a vlan tag,</a>
<a name="ln4446">		 * attach that information to the packet.</a>
<a name="ln4447">		 */</a>
<a name="ln4448">		if (have_tag) {</a>
<a name="ln4449">			m-&gt;m_pkthdr.ether_vtag = vlan_tag;</a>
<a name="ln4450">			m-&gt;m_flags |= M_VLANTAG;</a>
<a name="ln4451">		}</a>
<a name="ln4452"> </a>
<a name="ln4453">		if (holdlck != 0) {</a>
<a name="ln4454">			BGE_UNLOCK(sc);</a>
<a name="ln4455">			if_input(ifp, m);</a>
<a name="ln4456">			BGE_LOCK(sc);</a>
<a name="ln4457">		} else</a>
<a name="ln4458">			if_input(ifp, m);</a>
<a name="ln4459">		rx_npkts++;</a>
<a name="ln4460"> </a>
<a name="ln4461">		if (!(if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING))</a>
<a name="ln4462">			return (rx_npkts);</a>
<a name="ln4463">	}</a>
<a name="ln4464"> </a>
<a name="ln4465">	bus_dmamap_sync(sc-&gt;bge_cdata.bge_rx_return_ring_tag,</a>
<a name="ln4466">	    sc-&gt;bge_cdata.bge_rx_return_ring_map, BUS_DMASYNC_PREREAD);</a>
<a name="ln4467">	if (stdcnt &gt; 0)</a>
<a name="ln4468">		bus_dmamap_sync(sc-&gt;bge_cdata.bge_rx_std_ring_tag,</a>
<a name="ln4469">		    sc-&gt;bge_cdata.bge_rx_std_ring_map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln4470"> </a>
<a name="ln4471">	if (jumbocnt &gt; 0)</a>
<a name="ln4472">		bus_dmamap_sync(sc-&gt;bge_cdata.bge_rx_jumbo_ring_tag,</a>
<a name="ln4473">		    sc-&gt;bge_cdata.bge_rx_jumbo_ring_map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln4474"> </a>
<a name="ln4475">	sc-&gt;bge_rx_saved_considx = rx_cons;</a>
<a name="ln4476">	bge_writembx(sc, BGE_MBX_RX_CONS0_LO, sc-&gt;bge_rx_saved_considx);</a>
<a name="ln4477">	if (stdcnt)</a>
<a name="ln4478">		bge_writembx(sc, BGE_MBX_RX_STD_PROD_LO, (sc-&gt;bge_std +</a>
<a name="ln4479">		    BGE_STD_RX_RING_CNT - 1) % BGE_STD_RX_RING_CNT);</a>
<a name="ln4480">	if (jumbocnt)</a>
<a name="ln4481">		bge_writembx(sc, BGE_MBX_RX_JUMBO_PROD_LO, (sc-&gt;bge_jumbo +</a>
<a name="ln4482">		    BGE_JUMBO_RX_RING_CNT - 1) % BGE_JUMBO_RX_RING_CNT);</a>
<a name="ln4483">#ifdef notyet</a>
<a name="ln4484">	/*</a>
<a name="ln4485">	 * This register wraps very quickly under heavy packet drops.</a>
<a name="ln4486">	 * If you need correct statistics, you can enable this check.</a>
<a name="ln4487">	 */</a>
<a name="ln4488">	if (BGE_IS_5705_PLUS(sc))</a>
<a name="ln4489">		if_incierrors(ifp, CSR_READ_4(sc, BGE_RXLP_LOCSTAT_IFIN_DROPS));</a>
<a name="ln4490">#endif</a>
<a name="ln4491">	return (rx_npkts);</a>
<a name="ln4492">}</a>
<a name="ln4493"> </a>
<a name="ln4494">static void</a>
<a name="ln4495">bge_rxcsum(struct bge_softc *sc, struct bge_rx_bd *cur_rx, struct mbuf *m)</a>
<a name="ln4496">{</a>
<a name="ln4497"> </a>
<a name="ln4498">	if (BGE_IS_5717_PLUS(sc)) {</a>
<a name="ln4499">		if ((cur_rx-&gt;bge_flags &amp; BGE_RXBDFLAG_IPV6) == 0) {</a>
<a name="ln4500">			if (cur_rx-&gt;bge_flags &amp; BGE_RXBDFLAG_IP_CSUM) {</a>
<a name="ln4501">				m-&gt;m_pkthdr.csum_flags |= CSUM_IP_CHECKED;</a>
<a name="ln4502">				if ((cur_rx-&gt;bge_error_flag &amp;</a>
<a name="ln4503">				    BGE_RXERRFLAG_IP_CSUM_NOK) == 0)</a>
<a name="ln4504">					m-&gt;m_pkthdr.csum_flags |= CSUM_IP_VALID;</a>
<a name="ln4505">			}</a>
<a name="ln4506">			if (cur_rx-&gt;bge_flags &amp; BGE_RXBDFLAG_TCP_UDP_CSUM) {</a>
<a name="ln4507">				m-&gt;m_pkthdr.csum_data =</a>
<a name="ln4508">				    cur_rx-&gt;bge_tcp_udp_csum;</a>
<a name="ln4509">				m-&gt;m_pkthdr.csum_flags |= CSUM_DATA_VALID |</a>
<a name="ln4510">				    CSUM_PSEUDO_HDR;</a>
<a name="ln4511">			}</a>
<a name="ln4512">		}</a>
<a name="ln4513">	} else {</a>
<a name="ln4514">		if (cur_rx-&gt;bge_flags &amp; BGE_RXBDFLAG_IP_CSUM) {</a>
<a name="ln4515">			m-&gt;m_pkthdr.csum_flags |= CSUM_IP_CHECKED;</a>
<a name="ln4516">			if ((cur_rx-&gt;bge_ip_csum ^ 0xFFFF) == 0)</a>
<a name="ln4517">				m-&gt;m_pkthdr.csum_flags |= CSUM_IP_VALID;</a>
<a name="ln4518">		}</a>
<a name="ln4519">		if (cur_rx-&gt;bge_flags &amp; BGE_RXBDFLAG_TCP_UDP_CSUM &amp;&amp;</a>
<a name="ln4520">		    m-&gt;m_pkthdr.len &gt;= ETHER_MIN_NOPAD) {</a>
<a name="ln4521">			m-&gt;m_pkthdr.csum_data =</a>
<a name="ln4522">			    cur_rx-&gt;bge_tcp_udp_csum;</a>
<a name="ln4523">			m-&gt;m_pkthdr.csum_flags |= CSUM_DATA_VALID |</a>
<a name="ln4524">			    CSUM_PSEUDO_HDR;</a>
<a name="ln4525">		}</a>
<a name="ln4526">	}</a>
<a name="ln4527">}</a>
<a name="ln4528"> </a>
<a name="ln4529">static void</a>
<a name="ln4530">bge_txeof(struct bge_softc *sc, uint16_t tx_cons)</a>
<a name="ln4531">{</a>
<a name="ln4532">	struct bge_tx_bd *cur_tx;</a>
<a name="ln4533">	if_t ifp;</a>
<a name="ln4534"> </a>
<a name="ln4535">	BGE_LOCK_ASSERT(sc);</a>
<a name="ln4536"> </a>
<a name="ln4537">	/* Nothing to do. */</a>
<a name="ln4538">	if (sc-&gt;bge_tx_saved_considx == tx_cons)</a>
<a name="ln4539">		return;</a>
<a name="ln4540"> </a>
<a name="ln4541">	ifp = sc-&gt;bge_ifp;</a>
<a name="ln4542"> </a>
<a name="ln4543">	bus_dmamap_sync(sc-&gt;bge_cdata.bge_tx_ring_tag,</a>
<a name="ln4544">	    sc-&gt;bge_cdata.bge_tx_ring_map, BUS_DMASYNC_POSTWRITE);</a>
<a name="ln4545">	/*</a>
<a name="ln4546">	 * Go through our tx ring and free mbufs for those</a>
<a name="ln4547">	 * frames that have been sent.</a>
<a name="ln4548">	 */</a>
<a name="ln4549">	while (sc-&gt;bge_tx_saved_considx != tx_cons) {</a>
<a name="ln4550">		uint32_t		idx;</a>
<a name="ln4551"> </a>
<a name="ln4552">		idx = sc-&gt;bge_tx_saved_considx;</a>
<a name="ln4553">		cur_tx = &amp;sc-&gt;bge_ldata.bge_tx_ring[idx];</a>
<a name="ln4554">		if (cur_tx-&gt;bge_flags &amp; BGE_TXBDFLAG_END)</a>
<a name="ln4555">			if_inc_counter(ifp, IFCOUNTER_OPACKETS, 1);</a>
<a name="ln4556">		if (sc-&gt;bge_cdata.bge_tx_chain[idx] != NULL) {</a>
<a name="ln4557">			bus_dmamap_sync(sc-&gt;bge_cdata.bge_tx_mtag,</a>
<a name="ln4558">			    sc-&gt;bge_cdata.bge_tx_dmamap[idx],</a>
<a name="ln4559">			    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln4560">			bus_dmamap_unload(sc-&gt;bge_cdata.bge_tx_mtag,</a>
<a name="ln4561">			    sc-&gt;bge_cdata.bge_tx_dmamap[idx]);</a>
<a name="ln4562">			m_freem(sc-&gt;bge_cdata.bge_tx_chain[idx]);</a>
<a name="ln4563">			sc-&gt;bge_cdata.bge_tx_chain[idx] = NULL;</a>
<a name="ln4564">		}</a>
<a name="ln4565">		sc-&gt;bge_txcnt--;</a>
<a name="ln4566">		BGE_INC(sc-&gt;bge_tx_saved_considx, BGE_TX_RING_CNT);</a>
<a name="ln4567">	}</a>
<a name="ln4568"> </a>
<a name="ln4569">	if_setdrvflagbits(ifp, 0, IFF_DRV_OACTIVE);</a>
<a name="ln4570">	if (sc-&gt;bge_txcnt == 0)</a>
<a name="ln4571">		sc-&gt;bge_timer = 0;</a>
<a name="ln4572">}</a>
<a name="ln4573"> </a>
<a name="ln4574">#ifdef DEVICE_POLLING</a>
<a name="ln4575">static int</a>
<a name="ln4576">bge_poll(if_t ifp, enum poll_cmd cmd, int count)</a>
<a name="ln4577">{</a>
<a name="ln4578">	struct bge_softc *sc = if_getsoftc(ifp);</a>
<a name="ln4579">	uint16_t rx_prod, tx_cons;</a>
<a name="ln4580">	uint32_t statusword;</a>
<a name="ln4581">	int rx_npkts = 0;</a>
<a name="ln4582"> </a>
<a name="ln4583">	BGE_LOCK(sc);</a>
<a name="ln4584">	if (!(if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING)) {</a>
<a name="ln4585">		BGE_UNLOCK(sc);</a>
<a name="ln4586">		return (rx_npkts);</a>
<a name="ln4587">	}</a>
<a name="ln4588"> </a>
<a name="ln4589">	bus_dmamap_sync(sc-&gt;bge_cdata.bge_status_tag,</a>
<a name="ln4590">	    sc-&gt;bge_cdata.bge_status_map,</a>
<a name="ln4591">	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);</a>
<a name="ln4592">	/* Fetch updates from the status block. */</a>
<a name="ln4593">	rx_prod = sc-&gt;bge_ldata.bge_status_block-&gt;bge_idx[0].bge_rx_prod_idx;</a>
<a name="ln4594">	tx_cons = sc-&gt;bge_ldata.bge_status_block-&gt;bge_idx[0].bge_tx_cons_idx;</a>
<a name="ln4595"> </a>
<a name="ln4596">	statusword = sc-&gt;bge_ldata.bge_status_block-&gt;bge_status;</a>
<a name="ln4597">	/* Clear the status so the next pass only sees the changes. */</a>
<a name="ln4598">	sc-&gt;bge_ldata.bge_status_block-&gt;bge_status = 0;</a>
<a name="ln4599"> </a>
<a name="ln4600">	bus_dmamap_sync(sc-&gt;bge_cdata.bge_status_tag,</a>
<a name="ln4601">	    sc-&gt;bge_cdata.bge_status_map,</a>
<a name="ln4602">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln4603"> </a>
<a name="ln4604">	/* Note link event. It will be processed by POLL_AND_CHECK_STATUS. */</a>
<a name="ln4605">	if (statusword &amp; BGE_STATFLAG_LINKSTATE_CHANGED)</a>
<a name="ln4606">		sc-&gt;bge_link_evt++;</a>
<a name="ln4607"> </a>
<a name="ln4608">	if (cmd == POLL_AND_CHECK_STATUS)</a>
<a name="ln4609">		if ((sc-&gt;bge_asicrev == BGE_ASICREV_BCM5700 &amp;&amp;</a>
<a name="ln4610">		    sc-&gt;bge_chipid != BGE_CHIPID_BCM5700_B2) ||</a>
<a name="ln4611">		    sc-&gt;bge_link_evt || (sc-&gt;bge_flags &amp; BGE_FLAG_TBI))</a>
<a name="ln4612">			bge_link_upd(sc);</a>
<a name="ln4613"> </a>
<a name="ln4614">	sc-&gt;rxcycles = count;</a>
<a name="ln4615">	rx_npkts = bge_rxeof(sc, rx_prod, 1);</a>
<a name="ln4616">	if (!(if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING)) {</a>
<a name="ln4617">		BGE_UNLOCK(sc);</a>
<a name="ln4618">		return (rx_npkts);</a>
<a name="ln4619">	}</a>
<a name="ln4620">	bge_txeof(sc, tx_cons);</a>
<a name="ln4621">	if (!if_sendq_empty(ifp))</a>
<a name="ln4622">		bge_start_locked(ifp);</a>
<a name="ln4623"> </a>
<a name="ln4624">	BGE_UNLOCK(sc);</a>
<a name="ln4625">	return (rx_npkts);</a>
<a name="ln4626">}</a>
<a name="ln4627">#endif /* DEVICE_POLLING */</a>
<a name="ln4628"> </a>
<a name="ln4629">static int</a>
<a name="ln4630">bge_msi_intr(void *arg)</a>
<a name="ln4631">{</a>
<a name="ln4632">	struct bge_softc *sc;</a>
<a name="ln4633"> </a>
<a name="ln4634">	sc = (struct bge_softc *)arg;</a>
<a name="ln4635">	/*</a>
<a name="ln4636">	 * This interrupt is not shared and controller already</a>
<a name="ln4637">	 * disabled further interrupt.</a>
<a name="ln4638">	 */</a>
<a name="ln4639">	taskqueue_enqueue(sc-&gt;bge_tq, &amp;sc-&gt;bge_intr_task);</a>
<a name="ln4640">	return (FILTER_HANDLED);</a>
<a name="ln4641">}</a>
<a name="ln4642"> </a>
<a name="ln4643">static void</a>
<a name="ln4644">bge_intr_task(void *arg, int pending)</a>
<a name="ln4645">{</a>
<a name="ln4646">	struct bge_softc *sc;</a>
<a name="ln4647">	if_t ifp;</a>
<a name="ln4648">	uint32_t status, status_tag;</a>
<a name="ln4649">	uint16_t rx_prod, tx_cons;</a>
<a name="ln4650"> </a>
<a name="ln4651">	sc = (struct bge_softc *)arg;</a>
<a name="ln4652">	ifp = sc-&gt;bge_ifp;</a>
<a name="ln4653"> </a>
<a name="ln4654">	BGE_LOCK(sc);</a>
<a name="ln4655">	if ((if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING) == 0) {</a>
<a name="ln4656">		BGE_UNLOCK(sc);</a>
<a name="ln4657">		return;</a>
<a name="ln4658">	}</a>
<a name="ln4659"> </a>
<a name="ln4660">	/* Get updated status block. */</a>
<a name="ln4661">	bus_dmamap_sync(sc-&gt;bge_cdata.bge_status_tag,</a>
<a name="ln4662">	    sc-&gt;bge_cdata.bge_status_map,</a>
<a name="ln4663">	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);</a>
<a name="ln4664"> </a>
<a name="ln4665">	/* Save producer/consumer indices. */</a>
<a name="ln4666">	rx_prod = sc-&gt;bge_ldata.bge_status_block-&gt;bge_idx[0].bge_rx_prod_idx;</a>
<a name="ln4667">	tx_cons = sc-&gt;bge_ldata.bge_status_block-&gt;bge_idx[0].bge_tx_cons_idx;</a>
<a name="ln4668">	status = sc-&gt;bge_ldata.bge_status_block-&gt;bge_status;</a>
<a name="ln4669">	status_tag = sc-&gt;bge_ldata.bge_status_block-&gt;bge_status_tag &lt;&lt; 24;</a>
<a name="ln4670">	/* Dirty the status flag. */</a>
<a name="ln4671">	sc-&gt;bge_ldata.bge_status_block-&gt;bge_status = 0;</a>
<a name="ln4672">	bus_dmamap_sync(sc-&gt;bge_cdata.bge_status_tag,</a>
<a name="ln4673">	    sc-&gt;bge_cdata.bge_status_map,</a>
<a name="ln4674">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln4675">	if ((sc-&gt;bge_flags &amp; BGE_FLAG_TAGGED_STATUS) == 0)</a>
<a name="ln4676">		status_tag = 0;</a>
<a name="ln4677"> </a>
<a name="ln4678">	if ((status &amp; BGE_STATFLAG_LINKSTATE_CHANGED) != 0)</a>
<a name="ln4679">		bge_link_upd(sc);</a>
<a name="ln4680"> </a>
<a name="ln4681">	/* Let controller work. */</a>
<a name="ln4682">	bge_writembx(sc, BGE_MBX_IRQ0_LO, status_tag);</a>
<a name="ln4683"> </a>
<a name="ln4684">	if (if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING &amp;&amp;</a>
<a name="ln4685">	    sc-&gt;bge_rx_saved_considx != rx_prod) {</a>
<a name="ln4686">		/* Check RX return ring producer/consumer. */</a>
<a name="ln4687">		BGE_UNLOCK(sc);</a>
<a name="ln4688">		bge_rxeof(sc, rx_prod, 0);</a>
<a name="ln4689">		BGE_LOCK(sc);</a>
<a name="ln4690">	}</a>
<a name="ln4691">	if (if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING) {</a>
<a name="ln4692">		/* Check TX ring producer/consumer. */</a>
<a name="ln4693">		bge_txeof(sc, tx_cons);</a>
<a name="ln4694">		if (!if_sendq_empty(ifp))</a>
<a name="ln4695">			bge_start_locked(ifp);</a>
<a name="ln4696">	}</a>
<a name="ln4697">	BGE_UNLOCK(sc);</a>
<a name="ln4698">}</a>
<a name="ln4699"> </a>
<a name="ln4700">static void</a>
<a name="ln4701">bge_intr(void *xsc)</a>
<a name="ln4702">{</a>
<a name="ln4703">	struct bge_softc *sc;</a>
<a name="ln4704">	if_t ifp;</a>
<a name="ln4705">	uint32_t statusword;</a>
<a name="ln4706">	uint16_t rx_prod, tx_cons;</a>
<a name="ln4707"> </a>
<a name="ln4708">	sc = xsc;</a>
<a name="ln4709"> </a>
<a name="ln4710">	BGE_LOCK(sc);</a>
<a name="ln4711"> </a>
<a name="ln4712">	ifp = sc-&gt;bge_ifp;</a>
<a name="ln4713"> </a>
<a name="ln4714">#ifdef DEVICE_POLLING</a>
<a name="ln4715">	if (if_getcapenable(ifp) &amp; IFCAP_POLLING) {</a>
<a name="ln4716">		BGE_UNLOCK(sc);</a>
<a name="ln4717">		return;</a>
<a name="ln4718">	}</a>
<a name="ln4719">#endif</a>
<a name="ln4720"> </a>
<a name="ln4721">	/*</a>
<a name="ln4722">	 * Ack the interrupt by writing something to BGE_MBX_IRQ0_LO.  Don't</a>
<a name="ln4723">	 * disable interrupts by writing nonzero like we used to, since with</a>
<a name="ln4724">	 * our current organization this just gives complications and</a>
<a name="ln4725">	 * pessimizations for re-enabling interrupts.  We used to have races</a>
<a name="ln4726">	 * instead of the necessary complications.  Disabling interrupts</a>
<a name="ln4727">	 * would just reduce the chance of a status update while we are</a>
<a name="ln4728">	 * running (by switching to the interrupt-mode coalescence</a>
<a name="ln4729">	 * parameters), but this chance is already very low so it is more</a>
<a name="ln4730">	 * efficient to get another interrupt than prevent it.</a>
<a name="ln4731">	 *</a>
<a name="ln4732">	 * We do the ack first to ensure another interrupt if there is a</a>
<a name="ln4733">	 * status update after the ack.  We don't check for the status</a>
<a name="ln4734">	 * changing later because it is more efficient to get another</a>
<a name="ln4735">	 * interrupt than prevent it, not quite as above (not checking is</a>
<a name="ln4736">	 * a smaller optimization than not toggling the interrupt enable,</a>
<a name="ln4737">	 * since checking doesn't involve PCI accesses and toggling require</a>
<a name="ln4738">	 * the status check).  So toggling would probably be a pessimization</a>
<a name="ln4739">	 * even with MSI.  It would only be needed for using a task queue.</a>
<a name="ln4740">	 */</a>
<a name="ln4741">	bge_writembx(sc, BGE_MBX_IRQ0_LO, 0);</a>
<a name="ln4742"> </a>
<a name="ln4743">	/*</a>
<a name="ln4744">	 * Do the mandatory PCI flush as well as get the link status.</a>
<a name="ln4745">	 */</a>
<a name="ln4746">	statusword = CSR_READ_4(sc, BGE_MAC_STS) &amp; BGE_MACSTAT_LINK_CHANGED;</a>
<a name="ln4747"> </a>
<a name="ln4748">	/* Make sure the descriptor ring indexes are coherent. */</a>
<a name="ln4749">	bus_dmamap_sync(sc-&gt;bge_cdata.bge_status_tag,</a>
<a name="ln4750">	    sc-&gt;bge_cdata.bge_status_map,</a>
<a name="ln4751">	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);</a>
<a name="ln4752">	rx_prod = sc-&gt;bge_ldata.bge_status_block-&gt;bge_idx[0].bge_rx_prod_idx;</a>
<a name="ln4753">	tx_cons = sc-&gt;bge_ldata.bge_status_block-&gt;bge_idx[0].bge_tx_cons_idx;</a>
<a name="ln4754">	sc-&gt;bge_ldata.bge_status_block-&gt;bge_status = 0;</a>
<a name="ln4755">	bus_dmamap_sync(sc-&gt;bge_cdata.bge_status_tag,</a>
<a name="ln4756">	    sc-&gt;bge_cdata.bge_status_map,</a>
<a name="ln4757">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln4758"> </a>
<a name="ln4759">	if ((sc-&gt;bge_asicrev == BGE_ASICREV_BCM5700 &amp;&amp;</a>
<a name="ln4760">	    sc-&gt;bge_chipid != BGE_CHIPID_BCM5700_B2) ||</a>
<a name="ln4761">	    statusword || sc-&gt;bge_link_evt)</a>
<a name="ln4762">		bge_link_upd(sc);</a>
<a name="ln4763"> </a>
<a name="ln4764">	if (if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING) {</a>
<a name="ln4765">		/* Check RX return ring producer/consumer. */</a>
<a name="ln4766">		bge_rxeof(sc, rx_prod, 1);</a>
<a name="ln4767">	}</a>
<a name="ln4768"> </a>
<a name="ln4769">	if (if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING) {</a>
<a name="ln4770">		/* Check TX ring producer/consumer. */</a>
<a name="ln4771">		bge_txeof(sc, tx_cons);</a>
<a name="ln4772">	}</a>
<a name="ln4773"> </a>
<a name="ln4774">	if (if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING &amp;&amp;</a>
<a name="ln4775">	    !if_sendq_empty(ifp))</a>
<a name="ln4776">		bge_start_locked(ifp);</a>
<a name="ln4777"> </a>
<a name="ln4778">	BGE_UNLOCK(sc);</a>
<a name="ln4779">}</a>
<a name="ln4780"> </a>
<a name="ln4781">static void</a>
<a name="ln4782">bge_asf_driver_up(struct bge_softc *sc)</a>
<a name="ln4783">{</a>
<a name="ln4784">	if (sc-&gt;bge_asf_mode &amp; ASF_STACKUP) {</a>
<a name="ln4785">		/* Send ASF heartbeat aprox. every 2s */</a>
<a name="ln4786">		if (sc-&gt;bge_asf_count)</a>
<a name="ln4787">			sc-&gt;bge_asf_count --;</a>
<a name="ln4788">		else {</a>
<a name="ln4789">			sc-&gt;bge_asf_count = 2;</a>
<a name="ln4790">			bge_writemem_ind(sc, BGE_SRAM_FW_CMD_MB,</a>
<a name="ln4791">			    BGE_FW_CMD_DRV_ALIVE);</a>
<a name="ln4792">			bge_writemem_ind(sc, BGE_SRAM_FW_CMD_LEN_MB, 4);</a>
<a name="ln4793">			bge_writemem_ind(sc, BGE_SRAM_FW_CMD_DATA_MB,</a>
<a name="ln4794">			    BGE_FW_HB_TIMEOUT_SEC);</a>
<a name="ln4795">			CSR_WRITE_4(sc, BGE_RX_CPU_EVENT,</a>
<a name="ln4796">			    CSR_READ_4(sc, BGE_RX_CPU_EVENT) |</a>
<a name="ln4797">			    BGE_RX_CPU_DRV_EVENT);</a>
<a name="ln4798">		}</a>
<a name="ln4799">	}</a>
<a name="ln4800">}</a>
<a name="ln4801"> </a>
<a name="ln4802">static void</a>
<a name="ln4803">bge_tick(void *xsc)</a>
<a name="ln4804">{</a>
<a name="ln4805">	struct bge_softc *sc = xsc;</a>
<a name="ln4806">	struct mii_data *mii = NULL;</a>
<a name="ln4807"> </a>
<a name="ln4808">	BGE_LOCK_ASSERT(sc);</a>
<a name="ln4809"> </a>
<a name="ln4810">	/* Synchronize with possible callout reset/stop. */</a>
<a name="ln4811">	if (callout_pending(&amp;sc-&gt;bge_stat_ch) ||</a>
<a name="ln4812">	    !callout_active(&amp;sc-&gt;bge_stat_ch))</a>
<a name="ln4813">		return;</a>
<a name="ln4814"> </a>
<a name="ln4815">	if (BGE_IS_5705_PLUS(sc))</a>
<a name="ln4816">		bge_stats_update_regs(sc);</a>
<a name="ln4817">	else</a>
<a name="ln4818">		bge_stats_update(sc);</a>
<a name="ln4819"> </a>
<a name="ln4820">	/* XXX Add APE heartbeat check here? */</a>
<a name="ln4821"> </a>
<a name="ln4822">	if ((sc-&gt;bge_flags &amp; BGE_FLAG_TBI) == 0) {</a>
<a name="ln4823">		mii = device_get_softc(sc-&gt;bge_miibus);</a>
<a name="ln4824">		/*</a>
<a name="ln4825">		 * Do not touch PHY if we have link up. This could break</a>
<a name="ln4826">		 * IPMI/ASF mode or produce extra input errors</a>
<a name="ln4827">		 * (extra errors was reported for bcm5701 &amp; bcm5704).</a>
<a name="ln4828">		 */</a>
<a name="ln4829">		if (!sc-&gt;bge_link)</a>
<a name="ln4830">			mii_tick(mii);</a>
<a name="ln4831">	} else {</a>
<a name="ln4832">		/*</a>
<a name="ln4833">		 * Since in TBI mode auto-polling can't be used we should poll</a>
<a name="ln4834">		 * link status manually. Here we register pending link event</a>
<a name="ln4835">		 * and trigger interrupt.</a>
<a name="ln4836">		 */</a>
<a name="ln4837">#ifdef DEVICE_POLLING</a>
<a name="ln4838">		/* In polling mode we poll link state in bge_poll(). */</a>
<a name="ln4839">		if (!(if_getcapenable(sc-&gt;bge_ifp) &amp; IFCAP_POLLING))</a>
<a name="ln4840">#endif</a>
<a name="ln4841">		{</a>
<a name="ln4842">		sc-&gt;bge_link_evt++;</a>
<a name="ln4843">		if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5700 ||</a>
<a name="ln4844">		    sc-&gt;bge_flags &amp; BGE_FLAG_5788)</a>
<a name="ln4845">			BGE_SETBIT(sc, BGE_MISC_LOCAL_CTL, BGE_MLC_INTR_SET);</a>
<a name="ln4846">		else</a>
<a name="ln4847">			BGE_SETBIT(sc, BGE_HCC_MODE, BGE_HCCMODE_COAL_NOW);</a>
<a name="ln4848">		}</a>
<a name="ln4849">	}</a>
<a name="ln4850"> </a>
<a name="ln4851">	bge_asf_driver_up(sc);</a>
<a name="ln4852">	bge_watchdog(sc);</a>
<a name="ln4853"> </a>
<a name="ln4854">	callout_reset(&amp;sc-&gt;bge_stat_ch, hz, bge_tick, sc);</a>
<a name="ln4855">}</a>
<a name="ln4856"> </a>
<a name="ln4857">static void</a>
<a name="ln4858">bge_stats_update_regs(struct bge_softc *sc)</a>
<a name="ln4859">{</a>
<a name="ln4860">	if_t ifp;</a>
<a name="ln4861">	struct bge_mac_stats *stats;</a>
<a name="ln4862">	uint32_t val;</a>
<a name="ln4863"> </a>
<a name="ln4864">	ifp = sc-&gt;bge_ifp;</a>
<a name="ln4865">	stats = &amp;sc-&gt;bge_mac_stats;</a>
<a name="ln4866"> </a>
<a name="ln4867">	stats-&gt;ifHCOutOctets +=</a>
<a name="ln4868">	    CSR_READ_4(sc, BGE_TX_MAC_STATS_OCTETS);</a>
<a name="ln4869">	stats-&gt;etherStatsCollisions +=</a>
<a name="ln4870">	    CSR_READ_4(sc, BGE_TX_MAC_STATS_COLLS);</a>
<a name="ln4871">	stats-&gt;outXonSent +=</a>
<a name="ln4872">	    CSR_READ_4(sc, BGE_TX_MAC_STATS_XON_SENT);</a>
<a name="ln4873">	stats-&gt;outXoffSent +=</a>
<a name="ln4874">	    CSR_READ_4(sc, BGE_TX_MAC_STATS_XOFF_SENT);</a>
<a name="ln4875">	stats-&gt;dot3StatsInternalMacTransmitErrors +=</a>
<a name="ln4876">	    CSR_READ_4(sc, BGE_TX_MAC_STATS_ERRORS);</a>
<a name="ln4877">	stats-&gt;dot3StatsSingleCollisionFrames +=</a>
<a name="ln4878">	    CSR_READ_4(sc, BGE_TX_MAC_STATS_SINGLE_COLL);</a>
<a name="ln4879">	stats-&gt;dot3StatsMultipleCollisionFrames +=</a>
<a name="ln4880">	    CSR_READ_4(sc, BGE_TX_MAC_STATS_MULTI_COLL);</a>
<a name="ln4881">	stats-&gt;dot3StatsDeferredTransmissions +=</a>
<a name="ln4882">	    CSR_READ_4(sc, BGE_TX_MAC_STATS_DEFERRED);</a>
<a name="ln4883">	stats-&gt;dot3StatsExcessiveCollisions +=</a>
<a name="ln4884">	    CSR_READ_4(sc, BGE_TX_MAC_STATS_EXCESS_COLL);</a>
<a name="ln4885">	stats-&gt;dot3StatsLateCollisions +=</a>
<a name="ln4886">	    CSR_READ_4(sc, BGE_TX_MAC_STATS_LATE_COLL);</a>
<a name="ln4887">	stats-&gt;ifHCOutUcastPkts +=</a>
<a name="ln4888">	    CSR_READ_4(sc, BGE_TX_MAC_STATS_UCAST);</a>
<a name="ln4889">	stats-&gt;ifHCOutMulticastPkts +=</a>
<a name="ln4890">	    CSR_READ_4(sc, BGE_TX_MAC_STATS_MCAST);</a>
<a name="ln4891">	stats-&gt;ifHCOutBroadcastPkts +=</a>
<a name="ln4892">	    CSR_READ_4(sc, BGE_TX_MAC_STATS_BCAST);</a>
<a name="ln4893"> </a>
<a name="ln4894">	stats-&gt;ifHCInOctets +=</a>
<a name="ln4895">	    CSR_READ_4(sc, BGE_RX_MAC_STATS_OCTESTS);</a>
<a name="ln4896">	stats-&gt;etherStatsFragments +=</a>
<a name="ln4897">	    CSR_READ_4(sc, BGE_RX_MAC_STATS_FRAGMENTS);</a>
<a name="ln4898">	stats-&gt;ifHCInUcastPkts +=</a>
<a name="ln4899">	    CSR_READ_4(sc, BGE_RX_MAC_STATS_UCAST);</a>
<a name="ln4900">	stats-&gt;ifHCInMulticastPkts +=</a>
<a name="ln4901">	    CSR_READ_4(sc, BGE_RX_MAC_STATS_MCAST);</a>
<a name="ln4902">	stats-&gt;ifHCInBroadcastPkts +=</a>
<a name="ln4903">	    CSR_READ_4(sc, BGE_RX_MAC_STATS_BCAST);</a>
<a name="ln4904">	stats-&gt;dot3StatsFCSErrors +=</a>
<a name="ln4905">	    CSR_READ_4(sc, BGE_RX_MAC_STATS_FCS_ERRORS);</a>
<a name="ln4906">	stats-&gt;dot3StatsAlignmentErrors +=</a>
<a name="ln4907">	    CSR_READ_4(sc, BGE_RX_MAC_STATS_ALGIN_ERRORS);</a>
<a name="ln4908">	stats-&gt;xonPauseFramesReceived +=</a>
<a name="ln4909">	    CSR_READ_4(sc, BGE_RX_MAC_STATS_XON_RCVD);</a>
<a name="ln4910">	stats-&gt;xoffPauseFramesReceived +=</a>
<a name="ln4911">	    CSR_READ_4(sc, BGE_RX_MAC_STATS_XOFF_RCVD);</a>
<a name="ln4912">	stats-&gt;macControlFramesReceived +=</a>
<a name="ln4913">	    CSR_READ_4(sc, BGE_RX_MAC_STATS_CTRL_RCVD);</a>
<a name="ln4914">	stats-&gt;xoffStateEntered +=</a>
<a name="ln4915">	    CSR_READ_4(sc, BGE_RX_MAC_STATS_XOFF_ENTERED);</a>
<a name="ln4916">	stats-&gt;dot3StatsFramesTooLong +=</a>
<a name="ln4917">	    CSR_READ_4(sc, BGE_RX_MAC_STATS_FRAME_TOO_LONG);</a>
<a name="ln4918">	stats-&gt;etherStatsJabbers +=</a>
<a name="ln4919">	    CSR_READ_4(sc, BGE_RX_MAC_STATS_JABBERS);</a>
<a name="ln4920">	stats-&gt;etherStatsUndersizePkts +=</a>
<a name="ln4921">	    CSR_READ_4(sc, BGE_RX_MAC_STATS_UNDERSIZE);</a>
<a name="ln4922"> </a>
<a name="ln4923">	stats-&gt;FramesDroppedDueToFilters +=</a>
<a name="ln4924">	    CSR_READ_4(sc, BGE_RXLP_LOCSTAT_FILTDROP);</a>
<a name="ln4925">	stats-&gt;DmaWriteQueueFull +=</a>
<a name="ln4926">	    CSR_READ_4(sc, BGE_RXLP_LOCSTAT_DMA_WRQ_FULL);</a>
<a name="ln4927">	stats-&gt;DmaWriteHighPriQueueFull +=</a>
<a name="ln4928">	    CSR_READ_4(sc, BGE_RXLP_LOCSTAT_DMA_HPWRQ_FULL);</a>
<a name="ln4929">	stats-&gt;NoMoreRxBDs +=</a>
<a name="ln4930">	    CSR_READ_4(sc, BGE_RXLP_LOCSTAT_OUT_OF_BDS);</a>
<a name="ln4931">	/*</a>
<a name="ln4932">	 * XXX</a>
<a name="ln4933">	 * Unlike other controllers, BGE_RXLP_LOCSTAT_IFIN_DROPS</a>
<a name="ln4934">	 * counter of BCM5717, BCM5718, BCM5719 A0 and BCM5720 A0</a>
<a name="ln4935">	 * includes number of unwanted multicast frames.  This comes</a>
<a name="ln4936">	 * from silicon bug and known workaround to get rough(not</a>
<a name="ln4937">	 * exact) counter is to enable interrupt on MBUF low water</a>
<a name="ln4938">	 * attention.  This can be accomplished by setting</a>
<a name="ln4939">	 * BGE_HCCMODE_ATTN bit of BGE_HCC_MODE,</a>
<a name="ln4940">	 * BGE_BMANMODE_LOMBUF_ATTN bit of BGE_BMAN_MODE and</a>
<a name="ln4941">	 * BGE_MODECTL_FLOWCTL_ATTN_INTR bit of BGE_MODE_CTL.</a>
<a name="ln4942">	 * However that change would generate more interrupts and</a>
<a name="ln4943">	 * there are still possibilities of losing multiple frames</a>
<a name="ln4944">	 * during BGE_MODECTL_FLOWCTL_ATTN_INTR interrupt handling.</a>
<a name="ln4945">	 * Given that the workaround still would not get correct</a>
<a name="ln4946">	 * counter I don't think it's worth to implement it.  So</a>
<a name="ln4947">	 * ignore reading the counter on controllers that have the</a>
<a name="ln4948">	 * silicon bug.</a>
<a name="ln4949">	 */</a>
<a name="ln4950">	if (sc-&gt;bge_asicrev != BGE_ASICREV_BCM5717 &amp;&amp;</a>
<a name="ln4951">	    sc-&gt;bge_chipid != BGE_CHIPID_BCM5719_A0 &amp;&amp;</a>
<a name="ln4952">	    sc-&gt;bge_chipid != BGE_CHIPID_BCM5720_A0)</a>
<a name="ln4953">		stats-&gt;InputDiscards +=</a>
<a name="ln4954">		    CSR_READ_4(sc, BGE_RXLP_LOCSTAT_IFIN_DROPS);</a>
<a name="ln4955">	stats-&gt;InputErrors +=</a>
<a name="ln4956">	    CSR_READ_4(sc, BGE_RXLP_LOCSTAT_IFIN_ERRORS);</a>
<a name="ln4957">	stats-&gt;RecvThresholdHit +=</a>
<a name="ln4958">	    CSR_READ_4(sc, BGE_RXLP_LOCSTAT_RXTHRESH_HIT);</a>
<a name="ln4959"> </a>
<a name="ln4960">	if (sc-&gt;bge_flags &amp; BGE_FLAG_RDMA_BUG) {</a>
<a name="ln4961">		/*</a>
<a name="ln4962">		 * If controller transmitted more than BGE_NUM_RDMA_CHANNELS</a>
<a name="ln4963">		 * frames, it's safe to disable workaround for DMA engine's</a>
<a name="ln4964">		 * miscalculation of TXMBUF space.</a>
<a name="ln4965">		 */</a>
<a name="ln4966">		if (stats-&gt;ifHCOutUcastPkts + stats-&gt;ifHCOutMulticastPkts +</a>
<a name="ln4967">		    stats-&gt;ifHCOutBroadcastPkts &gt; BGE_NUM_RDMA_CHANNELS) {</a>
<a name="ln4968">			val = CSR_READ_4(sc, BGE_RDMA_LSO_CRPTEN_CTRL);</a>
<a name="ln4969">			if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5719)</a>
<a name="ln4970">				val &amp;= ~BGE_RDMA_TX_LENGTH_WA_5719;</a>
<a name="ln4971">			else</a>
<a name="ln4972">				val &amp;= ~BGE_RDMA_TX_LENGTH_WA_5720;</a>
<a name="ln4973">			CSR_WRITE_4(sc, BGE_RDMA_LSO_CRPTEN_CTRL, val);</a>
<a name="ln4974">			sc-&gt;bge_flags &amp;= ~BGE_FLAG_RDMA_BUG;</a>
<a name="ln4975">		}</a>
<a name="ln4976">	}</a>
<a name="ln4977">}</a>
<a name="ln4978"> </a>
<a name="ln4979">static void</a>
<a name="ln4980">bge_stats_clear_regs(struct bge_softc *sc)</a>
<a name="ln4981">{</a>
<a name="ln4982"> </a>
<a name="ln4983">	CSR_READ_4(sc, BGE_TX_MAC_STATS_OCTETS);</a>
<a name="ln4984">	CSR_READ_4(sc, BGE_TX_MAC_STATS_COLLS);</a>
<a name="ln4985">	CSR_READ_4(sc, BGE_TX_MAC_STATS_XON_SENT);</a>
<a name="ln4986">	CSR_READ_4(sc, BGE_TX_MAC_STATS_XOFF_SENT);</a>
<a name="ln4987">	CSR_READ_4(sc, BGE_TX_MAC_STATS_ERRORS);</a>
<a name="ln4988">	CSR_READ_4(sc, BGE_TX_MAC_STATS_SINGLE_COLL);</a>
<a name="ln4989">	CSR_READ_4(sc, BGE_TX_MAC_STATS_MULTI_COLL);</a>
<a name="ln4990">	CSR_READ_4(sc, BGE_TX_MAC_STATS_DEFERRED);</a>
<a name="ln4991">	CSR_READ_4(sc, BGE_TX_MAC_STATS_EXCESS_COLL);</a>
<a name="ln4992">	CSR_READ_4(sc, BGE_TX_MAC_STATS_LATE_COLL);</a>
<a name="ln4993">	CSR_READ_4(sc, BGE_TX_MAC_STATS_UCAST);</a>
<a name="ln4994">	CSR_READ_4(sc, BGE_TX_MAC_STATS_MCAST);</a>
<a name="ln4995">	CSR_READ_4(sc, BGE_TX_MAC_STATS_BCAST);</a>
<a name="ln4996"> </a>
<a name="ln4997">	CSR_READ_4(sc, BGE_RX_MAC_STATS_OCTESTS);</a>
<a name="ln4998">	CSR_READ_4(sc, BGE_RX_MAC_STATS_FRAGMENTS);</a>
<a name="ln4999">	CSR_READ_4(sc, BGE_RX_MAC_STATS_UCAST);</a>
<a name="ln5000">	CSR_READ_4(sc, BGE_RX_MAC_STATS_MCAST);</a>
<a name="ln5001">	CSR_READ_4(sc, BGE_RX_MAC_STATS_BCAST);</a>
<a name="ln5002">	CSR_READ_4(sc, BGE_RX_MAC_STATS_FCS_ERRORS);</a>
<a name="ln5003">	CSR_READ_4(sc, BGE_RX_MAC_STATS_ALGIN_ERRORS);</a>
<a name="ln5004">	CSR_READ_4(sc, BGE_RX_MAC_STATS_XON_RCVD);</a>
<a name="ln5005">	CSR_READ_4(sc, BGE_RX_MAC_STATS_XOFF_RCVD);</a>
<a name="ln5006">	CSR_READ_4(sc, BGE_RX_MAC_STATS_CTRL_RCVD);</a>
<a name="ln5007">	CSR_READ_4(sc, BGE_RX_MAC_STATS_XOFF_ENTERED);</a>
<a name="ln5008">	CSR_READ_4(sc, BGE_RX_MAC_STATS_FRAME_TOO_LONG);</a>
<a name="ln5009">	CSR_READ_4(sc, BGE_RX_MAC_STATS_JABBERS);</a>
<a name="ln5010">	CSR_READ_4(sc, BGE_RX_MAC_STATS_UNDERSIZE);</a>
<a name="ln5011"> </a>
<a name="ln5012">	CSR_READ_4(sc, BGE_RXLP_LOCSTAT_FILTDROP);</a>
<a name="ln5013">	CSR_READ_4(sc, BGE_RXLP_LOCSTAT_DMA_WRQ_FULL);</a>
<a name="ln5014">	CSR_READ_4(sc, BGE_RXLP_LOCSTAT_DMA_HPWRQ_FULL);</a>
<a name="ln5015">	CSR_READ_4(sc, BGE_RXLP_LOCSTAT_OUT_OF_BDS);</a>
<a name="ln5016">	CSR_READ_4(sc, BGE_RXLP_LOCSTAT_IFIN_DROPS);</a>
<a name="ln5017">	CSR_READ_4(sc, BGE_RXLP_LOCSTAT_IFIN_ERRORS);</a>
<a name="ln5018">	CSR_READ_4(sc, BGE_RXLP_LOCSTAT_RXTHRESH_HIT);</a>
<a name="ln5019">}</a>
<a name="ln5020"> </a>
<a name="ln5021">static void</a>
<a name="ln5022">bge_stats_update(struct bge_softc *sc)</a>
<a name="ln5023">{</a>
<a name="ln5024">	if_t ifp;</a>
<a name="ln5025">	bus_size_t stats;</a>
<a name="ln5026">	uint32_t cnt;	/* current register value */</a>
<a name="ln5027"> </a>
<a name="ln5028">	ifp = sc-&gt;bge_ifp;</a>
<a name="ln5029"> </a>
<a name="ln5030">	stats = BGE_MEMWIN_START + BGE_STATS_BLOCK;</a>
<a name="ln5031"> </a>
<a name="ln5032">#define	READ_STAT(sc, stats, stat) \</a>
<a name="ln5033">	CSR_READ_4(sc, stats + offsetof(struct bge_stats, stat))</a>
<a name="ln5034"> </a>
<a name="ln5035">	cnt = READ_STAT(sc, stats, txstats.etherStatsCollisions.bge_addr_lo);</a>
<a name="ln5036">	if_inc_counter(ifp, IFCOUNTER_COLLISIONS, cnt - sc-&gt;bge_tx_collisions);</a>
<a name="ln5037">	sc-&gt;bge_tx_collisions = cnt;</a>
<a name="ln5038"> </a>
<a name="ln5039">	cnt = READ_STAT(sc, stats, nicNoMoreRxBDs.bge_addr_lo);</a>
<a name="ln5040">	if_inc_counter(ifp, IFCOUNTER_IERRORS, cnt - sc-&gt;bge_rx_nobds);</a>
<a name="ln5041">	sc-&gt;bge_rx_nobds = cnt;</a>
<a name="ln5042">	cnt = READ_STAT(sc, stats, ifInErrors.bge_addr_lo);</a>
<a name="ln5043">	if_inc_counter(ifp, IFCOUNTER_IERRORS, cnt - sc-&gt;bge_rx_inerrs);</a>
<a name="ln5044">	sc-&gt;bge_rx_inerrs = cnt;</a>
<a name="ln5045">	cnt = READ_STAT(sc, stats, ifInDiscards.bge_addr_lo);</a>
<a name="ln5046">	if_inc_counter(ifp, IFCOUNTER_IERRORS, cnt - sc-&gt;bge_rx_discards);</a>
<a name="ln5047">	sc-&gt;bge_rx_discards = cnt;</a>
<a name="ln5048"> </a>
<a name="ln5049">	cnt = READ_STAT(sc, stats, txstats.ifOutDiscards.bge_addr_lo);</a>
<a name="ln5050">	if_inc_counter(ifp, IFCOUNTER_OERRORS, cnt - sc-&gt;bge_tx_discards);</a>
<a name="ln5051">	sc-&gt;bge_tx_discards = cnt;</a>
<a name="ln5052"> </a>
<a name="ln5053">#undef	READ_STAT</a>
<a name="ln5054">}</a>
<a name="ln5055"> </a>
<a name="ln5056">/*</a>
<a name="ln5057"> * Pad outbound frame to ETHER_MIN_NOPAD for an unusual reason.</a>
<a name="ln5058"> * The bge hardware will pad out Tx runts to ETHER_MIN_NOPAD,</a>
<a name="ln5059"> * but when such padded frames employ the bge IP/TCP checksum offload,</a>
<a name="ln5060"> * the hardware checksum assist gives incorrect results (possibly</a>
<a name="ln5061"> * from incorporating its own padding into the UDP/TCP checksum; who knows).</a>
<a name="ln5062"> * If we pad such runts with zeros, the onboard checksum comes out correct.</a>
<a name="ln5063"> */</a>
<a name="ln5064">static __inline int</a>
<a name="ln5065">bge_cksum_pad(struct mbuf *m)</a>
<a name="ln5066">{</a>
<a name="ln5067">	int padlen = ETHER_MIN_NOPAD - m-&gt;m_pkthdr.len;</a>
<a name="ln5068">	struct mbuf *last;</a>
<a name="ln5069"> </a>
<a name="ln5070">	/* If there's only the packet-header and we can pad there, use it. */</a>
<a name="ln5071">	if (m-&gt;m_pkthdr.len == m-&gt;m_len &amp;&amp; M_WRITABLE(m) &amp;&amp;</a>
<a name="ln5072">	    M_TRAILINGSPACE(m) &gt;= padlen) {</a>
<a name="ln5073">		last = m;</a>
<a name="ln5074">	} else {</a>
<a name="ln5075">		/*</a>
<a name="ln5076">		 * Walk packet chain to find last mbuf. We will either</a>
<a name="ln5077">		 * pad there, or append a new mbuf and pad it.</a>
<a name="ln5078">		 */</a>
<a name="ln5079">		for (last = m; last-&gt;m_next != NULL; last = last-&gt;m_next);</a>
<a name="ln5080">		if (!(M_WRITABLE(last) &amp;&amp; M_TRAILINGSPACE(last) &gt;= padlen)) {</a>
<a name="ln5081">			/* Allocate new empty mbuf, pad it. Compact later. */</a>
<a name="ln5082">			struct mbuf *n;</a>
<a name="ln5083"> </a>
<a name="ln5084">			MGET(n, M_NOWAIT, MT_DATA);</a>
<a name="ln5085">			if (n == NULL)</a>
<a name="ln5086">				return (ENOBUFS);</a>
<a name="ln5087">			n-&gt;m_len = 0;</a>
<a name="ln5088">			last-&gt;m_next = n;</a>
<a name="ln5089">			last = n;</a>
<a name="ln5090">		}</a>
<a name="ln5091">	}</a>
<a name="ln5092"> </a>
<a name="ln5093">	/* Now zero the pad area, to avoid the bge cksum-assist bug. */</a>
<a name="ln5094">	memset(mtod(last, caddr_t) + last-&gt;m_len, 0, padlen);</a>
<a name="ln5095">	last-&gt;m_len += padlen;</a>
<a name="ln5096">	m-&gt;m_pkthdr.len += padlen;</a>
<a name="ln5097"> </a>
<a name="ln5098">	return (0);</a>
<a name="ln5099">}</a>
<a name="ln5100"> </a>
<a name="ln5101">static struct mbuf *</a>
<a name="ln5102">bge_check_short_dma(struct mbuf *m)</a>
<a name="ln5103">{</a>
<a name="ln5104">	struct mbuf *n;</a>
<a name="ln5105">	int found;</a>
<a name="ln5106"> </a>
<a name="ln5107">	/*</a>
<a name="ln5108">	 * If device receive two back-to-back send BDs with less than</a>
<a name="ln5109">	 * or equal to 8 total bytes then the device may hang.  The two</a>
<a name="ln5110">	 * back-to-back send BDs must in the same frame for this failure</a>
<a name="ln5111">	 * to occur.  Scan mbuf chains and see whether two back-to-back</a>
<a name="ln5112">	 * send BDs are there. If this is the case, allocate new mbuf</a>
<a name="ln5113">	 * and copy the frame to workaround the silicon bug.</a>
<a name="ln5114">	 */</a>
<a name="ln5115">	for (n = m, found = 0; n != NULL; n = n-&gt;m_next) {</a>
<a name="ln5116">		if (n-&gt;m_len &lt; 8) {</a>
<a name="ln5117">			found++;</a>
<a name="ln5118">			if (found &gt; 1)</a>
<a name="ln5119">				break;</a>
<a name="ln5120">			continue;</a>
<a name="ln5121">		}</a>
<a name="ln5122">		found = 0;</a>
<a name="ln5123">	}</a>
<a name="ln5124"> </a>
<a name="ln5125">	if (found &gt; 1) {</a>
<a name="ln5126">		n = m_defrag(m, M_NOWAIT);</a>
<a name="ln5127">		if (n == NULL)</a>
<a name="ln5128">			m_freem(m);</a>
<a name="ln5129">	} else</a>
<a name="ln5130">		n = m;</a>
<a name="ln5131">	return (n);</a>
<a name="ln5132">}</a>
<a name="ln5133"> </a>
<a name="ln5134">static struct mbuf *</a>
<a name="ln5135">bge_setup_tso(struct bge_softc *sc, struct mbuf *m, uint16_t *mss,</a>
<a name="ln5136">    uint16_t *flags)</a>
<a name="ln5137">{</a>
<a name="ln5138">	struct ip *ip;</a>
<a name="ln5139">	struct tcphdr *tcp;</a>
<a name="ln5140">	struct mbuf *n;</a>
<a name="ln5141">	uint16_t hlen;</a>
<a name="ln5142">	uint32_t poff;</a>
<a name="ln5143"> </a>
<a name="ln5144">	if (M_WRITABLE(m) == 0) {</a>
<a name="ln5145">		/* Get a writable copy. */</a>
<a name="ln5146">		n = m_dup(m, M_NOWAIT);</a>
<a name="ln5147">		m_freem(m);</a>
<a name="ln5148">		if (n == NULL)</a>
<a name="ln5149">			return (NULL);</a>
<a name="ln5150">		m = n;</a>
<a name="ln5151">	}</a>
<a name="ln5152">	m = m_pullup(m, sizeof(struct ether_header) + sizeof(struct ip));</a>
<a name="ln5153">	if (m == NULL)</a>
<a name="ln5154">		return (NULL);</a>
<a name="ln5155">	ip = (struct ip *)(mtod(m, char *) + sizeof(struct ether_header));</a>
<a name="ln5156">	poff = sizeof(struct ether_header) + (ip-&gt;ip_hl &lt;&lt; 2);</a>
<a name="ln5157">	m = m_pullup(m, poff + sizeof(struct tcphdr));</a>
<a name="ln5158">	if (m == NULL)</a>
<a name="ln5159">		return (NULL);</a>
<a name="ln5160">	tcp = (struct tcphdr *)(mtod(m, char *) + poff);</a>
<a name="ln5161">	m = m_pullup(m, poff + (tcp-&gt;th_off &lt;&lt; 2));</a>
<a name="ln5162">	if (m == NULL)</a>
<a name="ln5163">		return (NULL);</a>
<a name="ln5164">	/*</a>
<a name="ln5165">	 * It seems controller doesn't modify IP length and TCP pseudo</a>
<a name="ln5166">	 * checksum. These checksum computed by upper stack should be 0.</a>
<a name="ln5167">	 */</a>
<a name="ln5168">	*mss = m-&gt;m_pkthdr.tso_segsz;</a>
<a name="ln5169">	ip = (struct ip *)(mtod(m, char *) + sizeof(struct ether_header));</a>
<a name="ln5170">	ip-&gt;ip_sum = 0;</a>
<a name="ln5171">	ip-&gt;ip_len = htons(*mss + (ip-&gt;ip_hl &lt;&lt; 2) + (tcp-&gt;th_off &lt;&lt; 2));</a>
<a name="ln5172">	/* Clear pseudo checksum computed by TCP stack. */</a>
<a name="ln5173">	tcp = (struct tcphdr *)(mtod(m, char *) + poff);</a>
<a name="ln5174">	tcp-&gt;th_sum = 0;</a>
<a name="ln5175">	/*</a>
<a name="ln5176">	 * Broadcom controllers uses different descriptor format for</a>
<a name="ln5177">	 * TSO depending on ASIC revision. Due to TSO-capable firmware</a>
<a name="ln5178">	 * license issue and lower performance of firmware based TSO</a>
<a name="ln5179">	 * we only support hardware based TSO.</a>
<a name="ln5180">	 */</a>
<a name="ln5181">	/* Calculate header length, incl. TCP/IP options, in 32 bit units. */</a>
<a name="ln5182">	hlen = ((ip-&gt;ip_hl &lt;&lt; 2) + (tcp-&gt;th_off &lt;&lt; 2)) &gt;&gt; 2;</a>
<a name="ln5183">	if (sc-&gt;bge_flags &amp; BGE_FLAG_TSO3) {</a>
<a name="ln5184">		/*</a>
<a name="ln5185">		 * For BCM5717 and newer controllers, hardware based TSO</a>
<a name="ln5186">		 * uses the 14 lower bits of the bge_mss field to store the</a>
<a name="ln5187">		 * MSS and the upper 2 bits to store the lowest 2 bits of</a>
<a name="ln5188">		 * the IP/TCP header length.  The upper 6 bits of the header</a>
<a name="ln5189">		 * length are stored in the bge_flags[14:10,4] field.  Jumbo</a>
<a name="ln5190">		 * frames are supported.</a>
<a name="ln5191">		 */</a>
<a name="ln5192">		*mss |= ((hlen &amp; 0x3) &lt;&lt; 14);</a>
<a name="ln5193">		*flags |= ((hlen &amp; 0xF8) &lt;&lt; 7) | ((hlen &amp; 0x4) &lt;&lt; 2);</a>
<a name="ln5194">	} else {</a>
<a name="ln5195">		/*</a>
<a name="ln5196">		 * For BCM5755 and newer controllers, hardware based TSO uses</a>
<a name="ln5197">		 * the lower 11	bits to store the MSS and the upper 5 bits to</a>
<a name="ln5198">		 * store the IP/TCP header length. Jumbo frames are not</a>
<a name="ln5199">		 * supported.</a>
<a name="ln5200">		 */</a>
<a name="ln5201">		*mss |= (hlen &lt;&lt; 11);</a>
<a name="ln5202">	}</a>
<a name="ln5203">	return (m);</a>
<a name="ln5204">}</a>
<a name="ln5205"> </a>
<a name="ln5206">/*</a>
<a name="ln5207"> * Encapsulate an mbuf chain in the tx ring  by coupling the mbuf data</a>
<a name="ln5208"> * pointers to descriptors.</a>
<a name="ln5209"> */</a>
<a name="ln5210">static int</a>
<a name="ln5211">bge_encap(struct bge_softc *sc, struct mbuf **m_head, uint32_t *txidx)</a>
<a name="ln5212">{</a>
<a name="ln5213">	bus_dma_segment_t	segs[BGE_NSEG_NEW];</a>
<a name="ln5214">	bus_dmamap_t		map;</a>
<a name="ln5215">	struct bge_tx_bd	*d;</a>
<a name="ln5216">	struct mbuf		*m = *m_head;</a>
<a name="ln5217">	uint32_t		idx = *txidx;</a>
<a name="ln5218">	uint16_t		csum_flags, mss, vlan_tag;</a>
<a name="ln5219">	int			nsegs, i, error;</a>
<a name="ln5220"> </a>
<a name="ln5221">	csum_flags = 0;</a>
<a name="ln5222">	mss = 0;</a>
<a name="ln5223">	vlan_tag = 0;</a>
<a name="ln5224">	if ((sc-&gt;bge_flags &amp; BGE_FLAG_SHORT_DMA_BUG) != 0 &amp;&amp;</a>
<a name="ln5225">	    m-&gt;m_next != NULL) {</a>
<a name="ln5226">		*m_head = bge_check_short_dma(m);</a>
<a name="ln5227">		if (*m_head == NULL)</a>
<a name="ln5228">			return (ENOBUFS);</a>
<a name="ln5229">		m = *m_head;</a>
<a name="ln5230">	}</a>
<a name="ln5231">	if ((m-&gt;m_pkthdr.csum_flags &amp; CSUM_TSO) != 0) {</a>
<a name="ln5232">		*m_head = m = bge_setup_tso(sc, m, &amp;mss, &amp;csum_flags);</a>
<a name="ln5233">		if (*m_head == NULL)</a>
<a name="ln5234">			return (ENOBUFS);</a>
<a name="ln5235">		csum_flags |= BGE_TXBDFLAG_CPU_PRE_DMA |</a>
<a name="ln5236">		    BGE_TXBDFLAG_CPU_POST_DMA;</a>
<a name="ln5237">	} else if ((m-&gt;m_pkthdr.csum_flags &amp; sc-&gt;bge_csum_features) != 0) {</a>
<a name="ln5238">		if (m-&gt;m_pkthdr.csum_flags &amp; CSUM_IP)</a>
<a name="ln5239">			csum_flags |= BGE_TXBDFLAG_IP_CSUM;</a>
<a name="ln5240">		if (m-&gt;m_pkthdr.csum_flags &amp; (CSUM_TCP | CSUM_UDP)) {</a>
<a name="ln5241">			csum_flags |= BGE_TXBDFLAG_TCP_UDP_CSUM;</a>
<a name="ln5242">			if (m-&gt;m_pkthdr.len &lt; ETHER_MIN_NOPAD &amp;&amp;</a>
<a name="ln5243">			    (error = bge_cksum_pad(m)) != 0) {</a>
<a name="ln5244">				m_freem(m);</a>
<a name="ln5245">				*m_head = NULL;</a>
<a name="ln5246">				return (error);</a>
<a name="ln5247">			}</a>
<a name="ln5248">		}</a>
<a name="ln5249">	}</a>
<a name="ln5250"> </a>
<a name="ln5251">	if ((m-&gt;m_pkthdr.csum_flags &amp; CSUM_TSO) == 0) {</a>
<a name="ln5252">		if (sc-&gt;bge_flags &amp; BGE_FLAG_JUMBO_FRAME &amp;&amp;</a>
<a name="ln5253">		    m-&gt;m_pkthdr.len &gt; ETHER_MAX_LEN)</a>
<a name="ln5254">			csum_flags |= BGE_TXBDFLAG_JUMBO_FRAME;</a>
<a name="ln5255">		if (sc-&gt;bge_forced_collapse &gt; 0 &amp;&amp;</a>
<a name="ln5256">		    (sc-&gt;bge_flags &amp; BGE_FLAG_PCIE) != 0 &amp;&amp; m-&gt;m_next != NULL) {</a>
<a name="ln5257">			/*</a>
<a name="ln5258">			 * Forcedly collapse mbuf chains to overcome hardware</a>
<a name="ln5259">			 * limitation which only support a single outstanding</a>
<a name="ln5260">			 * DMA read operation.</a>
<a name="ln5261">			 */</a>
<a name="ln5262">			if (sc-&gt;bge_forced_collapse == 1)</a>
<a name="ln5263">				m = m_defrag(m, M_NOWAIT);</a>
<a name="ln5264">			else</a>
<a name="ln5265">				m = m_collapse(m, M_NOWAIT,</a>
<a name="ln5266">				    sc-&gt;bge_forced_collapse);</a>
<a name="ln5267">			if (m == NULL)</a>
<a name="ln5268">				m = *m_head;</a>
<a name="ln5269">			*m_head = m;</a>
<a name="ln5270">		}</a>
<a name="ln5271">	}</a>
<a name="ln5272"> </a>
<a name="ln5273">	map = sc-&gt;bge_cdata.bge_tx_dmamap[idx];</a>
<a name="ln5274">	error = bus_dmamap_load_mbuf_sg(sc-&gt;bge_cdata.bge_tx_mtag, map, m, segs,</a>
<a name="ln5275">	    &amp;nsegs, BUS_DMA_NOWAIT);</a>
<a name="ln5276">	if (error == EFBIG) {</a>
<a name="ln5277">		m = m_collapse(m, M_NOWAIT, BGE_NSEG_NEW);</a>
<a name="ln5278">		if (m == NULL) {</a>
<a name="ln5279">			m_freem(*m_head);</a>
<a name="ln5280">			*m_head = NULL;</a>
<a name="ln5281">			return (ENOBUFS);</a>
<a name="ln5282">		}</a>
<a name="ln5283">		*m_head = m;</a>
<a name="ln5284">		error = bus_dmamap_load_mbuf_sg(sc-&gt;bge_cdata.bge_tx_mtag, map,</a>
<a name="ln5285">		    m, segs, &amp;nsegs, BUS_DMA_NOWAIT);</a>
<a name="ln5286">		if (error) {</a>
<a name="ln5287">			m_freem(m);</a>
<a name="ln5288">			*m_head = NULL;</a>
<a name="ln5289">			return (error);</a>
<a name="ln5290">		}</a>
<a name="ln5291">	} else if (error != 0)</a>
<a name="ln5292">		return (error);</a>
<a name="ln5293"> </a>
<a name="ln5294">	/* Check if we have enough free send BDs. */</a>
<a name="ln5295">	if (sc-&gt;bge_txcnt + nsegs &gt;= BGE_TX_RING_CNT) {</a>
<a name="ln5296">		bus_dmamap_unload(sc-&gt;bge_cdata.bge_tx_mtag, map);</a>
<a name="ln5297">		return (ENOBUFS);</a>
<a name="ln5298">	}</a>
<a name="ln5299"> </a>
<a name="ln5300">	bus_dmamap_sync(sc-&gt;bge_cdata.bge_tx_mtag, map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln5301"> </a>
<a name="ln5302">	if (m-&gt;m_flags &amp; M_VLANTAG) {</a>
<a name="ln5303">		csum_flags |= BGE_TXBDFLAG_VLAN_TAG;</a>
<a name="ln5304">		vlan_tag = m-&gt;m_pkthdr.ether_vtag;</a>
<a name="ln5305">	}</a>
<a name="ln5306"> </a>
<a name="ln5307">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5762 &amp;&amp;</a>
<a name="ln5308">	    (m-&gt;m_pkthdr.csum_flags &amp; CSUM_TSO) != 0) {</a>
<a name="ln5309">		/*</a>
<a name="ln5310">		 * 5725 family of devices corrupts TSO packets when TSO DMA</a>
<a name="ln5311">		 * buffers cross into regions which are within MSS bytes of</a>
<a name="ln5312">		 * a 4GB boundary.  If we encounter the condition, drop the</a>
<a name="ln5313">		 * packet.</a>
<a name="ln5314">		 */</a>
<a name="ln5315">		for (i = 0; ; i++) {</a>
<a name="ln5316">			d = &amp;sc-&gt;bge_ldata.bge_tx_ring[idx];</a>
<a name="ln5317">			d-&gt;bge_addr.bge_addr_lo = BGE_ADDR_LO(segs[i].ds_addr);</a>
<a name="ln5318">			d-&gt;bge_addr.bge_addr_hi = BGE_ADDR_HI(segs[i].ds_addr);</a>
<a name="ln5319">			d-&gt;bge_len = segs[i].ds_len;</a>
<a name="ln5320">			if (d-&gt;bge_addr.bge_addr_lo + segs[i].ds_len + mss &lt;</a>
<a name="ln5321">			    d-&gt;bge_addr.bge_addr_lo)</a>
<a name="ln5322">				break;</a>
<a name="ln5323">			d-&gt;bge_flags = csum_flags;</a>
<a name="ln5324">			d-&gt;bge_vlan_tag = vlan_tag;</a>
<a name="ln5325">			d-&gt;bge_mss = mss;</a>
<a name="ln5326">			if (i == nsegs - 1)</a>
<a name="ln5327">				break;</a>
<a name="ln5328">			BGE_INC(idx, BGE_TX_RING_CNT);</a>
<a name="ln5329">		}</a>
<a name="ln5330">		if (i != nsegs - 1) {</a>
<a name="ln5331">			bus_dmamap_sync(sc-&gt;bge_cdata.bge_tx_mtag, map,</a>
<a name="ln5332">			    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln5333">			bus_dmamap_unload(sc-&gt;bge_cdata.bge_tx_mtag, map);</a>
<a name="ln5334">			m_freem(*m_head);</a>
<a name="ln5335">			*m_head = NULL;</a>
<a name="ln5336">			return (EIO);</a>
<a name="ln5337">		}</a>
<a name="ln5338">	} else {</a>
<a name="ln5339">		for (i = 0; ; i++) {</a>
<a name="ln5340">			d = &amp;sc-&gt;bge_ldata.bge_tx_ring[idx];</a>
<a name="ln5341">			d-&gt;bge_addr.bge_addr_lo = BGE_ADDR_LO(segs[i].ds_addr);</a>
<a name="ln5342">			d-&gt;bge_addr.bge_addr_hi = BGE_ADDR_HI(segs[i].ds_addr);</a>
<a name="ln5343">			d-&gt;bge_len = segs[i].ds_len;</a>
<a name="ln5344">			d-&gt;bge_flags = csum_flags;</a>
<a name="ln5345">			d-&gt;bge_vlan_tag = vlan_tag;</a>
<a name="ln5346">			d-&gt;bge_mss = mss;</a>
<a name="ln5347">			if (i == nsegs - 1)</a>
<a name="ln5348">				break;</a>
<a name="ln5349">			BGE_INC(idx, BGE_TX_RING_CNT);</a>
<a name="ln5350">		}</a>
<a name="ln5351">	}</a>
<a name="ln5352"> </a>
<a name="ln5353">	/* Mark the last segment as end of packet... */</a>
<a name="ln5354">	d-&gt;bge_flags |= BGE_TXBDFLAG_END;</a>
<a name="ln5355"> </a>
<a name="ln5356">	/*</a>
<a name="ln5357">	 * Insure that the map for this transmission</a>
<a name="ln5358">	 * is placed at the array index of the last descriptor</a>
<a name="ln5359">	 * in this chain.</a>
<a name="ln5360">	 */</a>
<a name="ln5361">	sc-&gt;bge_cdata.bge_tx_dmamap[*txidx] = sc-&gt;bge_cdata.bge_tx_dmamap[idx];</a>
<a name="ln5362">	sc-&gt;bge_cdata.bge_tx_dmamap[idx] = map;</a>
<a name="ln5363">	sc-&gt;bge_cdata.bge_tx_chain[idx] = m;</a>
<a name="ln5364">	sc-&gt;bge_txcnt += nsegs;</a>
<a name="ln5365"> </a>
<a name="ln5366">	BGE_INC(idx, BGE_TX_RING_CNT);</a>
<a name="ln5367">	*txidx = idx;</a>
<a name="ln5368"> </a>
<a name="ln5369">	return (0);</a>
<a name="ln5370">}</a>
<a name="ln5371"> </a>
<a name="ln5372">/*</a>
<a name="ln5373"> * Main transmit routine. To avoid having to do mbuf copies, we put pointers</a>
<a name="ln5374"> * to the mbuf data regions directly in the transmit descriptors.</a>
<a name="ln5375"> */</a>
<a name="ln5376">static void</a>
<a name="ln5377">bge_start_locked(if_t ifp)</a>
<a name="ln5378">{</a>
<a name="ln5379">	struct bge_softc *sc;</a>
<a name="ln5380">	struct mbuf *m_head;</a>
<a name="ln5381">	uint32_t prodidx;</a>
<a name="ln5382">	int count;</a>
<a name="ln5383"> </a>
<a name="ln5384">	sc = if_getsoftc(ifp);</a>
<a name="ln5385">	BGE_LOCK_ASSERT(sc);</a>
<a name="ln5386"> </a>
<a name="ln5387">	if (!sc-&gt;bge_link ||</a>
<a name="ln5388">	    (if_getdrvflags(ifp) &amp; (IFF_DRV_RUNNING | IFF_DRV_OACTIVE)) !=</a>
<a name="ln5389">	    IFF_DRV_RUNNING)</a>
<a name="ln5390">		return;</a>
<a name="ln5391"> </a>
<a name="ln5392">	prodidx = sc-&gt;bge_tx_prodidx;</a>
<a name="ln5393"> </a>
<a name="ln5394">	for (count = 0; !if_sendq_empty(ifp);) {</a>
<a name="ln5395">		if (sc-&gt;bge_txcnt &gt; BGE_TX_RING_CNT - 16) {</a>
<a name="ln5396">			if_setdrvflagbits(ifp, IFF_DRV_OACTIVE, 0);</a>
<a name="ln5397">			break;</a>
<a name="ln5398">		}</a>
<a name="ln5399">		m_head = if_dequeue(ifp);</a>
<a name="ln5400">		if (m_head == NULL)</a>
<a name="ln5401">			break;</a>
<a name="ln5402"> </a>
<a name="ln5403">		/*</a>
<a name="ln5404">		 * Pack the data into the transmit ring. If we</a>
<a name="ln5405">		 * don't have room, set the OACTIVE flag and wait</a>
<a name="ln5406">		 * for the NIC to drain the ring.</a>
<a name="ln5407">		 */</a>
<a name="ln5408">		if (bge_encap(sc, &amp;m_head, &amp;prodidx)) {</a>
<a name="ln5409">			if (m_head == NULL)</a>
<a name="ln5410">				break;</a>
<a name="ln5411">			if_sendq_prepend(ifp, m_head);</a>
<a name="ln5412">			if_setdrvflagbits(ifp, IFF_DRV_OACTIVE, 0);</a>
<a name="ln5413">			break;</a>
<a name="ln5414">		}</a>
<a name="ln5415">		++count;</a>
<a name="ln5416"> </a>
<a name="ln5417">		/*</a>
<a name="ln5418">		 * If there's a BPF listener, bounce a copy of this frame</a>
<a name="ln5419">		 * to him.</a>
<a name="ln5420">		 */</a>
<a name="ln5421">		if_bpfmtap(ifp, m_head);</a>
<a name="ln5422">	}</a>
<a name="ln5423"> </a>
<a name="ln5424">	if (count &gt; 0)</a>
<a name="ln5425">		bge_start_tx(sc, prodidx);</a>
<a name="ln5426">}</a>
<a name="ln5427"> </a>
<a name="ln5428">static void</a>
<a name="ln5429">bge_start_tx(struct bge_softc *sc, uint32_t prodidx)</a>
<a name="ln5430">{</a>
<a name="ln5431"> </a>
<a name="ln5432">	bus_dmamap_sync(sc-&gt;bge_cdata.bge_tx_ring_tag,</a>
<a name="ln5433">	    sc-&gt;bge_cdata.bge_tx_ring_map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln5434">	/* Transmit. */</a>
<a name="ln5435">	bge_writembx(sc, BGE_MBX_TX_HOST_PROD0_LO, prodidx);</a>
<a name="ln5436">	/* 5700 b2 errata */</a>
<a name="ln5437">	if (sc-&gt;bge_chiprev == BGE_CHIPREV_5700_BX)</a>
<a name="ln5438">		bge_writembx(sc, BGE_MBX_TX_HOST_PROD0_LO, prodidx);</a>
<a name="ln5439"> </a>
<a name="ln5440">	sc-&gt;bge_tx_prodidx = prodidx;</a>
<a name="ln5441"> </a>
<a name="ln5442">	/* Set a timeout in case the chip goes out to lunch. */</a>
<a name="ln5443">	sc-&gt;bge_timer = BGE_TX_TIMEOUT;</a>
<a name="ln5444">}</a>
<a name="ln5445"> </a>
<a name="ln5446">/*</a>
<a name="ln5447"> * Main transmit routine. To avoid having to do mbuf copies, we put pointers</a>
<a name="ln5448"> * to the mbuf data regions directly in the transmit descriptors.</a>
<a name="ln5449"> */</a>
<a name="ln5450">static void</a>
<a name="ln5451">bge_start(if_t ifp)</a>
<a name="ln5452">{</a>
<a name="ln5453">	struct bge_softc *sc;</a>
<a name="ln5454"> </a>
<a name="ln5455">	sc = if_getsoftc(ifp);</a>
<a name="ln5456">	BGE_LOCK(sc);</a>
<a name="ln5457">	bge_start_locked(ifp);</a>
<a name="ln5458">	BGE_UNLOCK(sc);</a>
<a name="ln5459">}</a>
<a name="ln5460"> </a>
<a name="ln5461">static void</a>
<a name="ln5462">bge_init_locked(struct bge_softc *sc)</a>
<a name="ln5463">{</a>
<a name="ln5464">	if_t ifp;</a>
<a name="ln5465">	uint16_t *m;</a>
<a name="ln5466">	uint32_t mode;</a>
<a name="ln5467"> </a>
<a name="ln5468">	BGE_LOCK_ASSERT(sc);</a>
<a name="ln5469"> </a>
<a name="ln5470">	ifp = sc-&gt;bge_ifp;</a>
<a name="ln5471"> </a>
<a name="ln5472">	if (if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING)</a>
<a name="ln5473">		return;</a>
<a name="ln5474"> </a>
<a name="ln5475">	/* Cancel pending I/O and flush buffers. */</a>
<a name="ln5476">	bge_stop(sc);</a>
<a name="ln5477"> </a>
<a name="ln5478">	bge_stop_fw(sc);</a>
<a name="ln5479">	bge_sig_pre_reset(sc, BGE_RESET_START);</a>
<a name="ln5480">	bge_reset(sc);</a>
<a name="ln5481">	bge_sig_legacy(sc, BGE_RESET_START);</a>
<a name="ln5482">	bge_sig_post_reset(sc, BGE_RESET_START);</a>
<a name="ln5483"> </a>
<a name="ln5484">	bge_chipinit(sc);</a>
<a name="ln5485"> </a>
<a name="ln5486">	/*</a>
<a name="ln5487">	 * Init the various state machines, ring</a>
<a name="ln5488">	 * control blocks and firmware.</a>
<a name="ln5489">	 */</a>
<a name="ln5490">	if (bge_blockinit(sc)) {</a>
<a name="ln5491">		device_printf(sc-&gt;bge_dev, &quot;initialization failure\n&quot;);</a>
<a name="ln5492">		return;</a>
<a name="ln5493">	}</a>
<a name="ln5494"> </a>
<a name="ln5495">	ifp = sc-&gt;bge_ifp;</a>
<a name="ln5496"> </a>
<a name="ln5497">	/* Specify MTU. */</a>
<a name="ln5498">	CSR_WRITE_4(sc, BGE_RX_MTU, if_getmtu(ifp) +</a>
<a name="ln5499">	    ETHER_HDR_LEN + ETHER_CRC_LEN +</a>
<a name="ln5500">	    (if_getcapenable(ifp) &amp; IFCAP_VLAN_MTU ? ETHER_VLAN_ENCAP_LEN : 0));</a>
<a name="ln5501"> </a>
<a name="ln5502">	/* Load our MAC address. */</a>
<a name="ln5503">	m = (uint16_t *)IF_LLADDR(sc-&gt;bge_ifp);</a>
<a name="ln5504">	CSR_WRITE_4(sc, BGE_MAC_ADDR1_LO, htons(m[0]));</a>
<a name="ln5505">	CSR_WRITE_4(sc, BGE_MAC_ADDR1_HI, (htons(m[1]) &lt;&lt; 16) | htons(m[2]));</a>
<a name="ln5506"> </a>
<a name="ln5507">	/* Program promiscuous mode. */</a>
<a name="ln5508">	bge_setpromisc(sc);</a>
<a name="ln5509"> </a>
<a name="ln5510">	/* Program multicast filter. */</a>
<a name="ln5511">	bge_setmulti(sc);</a>
<a name="ln5512"> </a>
<a name="ln5513">	/* Program VLAN tag stripping. */</a>
<a name="ln5514">	bge_setvlan(sc);</a>
<a name="ln5515"> </a>
<a name="ln5516">	/* Override UDP checksum offloading. */</a>
<a name="ln5517">	if (sc-&gt;bge_forced_udpcsum == 0)</a>
<a name="ln5518">		sc-&gt;bge_csum_features &amp;= ~CSUM_UDP;</a>
<a name="ln5519">	else</a>
<a name="ln5520">		sc-&gt;bge_csum_features |= CSUM_UDP;</a>
<a name="ln5521">	if (if_getcapabilities(ifp) &amp; IFCAP_TXCSUM &amp;&amp;</a>
<a name="ln5522">	    if_getcapenable(ifp) &amp; IFCAP_TXCSUM) {</a>
<a name="ln5523">		if_sethwassistbits(ifp, 0, (BGE_CSUM_FEATURES | CSUM_UDP));</a>
<a name="ln5524">		if_sethwassistbits(ifp, sc-&gt;bge_csum_features, 0);</a>
<a name="ln5525">	}</a>
<a name="ln5526"> </a>
<a name="ln5527">	/* Init RX ring. */</a>
<a name="ln5528">	if (bge_init_rx_ring_std(sc) != 0) {</a>
<a name="ln5529">		device_printf(sc-&gt;bge_dev, &quot;no memory for std Rx buffers.\n&quot;);</a>
<a name="ln5530">		bge_stop(sc);</a>
<a name="ln5531">		return;</a>
<a name="ln5532">	}</a>
<a name="ln5533"> </a>
<a name="ln5534">	/*</a>
<a name="ln5535">	 * Workaround for a bug in 5705 ASIC rev A0. Poll the NIC's</a>
<a name="ln5536">	 * memory to insure that the chip has in fact read the first</a>
<a name="ln5537">	 * entry of the ring.</a>
<a name="ln5538">	 */</a>
<a name="ln5539">	if (sc-&gt;bge_chipid == BGE_CHIPID_BCM5705_A0) {</a>
<a name="ln5540">		uint32_t		v, i;</a>
<a name="ln5541">		for (i = 0; i &lt; 10; i++) {</a>
<a name="ln5542">			DELAY(20);</a>
<a name="ln5543">			v = bge_readmem_ind(sc, BGE_STD_RX_RINGS + 8);</a>
<a name="ln5544">			if (v == (MCLBYTES - ETHER_ALIGN))</a>
<a name="ln5545">				break;</a>
<a name="ln5546">		}</a>
<a name="ln5547">		if (i == 10)</a>
<a name="ln5548">			device_printf (sc-&gt;bge_dev,</a>
<a name="ln5549">			    &quot;5705 A0 chip failed to load RX ring\n&quot;);</a>
<a name="ln5550">	}</a>
<a name="ln5551"> </a>
<a name="ln5552">	/* Init jumbo RX ring. */</a>
<a name="ln5553">	if (BGE_IS_JUMBO_CAPABLE(sc) &amp;&amp;</a>
<a name="ln5554">	    if_getmtu(ifp) + ETHER_HDR_LEN + ETHER_CRC_LEN + </a>
<a name="ln5555">     	    ETHER_VLAN_ENCAP_LEN &gt; (MCLBYTES - ETHER_ALIGN)) {</a>
<a name="ln5556">		if (bge_init_rx_ring_jumbo(sc) != 0) {</a>
<a name="ln5557">			device_printf(sc-&gt;bge_dev,</a>
<a name="ln5558">			    &quot;no memory for jumbo Rx buffers.\n&quot;);</a>
<a name="ln5559">			bge_stop(sc);</a>
<a name="ln5560">			return;</a>
<a name="ln5561">		}</a>
<a name="ln5562">	}</a>
<a name="ln5563"> </a>
<a name="ln5564">	/* Init our RX return ring index. */</a>
<a name="ln5565">	sc-&gt;bge_rx_saved_considx = 0;</a>
<a name="ln5566"> </a>
<a name="ln5567">	/* Init our RX/TX stat counters. */</a>
<a name="ln5568">	sc-&gt;bge_rx_discards = sc-&gt;bge_tx_discards = sc-&gt;bge_tx_collisions = 0;</a>
<a name="ln5569"> </a>
<a name="ln5570">	/* Init TX ring. */</a>
<a name="ln5571">	bge_init_tx_ring(sc);</a>
<a name="ln5572"> </a>
<a name="ln5573">	/* Enable TX MAC state machine lockup fix. */</a>
<a name="ln5574">	mode = CSR_READ_4(sc, BGE_TX_MODE);</a>
<a name="ln5575">	if (BGE_IS_5755_PLUS(sc) || sc-&gt;bge_asicrev == BGE_ASICREV_BCM5906)</a>
<a name="ln5576">		mode |= BGE_TXMODE_MBUF_LOCKUP_FIX;</a>
<a name="ln5577">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5720 ||</a>
<a name="ln5578">	    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5762) {</a>
<a name="ln5579">		mode &amp;= ~(BGE_TXMODE_JMB_FRM_LEN | BGE_TXMODE_CNT_DN_MODE);</a>
<a name="ln5580">		mode |= CSR_READ_4(sc, BGE_TX_MODE) &amp;</a>
<a name="ln5581">		    (BGE_TXMODE_JMB_FRM_LEN | BGE_TXMODE_CNT_DN_MODE);</a>
<a name="ln5582">	}</a>
<a name="ln5583">	/* Turn on transmitter. */</a>
<a name="ln5584">	CSR_WRITE_4(sc, BGE_TX_MODE, mode | BGE_TXMODE_ENABLE);</a>
<a name="ln5585">	DELAY(100);</a>
<a name="ln5586"> </a>
<a name="ln5587">	/* Turn on receiver. */</a>
<a name="ln5588">	mode = CSR_READ_4(sc, BGE_RX_MODE);</a>
<a name="ln5589">	if (BGE_IS_5755_PLUS(sc))</a>
<a name="ln5590">		mode |= BGE_RXMODE_IPV6_ENABLE;</a>
<a name="ln5591">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5762)</a>
<a name="ln5592">		mode |= BGE_RXMODE_IPV4_FRAG_FIX;</a>
<a name="ln5593">	CSR_WRITE_4(sc,BGE_RX_MODE, mode | BGE_RXMODE_ENABLE);</a>
<a name="ln5594">	DELAY(10);</a>
<a name="ln5595"> </a>
<a name="ln5596">	/*</a>
<a name="ln5597">	 * Set the number of good frames to receive after RX MBUF</a>
<a name="ln5598">	 * Low Watermark has been reached. After the RX MAC receives</a>
<a name="ln5599">	 * this number of frames, it will drop subsequent incoming</a>
<a name="ln5600">	 * frames until the MBUF High Watermark is reached.</a>
<a name="ln5601">	 */</a>
<a name="ln5602">	if (BGE_IS_57765_PLUS(sc))</a>
<a name="ln5603">		CSR_WRITE_4(sc, BGE_MAX_RX_FRAME_LOWAT, 1);</a>
<a name="ln5604">	else</a>
<a name="ln5605">		CSR_WRITE_4(sc, BGE_MAX_RX_FRAME_LOWAT, 2);</a>
<a name="ln5606"> </a>
<a name="ln5607">	/* Clear MAC statistics. */</a>
<a name="ln5608">	if (BGE_IS_5705_PLUS(sc))</a>
<a name="ln5609">		bge_stats_clear_regs(sc);</a>
<a name="ln5610"> </a>
<a name="ln5611">	/* Tell firmware we're alive. */</a>
<a name="ln5612">	BGE_SETBIT(sc, BGE_MODE_CTL, BGE_MODECTL_STACKUP);</a>
<a name="ln5613"> </a>
<a name="ln5614">#ifdef DEVICE_POLLING</a>
<a name="ln5615">	/* Disable interrupts if we are polling. */</a>
<a name="ln5616">	if (if_getcapenable(ifp) &amp; IFCAP_POLLING) {</a>
<a name="ln5617">		BGE_SETBIT(sc, BGE_PCI_MISC_CTL,</a>
<a name="ln5618">		    BGE_PCIMISCCTL_MASK_PCI_INTR);</a>
<a name="ln5619">		bge_writembx(sc, BGE_MBX_IRQ0_LO, 1);</a>
<a name="ln5620">	} else</a>
<a name="ln5621">#endif</a>
<a name="ln5622"> </a>
<a name="ln5623">	/* Enable host interrupts. */</a>
<a name="ln5624">	{</a>
<a name="ln5625">	BGE_SETBIT(sc, BGE_PCI_MISC_CTL, BGE_PCIMISCCTL_CLEAR_INTA);</a>
<a name="ln5626">	BGE_CLRBIT(sc, BGE_PCI_MISC_CTL, BGE_PCIMISCCTL_MASK_PCI_INTR);</a>
<a name="ln5627">	bge_writembx(sc, BGE_MBX_IRQ0_LO, 0);</a>
<a name="ln5628">	}</a>
<a name="ln5629"> </a>
<a name="ln5630">	if_setdrvflagbits(ifp, IFF_DRV_RUNNING, 0);</a>
<a name="ln5631">	if_setdrvflagbits(ifp, 0, IFF_DRV_OACTIVE);</a>
<a name="ln5632"> </a>
<a name="ln5633">	bge_ifmedia_upd_locked(ifp);</a>
<a name="ln5634"> </a>
<a name="ln5635">	callout_reset(&amp;sc-&gt;bge_stat_ch, hz, bge_tick, sc);</a>
<a name="ln5636">}</a>
<a name="ln5637"> </a>
<a name="ln5638">static void</a>
<a name="ln5639">bge_init(void *xsc)</a>
<a name="ln5640">{</a>
<a name="ln5641">	struct bge_softc *sc = xsc;</a>
<a name="ln5642"> </a>
<a name="ln5643">	BGE_LOCK(sc);</a>
<a name="ln5644">	bge_init_locked(sc);</a>
<a name="ln5645">	BGE_UNLOCK(sc);</a>
<a name="ln5646">}</a>
<a name="ln5647"> </a>
<a name="ln5648">/*</a>
<a name="ln5649"> * Set media options.</a>
<a name="ln5650"> */</a>
<a name="ln5651">static int</a>
<a name="ln5652">bge_ifmedia_upd(if_t ifp)</a>
<a name="ln5653">{</a>
<a name="ln5654">	struct bge_softc *sc = if_getsoftc(ifp);</a>
<a name="ln5655">	int res;</a>
<a name="ln5656"> </a>
<a name="ln5657">	BGE_LOCK(sc);</a>
<a name="ln5658">	res = bge_ifmedia_upd_locked(ifp);</a>
<a name="ln5659">	BGE_UNLOCK(sc);</a>
<a name="ln5660"> </a>
<a name="ln5661">	return (res);</a>
<a name="ln5662">}</a>
<a name="ln5663"> </a>
<a name="ln5664">static int</a>
<a name="ln5665">bge_ifmedia_upd_locked(if_t ifp)</a>
<a name="ln5666">{</a>
<a name="ln5667">	struct bge_softc *sc = if_getsoftc(ifp);</a>
<a name="ln5668">	struct mii_data *mii;</a>
<a name="ln5669">	struct mii_softc *miisc;</a>
<a name="ln5670">	struct ifmedia *ifm;</a>
<a name="ln5671"> </a>
<a name="ln5672">	BGE_LOCK_ASSERT(sc);</a>
<a name="ln5673"> </a>
<a name="ln5674">	ifm = &amp;sc-&gt;bge_ifmedia;</a>
<a name="ln5675"> </a>
<a name="ln5676">	/* If this is a 1000baseX NIC, enable the TBI port. */</a>
<a name="ln5677">	if (sc-&gt;bge_flags &amp; BGE_FLAG_TBI) {</a>
<a name="ln5678">		if (IFM_TYPE(ifm-&gt;ifm_media) != IFM_ETHER)</a>
<a name="ln5679">			return (EINVAL);</a>
<a name="ln5680">		switch(IFM_SUBTYPE(ifm-&gt;ifm_media)) {</a>
<a name="ln5681">		case IFM_AUTO:</a>
<a name="ln5682">			/*</a>
<a name="ln5683">			 * The BCM5704 ASIC appears to have a special</a>
<a name="ln5684">			 * mechanism for programming the autoneg</a>
<a name="ln5685">			 * advertisement registers in TBI mode.</a>
<a name="ln5686">			 */</a>
<a name="ln5687">			if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5704) {</a>
<a name="ln5688">				uint32_t sgdig;</a>
<a name="ln5689">				sgdig = CSR_READ_4(sc, BGE_SGDIG_STS);</a>
<a name="ln5690">				if (sgdig &amp; BGE_SGDIGSTS_DONE) {</a>
<a name="ln5691">					CSR_WRITE_4(sc, BGE_TX_TBI_AUTONEG, 0);</a>
<a name="ln5692">					sgdig = CSR_READ_4(sc, BGE_SGDIG_CFG);</a>
<a name="ln5693">					sgdig |= BGE_SGDIGCFG_AUTO |</a>
<a name="ln5694">					    BGE_SGDIGCFG_PAUSE_CAP |</a>
<a name="ln5695">					    BGE_SGDIGCFG_ASYM_PAUSE;</a>
<a name="ln5696">					CSR_WRITE_4(sc, BGE_SGDIG_CFG,</a>
<a name="ln5697">					    sgdig | BGE_SGDIGCFG_SEND);</a>
<a name="ln5698">					DELAY(5);</a>
<a name="ln5699">					CSR_WRITE_4(sc, BGE_SGDIG_CFG, sgdig);</a>
<a name="ln5700">				}</a>
<a name="ln5701">			}</a>
<a name="ln5702">			break;</a>
<a name="ln5703">		case IFM_1000_SX:</a>
<a name="ln5704">			if ((ifm-&gt;ifm_media &amp; IFM_GMASK) == IFM_FDX) {</a>
<a name="ln5705">				BGE_CLRBIT(sc, BGE_MAC_MODE,</a>
<a name="ln5706">				    BGE_MACMODE_HALF_DUPLEX);</a>
<a name="ln5707">			} else {</a>
<a name="ln5708">				BGE_SETBIT(sc, BGE_MAC_MODE,</a>
<a name="ln5709">				    BGE_MACMODE_HALF_DUPLEX);</a>
<a name="ln5710">			}</a>
<a name="ln5711">			DELAY(40);</a>
<a name="ln5712">			break;</a>
<a name="ln5713">		default:</a>
<a name="ln5714">			return (EINVAL);</a>
<a name="ln5715">		}</a>
<a name="ln5716">		return (0);</a>
<a name="ln5717">	}</a>
<a name="ln5718"> </a>
<a name="ln5719">	sc-&gt;bge_link_evt++;</a>
<a name="ln5720">	mii = device_get_softc(sc-&gt;bge_miibus);</a>
<a name="ln5721">	LIST_FOREACH(miisc, &amp;mii-&gt;mii_phys, mii_list)</a>
<a name="ln5722">		PHY_RESET(miisc);</a>
<a name="ln5723">	mii_mediachg(mii);</a>
<a name="ln5724"> </a>
<a name="ln5725">	/*</a>
<a name="ln5726">	 * Force an interrupt so that we will call bge_link_upd</a>
<a name="ln5727">	 * if needed and clear any pending link state attention.</a>
<a name="ln5728">	 * Without this we are not getting any further interrupts</a>
<a name="ln5729">	 * for link state changes and thus will not UP the link and</a>
<a name="ln5730">	 * not be able to send in bge_start_locked. The only</a>
<a name="ln5731">	 * way to get things working was to receive a packet and</a>
<a name="ln5732">	 * get an RX intr.</a>
<a name="ln5733">	 * bge_tick should help for fiber cards and we might not</a>
<a name="ln5734">	 * need to do this here if BGE_FLAG_TBI is set but as</a>
<a name="ln5735">	 * we poll for fiber anyway it should not harm.</a>
<a name="ln5736">	 */</a>
<a name="ln5737">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5700 ||</a>
<a name="ln5738">	    sc-&gt;bge_flags &amp; BGE_FLAG_5788)</a>
<a name="ln5739">		BGE_SETBIT(sc, BGE_MISC_LOCAL_CTL, BGE_MLC_INTR_SET);</a>
<a name="ln5740">	else</a>
<a name="ln5741">		BGE_SETBIT(sc, BGE_HCC_MODE, BGE_HCCMODE_COAL_NOW);</a>
<a name="ln5742"> </a>
<a name="ln5743">	return (0);</a>
<a name="ln5744">}</a>
<a name="ln5745"> </a>
<a name="ln5746">/*</a>
<a name="ln5747"> * Report current media status.</a>
<a name="ln5748"> */</a>
<a name="ln5749">static void</a>
<a name="ln5750">bge_ifmedia_sts(if_t ifp, struct ifmediareq *ifmr)</a>
<a name="ln5751">{</a>
<a name="ln5752">	struct bge_softc *sc = if_getsoftc(ifp);</a>
<a name="ln5753">	struct mii_data *mii;</a>
<a name="ln5754"> </a>
<a name="ln5755">	BGE_LOCK(sc);</a>
<a name="ln5756"> </a>
<a name="ln5757">	if ((if_getflags(ifp) &amp; IFF_UP) == 0) {</a>
<a name="ln5758">		BGE_UNLOCK(sc);</a>
<a name="ln5759">		return;</a>
<a name="ln5760">	}</a>
<a name="ln5761">	if (sc-&gt;bge_flags &amp; BGE_FLAG_TBI) {</a>
<a name="ln5762">		ifmr-&gt;ifm_status = IFM_AVALID;</a>
<a name="ln5763">		ifmr-&gt;ifm_active = IFM_ETHER;</a>
<a name="ln5764">		if (CSR_READ_4(sc, BGE_MAC_STS) &amp;</a>
<a name="ln5765">		    BGE_MACSTAT_TBI_PCS_SYNCHED)</a>
<a name="ln5766">			ifmr-&gt;ifm_status |= IFM_ACTIVE;</a>
<a name="ln5767">		else {</a>
<a name="ln5768">			ifmr-&gt;ifm_active |= IFM_NONE;</a>
<a name="ln5769">			BGE_UNLOCK(sc);</a>
<a name="ln5770">			return;</a>
<a name="ln5771">		}</a>
<a name="ln5772">		ifmr-&gt;ifm_active |= IFM_1000_SX;</a>
<a name="ln5773">		if (CSR_READ_4(sc, BGE_MAC_MODE) &amp; BGE_MACMODE_HALF_DUPLEX)</a>
<a name="ln5774">			ifmr-&gt;ifm_active |= IFM_HDX;</a>
<a name="ln5775">		else</a>
<a name="ln5776">			ifmr-&gt;ifm_active |= IFM_FDX;</a>
<a name="ln5777">		BGE_UNLOCK(sc);</a>
<a name="ln5778">		return;</a>
<a name="ln5779">	}</a>
<a name="ln5780"> </a>
<a name="ln5781">	mii = device_get_softc(sc-&gt;bge_miibus);</a>
<a name="ln5782">	mii_pollstat(mii);</a>
<a name="ln5783">	ifmr-&gt;ifm_active = mii-&gt;mii_media_active;</a>
<a name="ln5784">	ifmr-&gt;ifm_status = mii-&gt;mii_media_status;</a>
<a name="ln5785"> </a>
<a name="ln5786">	BGE_UNLOCK(sc);</a>
<a name="ln5787">}</a>
<a name="ln5788"> </a>
<a name="ln5789">static int</a>
<a name="ln5790">bge_ioctl(if_t ifp, u_long command, caddr_t data)</a>
<a name="ln5791">{</a>
<a name="ln5792">	struct bge_softc *sc = if_getsoftc(ifp);</a>
<a name="ln5793">	struct ifreq *ifr = (struct ifreq *) data;</a>
<a name="ln5794">	struct mii_data *mii;</a>
<a name="ln5795">	int flags, mask, error = 0;</a>
<a name="ln5796"> </a>
<a name="ln5797">	switch (command) {</a>
<a name="ln5798">	case SIOCSIFMTU:</a>
<a name="ln5799">		if (BGE_IS_JUMBO_CAPABLE(sc) ||</a>
<a name="ln5800">		    (sc-&gt;bge_flags &amp; BGE_FLAG_JUMBO_STD)) {</a>
<a name="ln5801">			if (ifr-&gt;ifr_mtu &lt; ETHERMIN ||</a>
<a name="ln5802">			    ifr-&gt;ifr_mtu &gt; BGE_JUMBO_MTU) {</a>
<a name="ln5803">				error = EINVAL;</a>
<a name="ln5804">				break;</a>
<a name="ln5805">			}</a>
<a name="ln5806">		} else if (ifr-&gt;ifr_mtu &lt; ETHERMIN || ifr-&gt;ifr_mtu &gt; ETHERMTU) {</a>
<a name="ln5807">			error = EINVAL;</a>
<a name="ln5808">			break;</a>
<a name="ln5809">		}</a>
<a name="ln5810">		BGE_LOCK(sc);</a>
<a name="ln5811">		if (if_getmtu(ifp) != ifr-&gt;ifr_mtu) {</a>
<a name="ln5812">			if_setmtu(ifp, ifr-&gt;ifr_mtu);</a>
<a name="ln5813">			if (if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING) {</a>
<a name="ln5814">				if_setdrvflagbits(ifp, 0, IFF_DRV_RUNNING);</a>
<a name="ln5815">				bge_init_locked(sc);</a>
<a name="ln5816">			}</a>
<a name="ln5817">		}</a>
<a name="ln5818">		BGE_UNLOCK(sc);</a>
<a name="ln5819">		break;</a>
<a name="ln5820">	case SIOCSIFFLAGS:</a>
<a name="ln5821">		BGE_LOCK(sc);</a>
<a name="ln5822">		if (if_getflags(ifp) &amp; IFF_UP) {</a>
<a name="ln5823">			/*</a>
<a name="ln5824">			 * If only the state of the PROMISC flag changed,</a>
<a name="ln5825">			 * then just use the 'set promisc mode' command</a>
<a name="ln5826">			 * instead of reinitializing the entire NIC. Doing</a>
<a name="ln5827">			 * a full re-init means reloading the firmware and</a>
<a name="ln5828">			 * waiting for it to start up, which may take a</a>
<a name="ln5829">			 * second or two.  Similarly for ALLMULTI.</a>
<a name="ln5830">			 */</a>
<a name="ln5831">			if (if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING) {</a>
<a name="ln5832">				flags = if_getflags(ifp) ^ sc-&gt;bge_if_flags;</a>
<a name="ln5833">				if (flags &amp; IFF_PROMISC)</a>
<a name="ln5834">					bge_setpromisc(sc);</a>
<a name="ln5835">				if (flags &amp; IFF_ALLMULTI)</a>
<a name="ln5836">					bge_setmulti(sc);</a>
<a name="ln5837">			} else</a>
<a name="ln5838">				bge_init_locked(sc);</a>
<a name="ln5839">		} else {</a>
<a name="ln5840">			if (if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING) {</a>
<a name="ln5841">				bge_stop(sc);</a>
<a name="ln5842">			}</a>
<a name="ln5843">		}</a>
<a name="ln5844">		sc-&gt;bge_if_flags = if_getflags(ifp);</a>
<a name="ln5845">		BGE_UNLOCK(sc);</a>
<a name="ln5846">		error = 0;</a>
<a name="ln5847">		break;</a>
<a name="ln5848">	case SIOCADDMULTI:</a>
<a name="ln5849">	case SIOCDELMULTI:</a>
<a name="ln5850">		if (if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING) {</a>
<a name="ln5851">			BGE_LOCK(sc);</a>
<a name="ln5852">			bge_setmulti(sc);</a>
<a name="ln5853">			BGE_UNLOCK(sc);</a>
<a name="ln5854">			error = 0;</a>
<a name="ln5855">		}</a>
<a name="ln5856">		break;</a>
<a name="ln5857">	case SIOCSIFMEDIA:</a>
<a name="ln5858">	case SIOCGIFMEDIA:</a>
<a name="ln5859">		if (sc-&gt;bge_flags &amp; BGE_FLAG_TBI) {</a>
<a name="ln5860">			error = ifmedia_ioctl(ifp, ifr,</a>
<a name="ln5861">			    &amp;sc-&gt;bge_ifmedia, command);</a>
<a name="ln5862">		} else {</a>
<a name="ln5863">			mii = device_get_softc(sc-&gt;bge_miibus);</a>
<a name="ln5864">			error = ifmedia_ioctl(ifp, ifr,</a>
<a name="ln5865">			    &amp;mii-&gt;mii_media, command);</a>
<a name="ln5866">		}</a>
<a name="ln5867">		break;</a>
<a name="ln5868">	case SIOCSIFCAP:</a>
<a name="ln5869">		mask = ifr-&gt;ifr_reqcap ^ if_getcapenable(ifp);</a>
<a name="ln5870">#ifdef DEVICE_POLLING</a>
<a name="ln5871">		if (mask &amp; IFCAP_POLLING) {</a>
<a name="ln5872">			if (ifr-&gt;ifr_reqcap &amp; IFCAP_POLLING) {</a>
<a name="ln5873">				error = ether_poll_register(bge_poll, ifp);</a>
<a name="ln5874">				if (error)</a>
<a name="ln5875">					return (error);</a>
<a name="ln5876">				BGE_LOCK(sc);</a>
<a name="ln5877">				BGE_SETBIT(sc, BGE_PCI_MISC_CTL,</a>
<a name="ln5878">				    BGE_PCIMISCCTL_MASK_PCI_INTR);</a>
<a name="ln5879">				bge_writembx(sc, BGE_MBX_IRQ0_LO, 1);</a>
<a name="ln5880">				if_setcapenablebit(ifp, IFCAP_POLLING, 0);</a>
<a name="ln5881">				BGE_UNLOCK(sc);</a>
<a name="ln5882">			} else {</a>
<a name="ln5883">				error = ether_poll_deregister(ifp);</a>
<a name="ln5884">				/* Enable interrupt even in error case */</a>
<a name="ln5885">				BGE_LOCK(sc);</a>
<a name="ln5886">				BGE_CLRBIT(sc, BGE_PCI_MISC_CTL,</a>
<a name="ln5887">				    BGE_PCIMISCCTL_MASK_PCI_INTR);</a>
<a name="ln5888">				bge_writembx(sc, BGE_MBX_IRQ0_LO, 0);</a>
<a name="ln5889">				if_setcapenablebit(ifp, 0, IFCAP_POLLING);</a>
<a name="ln5890">				BGE_UNLOCK(sc);</a>
<a name="ln5891">			}</a>
<a name="ln5892">		}</a>
<a name="ln5893">#endif</a>
<a name="ln5894">		if ((mask &amp; IFCAP_TXCSUM) != 0 &amp;&amp;</a>
<a name="ln5895">		    (if_getcapabilities(ifp) &amp; IFCAP_TXCSUM) != 0) {</a>
<a name="ln5896">			if_togglecapenable(ifp, IFCAP_TXCSUM);</a>
<a name="ln5897">			if ((if_getcapenable(ifp) &amp; IFCAP_TXCSUM) != 0)</a>
<a name="ln5898">				if_sethwassistbits(ifp,</a>
<a name="ln5899">				    sc-&gt;bge_csum_features, 0);</a>
<a name="ln5900">			else</a>
<a name="ln5901">				if_sethwassistbits(ifp, 0,</a>
<a name="ln5902">				    sc-&gt;bge_csum_features);</a>
<a name="ln5903">		}</a>
<a name="ln5904"> </a>
<a name="ln5905">		if ((mask &amp; IFCAP_RXCSUM) != 0 &amp;&amp;</a>
<a name="ln5906">		    (if_getcapabilities(ifp) &amp; IFCAP_RXCSUM) != 0)</a>
<a name="ln5907">			if_togglecapenable(ifp, IFCAP_RXCSUM);</a>
<a name="ln5908"> </a>
<a name="ln5909">		if ((mask &amp; IFCAP_TSO4) != 0 &amp;&amp;</a>
<a name="ln5910">		    (if_getcapabilities(ifp) &amp; IFCAP_TSO4) != 0) {</a>
<a name="ln5911">			if_togglecapenable(ifp, IFCAP_TSO4);</a>
<a name="ln5912">			if ((if_getcapenable(ifp) &amp; IFCAP_TSO4) != 0)</a>
<a name="ln5913">				if_sethwassistbits(ifp, CSUM_TSO, 0);</a>
<a name="ln5914">			else</a>
<a name="ln5915">				if_sethwassistbits(ifp, 0, CSUM_TSO);</a>
<a name="ln5916">		}</a>
<a name="ln5917"> </a>
<a name="ln5918">		if (mask &amp; IFCAP_VLAN_MTU) {</a>
<a name="ln5919">			if_togglecapenable(ifp, IFCAP_VLAN_MTU);</a>
<a name="ln5920">			if_setdrvflagbits(ifp, 0, IFF_DRV_RUNNING);</a>
<a name="ln5921">			bge_init(sc);</a>
<a name="ln5922">		}</a>
<a name="ln5923"> </a>
<a name="ln5924">		if ((mask &amp; IFCAP_VLAN_HWTSO) != 0 &amp;&amp;</a>
<a name="ln5925">		    (if_getcapabilities(ifp) &amp; IFCAP_VLAN_HWTSO) != 0)</a>
<a name="ln5926">			if_togglecapenable(ifp, IFCAP_VLAN_HWTSO);</a>
<a name="ln5927">		if ((mask &amp; IFCAP_VLAN_HWTAGGING) != 0 &amp;&amp;</a>
<a name="ln5928">		    (if_getcapabilities(ifp) &amp; IFCAP_VLAN_HWTAGGING) != 0) {</a>
<a name="ln5929">			if_togglecapenable(ifp, IFCAP_VLAN_HWTAGGING);</a>
<a name="ln5930">			if ((if_getcapenable(ifp) &amp; IFCAP_VLAN_HWTAGGING) == 0)</a>
<a name="ln5931">				if_setcapenablebit(ifp, 0, IFCAP_VLAN_HWTSO);</a>
<a name="ln5932">			BGE_LOCK(sc);</a>
<a name="ln5933">			bge_setvlan(sc);</a>
<a name="ln5934">			BGE_UNLOCK(sc);</a>
<a name="ln5935">		}</a>
<a name="ln5936">#ifdef VLAN_CAPABILITIES</a>
<a name="ln5937">		if_vlancap(ifp);</a>
<a name="ln5938">#endif</a>
<a name="ln5939">		break;</a>
<a name="ln5940">	default:</a>
<a name="ln5941">		error = ether_ioctl(ifp, command, data);</a>
<a name="ln5942">		break;</a>
<a name="ln5943">	}</a>
<a name="ln5944"> </a>
<a name="ln5945">	return (error);</a>
<a name="ln5946">}</a>
<a name="ln5947"> </a>
<a name="ln5948">static void</a>
<a name="ln5949">bge_watchdog(struct bge_softc *sc)</a>
<a name="ln5950">{</a>
<a name="ln5951">	if_t ifp;</a>
<a name="ln5952">	uint32_t status;</a>
<a name="ln5953"> </a>
<a name="ln5954">	BGE_LOCK_ASSERT(sc);</a>
<a name="ln5955"> </a>
<a name="ln5956">	if (sc-&gt;bge_timer == 0 || --sc-&gt;bge_timer)</a>
<a name="ln5957">		return;</a>
<a name="ln5958"> </a>
<a name="ln5959">	/* If pause frames are active then don't reset the hardware. */</a>
<a name="ln5960">	if ((CSR_READ_4(sc, BGE_RX_MODE) &amp; BGE_RXMODE_FLOWCTL_ENABLE) != 0) {</a>
<a name="ln5961">		status = CSR_READ_4(sc, BGE_RX_STS);</a>
<a name="ln5962">		if ((status &amp; BGE_RXSTAT_REMOTE_XOFFED) != 0) {</a>
<a name="ln5963">			/*</a>
<a name="ln5964">			 * If link partner has us in XOFF state then wait for</a>
<a name="ln5965">			 * the condition to clear.</a>
<a name="ln5966">			 */</a>
<a name="ln5967">			CSR_WRITE_4(sc, BGE_RX_STS, status);</a>
<a name="ln5968">			sc-&gt;bge_timer = BGE_TX_TIMEOUT;</a>
<a name="ln5969">			return;</a>
<a name="ln5970">		} else if ((status &amp; BGE_RXSTAT_RCVD_XOFF) != 0 &amp;&amp;</a>
<a name="ln5971">		    (status &amp; BGE_RXSTAT_RCVD_XON) != 0) {</a>
<a name="ln5972">			/*</a>
<a name="ln5973">			 * If link partner has us in XOFF state then wait for</a>
<a name="ln5974">			 * the condition to clear.</a>
<a name="ln5975">			 */</a>
<a name="ln5976">			CSR_WRITE_4(sc, BGE_RX_STS, status);</a>
<a name="ln5977">			sc-&gt;bge_timer = BGE_TX_TIMEOUT;</a>
<a name="ln5978">			return;</a>
<a name="ln5979">		}</a>
<a name="ln5980">		/*</a>
<a name="ln5981">		 * Any other condition is unexpected and the controller</a>
<a name="ln5982">		 * should be reset.</a>
<a name="ln5983">		 */</a>
<a name="ln5984">	}</a>
<a name="ln5985"> </a>
<a name="ln5986">	ifp = sc-&gt;bge_ifp;</a>
<a name="ln5987"> </a>
<a name="ln5988">	if_printf(ifp, &quot;watchdog timeout -- resetting\n&quot;);</a>
<a name="ln5989"> </a>
<a name="ln5990">	if_setdrvflagbits(ifp, 0, IFF_DRV_RUNNING);</a>
<a name="ln5991">	bge_init_locked(sc);</a>
<a name="ln5992"> </a>
<a name="ln5993">	if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln5994">}</a>
<a name="ln5995"> </a>
<a name="ln5996">static void</a>
<a name="ln5997">bge_stop_block(struct bge_softc *sc, bus_size_t reg, uint32_t bit)</a>
<a name="ln5998">{</a>
<a name="ln5999">	int i;</a>
<a name="ln6000"> </a>
<a name="ln6001">	BGE_CLRBIT(sc, reg, bit);</a>
<a name="ln6002"> </a>
<a name="ln6003">	for (i = 0; i &lt; BGE_TIMEOUT; i++) {</a>
<a name="ln6004">		if ((CSR_READ_4(sc, reg) &amp; bit) == 0)</a>
<a name="ln6005">			return;</a>
<a name="ln6006">		DELAY(100);</a>
<a name="ln6007">        }</a>
<a name="ln6008">}</a>
<a name="ln6009"> </a>
<a name="ln6010">/*</a>
<a name="ln6011"> * Stop the adapter and free any mbufs allocated to the</a>
<a name="ln6012"> * RX and TX lists.</a>
<a name="ln6013"> */</a>
<a name="ln6014">static void</a>
<a name="ln6015">bge_stop(struct bge_softc *sc)</a>
<a name="ln6016">{</a>
<a name="ln6017">	if_t ifp;</a>
<a name="ln6018"> </a>
<a name="ln6019">	BGE_LOCK_ASSERT(sc);</a>
<a name="ln6020"> </a>
<a name="ln6021">	ifp = sc-&gt;bge_ifp;</a>
<a name="ln6022"> </a>
<a name="ln6023">	callout_stop(&amp;sc-&gt;bge_stat_ch);</a>
<a name="ln6024"> </a>
<a name="ln6025">	/* Disable host interrupts. */</a>
<a name="ln6026">	BGE_SETBIT(sc, BGE_PCI_MISC_CTL, BGE_PCIMISCCTL_MASK_PCI_INTR);</a>
<a name="ln6027">	bge_writembx(sc, BGE_MBX_IRQ0_LO, 1);</a>
<a name="ln6028"> </a>
<a name="ln6029">	/*</a>
<a name="ln6030">	 * Tell firmware we're shutting down.</a>
<a name="ln6031">	 */</a>
<a name="ln6032">	bge_stop_fw(sc);</a>
<a name="ln6033">	bge_sig_pre_reset(sc, BGE_RESET_SHUTDOWN);</a>
<a name="ln6034"> </a>
<a name="ln6035">	/*</a>
<a name="ln6036">	 * Disable all of the receiver blocks.</a>
<a name="ln6037">	 */</a>
<a name="ln6038">	bge_stop_block(sc, BGE_RX_MODE, BGE_RXMODE_ENABLE);</a>
<a name="ln6039">	bge_stop_block(sc, BGE_RBDI_MODE, BGE_RBDIMODE_ENABLE);</a>
<a name="ln6040">	bge_stop_block(sc, BGE_RXLP_MODE, BGE_RXLPMODE_ENABLE);</a>
<a name="ln6041">	if (BGE_IS_5700_FAMILY(sc))</a>
<a name="ln6042">		bge_stop_block(sc, BGE_RXLS_MODE, BGE_RXLSMODE_ENABLE);</a>
<a name="ln6043">	bge_stop_block(sc, BGE_RDBDI_MODE, BGE_RBDIMODE_ENABLE);</a>
<a name="ln6044">	bge_stop_block(sc, BGE_RDC_MODE, BGE_RDCMODE_ENABLE);</a>
<a name="ln6045">	bge_stop_block(sc, BGE_RBDC_MODE, BGE_RBDCMODE_ENABLE);</a>
<a name="ln6046"> </a>
<a name="ln6047">	/*</a>
<a name="ln6048">	 * Disable all of the transmit blocks.</a>
<a name="ln6049">	 */</a>
<a name="ln6050">	bge_stop_block(sc, BGE_SRS_MODE, BGE_SRSMODE_ENABLE);</a>
<a name="ln6051">	bge_stop_block(sc, BGE_SBDI_MODE, BGE_SBDIMODE_ENABLE);</a>
<a name="ln6052">	bge_stop_block(sc, BGE_SDI_MODE, BGE_SDIMODE_ENABLE);</a>
<a name="ln6053">	bge_stop_block(sc, BGE_RDMA_MODE, BGE_RDMAMODE_ENABLE);</a>
<a name="ln6054">	bge_stop_block(sc, BGE_SDC_MODE, BGE_SDCMODE_ENABLE);</a>
<a name="ln6055">	if (BGE_IS_5700_FAMILY(sc))</a>
<a name="ln6056">		bge_stop_block(sc, BGE_DMAC_MODE, BGE_DMACMODE_ENABLE);</a>
<a name="ln6057">	bge_stop_block(sc, BGE_SBDC_MODE, BGE_SBDCMODE_ENABLE);</a>
<a name="ln6058"> </a>
<a name="ln6059">	/*</a>
<a name="ln6060">	 * Shut down all of the memory managers and related</a>
<a name="ln6061">	 * state machines.</a>
<a name="ln6062">	 */</a>
<a name="ln6063">	bge_stop_block(sc, BGE_HCC_MODE, BGE_HCCMODE_ENABLE);</a>
<a name="ln6064">	bge_stop_block(sc, BGE_WDMA_MODE, BGE_WDMAMODE_ENABLE);</a>
<a name="ln6065">	if (BGE_IS_5700_FAMILY(sc))</a>
<a name="ln6066">		bge_stop_block(sc, BGE_MBCF_MODE, BGE_MBCFMODE_ENABLE);</a>
<a name="ln6067"> </a>
<a name="ln6068">	CSR_WRITE_4(sc, BGE_FTQ_RESET, 0xFFFFFFFF);</a>
<a name="ln6069">	CSR_WRITE_4(sc, BGE_FTQ_RESET, 0);</a>
<a name="ln6070">	if (!(BGE_IS_5705_PLUS(sc))) {</a>
<a name="ln6071">		BGE_CLRBIT(sc, BGE_BMAN_MODE, BGE_BMANMODE_ENABLE);</a>
<a name="ln6072">		BGE_CLRBIT(sc, BGE_MARB_MODE, BGE_MARBMODE_ENABLE);</a>
<a name="ln6073">	}</a>
<a name="ln6074">	/* Update MAC statistics. */</a>
<a name="ln6075">	if (BGE_IS_5705_PLUS(sc))</a>
<a name="ln6076">		bge_stats_update_regs(sc);</a>
<a name="ln6077"> </a>
<a name="ln6078">	bge_reset(sc);</a>
<a name="ln6079">	bge_sig_legacy(sc, BGE_RESET_SHUTDOWN);</a>
<a name="ln6080">	bge_sig_post_reset(sc, BGE_RESET_SHUTDOWN);</a>
<a name="ln6081"> </a>
<a name="ln6082">	/*</a>
<a name="ln6083">	 * Keep the ASF firmware running if up.</a>
<a name="ln6084">	 */</a>
<a name="ln6085">	if (sc-&gt;bge_asf_mode &amp; ASF_STACKUP)</a>
<a name="ln6086">		BGE_SETBIT(sc, BGE_MODE_CTL, BGE_MODECTL_STACKUP);</a>
<a name="ln6087">	else</a>
<a name="ln6088">		BGE_CLRBIT(sc, BGE_MODE_CTL, BGE_MODECTL_STACKUP);</a>
<a name="ln6089"> </a>
<a name="ln6090">	/* Free the RX lists. */</a>
<a name="ln6091">	bge_free_rx_ring_std(sc);</a>
<a name="ln6092"> </a>
<a name="ln6093">	/* Free jumbo RX list. */</a>
<a name="ln6094">	if (BGE_IS_JUMBO_CAPABLE(sc))</a>
<a name="ln6095">		bge_free_rx_ring_jumbo(sc);</a>
<a name="ln6096"> </a>
<a name="ln6097">	/* Free TX buffers. */</a>
<a name="ln6098">	bge_free_tx_ring(sc);</a>
<a name="ln6099"> </a>
<a name="ln6100">	sc-&gt;bge_tx_saved_considx = BGE_TXCONS_UNSET;</a>
<a name="ln6101"> </a>
<a name="ln6102">	/* Clear MAC's link state (PHY may still have link UP). */</a>
<a name="ln6103">	if (bootverbose &amp;&amp; sc-&gt;bge_link)</a>
<a name="ln6104">		if_printf(sc-&gt;bge_ifp, &quot;link DOWN\n&quot;);</a>
<a name="ln6105">	sc-&gt;bge_link = 0;</a>
<a name="ln6106"> </a>
<a name="ln6107">	if_setdrvflagbits(ifp, 0, (IFF_DRV_RUNNING | IFF_DRV_OACTIVE));</a>
<a name="ln6108">}</a>
<a name="ln6109"> </a>
<a name="ln6110">/*</a>
<a name="ln6111"> * Stop all chip I/O so that the kernel's probe routines don't</a>
<a name="ln6112"> * get confused by errant DMAs when rebooting.</a>
<a name="ln6113"> */</a>
<a name="ln6114">static int</a>
<a name="ln6115">bge_shutdown(device_t dev)</a>
<a name="ln6116">{</a>
<a name="ln6117">	struct bge_softc *sc;</a>
<a name="ln6118"> </a>
<a name="ln6119">	sc = device_get_softc(dev);</a>
<a name="ln6120">	BGE_LOCK(sc);</a>
<a name="ln6121">	bge_stop(sc);</a>
<a name="ln6122">	BGE_UNLOCK(sc);</a>
<a name="ln6123"> </a>
<a name="ln6124">	return (0);</a>
<a name="ln6125">}</a>
<a name="ln6126"> </a>
<a name="ln6127">static int</a>
<a name="ln6128">bge_suspend(device_t dev)</a>
<a name="ln6129">{</a>
<a name="ln6130">	struct bge_softc *sc;</a>
<a name="ln6131"> </a>
<a name="ln6132">	sc = device_get_softc(dev);</a>
<a name="ln6133">	BGE_LOCK(sc);</a>
<a name="ln6134">	bge_stop(sc);</a>
<a name="ln6135">	BGE_UNLOCK(sc);</a>
<a name="ln6136"> </a>
<a name="ln6137">	return (0);</a>
<a name="ln6138">}</a>
<a name="ln6139"> </a>
<a name="ln6140">static int</a>
<a name="ln6141">bge_resume(device_t dev)</a>
<a name="ln6142">{</a>
<a name="ln6143">	struct bge_softc *sc;</a>
<a name="ln6144">	if_t ifp;</a>
<a name="ln6145"> </a>
<a name="ln6146">	sc = device_get_softc(dev);</a>
<a name="ln6147">	BGE_LOCK(sc);</a>
<a name="ln6148">	ifp = sc-&gt;bge_ifp;</a>
<a name="ln6149">	if (if_getflags(ifp) &amp; IFF_UP) {</a>
<a name="ln6150">		bge_init_locked(sc);</a>
<a name="ln6151">		if (if_getdrvflags(ifp) &amp; IFF_DRV_RUNNING)</a>
<a name="ln6152">			bge_start_locked(ifp);</a>
<a name="ln6153">	}</a>
<a name="ln6154">	BGE_UNLOCK(sc);</a>
<a name="ln6155"> </a>
<a name="ln6156">	return (0);</a>
<a name="ln6157">}</a>
<a name="ln6158"> </a>
<a name="ln6159">static void</a>
<a name="ln6160">bge_link_upd(struct bge_softc *sc)</a>
<a name="ln6161">{</a>
<a name="ln6162">	struct mii_data *mii;</a>
<a name="ln6163">	uint32_t link, status;</a>
<a name="ln6164"> </a>
<a name="ln6165">	BGE_LOCK_ASSERT(sc);</a>
<a name="ln6166"> </a>
<a name="ln6167">	/* Clear 'pending link event' flag. */</a>
<a name="ln6168">	sc-&gt;bge_link_evt = 0;</a>
<a name="ln6169"> </a>
<a name="ln6170">	/*</a>
<a name="ln6171">	 * Process link state changes.</a>
<a name="ln6172">	 * Grrr. The link status word in the status block does</a>
<a name="ln6173">	 * not work correctly on the BCM5700 rev AX and BX chips,</a>
<a name="ln6174">	 * according to all available information. Hence, we have</a>
<a name="ln6175">	 * to enable MII interrupts in order to properly obtain</a>
<a name="ln6176">	 * async link changes. Unfortunately, this also means that</a>
<a name="ln6177">	 * we have to read the MAC status register to detect link</a>
<a name="ln6178">	 * changes, thereby adding an additional register access to</a>
<a name="ln6179">	 * the interrupt handler.</a>
<a name="ln6180">	 *</a>
<a name="ln6181">	 * XXX: perhaps link state detection procedure used for</a>
<a name="ln6182">	 * BGE_CHIPID_BCM5700_B2 can be used for others BCM5700 revisions.</a>
<a name="ln6183">	 */</a>
<a name="ln6184"> </a>
<a name="ln6185">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5700 &amp;&amp;</a>
<a name="ln6186">	    sc-&gt;bge_chipid != BGE_CHIPID_BCM5700_B2) {</a>
<a name="ln6187">		status = CSR_READ_4(sc, BGE_MAC_STS);</a>
<a name="ln6188">		if (status &amp; BGE_MACSTAT_MI_INTERRUPT) {</a>
<a name="ln6189">			mii = device_get_softc(sc-&gt;bge_miibus);</a>
<a name="ln6190">			mii_pollstat(mii);</a>
<a name="ln6191">			if (!sc-&gt;bge_link &amp;&amp;</a>
<a name="ln6192">			    mii-&gt;mii_media_status &amp; IFM_ACTIVE &amp;&amp;</a>
<a name="ln6193">			    IFM_SUBTYPE(mii-&gt;mii_media_active) != IFM_NONE) {</a>
<a name="ln6194">				sc-&gt;bge_link++;</a>
<a name="ln6195">				if (bootverbose)</a>
<a name="ln6196">					if_printf(sc-&gt;bge_ifp, &quot;link UP\n&quot;);</a>
<a name="ln6197">			} else if (sc-&gt;bge_link &amp;&amp;</a>
<a name="ln6198">			    (!(mii-&gt;mii_media_status &amp; IFM_ACTIVE) ||</a>
<a name="ln6199">			    IFM_SUBTYPE(mii-&gt;mii_media_active) == IFM_NONE)) {</a>
<a name="ln6200">				sc-&gt;bge_link = 0;</a>
<a name="ln6201">				if (bootverbose)</a>
<a name="ln6202">					if_printf(sc-&gt;bge_ifp, &quot;link DOWN\n&quot;);</a>
<a name="ln6203">			}</a>
<a name="ln6204"> </a>
<a name="ln6205">			/* Clear the interrupt. */</a>
<a name="ln6206">			CSR_WRITE_4(sc, BGE_MAC_EVT_ENB,</a>
<a name="ln6207">			    BGE_EVTENB_MI_INTERRUPT);</a>
<a name="ln6208">			bge_miibus_readreg(sc-&gt;bge_dev, sc-&gt;bge_phy_addr,</a>
<a name="ln6209">			    BRGPHY_MII_ISR);</a>
<a name="ln6210">			bge_miibus_writereg(sc-&gt;bge_dev, sc-&gt;bge_phy_addr,</a>
<a name="ln6211">			    BRGPHY_MII_IMR, BRGPHY_INTRS);</a>
<a name="ln6212">		}</a>
<a name="ln6213">		return;</a>
<a name="ln6214">	}</a>
<a name="ln6215"> </a>
<a name="ln6216">	if (sc-&gt;bge_flags &amp; BGE_FLAG_TBI) {</a>
<a name="ln6217">		status = CSR_READ_4(sc, BGE_MAC_STS);</a>
<a name="ln6218">		if (status &amp; BGE_MACSTAT_TBI_PCS_SYNCHED) {</a>
<a name="ln6219">			if (!sc-&gt;bge_link) {</a>
<a name="ln6220">				sc-&gt;bge_link++;</a>
<a name="ln6221">				if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5704) {</a>
<a name="ln6222">					BGE_CLRBIT(sc, BGE_MAC_MODE,</a>
<a name="ln6223">					    BGE_MACMODE_TBI_SEND_CFGS);</a>
<a name="ln6224">					DELAY(40);</a>
<a name="ln6225">				}</a>
<a name="ln6226">				CSR_WRITE_4(sc, BGE_MAC_STS, 0xFFFFFFFF);</a>
<a name="ln6227">				if (bootverbose)</a>
<a name="ln6228">					if_printf(sc-&gt;bge_ifp, &quot;link UP\n&quot;);</a>
<a name="ln6229">				if_link_state_change(sc-&gt;bge_ifp,</a>
<a name="ln6230">				    LINK_STATE_UP);</a>
<a name="ln6231">			}</a>
<a name="ln6232">		} else if (sc-&gt;bge_link) {</a>
<a name="ln6233">			sc-&gt;bge_link = 0;</a>
<a name="ln6234">			if (bootverbose)</a>
<a name="ln6235">				if_printf(sc-&gt;bge_ifp, &quot;link DOWN\n&quot;);</a>
<a name="ln6236">			if_link_state_change(sc-&gt;bge_ifp, LINK_STATE_DOWN);</a>
<a name="ln6237">		}</a>
<a name="ln6238">	} else if ((sc-&gt;bge_mi_mode &amp; BGE_MIMODE_AUTOPOLL) != 0) {</a>
<a name="ln6239">		/*</a>
<a name="ln6240">		 * Some broken BCM chips have BGE_STATFLAG_LINKSTATE_CHANGED bit</a>
<a name="ln6241">		 * in status word always set. Workaround this bug by reading</a>
<a name="ln6242">		 * PHY link status directly.</a>
<a name="ln6243">		 */</a>
<a name="ln6244">		link = (CSR_READ_4(sc, BGE_MI_STS) &amp; BGE_MISTS_LINK) ? 1 : 0;</a>
<a name="ln6245"> </a>
<a name="ln6246">		if (link != sc-&gt;bge_link ||</a>
<a name="ln6247">		    sc-&gt;bge_asicrev == BGE_ASICREV_BCM5700) {</a>
<a name="ln6248">			mii = device_get_softc(sc-&gt;bge_miibus);</a>
<a name="ln6249">			mii_pollstat(mii);</a>
<a name="ln6250">			if (!sc-&gt;bge_link &amp;&amp;</a>
<a name="ln6251">			    mii-&gt;mii_media_status &amp; IFM_ACTIVE &amp;&amp;</a>
<a name="ln6252">			    IFM_SUBTYPE(mii-&gt;mii_media_active) != IFM_NONE) {</a>
<a name="ln6253">				sc-&gt;bge_link++;</a>
<a name="ln6254">				if (bootverbose)</a>
<a name="ln6255">					if_printf(sc-&gt;bge_ifp, &quot;link UP\n&quot;);</a>
<a name="ln6256">			} else if (sc-&gt;bge_link &amp;&amp;</a>
<a name="ln6257">			    (!(mii-&gt;mii_media_status &amp; IFM_ACTIVE) ||</a>
<a name="ln6258">			    IFM_SUBTYPE(mii-&gt;mii_media_active) == IFM_NONE)) {</a>
<a name="ln6259">				sc-&gt;bge_link = 0;</a>
<a name="ln6260">				if (bootverbose)</a>
<a name="ln6261">					if_printf(sc-&gt;bge_ifp, &quot;link DOWN\n&quot;);</a>
<a name="ln6262">			}</a>
<a name="ln6263">		}</a>
<a name="ln6264">	} else {</a>
<a name="ln6265">		/*</a>
<a name="ln6266">		 * For controllers that call mii_tick, we have to poll</a>
<a name="ln6267">		 * link status.</a>
<a name="ln6268">		 */</a>
<a name="ln6269">		mii = device_get_softc(sc-&gt;bge_miibus);</a>
<a name="ln6270">		mii_pollstat(mii);</a>
<a name="ln6271">		bge_miibus_statchg(sc-&gt;bge_dev);</a>
<a name="ln6272">	}</a>
<a name="ln6273"> </a>
<a name="ln6274">	/* Disable MAC attention when link is up. */</a>
<a name="ln6275">	CSR_WRITE_4(sc, BGE_MAC_STS, BGE_MACSTAT_SYNC_CHANGED |</a>
<a name="ln6276">	    BGE_MACSTAT_CFG_CHANGED | BGE_MACSTAT_MI_COMPLETE |</a>
<a name="ln6277">	    BGE_MACSTAT_LINK_CHANGED);</a>
<a name="ln6278">}</a>
<a name="ln6279"> </a>
<a name="ln6280">static void</a>
<a name="ln6281">bge_add_sysctls(struct bge_softc *sc)</a>
<a name="ln6282">{</a>
<a name="ln6283">	struct sysctl_ctx_list *ctx;</a>
<a name="ln6284">	struct sysctl_oid_list *children;</a>
<a name="ln6285">	int unit;</a>
<a name="ln6286"> </a>
<a name="ln6287">	ctx = device_get_sysctl_ctx(sc-&gt;bge_dev);</a>
<a name="ln6288">	children = SYSCTL_CHILDREN(device_get_sysctl_tree(sc-&gt;bge_dev));</a>
<a name="ln6289"> </a>
<a name="ln6290">#ifdef BGE_REGISTER_DEBUG</a>
<a name="ln6291">	SYSCTL_ADD_PROC(ctx, children, OID_AUTO, &quot;debug_info&quot;,</a>
<a name="ln6292">	    CTLTYPE_INT | CTLFLAG_RW, sc, 0, bge_sysctl_debug_info, &quot;I&quot;,</a>
<a name="ln6293">	    &quot;Debug Information&quot;);</a>
<a name="ln6294"> </a>
<a name="ln6295">	SYSCTL_ADD_PROC(ctx, children, OID_AUTO, &quot;reg_read&quot;,</a>
<a name="ln6296">	    CTLTYPE_INT | CTLFLAG_RW, sc, 0, bge_sysctl_reg_read, &quot;I&quot;,</a>
<a name="ln6297">	    &quot;MAC Register Read&quot;);</a>
<a name="ln6298"> </a>
<a name="ln6299">	SYSCTL_ADD_PROC(ctx, children, OID_AUTO, &quot;ape_read&quot;,</a>
<a name="ln6300">	    CTLTYPE_INT | CTLFLAG_RW, sc, 0, bge_sysctl_ape_read, &quot;I&quot;,</a>
<a name="ln6301">	    &quot;APE Register Read&quot;);</a>
<a name="ln6302"> </a>
<a name="ln6303">	SYSCTL_ADD_PROC(ctx, children, OID_AUTO, &quot;mem_read&quot;,</a>
<a name="ln6304">	    CTLTYPE_INT | CTLFLAG_RW, sc, 0, bge_sysctl_mem_read, &quot;I&quot;,</a>
<a name="ln6305">	    &quot;Memory Read&quot;);</a>
<a name="ln6306"> </a>
<a name="ln6307">#endif</a>
<a name="ln6308"> </a>
<a name="ln6309">	unit = device_get_unit(sc-&gt;bge_dev);</a>
<a name="ln6310">	/*</a>
<a name="ln6311">	 * A common design characteristic for many Broadcom client controllers</a>
<a name="ln6312">	 * is that they only support a single outstanding DMA read operation</a>
<a name="ln6313">	 * on the PCIe bus. This means that it will take twice as long to fetch</a>
<a name="ln6314">	 * a TX frame that is split into header and payload buffers as it does</a>
<a name="ln6315">	 * to fetch a single, contiguous TX frame (2 reads vs. 1 read). For</a>
<a name="ln6316">	 * these controllers, coalescing buffers to reduce the number of memory</a>
<a name="ln6317">	 * reads is effective way to get maximum performance(about 940Mbps).</a>
<a name="ln6318">	 * Without collapsing TX buffers the maximum TCP bulk transfer</a>
<a name="ln6319">	 * performance is about 850Mbps. However forcing coalescing mbufs</a>
<a name="ln6320">	 * consumes a lot of CPU cycles, so leave it off by default.</a>
<a name="ln6321">	 */</a>
<a name="ln6322">	sc-&gt;bge_forced_collapse = 0;</a>
<a name="ln6323">	SYSCTL_ADD_INT(ctx, children, OID_AUTO, &quot;forced_collapse&quot;,</a>
<a name="ln6324">	    CTLFLAG_RWTUN, &amp;sc-&gt;bge_forced_collapse, 0,</a>
<a name="ln6325">	    &quot;Number of fragmented TX buffers of a frame allowed before &quot;</a>
<a name="ln6326">	    &quot;forced collapsing&quot;);</a>
<a name="ln6327"> </a>
<a name="ln6328">	sc-&gt;bge_msi = 1;</a>
<a name="ln6329">	SYSCTL_ADD_INT(ctx, children, OID_AUTO, &quot;msi&quot;,</a>
<a name="ln6330">	    CTLFLAG_RDTUN, &amp;sc-&gt;bge_msi, 0, &quot;Enable MSI&quot;);</a>
<a name="ln6331"> </a>
<a name="ln6332">	/*</a>
<a name="ln6333">	 * It seems all Broadcom controllers have a bug that can generate UDP</a>
<a name="ln6334">	 * datagrams with checksum value 0 when TX UDP checksum offloading is</a>
<a name="ln6335">	 * enabled.  Generating UDP checksum value 0 is RFC 768 violation.</a>
<a name="ln6336">	 * Even though the probability of generating such UDP datagrams is</a>
<a name="ln6337">	 * low, I don't want to see FreeBSD boxes to inject such datagrams</a>
<a name="ln6338">	 * into network so disable UDP checksum offloading by default.  Users</a>
<a name="ln6339">	 * still override this behavior by setting a sysctl variable,</a>
<a name="ln6340">	 * dev.bge.0.forced_udpcsum.</a>
<a name="ln6341">	 */</a>
<a name="ln6342">	sc-&gt;bge_forced_udpcsum = 0;</a>
<a name="ln6343">	SYSCTL_ADD_INT(ctx, children, OID_AUTO, &quot;forced_udpcsum&quot;,</a>
<a name="ln6344">	    CTLFLAG_RWTUN, &amp;sc-&gt;bge_forced_udpcsum, 0,</a>
<a name="ln6345">	    &quot;Enable UDP checksum offloading even if controller can &quot;</a>
<a name="ln6346">	    &quot;generate UDP checksum value 0&quot;);</a>
<a name="ln6347"> </a>
<a name="ln6348">	if (BGE_IS_5705_PLUS(sc))</a>
<a name="ln6349">		bge_add_sysctl_stats_regs(sc, ctx, children);</a>
<a name="ln6350">	else</a>
<a name="ln6351">		bge_add_sysctl_stats(sc, ctx, children);</a>
<a name="ln6352">}</a>
<a name="ln6353"> </a>
<a name="ln6354">#define BGE_SYSCTL_STAT(sc, ctx, desc, parent, node, oid) \</a>
<a name="ln6355">	SYSCTL_ADD_PROC(ctx, parent, OID_AUTO, oid, CTLTYPE_UINT|CTLFLAG_RD, \</a>
<a name="ln6356">	    sc, offsetof(struct bge_stats, node), bge_sysctl_stats, &quot;IU&quot;, \</a>
<a name="ln6357">	    desc)</a>
<a name="ln6358"> </a>
<a name="ln6359">static void</a>
<a name="ln6360">bge_add_sysctl_stats(struct bge_softc *sc, struct sysctl_ctx_list *ctx,</a>
<a name="ln6361">    struct sysctl_oid_list *parent)</a>
<a name="ln6362">{</a>
<a name="ln6363">	struct sysctl_oid *tree;</a>
<a name="ln6364">	struct sysctl_oid_list *children, *schildren;</a>
<a name="ln6365"> </a>
<a name="ln6366">	tree = SYSCTL_ADD_NODE(ctx, parent, OID_AUTO, &quot;stats&quot;, CTLFLAG_RD,</a>
<a name="ln6367">	    NULL, &quot;BGE Statistics&quot;);</a>
<a name="ln6368">	schildren = children = SYSCTL_CHILDREN(tree);</a>
<a name="ln6369">	BGE_SYSCTL_STAT(sc, ctx, &quot;Frames Dropped Due To Filters&quot;,</a>
<a name="ln6370">	    children, COSFramesDroppedDueToFilters,</a>
<a name="ln6371">	    &quot;FramesDroppedDueToFilters&quot;);</a>
<a name="ln6372">	BGE_SYSCTL_STAT(sc, ctx, &quot;NIC DMA Write Queue Full&quot;,</a>
<a name="ln6373">	    children, nicDmaWriteQueueFull, &quot;DmaWriteQueueFull&quot;);</a>
<a name="ln6374">	BGE_SYSCTL_STAT(sc, ctx, &quot;NIC DMA Write High Priority Queue Full&quot;,</a>
<a name="ln6375">	    children, nicDmaWriteHighPriQueueFull, &quot;DmaWriteHighPriQueueFull&quot;);</a>
<a name="ln6376">	BGE_SYSCTL_STAT(sc, ctx, &quot;NIC No More RX Buffer Descriptors&quot;,</a>
<a name="ln6377">	    children, nicNoMoreRxBDs, &quot;NoMoreRxBDs&quot;);</a>
<a name="ln6378">	BGE_SYSCTL_STAT(sc, ctx, &quot;Discarded Input Frames&quot;,</a>
<a name="ln6379">	    children, ifInDiscards, &quot;InputDiscards&quot;);</a>
<a name="ln6380">	BGE_SYSCTL_STAT(sc, ctx, &quot;Input Errors&quot;,</a>
<a name="ln6381">	    children, ifInErrors, &quot;InputErrors&quot;);</a>
<a name="ln6382">	BGE_SYSCTL_STAT(sc, ctx, &quot;NIC Recv Threshold Hit&quot;,</a>
<a name="ln6383">	    children, nicRecvThresholdHit, &quot;RecvThresholdHit&quot;);</a>
<a name="ln6384">	BGE_SYSCTL_STAT(sc, ctx, &quot;NIC DMA Read Queue Full&quot;,</a>
<a name="ln6385">	    children, nicDmaReadQueueFull, &quot;DmaReadQueueFull&quot;);</a>
<a name="ln6386">	BGE_SYSCTL_STAT(sc, ctx, &quot;NIC DMA Read High Priority Queue Full&quot;,</a>
<a name="ln6387">	    children, nicDmaReadHighPriQueueFull, &quot;DmaReadHighPriQueueFull&quot;);</a>
<a name="ln6388">	BGE_SYSCTL_STAT(sc, ctx, &quot;NIC Send Data Complete Queue Full&quot;,</a>
<a name="ln6389">	    children, nicSendDataCompQueueFull, &quot;SendDataCompQueueFull&quot;);</a>
<a name="ln6390">	BGE_SYSCTL_STAT(sc, ctx, &quot;NIC Ring Set Send Producer Index&quot;,</a>
<a name="ln6391">	    children, nicRingSetSendProdIndex, &quot;RingSetSendProdIndex&quot;);</a>
<a name="ln6392">	BGE_SYSCTL_STAT(sc, ctx, &quot;NIC Ring Status Update&quot;,</a>
<a name="ln6393">	    children, nicRingStatusUpdate, &quot;RingStatusUpdate&quot;);</a>
<a name="ln6394">	BGE_SYSCTL_STAT(sc, ctx, &quot;NIC Interrupts&quot;,</a>
<a name="ln6395">	    children, nicInterrupts, &quot;Interrupts&quot;);</a>
<a name="ln6396">	BGE_SYSCTL_STAT(sc, ctx, &quot;NIC Avoided Interrupts&quot;,</a>
<a name="ln6397">	    children, nicAvoidedInterrupts, &quot;AvoidedInterrupts&quot;);</a>
<a name="ln6398">	BGE_SYSCTL_STAT(sc, ctx, &quot;NIC Send Threshold Hit&quot;,</a>
<a name="ln6399">	    children, nicSendThresholdHit, &quot;SendThresholdHit&quot;);</a>
<a name="ln6400"> </a>
<a name="ln6401">	tree = SYSCTL_ADD_NODE(ctx, schildren, OID_AUTO, &quot;rx&quot;, CTLFLAG_RD,</a>
<a name="ln6402">	    NULL, &quot;BGE RX Statistics&quot;);</a>
<a name="ln6403">	children = SYSCTL_CHILDREN(tree);</a>
<a name="ln6404">	BGE_SYSCTL_STAT(sc, ctx, &quot;Inbound Octets&quot;,</a>
<a name="ln6405">	    children, rxstats.ifHCInOctets, &quot;ifHCInOctets&quot;);</a>
<a name="ln6406">	BGE_SYSCTL_STAT(sc, ctx, &quot;Fragments&quot;,</a>
<a name="ln6407">	    children, rxstats.etherStatsFragments, &quot;Fragments&quot;);</a>
<a name="ln6408">	BGE_SYSCTL_STAT(sc, ctx, &quot;Inbound Unicast Packets&quot;,</a>
<a name="ln6409">	    children, rxstats.ifHCInUcastPkts, &quot;UnicastPkts&quot;);</a>
<a name="ln6410">	BGE_SYSCTL_STAT(sc, ctx, &quot;Inbound Multicast Packets&quot;,</a>
<a name="ln6411">	    children, rxstats.ifHCInMulticastPkts, &quot;MulticastPkts&quot;);</a>
<a name="ln6412">	BGE_SYSCTL_STAT(sc, ctx, &quot;FCS Errors&quot;,</a>
<a name="ln6413">	    children, rxstats.dot3StatsFCSErrors, &quot;FCSErrors&quot;);</a>
<a name="ln6414">	BGE_SYSCTL_STAT(sc, ctx, &quot;Alignment Errors&quot;,</a>
<a name="ln6415">	    children, rxstats.dot3StatsAlignmentErrors, &quot;AlignmentErrors&quot;);</a>
<a name="ln6416">	BGE_SYSCTL_STAT(sc, ctx, &quot;XON Pause Frames Received&quot;,</a>
<a name="ln6417">	    children, rxstats.xonPauseFramesReceived, &quot;xonPauseFramesReceived&quot;);</a>
<a name="ln6418">	BGE_SYSCTL_STAT(sc, ctx, &quot;XOFF Pause Frames Received&quot;,</a>
<a name="ln6419">	    children, rxstats.xoffPauseFramesReceived,</a>
<a name="ln6420">	    &quot;xoffPauseFramesReceived&quot;);</a>
<a name="ln6421">	BGE_SYSCTL_STAT(sc, ctx, &quot;MAC Control Frames Received&quot;,</a>
<a name="ln6422">	    children, rxstats.macControlFramesReceived,</a>
<a name="ln6423">	    &quot;ControlFramesReceived&quot;);</a>
<a name="ln6424">	BGE_SYSCTL_STAT(sc, ctx, &quot;XOFF State Entered&quot;,</a>
<a name="ln6425">	    children, rxstats.xoffStateEntered, &quot;xoffStateEntered&quot;);</a>
<a name="ln6426">	BGE_SYSCTL_STAT(sc, ctx, &quot;Frames Too Long&quot;,</a>
<a name="ln6427">	    children, rxstats.dot3StatsFramesTooLong, &quot;FramesTooLong&quot;);</a>
<a name="ln6428">	BGE_SYSCTL_STAT(sc, ctx, &quot;Jabbers&quot;,</a>
<a name="ln6429">	    children, rxstats.etherStatsJabbers, &quot;Jabbers&quot;);</a>
<a name="ln6430">	BGE_SYSCTL_STAT(sc, ctx, &quot;Undersized Packets&quot;,</a>
<a name="ln6431">	    children, rxstats.etherStatsUndersizePkts, &quot;UndersizePkts&quot;);</a>
<a name="ln6432">	BGE_SYSCTL_STAT(sc, ctx, &quot;Inbound Range Length Errors&quot;,</a>
<a name="ln6433">	    children, rxstats.inRangeLengthError, &quot;inRangeLengthError&quot;);</a>
<a name="ln6434">	BGE_SYSCTL_STAT(sc, ctx, &quot;Outbound Range Length Errors&quot;,</a>
<a name="ln6435">	    children, rxstats.outRangeLengthError, &quot;outRangeLengthError&quot;);</a>
<a name="ln6436"> </a>
<a name="ln6437">	tree = SYSCTL_ADD_NODE(ctx, schildren, OID_AUTO, &quot;tx&quot;, CTLFLAG_RD,</a>
<a name="ln6438">	    NULL, &quot;BGE TX Statistics&quot;);</a>
<a name="ln6439">	children = SYSCTL_CHILDREN(tree);</a>
<a name="ln6440">	BGE_SYSCTL_STAT(sc, ctx, &quot;Outbound Octets&quot;,</a>
<a name="ln6441">	    children, txstats.ifHCOutOctets, &quot;ifHCOutOctets&quot;);</a>
<a name="ln6442">	BGE_SYSCTL_STAT(sc, ctx, &quot;TX Collisions&quot;,</a>
<a name="ln6443">	    children, txstats.etherStatsCollisions, &quot;Collisions&quot;);</a>
<a name="ln6444">	BGE_SYSCTL_STAT(sc, ctx, &quot;XON Sent&quot;,</a>
<a name="ln6445">	    children, txstats.outXonSent, &quot;XonSent&quot;);</a>
<a name="ln6446">	BGE_SYSCTL_STAT(sc, ctx, &quot;XOFF Sent&quot;,</a>
<a name="ln6447">	    children, txstats.outXoffSent, &quot;XoffSent&quot;);</a>
<a name="ln6448">	BGE_SYSCTL_STAT(sc, ctx, &quot;Flow Control Done&quot;,</a>
<a name="ln6449">	    children, txstats.flowControlDone, &quot;flowControlDone&quot;);</a>
<a name="ln6450">	BGE_SYSCTL_STAT(sc, ctx, &quot;Internal MAC TX errors&quot;,</a>
<a name="ln6451">	    children, txstats.dot3StatsInternalMacTransmitErrors,</a>
<a name="ln6452">	    &quot;InternalMacTransmitErrors&quot;);</a>
<a name="ln6453">	BGE_SYSCTL_STAT(sc, ctx, &quot;Single Collision Frames&quot;,</a>
<a name="ln6454">	    children, txstats.dot3StatsSingleCollisionFrames,</a>
<a name="ln6455">	    &quot;SingleCollisionFrames&quot;);</a>
<a name="ln6456">	BGE_SYSCTL_STAT(sc, ctx, &quot;Multiple Collision Frames&quot;,</a>
<a name="ln6457">	    children, txstats.dot3StatsMultipleCollisionFrames,</a>
<a name="ln6458">	    &quot;MultipleCollisionFrames&quot;);</a>
<a name="ln6459">	BGE_SYSCTL_STAT(sc, ctx, &quot;Deferred Transmissions&quot;,</a>
<a name="ln6460">	    children, txstats.dot3StatsDeferredTransmissions,</a>
<a name="ln6461">	    &quot;DeferredTransmissions&quot;);</a>
<a name="ln6462">	BGE_SYSCTL_STAT(sc, ctx, &quot;Excessive Collisions&quot;,</a>
<a name="ln6463">	    children, txstats.dot3StatsExcessiveCollisions,</a>
<a name="ln6464">	    &quot;ExcessiveCollisions&quot;);</a>
<a name="ln6465">	BGE_SYSCTL_STAT(sc, ctx, &quot;Late Collisions&quot;,</a>
<a name="ln6466">	    children, txstats.dot3StatsLateCollisions,</a>
<a name="ln6467">	    &quot;LateCollisions&quot;);</a>
<a name="ln6468">	BGE_SYSCTL_STAT(sc, ctx, &quot;Outbound Unicast Packets&quot;,</a>
<a name="ln6469">	    children, txstats.ifHCOutUcastPkts, &quot;UnicastPkts&quot;);</a>
<a name="ln6470">	BGE_SYSCTL_STAT(sc, ctx, &quot;Outbound Multicast Packets&quot;,</a>
<a name="ln6471">	    children, txstats.ifHCOutMulticastPkts, &quot;MulticastPkts&quot;);</a>
<a name="ln6472">	BGE_SYSCTL_STAT(sc, ctx, &quot;Outbound Broadcast Packets&quot;,</a>
<a name="ln6473">	    children, txstats.ifHCOutBroadcastPkts, &quot;BroadcastPkts&quot;);</a>
<a name="ln6474">	BGE_SYSCTL_STAT(sc, ctx, &quot;Carrier Sense Errors&quot;,</a>
<a name="ln6475">	    children, txstats.dot3StatsCarrierSenseErrors,</a>
<a name="ln6476">	    &quot;CarrierSenseErrors&quot;);</a>
<a name="ln6477">	BGE_SYSCTL_STAT(sc, ctx, &quot;Outbound Discards&quot;,</a>
<a name="ln6478">	    children, txstats.ifOutDiscards, &quot;Discards&quot;);</a>
<a name="ln6479">	BGE_SYSCTL_STAT(sc, ctx, &quot;Outbound Errors&quot;,</a>
<a name="ln6480">	    children, txstats.ifOutErrors, &quot;Errors&quot;);</a>
<a name="ln6481">}</a>
<a name="ln6482"> </a>
<a name="ln6483">#undef BGE_SYSCTL_STAT</a>
<a name="ln6484"> </a>
<a name="ln6485">#define	BGE_SYSCTL_STAT_ADD64(c, h, n, p, d)	\</a>
<a name="ln6486">	    SYSCTL_ADD_UQUAD(c, h, OID_AUTO, n, CTLFLAG_RD, p, d)</a>
<a name="ln6487"> </a>
<a name="ln6488">static void</a>
<a name="ln6489">bge_add_sysctl_stats_regs(struct bge_softc *sc, struct sysctl_ctx_list *ctx,</a>
<a name="ln6490">    struct sysctl_oid_list *parent)</a>
<a name="ln6491">{</a>
<a name="ln6492">	struct sysctl_oid *tree;</a>
<a name="ln6493">	struct sysctl_oid_list *child, *schild;</a>
<a name="ln6494">	struct bge_mac_stats *stats;</a>
<a name="ln6495"> </a>
<a name="ln6496">	stats = &amp;sc-&gt;bge_mac_stats;</a>
<a name="ln6497">	tree = SYSCTL_ADD_NODE(ctx, parent, OID_AUTO, &quot;stats&quot;, CTLFLAG_RD,</a>
<a name="ln6498">	    NULL, &quot;BGE Statistics&quot;);</a>
<a name="ln6499">	schild = child = SYSCTL_CHILDREN(tree);</a>
<a name="ln6500">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;FramesDroppedDueToFilters&quot;,</a>
<a name="ln6501">	    &amp;stats-&gt;FramesDroppedDueToFilters, &quot;Frames Dropped Due to Filters&quot;);</a>
<a name="ln6502">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;DmaWriteQueueFull&quot;,</a>
<a name="ln6503">	    &amp;stats-&gt;DmaWriteQueueFull, &quot;NIC DMA Write Queue Full&quot;);</a>
<a name="ln6504">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;DmaWriteHighPriQueueFull&quot;,</a>
<a name="ln6505">	    &amp;stats-&gt;DmaWriteHighPriQueueFull,</a>
<a name="ln6506">	    &quot;NIC DMA Write High Priority Queue Full&quot;);</a>
<a name="ln6507">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;NoMoreRxBDs&quot;,</a>
<a name="ln6508">	    &amp;stats-&gt;NoMoreRxBDs, &quot;NIC No More RX Buffer Descriptors&quot;);</a>
<a name="ln6509">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;InputDiscards&quot;,</a>
<a name="ln6510">	    &amp;stats-&gt;InputDiscards, &quot;Discarded Input Frames&quot;);</a>
<a name="ln6511">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;InputErrors&quot;,</a>
<a name="ln6512">	    &amp;stats-&gt;InputErrors, &quot;Input Errors&quot;);</a>
<a name="ln6513">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;RecvThresholdHit&quot;,</a>
<a name="ln6514">	    &amp;stats-&gt;RecvThresholdHit, &quot;NIC Recv Threshold Hit&quot;);</a>
<a name="ln6515"> </a>
<a name="ln6516">	tree = SYSCTL_ADD_NODE(ctx, schild, OID_AUTO, &quot;rx&quot;, CTLFLAG_RD,</a>
<a name="ln6517">	    NULL, &quot;BGE RX Statistics&quot;);</a>
<a name="ln6518">	child = SYSCTL_CHILDREN(tree);</a>
<a name="ln6519">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;ifHCInOctets&quot;,</a>
<a name="ln6520">	    &amp;stats-&gt;ifHCInOctets, &quot;Inbound Octets&quot;);</a>
<a name="ln6521">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;Fragments&quot;,</a>
<a name="ln6522">	    &amp;stats-&gt;etherStatsFragments, &quot;Fragments&quot;);</a>
<a name="ln6523">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;UnicastPkts&quot;,</a>
<a name="ln6524">	    &amp;stats-&gt;ifHCInUcastPkts, &quot;Inbound Unicast Packets&quot;);</a>
<a name="ln6525">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;MulticastPkts&quot;,</a>
<a name="ln6526">	    &amp;stats-&gt;ifHCInMulticastPkts, &quot;Inbound Multicast Packets&quot;);</a>
<a name="ln6527">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;BroadcastPkts&quot;,</a>
<a name="ln6528">	    &amp;stats-&gt;ifHCInBroadcastPkts, &quot;Inbound Broadcast Packets&quot;);</a>
<a name="ln6529">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;FCSErrors&quot;,</a>
<a name="ln6530">	    &amp;stats-&gt;dot3StatsFCSErrors, &quot;FCS Errors&quot;);</a>
<a name="ln6531">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;AlignmentErrors&quot;,</a>
<a name="ln6532">	    &amp;stats-&gt;dot3StatsAlignmentErrors, &quot;Alignment Errors&quot;);</a>
<a name="ln6533">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;xonPauseFramesReceived&quot;,</a>
<a name="ln6534">	    &amp;stats-&gt;xonPauseFramesReceived, &quot;XON Pause Frames Received&quot;);</a>
<a name="ln6535">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;xoffPauseFramesReceived&quot;,</a>
<a name="ln6536">	    &amp;stats-&gt;xoffPauseFramesReceived, &quot;XOFF Pause Frames Received&quot;);</a>
<a name="ln6537">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;ControlFramesReceived&quot;,</a>
<a name="ln6538">	    &amp;stats-&gt;macControlFramesReceived, &quot;MAC Control Frames Received&quot;);</a>
<a name="ln6539">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;xoffStateEntered&quot;,</a>
<a name="ln6540">	    &amp;stats-&gt;xoffStateEntered, &quot;XOFF State Entered&quot;);</a>
<a name="ln6541">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;FramesTooLong&quot;,</a>
<a name="ln6542">	    &amp;stats-&gt;dot3StatsFramesTooLong, &quot;Frames Too Long&quot;);</a>
<a name="ln6543">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;Jabbers&quot;,</a>
<a name="ln6544">	    &amp;stats-&gt;etherStatsJabbers, &quot;Jabbers&quot;);</a>
<a name="ln6545">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;UndersizePkts&quot;,</a>
<a name="ln6546">	    &amp;stats-&gt;etherStatsUndersizePkts, &quot;Undersized Packets&quot;);</a>
<a name="ln6547"> </a>
<a name="ln6548">	tree = SYSCTL_ADD_NODE(ctx, schild, OID_AUTO, &quot;tx&quot;, CTLFLAG_RD,</a>
<a name="ln6549">	    NULL, &quot;BGE TX Statistics&quot;);</a>
<a name="ln6550">	child = SYSCTL_CHILDREN(tree);</a>
<a name="ln6551">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;ifHCOutOctets&quot;,</a>
<a name="ln6552">	    &amp;stats-&gt;ifHCOutOctets, &quot;Outbound Octets&quot;);</a>
<a name="ln6553">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;Collisions&quot;,</a>
<a name="ln6554">	    &amp;stats-&gt;etherStatsCollisions, &quot;TX Collisions&quot;);</a>
<a name="ln6555">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;XonSent&quot;,</a>
<a name="ln6556">	    &amp;stats-&gt;outXonSent, &quot;XON Sent&quot;);</a>
<a name="ln6557">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;XoffSent&quot;,</a>
<a name="ln6558">	    &amp;stats-&gt;outXoffSent, &quot;XOFF Sent&quot;);</a>
<a name="ln6559">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;InternalMacTransmitErrors&quot;,</a>
<a name="ln6560">	    &amp;stats-&gt;dot3StatsInternalMacTransmitErrors,</a>
<a name="ln6561">	    &quot;Internal MAC TX Errors&quot;);</a>
<a name="ln6562">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;SingleCollisionFrames&quot;,</a>
<a name="ln6563">	    &amp;stats-&gt;dot3StatsSingleCollisionFrames, &quot;Single Collision Frames&quot;);</a>
<a name="ln6564">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;MultipleCollisionFrames&quot;,</a>
<a name="ln6565">	    &amp;stats-&gt;dot3StatsMultipleCollisionFrames,</a>
<a name="ln6566">	    &quot;Multiple Collision Frames&quot;);</a>
<a name="ln6567">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;DeferredTransmissions&quot;,</a>
<a name="ln6568">	    &amp;stats-&gt;dot3StatsDeferredTransmissions, &quot;Deferred Transmissions&quot;);</a>
<a name="ln6569">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;ExcessiveCollisions&quot;,</a>
<a name="ln6570">	    &amp;stats-&gt;dot3StatsExcessiveCollisions, &quot;Excessive Collisions&quot;);</a>
<a name="ln6571">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;LateCollisions&quot;,</a>
<a name="ln6572">	    &amp;stats-&gt;dot3StatsLateCollisions, &quot;Late Collisions&quot;);</a>
<a name="ln6573">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;UnicastPkts&quot;,</a>
<a name="ln6574">	    &amp;stats-&gt;ifHCOutUcastPkts, &quot;Outbound Unicast Packets&quot;);</a>
<a name="ln6575">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;MulticastPkts&quot;,</a>
<a name="ln6576">	    &amp;stats-&gt;ifHCOutMulticastPkts, &quot;Outbound Multicast Packets&quot;);</a>
<a name="ln6577">	BGE_SYSCTL_STAT_ADD64(ctx, child, &quot;BroadcastPkts&quot;,</a>
<a name="ln6578">	    &amp;stats-&gt;ifHCOutBroadcastPkts, &quot;Outbound Broadcast Packets&quot;);</a>
<a name="ln6579">}</a>
<a name="ln6580"> </a>
<a name="ln6581">#undef	BGE_SYSCTL_STAT_ADD64</a>
<a name="ln6582"> </a>
<a name="ln6583">static int</a>
<a name="ln6584">bge_sysctl_stats(SYSCTL_HANDLER_ARGS)</a>
<a name="ln6585">{</a>
<a name="ln6586">	struct bge_softc *sc;</a>
<a name="ln6587">	uint32_t result;</a>
<a name="ln6588">	int offset;</a>
<a name="ln6589"> </a>
<a name="ln6590">	sc = (struct bge_softc *)arg1;</a>
<a name="ln6591">	offset = arg2;</a>
<a name="ln6592">	result = CSR_READ_4(sc, BGE_MEMWIN_START + BGE_STATS_BLOCK + offset +</a>
<a name="ln6593">	    offsetof(bge_hostaddr, bge_addr_lo));</a>
<a name="ln6594">	return (sysctl_handle_int(oidp, &amp;result, 0, req));</a>
<a name="ln6595">}</a>
<a name="ln6596"> </a>
<a name="ln6597">#ifdef BGE_REGISTER_DEBUG</a>
<a name="ln6598">static int</a>
<a name="ln6599">bge_sysctl_debug_info(SYSCTL_HANDLER_ARGS)</a>
<a name="ln6600">{</a>
<a name="ln6601">	struct bge_softc *sc;</a>
<a name="ln6602">	uint16_t *sbdata;</a>
<a name="ln6603">	int error, result, sbsz;</a>
<a name="ln6604">	int i, j;</a>
<a name="ln6605"> </a>
<a name="ln6606">	result = -1;</a>
<a name="ln6607">	error = sysctl_handle_int(oidp, &amp;result, 0, req);</a>
<a name="ln6608">	if (error || (req-&gt;newptr == NULL))</a>
<a name="ln6609">		return (error);</a>
<a name="ln6610"> </a>
<a name="ln6611">	if (result == 1) {</a>
<a name="ln6612">		sc = (struct bge_softc *)arg1;</a>
<a name="ln6613"> </a>
<a name="ln6614">		if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5700 &amp;&amp;</a>
<a name="ln6615">		    sc-&gt;bge_chipid != BGE_CHIPID_BCM5700_C0)</a>
<a name="ln6616">			sbsz = BGE_STATUS_BLK_SZ;</a>
<a name="ln6617">		else</a>
<a name="ln6618">			sbsz = 32;</a>
<a name="ln6619">		sbdata = (uint16_t *)sc-&gt;bge_ldata.bge_status_block;</a>
<a name="ln6620">		printf(&quot;Status Block:\n&quot;);</a>
<a name="ln6621">		BGE_LOCK(sc);</a>
<a name="ln6622">		bus_dmamap_sync(sc-&gt;bge_cdata.bge_status_tag,</a>
<a name="ln6623">		    sc-&gt;bge_cdata.bge_status_map,</a>
<a name="ln6624">		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);</a>
<a name="ln6625">		for (i = 0x0; i &lt; sbsz / sizeof(uint16_t); ) {</a>
<a name="ln6626">			printf(&quot;%06x:&quot;, i);</a>
<a name="ln6627">			for (j = 0; j &lt; 8; j++)</a>
<a name="ln6628">				printf(&quot; %04x&quot;, sbdata[i++]);</a>
<a name="ln6629">			printf(&quot;\n&quot;);</a>
<a name="ln6630">		}</a>
<a name="ln6631"> </a>
<a name="ln6632">		printf(&quot;Registers:\n&quot;);</a>
<a name="ln6633">		for (i = 0x800; i &lt; 0xA00; ) {</a>
<a name="ln6634">			printf(&quot;%06x:&quot;, i);</a>
<a name="ln6635">			for (j = 0; j &lt; 8; j++) {</a>
<a name="ln6636">				printf(&quot; %08x&quot;, CSR_READ_4(sc, i));</a>
<a name="ln6637">				i += 4;</a>
<a name="ln6638">			}</a>
<a name="ln6639">			printf(&quot;\n&quot;);</a>
<a name="ln6640">		}</a>
<a name="ln6641">		BGE_UNLOCK(sc);</a>
<a name="ln6642"> </a>
<a name="ln6643">		printf(&quot;Hardware Flags:\n&quot;);</a>
<a name="ln6644">		if (BGE_IS_5717_PLUS(sc))</a>
<a name="ln6645">			printf(&quot; - 5717 Plus\n&quot;);</a>
<a name="ln6646">		if (BGE_IS_5755_PLUS(sc))</a>
<a name="ln6647">			printf(&quot; - 5755 Plus\n&quot;);</a>
<a name="ln6648">		if (BGE_IS_575X_PLUS(sc))</a>
<a name="ln6649">			printf(&quot; - 575X Plus\n&quot;);</a>
<a name="ln6650">		if (BGE_IS_5705_PLUS(sc))</a>
<a name="ln6651">			printf(&quot; - 5705 Plus\n&quot;);</a>
<a name="ln6652">		if (BGE_IS_5714_FAMILY(sc))</a>
<a name="ln6653">			printf(&quot; - 5714 Family\n&quot;);</a>
<a name="ln6654">		if (BGE_IS_5700_FAMILY(sc))</a>
<a name="ln6655">			printf(&quot; - 5700 Family\n&quot;);</a>
<a name="ln6656">		if (sc-&gt;bge_flags &amp; BGE_FLAG_JUMBO)</a>
<a name="ln6657">			printf(&quot; - Supports Jumbo Frames\n&quot;);</a>
<a name="ln6658">		if (sc-&gt;bge_flags &amp; BGE_FLAG_PCIX)</a>
<a name="ln6659">			printf(&quot; - PCI-X Bus\n&quot;);</a>
<a name="ln6660">		if (sc-&gt;bge_flags &amp; BGE_FLAG_PCIE)</a>
<a name="ln6661">			printf(&quot; - PCI Express Bus\n&quot;);</a>
<a name="ln6662">		if (sc-&gt;bge_phy_flags &amp; BGE_PHY_NO_3LED)</a>
<a name="ln6663">			printf(&quot; - No 3 LEDs\n&quot;);</a>
<a name="ln6664">		if (sc-&gt;bge_flags &amp; BGE_FLAG_RX_ALIGNBUG)</a>
<a name="ln6665">			printf(&quot; - RX Alignment Bug\n&quot;);</a>
<a name="ln6666">	}</a>
<a name="ln6667"> </a>
<a name="ln6668">	return (error);</a>
<a name="ln6669">}</a>
<a name="ln6670"> </a>
<a name="ln6671">static int</a>
<a name="ln6672">bge_sysctl_reg_read(SYSCTL_HANDLER_ARGS)</a>
<a name="ln6673">{</a>
<a name="ln6674">	struct bge_softc *sc;</a>
<a name="ln6675">	int error;</a>
<a name="ln6676">	uint16_t result;</a>
<a name="ln6677">	uint32_t val;</a>
<a name="ln6678"> </a>
<a name="ln6679">	result = -1;</a>
<a name="ln6680">	error = sysctl_handle_int(oidp, &amp;result, 0, req);</a>
<a name="ln6681">	if (error || (req-&gt;newptr == NULL))</a>
<a name="ln6682">		return (error);</a>
<a name="ln6683"> </a>
<a name="ln6684">	if (result &lt; 0x8000) {</a>
<a name="ln6685">		sc = (struct bge_softc *)arg1;</a>
<a name="ln6686">		val = CSR_READ_4(sc, result);</a>
<a name="ln6687">		printf(&quot;reg 0x%06X = 0x%08X\n&quot;, result, val);</a>
<a name="ln6688">	}</a>
<a name="ln6689"> </a>
<a name="ln6690">	return (error);</a>
<a name="ln6691">}</a>
<a name="ln6692"> </a>
<a name="ln6693">static int</a>
<a name="ln6694">bge_sysctl_ape_read(SYSCTL_HANDLER_ARGS)</a>
<a name="ln6695">{</a>
<a name="ln6696">	struct bge_softc *sc;</a>
<a name="ln6697">	int error;</a>
<a name="ln6698">	uint16_t result;</a>
<a name="ln6699">	uint32_t val;</a>
<a name="ln6700"> </a>
<a name="ln6701">	result = -1;</a>
<a name="ln6702">	error = sysctl_handle_int(oidp, &amp;result, 0, req);</a>
<a name="ln6703">	if (error || (req-&gt;newptr == NULL))</a>
<a name="ln6704">		return (error);</a>
<a name="ln6705"> </a>
<a name="ln6706">	if (result &lt; 0x8000) {</a>
<a name="ln6707">		sc = (struct bge_softc *)arg1;</a>
<a name="ln6708">		val = APE_READ_4(sc, result);</a>
<a name="ln6709">		printf(&quot;reg 0x%06X = 0x%08X\n&quot;, result, val);</a>
<a name="ln6710">	}</a>
<a name="ln6711"> </a>
<a name="ln6712">	return (error);</a>
<a name="ln6713">}</a>
<a name="ln6714"> </a>
<a name="ln6715">static int</a>
<a name="ln6716">bge_sysctl_mem_read(SYSCTL_HANDLER_ARGS)</a>
<a name="ln6717">{</a>
<a name="ln6718">	struct bge_softc *sc;</a>
<a name="ln6719">	int error;</a>
<a name="ln6720">	uint16_t result;</a>
<a name="ln6721">	uint32_t val;</a>
<a name="ln6722"> </a>
<a name="ln6723">	result = -1;</a>
<a name="ln6724">	error = sysctl_handle_int(oidp, &amp;result, 0, req);</a>
<a name="ln6725">	if (error || (req-&gt;newptr == NULL))</a>
<a name="ln6726">		return (error);</a>
<a name="ln6727"> </a>
<a name="ln6728">	if (result &lt; 0x8000) {</a>
<a name="ln6729">		sc = (struct bge_softc *)arg1;</a>
<a name="ln6730">		val = bge_readmem_ind(sc, result);</a>
<a name="ln6731">		printf(&quot;mem 0x%06X = 0x%08X\n&quot;, result, val);</a>
<a name="ln6732">	}</a>
<a name="ln6733"> </a>
<a name="ln6734">	return (error);</a>
<a name="ln6735">}</a>
<a name="ln6736">#endif</a>
<a name="ln6737"> </a>
<a name="ln6738">static int</a>
<a name="ln6739">bge_get_eaddr_fw(struct bge_softc *sc, uint8_t ether_addr[])</a>
<a name="ln6740">{</a>
<a name="ln6741">#ifdef __sparc64__</a>
<a name="ln6742">	if (sc-&gt;bge_flags &amp; BGE_FLAG_EADDR)</a>
<a name="ln6743">		return (1);</a>
<a name="ln6744"> </a>
<a name="ln6745">	OF_getetheraddr(sc-&gt;bge_dev, ether_addr);</a>
<a name="ln6746">	return (0);</a>
<a name="ln6747">#else</a>
<a name="ln6748">	return (1);</a>
<a name="ln6749">#endif</a>
<a name="ln6750">}</a>
<a name="ln6751"> </a>
<a name="ln6752">static int</a>
<a name="ln6753">bge_get_eaddr_mem(struct bge_softc *sc, uint8_t ether_addr[])</a>
<a name="ln6754">{</a>
<a name="ln6755">	uint32_t mac_addr;</a>
<a name="ln6756"> </a>
<a name="ln6757">	mac_addr = bge_readmem_ind(sc, BGE_SRAM_MAC_ADDR_HIGH_MB);</a>
<a name="ln6758">	if ((mac_addr &gt;&gt; 16) == 0x484b) {</a>
<a name="ln6759">		ether_addr[0] = (uint8_t)(mac_addr &gt;&gt; 8);</a>
<a name="ln6760">		ether_addr[1] = (uint8_t)mac_addr;</a>
<a name="ln6761">		mac_addr = bge_readmem_ind(sc, BGE_SRAM_MAC_ADDR_LOW_MB);</a>
<a name="ln6762">		ether_addr[2] = (uint8_t)(mac_addr &gt;&gt; 24);</a>
<a name="ln6763">		ether_addr[3] = (uint8_t)(mac_addr &gt;&gt; 16);</a>
<a name="ln6764">		ether_addr[4] = (uint8_t)(mac_addr &gt;&gt; 8);</a>
<a name="ln6765">		ether_addr[5] = (uint8_t)mac_addr;</a>
<a name="ln6766">		return (0);</a>
<a name="ln6767">	}</a>
<a name="ln6768">	return (1);</a>
<a name="ln6769">}</a>
<a name="ln6770"> </a>
<a name="ln6771">static int</a>
<a name="ln6772">bge_get_eaddr_nvram(struct bge_softc *sc, uint8_t ether_addr[])</a>
<a name="ln6773">{</a>
<a name="ln6774">	int mac_offset = BGE_EE_MAC_OFFSET;</a>
<a name="ln6775"> </a>
<a name="ln6776">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5906)</a>
<a name="ln6777">		mac_offset = BGE_EE_MAC_OFFSET_5906;</a>
<a name="ln6778"> </a>
<a name="ln6779">	return (bge_read_nvram(sc, ether_addr, mac_offset + 2,</a>
<a name="ln6780">	    ETHER_ADDR_LEN));</a>
<a name="ln6781">}</a>
<a name="ln6782"> </a>
<a name="ln6783">static int</a>
<a name="ln6784">bge_get_eaddr_eeprom(struct bge_softc *sc, uint8_t ether_addr[])</a>
<a name="ln6785">{</a>
<a name="ln6786"> </a>
<a name="ln6787">	if (sc-&gt;bge_asicrev == BGE_ASICREV_BCM5906)</a>
<a name="ln6788">		return (1);</a>
<a name="ln6789"> </a>
<a name="ln6790">	return (bge_read_eeprom(sc, ether_addr, BGE_EE_MAC_OFFSET + 2,</a>
<a name="ln6791">	   ETHER_ADDR_LEN));</a>
<a name="ln6792">}</a>
<a name="ln6793"> </a>
<a name="ln6794">static int</a>
<a name="ln6795">bge_get_eaddr(struct bge_softc *sc, uint8_t eaddr[])</a>
<a name="ln6796">{</a>
<a name="ln6797">	static const bge_eaddr_fcn_t bge_eaddr_funcs[] = {</a>
<a name="ln6798">		/* NOTE: Order is critical */</a>
<a name="ln6799">		bge_get_eaddr_fw,</a>
<a name="ln6800">		bge_get_eaddr_mem,</a>
<a name="ln6801">		bge_get_eaddr_nvram,</a>
<a name="ln6802">		bge_get_eaddr_eeprom,</a>
<a name="ln6803">		NULL</a>
<a name="ln6804">	};</a>
<a name="ln6805">	const bge_eaddr_fcn_t *func;</a>
<a name="ln6806"> </a>
<a name="ln6807">	for (func = bge_eaddr_funcs; *func != NULL; ++func) {</a>
<a name="ln6808">		if ((*func)(sc, eaddr) == 0)</a>
<a name="ln6809">			break;</a>
<a name="ln6810">	}</a>
<a name="ln6811">	return (*func == NULL ? ENXIO : 0);</a>
<a name="ln6812">}</a>
<a name="ln6813"> </a>
<a name="ln6814">static uint64_t</a>
<a name="ln6815">bge_get_counter(if_t ifp, ift_counter cnt)</a>
<a name="ln6816">{</a>
<a name="ln6817">	struct bge_softc *sc;</a>
<a name="ln6818">	struct bge_mac_stats *stats;</a>
<a name="ln6819"> </a>
<a name="ln6820">	sc = if_getsoftc(ifp);</a>
<a name="ln6821">	if (!BGE_IS_5705_PLUS(sc))</a>
<a name="ln6822">		return (if_get_counter_default(ifp, cnt));</a>
<a name="ln6823">	stats = &amp;sc-&gt;bge_mac_stats;</a>
<a name="ln6824"> </a>
<a name="ln6825">	switch (cnt) {</a>
<a name="ln6826">	case IFCOUNTER_IERRORS:</a>
<a name="ln6827">		return (stats-&gt;NoMoreRxBDs + stats-&gt;InputDiscards +</a>
<a name="ln6828">		    stats-&gt;InputErrors);</a>
<a name="ln6829">	case IFCOUNTER_COLLISIONS:</a>
<a name="ln6830">		return (stats-&gt;etherStatsCollisions);</a>
<a name="ln6831">	default:</a>
<a name="ln6832">		return (if_get_counter_default(ifp, cnt));</a>
<a name="ln6833">	}</a>
<a name="ln6834">}</a>
<a name="ln6835"> </a>
<a name="ln6836">#ifdef NETDUMP</a>
<a name="ln6837">static void</a>
<a name="ln6838">bge_netdump_init(if_t ifp, int *nrxr, int *ncl, int *clsize)</a>
<a name="ln6839">{</a>
<a name="ln6840">	struct bge_softc *sc;</a>
<a name="ln6841"> </a>
<a name="ln6842">	sc = if_getsoftc(ifp);</a>
<a name="ln6843">	BGE_LOCK(sc);</a>
<a name="ln6844">	*nrxr = sc-&gt;bge_return_ring_cnt;</a>
<a name="ln6845">	*ncl = NETDUMP_MAX_IN_FLIGHT;</a>
<a name="ln6846">	if ((sc-&gt;bge_flags &amp; BGE_FLAG_JUMBO_STD) != 0 &amp;&amp;</a>
<a name="ln6847">	    (if_getmtu(sc-&gt;bge_ifp) + ETHER_HDR_LEN + ETHER_CRC_LEN +</a>
<a name="ln6848">	    ETHER_VLAN_ENCAP_LEN &gt; (MCLBYTES - ETHER_ALIGN)))</a>
<a name="ln6849">		*clsize = MJUM9BYTES;</a>
<a name="ln6850">	else</a>
<a name="ln6851">		*clsize = MCLBYTES;</a>
<a name="ln6852">	BGE_UNLOCK(sc);</a>
<a name="ln6853">}</a>
<a name="ln6854"> </a>
<a name="ln6855">static void</a>
<a name="ln6856">bge_netdump_event(if_t ifp __unused, enum netdump_ev event __unused)</a>
<a name="ln6857">{</a>
<a name="ln6858">}</a>
<a name="ln6859"> </a>
<a name="ln6860">static int</a>
<a name="ln6861">bge_netdump_transmit(if_t ifp, struct mbuf *m)</a>
<a name="ln6862">{</a>
<a name="ln6863">	struct bge_softc *sc;</a>
<a name="ln6864">	uint32_t prodidx;</a>
<a name="ln6865">	int error;</a>
<a name="ln6866"> </a>
<a name="ln6867">	sc = if_getsoftc(ifp);</a>
<a name="ln6868">	if ((if_getdrvflags(ifp) &amp; (IFF_DRV_RUNNING | IFF_DRV_OACTIVE)) !=</a>
<a name="ln6869">	    IFF_DRV_RUNNING)</a>
<a name="ln6870">		return (1);</a>
<a name="ln6871"> </a>
<a name="ln6872">	prodidx = sc-&gt;bge_tx_prodidx;</a>
<a name="ln6873">	error = bge_encap(sc, &amp;m, &amp;prodidx);</a>
<a name="ln6874">	if (error == 0)</a>
<a name="ln6875">		bge_start_tx(sc, prodidx);</a>
<a name="ln6876">	return (error);</a>
<a name="ln6877">}</a>
<a name="ln6878"> </a>
<a name="ln6879">static int</a>
<a name="ln6880">bge_netdump_poll(if_t ifp, int count)</a>
<a name="ln6881">{</a>
<a name="ln6882">	struct bge_softc *sc;</a>
<a name="ln6883">	uint32_t rx_prod, tx_cons;</a>
<a name="ln6884"> </a>
<a name="ln6885">	sc = if_getsoftc(ifp);</a>
<a name="ln6886">	if ((if_getdrvflags(ifp) &amp; (IFF_DRV_RUNNING | IFF_DRV_OACTIVE)) !=</a>
<a name="ln6887">	    IFF_DRV_RUNNING)</a>
<a name="ln6888">		return (1);</a>
<a name="ln6889"> </a>
<a name="ln6890">	bus_dmamap_sync(sc-&gt;bge_cdata.bge_status_tag,</a>
<a name="ln6891">	    sc-&gt;bge_cdata.bge_status_map,</a>
<a name="ln6892">	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);</a>
<a name="ln6893"> </a>
<a name="ln6894">	rx_prod = sc-&gt;bge_ldata.bge_status_block-&gt;bge_idx[0].bge_rx_prod_idx;</a>
<a name="ln6895">	tx_cons = sc-&gt;bge_ldata.bge_status_block-&gt;bge_idx[0].bge_tx_cons_idx;</a>
<a name="ln6896"> </a>
<a name="ln6897">	bus_dmamap_sync(sc-&gt;bge_cdata.bge_status_tag,</a>
<a name="ln6898">	    sc-&gt;bge_cdata.bge_status_map,</a>
<a name="ln6899">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln6900"> </a>
<a name="ln6901">	(void)bge_rxeof(sc, rx_prod, 0);</a>
<a name="ln6902">	bge_txeof(sc, tx_cons);</a>
<a name="ln6903">	return (0);</a>
<a name="ln6904">}</a>
<a name="ln6905">#endif /* NETDUMP */</a>

</code></pre>
<div class="balloon" rel="2419"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memset' function will lead to underflow of the buffer 'sc->bge_ldata.bge_status_block'.</p></div>
<div class="balloon" rel="3686"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'rid != 0' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
