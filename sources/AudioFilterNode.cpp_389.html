
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>AudioFilterNode.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright (c) 1999-2000, Eric Moon.</a>
<a name="ln3"> * All rights reserved.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln6"> * modification, are permitted provided that the following conditions</a>
<a name="ln7"> * are met:</a>
<a name="ln8"> *</a>
<a name="ln9"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln10"> *    notice, this list of conditions, and the following disclaimer.</a>
<a name="ln11"> *</a>
<a name="ln12"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln13"> *    notice, this list of conditions, and the following disclaimer in the</a>
<a name="ln14"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln15"> *</a>
<a name="ln16"> * 3. The name of the author may not be used to endorse or promote products</a>
<a name="ln17"> *    derived from this software without specific prior written permission.</a>
<a name="ln18"> *</a>
<a name="ln19"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR &quot;AS IS&quot; AND ANY EXPRESS OR</a>
<a name="ln20"> * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</a>
<a name="ln21"> * OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR</a>
<a name="ln22"> * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY</a>
<a name="ln23"> * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</a>
<a name="ln24"> * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</a>
<a name="ln25"> * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED</a>
<a name="ln26"> * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR</a>
<a name="ln27"> * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</a>
<a name="ln28"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln29"> */</a>
<a name="ln30"> </a>
<a name="ln31"> </a>
<a name="ln32">// AudioFilterNode.cpp</a>
<a name="ln33"> </a>
<a name="ln34">#include &quot;AudioFilterNode.h&quot;</a>
<a name="ln35"> </a>
<a name="ln36">#include &quot;AudioBuffer.h&quot;</a>
<a name="ln37">#include &quot;IParameterSet.h&quot;</a>
<a name="ln38">#include &quot;IAudioOpFactory.h&quot;</a>
<a name="ln39">#include &quot;IAudioOp.h&quot;</a>
<a name="ln40">#include &quot;SoundUtils.h&quot;</a>
<a name="ln41"> </a>
<a name="ln42">#include &lt;Buffer.h&gt;</a>
<a name="ln43">#include &lt;BufferGroup.h&gt;</a>
<a name="ln44">#include &lt;ByteOrder.h&gt;</a>
<a name="ln45">#include &lt;ParameterWeb.h&gt;</a>
<a name="ln46">#include &lt;String.h&gt;</a>
<a name="ln47">#include &lt;TimeSource.h&gt;</a>
<a name="ln48"> </a>
<a name="ln49"> </a>
<a name="ln50">#include &lt;cstdio&gt;</a>
<a name="ln51">#include &lt;cstdlib&gt;</a>
<a name="ln52">#include &lt;cstring&gt;</a>
<a name="ln53">//#include &lt;cmath&gt;</a>
<a name="ln54"> </a>
<a name="ln55">// -------------------------------------------------------- //</a>
<a name="ln56">// constants </a>
<a name="ln57">// -------------------------------------------------------- //</a>
<a name="ln58"> </a>
<a name="ln59">// input-ID symbols</a>
<a name="ln60">enum input_id_t {</a>
<a name="ln61">	ID_AUDIO_INPUT</a>
<a name="ln62">};</a>
<a name="ln63">	</a>
<a name="ln64">// output-ID symbols</a>
<a name="ln65">enum output_id_t {</a>
<a name="ln66">	ID_AUDIO_MIX_OUTPUT</a>
<a name="ln67">	//ID_AUDIO_WET_OUTPUT ...</a>
<a name="ln68">};</a>
<a name="ln69">	</a>
<a name="ln70">// -------------------------------------------------------- //</a>
<a name="ln71">// *** HOOKS</a>
<a name="ln72">// -------------------------------------------------------- //</a>
<a name="ln73"> </a>
<a name="ln74">// *** FORMAT NEGOTIATION</a>
<a name="ln75"> </a>
<a name="ln76">// requests the required format for the given type (ioFormat.type must be</a>
<a name="ln77">// filled in!)</a>
<a name="ln78">// upon returning, all fields must be filled in.</a>
<a name="ln79">// Default:</a>
<a name="ln80">// - raw_audio format:</a>
<a name="ln81">//   float</a>
<a name="ln82">//   44100hz</a>
<a name="ln83">//   host-endian</a>
<a name="ln84">//   1 channel</a>
<a name="ln85">//   1k buffers</a>
<a name="ln86"> </a>
<a name="ln87">status_t AudioFilterNode::getPreferredInputFormat(</a>
<a name="ln88">	media_format&amp;								ioFormat) {</a>
<a name="ln89">	return getPreferredOutputFormat(ioFormat);</a>
<a name="ln90">}</a>
<a name="ln91"> </a>
<a name="ln92">status_t AudioFilterNode::getPreferredOutputFormat(</a>
<a name="ln93">	media_format&amp;								ioFormat) {</a>
<a name="ln94"> </a>
<a name="ln95">	if(ioFormat.type != B_MEDIA_RAW_AUDIO)</a>
<a name="ln96">		return B_MEDIA_BAD_FORMAT;</a>
<a name="ln97">	</a>
<a name="ln98">	media_raw_audio_format&amp; f = ioFormat.u.raw_audio;</a>
<a name="ln99">	f.format = media_raw_audio_format::B_AUDIO_FLOAT;</a>
<a name="ln100">	f.frame_rate = 44100.0;</a>
<a name="ln101">	f.channel_count = 1;</a>
<a name="ln102">	f.byte_order = B_MEDIA_HOST_ENDIAN; //(B_HOST_IS_BENDIAN) ? B_MEDIA_BIG_ENDIAN : B_MEDIA_LITTLE_ENDIAN;</a>
<a name="ln103">	f.buffer_size = 1024;</a>
<a name="ln104"> </a>
<a name="ln105">	return B_OK;	</a>
<a name="ln106">}</a>
<a name="ln107"> </a>
<a name="ln108">// test the given template format against a proposed format.</a>
<a name="ln109">// specialize wildcards for fields where the template contains</a>
<a name="ln110">// non-wildcard data; write required fields into proposed format</a>
<a name="ln111">// if they mismatch.</a>
<a name="ln112">// Returns B_OK if the proposed format doesn't conflict with the</a>
<a name="ln113">// template, or B_MEDIA_BAD_FORMAT otherwise.</a>
<a name="ln114"> </a>
<a name="ln115">status_t AudioFilterNode::_validate_raw_audio_format(</a>
<a name="ln116">	const media_format&amp;					preferredFormat,</a>
<a name="ln117">	media_format&amp;								ioProposedFormat) {</a>
<a name="ln118"> </a>
<a name="ln119">	char formatStr[256];</a>
<a name="ln120">	PRINT((&quot;AudioFilterNode::_validate_raw_audio_format()\n&quot;));</a>
<a name="ln121"> </a>
<a name="ln122">	ASSERT(preferredFormat.type == B_MEDIA_RAW_AUDIO);</a>
<a name="ln123">	</a>
<a name="ln124">	string_for_format(preferredFormat, formatStr, 255);</a>
<a name="ln125">	PRINT((&quot;\ttemplate format: %s\n&quot;, formatStr));</a>
<a name="ln126"> </a>
<a name="ln127">	string_for_format(ioProposedFormat, formatStr, 255);</a>
<a name="ln128">	PRINT((&quot;\tincoming proposed format: %s\n&quot;, formatStr));</a>
<a name="ln129">	</a>
<a name="ln130">	status_t err = B_OK;</a>
<a name="ln131">	</a>
<a name="ln132">	if(ioProposedFormat.type != B_MEDIA_RAW_AUDIO) {</a>
<a name="ln133">		// out of the ballpark</a>
<a name="ln134">		ioProposedFormat = preferredFormat;</a>
<a name="ln135">		return B_MEDIA_BAD_FORMAT;</a>
<a name="ln136">	}</a>
<a name="ln137"> </a>
<a name="ln138">	// wildcard format</a>
<a name="ln139">	media_raw_audio_format&amp; wild = media_raw_audio_format::wildcard;</a>
<a name="ln140">	// proposed format</a>
<a name="ln141">	media_raw_audio_format&amp; f = ioProposedFormat.u.raw_audio;</a>
<a name="ln142">	// template format</a>
<a name="ln143">	const media_raw_audio_format&amp; pref = preferredFormat.u.raw_audio;</a>
<a name="ln144">		</a>
<a name="ln145">	if(pref.frame_rate != wild.frame_rate) {</a>
<a name="ln146">		if(f.frame_rate != pref.frame_rate) {</a>
<a name="ln147">			if(f.frame_rate != wild.frame_rate)</a>
<a name="ln148">				err = B_MEDIA_BAD_FORMAT;</a>
<a name="ln149">			f.frame_rate = pref.frame_rate;</a>
<a name="ln150">		}</a>
<a name="ln151">	}</a>
<a name="ln152"> </a>
<a name="ln153">	if(pref.channel_count != wild.channel_count) {</a>
<a name="ln154">		if(f.channel_count != pref.channel_count) {</a>
<a name="ln155">			if(f.channel_count != wild.channel_count)</a>
<a name="ln156">				err = B_MEDIA_BAD_FORMAT;</a>
<a name="ln157">			f.channel_count = pref.channel_count;</a>
<a name="ln158">		}</a>
<a name="ln159">	}</a>
<a name="ln160">		</a>
<a name="ln161">	if(pref.format != wild.format) {</a>
<a name="ln162">		if(f.format != pref.format) {</a>
<a name="ln163">			if(f.format != wild.format)</a>
<a name="ln164">				err = B_MEDIA_BAD_FORMAT;</a>
<a name="ln165">			f.format = pref.format;</a>
<a name="ln166">		}</a>
<a name="ln167">	}</a>
<a name="ln168">		</a>
<a name="ln169">	if(pref.byte_order != wild.byte_order) {</a>
<a name="ln170">		if(f.byte_order != pref.byte_order) {</a>
<a name="ln171">			if(f.byte_order != wild.byte_order)</a>
<a name="ln172">				err = B_MEDIA_BAD_FORMAT;</a>
<a name="ln173">			f.byte_order = pref.byte_order;</a>
<a name="ln174">		}</a>
<a name="ln175">	}</a>
<a name="ln176">		</a>
<a name="ln177">	if(pref.buffer_size != wild.buffer_size) {</a>
<a name="ln178">		if(f.buffer_size != pref.buffer_size) {</a>
<a name="ln179">			if(f.buffer_size != wild.buffer_size)</a>
<a name="ln180">				err = B_MEDIA_BAD_FORMAT;</a>
<a name="ln181">			f.buffer_size = pref.buffer_size;</a>
<a name="ln182">		}</a>
<a name="ln183">	}</a>
<a name="ln184">	</a>
<a name="ln185">	if(err != B_OK) {</a>
<a name="ln186">		string_for_format(ioProposedFormat, formatStr, 255);</a>
<a name="ln187">		PRINT((</a>
<a name="ln188">			&quot;\tformat conflict; suggesting:\n\tformat %s\n&quot;, formatStr));</a>
<a name="ln189">	}</a>
<a name="ln190">	else {</a>
<a name="ln191">		string_for_format(ioProposedFormat, formatStr, 255);</a>
<a name="ln192">		PRINT((&quot;\toutbound proposed format: %s\n&quot;, formatStr));</a>
<a name="ln193">	}</a>
<a name="ln194">	</a>
<a name="ln195">	return err;	</a>
<a name="ln196">}</a>
<a name="ln197"> </a>
<a name="ln198">status_t AudioFilterNode::validateProposedInputFormat(</a>
<a name="ln199">	const media_format&amp;					preferredFormat,</a>
<a name="ln200">	media_format&amp;								ioProposedFormat) {</a>
<a name="ln201">	</a>
<a name="ln202">	return _validate_raw_audio_format(</a>
<a name="ln203">		preferredFormat, ioProposedFormat);</a>
<a name="ln204">}</a>
<a name="ln205">	</a>
<a name="ln206">status_t AudioFilterNode::validateProposedOutputFormat(</a>
<a name="ln207">	const media_format&amp;					preferredFormat,</a>
<a name="ln208">	media_format&amp;								ioProposedFormat) {</a>
<a name="ln209">	</a>
<a name="ln210">	return _validate_raw_audio_format(</a>
<a name="ln211">		preferredFormat, ioProposedFormat);</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214"> </a>
<a name="ln215">void AudioFilterNode::_specialize_raw_audio_format(</a>
<a name="ln216">	const media_format&amp;					templateFormat,</a>
<a name="ln217">	media_format&amp;								ioFormat) {</a>
<a name="ln218">	</a>
<a name="ln219">	ASSERT(templateFormat.type == B_MEDIA_RAW_AUDIO);</a>
<a name="ln220">	ASSERT(ioFormat.type == B_MEDIA_RAW_AUDIO);</a>
<a name="ln221">	</a>
<a name="ln222">	media_raw_audio_format&amp; f = ioFormat.u.raw_audio;</a>
<a name="ln223">	const media_raw_audio_format&amp; p = templateFormat.u.raw_audio;</a>
<a name="ln224">	const media_raw_audio_format&amp; w = media_raw_audio_format::wildcard;</a>
<a name="ln225"> </a>
<a name="ln226">	if(f.format == w.format) {</a>
<a name="ln227">		ASSERT(p.format);</a>
<a name="ln228">		f.format = p.format;</a>
<a name="ln229">	}</a>
<a name="ln230"> </a>
<a name="ln231">	if(f.channel_count == w.channel_count) {</a>
<a name="ln232">		ASSERT(p.channel_count);</a>
<a name="ln233">		f.channel_count = p.channel_count;</a>
<a name="ln234">	}</a>
<a name="ln235"> </a>
<a name="ln236">	if(f.frame_rate == w.frame_rate) {</a>
<a name="ln237">		ASSERT(p.frame_rate);</a>
<a name="ln238">		f.frame_rate = p.frame_rate;</a>
<a name="ln239">	}</a>
<a name="ln240"> </a>
<a name="ln241">	if(f.byte_order == w.byte_order) {</a>
<a name="ln242">		ASSERT(p.byte_order);</a>
<a name="ln243">		f.byte_order = p.byte_order;</a>
<a name="ln244">	}</a>
<a name="ln245"> </a>
<a name="ln246">	if(f.buffer_size == w.buffer_size) {</a>
<a name="ln247">		ASSERT(p.buffer_size);</a>
<a name="ln248">		f.buffer_size = p.buffer_size;</a>
<a name="ln249">	}</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252">// -------------------------------------------------------- //</a>
<a name="ln253">// *** ctor/dtor</a>
<a name="ln254">// -------------------------------------------------------- //</a>
<a name="ln255"> </a>
<a name="ln256">AudioFilterNode::~AudioFilterNode() {</a>
<a name="ln257">	// shut down</a>
<a name="ln258">	Quit();</a>
<a name="ln259">	</a>
<a name="ln260">	// clean up</a>
<a name="ln261">	if(m_parameterSet) delete m_parameterSet;</a>
<a name="ln262">	if(m_opFactory) delete m_opFactory;</a>
<a name="ln263">	if(m_op) delete m_op;</a>
<a name="ln264">}</a>
<a name="ln265">	</a>
<a name="ln266">// the node acquires ownership of opFactory and</a>
<a name="ln267">AudioFilterNode::AudioFilterNode(</a>
<a name="ln268">	const char*									name,</a>
<a name="ln269">	IAudioOpFactory*						opFactory,</a>
<a name="ln270">	BMediaAddOn*								addOn) :</a>
<a name="ln271"> </a>
<a name="ln272">	// * init base classes</a>
<a name="ln273">	BMediaNode(name), // (virtual base)</a>
<a name="ln274">	BBufferConsumer(B_MEDIA_RAW_AUDIO),</a>
<a name="ln275">	BBufferProducer(B_MEDIA_RAW_AUDIO),</a>
<a name="ln276">	BControllable(),</a>
<a name="ln277">	BMediaEventLooper(),</a>
<a name="ln278">	</a>
<a name="ln279">	// * init connection state</a>
<a name="ln280">	m_outputEnabled(true),</a>
<a name="ln281">	m_downstreamLatency(0),</a>
<a name="ln282">	m_processingLatency(0),</a>
<a name="ln283">	m_bufferGroup(0),</a>
<a name="ln284">	</a>
<a name="ln285">	// * init parameter/operation components</a>
<a name="ln286">	m_parameterSet(opFactory-&gt;createParameterSet()),</a>
<a name="ln287">	m_opFactory(opFactory),</a>
<a name="ln288">	m_op(0),</a>
<a name="ln289">	</a>
<a name="ln290">	// * init add-on if any</a>
<a name="ln291">	m_addOn(addOn) {</a>
<a name="ln292"> </a>
<a name="ln293">	ASSERT(m_opFactory);</a>
<a name="ln294">	ASSERT(m_parameterSet);</a>
<a name="ln295">	</a>
<a name="ln296">	PRINT((</a>
<a name="ln297">		&quot;AudioFilterNode::AudioFilterNode()\n&quot;));</a>
<a name="ln298"> </a>
<a name="ln299">	// the rest of the initialization happens in NodeRegistered().</a>
<a name="ln300">}</a>
<a name="ln301"> </a>
<a name="ln302">// -------------------------------------------------------- //</a>
<a name="ln303">// *** BMediaNode</a>
<a name="ln304">// -------------------------------------------------------- //</a>
<a name="ln305"> </a>
<a name="ln306">status_t AudioFilterNode::HandleMessage(</a>
<a name="ln307">	int32												code,</a>
<a name="ln308">	const void*									data,</a>
<a name="ln309">	size_t											size) {</a>
<a name="ln310"> </a>
<a name="ln311">	// pass off to each base class</a>
<a name="ln312">	if(</a>
<a name="ln313">		BBufferConsumer::HandleMessage(code, data, size) &amp;&amp;</a>
<a name="ln314">		BBufferProducer::HandleMessage(code, data, size) &amp;&amp;</a>
<a name="ln315">		BControllable::HandleMessage(code, data, size) &amp;&amp;</a>
<a name="ln316">		BMediaNode::HandleMessage(code, data, size))</a>
<a name="ln317">		BMediaNode::HandleBadMessage(code, data, size);</a>
<a name="ln318">	</a>
<a name="ln319">	// +++++ return error on bad message?</a>
<a name="ln320">	return B_OK;</a>
<a name="ln321">}</a>
<a name="ln322"> </a>
<a name="ln323">BMediaAddOn* AudioFilterNode::AddOn(</a>
<a name="ln324">	int32*											outID) const {</a>
<a name="ln325"> </a>
<a name="ln326">	if(m_addOn)</a>
<a name="ln327">		*outID = 0;</a>
<a name="ln328">	return m_addOn;</a>
<a name="ln329">}</a>
<a name="ln330"> </a>
<a name="ln331">void AudioFilterNode::SetRunMode(</a>
<a name="ln332">	run_mode										mode) {</a>
<a name="ln333"> </a>
<a name="ln334">	// disallow offline mode for now</a>
<a name="ln335">	// +++++</a>
<a name="ln336">	if(mode == B_OFFLINE)</a>
<a name="ln337">		ReportError(B_NODE_FAILED_SET_RUN_MODE);</a>
<a name="ln338">		</a>
<a name="ln339">	// +++++ any other work to do?</a>
<a name="ln340">	</a>
<a name="ln341">	// hand off</a>
<a name="ln342">	BMediaEventLooper::SetRunMode(mode);</a>
<a name="ln343">}</a>
<a name="ln344">	</a>
<a name="ln345">// -------------------------------------------------------- //</a>
<a name="ln346">// *** BMediaEventLooper</a>
<a name="ln347">// -------------------------------------------------------- //</a>
<a name="ln348"> </a>
<a name="ln349">void AudioFilterNode::HandleEvent(</a>
<a name="ln350">	const media_timed_event*		event,</a>
<a name="ln351">	bigtime_t										howLate,</a>
<a name="ln352">	bool												realTimeEvent) {</a>
<a name="ln353"> </a>
<a name="ln354">	ASSERT(event);</a>
<a name="ln355">	</a>
<a name="ln356">	switch(event-&gt;type) {</a>
<a name="ln357">		case BTimedEventQueue::B_PARAMETER:</a>
<a name="ln358">			handleParameterEvent(event);</a>
<a name="ln359">			break;</a>
<a name="ln360">			</a>
<a name="ln361">		case BTimedEventQueue::B_START:</a>
<a name="ln362">			handleStartEvent(event);</a>
<a name="ln363">			break;</a>
<a name="ln364">			</a>
<a name="ln365">		case BTimedEventQueue::B_STOP:</a>
<a name="ln366">			handleStopEvent(event);</a>
<a name="ln367">			break;</a>
<a name="ln368">			</a>
<a name="ln369">		default:</a>
<a name="ln370">			ignoreEvent(event);</a>
<a name="ln371">			break;</a>
<a name="ln372">	}</a>
<a name="ln373">}</a>
<a name="ln374"> </a>
<a name="ln375">// &quot;The Media Server calls this hook function after the node has</a>
<a name="ln376">//  been registered.  This is derived from BMediaNode; BMediaEventLooper</a>
<a name="ln377">//  implements it to call Run() automatically when the node is registered;</a>
<a name="ln378">//  if you implement NodeRegistered() you should call through to</a>
<a name="ln379">//  BMediaEventLooper::NodeRegistered() after you've done your custom </a>
<a name="ln380">//  operations.&quot;</a>
<a name="ln381"> </a>
<a name="ln382">void AudioFilterNode::NodeRegistered() {</a>
<a name="ln383"> </a>
<a name="ln384">	PRINT((&quot;AudioFilterNode::NodeRegistered()\n&quot;));</a>
<a name="ln385">	status_t err;</a>
<a name="ln386"> </a>
<a name="ln387">	// init input</a>
<a name="ln388">	m_input.destination.port = ControlPort();</a>
<a name="ln389">	m_input.destination.id = ID_AUDIO_INPUT;</a>
<a name="ln390">	m_input.node = Node();</a>
<a name="ln391">	m_input.source = media_source::null;</a>
<a name="ln392"> </a>
<a name="ln393">	m_input.format.type = B_MEDIA_RAW_AUDIO;</a>
<a name="ln394">	err = getRequiredInputFormat(m_input.format);</a>
<a name="ln395">	ASSERT(err == B_OK);</a>
<a name="ln396"> </a>
<a name="ln397">	strncpy(m_input.name, &quot;Audio Input&quot;, B_MEDIA_NAME_LENGTH);</a>
<a name="ln398">	</a>
<a name="ln399">	// init output</a>
<a name="ln400">	m_output.source.port = ControlPort();</a>
<a name="ln401">	m_output.source.id = ID_AUDIO_MIX_OUTPUT;</a>
<a name="ln402">	m_output.node = Node();</a>
<a name="ln403">	m_output.destination = media_destination::null;</a>
<a name="ln404"> </a>
<a name="ln405">	m_output.format.type = B_MEDIA_RAW_AUDIO;</a>
<a name="ln406">	err = getRequiredOutputFormat(m_output.format);</a>
<a name="ln407">	ASSERT(err == B_OK);</a>
<a name="ln408"> </a>
<a name="ln409">	strncpy(m_output.name, &quot;Audio Output&quot;, B_MEDIA_NAME_LENGTH);</a>
<a name="ln410"> </a>
<a name="ln411">	// init parameters</a>
<a name="ln412">	initParameterWeb();</a>
<a name="ln413"> </a>
<a name="ln414">	// Start the BMediaEventLooper thread</a>
<a name="ln415">	SetPriority(B_REAL_TIME_PRIORITY);</a>
<a name="ln416">	Run();</a>
<a name="ln417">}</a>
<a name="ln418">	</a>
<a name="ln419">// &quot;Augment OfflineTime() to compute the node's current time; it's called</a>
<a name="ln420">//  by the Media Kit when it's in offline mode. Update any appropriate</a>
<a name="ln421">//  internal information as well, then call through to the BMediaEventLooper</a>
<a name="ln422">//  implementation.&quot;</a>
<a name="ln423"> </a>
<a name="ln424">bigtime_t AudioFilterNode::OfflineTime() {</a>
<a name="ln425">	// +++++ offline mode not implemented +++++</a>
<a name="ln426">	return 0LL;</a>
<a name="ln427">}</a>
<a name="ln428"> </a>
<a name="ln429"> </a>
<a name="ln430">// -------------------------------------------------------- //</a>
<a name="ln431">// *** BBufferConsumer</a>
<a name="ln432">// -------------------------------------------------------- //</a>
<a name="ln433"> </a>
<a name="ln434">status_t AudioFilterNode::AcceptFormat(</a>
<a name="ln435">	const media_destination&amp;		destination,</a>
<a name="ln436">	media_format*								ioFormat) {</a>
<a name="ln437"> </a>
<a name="ln438">	PRINT((&quot;AudioFilterNode::AcceptFormat()\n&quot;));</a>
<a name="ln439">	status_t err;</a>
<a name="ln440">	</a>
<a name="ln441">	// sanity checks</a>
<a name="ln442">	if(destination != m_input.destination) {</a>
<a name="ln443">		PRINT((&quot;\tbad destination\n&quot;));</a>
<a name="ln444">		return B_MEDIA_BAD_DESTINATION;</a>
<a name="ln445">	}</a>
<a name="ln446">	if(ioFormat-&gt;type != B_MEDIA_RAW_AUDIO) {</a>
<a name="ln447">		PRINT((&quot;\tnot B_MEDIA_RAW_AUDIO\n&quot;));</a>
<a name="ln448">		return B_MEDIA_BAD_FORMAT;</a>
<a name="ln449">	}</a>
<a name="ln450"> </a>
<a name="ln451">	media_format required;</a>
<a name="ln452">	required.type = B_MEDIA_RAW_AUDIO;</a>
<a name="ln453">	err = getRequiredInputFormat(required);</a>
<a name="ln454">	ASSERT(err == B_OK);</a>
<a name="ln455"> </a>
<a name="ln456">//	// attempt to create op? +++++  </a>
<a name="ln457">//</a>
<a name="ln458">//	// validate against current input/output format for now</a>
<a name="ln459">//	validateProposedFormat(</a>
<a name="ln460">//		(m_format.u.raw_audio.format != media_raw_audio_format::wildcard.format) ?</a>
<a name="ln461">//			m_format : preferred,</a>
<a name="ln462">//		*ioFormat);</a>
<a name="ln463"> </a>
<a name="ln464">	// validate against required format</a>
<a name="ln465">	err = validateProposedInputFormat(required, *ioFormat);</a>
<a name="ln466">	if(err &lt; B_OK)</a>
<a name="ln467">		return err;</a>
<a name="ln468">		</a>
<a name="ln469">	// if an output connection has been made, try to create an operation</a>
<a name="ln470">	if(m_output.destination != media_destination::null) {</a>
<a name="ln471">		ASSERT(m_opFactory);</a>
<a name="ln472">		IAudioOp* op = m_opFactory-&gt;createOp(</a>
<a name="ln473">			this,</a>
<a name="ln474">			ioFormat-&gt;u.raw_audio,</a>
<a name="ln475">			m_output.format.u.raw_audio);</a>
<a name="ln476"> </a>
<a name="ln477">		if(!op) {</a>
<a name="ln478">			// format passed validation, but factory failed to provide a</a>
<a name="ln479">			// capable operation object</a>
<a name="ln480">			char fmt[256];</a>
<a name="ln481">			string_for_format(*ioFormat, fmt, 255);</a>
<a name="ln482">			PRINT((</a>
<a name="ln483">				&quot;*** AcceptFormat(): format validated, but no operation found:\n&quot;</a>
<a name="ln484">				&quot;    %s\n&quot;,</a>
<a name="ln485">				fmt));</a>
<a name="ln486"> </a>
<a name="ln487">			return B_MEDIA_BAD_FORMAT;</a>
<a name="ln488">		}</a>
<a name="ln489">		// clean up</a>
<a name="ln490">		delete op;</a>
<a name="ln491">	}</a>
<a name="ln492">	</a>
<a name="ln493">	// format passed inspection</a>
<a name="ln494">	return B_OK;</a>
<a name="ln495">}</a>
<a name="ln496">	</a>
<a name="ln497">// &quot;If you're writing a node, and receive a buffer with the B_SMALL_BUFFER</a>
<a name="ln498">//  flag set, you must recycle the buffer before returning.&quot;	</a>
<a name="ln499"> </a>
<a name="ln500">void AudioFilterNode::BufferReceived(</a>
<a name="ln501">	BBuffer*										buffer) {</a>
<a name="ln502">	ASSERT(buffer);</a>
<a name="ln503"> </a>
<a name="ln504">	// check buffer destination</a>
<a name="ln505">	if(buffer-&gt;Header()-&gt;destination !=</a>
<a name="ln506">		m_input.destination.id) {</a>
<a name="ln507">		PRINT((&quot;AudioFilterNode::BufferReceived():\n&quot;</a>
<a name="ln508">			&quot;\tBad destination.\n&quot;));</a>
<a name="ln509">		buffer-&gt;Recycle();</a>
<a name="ln510">		return;</a>
<a name="ln511">	}</a>
<a name="ln512">	</a>
<a name="ln513">	if(buffer-&gt;Header()-&gt;time_source != TimeSource()-&gt;ID()) { // +++++ no-go in offline mode</a>
<a name="ln514">		PRINT((&quot;* timesource mismatch\n&quot;));</a>
<a name="ln515">	}</a>
<a name="ln516"> </a>
<a name="ln517">	// check output</a>
<a name="ln518">	if(m_output.destination == media_destination::null ||</a>
<a name="ln519">		!m_outputEnabled) {</a>
<a name="ln520">		buffer-&gt;Recycle();</a>
<a name="ln521">		return;</a>
<a name="ln522">	}</a>
<a name="ln523">	</a>
<a name="ln524">//	// +++++ [9sep99]</a>
<a name="ln525">//	bigtime_t now = TimeSource()-&gt;Now();</a>
<a name="ln526">//	bigtime_t delta = now - m_tpLastReceived;</a>
<a name="ln527">//	m_tpLastReceived = now;</a>
<a name="ln528">//	PRINT((</a>
<a name="ln529">//		&quot;### delta: %Ld (%Ld)\n&quot;,</a>
<a name="ln530">//		delta, buffer-&gt;Header()-&gt;start_time - now));</a>
<a name="ln531"> </a>
<a name="ln532">	// fetch outbound buffer if needed</a>
<a name="ln533">	BBuffer* outBuffer;</a>
<a name="ln534">	if(m_bufferGroup) {</a>
<a name="ln535">		outBuffer = m_bufferGroup-&gt;RequestBuffer(</a>
<a name="ln536">			m_output.format.u.raw_audio.buffer_size, -1);</a>
<a name="ln537">		ASSERT(outBuffer);</a>
<a name="ln538">		</a>
<a name="ln539">		// prepare outbound buffer</a>
<a name="ln540">		outBuffer-&gt;Header()-&gt;type = B_MEDIA_RAW_AUDIO;</a>
<a name="ln541"> </a>
<a name="ln542">		// copy start time info from upstream node</a>
<a name="ln543">		// +++++ is this proper, or should the next buffer-start be</a>
<a name="ln544">		//       continuously tracked (figured from Start() or the first</a>
<a name="ln545">		//       buffer received?)</a>
<a name="ln546">		outBuffer-&gt;Header()-&gt;time_source = buffer-&gt;Header()-&gt;time_source;</a>
<a name="ln547">		outBuffer-&gt;Header()-&gt;start_time = buffer-&gt;Header()-&gt;start_time;</a>
<a name="ln548">	}</a>
<a name="ln549">	else {</a>
<a name="ln550">		// process inplace</a>
<a name="ln551">		outBuffer = buffer;</a>
<a name="ln552">	}</a>
<a name="ln553">			</a>
<a name="ln554">	// process and retransmit buffer</a>
<a name="ln555">	processBuffer(buffer, outBuffer);</a>
<a name="ln556"> </a>
<a name="ln557">	status_t err = SendBuffer(outBuffer, m_output.source, m_output.destination);</a>
<a name="ln558">	if (err &lt; B_OK) {</a>
<a name="ln559">		PRINT((&quot;AudioFilterNode::BufferReceived():\n&quot;</a>
<a name="ln560">			&quot;\tSendBuffer() failed: %s\n&quot;, strerror(err)));</a>
<a name="ln561">		outBuffer-&gt;Recycle();</a>
<a name="ln562">	}</a>
<a name="ln563"> </a>
<a name="ln564">	// free inbound buffer if data was copied	</a>
<a name="ln565">	if(buffer != outBuffer)</a>
<a name="ln566">		buffer-&gt;Recycle();</a>
<a name="ln567"> </a>
<a name="ln568">//	//####resend</a>
<a name="ln569">//	SendBuffer(buffer, m_output.destination);</a>
<a name="ln570"> </a>
<a name="ln571">	// sent!</a>
<a name="ln572">}</a>
<a name="ln573">	</a>
<a name="ln574">// * make sure to fill in poInput-&gt;format with the contents of</a>
<a name="ln575">//   pFormat; as of R4.5 the Media Kit passes poInput-&gt;format to</a>
<a name="ln576">//   the producer in BBufferProducer::Connect().</a>
<a name="ln577"> </a>
<a name="ln578">status_t AudioFilterNode::Connected(</a>
<a name="ln579">	const media_source&amp;					source,</a>
<a name="ln580">	const media_destination&amp;		destination,</a>
<a name="ln581">	const media_format&amp;					format,</a>
<a name="ln582">	media_input*								outInput) {</a>
<a name="ln583">	</a>
<a name="ln584">	PRINT((&quot;AudioFilterNode::Connected()\n&quot;</a>
<a name="ln585">		&quot;\tto source %&quot; B_PRId32 &quot;\n&quot;, source.id));</a>
<a name="ln586">	</a>
<a name="ln587">	// sanity check</a>
<a name="ln588">	if(destination != m_input.destination) {</a>
<a name="ln589">		PRINT((&quot;\tbad destination\n&quot;));</a>
<a name="ln590">		return B_MEDIA_BAD_DESTINATION;</a>
<a name="ln591">	}</a>
<a name="ln592">	if(m_input.source != media_source::null) {</a>
<a name="ln593">		PRINT((&quot;\talready connected\n&quot;));</a>
<a name="ln594">		return B_MEDIA_ALREADY_CONNECTED;</a>
<a name="ln595">	}</a>
<a name="ln596">	</a>
<a name="ln597">	// initialize input</a>
<a name="ln598">	m_input.source = source;</a>
<a name="ln599">	m_input.format = format;</a>
<a name="ln600">	*outInput = m_input;</a>
<a name="ln601">	</a>
<a name="ln602">	// [re-]initialize operation</a>
<a name="ln603">	updateOperation();</a>
<a name="ln604">	</a>
<a name="ln605">	return B_OK;</a>
<a name="ln606">}</a>
<a name="ln607"> </a>
<a name="ln608">void AudioFilterNode::Disconnected(</a>
<a name="ln609">	const media_source&amp;					source,</a>
<a name="ln610">	const media_destination&amp;		destination) {</a>
<a name="ln611">	</a>
<a name="ln612">	PRINT((&quot;AudioFilterNode::Disconnected()\n&quot;));</a>
<a name="ln613"> </a>
<a name="ln614">	// sanity checks</a>
<a name="ln615">	if(m_input.source != source) {</a>
<a name="ln616">		PRINT((&quot;\tsource mismatch: expected ID %&quot; B_PRId32 &quot;, got %&quot; B_PRId32</a>
<a name="ln617">				&quot;\n&quot;, m_input.source.id, source.id));</a>
<a name="ln618">		return;</a>
<a name="ln619">	}</a>
<a name="ln620">	if(destination != m_input.destination) {</a>
<a name="ln621">		PRINT((&quot;\tdestination mismatch: expected ID %&quot; B_PRId32 &quot;, got %&quot;</a>
<a name="ln622">				B_PRId32 &quot;\n&quot;, m_input.destination.id, destination.id));</a>
<a name="ln623">		return;</a>
<a name="ln624">	}</a>
<a name="ln625"> </a>
<a name="ln626">	// mark disconnected</a>
<a name="ln627">	m_input.source = media_source::null;</a>
<a name="ln628"> </a>
<a name="ln629">#ifdef DEBUG</a>
<a name="ln630">	status_t err =</a>
<a name="ln631">#endif</a>
<a name="ln632">	getRequiredInputFormat(m_input.format);</a>
<a name="ln633">	ASSERT(err == B_OK);</a>
<a name="ln634">	</a>
<a name="ln635">	// remove operation</a>
<a name="ln636">	if(m_op) {</a>
<a name="ln637">		delete m_op;</a>
<a name="ln638">		m_op = 0;</a>
<a name="ln639">	}</a>
<a name="ln640">	</a>
<a name="ln641">	// +++++ further cleanup?</a>
<a name="ln642"> </a>
<a name="ln643">	// release buffer group</a>
<a name="ln644">	updateBufferGroup();</a>
<a name="ln645">}</a>
<a name="ln646">		</a>
<a name="ln647">		</a>
<a name="ln648">void AudioFilterNode::DisposeInputCookie(</a>
<a name="ln649">	int32												cookie) {}</a>
<a name="ln650">	</a>
<a name="ln651">// &quot;You should implement this function so your node will know that the data</a>
<a name="ln652">//  format is going to change. Note that this may be called in response to</a>
<a name="ln653">//  your AcceptFormat() call, if your AcceptFormat() call alters any wildcard</a>
<a name="ln654">//  fields in the specified format. </a>
<a name="ln655">//</a>
<a name="ln656">//  Because FormatChanged() is called by the producer, you don't need to (and</a>
<a name="ln657">//  shouldn't) ask it if the new format is acceptable. </a>
<a name="ln658">//</a>
<a name="ln659">//  If the format change isn't possible, return an appropriate error from</a>
<a name="ln660">//  FormatChanged(); this error will be passed back to the producer that</a>
<a name="ln661">//  initiated the new format negotiation in the first place.&quot;</a>
<a name="ln662"> </a>
<a name="ln663">status_t AudioFilterNode::FormatChanged(</a>
<a name="ln664">	const media_source&amp;					source,</a>
<a name="ln665">	const media_destination&amp;		destination,</a>
<a name="ln666">	int32												changeTag,</a>
<a name="ln667">	const media_format&amp;					newFormat) {</a>
<a name="ln668">	</a>
<a name="ln669">	// flat-out deny format changes for now +++++</a>
<a name="ln670">	return B_MEDIA_BAD_FORMAT;</a>
<a name="ln671">}</a>
<a name="ln672">		</a>
<a name="ln673">status_t AudioFilterNode::GetLatencyFor(</a>
<a name="ln674">	const media_destination&amp;		destination,</a>
<a name="ln675">	bigtime_t*									outLatency,</a>
<a name="ln676">	media_node_id*							outTimeSource) {</a>
<a name="ln677">	</a>
<a name="ln678">	PRINT((&quot;AudioFilterNode::GetLatencyFor()\n&quot;));</a>
<a name="ln679">	</a>
<a name="ln680">	// sanity check</a>
<a name="ln681">	if(destination != m_input.destination) {</a>
<a name="ln682">		PRINT((&quot;\tbad destination\n&quot;));</a>
<a name="ln683">		return B_MEDIA_BAD_DESTINATION;</a>
<a name="ln684">	}</a>
<a name="ln685">	</a>
<a name="ln686">	*outLatency = m_downstreamLatency + m_processingLatency;</a>
<a name="ln687">	PRINT((&quot;\treturning %&quot; B_PRIdBIGTIME &quot;\n&quot;, *outLatency));</a>
<a name="ln688">	*outTimeSource = TimeSource()-&gt;ID();</a>
<a name="ln689">	return B_OK;</a>
<a name="ln690">}</a>
<a name="ln691">		</a>
<a name="ln692">status_t AudioFilterNode::GetNextInput(</a>
<a name="ln693">	int32*											ioCookie,</a>
<a name="ln694">	media_input*								outInput) {</a>
<a name="ln695"> </a>
<a name="ln696">	if(*ioCookie)</a>
<a name="ln697">		return B_BAD_INDEX;</a>
<a name="ln698">	</a>
<a name="ln699">	++*ioCookie;</a>
<a name="ln700">	*outInput = m_input;</a>
<a name="ln701">	return B_OK;</a>
<a name="ln702">}</a>
<a name="ln703"> </a>
<a name="ln704"> </a>
<a name="ln705">void AudioFilterNode::ProducerDataStatus(</a>
<a name="ln706">	const media_destination&amp;		destination,</a>
<a name="ln707">	int32												status,</a>
<a name="ln708">	bigtime_t										tpWhen) {</a>
<a name="ln709"> </a>
<a name="ln710">	PRINT((&quot;AudioFilterNode::ProducerDataStatus(%&quot; B_PRId32 &quot; at %&quot;</a>
<a name="ln711">			B_PRIdBIGTIME &quot;)\n&quot;, status, tpWhen));</a>
<a name="ln712">	</a>
<a name="ln713">	// sanity check</a>
<a name="ln714">	if(destination != m_input.destination) {</a>
<a name="ln715">		PRINT((&quot;\tbad destination\n&quot;));</a>
<a name="ln716">	}</a>
<a name="ln717">	</a>
<a name="ln718">	if(m_output.destination != media_destination::null) {</a>
<a name="ln719">		// pass status downstream</a>
<a name="ln720">		status_t err = SendDataStatus(</a>
<a name="ln721">			status, </a>
<a name="ln722">			m_output.destination,</a>
<a name="ln723">			tpWhen);</a>
<a name="ln724">		if(err &lt; B_OK) {</a>
<a name="ln725">			PRINT((&quot;\tSendDataStatus(): %s\n&quot;, strerror(err)));</a>
<a name="ln726">		}</a>
<a name="ln727">	}</a>
<a name="ln728">}</a>
<a name="ln729"> </a>
<a name="ln730">// &quot;This function is provided to aid in supporting media formats in which the</a>
<a name="ln731">//  outer encapsulation layer doesn't supply timing information. Producers will</a>
<a name="ln732">//  tag the buffers they generate with seek tags; these tags can be used to</a>
<a name="ln733">//  locate key frames in the media data.&quot;</a>
<a name="ln734"> </a>
<a name="ln735">status_t AudioFilterNode::SeekTagRequested(</a>
<a name="ln736">	const media_destination&amp;		destination,</a>
<a name="ln737">	bigtime_t										targetTime,</a>
<a name="ln738">	uint32											flags,</a>
<a name="ln739">	media_seek_tag*							outSeekTag,</a>
<a name="ln740">	bigtime_t*									outTaggedTime,</a>
<a name="ln741">	uint32*											outFlags) {</a>
<a name="ln742"> </a>
<a name="ln743">	// +++++</a>
<a name="ln744">	PRINT((&quot;AudioFilterNode::SeekTagRequested()\n&quot;</a>
<a name="ln745">		&quot;\tNot implemented.\n&quot;));</a>
<a name="ln746">	return B_ERROR;</a>
<a name="ln747">}</a>
<a name="ln748">	</a>
<a name="ln749">// -------------------------------------------------------- //</a>
<a name="ln750">// *** BBufferProducer</a>
<a name="ln751">// -------------------------------------------------------- //</a>
<a name="ln752"> </a>
<a name="ln753">// &quot;When a consumer calls BBufferConsumer::RequestAdditionalBuffer(), this</a>
<a name="ln754">//  function is called as a result. Its job is to call SendBuffer() to</a>
<a name="ln755">//  immediately send the next buffer to the consumer. The previousBufferID,</a>
<a name="ln756">//  previousTime, and previousTag arguments identify the last buffer the</a>
<a name="ln757">//  consumer received. Your node should respond by sending the next buffer</a>
<a name="ln758">//  after the one described. </a>
<a name="ln759">//</a>
<a name="ln760">//  The previousTag may be NULL.</a>
<a name="ln761">//  Return B_OK if all is well; otherwise return an appropriate error code.&quot;</a>
<a name="ln762"> </a>
<a name="ln763">void AudioFilterNode::AdditionalBufferRequested(</a>
<a name="ln764">	const media_source&amp;					source,</a>
<a name="ln765">	media_buffer_id							previousBufferID,</a>
<a name="ln766">	bigtime_t										previousTime,</a>
<a name="ln767">	const media_seek_tag*				previousTag) {</a>
<a name="ln768">	</a>
<a name="ln769">	// +++++</a>
<a name="ln770">	PRINT((&quot;AudioFilterNode::AdditionalBufferRequested\n&quot;</a>
<a name="ln771">		&quot;\tOffline mode not implemented.&quot;));</a>
<a name="ln772">}</a>
<a name="ln773">		</a>
<a name="ln774">void AudioFilterNode::Connect(</a>
<a name="ln775">	status_t										status,</a>
<a name="ln776">	const media_source&amp;					source,</a>
<a name="ln777">	const media_destination&amp;		destination,</a>
<a name="ln778">	const media_format&amp;					format,</a>
<a name="ln779">	char*												ioName) {</a>
<a name="ln780">	</a>
<a name="ln781">	PRINT((&quot;AudioFilterNode::Connect()\n&quot;));</a>
<a name="ln782">	status_t err;</a>
<a name="ln783"> </a>
<a name="ln784">#if DEBUG</a>
<a name="ln785">	char formatStr[256];</a>
<a name="ln786">	string_for_format(format, formatStr, 255);</a>
<a name="ln787">	PRINT((&quot;\tformat: %s\n&quot;, formatStr));</a>
<a name="ln788">#endif</a>
<a name="ln789"> </a>
<a name="ln790">	// connection failed?	</a>
<a name="ln791">	if(status &lt; B_OK) {</a>
<a name="ln792">		PRINT((&quot;\tCONNECTION FAILED: Status '%s'\n&quot;, strerror(status)));</a>
<a name="ln793">		// 'unreserve' the output</a>
<a name="ln794">		m_output.destination = media_destination::null;</a>
<a name="ln795">		return;</a>
<a name="ln796">	}</a>
<a name="ln797">	</a>
<a name="ln798">	// connection established:</a>
<a name="ln799">	strncpy(ioName, m_output.name, B_MEDIA_NAME_LENGTH);</a>
<a name="ln800">	m_output.destination = destination;</a>
<a name="ln801">	</a>
<a name="ln802">	// figure downstream latency</a>
<a name="ln803">	media_node_id timeSource;</a>
<a name="ln804">	err = FindLatencyFor(m_output.destination, &amp;m_downstreamLatency, &amp;timeSource);</a>
<a name="ln805">	if(err &lt; B_OK) {</a>
<a name="ln806">		PRINT((&quot;\t!!! FindLatencyFor(): %s\n&quot;, strerror(err)));</a>
<a name="ln807">	}</a>
<a name="ln808">	PRINT((&quot;\tdownstream latency = %&quot; B_PRIdBIGTIME &quot;\n&quot;, m_downstreamLatency));</a>
<a name="ln809">	</a>
<a name="ln810">//	// prepare the filter</a>
<a name="ln811">//	initFilter();</a>
<a name="ln812">//</a>
<a name="ln813">//	// figure processing time</a>
<a name="ln814">//	m_processingLatency = calcProcessingLatency();</a>
<a name="ln815">//	PRINT((&quot;\tprocessing latency = %Ld\n&quot;, m_processingLatency));</a>
<a name="ln816">//	</a>
<a name="ln817">//	// store summed latency</a>
<a name="ln818">//	SetEventLatency(m_downstreamLatency + m_processingLatency);</a>
<a name="ln819">//	</a>
<a name="ln820">//	if(m_input.source != media_source::null) {</a>
<a name="ln821">//		// pass new latency upstream</a>
<a name="ln822">//		err = SendLatencyChange(</a>
<a name="ln823">//			m_input.source,</a>
<a name="ln824">//			m_input.destination,</a>
<a name="ln825">//			EventLatency() + SchedulingLatency());</a>
<a name="ln826">//		if(err &lt; B_OK)</a>
<a name="ln827">//			PRINT((&quot;\t!!! SendLatencyChange(): %s\n&quot;, strerror(err)));</a>
<a name="ln828">//	}</a>
<a name="ln829"> </a>
<a name="ln830">	// cache buffer duration</a>
<a name="ln831">	SetBufferDuration(</a>
<a name="ln832">		buffer_duration(</a>
<a name="ln833">			m_output.format.u.raw_audio));</a>
<a name="ln834">			</a>
<a name="ln835">	// [re-]initialize operation</a>
<a name="ln836">	updateOperation();	</a>
<a name="ln837"> </a>
<a name="ln838">	// initialize buffer group if necessary</a>
<a name="ln839">	updateBufferGroup();</a>
<a name="ln840">}</a>
<a name="ln841">	</a>
<a name="ln842">void AudioFilterNode::Disconnect(</a>
<a name="ln843">	const media_source&amp;					source,</a>
<a name="ln844">	const media_destination&amp;		destination) {</a>
<a name="ln845"> </a>
<a name="ln846">	PRINT((&quot;AudioFilterNode::Disconnect()\n&quot;));</a>
<a name="ln847">	</a>
<a name="ln848">	// sanity checks	</a>
<a name="ln849">	if(source != m_output.source) {</a>
<a name="ln850">		PRINT((&quot;\tbad source\n&quot;));</a>
<a name="ln851">		return;</a>
<a name="ln852">	}</a>
<a name="ln853">	if(destination != m_output.destination) {</a>
<a name="ln854">		PRINT((&quot;\tbad destination\n&quot;));</a>
<a name="ln855">		return;</a>
<a name="ln856">	}</a>
<a name="ln857"> </a>
<a name="ln858">	// clean up</a>
<a name="ln859">	m_output.destination = media_destination::null;</a>
<a name="ln860"> </a>
<a name="ln861">#ifdef DEBUG</a>
<a name="ln862">	status_t err =</a>
<a name="ln863">#endif</a>
<a name="ln864">	getRequiredOutputFormat(m_output.format);</a>
<a name="ln865">	ASSERT(err == B_OK);</a>
<a name="ln866"> </a>
<a name="ln867">	updateBufferGroup();</a>
<a name="ln868">	</a>
<a name="ln869">	if(m_op) {</a>
<a name="ln870">		delete m_op;</a>
<a name="ln871">		m_op = 0;</a>
<a name="ln872">	}</a>
<a name="ln873">}</a>
<a name="ln874">		</a>
<a name="ln875">status_t AudioFilterNode::DisposeOutputCookie(</a>
<a name="ln876">	int32												cookie) {</a>
<a name="ln877">	return B_OK;</a>
<a name="ln878">}</a>
<a name="ln879">		</a>
<a name="ln880">void AudioFilterNode::EnableOutput(</a>
<a name="ln881">	const media_source&amp;					source,</a>
<a name="ln882">	bool												enabled,</a>
<a name="ln883">	int32* _deprecated_) {</a>
<a name="ln884">	</a>
<a name="ln885">	PRINT((&quot;AudioFilterNode::EnableOutput()\n&quot;));</a>
<a name="ln886">	if(source != m_output.source) {</a>
<a name="ln887">		PRINT((&quot;\tbad source\n&quot;));</a>
<a name="ln888">		return;</a>
<a name="ln889">	}</a>
<a name="ln890">	</a>
<a name="ln891">	m_outputEnabled = enabled;</a>
<a name="ln892">}</a>
<a name="ln893">		</a>
<a name="ln894">status_t AudioFilterNode::FormatChangeRequested(</a>
<a name="ln895">	const media_source&amp;					source,</a>
<a name="ln896">	const media_destination&amp;		destination,</a>
<a name="ln897">	media_format*								ioFormat,</a>
<a name="ln898">	int32* _deprecated_) {</a>
<a name="ln899">	</a>
<a name="ln900">	// deny +++++ for now</a>
<a name="ln901">	PRINT((&quot;AudioFilterNode::FormatChangeRequested()\n&quot;</a>
<a name="ln902">		&quot;\tNot supported.\n&quot;));</a>
<a name="ln903">		</a>
<a name="ln904">	return B_MEDIA_BAD_FORMAT;</a>
<a name="ln905">}</a>
<a name="ln906">		</a>
<a name="ln907">status_t AudioFilterNode::FormatProposal(</a>
<a name="ln908">	const media_source&amp;					source,</a>
<a name="ln909">	media_format*								ioFormat) {</a>
<a name="ln910"> </a>
<a name="ln911">	PRINT((&quot;AudioFilterNode::FormatProposal()\n&quot;));</a>
<a name="ln912">	status_t err;</a>
<a name="ln913">	</a>
<a name="ln914">	if(source != m_output.source) {</a>
<a name="ln915">		PRINT((&quot;\tbad source\n&quot;));</a>
<a name="ln916">		return B_MEDIA_BAD_SOURCE;</a>
<a name="ln917">	}</a>
<a name="ln918">	</a>
<a name="ln919">	if(ioFormat-&gt;type != B_MEDIA_RAW_AUDIO) {</a>
<a name="ln920">		PRINT((&quot;\tbad type\n&quot;));</a>
<a name="ln921">		return B_MEDIA_BAD_FORMAT;</a>
<a name="ln922">	}</a>
<a name="ln923">	</a>
<a name="ln924">	// validate against required format</a>
<a name="ln925">	media_format required;</a>
<a name="ln926">	required.type = B_MEDIA_RAW_AUDIO;</a>
<a name="ln927">	err = getRequiredOutputFormat(required);</a>
<a name="ln928">	ASSERT(err == B_OK);</a>
<a name="ln929">	</a>
<a name="ln930">	err = validateProposedOutputFormat(</a>
<a name="ln931">		required,</a>
<a name="ln932">		*ioFormat);</a>
<a name="ln933">	if(err &lt; B_OK)</a>
<a name="ln934">		return err;</a>
<a name="ln935">	</a>
<a name="ln936">//	// specialize the format</a>
<a name="ln937">//	media_format testFormat = *ioFormat;</a>
<a name="ln938">//	specializeOutputFormat(testFormat);</a>
<a name="ln939">//	</a>
<a name="ln940">//	// if the input is connected, ask the factory for a matching operation</a>
<a name="ln941">//	if(m_input.source != media_source::null) {</a>
<a name="ln942">//		ASSERT(m_opFactory);</a>
<a name="ln943">//		IAudioOp* op = m_opFactory-&gt;createOp(</a>
<a name="ln944">//			this,</a>
<a name="ln945">//			m_input.format.u.raw_audio,</a>
<a name="ln946">//			testFormat.u.raw_audio);</a>
<a name="ln947">//</a>
<a name="ln948">//		if(!op) {</a>
<a name="ln949">//			// format passed validation, but factory failed to provide a</a>
<a name="ln950">//			// capable operation object</a>
<a name="ln951">//			char fmt[256];</a>
<a name="ln952">//			string_for_format(*ioFormat, fmt, 255);</a>
<a name="ln953">//			PRINT((</a>
<a name="ln954">//				&quot;*** FormatProposal(): format validated, but no operation found:\n&quot;</a>
<a name="ln955">//				&quot;    %s\n&quot;,</a>
<a name="ln956">//				fmt));</a>
<a name="ln957">//</a>
<a name="ln958">//			return B_MEDIA_BAD_FORMAT;</a>
<a name="ln959">//		}</a>
<a name="ln960">//		// clean up</a>
<a name="ln961">//		delete op;</a>
<a name="ln962">//	}</a>
<a name="ln963">	</a>
<a name="ln964">	// format passed inspection</a>
<a name="ln965">	return B_OK;</a>
<a name="ln966">}</a>
<a name="ln967">		</a>
<a name="ln968">status_t AudioFilterNode::FormatSuggestionRequested(</a>
<a name="ln969">	media_type									type,</a>
<a name="ln970">	int32												quality,</a>
<a name="ln971">	media_format*								outFormat) {</a>
<a name="ln972">	</a>
<a name="ln973">	PRINT((&quot;AudioFilterNode::FormatSuggestionRequested()\n&quot;));</a>
<a name="ln974">	if(type != B_MEDIA_RAW_AUDIO) {</a>
<a name="ln975">		PRINT((&quot;\tbad type\n&quot;));</a>
<a name="ln976">		return B_MEDIA_BAD_FORMAT;</a>
<a name="ln977">	}</a>
<a name="ln978">	</a>
<a name="ln979">	outFormat-&gt;type = type;</a>
<a name="ln980">	return getPreferredOutputFormat(*outFormat);</a>
<a name="ln981">}</a>
<a name="ln982">		</a>
<a name="ln983">status_t AudioFilterNode::GetLatency(</a>
<a name="ln984">	bigtime_t*									outLatency) {</a>
<a name="ln985">	</a>
<a name="ln986">	PRINT((&quot;AudioFilterNode::GetLatency()\n&quot;));</a>
<a name="ln987">	*outLatency = EventLatency() + SchedulingLatency();</a>
<a name="ln988">	PRINT((&quot;\treturning %&quot; B_PRIdBIGTIME &quot;\n&quot;, *outLatency));</a>
<a name="ln989">	</a>
<a name="ln990">	return B_OK;</a>
<a name="ln991">}</a>
<a name="ln992">		</a>
<a name="ln993">status_t AudioFilterNode::GetNextOutput(</a>
<a name="ln994">	int32*											ioCookie,</a>
<a name="ln995">	media_output*								outOutput) {</a>
<a name="ln996"> </a>
<a name="ln997">	if(*ioCookie)</a>
<a name="ln998">		return B_BAD_INDEX;</a>
<a name="ln999">	</a>
<a name="ln1000">	++*ioCookie;</a>
<a name="ln1001">	*outOutput = m_output;</a>
<a name="ln1002">	</a>
<a name="ln1003">	return B_OK;</a>
<a name="ln1004">}</a>
<a name="ln1005"> </a>
<a name="ln1006">	</a>
<a name="ln1007">// &quot;This hook function is called when a BBufferConsumer that's receiving data</a>
<a name="ln1008">//  from you determines that its latency has changed. It will call its</a>
<a name="ln1009">//  BBufferConsumer::SendLatencyChange() function, and in response, the Media</a>
<a name="ln1010">//  Server will call your LatencyChanged() function.  The source argument</a>
<a name="ln1011">//  indicates your output that's involved in the connection, and destination</a>
<a name="ln1012">//  specifies the input on the consumer to which the connection is linked.</a>
<a name="ln1013">//  newLatency is the consumer's new latency. The flags are currently unused.&quot;</a>
<a name="ln1014">void AudioFilterNode::LatencyChanged(</a>
<a name="ln1015">	const media_source&amp;					source,</a>
<a name="ln1016">	const media_destination&amp;		destination,</a>
<a name="ln1017">	bigtime_t										newLatency,</a>
<a name="ln1018">	uint32											flags) {</a>
<a name="ln1019"> </a>
<a name="ln1020">	PRINT((&quot;AudioFilterNode::LatencyChanged()\n&quot;));</a>
<a name="ln1021">	</a>
<a name="ln1022">	if(source != m_output.source) {</a>
<a name="ln1023">		PRINT((&quot;\tBad source.\n&quot;));</a>
<a name="ln1024">		return;</a>
<a name="ln1025">	}</a>
<a name="ln1026">	if(destination != m_output.destination) {</a>
<a name="ln1027">		PRINT((&quot;\tBad destination.\n&quot;));</a>
<a name="ln1028">		return;</a>
<a name="ln1029">	}</a>
<a name="ln1030">	</a>
<a name="ln1031">	m_downstreamLatency = newLatency;</a>
<a name="ln1032">	SetEventLatency(m_downstreamLatency + m_processingLatency);</a>
<a name="ln1033">	</a>
<a name="ln1034">	if(m_input.source != media_source::null) {</a>
<a name="ln1035">		// pass new latency upstream</a>
<a name="ln1036">		status_t err = SendLatencyChange(</a>
<a name="ln1037">			m_input.source,</a>
<a name="ln1038">			m_input.destination,</a>
<a name="ln1039">			EventLatency() + SchedulingLatency());</a>
<a name="ln1040">		if(err &lt; B_OK)</a>
<a name="ln1041">			PRINT((&quot;\t!!! SendLatencyChange(): %s\n&quot;, strerror(err)));</a>
<a name="ln1042">	}</a>
<a name="ln1043">}</a>
<a name="ln1044"> </a>
<a name="ln1045">void AudioFilterNode::LateNoticeReceived(</a>
<a name="ln1046">	const media_source&amp;					source,</a>
<a name="ln1047">	bigtime_t										howLate,</a>
<a name="ln1048">	bigtime_t										tpWhen) {</a>
<a name="ln1049"> </a>
<a name="ln1050">	PRINT((&quot;AudioFilterNode::LateNoticeReceived()\n&quot;</a>
<a name="ln1051">		&quot;\thowLate == %&quot; B_PRIdBIGTIME &quot;\n&quot;</a>
<a name="ln1052">		&quot;\twhen    == %&quot; B_PRIdBIGTIME &quot;\n&quot;, howLate, tpWhen));</a>
<a name="ln1053">		</a>
<a name="ln1054">	if(source != m_output.source) {</a>
<a name="ln1055">		PRINT((&quot;\tBad source.\n&quot;));</a>
<a name="ln1056">		return;</a>
<a name="ln1057">	}</a>
<a name="ln1058"> </a>
<a name="ln1059">	if(m_input.source == media_source::null) {</a>
<a name="ln1060">		PRINT((&quot;\t!!! No input to blame.\n&quot;));</a>
<a name="ln1061">		return;</a>
<a name="ln1062">	}</a>
<a name="ln1063">	</a>
<a name="ln1064">	// +++++ check run mode?</a>
<a name="ln1065">	</a>
<a name="ln1066">	// pass the buck, since this node doesn't schedule buffer</a>
<a name="ln1067">	// production</a>
<a name="ln1068">	NotifyLateProducer(</a>
<a name="ln1069">		m_input.source,</a>
<a name="ln1070">		howLate,</a>
<a name="ln1071">		tpWhen);</a>
<a name="ln1072">}</a>
<a name="ln1073"> </a>
<a name="ln1074">// PrepareToConnect() is the second stage of format negotiations that happens</a>
<a name="ln1075">// inside BMediaRoster::Connect().  At this point, the consumer's AcceptFormat()</a>
<a name="ln1076">// method has been called, and that node has potentially changed the proposed</a>
<a name="ln1077">// format.  It may also have left wildcards in the format.  PrepareToConnect()</a>
<a name="ln1078">// *must* fully specialize the format before returning!</a>
<a name="ln1079"> </a>
<a name="ln1080">status_t AudioFilterNode::PrepareToConnect(</a>
<a name="ln1081">	const media_source&amp;					source,</a>
<a name="ln1082">	const media_destination&amp;		destination,</a>
<a name="ln1083">	media_format*								ioFormat,</a>
<a name="ln1084">	media_source*								outSource,</a>
<a name="ln1085">	char*												outName) {</a>
<a name="ln1086"> </a>
<a name="ln1087">	status_t err;</a>
<a name="ln1088">	char formatStr[256];</a>
<a name="ln1089">	string_for_format(*ioFormat, formatStr, 255);</a>
<a name="ln1090">	PRINT((&quot;AudioFilterNode::PrepareToConnect()\n&quot;</a>
<a name="ln1091">		&quot;\tproposed format: %s\n&quot;, formatStr));</a>
<a name="ln1092">	</a>
<a name="ln1093">	if(source != m_output.source) {</a>
<a name="ln1094">		PRINT((&quot;\tBad source.\n&quot;));</a>
<a name="ln1095">		return B_MEDIA_BAD_SOURCE;</a>
<a name="ln1096">	}</a>
<a name="ln1097">	if(m_output.destination != media_destination::null) {</a>
<a name="ln1098">		PRINT((&quot;\tAlready connected.\n&quot;));</a>
<a name="ln1099">		return B_MEDIA_ALREADY_CONNECTED;</a>
<a name="ln1100">	}</a>
<a name="ln1101">	</a>
<a name="ln1102">	if(ioFormat-&gt;type != B_MEDIA_RAW_AUDIO) {</a>
<a name="ln1103">		PRINT((&quot;\tBad format type.\n&quot;));</a>
<a name="ln1104">		return B_MEDIA_BAD_FORMAT;</a>
<a name="ln1105">	}</a>
<a name="ln1106"> </a>
<a name="ln1107">	// do a final validity check:</a>
<a name="ln1108">	media_format required;</a>
<a name="ln1109">	required.type = B_MEDIA_RAW_AUDIO;</a>
<a name="ln1110">	err = getRequiredOutputFormat(required);</a>
<a name="ln1111">	ASSERT(err == B_OK);</a>
<a name="ln1112">	</a>
<a name="ln1113">	err = validateProposedOutputFormat(</a>
<a name="ln1114">		required,	*ioFormat);</a>
<a name="ln1115"> </a>
<a name="ln1116">	if(err &lt; B_OK) {</a>
<a name="ln1117">		// no go</a>
<a name="ln1118">		return err;</a>
<a name="ln1119">	}</a>
<a name="ln1120">	</a>
<a name="ln1121">	// fill in wildcards</a>
<a name="ln1122">	specializeOutputFormat(*ioFormat);</a>
<a name="ln1123">	</a>
<a name="ln1124">	string_for_format(*ioFormat, formatStr, 255);</a>
<a name="ln1125">	PRINT((&quot;FINAL FORMAT: %s\n&quot;, formatStr));</a>
<a name="ln1126"> </a>
<a name="ln1127">	// reserve the output</a>
<a name="ln1128">	m_output.destination = destination;</a>
<a name="ln1129">	m_output.format = *ioFormat;</a>
<a name="ln1130">	</a>
<a name="ln1131">	// pass back source &amp; output name</a>
<a name="ln1132">	*outSource = m_output.source;</a>
<a name="ln1133">	strncpy(outName, m_output.name, B_MEDIA_NAME_LENGTH);</a>
<a name="ln1134">	</a>
<a name="ln1135">	return B_OK;</a>
<a name="ln1136">}</a>
<a name="ln1137">		</a>
<a name="ln1138">status_t AudioFilterNode::SetBufferGroup(</a>
<a name="ln1139">	const media_source&amp;					source,</a>
<a name="ln1140">	BBufferGroup*								group) {</a>
<a name="ln1141"> </a>
<a name="ln1142">	PRINT((&quot;AudioFilterNode::SetBufferGroup()\n&quot;));</a>
<a name="ln1143">	if(source != m_output.source) {</a>
<a name="ln1144">		PRINT((&quot;\tBad source.\n&quot;));</a>
<a name="ln1145">		return B_MEDIA_BAD_SOURCE;</a>
<a name="ln1146">	}</a>
<a name="ln1147">	</a>
<a name="ln1148">//	if(m_input.source == media_source::null) {</a>
<a name="ln1149">//		PRINT((&quot;\tNo producer to send buffers to.\n&quot;));</a>
<a name="ln1150">//		return B_ERROR;</a>
<a name="ln1151">//	}</a>
<a name="ln1152">//	</a>
<a name="ln1153">//	// +++++ is this right?  buffer-group selection gets</a>
<a name="ln1154">//	//       all asynchronous and weird...</a>
<a name="ln1155">//	int32 changeTag;</a>
<a name="ln1156">//	return SetOutputBuffersFor(</a>
<a name="ln1157">//		m_input.source,</a>
<a name="ln1158">//		m_input.destination,</a>
<a name="ln1159">//		group,</a>
<a name="ln1160">//		0, &amp;changeTag);</a>
<a name="ln1161"> </a>
<a name="ln1162">	// do it [8sep99]</a>
<a name="ln1163">	if(m_bufferGroup)</a>
<a name="ln1164">		delete m_bufferGroup;</a>
<a name="ln1165">	m_bufferGroup = group;</a>
<a name="ln1166">	</a>
<a name="ln1167">	return B_OK;</a>
<a name="ln1168">}</a>
<a name="ln1169">	</a>
<a name="ln1170">status_t AudioFilterNode::SetPlayRate(</a>
<a name="ln1171">	int32												numerator,</a>
<a name="ln1172">	int32												denominator) {</a>
<a name="ln1173">	// not supported</a>
<a name="ln1174">	return B_ERROR;</a>
<a name="ln1175">}</a>
<a name="ln1176">	</a>
<a name="ln1177">status_t AudioFilterNode::VideoClippingChanged(</a>
<a name="ln1178">	const media_source&amp;					source,</a>
<a name="ln1179">	int16												numShorts,</a>
<a name="ln1180">	int16*											clipData,</a>
<a name="ln1181">	const media_video_display_info&amp; display,</a>
<a name="ln1182">	int32*											outFromChangeTag) {</a>
<a name="ln1183">	// not sane</a>
<a name="ln1184">	return B_ERROR;</a>
<a name="ln1185">}</a>
<a name="ln1186"> </a>
<a name="ln1187">// -------------------------------------------------------- //</a>
<a name="ln1188">// *** BControllable</a>
<a name="ln1189">// -------------------------------------------------------- //</a>
<a name="ln1190"> </a>
<a name="ln1191">status_t AudioFilterNode::GetParameterValue(</a>
<a name="ln1192">	int32												id,</a>
<a name="ln1193">	bigtime_t*									outLastChangeTime,</a>
<a name="ln1194">	void*												outValue,</a>
<a name="ln1195">	size_t*											ioSize) {</a>
<a name="ln1196">	</a>
<a name="ln1197">	ASSERT(m_parameterSet);</a>
<a name="ln1198">	return m_parameterSet-&gt;getValue(</a>
<a name="ln1199">		id,</a>
<a name="ln1200">		outLastChangeTime,</a>
<a name="ln1201">		outValue,</a>
<a name="ln1202">		ioSize);</a>
<a name="ln1203">}</a>
<a name="ln1204">	</a>
<a name="ln1205">void AudioFilterNode::SetParameterValue(</a>
<a name="ln1206">	int32												id,</a>
<a name="ln1207">	bigtime_t										changeTime,</a>
<a name="ln1208">	const void*									value,</a>
<a name="ln1209">	size_t											size) {</a>
<a name="ln1210"> </a>
<a name="ln1211">	// not running? set parameter now</a>
<a name="ln1212">	if(RunState() != B_STARTED) {</a>
<a name="ln1213">		ASSERT(m_parameterSet);</a>
<a name="ln1214">		m_parameterSet-&gt;setValue(</a>
<a name="ln1215">			id,</a>
<a name="ln1216">			changeTime,</a>
<a name="ln1217">			value,</a>
<a name="ln1218">			size);</a>
<a name="ln1219">		return;</a>
<a name="ln1220">	}</a>
<a name="ln1221">	</a>
<a name="ln1222">	// queue a parameter-change event</a>
<a name="ln1223"> </a>
<a name="ln1224">	if(size &gt; 64) { // +++++ hard-coded limitation in media_timed_event</a>
<a name="ln1225">		DEBUGGER((</a>
<a name="ln1226">			&quot;!!! AudioFilterNode::SetParameterValue(): parameter data too large\n&quot;));</a>
<a name="ln1227">	}</a>
<a name="ln1228">	</a>
<a name="ln1229">	media_timed_event ev(</a>
<a name="ln1230">		changeTime,</a>
<a name="ln1231">		BTimedEventQueue::B_PARAMETER,</a>
<a name="ln1232">		0,</a>
<a name="ln1233">		BTimedEventQueue::B_NO_CLEANUP,</a>
<a name="ln1234">		size,</a>
<a name="ln1235">		id,</a>
<a name="ln1236">		(char*)value, size);</a>
<a name="ln1237">	EventQueue()-&gt;AddEvent(ev);	</a>
<a name="ln1238">}</a>
<a name="ln1239"> </a>
<a name="ln1240">// -------------------------------------------------------- //</a>
<a name="ln1241">// *** IAudioOpHost</a>
<a name="ln1242">// -------------------------------------------------------- //</a>
<a name="ln1243"> </a>
<a name="ln1244">IParameterSet* AudioFilterNode::parameterSet() const {</a>
<a name="ln1245">	return m_parameterSet;</a>
<a name="ln1246">}</a>
<a name="ln1247"> </a>
<a name="ln1248">// -------------------------------------------------------- //</a>
<a name="ln1249">// HandleEvent() impl.</a>
<a name="ln1250">// -------------------------------------------------------- //</a>
<a name="ln1251"> </a>
<a name="ln1252">void AudioFilterNode::handleParameterEvent(</a>
<a name="ln1253">	const media_timed_event*		event) {</a>
<a name="ln1254">	</a>
<a name="ln1255">	// retrieve encoded parameter data</a>
<a name="ln1256">	void* value = (void*)event-&gt;user_data;</a>
<a name="ln1257">	int32 id = event-&gt;bigdata;</a>
<a name="ln1258">	size_t size = event-&gt;data;</a>
<a name="ln1259">	bigtime_t changeTime = event-&gt;event_time;</a>
<a name="ln1260">	status_t err;</a>
<a name="ln1261">	</a>
<a name="ln1262">	// hand to parameter set</a>
<a name="ln1263">	ASSERT(m_parameterSet);</a>
<a name="ln1264">	err = m_parameterSet-&gt;setValue(id, changeTime, value, size);</a>
<a name="ln1265">	</a>
<a name="ln1266">	if(err &lt; B_OK) {</a>
<a name="ln1267">		PRINT((</a>
<a name="ln1268">			&quot;* AudioFilterNode::handleParameterEvent(): m_parameterSet-&gt;SetValue() failed:\n&quot;</a>
<a name="ln1269">			&quot;  %s\n&quot;, strerror(err)));</a>
<a name="ln1270">	}</a>
<a name="ln1271">}</a>
<a name="ln1272">		</a>
<a name="ln1273">void AudioFilterNode::handleStartEvent(</a>
<a name="ln1274">	const media_timed_event*		event) {</a>
<a name="ln1275">	PRINT((&quot;AudioFilterNode::handleStartEvent\n&quot;));</a>
<a name="ln1276"> </a>
<a name="ln1277">	// initialize the filter</a>
<a name="ln1278">	ASSERT(m_op);</a>
<a name="ln1279">	m_op-&gt;init();</a>
<a name="ln1280">}</a>
<a name="ln1281">		</a>
<a name="ln1282">void AudioFilterNode::handleStopEvent(</a>
<a name="ln1283">	const media_timed_event*		event) {</a>
<a name="ln1284"> </a>
<a name="ln1285">	PRINT((&quot;AudioFilterNode::handleStopEvent\n&quot;));</a>
<a name="ln1286">	// +++++</a>
<a name="ln1287">}</a>
<a name="ln1288">		</a>
<a name="ln1289">void AudioFilterNode::ignoreEvent(</a>
<a name="ln1290">	const media_timed_event*		event) {</a>
<a name="ln1291"> </a>
<a name="ln1292">	PRINT((&quot;AudioFilterNode::ignoreEvent\n&quot;));</a>
<a name="ln1293">}</a>
<a name="ln1294"> </a>
<a name="ln1295">// -------------------------------------------------------- //</a>
<a name="ln1296">// *** internal operations</a>
<a name="ln1297">// -------------------------------------------------------- //</a>
<a name="ln1298"> </a>
<a name="ln1299">status_t </a>
<a name="ln1300">AudioFilterNode::prepareFormatChange(const media_format &amp;newFormat)</a>
<a name="ln1301">{</a>
<a name="ln1302">	media_format required;</a>
<a name="ln1303">	required.type = B_MEDIA_RAW_AUDIO;</a>
<a name="ln1304">	status_t err = getRequiredOutputFormat(required);</a>
<a name="ln1305">	ASSERT(err == B_OK);</a>
<a name="ln1306">	</a>
<a name="ln1307">	media_format proposed = newFormat;</a>
<a name="ln1308">	err = validateProposedOutputFormat(</a>
<a name="ln1309">		required,</a>
<a name="ln1310">		proposed);</a>
<a name="ln1311">	return err;</a>
<a name="ln1312">}</a>
<a name="ln1313"> </a>
<a name="ln1314">void </a>
<a name="ln1315">AudioFilterNode::doFormatChange(const media_format &amp;newFormat)</a>
<a name="ln1316">{</a>
<a name="ln1317">	m_output.format = newFormat;</a>
<a name="ln1318">	updateOperation();</a>
<a name="ln1319">}</a>
<a name="ln1320"> </a>
<a name="ln1321"> </a>
<a name="ln1322">// create and register a parameter web</a>
<a name="ln1323">void AudioFilterNode::initParameterWeb() {</a>
<a name="ln1324">	ASSERT(m_parameterSet);</a>
<a name="ln1325">	</a>
<a name="ln1326">	BParameterWeb* web = new BParameterWeb();</a>
<a name="ln1327">	BString groupName = Name();</a>
<a name="ln1328">	groupName &lt;&lt; &quot; Parameters&quot;;</a>
<a name="ln1329">	BParameterGroup* group = web-&gt;MakeGroup(groupName.String());</a>
<a name="ln1330">	m_parameterSet-&gt;populateGroup(group);</a>
<a name="ln1331">	</a>
<a name="ln1332">	SetParameterWeb(web);</a>
<a name="ln1333">}</a>
<a name="ln1334"> </a>
<a name="ln1335">// [re-]initialize operation if necessary</a>
<a name="ln1336">void AudioFilterNode::updateOperation() {</a>
<a name="ln1337"> </a>
<a name="ln1338">	if(m_input.source == media_source::null ||</a>
<a name="ln1339">		m_output.destination == media_destination::null)</a>
<a name="ln1340">		// not fully connected; nothing to do</a>
<a name="ln1341">		return;</a>
<a name="ln1342">	</a>
<a name="ln1343">	// ask the factory for an operation</a>
<a name="ln1344">	ASSERT(m_opFactory);</a>
<a name="ln1345">	IAudioOp* op = m_opFactory-&gt;createOp(</a>
<a name="ln1346">		this,</a>
<a name="ln1347">		m_input.format.u.raw_audio,</a>
<a name="ln1348">		m_output.format.u.raw_audio);</a>
<a name="ln1349">	if(!op) {</a>
<a name="ln1350">		PRINT((</a>
<a name="ln1351">			&quot;!!! AudioFilterNode::updateOperation(): no operation created!\n&quot;));</a>
<a name="ln1352">			</a>
<a name="ln1353">		// clean up existing operation</a>
<a name="ln1354">		delete m_op;</a>
<a name="ln1355">		m_op = 0;</a>
<a name="ln1356">		return;</a>
<a name="ln1357">	}</a>
<a name="ln1358">	</a>
<a name="ln1359">	// install new operation</a>
<a name="ln1360">	op-&gt;replace(m_op);</a>
<a name="ln1361">	m_op = op;</a>
<a name="ln1362">	</a>
<a name="ln1363">	// do performance tests (what if I'm running? +++++)</a>
<a name="ln1364"> </a>
<a name="ln1365">	m_processingLatency = calcProcessingLatency();</a>
<a name="ln1366">	PRINT((&quot;\tprocessing latency = %&quot; B_PRIdBIGTIME &quot;\n&quot;, m_processingLatency));</a>
<a name="ln1367">	</a>
<a name="ln1368">	// store summed latency</a>
<a name="ln1369">	SetEventLatency(m_downstreamLatency + m_processingLatency);</a>
<a name="ln1370">	</a>
<a name="ln1371">	// pass new latency upstream</a>
<a name="ln1372">	status_t err = SendLatencyChange(</a>
<a name="ln1373">		m_input.source,</a>
<a name="ln1374">		m_input.destination,</a>
<a name="ln1375">		EventLatency() + SchedulingLatency());</a>
<a name="ln1376">	if(err &lt; B_OK)</a>
<a name="ln1377">		PRINT((&quot;\t!!! SendLatencyChange(): %s\n&quot;, strerror(err)));</a>
<a name="ln1378">}</a>
<a name="ln1379"> </a>
<a name="ln1380"> </a>
<a name="ln1381">// create or discard buffer group if necessary</a>
<a name="ln1382">void AudioFilterNode::updateBufferGroup() {</a>
<a name="ln1383"> </a>
<a name="ln1384">	status_t err;</a>
<a name="ln1385">	</a>
<a name="ln1386">	size_t inputSize = bytes_per_frame(m_input.format.u.raw_audio);</a>
<a name="ln1387">	size_t outputSize = bytes_per_frame(m_output.format.u.raw_audio);</a>
<a name="ln1388">	</a>
<a name="ln1389">	if(m_input.source == media_source::null ||</a>
<a name="ln1390">		m_output.destination == media_destination::null ||</a>
<a name="ln1391">		inputSize &gt;= outputSize) {</a>
<a name="ln1392"> </a>
<a name="ln1393">		PRINT((&quot;###### NO BUFFER GROUP NEEDED\n&quot;));</a>
<a name="ln1394">		</a>
<a name="ln1395">		// no internal buffer group needed</a>
<a name="ln1396">		if(m_bufferGroup) {</a>
<a name="ln1397">			// does this block? +++++</a>
<a name="ln1398">			delete m_bufferGroup;</a>
<a name="ln1399">			m_bufferGroup = 0;</a>
<a name="ln1400">		}</a>
<a name="ln1401">		return;</a>
<a name="ln1402">	}</a>
<a name="ln1403">	</a>
<a name="ln1404">	int32 bufferCount = EventLatency() / BufferDuration() + 1 + 1;</a>
<a name="ln1405">	</a>
<a name="ln1406">	// +++++</a>
<a name="ln1407">	// [e.moon 27sep99] this is a reasonable number of buffers,</a>
<a name="ln1408">	// but it fails with looped file-player node in BeOS 4.5.2.</a>
<a name="ln1409">	//</a>
<a name="ln1410">	if(bufferCount &lt; 5)</a>
<a name="ln1411">		bufferCount = 5;</a>
<a name="ln1412">//	if(bufferCount &lt; 3)</a>
<a name="ln1413">//		bufferCount = 3;</a>
<a name="ln1414">		</a>
<a name="ln1415">	if(m_bufferGroup) {</a>
<a name="ln1416"> </a>
<a name="ln1417">		// is the current group sufficient?</a>
<a name="ln1418">		int32 curBufferCount;</a>
<a name="ln1419">		err = m_bufferGroup-&gt;CountBuffers(&amp;curBufferCount);</a>
<a name="ln1420">		if(err == B_OK &amp;&amp; curBufferCount &gt;= bufferCount) {		</a>
<a name="ln1421">			BBuffer* buf = m_bufferGroup-&gt;RequestBuffer(</a>
<a name="ln1422">				outputSize, -1);</a>
<a name="ln1423">		</a>
<a name="ln1424">			if(buf) {</a>
<a name="ln1425">				// yup</a>
<a name="ln1426">				buf-&gt;Recycle();</a>
<a name="ln1427">				return;</a>
<a name="ln1428">			}</a>
<a name="ln1429">		}</a>
<a name="ln1430"> </a>
<a name="ln1431">		// nope, delete it to make way for the new one</a>
<a name="ln1432">		delete m_bufferGroup;</a>
<a name="ln1433">		m_bufferGroup = 0;		</a>
<a name="ln1434">	}</a>
<a name="ln1435">	</a>
<a name="ln1436">	// create buffer group</a>
<a name="ln1437">	PRINT((</a>
<a name="ln1438">		&quot;##### AudioFilterNode::updateBufferGroup():\n&quot;</a>
<a name="ln1439">		&quot;##### creating %&quot; B_PRId32 &quot; buffers of size %&quot; B_PRIuSIZE &quot;\n&quot;,</a>
<a name="ln1440">		bufferCount, m_output.format.u.raw_audio.buffer_size));</a>
<a name="ln1441"> </a>
<a name="ln1442">	m_bufferGroup = new BBufferGroup(</a>
<a name="ln1443">		m_output.format.u.raw_audio.buffer_size,</a>
<a name="ln1444">		bufferCount);</a>
<a name="ln1445">}</a>
<a name="ln1446"> </a>
<a name="ln1447"> </a>
<a name="ln1448">// figure processing latency by doing 'dry runs' of processBuffer()</a>
<a name="ln1449">bigtime_t AudioFilterNode::calcProcessingLatency() {</a>
<a name="ln1450"> </a>
<a name="ln1451">	PRINT((&quot;AudioFilterNode::calcProcessingLatency()\n&quot;));</a>
<a name="ln1452">	</a>
<a name="ln1453">	ASSERT(m_input.source != media_source::null);</a>
<a name="ln1454">	ASSERT(m_output.destination != media_destination::null);</a>
<a name="ln1455">	ASSERT(m_op);</a>
<a name="ln1456"> </a>
<a name="ln1457">	// initialize filter</a>
<a name="ln1458">	m_op-&gt;init();</a>
<a name="ln1459"> </a>
<a name="ln1460">	size_t maxSize = max_c(</a>
<a name="ln1461">		m_input.format.u.raw_audio.buffer_size,</a>
<a name="ln1462">		m_output.format.u.raw_audio.buffer_size);</a>
<a name="ln1463"> </a>
<a name="ln1464">	// allocate a temporary buffer group</a>
<a name="ln1465">	BBufferGroup* testGroup = new BBufferGroup(</a>
<a name="ln1466">		maxSize, 1);</a>
<a name="ln1467">	</a>
<a name="ln1468">	// fetch a buffer big enough for in-place processing</a>
<a name="ln1469">	BBuffer* buffer = testGroup-&gt;RequestBuffer(</a>
<a name="ln1470">		maxSize, -1);</a>
<a name="ln1471">	ASSERT(buffer);</a>
<a name="ln1472">	</a>
<a name="ln1473">	buffer-&gt;Header()-&gt;type = B_MEDIA_RAW_AUDIO;</a>
<a name="ln1474">	buffer-&gt;Header()-&gt;size_used = m_input.format.u.raw_audio.buffer_size;</a>
<a name="ln1475">	</a>
<a name="ln1476">	// run the test</a>
<a name="ln1477">	bigtime_t preTest = system_time();</a>
<a name="ln1478">	processBuffer(buffer, buffer);</a>
<a name="ln1479">	bigtime_t elapsed = system_time()-preTest;</a>
<a name="ln1480">	</a>
<a name="ln1481">	// clean up</a>
<a name="ln1482">	buffer-&gt;Recycle();</a>
<a name="ln1483">	delete testGroup;</a>
<a name="ln1484"> </a>
<a name="ln1485">	// reset filter state</a>
<a name="ln1486">	m_op-&gt;init();</a>
<a name="ln1487"> </a>
<a name="ln1488">	return elapsed;// + 100000LL;</a>
<a name="ln1489">}</a>
<a name="ln1490">	</a>
<a name="ln1491">// filter buffer data; inputBuffer and outputBuffer may be identical!</a>
<a name="ln1492"> </a>
<a name="ln1493">void AudioFilterNode::processBuffer(</a>
<a name="ln1494">	BBuffer*										inputBuffer,</a>
<a name="ln1495">	BBuffer*										outputBuffer) {</a>
<a name="ln1496"> </a>
<a name="ln1497">	ASSERT(inputBuffer);</a>
<a name="ln1498">	ASSERT(outputBuffer);</a>
<a name="ln1499">	ASSERT(m_op);</a>
<a name="ln1500"> </a>
<a name="ln1501">	// create wrapper objects</a>
<a name="ln1502">	AudioBuffer input(m_input.format.u.raw_audio, inputBuffer);</a>
<a name="ln1503">	AudioBuffer output(m_output.format.u.raw_audio, outputBuffer);</a>
<a name="ln1504"> </a>
<a name="ln1505">	double sourceOffset = 0.0;</a>
<a name="ln1506">	uint32 destinationOffset = 0L;</a>
<a name="ln1507"> </a>
<a name="ln1508">	// when is the first frame due to be consumed?</a>
<a name="ln1509">	bigtime_t startTime = outputBuffer-&gt;Header()-&gt;start_time;</a>
<a name="ln1510">	// when is the next frame to be produced going to be consumed?</a>
<a name="ln1511">	bigtime_t targetTime = startTime;</a>
<a name="ln1512">	// when will the first frame of the next buffer be consumed?</a>
<a name="ln1513">	bigtime_t endTime = startTime + BufferDuration();</a>
<a name="ln1514">	</a>
<a name="ln1515">	uint32 framesRemaining = input.frames();</a>
<a name="ln1516">	while(framesRemaining) {</a>
<a name="ln1517"> </a>
<a name="ln1518">		// handle all events occurring before targetTime</a>
<a name="ln1519">		// +++++</a>
<a name="ln1520">		</a>
<a name="ln1521">		bigtime_t nextEventTime = endTime;</a>
<a name="ln1522">		</a>
<a name="ln1523">		// look for next event occurring before endTime</a>
<a name="ln1524">		// +++++</a>
<a name="ln1525">		</a>
<a name="ln1526">		// process up to found event, if any, or to end of buffer</a>
<a name="ln1527">		</a>
<a name="ln1528">		int64 toProcess = frames_for_duration(output.format(), nextEventTime - targetTime);</a>
<a name="ln1529"> </a>
<a name="ln1530">		ASSERT(toProcess &gt; 0);</a>
<a name="ln1531"> </a>
<a name="ln1532">		uint32 processed = m_op-&gt;process(</a>
<a name="ln1533">			input, output, sourceOffset, destinationOffset, (uint32)toProcess, targetTime);</a>
<a name="ln1534">		if(processed &lt; toProcess) {</a>
<a name="ln1535">			// +++++ in offline mode this will have to request additional buffer(s), right?</a>
<a name="ln1536">			PRINT((</a>
<a name="ln1537">				&quot;*** AudioFilterNode::processBuffer(): insufficient frames filled\n&quot;));</a>
<a name="ln1538">		}</a>
<a name="ln1539">			</a>
<a name="ln1540">		if(toProcess &gt; framesRemaining)</a>
<a name="ln1541">			framesRemaining = 0;</a>
<a name="ln1542">		else</a>
<a name="ln1543">			framesRemaining -= toProcess;</a>
<a name="ln1544">			</a>
<a name="ln1545">		// advance target time</a>
<a name="ln1546">		targetTime = nextEventTime; // +++++ might this drift from the real frame offset?</a>
<a name="ln1547">	}</a>
<a name="ln1548">	</a>
<a name="ln1549">	outputBuffer-&gt;Header()-&gt;size_used = input.frames() * bytes_per_frame(m_output.format.u.raw_audio);</a>
<a name="ln1550">//	PRINT((&quot;### output size: %ld\n&quot;, outputBuffer-&gt;Header()-&gt;size_used));</a>
<a name="ln1551">}</a>
<a name="ln1552"> </a>
<a name="ln1553">// END -- AudioFilterNode.cpp --</a>

</code></pre>
<div class="balloon" rel="190"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
