
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>CommandActuators.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 1999-2009 Haiku, Inc. All rights reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Jeremy Friesner</a>
<a name="ln7"> *		Fredrik Mod√©en</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10"> </a>
<a name="ln11">#include &quot;CommandActuators.h&quot;</a>
<a name="ln12"> </a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;stdio.h&gt;</a>
<a name="ln15">#include &lt;stdlib.h&gt;</a>
<a name="ln16">#include &lt;strings.h&gt;</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;String.h&gt;</a>
<a name="ln19">#include &lt;Roster.h&gt;</a>
<a name="ln20">#include &lt;Alert.h&gt;</a>
<a name="ln21">#include &lt;Screen.h&gt;</a>
<a name="ln22">#include &lt;Rect.h&gt;</a>
<a name="ln23">#include &lt;View.h&gt;</a>
<a name="ln24">#include &lt;Directory.h&gt;</a>
<a name="ln25">#include &lt;Entry.h&gt;</a>
<a name="ln26">#include &lt;List.h&gt;</a>
<a name="ln27">#include &lt;Beep.h&gt;</a>
<a name="ln28"> </a>
<a name="ln29"> </a>
<a name="ln30">#include &quot;ParseCommandLine.h&quot;</a>
<a name="ln31">#include &quot;KeyInfos.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">#define IS_KEY_DOWN(msg) ((msg-&gt;what == B_KEY_DOWN) \</a>
<a name="ln34">	|| (msg-&gt;what == B_UNMAPPED_KEY_DOWN))</a>
<a name="ln35"> </a>
<a name="ln36"> </a>
<a name="ln37">// factory function</a>
<a name="ln38">CommandActuator*</a>
<a name="ln39">CreateCommandActuator(const char* command)</a>
<a name="ln40">{</a>
<a name="ln41">	CommandActuator* act = NULL;</a>
<a name="ln42">	int32 argc;</a>
<a name="ln43">	char** argv = ParseArgvFromString(command, argc);</a>
<a name="ln44">	if (command[0] == '*') {</a>
<a name="ln45">		if (argc &gt; 0) {</a>
<a name="ln46">			char* c = argv[0] + 1;</a>
<a name="ln47">			if (strcmp(c, &quot;InsertString&quot;) == 0)</a>
<a name="ln48">				act = new KeyStrokeSequenceCommandActuator(argc, argv);</a>
<a name="ln49">			else if (strcmp(c, &quot;MoveMouse&quot;) == 0)</a>
<a name="ln50">				act = new MoveMouseByCommandActuator(argc, argv);</a>
<a name="ln51">			else if (strcmp(c, &quot;MoveMouseTo&quot;) == 0)</a>
<a name="ln52">				act = new MoveMouseToCommandActuator(argc, argv);</a>
<a name="ln53">			else if (strcmp(c, &quot;MouseButton&quot;) == 0)</a>
<a name="ln54">				act = new MouseButtonCommandActuator(argc, argv);</a>
<a name="ln55">			else if (strcmp(c, &quot;LaunchHandler&quot;) == 0)</a>
<a name="ln56">				act = new MIMEHandlerCommandActuator(argc, argv);</a>
<a name="ln57">			else if (strcmp(c, &quot;Multi&quot;) == 0)</a>
<a name="ln58">				act = new MultiCommandActuator(argc, argv);</a>
<a name="ln59">			else if (strcmp(c, &quot;MouseDown&quot;) == 0)</a>
<a name="ln60">				act = new MouseDownCommandActuator(argc, argv);</a>
<a name="ln61">			else if (strcmp(c, &quot;MouseUp&quot;) == 0)</a>
<a name="ln62">				act = new MouseUpCommandActuator(argc, argv);</a>
<a name="ln63">			else if (strcmp(c, &quot;SendMessage&quot;) == 0)</a>
<a name="ln64">				act = new SendMessageCommandActuator(argc, argv);</a>
<a name="ln65">			else</a>
<a name="ln66">				act = new BeepCommandActuator(argc, argv);</a>
<a name="ln67">		}</a>
<a name="ln68">	} else</a>
<a name="ln69">		act = new LaunchCommandActuator(argc, argv);</a>
<a name="ln70"> </a>
<a name="ln71">	FreeArgv(argv);</a>
<a name="ln72">	return act;</a>
<a name="ln73">}</a>
<a name="ln74"> </a>
<a name="ln75"> </a>
<a name="ln76">//	#pragma mark - CommandActuator</a>
<a name="ln77"> </a>
<a name="ln78"> </a>
<a name="ln79">CommandActuator::CommandActuator(int32 argc, char** argv)</a>
<a name="ln80">{</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83"> </a>
<a name="ln84">CommandActuator::CommandActuator(BMessage* from)</a>
<a name="ln85">	:</a>
<a name="ln86">	BArchivable(from)</a>
<a name="ln87">{</a>
<a name="ln88">}</a>
<a name="ln89"> </a>
<a name="ln90"> </a>
<a name="ln91">status_t</a>
<a name="ln92">CommandActuator::Archive(BMessage* into, bool deep) const</a>
<a name="ln93">{</a>
<a name="ln94">	status_t ret = BArchivable::Archive(into, deep);</a>
<a name="ln95">	return ret;</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98"> </a>
<a name="ln99">//	#pragma mark - LaunchCommandActuator</a>
<a name="ln100"> </a>
<a name="ln101"> </a>
<a name="ln102">LaunchCommandActuator::LaunchCommandActuator(int32 argc, char** argv)</a>
<a name="ln103">	:</a>
<a name="ln104">	CommandActuator(argc, argv),</a>
<a name="ln105">	fArgv(CloneArgv(argv)),</a>
<a name="ln106">	fArgc(argc)</a>
<a name="ln107">{</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110"> </a>
<a name="ln111">LaunchCommandActuator::LaunchCommandActuator(BMessage* from)</a>
<a name="ln112">	:</a>
<a name="ln113">	CommandActuator(from)</a>
<a name="ln114">{</a>
<a name="ln115">	BList argList;</a>
<a name="ln116">	const char* temp;</a>
<a name="ln117">	int idx = 0;</a>
<a name="ln118">	while (from-&gt;FindString(&quot;largv&quot;, idx++, &amp;temp) == B_OK) {</a>
<a name="ln119">		if (temp) {</a>
<a name="ln120">			char* copy = new char[strlen(temp) + 1];</a>
<a name="ln121">			strcpy(copy, temp);</a>
<a name="ln122">			argList.AddItem(copy);</a>
<a name="ln123">		}</a>
<a name="ln124">	}</a>
<a name="ln125"> </a>
<a name="ln126">	fArgc = argList.CountItems();</a>
<a name="ln127">	fArgv = new char*[fArgc+ 1];</a>
<a name="ln128"> </a>
<a name="ln129">	for (int i = 0; i &lt; fArgc; i++)</a>
<a name="ln130">		fArgv[i] = (char*) argList.ItemAt(i);</a>
<a name="ln131"> </a>
<a name="ln132">	fArgv[fArgc] = NULL;// terminate the array</a>
<a name="ln133">}</a>
<a name="ln134"> </a>
<a name="ln135"> </a>
<a name="ln136">LaunchCommandActuator::~LaunchCommandActuator()</a>
<a name="ln137">{</a>
<a name="ln138">	FreeArgv(fArgv);</a>
<a name="ln139">}</a>
<a name="ln140"> </a>
<a name="ln141"> </a>
<a name="ln142">filter_result</a>
<a name="ln143">LaunchCommandActuator::KeyEvent(const BMessage* keyMessage, BList* outList,</a>
<a name="ln144">	void** setAsyncData, BMessage* mouseMessage)</a>
<a name="ln145">{</a>
<a name="ln146">	if (IS_KEY_DOWN(keyMessage)) {</a>
<a name="ln147">		// cause KeyEventAsync() to be called asynchronously</a>
<a name="ln148">		*setAsyncData = (void*) true;</a>
<a name="ln149">	}</a>
<a name="ln150">	return B_SKIP_MESSAGE;</a>
<a name="ln151">}</a>
<a name="ln152"> </a>
<a name="ln153"> </a>
<a name="ln154">status_t</a>
<a name="ln155">LaunchCommandActuator::Archive(BMessage* into, bool deep) const</a>
<a name="ln156">{</a>
<a name="ln157">	status_t ret = CommandActuator::Archive(into, deep);</a>
<a name="ln158"> </a>
<a name="ln159">	for (int i = 0; i &lt; fArgc; i++)</a>
<a name="ln160">		into-&gt;AddString(&quot;largv&quot;, fArgv[i]);</a>
<a name="ln161"> </a>
<a name="ln162">	return ret;</a>
<a name="ln163">}</a>
<a name="ln164"> </a>
<a name="ln165"> </a>
<a name="ln166">BArchivable*</a>
<a name="ln167">LaunchCommandActuator::Instantiate(BMessage* from)</a>
<a name="ln168">{</a>
<a name="ln169">	if (validate_instantiation(from, &quot;LaunchCommandActuator&quot;))</a>
<a name="ln170">		return new LaunchCommandActuator(from);</a>
<a name="ln171">	else</a>
<a name="ln172">		return NULL;</a>
<a name="ln173">}</a>
<a name="ln174"> </a>
<a name="ln175"> </a>
<a name="ln176">void</a>
<a name="ln177">LaunchCommandActuator::KeyEventAsync(const BMessage* keyMessage,</a>
<a name="ln178">	void* asyncData)</a>
<a name="ln179">{</a>
<a name="ln180">	if (be_roster == NULL)</a>
<a name="ln181">		return;</a>
<a name="ln182"> </a>
<a name="ln183">	status_t result = B_OK;</a>
<a name="ln184">	BString string;</a>
<a name="ln185">	if (fArgc &lt; 1)</a>
<a name="ln186">		string &lt;&lt; &quot;You didn't specify a command for this hotkey.&quot;;</a>
<a name="ln187">	else if ((result = LaunchCommand(fArgv, fArgc)) != B_OK) {</a>
<a name="ln188">		string &lt;&lt; &quot;Can't launch &quot; &lt;&lt; fArgv[0];</a>
<a name="ln189">		string &lt;&lt; &quot;, no such file exists.&quot;;</a>
<a name="ln190">		string &lt;&lt; &quot; Please check your Shortcuts settings.&quot;;</a>
<a name="ln191">	}</a>
<a name="ln192"> </a>
<a name="ln193">	if (fArgc &lt; 1 || result != B_OK) {</a>
<a name="ln194">		BAlert* alert = new BAlert(&quot;Shortcuts launcher error&quot;,</a>
<a name="ln195">			string.String(), &quot;OK&quot;);</a>
<a name="ln196">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln197">		alert-&gt;Go(NULL);</a>
<a name="ln198">	}</a>
<a name="ln199">}</a>
<a name="ln200"> </a>
<a name="ln201"> </a>
<a name="ln202">//	#pragma mark - MouseCommandActuator</a>
<a name="ln203"> </a>
<a name="ln204"> </a>
<a name="ln205">MouseCommandActuator::MouseCommandActuator(int32 argc, char** argv)</a>
<a name="ln206">	:</a>
<a name="ln207">	CommandActuator(argc, argv),</a>
<a name="ln208">	fWhichButtons(B_PRIMARY_MOUSE_BUTTON)</a>
<a name="ln209">{</a>
<a name="ln210">	if (argc &gt; 1) {</a>
<a name="ln211">		fWhichButtons = 0;</a>
<a name="ln212"> </a>
<a name="ln213">		for (int i = 1; i &lt; argc; i++) {</a>
<a name="ln214">			int buttonNumber = atoi(argv[i]);</a>
<a name="ln215"> </a>
<a name="ln216">			switch(buttonNumber) {</a>
<a name="ln217">				case 1:</a>
<a name="ln218">					fWhichButtons |= B_PRIMARY_MOUSE_BUTTON;</a>
<a name="ln219">				break;</a>
<a name="ln220">				case 2:</a>
<a name="ln221">					fWhichButtons |= B_SECONDARY_MOUSE_BUTTON;</a>
<a name="ln222">				break;</a>
<a name="ln223">				case 3:</a>
<a name="ln224">					fWhichButtons |= B_TERTIARY_MOUSE_BUTTON;</a>
<a name="ln225">				break;</a>
<a name="ln226">			}</a>
<a name="ln227">		}</a>
<a name="ln228">	}</a>
<a name="ln229">}</a>
<a name="ln230"> </a>
<a name="ln231"> </a>
<a name="ln232">MouseCommandActuator::MouseCommandActuator(BMessage* from)</a>
<a name="ln233">	:</a>
<a name="ln234">	CommandActuator(from),</a>
<a name="ln235">	fWhichButtons(B_PRIMARY_MOUSE_BUTTON)</a>
<a name="ln236">{</a>
<a name="ln237">	from-&gt;FindInt32(&quot;buttons&quot;, &amp;fWhichButtons);</a>
<a name="ln238">}</a>
<a name="ln239"> </a>
<a name="ln240"> </a>
<a name="ln241">MouseCommandActuator::~MouseCommandActuator()</a>
<a name="ln242">{</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245"> </a>
<a name="ln246">status_t</a>
<a name="ln247">MouseCommandActuator::Archive(BMessage* into, bool deep) const</a>
<a name="ln248">{</a>
<a name="ln249">	status_t ret = CommandActuator::Archive(into, deep);</a>
<a name="ln250">	into-&gt;AddInt32(&quot;buttons&quot;, fWhichButtons);</a>
<a name="ln251">	return ret;</a>
<a name="ln252">}</a>
<a name="ln253"> </a>
<a name="ln254"> </a>
<a name="ln255">int32</a>
<a name="ln256">MouseCommandActuator::_GetWhichButtons() const</a>
<a name="ln257">{</a>
<a name="ln258">	return fWhichButtons;</a>
<a name="ln259">}</a>
<a name="ln260"> </a>
<a name="ln261"> </a>
<a name="ln262">void</a>
<a name="ln263">MouseCommandActuator::_GenerateMouseButtonEvent(bool mouseDown,</a>
<a name="ln264">	const BMessage* keyMessage, BList* outList, BMessage* mouseMessage)</a>
<a name="ln265">{</a>
<a name="ln266">	BMessage* fakeMouse = new BMessage(*mouseMessage);</a>
<a name="ln267">	fakeMouse-&gt;what = mouseDown ? B_MOUSE_DOWN : B_MOUSE_UP;</a>
<a name="ln268"> </a>
<a name="ln269">	// Update the buttons to reflect which mouse buttons we are faking</a>
<a name="ln270">	fakeMouse-&gt;RemoveName(&quot;buttons&quot;);</a>
<a name="ln271"> </a>
<a name="ln272">	if (mouseDown)</a>
<a name="ln273">		fakeMouse-&gt;AddInt32(&quot;buttons&quot;, fWhichButtons);</a>
<a name="ln274"> </a>
<a name="ln275">	// Trey sez you gotta keep then &quot;when&quot;'s increasing if you want</a>
<a name="ln276">	// click &amp; drag to work!</a>
<a name="ln277">	int64 when;</a>
<a name="ln278"> </a>
<a name="ln279">	const BMessage* lastMessage;</a>
<a name="ln280">	if (outList-&gt;CountItems() &gt; 0) {</a>
<a name="ln281">		int32 last = outList-&gt;CountItems() - 1;</a>
<a name="ln282">		lastMessage = (const BMessage*)outList-&gt;ItemAt(last);</a>
<a name="ln283">	} else</a>
<a name="ln284">		lastMessage = keyMessage;</a>
<a name="ln285"> </a>
<a name="ln286">	if (lastMessage-&gt;FindInt64(&quot;when&quot;, &amp;when) == B_OK) {</a>
<a name="ln287">		when++;</a>
<a name="ln288">		fakeMouse-&gt;RemoveName(&quot;when&quot;);</a>
<a name="ln289">		fakeMouse-&gt;AddInt64(&quot;when&quot;, when);</a>
<a name="ln290">	}</a>
<a name="ln291"> </a>
<a name="ln292">	outList-&gt;AddItem(fakeMouse);</a>
<a name="ln293">}</a>
<a name="ln294"> </a>
<a name="ln295"> </a>
<a name="ln296">//	#pragma mark - MouseDownCommandActuator</a>
<a name="ln297"> </a>
<a name="ln298"> </a>
<a name="ln299">MouseDownCommandActuator::MouseDownCommandActuator(int32 argc, char** argv)</a>
<a name="ln300">	:</a>
<a name="ln301">	MouseCommandActuator(argc, argv)</a>
<a name="ln302">{</a>
<a name="ln303">}</a>
<a name="ln304"> </a>
<a name="ln305"> </a>
<a name="ln306">MouseDownCommandActuator::MouseDownCommandActuator(BMessage* from)</a>
<a name="ln307">	:</a>
<a name="ln308">	MouseCommandActuator(from)</a>
<a name="ln309">{</a>
<a name="ln310">}</a>
<a name="ln311"> </a>
<a name="ln312"> </a>
<a name="ln313">MouseDownCommandActuator::~MouseDownCommandActuator()</a>
<a name="ln314">{</a>
<a name="ln315">}</a>
<a name="ln316"> </a>
<a name="ln317"> </a>
<a name="ln318">filter_result</a>
<a name="ln319">MouseDownCommandActuator::KeyEvent(const BMessage* keyMessage, BList* outList,</a>
<a name="ln320">	void** setAsyncData, BMessage* mouseMessage)</a>
<a name="ln321">{</a>
<a name="ln322">	if (IS_KEY_DOWN(keyMessage))</a>
<a name="ln323">		_GenerateMouseButtonEvent(true, keyMessage, outList, mouseMessage);</a>
<a name="ln324"> </a>
<a name="ln325">	return B_DISPATCH_MESSAGE;</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328"> </a>
<a name="ln329">status_t</a>
<a name="ln330">MouseDownCommandActuator::Archive(BMessage* into, bool deep) const</a>
<a name="ln331">{</a>
<a name="ln332">	return MouseCommandActuator::Archive(into, deep);</a>
<a name="ln333">}</a>
<a name="ln334"> </a>
<a name="ln335"> </a>
<a name="ln336">BArchivable*</a>
<a name="ln337">MouseDownCommandActuator::Instantiate(BMessage* from)</a>
<a name="ln338">{</a>
<a name="ln339">	if (validate_instantiation(from, &quot;MouseDownCommandActuator&quot;))</a>
<a name="ln340">		return new MouseDownCommandActuator(from);</a>
<a name="ln341">	else</a>
<a name="ln342">		return NULL;</a>
<a name="ln343">}</a>
<a name="ln344"> </a>
<a name="ln345"> </a>
<a name="ln346">//	#pragma mark - MouseUpCommandActuator</a>
<a name="ln347"> </a>
<a name="ln348"> </a>
<a name="ln349">MouseUpCommandActuator::MouseUpCommandActuator(int32 argc, char** argv)</a>
<a name="ln350">	:</a>
<a name="ln351">	MouseCommandActuator(argc, argv)</a>
<a name="ln352">{</a>
<a name="ln353">}</a>
<a name="ln354"> </a>
<a name="ln355"> </a>
<a name="ln356">MouseUpCommandActuator::MouseUpCommandActuator(BMessage* from)</a>
<a name="ln357">	:</a>
<a name="ln358">	MouseCommandActuator(from)</a>
<a name="ln359">{</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362"> </a>
<a name="ln363">MouseUpCommandActuator::~MouseUpCommandActuator()</a>
<a name="ln364">{</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367"> </a>
<a name="ln368">filter_result</a>
<a name="ln369">MouseUpCommandActuator::KeyEvent(const BMessage* keyMessage, BList* outList,</a>
<a name="ln370">	void** setAsyncData, BMessage* mouseMessage)</a>
<a name="ln371">{</a>
<a name="ln372">	if (IS_KEY_DOWN(keyMessage))</a>
<a name="ln373">		_GenerateMouseButtonEvent(false, keyMessage, outList, mouseMessage);</a>
<a name="ln374"> </a>
<a name="ln375">	return B_DISPATCH_MESSAGE;</a>
<a name="ln376">}</a>
<a name="ln377"> </a>
<a name="ln378"> </a>
<a name="ln379">status_t</a>
<a name="ln380">MouseUpCommandActuator::Archive(BMessage* into, bool deep) const</a>
<a name="ln381">{</a>
<a name="ln382">	return MouseCommandActuator::Archive(into, deep);</a>
<a name="ln383">}</a>
<a name="ln384"> </a>
<a name="ln385"> </a>
<a name="ln386">BArchivable*</a>
<a name="ln387">MouseUpCommandActuator::Instantiate(BMessage* from)</a>
<a name="ln388">{</a>
<a name="ln389">	if (validate_instantiation(from, &quot;MouseUpCommandActuator&quot;))</a>
<a name="ln390">		return new MouseUpCommandActuator(from);</a>
<a name="ln391">	else</a>
<a name="ln392">		return NULL;</a>
<a name="ln393">}</a>
<a name="ln394"> </a>
<a name="ln395"> </a>
<a name="ln396">//	#pragma mark - MouseButtonCommandActuator</a>
<a name="ln397"> </a>
<a name="ln398"> </a>
<a name="ln399">MouseButtonCommandActuator::MouseButtonCommandActuator(int32 argc, char** argv)</a>
<a name="ln400">	:</a>
<a name="ln401">	MouseCommandActuator(argc, argv),</a>
<a name="ln402">	fKeyDown(false)</a>
<a name="ln403">{</a>
<a name="ln404">}</a>
<a name="ln405"> </a>
<a name="ln406"> </a>
<a name="ln407">MouseButtonCommandActuator::MouseButtonCommandActuator(BMessage* from)</a>
<a name="ln408">	:</a>
<a name="ln409">	MouseCommandActuator(from),</a>
<a name="ln410">	fKeyDown(false)</a>
<a name="ln411">{</a>
<a name="ln412">}</a>
<a name="ln413"> </a>
<a name="ln414"> </a>
<a name="ln415">MouseButtonCommandActuator::~MouseButtonCommandActuator()</a>
<a name="ln416">{</a>
<a name="ln417">}</a>
<a name="ln418"> </a>
<a name="ln419"> </a>
<a name="ln420">filter_result</a>
<a name="ln421">MouseButtonCommandActuator::KeyEvent(const BMessage* keyMessage, BList* outList,</a>
<a name="ln422">	void** setAsyncData, BMessage* mouseMessage)</a>
<a name="ln423">{</a>
<a name="ln424">	if (IS_KEY_DOWN(keyMessage) != fKeyDown) {</a>
<a name="ln425">		_GenerateMouseButtonEvent(IS_KEY_DOWN(keyMessage), keyMessage, outList,</a>
<a name="ln426">			mouseMessage);</a>
<a name="ln427">		fKeyDown = IS_KEY_DOWN(keyMessage);</a>
<a name="ln428"> </a>
<a name="ln429">		return B_DISPATCH_MESSAGE;</a>
<a name="ln430">	} else {</a>
<a name="ln431">		// This will handle key-repeats, which we don't want turned into lots</a>
<a name="ln432">		// of B_MOUSE_DOWN messages.</a>
<a name="ln433">		return B_SKIP_MESSAGE;</a>
<a name="ln434">	}</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437"> </a>
<a name="ln438">status_t</a>
<a name="ln439">MouseButtonCommandActuator::Archive(BMessage* into, bool deep) const</a>
<a name="ln440">{</a>
<a name="ln441">	return MouseCommandActuator::Archive(into, deep);</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444"> </a>
<a name="ln445">BArchivable*</a>
<a name="ln446">MouseButtonCommandActuator::Instantiate(BMessage* from)</a>
<a name="ln447">{</a>
<a name="ln448">	if (validate_instantiation(from, &quot;MouseButtonCommandActuator&quot;))</a>
<a name="ln449">		return new MouseButtonCommandActuator(from);</a>
<a name="ln450">	else</a>
<a name="ln451">		return NULL;</a>
<a name="ln452">}</a>
<a name="ln453"> </a>
<a name="ln454"> </a>
<a name="ln455">//	#pragma mark - KeyStrokeSequenceCommandActuator</a>
<a name="ln456"> </a>
<a name="ln457"> </a>
<a name="ln458">KeyStrokeSequenceCommandActuator::KeyStrokeSequenceCommandActuator(int32 argc,</a>
<a name="ln459">	char** argv)</a>
<a name="ln460">	:</a>
<a name="ln461">	CommandActuator(argc, argv)</a>
<a name="ln462">{</a>
<a name="ln463">	for (int s = 1; s &lt; argc; s++) {</a>
<a name="ln464">		fSequence.Append(argv[s]);</a>
<a name="ln465">		if (s &lt; argc - 1)</a>
<a name="ln466">			fSequence.Append(&quot; &quot;);</a>
<a name="ln467">	}</a>
<a name="ln468"> </a>
<a name="ln469">	// Find any insert-unicode-here sequences and replace them with spaces...</a>
<a name="ln470">	int32 nextStart;</a>
<a name="ln471">	while ((nextStart = fSequence.FindFirst(&quot;$$&quot;)) &gt;= 0) {</a>
<a name="ln472">		int32 nextEnd = fSequence.FindFirst(&quot;$$&quot;, nextStart + 2);</a>
<a name="ln473">		if (nextEnd &gt;= 0) {</a>
<a name="ln474">			uint32 customKey= 0;</a>
<a name="ln475">			int32 unicodeVal= 0;</a>
<a name="ln476">			uint32 customMods = 0;</a>
<a name="ln477">			BString sub;</a>
<a name="ln478">			fSequence.CopyInto(sub, nextStart + 2, nextEnd-(nextStart + 2));</a>
<a name="ln479">			sub.ToLower();</a>
<a name="ln480"> </a>
<a name="ln481">			if ((sub.FindFirst('-') &gt;= 0) || ((sub.Length() &gt; 0)</a>
<a name="ln482">				&amp;&amp; ((sub.String()[0] &lt; '0') || (sub.String()[0] &gt; '9')))) {</a>
<a name="ln483"> </a>
<a name="ln484">				const char* s = sub.String();</a>
<a name="ln485">				while (*s == '-') s++;// go past any initial dashes</a>
<a name="ln486"> </a>
<a name="ln487">				bool lastWasDash = true;</a>
<a name="ln488">				while (*s) {</a>
<a name="ln489">					if (lastWasDash) {</a>
<a name="ln490">						if (strncmp(s, &quot;shift&quot;,5) == 0)</a>
<a name="ln491">							customMods |=B_LEFT_SHIFT_KEY| B_SHIFT_KEY;</a>
<a name="ln492">						else if (strncmp(s, &quot;leftsh&quot;, 6) == 0)</a>
<a name="ln493">							customMods |=B_LEFT_SHIFT_KEY| B_SHIFT_KEY;</a>
<a name="ln494">						else if (strncmp(s, &quot;rightsh&quot;,7) == 0)</a>
<a name="ln495">							customMods |=B_RIGHT_SHIFT_KEY | B_SHIFT_KEY;</a>
<a name="ln496">						else if (strncmp(s, &quot;alt&quot;,3) == 0)</a>
<a name="ln497">							customMods |=B_LEFT_COMMAND_KEY| B_COMMAND_KEY;</a>
<a name="ln498">						else if (strncmp(s, &quot;leftalt&quot;,7) == 0)</a>
<a name="ln499">							customMods |=B_LEFT_COMMAND_KEY| B_COMMAND_KEY;</a>
<a name="ln500">						else if (strncmp(s, &quot;rightalt&quot;, 8) == 0)</a>
<a name="ln501">							customMods |=B_RIGHT_COMMAND_KEY | B_COMMAND_KEY;</a>
<a name="ln502">						else if (strncmp(s, &quot;com&quot;,3) == 0)</a>
<a name="ln503">							customMods |=B_LEFT_COMMAND_KEY| B_COMMAND_KEY;</a>
<a name="ln504">						else if (strncmp(s, &quot;leftcom&quot;,7) == 0)</a>
<a name="ln505">							customMods |=B_LEFT_COMMAND_KEY| B_COMMAND_KEY;</a>
<a name="ln506">						else if (strncmp(s, &quot;rightcom&quot;, 8) == 0)</a>
<a name="ln507">							customMods |=B_RIGHT_COMMAND_KEY | B_COMMAND_KEY;</a>
<a name="ln508">						else if (strncmp(s, &quot;con&quot;,3) == 0)</a>
<a name="ln509">							customMods |=B_LEFT_CONTROL_KEY| B_CONTROL_KEY;</a>
<a name="ln510">						else if (strncmp(s, &quot;leftcon&quot;,7) == 0)</a>
<a name="ln511">							customMods |=B_LEFT_CONTROL_KEY| B_CONTROL_KEY;</a>
<a name="ln512">						else if (strncmp(s, &quot;rightcon&quot;, 8) == 0)</a>
<a name="ln513">							customMods |=B_RIGHT_CONTROL_KEY | B_CONTROL_KEY;</a>
<a name="ln514">						else if (strncmp(s, &quot;win&quot;,3) == 0)</a>
<a name="ln515">							customMods |=B_LEFT_OPTION_KEY | B_OPTION_KEY;</a>
<a name="ln516">						else if (strncmp(s, &quot;leftwin&quot;,7) == 0)</a>
<a name="ln517">							customMods |=B_LEFT_OPTION_KEY | B_OPTION_KEY;</a>
<a name="ln518">						else if (strncmp(s, &quot;rightwin&quot;, 8) == 0)</a>
<a name="ln519">							customMods |=B_RIGHT_OPTION_KEY| B_OPTION_KEY;</a>
<a name="ln520">						else if (strncmp(s, &quot;opt&quot;,3) == 0)</a>
<a name="ln521">							customMods |=B_LEFT_OPTION_KEY | B_OPTION_KEY;</a>
<a name="ln522">						else if (strncmp(s, &quot;leftopt&quot;,7) == 0)</a>
<a name="ln523">							customMods |=B_LEFT_OPTION_KEY | B_OPTION_KEY;</a>
<a name="ln524">						else if (strncmp(s, &quot;rightopt&quot;, 8) == 0)</a>
<a name="ln525">							customMods |=B_RIGHT_OPTION_KEY| B_OPTION_KEY;</a>
<a name="ln526">						else if (strncmp(s, &quot;menu&quot;, 4) == 0)</a>
<a name="ln527">							customMods |=B_MENU_KEY;</a>
<a name="ln528">						else if (strncmp(s, &quot;caps&quot;, 4) == 0)</a>
<a name="ln529">							customMods |=B_CAPS_LOCK;</a>
<a name="ln530">						else if (strncmp(s, &quot;scroll&quot;, 6) == 0)</a>
<a name="ln531">							customMods |=B_SCROLL_LOCK;</a>
<a name="ln532">						else if (strncmp(s, &quot;num&quot;,3) == 0)</a>
<a name="ln533">							customMods |=B_NUM_LOCK;</a>
<a name="ln534">						else if (customKey == 0) {</a>
<a name="ln535">							BString arg = s;</a>
<a name="ln536">							int32 dashIdx = arg.FindFirst('-');</a>
<a name="ln537"> </a>
<a name="ln538">							if (dashIdx &gt;= 0)</a>
<a name="ln539">								arg.Truncate(dashIdx);</a>
<a name="ln540"> </a>
<a name="ln541">							uint32 key = (uint32)FindKeyCode(arg.String());</a>
<a name="ln542"> </a>
<a name="ln543">							if (key &gt; 0) {</a>
<a name="ln544">								customKey = key;</a>
<a name="ln545">								const char* u = GetKeyUTF8(key);</a>
<a name="ln546"> </a>
<a name="ln547">								//Parse the UTF8 back into an int32</a>
<a name="ln548">								switch(strlen(u)) {</a>
<a name="ln549">									case 1:</a>
<a name="ln550">										unicodeVal = ((uint32)(u[0]&amp;0x7F));</a>
<a name="ln551">										break;</a>
<a name="ln552">									case 2:</a>
<a name="ln553">										unicodeVal = ((uint32)(u[1]&amp;0x3F)) |</a>
<a name="ln554">											(((uint32)(u[0]&amp;0x1F)) &lt;&lt; 6);</a>
<a name="ln555">										break;</a>
<a name="ln556">									case 3:</a>
<a name="ln557">										unicodeVal = ((uint32)(u[2]&amp;0x3F)) |</a>
<a name="ln558">											(((uint32)(u[1]&amp;0x3F)) &lt;&lt; 6) |</a>
<a name="ln559">											(((uint32)(u[0]&amp;0x0F)) &lt;&lt; 12);</a>
<a name="ln560">										break;</a>
<a name="ln561">									default: unicodeVal = 0;</a>
<a name="ln562">										break;</a>
<a name="ln563">								}</a>
<a name="ln564">							}</a>
<a name="ln565">						}</a>
<a name="ln566">						lastWasDash = false;</a>
<a name="ln567">					} else</a>
<a name="ln568">						lastWasDash = (*s == '-');</a>
<a name="ln569"> </a>
<a name="ln570">					s++;</a>
<a name="ln571">				}</a>
<a name="ln572"> </a>
<a name="ln573">				// If we have a letter, try to make it the correct case</a>
<a name="ln574">				if ((unicodeVal &gt;= 'A') &amp;&amp; (unicodeVal &lt;= 'Z')) {</a>
<a name="ln575">					if ((customMods &amp; B_SHIFT_KEY) == 0)</a>
<a name="ln576">						unicodeVal += 'a'-'A';</a>
<a name="ln577">				} else if ((unicodeVal &gt;= 'a') &amp;&amp; (unicodeVal &lt;= 'z')) {</a>
<a name="ln578">					if ((customMods &amp; B_SHIFT_KEY) != 0)</a>
<a name="ln579">						unicodeVal -= 'a'-'A';</a>
<a name="ln580">				}</a>
<a name="ln581">			} else {</a>
<a name="ln582">				unicodeVal = strtol(&amp;(fSequence.String())[nextStart + 2],</a>
<a name="ln583">					NULL, 0);</a>
<a name="ln584">				customMods = (uint32) -1;</a>
<a name="ln585">			}</a>
<a name="ln586"> </a>
<a name="ln587">			if (unicodeVal == 0)</a>
<a name="ln588">				unicodeVal = ' ';</a>
<a name="ln589"> </a>
<a name="ln590">			BString newString = fSequence;</a>
<a name="ln591">			newString.Truncate(nextStart);</a>
<a name="ln592">			fOverrides.AddItem((void*)(addr_t)unicodeVal);</a>
<a name="ln593">			fOverrideOffsets.AddItem((void*)(addr_t)newString.Length());</a>
<a name="ln594">			fOverrideModifiers.AddItem((void*)(addr_t)customMods);</a>
<a name="ln595">			fOverrideKeyCodes.AddItem((void*)(addr_t)customKey);</a>
<a name="ln596">			newString.Append((unicodeVal &gt; 0</a>
<a name="ln597">				&amp;&amp; unicodeVal &lt; 127) ? (char)unicodeVal : ' ', 1);</a>
<a name="ln598">			newString.Append(&amp;fSequence.String()[nextEnd + 2]);</a>
<a name="ln599">			fSequence = newString;</a>
<a name="ln600">		} else</a>
<a name="ln601">			break;</a>
<a name="ln602">	}</a>
<a name="ln603"> </a>
<a name="ln604">	_GenerateKeyCodes();</a>
<a name="ln605">}</a>
<a name="ln606"> </a>
<a name="ln607"> </a>
<a name="ln608">KeyStrokeSequenceCommandActuator::KeyStrokeSequenceCommandActuator(</a>
<a name="ln609">	BMessage* from)</a>
<a name="ln610">	:</a>
<a name="ln611">	CommandActuator(from)</a>
<a name="ln612">{</a>
<a name="ln613">	const char* sequence;</a>
<a name="ln614">	if (from-&gt;FindString(&quot;sequence&quot;, 0, &amp;sequence) == B_OK)</a>
<a name="ln615">		fSequence = sequence;</a>
<a name="ln616"> </a>
<a name="ln617">	int32 temp;</a>
<a name="ln618">	for (int32 i = 0; from-&gt;FindInt32(&quot;ooffsets&quot;, i, &amp;temp) == B_OK; i++) {</a>
<a name="ln619">		fOverrideOffsets.AddItem((void*)(addr_t)temp);</a>
<a name="ln620"> </a>
<a name="ln621">		if (from-&gt;FindInt32(&quot;overrides&quot;, i, &amp;temp) != B_OK)</a>
<a name="ln622">			temp = ' ';</a>
<a name="ln623"> </a>
<a name="ln624">		fOverrides.AddItem((void*)(addr_t)temp);</a>
<a name="ln625"> </a>
<a name="ln626">		if (from-&gt;FindInt32(&quot;omods&quot;, i, &amp;temp) != B_OK)</a>
<a name="ln627">			temp = -1;</a>
<a name="ln628"> </a>
<a name="ln629">		fOverrideModifiers.AddItem((void*)(addr_t)temp);</a>
<a name="ln630"> </a>
<a name="ln631">		if (from-&gt;FindInt32(&quot;okeys&quot;, i, &amp;temp) != B_OK)</a>
<a name="ln632">			temp = 0;</a>
<a name="ln633"> </a>
<a name="ln634">		fOverrideKeyCodes.AddItem((void*)(addr_t)temp);</a>
<a name="ln635">	}</a>
<a name="ln636"> </a>
<a name="ln637">	_GenerateKeyCodes();</a>
<a name="ln638">}</a>
<a name="ln639"> </a>
<a name="ln640"> </a>
<a name="ln641">KeyStrokeSequenceCommandActuator::~KeyStrokeSequenceCommandActuator()</a>
<a name="ln642">{</a>
<a name="ln643">	delete[] fKeyCodes;</a>
<a name="ln644">	delete[] fModCodes;</a>
<a name="ln645">	delete[] fStates;</a>
<a name="ln646">}</a>
<a name="ln647"> </a>
<a name="ln648"> </a>
<a name="ln649">void</a>
<a name="ln650">KeyStrokeSequenceCommandActuator::_GenerateKeyCodes()</a>
<a name="ln651">{</a>
<a name="ln652">	int slen = fSequence.Length();</a>
<a name="ln653">	fKeyCodes = new int32[slen];</a>
<a name="ln654">	fModCodes = new int32[slen];</a>
<a name="ln655">	fStates = new uint8[slen * 16];</a>
<a name="ln656"> </a>
<a name="ln657">	memset(fStates, 0, slen * 16);</a>
<a name="ln658"> </a>
<a name="ln659">	key_map* map;</a>
<a name="ln660">	char* keys;</a>
<a name="ln661">	get_key_map(&amp;map, &amp;keys);</a>
<a name="ln662">	for (int i = 0; i &lt; slen; i++) {</a>
<a name="ln663">		uint32 overrideKey = 0;</a>
<a name="ln664">		uint32 overrideMods = (uint32)-1;</a>
<a name="ln665">		for (int32 j = fOverrideOffsets.CountItems()-1; j &gt;= 0; j--) {</a>
<a name="ln666">			if ((int32)(addr_t)fOverrideOffsets.ItemAt(j) == i) {</a>
<a name="ln667">				overrideKey= (uint32)(addr_t) fOverrideKeyCodes.ItemAt(j);</a>
<a name="ln668">				overrideMods = (uint32)(addr_t) fOverrideModifiers.ItemAt(j);</a>
<a name="ln669">				break;</a>
<a name="ln670">			}</a>
<a name="ln671">		}</a>
<a name="ln672"> </a>
<a name="ln673">		uint8* states = &amp;fStates[i * 16];</a>
<a name="ln674">		int32&amp; modCode = fModCodes[i];</a>
<a name="ln675">		if (overrideKey == 0) {</a>
<a name="ln676">			// Gotta do reverse-lookups to find out the raw keycodes for a</a>
<a name="ln677">			// given character. Expensive--there oughtta be a better way to do</a>
<a name="ln678">			// this.</a>
<a name="ln679">			char next = fSequence.ByteAt(i);</a>
<a name="ln680">			int32 key = _LookupKeyCode(map, keys, map-&gt;normal_map, next,</a>
<a name="ln681">				states, modCode, 0);</a>
<a name="ln682">			if (key &lt; 0) {</a>
<a name="ln683">				key = _LookupKeyCode(map, keys, map-&gt;shift_map, next, states,</a>
<a name="ln684">					modCode, B_LEFT_SHIFT_KEY | B_SHIFT_KEY);</a>
<a name="ln685">			}</a>
<a name="ln686"> </a>
<a name="ln687">			if (key &lt; 0) {</a>
<a name="ln688">				key = _LookupKeyCode(map, keys, map-&gt;caps_map, next, states,</a>
<a name="ln689">					modCode, B_CAPS_LOCK);</a>
<a name="ln690">			}</a>
<a name="ln691"> </a>
<a name="ln692">			if (key &lt; 0) {</a>
<a name="ln693">				key = _LookupKeyCode(map, keys, map-&gt;caps_shift_map, next,</a>
<a name="ln694">					states, modCode,</a>
<a name="ln695">					B_LEFT_SHIFT_KEY | B_SHIFT_KEY | B_CAPS_LOCK);</a>
<a name="ln696">			}</a>
<a name="ln697"> </a>
<a name="ln698">			if (key &lt; 0) {</a>
<a name="ln699">				key = _LookupKeyCode(map, keys, map-&gt;option_map, next, states,</a>
<a name="ln700">					modCode, B_LEFT_OPTION_KEY | B_OPTION_KEY);</a>
<a name="ln701">			}</a>
<a name="ln702"> </a>
<a name="ln703">			if (key &lt; 0) {</a>
<a name="ln704">				key = _LookupKeyCode(map, keys, map-&gt;option_shift_map, next,</a>
<a name="ln705">					states, modCode, B_LEFT_OPTION_KEY | B_OPTION_KEY</a>
<a name="ln706">						| B_LEFT_SHIFT_KEY | B_SHIFT_KEY);</a>
<a name="ln707">			}</a>
<a name="ln708"> </a>
<a name="ln709">			if (key &lt; 0) {</a>
<a name="ln710">				key = _LookupKeyCode(map, keys, map-&gt;option_caps_map, next,</a>
<a name="ln711">					states, modCode,</a>
<a name="ln712">					B_LEFT_OPTION_KEY | B_OPTION_KEY | B_CAPS_LOCK);</a>
<a name="ln713">			}</a>
<a name="ln714"> </a>
<a name="ln715">			if (key &lt; 0) {</a>
<a name="ln716">				key = _LookupKeyCode(map, keys, map-&gt;option_caps_shift_map,</a>
<a name="ln717">					next, states, modCode, B_LEFT_OPTION_KEY | B_OPTION_KEY</a>
<a name="ln718">						| B_CAPS_LOCK | B_LEFT_SHIFT_KEY | B_SHIFT_KEY);</a>
<a name="ln719">			}</a>
<a name="ln720"> </a>
<a name="ln721">			if (key &lt; 0) {</a>
<a name="ln722">				key = _LookupKeyCode(map, keys, map-&gt;control_map, next, states,</a>
<a name="ln723">					modCode, B_CONTROL_KEY);</a>
<a name="ln724">			}</a>
<a name="ln725"> </a>
<a name="ln726">			fKeyCodes[i] = key &gt;= 0 ? key : 0;</a>
<a name="ln727">		}</a>
<a name="ln728"> </a>
<a name="ln729">		if (overrideMods != (uint32)-1) {</a>
<a name="ln730">			modCode = (int32)overrideMods;</a>
<a name="ln731"> </a>
<a name="ln732">			// Clear any bits that might have been set by the lookups...</a>
<a name="ln733">			_SetStateBit(states, map-&gt;caps_key, false);</a>
<a name="ln734">			_SetStateBit(states, map-&gt;scroll_key, false);</a>
<a name="ln735">			_SetStateBit(states, map-&gt;num_key, false);</a>
<a name="ln736">			_SetStateBit(states, map-&gt;menu_key, false);</a>
<a name="ln737">			_SetStateBit(states, map-&gt;left_shift_key, false);</a>
<a name="ln738">			_SetStateBit(states, map-&gt;right_shift_key, false);</a>
<a name="ln739">			_SetStateBit(states, map-&gt;left_command_key, false);</a>
<a name="ln740">			_SetStateBit(states, map-&gt;right_command_key, false);</a>
<a name="ln741">			_SetStateBit(states, map-&gt;left_control_key, false);</a>
<a name="ln742">			_SetStateBit(states, map-&gt;right_control_key, false);</a>
<a name="ln743">			_SetStateBit(states, map-&gt;left_option_key, false);</a>
<a name="ln744">			_SetStateBit(states, map-&gt;right_option_key, false);</a>
<a name="ln745"> </a>
<a name="ln746">			// And then set any bits that were specified in our override.</a>
<a name="ln747">			if (modCode &amp; B_CAPS_LOCK)</a>
<a name="ln748">				_SetStateBit(states, map-&gt;caps_key);</a>
<a name="ln749"> </a>
<a name="ln750">			if (modCode &amp; B_SCROLL_LOCK)</a>
<a name="ln751">				_SetStateBit(states, map-&gt;scroll_key);</a>
<a name="ln752"> </a>
<a name="ln753">			if (modCode &amp; B_NUM_LOCK)</a>
<a name="ln754">				_SetStateBit(states, map-&gt;num_key);</a>
<a name="ln755"> </a>
<a name="ln756">			if (modCode &amp; B_MENU_KEY)</a>
<a name="ln757">				_SetStateBit(states, map-&gt;menu_key);</a>
<a name="ln758"> </a>
<a name="ln759">			if (modCode &amp; B_LEFT_SHIFT_KEY)</a>
<a name="ln760">				_SetStateBit(states, map-&gt;left_shift_key);</a>
<a name="ln761"> </a>
<a name="ln762">			if (modCode &amp; B_RIGHT_SHIFT_KEY)</a>
<a name="ln763">				_SetStateBit(states, map-&gt;right_shift_key);</a>
<a name="ln764"> </a>
<a name="ln765">			if (modCode &amp; B_LEFT_COMMAND_KEY)</a>
<a name="ln766">				_SetStateBit(states, map-&gt;left_command_key);</a>
<a name="ln767"> </a>
<a name="ln768">			if (modCode &amp; B_RIGHT_COMMAND_KEY)</a>
<a name="ln769">				_SetStateBit(states, map-&gt;right_command_key);</a>
<a name="ln770"> </a>
<a name="ln771">			if (modCode &amp; B_LEFT_CONTROL_KEY)</a>
<a name="ln772">				_SetStateBit(states, map-&gt;left_control_key);</a>
<a name="ln773"> </a>
<a name="ln774">			if (modCode &amp; B_RIGHT_CONTROL_KEY)</a>
<a name="ln775">				_SetStateBit(states, map-&gt;right_control_key);</a>
<a name="ln776"> </a>
<a name="ln777">			if (modCode &amp; B_LEFT_OPTION_KEY)</a>
<a name="ln778">				_SetStateBit(states, map-&gt;left_option_key);</a>
<a name="ln779"> </a>
<a name="ln780">			if (modCode &amp; B_RIGHT_OPTION_KEY)</a>
<a name="ln781">				_SetStateBit(states, map-&gt;right_option_key);</a>
<a name="ln782">		}</a>
<a name="ln783"> </a>
<a name="ln784">		if (overrideKey &gt; 0) {</a>
<a name="ln785">			if (overrideKey &gt; 127) {</a>
<a name="ln786">				// invalid value?</a>
<a name="ln787">				overrideKey = 0;</a>
<a name="ln788">			}</a>
<a name="ln789"> </a>
<a name="ln790">			fKeyCodes[i] = overrideKey;</a>
<a name="ln791">			_SetStateBit(states, overrideKey);</a>
<a name="ln792">		}</a>
<a name="ln793">	}</a>
<a name="ln794"> </a>
<a name="ln795">	free(keys);</a>
<a name="ln796">	free(map);</a>
<a name="ln797">}</a>
<a name="ln798"> </a>
<a name="ln799"> </a>
<a name="ln800">int32</a>
<a name="ln801">KeyStrokeSequenceCommandActuator::_LookupKeyCode(key_map* map, char* keys,</a>
<a name="ln802">	int32 offsets[128], char c, uint8* setStates, int32&amp; setModifier,</a>
<a name="ln803">	int32 setTo) const</a>
<a name="ln804">{</a>
<a name="ln805">	for (int i = 0; i &lt; 128; i++) {</a>
<a name="ln806">		if (keys[offsets[i]+ 1] == c) {</a>
<a name="ln807">			_SetStateBit(setStates, i);</a>
<a name="ln808"> </a>
<a name="ln809">			if (setTo &amp; B_SHIFT_KEY)</a>
<a name="ln810">				_SetStateBit(setStates, map-&gt;left_shift_key);</a>
<a name="ln811"> </a>
<a name="ln812">			if (setTo &amp; B_OPTION_KEY)</a>
<a name="ln813">				_SetStateBit(setStates, map-&gt;left_option_key);</a>
<a name="ln814"> </a>
<a name="ln815">			if (setTo &amp; B_CONTROL_KEY)</a>
<a name="ln816">				_SetStateBit(setStates, map-&gt;left_control_key);</a>
<a name="ln817"> </a>
<a name="ln818">			if (setTo &amp; B_CAPS_LOCK)</a>
<a name="ln819">				_SetStateBit(setStates, map-&gt;caps_key);</a>
<a name="ln820"> </a>
<a name="ln821">			setModifier = setTo;</a>
<a name="ln822"> </a>
<a name="ln823">			return i;</a>
<a name="ln824">		}</a>
<a name="ln825">	}</a>
<a name="ln826"> </a>
<a name="ln827">	return -1;</a>
<a name="ln828">}</a>
<a name="ln829"> </a>
<a name="ln830"> </a>
<a name="ln831">void</a>
<a name="ln832">KeyStrokeSequenceCommandActuator::_SetStateBit(uint8* setStates, uint32 key,</a>
<a name="ln833">	bool on) const</a>
<a name="ln834">{</a>
<a name="ln835">	if (on)</a>
<a name="ln836">		setStates[key / 8] |= (0x80 &gt;&gt; (key % 8));</a>
<a name="ln837">	else</a>
<a name="ln838">		setStates[key / 8] &amp;= ~(0x80 &gt;&gt; (key % 8));</a>
<a name="ln839">}</a>
<a name="ln840"> </a>
<a name="ln841"> </a>
<a name="ln842">status_t</a>
<a name="ln843">KeyStrokeSequenceCommandActuator::Archive(BMessage* into, bool deep) const</a>
<a name="ln844">{</a>
<a name="ln845">	status_t result = CommandActuator::Archive(into, deep);</a>
<a name="ln846">	if (result != B_OK)</a>
<a name="ln847">		return result;</a>
<a name="ln848"> </a>
<a name="ln849">	into-&gt;AddString(&quot;sequence&quot;, fSequence.String());</a>
<a name="ln850">	int32 numOverrides = fOverrideOffsets.CountItems();</a>
<a name="ln851"> </a>
<a name="ln852">	status_t overridesResult = B_OK;</a>
<a name="ln853">	for (int32 i = 0; i &lt; numOverrides; i++) {</a>
<a name="ln854">		result = into-&gt;AddInt32(&quot;ooffsets&quot;,</a>
<a name="ln855">			(int32)(addr_t)fOverrideOffsets.ItemAt(i));</a>
<a name="ln856">		if (result != B_OK)</a>
<a name="ln857">			overridesResult = B_ERROR;</a>
<a name="ln858"> </a>
<a name="ln859">		result = into-&gt;AddInt32(&quot;overrides&quot;,</a>
<a name="ln860">			(int32)(addr_t)fOverrides.ItemAt(i));</a>
<a name="ln861">		if (result != B_OK)</a>
<a name="ln862">			overridesResult = B_ERROR;</a>
<a name="ln863"> </a>
<a name="ln864">		result = into-&gt;AddInt32(&quot;omods&quot;,</a>
<a name="ln865">			(int32)(addr_t)fOverrideModifiers.ItemAt(i));</a>
<a name="ln866">		if (result != B_OK)</a>
<a name="ln867">			overridesResult = B_ERROR;</a>
<a name="ln868"> </a>
<a name="ln869">		result = into-&gt;AddInt32(&quot;okeys&quot;,</a>
<a name="ln870">			(int32)(addr_t)fOverrideKeyCodes.ItemAt(i));</a>
<a name="ln871">	}</a>
<a name="ln872"> </a>
<a name="ln873">	return overridesResult == B_ERROR ? B_ERROR : result;</a>
<a name="ln874">}</a>
<a name="ln875"> </a>
<a name="ln876"> </a>
<a name="ln877">filter_result</a>
<a name="ln878">KeyStrokeSequenceCommandActuator::KeyEvent(const BMessage* keyMessage,</a>
<a name="ln879">	BList* outList, void** setAsyncData, BMessage* mouseMessage)</a>
<a name="ln880">{</a>
<a name="ln881">	if (IS_KEY_DOWN(keyMessage)) {</a>
<a name="ln882">		BMessage temp(*keyMessage);</a>
<a name="ln883">		int numChars = fSequence.Length();</a>
<a name="ln884">		for (int i = 0; i &lt; numChars; i++) {</a>
<a name="ln885">			char nextChar = fSequence.ByteAt(i);</a>
<a name="ln886"> </a>
<a name="ln887">			temp.RemoveName(&quot;modifiers&quot;);</a>
<a name="ln888">			temp.AddInt32(&quot;modifiers&quot;, fModCodes[i]);</a>
<a name="ln889">			temp.RemoveName(&quot;key&quot;);</a>
<a name="ln890">			temp.AddInt32(&quot;key&quot;, fKeyCodes[i]);</a>
<a name="ln891">			temp.RemoveName(&quot;raw_char&quot;);</a>
<a name="ln892">			temp.AddInt32(&quot;raw_char&quot;, (int32) nextChar);</a>
<a name="ln893">			temp.RemoveName(&quot;byte&quot;);</a>
<a name="ln894"> </a>
<a name="ln895">			int32 override = -1;</a>
<a name="ln896">			for (int32 j = fOverrideOffsets.CountItems()-1; j &gt;= 0; j--) {</a>
<a name="ln897">				int32 offset = (int32)(addr_t) fOverrideOffsets.ItemAt(j);</a>
<a name="ln898">				if (offset == i) {</a>
<a name="ln899">					override = (int32)(addr_t) fOverrides.ItemAt(j);</a>
<a name="ln900">					break;</a>
<a name="ln901">				}</a>
<a name="ln902">			}</a>
<a name="ln903"> </a>
<a name="ln904">			char t[4];</a>
<a name="ln905">			if (override &gt;= 0) {</a>
<a name="ln906">				if (override &lt; 0x80) {</a>
<a name="ln907">					// one-byte encoding</a>
<a name="ln908">					t[0] = (char) override;</a>
<a name="ln909">					t[1] = 0x00;</a>
<a name="ln910">				} else if (override &lt; 0x800) {</a>
<a name="ln911">					// two-byte encoding</a>
<a name="ln912">					t[0] = 0xC0 | ((char)((override &amp; 0x7C0)&gt;&gt;6));</a>
<a name="ln913">					t[1] = 0x80 | ((char)((override &amp; 0x03F)&gt;&gt;0));</a>
<a name="ln914">					t[2] = 0x00;</a>
<a name="ln915">				} else {</a>
<a name="ln916">					// three-byte encoding</a>
<a name="ln917">					t[0] = 0xE0 | ((char)((override &amp; 0xF000)&gt;&gt;12));</a>
<a name="ln918">					t[1] = 0x80 | ((char)((override &amp; 0x0FC0)&gt;&gt;6));</a>
<a name="ln919">					t[2] = 0x80 | ((char)((override &amp; 0x003F)&gt;&gt;0));</a>
<a name="ln920">					t[3] = 0x00;</a>
<a name="ln921">				}</a>
<a name="ln922">			} else {</a>
<a name="ln923">				t[0] = nextChar;</a>
<a name="ln924">				t[1] = 0x00;</a>
<a name="ln925">			}</a>
<a name="ln926"> </a>
<a name="ln927">			temp.RemoveName(&quot;byte&quot;);</a>
<a name="ln928"> </a>
<a name="ln929">			for (int m = 0; t[m] != 0x00; m++)</a>
<a name="ln930">				temp.AddInt8(&quot;byte&quot;, t[m]);</a>
<a name="ln931"> </a>
<a name="ln932">			temp.RemoveName(&quot;states&quot;);</a>
<a name="ln933">			temp.AddData(&quot;states&quot;, B_UINT8_TYPE, &amp;fStates[i * 16], 16, true, 16);</a>
<a name="ln934">			temp.RemoveName(&quot;bytes&quot;);</a>
<a name="ln935">			temp.AddString(&quot;bytes&quot;, t);</a>
<a name="ln936">			temp.what = B_KEY_DOWN;</a>
<a name="ln937">			outList-&gt;AddItem(new BMessage(temp));</a>
<a name="ln938">			temp.what = B_KEY_UP;</a>
<a name="ln939">			outList-&gt;AddItem(new BMessage(temp));</a>
<a name="ln940">		}</a>
<a name="ln941"> </a>
<a name="ln942">		return B_DISPATCH_MESSAGE;</a>
<a name="ln943">	} else</a>
<a name="ln944">		return B_SKIP_MESSAGE;</a>
<a name="ln945">}</a>
<a name="ln946"> </a>
<a name="ln947"> </a>
<a name="ln948">BArchivable*</a>
<a name="ln949">KeyStrokeSequenceCommandActuator::Instantiate(BMessage* from)</a>
<a name="ln950">{</a>
<a name="ln951">	if (validate_instantiation(from, &quot;KeyStrokeSequenceCommandActuator&quot;))</a>
<a name="ln952">		return new KeyStrokeSequenceCommandActuator(from);</a>
<a name="ln953">	else</a>
<a name="ln954">		return NULL;</a>
<a name="ln955">}</a>
<a name="ln956"> </a>
<a name="ln957"> </a>
<a name="ln958">//	#pragma mark - MIMEHandlerCommandActuator</a>
<a name="ln959"> </a>
<a name="ln960"> </a>
<a name="ln961">MIMEHandlerCommandActuator::MIMEHandlerCommandActuator(int32 argc, char** argv)</a>
<a name="ln962">	:</a>
<a name="ln963">	CommandActuator(argc, argv),</a>
<a name="ln964">	fMimeType((argc &gt; 1) ? argv[1] : &quot;&quot;)</a>
<a name="ln965">{</a>
<a name="ln966">}</a>
<a name="ln967"> </a>
<a name="ln968"> </a>
<a name="ln969">MIMEHandlerCommandActuator::MIMEHandlerCommandActuator(BMessage* from)</a>
<a name="ln970">	:</a>
<a name="ln971">	CommandActuator(from)</a>
<a name="ln972">{</a>
<a name="ln973">	const char* temp;</a>
<a name="ln974">	if (from-&gt;FindString(&quot;mimeType&quot;, 0, &amp;temp) == B_OK)</a>
<a name="ln975">		fMimeType = temp;</a>
<a name="ln976">}</a>
<a name="ln977"> </a>
<a name="ln978"> </a>
<a name="ln979">MIMEHandlerCommandActuator::~MIMEHandlerCommandActuator()</a>
<a name="ln980">{</a>
<a name="ln981">}</a>
<a name="ln982"> </a>
<a name="ln983"> </a>
<a name="ln984">status_t</a>
<a name="ln985">MIMEHandlerCommandActuator::Archive(BMessage* into, bool deep) const</a>
<a name="ln986">{</a>
<a name="ln987">	status_t ret = CommandActuator::Archive(into, deep);</a>
<a name="ln988">	into-&gt;AddString(&quot;mimeType&quot;, fMimeType.String());</a>
<a name="ln989">	return ret;</a>
<a name="ln990">}</a>
<a name="ln991"> </a>
<a name="ln992"> </a>
<a name="ln993">filter_result</a>
<a name="ln994">MIMEHandlerCommandActuator::KeyEvent(const BMessage* keyMessage, BList* outList,</a>
<a name="ln995">	void** setAsyncData, BMessage* mouseMessage)</a>
<a name="ln996">{</a>
<a name="ln997">	if (IS_KEY_DOWN(keyMessage))</a>
<a name="ln998">		// cause KeyEventAsync() to be called asynchronously</a>
<a name="ln999">		*setAsyncData = (void*) true;</a>
<a name="ln1000">	return B_SKIP_MESSAGE;</a>
<a name="ln1001">}</a>
<a name="ln1002"> </a>
<a name="ln1003"> </a>
<a name="ln1004">void</a>
<a name="ln1005">MIMEHandlerCommandActuator::KeyEventAsync(const BMessage* keyMessage,</a>
<a name="ln1006">	void* asyncData)</a>
<a name="ln1007">{</a>
<a name="ln1008">	if (be_roster == NULL)</a>
<a name="ln1009">		return;</a>
<a name="ln1010"> </a>
<a name="ln1011">	BString string;</a>
<a name="ln1012">	status_t ret = be_roster-&gt;Launch(fMimeType.String());</a>
<a name="ln1013">	if ((ret != B_OK) &amp;&amp; (ret != B_ALREADY_RUNNING)) {</a>
<a name="ln1014">		string &lt;&lt; &quot;Can't launch handler for &quot;;</a>
<a name="ln1015">		string &lt;&lt; &quot;, no such MIME type exists. Please check your Shortcuts&quot;;</a>
<a name="ln1016">		string &lt;&lt; &quot; settings.&quot;;</a>
<a name="ln1017">		BAlert* alert = new BAlert(&quot;Shortcuts MIME launcher error&quot;,</a>
<a name="ln1018">			string.String(), &quot;OK&quot;);</a>
<a name="ln1019">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln1020">		alert-&gt;Go(NULL);</a>
<a name="ln1021">	}</a>
<a name="ln1022">}</a>
<a name="ln1023"> </a>
<a name="ln1024"> </a>
<a name="ln1025">BArchivable* MIMEHandlerCommandActuator::Instantiate(BMessage* from)</a>
<a name="ln1026">{</a>
<a name="ln1027">	if (validate_instantiation(from, &quot;MIMEHandlerCommandActuator&quot;))</a>
<a name="ln1028">		return new MIMEHandlerCommandActuator(from);</a>
<a name="ln1029">	else</a>
<a name="ln1030">		return NULL;</a>
<a name="ln1031">}</a>
<a name="ln1032"> </a>
<a name="ln1033"> </a>
<a name="ln1034">//	#pragma mark - BeepCommandActuator</a>
<a name="ln1035"> </a>
<a name="ln1036"> </a>
<a name="ln1037">BeepCommandActuator::BeepCommandActuator(int32 argc, char** argv)</a>
<a name="ln1038">	:</a>
<a name="ln1039">	CommandActuator(argc, argv)</a>
<a name="ln1040">{</a>
<a name="ln1041">}</a>
<a name="ln1042"> </a>
<a name="ln1043"> </a>
<a name="ln1044">BeepCommandActuator::BeepCommandActuator(BMessage* from)</a>
<a name="ln1045">	:</a>
<a name="ln1046">	CommandActuator(from)</a>
<a name="ln1047">{</a>
<a name="ln1048">}</a>
<a name="ln1049"> </a>
<a name="ln1050"> </a>
<a name="ln1051">BeepCommandActuator::~BeepCommandActuator()</a>
<a name="ln1052">{</a>
<a name="ln1053">}</a>
<a name="ln1054"> </a>
<a name="ln1055"> </a>
<a name="ln1056">status_t</a>
<a name="ln1057">BeepCommandActuator::Archive(BMessage* into, bool deep) const</a>
<a name="ln1058">{</a>
<a name="ln1059">	return CommandActuator::Archive(into, deep);</a>
<a name="ln1060">}</a>
<a name="ln1061"> </a>
<a name="ln1062"> </a>
<a name="ln1063">BArchivable*</a>
<a name="ln1064">BeepCommandActuator::Instantiate(BMessage* from)</a>
<a name="ln1065">{</a>
<a name="ln1066">	if (validate_instantiation(from, &quot;BeepCommandActuator&quot;))</a>
<a name="ln1067">		return new BeepCommandActuator(from);</a>
<a name="ln1068">	else</a>
<a name="ln1069">		return NULL;</a>
<a name="ln1070">}</a>
<a name="ln1071"> </a>
<a name="ln1072"> </a>
<a name="ln1073">filter_result</a>
<a name="ln1074">BeepCommandActuator::KeyEvent(const BMessage* keyMessage, BList* outList,</a>
<a name="ln1075">	void** setAsyncData, BMessage* mouseMessage)</a>
<a name="ln1076">{</a>
<a name="ln1077">	if (IS_KEY_DOWN(keyMessage))</a>
<a name="ln1078">		beep();</a>
<a name="ln1079"> </a>
<a name="ln1080">	return B_SKIP_MESSAGE;</a>
<a name="ln1081">}</a>
<a name="ln1082"> </a>
<a name="ln1083"> </a>
<a name="ln1084">//	#pragma mark - MultiCommandActuator</a>
<a name="ln1085"> </a>
<a name="ln1086"> </a>
<a name="ln1087">MultiCommandActuator::MultiCommandActuator(BMessage* from)</a>
<a name="ln1088">	:</a>
<a name="ln1089">	CommandActuator(from)</a>
<a name="ln1090">{</a>
<a name="ln1091">	BMessage msg;</a>
<a name="ln1092">	for (int i = 0; from-&gt;FindMessage(&quot;subs&quot;, i, &amp;msg) == B_OK; i++) {</a>
<a name="ln1093">		BArchivable* subObj = instantiate_object(&amp;msg);</a>
<a name="ln1094">		if (subObj) {</a>
<a name="ln1095">			CommandActuator* ca = dynamic_cast &lt; CommandActuator*&gt;(subObj);</a>
<a name="ln1096"> </a>
<a name="ln1097">			if (ca)</a>
<a name="ln1098">				fSubActuators.AddItem(ca);</a>
<a name="ln1099">			else</a>
<a name="ln1100">				delete subObj;</a>
<a name="ln1101">		}</a>
<a name="ln1102">	}</a>
<a name="ln1103">}</a>
<a name="ln1104"> </a>
<a name="ln1105"> </a>
<a name="ln1106">MultiCommandActuator::MultiCommandActuator(int32 argc, char** argv)</a>
<a name="ln1107">	:</a>
<a name="ln1108">	CommandActuator(argc, argv)</a>
<a name="ln1109">{</a>
<a name="ln1110">	for (int i = 1; i &lt; argc; i++) {</a>
<a name="ln1111">		CommandActuator* sub = CreateCommandActuator(argv[i]);</a>
<a name="ln1112"> </a>
<a name="ln1113">		if (sub)</a>
<a name="ln1114">			fSubActuators.AddItem(sub);</a>
<a name="ln1115">		else</a>
<a name="ln1116">			printf(&quot;Error creating subActuator from [%s]\n&quot;, argv[i]);</a>
<a name="ln1117">	}</a>
<a name="ln1118">}</a>
<a name="ln1119"> </a>
<a name="ln1120"> </a>
<a name="ln1121">MultiCommandActuator::~MultiCommandActuator()</a>
<a name="ln1122">{</a>
<a name="ln1123">	int numSubs = fSubActuators.CountItems();</a>
<a name="ln1124">	for (int i = 0; i &lt; numSubs; i++)</a>
<a name="ln1125">		delete ((CommandActuator*) fSubActuators.ItemAt(i));</a>
<a name="ln1126">}</a>
<a name="ln1127"> </a>
<a name="ln1128"> </a>
<a name="ln1129">status_t</a>
<a name="ln1130">MultiCommandActuator::Archive(BMessage* into, bool deep) const</a>
<a name="ln1131">{</a>
<a name="ln1132">	status_t ret = CommandActuator::Archive(into, deep);</a>
<a name="ln1133">	if (ret != B_OK)</a>
<a name="ln1134">		return ret;</a>
<a name="ln1135"> </a>
<a name="ln1136">	int numSubs = fSubActuators.CountItems();</a>
<a name="ln1137">	for (int i = 0; i &lt; numSubs; i++) {</a>
<a name="ln1138">		BMessage msg;</a>
<a name="ln1139">		ret = ((CommandActuator*)fSubActuators.ItemAt(i))-&gt;Archive(&amp;msg, deep);</a>
<a name="ln1140"> </a>
<a name="ln1141">		if (ret != B_OK)</a>
<a name="ln1142">			return ret;</a>
<a name="ln1143"> </a>
<a name="ln1144">		into-&gt;AddMessage(&quot;subs&quot;, &amp;msg);</a>
<a name="ln1145">	}</a>
<a name="ln1146">	return B_OK;</a>
<a name="ln1147">}</a>
<a name="ln1148"> </a>
<a name="ln1149"> </a>
<a name="ln1150">BArchivable*</a>
<a name="ln1151">MultiCommandActuator::Instantiate(BMessage* from)</a>
<a name="ln1152">{</a>
<a name="ln1153">	if (validate_instantiation(from, &quot;MultiCommandActuator&quot;))</a>
<a name="ln1154">		return new MultiCommandActuator(from);</a>
<a name="ln1155">	else</a>
<a name="ln1156">		return NULL;</a>
<a name="ln1157">}</a>
<a name="ln1158"> </a>
<a name="ln1159"> </a>
<a name="ln1160">filter_result</a>
<a name="ln1161">MultiCommandActuator::KeyEvent(const BMessage* keyMessage, BList* outList,</a>
<a name="ln1162">	void** asyncData, BMessage* mouseMessage)</a>
<a name="ln1163">{</a>
<a name="ln1164">	BList* aDataList = NULL; // demand-allocated</a>
<a name="ln1165">	filter_result res = B_SKIP_MESSAGE;</a>
<a name="ln1166">	int numSubs = fSubActuators.CountItems();</a>
<a name="ln1167">	for (int i = 0; i &lt; numSubs; i++) {</a>
<a name="ln1168">		void* aData = NULL;</a>
<a name="ln1169">		status_t next = ((CommandActuator*)fSubActuators.ItemAt(i))-&gt;</a>
<a name="ln1170">			KeyEvent(keyMessage, outList, &amp;aData, mouseMessage);</a>
<a name="ln1171"> </a>
<a name="ln1172">		if (next == B_DISPATCH_MESSAGE)</a>
<a name="ln1173">			// dispatch message if at least one sub wants it dispatched</a>
<a name="ln1174">			res = B_DISPATCH_MESSAGE;</a>
<a name="ln1175"> </a>
<a name="ln1176">		if (aData) {</a>
<a name="ln1177">			if (aDataList == NULL)</a>
<a name="ln1178">				*asyncData = aDataList = new BList;</a>
<a name="ln1179"> </a>
<a name="ln1180">			while (aDataList-&gt;CountItems() &lt; i - 1)</a>
<a name="ln1181">				aDataList-&gt;AddItem(NULL);</a>
<a name="ln1182">			aDataList-&gt;AddItem(aData);</a>
<a name="ln1183">		}</a>
<a name="ln1184">	}</a>
<a name="ln1185">	return res;</a>
<a name="ln1186">}</a>
<a name="ln1187"> </a>
<a name="ln1188"> </a>
<a name="ln1189">void</a>
<a name="ln1190">MultiCommandActuator::KeyEventAsync(const BMessage* keyUpMsg, void* asyncData)</a>
<a name="ln1191">{</a>
<a name="ln1192">	BList* list = (BList*) asyncData;</a>
<a name="ln1193">	int numSubs = list-&gt;CountItems();</a>
<a name="ln1194">	for (int i = 0; i &lt; numSubs; i++) {</a>
<a name="ln1195">		void* aData = list-&gt;ItemAt(i);</a>
<a name="ln1196">		if (aData)</a>
<a name="ln1197">			((CommandActuator*) fSubActuators.ItemAt(i))-&gt;</a>
<a name="ln1198">				KeyEventAsync(keyUpMsg, aData);</a>
<a name="ln1199">	}</a>
<a name="ln1200">	delete list;</a>
<a name="ln1201">}</a>
<a name="ln1202"> </a>
<a name="ln1203"> </a>
<a name="ln1204">//	#pragma mark - MoveMouseCommandActuator</a>
<a name="ln1205"> </a>
<a name="ln1206"> </a>
<a name="ln1207">MoveMouseCommandActuator::MoveMouseCommandActuator(BMessage* from)</a>
<a name="ln1208">	:</a>
<a name="ln1209">	CommandActuator(from)</a>
<a name="ln1210">{</a>
<a name="ln1211">	if (from-&gt;FindFloat(&quot;xPercent&quot;, &amp;fXPercent) != B_OK)</a>
<a name="ln1212">		fXPercent = 0.0f;</a>
<a name="ln1213"> </a>
<a name="ln1214">	if (from-&gt;FindFloat(&quot;yPercent&quot;, &amp;fYPercent) != B_OK)</a>
<a name="ln1215">		fYPercent = 0.0f;</a>
<a name="ln1216"> </a>
<a name="ln1217">	if (from-&gt;FindFloat(&quot;xPixels&quot;, &amp;fXPixels) != B_OK)</a>
<a name="ln1218">		fXPixels = 0;</a>
<a name="ln1219"> </a>
<a name="ln1220">	if (from-&gt;FindFloat(&quot;yPixels&quot;, &amp;fYPixels) != B_OK)</a>
<a name="ln1221">		fYPixels = 0;</a>
<a name="ln1222">}</a>
<a name="ln1223"> </a>
<a name="ln1224"> </a>
<a name="ln1225">MoveMouseCommandActuator::MoveMouseCommandActuator(int32 argc, char** argv)</a>
<a name="ln1226">	:</a>
<a name="ln1227">	CommandActuator(argc, argv),</a>
<a name="ln1228">	fXPercent(0.0f),</a>
<a name="ln1229">	fYPercent(0.0f),</a>
<a name="ln1230">	fXPixels(0),</a>
<a name="ln1231">	fYPixels(0)</a>
<a name="ln1232">{</a>
<a name="ln1233">	if (argc &gt; 1)</a>
<a name="ln1234">		_ParseArg(argv[1], fXPercent, fXPixels);</a>
<a name="ln1235"> </a>
<a name="ln1236">	if (argc &gt; 2)</a>
<a name="ln1237">		_ParseArg(argv[2], fYPercent, fYPixels);</a>
<a name="ln1238">}</a>
<a name="ln1239"> </a>
<a name="ln1240"> </a>
<a name="ln1241">MoveMouseCommandActuator::~MoveMouseCommandActuator()</a>
<a name="ln1242">{</a>
<a name="ln1243">}</a>
<a name="ln1244"> </a>
<a name="ln1245"> </a>
<a name="ln1246">status_t</a>
<a name="ln1247">MoveMouseCommandActuator::Archive(BMessage* into, bool deep) const</a>
<a name="ln1248">{</a>
<a name="ln1249">	status_t ret = CommandActuator::Archive(into, deep);</a>
<a name="ln1250">	into-&gt;AddFloat(&quot;xPercent&quot;, fXPercent);</a>
<a name="ln1251">	into-&gt;AddFloat(&quot;yPercent&quot;, fYPercent);</a>
<a name="ln1252">	into-&gt;AddFloat(&quot;xPixels&quot;, fXPixels);</a>
<a name="ln1253">	into-&gt;AddFloat(&quot;yPixels&quot;, fYPixels);</a>
<a name="ln1254">	return ret;</a>
<a name="ln1255">}</a>
<a name="ln1256"> </a>
<a name="ln1257"> </a>
<a name="ln1258">void</a>
<a name="ln1259">MoveMouseCommandActuator::CalculateCoords(float&amp; setX, float&amp; setY) const</a>
<a name="ln1260">{</a>
<a name="ln1261">	BScreen s;</a>
<a name="ln1262">	BRect frame = s.Frame();</a>
<a name="ln1263">	setX = (frame.Width() * fXPercent) + fXPixels;</a>
<a name="ln1264">	setY = (frame.Height() * fYPercent) + fYPixels;</a>
<a name="ln1265">}</a>
<a name="ln1266"> </a>
<a name="ln1267"> </a>
<a name="ln1268">BMessage*</a>
<a name="ln1269">MoveMouseCommandActuator::CreateMouseMessage(const BMessage* original,</a>
<a name="ln1270">	BPoint where, BList* outList) const</a>
<a name="ln1271">{</a>
<a name="ln1272">	// Force where into the screen space</a>
<a name="ln1273">	{</a>
<a name="ln1274">		BScreen screen;</a>
<a name="ln1275">		where.ConstrainTo(screen.Frame());</a>
<a name="ln1276">	}</a>
<a name="ln1277"> </a>
<a name="ln1278">	BMessage* newMessage = new BMessage(B_MOUSE_MOVED);</a>
<a name="ln1279"> </a>
<a name="ln1280">	newMessage-&gt;AddPoint(&quot;where&quot;, where);</a>
<a name="ln1281"> </a>
<a name="ln1282">	int32 buttons = 0;</a>
<a name="ln1283">	(void)original-&gt;FindInt32(&quot;buttons&quot;, &amp;buttons);</a>
<a name="ln1284"> </a>
<a name="ln1285">	if (buttons == 0)</a>
<a name="ln1286">		buttons = 1;</a>
<a name="ln1287"> </a>
<a name="ln1288">	newMessage-&gt;AddInt32(&quot;buttons&quot;, buttons);</a>
<a name="ln1289"> </a>
<a name="ln1290">	// Trey sez you gotta keep then &quot;when&quot;'s increasing if you want click&amp;drag</a>
<a name="ln1291">	// to work!</a>
<a name="ln1292">	const BMessage* lastMessage;</a>
<a name="ln1293">	int32 last = outList-&gt;CountItems() - 1;</a>
<a name="ln1294"> </a>
<a name="ln1295">	if (outList-&gt;CountItems() &gt; 0)</a>
<a name="ln1296">		lastMessage = (const BMessage*)outList-&gt;ItemAt(last);</a>
<a name="ln1297">	else</a>
<a name="ln1298">		lastMessage = original;</a>
<a name="ln1299"> </a>
<a name="ln1300">	int64 when;</a>
<a name="ln1301"> </a>
<a name="ln1302">	if (lastMessage-&gt;FindInt64(&quot;when&quot;, &amp;when) == B_OK) {</a>
<a name="ln1303">		when++;</a>
<a name="ln1304">		newMessage-&gt;RemoveName(&quot;when&quot;);</a>
<a name="ln1305">		newMessage-&gt;AddInt64(&quot;when&quot;, when);</a>
<a name="ln1306">	}</a>
<a name="ln1307">	return newMessage;</a>
<a name="ln1308">}</a>
<a name="ln1309"> </a>
<a name="ln1310"> </a>
<a name="ln1311">static bool IsNumeric(char c);</a>
<a name="ln1312">static bool IsNumeric(char c)</a>
<a name="ln1313">{</a>
<a name="ln1314">	return (((c &gt;= '0') &amp;&amp; (c &lt;= '9')) || (c == '.') || (c == '-'));</a>
<a name="ln1315">}</a>
<a name="ln1316"> </a>
<a name="ln1317"> </a>
<a name="ln1318">// Parse a string of the form &quot;10&quot;, &quot;10%&quot;, &quot;10+ 10%&quot;, or &quot;10%+ 10&quot;</a>
<a name="ln1319">void</a>
<a name="ln1320">MoveMouseCommandActuator::_ParseArg(const char* arg, float&amp; setPercent,</a>
<a name="ln1321">	float&amp; setPixels) const</a>
<a name="ln1322">{</a>
<a name="ln1323">	char* temp = new char[strlen(arg) + 1];</a>
<a name="ln1324">	strcpy(temp, arg);</a>
<a name="ln1325"> </a>
<a name="ln1326">	// Find the percent part, if any</a>
<a name="ln1327">	char* percent = strchr(temp, '%');</a>
<a name="ln1328">	if (percent) {</a>
<a name="ln1329">		// Rewind to one before the beginning of the number</a>
<a name="ln1330">		char* beginNum = percent - 1;</a>
<a name="ln1331">		while (beginNum &gt;= temp) {</a>
<a name="ln1332">			char c = *beginNum;</a>
<a name="ln1333">			if (IsNumeric(c))</a>
<a name="ln1334">				beginNum--;</a>
<a name="ln1335">			else</a>
<a name="ln1336">				break;</a>
<a name="ln1337">		}</a>
<a name="ln1338"> </a>
<a name="ln1339">		// parse the number</a>
<a name="ln1340">		setPercent = atof(++beginNum)/100.0f;</a>
<a name="ln1341"> </a>
<a name="ln1342">		// Now white it out to ease finding the other #</a>
<a name="ln1343">		while (beginNum &lt;= percent)</a>
<a name="ln1344">			*(beginNum++) = ' ';</a>
<a name="ln1345">	}</a>
<a name="ln1346"> </a>
<a name="ln1347">	// Find the pixel part, if any</a>
<a name="ln1348">	char* pixel = temp;</a>
<a name="ln1349">	while (!IsNumeric(*pixel)) {</a>
<a name="ln1350">		if (*pixel == '\0')</a>
<a name="ln1351">			break;</a>
<a name="ln1352">		pixel++;</a>
<a name="ln1353">	}</a>
<a name="ln1354">	setPixels = atof(pixel);</a>
<a name="ln1355"> delete [] temp;</a>
<a name="ln1356">}</a>
<a name="ln1357"> </a>
<a name="ln1358"> </a>
<a name="ln1359">//	#pragma mark - MoveMouseToCommandActuator</a>
<a name="ln1360"> </a>
<a name="ln1361"> </a>
<a name="ln1362">MoveMouseToCommandActuator::MoveMouseToCommandActuator(BMessage* from)</a>
<a name="ln1363">	:</a>
<a name="ln1364">	MoveMouseCommandActuator(from)</a>
<a name="ln1365">{</a>
<a name="ln1366">}</a>
<a name="ln1367"> </a>
<a name="ln1368"> </a>
<a name="ln1369">MoveMouseToCommandActuator::MoveMouseToCommandActuator(int32 argc, char** argv)</a>
<a name="ln1370">	:</a>
<a name="ln1371">	MoveMouseCommandActuator(argc, argv)</a>
<a name="ln1372">{</a>
<a name="ln1373">}</a>
<a name="ln1374"> </a>
<a name="ln1375"> </a>
<a name="ln1376">MoveMouseToCommandActuator::~MoveMouseToCommandActuator()</a>
<a name="ln1377">{</a>
<a name="ln1378">}</a>
<a name="ln1379"> </a>
<a name="ln1380"> </a>
<a name="ln1381">status_t</a>
<a name="ln1382">MoveMouseToCommandActuator::Archive(BMessage* into, bool deep) const</a>
<a name="ln1383">{</a>
<a name="ln1384">	return MoveMouseCommandActuator::Archive(into, deep);</a>
<a name="ln1385">}</a>
<a name="ln1386"> </a>
<a name="ln1387"> </a>
<a name="ln1388">BArchivable*</a>
<a name="ln1389">MoveMouseToCommandActuator::Instantiate(BMessage* from)</a>
<a name="ln1390">{</a>
<a name="ln1391">	if (validate_instantiation(from, &quot;MoveMouseToCommandActuator&quot;))</a>
<a name="ln1392">		return new MoveMouseToCommandActuator(from);</a>
<a name="ln1393">	else</a>
<a name="ln1394">		return NULL;</a>
<a name="ln1395">}</a>
<a name="ln1396"> </a>
<a name="ln1397"> </a>
<a name="ln1398">filter_result</a>
<a name="ln1399">MoveMouseToCommandActuator::KeyEvent(const BMessage* keyMessage, BList* outList,</a>
<a name="ln1400">	void** setAsyncData, BMessage* mouseMessage)</a>
<a name="ln1401">{</a>
<a name="ln1402">	if (IS_KEY_DOWN(keyMessage)) {</a>
<a name="ln1403">		float x, y;</a>
<a name="ln1404">		CalculateCoords(x, y);</a>
<a name="ln1405">		BPoint where(x, y);</a>
<a name="ln1406">		BMessage* newMessage = CreateMouseMessage(keyMessage, where, outList);</a>
<a name="ln1407">		*mouseMessage = *newMessage;</a>
<a name="ln1408">		outList-&gt;AddItem(newMessage);</a>
<a name="ln1409"> </a>
<a name="ln1410">		return B_DISPATCH_MESSAGE;</a>
<a name="ln1411">	}</a>
<a name="ln1412"> </a>
<a name="ln1413">	return B_SKIP_MESSAGE;</a>
<a name="ln1414">}</a>
<a name="ln1415"> </a>
<a name="ln1416"> </a>
<a name="ln1417">//	#pragma mark - MoveMouseByCommandActuator</a>
<a name="ln1418"> </a>
<a name="ln1419"> </a>
<a name="ln1420">MoveMouseByCommandActuator::MoveMouseByCommandActuator(BMessage* from)</a>
<a name="ln1421">	:</a>
<a name="ln1422">	MoveMouseCommandActuator(from)</a>
<a name="ln1423">{</a>
<a name="ln1424">}</a>
<a name="ln1425"> </a>
<a name="ln1426"> </a>
<a name="ln1427">MoveMouseByCommandActuator::MoveMouseByCommandActuator(int32 argc, char** argv)</a>
<a name="ln1428">	:</a>
<a name="ln1429">	MoveMouseCommandActuator(argc, argv)</a>
<a name="ln1430">{</a>
<a name="ln1431">}</a>
<a name="ln1432"> </a>
<a name="ln1433"> </a>
<a name="ln1434">MoveMouseByCommandActuator::~MoveMouseByCommandActuator()</a>
<a name="ln1435">{</a>
<a name="ln1436">}</a>
<a name="ln1437"> </a>
<a name="ln1438"> </a>
<a name="ln1439">status_t MoveMouseByCommandActuator::Archive(BMessage* into, bool deep) const</a>
<a name="ln1440">{</a>
<a name="ln1441"> status_t ret = MoveMouseCommandActuator::Archive(into, deep);</a>
<a name="ln1442"> return ret;</a>
<a name="ln1443">}</a>
<a name="ln1444"> </a>
<a name="ln1445"> </a>
<a name="ln1446">BArchivable*</a>
<a name="ln1447">MoveMouseByCommandActuator::Instantiate(BMessage* from)</a>
<a name="ln1448">{</a>
<a name="ln1449">	if (validate_instantiation(from, &quot;MoveMouseByCommandActuator&quot;))</a>
<a name="ln1450">		return new MoveMouseByCommandActuator(from);</a>
<a name="ln1451">	else</a>
<a name="ln1452">		return NULL;</a>
<a name="ln1453">}</a>
<a name="ln1454"> </a>
<a name="ln1455"> </a>
<a name="ln1456">filter_result</a>
<a name="ln1457">MoveMouseByCommandActuator::KeyEvent(const BMessage* keyMessage, BList* outList,</a>
<a name="ln1458">	void** setAsyncData, BMessage* mouseMessage)</a>
<a name="ln1459">{</a>
<a name="ln1460">	if (IS_KEY_DOWN(keyMessage)) {</a>
<a name="ln1461">		// Get the current mouse position</a>
<a name="ln1462">		BPoint where;</a>
<a name="ln1463">		if (mouseMessage-&gt;FindPoint(&quot;where&quot;, &amp;where) == B_OK) {</a>
<a name="ln1464">			// Get the desired offset</a>
<a name="ln1465">			BPoint diff;</a>
<a name="ln1466">			CalculateCoords(diff.x, diff.y);</a>
<a name="ln1467">			where += diff;</a>
<a name="ln1468">			BMessage* newMessage = CreateMouseMessage(keyMessage, where, outList);</a>
<a name="ln1469">			*mouseMessage = *newMessage;</a>
<a name="ln1470">			outList-&gt;AddItem(newMessage);</a>
<a name="ln1471">			return B_DISPATCH_MESSAGE;</a>
<a name="ln1472">		}</a>
<a name="ln1473">	}</a>
<a name="ln1474">	return B_SKIP_MESSAGE;</a>
<a name="ln1475">}</a>
<a name="ln1476"> </a>
<a name="ln1477"> </a>
<a name="ln1478">//	#pragma mark - SendMessageCommandActuator</a>
<a name="ln1479"> </a>
<a name="ln1480"> </a>
<a name="ln1481">SendMessageCommandActuator::SendMessageCommandActuator(int32 argc, char** argv)</a>
<a name="ln1482">	:</a>
<a name="ln1483">	CommandActuator(argc, argv),</a>
<a name="ln1484">	fSignature((argc &gt; 1) ? argv[1] : &quot;&quot;)</a>
<a name="ln1485">{</a>
<a name="ln1486">	// Parse the what code. It may be in any of the following formats:</a>
<a name="ln1487">	// 12356 (int)</a>
<a name="ln1488">	// 'HELO' (chars enclosed in single quotes)</a>
<a name="ln1489">	// 0x12ab3c (hex)</a>
<a name="ln1490"> </a>
<a name="ln1491">	if (argc &gt; 2) {</a>
<a name="ln1492">		const char* whatStr = argv[2];</a>
<a name="ln1493">		if ((whatStr[0] == '\'')</a>
<a name="ln1494">			&amp;&amp; (strlen(whatStr) == 6)</a>
<a name="ln1495">			&amp;&amp; (whatStr[5] == '\'')) {</a>
<a name="ln1496">			// Translate the characters into the uint32 they stand for.</a>
<a name="ln1497">			// Note that we must do this in a byte-endian-independant fashion</a>
<a name="ln1498">			// (no casting!)</a>
<a name="ln1499">			fSendMessage.what = 0;</a>
<a name="ln1500">			uint32 mult = 1;</a>
<a name="ln1501">			for (int i = 0; i &lt; 4; i++) {</a>
<a name="ln1502">				fSendMessage.what += ((uint32)(whatStr[4 - i]))* mult;</a>
<a name="ln1503">				mult &lt;&lt;= 8;</a>
<a name="ln1504">			}</a>
<a name="ln1505">		} else if (strncmp(whatStr, &quot;0x&quot;, 2) == 0)</a>
<a name="ln1506">			// translate hex string to decimal</a>
<a name="ln1507">			fSendMessage.what = strtoul(&amp;whatStr[2], NULL, 16);</a>
<a name="ln1508">		else</a>
<a name="ln1509">			fSendMessage.what = atoi(whatStr);</a>
<a name="ln1510">	} else</a>
<a name="ln1511">		fSendMessage.what = 0;</a>
<a name="ln1512"> </a>
<a name="ln1513">	for (int i = 3; i &lt; argc; i++) {</a>
<a name="ln1514">		type_code tc = B_BOOL_TYPE;// default type when no value is present</a>
<a name="ln1515">		const char* arg = argv[i];</a>
<a name="ln1516">		BString argString(arg);</a>
<a name="ln1517">		const char* equals = strchr(arg, '=');</a>
<a name="ln1518">		const char* value = &quot;true&quot;;// default if no value is present</a>
<a name="ln1519"> </a>
<a name="ln1520">		if (equals) {</a>
<a name="ln1521">			tc = B_STRING_TYPE;// default type when value is present</a>
<a name="ln1522">			value = equals + 1;</a>
<a name="ln1523">			const char* colon = strchr(arg, ':');</a>
<a name="ln1524">			if (colon &gt; equals)</a>
<a name="ln1525">				colon = NULL;// colons after the equals sign don't count</a>
<a name="ln1526"> </a>
<a name="ln1527">			if (colon) {</a>
<a name="ln1528">				const char* typeStr = colon + 1;</a>
<a name="ln1529">				if (strncasecmp(typeStr, &quot;string&quot;, 6) == 0)</a>
<a name="ln1530">					tc = B_STRING_TYPE;</a>
<a name="ln1531">				else if (strncasecmp(typeStr, &quot;int8&quot;, 4) == 0)</a>
<a name="ln1532">					tc = B_INT8_TYPE;</a>
<a name="ln1533">				else if (strncasecmp(typeStr, &quot;int16&quot;, 5) == 0)</a>
<a name="ln1534">					tc = B_INT16_TYPE;</a>
<a name="ln1535">				else if (strncasecmp(typeStr, &quot;int32&quot;, 5) == 0)</a>
<a name="ln1536">					tc = B_INT32_TYPE;</a>
<a name="ln1537">				else if (strncasecmp(typeStr, &quot;int64&quot;, 5) == 0)</a>
<a name="ln1538">					tc = B_INT64_TYPE;</a>
<a name="ln1539">				else if (strncasecmp(typeStr, &quot;bool&quot;, 4) == 0)</a>
<a name="ln1540">					tc = B_BOOL_TYPE;</a>
<a name="ln1541">				else if (strncasecmp(typeStr, &quot;float&quot;, 5) == 0)</a>
<a name="ln1542">					tc = B_FLOAT_TYPE;</a>
<a name="ln1543">				else if (strncasecmp(typeStr, &quot;double&quot;, 6) == 0)</a>
<a name="ln1544">					tc = B_DOUBLE_TYPE;</a>
<a name="ln1545">				else if (strncasecmp(typeStr, &quot;point&quot;, 5) == 0)</a>
<a name="ln1546">					tc = B_POINT_TYPE;</a>
<a name="ln1547">				else if (strncasecmp(typeStr, &quot;rect&quot;, 4) == 0)</a>
<a name="ln1548">					tc = B_RECT_TYPE;</a>
<a name="ln1549"> </a>
<a name="ln1550">				// remove the colon and stuff</a>
<a name="ln1551">				argString = argString.Truncate(colon - arg);</a>
<a name="ln1552">			} else</a>
<a name="ln1553">				// remove the equals and arg</a>
<a name="ln1554">				argString = argString.Truncate(equals - arg);</a>
<a name="ln1555">		}</a>
<a name="ln1556"> </a>
<a name="ln1557">		switch(tc) {</a>
<a name="ln1558">			case B_STRING_TYPE:</a>
<a name="ln1559">				fSendMessage.AddString(argString.String(), value);</a>
<a name="ln1560">				break;</a>
<a name="ln1561"> </a>
<a name="ln1562">			case B_INT8_TYPE:</a>
<a name="ln1563">				fSendMessage.AddInt8(argString.String(), (int8)atoi(value));</a>
<a name="ln1564">				break;</a>
<a name="ln1565"> </a>
<a name="ln1566">			case B_INT16_TYPE:</a>
<a name="ln1567">				fSendMessage.AddInt16(argString.String(), (int16)atoi(value));</a>
<a name="ln1568">				break;</a>
<a name="ln1569"> </a>
<a name="ln1570">			case B_INT32_TYPE:</a>
<a name="ln1571">				fSendMessage.AddInt32(argString.String(), (int32)atoi(value));</a>
<a name="ln1572">				break;</a>
<a name="ln1573"> </a>
<a name="ln1574">			case B_INT64_TYPE:</a>
<a name="ln1575">				fSendMessage.AddInt64(argString.String(), (int64)atoi(value));</a>
<a name="ln1576">				break;</a>
<a name="ln1577"> </a>
<a name="ln1578">			case B_BOOL_TYPE:</a>
<a name="ln1579">				fSendMessage.AddBool(argString.String(), ((value[0] == 't')</a>
<a name="ln1580">					|| (value[0] == 'T')));</a>
<a name="ln1581">				break;</a>
<a name="ln1582"> </a>
<a name="ln1583">			case B_FLOAT_TYPE:</a>
<a name="ln1584">				fSendMessage.AddFloat(argString.String(), atof(value));</a>
<a name="ln1585">				break;</a>
<a name="ln1586"> </a>
<a name="ln1587">			case B_DOUBLE_TYPE:</a>
<a name="ln1588">				fSendMessage.AddDouble(argString.String(), (double)atof(value));</a>
<a name="ln1589">				break;</a>
<a name="ln1590"> </a>
<a name="ln1591">			case B_POINT_TYPE:</a>
<a name="ln1592">			{</a>
<a name="ln1593">				float pts[2] = {0.0f, 0.0f};</a>
<a name="ln1594">				_ParseFloatArgs(pts, 2, value);</a>
<a name="ln1595">				fSendMessage.AddPoint(argString.String(), BPoint(pts[0], pts[1]));</a>
<a name="ln1596">				break;</a>
<a name="ln1597">			}</a>
<a name="ln1598"> </a>
<a name="ln1599">			case B_RECT_TYPE:</a>
<a name="ln1600">			{</a>
<a name="ln1601">				float pts[4] = {0.0f, 0.0f, 0.0f, 0.0f};</a>
<a name="ln1602">				_ParseFloatArgs(pts, 4, value);</a>
<a name="ln1603">				fSendMessage.AddRect(argString.String(),</a>
<a name="ln1604">					BRect(pts[0], pts[1], pts[2], pts[3]));</a>
<a name="ln1605">				break;</a>
<a name="ln1606">			}</a>
<a name="ln1607">		}</a>
<a name="ln1608">	}</a>
<a name="ln1609">}</a>
<a name="ln1610"> </a>
<a name="ln1611"> </a>
<a name="ln1612">void</a>
<a name="ln1613">SendMessageCommandActuator::_ParseFloatArgs(float* args, int maxArgs,</a>
<a name="ln1614">	const char* str) const</a>
<a name="ln1615">{</a>
<a name="ln1616">	const char* next = str;</a>
<a name="ln1617">	for (int i = 0; i &lt; maxArgs; i++) {</a>
<a name="ln1618">		args[i] = atof(next);</a>
<a name="ln1619">		next = strchr(next, ',');</a>
<a name="ln1620">		if (next) next++;</a>
<a name="ln1621">		else break;</a>
<a name="ln1622">	}</a>
<a name="ln1623">}</a>
<a name="ln1624"> </a>
<a name="ln1625"> </a>
<a name="ln1626">SendMessageCommandActuator::SendMessageCommandActuator(BMessage* from)</a>
<a name="ln1627">	:</a>
<a name="ln1628">	CommandActuator(from)</a>
<a name="ln1629">{</a>
<a name="ln1630">	const char* temp;</a>
<a name="ln1631"> </a>
<a name="ln1632">	if (from-&gt;FindString(&quot;signature&quot;, 0, &amp;temp) == B_OK)</a>
<a name="ln1633">		fSignature = temp;</a>
<a name="ln1634"> </a>
<a name="ln1635">	(void) from-&gt;FindMessage(&quot;sendmsg&quot;, &amp;fSendMessage);</a>
<a name="ln1636">}</a>
<a name="ln1637"> </a>
<a name="ln1638"> </a>
<a name="ln1639">SendMessageCommandActuator::~SendMessageCommandActuator()</a>
<a name="ln1640">{</a>
<a name="ln1641">}</a>
<a name="ln1642"> </a>
<a name="ln1643"> </a>
<a name="ln1644">status_t</a>
<a name="ln1645">SendMessageCommandActuator::Archive(BMessage* into, bool deep) const</a>
<a name="ln1646">{</a>
<a name="ln1647">	status_t ret = CommandActuator::Archive(into, deep);</a>
<a name="ln1648">	into-&gt;AddString(&quot;signature&quot;, fSignature.String());</a>
<a name="ln1649">	into-&gt;AddMessage(&quot;sendmsg&quot;, &amp;fSendMessage);</a>
<a name="ln1650">	return ret;</a>
<a name="ln1651">}</a>
<a name="ln1652"> </a>
<a name="ln1653"> </a>
<a name="ln1654">filter_result</a>
<a name="ln1655">SendMessageCommandActuator::KeyEvent(const BMessage* keyMessage, BList* outList,</a>
<a name="ln1656">	void** setAsyncData, BMessage* mouseMessage)</a>
<a name="ln1657">{</a>
<a name="ln1658">	if (IS_KEY_DOWN(keyMessage))</a>
<a name="ln1659">		// cause KeyEventAsync() to be called asynchronously</a>
<a name="ln1660">		*setAsyncData = (void*) true;</a>
<a name="ln1661"> </a>
<a name="ln1662">	return B_SKIP_MESSAGE;</a>
<a name="ln1663">}</a>
<a name="ln1664"> </a>
<a name="ln1665"> </a>
<a name="ln1666">void</a>
<a name="ln1667">SendMessageCommandActuator::KeyEventAsync(const BMessage* keyMessage,</a>
<a name="ln1668">	void* asyncData)</a>
<a name="ln1669">{</a>
<a name="ln1670">	if (be_roster == NULL)</a>
<a name="ln1671">		return;</a>
<a name="ln1672"> </a>
<a name="ln1673">	BString string;</a>
<a name="ln1674">	if (fSignature.Length() == 0) {</a>
<a name="ln1675">		string &lt;&lt; &quot;SendMessage: Target application signature not specified&quot;;</a>
<a name="ln1676">		BAlert* alert = new BAlert(&quot;Shortcuts SendMessage error&quot;,</a>
<a name="ln1677">			string.String(), &quot;OK&quot;);</a>
<a name="ln1678">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln1679">		alert-&gt;Go(NULL);</a>
<a name="ln1680">	} else {</a>
<a name="ln1681">		status_t result = B_OK;</a>
<a name="ln1682">		BMessenger messenger(fSignature.String(), -1, &amp;result);</a>
<a name="ln1683">		if (result == B_OK)</a>
<a name="ln1684">			messenger.SendMessage(&amp;fSendMessage);</a>
<a name="ln1685">	}</a>
<a name="ln1686">}</a>
<a name="ln1687"> </a>
<a name="ln1688"> </a>
<a name="ln1689">BArchivable*</a>
<a name="ln1690">SendMessageCommandActuator::Instantiate(BMessage* from)</a>
<a name="ln1691">{</a>
<a name="ln1692">	if (validate_instantiation(from, &quot;SendMessageCommandActuator&quot;))</a>
<a name="ln1693">		return new SendMessageCommandActuator(from);</a>
<a name="ln1694">	else</a>
<a name="ln1695">		return NULL;</a>
<a name="ln1696">}</a>

</code></pre>
<div class="balloon" rel="198"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="1680"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="1021"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
