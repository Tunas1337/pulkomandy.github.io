
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>PrintJob.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2001-2009, Haiku.</a>
<a name="ln3"> * Distributed under the terms of the MIT license.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		I.R. Adema</a>
<a name="ln7"> *		Stefano Ceccherini (burton666@libero.it)</a>
<a name="ln8"> *		Michael Pfeiffer</a>
<a name="ln9"> *		julun &lt;host.haiku@gmx.de&gt;</a>
<a name="ln10"> */</a>
<a name="ln11"> </a>
<a name="ln12"> </a>
<a name="ln13">#include &lt;PrintJob.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;stdio.h&gt;</a>
<a name="ln16">#include &lt;stdlib.h&gt;</a>
<a name="ln17">#include &lt;string.h&gt;</a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;Alert.h&gt;</a>
<a name="ln20">#include &lt;Application.h&gt;</a>
<a name="ln21">#include &lt;Button.h&gt;</a>
<a name="ln22">#include &lt;Debug.h&gt;</a>
<a name="ln23">#include &lt;Entry.h&gt;</a>
<a name="ln24">#include &lt;File.h&gt;</a>
<a name="ln25">#include &lt;FindDirectory.h&gt;</a>
<a name="ln26">#include &lt;Messenger.h&gt;</a>
<a name="ln27">#include &lt;NodeInfo.h&gt;</a>
<a name="ln28">#include &lt;OS.h&gt;</a>
<a name="ln29">#include &lt;Path.h&gt;</a>
<a name="ln30">#include &lt;Region.h&gt;</a>
<a name="ln31">#include &lt;Roster.h&gt;</a>
<a name="ln32">#include &lt;SystemCatalog.h&gt;</a>
<a name="ln33">#include &lt;View.h&gt;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;AutoDeleter.h&gt;</a>
<a name="ln36">#include &lt;pr_server.h&gt;</a>
<a name="ln37">#include &lt;ViewPrivate.h&gt;</a>
<a name="ln38"> </a>
<a name="ln39">using BPrivate::gSystemCatalog;</a>
<a name="ln40"> </a>
<a name="ln41">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln42">#define B_TRANSLATION_CONTEXT &quot;PrintJob&quot;</a>
<a name="ln43"> </a>
<a name="ln44">#undef B_TRANSLATE</a>
<a name="ln45">#define B_TRANSLATE(str) \</a>
<a name="ln46">	gSystemCatalog.GetString(B_TRANSLATE_MARK(str), &quot;PrintJob&quot;)</a>
<a name="ln47"> </a>
<a name="ln48"> </a>
<a name="ln49">/*!	Summary of spool file:</a>
<a name="ln50"> </a>
<a name="ln51">		|-----------------------------------|</a>
<a name="ln52">		|         print_file_header         |</a>
<a name="ln53">		|-----------------------------------|</a>
<a name="ln54">		|    BMessage print_job_settings    |</a>
<a name="ln55">		|-----------------------------------|</a>
<a name="ln56">		|                                   |</a>
<a name="ln57">		| ********** (first page) ********* |</a>
<a name="ln58">		| *                               * |</a>
<a name="ln59">		| *         _page_header_         * |</a>
<a name="ln60">		| * ----------------------------- * |</a>
<a name="ln61">		| * |---------------------------| * |</a>
<a name="ln62">		| * |       BPoint where        | * |</a>
<a name="ln63">		| * |       BRect bounds        | * |</a>
<a name="ln64">		| * |       BPicture pic        | * |</a>
<a name="ln65">		| * |---------------------------| * |</a>
<a name="ln66">		| * |---------------------------| * |</a>
<a name="ln67">		| * |       BPoint where        | * |</a>
<a name="ln68">		| * |       BRect bounds        | * |</a>
<a name="ln69">		| * |       BPicture pic        | * |</a>
<a name="ln70">		| * |---------------------------| * |</a>
<a name="ln71">		| ********************************* |</a>
<a name="ln72">		|                                   |</a>
<a name="ln73">		| ********* (second page) ********* |</a>
<a name="ln74">		| *                               * |</a>
<a name="ln75">		| *         _page_header_         * |</a>
<a name="ln76">		| * ----------------------------- * |</a>
<a name="ln77">		| * |---------------------------| * |</a>
<a name="ln78">		| * |       BPoint where        | * |</a>
<a name="ln79">		| * |       BRect bounds        | * |</a>
<a name="ln80">		| * |       BPicture pic        | * |</a>
<a name="ln81">		| * |---------------------------| * |</a>
<a name="ln82">		| ********************************* |</a>
<a name="ln83">		|-----------------------------------|</a>
<a name="ln84"> </a>
<a name="ln85">	BeOS R5 print_file_header.version is 1 &lt;&lt; 16</a>
<a name="ln86">	BeOS R5 print_file_header.first_page is -1</a>
<a name="ln87"> </a>
<a name="ln88">	each page can consist of a collection of picture structures</a>
<a name="ln89">	remaining pages start at _page_header_.next_page of previous _page_header_</a>
<a name="ln90"> </a>
<a name="ln91">	See also: &quot;How to Write a BeOS R5 Printer Driver&quot; for description of spool</a>
<a name="ln92">	file format: http://haiku-os.org/documents/dev/how_to_write_a_printer_driver</a>
<a name="ln93">*/</a>
<a name="ln94"> </a>
<a name="ln95"> </a>
<a name="ln96">struct _page_header_ {</a>
<a name="ln97">	int32 number_of_pictures;</a>
<a name="ln98">	off_t next_page;</a>
<a name="ln99">	int32 reserved[10];</a>
<a name="ln100">} _PACKED;</a>
<a name="ln101"> </a>
<a name="ln102"> </a>
<a name="ln103">static void</a>
<a name="ln104">ShowError(const char* message)</a>
<a name="ln105">{</a>
<a name="ln106">	BAlert* alert = new BAlert(B_TRANSLATE(&quot;Error&quot;), message, B_TRANSLATE(&quot;OK&quot;));</a>
<a name="ln107">	alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln108">	alert-&gt;Go();</a>
<a name="ln109">}</a>
<a name="ln110"> </a>
<a name="ln111"> </a>
<a name="ln112">// #pragma mark -- PrintServerMessenger</a>
<a name="ln113"> </a>
<a name="ln114"> </a>
<a name="ln115">namespace BPrivate {</a>
<a name="ln116"> </a>
<a name="ln117"> </a>
<a name="ln118">class PrintServerMessenger {</a>
<a name="ln119">public:</a>
<a name="ln120">							PrintServerMessenger(uint32 what, BMessage* input);</a>
<a name="ln121">							~PrintServerMessenger();</a>
<a name="ln122"> </a>
<a name="ln123">			BMessage*		Request();</a>
<a name="ln124">			status_t		SendRequest();</a>
<a name="ln125"> </a>
<a name="ln126">			void			SetResult(BMessage* result);</a>
<a name="ln127">			BMessage*		Result() const { return fResult; }</a>
<a name="ln128"> </a>
<a name="ln129">	static	status_t		GetPrintServerMessenger(BMessenger&amp; messenger);</a>
<a name="ln130"> </a>
<a name="ln131">private:</a>
<a name="ln132">			void			RejectUserInput();</a>
<a name="ln133">			void			AllowUserInput();</a>
<a name="ln134">			void			DeleteSemaphore();</a>
<a name="ln135">	static	status_t		MessengerThread(void* data);</a>
<a name="ln136"> </a>
<a name="ln137">			uint32			fWhat;</a>
<a name="ln138">			BMessage*		fInput;</a>
<a name="ln139">			BMessage*		fRequest;</a>
<a name="ln140">			BMessage*		fResult;</a>
<a name="ln141">			sem_id			fThreadCompleted;</a>
<a name="ln142">			BAlert*			fHiddenApplicationModalWindow;</a>
<a name="ln143">};</a>
<a name="ln144"> </a>
<a name="ln145"> </a>
<a name="ln146">}	// namespace BPrivate</a>
<a name="ln147"> </a>
<a name="ln148"> </a>
<a name="ln149">using namespace BPrivate;</a>
<a name="ln150"> </a>
<a name="ln151"> </a>
<a name="ln152">// #pragma mark -- BPrintJob</a>
<a name="ln153"> </a>
<a name="ln154"> </a>
<a name="ln155">BPrintJob::BPrintJob(const char* jobName)</a>
<a name="ln156">	:</a>
<a name="ln157">	fPrintJobName(NULL),</a>
<a name="ln158">	fSpoolFile(NULL),</a>
<a name="ln159">	fError(B_NO_INIT),</a>
<a name="ln160">	fSetupMessage(NULL),</a>
<a name="ln161">	fDefaultSetupMessage(NULL),</a>
<a name="ln162">	fAbort(0),</a>
<a name="ln163">	fCurrentPageHeader(NULL)</a>
<a name="ln164">{</a>
<a name="ln165">	memset(&amp;fSpoolFileHeader, 0, sizeof(print_file_header));</a>
<a name="ln166"> </a>
<a name="ln167">	if (jobName != NULL &amp;&amp; jobName[0])</a>
<a name="ln168">		fPrintJobName = strdup(jobName);</a>
<a name="ln169"> </a>
<a name="ln170">	fCurrentPageHeader = new _page_header_;</a>
<a name="ln171">	if (fCurrentPageHeader != NULL)</a>
<a name="ln172">		memset(fCurrentPageHeader, 0, sizeof(_page_header_));</a>
<a name="ln173">}</a>
<a name="ln174"> </a>
<a name="ln175"> </a>
<a name="ln176">BPrintJob::~BPrintJob()</a>
<a name="ln177">{</a>
<a name="ln178">	CancelJob();</a>
<a name="ln179"> </a>
<a name="ln180">	free(fPrintJobName);</a>
<a name="ln181">	delete fSetupMessage;</a>
<a name="ln182">	delete fDefaultSetupMessage;</a>
<a name="ln183">	delete fCurrentPageHeader;</a>
<a name="ln184">}</a>
<a name="ln185"> </a>
<a name="ln186"> </a>
<a name="ln187">status_t</a>
<a name="ln188">BPrintJob::ConfigPage()</a>
<a name="ln189">{</a>
<a name="ln190">	PrintServerMessenger messenger(PSRV_SHOW_PAGE_SETUP, fSetupMessage);</a>
<a name="ln191">	status_t status = messenger.SendRequest();</a>
<a name="ln192">	if (status != B_OK)</a>
<a name="ln193">		return status;</a>
<a name="ln194"> </a>
<a name="ln195">	delete fSetupMessage;</a>
<a name="ln196">	fSetupMessage = messenger.Result();</a>
<a name="ln197">	_HandlePageSetup(fSetupMessage);</a>
<a name="ln198"> </a>
<a name="ln199">	return B_OK;</a>
<a name="ln200">}</a>
<a name="ln201"> </a>
<a name="ln202"> </a>
<a name="ln203">status_t</a>
<a name="ln204">BPrintJob::ConfigJob()</a>
<a name="ln205">{</a>
<a name="ln206">	PrintServerMessenger messenger(PSRV_SHOW_PRINT_SETUP, fSetupMessage);</a>
<a name="ln207">	status_t status = messenger.SendRequest();</a>
<a name="ln208">	if (status != B_OK)</a>
<a name="ln209">		return status;</a>
<a name="ln210"> </a>
<a name="ln211">	delete fSetupMessage;</a>
<a name="ln212">	fSetupMessage = messenger.Result();</a>
<a name="ln213">	if (!_HandlePrintSetup(fSetupMessage))</a>
<a name="ln214">		return B_ERROR;</a>
<a name="ln215"> </a>
<a name="ln216">	fError = B_OK;</a>
<a name="ln217">	return B_OK;</a>
<a name="ln218">}</a>
<a name="ln219"> </a>
<a name="ln220"> </a>
<a name="ln221">void</a>
<a name="ln222">BPrintJob::BeginJob()</a>
<a name="ln223">{</a>
<a name="ln224">	fError = B_ERROR;</a>
<a name="ln225"> </a>
<a name="ln226">	// can not start a new job until it has been commited or cancelled</a>
<a name="ln227">	if (fSpoolFile != NULL || fCurrentPageHeader == NULL)</a>
<a name="ln228">		return;</a>
<a name="ln229"> </a>
<a name="ln230">	// TODO show alert, setup message is required</a>
<a name="ln231">	if (fSetupMessage == NULL)</a>
<a name="ln232">		return;</a>
<a name="ln233"> </a>
<a name="ln234">	// create spool file</a>
<a name="ln235">	BPath path;</a>
<a name="ln236">	status_t status = find_directory(B_USER_PRINTERS_DIRECTORY, &amp;path);</a>
<a name="ln237">	if (status != B_OK)</a>
<a name="ln238">		return;</a>
<a name="ln239"> </a>
<a name="ln240">	char *printer = _GetCurrentPrinterName();</a>
<a name="ln241">	if (printer == NULL)</a>
<a name="ln242">		return;</a>
<a name="ln243">	MemoryDeleter _(printer);</a>
<a name="ln244"> </a>
<a name="ln245">	path.Append(printer);</a>
<a name="ln246"> </a>
<a name="ln247">	char mangledName[B_FILE_NAME_LENGTH];</a>
<a name="ln248">	_GetMangledName(mangledName, B_FILE_NAME_LENGTH);</a>
<a name="ln249"> </a>
<a name="ln250">	path.Append(mangledName);</a>
<a name="ln251">	if (path.InitCheck() != B_OK)</a>
<a name="ln252">		return;</a>
<a name="ln253"> </a>
<a name="ln254">	// TODO: fSpoolFileName should store the name only (not path which can be</a>
<a name="ln255">	// 1024 bytes long)</a>
<a name="ln256">	strlcpy(fSpoolFileName, path.Path(), sizeof(fSpoolFileName));</a>
<a name="ln257">	fSpoolFile = new BFile(fSpoolFileName, B_READ_WRITE | B_CREATE_FILE);</a>
<a name="ln258"> </a>
<a name="ln259">	if (fSpoolFile-&gt;InitCheck() != B_OK) {</a>
<a name="ln260">		CancelJob();</a>
<a name="ln261">		return;</a>
<a name="ln262">	}</a>
<a name="ln263"> </a>
<a name="ln264">	// add print_file_header</a>
<a name="ln265">	// page_count is updated in CommitJob()</a>
<a name="ln266">	// on BeOS R5 the offset to the first page was always -1</a>
<a name="ln267">	fSpoolFileHeader.version = 1 &lt;&lt; 16;</a>
<a name="ln268">	fSpoolFileHeader.page_count = 0;</a>
<a name="ln269">	fSpoolFileHeader.first_page = (off_t)-1;</a>
<a name="ln270"> </a>
<a name="ln271">	if (fSpoolFile-&gt;Write(&amp;fSpoolFileHeader, sizeof(print_file_header))</a>
<a name="ln272">			!= sizeof(print_file_header)) {</a>
<a name="ln273">		CancelJob();</a>
<a name="ln274">		return;</a>
<a name="ln275">	}</a>
<a name="ln276"> </a>
<a name="ln277">	// add printer settings message</a>
<a name="ln278">	if (!fSetupMessage-&gt;HasString(PSRV_FIELD_CURRENT_PRINTER))</a>
<a name="ln279">		fSetupMessage-&gt;AddString(PSRV_FIELD_CURRENT_PRINTER, printer);</a>
<a name="ln280"> </a>
<a name="ln281">	_AddSetupSpec();</a>
<a name="ln282">	_NewPage();</a>
<a name="ln283"> </a>
<a name="ln284">	// state variables</a>
<a name="ln285">	fAbort = 0;</a>
<a name="ln286">	fError = B_OK;</a>
<a name="ln287">}</a>
<a name="ln288"> </a>
<a name="ln289"> </a>
<a name="ln290">void</a>
<a name="ln291">BPrintJob::CommitJob()</a>
<a name="ln292">{</a>
<a name="ln293">	if (fSpoolFile == NULL)</a>
<a name="ln294">		return;</a>
<a name="ln295"> </a>
<a name="ln296">	if (fSpoolFileHeader.page_count == 0) {</a>
<a name="ln297">		ShowError(B_TRANSLATE(&quot;No pages to print!&quot;));</a>
<a name="ln298">		CancelJob();</a>
<a name="ln299">		return;</a>
<a name="ln300">	}</a>
<a name="ln301"> </a>
<a name="ln302">	// update spool file</a>
<a name="ln303">	_EndLastPage();</a>
<a name="ln304"> </a>
<a name="ln305">	// write spool file header</a>
<a name="ln306">	fSpoolFile-&gt;Seek(0, SEEK_SET);</a>
<a name="ln307">	fSpoolFile-&gt;Write(&amp;fSpoolFileHeader, sizeof(print_file_header));</a>
<a name="ln308"> </a>
<a name="ln309">	// set file attributes</a>
<a name="ln310">	app_info appInfo;</a>
<a name="ln311">	be_app-&gt;GetAppInfo(&amp;appInfo);</a>
<a name="ln312">	const char* printerName = &quot;&quot;;</a>
<a name="ln313">	fSetupMessage-&gt;FindString(PSRV_FIELD_CURRENT_PRINTER, &amp;printerName);</a>
<a name="ln314"> </a>
<a name="ln315">	BNodeInfo info(fSpoolFile);</a>
<a name="ln316">	info.SetType(PSRV_SPOOL_FILETYPE);</a>
<a name="ln317"> </a>
<a name="ln318">	fSpoolFile-&gt;WriteAttr(PSRV_SPOOL_ATTR_PAGECOUNT, B_INT32_TYPE, 0,</a>
<a name="ln319">		&amp;fSpoolFileHeader.page_count, sizeof(int32));</a>
<a name="ln320">	fSpoolFile-&gt;WriteAttr(PSRV_SPOOL_ATTR_DESCRIPTION, B_STRING_TYPE, 0,</a>
<a name="ln321">		fPrintJobName, strlen(fPrintJobName) + 1);</a>
<a name="ln322">	fSpoolFile-&gt;WriteAttr(PSRV_SPOOL_ATTR_PRINTER, B_STRING_TYPE, 0,</a>
<a name="ln323">		printerName, strlen(printerName) + 1);</a>
<a name="ln324">	fSpoolFile-&gt;WriteAttr(PSRV_SPOOL_ATTR_STATUS, B_STRING_TYPE, 0,</a>
<a name="ln325">		PSRV_JOB_STATUS_WAITING, strlen(PSRV_JOB_STATUS_WAITING) + 1);</a>
<a name="ln326">	fSpoolFile-&gt;WriteAttr(PSRV_SPOOL_ATTR_MIMETYPE, B_STRING_TYPE, 0,</a>
<a name="ln327">		appInfo.signature, strlen(appInfo.signature) + 1);</a>
<a name="ln328"> </a>
<a name="ln329">	delete fSpoolFile;</a>
<a name="ln330">	fSpoolFile = NULL;</a>
<a name="ln331">	fError = B_ERROR;</a>
<a name="ln332"> </a>
<a name="ln333">	// notify print server</a>
<a name="ln334">	BMessenger printServer;</a>
<a name="ln335">	if (PrintServerMessenger::GetPrintServerMessenger(printServer) != B_OK)</a>
<a name="ln336">		return;</a>
<a name="ln337"> </a>
<a name="ln338">	BMessage request(PSRV_PRINT_SPOOLED_JOB);</a>
<a name="ln339">	request.AddString(&quot;JobName&quot;, fPrintJobName);</a>
<a name="ln340">	request.AddString(&quot;Spool File&quot;, fSpoolFileName);</a>
<a name="ln341"> </a>
<a name="ln342">	BMessage reply;</a>
<a name="ln343">	printServer.SendMessage(&amp;request, &amp;reply);</a>
<a name="ln344">}</a>
<a name="ln345"> </a>
<a name="ln346"> </a>
<a name="ln347">void</a>
<a name="ln348">BPrintJob::CancelJob()</a>
<a name="ln349">{</a>
<a name="ln350">	if (fSpoolFile == NULL)</a>
<a name="ln351">		return;</a>
<a name="ln352"> </a>
<a name="ln353">	fAbort = 1;</a>
<a name="ln354">	BEntry(fSpoolFileName).Remove();</a>
<a name="ln355">	delete fSpoolFile;</a>
<a name="ln356">	fSpoolFile = NULL;</a>
<a name="ln357">}</a>
<a name="ln358"> </a>
<a name="ln359"> </a>
<a name="ln360">void</a>
<a name="ln361">BPrintJob::SpoolPage()</a>
<a name="ln362">{</a>
<a name="ln363">	if (fSpoolFile == NULL)</a>
<a name="ln364">		return;</a>
<a name="ln365"> </a>
<a name="ln366">	if (fCurrentPageHeader-&gt;number_of_pictures == 0)</a>
<a name="ln367">		return;</a>
<a name="ln368"> </a>
<a name="ln369">	fSpoolFileHeader.page_count++;</a>
<a name="ln370">	fSpoolFile-&gt;Seek(0, SEEK_END);</a>
<a name="ln371">	if (fCurrentPageHeaderOffset) {</a>
<a name="ln372">		// update last written page_header</a>
<a name="ln373">		fCurrentPageHeader-&gt;next_page = fSpoolFile-&gt;Position();</a>
<a name="ln374">		fSpoolFile-&gt;Seek(fCurrentPageHeaderOffset, SEEK_SET);</a>
<a name="ln375">		fSpoolFile-&gt;Write(fCurrentPageHeader, sizeof(_page_header_));</a>
<a name="ln376">		fSpoolFile-&gt;Seek(fCurrentPageHeader-&gt;next_page, SEEK_SET);</a>
<a name="ln377">	}</a>
<a name="ln378"> </a>
<a name="ln379">	_NewPage();</a>
<a name="ln380">}</a>
<a name="ln381"> </a>
<a name="ln382"> </a>
<a name="ln383">bool</a>
<a name="ln384">BPrintJob::CanContinue()</a>
<a name="ln385">{</a>
<a name="ln386">	// Check if our local error storage is still B_OK</a>
<a name="ln387">	return fError == B_OK &amp;&amp; !fAbort;</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390"> </a>
<a name="ln391">void</a>
<a name="ln392">BPrintJob::DrawView(BView* view, BRect rect, BPoint where)</a>
<a name="ln393">{</a>
<a name="ln394">	if (fSpoolFile == NULL)</a>
<a name="ln395">		return;</a>
<a name="ln396"> </a>
<a name="ln397">	if (view == NULL)</a>
<a name="ln398">		return;</a>
<a name="ln399"> </a>
<a name="ln400">	if (view-&gt;LockLooper()) {</a>
<a name="ln401">		BPicture picture;</a>
<a name="ln402">		_RecurseView(view, B_ORIGIN - rect.LeftTop(), &amp;picture, rect);</a>
<a name="ln403">		_AddPicture(picture, rect, where);</a>
<a name="ln404">		view-&gt;UnlockLooper();</a>
<a name="ln405">	}</a>
<a name="ln406">}</a>
<a name="ln407"> </a>
<a name="ln408"> </a>
<a name="ln409">BMessage*</a>
<a name="ln410">BPrintJob::Settings()</a>
<a name="ln411">{</a>
<a name="ln412">	if (fSetupMessage == NULL)</a>
<a name="ln413">		return NULL;</a>
<a name="ln414"> </a>
<a name="ln415">	return new BMessage(*fSetupMessage);</a>
<a name="ln416">}</a>
<a name="ln417"> </a>
<a name="ln418"> </a>
<a name="ln419">void</a>
<a name="ln420">BPrintJob::SetSettings(BMessage* message)</a>
<a name="ln421">{</a>
<a name="ln422">	if (message != NULL)</a>
<a name="ln423">		_HandlePrintSetup(message);</a>
<a name="ln424"> </a>
<a name="ln425">	delete fSetupMessage;</a>
<a name="ln426">	fSetupMessage = message;</a>
<a name="ln427">}</a>
<a name="ln428"> </a>
<a name="ln429"> </a>
<a name="ln430">bool</a>
<a name="ln431">BPrintJob::IsSettingsMessageValid(BMessage* message) const</a>
<a name="ln432">{</a>
<a name="ln433">	char* printerName = _GetCurrentPrinterName();</a>
<a name="ln434">	if (printerName == NULL)</a>
<a name="ln435">		return false;</a>
<a name="ln436"> </a>
<a name="ln437">	const char* name = NULL;</a>
<a name="ln438">	// The passed message is valid if it contains the right printer name.</a>
<a name="ln439">	bool valid = message != NULL</a>
<a name="ln440">		&amp;&amp; message-&gt;FindString(&quot;printer_name&quot;, &amp;name) == B_OK</a>
<a name="ln441">		&amp;&amp; strcmp(printerName, name) == 0;</a>
<a name="ln442"> </a>
<a name="ln443">	free(printerName);</a>
<a name="ln444">	return valid;</a>
<a name="ln445">}</a>
<a name="ln446"> </a>
<a name="ln447"> </a>
<a name="ln448">// Either SetSettings() or ConfigPage() has to be called prior</a>
<a name="ln449">// to any of the getters otherwise they return undefined values.</a>
<a name="ln450">BRect</a>
<a name="ln451">BPrintJob::PaperRect()</a>
<a name="ln452">{</a>
<a name="ln453">	if (fDefaultSetupMessage == NULL)</a>
<a name="ln454">		_LoadDefaultSettings();</a>
<a name="ln455"> </a>
<a name="ln456">	return fPaperSize;</a>
<a name="ln457">}</a>
<a name="ln458"> </a>
<a name="ln459"> </a>
<a name="ln460">BRect</a>
<a name="ln461">BPrintJob::PrintableRect()</a>
<a name="ln462">{</a>
<a name="ln463">	if (fDefaultSetupMessage == NULL)</a>
<a name="ln464">		_LoadDefaultSettings();</a>
<a name="ln465"> </a>
<a name="ln466">	return fUsableSize;</a>
<a name="ln467">}</a>
<a name="ln468"> </a>
<a name="ln469"> </a>
<a name="ln470">void</a>
<a name="ln471">BPrintJob::GetResolution(int32* xdpi, int32* ydpi)</a>
<a name="ln472">{</a>
<a name="ln473">	if (fDefaultSetupMessage == NULL)</a>
<a name="ln474">		_LoadDefaultSettings();</a>
<a name="ln475"> </a>
<a name="ln476">	if (xdpi != NULL)</a>
<a name="ln477">		*xdpi = fXResolution;</a>
<a name="ln478"> </a>
<a name="ln479">	if (ydpi != NULL)</a>
<a name="ln480">		*ydpi = fYResolution;</a>
<a name="ln481">}</a>
<a name="ln482"> </a>
<a name="ln483"> </a>
<a name="ln484">int32</a>
<a name="ln485">BPrintJob::FirstPage()</a>
<a name="ln486">{</a>
<a name="ln487">	return fFirstPage;</a>
<a name="ln488">}</a>
<a name="ln489"> </a>
<a name="ln490"> </a>
<a name="ln491">int32</a>
<a name="ln492">BPrintJob::LastPage()</a>
<a name="ln493">{</a>
<a name="ln494">	return fLastPage;</a>
<a name="ln495">}</a>
<a name="ln496"> </a>
<a name="ln497"> </a>
<a name="ln498">int32</a>
<a name="ln499">BPrintJob::PrinterType(void*) const</a>
<a name="ln500">{</a>
<a name="ln501">	BMessenger printServer;</a>
<a name="ln502">	if (PrintServerMessenger::GetPrintServerMessenger(printServer) != B_OK)</a>
<a name="ln503">		return B_COLOR_PRINTER; // default</a>
<a name="ln504"> </a>
<a name="ln505">	BMessage reply;</a>
<a name="ln506">	BMessage message(PSRV_GET_ACTIVE_PRINTER);</a>
<a name="ln507">	printServer.SendMessage(&amp;message, &amp;reply);</a>
<a name="ln508"> </a>
<a name="ln509">	int32 type;</a>
<a name="ln510">	if (reply.FindInt32(&quot;color&quot;, &amp;type) != B_OK)</a>
<a name="ln511">		return B_COLOR_PRINTER; // default</a>
<a name="ln512"> </a>
<a name="ln513">	return type;</a>
<a name="ln514">}</a>
<a name="ln515"> </a>
<a name="ln516"> </a>
<a name="ln517">// #pragma mark - private</a>
<a name="ln518"> </a>
<a name="ln519"> </a>
<a name="ln520">void</a>
<a name="ln521">BPrintJob::_RecurseView(BView* view, BPoint origin, BPicture* picture,</a>
<a name="ln522">	BRect rect)</a>
<a name="ln523">{</a>
<a name="ln524">	ASSERT(picture != NULL);</a>
<a name="ln525"> </a>
<a name="ln526">	BRegion region;</a>
<a name="ln527">	region.Set(BRect(rect.left, rect.top, rect.right, rect.bottom));</a>
<a name="ln528">	view-&gt;fState-&gt;print_rect = rect;</a>
<a name="ln529"> </a>
<a name="ln530">	view-&gt;AppendToPicture(picture);</a>
<a name="ln531">	view-&gt;PushState();</a>
<a name="ln532">	view-&gt;SetOrigin(origin);</a>
<a name="ln533">	view-&gt;ConstrainClippingRegion(&amp;region);</a>
<a name="ln534"> </a>
<a name="ln535">	if (view-&gt;ViewColor() != B_TRANSPARENT_COLOR) {</a>
<a name="ln536">		rgb_color highColor = view-&gt;HighColor();</a>
<a name="ln537">		view-&gt;SetHighColor(view-&gt;ViewColor());</a>
<a name="ln538">		view-&gt;FillRect(rect);</a>
<a name="ln539">		view-&gt;SetHighColor(highColor);</a>
<a name="ln540">	}</a>
<a name="ln541"> </a>
<a name="ln542">	if ((view-&gt;Flags() &amp; B_WILL_DRAW) != 0) {</a>
<a name="ln543">		view-&gt;fIsPrinting = true;</a>
<a name="ln544">		view-&gt;Draw(rect);</a>
<a name="ln545">		view-&gt;fIsPrinting = false;</a>
<a name="ln546">	}</a>
<a name="ln547"> </a>
<a name="ln548">	view-&gt;PopState();</a>
<a name="ln549">	view-&gt;EndPicture();</a>
<a name="ln550"> </a>
<a name="ln551">	BView* child = view-&gt;ChildAt(0);</a>
<a name="ln552">	while (child != NULL) {</a>
<a name="ln553">		if (!child-&gt;IsHidden()) {</a>
<a name="ln554">			BPoint leftTop(view-&gt;Bounds().LeftTop() + child-&gt;Frame().LeftTop());</a>
<a name="ln555">			BRect printRect(rect.OffsetToCopy(rect.LeftTop() - leftTop)</a>
<a name="ln556">				&amp; child-&gt;Bounds());</a>
<a name="ln557">			if (printRect.IsValid())</a>
<a name="ln558">				_RecurseView(child, origin + leftTop, picture, printRect);</a>
<a name="ln559">		}</a>
<a name="ln560">		child = child-&gt;NextSibling();</a>
<a name="ln561">	}</a>
<a name="ln562"> </a>
<a name="ln563">	if ((view-&gt;Flags() &amp; B_DRAW_ON_CHILDREN) != 0) {</a>
<a name="ln564">		view-&gt;AppendToPicture(picture);</a>
<a name="ln565">		view-&gt;PushState();</a>
<a name="ln566">		view-&gt;SetOrigin(origin);</a>
<a name="ln567">		view-&gt;ConstrainClippingRegion(&amp;region);</a>
<a name="ln568">		view-&gt;fIsPrinting = true;</a>
<a name="ln569">		view-&gt;DrawAfterChildren(rect);</a>
<a name="ln570">		view-&gt;fIsPrinting = false;</a>
<a name="ln571">		view-&gt;PopState();</a>
<a name="ln572">		view-&gt;EndPicture();</a>
<a name="ln573">	}</a>
<a name="ln574">}</a>
<a name="ln575"> </a>
<a name="ln576"> </a>
<a name="ln577">void</a>
<a name="ln578">BPrintJob::_GetMangledName(char* buffer, size_t bufferSize) const</a>
<a name="ln579">{</a>
<a name="ln580">	snprintf(buffer, bufferSize, &quot;%s@%&quot; B_PRId64, fPrintJobName,</a>
<a name="ln581">		system_time() / 1000);</a>
<a name="ln582">}</a>
<a name="ln583"> </a>
<a name="ln584"> </a>
<a name="ln585">void</a>
<a name="ln586">BPrintJob::_HandlePageSetup(BMessage* setup)</a>
<a name="ln587">{</a>
<a name="ln588">	setup-&gt;FindRect(PSRV_FIELD_PRINTABLE_RECT, &amp;fUsableSize);</a>
<a name="ln589">	setup-&gt;FindRect(PSRV_FIELD_PAPER_RECT, &amp;fPaperSize);</a>
<a name="ln590"> </a>
<a name="ln591">	// TODO verify data type (taken from libprint)</a>
<a name="ln592">	int64 valueInt64;</a>
<a name="ln593">	if (setup-&gt;FindInt64(PSRV_FIELD_XRES, &amp;valueInt64) == B_OK)</a>
<a name="ln594">		fXResolution = (short)valueInt64;</a>
<a name="ln595"> </a>
<a name="ln596">	if (setup-&gt;FindInt64(PSRV_FIELD_YRES, &amp;valueInt64) == B_OK)</a>
<a name="ln597">		fYResolution = (short)valueInt64;</a>
<a name="ln598">}</a>
<a name="ln599"> </a>
<a name="ln600"> </a>
<a name="ln601">bool</a>
<a name="ln602">BPrintJob::_HandlePrintSetup(BMessage* message)</a>
<a name="ln603">{</a>
<a name="ln604">	_HandlePageSetup(message);</a>
<a name="ln605"> </a>
<a name="ln606">	bool valid = true;</a>
<a name="ln607">	if (message-&gt;FindInt32(PSRV_FIELD_FIRST_PAGE, &amp;fFirstPage) != B_OK)</a>
<a name="ln608">		valid = false;</a>
<a name="ln609"> </a>
<a name="ln610">	if (message-&gt;FindInt32(PSRV_FIELD_LAST_PAGE, &amp;fLastPage) != B_OK)</a>
<a name="ln611">		valid = false;</a>
<a name="ln612"> </a>
<a name="ln613">	return valid;</a>
<a name="ln614">}</a>
<a name="ln615"> </a>
<a name="ln616"> </a>
<a name="ln617">void</a>
<a name="ln618">BPrintJob::_NewPage()</a>
<a name="ln619">{</a>
<a name="ln620">	// init, write new page_header</a>
<a name="ln621">	fCurrentPageHeader-&gt;next_page = 0;</a>
<a name="ln622">	fCurrentPageHeader-&gt;number_of_pictures = 0;</a>
<a name="ln623">	fCurrentPageHeaderOffset = fSpoolFile-&gt;Position();</a>
<a name="ln624">	fSpoolFile-&gt;Write(fCurrentPageHeader, sizeof(_page_header_));</a>
<a name="ln625">}</a>
<a name="ln626"> </a>
<a name="ln627"> </a>
<a name="ln628">void</a>
<a name="ln629">BPrintJob::_EndLastPage()</a>
<a name="ln630">{</a>
<a name="ln631">	if (!fSpoolFile)</a>
<a name="ln632">		return;</a>
<a name="ln633"> </a>
<a name="ln634">	if (fCurrentPageHeader-&gt;number_of_pictures == 0)</a>
<a name="ln635">		return;</a>
<a name="ln636"> </a>
<a name="ln637">	fSpoolFileHeader.page_count++;</a>
<a name="ln638">	fSpoolFile-&gt;Seek(0, SEEK_END);</a>
<a name="ln639">	if (fCurrentPageHeaderOffset) {</a>
<a name="ln640">		fCurrentPageHeader-&gt;next_page = 0;</a>
<a name="ln641">		fSpoolFile-&gt;Seek(fCurrentPageHeaderOffset, SEEK_SET);</a>
<a name="ln642">		fSpoolFile-&gt;Write(fCurrentPageHeader, sizeof(_page_header_));</a>
<a name="ln643">		fSpoolFile-&gt;Seek(0, SEEK_END);</a>
<a name="ln644">	}</a>
<a name="ln645">}</a>
<a name="ln646"> </a>
<a name="ln647"> </a>
<a name="ln648">void</a>
<a name="ln649">BPrintJob::_AddSetupSpec()</a>
<a name="ln650">{</a>
<a name="ln651">	fSetupMessage-&gt;Flatten(fSpoolFile);</a>
<a name="ln652">}</a>
<a name="ln653"> </a>
<a name="ln654"> </a>
<a name="ln655">void</a>
<a name="ln656">BPrintJob::_AddPicture(BPicture&amp; picture, BRect&amp; rect, BPoint&amp; where)</a>
<a name="ln657">{</a>
<a name="ln658">	ASSERT(fSpoolFile != NULL);</a>
<a name="ln659"> </a>
<a name="ln660">	fCurrentPageHeader-&gt;number_of_pictures++;</a>
<a name="ln661">	fSpoolFile-&gt;Write(&amp;where, sizeof(BRect));</a>
<a name="ln662">	fSpoolFile-&gt;Write(&amp;rect, sizeof(BPoint));</a>
<a name="ln663">	picture.Flatten(fSpoolFile);</a>
<a name="ln664">}</a>
<a name="ln665"> </a>
<a name="ln666"> </a>
<a name="ln667">/*!	Returns a copy of the applications default printer name or NULL if it</a>
<a name="ln668">	could not be obtained. Caller is responsible to free the string using</a>
<a name="ln669">	free().</a>
<a name="ln670">*/</a>
<a name="ln671">char*</a>
<a name="ln672">BPrintJob::_GetCurrentPrinterName() const</a>
<a name="ln673">{</a>
<a name="ln674">	BMessenger printServer;</a>
<a name="ln675">	if (PrintServerMessenger::GetPrintServerMessenger(printServer) != B_OK)</a>
<a name="ln676">		return NULL;</a>
<a name="ln677"> </a>
<a name="ln678">	const char* printerName = NULL;</a>
<a name="ln679"> </a>
<a name="ln680">	BMessage reply;</a>
<a name="ln681">	BMessage message(PSRV_GET_ACTIVE_PRINTER);</a>
<a name="ln682">	if (printServer.SendMessage(&amp;message, &amp;reply) == B_OK)</a>
<a name="ln683">		reply.FindString(&quot;printer_name&quot;, &amp;printerName);</a>
<a name="ln684"> </a>
<a name="ln685">	if (printerName == NULL)</a>
<a name="ln686">		return NULL;</a>
<a name="ln687"> </a>
<a name="ln688">	return strdup(printerName);</a>
<a name="ln689">}</a>
<a name="ln690"> </a>
<a name="ln691"> </a>
<a name="ln692">void</a>
<a name="ln693">BPrintJob::_LoadDefaultSettings()</a>
<a name="ln694">{</a>
<a name="ln695">	BMessenger printServer;</a>
<a name="ln696">	if (PrintServerMessenger::GetPrintServerMessenger(printServer) != B_OK)</a>
<a name="ln697">		return;</a>
<a name="ln698"> </a>
<a name="ln699">	BMessage message(PSRV_GET_DEFAULT_SETTINGS);</a>
<a name="ln700">	BMessage* reply = new BMessage;</a>
<a name="ln701"> </a>
<a name="ln702">	printServer.SendMessage(&amp;message, reply);</a>
<a name="ln703"> </a>
<a name="ln704">	// Only override our settings if we don't have any settings yet</a>
<a name="ln705">	if (fSetupMessage == NULL)</a>
<a name="ln706">		_HandlePrintSetup(reply);</a>
<a name="ln707"> </a>
<a name="ln708">	delete fDefaultSetupMessage;</a>
<a name="ln709">	fDefaultSetupMessage = reply;</a>
<a name="ln710">}</a>
<a name="ln711"> </a>
<a name="ln712"> </a>
<a name="ln713">void BPrintJob::_ReservedPrintJob1() {}</a>
<a name="ln714">void BPrintJob::_ReservedPrintJob2() {}</a>
<a name="ln715">void BPrintJob::_ReservedPrintJob3() {}</a>
<a name="ln716">void BPrintJob::_ReservedPrintJob4() {}</a>
<a name="ln717"> </a>
<a name="ln718"> </a>
<a name="ln719">// #pragma mark -- PrintServerMessenger</a>
<a name="ln720"> </a>
<a name="ln721"> </a>
<a name="ln722">namespace BPrivate {</a>
<a name="ln723"> </a>
<a name="ln724"> </a>
<a name="ln725">PrintServerMessenger::PrintServerMessenger(uint32 what, BMessage *input)</a>
<a name="ln726">	:</a>
<a name="ln727">	fWhat(what),</a>
<a name="ln728">	fInput(input),</a>
<a name="ln729">	fRequest(NULL),</a>
<a name="ln730">	fResult(NULL),</a>
<a name="ln731">	fThreadCompleted(-1),</a>
<a name="ln732">	fHiddenApplicationModalWindow(NULL)</a>
<a name="ln733">{</a>
<a name="ln734">	RejectUserInput();</a>
<a name="ln735">}</a>
<a name="ln736"> </a>
<a name="ln737"> </a>
<a name="ln738">PrintServerMessenger::~PrintServerMessenger()</a>
<a name="ln739">{</a>
<a name="ln740">	DeleteSemaphore();</a>
<a name="ln741">		// in case SendRequest could not start the thread</a>
<a name="ln742">	delete fRequest; fRequest = NULL;</a>
<a name="ln743">	AllowUserInput();</a>
<a name="ln744">}</a>
<a name="ln745"> </a>
<a name="ln746"> </a>
<a name="ln747">void</a>
<a name="ln748">PrintServerMessenger::RejectUserInput()</a>
<a name="ln749">{</a>
<a name="ln750">	fHiddenApplicationModalWindow = new BAlert(&quot;bogus&quot;, &quot;app_modal&quot;, &quot;OK&quot;);</a>
<a name="ln751">	fHiddenApplicationModalWindow-&gt;DefaultButton()-&gt;SetEnabled(false);</a>
<a name="ln752">	fHiddenApplicationModalWindow-&gt;SetDefaultButton(NULL);</a>
<a name="ln753">	fHiddenApplicationModalWindow-&gt;SetFlags(fHiddenApplicationModalWindow-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln754">	fHiddenApplicationModalWindow-&gt;MoveTo(-65000, -65000);</a>
<a name="ln755">	fHiddenApplicationModalWindow-&gt;Go(NULL);</a>
<a name="ln756">}</a>
<a name="ln757"> </a>
<a name="ln758"> </a>
<a name="ln759">void</a>
<a name="ln760">PrintServerMessenger::AllowUserInput()</a>
<a name="ln761">{</a>
<a name="ln762">	fHiddenApplicationModalWindow-&gt;Lock();</a>
<a name="ln763">	fHiddenApplicationModalWindow-&gt;Quit();</a>
<a name="ln764">}</a>
<a name="ln765"> </a>
<a name="ln766"> </a>
<a name="ln767">void</a>
<a name="ln768">PrintServerMessenger::DeleteSemaphore()</a>
<a name="ln769">{</a>
<a name="ln770">	if (fThreadCompleted &gt;= B_OK) {</a>
<a name="ln771">		sem_id id = fThreadCompleted;</a>
<a name="ln772">		fThreadCompleted = -1;</a>
<a name="ln773">		delete_sem(id);</a>
<a name="ln774">	}</a>
<a name="ln775">}</a>
<a name="ln776"> </a>
<a name="ln777"> </a>
<a name="ln778">status_t</a>
<a name="ln779">PrintServerMessenger::SendRequest()</a>
<a name="ln780">{</a>
<a name="ln781">	fThreadCompleted = create_sem(0, &quot;print_server_messenger_sem&quot;);</a>
<a name="ln782">	if (fThreadCompleted &lt; B_OK)</a>
<a name="ln783">		return B_ERROR;</a>
<a name="ln784"> </a>
<a name="ln785">	thread_id id = spawn_thread(MessengerThread, &quot;async_request&quot;,</a>
<a name="ln786">		B_NORMAL_PRIORITY, this);</a>
<a name="ln787">	if (id &lt;= 0 || resume_thread(id) != B_OK)</a>
<a name="ln788">		return B_ERROR;</a>
<a name="ln789"> </a>
<a name="ln790">	// Get the originating window, if it exists</a>
<a name="ln791">	BWindow* window = dynamic_cast&lt;BWindow*&gt;(</a>
<a name="ln792">		BLooper::LooperForThread(find_thread(NULL)));</a>
<a name="ln793">	if (window != NULL) {</a>
<a name="ln794">		status_t err;</a>
<a name="ln795">		while (true) {</a>
<a name="ln796">			do {</a>
<a name="ln797">				err = acquire_sem_etc(fThreadCompleted, 1, B_RELATIVE_TIMEOUT,</a>
<a name="ln798">					50000);</a>
<a name="ln799">			// We've (probably) had our time slice taken away from us</a>
<a name="ln800">			} while (err == B_INTERRUPTED);</a>
<a name="ln801"> </a>
<a name="ln802">			// Semaphore was finally nuked in SetResult(BMessage *)</a>
<a name="ln803">			if (err == B_BAD_SEM_ID)</a>
<a name="ln804">				break;</a>
<a name="ln805">			window-&gt;UpdateIfNeeded();</a>
<a name="ln806">		}</a>
<a name="ln807">	} else {</a>
<a name="ln808">		// No window to update, so just hang out until we're done.</a>
<a name="ln809">		while (acquire_sem(fThreadCompleted) == B_INTERRUPTED);</a>
<a name="ln810">	}</a>
<a name="ln811"> </a>
<a name="ln812">	status_t status;</a>
<a name="ln813">	wait_for_thread(id, &amp;status);</a>
<a name="ln814"> </a>
<a name="ln815">	return Result() != NULL ? B_OK : B_ERROR;</a>
<a name="ln816">}</a>
<a name="ln817"> </a>
<a name="ln818"> </a>
<a name="ln819">BMessage*</a>
<a name="ln820">PrintServerMessenger::Request()</a>
<a name="ln821">{</a>
<a name="ln822">	if (fRequest != NULL)</a>
<a name="ln823">		return fRequest;</a>
<a name="ln824"> </a>
<a name="ln825">	if (fInput != NULL) {</a>
<a name="ln826">		fRequest = new BMessage(*fInput);</a>
<a name="ln827">		fRequest-&gt;what = fWhat;</a>
<a name="ln828">	} else</a>
<a name="ln829">		fRequest = new BMessage(fWhat);</a>
<a name="ln830"> </a>
<a name="ln831">	return fRequest;</a>
<a name="ln832">}</a>
<a name="ln833"> </a>
<a name="ln834"> </a>
<a name="ln835">void</a>
<a name="ln836">PrintServerMessenger::SetResult(BMessage* result)</a>
<a name="ln837">{</a>
<a name="ln838">	fResult = result;</a>
<a name="ln839">	DeleteSemaphore();</a>
<a name="ln840">	// terminate loop in thread spawned by SendRequest</a>
<a name="ln841">}</a>
<a name="ln842"> </a>
<a name="ln843"> </a>
<a name="ln844">status_t</a>
<a name="ln845">PrintServerMessenger::GetPrintServerMessenger(BMessenger&amp; messenger)</a>
<a name="ln846">{</a>
<a name="ln847">	messenger = BMessenger(PSRV_SIGNATURE_TYPE);</a>
<a name="ln848">	return messenger.IsValid() ? B_OK : B_ERROR;</a>
<a name="ln849">}</a>
<a name="ln850"> </a>
<a name="ln851"> </a>
<a name="ln852">status_t</a>
<a name="ln853">PrintServerMessenger::MessengerThread(void* data)</a>
<a name="ln854">{</a>
<a name="ln855">	PrintServerMessenger* messenger = static_cast&lt;PrintServerMessenger*&gt;(data);</a>
<a name="ln856"> </a>
<a name="ln857">	BMessenger printServer;</a>
<a name="ln858">	if (messenger-&gt;GetPrintServerMessenger(printServer) != B_OK) {</a>
<a name="ln859">		ShowError(B_TRANSLATE(&quot;Print Server is not responding.&quot;));</a>
<a name="ln860">		messenger-&gt;SetResult(NULL);</a>
<a name="ln861">		return B_ERROR;</a>
<a name="ln862">	}</a>
<a name="ln863"> </a>
<a name="ln864">	BMessage* request = messenger-&gt;Request();</a>
<a name="ln865">	if (request == NULL) {</a>
<a name="ln866">		messenger-&gt;SetResult(NULL);</a>
<a name="ln867">		return B_ERROR;</a>
<a name="ln868">	}</a>
<a name="ln869"> </a>
<a name="ln870"> </a>
<a name="ln871">	BMessage reply;</a>
<a name="ln872">	if (printServer.SendMessage(request, &amp;reply) != B_OK</a>
<a name="ln873">		|| reply.what != 'okok' ) {</a>
<a name="ln874">		messenger-&gt;SetResult(NULL);</a>
<a name="ln875">		return B_ERROR;</a>
<a name="ln876">	}</a>
<a name="ln877"> </a>
<a name="ln878">	messenger-&gt;SetResult(new BMessage(reply));</a>
<a name="ln879">	return B_OK;</a>
<a name="ln880">}</a>
<a name="ln881"> </a>
<a name="ln882"> </a>
<a name="ln883">}	// namespace BPrivate</a>

</code></pre>
<div class="balloon" rel="109"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
