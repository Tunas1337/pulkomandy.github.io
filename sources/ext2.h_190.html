
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>ext2.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2008-2010, Axel DÃ¶rfler, axeld@pinc-software.de.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> */</a>
<a name="ln5">#ifndef EXT2_H</a>
<a name="ln6">#define EXT2_H</a>
<a name="ln7"> </a>
<a name="ln8"> </a>
<a name="ln9">#include &lt;sys/stat.h&gt;</a>
<a name="ln10"> </a>
<a name="ln11">#include &lt;ByteOrder.h&gt;</a>
<a name="ln12">#include &lt;fs_interface.h&gt;</a>
<a name="ln13">#include &lt;KernelExport.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15"> </a>
<a name="ln16">typedef uint64 fileblock_t;		// file block number</a>
<a name="ln17">typedef uint64 fsblock_t;		// filesystem block number</a>
<a name="ln18"> </a>
<a name="ln19"> </a>
<a name="ln20">#define EXT2_SUPER_BLOCK_OFFSET	1024</a>
<a name="ln21"> </a>
<a name="ln22">struct ext2_super_block {</a>
<a name="ln23">	uint32	num_inodes;</a>
<a name="ln24">	uint32	num_blocks;</a>
<a name="ln25">	uint32	reserved_blocks;</a>
<a name="ln26">	uint32	free_blocks;</a>
<a name="ln27">	uint32	free_inodes;</a>
<a name="ln28">	uint32	first_data_block;</a>
<a name="ln29">	uint32	block_shift;</a>
<a name="ln30">	uint32	fragment_shift;</a>
<a name="ln31">	uint32	blocks_per_group;</a>
<a name="ln32">	uint32	fragments_per_group;</a>
<a name="ln33">	uint32	inodes_per_group;</a>
<a name="ln34">	uint32	mount_time;</a>
<a name="ln35">	uint32	write_time;</a>
<a name="ln36">	uint16	mount_count;</a>
<a name="ln37">	uint16	max_mount_count;</a>
<a name="ln38">	uint16	magic;</a>
<a name="ln39">	uint16	state;</a>
<a name="ln40">	uint16	error_handling;</a>
<a name="ln41">	uint16	minor_revision_level;</a>
<a name="ln42">	uint32	last_check_time;</a>
<a name="ln43">	uint32	check_interval;</a>
<a name="ln44">	uint32	creator_os;</a>
<a name="ln45">	uint32	revision_level;</a>
<a name="ln46">	uint16	reserved_blocks_uid;</a>
<a name="ln47">	uint16	reserved_blocks_gid;</a>
<a name="ln48">	uint32	first_inode;</a>
<a name="ln49">	uint16	inode_size;</a>
<a name="ln50">	uint16	block_group;</a>
<a name="ln51">	uint32	compatible_features;</a>
<a name="ln52">	uint32	incompatible_features;</a>
<a name="ln53">	uint32	read_only_features;</a>
<a name="ln54">	uint8	uuid[16];</a>
<a name="ln55">	char	name[16];</a>
<a name="ln56">	char	last_mount_point[64];</a>
<a name="ln57">	uint32	algorithm_usage_bitmap;</a>
<a name="ln58">	uint8	preallocated_blocks;</a>
<a name="ln59">	uint8	preallocated_directory_blocks;</a>
<a name="ln60">	uint16	reserved_gdt_blocks;</a>
<a name="ln61"> </a>
<a name="ln62">	// journaling ext3 support</a>
<a name="ln63">	uint8	journal_uuid[16];</a>
<a name="ln64">	uint32	journal_inode;</a>
<a name="ln65">	uint32	journal_device;</a>
<a name="ln66">	uint32	last_orphan;</a>
<a name="ln67">	uint32	hash_seed[4];</a>
<a name="ln68">	uint8	default_hash_version;</a>
<a name="ln69">	uint8	_reserved1;</a>
<a name="ln70">	uint16	group_descriptor_size;</a>
<a name="ln71">	uint32	default_mount_options;</a>
<a name="ln72">	uint32	first_meta_block_group;</a>
<a name="ln73">	uint32	fs_creation_time;</a>
<a name="ln74">	uint32	journal_inode_backup[17];</a>
<a name="ln75"> </a>
<a name="ln76">	// ext4 support</a>
<a name="ln77">	uint32	num_blocks_high;</a>
<a name="ln78">	uint32	reserved_blocks_high;</a>
<a name="ln79">	uint32	free_blocks_high;</a>
<a name="ln80">	uint16	min_inode_size;</a>
<a name="ln81">	uint16	want_inode_size;</a>
<a name="ln82">	uint32	flags;</a>
<a name="ln83">	uint16	raid_stride;</a>
<a name="ln84">	uint16	mmp_interval;</a>
<a name="ln85">	uint64	mmp_block;</a>
<a name="ln86">	uint32	raid_stripe_width;</a>
<a name="ln87">	uint8	groups_per_flex_shift;</a>
<a name="ln88">	uint8	_reserved3;</a>
<a name="ln89">	uint16	_reserved4;</a>
<a name="ln90">	uint32	_reserved5[162];</a>
<a name="ln91"> </a>
<a name="ln92">	uint16 Magic() const { return B_LENDIAN_TO_HOST_INT16(magic); }</a>
<a name="ln93">	uint16 State() const { return B_LENDIAN_TO_HOST_INT16(state); }</a>
<a name="ln94">	uint32 RevisionLevel() const { return B_LENDIAN_TO_HOST_INT16(revision_level); }</a>
<a name="ln95">	uint32 BlockShift() const { return B_LENDIAN_TO_HOST_INT32(block_shift) + 10; }</a>
<a name="ln96">	uint32 NumInodes() const { return B_LENDIAN_TO_HOST_INT32(num_inodes); }</a>
<a name="ln97">	uint64 NumBlocks(bool has64bits) const</a>
<a name="ln98">	{</a>
<a name="ln99">		uint64 blocks = B_LENDIAN_TO_HOST_INT32(num_blocks);</a>
<a name="ln100">		if (has64bits)</a>
<a name="ln101">			blocks |= ((uint64)B_LENDIAN_TO_HOST_INT32(num_blocks_high) &lt;&lt; 32);</a>
<a name="ln102">		return blocks;</a>
<a name="ln103">	}</a>
<a name="ln104">	uint32 FreeInodes() const { return B_LENDIAN_TO_HOST_INT32(free_inodes); }</a>
<a name="ln105">	uint64 FreeBlocks(bool has64bits) const</a>
<a name="ln106">	{</a>
<a name="ln107">		uint64 blocks = B_LENDIAN_TO_HOST_INT32(free_blocks);</a>
<a name="ln108">		if (has64bits)</a>
<a name="ln109">			blocks |= ((uint64)B_LENDIAN_TO_HOST_INT32(free_blocks_high) &lt;&lt; 32);</a>
<a name="ln110">		return blocks;</a>
<a name="ln111">	}</a>
<a name="ln112">	uint16 InodeSize() const { return B_LENDIAN_TO_HOST_INT16(inode_size); }</a>
<a name="ln113">	uint32 FirstDataBlock() const</a>
<a name="ln114">		{ return B_LENDIAN_TO_HOST_INT32(first_data_block); }</a>
<a name="ln115">	uint32 BlocksPerGroup() const</a>
<a name="ln116">		{ return B_LENDIAN_TO_HOST_INT32(blocks_per_group); }</a>
<a name="ln117">	uint32 InodesPerGroup() const</a>
<a name="ln118">		{ return B_LENDIAN_TO_HOST_INT32(inodes_per_group); }</a>
<a name="ln119">	uint32 FirstMetaBlockGroup() const</a>
<a name="ln120">		{ return B_LENDIAN_TO_HOST_INT32(first_meta_block_group); }</a>
<a name="ln121">	uint32 CompatibleFeatures() const</a>
<a name="ln122">		{ return B_LENDIAN_TO_HOST_INT32(compatible_features); }</a>
<a name="ln123">	uint32 ReadOnlyFeatures() const</a>
<a name="ln124">		{ return B_LENDIAN_TO_HOST_INT32(read_only_features); }</a>
<a name="ln125">	uint32 IncompatibleFeatures() const</a>
<a name="ln126">		{ return B_LENDIAN_TO_HOST_INT32(incompatible_features); }</a>
<a name="ln127">	uint16 ReservedGDTBlocks() const</a>
<a name="ln128">		{ return B_LENDIAN_TO_HOST_INT16(reserved_gdt_blocks); }</a>
<a name="ln129">	ino_t  JournalInode() const</a>
<a name="ln130">		{ return B_LENDIAN_TO_HOST_INT32(journal_inode); }</a>
<a name="ln131">	ino_t  LastOrphan() const</a>
<a name="ln132">		{ return (ino_t)B_LENDIAN_TO_HOST_INT32(last_orphan); }</a>
<a name="ln133">	uint32 HashSeed(uint8 i) const</a>
<a name="ln134">		{ return B_LENDIAN_TO_HOST_INT32(hash_seed[i]); }</a>
<a name="ln135">	uint16 GroupDescriptorSize() const</a>
<a name="ln136">		{ return B_LENDIAN_TO_HOST_INT16(group_descriptor_size); }</a>
<a name="ln137"> </a>
<a name="ln138">	void SetFreeInodes(uint32 freeInodes)</a>
<a name="ln139">		{ free_inodes = B_HOST_TO_LENDIAN_INT32(freeInodes); }</a>
<a name="ln140">	void SetFreeBlocks(uint64 freeBlocks, bool has64bits)</a>
<a name="ln141">	{</a>
<a name="ln142">		free_blocks = B_HOST_TO_LENDIAN_INT32(freeBlocks &amp; 0xffffffff);</a>
<a name="ln143">		if (has64bits)</a>
<a name="ln144">			free_blocks_high = B_HOST_TO_LENDIAN_INT32(freeBlocks &gt;&gt; 32);</a>
<a name="ln145">	}</a>
<a name="ln146">	void SetLastOrphan(ino_t id)</a>
<a name="ln147">		{ last_orphan = B_HOST_TO_LENDIAN_INT32((uint32)id); }</a>
<a name="ln148">	void SetReadOnlyFeatures(uint32 readOnlyFeatures) const</a>
<a name="ln149">		{ readOnlyFeatures = B_HOST_TO_LENDIAN_INT32(readOnlyFeatures); }</a>
<a name="ln150"> </a>
<a name="ln151">	bool IsValid();</a>
<a name="ln152">		// implemented in Volume.cpp</a>
<a name="ln153">} _PACKED;</a>
<a name="ln154"> </a>
<a name="ln155">#define EXT2_OLD_REVISION		0</a>
<a name="ln156">#define EXT2_DYNAMIC_REVISION	1</a>
<a name="ln157"> </a>
<a name="ln158">#define EXT2_MAX_REVISION		EXT2_DYNAMIC_REVISION</a>
<a name="ln159"> </a>
<a name="ln160">#define EXT2_FS_STATE_VALID		1	// File system was cleanly unmounted</a>
<a name="ln161">#define EXT2_FS_STATE_ERROR		2	// File system has errors</a>
<a name="ln162">#define EXT2_FS_STATE_ORPHAN	3	// Orphans are being recovered</a>
<a name="ln163"> </a>
<a name="ln164">// compatible features</a>
<a name="ln165">#define EXT2_FEATURE_DIRECTORY_PREALLOCATION	0x0001</a>
<a name="ln166">#define EXT2_FEATURE_IMAGIC_INODES				0x0002</a>
<a name="ln167">#define EXT2_FEATURE_HAS_JOURNAL				0x0004</a>
<a name="ln168">#define EXT2_FEATURE_EXT_ATTR					0x0008</a>
<a name="ln169">#define EXT2_FEATURE_RESIZE_INODE				0x0010</a>
<a name="ln170">#define EXT2_FEATURE_DIRECTORY_INDEX			0x0020</a>
<a name="ln171"> </a>
<a name="ln172">// read-only compatible features</a>
<a name="ln173">#define EXT2_READ_ONLY_FEATURE_SPARSE_SUPER		0x0001</a>
<a name="ln174">#define EXT2_READ_ONLY_FEATURE_LARGE_FILE		0x0002</a>
<a name="ln175">#define EXT2_READ_ONLY_FEATURE_BTREE_DIRECTORY	0x0004</a>
<a name="ln176">#define EXT2_READ_ONLY_FEATURE_HUGE_FILE		0x0008</a>
<a name="ln177">#define EXT2_READ_ONLY_FEATURE_GDT_CSUM			0x0010</a>
<a name="ln178">#define EXT2_READ_ONLY_FEATURE_DIR_NLINK		0x0020</a>
<a name="ln179">#define EXT2_READ_ONLY_FEATURE_EXTRA_ISIZE		0x0040</a>
<a name="ln180"> </a>
<a name="ln181">// incompatible features</a>
<a name="ln182">#define EXT2_INCOMPATIBLE_FEATURE_COMPRESSION	0x0001</a>
<a name="ln183">#define EXT2_INCOMPATIBLE_FEATURE_FILE_TYPE		0x0002</a>
<a name="ln184">#define EXT2_INCOMPATIBLE_FEATURE_RECOVER		0x0004</a>
<a name="ln185">#define EXT2_INCOMPATIBLE_FEATURE_JOURNAL		0x0008</a>
<a name="ln186">#define EXT2_INCOMPATIBLE_FEATURE_META_GROUP	0x0010</a>
<a name="ln187">#define EXT2_INCOMPATIBLE_FEATURE_EXTENTS		0x0040</a>
<a name="ln188">#define EXT2_INCOMPATIBLE_FEATURE_64BIT			0x0080</a>
<a name="ln189">#define EXT2_INCOMPATIBLE_FEATURE_MMP			0x0100</a>
<a name="ln190">#define EXT2_INCOMPATIBLE_FEATURE_FLEX_GROUP	0x0200</a>
<a name="ln191"> </a>
<a name="ln192">// states</a>
<a name="ln193">#define EXT2_STATE_VALID						0x01</a>
<a name="ln194">#define	EXT2_STATE_INVALID						0x02</a>
<a name="ln195"> </a>
<a name="ln196">#define EXT2_BLOCK_GROUP_NORMAL_SIZE			32</a>
<a name="ln197">#define EXT2_BLOCK_GROUP_64BIT_SIZE				64</a>
<a name="ln198"> </a>
<a name="ln199">// block group flags</a>
<a name="ln200">#define EXT2_BLOCK_GROUP_INODE_UNINIT	0x1</a>
<a name="ln201">#define EXT2_BLOCK_GROUP_BLOCK_UNINIT	0x2</a>
<a name="ln202"> </a>
<a name="ln203"> </a>
<a name="ln204">struct ext2_block_group {</a>
<a name="ln205">	uint32	block_bitmap;</a>
<a name="ln206">	uint32	inode_bitmap;</a>
<a name="ln207">	uint32	inode_table;</a>
<a name="ln208">	uint16	free_blocks;</a>
<a name="ln209">	uint16	free_inodes;</a>
<a name="ln210">	uint16	used_directories;</a>
<a name="ln211">	uint16	flags;</a>
<a name="ln212">	uint32	_reserved[2];</a>
<a name="ln213">	uint16	unused_inodes;</a>
<a name="ln214">	uint16	checksum;</a>
<a name="ln215"> </a>
<a name="ln216">	// ext4</a>
<a name="ln217">	uint32	block_bitmap_high;</a>
<a name="ln218">	uint32	inode_bitmap_high;</a>
<a name="ln219">	uint32	inode_table_high;</a>
<a name="ln220">	uint16	free_blocks_high;</a>
<a name="ln221">	uint16	free_inodes_high;</a>
<a name="ln222">	uint16	used_directories_high;</a>
<a name="ln223">	uint16	unused_inodes_high;</a>
<a name="ln224">	uint32	_reserved2[3];</a>
<a name="ln225"> </a>
<a name="ln226">	fsblock_t BlockBitmap(bool has64bits) const</a>
<a name="ln227">	{</a>
<a name="ln228">		uint64 block = B_LENDIAN_TO_HOST_INT32(block_bitmap);</a>
<a name="ln229">		if (has64bits)</a>
<a name="ln230">			block |=</a>
<a name="ln231">				((uint64)B_LENDIAN_TO_HOST_INT32(block_bitmap_high) &lt;&lt; 32);</a>
<a name="ln232">		return block;</a>
<a name="ln233">	}</a>
<a name="ln234">	fsblock_t InodeBitmap(bool has64bits) const</a>
<a name="ln235">	{</a>
<a name="ln236">		uint64 bitmap = B_LENDIAN_TO_HOST_INT32(inode_bitmap);</a>
<a name="ln237">		if (has64bits)</a>
<a name="ln238">			bitmap |=</a>
<a name="ln239">				((uint64)B_LENDIAN_TO_HOST_INT32(inode_bitmap_high) &lt;&lt; 32);</a>
<a name="ln240">		return bitmap;</a>
<a name="ln241">	}</a>
<a name="ln242">	uint64 InodeTable(bool has64bits) const</a>
<a name="ln243">	{</a>
<a name="ln244">		uint64 table = B_LENDIAN_TO_HOST_INT32(inode_table);</a>
<a name="ln245">		if (has64bits)</a>
<a name="ln246">			table |= ((uint64)B_LENDIAN_TO_HOST_INT32(inode_table_high) &lt;&lt; 32);</a>
<a name="ln247">		return table;</a>
<a name="ln248">	}</a>
<a name="ln249">	uint32 FreeBlocks(bool has64bits) const</a>
<a name="ln250">	{</a>
<a name="ln251">		uint32 blocks = B_LENDIAN_TO_HOST_INT16(free_blocks);</a>
<a name="ln252">		if (has64bits)</a>
<a name="ln253">			blocks |=</a>
<a name="ln254">				((uint32)B_LENDIAN_TO_HOST_INT16(free_blocks_high) &lt;&lt; 16);</a>
<a name="ln255">		return blocks;</a>
<a name="ln256">	}</a>
<a name="ln257">	uint32 FreeInodes(bool has64bits) const</a>
<a name="ln258">	{</a>
<a name="ln259">		uint32 inodes = B_LENDIAN_TO_HOST_INT16(free_inodes);</a>
<a name="ln260">		if (has64bits)</a>
<a name="ln261">			inodes |=</a>
<a name="ln262">				((uint32)B_LENDIAN_TO_HOST_INT16(free_inodes_high) &lt;&lt; 16);</a>
<a name="ln263">		return inodes;</a>
<a name="ln264">	}</a>
<a name="ln265">	uint32 UsedDirectories(bool has64bits) const</a>
<a name="ln266">	{</a>
<a name="ln267">		uint32 dirs = B_LENDIAN_TO_HOST_INT16(used_directories);</a>
<a name="ln268">		if (has64bits)</a>
<a name="ln269">			dirs |=</a>
<a name="ln270">				((uint32)B_LENDIAN_TO_HOST_INT16(used_directories_high) &lt;&lt; 16);</a>
<a name="ln271">		return dirs;</a>
<a name="ln272">	}</a>
<a name="ln273">	uint16 Flags() const { return B_LENDIAN_TO_HOST_INT16(flags); }</a>
<a name="ln274">	uint32 UnusedInodes(bool has64bits) const</a>
<a name="ln275">	{</a>
<a name="ln276">		uint32 inodes = B_LENDIAN_TO_HOST_INT16(unused_inodes);</a>
<a name="ln277">		if (has64bits)</a>
<a name="ln278">			inodes |=</a>
<a name="ln279">				((uint32)B_LENDIAN_TO_HOST_INT16(unused_inodes_high) &lt;&lt; 16);</a>
<a name="ln280">		return inodes;</a>
<a name="ln281">	}</a>
<a name="ln282"> </a>
<a name="ln283"> </a>
<a name="ln284">	void SetFreeBlocks(uint32 freeBlocks, bool has64bits)</a>
<a name="ln285">	{</a>
<a name="ln286">		free_blocks = B_HOST_TO_LENDIAN_INT16(freeBlocks) &amp; 0xffff;</a>
<a name="ln287">		if (has64bits)</a>
<a name="ln288">			free_blocks_high = B_HOST_TO_LENDIAN_INT16(freeBlocks &gt;&gt; 16);</a>
<a name="ln289">	}</a>
<a name="ln290"> </a>
<a name="ln291">	void SetFreeInodes(uint32 freeInodes, bool has64bits)</a>
<a name="ln292">	{</a>
<a name="ln293">		free_inodes = B_HOST_TO_LENDIAN_INT16(freeInodes) &amp; 0xffff;</a>
<a name="ln294">		if (has64bits)</a>
<a name="ln295">			free_inodes_high = B_HOST_TO_LENDIAN_INT16(freeInodes &gt;&gt; 16);</a>
<a name="ln296">	}</a>
<a name="ln297"> </a>
<a name="ln298">	void SetUsedDirectories(uint16 usedDirectories, bool has64bits)</a>
<a name="ln299">	{</a>
<a name="ln300">		used_directories = B_HOST_TO_LENDIAN_INT16(usedDirectories&amp; 0xffff);</a>
<a name="ln301">		if (has64bits)</a>
<a name="ln302">			used_directories_high =</a>
<a name="ln303">				B_HOST_TO_LENDIAN_INT16(usedDirectories &gt;&gt; 16);</a>
<a name="ln304">	}</a>
<a name="ln305"> </a>
<a name="ln306">	void SetFlags(uint16 newFlags)</a>
<a name="ln307">	{</a>
<a name="ln308">		flags = B_HOST_TO_LENDIAN_INT16(newFlags);</a>
<a name="ln309">	}</a>
<a name="ln310"> </a>
<a name="ln311">	void SetUnusedInodes(uint32 unusedInodes, bool has64bits)</a>
<a name="ln312">	{</a>
<a name="ln313">		unused_inodes = B_HOST_TO_LENDIAN_INT16(unusedInodes) &amp; 0xffff;</a>
<a name="ln314">		if (has64bits)</a>
<a name="ln315">			unused_inodes_high = B_HOST_TO_LENDIAN_INT16(unusedInodes &gt;&gt; 16);</a>
<a name="ln316">	}</a>
<a name="ln317">} _PACKED;</a>
<a name="ln318"> </a>
<a name="ln319">#define EXT2_DIRECT_BLOCKS			12</a>
<a name="ln320">#define EXT2_ROOT_NODE				2</a>
<a name="ln321">#define EXT2_SHORT_SYMLINK_LENGTH	60</a>
<a name="ln322"> </a>
<a name="ln323">struct ext2_data_stream {</a>
<a name="ln324">	uint32 direct[EXT2_DIRECT_BLOCKS];</a>
<a name="ln325">	uint32 indirect;</a>
<a name="ln326">	uint32 double_indirect;</a>
<a name="ln327">	uint32 triple_indirect;</a>
<a name="ln328">} _PACKED;</a>
<a name="ln329"> </a>
<a name="ln330">#define EXT2_EXTENT_MAGIC			0xf30a</a>
<a name="ln331">#define EXT2_EXTENT_MAX_LENGTH		0x8000</a>
<a name="ln332"> </a>
<a name="ln333">struct ext2_extent_header {</a>
<a name="ln334">	uint16 magic;</a>
<a name="ln335">	uint16 num_entries;</a>
<a name="ln336">	uint16 max_entries;</a>
<a name="ln337">	uint16 depth;</a>
<a name="ln338">	uint32 generation;</a>
<a name="ln339">	bool IsValid() const</a>
<a name="ln340">	{</a>
<a name="ln341">		return B_LENDIAN_TO_HOST_INT16(magic) == EXT2_EXTENT_MAGIC;</a>
<a name="ln342">	}</a>
<a name="ln343">	uint16 NumEntries() const { return B_LENDIAN_TO_HOST_INT16(num_entries); }</a>
<a name="ln344">	uint16 MaxEntries() const { return B_LENDIAN_TO_HOST_INT16(max_entries); }</a>
<a name="ln345">	uint16 Depth() const { return B_LENDIAN_TO_HOST_INT16(depth); }</a>
<a name="ln346">	uint32 Generation() const { return B_LENDIAN_TO_HOST_INT32(generation); }</a>
<a name="ln347">	void SetNumEntries(uint16 num)</a>
<a name="ln348">		{ num_entries = B_HOST_TO_LENDIAN_INT16(num); }</a>
<a name="ln349">	void SetMaxEntries(uint16 max)</a>
<a name="ln350">		{ max_entries = B_HOST_TO_LENDIAN_INT16(max); }</a>
<a name="ln351">	void SetDepth(uint16 _depth)</a>
<a name="ln352">		{ depth = B_HOST_TO_LENDIAN_INT16(_depth); }</a>
<a name="ln353">	void SetGeneration(uint32 _generation)</a>
<a name="ln354">		{ generation = B_HOST_TO_LENDIAN_INT32(_generation); }</a>
<a name="ln355">} _PACKED;</a>
<a name="ln356"> </a>
<a name="ln357">struct ext2_extent_index {</a>
<a name="ln358">	uint32 logical_block;</a>
<a name="ln359">	uint32 physical_block;</a>
<a name="ln360">	uint16 physical_block_high;</a>
<a name="ln361">	uint16 _reserved;</a>
<a name="ln362">	uint32 LogicalBlock() const</a>
<a name="ln363">		{ return B_LENDIAN_TO_HOST_INT32(logical_block); }</a>
<a name="ln364">	uint64 PhysicalBlock() const { return B_LENDIAN_TO_HOST_INT32(physical_block)</a>
<a name="ln365">		| ((uint64)B_LENDIAN_TO_HOST_INT16(physical_block_high) &lt;&lt; 32); }</a>
<a name="ln366">	void SetLogicalBlock(uint32 block) {</a>
<a name="ln367">		logical_block = B_HOST_TO_LENDIAN_INT32(block); }</a>
<a name="ln368">	void SetPhysicalBlock(uint64 block) {</a>
<a name="ln369">		physical_block = B_HOST_TO_LENDIAN_INT32(block &amp; 0xffffffff);</a>
<a name="ln370">		physical_block_high = B_HOST_TO_LENDIAN_INT16((block &gt;&gt; 32) &amp; 0xffff); }</a>
<a name="ln371">} _PACKED;</a>
<a name="ln372"> </a>
<a name="ln373">struct ext2_extent_entry {</a>
<a name="ln374">	uint32 logical_block;</a>
<a name="ln375">	uint16 length;</a>
<a name="ln376">	uint16 physical_block_high;</a>
<a name="ln377">	uint32 physical_block;</a>
<a name="ln378">	uint32 LogicalBlock() const</a>
<a name="ln379">		{ return B_LENDIAN_TO_HOST_INT32(logical_block); }</a>
<a name="ln380">	uint16 Length() const { return B_LENDIAN_TO_HOST_INT16(length) == 0x8000</a>
<a name="ln381">		? 0x8000 : B_LENDIAN_TO_HOST_INT16(length) &amp; 0x7fff; }</a>
<a name="ln382">	uint64 PhysicalBlock() const { return B_LENDIAN_TO_HOST_INT32(physical_block)</a>
<a name="ln383">		| ((uint64)B_LENDIAN_TO_HOST_INT16(physical_block_high) &lt;&lt; 32); }</a>
<a name="ln384">	void SetLogicalBlock(uint32 block) {</a>
<a name="ln385">		logical_block = B_HOST_TO_LENDIAN_INT32(block); }</a>
<a name="ln386">	void SetLength(uint16 _length) {</a>
<a name="ln387">		length = B_HOST_TO_LENDIAN_INT16(_length) &amp; 0x7fff; }</a>
<a name="ln388">	void SetPhysicalBlock(uint64 block) {</a>
<a name="ln389">		physical_block = B_HOST_TO_LENDIAN_INT32(block &amp; 0xffffffff);</a>
<a name="ln390">		physical_block_high = B_HOST_TO_LENDIAN_INT16((block &gt;&gt; 32) &amp; 0xffff); }</a>
<a name="ln391">} _PACKED;</a>
<a name="ln392"> </a>
<a name="ln393">struct ext2_extent_stream {</a>
<a name="ln394">	ext2_extent_header extent_header;</a>
<a name="ln395">	union {</a>
<a name="ln396">		ext2_extent_entry extent_entries[4];</a>
<a name="ln397">		ext2_extent_index extent_index[4];</a>
<a name="ln398">	};</a>
<a name="ln399">} _PACKED;</a>
<a name="ln400"> </a>
<a name="ln401">#define EXT2_INODE_NORMAL_SIZE		128</a>
<a name="ln402">#define EXT2_INODE_MAX_LINKS		65000</a>
<a name="ln403"> </a>
<a name="ln404">struct ext2_inode {</a>
<a name="ln405">	uint16	mode;</a>
<a name="ln406">	uint16	uid;</a>
<a name="ln407">	uint32	size;</a>
<a name="ln408">	uint32	access_time;</a>
<a name="ln409">	uint32	change_time;</a>
<a name="ln410">	uint32	modification_time;</a>
<a name="ln411">	uint32	deletion_time;</a>
<a name="ln412">	uint16	gid;</a>
<a name="ln413">	uint16	num_links;</a>
<a name="ln414">	uint32	num_blocks;</a>
<a name="ln415">	uint32	flags;</a>
<a name="ln416">	uint32	version;</a>
<a name="ln417">	union {</a>
<a name="ln418">		ext2_data_stream stream;</a>
<a name="ln419">		char symlink[EXT2_SHORT_SYMLINK_LENGTH];</a>
<a name="ln420">		ext2_extent_stream extent_stream;</a>
<a name="ln421">	};</a>
<a name="ln422">	uint32	generation;</a>
<a name="ln423">	uint32	file_access_control;</a>
<a name="ln424">	union {</a>
<a name="ln425">		// for directories vs. files</a>
<a name="ln426">		uint32	directory_access_control;</a>
<a name="ln427">		uint32	size_high;</a>
<a name="ln428">	};</a>
<a name="ln429">	uint32	fragment;</a>
<a name="ln430">	union {</a>
<a name="ln431">		struct {</a>
<a name="ln432">			uint8	fragment_number;</a>
<a name="ln433">			uint8	fragment_size;</a>
<a name="ln434">		};</a>
<a name="ln435">		uint16 num_blocks_high;</a>
<a name="ln436">	};</a>
<a name="ln437">	uint16	_padding;</a>
<a name="ln438">	uint16	uid_high;</a>
<a name="ln439">	uint16	gid_high;</a>
<a name="ln440">	uint32	_reserved2;</a>
<a name="ln441"> </a>
<a name="ln442">	// extra attributes</a>
<a name="ln443">	uint16	extra_inode_size;</a>
<a name="ln444">	uint16	_padding2;</a>
<a name="ln445">	uint32	change_time_extra;</a>
<a name="ln446">	uint32	modification_time_extra;</a>
<a name="ln447">	uint32	access_time_extra;</a>
<a name="ln448">	uint32	creation_time;</a>
<a name="ln449">	uint32	creation_time_extra;</a>
<a name="ln450">	uint32	version_high;</a>
<a name="ln451"> </a>
<a name="ln452">	uint16 Mode() const { return B_LENDIAN_TO_HOST_INT16(mode); }</a>
<a name="ln453">	uint32 Flags() const { return B_LENDIAN_TO_HOST_INT32(flags); }</a>
<a name="ln454">	uint16 NumLinks() const { return B_LENDIAN_TO_HOST_INT16(num_links); }</a>
<a name="ln455">	uint32 NumBlocks() const { return B_LENDIAN_TO_HOST_INT32(num_blocks); }</a>
<a name="ln456">	uint64 NumBlocks64() const { return B_LENDIAN_TO_HOST_INT32(num_blocks)</a>
<a name="ln457">		| ((uint64)B_LENDIAN_TO_HOST_INT32(num_blocks_high) &lt;&lt; 32); }</a>
<a name="ln458"> </a>
<a name="ln459">	static void _DecodeTime(struct timespec *timespec, uint32 time,</a>
<a name="ln460">		uint32 time_extra, bool extra)</a>
<a name="ln461">	{</a>
<a name="ln462">		timespec-&gt;tv_sec = B_LENDIAN_TO_HOST_INT32(time);</a>
<a name="ln463">		if (extra &amp;&amp; sizeof(timespec-&gt;tv_sec) &gt; 4)</a>
<a name="ln464">			timespec-&gt;tv_sec |=</a>
<a name="ln465">				(uint64)(B_LENDIAN_TO_HOST_INT32(time_extra) &amp; 0x2) &lt;&lt; 32;</a>
<a name="ln466">		if (extra)</a>
<a name="ln467">			timespec-&gt;tv_nsec = B_LENDIAN_TO_HOST_INT32(time_extra) &gt;&gt; 2;</a>
<a name="ln468">		else</a>
<a name="ln469">			timespec-&gt;tv_nsec = 0;</a>
<a name="ln470">	}</a>
<a name="ln471"> </a>
<a name="ln472">	void GetModificationTime(struct timespec *timespec, bool extra) const</a>
<a name="ln473">		{ _DecodeTime(timespec, modification_time, modification_time_extra,</a>
<a name="ln474">			extra); }</a>
<a name="ln475">	void GetAccessTime(struct timespec *timespec, bool extra) const</a>
<a name="ln476">		{ _DecodeTime(timespec, access_time, access_time_extra, extra); }</a>
<a name="ln477">	void GetChangeTime(struct timespec *timespec, bool extra) const</a>
<a name="ln478">		{ _DecodeTime(timespec, change_time, change_time_extra, extra); }</a>
<a name="ln479">	void GetCreationTime(struct timespec *timespec, bool extra) const</a>
<a name="ln480">	{</a>
<a name="ln481">		if (extra)</a>
<a name="ln482">			_DecodeTime(timespec, creation_time, creation_time_extra, extra);</a>
<a name="ln483">		else {</a>
<a name="ln484">			timespec-&gt;tv_sec = 0;</a>
<a name="ln485">			timespec-&gt;tv_nsec = 0;</a>
<a name="ln486">		}</a>
<a name="ln487">	}</a>
<a name="ln488">	time_t DeletionTime() const</a>
<a name="ln489">		{ return B_LENDIAN_TO_HOST_INT32(deletion_time); }</a>
<a name="ln490"> </a>
<a name="ln491">	static uint32 _EncodeTime(const struct timespec *timespec)</a>
<a name="ln492">	{</a>
<a name="ln493">		uint32 time = (timespec-&gt;tv_nsec &lt;&lt; 2) &amp; 0xfffffffc;</a>
<a name="ln494">		if (sizeof(timespec-&gt;tv_sec) &gt; 4)</a>
<a name="ln495">			time |= (uint64)timespec-&gt;tv_sec &gt;&gt; 32;</a>
<a name="ln496">		return B_HOST_TO_LENDIAN_INT32(time);</a>
<a name="ln497">	}</a>
<a name="ln498"> </a>
<a name="ln499">	void SetModificationTime(const struct timespec *timespec, bool extra)</a>
<a name="ln500">	{</a>
<a name="ln501">		modification_time = B_HOST_TO_LENDIAN_INT32((uint32)timespec-&gt;tv_sec);</a>
<a name="ln502">		if (extra)</a>
<a name="ln503">			modification_time_extra = _EncodeTime(timespec);</a>
<a name="ln504">	}</a>
<a name="ln505">	void SetAccessTime(const struct timespec *timespec, bool extra)</a>
<a name="ln506">	{</a>
<a name="ln507">		access_time = B_HOST_TO_LENDIAN_INT32((uint32)timespec-&gt;tv_sec);</a>
<a name="ln508">		if (extra)</a>
<a name="ln509">			access_time_extra = _EncodeTime(timespec);</a>
<a name="ln510">	}</a>
<a name="ln511">	void SetChangeTime(const struct timespec *timespec, bool extra)</a>
<a name="ln512">	{</a>
<a name="ln513">		change_time = B_HOST_TO_LENDIAN_INT32((uint32)timespec-&gt;tv_sec);</a>
<a name="ln514">		if (extra)</a>
<a name="ln515">			change_time_extra = _EncodeTime(timespec);</a>
<a name="ln516">	}</a>
<a name="ln517">	void SetCreationTime(const struct timespec *timespec, bool extra)</a>
<a name="ln518">	{</a>
<a name="ln519">		if (extra) {</a>
<a name="ln520">			creation_time = B_HOST_TO_LENDIAN_INT32((uint32)timespec-&gt;tv_sec);</a>
<a name="ln521">			creation_time_extra =</a>
<a name="ln522">				B_HOST_TO_LENDIAN_INT32((uint32)timespec-&gt;tv_nsec);</a>
<a name="ln523">		}</a>
<a name="ln524">	}</a>
<a name="ln525">	void SetDeletionTime(time_t deletionTime)</a>
<a name="ln526">	{</a>
<a name="ln527">		deletion_time = B_HOST_TO_LENDIAN_INT32((uint32)deletionTime);</a>
<a name="ln528">	}</a>
<a name="ln529"> </a>
<a name="ln530">	ino_t  NextOrphan() const { return (ino_t)DeletionTime(); }</a>
<a name="ln531"> </a>
<a name="ln532">	off_t Size() const</a>
<a name="ln533">	{</a>
<a name="ln534">		if (S_ISREG(Mode())) {</a>
<a name="ln535">			return B_LENDIAN_TO_HOST_INT32(size)</a>
<a name="ln536">				| ((off_t)B_LENDIAN_TO_HOST_INT32(size_high) &lt;&lt; 32);</a>
<a name="ln537">		}</a>
<a name="ln538"> </a>
<a name="ln539">		return B_LENDIAN_TO_HOST_INT32(size);</a>
<a name="ln540">	}</a>
<a name="ln541"> </a>
<a name="ln542">	uint32 ExtendedAttributesBlock() const</a>
<a name="ln543">	{	return B_LENDIAN_TO_HOST_INT32(file_access_control);}</a>
<a name="ln544"> </a>
<a name="ln545">	uint16 ExtraInodeSize() const</a>
<a name="ln546">		{ return B_LENDIAN_TO_HOST_INT16(extra_inode_size); }</a>
<a name="ln547"> </a>
<a name="ln548">	uint32 UserID() const</a>
<a name="ln549">	{</a>
<a name="ln550">		return B_LENDIAN_TO_HOST_INT16(uid)</a>
<a name="ln551">			| (B_LENDIAN_TO_HOST_INT16(uid_high) &lt;&lt; 16);</a>
<a name="ln552">	}</a>
<a name="ln553"> </a>
<a name="ln554">	uint32 GroupID() const</a>
<a name="ln555">	{</a>
<a name="ln556">		return B_LENDIAN_TO_HOST_INT16(gid)</a>
<a name="ln557">			| (B_LENDIAN_TO_HOST_INT16(gid_high) &lt;&lt; 16);</a>
<a name="ln558">	}</a>
<a name="ln559"> </a>
<a name="ln560">	void SetMode(uint16 newMode)</a>
<a name="ln561">	{</a>
<a name="ln562">		mode = B_LENDIAN_TO_HOST_INT16(newMode);</a>
<a name="ln563">	}</a>
<a name="ln564"> </a>
<a name="ln565">	void UpdateMode(uint16 newMode, uint16 mask)</a>
<a name="ln566">	{</a>
<a name="ln567">		SetMode((Mode() &amp; ~mask) | (newMode &amp; mask));</a>
<a name="ln568">	}</a>
<a name="ln569"> </a>
<a name="ln570">	void ClearFlag(uint32 mask)</a>
<a name="ln571">	{</a>
<a name="ln572">		flags &amp;= ~B_HOST_TO_LENDIAN_INT32(mask);</a>
<a name="ln573">	}</a>
<a name="ln574"> </a>
<a name="ln575">	void SetFlag(uint32 mask)</a>
<a name="ln576">	{</a>
<a name="ln577">		flags |= B_HOST_TO_LENDIAN_INT32(mask);</a>
<a name="ln578">	}</a>
<a name="ln579"> </a>
<a name="ln580">	void SetFlags(uint32 newFlags)</a>
<a name="ln581">	{</a>
<a name="ln582">		flags = B_HOST_TO_LENDIAN_INT32(newFlags);</a>
<a name="ln583">	}</a>
<a name="ln584"> </a>
<a name="ln585">	void SetNumLinks(uint16 numLinks)</a>
<a name="ln586">	{</a>
<a name="ln587">		num_links = B_HOST_TO_LENDIAN_INT16(numLinks);</a>
<a name="ln588">	}</a>
<a name="ln589"> </a>
<a name="ln590">	void SetNumBlocks(uint32 numBlocks)</a>
<a name="ln591">	{</a>
<a name="ln592">		num_blocks = B_HOST_TO_LENDIAN_INT32(numBlocks);</a>
<a name="ln593">	}</a>
<a name="ln594"> </a>
<a name="ln595">	void SetNumBlocks64(uint64 numBlocks)</a>
<a name="ln596">	{</a>
<a name="ln597">		num_blocks = B_HOST_TO_LENDIAN_INT32(numBlocks &amp; 0xffffffff);</a>
<a name="ln598">		num_blocks_high = B_HOST_TO_LENDIAN_INT32(numBlocks &gt;&gt; 32);</a>
<a name="ln599">	}</a>
<a name="ln600"> </a>
<a name="ln601">	void SetNextOrphan(ino_t id)</a>
<a name="ln602">	{</a>
<a name="ln603">		deletion_time = B_HOST_TO_LENDIAN_INT32((uint32)id);</a>
<a name="ln604">	}</a>
<a name="ln605"> </a>
<a name="ln606">	void SetSize(off_t newSize)</a>
<a name="ln607">	{</a>
<a name="ln608">		size = B_HOST_TO_LENDIAN_INT32(newSize &amp; 0xFFFFFFFF);</a>
<a name="ln609">		if (S_ISREG(Mode()))</a>
<a name="ln610">			size_high = B_HOST_TO_LENDIAN_INT32(newSize &gt;&gt; 32);</a>
<a name="ln611">	}</a>
<a name="ln612"> </a>
<a name="ln613">	void SetUserID(uint32 newUID)</a>
<a name="ln614">	{</a>
<a name="ln615">		uid = B_HOST_TO_LENDIAN_INT16(newUID &amp; 0xFFFF);</a>
<a name="ln616">		uid_high = B_HOST_TO_LENDIAN_INT16(newUID &gt;&gt; 16);</a>
<a name="ln617">	}</a>
<a name="ln618"> </a>
<a name="ln619">	void SetGroupID(uint32 newGID)</a>
<a name="ln620">	{</a>
<a name="ln621">		gid = B_HOST_TO_LENDIAN_INT16(newGID &amp; 0xFFFF);</a>
<a name="ln622">		gid_high = B_HOST_TO_LENDIAN_INT16(newGID &gt;&gt; 16);</a>
<a name="ln623">	}</a>
<a name="ln624"> </a>
<a name="ln625">	void SetExtendedAttributesBlock(uint32 block)</a>
<a name="ln626">	{</a>
<a name="ln627">		file_access_control = B_HOST_TO_LENDIAN_INT32(block);</a>
<a name="ln628">	}</a>
<a name="ln629"> </a>
<a name="ln630">	void SetExtraInodeSize(uint16 newSize)</a>
<a name="ln631">	{</a>
<a name="ln632">		extra_inode_size = B_HOST_TO_LENDIAN_INT16(newSize);</a>
<a name="ln633">	}</a>
<a name="ln634">} _PACKED;</a>
<a name="ln635"> </a>
<a name="ln636">#define EXT2_SUPER_BLOCK_MAGIC			0xef53</a>
<a name="ln637"> </a>
<a name="ln638">// flags</a>
<a name="ln639">#define EXT2_INODE_SECURE_DELETION		0x00000001</a>
<a name="ln640">#define EXT2_INODE_UNDELETE				0x00000002</a>
<a name="ln641">#define EXT2_INODE_COMPRESSED			0x00000004</a>
<a name="ln642">#define EXT2_INODE_SYNCHRONOUS			0x00000008</a>
<a name="ln643">#define EXT2_INODE_IMMUTABLE			0x00000010</a>
<a name="ln644">#define EXT2_INODE_APPEND_ONLY			0x00000020</a>
<a name="ln645">#define EXT2_INODE_NO_DUMP				0x00000040</a>
<a name="ln646">#define EXT2_INODE_NO_ACCESS_TIME		0x00000080</a>
<a name="ln647">#define EXT2_INODE_DIRTY				0x00000100</a>
<a name="ln648">#define EXT2_INODE_COMPRESSED_BLOCKS	0x00000200</a>
<a name="ln649">#define EXT2_INODE_DO_NOT_COMPRESS		0x00000400</a>
<a name="ln650">#define EXT2_INODE_COMPRESSION_ERROR	0x00000800</a>
<a name="ln651">#define EXT2_INODE_BTREE				0x00001000</a>
<a name="ln652">#define EXT2_INODE_INDEXED				0x00001000</a>
<a name="ln653">#define EXT2_INODE_JOURNAL_DATA			0x00004000</a>
<a name="ln654">#define EXT2_INODE_NO_MERGE_TAIL		0x00008000</a>
<a name="ln655">#define EXT2_INODE_DIR_SYNCH			0x00010000</a>
<a name="ln656">#define EXT2_INODE_HUGE_FILE			0x00040000</a>
<a name="ln657">#define EXT2_INODE_EXTENTS				0x00080000</a>
<a name="ln658">#define EXT2_INODE_LARGE_EA				0x00200000</a>
<a name="ln659">#define EXT2_INODE_EOF_BLOCKS			0x00400000</a>
<a name="ln660">#define EXT2_INODE_INLINE_DATA			0x10000000</a>
<a name="ln661">#define EXT2_INODE_RESERVED				0x80000000</a>
<a name="ln662"> </a>
<a name="ln663">#define EXT2_INODE_INHERITED (EXT2_INODE_SECURE_DELETION | EXT2_INODE_UNDELETE \</a>
<a name="ln664">	| EXT2_INODE_COMPRESSED | EXT2_INODE_SYNCHRONOUS | EXT2_INODE_IMMUTABLE \</a>
<a name="ln665">	| EXT2_INODE_APPEND_ONLY | EXT2_INODE_NO_DUMP | EXT2_INODE_NO_ACCESS_TIME \</a>
<a name="ln666">	| EXT2_INODE_DO_NOT_COMPRESS | EXT2_INODE_JOURNAL_DATA \</a>
<a name="ln667">	| EXT2_INODE_NO_MERGE_TAIL | EXT2_INODE_DIR_SYNCH)</a>
<a name="ln668"> </a>
<a name="ln669">#define EXT2_NAME_LENGTH	255</a>
<a name="ln670"> </a>
<a name="ln671">struct ext2_dir_entry {</a>
<a name="ln672">	uint32	inode_id;</a>
<a name="ln673">	uint16	length;</a>
<a name="ln674">	uint8	name_length;</a>
<a name="ln675">	uint8	file_type;</a>
<a name="ln676">	char	name[EXT2_NAME_LENGTH];</a>
<a name="ln677"> </a>
<a name="ln678">	uint32	InodeID() const { return B_LENDIAN_TO_HOST_INT32(inode_id); }</a>
<a name="ln679">	uint16	Length() const { return B_LENDIAN_TO_HOST_INT16(length); }</a>
<a name="ln680">	uint8	NameLength() const { return name_length; }</a>
<a name="ln681">	uint8	FileType() const { return file_type; }</a>
<a name="ln682"> </a>
<a name="ln683">	void	SetInodeID(uint32 id) { inode_id = B_HOST_TO_LENDIAN_INT32(id); }</a>
<a name="ln684"> </a>
<a name="ln685">	void	SetLength(uint16 newLength/*uint8 nameLength*/)</a>
<a name="ln686">	{</a>
<a name="ln687">		length = B_HOST_TO_LENDIAN_INT16(newLength);</a>
<a name="ln688">		/*name_length = nameLength;</a>
<a name="ln689"> </a>
<a name="ln690">		if (nameLength % 4 == 0) {</a>
<a name="ln691">			length = B_HOST_TO_LENDIAN_INT16(</a>
<a name="ln692">				(short)(nameLength + MinimumSize()));</a>
<a name="ln693">		} else {</a>
<a name="ln694">			length = B_HOST_TO_LENDIAN_INT16(</a>
<a name="ln695">				(short)(nameLength % 4 + 1 + MinimumSize()));</a>
<a name="ln696">		}*/</a>
<a name="ln697">	}</a>
<a name="ln698"> </a>
<a name="ln699">	bool IsValid() const</a>
<a name="ln700">	{</a>
<a name="ln701">		return Length() &gt; MinimumSize();</a>
<a name="ln702">			// There is no maximum size, as the last entry spans until the</a>
<a name="ln703">			// end of the block</a>
<a name="ln704">	}</a>
<a name="ln705"> </a>
<a name="ln706">	static size_t MinimumSize()</a>
<a name="ln707">	{</a>
<a name="ln708">		return sizeof(ext2_dir_entry) - EXT2_NAME_LENGTH;</a>
<a name="ln709">	}</a>
<a name="ln710">} _PACKED;</a>
<a name="ln711"> </a>
<a name="ln712">// file types</a>
<a name="ln713">#define EXT2_TYPE_UNKNOWN		0</a>
<a name="ln714">#define EXT2_TYPE_FILE			1</a>
<a name="ln715">#define EXT2_TYPE_DIRECTORY		2</a>
<a name="ln716">#define EXT2_TYPE_CHAR_DEVICE	3</a>
<a name="ln717">#define EXT2_TYPE_BLOCK_DEVICE	4</a>
<a name="ln718">#define EXT2_TYPE_FIFO			5</a>
<a name="ln719">#define EXT2_TYPE_SOCKET		6</a>
<a name="ln720">#define EXT2_TYPE_SYMLINK		7</a>
<a name="ln721"> </a>
<a name="ln722">#define EXT2_XATTR_MAGIC		0xea020000</a>
<a name="ln723">#define EXT2_XATTR_ROUND		((1 &lt;&lt; 2) - 1)</a>
<a name="ln724">#define EXT2_XATTR_NAME_LENGTH	255</a>
<a name="ln725"> </a>
<a name="ln726">#define EXT2_XATTR_INDEX_USER	1</a>
<a name="ln727"> </a>
<a name="ln728">struct ext2_xattr_header {</a>
<a name="ln729">	uint32	magic;</a>
<a name="ln730">	uint32	refcount;</a>
<a name="ln731">	uint32	blocks;		// must be 1 for ext2</a>
<a name="ln732">	uint32	hash;</a>
<a name="ln733">	uint32	reserved[4];	// zero</a>
<a name="ln734"> </a>
<a name="ln735">	bool IsValid() const</a>
<a name="ln736">	{</a>
<a name="ln737">		return B_LENDIAN_TO_HOST_INT32(magic) == EXT2_XATTR_MAGIC</a>
<a name="ln738">			&amp;&amp; B_LENDIAN_TO_HOST_INT32(blocks) == 1</a>
<a name="ln739">			&amp;&amp; refcount &lt;= 1024;</a>
<a name="ln740">	}</a>
<a name="ln741"> </a>
<a name="ln742">	void Dump() const {</a>
<a name="ln743">		for (unsigned int i = 0; i &lt; Length(); i++)</a>
<a name="ln744">			dprintf(&quot;%02x &quot;, ((uint8 *)this)[i]);</a>
<a name="ln745">		dprintf(&quot;\n&quot;);</a>
<a name="ln746">	}</a>
<a name="ln747"> </a>
<a name="ln748">	static size_t Length()</a>
<a name="ln749">	{</a>
<a name="ln750">		return sizeof(ext2_xattr_header);</a>
<a name="ln751">	}</a>
<a name="ln752">};</a>
<a name="ln753"> </a>
<a name="ln754">struct ext2_xattr_entry {</a>
<a name="ln755">	uint8	name_length;</a>
<a name="ln756">	uint8	name_index;</a>
<a name="ln757">	uint16	value_offset;</a>
<a name="ln758">	uint32	value_block;	// must be zero for ext2</a>
<a name="ln759">	uint32	value_size;</a>
<a name="ln760">	uint32	hash;</a>
<a name="ln761">	char	name[EXT2_XATTR_NAME_LENGTH];</a>
<a name="ln762"> </a>
<a name="ln763">	uint8 NameLength() const { return name_length; }</a>
<a name="ln764">	uint8 NameIndex() const { return name_index; }</a>
<a name="ln765">	uint16 ValueOffset() const { return</a>
<a name="ln766">			B_LENDIAN_TO_HOST_INT16(value_offset); }</a>
<a name="ln767">	uint32 ValueSize() const { return</a>
<a name="ln768">			B_LENDIAN_TO_HOST_INT32(value_size); }</a>
<a name="ln769"> </a>
<a name="ln770">	// padded sizes</a>
<a name="ln771">	uint32 Length() const { return (MinimumSize() + NameLength()</a>
<a name="ln772">		+ EXT2_XATTR_ROUND) &amp; ~EXT2_XATTR_ROUND; }</a>
<a name="ln773"> </a>
<a name="ln774">	bool IsValid() const</a>
<a name="ln775">	{</a>
<a name="ln776">		return NameLength() &gt; 0 &amp;&amp; value_block == 0;</a>
<a name="ln777">			// There is no maximum size, as the last entry spans until the</a>
<a name="ln778">			// end of the block</a>
<a name="ln779">	}</a>
<a name="ln780"> </a>
<a name="ln781">	void Dump(bool full=false) const {</a>
<a name="ln782">		for (unsigned int i = 0; i &lt; (full ? sizeof(this) : MinimumSize()); i++)</a>
<a name="ln783">			dprintf(&quot;%02x &quot;, ((uint8 *)this)[i]);</a>
<a name="ln784">		dprintf(&quot;\n&quot;);</a>
<a name="ln785">	}</a>
<a name="ln786"> </a>
<a name="ln787">	static size_t MinimumSize()</a>
<a name="ln788">	{</a>
<a name="ln789">		return sizeof(ext2_xattr_entry) - EXT2_XATTR_NAME_LENGTH;</a>
<a name="ln790">	}</a>
<a name="ln791">} _PACKED;</a>
<a name="ln792"> </a>
<a name="ln793"> </a>
<a name="ln794">struct file_cookie {</a>
<a name="ln795">	bigtime_t	last_notification;</a>
<a name="ln796">	off_t		last_size;</a>
<a name="ln797">	int			open_mode;</a>
<a name="ln798">};</a>
<a name="ln799"> </a>
<a name="ln800"> </a>
<a name="ln801">#define EXT2_OPEN_MODE_USER_MASK		0x7fffffff</a>
<a name="ln802"> </a>
<a name="ln803">#define INODE_NOTIFICATION_INTERVAL		10000000LL</a>
<a name="ln804"> </a>
<a name="ln805"> </a>
<a name="ln806">extern fs_volume_ops gExt2VolumeOps;</a>
<a name="ln807">extern fs_vnode_ops gExt2VnodeOps;</a>
<a name="ln808"> </a>
<a name="ln809">#endif	// EXT2_H</a>

</code></pre>
<div class="balloon" rel="782"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v568/" target="_blank">V568</a> It's odd that 'sizeof()' operator evaluates the size of a pointer to a class, but not the size of the 'this' class object.</p></div>
<div class="balloon" rel="149"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v570/" target="_blank">V570</a> The 'readOnlyFeatures' variable is assigned to itself.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
