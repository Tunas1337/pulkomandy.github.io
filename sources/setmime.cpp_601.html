
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>setmime.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2011 Aleksas Pantechovskis, &lt;alexp.frl@gmail.com&gt;</a>
<a name="ln3"> * Copyright 2011 Siarzhuk Zharski, &lt;imker@gmx.li&gt;</a>
<a name="ln4"> * All rights reserved. Distributed under the terms of the MIT License.</a>
<a name="ln5"> */</a>
<a name="ln6"> </a>
<a name="ln7">#include &lt;iomanip&gt;</a>
<a name="ln8">#include &lt;iostream&gt;</a>
<a name="ln9">#include &lt;map&gt;</a>
<a name="ln10">#include &lt;math.h&gt;</a>
<a name="ln11">#include &lt;set&gt;</a>
<a name="ln12">#include &lt;sstream&gt;</a>
<a name="ln13">#include &lt;stdio.h&gt;</a>
<a name="ln14">#include &lt;stdlib.h&gt;</a>
<a name="ln15">#include &lt;strings.h&gt;</a>
<a name="ln16">#include &lt;vector&gt;</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;Application.h&gt;</a>
<a name="ln19">#include &lt;Bitmap.h&gt;</a>
<a name="ln20">#include &lt;Entry.h&gt;</a>
<a name="ln21">#include &lt;InterfaceDefs.h&gt;</a>
<a name="ln22">#include &lt;Message.h&gt;</a>
<a name="ln23">#include &lt;Mime.h&gt;</a>
<a name="ln24">#include &lt;Path.h&gt;</a>
<a name="ln25">#include &lt;String.h&gt;</a>
<a name="ln26"> </a>
<a name="ln27"> </a>
<a name="ln28">using namespace std;</a>
<a name="ln29"> </a>
<a name="ln30"> </a>
<a name="ln31">const char* kUsageMessage = &quot;# setmime:\n&quot;</a>
<a name="ln32">	&quot;# usage: setmime ((-dump | -dumpSniffRule | -dumpIcon | -dumpAll) &quot;</a>
<a name="ln33">													&quot;[ &lt;signatureString&gt; ] )\n&quot;</a>
<a name="ln34">	&quot;#      | (-remove &lt;signatureString&gt; )\n&quot;</a>
<a name="ln35">	&quot;#      | ( (-set | -force | -add)  &lt;signatureString&gt;\n&quot;</a>
<a name="ln36">	&quot;#          [ -short &lt;short description&gt; ] [ -long &lt;long description&gt; ]\n&quot;</a>
<a name="ln37">	&quot;#          [ -preferredApp &lt;preferred app path&gt; ]\n&quot;</a>
<a name="ln38">	&quot;#          [ -preferredAppSig &lt;preferred app signature&gt; ]\n&quot;</a>
<a name="ln39">	&quot;#          [ -sniffRule &lt;sniffRule&gt; ]\n&quot;</a>
<a name="ln40">	&quot;#          [ -extension &lt;file suffix&gt; ]\n&quot;</a>
<a name="ln41">	&quot;#          [ -attribute &lt;internal name&gt;\n&quot;</a>
<a name="ln42">	&quot;#             [ -attrName &lt;public name&gt; ] [ -attrType &lt;type code&gt; ]\n&quot;</a>
<a name="ln43">	&quot;#             [ -attrWidth &lt;display width&gt; ][ -attrAlignment &lt;position&gt;]\n&quot;</a>
<a name="ln44">	&quot;#             [ -attrViewable &lt;bool flag&gt; ][ -attrEditable &lt;bool flag&gt; ]\n&quot;</a>
<a name="ln45">	&quot;#             [ -attrExtra &lt;bool flag&gt; ] ]\n&quot;</a>
<a name="ln46">	&quot;#          [ -miniIcon &lt;256 hex bytes&gt; ]\n&quot;</a>
<a name="ln47">	&quot;#          [ -largeIcon &lt;1024 hex bytes&gt; ]\n&quot;</a>
<a name="ln48">	&quot;#          [ -vectorIcon &lt;icon hex bytes&gt; ] ... )\n&quot;</a>
<a name="ln49">	&quot;#      | (-checkSniffRule &lt;sniffRule&gt;\n&quot;</a>
<a name="ln50">	&quot;#      | -includeApps)\n&quot;;</a>
<a name="ln51"> </a>
<a name="ln52">const char* kHelpMessage = &quot;#  -dump prints a specified metamime\n&quot;</a>
<a name="ln53">	&quot;#  -remove removes specified metamime\n&quot;</a>
<a name="ln54">	&quot;#  -add adds specified metamime and specified metamime attributes\n&quot;</a>
<a name="ln55">	&quot;#      that have not yet been defined\n&quot;</a>
<a name="ln56">	&quot;#  -set adds specified metamime and specified metamime attributes, \n&quot;</a>
<a name="ln57">	&quot;#      overwrites the existing values of specified metamime attributes\n&quot;</a>
<a name="ln58">	&quot;#  -force adds specified metamime and specified metamime attributes\n&quot;</a>
<a name="ln59">	&quot;#      after first erasing all the existing attributes\n&quot;</a>
<a name="ln60">	&quot;#  -dumpSniffRule prints just the MIME sniffer rule of a &quot;</a>
<a name="ln61">														&quot;specified metamime\n&quot;</a>
<a name="ln62">	&quot;#     -dumpIcon prints just the icon information of a specified metamime\n&quot;</a>
<a name="ln63">	&quot;#  -dumpAll prints all the information, including icons of a &quot;</a>
<a name="ln64">														&quot;specified metamime\n&quot;</a>
<a name="ln65">	&quot;#  -checkSniffRule parses a MIME sniffer rule and reports any errors\n&quot;</a>
<a name="ln66">	&quot;#  -includeApps will include applications\n&quot;;</a>
<a name="ln67"> </a>
<a name="ln68">const char* kNeedArgMessage =	&quot;you have to specify any of &quot;</a>
<a name="ln69">								&quot;-dump[All|Icon|SnifferRule], -add, -set, &quot;</a>
<a name="ln70">								&quot;-force or -remove&quot;;</a>
<a name="ln71"> </a>
<a name="ln72">const char* kWrongModeMessage = &quot;can only specify one of -dump, -dumpAll, &quot;</a>
<a name="ln73">								&quot;-dumpIcon, -dumpSnifferRule, -remove, &quot;</a>
<a name="ln74">								&quot;-add, -set, -force or -checkSnifferRule&quot;;</a>
<a name="ln75"> </a>
<a name="ln76">const char* kHelpReq		=	&quot;--help&quot;;</a>
<a name="ln77">const char* kDump			=	&quot;-dump&quot;;</a>
<a name="ln78">const char* kDumpSniffRule	=	&quot;-dumpSniffRule&quot;;</a>
<a name="ln79">const char* kDumpIcon		=	&quot;-dumpIcon&quot;;</a>
<a name="ln80">const char* kDumpAll		=	&quot;-dumpAll&quot;;</a>
<a name="ln81">const char* kAdd			=	&quot;-add&quot;;</a>
<a name="ln82">const char* kSet			=	&quot;-set&quot;;</a>
<a name="ln83">const char* kForce			=	&quot;-force&quot;;</a>
<a name="ln84">const char* kRemove			=	&quot;-remove&quot;;</a>
<a name="ln85">const char* kCheckSniffRule	=	&quot;-checkSniffRule&quot;;</a>
<a name="ln86">const char* kShort			=	&quot;-short&quot;;</a>
<a name="ln87">const char* kLong			=	&quot;-long&quot;;</a>
<a name="ln88">const char* kPreferredApp	=	&quot;-preferredApp&quot;;</a>
<a name="ln89">const char* kPreferredAppSig =	&quot;-preferredAppSig&quot;;</a>
<a name="ln90">const char* kSniffRule		=	&quot;-sniffRule&quot;;</a>
<a name="ln91">const char* kMiniIcon		=	&quot;-miniIcon&quot;;</a>
<a name="ln92">const char* kLargeIcon		=	&quot;-largeIcon&quot;;</a>
<a name="ln93">const char* kVectorIcon		=	&quot;-vectorIcon&quot;;</a>
<a name="ln94">const char* kIncludeApps	=	&quot;-includeApps&quot;;</a>
<a name="ln95">const char* kExtension		=	&quot;-extension&quot;;</a>
<a name="ln96">const char* kAttribute		=	&quot;-attribute&quot;;</a>
<a name="ln97">const char* kAttrName		=	&quot;-attrName&quot;;</a>
<a name="ln98">const char* kAttrType		=	&quot;-attrType&quot;;</a>
<a name="ln99">const char* kAttrWidth		=	&quot;-attrWidth&quot;;</a>
<a name="ln100">const char* kAttrAlignment	=	&quot;-attrAlignment&quot;;</a>
<a name="ln101">const char* kAttrViewable	=	&quot;-attrViewable&quot;;</a>
<a name="ln102">const char* kAttrEditable	=	&quot;-attrEditable&quot;;</a>
<a name="ln103">const char* kAttrExtra		=	&quot;-attrExtra&quot;;</a>
<a name="ln104"> </a>
<a name="ln105"> </a>
<a name="ln106">const uint32 hash_function(const char* str)</a>
<a name="ln107">{</a>
<a name="ln108">	uint32 h = 0;</a>
<a name="ln109">	uint32 g = 0;</a>
<a name="ln110">	for (const char* p = str; *p; p++) {</a>
<a name="ln111">		h = (h &lt;&lt; 4) + (*p &amp; 0xFF);</a>
<a name="ln112">		g = h &amp; 0xF0000000;</a>
<a name="ln113">		if (g != 0) {</a>
<a name="ln114">			h ^= g &gt;&gt; 24;</a>
<a name="ln115">			h ^= g;</a>
<a name="ln116">		}</a>
<a name="ln117">	}</a>
<a name="ln118">	return h;</a>
<a name="ln119">}</a>
<a name="ln120"> </a>
<a name="ln121"> </a>
<a name="ln122">// the list of all acceptable command-line options</a>
<a name="ln123">struct CmdOption {</a>
<a name="ln124"> </a>
<a name="ln125">	enum Type {</a>
<a name="ln126">		kMode,</a>
<a name="ln127">		kOption,</a>
<a name="ln128">		kAttrRoot,</a>
<a name="ln129">		kAttrib,</a>
<a name="ln130">		kHelp</a>
<a name="ln131">	};</a>
<a name="ln132"> </a>
<a name="ln133">	const char*	fName;</a>
<a name="ln134">	Type		fType;</a>
<a name="ln135">	bool		fNeedArg;</a>
<a name="ln136">	bool		fNonExclusive;</a>
<a name="ln137"> </a>
<a name="ln138">} gCmdOptions[] = {</a>
<a name="ln139"> </a>
<a name="ln140">	{ kHelpReq,			CmdOption::kHelp },</a>
<a name="ln141"> </a>
<a name="ln142">	{ kDump,			CmdOption::kMode },</a>
<a name="ln143">	{ kDumpSniffRule,	CmdOption::kMode },</a>
<a name="ln144">	{ kDumpIcon,		CmdOption::kMode },</a>
<a name="ln145">	{ kDumpAll,			CmdOption::kMode },</a>
<a name="ln146">	{ kAdd,				CmdOption::kMode },</a>
<a name="ln147">	{ kSet,				CmdOption::kMode },</a>
<a name="ln148">	{ kForce,			CmdOption::kMode },</a>
<a name="ln149">	{ kRemove,			CmdOption::kMode },</a>
<a name="ln150">	{ kCheckSniffRule,	CmdOption::kMode, true },</a>
<a name="ln151"> </a>
<a name="ln152">	{ kShort,			CmdOption::kOption, true },</a>
<a name="ln153">	{ kLong,			CmdOption::kOption, true },</a>
<a name="ln154">	{ kPreferredApp,	CmdOption::kOption, true },</a>
<a name="ln155">	{ kPreferredAppSig,	CmdOption::kOption, true },</a>
<a name="ln156">	{ kSniffRule,		CmdOption::kOption, true },</a>
<a name="ln157">	{ kMiniIcon	,		CmdOption::kOption, true },</a>
<a name="ln158">	{ kLargeIcon,		CmdOption::kOption, true },</a>
<a name="ln159">	{ kVectorIcon,		CmdOption::kOption, true },</a>
<a name="ln160">	{ kIncludeApps,		CmdOption::kOption, false },</a>
<a name="ln161">	{ kExtension,		CmdOption::kOption, true, true },</a>
<a name="ln162">	{ kAttribute,		CmdOption::kAttrRoot, true, true },</a>
<a name="ln163"> </a>
<a name="ln164">	{ kAttrName,		CmdOption::kAttrib, true },</a>
<a name="ln165">	{ kAttrType,		CmdOption::kAttrib, true },</a>
<a name="ln166">	{ kAttrWidth,		CmdOption::kAttrib, true },</a>
<a name="ln167">	{ kAttrAlignment,	CmdOption::kAttrib, true },</a>
<a name="ln168">	{ kAttrViewable,	CmdOption::kAttrib, true },</a>
<a name="ln169">	{ kAttrEditable,	CmdOption::kAttrib, true },</a>
<a name="ln170">	{ kAttrExtra,		CmdOption::kAttrib, true }</a>
<a name="ln171">};</a>
<a name="ln172"> </a>
<a name="ln173">// the 'hash -&gt; value' map of arguments provided by user</a>
<a name="ln174">typedef multimap&lt;uint32, const char*&gt;				TUserArgs;</a>
<a name="ln175">typedef multimap&lt;uint32, const char*&gt;::iterator		TUserArgsI;</a>
<a name="ln176"> </a>
<a name="ln177">// user provided attributes are grouped separately in vector</a>
<a name="ln178">typedef vector&lt;TUserArgs&gt;			TUserAttrs;</a>
<a name="ln179">typedef vector&lt;TUserArgs&gt;::iterator	TUserAttrsI;</a>
<a name="ln180"> </a>
<a name="ln181">const uint32 kOpModeUndefined = 0;</a>
<a name="ln182"> </a>
<a name="ln183"> </a>
<a name="ln184">// #pragma mark -</a>
<a name="ln185"> </a>
<a name="ln186">class Error : public std::exception</a>
<a name="ln187">{</a>
<a name="ln188">			BString		fWhat;</a>
<a name="ln189">public:</a>
<a name="ln190">						Error(const char* what, ...);</a>
<a name="ln191">	virtual				~Error() throw() {}</a>
<a name="ln192">	virtual const char*	what() const throw() { return fWhat.String(); }</a>
<a name="ln193">};</a>
<a name="ln194"> </a>
<a name="ln195"> </a>
<a name="ln196">Error::Error(const char* what, ...)</a>
<a name="ln197">{</a>
<a name="ln198">	const int size = 1024;</a>
<a name="ln199">	va_list args;</a>
<a name="ln200">	va_start(args, what);</a>
<a name="ln201">	vsnprintf(fWhat.LockBuffer(size), size, what, args);</a>
<a name="ln202">	fWhat.UnlockBuffer();</a>
<a name="ln203">	va_end(args);</a>
<a name="ln204">}</a>
<a name="ln205"> </a>
<a name="ln206"> </a>
<a name="ln207">// #pragma mark -</a>
<a name="ln208"> </a>
<a name="ln209">// encapsulate the single attribute params</a>
<a name="ln210">//</a>
<a name="ln211">struct MimeAttribute</a>
<a name="ln212">{</a>
<a name="ln213">	status_t	fStatus;</a>
<a name="ln214">	BString 	fName;</a>
<a name="ln215">	BString 	fPublicName;</a>
<a name="ln216">	int32 		fType;</a>
<a name="ln217">	bool 		fViewable;</a>
<a name="ln218">	bool 		fEditable;</a>
<a name="ln219">	bool 		fExtra;</a>
<a name="ln220">	int32 		fWidth;</a>
<a name="ln221">	int32 		fAlignment;</a>
<a name="ln222"> </a>
<a name="ln223">				MimeAttribute(BMessage&amp; msg, int32 index);</a>
<a name="ln224">				MimeAttribute(TUserArgs&amp; args);</a>
<a name="ln225">				MimeAttribute(const MimeAttribute&amp; src);</a>
<a name="ln226"> </a>
<a name="ln227">	status_t	InitCheck() { return fStatus; }</a>
<a name="ln228"> </a>
<a name="ln229">	MimeAttribute&amp; operator=(const MimeAttribute&amp; src);</a>
<a name="ln230"> </a>
<a name="ln231">	void		Dump();</a>
<a name="ln232">	void		SyncWith(TUserArgs&amp; args) throw(Error);</a>
<a name="ln233">	void		StoreInto(BMessage* target);</a>
<a name="ln234">	const char*	UserArgValue(TUserArgs&amp; map, const char* name);</a>
<a name="ln235"> </a>
<a name="ln236">	bool		IsPrintableChar(char c)</a>
<a name="ln237">					{ return c &gt;= ' ' &amp;&amp; c &lt; 127 &amp;&amp; c != '\'' &amp;&amp; c != '\\'; }</a>
<a name="ln238">};</a>
<a name="ln239"> </a>
<a name="ln240"> </a>
<a name="ln241">MimeAttribute::MimeAttribute(BMessage&amp; msg, int32 index)</a>
<a name="ln242">		:</a>
<a name="ln243">		fStatus(B_NO_INIT),</a>
<a name="ln244">		fType('CSTR'),</a>
<a name="ln245">		fViewable(true),</a>
<a name="ln246">		fEditable(false),</a>
<a name="ln247">		fExtra(false),</a>
<a name="ln248">		fWidth(0),</a>
<a name="ln249">		fAlignment(0)</a>
<a name="ln250">{</a>
<a name="ln251">	BString rawPublicName;</a>
<a name="ln252">	struct attrEntry {</a>
<a name="ln253">		const char* name;</a>
<a name="ln254">		type_code	type;</a>
<a name="ln255">		bool		required;</a>
<a name="ln256">		void*		data;</a>
<a name="ln257">	} attrEntries[] = {</a>
<a name="ln258">		{ &quot;attr:name&quot;,			B_STRING_TYPE,	true, &amp;fName },</a>
<a name="ln259">		{ &quot;attr:public_name&quot;,	B_STRING_TYPE,	true, &amp;rawPublicName },</a>
<a name="ln260">		{ &quot;attr:type&quot;,			B_INT32_TYPE,	true, &amp;fType },</a>
<a name="ln261">		{ &quot;attr:viewable&quot;,		B_BOOL_TYPE,	false, &amp;fViewable },</a>
<a name="ln262">		{ &quot;attr:editable&quot;,		B_BOOL_TYPE,	false, &amp;fEditable },</a>
<a name="ln263">		{ &quot;attr:extra&quot;,			B_BOOL_TYPE,	false, &amp;fExtra },</a>
<a name="ln264">		{ &quot;attr:width&quot;,			B_INT32_TYPE,	false, &amp;fWidth },</a>
<a name="ln265">		{ &quot;attr:alignment&quot;,		B_INT32_TYPE,	false, &amp;fAlignment }</a>
<a name="ln266">	};</a>
<a name="ln267"> </a>
<a name="ln268">	for (size_t i = 0; i &lt; sizeof(attrEntries) / sizeof(attrEntries[0]); i++) {</a>
<a name="ln269">		switch (attrEntries[i].type) {</a>
<a name="ln270">			case B_STRING_TYPE:</a>
<a name="ln271">				fStatus = msg.FindString(attrEntries[i].name, index,</a>
<a name="ln272">								(BString*)attrEntries[i].data);</a>
<a name="ln273">				break;</a>
<a name="ln274">			case B_BOOL_TYPE:</a>
<a name="ln275">				fStatus = msg.FindBool(attrEntries[i].name, index,</a>
<a name="ln276">								(bool*)attrEntries[i].data);</a>
<a name="ln277">				break;</a>
<a name="ln278">			case B_INT32_TYPE:</a>
<a name="ln279">				fStatus = msg.FindInt32(attrEntries[i].name, index,</a>
<a name="ln280">								(int32*)attrEntries[i].data);</a>
<a name="ln281">				break;</a>
<a name="ln282">		}</a>
<a name="ln283"> </a>
<a name="ln284">		if (attrEntries[i].required &amp;&amp; fStatus != B_OK)</a>
<a name="ln285">			return;</a>
<a name="ln286">	}</a>
<a name="ln287"> </a>
<a name="ln288">	fPublicName.CharacterEscape(rawPublicName, &quot;\'&quot;, '\\');</a>
<a name="ln289">	fStatus = B_OK;</a>
<a name="ln290">}</a>
<a name="ln291"> </a>
<a name="ln292"> </a>
<a name="ln293">MimeAttribute::MimeAttribute(TUserArgs&amp; args)</a>
<a name="ln294">		:</a>
<a name="ln295">		fStatus(B_NO_INIT),</a>
<a name="ln296">		fType('CSTR'),</a>
<a name="ln297">		fViewable(true),</a>
<a name="ln298">		fEditable(false),</a>
<a name="ln299">		fExtra(false),</a>
<a name="ln300">		fWidth(0),</a>
<a name="ln301">		fAlignment(0)</a>
<a name="ln302">{</a>
<a name="ln303">	SyncWith(args);</a>
<a name="ln304">	fStatus = B_OK;</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307"> </a>
<a name="ln308">MimeAttribute::MimeAttribute(const MimeAttribute&amp; src)</a>
<a name="ln309">{</a>
<a name="ln310">	*this = src;</a>
<a name="ln311">}</a>
<a name="ln312"> </a>
<a name="ln313"> </a>
<a name="ln314">MimeAttribute&amp;</a>
<a name="ln315">MimeAttribute::operator=(const MimeAttribute&amp; src)</a>
<a name="ln316">{</a>
<a name="ln317">	fStatus = src.fStatus;</a>
<a name="ln318">	fName = src.fName;</a>
<a name="ln319">	fPublicName = src.fPublicName;</a>
<a name="ln320">	fType = src.fType;</a>
<a name="ln321">	fViewable = src.fViewable;</a>
<a name="ln322">	fEditable = src.fEditable;</a>
<a name="ln323">	fExtra = src.fExtra;</a>
<a name="ln324">	fWidth = src.fWidth;</a>
<a name="ln325">	fAlignment = src.fAlignment;</a>
<a name="ln326"> </a>
<a name="ln327">	return *this;</a>
<a name="ln328">}</a>
<a name="ln329"> </a>
<a name="ln330"> </a>
<a name="ln331">void</a>
<a name="ln332">MimeAttribute::SyncWith(TUserArgs&amp; args) throw(Error)</a>
<a name="ln333">{</a>
<a name="ln334">	const char* value = UserArgValue(args, kAttribute);</a>
<a name="ln335">	if (value != NULL)</a>
<a name="ln336">		fName.SetTo(value, B_MIME_TYPE_LENGTH);</a>
<a name="ln337"> </a>
<a name="ln338">	value = UserArgValue(args, kAttrName);</a>
<a name="ln339">	if (value != NULL)</a>
<a name="ln340">		fPublicName.SetTo(value, B_MIME_TYPE_LENGTH);</a>
<a name="ln341"> </a>
<a name="ln342">	value = UserArgValue(args, kAttrType);</a>
<a name="ln343">	if (value != NULL) {</a>
<a name="ln344">		fType = 0;</a>
<a name="ln345">		if (strlen(value) &gt; 2 &amp;&amp; value[0] == '0' &amp;&amp; value[1] == 'x') {</a>
<a name="ln346">			stringstream ss;</a>
<a name="ln347">			ss &lt;&lt; setbase(16) &lt;&lt; value + 2;</a>
<a name="ln348">			ss &gt;&gt; fType;</a>
<a name="ln349">		} else if (strlen(value) == 4) {</a>
<a name="ln350">			for (int i = 0; i &lt; 4 &amp;&amp; value[i] != '\0'; i++) {</a>
<a name="ln351">				fType &lt;&lt;= 8;</a>
<a name="ln352">				fType |= (value[i] != '\0' ? value[i] : ' ');</a>
<a name="ln353">			}</a>
<a name="ln354"> </a>
<a name="ln355">		} else</a>
<a name="ln356">			throw Error(&quot;Invalid data for %s&quot;, kAttrType);</a>
<a name="ln357"> </a>
<a name="ln358">		fType = B_LENDIAN_TO_HOST_INT32(fType);</a>
<a name="ln359">	}</a>
<a name="ln360"> </a>
<a name="ln361">	value = UserArgValue(args, kAttrWidth);</a>
<a name="ln362">	if (value != NULL)</a>
<a name="ln363">		fWidth = atoi(value);</a>
<a name="ln364"> </a>
<a name="ln365">	value = UserArgValue(args, kAttrAlignment);</a>
<a name="ln366">	if (value != NULL) {</a>
<a name="ln367">		if (strcasecmp(value, &quot;right&quot;) == 0) {</a>
<a name="ln368">			fAlignment = B_ALIGN_RIGHT;</a>
<a name="ln369">		} else if (strcasecmp(value, &quot;left&quot;) == 0) {</a>
<a name="ln370">			fAlignment = B_ALIGN_LEFT;</a>
<a name="ln371">		} else if (strcasecmp(value, &quot;center&quot;) == 0) {</a>
<a name="ln372">			fAlignment = B_ALIGN_CENTER;</a>
<a name="ln373">		} else</a>
<a name="ln374">			fAlignment = atoi(value);</a>
<a name="ln375">	}</a>
<a name="ln376"> </a>
<a name="ln377">	value = UserArgValue(args, kAttrViewable);</a>
<a name="ln378">	if (value != NULL)</a>
<a name="ln379">		fViewable = atoi(value) != 0;</a>
<a name="ln380"> </a>
<a name="ln381">	value = UserArgValue(args, kAttrEditable);</a>
<a name="ln382">	if (value != NULL)</a>
<a name="ln383">		fEditable = atoi(value) != 0;</a>
<a name="ln384"> </a>
<a name="ln385">	value = UserArgValue(args, kAttrExtra);</a>
<a name="ln386">	if (value != NULL)</a>
<a name="ln387">		fExtra = atoi(value) != 0;</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390"> </a>
<a name="ln391">void</a>
<a name="ln392">MimeAttribute::Dump()</a>
<a name="ln393">{</a>
<a name="ln394">	uint32 type = B_HOST_TO_LENDIAN_INT32(fType);</a>
<a name="ln395">	const char* alignment = fAlignment == B_ALIGN_RIGHT ? &quot;right&quot;</a>
<a name="ln396">					: (fAlignment == B_ALIGN_LEFT ? &quot;left&quot; : &quot;center&quot;);</a>
<a name="ln397"> </a>
<a name="ln398">	cout &lt;&lt; &quot; \\&quot; &lt;&lt; endl &lt;&lt; &quot;\t&quot; &lt;&lt; kAttribute &lt;&lt; &quot; \&quot;&quot; &lt;&lt; fName &lt;&lt; &quot;\&quot; &quot;</a>
<a name="ln399">				&lt;&lt; kAttrName &lt;&lt; &quot; \&quot;&quot; &lt;&lt; fPublicName &lt;&lt; &quot;\&quot;&quot;;</a>
<a name="ln400"> </a>
<a name="ln401">	char c1 = (char)((type &gt;&gt; 24) &amp; 0xFF);</a>
<a name="ln402">	char c2 = (char)((type &gt;&gt; 16) &amp; 0xFF);</a>
<a name="ln403">	char c3 = (char)((type &gt;&gt; 8) &amp; 0xFF);</a>
<a name="ln404">	char c4 = (char)(type &amp; 0xFF);</a>
<a name="ln405">	</a>
<a name="ln406">	ios::fmtflags flags = cout.flags();</a>
<a name="ln407"> </a>
<a name="ln408">	cout &lt;&lt; &quot; \\&quot; &lt;&lt; endl &lt;&lt; &quot;\t\t&quot; &lt;&lt; kAttrType;</a>
<a name="ln409">	if (IsPrintableChar(c1) &amp;&amp; IsPrintableChar(c2) &amp;&amp;</a>
<a name="ln410">		IsPrintableChar(c3) &amp;&amp; IsPrintableChar(c4))</a>
<a name="ln411">		cout &lt;&lt; &quot; '&quot; &lt;&lt; c1 &lt;&lt; c2 &lt;&lt; c3 &lt;&lt; c4 &lt;&lt; &quot;' &quot;;</a>
<a name="ln412">	else</a>
<a name="ln413">		cout &lt;&lt; &quot;0x&quot; &lt;&lt; hex &lt;&lt; type;</a>
<a name="ln414"> </a>
<a name="ln415">	cout &lt;&lt; &quot; &quot; &lt;&lt; kAttrWidth &lt;&lt; &quot; &quot; &lt;&lt; fWidth</a>
<a name="ln416">			&lt;&lt; &quot; &quot; &lt;&lt; kAttrAlignment &lt;&lt; &quot; &quot; &lt;&lt; alignment;</a>
<a name="ln417"> </a>
<a name="ln418">	cout &lt;&lt; &quot; \\&quot; &lt;&lt; endl &lt;&lt; &quot;\t\t&quot; &lt;&lt; kAttrViewable &lt;&lt; &quot; &quot; &lt;&lt; fViewable</a>
<a name="ln419">			&lt;&lt; &quot; &quot; &lt;&lt; kAttrEditable &lt;&lt; &quot; &quot; &lt;&lt; fEditable</a>
<a name="ln420">			&lt;&lt; &quot; &quot; &lt;&lt; kAttrExtra &lt;&lt; &quot; &quot; &lt;&lt; fExtra;</a>
<a name="ln421">	</a>
<a name="ln422">	cout.flags(flags);</a>
<a name="ln423">}</a>
<a name="ln424"> </a>
<a name="ln425"> </a>
<a name="ln426">void</a>
<a name="ln427">MimeAttribute::StoreInto(BMessage* target)</a>
<a name="ln428">{</a>
<a name="ln429">	struct attrEntry {</a>
<a name="ln430">		const char* name;</a>
<a name="ln431">		type_code	type;</a>
<a name="ln432">		const void*	data;</a>
<a name="ln433">	} attrEntries[] = {</a>
<a name="ln434">		{ &quot;attr:name&quot;,			B_STRING_TYPE,	fName.String() },</a>
<a name="ln435">		{ &quot;attr:public_name&quot;,	B_STRING_TYPE,	fPublicName.String() },</a>
<a name="ln436">		{ &quot;attr:type&quot;,			B_INT32_TYPE,	&amp;fType },</a>
<a name="ln437">		{ &quot;attr:viewable&quot;,		B_BOOL_TYPE,	&amp;fViewable },</a>
<a name="ln438">		{ &quot;attr:editable&quot;,		B_BOOL_TYPE,	&amp;fEditable },</a>
<a name="ln439">		{ &quot;attr:extra&quot;,			B_BOOL_TYPE,	&amp;fExtra },</a>
<a name="ln440">		{ &quot;attr:width&quot;,			B_INT32_TYPE,	&amp;fWidth },</a>
<a name="ln441">		{ &quot;attr:alignment&quot;,		B_INT32_TYPE,	&amp;fAlignment }</a>
<a name="ln442">	};</a>
<a name="ln443"> </a>
<a name="ln444">	for (size_t i = 0; i &lt; sizeof(attrEntries) / sizeof(attrEntries[0]); i++) {</a>
<a name="ln445">		switch (attrEntries[i].type) {</a>
<a name="ln446">			case B_STRING_TYPE:</a>
<a name="ln447">				fStatus = target-&gt;AddString(attrEntries[i].name,</a>
<a name="ln448">								(const char*)attrEntries[i].data);</a>
<a name="ln449">				break;</a>
<a name="ln450">			case B_BOOL_TYPE:</a>
<a name="ln451">				fStatus = target-&gt;AddBool(attrEntries[i].name,</a>
<a name="ln452">								(bool*)attrEntries[i].data);</a>
<a name="ln453">				break;</a>
<a name="ln454">			case B_INT32_TYPE:</a>
<a name="ln455">				fStatus = target-&gt;AddInt32(attrEntries[i].name,</a>
<a name="ln456">								*(int32*)attrEntries[i].data);</a>
<a name="ln457">				break;</a>
<a name="ln458">		}</a>
<a name="ln459"> </a>
<a name="ln460">		if (fStatus != B_OK)</a>
<a name="ln461">			return;</a>
<a name="ln462">	}</a>
<a name="ln463">}</a>
<a name="ln464"> </a>
<a name="ln465"> </a>
<a name="ln466">const char*</a>
<a name="ln467">MimeAttribute::UserArgValue(TUserArgs&amp; map, const char* name)</a>
<a name="ln468">{</a>
<a name="ln469">	TUserArgsI i = map.find(hash_function(name));</a>
<a name="ln470">	if (i == map.end())</a>
<a name="ln471">		return NULL;</a>
<a name="ln472">	return i-&gt;second != NULL ? i-&gt;second : &quot;&quot;;</a>
<a name="ln473">}</a>
<a name="ln474"> </a>
<a name="ln475"> </a>
<a name="ln476">// #pragma mark -</a>
<a name="ln477"> </a>
<a name="ln478">// the work-horse of the app - the class encapsulates extended info readed</a>
<a name="ln479">// from the mime type and do all edit and dump operations</a>
<a name="ln480">//</a>
<a name="ln481">class MimeType : public BMimeType {</a>
<a name="ln482"> </a>
<a name="ln483">public:</a>
<a name="ln484">					MimeType(char** argv) throw (Error);</a>
<a name="ln485">					~MimeType();</a>
<a name="ln486"> </a>
<a name="ln487">	void			Process() throw (Error);</a>
<a name="ln488"> </a>
<a name="ln489">private:</a>
<a name="ln490">	status_t		_InitCheck();</a>
<a name="ln491">	void			_SetTo(const char* mimetype) throw (Error);</a>
<a name="ln492">	void			_PurgeProperties();</a>
<a name="ln493">	void			_Init(char** argv) throw (Error);</a>
<a name="ln494">	void			_DumpIcon(uint8 *iconData, size_t iconSize);</a>
<a name="ln495">	void			_Dump(const char* mimetype) throw (Error);</a>
<a name="ln496">	void			_DoEdit() throw (Error);</a>
<a name="ln497">	void			_SetIcon(const char* iconData, int32 iconSize);</a>
<a name="ln498"> </a>
<a name="ln499">	const char*		_UserArgValue(const char* name);</a>
<a name="ln500"> </a>
<a name="ln501">	status_t		fStatus;</a>
<a name="ln502">	const char*		fToolName;</a>
<a name="ln503"> </a>
<a name="ln504">	// configurable MimeType properties</a>
<a name="ln505">	BString			fShort;</a>
<a name="ln506">	BString			fLong;</a>
<a name="ln507">	BString			fPrefApp;</a>
<a name="ln508">	BString			fPrefAppSig;</a>
<a name="ln509">	BString			fSniffRule;</a>
<a name="ln510">	BBitmap*		fSmallIcon;</a>
<a name="ln511">	BBitmap*		fBigIcon;</a>
<a name="ln512">	uint8*			fVectorIcon;</a>
<a name="ln513">	size_t			fVectorIconSize;</a>
<a name="ln514"> </a>
<a name="ln515">	map&lt;uint32, BString&gt;		fExtensions;</a>
<a name="ln516">	map&lt;uint32, MimeAttribute&gt;	fAttributes;</a>
<a name="ln517"> </a>
<a name="ln518">	// user provided arguments</a>
<a name="ln519">	TUserArgs		fUserArguments;</a>
<a name="ln520">	TUserAttrs		fUserAttributes;</a>
<a name="ln521"> </a>
<a name="ln522">	// operation mode switches and flags</a>
<a name="ln523">	uint32			fOpMode;</a>
<a name="ln524">	bool			fDumpNormal;</a>
<a name="ln525">	bool			fDumpRule;</a>
<a name="ln526">	bool			fDumpIcon;</a>
<a name="ln527">	bool			fDumpAll;</a>
<a name="ln528">	bool			fDoAdd;</a>
<a name="ln529">	bool			fDoSet;</a>
<a name="ln530">	bool			fDoForce;</a>
<a name="ln531">	bool			fDoRemove;</a>
<a name="ln532">	bool			fCheckSniffRule;</a>
<a name="ln533">};</a>
<a name="ln534"> </a>
<a name="ln535"> </a>
<a name="ln536">MimeType::MimeType(char** argv) throw (Error)</a>
<a name="ln537">		:</a>
<a name="ln538">		fStatus(B_NO_INIT),</a>
<a name="ln539">		fToolName(argv[0]),</a>
<a name="ln540">		fSmallIcon(NULL),</a>
<a name="ln541">		fBigIcon(NULL),</a>
<a name="ln542">		fVectorIcon(NULL),</a>
<a name="ln543">		fVectorIconSize(0),</a>
<a name="ln544">		fOpMode(kOpModeUndefined),</a>
<a name="ln545">		fDumpNormal(false),</a>
<a name="ln546">		fDumpRule(false),</a>
<a name="ln547">		fDumpIcon(false),</a>
<a name="ln548">		fDumpAll(false),</a>
<a name="ln549">		fDoAdd(false),</a>
<a name="ln550">		fDoSet(false),</a>
<a name="ln551">		fDoForce(false),</a>
<a name="ln552">		fDoRemove(false),</a>
<a name="ln553">		fCheckSniffRule(false)</a>
<a name="ln554">{</a>
<a name="ln555">	fToolName = strrchr(argv[0], '/');</a>
<a name="ln556">	fToolName = fToolName == NULL ? argv[0] : fToolName + 1;</a>
<a name="ln557"> </a>
<a name="ln558">	_Init(++argv);</a>
<a name="ln559">}</a>
<a name="ln560"> </a>
<a name="ln561"> </a>
<a name="ln562">MimeType::~MimeType()</a>
<a name="ln563">{</a>
<a name="ln564">	delete fSmallIcon;</a>
<a name="ln565">	delete fBigIcon;</a>
<a name="ln566">	free(fVectorIcon);</a>
<a name="ln567">}</a>
<a name="ln568"> </a>
<a name="ln569"> </a>
<a name="ln570">void</a>
<a name="ln571">MimeType::_Init(char** argv) throw (Error)</a>
<a name="ln572">{</a>
<a name="ln573">	// fill the helper map of options - for quick lookup of arguments</a>
<a name="ln574">	map&lt;uint32, const CmdOption*&gt; cmdOptionsMap;</a>
<a name="ln575">	for (size_t i = 0; i &lt; sizeof(gCmdOptions) / sizeof(gCmdOptions[0]); i++)</a>
<a name="ln576">		cmdOptionsMap.insert(pair&lt;uint32, CmdOption*&gt;(</a>
<a name="ln577">							hash_function(gCmdOptions[i].fName), &amp;gCmdOptions[i]));</a>
<a name="ln578"> </a>
<a name="ln579">	// parse the command line arguments</a>
<a name="ln580">	for (char** arg = argv; *arg; arg++) {</a>
<a name="ln581">		// non-option arguments are assumed as signature</a>
<a name="ln582">		if (**arg != '-') {</a>
<a name="ln583">			if (Type() != NULL)</a>
<a name="ln584">				throw Error(&quot;mime signature already specified: '%s'&quot;, Type());</a>
<a name="ln585"> </a>
<a name="ln586">			SetTo(*arg);</a>
<a name="ln587">			continue;</a>
<a name="ln588">		}</a>
<a name="ln589"> </a>
<a name="ln590">		// check op.modes, options and attribs</a>
<a name="ln591">		uint32 key = hash_function(*arg);</a>
<a name="ln592"> </a>
<a name="ln593">		map&lt;uint32, const CmdOption*&gt;::iterator I = cmdOptionsMap.find(key);</a>
<a name="ln594">		if (I == cmdOptionsMap.end())</a>
<a name="ln595">			throw Error(&quot;unknown option '%s'&quot;, *arg);</a>
<a name="ln596"> </a>
<a name="ln597">		switch (I-&gt;second-&gt;fType) {</a>
<a name="ln598">			case CmdOption::kHelp:</a>
<a name="ln599">				cerr &lt;&lt; kUsageMessage;</a>
<a name="ln600">				throw Error(kHelpMessage);</a>
<a name="ln601"> </a>
<a name="ln602">			case CmdOption::kMode:</a>
<a name="ln603">				// op.modes are exclusive - no simultaneous possible</a>
<a name="ln604">				if (fOpMode != kOpModeUndefined)</a>
<a name="ln605">					throw Error(kWrongModeMessage);</a>
<a name="ln606">				fOpMode = key;</a>
<a name="ln607"> </a>
<a name="ln608">				if (hash_function(I-&gt;second-&gt;fName) != hash_function(kCheckSniffRule))</a>
<a name="ln609">					break;</a>
<a name="ln610">				// else -&gt; fallthrough, CheckRule works both as mode and Option</a>
<a name="ln611">			case CmdOption::kOption:</a>
<a name="ln612">				{</a>
<a name="ln613">					const char* name = *arg;</a>
<a name="ln614">					const char* param = NULL;</a>
<a name="ln615">					if (I-&gt;second-&gt;fNeedArg) {</a>
<a name="ln616">						if (!*++arg)</a>
<a name="ln617">							throw Error(&quot;argument required for '%s'&quot;, name);</a>
<a name="ln618">						param = *arg;</a>
<a name="ln619">					}</a>
<a name="ln620"> </a>
<a name="ln621">					TUserArgsI A = fUserArguments.find(key);</a>
<a name="ln622">					if (A != fUserArguments.end() &amp;&amp; !I-&gt;second-&gt;fNonExclusive)</a>
<a name="ln623">						throw Error(&quot;option '%s' already specified&quot;, name);</a>
<a name="ln624"> </a>
<a name="ln625">					fUserArguments.insert(</a>
<a name="ln626">							pair&lt;uint32, const char*&gt;(key, param));</a>
<a name="ln627">				}</a>
<a name="ln628">				break;</a>
<a name="ln629"> </a>
<a name="ln630">			case CmdOption::kAttrRoot:</a>
<a name="ln631">				if (!*++arg)</a>
<a name="ln632">					throw Error(&quot;attribute name should be specified&quot;);</a>
<a name="ln633"> </a>
<a name="ln634">				fUserAttributes.resize(fUserAttributes.size() + 1);</a>
<a name="ln635">				fUserAttributes.back().insert(</a>
<a name="ln636">							pair&lt;uint32, const char*&gt;(key, *arg));</a>
<a name="ln637">				break;</a>
<a name="ln638"> </a>
<a name="ln639">			case CmdOption::kAttrib:</a>
<a name="ln640">				{</a>
<a name="ln641">					const char* name = *arg;</a>
<a name="ln642">					if (fUserAttributes.size() &lt;= 0)</a>
<a name="ln643">						throw Error(&quot;'%s' allowed only after the '%s' &lt;name&gt;&quot;,</a>
<a name="ln644">								name, kAttribute);</a>
<a name="ln645"> </a>
<a name="ln646">					if (!*++arg || **arg == '-')</a>
<a name="ln647">						throw Error(&quot;'%s', argument should be specified&quot;, name);</a>
<a name="ln648"> </a>
<a name="ln649">					TUserArgsI A = fUserAttributes.back().find(key);</a>
<a name="ln650">					if (A != fUserAttributes.back().end())</a>
<a name="ln651">						throw Error(&quot;'%s' for attribute '%s' already specified&quot;,</a>
<a name="ln652">								name, A-&gt;second);</a>
<a name="ln653"> </a>
<a name="ln654">					fUserAttributes.back().insert(</a>
<a name="ln655">							pair&lt;uint32, const char*&gt;(key, *arg));</a>
<a name="ln656">				}</a>
<a name="ln657">				break;</a>
<a name="ln658"> </a>
<a name="ln659">			default:</a>
<a name="ln660">				throw Error(&quot;internal error. wrong mode: %d&quot;, I-&gt;second-&gt;fType);</a>
<a name="ln661">		}</a>
<a name="ln662">	}</a>
<a name="ln663"> </a>
<a name="ln664">	// check some mutual exclusive conditions</a>
<a name="ln665">	if (fOpMode == kOpModeUndefined)</a>
<a name="ln666">		throw Error(kNeedArgMessage);</a>
<a name="ln667"> </a>
<a name="ln668">	if (Type() != NULL &amp;&amp; InitCheck() != B_OK)</a>
<a name="ln669">		throw Error(&quot;error instantiating mime for '%s': %s&quot;,</a>
<a name="ln670">							Type(), strerror(InitCheck()));</a>
<a name="ln671"> </a>
<a name="ln672">	fDoAdd = fOpMode == hash_function(kAdd);</a>
<a name="ln673">	fDoSet = fOpMode == hash_function(kSet);</a>
<a name="ln674">	fDoForce = fOpMode == hash_function(kForce);</a>
<a name="ln675">	fDoRemove = fOpMode == hash_function(kRemove);</a>
<a name="ln676">	fDumpNormal = fOpMode == hash_function(kDump);</a>
<a name="ln677">	fDumpRule = fOpMode == hash_function(kDumpSniffRule);</a>
<a name="ln678">	fDumpIcon = fOpMode == hash_function(kDumpIcon);</a>
<a name="ln679">	fDumpAll = fOpMode == hash_function(kDumpAll);</a>
<a name="ln680">	fCheckSniffRule = fOpMode == hash_function(kCheckSniffRule);</a>
<a name="ln681"> </a>
<a name="ln682">	if (fDoAdd || fDoSet || fDoForce || fDoRemove) {</a>
<a name="ln683">		if (Type() == NULL)</a>
<a name="ln684">			throw Error(&quot;signature should be specified&quot;);</a>
<a name="ln685"> </a>
<a name="ln686">		if (!IsValid())</a>
<a name="ln687">			throw Error(&quot;mime for '%s' is not valid&quot;, Type());</a>
<a name="ln688"> </a>
<a name="ln689">	} else if (fDumpNormal || fDumpRule || fDumpIcon || fDumpAll) {</a>
<a name="ln690">		if (Type() != NULL) {</a>
<a name="ln691">			if (!IsValid())</a>
<a name="ln692">				throw Error(&quot;mime for '%s' is not valid&quot;, Type());</a>
<a name="ln693"> </a>
<a name="ln694">			if (!IsInstalled())</a>
<a name="ln695">				throw Error(&quot;mime for '%s' is not installed&quot;, Type());</a>
<a name="ln696">		}</a>
<a name="ln697">	}</a>
<a name="ln698"> </a>
<a name="ln699">	// finally force to load mime-specific fileds</a>
<a name="ln700">	_SetTo(Type());</a>
<a name="ln701">}</a>
<a name="ln702"> </a>
<a name="ln703"> </a>
<a name="ln704">status_t</a>
<a name="ln705">MimeType::_InitCheck()</a>
<a name="ln706">{</a>
<a name="ln707">	return fStatus != B_OK ? fStatus : BMimeType::InitCheck();</a>
<a name="ln708">}</a>
<a name="ln709"> </a>
<a name="ln710"> </a>
<a name="ln711">void</a>
<a name="ln712">MimeType::_PurgeProperties()</a>
<a name="ln713">{</a>
<a name="ln714">	fShort.Truncate(0);</a>
<a name="ln715">	fLong.Truncate(0);</a>
<a name="ln716">	fPrefApp.Truncate(0);</a>
<a name="ln717">	fPrefAppSig.Truncate(0);</a>
<a name="ln718">	fSniffRule.Truncate(0);</a>
<a name="ln719"> </a>
<a name="ln720">	delete fSmallIcon;</a>
<a name="ln721">	fSmallIcon = NULL;</a>
<a name="ln722"> </a>
<a name="ln723">	delete fBigIcon;</a>
<a name="ln724">	fBigIcon = NULL;</a>
<a name="ln725"> </a>
<a name="ln726">	fVectorIcon = NULL;</a>
<a name="ln727">	free(fVectorIcon);</a>
<a name="ln728"> </a>
<a name="ln729">	fExtensions.clear();</a>
<a name="ln730">	fAttributes.clear();</a>
<a name="ln731">}</a>
<a name="ln732"> </a>
<a name="ln733"> </a>
<a name="ln734">void</a>
<a name="ln735">MimeType::_DumpIcon(uint8 *iconData, size_t iconSize)</a>
<a name="ln736">{</a>
<a name="ln737">	// bitmap icons ASCII art :)</a>
<a name="ln738">	int lineLimit = iconSize == B_MINI_ICON * B_MINI_ICON</a>
<a name="ln739">						? B_MINI_ICON : B_LARGE_ICON;</a>
<a name="ln740"> </a>
<a name="ln741">	ios::fmtflags flags = cout.flags();</a>
<a name="ln742"> </a>
<a name="ln743">	for (size_t i = 0; i &lt; iconSize; i++) {</a>
<a name="ln744">		if (i % lineLimit == 0 &amp;&amp; i != iconSize - 1)</a>
<a name="ln745">			cout &lt;&lt; &quot;\\&quot; &lt;&lt; endl;</a>
<a name="ln746"> </a>
<a name="ln747">		cout &lt;&lt; hex &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; (uint16) iconData[i];</a>
<a name="ln748">	}</a>
<a name="ln749"> </a>
<a name="ln750">	cout.flags(flags);</a>
<a name="ln751">}</a>
<a name="ln752"> </a>
<a name="ln753"> </a>
<a name="ln754">void</a>
<a name="ln755">MimeType::_SetIcon(const char* iconData, int32 iconSize)</a>
<a name="ln756">{</a>
<a name="ln757">	uint8* bits = NULL;</a>
<a name="ln758">	BRect rect(0, 0, iconSize - 1, iconSize - 1);</a>
<a name="ln759"> </a>
<a name="ln760">	switch (iconSize) {</a>
<a name="ln761">		case B_MINI_ICON:</a>
<a name="ln762">			if (fSmallIcon == NULL)</a>
<a name="ln763">				fSmallIcon = new BBitmap(rect, B_COLOR_8_BIT);</a>
<a name="ln764">			bits = (uint8*) fSmallIcon-&gt;Bits();</a>
<a name="ln765">			break;</a>
<a name="ln766">		case B_LARGE_ICON:</a>
<a name="ln767">			if (fBigIcon == NULL)</a>
<a name="ln768">				fBigIcon = new BBitmap(rect, B_COLOR_8_BIT);</a>
<a name="ln769">			bits = (uint8*) fBigIcon-&gt;Bits();</a>
<a name="ln770">			break;</a>
<a name="ln771">		default:</a>
<a name="ln772">			if (iconSize &gt;= 0)</a>
<a name="ln773">				break;</a>
<a name="ln774">			free(fVectorIcon);</a>
<a name="ln775">			fVectorIconSize = -iconSize;</a>
<a name="ln776">			bits = fVectorIcon = (uint8*) malloc(fVectorIconSize);</a>
<a name="ln777">			break;</a>
<a name="ln778">	}</a>
<a name="ln779"> </a>
<a name="ln780">	if (bits == NULL)</a>
<a name="ln781">		throw Error(&quot;cannot create icon of size %d&quot;, iconSize);</a>
<a name="ln782"> </a>
<a name="ln783">	size_t dataSize = iconSize &lt; 0 ? -iconSize / 2 : iconSize * iconSize;</a>
<a name="ln784"> </a>
<a name="ln785">	for (size_t i = 0; i &lt; dataSize; i++) {</a>
<a name="ln786">		stringstream ss;</a>
<a name="ln787">		uint16 val;</a>
<a name="ln788">		ss &lt;&lt; setbase(16) &lt;&lt; iconData[i * 2] &lt;&lt; iconData[i * 2 + 1];</a>
<a name="ln789">		ss &gt;&gt; val;</a>
<a name="ln790">		bits[i] = uint8(val &amp; 0xff);</a>
<a name="ln791">	}</a>
<a name="ln792"> </a>
<a name="ln793">	if (iconSize &lt; 0)</a>
<a name="ln794">		SetIcon(fVectorIcon, dataSize);</a>
<a name="ln795">	else</a>
<a name="ln796">		SetIcon(iconSize == B_MINI_ICON ? fSmallIcon : fBigIcon,</a>
<a name="ln797">					(icon_size) iconSize);</a>
<a name="ln798">}</a>
<a name="ln799"> </a>
<a name="ln800"> </a>
<a name="ln801">void</a>
<a name="ln802">MimeType::_SetTo(const char* mimetype) throw (Error)</a>
<a name="ln803">{</a>
<a name="ln804">	if (mimetype == NULL)</a>
<a name="ln805">		return; // iterate all types - nothing to load ATM</a>
<a name="ln806"> </a>
<a name="ln807">	if (BMimeType::SetTo(mimetype) != B_OK)</a>
<a name="ln808">		throw Error(&quot;failed to set mimetype to '%s'&quot;, mimetype);</a>
<a name="ln809"> </a>
<a name="ln810">	_PurgeProperties();</a>
<a name="ln811"> </a>
<a name="ln812">	char buffer[B_MIME_TYPE_LENGTH] = { 0 };</a>
<a name="ln813">	if (GetShortDescription(buffer) == B_OK)</a>
<a name="ln814">		fShort.SetTo(buffer, B_MIME_TYPE_LENGTH);</a>
<a name="ln815"> </a>
<a name="ln816">	if (GetLongDescription(buffer) == B_OK)</a>
<a name="ln817">		fLong.SetTo(buffer, B_MIME_TYPE_LENGTH);</a>
<a name="ln818"> </a>
<a name="ln819">	entry_ref ref;</a>
<a name="ln820">	if (GetAppHint(&amp;ref) == B_OK) {</a>
<a name="ln821">		BPath path(&amp;ref);</a>
<a name="ln822">		fPrefApp.SetTo(path.Path(), B_MIME_TYPE_LENGTH);</a>
<a name="ln823">	}</a>
<a name="ln824"> </a>
<a name="ln825">	if (GetPreferredApp(buffer, B_OPEN) == B_OK)</a>
<a name="ln826">		fPrefAppSig.SetTo(buffer, B_MIME_TYPE_LENGTH);</a>
<a name="ln827"> </a>
<a name="ln828">	BString rule;</a>
<a name="ln829">	if (GetSnifferRule(&amp;rule) == B_OK)</a>
<a name="ln830">		fSniffRule.CharacterEscape(rule.String(), &quot;\'&quot;, '\\');</a>
<a name="ln831"> </a>
<a name="ln832">	BMessage exts;</a>
<a name="ln833">	fExtensions.clear();</a>
<a name="ln834">	if (GetFileExtensions(&amp;exts) == B_OK) {</a>
<a name="ln835">		uint32 i = 0;</a>
<a name="ln836">		const char* ext = NULL;</a>
<a name="ln837">		while (exts.FindString(&quot;extensions&quot;, i++, &amp;ext) == B_OK)</a>
<a name="ln838">			fExtensions.insert(pair&lt;uint32, BString&gt;(hash_function(ext), ext));</a>
<a name="ln839">	}</a>
<a name="ln840"> </a>
<a name="ln841">	BMessage attrs;</a>
<a name="ln842">	fAttributes.clear();</a>
<a name="ln843">	if (GetAttrInfo(&amp;attrs) == B_OK) {</a>
<a name="ln844">		for (int index = 0; ; index++) {</a>
<a name="ln845">			MimeAttribute attr(attrs, index);</a>
<a name="ln846">			if (attr.InitCheck() != B_OK)</a>
<a name="ln847">				break;</a>
<a name="ln848"> </a>
<a name="ln849">			fAttributes.insert(</a>
<a name="ln850">					pair&lt;uint32, MimeAttribute&gt;(hash_function(attr.fName), attr));</a>
<a name="ln851">		}</a>
<a name="ln852">	}</a>
<a name="ln853"> </a>
<a name="ln854">	fSmallIcon = new BBitmap(BRect(0, 0, 15, 15), B_COLOR_8_BIT);</a>
<a name="ln855">	if (GetIcon(fSmallIcon, B_MINI_ICON) != B_OK) {</a>
<a name="ln856">		delete fSmallIcon;</a>
<a name="ln857">		fSmallIcon = NULL;</a>
<a name="ln858">	}</a>
<a name="ln859"> </a>
<a name="ln860">	fBigIcon = new BBitmap(BRect(0, 0, 31, 31), B_COLOR_8_BIT);</a>
<a name="ln861">	if (GetIcon(fBigIcon, B_LARGE_ICON) != B_OK) {</a>
<a name="ln862">		delete fBigIcon;</a>
<a name="ln863">		fBigIcon = NULL;</a>
<a name="ln864">	}</a>
<a name="ln865"> </a>
<a name="ln866">	if (GetIcon(&amp;fVectorIcon, &amp;fVectorIconSize) != B_OK)</a>
<a name="ln867">		fVectorIcon = NULL;</a>
<a name="ln868">}</a>
<a name="ln869"> </a>
<a name="ln870"> </a>
<a name="ln871">const char*</a>
<a name="ln872">MimeType::_UserArgValue(const char* name)</a>
<a name="ln873">{</a>
<a name="ln874">	TUserArgsI i = fUserArguments.find(hash_function(name));</a>
<a name="ln875">	if (i == fUserArguments.end())</a>
<a name="ln876">		return NULL;</a>
<a name="ln877"> </a>
<a name="ln878">	return i-&gt;second != NULL ? i-&gt;second : &quot;&quot;;</a>
<a name="ln879">}</a>
<a name="ln880"> </a>
<a name="ln881"> </a>
<a name="ln882">void</a>
<a name="ln883">MimeType::_Dump(const char* mimetype) throw (Error)</a>
<a name="ln884">{</a>
<a name="ln885">	// _Dump can be called as part of all types iteration - so set to required</a>
<a name="ln886">	if (Type() == NULL || strcasecmp(Type(), mimetype) != 0)</a>
<a name="ln887">		_SetTo(mimetype);</a>
<a name="ln888"> </a>
<a name="ln889">	// apps have themself as preferred app - use it to handle</a>
<a name="ln890">	// -includeApps option - do not dump applications info</a>
<a name="ln891">	if (!fPrefApp.IsEmpty()</a>
<a name="ln892">		&amp;&amp; fPrefApp.ICompare(mimetype) == 0</a>
<a name="ln893">		&amp;&amp; _UserArgValue(kIncludeApps) == NULL)</a>
<a name="ln894">			return;</a>
<a name="ln895"> </a>
<a name="ln896">	if (fDumpIcon &amp;&amp; fSmallIcon == NULL &amp;&amp; fBigIcon == NULL)</a>
<a name="ln897">		return;</a>
<a name="ln898"> </a>
<a name="ln899">	if (fDumpRule &amp;&amp; fSniffRule.IsEmpty())</a>
<a name="ln900">		return;</a>
<a name="ln901"> </a>
<a name="ln902">	cout &lt;&lt; fToolName &lt;&lt; &quot; -set &quot; &lt;&lt; mimetype;</a>
<a name="ln903"> </a>
<a name="ln904">	if (fDumpNormal || fDumpAll) {</a>
<a name="ln905">		if (!fShort.IsEmpty())</a>
<a name="ln906">			cout &lt;&lt; &quot; &quot; &lt;&lt; kShort &lt;&lt; &quot; \&quot;&quot; &lt;&lt; fShort &lt;&lt; &quot;\&quot;&quot;;</a>
<a name="ln907">		if (!fLong.IsEmpty())</a>
<a name="ln908">			cout &lt;&lt; &quot; &quot; &lt;&lt; kLong &lt;&lt; &quot; \&quot;&quot; &lt;&lt; fLong &lt;&lt; &quot;\&quot;&quot;;</a>
<a name="ln909">		if (!fPrefApp.IsEmpty())</a>
<a name="ln910">			cout &lt;&lt; &quot; &quot; &lt;&lt; kPreferredApp &lt;&lt; &quot; &quot; &lt;&lt; fPrefApp;</a>
<a name="ln911">		if (!fPrefAppSig.IsEmpty())</a>
<a name="ln912">			cout &lt;&lt; &quot; &quot; &lt;&lt; kPreferredAppSig &lt;&lt; &quot; &quot; &lt;&lt; fPrefAppSig;</a>
<a name="ln913">	}</a>
<a name="ln914"> </a>
<a name="ln915">	if (!fDumpIcon &amp;&amp; !fSniffRule.IsEmpty())</a>
<a name="ln916">		cout &lt;&lt; &quot; &quot; &lt;&lt; kSniffRule &lt;&lt; &quot; '&quot; &lt;&lt; fSniffRule &lt;&lt; &quot;'&quot;;</a>
<a name="ln917"> </a>
<a name="ln918">	if (fDumpNormal || fDumpAll)</a>
<a name="ln919">		for (map&lt;uint32, BString&gt;::iterator i = fExtensions.begin();</a>
<a name="ln920">				i != fExtensions.end(); i++)</a>
<a name="ln921">			cout &lt;&lt; &quot; &quot; &lt;&lt; kExtension &lt;&lt; &quot; &quot; &lt;&lt; i-&gt;second;</a>
<a name="ln922"> </a>
<a name="ln923">	if (fDumpAll)</a>
<a name="ln924">		for (map&lt;uint32, MimeAttribute&gt;::iterator i = fAttributes.begin();</a>
<a name="ln925">				i != fAttributes.end(); i++)</a>
<a name="ln926">			i-&gt;second.Dump();</a>
<a name="ln927"> </a>
<a name="ln928">	if (fDumpIcon || fDumpAll) {</a>
<a name="ln929">		if (fSmallIcon != NULL &amp;&amp; fSmallIcon-&gt;Bits() != NULL) {</a>
<a name="ln930">			cout &lt;&lt; &quot; \\&quot; &lt;&lt; endl &lt;&lt; &quot;\t&quot; &lt;&lt; kMiniIcon &lt;&lt; &quot; &quot;;</a>
<a name="ln931">			_DumpIcon((uint8*) fSmallIcon-&gt;Bits(), fSmallIcon-&gt;BitsLength());</a>
<a name="ln932">		}</a>
<a name="ln933"> </a>
<a name="ln934">		if (fBigIcon != NULL &amp;&amp; fBigIcon-&gt;Bits() != NULL) {</a>
<a name="ln935">			cout &lt;&lt; &quot; \\&quot; &lt;&lt; endl &lt;&lt; &quot;\t&quot; &lt;&lt; kLargeIcon &lt;&lt; &quot; &quot;;</a>
<a name="ln936">			_DumpIcon((uint8*) fBigIcon-&gt;Bits(), fBigIcon-&gt;BitsLength());</a>
<a name="ln937">		}</a>
<a name="ln938"> </a>
<a name="ln939">		if (fVectorIcon != NULL &amp;&amp; fVectorIconSize != 0) {</a>
<a name="ln940">			cout &lt;&lt; &quot; \\&quot; &lt;&lt; endl &lt;&lt; &quot;\t&quot; &lt;&lt; kVectorIcon &lt;&lt; &quot; &quot;;</a>
<a name="ln941">			_DumpIcon((uint8*) fVectorIcon, fVectorIconSize);</a>
<a name="ln942">		}</a>
<a name="ln943">	}</a>
<a name="ln944"> </a>
<a name="ln945">	cout &lt;&lt; endl;</a>
<a name="ln946">}</a>
<a name="ln947"> </a>
<a name="ln948"> </a>
<a name="ln949">void</a>
<a name="ln950">MimeType::_DoEdit() throw (Error)</a>
<a name="ln951">{</a>
<a name="ln952">	if (fDoRemove || fDoForce) {</a>
<a name="ln953">		status_t result = Delete();</a>
<a name="ln954">		if (result != B_OK)</a>
<a name="ln955">			throw Error(strerror(result), result);</a>
<a name="ln956"> </a>
<a name="ln957">		if (fDoRemove)</a>
<a name="ln958">			return;</a>
<a name="ln959"> </a>
<a name="ln960">		_PurgeProperties();</a>
<a name="ln961">	}</a>
<a name="ln962"> </a>
<a name="ln963">	if (!IsInstalled() &amp;&amp; Install() != B_OK)</a>
<a name="ln964">		throw Error(&quot;could not install mimetype '%s'&quot;, Type());</a>
<a name="ln965"> </a>
<a name="ln966">	const char* value = _UserArgValue(kShort);</a>
<a name="ln967">	if (value != NULL &amp;&amp; (!fDoAdd || fShort.IsEmpty()))</a>
<a name="ln968">		if (SetShortDescription(value) != B_OK)</a>
<a name="ln969">			throw Error(&quot;cannot set %s to %s for '%s'&quot;, kShort, value, Type());</a>
<a name="ln970"> </a>
<a name="ln971">	value = _UserArgValue(kLong);</a>
<a name="ln972">	if (value != NULL &amp;&amp; (!fDoAdd || fLong.IsEmpty()))</a>
<a name="ln973">		if (SetLongDescription(value) != B_OK)</a>
<a name="ln974">			throw Error(&quot;cannot set %s to %s for '%s'&quot;, kLong, value, Type());</a>
<a name="ln975"> </a>
<a name="ln976">	value = _UserArgValue(kPreferredApp);</a>
<a name="ln977">	if (value != NULL &amp;&amp; (!fDoAdd || fPrefApp.IsEmpty())) {</a>
<a name="ln978">		entry_ref appHint;</a>
<a name="ln979">		if (get_ref_for_path(value, &amp;appHint) != B_OK)</a>
<a name="ln980">			throw Error(&quot;%s ref_entry for '%s' couldn't be found for '%s'&quot;,</a>
<a name="ln981">						kPreferredApp, value, Type());</a>
<a name="ln982"> </a>
<a name="ln983">		if (SetAppHint(&amp;appHint) != B_OK)</a>
<a name="ln984">			throw Error(&quot;cannot set %s to %s for '%s'&quot;,</a>
<a name="ln985">					kPreferredApp, value, Type());</a>
<a name="ln986">	}</a>
<a name="ln987"> </a>
<a name="ln988">	value = _UserArgValue(kPreferredAppSig);</a>
<a name="ln989">	if (value != NULL &amp;&amp; (!fDoAdd || fPrefAppSig.IsEmpty()))</a>
<a name="ln990">		if (SetPreferredApp(value) != B_OK)</a>
<a name="ln991">			throw Error(&quot;cannot set %s to %s for '%s'&quot;,</a>
<a name="ln992">					kPreferredAppSig, value, Type());</a>
<a name="ln993"> </a>
<a name="ln994">	value = _UserArgValue(kSniffRule);</a>
<a name="ln995">	if (value != NULL &amp;&amp; (!fDoAdd || fSniffRule.IsEmpty()))</a>
<a name="ln996">		if (SetSnifferRule(value) != B_OK)</a>
<a name="ln997">			throw Error(&quot;cannot set %s to %s for '%s'&quot;,</a>
<a name="ln998">					kSniffRule, value, Type());</a>
<a name="ln999"> </a>
<a name="ln1000">	value = _UserArgValue(kMiniIcon);</a>
<a name="ln1001">	if (value != NULL &amp;&amp; (!fDoAdd || fSmallIcon == NULL)) {</a>
<a name="ln1002">		int32 iconSize = strlen(value);</a>
<a name="ln1003">		if (iconSize / 2 != B_MINI_ICON * B_MINI_ICON)</a>
<a name="ln1004">			throw Error(&quot;cannot set %s for '%s'. Hex data size %d is invalid&quot;,</a>
<a name="ln1005">					kMiniIcon, Type(), iconSize);</a>
<a name="ln1006"> </a>
<a name="ln1007">		_SetIcon(value, B_MINI_ICON);</a>
<a name="ln1008">	}</a>
<a name="ln1009"> </a>
<a name="ln1010">	value = _UserArgValue(kLargeIcon);</a>
<a name="ln1011">	if (value != NULL &amp;&amp; (!fDoAdd || fBigIcon == NULL)) {</a>
<a name="ln1012">		int32 iconSize = strlen(value);</a>
<a name="ln1013">		if (iconSize / 2 != B_LARGE_ICON * B_LARGE_ICON)</a>
<a name="ln1014">			throw Error(&quot;cannot set %s for '%s'. Hex data size %d is invalid&quot;,</a>
<a name="ln1015">					kLargeIcon, Type(), iconSize);</a>
<a name="ln1016"> </a>
<a name="ln1017">		_SetIcon(value, B_LARGE_ICON);</a>
<a name="ln1018">	}</a>
<a name="ln1019"> </a>
<a name="ln1020">	value = _UserArgValue(kVectorIcon);</a>
<a name="ln1021">	if (value != NULL &amp;&amp; (!fDoAdd || fVectorIcon == NULL)) {</a>
<a name="ln1022">		int32 iconSize = strlen(value);</a>
<a name="ln1023">		if ((iconSize % 2) != 0)</a>
<a name="ln1024">			throw Error(&quot;cannot set %s for '%s'. Hex data size %d is invalid&quot;,</a>
<a name="ln1025">					kVectorIcon, Type(), iconSize);</a>
<a name="ln1026"> </a>
<a name="ln1027">		// vector icon size is negative intended</a>
<a name="ln1028">		_SetIcon(value, -iconSize);</a>
<a name="ln1029">	}</a>
<a name="ln1030"> </a>
<a name="ln1031">	// handle extensions update</a>
<a name="ln1032">	pair&lt;TUserArgsI, TUserArgsI&gt; exts</a>
<a name="ln1033">							= fUserArguments.equal_range(hash_function(kExtension));</a>
<a name="ln1034">	for (TUserArgsI i = exts.first; i != exts.second; i++) {</a>
<a name="ln1035">		uint32 key = hash_function(i-&gt;second);</a>
<a name="ln1036">		if (fExtensions.find(key) == fExtensions.end())</a>
<a name="ln1037">			fExtensions.insert(pair&lt;uint32, BString&gt;(key, i-&gt;second));</a>
<a name="ln1038">	}</a>
<a name="ln1039"> </a>
<a name="ln1040">	if (exts.first != exts.second) {</a>
<a name="ln1041">		BMessage msg;</a>
<a name="ln1042">		for (map&lt;uint32, BString&gt;::iterator i = fExtensions.begin();</a>
<a name="ln1043">				i != fExtensions.end(); i++)</a>
<a name="ln1044">			if (msg.AddString(&quot;extensions&quot;, i-&gt;second.String()) != B_OK)</a>
<a name="ln1045">				throw Error(&quot;extension '%s' couldn't be added&quot;,</a>
<a name="ln1046">					i-&gt;second.String());</a>
<a name="ln1047"> </a>
<a name="ln1048">		if (SetFileExtensions(&amp;msg) != B_OK)</a>
<a name="ln1049">			throw Error(&quot;set file extensions failed&quot;);</a>
<a name="ln1050">	}</a>
<a name="ln1051"> </a>
<a name="ln1052">	// take care about attribute trees</a>
<a name="ln1053">	for (TUserAttrsI userAttr = fUserAttributes.begin();</a>
<a name="ln1054">			userAttr != fUserAttributes.end(); userAttr++ )</a>
<a name="ln1055">	{</a>
<a name="ln1056">		// search for -attribute &quot;name&quot; in args map</a>
<a name="ln1057">		TUserArgsI attrArgs = userAttr-&gt;find(hash_function(kAttribute));</a>
<a name="ln1058">		if (attrArgs == userAttr-&gt;end())</a>
<a name="ln1059">			throw Error(&quot;internal error: %s arg not found&quot;, kAttribute);</a>
<a name="ln1060"> </a>
<a name="ln1061">		// check if we already have this attribute cached</a>
<a name="ln1062">		map&lt;uint32, MimeAttribute&gt;::iterator</a>
<a name="ln1063">								attr = fAttributes.find(hash_function(attrArgs-&gt;second));</a>
<a name="ln1064">		if (attr == fAttributes.end()) {</a>
<a name="ln1065">			// add new one</a>
<a name="ln1066">			MimeAttribute mimeAttr(*userAttr);</a>
<a name="ln1067">			fAttributes.insert(</a>
<a name="ln1068">				pair&lt;uint32, MimeAttribute&gt;(hash_function(mimeAttr.fName), mimeAttr));</a>
<a name="ln1069">		} else if (!fDoAdd)</a>
<a name="ln1070">			attr-&gt;second.SyncWith(*userAttr);</a>
<a name="ln1071">	}</a>
<a name="ln1072"> </a>
<a name="ln1073">	if (fAttributes.size() &gt; 0) {</a>
<a name="ln1074">		BMessage msg;</a>
<a name="ln1075">		for (map&lt;uint32, MimeAttribute&gt;::iterator i = fAttributes.begin();</a>
<a name="ln1076">				i != fAttributes.end(); i++)</a>
<a name="ln1077">		{</a>
<a name="ln1078">			i-&gt;second.StoreInto(&amp;msg);</a>
<a name="ln1079">			if (i-&gt;second.InitCheck() != B_OK)</a>
<a name="ln1080">				throw Error(&quot;storing attributes in message failed&quot;);</a>
<a name="ln1081">		}</a>
<a name="ln1082"> </a>
<a name="ln1083">		if (SetAttrInfo(&amp;msg) != B_OK)</a>
<a name="ln1084">			throw Error(&quot;set mimetype attributes failed&quot;);</a>
<a name="ln1085">	}</a>
<a name="ln1086">}</a>
<a name="ln1087"> </a>
<a name="ln1088"> </a>
<a name="ln1089">void</a>
<a name="ln1090">MimeType::Process() throw (Error)</a>
<a name="ln1091">{</a>
<a name="ln1092">	if (fCheckSniffRule) {</a>
<a name="ln1093">		TUserArgsI I = fUserArguments.find(fOpMode);</a>
<a name="ln1094">		if (I == fUserArguments.end())</a>
<a name="ln1095">			throw Error(&quot;Sniffer rule is empty&quot;);</a>
<a name="ln1096"> </a>
<a name="ln1097">		BString error;</a>
<a name="ln1098">		status_t result = BMimeType::CheckSnifferRule(I-&gt;second, &amp;error);</a>
<a name="ln1099">		if (result == B_OK)</a>
<a name="ln1100">			cerr &lt;&lt; I-&gt;second &lt;&lt; endl &lt;&lt; &quot;Sniffer rule is correct&quot; &lt;&lt; endl;</a>
<a name="ln1101">		else</a>
<a name="ln1102">			cerr &lt;&lt;  error.String() &lt;&lt; endl;</a>
<a name="ln1103"> </a>
<a name="ln1104">		return;</a>
<a name="ln1105">	}</a>
<a name="ln1106"> </a>
<a name="ln1107">	if (fDoAdd || fDoSet || fDoForce || fDoRemove) {</a>
<a name="ln1108">		_DoEdit();</a>
<a name="ln1109">		return;</a>
<a name="ln1110">	}</a>
<a name="ln1111"> </a>
<a name="ln1112">	if (fDumpNormal || fDumpRule || fDumpIcon || fDumpAll) {</a>
<a name="ln1113">		if (Type() != NULL) {</a>
<a name="ln1114">			_Dump(Type());</a>
<a name="ln1115">			return;</a>
<a name="ln1116">		}</a>
<a name="ln1117"> </a>
<a name="ln1118">		BMessage superTypes;</a>
<a name="ln1119">		int32 superCount = 0;</a>
<a name="ln1120">		type_code type = B_INT32_TYPE;</a>
<a name="ln1121">		if (BMimeType::GetInstalledSupertypes(&amp;superTypes) != B_OK</a>
<a name="ln1122">			|| superTypes.GetInfo(&quot;super_types&quot;, &amp;type, &amp;superCount) != B_OK)</a>
<a name="ln1123">			throw Error(&quot;super types enumeration failed&quot;);</a>
<a name="ln1124"> </a>
<a name="ln1125">		for (int32 si = 0; si &lt; superCount; si++) {</a>
<a name="ln1126">			const char* superName = NULL;</a>
<a name="ln1127">			if (superTypes.FindString(&quot;super_types&quot;, si, &amp;superName) != B_OK)</a>
<a name="ln1128">				throw Error(&quot;name for supertype #%d not found&quot;, si);</a>
<a name="ln1129"> </a>
<a name="ln1130">			BMessage types;</a>
<a name="ln1131">			if (BMimeType::GetInstalledTypes(superName, &amp;types) != B_OK)</a>
<a name="ln1132">				throw Error(&quot;mimetypes of supertype '%s' not found&quot;, superName);</a>
<a name="ln1133"> </a>
<a name="ln1134">			int32 count = 0;</a>
<a name="ln1135">			if (types.GetInfo(&quot;types&quot;, &amp;type, &amp;count) != B_OK)</a>
<a name="ln1136">				continue; // no sub-types?</a>
<a name="ln1137"> </a>
<a name="ln1138">			for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln1139">				const char* name = NULL;</a>
<a name="ln1140">				if (types.FindString(&quot;types&quot;, i, &amp;name) != B_OK)</a>
<a name="ln1141">					throw Error(&quot;name for type %s/#%d not found&quot;, superName, i);</a>
<a name="ln1142"> </a>
<a name="ln1143">				_Dump(name);</a>
<a name="ln1144">			}</a>
<a name="ln1145">		}</a>
<a name="ln1146">	}</a>
<a name="ln1147">}</a>
<a name="ln1148"> </a>
<a name="ln1149"> </a>
<a name="ln1150">int</a>
<a name="ln1151">main(int argc, char** argv)</a>
<a name="ln1152">{</a>
<a name="ln1153">	// AppServer link is required to work with bitmaps</a>
<a name="ln1154">	BApplication app(&quot;application/x-vnd.haiku.setmime&quot;);</a>
<a name="ln1155"> </a>
<a name="ln1156">	try {</a>
<a name="ln1157"> </a>
<a name="ln1158">		if (argc &lt; 2)</a>
<a name="ln1159">			throw Error(kNeedArgMessage);</a>
<a name="ln1160"> </a>
<a name="ln1161">		MimeType mimetype(argv);</a>
<a name="ln1162"> </a>
<a name="ln1163">		mimetype.Process();</a>
<a name="ln1164"> </a>
<a name="ln1165">	} catch(exception&amp; exc) {</a>
<a name="ln1166">		cerr &lt;&lt; argv[0] &lt;&lt; &quot; : &quot; &lt;&lt; exc.what() &lt;&lt; endl;</a>
<a name="ln1167">		cerr &lt;&lt;	kUsageMessage;</a>
<a name="ln1168">		return B_ERROR;</a>
<a name="ln1169">	}</a>
<a name="ln1170"> </a>
<a name="ln1171">	return B_OK;</a>
<a name="ln1172">}</a>
<a name="ln1173"> </a>

</code></pre>
<div class="balloon" rel="727"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v575/" target="_blank">V575</a> The null pointer is passed into 'free' function. Inspect the first argument.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
