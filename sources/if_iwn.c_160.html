
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>if_iwn.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * Copyright (c) 2007-2009 Damien Bergamini &lt;damien.bergamini@free.fr&gt;</a>
<a name="ln3"> * Copyright (c) 2008 Benjamin Close &lt;benjsc@FreeBSD.org&gt;</a>
<a name="ln4"> * Copyright (c) 2008 Sam Leffler, Errno Consulting</a>
<a name="ln5"> * Copyright (c) 2011 Intel Corporation</a>
<a name="ln6"> * Copyright (c) 2013 Cedric GROSS &lt;c.gross@kreiz-it.fr&gt;</a>
<a name="ln7"> * Copyright (c) 2013 Adrian Chadd &lt;adrian@FreeBSD.org&gt;</a>
<a name="ln8"> *</a>
<a name="ln9"> * Permission to use, copy, modify, and distribute this software for any</a>
<a name="ln10"> * purpose with or without fee is hereby granted, provided that the above</a>
<a name="ln11"> * copyright notice and this permission notice appear in all copies.</a>
<a name="ln12"> *</a>
<a name="ln13"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES</a>
<a name="ln14"> * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</a>
<a name="ln15"> * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR</a>
<a name="ln16"> * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</a>
<a name="ln17"> * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</a>
<a name="ln18"> * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</a>
<a name="ln19"> * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">/*</a>
<a name="ln23"> * Driver for Intel WiFi Link 4965 and 1000/5000/6000 Series 802.11 network</a>
<a name="ln24"> * adapters.</a>
<a name="ln25"> */</a>
<a name="ln26"> </a>
<a name="ln27">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln28">__FBSDID(&quot;$FreeBSD: releng/12.0/sys/dev/iwn/if_iwn.c 338949 2018-09-26 17:12:30Z imp $&quot;);</a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;sys/param.h&gt;</a>
<a name="ln31">#include &lt;sys/sockio.h&gt;</a>
<a name="ln32">#include &lt;sys/sysctl.h&gt;</a>
<a name="ln33">#include &lt;sys/mbuf.h&gt;</a>
<a name="ln34">#include &lt;sys/kernel.h&gt;</a>
<a name="ln35">#include &lt;sys/socket.h&gt;</a>
<a name="ln36">#include &lt;sys/systm.h&gt;</a>
<a name="ln37">#include &lt;sys/malloc.h&gt;</a>
<a name="ln38">#include &lt;sys/bus.h&gt;</a>
<a name="ln39">#include &lt;sys/conf.h&gt;</a>
<a name="ln40">#include &lt;sys/rman.h&gt;</a>
<a name="ln41">#include &lt;sys/endian.h&gt;</a>
<a name="ln42">#include &lt;sys/firmware.h&gt;</a>
<a name="ln43">#include &lt;sys/limits.h&gt;</a>
<a name="ln44">#include &lt;sys/module.h&gt;</a>
<a name="ln45">#include &lt;sys/priv.h&gt;</a>
<a name="ln46">#include &lt;sys/queue.h&gt;</a>
<a name="ln47">#include &lt;sys/taskqueue.h&gt;</a>
<a name="ln48"> </a>
<a name="ln49">#include &lt;machine/bus.h&gt;</a>
<a name="ln50">#include &lt;machine/resource.h&gt;</a>
<a name="ln51">#include &lt;machine/clock.h&gt;</a>
<a name="ln52"> </a>
<a name="ln53">#include &lt;dev/pci/pcireg.h&gt;</a>
<a name="ln54">#include &lt;dev/pci/pcivar.h&gt;</a>
<a name="ln55"> </a>
<a name="ln56">#include &lt;net/if.h&gt;</a>
<a name="ln57">#include &lt;net/if_var.h&gt;</a>
<a name="ln58">#include &lt;net/if_dl.h&gt;</a>
<a name="ln59">#include &lt;net/if_media.h&gt;</a>
<a name="ln60"> </a>
<a name="ln61">#include &lt;netinet/in.h&gt;</a>
<a name="ln62">#include &lt;netinet/if_ether.h&gt;</a>
<a name="ln63"> </a>
<a name="ln64">#include &lt;net80211/ieee80211_var.h&gt;</a>
<a name="ln65">#include &lt;net80211/ieee80211_radiotap.h&gt;</a>
<a name="ln66">#include &lt;net80211/ieee80211_regdomain.h&gt;</a>
<a name="ln67">#include &lt;net80211/ieee80211_ratectl.h&gt;</a>
<a name="ln68"> </a>
<a name="ln69">#include &lt;dev/iwn/if_iwnreg.h&gt;</a>
<a name="ln70">#include &lt;dev/iwn/if_iwnvar.h&gt;</a>
<a name="ln71">#include &lt;dev/iwn/if_iwn_devid.h&gt;</a>
<a name="ln72">#include &lt;dev/iwn/if_iwn_chip_cfg.h&gt;</a>
<a name="ln73">#include &lt;dev/iwn/if_iwn_debug.h&gt;</a>
<a name="ln74">#include &lt;dev/iwn/if_iwn_ioctl.h&gt;</a>
<a name="ln75"> </a>
<a name="ln76">struct iwn_ident {</a>
<a name="ln77">	uint16_t	vendor;</a>
<a name="ln78">	uint16_t	device;</a>
<a name="ln79">	const char	*name;</a>
<a name="ln80">};</a>
<a name="ln81"> </a>
<a name="ln82">static const struct iwn_ident iwn_ident_table[] = {</a>
<a name="ln83">	{ 0x8086, IWN_DID_6x05_1, &quot;Intel Centrino Advanced-N 6205&quot;		},</a>
<a name="ln84">	{ 0x8086, IWN_DID_1000_1, &quot;Intel Centrino Wireless-N 1000&quot;		},</a>
<a name="ln85">	{ 0x8086, IWN_DID_1000_2, &quot;Intel Centrino Wireless-N 1000&quot;		},</a>
<a name="ln86">	{ 0x8086, IWN_DID_6x05_2, &quot;Intel Centrino Advanced-N 6205&quot;		},</a>
<a name="ln87">	{ 0x8086, IWN_DID_6050_1, &quot;Intel Centrino Advanced-N + WiMAX 6250&quot;	},</a>
<a name="ln88">	{ 0x8086, IWN_DID_6050_2, &quot;Intel Centrino Advanced-N + WiMAX 6250&quot;	},</a>
<a name="ln89">	{ 0x8086, IWN_DID_x030_1, &quot;Intel Centrino Wireless-N 1030&quot;		},</a>
<a name="ln90">	{ 0x8086, IWN_DID_x030_2, &quot;Intel Centrino Wireless-N 1030&quot;		},</a>
<a name="ln91">	{ 0x8086, IWN_DID_x030_3, &quot;Intel Centrino Advanced-N 6230&quot;		},</a>
<a name="ln92">	{ 0x8086, IWN_DID_x030_4, &quot;Intel Centrino Advanced-N 6230&quot;		},</a>
<a name="ln93">	{ 0x8086, IWN_DID_6150_1, &quot;Intel Centrino Wireless-N + WiMAX 6150&quot;	},</a>
<a name="ln94">	{ 0x8086, IWN_DID_6150_2, &quot;Intel Centrino Wireless-N + WiMAX 6150&quot;	},</a>
<a name="ln95">	{ 0x8086, IWN_DID_2x00_1, &quot;Intel(R) Centrino(R) Wireless-N 2200 BGN&quot;	},</a>
<a name="ln96">	{ 0x8086, IWN_DID_2x00_2, &quot;Intel(R) Centrino(R) Wireless-N 2200 BGN&quot;	},</a>
<a name="ln97">	/* XXX 2200D is IWN_SDID_2x00_4; there's no way to express this here! */</a>
<a name="ln98">	{ 0x8086, IWN_DID_2x30_1, &quot;Intel Centrino Wireless-N 2230&quot;		},</a>
<a name="ln99">	{ 0x8086, IWN_DID_2x30_2, &quot;Intel Centrino Wireless-N 2230&quot;		},</a>
<a name="ln100">	{ 0x8086, IWN_DID_130_1, &quot;Intel Centrino Wireless-N 130&quot;		},</a>
<a name="ln101">	{ 0x8086, IWN_DID_130_2, &quot;Intel Centrino Wireless-N 130&quot;		},</a>
<a name="ln102">	{ 0x8086, IWN_DID_100_1, &quot;Intel Centrino Wireless-N 100&quot;		},</a>
<a name="ln103">	{ 0x8086, IWN_DID_100_2, &quot;Intel Centrino Wireless-N 100&quot;		},</a>
<a name="ln104">	{ 0x8086, IWN_DID_105_1, &quot;Intel Centrino Wireless-N 105&quot;		},</a>
<a name="ln105">	{ 0x8086, IWN_DID_105_2, &quot;Intel Centrino Wireless-N 105&quot;		},</a>
<a name="ln106">	{ 0x8086, IWN_DID_135_1, &quot;Intel Centrino Wireless-N 135&quot;		},</a>
<a name="ln107">	{ 0x8086, IWN_DID_135_2, &quot;Intel Centrino Wireless-N 135&quot;		},</a>
<a name="ln108">	{ 0x8086, IWN_DID_4965_1, &quot;Intel Wireless WiFi Link 4965&quot;		},</a>
<a name="ln109">	{ 0x8086, IWN_DID_6x00_1, &quot;Intel Centrino Ultimate-N 6300&quot;		},</a>
<a name="ln110">	{ 0x8086, IWN_DID_6x00_2, &quot;Intel Centrino Advanced-N 6200&quot;		},</a>
<a name="ln111">	{ 0x8086, IWN_DID_4965_2, &quot;Intel Wireless WiFi Link 4965&quot;		},</a>
<a name="ln112">	{ 0x8086, IWN_DID_4965_3, &quot;Intel Wireless WiFi Link 4965&quot;		},</a>
<a name="ln113">	{ 0x8086, IWN_DID_5x00_1, &quot;Intel WiFi Link 5100&quot;			},</a>
<a name="ln114">	{ 0x8086, IWN_DID_4965_4, &quot;Intel Wireless WiFi Link 4965&quot;		},</a>
<a name="ln115">	{ 0x8086, IWN_DID_5x00_3, &quot;Intel Ultimate N WiFi Link 5300&quot;		},</a>
<a name="ln116">	{ 0x8086, IWN_DID_5x00_4, &quot;Intel Ultimate N WiFi Link 5300&quot;		},</a>
<a name="ln117">	{ 0x8086, IWN_DID_5x00_2, &quot;Intel WiFi Link 5100&quot;			},</a>
<a name="ln118">	{ 0x8086, IWN_DID_6x00_3, &quot;Intel Centrino Ultimate-N 6300&quot;		},</a>
<a name="ln119">	{ 0x8086, IWN_DID_6x00_4, &quot;Intel Centrino Advanced-N 6200&quot;		},</a>
<a name="ln120">	{ 0x8086, IWN_DID_5x50_1, &quot;Intel WiMAX/WiFi Link 5350&quot;			},</a>
<a name="ln121">	{ 0x8086, IWN_DID_5x50_2, &quot;Intel WiMAX/WiFi Link 5350&quot;			},</a>
<a name="ln122">	{ 0x8086, IWN_DID_5x50_3, &quot;Intel WiMAX/WiFi Link 5150&quot;			},</a>
<a name="ln123">	{ 0x8086, IWN_DID_5x50_4, &quot;Intel WiMAX/WiFi Link 5150&quot;			},</a>
<a name="ln124">	{ 0x8086, IWN_DID_6035_1, &quot;Intel Centrino Advanced 6235&quot;		},</a>
<a name="ln125">	{ 0x8086, IWN_DID_6035_2, &quot;Intel Centrino Advanced 6235&quot;		},</a>
<a name="ln126">	{ 0, 0, NULL }</a>
<a name="ln127">};</a>
<a name="ln128"> </a>
<a name="ln129">static int	iwn_probe(device_t);</a>
<a name="ln130">static int	iwn_attach(device_t);</a>
<a name="ln131">static int	iwn4965_attach(struct iwn_softc *, uint16_t);</a>
<a name="ln132">static int	iwn5000_attach(struct iwn_softc *, uint16_t);</a>
<a name="ln133">static int	iwn_config_specific(struct iwn_softc *, uint16_t);</a>
<a name="ln134">static void	iwn_radiotap_attach(struct iwn_softc *);</a>
<a name="ln135">static void	iwn_sysctlattach(struct iwn_softc *);</a>
<a name="ln136">static struct ieee80211vap *iwn_vap_create(struct ieee80211com *,</a>
<a name="ln137">		    const char [IFNAMSIZ], int, enum ieee80211_opmode, int,</a>
<a name="ln138">		    const uint8_t [IEEE80211_ADDR_LEN],</a>
<a name="ln139">		    const uint8_t [IEEE80211_ADDR_LEN]);</a>
<a name="ln140">static void	iwn_vap_delete(struct ieee80211vap *);</a>
<a name="ln141">static int	iwn_detach(device_t);</a>
<a name="ln142">static int	iwn_shutdown(device_t);</a>
<a name="ln143">static int	iwn_suspend(device_t);</a>
<a name="ln144">static int	iwn_resume(device_t);</a>
<a name="ln145">static int	iwn_nic_lock(struct iwn_softc *);</a>
<a name="ln146">static int	iwn_eeprom_lock(struct iwn_softc *);</a>
<a name="ln147">static int	iwn_init_otprom(struct iwn_softc *);</a>
<a name="ln148">static int	iwn_read_prom_data(struct iwn_softc *, uint32_t, void *, int);</a>
<a name="ln149">static void	iwn_dma_map_addr(void *, bus_dma_segment_t *, int, int);</a>
<a name="ln150">static int	iwn_dma_contig_alloc(struct iwn_softc *, struct iwn_dma_info *,</a>
<a name="ln151">		    void **, bus_size_t, bus_size_t);</a>
<a name="ln152">static void	iwn_dma_contig_free(struct iwn_dma_info *);</a>
<a name="ln153">static int	iwn_alloc_sched(struct iwn_softc *);</a>
<a name="ln154">static void	iwn_free_sched(struct iwn_softc *);</a>
<a name="ln155">static int	iwn_alloc_kw(struct iwn_softc *);</a>
<a name="ln156">static void	iwn_free_kw(struct iwn_softc *);</a>
<a name="ln157">static int	iwn_alloc_ict(struct iwn_softc *);</a>
<a name="ln158">static void	iwn_free_ict(struct iwn_softc *);</a>
<a name="ln159">static int	iwn_alloc_fwmem(struct iwn_softc *);</a>
<a name="ln160">static void	iwn_free_fwmem(struct iwn_softc *);</a>
<a name="ln161">static int	iwn_alloc_rx_ring(struct iwn_softc *, struct iwn_rx_ring *);</a>
<a name="ln162">static void	iwn_reset_rx_ring(struct iwn_softc *, struct iwn_rx_ring *);</a>
<a name="ln163">static void	iwn_free_rx_ring(struct iwn_softc *, struct iwn_rx_ring *);</a>
<a name="ln164">static int	iwn_alloc_tx_ring(struct iwn_softc *, struct iwn_tx_ring *,</a>
<a name="ln165">		    int);</a>
<a name="ln166">static void	iwn_reset_tx_ring(struct iwn_softc *, struct iwn_tx_ring *);</a>
<a name="ln167">static void	iwn_free_tx_ring(struct iwn_softc *, struct iwn_tx_ring *);</a>
<a name="ln168">static void	iwn5000_ict_reset(struct iwn_softc *);</a>
<a name="ln169">static int	iwn_read_eeprom(struct iwn_softc *,</a>
<a name="ln170">		    uint8_t macaddr[IEEE80211_ADDR_LEN]);</a>
<a name="ln171">static void	iwn4965_read_eeprom(struct iwn_softc *);</a>
<a name="ln172">#ifdef	IWN_DEBUG</a>
<a name="ln173">static void	iwn4965_print_power_group(struct iwn_softc *, int);</a>
<a name="ln174">#endif</a>
<a name="ln175">static void	iwn5000_read_eeprom(struct iwn_softc *);</a>
<a name="ln176">static uint32_t	iwn_eeprom_channel_flags(struct iwn_eeprom_chan *);</a>
<a name="ln177">static void	iwn_read_eeprom_band(struct iwn_softc *, int, int, int *,</a>
<a name="ln178">		    struct ieee80211_channel[]);</a>
<a name="ln179">static void	iwn_read_eeprom_ht40(struct iwn_softc *, int, int, int *,</a>
<a name="ln180">		    struct ieee80211_channel[]);</a>
<a name="ln181">static void	iwn_read_eeprom_channels(struct iwn_softc *, int, uint32_t);</a>
<a name="ln182">static struct iwn_eeprom_chan *iwn_find_eeprom_channel(struct iwn_softc *,</a>
<a name="ln183">		    struct ieee80211_channel *);</a>
<a name="ln184">static void	iwn_getradiocaps(struct ieee80211com *, int, int *,</a>
<a name="ln185">		    struct ieee80211_channel[]);</a>
<a name="ln186">static int	iwn_setregdomain(struct ieee80211com *,</a>
<a name="ln187">		    struct ieee80211_regdomain *, int,</a>
<a name="ln188">		    struct ieee80211_channel[]);</a>
<a name="ln189">static void	iwn_read_eeprom_enhinfo(struct iwn_softc *);</a>
<a name="ln190">static struct ieee80211_node *iwn_node_alloc(struct ieee80211vap *,</a>
<a name="ln191">		    const uint8_t mac[IEEE80211_ADDR_LEN]);</a>
<a name="ln192">static void	iwn_newassoc(struct ieee80211_node *, int);</a>
<a name="ln193">static int	iwn_media_change(struct ifnet *);</a>
<a name="ln194">static int	iwn_newstate(struct ieee80211vap *, enum ieee80211_state, int);</a>
<a name="ln195">static void	iwn_calib_timeout(void *);</a>
<a name="ln196">static void	iwn_rx_phy(struct iwn_softc *, struct iwn_rx_desc *);</a>
<a name="ln197">static void	iwn_rx_done(struct iwn_softc *, struct iwn_rx_desc *,</a>
<a name="ln198">		    struct iwn_rx_data *);</a>
<a name="ln199">static void	iwn_rx_compressed_ba(struct iwn_softc *, struct iwn_rx_desc *);</a>
<a name="ln200">static void	iwn5000_rx_calib_results(struct iwn_softc *,</a>
<a name="ln201">		    struct iwn_rx_desc *);</a>
<a name="ln202">static void	iwn_rx_statistics(struct iwn_softc *, struct iwn_rx_desc *);</a>
<a name="ln203">static void	iwn4965_tx_done(struct iwn_softc *, struct iwn_rx_desc *,</a>
<a name="ln204">		    struct iwn_rx_data *);</a>
<a name="ln205">static void	iwn5000_tx_done(struct iwn_softc *, struct iwn_rx_desc *,</a>
<a name="ln206">		    struct iwn_rx_data *);</a>
<a name="ln207">static void	iwn_tx_done(struct iwn_softc *, struct iwn_rx_desc *, int, int,</a>
<a name="ln208">		    uint8_t);</a>
<a name="ln209">static void	iwn_ampdu_tx_done(struct iwn_softc *, int, int, int, int, int,</a>
<a name="ln210">		    void *);</a>
<a name="ln211">static void	iwn_cmd_done(struct iwn_softc *, struct iwn_rx_desc *);</a>
<a name="ln212">static void	iwn_notif_intr(struct iwn_softc *);</a>
<a name="ln213">static void	iwn_wakeup_intr(struct iwn_softc *);</a>
<a name="ln214">static void	iwn_rftoggle_task(void *, int);</a>
<a name="ln215">static void	iwn_fatal_intr(struct iwn_softc *);</a>
<a name="ln216">static void	iwn_intr(void *);</a>
<a name="ln217">static void	iwn4965_update_sched(struct iwn_softc *, int, int, uint8_t,</a>
<a name="ln218">		    uint16_t);</a>
<a name="ln219">static void	iwn5000_update_sched(struct iwn_softc *, int, int, uint8_t,</a>
<a name="ln220">		    uint16_t);</a>
<a name="ln221">#ifdef notyet</a>
<a name="ln222">static void	iwn5000_reset_sched(struct iwn_softc *, int, int);</a>
<a name="ln223">#endif</a>
<a name="ln224">static int	iwn_tx_data(struct iwn_softc *, struct mbuf *,</a>
<a name="ln225">		    struct ieee80211_node *);</a>
<a name="ln226">static int	iwn_tx_data_raw(struct iwn_softc *, struct mbuf *,</a>
<a name="ln227">		    struct ieee80211_node *,</a>
<a name="ln228">		    const struct ieee80211_bpf_params *params);</a>
<a name="ln229">static int	iwn_tx_cmd(struct iwn_softc *, struct mbuf *,</a>
<a name="ln230">		    struct ieee80211_node *, struct iwn_tx_ring *);</a>
<a name="ln231">static void	iwn_xmit_task(void *arg0, int pending);</a>
<a name="ln232">static int	iwn_raw_xmit(struct ieee80211_node *, struct mbuf *,</a>
<a name="ln233">		    const struct ieee80211_bpf_params *);</a>
<a name="ln234">static int	iwn_transmit(struct ieee80211com *, struct mbuf *);</a>
<a name="ln235">static void	iwn_scan_timeout(void *);</a>
<a name="ln236">static void	iwn_watchdog(void *);</a>
<a name="ln237">static int	iwn_ioctl(struct ieee80211com *, u_long , void *);</a>
<a name="ln238">static void	iwn_parent(struct ieee80211com *);</a>
<a name="ln239">static int	iwn_cmd(struct iwn_softc *, int, const void *, int, int);</a>
<a name="ln240">static int	iwn4965_add_node(struct iwn_softc *, struct iwn_node_info *,</a>
<a name="ln241">		    int);</a>
<a name="ln242">static int	iwn5000_add_node(struct iwn_softc *, struct iwn_node_info *,</a>
<a name="ln243">		    int);</a>
<a name="ln244">static int	iwn_set_link_quality(struct iwn_softc *,</a>
<a name="ln245">		    struct ieee80211_node *);</a>
<a name="ln246">static int	iwn_add_broadcast_node(struct iwn_softc *, int);</a>
<a name="ln247">static int	iwn_updateedca(struct ieee80211com *);</a>
<a name="ln248">static void	iwn_set_promisc(struct iwn_softc *);</a>
<a name="ln249">static void	iwn_update_promisc(struct ieee80211com *);</a>
<a name="ln250">static void	iwn_update_mcast(struct ieee80211com *);</a>
<a name="ln251">static void	iwn_set_led(struct iwn_softc *, uint8_t, uint8_t, uint8_t);</a>
<a name="ln252">static int	iwn_set_critical_temp(struct iwn_softc *);</a>
<a name="ln253">static int	iwn_set_timing(struct iwn_softc *, struct ieee80211_node *);</a>
<a name="ln254">static void	iwn4965_power_calibration(struct iwn_softc *, int);</a>
<a name="ln255">static int	iwn4965_set_txpower(struct iwn_softc *, int);</a>
<a name="ln256">static int	iwn5000_set_txpower(struct iwn_softc *, int);</a>
<a name="ln257">static int	iwn4965_get_rssi(struct iwn_softc *, struct iwn_rx_stat *);</a>
<a name="ln258">static int	iwn5000_get_rssi(struct iwn_softc *, struct iwn_rx_stat *);</a>
<a name="ln259">static int	iwn_get_noise(const struct iwn_rx_general_stats *);</a>
<a name="ln260">static int	iwn4965_get_temperature(struct iwn_softc *);</a>
<a name="ln261">static int	iwn5000_get_temperature(struct iwn_softc *);</a>
<a name="ln262">static int	iwn_init_sensitivity(struct iwn_softc *);</a>
<a name="ln263">static void	iwn_collect_noise(struct iwn_softc *,</a>
<a name="ln264">		    const struct iwn_rx_general_stats *);</a>
<a name="ln265">static int	iwn4965_init_gains(struct iwn_softc *);</a>
<a name="ln266">static int	iwn5000_init_gains(struct iwn_softc *);</a>
<a name="ln267">static int	iwn4965_set_gains(struct iwn_softc *);</a>
<a name="ln268">static int	iwn5000_set_gains(struct iwn_softc *);</a>
<a name="ln269">static void	iwn_tune_sensitivity(struct iwn_softc *,</a>
<a name="ln270">		    const struct iwn_rx_stats *);</a>
<a name="ln271">static void	iwn_save_stats_counters(struct iwn_softc *,</a>
<a name="ln272">		    const struct iwn_stats *);</a>
<a name="ln273">static int	iwn_send_sensitivity(struct iwn_softc *);</a>
<a name="ln274">static void	iwn_check_rx_recovery(struct iwn_softc *, struct iwn_stats *);</a>
<a name="ln275">static int	iwn_set_pslevel(struct iwn_softc *, int, int, int);</a>
<a name="ln276">static int	iwn_send_btcoex(struct iwn_softc *);</a>
<a name="ln277">static int	iwn_send_advanced_btcoex(struct iwn_softc *);</a>
<a name="ln278">static int	iwn5000_runtime_calib(struct iwn_softc *);</a>
<a name="ln279">static int	iwn_check_bss_filter(struct iwn_softc *);</a>
<a name="ln280">static int	iwn4965_rxon_assoc(struct iwn_softc *, int);</a>
<a name="ln281">static int	iwn5000_rxon_assoc(struct iwn_softc *, int);</a>
<a name="ln282">static int	iwn_send_rxon(struct iwn_softc *, int, int);</a>
<a name="ln283">static int	iwn_config(struct iwn_softc *);</a>
<a name="ln284">static int	iwn_scan(struct iwn_softc *, struct ieee80211vap *,</a>
<a name="ln285">		    struct ieee80211_scan_state *, struct ieee80211_channel *);</a>
<a name="ln286">static int	iwn_auth(struct iwn_softc *, struct ieee80211vap *vap);</a>
<a name="ln287">static int	iwn_run(struct iwn_softc *, struct ieee80211vap *vap);</a>
<a name="ln288">static int	iwn_ampdu_rx_start(struct ieee80211_node *,</a>
<a name="ln289">		    struct ieee80211_rx_ampdu *, int, int, int);</a>
<a name="ln290">static void	iwn_ampdu_rx_stop(struct ieee80211_node *,</a>
<a name="ln291">		    struct ieee80211_rx_ampdu *);</a>
<a name="ln292">static int	iwn_addba_request(struct ieee80211_node *,</a>
<a name="ln293">		    struct ieee80211_tx_ampdu *, int, int, int);</a>
<a name="ln294">static int	iwn_addba_response(struct ieee80211_node *,</a>
<a name="ln295">		    struct ieee80211_tx_ampdu *, int, int, int);</a>
<a name="ln296">static int	iwn_ampdu_tx_start(struct ieee80211com *,</a>
<a name="ln297">		    struct ieee80211_node *, uint8_t);</a>
<a name="ln298">static void	iwn_ampdu_tx_stop(struct ieee80211_node *,</a>
<a name="ln299">		    struct ieee80211_tx_ampdu *);</a>
<a name="ln300">static void	iwn4965_ampdu_tx_start(struct iwn_softc *,</a>
<a name="ln301">		    struct ieee80211_node *, int, uint8_t, uint16_t);</a>
<a name="ln302">static void	iwn4965_ampdu_tx_stop(struct iwn_softc *, int,</a>
<a name="ln303">		    uint8_t, uint16_t);</a>
<a name="ln304">static void	iwn5000_ampdu_tx_start(struct iwn_softc *,</a>
<a name="ln305">		    struct ieee80211_node *, int, uint8_t, uint16_t);</a>
<a name="ln306">static void	iwn5000_ampdu_tx_stop(struct iwn_softc *, int,</a>
<a name="ln307">		    uint8_t, uint16_t);</a>
<a name="ln308">static int	iwn5000_query_calibration(struct iwn_softc *);</a>
<a name="ln309">static int	iwn5000_send_calibration(struct iwn_softc *);</a>
<a name="ln310">static int	iwn5000_send_wimax_coex(struct iwn_softc *);</a>
<a name="ln311">static int	iwn5000_crystal_calib(struct iwn_softc *);</a>
<a name="ln312">static int	iwn5000_temp_offset_calib(struct iwn_softc *);</a>
<a name="ln313">static int	iwn5000_temp_offset_calibv2(struct iwn_softc *);</a>
<a name="ln314">static int	iwn4965_post_alive(struct iwn_softc *);</a>
<a name="ln315">static int	iwn5000_post_alive(struct iwn_softc *);</a>
<a name="ln316">static int	iwn4965_load_bootcode(struct iwn_softc *, const uint8_t *,</a>
<a name="ln317">		    int);</a>
<a name="ln318">static int	iwn4965_load_firmware(struct iwn_softc *);</a>
<a name="ln319">static int	iwn5000_load_firmware_section(struct iwn_softc *, uint32_t,</a>
<a name="ln320">		    const uint8_t *, int);</a>
<a name="ln321">static int	iwn5000_load_firmware(struct iwn_softc *);</a>
<a name="ln322">static int	iwn_read_firmware_leg(struct iwn_softc *,</a>
<a name="ln323">		    struct iwn_fw_info *);</a>
<a name="ln324">static int	iwn_read_firmware_tlv(struct iwn_softc *,</a>
<a name="ln325">		    struct iwn_fw_info *, uint16_t);</a>
<a name="ln326">static int	iwn_read_firmware(struct iwn_softc *);</a>
<a name="ln327">static void	iwn_unload_firmware(struct iwn_softc *);</a>
<a name="ln328">static int	iwn_clock_wait(struct iwn_softc *);</a>
<a name="ln329">static int	iwn_apm_init(struct iwn_softc *);</a>
<a name="ln330">static void	iwn_apm_stop_master(struct iwn_softc *);</a>
<a name="ln331">static void	iwn_apm_stop(struct iwn_softc *);</a>
<a name="ln332">static int	iwn4965_nic_config(struct iwn_softc *);</a>
<a name="ln333">static int	iwn5000_nic_config(struct iwn_softc *);</a>
<a name="ln334">static int	iwn_hw_prepare(struct iwn_softc *);</a>
<a name="ln335">static int	iwn_hw_init(struct iwn_softc *);</a>
<a name="ln336">static void	iwn_hw_stop(struct iwn_softc *);</a>
<a name="ln337">static void	iwn_panicked(void *, int);</a>
<a name="ln338">static int	iwn_init_locked(struct iwn_softc *);</a>
<a name="ln339">static int	iwn_init(struct iwn_softc *);</a>
<a name="ln340">static void	iwn_stop_locked(struct iwn_softc *);</a>
<a name="ln341">static void	iwn_stop(struct iwn_softc *);</a>
<a name="ln342">static void	iwn_scan_start(struct ieee80211com *);</a>
<a name="ln343">static void	iwn_scan_end(struct ieee80211com *);</a>
<a name="ln344">static void	iwn_set_channel(struct ieee80211com *);</a>
<a name="ln345">static void	iwn_scan_curchan(struct ieee80211_scan_state *, unsigned long);</a>
<a name="ln346">static void	iwn_scan_mindwell(struct ieee80211_scan_state *);</a>
<a name="ln347">#ifdef	IWN_DEBUG</a>
<a name="ln348">static char	*iwn_get_csr_string(int);</a>
<a name="ln349">static void	iwn_debug_register(struct iwn_softc *);</a>
<a name="ln350">#endif</a>
<a name="ln351"> </a>
<a name="ln352">static device_method_t iwn_methods[] = {</a>
<a name="ln353">	/* Device interface */</a>
<a name="ln354">	DEVMETHOD(device_probe,		iwn_probe),</a>
<a name="ln355">	DEVMETHOD(device_attach,	iwn_attach),</a>
<a name="ln356">	DEVMETHOD(device_detach,	iwn_detach),</a>
<a name="ln357">	DEVMETHOD(device_shutdown,	iwn_shutdown),</a>
<a name="ln358">	DEVMETHOD(device_suspend,	iwn_suspend),</a>
<a name="ln359">	DEVMETHOD(device_resume,	iwn_resume),</a>
<a name="ln360"> </a>
<a name="ln361">	DEVMETHOD_END</a>
<a name="ln362">};</a>
<a name="ln363"> </a>
<a name="ln364">static driver_t iwn_driver = {</a>
<a name="ln365">	&quot;iwn&quot;,</a>
<a name="ln366">	iwn_methods,</a>
<a name="ln367">	sizeof(struct iwn_softc)</a>
<a name="ln368">};</a>
<a name="ln369">static devclass_t iwn_devclass;</a>
<a name="ln370"> </a>
<a name="ln371">DRIVER_MODULE(iwn, pci, iwn_driver, iwn_devclass, NULL, NULL);</a>
<a name="ln372">MODULE_PNP_INFO(&quot;U16:vendor;U16:device;D:#&quot;, pci, iwn, iwn_ident_table,</a>
<a name="ln373">    nitems(iwn_ident_table) - 1);</a>
<a name="ln374">MODULE_VERSION(iwn, 1);</a>
<a name="ln375"> </a>
<a name="ln376">MODULE_DEPEND(iwn, firmware, 1, 1, 1);</a>
<a name="ln377">MODULE_DEPEND(iwn, pci, 1, 1, 1);</a>
<a name="ln378">MODULE_DEPEND(iwn, wlan, 1, 1, 1);</a>
<a name="ln379"> </a>
<a name="ln380">#ifndef __HAIKU__</a>
<a name="ln381">static d_ioctl_t iwn_cdev_ioctl;</a>
<a name="ln382">static d_open_t iwn_cdev_open;</a>
<a name="ln383">static d_close_t iwn_cdev_close;</a>
<a name="ln384"> </a>
<a name="ln385">static struct cdevsw iwn_cdevsw = {</a>
<a name="ln386">	.d_version = D_VERSION,</a>
<a name="ln387">	.d_flags = 0,</a>
<a name="ln388">	.d_open = iwn_cdev_open,</a>
<a name="ln389">	.d_close = iwn_cdev_close,</a>
<a name="ln390">	.d_ioctl = iwn_cdev_ioctl,</a>
<a name="ln391">	.d_name = &quot;iwn&quot;,</a>
<a name="ln392">};</a>
<a name="ln393">#endif</a>
<a name="ln394"> </a>
<a name="ln395">static int</a>
<a name="ln396">iwn_probe(device_t dev)</a>
<a name="ln397">{</a>
<a name="ln398">	const struct iwn_ident *ident;</a>
<a name="ln399"> </a>
<a name="ln400">	for (ident = iwn_ident_table; ident-&gt;name != NULL; ident++) {</a>
<a name="ln401">		if (pci_get_vendor(dev) == ident-&gt;vendor &amp;&amp;</a>
<a name="ln402">		    pci_get_device(dev) == ident-&gt;device) {</a>
<a name="ln403">			device_set_desc(dev, ident-&gt;name);</a>
<a name="ln404">			return (BUS_PROBE_DEFAULT);</a>
<a name="ln405">		}</a>
<a name="ln406">	}</a>
<a name="ln407">	return ENXIO;</a>
<a name="ln408">}</a>
<a name="ln409"> </a>
<a name="ln410">static int</a>
<a name="ln411">iwn_is_3stream_device(struct iwn_softc *sc)</a>
<a name="ln412">{</a>
<a name="ln413">	/* XXX for now only 5300, until the 5350 can be tested */</a>
<a name="ln414">	if (sc-&gt;hw_type == IWN_HW_REV_TYPE_5300)</a>
<a name="ln415">		return (1);</a>
<a name="ln416">	return (0);</a>
<a name="ln417">}</a>
<a name="ln418"> </a>
<a name="ln419">static int</a>
<a name="ln420">iwn_attach(device_t dev)</a>
<a name="ln421">{</a>
<a name="ln422">	struct iwn_softc *sc = device_get_softc(dev);</a>
<a name="ln423">	struct ieee80211com *ic;</a>
<a name="ln424">	int i, error, rid;</a>
<a name="ln425"> </a>
<a name="ln426">	sc-&gt;sc_dev = dev;</a>
<a name="ln427"> </a>
<a name="ln428">#ifdef	IWN_DEBUG</a>
<a name="ln429">	error = resource_int_value(device_get_name(sc-&gt;sc_dev),</a>
<a name="ln430">	    device_get_unit(sc-&gt;sc_dev), &quot;debug&quot;, &amp;(sc-&gt;sc_debug));</a>
<a name="ln431">	if (error != 0)</a>
<a name="ln432">		sc-&gt;sc_debug = 0;</a>
<a name="ln433">#else</a>
<a name="ln434">	sc-&gt;sc_debug = 0;</a>
<a name="ln435">#endif</a>
<a name="ln436"> </a>
<a name="ln437">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: begin\n&quot;,__func__);</a>
<a name="ln438"> </a>
<a name="ln439">	/*</a>
<a name="ln440">	 * Get the offset of the PCI Express Capability Structure in PCI</a>
<a name="ln441">	 * Configuration Space.</a>
<a name="ln442">	 */</a>
<a name="ln443">	error = pci_find_cap(dev, PCIY_EXPRESS, &amp;sc-&gt;sc_cap_off);</a>
<a name="ln444">	if (error != 0) {</a>
<a name="ln445">		device_printf(dev, &quot;PCIe capability structure not found!\n&quot;);</a>
<a name="ln446">		return error;</a>
<a name="ln447">	}</a>
<a name="ln448"> </a>
<a name="ln449">	/* Clear device-specific &quot;PCI retry timeout&quot; register (41h). */</a>
<a name="ln450">	pci_write_config(dev, 0x41, 0, 1);</a>
<a name="ln451"> </a>
<a name="ln452">	/* Enable bus-mastering. */</a>
<a name="ln453">	pci_enable_busmaster(dev);</a>
<a name="ln454"> </a>
<a name="ln455">	rid = PCIR_BAR(0);</a>
<a name="ln456">	sc-&gt;mem = bus_alloc_resource_any(dev, SYS_RES_MEMORY, &amp;rid,</a>
<a name="ln457">	    RF_ACTIVE);</a>
<a name="ln458">	if (sc-&gt;mem == NULL) {</a>
<a name="ln459">		device_printf(dev, &quot;can't map mem space\n&quot;);</a>
<a name="ln460">		error = ENOMEM;</a>
<a name="ln461">		return error;</a>
<a name="ln462">	}</a>
<a name="ln463">	sc-&gt;sc_st = rman_get_bustag(sc-&gt;mem);</a>
<a name="ln464">	sc-&gt;sc_sh = rman_get_bushandle(sc-&gt;mem);</a>
<a name="ln465"> </a>
<a name="ln466">	i = 1;</a>
<a name="ln467">	rid = 0;</a>
<a name="ln468">	if (pci_alloc_msi(dev, &amp;i) == 0)</a>
<a name="ln469">		rid = 1;</a>
<a name="ln470">	/* Install interrupt handler. */</a>
<a name="ln471">	sc-&gt;irq = bus_alloc_resource_any(dev, SYS_RES_IRQ, &amp;rid, RF_ACTIVE |</a>
<a name="ln472">	    (rid != 0 ? 0 : RF_SHAREABLE));</a>
<a name="ln473">	if (sc-&gt;irq == NULL) {</a>
<a name="ln474">		device_printf(dev, &quot;can't map interrupt\n&quot;);</a>
<a name="ln475">		error = ENOMEM;</a>
<a name="ln476">		goto fail;</a>
<a name="ln477">	}</a>
<a name="ln478"> </a>
<a name="ln479">	IWN_LOCK_INIT(sc);</a>
<a name="ln480"> </a>
<a name="ln481">	/* Read hardware revision and attach. */</a>
<a name="ln482">	sc-&gt;hw_type = (IWN_READ(sc, IWN_HW_REV) &gt;&gt; IWN_HW_REV_TYPE_SHIFT)</a>
<a name="ln483">	    &amp; IWN_HW_REV_TYPE_MASK;</a>
<a name="ln484">	sc-&gt;subdevice_id = pci_get_subdevice(dev);</a>
<a name="ln485"> </a>
<a name="ln486">	/*</a>
<a name="ln487">	 * 4965 versus 5000 and later have different methods.</a>
<a name="ln488">	 * Let's set those up first.</a>
<a name="ln489">	 */</a>
<a name="ln490">	if (sc-&gt;hw_type == IWN_HW_REV_TYPE_4965)</a>
<a name="ln491">		error = iwn4965_attach(sc, pci_get_device(dev));</a>
<a name="ln492">	else</a>
<a name="ln493">		error = iwn5000_attach(sc, pci_get_device(dev));</a>
<a name="ln494">	if (error != 0) {</a>
<a name="ln495">		device_printf(dev, &quot;could not attach device, error %d\n&quot;,</a>
<a name="ln496">		    error);</a>
<a name="ln497">		goto fail;</a>
<a name="ln498">	}</a>
<a name="ln499"> </a>
<a name="ln500">	/*</a>
<a name="ln501">	 * Next, let's setup the various parameters of each NIC.</a>
<a name="ln502">	 */</a>
<a name="ln503">	error = iwn_config_specific(sc, pci_get_device(dev));</a>
<a name="ln504">	if (error != 0) {</a>
<a name="ln505">		device_printf(dev, &quot;could not attach device, error %d\n&quot;,</a>
<a name="ln506">		    error);</a>
<a name="ln507">		goto fail;</a>
<a name="ln508">	}</a>
<a name="ln509"> </a>
<a name="ln510">	if ((error = iwn_hw_prepare(sc)) != 0) {</a>
<a name="ln511">		device_printf(dev, &quot;hardware not ready, error %d\n&quot;, error);</a>
<a name="ln512">		goto fail;</a>
<a name="ln513">	}</a>
<a name="ln514"> </a>
<a name="ln515">	/* Allocate DMA memory for firmware transfers. */</a>
<a name="ln516">	if ((error = iwn_alloc_fwmem(sc)) != 0) {</a>
<a name="ln517">		device_printf(dev,</a>
<a name="ln518">		    &quot;could not allocate memory for firmware, error %d\n&quot;,</a>
<a name="ln519">		    error);</a>
<a name="ln520">		goto fail;</a>
<a name="ln521">	}</a>
<a name="ln522"> </a>
<a name="ln523">	/* Allocate &quot;Keep Warm&quot; page. */</a>
<a name="ln524">	if ((error = iwn_alloc_kw(sc)) != 0) {</a>
<a name="ln525">		device_printf(dev,</a>
<a name="ln526">		    &quot;could not allocate keep warm page, error %d\n&quot;, error);</a>
<a name="ln527">		goto fail;</a>
<a name="ln528">	}</a>
<a name="ln529"> </a>
<a name="ln530">	/* Allocate ICT table for 5000 Series. */</a>
<a name="ln531">	if (sc-&gt;hw_type != IWN_HW_REV_TYPE_4965 &amp;&amp;</a>
<a name="ln532">	    (error = iwn_alloc_ict(sc)) != 0) {</a>
<a name="ln533">		device_printf(dev, &quot;could not allocate ICT table, error %d\n&quot;,</a>
<a name="ln534">		    error);</a>
<a name="ln535">		goto fail;</a>
<a name="ln536">	}</a>
<a name="ln537"> </a>
<a name="ln538">	/* Allocate TX scheduler &quot;rings&quot;. */</a>
<a name="ln539">	if ((error = iwn_alloc_sched(sc)) != 0) {</a>
<a name="ln540">		device_printf(dev,</a>
<a name="ln541">		    &quot;could not allocate TX scheduler rings, error %d\n&quot;, error);</a>
<a name="ln542">		goto fail;</a>
<a name="ln543">	}</a>
<a name="ln544"> </a>
<a name="ln545">	/* Allocate TX rings (16 on 4965AGN, 20 on &gt;=5000). */</a>
<a name="ln546">	for (i = 0; i &lt; sc-&gt;ntxqs; i++) {</a>
<a name="ln547">		if ((error = iwn_alloc_tx_ring(sc, &amp;sc-&gt;txq[i], i)) != 0) {</a>
<a name="ln548">			device_printf(dev,</a>
<a name="ln549">			    &quot;could not allocate TX ring %d, error %d\n&quot;, i,</a>
<a name="ln550">			    error);</a>
<a name="ln551">			goto fail;</a>
<a name="ln552">		}</a>
<a name="ln553">	}</a>
<a name="ln554"> </a>
<a name="ln555">	/* Allocate RX ring. */</a>
<a name="ln556">	if ((error = iwn_alloc_rx_ring(sc, &amp;sc-&gt;rxq)) != 0) {</a>
<a name="ln557">		device_printf(dev, &quot;could not allocate RX ring, error %d\n&quot;,</a>
<a name="ln558">		    error);</a>
<a name="ln559">		goto fail;</a>
<a name="ln560">	}</a>
<a name="ln561"> </a>
<a name="ln562">	/* Clear pending interrupts. */</a>
<a name="ln563">	IWN_WRITE(sc, IWN_INT, 0xffffffff);</a>
<a name="ln564"> </a>
<a name="ln565">	ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln566">	ic-&gt;ic_softc = sc;</a>
<a name="ln567">	ic-&gt;ic_name = device_get_nameunit(dev);</a>
<a name="ln568">	ic-&gt;ic_phytype = IEEE80211_T_OFDM;	/* not only, but not used */</a>
<a name="ln569">	ic-&gt;ic_opmode = IEEE80211_M_STA;	/* default to BSS mode */</a>
<a name="ln570"> </a>
<a name="ln571">	/* Set device capabilities. */</a>
<a name="ln572">	ic-&gt;ic_caps =</a>
<a name="ln573">		  IEEE80211_C_STA		/* station mode supported */</a>
<a name="ln574">		| IEEE80211_C_MONITOR		/* monitor mode supported */</a>
<a name="ln575">#if 0</a>
<a name="ln576">		| IEEE80211_C_BGSCAN		/* background scanning */</a>
<a name="ln577">#endif</a>
<a name="ln578">		| IEEE80211_C_TXPMGT		/* tx power management */</a>
<a name="ln579">		| IEEE80211_C_SHSLOT		/* short slot time supported */</a>
<a name="ln580">		| IEEE80211_C_WPA</a>
<a name="ln581">		| IEEE80211_C_SHPREAMBLE	/* short preamble supported */</a>
<a name="ln582">#if 0</a>
<a name="ln583">		| IEEE80211_C_IBSS		/* ibss/adhoc mode */</a>
<a name="ln584">#endif</a>
<a name="ln585">		| IEEE80211_C_WME		/* WME */</a>
<a name="ln586">		| IEEE80211_C_PMGT		/* Station-side power mgmt */</a>
<a name="ln587">		;</a>
<a name="ln588"> </a>
<a name="ln589">	/* Read MAC address, channels, etc from EEPROM. */</a>
<a name="ln590">	if ((error = iwn_read_eeprom(sc, ic-&gt;ic_macaddr)) != 0) {</a>
<a name="ln591">		device_printf(dev, &quot;could not read EEPROM, error %d\n&quot;,</a>
<a name="ln592">		    error);</a>
<a name="ln593">		goto fail;</a>
<a name="ln594">	}</a>
<a name="ln595"> </a>
<a name="ln596">	/* Count the number of available chains. */</a>
<a name="ln597">	sc-&gt;ntxchains =</a>
<a name="ln598">	    ((sc-&gt;txchainmask &gt;&gt; 2) &amp; 1) +</a>
<a name="ln599">	    ((sc-&gt;txchainmask &gt;&gt; 1) &amp; 1) +</a>
<a name="ln600">	    ((sc-&gt;txchainmask &gt;&gt; 0) &amp; 1);</a>
<a name="ln601">	sc-&gt;nrxchains =</a>
<a name="ln602">	    ((sc-&gt;rxchainmask &gt;&gt; 2) &amp; 1) +</a>
<a name="ln603">	    ((sc-&gt;rxchainmask &gt;&gt; 1) &amp; 1) +</a>
<a name="ln604">	    ((sc-&gt;rxchainmask &gt;&gt; 0) &amp; 1);</a>
<a name="ln605">	if (bootverbose) {</a>
<a name="ln606">		device_printf(dev, &quot;MIMO %dT%dR, %.4s, address %6D\n&quot;,</a>
<a name="ln607">		    sc-&gt;ntxchains, sc-&gt;nrxchains, sc-&gt;eeprom_domain,</a>
<a name="ln608">		    ic-&gt;ic_macaddr, &quot;:&quot;);</a>
<a name="ln609">	}</a>
<a name="ln610"> </a>
<a name="ln611">	if (sc-&gt;sc_flags &amp; IWN_FLAG_HAS_11N) {</a>
<a name="ln612">		ic-&gt;ic_rxstream = sc-&gt;nrxchains;</a>
<a name="ln613">		ic-&gt;ic_txstream = sc-&gt;ntxchains;</a>
<a name="ln614"> </a>
<a name="ln615">		/*</a>
<a name="ln616">		 * Some of the 3 antenna devices (ie, the 4965) only supports</a>
<a name="ln617">		 * 2x2 operation.  So correct the number of streams if</a>
<a name="ln618">		 * it's not a 3-stream device.</a>
<a name="ln619">		 */</a>
<a name="ln620">		if (! iwn_is_3stream_device(sc)) {</a>
<a name="ln621">			if (ic-&gt;ic_rxstream &gt; 2)</a>
<a name="ln622">				ic-&gt;ic_rxstream = 2;</a>
<a name="ln623">			if (ic-&gt;ic_txstream &gt; 2)</a>
<a name="ln624">				ic-&gt;ic_txstream = 2;</a>
<a name="ln625">		}</a>
<a name="ln626"> </a>
<a name="ln627">		ic-&gt;ic_htcaps =</a>
<a name="ln628">			  IEEE80211_HTCAP_SMPS_OFF	/* SMPS mode disabled */</a>
<a name="ln629">			| IEEE80211_HTCAP_SHORTGI20	/* short GI in 20MHz */</a>
<a name="ln630">			| IEEE80211_HTCAP_CHWIDTH40	/* 40MHz channel width*/</a>
<a name="ln631">			| IEEE80211_HTCAP_SHORTGI40	/* short GI in 40MHz */</a>
<a name="ln632">#ifdef notyet</a>
<a name="ln633">			| IEEE80211_HTCAP_GREENFIELD</a>
<a name="ln634">#if IWN_RBUF_SIZE == 8192</a>
<a name="ln635">			| IEEE80211_HTCAP_MAXAMSDU_7935	/* max A-MSDU length */</a>
<a name="ln636">#else</a>
<a name="ln637">			| IEEE80211_HTCAP_MAXAMSDU_3839	/* max A-MSDU length */</a>
<a name="ln638">#endif</a>
<a name="ln639">#endif</a>
<a name="ln640">			/* s/w capabilities */</a>
<a name="ln641">			| IEEE80211_HTC_HT		/* HT operation */</a>
<a name="ln642">			| IEEE80211_HTC_AMPDU		/* tx A-MPDU */</a>
<a name="ln643">#ifdef notyet</a>
<a name="ln644">			| IEEE80211_HTC_AMSDU		/* tx A-MSDU */</a>
<a name="ln645">#endif</a>
<a name="ln646">			;</a>
<a name="ln647">	}</a>
<a name="ln648"> </a>
<a name="ln649">	ieee80211_ifattach(ic);</a>
<a name="ln650">	ic-&gt;ic_vap_create = iwn_vap_create;</a>
<a name="ln651">	ic-&gt;ic_ioctl = iwn_ioctl;</a>
<a name="ln652">	ic-&gt;ic_parent = iwn_parent;</a>
<a name="ln653">	ic-&gt;ic_vap_delete = iwn_vap_delete;</a>
<a name="ln654">	ic-&gt;ic_transmit = iwn_transmit;</a>
<a name="ln655">	ic-&gt;ic_raw_xmit = iwn_raw_xmit;</a>
<a name="ln656">	ic-&gt;ic_node_alloc = iwn_node_alloc;</a>
<a name="ln657">	sc-&gt;sc_ampdu_rx_start = ic-&gt;ic_ampdu_rx_start;</a>
<a name="ln658">	ic-&gt;ic_ampdu_rx_start = iwn_ampdu_rx_start;</a>
<a name="ln659">	sc-&gt;sc_ampdu_rx_stop = ic-&gt;ic_ampdu_rx_stop;</a>
<a name="ln660">	ic-&gt;ic_ampdu_rx_stop = iwn_ampdu_rx_stop;</a>
<a name="ln661">	sc-&gt;sc_addba_request = ic-&gt;ic_addba_request;</a>
<a name="ln662">	ic-&gt;ic_addba_request = iwn_addba_request;</a>
<a name="ln663">	sc-&gt;sc_addba_response = ic-&gt;ic_addba_response;</a>
<a name="ln664">	ic-&gt;ic_addba_response = iwn_addba_response;</a>
<a name="ln665">	sc-&gt;sc_addba_stop = ic-&gt;ic_addba_stop;</a>
<a name="ln666">	ic-&gt;ic_addba_stop = iwn_ampdu_tx_stop;</a>
<a name="ln667">	ic-&gt;ic_newassoc = iwn_newassoc;</a>
<a name="ln668">	ic-&gt;ic_wme.wme_update = iwn_updateedca;</a>
<a name="ln669">	ic-&gt;ic_update_promisc = iwn_update_promisc;</a>
<a name="ln670">	ic-&gt;ic_update_mcast = iwn_update_mcast;</a>
<a name="ln671">	ic-&gt;ic_scan_start = iwn_scan_start;</a>
<a name="ln672">	ic-&gt;ic_scan_end = iwn_scan_end;</a>
<a name="ln673">	ic-&gt;ic_set_channel = iwn_set_channel;</a>
<a name="ln674">	ic-&gt;ic_scan_curchan = iwn_scan_curchan;</a>
<a name="ln675">	ic-&gt;ic_scan_mindwell = iwn_scan_mindwell;</a>
<a name="ln676">	ic-&gt;ic_getradiocaps = iwn_getradiocaps;</a>
<a name="ln677">	ic-&gt;ic_setregdomain = iwn_setregdomain;</a>
<a name="ln678"> </a>
<a name="ln679">	iwn_radiotap_attach(sc);</a>
<a name="ln680"> </a>
<a name="ln681">	callout_init_mtx(&amp;sc-&gt;calib_to, &amp;sc-&gt;sc_mtx, 0);</a>
<a name="ln682">	callout_init_mtx(&amp;sc-&gt;scan_timeout, &amp;sc-&gt;sc_mtx, 0);</a>
<a name="ln683">	callout_init_mtx(&amp;sc-&gt;watchdog_to, &amp;sc-&gt;sc_mtx, 0);</a>
<a name="ln684">	TASK_INIT(&amp;sc-&gt;sc_rftoggle_task, 0, iwn_rftoggle_task, sc);</a>
<a name="ln685">	TASK_INIT(&amp;sc-&gt;sc_panic_task, 0, iwn_panicked, sc);</a>
<a name="ln686">	TASK_INIT(&amp;sc-&gt;sc_xmit_task, 0, iwn_xmit_task, sc);</a>
<a name="ln687"> </a>
<a name="ln688">	mbufq_init(&amp;sc-&gt;sc_xmit_queue, 1024);</a>
<a name="ln689"> </a>
<a name="ln690">	sc-&gt;sc_tq = taskqueue_create(&quot;iwn_taskq&quot;, M_WAITOK,</a>
<a name="ln691">	    taskqueue_thread_enqueue, &amp;sc-&gt;sc_tq);</a>
<a name="ln692">	error = taskqueue_start_threads(&amp;sc-&gt;sc_tq, 1, 0, &quot;iwn_taskq&quot;);</a>
<a name="ln693">	if (error != 0) {</a>
<a name="ln694">		device_printf(dev, &quot;can't start threads, error %d\n&quot;, error);</a>
<a name="ln695">		goto fail;</a>
<a name="ln696">	}</a>
<a name="ln697"> </a>
<a name="ln698">	iwn_sysctlattach(sc);</a>
<a name="ln699"> </a>
<a name="ln700">	/*</a>
<a name="ln701">	 * Hook our interrupt after all initialization is complete.</a>
<a name="ln702">	 */</a>
<a name="ln703">	error = bus_setup_intr(dev, sc-&gt;irq, INTR_TYPE_NET | INTR_MPSAFE,</a>
<a name="ln704">	    NULL, iwn_intr, sc, &amp;sc-&gt;sc_ih);</a>
<a name="ln705">	if (error != 0) {</a>
<a name="ln706">		device_printf(dev, &quot;can't establish interrupt, error %d\n&quot;,</a>
<a name="ln707">		    error);</a>
<a name="ln708">		goto fail;</a>
<a name="ln709">	}</a>
<a name="ln710"> </a>
<a name="ln711">#if 0</a>
<a name="ln712">	device_printf(sc-&gt;sc_dev, &quot;%s: rx_stats=%d, rx_stats_bt=%d\n&quot;,</a>
<a name="ln713">	    __func__,</a>
<a name="ln714">	    sizeof(struct iwn_stats),</a>
<a name="ln715">	    sizeof(struct iwn_stats_bt));</a>
<a name="ln716">#endif</a>
<a name="ln717"> </a>
<a name="ln718">	if (bootverbose)</a>
<a name="ln719">		ieee80211_announce(ic);</a>
<a name="ln720">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: end\n&quot;,__func__);</a>
<a name="ln721"> </a>
<a name="ln722">#ifndef __HAIKU__</a>
<a name="ln723">	/* Add debug ioctl right at the end */</a>
<a name="ln724">	sc-&gt;sc_cdev = make_dev(&amp;iwn_cdevsw, device_get_unit(dev),</a>
<a name="ln725">	    UID_ROOT, GID_WHEEL, 0600, &quot;%s&quot;, device_get_nameunit(dev));</a>
<a name="ln726">	if (sc-&gt;sc_cdev == NULL) {</a>
<a name="ln727">		device_printf(dev, &quot;failed to create debug character device\n&quot;);</a>
<a name="ln728">	} else {</a>
<a name="ln729">		sc-&gt;sc_cdev-&gt;si_drv1 = sc;</a>
<a name="ln730">	}</a>
<a name="ln731">#else</a>
<a name="ln732">	sc-&gt;sc_cdev = NULL;</a>
<a name="ln733">#endif</a>
<a name="ln734">	return 0;</a>
<a name="ln735">fail:</a>
<a name="ln736">	iwn_detach(dev);</a>
<a name="ln737">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: end in error\n&quot;,__func__);</a>
<a name="ln738">	return error;</a>
<a name="ln739">}</a>
<a name="ln740"> </a>
<a name="ln741">/*</a>
<a name="ln742"> * Define specific configuration based on device id and subdevice id</a>
<a name="ln743"> * pid : PCI device id</a>
<a name="ln744"> */</a>
<a name="ln745">static int</a>
<a name="ln746">iwn_config_specific(struct iwn_softc *sc, uint16_t pid)</a>
<a name="ln747">{</a>
<a name="ln748"> </a>
<a name="ln749">	switch (pid) {</a>
<a name="ln750">/* 4965 series */</a>
<a name="ln751">	case IWN_DID_4965_1:</a>
<a name="ln752">	case IWN_DID_4965_2:</a>
<a name="ln753">	case IWN_DID_4965_3:</a>
<a name="ln754">	case IWN_DID_4965_4:</a>
<a name="ln755">		sc-&gt;base_params = &amp;iwn4965_base_params;</a>
<a name="ln756">		sc-&gt;limits = &amp;iwn4965_sensitivity_limits;</a>
<a name="ln757">		sc-&gt;fwname = &quot;iwn4965fw&quot;;</a>
<a name="ln758">		/* Override chains masks, ROM is known to be broken. */</a>
<a name="ln759">		sc-&gt;txchainmask = IWN_ANT_AB;</a>
<a name="ln760">		sc-&gt;rxchainmask = IWN_ANT_ABC;</a>
<a name="ln761">		/* Enable normal btcoex */</a>
<a name="ln762">		sc-&gt;sc_flags |= IWN_FLAG_BTCOEX;</a>
<a name="ln763">		break;</a>
<a name="ln764">/* 1000 Series */</a>
<a name="ln765">	case IWN_DID_1000_1:</a>
<a name="ln766">	case IWN_DID_1000_2:</a>
<a name="ln767">		switch(sc-&gt;subdevice_id) {</a>
<a name="ln768">			case	IWN_SDID_1000_1:</a>
<a name="ln769">			case	IWN_SDID_1000_2:</a>
<a name="ln770">			case	IWN_SDID_1000_3:</a>
<a name="ln771">			case	IWN_SDID_1000_4:</a>
<a name="ln772">			case	IWN_SDID_1000_5:</a>
<a name="ln773">			case	IWN_SDID_1000_6:</a>
<a name="ln774">			case	IWN_SDID_1000_7:</a>
<a name="ln775">			case	IWN_SDID_1000_8:</a>
<a name="ln776">			case	IWN_SDID_1000_9:</a>
<a name="ln777">			case	IWN_SDID_1000_10:</a>
<a name="ln778">			case	IWN_SDID_1000_11:</a>
<a name="ln779">			case	IWN_SDID_1000_12:</a>
<a name="ln780">				sc-&gt;limits = &amp;iwn1000_sensitivity_limits;</a>
<a name="ln781">				sc-&gt;base_params = &amp;iwn1000_base_params;</a>
<a name="ln782">				sc-&gt;fwname = &quot;iwn1000fw&quot;;</a>
<a name="ln783">				break;</a>
<a name="ln784">			default:</a>
<a name="ln785">				device_printf(sc-&gt;sc_dev, &quot;adapter type id : 0x%04x sub id :&quot;</a>
<a name="ln786">				    &quot;0x%04x rev %d not supported (subdevice)\n&quot;, pid,</a>
<a name="ln787">				    sc-&gt;subdevice_id,sc-&gt;hw_type);</a>
<a name="ln788">				return ENOTSUP;</a>
<a name="ln789">		}</a>
<a name="ln790">		break;</a>
<a name="ln791">/* 6x00 Series */</a>
<a name="ln792">	case IWN_DID_6x00_2:</a>
<a name="ln793">	case IWN_DID_6x00_4:</a>
<a name="ln794">	case IWN_DID_6x00_1:</a>
<a name="ln795">	case IWN_DID_6x00_3:</a>
<a name="ln796">		sc-&gt;fwname = &quot;iwn6000fw&quot;;</a>
<a name="ln797">		sc-&gt;limits = &amp;iwn6000_sensitivity_limits;</a>
<a name="ln798">		switch(sc-&gt;subdevice_id) {</a>
<a name="ln799">			case IWN_SDID_6x00_1:</a>
<a name="ln800">			case IWN_SDID_6x00_2:</a>
<a name="ln801">			case IWN_SDID_6x00_8:</a>
<a name="ln802">				//iwl6000_3agn_cfg</a>
<a name="ln803">				sc-&gt;base_params = &amp;iwn_6000_base_params;</a>
<a name="ln804">				break;</a>
<a name="ln805">			case IWN_SDID_6x00_3:</a>
<a name="ln806">			case IWN_SDID_6x00_6:</a>
<a name="ln807">			case IWN_SDID_6x00_9:</a>
<a name="ln808">				////iwl6000i_2agn</a>
<a name="ln809">			case IWN_SDID_6x00_4:</a>
<a name="ln810">			case IWN_SDID_6x00_7:</a>
<a name="ln811">			case IWN_SDID_6x00_10:</a>
<a name="ln812">				//iwl6000i_2abg_cfg</a>
<a name="ln813">			case IWN_SDID_6x00_5:</a>
<a name="ln814">				//iwl6000i_2bg_cfg</a>
<a name="ln815">				sc-&gt;base_params = &amp;iwn_6000i_base_params;</a>
<a name="ln816">				sc-&gt;sc_flags |= IWN_FLAG_INTERNAL_PA;</a>
<a name="ln817">				sc-&gt;txchainmask = IWN_ANT_BC;</a>
<a name="ln818">				sc-&gt;rxchainmask = IWN_ANT_BC;</a>
<a name="ln819">				break;</a>
<a name="ln820">			default:</a>
<a name="ln821">				device_printf(sc-&gt;sc_dev, &quot;adapter type id : 0x%04x sub id :&quot;</a>
<a name="ln822">				    &quot;0x%04x rev %d not supported (subdevice)\n&quot;, pid,</a>
<a name="ln823">				    sc-&gt;subdevice_id,sc-&gt;hw_type);</a>
<a name="ln824">				return ENOTSUP;</a>
<a name="ln825">		}</a>
<a name="ln826">		break;</a>
<a name="ln827">/* 6x05 Series */</a>
<a name="ln828">	case IWN_DID_6x05_1:</a>
<a name="ln829">	case IWN_DID_6x05_2:</a>
<a name="ln830">		switch(sc-&gt;subdevice_id) {</a>
<a name="ln831">			case IWN_SDID_6x05_1:</a>
<a name="ln832">			case IWN_SDID_6x05_4:</a>
<a name="ln833">			case IWN_SDID_6x05_6:</a>
<a name="ln834">				//iwl6005_2agn_cfg</a>
<a name="ln835">			case IWN_SDID_6x05_2:</a>
<a name="ln836">			case IWN_SDID_6x05_5:</a>
<a name="ln837">			case IWN_SDID_6x05_7:</a>
<a name="ln838">				//iwl6005_2abg_cfg</a>
<a name="ln839">			case IWN_SDID_6x05_3:</a>
<a name="ln840">				//iwl6005_2bg_cfg</a>
<a name="ln841">			case IWN_SDID_6x05_8:</a>
<a name="ln842">			case IWN_SDID_6x05_9:</a>
<a name="ln843">				//iwl6005_2agn_sff_cfg</a>
<a name="ln844">			case IWN_SDID_6x05_10:</a>
<a name="ln845">				//iwl6005_2agn_d_cfg</a>
<a name="ln846">			case IWN_SDID_6x05_11:</a>
<a name="ln847">				//iwl6005_2agn_mow1_cfg</a>
<a name="ln848">			case IWN_SDID_6x05_12:</a>
<a name="ln849">				//iwl6005_2agn_mow2_cfg</a>
<a name="ln850">				sc-&gt;fwname = &quot;iwn6000g2afw&quot;;</a>
<a name="ln851">				sc-&gt;limits = &amp;iwn6000_sensitivity_limits;</a>
<a name="ln852">				sc-&gt;base_params = &amp;iwn_6000g2_base_params;</a>
<a name="ln853">				break;</a>
<a name="ln854">			default:</a>
<a name="ln855">				device_printf(sc-&gt;sc_dev, &quot;adapter type id : 0x%04x sub id :&quot;</a>
<a name="ln856">				    &quot;0x%04x rev %d not supported (subdevice)\n&quot;, pid,</a>
<a name="ln857">				    sc-&gt;subdevice_id,sc-&gt;hw_type);</a>
<a name="ln858">				return ENOTSUP;</a>
<a name="ln859">		}</a>
<a name="ln860">		break;</a>
<a name="ln861">/* 6x35 Series */</a>
<a name="ln862">	case IWN_DID_6035_1:</a>
<a name="ln863">	case IWN_DID_6035_2:</a>
<a name="ln864">		switch(sc-&gt;subdevice_id) {</a>
<a name="ln865">			case IWN_SDID_6035_1:</a>
<a name="ln866">			case IWN_SDID_6035_2:</a>
<a name="ln867">			case IWN_SDID_6035_3:</a>
<a name="ln868">			case IWN_SDID_6035_4:</a>
<a name="ln869">			case IWN_SDID_6035_5:</a>
<a name="ln870">				sc-&gt;fwname = &quot;iwn6000g2bfw&quot;;</a>
<a name="ln871">				sc-&gt;limits = &amp;iwn6235_sensitivity_limits;</a>
<a name="ln872">				sc-&gt;base_params = &amp;iwn_6235_base_params;</a>
<a name="ln873">				break;</a>
<a name="ln874">			default:</a>
<a name="ln875">				device_printf(sc-&gt;sc_dev, &quot;adapter type id : 0x%04x sub id :&quot;</a>
<a name="ln876">				    &quot;0x%04x rev %d not supported (subdevice)\n&quot;, pid,</a>
<a name="ln877">				    sc-&gt;subdevice_id,sc-&gt;hw_type);</a>
<a name="ln878">				return ENOTSUP;</a>
<a name="ln879">		}</a>
<a name="ln880">		break;</a>
<a name="ln881">/* 6x50 WiFi/WiMax Series */</a>
<a name="ln882">	case IWN_DID_6050_1:</a>
<a name="ln883">	case IWN_DID_6050_2:</a>
<a name="ln884">		switch(sc-&gt;subdevice_id) {</a>
<a name="ln885">			case IWN_SDID_6050_1:</a>
<a name="ln886">			case IWN_SDID_6050_3:</a>
<a name="ln887">			case IWN_SDID_6050_5:</a>
<a name="ln888">				//iwl6050_2agn_cfg</a>
<a name="ln889">			case IWN_SDID_6050_2:</a>
<a name="ln890">			case IWN_SDID_6050_4:</a>
<a name="ln891">			case IWN_SDID_6050_6:</a>
<a name="ln892">				//iwl6050_2abg_cfg</a>
<a name="ln893">				sc-&gt;fwname = &quot;iwn6050fw&quot;;</a>
<a name="ln894">				sc-&gt;txchainmask = IWN_ANT_AB;</a>
<a name="ln895">				sc-&gt;rxchainmask = IWN_ANT_AB;</a>
<a name="ln896">				sc-&gt;limits = &amp;iwn6000_sensitivity_limits;</a>
<a name="ln897">				sc-&gt;base_params = &amp;iwn_6050_base_params;</a>
<a name="ln898">				break;</a>
<a name="ln899">			default:</a>
<a name="ln900">				device_printf(sc-&gt;sc_dev, &quot;adapter type id : 0x%04x sub id :&quot;</a>
<a name="ln901">				    &quot;0x%04x rev %d not supported (subdevice)\n&quot;, pid,</a>
<a name="ln902">				    sc-&gt;subdevice_id,sc-&gt;hw_type);</a>
<a name="ln903">				return ENOTSUP;</a>
<a name="ln904">		}</a>
<a name="ln905">		break;</a>
<a name="ln906">/* 6150 WiFi/WiMax Series */</a>
<a name="ln907">	case IWN_DID_6150_1:</a>
<a name="ln908">	case IWN_DID_6150_2:</a>
<a name="ln909">		switch(sc-&gt;subdevice_id) {</a>
<a name="ln910">			case IWN_SDID_6150_1:</a>
<a name="ln911">			case IWN_SDID_6150_3:</a>
<a name="ln912">			case IWN_SDID_6150_5:</a>
<a name="ln913">				// iwl6150_bgn_cfg</a>
<a name="ln914">			case IWN_SDID_6150_2:</a>
<a name="ln915">			case IWN_SDID_6150_4:</a>
<a name="ln916">			case IWN_SDID_6150_6:</a>
<a name="ln917">				//iwl6150_bg_cfg</a>
<a name="ln918">				sc-&gt;fwname = &quot;iwn6050fw&quot;;</a>
<a name="ln919">				sc-&gt;limits = &amp;iwn6000_sensitivity_limits;</a>
<a name="ln920">				sc-&gt;base_params = &amp;iwn_6150_base_params;</a>
<a name="ln921">				break;</a>
<a name="ln922">			default:</a>
<a name="ln923">				device_printf(sc-&gt;sc_dev, &quot;adapter type id : 0x%04x sub id :&quot;</a>
<a name="ln924">				    &quot;0x%04x rev %d not supported (subdevice)\n&quot;, pid,</a>
<a name="ln925">				    sc-&gt;subdevice_id,sc-&gt;hw_type);</a>
<a name="ln926">				return ENOTSUP;</a>
<a name="ln927">		}</a>
<a name="ln928">		break;</a>
<a name="ln929">/* 6030 Series and 1030 Series */</a>
<a name="ln930">	case IWN_DID_x030_1:</a>
<a name="ln931">	case IWN_DID_x030_2:</a>
<a name="ln932">	case IWN_DID_x030_3:</a>
<a name="ln933">	case IWN_DID_x030_4:</a>
<a name="ln934">		switch(sc-&gt;subdevice_id) {</a>
<a name="ln935">			case IWN_SDID_x030_1:</a>
<a name="ln936">			case IWN_SDID_x030_3:</a>
<a name="ln937">			case IWN_SDID_x030_5:</a>
<a name="ln938">			// iwl1030_bgn_cfg</a>
<a name="ln939">			case IWN_SDID_x030_2:</a>
<a name="ln940">			case IWN_SDID_x030_4:</a>
<a name="ln941">			case IWN_SDID_x030_6:</a>
<a name="ln942">			//iwl1030_bg_cfg</a>
<a name="ln943">			case IWN_SDID_x030_7:</a>
<a name="ln944">			case IWN_SDID_x030_10:</a>
<a name="ln945">			case IWN_SDID_x030_14:</a>
<a name="ln946">			//iwl6030_2agn_cfg</a>
<a name="ln947">			case IWN_SDID_x030_8:</a>
<a name="ln948">			case IWN_SDID_x030_11:</a>
<a name="ln949">			case IWN_SDID_x030_15:</a>
<a name="ln950">			// iwl6030_2bgn_cfg</a>
<a name="ln951">			case IWN_SDID_x030_9:</a>
<a name="ln952">			case IWN_SDID_x030_12:</a>
<a name="ln953">			case IWN_SDID_x030_16:</a>
<a name="ln954">			// iwl6030_2abg_cfg</a>
<a name="ln955">			case IWN_SDID_x030_13:</a>
<a name="ln956">			//iwl6030_2bg_cfg</a>
<a name="ln957">				sc-&gt;fwname = &quot;iwn6000g2bfw&quot;;</a>
<a name="ln958">				sc-&gt;limits = &amp;iwn6000_sensitivity_limits;</a>
<a name="ln959">				sc-&gt;base_params = &amp;iwn_6000g2b_base_params;</a>
<a name="ln960">				break;</a>
<a name="ln961">			default:</a>
<a name="ln962">				device_printf(sc-&gt;sc_dev, &quot;adapter type id : 0x%04x sub id :&quot;</a>
<a name="ln963">				    &quot;0x%04x rev %d not supported (subdevice)\n&quot;, pid,</a>
<a name="ln964">				    sc-&gt;subdevice_id,sc-&gt;hw_type);</a>
<a name="ln965">				return ENOTSUP;</a>
<a name="ln966">		}</a>
<a name="ln967">		break;</a>
<a name="ln968">/* 130 Series WiFi */</a>
<a name="ln969">/* XXX: This series will need adjustment for rate.</a>
<a name="ln970"> * see rx_with_siso_diversity in linux kernel</a>
<a name="ln971"> */</a>
<a name="ln972">	case IWN_DID_130_1:</a>
<a name="ln973">	case IWN_DID_130_2:</a>
<a name="ln974">		switch(sc-&gt;subdevice_id) {</a>
<a name="ln975">			case IWN_SDID_130_1:</a>
<a name="ln976">			case IWN_SDID_130_3:</a>
<a name="ln977">			case IWN_SDID_130_5:</a>
<a name="ln978">			//iwl130_bgn_cfg</a>
<a name="ln979">			case IWN_SDID_130_2:</a>
<a name="ln980">			case IWN_SDID_130_4:</a>
<a name="ln981">			case IWN_SDID_130_6:</a>
<a name="ln982">			//iwl130_bg_cfg</a>
<a name="ln983">				sc-&gt;fwname = &quot;iwn6000g2bfw&quot;;</a>
<a name="ln984">				sc-&gt;limits = &amp;iwn6000_sensitivity_limits;</a>
<a name="ln985">				sc-&gt;base_params = &amp;iwn_6000g2b_base_params;</a>
<a name="ln986">				break;</a>
<a name="ln987">			default:</a>
<a name="ln988">				device_printf(sc-&gt;sc_dev, &quot;adapter type id : 0x%04x sub id :&quot;</a>
<a name="ln989">				    &quot;0x%04x rev %d not supported (subdevice)\n&quot;, pid,</a>
<a name="ln990">				    sc-&gt;subdevice_id,sc-&gt;hw_type);</a>
<a name="ln991">				return ENOTSUP;</a>
<a name="ln992">		}</a>
<a name="ln993">		break;</a>
<a name="ln994">/* 100 Series WiFi */</a>
<a name="ln995">	case IWN_DID_100_1:</a>
<a name="ln996">	case IWN_DID_100_2:</a>
<a name="ln997">		switch(sc-&gt;subdevice_id) {</a>
<a name="ln998">			case IWN_SDID_100_1:</a>
<a name="ln999">			case IWN_SDID_100_2:</a>
<a name="ln1000">			case IWN_SDID_100_3:</a>
<a name="ln1001">			case IWN_SDID_100_4:</a>
<a name="ln1002">			case IWN_SDID_100_5:</a>
<a name="ln1003">			case IWN_SDID_100_6:</a>
<a name="ln1004">				sc-&gt;limits = &amp;iwn1000_sensitivity_limits;</a>
<a name="ln1005">				sc-&gt;base_params = &amp;iwn1000_base_params;</a>
<a name="ln1006">				sc-&gt;fwname = &quot;iwn100fw&quot;;</a>
<a name="ln1007">				break;</a>
<a name="ln1008">			default:</a>
<a name="ln1009">				device_printf(sc-&gt;sc_dev, &quot;adapter type id : 0x%04x sub id :&quot;</a>
<a name="ln1010">				    &quot;0x%04x rev %d not supported (subdevice)\n&quot;, pid,</a>
<a name="ln1011">				    sc-&gt;subdevice_id,sc-&gt;hw_type);</a>
<a name="ln1012">				return ENOTSUP;</a>
<a name="ln1013">		}</a>
<a name="ln1014">		break;</a>
<a name="ln1015"> </a>
<a name="ln1016">/* 105 Series */</a>
<a name="ln1017">/* XXX: This series will need adjustment for rate.</a>
<a name="ln1018"> * see rx_with_siso_diversity in linux kernel</a>
<a name="ln1019"> */</a>
<a name="ln1020">	case IWN_DID_105_1:</a>
<a name="ln1021">	case IWN_DID_105_2:</a>
<a name="ln1022">		switch(sc-&gt;subdevice_id) {</a>
<a name="ln1023">			case IWN_SDID_105_1:</a>
<a name="ln1024">			case IWN_SDID_105_2:</a>
<a name="ln1025">			case IWN_SDID_105_3:</a>
<a name="ln1026">			//iwl105_bgn_cfg</a>
<a name="ln1027">			case IWN_SDID_105_4:</a>
<a name="ln1028">			//iwl105_bgn_d_cfg</a>
<a name="ln1029">				sc-&gt;limits = &amp;iwn2030_sensitivity_limits;</a>
<a name="ln1030">				sc-&gt;base_params = &amp;iwn2000_base_params;</a>
<a name="ln1031">				sc-&gt;fwname = &quot;iwn105fw&quot;;</a>
<a name="ln1032">				break;</a>
<a name="ln1033">			default:</a>
<a name="ln1034">				device_printf(sc-&gt;sc_dev, &quot;adapter type id : 0x%04x sub id :&quot;</a>
<a name="ln1035">				    &quot;0x%04x rev %d not supported (subdevice)\n&quot;, pid,</a>
<a name="ln1036">				    sc-&gt;subdevice_id,sc-&gt;hw_type);</a>
<a name="ln1037">				return ENOTSUP;</a>
<a name="ln1038">		}</a>
<a name="ln1039">		break;</a>
<a name="ln1040"> </a>
<a name="ln1041">/* 135 Series */</a>
<a name="ln1042">/* XXX: This series will need adjustment for rate.</a>
<a name="ln1043"> * see rx_with_siso_diversity in linux kernel</a>
<a name="ln1044"> */</a>
<a name="ln1045">	case IWN_DID_135_1:</a>
<a name="ln1046">	case IWN_DID_135_2:</a>
<a name="ln1047">		switch(sc-&gt;subdevice_id) {</a>
<a name="ln1048">			case IWN_SDID_135_1:</a>
<a name="ln1049">			case IWN_SDID_135_2:</a>
<a name="ln1050">			case IWN_SDID_135_3:</a>
<a name="ln1051">				sc-&gt;limits = &amp;iwn2030_sensitivity_limits;</a>
<a name="ln1052">				sc-&gt;base_params = &amp;iwn2030_base_params;</a>
<a name="ln1053">				sc-&gt;fwname = &quot;iwn135fw&quot;;</a>
<a name="ln1054">				break;</a>
<a name="ln1055">			default:</a>
<a name="ln1056">				device_printf(sc-&gt;sc_dev, &quot;adapter type id : 0x%04x sub id :&quot;</a>
<a name="ln1057">				    &quot;0x%04x rev %d not supported (subdevice)\n&quot;, pid,</a>
<a name="ln1058">				    sc-&gt;subdevice_id,sc-&gt;hw_type);</a>
<a name="ln1059">				return ENOTSUP;</a>
<a name="ln1060">		}</a>
<a name="ln1061">		break;</a>
<a name="ln1062"> </a>
<a name="ln1063">/* 2x00 Series */</a>
<a name="ln1064">	case IWN_DID_2x00_1:</a>
<a name="ln1065">	case IWN_DID_2x00_2:</a>
<a name="ln1066">		switch(sc-&gt;subdevice_id) {</a>
<a name="ln1067">			case IWN_SDID_2x00_1:</a>
<a name="ln1068">			case IWN_SDID_2x00_2:</a>
<a name="ln1069">			case IWN_SDID_2x00_3:</a>
<a name="ln1070">			//iwl2000_2bgn_cfg</a>
<a name="ln1071">			case IWN_SDID_2x00_4:</a>
<a name="ln1072">			//iwl2000_2bgn_d_cfg</a>
<a name="ln1073">				sc-&gt;limits = &amp;iwn2030_sensitivity_limits;</a>
<a name="ln1074">				sc-&gt;base_params = &amp;iwn2000_base_params;</a>
<a name="ln1075">				sc-&gt;fwname = &quot;iwn2000fw&quot;;</a>
<a name="ln1076">				break;</a>
<a name="ln1077">			default:</a>
<a name="ln1078">				device_printf(sc-&gt;sc_dev, &quot;adapter type id : 0x%04x sub id :&quot;</a>
<a name="ln1079">				    &quot;0x%04x rev %d not supported (subdevice) \n&quot;,</a>
<a name="ln1080">				    pid, sc-&gt;subdevice_id, sc-&gt;hw_type);</a>
<a name="ln1081">				return ENOTSUP;</a>
<a name="ln1082">		}</a>
<a name="ln1083">		break;</a>
<a name="ln1084">/* 2x30 Series */</a>
<a name="ln1085">	case IWN_DID_2x30_1:</a>
<a name="ln1086">	case IWN_DID_2x30_2:</a>
<a name="ln1087">		switch(sc-&gt;subdevice_id) {</a>
<a name="ln1088">			case IWN_SDID_2x30_1:</a>
<a name="ln1089">			case IWN_SDID_2x30_3:</a>
<a name="ln1090">			case IWN_SDID_2x30_5:</a>
<a name="ln1091">			//iwl100_bgn_cfg</a>
<a name="ln1092">			case IWN_SDID_2x30_2:</a>
<a name="ln1093">			case IWN_SDID_2x30_4:</a>
<a name="ln1094">			case IWN_SDID_2x30_6:</a>
<a name="ln1095">			//iwl100_bg_cfg</a>
<a name="ln1096">				sc-&gt;limits = &amp;iwn2030_sensitivity_limits;</a>
<a name="ln1097">				sc-&gt;base_params = &amp;iwn2030_base_params;</a>
<a name="ln1098">				sc-&gt;fwname = &quot;iwn2030fw&quot;;</a>
<a name="ln1099">				break;</a>
<a name="ln1100">			default:</a>
<a name="ln1101">				device_printf(sc-&gt;sc_dev, &quot;adapter type id : 0x%04x sub id :&quot;</a>
<a name="ln1102">				    &quot;0x%04x rev %d not supported (subdevice)\n&quot;, pid,</a>
<a name="ln1103">				    sc-&gt;subdevice_id,sc-&gt;hw_type);</a>
<a name="ln1104">				return ENOTSUP;</a>
<a name="ln1105">		}</a>
<a name="ln1106">		break;</a>
<a name="ln1107">/* 5x00 Series */</a>
<a name="ln1108">	case IWN_DID_5x00_1:</a>
<a name="ln1109">	case IWN_DID_5x00_2:</a>
<a name="ln1110">	case IWN_DID_5x00_3:</a>
<a name="ln1111">	case IWN_DID_5x00_4:</a>
<a name="ln1112">		sc-&gt;limits = &amp;iwn5000_sensitivity_limits;</a>
<a name="ln1113">		sc-&gt;base_params = &amp;iwn5000_base_params;</a>
<a name="ln1114">		sc-&gt;fwname = &quot;iwn5000fw&quot;;</a>
<a name="ln1115">		switch(sc-&gt;subdevice_id) {</a>
<a name="ln1116">			case IWN_SDID_5x00_1:</a>
<a name="ln1117">			case IWN_SDID_5x00_2:</a>
<a name="ln1118">			case IWN_SDID_5x00_3:</a>
<a name="ln1119">			case IWN_SDID_5x00_4:</a>
<a name="ln1120">			case IWN_SDID_5x00_9:</a>
<a name="ln1121">			case IWN_SDID_5x00_10:</a>
<a name="ln1122">			case IWN_SDID_5x00_11:</a>
<a name="ln1123">			case IWN_SDID_5x00_12:</a>
<a name="ln1124">			case IWN_SDID_5x00_17:</a>
<a name="ln1125">			case IWN_SDID_5x00_18:</a>
<a name="ln1126">			case IWN_SDID_5x00_19:</a>
<a name="ln1127">			case IWN_SDID_5x00_20:</a>
<a name="ln1128">			//iwl5100_agn_cfg</a>
<a name="ln1129">				sc-&gt;txchainmask = IWN_ANT_B;</a>
<a name="ln1130">				sc-&gt;rxchainmask = IWN_ANT_AB;</a>
<a name="ln1131">				break;</a>
<a name="ln1132">			case IWN_SDID_5x00_5:</a>
<a name="ln1133">			case IWN_SDID_5x00_6:</a>
<a name="ln1134">			case IWN_SDID_5x00_13:</a>
<a name="ln1135">			case IWN_SDID_5x00_14:</a>
<a name="ln1136">			case IWN_SDID_5x00_21:</a>
<a name="ln1137">			case IWN_SDID_5x00_22:</a>
<a name="ln1138">			//iwl5100_bgn_cfg</a>
<a name="ln1139">				sc-&gt;txchainmask = IWN_ANT_B;</a>
<a name="ln1140">				sc-&gt;rxchainmask = IWN_ANT_AB;</a>
<a name="ln1141">				break;</a>
<a name="ln1142">			case IWN_SDID_5x00_7:</a>
<a name="ln1143">			case IWN_SDID_5x00_8:</a>
<a name="ln1144">			case IWN_SDID_5x00_15:</a>
<a name="ln1145">			case IWN_SDID_5x00_16:</a>
<a name="ln1146">			case IWN_SDID_5x00_23:</a>
<a name="ln1147">			case IWN_SDID_5x00_24:</a>
<a name="ln1148">			//iwl5100_abg_cfg</a>
<a name="ln1149">				sc-&gt;txchainmask = IWN_ANT_B;</a>
<a name="ln1150">				sc-&gt;rxchainmask = IWN_ANT_AB;</a>
<a name="ln1151">				break;</a>
<a name="ln1152">			case IWN_SDID_5x00_25:</a>
<a name="ln1153">			case IWN_SDID_5x00_26:</a>
<a name="ln1154">			case IWN_SDID_5x00_27:</a>
<a name="ln1155">			case IWN_SDID_5x00_28:</a>
<a name="ln1156">			case IWN_SDID_5x00_29:</a>
<a name="ln1157">			case IWN_SDID_5x00_30:</a>
<a name="ln1158">			case IWN_SDID_5x00_31:</a>
<a name="ln1159">			case IWN_SDID_5x00_32:</a>
<a name="ln1160">			case IWN_SDID_5x00_33:</a>
<a name="ln1161">			case IWN_SDID_5x00_34:</a>
<a name="ln1162">			case IWN_SDID_5x00_35:</a>
<a name="ln1163">			case IWN_SDID_5x00_36:</a>
<a name="ln1164">			//iwl5300_agn_cfg</a>
<a name="ln1165">				sc-&gt;txchainmask = IWN_ANT_ABC;</a>
<a name="ln1166">				sc-&gt;rxchainmask = IWN_ANT_ABC;</a>
<a name="ln1167">				break;</a>
<a name="ln1168">			default:</a>
<a name="ln1169">				device_printf(sc-&gt;sc_dev, &quot;adapter type id : 0x%04x sub id :&quot;</a>
<a name="ln1170">				    &quot;0x%04x rev %d not supported (subdevice)\n&quot;, pid,</a>
<a name="ln1171">				    sc-&gt;subdevice_id,sc-&gt;hw_type);</a>
<a name="ln1172">				return ENOTSUP;</a>
<a name="ln1173">		}</a>
<a name="ln1174">		break;</a>
<a name="ln1175">/* 5x50 Series */</a>
<a name="ln1176">	case IWN_DID_5x50_1:</a>
<a name="ln1177">	case IWN_DID_5x50_2:</a>
<a name="ln1178">	case IWN_DID_5x50_3:</a>
<a name="ln1179">	case IWN_DID_5x50_4:</a>
<a name="ln1180">		sc-&gt;limits = &amp;iwn5000_sensitivity_limits;</a>
<a name="ln1181">		sc-&gt;base_params = &amp;iwn5000_base_params;</a>
<a name="ln1182">		sc-&gt;fwname = &quot;iwn5000fw&quot;;</a>
<a name="ln1183">		switch(sc-&gt;subdevice_id) {</a>
<a name="ln1184">			case IWN_SDID_5x50_1:</a>
<a name="ln1185">			case IWN_SDID_5x50_2:</a>
<a name="ln1186">			case IWN_SDID_5x50_3:</a>
<a name="ln1187">			//iwl5350_agn_cfg</a>
<a name="ln1188">				sc-&gt;limits = &amp;iwn5000_sensitivity_limits;</a>
<a name="ln1189">				sc-&gt;base_params = &amp;iwn5000_base_params;</a>
<a name="ln1190">				sc-&gt;fwname = &quot;iwn5000fw&quot;;</a>
<a name="ln1191">				break;</a>
<a name="ln1192">			case IWN_SDID_5x50_4:</a>
<a name="ln1193">			case IWN_SDID_5x50_5:</a>
<a name="ln1194">			case IWN_SDID_5x50_8:</a>
<a name="ln1195">			case IWN_SDID_5x50_9:</a>
<a name="ln1196">			case IWN_SDID_5x50_10:</a>
<a name="ln1197">			case IWN_SDID_5x50_11:</a>
<a name="ln1198">			//iwl5150_agn_cfg</a>
<a name="ln1199">			case IWN_SDID_5x50_6:</a>
<a name="ln1200">			case IWN_SDID_5x50_7:</a>
<a name="ln1201">			case IWN_SDID_5x50_12:</a>
<a name="ln1202">			case IWN_SDID_5x50_13:</a>
<a name="ln1203">			//iwl5150_abg_cfg</a>
<a name="ln1204">				sc-&gt;limits = &amp;iwn5000_sensitivity_limits;</a>
<a name="ln1205">				sc-&gt;fwname = &quot;iwn5150fw&quot;;</a>
<a name="ln1206">				sc-&gt;base_params = &amp;iwn_5x50_base_params;</a>
<a name="ln1207">				break;</a>
<a name="ln1208">			default:</a>
<a name="ln1209">				device_printf(sc-&gt;sc_dev, &quot;adapter type id : 0x%04x sub id :&quot;</a>
<a name="ln1210">				    &quot;0x%04x rev %d not supported (subdevice)\n&quot;, pid,</a>
<a name="ln1211">				    sc-&gt;subdevice_id,sc-&gt;hw_type);</a>
<a name="ln1212">				return ENOTSUP;</a>
<a name="ln1213">		}</a>
<a name="ln1214">		break;</a>
<a name="ln1215">	default:</a>
<a name="ln1216">		device_printf(sc-&gt;sc_dev, &quot;adapter type id : 0x%04x sub id : 0x%04x&quot;</a>
<a name="ln1217">		    &quot;rev 0x%08x not supported (device)\n&quot;, pid, sc-&gt;subdevice_id,</a>
<a name="ln1218">		     sc-&gt;hw_type);</a>
<a name="ln1219">		return ENOTSUP;</a>
<a name="ln1220">	}</a>
<a name="ln1221">	return 0;</a>
<a name="ln1222">}</a>
<a name="ln1223"> </a>
<a name="ln1224">static int</a>
<a name="ln1225">iwn4965_attach(struct iwn_softc *sc, uint16_t pid)</a>
<a name="ln1226">{</a>
<a name="ln1227">	struct iwn_ops *ops = &amp;sc-&gt;ops;</a>
<a name="ln1228"> </a>
<a name="ln1229">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln1230">	ops-&gt;load_firmware = iwn4965_load_firmware;</a>
<a name="ln1231">	ops-&gt;read_eeprom = iwn4965_read_eeprom;</a>
<a name="ln1232">	ops-&gt;post_alive = iwn4965_post_alive;</a>
<a name="ln1233">	ops-&gt;nic_config = iwn4965_nic_config;</a>
<a name="ln1234">	ops-&gt;update_sched = iwn4965_update_sched;</a>
<a name="ln1235">	ops-&gt;get_temperature = iwn4965_get_temperature;</a>
<a name="ln1236">	ops-&gt;get_rssi = iwn4965_get_rssi;</a>
<a name="ln1237">	ops-&gt;set_txpower = iwn4965_set_txpower;</a>
<a name="ln1238">	ops-&gt;init_gains = iwn4965_init_gains;</a>
<a name="ln1239">	ops-&gt;set_gains = iwn4965_set_gains;</a>
<a name="ln1240">	ops-&gt;rxon_assoc = iwn4965_rxon_assoc;</a>
<a name="ln1241">	ops-&gt;add_node = iwn4965_add_node;</a>
<a name="ln1242">	ops-&gt;tx_done = iwn4965_tx_done;</a>
<a name="ln1243">	ops-&gt;ampdu_tx_start = iwn4965_ampdu_tx_start;</a>
<a name="ln1244">	ops-&gt;ampdu_tx_stop = iwn4965_ampdu_tx_stop;</a>
<a name="ln1245">	sc-&gt;ntxqs = IWN4965_NTXQUEUES;</a>
<a name="ln1246">	sc-&gt;firstaggqueue = IWN4965_FIRSTAGGQUEUE;</a>
<a name="ln1247">	sc-&gt;ndmachnls = IWN4965_NDMACHNLS;</a>
<a name="ln1248">	sc-&gt;broadcast_id = IWN4965_ID_BROADCAST;</a>
<a name="ln1249">	sc-&gt;rxonsz = IWN4965_RXONSZ;</a>
<a name="ln1250">	sc-&gt;schedsz = IWN4965_SCHEDSZ;</a>
<a name="ln1251">	sc-&gt;fw_text_maxsz = IWN4965_FW_TEXT_MAXSZ;</a>
<a name="ln1252">	sc-&gt;fw_data_maxsz = IWN4965_FW_DATA_MAXSZ;</a>
<a name="ln1253">	sc-&gt;fwsz = IWN4965_FWSZ;</a>
<a name="ln1254">	sc-&gt;sched_txfact_addr = IWN4965_SCHED_TXFACT;</a>
<a name="ln1255">	sc-&gt;limits = &amp;iwn4965_sensitivity_limits;</a>
<a name="ln1256">	sc-&gt;fwname = &quot;iwn4965fw&quot;;</a>
<a name="ln1257">	/* Override chains masks, ROM is known to be broken. */</a>
<a name="ln1258">	sc-&gt;txchainmask = IWN_ANT_AB;</a>
<a name="ln1259">	sc-&gt;rxchainmask = IWN_ANT_ABC;</a>
<a name="ln1260">	/* Enable normal btcoex */</a>
<a name="ln1261">	sc-&gt;sc_flags |= IWN_FLAG_BTCOEX;</a>
<a name="ln1262"> </a>
<a name="ln1263">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;%s: end\n&quot;,__func__);</a>
<a name="ln1264"> </a>
<a name="ln1265">	return 0;</a>
<a name="ln1266">}</a>
<a name="ln1267"> </a>
<a name="ln1268">static int</a>
<a name="ln1269">iwn5000_attach(struct iwn_softc *sc, uint16_t pid)</a>
<a name="ln1270">{</a>
<a name="ln1271">	struct iwn_ops *ops = &amp;sc-&gt;ops;</a>
<a name="ln1272"> </a>
<a name="ln1273">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln1274"> </a>
<a name="ln1275">	ops-&gt;load_firmware = iwn5000_load_firmware;</a>
<a name="ln1276">	ops-&gt;read_eeprom = iwn5000_read_eeprom;</a>
<a name="ln1277">	ops-&gt;post_alive = iwn5000_post_alive;</a>
<a name="ln1278">	ops-&gt;nic_config = iwn5000_nic_config;</a>
<a name="ln1279">	ops-&gt;update_sched = iwn5000_update_sched;</a>
<a name="ln1280">	ops-&gt;get_temperature = iwn5000_get_temperature;</a>
<a name="ln1281">	ops-&gt;get_rssi = iwn5000_get_rssi;</a>
<a name="ln1282">	ops-&gt;set_txpower = iwn5000_set_txpower;</a>
<a name="ln1283">	ops-&gt;init_gains = iwn5000_init_gains;</a>
<a name="ln1284">	ops-&gt;set_gains = iwn5000_set_gains;</a>
<a name="ln1285">	ops-&gt;rxon_assoc = iwn5000_rxon_assoc;</a>
<a name="ln1286">	ops-&gt;add_node = iwn5000_add_node;</a>
<a name="ln1287">	ops-&gt;tx_done = iwn5000_tx_done;</a>
<a name="ln1288">	ops-&gt;ampdu_tx_start = iwn5000_ampdu_tx_start;</a>
<a name="ln1289">	ops-&gt;ampdu_tx_stop = iwn5000_ampdu_tx_stop;</a>
<a name="ln1290">	sc-&gt;ntxqs = IWN5000_NTXQUEUES;</a>
<a name="ln1291">	sc-&gt;firstaggqueue = IWN5000_FIRSTAGGQUEUE;</a>
<a name="ln1292">	sc-&gt;ndmachnls = IWN5000_NDMACHNLS;</a>
<a name="ln1293">	sc-&gt;broadcast_id = IWN5000_ID_BROADCAST;</a>
<a name="ln1294">	sc-&gt;rxonsz = IWN5000_RXONSZ;</a>
<a name="ln1295">	sc-&gt;schedsz = IWN5000_SCHEDSZ;</a>
<a name="ln1296">	sc-&gt;fw_text_maxsz = IWN5000_FW_TEXT_MAXSZ;</a>
<a name="ln1297">	sc-&gt;fw_data_maxsz = IWN5000_FW_DATA_MAXSZ;</a>
<a name="ln1298">	sc-&gt;fwsz = IWN5000_FWSZ;</a>
<a name="ln1299">	sc-&gt;sched_txfact_addr = IWN5000_SCHED_TXFACT;</a>
<a name="ln1300">	sc-&gt;reset_noise_gain = IWN5000_PHY_CALIB_RESET_NOISE_GAIN;</a>
<a name="ln1301">	sc-&gt;noise_gain = IWN5000_PHY_CALIB_NOISE_GAIN;</a>
<a name="ln1302"> </a>
<a name="ln1303">	return 0;</a>
<a name="ln1304">}</a>
<a name="ln1305"> </a>
<a name="ln1306">/*</a>
<a name="ln1307"> * Attach the interface to 802.11 radiotap.</a>
<a name="ln1308"> */</a>
<a name="ln1309">static void</a>
<a name="ln1310">iwn_radiotap_attach(struct iwn_softc *sc)</a>
<a name="ln1311">{</a>
<a name="ln1312"> </a>
<a name="ln1313">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln1314">	ieee80211_radiotap_attach(&amp;sc-&gt;sc_ic,</a>
<a name="ln1315">	    &amp;sc-&gt;sc_txtap.wt_ihdr, sizeof(sc-&gt;sc_txtap),</a>
<a name="ln1316">		IWN_TX_RADIOTAP_PRESENT,</a>
<a name="ln1317">	    &amp;sc-&gt;sc_rxtap.wr_ihdr, sizeof(sc-&gt;sc_rxtap),</a>
<a name="ln1318">		IWN_RX_RADIOTAP_PRESENT);</a>
<a name="ln1319">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s end\n&quot;, __func__);</a>
<a name="ln1320">}</a>
<a name="ln1321"> </a>
<a name="ln1322">static void</a>
<a name="ln1323">iwn_sysctlattach(struct iwn_softc *sc)</a>
<a name="ln1324">{</a>
<a name="ln1325">#ifdef	IWN_DEBUG</a>
<a name="ln1326">	struct sysctl_ctx_list *ctx = device_get_sysctl_ctx(sc-&gt;sc_dev);</a>
<a name="ln1327">	struct sysctl_oid *tree = device_get_sysctl_tree(sc-&gt;sc_dev);</a>
<a name="ln1328"> </a>
<a name="ln1329">	SYSCTL_ADD_INT(ctx, SYSCTL_CHILDREN(tree), OID_AUTO,</a>
<a name="ln1330">	    &quot;debug&quot;, CTLFLAG_RW, &amp;sc-&gt;sc_debug, sc-&gt;sc_debug,</a>
<a name="ln1331">		&quot;control debugging printfs&quot;);</a>
<a name="ln1332">#endif</a>
<a name="ln1333">}</a>
<a name="ln1334"> </a>
<a name="ln1335">static struct ieee80211vap *</a>
<a name="ln1336">iwn_vap_create(struct ieee80211com *ic, const char name[IFNAMSIZ], int unit,</a>
<a name="ln1337">    enum ieee80211_opmode opmode, int flags,</a>
<a name="ln1338">    const uint8_t bssid[IEEE80211_ADDR_LEN],</a>
<a name="ln1339">    const uint8_t mac[IEEE80211_ADDR_LEN])</a>
<a name="ln1340">{</a>
<a name="ln1341">	struct iwn_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1342">	struct iwn_vap *ivp;</a>
<a name="ln1343">	struct ieee80211vap *vap;</a>
<a name="ln1344"> </a>
<a name="ln1345">	if (!TAILQ_EMPTY(&amp;ic-&gt;ic_vaps))		/* only one at a time */</a>
<a name="ln1346">		return NULL;</a>
<a name="ln1347"> </a>
<a name="ln1348">	ivp = malloc(sizeof(struct iwn_vap), M_80211_VAP, M_WAITOK | M_ZERO);</a>
<a name="ln1349">	vap = &amp;ivp-&gt;iv_vap;</a>
<a name="ln1350">	ieee80211_vap_setup(ic, vap, name, unit, opmode, flags, bssid);</a>
<a name="ln1351">	ivp-&gt;ctx = IWN_RXON_BSS_CTX;</a>
<a name="ln1352">	vap-&gt;iv_bmissthreshold = 10;		/* override default */</a>
<a name="ln1353">	/* Override with driver methods. */</a>
<a name="ln1354">	ivp-&gt;iv_newstate = vap-&gt;iv_newstate;</a>
<a name="ln1355">	vap-&gt;iv_newstate = iwn_newstate;</a>
<a name="ln1356">	sc-&gt;ivap[IWN_RXON_BSS_CTX] = vap;</a>
<a name="ln1357"> </a>
<a name="ln1358">	ieee80211_ratectl_init(vap);</a>
<a name="ln1359">	/* Complete setup. */</a>
<a name="ln1360">	ieee80211_vap_attach(vap, iwn_media_change, ieee80211_media_status,</a>
<a name="ln1361">	    mac);</a>
<a name="ln1362">	ic-&gt;ic_opmode = opmode;</a>
<a name="ln1363">	return vap;</a>
<a name="ln1364">}</a>
<a name="ln1365"> </a>
<a name="ln1366">static void</a>
<a name="ln1367">iwn_vap_delete(struct ieee80211vap *vap)</a>
<a name="ln1368">{</a>
<a name="ln1369">	struct iwn_vap *ivp = IWN_VAP(vap);</a>
<a name="ln1370"> </a>
<a name="ln1371">	ieee80211_ratectl_deinit(vap);</a>
<a name="ln1372">	ieee80211_vap_detach(vap);</a>
<a name="ln1373">	free(ivp, M_80211_VAP);</a>
<a name="ln1374">}</a>
<a name="ln1375"> </a>
<a name="ln1376">static void</a>
<a name="ln1377">iwn_xmit_queue_drain(struct iwn_softc *sc)</a>
<a name="ln1378">{</a>
<a name="ln1379">	struct mbuf *m;</a>
<a name="ln1380">	struct ieee80211_node *ni;</a>
<a name="ln1381"> </a>
<a name="ln1382">	IWN_LOCK_ASSERT(sc);</a>
<a name="ln1383">	while ((m = mbufq_dequeue(&amp;sc-&gt;sc_xmit_queue)) != NULL) {</a>
<a name="ln1384">		ni = (struct ieee80211_node *)m-&gt;m_pkthdr.rcvif;</a>
<a name="ln1385">		ieee80211_free_node(ni);</a>
<a name="ln1386">		m_freem(m);</a>
<a name="ln1387">	}</a>
<a name="ln1388">}</a>
<a name="ln1389"> </a>
<a name="ln1390">static int</a>
<a name="ln1391">iwn_xmit_queue_enqueue(struct iwn_softc *sc, struct mbuf *m)</a>
<a name="ln1392">{</a>
<a name="ln1393"> </a>
<a name="ln1394">	IWN_LOCK_ASSERT(sc);</a>
<a name="ln1395">	return (mbufq_enqueue(&amp;sc-&gt;sc_xmit_queue, m));</a>
<a name="ln1396">}</a>
<a name="ln1397"> </a>
<a name="ln1398">static int</a>
<a name="ln1399">iwn_detach(device_t dev)</a>
<a name="ln1400">{</a>
<a name="ln1401">	struct iwn_softc *sc = device_get_softc(dev);</a>
<a name="ln1402">	int qid;</a>
<a name="ln1403"> </a>
<a name="ln1404">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln1405"> </a>
<a name="ln1406">	if (sc-&gt;sc_ic.ic_softc != NULL) {</a>
<a name="ln1407">		/* Free the mbuf queue and node references */</a>
<a name="ln1408">		IWN_LOCK(sc);</a>
<a name="ln1409">		iwn_xmit_queue_drain(sc);</a>
<a name="ln1410">		IWN_UNLOCK(sc);</a>
<a name="ln1411"> </a>
<a name="ln1412">		iwn_stop(sc);</a>
<a name="ln1413"> </a>
<a name="ln1414">		taskqueue_drain_all(sc-&gt;sc_tq);</a>
<a name="ln1415">		taskqueue_free(sc-&gt;sc_tq);</a>
<a name="ln1416"> </a>
<a name="ln1417">		callout_drain(&amp;sc-&gt;watchdog_to);</a>
<a name="ln1418">		callout_drain(&amp;sc-&gt;scan_timeout);</a>
<a name="ln1419">		callout_drain(&amp;sc-&gt;calib_to);</a>
<a name="ln1420">		ieee80211_ifdetach(&amp;sc-&gt;sc_ic);</a>
<a name="ln1421">	}</a>
<a name="ln1422"> </a>
<a name="ln1423">	/* Uninstall interrupt handler. */</a>
<a name="ln1424">	if (sc-&gt;irq != NULL) {</a>
<a name="ln1425">		bus_teardown_intr(dev, sc-&gt;irq, sc-&gt;sc_ih);</a>
<a name="ln1426">		bus_release_resource(dev, SYS_RES_IRQ, rman_get_rid(sc-&gt;irq),</a>
<a name="ln1427">		    sc-&gt;irq);</a>
<a name="ln1428">		pci_release_msi(dev);</a>
<a name="ln1429">	}</a>
<a name="ln1430"> </a>
<a name="ln1431">	/* Free DMA resources. */</a>
<a name="ln1432">	iwn_free_rx_ring(sc, &amp;sc-&gt;rxq);</a>
<a name="ln1433">	for (qid = 0; qid &lt; sc-&gt;ntxqs; qid++)</a>
<a name="ln1434">		iwn_free_tx_ring(sc, &amp;sc-&gt;txq[qid]);</a>
<a name="ln1435">	iwn_free_sched(sc);</a>
<a name="ln1436">	iwn_free_kw(sc);</a>
<a name="ln1437">	if (sc-&gt;ict != NULL)</a>
<a name="ln1438">		iwn_free_ict(sc);</a>
<a name="ln1439">	iwn_free_fwmem(sc);</a>
<a name="ln1440"> </a>
<a name="ln1441">	if (sc-&gt;mem != NULL)</a>
<a name="ln1442">		bus_release_resource(dev, SYS_RES_MEMORY,</a>
<a name="ln1443">		    rman_get_rid(sc-&gt;mem), sc-&gt;mem);</a>
<a name="ln1444"> </a>
<a name="ln1445">#ifndef __HAIKU__</a>
<a name="ln1446">	if (sc-&gt;sc_cdev) {</a>
<a name="ln1447">		destroy_dev(sc-&gt;sc_cdev);</a>
<a name="ln1448">		sc-&gt;sc_cdev = NULL;</a>
<a name="ln1449">	}</a>
<a name="ln1450">#endif</a>
<a name="ln1451"> </a>
<a name="ln1452">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: end\n&quot;, __func__);</a>
<a name="ln1453">	IWN_LOCK_DESTROY(sc);</a>
<a name="ln1454">	return 0;</a>
<a name="ln1455">}</a>
<a name="ln1456"> </a>
<a name="ln1457">static int</a>
<a name="ln1458">iwn_shutdown(device_t dev)</a>
<a name="ln1459">{</a>
<a name="ln1460">	struct iwn_softc *sc = device_get_softc(dev);</a>
<a name="ln1461"> </a>
<a name="ln1462">	iwn_stop(sc);</a>
<a name="ln1463">	return 0;</a>
<a name="ln1464">}</a>
<a name="ln1465"> </a>
<a name="ln1466">static int</a>
<a name="ln1467">iwn_suspend(device_t dev)</a>
<a name="ln1468">{</a>
<a name="ln1469">	struct iwn_softc *sc = device_get_softc(dev);</a>
<a name="ln1470"> </a>
<a name="ln1471">	ieee80211_suspend_all(&amp;sc-&gt;sc_ic);</a>
<a name="ln1472">	return 0;</a>
<a name="ln1473">}</a>
<a name="ln1474"> </a>
<a name="ln1475">static int</a>
<a name="ln1476">iwn_resume(device_t dev)</a>
<a name="ln1477">{</a>
<a name="ln1478">	struct iwn_softc *sc = device_get_softc(dev);</a>
<a name="ln1479"> </a>
<a name="ln1480">	/* Clear device-specific &quot;PCI retry timeout&quot; register (41h). */</a>
<a name="ln1481">	pci_write_config(dev, 0x41, 0, 1);</a>
<a name="ln1482"> </a>
<a name="ln1483">	ieee80211_resume_all(&amp;sc-&gt;sc_ic);</a>
<a name="ln1484">	return 0;</a>
<a name="ln1485">}</a>
<a name="ln1486"> </a>
<a name="ln1487">static int</a>
<a name="ln1488">iwn_nic_lock(struct iwn_softc *sc)</a>
<a name="ln1489">{</a>
<a name="ln1490">	int ntries;</a>
<a name="ln1491"> </a>
<a name="ln1492">	/* Request exclusive access to NIC. */</a>
<a name="ln1493">	IWN_SETBITS(sc, IWN_GP_CNTRL, IWN_GP_CNTRL_MAC_ACCESS_REQ);</a>
<a name="ln1494"> </a>
<a name="ln1495">	/* Spin until we actually get the lock. */</a>
<a name="ln1496">	for (ntries = 0; ntries &lt; 1000; ntries++) {</a>
<a name="ln1497">		if ((IWN_READ(sc, IWN_GP_CNTRL) &amp;</a>
<a name="ln1498">		     (IWN_GP_CNTRL_MAC_ACCESS_ENA | IWN_GP_CNTRL_SLEEP)) ==</a>
<a name="ln1499">		    IWN_GP_CNTRL_MAC_ACCESS_ENA)</a>
<a name="ln1500">			return 0;</a>
<a name="ln1501">		DELAY(10);</a>
<a name="ln1502">	}</a>
<a name="ln1503">	return ETIMEDOUT;</a>
<a name="ln1504">}</a>
<a name="ln1505"> </a>
<a name="ln1506">static __inline void</a>
<a name="ln1507">iwn_nic_unlock(struct iwn_softc *sc)</a>
<a name="ln1508">{</a>
<a name="ln1509">	IWN_CLRBITS(sc, IWN_GP_CNTRL, IWN_GP_CNTRL_MAC_ACCESS_REQ);</a>
<a name="ln1510">}</a>
<a name="ln1511"> </a>
<a name="ln1512">static __inline uint32_t</a>
<a name="ln1513">iwn_prph_read(struct iwn_softc *sc, uint32_t addr)</a>
<a name="ln1514">{</a>
<a name="ln1515">	IWN_WRITE(sc, IWN_PRPH_RADDR, IWN_PRPH_DWORD | addr);</a>
<a name="ln1516">	IWN_BARRIER_READ_WRITE(sc);</a>
<a name="ln1517">	return IWN_READ(sc, IWN_PRPH_RDATA);</a>
<a name="ln1518">}</a>
<a name="ln1519"> </a>
<a name="ln1520">static __inline void</a>
<a name="ln1521">iwn_prph_write(struct iwn_softc *sc, uint32_t addr, uint32_t data)</a>
<a name="ln1522">{</a>
<a name="ln1523">	IWN_WRITE(sc, IWN_PRPH_WADDR, IWN_PRPH_DWORD | addr);</a>
<a name="ln1524">	IWN_BARRIER_WRITE(sc);</a>
<a name="ln1525">	IWN_WRITE(sc, IWN_PRPH_WDATA, data);</a>
<a name="ln1526">}</a>
<a name="ln1527"> </a>
<a name="ln1528">static __inline void</a>
<a name="ln1529">iwn_prph_setbits(struct iwn_softc *sc, uint32_t addr, uint32_t mask)</a>
<a name="ln1530">{</a>
<a name="ln1531">	iwn_prph_write(sc, addr, iwn_prph_read(sc, addr) | mask);</a>
<a name="ln1532">}</a>
<a name="ln1533"> </a>
<a name="ln1534">static __inline void</a>
<a name="ln1535">iwn_prph_clrbits(struct iwn_softc *sc, uint32_t addr, uint32_t mask)</a>
<a name="ln1536">{</a>
<a name="ln1537">	iwn_prph_write(sc, addr, iwn_prph_read(sc, addr) &amp; ~mask);</a>
<a name="ln1538">}</a>
<a name="ln1539"> </a>
<a name="ln1540">static __inline void</a>
<a name="ln1541">iwn_prph_write_region_4(struct iwn_softc *sc, uint32_t addr,</a>
<a name="ln1542">    const uint32_t *data, int count)</a>
<a name="ln1543">{</a>
<a name="ln1544">	for (; count &gt; 0; count--, data++, addr += 4)</a>
<a name="ln1545">		iwn_prph_write(sc, addr, *data);</a>
<a name="ln1546">}</a>
<a name="ln1547"> </a>
<a name="ln1548">static __inline uint32_t</a>
<a name="ln1549">iwn_mem_read(struct iwn_softc *sc, uint32_t addr)</a>
<a name="ln1550">{</a>
<a name="ln1551">	IWN_WRITE(sc, IWN_MEM_RADDR, addr);</a>
<a name="ln1552">	IWN_BARRIER_READ_WRITE(sc);</a>
<a name="ln1553">	return IWN_READ(sc, IWN_MEM_RDATA);</a>
<a name="ln1554">}</a>
<a name="ln1555"> </a>
<a name="ln1556">static __inline void</a>
<a name="ln1557">iwn_mem_write(struct iwn_softc *sc, uint32_t addr, uint32_t data)</a>
<a name="ln1558">{</a>
<a name="ln1559">	IWN_WRITE(sc, IWN_MEM_WADDR, addr);</a>
<a name="ln1560">	IWN_BARRIER_WRITE(sc);</a>
<a name="ln1561">	IWN_WRITE(sc, IWN_MEM_WDATA, data);</a>
<a name="ln1562">}</a>
<a name="ln1563"> </a>
<a name="ln1564">static __inline void</a>
<a name="ln1565">iwn_mem_write_2(struct iwn_softc *sc, uint32_t addr, uint16_t data)</a>
<a name="ln1566">{</a>
<a name="ln1567">	uint32_t tmp;</a>
<a name="ln1568"> </a>
<a name="ln1569">	tmp = iwn_mem_read(sc, addr &amp; ~3);</a>
<a name="ln1570">	if (addr &amp; 3)</a>
<a name="ln1571">		tmp = (tmp &amp; 0x0000ffff) | data &lt;&lt; 16;</a>
<a name="ln1572">	else</a>
<a name="ln1573">		tmp = (tmp &amp; 0xffff0000) | data;</a>
<a name="ln1574">	iwn_mem_write(sc, addr &amp; ~3, tmp);</a>
<a name="ln1575">}</a>
<a name="ln1576"> </a>
<a name="ln1577">static __inline void</a>
<a name="ln1578">iwn_mem_read_region_4(struct iwn_softc *sc, uint32_t addr, uint32_t *data,</a>
<a name="ln1579">    int count)</a>
<a name="ln1580">{</a>
<a name="ln1581">	for (; count &gt; 0; count--, addr += 4)</a>
<a name="ln1582">		*data++ = iwn_mem_read(sc, addr);</a>
<a name="ln1583">}</a>
<a name="ln1584"> </a>
<a name="ln1585">static __inline void</a>
<a name="ln1586">iwn_mem_set_region_4(struct iwn_softc *sc, uint32_t addr, uint32_t val,</a>
<a name="ln1587">    int count)</a>
<a name="ln1588">{</a>
<a name="ln1589">	for (; count &gt; 0; count--, addr += 4)</a>
<a name="ln1590">		iwn_mem_write(sc, addr, val);</a>
<a name="ln1591">}</a>
<a name="ln1592"> </a>
<a name="ln1593">static int</a>
<a name="ln1594">iwn_eeprom_lock(struct iwn_softc *sc)</a>
<a name="ln1595">{</a>
<a name="ln1596">	int i, ntries;</a>
<a name="ln1597"> </a>
<a name="ln1598">	for (i = 0; i &lt; 100; i++) {</a>
<a name="ln1599">		/* Request exclusive access to EEPROM. */</a>
<a name="ln1600">		IWN_SETBITS(sc, IWN_HW_IF_CONFIG,</a>
<a name="ln1601">		    IWN_HW_IF_CONFIG_EEPROM_LOCKED);</a>
<a name="ln1602"> </a>
<a name="ln1603">		/* Spin until we actually get the lock. */</a>
<a name="ln1604">		for (ntries = 0; ntries &lt; 100; ntries++) {</a>
<a name="ln1605">			if (IWN_READ(sc, IWN_HW_IF_CONFIG) &amp;</a>
<a name="ln1606">			    IWN_HW_IF_CONFIG_EEPROM_LOCKED)</a>
<a name="ln1607">				return 0;</a>
<a name="ln1608">			DELAY(10);</a>
<a name="ln1609">		}</a>
<a name="ln1610">	}</a>
<a name="ln1611">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s end timeout\n&quot;, __func__);</a>
<a name="ln1612">	return ETIMEDOUT;</a>
<a name="ln1613">}</a>
<a name="ln1614"> </a>
<a name="ln1615">static __inline void</a>
<a name="ln1616">iwn_eeprom_unlock(struct iwn_softc *sc)</a>
<a name="ln1617">{</a>
<a name="ln1618">	IWN_CLRBITS(sc, IWN_HW_IF_CONFIG, IWN_HW_IF_CONFIG_EEPROM_LOCKED);</a>
<a name="ln1619">}</a>
<a name="ln1620"> </a>
<a name="ln1621">/*</a>
<a name="ln1622"> * Initialize access by host to One Time Programmable ROM.</a>
<a name="ln1623"> * NB: This kind of ROM can be found on 1000 or 6000 Series only.</a>
<a name="ln1624"> */</a>
<a name="ln1625">static int</a>
<a name="ln1626">iwn_init_otprom(struct iwn_softc *sc)</a>
<a name="ln1627">{</a>
<a name="ln1628">	uint16_t prev, base, next;</a>
<a name="ln1629">	int count, error;</a>
<a name="ln1630"> </a>
<a name="ln1631">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln1632"> </a>
<a name="ln1633">	/* Wait for clock stabilization before accessing prph. */</a>
<a name="ln1634">	if ((error = iwn_clock_wait(sc)) != 0)</a>
<a name="ln1635">		return error;</a>
<a name="ln1636"> </a>
<a name="ln1637">	if ((error = iwn_nic_lock(sc)) != 0)</a>
<a name="ln1638">		return error;</a>
<a name="ln1639">	iwn_prph_setbits(sc, IWN_APMG_PS, IWN_APMG_PS_RESET_REQ);</a>
<a name="ln1640">	DELAY(5);</a>
<a name="ln1641">	iwn_prph_clrbits(sc, IWN_APMG_PS, IWN_APMG_PS_RESET_REQ);</a>
<a name="ln1642">	iwn_nic_unlock(sc);</a>
<a name="ln1643"> </a>
<a name="ln1644">	/* Set auto clock gate disable bit for HW with OTP shadow RAM. */</a>
<a name="ln1645">	if (sc-&gt;base_params-&gt;shadow_ram_support) {</a>
<a name="ln1646">		IWN_SETBITS(sc, IWN_DBG_LINK_PWR_MGMT,</a>
<a name="ln1647">		    IWN_RESET_LINK_PWR_MGMT_DIS);</a>
<a name="ln1648">	}</a>
<a name="ln1649">	IWN_CLRBITS(sc, IWN_EEPROM_GP, IWN_EEPROM_GP_IF_OWNER);</a>
<a name="ln1650">	/* Clear ECC status. */</a>
<a name="ln1651">	IWN_SETBITS(sc, IWN_OTP_GP,</a>
<a name="ln1652">	    IWN_OTP_GP_ECC_CORR_STTS | IWN_OTP_GP_ECC_UNCORR_STTS);</a>
<a name="ln1653"> </a>
<a name="ln1654">	/*</a>
<a name="ln1655">	 * Find the block before last block (contains the EEPROM image)</a>
<a name="ln1656">	 * for HW without OTP shadow RAM.</a>
<a name="ln1657">	 */</a>
<a name="ln1658">	if (! sc-&gt;base_params-&gt;shadow_ram_support) {</a>
<a name="ln1659">		/* Switch to absolute addressing mode. */</a>
<a name="ln1660">		IWN_CLRBITS(sc, IWN_OTP_GP, IWN_OTP_GP_RELATIVE_ACCESS);</a>
<a name="ln1661">		base = prev = 0;</a>
<a name="ln1662">		for (count = 0; count &lt; sc-&gt;base_params-&gt;max_ll_items;</a>
<a name="ln1663">		    count++) {</a>
<a name="ln1664">			error = iwn_read_prom_data(sc, base, &amp;next, 2);</a>
<a name="ln1665">			if (error != 0)</a>
<a name="ln1666">				return error;</a>
<a name="ln1667">			if (next == 0)	/* End of linked-list. */</a>
<a name="ln1668">				break;</a>
<a name="ln1669">			prev = base;</a>
<a name="ln1670">			base = le16toh(next);</a>
<a name="ln1671">		}</a>
<a name="ln1672">		if (count == 0 || count == sc-&gt;base_params-&gt;max_ll_items)</a>
<a name="ln1673">			return EIO;</a>
<a name="ln1674">		/* Skip &quot;next&quot; word. */</a>
<a name="ln1675">		sc-&gt;prom_base = prev + 1;</a>
<a name="ln1676">	}</a>
<a name="ln1677"> </a>
<a name="ln1678">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s end\n&quot;, __func__);</a>
<a name="ln1679"> </a>
<a name="ln1680">	return 0;</a>
<a name="ln1681">}</a>
<a name="ln1682"> </a>
<a name="ln1683">static int</a>
<a name="ln1684">iwn_read_prom_data(struct iwn_softc *sc, uint32_t addr, void *data, int count)</a>
<a name="ln1685">{</a>
<a name="ln1686">	uint8_t *out = data;</a>
<a name="ln1687">	uint32_t val, tmp;</a>
<a name="ln1688">	int ntries;</a>
<a name="ln1689"> </a>
<a name="ln1690">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln1691"> </a>
<a name="ln1692">	addr += sc-&gt;prom_base;</a>
<a name="ln1693">	for (; count &gt; 0; count -= 2, addr++) {</a>
<a name="ln1694">		IWN_WRITE(sc, IWN_EEPROM, addr &lt;&lt; 2);</a>
<a name="ln1695">		for (ntries = 0; ntries &lt; 10; ntries++) {</a>
<a name="ln1696">			val = IWN_READ(sc, IWN_EEPROM);</a>
<a name="ln1697">			if (val &amp; IWN_EEPROM_READ_VALID)</a>
<a name="ln1698">				break;</a>
<a name="ln1699">			DELAY(5);</a>
<a name="ln1700">		}</a>
<a name="ln1701">		if (ntries == 10) {</a>
<a name="ln1702">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1703">			    &quot;timeout reading ROM at 0x%x\n&quot;, addr);</a>
<a name="ln1704">			return ETIMEDOUT;</a>
<a name="ln1705">		}</a>
<a name="ln1706">		if (sc-&gt;sc_flags &amp; IWN_FLAG_HAS_OTPROM) {</a>
<a name="ln1707">			/* OTPROM, check for ECC errors. */</a>
<a name="ln1708">			tmp = IWN_READ(sc, IWN_OTP_GP);</a>
<a name="ln1709">			if (tmp &amp; IWN_OTP_GP_ECC_UNCORR_STTS) {</a>
<a name="ln1710">				device_printf(sc-&gt;sc_dev,</a>
<a name="ln1711">				    &quot;OTPROM ECC error at 0x%x\n&quot;, addr);</a>
<a name="ln1712">				return EIO;</a>
<a name="ln1713">			}</a>
<a name="ln1714">			if (tmp &amp; IWN_OTP_GP_ECC_CORR_STTS) {</a>
<a name="ln1715">				/* Correctable ECC error, clear bit. */</a>
<a name="ln1716">				IWN_SETBITS(sc, IWN_OTP_GP,</a>
<a name="ln1717">				    IWN_OTP_GP_ECC_CORR_STTS);</a>
<a name="ln1718">			}</a>
<a name="ln1719">		}</a>
<a name="ln1720">		*out++ = val &gt;&gt; 16;</a>
<a name="ln1721">		if (count &gt; 1)</a>
<a name="ln1722">			*out++ = val &gt;&gt; 24;</a>
<a name="ln1723">	}</a>
<a name="ln1724"> </a>
<a name="ln1725">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s end\n&quot;, __func__);</a>
<a name="ln1726"> </a>
<a name="ln1727">	return 0;</a>
<a name="ln1728">}</a>
<a name="ln1729"> </a>
<a name="ln1730">static void</a>
<a name="ln1731">iwn_dma_map_addr(void *arg, bus_dma_segment_t *segs, int nsegs, int error)</a>
<a name="ln1732">{</a>
<a name="ln1733">	if (error != 0)</a>
<a name="ln1734">		return;</a>
<a name="ln1735">	KASSERT(nsegs == 1, (&quot;too many DMA segments, %d should be 1&quot;, nsegs));</a>
<a name="ln1736">	*(bus_addr_t *)arg = segs[0].ds_addr;</a>
<a name="ln1737">}</a>
<a name="ln1738"> </a>
<a name="ln1739">static int</a>
<a name="ln1740">iwn_dma_contig_alloc(struct iwn_softc *sc, struct iwn_dma_info *dma,</a>
<a name="ln1741">    void **kvap, bus_size_t size, bus_size_t alignment)</a>
<a name="ln1742">{</a>
<a name="ln1743">	int error;</a>
<a name="ln1744"> </a>
<a name="ln1745">	dma-&gt;tag = NULL;</a>
<a name="ln1746">	dma-&gt;size = size;</a>
<a name="ln1747"> </a>
<a name="ln1748">	error = bus_dma_tag_create(bus_get_dma_tag(sc-&gt;sc_dev), alignment,</a>
<a name="ln1749">	    0, BUS_SPACE_MAXADDR_32BIT, BUS_SPACE_MAXADDR, NULL, NULL, size,</a>
<a name="ln1750">	    1, size, 0, NULL, NULL, &amp;dma-&gt;tag);</a>
<a name="ln1751">	if (error != 0)</a>
<a name="ln1752">		goto fail;</a>
<a name="ln1753"> </a>
<a name="ln1754">	error = bus_dmamem_alloc(dma-&gt;tag, (void **)&amp;dma-&gt;vaddr,</a>
<a name="ln1755">	    BUS_DMA_NOWAIT | BUS_DMA_ZERO | BUS_DMA_COHERENT, &amp;dma-&gt;map);</a>
<a name="ln1756">	if (error != 0)</a>
<a name="ln1757">		goto fail;</a>
<a name="ln1758"> </a>
<a name="ln1759">	error = bus_dmamap_load(dma-&gt;tag, dma-&gt;map, dma-&gt;vaddr, size,</a>
<a name="ln1760">	    iwn_dma_map_addr, &amp;dma-&gt;paddr, BUS_DMA_NOWAIT);</a>
<a name="ln1761">	if (error != 0)</a>
<a name="ln1762">		goto fail;</a>
<a name="ln1763"> </a>
<a name="ln1764">	bus_dmamap_sync(dma-&gt;tag, dma-&gt;map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln1765"> </a>
<a name="ln1766">	if (kvap != NULL)</a>
<a name="ln1767">		*kvap = dma-&gt;vaddr;</a>
<a name="ln1768"> </a>
<a name="ln1769">	return 0;</a>
<a name="ln1770"> </a>
<a name="ln1771">fail:	iwn_dma_contig_free(dma);</a>
<a name="ln1772">	return error;</a>
<a name="ln1773">}</a>
<a name="ln1774"> </a>
<a name="ln1775">static void</a>
<a name="ln1776">iwn_dma_contig_free(struct iwn_dma_info *dma)</a>
<a name="ln1777">{</a>
<a name="ln1778">	if (dma-&gt;vaddr != NULL) {</a>
<a name="ln1779">		bus_dmamap_sync(dma-&gt;tag, dma-&gt;map,</a>
<a name="ln1780">		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);</a>
<a name="ln1781">		bus_dmamap_unload(dma-&gt;tag, dma-&gt;map);</a>
<a name="ln1782">		bus_dmamem_free(dma-&gt;tag, dma-&gt;vaddr, dma-&gt;map);</a>
<a name="ln1783">		dma-&gt;vaddr = NULL;</a>
<a name="ln1784">	}</a>
<a name="ln1785">	if (dma-&gt;tag != NULL) {</a>
<a name="ln1786">		bus_dma_tag_destroy(dma-&gt;tag);</a>
<a name="ln1787">		dma-&gt;tag = NULL;</a>
<a name="ln1788">	}</a>
<a name="ln1789">}</a>
<a name="ln1790"> </a>
<a name="ln1791">static int</a>
<a name="ln1792">iwn_alloc_sched(struct iwn_softc *sc)</a>
<a name="ln1793">{</a>
<a name="ln1794">	/* TX scheduler rings must be aligned on a 1KB boundary. */</a>
<a name="ln1795">	return iwn_dma_contig_alloc(sc, &amp;sc-&gt;sched_dma, (void **)&amp;sc-&gt;sched,</a>
<a name="ln1796">	    sc-&gt;schedsz, 1024);</a>
<a name="ln1797">}</a>
<a name="ln1798"> </a>
<a name="ln1799">static void</a>
<a name="ln1800">iwn_free_sched(struct iwn_softc *sc)</a>
<a name="ln1801">{</a>
<a name="ln1802">	iwn_dma_contig_free(&amp;sc-&gt;sched_dma);</a>
<a name="ln1803">}</a>
<a name="ln1804"> </a>
<a name="ln1805">static int</a>
<a name="ln1806">iwn_alloc_kw(struct iwn_softc *sc)</a>
<a name="ln1807">{</a>
<a name="ln1808">	/* &quot;Keep Warm&quot; page must be aligned on a 4KB boundary. */</a>
<a name="ln1809">	return iwn_dma_contig_alloc(sc, &amp;sc-&gt;kw_dma, NULL, 4096, 4096);</a>
<a name="ln1810">}</a>
<a name="ln1811"> </a>
<a name="ln1812">static void</a>
<a name="ln1813">iwn_free_kw(struct iwn_softc *sc)</a>
<a name="ln1814">{</a>
<a name="ln1815">	iwn_dma_contig_free(&amp;sc-&gt;kw_dma);</a>
<a name="ln1816">}</a>
<a name="ln1817"> </a>
<a name="ln1818">static int</a>
<a name="ln1819">iwn_alloc_ict(struct iwn_softc *sc)</a>
<a name="ln1820">{</a>
<a name="ln1821">	/* ICT table must be aligned on a 4KB boundary. */</a>
<a name="ln1822">	return iwn_dma_contig_alloc(sc, &amp;sc-&gt;ict_dma, (void **)&amp;sc-&gt;ict,</a>
<a name="ln1823">	    IWN_ICT_SIZE, 4096);</a>
<a name="ln1824">}</a>
<a name="ln1825"> </a>
<a name="ln1826">static void</a>
<a name="ln1827">iwn_free_ict(struct iwn_softc *sc)</a>
<a name="ln1828">{</a>
<a name="ln1829">	iwn_dma_contig_free(&amp;sc-&gt;ict_dma);</a>
<a name="ln1830">}</a>
<a name="ln1831"> </a>
<a name="ln1832">static int</a>
<a name="ln1833">iwn_alloc_fwmem(struct iwn_softc *sc)</a>
<a name="ln1834">{</a>
<a name="ln1835">	/* Must be aligned on a 16-byte boundary. */</a>
<a name="ln1836">	return iwn_dma_contig_alloc(sc, &amp;sc-&gt;fw_dma, NULL, sc-&gt;fwsz, 16);</a>
<a name="ln1837">}</a>
<a name="ln1838"> </a>
<a name="ln1839">static void</a>
<a name="ln1840">iwn_free_fwmem(struct iwn_softc *sc)</a>
<a name="ln1841">{</a>
<a name="ln1842">	iwn_dma_contig_free(&amp;sc-&gt;fw_dma);</a>
<a name="ln1843">}</a>
<a name="ln1844"> </a>
<a name="ln1845">static int</a>
<a name="ln1846">iwn_alloc_rx_ring(struct iwn_softc *sc, struct iwn_rx_ring *ring)</a>
<a name="ln1847">{</a>
<a name="ln1848">	bus_size_t size;</a>
<a name="ln1849">	int i, error;</a>
<a name="ln1850"> </a>
<a name="ln1851">	ring-&gt;cur = 0;</a>
<a name="ln1852"> </a>
<a name="ln1853">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln1854"> </a>
<a name="ln1855">	/* Allocate RX descriptors (256-byte aligned). */</a>
<a name="ln1856">	size = IWN_RX_RING_COUNT * sizeof (uint32_t);</a>
<a name="ln1857">	error = iwn_dma_contig_alloc(sc, &amp;ring-&gt;desc_dma, (void **)&amp;ring-&gt;desc,</a>
<a name="ln1858">	    size, 256);</a>
<a name="ln1859">	if (error != 0) {</a>
<a name="ln1860">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln1861">		    &quot;%s: could not allocate RX ring DMA memory, error %d\n&quot;,</a>
<a name="ln1862">		    __func__, error);</a>
<a name="ln1863">		goto fail;</a>
<a name="ln1864">	}</a>
<a name="ln1865"> </a>
<a name="ln1866">	/* Allocate RX status area (16-byte aligned). */</a>
<a name="ln1867">	error = iwn_dma_contig_alloc(sc, &amp;ring-&gt;stat_dma, (void **)&amp;ring-&gt;stat,</a>
<a name="ln1868">	    sizeof (struct iwn_rx_status), 16);</a>
<a name="ln1869">	if (error != 0) {</a>
<a name="ln1870">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln1871">		    &quot;%s: could not allocate RX status DMA memory, error %d\n&quot;,</a>
<a name="ln1872">		    __func__, error);</a>
<a name="ln1873">		goto fail;</a>
<a name="ln1874">	}</a>
<a name="ln1875"> </a>
<a name="ln1876">	/* Create RX buffer DMA tag. */</a>
<a name="ln1877">	error = bus_dma_tag_create(bus_get_dma_tag(sc-&gt;sc_dev), 1, 0,</a>
<a name="ln1878">	    BUS_SPACE_MAXADDR_32BIT, BUS_SPACE_MAXADDR, NULL, NULL,</a>
<a name="ln1879">	    IWN_RBUF_SIZE, 1, IWN_RBUF_SIZE, 0, NULL, NULL, &amp;ring-&gt;data_dmat);</a>
<a name="ln1880">	if (error != 0) {</a>
<a name="ln1881">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln1882">		    &quot;%s: could not create RX buf DMA tag, error %d\n&quot;,</a>
<a name="ln1883">		    __func__, error);</a>
<a name="ln1884">		goto fail;</a>
<a name="ln1885">	}</a>
<a name="ln1886"> </a>
<a name="ln1887">	/*</a>
<a name="ln1888">	 * Allocate and map RX buffers.</a>
<a name="ln1889">	 */</a>
<a name="ln1890">	for (i = 0; i &lt; IWN_RX_RING_COUNT; i++) {</a>
<a name="ln1891">		struct iwn_rx_data *data = &amp;ring-&gt;data[i];</a>
<a name="ln1892">		bus_addr_t paddr;</a>
<a name="ln1893"> </a>
<a name="ln1894">		error = bus_dmamap_create(ring-&gt;data_dmat, 0, &amp;data-&gt;map);</a>
<a name="ln1895">		if (error != 0) {</a>
<a name="ln1896">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1897">			    &quot;%s: could not create RX buf DMA map, error %d\n&quot;,</a>
<a name="ln1898">			    __func__, error);</a>
<a name="ln1899">			goto fail;</a>
<a name="ln1900">		}</a>
<a name="ln1901"> </a>
<a name="ln1902">		data-&gt;m = m_getjcl(M_NOWAIT, MT_DATA, M_PKTHDR,</a>
<a name="ln1903">		    IWN_RBUF_SIZE);</a>
<a name="ln1904">		if (data-&gt;m == NULL) {</a>
<a name="ln1905">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1906">			    &quot;%s: could not allocate RX mbuf\n&quot;, __func__);</a>
<a name="ln1907">			error = ENOBUFS;</a>
<a name="ln1908">			goto fail;</a>
<a name="ln1909">		}</a>
<a name="ln1910"> </a>
<a name="ln1911">		error = bus_dmamap_load(ring-&gt;data_dmat, data-&gt;map,</a>
<a name="ln1912">		    mtod(data-&gt;m, void *), IWN_RBUF_SIZE, iwn_dma_map_addr,</a>
<a name="ln1913">		    &amp;paddr, BUS_DMA_NOWAIT);</a>
<a name="ln1914">		if (error != 0 &amp;&amp; error != EFBIG) {</a>
<a name="ln1915">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1916">			    &quot;%s: can't map mbuf, error %d\n&quot;, __func__,</a>
<a name="ln1917">			    error);</a>
<a name="ln1918">			goto fail;</a>
<a name="ln1919">		}</a>
<a name="ln1920"> </a>
<a name="ln1921">		bus_dmamap_sync(ring-&gt;data_dmat, data-&gt;map,</a>
<a name="ln1922">		    BUS_DMASYNC_PREREAD);</a>
<a name="ln1923"> </a>
<a name="ln1924">		/* Set physical address of RX buffer (256-byte aligned). */</a>
<a name="ln1925">		ring-&gt;desc[i] = htole32(paddr &gt;&gt; 8);</a>
<a name="ln1926">	}</a>
<a name="ln1927"> </a>
<a name="ln1928">	bus_dmamap_sync(ring-&gt;desc_dma.tag, ring-&gt;desc_dma.map,</a>
<a name="ln1929">	    BUS_DMASYNC_PREWRITE);</a>
<a name="ln1930"> </a>
<a name="ln1931">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: end\n&quot;,__func__);</a>
<a name="ln1932"> </a>
<a name="ln1933">	return 0;</a>
<a name="ln1934"> </a>
<a name="ln1935">fail:	iwn_free_rx_ring(sc, ring);</a>
<a name="ln1936"> </a>
<a name="ln1937">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: end in error\n&quot;,__func__);</a>
<a name="ln1938"> </a>
<a name="ln1939">	return error;</a>
<a name="ln1940">}</a>
<a name="ln1941"> </a>
<a name="ln1942">static void</a>
<a name="ln1943">iwn_reset_rx_ring(struct iwn_softc *sc, struct iwn_rx_ring *ring)</a>
<a name="ln1944">{</a>
<a name="ln1945">	int ntries;</a>
<a name="ln1946"> </a>
<a name="ln1947">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln1948"> </a>
<a name="ln1949">	if (iwn_nic_lock(sc) == 0) {</a>
<a name="ln1950">		IWN_WRITE(sc, IWN_FH_RX_CONFIG, 0);</a>
<a name="ln1951">		for (ntries = 0; ntries &lt; 1000; ntries++) {</a>
<a name="ln1952">			if (IWN_READ(sc, IWN_FH_RX_STATUS) &amp;</a>
<a name="ln1953">			    IWN_FH_RX_STATUS_IDLE)</a>
<a name="ln1954">				break;</a>
<a name="ln1955">			DELAY(10);</a>
<a name="ln1956">		}</a>
<a name="ln1957">		iwn_nic_unlock(sc);</a>
<a name="ln1958">	}</a>
<a name="ln1959">	ring-&gt;cur = 0;</a>
<a name="ln1960">	sc-&gt;last_rx_valid = 0;</a>
<a name="ln1961">}</a>
<a name="ln1962"> </a>
<a name="ln1963">static void</a>
<a name="ln1964">iwn_free_rx_ring(struct iwn_softc *sc, struct iwn_rx_ring *ring)</a>
<a name="ln1965">{</a>
<a name="ln1966">	int i;</a>
<a name="ln1967"> </a>
<a name="ln1968">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s \n&quot;, __func__);</a>
<a name="ln1969"> </a>
<a name="ln1970">	iwn_dma_contig_free(&amp;ring-&gt;desc_dma);</a>
<a name="ln1971">	iwn_dma_contig_free(&amp;ring-&gt;stat_dma);</a>
<a name="ln1972"> </a>
<a name="ln1973">	for (i = 0; i &lt; IWN_RX_RING_COUNT; i++) {</a>
<a name="ln1974">		struct iwn_rx_data *data = &amp;ring-&gt;data[i];</a>
<a name="ln1975"> </a>
<a name="ln1976">		if (data-&gt;m != NULL) {</a>
<a name="ln1977">			bus_dmamap_sync(ring-&gt;data_dmat, data-&gt;map,</a>
<a name="ln1978">			    BUS_DMASYNC_POSTREAD);</a>
<a name="ln1979">			bus_dmamap_unload(ring-&gt;data_dmat, data-&gt;map);</a>
<a name="ln1980">			m_freem(data-&gt;m);</a>
<a name="ln1981">			data-&gt;m = NULL;</a>
<a name="ln1982">		}</a>
<a name="ln1983">		if (data-&gt;map != NULL)</a>
<a name="ln1984">			bus_dmamap_destroy(ring-&gt;data_dmat, data-&gt;map);</a>
<a name="ln1985">	}</a>
<a name="ln1986">	if (ring-&gt;data_dmat != NULL) {</a>
<a name="ln1987">		bus_dma_tag_destroy(ring-&gt;data_dmat);</a>
<a name="ln1988">		ring-&gt;data_dmat = NULL;</a>
<a name="ln1989">	}</a>
<a name="ln1990">}</a>
<a name="ln1991"> </a>
<a name="ln1992">static int</a>
<a name="ln1993">iwn_alloc_tx_ring(struct iwn_softc *sc, struct iwn_tx_ring *ring, int qid)</a>
<a name="ln1994">{</a>
<a name="ln1995">	bus_addr_t paddr;</a>
<a name="ln1996">	bus_size_t size;</a>
<a name="ln1997">	int i, error;</a>
<a name="ln1998"> </a>
<a name="ln1999">	ring-&gt;qid = qid;</a>
<a name="ln2000">	ring-&gt;queued = 0;</a>
<a name="ln2001">	ring-&gt;cur = 0;</a>
<a name="ln2002"> </a>
<a name="ln2003">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln2004"> </a>
<a name="ln2005">	/* Allocate TX descriptors (256-byte aligned). */</a>
<a name="ln2006">	size = IWN_TX_RING_COUNT * sizeof (struct iwn_tx_desc);</a>
<a name="ln2007">	error = iwn_dma_contig_alloc(sc, &amp;ring-&gt;desc_dma, (void **)&amp;ring-&gt;desc,</a>
<a name="ln2008">	    size, 256);</a>
<a name="ln2009">	if (error != 0) {</a>
<a name="ln2010">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln2011">		    &quot;%s: could not allocate TX ring DMA memory, error %d\n&quot;,</a>
<a name="ln2012">		    __func__, error);</a>
<a name="ln2013">		goto fail;</a>
<a name="ln2014">	}</a>
<a name="ln2015"> </a>
<a name="ln2016">	size = IWN_TX_RING_COUNT * sizeof (struct iwn_tx_cmd);</a>
<a name="ln2017">	error = iwn_dma_contig_alloc(sc, &amp;ring-&gt;cmd_dma, (void **)&amp;ring-&gt;cmd,</a>
<a name="ln2018">	    size, 4);</a>
<a name="ln2019">	if (error != 0) {</a>
<a name="ln2020">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln2021">		    &quot;%s: could not allocate TX cmd DMA memory, error %d\n&quot;,</a>
<a name="ln2022">		    __func__, error);</a>
<a name="ln2023">		goto fail;</a>
<a name="ln2024">	}</a>
<a name="ln2025"> </a>
<a name="ln2026">	error = bus_dma_tag_create(bus_get_dma_tag(sc-&gt;sc_dev), 1, 0,</a>
<a name="ln2027">	    BUS_SPACE_MAXADDR_32BIT, BUS_SPACE_MAXADDR, NULL, NULL, MCLBYTES,</a>
<a name="ln2028">	    IWN_MAX_SCATTER - 1, MCLBYTES, 0, NULL, NULL, &amp;ring-&gt;data_dmat);</a>
<a name="ln2029">	if (error != 0) {</a>
<a name="ln2030">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln2031">		    &quot;%s: could not create TX buf DMA tag, error %d\n&quot;,</a>
<a name="ln2032">		    __func__, error);</a>
<a name="ln2033">		goto fail;</a>
<a name="ln2034">	}</a>
<a name="ln2035"> </a>
<a name="ln2036">	paddr = ring-&gt;cmd_dma.paddr;</a>
<a name="ln2037">	for (i = 0; i &lt; IWN_TX_RING_COUNT; i++) {</a>
<a name="ln2038">		struct iwn_tx_data *data = &amp;ring-&gt;data[i];</a>
<a name="ln2039"> </a>
<a name="ln2040">		data-&gt;cmd_paddr = paddr;</a>
<a name="ln2041">		data-&gt;scratch_paddr = paddr + 12;</a>
<a name="ln2042">		paddr += sizeof (struct iwn_tx_cmd);</a>
<a name="ln2043"> </a>
<a name="ln2044">		error = bus_dmamap_create(ring-&gt;data_dmat, 0, &amp;data-&gt;map);</a>
<a name="ln2045">		if (error != 0) {</a>
<a name="ln2046">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln2047">			    &quot;%s: could not create TX buf DMA map, error %d\n&quot;,</a>
<a name="ln2048">			    __func__, error);</a>
<a name="ln2049">			goto fail;</a>
<a name="ln2050">		}</a>
<a name="ln2051">	}</a>
<a name="ln2052"> </a>
<a name="ln2053">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s end\n&quot;, __func__);</a>
<a name="ln2054"> </a>
<a name="ln2055">	return 0;</a>
<a name="ln2056"> </a>
<a name="ln2057">fail:	iwn_free_tx_ring(sc, ring);</a>
<a name="ln2058">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s end in error\n&quot;, __func__);</a>
<a name="ln2059">	return error;</a>
<a name="ln2060">}</a>
<a name="ln2061"> </a>
<a name="ln2062">static void</a>
<a name="ln2063">iwn_reset_tx_ring(struct iwn_softc *sc, struct iwn_tx_ring *ring)</a>
<a name="ln2064">{</a>
<a name="ln2065">	int i;</a>
<a name="ln2066"> </a>
<a name="ln2067">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;doing %s \n&quot;, __func__);</a>
<a name="ln2068"> </a>
<a name="ln2069">	for (i = 0; i &lt; IWN_TX_RING_COUNT; i++) {</a>
<a name="ln2070">		struct iwn_tx_data *data = &amp;ring-&gt;data[i];</a>
<a name="ln2071"> </a>
<a name="ln2072">		if (data-&gt;m != NULL) {</a>
<a name="ln2073">			bus_dmamap_sync(ring-&gt;data_dmat, data-&gt;map,</a>
<a name="ln2074">			    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln2075">			bus_dmamap_unload(ring-&gt;data_dmat, data-&gt;map);</a>
<a name="ln2076">			m_freem(data-&gt;m);</a>
<a name="ln2077">			data-&gt;m = NULL;</a>
<a name="ln2078">		}</a>
<a name="ln2079">		if (data-&gt;ni != NULL) {</a>
<a name="ln2080">			ieee80211_free_node(data-&gt;ni);</a>
<a name="ln2081">			data-&gt;ni = NULL;</a>
<a name="ln2082">		}</a>
<a name="ln2083">	}</a>
<a name="ln2084">	/* Clear TX descriptors. */</a>
<a name="ln2085">	memset(ring-&gt;desc, 0, ring-&gt;desc_dma.size);</a>
<a name="ln2086">	bus_dmamap_sync(ring-&gt;desc_dma.tag, ring-&gt;desc_dma.map,</a>
<a name="ln2087">	    BUS_DMASYNC_PREWRITE);</a>
<a name="ln2088">	sc-&gt;qfullmsk &amp;= ~(1 &lt;&lt; ring-&gt;qid);</a>
<a name="ln2089">	ring-&gt;queued = 0;</a>
<a name="ln2090">	ring-&gt;cur = 0;</a>
<a name="ln2091">}</a>
<a name="ln2092"> </a>
<a name="ln2093">static void</a>
<a name="ln2094">iwn_free_tx_ring(struct iwn_softc *sc, struct iwn_tx_ring *ring)</a>
<a name="ln2095">{</a>
<a name="ln2096">	int i;</a>
<a name="ln2097"> </a>
<a name="ln2098">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s \n&quot;, __func__);</a>
<a name="ln2099"> </a>
<a name="ln2100">	iwn_dma_contig_free(&amp;ring-&gt;desc_dma);</a>
<a name="ln2101">	iwn_dma_contig_free(&amp;ring-&gt;cmd_dma);</a>
<a name="ln2102"> </a>
<a name="ln2103">	for (i = 0; i &lt; IWN_TX_RING_COUNT; i++) {</a>
<a name="ln2104">		struct iwn_tx_data *data = &amp;ring-&gt;data[i];</a>
<a name="ln2105"> </a>
<a name="ln2106">		if (data-&gt;m != NULL) {</a>
<a name="ln2107">			bus_dmamap_sync(ring-&gt;data_dmat, data-&gt;map,</a>
<a name="ln2108">			    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln2109">			bus_dmamap_unload(ring-&gt;data_dmat, data-&gt;map);</a>
<a name="ln2110">			m_freem(data-&gt;m);</a>
<a name="ln2111">		}</a>
<a name="ln2112">		if (data-&gt;map != NULL)</a>
<a name="ln2113">			bus_dmamap_destroy(ring-&gt;data_dmat, data-&gt;map);</a>
<a name="ln2114">	}</a>
<a name="ln2115">	if (ring-&gt;data_dmat != NULL) {</a>
<a name="ln2116">		bus_dma_tag_destroy(ring-&gt;data_dmat);</a>
<a name="ln2117">		ring-&gt;data_dmat = NULL;</a>
<a name="ln2118">	}</a>
<a name="ln2119">}</a>
<a name="ln2120"> </a>
<a name="ln2121">static void</a>
<a name="ln2122">iwn5000_ict_reset(struct iwn_softc *sc)</a>
<a name="ln2123">{</a>
<a name="ln2124">	/* Disable interrupts. */</a>
<a name="ln2125">	IWN_WRITE(sc, IWN_INT_MASK, 0);</a>
<a name="ln2126"> </a>
<a name="ln2127">	/* Reset ICT table. */</a>
<a name="ln2128">	memset(sc-&gt;ict, 0, IWN_ICT_SIZE);</a>
<a name="ln2129">	sc-&gt;ict_cur = 0;</a>
<a name="ln2130"> </a>
<a name="ln2131">	bus_dmamap_sync(sc-&gt;ict_dma.tag, sc-&gt;ict_dma.map,</a>
<a name="ln2132">	    BUS_DMASYNC_PREWRITE);</a>
<a name="ln2133"> </a>
<a name="ln2134">	/* Set physical address of ICT table (4KB aligned). */</a>
<a name="ln2135">	DPRINTF(sc, IWN_DEBUG_RESET, &quot;%s: enabling ICT\n&quot;, __func__);</a>
<a name="ln2136">	IWN_WRITE(sc, IWN_DRAM_INT_TBL, IWN_DRAM_INT_TBL_ENABLE |</a>
<a name="ln2137">	    IWN_DRAM_INT_TBL_WRAP_CHECK | sc-&gt;ict_dma.paddr &gt;&gt; 12);</a>
<a name="ln2138"> </a>
<a name="ln2139">	/* Enable periodic RX interrupt. */</a>
<a name="ln2140">	sc-&gt;int_mask |= IWN_INT_RX_PERIODIC;</a>
<a name="ln2141">	/* Switch to ICT interrupt mode in driver. */</a>
<a name="ln2142">	sc-&gt;sc_flags |= IWN_FLAG_USE_ICT;</a>
<a name="ln2143"> </a>
<a name="ln2144">	/* Re-enable interrupts. */</a>
<a name="ln2145">	IWN_WRITE(sc, IWN_INT, 0xffffffff);</a>
<a name="ln2146">	IWN_WRITE(sc, IWN_INT_MASK, sc-&gt;int_mask);</a>
<a name="ln2147">}</a>
<a name="ln2148"> </a>
<a name="ln2149">static int</a>
<a name="ln2150">iwn_read_eeprom(struct iwn_softc *sc, uint8_t macaddr[IEEE80211_ADDR_LEN])</a>
<a name="ln2151">{</a>
<a name="ln2152">	struct iwn_ops *ops = &amp;sc-&gt;ops;</a>
<a name="ln2153">	uint16_t val;</a>
<a name="ln2154">	int error;</a>
<a name="ln2155"> </a>
<a name="ln2156">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln2157"> </a>
<a name="ln2158">	/* Check whether adapter has an EEPROM or an OTPROM. */</a>
<a name="ln2159">	if (sc-&gt;hw_type &gt;= IWN_HW_REV_TYPE_1000 &amp;&amp;</a>
<a name="ln2160">	    (IWN_READ(sc, IWN_OTP_GP) &amp; IWN_OTP_GP_DEV_SEL_OTP))</a>
<a name="ln2161">		sc-&gt;sc_flags |= IWN_FLAG_HAS_OTPROM;</a>
<a name="ln2162">	DPRINTF(sc, IWN_DEBUG_RESET, &quot;%s found\n&quot;,</a>
<a name="ln2163">	    (sc-&gt;sc_flags &amp; IWN_FLAG_HAS_OTPROM) ? &quot;OTPROM&quot; : &quot;EEPROM&quot;);</a>
<a name="ln2164"> </a>
<a name="ln2165">	/* Adapter has to be powered on for EEPROM access to work. */</a>
<a name="ln2166">	if ((error = iwn_apm_init(sc)) != 0) {</a>
<a name="ln2167">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln2168">		    &quot;%s: could not power ON adapter, error %d\n&quot;, __func__,</a>
<a name="ln2169">		    error);</a>
<a name="ln2170">		return error;</a>
<a name="ln2171">	}</a>
<a name="ln2172"> </a>
<a name="ln2173">	if ((IWN_READ(sc, IWN_EEPROM_GP) &amp; 0x7) == 0) {</a>
<a name="ln2174">		device_printf(sc-&gt;sc_dev, &quot;%s: bad ROM signature\n&quot;, __func__);</a>
<a name="ln2175">		return EIO;</a>
<a name="ln2176">	}</a>
<a name="ln2177">	if ((error = iwn_eeprom_lock(sc)) != 0) {</a>
<a name="ln2178">		device_printf(sc-&gt;sc_dev, &quot;%s: could not lock ROM, error %d\n&quot;,</a>
<a name="ln2179">		    __func__, error);</a>
<a name="ln2180">		return error;</a>
<a name="ln2181">	}</a>
<a name="ln2182">	if (sc-&gt;sc_flags &amp; IWN_FLAG_HAS_OTPROM) {</a>
<a name="ln2183">		if ((error = iwn_init_otprom(sc)) != 0) {</a>
<a name="ln2184">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln2185">			    &quot;%s: could not initialize OTPROM, error %d\n&quot;,</a>
<a name="ln2186">			    __func__, error);</a>
<a name="ln2187">			return error;</a>
<a name="ln2188">		}</a>
<a name="ln2189">	}</a>
<a name="ln2190"> </a>
<a name="ln2191">	iwn_read_prom_data(sc, IWN_EEPROM_SKU_CAP, &amp;val, 2);</a>
<a name="ln2192">	DPRINTF(sc, IWN_DEBUG_RESET, &quot;SKU capabilities=0x%04x\n&quot;, le16toh(val));</a>
<a name="ln2193">	/* Check if HT support is bonded out. */</a>
<a name="ln2194">	if (val &amp; htole16(IWN_EEPROM_SKU_CAP_11N))</a>
<a name="ln2195">		sc-&gt;sc_flags |= IWN_FLAG_HAS_11N;</a>
<a name="ln2196"> </a>
<a name="ln2197">	iwn_read_prom_data(sc, IWN_EEPROM_RFCFG, &amp;val, 2);</a>
<a name="ln2198">	sc-&gt;rfcfg = le16toh(val);</a>
<a name="ln2199">	DPRINTF(sc, IWN_DEBUG_RESET, &quot;radio config=0x%04x\n&quot;, sc-&gt;rfcfg);</a>
<a name="ln2200">	/* Read Tx/Rx chains from ROM unless it's known to be broken. */</a>
<a name="ln2201">	if (sc-&gt;txchainmask == 0)</a>
<a name="ln2202">		sc-&gt;txchainmask = IWN_RFCFG_TXANTMSK(sc-&gt;rfcfg);</a>
<a name="ln2203">	if (sc-&gt;rxchainmask == 0)</a>
<a name="ln2204">		sc-&gt;rxchainmask = IWN_RFCFG_RXANTMSK(sc-&gt;rfcfg);</a>
<a name="ln2205"> </a>
<a name="ln2206">	/* Read MAC address. */</a>
<a name="ln2207">	iwn_read_prom_data(sc, IWN_EEPROM_MAC, macaddr, 6);</a>
<a name="ln2208"> </a>
<a name="ln2209">	/* Read adapter-specific information from EEPROM. */</a>
<a name="ln2210">	ops-&gt;read_eeprom(sc);</a>
<a name="ln2211"> </a>
<a name="ln2212">	iwn_apm_stop(sc);	/* Power OFF adapter. */</a>
<a name="ln2213"> </a>
<a name="ln2214">	iwn_eeprom_unlock(sc);</a>
<a name="ln2215"> </a>
<a name="ln2216">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s end\n&quot;, __func__);</a>
<a name="ln2217"> </a>
<a name="ln2218">	return 0;</a>
<a name="ln2219">}</a>
<a name="ln2220"> </a>
<a name="ln2221">static void</a>
<a name="ln2222">iwn4965_read_eeprom(struct iwn_softc *sc)</a>
<a name="ln2223">{</a>
<a name="ln2224">	uint32_t addr;</a>
<a name="ln2225">	uint16_t val;</a>
<a name="ln2226">	int i;</a>
<a name="ln2227"> </a>
<a name="ln2228">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln2229"> </a>
<a name="ln2230">	/* Read regulatory domain (4 ASCII characters). */</a>
<a name="ln2231">	iwn_read_prom_data(sc, IWN4965_EEPROM_DOMAIN, sc-&gt;eeprom_domain, 4);</a>
<a name="ln2232"> </a>
<a name="ln2233">	/* Read the list of authorized channels (20MHz &amp; 40MHz). */</a>
<a name="ln2234">	for (i = 0; i &lt; IWN_NBANDS - 1; i++) {</a>
<a name="ln2235">		addr = iwn4965_regulatory_bands[i];</a>
<a name="ln2236">		iwn_read_eeprom_channels(sc, i, addr);</a>
<a name="ln2237">	}</a>
<a name="ln2238"> </a>
<a name="ln2239">	/* Read maximum allowed TX power for 2GHz and 5GHz bands. */</a>
<a name="ln2240">	iwn_read_prom_data(sc, IWN4965_EEPROM_MAXPOW, &amp;val, 2);</a>
<a name="ln2241">	sc-&gt;maxpwr2GHz = val &amp; 0xff;</a>
<a name="ln2242">	sc-&gt;maxpwr5GHz = val &gt;&gt; 8;</a>
<a name="ln2243">	/* Check that EEPROM values are within valid range. */</a>
<a name="ln2244">	if (sc-&gt;maxpwr5GHz &lt; 20 || sc-&gt;maxpwr5GHz &gt; 50)</a>
<a name="ln2245">		sc-&gt;maxpwr5GHz = 38;</a>
<a name="ln2246">	if (sc-&gt;maxpwr2GHz &lt; 20 || sc-&gt;maxpwr2GHz &gt; 50)</a>
<a name="ln2247">		sc-&gt;maxpwr2GHz = 38;</a>
<a name="ln2248">	DPRINTF(sc, IWN_DEBUG_RESET, &quot;maxpwr 2GHz=%d 5GHz=%d\n&quot;,</a>
<a name="ln2249">	    sc-&gt;maxpwr2GHz, sc-&gt;maxpwr5GHz);</a>
<a name="ln2250"> </a>
<a name="ln2251">	/* Read samples for each TX power group. */</a>
<a name="ln2252">	iwn_read_prom_data(sc, IWN4965_EEPROM_BANDS, sc-&gt;bands,</a>
<a name="ln2253">	    sizeof sc-&gt;bands);</a>
<a name="ln2254"> </a>
<a name="ln2255">	/* Read voltage at which samples were taken. */</a>
<a name="ln2256">	iwn_read_prom_data(sc, IWN4965_EEPROM_VOLTAGE, &amp;val, 2);</a>
<a name="ln2257">	sc-&gt;eeprom_voltage = (int16_t)le16toh(val);</a>
<a name="ln2258">	DPRINTF(sc, IWN_DEBUG_RESET, &quot;voltage=%d (in 0.3V)\n&quot;,</a>
<a name="ln2259">	    sc-&gt;eeprom_voltage);</a>
<a name="ln2260"> </a>
<a name="ln2261">#ifdef IWN_DEBUG</a>
<a name="ln2262">	/* Print samples. */</a>
<a name="ln2263">	if (sc-&gt;sc_debug &amp; IWN_DEBUG_ANY) {</a>
<a name="ln2264">		for (i = 0; i &lt; IWN_NBANDS - 1; i++)</a>
<a name="ln2265">			iwn4965_print_power_group(sc, i);</a>
<a name="ln2266">	}</a>
<a name="ln2267">#endif</a>
<a name="ln2268"> </a>
<a name="ln2269">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s end\n&quot;, __func__);</a>
<a name="ln2270">}</a>
<a name="ln2271"> </a>
<a name="ln2272">#ifdef IWN_DEBUG</a>
<a name="ln2273">static void</a>
<a name="ln2274">iwn4965_print_power_group(struct iwn_softc *sc, int i)</a>
<a name="ln2275">{</a>
<a name="ln2276">	struct iwn4965_eeprom_band *band = &amp;sc-&gt;bands[i];</a>
<a name="ln2277">	struct iwn4965_eeprom_chan_samples *chans = band-&gt;chans;</a>
<a name="ln2278">	int j, c;</a>
<a name="ln2279"> </a>
<a name="ln2280">	printf(&quot;===band %d===\n&quot;, i);</a>
<a name="ln2281">	printf(&quot;chan lo=%d, chan hi=%d\n&quot;, band-&gt;lo, band-&gt;hi);</a>
<a name="ln2282">	printf(&quot;chan1 num=%d\n&quot;, chans[0].num);</a>
<a name="ln2283">	for (c = 0; c &lt; 2; c++) {</a>
<a name="ln2284">		for (j = 0; j &lt; IWN_NSAMPLES; j++) {</a>
<a name="ln2285">			printf(&quot;chain %d, sample %d: temp=%d gain=%d &quot;</a>
<a name="ln2286">			    &quot;power=%d pa_det=%d\n&quot;, c, j,</a>
<a name="ln2287">			    chans[0].samples[c][j].temp,</a>
<a name="ln2288">			    chans[0].samples[c][j].gain,</a>
<a name="ln2289">			    chans[0].samples[c][j].power,</a>
<a name="ln2290">			    chans[0].samples[c][j].pa_det);</a>
<a name="ln2291">		}</a>
<a name="ln2292">	}</a>
<a name="ln2293">	printf(&quot;chan2 num=%d\n&quot;, chans[1].num);</a>
<a name="ln2294">	for (c = 0; c &lt; 2; c++) {</a>
<a name="ln2295">		for (j = 0; j &lt; IWN_NSAMPLES; j++) {</a>
<a name="ln2296">			printf(&quot;chain %d, sample %d: temp=%d gain=%d &quot;</a>
<a name="ln2297">			    &quot;power=%d pa_det=%d\n&quot;, c, j,</a>
<a name="ln2298">			    chans[1].samples[c][j].temp,</a>
<a name="ln2299">			    chans[1].samples[c][j].gain,</a>
<a name="ln2300">			    chans[1].samples[c][j].power,</a>
<a name="ln2301">			    chans[1].samples[c][j].pa_det);</a>
<a name="ln2302">		}</a>
<a name="ln2303">	}</a>
<a name="ln2304">}</a>
<a name="ln2305">#endif</a>
<a name="ln2306"> </a>
<a name="ln2307">static void</a>
<a name="ln2308">iwn5000_read_eeprom(struct iwn_softc *sc)</a>
<a name="ln2309">{</a>
<a name="ln2310">	struct iwn5000_eeprom_calib_hdr hdr;</a>
<a name="ln2311">	int32_t volt;</a>
<a name="ln2312">	uint32_t base, addr;</a>
<a name="ln2313">	uint16_t val;</a>
<a name="ln2314">	int i;</a>
<a name="ln2315"> </a>
<a name="ln2316">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln2317"> </a>
<a name="ln2318">	/* Read regulatory domain (4 ASCII characters). */</a>
<a name="ln2319">	iwn_read_prom_data(sc, IWN5000_EEPROM_REG, &amp;val, 2);</a>
<a name="ln2320">	base = le16toh(val);</a>
<a name="ln2321">	iwn_read_prom_data(sc, base + IWN5000_EEPROM_DOMAIN,</a>
<a name="ln2322">	    sc-&gt;eeprom_domain, 4);</a>
<a name="ln2323"> </a>
<a name="ln2324">	/* Read the list of authorized channels (20MHz &amp; 40MHz). */</a>
<a name="ln2325">	for (i = 0; i &lt; IWN_NBANDS - 1; i++) {</a>
<a name="ln2326">		addr =  base + sc-&gt;base_params-&gt;regulatory_bands[i];</a>
<a name="ln2327">		iwn_read_eeprom_channels(sc, i, addr);</a>
<a name="ln2328">	}</a>
<a name="ln2329"> </a>
<a name="ln2330">	/* Read enhanced TX power information for 6000 Series. */</a>
<a name="ln2331">	if (sc-&gt;base_params-&gt;enhanced_TX_power)</a>
<a name="ln2332">		iwn_read_eeprom_enhinfo(sc);</a>
<a name="ln2333"> </a>
<a name="ln2334">	iwn_read_prom_data(sc, IWN5000_EEPROM_CAL, &amp;val, 2);</a>
<a name="ln2335">	base = le16toh(val);</a>
<a name="ln2336">	iwn_read_prom_data(sc, base, &amp;hdr, sizeof hdr);</a>
<a name="ln2337">	DPRINTF(sc, IWN_DEBUG_CALIBRATE,</a>
<a name="ln2338">	    &quot;%s: calib version=%u pa type=%u voltage=%u\n&quot;, __func__,</a>
<a name="ln2339">	    hdr.version, hdr.pa_type, le16toh(hdr.volt));</a>
<a name="ln2340">	sc-&gt;calib_ver = hdr.version;</a>
<a name="ln2341"> </a>
<a name="ln2342">	if (sc-&gt;base_params-&gt;calib_need &amp; IWN_FLG_NEED_PHY_CALIB_TEMP_OFFSETv2) {</a>
<a name="ln2343">		sc-&gt;eeprom_voltage = le16toh(hdr.volt);</a>
<a name="ln2344">		iwn_read_prom_data(sc, base + IWN5000_EEPROM_TEMP, &amp;val, 2);</a>
<a name="ln2345">		sc-&gt;eeprom_temp_high=le16toh(val);</a>
<a name="ln2346">		iwn_read_prom_data(sc, base + IWN5000_EEPROM_VOLT, &amp;val, 2);</a>
<a name="ln2347">		sc-&gt;eeprom_temp = le16toh(val);</a>
<a name="ln2348">	}</a>
<a name="ln2349"> </a>
<a name="ln2350">	if (sc-&gt;hw_type == IWN_HW_REV_TYPE_5150) {</a>
<a name="ln2351">		/* Compute temperature offset. */</a>
<a name="ln2352">		iwn_read_prom_data(sc, base + IWN5000_EEPROM_TEMP, &amp;val, 2);</a>
<a name="ln2353">		sc-&gt;eeprom_temp = le16toh(val);</a>
<a name="ln2354">		iwn_read_prom_data(sc, base + IWN5000_EEPROM_VOLT, &amp;val, 2);</a>
<a name="ln2355">		volt = le16toh(val);</a>
<a name="ln2356">		sc-&gt;temp_off = sc-&gt;eeprom_temp - (volt / -5);</a>
<a name="ln2357">		DPRINTF(sc, IWN_DEBUG_CALIBRATE, &quot;temp=%d volt=%d offset=%dK\n&quot;,</a>
<a name="ln2358">		    sc-&gt;eeprom_temp, volt, sc-&gt;temp_off);</a>
<a name="ln2359">	} else {</a>
<a name="ln2360">		/* Read crystal calibration. */</a>
<a name="ln2361">		iwn_read_prom_data(sc, base + IWN5000_EEPROM_CRYSTAL,</a>
<a name="ln2362">		    &amp;sc-&gt;eeprom_crystal, sizeof (uint32_t));</a>
<a name="ln2363">		DPRINTF(sc, IWN_DEBUG_CALIBRATE, &quot;crystal calibration 0x%08x\n&quot;,</a>
<a name="ln2364">		    le32toh(sc-&gt;eeprom_crystal));</a>
<a name="ln2365">	}</a>
<a name="ln2366"> </a>
<a name="ln2367">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s end\n&quot;, __func__);</a>
<a name="ln2368"> </a>
<a name="ln2369">}</a>
<a name="ln2370"> </a>
<a name="ln2371">/*</a>
<a name="ln2372"> * Translate EEPROM flags to net80211.</a>
<a name="ln2373"> */</a>
<a name="ln2374">static uint32_t</a>
<a name="ln2375">iwn_eeprom_channel_flags(struct iwn_eeprom_chan *channel)</a>
<a name="ln2376">{</a>
<a name="ln2377">	uint32_t nflags;</a>
<a name="ln2378"> </a>
<a name="ln2379">	nflags = 0;</a>
<a name="ln2380">	if ((channel-&gt;flags &amp; IWN_EEPROM_CHAN_ACTIVE) == 0)</a>
<a name="ln2381">		nflags |= IEEE80211_CHAN_PASSIVE;</a>
<a name="ln2382">	if ((channel-&gt;flags &amp; IWN_EEPROM_CHAN_IBSS) == 0)</a>
<a name="ln2383">		nflags |= IEEE80211_CHAN_NOADHOC;</a>
<a name="ln2384">	if (channel-&gt;flags &amp; IWN_EEPROM_CHAN_RADAR) {</a>
<a name="ln2385">		nflags |= IEEE80211_CHAN_DFS;</a>
<a name="ln2386">		/* XXX apparently IBSS may still be marked */</a>
<a name="ln2387">		nflags |= IEEE80211_CHAN_NOADHOC;</a>
<a name="ln2388">	}</a>
<a name="ln2389"> </a>
<a name="ln2390">	return nflags;</a>
<a name="ln2391">}</a>
<a name="ln2392"> </a>
<a name="ln2393">static void</a>
<a name="ln2394">iwn_read_eeprom_band(struct iwn_softc *sc, int n, int maxchans, int *nchans,</a>
<a name="ln2395">    struct ieee80211_channel chans[])</a>
<a name="ln2396">{</a>
<a name="ln2397">	struct iwn_eeprom_chan *channels = sc-&gt;eeprom_channels[n];</a>
<a name="ln2398">	const struct iwn_chan_band *band = &amp;iwn_bands[n];</a>
<a name="ln2399">	uint8_t bands[IEEE80211_MODE_BYTES];</a>
<a name="ln2400">	uint8_t chan;</a>
<a name="ln2401">	int i, error, nflags;</a>
<a name="ln2402"> </a>
<a name="ln2403">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln2404"> </a>
<a name="ln2405">	memset(bands, 0, sizeof(bands));</a>
<a name="ln2406">	if (n == 0) {</a>
<a name="ln2407">		setbit(bands, IEEE80211_MODE_11B);</a>
<a name="ln2408">		setbit(bands, IEEE80211_MODE_11G);</a>
<a name="ln2409">		if (sc-&gt;sc_flags &amp; IWN_FLAG_HAS_11N)</a>
<a name="ln2410">			setbit(bands, IEEE80211_MODE_11NG);</a>
<a name="ln2411">	} else {</a>
<a name="ln2412">		setbit(bands, IEEE80211_MODE_11A);</a>
<a name="ln2413">		if (sc-&gt;sc_flags &amp; IWN_FLAG_HAS_11N)</a>
<a name="ln2414">			setbit(bands, IEEE80211_MODE_11NA);</a>
<a name="ln2415">	}</a>
<a name="ln2416"> </a>
<a name="ln2417">	for (i = 0; i &lt; band-&gt;nchan; i++) {</a>
<a name="ln2418">		if (!(channels[i].flags &amp; IWN_EEPROM_CHAN_VALID)) {</a>
<a name="ln2419">			DPRINTF(sc, IWN_DEBUG_RESET,</a>
<a name="ln2420">			    &quot;skip chan %d flags 0x%x maxpwr %d\n&quot;,</a>
<a name="ln2421">			    band-&gt;chan[i], channels[i].flags,</a>
<a name="ln2422">			    channels[i].maxpwr);</a>
<a name="ln2423">			continue;</a>
<a name="ln2424">		}</a>
<a name="ln2425"> </a>
<a name="ln2426">		chan = band-&gt;chan[i];</a>
<a name="ln2427">		nflags = iwn_eeprom_channel_flags(&amp;channels[i]);</a>
<a name="ln2428">		error = ieee80211_add_channel(chans, maxchans, nchans,</a>
<a name="ln2429">		    chan, 0, channels[i].maxpwr, nflags, bands);</a>
<a name="ln2430">		if (error != 0)</a>
<a name="ln2431">			break;</a>
<a name="ln2432"> </a>
<a name="ln2433">		/* Save maximum allowed TX power for this channel. */</a>
<a name="ln2434">		/* XXX wrong */</a>
<a name="ln2435">		sc-&gt;maxpwr[chan] = channels[i].maxpwr;</a>
<a name="ln2436"> </a>
<a name="ln2437">		DPRINTF(sc, IWN_DEBUG_RESET,</a>
<a name="ln2438">		    &quot;add chan %d flags 0x%x maxpwr %d\n&quot;, chan,</a>
<a name="ln2439">		    channels[i].flags, channels[i].maxpwr);</a>
<a name="ln2440">	}</a>
<a name="ln2441"> </a>
<a name="ln2442">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s end\n&quot;, __func__);</a>
<a name="ln2443"> </a>
<a name="ln2444">}</a>
<a name="ln2445"> </a>
<a name="ln2446">static void</a>
<a name="ln2447">iwn_read_eeprom_ht40(struct iwn_softc *sc, int n, int maxchans, int *nchans,</a>
<a name="ln2448">    struct ieee80211_channel chans[])</a>
<a name="ln2449">{</a>
<a name="ln2450">	struct iwn_eeprom_chan *channels = sc-&gt;eeprom_channels[n];</a>
<a name="ln2451">	const struct iwn_chan_band *band = &amp;iwn_bands[n];</a>
<a name="ln2452">	uint8_t chan;</a>
<a name="ln2453">	int i, error, nflags;</a>
<a name="ln2454"> </a>
<a name="ln2455">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s start\n&quot;, __func__);</a>
<a name="ln2456"> </a>
<a name="ln2457">	if (!(sc-&gt;sc_flags &amp; IWN_FLAG_HAS_11N)) {</a>
<a name="ln2458">		DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s end no 11n\n&quot;, __func__);</a>
<a name="ln2459">		return;</a>
<a name="ln2460">	}</a>
<a name="ln2461"> </a>
<a name="ln2462">	for (i = 0; i &lt; band-&gt;nchan; i++) {</a>
<a name="ln2463">		if (!(channels[i].flags &amp; IWN_EEPROM_CHAN_VALID)) {</a>
<a name="ln2464">			DPRINTF(sc, IWN_DEBUG_RESET,</a>
<a name="ln2465">			    &quot;skip chan %d flags 0x%x maxpwr %d\n&quot;,</a>
<a name="ln2466">			    band-&gt;chan[i], channels[i].flags,</a>
<a name="ln2467">			    channels[i].maxpwr);</a>
<a name="ln2468">			continue;</a>
<a name="ln2469">		}</a>
<a name="ln2470"> </a>
<a name="ln2471">		chan = band-&gt;chan[i];</a>
<a name="ln2472">		nflags = iwn_eeprom_channel_flags(&amp;channels[i]);</a>
<a name="ln2473">		nflags |= (n == 5 ? IEEE80211_CHAN_G : IEEE80211_CHAN_A);</a>
<a name="ln2474">		error = ieee80211_add_channel_ht40(chans, maxchans, nchans,</a>
<a name="ln2475">		    chan, channels[i].maxpwr, nflags);</a>
<a name="ln2476">		switch (error) {</a>
<a name="ln2477">		case EINVAL:</a>
<a name="ln2478">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln2479">			    &quot;%s: no entry for channel %d\n&quot;, __func__, chan);</a>
<a name="ln2480">			continue;</a>
<a name="ln2481">		case ENOENT:</a>
<a name="ln2482">			DPRINTF(sc, IWN_DEBUG_RESET,</a>
<a name="ln2483">			    &quot;%s: skip chan %d, extension channel not found\n&quot;,</a>
<a name="ln2484">			    __func__, chan);</a>
<a name="ln2485">			continue;</a>
<a name="ln2486">		case ENOBUFS:</a>
<a name="ln2487">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln2488">			    &quot;%s: channel table is full!\n&quot;, __func__);</a>
<a name="ln2489">			break;</a>
<a name="ln2490">		case 0:</a>
<a name="ln2491">			DPRINTF(sc, IWN_DEBUG_RESET,</a>
<a name="ln2492">			    &quot;add ht40 chan %d flags 0x%x maxpwr %d\n&quot;,</a>
<a name="ln2493">			    chan, channels[i].flags, channels[i].maxpwr);</a>
<a name="ln2494">			/* FALLTHROUGH */</a>
<a name="ln2495">		default:</a>
<a name="ln2496">			break;</a>
<a name="ln2497">		}</a>
<a name="ln2498">	}</a>
<a name="ln2499"> </a>
<a name="ln2500">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s end\n&quot;, __func__);</a>
<a name="ln2501"> </a>
<a name="ln2502">}</a>
<a name="ln2503"> </a>
<a name="ln2504">static void</a>
<a name="ln2505">iwn_read_eeprom_channels(struct iwn_softc *sc, int n, uint32_t addr)</a>
<a name="ln2506">{</a>
<a name="ln2507">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln2508"> </a>
<a name="ln2509">	iwn_read_prom_data(sc, addr, &amp;sc-&gt;eeprom_channels[n],</a>
<a name="ln2510">	    iwn_bands[n].nchan * sizeof (struct iwn_eeprom_chan));</a>
<a name="ln2511"> </a>
<a name="ln2512">	if (n &lt; 5) {</a>
<a name="ln2513">		iwn_read_eeprom_band(sc, n, IEEE80211_CHAN_MAX, &amp;ic-&gt;ic_nchans,</a>
<a name="ln2514">		    ic-&gt;ic_channels);</a>
<a name="ln2515">	} else {</a>
<a name="ln2516">		iwn_read_eeprom_ht40(sc, n, IEEE80211_CHAN_MAX, &amp;ic-&gt;ic_nchans,</a>
<a name="ln2517">		    ic-&gt;ic_channels);</a>
<a name="ln2518">	}</a>
<a name="ln2519">	ieee80211_sort_channels(ic-&gt;ic_channels, ic-&gt;ic_nchans);</a>
<a name="ln2520">}</a>
<a name="ln2521"> </a>
<a name="ln2522">static struct iwn_eeprom_chan *</a>
<a name="ln2523">iwn_find_eeprom_channel(struct iwn_softc *sc, struct ieee80211_channel *c)</a>
<a name="ln2524">{</a>
<a name="ln2525">	int band, chan, i, j;</a>
<a name="ln2526"> </a>
<a name="ln2527">	if (IEEE80211_IS_CHAN_HT40(c)) {</a>
<a name="ln2528">		band = IEEE80211_IS_CHAN_5GHZ(c) ? 6 : 5;</a>
<a name="ln2529">		if (IEEE80211_IS_CHAN_HT40D(c))</a>
<a name="ln2530">			chan = c-&gt;ic_extieee;</a>
<a name="ln2531">		else</a>
<a name="ln2532">			chan = c-&gt;ic_ieee;</a>
<a name="ln2533">		for (i = 0; i &lt; iwn_bands[band].nchan; i++) {</a>
<a name="ln2534">			if (iwn_bands[band].chan[i] == chan)</a>
<a name="ln2535">				return &amp;sc-&gt;eeprom_channels[band][i];</a>
<a name="ln2536">		}</a>
<a name="ln2537">	} else {</a>
<a name="ln2538">		for (j = 0; j &lt; 5; j++) {</a>
<a name="ln2539">			for (i = 0; i &lt; iwn_bands[j].nchan; i++) {</a>
<a name="ln2540">				if (iwn_bands[j].chan[i] == c-&gt;ic_ieee &amp;&amp;</a>
<a name="ln2541">				    ((j == 0) ^ IEEE80211_IS_CHAN_A(c)) == 1)</a>
<a name="ln2542">					return &amp;sc-&gt;eeprom_channels[j][i];</a>
<a name="ln2543">			}</a>
<a name="ln2544">		}</a>
<a name="ln2545">	}</a>
<a name="ln2546">	return NULL;</a>
<a name="ln2547">}</a>
<a name="ln2548"> </a>
<a name="ln2549">static void</a>
<a name="ln2550">iwn_getradiocaps(struct ieee80211com *ic,</a>
<a name="ln2551">    int maxchans, int *nchans, struct ieee80211_channel chans[])</a>
<a name="ln2552">{</a>
<a name="ln2553">	struct iwn_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln2554">	int i;</a>
<a name="ln2555"> </a>
<a name="ln2556">	/* Parse the list of authorized channels. */</a>
<a name="ln2557">	for (i = 0; i &lt; 5 &amp;&amp; *nchans &lt; maxchans; i++)</a>
<a name="ln2558">		iwn_read_eeprom_band(sc, i, maxchans, nchans, chans);</a>
<a name="ln2559">	for (i = 5; i &lt; IWN_NBANDS - 1 &amp;&amp; *nchans &lt; maxchans; i++)</a>
<a name="ln2560">		iwn_read_eeprom_ht40(sc, i, maxchans, nchans, chans);</a>
<a name="ln2561">}</a>
<a name="ln2562"> </a>
<a name="ln2563">/*</a>
<a name="ln2564"> * Enforce flags read from EEPROM.</a>
<a name="ln2565"> */</a>
<a name="ln2566">static int</a>
<a name="ln2567">iwn_setregdomain(struct ieee80211com *ic, struct ieee80211_regdomain *rd,</a>
<a name="ln2568">    int nchan, struct ieee80211_channel chans[])</a>
<a name="ln2569">{</a>
<a name="ln2570">	struct iwn_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln2571">	int i;</a>
<a name="ln2572"> </a>
<a name="ln2573">	for (i = 0; i &lt; nchan; i++) {</a>
<a name="ln2574">		struct ieee80211_channel *c = &amp;chans[i];</a>
<a name="ln2575">		struct iwn_eeprom_chan *channel;</a>
<a name="ln2576"> </a>
<a name="ln2577">		channel = iwn_find_eeprom_channel(sc, c);</a>
<a name="ln2578">		if (channel == NULL) {</a>
<a name="ln2579">			ic_printf(ic, &quot;%s: invalid channel %u freq %u/0x%x\n&quot;,</a>
<a name="ln2580">			    __func__, c-&gt;ic_ieee, c-&gt;ic_freq, c-&gt;ic_flags);</a>
<a name="ln2581">			return EINVAL;</a>
<a name="ln2582">		}</a>
<a name="ln2583">		c-&gt;ic_flags |= iwn_eeprom_channel_flags(channel);</a>
<a name="ln2584">	}</a>
<a name="ln2585"> </a>
<a name="ln2586">	return 0;</a>
<a name="ln2587">}</a>
<a name="ln2588"> </a>
<a name="ln2589">static void</a>
<a name="ln2590">iwn_read_eeprom_enhinfo(struct iwn_softc *sc)</a>
<a name="ln2591">{</a>
<a name="ln2592">	struct iwn_eeprom_enhinfo enhinfo[35];</a>
<a name="ln2593">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln2594">	struct ieee80211_channel *c;</a>
<a name="ln2595">	uint16_t val, base;</a>
<a name="ln2596">	int8_t maxpwr;</a>
<a name="ln2597">	uint8_t flags;</a>
<a name="ln2598">	int i, j;</a>
<a name="ln2599"> </a>
<a name="ln2600">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln2601"> </a>
<a name="ln2602">	iwn_read_prom_data(sc, IWN5000_EEPROM_REG, &amp;val, 2);</a>
<a name="ln2603">	base = le16toh(val);</a>
<a name="ln2604">	iwn_read_prom_data(sc, base + IWN6000_EEPROM_ENHINFO,</a>
<a name="ln2605">	    enhinfo, sizeof enhinfo);</a>
<a name="ln2606"> </a>
<a name="ln2607">	for (i = 0; i &lt; nitems(enhinfo); i++) {</a>
<a name="ln2608">		flags = enhinfo[i].flags;</a>
<a name="ln2609">		if (!(flags &amp; IWN_ENHINFO_VALID))</a>
<a name="ln2610">			continue;	/* Skip invalid entries. */</a>
<a name="ln2611"> </a>
<a name="ln2612">		maxpwr = 0;</a>
<a name="ln2613">		if (sc-&gt;txchainmask &amp; IWN_ANT_A)</a>
<a name="ln2614">			maxpwr = MAX(maxpwr, enhinfo[i].chain[0]);</a>
<a name="ln2615">		if (sc-&gt;txchainmask &amp; IWN_ANT_B)</a>
<a name="ln2616">			maxpwr = MAX(maxpwr, enhinfo[i].chain[1]);</a>
<a name="ln2617">		if (sc-&gt;txchainmask &amp; IWN_ANT_C)</a>
<a name="ln2618">			maxpwr = MAX(maxpwr, enhinfo[i].chain[2]);</a>
<a name="ln2619">		if (sc-&gt;ntxchains == 2)</a>
<a name="ln2620">			maxpwr = MAX(maxpwr, enhinfo[i].mimo2);</a>
<a name="ln2621">		else if (sc-&gt;ntxchains == 3)</a>
<a name="ln2622">			maxpwr = MAX(maxpwr, enhinfo[i].mimo3);</a>
<a name="ln2623"> </a>
<a name="ln2624">		for (j = 0; j &lt; ic-&gt;ic_nchans; j++) {</a>
<a name="ln2625">			c = &amp;ic-&gt;ic_channels[j];</a>
<a name="ln2626">			if ((flags &amp; IWN_ENHINFO_5GHZ)) {</a>
<a name="ln2627">				if (!IEEE80211_IS_CHAN_A(c))</a>
<a name="ln2628">					continue;</a>
<a name="ln2629">			} else if ((flags &amp; IWN_ENHINFO_OFDM)) {</a>
<a name="ln2630">				if (!IEEE80211_IS_CHAN_G(c))</a>
<a name="ln2631">					continue;</a>
<a name="ln2632">			} else if (!IEEE80211_IS_CHAN_B(c))</a>
<a name="ln2633">				continue;</a>
<a name="ln2634">			if ((flags &amp; IWN_ENHINFO_HT40)) {</a>
<a name="ln2635">				if (!IEEE80211_IS_CHAN_HT40(c))</a>
<a name="ln2636">					continue;</a>
<a name="ln2637">			} else {</a>
<a name="ln2638">				if (IEEE80211_IS_CHAN_HT40(c))</a>
<a name="ln2639">					continue;</a>
<a name="ln2640">			}</a>
<a name="ln2641">			if (enhinfo[i].chan != 0 &amp;&amp;</a>
<a name="ln2642">			    enhinfo[i].chan != c-&gt;ic_ieee)</a>
<a name="ln2643">				continue;</a>
<a name="ln2644"> </a>
<a name="ln2645">			DPRINTF(sc, IWN_DEBUG_RESET,</a>
<a name="ln2646">			    &quot;channel %d(%x), maxpwr %d\n&quot;, c-&gt;ic_ieee,</a>
<a name="ln2647">			    c-&gt;ic_flags, maxpwr / 2);</a>
<a name="ln2648">			c-&gt;ic_maxregpower = maxpwr / 2;</a>
<a name="ln2649">			c-&gt;ic_maxpower = maxpwr;</a>
<a name="ln2650">		}</a>
<a name="ln2651">	}</a>
<a name="ln2652"> </a>
<a name="ln2653">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s end\n&quot;, __func__);</a>
<a name="ln2654"> </a>
<a name="ln2655">}</a>
<a name="ln2656"> </a>
<a name="ln2657">static struct ieee80211_node *</a>
<a name="ln2658">iwn_node_alloc(struct ieee80211vap *vap, const uint8_t mac[IEEE80211_ADDR_LEN])</a>
<a name="ln2659">{</a>
<a name="ln2660">	struct iwn_node *wn;</a>
<a name="ln2661"> </a>
<a name="ln2662">	wn = malloc(sizeof (struct iwn_node), M_80211_NODE, M_NOWAIT | M_ZERO);</a>
<a name="ln2663">	if (wn == NULL)</a>
<a name="ln2664">		return (NULL);</a>
<a name="ln2665"> </a>
<a name="ln2666">	wn-&gt;id = IWN_ID_UNDEFINED;</a>
<a name="ln2667"> </a>
<a name="ln2668">	return (&amp;wn-&gt;ni);</a>
<a name="ln2669">}</a>
<a name="ln2670"> </a>
<a name="ln2671">static __inline int</a>
<a name="ln2672">rate2plcp(int rate)</a>
<a name="ln2673">{</a>
<a name="ln2674">	switch (rate &amp; 0xff) {</a>
<a name="ln2675">	case 12:	return 0xd;</a>
<a name="ln2676">	case 18:	return 0xf;</a>
<a name="ln2677">	case 24:	return 0x5;</a>
<a name="ln2678">	case 36:	return 0x7;</a>
<a name="ln2679">	case 48:	return 0x9;</a>
<a name="ln2680">	case 72:	return 0xb;</a>
<a name="ln2681">	case 96:	return 0x1;</a>
<a name="ln2682">	case 108:	return 0x3;</a>
<a name="ln2683">	case 2:		return 10;</a>
<a name="ln2684">	case 4:		return 20;</a>
<a name="ln2685">	case 11:	return 55;</a>
<a name="ln2686">	case 22:	return 110;</a>
<a name="ln2687">	}</a>
<a name="ln2688">	return 0;</a>
<a name="ln2689">}</a>
<a name="ln2690"> </a>
<a name="ln2691">static __inline uint8_t</a>
<a name="ln2692">plcp2rate(const uint8_t rate_plcp)</a>
<a name="ln2693">{</a>
<a name="ln2694">	switch (rate_plcp) {</a>
<a name="ln2695">	case 0xd:	return 12;</a>
<a name="ln2696">	case 0xf:	return 18;</a>
<a name="ln2697">	case 0x5:	return 24;</a>
<a name="ln2698">	case 0x7:	return 36;</a>
<a name="ln2699">	case 0x9:	return 48;</a>
<a name="ln2700">	case 0xb:	return 72;</a>
<a name="ln2701">	case 0x1:	return 96;</a>
<a name="ln2702">	case 0x3:	return 108;</a>
<a name="ln2703">	case 10:	return 2;</a>
<a name="ln2704">	case 20:	return 4;</a>
<a name="ln2705">	case 55:	return 11;</a>
<a name="ln2706">	case 110:	return 22;</a>
<a name="ln2707">	default:	return 0;</a>
<a name="ln2708">	}</a>
<a name="ln2709">}</a>
<a name="ln2710"> </a>
<a name="ln2711">static int</a>
<a name="ln2712">iwn_get_1stream_tx_antmask(struct iwn_softc *sc)</a>
<a name="ln2713">{</a>
<a name="ln2714"> </a>
<a name="ln2715">	return IWN_LSB(sc-&gt;txchainmask);</a>
<a name="ln2716">}</a>
<a name="ln2717"> </a>
<a name="ln2718">static int</a>
<a name="ln2719">iwn_get_2stream_tx_antmask(struct iwn_softc *sc)</a>
<a name="ln2720">{</a>
<a name="ln2721">	int tx;</a>
<a name="ln2722"> </a>
<a name="ln2723">	/*</a>
<a name="ln2724">	 * The '2 stream' setup is a bit .. odd.</a>
<a name="ln2725">	 *</a>
<a name="ln2726">	 * For NICs that support only 1 antenna, default to IWN_ANT_AB or</a>
<a name="ln2727">	 * the firmware panics (eg Intel 5100.)</a>
<a name="ln2728">	 *</a>
<a name="ln2729">	 * For NICs that support two antennas, we use ANT_AB.</a>
<a name="ln2730">	 *</a>
<a name="ln2731">	 * For NICs that support three antennas, we use the two that</a>
<a name="ln2732">	 * wasn't the default one.</a>
<a name="ln2733">	 *</a>
<a name="ln2734">	 * XXX TODO: if bluetooth (full concurrent) is enabled, restrict</a>
<a name="ln2735">	 * this to only one antenna.</a>
<a name="ln2736">	 */</a>
<a name="ln2737"> </a>
<a name="ln2738">	/* Default - transmit on the other antennas */</a>
<a name="ln2739">	tx = (sc-&gt;txchainmask &amp; ~IWN_LSB(sc-&gt;txchainmask));</a>
<a name="ln2740"> </a>
<a name="ln2741">	/* Now, if it's zero, set it to IWN_ANT_AB, so to not panic firmware */</a>
<a name="ln2742">	if (tx == 0)</a>
<a name="ln2743">		tx = IWN_ANT_AB;</a>
<a name="ln2744"> </a>
<a name="ln2745">	/*</a>
<a name="ln2746">	 * If the NIC is a two-stream TX NIC, configure the TX mask to</a>
<a name="ln2747">	 * the default chainmask</a>
<a name="ln2748">	 */</a>
<a name="ln2749">	else if (sc-&gt;ntxchains == 2)</a>
<a name="ln2750">		tx = sc-&gt;txchainmask;</a>
<a name="ln2751"> </a>
<a name="ln2752">	return (tx);</a>
<a name="ln2753">}</a>
<a name="ln2754"> </a>
<a name="ln2755"> </a>
<a name="ln2756"> </a>
<a name="ln2757">/*</a>
<a name="ln2758"> * Calculate the required PLCP value from the given rate,</a>
<a name="ln2759"> * to the given node.</a>
<a name="ln2760"> *</a>
<a name="ln2761"> * This will take the node configuration (eg 11n, rate table</a>
<a name="ln2762"> * setup, etc) into consideration.</a>
<a name="ln2763"> */</a>
<a name="ln2764">static uint32_t</a>
<a name="ln2765">iwn_rate_to_plcp(struct iwn_softc *sc, struct ieee80211_node *ni,</a>
<a name="ln2766">    uint8_t rate)</a>
<a name="ln2767">{</a>
<a name="ln2768">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln2769">	uint32_t plcp = 0;</a>
<a name="ln2770">	int ridx;</a>
<a name="ln2771"> </a>
<a name="ln2772">	/*</a>
<a name="ln2773">	 * If it's an MCS rate, let's set the plcp correctly</a>
<a name="ln2774">	 * and set the relevant flags based on the node config.</a>
<a name="ln2775">	 */</a>
<a name="ln2776">	if (rate &amp; IEEE80211_RATE_MCS) {</a>
<a name="ln2777">		/*</a>
<a name="ln2778">		 * Set the initial PLCP value to be between 0-&gt;31 for</a>
<a name="ln2779">		 * MCS 0 -&gt; MCS 31, then set the &quot;I'm an MCS rate!&quot;</a>
<a name="ln2780">		 * flag.</a>
<a name="ln2781">		 */</a>
<a name="ln2782">		plcp = IEEE80211_RV(rate) | IWN_RFLAG_MCS;</a>
<a name="ln2783"> </a>
<a name="ln2784">		/*</a>
<a name="ln2785">		 * XXX the following should only occur if both</a>
<a name="ln2786">		 * the local configuration _and_ the remote node</a>
<a name="ln2787">		 * advertise these capabilities.  Thus this code</a>
<a name="ln2788">		 * may need fixing!</a>
<a name="ln2789">		 */</a>
<a name="ln2790"> </a>
<a name="ln2791">		/*</a>
<a name="ln2792">		 * Set the channel width and guard interval.</a>
<a name="ln2793">		 */</a>
<a name="ln2794">		if (IEEE80211_IS_CHAN_HT40(ni-&gt;ni_chan)) {</a>
<a name="ln2795">			plcp |= IWN_RFLAG_HT40;</a>
<a name="ln2796">			if (ni-&gt;ni_htcap &amp; IEEE80211_HTCAP_SHORTGI40)</a>
<a name="ln2797">				plcp |= IWN_RFLAG_SGI;</a>
<a name="ln2798">		} else if (ni-&gt;ni_htcap &amp; IEEE80211_HTCAP_SHORTGI20) {</a>
<a name="ln2799">			plcp |= IWN_RFLAG_SGI;</a>
<a name="ln2800">		}</a>
<a name="ln2801"> </a>
<a name="ln2802">		/*</a>
<a name="ln2803">		 * Ensure the selected rate matches the link quality</a>
<a name="ln2804">		 * table entries being used.</a>
<a name="ln2805">		 */</a>
<a name="ln2806">		if (rate &gt; 0x8f)</a>
<a name="ln2807">			plcp |= IWN_RFLAG_ANT(sc-&gt;txchainmask);</a>
<a name="ln2808">		else if (rate &gt; 0x87)</a>
<a name="ln2809">			plcp |= IWN_RFLAG_ANT(iwn_get_2stream_tx_antmask(sc));</a>
<a name="ln2810">		else</a>
<a name="ln2811">			plcp |= IWN_RFLAG_ANT(iwn_get_1stream_tx_antmask(sc));</a>
<a name="ln2812">	} else {</a>
<a name="ln2813">		/*</a>
<a name="ln2814">		 * Set the initial PLCP - fine for both</a>
<a name="ln2815">		 * OFDM and CCK rates.</a>
<a name="ln2816">		 */</a>
<a name="ln2817">		plcp = rate2plcp(rate);</a>
<a name="ln2818"> </a>
<a name="ln2819">		/* Set CCK flag if it's CCK */</a>
<a name="ln2820"> </a>
<a name="ln2821">		/* XXX It would be nice to have a method</a>
<a name="ln2822">		 * to map the ridx -&gt; phy table entry</a>
<a name="ln2823">		 * so we could just query that, rather than</a>
<a name="ln2824">		 * this hack to check against IWN_RIDX_OFDM6.</a>
<a name="ln2825">		 */</a>
<a name="ln2826">		ridx = ieee80211_legacy_rate_lookup(ic-&gt;ic_rt,</a>
<a name="ln2827">		    rate &amp; IEEE80211_RATE_VAL);</a>
<a name="ln2828">		if (ridx &lt; IWN_RIDX_OFDM6 &amp;&amp;</a>
<a name="ln2829">		    IEEE80211_IS_CHAN_2GHZ(ni-&gt;ni_chan))</a>
<a name="ln2830">			plcp |= IWN_RFLAG_CCK;</a>
<a name="ln2831"> </a>
<a name="ln2832">		/* Set antenna configuration */</a>
<a name="ln2833">		/* XXX TODO: is this the right antenna to use for legacy? */</a>
<a name="ln2834">		plcp |= IWN_RFLAG_ANT(iwn_get_1stream_tx_antmask(sc));</a>
<a name="ln2835">	}</a>
<a name="ln2836"> </a>
<a name="ln2837">	DPRINTF(sc, IWN_DEBUG_TXRATE, &quot;%s: rate=0x%02x, plcp=0x%08x\n&quot;,</a>
<a name="ln2838">	    __func__,</a>
<a name="ln2839">	    rate,</a>
<a name="ln2840">	    plcp);</a>
<a name="ln2841"> </a>
<a name="ln2842">	return (htole32(plcp));</a>
<a name="ln2843">}</a>
<a name="ln2844"> </a>
<a name="ln2845">static void</a>
<a name="ln2846">iwn_newassoc(struct ieee80211_node *ni, int isnew)</a>
<a name="ln2847">{</a>
<a name="ln2848">	/* Doesn't do anything at the moment */</a>
<a name="ln2849">}</a>
<a name="ln2850"> </a>
<a name="ln2851">static int</a>
<a name="ln2852">iwn_media_change(struct ifnet *ifp)</a>
<a name="ln2853">{</a>
<a name="ln2854">	int error;</a>
<a name="ln2855"> </a>
<a name="ln2856">	error = ieee80211_media_change(ifp);</a>
<a name="ln2857">	/* NB: only the fixed rate can change and that doesn't need a reset */</a>
<a name="ln2858">	return (error == ENETRESET ? 0 : error);</a>
<a name="ln2859">}</a>
<a name="ln2860"> </a>
<a name="ln2861">static int</a>
<a name="ln2862">iwn_newstate(struct ieee80211vap *vap, enum ieee80211_state nstate, int arg)</a>
<a name="ln2863">{</a>
<a name="ln2864">	struct iwn_vap *ivp = IWN_VAP(vap);</a>
<a name="ln2865">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln2866">	struct iwn_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln2867">	int error = 0;</a>
<a name="ln2868"> </a>
<a name="ln2869">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln2870"> </a>
<a name="ln2871">	DPRINTF(sc, IWN_DEBUG_STATE, &quot;%s: %s -&gt; %s\n&quot;, __func__,</a>
<a name="ln2872">	    ieee80211_state_name[vap-&gt;iv_state], ieee80211_state_name[nstate]);</a>
<a name="ln2873"> </a>
<a name="ln2874">	IEEE80211_UNLOCK(ic);</a>
<a name="ln2875">	IWN_LOCK(sc);</a>
<a name="ln2876">	callout_stop(&amp;sc-&gt;calib_to);</a>
<a name="ln2877"> </a>
<a name="ln2878">	sc-&gt;rxon = &amp;sc-&gt;rx_on[IWN_RXON_BSS_CTX];</a>
<a name="ln2879"> </a>
<a name="ln2880">	switch (nstate) {</a>
<a name="ln2881">	case IEEE80211_S_ASSOC:</a>
<a name="ln2882">		if (vap-&gt;iv_state != IEEE80211_S_RUN)</a>
<a name="ln2883">			break;</a>
<a name="ln2884">		/* FALLTHROUGH */</a>
<a name="ln2885">	case IEEE80211_S_AUTH:</a>
<a name="ln2886">		if (vap-&gt;iv_state == IEEE80211_S_AUTH)</a>
<a name="ln2887">			break;</a>
<a name="ln2888"> </a>
<a name="ln2889">		/*</a>
<a name="ln2890">		 * !AUTH -&gt; AUTH transition requires state reset to handle</a>
<a name="ln2891">		 * reassociations correctly.</a>
<a name="ln2892">		 */</a>
<a name="ln2893">		sc-&gt;rxon-&gt;associd = 0;</a>
<a name="ln2894">		sc-&gt;rxon-&gt;filter &amp;= ~htole32(IWN_FILTER_BSS);</a>
<a name="ln2895">		sc-&gt;calib.state = IWN_CALIB_STATE_INIT;</a>
<a name="ln2896"> </a>
<a name="ln2897">		/* Wait until we hear a beacon before we transmit */</a>
<a name="ln2898">		if (IEEE80211_IS_CHAN_PASSIVE(ic-&gt;ic_curchan))</a>
<a name="ln2899">			sc-&gt;sc_beacon_wait = 1;</a>
<a name="ln2900"> </a>
<a name="ln2901">		if ((error = iwn_auth(sc, vap)) != 0) {</a>
<a name="ln2902">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln2903">			    &quot;%s: could not move to auth state\n&quot;, __func__);</a>
<a name="ln2904">		}</a>
<a name="ln2905">		break;</a>
<a name="ln2906"> </a>
<a name="ln2907">	case IEEE80211_S_RUN:</a>
<a name="ln2908">		/*</a>
<a name="ln2909">		 * RUN -&gt; RUN transition; Just restart the timers.</a>
<a name="ln2910">		 */</a>
<a name="ln2911">		if (vap-&gt;iv_state == IEEE80211_S_RUN) {</a>
<a name="ln2912">			sc-&gt;calib_cnt = 0;</a>
<a name="ln2913">			break;</a>
<a name="ln2914">		}</a>
<a name="ln2915"> </a>
<a name="ln2916">		/* Wait until we hear a beacon before we transmit */</a>
<a name="ln2917">		if (IEEE80211_IS_CHAN_PASSIVE(ic-&gt;ic_curchan))</a>
<a name="ln2918">			sc-&gt;sc_beacon_wait = 1;</a>
<a name="ln2919"> </a>
<a name="ln2920">		/*</a>
<a name="ln2921">		 * !RUN -&gt; RUN requires setting the association id</a>
<a name="ln2922">		 * which is done with a firmware cmd.  We also defer</a>
<a name="ln2923">		 * starting the timers until that work is done.</a>
<a name="ln2924">		 */</a>
<a name="ln2925">		if ((error = iwn_run(sc, vap)) != 0) {</a>
<a name="ln2926">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln2927">			    &quot;%s: could not move to run state\n&quot;, __func__);</a>
<a name="ln2928">		}</a>
<a name="ln2929">		break;</a>
<a name="ln2930"> </a>
<a name="ln2931">	case IEEE80211_S_INIT:</a>
<a name="ln2932">		sc-&gt;calib.state = IWN_CALIB_STATE_INIT;</a>
<a name="ln2933">		/*</a>
<a name="ln2934">		 * Purge the xmit queue so we don't have old frames</a>
<a name="ln2935">		 * during a new association attempt.</a>
<a name="ln2936">		 */</a>
<a name="ln2937">		sc-&gt;sc_beacon_wait = 0;</a>
<a name="ln2938">		iwn_xmit_queue_drain(sc);</a>
<a name="ln2939">		break;</a>
<a name="ln2940"> </a>
<a name="ln2941">	default:</a>
<a name="ln2942">		break;</a>
<a name="ln2943">	}</a>
<a name="ln2944">	IWN_UNLOCK(sc);</a>
<a name="ln2945">	IEEE80211_LOCK(ic);</a>
<a name="ln2946">	if (error != 0){</a>
<a name="ln2947">		DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s end in error\n&quot;, __func__);</a>
<a name="ln2948">		return error;</a>
<a name="ln2949">	}</a>
<a name="ln2950"> </a>
<a name="ln2951">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: end\n&quot;,__func__);</a>
<a name="ln2952"> </a>
<a name="ln2953">	return ivp-&gt;iv_newstate(vap, nstate, arg);</a>
<a name="ln2954">}</a>
<a name="ln2955"> </a>
<a name="ln2956">static void</a>
<a name="ln2957">iwn_calib_timeout(void *arg)</a>
<a name="ln2958">{</a>
<a name="ln2959">	struct iwn_softc *sc = arg;</a>
<a name="ln2960"> </a>
<a name="ln2961">	IWN_LOCK_ASSERT(sc);</a>
<a name="ln2962"> </a>
<a name="ln2963">	/* Force automatic TX power calibration every 60 secs. */</a>
<a name="ln2964">	if (++sc-&gt;calib_cnt &gt;= 120) {</a>
<a name="ln2965">		uint32_t flags = 0;</a>
<a name="ln2966"> </a>
<a name="ln2967">		DPRINTF(sc, IWN_DEBUG_CALIBRATE, &quot;%s\n&quot;,</a>
<a name="ln2968">		    &quot;sending request for statistics&quot;);</a>
<a name="ln2969">		(void)iwn_cmd(sc, IWN_CMD_GET_STATISTICS, &amp;flags,</a>
<a name="ln2970">		    sizeof flags, 1);</a>
<a name="ln2971">		sc-&gt;calib_cnt = 0;</a>
<a name="ln2972">	}</a>
<a name="ln2973">	callout_reset(&amp;sc-&gt;calib_to, msecs_to_ticks(500), iwn_calib_timeout,</a>
<a name="ln2974">	    sc);</a>
<a name="ln2975">}</a>
<a name="ln2976"> </a>
<a name="ln2977">/*</a>
<a name="ln2978"> * Process an RX_PHY firmware notification.  This is usually immediately</a>
<a name="ln2979"> * followed by an MPDU_RX_DONE notification.</a>
<a name="ln2980"> */</a>
<a name="ln2981">static void</a>
<a name="ln2982">iwn_rx_phy(struct iwn_softc *sc, struct iwn_rx_desc *desc)</a>
<a name="ln2983">{</a>
<a name="ln2984">	struct iwn_rx_stat *stat = (struct iwn_rx_stat *)(desc + 1);</a>
<a name="ln2985"> </a>
<a name="ln2986">	DPRINTF(sc, IWN_DEBUG_CALIBRATE, &quot;%s: received PHY stats\n&quot;, __func__);</a>
<a name="ln2987"> </a>
<a name="ln2988">	/* Save RX statistics, they will be used on MPDU_RX_DONE. */</a>
<a name="ln2989">	memcpy(&amp;sc-&gt;last_rx_stat, stat, sizeof (*stat));</a>
<a name="ln2990">	sc-&gt;last_rx_valid = 1;</a>
<a name="ln2991">}</a>
<a name="ln2992"> </a>
<a name="ln2993">/*</a>
<a name="ln2994"> * Process an RX_DONE (4965AGN only) or MPDU_RX_DONE firmware notification.</a>
<a name="ln2995"> * Each MPDU_RX_DONE notification must be preceded by an RX_PHY one.</a>
<a name="ln2996"> */</a>
<a name="ln2997">static void</a>
<a name="ln2998">iwn_rx_done(struct iwn_softc *sc, struct iwn_rx_desc *desc,</a>
<a name="ln2999">    struct iwn_rx_data *data)</a>
<a name="ln3000">{</a>
<a name="ln3001">	struct iwn_ops *ops = &amp;sc-&gt;ops;</a>
<a name="ln3002">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln3003">	struct iwn_rx_ring *ring = &amp;sc-&gt;rxq;</a>
<a name="ln3004">	struct ieee80211_frame_min *wh;</a>
<a name="ln3005">	struct ieee80211_node *ni;</a>
<a name="ln3006">	struct mbuf *m, *m1;</a>
<a name="ln3007">	struct iwn_rx_stat *stat;</a>
<a name="ln3008">	caddr_t head;</a>
<a name="ln3009">	bus_addr_t paddr;</a>
<a name="ln3010">	uint32_t flags;</a>
<a name="ln3011">	int error, len, rssi, nf;</a>
<a name="ln3012"> </a>
<a name="ln3013">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln3014"> </a>
<a name="ln3015">	if (desc-&gt;type == IWN_MPDU_RX_DONE) {</a>
<a name="ln3016">		/* Check for prior RX_PHY notification. */</a>
<a name="ln3017">		if (!sc-&gt;last_rx_valid) {</a>
<a name="ln3018">			DPRINTF(sc, IWN_DEBUG_ANY,</a>
<a name="ln3019">			    &quot;%s: missing RX_PHY\n&quot;, __func__);</a>
<a name="ln3020">			return;</a>
<a name="ln3021">		}</a>
<a name="ln3022">		stat = &amp;sc-&gt;last_rx_stat;</a>
<a name="ln3023">	} else</a>
<a name="ln3024">		stat = (struct iwn_rx_stat *)(desc + 1);</a>
<a name="ln3025"> </a>
<a name="ln3026">	if (stat-&gt;cfg_phy_len &gt; IWN_STAT_MAXLEN) {</a>
<a name="ln3027">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln3028">		    &quot;%s: invalid RX statistic header, len %d\n&quot;, __func__,</a>
<a name="ln3029">		    stat-&gt;cfg_phy_len);</a>
<a name="ln3030">		return;</a>
<a name="ln3031">	}</a>
<a name="ln3032">	if (desc-&gt;type == IWN_MPDU_RX_DONE) {</a>
<a name="ln3033">		struct iwn_rx_mpdu *mpdu = (struct iwn_rx_mpdu *)(desc + 1);</a>
<a name="ln3034">		head = (caddr_t)(mpdu + 1);</a>
<a name="ln3035">		len = le16toh(mpdu-&gt;len);</a>
<a name="ln3036">	} else {</a>
<a name="ln3037">		head = (caddr_t)(stat + 1) + stat-&gt;cfg_phy_len;</a>
<a name="ln3038">		len = le16toh(stat-&gt;len);</a>
<a name="ln3039">	}</a>
<a name="ln3040"> </a>
<a name="ln3041">	flags = le32toh(*(uint32_t *)(head + len));</a>
<a name="ln3042"> </a>
<a name="ln3043">	/* Discard frames with a bad FCS early. */</a>
<a name="ln3044">	if ((flags &amp; IWN_RX_NOERROR) != IWN_RX_NOERROR) {</a>
<a name="ln3045">		DPRINTF(sc, IWN_DEBUG_RECV, &quot;%s: RX flags error %x\n&quot;,</a>
<a name="ln3046">		    __func__, flags);</a>
<a name="ln3047">		counter_u64_add(ic-&gt;ic_ierrors, 1);</a>
<a name="ln3048">		return;</a>
<a name="ln3049">	}</a>
<a name="ln3050">	/* Discard frames that are too short. */</a>
<a name="ln3051">	if (len &lt; sizeof (struct ieee80211_frame_ack)) {</a>
<a name="ln3052">		DPRINTF(sc, IWN_DEBUG_RECV, &quot;%s: frame too short: %d\n&quot;,</a>
<a name="ln3053">		    __func__, len);</a>
<a name="ln3054">		counter_u64_add(ic-&gt;ic_ierrors, 1);</a>
<a name="ln3055">		return;</a>
<a name="ln3056">	}</a>
<a name="ln3057"> </a>
<a name="ln3058">	m1 = m_getjcl(M_NOWAIT, MT_DATA, M_PKTHDR, IWN_RBUF_SIZE);</a>
<a name="ln3059">	if (m1 == NULL) {</a>
<a name="ln3060">		DPRINTF(sc, IWN_DEBUG_ANY, &quot;%s: no mbuf to restock ring\n&quot;,</a>
<a name="ln3061">		    __func__);</a>
<a name="ln3062">		counter_u64_add(ic-&gt;ic_ierrors, 1);</a>
<a name="ln3063">		return;</a>
<a name="ln3064">	}</a>
<a name="ln3065">	bus_dmamap_unload(ring-&gt;data_dmat, data-&gt;map);</a>
<a name="ln3066"> </a>
<a name="ln3067">	error = bus_dmamap_load(ring-&gt;data_dmat, data-&gt;map, mtod(m1, void *),</a>
<a name="ln3068">	    IWN_RBUF_SIZE, iwn_dma_map_addr, &amp;paddr, BUS_DMA_NOWAIT);</a>
<a name="ln3069">	if (error != 0 &amp;&amp; error != EFBIG) {</a>
<a name="ln3070">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln3071">		    &quot;%s: bus_dmamap_load failed, error %d\n&quot;, __func__, error);</a>
<a name="ln3072">		m_freem(m1);</a>
<a name="ln3073"> </a>
<a name="ln3074">		/* Try to reload the old mbuf. */</a>
<a name="ln3075">		error = bus_dmamap_load(ring-&gt;data_dmat, data-&gt;map,</a>
<a name="ln3076">		    mtod(data-&gt;m, void *), IWN_RBUF_SIZE, iwn_dma_map_addr,</a>
<a name="ln3077">		    &amp;paddr, BUS_DMA_NOWAIT);</a>
<a name="ln3078">		if (error != 0 &amp;&amp; error != EFBIG) {</a>
<a name="ln3079">			panic(&quot;%s: could not load old RX mbuf&quot;, __func__);</a>
<a name="ln3080">		}</a>
<a name="ln3081">		bus_dmamap_sync(ring-&gt;data_dmat, data-&gt;map,</a>
<a name="ln3082">		    BUS_DMASYNC_PREREAD);</a>
<a name="ln3083">		/* Physical address may have changed. */</a>
<a name="ln3084">		ring-&gt;desc[ring-&gt;cur] = htole32(paddr &gt;&gt; 8);</a>
<a name="ln3085">		bus_dmamap_sync(ring-&gt;desc_dma.tag, ring-&gt;desc_dma.map,</a>
<a name="ln3086">		    BUS_DMASYNC_PREWRITE);</a>
<a name="ln3087">		counter_u64_add(ic-&gt;ic_ierrors, 1);</a>
<a name="ln3088">		return;</a>
<a name="ln3089">	}</a>
<a name="ln3090"> </a>
<a name="ln3091">	bus_dmamap_sync(ring-&gt;data_dmat, data-&gt;map,</a>
<a name="ln3092">	    BUS_DMASYNC_PREREAD);</a>
<a name="ln3093"> </a>
<a name="ln3094">	m = data-&gt;m;</a>
<a name="ln3095">	data-&gt;m = m1;</a>
<a name="ln3096">	/* Update RX descriptor. */</a>
<a name="ln3097">	ring-&gt;desc[ring-&gt;cur] = htole32(paddr &gt;&gt; 8);</a>
<a name="ln3098">	bus_dmamap_sync(ring-&gt;desc_dma.tag, ring-&gt;desc_dma.map,</a>
<a name="ln3099">	    BUS_DMASYNC_PREWRITE);</a>
<a name="ln3100"> </a>
<a name="ln3101">	/* Finalize mbuf. */</a>
<a name="ln3102">	m-&gt;m_data = head;</a>
<a name="ln3103">	m-&gt;m_pkthdr.len = m-&gt;m_len = len;</a>
<a name="ln3104"> </a>
<a name="ln3105">	/* Grab a reference to the source node. */</a>
<a name="ln3106">	wh = mtod(m, struct ieee80211_frame_min *);</a>
<a name="ln3107">	if (len &gt;= sizeof(struct ieee80211_frame_min))</a>
<a name="ln3108">		ni = ieee80211_find_rxnode(ic, wh);</a>
<a name="ln3109">	else</a>
<a name="ln3110">		ni = NULL;</a>
<a name="ln3111">	nf = (ni != NULL &amp;&amp; ni-&gt;ni_vap-&gt;iv_state == IEEE80211_S_RUN &amp;&amp;</a>
<a name="ln3112">	    (ic-&gt;ic_flags &amp; IEEE80211_F_SCAN) == 0) ? sc-&gt;noise : -95;</a>
<a name="ln3113"> </a>
<a name="ln3114">	rssi = ops-&gt;get_rssi(sc, stat);</a>
<a name="ln3115"> </a>
<a name="ln3116">	if (ieee80211_radiotap_active(ic)) {</a>
<a name="ln3117">		struct iwn_rx_radiotap_header *tap = &amp;sc-&gt;sc_rxtap;</a>
<a name="ln3118">		uint32_t rate = le32toh(stat-&gt;rate);</a>
<a name="ln3119"> </a>
<a name="ln3120">		tap-&gt;wr_flags = 0;</a>
<a name="ln3121">		if (stat-&gt;flags &amp; htole16(IWN_STAT_FLAG_SHPREAMBLE))</a>
<a name="ln3122">			tap-&gt;wr_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;</a>
<a name="ln3123">		tap-&gt;wr_dbm_antsignal = (int8_t)rssi;</a>
<a name="ln3124">		tap-&gt;wr_dbm_antnoise = (int8_t)nf;</a>
<a name="ln3125">		tap-&gt;wr_tsft = stat-&gt;tstamp;</a>
<a name="ln3126">		if (rate &amp; IWN_RFLAG_MCS) {</a>
<a name="ln3127">			tap-&gt;wr_rate = rate &amp; IWN_RFLAG_RATE_MCS;</a>
<a name="ln3128">			tap-&gt;wr_rate |= IEEE80211_RATE_MCS;</a>
<a name="ln3129">		} else</a>
<a name="ln3130">			tap-&gt;wr_rate = plcp2rate(rate &amp; IWN_RFLAG_RATE);</a>
<a name="ln3131">	}</a>
<a name="ln3132"> </a>
<a name="ln3133">	/*</a>
<a name="ln3134">	 * If it's a beacon and we're waiting, then do the</a>
<a name="ln3135">	 * wakeup.  This should unblock raw_xmit/start.</a>
<a name="ln3136">	 */</a>
<a name="ln3137">	if (sc-&gt;sc_beacon_wait) {</a>
<a name="ln3138">		uint8_t type, subtype;</a>
<a name="ln3139">		/* NB: Re-assign wh */</a>
<a name="ln3140">		wh = mtod(m, struct ieee80211_frame_min *);</a>
<a name="ln3141">		type = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_TYPE_MASK;</a>
<a name="ln3142">		subtype = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_SUBTYPE_MASK;</a>
<a name="ln3143">		/*</a>
<a name="ln3144">		 * This assumes at this point we've received our own</a>
<a name="ln3145">		 * beacon.</a>
<a name="ln3146">		 */</a>
<a name="ln3147">		DPRINTF(sc, IWN_DEBUG_TRACE,</a>
<a name="ln3148">		    &quot;%s: beacon_wait, type=%d, subtype=%d\n&quot;,</a>
<a name="ln3149">		    __func__, type, subtype);</a>
<a name="ln3150">		if (type == IEEE80211_FC0_TYPE_MGT &amp;&amp;</a>
<a name="ln3151">		    subtype == IEEE80211_FC0_SUBTYPE_BEACON) {</a>
<a name="ln3152">			DPRINTF(sc, IWN_DEBUG_TRACE | IWN_DEBUG_XMIT,</a>
<a name="ln3153">			    &quot;%s: waking things up\n&quot;, __func__);</a>
<a name="ln3154">			/* queue taskqueue to transmit! */</a>
<a name="ln3155">			taskqueue_enqueue(sc-&gt;sc_tq, &amp;sc-&gt;sc_xmit_task);</a>
<a name="ln3156">		}</a>
<a name="ln3157">	}</a>
<a name="ln3158"> </a>
<a name="ln3159">	IWN_UNLOCK(sc);</a>
<a name="ln3160"> </a>
<a name="ln3161">	/* Send the frame to the 802.11 layer. */</a>
<a name="ln3162">	if (ni != NULL) {</a>
<a name="ln3163">		if (ni-&gt;ni_flags &amp; IEEE80211_NODE_HT)</a>
<a name="ln3164">			m-&gt;m_flags |= M_AMPDU;</a>
<a name="ln3165">		(void)ieee80211_input(ni, m, rssi - nf, nf);</a>
<a name="ln3166">		/* Node is no longer needed. */</a>
<a name="ln3167">		ieee80211_free_node(ni);</a>
<a name="ln3168">	} else</a>
<a name="ln3169">		(void)ieee80211_input_all(ic, m, rssi - nf, nf);</a>
<a name="ln3170"> </a>
<a name="ln3171">	IWN_LOCK(sc);</a>
<a name="ln3172"> </a>
<a name="ln3173">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: end\n&quot;,__func__);</a>
<a name="ln3174"> </a>
<a name="ln3175">}</a>
<a name="ln3176"> </a>
<a name="ln3177">/* Process an incoming Compressed BlockAck. */</a>
<a name="ln3178">static void</a>
<a name="ln3179">iwn_rx_compressed_ba(struct iwn_softc *sc, struct iwn_rx_desc *desc)</a>
<a name="ln3180">{</a>
<a name="ln3181">	struct ieee80211_ratectl_tx_status *txs = &amp;sc-&gt;sc_txs;</a>
<a name="ln3182">	struct iwn_ops *ops = &amp;sc-&gt;ops;</a>
<a name="ln3183">	struct iwn_node *wn;</a>
<a name="ln3184">	struct ieee80211_node *ni;</a>
<a name="ln3185">	struct iwn_compressed_ba *ba = (struct iwn_compressed_ba *)(desc + 1);</a>
<a name="ln3186">	struct iwn_tx_ring *txq;</a>
<a name="ln3187">	struct iwn_tx_data *txdata;</a>
<a name="ln3188">	struct ieee80211_tx_ampdu *tap;</a>
<a name="ln3189">	struct mbuf *m;</a>
<a name="ln3190">	uint64_t bitmap;</a>
<a name="ln3191">	uint16_t ssn;</a>
<a name="ln3192">	uint8_t tid;</a>
<a name="ln3193">	int i, lastidx, qid, *res, shift;</a>
<a name="ln3194">	int tx_ok = 0, tx_err = 0;</a>
<a name="ln3195"> </a>
<a name="ln3196">	DPRINTF(sc, IWN_DEBUG_TRACE | IWN_DEBUG_XMIT, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln3197"> </a>
<a name="ln3198">	qid = le16toh(ba-&gt;qid);</a>
<a name="ln3199">	txq = &amp;sc-&gt;txq[ba-&gt;qid];</a>
<a name="ln3200">	tap = sc-&gt;qid2tap[ba-&gt;qid];</a>
<a name="ln3201">	tid = tap-&gt;txa_tid;</a>
<a name="ln3202">	wn = (void *)tap-&gt;txa_ni;</a>
<a name="ln3203"> </a>
<a name="ln3204">	res = NULL;</a>
<a name="ln3205">	ssn = 0;</a>
<a name="ln3206">	if (!IEEE80211_AMPDU_RUNNING(tap)) {</a>
<a name="ln3207">		res = tap-&gt;txa_private;</a>
<a name="ln3208">		ssn = tap-&gt;txa_start &amp; 0xfff;</a>
<a name="ln3209">	}</a>
<a name="ln3210"> </a>
<a name="ln3211">	for (lastidx = le16toh(ba-&gt;ssn) &amp; 0xff; txq-&gt;read != lastidx;) {</a>
<a name="ln3212">		txdata = &amp;txq-&gt;data[txq-&gt;read];</a>
<a name="ln3213"> </a>
<a name="ln3214">		/* Unmap and free mbuf. */</a>
<a name="ln3215">		bus_dmamap_sync(txq-&gt;data_dmat, txdata-&gt;map,</a>
<a name="ln3216">		    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln3217">		bus_dmamap_unload(txq-&gt;data_dmat, txdata-&gt;map);</a>
<a name="ln3218">		m = txdata-&gt;m, txdata-&gt;m = NULL;</a>
<a name="ln3219">		ni = txdata-&gt;ni, txdata-&gt;ni = NULL;</a>
<a name="ln3220"> </a>
<a name="ln3221">		KASSERT(ni != NULL, (&quot;no node&quot;));</a>
<a name="ln3222">		KASSERT(m != NULL, (&quot;no mbuf&quot;));</a>
<a name="ln3223"> </a>
<a name="ln3224">		DPRINTF(sc, IWN_DEBUG_XMIT, &quot;%s: freeing m=%p\n&quot;, __func__, m);</a>
<a name="ln3225">		ieee80211_tx_complete(ni, m, 1);</a>
<a name="ln3226"> </a>
<a name="ln3227">		txq-&gt;queued--;</a>
<a name="ln3228">		txq-&gt;read = (txq-&gt;read + 1) % IWN_TX_RING_COUNT;</a>
<a name="ln3229">	}</a>
<a name="ln3230"> </a>
<a name="ln3231">	if (txq-&gt;queued == 0 &amp;&amp; res != NULL) {</a>
<a name="ln3232">		iwn_nic_lock(sc);</a>
<a name="ln3233">		ops-&gt;ampdu_tx_stop(sc, qid, tid, ssn);</a>
<a name="ln3234">		iwn_nic_unlock(sc);</a>
<a name="ln3235">		sc-&gt;qid2tap[qid] = NULL;</a>
<a name="ln3236">		free(res, M_DEVBUF);</a>
<a name="ln3237">		return;</a>
<a name="ln3238">	}</a>
<a name="ln3239"> </a>
<a name="ln3240">	if (wn-&gt;agg[tid].bitmap == 0)</a>
<a name="ln3241">		return;</a>
<a name="ln3242"> </a>
<a name="ln3243">	shift = wn-&gt;agg[tid].startidx - ((le16toh(ba-&gt;seq) &gt;&gt; 4) &amp; 0xff);</a>
<a name="ln3244">	if (shift &lt; 0)</a>
<a name="ln3245">		shift += 0x100;</a>
<a name="ln3246"> </a>
<a name="ln3247">	if (wn-&gt;agg[tid].nframes &gt; (64 - shift))</a>
<a name="ln3248">		return;</a>
<a name="ln3249"> </a>
<a name="ln3250">	/*</a>
<a name="ln3251">	 * Walk the bitmap and calculate how many successful and failed</a>
<a name="ln3252">	 * attempts are made.</a>
<a name="ln3253">	 *</a>
<a name="ln3254">	 * Yes, the rate control code doesn't know these are A-MPDU</a>
<a name="ln3255">	 * subframes and that it's okay to fail some of these.</a>
<a name="ln3256">	 */</a>
<a name="ln3257">	ni = tap-&gt;txa_ni;</a>
<a name="ln3258">	bitmap = (le64toh(ba-&gt;bitmap) &gt;&gt; shift) &amp; wn-&gt;agg[tid].bitmap;</a>
<a name="ln3259">	for (i = 0; bitmap; i++) {</a>
<a name="ln3260">		txs-&gt;flags = 0;		/* XXX TODO */</a>
<a name="ln3261">		if ((bitmap &amp; 1) == 0) {</a>
<a name="ln3262">			tx_err ++;</a>
<a name="ln3263">			txs-&gt;status = IEEE80211_RATECTL_TX_FAIL_UNSPECIFIED;</a>
<a name="ln3264">		} else {</a>
<a name="ln3265">			tx_ok ++;</a>
<a name="ln3266">			txs-&gt;status = IEEE80211_RATECTL_TX_SUCCESS;</a>
<a name="ln3267">		}</a>
<a name="ln3268">		ieee80211_ratectl_tx_complete(ni, txs);</a>
<a name="ln3269">		bitmap &gt;&gt;= 1;</a>
<a name="ln3270">	}</a>
<a name="ln3271"> </a>
<a name="ln3272">	DPRINTF(sc, IWN_DEBUG_TRACE | IWN_DEBUG_XMIT,</a>
<a name="ln3273">	    &quot;-&gt;%s: end; %d ok; %d err\n&quot;,__func__, tx_ok, tx_err);</a>
<a name="ln3274"> </a>
<a name="ln3275">}</a>
<a name="ln3276"> </a>
<a name="ln3277">/*</a>
<a name="ln3278"> * Process a CALIBRATION_RESULT notification sent by the initialization</a>
<a name="ln3279"> * firmware on response to a CMD_CALIB_CONFIG command (5000 only).</a>
<a name="ln3280"> */</a>
<a name="ln3281">static void</a>
<a name="ln3282">iwn5000_rx_calib_results(struct iwn_softc *sc, struct iwn_rx_desc *desc)</a>
<a name="ln3283">{</a>
<a name="ln3284">	struct iwn_phy_calib *calib = (struct iwn_phy_calib *)(desc + 1);</a>
<a name="ln3285">	int len, idx = -1;</a>
<a name="ln3286"> </a>
<a name="ln3287">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln3288"> </a>
<a name="ln3289">	/* Runtime firmware should not send such a notification. */</a>
<a name="ln3290">	if (sc-&gt;sc_flags &amp; IWN_FLAG_CALIB_DONE){</a>
<a name="ln3291">		DPRINTF(sc, IWN_DEBUG_TRACE,</a>
<a name="ln3292">		    &quot;-&gt;%s received after calib done\n&quot;, __func__);</a>
<a name="ln3293">		return;</a>
<a name="ln3294">	}</a>
<a name="ln3295">	len = (le32toh(desc-&gt;len) &amp; 0x3fff) - 4;</a>
<a name="ln3296"> </a>
<a name="ln3297">	switch (calib-&gt;code) {</a>
<a name="ln3298">	case IWN5000_PHY_CALIB_DC:</a>
<a name="ln3299">		if (sc-&gt;base_params-&gt;calib_need &amp; IWN_FLG_NEED_PHY_CALIB_DC)</a>
<a name="ln3300">			idx = 0;</a>
<a name="ln3301">		break;</a>
<a name="ln3302">	case IWN5000_PHY_CALIB_LO:</a>
<a name="ln3303">		if (sc-&gt;base_params-&gt;calib_need &amp; IWN_FLG_NEED_PHY_CALIB_LO)</a>
<a name="ln3304">			idx = 1;</a>
<a name="ln3305">		break;</a>
<a name="ln3306">	case IWN5000_PHY_CALIB_TX_IQ:</a>
<a name="ln3307">		if (sc-&gt;base_params-&gt;calib_need &amp; IWN_FLG_NEED_PHY_CALIB_TX_IQ)</a>
<a name="ln3308">			idx = 2;</a>
<a name="ln3309">		break;</a>
<a name="ln3310">	case IWN5000_PHY_CALIB_TX_IQ_PERIODIC:</a>
<a name="ln3311">		if (sc-&gt;base_params-&gt;calib_need &amp; IWN_FLG_NEED_PHY_CALIB_TX_IQ_PERIODIC)</a>
<a name="ln3312">			idx = 3;</a>
<a name="ln3313">		break;</a>
<a name="ln3314">	case IWN5000_PHY_CALIB_BASE_BAND:</a>
<a name="ln3315">		if (sc-&gt;base_params-&gt;calib_need &amp; IWN_FLG_NEED_PHY_CALIB_BASE_BAND)</a>
<a name="ln3316">			idx = 4;</a>
<a name="ln3317">		break;</a>
<a name="ln3318">	}</a>
<a name="ln3319">	if (idx == -1)	/* Ignore other results. */</a>
<a name="ln3320">		return;</a>
<a name="ln3321"> </a>
<a name="ln3322">	/* Save calibration result. */</a>
<a name="ln3323">	if (sc-&gt;calibcmd[idx].buf != NULL)</a>
<a name="ln3324">		free(sc-&gt;calibcmd[idx].buf, M_DEVBUF);</a>
<a name="ln3325">	sc-&gt;calibcmd[idx].buf = malloc(len, M_DEVBUF, M_NOWAIT);</a>
<a name="ln3326">	if (sc-&gt;calibcmd[idx].buf == NULL) {</a>
<a name="ln3327">		DPRINTF(sc, IWN_DEBUG_CALIBRATE,</a>
<a name="ln3328">		    &quot;not enough memory for calibration result %d\n&quot;,</a>
<a name="ln3329">		    calib-&gt;code);</a>
<a name="ln3330">		return;</a>
<a name="ln3331">	}</a>
<a name="ln3332">	DPRINTF(sc, IWN_DEBUG_CALIBRATE,</a>
<a name="ln3333">	    &quot;saving calibration result idx=%d, code=%d len=%d\n&quot;, idx, calib-&gt;code, len);</a>
<a name="ln3334">	sc-&gt;calibcmd[idx].len = len;</a>
<a name="ln3335">	memcpy(sc-&gt;calibcmd[idx].buf, calib, len);</a>
<a name="ln3336">}</a>
<a name="ln3337"> </a>
<a name="ln3338">static void</a>
<a name="ln3339">iwn_stats_update(struct iwn_softc *sc, struct iwn_calib_state *calib,</a>
<a name="ln3340">    struct iwn_stats *stats, int len)</a>
<a name="ln3341">{</a>
<a name="ln3342">	struct iwn_stats_bt *stats_bt;</a>
<a name="ln3343">	struct iwn_stats *lstats;</a>
<a name="ln3344"> </a>
<a name="ln3345">	/*</a>
<a name="ln3346">	 * First - check whether the length is the bluetooth or normal.</a>
<a name="ln3347">	 *</a>
<a name="ln3348">	 * If it's normal - just copy it and bump out.</a>
<a name="ln3349">	 * Otherwise we have to convert things.</a>
<a name="ln3350">	 */</a>
<a name="ln3351"> </a>
<a name="ln3352">	if (len == sizeof(struct iwn_stats) + 4) {</a>
<a name="ln3353">		memcpy(&amp;sc-&gt;last_stat, stats, sizeof(struct iwn_stats));</a>
<a name="ln3354">		sc-&gt;last_stat_valid = 1;</a>
<a name="ln3355">		return;</a>
<a name="ln3356">	}</a>
<a name="ln3357"> </a>
<a name="ln3358">	/*</a>
<a name="ln3359">	 * If it's not the bluetooth size - log, then just copy.</a>
<a name="ln3360">	 */</a>
<a name="ln3361">	if (len != sizeof(struct iwn_stats_bt) + 4) {</a>
<a name="ln3362">		DPRINTF(sc, IWN_DEBUG_STATS,</a>
<a name="ln3363">		    &quot;%s: size of rx statistics (%d) not an expected size!\n&quot;,</a>
<a name="ln3364">		    __func__,</a>
<a name="ln3365">		    len);</a>
<a name="ln3366">		memcpy(&amp;sc-&gt;last_stat, stats, sizeof(struct iwn_stats));</a>
<a name="ln3367">		sc-&gt;last_stat_valid = 1;</a>
<a name="ln3368">		return;</a>
<a name="ln3369">	}</a>
<a name="ln3370"> </a>
<a name="ln3371">	/*</a>
<a name="ln3372">	 * Ok. Time to copy.</a>
<a name="ln3373">	 */</a>
<a name="ln3374">	stats_bt = (struct iwn_stats_bt *) stats;</a>
<a name="ln3375">	lstats = &amp;sc-&gt;last_stat;</a>
<a name="ln3376"> </a>
<a name="ln3377">	/* flags */</a>
<a name="ln3378">	lstats-&gt;flags = stats_bt-&gt;flags;</a>
<a name="ln3379">	/* rx_bt */</a>
<a name="ln3380">	memcpy(&amp;lstats-&gt;rx.ofdm, &amp;stats_bt-&gt;rx_bt.ofdm,</a>
<a name="ln3381">	    sizeof(struct iwn_rx_phy_stats));</a>
<a name="ln3382">	memcpy(&amp;lstats-&gt;rx.cck, &amp;stats_bt-&gt;rx_bt.cck,</a>
<a name="ln3383">	    sizeof(struct iwn_rx_phy_stats));</a>
<a name="ln3384">	memcpy(&amp;lstats-&gt;rx.general, &amp;stats_bt-&gt;rx_bt.general_bt.common,</a>
<a name="ln3385">	    sizeof(struct iwn_rx_general_stats));</a>
<a name="ln3386">	memcpy(&amp;lstats-&gt;rx.ht, &amp;stats_bt-&gt;rx_bt.ht,</a>
<a name="ln3387">	    sizeof(struct iwn_rx_ht_phy_stats));</a>
<a name="ln3388">	/* tx */</a>
<a name="ln3389">	memcpy(&amp;lstats-&gt;tx, &amp;stats_bt-&gt;tx,</a>
<a name="ln3390">	    sizeof(struct iwn_tx_stats));</a>
<a name="ln3391">	/* general */</a>
<a name="ln3392">	memcpy(&amp;lstats-&gt;general, &amp;stats_bt-&gt;general,</a>
<a name="ln3393">	    sizeof(struct iwn_general_stats));</a>
<a name="ln3394"> </a>
<a name="ln3395">	/* XXX TODO: Squirrel away the extra bluetooth stats somewhere */</a>
<a name="ln3396">	sc-&gt;last_stat_valid = 1;</a>
<a name="ln3397">}</a>
<a name="ln3398"> </a>
<a name="ln3399">/*</a>
<a name="ln3400"> * Process an RX_STATISTICS or BEACON_STATISTICS firmware notification.</a>
<a name="ln3401"> * The latter is sent by the firmware after each received beacon.</a>
<a name="ln3402"> */</a>
<a name="ln3403">static void</a>
<a name="ln3404">iwn_rx_statistics(struct iwn_softc *sc, struct iwn_rx_desc *desc)</a>
<a name="ln3405">{</a>
<a name="ln3406">	struct iwn_ops *ops = &amp;sc-&gt;ops;</a>
<a name="ln3407">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln3408">	struct ieee80211vap *vap = TAILQ_FIRST(&amp;ic-&gt;ic_vaps);</a>
<a name="ln3409">	struct iwn_calib_state *calib = &amp;sc-&gt;calib;</a>
<a name="ln3410">	struct iwn_stats *stats = (struct iwn_stats *)(desc + 1);</a>
<a name="ln3411">	struct iwn_stats *lstats;</a>
<a name="ln3412">	int temp;</a>
<a name="ln3413"> </a>
<a name="ln3414">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln3415"> </a>
<a name="ln3416">	/* Ignore statistics received during a scan. */</a>
<a name="ln3417">	if (vap-&gt;iv_state != IEEE80211_S_RUN ||</a>
<a name="ln3418">	    (ic-&gt;ic_flags &amp; IEEE80211_F_SCAN)){</a>
<a name="ln3419">		DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s received during calib\n&quot;,</a>
<a name="ln3420">	    __func__);</a>
<a name="ln3421">		return;</a>
<a name="ln3422">	}</a>
<a name="ln3423"> </a>
<a name="ln3424">	DPRINTF(sc, IWN_DEBUG_CALIBRATE | IWN_DEBUG_STATS,</a>
<a name="ln3425">	    &quot;%s: received statistics, cmd %d, len %d\n&quot;,</a>
<a name="ln3426">	    __func__, desc-&gt;type, le16toh(desc-&gt;len));</a>
<a name="ln3427">	sc-&gt;calib_cnt = 0;	/* Reset TX power calibration timeout. */</a>
<a name="ln3428"> </a>
<a name="ln3429">	/*</a>
<a name="ln3430">	 * Collect/track general statistics for reporting.</a>
<a name="ln3431">	 *</a>
<a name="ln3432">	 * This takes care of ensuring that the bluetooth sized message</a>
<a name="ln3433">	 * will be correctly converted to the legacy sized message.</a>
<a name="ln3434">	 */</a>
<a name="ln3435">	iwn_stats_update(sc, calib, stats, le16toh(desc-&gt;len));</a>
<a name="ln3436"> </a>
<a name="ln3437">	/*</a>
<a name="ln3438">	 * And now, let's take a reference of it to use!</a>
<a name="ln3439">	 */</a>
<a name="ln3440">	lstats = &amp;sc-&gt;last_stat;</a>
<a name="ln3441"> </a>
<a name="ln3442">	/* Test if temperature has changed. */</a>
<a name="ln3443">	if (lstats-&gt;general.temp != sc-&gt;rawtemp) {</a>
<a name="ln3444">		/* Convert &quot;raw&quot; temperature to degC. */</a>
<a name="ln3445">		sc-&gt;rawtemp = stats-&gt;general.temp;</a>
<a name="ln3446">		temp = ops-&gt;get_temperature(sc);</a>
<a name="ln3447">		DPRINTF(sc, IWN_DEBUG_CALIBRATE, &quot;%s: temperature %d\n&quot;,</a>
<a name="ln3448">		    __func__, temp);</a>
<a name="ln3449"> </a>
<a name="ln3450">		/* Update TX power if need be (4965AGN only). */</a>
<a name="ln3451">		if (sc-&gt;hw_type == IWN_HW_REV_TYPE_4965)</a>
<a name="ln3452">			iwn4965_power_calibration(sc, temp);</a>
<a name="ln3453">	}</a>
<a name="ln3454"> </a>
<a name="ln3455">	if (desc-&gt;type != IWN_BEACON_STATISTICS)</a>
<a name="ln3456">		return;	/* Reply to a statistics request. */</a>
<a name="ln3457"> </a>
<a name="ln3458">	sc-&gt;noise = iwn_get_noise(&amp;lstats-&gt;rx.general);</a>
<a name="ln3459">	DPRINTF(sc, IWN_DEBUG_CALIBRATE, &quot;%s: noise %d\n&quot;, __func__, sc-&gt;noise);</a>
<a name="ln3460"> </a>
<a name="ln3461">	/* Test that RSSI and noise are present in stats report. */</a>
<a name="ln3462">	if (le32toh(lstats-&gt;rx.general.flags) != 1) {</a>
<a name="ln3463">		DPRINTF(sc, IWN_DEBUG_ANY, &quot;%s\n&quot;,</a>
<a name="ln3464">		    &quot;received statistics without RSSI&quot;);</a>
<a name="ln3465">		return;</a>
<a name="ln3466">	}</a>
<a name="ln3467"> </a>
<a name="ln3468">	if (calib-&gt;state == IWN_CALIB_STATE_ASSOC)</a>
<a name="ln3469">		iwn_collect_noise(sc, &amp;lstats-&gt;rx.general);</a>
<a name="ln3470">	else if (calib-&gt;state == IWN_CALIB_STATE_RUN) {</a>
<a name="ln3471">		iwn_tune_sensitivity(sc, &amp;lstats-&gt;rx);</a>
<a name="ln3472">		/*</a>
<a name="ln3473">		 * XXX TODO: Only run the RX recovery if we're associated!</a>
<a name="ln3474">		 */</a>
<a name="ln3475">		iwn_check_rx_recovery(sc, lstats);</a>
<a name="ln3476">		iwn_save_stats_counters(sc, lstats);</a>
<a name="ln3477">	}</a>
<a name="ln3478"> </a>
<a name="ln3479">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: end\n&quot;,__func__);</a>
<a name="ln3480">}</a>
<a name="ln3481"> </a>
<a name="ln3482">/*</a>
<a name="ln3483"> * Save the relevant statistic counters for the next calibration</a>
<a name="ln3484"> * pass.</a>
<a name="ln3485"> */</a>
<a name="ln3486">static void</a>
<a name="ln3487">iwn_save_stats_counters(struct iwn_softc *sc, const struct iwn_stats *rs)</a>
<a name="ln3488">{</a>
<a name="ln3489">	struct iwn_calib_state *calib = &amp;sc-&gt;calib;</a>
<a name="ln3490"> </a>
<a name="ln3491">	/* Save counters values for next call. */</a>
<a name="ln3492">	calib-&gt;bad_plcp_cck = le32toh(rs-&gt;rx.cck.bad_plcp);</a>
<a name="ln3493">	calib-&gt;fa_cck = le32toh(rs-&gt;rx.cck.fa);</a>
<a name="ln3494">	calib-&gt;bad_plcp_ht = le32toh(rs-&gt;rx.ht.bad_plcp);</a>
<a name="ln3495">	calib-&gt;bad_plcp_ofdm = le32toh(rs-&gt;rx.ofdm.bad_plcp);</a>
<a name="ln3496">	calib-&gt;fa_ofdm = le32toh(rs-&gt;rx.ofdm.fa);</a>
<a name="ln3497"> </a>
<a name="ln3498">	/* Last time we received these tick values */</a>
<a name="ln3499">	sc-&gt;last_calib_ticks = ticks;</a>
<a name="ln3500">}</a>
<a name="ln3501"> </a>
<a name="ln3502">/*</a>
<a name="ln3503"> * Process a TX_DONE firmware notification.  Unfortunately, the 4965AGN</a>
<a name="ln3504"> * and 5000 adapters have different incompatible TX status formats.</a>
<a name="ln3505"> */</a>
<a name="ln3506">static void</a>
<a name="ln3507">iwn4965_tx_done(struct iwn_softc *sc, struct iwn_rx_desc *desc,</a>
<a name="ln3508">    struct iwn_rx_data *data)</a>
<a name="ln3509">{</a>
<a name="ln3510">	struct iwn4965_tx_stat *stat = (struct iwn4965_tx_stat *)(desc + 1);</a>
<a name="ln3511">	int qid = desc-&gt;qid &amp; IWN_RX_DESC_QID_MSK;</a>
<a name="ln3512"> </a>
<a name="ln3513">	DPRINTF(sc, IWN_DEBUG_XMIT, &quot;%s: &quot;</a>
<a name="ln3514">	    &quot;qid %d idx %d RTS retries %d ACK retries %d nkill %d rate %x duration %d status %x\n&quot;,</a>
<a name="ln3515">	    __func__, desc-&gt;qid, desc-&gt;idx,</a>
<a name="ln3516">	    stat-&gt;rtsfailcnt,</a>
<a name="ln3517">	    stat-&gt;ackfailcnt,</a>
<a name="ln3518">	    stat-&gt;btkillcnt,</a>
<a name="ln3519">	    stat-&gt;rate, le16toh(stat-&gt;duration),</a>
<a name="ln3520">	    le32toh(stat-&gt;status));</a>
<a name="ln3521"> </a>
<a name="ln3522">	if (qid &gt;= sc-&gt;firstaggqueue) {</a>
<a name="ln3523">		iwn_ampdu_tx_done(sc, qid, desc-&gt;idx, stat-&gt;nframes,</a>
<a name="ln3524">		    stat-&gt;rtsfailcnt, stat-&gt;ackfailcnt, &amp;stat-&gt;status);</a>
<a name="ln3525">	} else {</a>
<a name="ln3526">		iwn_tx_done(sc, desc, stat-&gt;rtsfailcnt, stat-&gt;ackfailcnt,</a>
<a name="ln3527">		    le32toh(stat-&gt;status) &amp; 0xff);</a>
<a name="ln3528">	}</a>
<a name="ln3529">}</a>
<a name="ln3530"> </a>
<a name="ln3531">static void</a>
<a name="ln3532">iwn5000_tx_done(struct iwn_softc *sc, struct iwn_rx_desc *desc,</a>
<a name="ln3533">    struct iwn_rx_data *data)</a>
<a name="ln3534">{</a>
<a name="ln3535">	struct iwn5000_tx_stat *stat = (struct iwn5000_tx_stat *)(desc + 1);</a>
<a name="ln3536">	int qid = desc-&gt;qid &amp; IWN_RX_DESC_QID_MSK;</a>
<a name="ln3537"> </a>
<a name="ln3538">	DPRINTF(sc, IWN_DEBUG_XMIT, &quot;%s: &quot;</a>
<a name="ln3539">	    &quot;qid %d idx %d RTS retries %d ACK retries %d nkill %d rate %x duration %d status %x\n&quot;,</a>
<a name="ln3540">	    __func__, desc-&gt;qid, desc-&gt;idx,</a>
<a name="ln3541">	    stat-&gt;rtsfailcnt,</a>
<a name="ln3542">	    stat-&gt;ackfailcnt,</a>
<a name="ln3543">	    stat-&gt;btkillcnt,</a>
<a name="ln3544">	    stat-&gt;rate, le16toh(stat-&gt;duration),</a>
<a name="ln3545">	    le32toh(stat-&gt;status));</a>
<a name="ln3546"> </a>
<a name="ln3547">#ifdef notyet</a>
<a name="ln3548">	/* Reset TX scheduler slot. */</a>
<a name="ln3549">	iwn5000_reset_sched(sc, qid, desc-&gt;idx);</a>
<a name="ln3550">#endif</a>
<a name="ln3551"> </a>
<a name="ln3552">	if (qid &gt;= sc-&gt;firstaggqueue) {</a>
<a name="ln3553">		iwn_ampdu_tx_done(sc, qid, desc-&gt;idx, stat-&gt;nframes,</a>
<a name="ln3554">		    stat-&gt;rtsfailcnt, stat-&gt;ackfailcnt, &amp;stat-&gt;status);</a>
<a name="ln3555">	} else {</a>
<a name="ln3556">		iwn_tx_done(sc, desc, stat-&gt;rtsfailcnt, stat-&gt;ackfailcnt,</a>
<a name="ln3557">		    le16toh(stat-&gt;status) &amp; 0xff);</a>
<a name="ln3558">	}</a>
<a name="ln3559">}</a>
<a name="ln3560"> </a>
<a name="ln3561">/*</a>
<a name="ln3562"> * Adapter-independent backend for TX_DONE firmware notifications.</a>
<a name="ln3563"> */</a>
<a name="ln3564">static void</a>
<a name="ln3565">iwn_tx_done(struct iwn_softc *sc, struct iwn_rx_desc *desc, int rtsfailcnt,</a>
<a name="ln3566">    int ackfailcnt, uint8_t status)</a>
<a name="ln3567">{</a>
<a name="ln3568">	struct ieee80211_ratectl_tx_status *txs = &amp;sc-&gt;sc_txs;</a>
<a name="ln3569">	struct iwn_tx_ring *ring = &amp;sc-&gt;txq[desc-&gt;qid &amp; IWN_RX_DESC_QID_MSK];</a>
<a name="ln3570">	struct iwn_tx_data *data = &amp;ring-&gt;data[desc-&gt;idx];</a>
<a name="ln3571">	struct mbuf *m;</a>
<a name="ln3572">	struct ieee80211_node *ni;</a>
<a name="ln3573"> </a>
<a name="ln3574">	KASSERT(data-&gt;ni != NULL, (&quot;no node&quot;));</a>
<a name="ln3575"> </a>
<a name="ln3576">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln3577"> </a>
<a name="ln3578">	/* Unmap and free mbuf. */</a>
<a name="ln3579">	bus_dmamap_sync(ring-&gt;data_dmat, data-&gt;map, BUS_DMASYNC_POSTWRITE);</a>
<a name="ln3580">	bus_dmamap_unload(ring-&gt;data_dmat, data-&gt;map);</a>
<a name="ln3581">	m = data-&gt;m, data-&gt;m = NULL;</a>
<a name="ln3582">	ni = data-&gt;ni, data-&gt;ni = NULL;</a>
<a name="ln3583"> </a>
<a name="ln3584">	/*</a>
<a name="ln3585">	 * Update rate control statistics for the node.</a>
<a name="ln3586">	 */</a>
<a name="ln3587">	txs-&gt;flags = IEEE80211_RATECTL_STATUS_SHORT_RETRY |</a>
<a name="ln3588">		     IEEE80211_RATECTL_STATUS_LONG_RETRY;</a>
<a name="ln3589">	txs-&gt;short_retries = rtsfailcnt;</a>
<a name="ln3590">	txs-&gt;long_retries = ackfailcnt;</a>
<a name="ln3591">	if (!(status &amp; IWN_TX_FAIL))</a>
<a name="ln3592">		txs-&gt;status = IEEE80211_RATECTL_TX_SUCCESS;</a>
<a name="ln3593">	else {</a>
<a name="ln3594">		switch (status) {</a>
<a name="ln3595">		case IWN_TX_FAIL_SHORT_LIMIT:</a>
<a name="ln3596">			txs-&gt;status = IEEE80211_RATECTL_TX_FAIL_SHORT;</a>
<a name="ln3597">			break;</a>
<a name="ln3598">		case IWN_TX_FAIL_LONG_LIMIT:</a>
<a name="ln3599">			txs-&gt;status = IEEE80211_RATECTL_TX_FAIL_LONG;</a>
<a name="ln3600">			break;</a>
<a name="ln3601">		case IWN_TX_STATUS_FAIL_LIFE_EXPIRE:</a>
<a name="ln3602">			txs-&gt;status = IEEE80211_RATECTL_TX_FAIL_EXPIRED;</a>
<a name="ln3603">			break;</a>
<a name="ln3604">		default:</a>
<a name="ln3605">			txs-&gt;status = IEEE80211_RATECTL_TX_FAIL_UNSPECIFIED;</a>
<a name="ln3606">			break;</a>
<a name="ln3607">		}</a>
<a name="ln3608">	}</a>
<a name="ln3609">	ieee80211_ratectl_tx_complete(ni, txs);</a>
<a name="ln3610"> </a>
<a name="ln3611">	/*</a>
<a name="ln3612">	 * Channels marked for &quot;radar&quot; require traffic to be received</a>
<a name="ln3613">	 * to unlock before we can transmit.  Until traffic is seen</a>
<a name="ln3614">	 * any attempt to transmit is returned immediately with status</a>
<a name="ln3615">	 * set to IWN_TX_FAIL_TX_LOCKED.  Unfortunately this can easily</a>
<a name="ln3616">	 * happen on first authenticate after scanning.  To workaround</a>
<a name="ln3617">	 * this we ignore a failure of this sort in AUTH state so the</a>
<a name="ln3618">	 * 802.11 layer will fall back to using a timeout to wait for</a>
<a name="ln3619">	 * the AUTH reply.  This allows the firmware time to see</a>
<a name="ln3620">	 * traffic so a subsequent retry of AUTH succeeds.  It's</a>
<a name="ln3621">	 * unclear why the firmware does not maintain state for</a>
<a name="ln3622">	 * channels recently visited as this would allow immediate</a>
<a name="ln3623">	 * use of the channel after a scan (where we see traffic).</a>
<a name="ln3624">	 */</a>
<a name="ln3625">	if (status == IWN_TX_FAIL_TX_LOCKED &amp;&amp;</a>
<a name="ln3626">	    ni-&gt;ni_vap-&gt;iv_state == IEEE80211_S_AUTH)</a>
<a name="ln3627">		ieee80211_tx_complete(ni, m, 0);</a>
<a name="ln3628">	else</a>
<a name="ln3629">		ieee80211_tx_complete(ni, m,</a>
<a name="ln3630">		    (status &amp; IWN_TX_FAIL) != 0);</a>
<a name="ln3631"> </a>
<a name="ln3632">	sc-&gt;sc_tx_timer = 0;</a>
<a name="ln3633">	if (--ring-&gt;queued &lt; IWN_TX_RING_LOMARK)</a>
<a name="ln3634">		sc-&gt;qfullmsk &amp;= ~(1 &lt;&lt; ring-&gt;qid);</a>
<a name="ln3635"> </a>
<a name="ln3636">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: end\n&quot;,__func__);</a>
<a name="ln3637">}</a>
<a name="ln3638"> </a>
<a name="ln3639">/*</a>
<a name="ln3640"> * Process a &quot;command done&quot; firmware notification.  This is where we wakeup</a>
<a name="ln3641"> * processes waiting for a synchronous command completion.</a>
<a name="ln3642"> */</a>
<a name="ln3643">static void</a>
<a name="ln3644">iwn_cmd_done(struct iwn_softc *sc, struct iwn_rx_desc *desc)</a>
<a name="ln3645">{</a>
<a name="ln3646">	struct iwn_tx_ring *ring;</a>
<a name="ln3647">	struct iwn_tx_data *data;</a>
<a name="ln3648">	int cmd_queue_num;</a>
<a name="ln3649"> </a>
<a name="ln3650">	if (sc-&gt;sc_flags &amp; IWN_FLAG_PAN_SUPPORT)</a>
<a name="ln3651">		cmd_queue_num = IWN_PAN_CMD_QUEUE;</a>
<a name="ln3652">	else</a>
<a name="ln3653">		cmd_queue_num = IWN_CMD_QUEUE_NUM;</a>
<a name="ln3654"> </a>
<a name="ln3655">	if ((desc-&gt;qid &amp; IWN_RX_DESC_QID_MSK) != cmd_queue_num)</a>
<a name="ln3656">		return;	/* Not a command ack. */</a>
<a name="ln3657"> </a>
<a name="ln3658">	ring = &amp;sc-&gt;txq[cmd_queue_num];</a>
<a name="ln3659">	data = &amp;ring-&gt;data[desc-&gt;idx];</a>
<a name="ln3660"> </a>
<a name="ln3661">	/* If the command was mapped in an mbuf, free it. */</a>
<a name="ln3662">	if (data-&gt;m != NULL) {</a>
<a name="ln3663">		bus_dmamap_sync(ring-&gt;data_dmat, data-&gt;map,</a>
<a name="ln3664">		    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln3665">		bus_dmamap_unload(ring-&gt;data_dmat, data-&gt;map);</a>
<a name="ln3666">		m_freem(data-&gt;m);</a>
<a name="ln3667">		data-&gt;m = NULL;</a>
<a name="ln3668">	}</a>
<a name="ln3669">	wakeup(&amp;ring-&gt;desc[desc-&gt;idx]);</a>
<a name="ln3670">}</a>
<a name="ln3671"> </a>
<a name="ln3672">static void</a>
<a name="ln3673">iwn_ampdu_tx_done(struct iwn_softc *sc, int qid, int idx, int nframes,</a>
<a name="ln3674">    int rtsfailcnt, int ackfailcnt, void *stat)</a>
<a name="ln3675">{</a>
<a name="ln3676">	struct iwn_ops *ops = &amp;sc-&gt;ops;</a>
<a name="ln3677">	struct iwn_tx_ring *ring = &amp;sc-&gt;txq[qid];</a>
<a name="ln3678">	struct ieee80211_ratectl_tx_status *txs = &amp;sc-&gt;sc_txs;</a>
<a name="ln3679">	struct iwn_tx_data *data;</a>
<a name="ln3680">	struct mbuf *m;</a>
<a name="ln3681">	struct iwn_node *wn;</a>
<a name="ln3682">	struct ieee80211_node *ni;</a>
<a name="ln3683">	struct ieee80211_tx_ampdu *tap;</a>
<a name="ln3684">	uint64_t bitmap;</a>
<a name="ln3685">	uint32_t *status = stat;</a>
<a name="ln3686">	uint16_t *aggstatus = stat;</a>
<a name="ln3687">	uint16_t ssn;</a>
<a name="ln3688">	uint8_t tid;</a>
<a name="ln3689">	int bit, i, lastidx, *res, seqno, shift, start;</a>
<a name="ln3690"> </a>
<a name="ln3691">	/* XXX TODO: status is le16 field! Grr */</a>
<a name="ln3692"> </a>
<a name="ln3693">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln3694">	DPRINTF(sc, IWN_DEBUG_XMIT, &quot;%s: nframes=%d, status=0x%08x\n&quot;,</a>
<a name="ln3695">	    __func__,</a>
<a name="ln3696">	    nframes,</a>
<a name="ln3697">	    *status);</a>
<a name="ln3698"> </a>
<a name="ln3699">	tap = sc-&gt;qid2tap[qid];</a>
<a name="ln3700">	tid = tap-&gt;txa_tid;</a>
<a name="ln3701">	wn = (void *)tap-&gt;txa_ni;</a>
<a name="ln3702">	ni = tap-&gt;txa_ni;</a>
<a name="ln3703"> </a>
<a name="ln3704">	/*</a>
<a name="ln3705">	 * XXX TODO: ACK and RTS failures would be nice here!</a>
<a name="ln3706">	 */</a>
<a name="ln3707"> </a>
<a name="ln3708">	/*</a>
<a name="ln3709">	 * A-MPDU single frame status - if we failed to transmit it</a>
<a name="ln3710">	 * in A-MPDU, then it may be a permanent failure.</a>
<a name="ln3711">	 *</a>
<a name="ln3712">	 * XXX TODO: check what the Linux iwlwifi driver does here;</a>
<a name="ln3713">	 * there's some permanent and temporary failures that may be</a>
<a name="ln3714">	 * handled differently.</a>
<a name="ln3715">	 */</a>
<a name="ln3716">	if (nframes == 1) {</a>
<a name="ln3717">		txs-&gt;flags = IEEE80211_RATECTL_STATUS_SHORT_RETRY |</a>
<a name="ln3718">			     IEEE80211_RATECTL_STATUS_LONG_RETRY;</a>
<a name="ln3719">		txs-&gt;short_retries = rtsfailcnt;</a>
<a name="ln3720">		txs-&gt;long_retries = ackfailcnt;</a>
<a name="ln3721">		if ((*status &amp; 0xff) != 1 &amp;&amp; (*status &amp; 0xff) != 2) {</a>
<a name="ln3722">#ifdef	NOT_YET</a>
<a name="ln3723">			printf(&quot;ieee80211_send_bar()\n&quot;);</a>
<a name="ln3724">#endif</a>
<a name="ln3725">			/*</a>
<a name="ln3726">			 * If we completely fail a transmit, make sure a</a>
<a name="ln3727">			 * notification is pushed up to the rate control</a>
<a name="ln3728">			 * layer.</a>
<a name="ln3729">			 */</a>
<a name="ln3730">			/* XXX */</a>
<a name="ln3731">			txs-&gt;status = IEEE80211_RATECTL_TX_FAIL_UNSPECIFIED;</a>
<a name="ln3732">		} else {</a>
<a name="ln3733">			/*</a>
<a name="ln3734">			 * If nframes=1, then we won't be getting a BA for</a>
<a name="ln3735">			 * this frame.  Ensure that we correctly update the</a>
<a name="ln3736">			 * rate control code with how many retries were</a>
<a name="ln3737">			 * needed to send it.</a>
<a name="ln3738">			 */</a>
<a name="ln3739">			txs-&gt;status = IEEE80211_RATECTL_TX_SUCCESS;</a>
<a name="ln3740">		}</a>
<a name="ln3741">		ieee80211_ratectl_tx_complete(ni, txs);</a>
<a name="ln3742">	}</a>
<a name="ln3743"> </a>
<a name="ln3744">	bitmap = 0;</a>
<a name="ln3745">	start = idx;</a>
<a name="ln3746">	for (i = 0; i &lt; nframes; i++) {</a>
<a name="ln3747">		if (le16toh(aggstatus[i * 2]) &amp; 0xc)</a>
<a name="ln3748">			continue;</a>
<a name="ln3749"> </a>
<a name="ln3750">		idx = le16toh(aggstatus[2*i + 1]) &amp; 0xff;</a>
<a name="ln3751">		bit = idx - start;</a>
<a name="ln3752">		shift = 0;</a>
<a name="ln3753">		if (bit &gt;= 64) {</a>
<a name="ln3754">			shift = 0x100 - idx + start;</a>
<a name="ln3755">			bit = 0;</a>
<a name="ln3756">			start = idx;</a>
<a name="ln3757">		} else if (bit &lt;= -64)</a>
<a name="ln3758">			bit = 0x100 - start + idx;</a>
<a name="ln3759">		else if (bit &lt; 0) {</a>
<a name="ln3760">			shift = start - idx;</a>
<a name="ln3761">			start = idx;</a>
<a name="ln3762">			bit = 0;</a>
<a name="ln3763">		}</a>
<a name="ln3764">		bitmap = bitmap &lt;&lt; shift;</a>
<a name="ln3765">		bitmap |= 1ULL &lt;&lt; bit;</a>
<a name="ln3766">	}</a>
<a name="ln3767">	tap = sc-&gt;qid2tap[qid];</a>
<a name="ln3768">	tid = tap-&gt;txa_tid;</a>
<a name="ln3769">	wn = (void *)tap-&gt;txa_ni;</a>
<a name="ln3770">	wn-&gt;agg[tid].bitmap = bitmap;</a>
<a name="ln3771">	wn-&gt;agg[tid].startidx = start;</a>
<a name="ln3772">	wn-&gt;agg[tid].nframes = nframes;</a>
<a name="ln3773"> </a>
<a name="ln3774">	res = NULL;</a>
<a name="ln3775">	ssn = 0;</a>
<a name="ln3776">	if (!IEEE80211_AMPDU_RUNNING(tap)) {</a>
<a name="ln3777">		res = tap-&gt;txa_private;</a>
<a name="ln3778">		ssn = tap-&gt;txa_start &amp; 0xfff;</a>
<a name="ln3779">	}</a>
<a name="ln3780"> </a>
<a name="ln3781">	/* This is going nframes DWORDS into the descriptor? */</a>
<a name="ln3782">	seqno = le32toh(*(status + nframes)) &amp; 0xfff;</a>
<a name="ln3783">	for (lastidx = (seqno &amp; 0xff); ring-&gt;read != lastidx;) {</a>
<a name="ln3784">		data = &amp;ring-&gt;data[ring-&gt;read];</a>
<a name="ln3785"> </a>
<a name="ln3786">		/* Unmap and free mbuf. */</a>
<a name="ln3787">		bus_dmamap_sync(ring-&gt;data_dmat, data-&gt;map,</a>
<a name="ln3788">		    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln3789">		bus_dmamap_unload(ring-&gt;data_dmat, data-&gt;map);</a>
<a name="ln3790">		m = data-&gt;m, data-&gt;m = NULL;</a>
<a name="ln3791">		ni = data-&gt;ni, data-&gt;ni = NULL;</a>
<a name="ln3792"> </a>
<a name="ln3793">		KASSERT(ni != NULL, (&quot;no node&quot;));</a>
<a name="ln3794">		KASSERT(m != NULL, (&quot;no mbuf&quot;));</a>
<a name="ln3795">		DPRINTF(sc, IWN_DEBUG_XMIT, &quot;%s: freeing m=%p\n&quot;, __func__, m);</a>
<a name="ln3796">		ieee80211_tx_complete(ni, m, 1);</a>
<a name="ln3797"> </a>
<a name="ln3798">		ring-&gt;queued--;</a>
<a name="ln3799">		ring-&gt;read = (ring-&gt;read + 1) % IWN_TX_RING_COUNT;</a>
<a name="ln3800">	}</a>
<a name="ln3801"> </a>
<a name="ln3802">	if (ring-&gt;queued == 0 &amp;&amp; res != NULL) {</a>
<a name="ln3803">		iwn_nic_lock(sc);</a>
<a name="ln3804">		ops-&gt;ampdu_tx_stop(sc, qid, tid, ssn);</a>
<a name="ln3805">		iwn_nic_unlock(sc);</a>
<a name="ln3806">		sc-&gt;qid2tap[qid] = NULL;</a>
<a name="ln3807">		free(res, M_DEVBUF);</a>
<a name="ln3808">		return;</a>
<a name="ln3809">	}</a>
<a name="ln3810"> </a>
<a name="ln3811">	sc-&gt;sc_tx_timer = 0;</a>
<a name="ln3812">	if (ring-&gt;queued &lt; IWN_TX_RING_LOMARK)</a>
<a name="ln3813">		sc-&gt;qfullmsk &amp;= ~(1 &lt;&lt; ring-&gt;qid);</a>
<a name="ln3814"> </a>
<a name="ln3815">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: end\n&quot;,__func__);</a>
<a name="ln3816">}</a>
<a name="ln3817"> </a>
<a name="ln3818">/*</a>
<a name="ln3819"> * Process an INT_FH_RX or INT_SW_RX interrupt.</a>
<a name="ln3820"> */</a>
<a name="ln3821">static void</a>
<a name="ln3822">iwn_notif_intr(struct iwn_softc *sc)</a>
<a name="ln3823">{</a>
<a name="ln3824">	struct iwn_ops *ops = &amp;sc-&gt;ops;</a>
<a name="ln3825">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln3826">	struct ieee80211vap *vap = TAILQ_FIRST(&amp;ic-&gt;ic_vaps);</a>
<a name="ln3827">	uint16_t hw;</a>
<a name="ln3828"> </a>
<a name="ln3829">	bus_dmamap_sync(sc-&gt;rxq.stat_dma.tag, sc-&gt;rxq.stat_dma.map,</a>
<a name="ln3830">	    BUS_DMASYNC_POSTREAD);</a>
<a name="ln3831"> </a>
<a name="ln3832">	hw = le16toh(sc-&gt;rxq.stat-&gt;closed_count) &amp; 0xfff;</a>
<a name="ln3833">	while (sc-&gt;rxq.cur != hw) {</a>
<a name="ln3834">		struct iwn_rx_data *data = &amp;sc-&gt;rxq.data[sc-&gt;rxq.cur];</a>
<a name="ln3835">		struct iwn_rx_desc *desc;</a>
<a name="ln3836"> </a>
<a name="ln3837">		bus_dmamap_sync(sc-&gt;rxq.data_dmat, data-&gt;map,</a>
<a name="ln3838">		    BUS_DMASYNC_POSTREAD);</a>
<a name="ln3839">		desc = mtod(data-&gt;m, struct iwn_rx_desc *);</a>
<a name="ln3840"> </a>
<a name="ln3841">		DPRINTF(sc, IWN_DEBUG_RECV,</a>
<a name="ln3842">		    &quot;%s: cur=%d; qid %x idx %d flags %x type %d(%s) len %d\n&quot;,</a>
<a name="ln3843">		    __func__, sc-&gt;rxq.cur, desc-&gt;qid &amp; IWN_RX_DESC_QID_MSK,</a>
<a name="ln3844">		    desc-&gt;idx, desc-&gt;flags, desc-&gt;type,</a>
<a name="ln3845">		    iwn_intr_str(desc-&gt;type), le16toh(desc-&gt;len));</a>
<a name="ln3846"> </a>
<a name="ln3847">		if (!(desc-&gt;qid &amp; IWN_UNSOLICITED_RX_NOTIF))	/* Reply to a command. */</a>
<a name="ln3848">			iwn_cmd_done(sc, desc);</a>
<a name="ln3849"> </a>
<a name="ln3850">		switch (desc-&gt;type) {</a>
<a name="ln3851">		case IWN_RX_PHY:</a>
<a name="ln3852">			iwn_rx_phy(sc, desc);</a>
<a name="ln3853">			break;</a>
<a name="ln3854"> </a>
<a name="ln3855">		case IWN_RX_DONE:		/* 4965AGN only. */</a>
<a name="ln3856">		case IWN_MPDU_RX_DONE:</a>
<a name="ln3857">			/* An 802.11 frame has been received. */</a>
<a name="ln3858">			iwn_rx_done(sc, desc, data);</a>
<a name="ln3859">			break;</a>
<a name="ln3860"> </a>
<a name="ln3861">		case IWN_RX_COMPRESSED_BA:</a>
<a name="ln3862">			/* A Compressed BlockAck has been received. */</a>
<a name="ln3863">			iwn_rx_compressed_ba(sc, desc);</a>
<a name="ln3864">			break;</a>
<a name="ln3865"> </a>
<a name="ln3866">		case IWN_TX_DONE:</a>
<a name="ln3867">			/* An 802.11 frame has been transmitted. */</a>
<a name="ln3868">			ops-&gt;tx_done(sc, desc, data);</a>
<a name="ln3869">			break;</a>
<a name="ln3870"> </a>
<a name="ln3871">		case IWN_RX_STATISTICS:</a>
<a name="ln3872">		case IWN_BEACON_STATISTICS:</a>
<a name="ln3873">			iwn_rx_statistics(sc, desc);</a>
<a name="ln3874">			break;</a>
<a name="ln3875"> </a>
<a name="ln3876">		case IWN_BEACON_MISSED:</a>
<a name="ln3877">		{</a>
<a name="ln3878">			struct iwn_beacon_missed *miss =</a>
<a name="ln3879">			    (struct iwn_beacon_missed *)(desc + 1);</a>
<a name="ln3880">			int misses;</a>
<a name="ln3881"> </a>
<a name="ln3882">			misses = le32toh(miss-&gt;consecutive);</a>
<a name="ln3883"> </a>
<a name="ln3884">			DPRINTF(sc, IWN_DEBUG_STATE,</a>
<a name="ln3885">			    &quot;%s: beacons missed %d/%d\n&quot;, __func__,</a>
<a name="ln3886">			    misses, le32toh(miss-&gt;total));</a>
<a name="ln3887">			/*</a>
<a name="ln3888">			 * If more than 5 consecutive beacons are missed,</a>
<a name="ln3889">			 * reinitialize the sensitivity state machine.</a>
<a name="ln3890">			 */</a>
<a name="ln3891">			if (vap-&gt;iv_state == IEEE80211_S_RUN &amp;&amp;</a>
<a name="ln3892">			    (ic-&gt;ic_flags &amp; IEEE80211_F_SCAN) == 0) {</a>
<a name="ln3893">				if (misses &gt; 5)</a>
<a name="ln3894">					(void)iwn_init_sensitivity(sc);</a>
<a name="ln3895">				if (misses &gt;= vap-&gt;iv_bmissthreshold) {</a>
<a name="ln3896">					IWN_UNLOCK(sc);</a>
<a name="ln3897">					ieee80211_beacon_miss(ic);</a>
<a name="ln3898">					IWN_LOCK(sc);</a>
<a name="ln3899">				}</a>
<a name="ln3900">			}</a>
<a name="ln3901">			break;</a>
<a name="ln3902">		}</a>
<a name="ln3903">		case IWN_UC_READY:</a>
<a name="ln3904">		{</a>
<a name="ln3905">			struct iwn_ucode_info *uc =</a>
<a name="ln3906">			    (struct iwn_ucode_info *)(desc + 1);</a>
<a name="ln3907"> </a>
<a name="ln3908">			/* The microcontroller is ready. */</a>
<a name="ln3909">			DPRINTF(sc, IWN_DEBUG_RESET,</a>
<a name="ln3910">			    &quot;microcode alive notification version=%d.%d &quot;</a>
<a name="ln3911">			    &quot;subtype=%x alive=%x\n&quot;, uc-&gt;major, uc-&gt;minor,</a>
<a name="ln3912">			    uc-&gt;subtype, le32toh(uc-&gt;valid));</a>
<a name="ln3913"> </a>
<a name="ln3914">			if (le32toh(uc-&gt;valid) != 1) {</a>
<a name="ln3915">				device_printf(sc-&gt;sc_dev,</a>
<a name="ln3916">				    &quot;microcontroller initialization failed&quot;);</a>
<a name="ln3917">				break;</a>
<a name="ln3918">			}</a>
<a name="ln3919">			if (uc-&gt;subtype == IWN_UCODE_INIT) {</a>
<a name="ln3920">				/* Save microcontroller report. */</a>
<a name="ln3921">				memcpy(&amp;sc-&gt;ucode_info, uc, sizeof (*uc));</a>
<a name="ln3922">			}</a>
<a name="ln3923">			/* Save the address of the error log in SRAM. */</a>
<a name="ln3924">			sc-&gt;errptr = le32toh(uc-&gt;errptr);</a>
<a name="ln3925">			break;</a>
<a name="ln3926">		}</a>
<a name="ln3927">#ifdef IWN_DEBUG</a>
<a name="ln3928">		case IWN_STATE_CHANGED:</a>
<a name="ln3929">		{</a>
<a name="ln3930">			/*</a>
<a name="ln3931">			 * State change allows hardware switch change to be</a>
<a name="ln3932">			 * noted. However, we handle this in iwn_intr as we</a>
<a name="ln3933">			 * get both the enable/disble intr.</a>
<a name="ln3934">			 */</a>
<a name="ln3935">			uint32_t *status = (uint32_t *)(desc + 1);</a>
<a name="ln3936">			DPRINTF(sc, IWN_DEBUG_INTR | IWN_DEBUG_STATE,</a>
<a name="ln3937">			    &quot;state changed to %x\n&quot;,</a>
<a name="ln3938">			    le32toh(*status));</a>
<a name="ln3939">			break;</a>
<a name="ln3940">		}</a>
<a name="ln3941">		case IWN_START_SCAN:</a>
<a name="ln3942">		{</a>
<a name="ln3943">			struct iwn_start_scan *scan =</a>
<a name="ln3944">			    (struct iwn_start_scan *)(desc + 1);</a>
<a name="ln3945">			DPRINTF(sc, IWN_DEBUG_ANY,</a>
<a name="ln3946">			    &quot;%s: scanning channel %d status %x\n&quot;,</a>
<a name="ln3947">			    __func__, scan-&gt;chan, le32toh(scan-&gt;status));</a>
<a name="ln3948">			break;</a>
<a name="ln3949">		}</a>
<a name="ln3950">#endif</a>
<a name="ln3951">		case IWN_STOP_SCAN:</a>
<a name="ln3952">		{</a>
<a name="ln3953">#ifdef	IWN_DEBUG</a>
<a name="ln3954">			struct iwn_stop_scan *scan =</a>
<a name="ln3955">			    (struct iwn_stop_scan *)(desc + 1);</a>
<a name="ln3956">			DPRINTF(sc, IWN_DEBUG_STATE | IWN_DEBUG_SCAN,</a>
<a name="ln3957">			    &quot;scan finished nchan=%d status=%d chan=%d\n&quot;,</a>
<a name="ln3958">			    scan-&gt;nchan, scan-&gt;status, scan-&gt;chan);</a>
<a name="ln3959">#endif</a>
<a name="ln3960">			sc-&gt;sc_is_scanning = 0;</a>
<a name="ln3961">			callout_stop(&amp;sc-&gt;scan_timeout);</a>
<a name="ln3962">			IWN_UNLOCK(sc);</a>
<a name="ln3963">			ieee80211_scan_next(vap);</a>
<a name="ln3964">			IWN_LOCK(sc);</a>
<a name="ln3965">			break;</a>
<a name="ln3966">		}</a>
<a name="ln3967">		case IWN5000_CALIBRATION_RESULT:</a>
<a name="ln3968">			iwn5000_rx_calib_results(sc, desc);</a>
<a name="ln3969">			break;</a>
<a name="ln3970"> </a>
<a name="ln3971">		case IWN5000_CALIBRATION_DONE:</a>
<a name="ln3972">			sc-&gt;sc_flags |= IWN_FLAG_CALIB_DONE;</a>
<a name="ln3973">			wakeup(sc);</a>
<a name="ln3974">			break;</a>
<a name="ln3975">		}</a>
<a name="ln3976"> </a>
<a name="ln3977">		sc-&gt;rxq.cur = (sc-&gt;rxq.cur + 1) % IWN_RX_RING_COUNT;</a>
<a name="ln3978">	}</a>
<a name="ln3979"> </a>
<a name="ln3980">	/* Tell the firmware what we have processed. */</a>
<a name="ln3981">	hw = (hw == 0) ? IWN_RX_RING_COUNT - 1 : hw - 1;</a>
<a name="ln3982">	IWN_WRITE(sc, IWN_FH_RX_WPTR, hw &amp; ~7);</a>
<a name="ln3983">}</a>
<a name="ln3984"> </a>
<a name="ln3985">/*</a>
<a name="ln3986"> * Process an INT_WAKEUP interrupt raised when the microcontroller wakes up</a>
<a name="ln3987"> * from power-down sleep mode.</a>
<a name="ln3988"> */</a>
<a name="ln3989">static void</a>
<a name="ln3990">iwn_wakeup_intr(struct iwn_softc *sc)</a>
<a name="ln3991">{</a>
<a name="ln3992">	int qid;</a>
<a name="ln3993"> </a>
<a name="ln3994">	DPRINTF(sc, IWN_DEBUG_RESET, &quot;%s: ucode wakeup from power-down sleep\n&quot;,</a>
<a name="ln3995">	    __func__);</a>
<a name="ln3996"> </a>
<a name="ln3997">	/* Wakeup RX and TX rings. */</a>
<a name="ln3998">	IWN_WRITE(sc, IWN_FH_RX_WPTR, sc-&gt;rxq.cur &amp; ~7);</a>
<a name="ln3999">	for (qid = 0; qid &lt; sc-&gt;ntxqs; qid++) {</a>
<a name="ln4000">		struct iwn_tx_ring *ring = &amp;sc-&gt;txq[qid];</a>
<a name="ln4001">		IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, qid &lt;&lt; 8 | ring-&gt;cur);</a>
<a name="ln4002">	}</a>
<a name="ln4003">}</a>
<a name="ln4004"> </a>
<a name="ln4005">static void</a>
<a name="ln4006">iwn_rftoggle_task(void *arg, int npending)</a>
<a name="ln4007">{</a>
<a name="ln4008">	struct iwn_softc *sc = arg;</a>
<a name="ln4009">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln4010">	uint32_t tmp;</a>
<a name="ln4011"> </a>
<a name="ln4012">	IWN_LOCK(sc);</a>
<a name="ln4013">	tmp = IWN_READ(sc, IWN_GP_CNTRL);</a>
<a name="ln4014">	IWN_UNLOCK(sc);</a>
<a name="ln4015"> </a>
<a name="ln4016">	device_printf(sc-&gt;sc_dev, &quot;RF switch: radio %s\n&quot;,</a>
<a name="ln4017">	    (tmp &amp; IWN_GP_CNTRL_RFKILL) ? &quot;enabled&quot; : &quot;disabled&quot;);</a>
<a name="ln4018">	if (!(tmp &amp; IWN_GP_CNTRL_RFKILL)) {</a>
<a name="ln4019">		ieee80211_suspend_all(ic);</a>
<a name="ln4020"> </a>
<a name="ln4021">		/* Enable interrupts to get RF toggle notification. */</a>
<a name="ln4022">		IWN_LOCK(sc);</a>
<a name="ln4023">		IWN_WRITE(sc, IWN_INT, 0xffffffff);</a>
<a name="ln4024">		IWN_WRITE(sc, IWN_INT_MASK, sc-&gt;int_mask);</a>
<a name="ln4025">		IWN_UNLOCK(sc);</a>
<a name="ln4026">	} else</a>
<a name="ln4027">		ieee80211_resume_all(ic);</a>
<a name="ln4028">}</a>
<a name="ln4029"> </a>
<a name="ln4030">/*</a>
<a name="ln4031"> * Dump the error log of the firmware when a firmware panic occurs.  Although</a>
<a name="ln4032"> * we can't debug the firmware because it is neither open source nor free, it</a>
<a name="ln4033"> * can help us to identify certain classes of problems.</a>
<a name="ln4034"> */</a>
<a name="ln4035">static void</a>
<a name="ln4036">iwn_fatal_intr(struct iwn_softc *sc)</a>
<a name="ln4037">{</a>
<a name="ln4038">	struct iwn_fw_dump dump;</a>
<a name="ln4039">	int i;</a>
<a name="ln4040"> </a>
<a name="ln4041">	IWN_LOCK_ASSERT(sc);</a>
<a name="ln4042"> </a>
<a name="ln4043">	/* Force a complete recalibration on next init. */</a>
<a name="ln4044">	sc-&gt;sc_flags &amp;= ~IWN_FLAG_CALIB_DONE;</a>
<a name="ln4045"> </a>
<a name="ln4046">	/* Check that the error log address is valid. */</a>
<a name="ln4047">	if (sc-&gt;errptr &lt; IWN_FW_DATA_BASE ||</a>
<a name="ln4048">	    sc-&gt;errptr + sizeof (dump) &gt;</a>
<a name="ln4049">	    IWN_FW_DATA_BASE + sc-&gt;fw_data_maxsz) {</a>
<a name="ln4050">		printf(&quot;%s: bad firmware error log address 0x%08x\n&quot;, __func__,</a>
<a name="ln4051">		    sc-&gt;errptr);</a>
<a name="ln4052">		return;</a>
<a name="ln4053">	}</a>
<a name="ln4054">	if (iwn_nic_lock(sc) != 0) {</a>
<a name="ln4055">		printf(&quot;%s: could not read firmware error log\n&quot;, __func__);</a>
<a name="ln4056">		return;</a>
<a name="ln4057">	}</a>
<a name="ln4058">	/* Read firmware error log from SRAM. */</a>
<a name="ln4059">	iwn_mem_read_region_4(sc, sc-&gt;errptr, (uint32_t *)&amp;dump,</a>
<a name="ln4060">	    sizeof (dump) / sizeof (uint32_t));</a>
<a name="ln4061">	iwn_nic_unlock(sc);</a>
<a name="ln4062"> </a>
<a name="ln4063">	if (dump.valid == 0) {</a>
<a name="ln4064">		printf(&quot;%s: firmware error log is empty\n&quot;, __func__);</a>
<a name="ln4065">		return;</a>
<a name="ln4066">	}</a>
<a name="ln4067">	printf(&quot;firmware error log:\n&quot;);</a>
<a name="ln4068">	printf(&quot;  error type      = \&quot;%s\&quot; (0x%08X)\n&quot;,</a>
<a name="ln4069">	    (dump.id &lt; nitems(iwn_fw_errmsg)) ?</a>
<a name="ln4070">		iwn_fw_errmsg[dump.id] : &quot;UNKNOWN&quot;,</a>
<a name="ln4071">	    dump.id);</a>
<a name="ln4072">	printf(&quot;  program counter = 0x%08X\n&quot;, dump.pc);</a>
<a name="ln4073">	printf(&quot;  source line     = 0x%08X\n&quot;, dump.src_line);</a>
<a name="ln4074">	printf(&quot;  error data      = 0x%08X%08X\n&quot;,</a>
<a name="ln4075">	    dump.error_data[0], dump.error_data[1]);</a>
<a name="ln4076">	printf(&quot;  branch link     = 0x%08X%08X\n&quot;,</a>
<a name="ln4077">	    dump.branch_link[0], dump.branch_link[1]);</a>
<a name="ln4078">	printf(&quot;  interrupt link  = 0x%08X%08X\n&quot;,</a>
<a name="ln4079">	    dump.interrupt_link[0], dump.interrupt_link[1]);</a>
<a name="ln4080">	printf(&quot;  time            = %u\n&quot;, dump.time[0]);</a>
<a name="ln4081"> </a>
<a name="ln4082">	/* Dump driver status (TX and RX rings) while we're here. */</a>
<a name="ln4083">	printf(&quot;driver status:\n&quot;);</a>
<a name="ln4084">	for (i = 0; i &lt; sc-&gt;ntxqs; i++) {</a>
<a name="ln4085">		struct iwn_tx_ring *ring = &amp;sc-&gt;txq[i];</a>
<a name="ln4086">		printf(&quot;  tx ring %2d: qid=%-2d cur=%-3d queued=%-3d\n&quot;,</a>
<a name="ln4087">		    i, ring-&gt;qid, ring-&gt;cur, ring-&gt;queued);</a>
<a name="ln4088">	}</a>
<a name="ln4089">	printf(&quot;  rx ring: cur=%d\n&quot;, sc-&gt;rxq.cur);</a>
<a name="ln4090">}</a>
<a name="ln4091"> </a>
<a name="ln4092">static void</a>
<a name="ln4093">iwn_intr(void *arg)</a>
<a name="ln4094">{</a>
<a name="ln4095">	struct iwn_softc *sc = arg;</a>
<a name="ln4096">	uint32_t r1, r2, tmp;</a>
<a name="ln4097"> </a>
<a name="ln4098">	IWN_LOCK(sc);</a>
<a name="ln4099"> </a>
<a name="ln4100">#ifndef __HAIKU__</a>
<a name="ln4101">	/* Disable interrupts. */</a>
<a name="ln4102">	IWN_WRITE(sc, IWN_INT_MASK, 0);</a>
<a name="ln4103"> </a>
<a name="ln4104">	/* Read interrupts from ICT (fast) or from registers (slow). */</a>
<a name="ln4105">	if (sc-&gt;sc_flags &amp; IWN_FLAG_USE_ICT) {</a>
<a name="ln4106">		bus_dmamap_sync(sc-&gt;ict_dma.tag, sc-&gt;ict_dma.map,</a>
<a name="ln4107">		    BUS_DMASYNC_POSTREAD);</a>
<a name="ln4108">		tmp = 0;</a>
<a name="ln4109">		while (sc-&gt;ict[sc-&gt;ict_cur] != 0) {</a>
<a name="ln4110">			tmp |= sc-&gt;ict[sc-&gt;ict_cur];</a>
<a name="ln4111">			sc-&gt;ict[sc-&gt;ict_cur] = 0;	/* Acknowledge. */</a>
<a name="ln4112">			sc-&gt;ict_cur = (sc-&gt;ict_cur + 1) % IWN_ICT_COUNT;</a>
<a name="ln4113">		}</a>
<a name="ln4114">		tmp = le32toh(tmp);</a>
<a name="ln4115">		if (tmp == 0xffffffff)	/* Shouldn't happen. */</a>
<a name="ln4116">			tmp = 0;</a>
<a name="ln4117">		else if (tmp &amp; 0xc0000)	/* Workaround a HW bug. */</a>
<a name="ln4118">			tmp |= 0x8000;</a>
<a name="ln4119">		r1 = (tmp &amp; 0xff00) &lt;&lt; 16 | (tmp &amp; 0xff);</a>
<a name="ln4120">		r2 = 0;	/* Unused. */</a>
<a name="ln4121">	} else {</a>
<a name="ln4122">		r1 = IWN_READ(sc, IWN_INT);</a>
<a name="ln4123">		if (r1 == 0xffffffff || (r1 &amp; 0xfffffff0) == 0xa5a5a5a0) {</a>
<a name="ln4124">			IWN_UNLOCK(sc);</a>
<a name="ln4125">			return;	/* Hardware gone! */</a>
<a name="ln4126">		}</a>
<a name="ln4127">		r2 = IWN_READ(sc, IWN_FH_INT);</a>
<a name="ln4128">	}</a>
<a name="ln4129">#else</a>
<a name="ln4130">	r1 = atomic_get((int32 *)&amp;sc-&gt;sc_intr_status_1);</a>
<a name="ln4131">	r2 = atomic_get((int32 *)&amp;sc-&gt;sc_intr_status_2);</a>
<a name="ln4132">#endif</a>
<a name="ln4133"> </a>
<a name="ln4134">	DPRINTF(sc, IWN_DEBUG_INTR, &quot;interrupt reg1=0x%08x reg2=0x%08x\n&quot;</a>
<a name="ln4135">    , r1, r2);</a>
<a name="ln4136"> </a>
<a name="ln4137">	if (r1 == 0 &amp;&amp; r2 == 0)</a>
<a name="ln4138">		goto done;	/* Interrupt not for us. */</a>
<a name="ln4139"> </a>
<a name="ln4140">	/* Acknowledge interrupts. */</a>
<a name="ln4141">	IWN_WRITE(sc, IWN_INT, r1);</a>
<a name="ln4142">	if (!(sc-&gt;sc_flags &amp; IWN_FLAG_USE_ICT))</a>
<a name="ln4143">		IWN_WRITE(sc, IWN_FH_INT, r2);</a>
<a name="ln4144"> </a>
<a name="ln4145">	if (r1 &amp; IWN_INT_RF_TOGGLED) {</a>
<a name="ln4146">		taskqueue_enqueue(sc-&gt;sc_tq, &amp;sc-&gt;sc_rftoggle_task);</a>
<a name="ln4147">		goto done;</a>
<a name="ln4148">	}</a>
<a name="ln4149">	if (r1 &amp; IWN_INT_CT_REACHED) {</a>
<a name="ln4150">		device_printf(sc-&gt;sc_dev, &quot;%s: critical temperature reached!\n&quot;,</a>
<a name="ln4151">		    __func__);</a>
<a name="ln4152">	}</a>
<a name="ln4153">	if (r1 &amp; (IWN_INT_SW_ERR | IWN_INT_HW_ERR)) {</a>
<a name="ln4154">		device_printf(sc-&gt;sc_dev, &quot;%s: fatal firmware error\n&quot;,</a>
<a name="ln4155">		    __func__);</a>
<a name="ln4156">#ifdef	IWN_DEBUG</a>
<a name="ln4157">		iwn_debug_register(sc);</a>
<a name="ln4158">#endif</a>
<a name="ln4159">		/* Dump firmware error log and stop. */</a>
<a name="ln4160">		iwn_fatal_intr(sc);</a>
<a name="ln4161"> </a>
<a name="ln4162">		taskqueue_enqueue(sc-&gt;sc_tq, &amp;sc-&gt;sc_panic_task);</a>
<a name="ln4163">		goto done;</a>
<a name="ln4164">	}</a>
<a name="ln4165">	if ((r1 &amp; (IWN_INT_FH_RX | IWN_INT_SW_RX | IWN_INT_RX_PERIODIC)) ||</a>
<a name="ln4166">	    (r2 &amp; IWN_FH_INT_RX)) {</a>
<a name="ln4167">		if (sc-&gt;sc_flags &amp; IWN_FLAG_USE_ICT) {</a>
<a name="ln4168">			if (r1 &amp; (IWN_INT_FH_RX | IWN_INT_SW_RX))</a>
<a name="ln4169">				IWN_WRITE(sc, IWN_FH_INT, IWN_FH_INT_RX);</a>
<a name="ln4170">			IWN_WRITE_1(sc, IWN_INT_PERIODIC,</a>
<a name="ln4171">			    IWN_INT_PERIODIC_DIS);</a>
<a name="ln4172">			iwn_notif_intr(sc);</a>
<a name="ln4173">			if (r1 &amp; (IWN_INT_FH_RX | IWN_INT_SW_RX)) {</a>
<a name="ln4174">				IWN_WRITE_1(sc, IWN_INT_PERIODIC,</a>
<a name="ln4175">				    IWN_INT_PERIODIC_ENA);</a>
<a name="ln4176">			}</a>
<a name="ln4177">		} else</a>
<a name="ln4178">			iwn_notif_intr(sc);</a>
<a name="ln4179">	}</a>
<a name="ln4180"> </a>
<a name="ln4181">	if ((r1 &amp; IWN_INT_FH_TX) || (r2 &amp; IWN_FH_INT_TX)) {</a>
<a name="ln4182">		if (sc-&gt;sc_flags &amp; IWN_FLAG_USE_ICT)</a>
<a name="ln4183">			IWN_WRITE(sc, IWN_FH_INT, IWN_FH_INT_TX);</a>
<a name="ln4184">		wakeup(sc);	/* FH DMA transfer completed. */</a>
<a name="ln4185">	}</a>
<a name="ln4186"> </a>
<a name="ln4187">	if (r1 &amp; IWN_INT_ALIVE)</a>
<a name="ln4188">		wakeup(sc);	/* Firmware is alive. */</a>
<a name="ln4189"> </a>
<a name="ln4190">	if (r1 &amp; IWN_INT_WAKEUP)</a>
<a name="ln4191">		iwn_wakeup_intr(sc);</a>
<a name="ln4192"> </a>
<a name="ln4193">done:</a>
<a name="ln4194">	/* Re-enable interrupts. */</a>
<a name="ln4195">	if (sc-&gt;sc_flags &amp; IWN_FLAG_RUNNING)</a>
<a name="ln4196">		IWN_WRITE(sc, IWN_INT_MASK, sc-&gt;int_mask);</a>
<a name="ln4197"> </a>
<a name="ln4198">	IWN_UNLOCK(sc);</a>
<a name="ln4199">}</a>
<a name="ln4200"> </a>
<a name="ln4201">/*</a>
<a name="ln4202"> * Update TX scheduler ring when transmitting an 802.11 frame (4965AGN and</a>
<a name="ln4203"> * 5000 adapters use a slightly different format).</a>
<a name="ln4204"> */</a>
<a name="ln4205">static void</a>
<a name="ln4206">iwn4965_update_sched(struct iwn_softc *sc, int qid, int idx, uint8_t id,</a>
<a name="ln4207">    uint16_t len)</a>
<a name="ln4208">{</a>
<a name="ln4209">	uint16_t *w = &amp;sc-&gt;sched[qid * IWN4965_SCHED_COUNT + idx];</a>
<a name="ln4210"> </a>
<a name="ln4211">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln4212"> </a>
<a name="ln4213">	*w = htole16(len + 8);</a>
<a name="ln4214">	bus_dmamap_sync(sc-&gt;sched_dma.tag, sc-&gt;sched_dma.map,</a>
<a name="ln4215">	    BUS_DMASYNC_PREWRITE);</a>
<a name="ln4216">	if (idx &lt; IWN_SCHED_WINSZ) {</a>
<a name="ln4217">		*(w + IWN_TX_RING_COUNT) = *w;</a>
<a name="ln4218">		bus_dmamap_sync(sc-&gt;sched_dma.tag, sc-&gt;sched_dma.map,</a>
<a name="ln4219">		    BUS_DMASYNC_PREWRITE);</a>
<a name="ln4220">	}</a>
<a name="ln4221">}</a>
<a name="ln4222"> </a>
<a name="ln4223">static void</a>
<a name="ln4224">iwn5000_update_sched(struct iwn_softc *sc, int qid, int idx, uint8_t id,</a>
<a name="ln4225">    uint16_t len)</a>
<a name="ln4226">{</a>
<a name="ln4227">	uint16_t *w = &amp;sc-&gt;sched[qid * IWN5000_SCHED_COUNT + idx];</a>
<a name="ln4228"> </a>
<a name="ln4229">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln4230"> </a>
<a name="ln4231">	*w = htole16(id &lt;&lt; 12 | (len + 8));</a>
<a name="ln4232">	bus_dmamap_sync(sc-&gt;sched_dma.tag, sc-&gt;sched_dma.map,</a>
<a name="ln4233">	    BUS_DMASYNC_PREWRITE);</a>
<a name="ln4234">	if (idx &lt; IWN_SCHED_WINSZ) {</a>
<a name="ln4235">		*(w + IWN_TX_RING_COUNT) = *w;</a>
<a name="ln4236">		bus_dmamap_sync(sc-&gt;sched_dma.tag, sc-&gt;sched_dma.map,</a>
<a name="ln4237">		    BUS_DMASYNC_PREWRITE);</a>
<a name="ln4238">	}</a>
<a name="ln4239">}</a>
<a name="ln4240"> </a>
<a name="ln4241">#ifdef notyet</a>
<a name="ln4242">static void</a>
<a name="ln4243">iwn5000_reset_sched(struct iwn_softc *sc, int qid, int idx)</a>
<a name="ln4244">{</a>
<a name="ln4245">	uint16_t *w = &amp;sc-&gt;sched[qid * IWN5000_SCHED_COUNT + idx];</a>
<a name="ln4246"> </a>
<a name="ln4247">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln4248"> </a>
<a name="ln4249">	*w = (*w &amp; htole16(0xf000)) | htole16(1);</a>
<a name="ln4250">	bus_dmamap_sync(sc-&gt;sched_dma.tag, sc-&gt;sched_dma.map,</a>
<a name="ln4251">	    BUS_DMASYNC_PREWRITE);</a>
<a name="ln4252">	if (idx &lt; IWN_SCHED_WINSZ) {</a>
<a name="ln4253">		*(w + IWN_TX_RING_COUNT) = *w;</a>
<a name="ln4254">		bus_dmamap_sync(sc-&gt;sched_dma.tag, sc-&gt;sched_dma.map,</a>
<a name="ln4255">		    BUS_DMASYNC_PREWRITE);</a>
<a name="ln4256">	}</a>
<a name="ln4257">}</a>
<a name="ln4258">#endif</a>
<a name="ln4259"> </a>
<a name="ln4260">/*</a>
<a name="ln4261"> * Check whether OFDM 11g protection will be enabled for the given rate.</a>
<a name="ln4262"> *</a>
<a name="ln4263"> * The original driver code only enabled protection for OFDM rates.</a>
<a name="ln4264"> * It didn't check to see whether it was operating in 11a or 11bg mode.</a>
<a name="ln4265"> */</a>
<a name="ln4266">static int</a>
<a name="ln4267">iwn_check_rate_needs_protection(struct iwn_softc *sc,</a>
<a name="ln4268">    struct ieee80211vap *vap, uint8_t rate)</a>
<a name="ln4269">{</a>
<a name="ln4270">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln4271"> </a>
<a name="ln4272">	/*</a>
<a name="ln4273">	 * Not in 2GHz mode? Then there's no need to enable OFDM</a>
<a name="ln4274">	 * 11bg protection.</a>
<a name="ln4275">	 */</a>
<a name="ln4276">	if (! IEEE80211_IS_CHAN_2GHZ(ic-&gt;ic_curchan)) {</a>
<a name="ln4277">		return (0);</a>
<a name="ln4278">	}</a>
<a name="ln4279"> </a>
<a name="ln4280">	/*</a>
<a name="ln4281">	 * 11bg protection not enabled? Then don't use it.</a>
<a name="ln4282">	 */</a>
<a name="ln4283">	if ((ic-&gt;ic_flags &amp; IEEE80211_F_USEPROT) == 0)</a>
<a name="ln4284">		return (0);</a>
<a name="ln4285"> </a>
<a name="ln4286">	/*</a>
<a name="ln4287">	 * If it's an 11n rate - no protection.</a>
<a name="ln4288">	 * We'll do it via a specific 11n check.</a>
<a name="ln4289">	 */</a>
<a name="ln4290">	if (rate &amp; IEEE80211_RATE_MCS) {</a>
<a name="ln4291">		return (0);</a>
<a name="ln4292">	}</a>
<a name="ln4293"> </a>
<a name="ln4294">	/*</a>
<a name="ln4295">	 * Do a rate table lookup.  If the PHY is CCK,</a>
<a name="ln4296">	 * don't do protection.</a>
<a name="ln4297">	 */</a>
<a name="ln4298">	if (ieee80211_rate2phytype(ic-&gt;ic_rt, rate) == IEEE80211_T_CCK)</a>
<a name="ln4299">		return (0);</a>
<a name="ln4300"> </a>
<a name="ln4301">	/*</a>
<a name="ln4302">	 * Yup, enable protection.</a>
<a name="ln4303">	 */</a>
<a name="ln4304">	return (1);</a>
<a name="ln4305">}</a>
<a name="ln4306"> </a>
<a name="ln4307">/*</a>
<a name="ln4308"> * return a value between 0 and IWN_MAX_TX_RETRIES-1 as an index into</a>
<a name="ln4309"> * the link quality table that reflects this particular entry.</a>
<a name="ln4310"> */</a>
<a name="ln4311">static int</a>
<a name="ln4312">iwn_tx_rate_to_linkq_offset(struct iwn_softc *sc, struct ieee80211_node *ni,</a>
<a name="ln4313">    uint8_t rate)</a>
<a name="ln4314">{</a>
<a name="ln4315">	struct ieee80211_rateset *rs;</a>
<a name="ln4316">	int is_11n;</a>
<a name="ln4317">	int nr;</a>
<a name="ln4318">	int i;</a>
<a name="ln4319">	uint8_t cmp_rate;</a>
<a name="ln4320"> </a>
<a name="ln4321">	/*</a>
<a name="ln4322">	 * Figure out if we're using 11n or not here.</a>
<a name="ln4323">	 */</a>
<a name="ln4324">	if (IEEE80211_IS_CHAN_HT(ni-&gt;ni_chan) &amp;&amp; ni-&gt;ni_htrates.rs_nrates &gt; 0)</a>
<a name="ln4325">		is_11n = 1;</a>
<a name="ln4326">	else</a>
<a name="ln4327">		is_11n = 0;</a>
<a name="ln4328"> </a>
<a name="ln4329">	/*</a>
<a name="ln4330">	 * Use the correct rate table.</a>
<a name="ln4331">	 */</a>
<a name="ln4332">	if (is_11n) {</a>
<a name="ln4333">		rs = (struct ieee80211_rateset *) &amp;ni-&gt;ni_htrates;</a>
<a name="ln4334">		nr = ni-&gt;ni_htrates.rs_nrates;</a>
<a name="ln4335">	} else {</a>
<a name="ln4336">		rs = &amp;ni-&gt;ni_rates;</a>
<a name="ln4337">		nr = rs-&gt;rs_nrates;</a>
<a name="ln4338">	}</a>
<a name="ln4339"> </a>
<a name="ln4340">	/*</a>
<a name="ln4341">	 * Find the relevant link quality entry in the table.</a>
<a name="ln4342">	 */</a>
<a name="ln4343">	for (i = 0; i &lt; nr &amp;&amp; i &lt; IWN_MAX_TX_RETRIES - 1 ; i++) {</a>
<a name="ln4344">		/*</a>
<a name="ln4345">		 * The link quality table index starts at 0 == highest</a>
<a name="ln4346">		 * rate, so we walk the rate table backwards.</a>
<a name="ln4347">		 */</a>
<a name="ln4348">		cmp_rate = rs-&gt;rs_rates[(nr - 1) - i];</a>
<a name="ln4349">		if (rate &amp; IEEE80211_RATE_MCS)</a>
<a name="ln4350">			cmp_rate |= IEEE80211_RATE_MCS;</a>
<a name="ln4351"> </a>
<a name="ln4352">#if 0</a>
<a name="ln4353">		DPRINTF(sc, IWN_DEBUG_XMIT, &quot;%s: idx %d: nr=%d, rate=0x%02x, rateentry=0x%02x\n&quot;,</a>
<a name="ln4354">		    __func__,</a>
<a name="ln4355">		    i,</a>
<a name="ln4356">		    nr,</a>
<a name="ln4357">		    rate,</a>
<a name="ln4358">		    cmp_rate);</a>
<a name="ln4359">#endif</a>
<a name="ln4360"> </a>
<a name="ln4361">		if (cmp_rate == rate)</a>
<a name="ln4362">			return (i);</a>
<a name="ln4363">	}</a>
<a name="ln4364"> </a>
<a name="ln4365">	/* Failed? Start at the end */</a>
<a name="ln4366">	return (IWN_MAX_TX_RETRIES - 1);</a>
<a name="ln4367">}</a>
<a name="ln4368"> </a>
<a name="ln4369">static int</a>
<a name="ln4370">iwn_tx_data(struct iwn_softc *sc, struct mbuf *m, struct ieee80211_node *ni)</a>
<a name="ln4371">{</a>
<a name="ln4372">	const struct ieee80211_txparam *tp = ni-&gt;ni_txparms;</a>
<a name="ln4373">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln4374">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln4375">	struct iwn_node *wn = (void *)ni;</a>
<a name="ln4376">	struct iwn_tx_ring *ring;</a>
<a name="ln4377">	struct iwn_tx_cmd *cmd;</a>
<a name="ln4378">	struct iwn_cmd_data *tx;</a>
<a name="ln4379">	struct ieee80211_frame *wh;</a>
<a name="ln4380">	struct ieee80211_key *k = NULL;</a>
<a name="ln4381">	uint32_t flags;</a>
<a name="ln4382">	uint16_t seqno, qos;</a>
<a name="ln4383">	uint8_t tid, type;</a>
<a name="ln4384">	int ac, totlen, rate;</a>
<a name="ln4385"> </a>
<a name="ln4386">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln4387"> </a>
<a name="ln4388">	IWN_LOCK_ASSERT(sc);</a>
<a name="ln4389"> </a>
<a name="ln4390">	wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln4391">	type = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_TYPE_MASK;</a>
<a name="ln4392"> </a>
<a name="ln4393">	/* Select EDCA Access Category and TX ring for this frame. */</a>
<a name="ln4394">	if (IEEE80211_QOS_HAS_SEQ(wh)) {</a>
<a name="ln4395">		qos = ((const struct ieee80211_qosframe *)wh)-&gt;i_qos[0];</a>
<a name="ln4396">		tid = qos &amp; IEEE80211_QOS_TID;</a>
<a name="ln4397">	} else {</a>
<a name="ln4398">		qos = 0;</a>
<a name="ln4399">		tid = 0;</a>
<a name="ln4400">	}</a>
<a name="ln4401"> </a>
<a name="ln4402">	/* Choose a TX rate index. */</a>
<a name="ln4403">	if (type == IEEE80211_FC0_TYPE_MGT ||</a>
<a name="ln4404">	    type == IEEE80211_FC0_TYPE_CTL ||</a>
<a name="ln4405">	    (m-&gt;m_flags &amp; M_EAPOL) != 0)</a>
<a name="ln4406">		rate = tp-&gt;mgmtrate;</a>
<a name="ln4407">	else if (IEEE80211_IS_MULTICAST(wh-&gt;i_addr1))</a>
<a name="ln4408">		rate = tp-&gt;mcastrate;</a>
<a name="ln4409">	else if (tp-&gt;ucastrate != IEEE80211_FIXED_RATE_NONE)</a>
<a name="ln4410">		rate = tp-&gt;ucastrate;</a>
<a name="ln4411">	else {</a>
<a name="ln4412">		/* XXX pass pktlen */</a>
<a name="ln4413">		(void) ieee80211_ratectl_rate(ni, NULL, 0);</a>
<a name="ln4414">		rate = ni-&gt;ni_txrate;</a>
<a name="ln4415">	}</a>
<a name="ln4416"> </a>
<a name="ln4417">	/*</a>
<a name="ln4418">	 * XXX TODO: Group addressed frames aren't aggregated and must</a>
<a name="ln4419">	 * go to the normal non-aggregation queue, and have a NONQOS TID</a>
<a name="ln4420">	 * assigned from net80211.</a>
<a name="ln4421">	 */</a>
<a name="ln4422"> </a>
<a name="ln4423">	ac = M_WME_GETAC(m);</a>
<a name="ln4424">	seqno = ni-&gt;ni_txseqs[tid];</a>
<a name="ln4425">	if (m-&gt;m_flags &amp; M_AMPDU_MPDU) {</a>
<a name="ln4426">		struct ieee80211_tx_ampdu *tap = &amp;ni-&gt;ni_tx_ampdu[ac];</a>
<a name="ln4427"> </a>
<a name="ln4428">		if (!IEEE80211_AMPDU_RUNNING(tap)) {</a>
<a name="ln4429">			return (EINVAL);</a>
<a name="ln4430">		}</a>
<a name="ln4431"> </a>
<a name="ln4432">		/*</a>
<a name="ln4433">		 * Queue this frame to the hardware ring that we've</a>
<a name="ln4434">		 * negotiated AMPDU TX on.</a>
<a name="ln4435">		 *</a>
<a name="ln4436">		 * Note that the sequence number must match the TX slot</a>
<a name="ln4437">		 * being used!</a>
<a name="ln4438">		 */</a>
<a name="ln4439">		ac = *(int *)tap-&gt;txa_private;</a>
<a name="ln4440">		*(uint16_t *)wh-&gt;i_seq =</a>
<a name="ln4441">		    htole16(seqno &lt;&lt; IEEE80211_SEQ_SEQ_SHIFT);</a>
<a name="ln4442">		ni-&gt;ni_txseqs[tid]++;</a>
<a name="ln4443">	}</a>
<a name="ln4444"> </a>
<a name="ln4445">	/* Encrypt the frame if need be. */</a>
<a name="ln4446">	if (wh-&gt;i_fc[1] &amp; IEEE80211_FC1_PROTECTED) {</a>
<a name="ln4447">		/* Retrieve key for TX. */</a>
<a name="ln4448">		k = ieee80211_crypto_encap(ni, m);</a>
<a name="ln4449">		if (k == NULL) {</a>
<a name="ln4450">			return ENOBUFS;</a>
<a name="ln4451">		}</a>
<a name="ln4452">		/* 802.11 header may have moved. */</a>
<a name="ln4453">		wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln4454">	}</a>
<a name="ln4455">	totlen = m-&gt;m_pkthdr.len;</a>
<a name="ln4456"> </a>
<a name="ln4457">	if (ieee80211_radiotap_active_vap(vap)) {</a>
<a name="ln4458">		struct iwn_tx_radiotap_header *tap = &amp;sc-&gt;sc_txtap;</a>
<a name="ln4459"> </a>
<a name="ln4460">		tap-&gt;wt_flags = 0;</a>
<a name="ln4461">		tap-&gt;wt_rate = rate;</a>
<a name="ln4462">		if (k != NULL)</a>
<a name="ln4463">			tap-&gt;wt_flags |= IEEE80211_RADIOTAP_F_WEP;</a>
<a name="ln4464"> </a>
<a name="ln4465">		ieee80211_radiotap_tx(vap, m);</a>
<a name="ln4466">	}</a>
<a name="ln4467"> </a>
<a name="ln4468">	flags = 0;</a>
<a name="ln4469">	if (!IEEE80211_IS_MULTICAST(wh-&gt;i_addr1)) {</a>
<a name="ln4470">		/* Unicast frame, check if an ACK is expected. */</a>
<a name="ln4471">		if (!qos || (qos &amp; IEEE80211_QOS_ACKPOLICY) !=</a>
<a name="ln4472">		    IEEE80211_QOS_ACKPOLICY_NOACK)</a>
<a name="ln4473">			flags |= IWN_TX_NEED_ACK;</a>
<a name="ln4474">	}</a>
<a name="ln4475">	if ((wh-&gt;i_fc[0] &amp;</a>
<a name="ln4476">	    (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_MASK)) ==</a>
<a name="ln4477">	    (IEEE80211_FC0_TYPE_CTL | IEEE80211_FC0_SUBTYPE_BAR))</a>
<a name="ln4478">		flags |= IWN_TX_IMM_BA;		/* Cannot happen yet. */</a>
<a name="ln4479"> </a>
<a name="ln4480">	if (wh-&gt;i_fc[1] &amp; IEEE80211_FC1_MORE_FRAG)</a>
<a name="ln4481">		flags |= IWN_TX_MORE_FRAG;	/* Cannot happen yet. */</a>
<a name="ln4482"> </a>
<a name="ln4483">	/* Check if frame must be protected using RTS/CTS or CTS-to-self. */</a>
<a name="ln4484">	if (!IEEE80211_IS_MULTICAST(wh-&gt;i_addr1)) {</a>
<a name="ln4485">		/* NB: Group frames are sent using CCK in 802.11b/g. */</a>
<a name="ln4486">		if (totlen + IEEE80211_CRC_LEN &gt; vap-&gt;iv_rtsthreshold) {</a>
<a name="ln4487">			flags |= IWN_TX_NEED_RTS;</a>
<a name="ln4488">		} else if (iwn_check_rate_needs_protection(sc, vap, rate)) {</a>
<a name="ln4489">			if (ic-&gt;ic_protmode == IEEE80211_PROT_CTSONLY)</a>
<a name="ln4490">				flags |= IWN_TX_NEED_CTS;</a>
<a name="ln4491">			else if (ic-&gt;ic_protmode == IEEE80211_PROT_RTSCTS)</a>
<a name="ln4492">				flags |= IWN_TX_NEED_RTS;</a>
<a name="ln4493">		} else if ((rate &amp; IEEE80211_RATE_MCS) &amp;&amp;</a>
<a name="ln4494">			(ic-&gt;ic_htprotmode == IEEE80211_PROT_RTSCTS)) {</a>
<a name="ln4495">			flags |= IWN_TX_NEED_RTS;</a>
<a name="ln4496">		}</a>
<a name="ln4497"> </a>
<a name="ln4498">		/* XXX HT protection? */</a>
<a name="ln4499"> </a>
<a name="ln4500">		if (flags &amp; (IWN_TX_NEED_RTS | IWN_TX_NEED_CTS)) {</a>
<a name="ln4501">			if (sc-&gt;hw_type != IWN_HW_REV_TYPE_4965) {</a>
<a name="ln4502">				/* 5000 autoselects RTS/CTS or CTS-to-self. */</a>
<a name="ln4503">				flags &amp;= ~(IWN_TX_NEED_RTS | IWN_TX_NEED_CTS);</a>
<a name="ln4504">				flags |= IWN_TX_NEED_PROTECTION;</a>
<a name="ln4505">			} else</a>
<a name="ln4506">				flags |= IWN_TX_FULL_TXOP;</a>
<a name="ln4507">		}</a>
<a name="ln4508">	}</a>
<a name="ln4509"> </a>
<a name="ln4510">	ring = &amp;sc-&gt;txq[ac];</a>
<a name="ln4511">	if ((m-&gt;m_flags &amp; M_AMPDU_MPDU) != 0 &amp;&amp;</a>
<a name="ln4512">	    (seqno % 256) != ring-&gt;cur) {</a>
<a name="ln4513">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln4514">		    &quot;%s: m=%p: seqno (%d) (%d) != ring index (%d) !\n&quot;,</a>
<a name="ln4515">		    __func__,</a>
<a name="ln4516">		    m,</a>
<a name="ln4517">		    seqno,</a>
<a name="ln4518">		    seqno % 256,</a>
<a name="ln4519">		    ring-&gt;cur);</a>
<a name="ln4520">	}</a>
<a name="ln4521"> </a>
<a name="ln4522">	/* Prepare TX firmware command. */</a>
<a name="ln4523">	cmd = &amp;ring-&gt;cmd[ring-&gt;cur];</a>
<a name="ln4524">	tx = (struct iwn_cmd_data *)cmd-&gt;data;</a>
<a name="ln4525"> </a>
<a name="ln4526">	/* NB: No need to clear tx, all fields are reinitialized here. */</a>
<a name="ln4527">	tx-&gt;scratch = 0;	/* clear &quot;scratch&quot; area */</a>
<a name="ln4528"> </a>
<a name="ln4529">	if (IEEE80211_IS_MULTICAST(wh-&gt;i_addr1) ||</a>
<a name="ln4530">	    type != IEEE80211_FC0_TYPE_DATA)</a>
<a name="ln4531">		tx-&gt;id = sc-&gt;broadcast_id;</a>
<a name="ln4532">	else</a>
<a name="ln4533">		tx-&gt;id = wn-&gt;id;</a>
<a name="ln4534"> </a>
<a name="ln4535">	if (type == IEEE80211_FC0_TYPE_MGT) {</a>
<a name="ln4536">		uint8_t subtype = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_SUBTYPE_MASK;</a>
<a name="ln4537"> </a>
<a name="ln4538">		/* Tell HW to set timestamp in probe responses. */</a>
<a name="ln4539">		if (subtype == IEEE80211_FC0_SUBTYPE_PROBE_RESP)</a>
<a name="ln4540">			flags |= IWN_TX_INSERT_TSTAMP;</a>
<a name="ln4541">		if (subtype == IEEE80211_FC0_SUBTYPE_ASSOC_REQ ||</a>
<a name="ln4542">		    subtype == IEEE80211_FC0_SUBTYPE_REASSOC_REQ)</a>
<a name="ln4543">			tx-&gt;timeout = htole16(3);</a>
<a name="ln4544">		else</a>
<a name="ln4545">			tx-&gt;timeout = htole16(2);</a>
<a name="ln4546">	} else</a>
<a name="ln4547">		tx-&gt;timeout = htole16(0);</a>
<a name="ln4548"> </a>
<a name="ln4549">	if (tx-&gt;id == sc-&gt;broadcast_id) {</a>
<a name="ln4550">		/* Group or management frame. */</a>
<a name="ln4551">		tx-&gt;linkq = 0;</a>
<a name="ln4552">	} else {</a>
<a name="ln4553">		tx-&gt;linkq = iwn_tx_rate_to_linkq_offset(sc, ni, rate);</a>
<a name="ln4554">		flags |= IWN_TX_LINKQ;	/* enable MRR */</a>
<a name="ln4555">	}</a>
<a name="ln4556"> </a>
<a name="ln4557">	tx-&gt;tid = tid;</a>
<a name="ln4558">	tx-&gt;rts_ntries = 60;</a>
<a name="ln4559">	tx-&gt;data_ntries = 15;</a>
<a name="ln4560">	tx-&gt;lifetime = htole32(IWN_LIFETIME_INFINITE);</a>
<a name="ln4561">	tx-&gt;rate = iwn_rate_to_plcp(sc, ni, rate);</a>
<a name="ln4562">	tx-&gt;security = 0;</a>
<a name="ln4563">	tx-&gt;flags = htole32(flags);</a>
<a name="ln4564"> </a>
<a name="ln4565">	return (iwn_tx_cmd(sc, m, ni, ring));</a>
<a name="ln4566">}</a>
<a name="ln4567"> </a>
<a name="ln4568">static int</a>
<a name="ln4569">iwn_tx_data_raw(struct iwn_softc *sc, struct mbuf *m,</a>
<a name="ln4570">    struct ieee80211_node *ni, const struct ieee80211_bpf_params *params)</a>
<a name="ln4571">{</a>
<a name="ln4572">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln4573">	struct iwn_tx_cmd *cmd;</a>
<a name="ln4574">	struct iwn_cmd_data *tx;</a>
<a name="ln4575">	struct ieee80211_frame *wh;</a>
<a name="ln4576">	struct iwn_tx_ring *ring;</a>
<a name="ln4577">	uint32_t flags;</a>
<a name="ln4578">	int ac, rate;</a>
<a name="ln4579">	uint8_t type;</a>
<a name="ln4580"> </a>
<a name="ln4581">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln4582"> </a>
<a name="ln4583">	IWN_LOCK_ASSERT(sc);</a>
<a name="ln4584"> </a>
<a name="ln4585">	wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln4586">	type = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_TYPE_MASK;</a>
<a name="ln4587"> </a>
<a name="ln4588">	ac = params-&gt;ibp_pri &amp; 3;</a>
<a name="ln4589"> </a>
<a name="ln4590">	/* Choose a TX rate. */</a>
<a name="ln4591">	rate = params-&gt;ibp_rate0;</a>
<a name="ln4592"> </a>
<a name="ln4593">	flags = 0;</a>
<a name="ln4594">	if ((params-&gt;ibp_flags &amp; IEEE80211_BPF_NOACK) == 0)</a>
<a name="ln4595">		flags |= IWN_TX_NEED_ACK;</a>
<a name="ln4596">	if (params-&gt;ibp_flags &amp; IEEE80211_BPF_RTS) {</a>
<a name="ln4597">		if (sc-&gt;hw_type != IWN_HW_REV_TYPE_4965) {</a>
<a name="ln4598">			/* 5000 autoselects RTS/CTS or CTS-to-self. */</a>
<a name="ln4599">			flags &amp;= ~IWN_TX_NEED_RTS;</a>
<a name="ln4600">			flags |= IWN_TX_NEED_PROTECTION;</a>
<a name="ln4601">		} else</a>
<a name="ln4602">			flags |= IWN_TX_NEED_RTS | IWN_TX_FULL_TXOP;</a>
<a name="ln4603">	}</a>
<a name="ln4604">	if (params-&gt;ibp_flags &amp; IEEE80211_BPF_CTS) {</a>
<a name="ln4605">		if (sc-&gt;hw_type != IWN_HW_REV_TYPE_4965) {</a>
<a name="ln4606">			/* 5000 autoselects RTS/CTS or CTS-to-self. */</a>
<a name="ln4607">			flags &amp;= ~IWN_TX_NEED_CTS;</a>
<a name="ln4608">			flags |= IWN_TX_NEED_PROTECTION;</a>
<a name="ln4609">		} else</a>
<a name="ln4610">			flags |= IWN_TX_NEED_CTS | IWN_TX_FULL_TXOP;</a>
<a name="ln4611">	}</a>
<a name="ln4612"> </a>
<a name="ln4613">	if (ieee80211_radiotap_active_vap(vap)) {</a>
<a name="ln4614">		struct iwn_tx_radiotap_header *tap = &amp;sc-&gt;sc_txtap;</a>
<a name="ln4615"> </a>
<a name="ln4616">		tap-&gt;wt_flags = 0;</a>
<a name="ln4617">		tap-&gt;wt_rate = rate;</a>
<a name="ln4618"> </a>
<a name="ln4619">		ieee80211_radiotap_tx(vap, m);</a>
<a name="ln4620">	}</a>
<a name="ln4621"> </a>
<a name="ln4622">	ring = &amp;sc-&gt;txq[ac];</a>
<a name="ln4623">	cmd = &amp;ring-&gt;cmd[ring-&gt;cur];</a>
<a name="ln4624"> </a>
<a name="ln4625">	tx = (struct iwn_cmd_data *)cmd-&gt;data;</a>
<a name="ln4626">	/* NB: No need to clear tx, all fields are reinitialized here. */</a>
<a name="ln4627">	tx-&gt;scratch = 0;	/* clear &quot;scratch&quot; area */</a>
<a name="ln4628"> </a>
<a name="ln4629">	if (type == IEEE80211_FC0_TYPE_MGT) {</a>
<a name="ln4630">		uint8_t subtype = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_SUBTYPE_MASK;</a>
<a name="ln4631"> </a>
<a name="ln4632">		/* Tell HW to set timestamp in probe responses. */</a>
<a name="ln4633">		if (subtype == IEEE80211_FC0_SUBTYPE_PROBE_RESP)</a>
<a name="ln4634">			flags |= IWN_TX_INSERT_TSTAMP;</a>
<a name="ln4635"> </a>
<a name="ln4636">		if (subtype == IEEE80211_FC0_SUBTYPE_ASSOC_REQ ||</a>
<a name="ln4637">		    subtype == IEEE80211_FC0_SUBTYPE_REASSOC_REQ)</a>
<a name="ln4638">			tx-&gt;timeout = htole16(3);</a>
<a name="ln4639">		else</a>
<a name="ln4640">			tx-&gt;timeout = htole16(2);</a>
<a name="ln4641">	} else</a>
<a name="ln4642">		tx-&gt;timeout = htole16(0);</a>
<a name="ln4643"> </a>
<a name="ln4644">	tx-&gt;tid = 0;</a>
<a name="ln4645">	tx-&gt;id = sc-&gt;broadcast_id;</a>
<a name="ln4646">	tx-&gt;rts_ntries = params-&gt;ibp_try1;</a>
<a name="ln4647">	tx-&gt;data_ntries = params-&gt;ibp_try0;</a>
<a name="ln4648">	tx-&gt;lifetime = htole32(IWN_LIFETIME_INFINITE);</a>
<a name="ln4649">	tx-&gt;rate = iwn_rate_to_plcp(sc, ni, rate);</a>
<a name="ln4650">	tx-&gt;security = 0;</a>
<a name="ln4651">	tx-&gt;flags = htole32(flags);</a>
<a name="ln4652"> </a>
<a name="ln4653">	/* Group or management frame. */</a>
<a name="ln4654">	tx-&gt;linkq = 0;</a>
<a name="ln4655"> </a>
<a name="ln4656">	return (iwn_tx_cmd(sc, m, ni, ring));</a>
<a name="ln4657">}</a>
<a name="ln4658"> </a>
<a name="ln4659">static int</a>
<a name="ln4660">iwn_tx_cmd(struct iwn_softc *sc, struct mbuf *m, struct ieee80211_node *ni,</a>
<a name="ln4661">    struct iwn_tx_ring *ring)</a>
<a name="ln4662">{</a>
<a name="ln4663">	struct iwn_ops *ops = &amp;sc-&gt;ops;</a>
<a name="ln4664">	struct iwn_tx_cmd *cmd;</a>
<a name="ln4665">	struct iwn_cmd_data *tx;</a>
<a name="ln4666">	struct ieee80211_frame *wh;</a>
<a name="ln4667">	struct iwn_tx_desc *desc;</a>
<a name="ln4668">	struct iwn_tx_data *data;</a>
<a name="ln4669">	bus_dma_segment_t *seg, segs[IWN_MAX_SCATTER];</a>
<a name="ln4670">	struct mbuf *m1;</a>
<a name="ln4671">	u_int hdrlen;</a>
<a name="ln4672">	int totlen, error, pad, nsegs = 0, i;</a>
<a name="ln4673"> </a>
<a name="ln4674">	wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln4675">	hdrlen = ieee80211_anyhdrsize(wh);</a>
<a name="ln4676">	totlen = m-&gt;m_pkthdr.len;</a>
<a name="ln4677"> </a>
<a name="ln4678">	desc = &amp;ring-&gt;desc[ring-&gt;cur];</a>
<a name="ln4679">	data = &amp;ring-&gt;data[ring-&gt;cur];</a>
<a name="ln4680"> </a>
<a name="ln4681">	/* Prepare TX firmware command. */</a>
<a name="ln4682">	cmd = &amp;ring-&gt;cmd[ring-&gt;cur];</a>
<a name="ln4683">	cmd-&gt;code = IWN_CMD_TX_DATA;</a>
<a name="ln4684">	cmd-&gt;flags = 0;</a>
<a name="ln4685">	cmd-&gt;qid = ring-&gt;qid;</a>
<a name="ln4686">	cmd-&gt;idx = ring-&gt;cur;</a>
<a name="ln4687"> </a>
<a name="ln4688">	tx = (struct iwn_cmd_data *)cmd-&gt;data;</a>
<a name="ln4689">	tx-&gt;len = htole16(totlen);</a>
<a name="ln4690"> </a>
<a name="ln4691">	/* Set physical address of &quot;scratch area&quot;. */</a>
<a name="ln4692">	tx-&gt;loaddr = htole32(IWN_LOADDR(data-&gt;scratch_paddr));</a>
<a name="ln4693">	tx-&gt;hiaddr = IWN_HIADDR(data-&gt;scratch_paddr);</a>
<a name="ln4694">	if (hdrlen &amp; 3) {</a>
<a name="ln4695">		/* First segment length must be a multiple of 4. */</a>
<a name="ln4696">		tx-&gt;flags |= htole32(IWN_TX_NEED_PADDING);</a>
<a name="ln4697">		pad = 4 - (hdrlen &amp; 3);</a>
<a name="ln4698">	} else</a>
<a name="ln4699">		pad = 0;</a>
<a name="ln4700"> </a>
<a name="ln4701">	/* Copy 802.11 header in TX command. */</a>
<a name="ln4702">	memcpy((uint8_t *)(tx + 1), wh, hdrlen);</a>
<a name="ln4703"> </a>
<a name="ln4704">	/* Trim 802.11 header. */</a>
<a name="ln4705">	m_adj(m, hdrlen);</a>
<a name="ln4706"> </a>
<a name="ln4707">	error = bus_dmamap_load_mbuf_sg(ring-&gt;data_dmat, data-&gt;map, m, segs,</a>
<a name="ln4708">	    &amp;nsegs, BUS_DMA_NOWAIT);</a>
<a name="ln4709">	if (error != 0) {</a>
<a name="ln4710">		if (error != EFBIG) {</a>
<a name="ln4711">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln4712">			    &quot;%s: can't map mbuf (error %d)\n&quot;, __func__, error);</a>
<a name="ln4713">			return error;</a>
<a name="ln4714">		}</a>
<a name="ln4715">		/* Too many DMA segments, linearize mbuf. */</a>
<a name="ln4716">		m1 = m_collapse(m, M_NOWAIT, IWN_MAX_SCATTER - 1);</a>
<a name="ln4717">		if (m1 == NULL) {</a>
<a name="ln4718">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln4719">			    &quot;%s: could not defrag mbuf\n&quot;, __func__);</a>
<a name="ln4720">			return ENOBUFS;</a>
<a name="ln4721">		}</a>
<a name="ln4722">		m = m1;</a>
<a name="ln4723"> </a>
<a name="ln4724">		error = bus_dmamap_load_mbuf_sg(ring-&gt;data_dmat, data-&gt;map, m,</a>
<a name="ln4725">		    segs, &amp;nsegs, BUS_DMA_NOWAIT);</a>
<a name="ln4726">		if (error != 0) {</a>
<a name="ln4727">			/* XXX fix this */</a>
<a name="ln4728">			/*</a>
<a name="ln4729">			 * NB: Do not return error;</a>
<a name="ln4730">			 * original mbuf does not exist anymore.</a>
<a name="ln4731">			 */</a>
<a name="ln4732">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln4733">			    &quot;%s: can't map mbuf (error %d)\n&quot;,</a>
<a name="ln4734">			    __func__, error);</a>
<a name="ln4735">			if_inc_counter(ni-&gt;ni_vap-&gt;iv_ifp,</a>
<a name="ln4736">			    IFCOUNTER_OERRORS, 1);</a>
<a name="ln4737">			ieee80211_free_node(ni);</a>
<a name="ln4738">			m_freem(m);</a>
<a name="ln4739">			return 0;</a>
<a name="ln4740">		}</a>
<a name="ln4741">	}</a>
<a name="ln4742"> </a>
<a name="ln4743">	data-&gt;m = m;</a>
<a name="ln4744">	data-&gt;ni = ni;</a>
<a name="ln4745"> </a>
<a name="ln4746">	DPRINTF(sc, IWN_DEBUG_XMIT, &quot;%s: qid %d idx %d len %d nsegs %d &quot;</a>
<a name="ln4747">	    &quot;plcp %d\n&quot;,</a>
<a name="ln4748">	    __func__, ring-&gt;qid, ring-&gt;cur, totlen, nsegs, tx-&gt;rate);</a>
<a name="ln4749"> </a>
<a name="ln4750">	/* Fill TX descriptor. */</a>
<a name="ln4751">	desc-&gt;nsegs = 1;</a>
<a name="ln4752">	if (m-&gt;m_len != 0)</a>
<a name="ln4753">		desc-&gt;nsegs += nsegs;</a>
<a name="ln4754">	/* First DMA segment is used by the TX command. */</a>
<a name="ln4755">	desc-&gt;segs[0].addr = htole32(IWN_LOADDR(data-&gt;cmd_paddr));</a>
<a name="ln4756">	desc-&gt;segs[0].len  = htole16(IWN_HIADDR(data-&gt;cmd_paddr) |</a>
<a name="ln4757">	    (4 + sizeof (*tx) + hdrlen + pad) &lt;&lt; 4);</a>
<a name="ln4758">	/* Other DMA segments are for data payload. */</a>
<a name="ln4759">	seg = &amp;segs[0];</a>
<a name="ln4760">	for (i = 1; i &lt;= nsegs; i++) {</a>
<a name="ln4761">		desc-&gt;segs[i].addr = htole32(IWN_LOADDR(seg-&gt;ds_addr));</a>
<a name="ln4762">		desc-&gt;segs[i].len  = htole16(IWN_HIADDR(seg-&gt;ds_addr) |</a>
<a name="ln4763">		    seg-&gt;ds_len &lt;&lt; 4);</a>
<a name="ln4764">		seg++;</a>
<a name="ln4765">	}</a>
<a name="ln4766"> </a>
<a name="ln4767">	bus_dmamap_sync(ring-&gt;data_dmat, data-&gt;map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln4768">	bus_dmamap_sync(ring-&gt;cmd_dma.tag, ring-&gt;cmd_dma.map,</a>
<a name="ln4769">	    BUS_DMASYNC_PREWRITE);</a>
<a name="ln4770">	bus_dmamap_sync(ring-&gt;desc_dma.tag, ring-&gt;desc_dma.map,</a>
<a name="ln4771">	    BUS_DMASYNC_PREWRITE);</a>
<a name="ln4772"> </a>
<a name="ln4773">	/* Update TX scheduler. */</a>
<a name="ln4774">	if (ring-&gt;qid &gt;= sc-&gt;firstaggqueue)</a>
<a name="ln4775">		ops-&gt;update_sched(sc, ring-&gt;qid, ring-&gt;cur, tx-&gt;id, totlen);</a>
<a name="ln4776"> </a>
<a name="ln4777">	/* Kick TX ring. */</a>
<a name="ln4778">	ring-&gt;cur = (ring-&gt;cur + 1) % IWN_TX_RING_COUNT;</a>
<a name="ln4779">	IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, ring-&gt;qid &lt;&lt; 8 | ring-&gt;cur);</a>
<a name="ln4780"> </a>
<a name="ln4781">	/* Mark TX ring as full if we reach a certain threshold. */</a>
<a name="ln4782">	if (++ring-&gt;queued &gt; IWN_TX_RING_HIMARK)</a>
<a name="ln4783">		sc-&gt;qfullmsk |= 1 &lt;&lt; ring-&gt;qid;</a>
<a name="ln4784"> </a>
<a name="ln4785">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: end\n&quot;,__func__);</a>
<a name="ln4786"> </a>
<a name="ln4787">	return 0;</a>
<a name="ln4788">}</a>
<a name="ln4789"> </a>
<a name="ln4790">static void</a>
<a name="ln4791">iwn_xmit_task(void *arg0, int pending)</a>
<a name="ln4792">{</a>
<a name="ln4793">	struct iwn_softc *sc = arg0;</a>
<a name="ln4794">	struct ieee80211_node *ni;</a>
<a name="ln4795">	struct mbuf *m;</a>
<a name="ln4796">	int error;</a>
<a name="ln4797">	struct ieee80211_bpf_params p;</a>
<a name="ln4798">	int have_p;</a>
<a name="ln4799"> </a>
<a name="ln4800">	DPRINTF(sc, IWN_DEBUG_XMIT, &quot;%s: called\n&quot;, __func__);</a>
<a name="ln4801"> </a>
<a name="ln4802">	IWN_LOCK(sc);</a>
<a name="ln4803">	/*</a>
<a name="ln4804">	 * Dequeue frames, attempt to transmit,</a>
<a name="ln4805">	 * then disable beaconwait when we're done.</a>
<a name="ln4806">	 */</a>
<a name="ln4807">	while ((m = mbufq_dequeue(&amp;sc-&gt;sc_xmit_queue)) != NULL) {</a>
<a name="ln4808">		have_p = 0;</a>
<a name="ln4809">		ni = (struct ieee80211_node *)m-&gt;m_pkthdr.rcvif;</a>
<a name="ln4810"> </a>
<a name="ln4811">		/* Get xmit params if appropriate */</a>
<a name="ln4812">		if (ieee80211_get_xmit_params(m, &amp;p) == 0)</a>
<a name="ln4813">			have_p = 1;</a>
<a name="ln4814"> </a>
<a name="ln4815">		DPRINTF(sc, IWN_DEBUG_XMIT, &quot;%s: m=%p, have_p=%d\n&quot;,</a>
<a name="ln4816">		    __func__, m, have_p);</a>
<a name="ln4817"> </a>
<a name="ln4818">		/* If we have xmit params, use them */</a>
<a name="ln4819">		if (have_p)</a>
<a name="ln4820">			error = iwn_tx_data_raw(sc, m, ni, &amp;p);</a>
<a name="ln4821">		else</a>
<a name="ln4822">			error = iwn_tx_data(sc, m, ni);</a>
<a name="ln4823"> </a>
<a name="ln4824">		if (error != 0) {</a>
<a name="ln4825">			if_inc_counter(ni-&gt;ni_vap-&gt;iv_ifp,</a>
<a name="ln4826">			    IFCOUNTER_OERRORS, 1);</a>
<a name="ln4827">			ieee80211_free_node(ni);</a>
<a name="ln4828">			m_freem(m);</a>
<a name="ln4829">		}</a>
<a name="ln4830">	}</a>
<a name="ln4831"> </a>
<a name="ln4832">	sc-&gt;sc_beacon_wait = 0;</a>
<a name="ln4833">	IWN_UNLOCK(sc);</a>
<a name="ln4834">}</a>
<a name="ln4835"> </a>
<a name="ln4836">/*</a>
<a name="ln4837"> * raw frame xmit - free node/reference if failed.</a>
<a name="ln4838"> */</a>
<a name="ln4839">static int</a>
<a name="ln4840">iwn_raw_xmit(struct ieee80211_node *ni, struct mbuf *m,</a>
<a name="ln4841">    const struct ieee80211_bpf_params *params)</a>
<a name="ln4842">{</a>
<a name="ln4843">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln4844">	struct iwn_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln4845">	int error = 0;</a>
<a name="ln4846"> </a>
<a name="ln4847">	DPRINTF(sc, IWN_DEBUG_XMIT | IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln4848"> </a>
<a name="ln4849">	IWN_LOCK(sc);</a>
<a name="ln4850">	if ((sc-&gt;sc_flags &amp; IWN_FLAG_RUNNING) == 0) {</a>
<a name="ln4851">		m_freem(m);</a>
<a name="ln4852">		IWN_UNLOCK(sc);</a>
<a name="ln4853">		return (ENETDOWN);</a>
<a name="ln4854">	}</a>
<a name="ln4855"> </a>
<a name="ln4856">	/* queue frame if we have to */</a>
<a name="ln4857">	if (sc-&gt;sc_beacon_wait) {</a>
<a name="ln4858">		if (iwn_xmit_queue_enqueue(sc, m) != 0) {</a>
<a name="ln4859">			m_freem(m);</a>
<a name="ln4860">			IWN_UNLOCK(sc);</a>
<a name="ln4861">			return (ENOBUFS);</a>
<a name="ln4862">		}</a>
<a name="ln4863">		/* Queued, so just return OK */</a>
<a name="ln4864">		IWN_UNLOCK(sc);</a>
<a name="ln4865">		return (0);</a>
<a name="ln4866">	}</a>
<a name="ln4867"> </a>
<a name="ln4868">	if (params == NULL) {</a>
<a name="ln4869">		/*</a>
<a name="ln4870">		 * Legacy path; interpret frame contents to decide</a>
<a name="ln4871">		 * precisely how to send the frame.</a>
<a name="ln4872">		 */</a>
<a name="ln4873">		error = iwn_tx_data(sc, m, ni);</a>
<a name="ln4874">	} else {</a>
<a name="ln4875">		/*</a>
<a name="ln4876">		 * Caller supplied explicit parameters to use in</a>
<a name="ln4877">		 * sending the frame.</a>
<a name="ln4878">		 */</a>
<a name="ln4879">		error = iwn_tx_data_raw(sc, m, ni, params);</a>
<a name="ln4880">	}</a>
<a name="ln4881">	if (error == 0)</a>
<a name="ln4882">		sc-&gt;sc_tx_timer = 5;</a>
<a name="ln4883">	else</a>
<a name="ln4884">		m_freem(m);</a>
<a name="ln4885"> </a>
<a name="ln4886">	IWN_UNLOCK(sc);</a>
<a name="ln4887"> </a>
<a name="ln4888">	DPRINTF(sc, IWN_DEBUG_TRACE | IWN_DEBUG_XMIT, &quot;-&gt;%s: end\n&quot;,__func__);</a>
<a name="ln4889"> </a>
<a name="ln4890">	return (error);</a>
<a name="ln4891">}</a>
<a name="ln4892"> </a>
<a name="ln4893">/*</a>
<a name="ln4894"> * transmit - don't free mbuf if failed; don't free node ref if failed.</a>
<a name="ln4895"> */</a>
<a name="ln4896">static int</a>
<a name="ln4897">iwn_transmit(struct ieee80211com *ic, struct mbuf *m)</a>
<a name="ln4898">{</a>
<a name="ln4899">	struct iwn_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln4900">	struct ieee80211_node *ni;</a>
<a name="ln4901">	int error;</a>
<a name="ln4902"> </a>
<a name="ln4903">	ni = (struct ieee80211_node *)m-&gt;m_pkthdr.rcvif;</a>
<a name="ln4904"> </a>
<a name="ln4905">	IWN_LOCK(sc);</a>
<a name="ln4906">	if ((sc-&gt;sc_flags &amp; IWN_FLAG_RUNNING) == 0 || sc-&gt;sc_beacon_wait) {</a>
<a name="ln4907">		IWN_UNLOCK(sc);</a>
<a name="ln4908">		return (ENXIO);</a>
<a name="ln4909">	}</a>
<a name="ln4910"> </a>
<a name="ln4911">	if (sc-&gt;qfullmsk) {</a>
<a name="ln4912">		IWN_UNLOCK(sc);</a>
<a name="ln4913">		return (ENOBUFS);</a>
<a name="ln4914">	}</a>
<a name="ln4915"> </a>
<a name="ln4916">	error = iwn_tx_data(sc, m, ni);</a>
<a name="ln4917">	if (!error)</a>
<a name="ln4918">		sc-&gt;sc_tx_timer = 5;</a>
<a name="ln4919">	IWN_UNLOCK(sc);</a>
<a name="ln4920">	return (error);</a>
<a name="ln4921">}</a>
<a name="ln4922"> </a>
<a name="ln4923">static void</a>
<a name="ln4924">iwn_scan_timeout(void *arg)</a>
<a name="ln4925">{</a>
<a name="ln4926">	struct iwn_softc *sc = arg;</a>
<a name="ln4927">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln4928"> </a>
<a name="ln4929">	ic_printf(ic, &quot;scan timeout\n&quot;);</a>
<a name="ln4930">	ieee80211_restart_all(ic);</a>
<a name="ln4931">}</a>
<a name="ln4932"> </a>
<a name="ln4933">static void</a>
<a name="ln4934">iwn_watchdog(void *arg)</a>
<a name="ln4935">{</a>
<a name="ln4936">	struct iwn_softc *sc = arg;</a>
<a name="ln4937">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln4938"> </a>
<a name="ln4939">	IWN_LOCK_ASSERT(sc);</a>
<a name="ln4940"> </a>
<a name="ln4941">	KASSERT(sc-&gt;sc_flags &amp; IWN_FLAG_RUNNING, (&quot;not running&quot;));</a>
<a name="ln4942"> </a>
<a name="ln4943">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln4944"> </a>
<a name="ln4945">	if (sc-&gt;sc_tx_timer &gt; 0) {</a>
<a name="ln4946">		if (--sc-&gt;sc_tx_timer == 0) {</a>
<a name="ln4947">			ic_printf(ic, &quot;device timeout\n&quot;);</a>
<a name="ln4948">			ieee80211_restart_all(ic);</a>
<a name="ln4949">			return;</a>
<a name="ln4950">		}</a>
<a name="ln4951">	}</a>
<a name="ln4952">	callout_reset(&amp;sc-&gt;watchdog_to, hz, iwn_watchdog, sc);</a>
<a name="ln4953">}</a>
<a name="ln4954"> </a>
<a name="ln4955">static int</a>
<a name="ln4956">iwn_cdev_open(struct cdev *dev, int flags, int type, struct thread *td)</a>
<a name="ln4957">{</a>
<a name="ln4958"> </a>
<a name="ln4959">	return (0);</a>
<a name="ln4960">}</a>
<a name="ln4961"> </a>
<a name="ln4962">static int</a>
<a name="ln4963">iwn_cdev_close(struct cdev *dev, int flags, int type, struct thread *td)</a>
<a name="ln4964">{</a>
<a name="ln4965"> </a>
<a name="ln4966">	return (0);</a>
<a name="ln4967">}</a>
<a name="ln4968"> </a>
<a name="ln4969">#ifndef __HAIKU__</a>
<a name="ln4970">static int</a>
<a name="ln4971">iwn_cdev_ioctl(struct cdev *dev, unsigned long cmd, caddr_t data, int fflag,</a>
<a name="ln4972">    struct thread *td)</a>
<a name="ln4973">{</a>
<a name="ln4974">	int rc;</a>
<a name="ln4975">	struct iwn_softc *sc = dev-&gt;si_drv1;</a>
<a name="ln4976">	struct iwn_ioctl_data *d;</a>
<a name="ln4977"> </a>
<a name="ln4978">	rc = priv_check(td, PRIV_DRIVER);</a>
<a name="ln4979">	if (rc != 0)</a>
<a name="ln4980">		return (0);</a>
<a name="ln4981"> </a>
<a name="ln4982">	switch (cmd) {</a>
<a name="ln4983">	case SIOCGIWNSTATS:</a>
<a name="ln4984">		d = (struct iwn_ioctl_data *) data;</a>
<a name="ln4985">		IWN_LOCK(sc);</a>
<a name="ln4986">		/* XXX validate permissions/memory/etc? */</a>
<a name="ln4987">		rc = copyout(&amp;sc-&gt;last_stat, d-&gt;dst_addr, sizeof(struct iwn_stats));</a>
<a name="ln4988">		IWN_UNLOCK(sc);</a>
<a name="ln4989">		break;</a>
<a name="ln4990">	case SIOCZIWNSTATS:</a>
<a name="ln4991">		IWN_LOCK(sc);</a>
<a name="ln4992">		memset(&amp;sc-&gt;last_stat, 0, sizeof(struct iwn_stats));</a>
<a name="ln4993">		IWN_UNLOCK(sc);</a>
<a name="ln4994">		break;</a>
<a name="ln4995">	default:</a>
<a name="ln4996">		rc = EINVAL;</a>
<a name="ln4997">		break;</a>
<a name="ln4998">	}</a>
<a name="ln4999">	return (rc);</a>
<a name="ln5000">}</a>
<a name="ln5001">#endif</a>
<a name="ln5002"> </a>
<a name="ln5003">static int</a>
<a name="ln5004">iwn_ioctl(struct ieee80211com *ic, u_long cmd, void *data)</a>
<a name="ln5005">{</a>
<a name="ln5006"> </a>
<a name="ln5007">	return (ENOTTY);</a>
<a name="ln5008">}</a>
<a name="ln5009"> </a>
<a name="ln5010">static void</a>
<a name="ln5011">iwn_parent(struct ieee80211com *ic)</a>
<a name="ln5012">{</a>
<a name="ln5013">	struct iwn_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln5014">	struct ieee80211vap *vap;</a>
<a name="ln5015">	int error;</a>
<a name="ln5016"> </a>
<a name="ln5017">	if (ic-&gt;ic_nrunning &gt; 0) {</a>
<a name="ln5018">		error = iwn_init(sc);</a>
<a name="ln5019"> </a>
<a name="ln5020">		switch (error) {</a>
<a name="ln5021">		case 0:</a>
<a name="ln5022">			ieee80211_start_all(ic);</a>
<a name="ln5023">			break;</a>
<a name="ln5024">		case 1:</a>
<a name="ln5025">			/* radio is disabled via RFkill switch */</a>
<a name="ln5026">			taskqueue_enqueue(sc-&gt;sc_tq, &amp;sc-&gt;sc_rftoggle_task);</a>
<a name="ln5027">			break;</a>
<a name="ln5028">		default:</a>
<a name="ln5029">			vap = TAILQ_FIRST(&amp;ic-&gt;ic_vaps);</a>
<a name="ln5030">			if (vap != NULL)</a>
<a name="ln5031">				ieee80211_stop(vap);</a>
<a name="ln5032">			break;</a>
<a name="ln5033">		}</a>
<a name="ln5034">	} else</a>
<a name="ln5035">		iwn_stop(sc);</a>
<a name="ln5036">}</a>
<a name="ln5037"> </a>
<a name="ln5038">/*</a>
<a name="ln5039"> * Send a command to the firmware.</a>
<a name="ln5040"> */</a>
<a name="ln5041">static int</a>
<a name="ln5042">iwn_cmd(struct iwn_softc *sc, int code, const void *buf, int size, int async)</a>
<a name="ln5043">{</a>
<a name="ln5044">	struct iwn_tx_ring *ring;</a>
<a name="ln5045">	struct iwn_tx_desc *desc;</a>
<a name="ln5046">	struct iwn_tx_data *data;</a>
<a name="ln5047">	struct iwn_tx_cmd *cmd;</a>
<a name="ln5048">	struct mbuf *m;</a>
<a name="ln5049">	bus_addr_t paddr;</a>
<a name="ln5050">	int totlen, error;</a>
<a name="ln5051">	int cmd_queue_num;</a>
<a name="ln5052"> </a>
<a name="ln5053">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln5054"> </a>
<a name="ln5055">	if (async == 0)</a>
<a name="ln5056">		IWN_LOCK_ASSERT(sc);</a>
<a name="ln5057"> </a>
<a name="ln5058">	if (sc-&gt;sc_flags &amp; IWN_FLAG_PAN_SUPPORT)</a>
<a name="ln5059">		cmd_queue_num = IWN_PAN_CMD_QUEUE;</a>
<a name="ln5060">	else</a>
<a name="ln5061">		cmd_queue_num = IWN_CMD_QUEUE_NUM;</a>
<a name="ln5062"> </a>
<a name="ln5063">	ring = &amp;sc-&gt;txq[cmd_queue_num];</a>
<a name="ln5064">	desc = &amp;ring-&gt;desc[ring-&gt;cur];</a>
<a name="ln5065">	data = &amp;ring-&gt;data[ring-&gt;cur];</a>
<a name="ln5066">	totlen = 4 + size;</a>
<a name="ln5067"> </a>
<a name="ln5068">	if (size &gt; sizeof cmd-&gt;data) {</a>
<a name="ln5069">		/* Command is too large to fit in a descriptor. */</a>
<a name="ln5070">		if (totlen &gt; MCLBYTES)</a>
<a name="ln5071">			return EINVAL;</a>
<a name="ln5072">		m = m_getjcl(M_NOWAIT, MT_DATA, M_PKTHDR, MJUMPAGESIZE);</a>
<a name="ln5073">		if (m == NULL)</a>
<a name="ln5074">			return ENOMEM;</a>
<a name="ln5075">		cmd = mtod(m, struct iwn_tx_cmd *);</a>
<a name="ln5076">		error = bus_dmamap_load(ring-&gt;data_dmat, data-&gt;map, cmd,</a>
<a name="ln5077">		    totlen, iwn_dma_map_addr, &amp;paddr, BUS_DMA_NOWAIT);</a>
<a name="ln5078">		if (error != 0) {</a>
<a name="ln5079">			m_freem(m);</a>
<a name="ln5080">			return error;</a>
<a name="ln5081">		}</a>
<a name="ln5082">		data-&gt;m = m;</a>
<a name="ln5083">	} else {</a>
<a name="ln5084">		cmd = &amp;ring-&gt;cmd[ring-&gt;cur];</a>
<a name="ln5085">		paddr = data-&gt;cmd_paddr;</a>
<a name="ln5086">	}</a>
<a name="ln5087"> </a>
<a name="ln5088">	cmd-&gt;code = code;</a>
<a name="ln5089">	cmd-&gt;flags = 0;</a>
<a name="ln5090">	cmd-&gt;qid = ring-&gt;qid;</a>
<a name="ln5091">	cmd-&gt;idx = ring-&gt;cur;</a>
<a name="ln5092">	memcpy(cmd-&gt;data, buf, size);</a>
<a name="ln5093"> </a>
<a name="ln5094">	desc-&gt;nsegs = 1;</a>
<a name="ln5095">	desc-&gt;segs[0].addr = htole32(IWN_LOADDR(paddr));</a>
<a name="ln5096">	desc-&gt;segs[0].len  = htole16(IWN_HIADDR(paddr) | totlen &lt;&lt; 4);</a>
<a name="ln5097"> </a>
<a name="ln5098">	DPRINTF(sc, IWN_DEBUG_CMD, &quot;%s: %s (0x%x) flags %d qid %d idx %d\n&quot;,</a>
<a name="ln5099">	    __func__, iwn_intr_str(cmd-&gt;code), cmd-&gt;code,</a>
<a name="ln5100">	    cmd-&gt;flags, cmd-&gt;qid, cmd-&gt;idx);</a>
<a name="ln5101"> </a>
<a name="ln5102">	if (size &gt; sizeof cmd-&gt;data) {</a>
<a name="ln5103">		bus_dmamap_sync(ring-&gt;data_dmat, data-&gt;map,</a>
<a name="ln5104">		    BUS_DMASYNC_PREWRITE);</a>
<a name="ln5105">	} else {</a>
<a name="ln5106">		bus_dmamap_sync(ring-&gt;cmd_dma.tag, ring-&gt;cmd_dma.map,</a>
<a name="ln5107">		    BUS_DMASYNC_PREWRITE);</a>
<a name="ln5108">	}</a>
<a name="ln5109">	bus_dmamap_sync(ring-&gt;desc_dma.tag, ring-&gt;desc_dma.map,</a>
<a name="ln5110">	    BUS_DMASYNC_PREWRITE);</a>
<a name="ln5111"> </a>
<a name="ln5112">	/* Kick command ring. */</a>
<a name="ln5113">	ring-&gt;cur = (ring-&gt;cur + 1) % IWN_TX_RING_COUNT;</a>
<a name="ln5114">	IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, ring-&gt;qid &lt;&lt; 8 | ring-&gt;cur);</a>
<a name="ln5115"> </a>
<a name="ln5116">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: end\n&quot;,__func__);</a>
<a name="ln5117"> </a>
<a name="ln5118">	return async ? 0 : msleep(desc, &amp;sc-&gt;sc_mtx, PCATCH, &quot;iwncmd&quot;, hz);</a>
<a name="ln5119">}</a>
<a name="ln5120"> </a>
<a name="ln5121">static int</a>
<a name="ln5122">iwn4965_add_node(struct iwn_softc *sc, struct iwn_node_info *node, int async)</a>
<a name="ln5123">{</a>
<a name="ln5124">	struct iwn4965_node_info hnode;</a>
<a name="ln5125">	caddr_t src, dst;</a>
<a name="ln5126"> </a>
<a name="ln5127">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln5128"> </a>
<a name="ln5129">	/*</a>
<a name="ln5130">	 * We use the node structure for 5000 Series internally (it is</a>
<a name="ln5131">	 * a superset of the one for 4965AGN). We thus copy the common</a>
<a name="ln5132">	 * fields before sending the command.</a>
<a name="ln5133">	 */</a>
<a name="ln5134">	src = (caddr_t)node;</a>
<a name="ln5135">	dst = (caddr_t)&amp;hnode;</a>
<a name="ln5136">	memcpy(dst, src, 48);</a>
<a name="ln5137">	/* Skip TSC, RX MIC and TX MIC fields from ``src''. */</a>
<a name="ln5138">	memcpy(dst + 48, src + 72, 20);</a>
<a name="ln5139">	return iwn_cmd(sc, IWN_CMD_ADD_NODE, &amp;hnode, sizeof hnode, async);</a>
<a name="ln5140">}</a>
<a name="ln5141"> </a>
<a name="ln5142">static int</a>
<a name="ln5143">iwn5000_add_node(struct iwn_softc *sc, struct iwn_node_info *node, int async)</a>
<a name="ln5144">{</a>
<a name="ln5145"> </a>
<a name="ln5146">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln5147"> </a>
<a name="ln5148">	/* Direct mapping. */</a>
<a name="ln5149">	return iwn_cmd(sc, IWN_CMD_ADD_NODE, node, sizeof (*node), async);</a>
<a name="ln5150">}</a>
<a name="ln5151"> </a>
<a name="ln5152">static int</a>
<a name="ln5153">iwn_set_link_quality(struct iwn_softc *sc, struct ieee80211_node *ni)</a>
<a name="ln5154">{</a>
<a name="ln5155">	struct iwn_node *wn = (void *)ni;</a>
<a name="ln5156">	struct ieee80211_rateset *rs;</a>
<a name="ln5157">	struct iwn_cmd_link_quality linkq;</a>
<a name="ln5158">	int i, rate, txrate;</a>
<a name="ln5159">	int is_11n;</a>
<a name="ln5160"> </a>
<a name="ln5161">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln5162"> </a>
<a name="ln5163">	memset(&amp;linkq, 0, sizeof linkq);</a>
<a name="ln5164">	linkq.id = wn-&gt;id;</a>
<a name="ln5165">	linkq.antmsk_1stream = iwn_get_1stream_tx_antmask(sc);</a>
<a name="ln5166">	linkq.antmsk_2stream = iwn_get_2stream_tx_antmask(sc);</a>
<a name="ln5167"> </a>
<a name="ln5168">	linkq.ampdu_max = 32;		/* XXX negotiated? */</a>
<a name="ln5169">	linkq.ampdu_threshold = 3;</a>
<a name="ln5170">	linkq.ampdu_limit = htole16(4000);	/* 4ms */</a>
<a name="ln5171"> </a>
<a name="ln5172">	DPRINTF(sc, IWN_DEBUG_XMIT,</a>
<a name="ln5173">	    &quot;%s: 1stream antenna=0x%02x, 2stream antenna=0x%02x, ntxstreams=%d\n&quot;,</a>
<a name="ln5174">	    __func__,</a>
<a name="ln5175">	    linkq.antmsk_1stream,</a>
<a name="ln5176">	    linkq.antmsk_2stream,</a>
<a name="ln5177">	    sc-&gt;ntxchains);</a>
<a name="ln5178"> </a>
<a name="ln5179">	/*</a>
<a name="ln5180">	 * Are we using 11n rates? Ensure the channel is</a>
<a name="ln5181">	 * 11n _and_ we have some 11n rates, or don't</a>
<a name="ln5182">	 * try.</a>
<a name="ln5183">	 */</a>
<a name="ln5184">	if (IEEE80211_IS_CHAN_HT(ni-&gt;ni_chan) &amp;&amp; ni-&gt;ni_htrates.rs_nrates &gt; 0) {</a>
<a name="ln5185">		rs = (struct ieee80211_rateset *) &amp;ni-&gt;ni_htrates;</a>
<a name="ln5186">		is_11n = 1;</a>
<a name="ln5187">	} else {</a>
<a name="ln5188">		rs = &amp;ni-&gt;ni_rates;</a>
<a name="ln5189">		is_11n = 0;</a>
<a name="ln5190">	}</a>
<a name="ln5191"> </a>
<a name="ln5192">	/* Start at highest available bit-rate. */</a>
<a name="ln5193">	/*</a>
<a name="ln5194">	 * XXX this is all very dirty!</a>
<a name="ln5195">	 */</a>
<a name="ln5196">	if (is_11n)</a>
<a name="ln5197">		txrate = ni-&gt;ni_htrates.rs_nrates - 1;</a>
<a name="ln5198">	else</a>
<a name="ln5199">		txrate = rs-&gt;rs_nrates - 1;</a>
<a name="ln5200">	for (i = 0; i &lt; IWN_MAX_TX_RETRIES; i++) {</a>
<a name="ln5201">		uint32_t plcp;</a>
<a name="ln5202"> </a>
<a name="ln5203">		/*</a>
<a name="ln5204">		 * XXX TODO: ensure the last two slots are the two lowest</a>
<a name="ln5205">		 * rate entries, just for now.</a>
<a name="ln5206">		 */</a>
<a name="ln5207">		if (i == 14 || i == 15)</a>
<a name="ln5208">			txrate = 0;</a>
<a name="ln5209"> </a>
<a name="ln5210">		if (is_11n)</a>
<a name="ln5211">			rate = IEEE80211_RATE_MCS | rs-&gt;rs_rates[txrate];</a>
<a name="ln5212">		else</a>
<a name="ln5213">			rate = IEEE80211_RV(rs-&gt;rs_rates[txrate]);</a>
<a name="ln5214"> </a>
<a name="ln5215">		/* Do rate -&gt; PLCP config mapping */</a>
<a name="ln5216">		plcp = iwn_rate_to_plcp(sc, ni, rate);</a>
<a name="ln5217">		linkq.retry[i] = plcp;</a>
<a name="ln5218">		DPRINTF(sc, IWN_DEBUG_XMIT,</a>
<a name="ln5219">		    &quot;%s: i=%d, txrate=%d, rate=0x%02x, plcp=0x%08x\n&quot;,</a>
<a name="ln5220">		    __func__,</a>
<a name="ln5221">		    i,</a>
<a name="ln5222">		    txrate,</a>
<a name="ln5223">		    rate,</a>
<a name="ln5224">		    le32toh(plcp));</a>
<a name="ln5225"> </a>
<a name="ln5226">		/*</a>
<a name="ln5227">		 * The mimo field is an index into the table which</a>
<a name="ln5228">		 * indicates the first index where it and subsequent entries</a>
<a name="ln5229">		 * will not be using MIMO.</a>
<a name="ln5230">		 *</a>
<a name="ln5231">		 * Since we're filling linkq from 0..15 and we're filling</a>
<a name="ln5232">		 * from the highest MCS rates to the lowest rates, if we</a>
<a name="ln5233">		 * _are_ doing a dual-stream rate, set mimo to idx+1 (ie,</a>
<a name="ln5234">		 * the next entry.)  That way if the next entry is a non-MIMO</a>
<a name="ln5235">		 * entry, we're already pointing at it.</a>
<a name="ln5236">		 */</a>
<a name="ln5237">		if ((le32toh(plcp) &amp; IWN_RFLAG_MCS) &amp;&amp;</a>
<a name="ln5238">		    IEEE80211_RV(le32toh(plcp)) &gt; 7)</a>
<a name="ln5239">			linkq.mimo = i + 1;</a>
<a name="ln5240"> </a>
<a name="ln5241">		/* Next retry at immediate lower bit-rate. */</a>
<a name="ln5242">		if (txrate &gt; 0)</a>
<a name="ln5243">			txrate--;</a>
<a name="ln5244">	}</a>
<a name="ln5245">	/*</a>
<a name="ln5246">	 * If we reached the end of the list and indeed we hit</a>
<a name="ln5247">	 * all MIMO rates (eg 5300 doing MCS23-15) then yes,</a>
<a name="ln5248">	 * set mimo to 15.  Setting it to 16 panics the firmware.</a>
<a name="ln5249">	 */</a>
<a name="ln5250">	if (linkq.mimo &gt; 15)</a>
<a name="ln5251">		linkq.mimo = 15;</a>
<a name="ln5252"> </a>
<a name="ln5253">	DPRINTF(sc, IWN_DEBUG_XMIT, &quot;%s: mimo = %d\n&quot;, __func__, linkq.mimo);</a>
<a name="ln5254"> </a>
<a name="ln5255">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: end\n&quot;,__func__);</a>
<a name="ln5256"> </a>
<a name="ln5257">	return iwn_cmd(sc, IWN_CMD_LINK_QUALITY, &amp;linkq, sizeof linkq, 1);</a>
<a name="ln5258">}</a>
<a name="ln5259"> </a>
<a name="ln5260">/*</a>
<a name="ln5261"> * Broadcast node is used to send group-addressed and management frames.</a>
<a name="ln5262"> */</a>
<a name="ln5263">static int</a>
<a name="ln5264">iwn_add_broadcast_node(struct iwn_softc *sc, int async)</a>
<a name="ln5265">{</a>
<a name="ln5266">	struct iwn_ops *ops = &amp;sc-&gt;ops;</a>
<a name="ln5267">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln5268">	struct iwn_node_info node;</a>
<a name="ln5269">	struct iwn_cmd_link_quality linkq;</a>
<a name="ln5270">	uint8_t txant;</a>
<a name="ln5271">	int i, error;</a>
<a name="ln5272"> </a>
<a name="ln5273">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln5274"> </a>
<a name="ln5275">	sc-&gt;rxon = &amp;sc-&gt;rx_on[IWN_RXON_BSS_CTX];</a>
<a name="ln5276"> </a>
<a name="ln5277">	memset(&amp;node, 0, sizeof node);</a>
<a name="ln5278">	IEEE80211_ADDR_COPY(node.macaddr, ieee80211broadcastaddr);</a>
<a name="ln5279">	node.id = sc-&gt;broadcast_id;</a>
<a name="ln5280">	DPRINTF(sc, IWN_DEBUG_RESET, &quot;%s: adding broadcast node\n&quot;, __func__);</a>
<a name="ln5281">	if ((error = ops-&gt;add_node(sc, &amp;node, async)) != 0)</a>
<a name="ln5282">		return error;</a>
<a name="ln5283"> </a>
<a name="ln5284">	/* Use the first valid TX antenna. */</a>
<a name="ln5285">	txant = IWN_LSB(sc-&gt;txchainmask);</a>
<a name="ln5286"> </a>
<a name="ln5287">	memset(&amp;linkq, 0, sizeof linkq);</a>
<a name="ln5288">	linkq.id = sc-&gt;broadcast_id;</a>
<a name="ln5289">	linkq.antmsk_1stream = iwn_get_1stream_tx_antmask(sc);</a>
<a name="ln5290">	linkq.antmsk_2stream = iwn_get_2stream_tx_antmask(sc);</a>
<a name="ln5291">	linkq.ampdu_max = 64;</a>
<a name="ln5292">	linkq.ampdu_threshold = 3;</a>
<a name="ln5293">	linkq.ampdu_limit = htole16(4000);	/* 4ms */</a>
<a name="ln5294"> </a>
<a name="ln5295">	/* Use lowest mandatory bit-rate. */</a>
<a name="ln5296">	/* XXX rate table lookup? */</a>
<a name="ln5297">	if (IEEE80211_IS_CHAN_5GHZ(ic-&gt;ic_curchan))</a>
<a name="ln5298">		linkq.retry[0] = htole32(0xd);</a>
<a name="ln5299">	else</a>
<a name="ln5300">		linkq.retry[0] = htole32(10 | IWN_RFLAG_CCK);</a>
<a name="ln5301">	linkq.retry[0] |= htole32(IWN_RFLAG_ANT(txant));</a>
<a name="ln5302">	/* Use same bit-rate for all TX retries. */</a>
<a name="ln5303">	for (i = 1; i &lt; IWN_MAX_TX_RETRIES; i++) {</a>
<a name="ln5304">		linkq.retry[i] = linkq.retry[0];</a>
<a name="ln5305">	}</a>
<a name="ln5306"> </a>
<a name="ln5307">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: end\n&quot;,__func__);</a>
<a name="ln5308"> </a>
<a name="ln5309">	return iwn_cmd(sc, IWN_CMD_LINK_QUALITY, &amp;linkq, sizeof linkq, async);</a>
<a name="ln5310">}</a>
<a name="ln5311"> </a>
<a name="ln5312">static int</a>
<a name="ln5313">iwn_updateedca(struct ieee80211com *ic)</a>
<a name="ln5314">{</a>
<a name="ln5315">#define IWN_EXP2(x)	((1 &lt;&lt; (x)) - 1)	/* CWmin = 2^ECWmin - 1 */</a>
<a name="ln5316">	struct iwn_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln5317">	struct iwn_edca_params cmd;</a>
<a name="ln5318">	struct chanAccParams chp;</a>
<a name="ln5319">	int aci;</a>
<a name="ln5320"> </a>
<a name="ln5321">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln5322"> </a>
<a name="ln5323">	ieee80211_wme_ic_getparams(ic, &amp;chp);</a>
<a name="ln5324"> </a>
<a name="ln5325">	memset(&amp;cmd, 0, sizeof cmd);</a>
<a name="ln5326">	cmd.flags = htole32(IWN_EDCA_UPDATE);</a>
<a name="ln5327"> </a>
<a name="ln5328">	IEEE80211_LOCK(ic);</a>
<a name="ln5329">	for (aci = 0; aci &lt; WME_NUM_AC; aci++) {</a>
<a name="ln5330">		const struct wmeParams *ac = &amp;chp.cap_wmeParams[aci];</a>
<a name="ln5331">		cmd.ac[aci].aifsn = ac-&gt;wmep_aifsn;</a>
<a name="ln5332">		cmd.ac[aci].cwmin = htole16(IWN_EXP2(ac-&gt;wmep_logcwmin));</a>
<a name="ln5333">		cmd.ac[aci].cwmax = htole16(IWN_EXP2(ac-&gt;wmep_logcwmax));</a>
<a name="ln5334">		cmd.ac[aci].txoplimit =</a>
<a name="ln5335">		    htole16(IEEE80211_TXOP_TO_US(ac-&gt;wmep_txopLimit));</a>
<a name="ln5336">	}</a>
<a name="ln5337">	IEEE80211_UNLOCK(ic);</a>
<a name="ln5338"> </a>
<a name="ln5339">	IWN_LOCK(sc);</a>
<a name="ln5340">	(void)iwn_cmd(sc, IWN_CMD_EDCA_PARAMS, &amp;cmd, sizeof cmd, 1);</a>
<a name="ln5341">	IWN_UNLOCK(sc);</a>
<a name="ln5342"> </a>
<a name="ln5343">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: end\n&quot;,__func__);</a>
<a name="ln5344"> </a>
<a name="ln5345">	return 0;</a>
<a name="ln5346">#undef IWN_EXP2</a>
<a name="ln5347">}</a>
<a name="ln5348"> </a>
<a name="ln5349">static void</a>
<a name="ln5350">iwn_set_promisc(struct iwn_softc *sc)</a>
<a name="ln5351">{</a>
<a name="ln5352">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln5353">	uint32_t promisc_filter;</a>
<a name="ln5354"> </a>
<a name="ln5355">	promisc_filter = IWN_FILTER_CTL | IWN_FILTER_PROMISC;</a>
<a name="ln5356">	if (ic-&gt;ic_promisc &gt; 0 || ic-&gt;ic_opmode == IEEE80211_M_MONITOR)</a>
<a name="ln5357">		sc-&gt;rxon-&gt;filter |= htole32(promisc_filter);</a>
<a name="ln5358">	else</a>
<a name="ln5359">		sc-&gt;rxon-&gt;filter &amp;= ~htole32(promisc_filter);</a>
<a name="ln5360">}</a>
<a name="ln5361"> </a>
<a name="ln5362">static void</a>
<a name="ln5363">iwn_update_promisc(struct ieee80211com *ic)</a>
<a name="ln5364">{</a>
<a name="ln5365">	struct iwn_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln5366">	int error;</a>
<a name="ln5367"> </a>
<a name="ln5368">	if (ic-&gt;ic_opmode == IEEE80211_M_MONITOR)</a>
<a name="ln5369">		return;		/* nothing to do */</a>
<a name="ln5370"> </a>
<a name="ln5371">	IWN_LOCK(sc);</a>
<a name="ln5372">	if (!(sc-&gt;sc_flags &amp; IWN_FLAG_RUNNING)) {</a>
<a name="ln5373">		IWN_UNLOCK(sc);</a>
<a name="ln5374">		return;</a>
<a name="ln5375">	}</a>
<a name="ln5376"> </a>
<a name="ln5377">	iwn_set_promisc(sc);</a>
<a name="ln5378">	if ((error = iwn_send_rxon(sc, 1, 1)) != 0) {</a>
<a name="ln5379">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln5380">		    &quot;%s: could not send RXON, error %d\n&quot;,</a>
<a name="ln5381">		    __func__, error);</a>
<a name="ln5382">	}</a>
<a name="ln5383">	IWN_UNLOCK(sc);</a>
<a name="ln5384">}</a>
<a name="ln5385"> </a>
<a name="ln5386">static void</a>
<a name="ln5387">iwn_update_mcast(struct ieee80211com *ic)</a>
<a name="ln5388">{</a>
<a name="ln5389">	/* Ignore */</a>
<a name="ln5390">}</a>
<a name="ln5391"> </a>
<a name="ln5392">static void</a>
<a name="ln5393">iwn_set_led(struct iwn_softc *sc, uint8_t which, uint8_t off, uint8_t on)</a>
<a name="ln5394">{</a>
<a name="ln5395">	struct iwn_cmd_led led;</a>
<a name="ln5396"> </a>
<a name="ln5397">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln5398"> </a>
<a name="ln5399">#if 0</a>
<a name="ln5400">	/* XXX don't set LEDs during scan? */</a>
<a name="ln5401">	if (sc-&gt;sc_is_scanning)</a>
<a name="ln5402">		return;</a>
<a name="ln5403">#endif</a>
<a name="ln5404"> </a>
<a name="ln5405">	/* Clear microcode LED ownership. */</a>
<a name="ln5406">	IWN_CLRBITS(sc, IWN_LED, IWN_LED_BSM_CTRL);</a>
<a name="ln5407"> </a>
<a name="ln5408">	led.which = which;</a>
<a name="ln5409">	led.unit = htole32(10000);	/* on/off in unit of 100ms */</a>
<a name="ln5410">	led.off = off;</a>
<a name="ln5411">	led.on = on;</a>
<a name="ln5412">	(void)iwn_cmd(sc, IWN_CMD_SET_LED, &amp;led, sizeof led, 1);</a>
<a name="ln5413">}</a>
<a name="ln5414"> </a>
<a name="ln5415">/*</a>
<a name="ln5416"> * Set the critical temperature at which the firmware will stop the radio</a>
<a name="ln5417"> * and notify us.</a>
<a name="ln5418"> */</a>
<a name="ln5419">static int</a>
<a name="ln5420">iwn_set_critical_temp(struct iwn_softc *sc)</a>
<a name="ln5421">{</a>
<a name="ln5422">	struct iwn_critical_temp crit;</a>
<a name="ln5423">	int32_t temp;</a>
<a name="ln5424"> </a>
<a name="ln5425">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln5426"> </a>
<a name="ln5427">	IWN_WRITE(sc, IWN_UCODE_GP1_CLR, IWN_UCODE_GP1_CTEMP_STOP_RF);</a>
<a name="ln5428"> </a>
<a name="ln5429">	if (sc-&gt;hw_type == IWN_HW_REV_TYPE_5150)</a>
<a name="ln5430">		temp = (IWN_CTOK(110) - sc-&gt;temp_off) * -5;</a>
<a name="ln5431">	else if (sc-&gt;hw_type == IWN_HW_REV_TYPE_4965)</a>
<a name="ln5432">		temp = IWN_CTOK(110);</a>
<a name="ln5433">	else</a>
<a name="ln5434">		temp = 110;</a>
<a name="ln5435">	memset(&amp;crit, 0, sizeof crit);</a>
<a name="ln5436">	crit.tempR = htole32(temp);</a>
<a name="ln5437">	DPRINTF(sc, IWN_DEBUG_RESET, &quot;setting critical temp to %d\n&quot;, temp);</a>
<a name="ln5438">	return iwn_cmd(sc, IWN_CMD_SET_CRITICAL_TEMP, &amp;crit, sizeof crit, 0);</a>
<a name="ln5439">}</a>
<a name="ln5440"> </a>
<a name="ln5441">static int</a>
<a name="ln5442">iwn_set_timing(struct iwn_softc *sc, struct ieee80211_node *ni)</a>
<a name="ln5443">{</a>
<a name="ln5444">	struct iwn_cmd_timing cmd;</a>
<a name="ln5445">	uint64_t val, mod;</a>
<a name="ln5446"> </a>
<a name="ln5447">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln5448"> </a>
<a name="ln5449">	memset(&amp;cmd, 0, sizeof cmd);</a>
<a name="ln5450">	memcpy(&amp;cmd.tstamp, ni-&gt;ni_tstamp.data, sizeof (uint64_t));</a>
<a name="ln5451">	cmd.bintval = htole16(ni-&gt;ni_intval);</a>
<a name="ln5452">	cmd.lintval = htole16(10);</a>
<a name="ln5453"> </a>
<a name="ln5454">	/* Compute remaining time until next beacon. */</a>
<a name="ln5455">	val = (uint64_t)ni-&gt;ni_intval * IEEE80211_DUR_TU;</a>
<a name="ln5456">	mod = le64toh(cmd.tstamp) % val;</a>
<a name="ln5457">	cmd.binitval = htole32((uint32_t)(val - mod));</a>
<a name="ln5458"> </a>
<a name="ln5459">	DPRINTF(sc, IWN_DEBUG_RESET, &quot;timing bintval=%u tstamp=%ju, init=%u\n&quot;,</a>
<a name="ln5460">	    ni-&gt;ni_intval, le64toh(cmd.tstamp), (uint32_t)(val - mod));</a>
<a name="ln5461"> </a>
<a name="ln5462">	return iwn_cmd(sc, IWN_CMD_TIMING, &amp;cmd, sizeof cmd, 1);</a>
<a name="ln5463">}</a>
<a name="ln5464"> </a>
<a name="ln5465">static void</a>
<a name="ln5466">iwn4965_power_calibration(struct iwn_softc *sc, int temp)</a>
<a name="ln5467">{</a>
<a name="ln5468"> </a>
<a name="ln5469">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln5470"> </a>
<a name="ln5471">	/* Adjust TX power if need be (delta &gt;= 3 degC). */</a>
<a name="ln5472">	DPRINTF(sc, IWN_DEBUG_CALIBRATE, &quot;%s: temperature %d-&gt;%d\n&quot;,</a>
<a name="ln5473">	    __func__, sc-&gt;temp, temp);</a>
<a name="ln5474">	if (abs(temp - sc-&gt;temp) &gt;= 3) {</a>
<a name="ln5475">		/* Record temperature of last calibration. */</a>
<a name="ln5476">		sc-&gt;temp = temp;</a>
<a name="ln5477">		(void)iwn4965_set_txpower(sc, 1);</a>
<a name="ln5478">	}</a>
<a name="ln5479">}</a>
<a name="ln5480"> </a>
<a name="ln5481">/*</a>
<a name="ln5482"> * Set TX power for current channel (each rate has its own power settings).</a>
<a name="ln5483"> * This function takes into account the regulatory information from EEPROM,</a>
<a name="ln5484"> * the current temperature and the current voltage.</a>
<a name="ln5485"> */</a>
<a name="ln5486">static int</a>
<a name="ln5487">iwn4965_set_txpower(struct iwn_softc *sc, int async)</a>
<a name="ln5488">{</a>
<a name="ln5489">/* Fixed-point arithmetic division using a n-bit fractional part. */</a>
<a name="ln5490">#define fdivround(a, b, n)	\</a>
<a name="ln5491">	((((1 &lt;&lt; n) * (a)) / (b) + (1 &lt;&lt; n) / 2) / (1 &lt;&lt; n))</a>
<a name="ln5492">/* Linear interpolation. */</a>
<a name="ln5493">#define interpolate(x, x1, y1, x2, y2, n)	\</a>
<a name="ln5494">	((y1) + fdivround(((int)(x) - (x1)) * ((y2) - (y1)), (x2) - (x1), n))</a>
<a name="ln5495"> </a>
<a name="ln5496">	static const int tdiv[IWN_NATTEN_GROUPS] = { 9, 8, 8, 8, 6 };</a>
<a name="ln5497">	struct iwn_ucode_info *uc = &amp;sc-&gt;ucode_info;</a>
<a name="ln5498">	struct iwn4965_cmd_txpower cmd;</a>
<a name="ln5499">	struct iwn4965_eeprom_chan_samples *chans;</a>
<a name="ln5500">	const uint8_t *rf_gain, *dsp_gain;</a>
<a name="ln5501">	int32_t vdiff, tdiff;</a>
<a name="ln5502">	int i, is_chan_5ghz, c, grp, maxpwr;</a>
<a name="ln5503">	uint8_t chan;</a>
<a name="ln5504"> </a>
<a name="ln5505">	sc-&gt;rxon = &amp;sc-&gt;rx_on[IWN_RXON_BSS_CTX];</a>
<a name="ln5506">	/* Retrieve current channel from last RXON. */</a>
<a name="ln5507">	chan = sc-&gt;rxon-&gt;chan;</a>
<a name="ln5508">	is_chan_5ghz = (sc-&gt;rxon-&gt;flags &amp; htole32(IWN_RXON_24GHZ)) == 0;</a>
<a name="ln5509">	DPRINTF(sc, IWN_DEBUG_RESET, &quot;setting TX power for channel %d\n&quot;,</a>
<a name="ln5510">	    chan);</a>
<a name="ln5511"> </a>
<a name="ln5512">	memset(&amp;cmd, 0, sizeof cmd);</a>
<a name="ln5513">	cmd.band = is_chan_5ghz ? 0 : 1;</a>
<a name="ln5514">	cmd.chan = chan;</a>
<a name="ln5515"> </a>
<a name="ln5516">	if (is_chan_5ghz) {</a>
<a name="ln5517">		maxpwr   = sc-&gt;maxpwr5GHz;</a>
<a name="ln5518">		rf_gain  = iwn4965_rf_gain_5ghz;</a>
<a name="ln5519">		dsp_gain = iwn4965_dsp_gain_5ghz;</a>
<a name="ln5520">	} else {</a>
<a name="ln5521">		maxpwr   = sc-&gt;maxpwr2GHz;</a>
<a name="ln5522">		rf_gain  = iwn4965_rf_gain_2ghz;</a>
<a name="ln5523">		dsp_gain = iwn4965_dsp_gain_2ghz;</a>
<a name="ln5524">	}</a>
<a name="ln5525"> </a>
<a name="ln5526">	/* Compute voltage compensation. */</a>
<a name="ln5527">	vdiff = ((int32_t)le32toh(uc-&gt;volt) - sc-&gt;eeprom_voltage) / 7;</a>
<a name="ln5528">	if (vdiff &gt; 0)</a>
<a name="ln5529">		vdiff *= 2;</a>
<a name="ln5530">	if (abs(vdiff) &gt; 2)</a>
<a name="ln5531">		vdiff = 0;</a>
<a name="ln5532">	DPRINTF(sc, IWN_DEBUG_CALIBRATE | IWN_DEBUG_TXPOW,</a>
<a name="ln5533">	    &quot;%s: voltage compensation=%d (UCODE=%d, EEPROM=%d)\n&quot;,</a>
<a name="ln5534">	    __func__, vdiff, le32toh(uc-&gt;volt), sc-&gt;eeprom_voltage);</a>
<a name="ln5535"> </a>
<a name="ln5536">	/* Get channel attenuation group. */</a>
<a name="ln5537">	if (chan &lt;= 20)		/* 1-20 */</a>
<a name="ln5538">		grp = 4;</a>
<a name="ln5539">	else if (chan &lt;= 43)	/* 34-43 */</a>
<a name="ln5540">		grp = 0;</a>
<a name="ln5541">	else if (chan &lt;= 70)	/* 44-70 */</a>
<a name="ln5542">		grp = 1;</a>
<a name="ln5543">	else if (chan &lt;= 124)	/* 71-124 */</a>
<a name="ln5544">		grp = 2;</a>
<a name="ln5545">	else			/* 125-200 */</a>
<a name="ln5546">		grp = 3;</a>
<a name="ln5547">	DPRINTF(sc, IWN_DEBUG_CALIBRATE | IWN_DEBUG_TXPOW,</a>
<a name="ln5548">	    &quot;%s: chan %d, attenuation group=%d\n&quot;, __func__, chan, grp);</a>
<a name="ln5549"> </a>
<a name="ln5550">	/* Get channel sub-band. */</a>
<a name="ln5551">	for (i = 0; i &lt; IWN_NBANDS; i++)</a>
<a name="ln5552">		if (sc-&gt;bands[i].lo != 0 &amp;&amp;</a>
<a name="ln5553">		    sc-&gt;bands[i].lo &lt;= chan &amp;&amp; chan &lt;= sc-&gt;bands[i].hi)</a>
<a name="ln5554">			break;</a>
<a name="ln5555">	if (i == IWN_NBANDS)	/* Can't happen in real-life. */</a>
<a name="ln5556">		return EINVAL;</a>
<a name="ln5557">	chans = sc-&gt;bands[i].chans;</a>
<a name="ln5558">	DPRINTF(sc, IWN_DEBUG_CALIBRATE | IWN_DEBUG_TXPOW,</a>
<a name="ln5559">	    &quot;%s: chan %d sub-band=%d\n&quot;, __func__, chan, i);</a>
<a name="ln5560"> </a>
<a name="ln5561">	for (c = 0; c &lt; 2; c++) {</a>
<a name="ln5562">		uint8_t power, gain, temp;</a>
<a name="ln5563">		int maxchpwr, pwr, ridx, idx;</a>
<a name="ln5564"> </a>
<a name="ln5565">		power = interpolate(chan,</a>
<a name="ln5566">		    chans[0].num, chans[0].samples[c][1].power,</a>
<a name="ln5567">		    chans[1].num, chans[1].samples[c][1].power, 1);</a>
<a name="ln5568">		gain  = interpolate(chan,</a>
<a name="ln5569">		    chans[0].num, chans[0].samples[c][1].gain,</a>
<a name="ln5570">		    chans[1].num, chans[1].samples[c][1].gain, 1);</a>
<a name="ln5571">		temp  = interpolate(chan,</a>
<a name="ln5572">		    chans[0].num, chans[0].samples[c][1].temp,</a>
<a name="ln5573">		    chans[1].num, chans[1].samples[c][1].temp, 1);</a>
<a name="ln5574">		DPRINTF(sc, IWN_DEBUG_CALIBRATE | IWN_DEBUG_TXPOW,</a>
<a name="ln5575">		    &quot;%s: Tx chain %d: power=%d gain=%d temp=%d\n&quot;,</a>
<a name="ln5576">		    __func__, c, power, gain, temp);</a>
<a name="ln5577"> </a>
<a name="ln5578">		/* Compute temperature compensation. */</a>
<a name="ln5579">		tdiff = ((sc-&gt;temp - temp) * 2) / tdiv[grp];</a>
<a name="ln5580">		DPRINTF(sc, IWN_DEBUG_CALIBRATE | IWN_DEBUG_TXPOW,</a>
<a name="ln5581">		    &quot;%s: temperature compensation=%d (current=%d, EEPROM=%d)\n&quot;,</a>
<a name="ln5582">		    __func__, tdiff, sc-&gt;temp, temp);</a>
<a name="ln5583"> </a>
<a name="ln5584">		for (ridx = 0; ridx &lt;= IWN_RIDX_MAX; ridx++) {</a>
<a name="ln5585">			/* Convert dBm to half-dBm. */</a>
<a name="ln5586">			maxchpwr = sc-&gt;maxpwr[chan] * 2;</a>
<a name="ln5587">			if ((ridx / 8) &amp; 1)</a>
<a name="ln5588">				maxchpwr -= 6;	/* MIMO 2T: -3dB */</a>
<a name="ln5589"> </a>
<a name="ln5590">			pwr = maxpwr;</a>
<a name="ln5591"> </a>
<a name="ln5592">			/* Adjust TX power based on rate. */</a>
<a name="ln5593">			if ((ridx % 8) == 5)</a>
<a name="ln5594">				pwr -= 15;	/* OFDM48: -7.5dB */</a>
<a name="ln5595">			else if ((ridx % 8) == 6)</a>
<a name="ln5596">				pwr -= 17;	/* OFDM54: -8.5dB */</a>
<a name="ln5597">			else if ((ridx % 8) == 7)</a>
<a name="ln5598">				pwr -= 20;	/* OFDM60: -10dB */</a>
<a name="ln5599">			else</a>
<a name="ln5600">				pwr -= 10;	/* Others: -5dB */</a>
<a name="ln5601"> </a>
<a name="ln5602">			/* Do not exceed channel max TX power. */</a>
<a name="ln5603">			if (pwr &gt; maxchpwr)</a>
<a name="ln5604">				pwr = maxchpwr;</a>
<a name="ln5605"> </a>
<a name="ln5606">			idx = gain - (pwr - power) - tdiff - vdiff;</a>
<a name="ln5607">			if ((ridx / 8) &amp; 1)	/* MIMO */</a>
<a name="ln5608">				idx += (int32_t)le32toh(uc-&gt;atten[grp][c]);</a>
<a name="ln5609"> </a>
<a name="ln5610">			if (cmd.band == 0)</a>
<a name="ln5611">				idx += 9;	/* 5GHz */</a>
<a name="ln5612">			if (ridx == IWN_RIDX_MAX)</a>
<a name="ln5613">				idx += 5;	/* CCK */</a>
<a name="ln5614"> </a>
<a name="ln5615">			/* Make sure idx stays in a valid range. */</a>
<a name="ln5616">			if (idx &lt; 0)</a>
<a name="ln5617">				idx = 0;</a>
<a name="ln5618">			else if (idx &gt; IWN4965_MAX_PWR_INDEX)</a>
<a name="ln5619">				idx = IWN4965_MAX_PWR_INDEX;</a>
<a name="ln5620"> </a>
<a name="ln5621">			DPRINTF(sc, IWN_DEBUG_CALIBRATE | IWN_DEBUG_TXPOW,</a>
<a name="ln5622">			    &quot;%s: Tx chain %d, rate idx %d: power=%d\n&quot;,</a>
<a name="ln5623">			    __func__, c, ridx, idx);</a>
<a name="ln5624">			cmd.power[ridx].rf_gain[c] = rf_gain[idx];</a>
<a name="ln5625">			cmd.power[ridx].dsp_gain[c] = dsp_gain[idx];</a>
<a name="ln5626">		}</a>
<a name="ln5627">	}</a>
<a name="ln5628"> </a>
<a name="ln5629">	DPRINTF(sc, IWN_DEBUG_CALIBRATE | IWN_DEBUG_TXPOW,</a>
<a name="ln5630">	    &quot;%s: set tx power for chan %d\n&quot;, __func__, chan);</a>
<a name="ln5631">	return iwn_cmd(sc, IWN_CMD_TXPOWER, &amp;cmd, sizeof cmd, async);</a>
<a name="ln5632"> </a>
<a name="ln5633">#undef interpolate</a>
<a name="ln5634">#undef fdivround</a>
<a name="ln5635">}</a>
<a name="ln5636"> </a>
<a name="ln5637">static int</a>
<a name="ln5638">iwn5000_set_txpower(struct iwn_softc *sc, int async)</a>
<a name="ln5639">{</a>
<a name="ln5640">	struct iwn5000_cmd_txpower cmd;</a>
<a name="ln5641">	int cmdid;</a>
<a name="ln5642"> </a>
<a name="ln5643">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln5644"> </a>
<a name="ln5645">	/*</a>
<a name="ln5646">	 * TX power calibration is handled automatically by the firmware</a>
<a name="ln5647">	 * for 5000 Series.</a>
<a name="ln5648">	 */</a>
<a name="ln5649">	memset(&amp;cmd, 0, sizeof cmd);</a>
<a name="ln5650">	cmd.global_limit = 2 * IWN5000_TXPOWER_MAX_DBM;	/* 16 dBm */</a>
<a name="ln5651">	cmd.flags = IWN5000_TXPOWER_NO_CLOSED;</a>
<a name="ln5652">	cmd.srv_limit = IWN5000_TXPOWER_AUTO;</a>
<a name="ln5653">	DPRINTF(sc, IWN_DEBUG_CALIBRATE | IWN_DEBUG_XMIT,</a>
<a name="ln5654">	    &quot;%s: setting TX power; rev=%d\n&quot;,</a>
<a name="ln5655">	    __func__,</a>
<a name="ln5656">	    IWN_UCODE_API(sc-&gt;ucode_rev));</a>
<a name="ln5657">	if (IWN_UCODE_API(sc-&gt;ucode_rev) == 1)</a>
<a name="ln5658">		cmdid = IWN_CMD_TXPOWER_DBM_V1;</a>
<a name="ln5659">	else</a>
<a name="ln5660">		cmdid = IWN_CMD_TXPOWER_DBM;</a>
<a name="ln5661">	return iwn_cmd(sc, cmdid, &amp;cmd, sizeof cmd, async);</a>
<a name="ln5662">}</a>
<a name="ln5663"> </a>
<a name="ln5664">/*</a>
<a name="ln5665"> * Retrieve the maximum RSSI (in dBm) among receivers.</a>
<a name="ln5666"> */</a>
<a name="ln5667">static int</a>
<a name="ln5668">iwn4965_get_rssi(struct iwn_softc *sc, struct iwn_rx_stat *stat)</a>
<a name="ln5669">{</a>
<a name="ln5670">	struct iwn4965_rx_phystat *phy = (void *)stat-&gt;phybuf;</a>
<a name="ln5671">	uint8_t mask, agc;</a>
<a name="ln5672">	int rssi;</a>
<a name="ln5673"> </a>
<a name="ln5674">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln5675"> </a>
<a name="ln5676">	mask = (le16toh(phy-&gt;antenna) &gt;&gt; 4) &amp; IWN_ANT_ABC;</a>
<a name="ln5677">	agc  = (le16toh(phy-&gt;agc) &gt;&gt; 7) &amp; 0x7f;</a>
<a name="ln5678"> </a>
<a name="ln5679">	rssi = 0;</a>
<a name="ln5680">	if (mask &amp; IWN_ANT_A)</a>
<a name="ln5681">		rssi = MAX(rssi, phy-&gt;rssi[0]);</a>
<a name="ln5682">	if (mask &amp; IWN_ANT_B)</a>
<a name="ln5683">		rssi = MAX(rssi, phy-&gt;rssi[2]);</a>
<a name="ln5684">	if (mask &amp; IWN_ANT_C)</a>
<a name="ln5685">		rssi = MAX(rssi, phy-&gt;rssi[4]);</a>
<a name="ln5686"> </a>
<a name="ln5687">	DPRINTF(sc, IWN_DEBUG_RECV,</a>
<a name="ln5688">	    &quot;%s: agc %d mask 0x%x rssi %d %d %d result %d\n&quot;, __func__, agc,</a>
<a name="ln5689">	    mask, phy-&gt;rssi[0], phy-&gt;rssi[2], phy-&gt;rssi[4],</a>
<a name="ln5690">	    rssi - agc - IWN_RSSI_TO_DBM);</a>
<a name="ln5691">	return rssi - agc - IWN_RSSI_TO_DBM;</a>
<a name="ln5692">}</a>
<a name="ln5693"> </a>
<a name="ln5694">static int</a>
<a name="ln5695">iwn5000_get_rssi(struct iwn_softc *sc, struct iwn_rx_stat *stat)</a>
<a name="ln5696">{</a>
<a name="ln5697">	struct iwn5000_rx_phystat *phy = (void *)stat-&gt;phybuf;</a>
<a name="ln5698">	uint8_t agc;</a>
<a name="ln5699">	int rssi;</a>
<a name="ln5700"> </a>
<a name="ln5701">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln5702"> </a>
<a name="ln5703">	agc = (le32toh(phy-&gt;agc) &gt;&gt; 9) &amp; 0x7f;</a>
<a name="ln5704"> </a>
<a name="ln5705">	rssi = MAX(le16toh(phy-&gt;rssi[0]) &amp; 0xff,</a>
<a name="ln5706">		   le16toh(phy-&gt;rssi[1]) &amp; 0xff);</a>
<a name="ln5707">	rssi = MAX(le16toh(phy-&gt;rssi[2]) &amp; 0xff, rssi);</a>
<a name="ln5708"> </a>
<a name="ln5709">	DPRINTF(sc, IWN_DEBUG_RECV,</a>
<a name="ln5710">	    &quot;%s: agc %d rssi %d %d %d result %d\n&quot;, __func__, agc,</a>
<a name="ln5711">	    phy-&gt;rssi[0], phy-&gt;rssi[1], phy-&gt;rssi[2],</a>
<a name="ln5712">	    rssi - agc - IWN_RSSI_TO_DBM);</a>
<a name="ln5713">	return rssi - agc - IWN_RSSI_TO_DBM;</a>
<a name="ln5714">}</a>
<a name="ln5715"> </a>
<a name="ln5716">/*</a>
<a name="ln5717"> * Retrieve the average noise (in dBm) among receivers.</a>
<a name="ln5718"> */</a>
<a name="ln5719">static int</a>
<a name="ln5720">iwn_get_noise(const struct iwn_rx_general_stats *stats)</a>
<a name="ln5721">{</a>
<a name="ln5722">	int i, total, nbant, noise;</a>
<a name="ln5723"> </a>
<a name="ln5724">	total = nbant = 0;</a>
<a name="ln5725">	for (i = 0; i &lt; 3; i++) {</a>
<a name="ln5726">		if ((noise = le32toh(stats-&gt;noise[i]) &amp; 0xff) == 0)</a>
<a name="ln5727">			continue;</a>
<a name="ln5728">		total += noise;</a>
<a name="ln5729">		nbant++;</a>
<a name="ln5730">	}</a>
<a name="ln5731">	/* There should be at least one antenna but check anyway. */</a>
<a name="ln5732">	return (nbant == 0) ? -127 : (total / nbant) - 107;</a>
<a name="ln5733">}</a>
<a name="ln5734"> </a>
<a name="ln5735">/*</a>
<a name="ln5736"> * Compute temperature (in degC) from last received statistics.</a>
<a name="ln5737"> */</a>
<a name="ln5738">static int</a>
<a name="ln5739">iwn4965_get_temperature(struct iwn_softc *sc)</a>
<a name="ln5740">{</a>
<a name="ln5741">	struct iwn_ucode_info *uc = &amp;sc-&gt;ucode_info;</a>
<a name="ln5742">	int32_t r1, r2, r3, r4, temp;</a>
<a name="ln5743"> </a>
<a name="ln5744">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln5745"> </a>
<a name="ln5746">	r1 = le32toh(uc-&gt;temp[0].chan20MHz);</a>
<a name="ln5747">	r2 = le32toh(uc-&gt;temp[1].chan20MHz);</a>
<a name="ln5748">	r3 = le32toh(uc-&gt;temp[2].chan20MHz);</a>
<a name="ln5749">	r4 = le32toh(sc-&gt;rawtemp);</a>
<a name="ln5750"> </a>
<a name="ln5751">	if (r1 == r3)	/* Prevents division by 0 (should not happen). */</a>
<a name="ln5752">		return 0;</a>
<a name="ln5753"> </a>
<a name="ln5754">	/* Sign-extend 23-bit R4 value to 32-bit. */</a>
<a name="ln5755">	r4 = ((r4 &amp; 0xffffff) ^ 0x800000) - 0x800000;</a>
<a name="ln5756">	/* Compute temperature in Kelvin. */</a>
<a name="ln5757">	temp = (259 * (r4 - r2)) / (r3 - r1);</a>
<a name="ln5758">	temp = (temp * 97) / 100 + 8;</a>
<a name="ln5759"> </a>
<a name="ln5760">	DPRINTF(sc, IWN_DEBUG_ANY, &quot;temperature %dK/%dC\n&quot;, temp,</a>
<a name="ln5761">	    IWN_KTOC(temp));</a>
<a name="ln5762">	return IWN_KTOC(temp);</a>
<a name="ln5763">}</a>
<a name="ln5764"> </a>
<a name="ln5765">static int</a>
<a name="ln5766">iwn5000_get_temperature(struct iwn_softc *sc)</a>
<a name="ln5767">{</a>
<a name="ln5768">	int32_t temp;</a>
<a name="ln5769"> </a>
<a name="ln5770">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln5771"> </a>
<a name="ln5772">	/*</a>
<a name="ln5773">	 * Temperature is not used by the driver for 5000 Series because</a>
<a name="ln5774">	 * TX power calibration is handled by firmware.</a>
<a name="ln5775">	 */</a>
<a name="ln5776">	temp = le32toh(sc-&gt;rawtemp);</a>
<a name="ln5777">	if (sc-&gt;hw_type == IWN_HW_REV_TYPE_5150) {</a>
<a name="ln5778">		temp = (temp / -5) + sc-&gt;temp_off;</a>
<a name="ln5779">		temp = IWN_KTOC(temp);</a>
<a name="ln5780">	}</a>
<a name="ln5781">	return temp;</a>
<a name="ln5782">}</a>
<a name="ln5783"> </a>
<a name="ln5784">/*</a>
<a name="ln5785"> * Initialize sensitivity calibration state machine.</a>
<a name="ln5786"> */</a>
<a name="ln5787">static int</a>
<a name="ln5788">iwn_init_sensitivity(struct iwn_softc *sc)</a>
<a name="ln5789">{</a>
<a name="ln5790">	struct iwn_ops *ops = &amp;sc-&gt;ops;</a>
<a name="ln5791">	struct iwn_calib_state *calib = &amp;sc-&gt;calib;</a>
<a name="ln5792">	uint32_t flags;</a>
<a name="ln5793">	int error;</a>
<a name="ln5794"> </a>
<a name="ln5795">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln5796"> </a>
<a name="ln5797">	/* Reset calibration state machine. */</a>
<a name="ln5798">	memset(calib, 0, sizeof (*calib));</a>
<a name="ln5799">	calib-&gt;state = IWN_CALIB_STATE_INIT;</a>
<a name="ln5800">	calib-&gt;cck_state = IWN_CCK_STATE_HIFA;</a>
<a name="ln5801">	/* Set initial correlation values. */</a>
<a name="ln5802">	calib-&gt;ofdm_x1     = sc-&gt;limits-&gt;min_ofdm_x1;</a>
<a name="ln5803">	calib-&gt;ofdm_mrc_x1 = sc-&gt;limits-&gt;min_ofdm_mrc_x1;</a>
<a name="ln5804">	calib-&gt;ofdm_x4     = sc-&gt;limits-&gt;min_ofdm_x4;</a>
<a name="ln5805">	calib-&gt;ofdm_mrc_x4 = sc-&gt;limits-&gt;min_ofdm_mrc_x4;</a>
<a name="ln5806">	calib-&gt;cck_x4      = 125;</a>
<a name="ln5807">	calib-&gt;cck_mrc_x4  = sc-&gt;limits-&gt;min_cck_mrc_x4;</a>
<a name="ln5808">	calib-&gt;energy_cck  = sc-&gt;limits-&gt;energy_cck;</a>
<a name="ln5809"> </a>
<a name="ln5810">	/* Write initial sensitivity. */</a>
<a name="ln5811">	if ((error = iwn_send_sensitivity(sc)) != 0)</a>
<a name="ln5812">		return error;</a>
<a name="ln5813"> </a>
<a name="ln5814">	/* Write initial gains. */</a>
<a name="ln5815">	if ((error = ops-&gt;init_gains(sc)) != 0)</a>
<a name="ln5816">		return error;</a>
<a name="ln5817"> </a>
<a name="ln5818">	/* Request statistics at each beacon interval. */</a>
<a name="ln5819">	flags = 0;</a>
<a name="ln5820">	DPRINTF(sc, IWN_DEBUG_CALIBRATE, &quot;%s: sending request for statistics\n&quot;,</a>
<a name="ln5821">	    __func__);</a>
<a name="ln5822">	return iwn_cmd(sc, IWN_CMD_GET_STATISTICS, &amp;flags, sizeof flags, 1);</a>
<a name="ln5823">}</a>
<a name="ln5824"> </a>
<a name="ln5825">/*</a>
<a name="ln5826"> * Collect noise and RSSI statistics for the first 20 beacons received</a>
<a name="ln5827"> * after association and use them to determine connected antennas and</a>
<a name="ln5828"> * to set differential gains.</a>
<a name="ln5829"> */</a>
<a name="ln5830">static void</a>
<a name="ln5831">iwn_collect_noise(struct iwn_softc *sc,</a>
<a name="ln5832">    const struct iwn_rx_general_stats *stats)</a>
<a name="ln5833">{</a>
<a name="ln5834">	struct iwn_ops *ops = &amp;sc-&gt;ops;</a>
<a name="ln5835">	struct iwn_calib_state *calib = &amp;sc-&gt;calib;</a>
<a name="ln5836">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln5837">	uint32_t val;</a>
<a name="ln5838">	int i;</a>
<a name="ln5839"> </a>
<a name="ln5840">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln5841"> </a>
<a name="ln5842">	/* Accumulate RSSI and noise for all 3 antennas. */</a>
<a name="ln5843">	for (i = 0; i &lt; 3; i++) {</a>
<a name="ln5844">		calib-&gt;rssi[i] += le32toh(stats-&gt;rssi[i]) &amp; 0xff;</a>
<a name="ln5845">		calib-&gt;noise[i] += le32toh(stats-&gt;noise[i]) &amp; 0xff;</a>
<a name="ln5846">	}</a>
<a name="ln5847">	/* NB: We update differential gains only once after 20 beacons. */</a>
<a name="ln5848">	if (++calib-&gt;nbeacons &lt; 20)</a>
<a name="ln5849">		return;</a>
<a name="ln5850"> </a>
<a name="ln5851">	/* Determine highest average RSSI. */</a>
<a name="ln5852">	val = MAX(calib-&gt;rssi[0], calib-&gt;rssi[1]);</a>
<a name="ln5853">	val = MAX(calib-&gt;rssi[2], val);</a>
<a name="ln5854"> </a>
<a name="ln5855">	/* Determine which antennas are connected. */</a>
<a name="ln5856">	sc-&gt;chainmask = sc-&gt;rxchainmask;</a>
<a name="ln5857">	for (i = 0; i &lt; 3; i++)</a>
<a name="ln5858">		if (val - calib-&gt;rssi[i] &gt; 15 * 20)</a>
<a name="ln5859">			sc-&gt;chainmask &amp;= ~(1 &lt;&lt; i);</a>
<a name="ln5860">	DPRINTF(sc, IWN_DEBUG_CALIBRATE | IWN_DEBUG_XMIT,</a>
<a name="ln5861">	    &quot;%s: RX chains mask: theoretical=0x%x, actual=0x%x\n&quot;,</a>
<a name="ln5862">	    __func__, sc-&gt;rxchainmask, sc-&gt;chainmask);</a>
<a name="ln5863"> </a>
<a name="ln5864">	/* If none of the TX antennas are connected, keep at least one. */</a>
<a name="ln5865">	if ((sc-&gt;chainmask &amp; sc-&gt;txchainmask) == 0)</a>
<a name="ln5866">		sc-&gt;chainmask |= IWN_LSB(sc-&gt;txchainmask);</a>
<a name="ln5867"> </a>
<a name="ln5868">	(void)ops-&gt;set_gains(sc);</a>
<a name="ln5869">	calib-&gt;state = IWN_CALIB_STATE_RUN;</a>
<a name="ln5870"> </a>
<a name="ln5871">#ifdef notyet</a>
<a name="ln5872">	/* XXX Disable RX chains with no antennas connected. */</a>
<a name="ln5873">	sc-&gt;rxon-&gt;rxchain = htole16(IWN_RXCHAIN_SEL(sc-&gt;chainmask));</a>
<a name="ln5874">	if (sc-&gt;sc_is_scanning)</a>
<a name="ln5875">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln5876">		    &quot;%s: is_scanning set, before RXON\n&quot;,</a>
<a name="ln5877">		    __func__);</a>
<a name="ln5878">	(void)iwn_cmd(sc, IWN_CMD_RXON, sc-&gt;rxon, sc-&gt;rxonsz, 1);</a>
<a name="ln5879">#endif</a>
<a name="ln5880"> </a>
<a name="ln5881">	/* Enable power-saving mode if requested by user. */</a>
<a name="ln5882">	if (ic-&gt;ic_flags &amp; IEEE80211_F_PMGTON)</a>
<a name="ln5883">		(void)iwn_set_pslevel(sc, 0, 3, 1);</a>
<a name="ln5884"> </a>
<a name="ln5885">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: end\n&quot;,__func__);</a>
<a name="ln5886"> </a>
<a name="ln5887">}</a>
<a name="ln5888"> </a>
<a name="ln5889">static int</a>
<a name="ln5890">iwn4965_init_gains(struct iwn_softc *sc)</a>
<a name="ln5891">{</a>
<a name="ln5892">	struct iwn_phy_calib_gain cmd;</a>
<a name="ln5893"> </a>
<a name="ln5894">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln5895"> </a>
<a name="ln5896">	memset(&amp;cmd, 0, sizeof cmd);</a>
<a name="ln5897">	cmd.code = IWN4965_PHY_CALIB_DIFF_GAIN;</a>
<a name="ln5898">	/* Differential gains initially set to 0 for all 3 antennas. */</a>
<a name="ln5899">	DPRINTF(sc, IWN_DEBUG_CALIBRATE,</a>
<a name="ln5900">	    &quot;%s: setting initial differential gains\n&quot;, __func__);</a>
<a name="ln5901">	return iwn_cmd(sc, IWN_CMD_PHY_CALIB, &amp;cmd, sizeof cmd, 1);</a>
<a name="ln5902">}</a>
<a name="ln5903"> </a>
<a name="ln5904">static int</a>
<a name="ln5905">iwn5000_init_gains(struct iwn_softc *sc)</a>
<a name="ln5906">{</a>
<a name="ln5907">	struct iwn_phy_calib cmd;</a>
<a name="ln5908"> </a>
<a name="ln5909">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln5910"> </a>
<a name="ln5911">	memset(&amp;cmd, 0, sizeof cmd);</a>
<a name="ln5912">	cmd.code = sc-&gt;reset_noise_gain;</a>
<a name="ln5913">	cmd.ngroups = 1;</a>
<a name="ln5914">	cmd.isvalid = 1;</a>
<a name="ln5915">	DPRINTF(sc, IWN_DEBUG_CALIBRATE,</a>
<a name="ln5916">	    &quot;%s: setting initial differential gains\n&quot;, __func__);</a>
<a name="ln5917">	return iwn_cmd(sc, IWN_CMD_PHY_CALIB, &amp;cmd, sizeof cmd, 1);</a>
<a name="ln5918">}</a>
<a name="ln5919"> </a>
<a name="ln5920">static int</a>
<a name="ln5921">iwn4965_set_gains(struct iwn_softc *sc)</a>
<a name="ln5922">{</a>
<a name="ln5923">	struct iwn_calib_state *calib = &amp;sc-&gt;calib;</a>
<a name="ln5924">	struct iwn_phy_calib_gain cmd;</a>
<a name="ln5925">	int i, delta, noise;</a>
<a name="ln5926"> </a>
<a name="ln5927">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln5928"> </a>
<a name="ln5929">	/* Get minimal noise among connected antennas. */</a>
<a name="ln5930">	noise = INT_MAX;	/* NB: There's at least one antenna. */</a>
<a name="ln5931">	for (i = 0; i &lt; 3; i++)</a>
<a name="ln5932">		if (sc-&gt;chainmask &amp; (1 &lt;&lt; i))</a>
<a name="ln5933">			noise = MIN(calib-&gt;noise[i], noise);</a>
<a name="ln5934"> </a>
<a name="ln5935">	memset(&amp;cmd, 0, sizeof cmd);</a>
<a name="ln5936">	cmd.code = IWN4965_PHY_CALIB_DIFF_GAIN;</a>
<a name="ln5937">	/* Set differential gains for connected antennas. */</a>
<a name="ln5938">	for (i = 0; i &lt; 3; i++) {</a>
<a name="ln5939">		if (sc-&gt;chainmask &amp; (1 &lt;&lt; i)) {</a>
<a name="ln5940">			/* Compute attenuation (in unit of 1.5dB). */</a>
<a name="ln5941">			delta = (noise - (int32_t)calib-&gt;noise[i]) / 30;</a>
<a name="ln5942">			/* NB: delta &lt;= 0 */</a>
<a name="ln5943">			/* Limit to [-4.5dB,0]. */</a>
<a name="ln5944">			cmd.gain[i] = MIN(abs(delta), 3);</a>
<a name="ln5945">			if (delta &lt; 0)</a>
<a name="ln5946">				cmd.gain[i] |= 1 &lt;&lt; 2;	/* sign bit */</a>
<a name="ln5947">		}</a>
<a name="ln5948">	}</a>
<a name="ln5949">	DPRINTF(sc, IWN_DEBUG_CALIBRATE,</a>
<a name="ln5950">	    &quot;setting differential gains Ant A/B/C: %x/%x/%x (%x)\n&quot;,</a>
<a name="ln5951">	    cmd.gain[0], cmd.gain[1], cmd.gain[2], sc-&gt;chainmask);</a>
<a name="ln5952">	return iwn_cmd(sc, IWN_CMD_PHY_CALIB, &amp;cmd, sizeof cmd, 1);</a>
<a name="ln5953">}</a>
<a name="ln5954"> </a>
<a name="ln5955">static int</a>
<a name="ln5956">iwn5000_set_gains(struct iwn_softc *sc)</a>
<a name="ln5957">{</a>
<a name="ln5958">	struct iwn_calib_state *calib = &amp;sc-&gt;calib;</a>
<a name="ln5959">	struct iwn_phy_calib_gain cmd;</a>
<a name="ln5960">	int i, ant, div, delta;</a>
<a name="ln5961"> </a>
<a name="ln5962">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln5963"> </a>
<a name="ln5964">	/* We collected 20 beacons and !=6050 need a 1.5 factor. */</a>
<a name="ln5965">	div = (sc-&gt;hw_type == IWN_HW_REV_TYPE_6050) ? 20 : 30;</a>
<a name="ln5966"> </a>
<a name="ln5967">	memset(&amp;cmd, 0, sizeof cmd);</a>
<a name="ln5968">	cmd.code = sc-&gt;noise_gain;</a>
<a name="ln5969">	cmd.ngroups = 1;</a>
<a name="ln5970">	cmd.isvalid = 1;</a>
<a name="ln5971">	/* Get first available RX antenna as referential. */</a>
<a name="ln5972">	ant = IWN_LSB(sc-&gt;rxchainmask);</a>
<a name="ln5973">	/* Set differential gains for other antennas. */</a>
<a name="ln5974">	for (i = ant + 1; i &lt; 3; i++) {</a>
<a name="ln5975">		if (sc-&gt;chainmask &amp; (1 &lt;&lt; i)) {</a>
<a name="ln5976">			/* The delta is relative to antenna &quot;ant&quot;. */</a>
<a name="ln5977">			delta = ((int32_t)calib-&gt;noise[ant] -</a>
<a name="ln5978">			    (int32_t)calib-&gt;noise[i]) / div;</a>
<a name="ln5979">			/* Limit to [-4.5dB,+4.5dB]. */</a>
<a name="ln5980">			cmd.gain[i - 1] = MIN(abs(delta), 3);</a>
<a name="ln5981">			if (delta &lt; 0)</a>
<a name="ln5982">				cmd.gain[i - 1] |= 1 &lt;&lt; 2;	/* sign bit */</a>
<a name="ln5983">		}</a>
<a name="ln5984">	}</a>
<a name="ln5985">	DPRINTF(sc, IWN_DEBUG_CALIBRATE | IWN_DEBUG_XMIT,</a>
<a name="ln5986">	    &quot;setting differential gains Ant B/C: %x/%x (%x)\n&quot;,</a>
<a name="ln5987">	    cmd.gain[0], cmd.gain[1], sc-&gt;chainmask);</a>
<a name="ln5988">	return iwn_cmd(sc, IWN_CMD_PHY_CALIB, &amp;cmd, sizeof cmd, 1);</a>
<a name="ln5989">}</a>
<a name="ln5990"> </a>
<a name="ln5991">/*</a>
<a name="ln5992"> * Tune RF RX sensitivity based on the number of false alarms detected</a>
<a name="ln5993"> * during the last beacon period.</a>
<a name="ln5994"> */</a>
<a name="ln5995">static void</a>
<a name="ln5996">iwn_tune_sensitivity(struct iwn_softc *sc, const struct iwn_rx_stats *stats)</a>
<a name="ln5997">{</a>
<a name="ln5998">#define inc(val, inc, max)			\</a>
<a name="ln5999">	if ((val) &lt; (max)) {			\</a>
<a name="ln6000">		if ((val) &lt; (max) - (inc))	\</a>
<a name="ln6001">			(val) += (inc);		\</a>
<a name="ln6002">		else				\</a>
<a name="ln6003">			(val) = (max);		\</a>
<a name="ln6004">		needs_update = 1;		\</a>
<a name="ln6005">	}</a>
<a name="ln6006">#define dec(val, dec, min)			\</a>
<a name="ln6007">	if ((val) &gt; (min)) {			\</a>
<a name="ln6008">		if ((val) &gt; (min) + (dec))	\</a>
<a name="ln6009">			(val) -= (dec);		\</a>
<a name="ln6010">		else				\</a>
<a name="ln6011">			(val) = (min);		\</a>
<a name="ln6012">		needs_update = 1;		\</a>
<a name="ln6013">	}</a>
<a name="ln6014"> </a>
<a name="ln6015">	const struct iwn_sensitivity_limits *limits = sc-&gt;limits;</a>
<a name="ln6016">	struct iwn_calib_state *calib = &amp;sc-&gt;calib;</a>
<a name="ln6017">	uint32_t val, rxena, fa;</a>
<a name="ln6018">	uint32_t energy[3], energy_min;</a>
<a name="ln6019">	uint8_t noise[3], noise_ref;</a>
<a name="ln6020">	int i, needs_update = 0;</a>
<a name="ln6021"> </a>
<a name="ln6022">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln6023"> </a>
<a name="ln6024">	/* Check that we've been enabled long enough. */</a>
<a name="ln6025">	if ((rxena = le32toh(stats-&gt;general.load)) == 0){</a>
<a name="ln6026">		DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s end not so long\n&quot;, __func__);</a>
<a name="ln6027">		return;</a>
<a name="ln6028">	}</a>
<a name="ln6029"> </a>
<a name="ln6030">	/* Compute number of false alarms since last call for OFDM. */</a>
<a name="ln6031">	fa  = le32toh(stats-&gt;ofdm.bad_plcp) - calib-&gt;bad_plcp_ofdm;</a>
<a name="ln6032">	fa += le32toh(stats-&gt;ofdm.fa) - calib-&gt;fa_ofdm;</a>
<a name="ln6033">	fa *= 200 * IEEE80211_DUR_TU;	/* 200TU */</a>
<a name="ln6034"> </a>
<a name="ln6035">	if (fa &gt; 50 * rxena) {</a>
<a name="ln6036">		/* High false alarm count, decrease sensitivity. */</a>
<a name="ln6037">		DPRINTF(sc, IWN_DEBUG_CALIBRATE,</a>
<a name="ln6038">		    &quot;%s: OFDM high false alarm count: %u\n&quot;, __func__, fa);</a>
<a name="ln6039">		inc(calib-&gt;ofdm_x1,     1, limits-&gt;max_ofdm_x1);</a>
<a name="ln6040">		inc(calib-&gt;ofdm_mrc_x1, 1, limits-&gt;max_ofdm_mrc_x1);</a>
<a name="ln6041">		inc(calib-&gt;ofdm_x4,     1, limits-&gt;max_ofdm_x4);</a>
<a name="ln6042">		inc(calib-&gt;ofdm_mrc_x4, 1, limits-&gt;max_ofdm_mrc_x4);</a>
<a name="ln6043"> </a>
<a name="ln6044">	} else if (fa &lt; 5 * rxena) {</a>
<a name="ln6045">		/* Low false alarm count, increase sensitivity. */</a>
<a name="ln6046">		DPRINTF(sc, IWN_DEBUG_CALIBRATE,</a>
<a name="ln6047">		    &quot;%s: OFDM low false alarm count: %u\n&quot;, __func__, fa);</a>
<a name="ln6048">		dec(calib-&gt;ofdm_x1,     1, limits-&gt;min_ofdm_x1);</a>
<a name="ln6049">		dec(calib-&gt;ofdm_mrc_x1, 1, limits-&gt;min_ofdm_mrc_x1);</a>
<a name="ln6050">		dec(calib-&gt;ofdm_x4,     1, limits-&gt;min_ofdm_x4);</a>
<a name="ln6051">		dec(calib-&gt;ofdm_mrc_x4, 1, limits-&gt;min_ofdm_mrc_x4);</a>
<a name="ln6052">	}</a>
<a name="ln6053"> </a>
<a name="ln6054">	/* Compute maximum noise among 3 receivers. */</a>
<a name="ln6055">	for (i = 0; i &lt; 3; i++)</a>
<a name="ln6056">		noise[i] = (le32toh(stats-&gt;general.noise[i]) &gt;&gt; 8) &amp; 0xff;</a>
<a name="ln6057">	val = MAX(noise[0], noise[1]);</a>
<a name="ln6058">	val = MAX(noise[2], val);</a>
<a name="ln6059">	/* Insert it into our samples table. */</a>
<a name="ln6060">	calib-&gt;noise_samples[calib-&gt;cur_noise_sample] = val;</a>
<a name="ln6061">	calib-&gt;cur_noise_sample = (calib-&gt;cur_noise_sample + 1) % 20;</a>
<a name="ln6062"> </a>
<a name="ln6063">	/* Compute maximum noise among last 20 samples. */</a>
<a name="ln6064">	noise_ref = calib-&gt;noise_samples[0];</a>
<a name="ln6065">	for (i = 1; i &lt; 20; i++)</a>
<a name="ln6066">		noise_ref = MAX(noise_ref, calib-&gt;noise_samples[i]);</a>
<a name="ln6067"> </a>
<a name="ln6068">	/* Compute maximum energy among 3 receivers. */</a>
<a name="ln6069">	for (i = 0; i &lt; 3; i++)</a>
<a name="ln6070">		energy[i] = le32toh(stats-&gt;general.energy[i]);</a>
<a name="ln6071">	val = MIN(energy[0], energy[1]);</a>
<a name="ln6072">	val = MIN(energy[2], val);</a>
<a name="ln6073">	/* Insert it into our samples table. */</a>
<a name="ln6074">	calib-&gt;energy_samples[calib-&gt;cur_energy_sample] = val;</a>
<a name="ln6075">	calib-&gt;cur_energy_sample = (calib-&gt;cur_energy_sample + 1) % 10;</a>
<a name="ln6076"> </a>
<a name="ln6077">	/* Compute minimum energy among last 10 samples. */</a>
<a name="ln6078">	energy_min = calib-&gt;energy_samples[0];</a>
<a name="ln6079">	for (i = 1; i &lt; 10; i++)</a>
<a name="ln6080">		energy_min = MAX(energy_min, calib-&gt;energy_samples[i]);</a>
<a name="ln6081">	energy_min += 6;</a>
<a name="ln6082"> </a>
<a name="ln6083">	/* Compute number of false alarms since last call for CCK. */</a>
<a name="ln6084">	fa  = le32toh(stats-&gt;cck.bad_plcp) - calib-&gt;bad_plcp_cck;</a>
<a name="ln6085">	fa += le32toh(stats-&gt;cck.fa) - calib-&gt;fa_cck;</a>
<a name="ln6086">	fa *= 200 * IEEE80211_DUR_TU;	/* 200TU */</a>
<a name="ln6087"> </a>
<a name="ln6088">	if (fa &gt; 50 * rxena) {</a>
<a name="ln6089">		/* High false alarm count, decrease sensitivity. */</a>
<a name="ln6090">		DPRINTF(sc, IWN_DEBUG_CALIBRATE,</a>
<a name="ln6091">		    &quot;%s: CCK high false alarm count: %u\n&quot;, __func__, fa);</a>
<a name="ln6092">		calib-&gt;cck_state = IWN_CCK_STATE_HIFA;</a>
<a name="ln6093">		calib-&gt;low_fa = 0;</a>
<a name="ln6094"> </a>
<a name="ln6095">		if (calib-&gt;cck_x4 &gt; 160) {</a>
<a name="ln6096">			calib-&gt;noise_ref = noise_ref;</a>
<a name="ln6097">			if (calib-&gt;energy_cck &gt; 2)</a>
<a name="ln6098">				dec(calib-&gt;energy_cck, 2, energy_min);</a>
<a name="ln6099">		}</a>
<a name="ln6100">		if (calib-&gt;cck_x4 &lt; 160) {</a>
<a name="ln6101">			calib-&gt;cck_x4 = 161;</a>
<a name="ln6102">			needs_update = 1;</a>
<a name="ln6103">		} else</a>
<a name="ln6104">			inc(calib-&gt;cck_x4, 3, limits-&gt;max_cck_x4);</a>
<a name="ln6105"> </a>
<a name="ln6106">		inc(calib-&gt;cck_mrc_x4, 3, limits-&gt;max_cck_mrc_x4);</a>
<a name="ln6107"> </a>
<a name="ln6108">	} else if (fa &lt; 5 * rxena) {</a>
<a name="ln6109">		/* Low false alarm count, increase sensitivity. */</a>
<a name="ln6110">		DPRINTF(sc, IWN_DEBUG_CALIBRATE,</a>
<a name="ln6111">		    &quot;%s: CCK low false alarm count: %u\n&quot;, __func__, fa);</a>
<a name="ln6112">		calib-&gt;cck_state = IWN_CCK_STATE_LOFA;</a>
<a name="ln6113">		calib-&gt;low_fa++;</a>
<a name="ln6114"> </a>
<a name="ln6115">		if (calib-&gt;cck_state != IWN_CCK_STATE_INIT &amp;&amp;</a>
<a name="ln6116">		    (((int32_t)calib-&gt;noise_ref - (int32_t)noise_ref) &gt; 2 ||</a>
<a name="ln6117">		     calib-&gt;low_fa &gt; 100)) {</a>
<a name="ln6118">			inc(calib-&gt;energy_cck, 2, limits-&gt;min_energy_cck);</a>
<a name="ln6119">			dec(calib-&gt;cck_x4,     3, limits-&gt;min_cck_x4);</a>
<a name="ln6120">			dec(calib-&gt;cck_mrc_x4, 3, limits-&gt;min_cck_mrc_x4);</a>
<a name="ln6121">		}</a>
<a name="ln6122">	} else {</a>
<a name="ln6123">		/* Not worth to increase or decrease sensitivity. */</a>
<a name="ln6124">		DPRINTF(sc, IWN_DEBUG_CALIBRATE,</a>
<a name="ln6125">		    &quot;%s: CCK normal false alarm count: %u\n&quot;, __func__, fa);</a>
<a name="ln6126">		calib-&gt;low_fa = 0;</a>
<a name="ln6127">		calib-&gt;noise_ref = noise_ref;</a>
<a name="ln6128"> </a>
<a name="ln6129">		if (calib-&gt;cck_state == IWN_CCK_STATE_HIFA) {</a>
<a name="ln6130">			/* Previous interval had many false alarms. */</a>
<a name="ln6131">			dec(calib-&gt;energy_cck, 8, energy_min);</a>
<a name="ln6132">		}</a>
<a name="ln6133">		calib-&gt;cck_state = IWN_CCK_STATE_INIT;</a>
<a name="ln6134">	}</a>
<a name="ln6135"> </a>
<a name="ln6136">	if (needs_update)</a>
<a name="ln6137">		(void)iwn_send_sensitivity(sc);</a>
<a name="ln6138"> </a>
<a name="ln6139">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: end\n&quot;,__func__);</a>
<a name="ln6140"> </a>
<a name="ln6141">#undef dec</a>
<a name="ln6142">#undef inc</a>
<a name="ln6143">}</a>
<a name="ln6144"> </a>
<a name="ln6145">static int</a>
<a name="ln6146">iwn_send_sensitivity(struct iwn_softc *sc)</a>
<a name="ln6147">{</a>
<a name="ln6148">	struct iwn_calib_state *calib = &amp;sc-&gt;calib;</a>
<a name="ln6149">	struct iwn_enhanced_sensitivity_cmd cmd;</a>
<a name="ln6150">	int len;</a>
<a name="ln6151"> </a>
<a name="ln6152">	memset(&amp;cmd, 0, sizeof cmd);</a>
<a name="ln6153">	len = sizeof (struct iwn_sensitivity_cmd);</a>
<a name="ln6154">	cmd.which = IWN_SENSITIVITY_WORKTBL;</a>
<a name="ln6155">	/* OFDM modulation. */</a>
<a name="ln6156">	cmd.corr_ofdm_x1       = htole16(calib-&gt;ofdm_x1);</a>
<a name="ln6157">	cmd.corr_ofdm_mrc_x1   = htole16(calib-&gt;ofdm_mrc_x1);</a>
<a name="ln6158">	cmd.corr_ofdm_x4       = htole16(calib-&gt;ofdm_x4);</a>
<a name="ln6159">	cmd.corr_ofdm_mrc_x4   = htole16(calib-&gt;ofdm_mrc_x4);</a>
<a name="ln6160">	cmd.energy_ofdm        = htole16(sc-&gt;limits-&gt;energy_ofdm);</a>
<a name="ln6161">	cmd.energy_ofdm_th     = htole16(62);</a>
<a name="ln6162">	/* CCK modulation. */</a>
<a name="ln6163">	cmd.corr_cck_x4        = htole16(calib-&gt;cck_x4);</a>
<a name="ln6164">	cmd.corr_cck_mrc_x4    = htole16(calib-&gt;cck_mrc_x4);</a>
<a name="ln6165">	cmd.energy_cck         = htole16(calib-&gt;energy_cck);</a>
<a name="ln6166">	/* Barker modulation: use default values. */</a>
<a name="ln6167">	cmd.corr_barker        = htole16(190);</a>
<a name="ln6168">	cmd.corr_barker_mrc    = htole16(sc-&gt;limits-&gt;barker_mrc);</a>
<a name="ln6169"> </a>
<a name="ln6170">	DPRINTF(sc, IWN_DEBUG_CALIBRATE,</a>
<a name="ln6171">	    &quot;%s: set sensitivity %d/%d/%d/%d/%d/%d/%d\n&quot;, __func__,</a>
<a name="ln6172">	    calib-&gt;ofdm_x1, calib-&gt;ofdm_mrc_x1, calib-&gt;ofdm_x4,</a>
<a name="ln6173">	    calib-&gt;ofdm_mrc_x4, calib-&gt;cck_x4,</a>
<a name="ln6174">	    calib-&gt;cck_mrc_x4, calib-&gt;energy_cck);</a>
<a name="ln6175"> </a>
<a name="ln6176">	if (!(sc-&gt;sc_flags &amp; IWN_FLAG_ENH_SENS))</a>
<a name="ln6177">		goto send;</a>
<a name="ln6178">	/* Enhanced sensitivity settings. */</a>
<a name="ln6179">	len = sizeof (struct iwn_enhanced_sensitivity_cmd);</a>
<a name="ln6180">	cmd.ofdm_det_slope_mrc = htole16(668);</a>
<a name="ln6181">	cmd.ofdm_det_icept_mrc = htole16(4);</a>
<a name="ln6182">	cmd.ofdm_det_slope     = htole16(486);</a>
<a name="ln6183">	cmd.ofdm_det_icept     = htole16(37);</a>
<a name="ln6184">	cmd.cck_det_slope_mrc  = htole16(853);</a>
<a name="ln6185">	cmd.cck_det_icept_mrc  = htole16(4);</a>
<a name="ln6186">	cmd.cck_det_slope      = htole16(476);</a>
<a name="ln6187">	cmd.cck_det_icept      = htole16(99);</a>
<a name="ln6188">send:</a>
<a name="ln6189">	return iwn_cmd(sc, IWN_CMD_SET_SENSITIVITY, &amp;cmd, len, 1);</a>
<a name="ln6190">}</a>
<a name="ln6191"> </a>
<a name="ln6192">/*</a>
<a name="ln6193"> * Look at the increase of PLCP errors over time; if it exceeds</a>
<a name="ln6194"> * a programmed threshold then trigger an RF retune.</a>
<a name="ln6195"> */</a>
<a name="ln6196">static void</a>
<a name="ln6197">iwn_check_rx_recovery(struct iwn_softc *sc, struct iwn_stats *rs)</a>
<a name="ln6198">{</a>
<a name="ln6199">	int32_t delta_ofdm, delta_ht, delta_cck;</a>
<a name="ln6200">	struct iwn_calib_state *calib = &amp;sc-&gt;calib;</a>
<a name="ln6201">	int delta_ticks, cur_ticks;</a>
<a name="ln6202">	int delta_msec;</a>
<a name="ln6203">	int thresh;</a>
<a name="ln6204"> </a>
<a name="ln6205">	/*</a>
<a name="ln6206">	 * Calculate the difference between the current and</a>
<a name="ln6207">	 * previous statistics.</a>
<a name="ln6208">	 */</a>
<a name="ln6209">	delta_cck = le32toh(rs-&gt;rx.cck.bad_plcp) - calib-&gt;bad_plcp_cck;</a>
<a name="ln6210">	delta_ofdm = le32toh(rs-&gt;rx.ofdm.bad_plcp) - calib-&gt;bad_plcp_ofdm;</a>
<a name="ln6211">	delta_ht = le32toh(rs-&gt;rx.ht.bad_plcp) - calib-&gt;bad_plcp_ht;</a>
<a name="ln6212"> </a>
<a name="ln6213">	/*</a>
<a name="ln6214">	 * Calculate the delta in time between successive statistics</a>
<a name="ln6215">	 * messages.  Yes, it can roll over; so we make sure that</a>
<a name="ln6216">	 * this doesn't happen.</a>
<a name="ln6217">	 *</a>
<a name="ln6218">	 * XXX go figure out what to do about rollover</a>
<a name="ln6219">	 * XXX go figure out what to do if ticks rolls over to -ve instead!</a>
<a name="ln6220">	 * XXX go stab signed integer overflow undefined-ness in the face.</a>
<a name="ln6221">	 */</a>
<a name="ln6222">	cur_ticks = ticks;</a>
<a name="ln6223">	delta_ticks = cur_ticks - sc-&gt;last_calib_ticks;</a>
<a name="ln6224"> </a>
<a name="ln6225">	/*</a>
<a name="ln6226">	 * If any are negative, then the firmware likely reset; so just</a>
<a name="ln6227">	 * bail.  We'll pick this up next time.</a>
<a name="ln6228">	 */</a>
<a name="ln6229">	if (delta_cck &lt; 0 || delta_ofdm &lt; 0 || delta_ht &lt; 0 || delta_ticks &lt; 0)</a>
<a name="ln6230">		return;</a>
<a name="ln6231"> </a>
<a name="ln6232">	/*</a>
<a name="ln6233">	 * delta_ticks is in ticks; we need to convert it up to milliseconds</a>
<a name="ln6234">	 * so we can do some useful math with it.</a>
<a name="ln6235">	 */</a>
<a name="ln6236">	delta_msec = ticks_to_msecs(delta_ticks);</a>
<a name="ln6237"> </a>
<a name="ln6238">	/*</a>
<a name="ln6239">	 * Calculate what our threshold is given the current delta_msec.</a>
<a name="ln6240">	 */</a>
<a name="ln6241">	thresh = sc-&gt;base_params-&gt;plcp_err_threshold * delta_msec;</a>
<a name="ln6242"> </a>
<a name="ln6243">	DPRINTF(sc, IWN_DEBUG_STATE,</a>
<a name="ln6244">	    &quot;%s: time delta: %d; cck=%d, ofdm=%d, ht=%d, total=%d, thresh=%d\n&quot;,</a>
<a name="ln6245">	    __func__,</a>
<a name="ln6246">	    delta_msec,</a>
<a name="ln6247">	    delta_cck,</a>
<a name="ln6248">	    delta_ofdm,</a>
<a name="ln6249">	    delta_ht,</a>
<a name="ln6250">	    (delta_msec + delta_cck + delta_ofdm + delta_ht),</a>
<a name="ln6251">	    thresh);</a>
<a name="ln6252"> </a>
<a name="ln6253">	/*</a>
<a name="ln6254">	 * If we need a retune, then schedule a single channel scan</a>
<a name="ln6255">	 * to a channel that isn't the currently active one!</a>
<a name="ln6256">	 *</a>
<a name="ln6257">	 * The math from linux iwlwifi:</a>
<a name="ln6258">	 *</a>
<a name="ln6259">	 * if ((delta * 100 / msecs) &gt; threshold)</a>
<a name="ln6260">	 */</a>
<a name="ln6261">	if (thresh &gt; 0 &amp;&amp; (delta_cck + delta_ofdm + delta_ht) * 100 &gt; thresh) {</a>
<a name="ln6262">		DPRINTF(sc, IWN_DEBUG_ANY,</a>
<a name="ln6263">		    &quot;%s: PLCP error threshold raw (%d) comparison (%d) &quot;</a>
<a name="ln6264">		    &quot;over limit (%d); retune!\n&quot;,</a>
<a name="ln6265">		    __func__,</a>
<a name="ln6266">		    (delta_cck + delta_ofdm + delta_ht),</a>
<a name="ln6267">		    (delta_cck + delta_ofdm + delta_ht) * 100,</a>
<a name="ln6268">		    thresh);</a>
<a name="ln6269">	}</a>
<a name="ln6270">}</a>
<a name="ln6271"> </a>
<a name="ln6272">/*</a>
<a name="ln6273"> * Set STA mode power saving level (between 0 and 5).</a>
<a name="ln6274"> * Level 0 is CAM (Continuously Aware Mode), 5 is for maximum power saving.</a>
<a name="ln6275"> */</a>
<a name="ln6276">static int</a>
<a name="ln6277">iwn_set_pslevel(struct iwn_softc *sc, int dtim, int level, int async)</a>
<a name="ln6278">{</a>
<a name="ln6279">	struct iwn_pmgt_cmd cmd;</a>
<a name="ln6280">	const struct iwn_pmgt *pmgt;</a>
<a name="ln6281">	uint32_t max, skip_dtim;</a>
<a name="ln6282">	uint32_t reg;</a>
<a name="ln6283">	int i;</a>
<a name="ln6284"> </a>
<a name="ln6285">	DPRINTF(sc, IWN_DEBUG_PWRSAVE,</a>
<a name="ln6286">	    &quot;%s: dtim=%d, level=%d, async=%d\n&quot;,</a>
<a name="ln6287">	    __func__,</a>
<a name="ln6288">	    dtim,</a>
<a name="ln6289">	    level,</a>
<a name="ln6290">	    async);</a>
<a name="ln6291"> </a>
<a name="ln6292">	/* Select which PS parameters to use. */</a>
<a name="ln6293">	if (dtim &lt;= 2)</a>
<a name="ln6294">		pmgt = &amp;iwn_pmgt[0][level];</a>
<a name="ln6295">	else if (dtim &lt;= 10)</a>
<a name="ln6296">		pmgt = &amp;iwn_pmgt[1][level];</a>
<a name="ln6297">	else</a>
<a name="ln6298">		pmgt = &amp;iwn_pmgt[2][level];</a>
<a name="ln6299"> </a>
<a name="ln6300">	memset(&amp;cmd, 0, sizeof cmd);</a>
<a name="ln6301">	if (level != 0)	/* not CAM */</a>
<a name="ln6302">		cmd.flags |= htole16(IWN_PS_ALLOW_SLEEP);</a>
<a name="ln6303">	if (level == 5)</a>
<a name="ln6304">		cmd.flags |= htole16(IWN_PS_FAST_PD);</a>
<a name="ln6305">	/* Retrieve PCIe Active State Power Management (ASPM). */</a>
<a name="ln6306">	reg = pci_read_config(sc-&gt;sc_dev, sc-&gt;sc_cap_off + PCIER_LINK_CTL, 4);</a>
<a name="ln6307">	if (!(reg &amp; PCIEM_LINK_CTL_ASPMC_L0S))	/* L0s Entry disabled. */</a>
<a name="ln6308">		cmd.flags |= htole16(IWN_PS_PCI_PMGT);</a>
<a name="ln6309">	cmd.rxtimeout = htole32(pmgt-&gt;rxtimeout * 1024);</a>
<a name="ln6310">	cmd.txtimeout = htole32(pmgt-&gt;txtimeout * 1024);</a>
<a name="ln6311"> </a>
<a name="ln6312">	if (dtim == 0) {</a>
<a name="ln6313">		dtim = 1;</a>
<a name="ln6314">		skip_dtim = 0;</a>
<a name="ln6315">	} else</a>
<a name="ln6316">		skip_dtim = pmgt-&gt;skip_dtim;</a>
<a name="ln6317">	if (skip_dtim != 0) {</a>
<a name="ln6318">		cmd.flags |= htole16(IWN_PS_SLEEP_OVER_DTIM);</a>
<a name="ln6319">		max = pmgt-&gt;intval[4];</a>
<a name="ln6320">		if (max == (uint32_t)-1)</a>
<a name="ln6321">			max = dtim * (skip_dtim + 1);</a>
<a name="ln6322">		else if (max &gt; dtim)</a>
<a name="ln6323">			max = rounddown(max, dtim);</a>
<a name="ln6324">	} else</a>
<a name="ln6325">		max = dtim;</a>
<a name="ln6326">	for (i = 0; i &lt; 5; i++)</a>
<a name="ln6327">		cmd.intval[i] = htole32(MIN(max, pmgt-&gt;intval[i]));</a>
<a name="ln6328"> </a>
<a name="ln6329">	DPRINTF(sc, IWN_DEBUG_RESET, &quot;setting power saving level to %d\n&quot;,</a>
<a name="ln6330">	    level);</a>
<a name="ln6331">	return iwn_cmd(sc, IWN_CMD_SET_POWER_MODE, &amp;cmd, sizeof cmd, async);</a>
<a name="ln6332">}</a>
<a name="ln6333"> </a>
<a name="ln6334">static int</a>
<a name="ln6335">iwn_send_btcoex(struct iwn_softc *sc)</a>
<a name="ln6336">{</a>
<a name="ln6337">	struct iwn_bluetooth cmd;</a>
<a name="ln6338"> </a>
<a name="ln6339">	memset(&amp;cmd, 0, sizeof cmd);</a>
<a name="ln6340">	cmd.flags = IWN_BT_COEX_CHAN_ANN | IWN_BT_COEX_BT_PRIO;</a>
<a name="ln6341">	cmd.lead_time = IWN_BT_LEAD_TIME_DEF;</a>
<a name="ln6342">	cmd.max_kill = IWN_BT_MAX_KILL_DEF;</a>
<a name="ln6343">	DPRINTF(sc, IWN_DEBUG_RESET, &quot;%s: configuring bluetooth coexistence\n&quot;,</a>
<a name="ln6344">	    __func__);</a>
<a name="ln6345">	return iwn_cmd(sc, IWN_CMD_BT_COEX, &amp;cmd, sizeof(cmd), 0);</a>
<a name="ln6346">}</a>
<a name="ln6347"> </a>
<a name="ln6348">static int</a>
<a name="ln6349">iwn_send_advanced_btcoex(struct iwn_softc *sc)</a>
<a name="ln6350">{</a>
<a name="ln6351">	static const uint32_t btcoex_3wire[12] = {</a>
<a name="ln6352">		0xaaaaaaaa, 0xaaaaaaaa, 0xaeaaaaaa, 0xaaaaaaaa,</a>
<a name="ln6353">		0xcc00ff28, 0x0000aaaa, 0xcc00aaaa, 0x0000aaaa,</a>
<a name="ln6354">		0xc0004000, 0x00004000, 0xf0005000, 0xf0005000,</a>
<a name="ln6355">	};</a>
<a name="ln6356">	struct iwn6000_btcoex_config btconfig;</a>
<a name="ln6357">	struct iwn2000_btcoex_config btconfig2k;</a>
<a name="ln6358">	struct iwn_btcoex_priotable btprio;</a>
<a name="ln6359">	struct iwn_btcoex_prot btprot;</a>
<a name="ln6360">	int error, i;</a>
<a name="ln6361">	uint8_t flags;</a>
<a name="ln6362"> </a>
<a name="ln6363">	memset(&amp;btconfig, 0, sizeof btconfig);</a>
<a name="ln6364">	memset(&amp;btconfig2k, 0, sizeof btconfig2k);</a>
<a name="ln6365"> </a>
<a name="ln6366">	flags = IWN_BT_FLAG_COEX6000_MODE_3W &lt;&lt;</a>
<a name="ln6367">	    IWN_BT_FLAG_COEX6000_MODE_SHIFT; // Done as is in linux kernel 3.2</a>
<a name="ln6368"> </a>
<a name="ln6369">	if (sc-&gt;base_params-&gt;bt_sco_disable)</a>
<a name="ln6370">		flags &amp;= ~IWN_BT_FLAG_SYNC_2_BT_DISABLE;</a>
<a name="ln6371">	else</a>
<a name="ln6372">		flags |= IWN_BT_FLAG_SYNC_2_BT_DISABLE;</a>
<a name="ln6373"> </a>
<a name="ln6374">	flags |= IWN_BT_FLAG_COEX6000_CHAN_INHIBITION;</a>
<a name="ln6375"> </a>
<a name="ln6376">	/* Default flags result is 145 as old value */</a>
<a name="ln6377"> </a>
<a name="ln6378">	/*</a>
<a name="ln6379">	 * Flags value has to be review. Values must change if we</a>
<a name="ln6380">	 * which to disable it</a>
<a name="ln6381">	 */</a>
<a name="ln6382">	if (sc-&gt;base_params-&gt;bt_session_2) {</a>
<a name="ln6383">		btconfig2k.flags = flags;</a>
<a name="ln6384">		btconfig2k.max_kill = 5;</a>
<a name="ln6385">		btconfig2k.bt3_t7_timer = 1;</a>
<a name="ln6386">		btconfig2k.kill_ack = htole32(0xffff0000);</a>
<a name="ln6387">		btconfig2k.kill_cts = htole32(0xffff0000);</a>
<a name="ln6388">		btconfig2k.sample_time = 2;</a>
<a name="ln6389">		btconfig2k.bt3_t2_timer = 0xc;</a>
<a name="ln6390"> </a>
<a name="ln6391">		for (i = 0; i &lt; 12; i++)</a>
<a name="ln6392">			btconfig2k.lookup_table[i] = htole32(btcoex_3wire[i]);</a>
<a name="ln6393">		btconfig2k.valid = htole16(0xff);</a>
<a name="ln6394">		btconfig2k.prio_boost = htole32(0xf0);</a>
<a name="ln6395">		DPRINTF(sc, IWN_DEBUG_RESET,</a>
<a name="ln6396">		    &quot;%s: configuring advanced bluetooth coexistence&quot;</a>
<a name="ln6397">		    &quot; session 2, flags : 0x%x\n&quot;,</a>
<a name="ln6398">		    __func__,</a>
<a name="ln6399">		    flags);</a>
<a name="ln6400">		error = iwn_cmd(sc, IWN_CMD_BT_COEX, &amp;btconfig2k,</a>
<a name="ln6401">		    sizeof(btconfig2k), 1);</a>
<a name="ln6402">	} else {</a>
<a name="ln6403">		btconfig.flags = flags;</a>
<a name="ln6404">		btconfig.max_kill = 5;</a>
<a name="ln6405">		btconfig.bt3_t7_timer = 1;</a>
<a name="ln6406">		btconfig.kill_ack = htole32(0xffff0000);</a>
<a name="ln6407">		btconfig.kill_cts = htole32(0xffff0000);</a>
<a name="ln6408">		btconfig.sample_time = 2;</a>
<a name="ln6409">		btconfig.bt3_t2_timer = 0xc;</a>
<a name="ln6410"> </a>
<a name="ln6411">		for (i = 0; i &lt; 12; i++)</a>
<a name="ln6412">			btconfig.lookup_table[i] = htole32(btcoex_3wire[i]);</a>
<a name="ln6413">		btconfig.valid = htole16(0xff);</a>
<a name="ln6414">		btconfig.prio_boost = 0xf0;</a>
<a name="ln6415">		DPRINTF(sc, IWN_DEBUG_RESET,</a>
<a name="ln6416">		    &quot;%s: configuring advanced bluetooth coexistence,&quot;</a>
<a name="ln6417">		    &quot; flags : 0x%x\n&quot;,</a>
<a name="ln6418">		    __func__,</a>
<a name="ln6419">		    flags);</a>
<a name="ln6420">		error = iwn_cmd(sc, IWN_CMD_BT_COEX, &amp;btconfig,</a>
<a name="ln6421">		    sizeof(btconfig), 1);</a>
<a name="ln6422">	}</a>
<a name="ln6423"> </a>
<a name="ln6424">	if (error != 0)</a>
<a name="ln6425">		return error;</a>
<a name="ln6426"> </a>
<a name="ln6427">	memset(&amp;btprio, 0, sizeof btprio);</a>
<a name="ln6428">	btprio.calib_init1 = 0x6;</a>
<a name="ln6429">	btprio.calib_init2 = 0x7;</a>
<a name="ln6430">	btprio.calib_periodic_low1 = 0x2;</a>
<a name="ln6431">	btprio.calib_periodic_low2 = 0x3;</a>
<a name="ln6432">	btprio.calib_periodic_high1 = 0x4;</a>
<a name="ln6433">	btprio.calib_periodic_high2 = 0x5;</a>
<a name="ln6434">	btprio.dtim = 0x6;</a>
<a name="ln6435">	btprio.scan52 = 0x8;</a>
<a name="ln6436">	btprio.scan24 = 0xa;</a>
<a name="ln6437">	error = iwn_cmd(sc, IWN_CMD_BT_COEX_PRIOTABLE, &amp;btprio, sizeof(btprio),</a>
<a name="ln6438">	    1);</a>
<a name="ln6439">	if (error != 0)</a>
<a name="ln6440">		return error;</a>
<a name="ln6441"> </a>
<a name="ln6442">	/* Force BT state machine change. */</a>
<a name="ln6443">	memset(&amp;btprot, 0, sizeof btprot);</a>
<a name="ln6444">	btprot.open = 1;</a>
<a name="ln6445">	btprot.type = 1;</a>
<a name="ln6446">	error = iwn_cmd(sc, IWN_CMD_BT_COEX_PROT, &amp;btprot, sizeof(btprot), 1);</a>
<a name="ln6447">	if (error != 0)</a>
<a name="ln6448">		return error;</a>
<a name="ln6449">	btprot.open = 0;</a>
<a name="ln6450">	return iwn_cmd(sc, IWN_CMD_BT_COEX_PROT, &amp;btprot, sizeof(btprot), 1);</a>
<a name="ln6451">}</a>
<a name="ln6452"> </a>
<a name="ln6453">static int</a>
<a name="ln6454">iwn5000_runtime_calib(struct iwn_softc *sc)</a>
<a name="ln6455">{</a>
<a name="ln6456">	struct iwn5000_calib_config cmd;</a>
<a name="ln6457"> </a>
<a name="ln6458">	memset(&amp;cmd, 0, sizeof cmd);</a>
<a name="ln6459">	cmd.ucode.once.enable = 0xffffffff;</a>
<a name="ln6460">	cmd.ucode.once.start = IWN5000_CALIB_DC;</a>
<a name="ln6461">	DPRINTF(sc, IWN_DEBUG_CALIBRATE,</a>
<a name="ln6462">	    &quot;%s: configuring runtime calibration\n&quot;, __func__);</a>
<a name="ln6463">	return iwn_cmd(sc, IWN5000_CMD_CALIB_CONFIG, &amp;cmd, sizeof(cmd), 0);</a>
<a name="ln6464">}</a>
<a name="ln6465"> </a>
<a name="ln6466">static uint32_t</a>
<a name="ln6467">iwn_get_rxon_ht_flags(struct iwn_softc *sc, struct ieee80211_channel *c)</a>
<a name="ln6468">{</a>
<a name="ln6469">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln6470">	uint32_t htflags = 0;</a>
<a name="ln6471"> </a>
<a name="ln6472">	if (! IEEE80211_IS_CHAN_HT(c))</a>
<a name="ln6473">		return (0);</a>
<a name="ln6474"> </a>
<a name="ln6475">	htflags |= IWN_RXON_HT_PROTMODE(ic-&gt;ic_curhtprotmode);</a>
<a name="ln6476"> </a>
<a name="ln6477">	if (IEEE80211_IS_CHAN_HT40(c)) {</a>
<a name="ln6478">		switch (ic-&gt;ic_curhtprotmode) {</a>
<a name="ln6479">		case IEEE80211_HTINFO_OPMODE_HT20PR:</a>
<a name="ln6480">			htflags |= IWN_RXON_HT_MODEPURE40;</a>
<a name="ln6481">			break;</a>
<a name="ln6482">		default:</a>
<a name="ln6483">			htflags |= IWN_RXON_HT_MODEMIXED;</a>
<a name="ln6484">			break;</a>
<a name="ln6485">		}</a>
<a name="ln6486">	}</a>
<a name="ln6487">	if (IEEE80211_IS_CHAN_HT40D(c))</a>
<a name="ln6488">		htflags |= IWN_RXON_HT_HT40MINUS;</a>
<a name="ln6489"> </a>
<a name="ln6490">	return (htflags);</a>
<a name="ln6491">}</a>
<a name="ln6492"> </a>
<a name="ln6493">static int</a>
<a name="ln6494">iwn_check_bss_filter(struct iwn_softc *sc)</a>
<a name="ln6495">{</a>
<a name="ln6496">	return ((sc-&gt;rxon-&gt;filter &amp; htole32(IWN_FILTER_BSS)) != 0);</a>
<a name="ln6497">}</a>
<a name="ln6498"> </a>
<a name="ln6499">static int</a>
<a name="ln6500">iwn4965_rxon_assoc(struct iwn_softc *sc, int async)</a>
<a name="ln6501">{</a>
<a name="ln6502">	struct iwn4965_rxon_assoc cmd;</a>
<a name="ln6503">	struct iwn_rxon *rxon = sc-&gt;rxon;</a>
<a name="ln6504"> </a>
<a name="ln6505">	cmd.flags = rxon-&gt;flags;</a>
<a name="ln6506">	cmd.filter = rxon-&gt;filter;</a>
<a name="ln6507">	cmd.ofdm_mask = rxon-&gt;ofdm_mask;</a>
<a name="ln6508">	cmd.cck_mask = rxon-&gt;cck_mask;</a>
<a name="ln6509">	cmd.ht_single_mask = rxon-&gt;ht_single_mask;</a>
<a name="ln6510">	cmd.ht_dual_mask = rxon-&gt;ht_dual_mask;</a>
<a name="ln6511">	cmd.rxchain = rxon-&gt;rxchain;</a>
<a name="ln6512">	cmd.reserved = 0;</a>
<a name="ln6513"> </a>
<a name="ln6514">	return (iwn_cmd(sc, IWN_CMD_RXON_ASSOC, &amp;cmd, sizeof(cmd), async));</a>
<a name="ln6515">}</a>
<a name="ln6516"> </a>
<a name="ln6517">static int</a>
<a name="ln6518">iwn5000_rxon_assoc(struct iwn_softc *sc, int async)</a>
<a name="ln6519">{</a>
<a name="ln6520">	struct iwn5000_rxon_assoc cmd;</a>
<a name="ln6521">	struct iwn_rxon *rxon = sc-&gt;rxon;</a>
<a name="ln6522"> </a>
<a name="ln6523">	cmd.flags = rxon-&gt;flags;</a>
<a name="ln6524">	cmd.filter = rxon-&gt;filter;</a>
<a name="ln6525">	cmd.ofdm_mask = rxon-&gt;ofdm_mask;</a>
<a name="ln6526">	cmd.cck_mask = rxon-&gt;cck_mask;</a>
<a name="ln6527">	cmd.reserved1 = 0;</a>
<a name="ln6528">	cmd.ht_single_mask = rxon-&gt;ht_single_mask;</a>
<a name="ln6529">	cmd.ht_dual_mask = rxon-&gt;ht_dual_mask;</a>
<a name="ln6530">	cmd.ht_triple_mask = rxon-&gt;ht_triple_mask;</a>
<a name="ln6531">	cmd.reserved2 = 0;</a>
<a name="ln6532">	cmd.rxchain = rxon-&gt;rxchain;</a>
<a name="ln6533">	cmd.acquisition = rxon-&gt;acquisition;</a>
<a name="ln6534">	cmd.reserved3 = 0;</a>
<a name="ln6535"> </a>
<a name="ln6536">	return (iwn_cmd(sc, IWN_CMD_RXON_ASSOC, &amp;cmd, sizeof(cmd), async));</a>
<a name="ln6537">}</a>
<a name="ln6538"> </a>
<a name="ln6539">static int</a>
<a name="ln6540">iwn_send_rxon(struct iwn_softc *sc, int assoc, int async)</a>
<a name="ln6541">{</a>
<a name="ln6542">	struct iwn_ops *ops = &amp;sc-&gt;ops;</a>
<a name="ln6543">	int error;</a>
<a name="ln6544"> </a>
<a name="ln6545">	IWN_LOCK_ASSERT(sc);</a>
<a name="ln6546"> </a>
<a name="ln6547">	if (assoc &amp;&amp; iwn_check_bss_filter(sc) != 0) {</a>
<a name="ln6548">		error = ops-&gt;rxon_assoc(sc, async);</a>
<a name="ln6549">		if (error != 0) {</a>
<a name="ln6550">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln6551">			    &quot;%s: RXON_ASSOC command failed, error %d\n&quot;,</a>
<a name="ln6552">			    __func__, error);</a>
<a name="ln6553">			return (error);</a>
<a name="ln6554">		}</a>
<a name="ln6555">	} else {</a>
<a name="ln6556">		if (sc-&gt;sc_is_scanning)</a>
<a name="ln6557">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln6558">			    &quot;%s: is_scanning set, before RXON\n&quot;,</a>
<a name="ln6559">			    __func__);</a>
<a name="ln6560"> </a>
<a name="ln6561">		error = iwn_cmd(sc, IWN_CMD_RXON, sc-&gt;rxon, sc-&gt;rxonsz, async);</a>
<a name="ln6562">		if (error != 0) {</a>
<a name="ln6563">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln6564">			    &quot;%s: RXON command failed, error %d\n&quot;,</a>
<a name="ln6565">			    __func__, error);</a>
<a name="ln6566">			return (error);</a>
<a name="ln6567">		}</a>
<a name="ln6568"> </a>
<a name="ln6569">		/*</a>
<a name="ln6570">		 * Reconfiguring RXON clears the firmware nodes table so</a>
<a name="ln6571">		 * we must add the broadcast node again.</a>
<a name="ln6572">		 */</a>
<a name="ln6573">		if (iwn_check_bss_filter(sc) == 0 &amp;&amp;</a>
<a name="ln6574">		    (error = iwn_add_broadcast_node(sc, async)) != 0) {</a>
<a name="ln6575">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln6576">			    &quot;%s: could not add broadcast node, error %d\n&quot;,</a>
<a name="ln6577">			    __func__, error);</a>
<a name="ln6578">			return (error);</a>
<a name="ln6579">		}</a>
<a name="ln6580">	}</a>
<a name="ln6581"> </a>
<a name="ln6582">	/* Configuration has changed, set TX power accordingly. */</a>
<a name="ln6583">	if ((error = ops-&gt;set_txpower(sc, async)) != 0) {</a>
<a name="ln6584">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln6585">		    &quot;%s: could not set TX power, error %d\n&quot;,</a>
<a name="ln6586">		    __func__, error);</a>
<a name="ln6587">		return (error);</a>
<a name="ln6588">	}</a>
<a name="ln6589"> </a>
<a name="ln6590">	return (0);</a>
<a name="ln6591">}</a>
<a name="ln6592"> </a>
<a name="ln6593">static int</a>
<a name="ln6594">iwn_config(struct iwn_softc *sc)</a>
<a name="ln6595">{</a>
<a name="ln6596">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln6597">	struct ieee80211vap *vap = TAILQ_FIRST(&amp;ic-&gt;ic_vaps);</a>
<a name="ln6598">	const uint8_t *macaddr;</a>
<a name="ln6599">	uint32_t txmask;</a>
<a name="ln6600">	uint16_t rxchain;</a>
<a name="ln6601">	int error;</a>
<a name="ln6602"> </a>
<a name="ln6603">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln6604"> </a>
<a name="ln6605">	if ((sc-&gt;base_params-&gt;calib_need &amp; IWN_FLG_NEED_PHY_CALIB_TEMP_OFFSET)</a>
<a name="ln6606">	    &amp;&amp; (sc-&gt;base_params-&gt;calib_need &amp; IWN_FLG_NEED_PHY_CALIB_TEMP_OFFSETv2)) {</a>
<a name="ln6607">		device_printf(sc-&gt;sc_dev,&quot;%s: temp_offset and temp_offsetv2 are&quot;</a>
<a name="ln6608">		    &quot; exclusive each together. Review NIC config file. Conf&quot;</a>
<a name="ln6609">		    &quot; :  0x%08x Flags :  0x%08x  \n&quot;, __func__,</a>
<a name="ln6610">		    sc-&gt;base_params-&gt;calib_need,</a>
<a name="ln6611">		    (IWN_FLG_NEED_PHY_CALIB_TEMP_OFFSET |</a>
<a name="ln6612">		    IWN_FLG_NEED_PHY_CALIB_TEMP_OFFSETv2));</a>
<a name="ln6613">		return (EINVAL);</a>
<a name="ln6614">	}</a>
<a name="ln6615"> </a>
<a name="ln6616">	/* Compute temperature calib if needed. Will be send by send calib */</a>
<a name="ln6617">	if (sc-&gt;base_params-&gt;calib_need &amp; IWN_FLG_NEED_PHY_CALIB_TEMP_OFFSET) {</a>
<a name="ln6618">		error = iwn5000_temp_offset_calib(sc);</a>
<a name="ln6619">		if (error != 0) {</a>
<a name="ln6620">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln6621">			    &quot;%s: could not set temperature offset\n&quot;, __func__);</a>
<a name="ln6622">			return (error);</a>
<a name="ln6623">		}</a>
<a name="ln6624">	} else if (sc-&gt;base_params-&gt;calib_need &amp; IWN_FLG_NEED_PHY_CALIB_TEMP_OFFSETv2) {</a>
<a name="ln6625">		error = iwn5000_temp_offset_calibv2(sc);</a>
<a name="ln6626">		if (error != 0) {</a>
<a name="ln6627">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln6628">			    &quot;%s: could not compute temperature offset v2\n&quot;,</a>
<a name="ln6629">			    __func__);</a>
<a name="ln6630">			return (error);</a>
<a name="ln6631">		}</a>
<a name="ln6632">	}</a>
<a name="ln6633"> </a>
<a name="ln6634">	if (sc-&gt;hw_type == IWN_HW_REV_TYPE_6050) {</a>
<a name="ln6635">		/* Configure runtime DC calibration. */</a>
<a name="ln6636">		error = iwn5000_runtime_calib(sc);</a>
<a name="ln6637">		if (error != 0) {</a>
<a name="ln6638">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln6639">			    &quot;%s: could not configure runtime calibration\n&quot;,</a>
<a name="ln6640">			    __func__);</a>
<a name="ln6641">			return error;</a>
<a name="ln6642">		}</a>
<a name="ln6643">	}</a>
<a name="ln6644"> </a>
<a name="ln6645">	/* Configure valid TX chains for &gt;=5000 Series. */</a>
<a name="ln6646">	if (sc-&gt;hw_type != IWN_HW_REV_TYPE_4965 &amp;&amp;</a>
<a name="ln6647">	    IWN_UCODE_API(sc-&gt;ucode_rev) &gt; 1) {</a>
<a name="ln6648">		txmask = htole32(sc-&gt;txchainmask);</a>
<a name="ln6649">		DPRINTF(sc, IWN_DEBUG_RESET | IWN_DEBUG_XMIT,</a>
<a name="ln6650">		    &quot;%s: configuring valid TX chains 0x%x\n&quot;, __func__, txmask);</a>
<a name="ln6651">		error = iwn_cmd(sc, IWN5000_CMD_TX_ANT_CONFIG, &amp;txmask,</a>
<a name="ln6652">		    sizeof txmask, 0);</a>
<a name="ln6653">		if (error != 0) {</a>
<a name="ln6654">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln6655">			    &quot;%s: could not configure valid TX chains, &quot;</a>
<a name="ln6656">			    &quot;error %d\n&quot;, __func__, error);</a>
<a name="ln6657">			return error;</a>
<a name="ln6658">		}</a>
<a name="ln6659">	}</a>
<a name="ln6660"> </a>
<a name="ln6661">	/* Configure bluetooth coexistence. */</a>
<a name="ln6662">	error = 0;</a>
<a name="ln6663"> </a>
<a name="ln6664">	/* Configure bluetooth coexistence if needed. */</a>
<a name="ln6665">	if (sc-&gt;base_params-&gt;bt_mode == IWN_BT_ADVANCED)</a>
<a name="ln6666">		error = iwn_send_advanced_btcoex(sc);</a>
<a name="ln6667">	if (sc-&gt;base_params-&gt;bt_mode == IWN_BT_SIMPLE)</a>
<a name="ln6668">		error = iwn_send_btcoex(sc);</a>
<a name="ln6669"> </a>
<a name="ln6670">	if (error != 0) {</a>
<a name="ln6671">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln6672">		    &quot;%s: could not configure bluetooth coexistence, error %d\n&quot;,</a>
<a name="ln6673">		    __func__, error);</a>
<a name="ln6674">		return error;</a>
<a name="ln6675">	}</a>
<a name="ln6676"> </a>
<a name="ln6677">	/* Set mode, channel, RX filter and enable RX. */</a>
<a name="ln6678">	sc-&gt;rxon = &amp;sc-&gt;rx_on[IWN_RXON_BSS_CTX];</a>
<a name="ln6679">	memset(sc-&gt;rxon, 0, sizeof (struct iwn_rxon));</a>
<a name="ln6680">	macaddr = vap ? vap-&gt;iv_myaddr : ic-&gt;ic_macaddr;</a>
<a name="ln6681">	IEEE80211_ADDR_COPY(sc-&gt;rxon-&gt;myaddr, macaddr);</a>
<a name="ln6682">	IEEE80211_ADDR_COPY(sc-&gt;rxon-&gt;wlap, macaddr);</a>
<a name="ln6683">	sc-&gt;rxon-&gt;chan = ieee80211_chan2ieee(ic, ic-&gt;ic_curchan);</a>
<a name="ln6684">	sc-&gt;rxon-&gt;flags = htole32(IWN_RXON_TSF | IWN_RXON_CTS_TO_SELF);</a>
<a name="ln6685">	if (IEEE80211_IS_CHAN_2GHZ(ic-&gt;ic_curchan))</a>
<a name="ln6686">		sc-&gt;rxon-&gt;flags |= htole32(IWN_RXON_AUTO | IWN_RXON_24GHZ);</a>
<a name="ln6687"> </a>
<a name="ln6688">	sc-&gt;rxon-&gt;filter = htole32(IWN_FILTER_MULTICAST);</a>
<a name="ln6689">	switch (ic-&gt;ic_opmode) {</a>
<a name="ln6690">	case IEEE80211_M_STA:</a>
<a name="ln6691">		sc-&gt;rxon-&gt;mode = IWN_MODE_STA;</a>
<a name="ln6692">		break;</a>
<a name="ln6693">	case IEEE80211_M_MONITOR:</a>
<a name="ln6694">		sc-&gt;rxon-&gt;mode = IWN_MODE_MONITOR;</a>
<a name="ln6695">		break;</a>
<a name="ln6696">	default:</a>
<a name="ln6697">		/* Should not get there. */</a>
<a name="ln6698">		break;</a>
<a name="ln6699">	}</a>
<a name="ln6700">	iwn_set_promisc(sc);</a>
<a name="ln6701">	sc-&gt;rxon-&gt;cck_mask  = 0x0f;	/* not yet negotiated */</a>
<a name="ln6702">	sc-&gt;rxon-&gt;ofdm_mask = 0xff;	/* not yet negotiated */</a>
<a name="ln6703">	sc-&gt;rxon-&gt;ht_single_mask = 0xff;</a>
<a name="ln6704">	sc-&gt;rxon-&gt;ht_dual_mask = 0xff;</a>
<a name="ln6705">	sc-&gt;rxon-&gt;ht_triple_mask = 0xff;</a>
<a name="ln6706">	/*</a>
<a name="ln6707">	 * In active association mode, ensure that</a>
<a name="ln6708">	 * all the receive chains are enabled.</a>
<a name="ln6709">	 *</a>
<a name="ln6710">	 * Since we're not yet doing SMPS, don't allow the</a>
<a name="ln6711">	 * number of idle RX chains to be less than the active</a>
<a name="ln6712">	 * number.</a>
<a name="ln6713">	 */</a>
<a name="ln6714">	rxchain =</a>
<a name="ln6715">	    IWN_RXCHAIN_VALID(sc-&gt;rxchainmask) |</a>
<a name="ln6716">	    IWN_RXCHAIN_MIMO_COUNT(sc-&gt;nrxchains) |</a>
<a name="ln6717">	    IWN_RXCHAIN_IDLE_COUNT(sc-&gt;nrxchains);</a>
<a name="ln6718">	sc-&gt;rxon-&gt;rxchain = htole16(rxchain);</a>
<a name="ln6719">	DPRINTF(sc, IWN_DEBUG_RESET | IWN_DEBUG_XMIT,</a>
<a name="ln6720">	    &quot;%s: rxchainmask=0x%x, nrxchains=%d\n&quot;,</a>
<a name="ln6721">	    __func__,</a>
<a name="ln6722">	    sc-&gt;rxchainmask,</a>
<a name="ln6723">	    sc-&gt;nrxchains);</a>
<a name="ln6724"> </a>
<a name="ln6725">	sc-&gt;rxon-&gt;flags |= htole32(iwn_get_rxon_ht_flags(sc, ic-&gt;ic_curchan));</a>
<a name="ln6726"> </a>
<a name="ln6727">	DPRINTF(sc, IWN_DEBUG_RESET,</a>
<a name="ln6728">	    &quot;%s: setting configuration; flags=0x%08x\n&quot;,</a>
<a name="ln6729">	    __func__, le32toh(sc-&gt;rxon-&gt;flags));</a>
<a name="ln6730">	if ((error = iwn_send_rxon(sc, 0, 0)) != 0) {</a>
<a name="ln6731">		device_printf(sc-&gt;sc_dev, &quot;%s: could not send RXON\n&quot;,</a>
<a name="ln6732">		    __func__);</a>
<a name="ln6733">		return error;</a>
<a name="ln6734">	}</a>
<a name="ln6735"> </a>
<a name="ln6736">	if ((error = iwn_set_critical_temp(sc)) != 0) {</a>
<a name="ln6737">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln6738">		    &quot;%s: could not set critical temperature\n&quot;, __func__);</a>
<a name="ln6739">		return error;</a>
<a name="ln6740">	}</a>
<a name="ln6741"> </a>
<a name="ln6742">	/* Set power saving level to CAM during initialization. */</a>
<a name="ln6743">	if ((error = iwn_set_pslevel(sc, 0, 0, 0)) != 0) {</a>
<a name="ln6744">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln6745">		    &quot;%s: could not set power saving level\n&quot;, __func__);</a>
<a name="ln6746">		return error;</a>
<a name="ln6747">	}</a>
<a name="ln6748"> </a>
<a name="ln6749">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: end\n&quot;,__func__);</a>
<a name="ln6750"> </a>
<a name="ln6751">	return 0;</a>
<a name="ln6752">}</a>
<a name="ln6753"> </a>
<a name="ln6754">static uint16_t</a>
<a name="ln6755">iwn_get_active_dwell_time(struct iwn_softc *sc,</a>
<a name="ln6756">    struct ieee80211_channel *c, uint8_t n_probes)</a>
<a name="ln6757">{</a>
<a name="ln6758">	/* No channel? Default to 2GHz settings */</a>
<a name="ln6759">	if (c == NULL || IEEE80211_IS_CHAN_2GHZ(c)) {</a>
<a name="ln6760">		return (IWN_ACTIVE_DWELL_TIME_2GHZ +</a>
<a name="ln6761">		IWN_ACTIVE_DWELL_FACTOR_2GHZ * (n_probes + 1));</a>
<a name="ln6762">	}</a>
<a name="ln6763"> </a>
<a name="ln6764">	/* 5GHz dwell time */</a>
<a name="ln6765">	return (IWN_ACTIVE_DWELL_TIME_5GHZ +</a>
<a name="ln6766">	    IWN_ACTIVE_DWELL_FACTOR_5GHZ * (n_probes + 1));</a>
<a name="ln6767">}</a>
<a name="ln6768"> </a>
<a name="ln6769">/*</a>
<a name="ln6770"> * Limit the total dwell time to 85% of the beacon interval.</a>
<a name="ln6771"> *</a>
<a name="ln6772"> * Returns the dwell time in milliseconds.</a>
<a name="ln6773"> */</a>
<a name="ln6774">static uint16_t</a>
<a name="ln6775">iwn_limit_dwell(struct iwn_softc *sc, uint16_t dwell_time)</a>
<a name="ln6776">{</a>
<a name="ln6777">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln6778">	struct ieee80211vap *vap = NULL;</a>
<a name="ln6779">	int bintval = 0;</a>
<a name="ln6780"> </a>
<a name="ln6781">	/* bintval is in TU (1.024mS) */</a>
<a name="ln6782">	if (! TAILQ_EMPTY(&amp;ic-&gt;ic_vaps)) {</a>
<a name="ln6783">		vap = TAILQ_FIRST(&amp;ic-&gt;ic_vaps);</a>
<a name="ln6784">		bintval = vap-&gt;iv_bss-&gt;ni_intval;</a>
<a name="ln6785">	}</a>
<a name="ln6786"> </a>
<a name="ln6787">	/*</a>
<a name="ln6788">	 * If it's non-zero, we should calculate the minimum of</a>
<a name="ln6789">	 * it and the DWELL_BASE.</a>
<a name="ln6790">	 *</a>
<a name="ln6791">	 * XXX Yes, the math should take into account that bintval</a>
<a name="ln6792">	 * is 1.024mS, not 1mS..</a>
<a name="ln6793">	 */</a>
<a name="ln6794">	if (bintval &gt; 0) {</a>
<a name="ln6795">		DPRINTF(sc, IWN_DEBUG_SCAN,</a>
<a name="ln6796">		    &quot;%s: bintval=%d\n&quot;,</a>
<a name="ln6797">		    __func__,</a>
<a name="ln6798">		    bintval);</a>
<a name="ln6799">		return (MIN(IWN_PASSIVE_DWELL_BASE, ((bintval * 85) / 100)));</a>
<a name="ln6800">	}</a>
<a name="ln6801"> </a>
<a name="ln6802">	/* No association context? Default */</a>
<a name="ln6803">	return (IWN_PASSIVE_DWELL_BASE);</a>
<a name="ln6804">}</a>
<a name="ln6805"> </a>
<a name="ln6806">static uint16_t</a>
<a name="ln6807">iwn_get_passive_dwell_time(struct iwn_softc *sc, struct ieee80211_channel *c)</a>
<a name="ln6808">{</a>
<a name="ln6809">	uint16_t passive;</a>
<a name="ln6810"> </a>
<a name="ln6811">	if (c == NULL || IEEE80211_IS_CHAN_2GHZ(c)) {</a>
<a name="ln6812">		passive = IWN_PASSIVE_DWELL_BASE + IWN_PASSIVE_DWELL_TIME_2GHZ;</a>
<a name="ln6813">	} else {</a>
<a name="ln6814">		passive = IWN_PASSIVE_DWELL_BASE + IWN_PASSIVE_DWELL_TIME_5GHZ;</a>
<a name="ln6815">	}</a>
<a name="ln6816"> </a>
<a name="ln6817">	/* Clamp to the beacon interval if we're associated */</a>
<a name="ln6818">	return (iwn_limit_dwell(sc, passive));</a>
<a name="ln6819">}</a>
<a name="ln6820"> </a>
<a name="ln6821">static int</a>
<a name="ln6822">iwn_scan(struct iwn_softc *sc, struct ieee80211vap *vap,</a>
<a name="ln6823">    struct ieee80211_scan_state *ss, struct ieee80211_channel *c)</a>
<a name="ln6824">{</a>
<a name="ln6825">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln6826">	struct ieee80211_node *ni = vap-&gt;iv_bss;</a>
<a name="ln6827">	struct iwn_scan_hdr *hdr;</a>
<a name="ln6828">	struct iwn_cmd_data *tx;</a>
<a name="ln6829">	struct iwn_scan_essid *essid;</a>
<a name="ln6830">	struct iwn_scan_chan *chan;</a>
<a name="ln6831">	struct ieee80211_frame *wh;</a>
<a name="ln6832">	struct ieee80211_rateset *rs;</a>
<a name="ln6833">	uint8_t *buf, *frm;</a>
<a name="ln6834">	uint16_t rxchain;</a>
<a name="ln6835">	uint8_t txant;</a>
<a name="ln6836">	int buflen, error;</a>
<a name="ln6837">	int is_active;</a>
<a name="ln6838">	uint16_t dwell_active, dwell_passive;</a>
<a name="ln6839">	uint32_t extra, scan_service_time;</a>
<a name="ln6840"> </a>
<a name="ln6841">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln6842"> </a>
<a name="ln6843">	/*</a>
<a name="ln6844">	 * We are absolutely not allowed to send a scan command when another</a>
<a name="ln6845">	 * scan command is pending.</a>
<a name="ln6846">	 */</a>
<a name="ln6847">	if (sc-&gt;sc_is_scanning) {</a>
<a name="ln6848">		device_printf(sc-&gt;sc_dev, &quot;%s: called whilst scanning!\n&quot;,</a>
<a name="ln6849">		    __func__);</a>
<a name="ln6850">		return (EAGAIN);</a>
<a name="ln6851">	}</a>
<a name="ln6852"> </a>
<a name="ln6853">	/* Assign the scan channel */</a>
<a name="ln6854">	c = ic-&gt;ic_curchan;</a>
<a name="ln6855"> </a>
<a name="ln6856">	sc-&gt;rxon = &amp;sc-&gt;rx_on[IWN_RXON_BSS_CTX];</a>
<a name="ln6857">	buf = malloc(IWN_SCAN_MAXSZ, M_DEVBUF, M_NOWAIT | M_ZERO);</a>
<a name="ln6858">	if (buf == NULL) {</a>
<a name="ln6859">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln6860">		    &quot;%s: could not allocate buffer for scan command\n&quot;,</a>
<a name="ln6861">		    __func__);</a>
<a name="ln6862">		return ENOMEM;</a>
<a name="ln6863">	}</a>
<a name="ln6864">	hdr = (struct iwn_scan_hdr *)buf;</a>
<a name="ln6865">	/*</a>
<a name="ln6866">	 * Move to the next channel if no frames are received within 10ms</a>
<a name="ln6867">	 * after sending the probe request.</a>
<a name="ln6868">	 */</a>
<a name="ln6869">	hdr-&gt;quiet_time = htole16(10);		/* timeout in milliseconds */</a>
<a name="ln6870">	hdr-&gt;quiet_threshold = htole16(1);	/* min # of packets */</a>
<a name="ln6871">	/*</a>
<a name="ln6872">	 * Max needs to be greater than active and passive and quiet!</a>
<a name="ln6873">	 * It's also in microseconds!</a>
<a name="ln6874">	 */</a>
<a name="ln6875">	hdr-&gt;max_svc = htole32(250 * 1024);</a>
<a name="ln6876"> </a>
<a name="ln6877">	/*</a>
<a name="ln6878">	 * Reset scan: interval=100</a>
<a name="ln6879">	 * Normal scan: interval=becaon interval</a>
<a name="ln6880">	 * suspend_time: 100 (TU)</a>
<a name="ln6881">	 *</a>
<a name="ln6882">	 */</a>
<a name="ln6883">	extra = (100 /* suspend_time */ / 100 /* beacon interval */) &lt;&lt; 22;</a>
<a name="ln6884">	//scan_service_time = extra | ((100 /* susp */ % 100 /* int */) * 1024);</a>
<a name="ln6885">	scan_service_time = (4 &lt;&lt; 22) | (100 * 1024);	/* Hardcode for now! */</a>
<a name="ln6886">	hdr-&gt;pause_svc = htole32(scan_service_time);</a>
<a name="ln6887"> </a>
<a name="ln6888">	/* Select antennas for scanning. */</a>
<a name="ln6889">	rxchain =</a>
<a name="ln6890">	    IWN_RXCHAIN_VALID(sc-&gt;rxchainmask) |</a>
<a name="ln6891">	    IWN_RXCHAIN_FORCE_MIMO_SEL(sc-&gt;rxchainmask) |</a>
<a name="ln6892">	    IWN_RXCHAIN_DRIVER_FORCE;</a>
<a name="ln6893">	if (IEEE80211_IS_CHAN_A(c) &amp;&amp;</a>
<a name="ln6894">	    sc-&gt;hw_type == IWN_HW_REV_TYPE_4965) {</a>
<a name="ln6895">		/* Ant A must be avoided in 5GHz because of an HW bug. */</a>
<a name="ln6896">		rxchain |= IWN_RXCHAIN_FORCE_SEL(IWN_ANT_B);</a>
<a name="ln6897">	} else	/* Use all available RX antennas. */</a>
<a name="ln6898">		rxchain |= IWN_RXCHAIN_FORCE_SEL(sc-&gt;rxchainmask);</a>
<a name="ln6899">	hdr-&gt;rxchain = htole16(rxchain);</a>
<a name="ln6900">	hdr-&gt;filter = htole32(IWN_FILTER_MULTICAST | IWN_FILTER_BEACON);</a>
<a name="ln6901"> </a>
<a name="ln6902">	tx = (struct iwn_cmd_data *)(hdr + 1);</a>
<a name="ln6903">	tx-&gt;flags = htole32(IWN_TX_AUTO_SEQ);</a>
<a name="ln6904">	tx-&gt;id = sc-&gt;broadcast_id;</a>
<a name="ln6905">	tx-&gt;lifetime = htole32(IWN_LIFETIME_INFINITE);</a>
<a name="ln6906"> </a>
<a name="ln6907">	if (IEEE80211_IS_CHAN_5GHZ(c)) {</a>
<a name="ln6908">		/* Send probe requests at 6Mbps. */</a>
<a name="ln6909">		tx-&gt;rate = htole32(0xd);</a>
<a name="ln6910">		rs = &amp;ic-&gt;ic_sup_rates[IEEE80211_MODE_11A];</a>
<a name="ln6911">	} else {</a>
<a name="ln6912">		hdr-&gt;flags = htole32(IWN_RXON_24GHZ | IWN_RXON_AUTO);</a>
<a name="ln6913">		if (sc-&gt;hw_type == IWN_HW_REV_TYPE_4965 &amp;&amp;</a>
<a name="ln6914">		    sc-&gt;rxon-&gt;associd &amp;&amp; sc-&gt;rxon-&gt;chan &gt; 14)</a>
<a name="ln6915">			tx-&gt;rate = htole32(0xd);</a>
<a name="ln6916">		else {</a>
<a name="ln6917">			/* Send probe requests at 1Mbps. */</a>
<a name="ln6918">			tx-&gt;rate = htole32(10 | IWN_RFLAG_CCK);</a>
<a name="ln6919">		}</a>
<a name="ln6920">		rs = &amp;ic-&gt;ic_sup_rates[IEEE80211_MODE_11G];</a>
<a name="ln6921">	}</a>
<a name="ln6922">	/* Use the first valid TX antenna. */</a>
<a name="ln6923">	txant = IWN_LSB(sc-&gt;txchainmask);</a>
<a name="ln6924">	tx-&gt;rate |= htole32(IWN_RFLAG_ANT(txant));</a>
<a name="ln6925"> </a>
<a name="ln6926">	/*</a>
<a name="ln6927">	 * Only do active scanning if we're announcing a probe request</a>
<a name="ln6928">	 * for a given SSID (or more, if we ever add it to the driver.)</a>
<a name="ln6929">	 */</a>
<a name="ln6930">	is_active = 0;</a>
<a name="ln6931"> </a>
<a name="ln6932">	/*</a>
<a name="ln6933">	 * If we're scanning for a specific SSID, add it to the command.</a>
<a name="ln6934">	 *</a>
<a name="ln6935">	 * XXX maybe look at adding support for scanning multiple SSIDs?</a>
<a name="ln6936">	 */</a>
<a name="ln6937">	essid = (struct iwn_scan_essid *)(tx + 1);</a>
<a name="ln6938">	if (ss != NULL) {</a>
<a name="ln6939">		if (ss-&gt;ss_ssid[0].len != 0) {</a>
<a name="ln6940">			essid[0].id = IEEE80211_ELEMID_SSID;</a>
<a name="ln6941">			essid[0].len = ss-&gt;ss_ssid[0].len;</a>
<a name="ln6942">			memcpy(essid[0].data, ss-&gt;ss_ssid[0].ssid, ss-&gt;ss_ssid[0].len);</a>
<a name="ln6943">		}</a>
<a name="ln6944"> </a>
<a name="ln6945">		DPRINTF(sc, IWN_DEBUG_SCAN, &quot;%s: ssid_len=%d, ssid=%*s\n&quot;,</a>
<a name="ln6946">		    __func__,</a>
<a name="ln6947">		    ss-&gt;ss_ssid[0].len,</a>
<a name="ln6948">		    ss-&gt;ss_ssid[0].len,</a>
<a name="ln6949">		    ss-&gt;ss_ssid[0].ssid);</a>
<a name="ln6950"> </a>
<a name="ln6951">		if (ss-&gt;ss_nssid &gt; 0)</a>
<a name="ln6952">			is_active = 1;</a>
<a name="ln6953">	}</a>
<a name="ln6954"> </a>
<a name="ln6955">	/*</a>
<a name="ln6956">	 * Build a probe request frame.  Most of the following code is a</a>
<a name="ln6957">	 * copy &amp; paste of what is done in net80211.</a>
<a name="ln6958">	 */</a>
<a name="ln6959">	wh = (struct ieee80211_frame *)(essid + 20);</a>
<a name="ln6960">	wh-&gt;i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_MGT |</a>
<a name="ln6961">	    IEEE80211_FC0_SUBTYPE_PROBE_REQ;</a>
<a name="ln6962">	wh-&gt;i_fc[1] = IEEE80211_FC1_DIR_NODS;</a>
<a name="ln6963">	IEEE80211_ADDR_COPY(wh-&gt;i_addr1, vap-&gt;iv_ifp-&gt;if_broadcastaddr);</a>
<a name="ln6964">	IEEE80211_ADDR_COPY(wh-&gt;i_addr2, IF_LLADDR(vap-&gt;iv_ifp));</a>
<a name="ln6965">	IEEE80211_ADDR_COPY(wh-&gt;i_addr3, vap-&gt;iv_ifp-&gt;if_broadcastaddr);</a>
<a name="ln6966">	*(uint16_t *)&amp;wh-&gt;i_dur[0] = 0;	/* filled by HW */</a>
<a name="ln6967">	*(uint16_t *)&amp;wh-&gt;i_seq[0] = 0;	/* filled by HW */</a>
<a name="ln6968"> </a>
<a name="ln6969">	frm = (uint8_t *)(wh + 1);</a>
<a name="ln6970">	frm = ieee80211_add_ssid(frm, NULL, 0);</a>
<a name="ln6971">	frm = ieee80211_add_rates(frm, rs);</a>
<a name="ln6972">	if (rs-&gt;rs_nrates &gt; IEEE80211_RATE_SIZE)</a>
<a name="ln6973">		frm = ieee80211_add_xrates(frm, rs);</a>
<a name="ln6974">	if (ic-&gt;ic_htcaps &amp; IEEE80211_HTC_HT)</a>
<a name="ln6975">		frm = ieee80211_add_htcap(frm, ni);</a>
<a name="ln6976"> </a>
<a name="ln6977">	/* Set length of probe request. */</a>
<a name="ln6978">	tx-&gt;len = htole16(frm - (uint8_t *)wh);</a>
<a name="ln6979"> </a>
<a name="ln6980">	/*</a>
<a name="ln6981">	 * If active scanning is requested but a certain channel is</a>
<a name="ln6982">	 * marked passive, we can do active scanning if we detect</a>
<a name="ln6983">	 * transmissions.</a>
<a name="ln6984">	 *</a>
<a name="ln6985">	 * There is an issue with some firmware versions that triggers</a>
<a name="ln6986">	 * a sysassert on a &quot;good CRC threshold&quot; of zero (== disabled),</a>
<a name="ln6987">	 * on a radar channel even though this means that we should NOT</a>
<a name="ln6988">	 * send probes.</a>
<a name="ln6989">	 *</a>
<a name="ln6990">	 * The &quot;good CRC threshold&quot; is the number of frames that we</a>
<a name="ln6991">	 * need to receive during our dwell time on a channel before</a>
<a name="ln6992">	 * sending out probes -- setting this to a huge value will</a>
<a name="ln6993">	 * mean we never reach it, but at the same time work around</a>
<a name="ln6994">	 * the aforementioned issue. Thus use IWL_GOOD_CRC_TH_NEVER</a>
<a name="ln6995">	 * here instead of IWL_GOOD_CRC_TH_DISABLED.</a>
<a name="ln6996">	 *</a>
<a name="ln6997">	 * This was fixed in later versions along with some other</a>
<a name="ln6998">	 * scan changes, and the threshold behaves as a flag in those</a>
<a name="ln6999">	 * versions.</a>
<a name="ln7000">	 */</a>
<a name="ln7001"> </a>
<a name="ln7002">	/*</a>
<a name="ln7003">	 * If we're doing active scanning, set the crc_threshold</a>
<a name="ln7004">	 * to a suitable value.  This is different to active veruss</a>
<a name="ln7005">	 * passive scanning depending upon the channel flags; the</a>
<a name="ln7006">	 * firmware will obey that particular check for us.</a>
<a name="ln7007">	 */</a>
<a name="ln7008">	if (sc-&gt;tlv_feature_flags &amp; IWN_UCODE_TLV_FLAGS_NEWSCAN)</a>
<a name="ln7009">		hdr-&gt;crc_threshold = is_active ?</a>
<a name="ln7010">		    IWN_GOOD_CRC_TH_DEFAULT : IWN_GOOD_CRC_TH_DISABLED;</a>
<a name="ln7011">	else</a>
<a name="ln7012">		hdr-&gt;crc_threshold = is_active ?</a>
<a name="ln7013">		    IWN_GOOD_CRC_TH_DEFAULT : IWN_GOOD_CRC_TH_NEVER;</a>
<a name="ln7014"> </a>
<a name="ln7015">	chan = (struct iwn_scan_chan *)frm;</a>
<a name="ln7016">	chan-&gt;chan = htole16(ieee80211_chan2ieee(ic, c));</a>
<a name="ln7017">	chan-&gt;flags = 0;</a>
<a name="ln7018">	if (ss-&gt;ss_nssid &gt; 0)</a>
<a name="ln7019">		chan-&gt;flags |= htole32(IWN_CHAN_NPBREQS(1));</a>
<a name="ln7020">	chan-&gt;dsp_gain = 0x6e;</a>
<a name="ln7021"> </a>
<a name="ln7022">	/*</a>
<a name="ln7023">	 * Set the passive/active flag depending upon the channel mode.</a>
<a name="ln7024">	 * XXX TODO: take the is_active flag into account as well?</a>
<a name="ln7025">	 */</a>
<a name="ln7026">	if (c-&gt;ic_flags &amp; IEEE80211_CHAN_PASSIVE)</a>
<a name="ln7027">		chan-&gt;flags |= htole32(IWN_CHAN_PASSIVE);</a>
<a name="ln7028">	else</a>
<a name="ln7029">		chan-&gt;flags |= htole32(IWN_CHAN_ACTIVE);</a>
<a name="ln7030"> </a>
<a name="ln7031">	/*</a>
<a name="ln7032">	 * Calculate the active/passive dwell times.</a>
<a name="ln7033">	 */</a>
<a name="ln7034"> </a>
<a name="ln7035">	dwell_active = iwn_get_active_dwell_time(sc, c, ss-&gt;ss_nssid);</a>
<a name="ln7036">	dwell_passive = iwn_get_passive_dwell_time(sc, c);</a>
<a name="ln7037"> </a>
<a name="ln7038">	/* Make sure they're valid */</a>
<a name="ln7039">	if (dwell_passive &lt;= dwell_active)</a>
<a name="ln7040">		dwell_passive = dwell_active + 1;</a>
<a name="ln7041"> </a>
<a name="ln7042">	chan-&gt;active = htole16(dwell_active);</a>
<a name="ln7043">	chan-&gt;passive = htole16(dwell_passive);</a>
<a name="ln7044"> </a>
<a name="ln7045">	if (IEEE80211_IS_CHAN_5GHZ(c))</a>
<a name="ln7046">		chan-&gt;rf_gain = 0x3b;</a>
<a name="ln7047">	else</a>
<a name="ln7048">		chan-&gt;rf_gain = 0x28;</a>
<a name="ln7049"> </a>
<a name="ln7050">	DPRINTF(sc, IWN_DEBUG_STATE,</a>
<a name="ln7051">	    &quot;%s: chan %u flags 0x%x rf_gain 0x%x &quot;</a>
<a name="ln7052">	    &quot;dsp_gain 0x%x active %d passive %d scan_svc_time %d crc 0x%x &quot;</a>
<a name="ln7053">	    &quot;isactive=%d numssid=%d\n&quot;, __func__,</a>
<a name="ln7054">	    chan-&gt;chan, chan-&gt;flags, chan-&gt;rf_gain, chan-&gt;dsp_gain,</a>
<a name="ln7055">	    dwell_active, dwell_passive, scan_service_time,</a>
<a name="ln7056">	    hdr-&gt;crc_threshold, is_active, ss-&gt;ss_nssid);</a>
<a name="ln7057"> </a>
<a name="ln7058">	hdr-&gt;nchan++;</a>
<a name="ln7059">	chan++;</a>
<a name="ln7060">	buflen = (uint8_t *)chan - buf;</a>
<a name="ln7061">	hdr-&gt;len = htole16(buflen);</a>
<a name="ln7062"> </a>
<a name="ln7063">	if (sc-&gt;sc_is_scanning) {</a>
<a name="ln7064">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln7065">		    &quot;%s: called with is_scanning set!\n&quot;,</a>
<a name="ln7066">		    __func__);</a>
<a name="ln7067">	}</a>
<a name="ln7068">	sc-&gt;sc_is_scanning = 1;</a>
<a name="ln7069"> </a>
<a name="ln7070">	DPRINTF(sc, IWN_DEBUG_STATE, &quot;sending scan command nchan=%d\n&quot;,</a>
<a name="ln7071">	    hdr-&gt;nchan);</a>
<a name="ln7072">	error = iwn_cmd(sc, IWN_CMD_SCAN, buf, buflen, 1);</a>
<a name="ln7073">	free(buf, M_DEVBUF);</a>
<a name="ln7074">	if (error == 0)</a>
<a name="ln7075">		callout_reset(&amp;sc-&gt;scan_timeout, 5*hz, iwn_scan_timeout, sc);</a>
<a name="ln7076"> </a>
<a name="ln7077">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: end\n&quot;,__func__);</a>
<a name="ln7078"> </a>
<a name="ln7079">	return error;</a>
<a name="ln7080">}</a>
<a name="ln7081"> </a>
<a name="ln7082">static int</a>
<a name="ln7083">iwn_auth(struct iwn_softc *sc, struct ieee80211vap *vap)</a>
<a name="ln7084">{</a>
<a name="ln7085">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln7086">	struct ieee80211_node *ni = vap-&gt;iv_bss;</a>
<a name="ln7087">	int error;</a>
<a name="ln7088"> </a>
<a name="ln7089">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln7090"> </a>
<a name="ln7091">	sc-&gt;rxon = &amp;sc-&gt;rx_on[IWN_RXON_BSS_CTX];</a>
<a name="ln7092">	/* Update adapter configuration. */</a>
<a name="ln7093">	IEEE80211_ADDR_COPY(sc-&gt;rxon-&gt;bssid, ni-&gt;ni_bssid);</a>
<a name="ln7094">	sc-&gt;rxon-&gt;chan = ieee80211_chan2ieee(ic, ni-&gt;ni_chan);</a>
<a name="ln7095">	sc-&gt;rxon-&gt;flags = htole32(IWN_RXON_TSF | IWN_RXON_CTS_TO_SELF);</a>
<a name="ln7096">	if (IEEE80211_IS_CHAN_2GHZ(ni-&gt;ni_chan))</a>
<a name="ln7097">		sc-&gt;rxon-&gt;flags |= htole32(IWN_RXON_AUTO | IWN_RXON_24GHZ);</a>
<a name="ln7098">	if (ic-&gt;ic_flags &amp; IEEE80211_F_SHSLOT)</a>
<a name="ln7099">		sc-&gt;rxon-&gt;flags |= htole32(IWN_RXON_SHSLOT);</a>
<a name="ln7100">	if (ic-&gt;ic_flags &amp; IEEE80211_F_SHPREAMBLE)</a>
<a name="ln7101">		sc-&gt;rxon-&gt;flags |= htole32(IWN_RXON_SHPREAMBLE);</a>
<a name="ln7102">	if (IEEE80211_IS_CHAN_A(ni-&gt;ni_chan)) {</a>
<a name="ln7103">		sc-&gt;rxon-&gt;cck_mask  = 0;</a>
<a name="ln7104">		sc-&gt;rxon-&gt;ofdm_mask = 0x15;</a>
<a name="ln7105">	} else if (IEEE80211_IS_CHAN_B(ni-&gt;ni_chan)) {</a>
<a name="ln7106">		sc-&gt;rxon-&gt;cck_mask  = 0x03;</a>
<a name="ln7107">		sc-&gt;rxon-&gt;ofdm_mask = 0;</a>
<a name="ln7108">	} else {</a>
<a name="ln7109">		/* Assume 802.11b/g. */</a>
<a name="ln7110">		sc-&gt;rxon-&gt;cck_mask  = 0x03;</a>
<a name="ln7111">		sc-&gt;rxon-&gt;ofdm_mask = 0x15;</a>
<a name="ln7112">	}</a>
<a name="ln7113"> </a>
<a name="ln7114">	/* try HT */</a>
<a name="ln7115">	sc-&gt;rxon-&gt;flags |= htole32(iwn_get_rxon_ht_flags(sc, ic-&gt;ic_curchan));</a>
<a name="ln7116"> </a>
<a name="ln7117">	DPRINTF(sc, IWN_DEBUG_STATE, &quot;rxon chan %d flags %x cck %x ofdm %x\n&quot;,</a>
<a name="ln7118">	    sc-&gt;rxon-&gt;chan, sc-&gt;rxon-&gt;flags, sc-&gt;rxon-&gt;cck_mask,</a>
<a name="ln7119">	    sc-&gt;rxon-&gt;ofdm_mask);</a>
<a name="ln7120"> </a>
<a name="ln7121">	if ((error = iwn_send_rxon(sc, 0, 1)) != 0) {</a>
<a name="ln7122">		device_printf(sc-&gt;sc_dev, &quot;%s: could not send RXON\n&quot;,</a>
<a name="ln7123">		    __func__);</a>
<a name="ln7124">		return (error);</a>
<a name="ln7125">	}</a>
<a name="ln7126"> </a>
<a name="ln7127">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: end\n&quot;,__func__);</a>
<a name="ln7128"> </a>
<a name="ln7129">	return (0);</a>
<a name="ln7130">}</a>
<a name="ln7131"> </a>
<a name="ln7132">static int</a>
<a name="ln7133">iwn_run(struct iwn_softc *sc, struct ieee80211vap *vap)</a>
<a name="ln7134">{</a>
<a name="ln7135">	struct iwn_ops *ops = &amp;sc-&gt;ops;</a>
<a name="ln7136">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln7137">	struct ieee80211_node *ni = vap-&gt;iv_bss;</a>
<a name="ln7138">	struct iwn_node_info node;</a>
<a name="ln7139">	int error;</a>
<a name="ln7140"> </a>
<a name="ln7141">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln7142"> </a>
<a name="ln7143">	sc-&gt;rxon = &amp;sc-&gt;rx_on[IWN_RXON_BSS_CTX];</a>
<a name="ln7144">	if (ic-&gt;ic_opmode == IEEE80211_M_MONITOR) {</a>
<a name="ln7145">		/* Link LED blinks while monitoring. */</a>
<a name="ln7146">		iwn_set_led(sc, IWN_LED_LINK, 5, 5);</a>
<a name="ln7147">		return 0;</a>
<a name="ln7148">	}</a>
<a name="ln7149">	if ((error = iwn_set_timing(sc, ni)) != 0) {</a>
<a name="ln7150">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln7151">		    &quot;%s: could not set timing, error %d\n&quot;, __func__, error);</a>
<a name="ln7152">		return error;</a>
<a name="ln7153">	}</a>
<a name="ln7154"> </a>
<a name="ln7155">	/* Update adapter configuration. */</a>
<a name="ln7156">	IEEE80211_ADDR_COPY(sc-&gt;rxon-&gt;bssid, ni-&gt;ni_bssid);</a>
<a name="ln7157">	sc-&gt;rxon-&gt;associd = htole16(IEEE80211_AID(ni-&gt;ni_associd));</a>
<a name="ln7158">	sc-&gt;rxon-&gt;chan = ieee80211_chan2ieee(ic, ni-&gt;ni_chan);</a>
<a name="ln7159">	sc-&gt;rxon-&gt;flags = htole32(IWN_RXON_TSF | IWN_RXON_CTS_TO_SELF);</a>
<a name="ln7160">	if (IEEE80211_IS_CHAN_2GHZ(ni-&gt;ni_chan))</a>
<a name="ln7161">		sc-&gt;rxon-&gt;flags |= htole32(IWN_RXON_AUTO | IWN_RXON_24GHZ);</a>
<a name="ln7162">	if (ic-&gt;ic_flags &amp; IEEE80211_F_SHSLOT)</a>
<a name="ln7163">		sc-&gt;rxon-&gt;flags |= htole32(IWN_RXON_SHSLOT);</a>
<a name="ln7164">	if (ic-&gt;ic_flags &amp; IEEE80211_F_SHPREAMBLE)</a>
<a name="ln7165">		sc-&gt;rxon-&gt;flags |= htole32(IWN_RXON_SHPREAMBLE);</a>
<a name="ln7166">	if (IEEE80211_IS_CHAN_A(ni-&gt;ni_chan)) {</a>
<a name="ln7167">		sc-&gt;rxon-&gt;cck_mask  = 0;</a>
<a name="ln7168">		sc-&gt;rxon-&gt;ofdm_mask = 0x15;</a>
<a name="ln7169">	} else if (IEEE80211_IS_CHAN_B(ni-&gt;ni_chan)) {</a>
<a name="ln7170">		sc-&gt;rxon-&gt;cck_mask  = 0x03;</a>
<a name="ln7171">		sc-&gt;rxon-&gt;ofdm_mask = 0;</a>
<a name="ln7172">	} else {</a>
<a name="ln7173">		/* Assume 802.11b/g. */</a>
<a name="ln7174">		sc-&gt;rxon-&gt;cck_mask  = 0x0f;</a>
<a name="ln7175">		sc-&gt;rxon-&gt;ofdm_mask = 0x15;</a>
<a name="ln7176">	}</a>
<a name="ln7177">	/* try HT */</a>
<a name="ln7178">	sc-&gt;rxon-&gt;flags |= htole32(iwn_get_rxon_ht_flags(sc, ni-&gt;ni_chan));</a>
<a name="ln7179">	sc-&gt;rxon-&gt;filter |= htole32(IWN_FILTER_BSS);</a>
<a name="ln7180">	DPRINTF(sc, IWN_DEBUG_STATE, &quot;rxon chan %d flags %x, curhtprotmode=%d\n&quot;,</a>
<a name="ln7181">	    sc-&gt;rxon-&gt;chan, le32toh(sc-&gt;rxon-&gt;flags), ic-&gt;ic_curhtprotmode);</a>
<a name="ln7182"> </a>
<a name="ln7183">	if ((error = iwn_send_rxon(sc, 0, 1)) != 0) {</a>
<a name="ln7184">		device_printf(sc-&gt;sc_dev, &quot;%s: could not send RXON\n&quot;,</a>
<a name="ln7185">		    __func__);</a>
<a name="ln7186">		return error;</a>
<a name="ln7187">	}</a>
<a name="ln7188"> </a>
<a name="ln7189">	/* Fake a join to initialize the TX rate. */</a>
<a name="ln7190">	((struct iwn_node *)ni)-&gt;id = IWN_ID_BSS;</a>
<a name="ln7191">	iwn_newassoc(ni, 1);</a>
<a name="ln7192"> </a>
<a name="ln7193">	/* Add BSS node. */</a>
<a name="ln7194">	memset(&amp;node, 0, sizeof node);</a>
<a name="ln7195">	IEEE80211_ADDR_COPY(node.macaddr, ni-&gt;ni_macaddr);</a>
<a name="ln7196">	node.id = IWN_ID_BSS;</a>
<a name="ln7197">	if (IEEE80211_IS_CHAN_HT(ni-&gt;ni_chan)) {</a>
<a name="ln7198">		switch (ni-&gt;ni_htcap &amp; IEEE80211_HTCAP_SMPS) {</a>
<a name="ln7199">		case IEEE80211_HTCAP_SMPS_ENA:</a>
<a name="ln7200">			node.htflags |= htole32(IWN_SMPS_MIMO_DIS);</a>
<a name="ln7201">			break;</a>
<a name="ln7202">		case IEEE80211_HTCAP_SMPS_DYNAMIC:</a>
<a name="ln7203">			node.htflags |= htole32(IWN_SMPS_MIMO_PROT);</a>
<a name="ln7204">			break;</a>
<a name="ln7205">		}</a>
<a name="ln7206">		node.htflags |= htole32(IWN_AMDPU_SIZE_FACTOR(3) |</a>
<a name="ln7207">		    IWN_AMDPU_DENSITY(5));	/* 4us */</a>
<a name="ln7208">		if (IEEE80211_IS_CHAN_HT40(ni-&gt;ni_chan))</a>
<a name="ln7209">			node.htflags |= htole32(IWN_NODE_HT40);</a>
<a name="ln7210">	}</a>
<a name="ln7211">	DPRINTF(sc, IWN_DEBUG_STATE, &quot;%s: adding BSS node\n&quot;, __func__);</a>
<a name="ln7212">	error = ops-&gt;add_node(sc, &amp;node, 1);</a>
<a name="ln7213">	if (error != 0) {</a>
<a name="ln7214">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln7215">		    &quot;%s: could not add BSS node, error %d\n&quot;, __func__, error);</a>
<a name="ln7216">		return error;</a>
<a name="ln7217">	}</a>
<a name="ln7218">	DPRINTF(sc, IWN_DEBUG_STATE, &quot;%s: setting link quality for node %d\n&quot;,</a>
<a name="ln7219">	    __func__, node.id);</a>
<a name="ln7220">	if ((error = iwn_set_link_quality(sc, ni)) != 0) {</a>
<a name="ln7221">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln7222">		    &quot;%s: could not setup link quality for node %d, error %d\n&quot;,</a>
<a name="ln7223">		    __func__, node.id, error);</a>
<a name="ln7224">		return error;</a>
<a name="ln7225">	}</a>
<a name="ln7226"> </a>
<a name="ln7227">	if ((error = iwn_init_sensitivity(sc)) != 0) {</a>
<a name="ln7228">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln7229">		    &quot;%s: could not set sensitivity, error %d\n&quot;, __func__,</a>
<a name="ln7230">		    error);</a>
<a name="ln7231">		return error;</a>
<a name="ln7232">	}</a>
<a name="ln7233">	/* Start periodic calibration timer. */</a>
<a name="ln7234">	sc-&gt;calib.state = IWN_CALIB_STATE_ASSOC;</a>
<a name="ln7235">	sc-&gt;calib_cnt = 0;</a>
<a name="ln7236">	callout_reset(&amp;sc-&gt;calib_to, msecs_to_ticks(500), iwn_calib_timeout,</a>
<a name="ln7237">	    sc);</a>
<a name="ln7238"> </a>
<a name="ln7239">	/* Link LED always on while associated. */</a>
<a name="ln7240">	iwn_set_led(sc, IWN_LED_LINK, 0, 1);</a>
<a name="ln7241"> </a>
<a name="ln7242">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: end\n&quot;,__func__);</a>
<a name="ln7243"> </a>
<a name="ln7244">	return 0;</a>
<a name="ln7245">}</a>
<a name="ln7246"> </a>
<a name="ln7247">/*</a>
<a name="ln7248"> * This function is called by upper layer when an ADDBA request is received</a>
<a name="ln7249"> * from another STA and before the ADDBA response is sent.</a>
<a name="ln7250"> */</a>
<a name="ln7251">static int</a>
<a name="ln7252">iwn_ampdu_rx_start(struct ieee80211_node *ni, struct ieee80211_rx_ampdu *rap,</a>
<a name="ln7253">    int baparamset, int batimeout, int baseqctl)</a>
<a name="ln7254">{</a>
<a name="ln7255">#define MS(_v, _f)	(((_v) &amp; _f) &gt;&gt; _f##_S)</a>
<a name="ln7256">	struct iwn_softc *sc = ni-&gt;ni_ic-&gt;ic_softc;</a>
<a name="ln7257">	struct iwn_ops *ops = &amp;sc-&gt;ops;</a>
<a name="ln7258">	struct iwn_node *wn = (void *)ni;</a>
<a name="ln7259">	struct iwn_node_info node;</a>
<a name="ln7260">	uint16_t ssn;</a>
<a name="ln7261">	uint8_t tid;</a>
<a name="ln7262">	int error;</a>
<a name="ln7263"> </a>
<a name="ln7264">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln7265"> </a>
<a name="ln7266">	tid = MS(le16toh(baparamset), IEEE80211_BAPS_TID);</a>
<a name="ln7267">	ssn = MS(le16toh(baseqctl), IEEE80211_BASEQ_START);</a>
<a name="ln7268"> </a>
<a name="ln7269">	if (wn-&gt;id == IWN_ID_UNDEFINED)</a>
<a name="ln7270">		return (ENOENT);</a>
<a name="ln7271"> </a>
<a name="ln7272">	memset(&amp;node, 0, sizeof node);</a>
<a name="ln7273">	node.id = wn-&gt;id;</a>
<a name="ln7274">	node.control = IWN_NODE_UPDATE;</a>
<a name="ln7275">	node.flags = IWN_FLAG_SET_ADDBA;</a>
<a name="ln7276">	node.addba_tid = tid;</a>
<a name="ln7277">	node.addba_ssn = htole16(ssn);</a>
<a name="ln7278">	DPRINTF(sc, IWN_DEBUG_RECV, &quot;ADDBA RA=%d TID=%d SSN=%d\n&quot;,</a>
<a name="ln7279">	    wn-&gt;id, tid, ssn);</a>
<a name="ln7280">	error = ops-&gt;add_node(sc, &amp;node, 1);</a>
<a name="ln7281">	if (error != 0)</a>
<a name="ln7282">		return error;</a>
<a name="ln7283">	return sc-&gt;sc_ampdu_rx_start(ni, rap, baparamset, batimeout, baseqctl);</a>
<a name="ln7284">#undef MS</a>
<a name="ln7285">}</a>
<a name="ln7286"> </a>
<a name="ln7287">/*</a>
<a name="ln7288"> * This function is called by upper layer on teardown of an HT-immediate</a>
<a name="ln7289"> * Block Ack agreement (eg. uppon receipt of a DELBA frame).</a>
<a name="ln7290"> */</a>
<a name="ln7291">static void</a>
<a name="ln7292">iwn_ampdu_rx_stop(struct ieee80211_node *ni, struct ieee80211_rx_ampdu *rap)</a>
<a name="ln7293">{</a>
<a name="ln7294">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln7295">	struct iwn_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln7296">	struct iwn_ops *ops = &amp;sc-&gt;ops;</a>
<a name="ln7297">	struct iwn_node *wn = (void *)ni;</a>
<a name="ln7298">	struct iwn_node_info node;</a>
<a name="ln7299">	uint8_t tid;</a>
<a name="ln7300"> </a>
<a name="ln7301">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln7302"> </a>
<a name="ln7303">	if (wn-&gt;id == IWN_ID_UNDEFINED)</a>
<a name="ln7304">		goto end;</a>
<a name="ln7305"> </a>
<a name="ln7306">	/* XXX: tid as an argument */</a>
<a name="ln7307">	for (tid = 0; tid &lt; WME_NUM_TID; tid++) {</a>
<a name="ln7308">		if (&amp;ni-&gt;ni_rx_ampdu[tid] == rap)</a>
<a name="ln7309">			break;</a>
<a name="ln7310">	}</a>
<a name="ln7311"> </a>
<a name="ln7312">	memset(&amp;node, 0, sizeof node);</a>
<a name="ln7313">	node.id = wn-&gt;id;</a>
<a name="ln7314">	node.control = IWN_NODE_UPDATE;</a>
<a name="ln7315">	node.flags = IWN_FLAG_SET_DELBA;</a>
<a name="ln7316">	node.delba_tid = tid;</a>
<a name="ln7317">	DPRINTF(sc, IWN_DEBUG_RECV, &quot;DELBA RA=%d TID=%d\n&quot;, wn-&gt;id, tid);</a>
<a name="ln7318">	(void)ops-&gt;add_node(sc, &amp;node, 1);</a>
<a name="ln7319">end:</a>
<a name="ln7320">	sc-&gt;sc_ampdu_rx_stop(ni, rap);</a>
<a name="ln7321">}</a>
<a name="ln7322"> </a>
<a name="ln7323">static int</a>
<a name="ln7324">iwn_addba_request(struct ieee80211_node *ni, struct ieee80211_tx_ampdu *tap,</a>
<a name="ln7325">    int dialogtoken, int baparamset, int batimeout)</a>
<a name="ln7326">{</a>
<a name="ln7327">	struct iwn_softc *sc = ni-&gt;ni_ic-&gt;ic_softc;</a>
<a name="ln7328">	int qid;</a>
<a name="ln7329"> </a>
<a name="ln7330">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln7331"> </a>
<a name="ln7332">	for (qid = sc-&gt;firstaggqueue; qid &lt; sc-&gt;ntxqs; qid++) {</a>
<a name="ln7333">		if (sc-&gt;qid2tap[qid] == NULL)</a>
<a name="ln7334">			break;</a>
<a name="ln7335">	}</a>
<a name="ln7336">	if (qid == sc-&gt;ntxqs) {</a>
<a name="ln7337">		DPRINTF(sc, IWN_DEBUG_XMIT, &quot;%s: not free aggregation queue\n&quot;,</a>
<a name="ln7338">		    __func__);</a>
<a name="ln7339">		return 0;</a>
<a name="ln7340">	}</a>
<a name="ln7341">	tap-&gt;txa_private = malloc(sizeof(int), M_DEVBUF, M_NOWAIT);</a>
<a name="ln7342">	if (tap-&gt;txa_private == NULL) {</a>
<a name="ln7343">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln7344">		    &quot;%s: failed to alloc TX aggregation structure\n&quot;, __func__);</a>
<a name="ln7345">		return 0;</a>
<a name="ln7346">	}</a>
<a name="ln7347">	sc-&gt;qid2tap[qid] = tap;</a>
<a name="ln7348">	*(int *)tap-&gt;txa_private = qid;</a>
<a name="ln7349">	return sc-&gt;sc_addba_request(ni, tap, dialogtoken, baparamset,</a>
<a name="ln7350">	    batimeout);</a>
<a name="ln7351">}</a>
<a name="ln7352"> </a>
<a name="ln7353">static int</a>
<a name="ln7354">iwn_addba_response(struct ieee80211_node *ni, struct ieee80211_tx_ampdu *tap,</a>
<a name="ln7355">    int code, int baparamset, int batimeout)</a>
<a name="ln7356">{</a>
<a name="ln7357">	struct iwn_softc *sc = ni-&gt;ni_ic-&gt;ic_softc;</a>
<a name="ln7358">	int qid = *(int *)tap-&gt;txa_private;</a>
<a name="ln7359">	uint8_t tid = tap-&gt;txa_tid;</a>
<a name="ln7360">	int ret;</a>
<a name="ln7361"> </a>
<a name="ln7362">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln7363"> </a>
<a name="ln7364">	if (code == IEEE80211_STATUS_SUCCESS) {</a>
<a name="ln7365">		ni-&gt;ni_txseqs[tid] = tap-&gt;txa_start &amp; 0xfff;</a>
<a name="ln7366">		ret = iwn_ampdu_tx_start(ni-&gt;ni_ic, ni, tid);</a>
<a name="ln7367">		if (ret != 1)</a>
<a name="ln7368">			return ret;</a>
<a name="ln7369">	} else {</a>
<a name="ln7370">		sc-&gt;qid2tap[qid] = NULL;</a>
<a name="ln7371">		free(tap-&gt;txa_private, M_DEVBUF);</a>
<a name="ln7372">		tap-&gt;txa_private = NULL;</a>
<a name="ln7373">	}</a>
<a name="ln7374">	return sc-&gt;sc_addba_response(ni, tap, code, baparamset, batimeout);</a>
<a name="ln7375">}</a>
<a name="ln7376"> </a>
<a name="ln7377">/*</a>
<a name="ln7378"> * This function is called by upper layer when an ADDBA response is received</a>
<a name="ln7379"> * from another STA.</a>
<a name="ln7380"> */</a>
<a name="ln7381">static int</a>
<a name="ln7382">iwn_ampdu_tx_start(struct ieee80211com *ic, struct ieee80211_node *ni,</a>
<a name="ln7383">    uint8_t tid)</a>
<a name="ln7384">{</a>
<a name="ln7385">	struct ieee80211_tx_ampdu *tap = &amp;ni-&gt;ni_tx_ampdu[tid];</a>
<a name="ln7386">	struct iwn_softc *sc = ni-&gt;ni_ic-&gt;ic_softc;</a>
<a name="ln7387">	struct iwn_ops *ops = &amp;sc-&gt;ops;</a>
<a name="ln7388">	struct iwn_node *wn = (void *)ni;</a>
<a name="ln7389">	struct iwn_node_info node;</a>
<a name="ln7390">	int error, qid;</a>
<a name="ln7391"> </a>
<a name="ln7392">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln7393"> </a>
<a name="ln7394">	if (wn-&gt;id == IWN_ID_UNDEFINED)</a>
<a name="ln7395">		return (0);</a>
<a name="ln7396"> </a>
<a name="ln7397">	/* Enable TX for the specified RA/TID. */</a>
<a name="ln7398">	wn-&gt;disable_tid &amp;= ~(1 &lt;&lt; tid);</a>
<a name="ln7399">	memset(&amp;node, 0, sizeof node);</a>
<a name="ln7400">	node.id = wn-&gt;id;</a>
<a name="ln7401">	node.control = IWN_NODE_UPDATE;</a>
<a name="ln7402">	node.flags = IWN_FLAG_SET_DISABLE_TID;</a>
<a name="ln7403">	node.disable_tid = htole16(wn-&gt;disable_tid);</a>
<a name="ln7404">	error = ops-&gt;add_node(sc, &amp;node, 1);</a>
<a name="ln7405">	if (error != 0)</a>
<a name="ln7406">		return 0;</a>
<a name="ln7407"> </a>
<a name="ln7408">	if ((error = iwn_nic_lock(sc)) != 0)</a>
<a name="ln7409">		return 0;</a>
<a name="ln7410">	qid = *(int *)tap-&gt;txa_private;</a>
<a name="ln7411">	DPRINTF(sc, IWN_DEBUG_XMIT, &quot;%s: ra=%d tid=%d ssn=%d qid=%d\n&quot;,</a>
<a name="ln7412">	    __func__, wn-&gt;id, tid, tap-&gt;txa_start, qid);</a>
<a name="ln7413">	ops-&gt;ampdu_tx_start(sc, ni, qid, tid, tap-&gt;txa_start &amp; 0xfff);</a>
<a name="ln7414">	iwn_nic_unlock(sc);</a>
<a name="ln7415"> </a>
<a name="ln7416">	iwn_set_link_quality(sc, ni);</a>
<a name="ln7417">	return 1;</a>
<a name="ln7418">}</a>
<a name="ln7419"> </a>
<a name="ln7420">static void</a>
<a name="ln7421">iwn_ampdu_tx_stop(struct ieee80211_node *ni, struct ieee80211_tx_ampdu *tap)</a>
<a name="ln7422">{</a>
<a name="ln7423">	struct iwn_softc *sc = ni-&gt;ni_ic-&gt;ic_softc;</a>
<a name="ln7424">	struct iwn_ops *ops = &amp;sc-&gt;ops;</a>
<a name="ln7425">	uint8_t tid = tap-&gt;txa_tid;</a>
<a name="ln7426">	int qid;</a>
<a name="ln7427"> </a>
<a name="ln7428">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln7429"> </a>
<a name="ln7430">	sc-&gt;sc_addba_stop(ni, tap);</a>
<a name="ln7431"> </a>
<a name="ln7432">	if (tap-&gt;txa_private == NULL)</a>
<a name="ln7433">		return;</a>
<a name="ln7434"> </a>
<a name="ln7435">	qid = *(int *)tap-&gt;txa_private;</a>
<a name="ln7436">	if (sc-&gt;txq[qid].queued != 0)</a>
<a name="ln7437">		return;</a>
<a name="ln7438">	if (iwn_nic_lock(sc) != 0)</a>
<a name="ln7439">		return;</a>
<a name="ln7440">	ops-&gt;ampdu_tx_stop(sc, qid, tid, tap-&gt;txa_start &amp; 0xfff);</a>
<a name="ln7441">	iwn_nic_unlock(sc);</a>
<a name="ln7442">	sc-&gt;qid2tap[qid] = NULL;</a>
<a name="ln7443">	free(tap-&gt;txa_private, M_DEVBUF);</a>
<a name="ln7444">	tap-&gt;txa_private = NULL;</a>
<a name="ln7445">}</a>
<a name="ln7446"> </a>
<a name="ln7447">static void</a>
<a name="ln7448">iwn4965_ampdu_tx_start(struct iwn_softc *sc, struct ieee80211_node *ni,</a>
<a name="ln7449">    int qid, uint8_t tid, uint16_t ssn)</a>
<a name="ln7450">{</a>
<a name="ln7451">	struct iwn_node *wn = (void *)ni;</a>
<a name="ln7452"> </a>
<a name="ln7453">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln7454"> </a>
<a name="ln7455">	/* Stop TX scheduler while we're changing its configuration. */</a>
<a name="ln7456">	iwn_prph_write(sc, IWN4965_SCHED_QUEUE_STATUS(qid),</a>
<a name="ln7457">	    IWN4965_TXQ_STATUS_CHGACT);</a>
<a name="ln7458"> </a>
<a name="ln7459">	/* Assign RA/TID translation to the queue. */</a>
<a name="ln7460">	iwn_mem_write_2(sc, sc-&gt;sched_base + IWN4965_SCHED_TRANS_TBL(qid),</a>
<a name="ln7461">	    wn-&gt;id &lt;&lt; 4 | tid);</a>
<a name="ln7462"> </a>
<a name="ln7463">	/* Enable chain-building mode for the queue. */</a>
<a name="ln7464">	iwn_prph_setbits(sc, IWN4965_SCHED_QCHAIN_SEL, 1 &lt;&lt; qid);</a>
<a name="ln7465"> </a>
<a name="ln7466">	/* Set starting sequence number from the ADDBA request. */</a>
<a name="ln7467">	sc-&gt;txq[qid].cur = sc-&gt;txq[qid].read = (ssn &amp; 0xff);</a>
<a name="ln7468">	IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, qid &lt;&lt; 8 | (ssn &amp; 0xff));</a>
<a name="ln7469">	iwn_prph_write(sc, IWN4965_SCHED_QUEUE_RDPTR(qid), ssn);</a>
<a name="ln7470"> </a>
<a name="ln7471">	/* Set scheduler window size. */</a>
<a name="ln7472">	iwn_mem_write(sc, sc-&gt;sched_base + IWN4965_SCHED_QUEUE_OFFSET(qid),</a>
<a name="ln7473">	    IWN_SCHED_WINSZ);</a>
<a name="ln7474">	/* Set scheduler frame limit. */</a>
<a name="ln7475">	iwn_mem_write(sc, sc-&gt;sched_base + IWN4965_SCHED_QUEUE_OFFSET(qid) + 4,</a>
<a name="ln7476">	    IWN_SCHED_LIMIT &lt;&lt; 16);</a>
<a name="ln7477"> </a>
<a name="ln7478">	/* Enable interrupts for the queue. */</a>
<a name="ln7479">	iwn_prph_setbits(sc, IWN4965_SCHED_INTR_MASK, 1 &lt;&lt; qid);</a>
<a name="ln7480"> </a>
<a name="ln7481">	/* Mark the queue as active. */</a>
<a name="ln7482">	iwn_prph_write(sc, IWN4965_SCHED_QUEUE_STATUS(qid),</a>
<a name="ln7483">	    IWN4965_TXQ_STATUS_ACTIVE | IWN4965_TXQ_STATUS_AGGR_ENA |</a>
<a name="ln7484">	    iwn_tid2fifo[tid] &lt;&lt; 1);</a>
<a name="ln7485">}</a>
<a name="ln7486"> </a>
<a name="ln7487">static void</a>
<a name="ln7488">iwn4965_ampdu_tx_stop(struct iwn_softc *sc, int qid, uint8_t tid, uint16_t ssn)</a>
<a name="ln7489">{</a>
<a name="ln7490">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln7491"> </a>
<a name="ln7492">	/* Stop TX scheduler while we're changing its configuration. */</a>
<a name="ln7493">	iwn_prph_write(sc, IWN4965_SCHED_QUEUE_STATUS(qid),</a>
<a name="ln7494">	    IWN4965_TXQ_STATUS_CHGACT);</a>
<a name="ln7495"> </a>
<a name="ln7496">	/* Set starting sequence number from the ADDBA request. */</a>
<a name="ln7497">	IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, qid &lt;&lt; 8 | (ssn &amp; 0xff));</a>
<a name="ln7498">	iwn_prph_write(sc, IWN4965_SCHED_QUEUE_RDPTR(qid), ssn);</a>
<a name="ln7499"> </a>
<a name="ln7500">	/* Disable interrupts for the queue. */</a>
<a name="ln7501">	iwn_prph_clrbits(sc, IWN4965_SCHED_INTR_MASK, 1 &lt;&lt; qid);</a>
<a name="ln7502"> </a>
<a name="ln7503">	/* Mark the queue as inactive. */</a>
<a name="ln7504">	iwn_prph_write(sc, IWN4965_SCHED_QUEUE_STATUS(qid),</a>
<a name="ln7505">	    IWN4965_TXQ_STATUS_INACTIVE | iwn_tid2fifo[tid] &lt;&lt; 1);</a>
<a name="ln7506">}</a>
<a name="ln7507"> </a>
<a name="ln7508">static void</a>
<a name="ln7509">iwn5000_ampdu_tx_start(struct iwn_softc *sc, struct ieee80211_node *ni,</a>
<a name="ln7510">    int qid, uint8_t tid, uint16_t ssn)</a>
<a name="ln7511">{</a>
<a name="ln7512">	struct iwn_node *wn = (void *)ni;</a>
<a name="ln7513"> </a>
<a name="ln7514">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln7515"> </a>
<a name="ln7516">	/* Stop TX scheduler while we're changing its configuration. */</a>
<a name="ln7517">	iwn_prph_write(sc, IWN5000_SCHED_QUEUE_STATUS(qid),</a>
<a name="ln7518">	    IWN5000_TXQ_STATUS_CHGACT);</a>
<a name="ln7519"> </a>
<a name="ln7520">	/* Assign RA/TID translation to the queue. */</a>
<a name="ln7521">	iwn_mem_write_2(sc, sc-&gt;sched_base + IWN5000_SCHED_TRANS_TBL(qid),</a>
<a name="ln7522">	    wn-&gt;id &lt;&lt; 4 | tid);</a>
<a name="ln7523"> </a>
<a name="ln7524">	/* Enable chain-building mode for the queue. */</a>
<a name="ln7525">	iwn_prph_setbits(sc, IWN5000_SCHED_QCHAIN_SEL, 1 &lt;&lt; qid);</a>
<a name="ln7526"> </a>
<a name="ln7527">	/* Enable aggregation for the queue. */</a>
<a name="ln7528">	iwn_prph_setbits(sc, IWN5000_SCHED_AGGR_SEL, 1 &lt;&lt; qid);</a>
<a name="ln7529"> </a>
<a name="ln7530">	/* Set starting sequence number from the ADDBA request. */</a>
<a name="ln7531">	sc-&gt;txq[qid].cur = sc-&gt;txq[qid].read = (ssn &amp; 0xff);</a>
<a name="ln7532">	IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, qid &lt;&lt; 8 | (ssn &amp; 0xff));</a>
<a name="ln7533">	iwn_prph_write(sc, IWN5000_SCHED_QUEUE_RDPTR(qid), ssn);</a>
<a name="ln7534"> </a>
<a name="ln7535">	/* Set scheduler window size and frame limit. */</a>
<a name="ln7536">	iwn_mem_write(sc, sc-&gt;sched_base + IWN5000_SCHED_QUEUE_OFFSET(qid) + 4,</a>
<a name="ln7537">	    IWN_SCHED_LIMIT &lt;&lt; 16 | IWN_SCHED_WINSZ);</a>
<a name="ln7538"> </a>
<a name="ln7539">	/* Enable interrupts for the queue. */</a>
<a name="ln7540">	iwn_prph_setbits(sc, IWN5000_SCHED_INTR_MASK, 1 &lt;&lt; qid);</a>
<a name="ln7541"> </a>
<a name="ln7542">	/* Mark the queue as active. */</a>
<a name="ln7543">	iwn_prph_write(sc, IWN5000_SCHED_QUEUE_STATUS(qid),</a>
<a name="ln7544">	    IWN5000_TXQ_STATUS_ACTIVE | iwn_tid2fifo[tid]);</a>
<a name="ln7545">}</a>
<a name="ln7546"> </a>
<a name="ln7547">static void</a>
<a name="ln7548">iwn5000_ampdu_tx_stop(struct iwn_softc *sc, int qid, uint8_t tid, uint16_t ssn)</a>
<a name="ln7549">{</a>
<a name="ln7550">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln7551"> </a>
<a name="ln7552">	/* Stop TX scheduler while we're changing its configuration. */</a>
<a name="ln7553">	iwn_prph_write(sc, IWN5000_SCHED_QUEUE_STATUS(qid),</a>
<a name="ln7554">	    IWN5000_TXQ_STATUS_CHGACT);</a>
<a name="ln7555"> </a>
<a name="ln7556">	/* Disable aggregation for the queue. */</a>
<a name="ln7557">	iwn_prph_clrbits(sc, IWN5000_SCHED_AGGR_SEL, 1 &lt;&lt; qid);</a>
<a name="ln7558"> </a>
<a name="ln7559">	/* Set starting sequence number from the ADDBA request. */</a>
<a name="ln7560">	IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, qid &lt;&lt; 8 | (ssn &amp; 0xff));</a>
<a name="ln7561">	iwn_prph_write(sc, IWN5000_SCHED_QUEUE_RDPTR(qid), ssn);</a>
<a name="ln7562"> </a>
<a name="ln7563">	/* Disable interrupts for the queue. */</a>
<a name="ln7564">	iwn_prph_clrbits(sc, IWN5000_SCHED_INTR_MASK, 1 &lt;&lt; qid);</a>
<a name="ln7565"> </a>
<a name="ln7566">	/* Mark the queue as inactive. */</a>
<a name="ln7567">	iwn_prph_write(sc, IWN5000_SCHED_QUEUE_STATUS(qid),</a>
<a name="ln7568">	    IWN5000_TXQ_STATUS_INACTIVE | iwn_tid2fifo[tid]);</a>
<a name="ln7569">}</a>
<a name="ln7570"> </a>
<a name="ln7571">/*</a>
<a name="ln7572"> * Query calibration tables from the initialization firmware.  We do this</a>
<a name="ln7573"> * only once at first boot.  Called from a process context.</a>
<a name="ln7574"> */</a>
<a name="ln7575">static int</a>
<a name="ln7576">iwn5000_query_calibration(struct iwn_softc *sc)</a>
<a name="ln7577">{</a>
<a name="ln7578">	struct iwn5000_calib_config cmd;</a>
<a name="ln7579">	int error;</a>
<a name="ln7580"> </a>
<a name="ln7581">	memset(&amp;cmd, 0, sizeof cmd);</a>
<a name="ln7582">	cmd.ucode.once.enable = htole32(0xffffffff);</a>
<a name="ln7583">	cmd.ucode.once.start  = htole32(0xffffffff);</a>
<a name="ln7584">	cmd.ucode.once.send   = htole32(0xffffffff);</a>
<a name="ln7585">	cmd.ucode.flags       = htole32(0xffffffff);</a>
<a name="ln7586">	DPRINTF(sc, IWN_DEBUG_CALIBRATE, &quot;%s: sending calibration query\n&quot;,</a>
<a name="ln7587">	    __func__);</a>
<a name="ln7588">	error = iwn_cmd(sc, IWN5000_CMD_CALIB_CONFIG, &amp;cmd, sizeof cmd, 0);</a>
<a name="ln7589">	if (error != 0)</a>
<a name="ln7590">		return error;</a>
<a name="ln7591"> </a>
<a name="ln7592">	/* Wait at most two seconds for calibration to complete. */</a>
<a name="ln7593">	if (!(sc-&gt;sc_flags &amp; IWN_FLAG_CALIB_DONE))</a>
<a name="ln7594">		error = msleep(sc, &amp;sc-&gt;sc_mtx, PCATCH, &quot;iwncal&quot;, 2 * hz);</a>
<a name="ln7595">	return error;</a>
<a name="ln7596">}</a>
<a name="ln7597"> </a>
<a name="ln7598">/*</a>
<a name="ln7599"> * Send calibration results to the runtime firmware.  These results were</a>
<a name="ln7600"> * obtained on first boot from the initialization firmware.</a>
<a name="ln7601"> */</a>
<a name="ln7602">static int</a>
<a name="ln7603">iwn5000_send_calibration(struct iwn_softc *sc)</a>
<a name="ln7604">{</a>
<a name="ln7605">	int idx, error;</a>
<a name="ln7606"> </a>
<a name="ln7607">	for (idx = 0; idx &lt; IWN5000_PHY_CALIB_MAX_RESULT; idx++) {</a>
<a name="ln7608">		if (!(sc-&gt;base_params-&gt;calib_need &amp; (1&lt;&lt;idx))) {</a>
<a name="ln7609">			DPRINTF(sc, IWN_DEBUG_CALIBRATE,</a>
<a name="ln7610">			    &quot;No need of calib %d\n&quot;,</a>
<a name="ln7611">			    idx);</a>
<a name="ln7612">			continue; /* no need for this calib */</a>
<a name="ln7613">		}</a>
<a name="ln7614">		if (sc-&gt;calibcmd[idx].buf == NULL) {</a>
<a name="ln7615">			DPRINTF(sc, IWN_DEBUG_CALIBRATE,</a>
<a name="ln7616">			    &quot;Need calib idx : %d but no available data\n&quot;,</a>
<a name="ln7617">			    idx);</a>
<a name="ln7618">			continue;</a>
<a name="ln7619">		}</a>
<a name="ln7620"> </a>
<a name="ln7621">		DPRINTF(sc, IWN_DEBUG_CALIBRATE,</a>
<a name="ln7622">		    &quot;send calibration result idx=%d len=%d\n&quot;, idx,</a>
<a name="ln7623">		    sc-&gt;calibcmd[idx].len);</a>
<a name="ln7624">		error = iwn_cmd(sc, IWN_CMD_PHY_CALIB, sc-&gt;calibcmd[idx].buf,</a>
<a name="ln7625">		    sc-&gt;calibcmd[idx].len, 0);</a>
<a name="ln7626">		if (error != 0) {</a>
<a name="ln7627">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln7628">			    &quot;%s: could not send calibration result, error %d\n&quot;,</a>
<a name="ln7629">			    __func__, error);</a>
<a name="ln7630">			return error;</a>
<a name="ln7631">		}</a>
<a name="ln7632">	}</a>
<a name="ln7633">	return 0;</a>
<a name="ln7634">}</a>
<a name="ln7635"> </a>
<a name="ln7636">static int</a>
<a name="ln7637">iwn5000_send_wimax_coex(struct iwn_softc *sc)</a>
<a name="ln7638">{</a>
<a name="ln7639">	struct iwn5000_wimax_coex wimax;</a>
<a name="ln7640"> </a>
<a name="ln7641">#if 0</a>
<a name="ln7642">	if (sc-&gt;hw_type == IWN_HW_REV_TYPE_6050) {</a>
<a name="ln7643">		/* Enable WiMAX coexistence for combo adapters. */</a>
<a name="ln7644">		wimax.flags =</a>
<a name="ln7645">		    IWN_WIMAX_COEX_ASSOC_WA_UNMASK |</a>
<a name="ln7646">		    IWN_WIMAX_COEX_UNASSOC_WA_UNMASK |</a>
<a name="ln7647">		    IWN_WIMAX_COEX_STA_TABLE_VALID |</a>
<a name="ln7648">		    IWN_WIMAX_COEX_ENABLE;</a>
<a name="ln7649">		memcpy(wimax.events, iwn6050_wimax_events,</a>
<a name="ln7650">		    sizeof iwn6050_wimax_events);</a>
<a name="ln7651">	} else</a>
<a name="ln7652">#endif</a>
<a name="ln7653">	{</a>
<a name="ln7654">		/* Disable WiMAX coexistence. */</a>
<a name="ln7655">		wimax.flags = 0;</a>
<a name="ln7656">		memset(wimax.events, 0, sizeof wimax.events);</a>
<a name="ln7657">	}</a>
<a name="ln7658">	DPRINTF(sc, IWN_DEBUG_RESET, &quot;%s: Configuring WiMAX coexistence\n&quot;,</a>
<a name="ln7659">	    __func__);</a>
<a name="ln7660">	return iwn_cmd(sc, IWN5000_CMD_WIMAX_COEX, &amp;wimax, sizeof wimax, 0);</a>
<a name="ln7661">}</a>
<a name="ln7662"> </a>
<a name="ln7663">static int</a>
<a name="ln7664">iwn5000_crystal_calib(struct iwn_softc *sc)</a>
<a name="ln7665">{</a>
<a name="ln7666">	struct iwn5000_phy_calib_crystal cmd;</a>
<a name="ln7667"> </a>
<a name="ln7668">	memset(&amp;cmd, 0, sizeof cmd);</a>
<a name="ln7669">	cmd.code = IWN5000_PHY_CALIB_CRYSTAL;</a>
<a name="ln7670">	cmd.ngroups = 1;</a>
<a name="ln7671">	cmd.isvalid = 1;</a>
<a name="ln7672">	cmd.cap_pin[0] = le32toh(sc-&gt;eeprom_crystal) &amp; 0xff;</a>
<a name="ln7673">	cmd.cap_pin[1] = (le32toh(sc-&gt;eeprom_crystal) &gt;&gt; 16) &amp; 0xff;</a>
<a name="ln7674">	DPRINTF(sc, IWN_DEBUG_CALIBRATE, &quot;sending crystal calibration %d, %d\n&quot;,</a>
<a name="ln7675">	    cmd.cap_pin[0], cmd.cap_pin[1]);</a>
<a name="ln7676">	return iwn_cmd(sc, IWN_CMD_PHY_CALIB, &amp;cmd, sizeof cmd, 0);</a>
<a name="ln7677">}</a>
<a name="ln7678"> </a>
<a name="ln7679">static int</a>
<a name="ln7680">iwn5000_temp_offset_calib(struct iwn_softc *sc)</a>
<a name="ln7681">{</a>
<a name="ln7682">	struct iwn5000_phy_calib_temp_offset cmd;</a>
<a name="ln7683"> </a>
<a name="ln7684">	memset(&amp;cmd, 0, sizeof cmd);</a>
<a name="ln7685">	cmd.code = IWN5000_PHY_CALIB_TEMP_OFFSET;</a>
<a name="ln7686">	cmd.ngroups = 1;</a>
<a name="ln7687">	cmd.isvalid = 1;</a>
<a name="ln7688">	if (sc-&gt;eeprom_temp != 0)</a>
<a name="ln7689">		cmd.offset = htole16(sc-&gt;eeprom_temp);</a>
<a name="ln7690">	else</a>
<a name="ln7691">		cmd.offset = htole16(IWN_DEFAULT_TEMP_OFFSET);</a>
<a name="ln7692">	DPRINTF(sc, IWN_DEBUG_CALIBRATE, &quot;setting radio sensor offset to %d\n&quot;,</a>
<a name="ln7693">	    le16toh(cmd.offset));</a>
<a name="ln7694">	return iwn_cmd(sc, IWN_CMD_PHY_CALIB, &amp;cmd, sizeof cmd, 0);</a>
<a name="ln7695">}</a>
<a name="ln7696"> </a>
<a name="ln7697">static int</a>
<a name="ln7698">iwn5000_temp_offset_calibv2(struct iwn_softc *sc)</a>
<a name="ln7699">{</a>
<a name="ln7700">	struct iwn5000_phy_calib_temp_offsetv2 cmd;</a>
<a name="ln7701"> </a>
<a name="ln7702">	memset(&amp;cmd, 0, sizeof cmd);</a>
<a name="ln7703">	cmd.code = IWN5000_PHY_CALIB_TEMP_OFFSET;</a>
<a name="ln7704">	cmd.ngroups = 1;</a>
<a name="ln7705">	cmd.isvalid = 1;</a>
<a name="ln7706">	if (sc-&gt;eeprom_temp != 0) {</a>
<a name="ln7707">		cmd.offset_low = htole16(sc-&gt;eeprom_temp);</a>
<a name="ln7708">		cmd.offset_high = htole16(sc-&gt;eeprom_temp_high);</a>
<a name="ln7709">	} else {</a>
<a name="ln7710">		cmd.offset_low = htole16(IWN_DEFAULT_TEMP_OFFSET);</a>
<a name="ln7711">		cmd.offset_high = htole16(IWN_DEFAULT_TEMP_OFFSET);</a>
<a name="ln7712">	}</a>
<a name="ln7713">	cmd.burnt_voltage_ref = htole16(sc-&gt;eeprom_voltage);</a>
<a name="ln7714"> </a>
<a name="ln7715">	DPRINTF(sc, IWN_DEBUG_CALIBRATE,</a>
<a name="ln7716">	    &quot;setting radio sensor low offset to %d, high offset to %d, voltage to %d\n&quot;,</a>
<a name="ln7717">	    le16toh(cmd.offset_low),</a>
<a name="ln7718">	    le16toh(cmd.offset_high),</a>
<a name="ln7719">	    le16toh(cmd.burnt_voltage_ref));</a>
<a name="ln7720"> </a>
<a name="ln7721">	return iwn_cmd(sc, IWN_CMD_PHY_CALIB, &amp;cmd, sizeof cmd, 0);</a>
<a name="ln7722">}</a>
<a name="ln7723"> </a>
<a name="ln7724">/*</a>
<a name="ln7725"> * This function is called after the runtime firmware notifies us of its</a>
<a name="ln7726"> * readiness (called in a process context).</a>
<a name="ln7727"> */</a>
<a name="ln7728">static int</a>
<a name="ln7729">iwn4965_post_alive(struct iwn_softc *sc)</a>
<a name="ln7730">{</a>
<a name="ln7731">	int error, qid;</a>
<a name="ln7732"> </a>
<a name="ln7733">	if ((error = iwn_nic_lock(sc)) != 0)</a>
<a name="ln7734">		return error;</a>
<a name="ln7735"> </a>
<a name="ln7736">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln7737"> </a>
<a name="ln7738">	/* Clear TX scheduler state in SRAM. */</a>
<a name="ln7739">	sc-&gt;sched_base = iwn_prph_read(sc, IWN_SCHED_SRAM_ADDR);</a>
<a name="ln7740">	iwn_mem_set_region_4(sc, sc-&gt;sched_base + IWN4965_SCHED_CTX_OFF, 0,</a>
<a name="ln7741">	    IWN4965_SCHED_CTX_LEN / sizeof (uint32_t));</a>
<a name="ln7742"> </a>
<a name="ln7743">	/* Set physical address of TX scheduler rings (1KB aligned). */</a>
<a name="ln7744">	iwn_prph_write(sc, IWN4965_SCHED_DRAM_ADDR, sc-&gt;sched_dma.paddr &gt;&gt; 10);</a>
<a name="ln7745"> </a>
<a name="ln7746">	IWN_SETBITS(sc, IWN_FH_TX_CHICKEN, IWN_FH_TX_CHICKEN_SCHED_RETRY);</a>
<a name="ln7747"> </a>
<a name="ln7748">	/* Disable chain mode for all our 16 queues. */</a>
<a name="ln7749">	iwn_prph_write(sc, IWN4965_SCHED_QCHAIN_SEL, 0);</a>
<a name="ln7750"> </a>
<a name="ln7751">	for (qid = 0; qid &lt; IWN4965_NTXQUEUES; qid++) {</a>
<a name="ln7752">		iwn_prph_write(sc, IWN4965_SCHED_QUEUE_RDPTR(qid), 0);</a>
<a name="ln7753">		IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, qid &lt;&lt; 8 | 0);</a>
<a name="ln7754"> </a>
<a name="ln7755">		/* Set scheduler window size. */</a>
<a name="ln7756">		iwn_mem_write(sc, sc-&gt;sched_base +</a>
<a name="ln7757">		    IWN4965_SCHED_QUEUE_OFFSET(qid), IWN_SCHED_WINSZ);</a>
<a name="ln7758">		/* Set scheduler frame limit. */</a>
<a name="ln7759">		iwn_mem_write(sc, sc-&gt;sched_base +</a>
<a name="ln7760">		    IWN4965_SCHED_QUEUE_OFFSET(qid) + 4,</a>
<a name="ln7761">		    IWN_SCHED_LIMIT &lt;&lt; 16);</a>
<a name="ln7762">	}</a>
<a name="ln7763"> </a>
<a name="ln7764">	/* Enable interrupts for all our 16 queues. */</a>
<a name="ln7765">	iwn_prph_write(sc, IWN4965_SCHED_INTR_MASK, 0xffff);</a>
<a name="ln7766">	/* Identify TX FIFO rings (0-7). */</a>
<a name="ln7767">	iwn_prph_write(sc, IWN4965_SCHED_TXFACT, 0xff);</a>
<a name="ln7768"> </a>
<a name="ln7769">	/* Mark TX rings (4 EDCA + cmd + 2 HCCA) as active. */</a>
<a name="ln7770">	for (qid = 0; qid &lt; 7; qid++) {</a>
<a name="ln7771">		static uint8_t qid2fifo[] = { 3, 2, 1, 0, 4, 5, 6 };</a>
<a name="ln7772">		iwn_prph_write(sc, IWN4965_SCHED_QUEUE_STATUS(qid),</a>
<a name="ln7773">		    IWN4965_TXQ_STATUS_ACTIVE | qid2fifo[qid] &lt;&lt; 1);</a>
<a name="ln7774">	}</a>
<a name="ln7775">	iwn_nic_unlock(sc);</a>
<a name="ln7776">	return 0;</a>
<a name="ln7777">}</a>
<a name="ln7778"> </a>
<a name="ln7779">/*</a>
<a name="ln7780"> * This function is called after the initialization or runtime firmware</a>
<a name="ln7781"> * notifies us of its readiness (called in a process context).</a>
<a name="ln7782"> */</a>
<a name="ln7783">static int</a>
<a name="ln7784">iwn5000_post_alive(struct iwn_softc *sc)</a>
<a name="ln7785">{</a>
<a name="ln7786">	int error, qid;</a>
<a name="ln7787"> </a>
<a name="ln7788">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln7789"> </a>
<a name="ln7790">#ifndef __HAIKU__</a>
<a name="ln7791">	/* Switch to using ICT interrupt mode. */</a>
<a name="ln7792">	iwn5000_ict_reset(sc);</a>
<a name="ln7793">#endif</a>
<a name="ln7794"> </a>
<a name="ln7795">	if ((error = iwn_nic_lock(sc)) != 0){</a>
<a name="ln7796">		DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s end in error\n&quot;, __func__);</a>
<a name="ln7797">		return error;</a>
<a name="ln7798">	}</a>
<a name="ln7799"> </a>
<a name="ln7800">	/* Clear TX scheduler state in SRAM. */</a>
<a name="ln7801">	sc-&gt;sched_base = iwn_prph_read(sc, IWN_SCHED_SRAM_ADDR);</a>
<a name="ln7802">	iwn_mem_set_region_4(sc, sc-&gt;sched_base + IWN5000_SCHED_CTX_OFF, 0,</a>
<a name="ln7803">	    IWN5000_SCHED_CTX_LEN / sizeof (uint32_t));</a>
<a name="ln7804"> </a>
<a name="ln7805">	/* Set physical address of TX scheduler rings (1KB aligned). */</a>
<a name="ln7806">	iwn_prph_write(sc, IWN5000_SCHED_DRAM_ADDR, sc-&gt;sched_dma.paddr &gt;&gt; 10);</a>
<a name="ln7807"> </a>
<a name="ln7808">	IWN_SETBITS(sc, IWN_FH_TX_CHICKEN, IWN_FH_TX_CHICKEN_SCHED_RETRY);</a>
<a name="ln7809"> </a>
<a name="ln7810">	/* Enable chain mode for all queues, except command queue. */</a>
<a name="ln7811">	if (sc-&gt;sc_flags &amp; IWN_FLAG_PAN_SUPPORT)</a>
<a name="ln7812">		iwn_prph_write(sc, IWN5000_SCHED_QCHAIN_SEL, 0xfffdf);</a>
<a name="ln7813">	else</a>
<a name="ln7814">		iwn_prph_write(sc, IWN5000_SCHED_QCHAIN_SEL, 0xfffef);</a>
<a name="ln7815">	iwn_prph_write(sc, IWN5000_SCHED_AGGR_SEL, 0);</a>
<a name="ln7816"> </a>
<a name="ln7817">	for (qid = 0; qid &lt; IWN5000_NTXQUEUES; qid++) {</a>
<a name="ln7818">		iwn_prph_write(sc, IWN5000_SCHED_QUEUE_RDPTR(qid), 0);</a>
<a name="ln7819">		IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, qid &lt;&lt; 8 | 0);</a>
<a name="ln7820"> </a>
<a name="ln7821">		iwn_mem_write(sc, sc-&gt;sched_base +</a>
<a name="ln7822">		    IWN5000_SCHED_QUEUE_OFFSET(qid), 0);</a>
<a name="ln7823">		/* Set scheduler window size and frame limit. */</a>
<a name="ln7824">		iwn_mem_write(sc, sc-&gt;sched_base +</a>
<a name="ln7825">		    IWN5000_SCHED_QUEUE_OFFSET(qid) + 4,</a>
<a name="ln7826">		    IWN_SCHED_LIMIT &lt;&lt; 16 | IWN_SCHED_WINSZ);</a>
<a name="ln7827">	}</a>
<a name="ln7828"> </a>
<a name="ln7829">	/* Enable interrupts for all our 20 queues. */</a>
<a name="ln7830">	iwn_prph_write(sc, IWN5000_SCHED_INTR_MASK, 0xfffff);</a>
<a name="ln7831">	/* Identify TX FIFO rings (0-7). */</a>
<a name="ln7832">	iwn_prph_write(sc, IWN5000_SCHED_TXFACT, 0xff);</a>
<a name="ln7833"> </a>
<a name="ln7834">	/* Mark TX rings (4 EDCA + cmd + 2 HCCA) as active. */</a>
<a name="ln7835">	if (sc-&gt;sc_flags &amp; IWN_FLAG_PAN_SUPPORT) {</a>
<a name="ln7836">		/* Mark TX rings as active. */</a>
<a name="ln7837">		for (qid = 0; qid &lt; 11; qid++) {</a>
<a name="ln7838">			static uint8_t qid2fifo[] = { 3, 2, 1, 0, 0, 4, 2, 5, 4, 7, 5 };</a>
<a name="ln7839">			iwn_prph_write(sc, IWN5000_SCHED_QUEUE_STATUS(qid),</a>
<a name="ln7840">			    IWN5000_TXQ_STATUS_ACTIVE | qid2fifo[qid]);</a>
<a name="ln7841">		}</a>
<a name="ln7842">	} else {</a>
<a name="ln7843">		/* Mark TX rings (4 EDCA + cmd + 2 HCCA) as active. */</a>
<a name="ln7844">		for (qid = 0; qid &lt; 7; qid++) {</a>
<a name="ln7845">			static uint8_t qid2fifo[] = { 3, 2, 1, 0, 7, 5, 6 };</a>
<a name="ln7846">			iwn_prph_write(sc, IWN5000_SCHED_QUEUE_STATUS(qid),</a>
<a name="ln7847">			    IWN5000_TXQ_STATUS_ACTIVE | qid2fifo[qid]);</a>
<a name="ln7848">		}</a>
<a name="ln7849">	}</a>
<a name="ln7850">	iwn_nic_unlock(sc);</a>
<a name="ln7851"> </a>
<a name="ln7852">	/* Configure WiMAX coexistence for combo adapters. */</a>
<a name="ln7853">	error = iwn5000_send_wimax_coex(sc);</a>
<a name="ln7854">	if (error != 0) {</a>
<a name="ln7855">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln7856">		    &quot;%s: could not configure WiMAX coexistence, error %d\n&quot;,</a>
<a name="ln7857">		    __func__, error);</a>
<a name="ln7858">		return error;</a>
<a name="ln7859">	}</a>
<a name="ln7860">	if (sc-&gt;hw_type != IWN_HW_REV_TYPE_5150) {</a>
<a name="ln7861">		/* Perform crystal calibration. */</a>
<a name="ln7862">		error = iwn5000_crystal_calib(sc);</a>
<a name="ln7863">		if (error != 0) {</a>
<a name="ln7864">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln7865">			    &quot;%s: crystal calibration failed, error %d\n&quot;,</a>
<a name="ln7866">			    __func__, error);</a>
<a name="ln7867">			return error;</a>
<a name="ln7868">		}</a>
<a name="ln7869">	}</a>
<a name="ln7870">	if (!(sc-&gt;sc_flags &amp; IWN_FLAG_CALIB_DONE)) {</a>
<a name="ln7871">		/* Query calibration from the initialization firmware. */</a>
<a name="ln7872">		if ((error = iwn5000_query_calibration(sc)) != 0) {</a>
<a name="ln7873">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln7874">			    &quot;%s: could not query calibration, error %d\n&quot;,</a>
<a name="ln7875">			    __func__, error);</a>
<a name="ln7876">			return error;</a>
<a name="ln7877">		}</a>
<a name="ln7878">		/*</a>
<a name="ln7879">		 * We have the calibration results now, reboot with the</a>
<a name="ln7880">		 * runtime firmware (call ourselves recursively!)</a>
<a name="ln7881">		 */</a>
<a name="ln7882">		iwn_hw_stop(sc);</a>
<a name="ln7883">		error = iwn_hw_init(sc);</a>
<a name="ln7884">	} else {</a>
<a name="ln7885">		/* Send calibration results to runtime firmware. */</a>
<a name="ln7886">		error = iwn5000_send_calibration(sc);</a>
<a name="ln7887">	}</a>
<a name="ln7888"> </a>
<a name="ln7889">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: end\n&quot;,__func__);</a>
<a name="ln7890"> </a>
<a name="ln7891">	return error;</a>
<a name="ln7892">}</a>
<a name="ln7893"> </a>
<a name="ln7894">/*</a>
<a name="ln7895"> * The firmware boot code is small and is intended to be copied directly into</a>
<a name="ln7896"> * the NIC internal memory (no DMA transfer).</a>
<a name="ln7897"> */</a>
<a name="ln7898">static int</a>
<a name="ln7899">iwn4965_load_bootcode(struct iwn_softc *sc, const uint8_t *ucode, int size)</a>
<a name="ln7900">{</a>
<a name="ln7901">	int error, ntries;</a>
<a name="ln7902"> </a>
<a name="ln7903">	size /= sizeof (uint32_t);</a>
<a name="ln7904"> </a>
<a name="ln7905">	if ((error = iwn_nic_lock(sc)) != 0)</a>
<a name="ln7906">		return error;</a>
<a name="ln7907"> </a>
<a name="ln7908">	/* Copy microcode image into NIC memory. */</a>
<a name="ln7909">	iwn_prph_write_region_4(sc, IWN_BSM_SRAM_BASE,</a>
<a name="ln7910">	    (const uint32_t *)ucode, size);</a>
<a name="ln7911"> </a>
<a name="ln7912">	iwn_prph_write(sc, IWN_BSM_WR_MEM_SRC, 0);</a>
<a name="ln7913">	iwn_prph_write(sc, IWN_BSM_WR_MEM_DST, IWN_FW_TEXT_BASE);</a>
<a name="ln7914">	iwn_prph_write(sc, IWN_BSM_WR_DWCOUNT, size);</a>
<a name="ln7915"> </a>
<a name="ln7916">	/* Start boot load now. */</a>
<a name="ln7917">	iwn_prph_write(sc, IWN_BSM_WR_CTRL, IWN_BSM_WR_CTRL_START);</a>
<a name="ln7918"> </a>
<a name="ln7919">	/* Wait for transfer to complete. */</a>
<a name="ln7920">	for (ntries = 0; ntries &lt; 1000; ntries++) {</a>
<a name="ln7921">		if (!(iwn_prph_read(sc, IWN_BSM_WR_CTRL) &amp;</a>
<a name="ln7922">		    IWN_BSM_WR_CTRL_START))</a>
<a name="ln7923">			break;</a>
<a name="ln7924">		DELAY(10);</a>
<a name="ln7925">	}</a>
<a name="ln7926">	if (ntries == 1000) {</a>
<a name="ln7927">		device_printf(sc-&gt;sc_dev, &quot;%s: could not load boot firmware\n&quot;,</a>
<a name="ln7928">		    __func__);</a>
<a name="ln7929">		iwn_nic_unlock(sc);</a>
<a name="ln7930">		return ETIMEDOUT;</a>
<a name="ln7931">	}</a>
<a name="ln7932"> </a>
<a name="ln7933">	/* Enable boot after power up. */</a>
<a name="ln7934">	iwn_prph_write(sc, IWN_BSM_WR_CTRL, IWN_BSM_WR_CTRL_START_EN);</a>
<a name="ln7935"> </a>
<a name="ln7936">	iwn_nic_unlock(sc);</a>
<a name="ln7937">	return 0;</a>
<a name="ln7938">}</a>
<a name="ln7939"> </a>
<a name="ln7940">static int</a>
<a name="ln7941">iwn4965_load_firmware(struct iwn_softc *sc)</a>
<a name="ln7942">{</a>
<a name="ln7943">	struct iwn_fw_info *fw = &amp;sc-&gt;fw;</a>
<a name="ln7944">	struct iwn_dma_info *dma = &amp;sc-&gt;fw_dma;</a>
<a name="ln7945">	int error;</a>
<a name="ln7946"> </a>
<a name="ln7947">	/* Copy initialization sections into pre-allocated DMA-safe memory. */</a>
<a name="ln7948">	memcpy(dma-&gt;vaddr, fw-&gt;init.data, fw-&gt;init.datasz);</a>
<a name="ln7949">	bus_dmamap_sync(dma-&gt;tag, dma-&gt;map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln7950">	memcpy(dma-&gt;vaddr + IWN4965_FW_DATA_MAXSZ,</a>
<a name="ln7951">	    fw-&gt;init.text, fw-&gt;init.textsz);</a>
<a name="ln7952">	bus_dmamap_sync(dma-&gt;tag, dma-&gt;map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln7953"> </a>
<a name="ln7954">	/* Tell adapter where to find initialization sections. */</a>
<a name="ln7955">	if ((error = iwn_nic_lock(sc)) != 0)</a>
<a name="ln7956">		return error;</a>
<a name="ln7957">	iwn_prph_write(sc, IWN_BSM_DRAM_DATA_ADDR, dma-&gt;paddr &gt;&gt; 4);</a>
<a name="ln7958">	iwn_prph_write(sc, IWN_BSM_DRAM_DATA_SIZE, fw-&gt;init.datasz);</a>
<a name="ln7959">	iwn_prph_write(sc, IWN_BSM_DRAM_TEXT_ADDR,</a>
<a name="ln7960">	    (dma-&gt;paddr + IWN4965_FW_DATA_MAXSZ) &gt;&gt; 4);</a>
<a name="ln7961">	iwn_prph_write(sc, IWN_BSM_DRAM_TEXT_SIZE, fw-&gt;init.textsz);</a>
<a name="ln7962">	iwn_nic_unlock(sc);</a>
<a name="ln7963"> </a>
<a name="ln7964">	/* Load firmware boot code. */</a>
<a name="ln7965">	error = iwn4965_load_bootcode(sc, fw-&gt;boot.text, fw-&gt;boot.textsz);</a>
<a name="ln7966">	if (error != 0) {</a>
<a name="ln7967">		device_printf(sc-&gt;sc_dev, &quot;%s: could not load boot firmware\n&quot;,</a>
<a name="ln7968">		    __func__);</a>
<a name="ln7969">		return error;</a>
<a name="ln7970">	}</a>
<a name="ln7971">	/* Now press &quot;execute&quot;. */</a>
<a name="ln7972">	IWN_WRITE(sc, IWN_RESET, 0);</a>
<a name="ln7973"> </a>
<a name="ln7974">	/* Wait at most one second for first alive notification. */</a>
<a name="ln7975">	if ((error = msleep(sc, &amp;sc-&gt;sc_mtx, PCATCH, &quot;iwninit&quot;, hz)) != 0) {</a>
<a name="ln7976">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln7977">		    &quot;%s: timeout waiting for adapter to initialize, error %d\n&quot;,</a>
<a name="ln7978">		    __func__, error);</a>
<a name="ln7979">		return error;</a>
<a name="ln7980">	}</a>
<a name="ln7981"> </a>
<a name="ln7982">	/* Retrieve current temperature for initial TX power calibration. */</a>
<a name="ln7983">	sc-&gt;rawtemp = sc-&gt;ucode_info.temp[3].chan20MHz;</a>
<a name="ln7984">	sc-&gt;temp = iwn4965_get_temperature(sc);</a>
<a name="ln7985"> </a>
<a name="ln7986">	/* Copy runtime sections into pre-allocated DMA-safe memory. */</a>
<a name="ln7987">	memcpy(dma-&gt;vaddr, fw-&gt;main.data, fw-&gt;main.datasz);</a>
<a name="ln7988">	bus_dmamap_sync(dma-&gt;tag, dma-&gt;map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln7989">	memcpy(dma-&gt;vaddr + IWN4965_FW_DATA_MAXSZ,</a>
<a name="ln7990">	    fw-&gt;main.text, fw-&gt;main.textsz);</a>
<a name="ln7991">	bus_dmamap_sync(dma-&gt;tag, dma-&gt;map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln7992"> </a>
<a name="ln7993">	/* Tell adapter where to find runtime sections. */</a>
<a name="ln7994">	if ((error = iwn_nic_lock(sc)) != 0)</a>
<a name="ln7995">		return error;</a>
<a name="ln7996">	iwn_prph_write(sc, IWN_BSM_DRAM_DATA_ADDR, dma-&gt;paddr &gt;&gt; 4);</a>
<a name="ln7997">	iwn_prph_write(sc, IWN_BSM_DRAM_DATA_SIZE, fw-&gt;main.datasz);</a>
<a name="ln7998">	iwn_prph_write(sc, IWN_BSM_DRAM_TEXT_ADDR,</a>
<a name="ln7999">	    (dma-&gt;paddr + IWN4965_FW_DATA_MAXSZ) &gt;&gt; 4);</a>
<a name="ln8000">	iwn_prph_write(sc, IWN_BSM_DRAM_TEXT_SIZE,</a>
<a name="ln8001">	    IWN_FW_UPDATED | fw-&gt;main.textsz);</a>
<a name="ln8002">	iwn_nic_unlock(sc);</a>
<a name="ln8003"> </a>
<a name="ln8004">	return 0;</a>
<a name="ln8005">}</a>
<a name="ln8006"> </a>
<a name="ln8007">static int</a>
<a name="ln8008">iwn5000_load_firmware_section(struct iwn_softc *sc, uint32_t dst,</a>
<a name="ln8009">    const uint8_t *section, int size)</a>
<a name="ln8010">{</a>
<a name="ln8011">	struct iwn_dma_info *dma = &amp;sc-&gt;fw_dma;</a>
<a name="ln8012">	int error;</a>
<a name="ln8013"> </a>
<a name="ln8014">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln8015"> </a>
<a name="ln8016">	/* Copy firmware section into pre-allocated DMA-safe memory. */</a>
<a name="ln8017">	memcpy(dma-&gt;vaddr, section, size);</a>
<a name="ln8018">	bus_dmamap_sync(dma-&gt;tag, dma-&gt;map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln8019"> </a>
<a name="ln8020">	if ((error = iwn_nic_lock(sc)) != 0)</a>
<a name="ln8021">		return error;</a>
<a name="ln8022"> </a>
<a name="ln8023">	IWN_WRITE(sc, IWN_FH_TX_CONFIG(IWN_SRVC_DMACHNL),</a>
<a name="ln8024">	    IWN_FH_TX_CONFIG_DMA_PAUSE);</a>
<a name="ln8025"> </a>
<a name="ln8026">	IWN_WRITE(sc, IWN_FH_SRAM_ADDR(IWN_SRVC_DMACHNL), dst);</a>
<a name="ln8027">	IWN_WRITE(sc, IWN_FH_TFBD_CTRL0(IWN_SRVC_DMACHNL),</a>
<a name="ln8028">	    IWN_LOADDR(dma-&gt;paddr));</a>
<a name="ln8029">	IWN_WRITE(sc, IWN_FH_TFBD_CTRL1(IWN_SRVC_DMACHNL),</a>
<a name="ln8030">	    IWN_HIADDR(dma-&gt;paddr) &lt;&lt; 28 | size);</a>
<a name="ln8031">	IWN_WRITE(sc, IWN_FH_TXBUF_STATUS(IWN_SRVC_DMACHNL),</a>
<a name="ln8032">	    IWN_FH_TXBUF_STATUS_TBNUM(1) |</a>
<a name="ln8033">	    IWN_FH_TXBUF_STATUS_TBIDX(1) |</a>
<a name="ln8034">	    IWN_FH_TXBUF_STATUS_TFBD_VALID);</a>
<a name="ln8035"> </a>
<a name="ln8036">	/* Kick Flow Handler to start DMA transfer. */</a>
<a name="ln8037">	IWN_WRITE(sc, IWN_FH_TX_CONFIG(IWN_SRVC_DMACHNL),</a>
<a name="ln8038">	    IWN_FH_TX_CONFIG_DMA_ENA | IWN_FH_TX_CONFIG_CIRQ_HOST_ENDTFD);</a>
<a name="ln8039"> </a>
<a name="ln8040">	iwn_nic_unlock(sc);</a>
<a name="ln8041"> </a>
<a name="ln8042">	/* Wait at most five seconds for FH DMA transfer to complete. */</a>
<a name="ln8043">	return msleep(sc, &amp;sc-&gt;sc_mtx, PCATCH, &quot;iwninit&quot;, 5 * hz);</a>
<a name="ln8044">}</a>
<a name="ln8045"> </a>
<a name="ln8046">static int</a>
<a name="ln8047">iwn5000_load_firmware(struct iwn_softc *sc)</a>
<a name="ln8048">{</a>
<a name="ln8049">	struct iwn_fw_part *fw;</a>
<a name="ln8050">	int error;</a>
<a name="ln8051"> </a>
<a name="ln8052">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln8053"> </a>
<a name="ln8054">	/* Load the initialization firmware on first boot only. */</a>
<a name="ln8055">	fw = (sc-&gt;sc_flags &amp; IWN_FLAG_CALIB_DONE) ?</a>
<a name="ln8056">	    &amp;sc-&gt;fw.main : &amp;sc-&gt;fw.init;</a>
<a name="ln8057"> </a>
<a name="ln8058">	error = iwn5000_load_firmware_section(sc, IWN_FW_TEXT_BASE,</a>
<a name="ln8059">	    fw-&gt;text, fw-&gt;textsz);</a>
<a name="ln8060">	if (error != 0) {</a>
<a name="ln8061">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln8062">		    &quot;%s: could not load firmware %s section, error %d\n&quot;,</a>
<a name="ln8063">		    __func__, &quot;.text&quot;, error);</a>
<a name="ln8064">		return error;</a>
<a name="ln8065">	}</a>
<a name="ln8066">	error = iwn5000_load_firmware_section(sc, IWN_FW_DATA_BASE,</a>
<a name="ln8067">	    fw-&gt;data, fw-&gt;datasz);</a>
<a name="ln8068">	if (error != 0) {</a>
<a name="ln8069">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln8070">		    &quot;%s: could not load firmware %s section, error %d\n&quot;,</a>
<a name="ln8071">		    __func__, &quot;.data&quot;, error);</a>
<a name="ln8072">		return error;</a>
<a name="ln8073">	}</a>
<a name="ln8074"> </a>
<a name="ln8075">	/* Now press &quot;execute&quot;. */</a>
<a name="ln8076">	IWN_WRITE(sc, IWN_RESET, 0);</a>
<a name="ln8077">	return 0;</a>
<a name="ln8078">}</a>
<a name="ln8079"> </a>
<a name="ln8080">/*</a>
<a name="ln8081"> * Extract text and data sections from a legacy firmware image.</a>
<a name="ln8082"> */</a>
<a name="ln8083">static int</a>
<a name="ln8084">iwn_read_firmware_leg(struct iwn_softc *sc, struct iwn_fw_info *fw)</a>
<a name="ln8085">{</a>
<a name="ln8086">	const uint32_t *ptr;</a>
<a name="ln8087">	size_t hdrlen = 24;</a>
<a name="ln8088">	uint32_t rev;</a>
<a name="ln8089"> </a>
<a name="ln8090">	ptr = (const uint32_t *)fw-&gt;data;</a>
<a name="ln8091">	rev = le32toh(*ptr++);</a>
<a name="ln8092"> </a>
<a name="ln8093">	sc-&gt;ucode_rev = rev;</a>
<a name="ln8094"> </a>
<a name="ln8095">	/* Check firmware API version. */</a>
<a name="ln8096">	if (IWN_FW_API(rev) &lt;= 1) {</a>
<a name="ln8097">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln8098">		    &quot;%s: bad firmware, need API version &gt;=2\n&quot;, __func__);</a>
<a name="ln8099">		return EINVAL;</a>
<a name="ln8100">	}</a>
<a name="ln8101">	if (IWN_FW_API(rev) &gt;= 3) {</a>
<a name="ln8102">		/* Skip build number (version 2 header). */</a>
<a name="ln8103">		hdrlen += 4;</a>
<a name="ln8104">		ptr++;</a>
<a name="ln8105">	}</a>
<a name="ln8106">	if (fw-&gt;size &lt; hdrlen) {</a>
<a name="ln8107">		device_printf(sc-&gt;sc_dev, &quot;%s: firmware too short: %zu bytes\n&quot;,</a>
<a name="ln8108">		    __func__, fw-&gt;size);</a>
<a name="ln8109">		return EINVAL;</a>
<a name="ln8110">	}</a>
<a name="ln8111">	fw-&gt;main.textsz = le32toh(*ptr++);</a>
<a name="ln8112">	fw-&gt;main.datasz = le32toh(*ptr++);</a>
<a name="ln8113">	fw-&gt;init.textsz = le32toh(*ptr++);</a>
<a name="ln8114">	fw-&gt;init.datasz = le32toh(*ptr++);</a>
<a name="ln8115">	fw-&gt;boot.textsz = le32toh(*ptr++);</a>
<a name="ln8116"> </a>
<a name="ln8117">	/* Check that all firmware sections fit. */</a>
<a name="ln8118">	if (fw-&gt;size &lt; hdrlen + fw-&gt;main.textsz + fw-&gt;main.datasz +</a>
<a name="ln8119">	    fw-&gt;init.textsz + fw-&gt;init.datasz + fw-&gt;boot.textsz) {</a>
<a name="ln8120">		device_printf(sc-&gt;sc_dev, &quot;%s: firmware too short: %zu bytes\n&quot;,</a>
<a name="ln8121">		    __func__, fw-&gt;size);</a>
<a name="ln8122">		return EINVAL;</a>
<a name="ln8123">	}</a>
<a name="ln8124"> </a>
<a name="ln8125">	/* Get pointers to firmware sections. */</a>
<a name="ln8126">	fw-&gt;main.text = (const uint8_t *)ptr;</a>
<a name="ln8127">	fw-&gt;main.data = fw-&gt;main.text + fw-&gt;main.textsz;</a>
<a name="ln8128">	fw-&gt;init.text = fw-&gt;main.data + fw-&gt;main.datasz;</a>
<a name="ln8129">	fw-&gt;init.data = fw-&gt;init.text + fw-&gt;init.textsz;</a>
<a name="ln8130">	fw-&gt;boot.text = fw-&gt;init.data + fw-&gt;init.datasz;</a>
<a name="ln8131">	return 0;</a>
<a name="ln8132">}</a>
<a name="ln8133"> </a>
<a name="ln8134">/*</a>
<a name="ln8135"> * Extract text and data sections from a TLV firmware image.</a>
<a name="ln8136"> */</a>
<a name="ln8137">static int</a>
<a name="ln8138">iwn_read_firmware_tlv(struct iwn_softc *sc, struct iwn_fw_info *fw,</a>
<a name="ln8139">    uint16_t alt)</a>
<a name="ln8140">{</a>
<a name="ln8141">	const struct iwn_fw_tlv_hdr *hdr;</a>
<a name="ln8142">	const struct iwn_fw_tlv *tlv;</a>
<a name="ln8143">	const uint8_t *ptr, *end;</a>
<a name="ln8144">	uint64_t altmask;</a>
<a name="ln8145">	uint32_t len, tmp;</a>
<a name="ln8146"> </a>
<a name="ln8147">	if (fw-&gt;size &lt; sizeof (*hdr)) {</a>
<a name="ln8148">		device_printf(sc-&gt;sc_dev, &quot;%s: firmware too short: %zu bytes\n&quot;,</a>
<a name="ln8149">		    __func__, fw-&gt;size);</a>
<a name="ln8150">		return EINVAL;</a>
<a name="ln8151">	}</a>
<a name="ln8152">	hdr = (const struct iwn_fw_tlv_hdr *)fw-&gt;data;</a>
<a name="ln8153">	if (hdr-&gt;signature != htole32(IWN_FW_SIGNATURE)) {</a>
<a name="ln8154">		device_printf(sc-&gt;sc_dev, &quot;%s: bad firmware signature 0x%08x\n&quot;,</a>
<a name="ln8155">		    __func__, le32toh(hdr-&gt;signature));</a>
<a name="ln8156">		return EINVAL;</a>
<a name="ln8157">	}</a>
<a name="ln8158">	DPRINTF(sc, IWN_DEBUG_RESET, &quot;FW: \&quot;%.64s\&quot;, build 0x%x\n&quot;, hdr-&gt;descr,</a>
<a name="ln8159">	    le32toh(hdr-&gt;build));</a>
<a name="ln8160">	sc-&gt;ucode_rev = le32toh(hdr-&gt;rev);</a>
<a name="ln8161"> </a>
<a name="ln8162">	/*</a>
<a name="ln8163">	 * Select the closest supported alternative that is less than</a>
<a name="ln8164">	 * or equal to the specified one.</a>
<a name="ln8165">	 */</a>
<a name="ln8166">	altmask = le64toh(hdr-&gt;altmask);</a>
<a name="ln8167">	while (alt &gt; 0 &amp;&amp; !(altmask &amp; (1ULL &lt;&lt; alt)))</a>
<a name="ln8168">		alt--;	/* Downgrade. */</a>
<a name="ln8169">	DPRINTF(sc, IWN_DEBUG_RESET, &quot;using alternative %d\n&quot;, alt);</a>
<a name="ln8170"> </a>
<a name="ln8171">	ptr = (const uint8_t *)(hdr + 1);</a>
<a name="ln8172">	end = (const uint8_t *)(fw-&gt;data + fw-&gt;size);</a>
<a name="ln8173"> </a>
<a name="ln8174">	/* Parse type-length-value fields. */</a>
<a name="ln8175">	while (ptr + sizeof (*tlv) &lt;= end) {</a>
<a name="ln8176">		tlv = (const struct iwn_fw_tlv *)ptr;</a>
<a name="ln8177">		len = le32toh(tlv-&gt;len);</a>
<a name="ln8178"> </a>
<a name="ln8179">		ptr += sizeof (*tlv);</a>
<a name="ln8180">		if (ptr + len &gt; end) {</a>
<a name="ln8181">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln8182">			    &quot;%s: firmware too short: %zu bytes\n&quot;, __func__,</a>
<a name="ln8183">			    fw-&gt;size);</a>
<a name="ln8184">			return EINVAL;</a>
<a name="ln8185">		}</a>
<a name="ln8186">		/* Skip other alternatives. */</a>
<a name="ln8187">		if (tlv-&gt;alt != 0 &amp;&amp; tlv-&gt;alt != htole16(alt))</a>
<a name="ln8188">			goto next;</a>
<a name="ln8189"> </a>
<a name="ln8190">		switch (le16toh(tlv-&gt;type)) {</a>
<a name="ln8191">		case IWN_FW_TLV_MAIN_TEXT:</a>
<a name="ln8192">			fw-&gt;main.text = ptr;</a>
<a name="ln8193">			fw-&gt;main.textsz = len;</a>
<a name="ln8194">			break;</a>
<a name="ln8195">		case IWN_FW_TLV_MAIN_DATA:</a>
<a name="ln8196">			fw-&gt;main.data = ptr;</a>
<a name="ln8197">			fw-&gt;main.datasz = len;</a>
<a name="ln8198">			break;</a>
<a name="ln8199">		case IWN_FW_TLV_INIT_TEXT:</a>
<a name="ln8200">			fw-&gt;init.text = ptr;</a>
<a name="ln8201">			fw-&gt;init.textsz = len;</a>
<a name="ln8202">			break;</a>
<a name="ln8203">		case IWN_FW_TLV_INIT_DATA:</a>
<a name="ln8204">			fw-&gt;init.data = ptr;</a>
<a name="ln8205">			fw-&gt;init.datasz = len;</a>
<a name="ln8206">			break;</a>
<a name="ln8207">		case IWN_FW_TLV_BOOT_TEXT:</a>
<a name="ln8208">			fw-&gt;boot.text = ptr;</a>
<a name="ln8209">			fw-&gt;boot.textsz = len;</a>
<a name="ln8210">			break;</a>
<a name="ln8211">		case IWN_FW_TLV_ENH_SENS:</a>
<a name="ln8212">			if (!len)</a>
<a name="ln8213">				sc-&gt;sc_flags |= IWN_FLAG_ENH_SENS;</a>
<a name="ln8214">			break;</a>
<a name="ln8215">		case IWN_FW_TLV_PHY_CALIB:</a>
<a name="ln8216">			tmp = le32toh(*ptr);</a>
<a name="ln8217">			if (tmp &lt; 253) {</a>
<a name="ln8218">				sc-&gt;reset_noise_gain = tmp;</a>
<a name="ln8219">				sc-&gt;noise_gain = tmp + 1;</a>
<a name="ln8220">			}</a>
<a name="ln8221">			break;</a>
<a name="ln8222">		case IWN_FW_TLV_PAN:</a>
<a name="ln8223">			sc-&gt;sc_flags |= IWN_FLAG_PAN_SUPPORT;</a>
<a name="ln8224">			DPRINTF(sc, IWN_DEBUG_RESET,</a>
<a name="ln8225">			    &quot;PAN Support found: %d\n&quot;, 1);</a>
<a name="ln8226">			break;</a>
<a name="ln8227">		case IWN_FW_TLV_FLAGS:</a>
<a name="ln8228">			if (len &lt; sizeof(uint32_t))</a>
<a name="ln8229">				break;</a>
<a name="ln8230">			if (len % sizeof(uint32_t))</a>
<a name="ln8231">				break;</a>
<a name="ln8232">			sc-&gt;tlv_feature_flags = le32toh(*ptr);</a>
<a name="ln8233">			DPRINTF(sc, IWN_DEBUG_RESET,</a>
<a name="ln8234">			    &quot;%s: feature: 0x%08x\n&quot;,</a>
<a name="ln8235">			    __func__,</a>
<a name="ln8236">			    sc-&gt;tlv_feature_flags);</a>
<a name="ln8237">			break;</a>
<a name="ln8238">		case IWN_FW_TLV_PBREQ_MAXLEN:</a>
<a name="ln8239">		case IWN_FW_TLV_RUNT_EVTLOG_PTR:</a>
<a name="ln8240">		case IWN_FW_TLV_RUNT_EVTLOG_SIZE:</a>
<a name="ln8241">		case IWN_FW_TLV_RUNT_ERRLOG_PTR:</a>
<a name="ln8242">		case IWN_FW_TLV_INIT_EVTLOG_PTR:</a>
<a name="ln8243">		case IWN_FW_TLV_INIT_EVTLOG_SIZE:</a>
<a name="ln8244">		case IWN_FW_TLV_INIT_ERRLOG_PTR:</a>
<a name="ln8245">		case IWN_FW_TLV_WOWLAN_INST:</a>
<a name="ln8246">		case IWN_FW_TLV_WOWLAN_DATA:</a>
<a name="ln8247">			DPRINTF(sc, IWN_DEBUG_RESET,</a>
<a name="ln8248">			    &quot;TLV type %d recognized but not handled\n&quot;,</a>
<a name="ln8249">			    le16toh(tlv-&gt;type));</a>
<a name="ln8250">			break;</a>
<a name="ln8251">		default:</a>
<a name="ln8252">			DPRINTF(sc, IWN_DEBUG_RESET,</a>
<a name="ln8253">			    &quot;TLV type %d not handled\n&quot;, le16toh(tlv-&gt;type));</a>
<a name="ln8254">			break;</a>
<a name="ln8255">		}</a>
<a name="ln8256"> next:		/* TLV fields are 32-bit aligned. */</a>
<a name="ln8257">		ptr += (len + 3) &amp; ~3;</a>
<a name="ln8258">	}</a>
<a name="ln8259">	return 0;</a>
<a name="ln8260">}</a>
<a name="ln8261"> </a>
<a name="ln8262">static int</a>
<a name="ln8263">iwn_read_firmware(struct iwn_softc *sc)</a>
<a name="ln8264">{</a>
<a name="ln8265">	struct iwn_fw_info *fw = &amp;sc-&gt;fw;</a>
<a name="ln8266">	int error;</a>
<a name="ln8267"> </a>
<a name="ln8268">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln8269"> </a>
<a name="ln8270">	IWN_UNLOCK(sc);</a>
<a name="ln8271"> </a>
<a name="ln8272">	memset(fw, 0, sizeof (*fw));</a>
<a name="ln8273"> </a>
<a name="ln8274">	/* Read firmware image from filesystem. */</a>
<a name="ln8275">	sc-&gt;fw_fp = firmware_get(sc-&gt;fwname);</a>
<a name="ln8276">	if (sc-&gt;fw_fp == NULL) {</a>
<a name="ln8277">		device_printf(sc-&gt;sc_dev, &quot;%s: could not read firmware %s\n&quot;,</a>
<a name="ln8278">		    __func__, sc-&gt;fwname);</a>
<a name="ln8279">		IWN_LOCK(sc);</a>
<a name="ln8280">		return EINVAL;</a>
<a name="ln8281">	}</a>
<a name="ln8282">	IWN_LOCK(sc);</a>
<a name="ln8283"> </a>
<a name="ln8284">	fw-&gt;size = sc-&gt;fw_fp-&gt;datasize;</a>
<a name="ln8285">	fw-&gt;data = (const uint8_t *)sc-&gt;fw_fp-&gt;data;</a>
<a name="ln8286">	if (fw-&gt;size &lt; sizeof (uint32_t)) {</a>
<a name="ln8287">		device_printf(sc-&gt;sc_dev, &quot;%s: firmware too short: %zu bytes\n&quot;,</a>
<a name="ln8288">		    __func__, fw-&gt;size);</a>
<a name="ln8289">		error = EINVAL;</a>
<a name="ln8290">		goto fail;</a>
<a name="ln8291">	}</a>
<a name="ln8292"> </a>
<a name="ln8293">	/* Retrieve text and data sections. */</a>
<a name="ln8294">	if (*(const uint32_t *)fw-&gt;data != 0)	/* Legacy image. */</a>
<a name="ln8295">		error = iwn_read_firmware_leg(sc, fw);</a>
<a name="ln8296">	else</a>
<a name="ln8297">		error = iwn_read_firmware_tlv(sc, fw, 1);</a>
<a name="ln8298">	if (error != 0) {</a>
<a name="ln8299">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln8300">		    &quot;%s: could not read firmware sections, error %d\n&quot;,</a>
<a name="ln8301">		    __func__, error);</a>
<a name="ln8302">		goto fail;</a>
<a name="ln8303">	}</a>
<a name="ln8304"> </a>
<a name="ln8305">	device_printf(sc-&gt;sc_dev, &quot;%s: ucode rev=0x%08x\n&quot;, __func__, sc-&gt;ucode_rev);</a>
<a name="ln8306"> </a>
<a name="ln8307">	/* Make sure text and data sections fit in hardware memory. */</a>
<a name="ln8308">	if (fw-&gt;main.textsz &gt; sc-&gt;fw_text_maxsz ||</a>
<a name="ln8309">	    fw-&gt;main.datasz &gt; sc-&gt;fw_data_maxsz ||</a>
<a name="ln8310">	    fw-&gt;init.textsz &gt; sc-&gt;fw_text_maxsz ||</a>
<a name="ln8311">	    fw-&gt;init.datasz &gt; sc-&gt;fw_data_maxsz ||</a>
<a name="ln8312">	    fw-&gt;boot.textsz &gt; IWN_FW_BOOT_TEXT_MAXSZ ||</a>
<a name="ln8313">	    (fw-&gt;boot.textsz &amp; 3) != 0) {</a>
<a name="ln8314">		device_printf(sc-&gt;sc_dev, &quot;%s: firmware sections too large\n&quot;,</a>
<a name="ln8315">		    __func__);</a>
<a name="ln8316">		error = EINVAL;</a>
<a name="ln8317">		goto fail;</a>
<a name="ln8318">	}</a>
<a name="ln8319"> </a>
<a name="ln8320">	/* We can proceed with loading the firmware. */</a>
<a name="ln8321">	return 0;</a>
<a name="ln8322"> </a>
<a name="ln8323">fail:	iwn_unload_firmware(sc);</a>
<a name="ln8324">	return error;</a>
<a name="ln8325">}</a>
<a name="ln8326"> </a>
<a name="ln8327">static void</a>
<a name="ln8328">iwn_unload_firmware(struct iwn_softc *sc)</a>
<a name="ln8329">{</a>
<a name="ln8330">	firmware_put(sc-&gt;fw_fp, FIRMWARE_UNLOAD);</a>
<a name="ln8331">	sc-&gt;fw_fp = NULL;</a>
<a name="ln8332">}</a>
<a name="ln8333"> </a>
<a name="ln8334">static int</a>
<a name="ln8335">iwn_clock_wait(struct iwn_softc *sc)</a>
<a name="ln8336">{</a>
<a name="ln8337">	int ntries;</a>
<a name="ln8338"> </a>
<a name="ln8339">	/* Set &quot;initialization complete&quot; bit. */</a>
<a name="ln8340">	IWN_SETBITS(sc, IWN_GP_CNTRL, IWN_GP_CNTRL_INIT_DONE);</a>
<a name="ln8341"> </a>
<a name="ln8342">	/* Wait for clock stabilization. */</a>
<a name="ln8343">	for (ntries = 0; ntries &lt; 2500; ntries++) {</a>
<a name="ln8344">		if (IWN_READ(sc, IWN_GP_CNTRL) &amp; IWN_GP_CNTRL_MAC_CLOCK_READY)</a>
<a name="ln8345">			return 0;</a>
<a name="ln8346">		DELAY(10);</a>
<a name="ln8347">	}</a>
<a name="ln8348">	device_printf(sc-&gt;sc_dev,</a>
<a name="ln8349">	    &quot;%s: timeout waiting for clock stabilization\n&quot;, __func__);</a>
<a name="ln8350">	return ETIMEDOUT;</a>
<a name="ln8351">}</a>
<a name="ln8352"> </a>
<a name="ln8353">static int</a>
<a name="ln8354">iwn_apm_init(struct iwn_softc *sc)</a>
<a name="ln8355">{</a>
<a name="ln8356">	uint32_t reg;</a>
<a name="ln8357">	int error;</a>
<a name="ln8358"> </a>
<a name="ln8359">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln8360"> </a>
<a name="ln8361">	/* Disable L0s exit timer (NMI bug workaround). */</a>
<a name="ln8362">	IWN_SETBITS(sc, IWN_GIO_CHICKEN, IWN_GIO_CHICKEN_DIS_L0S_TIMER);</a>
<a name="ln8363">	/* Don't wait for ICH L0s (ICH bug workaround). */</a>
<a name="ln8364">	IWN_SETBITS(sc, IWN_GIO_CHICKEN, IWN_GIO_CHICKEN_L1A_NO_L0S_RX);</a>
<a name="ln8365"> </a>
<a name="ln8366">	/* Set FH wait threshold to max (HW bug under stress workaround). */</a>
<a name="ln8367">	IWN_SETBITS(sc, IWN_DBG_HPET_MEM, 0xffff0000);</a>
<a name="ln8368"> </a>
<a name="ln8369">	/* Enable HAP INTA to move adapter from L1a to L0s. */</a>
<a name="ln8370">	IWN_SETBITS(sc, IWN_HW_IF_CONFIG, IWN_HW_IF_CONFIG_HAP_WAKE_L1A);</a>
<a name="ln8371"> </a>
<a name="ln8372">	/* Retrieve PCIe Active State Power Management (ASPM). */</a>
<a name="ln8373">	reg = pci_read_config(sc-&gt;sc_dev, sc-&gt;sc_cap_off + PCIER_LINK_CTL, 4);</a>
<a name="ln8374">	/* Workaround for HW instability in PCIe L0-&gt;L0s-&gt;L1 transition. */</a>
<a name="ln8375">	if (reg &amp; PCIEM_LINK_CTL_ASPMC_L1)	/* L1 Entry enabled. */</a>
<a name="ln8376">		IWN_SETBITS(sc, IWN_GIO, IWN_GIO_L0S_ENA);</a>
<a name="ln8377">	else</a>
<a name="ln8378">		IWN_CLRBITS(sc, IWN_GIO, IWN_GIO_L0S_ENA);</a>
<a name="ln8379"> </a>
<a name="ln8380">	if (sc-&gt;base_params-&gt;pll_cfg_val)</a>
<a name="ln8381">		IWN_SETBITS(sc, IWN_ANA_PLL, sc-&gt;base_params-&gt;pll_cfg_val);</a>
<a name="ln8382"> </a>
<a name="ln8383">	/* Wait for clock stabilization before accessing prph. */</a>
<a name="ln8384">	if ((error = iwn_clock_wait(sc)) != 0)</a>
<a name="ln8385">		return error;</a>
<a name="ln8386"> </a>
<a name="ln8387">	if ((error = iwn_nic_lock(sc)) != 0)</a>
<a name="ln8388">		return error;</a>
<a name="ln8389">	if (sc-&gt;hw_type == IWN_HW_REV_TYPE_4965) {</a>
<a name="ln8390">		/* Enable DMA and BSM (Bootstrap State Machine). */</a>
<a name="ln8391">		iwn_prph_write(sc, IWN_APMG_CLK_EN,</a>
<a name="ln8392">		    IWN_APMG_CLK_CTRL_DMA_CLK_RQT |</a>
<a name="ln8393">		    IWN_APMG_CLK_CTRL_BSM_CLK_RQT);</a>
<a name="ln8394">	} else {</a>
<a name="ln8395">		/* Enable DMA. */</a>
<a name="ln8396">		iwn_prph_write(sc, IWN_APMG_CLK_EN,</a>
<a name="ln8397">		    IWN_APMG_CLK_CTRL_DMA_CLK_RQT);</a>
<a name="ln8398">	}</a>
<a name="ln8399">	DELAY(20);</a>
<a name="ln8400">	/* Disable L1-Active. */</a>
<a name="ln8401">	iwn_prph_setbits(sc, IWN_APMG_PCI_STT, IWN_APMG_PCI_STT_L1A_DIS);</a>
<a name="ln8402">	iwn_nic_unlock(sc);</a>
<a name="ln8403"> </a>
<a name="ln8404">	return 0;</a>
<a name="ln8405">}</a>
<a name="ln8406"> </a>
<a name="ln8407">static void</a>
<a name="ln8408">iwn_apm_stop_master(struct iwn_softc *sc)</a>
<a name="ln8409">{</a>
<a name="ln8410">	int ntries;</a>
<a name="ln8411"> </a>
<a name="ln8412">	/* Stop busmaster DMA activity. */</a>
<a name="ln8413">	IWN_SETBITS(sc, IWN_RESET, IWN_RESET_STOP_MASTER);</a>
<a name="ln8414">	for (ntries = 0; ntries &lt; 100; ntries++) {</a>
<a name="ln8415">		if (IWN_READ(sc, IWN_RESET) &amp; IWN_RESET_MASTER_DISABLED)</a>
<a name="ln8416">			return;</a>
<a name="ln8417">		DELAY(10);</a>
<a name="ln8418">	}</a>
<a name="ln8419">	device_printf(sc-&gt;sc_dev, &quot;%s: timeout waiting for master\n&quot;, __func__);</a>
<a name="ln8420">}</a>
<a name="ln8421"> </a>
<a name="ln8422">static void</a>
<a name="ln8423">iwn_apm_stop(struct iwn_softc *sc)</a>
<a name="ln8424">{</a>
<a name="ln8425">	iwn_apm_stop_master(sc);</a>
<a name="ln8426"> </a>
<a name="ln8427">	/* Reset the entire device. */</a>
<a name="ln8428">	IWN_SETBITS(sc, IWN_RESET, IWN_RESET_SW);</a>
<a name="ln8429">	DELAY(10);</a>
<a name="ln8430">	/* Clear &quot;initialization complete&quot; bit. */</a>
<a name="ln8431">	IWN_CLRBITS(sc, IWN_GP_CNTRL, IWN_GP_CNTRL_INIT_DONE);</a>
<a name="ln8432">}</a>
<a name="ln8433"> </a>
<a name="ln8434">static int</a>
<a name="ln8435">iwn4965_nic_config(struct iwn_softc *sc)</a>
<a name="ln8436">{</a>
<a name="ln8437">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln8438"> </a>
<a name="ln8439">	if (IWN_RFCFG_TYPE(sc-&gt;rfcfg) == 1) {</a>
<a name="ln8440">		/*</a>
<a name="ln8441">		 * I don't believe this to be correct but this is what the</a>
<a name="ln8442">		 * vendor driver is doing. Probably the bits should not be</a>
<a name="ln8443">		 * shifted in IWN_RFCFG_*.</a>
<a name="ln8444">		 */</a>
<a name="ln8445">		IWN_SETBITS(sc, IWN_HW_IF_CONFIG,</a>
<a name="ln8446">		    IWN_RFCFG_TYPE(sc-&gt;rfcfg) |</a>
<a name="ln8447">		    IWN_RFCFG_STEP(sc-&gt;rfcfg) |</a>
<a name="ln8448">		    IWN_RFCFG_DASH(sc-&gt;rfcfg));</a>
<a name="ln8449">	}</a>
<a name="ln8450">	IWN_SETBITS(sc, IWN_HW_IF_CONFIG,</a>
<a name="ln8451">	    IWN_HW_IF_CONFIG_RADIO_SI | IWN_HW_IF_CONFIG_MAC_SI);</a>
<a name="ln8452">	return 0;</a>
<a name="ln8453">}</a>
<a name="ln8454"> </a>
<a name="ln8455">static int</a>
<a name="ln8456">iwn5000_nic_config(struct iwn_softc *sc)</a>
<a name="ln8457">{</a>
<a name="ln8458">	uint32_t tmp;</a>
<a name="ln8459">	int error;</a>
<a name="ln8460"> </a>
<a name="ln8461">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln8462"> </a>
<a name="ln8463">	if (IWN_RFCFG_TYPE(sc-&gt;rfcfg) &lt; 3) {</a>
<a name="ln8464">		IWN_SETBITS(sc, IWN_HW_IF_CONFIG,</a>
<a name="ln8465">		    IWN_RFCFG_TYPE(sc-&gt;rfcfg) |</a>
<a name="ln8466">		    IWN_RFCFG_STEP(sc-&gt;rfcfg) |</a>
<a name="ln8467">		    IWN_RFCFG_DASH(sc-&gt;rfcfg));</a>
<a name="ln8468">	}</a>
<a name="ln8469">	IWN_SETBITS(sc, IWN_HW_IF_CONFIG,</a>
<a name="ln8470">	    IWN_HW_IF_CONFIG_RADIO_SI | IWN_HW_IF_CONFIG_MAC_SI);</a>
<a name="ln8471"> </a>
<a name="ln8472">	if ((error = iwn_nic_lock(sc)) != 0)</a>
<a name="ln8473">		return error;</a>
<a name="ln8474">	iwn_prph_setbits(sc, IWN_APMG_PS, IWN_APMG_PS_EARLY_PWROFF_DIS);</a>
<a name="ln8475"> </a>
<a name="ln8476">	if (sc-&gt;hw_type == IWN_HW_REV_TYPE_1000) {</a>
<a name="ln8477">		/*</a>
<a name="ln8478">		 * Select first Switching Voltage Regulator (1.32V) to</a>
<a name="ln8479">		 * solve a stability issue related to noisy DC2DC line</a>
<a name="ln8480">		 * in the silicon of 1000 Series.</a>
<a name="ln8481">		 */</a>
<a name="ln8482">		tmp = iwn_prph_read(sc, IWN_APMG_DIGITAL_SVR);</a>
<a name="ln8483">		tmp &amp;= ~IWN_APMG_DIGITAL_SVR_VOLTAGE_MASK;</a>
<a name="ln8484">		tmp |= IWN_APMG_DIGITAL_SVR_VOLTAGE_1_32;</a>
<a name="ln8485">		iwn_prph_write(sc, IWN_APMG_DIGITAL_SVR, tmp);</a>
<a name="ln8486">	}</a>
<a name="ln8487">	iwn_nic_unlock(sc);</a>
<a name="ln8488"> </a>
<a name="ln8489">	if (sc-&gt;sc_flags &amp; IWN_FLAG_INTERNAL_PA) {</a>
<a name="ln8490">		/* Use internal power amplifier only. */</a>
<a name="ln8491">		IWN_WRITE(sc, IWN_GP_DRIVER, IWN_GP_DRIVER_RADIO_2X2_IPA);</a>
<a name="ln8492">	}</a>
<a name="ln8493">	if (sc-&gt;base_params-&gt;additional_nic_config &amp;&amp; sc-&gt;calib_ver &gt;= 6) {</a>
<a name="ln8494">		/* Indicate that ROM calibration version is &gt;=6. */</a>
<a name="ln8495">		IWN_SETBITS(sc, IWN_GP_DRIVER, IWN_GP_DRIVER_CALIB_VER6);</a>
<a name="ln8496">	}</a>
<a name="ln8497">	if (sc-&gt;base_params-&gt;additional_gp_drv_bit)</a>
<a name="ln8498">		IWN_SETBITS(sc, IWN_GP_DRIVER,</a>
<a name="ln8499">		    sc-&gt;base_params-&gt;additional_gp_drv_bit);</a>
<a name="ln8500">	return 0;</a>
<a name="ln8501">}</a>
<a name="ln8502"> </a>
<a name="ln8503">/*</a>
<a name="ln8504"> * Take NIC ownership over Intel Active Management Technology (AMT).</a>
<a name="ln8505"> */</a>
<a name="ln8506">static int</a>
<a name="ln8507">iwn_hw_prepare(struct iwn_softc *sc)</a>
<a name="ln8508">{</a>
<a name="ln8509">	int ntries;</a>
<a name="ln8510"> </a>
<a name="ln8511">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln8512"> </a>
<a name="ln8513">	/* Check if hardware is ready. */</a>
<a name="ln8514">	IWN_SETBITS(sc, IWN_HW_IF_CONFIG, IWN_HW_IF_CONFIG_NIC_READY);</a>
<a name="ln8515">	for (ntries = 0; ntries &lt; 5; ntries++) {</a>
<a name="ln8516">		if (IWN_READ(sc, IWN_HW_IF_CONFIG) &amp;</a>
<a name="ln8517">		    IWN_HW_IF_CONFIG_NIC_READY)</a>
<a name="ln8518">			return 0;</a>
<a name="ln8519">		DELAY(10);</a>
<a name="ln8520">	}</a>
<a name="ln8521"> </a>
<a name="ln8522">	/* Hardware not ready, force into ready state. */</a>
<a name="ln8523">	IWN_SETBITS(sc, IWN_HW_IF_CONFIG, IWN_HW_IF_CONFIG_PREPARE);</a>
<a name="ln8524">	for (ntries = 0; ntries &lt; 15000; ntries++) {</a>
<a name="ln8525">		if (!(IWN_READ(sc, IWN_HW_IF_CONFIG) &amp;</a>
<a name="ln8526">		    IWN_HW_IF_CONFIG_PREPARE_DONE))</a>
<a name="ln8527">			break;</a>
<a name="ln8528">		DELAY(10);</a>
<a name="ln8529">	}</a>
<a name="ln8530">	if (ntries == 15000)</a>
<a name="ln8531">		return ETIMEDOUT;</a>
<a name="ln8532"> </a>
<a name="ln8533">	/* Hardware should be ready now. */</a>
<a name="ln8534">	IWN_SETBITS(sc, IWN_HW_IF_CONFIG, IWN_HW_IF_CONFIG_NIC_READY);</a>
<a name="ln8535">	for (ntries = 0; ntries &lt; 5; ntries++) {</a>
<a name="ln8536">		if (IWN_READ(sc, IWN_HW_IF_CONFIG) &amp;</a>
<a name="ln8537">		    IWN_HW_IF_CONFIG_NIC_READY)</a>
<a name="ln8538">			return 0;</a>
<a name="ln8539">		DELAY(10);</a>
<a name="ln8540">	}</a>
<a name="ln8541">	return ETIMEDOUT;</a>
<a name="ln8542">}</a>
<a name="ln8543"> </a>
<a name="ln8544">static int</a>
<a name="ln8545">iwn_hw_init(struct iwn_softc *sc)</a>
<a name="ln8546">{</a>
<a name="ln8547">	struct iwn_ops *ops = &amp;sc-&gt;ops;</a>
<a name="ln8548">	int error, chnl, qid;</a>
<a name="ln8549"> </a>
<a name="ln8550">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln8551"> </a>
<a name="ln8552">	/* Clear pending interrupts. */</a>
<a name="ln8553">	IWN_WRITE(sc, IWN_INT, 0xffffffff);</a>
<a name="ln8554"> </a>
<a name="ln8555">	if ((error = iwn_apm_init(sc)) != 0) {</a>
<a name="ln8556">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln8557">		    &quot;%s: could not power ON adapter, error %d\n&quot;, __func__,</a>
<a name="ln8558">		    error);</a>
<a name="ln8559">		return error;</a>
<a name="ln8560">	}</a>
<a name="ln8561"> </a>
<a name="ln8562">	/* Select VMAIN power source. */</a>
<a name="ln8563">	if ((error = iwn_nic_lock(sc)) != 0)</a>
<a name="ln8564">		return error;</a>
<a name="ln8565">	iwn_prph_clrbits(sc, IWN_APMG_PS, IWN_APMG_PS_PWR_SRC_MASK);</a>
<a name="ln8566">	iwn_nic_unlock(sc);</a>
<a name="ln8567"> </a>
<a name="ln8568">	/* Perform adapter-specific initialization. */</a>
<a name="ln8569">	if ((error = ops-&gt;nic_config(sc)) != 0)</a>
<a name="ln8570">		return error;</a>
<a name="ln8571"> </a>
<a name="ln8572">	/* Initialize RX ring. */</a>
<a name="ln8573">	if ((error = iwn_nic_lock(sc)) != 0)</a>
<a name="ln8574">		return error;</a>
<a name="ln8575">	IWN_WRITE(sc, IWN_FH_RX_CONFIG, 0);</a>
<a name="ln8576">	IWN_WRITE(sc, IWN_FH_RX_WPTR, 0);</a>
<a name="ln8577">	/* Set physical address of RX ring (256-byte aligned). */</a>
<a name="ln8578">	IWN_WRITE(sc, IWN_FH_RX_BASE, sc-&gt;rxq.desc_dma.paddr &gt;&gt; 8);</a>
<a name="ln8579">	/* Set physical address of RX status (16-byte aligned). */</a>
<a name="ln8580">	IWN_WRITE(sc, IWN_FH_STATUS_WPTR, sc-&gt;rxq.stat_dma.paddr &gt;&gt; 4);</a>
<a name="ln8581">	/* Enable RX. */</a>
<a name="ln8582">	IWN_WRITE(sc, IWN_FH_RX_CONFIG,</a>
<a name="ln8583">	    IWN_FH_RX_CONFIG_ENA           |</a>
<a name="ln8584">	    IWN_FH_RX_CONFIG_IGN_RXF_EMPTY |	/* HW bug workaround */</a>
<a name="ln8585">	    IWN_FH_RX_CONFIG_IRQ_DST_HOST  |</a>
<a name="ln8586">	    IWN_FH_RX_CONFIG_SINGLE_FRAME  |</a>
<a name="ln8587">	    IWN_FH_RX_CONFIG_RB_TIMEOUT(0) |</a>
<a name="ln8588">	    IWN_FH_RX_CONFIG_NRBD(IWN_RX_RING_COUNT_LOG));</a>
<a name="ln8589">	iwn_nic_unlock(sc);</a>
<a name="ln8590">	IWN_WRITE(sc, IWN_FH_RX_WPTR, (IWN_RX_RING_COUNT - 1) &amp; ~7);</a>
<a name="ln8591"> </a>
<a name="ln8592">	if ((error = iwn_nic_lock(sc)) != 0)</a>
<a name="ln8593">		return error;</a>
<a name="ln8594"> </a>
<a name="ln8595">	/* Initialize TX scheduler. */</a>
<a name="ln8596">	iwn_prph_write(sc, sc-&gt;sched_txfact_addr, 0);</a>
<a name="ln8597"> </a>
<a name="ln8598">	/* Set physical address of &quot;keep warm&quot; page (16-byte aligned). */</a>
<a name="ln8599">	IWN_WRITE(sc, IWN_FH_KW_ADDR, sc-&gt;kw_dma.paddr &gt;&gt; 4);</a>
<a name="ln8600"> </a>
<a name="ln8601">	/* Initialize TX rings. */</a>
<a name="ln8602">	for (qid = 0; qid &lt; sc-&gt;ntxqs; qid++) {</a>
<a name="ln8603">		struct iwn_tx_ring *txq = &amp;sc-&gt;txq[qid];</a>
<a name="ln8604"> </a>
<a name="ln8605">		/* Set physical address of TX ring (256-byte aligned). */</a>
<a name="ln8606">		IWN_WRITE(sc, IWN_FH_CBBC_QUEUE(qid),</a>
<a name="ln8607">		    txq-&gt;desc_dma.paddr &gt;&gt; 8);</a>
<a name="ln8608">	}</a>
<a name="ln8609">	iwn_nic_unlock(sc);</a>
<a name="ln8610"> </a>
<a name="ln8611">	/* Enable DMA channels. */</a>
<a name="ln8612">	for (chnl = 0; chnl &lt; sc-&gt;ndmachnls; chnl++) {</a>
<a name="ln8613">		IWN_WRITE(sc, IWN_FH_TX_CONFIG(chnl),</a>
<a name="ln8614">		    IWN_FH_TX_CONFIG_DMA_ENA |</a>
<a name="ln8615">		    IWN_FH_TX_CONFIG_DMA_CREDIT_ENA);</a>
<a name="ln8616">	}</a>
<a name="ln8617"> </a>
<a name="ln8618">	/* Clear &quot;radio off&quot; and &quot;commands blocked&quot; bits. */</a>
<a name="ln8619">	IWN_WRITE(sc, IWN_UCODE_GP1_CLR, IWN_UCODE_GP1_RFKILL);</a>
<a name="ln8620">	IWN_WRITE(sc, IWN_UCODE_GP1_CLR, IWN_UCODE_GP1_CMD_BLOCKED);</a>
<a name="ln8621"> </a>
<a name="ln8622">	/* Clear pending interrupts. */</a>
<a name="ln8623">	IWN_WRITE(sc, IWN_INT, 0xffffffff);</a>
<a name="ln8624">	/* Enable interrupt coalescing. */</a>
<a name="ln8625">	IWN_WRITE(sc, IWN_INT_COALESCING, 512 / 8);</a>
<a name="ln8626">	/* Enable interrupts. */</a>
<a name="ln8627">	IWN_WRITE(sc, IWN_INT_MASK, sc-&gt;int_mask);</a>
<a name="ln8628"> </a>
<a name="ln8629">	/* _Really_ make sure &quot;radio off&quot; bit is cleared! */</a>
<a name="ln8630">	IWN_WRITE(sc, IWN_UCODE_GP1_CLR, IWN_UCODE_GP1_RFKILL);</a>
<a name="ln8631">	IWN_WRITE(sc, IWN_UCODE_GP1_CLR, IWN_UCODE_GP1_RFKILL);</a>
<a name="ln8632"> </a>
<a name="ln8633">	/* Enable shadow registers. */</a>
<a name="ln8634">	if (sc-&gt;base_params-&gt;shadow_reg_enable)</a>
<a name="ln8635">		IWN_SETBITS(sc, IWN_SHADOW_REG_CTRL, 0x800fffff);</a>
<a name="ln8636"> </a>
<a name="ln8637">	if ((error = ops-&gt;load_firmware(sc)) != 0) {</a>
<a name="ln8638">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln8639">		    &quot;%s: could not load firmware, error %d\n&quot;, __func__,</a>
<a name="ln8640">		    error);</a>
<a name="ln8641">		return error;</a>
<a name="ln8642">	}</a>
<a name="ln8643">	/* Wait at most one second for firmware alive notification. */</a>
<a name="ln8644">	if ((error = msleep(sc, &amp;sc-&gt;sc_mtx, PCATCH, &quot;iwninit&quot;, hz)) != 0) {</a>
<a name="ln8645">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln8646">		    &quot;%s: timeout waiting for adapter to initialize, error %d\n&quot;,</a>
<a name="ln8647">		    __func__, error);</a>
<a name="ln8648">		return error;</a>
<a name="ln8649">	}</a>
<a name="ln8650">	/* Do post-firmware initialization. */</a>
<a name="ln8651"> </a>
<a name="ln8652">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: end\n&quot;,__func__);</a>
<a name="ln8653"> </a>
<a name="ln8654">	return ops-&gt;post_alive(sc);</a>
<a name="ln8655">}</a>
<a name="ln8656"> </a>
<a name="ln8657">static void</a>
<a name="ln8658">iwn_hw_stop(struct iwn_softc *sc)</a>
<a name="ln8659">{</a>
<a name="ln8660">	int chnl, qid, ntries;</a>
<a name="ln8661"> </a>
<a name="ln8662">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln8663"> </a>
<a name="ln8664">	IWN_WRITE(sc, IWN_RESET, IWN_RESET_NEVO);</a>
<a name="ln8665"> </a>
<a name="ln8666">	/* Disable interrupts. */</a>
<a name="ln8667">	IWN_WRITE(sc, IWN_INT_MASK, 0);</a>
<a name="ln8668">	IWN_WRITE(sc, IWN_INT, 0xffffffff);</a>
<a name="ln8669">	IWN_WRITE(sc, IWN_FH_INT, 0xffffffff);</a>
<a name="ln8670">	sc-&gt;sc_flags &amp;= ~IWN_FLAG_USE_ICT;</a>
<a name="ln8671"> </a>
<a name="ln8672">	/* Make sure we no longer hold the NIC lock. */</a>
<a name="ln8673">	iwn_nic_unlock(sc);</a>
<a name="ln8674"> </a>
<a name="ln8675">	/* Stop TX scheduler. */</a>
<a name="ln8676">	iwn_prph_write(sc, sc-&gt;sched_txfact_addr, 0);</a>
<a name="ln8677"> </a>
<a name="ln8678">	/* Stop all DMA channels. */</a>
<a name="ln8679">	if (iwn_nic_lock(sc) == 0) {</a>
<a name="ln8680">		for (chnl = 0; chnl &lt; sc-&gt;ndmachnls; chnl++) {</a>
<a name="ln8681">			IWN_WRITE(sc, IWN_FH_TX_CONFIG(chnl), 0);</a>
<a name="ln8682">			for (ntries = 0; ntries &lt; 200; ntries++) {</a>
<a name="ln8683">				if (IWN_READ(sc, IWN_FH_TX_STATUS) &amp;</a>
<a name="ln8684">				    IWN_FH_TX_STATUS_IDLE(chnl))</a>
<a name="ln8685">					break;</a>
<a name="ln8686">				DELAY(10);</a>
<a name="ln8687">			}</a>
<a name="ln8688">		}</a>
<a name="ln8689">		iwn_nic_unlock(sc);</a>
<a name="ln8690">	}</a>
<a name="ln8691"> </a>
<a name="ln8692">	/* Stop RX ring. */</a>
<a name="ln8693">	iwn_reset_rx_ring(sc, &amp;sc-&gt;rxq);</a>
<a name="ln8694"> </a>
<a name="ln8695">	/* Reset all TX rings. */</a>
<a name="ln8696">	for (qid = 0; qid &lt; sc-&gt;ntxqs; qid++)</a>
<a name="ln8697">		iwn_reset_tx_ring(sc, &amp;sc-&gt;txq[qid]);</a>
<a name="ln8698"> </a>
<a name="ln8699">	if (iwn_nic_lock(sc) == 0) {</a>
<a name="ln8700">		iwn_prph_write(sc, IWN_APMG_CLK_DIS,</a>
<a name="ln8701">		    IWN_APMG_CLK_CTRL_DMA_CLK_RQT);</a>
<a name="ln8702">		iwn_nic_unlock(sc);</a>
<a name="ln8703">	}</a>
<a name="ln8704">	DELAY(5);</a>
<a name="ln8705">	/* Power OFF adapter. */</a>
<a name="ln8706">	iwn_apm_stop(sc);</a>
<a name="ln8707">}</a>
<a name="ln8708"> </a>
<a name="ln8709">static void</a>
<a name="ln8710">iwn_panicked(void *arg0, int pending)</a>
<a name="ln8711">{</a>
<a name="ln8712">	struct iwn_softc *sc = arg0;</a>
<a name="ln8713">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln8714">	struct ieee80211vap *vap = TAILQ_FIRST(&amp;ic-&gt;ic_vaps);</a>
<a name="ln8715">#if 0</a>
<a name="ln8716">	int error;</a>
<a name="ln8717">#endif</a>
<a name="ln8718"> </a>
<a name="ln8719">	if (vap == NULL) {</a>
<a name="ln8720">		printf(&quot;%s: null vap\n&quot;, __func__);</a>
<a name="ln8721">		return;</a>
<a name="ln8722">	}</a>
<a name="ln8723"> </a>
<a name="ln8724">	device_printf(sc-&gt;sc_dev, &quot;%s: controller panicked, iv_state = %d; &quot;</a>
<a name="ln8725">	    &quot;restarting\n&quot;, __func__, vap-&gt;iv_state);</a>
<a name="ln8726"> </a>
<a name="ln8727">	/*</a>
<a name="ln8728">	 * This is not enough work. We need to also reinitialise</a>
<a name="ln8729">	 * the correct transmit state for aggregation enabled queues,</a>
<a name="ln8730">	 * which has a very specific requirement of</a>
<a name="ln8731">	 * ring index = 802.11 seqno % 256.  If we don't do this (which</a>
<a name="ln8732">	 * we definitely don't!) then the firmware will just panic again.</a>
<a name="ln8733">	 */</a>
<a name="ln8734">#if 1</a>
<a name="ln8735">	ieee80211_restart_all(ic);</a>
<a name="ln8736">#else</a>
<a name="ln8737">	IWN_LOCK(sc);</a>
<a name="ln8738"> </a>
<a name="ln8739">	iwn_stop_locked(sc);</a>
<a name="ln8740">	if ((error = iwn_init_locked(sc)) != 0) {</a>
<a name="ln8741">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln8742">		    &quot;%s: could not init hardware\n&quot;, __func__);</a>
<a name="ln8743">		goto unlock;</a>
<a name="ln8744">	}</a>
<a name="ln8745">	if (vap-&gt;iv_state &gt;= IEEE80211_S_AUTH &amp;&amp;</a>
<a name="ln8746">	    (error = iwn_auth(sc, vap)) != 0) {</a>
<a name="ln8747">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln8748">		    &quot;%s: could not move to auth state\n&quot;, __func__);</a>
<a name="ln8749">	}</a>
<a name="ln8750">	if (vap-&gt;iv_state &gt;= IEEE80211_S_RUN &amp;&amp;</a>
<a name="ln8751">	    (error = iwn_run(sc, vap)) != 0) {</a>
<a name="ln8752">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln8753">		    &quot;%s: could not move to run state\n&quot;, __func__);</a>
<a name="ln8754">	}</a>
<a name="ln8755"> </a>
<a name="ln8756">unlock:</a>
<a name="ln8757">	IWN_UNLOCK(sc);</a>
<a name="ln8758">#endif</a>
<a name="ln8759">}</a>
<a name="ln8760"> </a>
<a name="ln8761">static int</a>
<a name="ln8762">iwn_init_locked(struct iwn_softc *sc)</a>
<a name="ln8763">{</a>
<a name="ln8764">	int error;</a>
<a name="ln8765"> </a>
<a name="ln8766">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln8767"> </a>
<a name="ln8768">	IWN_LOCK_ASSERT(sc);</a>
<a name="ln8769"> </a>
<a name="ln8770">	if (sc-&gt;sc_flags &amp; IWN_FLAG_RUNNING)</a>
<a name="ln8771">		goto end;</a>
<a name="ln8772"> </a>
<a name="ln8773">	sc-&gt;sc_flags |= IWN_FLAG_RUNNING;</a>
<a name="ln8774"> </a>
<a name="ln8775">	if ((error = iwn_hw_prepare(sc)) != 0) {</a>
<a name="ln8776">		device_printf(sc-&gt;sc_dev, &quot;%s: hardware not ready, error %d\n&quot;,</a>
<a name="ln8777">		    __func__, error);</a>
<a name="ln8778">		goto fail;</a>
<a name="ln8779">	}</a>
<a name="ln8780"> </a>
<a name="ln8781">	/* Initialize interrupt mask to default value. */</a>
<a name="ln8782">	sc-&gt;int_mask = IWN_INT_MASK_DEF;</a>
<a name="ln8783">	sc-&gt;sc_flags &amp;= ~IWN_FLAG_USE_ICT;</a>
<a name="ln8784"> </a>
<a name="ln8785">	/* Check that the radio is not disabled by hardware switch. */</a>
<a name="ln8786">	if (!(IWN_READ(sc, IWN_GP_CNTRL) &amp; IWN_GP_CNTRL_RFKILL)) {</a>
<a name="ln8787">		iwn_stop_locked(sc);</a>
<a name="ln8788">		DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: end\n&quot;,__func__);</a>
<a name="ln8789"> </a>
<a name="ln8790">		return (1);</a>
<a name="ln8791">	}</a>
<a name="ln8792"> </a>
<a name="ln8793">	/* Read firmware images from the filesystem. */</a>
<a name="ln8794">	if ((error = iwn_read_firmware(sc)) != 0) {</a>
<a name="ln8795">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln8796">		    &quot;%s: could not read firmware, error %d\n&quot;, __func__,</a>
<a name="ln8797">		    error);</a>
<a name="ln8798">		goto fail;</a>
<a name="ln8799">	}</a>
<a name="ln8800"> </a>
<a name="ln8801">	/* Initialize hardware and upload firmware. */</a>
<a name="ln8802">	error = iwn_hw_init(sc);</a>
<a name="ln8803">	iwn_unload_firmware(sc);</a>
<a name="ln8804">	if (error != 0) {</a>
<a name="ln8805">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln8806">		    &quot;%s: could not initialize hardware, error %d\n&quot;, __func__,</a>
<a name="ln8807">		    error);</a>
<a name="ln8808">		goto fail;</a>
<a name="ln8809">	}</a>
<a name="ln8810"> </a>
<a name="ln8811">	/* Configure adapter now that it is ready. */</a>
<a name="ln8812">	if ((error = iwn_config(sc)) != 0) {</a>
<a name="ln8813">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln8814">		    &quot;%s: could not configure device, error %d\n&quot;, __func__,</a>
<a name="ln8815">		    error);</a>
<a name="ln8816">		goto fail;</a>
<a name="ln8817">	}</a>
<a name="ln8818"> </a>
<a name="ln8819">	callout_reset(&amp;sc-&gt;watchdog_to, hz, iwn_watchdog, sc);</a>
<a name="ln8820"> </a>
<a name="ln8821">end:</a>
<a name="ln8822">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: end\n&quot;,__func__);</a>
<a name="ln8823"> </a>
<a name="ln8824">	return (0);</a>
<a name="ln8825"> </a>
<a name="ln8826">fail:</a>
<a name="ln8827">	iwn_stop_locked(sc);</a>
<a name="ln8828"> </a>
<a name="ln8829">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;%s: end in error\n&quot;,__func__);</a>
<a name="ln8830"> </a>
<a name="ln8831">	return (-1);</a>
<a name="ln8832">}</a>
<a name="ln8833"> </a>
<a name="ln8834">static int</a>
<a name="ln8835">iwn_init(struct iwn_softc *sc)</a>
<a name="ln8836">{</a>
<a name="ln8837">	int error;</a>
<a name="ln8838"> </a>
<a name="ln8839">	IWN_LOCK(sc);</a>
<a name="ln8840">	error = iwn_init_locked(sc);</a>
<a name="ln8841">	IWN_UNLOCK(sc);</a>
<a name="ln8842"> </a>
<a name="ln8843">	return (error);</a>
<a name="ln8844">}</a>
<a name="ln8845"> </a>
<a name="ln8846">static void</a>
<a name="ln8847">iwn_stop_locked(struct iwn_softc *sc)</a>
<a name="ln8848">{</a>
<a name="ln8849"> </a>
<a name="ln8850">	IWN_LOCK_ASSERT(sc);</a>
<a name="ln8851"> </a>
<a name="ln8852">	if (!(sc-&gt;sc_flags &amp; IWN_FLAG_RUNNING))</a>
<a name="ln8853">		return;</a>
<a name="ln8854"> </a>
<a name="ln8855">	sc-&gt;sc_is_scanning = 0;</a>
<a name="ln8856">	sc-&gt;sc_tx_timer = 0;</a>
<a name="ln8857">	callout_stop(&amp;sc-&gt;watchdog_to);</a>
<a name="ln8858">	callout_stop(&amp;sc-&gt;scan_timeout);</a>
<a name="ln8859">	callout_stop(&amp;sc-&gt;calib_to);</a>
<a name="ln8860">	sc-&gt;sc_flags &amp;= ~IWN_FLAG_RUNNING;</a>
<a name="ln8861"> </a>
<a name="ln8862">	/* Power OFF hardware. */</a>
<a name="ln8863">	iwn_hw_stop(sc);</a>
<a name="ln8864">}</a>
<a name="ln8865"> </a>
<a name="ln8866">static void</a>
<a name="ln8867">iwn_stop(struct iwn_softc *sc)</a>
<a name="ln8868">{</a>
<a name="ln8869">	IWN_LOCK(sc);</a>
<a name="ln8870">	iwn_stop_locked(sc);</a>
<a name="ln8871">	IWN_UNLOCK(sc);</a>
<a name="ln8872">}</a>
<a name="ln8873"> </a>
<a name="ln8874">/*</a>
<a name="ln8875"> * Callback from net80211 to start a scan.</a>
<a name="ln8876"> */</a>
<a name="ln8877">static void</a>
<a name="ln8878">iwn_scan_start(struct ieee80211com *ic)</a>
<a name="ln8879">{</a>
<a name="ln8880">	struct iwn_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln8881"> </a>
<a name="ln8882">	IWN_LOCK(sc);</a>
<a name="ln8883">	/* make the link LED blink while we're scanning */</a>
<a name="ln8884">	iwn_set_led(sc, IWN_LED_LINK, 20, 2);</a>
<a name="ln8885">	IWN_UNLOCK(sc);</a>
<a name="ln8886">}</a>
<a name="ln8887"> </a>
<a name="ln8888">/*</a>
<a name="ln8889"> * Callback from net80211 to terminate a scan.</a>
<a name="ln8890"> */</a>
<a name="ln8891">static void</a>
<a name="ln8892">iwn_scan_end(struct ieee80211com *ic)</a>
<a name="ln8893">{</a>
<a name="ln8894">	struct iwn_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln8895">	struct ieee80211vap *vap = TAILQ_FIRST(&amp;ic-&gt;ic_vaps);</a>
<a name="ln8896"> </a>
<a name="ln8897">	IWN_LOCK(sc);</a>
<a name="ln8898">	if (vap-&gt;iv_state == IEEE80211_S_RUN) {</a>
<a name="ln8899">		/* Set link LED to ON status if we are associated */</a>
<a name="ln8900">		iwn_set_led(sc, IWN_LED_LINK, 0, 1);</a>
<a name="ln8901">	}</a>
<a name="ln8902">	IWN_UNLOCK(sc);</a>
<a name="ln8903">}</a>
<a name="ln8904"> </a>
<a name="ln8905">/*</a>
<a name="ln8906"> * Callback from net80211 to force a channel change.</a>
<a name="ln8907"> */</a>
<a name="ln8908">static void</a>
<a name="ln8909">iwn_set_channel(struct ieee80211com *ic)</a>
<a name="ln8910">{</a>
<a name="ln8911">	const struct ieee80211_channel *c = ic-&gt;ic_curchan;</a>
<a name="ln8912">	struct iwn_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln8913">	int error;</a>
<a name="ln8914"> </a>
<a name="ln8915">	DPRINTF(sc, IWN_DEBUG_TRACE, &quot;-&gt;Doing %s\n&quot;, __func__);</a>
<a name="ln8916"> </a>
<a name="ln8917">	IWN_LOCK(sc);</a>
<a name="ln8918">	sc-&gt;sc_rxtap.wr_chan_freq = htole16(c-&gt;ic_freq);</a>
<a name="ln8919">	sc-&gt;sc_rxtap.wr_chan_flags = htole16(c-&gt;ic_flags);</a>
<a name="ln8920">	sc-&gt;sc_txtap.wt_chan_freq = htole16(c-&gt;ic_freq);</a>
<a name="ln8921">	sc-&gt;sc_txtap.wt_chan_flags = htole16(c-&gt;ic_flags);</a>
<a name="ln8922"> </a>
<a name="ln8923">	/*</a>
<a name="ln8924">	 * Only need to set the channel in Monitor mode. AP scanning and auth</a>
<a name="ln8925">	 * are already taken care of by their respective firmware commands.</a>
<a name="ln8926">	 */</a>
<a name="ln8927">	if (ic-&gt;ic_opmode == IEEE80211_M_MONITOR) {</a>
<a name="ln8928">		error = iwn_config(sc);</a>
<a name="ln8929">		if (error != 0)</a>
<a name="ln8930">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln8931">		    &quot;%s: error %d settting channel\n&quot;, __func__, error);</a>
<a name="ln8932">	}</a>
<a name="ln8933">	IWN_UNLOCK(sc);</a>
<a name="ln8934">}</a>
<a name="ln8935"> </a>
<a name="ln8936">/*</a>
<a name="ln8937"> * Callback from net80211 to start scanning of the current channel.</a>
<a name="ln8938"> */</a>
<a name="ln8939">static void</a>
<a name="ln8940">iwn_scan_curchan(struct ieee80211_scan_state *ss, unsigned long maxdwell)</a>
<a name="ln8941">{</a>
<a name="ln8942">	struct ieee80211vap *vap = ss-&gt;ss_vap;</a>
<a name="ln8943">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln8944">	struct iwn_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln8945">	int error;</a>
<a name="ln8946"> </a>
<a name="ln8947">	IWN_LOCK(sc);</a>
<a name="ln8948">	error = iwn_scan(sc, vap, ss, ic-&gt;ic_curchan);</a>
<a name="ln8949">	IWN_UNLOCK(sc);</a>
<a name="ln8950">	if (error != 0)</a>
<a name="ln8951">		ieee80211_cancel_scan(vap);</a>
<a name="ln8952">}</a>
<a name="ln8953"> </a>
<a name="ln8954">/*</a>
<a name="ln8955"> * Callback from net80211 to handle the minimum dwell time being met.</a>
<a name="ln8956"> * The intent is to terminate the scan but we just let the firmware</a>
<a name="ln8957"> * notify us when it's finished as we have no safe way to abort it.</a>
<a name="ln8958"> */</a>
<a name="ln8959">static void</a>
<a name="ln8960">iwn_scan_mindwell(struct ieee80211_scan_state *ss)</a>
<a name="ln8961">{</a>
<a name="ln8962">	/* NB: don't try to abort scan; wait for firmware to finish */</a>
<a name="ln8963">}</a>
<a name="ln8964">#ifdef	IWN_DEBUG</a>
<a name="ln8965">#define	IWN_DESC(x) case x:	return #x</a>
<a name="ln8966"> </a>
<a name="ln8967">/*</a>
<a name="ln8968"> * Translate CSR code to string</a>
<a name="ln8969"> */</a>
<a name="ln8970">static char *iwn_get_csr_string(int csr)</a>
<a name="ln8971">{</a>
<a name="ln8972">	switch (csr) {</a>
<a name="ln8973">		IWN_DESC(IWN_HW_IF_CONFIG);</a>
<a name="ln8974">		IWN_DESC(IWN_INT_COALESCING);</a>
<a name="ln8975">		IWN_DESC(IWN_INT);</a>
<a name="ln8976">		IWN_DESC(IWN_INT_MASK);</a>
<a name="ln8977">		IWN_DESC(IWN_FH_INT);</a>
<a name="ln8978">		IWN_DESC(IWN_GPIO_IN);</a>
<a name="ln8979">		IWN_DESC(IWN_RESET);</a>
<a name="ln8980">		IWN_DESC(IWN_GP_CNTRL);</a>
<a name="ln8981">		IWN_DESC(IWN_HW_REV);</a>
<a name="ln8982">		IWN_DESC(IWN_EEPROM);</a>
<a name="ln8983">		IWN_DESC(IWN_EEPROM_GP);</a>
<a name="ln8984">		IWN_DESC(IWN_OTP_GP);</a>
<a name="ln8985">		IWN_DESC(IWN_GIO);</a>
<a name="ln8986">		IWN_DESC(IWN_GP_UCODE);</a>
<a name="ln8987">		IWN_DESC(IWN_GP_DRIVER);</a>
<a name="ln8988">		IWN_DESC(IWN_UCODE_GP1);</a>
<a name="ln8989">		IWN_DESC(IWN_UCODE_GP2);</a>
<a name="ln8990">		IWN_DESC(IWN_LED);</a>
<a name="ln8991">		IWN_DESC(IWN_DRAM_INT_TBL);</a>
<a name="ln8992">		IWN_DESC(IWN_GIO_CHICKEN);</a>
<a name="ln8993">		IWN_DESC(IWN_ANA_PLL);</a>
<a name="ln8994">		IWN_DESC(IWN_HW_REV_WA);</a>
<a name="ln8995">		IWN_DESC(IWN_DBG_HPET_MEM);</a>
<a name="ln8996">	default:</a>
<a name="ln8997">		return &quot;UNKNOWN CSR&quot;;</a>
<a name="ln8998">	}</a>
<a name="ln8999">}</a>
<a name="ln9000"> </a>
<a name="ln9001">/*</a>
<a name="ln9002"> * This function print firmware register</a>
<a name="ln9003"> */</a>
<a name="ln9004">static void</a>
<a name="ln9005">iwn_debug_register(struct iwn_softc *sc)</a>
<a name="ln9006">{</a>
<a name="ln9007">	int i;</a>
<a name="ln9008">	static const uint32_t csr_tbl[] = {</a>
<a name="ln9009">		IWN_HW_IF_CONFIG,</a>
<a name="ln9010">		IWN_INT_COALESCING,</a>
<a name="ln9011">		IWN_INT,</a>
<a name="ln9012">		IWN_INT_MASK,</a>
<a name="ln9013">		IWN_FH_INT,</a>
<a name="ln9014">		IWN_GPIO_IN,</a>
<a name="ln9015">		IWN_RESET,</a>
<a name="ln9016">		IWN_GP_CNTRL,</a>
<a name="ln9017">		IWN_HW_REV,</a>
<a name="ln9018">		IWN_EEPROM,</a>
<a name="ln9019">		IWN_EEPROM_GP,</a>
<a name="ln9020">		IWN_OTP_GP,</a>
<a name="ln9021">		IWN_GIO,</a>
<a name="ln9022">		IWN_GP_UCODE,</a>
<a name="ln9023">		IWN_GP_DRIVER,</a>
<a name="ln9024">		IWN_UCODE_GP1,</a>
<a name="ln9025">		IWN_UCODE_GP2,</a>
<a name="ln9026">		IWN_LED,</a>
<a name="ln9027">		IWN_DRAM_INT_TBL,</a>
<a name="ln9028">		IWN_GIO_CHICKEN,</a>
<a name="ln9029">		IWN_ANA_PLL,</a>
<a name="ln9030">		IWN_HW_REV_WA,</a>
<a name="ln9031">		IWN_DBG_HPET_MEM,</a>
<a name="ln9032">	};</a>
<a name="ln9033">	DPRINTF(sc, IWN_DEBUG_REGISTER,</a>
<a name="ln9034">	    &quot;CSR values: (2nd byte of IWN_INT_COALESCING is IWN_INT_PERIODIC)%s&quot;,</a>
<a name="ln9035">	    &quot;\n&quot;);</a>
<a name="ln9036">	for (i = 0; i &lt;  nitems(csr_tbl); i++){</a>
<a name="ln9037">		DPRINTF(sc, IWN_DEBUG_REGISTER,&quot;  %10s: 0x%08x &quot;,</a>
<a name="ln9038">			iwn_get_csr_string(csr_tbl[i]), IWN_READ(sc, csr_tbl[i]));</a>
<a name="ln9039">		if ((i+1) % 3 == 0)</a>
<a name="ln9040">			DPRINTF(sc, IWN_DEBUG_REGISTER,&quot;%s&quot;,&quot;\n&quot;);</a>
<a name="ln9041">	}</a>
<a name="ln9042">	DPRINTF(sc, IWN_DEBUG_REGISTER,&quot;%s&quot;,&quot;\n&quot;);</a>
<a name="ln9043">}</a>
<a name="ln9044">#endif</a>
<a name="ln9045"> </a>
<a name="ln9046"> </a>

</code></pre>
<div class="balloon" rel="6679"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memset' function will lead to underflow of the buffer 'sc->rxon'.</p></div>
<div class="balloon" rel="5681"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '(rssi) > (phy->rssi[0])' is always false. Unsigned type value is never < 0.</p></div>
<div class="balloon" rel="6854"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v763/" target="_blank">V763</a> Parameter 'c' is always rewritten in function body before being used.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
