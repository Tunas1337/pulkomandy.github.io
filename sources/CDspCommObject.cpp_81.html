
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>CDspCommObject.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// ****************************************************************************</a>
<a name="ln2">//</a>
<a name="ln3">//  	CDspCommObject.cpp</a>
<a name="ln4">//</a>
<a name="ln5">//		Implementation file for EchoGals generic driver DSP interface class.</a>
<a name="ln6">//</a>
<a name="ln7">// ----------------------------------------------------------------------------</a>
<a name="ln8">//</a>
<a name="ln9">// This file is part of Echo Digital Audio's generic driver library.</a>
<a name="ln10">// Copyright Echo Digital Audio Corporation (c) 1998 - 2005</a>
<a name="ln11">// All rights reserved</a>
<a name="ln12">// www.echoaudio.com</a>
<a name="ln13">//</a>
<a name="ln14">// This library is free software; you can redistribute it and/or</a>
<a name="ln15">// modify it under the terms of the GNU Lesser General Public</a>
<a name="ln16">// License as published by the Free Software Foundation; either</a>
<a name="ln17">// version 2.1 of the License, or (at your option) any later version.</a>
<a name="ln18">//</a>
<a name="ln19">// This library is distributed in the hope that it will be useful,</a>
<a name="ln20">// but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln21">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln22">// Lesser General Public License for more details.</a>
<a name="ln23">//</a>
<a name="ln24">// You should have received a copy of the GNU Lesser General Public</a>
<a name="ln25">// License along with this library; if not, write to the Free Software</a>
<a name="ln26">// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</a>
<a name="ln27">//</a>
<a name="ln28">// ****************************************************************************</a>
<a name="ln29"> </a>
<a name="ln30">#include &quot;CEchoGals.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32">#ifdef DSP_56361</a>
<a name="ln33">#include &quot;LoaderDSP.c&quot;</a>
<a name="ln34">#endif</a>
<a name="ln35"> </a>
<a name="ln36">#define COMM_PAGE_PHYS_BYTES	((sizeof(DspCommPage)+PAGE_SIZE-1)/PAGE_SIZE)*PAGE_SIZE</a>
<a name="ln37"> </a>
<a name="ln38"> </a>
<a name="ln39">/****************************************************************************</a>
<a name="ln40"> </a>
<a name="ln41">	Construction and destruction</a>
<a name="ln42"> </a>
<a name="ln43"> ****************************************************************************/</a>
<a name="ln44"> </a>
<a name="ln45">//===========================================================================</a>
<a name="ln46">//</a>
<a name="ln47">// Overload new &amp; delete so memory for this object is allocated</a>
<a name="ln48">//	from non-paged memory.</a>
<a name="ln49">//</a>
<a name="ln50">//===========================================================================</a>
<a name="ln51"> </a>
<a name="ln52">PVOID CDspCommObject::operator new( size_t Size )</a>
<a name="ln53">{</a>
<a name="ln54">	PVOID 		pMemory;</a>
<a name="ln55">	ECHOSTATUS 	Status;</a>
<a name="ln56">	</a>
<a name="ln57">	Status = OsAllocateNonPaged(Size,&amp;pMemory);</a>
<a name="ln58">	</a>
<a name="ln59">	if ( (ECHOSTATUS_OK != Status) || (NULL == pMemory ))</a>
<a name="ln60">	{</a>
<a name="ln61">		ECHO_DEBUGPRINTF((&quot;CDspCommObject::operator new - memory allocation failed\n&quot;));</a>
<a name="ln62"> </a>
<a name="ln63">		pMemory = NULL;</a>
<a name="ln64">	}</a>
<a name="ln65">	else</a>
<a name="ln66">	{</a>
<a name="ln67">		memset( pMemory, 0, Size );</a>
<a name="ln68">	}</a>
<a name="ln69"> </a>
<a name="ln70">	return pMemory;</a>
<a name="ln71">	</a>
<a name="ln72">}	// PVOID CDspCommObject::operator new( size_t Size )</a>
<a name="ln73"> </a>
<a name="ln74"> </a>
<a name="ln75">VOID  CDspCommObject::operator delete( PVOID pVoid )</a>
<a name="ln76">{</a>
<a name="ln77">	if ( ECHOSTATUS_OK != OsFreeNonPaged( pVoid ) )</a>
<a name="ln78">	{</a>
<a name="ln79">		ECHO_DEBUGPRINTF( (&quot;CDspCommObject::operator delete memory free &quot;</a>
<a name="ln80">								 &quot;failed\n&quot;) );</a>
<a name="ln81">	}</a>
<a name="ln82">}	// VOID  CDspCommObject::operator delete( PVOID pVoid )</a>
<a name="ln83"> </a>
<a name="ln84"> </a>
<a name="ln85">//===========================================================================</a>
<a name="ln86">//</a>
<a name="ln87">// Constructor</a>
<a name="ln88">//</a>
<a name="ln89">//===========================================================================</a>
<a name="ln90"> </a>
<a name="ln91">CDspCommObject::CDspCommObject</a>
<a name="ln92">(</a>
<a name="ln93">	PDWORD		pdwDspRegBase,				// Virtual ptr to DSP registers</a>
<a name="ln94">	PCOsSupport	pOsSupport</a>
<a name="ln95">)</a>
<a name="ln96">{</a>
<a name="ln97">	INT32	i;</a>
<a name="ln98"> </a>
<a name="ln99">	ECHO_ASSERT(pOsSupport );</a>
<a name="ln100">	</a>
<a name="ln101">	//</a>
<a name="ln102">	// Init all the basic stuff</a>
<a name="ln103">	//</a>
<a name="ln104">	strcpy( m_szCardName, &quot;??????&quot; );</a>
<a name="ln105">	m_pOsSupport = pOsSupport;				// Ptr to OS Support methods &amp; data</a>
<a name="ln106">	m_pdwDspRegBase = pdwDspRegBase;		// Virtual addr DSP's register base</a>
<a name="ln107">	m_bBadBoard = TRUE;						// Set TRUE until DSP loaded</a>
<a name="ln108">	m_pwDspCode = NULL;						// Current DSP code not loaded</a>
<a name="ln109">	m_byDigitalMode = DIGITAL_MODE_NONE;</a>
<a name="ln110">	m_wInputClock = ECHO_CLOCK_INTERNAL;</a>
<a name="ln111">	m_wOutputClock = ECHO_CLOCK_WORD;</a>
<a name="ln112">	m_ullLastLoadAttemptTime = (ULONGLONG)(DWORD)(0L - DSP_LOAD_ATTEMPT_PERIOD);	// force first load to go</a>
<a name="ln113"> </a>
<a name="ln114">#ifdef MIDI_SUPPORT	</a>
<a name="ln115">	m_ullNextMidiWriteTime = 0;</a>
<a name="ln116">#endif</a>
<a name="ln117"> </a>
<a name="ln118">	//</a>
<a name="ln119">	// Create the DSP comm page - this is the area of memory read and written by</a>
<a name="ln120">	// the DSP via bus mastering</a>
<a name="ln121">	//</a>
<a name="ln122">	ECHOSTATUS Status;</a>
<a name="ln123">	DWORD dwSegmentSize;</a>
<a name="ln124">	PHYS_ADDR PhysAddr;</a>
<a name="ln125">	</a>
<a name="ln126">	Status = pOsSupport-&gt;AllocPhysPageBlock(	COMM_PAGE_PHYS_BYTES,</a>
<a name="ln127">															m_pDspCommPageBlock);</a>
<a name="ln128">	if (ECHOSTATUS_OK != Status)</a>
<a name="ln129">	{</a>
<a name="ln130">		ECHO_DEBUGPRINTF( (&quot;CDspCommObject::CDspCommObject DSP comm page &quot;</a>
<a name="ln131">								 &quot;memory allocation failed\n&quot;) );</a>
<a name="ln132">		return;</a>
<a name="ln133">	}</a>
<a name="ln134">	</a>
<a name="ln135">	m_pDspCommPage = (PDspCommPage) pOsSupport-&gt;</a>
<a name="ln136">													GetPageBlockVirtAddress( m_pDspCommPageBlock );</a>
<a name="ln137">	</a>
<a name="ln138">	pOsSupport-&gt;GetPageBlockPhysSegment(m_pDspCommPageBlock,</a>
<a name="ln139">													0,</a>
<a name="ln140">													PhysAddr,</a>
<a name="ln141">													dwSegmentSize);</a>
<a name="ln142">	m_dwCommPagePhys = PhysAddr;</a>
<a name="ln143">	</a>
<a name="ln144">	//</a>
<a name="ln145">	// Init the comm page</a>
<a name="ln146">	//</a>
<a name="ln147">	m_pDspCommPage-&gt;dwCommSize = SWAP( sizeof( DspCommPage ) );</a>
<a name="ln148">													// Size of DSP comm page</a>
<a name="ln149">	</a>
<a name="ln150">	m_pDspCommPage-&gt;dwHandshake = 0xffffffff;</a>
<a name="ln151">	m_pDspCommPage-&gt;dwMidiOutFreeCount = SWAP( (DWORD) DSP_MIDI_OUT_FIFO_SIZE );</a>
<a name="ln152"> </a>
<a name="ln153">	for ( i = 0; i &lt; DSP_MAXAUDIOINPUTS; i++ )</a>
<a name="ln154">		m_pDspCommPage-&gt;InLineLevel[ i ] = 0x00;</a>
<a name="ln155">													// Set line levels so we don't blast</a>
<a name="ln156">													// any inputs on startup</a>
<a name="ln157">	memset( m_pDspCommPage-&gt;byMonitors,</a>
<a name="ln158">			  GENERIC_TO_DSP(ECHOGAIN_MUTED),</a>
<a name="ln159">			  MONITOR_ARRAY_SIZE );			// Mute all monitors</a>
<a name="ln160"> </a>
<a name="ln161">	memset( m_pDspCommPage-&gt;byVmixerLevel,</a>
<a name="ln162">			  GENERIC_TO_DSP(ECHOGAIN_MUTED),</a>
<a name="ln163">			  VMIXER_ARRAY_SIZE );			// Mute all virtual mixer levels</a>
<a name="ln164">			  </a>
<a name="ln165">#ifdef DIGITAL_INPUT_AUTO_MUTE_SUPPORT</a>
<a name="ln166"> </a>
<a name="ln167">	m_fDigitalInAutoMute = TRUE;</a>
<a name="ln168"> </a>
<a name="ln169">#endif</a>
<a name="ln170"> </a>
<a name="ln171">}	// CDspCommObject::CDspCommObject</a>
<a name="ln172"> </a>
<a name="ln173"> </a>
<a name="ln174">//===========================================================================</a>
<a name="ln175">//</a>
<a name="ln176">// Destructor</a>
<a name="ln177">//</a>
<a name="ln178">//===========================================================================</a>
<a name="ln179"> </a>
<a name="ln180">CDspCommObject::~CDspCommObject()</a>
<a name="ln181">{</a>
<a name="ln182">	//</a>
<a name="ln183">	// Go to sleep</a>
<a name="ln184">	//</a>
<a name="ln185">	GoComatose();</a>
<a name="ln186"> </a>
<a name="ln187">	//</a>
<a name="ln188">	// Free the comm page</a>
<a name="ln189">	//</a>
<a name="ln190">	if ( NULL != m_pDspCommPageBlock )</a>
<a name="ln191">	{</a>
<a name="ln192">		m_pOsSupport-&gt;FreePhysPageBlock( COMM_PAGE_PHYS_BYTES,</a>
<a name="ln193">													m_pDspCommPageBlock);</a>
<a name="ln194">	}</a>
<a name="ln195"> </a>
<a name="ln196">	ECHO_DEBUGPRINTF( ( &quot;CDspCommObject::~CDspCommObject() is toast!\n&quot; ) );</a>
<a name="ln197"> </a>
<a name="ln198">}	// CDspCommObject::~CDspCommObject()</a>
<a name="ln199"> </a>
<a name="ln200"> </a>
<a name="ln201"> </a>
<a name="ln202"> </a>
<a name="ln203">/****************************************************************************</a>
<a name="ln204"> </a>
<a name="ln205">	Firmware loading functions</a>
<a name="ln206"> </a>
<a name="ln207"> ****************************************************************************/</a>
<a name="ln208"> </a>
<a name="ln209">//===========================================================================</a>
<a name="ln210">//</a>
<a name="ln211">// ASIC status check - some cards have one or two ASICs that need to be </a>
<a name="ln212">// loaded.  Once that load is complete, this function is called to see if</a>
<a name="ln213">// the load was successful. </a>
<a name="ln214">//</a>
<a name="ln215">// If this load fails, it does not necessarily mean that the hardware is</a>
<a name="ln216">// defective - the external box may be disconnected or turned off.</a>
<a name="ln217">//</a>
<a name="ln218">//===========================================================================</a>
<a name="ln219"> </a>
<a name="ln220">BOOL CDspCommObject::CheckAsicStatus()</a>
<a name="ln221">{</a>
<a name="ln222">	DWORD	dwAsicStatus;</a>
<a name="ln223">	DWORD	dwReturn;</a>
<a name="ln224"> </a>
<a name="ln225">	//</a>
<a name="ln226">	// Always succeed if this card doesn't have an ASIC</a>
<a name="ln227">	//</a>
<a name="ln228">	if ( !m_bHasASIC )</a>
<a name="ln229">	{</a>
<a name="ln230">		m_bASICLoaded = TRUE;</a>
<a name="ln231">		return TRUE;</a>
<a name="ln232">	}</a>
<a name="ln233">			</a>
<a name="ln234">	// Send the vector command</a>
<a name="ln235">	m_bASICLoaded = FALSE;</a>
<a name="ln236">	SendVector( DSP_VC_TEST_ASIC );	</a>
<a name="ln237"> </a>
<a name="ln238">	// The DSP will return a value to indicate whether or not the </a>
<a name="ln239">	// ASIC is currently loaded</a>
<a name="ln240">	dwReturn = Read_DSP( &amp;dwAsicStatus );</a>
<a name="ln241">	if ( ECHOSTATUS_OK != dwReturn )</a>
<a name="ln242">	{</a>
<a name="ln243">		ECHO_DEBUGPRINTF((&quot;CDspCommObject::CheckAsicStatus - failed on Read_DSP\n&quot;));</a>
<a name="ln244">		ECHO_DEBUGBREAK();</a>
<a name="ln245">		return FALSE;</a>
<a name="ln246">	}</a>
<a name="ln247"> </a>
<a name="ln248">#ifdef ECHO_DEBUG</a>
<a name="ln249">	if ( (dwAsicStatus != ASIC_LOADED) &amp;&amp; (dwAsicStatus != ASIC_NOT_LOADED) )</a>
<a name="ln250">	{</a>
<a name="ln251">		ECHO_DEBUGBREAK(); </a>
<a name="ln252">	}</a>
<a name="ln253">#endif</a>
<a name="ln254">	</a>
<a name="ln255">	if ( dwAsicStatus == ASIC_LOADED )</a>
<a name="ln256">		m_bASICLoaded = TRUE;</a>
<a name="ln257"> </a>
<a name="ln258">	return m_bASICLoaded;</a>
<a name="ln259"> </a>
<a name="ln260">}	// BOOL CDspCommObject::CheckAsicStatus()</a>
<a name="ln261"> </a>
<a name="ln262"> </a>
<a name="ln263">//===========================================================================</a>
<a name="ln264">//</a>
<a name="ln265">//	Load ASIC code - done after the DSP is loaded</a>
<a name="ln266">//</a>
<a name="ln267">//===========================================================================</a>
<a name="ln268"> </a>
<a name="ln269">BOOL CDspCommObject::LoadASIC</a>
<a name="ln270">(</a>
<a name="ln271">	DWORD	dwCmd,</a>
<a name="ln272">	PBYTE	pCode,</a>
<a name="ln273">	DWORD	dwSize</a>
<a name="ln274">)</a>
<a name="ln275">{</a>
<a name="ln276">	DWORD i;</a>
<a name="ln277">#ifdef _WIN32</a>
<a name="ln278">	DWORD dwChecksum = 0;</a>
<a name="ln279">#endif</a>
<a name="ln280"> </a>
<a name="ln281">	ECHO_DEBUGPRINTF((&quot;CDspCommObject::LoadASIC\n&quot;));</a>
<a name="ln282"> </a>
<a name="ln283">	if ( !m_bHasASIC )</a>
<a name="ln284">		return TRUE;</a>
<a name="ln285"> </a>
<a name="ln286">#ifdef _DEBUG</a>
<a name="ln287">	ULONGLONG	ullStartTime, ullCurTime;</a>
<a name="ln288">	m_pOsSupport-&gt;OsGetSystemTime( &amp;ullStartTime );</a>
<a name="ln289">#endif</a>
<a name="ln290"> </a>
<a name="ln291">	// Send the &quot;Here comes the ASIC&quot; command</a>
<a name="ln292">	if ( ECHOSTATUS_OK != Write_DSP( dwCmd ) )</a>
<a name="ln293">		return FALSE;</a>
<a name="ln294"> </a>
<a name="ln295">	// Write length of ASIC file in bytes</a>
<a name="ln296">	if ( ECHOSTATUS_OK != Write_DSP( dwSize ) )</a>
<a name="ln297">		return FALSE;</a>
<a name="ln298"> </a>
<a name="ln299">	for ( i = 0; i &lt; dwSize; i++ )</a>
<a name="ln300">	{</a>
<a name="ln301">#ifdef _WIN32</a>
<a name="ln302">		dwChecksum += pCode[i];</a>
<a name="ln303">#endif	</a>
<a name="ln304">	</a>
<a name="ln305">		if ( ECHOSTATUS_OK != Write_DSP( pCode[ i ] ) )</a>
<a name="ln306">		{</a>
<a name="ln307">			ECHO_DEBUGPRINTF((&quot;\tfailed on Write_DSP\n&quot;));</a>
<a name="ln308">			return FALSE;</a>
<a name="ln309">		}</a>
<a name="ln310">	}</a>
<a name="ln311"> </a>
<a name="ln312">#ifdef _DEBUG</a>
<a name="ln313">	m_pOsSupport-&gt;OsGetSystemTime( &amp;ullCurTime );</a>
<a name="ln314">	ECHO_DEBUGPRINTF( (&quot;CDspCommObject::LoadASIC took %ld usec.\n&quot;,</a>
<a name="ln315">							(ULONG) ( ullCurTime - ullStartTime ) ) );</a>
<a name="ln316">	ECHO_DEBUGPRINTF((&quot;ASIC load OK\n&quot;));</a>
<a name="ln317">#endif</a>
<a name="ln318"> </a>
<a name="ln319">#if defined(_WIN32) &amp;&amp; (DBG)</a>
<a name="ln320">	DbgPrint(&quot;--- ASIC checksum is 0x%lx\n&quot;,dwChecksum);</a>
<a name="ln321">#endif</a>
<a name="ln322"> </a>
<a name="ln323">	return TRUE;</a>
<a name="ln324"> </a>
<a name="ln325">}	// BOOL CDspCommObject::LoadASIC( DWORD dwCmd, PBYTE pCode, DWORD dwSize )</a>
<a name="ln326"> </a>
<a name="ln327"> </a>
<a name="ln328">//===========================================================================</a>
<a name="ln329">//</a>
<a name="ln330">// InstallResidentLoader</a>
<a name="ln331">//</a>
<a name="ln332">// Install the resident loader for 56361 DSPs;  The resident loader</a>
<a name="ln333">// is on the EPROM on the board for 56301 DSP.</a>
<a name="ln334">//</a>
<a name="ln335">// The resident loader is a tiny little program that is used to load</a>
<a name="ln336">// the real DSP code.</a>
<a name="ln337">//</a>
<a name="ln338">//===========================================================================</a>
<a name="ln339"> </a>
<a name="ln340">#ifdef DSP_56361</a>
<a name="ln341"> </a>
<a name="ln342">ECHOSTATUS CDspCommObject::InstallResidentLoader()</a>
<a name="ln343">{</a>
<a name="ln344">	DWORD			dwAddress;</a>
<a name="ln345">	DWORD			dwIndex;</a>
<a name="ln346">	INT32			iNum;</a>
<a name="ln347">	INT32			i;</a>
<a name="ln348">	DWORD			dwReturn;</a>
<a name="ln349">	PWORD			pCode;</a>
<a name="ln350"> </a>
<a name="ln351">	ECHO_DEBUGPRINTF( (&quot;CDspCommObject::InstallResidentLoader\n&quot;) );</a>
<a name="ln352">	</a>
<a name="ln353">	//</a>
<a name="ln354">	// 56361 cards only!</a>
<a name="ln355">	//</a>
<a name="ln356">	if (DEVICE_ID_56361 != m_pOsSupport-&gt;GetDeviceId() )</a>
<a name="ln357">		return ECHOSTATUS_OK;</a>
<a name="ln358"> </a>
<a name="ln359">	//</a>
<a name="ln360">	// Look to see if the resident loader is present.  If the resident loader</a>
<a name="ln361">	// is already installed, host flag 5 will be on.</a>
<a name="ln362">	//</a>
<a name="ln363">	DWORD dwStatus;</a>
<a name="ln364">	dwStatus = GetDspRegister( CHI32_STATUS_REG );</a>
<a name="ln365">	if ( 0 != (dwStatus &amp; CHI32_STATUS_REG_HF5 ) )</a>
<a name="ln366">	{</a>
<a name="ln367">		ECHO_DEBUGPRINTF((&quot;\tResident loader already installed; status is 0x%lx\n&quot;,</a>
<a name="ln368">								dwStatus));</a>
<a name="ln369">		return ECHOSTATUS_OK;</a>
<a name="ln370">	}</a>
<a name="ln371">	//</a>
<a name="ln372">	// Set DSP format bits for 24 bit mode</a>
<a name="ln373">	//</a>
<a name="ln374">	SetDspRegister( CHI32_CONTROL_REG,</a>
<a name="ln375">						 GetDspRegister( CHI32_CONTROL_REG ) | 0x900 );</a>
<a name="ln376"> </a>
<a name="ln377">	//---------------------------------------------------------------------------</a>
<a name="ln378">	//</a>
<a name="ln379">	// Loader</a>
<a name="ln380">	//</a>
<a name="ln381">	// The DSP code is an array of 16 bit words.  The array is divided up into</a>
<a name="ln382">	// sections.  The first word of each section is the size in words, followed</a>
<a name="ln383">	// by the section type.</a>
<a name="ln384">	//</a>
<a name="ln385">	// Since DSP addresses and data are 24 bits wide, they each take up two</a>
<a name="ln386">	// 16 bit words in the array.</a>
<a name="ln387">	//</a>
<a name="ln388">	// This is a lot like the other loader loop, but it's not a loop,</a>
<a name="ln389">	// you don't write the memory type, and you don't write a zero at the end.</a>
<a name="ln390">	//</a>
<a name="ln391">	//---------------------------------------------------------------------------</a>
<a name="ln392"> </a>
<a name="ln393">	pCode = pwLoaderDSP;</a>
<a name="ln394">	//</a>
<a name="ln395">	// Skip the header section; the first word in the array is the size of </a>
<a name="ln396">	//	the first section, so the first real section of code is pointed to </a>
<a name="ln397">	//	by pCode[0].</a>
<a name="ln398">	//</a>
<a name="ln399">	dwIndex = pCode[ 0 ];</a>
<a name="ln400">	//</a>
<a name="ln401">	// Skip the section size, LRS block type, and DSP memory type</a>
<a name="ln402">	//</a>
<a name="ln403">	dwIndex += 3;</a>
<a name="ln404">	//	</a>
<a name="ln405">	// Get the number of DSP words to write</a>
<a name="ln406">	//</a>
<a name="ln407">	iNum = pCode[ dwIndex++ ];</a>
<a name="ln408">	//</a>
<a name="ln409">	// Get the DSP address for this block; 24 bits, so build from two words</a>
<a name="ln410">	//</a>
<a name="ln411">	dwAddress = ( pCode[ dwIndex ] &lt;&lt; 16 ) + pCode[ dwIndex + 1 ];</a>
<a name="ln412">	dwIndex += 2;</a>
<a name="ln413">	//	</a>
<a name="ln414">	// Write the count to the DSP</a>
<a name="ln415">	//</a>
<a name="ln416">	dwReturn = Write_DSP( (DWORD) iNum );</a>
<a name="ln417">	if ( dwReturn != 0 )</a>
<a name="ln418">	{</a>
<a name="ln419">		ECHO_DEBUGPRINTF( (&quot;CDspCommObject::InstallResidentLoader: Failed to &quot;</a>
<a name="ln420">								 &quot;write word count!\n&quot;) );</a>
<a name="ln421">		return ECHOSTATUS_DSP_DEAD;</a>
<a name="ln422">	}</a>
<a name="ln423"> </a>
<a name="ln424">	// Write the DSP address</a>
<a name="ln425">	dwReturn = Write_DSP( dwAddress );</a>
<a name="ln426">	if ( dwReturn != 0 )</a>
<a name="ln427">	{</a>
<a name="ln428">		ECHO_DEBUGPRINTF( (&quot;CDspCommObject::InstallResidentLoader: Failed to &quot;</a>
<a name="ln429">								 &quot;write DSP address!\n&quot;) );</a>
<a name="ln430">		return ECHOSTATUS_DSP_DEAD;</a>
<a name="ln431">	}</a>
<a name="ln432"> </a>
<a name="ln433"> </a>
<a name="ln434">	// Write out this block of code to the DSP</a>
<a name="ln435">	for ( i = 0; i &lt; iNum; i++) // </a>
<a name="ln436">	{</a>
<a name="ln437">		DWORD	dwData;</a>
<a name="ln438"> </a>
<a name="ln439">		dwData = ( pCode[ dwIndex ] &lt;&lt; 16 ) + pCode[ dwIndex + 1 ];</a>
<a name="ln440">		dwReturn = Write_DSP( dwData );</a>
<a name="ln441">		if ( dwReturn != 0 )</a>
<a name="ln442">		{</a>
<a name="ln443">			ECHO_DEBUGPRINTF( (&quot;CDspCommObject::InstallResidentLoader: Failed to &quot;</a>
<a name="ln444">									 &quot;write DSP code\n&quot;) );</a>
<a name="ln445">			return ECHOSTATUS_DSP_DEAD;</a>
<a name="ln446">		}</a>
<a name="ln447"> </a>
<a name="ln448">		dwIndex+=2;</a>
<a name="ln449">	}</a>
<a name="ln450">	</a>
<a name="ln451">	//</a>
<a name="ln452">	// Wait for flag 5 to come up</a>
<a name="ln453">	//</a>
<a name="ln454">	BOOL			fSuccess;</a>
<a name="ln455">	ULONGLONG 	ullCurTime,ullTimeout;</a>
<a name="ln456"> </a>
<a name="ln457">	m_pOsSupport-&gt;OsGetSystemTime( &amp;ullCurTime );</a>
<a name="ln458">	ullTimeout = ullCurTime + 10000L;		// 10m.s.</a>
<a name="ln459">	fSuccess = FALSE;</a>
<a name="ln460">	do</a>
<a name="ln461">	{</a>
<a name="ln462">		m_pOsSupport-&gt;OsSnooze(50);	// Give the DSP some time;</a>
<a name="ln463">														// no need to hog the CPU</a>
<a name="ln464">		</a>
<a name="ln465">		dwStatus = GetDspRegister( CHI32_STATUS_REG );</a>
<a name="ln466">		if (0 != (dwStatus &amp; CHI32_STATUS_REG_HF5))</a>
<a name="ln467">		{</a>
<a name="ln468">			fSuccess = TRUE;</a>
<a name="ln469">			break;</a>
<a name="ln470">		}</a>
<a name="ln471">		</a>
<a name="ln472">		m_pOsSupport-&gt;OsGetSystemTime( &amp;ullCurTime );</a>
<a name="ln473"> </a>
<a name="ln474">	} while (ullCurTime &lt; ullTimeout);</a>
<a name="ln475">	</a>
<a name="ln476">	if (FALSE == fSuccess)</a>
<a name="ln477">	{</a>
<a name="ln478">		ECHO_DEBUGPRINTF((&quot;\tResident loader failed to set HF5\n&quot;));</a>
<a name="ln479">		return ECHOSTATUS_DSP_DEAD;</a>
<a name="ln480">	}</a>
<a name="ln481">		</a>
<a name="ln482">	ECHO_DEBUGPRINTF((&quot;\tResident loader successfully installed\n&quot;));</a>
<a name="ln483"> </a>
<a name="ln484">	return ECHOSTATUS_OK;</a>
<a name="ln485">	</a>
<a name="ln486">}	// ECHOSTATUS CDspCommObject::InstallResidentLoader()</a>
<a name="ln487"> </a>
<a name="ln488">#endif // DSP_56361</a>
<a name="ln489"> </a>
<a name="ln490"> </a>
<a name="ln491">//===========================================================================</a>
<a name="ln492">//</a>
<a name="ln493">// LoadDSP</a>
<a name="ln494">//</a>
<a name="ln495">// This loads the DSP code.</a>
<a name="ln496">//</a>
<a name="ln497">//===========================================================================</a>
<a name="ln498"> </a>
<a name="ln499">ECHOSTATUS CDspCommObject::LoadDSP</a>
<a name="ln500">(</a>
<a name="ln501">	PWORD	pCode					// Ptr to DSP object code</a>
<a name="ln502">)</a>
<a name="ln503">{</a>
<a name="ln504">	DWORD			dwAddress;</a>
<a name="ln505">	DWORD			dwIndex;</a>
<a name="ln506">	INT32			iNum;</a>
<a name="ln507">	INT32			i;</a>
<a name="ln508">	DWORD			dwReturn;</a>
<a name="ln509">	ULONGLONG	ullTimeout, ullCurTime;</a>
<a name="ln510">	ECHOSTATUS	Status;</a>
<a name="ln511"> </a>
<a name="ln512">	ECHO_DEBUGPRINTF((&quot;CDspCommObject::LoadDSP\n&quot;));</a>
<a name="ln513">	if ( m_pwDspCode == pCode )</a>
<a name="ln514">	{</a>
<a name="ln515">		ECHO_DEBUGPRINTF( (&quot;\tDSP is already loaded!\n&quot;) );</a>
<a name="ln516">		return ECHOSTATUS_FIRMWARE_LOADED;</a>
<a name="ln517">	}</a>
<a name="ln518">	m_bBadBoard = TRUE;		// Set TRUE until DSP loaded</a>
<a name="ln519">	m_pwDspCode = NULL;		// Current DSP code not loaded</a>
<a name="ln520">	m_bASICLoaded = FALSE;	// Loading the DSP code will reset the ASIC</a>
<a name="ln521">	</a>
<a name="ln522">	ECHO_DEBUGPRINTF((&quot;CDspCommObject::LoadDSP  Set m_bBadBoard to TRUE\n&quot;));</a>
<a name="ln523">	</a>
<a name="ln524">	//</a>
<a name="ln525">	//	If this board requires a resident loader, install it.</a>
<a name="ln526">	//</a>
<a name="ln527">#ifdef DSP_56361</a>
<a name="ln528">	InstallResidentLoader();</a>
<a name="ln529">#endif</a>
<a name="ln530"> </a>
<a name="ln531">	// Send software reset command	</a>
<a name="ln532">	if ( ECHOSTATUS_OK != SendVector( DSP_VC_RESET ) )</a>
<a name="ln533">	{</a>
<a name="ln534">		m_pOsSupport-&gt;EchoErrorMsg(</a>
<a name="ln535">			&quot;CDspCommObject::LoadDsp SendVector DSP_VC_RESET failed&quot;,</a>
<a name="ln536">			&quot;Critical Failure&quot; );</a>
<a name="ln537">		return ECHOSTATUS_DSP_DEAD;</a>
<a name="ln538">	}</a>
<a name="ln539"> </a>
<a name="ln540">	// Delay 10us</a>
<a name="ln541">	m_pOsSupport-&gt;OsSnooze( 10L );</a>
<a name="ln542"> </a>
<a name="ln543">	// Wait 10ms for HF3 to indicate that software reset is complete	</a>
<a name="ln544">	m_pOsSupport-&gt;OsGetSystemTime( &amp;ullCurTime );</a>
<a name="ln545">	ullTimeout = ullCurTime + 10000L;		// 10m.s.</a>
<a name="ln546"> </a>
<a name="ln547">	// wait for HF3 to be set</a>
<a name="ln548">wait_for_hf3:</a>
<a name="ln549">	</a>
<a name="ln550">	if ( GetDspRegister( CHI32_STATUS_REG ) &amp; CHI32_STATUS_REG_HF3 )</a>
<a name="ln551">			goto set_dsp_format_bits;</a>
<a name="ln552">		m_pOsSupport-&gt;OsGetSystemTime( &amp;ullCurTime );</a>
<a name="ln553">		if ( ullCurTime &gt; ullTimeout)</a>
<a name="ln554">		{</a>
<a name="ln555">			ECHO_DEBUGPRINTF( (&quot;CDspCommObject::LoadDSP Timeout waiting for &quot;</a>
<a name="ln556">									 &quot;CHI32_STATUS_REG_HF3\n&quot;) );</a>
<a name="ln557">			m_pOsSupport-&gt;EchoErrorMsg(</a>
<a name="ln558">				&quot;CDspCommObject::LoadDSP SendVector DSP_VC_RESET failed&quot;,</a>
<a name="ln559">				&quot;Critical Failure&quot; );</a>
<a name="ln560">			return ECHOSTATUS_DSP_TIMEOUT;</a>
<a name="ln561">		}</a>
<a name="ln562">	goto wait_for_hf3;</a>
<a name="ln563"> </a>
<a name="ln564"> </a>
<a name="ln565">	// Set DSP format bits for 24 bit mode now that soft reset is done</a>
<a name="ln566">set_dsp_format_bits:</a>
<a name="ln567">		SetDspRegister( CHI32_CONTROL_REG,</a>
<a name="ln568">						 GetDspRegister( CHI32_CONTROL_REG ) | (DWORD) 0x900 );</a>
<a name="ln569"> </a>
<a name="ln570">	//---------------------------------------------------------------------------</a>
<a name="ln571">	// Main loader loop</a>
<a name="ln572">	//---------------------------------------------------------------------------</a>
<a name="ln573"> </a>
<a name="ln574">	dwIndex = pCode[ 0 ];</a>
<a name="ln575"> </a>
<a name="ln576">	for (;;)</a>
<a name="ln577">	{</a>
<a name="ln578">		INT32	iBlockType;</a>
<a name="ln579">		INT32	iMemType;</a>
<a name="ln580"> </a>
<a name="ln581">		// Total Block Size</a>
<a name="ln582">		dwIndex++;</a>
<a name="ln583">		</a>
<a name="ln584">		// Block Type</a>
<a name="ln585">		iBlockType = pCode[ dwIndex ];</a>
<a name="ln586">		if ( iBlockType == 4 )  // We're finished</a>
<a name="ln587">			break;</a>
<a name="ln588"> </a>
<a name="ln589">		dwIndex++;</a>
<a name="ln590"> </a>
<a name="ln591">		// Memory Type  P=0,X=1,Y=2</a>
<a name="ln592">		iMemType = pCode[ dwIndex ]; </a>
<a name="ln593">		dwIndex++;</a>
<a name="ln594">		</a>
<a name="ln595">		// Block Code Size</a>
<a name="ln596">		iNum = pCode[ dwIndex ];</a>
<a name="ln597">		dwIndex++;</a>
<a name="ln598">		if ( iNum == 0 )			// We're finished</a>
<a name="ln599">			break;</a>
<a name="ln600">	</a>
<a name="ln601"> 		// Start Address</a>
<a name="ln602">		dwAddress = ( (DWORD) pCode[ dwIndex ] &lt;&lt; 16 ) + pCode[ dwIndex + 1 ];</a>
<a name="ln603">//		ECHO_DEBUGPRINTF( (&quot;\tdwAddress %lX\n&quot;, dwAddress) );</a>
<a name="ln604">		dwIndex += 2;</a>
<a name="ln605">		</a>
<a name="ln606">		dwReturn = Write_DSP( (DWORD)iNum );</a>
<a name="ln607">		if ( dwReturn != 0 )</a>
<a name="ln608">		{</a>
<a name="ln609">			ECHO_DEBUGPRINTF((&quot;LoadDSP - failed to write number of DSP words\n&quot;));</a>
<a name="ln610">			return ECHOSTATUS_DSP_DEAD;</a>
<a name="ln611">		}</a>
<a name="ln612"> </a>
<a name="ln613">		dwReturn = Write_DSP( dwAddress );</a>
<a name="ln614">		if ( dwReturn != 0 )</a>
<a name="ln615">		{</a>
<a name="ln616">			ECHO_DEBUGPRINTF((&quot;LoadDSP - failed to write DSP address\n&quot;));</a>
<a name="ln617">			return ECHOSTATUS_DSP_DEAD;</a>
<a name="ln618">		}</a>
<a name="ln619"> </a>
<a name="ln620">		dwReturn = Write_DSP( (DWORD)iMemType );</a>
<a name="ln621">		if ( dwReturn != 0 )</a>
<a name="ln622">		{</a>
<a name="ln623">			ECHO_DEBUGPRINTF((&quot;LoadDSP - failed to write DSP memory type\n&quot;));</a>
<a name="ln624">			return ECHOSTATUS_DSP_DEAD;</a>
<a name="ln625">		}</a>
<a name="ln626"> </a>
<a name="ln627">		// Code</a>
<a name="ln628">		for ( i = 0; i &lt; iNum; i++ )</a>
<a name="ln629">		{</a>
<a name="ln630">			DWORD	dwData;</a>
<a name="ln631"> </a>
<a name="ln632">			dwData = ( (DWORD) pCode[ dwIndex ] &lt;&lt; 16 ) + pCode[ dwIndex + 1 ];</a>
<a name="ln633">			dwReturn = Write_DSP( dwData );</a>
<a name="ln634">			if ( dwReturn != 0 )</a>
<a name="ln635">			{</a>
<a name="ln636">				ECHO_DEBUGPRINTF((&quot;LoadDSP - failed to write DSP data\n&quot;));</a>
<a name="ln637">				return ECHOSTATUS_DSP_DEAD;</a>
<a name="ln638">			}</a>
<a name="ln639">	</a>
<a name="ln640">			dwIndex += 2;</a>
<a name="ln641">		}</a>
<a name="ln642">//		ECHO_DEBUGPRINTF( (&quot;\tEnd Code Block\n&quot;) );</a>
<a name="ln643">	}</a>
<a name="ln644">	dwReturn = Write_DSP( 0 );					// We're done!!!</a>
<a name="ln645">	if ( dwReturn != 0 )</a>
<a name="ln646">	{</a>
<a name="ln647">		ECHO_DEBUGPRINTF((&quot;LoadDSP: Failed to write final zero\n&quot;));</a>
<a name="ln648">		return ECHOSTATUS_DSP_DEAD;</a>
<a name="ln649">	}</a>
<a name="ln650">		</a>
<a name="ln651"> </a>
<a name="ln652">	// Delay 10us</a>
<a name="ln653">	m_pOsSupport-&gt;OsSnooze( 10L );</a>
<a name="ln654"> </a>
<a name="ln655">	m_pOsSupport-&gt;OsGetSystemTime( &amp;ullCurTime );</a>
<a name="ln656">	ullTimeout  = ullCurTime + 500000L;		// 1/2 sec. timeout</a>
<a name="ln657"> </a>
<a name="ln658">	while ( ullCurTime &lt;= ullTimeout) </a>
<a name="ln659">	{</a>
<a name="ln660">		//</a>
<a name="ln661">		// Wait for flag 4 - indicates that the DSP loaded OK</a>
<a name="ln662">		//</a>
<a name="ln663">		if ( GetDspRegister( CHI32_STATUS_REG ) &amp; CHI32_STATUS_REG_HF4 )</a>
<a name="ln664">		{</a>
<a name="ln665">			SetDspRegister( CHI32_CONTROL_REG,</a>
<a name="ln666">								 GetDspRegister( CHI32_CONTROL_REG ) &amp; ~0x1b00 );</a>
<a name="ln667"> </a>
<a name="ln668">			dwReturn = Write_DSP( DSP_FNC_SET_COMMPAGE_ADDR );</a>
<a name="ln669">			if ( dwReturn != 0 )</a>
<a name="ln670">			{</a>
<a name="ln671">				ECHO_DEBUGPRINTF((&quot;LoadDSP - Failed to write DSP_FNC_SET_COMMPAGE_ADDR\n&quot;));</a>
<a name="ln672">				return ECHOSTATUS_DSP_DEAD;</a>
<a name="ln673">			}</a>
<a name="ln674">				</a>
<a name="ln675">			dwReturn = Write_DSP( m_dwCommPagePhys );</a>
<a name="ln676">			if ( dwReturn != 0 )</a>
<a name="ln677">			{</a>
<a name="ln678">				ECHO_DEBUGPRINTF((&quot;LoadDSP - Failed to write comm page address\n&quot;));</a>
<a name="ln679">				return ECHOSTATUS_DSP_DEAD;</a>
<a name="ln680">			}</a>
<a name="ln681"> </a>
<a name="ln682">			//</a>
<a name="ln683">			// Get the serial number via slave mode.</a>
<a name="ln684">			// This is triggered by the SET_COMMPAGE_ADDR command.</a>
<a name="ln685">			//	We don't actually use the serial number but we have to get</a>
<a name="ln686">			//	it as part of the DSP init vodoo.</a>
<a name="ln687">			//</a>
<a name="ln688">			Status = ReadSn();</a>
<a name="ln689">			if ( ECHOSTATUS_OK != Status )</a>
<a name="ln690">			{</a>
<a name="ln691">				ECHO_DEBUGPRINTF((&quot;LoadDSP - Failed to read serial number\n&quot;));</a>
<a name="ln692">				return Status;</a>
<a name="ln693">			}</a>
<a name="ln694"> </a>
<a name="ln695">			m_pwDspCode = pCode;			// Show which DSP code loaded</a>
<a name="ln696">			m_bBadBoard = FALSE;			// DSP OK</a>
<a name="ln697">			</a>
<a name="ln698">			ECHO_DEBUGPRINTF((&quot;CDspCommObject::LoadDSP  Set m_bBadBoard to FALSE\n&quot;));			</a>
<a name="ln699">		</a>
<a name="ln700">			return ECHOSTATUS_OK;</a>
<a name="ln701">		}</a>
<a name="ln702">		</a>
<a name="ln703">		m_pOsSupport-&gt;OsGetSystemTime( &amp;ullCurTime );</a>
<a name="ln704">	}</a>
<a name="ln705">	</a>
<a name="ln706">	ECHO_DEBUGPRINTF( (&quot;LoadDSP: DSP load timed out waiting for HF4\n&quot;) );	</a>
<a name="ln707">	</a>
<a name="ln708">	return ECHOSTATUS_DSP_TIMEOUT;</a>
<a name="ln709"> </a>
<a name="ln710">}	// DWORD	CDspCommObject::LoadDSP</a>
<a name="ln711"> </a>
<a name="ln712"> </a>
<a name="ln713"> </a>
<a name="ln714"> </a>
<a name="ln715">//===========================================================================</a>
<a name="ln716">//</a>
<a name="ln717">// LoadFirmware takes care of loading the DSP and any ASIC code.</a>
<a name="ln718">//</a>
<a name="ln719">//===========================================================================</a>
<a name="ln720"> </a>
<a name="ln721">ECHOSTATUS CDspCommObject::LoadFirmware()</a>
<a name="ln722">{</a>
<a name="ln723">	ECHOSTATUS	dwReturn;</a>
<a name="ln724">	ULONGLONG	ullRightNow;</a>
<a name="ln725"> </a>
<a name="ln726">	// Sanity check</a>
<a name="ln727">	if ( NULL == m_pwDspCodeToLoad || NULL == m_pDspCommPage )</a>
<a name="ln728">	{</a>
<a name="ln729">		ECHO_DEBUGBREAK();</a>
<a name="ln730">		return ECHOSTATUS_NO_MEM;</a>
<a name="ln731">	}</a>
<a name="ln732">	</a>
<a name="ln733">	//</a>
<a name="ln734">	// Even if the external box is off, an application may still try</a>
<a name="ln735">	// to repeatedly open the driver, causing multiple load attempts and </a>
<a name="ln736">	// making the machine spend lots of time in the kernel.  If the ASIC is not</a>
<a name="ln737">	// loaded, this code will gate the loading attempts so it doesn't happen</a>
<a name="ln738">	// more than once per second.</a>
<a name="ln739">	//</a>
<a name="ln740">	m_pOsSupport-&gt;OsGetSystemTime(&amp;ullRightNow);</a>
<a name="ln741">	if ( 	(FALSE == m_bASICLoaded) &amp;&amp;</a>
<a name="ln742">			(DSP_LOAD_ATTEMPT_PERIOD &gt; (ullRightNow - m_ullLastLoadAttemptTime)) )</a>
<a name="ln743">		return ECHOSTATUS_ASIC_NOT_LOADED;</a>
<a name="ln744">	</a>
<a name="ln745">	//</a>
<a name="ln746">	// Update the timestamp</a>
<a name="ln747">	//</a>
<a name="ln748">	m_ullLastLoadAttemptTime = ullRightNow;</a>
<a name="ln749"> </a>
<a name="ln750">	//</a>
<a name="ln751">	// See if the ASIC is present and working - only if the DSP is already loaded</a>
<a name="ln752">	//	</a>
<a name="ln753">	if (NULL != m_pwDspCode)</a>
<a name="ln754">	{</a>
<a name="ln755">		dwReturn = CheckAsicStatus();</a>
<a name="ln756">		if (TRUE == dwReturn)</a>
<a name="ln757">			return ECHOSTATUS_OK;</a>
<a name="ln758">		</a>
<a name="ln759">		//</a>
<a name="ln760">		// ASIC check failed; force the DSP to reload</a>
<a name="ln761">		//	</a>
<a name="ln762">		m_pwDspCode = NULL;</a>
<a name="ln763">	}</a>
<a name="ln764"> </a>
<a name="ln765">	//</a>
<a name="ln766">	// Try and load the DSP</a>
<a name="ln767">	//</a>
<a name="ln768">	dwReturn = LoadDSP( m_pwDspCodeToLoad );</a>
<a name="ln769">	if ( 	(ECHOSTATUS_OK != dwReturn) &amp;&amp; </a>
<a name="ln770">			(ECHOSTATUS_FIRMWARE_LOADED != dwReturn) )</a>
<a name="ln771">	{</a>
<a name="ln772">		return dwReturn;</a>
<a name="ln773">	}</a>
<a name="ln774">	</a>
<a name="ln775">	ECHO_DEBUGPRINTF((&quot;DSP load OK\n&quot;));</a>
<a name="ln776"> </a>
<a name="ln777">	//</a>
<a name="ln778">	// Load the ASIC if the DSP load succeeded; LoadASIC will</a>
<a name="ln779">	// always return TRUE for cards that don't have an ASIC.</a>
<a name="ln780">	//</a>
<a name="ln781">	dwReturn = LoadASIC();</a>
<a name="ln782">	if ( FALSE == dwReturn )</a>
<a name="ln783">	{</a>
<a name="ln784">		dwReturn = ECHOSTATUS_ASIC_NOT_LOADED;</a>
<a name="ln785">	}</a>
<a name="ln786">	else</a>
<a name="ln787">	{</a>
<a name="ln788">		//</a>
<a name="ln789">		// ASIC load was successful</a>
<a name="ln790">		//</a>
<a name="ln791">		RestoreDspSettings();</a>
<a name="ln792"> </a>
<a name="ln793">		dwReturn = ECHOSTATUS_OK;</a>
<a name="ln794">	}</a>
<a name="ln795">	</a>
<a name="ln796">	return dwReturn;</a>
<a name="ln797">	</a>
<a name="ln798">}	// BOOL CDspCommObject::LoadFirmware()</a>
<a name="ln799"> </a>
<a name="ln800"> </a>
<a name="ln801">//===========================================================================</a>
<a name="ln802">//</a>
<a name="ln803">// This function is used to read back the serial number from the DSP;</a>
<a name="ln804">// this is triggered by the SET_COMMPAGE_ADDR command.</a>
<a name="ln805">//</a>
<a name="ln806">// Only some early Echogals products have serial numbers in the ROM;</a>
<a name="ln807">// the serial number is not used, but you still need to do this as</a>
<a name="ln808">// part of the DSP load process.</a>
<a name="ln809">//</a>
<a name="ln810">//===========================================================================</a>
<a name="ln811"> </a>
<a name="ln812">ECHOSTATUS CDspCommObject::ReadSn()</a>
<a name="ln813">{</a>
<a name="ln814">	INT32			j;</a>
<a name="ln815">	DWORD			dwSn[ 6 ];</a>
<a name="ln816">	ECHOSTATUS	Status;</a>
<a name="ln817"> </a>
<a name="ln818">	ECHO_DEBUGPRINTF( (&quot;CDspCommObject::ReadSn\n&quot;) );</a>
<a name="ln819">	for ( j = 0; j &lt; 5; j++ )</a>
<a name="ln820">	{</a>
<a name="ln821">		Status = Read_DSP( &amp;dwSn[ j ] );</a>
<a name="ln822">		if ( Status != 0 )</a>
<a name="ln823">		{</a>
<a name="ln824">			ECHO_DEBUGPRINTF( (&quot;\tFailed to read serial number word %ld\n&quot;,</a>
<a name="ln825">									 j) );</a>
<a name="ln826">			return ECHOSTATUS_DSP_DEAD;</a>
<a name="ln827">		}</a>
<a name="ln828">	}</a>
<a name="ln829">	ECHO_DEBUGPRINTF( (&quot;\tRead serial number %08lx %08lx %08lx %08lx %08lx\n&quot;,</a>
<a name="ln830">							 dwSn[0], dwSn[1], dwSn[2], dwSn[3], dwSn[4]) );</a>
<a name="ln831">	return ECHOSTATUS_OK;</a>
<a name="ln832">	</a>
<a name="ln833">}	// DWORD	CDspCommObject::ReadSn</a>
<a name="ln834"> </a>
<a name="ln835"> </a>
<a name="ln836"> </a>
<a name="ln837"> </a>
<a name="ln838">//===========================================================================</a>
<a name="ln839">//</a>
<a name="ln840">//	This is called after LoadFirmware to restore old gains, meters on, </a>
<a name="ln841">// monitors, etc.</a>
<a name="ln842">//</a>
<a name="ln843">//===========================================================================</a>
<a name="ln844"> </a>
<a name="ln845">void CDspCommObject::RestoreDspSettings()</a>
<a name="ln846">{</a>
<a name="ln847">	ECHO_DEBUGPRINTF((&quot;RestoreDspSettings\n&quot;));</a>
<a name="ln848">	ECHO_DEBUGPRINTF((&quot;\tControl reg is 0x%lx\n&quot;,SWAP(m_pDspCommPage-&gt;dwControlReg) ));</a>
<a name="ln849"> </a>
<a name="ln850">	if ( !CheckAsicStatus() )</a>
<a name="ln851">		return;</a>
<a name="ln852"> </a>
<a name="ln853">	m_pDspCommPage-&gt;dwHandshake = 0xffffffff;		</a>
<a name="ln854">	</a>
<a name="ln855">#ifdef MIDI_SUPPORT</a>
<a name="ln856">	m_ullNextMidiWriteTime = 0;</a>
<a name="ln857">#endif</a>
<a name="ln858">	</a>
<a name="ln859">	SetSampleRate();</a>
<a name="ln860">	if ( 0 != m_wMeterOnCount )</a>
<a name="ln861">	{</a>
<a name="ln862">		SendVector( DSP_VC_METERS_ON );</a>
<a name="ln863">	}</a>
<a name="ln864"> </a>
<a name="ln865">	SetInputClock( m_wInputClock );</a>
<a name="ln866">	SetOutputClock( m_wOutputClock );</a>
<a name="ln867">		</a>
<a name="ln868">	if ( !WaitForHandshake() )</a>
<a name="ln869">	{</a>
<a name="ln870">		return;</a>
<a name="ln871">	}</a>
<a name="ln872">	UpdateAudioOutLineLevel();</a>
<a name="ln873"> </a>
<a name="ln874">	if ( !WaitForHandshake() )</a>
<a name="ln875">		return;</a>
<a name="ln876">	UpdateAudioInLineLevel();</a>
<a name="ln877"> </a>
<a name="ln878">	if ( HasVmixer() )</a>
<a name="ln879">	{</a>
<a name="ln880">		if ( !WaitForHandshake() )</a>
<a name="ln881">			return;</a>
<a name="ln882">		UpdateVmixerLevel();</a>
<a name="ln883">	}</a>
<a name="ln884">	</a>
<a name="ln885">	if ( !WaitForHandshake() )</a>
<a name="ln886">		return;</a>
<a name="ln887"> </a>
<a name="ln888">	ClearHandshake();</a>
<a name="ln889">	SendVector( DSP_VC_UPDATE_FLAGS );</a>
<a name="ln890">	</a>
<a name="ln891">	ECHO_DEBUGPRINTF((&quot;RestoreDspSettings done\n&quot;));	</a>
<a name="ln892">	</a>
<a name="ln893">}	// void CDspCommObject::RestoreDspSettings()</a>
<a name="ln894"> </a>
<a name="ln895"> </a>
<a name="ln896"> </a>
<a name="ln897"> </a>
<a name="ln898">/****************************************************************************</a>
<a name="ln899"> </a>
<a name="ln900">	DSP utilities</a>
<a name="ln901"> </a>
<a name="ln902"> ****************************************************************************/</a>
<a name="ln903"> </a>
<a name="ln904">//===========================================================================</a>
<a name="ln905">//</a>
<a name="ln906">// Write_DSP writes a 32-bit value to the DSP; this is used almost </a>
<a name="ln907">// exclusively for loading the DSP.</a>
<a name="ln908">//</a>
<a name="ln909">//===========================================================================</a>
<a name="ln910"> </a>
<a name="ln911">ECHOSTATUS CDspCommObject::Write_DSP</a>
<a name="ln912">(</a>
<a name="ln913">	DWORD dwData				// 32 bit value to write to DSP data register</a>
<a name="ln914">)</a>
<a name="ln915">{</a>
<a name="ln916">	DWORD 		dwStatus;</a>
<a name="ln917">	ULONGLONG 	ullCurTime, ullTimeout;</a>
<a name="ln918"> </a>
<a name="ln919">//	ECHO_DEBUGPRINTF((&quot;Write_DSP\n&quot;));</a>
<a name="ln920">	</a>
<a name="ln921">	m_pOsSupport-&gt;OsGetSystemTime( &amp;ullCurTime );</a>
<a name="ln922">	ullTimeout = ullCurTime + 10000000L;		// 10 sec.</a>
<a name="ln923">	while ( ullTimeout &gt;= ullCurTime ) </a>
<a name="ln924">	{</a>
<a name="ln925">		dwStatus = GetDspRegister( CHI32_STATUS_REG );</a>
<a name="ln926">		if ( ( dwStatus &amp; CHI32_STATUS_HOST_WRITE_EMPTY ) != 0 )</a>
<a name="ln927">		{</a>
<a name="ln928">			SetDspRegister( CHI32_DATA_REG, dwData );</a>
<a name="ln929">//			ECHO_DEBUGPRINTF((&quot;Write DSP: 0x%x&quot;, dwData));</a>
<a name="ln930">			return ECHOSTATUS_OK;</a>
<a name="ln931">		}</a>
<a name="ln932">		m_pOsSupport-&gt;OsGetSystemTime( &amp;ullCurTime );</a>
<a name="ln933">	}</a>
<a name="ln934"> </a>
<a name="ln935">	m_bBadBoard = TRUE;		// Set TRUE until DSP re-loaded</a>
<a name="ln936">	</a>
<a name="ln937">	ECHO_DEBUGPRINTF((&quot;CDspCommObject::Write_DSP  Set m_bBadBoard to TRUE\n&quot;));</a>
<a name="ln938">		</a>
<a name="ln939">	return ECHOSTATUS_DSP_TIMEOUT;</a>
<a name="ln940">	</a>
<a name="ln941">}	// ECHOSTATUS CDspCommObject::Write_DSP</a>
<a name="ln942"> </a>
<a name="ln943"> </a>
<a name="ln944"> </a>
<a name="ln945"> </a>
<a name="ln946">//===========================================================================</a>
<a name="ln947">//</a>
<a name="ln948">// Read_DSP reads a 32-bit value from the DSP; this is used almost </a>
<a name="ln949">// exclusively for loading the DSP and checking the status of the ASIC.</a>
<a name="ln950">//</a>
<a name="ln951">//===========================================================================</a>
<a name="ln952"> </a>
<a name="ln953">ECHOSTATUS CDspCommObject::Read_DSP</a>
<a name="ln954">(</a>
<a name="ln955">	DWORD *pdwData				// Ptr to 32 bit value read from DSP data register</a>
<a name="ln956">)</a>
<a name="ln957">{</a>
<a name="ln958">	DWORD 		dwStatus;</a>
<a name="ln959">	ULONGLONG	ullCurTime, ullTimeout;</a>
<a name="ln960"> </a>
<a name="ln961">//	ECHO_DEBUGPRINTF((&quot;Read_DSP\n&quot;));</a>
<a name="ln962">	m_pOsSupport-&gt;OsGetSystemTime( &amp;ullCurTime );</a>
<a name="ln963"> </a>
<a name="ln964">	ullTimeout = ullCurTime + READ_DSP_TIMEOUT;	</a>
<a name="ln965">	while ( ullTimeout &gt;= ullCurTime )</a>
<a name="ln966">	{</a>
<a name="ln967">		dwStatus = GetDspRegister( CHI32_STATUS_REG );</a>
<a name="ln968">		if ( ( dwStatus &amp; CHI32_STATUS_HOST_READ_FULL ) != 0 )</a>
<a name="ln969">		{</a>
<a name="ln970">			*pdwData = GetDspRegister( CHI32_DATA_REG );</a>
<a name="ln971">//			ECHO_DEBUGPRINTF((&quot;Read DSP: 0x%x\n&quot;, *pdwData));</a>
<a name="ln972">			return ECHOSTATUS_OK;</a>
<a name="ln973">		}</a>
<a name="ln974">		m_pOsSupport-&gt;OsGetSystemTime( &amp;ullCurTime );</a>
<a name="ln975">	}</a>
<a name="ln976"> </a>
<a name="ln977">	m_bBadBoard = TRUE;		// Set TRUE until DSP re-loaded</a>
<a name="ln978">	</a>
<a name="ln979">	ECHO_DEBUGPRINTF((&quot;CDspCommObject::Read_DSP  Set m_bBadBoard to TRUE\n&quot;));	</a>
<a name="ln980">	</a>
<a name="ln981">	return ECHOSTATUS_DSP_TIMEOUT;</a>
<a name="ln982">}	// ECHOSTATUS CDspCommObject::Read_DSP</a>
<a name="ln983"> </a>
<a name="ln984"> </a>
<a name="ln985"> </a>
<a name="ln986">//===========================================================================</a>
<a name="ln987">//</a>
<a name="ln988">// Much of the interaction between the DSP and the driver is done via vector</a>
<a name="ln989">// commands; SendVector writes a vector command to the DSP.  Typically,</a>
<a name="ln990">// this causes the DSP to read or write fields in the comm page.</a>
<a name="ln991">//</a>
<a name="ln992">// Returns ECHOSTATUS_OK if sent OK.</a>
<a name="ln993">//</a>
<a name="ln994">//===========================================================================</a>
<a name="ln995"> </a>
<a name="ln996">ECHOSTATUS CDspCommObject::SendVector</a>
<a name="ln997">(</a>
<a name="ln998">	DWORD dwCommand				// 32 bit command to send to DSP vector register</a>
<a name="ln999">)</a>
<a name="ln1000">{</a>
<a name="ln1001">	ULONGLONG	ullTimeout;</a>
<a name="ln1002">	ULONGLONG	ullCurTime;</a>
<a name="ln1003"> </a>
<a name="ln1004">//</a>
<a name="ln1005">// Turn this on if you want to see debug prints for every vector command</a>
<a name="ln1006">//</a>
<a name="ln1007">#if 0</a>
<a name="ln1008">//#ifdef ECHO_DEBUG</a>
<a name="ln1009">	char *	pszCmd;</a>
<a name="ln1010">	switch ( dwCommand )</a>
<a name="ln1011">	{</a>
<a name="ln1012">		case DSP_VC_ACK_INT :</a>
<a name="ln1013">			pszCmd = &quot;DSP_VC_ACK_INT&quot;;</a>
<a name="ln1014">			break;</a>
<a name="ln1015">		case DSP_VC_SET_VMIXER_GAIN :</a>
<a name="ln1016">			pszCmd = &quot;DSP_VC_SET_VMIXER_GAIN&quot;;</a>
<a name="ln1017">			break;</a>
<a name="ln1018">		case DSP_VC_START_TRANSFER :</a>
<a name="ln1019">			pszCmd = &quot;DSP_VC_START_TRANSFER&quot;;</a>
<a name="ln1020">			break;</a>
<a name="ln1021">		case DSP_VC_METERS_ON :</a>
<a name="ln1022">			pszCmd = &quot;DSP_VC_METERS_ON&quot;;</a>
<a name="ln1023">			break;</a>
<a name="ln1024">		case DSP_VC_METERS_OFF :</a>
<a name="ln1025">			pszCmd = &quot;DSP_VC_METERS_OFF&quot;;</a>
<a name="ln1026">			break;</a>
<a name="ln1027">		case DSP_VC_UPDATE_OUTVOL :</a>
<a name="ln1028">			pszCmd = &quot;DSP_VC_UPDATE_OUTVOL&quot;;</a>
<a name="ln1029">			break;</a>
<a name="ln1030">		case DSP_VC_UPDATE_INGAIN :</a>
<a name="ln1031">			pszCmd = &quot;DSP_VC_UPDATE_INGAIN&quot;;</a>
<a name="ln1032">			break;</a>
<a name="ln1033">		case DSP_VC_ADD_AUDIO_BUFFER :</a>
<a name="ln1034">			pszCmd = &quot;DSP_VC_ADD_AUDIO_BUFFER&quot;;</a>
<a name="ln1035">			break;</a>
<a name="ln1036">		case DSP_VC_TEST_ASIC :</a>
<a name="ln1037">			pszCmd = &quot;DSP_VC_TEST_ASIC&quot;;</a>
<a name="ln1038">			break;</a>
<a name="ln1039">		case DSP_VC_UPDATE_CLOCKS :</a>
<a name="ln1040">			pszCmd = &quot;DSP_VC_UPDATE_CLOCKS&quot;;</a>
<a name="ln1041">			break;</a>
<a name="ln1042">		case DSP_VC_SET_LAYLA_SAMPLE_RATE :</a>
<a name="ln1043">			if ( GetCardType() == LAYLA )</a>
<a name="ln1044">				pszCmd = &quot;DSP_VC_SET_LAYLA_RATE&quot;;</a>
<a name="ln1045">			else if ( GetCardType() == GINA || GetCardType() == DARLA )</a>
<a name="ln1046">				pszCmd = &quot;DSP_VC_SET_GD_AUDIO_STATE&quot;;</a>
<a name="ln1047">			else</a>
<a name="ln1048">				pszCmd = &quot;DSP_VC_WRITE_CONTROL_REG&quot;;</a>
<a name="ln1049">			break;</a>
<a name="ln1050">		case DSP_VC_MIDI_WRITE :</a>
<a name="ln1051">			pszCmd = &quot;DSP_VC_MIDI_WRITE&quot;;</a>
<a name="ln1052">			break;</a>
<a name="ln1053">		case DSP_VC_STOP_TRANSFER :</a>
<a name="ln1054">			pszCmd = &quot;DSP_VC_STOP_TRANSFER&quot;;</a>
<a name="ln1055">			break;</a>
<a name="ln1056">		case DSP_VC_UPDATE_FLAGS :</a>
<a name="ln1057">			pszCmd = &quot;DSP_VC_UPDATE_FLAGS&quot;;</a>
<a name="ln1058">			break;</a>
<a name="ln1059">		case DSP_VC_RESET :</a>
<a name="ln1060">			pszCmd = &quot;DSP_VC_RESET&quot;;</a>
<a name="ln1061">			break;</a>
<a name="ln1062">		default :</a>
<a name="ln1063">			pszCmd = &quot;?????&quot;;</a>
<a name="ln1064">			break;</a>
<a name="ln1065">	}</a>
<a name="ln1066"> </a>
<a name="ln1067">	ECHO_DEBUGPRINTF( (&quot;SendVector: %s dwCommand %s (0x%x)\n&quot;,</a>
<a name="ln1068">								GetCardName(),</a>
<a name="ln1069">								pszCmd,</a>
<a name="ln1070">								dwCommand) );				</a>
<a name="ln1071">#endif</a>
<a name="ln1072"> </a>
<a name="ln1073">	m_pOsSupport-&gt;OsGetSystemTime( &amp;ullCurTime );</a>
<a name="ln1074">	ullTimeout = ullCurTime + 100000L;		// 100m.s.</a>
<a name="ln1075"> </a>
<a name="ln1076">	//</a>
<a name="ln1077">	// Wait for the &quot;vector busy&quot; bit to be off</a>
<a name="ln1078">	//</a>
<a name="ln1079">	while ( ullCurTime &lt;= ullTimeout) </a>
<a name="ln1080">	{</a>
<a name="ln1081">		DWORD dwReg;</a>
<a name="ln1082"> </a>
<a name="ln1083">		dwReg = GetDspRegister( CHI32_VECTOR_REG );</a>
<a name="ln1084">		if ( 0 == (dwReg &amp; CHI32_VECTOR_BUSY) )</a>
<a name="ln1085">		{</a>
<a name="ln1086">			SetDspRegister( CHI32_VECTOR_REG, dwCommand );</a>
<a name="ln1087">			</a>
<a name="ln1088">			return ECHOSTATUS_OK;</a>
<a name="ln1089">		}</a>
<a name="ln1090">		m_pOsSupport-&gt;OsGetSystemTime( &amp;ullCurTime );</a>
<a name="ln1091">	}</a>
<a name="ln1092"> </a>
<a name="ln1093">	ECHO_DEBUGPRINTF( (&quot;\tPunked out on SendVector\n&quot;) );</a>
<a name="ln1094">	ECHO_DEBUGBREAK();</a>
<a name="ln1095">	return ECHOSTATUS_DSP_TIMEOUT;</a>
<a name="ln1096">	</a>
<a name="ln1097">}	// ECHOSTATUS CDspCommObject::SendVector</a>
<a name="ln1098"> </a>
<a name="ln1099"> </a>
<a name="ln1100"> </a>
<a name="ln1101">//===========================================================================</a>
<a name="ln1102">//</a>
<a name="ln1103">//	Some vector commands involve the DSP reading or writing data to and</a>
<a name="ln1104">// from the comm page; if you send one of these commands to the DSP,</a>
<a name="ln1105">// it will complete the command and then write a non-zero value to</a>
<a name="ln1106">// the dwHandshake field in the comm page.  This function waits for the </a>
<a name="ln1107">// handshake to show up.</a>
<a name="ln1108">//</a>
<a name="ln1109">//===========================================================================</a>
<a name="ln1110"> </a>
<a name="ln1111">BOOL CDspCommObject::WaitForHandshake()</a>
<a name="ln1112">{</a>
<a name="ln1113">	ULONGLONG ullDelta;</a>
<a name="ln1114">	ULONGLONG ullStartTime,ullTime;</a>
<a name="ln1115">	</a>
<a name="ln1116">	//</a>
<a name="ln1117">	// Wait up to three milliseconds for the handshake from the DSP </a>
<a name="ln1118">	//</a>
<a name="ln1119">	m_pOsSupport-&gt;OsGetSystemTime( &amp;ullStartTime );</a>
<a name="ln1120">	do</a>
<a name="ln1121">	{</a>
<a name="ln1122">		// Look for the handshake value</a>
<a name="ln1123">		if ( 0 != GetHandshakeFlag() )</a>
<a name="ln1124">		{</a>
<a name="ln1125">			return TRUE;</a>
<a name="ln1126">		}</a>
<a name="ln1127"> </a>
<a name="ln1128">		// Give the DSP time to access the comm page</a>
<a name="ln1129">		m_pOsSupport-&gt;OsSnooze( 2 );</a>
<a name="ln1130">		</a>
<a name="ln1131">		m_pOsSupport-&gt;OsGetSystemTime(&amp;ullTime);</a>
<a name="ln1132">		ullDelta = ullTime - ullStartTime;</a>
<a name="ln1133">	} while (ullDelta &lt; (ULONGLONG) HANDSHAKE_TIMEOUT);</a>
<a name="ln1134"> </a>
<a name="ln1135">	ECHO_DEBUGPRINTF( (&quot;CDspCommObject::WaitForHandshake: Timeout waiting &quot;</a>
<a name="ln1136">								&quot;for DSP\n&quot;) );</a>
<a name="ln1137">	ECHO_DEBUGBREAK();</a>
<a name="ln1138">	return FALSE;</a>
<a name="ln1139">	</a>
<a name="ln1140">}		// DWORD	CDspCommObject::WaitForHandshake()</a>
<a name="ln1141"> </a>
<a name="ln1142"> </a>
<a name="ln1143"> </a>
<a name="ln1144"> </a>
<a name="ln1145">/****************************************************************************</a>
<a name="ln1146"> </a>
<a name="ln1147">	Transport methods</a>
<a name="ln1148"> </a>
<a name="ln1149"> ****************************************************************************/</a>
<a name="ln1150"> </a>
<a name="ln1151">//===========================================================================</a>
<a name="ln1152">//</a>
<a name="ln1153">// StartTransport starts transport for a set of pipes</a>
<a name="ln1154">//</a>
<a name="ln1155">//===========================================================================</a>
<a name="ln1156"> </a>
<a name="ln1157">ECHOSTATUS CDspCommObject::StartTransport</a>
<a name="ln1158">(</a>
<a name="ln1159">	PCChannelMask	pChannelMask			// Pipes to start</a>
<a name="ln1160">)</a>
<a name="ln1161">{</a>
<a name="ln1162">	ECHO_DEBUGPRINTF( (&quot;StartTransport\n&quot;) );</a>
<a name="ln1163"> </a>
<a name="ln1164">	//</a>
<a name="ln1165">	// Wait for the previous command to complete</a>
<a name="ln1166">	//</a>
<a name="ln1167">	if ( !WaitForHandshake() )</a>
<a name="ln1168">		return ECHOSTATUS_DSP_DEAD;</a>
<a name="ln1169"> </a>
<a name="ln1170">	//</a>
<a name="ln1171">	// Write the appropriate fields in the comm page</a>
<a name="ln1172">	//</a>
<a name="ln1173">	m_pDspCommPage-&gt;cmdStart.Clear();</a>
<a name="ln1174">	m_pDspCommPage-&gt;cmdStart = *pChannelMask;</a>
<a name="ln1175">	if ( !m_pDspCommPage-&gt;cmdStart.IsEmpty() )</a>
<a name="ln1176">	{</a>
<a name="ln1177">		//</a>
<a name="ln1178">		// Clear the handshake and send the vector command</a>
<a name="ln1179">		//</a>
<a name="ln1180">		ClearHandshake();</a>
<a name="ln1181">		SendVector( DSP_VC_START_TRANSFER );</a>
<a name="ln1182"> </a>
<a name="ln1183">		//</a>
<a name="ln1184">		// Keep track of which pipes are transporting</a>
<a name="ln1185">		//</a>
<a name="ln1186">		m_cmActive += *pChannelMask;</a>
<a name="ln1187"> </a>
<a name="ln1188">		return ECHOSTATUS_OK;</a>
<a name="ln1189">	}		// if this monkey is being started</a>
<a name="ln1190"> </a>
<a name="ln1191">	ECHO_DEBUGPRINTF( (&quot;CDspCommObject::StartTransport: No pipes to start!\n&quot;) );</a>
<a name="ln1192">	return ECHOSTATUS_INVALID_CHANNEL;</a>
<a name="ln1193">	</a>
<a name="ln1194">}	// ECHOSTATUS CDspCommObject::StartTransport</a>
<a name="ln1195"> </a>
<a name="ln1196"> </a>
<a name="ln1197">//===========================================================================</a>
<a name="ln1198">//</a>
<a name="ln1199">// StopTransport pauses transport for a set of pipes</a>
<a name="ln1200">//</a>
<a name="ln1201">//===========================================================================</a>
<a name="ln1202"> </a>
<a name="ln1203">ECHOSTATUS CDspCommObject::StopTransport</a>
<a name="ln1204">(</a>
<a name="ln1205">	PCChannelMask	pChannelMask</a>
<a name="ln1206">)</a>
<a name="ln1207">{</a>
<a name="ln1208">	ECHO_DEBUGPRINTF((&quot;StopTransport\n&quot;));</a>
<a name="ln1209"> </a>
<a name="ln1210">	//</a>
<a name="ln1211">	// Wait for the last command to finish</a>
<a name="ln1212">	//</a>
<a name="ln1213">	if ( !WaitForHandshake() )</a>
<a name="ln1214">		return ECHOSTATUS_DSP_DEAD;</a>
<a name="ln1215"> </a>
<a name="ln1216">	//</a>
<a name="ln1217">	// Write to the comm page</a>
<a name="ln1218">	//</a>
<a name="ln1219">	m_pDspCommPage-&gt;cmdStop.Clear();</a>
<a name="ln1220">	m_pDspCommPage-&gt;cmdStop = *pChannelMask;</a>
<a name="ln1221">	m_pDspCommPage-&gt;cmdReset.Clear();</a>
<a name="ln1222">	if ( !m_pDspCommPage-&gt;cmdStop.IsEmpty() )</a>
<a name="ln1223">	{</a>
<a name="ln1224">		//</a>
<a name="ln1225">		// Clear the handshake and send the vector command</a>
<a name="ln1226">		//</a>
<a name="ln1227">		ClearHandshake();</a>
<a name="ln1228">		SendVector( DSP_VC_STOP_TRANSFER );</a>
<a name="ln1229"> </a>
<a name="ln1230">		//</a>
<a name="ln1231">		// Keep track of which pipes are transporting</a>
<a name="ln1232">		//</a>
<a name="ln1233">		m_cmActive -= *pChannelMask;</a>
<a name="ln1234"> </a>
<a name="ln1235">		return ECHOSTATUS_OK;</a>
<a name="ln1236">	}		// if this monkey is being started</a>
<a name="ln1237"> </a>
<a name="ln1238">	ECHO_DEBUGPRINTF( (&quot;CDspCommObject::StopTransport: No pipes to stop!\n&quot;) );</a>
<a name="ln1239">	return ECHOSTATUS_OK;</a>
<a name="ln1240"> </a>
<a name="ln1241">}	// ECHOSTATUS CDspCommObject::StopTransport</a>
<a name="ln1242"> </a>
<a name="ln1243"> </a>
<a name="ln1244">//===========================================================================</a>
<a name="ln1245">//</a>
<a name="ln1246">// ResetTransport resets transport for a set of pipes</a>
<a name="ln1247">//</a>
<a name="ln1248">//===========================================================================</a>
<a name="ln1249"> </a>
<a name="ln1250">ECHOSTATUS CDspCommObject::ResetTransport</a>
<a name="ln1251">(</a>
<a name="ln1252">	PCChannelMask	pChannelMask</a>
<a name="ln1253">)</a>
<a name="ln1254">{</a>
<a name="ln1255">	ECHO_DEBUGPRINTF((&quot;ResetTransport\n&quot;));</a>
<a name="ln1256"> </a>
<a name="ln1257">	//</a>
<a name="ln1258">	// Wait for the last command to finish</a>
<a name="ln1259">	//</a>
<a name="ln1260">	if ( !WaitForHandshake() )</a>
<a name="ln1261">		return ECHOSTATUS_DSP_DEAD;</a>
<a name="ln1262"> </a>
<a name="ln1263">	//</a>
<a name="ln1264">	// Write to the comm page</a>
<a name="ln1265">	//</a>
<a name="ln1266">	m_pDspCommPage-&gt;cmdStop.Clear();</a>
<a name="ln1267">	m_pDspCommPage-&gt;cmdReset.Clear();</a>
<a name="ln1268">	m_pDspCommPage-&gt;cmdStop = *pChannelMask;</a>
<a name="ln1269">	m_pDspCommPage-&gt;cmdReset = *pChannelMask;</a>
<a name="ln1270">	if ( !m_pDspCommPage-&gt;cmdReset.IsEmpty() )</a>
<a name="ln1271">	{</a>
<a name="ln1272">		//</a>
<a name="ln1273">		// Clear the handshake and send the vector command</a>
<a name="ln1274">		//</a>
<a name="ln1275">		ClearHandshake();</a>
<a name="ln1276">		SendVector( DSP_VC_STOP_TRANSFER );</a>
<a name="ln1277"> </a>
<a name="ln1278">		//</a>
<a name="ln1279">		// Keep track of which pipes are transporting</a>
<a name="ln1280">		//</a>
<a name="ln1281">		m_cmActive -= *pChannelMask;</a>
<a name="ln1282"> </a>
<a name="ln1283">		return ECHOSTATUS_OK;</a>
<a name="ln1284">	}		// if this monkey is being started</a>
<a name="ln1285"> </a>
<a name="ln1286">	ECHO_DEBUGPRINTF( (&quot;CDspCommObject::ResetTransport: No pipes to reset!\n&quot;) );</a>
<a name="ln1287">	return ECHOSTATUS_OK;</a>
<a name="ln1288"> </a>
<a name="ln1289">}	// ECHOSTATUS CDspCommObject::ResetTransport</a>
<a name="ln1290"> </a>
<a name="ln1291"> </a>
<a name="ln1292">//===========================================================================</a>
<a name="ln1293">//</a>
<a name="ln1294">// This tells the DSP where to start reading the scatter-gather list</a>
<a name="ln1295">// for a given pipe.</a>
<a name="ln1296">//</a>
<a name="ln1297">//===========================================================================</a>
<a name="ln1298"> </a>
<a name="ln1299">void CDspCommObject::SetAudioDuckListPhys</a>
<a name="ln1300">(</a>
<a name="ln1301">	WORD	wPipeIndex,			// Pipe index</a>
<a name="ln1302">	DWORD dwNewPhysAdr		// Physical address asserted on the PCI bus</a>
<a name="ln1303">)</a>
<a name="ln1304">{</a>
<a name="ln1305">	if (wPipeIndex &lt; GetNumPipes() )</a>
<a name="ln1306">	{</a>
<a name="ln1307">		m_pDspCommPage-&gt;DuckListPhys[ wPipeIndex ].PhysAddr = </a>
<a name="ln1308">																		SWAP( dwNewPhysAdr );</a>
<a name="ln1309">	}</a>
<a name="ln1310">}	// void CDspCommObject::SetAudioDuckListPhys</a>
<a name="ln1311"> </a>
<a name="ln1312"> </a>
<a name="ln1313"> </a>
<a name="ln1314">//===========================================================================</a>
<a name="ln1315">//</a>
<a name="ln1316">// Get a mask with active pipes</a>
<a name="ln1317">//</a>
<a name="ln1318">//===========================================================================</a>
<a name="ln1319"> </a>
<a name="ln1320">void CDspCommObject::GetActivePipes</a>
<a name="ln1321">(</a>
<a name="ln1322">	PCChannelMask	pChannelMask</a>
<a name="ln1323">)</a>
<a name="ln1324">{</a>
<a name="ln1325">	pChannelMask-&gt;Clear();</a>
<a name="ln1326">	*pChannelMask += m_cmActive;</a>
<a name="ln1327">}	// void CDspCommObject::GetActivePipes()</a>
<a name="ln1328"> </a>
<a name="ln1329"> </a>
<a name="ln1330">//===========================================================================</a>
<a name="ln1331">//</a>
<a name="ln1332">//	Set the audio format for a pipe</a>
<a name="ln1333">//</a>
<a name="ln1334">//===========================================================================</a>
<a name="ln1335"> </a>
<a name="ln1336">ECHOSTATUS CDspCommObject::SetAudioFormat</a>
<a name="ln1337">(</a>
<a name="ln1338">	WORD 							wPipeIndex,</a>
<a name="ln1339">	PECHOGALS_AUDIOFORMAT	pFormat</a>
<a name="ln1340">)</a>
<a name="ln1341">{</a>
<a name="ln1342">	WORD wDspFormat = DSP_AUDIOFORM_SS_16LE;</a>
<a name="ln1343">	</a>
<a name="ln1344">	ECHO_DEBUGPRINTF((&quot;CDspCommObject::SetAudioFormat - pipe %d  bps %d  channels %d\n&quot;,</a>
<a name="ln1345">							wPipeIndex,pFormat-&gt;wBitsPerSample,pFormat-&gt;wDataInterleave));</a>
<a name="ln1346"> </a>
<a name="ln1347">	//</a>
<a name="ln1348">	// Check the pipe number</a>
<a name="ln1349">	//</a>
<a name="ln1350">	if (wPipeIndex &gt;= GetNumPipes() )</a>
<a name="ln1351">	{</a>
<a name="ln1352">		ECHO_DEBUGPRINTF( (&quot;CDspCommObject::SetAudioFormat: Invalid pipe&quot;</a>
<a name="ln1353">								 &quot;%d\n&quot;,</a>
<a name="ln1354">								 wPipeIndex) );</a>
<a name="ln1355">		return ECHOSTATUS_INVALID_CHANNEL;</a>
<a name="ln1356">	}</a>
<a name="ln1357"> </a>
<a name="ln1358">	//</a>
<a name="ln1359">	// Look for super-interleave</a>
<a name="ln1360">	//</a>
<a name="ln1361">	if (pFormat-&gt;wDataInterleave &gt; 2)</a>
<a name="ln1362">	{</a>
<a name="ln1363">		switch (pFormat-&gt;wBitsPerSample)</a>
<a name="ln1364">		{</a>
<a name="ln1365">			case 16 :</a>
<a name="ln1366">				wDspFormat = DSP_AUDIOFORM_SUPER_INTERLEAVE_16LE;</a>
<a name="ln1367">				break;</a>
<a name="ln1368">				</a>
<a name="ln1369">			case 24 :</a>
<a name="ln1370">				wDspFormat = DSP_AUDIOFORM_SUPER_INTERLEAVE_24LE;</a>
<a name="ln1371">				break;</a>
<a name="ln1372">				</a>
<a name="ln1373">			case 32 :</a>
<a name="ln1374">				wDspFormat = DSP_AUDIOFORM_SUPER_INTERLEAVE_32LE;</a>
<a name="ln1375">				break;</a>
<a name="ln1376">		}</a>
<a name="ln1377">		</a>
<a name="ln1378">		wDspFormat |= pFormat-&gt;wDataInterleave;</a>
<a name="ln1379">	}</a>
<a name="ln1380">	else</a>
<a name="ln1381">	{</a>
<a name="ln1382">		//</a>
<a name="ln1383">		// For big-endian data, only 32 bit mono-&gt;mono samples and 32 bit stereo-&gt;stereo</a>
<a name="ln1384">		// are supported</a>
<a name="ln1385">		//</a>
<a name="ln1386">		if (pFormat-&gt;byDataAreBigEndian)</a>
<a name="ln1387">		{</a>
<a name="ln1388">			</a>
<a name="ln1389">			switch ( pFormat-&gt;wDataInterleave )</a>
<a name="ln1390">			{</a>
<a name="ln1391">				case 1 :</a>
<a name="ln1392">					wDspFormat = DSP_AUDIOFORM_MM_32BE;</a>
<a name="ln1393">					break;</a>
<a name="ln1394">					</a>
<a name="ln1395">#ifdef STEREO_BIG_ENDIAN32_SUPPORT</a>
<a name="ln1396">				case 2 :</a>
<a name="ln1397">					wDspFormat = DSP_AUDIOFORM_SS_32BE;</a>
<a name="ln1398">					break;</a>
<a name="ln1399">#endif</a>
<a name="ln1400"> </a>
<a name="ln1401">			}</a>
<a name="ln1402">		}</a>
<a name="ln1403">		else</a>
<a name="ln1404">		{</a>
<a name="ln1405">			//</a>
<a name="ln1406">			// Check for 32 bit little-endian mono-&gt;mono case</a>
<a name="ln1407">			//</a>
<a name="ln1408">			if ( 	(1 == pFormat-&gt;wDataInterleave) &amp;&amp;</a>
<a name="ln1409">					(32 == pFormat-&gt;wBitsPerSample) &amp;&amp;</a>
<a name="ln1410">					(0 == pFormat-&gt;byMonoToStereo) )</a>
<a name="ln1411">			{</a>
<a name="ln1412">				wDspFormat = DSP_AUDIOFORM_MM_32LE;</a>
<a name="ln1413">			}</a>
<a name="ln1414">			else</a>
<a name="ln1415">			{</a>
<a name="ln1416">				//</a>
<a name="ln1417">				// Handle the other little-endian formats</a>
<a name="ln1418">				//</a>
<a name="ln1419">				switch (pFormat-&gt;wBitsPerSample)</a>
<a name="ln1420">				{</a>
<a name="ln1421">					case 8 :</a>
<a name="ln1422">						if (2 == pFormat-&gt;wDataInterleave)</a>
<a name="ln1423">							wDspFormat = DSP_AUDIOFORM_SS_8;</a>
<a name="ln1424">						else</a>
<a name="ln1425">							wDspFormat = DSP_AUDIOFORM_MS_8;</a>
<a name="ln1426"> </a>
<a name="ln1427">						break;</a>
<a name="ln1428">				</a>
<a name="ln1429">					default :		</a>
<a name="ln1430">					case 16 :</a>
<a name="ln1431">						if (2 == pFormat-&gt;wDataInterleave)</a>
<a name="ln1432">							wDspFormat = DSP_AUDIOFORM_SS_16LE;</a>
<a name="ln1433">						else</a>
<a name="ln1434">							wDspFormat = DSP_AUDIOFORM_MS_16LE;</a>
<a name="ln1435">						break;	</a>
<a name="ln1436">					</a>
<a name="ln1437">					case 24 :</a>
<a name="ln1438">						if (2 == pFormat-&gt;wDataInterleave)</a>
<a name="ln1439">							wDspFormat = DSP_AUDIOFORM_SS_24LE;</a>
<a name="ln1440">						else</a>
<a name="ln1441">							wDspFormat = DSP_AUDIOFORM_MS_24LE;</a>
<a name="ln1442">						break;					</a>
<a name="ln1443">					</a>
<a name="ln1444">					case 32 :</a>
<a name="ln1445">						if (2 == pFormat-&gt;wDataInterleave)</a>
<a name="ln1446">							wDspFormat = DSP_AUDIOFORM_SS_32LE;</a>
<a name="ln1447">						else</a>
<a name="ln1448">							wDspFormat = DSP_AUDIOFORM_MS_32LE;</a>
<a name="ln1449">						break;					</a>
<a name="ln1450">				}</a>
<a name="ln1451">				</a>
<a name="ln1452">			} // check other little-endian formats</a>
<a name="ln1453">		</a>
<a name="ln1454">		} // not big endian data</a>
<a name="ln1455">		</a>
<a name="ln1456">	} // not super-interleave</a>
<a name="ln1457">	</a>
<a name="ln1458">	m_pDspCommPage-&gt;wAudioFormat[wPipeIndex] = SWAP( wDspFormat );	</a>
<a name="ln1459">	</a>
<a name="ln1460">	return ECHOSTATUS_OK;</a>
<a name="ln1461"> </a>
<a name="ln1462">}	// ECHOSTATUS CDspCommObject::SetAudioFormat</a>
<a name="ln1463"> </a>
<a name="ln1464"> </a>
<a name="ln1465">//===========================================================================</a>
<a name="ln1466">//</a>
<a name="ln1467">//	Get the audio format for a pipe</a>
<a name="ln1468">//</a>
<a name="ln1469">//===========================================================================</a>
<a name="ln1470"> </a>
<a name="ln1471">ECHOSTATUS CDspCommObject::GetAudioFormat</a>
<a name="ln1472">( </a>
<a name="ln1473">	WORD 							wPipeIndex,</a>
<a name="ln1474">	PECHOGALS_AUDIOFORMAT	pFormat</a>
<a name="ln1475">)</a>
<a name="ln1476">{</a>
<a name="ln1477">	if (wPipeIndex &gt;= GetNumPipes() )</a>
<a name="ln1478">	{</a>
<a name="ln1479">		ECHO_DEBUGPRINTF( (&quot;CDspCommObject::GetAudioFormat: Invalid pipe %d\n&quot;,</a>
<a name="ln1480">								 wPipeIndex) );</a>
<a name="ln1481"> </a>
<a name="ln1482">		return ECHOSTATUS_INVALID_CHANNEL;</a>
<a name="ln1483">	}</a>
<a name="ln1484"> </a>
<a name="ln1485">	pFormat-&gt;byDataAreBigEndian = 0;	// true for most of the formats</a>
<a name="ln1486">	pFormat-&gt;byMonoToStereo = 0;</a>
<a name="ln1487">	</a>
<a name="ln1488">	switch (SWAP(m_pDspCommPage-&gt;wAudioFormat[wPipeIndex]))</a>
<a name="ln1489">	{</a>
<a name="ln1490">		case DSP_AUDIOFORM_MS_8 :</a>
<a name="ln1491">			pFormat-&gt;wDataInterleave = 1;</a>
<a name="ln1492">			pFormat-&gt;wBitsPerSample = 8;</a>
<a name="ln1493">			pFormat-&gt;byMonoToStereo = 1;</a>
<a name="ln1494">			break;</a>
<a name="ln1495">			</a>
<a name="ln1496">		case DSP_AUDIOFORM_MS_16LE :</a>
<a name="ln1497">			pFormat-&gt;wDataInterleave = 1;</a>
<a name="ln1498">			pFormat-&gt;wBitsPerSample = 16;</a>
<a name="ln1499">			pFormat-&gt;byMonoToStereo = 1;			</a>
<a name="ln1500">			break;</a>
<a name="ln1501">			</a>
<a name="ln1502">		case DSP_AUDIOFORM_SS_8 :</a>
<a name="ln1503">			pFormat-&gt;wDataInterleave = 2;</a>
<a name="ln1504">			pFormat-&gt;wBitsPerSample = 8;</a>
<a name="ln1505">			break;</a>
<a name="ln1506"> </a>
<a name="ln1507">		case DSP_AUDIOFORM_SS_16LE :</a>
<a name="ln1508">			pFormat-&gt;wDataInterleave = 2;</a>
<a name="ln1509">			pFormat-&gt;wBitsPerSample = 16;</a>
<a name="ln1510">			break;</a>
<a name="ln1511">		</a>
<a name="ln1512">		case DSP_AUDIOFORM_SS_32LE :</a>
<a name="ln1513">			pFormat-&gt;wDataInterleave = 2;</a>
<a name="ln1514">			pFormat-&gt;wBitsPerSample = 32;</a>
<a name="ln1515">			break;			</a>
<a name="ln1516">		</a>
<a name="ln1517">		case DSP_AUDIOFORM_MS_32LE :</a>
<a name="ln1518">			pFormat-&gt;byMonoToStereo = 1;			</a>
<a name="ln1519">			// fall through</a>
<a name="ln1520"> </a>
<a name="ln1521">		case DSP_AUDIOFORM_MM_32LE :</a>
<a name="ln1522">			pFormat-&gt;wDataInterleave = 1;</a>
<a name="ln1523">			pFormat-&gt;wBitsPerSample = 32;</a>
<a name="ln1524">			break;			</a>
<a name="ln1525">			</a>
<a name="ln1526">		case DSP_AUDIOFORM_MM_32BE :</a>
<a name="ln1527">			pFormat-&gt;wDataInterleave = 1;</a>
<a name="ln1528">			pFormat-&gt;wBitsPerSample = 32;</a>
<a name="ln1529">			pFormat-&gt;byDataAreBigEndian = 1;</a>
<a name="ln1530">			break;			</a>
<a name="ln1531">			</a>
<a name="ln1532">		case DSP_AUDIOFORM_SS_32BE :</a>
<a name="ln1533">			pFormat-&gt;wDataInterleave = 2;</a>
<a name="ln1534">			pFormat-&gt;wBitsPerSample = 32;</a>
<a name="ln1535">			pFormat-&gt;byDataAreBigEndian = 1;</a>
<a name="ln1536">			break;			</a>
<a name="ln1537">		</a>
<a name="ln1538">	}</a>
<a name="ln1539">	</a>
<a name="ln1540">	return ECHOSTATUS_OK;</a>
<a name="ln1541">	</a>
<a name="ln1542">}	// void CDspCommObject::GetAudioFormat</a>
<a name="ln1543"> </a>
<a name="ln1544"> </a>
<a name="ln1545"> </a>
<a name="ln1546">/****************************************************************************</a>
<a name="ln1547"> </a>
<a name="ln1548">	Mixer methods</a>
<a name="ln1549"> </a>
<a name="ln1550"> ****************************************************************************/</a>
<a name="ln1551"> </a>
<a name="ln1552">//===========================================================================</a>
<a name="ln1553">//</a>
<a name="ln1554">// SetPipeOutGain - set the gain for a single output pipe</a>
<a name="ln1555">//</a>
<a name="ln1556">//===========================================================================</a>
<a name="ln1557"> </a>
<a name="ln1558">ECHOSTATUS CDspCommObject::SetPipeOutGain</a>
<a name="ln1559">( </a>
<a name="ln1560">	WORD 	wPipeOut, </a>
<a name="ln1561">	WORD	wBusOut,</a>
<a name="ln1562">	INT32	iGain,</a>
<a name="ln1563">	BOOL 	fImmediate</a>
<a name="ln1564">)</a>
<a name="ln1565">{</a>
<a name="ln1566">	if ( wPipeOut &lt; m_wNumPipesOut )</a>
<a name="ln1567">	{</a>
<a name="ln1568">		//</a>
<a name="ln1569">		// Wait for the handshake</a>
<a name="ln1570">		//</a>
<a name="ln1571">		if ( !WaitForHandshake() )</a>
<a name="ln1572">			return ECHOSTATUS_DSP_DEAD;</a>
<a name="ln1573">			</a>
<a name="ln1574">		//</a>
<a name="ln1575">		// Save the new value</a>
<a name="ln1576">		//</a>
<a name="ln1577">		iGain = GENERIC_TO_DSP(iGain);</a>
<a name="ln1578">		m_pDspCommPage-&gt;OutLineLevel[ wPipeOut ] = (BYTE) iGain;</a>
<a name="ln1579"> </a>
<a name="ln1580">		/*</a>
<a name="ln1581">		ECHO_DEBUGPRINTF( (&quot;CDspCommObject::SetPipeOutGain: Out pipe %d &quot;</a>
<a name="ln1582">								 &quot;= 0x%lx\n&quot;,</a>
<a name="ln1583">								 wPipeOut,</a>
<a name="ln1584">								 iGain) );</a>
<a name="ln1585">		*/</a>
<a name="ln1586"> </a>
<a name="ln1587">		//</a>
<a name="ln1588">		// If fImmediate is true, then do the gain setting right now.</a>
<a name="ln1589">		// If you want to do a batch of gain settings all at once, it's</a>
<a name="ln1590">		// more efficient to call this several times and then only set</a>
<a name="ln1591">		// fImmediate for the last one; then the DSP picks up all of</a>
<a name="ln1592">		// them at once.</a>
<a name="ln1593">		//								 </a>
<a name="ln1594">		if (fImmediate)</a>
<a name="ln1595">		{</a>
<a name="ln1596">			return UpdateAudioOutLineLevel();</a>
<a name="ln1597">		}</a>
<a name="ln1598"> </a>
<a name="ln1599">		return ECHOSTATUS_OK;		</a>
<a name="ln1600"> </a>
<a name="ln1601">	}</a>
<a name="ln1602"> </a>
<a name="ln1603">	ECHO_DEBUGPRINTF( (&quot;CDspCommObject::SetPipeOutGain: Invalid out pipe &quot;</a>
<a name="ln1604">							 &quot;%d\n&quot;,</a>
<a name="ln1605">							 wPipeOut) );</a>
<a name="ln1606">	ECHO_DEBUGBREAK();	 </a>
<a name="ln1607">							 </a>
<a name="ln1608">	return ECHOSTATUS_INVALID_CHANNEL;</a>
<a name="ln1609">	</a>
<a name="ln1610">}	// SetPipeOutGain</a>
<a name="ln1611"> </a>
<a name="ln1612"> </a>
<a name="ln1613">//===========================================================================</a>
<a name="ln1614">//</a>
<a name="ln1615">// GetPipeOutGain returns the current gain for an output pipe.  This isn't</a>
<a name="ln1616">// really used as the mixer code in CEchoGals stores logical values for</a>
<a name="ln1617">// these, but it's here for completeness.</a>
<a name="ln1618">//</a>
<a name="ln1619">//===========================================================================</a>
<a name="ln1620"> </a>
<a name="ln1621">ECHOSTATUS CDspCommObject::GetPipeOutGain</a>
<a name="ln1622">( </a>
<a name="ln1623">	WORD 	wPipeOut, </a>
<a name="ln1624">	WORD 	wBusOut,</a>
<a name="ln1625">	INT32 &amp;iGain</a>
<a name="ln1626">)</a>
<a name="ln1627">{</a>
<a name="ln1628">	if (wPipeOut &lt; m_wNumPipesOut)</a>
<a name="ln1629">	{</a>
<a name="ln1630">		iGain = (INT32) (char) m_pDspCommPage-&gt;OutLineLevel[ wPipeOut ];</a>
<a name="ln1631">		iGain = DSP_TO_GENERIC(8);</a>
<a name="ln1632">		return ECHOSTATUS_OK;		</a>
<a name="ln1633">	}</a>
<a name="ln1634"> </a>
<a name="ln1635">	ECHO_DEBUGPRINTF( (&quot;CDspCommObject::GetPipeOutGain: Invalid out pipe &quot;</a>
<a name="ln1636">							 &quot;%d\n&quot;,</a>
<a name="ln1637">							 wPipeOut) );</a>
<a name="ln1638">							 </a>
<a name="ln1639">	return ECHOSTATUS_INVALID_CHANNEL;</a>
<a name="ln1640">	</a>
<a name="ln1641">}	// GetPipeOutGain</a>
<a name="ln1642"> </a>
<a name="ln1643">	</a>
<a name="ln1644"> </a>
<a name="ln1645">//===========================================================================</a>
<a name="ln1646">//</a>
<a name="ln1647">// Set input bus gain - iGain is in units of 0.5 dB</a>
<a name="ln1648">//</a>
<a name="ln1649">//===========================================================================</a>
<a name="ln1650"> </a>
<a name="ln1651">ECHOSTATUS CDspCommObject::SetBusInGain( WORD wBusIn, INT32 iGain)</a>
<a name="ln1652">{</a>
<a name="ln1653">	if (wBusIn &gt; m_wNumBussesIn)</a>
<a name="ln1654">		return ECHOSTATUS_INVALID_CHANNEL;</a>
<a name="ln1655"> </a>
<a name="ln1656">	//</a>
<a name="ln1657">	// Wait for the handshake (OK even if ASIC is not loaded)</a>
<a name="ln1658">	//</a>
<a name="ln1659">	if ( !WaitForHandshake() )</a>
<a name="ln1660">		return ECHOSTATUS_DSP_DEAD;</a>
<a name="ln1661">		</a>
<a name="ln1662">	//</a>
<a name="ln1663">	// Adjust the gain value</a>
<a name="ln1664">	//		</a>
<a name="ln1665">	iGain += GL20_INPUT_GAIN_MAGIC_NUMBER;</a>
<a name="ln1666">	</a>
<a name="ln1667">	//</a>
<a name="ln1668">	// Put it in the comm page</a>
<a name="ln1669">	//</a>
<a name="ln1670">	m_pDspCommPage-&gt;InLineLevel[wBusIn] = (BYTE) iGain;</a>
<a name="ln1671"> </a>
<a name="ln1672">	return UpdateAudioInLineLevel();</a>
<a name="ln1673">}	</a>
<a name="ln1674"> </a>
<a name="ln1675"> </a>
<a name="ln1676">//===========================================================================</a>
<a name="ln1677">//</a>
<a name="ln1678">// Get the input bus gain in units of 0.5 dB</a>
<a name="ln1679">//</a>
<a name="ln1680">//===========================================================================</a>
<a name="ln1681"> </a>
<a name="ln1682">ECHOSTATUS CDspCommObject::GetBusInGain( WORD wBusIn, INT32 &amp;iGain)</a>
<a name="ln1683">{</a>
<a name="ln1684">	if (wBusIn &gt; m_wNumBussesIn)</a>
<a name="ln1685">		return ECHOSTATUS_INVALID_CHANNEL;</a>
<a name="ln1686">		</a>
<a name="ln1687">	iGain = m_pDspCommPage-&gt;InLineLevel[wBusIn];</a>
<a name="ln1688">	iGain -= GL20_INPUT_GAIN_MAGIC_NUMBER;</a>
<a name="ln1689"> </a>
<a name="ln1690">	return ECHOSTATUS_OK;</a>
<a name="ln1691">}	</a>
<a name="ln1692"> </a>
<a name="ln1693"> </a>
<a name="ln1694">//===========================================================================</a>
<a name="ln1695">//</a>
<a name="ln1696">//	Set the nominal level for an input or output bus</a>
<a name="ln1697">//</a>
<a name="ln1698">// bState TRUE			-10 nominal level</a>
<a name="ln1699">// bState FALSE		+4 nominal level</a>
<a name="ln1700">//</a>
<a name="ln1701">//===========================================================================</a>
<a name="ln1702"> </a>
<a name="ln1703">ECHOSTATUS CDspCommObject::SetNominalLevel</a>
<a name="ln1704">(</a>
<a name="ln1705">	WORD	wBus,</a>
<a name="ln1706">	BOOL	bState</a>
<a name="ln1707">)</a>
<a name="ln1708">{</a>
<a name="ln1709">	//</a>
<a name="ln1710">	// Check the pipe index</a>
<a name="ln1711">	//</a>
<a name="ln1712">	if (wBus &lt; (m_wNumBussesOut + m_wNumBussesIn))</a>
<a name="ln1713">	{</a>
<a name="ln1714">		//</a>
<a name="ln1715">		// Wait for the handshake (OK even if ASIC is not loaded)</a>
<a name="ln1716">		//</a>
<a name="ln1717">		if ( !WaitForHandshake() )</a>
<a name="ln1718">			return ECHOSTATUS_DSP_DEAD;</a>
<a name="ln1719"> </a>
<a name="ln1720">		//</a>
<a name="ln1721">		// Set the nominal bit</a>
<a name="ln1722">		//		</a>
<a name="ln1723">		if ( bState )</a>
<a name="ln1724">			m_pDspCommPage-&gt;cmdNominalLevel.SetIndexInMask( wBus );</a>
<a name="ln1725">		else</a>
<a name="ln1726">			m_pDspCommPage-&gt;cmdNominalLevel.ClearIndexInMask( wBus );</a>
<a name="ln1727"> </a>
<a name="ln1728">		return UpdateAudioOutLineLevel();</a>
<a name="ln1729">	}</a>
<a name="ln1730"> </a>
<a name="ln1731">	ECHO_DEBUGPRINTF( (&quot;CDspCommObject::SetNominalOutLineLevel Invalid &quot;</a>
<a name="ln1732">							 &quot;index %d\n&quot;,</a>
<a name="ln1733">							 wBus ) );</a>
<a name="ln1734">	return ECHOSTATUS_INVALID_CHANNEL;</a>
<a name="ln1735"> </a>
<a name="ln1736">}	// ECHOSTATUS CDspCommObject::SetNominalLevel</a>
<a name="ln1737"> </a>
<a name="ln1738"> </a>
<a name="ln1739">//===========================================================================</a>
<a name="ln1740">//</a>
<a name="ln1741">//	Get the nominal level for an input or output bus</a>
<a name="ln1742">//</a>
<a name="ln1743">// bState TRUE			-10 nominal level</a>
<a name="ln1744">// bState FALSE		+4 nominal level</a>
<a name="ln1745">//</a>
<a name="ln1746">//===========================================================================</a>
<a name="ln1747"> </a>
<a name="ln1748">ECHOSTATUS CDspCommObject::GetNominalLevel</a>
<a name="ln1749">(</a>
<a name="ln1750">	WORD	wBus,</a>
<a name="ln1751">	PBYTE pbyState</a>
<a name="ln1752">)</a>
<a name="ln1753">{</a>
<a name="ln1754"> </a>
<a name="ln1755">	if (wBus &lt; (m_wNumBussesOut + m_wNumBussesIn))</a>
<a name="ln1756">	{</a>
<a name="ln1757">		*pbyState = (BYTE)</a>
<a name="ln1758">			m_pDspCommPage-&gt;cmdNominalLevel.TestIndexInMask( wBus );</a>
<a name="ln1759">		return ECHOSTATUS_OK;</a>
<a name="ln1760">	}</a>
<a name="ln1761"> </a>
<a name="ln1762">	ECHO_DEBUGPRINTF( (&quot;CDspCommObject::GetNominalLevel Invalid &quot;</a>
<a name="ln1763">							 &quot;index %d\n&quot;,</a>
<a name="ln1764">							 wBus ) );</a>
<a name="ln1765">	return ECHOSTATUS_INVALID_CHANNEL;</a>
<a name="ln1766">}	// ECHOSTATUS CDspCommObject::GetNominalLevel</a>
<a name="ln1767"> </a>
<a name="ln1768"> </a>
<a name="ln1769">//===========================================================================</a>
<a name="ln1770">//</a>
<a name="ln1771">//	Set the monitor level from an input bus to an output bus.</a>
<a name="ln1772">//</a>
<a name="ln1773">//===========================================================================</a>
<a name="ln1774"> </a>
<a name="ln1775">ECHOSTATUS CDspCommObject::SetAudioMonitor</a>
<a name="ln1776">(</a>
<a name="ln1777">	WORD	wBusOut,	// output bus</a>
<a name="ln1778">	WORD	wBusIn,	// input bus</a>
<a name="ln1779">	INT32	iGain,</a>
<a name="ln1780">	BOOL 	fImmediate</a>
<a name="ln1781">)</a>
<a name="ln1782">{</a>
<a name="ln1783">	/*</a>
<a name="ln1784">	ECHO_DEBUGPRINTF( (&quot;CDspCommObject::SetAudioMonitor: &quot;</a>
<a name="ln1785">							 &quot;Out %d in %d Gain %d (0x%x)\n&quot;,</a>
<a name="ln1786">							 wBusOut, wBusIn, iGain, iGain) );</a>
<a name="ln1787">	*/</a>
<a name="ln1788"> </a>
<a name="ln1789">	//</a>
<a name="ln1790">	// The monitor array is a one-dimensional array;</a>
<a name="ln1791">	// compute the offset into the array</a>
<a name="ln1792">	//</a>
<a name="ln1793">	WORD	wOffset = ComputeAudioMonitorIndex( wBusOut, wBusIn );</a>
<a name="ln1794"> </a>
<a name="ln1795">	//</a>
<a name="ln1796">	// Wait for the offset</a>
<a name="ln1797">	//	</a>
<a name="ln1798">	if ( !WaitForHandshake() )</a>
<a name="ln1799">		return ECHOSTATUS_DSP_DEAD;</a>
<a name="ln1800"> </a>
<a name="ln1801">	//</a>
<a name="ln1802">	// Write the gain value to the comm page</a>
<a name="ln1803">	//</a>
<a name="ln1804">	iGain = GENERIC_TO_DSP(iGain);</a>
<a name="ln1805">	m_pDspCommPage-&gt;byMonitors[ wOffset ] = (BYTE) (iGain);</a>
<a name="ln1806">	</a>
<a name="ln1807">	//</a>
<a name="ln1808">	// If fImmediate is set, do the command right now</a>
<a name="ln1809">	//</a>
<a name="ln1810">	if (fImmediate)</a>
<a name="ln1811">	{</a>
<a name="ln1812">		return UpdateAudioOutLineLevel();</a>
<a name="ln1813">	}</a>
<a name="ln1814">	</a>
<a name="ln1815">	return ECHOSTATUS_OK;</a>
<a name="ln1816"> </a>
<a name="ln1817">}	// ECHOSTATUS CDspCommObject::SetAudioMonitor</a>
<a name="ln1818"> </a>
<a name="ln1819"> </a>
<a name="ln1820">//===========================================================================</a>
<a name="ln1821">//</a>
<a name="ln1822">// SetMetersOn turns the meters on or off.  If meters are turned on, the</a>
<a name="ln1823">// DSP will write the meter and clock detect values to the comm page</a>
<a name="ln1824">// at about 30 Hz.</a>
<a name="ln1825">//</a>
<a name="ln1826">//===========================================================================</a>
<a name="ln1827"> </a>
<a name="ln1828">ECHOSTATUS CDspCommObject::SetMetersOn</a>
<a name="ln1829">(</a>
<a name="ln1830">	BOOL bOn</a>
<a name="ln1831">)</a>
<a name="ln1832">{</a>
<a name="ln1833">	if ( bOn )</a>
<a name="ln1834">	{</a>
<a name="ln1835">		if ( 0 == m_wMeterOnCount )</a>
<a name="ln1836">		{</a>
<a name="ln1837">			SendVector( DSP_VC_METERS_ON );</a>
<a name="ln1838">		}</a>
<a name="ln1839">		m_wMeterOnCount++;</a>
<a name="ln1840">	}</a>
<a name="ln1841">	else</a>
<a name="ln1842">	{</a>
<a name="ln1843">		INT32	iDevice;</a>
<a name="ln1844">	</a>
<a name="ln1845">		if ( m_wMeterOnCount == 0 )</a>
<a name="ln1846">			return ECHOSTATUS_OK;</a>
<a name="ln1847"> </a>
<a name="ln1848">		if ( 0 == --m_wMeterOnCount )</a>
<a name="ln1849">		{</a>
<a name="ln1850">			SendVector( DSP_VC_METERS_OFF );</a>
<a name="ln1851">			</a>
<a name="ln1852">			for ( iDevice = 0; iDevice &lt; DSP_MAXPIPES; iDevice++ )</a>
<a name="ln1853">			{</a>
<a name="ln1854">				BYTE muted;</a>
<a name="ln1855"> </a>
<a name="ln1856">				muted = (BYTE) GENERIC_TO_DSP(ECHOGAIN_MUTED);</a>
<a name="ln1857">				m_pDspCommPage-&gt;VUMeter[ iDevice ]   = muted;</a>
<a name="ln1858">				m_pDspCommPage-&gt;PeakMeter[ iDevice ] = muted;</a>
<a name="ln1859">			}</a>
<a name="ln1860">		}</a>
<a name="ln1861">	}</a>
<a name="ln1862">	return ECHOSTATUS_OK;</a>
<a name="ln1863">	</a>
<a name="ln1864">}	// ECHOSTATUS CDspCommObject::SetMetersOn</a>
<a name="ln1865"> </a>
<a name="ln1866"> </a>
<a name="ln1867">//===========================================================================</a>
<a name="ln1868">//</a>
<a name="ln1869">// Tell the DSP to read and update output, nominal &amp; monitor levels </a>
<a name="ln1870">//	in comm page.</a>
<a name="ln1871">//</a>
<a name="ln1872">//===========================================================================</a>
<a name="ln1873"> </a>
<a name="ln1874">ECHOSTATUS CDspCommObject::UpdateAudioOutLineLevel()</a>
<a name="ln1875">{</a>
<a name="ln1876">	//ECHO_DEBUGPRINTF( ( &quot;CDspCommObject::UpdateAudioOutLineLevel:\n&quot; ) );</a>
<a name="ln1877">	</a>
<a name="ln1878">	if (FALSE == m_bASICLoaded)</a>
<a name="ln1879">		return ECHOSTATUS_ASIC_NOT_LOADED;</a>
<a name="ln1880">	</a>
<a name="ln1881">	ClearHandshake();</a>
<a name="ln1882">	return( SendVector( DSP_VC_UPDATE_OUTVOL ) );</a>
<a name="ln1883">	</a>
<a name="ln1884">}	// ECHOSTATUS CDspCommObject::UpdateAudioOutLineLevel()</a>
<a name="ln1885"> </a>
<a name="ln1886"> </a>
<a name="ln1887">//===========================================================================</a>
<a name="ln1888">//</a>
<a name="ln1889">// Tell the DSP to read and update input levels in comm page</a>
<a name="ln1890">//</a>
<a name="ln1891">//===========================================================================</a>
<a name="ln1892"> </a>
<a name="ln1893">ECHOSTATUS CDspCommObject::UpdateAudioInLineLevel()</a>
<a name="ln1894">{</a>
<a name="ln1895">	//ECHO_DEBUGPRINTF( ( &quot;CDspCommObject::UpdateAudioInLineLevel:\n&quot; ) );</a>
<a name="ln1896">	</a>
<a name="ln1897">	if (FALSE == m_bASICLoaded)</a>
<a name="ln1898">		return ECHOSTATUS_ASIC_NOT_LOADED;</a>
<a name="ln1899"> </a>
<a name="ln1900">	ClearHandshake();</a>
<a name="ln1901">	return( SendVector( DSP_VC_UPDATE_INGAIN ) );</a>
<a name="ln1902">}		// ECHOSTATUS CDspCommObject::UpdateAudioInLineLevel()</a>
<a name="ln1903"> </a>
<a name="ln1904"> </a>
<a name="ln1905">//===========================================================================</a>
<a name="ln1906">//</a>
<a name="ln1907">// Tell the DSP to read and update virtual mixer levels </a>
<a name="ln1908">//	in comm page.  This method is overridden by cards that actually </a>
<a name="ln1909">// support a vmixer.</a>
<a name="ln1910">//</a>
<a name="ln1911">//===========================================================================</a>
<a name="ln1912"> </a>
<a name="ln1913">ECHOSTATUS CDspCommObject::UpdateVmixerLevel()</a>
<a name="ln1914">{</a>
<a name="ln1915">	ECHO_DEBUGPRINTF((&quot;CDspCommObject::UpdateVmixerLevel\n&quot;));</a>
<a name="ln1916">	return ECHOSTATUS_NOT_SUPPORTED;</a>
<a name="ln1917">}	// ECHOSTATUS CDspCommObject::UpdateVmixerLevel()</a>
<a name="ln1918"> </a>
<a name="ln1919"> </a>
<a name="ln1920">//===========================================================================</a>
<a name="ln1921">//</a>
<a name="ln1922">// Tell the DSP to change the input clock</a>
<a name="ln1923">//</a>
<a name="ln1924">//===========================================================================</a>
<a name="ln1925"> </a>
<a name="ln1926">ECHOSTATUS CDspCommObject::SetInputClock(WORD wClock)</a>
<a name="ln1927">{</a>
<a name="ln1928">	//</a>
<a name="ln1929">	// Wait for the last command</a>
<a name="ln1930">	//</a>
<a name="ln1931">	if (!WaitForHandshake())</a>
<a name="ln1932">		return ECHOSTATUS_DSP_DEAD;</a>
<a name="ln1933"> </a>
<a name="ln1934">	ECHO_DEBUGPRINTF( (&quot;CDspCommObject::SetInputClock:\n&quot;) );		</a>
<a name="ln1935">		</a>
<a name="ln1936">	//</a>
<a name="ln1937">	// Write to the comm page</a>
<a name="ln1938">	//</a>
<a name="ln1939">	m_pDspCommPage-&gt;wInputClock = SWAP(wClock);</a>
<a name="ln1940">	</a>
<a name="ln1941">	//</a>
<a name="ln1942">	// Clear the handshake and send the command</a>
<a name="ln1943">	//</a>
<a name="ln1944">	ClearHandshake();</a>
<a name="ln1945">	ECHOSTATUS Status = SendVector(DSP_VC_UPDATE_CLOCKS);</a>
<a name="ln1946">	</a>
<a name="ln1947">	return Status;</a>
<a name="ln1948"> </a>
<a name="ln1949">}	// ECHOSTATUS CDspCommObject::SetInputClock</a>
<a name="ln1950"> </a>
<a name="ln1951"> </a>
<a name="ln1952">//===========================================================================</a>
<a name="ln1953">//</a>
<a name="ln1954">// Tell the DSP to change the output clock - Layla20 only</a>
<a name="ln1955">//</a>
<a name="ln1956">//===========================================================================</a>
<a name="ln1957"> </a>
<a name="ln1958">ECHOSTATUS CDspCommObject::SetOutputClock(WORD wClock)</a>
<a name="ln1959">{</a>
<a name="ln1960"> </a>
<a name="ln1961">	return ECHOSTATUS_CLOCK_NOT_SUPPORTED;</a>
<a name="ln1962">	</a>
<a name="ln1963">}	// ECHOSTATUS CDspCommObject::SetOutputClock</a>
<a name="ln1964"> </a>
<a name="ln1965"> </a>
<a name="ln1966">//===========================================================================</a>
<a name="ln1967">//</a>
<a name="ln1968">// Fill out an ECHOGALS_METERS struct using the current values in the </a>
<a name="ln1969">// comm page.  This method is overridden for vmixer cards.</a>
<a name="ln1970">//</a>
<a name="ln1971">//===========================================================================</a>
<a name="ln1972"> </a>
<a name="ln1973">ECHOSTATUS CDspCommObject::GetAudioMeters</a>
<a name="ln1974">(</a>
<a name="ln1975">	PECHOGALS_METERS	pMeters</a>
<a name="ln1976">)</a>
<a name="ln1977">{</a>
<a name="ln1978">	pMeters-&gt;iNumPipesOut = 0;</a>
<a name="ln1979">	pMeters-&gt;iNumPipesIn = 0;</a>
<a name="ln1980"> </a>
<a name="ln1981">	//</a>
<a name="ln1982">	//	Output </a>
<a name="ln1983">	// </a>
<a name="ln1984">	DWORD dwCh = 0;</a>
<a name="ln1985">	WORD 	i;</a>
<a name="ln1986"> </a>
<a name="ln1987">	pMeters-&gt;iNumBussesOut = (INT32) m_wNumBussesOut;</a>
<a name="ln1988">	for (i = 0; i &lt; m_wNumBussesOut; i++)</a>
<a name="ln1989">	{</a>
<a name="ln1990">		pMeters-&gt;iBusOutVU[i] = </a>
<a name="ln1991">			DSP_TO_GENERIC( ((INT32) (INT8) m_pDspCommPage-&gt;VUMeter[ dwCh ]) );</a>
<a name="ln1992"> </a>
<a name="ln1993">		pMeters-&gt;iBusOutPeak[i] = </a>
<a name="ln1994">			DSP_TO_GENERIC( ((INT32) (INT8) m_pDspCommPage-&gt;PeakMeter[ dwCh ]) );</a>
<a name="ln1995">		</a>
<a name="ln1996">		dwCh++;</a>
<a name="ln1997">	}</a>
<a name="ln1998"> </a>
<a name="ln1999">	pMeters-&gt;iNumBussesIn = (INT32) m_wNumBussesIn;	</a>
<a name="ln2000">	for (i = 0; i &lt; m_wNumBussesIn; i++)</a>
<a name="ln2001">	{</a>
<a name="ln2002">		pMeters-&gt;iBusInVU[i] = </a>
<a name="ln2003">			DSP_TO_GENERIC( ((INT32) (INT8) m_pDspCommPage-&gt;VUMeter[ dwCh ]) );</a>
<a name="ln2004">		pMeters-&gt;iBusInPeak[i] = </a>
<a name="ln2005">			DSP_TO_GENERIC( ((INT32) (INT8) m_pDspCommPage-&gt;PeakMeter[ dwCh ]) );</a>
<a name="ln2006">		</a>
<a name="ln2007">		dwCh++;</a>
<a name="ln2008">	}</a>
<a name="ln2009">	</a>
<a name="ln2010">	return ECHOSTATUS_OK;</a>
<a name="ln2011">	</a>
<a name="ln2012">} // GetAudioMeters</a>
<a name="ln2013"> </a>
<a name="ln2014"> </a>
<a name="ln2015">#ifdef DIGITAL_INPUT_AUTO_MUTE_SUPPORT</a>
<a name="ln2016"> </a>
<a name="ln2017">//===========================================================================</a>
<a name="ln2018">//</a>
<a name="ln2019">// Digital input auto-mute - Gina24, Layla24, and Mona only</a>
<a name="ln2020">//</a>
<a name="ln2021">//===========================================================================</a>
<a name="ln2022"> </a>
<a name="ln2023">ECHOSTATUS CDspCommObject::GetDigitalInputAutoMute(BOOL &amp;fAutoMute)</a>
<a name="ln2024">{</a>
<a name="ln2025">	fAutoMute = m_fDigitalInAutoMute;	</a>
<a name="ln2026">	</a>
<a name="ln2027">	ECHO_DEBUGPRINTF((&quot;CDspCommObject::GetDigitalInputAutoMute %d\n&quot;,fAutoMute));</a>
<a name="ln2028">	</a>
<a name="ln2029">	return ECHOSTATUS_OK;</a>
<a name="ln2030">}</a>
<a name="ln2031"> </a>
<a name="ln2032">ECHOSTATUS CDspCommObject::SetDigitalInputAutoMute(BOOL fAutoMute)</a>
<a name="ln2033">{</a>
<a name="ln2034">	ECHO_DEBUGPRINTF((&quot;CDspCommObject::SetDigitalInputAutoMute %d\n&quot;,fAutoMute));</a>
<a name="ln2035">	</a>
<a name="ln2036">	//</a>
<a name="ln2037">	// Store the flag</a>
<a name="ln2038">	//</a>
<a name="ln2039">	m_fDigitalInAutoMute = fAutoMute;</a>
<a name="ln2040">	</a>
<a name="ln2041">	//</a>
<a name="ln2042">	// Re-set the input clock to the current value - indirectly causes the </a>
<a name="ln2043">	// auto-mute flag to be sent to the DSP</a>
<a name="ln2044">	//</a>
<a name="ln2045">	SetInputClock(m_wInputClock);</a>
<a name="ln2046">	</a>
<a name="ln2047">	return ECHOSTATUS_OK;</a>
<a name="ln2048">}</a>
<a name="ln2049"> </a>
<a name="ln2050">#endif // DIGITAL_INPUT_AUTO_MUTE_SUPPORT</a>
<a name="ln2051"> </a>
<a name="ln2052"> </a>
<a name="ln2053"> </a>
<a name="ln2054"> </a>
<a name="ln2055">/****************************************************************************</a>
<a name="ln2056"> </a>
<a name="ln2057">	Power management</a>
<a name="ln2058"> </a>
<a name="ln2059"> ****************************************************************************/</a>
<a name="ln2060"> </a>
<a name="ln2061">//===========================================================================</a>
<a name="ln2062">//</a>
<a name="ln2063">// Tell the DSP to go into low-power mode</a>
<a name="ln2064">//</a>
<a name="ln2065">//===========================================================================</a>
<a name="ln2066"> </a>
<a name="ln2067">ECHOSTATUS CDspCommObject::GoComatose()</a>
<a name="ln2068">{</a>
<a name="ln2069">	ECHO_DEBUGPRINTF((&quot;CDspCommObject::GoComatose\n&quot;));</a>
<a name="ln2070"> </a>
<a name="ln2071">	if (NULL != m_pwDspCode)</a>
<a name="ln2072">	{</a>
<a name="ln2073">		//</a>
<a name="ln2074">		// Make LoadFirmware do a complete reload</a>
<a name="ln2075">		//	</a>
<a name="ln2076">		m_pwDspCode = NULL;</a>
<a name="ln2077">		</a>
<a name="ln2078">		//</a>
<a name="ln2079">		// Make sure that the sample rate get re-set on wakeup</a>
<a name="ln2080">		// (really only for Indigo and Mia)</a>
<a name="ln2081">		//</a>
<a name="ln2082">		m_pDspCommPage-&gt;dwControlReg = 0;</a>
<a name="ln2083">		</a>
<a name="ln2084">		//</a>
<a name="ln2085">		// Put the DSP to sleep</a>
<a name="ln2086">		//</a>
<a name="ln2087">		return SendVector(DSP_VC_GO_COMATOSE);</a>
<a name="ln2088">	}</a>
<a name="ln2089">	</a>
<a name="ln2090">	return ECHOSTATUS_OK;</a>
<a name="ln2091"> </a>
<a name="ln2092">}	// end of GoComatose</a>
<a name="ln2093"> </a>
<a name="ln2094"> </a>
<a name="ln2095"> </a>
<a name="ln2096">#ifdef MIDI_SUPPORT</a>
<a name="ln2097"> </a>
<a name="ln2098">/****************************************************************************</a>
<a name="ln2099"> </a>
<a name="ln2100">	MIDI</a>
<a name="ln2101"> </a>
<a name="ln2102"> ****************************************************************************/</a>
<a name="ln2103"> </a>
<a name="ln2104">//===========================================================================</a>
<a name="ln2105">//</a>
<a name="ln2106">// Send a buffer full of MIDI data to the DSP</a>
<a name="ln2107">//</a>
<a name="ln2108">//===========================================================================</a>
<a name="ln2109"> </a>
<a name="ln2110">ECHOSTATUS CDspCommObject::WriteMidi</a>
<a name="ln2111">(</a>
<a name="ln2112">	PBYTE		pData,						// Ptr to data buffer</a>
<a name="ln2113">	DWORD		dwLength,					// How many bytes to write</a>
<a name="ln2114">	PDWORD	pdwActualCt					// Return how many actually written</a>
<a name="ln2115">)</a>
<a name="ln2116">{</a>
<a name="ln2117">	DWORD 		dwWriteCount,dwHandshake,dwStatus;</a>
<a name="ln2118">	BYTE			*pOutBuffer;</a>
<a name="ln2119">	</a>
<a name="ln2120">	</a>
<a name="ln2121">	//</a>
<a name="ln2122">	// Return immediately if the handshake flag is clar</a>
<a name="ln2123">	//</a>
<a name="ln2124">	dwHandshake = GetHandshakeFlag();</a>
<a name="ln2125">	if (0 == dwHandshake)</a>
<a name="ln2126">	{</a>
<a name="ln2127">		ECHO_DEBUGPRINTF((&quot;CDCO::WriteMidi - can't write - handshake %ld\n&quot;,dwHandshake));</a>
<a name="ln2128">		</a>
<a name="ln2129">		*pdwActualCt = 0;</a>
<a name="ln2130">		return ECHOSTATUS_BUSY;</a>
<a name="ln2131">	}</a>
<a name="ln2132">	</a>
<a name="ln2133">	//</a>
<a name="ln2134">	// Return immediately if HF4 is clear - HF4 indicates that it is safe</a>
<a name="ln2135">	// to write MIDI output data</a>
<a name="ln2136">	//</a>
<a name="ln2137">	dwStatus = GetDspRegister( CHI32_STATUS_REG );</a>
<a name="ln2138">	if ( 0 == (dwStatus &amp; CHI32_STATUS_REG_HF4 ) )</a>
<a name="ln2139">	{</a>
<a name="ln2140">		ECHO_DEBUGPRINTF((&quot;CDCO::WriteMidi - can't write - dwStatus 0x%lx\n&quot;,dwStatus));</a>
<a name="ln2141">		</a>
<a name="ln2142">		*pdwActualCt = 0;</a>
<a name="ln2143">		return ECHOSTATUS_BUSY;</a>
<a name="ln2144">	}</a>
<a name="ln2145">	</a>
<a name="ln2146">	</a>
<a name="ln2147">	//</a>
<a name="ln2148">	// Copy data to the comm page; limit to the amount of space in the DSP output</a>
<a name="ln2149">	// FIFO and in the comm page</a>
<a name="ln2150">	//</a>
<a name="ln2151">	dwWriteCount = dwLength;</a>
<a name="ln2152">	if (dwWriteCount &gt; (CP_MIDI_OUT_BUFFER_SIZE - 1))</a>
<a name="ln2153">	{</a>
<a name="ln2154">		dwWriteCount = CP_MIDI_OUT_BUFFER_SIZE - 1;</a>
<a name="ln2155">	}</a>
<a name="ln2156"> </a>
<a name="ln2157">	ECHO_DEBUGPRINTF((&quot;WriteMidi - dwWriteCount %ld\n&quot;,dwWriteCount));</a>
<a name="ln2158">			</a>
<a name="ln2159">	*pdwActualCt = dwWriteCount;	// Save the # of bytes written for the caller</a>
<a name="ln2160"> </a>
<a name="ln2161">	pOutBuffer = m_pDspCommPage-&gt;byMidiOutData;</a>
<a name="ln2162">	*pOutBuffer = (BYTE) dwWriteCount;</a>
<a name="ln2163">	</a>
<a name="ln2164">	pOutBuffer++;</a>
<a name="ln2165">	</a>
<a name="ln2166">	OsCopyMemory(pOutBuffer,pData,dwWriteCount);</a>
<a name="ln2167"> </a>
<a name="ln2168">	//</a>
<a name="ln2169">	// Send the command to the DSP</a>
<a name="ln2170">	//	 </a>
<a name="ln2171">	ClearHandshake();</a>
<a name="ln2172">	m_pDspCommPage-&gt;dwMidiOutFreeCount = 0;</a>
<a name="ln2173">	SendVector( DSP_VC_MIDI_WRITE );</a>
<a name="ln2174">	</a>
<a name="ln2175">	//</a>
<a name="ln2176">	// Save the current time - used to detect if MIDI out is currently busy</a>
<a name="ln2177">	//</a>
<a name="ln2178">	ULONGLONG ullTime;</a>
<a name="ln2179"> </a>
<a name="ln2180">	m_pOsSupport-&gt;OsGetSystemTime( &amp;ullTime );</a>
<a name="ln2181">	m_ullMidiOutTime = ullTime;</a>
<a name="ln2182">														</a>
<a name="ln2183">	return ECHOSTATUS_OK;</a>
<a name="ln2184">	</a>
<a name="ln2185">}		// ECHOSTATUS CDspCommObject::WriteMidi</a>
<a name="ln2186"> </a>
<a name="ln2187"> </a>
<a name="ln2188">//===========================================================================</a>
<a name="ln2189">//</a>
<a name="ln2190">// Called from the interrupt handler - get a MIDI input byte</a>
<a name="ln2191">//</a>
<a name="ln2192">//===========================================================================</a>
<a name="ln2193"> </a>
<a name="ln2194">ECHOSTATUS CDspCommObject::ReadMidi</a>
<a name="ln2195">(</a>
<a name="ln2196">	WORD 		wIndex,				// Buffer index</a>
<a name="ln2197">	DWORD &amp;	dwData				// Return data</a>
<a name="ln2198">)</a>
<a name="ln2199">{</a>
<a name="ln2200">	if ( wIndex &gt;= CP_MIDI_IN_BUFFER_SIZE )</a>
<a name="ln2201">		return ECHOSTATUS_INVALID_INDEX;</a>
<a name="ln2202"> </a>
<a name="ln2203">	//</a>
<a name="ln2204">	// Get the data</a>
<a name="ln2205">	//	</a>
<a name="ln2206">	dwData = SWAP( m_pDspCommPage-&gt;wMidiInData[ wIndex ] );</a>
<a name="ln2207"> </a>
<a name="ln2208">	//</a>
<a name="ln2209">	// Timestamp for the MIDI input activity indicator</a>
<a name="ln2210">	//</a>
<a name="ln2211">	ULONGLONG ullTime;</a>
<a name="ln2212"> </a>
<a name="ln2213">	m_pOsSupport-&gt;OsGetSystemTime( &amp;ullTime );</a>
<a name="ln2214">	m_ullMidiInTime = ullTime;</a>
<a name="ln2215"> </a>
<a name="ln2216">	return ECHOSTATUS_OK;</a>
<a name="ln2217">	</a>
<a name="ln2218">}	// ECHOSTATUS CDspCommObject::ReadMidi</a>
<a name="ln2219"> </a>
<a name="ln2220"> </a>
<a name="ln2221">ECHOSTATUS CDspCommObject::SetMidiOn( BOOL bOn )</a>
<a name="ln2222">{</a>
<a name="ln2223">	if ( bOn )</a>
<a name="ln2224">	{</a>
<a name="ln2225">		if ( 0 == m_wMidiOnCount )</a>
<a name="ln2226">		{</a>
<a name="ln2227">			if ( !WaitForHandshake() )</a>
<a name="ln2228">				return ECHOSTATUS_DSP_DEAD;</a>
<a name="ln2229"> </a>
<a name="ln2230">			m_pDspCommPage-&gt;dwFlags |= SWAP( (DWORD) DSP_FLAG_MIDI_INPUT );</a>
<a name="ln2231">			</a>
<a name="ln2232">			ClearHandshake();</a>
<a name="ln2233">			SendVector( DSP_VC_UPDATE_FLAGS );</a>
<a name="ln2234">		}</a>
<a name="ln2235">		m_wMidiOnCount++;</a>
<a name="ln2236">	}</a>
<a name="ln2237">	else</a>
<a name="ln2238">	{</a>
<a name="ln2239">		if ( m_wMidiOnCount == 0 )</a>
<a name="ln2240">			return ECHOSTATUS_OK;</a>
<a name="ln2241"> </a>
<a name="ln2242">		if ( 0 == --m_wMidiOnCount )</a>
<a name="ln2243">		{</a>
<a name="ln2244">			if ( !WaitForHandshake() )</a>
<a name="ln2245">				return ECHOSTATUS_DSP_DEAD;</a>
<a name="ln2246">				</a>
<a name="ln2247">			m_pDspCommPage-&gt;dwFlags &amp;= SWAP( (DWORD) ~DSP_FLAG_MIDI_INPUT );</a>
<a name="ln2248">			</a>
<a name="ln2249">			ClearHandshake();</a>
<a name="ln2250">			SendVector( DSP_VC_UPDATE_FLAGS );</a>
<a name="ln2251">		}</a>
<a name="ln2252">	}</a>
<a name="ln2253"> </a>
<a name="ln2254">	return ECHOSTATUS_OK;</a>
<a name="ln2255"> </a>
<a name="ln2256">}	// ECHOSTATUS CDspCommObject::SetMidiOn</a>
<a name="ln2257"> </a>
<a name="ln2258"> </a>
<a name="ln2259">//===========================================================================</a>
<a name="ln2260">//</a>
<a name="ln2261">// Detect MIDI output activity</a>
<a name="ln2262">//</a>
<a name="ln2263">//===========================================================================</a>
<a name="ln2264"> </a>
<a name="ln2265">BOOL CDspCommObject::IsMidiOutActive()</a>
<a name="ln2266">{</a>
<a name="ln2267">	ULONGLONG	ullCurTime;</a>
<a name="ln2268"> </a>
<a name="ln2269">	m_pOsSupport-&gt;OsGetSystemTime( &amp;ullCurTime );</a>
<a name="ln2270">	return( ( ( ullCurTime - m_ullMidiOutTime ) &gt; MIDI_ACTIVITY_TIMEOUT_USEC ) ? FALSE : TRUE );</a>
<a name="ln2271">	</a>
<a name="ln2272">}	// BOOL CDspCommObject::IsMidiOutActive()</a>
<a name="ln2273"> </a>
<a name="ln2274"> </a>
<a name="ln2275">#endif // MIDI_SUPPORT</a>
<a name="ln2276"> </a>
<a name="ln2277"> </a>
<a name="ln2278"> </a>
<a name="ln2279">// **** CDspCommObject.cpp ****</a>

</code></pre>
<div class="balloon" rel="158"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v610/" target="_blank">V610</a> Undefined behavior. Check the shift operator '<<'. The left operand '-128' is negative.</p></div>
<div class="balloon" rel="1856"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v610/" target="_blank">V610</a> Undefined behavior. Check the shift operator '<<'. The left operand '-128' is negative.</p></div>
<div class="balloon" rel="162"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v610/" target="_blank">V610</a> Undefined behavior. Check the shift operator '<<'. The left operand '-128' is negative.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
