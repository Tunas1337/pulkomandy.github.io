
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ieee80211_adhoc.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2007-2009 Sam Leffler, Errno Consulting</a>
<a name="ln5"> * All rights reserved.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln8"> * modification, are permitted provided that the following conditions</a>
<a name="ln9"> * are met:</a>
<a name="ln10"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln11"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln12"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln13"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln14"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln15"> *</a>
<a name="ln16"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR</a>
<a name="ln17"> * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</a>
<a name="ln18"> * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</a>
<a name="ln19"> * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,</a>
<a name="ln20"> * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</a>
<a name="ln21"> * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</a>
<a name="ln22"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</a>
<a name="ln23"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</a>
<a name="ln24"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</a>
<a name="ln25"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln26"> */</a>
<a name="ln27"> </a>
<a name="ln28">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln29">#ifdef __FreeBSD__</a>
<a name="ln30">__FBSDID(&quot;$FreeBSD: releng/12.0/sys/net80211/ieee80211_adhoc.c 326272 2017-11-27 15:23:17Z pfg $&quot;);</a>
<a name="ln31">#endif</a>
<a name="ln32"> </a>
<a name="ln33">/*</a>
<a name="ln34"> * IEEE 802.11 IBSS mode support.</a>
<a name="ln35"> */</a>
<a name="ln36">#include &quot;opt_inet.h&quot;</a>
<a name="ln37">#include &quot;opt_wlan.h&quot;</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;sys/param.h&gt;</a>
<a name="ln40">#include &lt;sys/systm.h&gt; </a>
<a name="ln41">#include &lt;sys/mbuf.h&gt;   </a>
<a name="ln42">#include &lt;sys/malloc.h&gt;</a>
<a name="ln43">#include &lt;sys/kernel.h&gt;</a>
<a name="ln44"> </a>
<a name="ln45">#include &lt;sys/socket.h&gt;</a>
<a name="ln46">#include &lt;sys/sockio.h&gt;</a>
<a name="ln47">#include &lt;sys/endian.h&gt;</a>
<a name="ln48">#include &lt;sys/errno.h&gt;</a>
<a name="ln49">#include &lt;sys/proc.h&gt;</a>
<a name="ln50">#include &lt;sys/sysctl.h&gt;</a>
<a name="ln51"> </a>
<a name="ln52">#include &lt;net/if.h&gt;</a>
<a name="ln53">#include &lt;net/if_var.h&gt;</a>
<a name="ln54">#include &lt;net/if_media.h&gt;</a>
<a name="ln55">#include &lt;net/if_llc.h&gt;</a>
<a name="ln56">#include &lt;net/ethernet.h&gt;</a>
<a name="ln57"> </a>
<a name="ln58">#include &lt;net/bpf.h&gt;</a>
<a name="ln59"> </a>
<a name="ln60">#include &lt;net80211/ieee80211_var.h&gt;</a>
<a name="ln61">#include &lt;net80211/ieee80211_adhoc.h&gt;</a>
<a name="ln62">#include &lt;net80211/ieee80211_input.h&gt;</a>
<a name="ln63">#ifdef IEEE80211_SUPPORT_SUPERG</a>
<a name="ln64">#include &lt;net80211/ieee80211_superg.h&gt;</a>
<a name="ln65">#endif</a>
<a name="ln66">#ifdef IEEE80211_SUPPORT_TDMA</a>
<a name="ln67">#include &lt;net80211/ieee80211_tdma.h&gt;</a>
<a name="ln68">#endif</a>
<a name="ln69">#include &lt;net80211/ieee80211_sta.h&gt;</a>
<a name="ln70"> </a>
<a name="ln71">#define	IEEE80211_RATE2MBS(r)	(((r) &amp; IEEE80211_RATE_VAL) / 2)</a>
<a name="ln72"> </a>
<a name="ln73">static	void adhoc_vattach(struct ieee80211vap *);</a>
<a name="ln74">static	int adhoc_newstate(struct ieee80211vap *, enum ieee80211_state, int);</a>
<a name="ln75">static int adhoc_input(struct ieee80211_node *, struct mbuf *,</a>
<a name="ln76">	    const struct ieee80211_rx_stats *, int, int);</a>
<a name="ln77">static void adhoc_recv_mgmt(struct ieee80211_node *, struct mbuf *,</a>
<a name="ln78">	int subtype, const struct ieee80211_rx_stats *, int, int);</a>
<a name="ln79">static void ahdemo_recv_mgmt(struct ieee80211_node *, struct mbuf *,</a>
<a name="ln80">	    int subtype, const struct ieee80211_rx_stats *rxs, int, int);</a>
<a name="ln81">static void adhoc_recv_ctl(struct ieee80211_node *, struct mbuf *, int subtype);</a>
<a name="ln82"> </a>
<a name="ln83">void</a>
<a name="ln84">ieee80211_adhoc_attach(struct ieee80211com *ic)</a>
<a name="ln85">{</a>
<a name="ln86">	ic-&gt;ic_vattach[IEEE80211_M_IBSS] = adhoc_vattach;</a>
<a name="ln87">	ic-&gt;ic_vattach[IEEE80211_M_AHDEMO] = adhoc_vattach;</a>
<a name="ln88">}</a>
<a name="ln89"> </a>
<a name="ln90">void</a>
<a name="ln91">ieee80211_adhoc_detach(struct ieee80211com *ic)</a>
<a name="ln92">{</a>
<a name="ln93">}</a>
<a name="ln94"> </a>
<a name="ln95">static void</a>
<a name="ln96">adhoc_vdetach(struct ieee80211vap *vap)</a>
<a name="ln97">{</a>
<a name="ln98">}</a>
<a name="ln99"> </a>
<a name="ln100">static void</a>
<a name="ln101">adhoc_vattach(struct ieee80211vap *vap)</a>
<a name="ln102">{</a>
<a name="ln103">	vap-&gt;iv_newstate = adhoc_newstate;</a>
<a name="ln104">	vap-&gt;iv_input = adhoc_input;</a>
<a name="ln105">	if (vap-&gt;iv_opmode == IEEE80211_M_IBSS)</a>
<a name="ln106">		vap-&gt;iv_recv_mgmt = adhoc_recv_mgmt;</a>
<a name="ln107">	else</a>
<a name="ln108">		vap-&gt;iv_recv_mgmt = ahdemo_recv_mgmt;</a>
<a name="ln109">	vap-&gt;iv_recv_ctl = adhoc_recv_ctl;</a>
<a name="ln110">	vap-&gt;iv_opdetach = adhoc_vdetach;</a>
<a name="ln111">#ifdef IEEE80211_SUPPORT_TDMA</a>
<a name="ln112">	/*</a>
<a name="ln113">	 * Throw control to tdma support.  Note we do this</a>
<a name="ln114">	 * after setting up our callbacks so it can piggyback</a>
<a name="ln115">	 * on top of us.</a>
<a name="ln116">	 */</a>
<a name="ln117">	if (vap-&gt;iv_caps &amp; IEEE80211_C_TDMA)</a>
<a name="ln118">		ieee80211_tdma_vattach(vap);</a>
<a name="ln119">#endif</a>
<a name="ln120">}</a>
<a name="ln121"> </a>
<a name="ln122">static void</a>
<a name="ln123">sta_leave(void *arg, struct ieee80211_node *ni)</a>
<a name="ln124">{</a>
<a name="ln125">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln126"> </a>
<a name="ln127">	if (ni != vap-&gt;iv_bss)</a>
<a name="ln128">		ieee80211_node_leave(ni);</a>
<a name="ln129">}</a>
<a name="ln130"> </a>
<a name="ln131">/*</a>
<a name="ln132"> * IEEE80211_M_IBSS+IEEE80211_M_AHDEMO vap state machine handler.</a>
<a name="ln133"> */</a>
<a name="ln134">static int</a>
<a name="ln135">adhoc_newstate(struct ieee80211vap *vap, enum ieee80211_state nstate, int arg)</a>
<a name="ln136">{</a>
<a name="ln137">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln138">	struct ieee80211_node *ni;</a>
<a name="ln139">	enum ieee80211_state ostate;</a>
<a name="ln140"> </a>
<a name="ln141">	IEEE80211_LOCK_ASSERT(vap-&gt;iv_ic);</a>
<a name="ln142"> </a>
<a name="ln143">	ostate = vap-&gt;iv_state;</a>
<a name="ln144">	IEEE80211_DPRINTF(vap, IEEE80211_MSG_STATE, &quot;%s: %s -&gt; %s (%d)\n&quot;,</a>
<a name="ln145">	    __func__, ieee80211_state_name[ostate],</a>
<a name="ln146">	    ieee80211_state_name[nstate], arg);</a>
<a name="ln147">	vap-&gt;iv_state = nstate;			/* state transition */</a>
<a name="ln148">	if (ostate != IEEE80211_S_SCAN)</a>
<a name="ln149">		ieee80211_cancel_scan(vap);	/* background scan */</a>
<a name="ln150">	ni = vap-&gt;iv_bss;			/* NB: no reference held */</a>
<a name="ln151">	switch (nstate) {</a>
<a name="ln152">	case IEEE80211_S_INIT:</a>
<a name="ln153">		switch (ostate) {</a>
<a name="ln154">		case IEEE80211_S_SCAN:</a>
<a name="ln155">			ieee80211_cancel_scan(vap);</a>
<a name="ln156">			break;</a>
<a name="ln157">		default:</a>
<a name="ln158">			break;</a>
<a name="ln159">		}</a>
<a name="ln160">		if (ostate != IEEE80211_S_INIT) {</a>
<a name="ln161">			/* NB: optimize INIT -&gt; INIT case */</a>
<a name="ln162">			ieee80211_reset_bss(vap);</a>
<a name="ln163">		}</a>
<a name="ln164">		break;</a>
<a name="ln165">	case IEEE80211_S_SCAN:</a>
<a name="ln166">		switch (ostate) {</a>
<a name="ln167">		case IEEE80211_S_RUN:		/* beacon miss */</a>
<a name="ln168">			/* purge station table; entries are stale */</a>
<a name="ln169">			ieee80211_iterate_nodes_vap(&amp;ic-&gt;ic_sta, vap,</a>
<a name="ln170">			    sta_leave, NULL);</a>
<a name="ln171">			/* fall thru... */</a>
<a name="ln172">		case IEEE80211_S_INIT:</a>
<a name="ln173">			if (vap-&gt;iv_des_chan != IEEE80211_CHAN_ANYC &amp;&amp;</a>
<a name="ln174">			    !IEEE80211_IS_CHAN_RADAR(vap-&gt;iv_des_chan)) {</a>
<a name="ln175">				/*</a>
<a name="ln176">				 * Already have a channel; bypass the</a>
<a name="ln177">				 * scan and startup immediately.</a>
<a name="ln178">				 */</a>
<a name="ln179">				ieee80211_create_ibss(vap,</a>
<a name="ln180">				    ieee80211_ht_adjust_channel(ic,</a>
<a name="ln181">				    vap-&gt;iv_des_chan, vap-&gt;iv_flags_ht));</a>
<a name="ln182">				break;</a>
<a name="ln183">			}</a>
<a name="ln184">			/*</a>
<a name="ln185">			 * Initiate a scan.  We can come here as a result</a>
<a name="ln186">			 * of an IEEE80211_IOC_SCAN_REQ too in which case</a>
<a name="ln187">			 * the vap will be marked with IEEE80211_FEXT_SCANREQ</a>
<a name="ln188">			 * and the scan request parameters will be present</a>
<a name="ln189">			 * in iv_scanreq.  Otherwise we do the default.</a>
<a name="ln190">			 */</a>
<a name="ln191">			if (vap-&gt;iv_flags_ext &amp; IEEE80211_FEXT_SCANREQ) {</a>
<a name="ln192">				ieee80211_check_scan(vap,</a>
<a name="ln193">				    vap-&gt;iv_scanreq_flags,</a>
<a name="ln194">				    vap-&gt;iv_scanreq_duration,</a>
<a name="ln195">				    vap-&gt;iv_scanreq_mindwell,</a>
<a name="ln196">				    vap-&gt;iv_scanreq_maxdwell,</a>
<a name="ln197">				    vap-&gt;iv_scanreq_nssid, vap-&gt;iv_scanreq_ssid);</a>
<a name="ln198">				vap-&gt;iv_flags_ext &amp;= ~IEEE80211_FEXT_SCANREQ;</a>
<a name="ln199">			} else</a>
<a name="ln200">				ieee80211_check_scan_current(vap);</a>
<a name="ln201">			break;</a>
<a name="ln202">		case IEEE80211_S_SCAN:</a>
<a name="ln203">			/*</a>
<a name="ln204">			 * This can happen because of a change in state</a>
<a name="ln205">			 * that requires a reset.  Trigger a new scan</a>
<a name="ln206">			 * unless we're in manual roaming mode in which</a>
<a name="ln207">			 * case an application must issue an explicit request.</a>
<a name="ln208">			 */</a>
<a name="ln209">			if (vap-&gt;iv_roaming == IEEE80211_ROAMING_AUTO)</a>
<a name="ln210">				ieee80211_check_scan_current(vap);</a>
<a name="ln211">			break;</a>
<a name="ln212">		default:</a>
<a name="ln213">			goto invalid;</a>
<a name="ln214">		}</a>
<a name="ln215">		break;</a>
<a name="ln216">	case IEEE80211_S_RUN:</a>
<a name="ln217">		if (vap-&gt;iv_flags &amp; IEEE80211_F_WPA) {</a>
<a name="ln218">			/* XXX validate prerequisites */</a>
<a name="ln219">		}</a>
<a name="ln220">		switch (ostate) {</a>
<a name="ln221">		case IEEE80211_S_INIT:</a>
<a name="ln222">			/*</a>
<a name="ln223">			 * Already have a channel; bypass the</a>
<a name="ln224">			 * scan and startup immediately.</a>
<a name="ln225">			 * Note that ieee80211_create_ibss will call</a>
<a name="ln226">			 * back to do a RUN-&gt;RUN state change.</a>
<a name="ln227">			 */</a>
<a name="ln228">			ieee80211_create_ibss(vap,</a>
<a name="ln229">			    ieee80211_ht_adjust_channel(ic,</a>
<a name="ln230">				ic-&gt;ic_curchan, vap-&gt;iv_flags_ht));</a>
<a name="ln231">			/* NB: iv_bss is changed on return */</a>
<a name="ln232">			ni = vap-&gt;iv_bss;</a>
<a name="ln233">			break;</a>
<a name="ln234">		case IEEE80211_S_SCAN:</a>
<a name="ln235">#ifdef IEEE80211_DEBUG</a>
<a name="ln236">			if (ieee80211_msg_debug(vap)) {</a>
<a name="ln237">				ieee80211_note(vap,</a>
<a name="ln238">				    &quot;synchronized with %s ssid &quot;,</a>
<a name="ln239">				    ether_sprintf(ni-&gt;ni_bssid));</a>
<a name="ln240">				ieee80211_print_essid(vap-&gt;iv_bss-&gt;ni_essid,</a>
<a name="ln241">				    ni-&gt;ni_esslen);</a>
<a name="ln242">				/* XXX MCS/HT */</a>
<a name="ln243">				printf(&quot; channel %d start %uMb\n&quot;,</a>
<a name="ln244">				    ieee80211_chan2ieee(ic, ic-&gt;ic_curchan),</a>
<a name="ln245">				    IEEE80211_RATE2MBS(ni-&gt;ni_txrate));</a>
<a name="ln246">			}</a>
<a name="ln247">#endif</a>
<a name="ln248">			break;</a>
<a name="ln249">		case IEEE80211_S_RUN:	/* IBSS merge */</a>
<a name="ln250">			break;</a>
<a name="ln251">		default:</a>
<a name="ln252">			goto invalid;</a>
<a name="ln253">		}</a>
<a name="ln254">		/*</a>
<a name="ln255">		 * When 802.1x is not in use mark the port authorized</a>
<a name="ln256">		 * at this point so traffic can flow.</a>
<a name="ln257">		 */</a>
<a name="ln258">		if (ni-&gt;ni_authmode != IEEE80211_AUTH_8021X)</a>
<a name="ln259">			ieee80211_node_authorize(ni);</a>
<a name="ln260">		/*</a>
<a name="ln261">		 * Fake association when joining an existing bss.</a>
<a name="ln262">		 */</a>
<a name="ln263">		if (!IEEE80211_ADDR_EQ(ni-&gt;ni_macaddr, vap-&gt;iv_myaddr) &amp;&amp;</a>
<a name="ln264">		    ic-&gt;ic_newassoc != NULL)</a>
<a name="ln265">			ic-&gt;ic_newassoc(ni, ostate != IEEE80211_S_RUN);</a>
<a name="ln266">		break;</a>
<a name="ln267">	case IEEE80211_S_SLEEP:</a>
<a name="ln268">		vap-&gt;iv_sta_ps(vap, 0);</a>
<a name="ln269">		break;</a>
<a name="ln270">	default:</a>
<a name="ln271">	invalid:</a>
<a name="ln272">		IEEE80211_DPRINTF(vap, IEEE80211_MSG_STATE,</a>
<a name="ln273">		    &quot;%s: unexpected state transition %s -&gt; %s\n&quot;, __func__,</a>
<a name="ln274">		    ieee80211_state_name[ostate], ieee80211_state_name[nstate]);</a>
<a name="ln275">		break;</a>
<a name="ln276">	}</a>
<a name="ln277">	return 0;</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280">/*</a>
<a name="ln281"> * Decide if a received management frame should be</a>
<a name="ln282"> * printed when debugging is enabled.  This filters some</a>
<a name="ln283"> * of the less interesting frames that come frequently</a>
<a name="ln284"> * (e.g. beacons).</a>
<a name="ln285"> */</a>
<a name="ln286">static __inline int</a>
<a name="ln287">doprint(struct ieee80211vap *vap, int subtype)</a>
<a name="ln288">{</a>
<a name="ln289">	switch (subtype) {</a>
<a name="ln290">	case IEEE80211_FC0_SUBTYPE_BEACON:</a>
<a name="ln291">		return (vap-&gt;iv_ic-&gt;ic_flags &amp; IEEE80211_F_SCAN);</a>
<a name="ln292">	case IEEE80211_FC0_SUBTYPE_PROBE_REQ:</a>
<a name="ln293">		return 1;</a>
<a name="ln294">	}</a>
<a name="ln295">	return 1;</a>
<a name="ln296">}</a>
<a name="ln297"> </a>
<a name="ln298">/*</a>
<a name="ln299"> * Process a received frame.  The node associated with the sender</a>
<a name="ln300"> * should be supplied.  If nothing was found in the node table then</a>
<a name="ln301"> * the caller is assumed to supply a reference to iv_bss instead.</a>
<a name="ln302"> * The RSSI and a timestamp are also supplied.  The RSSI data is used</a>
<a name="ln303"> * during AP scanning to select a AP to associate with; it can have</a>
<a name="ln304"> * any units so long as values have consistent units and higher values</a>
<a name="ln305"> * mean ``better signal''.  The receive timestamp is currently not used</a>
<a name="ln306"> * by the 802.11 layer.</a>
<a name="ln307"> */</a>
<a name="ln308">static int</a>
<a name="ln309">adhoc_input(struct ieee80211_node *ni, struct mbuf *m,</a>
<a name="ln310">    const struct ieee80211_rx_stats *rxs, int rssi, int nf)</a>
<a name="ln311">{</a>
<a name="ln312">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln313">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln314">	struct ifnet *ifp = vap-&gt;iv_ifp;</a>
<a name="ln315">	struct ieee80211_frame *wh;</a>
<a name="ln316">	struct ieee80211_key *key;</a>
<a name="ln317">	struct ether_header *eh;</a>
<a name="ln318">	int hdrspace, need_tap = 1;	/* mbuf need to be tapped. */	</a>
<a name="ln319">	uint8_t dir, type, subtype, qos;</a>
<a name="ln320">	uint8_t *bssid;</a>
<a name="ln321">	int is_hw_decrypted = 0;</a>
<a name="ln322">	int has_decrypted = 0;</a>
<a name="ln323"> </a>
<a name="ln324">	/*</a>
<a name="ln325">	 * Some devices do hardware decryption all the way through</a>
<a name="ln326">	 * to pretending the frame wasn't encrypted in the first place.</a>
<a name="ln327">	 * So, tag it appropriately so it isn't discarded inappropriately.</a>
<a name="ln328">	 */</a>
<a name="ln329">	if ((rxs != NULL) &amp;&amp; (rxs-&gt;c_pktflags &amp; IEEE80211_RX_F_DECRYPTED))</a>
<a name="ln330">		is_hw_decrypted = 1;</a>
<a name="ln331"> </a>
<a name="ln332">	if (m-&gt;m_flags &amp; M_AMPDU_MPDU) {</a>
<a name="ln333">		/*</a>
<a name="ln334">		 * Fastpath for A-MPDU reorder q resubmission.  Frames</a>
<a name="ln335">		 * w/ M_AMPDU_MPDU marked have already passed through</a>
<a name="ln336">		 * here but were received out of order and been held on</a>
<a name="ln337">		 * the reorder queue.  When resubmitted they are marked</a>
<a name="ln338">		 * with the M_AMPDU_MPDU flag and we can bypass most of</a>
<a name="ln339">		 * the normal processing.</a>
<a name="ln340">		 */</a>
<a name="ln341">		wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln342">		type = IEEE80211_FC0_TYPE_DATA;</a>
<a name="ln343">		dir = wh-&gt;i_fc[1] &amp; IEEE80211_FC1_DIR_MASK;</a>
<a name="ln344">		subtype = IEEE80211_FC0_SUBTYPE_QOS;</a>
<a name="ln345">		hdrspace = ieee80211_hdrspace(ic, wh);	/* XXX optimize? */</a>
<a name="ln346">		goto resubmit_ampdu;</a>
<a name="ln347">	}</a>
<a name="ln348"> </a>
<a name="ln349">	KASSERT(ni != NULL, (&quot;null node&quot;));</a>
<a name="ln350">	ni-&gt;ni_inact = ni-&gt;ni_inact_reload;</a>
<a name="ln351"> </a>
<a name="ln352">	type = -1;			/* undefined */</a>
<a name="ln353"> </a>
<a name="ln354">	if (m-&gt;m_pkthdr.len &lt; sizeof(struct ieee80211_frame_min)) {</a>
<a name="ln355">		IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_ANY,</a>
<a name="ln356">		    ni-&gt;ni_macaddr, NULL,</a>
<a name="ln357">		    &quot;too short (1): len %u&quot;, m-&gt;m_pkthdr.len);</a>
<a name="ln358">		vap-&gt;iv_stats.is_rx_tooshort++;</a>
<a name="ln359">		goto out;</a>
<a name="ln360">	}</a>
<a name="ln361">	/*</a>
<a name="ln362">	 * Bit of a cheat here, we use a pointer for a 3-address</a>
<a name="ln363">	 * frame format but don't reference fields past outside</a>
<a name="ln364">	 * ieee80211_frame_min w/o first validating the data is</a>
<a name="ln365">	 * present.</a>
<a name="ln366">	 */</a>
<a name="ln367">	wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln368"> </a>
<a name="ln369">	if ((wh-&gt;i_fc[0] &amp; IEEE80211_FC0_VERSION_MASK) !=</a>
<a name="ln370">	    IEEE80211_FC0_VERSION_0) {</a>
<a name="ln371">		IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_ANY,</a>
<a name="ln372">		    ni-&gt;ni_macaddr, NULL, &quot;wrong version, fc %02x:%02x&quot;,</a>
<a name="ln373">		    wh-&gt;i_fc[0], wh-&gt;i_fc[1]);</a>
<a name="ln374">		vap-&gt;iv_stats.is_rx_badversion++;</a>
<a name="ln375">		goto err;</a>
<a name="ln376">	}</a>
<a name="ln377"> </a>
<a name="ln378">	dir = wh-&gt;i_fc[1] &amp; IEEE80211_FC1_DIR_MASK;</a>
<a name="ln379">	type = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_TYPE_MASK;</a>
<a name="ln380">	subtype = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_SUBTYPE_MASK;</a>
<a name="ln381">	if ((ic-&gt;ic_flags &amp; IEEE80211_F_SCAN) == 0) {</a>
<a name="ln382">		if (dir != IEEE80211_FC1_DIR_NODS)</a>
<a name="ln383">			bssid = wh-&gt;i_addr1;</a>
<a name="ln384">		else if (type == IEEE80211_FC0_TYPE_CTL)</a>
<a name="ln385">			bssid = wh-&gt;i_addr1;</a>
<a name="ln386">		else {</a>
<a name="ln387">			if (m-&gt;m_pkthdr.len &lt; sizeof(struct ieee80211_frame)) {</a>
<a name="ln388">				IEEE80211_DISCARD_MAC(vap,</a>
<a name="ln389">				    IEEE80211_MSG_ANY, ni-&gt;ni_macaddr,</a>
<a name="ln390">				    NULL, &quot;too short (2): len %u&quot;,</a>
<a name="ln391">				    m-&gt;m_pkthdr.len);</a>
<a name="ln392">				vap-&gt;iv_stats.is_rx_tooshort++;</a>
<a name="ln393">				goto out;</a>
<a name="ln394">			}</a>
<a name="ln395">			bssid = wh-&gt;i_addr3;</a>
<a name="ln396">		}</a>
<a name="ln397">		/*</a>
<a name="ln398">		 * Validate the bssid.</a>
<a name="ln399">		 */</a>
<a name="ln400">		if (!(type == IEEE80211_FC0_TYPE_MGT &amp;&amp;</a>
<a name="ln401">		     (subtype == IEEE80211_FC0_SUBTYPE_BEACON ||</a>
<a name="ln402">		      subtype == IEEE80211_FC0_SUBTYPE_PROBE_RESP)) &amp;&amp;</a>
<a name="ln403">		    !IEEE80211_ADDR_EQ(bssid, vap-&gt;iv_bss-&gt;ni_bssid) &amp;&amp;</a>
<a name="ln404">		    !IEEE80211_ADDR_EQ(bssid, ifp-&gt;if_broadcastaddr)) {</a>
<a name="ln405">			/* not interested in */</a>
<a name="ln406">			IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln407">			    bssid, NULL, &quot;%s&quot;, &quot;not to bss&quot;);</a>
<a name="ln408">			vap-&gt;iv_stats.is_rx_wrongbss++;</a>
<a name="ln409">			goto out;</a>
<a name="ln410">		}</a>
<a name="ln411">		/*</a>
<a name="ln412">		 * Data frame, cons up a node when it doesn't</a>
<a name="ln413">		 * exist. This should probably done after an ACL check.</a>
<a name="ln414">		 */</a>
<a name="ln415">		if (type == IEEE80211_FC0_TYPE_DATA &amp;&amp;</a>
<a name="ln416">		    ni == vap-&gt;iv_bss &amp;&amp;</a>
<a name="ln417">		    !IEEE80211_ADDR_EQ(wh-&gt;i_addr2, ni-&gt;ni_macaddr)) {</a>
<a name="ln418">			/*</a>
<a name="ln419">			 * Beware of frames that come in too early; we</a>
<a name="ln420">			 * can receive broadcast frames and creating sta</a>
<a name="ln421">			 * entries will blow up because there is no bss</a>
<a name="ln422">			 * channel yet.</a>
<a name="ln423">			 */</a>
<a name="ln424">			if (vap-&gt;iv_state != IEEE80211_S_RUN) {</a>
<a name="ln425">				IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln426">				    wh, &quot;data&quot;, &quot;not in RUN state (%s)&quot;,</a>
<a name="ln427">				    ieee80211_state_name[vap-&gt;iv_state]);</a>
<a name="ln428">				vap-&gt;iv_stats.is_rx_badstate++;</a>
<a name="ln429">				goto err;</a>
<a name="ln430">			}</a>
<a name="ln431">			/*</a>
<a name="ln432">			 * Fake up a node for this newly discovered member</a>
<a name="ln433">			 * of the IBSS.</a>
<a name="ln434">			 *</a>
<a name="ln435">			 * Note: This doesn't &quot;upgrade&quot; the node to 11n;</a>
<a name="ln436">			 * that will happen after a probe request/response</a>
<a name="ln437">			 * exchange.</a>
<a name="ln438">			 */</a>
<a name="ln439">			ni = ieee80211_fakeup_adhoc_node(vap, wh-&gt;i_addr2);</a>
<a name="ln440">			if (ni == NULL) {</a>
<a name="ln441">				/* NB: stat kept for alloc failure */</a>
<a name="ln442">				goto err;</a>
<a name="ln443">			}</a>
<a name="ln444">		}</a>
<a name="ln445">		IEEE80211_RSSI_LPF(ni-&gt;ni_avgrssi, rssi);</a>
<a name="ln446">		ni-&gt;ni_noise = nf;</a>
<a name="ln447">		if (IEEE80211_HAS_SEQ(type, subtype) &amp;&amp;</a>
<a name="ln448">		    IEEE80211_ADDR_EQ(wh-&gt;i_addr2, ni-&gt;ni_macaddr)) {</a>
<a name="ln449">			uint8_t tid = ieee80211_gettid(wh);</a>
<a name="ln450">			if (IEEE80211_QOS_HAS_SEQ(wh) &amp;&amp;</a>
<a name="ln451">			    TID_TO_WME_AC(tid) &gt;= WME_AC_VI)</a>
<a name="ln452">				ic-&gt;ic_wme.wme_hipri_traffic++;</a>
<a name="ln453">			if (! ieee80211_check_rxseq(ni, wh, bssid, rxs))</a>
<a name="ln454">				goto out;</a>
<a name="ln455">		}</a>
<a name="ln456">	}</a>
<a name="ln457"> </a>
<a name="ln458">	switch (type) {</a>
<a name="ln459">	case IEEE80211_FC0_TYPE_DATA:</a>
<a name="ln460">		hdrspace = ieee80211_hdrspace(ic, wh);</a>
<a name="ln461">		if (m-&gt;m_len &lt; hdrspace &amp;&amp;</a>
<a name="ln462">		    (m = m_pullup(m, hdrspace)) == NULL) {</a>
<a name="ln463">			IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_ANY,</a>
<a name="ln464">			    ni-&gt;ni_macaddr, NULL,</a>
<a name="ln465">			    &quot;data too short: expecting %u&quot;, hdrspace);</a>
<a name="ln466">			vap-&gt;iv_stats.is_rx_tooshort++;</a>
<a name="ln467">			goto out;		/* XXX */</a>
<a name="ln468">		}</a>
<a name="ln469">		if (dir != IEEE80211_FC1_DIR_NODS) {</a>
<a name="ln470">			IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln471">			    wh, &quot;data&quot;, &quot;incorrect dir 0x%x&quot;, dir);</a>
<a name="ln472">			vap-&gt;iv_stats.is_rx_wrongdir++;</a>
<a name="ln473">			goto out;</a>
<a name="ln474">		}</a>
<a name="ln475">		/* XXX no power-save support */</a>
<a name="ln476"> </a>
<a name="ln477">		/*</a>
<a name="ln478">		 * Handle A-MPDU re-ordering.  If the frame is to be</a>
<a name="ln479">		 * processed directly then ieee80211_ampdu_reorder</a>
<a name="ln480">		 * will return 0; otherwise it has consumed the mbuf</a>
<a name="ln481">		 * and we should do nothing more with it.</a>
<a name="ln482">		 */</a>
<a name="ln483">		if ((m-&gt;m_flags &amp; M_AMPDU) &amp;&amp;</a>
<a name="ln484">		    ieee80211_ampdu_reorder(ni, m, rxs) != 0) {</a>
<a name="ln485">			m = NULL;</a>
<a name="ln486">			goto out;</a>
<a name="ln487">		}</a>
<a name="ln488">	resubmit_ampdu:</a>
<a name="ln489"> </a>
<a name="ln490">		/*</a>
<a name="ln491">		 * Handle privacy requirements.  Note that we</a>
<a name="ln492">		 * must not be preempted from here until after</a>
<a name="ln493">		 * we (potentially) call ieee80211_crypto_demic;</a>
<a name="ln494">		 * otherwise we may violate assumptions in the</a>
<a name="ln495">		 * crypto cipher modules used to do delayed update</a>
<a name="ln496">		 * of replay sequence numbers.</a>
<a name="ln497">		 */</a>
<a name="ln498">		if (is_hw_decrypted || wh-&gt;i_fc[1] &amp; IEEE80211_FC1_PROTECTED) {</a>
<a name="ln499">			if ((vap-&gt;iv_flags &amp; IEEE80211_F_PRIVACY) == 0) {</a>
<a name="ln500">				/*</a>
<a name="ln501">				 * Discard encrypted frames when privacy is off.</a>
<a name="ln502">				 */</a>
<a name="ln503">				IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln504">				    wh, &quot;WEP&quot;, &quot;%s&quot;, &quot;PRIVACY off&quot;);</a>
<a name="ln505">				vap-&gt;iv_stats.is_rx_noprivacy++;</a>
<a name="ln506">				IEEE80211_NODE_STAT(ni, rx_noprivacy);</a>
<a name="ln507">				goto out;</a>
<a name="ln508">			}</a>
<a name="ln509">			if (ieee80211_crypto_decap(ni, m, hdrspace, &amp;key) == 0) {</a>
<a name="ln510">				/* NB: stats+msgs handled in crypto_decap */</a>
<a name="ln511">				IEEE80211_NODE_STAT(ni, rx_wepfail);</a>
<a name="ln512">				goto out;</a>
<a name="ln513">			}</a>
<a name="ln514">			wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln515">			wh-&gt;i_fc[1] &amp;= ~IEEE80211_FC1_PROTECTED;</a>
<a name="ln516">			has_decrypted = 1;</a>
<a name="ln517">		} else {</a>
<a name="ln518">			/* XXX M_WEP and IEEE80211_F_PRIVACY */</a>
<a name="ln519">			key = NULL;</a>
<a name="ln520">		}</a>
<a name="ln521"> </a>
<a name="ln522">		/*</a>
<a name="ln523">		 * Save QoS bits for use below--before we strip the header.</a>
<a name="ln524">		 */</a>
<a name="ln525">		if (subtype == IEEE80211_FC0_SUBTYPE_QOS) {</a>
<a name="ln526">			qos = (dir == IEEE80211_FC1_DIR_DSTODS) ?</a>
<a name="ln527">			    ((struct ieee80211_qosframe_addr4 *)wh)-&gt;i_qos[0] :</a>
<a name="ln528">			    ((struct ieee80211_qosframe *)wh)-&gt;i_qos[0];</a>
<a name="ln529">		} else</a>
<a name="ln530">			qos = 0;</a>
<a name="ln531"> </a>
<a name="ln532">		/*</a>
<a name="ln533">		 * Next up, any fragmentation.</a>
<a name="ln534">		 */</a>
<a name="ln535">		if (!IEEE80211_IS_MULTICAST(wh-&gt;i_addr1)) {</a>
<a name="ln536">			m = ieee80211_defrag(ni, m, hdrspace);</a>
<a name="ln537">			if (m == NULL) {</a>
<a name="ln538">				/* Fragment dropped or frame not complete yet */</a>
<a name="ln539">				goto out;</a>
<a name="ln540">			}</a>
<a name="ln541">		}</a>
<a name="ln542">		wh = NULL;		/* no longer valid, catch any uses */</a>
<a name="ln543"> </a>
<a name="ln544">		/*</a>
<a name="ln545">		 * Next strip any MSDU crypto bits.</a>
<a name="ln546">		 */</a>
<a name="ln547">		if (!ieee80211_crypto_demic(vap, key, m, 0)) {</a>
<a name="ln548">			IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln549">			    ni-&gt;ni_macaddr, &quot;data&quot;, &quot;%s&quot;, &quot;demic error&quot;);</a>
<a name="ln550">			vap-&gt;iv_stats.is_rx_demicfail++;</a>
<a name="ln551">			IEEE80211_NODE_STAT(ni, rx_demicfail);</a>
<a name="ln552">			goto out;</a>
<a name="ln553">		}</a>
<a name="ln554"> </a>
<a name="ln555">		/* copy to listener after decrypt */</a>
<a name="ln556">		if (ieee80211_radiotap_active_vap(vap))</a>
<a name="ln557">			ieee80211_radiotap_rx(vap, m);</a>
<a name="ln558">		need_tap = 0;</a>
<a name="ln559"> </a>
<a name="ln560">		/*</a>
<a name="ln561">		 * Finally, strip the 802.11 header.</a>
<a name="ln562">		 */</a>
<a name="ln563">		m = ieee80211_decap(vap, m, hdrspace);</a>
<a name="ln564">		if (m == NULL) {</a>
<a name="ln565">			/* XXX mask bit to check for both */</a>
<a name="ln566">			/* don't count Null data frames as errors */</a>
<a name="ln567">			if (subtype == IEEE80211_FC0_SUBTYPE_NODATA ||</a>
<a name="ln568">			    subtype == IEEE80211_FC0_SUBTYPE_QOS_NULL)</a>
<a name="ln569">				goto out;</a>
<a name="ln570">			IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln571">			    ni-&gt;ni_macaddr, &quot;data&quot;, &quot;%s&quot;, &quot;decap error&quot;);</a>
<a name="ln572">			vap-&gt;iv_stats.is_rx_decap++;</a>
<a name="ln573">			IEEE80211_NODE_STAT(ni, rx_decap);</a>
<a name="ln574">			goto err;</a>
<a name="ln575">		}</a>
<a name="ln576">		eh = mtod(m, struct ether_header *);</a>
<a name="ln577">		if (!ieee80211_node_is_authorized(ni)) {</a>
<a name="ln578">			/*</a>
<a name="ln579">			 * Deny any non-PAE frames received prior to</a>
<a name="ln580">			 * authorization.  For open/shared-key</a>
<a name="ln581">			 * authentication the port is mark authorized</a>
<a name="ln582">			 * after authentication completes.  For 802.1x</a>
<a name="ln583">			 * the port is not marked authorized by the</a>
<a name="ln584">			 * authenticator until the handshake has completed.</a>
<a name="ln585">			 */</a>
<a name="ln586">			if (eh-&gt;ether_type != htons(ETHERTYPE_PAE)) {</a>
<a name="ln587">				IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln588">				    eh-&gt;ether_shost, &quot;data&quot;,</a>
<a name="ln589">				    &quot;unauthorized port: ether type 0x%x len %u&quot;,</a>
<a name="ln590">				    eh-&gt;ether_type, m-&gt;m_pkthdr.len);</a>
<a name="ln591">				vap-&gt;iv_stats.is_rx_unauth++;</a>
<a name="ln592">				IEEE80211_NODE_STAT(ni, rx_unauth);</a>
<a name="ln593">				goto err;</a>
<a name="ln594">			}</a>
<a name="ln595">		} else {</a>
<a name="ln596">			/*</a>
<a name="ln597">			 * When denying unencrypted frames, discard</a>
<a name="ln598">			 * any non-PAE frames received without encryption.</a>
<a name="ln599">			 */</a>
<a name="ln600">			if ((vap-&gt;iv_flags &amp; IEEE80211_F_DROPUNENC) &amp;&amp;</a>
<a name="ln601">			    ((has_decrypted == 0) &amp;&amp; (m-&gt;m_flags &amp; M_WEP) == 0) &amp;&amp;</a>
<a name="ln602">			    (is_hw_decrypted == 0) &amp;&amp;</a>
<a name="ln603">			    eh-&gt;ether_type != htons(ETHERTYPE_PAE)) {</a>
<a name="ln604">				/*</a>
<a name="ln605">				 * Drop unencrypted frames.</a>
<a name="ln606">				 */</a>
<a name="ln607">				vap-&gt;iv_stats.is_rx_unencrypted++;</a>
<a name="ln608">				IEEE80211_NODE_STAT(ni, rx_unencrypted);</a>
<a name="ln609">				goto out;</a>
<a name="ln610">			}</a>
<a name="ln611">		}</a>
<a name="ln612">		/* XXX require HT? */</a>
<a name="ln613">		if (qos &amp; IEEE80211_QOS_AMSDU) {</a>
<a name="ln614">			m = ieee80211_decap_amsdu(ni, m);</a>
<a name="ln615">			if (m == NULL)</a>
<a name="ln616">				return IEEE80211_FC0_TYPE_DATA;</a>
<a name="ln617">		} else {</a>
<a name="ln618">#ifdef IEEE80211_SUPPORT_SUPERG</a>
<a name="ln619">			m = ieee80211_decap_fastframe(vap, ni, m);</a>
<a name="ln620">			if (m == NULL)</a>
<a name="ln621">				return IEEE80211_FC0_TYPE_DATA;</a>
<a name="ln622">#endif</a>
<a name="ln623">		}</a>
<a name="ln624">		if (dir == IEEE80211_FC1_DIR_DSTODS &amp;&amp; ni-&gt;ni_wdsvap != NULL)</a>
<a name="ln625">			ieee80211_deliver_data(ni-&gt;ni_wdsvap, ni, m);</a>
<a name="ln626">		else</a>
<a name="ln627">			ieee80211_deliver_data(vap, ni, m);</a>
<a name="ln628">		return IEEE80211_FC0_TYPE_DATA;</a>
<a name="ln629"> </a>
<a name="ln630">	case IEEE80211_FC0_TYPE_MGT:</a>
<a name="ln631">		vap-&gt;iv_stats.is_rx_mgmt++;</a>
<a name="ln632">		IEEE80211_NODE_STAT(ni, rx_mgmt);</a>
<a name="ln633">		if (dir != IEEE80211_FC1_DIR_NODS) {</a>
<a name="ln634">			IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln635">			    wh, &quot;data&quot;, &quot;incorrect dir 0x%x&quot;, dir);</a>
<a name="ln636">			vap-&gt;iv_stats.is_rx_wrongdir++;</a>
<a name="ln637">			goto err;</a>
<a name="ln638">		}</a>
<a name="ln639">		if (m-&gt;m_pkthdr.len &lt; sizeof(struct ieee80211_frame)) {</a>
<a name="ln640">			IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_ANY,</a>
<a name="ln641">			    ni-&gt;ni_macaddr, &quot;mgt&quot;, &quot;too short: len %u&quot;,</a>
<a name="ln642">			    m-&gt;m_pkthdr.len);</a>
<a name="ln643">			vap-&gt;iv_stats.is_rx_tooshort++;</a>
<a name="ln644">			goto out;</a>
<a name="ln645">		}</a>
<a name="ln646">#ifdef IEEE80211_DEBUG</a>
<a name="ln647">		if ((ieee80211_msg_debug(vap) &amp;&amp; doprint(vap, subtype)) ||</a>
<a name="ln648">		    ieee80211_msg_dumppkts(vap)) {</a>
<a name="ln649">			if_printf(ifp, &quot;received %s from %s rssi %d\n&quot;,</a>
<a name="ln650">			    ieee80211_mgt_subtype_name(subtype),</a>
<a name="ln651">			    ether_sprintf(wh-&gt;i_addr2), rssi);</a>
<a name="ln652">		}</a>
<a name="ln653">#endif</a>
<a name="ln654">		if (wh-&gt;i_fc[1] &amp; IEEE80211_FC1_PROTECTED) {</a>
<a name="ln655">			IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln656">			    wh, NULL, &quot;%s&quot;, &quot;WEP set but not permitted&quot;);</a>
<a name="ln657">			vap-&gt;iv_stats.is_rx_mgtdiscard++; /* XXX */</a>
<a name="ln658">			goto out;</a>
<a name="ln659">		}</a>
<a name="ln660">		vap-&gt;iv_recv_mgmt(ni, m, subtype, rxs, rssi, nf);</a>
<a name="ln661">		goto out;</a>
<a name="ln662"> </a>
<a name="ln663">	case IEEE80211_FC0_TYPE_CTL:</a>
<a name="ln664">		vap-&gt;iv_stats.is_rx_ctl++;</a>
<a name="ln665">		IEEE80211_NODE_STAT(ni, rx_ctrl);</a>
<a name="ln666">		vap-&gt;iv_recv_ctl(ni, m, subtype);</a>
<a name="ln667">		goto out;</a>
<a name="ln668"> </a>
<a name="ln669">	default:</a>
<a name="ln670">		IEEE80211_DISCARD(vap, IEEE80211_MSG_ANY,</a>
<a name="ln671">		    wh, &quot;bad&quot;, &quot;frame type 0x%x&quot;, type);</a>
<a name="ln672">		/* should not come here */</a>
<a name="ln673">		break;</a>
<a name="ln674">	}</a>
<a name="ln675">err:</a>
<a name="ln676">	if_inc_counter(ifp, IFCOUNTER_IERRORS, 1);</a>
<a name="ln677">out:</a>
<a name="ln678">	if (m != NULL) {</a>
<a name="ln679">		if (need_tap &amp;&amp; ieee80211_radiotap_active_vap(vap))</a>
<a name="ln680">			ieee80211_radiotap_rx(vap, m);</a>
<a name="ln681">		m_freem(m);</a>
<a name="ln682">	}</a>
<a name="ln683">	return type;</a>
<a name="ln684">}</a>
<a name="ln685"> </a>
<a name="ln686">static int</a>
<a name="ln687">is11bclient(const uint8_t *rates, const uint8_t *xrates)</a>
<a name="ln688">{</a>
<a name="ln689">	static const uint32_t brates = (1&lt;&lt;2*1)|(1&lt;&lt;2*2)|(1&lt;&lt;11)|(1&lt;&lt;2*11);</a>
<a name="ln690">	int i;</a>
<a name="ln691"> </a>
<a name="ln692">	/* NB: the 11b clients we care about will not have xrates */</a>
<a name="ln693">	if (xrates != NULL || rates == NULL)</a>
<a name="ln694">		return 0;</a>
<a name="ln695">	for (i = 0; i &lt; rates[1]; i++) {</a>
<a name="ln696">		int r = rates[2+i] &amp; IEEE80211_RATE_VAL;</a>
<a name="ln697">		if (r &gt; 2*11 || ((1&lt;&lt;r) &amp; brates) == 0)</a>
<a name="ln698">			return 0;</a>
<a name="ln699">	}</a>
<a name="ln700">	return 1;</a>
<a name="ln701">}</a>
<a name="ln702"> </a>
<a name="ln703">static void</a>
<a name="ln704">adhoc_recv_mgmt(struct ieee80211_node *ni, struct mbuf *m0,</a>
<a name="ln705">	int subtype, const struct ieee80211_rx_stats *rxs, int rssi, int nf)</a>
<a name="ln706">{</a>
<a name="ln707">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln708">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln709">	struct ieee80211_channel *rxchan = ic-&gt;ic_curchan;</a>
<a name="ln710">	struct ieee80211_frame *wh;</a>
<a name="ln711">	uint8_t *frm, *efrm;</a>
<a name="ln712">	uint8_t *ssid, *rates, *xrates;</a>
<a name="ln713">#if 0</a>
<a name="ln714">	int ht_state_change = 0;</a>
<a name="ln715">#endif</a>
<a name="ln716"> </a>
<a name="ln717">	wh = mtod(m0, struct ieee80211_frame *);</a>
<a name="ln718">	frm = (uint8_t *)&amp;wh[1];</a>
<a name="ln719">	efrm = mtod(m0, uint8_t *) + m0-&gt;m_len;</a>
<a name="ln720">	switch (subtype) {</a>
<a name="ln721">	case IEEE80211_FC0_SUBTYPE_PROBE_RESP:</a>
<a name="ln722">	case IEEE80211_FC0_SUBTYPE_BEACON: {</a>
<a name="ln723">		struct ieee80211_scanparams scan;</a>
<a name="ln724">		struct ieee80211_channel *c;</a>
<a name="ln725">		/*</a>
<a name="ln726">		 * We process beacon/probe response</a>
<a name="ln727">		 * frames to discover neighbors.</a>
<a name="ln728">		 */ </a>
<a name="ln729">		if (rxs != NULL) {</a>
<a name="ln730">			c = ieee80211_lookup_channel_rxstatus(vap, rxs);</a>
<a name="ln731">			if (c != NULL)</a>
<a name="ln732">				rxchan = c;</a>
<a name="ln733">		}</a>
<a name="ln734">		if (ieee80211_parse_beacon(ni, m0, rxchan, &amp;scan) != 0)</a>
<a name="ln735">			return;</a>
<a name="ln736">		/*</a>
<a name="ln737">		 * Count frame now that we know it's to be processed.</a>
<a name="ln738">		 */</a>
<a name="ln739">		if (subtype == IEEE80211_FC0_SUBTYPE_BEACON) {</a>
<a name="ln740">			vap-&gt;iv_stats.is_rx_beacon++;		/* XXX remove */</a>
<a name="ln741">			IEEE80211_NODE_STAT(ni, rx_beacons);</a>
<a name="ln742">		} else</a>
<a name="ln743">			IEEE80211_NODE_STAT(ni, rx_proberesp);</a>
<a name="ln744">		/*</a>
<a name="ln745">		 * If scanning, just pass information to the scan module.</a>
<a name="ln746">		 */</a>
<a name="ln747">		if (ic-&gt;ic_flags &amp; IEEE80211_F_SCAN) {</a>
<a name="ln748">			if (ic-&gt;ic_flags_ext &amp; IEEE80211_FEXT_PROBECHAN) {</a>
<a name="ln749">				/*</a>
<a name="ln750">				 * Actively scanning a channel marked passive;</a>
<a name="ln751">				 * send a probe request now that we know there</a>
<a name="ln752">				 * is 802.11 traffic present.</a>
<a name="ln753">				 *</a>
<a name="ln754">				 * XXX check if the beacon we recv'd gives</a>
<a name="ln755">				 * us what we need and suppress the probe req</a>
<a name="ln756">				 */</a>
<a name="ln757">				ieee80211_probe_curchan(vap, 1);</a>
<a name="ln758">				ic-&gt;ic_flags_ext &amp;= ~IEEE80211_FEXT_PROBECHAN;</a>
<a name="ln759">			}</a>
<a name="ln760">			ieee80211_add_scan(vap, rxchan, &amp;scan, wh,</a>
<a name="ln761">			    subtype, rssi, nf);</a>
<a name="ln762">			return;</a>
<a name="ln763">		}</a>
<a name="ln764">		if (scan.capinfo &amp; IEEE80211_CAPINFO_IBSS) {</a>
<a name="ln765">			if (!IEEE80211_ADDR_EQ(wh-&gt;i_addr2, ni-&gt;ni_macaddr)) {</a>
<a name="ln766">				/*</a>
<a name="ln767">				 * Create a new entry in the neighbor table.</a>
<a name="ln768">				 *</a>
<a name="ln769">				 * XXX TODO:</a>
<a name="ln770">				 *</a>
<a name="ln771">				 * Here we're not scanning; so if we have an</a>
<a name="ln772">				 * SSID then make sure it matches our SSID.</a>
<a name="ln773">				 * Otherwise this code will match on all IBSS</a>
<a name="ln774">				 * beacons/probe requests for all SSIDs,</a>
<a name="ln775">				 * filling the node table with nodes that</a>
<a name="ln776">				 * aren't ours.</a>
<a name="ln777">				 */</a>
<a name="ln778">				if (ieee80211_ibss_node_check_new(ni, &amp;scan)) {</a>
<a name="ln779">					ni = ieee80211_add_neighbor(vap, wh, &amp;scan);</a>
<a name="ln780">					/*</a>
<a name="ln781">					 * Send a probe request so we announce 11n</a>
<a name="ln782">					 * capabilities.</a>
<a name="ln783">					 */</a>
<a name="ln784">					ieee80211_send_probereq(ni, /* node */</a>
<a name="ln785">					    vap-&gt;iv_myaddr, /* SA */</a>
<a name="ln786">					    ni-&gt;ni_macaddr, /* DA */</a>
<a name="ln787">					    vap-&gt;iv_bss-&gt;ni_bssid, /* BSSID */</a>
<a name="ln788">					    vap-&gt;iv_bss-&gt;ni_essid,</a>
<a name="ln789">					    vap-&gt;iv_bss-&gt;ni_esslen); /* SSID */</a>
<a name="ln790">				} else</a>
<a name="ln791">					ni = NULL;</a>
<a name="ln792"> </a>
<a name="ln793">			} else if (ni-&gt;ni_capinfo == 0) {</a>
<a name="ln794">				/*</a>
<a name="ln795">				 * Update faked node created on transmit.</a>
<a name="ln796">				 * Note this also updates the tsf.</a>
<a name="ln797">				 */</a>
<a name="ln798">				ieee80211_init_neighbor(ni, wh, &amp;scan);</a>
<a name="ln799"> </a>
<a name="ln800">				/*</a>
<a name="ln801">				 * Send a probe request so we announce 11n</a>
<a name="ln802">				 * capabilities.</a>
<a name="ln803">				 */</a>
<a name="ln804">				ieee80211_send_probereq(ni, /* node */</a>
<a name="ln805">					vap-&gt;iv_myaddr, /* SA */</a>
<a name="ln806">					ni-&gt;ni_macaddr, /* DA */</a>
<a name="ln807">					vap-&gt;iv_bss-&gt;ni_bssid, /* BSSID */</a>
<a name="ln808">					vap-&gt;iv_bss-&gt;ni_essid,</a>
<a name="ln809">					vap-&gt;iv_bss-&gt;ni_esslen); /* SSID */</a>
<a name="ln810">			} else {</a>
<a name="ln811">				/*</a>
<a name="ln812">				 * Record tsf for potential resync.</a>
<a name="ln813">				 */</a>
<a name="ln814">				memcpy(ni-&gt;ni_tstamp.data, scan.tstamp,</a>
<a name="ln815">					sizeof(ni-&gt;ni_tstamp));</a>
<a name="ln816">			}</a>
<a name="ln817">			/*</a>
<a name="ln818">			 * This isn't enabled yet - otherwise it would</a>
<a name="ln819">			 * update the HT parameters and channel width</a>
<a name="ln820">			 * from any node, which could lead to lots of</a>
<a name="ln821">			 * strange behaviour if the 11n nodes aren't</a>
<a name="ln822">			 * exactly configured to match.</a>
<a name="ln823">			 */</a>
<a name="ln824">#if 0</a>
<a name="ln825">			if (scan.htcap != NULL &amp;&amp; scan.htinfo != NULL &amp;&amp;</a>
<a name="ln826">			    (vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_HT)) {</a>
<a name="ln827">				ieee80211_ht_updateparams(ni,</a>
<a name="ln828">				    scan.htcap, scan.htinfo));</a>
<a name="ln829">				if (ieee80211_ht_updateparams_final(ni,</a>
<a name="ln830">				    scan.htcap, scan.htinfo))</a>
<a name="ln831">					ht_state_change = 1;</a>
<a name="ln832">			}</a>
<a name="ln833"> </a>
<a name="ln834">			/* XXX same for VHT? */</a>
<a name="ln835">#endif</a>
<a name="ln836">			if (ni != NULL) {</a>
<a name="ln837">				IEEE80211_RSSI_LPF(ni-&gt;ni_avgrssi, rssi);</a>
<a name="ln838">				ni-&gt;ni_noise = nf;</a>
<a name="ln839">			}</a>
<a name="ln840">			/*</a>
<a name="ln841">			 * Same here - the channel width change should</a>
<a name="ln842">			 * be applied to the specific peer node, not</a>
<a name="ln843">			 * to the ic.  Ie, the interface configuration</a>
<a name="ln844">			 * should stay in its current channel width;</a>
<a name="ln845">			 * but it should change the rate control and</a>
<a name="ln846">			 * any queued frames for the given node only.</a>
<a name="ln847">			 *</a>
<a name="ln848">			 * Since there's no (current) way to inform</a>
<a name="ln849">			 * the driver that a channel width change has</a>
<a name="ln850">			 * occurred for a single node, just stub this</a>
<a name="ln851">			 * out.</a>
<a name="ln852">			 */</a>
<a name="ln853">#if 0</a>
<a name="ln854">			if (ht_state_change)</a>
<a name="ln855">				ieee80211_update_chw(ic);</a>
<a name="ln856">#endif</a>
<a name="ln857">		}</a>
<a name="ln858">		break;</a>
<a name="ln859">	}</a>
<a name="ln860"> </a>
<a name="ln861">	case IEEE80211_FC0_SUBTYPE_PROBE_REQ:</a>
<a name="ln862">		if (vap-&gt;iv_state != IEEE80211_S_RUN) {</a>
<a name="ln863">			IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln864">			    wh, NULL, &quot;wrong state %s&quot;,</a>
<a name="ln865">			    ieee80211_state_name[vap-&gt;iv_state]);</a>
<a name="ln866">			vap-&gt;iv_stats.is_rx_mgtdiscard++;</a>
<a name="ln867">			return;</a>
<a name="ln868">		}</a>
<a name="ln869">		if (IEEE80211_IS_MULTICAST(wh-&gt;i_addr2)) {</a>
<a name="ln870">			/* frame must be directed */</a>
<a name="ln871">			IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln872">			    wh, NULL, &quot;%s&quot;, &quot;not unicast&quot;);</a>
<a name="ln873">			vap-&gt;iv_stats.is_rx_mgtdiscard++;	/* XXX stat */</a>
<a name="ln874">			return;</a>
<a name="ln875">		}</a>
<a name="ln876"> </a>
<a name="ln877">		/*</a>
<a name="ln878">		 * prreq frame format</a>
<a name="ln879">		 *	[tlv] ssid</a>
<a name="ln880">		 *	[tlv] supported rates</a>
<a name="ln881">		 *	[tlv] extended supported rates</a>
<a name="ln882">		 */</a>
<a name="ln883">		ssid = rates = xrates = NULL;</a>
<a name="ln884">		while (efrm - frm &gt; 1) {</a>
<a name="ln885">			IEEE80211_VERIFY_LENGTH(efrm - frm, frm[1] + 2, return);</a>
<a name="ln886">			switch (*frm) {</a>
<a name="ln887">			case IEEE80211_ELEMID_SSID:</a>
<a name="ln888">				ssid = frm;</a>
<a name="ln889">				break;</a>
<a name="ln890">			case IEEE80211_ELEMID_RATES:</a>
<a name="ln891">				rates = frm;</a>
<a name="ln892">				break;</a>
<a name="ln893">			case IEEE80211_ELEMID_XRATES:</a>
<a name="ln894">				xrates = frm;</a>
<a name="ln895">				break;</a>
<a name="ln896">			}</a>
<a name="ln897">			frm += frm[1] + 2;</a>
<a name="ln898">		}</a>
<a name="ln899">		IEEE80211_VERIFY_ELEMENT(rates, IEEE80211_RATE_MAXSIZE, return);</a>
<a name="ln900">		if (xrates != NULL)</a>
<a name="ln901">			IEEE80211_VERIFY_ELEMENT(xrates,</a>
<a name="ln902">				IEEE80211_RATE_MAXSIZE - rates[1], return);</a>
<a name="ln903">		IEEE80211_VERIFY_ELEMENT(ssid, IEEE80211_NWID_LEN, return);</a>
<a name="ln904">		IEEE80211_VERIFY_SSID(vap-&gt;iv_bss, ssid, return);</a>
<a name="ln905">		if ((vap-&gt;iv_flags &amp; IEEE80211_F_HIDESSID) &amp;&amp; ssid[1] == 0) {</a>
<a name="ln906">			IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln907">			    wh, NULL,</a>
<a name="ln908">			    &quot;%s&quot;, &quot;no ssid with ssid suppression enabled&quot;);</a>
<a name="ln909">			vap-&gt;iv_stats.is_rx_ssidmismatch++; /*XXX*/</a>
<a name="ln910">			return;</a>
<a name="ln911">		}</a>
<a name="ln912"> </a>
<a name="ln913">		/* XXX find a better class or define it's own */</a>
<a name="ln914">		IEEE80211_NOTE_MAC(vap, IEEE80211_MSG_INPUT, wh-&gt;i_addr2,</a>
<a name="ln915">		    &quot;%s&quot;, &quot;recv probe req&quot;);</a>
<a name="ln916">		/*</a>
<a name="ln917">		 * Some legacy 11b clients cannot hack a complete</a>
<a name="ln918">		 * probe response frame.  When the request includes</a>
<a name="ln919">		 * only a bare-bones rate set, communicate this to</a>
<a name="ln920">		 * the transmit side.</a>
<a name="ln921">		 */</a>
<a name="ln922">		ieee80211_send_proberesp(vap, wh-&gt;i_addr2,</a>
<a name="ln923">		    is11bclient(rates, xrates) ? IEEE80211_SEND_LEGACY_11B : 0);</a>
<a name="ln924"> </a>
<a name="ln925">		/*</a>
<a name="ln926">		 * Note: we don't benefit from stashing the probe request</a>
<a name="ln927">		 * IEs away to use for IBSS negotiation, because we</a>
<a name="ln928">		 * typically don't get all of the IEs.</a>
<a name="ln929">		 */</a>
<a name="ln930">		break;</a>
<a name="ln931"> </a>
<a name="ln932">	case IEEE80211_FC0_SUBTYPE_ACTION:</a>
<a name="ln933">	case IEEE80211_FC0_SUBTYPE_ACTION_NOACK:</a>
<a name="ln934">		if ((ni == vap-&gt;iv_bss) &amp;&amp;</a>
<a name="ln935">		    !IEEE80211_ADDR_EQ(wh-&gt;i_addr2, ni-&gt;ni_macaddr)) {</a>
<a name="ln936">			IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln937">			    wh, NULL, &quot;%s&quot;, &quot;unknown node&quot;);</a>
<a name="ln938">			vap-&gt;iv_stats.is_rx_mgtdiscard++;</a>
<a name="ln939">		} else if (!IEEE80211_ADDR_EQ(vap-&gt;iv_myaddr, wh-&gt;i_addr1) &amp;&amp;</a>
<a name="ln940">		    !IEEE80211_IS_MULTICAST(wh-&gt;i_addr1)) {</a>
<a name="ln941">			IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln942">			    wh, NULL, &quot;%s&quot;, &quot;not for us&quot;);</a>
<a name="ln943">			vap-&gt;iv_stats.is_rx_mgtdiscard++;</a>
<a name="ln944">		} else if (vap-&gt;iv_state != IEEE80211_S_RUN) {</a>
<a name="ln945">			IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln946">			    wh, NULL, &quot;wrong state %s&quot;,</a>
<a name="ln947">			    ieee80211_state_name[vap-&gt;iv_state]);</a>
<a name="ln948">			vap-&gt;iv_stats.is_rx_mgtdiscard++;</a>
<a name="ln949">		} else {</a>
<a name="ln950">			if (ieee80211_parse_action(ni, m0) == 0)</a>
<a name="ln951">				(void)ic-&gt;ic_recv_action(ni, wh, frm, efrm);</a>
<a name="ln952">		}</a>
<a name="ln953">		break;</a>
<a name="ln954"> </a>
<a name="ln955">	case IEEE80211_FC0_SUBTYPE_ASSOC_REQ:</a>
<a name="ln956">	case IEEE80211_FC0_SUBTYPE_ASSOC_RESP:</a>
<a name="ln957">	case IEEE80211_FC0_SUBTYPE_REASSOC_REQ:</a>
<a name="ln958">	case IEEE80211_FC0_SUBTYPE_REASSOC_RESP:</a>
<a name="ln959">	case IEEE80211_FC0_SUBTYPE_TIMING_ADV:</a>
<a name="ln960">	case IEEE80211_FC0_SUBTYPE_ATIM:</a>
<a name="ln961">	case IEEE80211_FC0_SUBTYPE_DISASSOC:</a>
<a name="ln962">	case IEEE80211_FC0_SUBTYPE_AUTH:</a>
<a name="ln963">	case IEEE80211_FC0_SUBTYPE_DEAUTH:</a>
<a name="ln964">		IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln965">		    wh, NULL, &quot;%s&quot;, &quot;not handled&quot;);</a>
<a name="ln966">		vap-&gt;iv_stats.is_rx_mgtdiscard++;</a>
<a name="ln967">		break;</a>
<a name="ln968"> </a>
<a name="ln969">	default:</a>
<a name="ln970">		IEEE80211_DISCARD(vap, IEEE80211_MSG_ANY,</a>
<a name="ln971">		    wh, &quot;mgt&quot;, &quot;subtype 0x%x not handled&quot;, subtype);</a>
<a name="ln972">		vap-&gt;iv_stats.is_rx_badsubtype++;</a>
<a name="ln973">		break;</a>
<a name="ln974">	}</a>
<a name="ln975">}</a>
<a name="ln976">#undef IEEE80211_VERIFY_LENGTH</a>
<a name="ln977">#undef IEEE80211_VERIFY_ELEMENT</a>
<a name="ln978"> </a>
<a name="ln979">static void</a>
<a name="ln980">ahdemo_recv_mgmt(struct ieee80211_node *ni, struct mbuf *m0,</a>
<a name="ln981">	int subtype, const struct ieee80211_rx_stats *rxs, int rssi, int nf)</a>
<a name="ln982">{</a>
<a name="ln983">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln984">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln985">	struct ieee80211_frame *wh;</a>
<a name="ln986"> </a>
<a name="ln987">	/*</a>
<a name="ln988">	 * Process management frames when scanning; useful for doing</a>
<a name="ln989">	 * a site-survey.</a>
<a name="ln990">	 */</a>
<a name="ln991">	if (ic-&gt;ic_flags &amp; IEEE80211_F_SCAN)</a>
<a name="ln992">		adhoc_recv_mgmt(ni, m0, subtype, rxs, rssi, nf);</a>
<a name="ln993">	else {</a>
<a name="ln994">		wh = mtod(m0, struct ieee80211_frame *);</a>
<a name="ln995">		switch (subtype) {</a>
<a name="ln996">		case IEEE80211_FC0_SUBTYPE_ASSOC_REQ:</a>
<a name="ln997">		case IEEE80211_FC0_SUBTYPE_ASSOC_RESP:</a>
<a name="ln998">		case IEEE80211_FC0_SUBTYPE_REASSOC_REQ:</a>
<a name="ln999">		case IEEE80211_FC0_SUBTYPE_REASSOC_RESP:</a>
<a name="ln1000">		case IEEE80211_FC0_SUBTYPE_PROBE_REQ:</a>
<a name="ln1001">		case IEEE80211_FC0_SUBTYPE_PROBE_RESP:</a>
<a name="ln1002">		case IEEE80211_FC0_SUBTYPE_TIMING_ADV:</a>
<a name="ln1003">		case IEEE80211_FC0_SUBTYPE_BEACON:</a>
<a name="ln1004">		case IEEE80211_FC0_SUBTYPE_ATIM:</a>
<a name="ln1005">		case IEEE80211_FC0_SUBTYPE_DISASSOC:</a>
<a name="ln1006">		case IEEE80211_FC0_SUBTYPE_AUTH:</a>
<a name="ln1007">		case IEEE80211_FC0_SUBTYPE_DEAUTH:</a>
<a name="ln1008">		case IEEE80211_FC0_SUBTYPE_ACTION:</a>
<a name="ln1009">		case IEEE80211_FC0_SUBTYPE_ACTION_NOACK:</a>
<a name="ln1010">			IEEE80211_DISCARD(vap, IEEE80211_MSG_INPUT,</a>
<a name="ln1011">			     wh, NULL, &quot;%s&quot;, &quot;not handled&quot;);</a>
<a name="ln1012">			vap-&gt;iv_stats.is_rx_mgtdiscard++;</a>
<a name="ln1013">			break;</a>
<a name="ln1014">		default:</a>
<a name="ln1015">			IEEE80211_DISCARD(vap, IEEE80211_MSG_ANY,</a>
<a name="ln1016">			     wh, &quot;mgt&quot;, &quot;subtype 0x%x not handled&quot;, subtype);</a>
<a name="ln1017">			vap-&gt;iv_stats.is_rx_badsubtype++;</a>
<a name="ln1018">			break;</a>
<a name="ln1019">		}</a>
<a name="ln1020">	}</a>
<a name="ln1021">}</a>
<a name="ln1022"> </a>
<a name="ln1023">static void</a>
<a name="ln1024">adhoc_recv_ctl(struct ieee80211_node *ni, struct mbuf *m, int subtype)</a>
<a name="ln1025">{</a>
<a name="ln1026"> </a>
<a name="ln1027">	switch (subtype) {</a>
<a name="ln1028">	case IEEE80211_FC0_SUBTYPE_BAR:</a>
<a name="ln1029">		ieee80211_recv_bar(ni, m);</a>
<a name="ln1030">		break;</a>
<a name="ln1031">	}</a>
<a name="ln1032">}</a>

</code></pre>
<div class="balloon" rel="689"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v634/" target="_blank">V634</a> The priority of the '*' operation is higher than that of the '<<' operation. It's possible that parentheses should be used in the expression.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
