
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>if_rtwn.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*	$OpenBSD: if_urtwn.c,v 1.16 2011/02/10 17:26:40 jakemsr Exp $	*/</a>
<a name="ln2"> </a>
<a name="ln3">/*-</a>
<a name="ln4"> * Copyright (c) 2010 Damien Bergamini &lt;damien.bergamini@free.fr&gt;</a>
<a name="ln5"> * Copyright (c) 2014 Kevin Lo &lt;kevlo@FreeBSD.org&gt;</a>
<a name="ln6"> * Copyright (c) 2015-2016 Andriy Voskoboinyk &lt;avos@FreeBSD.org&gt;</a>
<a name="ln7"> *</a>
<a name="ln8"> * Permission to use, copy, modify, and distribute this software for any</a>
<a name="ln9"> * purpose with or without fee is hereby granted, provided that the above</a>
<a name="ln10"> * copyright notice and this permission notice appear in all copies.</a>
<a name="ln11"> *</a>
<a name="ln12"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES</a>
<a name="ln13"> * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</a>
<a name="ln14"> * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR</a>
<a name="ln15"> * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</a>
<a name="ln16"> * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</a>
<a name="ln17"> * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</a>
<a name="ln18"> * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</a>
<a name="ln19"> */</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln22">__FBSDID(&quot;$FreeBSD$&quot;);</a>
<a name="ln23"> </a>
<a name="ln24">/*</a>
<a name="ln25"> * Driver for Realtek RTL8188CE-VAU/RTL8188CUS/RTL8188EU/RTL8188RU/RTL8192CU/RTL8812AU/RTL8821AU.</a>
<a name="ln26"> */</a>
<a name="ln27">#include &quot;opt_wlan.h&quot;</a>
<a name="ln28"> </a>
<a name="ln29">#include &lt;sys/param.h&gt;</a>
<a name="ln30">#include &lt;sys/sockio.h&gt;</a>
<a name="ln31">#include &lt;sys/sysctl.h&gt;</a>
<a name="ln32">#include &lt;sys/lock.h&gt;</a>
<a name="ln33">#include &lt;sys/mutex.h&gt;</a>
<a name="ln34">#include &lt;sys/mbuf.h&gt;</a>
<a name="ln35">#include &lt;sys/kernel.h&gt;</a>
<a name="ln36">#include &lt;sys/socket.h&gt;</a>
<a name="ln37">#include &lt;sys/systm.h&gt;</a>
<a name="ln38">#include &lt;sys/malloc.h&gt;</a>
<a name="ln39">#include &lt;sys/module.h&gt;</a>
<a name="ln40">#include &lt;sys/bus.h&gt;</a>
<a name="ln41">#include &lt;sys/endian.h&gt;</a>
<a name="ln42">#include &lt;sys/linker.h&gt;</a>
<a name="ln43">#include &lt;sys/firmware.h&gt;</a>
<a name="ln44">#include &lt;sys/kdb.h&gt;</a>
<a name="ln45"> </a>
<a name="ln46">#include &lt;net/bpf.h&gt;</a>
<a name="ln47">#include &lt;net/if.h&gt;</a>
<a name="ln48">#include &lt;net/if_var.h&gt;</a>
<a name="ln49">#include &lt;net/if_arp.h&gt;</a>
<a name="ln50">#include &lt;net/ethernet.h&gt;</a>
<a name="ln51">#include &lt;net/if_dl.h&gt;</a>
<a name="ln52">#include &lt;net/if_media.h&gt;</a>
<a name="ln53">#include &lt;net/if_types.h&gt;</a>
<a name="ln54"> </a>
<a name="ln55">#include &lt;netinet/in.h&gt;</a>
<a name="ln56">#include &lt;netinet/in_systm.h&gt;</a>
<a name="ln57">#include &lt;netinet/in_var.h&gt;</a>
<a name="ln58">#include &lt;netinet/if_ether.h&gt;</a>
<a name="ln59">#include &lt;netinet/ip.h&gt;</a>
<a name="ln60"> </a>
<a name="ln61">#include &lt;net80211/ieee80211_var.h&gt;</a>
<a name="ln62">#include &lt;net80211/ieee80211_regdomain.h&gt;</a>
<a name="ln63">#include &lt;net80211/ieee80211_radiotap.h&gt;</a>
<a name="ln64">#include &lt;net80211/ieee80211_ratectl.h&gt;</a>
<a name="ln65"> </a>
<a name="ln66">#include &lt;dev/rtwn/if_rtwnreg.h&gt;</a>
<a name="ln67">#include &lt;dev/rtwn/if_rtwnvar.h&gt;</a>
<a name="ln68"> </a>
<a name="ln69">#include &lt;dev/rtwn/if_rtwn_beacon.h&gt;</a>
<a name="ln70">#include &lt;dev/rtwn/if_rtwn_calib.h&gt;</a>
<a name="ln71">#include &lt;dev/rtwn/if_rtwn_cam.h&gt;</a>
<a name="ln72">#include &lt;dev/rtwn/if_rtwn_debug.h&gt;</a>
<a name="ln73">#include &lt;dev/rtwn/if_rtwn_efuse.h&gt;</a>
<a name="ln74">#include &lt;dev/rtwn/if_rtwn_fw.h&gt;</a>
<a name="ln75">#include &lt;dev/rtwn/if_rtwn_ridx.h&gt;</a>
<a name="ln76">#include &lt;dev/rtwn/if_rtwn_rx.h&gt;</a>
<a name="ln77">#include &lt;dev/rtwn/if_rtwn_task.h&gt;</a>
<a name="ln78">#include &lt;dev/rtwn/if_rtwn_tx.h&gt;</a>
<a name="ln79"> </a>
<a name="ln80">#include &lt;dev/rtwn/rtl8192c/r92c_reg.h&gt;</a>
<a name="ln81"> </a>
<a name="ln82"> </a>
<a name="ln83">static void		rtwn_radiotap_attach(struct rtwn_softc *);</a>
<a name="ln84">static void		rtwn_vap_decrement_counters(struct rtwn_softc *,</a>
<a name="ln85">			    enum ieee80211_opmode, int);</a>
<a name="ln86">static void		rtwn_set_ic_opmode(struct rtwn_softc *);</a>
<a name="ln87">static struct ieee80211vap *rtwn_vap_create(struct ieee80211com *,</a>
<a name="ln88">			    const char [IFNAMSIZ], int, enum ieee80211_opmode,</a>
<a name="ln89">			    int, const uint8_t [IEEE80211_ADDR_LEN],</a>
<a name="ln90">			    const uint8_t [IEEE80211_ADDR_LEN]);</a>
<a name="ln91">static void		rtwn_vap_delete(struct ieee80211vap *);</a>
<a name="ln92">static int		rtwn_read_chipid(struct rtwn_softc *);</a>
<a name="ln93">static int		rtwn_ioctl_reset(struct ieee80211vap *, u_long);</a>
<a name="ln94">static void		rtwn_set_media_status(struct rtwn_softc *,</a>
<a name="ln95">			    union sec_param *);</a>
<a name="ln96">#ifndef RTWN_WITHOUT_UCODE</a>
<a name="ln97">static int		rtwn_tx_fwpkt_check(struct rtwn_softc *,</a>
<a name="ln98">			    struct ieee80211vap *);</a>
<a name="ln99">static int		rtwn_construct_nulldata(struct rtwn_softc *,</a>
<a name="ln100">			    struct ieee80211vap *, uint8_t *, int);</a>
<a name="ln101">static int		rtwn_push_nulldata(struct rtwn_softc *,</a>
<a name="ln102">			    struct ieee80211vap *);</a>
<a name="ln103">static void		rtwn_pwrmode_init(void *);</a>
<a name="ln104">static void		rtwn_set_pwrmode_cb(struct rtwn_softc *,</a>
<a name="ln105">			    union sec_param *);</a>
<a name="ln106">#endif</a>
<a name="ln107">static void		rtwn_tsf_sync_adhoc(void *);</a>
<a name="ln108">static void		rtwn_tsf_sync_adhoc_task(void *, int);</a>
<a name="ln109">static void		rtwn_tsf_sync_enable(struct rtwn_softc *,</a>
<a name="ln110">			    struct ieee80211vap *);</a>
<a name="ln111">static void		rtwn_set_ack_preamble(struct rtwn_softc *);</a>
<a name="ln112">static void		rtwn_set_mode(struct rtwn_softc *, uint8_t, int);</a>
<a name="ln113">static int		rtwn_monitor_newstate(struct ieee80211vap *,</a>
<a name="ln114">			    enum ieee80211_state, int);</a>
<a name="ln115">static int		rtwn_newstate(struct ieee80211vap *,</a>
<a name="ln116">			    enum ieee80211_state, int);</a>
<a name="ln117">static void		rtwn_calc_basicrates(struct rtwn_softc *);</a>
<a name="ln118">static int		rtwn_run(struct rtwn_softc *,</a>
<a name="ln119">			    struct ieee80211vap *);</a>
<a name="ln120">#ifndef D4054</a>
<a name="ln121">static void		rtwn_watchdog(void *);</a>
<a name="ln122">#endif</a>
<a name="ln123">static void		rtwn_parent(struct ieee80211com *);</a>
<a name="ln124">static int		rtwn_dma_init(struct rtwn_softc *);</a>
<a name="ln125">static int		rtwn_mac_init(struct rtwn_softc *);</a>
<a name="ln126">static void		rtwn_mrr_init(struct rtwn_softc *);</a>
<a name="ln127">static void		rtwn_scan_start(struct ieee80211com *);</a>
<a name="ln128">static void		rtwn_scan_curchan(struct ieee80211_scan_state *,</a>
<a name="ln129">			    unsigned long);</a>
<a name="ln130">static void		rtwn_scan_end(struct ieee80211com *);</a>
<a name="ln131">static void		rtwn_getradiocaps(struct ieee80211com *, int, int *,</a>
<a name="ln132">			    struct ieee80211_channel[]);</a>
<a name="ln133">static void		rtwn_update_chw(struct ieee80211com *);</a>
<a name="ln134">static void		rtwn_set_channel(struct ieee80211com *);</a>
<a name="ln135">static int		rtwn_wme_update(struct ieee80211com *);</a>
<a name="ln136">static void		rtwn_update_slot(struct ieee80211com *);</a>
<a name="ln137">static void		rtwn_update_slot_cb(struct rtwn_softc *,</a>
<a name="ln138">			    union sec_param *);</a>
<a name="ln139">static void		rtwn_update_aifs(struct rtwn_softc *, uint8_t);</a>
<a name="ln140">static void		rtwn_update_promisc(struct ieee80211com *);</a>
<a name="ln141">static void		rtwn_update_mcast(struct ieee80211com *);</a>
<a name="ln142">static int		rtwn_set_bssid(struct rtwn_softc *,</a>
<a name="ln143">			    const uint8_t *, int);</a>
<a name="ln144">static int		rtwn_set_macaddr(struct rtwn_softc *,</a>
<a name="ln145">			    const uint8_t *, int);</a>
<a name="ln146">static struct ieee80211_node *rtwn_node_alloc(struct ieee80211vap *,</a>
<a name="ln147">			    const uint8_t mac[IEEE80211_ADDR_LEN]);</a>
<a name="ln148">static void		rtwn_newassoc(struct ieee80211_node *, int);</a>
<a name="ln149">static void		rtwn_node_free(struct ieee80211_node *);</a>
<a name="ln150">static void		rtwn_init_beacon_reg(struct rtwn_softc *);</a>
<a name="ln151">static int		rtwn_init(struct rtwn_softc *);</a>
<a name="ln152">static void		rtwn_stop(struct rtwn_softc *);</a>
<a name="ln153"> </a>
<a name="ln154">MALLOC_DEFINE(M_RTWN_PRIV, &quot;rtwn_priv&quot;, &quot;rtwn driver private state&quot;);</a>
<a name="ln155"> </a>
<a name="ln156">static const uint8_t rtwn_chan_2ghz[] =</a>
<a name="ln157">	{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 };</a>
<a name="ln158"> </a>
<a name="ln159">static const uint16_t wme2reg[] =</a>
<a name="ln160">	{ R92C_EDCA_BE_PARAM, R92C_EDCA_BK_PARAM,</a>
<a name="ln161">	  R92C_EDCA_VI_PARAM, R92C_EDCA_VO_PARAM };</a>
<a name="ln162"> </a>
<a name="ln163">int</a>
<a name="ln164">rtwn_attach(struct rtwn_softc *sc)</a>
<a name="ln165">{</a>
<a name="ln166">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln167">	int error;</a>
<a name="ln168"> </a>
<a name="ln169">	sc-&gt;cur_bcnq_id = RTWN_VAP_ID_INVALID;</a>
<a name="ln170"> </a>
<a name="ln171">	RTWN_NT_LOCK_INIT(sc);</a>
<a name="ln172">	rtwn_cmdq_init(sc);</a>
<a name="ln173">#ifndef D4054</a>
<a name="ln174">	callout_init_mtx(&amp;sc-&gt;sc_watchdog_to, &amp;sc-&gt;sc_mtx, 0);</a>
<a name="ln175">#endif</a>
<a name="ln176">	callout_init(&amp;sc-&gt;sc_calib_to, 0);</a>
<a name="ln177">	callout_init(&amp;sc-&gt;sc_pwrmode_init, 0);</a>
<a name="ln178">	mbufq_init(&amp;sc-&gt;sc_snd, ifqmaxlen);</a>
<a name="ln179"> </a>
<a name="ln180">	RTWN_LOCK(sc);</a>
<a name="ln181">	error = rtwn_read_chipid(sc);</a>
<a name="ln182">	RTWN_UNLOCK(sc);</a>
<a name="ln183">	if (error != 0) {</a>
<a name="ln184">		device_printf(sc-&gt;sc_dev, &quot;unsupported test chip\n&quot;);</a>
<a name="ln185">		goto detach;</a>
<a name="ln186">	}</a>
<a name="ln187"> </a>
<a name="ln188">	error = rtwn_read_rom(sc);</a>
<a name="ln189">	if (error != 0) {</a>
<a name="ln190">		device_printf(sc-&gt;sc_dev, &quot;%s: cannot read rom, error %d\n&quot;,</a>
<a name="ln191">		    __func__, error);</a>
<a name="ln192">		goto detach;</a>
<a name="ln193">	}</a>
<a name="ln194"> </a>
<a name="ln195">	if (sc-&gt;macid_limit &gt; RTWN_MACID_LIMIT) {</a>
<a name="ln196">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln197">		    &quot;macid limit will be reduced from %d to %d\n&quot;,</a>
<a name="ln198">		    sc-&gt;macid_limit, RTWN_MACID_LIMIT);</a>
<a name="ln199">		sc-&gt;macid_limit = RTWN_MACID_LIMIT;</a>
<a name="ln200">	}</a>
<a name="ln201">	if (sc-&gt;cam_entry_limit &gt; RTWN_CAM_ENTRY_LIMIT) {</a>
<a name="ln202">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln203">		    &quot;cam entry limit will be reduced from %d to %d\n&quot;,</a>
<a name="ln204">		    sc-&gt;cam_entry_limit, RTWN_CAM_ENTRY_LIMIT);</a>
<a name="ln205">		sc-&gt;cam_entry_limit = RTWN_CAM_ENTRY_LIMIT;</a>
<a name="ln206">	}</a>
<a name="ln207">	if (sc-&gt;txdesc_len &gt; RTWN_TX_DESC_SIZE) {</a>
<a name="ln208">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln209">		    &quot;adjust size for Tx descriptor (current %d, needed %d)\n&quot;,</a>
<a name="ln210">		    RTWN_TX_DESC_SIZE, sc-&gt;txdesc_len);</a>
<a name="ln211">		goto detach;</a>
<a name="ln212">	}</a>
<a name="ln213"> </a>
<a name="ln214">	device_printf(sc-&gt;sc_dev, &quot;MAC/BB %s, RF 6052 %dT%dR\n&quot;,</a>
<a name="ln215">	    sc-&gt;name, sc-&gt;ntxchains, sc-&gt;nrxchains);</a>
<a name="ln216"> </a>
<a name="ln217">	ic-&gt;ic_softc = sc;</a>
<a name="ln218">	ic-&gt;ic_phytype = IEEE80211_T_OFDM;	/* not only, but not used */</a>
<a name="ln219">	ic-&gt;ic_opmode = IEEE80211_M_STA;	/* default to BSS mode */</a>
<a name="ln220"> </a>
<a name="ln221">	/* set device capabilities */</a>
<a name="ln222">	ic-&gt;ic_caps =</a>
<a name="ln223">		  IEEE80211_C_STA		/* station mode */</a>
<a name="ln224">		| IEEE80211_C_MONITOR		/* monitor mode */</a>
<a name="ln225">		| IEEE80211_C_IBSS		/* adhoc mode */</a>
<a name="ln226">		| IEEE80211_C_HOSTAP		/* hostap mode */</a>
<a name="ln227">#if 0	/* TODO: HRPWM register setup */</a>
<a name="ln228">#ifndef RTWN_WITHOUT_UCODE</a>
<a name="ln229">		| IEEE80211_C_PMGT		/* Station-side power mgmt */</a>
<a name="ln230">#endif</a>
<a name="ln231">#endif</a>
<a name="ln232">		| IEEE80211_C_SHPREAMBLE	/* short preamble supported */</a>
<a name="ln233">		| IEEE80211_C_SHSLOT		/* short slot time supported */</a>
<a name="ln234">#if 0</a>
<a name="ln235">		| IEEE80211_C_BGSCAN		/* capable of bg scanning */</a>
<a name="ln236">#endif</a>
<a name="ln237">		| IEEE80211_C_WPA		/* 802.11i */</a>
<a name="ln238">		| IEEE80211_C_WME		/* 802.11e */</a>
<a name="ln239">		| IEEE80211_C_SWAMSDUTX		/* Do software A-MSDU TX */</a>
<a name="ln240">		| IEEE80211_C_FF		/* Atheros fast-frames */</a>
<a name="ln241">		;</a>
<a name="ln242"> </a>
<a name="ln243">	if (sc-&gt;sc_hwcrypto != RTWN_CRYPTO_SW) {</a>
<a name="ln244">		ic-&gt;ic_cryptocaps =</a>
<a name="ln245">		    IEEE80211_CRYPTO_WEP |</a>
<a name="ln246">		    IEEE80211_CRYPTO_TKIP |</a>
<a name="ln247">		    IEEE80211_CRYPTO_AES_CCM;</a>
<a name="ln248">	}</a>
<a name="ln249"> </a>
<a name="ln250">	ic-&gt;ic_htcaps =</a>
<a name="ln251">	      IEEE80211_HTCAP_SHORTGI20		/* short GI in 20MHz */</a>
<a name="ln252">	    | IEEE80211_HTCAP_MAXAMSDU_3839	/* max A-MSDU length */</a>
<a name="ln253">	    | IEEE80211_HTCAP_SMPS_OFF		/* SM PS mode disabled */</a>
<a name="ln254">	    /* s/w capabilities */</a>
<a name="ln255">	    | IEEE80211_HTC_HT			/* HT operation */</a>
<a name="ln256">	    | IEEE80211_HTC_AMPDU		/* A-MPDU tx */</a>
<a name="ln257">	    | IEEE80211_HTC_AMSDU		/* A-MSDU tx */</a>
<a name="ln258">	    ;</a>
<a name="ln259"> </a>
<a name="ln260">	if (sc-&gt;sc_ht40) {</a>
<a name="ln261">		ic-&gt;ic_htcaps |=</a>
<a name="ln262">		      IEEE80211_HTCAP_CHWIDTH40	/* 40 MHz channel width */</a>
<a name="ln263">		    | IEEE80211_HTCAP_SHORTGI40	/* short GI in 40MHz */</a>
<a name="ln264">		    ;</a>
<a name="ln265">	}</a>
<a name="ln266"> </a>
<a name="ln267">	ic-&gt;ic_txstream = sc-&gt;ntxchains;</a>
<a name="ln268">	ic-&gt;ic_rxstream = sc-&gt;nrxchains;</a>
<a name="ln269"> </a>
<a name="ln270">	/* Enable TX watchdog */</a>
<a name="ln271">#ifdef D4054</a>
<a name="ln272">	ic-&gt;ic_flags_ext |= IEEE80211_FEXT_WATCHDOG;</a>
<a name="ln273">#endif</a>
<a name="ln274"> </a>
<a name="ln275">	/* Adjust capabilities. */</a>
<a name="ln276">	rtwn_adj_devcaps(sc);</a>
<a name="ln277"> </a>
<a name="ln278">	rtwn_getradiocaps(ic, IEEE80211_CHAN_MAX, &amp;ic-&gt;ic_nchans,</a>
<a name="ln279">	    ic-&gt;ic_channels);</a>
<a name="ln280"> </a>
<a name="ln281">	/* XXX TODO: setup regdomain if R92C_CHANNEL_PLAN_BY_HW bit is set. */</a>
<a name="ln282"> </a>
<a name="ln283">	ieee80211_ifattach(ic);</a>
<a name="ln284">	ic-&gt;ic_raw_xmit = rtwn_raw_xmit;</a>
<a name="ln285">	ic-&gt;ic_scan_start = rtwn_scan_start;</a>
<a name="ln286">	sc-&gt;sc_scan_curchan = ic-&gt;ic_scan_curchan;</a>
<a name="ln287">	ic-&gt;ic_scan_curchan = rtwn_scan_curchan;</a>
<a name="ln288">	ic-&gt;ic_scan_end = rtwn_scan_end;</a>
<a name="ln289">	ic-&gt;ic_getradiocaps = rtwn_getradiocaps;</a>
<a name="ln290">	ic-&gt;ic_update_chw = rtwn_update_chw;</a>
<a name="ln291">	ic-&gt;ic_set_channel = rtwn_set_channel;</a>
<a name="ln292">	ic-&gt;ic_transmit = rtwn_transmit;</a>
<a name="ln293">	ic-&gt;ic_parent = rtwn_parent;</a>
<a name="ln294">	ic-&gt;ic_vap_create = rtwn_vap_create;</a>
<a name="ln295">	ic-&gt;ic_vap_delete = rtwn_vap_delete;</a>
<a name="ln296">	ic-&gt;ic_wme.wme_update = rtwn_wme_update;</a>
<a name="ln297">	ic-&gt;ic_updateslot = rtwn_update_slot;</a>
<a name="ln298">	ic-&gt;ic_update_promisc = rtwn_update_promisc;</a>
<a name="ln299">	ic-&gt;ic_update_mcast = rtwn_update_mcast;</a>
<a name="ln300">	ic-&gt;ic_node_alloc = rtwn_node_alloc;</a>
<a name="ln301">	ic-&gt;ic_newassoc = rtwn_newassoc;</a>
<a name="ln302">	sc-&gt;sc_node_free = ic-&gt;ic_node_free;</a>
<a name="ln303">	ic-&gt;ic_node_free = rtwn_node_free;</a>
<a name="ln304"> </a>
<a name="ln305">	rtwn_postattach(sc);</a>
<a name="ln306">	rtwn_radiotap_attach(sc);</a>
<a name="ln307"> </a>
<a name="ln308">	if (bootverbose)</a>
<a name="ln309">		ieee80211_announce(ic);</a>
<a name="ln310"> </a>
<a name="ln311">	return (0);</a>
<a name="ln312"> </a>
<a name="ln313">detach:</a>
<a name="ln314">	return (ENXIO);			/* failure */</a>
<a name="ln315">}</a>
<a name="ln316"> </a>
<a name="ln317">static void</a>
<a name="ln318">rtwn_radiotap_attach(struct rtwn_softc *sc)</a>
<a name="ln319">{</a>
<a name="ln320">	struct rtwn_rx_radiotap_header *rxtap = &amp;sc-&gt;sc_rxtap;</a>
<a name="ln321">	struct rtwn_tx_radiotap_header *txtap = &amp;sc-&gt;sc_txtap;</a>
<a name="ln322"> </a>
<a name="ln323">	ieee80211_radiotap_attach(&amp;sc-&gt;sc_ic,</a>
<a name="ln324">	    &amp;txtap-&gt;wt_ihdr, sizeof(*txtap), RTWN_TX_RADIOTAP_PRESENT,</a>
<a name="ln325">	    &amp;rxtap-&gt;wr_ihdr, sizeof(*rxtap), RTWN_RX_RADIOTAP_PRESENT);</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328">void</a>
<a name="ln329">rtwn_sysctlattach(struct rtwn_softc *sc)</a>
<a name="ln330">{</a>
<a name="ln331">	struct sysctl_ctx_list *ctx = device_get_sysctl_ctx(sc-&gt;sc_dev);</a>
<a name="ln332">	struct sysctl_oid *tree = device_get_sysctl_tree(sc-&gt;sc_dev);</a>
<a name="ln333"> </a>
<a name="ln334">#if 1</a>
<a name="ln335">	sc-&gt;sc_ht40 = 0;</a>
<a name="ln336">	SYSCTL_ADD_INT(ctx, SYSCTL_CHILDREN(tree), OID_AUTO,</a>
<a name="ln337">	    &quot;ht40&quot;, CTLFLAG_RDTUN, &amp;sc-&gt;sc_ht40,</a>
<a name="ln338">	    sc-&gt;sc_ht40, &quot;Enable 40 MHz mode support&quot;);</a>
<a name="ln339">#endif</a>
<a name="ln340"> </a>
<a name="ln341">#ifdef RTWN_DEBUG</a>
<a name="ln342">	SYSCTL_ADD_U32(ctx, SYSCTL_CHILDREN(tree), OID_AUTO,</a>
<a name="ln343">	    &quot;debug&quot;, CTLFLAG_RWTUN, &amp;sc-&gt;sc_debug, sc-&gt;sc_debug,</a>
<a name="ln344">	    &quot;Control debugging printfs&quot;);</a>
<a name="ln345">#endif</a>
<a name="ln346"> </a>
<a name="ln347">	sc-&gt;sc_hwcrypto = RTWN_CRYPTO_PAIR;</a>
<a name="ln348">	SYSCTL_ADD_INT(ctx, SYSCTL_CHILDREN(tree), OID_AUTO,</a>
<a name="ln349">	    &quot;hwcrypto&quot;, CTLFLAG_RDTUN, &amp;sc-&gt;sc_hwcrypto,</a>
<a name="ln350">	    sc-&gt;sc_hwcrypto, &quot;Enable h/w crypto: &quot;</a>
<a name="ln351">	    &quot;0 - disable, 1 - pairwise keys, 2 - all keys&quot;);</a>
<a name="ln352">	if (sc-&gt;sc_hwcrypto &gt;= RTWN_CRYPTO_MAX)</a>
<a name="ln353">		sc-&gt;sc_hwcrypto = RTWN_CRYPTO_FULL;</a>
<a name="ln354"> </a>
<a name="ln355">	sc-&gt;sc_ratectl_sysctl = RTWN_RATECTL_NET80211;</a>
<a name="ln356">	SYSCTL_ADD_INT(ctx, SYSCTL_CHILDREN(tree), OID_AUTO,</a>
<a name="ln357">	    &quot;ratectl&quot;, CTLFLAG_RDTUN, &amp;sc-&gt;sc_ratectl_sysctl,</a>
<a name="ln358">	    sc-&gt;sc_ratectl_sysctl, &quot;Select rate control mechanism: &quot;</a>
<a name="ln359">	    &quot;0 - disabled, 1 - via net80211, 2 - via firmware&quot;);</a>
<a name="ln360">	if (sc-&gt;sc_ratectl_sysctl &gt;= RTWN_RATECTL_MAX)</a>
<a name="ln361">		sc-&gt;sc_ratectl_sysctl = RTWN_RATECTL_FW;</a>
<a name="ln362"> </a>
<a name="ln363">	sc-&gt;sc_ratectl = sc-&gt;sc_ratectl_sysctl;</a>
<a name="ln364">	SYSCTL_ADD_INT(ctx, SYSCTL_CHILDREN(tree), OID_AUTO,</a>
<a name="ln365">	    &quot;ratectl_selected&quot;, CTLFLAG_RD, &amp;sc-&gt;sc_ratectl,</a>
<a name="ln366">	    sc-&gt;sc_ratectl,</a>
<a name="ln367">	    &quot;Currently selected rate control mechanism (by the driver)&quot;);</a>
<a name="ln368">}</a>
<a name="ln369"> </a>
<a name="ln370">void</a>
<a name="ln371">rtwn_detach(struct rtwn_softc *sc)</a>
<a name="ln372">{</a>
<a name="ln373">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln374"> </a>
<a name="ln375">	if (ic-&gt;ic_softc == sc) {</a>
<a name="ln376">		/* Stop command queue. */</a>
<a name="ln377">		RTWN_CMDQ_LOCK(sc);</a>
<a name="ln378">		sc-&gt;sc_detached = 1;</a>
<a name="ln379">		RTWN_CMDQ_UNLOCK(sc);</a>
<a name="ln380"> </a>
<a name="ln381">		ieee80211_draintask(ic, &amp;sc-&gt;cmdq_task);</a>
<a name="ln382">		ieee80211_ifdetach(ic);</a>
<a name="ln383">	}</a>
<a name="ln384"> </a>
<a name="ln385">	rtwn_cmdq_destroy(sc);</a>
<a name="ln386">	if (RTWN_NT_LOCK_INITIALIZED(sc))</a>
<a name="ln387">		RTWN_NT_LOCK_DESTROY(sc);</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390">void</a>
<a name="ln391">rtwn_suspend(struct rtwn_softc *sc)</a>
<a name="ln392">{</a>
<a name="ln393">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln394"> </a>
<a name="ln395">	ieee80211_suspend_all(ic);</a>
<a name="ln396">}</a>
<a name="ln397"> </a>
<a name="ln398">void</a>
<a name="ln399">rtwn_resume(struct rtwn_softc *sc)</a>
<a name="ln400">{</a>
<a name="ln401">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln402"> </a>
<a name="ln403">	ieee80211_resume_all(ic);</a>
<a name="ln404">}</a>
<a name="ln405"> </a>
<a name="ln406">static void</a>
<a name="ln407">rtwn_vap_decrement_counters(struct rtwn_softc *sc,</a>
<a name="ln408">    enum ieee80211_opmode opmode, int id)</a>
<a name="ln409">{</a>
<a name="ln410"> </a>
<a name="ln411">	RTWN_ASSERT_LOCKED(sc);</a>
<a name="ln412"> </a>
<a name="ln413">	if (id != RTWN_VAP_ID_INVALID) {</a>
<a name="ln414">		KASSERT(id == 0 || id == 1, (&quot;wrong vap id %d!\n&quot;, id));</a>
<a name="ln415">		KASSERT(sc-&gt;vaps[id] != NULL, (&quot;vap pointer is NULL\n&quot;));</a>
<a name="ln416">		sc-&gt;vaps[id] = NULL;</a>
<a name="ln417">	}</a>
<a name="ln418"> </a>
<a name="ln419">	switch (opmode) {</a>
<a name="ln420">	case IEEE80211_M_HOSTAP:</a>
<a name="ln421">		sc-&gt;ap_vaps--;</a>
<a name="ln422">		/* FALLTHROUGH */</a>
<a name="ln423">	case IEEE80211_M_IBSS:</a>
<a name="ln424">		sc-&gt;bcn_vaps--;</a>
<a name="ln425">		/* FALLTHROUGH */</a>
<a name="ln426">	case IEEE80211_M_STA:</a>
<a name="ln427">		sc-&gt;nvaps--;</a>
<a name="ln428">		break;</a>
<a name="ln429">	case IEEE80211_M_MONITOR:</a>
<a name="ln430">		sc-&gt;mon_vaps--;</a>
<a name="ln431">		break;</a>
<a name="ln432">	default:</a>
<a name="ln433">		KASSERT(0, (&quot;wrong opmode %d\n&quot;, opmode));</a>
<a name="ln434">		break;</a>
<a name="ln435">	}</a>
<a name="ln436"> </a>
<a name="ln437">	KASSERT(sc-&gt;vaps_running &gt;= 0 &amp;&amp; sc-&gt;monvaps_running &gt;= 0,</a>
<a name="ln438">	    (&quot;number of running vaps is negative (vaps %d, monvaps %d)\n&quot;,</a>
<a name="ln439">	    sc-&gt;vaps_running, sc-&gt;monvaps_running));</a>
<a name="ln440">	KASSERT(sc-&gt;vaps_running - sc-&gt;monvaps_running &lt;= RTWN_PORT_COUNT,</a>
<a name="ln441">	    (&quot;number of running vaps is too big (vaps %d, monvaps %d)\n&quot;,</a>
<a name="ln442">	    sc-&gt;vaps_running, sc-&gt;monvaps_running));</a>
<a name="ln443"> </a>
<a name="ln444">	KASSERT(sc-&gt;nvaps &gt;= 0 &amp;&amp; sc-&gt;nvaps &lt;= RTWN_PORT_COUNT,</a>
<a name="ln445">	    (&quot;wrong value %d for nvaps\n&quot;, sc-&gt;nvaps));</a>
<a name="ln446">	KASSERT(sc-&gt;mon_vaps &gt;= 0, (&quot;mon_vaps is negative (%d)\n&quot;,</a>
<a name="ln447">	    sc-&gt;mon_vaps));</a>
<a name="ln448">	KASSERT(sc-&gt;bcn_vaps &gt;= 0 &amp;&amp; ((RTWN_CHIP_HAS_BCNQ1(sc) &amp;&amp;</a>
<a name="ln449">	    sc-&gt;bcn_vaps &lt;= RTWN_PORT_COUNT) || sc-&gt;bcn_vaps &lt;= 1),</a>
<a name="ln450">	    (&quot;bcn_vaps value %d is wrong\n&quot;, sc-&gt;bcn_vaps));</a>
<a name="ln451">	KASSERT(sc-&gt;ap_vaps &gt;= 0 &amp;&amp; ((RTWN_CHIP_HAS_BCNQ1(sc) &amp;&amp;</a>
<a name="ln452">	    sc-&gt;ap_vaps &lt;= RTWN_PORT_COUNT) || sc-&gt;ap_vaps &lt;= 1),</a>
<a name="ln453">	    (&quot;ap_vaps value %d is wrong\n&quot;, sc-&gt;ap_vaps));</a>
<a name="ln454">}</a>
<a name="ln455"> </a>
<a name="ln456">static void</a>
<a name="ln457">rtwn_set_ic_opmode(struct rtwn_softc *sc)</a>
<a name="ln458">{</a>
<a name="ln459">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln460"> </a>
<a name="ln461">	RTWN_ASSERT_LOCKED(sc);</a>
<a name="ln462"> </a>
<a name="ln463">	/* for ieee80211_reset_erp() */</a>
<a name="ln464">	if (sc-&gt;bcn_vaps - sc-&gt;ap_vaps &gt; 0)</a>
<a name="ln465">		ic-&gt;ic_opmode = IEEE80211_M_IBSS;</a>
<a name="ln466">	else if (sc-&gt;ap_vaps &gt; 0)</a>
<a name="ln467">		ic-&gt;ic_opmode = IEEE80211_M_HOSTAP;</a>
<a name="ln468">	else if (sc-&gt;nvaps &gt; 0)</a>
<a name="ln469">		ic-&gt;ic_opmode = IEEE80211_M_STA;</a>
<a name="ln470">	else</a>
<a name="ln471">		ic-&gt;ic_opmode = IEEE80211_M_MONITOR;</a>
<a name="ln472">}</a>
<a name="ln473"> </a>
<a name="ln474">static struct ieee80211vap *</a>
<a name="ln475">rtwn_vap_create(struct ieee80211com *ic, const char name[IFNAMSIZ], int unit,</a>
<a name="ln476">    enum ieee80211_opmode opmode, int flags,</a>
<a name="ln477">    const uint8_t bssid[IEEE80211_ADDR_LEN],</a>
<a name="ln478">    const uint8_t mac[IEEE80211_ADDR_LEN])</a>
<a name="ln479">{</a>
<a name="ln480">	struct rtwn_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln481">	struct rtwn_vap *uvp;</a>
<a name="ln482">	struct ieee80211vap *vap;</a>
<a name="ln483">	int id = RTWN_VAP_ID_INVALID;</a>
<a name="ln484"> </a>
<a name="ln485">	RTWN_LOCK(sc);</a>
<a name="ln486">	KASSERT(sc-&gt;nvaps &lt;= RTWN_PORT_COUNT,</a>
<a name="ln487">	    (&quot;nvaps overflow (%d &gt; %d)\n&quot;, sc-&gt;nvaps, RTWN_PORT_COUNT));</a>
<a name="ln488">	KASSERT(sc-&gt;ap_vaps &lt;= RTWN_PORT_COUNT,</a>
<a name="ln489">	    (&quot;ap_vaps overflow (%d &gt; %d)\n&quot;, sc-&gt;ap_vaps, RTWN_PORT_COUNT));</a>
<a name="ln490">	KASSERT(sc-&gt;bcn_vaps &lt;= RTWN_PORT_COUNT,</a>
<a name="ln491">	    (&quot;bcn_vaps overflow (%d &gt; %d)\n&quot;, sc-&gt;bcn_vaps, RTWN_PORT_COUNT));</a>
<a name="ln492"> </a>
<a name="ln493">	if (opmode != IEEE80211_M_MONITOR) {</a>
<a name="ln494">		switch (sc-&gt;nvaps) {</a>
<a name="ln495">		case 0:</a>
<a name="ln496">			id = 0;</a>
<a name="ln497">			break;</a>
<a name="ln498">		case 1:</a>
<a name="ln499">			if (sc-&gt;vaps[1] == NULL)</a>
<a name="ln500">				id = 1;</a>
<a name="ln501">			else if (sc-&gt;vaps[0] == NULL)</a>
<a name="ln502">				id = 0;</a>
<a name="ln503">			KASSERT(id != RTWN_VAP_ID_INVALID,</a>
<a name="ln504">			    (&quot;no free ports left\n&quot;));</a>
<a name="ln505">			break;</a>
<a name="ln506">		case 2:</a>
<a name="ln507">		default:</a>
<a name="ln508">			goto fail;</a>
<a name="ln509">		}</a>
<a name="ln510"> </a>
<a name="ln511">		if (opmode == IEEE80211_M_IBSS ||</a>
<a name="ln512">		    opmode == IEEE80211_M_HOSTAP) {</a>
<a name="ln513">			if ((sc-&gt;bcn_vaps == 1 &amp;&amp; !RTWN_CHIP_HAS_BCNQ1(sc)) ||</a>
<a name="ln514">			    sc-&gt;bcn_vaps == RTWN_PORT_COUNT)</a>
<a name="ln515">				goto fail;</a>
<a name="ln516">		}</a>
<a name="ln517">	}</a>
<a name="ln518"> </a>
<a name="ln519">	switch (opmode) {</a>
<a name="ln520">	case IEEE80211_M_HOSTAP:</a>
<a name="ln521">		sc-&gt;ap_vaps++;</a>
<a name="ln522">		/* FALLTHROUGH */</a>
<a name="ln523">	case IEEE80211_M_IBSS:</a>
<a name="ln524">		sc-&gt;bcn_vaps++;</a>
<a name="ln525">		/* FALLTHROUGH */</a>
<a name="ln526">	case IEEE80211_M_STA:</a>
<a name="ln527">		sc-&gt;nvaps++;</a>
<a name="ln528">		break;</a>
<a name="ln529">	case IEEE80211_M_MONITOR:</a>
<a name="ln530">		sc-&gt;mon_vaps++;</a>
<a name="ln531">		break;</a>
<a name="ln532">	default:</a>
<a name="ln533">		KASSERT(0, (&quot;unknown opmode %d\n&quot;, opmode));</a>
<a name="ln534">		goto fail;</a>
<a name="ln535">	}</a>
<a name="ln536">	RTWN_UNLOCK(sc);</a>
<a name="ln537"> </a>
<a name="ln538">	uvp = malloc(sizeof(struct rtwn_vap), M_80211_VAP, M_WAITOK | M_ZERO);</a>
<a name="ln539">	uvp-&gt;id = id;</a>
<a name="ln540">	if (id != RTWN_VAP_ID_INVALID) {</a>
<a name="ln541">		RTWN_LOCK(sc);</a>
<a name="ln542">		sc-&gt;vaps[id] = uvp;</a>
<a name="ln543">		RTWN_UNLOCK(sc);</a>
<a name="ln544">	}</a>
<a name="ln545">	vap = &amp;uvp-&gt;vap;</a>
<a name="ln546">	/* enable s/w bmiss handling for sta mode */</a>
<a name="ln547"> </a>
<a name="ln548">	if (ieee80211_vap_setup(ic, vap, name, unit, opmode,</a>
<a name="ln549">	    flags | IEEE80211_CLONE_NOBEACONS, bssid) != 0) {</a>
<a name="ln550">		/* out of memory */</a>
<a name="ln551">		free(uvp, M_80211_VAP);</a>
<a name="ln552"> </a>
<a name="ln553">		RTWN_LOCK(sc);</a>
<a name="ln554">		rtwn_vap_decrement_counters(sc, opmode, id);</a>
<a name="ln555">		RTWN_UNLOCK(sc);</a>
<a name="ln556"> </a>
<a name="ln557">		return (NULL);</a>
<a name="ln558">	}</a>
<a name="ln559"> </a>
<a name="ln560">	rtwn_beacon_init(sc, &amp;uvp-&gt;bcn_desc.txd[0], uvp-&gt;id);</a>
<a name="ln561">	rtwn_vap_preattach(sc, vap);</a>
<a name="ln562"> </a>
<a name="ln563">	/* override state transition machine */</a>
<a name="ln564">	uvp-&gt;newstate = vap-&gt;iv_newstate;</a>
<a name="ln565">	if (opmode == IEEE80211_M_MONITOR)</a>
<a name="ln566">		vap-&gt;iv_newstate = rtwn_monitor_newstate;</a>
<a name="ln567">	else</a>
<a name="ln568">		vap-&gt;iv_newstate = rtwn_newstate;</a>
<a name="ln569">	vap-&gt;iv_update_beacon = rtwn_update_beacon;</a>
<a name="ln570">	vap-&gt;iv_reset = rtwn_ioctl_reset;</a>
<a name="ln571">	vap-&gt;iv_key_alloc = rtwn_key_alloc;</a>
<a name="ln572">	vap-&gt;iv_key_set = rtwn_key_set;</a>
<a name="ln573">	vap-&gt;iv_key_delete = rtwn_key_delete;</a>
<a name="ln574">	vap-&gt;iv_max_aid = sc-&gt;macid_limit;</a>
<a name="ln575"> </a>
<a name="ln576">	/* 802.11n parameters */</a>
<a name="ln577">	vap-&gt;iv_ampdu_density = IEEE80211_HTCAP_MPDUDENSITY_16;</a>
<a name="ln578">	vap-&gt;iv_ampdu_rxmax = IEEE80211_HTCAP_MAXRXAMPDU_64K;</a>
<a name="ln579"> </a>
<a name="ln580">	TIMEOUT_TASK_INIT(taskqueue_thread, &amp;uvp-&gt;tx_beacon_csa, 0,</a>
<a name="ln581">	    rtwn_tx_beacon_csa, vap);</a>
<a name="ln582">	if (opmode == IEEE80211_M_IBSS) {</a>
<a name="ln583">		uvp-&gt;recv_mgmt = vap-&gt;iv_recv_mgmt;</a>
<a name="ln584">		vap-&gt;iv_recv_mgmt = rtwn_adhoc_recv_mgmt;</a>
<a name="ln585">		TASK_INIT(&amp;uvp-&gt;tsf_sync_adhoc_task, 0,</a>
<a name="ln586">		    rtwn_tsf_sync_adhoc_task, vap);</a>
<a name="ln587">		callout_init(&amp;uvp-&gt;tsf_sync_adhoc, 0);</a>
<a name="ln588">	}</a>
<a name="ln589"> </a>
<a name="ln590">	/*</a>
<a name="ln591">	 * NB: driver can select net80211 RA even when user requests</a>
<a name="ln592">	 * another mechanism.</a>
<a name="ln593">	 */</a>
<a name="ln594">	ieee80211_ratectl_init(vap);</a>
<a name="ln595"> </a>
<a name="ln596">	/* complete setup */</a>
<a name="ln597">	ieee80211_vap_attach(vap, ieee80211_media_change,</a>
<a name="ln598">	    ieee80211_media_status, mac);</a>
<a name="ln599"> </a>
<a name="ln600">	RTWN_LOCK(sc);</a>
<a name="ln601">	rtwn_set_ic_opmode(sc);</a>
<a name="ln602">	if (sc-&gt;sc_flags &amp; RTWN_RUNNING) {</a>
<a name="ln603">		if (uvp-&gt;id != RTWN_VAP_ID_INVALID)</a>
<a name="ln604">			rtwn_set_macaddr(sc, vap-&gt;iv_myaddr, uvp-&gt;id);</a>
<a name="ln605"> </a>
<a name="ln606">		rtwn_rxfilter_update(sc);</a>
<a name="ln607">	}</a>
<a name="ln608">	RTWN_UNLOCK(sc);</a>
<a name="ln609"> </a>
<a name="ln610">	return (vap);</a>
<a name="ln611"> </a>
<a name="ln612">fail:</a>
<a name="ln613">	RTWN_UNLOCK(sc);</a>
<a name="ln614">	return (NULL);</a>
<a name="ln615">}</a>
<a name="ln616"> </a>
<a name="ln617">static void</a>
<a name="ln618">rtwn_vap_delete(struct ieee80211vap *vap)</a>
<a name="ln619">{</a>
<a name="ln620">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln621">	struct rtwn_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln622">	struct rtwn_vap *uvp = RTWN_VAP(vap);</a>
<a name="ln623"> </a>
<a name="ln624">	/* Put vap into INIT state + stop device if needed. */</a>
<a name="ln625">	ieee80211_stop(vap);</a>
<a name="ln626">	ieee80211_draintask(ic, &amp;vap-&gt;iv_nstate_task);</a>
<a name="ln627">	ieee80211_draintask(ic, &amp;ic-&gt;ic_parent_task);</a>
<a name="ln628"> </a>
<a name="ln629">	RTWN_LOCK(sc);</a>
<a name="ln630">	/* Cancel any unfinished Tx. */</a>
<a name="ln631">	rtwn_reset_lists(sc, vap);</a>
<a name="ln632">	if (uvp-&gt;bcn_mbuf != NULL)</a>
<a name="ln633">		m_freem(uvp-&gt;bcn_mbuf);</a>
<a name="ln634">	rtwn_vap_decrement_counters(sc, vap-&gt;iv_opmode, uvp-&gt;id);</a>
<a name="ln635">	rtwn_set_ic_opmode(sc);</a>
<a name="ln636">	if (sc-&gt;sc_flags &amp; RTWN_RUNNING)</a>
<a name="ln637">		rtwn_rxfilter_update(sc);</a>
<a name="ln638">	RTWN_UNLOCK(sc);</a>
<a name="ln639"> </a>
<a name="ln640">	if (vap-&gt;iv_opmode == IEEE80211_M_IBSS) {</a>
<a name="ln641">		ieee80211_draintask(ic, &amp;uvp-&gt;tsf_sync_adhoc_task);</a>
<a name="ln642">		callout_drain(&amp;uvp-&gt;tsf_sync_adhoc);</a>
<a name="ln643">	}</a>
<a name="ln644"> </a>
<a name="ln645">	ieee80211_ratectl_deinit(vap);</a>
<a name="ln646">	ieee80211_vap_detach(vap);</a>
<a name="ln647">	free(uvp, M_80211_VAP);</a>
<a name="ln648">}</a>
<a name="ln649"> </a>
<a name="ln650">static int</a>
<a name="ln651">rtwn_read_chipid(struct rtwn_softc *sc)</a>
<a name="ln652">{</a>
<a name="ln653">	uint32_t reg;</a>
<a name="ln654"> </a>
<a name="ln655">	reg = rtwn_read_4(sc, R92C_SYS_CFG);</a>
<a name="ln656">	if (reg &amp; R92C_SYS_CFG_TRP_VAUX_EN)	/* test chip */</a>
<a name="ln657">		return (EOPNOTSUPP);</a>
<a name="ln658"> </a>
<a name="ln659">	rtwn_read_chipid_vendor(sc, reg);</a>
<a name="ln660"> </a>
<a name="ln661">	return (0);</a>
<a name="ln662">}</a>
<a name="ln663"> </a>
<a name="ln664">static int</a>
<a name="ln665">rtwn_ioctl_reset(struct ieee80211vap *vap, u_long cmd)</a>
<a name="ln666">{</a>
<a name="ln667">	int error;</a>
<a name="ln668"> </a>
<a name="ln669">	switch (cmd) {</a>
<a name="ln670">#ifndef RTWN_WITHOUT_UCODE</a>
<a name="ln671">	case IEEE80211_IOC_POWERSAVE:</a>
<a name="ln672">	case IEEE80211_IOC_POWERSAVESLEEP:</a>
<a name="ln673">	{</a>
<a name="ln674">		struct rtwn_softc *sc = vap-&gt;iv_ic-&gt;ic_softc;</a>
<a name="ln675">		struct rtwn_vap *uvp = RTWN_VAP(vap);</a>
<a name="ln676"> </a>
<a name="ln677">		if (vap-&gt;iv_opmode == IEEE80211_M_STA &amp;&amp; uvp-&gt;id == 0) {</a>
<a name="ln678">			RTWN_LOCK(sc);</a>
<a name="ln679">			if (sc-&gt;sc_flags &amp; RTWN_RUNNING)</a>
<a name="ln680">				error = rtwn_set_pwrmode(sc, vap, 1);</a>
<a name="ln681">			else</a>
<a name="ln682">				error = 0;</a>
<a name="ln683">			RTWN_UNLOCK(sc);</a>
<a name="ln684">			if (error != 0)</a>
<a name="ln685">				error = ENETRESET;</a>
<a name="ln686">		} else</a>
<a name="ln687">			error = EOPNOTSUPP;</a>
<a name="ln688">		break;</a>
<a name="ln689">	}</a>
<a name="ln690">#endif</a>
<a name="ln691">	case IEEE80211_IOC_SHORTGI:</a>
<a name="ln692">	case IEEE80211_IOC_RTSTHRESHOLD:</a>
<a name="ln693">	case IEEE80211_IOC_PROTMODE:</a>
<a name="ln694">	case IEEE80211_IOC_HTPROTMODE:</a>
<a name="ln695">	case IEEE80211_IOC_LDPC:</a>
<a name="ln696">		error = 0;</a>
<a name="ln697">		break;</a>
<a name="ln698">	default:</a>
<a name="ln699">		error = ENETRESET;</a>
<a name="ln700">		break;</a>
<a name="ln701">	}</a>
<a name="ln702"> </a>
<a name="ln703">	return (error);</a>
<a name="ln704">}</a>
<a name="ln705"> </a>
<a name="ln706">static void</a>
<a name="ln707">rtwn_set_media_status(struct rtwn_softc *sc, union sec_param *data)</a>
<a name="ln708">{</a>
<a name="ln709">	sc-&gt;sc_set_media_status(sc, data-&gt;macid);</a>
<a name="ln710">}</a>
<a name="ln711"> </a>
<a name="ln712">#ifndef RTWN_WITHOUT_UCODE</a>
<a name="ln713">static int</a>
<a name="ln714">rtwn_tx_fwpkt_check(struct rtwn_softc *sc, struct ieee80211vap *vap)</a>
<a name="ln715">{</a>
<a name="ln716">	int ntries, error;</a>
<a name="ln717"> </a>
<a name="ln718">	for (ntries = 0; ntries &lt; 5; ntries++) {</a>
<a name="ln719">		error = rtwn_push_nulldata(sc, vap);</a>
<a name="ln720">		if (error == 0)</a>
<a name="ln721">			break;</a>
<a name="ln722">	}</a>
<a name="ln723">	if (ntries == 5) {</a>
<a name="ln724">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln725">		    &quot;%s: cannot push f/w frames into chip, error %d!\n&quot;,</a>
<a name="ln726">		    __func__, error);</a>
<a name="ln727">		return (error);</a>
<a name="ln728">	}</a>
<a name="ln729"> </a>
<a name="ln730">	return (0);</a>
<a name="ln731">}</a>
<a name="ln732"> </a>
<a name="ln733">static int</a>
<a name="ln734">rtwn_construct_nulldata(struct rtwn_softc *sc, struct ieee80211vap *vap,</a>
<a name="ln735">    uint8_t *ptr, int qos)</a>
<a name="ln736">{</a>
<a name="ln737">	struct rtwn_vap *uvp = RTWN_VAP(vap);</a>
<a name="ln738">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln739">	struct rtwn_tx_desc_common *txd;</a>
<a name="ln740">	struct ieee80211_frame *wh;</a>
<a name="ln741">	int pktlen;</a>
<a name="ln742"> </a>
<a name="ln743">	/* XXX obtain from net80211 */</a>
<a name="ln744">	wh = (struct ieee80211_frame *)(ptr + sc-&gt;txdesc_len);</a>
<a name="ln745">	wh-&gt;i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_DATA;</a>
<a name="ln746">	wh-&gt;i_fc[1] = IEEE80211_FC1_DIR_TODS;</a>
<a name="ln747">	IEEE80211_ADDR_COPY(wh-&gt;i_addr1, vap-&gt;iv_bss-&gt;ni_bssid);</a>
<a name="ln748">	IEEE80211_ADDR_COPY(wh-&gt;i_addr2, vap-&gt;iv_myaddr);</a>
<a name="ln749">	IEEE80211_ADDR_COPY(wh-&gt;i_addr3, vap-&gt;iv_bss-&gt;ni_macaddr);</a>
<a name="ln750"> </a>
<a name="ln751">	txd = (struct rtwn_tx_desc_common *)ptr;</a>
<a name="ln752">	txd-&gt;offset = sc-&gt;txdesc_len;</a>
<a name="ln753">	pktlen = sc-&gt;txdesc_len;</a>
<a name="ln754">	if (qos) {</a>
<a name="ln755">		struct ieee80211_qosframe *qwh;</a>
<a name="ln756">		const int tid = WME_AC_TO_TID(WME_AC_BE);</a>
<a name="ln757"> </a>
<a name="ln758">		qwh = (struct ieee80211_qosframe *)wh;</a>
<a name="ln759">		qwh-&gt;i_fc[0] |= IEEE80211_FC0_SUBTYPE_QOS_NULL;</a>
<a name="ln760">		qwh-&gt;i_qos[0] = tid &amp; IEEE80211_QOS_TID;</a>
<a name="ln761"> </a>
<a name="ln762">		txd-&gt;pktlen = htole16(sizeof(struct ieee80211_qosframe));</a>
<a name="ln763">		pktlen += sizeof(struct ieee80211_qosframe);</a>
<a name="ln764">	} else {</a>
<a name="ln765">		wh-&gt;i_fc[0] |= IEEE80211_FC0_SUBTYPE_NODATA;</a>
<a name="ln766"> </a>
<a name="ln767">		txd-&gt;pktlen = htole16(sizeof(struct ieee80211_frame));</a>
<a name="ln768">		pktlen += sizeof(struct ieee80211_frame);</a>
<a name="ln769">	}</a>
<a name="ln770"> </a>
<a name="ln771">	rtwn_fill_tx_desc_null(sc, ptr,</a>
<a name="ln772">	    ic-&gt;ic_curmode == IEEE80211_MODE_11B, qos, uvp-&gt;id);</a>
<a name="ln773"> </a>
<a name="ln774">	return (pktlen);</a>
<a name="ln775">}</a>
<a name="ln776"> </a>
<a name="ln777">static int</a>
<a name="ln778">rtwn_push_nulldata(struct rtwn_softc *sc, struct ieee80211vap *vap)</a>
<a name="ln779">{</a>
<a name="ln780">	struct rtwn_vap *uvp = RTWN_VAP(vap);</a>
<a name="ln781">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln782">	struct ieee80211_channel *c = ic-&gt;ic_curchan;</a>
<a name="ln783">	struct mbuf *m;</a>
<a name="ln784">	uint8_t *ptr;</a>
<a name="ln785">	int required_size, bcn_size, null_size, null_data, error;</a>
<a name="ln786"> </a>
<a name="ln787">	if (!(sc-&gt;sc_flags &amp; RTWN_FW_LOADED))</a>
<a name="ln788">		return (0);	/* requires firmware */</a>
<a name="ln789"> </a>
<a name="ln790">	KASSERT(sc-&gt;page_size &gt; 0, (&quot;page size was not set!\n&quot;));</a>
<a name="ln791"> </a>
<a name="ln792">	/* Leave some space for beacon (multi-vap) */</a>
<a name="ln793">	bcn_size = roundup(RTWN_BCN_MAX_SIZE, sc-&gt;page_size);</a>
<a name="ln794">	/* 1 page for Null Data + 1 page for Qos Null Data frames. */</a>
<a name="ln795">	required_size = bcn_size + sc-&gt;page_size * 2;</a>
<a name="ln796"> </a>
<a name="ln797">	m = m_get2(required_size, M_NOWAIT, MT_DATA, M_PKTHDR);</a>
<a name="ln798">	if (m == NULL)</a>
<a name="ln799">		return (ENOMEM);</a>
<a name="ln800"> </a>
<a name="ln801">	/* Setup beacon descriptor. */</a>
<a name="ln802">	rtwn_beacon_set_rate(sc, &amp;uvp-&gt;bcn_desc.txd[0],</a>
<a name="ln803">	    IEEE80211_IS_CHAN_5GHZ(c));</a>
<a name="ln804"> </a>
<a name="ln805">	ptr = mtod(m, uint8_t *);</a>
<a name="ln806">	memset(ptr, 0, required_size - sc-&gt;txdesc_len);</a>
<a name="ln807"> </a>
<a name="ln808">	/* Construct Null Data frame. */</a>
<a name="ln809">	ptr += bcn_size - sc-&gt;txdesc_len;</a>
<a name="ln810">	null_size = rtwn_construct_nulldata(sc, vap, ptr, 0);</a>
<a name="ln811">	KASSERT(null_size &lt; sc-&gt;page_size,</a>
<a name="ln812">	    (&quot;recalculate size for Null Data frame\n&quot;));</a>
<a name="ln813"> </a>
<a name="ln814">	/* Construct Qos Null Data frame. */</a>
<a name="ln815">	ptr += roundup(null_size, sc-&gt;page_size);</a>
<a name="ln816">	null_size = rtwn_construct_nulldata(sc, vap, ptr, 1);</a>
<a name="ln817">	KASSERT(null_size &lt; sc-&gt;page_size,</a>
<a name="ln818">	    (&quot;recalculate size for Qos Null Data frame\n&quot;));</a>
<a name="ln819"> </a>
<a name="ln820">	/* Do not try to detect a beacon here. */</a>
<a name="ln821">	rtwn_setbits_1_shift(sc, R92C_CR, 0, R92C_CR_ENSWBCN, 1);</a>
<a name="ln822">	rtwn_setbits_1_shift(sc, R92C_FWHW_TXQ_CTRL,</a>
<a name="ln823">	    R92C_FWHW_TXQ_CTRL_REAL_BEACON, 0, 2);</a>
<a name="ln824"> </a>
<a name="ln825">	if (uvp-&gt;bcn_mbuf != NULL) {</a>
<a name="ln826">		rtwn_beacon_unload(sc, uvp-&gt;id);</a>
<a name="ln827">		m_freem(uvp-&gt;bcn_mbuf);</a>
<a name="ln828">	}</a>
<a name="ln829"> </a>
<a name="ln830">	m-&gt;m_pkthdr.len = m-&gt;m_len = required_size - sc-&gt;txdesc_len;</a>
<a name="ln831">	uvp-&gt;bcn_mbuf = m;</a>
<a name="ln832"> </a>
<a name="ln833">	error = rtwn_tx_beacon_check(sc, uvp);</a>
<a name="ln834">	if (error != 0) {</a>
<a name="ln835">		RTWN_DPRINTF(sc, RTWN_DEBUG_BEACON,</a>
<a name="ln836">		    &quot;%s: frame was not recognized!\n&quot;, __func__);</a>
<a name="ln837">		goto fail;</a>
<a name="ln838">	}</a>
<a name="ln839"> </a>
<a name="ln840">	/* Setup addresses in firmware. */</a>
<a name="ln841">	null_data = howmany(bcn_size, sc-&gt;page_size);</a>
<a name="ln842">	error = rtwn_set_rsvd_page(sc, 0, null_data, null_data + 1);</a>
<a name="ln843">	if (error != 0) {</a>
<a name="ln844">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln845">		    &quot;%s: CMD_RSVD_PAGE was not sent, error %d\n&quot;,</a>
<a name="ln846">		    __func__, error);</a>
<a name="ln847">		goto fail;</a>
<a name="ln848">	}</a>
<a name="ln849"> </a>
<a name="ln850">fail:</a>
<a name="ln851">	/* Re-enable beacon detection. */</a>
<a name="ln852">	rtwn_setbits_1_shift(sc, R92C_FWHW_TXQ_CTRL,</a>
<a name="ln853">	    0, R92C_FWHW_TXQ_CTRL_REAL_BEACON, 2);</a>
<a name="ln854">	rtwn_setbits_1_shift(sc, R92C_CR, R92C_CR_ENSWBCN, 0, 1);</a>
<a name="ln855"> </a>
<a name="ln856">	/* Restore beacon (if present). */</a>
<a name="ln857">	if (sc-&gt;bcn_vaps &gt; 0 &amp;&amp; sc-&gt;vaps[!uvp-&gt;id] != NULL) {</a>
<a name="ln858">		struct rtwn_vap *uvp2 = sc-&gt;vaps[!uvp-&gt;id];</a>
<a name="ln859"> </a>
<a name="ln860">		if (uvp2-&gt;curr_mode != R92C_MSR_NOLINK)</a>
<a name="ln861">			error = rtwn_tx_beacon_check(sc, uvp2);</a>
<a name="ln862">	}</a>
<a name="ln863"> </a>
<a name="ln864">	return (error);</a>
<a name="ln865">}</a>
<a name="ln866"> </a>
<a name="ln867">static void</a>
<a name="ln868">rtwn_pwrmode_init(void *arg)</a>
<a name="ln869">{</a>
<a name="ln870">	struct rtwn_softc *sc = arg;</a>
<a name="ln871"> </a>
<a name="ln872">	rtwn_cmd_sleepable(sc, NULL, 0, rtwn_set_pwrmode_cb);</a>
<a name="ln873">}</a>
<a name="ln874"> </a>
<a name="ln875">static void</a>
<a name="ln876">rtwn_set_pwrmode_cb(struct rtwn_softc *sc, union sec_param *data)</a>
<a name="ln877">{</a>
<a name="ln878">	struct ieee80211vap *vap = &amp;sc-&gt;vaps[0]-&gt;vap;</a>
<a name="ln879"> </a>
<a name="ln880">	if (vap != NULL)</a>
<a name="ln881">		rtwn_set_pwrmode(sc, vap, 1);</a>
<a name="ln882">}</a>
<a name="ln883">#endif</a>
<a name="ln884"> </a>
<a name="ln885">static void</a>
<a name="ln886">rtwn_tsf_sync_adhoc(void *arg)</a>
<a name="ln887">{</a>
<a name="ln888">	struct ieee80211vap *vap = arg;</a>
<a name="ln889">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln890">	struct rtwn_vap *uvp = RTWN_VAP(vap);</a>
<a name="ln891"> </a>
<a name="ln892">	if (uvp-&gt;curr_mode != R92C_MSR_NOLINK) {</a>
<a name="ln893">		/* Do it in process context. */</a>
<a name="ln894">		ieee80211_runtask(ic, &amp;uvp-&gt;tsf_sync_adhoc_task);</a>
<a name="ln895">	}</a>
<a name="ln896">}</a>
<a name="ln897"> </a>
<a name="ln898">/*</a>
<a name="ln899"> * Workaround for TSF synchronization:</a>
<a name="ln900"> * when BSSID filter in IBSS mode is not set</a>
<a name="ln901"> * (and TSF synchronization is enabled), then any beacon may update it.</a>
<a name="ln902"> * This routine synchronizes it when BSSID matching is enabled (IBSS merge</a>
<a name="ln903"> * is not possible during this period).</a>
<a name="ln904"> *</a>
<a name="ln905"> * NOTE: there is no race with rtwn_newstate(), since it uses the same</a>
<a name="ln906"> * taskqueue.</a>
<a name="ln907"> */</a>
<a name="ln908">static void</a>
<a name="ln909">rtwn_tsf_sync_adhoc_task(void *arg, int pending)</a>
<a name="ln910">{</a>
<a name="ln911">	struct ieee80211vap *vap = arg;</a>
<a name="ln912">	struct rtwn_vap *uvp = RTWN_VAP(vap);</a>
<a name="ln913">	struct rtwn_softc *sc = vap-&gt;iv_ic-&gt;ic_softc;</a>
<a name="ln914">	struct ieee80211_node *ni;</a>
<a name="ln915"> </a>
<a name="ln916">	RTWN_LOCK(sc);</a>
<a name="ln917">	ni = ieee80211_ref_node(vap-&gt;iv_bss);</a>
<a name="ln918"> </a>
<a name="ln919">	/* Accept beacons with the same BSSID. */</a>
<a name="ln920">	rtwn_set_rx_bssid_all(sc, 0);</a>
<a name="ln921"> </a>
<a name="ln922">	/* Deny RCR updates. */</a>
<a name="ln923">	sc-&gt;sc_flags |= RTWN_RCR_LOCKED;</a>
<a name="ln924"> </a>
<a name="ln925">	/* Enable synchronization. */</a>
<a name="ln926">	rtwn_setbits_1(sc, R92C_BCN_CTRL(uvp-&gt;id),</a>
<a name="ln927">	    R92C_BCN_CTRL_DIS_TSF_UDT0, 0);</a>
<a name="ln928"> </a>
<a name="ln929">	/* Synchronize. */</a>
<a name="ln930">	rtwn_delay(sc, ni-&gt;ni_intval * 5 * 1000);</a>
<a name="ln931"> </a>
<a name="ln932">	/* Disable synchronization. */</a>
<a name="ln933">	rtwn_setbits_1(sc, R92C_BCN_CTRL(uvp-&gt;id),</a>
<a name="ln934">	    0, R92C_BCN_CTRL_DIS_TSF_UDT0);</a>
<a name="ln935"> </a>
<a name="ln936">	/* Accept all beacons. */</a>
<a name="ln937">	sc-&gt;sc_flags &amp;= ~RTWN_RCR_LOCKED;</a>
<a name="ln938">	rtwn_set_rx_bssid_all(sc, 1);</a>
<a name="ln939"> </a>
<a name="ln940">	/* Schedule next TSF synchronization. */</a>
<a name="ln941">	callout_reset(&amp;uvp-&gt;tsf_sync_adhoc, 60*hz, rtwn_tsf_sync_adhoc, vap);</a>
<a name="ln942"> </a>
<a name="ln943">	ieee80211_free_node(ni);</a>
<a name="ln944">	RTWN_UNLOCK(sc);</a>
<a name="ln945">}</a>
<a name="ln946"> </a>
<a name="ln947">static void</a>
<a name="ln948">rtwn_tsf_sync_enable(struct rtwn_softc *sc, struct ieee80211vap *vap)</a>
<a name="ln949">{</a>
<a name="ln950">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln951">	struct rtwn_vap *uvp = RTWN_VAP(vap);</a>
<a name="ln952"> </a>
<a name="ln953">	/* Reset TSF. */</a>
<a name="ln954">	rtwn_write_1(sc, R92C_DUAL_TSF_RST, R92C_DUAL_TSF_RESET(uvp-&gt;id));</a>
<a name="ln955"> </a>
<a name="ln956">	switch (vap-&gt;iv_opmode) {</a>
<a name="ln957">	case IEEE80211_M_STA:</a>
<a name="ln958">		/* Enable TSF synchronization. */</a>
<a name="ln959">		rtwn_setbits_1(sc, R92C_BCN_CTRL(uvp-&gt;id),</a>
<a name="ln960">		    R92C_BCN_CTRL_DIS_TSF_UDT0, 0);</a>
<a name="ln961">		break;</a>
<a name="ln962">	case IEEE80211_M_IBSS:</a>
<a name="ln963">		ieee80211_runtask(ic, &amp;uvp-&gt;tsf_sync_adhoc_task);</a>
<a name="ln964">		/* FALLTHROUGH */</a>
<a name="ln965">	case IEEE80211_M_HOSTAP:</a>
<a name="ln966">		/* Enable beaconing. */</a>
<a name="ln967">		rtwn_beacon_enable(sc, uvp-&gt;id, 1);</a>
<a name="ln968">		break;</a>
<a name="ln969">	default:</a>
<a name="ln970">		device_printf(sc-&gt;sc_dev, &quot;undefined opmode %d\n&quot;,</a>
<a name="ln971">		    vap-&gt;iv_opmode);</a>
<a name="ln972">		return;</a>
<a name="ln973">	}</a>
<a name="ln974">}</a>
<a name="ln975"> </a>
<a name="ln976">static void</a>
<a name="ln977">rtwn_set_ack_preamble(struct rtwn_softc *sc)</a>
<a name="ln978">{</a>
<a name="ln979">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln980">	uint32_t reg;</a>
<a name="ln981"> </a>
<a name="ln982">	reg = rtwn_read_4(sc, R92C_WMAC_TRXPTCL_CTL);</a>
<a name="ln983">	if (ic-&gt;ic_flags &amp; IEEE80211_F_SHPREAMBLE)</a>
<a name="ln984">		reg |= R92C_WMAC_TRXPTCL_SHPRE;</a>
<a name="ln985">	else</a>
<a name="ln986">		reg &amp;= ~R92C_WMAC_TRXPTCL_SHPRE;</a>
<a name="ln987">	rtwn_write_4(sc, R92C_WMAC_TRXPTCL_CTL, reg);</a>
<a name="ln988">}</a>
<a name="ln989"> </a>
<a name="ln990">static void</a>
<a name="ln991">rtwn_set_mode(struct rtwn_softc *sc, uint8_t mode, int id)</a>
<a name="ln992">{</a>
<a name="ln993"> </a>
<a name="ln994">	rtwn_setbits_1(sc, R92C_MSR, R92C_MSR_MASK &lt;&lt; id * 2, mode &lt;&lt; id * 2);</a>
<a name="ln995">	if (sc-&gt;vaps[id] != NULL)</a>
<a name="ln996">		sc-&gt;vaps[id]-&gt;curr_mode = mode;</a>
<a name="ln997">}</a>
<a name="ln998"> </a>
<a name="ln999">static int</a>
<a name="ln1000">rtwn_monitor_newstate(struct ieee80211vap *vap, enum ieee80211_state nstate,</a>
<a name="ln1001">    int arg)</a>
<a name="ln1002">{</a>
<a name="ln1003">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln1004">	struct rtwn_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1005">	struct rtwn_vap *uvp = RTWN_VAP(vap);</a>
<a name="ln1006"> </a>
<a name="ln1007">	RTWN_DPRINTF(sc, RTWN_DEBUG_STATE, &quot;%s -&gt; %s\n&quot;,</a>
<a name="ln1008">	    ieee80211_state_name[vap-&gt;iv_state],</a>
<a name="ln1009">	    ieee80211_state_name[nstate]);</a>
<a name="ln1010"> </a>
<a name="ln1011">	if (vap-&gt;iv_state != nstate) {</a>
<a name="ln1012">		IEEE80211_UNLOCK(ic);</a>
<a name="ln1013">		RTWN_LOCK(sc);</a>
<a name="ln1014"> </a>
<a name="ln1015">		switch (nstate) {</a>
<a name="ln1016">		case IEEE80211_S_INIT:</a>
<a name="ln1017">			sc-&gt;vaps_running--;</a>
<a name="ln1018">			sc-&gt;monvaps_running--;</a>
<a name="ln1019"> </a>
<a name="ln1020">			if (sc-&gt;vaps_running == 0) {</a>
<a name="ln1021">				/* Turn link LED off. */</a>
<a name="ln1022">				rtwn_set_led(sc, RTWN_LED_LINK, 0);</a>
<a name="ln1023">			}</a>
<a name="ln1024">			break;</a>
<a name="ln1025">		case IEEE80211_S_RUN:</a>
<a name="ln1026">			sc-&gt;vaps_running++;</a>
<a name="ln1027">			sc-&gt;monvaps_running++;</a>
<a name="ln1028"> </a>
<a name="ln1029">			if (sc-&gt;vaps_running == 1) {</a>
<a name="ln1030">				/* Turn link LED on. */</a>
<a name="ln1031">				rtwn_set_led(sc, RTWN_LED_LINK, 1);</a>
<a name="ln1032">			}</a>
<a name="ln1033">			break;</a>
<a name="ln1034">		default:</a>
<a name="ln1035">			/* NOTREACHED */</a>
<a name="ln1036">			break;</a>
<a name="ln1037">		}</a>
<a name="ln1038"> </a>
<a name="ln1039">		RTWN_UNLOCK(sc);</a>
<a name="ln1040">		IEEE80211_LOCK(ic);</a>
<a name="ln1041">	}</a>
<a name="ln1042"> </a>
<a name="ln1043">	return (uvp-&gt;newstate(vap, nstate, arg));</a>
<a name="ln1044">}</a>
<a name="ln1045"> </a>
<a name="ln1046">static int</a>
<a name="ln1047">rtwn_newstate(struct ieee80211vap *vap, enum ieee80211_state nstate, int arg)</a>
<a name="ln1048">{</a>
<a name="ln1049">	struct rtwn_vap *uvp = RTWN_VAP(vap);</a>
<a name="ln1050">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln1051">	struct rtwn_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1052">	enum ieee80211_state ostate;</a>
<a name="ln1053">	int error, early_newstate;</a>
<a name="ln1054"> </a>
<a name="ln1055">	ostate = vap-&gt;iv_state;</a>
<a name="ln1056">	RTWN_DPRINTF(sc, RTWN_DEBUG_STATE, &quot;%s -&gt; %s\n&quot;,</a>
<a name="ln1057">	    ieee80211_state_name[ostate], ieee80211_state_name[nstate]);</a>
<a name="ln1058"> </a>
<a name="ln1059">	if (vap-&gt;iv_bss-&gt;ni_chan == IEEE80211_CHAN_ANYC &amp;&amp;</a>
<a name="ln1060">	    ostate == IEEE80211_S_INIT &amp;&amp; nstate == IEEE80211_S_RUN) {</a>
<a name="ln1061">		/* need to call iv_newstate() firstly */</a>
<a name="ln1062">		error = uvp-&gt;newstate(vap, nstate, arg);</a>
<a name="ln1063">		if (error != 0)</a>
<a name="ln1064">			return (error);</a>
<a name="ln1065"> </a>
<a name="ln1066">		early_newstate = 1;</a>
<a name="ln1067">	} else</a>
<a name="ln1068">		early_newstate = 0;</a>
<a name="ln1069"> </a>
<a name="ln1070">	if (ostate == IEEE80211_S_CSA) {</a>
<a name="ln1071">		taskqueue_cancel_timeout(taskqueue_thread,</a>
<a name="ln1072">		    &amp;uvp-&gt;tx_beacon_csa, NULL);</a>
<a name="ln1073"> </a>
<a name="ln1074">		/*</a>
<a name="ln1075">		 * In multi-vap case second counter may not be cleared</a>
<a name="ln1076">		 * properly.</a>
<a name="ln1077">		 */</a>
<a name="ln1078">		vap-&gt;iv_csa_count = 0;</a>
<a name="ln1079">	}</a>
<a name="ln1080">	IEEE80211_UNLOCK(ic);</a>
<a name="ln1081">	RTWN_LOCK(sc);</a>
<a name="ln1082"> </a>
<a name="ln1083">	if (ostate == IEEE80211_S_CSA) {</a>
<a name="ln1084">		/* Unblock all queues (multi-vap case). */</a>
<a name="ln1085">		rtwn_write_1(sc, R92C_TXPAUSE, 0);</a>
<a name="ln1086">	}</a>
<a name="ln1087"> </a>
<a name="ln1088">	if ((ostate == IEEE80211_S_RUN &amp;&amp; nstate != IEEE80211_S_CSA) ||</a>
<a name="ln1089">	    ostate == IEEE80211_S_CSA) {</a>
<a name="ln1090">		sc-&gt;vaps_running--;</a>
<a name="ln1091"> </a>
<a name="ln1092">		/* Set media status to 'No Link'. */</a>
<a name="ln1093">		rtwn_set_mode(sc, R92C_MSR_NOLINK, uvp-&gt;id);</a>
<a name="ln1094"> </a>
<a name="ln1095">		if (vap-&gt;iv_opmode == IEEE80211_M_IBSS) {</a>
<a name="ln1096">			/* Stop periodical TSF synchronization. */</a>
<a name="ln1097">			callout_stop(&amp;uvp-&gt;tsf_sync_adhoc);</a>
<a name="ln1098">		}</a>
<a name="ln1099"> </a>
<a name="ln1100">		/* Disable TSF synchronization / beaconing. */</a>
<a name="ln1101">		rtwn_beacon_enable(sc, uvp-&gt;id, 0);</a>
<a name="ln1102">		rtwn_setbits_1(sc, R92C_BCN_CTRL(uvp-&gt;id),</a>
<a name="ln1103">		    0, R92C_BCN_CTRL_DIS_TSF_UDT0);</a>
<a name="ln1104"> </a>
<a name="ln1105">		/* NB: monitor mode vaps are using port 0. */</a>
<a name="ln1106">		if (uvp-&gt;id != 0 || sc-&gt;monvaps_running == 0) {</a>
<a name="ln1107">			/* Reset TSF. */</a>
<a name="ln1108">			rtwn_write_1(sc, R92C_DUAL_TSF_RST,</a>
<a name="ln1109">			    R92C_DUAL_TSF_RESET(uvp-&gt;id));</a>
<a name="ln1110">		}</a>
<a name="ln1111"> </a>
<a name="ln1112">#ifndef RTWN_WITHOUT_UCODE</a>
<a name="ln1113">		if ((ic-&gt;ic_caps &amp; IEEE80211_C_PMGT) != 0 &amp;&amp; uvp-&gt;id == 0) {</a>
<a name="ln1114">			/* Disable power management. */</a>
<a name="ln1115">			callout_stop(&amp;sc-&gt;sc_pwrmode_init);</a>
<a name="ln1116">			rtwn_set_pwrmode(sc, vap, 0);</a>
<a name="ln1117">		}</a>
<a name="ln1118">#endif</a>
<a name="ln1119">		if (sc-&gt;vaps_running - sc-&gt;monvaps_running &gt; 0) {</a>
<a name="ln1120">			/* Recalculate basic rates bitmap. */</a>
<a name="ln1121">			rtwn_calc_basicrates(sc);</a>
<a name="ln1122">		}</a>
<a name="ln1123"> </a>
<a name="ln1124">		if (sc-&gt;vaps_running == sc-&gt;monvaps_running) {</a>
<a name="ln1125">			/* Stop calibration. */</a>
<a name="ln1126">			callout_stop(&amp;sc-&gt;sc_calib_to);</a>
<a name="ln1127"> </a>
<a name="ln1128">			/* Stop Rx of data frames. */</a>
<a name="ln1129">			rtwn_write_2(sc, R92C_RXFLTMAP2, 0);</a>
<a name="ln1130"> </a>
<a name="ln1131">			/* Reset EDCA parameters. */</a>
<a name="ln1132">			rtwn_write_4(sc, R92C_EDCA_VO_PARAM, 0x002f3217);</a>
<a name="ln1133">			rtwn_write_4(sc, R92C_EDCA_VI_PARAM, 0x005e4317);</a>
<a name="ln1134">			rtwn_write_4(sc, R92C_EDCA_BE_PARAM, 0x00105320);</a>
<a name="ln1135">			rtwn_write_4(sc, R92C_EDCA_BK_PARAM, 0x0000a444);</a>
<a name="ln1136"> </a>
<a name="ln1137">			if (sc-&gt;vaps_running == 0) {</a>
<a name="ln1138">				/* Turn link LED off. */</a>
<a name="ln1139">				rtwn_set_led(sc, RTWN_LED_LINK, 0);</a>
<a name="ln1140">			}</a>
<a name="ln1141">		}</a>
<a name="ln1142">	}</a>
<a name="ln1143"> </a>
<a name="ln1144">	error = 0;</a>
<a name="ln1145">	switch (nstate) {</a>
<a name="ln1146">	case IEEE80211_S_SCAN:</a>
<a name="ln1147">		/* Pause AC Tx queues. */</a>
<a name="ln1148">		if (sc-&gt;vaps_running == 0)</a>
<a name="ln1149">			rtwn_setbits_1(sc, R92C_TXPAUSE, 0, R92C_TX_QUEUE_AC);</a>
<a name="ln1150">		break;</a>
<a name="ln1151">	case IEEE80211_S_RUN:</a>
<a name="ln1152">		error = rtwn_run(sc, vap);</a>
<a name="ln1153">		if (error != 0) {</a>
<a name="ln1154">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1155">			    &quot;%s: could not move to RUN state\n&quot;, __func__);</a>
<a name="ln1156">			break;</a>
<a name="ln1157">		}</a>
<a name="ln1158"> </a>
<a name="ln1159">		sc-&gt;vaps_running++;</a>
<a name="ln1160">		break;</a>
<a name="ln1161">	case IEEE80211_S_CSA:</a>
<a name="ln1162">		/* Block all Tx queues (except beacon queue). */</a>
<a name="ln1163">		rtwn_setbits_1(sc, R92C_TXPAUSE, 0,</a>
<a name="ln1164">		    R92C_TX_QUEUE_AC | R92C_TX_QUEUE_MGT | R92C_TX_QUEUE_HIGH);</a>
<a name="ln1165">		break;</a>
<a name="ln1166">	default:</a>
<a name="ln1167">		break;</a>
<a name="ln1168">	}</a>
<a name="ln1169"> </a>
<a name="ln1170">	RTWN_UNLOCK(sc);</a>
<a name="ln1171">	IEEE80211_LOCK(ic);</a>
<a name="ln1172">	if (error != 0)</a>
<a name="ln1173">		return (error);</a>
<a name="ln1174"> </a>
<a name="ln1175">	return (early_newstate ? 0 : uvp-&gt;newstate(vap, nstate, arg));</a>
<a name="ln1176">}</a>
<a name="ln1177"> </a>
<a name="ln1178">static void</a>
<a name="ln1179">rtwn_calc_basicrates(struct rtwn_softc *sc)</a>
<a name="ln1180">{</a>
<a name="ln1181">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1182">	uint32_t basicrates;</a>
<a name="ln1183">	int i;</a>
<a name="ln1184"> </a>
<a name="ln1185">	RTWN_ASSERT_LOCKED(sc);</a>
<a name="ln1186"> </a>
<a name="ln1187">	if (ic-&gt;ic_flags &amp; IEEE80211_F_SCAN)</a>
<a name="ln1188">		return;		/* will be done by rtwn_scan_end(). */</a>
<a name="ln1189"> </a>
<a name="ln1190">	basicrates = 0;</a>
<a name="ln1191">	for (i = 0; i &lt; nitems(sc-&gt;vaps); i++) {</a>
<a name="ln1192">		struct rtwn_vap *rvp;</a>
<a name="ln1193">		struct ieee80211vap *vap;</a>
<a name="ln1194">		struct ieee80211_node *ni;</a>
<a name="ln1195">		uint32_t rates;</a>
<a name="ln1196"> </a>
<a name="ln1197">		rvp = sc-&gt;vaps[i];</a>
<a name="ln1198">		if (rvp == NULL || rvp-&gt;curr_mode == R92C_MSR_NOLINK)</a>
<a name="ln1199">			continue;</a>
<a name="ln1200"> </a>
<a name="ln1201">		vap = &amp;rvp-&gt;vap;</a>
<a name="ln1202">		if (vap-&gt;iv_bss == NULL)</a>
<a name="ln1203">			continue;</a>
<a name="ln1204"> </a>
<a name="ln1205">		ni = ieee80211_ref_node(vap-&gt;iv_bss);</a>
<a name="ln1206">		rtwn_get_rates(sc, &amp;ni-&gt;ni_rates, NULL, &amp;rates, NULL, 1);</a>
<a name="ln1207">		basicrates |= rates;</a>
<a name="ln1208">		ieee80211_free_node(ni);</a>
<a name="ln1209">	}</a>
<a name="ln1210"> </a>
<a name="ln1211">	if (basicrates == 0)</a>
<a name="ln1212">		return;</a>
<a name="ln1213"> </a>
<a name="ln1214">	/* XXX initial RTS rate? */</a>
<a name="ln1215">	rtwn_set_basicrates(sc, basicrates);</a>
<a name="ln1216">}</a>
<a name="ln1217"> </a>
<a name="ln1218">static int</a>
<a name="ln1219">rtwn_run(struct rtwn_softc *sc, struct ieee80211vap *vap)</a>
<a name="ln1220">{</a>
<a name="ln1221">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln1222">	struct rtwn_vap *uvp = RTWN_VAP(vap);</a>
<a name="ln1223">	struct ieee80211_node *ni;</a>
<a name="ln1224">	uint8_t mode;</a>
<a name="ln1225">	int error;</a>
<a name="ln1226"> </a>
<a name="ln1227">	RTWN_ASSERT_LOCKED(sc);</a>
<a name="ln1228"> </a>
<a name="ln1229">	error = 0;</a>
<a name="ln1230">	ni = ieee80211_ref_node(vap-&gt;iv_bss);</a>
<a name="ln1231"> </a>
<a name="ln1232">	if (ic-&gt;ic_bsschan == IEEE80211_CHAN_ANYC ||</a>
<a name="ln1233">	    ni-&gt;ni_chan == IEEE80211_CHAN_ANYC) {</a>
<a name="ln1234">		error = EINVAL;</a>
<a name="ln1235">		goto fail;</a>
<a name="ln1236">	}</a>
<a name="ln1237"> </a>
<a name="ln1238">	switch (vap-&gt;iv_opmode) {</a>
<a name="ln1239">	case IEEE80211_M_STA:</a>
<a name="ln1240">		mode = R92C_MSR_INFRA;</a>
<a name="ln1241">		break;</a>
<a name="ln1242">	case IEEE80211_M_IBSS:</a>
<a name="ln1243">		mode = R92C_MSR_ADHOC;</a>
<a name="ln1244">		break;</a>
<a name="ln1245">	case IEEE80211_M_HOSTAP:</a>
<a name="ln1246">		mode = R92C_MSR_AP;</a>
<a name="ln1247">		break;</a>
<a name="ln1248">	default:</a>
<a name="ln1249">		KASSERT(0, (&quot;undefined opmode %d\n&quot;, vap-&gt;iv_opmode));</a>
<a name="ln1250">		error = EINVAL;</a>
<a name="ln1251">		goto fail;</a>
<a name="ln1252">	}</a>
<a name="ln1253"> </a>
<a name="ln1254">	/* Set media status to 'Associated'. */</a>
<a name="ln1255">	rtwn_set_mode(sc, mode, uvp-&gt;id);</a>
<a name="ln1256"> </a>
<a name="ln1257">	/* Set AssocID. */</a>
<a name="ln1258">	/* XXX multi-vap? */</a>
<a name="ln1259">	rtwn_write_2(sc, R92C_BCN_PSR_RPT,</a>
<a name="ln1260">	    0xc000 | IEEE80211_NODE_AID(ni));</a>
<a name="ln1261"> </a>
<a name="ln1262">	/* Set BSSID. */</a>
<a name="ln1263">	rtwn_set_bssid(sc, ni-&gt;ni_bssid, uvp-&gt;id);</a>
<a name="ln1264"> </a>
<a name="ln1265">	/* Set beacon interval. */</a>
<a name="ln1266">	rtwn_write_2(sc, R92C_BCN_INTERVAL(uvp-&gt;id), ni-&gt;ni_intval);</a>
<a name="ln1267"> </a>
<a name="ln1268">	if (sc-&gt;vaps_running == sc-&gt;monvaps_running) {</a>
<a name="ln1269">		/* Enable Rx of data frames. */</a>
<a name="ln1270">		rtwn_write_2(sc, R92C_RXFLTMAP2, 0xffff);</a>
<a name="ln1271"> </a>
<a name="ln1272">		/* Flush all AC queues. */</a>
<a name="ln1273">		rtwn_write_1(sc, R92C_TXPAUSE, 0);</a>
<a name="ln1274">	}</a>
<a name="ln1275"> </a>
<a name="ln1276">#ifndef RTWN_WITHOUT_UCODE</a>
<a name="ln1277">	/* Upload (QoS) Null Data frame to firmware. */</a>
<a name="ln1278">	/* Note: do this for port 0 only. */</a>
<a name="ln1279">	if ((ic-&gt;ic_caps &amp; IEEE80211_C_PMGT) != 0 &amp;&amp;</a>
<a name="ln1280">	    vap-&gt;iv_opmode == IEEE80211_M_STA &amp;&amp; uvp-&gt;id == 0) {</a>
<a name="ln1281">		error = rtwn_tx_fwpkt_check(sc, vap);</a>
<a name="ln1282">		if (error != 0)</a>
<a name="ln1283">			goto fail;</a>
<a name="ln1284"> </a>
<a name="ln1285">		/* Setup power management. */</a>
<a name="ln1286">		/*</a>
<a name="ln1287">		 * NB: it will be enabled immediately - delay it,</a>
<a name="ln1288">		 * so 4-Way handshake will not be interrupted.</a>
<a name="ln1289">		 */</a>
<a name="ln1290">		callout_reset(&amp;sc-&gt;sc_pwrmode_init, 5*hz,</a>
<a name="ln1291">		    rtwn_pwrmode_init, sc);</a>
<a name="ln1292">	}</a>
<a name="ln1293">#endif</a>
<a name="ln1294"> </a>
<a name="ln1295">	/* Enable TSF synchronization. */</a>
<a name="ln1296">	rtwn_tsf_sync_enable(sc, vap);</a>
<a name="ln1297"> </a>
<a name="ln1298">	if (vap-&gt;iv_opmode == IEEE80211_M_HOSTAP ||</a>
<a name="ln1299">	    vap-&gt;iv_opmode == IEEE80211_M_IBSS) {</a>
<a name="ln1300">		error = rtwn_setup_beacon(sc, ni);</a>
<a name="ln1301">		if (error != 0) {</a>
<a name="ln1302">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1303">			    &quot;unable to push beacon into the chip, &quot;</a>
<a name="ln1304">			    &quot;error %d\n&quot;, error);</a>
<a name="ln1305">			goto fail;</a>
<a name="ln1306">		}</a>
<a name="ln1307">	}</a>
<a name="ln1308"> </a>
<a name="ln1309">	/* Set ACK preamble type. */</a>
<a name="ln1310">	rtwn_set_ack_preamble(sc);</a>
<a name="ln1311"> </a>
<a name="ln1312">	/* Set basic rates mask. */</a>
<a name="ln1313">	rtwn_calc_basicrates(sc);</a>
<a name="ln1314"> </a>
<a name="ln1315">#ifdef RTWN_TODO</a>
<a name="ln1316">	rtwn_write_1(sc, R92C_SIFS_CCK + 1, 10);</a>
<a name="ln1317">	rtwn_write_1(sc, R92C_SIFS_OFDM + 1, 10);</a>
<a name="ln1318">	rtwn_write_1(sc, R92C_SPEC_SIFS + 1, 10);</a>
<a name="ln1319">	rtwn_write_1(sc, R92C_MAC_SPEC_SIFS + 1, 10);</a>
<a name="ln1320">	rtwn_write_1(sc, R92C_R2T_SIFS + 1, 10);</a>
<a name="ln1321">	rtwn_write_1(sc, R92C_T2T_SIFS + 1, 10);</a>
<a name="ln1322">#endif</a>
<a name="ln1323"> </a>
<a name="ln1324">	if (sc-&gt;vaps_running == sc-&gt;monvaps_running) {</a>
<a name="ln1325">		/* Reset temperature calibration state machine. */</a>
<a name="ln1326">		sc-&gt;sc_flags &amp;= ~RTWN_TEMP_MEASURED;</a>
<a name="ln1327">		sc-&gt;thcal_temp = sc-&gt;thermal_meter;</a>
<a name="ln1328"> </a>
<a name="ln1329">		/* Start periodic calibration. */</a>
<a name="ln1330">		callout_reset(&amp;sc-&gt;sc_calib_to, 2*hz, rtwn_calib_to,</a>
<a name="ln1331">		    sc);</a>
<a name="ln1332"> </a>
<a name="ln1333">		if (sc-&gt;vaps_running == 0) {</a>
<a name="ln1334">			/* Turn link LED on. */</a>
<a name="ln1335">			rtwn_set_led(sc, RTWN_LED_LINK, 1);</a>
<a name="ln1336">		}</a>
<a name="ln1337">	}</a>
<a name="ln1338"> </a>
<a name="ln1339">fail:</a>
<a name="ln1340">	ieee80211_free_node(ni);</a>
<a name="ln1341"> </a>
<a name="ln1342">	return (error);</a>
<a name="ln1343">}</a>
<a name="ln1344"> </a>
<a name="ln1345">#ifndef D4054</a>
<a name="ln1346">static void</a>
<a name="ln1347">rtwn_watchdog(void *arg)</a>
<a name="ln1348">{</a>
<a name="ln1349">	struct rtwn_softc *sc = arg;</a>
<a name="ln1350">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1351"> </a>
<a name="ln1352">	RTWN_ASSERT_LOCKED(sc);</a>
<a name="ln1353"> </a>
<a name="ln1354">	KASSERT(sc-&gt;sc_flags &amp; RTWN_RUNNING, (&quot;not running&quot;));</a>
<a name="ln1355"> </a>
<a name="ln1356">	if (sc-&gt;sc_tx_timer != 0 &amp;&amp; --sc-&gt;sc_tx_timer == 0) {</a>
<a name="ln1357">		ic_printf(ic, &quot;device timeout\n&quot;);</a>
<a name="ln1358">		ieee80211_restart_all(ic);</a>
<a name="ln1359">		return;</a>
<a name="ln1360">	}</a>
<a name="ln1361">	callout_reset(&amp;sc-&gt;sc_watchdog_to, hz, rtwn_watchdog, sc);</a>
<a name="ln1362">}</a>
<a name="ln1363">#endif</a>
<a name="ln1364"> </a>
<a name="ln1365">static void</a>
<a name="ln1366">rtwn_parent(struct ieee80211com *ic)</a>
<a name="ln1367">{</a>
<a name="ln1368">	struct rtwn_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1369">	struct ieee80211vap *vap;</a>
<a name="ln1370"> </a>
<a name="ln1371">	if (ic-&gt;ic_nrunning &gt; 0) {</a>
<a name="ln1372">		if (rtwn_init(sc) != 0) {</a>
<a name="ln1373">			IEEE80211_LOCK(ic);</a>
<a name="ln1374">			TAILQ_FOREACH(vap, &amp;ic-&gt;ic_vaps, iv_next)</a>
<a name="ln1375">				ieee80211_stop_locked(vap);</a>
<a name="ln1376">			IEEE80211_UNLOCK(ic);</a>
<a name="ln1377">		} else</a>
<a name="ln1378">			ieee80211_start_all(ic);</a>
<a name="ln1379">	} else</a>
<a name="ln1380">		rtwn_stop(sc);</a>
<a name="ln1381">}</a>
<a name="ln1382"> </a>
<a name="ln1383">static int</a>
<a name="ln1384">rtwn_dma_init(struct rtwn_softc *sc)</a>
<a name="ln1385">{</a>
<a name="ln1386">#define RTWN_CHK(res) do {	\</a>
<a name="ln1387">	if (res != 0)		\</a>
<a name="ln1388">		return (EIO);	\</a>
<a name="ln1389">} while(0)</a>
<a name="ln1390">	uint16_t reg;</a>
<a name="ln1391">	uint8_t tx_boundary;</a>
<a name="ln1392">	int error;</a>
<a name="ln1393"> </a>
<a name="ln1394">	/* Initialize LLT table. */</a>
<a name="ln1395">	error = rtwn_llt_init(sc);</a>
<a name="ln1396">	if (error != 0)</a>
<a name="ln1397">		return (error);</a>
<a name="ln1398"> </a>
<a name="ln1399">	/* Set the number of pages for each queue. */</a>
<a name="ln1400">	RTWN_DPRINTF(sc, RTWN_DEBUG_RESET,</a>
<a name="ln1401">	    &quot;%s: pages per queue: high %d, normal %d, low %d, public %d\n&quot;,</a>
<a name="ln1402">	    __func__, sc-&gt;nhqpages, sc-&gt;nnqpages, sc-&gt;nlqpages,</a>
<a name="ln1403">	    sc-&gt;npubqpages);</a>
<a name="ln1404"> </a>
<a name="ln1405">	RTWN_CHK(rtwn_write_1(sc, R92C_RQPN_NPQ, sc-&gt;nnqpages));</a>
<a name="ln1406">	RTWN_CHK(rtwn_write_4(sc, R92C_RQPN,</a>
<a name="ln1407">	    /* Set number of pages for public queue. */</a>
<a name="ln1408">	    SM(R92C_RQPN_PUBQ, sc-&gt;npubqpages) |</a>
<a name="ln1409">	    /* Set number of pages for high priority queue. */</a>
<a name="ln1410">	    SM(R92C_RQPN_HPQ, sc-&gt;nhqpages) |</a>
<a name="ln1411">	    /* Set number of pages for low priority queue. */</a>
<a name="ln1412">	    SM(R92C_RQPN_LPQ, sc-&gt;nlqpages) |</a>
<a name="ln1413">	    /* Load values. */</a>
<a name="ln1414">	    R92C_RQPN_LD));</a>
<a name="ln1415"> </a>
<a name="ln1416">	/* Initialize TX buffer boundary. */</a>
<a name="ln1417">	KASSERT(sc-&gt;page_count &lt; 255 &amp;&amp; sc-&gt;page_count &gt; 0,</a>
<a name="ln1418">	    (&quot;page_count is %d\n&quot;, sc-&gt;page_count));</a>
<a name="ln1419">	tx_boundary = sc-&gt;page_count + 1;</a>
<a name="ln1420">	RTWN_CHK(rtwn_write_1(sc, R92C_TXPKTBUF_BCNQ_BDNY, tx_boundary));</a>
<a name="ln1421">	RTWN_CHK(rtwn_write_1(sc, R92C_TXPKTBUF_MGQ_BDNY, tx_boundary));</a>
<a name="ln1422">	RTWN_CHK(rtwn_write_1(sc, R92C_TXPKTBUF_WMAC_LBK_BF_HD, tx_boundary));</a>
<a name="ln1423">	RTWN_CHK(rtwn_write_1(sc, R92C_TRXFF_BNDY, tx_boundary));</a>
<a name="ln1424">	RTWN_CHK(rtwn_write_1(sc, R92C_TDECTRL + 1, tx_boundary));</a>
<a name="ln1425"> </a>
<a name="ln1426">	error = rtwn_init_bcnq1_boundary(sc);</a>
<a name="ln1427">	if (error != 0)</a>
<a name="ln1428">		return (error);</a>
<a name="ln1429"> </a>
<a name="ln1430">	/* Set queue to USB pipe mapping. */</a>
<a name="ln1431">	/* Note: PCIe devices are using some magic number here. */</a>
<a name="ln1432">	reg = rtwn_get_qmap(sc);</a>
<a name="ln1433">	RTWN_CHK(rtwn_setbits_2(sc, R92C_TRXDMA_CTRL,</a>
<a name="ln1434">	    R92C_TRXDMA_CTRL_QMAP_M, reg));</a>
<a name="ln1435"> </a>
<a name="ln1436">	/* Configure Tx/Rx DMA (PCIe). */</a>
<a name="ln1437">	rtwn_set_desc_addr(sc);</a>
<a name="ln1438"> </a>
<a name="ln1439">	/* Set Tx/Rx transfer page boundary. */</a>
<a name="ln1440">	RTWN_CHK(rtwn_write_2(sc, R92C_TRXFF_BNDY + 2,</a>
<a name="ln1441">	    sc-&gt;rx_dma_size - 1));</a>
<a name="ln1442"> </a>
<a name="ln1443">	/* Set Tx/Rx transfer page size. */</a>
<a name="ln1444">	rtwn_set_page_size(sc);</a>
<a name="ln1445"> </a>
<a name="ln1446">	return (0);</a>
<a name="ln1447">}</a>
<a name="ln1448"> </a>
<a name="ln1449">static int</a>
<a name="ln1450">rtwn_mac_init(struct rtwn_softc *sc)</a>
<a name="ln1451">{</a>
<a name="ln1452">	int i, error;</a>
<a name="ln1453"> </a>
<a name="ln1454">	/* Write MAC initialization values. */</a>
<a name="ln1455">	for (i = 0; i &lt; sc-&gt;mac_size; i++) {</a>
<a name="ln1456">		error = rtwn_write_1(sc, sc-&gt;mac_prog[i].reg,</a>
<a name="ln1457">		    sc-&gt;mac_prog[i].val);</a>
<a name="ln1458">		if (error != 0)</a>
<a name="ln1459">			return (error);</a>
<a name="ln1460">	}</a>
<a name="ln1461"> </a>
<a name="ln1462">	return (0);</a>
<a name="ln1463">}</a>
<a name="ln1464"> </a>
<a name="ln1465">static void</a>
<a name="ln1466">rtwn_mrr_init(struct rtwn_softc *sc)</a>
<a name="ln1467">{</a>
<a name="ln1468">	int i;</a>
<a name="ln1469"> </a>
<a name="ln1470">	/* Drop rate index by 1 per retry. */</a>
<a name="ln1471">	for (i = 0; i &lt; R92C_DARFRC_SIZE; i++) {</a>
<a name="ln1472">		rtwn_write_1(sc, R92C_DARFRC + i, i + 1);</a>
<a name="ln1473">		rtwn_write_1(sc, R92C_RARFRC + i, i + 1);</a>
<a name="ln1474">	}</a>
<a name="ln1475">}</a>
<a name="ln1476"> </a>
<a name="ln1477">static void</a>
<a name="ln1478">rtwn_scan_start(struct ieee80211com *ic)</a>
<a name="ln1479">{</a>
<a name="ln1480">	struct rtwn_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1481"> </a>
<a name="ln1482">	RTWN_LOCK(sc);</a>
<a name="ln1483">	/* Pause beaconing. */</a>
<a name="ln1484">	rtwn_setbits_1(sc, R92C_TXPAUSE, 0, R92C_TX_QUEUE_BCN);</a>
<a name="ln1485">	/* Receive beacons / probe responses from any BSSID. */</a>
<a name="ln1486">	if (sc-&gt;bcn_vaps == 0)</a>
<a name="ln1487">		rtwn_set_rx_bssid_all(sc, 1);</a>
<a name="ln1488">	RTWN_UNLOCK(sc);</a>
<a name="ln1489">}</a>
<a name="ln1490"> </a>
<a name="ln1491">static void</a>
<a name="ln1492">rtwn_scan_curchan(struct ieee80211_scan_state *ss, unsigned long maxdwell)</a>
<a name="ln1493">{</a>
<a name="ln1494">	struct rtwn_softc *sc = ss-&gt;ss_ic-&gt;ic_softc;</a>
<a name="ln1495"> </a>
<a name="ln1496">	/* Make link LED blink during scan. */</a>
<a name="ln1497">	RTWN_LOCK(sc);</a>
<a name="ln1498">	rtwn_set_led(sc, RTWN_LED_LINK, !sc-&gt;ledlink);</a>
<a name="ln1499">	RTWN_UNLOCK(sc);</a>
<a name="ln1500"> </a>
<a name="ln1501">	sc-&gt;sc_scan_curchan(ss, maxdwell);</a>
<a name="ln1502">}</a>
<a name="ln1503"> </a>
<a name="ln1504">static void</a>
<a name="ln1505">rtwn_scan_end(struct ieee80211com *ic)</a>
<a name="ln1506">{</a>
<a name="ln1507">	struct rtwn_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1508"> </a>
<a name="ln1509">	RTWN_LOCK(sc);</a>
<a name="ln1510">	/* Restore limitations. */</a>
<a name="ln1511">	if (ic-&gt;ic_promisc == 0 &amp;&amp; sc-&gt;bcn_vaps == 0)</a>
<a name="ln1512">		rtwn_set_rx_bssid_all(sc, 0);</a>
<a name="ln1513"> </a>
<a name="ln1514">	/* Restore LED state. */</a>
<a name="ln1515">	rtwn_set_led(sc, RTWN_LED_LINK, (sc-&gt;vaps_running != 0));</a>
<a name="ln1516"> </a>
<a name="ln1517">	/* Restore basic rates mask. */</a>
<a name="ln1518">	rtwn_calc_basicrates(sc);</a>
<a name="ln1519"> </a>
<a name="ln1520">	/* Resume beaconing. */</a>
<a name="ln1521">	rtwn_setbits_1(sc, R92C_TXPAUSE, R92C_TX_QUEUE_BCN, 0);</a>
<a name="ln1522">	RTWN_UNLOCK(sc);</a>
<a name="ln1523">}</a>
<a name="ln1524"> </a>
<a name="ln1525">static void</a>
<a name="ln1526">rtwn_getradiocaps(struct ieee80211com *ic,</a>
<a name="ln1527">    int maxchans, int *nchans, struct ieee80211_channel chans[])</a>
<a name="ln1528">{</a>
<a name="ln1529">	struct rtwn_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1530">	uint8_t bands[IEEE80211_MODE_BYTES];</a>
<a name="ln1531">	int i;</a>
<a name="ln1532"> </a>
<a name="ln1533">	memset(bands, 0, sizeof(bands));</a>
<a name="ln1534">	setbit(bands, IEEE80211_MODE_11B);</a>
<a name="ln1535">	setbit(bands, IEEE80211_MODE_11G);</a>
<a name="ln1536">	setbit(bands, IEEE80211_MODE_11NG);</a>
<a name="ln1537">	ieee80211_add_channel_list_2ghz(chans, maxchans, nchans,</a>
<a name="ln1538">	    rtwn_chan_2ghz, nitems(rtwn_chan_2ghz), bands,</a>
<a name="ln1539">	    !!(ic-&gt;ic_htcaps &amp; IEEE80211_HTCAP_CHWIDTH40));</a>
<a name="ln1540"> </a>
<a name="ln1541">	/* XXX workaround add_channel_list() limitations */</a>
<a name="ln1542">	setbit(bands, IEEE80211_MODE_11A);</a>
<a name="ln1543">	setbit(bands, IEEE80211_MODE_11NA);</a>
<a name="ln1544">	for (i = 0; i &lt; nitems(sc-&gt;chan_num_5ghz); i++) {</a>
<a name="ln1545">		if (sc-&gt;chan_num_5ghz[i] == 0)</a>
<a name="ln1546">			continue;</a>
<a name="ln1547"> </a>
<a name="ln1548">		ieee80211_add_channel_list_5ghz(chans, maxchans, nchans,</a>
<a name="ln1549">		    sc-&gt;chan_list_5ghz[i], sc-&gt;chan_num_5ghz[i], bands,</a>
<a name="ln1550">		    !!(ic-&gt;ic_htcaps &amp; IEEE80211_HTCAP_CHWIDTH40));</a>
<a name="ln1551">	}</a>
<a name="ln1552">}</a>
<a name="ln1553"> </a>
<a name="ln1554">static void</a>
<a name="ln1555">rtwn_update_chw(struct ieee80211com *ic)</a>
<a name="ln1556">{</a>
<a name="ln1557">}</a>
<a name="ln1558"> </a>
<a name="ln1559">static void</a>
<a name="ln1560">rtwn_set_channel(struct ieee80211com *ic)</a>
<a name="ln1561">{</a>
<a name="ln1562">	struct rtwn_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1563">	struct ieee80211_channel *c = ic-&gt;ic_curchan;</a>
<a name="ln1564"> </a>
<a name="ln1565">	RTWN_LOCK(sc);</a>
<a name="ln1566">	rtwn_set_chan(sc, c);</a>
<a name="ln1567">	sc-&gt;sc_rxtap.wr_chan_freq = htole16(c-&gt;ic_freq);</a>
<a name="ln1568">	sc-&gt;sc_rxtap.wr_chan_flags = htole16(c-&gt;ic_flags);</a>
<a name="ln1569">	sc-&gt;sc_txtap.wt_chan_freq = htole16(c-&gt;ic_freq);</a>
<a name="ln1570">	sc-&gt;sc_txtap.wt_chan_flags = htole16(c-&gt;ic_flags);</a>
<a name="ln1571">	RTWN_UNLOCK(sc);</a>
<a name="ln1572">}</a>
<a name="ln1573"> </a>
<a name="ln1574">static int</a>
<a name="ln1575">rtwn_wme_update(struct ieee80211com *ic)</a>
<a name="ln1576">{</a>
<a name="ln1577">	struct chanAccParams chp;</a>
<a name="ln1578">	struct ieee80211_channel *c = ic-&gt;ic_curchan;</a>
<a name="ln1579">	struct rtwn_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1580">	struct wmeParams *wmep = sc-&gt;cap_wmeParams;</a>
<a name="ln1581">	uint8_t aifs, acm, slottime;</a>
<a name="ln1582">	int ac;</a>
<a name="ln1583"> </a>
<a name="ln1584">	ieee80211_wme_ic_getparams(ic, &amp;chp);</a>
<a name="ln1585"> </a>
<a name="ln1586">	/* Prevent possible races. */</a>
<a name="ln1587">	IEEE80211_LOCK(ic);	/* XXX */</a>
<a name="ln1588">	RTWN_LOCK(sc);</a>
<a name="ln1589">	memcpy(wmep, chp.cap_wmeParams, sizeof(sc-&gt;cap_wmeParams));</a>
<a name="ln1590">	RTWN_UNLOCK(sc);</a>
<a name="ln1591">	IEEE80211_UNLOCK(ic);</a>
<a name="ln1592"> </a>
<a name="ln1593">	acm = 0;</a>
<a name="ln1594">	slottime = IEEE80211_GET_SLOTTIME(ic);</a>
<a name="ln1595"> </a>
<a name="ln1596">	RTWN_LOCK(sc);</a>
<a name="ln1597">	for (ac = WME_AC_BE; ac &lt; WME_NUM_AC; ac++) {</a>
<a name="ln1598">		/* AIFS[AC] = AIFSN[AC] * aSlotTime + aSIFSTime. */</a>
<a name="ln1599">		aifs = wmep[ac].wmep_aifsn * slottime +</a>
<a name="ln1600">		    (IEEE80211_IS_CHAN_5GHZ(c) ?</a>
<a name="ln1601">			IEEE80211_DUR_OFDM_SIFS : IEEE80211_DUR_SIFS);</a>
<a name="ln1602">		rtwn_write_4(sc, wme2reg[ac],</a>
<a name="ln1603">		    SM(R92C_EDCA_PARAM_TXOP, wmep[ac].wmep_txopLimit) |</a>
<a name="ln1604">		    SM(R92C_EDCA_PARAM_ECWMIN, wmep[ac].wmep_logcwmin) |</a>
<a name="ln1605">		    SM(R92C_EDCA_PARAM_ECWMAX, wmep[ac].wmep_logcwmax) |</a>
<a name="ln1606">		    SM(R92C_EDCA_PARAM_AIFS, aifs));</a>
<a name="ln1607">		if (ac != WME_AC_BE)</a>
<a name="ln1608">			acm |= wmep[ac].wmep_acm &lt;&lt; ac;</a>
<a name="ln1609">	}</a>
<a name="ln1610"> </a>
<a name="ln1611">	if (acm != 0)</a>
<a name="ln1612">		acm |= R92C_ACMHWCTRL_EN;</a>
<a name="ln1613">	rtwn_setbits_1(sc, R92C_ACMHWCTRL, R92C_ACMHWCTRL_ACM_MASK, acm);</a>
<a name="ln1614">	RTWN_UNLOCK(sc);</a>
<a name="ln1615"> </a>
<a name="ln1616">	return 0;</a>
<a name="ln1617">}</a>
<a name="ln1618"> </a>
<a name="ln1619">static void</a>
<a name="ln1620">rtwn_update_slot(struct ieee80211com *ic)</a>
<a name="ln1621">{</a>
<a name="ln1622">	rtwn_cmd_sleepable(ic-&gt;ic_softc, NULL, 0, rtwn_update_slot_cb);</a>
<a name="ln1623">}</a>
<a name="ln1624"> </a>
<a name="ln1625">static void</a>
<a name="ln1626">rtwn_update_slot_cb(struct rtwn_softc *sc, union sec_param *data)</a>
<a name="ln1627">{</a>
<a name="ln1628">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1629">	uint8_t slottime;</a>
<a name="ln1630"> </a>
<a name="ln1631">	slottime = IEEE80211_GET_SLOTTIME(ic);</a>
<a name="ln1632"> </a>
<a name="ln1633">	RTWN_DPRINTF(sc, RTWN_DEBUG_STATE, &quot;%s: setting slot time to %uus\n&quot;,</a>
<a name="ln1634">	    __func__, slottime);</a>
<a name="ln1635"> </a>
<a name="ln1636">	rtwn_write_1(sc, R92C_SLOT, slottime);</a>
<a name="ln1637">	rtwn_update_aifs(sc, slottime);</a>
<a name="ln1638">}</a>
<a name="ln1639"> </a>
<a name="ln1640">static void</a>
<a name="ln1641">rtwn_update_aifs(struct rtwn_softc *sc, uint8_t slottime)</a>
<a name="ln1642">{</a>
<a name="ln1643">	struct ieee80211_channel *c = sc-&gt;sc_ic.ic_curchan;</a>
<a name="ln1644">	const struct wmeParams *wmep = sc-&gt;cap_wmeParams;</a>
<a name="ln1645">	uint8_t aifs, ac;</a>
<a name="ln1646"> </a>
<a name="ln1647">	for (ac = WME_AC_BE; ac &lt; WME_NUM_AC; ac++) {</a>
<a name="ln1648">		/* AIFS[AC] = AIFSN[AC] * aSlotTime + aSIFSTime. */</a>
<a name="ln1649">		aifs = wmep[ac].wmep_aifsn * slottime +</a>
<a name="ln1650">		    (IEEE80211_IS_CHAN_5GHZ(c) ?</a>
<a name="ln1651">			IEEE80211_DUR_OFDM_SIFS : IEEE80211_DUR_SIFS);</a>
<a name="ln1652">		rtwn_write_1(sc, wme2reg[ac], aifs);</a>
<a name="ln1653">	}</a>
<a name="ln1654">}</a>
<a name="ln1655"> </a>
<a name="ln1656">static void</a>
<a name="ln1657">rtwn_update_promisc(struct ieee80211com *ic)</a>
<a name="ln1658">{</a>
<a name="ln1659">	struct rtwn_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1660"> </a>
<a name="ln1661">	RTWN_LOCK(sc);</a>
<a name="ln1662">	if (sc-&gt;sc_flags &amp; RTWN_RUNNING)</a>
<a name="ln1663">		rtwn_set_promisc(sc);</a>
<a name="ln1664">	RTWN_UNLOCK(sc);</a>
<a name="ln1665">}</a>
<a name="ln1666"> </a>
<a name="ln1667">static void</a>
<a name="ln1668">rtwn_update_mcast(struct ieee80211com *ic)</a>
<a name="ln1669">{</a>
<a name="ln1670">	struct rtwn_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1671"> </a>
<a name="ln1672">	RTWN_LOCK(sc);</a>
<a name="ln1673">	if (sc-&gt;sc_flags &amp; RTWN_RUNNING)</a>
<a name="ln1674">		rtwn_set_multi(sc);</a>
<a name="ln1675">	RTWN_UNLOCK(sc);</a>
<a name="ln1676">}</a>
<a name="ln1677"> </a>
<a name="ln1678">static int</a>
<a name="ln1679">rtwn_set_bssid(struct rtwn_softc *sc, const uint8_t *bssid, int id)</a>
<a name="ln1680">{</a>
<a name="ln1681">	int error;</a>
<a name="ln1682"> </a>
<a name="ln1683">	error = rtwn_write_4(sc, R92C_BSSID(id), le32dec(&amp;bssid[0]));</a>
<a name="ln1684">	if (error != 0)</a>
<a name="ln1685">		return (error);</a>
<a name="ln1686">	error = rtwn_write_2(sc, R92C_BSSID(id) + 4, le16dec(&amp;bssid[4]));</a>
<a name="ln1687"> </a>
<a name="ln1688">	return (error);</a>
<a name="ln1689">}</a>
<a name="ln1690"> </a>
<a name="ln1691">static int</a>
<a name="ln1692">rtwn_set_macaddr(struct rtwn_softc *sc, const uint8_t *addr, int id)</a>
<a name="ln1693">{</a>
<a name="ln1694">	int error;</a>
<a name="ln1695"> </a>
<a name="ln1696">	error = rtwn_write_4(sc, R92C_MACID(id), le32dec(&amp;addr[0]));</a>
<a name="ln1697">	if (error != 0)</a>
<a name="ln1698">		return (error);</a>
<a name="ln1699">	error = rtwn_write_2(sc, R92C_MACID(id) + 4, le16dec(&amp;addr[4]));</a>
<a name="ln1700"> </a>
<a name="ln1701">	return (error);</a>
<a name="ln1702">}</a>
<a name="ln1703"> </a>
<a name="ln1704">static struct ieee80211_node *</a>
<a name="ln1705">rtwn_node_alloc(struct ieee80211vap *vap,</a>
<a name="ln1706">    const uint8_t mac[IEEE80211_ADDR_LEN])</a>
<a name="ln1707">{</a>
<a name="ln1708">	struct rtwn_node *un;</a>
<a name="ln1709"> </a>
<a name="ln1710">	un = malloc(sizeof (struct rtwn_node), M_80211_NODE,</a>
<a name="ln1711">	    M_NOWAIT | M_ZERO);</a>
<a name="ln1712"> </a>
<a name="ln1713">	if (un == NULL)</a>
<a name="ln1714">		return NULL;</a>
<a name="ln1715"> </a>
<a name="ln1716">	un-&gt;id = RTWN_MACID_UNDEFINED;</a>
<a name="ln1717">	un-&gt;avg_pwdb = -1;</a>
<a name="ln1718"> </a>
<a name="ln1719">	return &amp;un-&gt;ni;</a>
<a name="ln1720">}</a>
<a name="ln1721"> </a>
<a name="ln1722">static void</a>
<a name="ln1723">rtwn_newassoc(struct ieee80211_node *ni, int isnew __unused)</a>
<a name="ln1724">{</a>
<a name="ln1725">	struct rtwn_softc *sc = ni-&gt;ni_ic-&gt;ic_softc;</a>
<a name="ln1726">	struct rtwn_node *un = RTWN_NODE(ni);</a>
<a name="ln1727">	int id;</a>
<a name="ln1728"> </a>
<a name="ln1729">	if (un-&gt;id != RTWN_MACID_UNDEFINED)</a>
<a name="ln1730">		return;</a>
<a name="ln1731"> </a>
<a name="ln1732">	RTWN_NT_LOCK(sc);</a>
<a name="ln1733">	for (id = 0; id &lt;= sc-&gt;macid_limit; id++) {</a>
<a name="ln1734">		if (id != RTWN_MACID_BC &amp;&amp; sc-&gt;node_list[id] == NULL) {</a>
<a name="ln1735">			un-&gt;id = id;</a>
<a name="ln1736">			sc-&gt;node_list[id] = ni;</a>
<a name="ln1737">			break;</a>
<a name="ln1738">		}</a>
<a name="ln1739">	}</a>
<a name="ln1740">	RTWN_NT_UNLOCK(sc);</a>
<a name="ln1741"> </a>
<a name="ln1742">	if (id &gt; sc-&gt;macid_limit) {</a>
<a name="ln1743">		device_printf(sc-&gt;sc_dev, &quot;%s: node table is full\n&quot;,</a>
<a name="ln1744">		    __func__);</a>
<a name="ln1745">		return;</a>
<a name="ln1746">	}</a>
<a name="ln1747"> </a>
<a name="ln1748">	/* Notify firmware. */</a>
<a name="ln1749">	id |= RTWN_MACID_VALID;</a>
<a name="ln1750">	rtwn_cmd_sleepable(sc, &amp;id, sizeof(id), rtwn_set_media_status);</a>
<a name="ln1751">}</a>
<a name="ln1752"> </a>
<a name="ln1753">static void</a>
<a name="ln1754">rtwn_node_free(struct ieee80211_node *ni)</a>
<a name="ln1755">{</a>
<a name="ln1756">	struct rtwn_softc *sc = ni-&gt;ni_ic-&gt;ic_softc;</a>
<a name="ln1757">	struct rtwn_node *un = RTWN_NODE(ni);</a>
<a name="ln1758"> </a>
<a name="ln1759">	RTWN_NT_LOCK(sc);</a>
<a name="ln1760">	if (un-&gt;id != RTWN_MACID_UNDEFINED) {</a>
<a name="ln1761">		sc-&gt;node_list[un-&gt;id] = NULL;</a>
<a name="ln1762">		rtwn_cmd_sleepable(sc, &amp;un-&gt;id, sizeof(un-&gt;id),</a>
<a name="ln1763">		    rtwn_set_media_status);</a>
<a name="ln1764">	}</a>
<a name="ln1765">	RTWN_NT_UNLOCK(sc);</a>
<a name="ln1766"> </a>
<a name="ln1767">	sc-&gt;sc_node_free(ni);</a>
<a name="ln1768">}</a>
<a name="ln1769"> </a>
<a name="ln1770">static void</a>
<a name="ln1771">rtwn_init_beacon_reg(struct rtwn_softc *sc)</a>
<a name="ln1772">{</a>
<a name="ln1773">	rtwn_write_1(sc, R92C_BCN_CTRL(0), R92C_BCN_CTRL_DIS_TSF_UDT0);</a>
<a name="ln1774">	rtwn_write_1(sc, R92C_BCN_CTRL(1), R92C_BCN_CTRL_DIS_TSF_UDT0);</a>
<a name="ln1775">	rtwn_write_2(sc, R92C_TBTT_PROHIBIT, 0x6404);</a>
<a name="ln1776">	rtwn_write_1(sc, R92C_DRVERLYINT, 0x05);</a>
<a name="ln1777">	rtwn_write_1(sc, R92C_BCNDMATIM, 0x02);</a>
<a name="ln1778">	rtwn_write_2(sc, R92C_BCNTCFG, 0x660f);</a>
<a name="ln1779">}</a>
<a name="ln1780"> </a>
<a name="ln1781">static int</a>
<a name="ln1782">rtwn_init(struct rtwn_softc *sc)</a>
<a name="ln1783">{</a>
<a name="ln1784">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1785">	int i, error;</a>
<a name="ln1786"> </a>
<a name="ln1787">	RTWN_LOCK(sc);</a>
<a name="ln1788">	if (sc-&gt;sc_flags &amp; RTWN_RUNNING) {</a>
<a name="ln1789">		RTWN_UNLOCK(sc);</a>
<a name="ln1790">		return (0);</a>
<a name="ln1791">	}</a>
<a name="ln1792">	sc-&gt;sc_flags |= RTWN_STARTED;</a>
<a name="ln1793"> </a>
<a name="ln1794">	/* Power on adapter. */</a>
<a name="ln1795">	error = rtwn_power_on(sc);</a>
<a name="ln1796">	if (error != 0)</a>
<a name="ln1797">		goto fail;</a>
<a name="ln1798"> </a>
<a name="ln1799">#ifndef RTWN_WITHOUT_UCODE</a>
<a name="ln1800">	/* Load 8051 microcode. */</a>
<a name="ln1801">	error = rtwn_load_firmware(sc);</a>
<a name="ln1802">	if (error == 0)</a>
<a name="ln1803">		sc-&gt;sc_flags |= RTWN_FW_LOADED;</a>
<a name="ln1804"> </a>
<a name="ln1805">	/* Init firmware commands ring. */</a>
<a name="ln1806">	sc-&gt;fwcur = 0;</a>
<a name="ln1807">#endif</a>
<a name="ln1808"> </a>
<a name="ln1809">	/* Initialize MAC block. */</a>
<a name="ln1810">	error = rtwn_mac_init(sc);</a>
<a name="ln1811">	if (error != 0) {</a>
<a name="ln1812">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln1813">		    &quot;%s: error while initializing MAC block\n&quot;, __func__);</a>
<a name="ln1814">		goto fail;</a>
<a name="ln1815">	}</a>
<a name="ln1816"> </a>
<a name="ln1817">	/* Initialize DMA. */</a>
<a name="ln1818">	error = rtwn_dma_init(sc);</a>
<a name="ln1819">	if (error != 0)</a>
<a name="ln1820">		goto fail;</a>
<a name="ln1821"> </a>
<a name="ln1822">	/* Drop incorrect TX (USB). */</a>
<a name="ln1823">	rtwn_drop_incorrect_tx(sc);</a>
<a name="ln1824"> </a>
<a name="ln1825">	/* Set info size in Rx descriptors (in 64-bit words). */</a>
<a name="ln1826">	rtwn_write_1(sc, R92C_RX_DRVINFO_SZ, R92C_RX_DRVINFO_SZ_DEF);</a>
<a name="ln1827"> </a>
<a name="ln1828">	/* Init interrupts. */</a>
<a name="ln1829">	rtwn_init_intr(sc);</a>
<a name="ln1830"> </a>
<a name="ln1831">	for (i = 0; i &lt; nitems(sc-&gt;vaps); i++) {</a>
<a name="ln1832">		struct rtwn_vap *uvp = sc-&gt;vaps[i];</a>
<a name="ln1833"> </a>
<a name="ln1834">		/* Set initial network type. */</a>
<a name="ln1835">		rtwn_set_mode(sc, R92C_MSR_NOLINK, i);</a>
<a name="ln1836"> </a>
<a name="ln1837">		if (uvp == NULL)</a>
<a name="ln1838">			continue;</a>
<a name="ln1839"> </a>
<a name="ln1840">		/* Set MAC address. */</a>
<a name="ln1841">		error = rtwn_set_macaddr(sc, uvp-&gt;vap.iv_myaddr, uvp-&gt;id);</a>
<a name="ln1842">		if (error != 0)</a>
<a name="ln1843">			goto fail;</a>
<a name="ln1844">	}</a>
<a name="ln1845"> </a>
<a name="ln1846">	/* Initialize Rx filter. */</a>
<a name="ln1847">	rtwn_rxfilter_init(sc);</a>
<a name="ln1848"> </a>
<a name="ln1849">	/* Set short/long retry limits. */</a>
<a name="ln1850">	rtwn_write_2(sc, R92C_RL,</a>
<a name="ln1851">	    SM(R92C_RL_SRL, 0x30) | SM(R92C_RL_LRL, 0x30));</a>
<a name="ln1852"> </a>
<a name="ln1853">	/* Initialize EDCA parameters. */</a>
<a name="ln1854">	rtwn_init_edca(sc);</a>
<a name="ln1855"> </a>
<a name="ln1856">	rtwn_setbits_1(sc, R92C_FWHW_TXQ_CTRL, 0,</a>
<a name="ln1857">	    R92C_FWHW_TXQ_CTRL_AMPDU_RTY_NEW);</a>
<a name="ln1858">	/* Set ACK timeout. */</a>
<a name="ln1859">	rtwn_write_1(sc, R92C_ACKTO, sc-&gt;ackto);</a>
<a name="ln1860"> </a>
<a name="ln1861">	/* Setup aggregation. */</a>
<a name="ln1862">	/* Tx aggregation. */</a>
<a name="ln1863">	rtwn_init_tx_agg(sc);</a>
<a name="ln1864">	rtwn_init_rx_agg(sc);</a>
<a name="ln1865"> </a>
<a name="ln1866">	/* Initialize beacon parameters. */</a>
<a name="ln1867">	rtwn_init_beacon_reg(sc);</a>
<a name="ln1868"> </a>
<a name="ln1869">	/* Init A-MPDU parameters. */</a>
<a name="ln1870">	rtwn_init_ampdu(sc);</a>
<a name="ln1871"> </a>
<a name="ln1872">	/* Init MACTXEN / MACRXEN after setting RxFF boundary. */</a>
<a name="ln1873">	rtwn_setbits_1(sc, R92C_CR, 0, R92C_CR_MACTXEN | R92C_CR_MACRXEN);</a>
<a name="ln1874"> </a>
<a name="ln1875">	/* Initialize BB/RF blocks. */</a>
<a name="ln1876">	rtwn_init_bb(sc);</a>
<a name="ln1877">	rtwn_init_rf(sc);</a>
<a name="ln1878"> </a>
<a name="ln1879">	/* Initialize wireless band. */</a>
<a name="ln1880">	rtwn_set_chan(sc, ic-&gt;ic_curchan);</a>
<a name="ln1881"> </a>
<a name="ln1882">	/* Clear per-station keys table. */</a>
<a name="ln1883">	rtwn_init_cam(sc);</a>
<a name="ln1884"> </a>
<a name="ln1885">	/* Enable decryption / encryption. */</a>
<a name="ln1886">	rtwn_init_seccfg(sc);</a>
<a name="ln1887"> </a>
<a name="ln1888">	/* Install static keys (if any). */</a>
<a name="ln1889">	for (i = 0; i &lt; nitems(sc-&gt;vaps); i++) {</a>
<a name="ln1890">		if (sc-&gt;vaps[i] != NULL) {</a>
<a name="ln1891">			error = rtwn_init_static_keys(sc, sc-&gt;vaps[i]);</a>
<a name="ln1892">			if (error != 0)</a>
<a name="ln1893">				goto fail;</a>
<a name="ln1894">		}</a>
<a name="ln1895">	}</a>
<a name="ln1896"> </a>
<a name="ln1897">	/* Initialize antenna selection. */</a>
<a name="ln1898">	rtwn_init_antsel(sc);</a>
<a name="ln1899"> </a>
<a name="ln1900">	/* Enable hardware sequence numbering. */</a>
<a name="ln1901">	rtwn_write_1(sc, R92C_HWSEQ_CTRL, R92C_TX_QUEUE_ALL);</a>
<a name="ln1902"> </a>
<a name="ln1903">	/* Disable BAR. */</a>
<a name="ln1904">	rtwn_write_4(sc, R92C_BAR_MODE_CTRL, 0x0201ffff);</a>
<a name="ln1905"> </a>
<a name="ln1906">	/* NAV limit. */</a>
<a name="ln1907">	rtwn_write_1(sc, R92C_NAV_UPPER, 0);</a>
<a name="ln1908"> </a>
<a name="ln1909">	/* Initialize GPIO setting. */</a>
<a name="ln1910">	rtwn_setbits_1(sc, R92C_GPIO_MUXCFG, R92C_GPIO_MUXCFG_ENBT, 0);</a>
<a name="ln1911"> </a>
<a name="ln1912">	/* Initialize MRR. */</a>
<a name="ln1913">	rtwn_mrr_init(sc);</a>
<a name="ln1914"> </a>
<a name="ln1915">	/* Device-specific post initialization. */</a>
<a name="ln1916">	rtwn_post_init(sc);</a>
<a name="ln1917"> </a>
<a name="ln1918">	rtwn_start_xfers(sc);</a>
<a name="ln1919"> </a>
<a name="ln1920">#ifndef D4054</a>
<a name="ln1921">	callout_reset(&amp;sc-&gt;sc_watchdog_to, hz, rtwn_watchdog, sc);</a>
<a name="ln1922">#endif</a>
<a name="ln1923"> </a>
<a name="ln1924">	sc-&gt;sc_flags |= RTWN_RUNNING;</a>
<a name="ln1925">fail:</a>
<a name="ln1926">	RTWN_UNLOCK(sc);</a>
<a name="ln1927"> </a>
<a name="ln1928">	return (error);</a>
<a name="ln1929">}</a>
<a name="ln1930"> </a>
<a name="ln1931">static void</a>
<a name="ln1932">rtwn_stop(struct rtwn_softc *sc)</a>
<a name="ln1933">{</a>
<a name="ln1934"> </a>
<a name="ln1935">	RTWN_LOCK(sc);</a>
<a name="ln1936">	if (!(sc-&gt;sc_flags &amp; RTWN_STARTED)) {</a>
<a name="ln1937">		RTWN_UNLOCK(sc);</a>
<a name="ln1938">		return;</a>
<a name="ln1939">	}</a>
<a name="ln1940"> </a>
<a name="ln1941">#ifndef D4054</a>
<a name="ln1942">	callout_stop(&amp;sc-&gt;sc_watchdog_to);</a>
<a name="ln1943">	sc-&gt;sc_tx_timer = 0;</a>
<a name="ln1944">#endif</a>
<a name="ln1945">	sc-&gt;sc_flags &amp;= ~(RTWN_STARTED | RTWN_RUNNING | RTWN_FW_LOADED);</a>
<a name="ln1946">	sc-&gt;sc_flags &amp;= ~RTWN_TEMP_MEASURED;</a>
<a name="ln1947">	sc-&gt;fwver = 0;</a>
<a name="ln1948">	sc-&gt;thcal_temp = 0;</a>
<a name="ln1949">	sc-&gt;cur_bcnq_id = RTWN_VAP_ID_INVALID;</a>
<a name="ln1950">	bzero(&amp;sc-&gt;last_physt, sizeof(sc-&gt;last_physt));</a>
<a name="ln1951"> </a>
<a name="ln1952">#ifdef D4054</a>
<a name="ln1953">	ieee80211_tx_watchdog_stop(&amp;sc-&gt;sc_ic);</a>
<a name="ln1954">#endif</a>
<a name="ln1955"> </a>
<a name="ln1956">	rtwn_abort_xfers(sc);</a>
<a name="ln1957">	rtwn_drain_mbufq(sc);</a>
<a name="ln1958">	rtwn_power_off(sc);</a>
<a name="ln1959">	rtwn_reset_lists(sc, NULL);</a>
<a name="ln1960">	RTWN_UNLOCK(sc);</a>
<a name="ln1961">}</a>
<a name="ln1962"> </a>
<a name="ln1963">MODULE_VERSION(rtwn, 2);</a>
<a name="ln1964">MODULE_DEPEND(rtwn, wlan, 1, 1, 1);</a>
<a name="ln1965">#ifndef RTWN_WITHOUT_UCODE</a>
<a name="ln1966">MODULE_DEPEND(rtwn, firmware, 1, 1, 1);</a>
<a name="ln1967">#endif</a>

</code></pre>
<div class="balloon" rel="760"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v616/" target="_blank">V616</a> The 'tid' named constant with the value of 0 is used in the bitwise operation.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
