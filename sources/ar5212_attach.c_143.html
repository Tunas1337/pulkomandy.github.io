
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ar5212_attach.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * SPDX-License-Identifier: ISC</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting</a>
<a name="ln5"> * Copyright (c) 2002-2008 Atheros Communications, Inc.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Permission to use, copy, modify, and/or distribute this software for any</a>
<a name="ln8"> * purpose with or without fee is hereby granted, provided that the above</a>
<a name="ln9"> * copyright notice and this permission notice appear in all copies.</a>
<a name="ln10"> *</a>
<a name="ln11"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES</a>
<a name="ln12"> * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</a>
<a name="ln13"> * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR</a>
<a name="ln14"> * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</a>
<a name="ln15"> * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</a>
<a name="ln16"> * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</a>
<a name="ln17"> * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</a>
<a name="ln18"> *</a>
<a name="ln19"> * $FreeBSD: releng/12.0/sys/dev/ath/ath_hal/ar5212/ar5212_attach.c 326695 2017-12-08 15:57:29Z pfg $</a>
<a name="ln20"> */</a>
<a name="ln21">#include &quot;opt_ah.h&quot;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;ah.h&quot;</a>
<a name="ln24">#include &quot;ah_internal.h&quot;</a>
<a name="ln25">#include &quot;ah_devid.h&quot;</a>
<a name="ln26"> </a>
<a name="ln27">#include &quot;ar5212/ar5212.h&quot;</a>
<a name="ln28">#include &quot;ar5212/ar5212reg.h&quot;</a>
<a name="ln29">#include &quot;ar5212/ar5212phy.h&quot;</a>
<a name="ln30"> </a>
<a name="ln31">#define AH_5212_COMMON</a>
<a name="ln32">#include &quot;ar5212/ar5212.ini&quot;</a>
<a name="ln33"> </a>
<a name="ln34">static void ar5212ConfigPCIE(struct ath_hal *ah, HAL_BOOL restore,</a>
<a name="ln35">		HAL_BOOL power_off);</a>
<a name="ln36">static void ar5212DisablePCIE(struct ath_hal *ah);</a>
<a name="ln37"> </a>
<a name="ln38">static const struct ath_hal_private ar5212hal = {{</a>
<a name="ln39">	.ah_magic			= AR5212_MAGIC,</a>
<a name="ln40"> </a>
<a name="ln41">	.ah_getRateTable		= ar5212GetRateTable,</a>
<a name="ln42">	.ah_detach			= ar5212Detach,</a>
<a name="ln43"> </a>
<a name="ln44">	/* Reset Functions */</a>
<a name="ln45">	.ah_reset			= ar5212Reset,</a>
<a name="ln46">	.ah_phyDisable			= ar5212PhyDisable,</a>
<a name="ln47">	.ah_disable			= ar5212Disable,</a>
<a name="ln48">	.ah_configPCIE			= ar5212ConfigPCIE,</a>
<a name="ln49">	.ah_disablePCIE			= ar5212DisablePCIE,</a>
<a name="ln50">	.ah_setPCUConfig		= ar5212SetPCUConfig,</a>
<a name="ln51">	.ah_perCalibration		= ar5212PerCalibration,</a>
<a name="ln52">	.ah_perCalibrationN		= ar5212PerCalibrationN,</a>
<a name="ln53">	.ah_resetCalValid		= ar5212ResetCalValid,</a>
<a name="ln54">	.ah_setTxPowerLimit		= ar5212SetTxPowerLimit,</a>
<a name="ln55">	.ah_getChanNoise		= ath_hal_getChanNoise,</a>
<a name="ln56"> </a>
<a name="ln57">	/* Transmit functions */</a>
<a name="ln58">	.ah_updateTxTrigLevel		= ar5212UpdateTxTrigLevel,</a>
<a name="ln59">	.ah_setupTxQueue		= ar5212SetupTxQueue,</a>
<a name="ln60">	.ah_setTxQueueProps             = ar5212SetTxQueueProps,</a>
<a name="ln61">	.ah_getTxQueueProps             = ar5212GetTxQueueProps,</a>
<a name="ln62">	.ah_releaseTxQueue		= ar5212ReleaseTxQueue,</a>
<a name="ln63">	.ah_resetTxQueue		= ar5212ResetTxQueue,</a>
<a name="ln64">	.ah_getTxDP			= ar5212GetTxDP,</a>
<a name="ln65">	.ah_setTxDP			= ar5212SetTxDP,</a>
<a name="ln66">	.ah_numTxPending		= ar5212NumTxPending,</a>
<a name="ln67">	.ah_startTxDma			= ar5212StartTxDma,</a>
<a name="ln68">	.ah_stopTxDma			= ar5212StopTxDma,</a>
<a name="ln69">	.ah_setupTxDesc			= ar5212SetupTxDesc,</a>
<a name="ln70">	.ah_setupXTxDesc		= ar5212SetupXTxDesc,</a>
<a name="ln71">	.ah_fillTxDesc			= ar5212FillTxDesc,</a>
<a name="ln72">	.ah_procTxDesc			= ar5212ProcTxDesc,</a>
<a name="ln73">	.ah_getTxIntrQueue		= ar5212GetTxIntrQueue,</a>
<a name="ln74">	.ah_reqTxIntrDesc 		= ar5212IntrReqTxDesc,</a>
<a name="ln75">	.ah_getTxCompletionRates	= ar5212GetTxCompletionRates,</a>
<a name="ln76">	.ah_setTxDescLink		= ar5212SetTxDescLink,</a>
<a name="ln77">	.ah_getTxDescLink		= ar5212GetTxDescLink,</a>
<a name="ln78">	.ah_getTxDescLinkPtr		= ar5212GetTxDescLinkPtr,</a>
<a name="ln79"> </a>
<a name="ln80">	/* RX Functions */</a>
<a name="ln81">	.ah_getRxDP			= ar5212GetRxDP,</a>
<a name="ln82">	.ah_setRxDP			= ar5212SetRxDP,</a>
<a name="ln83">	.ah_enableReceive		= ar5212EnableReceive,</a>
<a name="ln84">	.ah_stopDmaReceive		= ar5212StopDmaReceive,</a>
<a name="ln85">	.ah_startPcuReceive		= ar5212StartPcuReceive,</a>
<a name="ln86">	.ah_stopPcuReceive		= ar5212StopPcuReceive,</a>
<a name="ln87">	.ah_setMulticastFilter		= ar5212SetMulticastFilter,</a>
<a name="ln88">	.ah_setMulticastFilterIndex	= ar5212SetMulticastFilterIndex,</a>
<a name="ln89">	.ah_clrMulticastFilterIndex	= ar5212ClrMulticastFilterIndex,</a>
<a name="ln90">	.ah_getRxFilter			= ar5212GetRxFilter,</a>
<a name="ln91">	.ah_setRxFilter			= ar5212SetRxFilter,</a>
<a name="ln92">	.ah_setupRxDesc			= ar5212SetupRxDesc,</a>
<a name="ln93">	.ah_procRxDesc			= ar5212ProcRxDesc,</a>
<a name="ln94">	.ah_rxMonitor			= ar5212RxMonitor,</a>
<a name="ln95">	.ah_aniPoll			= ar5212AniPoll,</a>
<a name="ln96">	.ah_procMibEvent		= ar5212ProcessMibIntr,</a>
<a name="ln97"> </a>
<a name="ln98">	/* Misc Functions */</a>
<a name="ln99">	.ah_getCapability		= ar5212GetCapability,</a>
<a name="ln100">	.ah_setCapability		= ar5212SetCapability,</a>
<a name="ln101">	.ah_getDiagState		= ar5212GetDiagState,</a>
<a name="ln102">	.ah_getMacAddress		= ar5212GetMacAddress,</a>
<a name="ln103">	.ah_setMacAddress		= ar5212SetMacAddress,</a>
<a name="ln104">	.ah_getBssIdMask		= ar5212GetBssIdMask,</a>
<a name="ln105">	.ah_setBssIdMask		= ar5212SetBssIdMask,</a>
<a name="ln106">	.ah_setRegulatoryDomain		= ar5212SetRegulatoryDomain,</a>
<a name="ln107">	.ah_setLedState			= ar5212SetLedState,</a>
<a name="ln108">	.ah_writeAssocid		= ar5212WriteAssocid,</a>
<a name="ln109">	.ah_gpioCfgInput		= ar5212GpioCfgInput,</a>
<a name="ln110">	.ah_gpioCfgOutput		= ar5212GpioCfgOutput,</a>
<a name="ln111">	.ah_gpioGet			= ar5212GpioGet,</a>
<a name="ln112">	.ah_gpioSet			= ar5212GpioSet,</a>
<a name="ln113">	.ah_gpioSetIntr			= ar5212GpioSetIntr,</a>
<a name="ln114">	.ah_getTsf32			= ar5212GetTsf32,</a>
<a name="ln115">	.ah_getTsf64			= ar5212GetTsf64,</a>
<a name="ln116">	.ah_setTsf64			= ar5212SetTsf64,</a>
<a name="ln117">	.ah_resetTsf			= ar5212ResetTsf,</a>
<a name="ln118">	.ah_detectCardPresent		= ar5212DetectCardPresent,</a>
<a name="ln119">	.ah_updateMibCounters		= ar5212UpdateMibCounters,</a>
<a name="ln120">	.ah_getRfGain			= ar5212GetRfgain,</a>
<a name="ln121">	.ah_getDefAntenna		= ar5212GetDefAntenna,</a>
<a name="ln122">	.ah_setDefAntenna		= ar5212SetDefAntenna,</a>
<a name="ln123">	.ah_getAntennaSwitch		= ar5212GetAntennaSwitch,</a>
<a name="ln124">	.ah_setAntennaSwitch		= ar5212SetAntennaSwitch,</a>
<a name="ln125">	.ah_setSifsTime			= ar5212SetSifsTime,</a>
<a name="ln126">	.ah_getSifsTime			= ar5212GetSifsTime,</a>
<a name="ln127">	.ah_setSlotTime			= ar5212SetSlotTime,</a>
<a name="ln128">	.ah_getSlotTime			= ar5212GetSlotTime,</a>
<a name="ln129">	.ah_setAckTimeout		= ar5212SetAckTimeout,</a>
<a name="ln130">	.ah_getAckTimeout		= ar5212GetAckTimeout,</a>
<a name="ln131">	.ah_setAckCTSRate		= ar5212SetAckCTSRate,</a>
<a name="ln132">	.ah_getAckCTSRate		= ar5212GetAckCTSRate,</a>
<a name="ln133">	.ah_setCTSTimeout		= ar5212SetCTSTimeout,</a>
<a name="ln134">	.ah_getCTSTimeout		= ar5212GetCTSTimeout,</a>
<a name="ln135">	.ah_setDecompMask		= ar5212SetDecompMask,</a>
<a name="ln136">	.ah_setCoverageClass		= ar5212SetCoverageClass,</a>
<a name="ln137">	.ah_setQuiet			= ar5212SetQuiet,</a>
<a name="ln138">	.ah_getMibCycleCounts		= ar5212GetMibCycleCounts,</a>
<a name="ln139">	.ah_setChainMasks		= ar5212SetChainMasks,</a>
<a name="ln140"> </a>
<a name="ln141">	/* DFS Functions */</a>
<a name="ln142">	.ah_enableDfs			= ar5212EnableDfs,</a>
<a name="ln143">	.ah_getDfsThresh		= ar5212GetDfsThresh,</a>
<a name="ln144">	.ah_getDfsDefaultThresh		= ar5212GetDfsDefaultThresh,</a>
<a name="ln145">	.ah_procRadarEvent		= ar5212ProcessRadarEvent,</a>
<a name="ln146">	.ah_isFastClockEnabled		= ar5212IsFastClockEnabled,</a>
<a name="ln147">	.ah_get11nExtBusy		= ar5212Get11nExtBusy,</a>
<a name="ln148"> </a>
<a name="ln149">	/* Key Cache Functions */</a>
<a name="ln150">	.ah_getKeyCacheSize		= ar5212GetKeyCacheSize,</a>
<a name="ln151">	.ah_resetKeyCacheEntry		= ar5212ResetKeyCacheEntry,</a>
<a name="ln152">	.ah_isKeyCacheEntryValid	= ar5212IsKeyCacheEntryValid,</a>
<a name="ln153">	.ah_setKeyCacheEntry		= ar5212SetKeyCacheEntry,</a>
<a name="ln154">	.ah_setKeyCacheEntryMac		= ar5212SetKeyCacheEntryMac,</a>
<a name="ln155"> </a>
<a name="ln156">	/* Power Management Functions */</a>
<a name="ln157">	.ah_setPowerMode		= ar5212SetPowerMode,</a>
<a name="ln158">	.ah_getPowerMode		= ar5212GetPowerMode,</a>
<a name="ln159"> </a>
<a name="ln160">	/* Beacon Functions */</a>
<a name="ln161">	.ah_setBeaconTimers		= ar5212SetBeaconTimers,</a>
<a name="ln162">	.ah_beaconInit			= ar5212BeaconInit,</a>
<a name="ln163">	.ah_setStationBeaconTimers	= ar5212SetStaBeaconTimers,</a>
<a name="ln164">	.ah_resetStationBeaconTimers	= ar5212ResetStaBeaconTimers,</a>
<a name="ln165">	.ah_getNextTBTT			= ar5212GetNextTBTT,</a>
<a name="ln166"> </a>
<a name="ln167">	/* Interrupt Functions */</a>
<a name="ln168">	.ah_isInterruptPending		= ar5212IsInterruptPending,</a>
<a name="ln169">	.ah_getPendingInterrupts	= ar5212GetPendingInterrupts,</a>
<a name="ln170">	.ah_getInterrupts		= ar5212GetInterrupts,</a>
<a name="ln171">	.ah_setInterrupts		= ar5212SetInterrupts },</a>
<a name="ln172"> </a>
<a name="ln173">	.ah_getChannelEdges		= ar5212GetChannelEdges,</a>
<a name="ln174">	.ah_getWirelessModes		= ar5212GetWirelessModes,</a>
<a name="ln175">	.ah_eepromRead			= ar5212EepromRead,</a>
<a name="ln176">#ifdef AH_SUPPORT_WRITE_EEPROM</a>
<a name="ln177">	.ah_eepromWrite			= ar5212EepromWrite,</a>
<a name="ln178">#endif</a>
<a name="ln179">	.ah_getChipPowerLimits		= ar5212GetChipPowerLimits,</a>
<a name="ln180">};</a>
<a name="ln181"> </a>
<a name="ln182">uint32_t</a>
<a name="ln183">ar5212GetRadioRev(struct ath_hal *ah)</a>
<a name="ln184">{</a>
<a name="ln185">	uint32_t val;</a>
<a name="ln186">	int i;</a>
<a name="ln187"> </a>
<a name="ln188">	/* Read Radio Chip Rev Extract */</a>
<a name="ln189">	OS_REG_WRITE(ah, AR_PHY(0x34), 0x00001c16);</a>
<a name="ln190">	for (i = 0; i &lt; 8; i++)</a>
<a name="ln191">		OS_REG_WRITE(ah, AR_PHY(0x20), 0x00010000);</a>
<a name="ln192">	val = (OS_REG_READ(ah, AR_PHY(256)) &gt;&gt; 24) &amp; 0xff;</a>
<a name="ln193">	val = ((val &amp; 0xf0) &gt;&gt; 4) | ((val &amp; 0x0f) &lt;&lt; 4);</a>
<a name="ln194">	return ath_hal_reverseBits(val, 8);</a>
<a name="ln195">}</a>
<a name="ln196"> </a>
<a name="ln197">static void</a>
<a name="ln198">ar5212AniSetup(struct ath_hal *ah)</a>
<a name="ln199">{</a>
<a name="ln200">	static const struct ar5212AniParams aniparams = {</a>
<a name="ln201">		.maxNoiseImmunityLevel	= 4,	/* levels 0..4 */</a>
<a name="ln202">		.totalSizeDesired	= { -55, -55, -55, -55, -62 },</a>
<a name="ln203">		.coarseHigh		= { -14, -14, -14, -14, -12 },</a>
<a name="ln204">		.coarseLow		= { -64, -64, -64, -64, -70 },</a>
<a name="ln205">		.firpwr			= { -78, -78, -78, -78, -80 },</a>
<a name="ln206">		.maxSpurImmunityLevel	= 2,	/* NB: depends on chip rev */</a>
<a name="ln207">		.cycPwrThr1		= { 2, 4, 6, 8, 10, 12, 14, 16 },</a>
<a name="ln208">		.maxFirstepLevel	= 2,	/* levels 0..2 */</a>
<a name="ln209">		.firstep		= { 0, 4, 8 },</a>
<a name="ln210">		.ofdmTrigHigh		= 500,</a>
<a name="ln211">		.ofdmTrigLow		= 200,</a>
<a name="ln212">		.cckTrigHigh		= 200,</a>
<a name="ln213">		.cckTrigLow		= 100,</a>
<a name="ln214">		.rssiThrHigh		= 40,</a>
<a name="ln215">		.rssiThrLow		= 7,</a>
<a name="ln216">		.period			= 100,</a>
<a name="ln217">	};</a>
<a name="ln218">	if (AH_PRIVATE(ah)-&gt;ah_macVersion &lt; AR_SREV_VERSION_GRIFFIN) {</a>
<a name="ln219">		struct ar5212AniParams tmp;</a>
<a name="ln220">		OS_MEMCPY(&amp;tmp, &amp;aniparams, sizeof(struct ar5212AniParams));</a>
<a name="ln221">		tmp.maxSpurImmunityLevel = 7;	/* Venice and earlier */</a>
<a name="ln222">		ar5212AniAttach(ah, &amp;tmp, &amp;tmp, AH_TRUE);</a>
<a name="ln223">	} else</a>
<a name="ln224">		ar5212AniAttach(ah, &amp;aniparams, &amp;aniparams, AH_TRUE);</a>
<a name="ln225"> </a>
<a name="ln226">	/* Set overridable ANI methods */</a>
<a name="ln227">	AH5212(ah)-&gt;ah_aniControl = ar5212AniControl;</a>
<a name="ln228">}</a>
<a name="ln229"> </a>
<a name="ln230">/*</a>
<a name="ln231"> * Attach for an AR5212 part.</a>
<a name="ln232"> */</a>
<a name="ln233">void</a>
<a name="ln234">ar5212InitState(struct ath_hal_5212 *ahp, uint16_t devid, HAL_SOFTC sc,</a>
<a name="ln235">	HAL_BUS_TAG st, HAL_BUS_HANDLE sh, HAL_STATUS *status)</a>
<a name="ln236">{</a>
<a name="ln237">#define	N(a)	(sizeof(a)/sizeof(a[0]))</a>
<a name="ln238">	static const uint8_t defbssidmask[IEEE80211_ADDR_LEN] =</a>
<a name="ln239">		{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };</a>
<a name="ln240">	struct ath_hal *ah;</a>
<a name="ln241"> </a>
<a name="ln242">	ah = &amp;ahp-&gt;ah_priv.h;</a>
<a name="ln243">	/* set initial values */</a>
<a name="ln244">	OS_MEMCPY(&amp;ahp-&gt;ah_priv, &amp;ar5212hal, sizeof(struct ath_hal_private));</a>
<a name="ln245">	ah-&gt;ah_sc = sc;</a>
<a name="ln246">	ah-&gt;ah_st = st;</a>
<a name="ln247">	ah-&gt;ah_sh = sh;</a>
<a name="ln248"> </a>
<a name="ln249">	ah-&gt;ah_devid = devid;			/* NB: for alq */</a>
<a name="ln250">	AH_PRIVATE(ah)-&gt;ah_devid = devid;</a>
<a name="ln251">	AH_PRIVATE(ah)-&gt;ah_subvendorid = 0;	/* XXX */</a>
<a name="ln252"> </a>
<a name="ln253">	AH_PRIVATE(ah)-&gt;ah_powerLimit = MAX_RATE_POWER;</a>
<a name="ln254">	AH_PRIVATE(ah)-&gt;ah_tpScale = HAL_TP_SCALE_MAX;	/* no scaling */</a>
<a name="ln255"> </a>
<a name="ln256">	ahp-&gt;ah_antControl = HAL_ANT_VARIABLE;</a>
<a name="ln257">	ahp-&gt;ah_diversity = AH_TRUE;</a>
<a name="ln258">	ahp-&gt;ah_bIQCalibration = AH_FALSE;</a>
<a name="ln259">	/*</a>
<a name="ln260">	 * Enable MIC handling.</a>
<a name="ln261">	 */</a>
<a name="ln262">	ahp-&gt;ah_staId1Defaults = AR_STA_ID1_CRPT_MIC_ENABLE;</a>
<a name="ln263">	ahp-&gt;ah_rssiThr = INIT_RSSI_THR;</a>
<a name="ln264">	ahp-&gt;ah_tpcEnabled = AH_FALSE;		/* disabled by default */</a>
<a name="ln265">	ahp-&gt;ah_phyPowerOn = AH_FALSE;</a>
<a name="ln266">	ahp-&gt;ah_macTPC = SM(MAX_RATE_POWER, AR_TPC_ACK)</a>
<a name="ln267">		       | SM(MAX_RATE_POWER, AR_TPC_CTS)</a>
<a name="ln268">		       | SM(MAX_RATE_POWER, AR_TPC_CHIRP);</a>
<a name="ln269">	ahp-&gt;ah_beaconInterval = 100;		/* XXX [20..1000] */</a>
<a name="ln270">	ahp-&gt;ah_enable32kHzClock = DONT_USE_32KHZ;/* XXX */</a>
<a name="ln271">	ahp-&gt;ah_slottime = (u_int) -1;</a>
<a name="ln272">	ahp-&gt;ah_acktimeout = (u_int) -1;</a>
<a name="ln273">	ahp-&gt;ah_ctstimeout = (u_int) -1;</a>
<a name="ln274">	ahp-&gt;ah_sifstime = (u_int) -1;</a>
<a name="ln275">	ahp-&gt;ah_txTrigLev = INIT_TX_FIFO_THRESHOLD;</a>
<a name="ln276">	ahp-&gt;ah_maxTxTrigLev = MAX_TX_FIFO_THRESHOLD;</a>
<a name="ln277"> </a>
<a name="ln278">	OS_MEMCPY(&amp;ahp-&gt;ah_bssidmask, defbssidmask, IEEE80211_ADDR_LEN);</a>
<a name="ln279">#undef N</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282">/*</a>
<a name="ln283"> * Validate MAC version and revision. </a>
<a name="ln284"> */</a>
<a name="ln285">static HAL_BOOL</a>
<a name="ln286">ar5212IsMacSupported(uint8_t macVersion, uint8_t macRev)</a>
<a name="ln287">{</a>
<a name="ln288">#define	N(a)	(sizeof(a)/sizeof(a[0]))</a>
<a name="ln289">	static const struct {</a>
<a name="ln290">		uint8_t	version;</a>
<a name="ln291">		uint8_t	revMin, revMax;</a>
<a name="ln292">	} macs[] = {</a>
<a name="ln293">	    { AR_SREV_VERSION_VENICE,</a>
<a name="ln294">	      AR_SREV_D2PLUS,		AR_SREV_REVISION_MAX },</a>
<a name="ln295">	    { AR_SREV_VERSION_GRIFFIN,</a>
<a name="ln296">	      AR_SREV_D2PLUS,		AR_SREV_REVISION_MAX },</a>
<a name="ln297">	    { AR_SREV_5413,</a>
<a name="ln298">	      AR_SREV_REVISION_MIN,	AR_SREV_REVISION_MAX },</a>
<a name="ln299">	    { AR_SREV_5424,</a>
<a name="ln300">	      AR_SREV_REVISION_MIN,	AR_SREV_REVISION_MAX },</a>
<a name="ln301">	    { AR_SREV_2425,</a>
<a name="ln302">	      AR_SREV_REVISION_MIN,	AR_SREV_REVISION_MAX },</a>
<a name="ln303">	    { AR_SREV_2417,</a>
<a name="ln304">	      AR_SREV_REVISION_MIN,	AR_SREV_REVISION_MAX },</a>
<a name="ln305">	};</a>
<a name="ln306">	int i;</a>
<a name="ln307"> </a>
<a name="ln308">	for (i = 0; i &lt; N(macs); i++)</a>
<a name="ln309">		if (macs[i].version == macVersion &amp;&amp;</a>
<a name="ln310">		    macs[i].revMin &lt;= macRev &amp;&amp; macRev &lt;= macs[i].revMax)</a>
<a name="ln311">			return AH_TRUE;</a>
<a name="ln312">	return AH_FALSE;</a>
<a name="ln313">#undef N</a>
<a name="ln314">}</a>
<a name="ln315">       </a>
<a name="ln316">/*</a>
<a name="ln317"> * Attach for an AR5212 part.</a>
<a name="ln318"> */</a>
<a name="ln319">static struct ath_hal *</a>
<a name="ln320">ar5212Attach(uint16_t devid, HAL_SOFTC sc,</a>
<a name="ln321">	HAL_BUS_TAG st, HAL_BUS_HANDLE sh, uint16_t *eepromdata,</a>
<a name="ln322">	HAL_OPS_CONFIG *ah_config, HAL_STATUS *status)</a>
<a name="ln323">{</a>
<a name="ln324">#define	AH_EEPROM_PROTECT(ah) \</a>
<a name="ln325">	(AH_PRIVATE(ah)-&gt;ah_ispcie)? AR_EEPROM_PROTECT_PCIE : AR_EEPROM_PROTECT)</a>
<a name="ln326">	struct ath_hal_5212 *ahp;</a>
<a name="ln327">	struct ath_hal *ah;</a>
<a name="ln328">	struct ath_hal_rf *rf;</a>
<a name="ln329">	uint32_t val;</a>
<a name="ln330">	uint16_t eeval;</a>
<a name="ln331">	HAL_STATUS ecode;</a>
<a name="ln332"> </a>
<a name="ln333">	HALDEBUG(AH_NULL, HAL_DEBUG_ATTACH, &quot;%s: sc %p st %p sh %p\n&quot;,</a>
<a name="ln334">	    __func__, sc, (void*) st, (void*) sh);</a>
<a name="ln335"> </a>
<a name="ln336">	/* NB: memory is returned zero'd */</a>
<a name="ln337">	ahp = ath_hal_malloc(sizeof (struct ath_hal_5212));</a>
<a name="ln338">	if (ahp == AH_NULL) {</a>
<a name="ln339">		HALDEBUG(AH_NULL, HAL_DEBUG_ANY,</a>
<a name="ln340">		    &quot;%s: cannot allocate memory for state block\n&quot;, __func__);</a>
<a name="ln341">		*status = HAL_ENOMEM;</a>
<a name="ln342">		return AH_NULL;</a>
<a name="ln343">	}</a>
<a name="ln344">	ar5212InitState(ahp, devid, sc, st, sh, status);</a>
<a name="ln345">	ah = &amp;ahp-&gt;ah_priv.h;</a>
<a name="ln346"> </a>
<a name="ln347">	if (!ar5212SetPowerMode(ah, HAL_PM_AWAKE, AH_TRUE)) {</a>
<a name="ln348">		HALDEBUG(ah, HAL_DEBUG_ANY, &quot;%s: couldn't wakeup chip\n&quot;,</a>
<a name="ln349">		    __func__);</a>
<a name="ln350">		ecode = HAL_EIO;</a>
<a name="ln351">		goto bad;</a>
<a name="ln352">	}</a>
<a name="ln353">	/* Read Revisions from Chips before taking out of reset */</a>
<a name="ln354">	val = OS_REG_READ(ah, AR_SREV) &amp; AR_SREV_ID;</a>
<a name="ln355">	AH_PRIVATE(ah)-&gt;ah_macVersion = val &gt;&gt; AR_SREV_ID_S;</a>
<a name="ln356">	AH_PRIVATE(ah)-&gt;ah_macRev = val &amp; AR_SREV_REVISION;</a>
<a name="ln357">	AH_PRIVATE(ah)-&gt;ah_ispcie = IS_5424(ah) || IS_2425(ah);</a>
<a name="ln358"> </a>
<a name="ln359">	if (!ar5212IsMacSupported(AH_PRIVATE(ah)-&gt;ah_macVersion, AH_PRIVATE(ah)-&gt;ah_macRev)) {</a>
<a name="ln360">		HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln361">		    &quot;%s: Mac Chip Rev 0x%02x.%x not supported\n&quot; ,</a>
<a name="ln362">		    __func__, AH_PRIVATE(ah)-&gt;ah_macVersion,</a>
<a name="ln363">		    AH_PRIVATE(ah)-&gt;ah_macRev);</a>
<a name="ln364">		ecode = HAL_ENOTSUPP;</a>
<a name="ln365">		goto bad;</a>
<a name="ln366">	}</a>
<a name="ln367"> </a>
<a name="ln368">	/* setup common ini data; rf backends handle remainder */</a>
<a name="ln369">	HAL_INI_INIT(&amp;ahp-&gt;ah_ini_modes, ar5212Modes, 6);</a>
<a name="ln370">	HAL_INI_INIT(&amp;ahp-&gt;ah_ini_common, ar5212Common, 2);</a>
<a name="ln371"> </a>
<a name="ln372">	if (!ar5212ChipReset(ah, AH_NULL)) {	/* reset chip */</a>
<a name="ln373">		HALDEBUG(ah, HAL_DEBUG_ANY, &quot;%s: chip reset failed\n&quot;, __func__);</a>
<a name="ln374">		ecode = HAL_EIO;</a>
<a name="ln375">		goto bad;</a>
<a name="ln376">	}</a>
<a name="ln377"> </a>
<a name="ln378">	AH_PRIVATE(ah)-&gt;ah_phyRev = OS_REG_READ(ah, AR_PHY_CHIP_ID);</a>
<a name="ln379"> </a>
<a name="ln380">	if (AH_PRIVATE(ah)-&gt;ah_ispcie) {</a>
<a name="ln381">		/* XXX: build flag to disable this? */</a>
<a name="ln382">		ath_hal_configPCIE(ah, AH_FALSE, AH_FALSE);</a>
<a name="ln383">	}</a>
<a name="ln384"> </a>
<a name="ln385">	if (!ar5212ChipTest(ah)) {</a>
<a name="ln386">		HALDEBUG(ah, HAL_DEBUG_ANY, &quot;%s: hardware self-test failed\n&quot;,</a>
<a name="ln387">		    __func__);</a>
<a name="ln388">		ecode = HAL_ESELFTEST;</a>
<a name="ln389">		goto bad;</a>
<a name="ln390">	}</a>
<a name="ln391"> </a>
<a name="ln392">	/* Enable PCI core retry fix in software for Hainan and up */</a>
<a name="ln393">	if (AH_PRIVATE(ah)-&gt;ah_macVersion &gt;= AR_SREV_VERSION_VENICE)</a>
<a name="ln394">		OS_REG_SET_BIT(ah, AR_PCICFG, AR_PCICFG_RETRYFIXEN);</a>
<a name="ln395"> </a>
<a name="ln396">	/*</a>
<a name="ln397">	 * Set correct Baseband to analog shift</a>
<a name="ln398">	 * setting to access analog chips.</a>
<a name="ln399">	 */</a>
<a name="ln400">	OS_REG_WRITE(ah, AR_PHY(0), 0x00000007);</a>
<a name="ln401"> </a>
<a name="ln402">	/* Read Radio Chip Rev Extract */</a>
<a name="ln403">	AH_PRIVATE(ah)-&gt;ah_analog5GhzRev = ar5212GetRadioRev(ah);</a>
<a name="ln404"> </a>
<a name="ln405">	rf = ath_hal_rfprobe(ah, &amp;ecode);</a>
<a name="ln406">	if (rf == AH_NULL)</a>
<a name="ln407">		goto bad;</a>
<a name="ln408"> </a>
<a name="ln409">	/* NB: silently accept anything in release code per Atheros */</a>
<a name="ln410">	switch (AH_PRIVATE(ah)-&gt;ah_analog5GhzRev &amp; AR_RADIO_SREV_MAJOR) {</a>
<a name="ln411">	case AR_RAD5111_SREV_MAJOR:</a>
<a name="ln412">	case AR_RAD5112_SREV_MAJOR:</a>
<a name="ln413">	case AR_RAD2112_SREV_MAJOR:</a>
<a name="ln414">	case AR_RAD2111_SREV_MAJOR:</a>
<a name="ln415">	case AR_RAD2413_SREV_MAJOR:</a>
<a name="ln416">	case AR_RAD5413_SREV_MAJOR:</a>
<a name="ln417">	case AR_RAD5424_SREV_MAJOR:</a>
<a name="ln418">		break;</a>
<a name="ln419">	default:</a>
<a name="ln420">		if (AH_PRIVATE(ah)-&gt;ah_analog5GhzRev == 0) {</a>
<a name="ln421">			/*</a>
<a name="ln422">			 * When RF_Silent is used, the</a>
<a name="ln423">			 * analog chip is reset.  So when the system boots</a>
<a name="ln424">			 * up with the radio switch off we cannot determine</a>
<a name="ln425">			 * the RF chip rev.  To workaround this check the</a>
<a name="ln426">			 * mac+phy revs and if Hainan, set the radio rev</a>
<a name="ln427">			 * to Derby.</a>
<a name="ln428">			 */</a>
<a name="ln429">			if (AH_PRIVATE(ah)-&gt;ah_macVersion == AR_SREV_VERSION_VENICE &amp;&amp;</a>
<a name="ln430">			    AH_PRIVATE(ah)-&gt;ah_macRev == AR_SREV_HAINAN &amp;&amp;</a>
<a name="ln431">			    AH_PRIVATE(ah)-&gt;ah_phyRev == AR_PHYREV_HAINAN) {</a>
<a name="ln432">				AH_PRIVATE(ah)-&gt;ah_analog5GhzRev = AR_ANALOG5REV_HAINAN;</a>
<a name="ln433">				break;</a>
<a name="ln434">			}</a>
<a name="ln435">			if (IS_2413(ah)) {		/* Griffin */</a>
<a name="ln436">				AH_PRIVATE(ah)-&gt;ah_analog5GhzRev =</a>
<a name="ln437">				    AR_RAD2413_SREV_MAJOR | 0x1;</a>
<a name="ln438">				break;</a>
<a name="ln439">			}</a>
<a name="ln440">			if (IS_5413(ah)) {		/* Eagle */	</a>
<a name="ln441">				AH_PRIVATE(ah)-&gt;ah_analog5GhzRev =</a>
<a name="ln442">				    AR_RAD5413_SREV_MAJOR | 0x2;</a>
<a name="ln443">				break;</a>
<a name="ln444">			}</a>
<a name="ln445">			if (IS_2425(ah) || IS_2417(ah)) {/* Swan or Nala */	</a>
<a name="ln446">				AH_PRIVATE(ah)-&gt;ah_analog5GhzRev =</a>
<a name="ln447">				    AR_RAD5424_SREV_MAJOR | 0x2;</a>
<a name="ln448">				break;</a>
<a name="ln449">			}</a>
<a name="ln450">		}</a>
<a name="ln451">#ifdef AH_DEBUG</a>
<a name="ln452">		HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln453">		    &quot;%s: 5G Radio Chip Rev 0x%02X is not supported by &quot;</a>
<a name="ln454">		    &quot;this driver\n&quot;,</a>
<a name="ln455">		    __func__, AH_PRIVATE(ah)-&gt;ah_analog5GhzRev);</a>
<a name="ln456">		ecode = HAL_ENOTSUPP;</a>
<a name="ln457">		goto bad;</a>
<a name="ln458">#endif</a>
<a name="ln459">	}</a>
<a name="ln460">	if (IS_RAD5112_REV1(ah)) {</a>
<a name="ln461">		HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln462">		    &quot;%s: 5112 Rev 1 is not supported by this &quot;</a>
<a name="ln463">		    &quot;driver (analog5GhzRev 0x%x)\n&quot;, __func__,</a>
<a name="ln464">		    AH_PRIVATE(ah)-&gt;ah_analog5GhzRev);</a>
<a name="ln465">		ecode = HAL_ENOTSUPP;</a>
<a name="ln466">		goto bad;</a>
<a name="ln467">	}</a>
<a name="ln468"> </a>
<a name="ln469">	val = OS_REG_READ(ah, AR_PCICFG);</a>
<a name="ln470">	val = MS(val, AR_PCICFG_EEPROM_SIZE);</a>
<a name="ln471">	if (val == 0) {</a>
<a name="ln472">		if (!AH_PRIVATE(ah)-&gt;ah_ispcie) {</a>
<a name="ln473">			HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln474">			    &quot;%s: unsupported EEPROM size %u (0x%x) found\n&quot;,</a>
<a name="ln475">			    __func__, val, val);</a>
<a name="ln476">			ecode = HAL_EESIZE;</a>
<a name="ln477">			goto bad;</a>
<a name="ln478">		}</a>
<a name="ln479">		/* XXX AH_PRIVATE(ah)-&gt;ah_isPciExpress = AH_TRUE; */</a>
<a name="ln480">	} else if (val != AR_PCICFG_EEPROM_SIZE_16K) {</a>
<a name="ln481">		if (AR_PCICFG_EEPROM_SIZE_FAILED == val) {</a>
<a name="ln482">			HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln483">			    &quot;%s: unsupported EEPROM size %u (0x%x) found\n&quot;,</a>
<a name="ln484">			    __func__, val, val);</a>
<a name="ln485">			ecode = HAL_EESIZE;</a>
<a name="ln486">			goto bad;</a>
<a name="ln487">		}</a>
<a name="ln488">		HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln489">		    &quot;%s: EEPROM size = %d. Must be %d (16k).\n&quot;,</a>
<a name="ln490">		    __func__, val, AR_PCICFG_EEPROM_SIZE_16K);</a>
<a name="ln491">		ecode = HAL_EESIZE;</a>
<a name="ln492">		goto bad;</a>
<a name="ln493">	}</a>
<a name="ln494">	ecode = ath_hal_legacyEepromAttach(ah);</a>
<a name="ln495">	if (ecode != HAL_OK) {</a>
<a name="ln496">		goto bad;</a>
<a name="ln497">	}</a>
<a name="ln498">	ahp-&gt;ah_isHb63 = IS_2425(ah) &amp;&amp; ath_hal_eepromGetFlag(ah, AR_EEP_ISTALON);</a>
<a name="ln499"> </a>
<a name="ln500">	/*</a>
<a name="ln501">	 * If Bmode and AR5212, verify 2.4 analog exists</a>
<a name="ln502">	 */</a>
<a name="ln503">	if (ath_hal_eepromGetFlag(ah, AR_EEP_BMODE) &amp;&amp;</a>
<a name="ln504">	    (AH_PRIVATE(ah)-&gt;ah_analog5GhzRev &amp; 0xF0) == AR_RAD5111_SREV_MAJOR) {</a>
<a name="ln505">		/*</a>
<a name="ln506">		 * Set correct Baseband to analog shift</a>
<a name="ln507">		 * setting to access analog chips.</a>
<a name="ln508">		 */</a>
<a name="ln509">		OS_REG_WRITE(ah, AR_PHY(0), 0x00004007);</a>
<a name="ln510">		OS_DELAY(2000);</a>
<a name="ln511">		AH_PRIVATE(ah)-&gt;ah_analog2GhzRev = ar5212GetRadioRev(ah);</a>
<a name="ln512"> </a>
<a name="ln513">		/* Set baseband for 5GHz chip */</a>
<a name="ln514">		OS_REG_WRITE(ah, AR_PHY(0), 0x00000007);</a>
<a name="ln515">		OS_DELAY(2000);</a>
<a name="ln516">		if ((AH_PRIVATE(ah)-&gt;ah_analog2GhzRev &amp; 0xF0) != AR_RAD2111_SREV_MAJOR) {</a>
<a name="ln517">			HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln518">			    &quot;%s: 2G Radio Chip Rev 0x%02X is not &quot;</a>
<a name="ln519">			    &quot;supported by this driver\n&quot;, __func__,</a>
<a name="ln520">			    AH_PRIVATE(ah)-&gt;ah_analog2GhzRev);</a>
<a name="ln521">			ecode = HAL_ENOTSUPP;</a>
<a name="ln522">			goto bad;</a>
<a name="ln523">		}</a>
<a name="ln524">	}</a>
<a name="ln525"> </a>
<a name="ln526">	ecode = ath_hal_eepromGet(ah, AR_EEP_REGDMN_0, &amp;eeval);</a>
<a name="ln527">	if (ecode != HAL_OK) {</a>
<a name="ln528">		HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln529">		    &quot;%s: cannot read regulatory domain from EEPROM\n&quot;,</a>
<a name="ln530">		    __func__);</a>
<a name="ln531">		goto bad;</a>
<a name="ln532">        }</a>
<a name="ln533">	AH_PRIVATE(ah)-&gt;ah_currentRD = eeval;</a>
<a name="ln534">	/* XXX record serial number */</a>
<a name="ln535"> </a>
<a name="ln536">	/*</a>
<a name="ln537">	 * Got everything we need now to setup the capabilities.</a>
<a name="ln538">	 */</a>
<a name="ln539">	if (!ar5212FillCapabilityInfo(ah)) {</a>
<a name="ln540">		HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln541">		    &quot;%s: failed ar5212FillCapabilityInfo\n&quot;, __func__);</a>
<a name="ln542">		ecode = HAL_EEREAD;</a>
<a name="ln543">		goto bad;</a>
<a name="ln544">	}</a>
<a name="ln545"> </a>
<a name="ln546">	if (!rf-&gt;attach(ah, &amp;ecode)) {</a>
<a name="ln547">		HALDEBUG(ah, HAL_DEBUG_ANY, &quot;%s: RF setup failed, status %u\n&quot;,</a>
<a name="ln548">		    __func__, ecode);</a>
<a name="ln549">		goto bad;</a>
<a name="ln550">	}</a>
<a name="ln551">	/*</a>
<a name="ln552">	 * Set noise floor adjust method; we arrange a</a>
<a name="ln553">	 * direct call instead of thunking.</a>
<a name="ln554">	 */</a>
<a name="ln555">	AH_PRIVATE(ah)-&gt;ah_getNfAdjust = ahp-&gt;ah_rfHal-&gt;getNfAdjust;</a>
<a name="ln556"> </a>
<a name="ln557">	/* Initialize gain ladder thermal calibration structure */</a>
<a name="ln558">	ar5212InitializeGainValues(ah);</a>
<a name="ln559"> </a>
<a name="ln560">	ecode = ath_hal_eepromGet(ah, AR_EEP_MACADDR, ahp-&gt;ah_macaddr);</a>
<a name="ln561">	if (ecode != HAL_OK) {</a>
<a name="ln562">		HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln563">		    &quot;%s: error getting mac address from EEPROM\n&quot;, __func__);</a>
<a name="ln564">		goto bad;</a>
<a name="ln565">        }</a>
<a name="ln566"> </a>
<a name="ln567">	ar5212AniSetup(ah);</a>
<a name="ln568">	/* Setup of Radar/AR structures happens in ath_hal_initchannels*/</a>
<a name="ln569">	ar5212InitNfCalHistBuffer(ah);</a>
<a name="ln570"> </a>
<a name="ln571">	/* XXX EAR stuff goes here */</a>
<a name="ln572"> </a>
<a name="ln573">	HALDEBUG(ah, HAL_DEBUG_ATTACH, &quot;%s: return\n&quot;, __func__);</a>
<a name="ln574"> </a>
<a name="ln575">	return ah;</a>
<a name="ln576"> </a>
<a name="ln577">bad:</a>
<a name="ln578">	if (ahp)</a>
<a name="ln579">		ar5212Detach((struct ath_hal *) ahp);</a>
<a name="ln580">	if (status)</a>
<a name="ln581">		*status = ecode;</a>
<a name="ln582">	return AH_NULL;</a>
<a name="ln583">#undef AH_EEPROM_PROTECT</a>
<a name="ln584">}</a>
<a name="ln585"> </a>
<a name="ln586">void</a>
<a name="ln587">ar5212Detach(struct ath_hal *ah)</a>
<a name="ln588">{</a>
<a name="ln589">	HALDEBUG(ah, HAL_DEBUG_ATTACH, &quot;%s:\n&quot;, __func__);</a>
<a name="ln590"> </a>
<a name="ln591">	HALASSERT(ah != AH_NULL);</a>
<a name="ln592">	HALASSERT(ah-&gt;ah_magic == AR5212_MAGIC);</a>
<a name="ln593"> </a>
<a name="ln594">	ar5212AniDetach(ah);</a>
<a name="ln595">	ar5212RfDetach(ah);</a>
<a name="ln596">	ar5212Disable(ah);</a>
<a name="ln597">	ar5212SetPowerMode(ah, HAL_PM_FULL_SLEEP, AH_TRUE);</a>
<a name="ln598"> </a>
<a name="ln599">	ath_hal_eepromDetach(ah);</a>
<a name="ln600">	ath_hal_free(ah);</a>
<a name="ln601">}</a>
<a name="ln602"> </a>
<a name="ln603">HAL_BOOL</a>
<a name="ln604">ar5212ChipTest(struct ath_hal *ah)</a>
<a name="ln605">{</a>
<a name="ln606">	uint32_t regAddr[2] = { AR_STA_ID0, AR_PHY_BASE+(8 &lt;&lt; 2) };</a>
<a name="ln607">	uint32_t regHold[2];</a>
<a name="ln608">	uint32_t patternData[4] =</a>
<a name="ln609">	    { 0x55555555, 0xaaaaaaaa, 0x66666666, 0x99999999 };</a>
<a name="ln610">	int i, j;</a>
<a name="ln611"> </a>
<a name="ln612">	/* Test PHY &amp; MAC registers */</a>
<a name="ln613">	for (i = 0; i &lt; 2; i++) {</a>
<a name="ln614">		uint32_t addr = regAddr[i];</a>
<a name="ln615">		uint32_t wrData, rdData;</a>
<a name="ln616"> </a>
<a name="ln617">		regHold[i] = OS_REG_READ(ah, addr);</a>
<a name="ln618">		for (j = 0; j &lt; 0x100; j++) {</a>
<a name="ln619">			wrData = (j &lt;&lt; 16) | j;</a>
<a name="ln620">			OS_REG_WRITE(ah, addr, wrData);</a>
<a name="ln621">			rdData = OS_REG_READ(ah, addr);</a>
<a name="ln622">			if (rdData != wrData) {</a>
<a name="ln623">				HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln624">&quot;%s: address test failed addr: 0x%08x - wr:0x%08x != rd:0x%08x\n&quot;,</a>
<a name="ln625">				__func__, addr, wrData, rdData);</a>
<a name="ln626">				return AH_FALSE;</a>
<a name="ln627">			}</a>
<a name="ln628">		}</a>
<a name="ln629">		for (j = 0; j &lt; 4; j++) {</a>
<a name="ln630">			wrData = patternData[j];</a>
<a name="ln631">			OS_REG_WRITE(ah, addr, wrData);</a>
<a name="ln632">			rdData = OS_REG_READ(ah, addr);</a>
<a name="ln633">			if (wrData != rdData) {</a>
<a name="ln634">				HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln635">&quot;%s: address test failed addr: 0x%08x - wr:0x%08x != rd:0x%08x\n&quot;,</a>
<a name="ln636">					__func__, addr, wrData, rdData);</a>
<a name="ln637">				return AH_FALSE;</a>
<a name="ln638">			}</a>
<a name="ln639">		}</a>
<a name="ln640">		OS_REG_WRITE(ah, regAddr[i], regHold[i]);</a>
<a name="ln641">	}</a>
<a name="ln642">	OS_DELAY(100);</a>
<a name="ln643">	return AH_TRUE;</a>
<a name="ln644">}</a>
<a name="ln645"> </a>
<a name="ln646">/*</a>
<a name="ln647"> * Store the channel edges for the requested operational mode</a>
<a name="ln648"> */</a>
<a name="ln649">HAL_BOOL</a>
<a name="ln650">ar5212GetChannelEdges(struct ath_hal *ah,</a>
<a name="ln651">	uint16_t flags, uint16_t *low, uint16_t *high)</a>
<a name="ln652">{</a>
<a name="ln653">	if (flags &amp; IEEE80211_CHAN_5GHZ) {</a>
<a name="ln654">		*low = 4915;</a>
<a name="ln655">		*high = 6100;</a>
<a name="ln656">		return AH_TRUE;</a>
<a name="ln657">	}</a>
<a name="ln658">	if ((flags &amp; IEEE80211_CHAN_2GHZ) &amp;&amp;</a>
<a name="ln659">	    (ath_hal_eepromGetFlag(ah, AR_EEP_BMODE) ||</a>
<a name="ln660">	     ath_hal_eepromGetFlag(ah, AR_EEP_GMODE))) {</a>
<a name="ln661">		*low = 2312;</a>
<a name="ln662">		*high = 2732;</a>
<a name="ln663">		return AH_TRUE;</a>
<a name="ln664">	}</a>
<a name="ln665">	return AH_FALSE;</a>
<a name="ln666">}</a>
<a name="ln667"> </a>
<a name="ln668">/*</a>
<a name="ln669"> * Disable PLL when in L0s as well as receiver clock when in L1.</a>
<a name="ln670"> * This power saving option must be enabled through the Serdes.</a>
<a name="ln671"> *</a>
<a name="ln672"> * Programming the Serdes must go through the same 288 bit serial shift</a>
<a name="ln673"> * register as the other analog registers.  Hence the 9 writes.</a>
<a name="ln674"> *</a>
<a name="ln675"> * XXX Clean up the magic numbers.</a>
<a name="ln676"> */</a>
<a name="ln677">static void</a>
<a name="ln678">ar5212ConfigPCIE(struct ath_hal *ah, HAL_BOOL restore, HAL_BOOL power_off)</a>
<a name="ln679">{</a>
<a name="ln680">	OS_REG_WRITE(ah, AR_PCIE_SERDES, 0x9248fc00);</a>
<a name="ln681">	OS_REG_WRITE(ah, AR_PCIE_SERDES, 0x24924924);</a>
<a name="ln682"> </a>
<a name="ln683">	/* RX shut off when elecidle is asserted */</a>
<a name="ln684">	OS_REG_WRITE(ah, AR_PCIE_SERDES, 0x28000039);</a>
<a name="ln685">	OS_REG_WRITE(ah, AR_PCIE_SERDES, 0x53160824);</a>
<a name="ln686">	OS_REG_WRITE(ah, AR_PCIE_SERDES, 0xe5980579);</a>
<a name="ln687">                                                                                           </a>
<a name="ln688">	/* Shut off PLL and CLKREQ active in L1 */</a>
<a name="ln689">	OS_REG_WRITE(ah, AR_PCIE_SERDES, 0x001defff);</a>
<a name="ln690">	OS_REG_WRITE(ah, AR_PCIE_SERDES, 0x1aaabe40);</a>
<a name="ln691">	OS_REG_WRITE(ah, AR_PCIE_SERDES, 0xbe105554);</a>
<a name="ln692">	OS_REG_WRITE(ah, AR_PCIE_SERDES, 0x000e3007);</a>
<a name="ln693">                                                                                           </a>
<a name="ln694">	/* Load the new settings */</a>
<a name="ln695">	OS_REG_WRITE(ah, AR_PCIE_SERDES2, 0x00000000);</a>
<a name="ln696">}</a>
<a name="ln697"> </a>
<a name="ln698">static void</a>
<a name="ln699">ar5212DisablePCIE(struct ath_hal *ah)</a>
<a name="ln700">{</a>
<a name="ln701">	/* NB: fill in for 9100 */</a>
<a name="ln702">}</a>
<a name="ln703"> </a>
<a name="ln704">/*</a>
<a name="ln705"> * Fill all software cached or static hardware state information.</a>
<a name="ln706"> * Return failure if capabilities are to come from EEPROM and</a>
<a name="ln707"> * cannot be read.</a>
<a name="ln708"> */</a>
<a name="ln709">HAL_BOOL</a>
<a name="ln710">ar5212FillCapabilityInfo(struct ath_hal *ah)</a>
<a name="ln711">{</a>
<a name="ln712">#define	AR_KEYTABLE_SIZE	128</a>
<a name="ln713">#define	IS_GRIFFIN_LITE(ah) \</a>
<a name="ln714">    (AH_PRIVATE(ah)-&gt;ah_macVersion == AR_SREV_VERSION_GRIFFIN &amp;&amp; \</a>
<a name="ln715">     AH_PRIVATE(ah)-&gt;ah_macRev == AR_SREV_GRIFFIN_LITE)</a>
<a name="ln716">#define	IS_COBRA(ah) \</a>
<a name="ln717">    (AH_PRIVATE(ah)-&gt;ah_macVersion == AR_SREV_VERSION_COBRA)</a>
<a name="ln718">#define IS_2112(ah) \</a>
<a name="ln719">	((AH_PRIVATE(ah)-&gt;ah_analog5GhzRev &amp; 0xF0) == AR_RAD2112_SREV_MAJOR)</a>
<a name="ln720"> </a>
<a name="ln721">	struct ath_hal_private *ahpriv = AH_PRIVATE(ah);</a>
<a name="ln722">	HAL_CAPABILITIES *pCap = &amp;ahpriv-&gt;ah_caps;</a>
<a name="ln723">	uint16_t capField, val;</a>
<a name="ln724"> </a>
<a name="ln725">	/* Read the capability EEPROM location */</a>
<a name="ln726">	if (ath_hal_eepromGet(ah, AR_EEP_OPCAP, &amp;capField) != HAL_OK) {</a>
<a name="ln727">		HALDEBUG(ah, HAL_DEBUG_ANY,</a>
<a name="ln728">		    &quot;%s: unable to read caps from eeprom\n&quot;, __func__);</a>
<a name="ln729">		return AH_FALSE;</a>
<a name="ln730">	}</a>
<a name="ln731">	if (IS_2112(ah))</a>
<a name="ln732">		ath_hal_eepromSet(ah, AR_EEP_AMODE, AH_FALSE);</a>
<a name="ln733">	if (capField == 0 &amp;&amp; IS_GRIFFIN_LITE(ah)) {</a>
<a name="ln734">		/*</a>
<a name="ln735">		 * For griffin-lite cards with unprogrammed capabilities.</a>
<a name="ln736">		 */</a>
<a name="ln737">		ath_hal_eepromSet(ah, AR_EEP_COMPRESS, AH_FALSE);</a>
<a name="ln738">		ath_hal_eepromSet(ah, AR_EEP_FASTFRAME, AH_FALSE);</a>
<a name="ln739">		ath_hal_eepromSet(ah, AR_EEP_TURBO5DISABLE, AH_TRUE);</a>
<a name="ln740">		ath_hal_eepromSet(ah, AR_EEP_TURBO2DISABLE, AH_TRUE);</a>
<a name="ln741">		HALDEBUG(ah, HAL_DEBUG_ATTACH,</a>
<a name="ln742">		    &quot;%s: override caps for griffin-lite, now 0x%x (+!turbo)\n&quot;,</a>
<a name="ln743">		    __func__, capField);</a>
<a name="ln744">	}</a>
<a name="ln745"> </a>
<a name="ln746">	/* Modify reg domain on newer cards that need to work with older sw */</a>
<a name="ln747">	if (ahpriv-&gt;ah_opmode != HAL_M_HOSTAP &amp;&amp;</a>
<a name="ln748">	    ahpriv-&gt;ah_subvendorid == AR_SUBVENDOR_ID_NEW_A) {</a>
<a name="ln749">		if (ahpriv-&gt;ah_currentRD == 0x64 ||</a>
<a name="ln750">		    ahpriv-&gt;ah_currentRD == 0x65)</a>
<a name="ln751">			ahpriv-&gt;ah_currentRD += 5;</a>
<a name="ln752">		else if (ahpriv-&gt;ah_currentRD == 0x41)</a>
<a name="ln753">			ahpriv-&gt;ah_currentRD = 0x43;</a>
<a name="ln754">		HALDEBUG(ah, HAL_DEBUG_ATTACH, &quot;%s: regdomain mapped to 0x%x\n&quot;,</a>
<a name="ln755">		    __func__, ahpriv-&gt;ah_currentRD);</a>
<a name="ln756">	}</a>
<a name="ln757"> </a>
<a name="ln758">	if (AH_PRIVATE(ah)-&gt;ah_macVersion == AR_SREV_2417 ||</a>
<a name="ln759">	    AH_PRIVATE(ah)-&gt;ah_macVersion == AR_SREV_2425) {</a>
<a name="ln760">		HALDEBUG(ah, HAL_DEBUG_ATTACH,</a>
<a name="ln761">		    &quot;%s: enable Bmode and disable turbo for Swan/Nala\n&quot;,</a>
<a name="ln762">		    __func__);</a>
<a name="ln763">		ath_hal_eepromSet(ah, AR_EEP_BMODE, AH_TRUE);</a>
<a name="ln764">		ath_hal_eepromSet(ah, AR_EEP_COMPRESS, AH_FALSE);</a>
<a name="ln765">		ath_hal_eepromSet(ah, AR_EEP_FASTFRAME, AH_FALSE);</a>
<a name="ln766">		ath_hal_eepromSet(ah, AR_EEP_TURBO5DISABLE, AH_TRUE);</a>
<a name="ln767">		ath_hal_eepromSet(ah, AR_EEP_TURBO2DISABLE, AH_TRUE);</a>
<a name="ln768">	}</a>
<a name="ln769"> </a>
<a name="ln770">	/* Construct wireless mode from EEPROM */</a>
<a name="ln771">	pCap-&gt;halWirelessModes = 0;</a>
<a name="ln772">	if (ath_hal_eepromGetFlag(ah, AR_EEP_AMODE)) {</a>
<a name="ln773">		pCap-&gt;halWirelessModes |= HAL_MODE_11A;</a>
<a name="ln774">		if (!ath_hal_eepromGetFlag(ah, AR_EEP_TURBO5DISABLE))</a>
<a name="ln775">			pCap-&gt;halWirelessModes |= HAL_MODE_TURBO;</a>
<a name="ln776">	}</a>
<a name="ln777">	if (ath_hal_eepromGetFlag(ah, AR_EEP_BMODE))</a>
<a name="ln778">		pCap-&gt;halWirelessModes |= HAL_MODE_11B;</a>
<a name="ln779">	if (ath_hal_eepromGetFlag(ah, AR_EEP_GMODE) &amp;&amp;</a>
<a name="ln780">	    ahpriv-&gt;ah_subvendorid != AR_SUBVENDOR_ID_NOG) {</a>
<a name="ln781">		pCap-&gt;halWirelessModes |= HAL_MODE_11G;</a>
<a name="ln782">		if (!ath_hal_eepromGetFlag(ah, AR_EEP_TURBO2DISABLE))</a>
<a name="ln783">			pCap-&gt;halWirelessModes |= HAL_MODE_108G;</a>
<a name="ln784">	}</a>
<a name="ln785"> </a>
<a name="ln786">	pCap-&gt;halLow2GhzChan = 2312;</a>
<a name="ln787">	/* XXX 2417 too? */</a>
<a name="ln788">	if (IS_RAD5112_ANY(ah) || IS_5413(ah) || IS_2425(ah) ||  IS_2417(ah))</a>
<a name="ln789">		pCap-&gt;halHigh2GhzChan = 2500;</a>
<a name="ln790">	else</a>
<a name="ln791">		pCap-&gt;halHigh2GhzChan = 2732;</a>
<a name="ln792"> </a>
<a name="ln793">	/*</a>
<a name="ln794">	 * For AR5111 version &lt; 4, the lowest centre frequency supported is</a>
<a name="ln795">	 * 5130MHz.  For AR5111 version 4, the 4.9GHz channels are supported</a>
<a name="ln796">	 * but only in 10MHz increments.</a>
<a name="ln797">	 *</a>
<a name="ln798">	 * In addition, the programming method is wrong - it uses the IEEE</a>
<a name="ln799">	 * channel number to calculate the frequency, rather than the</a>
<a name="ln800">	 * channel centre.  Since half/quarter rates re-use some of the</a>
<a name="ln801">	 * 5GHz channel IEEE numbers, this will result in a badly programmed</a>
<a name="ln802">	 * synth.</a>
<a name="ln803">	 *</a>
<a name="ln804">	 * Until the relevant support is written, just limit lower frequency</a>
<a name="ln805">	 * support for AR5111 so things aren't incorrectly programmed.</a>
<a name="ln806">	 *</a>
<a name="ln807">	 * XXX It's also possible this code doesn't correctly limit the</a>
<a name="ln808">	 * centre frequencies of potential channels; this is very important</a>
<a name="ln809">	 * for half/quarter rate!</a>
<a name="ln810">	 */</a>
<a name="ln811">	if (AH_RADIO_MAJOR(ah) == AR_RAD5111_SREV_MAJOR) {</a>
<a name="ln812">		pCap-&gt;halLow5GhzChan = 5120; /* XXX lowest centre = 5130MHz */</a>
<a name="ln813">	} else {</a>
<a name="ln814">		pCap-&gt;halLow5GhzChan = 4915;</a>
<a name="ln815">	}</a>
<a name="ln816">	pCap-&gt;halHigh5GhzChan = 6100;</a>
<a name="ln817"> </a>
<a name="ln818">	pCap-&gt;halCipherCkipSupport = AH_FALSE;</a>
<a name="ln819">	pCap-&gt;halCipherTkipSupport = AH_TRUE;</a>
<a name="ln820">	pCap-&gt;halCipherAesCcmSupport =</a>
<a name="ln821">		(ath_hal_eepromGetFlag(ah, AR_EEP_AES) &amp;&amp;</a>
<a name="ln822">		 ((AH_PRIVATE(ah)-&gt;ah_macVersion &gt; AR_SREV_VERSION_VENICE) ||</a>
<a name="ln823">		  ((AH_PRIVATE(ah)-&gt;ah_macVersion == AR_SREV_VERSION_VENICE) &amp;&amp;</a>
<a name="ln824">		   (AH_PRIVATE(ah)-&gt;ah_macRev &gt;= AR_SREV_VERSION_OAHU))));</a>
<a name="ln825"> </a>
<a name="ln826">	pCap-&gt;halMicCkipSupport    = AH_FALSE;</a>
<a name="ln827">	pCap-&gt;halMicTkipSupport    = AH_TRUE;</a>
<a name="ln828">	pCap-&gt;halMicAesCcmSupport  = ath_hal_eepromGetFlag(ah, AR_EEP_AES);</a>
<a name="ln829">	/*</a>
<a name="ln830">	 * Starting with Griffin TX+RX mic keys can be combined</a>
<a name="ln831">	 * in one key cache slot.</a>
<a name="ln832">	 */</a>
<a name="ln833">	if (AH_PRIVATE(ah)-&gt;ah_macVersion &gt;= AR_SREV_VERSION_GRIFFIN)</a>
<a name="ln834">		pCap-&gt;halTkipMicTxRxKeySupport = AH_TRUE;</a>
<a name="ln835">	else</a>
<a name="ln836">		pCap-&gt;halTkipMicTxRxKeySupport = AH_FALSE;</a>
<a name="ln837">	pCap-&gt;halChanSpreadSupport = AH_TRUE;</a>
<a name="ln838">	pCap-&gt;halSleepAfterBeaconBroken = AH_TRUE;</a>
<a name="ln839"> </a>
<a name="ln840">	if (ahpriv-&gt;ah_macRev &gt; 1 || IS_COBRA(ah)) {</a>
<a name="ln841">		pCap-&gt;halCompressSupport   =</a>
<a name="ln842">			ath_hal_eepromGetFlag(ah, AR_EEP_COMPRESS) &amp;&amp;</a>
<a name="ln843">			(pCap-&gt;halWirelessModes &amp; (HAL_MODE_11A|HAL_MODE_11G)) != 0;</a>
<a name="ln844">		pCap-&gt;halBurstSupport = ath_hal_eepromGetFlag(ah, AR_EEP_BURST);</a>
<a name="ln845">		pCap-&gt;halFastFramesSupport =</a>
<a name="ln846">			ath_hal_eepromGetFlag(ah, AR_EEP_FASTFRAME) &amp;&amp;</a>
<a name="ln847">			(pCap-&gt;halWirelessModes &amp; (HAL_MODE_11A|HAL_MODE_11G)) != 0;</a>
<a name="ln848">		pCap-&gt;halChapTuningSupport = AH_TRUE;</a>
<a name="ln849">		pCap-&gt;halTurboPrimeSupport = AH_TRUE;</a>
<a name="ln850">	}</a>
<a name="ln851">	pCap-&gt;halTurboGSupport = pCap-&gt;halWirelessModes &amp; HAL_MODE_108G;</a>
<a name="ln852"> </a>
<a name="ln853">	pCap-&gt;halPSPollBroken = AH_TRUE;	/* XXX fixed in later revs? */</a>
<a name="ln854">	pCap-&gt;halNumMRRetries = 4;		/* Hardware supports 4 MRR */</a>
<a name="ln855">	pCap-&gt;halNumTxMaps = 1;			/* Single TX ptr per descr */</a>
<a name="ln856">	pCap-&gt;halVEOLSupport = AH_TRUE;</a>
<a name="ln857">	pCap-&gt;halBssIdMaskSupport = AH_TRUE;</a>
<a name="ln858">	pCap-&gt;halMcastKeySrchSupport = AH_TRUE;</a>
<a name="ln859">	if ((ahpriv-&gt;ah_macVersion == AR_SREV_VERSION_VENICE &amp;&amp;</a>
<a name="ln860">	     ahpriv-&gt;ah_macRev == 8) ||</a>
<a name="ln861">	    ahpriv-&gt;ah_macVersion &gt; AR_SREV_VERSION_VENICE)</a>
<a name="ln862">		pCap-&gt;halTsfAddSupport = AH_TRUE;</a>
<a name="ln863"> </a>
<a name="ln864">	if (ath_hal_eepromGet(ah, AR_EEP_MAXQCU, &amp;val) == HAL_OK)</a>
<a name="ln865">		pCap-&gt;halTotalQueues = val;</a>
<a name="ln866">	else</a>
<a name="ln867">		pCap-&gt;halTotalQueues = HAL_NUM_TX_QUEUES;</a>
<a name="ln868"> </a>
<a name="ln869">	if (ath_hal_eepromGet(ah, AR_EEP_KCENTRIES, &amp;val) == HAL_OK)</a>
<a name="ln870">		pCap-&gt;halKeyCacheSize = val;</a>
<a name="ln871">	else</a>
<a name="ln872">		pCap-&gt;halKeyCacheSize = AR_KEYTABLE_SIZE;</a>
<a name="ln873"> </a>
<a name="ln874">	pCap-&gt;halChanHalfRate = AH_TRUE;</a>
<a name="ln875">	pCap-&gt;halChanQuarterRate = AH_TRUE;</a>
<a name="ln876"> </a>
<a name="ln877">	/*</a>
<a name="ln878">	 * RSSI uses the combined field; some 11n NICs may use</a>
<a name="ln879">	 * the control chain RSSI.</a>
<a name="ln880">	 */</a>
<a name="ln881">	pCap-&gt;halUseCombinedRadarRssi = AH_TRUE;</a>
<a name="ln882"> </a>
<a name="ln883">	if (ath_hal_eepromGetFlag(ah, AR_EEP_RFKILL) &amp;&amp;</a>
<a name="ln884">	    ath_hal_eepromGet(ah, AR_EEP_RFSILENT, &amp;ahpriv-&gt;ah_rfsilent) == HAL_OK) {</a>
<a name="ln885">		/* NB: enabled by default */</a>
<a name="ln886">		ahpriv-&gt;ah_rfkillEnabled = AH_TRUE;</a>
<a name="ln887">		pCap-&gt;halRfSilentSupport = AH_TRUE;</a>
<a name="ln888">	}</a>
<a name="ln889"> </a>
<a name="ln890">	/* NB: this is a guess, no one seems to know the answer */</a>
<a name="ln891">	ahpriv-&gt;ah_rxornIsFatal =</a>
<a name="ln892">	    (AH_PRIVATE(ah)-&gt;ah_macVersion &lt; AR_SREV_VERSION_VENICE);</a>
<a name="ln893"> </a>
<a name="ln894">	/* enable features that first appeared in Hainan */</a>
<a name="ln895">	if ((AH_PRIVATE(ah)-&gt;ah_macVersion == AR_SREV_VERSION_VENICE &amp;&amp;</a>
<a name="ln896">	     AH_PRIVATE(ah)-&gt;ah_macRev == AR_SREV_HAINAN) ||</a>
<a name="ln897">	    AH_PRIVATE(ah)-&gt;ah_macVersion &gt; AR_SREV_VERSION_VENICE) {</a>
<a name="ln898">		/* h/w phy counters */</a>
<a name="ln899">		pCap-&gt;halHwPhyCounterSupport = AH_TRUE;</a>
<a name="ln900">		/* bssid match disable */</a>
<a name="ln901">		pCap-&gt;halBssidMatchSupport = AH_TRUE;</a>
<a name="ln902">	}</a>
<a name="ln903"> </a>
<a name="ln904">	pCap-&gt;halRxTstampPrecision = 15;</a>
<a name="ln905">	pCap-&gt;halTxTstampPrecision = 16;</a>
<a name="ln906">	pCap-&gt;halIntrMask = HAL_INT_COMMON</a>
<a name="ln907">			| HAL_INT_RX</a>
<a name="ln908">			| HAL_INT_TX</a>
<a name="ln909">			| HAL_INT_FATAL</a>
<a name="ln910">			| HAL_INT_BNR</a>
<a name="ln911">			| HAL_INT_BMISC</a>
<a name="ln912">			;</a>
<a name="ln913">	if (AH_PRIVATE(ah)-&gt;ah_macVersion &lt; AR_SREV_VERSION_GRIFFIN)</a>
<a name="ln914">		pCap-&gt;halIntrMask &amp;= ~HAL_INT_TBTT;</a>
<a name="ln915"> </a>
<a name="ln916">	pCap-&gt;hal4kbSplitTransSupport = AH_TRUE;</a>
<a name="ln917">	pCap-&gt;halHasRxSelfLinkedTail = AH_TRUE;</a>
<a name="ln918"> </a>
<a name="ln919">	return AH_TRUE;</a>
<a name="ln920">#undef IS_COBRA</a>
<a name="ln921">#undef IS_GRIFFIN_LITE</a>
<a name="ln922">#undef AR_KEYTABLE_SIZE</a>
<a name="ln923">}</a>
<a name="ln924"> </a>
<a name="ln925">static const char*</a>
<a name="ln926">ar5212Probe(uint16_t vendorid, uint16_t devid)</a>
<a name="ln927">{</a>
<a name="ln928">	if (vendorid == ATHEROS_VENDOR_ID ||</a>
<a name="ln929">	    vendorid == ATHEROS_3COM_VENDOR_ID ||</a>
<a name="ln930">	    vendorid == ATHEROS_3COM2_VENDOR_ID) {</a>
<a name="ln931">		switch (devid) {</a>
<a name="ln932">		case AR5212_FPGA:</a>
<a name="ln933">			return &quot;Atheros 5212 (FPGA)&quot;;</a>
<a name="ln934">		case AR5212_DEVID:</a>
<a name="ln935">		case AR5212_DEVID_IBM:</a>
<a name="ln936">		case AR5212_DEFAULT:</a>
<a name="ln937">			return &quot;Atheros 5212&quot;;</a>
<a name="ln938">		case AR5212_AR2413:</a>
<a name="ln939">			return &quot;Atheros 2413&quot;;</a>
<a name="ln940">		case AR5212_AR2417:</a>
<a name="ln941">			return &quot;Atheros 2417&quot;;</a>
<a name="ln942">		case AR5212_AR5413:</a>
<a name="ln943">			return &quot;Atheros 5413&quot;;</a>
<a name="ln944">		case AR5212_AR5424:</a>
<a name="ln945">			return &quot;Atheros 5424/2424&quot;;</a>
<a name="ln946">		}</a>
<a name="ln947">	}</a>
<a name="ln948">	return AH_NULL;</a>
<a name="ln949">}</a>
<a name="ln950">AH_CHIP(AR5212, ar5212Probe, ar5212Attach);</a>

</code></pre>
<div class="balloon" rel="490"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the subsequent code fragment.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
