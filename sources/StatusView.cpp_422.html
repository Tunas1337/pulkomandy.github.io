
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>StatusView.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">Open Tracker License</a>
<a name="ln3"> </a>
<a name="ln4">Terms and Conditions</a>
<a name="ln5"> </a>
<a name="ln6">Copyright (c) 1991-2000, Be Incorporated. All rights reserved.</a>
<a name="ln7"> </a>
<a name="ln8">Permission is hereby granted, free of charge, to any person obtaining a copy of</a>
<a name="ln9">this software and associated documentation files (the &quot;Software&quot;), to deal in</a>
<a name="ln10">the Software without restriction, including without limitation the rights to</a>
<a name="ln11">use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies</a>
<a name="ln12">of the Software, and to permit persons to whom the Software is furnished to do</a>
<a name="ln13">so, subject to the following conditions:</a>
<a name="ln14"> </a>
<a name="ln15">The above copyright notice and this permission notice applies to all licensees</a>
<a name="ln16">and shall be included in all copies or substantial portions of the Software.</a>
<a name="ln17"> </a>
<a name="ln18">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</a>
<a name="ln19">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF TITLE, MERCHANTABILITY,</a>
<a name="ln20">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL</a>
<a name="ln21">BE INCORPORATED BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN</a>
<a name="ln22">AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION</a>
<a name="ln23">WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</a>
<a name="ln24"> </a>
<a name="ln25">Except as contained in this notice, the name of Be Incorporated shall not be</a>
<a name="ln26">used in advertising or otherwise to promote the sale, use or other dealings in</a>
<a name="ln27">this Software without prior written authorization from Be Incorporated.</a>
<a name="ln28"> </a>
<a name="ln29">Tracker(TM), Be(R), BeOS(R), and BeIA(TM) are trademarks or registered</a>
<a name="ln30">trademarks of Be Incorporated in the United States and other countries. Other</a>
<a name="ln31">brand product names are registered trademarks or trademarks of their respective</a>
<a name="ln32">holders.</a>
<a name="ln33">All rights reserved.</a>
<a name="ln34">*/</a>
<a name="ln35"> </a>
<a name="ln36"> </a>
<a name="ln37">#include &quot;StatusView.h&quot;</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;errno.h&gt;</a>
<a name="ln40">#include &lt;stdio.h&gt;</a>
<a name="ln41">#include &lt;string.h&gt;</a>
<a name="ln42">#include &lt;time.h&gt;</a>
<a name="ln43">#include &lt;unistd.h&gt;</a>
<a name="ln44">#include &lt;algorithm&gt;</a>
<a name="ln45"> </a>
<a name="ln46">#include &lt;fs_index.h&gt;</a>
<a name="ln47">#include &lt;fs_info.h&gt;</a>
<a name="ln48"> </a>
<a name="ln49">#include &lt;Application.h&gt;</a>
<a name="ln50">#include &lt;Beep.h&gt;</a>
<a name="ln51">#include &lt;Bitmap.h&gt;</a>
<a name="ln52">#include &lt;Catalog.h&gt;</a>
<a name="ln53">#include &lt;ControlLook.h&gt;</a>
<a name="ln54">#include &lt;Debug.h&gt;</a>
<a name="ln55">#include &lt;Directory.h&gt;</a>
<a name="ln56">#include &lt;FindDirectory.h&gt;</a>
<a name="ln57">#include &lt;Locale.h&gt;</a>
<a name="ln58">#include &lt;MenuItem.h&gt;</a>
<a name="ln59">#include &lt;NodeInfo.h&gt;</a>
<a name="ln60">#include &lt;NodeMonitor.h&gt;</a>
<a name="ln61">#include &lt;Path.h&gt;</a>
<a name="ln62">#include &lt;PopUpMenu.h&gt;</a>
<a name="ln63">#include &lt;Roster.h&gt;</a>
<a name="ln64">#include &lt;Screen.h&gt;</a>
<a name="ln65">#include &lt;Volume.h&gt;</a>
<a name="ln66">#include &lt;VolumeRoster.h&gt;</a>
<a name="ln67">#include &lt;Window.h&gt;</a>
<a name="ln68"> </a>
<a name="ln69">#include &quot;icons.h&quot;</a>
<a name="ln70"> </a>
<a name="ln71">#include &quot;BarApp.h&quot;</a>
<a name="ln72">#include &quot;DeskbarUtils.h&quot;</a>
<a name="ln73">#include &quot;ResourceSet.h&quot;</a>
<a name="ln74">#include &quot;StatusViewShelf.h&quot;</a>
<a name="ln75">#include &quot;TimeView.h&quot;</a>
<a name="ln76"> </a>
<a name="ln77"> </a>
<a name="ln78">#ifdef DB_ADDONS</a>
<a name="ln79">// Add-on support</a>
<a name="ln80">//</a>
<a name="ln81">// Item - internal item list (node, eref, etc)</a>
<a name="ln82">// Icon - physical replicant handed to the DeskbarClass class</a>
<a name="ln83">// AddOn - attribute based add-on</a>
<a name="ln84"> </a>
<a name="ln85">const char* const kInstantiateItemCFunctionName = &quot;instantiate_deskbar_item&quot;;</a>
<a name="ln86">const char* const kInstantiateEntryCFunctionName = &quot;instantiate_deskbar_entry&quot;;</a>
<a name="ln87">const char* const kReplicantSettingsFile = &quot;replicants&quot;;</a>
<a name="ln88">const char* const kReplicantPathField = &quot;replicant_path&quot;;</a>
<a name="ln89"> </a>
<a name="ln90">float gMinimumWindowWidth = kGutter + kMinimumTrayWidth + kDragRegionWidth;</a>
<a name="ln91">float gMaximumWindowWidth = gMinimumWindowWidth * 2;</a>
<a name="ln92"> </a>
<a name="ln93"> </a>
<a name="ln94">static void</a>
<a name="ln95">DumpItem(DeskbarItemInfo* item)</a>
<a name="ln96">{</a>
<a name="ln97">	printf(&quot;is addon: %i, id: %&quot; B_PRId32 &quot;\n&quot;, item-&gt;isAddOn, item-&gt;id);</a>
<a name="ln98">	printf(&quot;entry_ref:  %&quot; B_PRIdDEV &quot;, %&quot; B_PRIdINO &quot;, %s\n&quot;,</a>
<a name="ln99">		item-&gt;entryRef.device, item-&gt;entryRef.directory, item-&gt;entryRef.name);</a>
<a name="ln100">	printf(&quot;node_ref:  %&quot; B_PRIdDEV &quot;, %&quot; B_PRIdINO &quot;\n&quot;, item-&gt;nodeRef.device,</a>
<a name="ln101">		item-&gt;nodeRef.node);</a>
<a name="ln102">}</a>
<a name="ln103"> </a>
<a name="ln104"> </a>
<a name="ln105">static void</a>
<a name="ln106">DumpList(BList* itemlist)</a>
<a name="ln107">{</a>
<a name="ln108">	int32 count = itemlist-&gt;CountItems() - 1;</a>
<a name="ln109">	if (count &lt; 0) {</a>
<a name="ln110">		printf(&quot;no items in list\n&quot;);</a>
<a name="ln111">		return;</a>
<a name="ln112">	}</a>
<a name="ln113">	for (int32 i = count; i &gt;= 0; i--) {</a>
<a name="ln114">		DeskbarItemInfo* item = (DeskbarItemInfo*)itemlist-&gt;ItemAt(i);</a>
<a name="ln115">		if (!item)</a>
<a name="ln116">			continue;</a>
<a name="ln117"> </a>
<a name="ln118">		DumpItem(item);</a>
<a name="ln119">	}</a>
<a name="ln120">}</a>
<a name="ln121">#endif	/* DB_ADDONS */</a>
<a name="ln122"> </a>
<a name="ln123"> </a>
<a name="ln124">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln125">#define B_TRANSLATION_CONTEXT &quot;Tray&quot;</a>
<a name="ln126"> </a>
<a name="ln127">// don't change the name of this view to anything other than &quot;Status&quot;!</a>
<a name="ln128"> </a>
<a name="ln129">TReplicantTray::TReplicantTray(TBarView* parent, bool vertical)</a>
<a name="ln130">	:</a>
<a name="ln131">	BView(BRect(0, 0, 1, 1), &quot;Status&quot;, B_FOLLOW_LEFT | B_FOLLOW_TOP,</a>
<a name="ln132">		B_WILL_DRAW | B_FRAME_EVENTS),</a>
<a name="ln133">	fTime(NULL),</a>
<a name="ln134">	fBarView(parent),</a>
<a name="ln135">	fShelf(new TReplicantShelf(this)),</a>
<a name="ln136">	fMultiRowMode(vertical),</a>
<a name="ln137">	fAlignmentSupport(false)</a>
<a name="ln138">{</a>
<a name="ln139">	fMaxReplicantHeight = std::max(kMinReplicantHeight,</a>
<a name="ln140">		floorf(kMinReplicantHeight * be_plain_font-&gt;Size() / 12));</a>
<a name="ln141">	// TODO: depends on window size... (so use something like</a>
<a name="ln142">	// max(129, height * 3), and restrict the minimum window width for it)</a>
<a name="ln143">	fMaxReplicantWidth = 129;</a>
<a name="ln144"> </a>
<a name="ln145">	fMinTrayHeight = kGutter + fMaxReplicantHeight + kGutter;</a>
<a name="ln146">	if (vertical)</a>
<a name="ln147">		fMinimumTrayWidth = gMinimumWindowWidth - kGutter - kDragRegionWidth;</a>
<a name="ln148">	else</a>
<a name="ln149">		fMinimumTrayWidth = kMinimumTrayWidth;</a>
<a name="ln150"> </a>
<a name="ln151">	// Create the time view</a>
<a name="ln152">	fTime = new TTimeView(fMinimumTrayWidth, fMaxReplicantHeight - 1.0);</a>
<a name="ln153">}</a>
<a name="ln154"> </a>
<a name="ln155"> </a>
<a name="ln156">TReplicantTray::~TReplicantTray()</a>
<a name="ln157">{</a>
<a name="ln158">	delete fShelf;</a>
<a name="ln159">	delete fTime;</a>
<a name="ln160">}</a>
<a name="ln161"> </a>
<a name="ln162"> </a>
<a name="ln163">void</a>
<a name="ln164">TReplicantTray::AttachedToWindow()</a>
<a name="ln165">{</a>
<a name="ln166">	BView::AttachedToWindow();</a>
<a name="ln167"> </a>
<a name="ln168">	if (be_control_look != NULL) {</a>
<a name="ln169">		AdoptParentColors();</a>
<a name="ln170">	} else {</a>
<a name="ln171">		SetViewUIColor(B_MENU_BACKGROUND_COLOR,	B_DARKEN_1_TINT);</a>
<a name="ln172">	}</a>
<a name="ln173">	SetDrawingMode(B_OP_COPY);</a>
<a name="ln174"> </a>
<a name="ln175">	Window()-&gt;SetPulseRate(1000000);</a>
<a name="ln176"> </a>
<a name="ln177">	clock_settings* clock = ((TBarApp*)be_app)-&gt;ClockSettings();</a>
<a name="ln178">	fTime-&gt;SetShowSeconds(clock-&gt;showSeconds);</a>
<a name="ln179">	fTime-&gt;SetShowDayOfWeek(clock-&gt;showDayOfWeek);</a>
<a name="ln180">	fTime-&gt;SetShowTimeZone(clock-&gt;showTimeZone);</a>
<a name="ln181"> </a>
<a name="ln182">	AddChild(fTime);</a>
<a name="ln183"> </a>
<a name="ln184">	fTime-&gt;MoveTo(Bounds().right - fTime-&gt;Bounds().Width() - kTrayPadding, 2);</a>
<a name="ln185">	fTime-&gt;SetOrientation(fMultiRowMode);</a>
<a name="ln186"> </a>
<a name="ln187">	if (!((TBarApp*)be_app)-&gt;Settings()-&gt;showClock)</a>
<a name="ln188">		fTime-&gt;Hide();</a>
<a name="ln189"> </a>
<a name="ln190">#ifdef DB_ADDONS</a>
<a name="ln191">	// load addons and rehydrate archives</a>
<a name="ln192">#if !defined(HAIKU_TARGET_PLATFORM_LIBBE_TEST)</a>
<a name="ln193">	InitAddOnSupport();</a>
<a name="ln194">#endif</a>
<a name="ln195">#endif</a>
<a name="ln196">	ResizeToPreferred();</a>
<a name="ln197">}</a>
<a name="ln198"> </a>
<a name="ln199"> </a>
<a name="ln200">void</a>
<a name="ln201">TReplicantTray::DetachedFromWindow()</a>
<a name="ln202">{</a>
<a name="ln203">#ifdef DB_ADDONS</a>
<a name="ln204">	// clean up add-on support</a>
<a name="ln205">#if !defined(HAIKU_TARGET_PLATFORM_LIBBE_TEST)</a>
<a name="ln206">	DeleteAddOnSupport();</a>
<a name="ln207">#endif</a>
<a name="ln208">#endif</a>
<a name="ln209">	BView::DetachedFromWindow();</a>
<a name="ln210">}</a>
<a name="ln211"> </a>
<a name="ln212"> </a>
<a name="ln213">/*! Width is set to a minimum of kMinimumReplicantCount by kMaxReplicantWidth</a>
<a name="ln214">	if not in multirowmode and greater than kMinimumReplicantCount</a>
<a name="ln215">	the width should be calculated based on the actual replicant widths</a>
<a name="ln216">*/</a>
<a name="ln217">void</a>
<a name="ln218">TReplicantTray::GetPreferredSize(float* preferredWidth, float* preferredHeight)</a>
<a name="ln219">{</a>
<a name="ln220">	float width = 0;</a>
<a name="ln221">	float height = fMinTrayHeight;</a>
<a name="ln222"> </a>
<a name="ln223">	if (fMultiRowMode) {</a>
<a name="ln224">		width = static_cast&lt;TBarApp*&gt;(be_app)-&gt;Settings()-&gt;width</a>
<a name="ln225">			- kDragWidth - kGutter;</a>
<a name="ln226">		if (fRightBottomReplicant.IsValid())</a>
<a name="ln227">			height = fRightBottomReplicant.bottom;</a>
<a name="ln228">		else if (ReplicantCount() &gt; 0) {</a>
<a name="ln229">			// The height will be uniform for the number of rows necessary</a>
<a name="ln230">			// to show all the replicants and gutters.</a>
<a name="ln231">			int32 rowCount = (int32)(height / fMaxReplicantHeight);</a>
<a name="ln232">			height = kGutter + (rowCount * fMaxReplicantHeight)</a>
<a name="ln233">				+ ((rowCount - 1) * kIconGap) + kGutter;</a>
<a name="ln234">			height = std::max(fMinTrayHeight, height);</a>
<a name="ln235">		} else</a>
<a name="ln236">			height = fMinTrayHeight;</a>
<a name="ln237">	} else {</a>
<a name="ln238">		// if last replicant overruns clock then resize to accomodate</a>
<a name="ln239">		if (ReplicantCount() &gt; 0) {</a>
<a name="ln240">			if (!fTime-&gt;IsHidden() &amp;&amp; Bounds().right - kTrayPadding - 2</a>
<a name="ln241">						- fTime-&gt;Frame().Width() - kClockMargin</a>
<a name="ln242">					&lt; fRightBottomReplicant.right + kClockMargin) {</a>
<a name="ln243">				width = fRightBottomReplicant.right + kClockMargin</a>
<a name="ln244">					+ fTime-&gt;Frame().Width() + kTrayPadding + 2;</a>
<a name="ln245">			} else</a>
<a name="ln246">				width = fRightBottomReplicant.right + kIconGap + kGutter;</a>
<a name="ln247">		}</a>
<a name="ln248"> </a>
<a name="ln249">		// this view has a fixed minimum width</a>
<a name="ln250">		width = std::max(kMinimumTrayWidth, width);</a>
<a name="ln251">		height = kGutter + static_cast&lt;TBarApp*&gt;(be_app)-&gt;IconSize() + kGutter;</a>
<a name="ln252">	}</a>
<a name="ln253"> </a>
<a name="ln254">	*preferredWidth = width;</a>
<a name="ln255">	// add 1 for the border</a>
<a name="ln256">	*preferredHeight = height + 1;</a>
<a name="ln257">}</a>
<a name="ln258"> </a>
<a name="ln259"> </a>
<a name="ln260">void</a>
<a name="ln261">TReplicantTray::AdjustPlacement()</a>
<a name="ln262">{</a>
<a name="ln263">	// called when an add-on has been added or removed</a>
<a name="ln264">	// need to resize the parent of this accordingly</a>
<a name="ln265"> </a>
<a name="ln266">	BRect bounds = Bounds();</a>
<a name="ln267">	float width, height;</a>
<a name="ln268">	GetPreferredSize(&amp;width, &amp;height);</a>
<a name="ln269"> </a>
<a name="ln270">	if (width == bounds.Width() &amp;&amp; height == bounds.Height()) {</a>
<a name="ln271">		// no need to change anything</a>
<a name="ln272">		return;</a>
<a name="ln273">	}</a>
<a name="ln274"> </a>
<a name="ln275">	Parent()-&gt;ResizeToPreferred();</a>
<a name="ln276">	fBarView-&gt;UpdatePlacement();</a>
<a name="ln277">	Parent()-&gt;Invalidate();</a>
<a name="ln278">	Invalidate();</a>
<a name="ln279">}</a>
<a name="ln280"> </a>
<a name="ln281"> </a>
<a name="ln282">void</a>
<a name="ln283">TReplicantTray::MessageReceived(BMessage* message)</a>
<a name="ln284">{</a>
<a name="ln285">	switch (message-&gt;what) {</a>
<a name="ln286">		case B_LOCALE_CHANGED:</a>
<a name="ln287">			if (fTime == NULL)</a>
<a name="ln288">				return;</a>
<a name="ln289"> </a>
<a name="ln290">			fTime-&gt;UpdateTimeFormat();</a>
<a name="ln291">			fTime-&gt;Update();</a>
<a name="ln292">			// time string reformat -&gt; realign</a>
<a name="ln293">			goto realignReplicants;</a>
<a name="ln294"> </a>
<a name="ln295">		case kShowHideTime:</a>
<a name="ln296">			// from context menu in clock and in this view</a>
<a name="ln297">			ShowHideTime();</a>
<a name="ln298">			break;</a>
<a name="ln299"> </a>
<a name="ln300">		case kShowSeconds:</a>
<a name="ln301">			if (fTime == NULL)</a>
<a name="ln302">				return;</a>
<a name="ln303"> </a>
<a name="ln304">			fTime-&gt;SetShowSeconds(!fTime-&gt;ShowSeconds());</a>
<a name="ln305"> </a>
<a name="ln306">			// time string reformat -&gt; realign</a>
<a name="ln307">			goto realignReplicants;</a>
<a name="ln308"> </a>
<a name="ln309">		case kShowDayOfWeek:</a>
<a name="ln310">			if (fTime == NULL)</a>
<a name="ln311">				return;</a>
<a name="ln312"> </a>
<a name="ln313">			fTime-&gt;SetShowDayOfWeek(!fTime-&gt;ShowDayOfWeek());</a>
<a name="ln314"> </a>
<a name="ln315">			// time string reformat -&gt; realign</a>
<a name="ln316">			goto realignReplicants;</a>
<a name="ln317"> </a>
<a name="ln318">		case kShowTimeZone:</a>
<a name="ln319">			if (fTime == NULL)</a>
<a name="ln320">				return;</a>
<a name="ln321"> </a>
<a name="ln322">			fTime-&gt;SetShowTimeZone(!fTime-&gt;ShowTimeZone());</a>
<a name="ln323"> </a>
<a name="ln324">			// time string reformat -&gt; realign</a>
<a name="ln325">			goto realignReplicants;</a>
<a name="ln326"> </a>
<a name="ln327">		case kGetClockSettings:</a>
<a name="ln328">		{</a>
<a name="ln329">			if (fTime == NULL)</a>
<a name="ln330">				return;</a>
<a name="ln331"> </a>
<a name="ln332">			bool showClock = !fTime-&gt;IsHidden();</a>
<a name="ln333">			bool showSeconds = fTime-&gt;ShowSeconds();</a>
<a name="ln334">			bool showDayOfWeek = fTime-&gt;ShowDayOfWeek();</a>
<a name="ln335">			bool showTimeZone = fTime-&gt;ShowTimeZone();</a>
<a name="ln336"> </a>
<a name="ln337">			BMessage reply(kGetClockSettings);</a>
<a name="ln338">			reply.AddBool(&quot;showClock&quot;, showClock);</a>
<a name="ln339">			reply.AddBool(&quot;showSeconds&quot;, showSeconds);</a>
<a name="ln340">			reply.AddBool(&quot;showDayOfWeek&quot;, showDayOfWeek);</a>
<a name="ln341">			reply.AddBool(&quot;showTimeZone&quot;, showTimeZone);</a>
<a name="ln342">			message-&gt;SendReply(&amp;reply);</a>
<a name="ln343">			break;</a>
<a name="ln344">		}</a>
<a name="ln345"> </a>
<a name="ln346">#ifdef DB_ADDONS</a>
<a name="ln347">		case B_NODE_MONITOR:</a>
<a name="ln348">			HandleEntryUpdate(message);</a>
<a name="ln349">			break;</a>
<a name="ln350">#endif</a>
<a name="ln351"> </a>
<a name="ln352">		case kRealignReplicants:</a>
<a name="ln353">realignReplicants:</a>
<a name="ln354">			RealignReplicants();</a>
<a name="ln355">			AdjustPlacement();</a>
<a name="ln356">			break;</a>
<a name="ln357"> </a>
<a name="ln358">		default:</a>
<a name="ln359">			BView::MessageReceived(message);</a>
<a name="ln360">			break;</a>
<a name="ln361">	}</a>
<a name="ln362">}</a>
<a name="ln363"> </a>
<a name="ln364"> </a>
<a name="ln365">void</a>
<a name="ln366">TReplicantTray::MouseDown(BPoint where)</a>
<a name="ln367">{</a>
<a name="ln368">#ifdef DB_ADDONS</a>
<a name="ln369">	if (modifiers() &amp; B_CONTROL_KEY)</a>
<a name="ln370">		DumpList(fItemList);</a>
<a name="ln371">#endif</a>
<a name="ln372"> </a>
<a name="ln373">	uint32 buttons;</a>
<a name="ln374"> </a>
<a name="ln375">	Window()-&gt;CurrentMessage()-&gt;FindInt32(&quot;buttons&quot;, (int32*)&amp;buttons);</a>
<a name="ln376">	if (buttons == B_SECONDARY_MOUSE_BUTTON) {</a>
<a name="ln377">		ShowReplicantMenu(where);</a>
<a name="ln378">	} else {</a>
<a name="ln379">		BPoint save = where;</a>
<a name="ln380">		bigtime_t doubleClickSpeed;</a>
<a name="ln381">		bigtime_t start = system_time();</a>
<a name="ln382">		uint32 buttons;</a>
<a name="ln383"> </a>
<a name="ln384">		get_click_speed(&amp;doubleClickSpeed);</a>
<a name="ln385"> </a>
<a name="ln386">		do {</a>
<a name="ln387">			if (fabs(where.x - save.x) &gt; 4 || fabs(where.y - save.y) &gt; 4)</a>
<a name="ln388">				// user moved out of bounds of click area</a>
<a name="ln389">				break;</a>
<a name="ln390"> </a>
<a name="ln391">			if ((system_time() - start) &gt; (2 * doubleClickSpeed)) {</a>
<a name="ln392">				ShowReplicantMenu(where);</a>
<a name="ln393">				break;</a>
<a name="ln394">			}</a>
<a name="ln395"> </a>
<a name="ln396">			snooze(50000);</a>
<a name="ln397">			GetMouse(&amp;where, &amp;buttons);</a>
<a name="ln398">		} while (buttons);</a>
<a name="ln399">	}</a>
<a name="ln400">	BView::MouseDown(where);</a>
<a name="ln401">}</a>
<a name="ln402"> </a>
<a name="ln403"> </a>
<a name="ln404">void</a>
<a name="ln405">TReplicantTray::ShowReplicantMenu(BPoint point)</a>
<a name="ln406">{</a>
<a name="ln407">	BPopUpMenu* menu = new BPopUpMenu(&quot;&quot;, false, false);</a>
<a name="ln408">	menu-&gt;SetFont(be_plain_font);</a>
<a name="ln409"> </a>
<a name="ln410">	// If clock is visible show the extended menu, otherwise show &quot;Show clock&quot;</a>
<a name="ln411"> </a>
<a name="ln412">	if (!fTime-&gt;IsHidden())</a>
<a name="ln413">		fTime-&gt;ShowTimeOptions(ConvertToScreen(point));</a>
<a name="ln414">	else {</a>
<a name="ln415">		BMenuItem* item = new BMenuItem(B_TRANSLATE(&quot;Show clock&quot;),</a>
<a name="ln416">			new BMessage(kShowHideTime));</a>
<a name="ln417">		menu-&gt;AddItem(item);</a>
<a name="ln418">		menu-&gt;SetTargetForItems(this);</a>
<a name="ln419">		BPoint where = ConvertToScreen(point);</a>
<a name="ln420">		menu-&gt;Go(where, true, true, BRect(where - BPoint(4, 4),</a>
<a name="ln421">			where + BPoint(4, 4)), true);</a>
<a name="ln422">	}</a>
<a name="ln423">}</a>
<a name="ln424"> </a>
<a name="ln425"> </a>
<a name="ln426">void</a>
<a name="ln427">TReplicantTray::SetMultiRow(bool state)</a>
<a name="ln428">{</a>
<a name="ln429">	fMultiRowMode = state;</a>
<a name="ln430">}</a>
<a name="ln431"> </a>
<a name="ln432"> </a>
<a name="ln433">void</a>
<a name="ln434">TReplicantTray::ShowHideTime()</a>
<a name="ln435">{</a>
<a name="ln436">	if (fTime == NULL)</a>
<a name="ln437">		return;</a>
<a name="ln438"> </a>
<a name="ln439">	// Check from the point of view of fTime because we need to ignore</a>
<a name="ln440">	// whether or not the parent window is hidden.</a>
<a name="ln441">	if (fTime-&gt;IsHidden(fTime))</a>
<a name="ln442">		fTime-&gt;Show();</a>
<a name="ln443">	else</a>
<a name="ln444">		fTime-&gt;Hide();</a>
<a name="ln445"> </a>
<a name="ln446">	RealignReplicants();</a>
<a name="ln447">	AdjustPlacement();</a>
<a name="ln448"> </a>
<a name="ln449">	// Check from the point of view of fTime ignoring parent's state.</a>
<a name="ln450">	bool showClock = !fTime-&gt;IsHidden(fTime);</a>
<a name="ln451"> </a>
<a name="ln452">	// Update showClock setting that gets saved to disk on quit</a>
<a name="ln453">	static_cast&lt;TBarApp*&gt;(be_app)-&gt;Settings()-&gt;showClock = showClock;</a>
<a name="ln454"> </a>
<a name="ln455">	// Send a message to Time preferences telling it to update</a>
<a name="ln456">	BMessenger messenger(&quot;application/x-vnd.Haiku-Time&quot;);</a>
<a name="ln457">	BMessage message(kShowHideTime);</a>
<a name="ln458">	message.AddBool(&quot;showClock&quot;, showClock);</a>
<a name="ln459">	messenger.SendMessage(&amp;message);</a>
<a name="ln460">}</a>
<a name="ln461"> </a>
<a name="ln462"> </a>
<a name="ln463">#ifdef DB_ADDONS</a>
<a name="ln464"> </a>
<a name="ln465"> </a>
<a name="ln466">void</a>
<a name="ln467">TReplicantTray::InitAddOnSupport()</a>
<a name="ln468">{</a>
<a name="ln469">	// list to maintain refs to each rep added/deleted</a>
<a name="ln470">	fItemList = new BList();</a>
<a name="ln471">	BPath path;</a>
<a name="ln472"> </a>
<a name="ln473">	if (GetDeskbarSettingsDirectory(path, true) == B_OK) {</a>
<a name="ln474">		path.Append(kReplicantSettingsFile);</a>
<a name="ln475"> </a>
<a name="ln476">		BFile file(path.Path(), B_READ_ONLY);</a>
<a name="ln477">		if (file.InitCheck() == B_OK) {</a>
<a name="ln478">			status_t result;</a>
<a name="ln479">			BEntry entry;</a>
<a name="ln480">			int32 id;</a>
<a name="ln481">			BString path;</a>
<a name="ln482">			if (fAddOnSettings.Unflatten(&amp;file) == B_OK) {</a>
<a name="ln483">				for (int32 i = 0; fAddOnSettings.FindString(kReplicantPathField,</a>
<a name="ln484">					i, &amp;path) == B_OK; i++) {</a>
<a name="ln485">					if (entry.SetTo(path.String()) == B_OK &amp;&amp; entry.Exists()) {</a>
<a name="ln486">						result = LoadAddOn(&amp;entry, &amp;id, false);</a>
<a name="ln487">					} else</a>
<a name="ln488">						result = B_ENTRY_NOT_FOUND;</a>
<a name="ln489"> </a>
<a name="ln490">					if (result != B_OK) {</a>
<a name="ln491">						fAddOnSettings.RemoveData(kReplicantPathField, i);</a>
<a name="ln492">						--i;</a>
<a name="ln493">					}</a>
<a name="ln494">				}</a>
<a name="ln495">			}</a>
<a name="ln496">		}</a>
<a name="ln497">	}</a>
<a name="ln498">}</a>
<a name="ln499"> </a>
<a name="ln500"> </a>
<a name="ln501">void</a>
<a name="ln502">TReplicantTray::DeleteAddOnSupport()</a>
<a name="ln503">{</a>
<a name="ln504">	_SaveSettings();</a>
<a name="ln505"> </a>
<a name="ln506">	for (int32 i = fItemList-&gt;CountItems() - 1; i &gt;= 0; i--) {</a>
<a name="ln507">		DeskbarItemInfo* item = (DeskbarItemInfo*)fItemList-&gt;RemoveItem(i);</a>
<a name="ln508">		if (item) {</a>
<a name="ln509">			if (item-&gt;isAddOn)</a>
<a name="ln510">				watch_node(&amp;(item-&gt;nodeRef), B_STOP_WATCHING, this, Window());</a>
<a name="ln511"> </a>
<a name="ln512">			delete item;</a>
<a name="ln513">		}</a>
<a name="ln514">	}</a>
<a name="ln515">	delete fItemList;</a>
<a name="ln516"> </a>
<a name="ln517">	// stop the volume mount/unmount watch</a>
<a name="ln518">	stop_watching(this, Window());</a>
<a name="ln519">}</a>
<a name="ln520"> </a>
<a name="ln521"> </a>
<a name="ln522">DeskbarItemInfo*</a>
<a name="ln523">TReplicantTray::DeskbarItemFor(node_ref&amp; nodeRef)</a>
<a name="ln524">{</a>
<a name="ln525">	for (int32 i = fItemList-&gt;CountItems() - 1; i &gt;= 0; i--) {</a>
<a name="ln526">		DeskbarItemInfo* item = (DeskbarItemInfo*)fItemList-&gt;ItemAt(i);</a>
<a name="ln527">		if (item == NULL)</a>
<a name="ln528">			continue;</a>
<a name="ln529"> </a>
<a name="ln530">		if (item-&gt;nodeRef == nodeRef)</a>
<a name="ln531">			return item;</a>
<a name="ln532">	}</a>
<a name="ln533"> </a>
<a name="ln534">	return NULL;</a>
<a name="ln535">}</a>
<a name="ln536"> </a>
<a name="ln537"> </a>
<a name="ln538">DeskbarItemInfo*</a>
<a name="ln539">TReplicantTray::DeskbarItemFor(int32 id)</a>
<a name="ln540">{</a>
<a name="ln541">	for (int32 i = fItemList-&gt;CountItems() - 1; i &gt;= 0; i--) {</a>
<a name="ln542">		DeskbarItemInfo* item = (DeskbarItemInfo*)fItemList-&gt;ItemAt(i);</a>
<a name="ln543">		if (item == NULL)</a>
<a name="ln544">			continue;</a>
<a name="ln545"> </a>
<a name="ln546">		if (item-&gt;id == id)</a>
<a name="ln547">			return item;</a>
<a name="ln548">	}</a>
<a name="ln549"> </a>
<a name="ln550">	return NULL;</a>
<a name="ln551">}</a>
<a name="ln552"> </a>
<a name="ln553"> </a>
<a name="ln554">bool</a>
<a name="ln555">TReplicantTray::NodeExists(node_ref&amp; nodeRef)</a>
<a name="ln556">{</a>
<a name="ln557">	return DeskbarItemFor(nodeRef) != NULL;</a>
<a name="ln558">}</a>
<a name="ln559"> </a>
<a name="ln560"> </a>
<a name="ln561">/*! This handles B_NODE_MONITOR &amp; B_QUERY_UPDATE messages received</a>
<a name="ln562">	for the registered add-ons.</a>
<a name="ln563">*/</a>
<a name="ln564">void</a>
<a name="ln565">TReplicantTray::HandleEntryUpdate(BMessage* message)</a>
<a name="ln566">{</a>
<a name="ln567">	int32 opcode;</a>
<a name="ln568">	if (message-&gt;FindInt32(&quot;opcode&quot;, &amp;opcode) != B_OK)</a>
<a name="ln569">		return;</a>
<a name="ln570"> </a>
<a name="ln571">	BPath path;</a>
<a name="ln572">	switch (opcode) {</a>
<a name="ln573">		case B_ENTRY_MOVED:</a>
<a name="ln574">		{</a>
<a name="ln575">			entry_ref ref;</a>
<a name="ln576">			ino_t todirectory;</a>
<a name="ln577">			ino_t node;</a>
<a name="ln578">			const char* name;</a>
<a name="ln579">			if (message-&gt;FindString(&quot;name&quot;, &amp;name) == B_OK</a>
<a name="ln580">				&amp;&amp; message-&gt;FindInt64(&quot;from directory&quot;, &amp;(ref.directory))</a>
<a name="ln581">					== B_OK</a>
<a name="ln582">				&amp;&amp; message-&gt;FindInt64(&quot;to directory&quot;, &amp;todirectory) == B_OK</a>
<a name="ln583">				&amp;&amp; message-&gt;FindInt32(&quot;device&quot;, &amp;(ref.device)) == B_OK</a>
<a name="ln584">				&amp;&amp; message-&gt;FindInt64(&quot;node&quot;, &amp;node) == B_OK ) {</a>
<a name="ln585"> </a>
<a name="ln586">				if (name == NULL)</a>
<a name="ln587">					break;</a>
<a name="ln588"> </a>
<a name="ln589">				ref.set_name(name);</a>
<a name="ln590">				// change the directory reference to</a>
<a name="ln591">				// the new directory</a>
<a name="ln592">				MoveItem(&amp;ref, todirectory);</a>
<a name="ln593">			}</a>
<a name="ln594">			break;</a>
<a name="ln595">		}</a>
<a name="ln596"> </a>
<a name="ln597">		case B_ENTRY_REMOVED:</a>
<a name="ln598">		{</a>
<a name="ln599">			// entry was rm'd from the device</a>
<a name="ln600">			node_ref nodeRef;</a>
<a name="ln601">			if (message-&gt;FindInt32(&quot;device&quot;, &amp;(nodeRef.device)) == B_OK</a>
<a name="ln602">				&amp;&amp; message-&gt;FindInt64(&quot;node&quot;, &amp;(nodeRef.node)) == B_OK) {</a>
<a name="ln603">				DeskbarItemInfo* item = DeskbarItemFor(nodeRef);</a>
<a name="ln604">				if (item == NULL)</a>
<a name="ln605">					break;</a>
<a name="ln606"> </a>
<a name="ln607">				// If there is a team running where the add-on comes from,</a>
<a name="ln608">				// we don't want to remove the icon yet.</a>
<a name="ln609">				if (be_roster-&gt;IsRunning(&amp;item-&gt;entryRef))</a>
<a name="ln610">					break;</a>
<a name="ln611"> </a>
<a name="ln612">				UnloadAddOn(&amp;nodeRef, NULL, true, false);</a>
<a name="ln613">			}</a>
<a name="ln614">			break;</a>
<a name="ln615">		}</a>
<a name="ln616">	}</a>
<a name="ln617">}</a>
<a name="ln618"> </a>
<a name="ln619"> </a>
<a name="ln620">/*! The add-ons must support the exported C function API</a>
<a name="ln621">	if they do, they will be loaded and added to deskbar</a>
<a name="ln622">	primary function is the Instantiate function</a>
<a name="ln623">*/</a>
<a name="ln624">status_t</a>
<a name="ln625">TReplicantTray::LoadAddOn(BEntry* entry, int32* id, bool addToSettings)</a>
<a name="ln626">{</a>
<a name="ln627">	if (entry == NULL)</a>
<a name="ln628">		return B_BAD_VALUE;</a>
<a name="ln629"> </a>
<a name="ln630">	node_ref nodeRef;</a>
<a name="ln631">	entry-&gt;GetNodeRef(&amp;nodeRef);</a>
<a name="ln632">	// no duplicates</a>
<a name="ln633">	if (NodeExists(nodeRef))</a>
<a name="ln634">		return B_ERROR;</a>
<a name="ln635"> </a>
<a name="ln636">	BNode node(entry);</a>
<a name="ln637">	BPath path;</a>
<a name="ln638">	status_t status = entry-&gt;GetPath(&amp;path);</a>
<a name="ln639">	if (status != B_OK)</a>
<a name="ln640">		return status;</a>
<a name="ln641"> </a>
<a name="ln642">	// load the add-on</a>
<a name="ln643">	image_id image = load_add_on(path.Path());</a>
<a name="ln644">	if (image &lt; B_OK)</a>
<a name="ln645">		return image;</a>
<a name="ln646"> </a>
<a name="ln647">	// get the view loading function symbol</a>
<a name="ln648">	//    we first look for a symbol that takes an image_id</a>
<a name="ln649">	//    and entry_ref pointer, if not found, go with normal</a>
<a name="ln650">	//    instantiate function</a>
<a name="ln651">	BView* (*entryFunction)(image_id, const entry_ref*, float, float);</a>
<a name="ln652">	BView* (*itemFunction)(float, float);</a>
<a name="ln653">	BView* view = NULL;</a>
<a name="ln654"> </a>
<a name="ln655">	entry_ref ref;</a>
<a name="ln656">	entry-&gt;GetRef(&amp;ref);</a>
<a name="ln657"> </a>
<a name="ln658">	if (get_image_symbol(image, kInstantiateEntryCFunctionName,</a>
<a name="ln659">			B_SYMBOL_TYPE_TEXT, (void**)&amp;entryFunction) &gt;= B_OK) {</a>
<a name="ln660">		view = (*entryFunction)(image, &amp;ref, fMaxReplicantWidth,</a>
<a name="ln661">			fMaxReplicantHeight);</a>
<a name="ln662">	} else if (get_image_symbol(image, kInstantiateItemCFunctionName,</a>
<a name="ln663">			B_SYMBOL_TYPE_TEXT, (void**)&amp;itemFunction) &gt;= B_OK) {</a>
<a name="ln664">		view = (*itemFunction)(fMaxReplicantWidth, fMaxReplicantHeight);</a>
<a name="ln665">	} else {</a>
<a name="ln666">		unload_add_on(image);</a>
<a name="ln667">		return B_ERROR;</a>
<a name="ln668">	}</a>
<a name="ln669"> </a>
<a name="ln670">	if (view == NULL || IconExists(view-&gt;Name())) {</a>
<a name="ln671">		delete view;</a>
<a name="ln672">		unload_add_on(image);</a>
<a name="ln673">		return B_ERROR;</a>
<a name="ln674">	}</a>
<a name="ln675"> </a>
<a name="ln676">	BMessage* data = new BMessage;</a>
<a name="ln677">	view-&gt;Archive(data);</a>
<a name="ln678">	delete view;</a>
<a name="ln679"> </a>
<a name="ln680">	// add the rep; adds info to list</a>
<a name="ln681">	if (AddIcon(data, id, &amp;ref) != B_OK)</a>
<a name="ln682">		delete data;</a>
<a name="ln683"> </a>
<a name="ln684">	if (addToSettings) {</a>
<a name="ln685">		fAddOnSettings.AddString(kReplicantPathField, path.Path());</a>
<a name="ln686">		_SaveSettings();</a>
<a name="ln687">	}</a>
<a name="ln688"> </a>
<a name="ln689">	return B_OK;</a>
<a name="ln690">}</a>
<a name="ln691"> </a>
<a name="ln692"> </a>
<a name="ln693">status_t</a>
<a name="ln694">TReplicantTray::AddItem(int32 id, node_ref nodeRef, BEntry&amp; entry, bool isAddOn)</a>
<a name="ln695">{</a>
<a name="ln696">	DeskbarItemInfo* item = new DeskbarItemInfo;</a>
<a name="ln697">	if (item == NULL)</a>
<a name="ln698">		return B_NO_MEMORY;</a>
<a name="ln699"> </a>
<a name="ln700">	item-&gt;id = id;</a>
<a name="ln701">	item-&gt;isAddOn = isAddOn;</a>
<a name="ln702"> </a>
<a name="ln703">	if (entry.GetRef(&amp;item-&gt;entryRef) != B_OK) {</a>
<a name="ln704">		item-&gt;entryRef.device = -1;</a>
<a name="ln705">		item-&gt;entryRef.directory = -1;</a>
<a name="ln706">		item-&gt;entryRef.name = NULL;</a>
<a name="ln707">	}</a>
<a name="ln708">	item-&gt;nodeRef = nodeRef;</a>
<a name="ln709"> </a>
<a name="ln710">	fItemList-&gt;AddItem(item);</a>
<a name="ln711"> </a>
<a name="ln712">	if (isAddOn)</a>
<a name="ln713">		watch_node(&amp;nodeRef, B_WATCH_NAME | B_WATCH_ATTR, this, Window());</a>
<a name="ln714"> </a>
<a name="ln715">	return B_OK;</a>
<a name="ln716">}</a>
<a name="ln717"> </a>
<a name="ln718"> </a>
<a name="ln719">/**	from entry_removed message, when attribute removed</a>
<a name="ln720"> *	or when a device is unmounted (use removeall, by device)</a>
<a name="ln721"> */</a>
<a name="ln722"> </a>
<a name="ln723">void</a>
<a name="ln724">TReplicantTray::UnloadAddOn(node_ref* nodeRef, dev_t* device, bool which,</a>
<a name="ln725">	bool removeAll)</a>
<a name="ln726">{</a>
<a name="ln727">	for (int32 i = fItemList-&gt;CountItems() - 1; i &gt;= 0; i--) {</a>
<a name="ln728">		DeskbarItemInfo* item = (DeskbarItemInfo*)fItemList-&gt;ItemAt(i);</a>
<a name="ln729">		if (item == NULL)</a>
<a name="ln730">			continue;</a>
<a name="ln731"> </a>
<a name="ln732">		if ((which &amp;&amp; nodeRef != NULL &amp;&amp; item-&gt;nodeRef == *nodeRef)</a>
<a name="ln733">			|| (device != NULL &amp;&amp; item-&gt;nodeRef.device == *device)) {</a>
<a name="ln734"> </a>
<a name="ln735">			if (device != NULL &amp;&amp; be_roster-&gt;IsRunning(&amp;item-&gt;entryRef))</a>
<a name="ln736">				continue;</a>
<a name="ln737"> </a>
<a name="ln738">			RemoveIcon(item-&gt;id);</a>
<a name="ln739"> </a>
<a name="ln740">			if (!removeAll)</a>
<a name="ln741">				break;</a>
<a name="ln742">		}</a>
<a name="ln743">	}</a>
<a name="ln744">}</a>
<a name="ln745"> </a>
<a name="ln746"> </a>
<a name="ln747">void</a>
<a name="ln748">TReplicantTray::RemoveItem(int32 id)</a>
<a name="ln749">{</a>
<a name="ln750">	DeskbarItemInfo* item = DeskbarItemFor(id);</a>
<a name="ln751">	if (item == NULL)</a>
<a name="ln752">		return;</a>
<a name="ln753"> </a>
<a name="ln754">	// attribute was added via Deskbar API (AddItem(entry_ref*, int32*)</a>
<a name="ln755">	if (item-&gt;isAddOn) {</a>
<a name="ln756">		BPath path(&amp;item-&gt;entryRef);</a>
<a name="ln757">		BString storedPath;</a>
<a name="ln758">		for (int32 i = 0;</a>
<a name="ln759">			fAddOnSettings.FindString(kReplicantPathField, i, &amp;storedPath)</a>
<a name="ln760">				== B_OK; i++) {</a>
<a name="ln761">			if (storedPath == path.Path()) {</a>
<a name="ln762">				fAddOnSettings.RemoveData(kReplicantPathField, i);</a>
<a name="ln763">				break;</a>
<a name="ln764">			}</a>
<a name="ln765">		}</a>
<a name="ln766">		_SaveSettings();</a>
<a name="ln767"> </a>
<a name="ln768">		BNode node(&amp;item-&gt;entryRef);</a>
<a name="ln769">		watch_node(&amp;item-&gt;nodeRef, B_STOP_WATCHING, this, Window());</a>
<a name="ln770">	}</a>
<a name="ln771"> </a>
<a name="ln772">	fItemList-&gt;RemoveItem(item);</a>
<a name="ln773">	delete item;</a>
<a name="ln774">}</a>
<a name="ln775"> </a>
<a name="ln776"> </a>
<a name="ln777">/**	ENTRY_MOVED message, moving only occurs on a device</a>
<a name="ln778"> *	copying will occur (ENTRY_CREATED) between devices</a>
<a name="ln779"> */</a>
<a name="ln780"> </a>
<a name="ln781">void</a>
<a name="ln782">TReplicantTray::MoveItem(entry_ref* ref, ino_t toDirectory)</a>
<a name="ln783">{</a>
<a name="ln784">	if (ref == NULL)</a>
<a name="ln785">		return;</a>
<a name="ln786"> </a>
<a name="ln787">	// scan for a matching entry_ref and update it</a>
<a name="ln788">	//</a>
<a name="ln789">	// don't need to change node info as it does not change</a>
<a name="ln790"> </a>
<a name="ln791">	for (int32 i = fItemList-&gt;CountItems() - 1; i &gt;= 0; i--) {</a>
<a name="ln792">		DeskbarItemInfo* item = (DeskbarItemInfo*)fItemList-&gt;ItemAt(i);</a>
<a name="ln793">		if (item == NULL)</a>
<a name="ln794">			continue;</a>
<a name="ln795"> </a>
<a name="ln796">		if (strcmp(item-&gt;entryRef.name, ref-&gt;name) == 0</a>
<a name="ln797">			&amp;&amp; item-&gt;entryRef.device == ref-&gt;device</a>
<a name="ln798">			&amp;&amp; item-&gt;entryRef.directory == ref-&gt;directory) {</a>
<a name="ln799">			item-&gt;entryRef.directory = toDirectory;</a>
<a name="ln800">			break;</a>
<a name="ln801">		}</a>
<a name="ln802">	}</a>
<a name="ln803">}</a>
<a name="ln804"> </a>
<a name="ln805">#endif // add-on support</a>
<a name="ln806"> </a>
<a name="ln807">//	external add-on API routines</a>
<a name="ln808">//	called using the new BDeskbar class</a>
<a name="ln809"> </a>
<a name="ln810">//	existence of icon/replicant by name or ID</a>
<a name="ln811">//	returns opposite</a>
<a name="ln812">//	note: name and id are semi-private limiting</a>
<a name="ln813">//		the ability of non-host apps to remove</a>
<a name="ln814">//		icons without a little bit of work</a>
<a name="ln815"> </a>
<a name="ln816">/**	for a specific id</a>
<a name="ln817"> *	return the name of the replicant (name of view)</a>
<a name="ln818"> */</a>
<a name="ln819"> </a>
<a name="ln820">status_t</a>
<a name="ln821">TReplicantTray::ItemInfo(int32 id, const char** name)</a>
<a name="ln822">{</a>
<a name="ln823">	if (id &lt; 0)</a>
<a name="ln824">		return B_BAD_VALUE;</a>
<a name="ln825"> </a>
<a name="ln826">	int32 index;</a>
<a name="ln827">	int32 temp;</a>
<a name="ln828">	BView* view = ViewAt(&amp;index, &amp;temp, id, false);</a>
<a name="ln829">	if (view != NULL) {</a>
<a name="ln830">		*name = view-&gt;Name();</a>
<a name="ln831">		return B_OK;</a>
<a name="ln832">	}</a>
<a name="ln833"> </a>
<a name="ln834">	return B_ERROR;</a>
<a name="ln835">}</a>
<a name="ln836"> </a>
<a name="ln837"> </a>
<a name="ln838">/**	for a specific name</a>
<a name="ln839"> *	return the id (internal to Deskbar)</a>
<a name="ln840"> */</a>
<a name="ln841"> </a>
<a name="ln842">status_t</a>
<a name="ln843">TReplicantTray::ItemInfo(const char* name, int32* id)</a>
<a name="ln844">{</a>
<a name="ln845">	if (name == NULL || *name == '\0')</a>
<a name="ln846">		return B_BAD_VALUE;</a>
<a name="ln847"> </a>
<a name="ln848">	int32 index;</a>
<a name="ln849">	BView* view = ViewAt(&amp;index, id, name);</a>
<a name="ln850"> </a>
<a name="ln851">	return view != NULL ? B_OK : B_ERROR;</a>
<a name="ln852">}</a>
<a name="ln853"> </a>
<a name="ln854"> </a>
<a name="ln855">/**	at a specific index</a>
<a name="ln856"> *	return both the name and the id of the replicant</a>
<a name="ln857"> */</a>
<a name="ln858"> </a>
<a name="ln859">status_t</a>
<a name="ln860">TReplicantTray::ItemInfo(int32 index, const char** name, int32* id)</a>
<a name="ln861">{</a>
<a name="ln862">	if (index &lt; 0)</a>
<a name="ln863">		return B_BAD_VALUE;</a>
<a name="ln864"> </a>
<a name="ln865">	BView* view;</a>
<a name="ln866">	fShelf-&gt;ReplicantAt(index, &amp;view, (uint32*)id, NULL);</a>
<a name="ln867">	if (view != NULL) {</a>
<a name="ln868">		*name = view-&gt;Name();</a>
<a name="ln869">		return B_OK;</a>
<a name="ln870">	}</a>
<a name="ln871"> </a>
<a name="ln872">	return B_ERROR;</a>
<a name="ln873">}</a>
<a name="ln874"> </a>
<a name="ln875"> </a>
<a name="ln876">/**	replicant exists, by id/index */</a>
<a name="ln877"> </a>
<a name="ln878">bool</a>
<a name="ln879">TReplicantTray::IconExists(int32 target, bool byIndex)</a>
<a name="ln880">{</a>
<a name="ln881">	int32 index;</a>
<a name="ln882">	int32 id;</a>
<a name="ln883">	BView* view = ViewAt(&amp;index, &amp;id, target, byIndex);</a>
<a name="ln884"> </a>
<a name="ln885">	return view &amp;&amp; index &gt;= 0;</a>
<a name="ln886">}</a>
<a name="ln887"> </a>
<a name="ln888"> </a>
<a name="ln889">/**	replicant exists, by name */</a>
<a name="ln890"> </a>
<a name="ln891">bool</a>
<a name="ln892">TReplicantTray::IconExists(const char* name)</a>
<a name="ln893">{</a>
<a name="ln894">	if (name == NULL || *name == '\0')</a>
<a name="ln895">		return false;</a>
<a name="ln896"> </a>
<a name="ln897">	int32 index;</a>
<a name="ln898">	int32 id;</a>
<a name="ln899">	BView* view = ViewAt(&amp;index, &amp;id, name);</a>
<a name="ln900"> </a>
<a name="ln901">	return view != NULL &amp;&amp; index &gt;= 0;</a>
<a name="ln902">}</a>
<a name="ln903"> </a>
<a name="ln904"> </a>
<a name="ln905">int32</a>
<a name="ln906">TReplicantTray::ReplicantCount() const</a>
<a name="ln907">{</a>
<a name="ln908">	return fShelf-&gt;CountReplicants();</a>
<a name="ln909">}</a>
<a name="ln910"> </a>
<a name="ln911"> </a>
<a name="ln912">/*! Message must contain an archivable view for later rehydration.</a>
<a name="ln913">	This function takes over ownership of the provided message on success</a>
<a name="ln914">	only.</a>
<a name="ln915">	Returns the current replicant ID.</a>
<a name="ln916">*/</a>
<a name="ln917">status_t</a>
<a name="ln918">TReplicantTray::AddIcon(BMessage* archive, int32* id, const entry_ref* addOn)</a>
<a name="ln919">{</a>
<a name="ln920">	if (archive == NULL || id == NULL)</a>
<a name="ln921">		return B_BAD_VALUE;</a>
<a name="ln922"> </a>
<a name="ln923">	// find entry_ref</a>
<a name="ln924"> </a>
<a name="ln925">	entry_ref ref;</a>
<a name="ln926">	if (addOn != NULL) {</a>
<a name="ln927">		// Use it if we got it</a>
<a name="ln928">		ref = *addOn;</a>
<a name="ln929">	} else {</a>
<a name="ln930">		const char* signature;</a>
<a name="ln931"> </a>
<a name="ln932">		status_t status = archive-&gt;FindString(&quot;add_on&quot;, &amp;signature);</a>
<a name="ln933">		if (status == B_OK) {</a>
<a name="ln934">			BRoster roster;</a>
<a name="ln935">			status = roster.FindApp(signature, &amp;ref);</a>
<a name="ln936">		}</a>
<a name="ln937">		if (status != B_OK)</a>
<a name="ln938">			return status;</a>
<a name="ln939">	}</a>
<a name="ln940"> </a>
<a name="ln941">	BFile file;</a>
<a name="ln942">	status_t status = file.SetTo(&amp;ref, B_READ_ONLY);</a>
<a name="ln943">	if (status != B_OK)</a>
<a name="ln944">		return status;</a>
<a name="ln945"> </a>
<a name="ln946">	node_ref nodeRef;</a>
<a name="ln947">	status = file.GetNodeRef(&amp;nodeRef);</a>
<a name="ln948">	if (status != B_OK)</a>
<a name="ln949">		return status;</a>
<a name="ln950"> </a>
<a name="ln951">	BEntry entry(&amp;ref, true);</a>
<a name="ln952">		// TODO: this resolves an eventual link for the item being added - this</a>
<a name="ln953">		// is okay for now, but in multi-user environments, one might want to</a>
<a name="ln954">		// have links that carry the be:deskbar_item_status attribute</a>
<a name="ln955">	status = entry.InitCheck();</a>
<a name="ln956">	if (status != B_OK)</a>
<a name="ln957">		return status;</a>
<a name="ln958"> </a>
<a name="ln959">	*id = 999;</a>
<a name="ln960">	if (archive-&gt;what == B_ARCHIVED_OBJECT)</a>
<a name="ln961">		archive-&gt;what = 0;</a>
<a name="ln962"> </a>
<a name="ln963">	BRect originalBounds = archive-&gt;FindRect(&quot;_frame&quot;);</a>
<a name="ln964">		// this is a work-around for buggy replicants that change their size in</a>
<a name="ln965">		// AttachedToWindow() (such as &quot;SVM&quot;)</a>
<a name="ln966"> </a>
<a name="ln967">	// TODO: check for name collisions?</a>
<a name="ln968">	status = fShelf-&gt;AddReplicant(archive, BPoint(1, 1));</a>
<a name="ln969">	if (status != B_OK)</a>
<a name="ln970">		return status;</a>
<a name="ln971"> </a>
<a name="ln972">	int32 count = ReplicantCount();</a>
<a name="ln973">	BView* view;</a>
<a name="ln974">	fShelf-&gt;ReplicantAt(count - 1, &amp;view, (uint32*)id, NULL);</a>
<a name="ln975"> </a>
<a name="ln976">	if (view != NULL &amp;&amp; originalBounds != view-&gt;Bounds()) {</a>
<a name="ln977">		// The replicant changed its size when added to the window, so we need</a>
<a name="ln978">		// to recompute all over again (it's already done once via</a>
<a name="ln979">		// BShelf::AddReplicant() and TReplicantShelf::CanAcceptReplicantView())</a>
<a name="ln980">		RealignReplicants();</a>
<a name="ln981">	}</a>
<a name="ln982"> </a>
<a name="ln983">	float oldWidth = Bounds().Width();</a>
<a name="ln984">	float oldHeight = Bounds().Height();</a>
<a name="ln985">	float width, height;</a>
<a name="ln986">	GetPreferredSize(&amp;width, &amp;height);</a>
<a name="ln987">	if (oldWidth != width || oldHeight != height)</a>
<a name="ln988">		AdjustPlacement();</a>
<a name="ln989"> </a>
<a name="ln990">	// add the item to the add-on list</a>
<a name="ln991"> </a>
<a name="ln992">	AddItem(*id, nodeRef, entry, addOn != NULL);</a>
<a name="ln993">	return B_OK;</a>
<a name="ln994">}</a>
<a name="ln995"> </a>
<a name="ln996"> </a>
<a name="ln997">void</a>
<a name="ln998">TReplicantTray::RemoveIcon(int32 target, bool byIndex)</a>
<a name="ln999">{</a>
<a name="ln1000">	if (target &lt; 0)</a>
<a name="ln1001">		return;</a>
<a name="ln1002"> </a>
<a name="ln1003">	int32 index;</a>
<a name="ln1004">	int32 id;</a>
<a name="ln1005">	BView* view = ViewAt(&amp;index, &amp;id, target, byIndex);</a>
<a name="ln1006">	if (view != NULL &amp;&amp; index &gt;= 0) {</a>
<a name="ln1007">		// remove the reference from the item list &amp; the shelf</a>
<a name="ln1008">		RemoveItem(id);</a>
<a name="ln1009">		fShelf-&gt;DeleteReplicant(index);</a>
<a name="ln1010"> </a>
<a name="ln1011">		// force a placement update,  !! need to fix BShelf</a>
<a name="ln1012">		RealReplicantAdjustment(index);</a>
<a name="ln1013">	}</a>
<a name="ln1014">}</a>
<a name="ln1015"> </a>
<a name="ln1016"> </a>
<a name="ln1017">void</a>
<a name="ln1018">TReplicantTray::RemoveIcon(const char* name)</a>
<a name="ln1019">{</a>
<a name="ln1020">	if (name == NULL || *name == '\0')</a>
<a name="ln1021">		return;</a>
<a name="ln1022"> </a>
<a name="ln1023">	int32 index;</a>
<a name="ln1024">	int32 id;</a>
<a name="ln1025">	BView* view = ViewAt(&amp;index, &amp;id, name);</a>
<a name="ln1026">	if (view != NULL &amp;&amp; index &gt;= 0) {</a>
<a name="ln1027">		// remove the reference from the item list &amp; shelf</a>
<a name="ln1028">		RemoveItem(id);</a>
<a name="ln1029">		fShelf-&gt;DeleteReplicant(index);</a>
<a name="ln1030"> </a>
<a name="ln1031">		// force a placement update,  !! need to fix BShelf</a>
<a name="ln1032">		RealReplicantAdjustment(index);</a>
<a name="ln1033">	}</a>
<a name="ln1034">}</a>
<a name="ln1035"> </a>
<a name="ln1036"> </a>
<a name="ln1037">void</a>
<a name="ln1038">TReplicantTray::RealReplicantAdjustment(int32 startIndex)</a>
<a name="ln1039">{</a>
<a name="ln1040">	if (startIndex &lt; 0)</a>
<a name="ln1041">		return;</a>
<a name="ln1042"> </a>
<a name="ln1043">	if (startIndex == fLastReplicant)</a>
<a name="ln1044">		startIndex = 0;</a>
<a name="ln1045"> </a>
<a name="ln1046">	// reset the locations of all replicants after the one deleted</a>
<a name="ln1047">	RealignReplicants(startIndex);</a>
<a name="ln1048"> </a>
<a name="ln1049">	float oldWidth = Bounds().Width();</a>
<a name="ln1050">	float oldHeight = Bounds().Height();</a>
<a name="ln1051">	float width, height;</a>
<a name="ln1052">	GetPreferredSize(&amp;width, &amp;height);</a>
<a name="ln1053">	if (oldWidth != width || oldHeight != height) {</a>
<a name="ln1054">		// resize view to accomodate the replicants, redraw as necessary</a>
<a name="ln1055">		AdjustPlacement();</a>
<a name="ln1056">	}</a>
<a name="ln1057">}</a>
<a name="ln1058"> </a>
<a name="ln1059"> </a>
<a name="ln1060">/**	looking for a replicant by id/index</a>
<a name="ln1061"> *	return the view and index</a>
<a name="ln1062"> */</a>
<a name="ln1063"> </a>
<a name="ln1064">BView*</a>
<a name="ln1065">TReplicantTray::ViewAt(int32* index, int32* id, int32 target, bool byIndex)</a>
<a name="ln1066">{</a>
<a name="ln1067">	*index = -1;</a>
<a name="ln1068"> </a>
<a name="ln1069">	BView* view;</a>
<a name="ln1070">	if (byIndex) {</a>
<a name="ln1071">		if (fShelf-&gt;ReplicantAt(target, &amp;view, (uint32*)id)) {</a>
<a name="ln1072">			if (view != NULL) {</a>
<a name="ln1073">				*index = target;</a>
<a name="ln1074"> </a>
<a name="ln1075">				return view;</a>
<a name="ln1076">			}</a>
<a name="ln1077">		}</a>
<a name="ln1078">	} else {</a>
<a name="ln1079">		int32 count = ReplicantCount() - 1;</a>
<a name="ln1080">		int32 localid;</a>
<a name="ln1081">		for (int32 repIndex = count; repIndex &gt;= 0; repIndex--) {</a>
<a name="ln1082">			fShelf-&gt;ReplicantAt(repIndex, &amp;view, (uint32*)&amp;localid);</a>
<a name="ln1083">			if (localid == target &amp;&amp; view != NULL) {</a>
<a name="ln1084">				*index = repIndex;</a>
<a name="ln1085">				*id = localid;</a>
<a name="ln1086"> </a>
<a name="ln1087">				return view;</a>
<a name="ln1088">			}</a>
<a name="ln1089">		}</a>
<a name="ln1090">	}</a>
<a name="ln1091"> </a>
<a name="ln1092">	return NULL;</a>
<a name="ln1093">}</a>
<a name="ln1094"> </a>
<a name="ln1095"> </a>
<a name="ln1096">/**	looking for a replicant with a view by name</a>
<a name="ln1097"> *	return the view, index and the id of the replicant</a>
<a name="ln1098"> */</a>
<a name="ln1099"> </a>
<a name="ln1100">BView*</a>
<a name="ln1101">TReplicantTray::ViewAt(int32* index, int32* id, const char* name)</a>
<a name="ln1102">{</a>
<a name="ln1103">	*index = -1;</a>
<a name="ln1104">	*id = -1;</a>
<a name="ln1105"> </a>
<a name="ln1106">	BView* view;</a>
<a name="ln1107">	int32 count = ReplicantCount() - 1;</a>
<a name="ln1108">	for (int32 repIndex = count; repIndex &gt;= 0; repIndex--) {</a>
<a name="ln1109">		fShelf-&gt;ReplicantAt(repIndex, &amp;view, (uint32*)id);</a>
<a name="ln1110">		if (view != NULL &amp;&amp; view-&gt;Name() != NULL</a>
<a name="ln1111">			&amp;&amp; strcmp(name, view-&gt;Name()) == 0) {</a>
<a name="ln1112">			*index = repIndex;</a>
<a name="ln1113"> </a>
<a name="ln1114">			return view;</a>
<a name="ln1115">		}</a>
<a name="ln1116">	}</a>
<a name="ln1117"> </a>
<a name="ln1118">	return NULL;</a>
<a name="ln1119">}</a>
<a name="ln1120"> </a>
<a name="ln1121"> </a>
<a name="ln1122">/**	Shelf will call to determine where and if</a>
<a name="ln1123"> *	the replicant is to be added</a>
<a name="ln1124"> */</a>
<a name="ln1125"> </a>
<a name="ln1126">bool</a>
<a name="ln1127">TReplicantTray::AcceptAddon(BRect replicantFrame, BMessage* message)</a>
<a name="ln1128">{</a>
<a name="ln1129">	if (message == NULL)</a>
<a name="ln1130">		return false;</a>
<a name="ln1131"> </a>
<a name="ln1132">	if (replicantFrame.Height() &gt; fMaxReplicantHeight)</a>
<a name="ln1133">		return false;</a>
<a name="ln1134"> </a>
<a name="ln1135">	alignment align = B_ALIGN_LEFT;</a>
<a name="ln1136">	if (fAlignmentSupport &amp;&amp; message-&gt;HasBool(&quot;deskbar:dynamic_align&quot;)) {</a>
<a name="ln1137">		if (!fBarView-&gt;Vertical())</a>
<a name="ln1138">			align = B_ALIGN_RIGHT;</a>
<a name="ln1139">		else</a>
<a name="ln1140">			align = fBarView-&gt;Left() ? B_ALIGN_LEFT : B_ALIGN_RIGHT;</a>
<a name="ln1141">	} else if (message-&gt;HasInt32(&quot;deskbar:align&quot;))</a>
<a name="ln1142">		message-&gt;FindInt32(&quot;deskbar:align&quot;, (int32*)&amp;align);</a>
<a name="ln1143"> </a>
<a name="ln1144">	if (message-&gt;HasInt32(&quot;deskbar:private_align&quot;))</a>
<a name="ln1145">		message-&gt;FindInt32(&quot;deskbar:private_align&quot;, (int32*)&amp;align);</a>
<a name="ln1146">	else</a>
<a name="ln1147">		align = B_ALIGN_LEFT;</a>
<a name="ln1148"> </a>
<a name="ln1149">	BPoint loc = LocationForReplicant(ReplicantCount(),</a>
<a name="ln1150">		replicantFrame.Width());</a>
<a name="ln1151">	message-&gt;AddPoint(&quot;_pjp_loc&quot;, loc);</a>
<a name="ln1152"> </a>
<a name="ln1153">	return true;</a>
<a name="ln1154">}</a>
<a name="ln1155"> </a>
<a name="ln1156"> </a>
<a name="ln1157">/**	based on the previous (index - 1) replicant in the list</a>
<a name="ln1158"> *	calculate where the left point should be for this</a>
<a name="ln1159"> *	replicant.  replicant will flow to the right on its own</a>
<a name="ln1160"> */</a>
<a name="ln1161"> </a>
<a name="ln1162">BPoint</a>
<a name="ln1163">TReplicantTray::LocationForReplicant(int32 index, float replicantWidth)</a>
<a name="ln1164">{</a>
<a name="ln1165">	BPoint loc(kTrayPadding, 2);</a>
<a name="ln1166">	if (fBarView-&gt;Vertical()) {</a>
<a name="ln1167">		if (!fBarView-&gt;Left())</a>
<a name="ln1168">			loc.x += kDragWidth; // move past dragger</a>
<a name="ln1169">	} else</a>
<a name="ln1170">		loc.x += 1; // keeps everything lined up nicely</a>
<a name="ln1171"> </a>
<a name="ln1172">	if (fMultiRowMode) {</a>
<a name="ln1173">		// try to find free space in every row</a>
<a name="ln1174">		for (int32 row = 0; ; loc.y += fMaxReplicantHeight + kIconGap, row++) {</a>
<a name="ln1175">			// determine free space in this row</a>
<a name="ln1176">			BRect rowRect(loc.x, loc.y,</a>
<a name="ln1177">				loc.x + static_cast&lt;TBarApp*&gt;(be_app)-&gt;Settings()-&gt;width</a>
<a name="ln1178">					- (kTrayPadding + kDragWidth + kGutter) * 2,</a>
<a name="ln1179">				loc.y + fMaxReplicantHeight);</a>
<a name="ln1180">			if (row == 0 &amp;&amp; !fTime-&gt;IsHidden())</a>
<a name="ln1181">				rowRect.right -= kClockMargin + fTime-&gt;Frame().Width();</a>
<a name="ln1182"> </a>
<a name="ln1183">			BRect replicantRect = rowRect;</a>
<a name="ln1184">			for (int32 i = 0; i &lt; index; i++) {</a>
<a name="ln1185">				BView* view = NULL;</a>
<a name="ln1186">				fShelf-&gt;ReplicantAt(i, &amp;view);</a>
<a name="ln1187">				if (view == NULL || view-&gt;Frame().top != rowRect.top)</a>
<a name="ln1188">					continue;</a>
<a name="ln1189"> </a>
<a name="ln1190">				// push this replicant placement past the last one</a>
<a name="ln1191">				replicantRect.left = view-&gt;Frame().right + kIconGap + 1;</a>
<a name="ln1192">			}</a>
<a name="ln1193"> </a>
<a name="ln1194">			// calculated left position, add replicantWidth to get right position</a>
<a name="ln1195">			replicantRect.right = replicantRect.left + replicantWidth;</a>
<a name="ln1196"> </a>
<a name="ln1197">			// check if replicant fits in this row</a>
<a name="ln1198">			if (replicantRect.right &lt; rowRect.right) {</a>
<a name="ln1199">				// replicant fits in this row</a>
<a name="ln1200">				loc = replicantRect.LeftTop();</a>
<a name="ln1201">				break;</a>
<a name="ln1202">			}</a>
<a name="ln1203"> </a>
<a name="ln1204">			// check next row</a>
<a name="ln1205">		}</a>
<a name="ln1206">	} else if (index &gt; 0) {</a>
<a name="ln1207">		// get the last replicant added for placement reference</a>
<a name="ln1208">		BView* view = NULL;</a>
<a name="ln1209">		fShelf-&gt;ReplicantAt(index - 1, &amp;view);</a>
<a name="ln1210">		if (view != NULL) {</a>
<a name="ln1211">			// push this replicant placement past the last one</a>
<a name="ln1212">			loc.x = view-&gt;Frame().right + kIconGap + 1;</a>
<a name="ln1213">			loc.y = view-&gt;Frame().top;</a>
<a name="ln1214">		}</a>
<a name="ln1215">	}</a>
<a name="ln1216"> </a>
<a name="ln1217">	if (loc.y &gt; fRightBottomReplicant.top</a>
<a name="ln1218">		|| (loc.y == fRightBottomReplicant.top</a>
<a name="ln1219">			&amp;&amp; loc.x &gt; fRightBottomReplicant.left)) {</a>
<a name="ln1220">		fRightBottomReplicant.Set(loc.x, loc.y, loc.x + replicantWidth,</a>
<a name="ln1221">			loc.y + fMaxReplicantHeight);</a>
<a name="ln1222">		fLastReplicant = index;</a>
<a name="ln1223">	}</a>
<a name="ln1224"> </a>
<a name="ln1225">	return loc;</a>
<a name="ln1226">}</a>
<a name="ln1227"> </a>
<a name="ln1228"> </a>
<a name="ln1229">BRect</a>
<a name="ln1230">TReplicantTray::IconFrame(int32 target, bool byIndex)</a>
<a name="ln1231">{</a>
<a name="ln1232">	int32 index;</a>
<a name="ln1233">	int32 id;</a>
<a name="ln1234">	BView* view = ViewAt(&amp;index, &amp;id, target, byIndex);</a>
<a name="ln1235"> </a>
<a name="ln1236">	return view != NULL ? view-&gt;Frame() : BRect(0, 0, 0, 0);</a>
<a name="ln1237">}</a>
<a name="ln1238"> </a>
<a name="ln1239"> </a>
<a name="ln1240">BRect</a>
<a name="ln1241">TReplicantTray::IconFrame(const char* name)</a>
<a name="ln1242">{</a>
<a name="ln1243">	if (name == NULL)</a>
<a name="ln1244">		return BRect(0, 0, 0, 0);</a>
<a name="ln1245"> </a>
<a name="ln1246">	int32 index;</a>
<a name="ln1247">	int32 id;</a>
<a name="ln1248">	BView* view = ViewAt(&amp;index, &amp;id, name);</a>
<a name="ln1249"> </a>
<a name="ln1250">	return view != NULL ? view-&gt;Frame() : BRect(0, 0, 0, 0);</a>
<a name="ln1251">}</a>
<a name="ln1252"> </a>
<a name="ln1253"> </a>
<a name="ln1254">/**	Scan from the startIndex and reset the location</a>
<a name="ln1255"> *	as defined in LocationForReplicant()</a>
<a name="ln1256"> */</a>
<a name="ln1257"> </a>
<a name="ln1258">void</a>
<a name="ln1259">TReplicantTray::RealignReplicants(int32 startIndex)</a>
<a name="ln1260">{</a>
<a name="ln1261">	if (startIndex &lt; 0)</a>
<a name="ln1262">		startIndex = 0;</a>
<a name="ln1263"> </a>
<a name="ln1264">	int32 replicantCount = ReplicantCount();</a>
<a name="ln1265">	if (replicantCount &lt;= 0)</a>
<a name="ln1266">		return;</a>
<a name="ln1267"> </a>
<a name="ln1268">	if (startIndex == 0)</a>
<a name="ln1269">		fRightBottomReplicant.Set(0, 0, 0, 0);</a>
<a name="ln1270"> </a>
<a name="ln1271">	BView* view = NULL;</a>
<a name="ln1272">	for (int32 index = startIndex; index &lt; replicantCount; index++) {</a>
<a name="ln1273">		fShelf-&gt;ReplicantAt(index, &amp;view);</a>
<a name="ln1274">		if (view == NULL)</a>
<a name="ln1275">			continue;</a>
<a name="ln1276"> </a>
<a name="ln1277">		float replicantWidth = view-&gt;Frame().Width();</a>
<a name="ln1278">		BPoint loc = LocationForReplicant(index, replicantWidth);</a>
<a name="ln1279">		if (view-&gt;Frame().LeftTop() != loc)</a>
<a name="ln1280">			view-&gt;MoveTo(loc);</a>
<a name="ln1281">	}</a>
<a name="ln1282">}</a>
<a name="ln1283"> </a>
<a name="ln1284"> </a>
<a name="ln1285">status_t</a>
<a name="ln1286">TReplicantTray::_SaveSettings()</a>
<a name="ln1287">{</a>
<a name="ln1288">	status_t result;</a>
<a name="ln1289">	BPath path;</a>
<a name="ln1290">	if ((result = GetDeskbarSettingsDirectory(path, true)) == B_OK) {</a>
<a name="ln1291">		path.Append(kReplicantSettingsFile);</a>
<a name="ln1292"> </a>
<a name="ln1293">		BFile file(path.Path(), B_READ_WRITE | B_CREATE_FILE | B_ERASE_FILE);</a>
<a name="ln1294">		if ((result = file.InitCheck()) == B_OK)</a>
<a name="ln1295">			result = fAddOnSettings.Flatten(&amp;file);</a>
<a name="ln1296">	}</a>
<a name="ln1297"> </a>
<a name="ln1298">	return result;</a>
<a name="ln1299">}</a>
<a name="ln1300"> </a>
<a name="ln1301"> </a>
<a name="ln1302">void</a>
<a name="ln1303">TReplicantTray::SaveTimeSettings()</a>
<a name="ln1304">{</a>
<a name="ln1305">	if (fTime == NULL)</a>
<a name="ln1306">		return;</a>
<a name="ln1307"> </a>
<a name="ln1308">	clock_settings* settings = ((TBarApp*)be_app)-&gt;ClockSettings();</a>
<a name="ln1309">	settings-&gt;showSeconds = fTime-&gt;ShowSeconds();</a>
<a name="ln1310">	settings-&gt;showDayOfWeek = fTime-&gt;ShowDayOfWeek();</a>
<a name="ln1311">	settings-&gt;showTimeZone = fTime-&gt;ShowTimeZone();</a>
<a name="ln1312">}</a>
<a name="ln1313"> </a>
<a name="ln1314"> </a>
<a name="ln1315">//	#pragma mark - TDragRegion</a>
<a name="ln1316"> </a>
<a name="ln1317"> </a>
<a name="ln1318">/*! Draggable region that is asynchronous so that dragging does not block</a>
<a name="ln1319">	other activities.</a>
<a name="ln1320">*/</a>
<a name="ln1321">TDragRegion::TDragRegion(TBarView* parent, BView* replicantTray)</a>
<a name="ln1322">	:</a>
<a name="ln1323">	BControl(BRect(0, 0, 0, 0), &quot;&quot;, &quot;&quot;, NULL, B_FOLLOW_NONE,</a>
<a name="ln1324">		B_WILL_DRAW | B_FRAME_EVENTS),</a>
<a name="ln1325">	fBarView(parent),</a>
<a name="ln1326">	fReplicantTray(replicantTray),</a>
<a name="ln1327">	fDragLocation(kAutoPlaceDragRegion)</a>
<a name="ln1328">{</a>
<a name="ln1329">}</a>
<a name="ln1330"> </a>
<a name="ln1331"> </a>
<a name="ln1332">void</a>
<a name="ln1333">TDragRegion::AttachedToWindow()</a>
<a name="ln1334">{</a>
<a name="ln1335">	BView::AttachedToWindow();</a>
<a name="ln1336"> </a>
<a name="ln1337">	if (be_control_look != NULL)</a>
<a name="ln1338">		SetViewUIColor(B_MENU_BACKGROUND_COLOR, 1.1);</a>
<a name="ln1339">	else</a>
<a name="ln1340">		SetViewUIColor(B_MENU_BACKGROUND_COLOR);</a>
<a name="ln1341"> </a>
<a name="ln1342">	ResizeToPreferred();</a>
<a name="ln1343">}</a>
<a name="ln1344"> </a>
<a name="ln1345"> </a>
<a name="ln1346">void</a>
<a name="ln1347">TDragRegion::GetPreferredSize(float* width, float* height)</a>
<a name="ln1348">{</a>
<a name="ln1349">	fReplicantTray-&gt;ResizeToPreferred();</a>
<a name="ln1350">	*width = fReplicantTray-&gt;Bounds().Width();</a>
<a name="ln1351">	*height = fReplicantTray-&gt;Bounds().Height();</a>
<a name="ln1352"> </a>
<a name="ln1353">	if (fDragLocation != kNoDragRegion)</a>
<a name="ln1354">		*width += kDragWidth + kGutter;</a>
<a name="ln1355">	else</a>
<a name="ln1356">		*width += 6;</a>
<a name="ln1357"> </a>
<a name="ln1358">	*height += 2;</a>
<a name="ln1359">}</a>
<a name="ln1360"> </a>
<a name="ln1361"> </a>
<a name="ln1362">void</a>
<a name="ln1363">TDragRegion::Draw(BRect updateRect)</a>
<a name="ln1364">{</a>
<a name="ln1365">	rgb_color menuColor = ViewColor();</a>
<a name="ln1366">	rgb_color hilite = tint_color(menuColor, B_DARKEN_1_TINT);</a>
<a name="ln1367">	rgb_color ldark = tint_color(menuColor, 1.02);</a>
<a name="ln1368">	rgb_color dark = tint_color(menuColor, B_DARKEN_2_TINT);</a>
<a name="ln1369">	rgb_color vvdark = tint_color(menuColor, B_DARKEN_4_TINT);</a>
<a name="ln1370">	rgb_color light = tint_color(menuColor, B_LIGHTEN_2_TINT);</a>
<a name="ln1371"> </a>
<a name="ln1372">	BRect frame(Bounds());</a>
<a name="ln1373">	BeginLineArray(4);</a>
<a name="ln1374"> </a>
<a name="ln1375">	if (be_control_look != NULL) {</a>
<a name="ln1376">		if (fBarView-&gt;Vertical()) {</a>
<a name="ln1377">			AddLine(frame.LeftTop(), frame.RightTop(), dark);</a>
<a name="ln1378">			AddLine(BPoint(frame.left, frame.top + 1),</a>
<a name="ln1379">				BPoint(frame.right, frame.top + 1), ldark);</a>
<a name="ln1380">			AddLine(frame.LeftBottom(), frame.RightBottom(), hilite);</a>
<a name="ln1381">		} else if (fBarView-&gt;AcrossTop() || fBarView-&gt;AcrossBottom()) {</a>
<a name="ln1382">			AddLine(frame.LeftTop(),</a>
<a name="ln1383">				BPoint(frame.left, frame.bottom), dark);</a>
<a name="ln1384">			AddLine(BPoint(frame.left + 1, frame.top + 1),</a>
<a name="ln1385">				BPoint(frame.right - 1, frame.top + 1), light);</a>
<a name="ln1386">			AddLine(BPoint(frame.right, frame.top + 2),</a>
<a name="ln1387">				BPoint(frame.right, frame.bottom), hilite);</a>
<a name="ln1388">			AddLine(BPoint(frame.left + 1, frame.bottom),</a>
<a name="ln1389">				BPoint(frame.right - 1, frame.bottom), hilite);</a>
<a name="ln1390">		}</a>
<a name="ln1391">	} else {</a>
<a name="ln1392">		if (fBarView-&gt;Vertical()) {</a>
<a name="ln1393">			AddLine(frame.LeftTop(), frame.RightTop(), light);</a>
<a name="ln1394">			AddLine(frame.LeftTop(), frame.LeftBottom(), light);</a>
<a name="ln1395">			AddLine(frame.RightBottom(), frame.RightTop(), hilite);</a>
<a name="ln1396">		} else if (fBarView-&gt;AcrossTop()) {</a>
<a name="ln1397">			AddLine(BPoint(frame.left, frame.top + 1),</a>
<a name="ln1398">				BPoint(frame.right - 1, frame.top + 1), light);</a>
<a name="ln1399">			AddLine(frame.RightTop(), frame.RightBottom(), vvdark);</a>
<a name="ln1400">			AddLine(BPoint(frame.right - 1, frame.top + 2),</a>
<a name="ln1401">				BPoint(frame.right - 1, frame.bottom - 1), hilite);</a>
<a name="ln1402">			AddLine(frame.LeftBottom(),</a>
<a name="ln1403">				BPoint(frame.right - 1, frame.bottom), hilite);</a>
<a name="ln1404">		} else if (fBarView-&gt;AcrossBottom()) {</a>
<a name="ln1405">			AddLine(BPoint(frame.left, frame.top + 1),</a>
<a name="ln1406">				BPoint(frame.right - 1, frame.top + 1), light);</a>
<a name="ln1407">			AddLine(frame.LeftBottom(), frame.RightBottom(), hilite);</a>
<a name="ln1408">			AddLine(frame.RightTop(), frame.RightBottom(), vvdark);</a>
<a name="ln1409">			AddLine(BPoint(frame.right - 1, frame.top + 1),</a>
<a name="ln1410">				BPoint(frame.right - 1, frame.bottom - 1), hilite);</a>
<a name="ln1411">		}</a>
<a name="ln1412">	}</a>
<a name="ln1413"> </a>
<a name="ln1414">	EndLineArray();</a>
<a name="ln1415"> </a>
<a name="ln1416">	if (fDragLocation != kDontDrawDragRegion || fDragLocation != kNoDragRegion)</a>
<a name="ln1417">		DrawDragRegion();</a>
<a name="ln1418">}</a>
<a name="ln1419"> </a>
<a name="ln1420"> </a>
<a name="ln1421">void</a>
<a name="ln1422">TDragRegion::DrawDragRegion()</a>
<a name="ln1423">{</a>
<a name="ln1424">	BRect dragRegion(DragRegion());</a>
<a name="ln1425"> </a>
<a name="ln1426">	rgb_color menuColor = ViewColor();</a>
<a name="ln1427">	rgb_color menuHilite = menuColor;</a>
<a name="ln1428">	if (IsTracking()) {</a>
<a name="ln1429">		// draw drag region highlighted if tracking mouse</a>
<a name="ln1430">		menuHilite = tint_color(menuColor, B_HIGHLIGHT_BACKGROUND_TINT);</a>
<a name="ln1431">		SetHighColor(menuHilite);</a>
<a name="ln1432">		FillRect(dragRegion);</a>
<a name="ln1433">	} else {</a>
<a name="ln1434">		SetHighColor(menuColor);</a>
<a name="ln1435">		FillRect(dragRegion);</a>
<a name="ln1436">	}</a>
<a name="ln1437"> </a>
<a name="ln1438">	rgb_color vdark = tint_color(menuHilite, B_DARKEN_3_TINT);</a>
<a name="ln1439">	rgb_color light = tint_color(menuHilite, B_LIGHTEN_2_TINT);</a>
<a name="ln1440"> </a>
<a name="ln1441">	BeginLineArray(dragRegion.IntegerHeight());</a>
<a name="ln1442">	BPoint where;</a>
<a name="ln1443">	where.x = floorf((dragRegion.left + dragRegion.right) / 2 + 0.5) - 1;</a>
<a name="ln1444">	where.y = dragRegion.top + 2;</a>
<a name="ln1445"> </a>
<a name="ln1446">	while (where.y + 1 &lt;= dragRegion.bottom) {</a>
<a name="ln1447">		AddLine(where, where, vdark);</a>
<a name="ln1448">		AddLine(where + BPoint(1, 1), where + BPoint(1, 1), light);</a>
<a name="ln1449"> </a>
<a name="ln1450">		where.y += 3;</a>
<a name="ln1451">	}</a>
<a name="ln1452">	EndLineArray();</a>
<a name="ln1453">}</a>
<a name="ln1454"> </a>
<a name="ln1455"> </a>
<a name="ln1456">BRect</a>
<a name="ln1457">TDragRegion::DragRegion() const</a>
<a name="ln1458">{</a>
<a name="ln1459">	float kTopBottomInset = 2;</a>
<a name="ln1460">	float kLeftRightInset = 1;</a>
<a name="ln1461">	if (be_control_look != NULL) {</a>
<a name="ln1462">		kTopBottomInset = 1;</a>
<a name="ln1463">		kLeftRightInset = 0;</a>
<a name="ln1464">	}</a>
<a name="ln1465"> </a>
<a name="ln1466">	BRect dragRegion(Bounds());</a>
<a name="ln1467">	dragRegion.top += kTopBottomInset;</a>
<a name="ln1468">	dragRegion.bottom -= kTopBottomInset;</a>
<a name="ln1469"> </a>
<a name="ln1470">	bool placeOnLeft = false;</a>
<a name="ln1471">	if (fDragLocation == kAutoPlaceDragRegion) {</a>
<a name="ln1472">		if (fBarView-&gt;Vertical() &amp;&amp; fBarView-&gt;Left())</a>
<a name="ln1473">			placeOnLeft = true;</a>
<a name="ln1474">		else</a>
<a name="ln1475">			placeOnLeft = false;</a>
<a name="ln1476">	} else</a>
<a name="ln1477">		placeOnLeft = fDragLocation == kDragRegionLeft;</a>
<a name="ln1478"> </a>
<a name="ln1479">	if (placeOnLeft) {</a>
<a name="ln1480">		dragRegion.left += kLeftRightInset;</a>
<a name="ln1481">		dragRegion.right = dragRegion.left + kDragWidth;</a>
<a name="ln1482">	} else {</a>
<a name="ln1483">		dragRegion.right += kLeftRightInset;</a>
<a name="ln1484">		dragRegion.left = dragRegion.right - kDragWidth;</a>
<a name="ln1485">	}</a>
<a name="ln1486"> </a>
<a name="ln1487">	return dragRegion;</a>
<a name="ln1488">}</a>
<a name="ln1489"> </a>
<a name="ln1490"> </a>
<a name="ln1491">void</a>
<a name="ln1492">TDragRegion::MouseDown(BPoint where)</a>
<a name="ln1493">{</a>
<a name="ln1494">	uint32 buttons;</a>
<a name="ln1495">	BPoint mouseLoc;</a>
<a name="ln1496"> </a>
<a name="ln1497">	BRect dragRegion(DragRegion());</a>
<a name="ln1498">	dragRegion.InsetBy(-2, -2);</a>
<a name="ln1499">		// DragRegion() is designed for drawing, not clicking</a>
<a name="ln1500"> </a>
<a name="ln1501">	if (!dragRegion.Contains(where))</a>
<a name="ln1502">		return;</a>
<a name="ln1503"> </a>
<a name="ln1504">	while (true) {</a>
<a name="ln1505">		GetMouse(&amp;mouseLoc, &amp;buttons);</a>
<a name="ln1506">		if (buttons == 0)</a>
<a name="ln1507">			break;</a>
<a name="ln1508"> </a>
<a name="ln1509">		if ((Window()-&gt;Flags() &amp; B_ASYNCHRONOUS_CONTROLS) != 0) {</a>
<a name="ln1510">			fPreviousPosition = where;</a>
<a name="ln1511">			SetTracking(true);</a>
<a name="ln1512">			SetMouseEventMask(B_POINTER_EVENTS,</a>
<a name="ln1513">				B_NO_POINTER_HISTORY | B_LOCK_WINDOW_FOCUS);</a>
<a name="ln1514">			Invalidate(DragRegion());</a>
<a name="ln1515">			break;</a>
<a name="ln1516">		}</a>
<a name="ln1517"> </a>
<a name="ln1518">		snooze(25000);</a>
<a name="ln1519">	}</a>
<a name="ln1520">}</a>
<a name="ln1521"> </a>
<a name="ln1522"> </a>
<a name="ln1523">void</a>
<a name="ln1524">TDragRegion::MouseUp(BPoint where)</a>
<a name="ln1525">{</a>
<a name="ln1526">	if (IsTracking()) {</a>
<a name="ln1527">		SetTracking(false);</a>
<a name="ln1528">		Invalidate(DragRegion());</a>
<a name="ln1529">	} else</a>
<a name="ln1530">		BControl::MouseUp(where);</a>
<a name="ln1531">}</a>
<a name="ln1532"> </a>
<a name="ln1533"> </a>
<a name="ln1534">bool</a>
<a name="ln1535">TDragRegion::SwitchModeForRect(BPoint where, BRect rect,</a>
<a name="ln1536">	bool newVertical, bool newLeft, bool newTop, int32 newState)</a>
<a name="ln1537">{</a>
<a name="ln1538">	if (!rect.Contains(where)) {</a>
<a name="ln1539">		// not our rect</a>
<a name="ln1540">		return false;</a>
<a name="ln1541">	}</a>
<a name="ln1542"> </a>
<a name="ln1543">	if (newVertical == fBarView-&gt;Vertical() &amp;&amp; newLeft == fBarView-&gt;Left()</a>
<a name="ln1544">		&amp;&amp; newTop == fBarView-&gt;Top() &amp;&amp; newState == fBarView-&gt;State()) {</a>
<a name="ln1545">		// already in the correct mode</a>
<a name="ln1546">		return true;</a>
<a name="ln1547">	}</a>
<a name="ln1548"> </a>
<a name="ln1549">	fBarView-&gt;ChangeState(newState, newVertical, newLeft, newTop, true);</a>
<a name="ln1550"> </a>
<a name="ln1551">	return true;</a>
<a name="ln1552">}</a>
<a name="ln1553"> </a>
<a name="ln1554"> </a>
<a name="ln1555">void</a>
<a name="ln1556">TDragRegion::MouseMoved(BPoint where, uint32 code, const BMessage* message)</a>
<a name="ln1557">{</a>
<a name="ln1558">	if (IsTracking()) {</a>
<a name="ln1559">		BScreen screen;</a>
<a name="ln1560">		BRect frame = screen.Frame();</a>
<a name="ln1561"> </a>
<a name="ln1562">		float hDivider = frame.Width() / 6;</a>
<a name="ln1563">		hDivider = (hDivider &lt; gMinimumWindowWidth + 10)</a>
<a name="ln1564">			? gMinimumWindowWidth + 10 : hDivider;</a>
<a name="ln1565">		float miniDivider = frame.top + kMiniHeight + 10;</a>
<a name="ln1566">		float vDivider = frame.Height() / 2;</a>
<a name="ln1567">#ifdef FULL_MODE</a>
<a name="ln1568">		float thirdScreen = frame.Height() / 3;</a>
<a name="ln1569">#endif</a>
<a name="ln1570">		BRect topLeft(frame.left, frame.top, frame.left + hDivider,</a>
<a name="ln1571">			miniDivider);</a>
<a name="ln1572">		BRect topMiddle(frame.left + hDivider, frame.top, frame.right</a>
<a name="ln1573">			- hDivider, vDivider);</a>
<a name="ln1574">		BRect topRight(frame.right - hDivider, frame.top, frame.right,</a>
<a name="ln1575">			miniDivider);</a>
<a name="ln1576"> </a>
<a name="ln1577">#ifdef FULL_MODE</a>
<a name="ln1578">		vDivider = miniDivider + thirdScreen;</a>
<a name="ln1579">#endif</a>
<a name="ln1580">		BRect middleLeft(frame.left, miniDivider, frame.left + hDivider,</a>
<a name="ln1581">			vDivider);</a>
<a name="ln1582">		BRect middleRight(frame.right - hDivider, miniDivider, frame.right,</a>
<a name="ln1583">			vDivider);</a>
<a name="ln1584"> </a>
<a name="ln1585">#ifdef FULL_MODE</a>
<a name="ln1586">		BRect leftSide(frame.left, vDivider, frame.left + hDivider,</a>
<a name="ln1587">			frame.bottom - thirdScreen);</a>
<a name="ln1588">		BRect rightSide(frame.right - hDivider, vDivider, frame.right,</a>
<a name="ln1589">			frame.bottom - thirdScreen);</a>
<a name="ln1590"> </a>
<a name="ln1591">		vDivider = frame.bottom - thirdScreen;</a>
<a name="ln1592">#endif</a>
<a name="ln1593">		BRect bottomLeft(frame.left, vDivider, frame.left + hDivider,</a>
<a name="ln1594">			frame.bottom);</a>
<a name="ln1595">		BRect bottomMiddle(frame.left + hDivider, vDivider, frame.right</a>
<a name="ln1596">			- hDivider, frame.bottom);</a>
<a name="ln1597">		BRect bottomRight(frame.right - hDivider, vDivider, frame.right,</a>
<a name="ln1598">			frame.bottom);</a>
<a name="ln1599"> </a>
<a name="ln1600">		if (where != fPreviousPosition) {</a>
<a name="ln1601">			fPreviousPosition = where;</a>
<a name="ln1602">			ConvertToScreen(&amp;where);</a>
<a name="ln1603"> </a>
<a name="ln1604">			// use short circuit evaluation for convenience</a>
<a name="ln1605">			if (SwitchModeForRect(where, topLeft, true, true, true, kMiniState)</a>
<a name="ln1606">				|| SwitchModeForRect(where, topMiddle, false, true, true,</a>
<a name="ln1607">					kExpandoState)</a>
<a name="ln1608">				|| SwitchModeForRect(where, topRight, true, false, true,</a>
<a name="ln1609">					kMiniState)</a>
<a name="ln1610">				|| SwitchModeForRect(where, middleLeft, true, true, true,</a>
<a name="ln1611">					kExpandoState)</a>
<a name="ln1612">				|| SwitchModeForRect(where, middleRight, true, false, true,</a>
<a name="ln1613">					kExpandoState)</a>
<a name="ln1614"> </a>
<a name="ln1615">#ifdef FULL_MODE</a>
<a name="ln1616">				|| SwitchModeForRect(where, leftSide, true, true, true,</a>
<a name="ln1617">					kFullState)</a>
<a name="ln1618">				|| SwitchModeForRect(where, rightSide, true, false, true,</a>
<a name="ln1619">					kFullState)</a>
<a name="ln1620">#endif</a>
<a name="ln1621">				|| SwitchModeForRect(where, bottomLeft, true, true, false,</a>
<a name="ln1622">					kMiniState)</a>
<a name="ln1623">				|| SwitchModeForRect(where, bottomMiddle, false, true, false,</a>
<a name="ln1624">					kExpandoState)</a>
<a name="ln1625">				|| SwitchModeForRect(where, bottomRight, true, false, false,</a>
<a name="ln1626">					kMiniState))</a>
<a name="ln1627">				;</a>
<a name="ln1628">		}</a>
<a name="ln1629">	} else</a>
<a name="ln1630">		BControl::MouseMoved(where, code, message);</a>
<a name="ln1631">}</a>
<a name="ln1632"> </a>
<a name="ln1633"> </a>
<a name="ln1634">int32</a>
<a name="ln1635">TDragRegion::DragRegionLocation() const</a>
<a name="ln1636">{</a>
<a name="ln1637">	return fDragLocation;</a>
<a name="ln1638">}</a>
<a name="ln1639"> </a>
<a name="ln1640"> </a>
<a name="ln1641">void</a>
<a name="ln1642">TDragRegion::SetDragRegionLocation(int32 location)</a>
<a name="ln1643">{</a>
<a name="ln1644">	if (location == fDragLocation)</a>
<a name="ln1645">		return;</a>
<a name="ln1646"> </a>
<a name="ln1647">	fDragLocation = location;</a>
<a name="ln1648">	Invalidate();</a>
<a name="ln1649">}</a>
<a name="ln1650"> </a>
<a name="ln1651"> </a>
<a name="ln1652">//	#pragma mark - TResizeControl</a>
<a name="ln1653"> </a>
<a name="ln1654"> </a>
<a name="ln1655">/*! Draggable region that is asynchronous so that resizing does not block.</a>
<a name="ln1656">*/</a>
<a name="ln1657">TResizeControl::TResizeControl(TBarView* barView)</a>
<a name="ln1658">	:</a>
<a name="ln1659">	BControl(BRect(0, kDragWidth, 0, kMenuBarHeight), &quot;&quot;, &quot;&quot;, NULL,</a>
<a name="ln1660">		B_FOLLOW_NONE, B_WILL_DRAW | B_FRAME_EVENTS),</a>
<a name="ln1661">	fBarView(barView)</a>
<a name="ln1662">{</a>
<a name="ln1663">}</a>
<a name="ln1664"> </a>
<a name="ln1665"> </a>
<a name="ln1666">TResizeControl::~TResizeControl()</a>
<a name="ln1667">{</a>
<a name="ln1668">}</a>
<a name="ln1669"> </a>
<a name="ln1670"> </a>
<a name="ln1671">void</a>
<a name="ln1672">TResizeControl::AttachedToWindow()</a>
<a name="ln1673">{</a>
<a name="ln1674">	BView::AttachedToWindow();</a>
<a name="ln1675"> </a>
<a name="ln1676">	if (be_control_look != NULL)</a>
<a name="ln1677">		SetViewUIColor(B_MENU_BACKGROUND_COLOR, 1.1);</a>
<a name="ln1678">	else</a>
<a name="ln1679">		SetViewUIColor(B_MENU_BACKGROUND_COLOR);</a>
<a name="ln1680">}</a>
<a name="ln1681"> </a>
<a name="ln1682"> </a>
<a name="ln1683">void</a>
<a name="ln1684">TResizeControl::Draw(BRect updateRect)</a>
<a name="ln1685">{</a>
<a name="ln1686">	if (!fBarView-&gt;Vertical())</a>
<a name="ln1687">		return;</a>
<a name="ln1688"> </a>
<a name="ln1689">	BRect dragRegion(Bounds());</a>
<a name="ln1690"> </a>
<a name="ln1691">	int32 height = dragRegion.IntegerHeight();</a>
<a name="ln1692">	if (height &lt;= 0)</a>
<a name="ln1693">		return;</a>
<a name="ln1694"> </a>
<a name="ln1695">	rgb_color menuColor = ViewColor();</a>
<a name="ln1696">	rgb_color menuHilite = menuColor;</a>
<a name="ln1697">	if (IsTracking()) {</a>
<a name="ln1698">		// draw drag region highlighted if tracking mouse</a>
<a name="ln1699">		menuHilite = tint_color(menuColor, B_HIGHLIGHT_BACKGROUND_TINT);</a>
<a name="ln1700">		SetHighColor(menuHilite);</a>
<a name="ln1701">		FillRect(dragRegion);</a>
<a name="ln1702">	} else {</a>
<a name="ln1703">		SetHighColor(menuColor);</a>
<a name="ln1704">		FillRect(dragRegion);</a>
<a name="ln1705">	}</a>
<a name="ln1706"> </a>
<a name="ln1707">	rgb_color vdark = tint_color(menuHilite, B_DARKEN_3_TINT);</a>
<a name="ln1708">	rgb_color light = tint_color(menuHilite, B_LIGHTEN_2_TINT);</a>
<a name="ln1709"> </a>
<a name="ln1710">	BeginLineArray(height);</a>
<a name="ln1711">	BPoint where;</a>
<a name="ln1712">	where.x = floorf((dragRegion.left + dragRegion.right) / 2 + 0.5) - 1;</a>
<a name="ln1713">	where.y = dragRegion.top + 2;</a>
<a name="ln1714"> </a>
<a name="ln1715">	while (where.y + 1 &lt;= dragRegion.bottom) {</a>
<a name="ln1716">		AddLine(where, where, vdark);</a>
<a name="ln1717">		AddLine(where + BPoint(1, 1), where + BPoint(1, 1), light);</a>
<a name="ln1718"> </a>
<a name="ln1719">		where.y += 3;</a>
<a name="ln1720">	}</a>
<a name="ln1721">	EndLineArray();</a>
<a name="ln1722">}</a>
<a name="ln1723"> </a>
<a name="ln1724"> </a>
<a name="ln1725">void</a>
<a name="ln1726">TResizeControl::MouseDown(BPoint where)</a>
<a name="ln1727">{</a>
<a name="ln1728">	uint32 buttons;</a>
<a name="ln1729">	BPoint mouseLoc;</a>
<a name="ln1730"> </a>
<a name="ln1731">	while (true) {</a>
<a name="ln1732">		GetMouse(&amp;mouseLoc, &amp;buttons);</a>
<a name="ln1733">		if (buttons == 0)</a>
<a name="ln1734">			break;</a>
<a name="ln1735"> </a>
<a name="ln1736">		if ((Window()-&gt;Flags() &amp; B_ASYNCHRONOUS_CONTROLS) != 0) {</a>
<a name="ln1737">			SetTracking(true);</a>
<a name="ln1738">			SetMouseEventMask(B_POINTER_EVENTS,</a>
<a name="ln1739">				B_NO_POINTER_HISTORY | B_LOCK_WINDOW_FOCUS);</a>
<a name="ln1740">			Invalidate();</a>
<a name="ln1741">			break;</a>
<a name="ln1742">		}</a>
<a name="ln1743"> </a>
<a name="ln1744">		snooze(25000);</a>
<a name="ln1745">	}</a>
<a name="ln1746">}</a>
<a name="ln1747"> </a>
<a name="ln1748"> </a>
<a name="ln1749">void</a>
<a name="ln1750">TResizeControl::MouseUp(BPoint where)</a>
<a name="ln1751">{</a>
<a name="ln1752">	if (IsTracking()) {</a>
<a name="ln1753">		SetTracking(false);</a>
<a name="ln1754">		Invalidate();</a>
<a name="ln1755">	} else</a>
<a name="ln1756">		BControl::MouseUp(where);</a>
<a name="ln1757">}</a>
<a name="ln1758"> </a>
<a name="ln1759"> </a>
<a name="ln1760">void</a>
<a name="ln1761">TResizeControl::MouseMoved(BPoint where, uint32 code,</a>
<a name="ln1762">	const BMessage* dragMessage)</a>
<a name="ln1763">{</a>
<a name="ln1764">	if (fBarView-&gt;Vertical()) {</a>
<a name="ln1765">		if (IsResizing()) {</a>
<a name="ln1766">			float windowWidth = Window()-&gt;Frame().Width();</a>
<a name="ln1767">			float delta = 0;</a>
<a name="ln1768">			BPoint whereScreen = ConvertToScreen(where);</a>
<a name="ln1769"> </a>
<a name="ln1770">			if (fBarView-&gt;Left()) {</a>
<a name="ln1771">				delta = whereScreen.x - Window()-&gt;Frame().right;</a>
<a name="ln1772">				if (delta &gt; 0 &amp;&amp; windowWidth &gt;= gMaximumWindowWidth)</a>
<a name="ln1773">					; // do nothing</a>
<a name="ln1774">				else if (delta &lt; 0 &amp;&amp; windowWidth &lt;= gMinimumWindowWidth)</a>
<a name="ln1775">					; // do nothing</a>
<a name="ln1776">				else</a>
<a name="ln1777">					Window()-&gt;ResizeBy(delta, 0);</a>
<a name="ln1778">			} else {</a>
<a name="ln1779">				delta = Window()-&gt;Frame().left - whereScreen.x;</a>
<a name="ln1780">				if (delta &gt; 0 &amp;&amp; windowWidth &gt;= gMaximumWindowWidth)</a>
<a name="ln1781">					; // do nothing</a>
<a name="ln1782">				else if (delta &lt; 0 &amp;&amp; windowWidth &lt;= gMinimumWindowWidth)</a>
<a name="ln1783">					; // do nothing</a>
<a name="ln1784">				else {</a>
<a name="ln1785">					Window()-&gt;MoveBy(delta, 0);</a>
<a name="ln1786">					Window()-&gt;ResizeBy(delta, 0);</a>
<a name="ln1787">				}</a>
<a name="ln1788">			}</a>
<a name="ln1789"> </a>
<a name="ln1790">			windowWidth = Window()-&gt;Frame().Width();</a>
<a name="ln1791">		}</a>
<a name="ln1792">	}</a>
<a name="ln1793"> </a>
<a name="ln1794">	BControl::MouseMoved(where, code, dragMessage);</a>
<a name="ln1795">}</a>

</code></pre>
<div class="balloon" rel="129"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fLastReplicant, fItemList.</p></div>
<div class="balloon" rel="423"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'menu' pointer was exited without releasing the memory. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
