
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>Workspaces.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2002-2016, Haiku, Inc. All rights reserved.</a>
<a name="ln3"> * Copyright 2002, François Revol, revol@free.fr.</a>
<a name="ln4"> * This file is distributed under the terms of the MIT License.</a>
<a name="ln5"> *</a>
<a name="ln6"> * Authors:</a>
<a name="ln7"> *		François Revol, revol@free.fr</a>
<a name="ln8"> *		Axel Dörfler, axeld@pinc-software.de</a>
<a name="ln9"> *		Oliver &quot;Madison&quot; Kohl,</a>
<a name="ln10"> *		Matt Madia</a>
<a name="ln11"> *		Daniel Devine, devine@ddevnet.net</a>
<a name="ln12"> */</a>
<a name="ln13"> </a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;AboutWindow.h&gt;</a>
<a name="ln16">#include &lt;Application.h&gt;</a>
<a name="ln17">#include &lt;Catalog.h&gt;</a>
<a name="ln18">#include &lt;Deskbar.h&gt;</a>
<a name="ln19">#include &lt;Dragger.h&gt;</a>
<a name="ln20">#include &lt;Entry.h&gt;</a>
<a name="ln21">#include &lt;File.h&gt;</a>
<a name="ln22">#include &lt;FindDirectory.h&gt;</a>
<a name="ln23">#include &lt;Locale.h&gt;</a>
<a name="ln24">#include &lt;MenuItem.h&gt;</a>
<a name="ln25">#include &lt;Path.h&gt;</a>
<a name="ln26">#include &lt;PopUpMenu.h&gt;</a>
<a name="ln27">#include &lt;Roster.h&gt;</a>
<a name="ln28">#include &lt;Screen.h&gt;</a>
<a name="ln29">#include &lt;TextView.h&gt;</a>
<a name="ln30">#include &lt;Window.h&gt;</a>
<a name="ln31"> </a>
<a name="ln32">#include &lt;ctype.h&gt;</a>
<a name="ln33">#include &lt;stdio.h&gt;</a>
<a name="ln34">#include &lt;stdlib.h&gt;</a>
<a name="ln35">#include &lt;string.h&gt;</a>
<a name="ln36"> </a>
<a name="ln37">#include &lt;InterfacePrivate.h&gt;</a>
<a name="ln38">#include &lt;ViewPrivate.h&gt;</a>
<a name="ln39">#include &lt;WindowPrivate.h&gt;</a>
<a name="ln40"> </a>
<a name="ln41">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln42">#define B_TRANSLATION_CONTEXT &quot;Workspaces&quot;</a>
<a name="ln43"> </a>
<a name="ln44"> </a>
<a name="ln45">static const char* kDeskbarItemName = &quot;workspaces&quot;;</a>
<a name="ln46">static const char* kSignature = &quot;application/x-vnd.Be-WORK&quot;;</a>
<a name="ln47">static const char* kDeskbarSignature = &quot;application/x-vnd.Be-TSKB&quot;;</a>
<a name="ln48">static const char* kScreenPrefletSignature = &quot;application/x-vnd.Haiku-Screen&quot;;</a>
<a name="ln49">static const char* kOldSettingFile = &quot;Workspace_data&quot;;</a>
<a name="ln50">static const char* kSettingsFile = &quot;Workspaces_settings&quot;;</a>
<a name="ln51"> </a>
<a name="ln52">static const uint32 kMsgChangeCount = 'chWC';</a>
<a name="ln53">static const uint32 kMsgToggleTitle = 'tgTt';</a>
<a name="ln54">static const uint32 kMsgToggleBorder = 'tgBd';</a>
<a name="ln55">static const uint32 kMsgToggleAutoRaise = 'tgAR';</a>
<a name="ln56">static const uint32 kMsgToggleAlwaysOnTop = 'tgAT';</a>
<a name="ln57">static const uint32 kMsgToggleLiveInDeskbar = 'tgDb';</a>
<a name="ln58">static const uint32 kMsgToggleSwitchOnWheel = 'tgWh';</a>
<a name="ln59"> </a>
<a name="ln60"> </a>
<a name="ln61">extern &quot;C&quot; _EXPORT BView* instantiate_deskbar_item(float maxWidth,</a>
<a name="ln62">	float maxHeight);</a>
<a name="ln63"> </a>
<a name="ln64"> </a>
<a name="ln65">static status_t</a>
<a name="ln66">OpenSettingsFile(BFile&amp; file, int mode)</a>
<a name="ln67">{</a>
<a name="ln68">	BPath path;</a>
<a name="ln69">	status_t status = find_directory(B_USER_SETTINGS_DIRECTORY, &amp;path);</a>
<a name="ln70">	if (status != B_OK)</a>
<a name="ln71">		status = find_directory(B_SYSTEM_SETTINGS_DIRECTORY, &amp;path);</a>
<a name="ln72">	if (status != B_OK)</a>
<a name="ln73">		return status;</a>
<a name="ln74"> </a>
<a name="ln75">	status = path.Append(kSettingsFile);</a>
<a name="ln76">	if (status != B_OK)</a>
<a name="ln77">		return status;</a>
<a name="ln78"> </a>
<a name="ln79">	status = file.SetTo(path.Path(), mode);</a>
<a name="ln80">	if (mode == B_READ_ONLY &amp;&amp; status == B_ENTRY_NOT_FOUND) {</a>
<a name="ln81">		if (find_directory(B_SYSTEM_SETTINGS_DIRECTORY, &amp;path) == B_OK</a>
<a name="ln82">			&amp;&amp; path.Append(kSettingsFile) == B_OK) {</a>
<a name="ln83">			status = file.SetTo(path.Path(), mode);</a>
<a name="ln84">		}</a>
<a name="ln85">	}</a>
<a name="ln86"> </a>
<a name="ln87">	return status;</a>
<a name="ln88">}</a>
<a name="ln89"> </a>
<a name="ln90"> </a>
<a name="ln91">class WorkspacesSettings {</a>
<a name="ln92">	public:</a>
<a name="ln93">		WorkspacesSettings();</a>
<a name="ln94">		virtual ~WorkspacesSettings();</a>
<a name="ln95"> </a>
<a name="ln96">		BRect WindowFrame() const { return fWindowFrame; }</a>
<a name="ln97">		BRect ScreenFrame() const { return fScreenFrame; }</a>
<a name="ln98"> </a>
<a name="ln99">		bool AutoRaising() const { return fAutoRaising; }</a>
<a name="ln100">		bool AlwaysOnTop() const { return fAlwaysOnTop; }</a>
<a name="ln101">		bool HasTitle() const { return fHasTitle; }</a>
<a name="ln102">		bool HasBorder() const { return fHasBorder; }</a>
<a name="ln103">		bool SettingsLoaded() const { return fLoaded; }</a>
<a name="ln104"> </a>
<a name="ln105">		void UpdateFramesForScreen(BRect screenFrame);</a>
<a name="ln106">		void UpdateScreenFrame();</a>
<a name="ln107"> </a>
<a name="ln108">		void SetWindowFrame(BRect);</a>
<a name="ln109">		void SetAutoRaising(bool enable) { fAutoRaising = enable; }</a>
<a name="ln110">		void SetAlwaysOnTop(bool enable) { fAlwaysOnTop = enable; }</a>
<a name="ln111">		void SetHasTitle(bool enable) { fHasTitle = enable; }</a>
<a name="ln112">		void SetHasBorder(bool enable) { fHasBorder = enable; }</a>
<a name="ln113"> </a>
<a name="ln114">	private:</a>
<a name="ln115">		BRect	fWindowFrame;</a>
<a name="ln116">		BRect	fScreenFrame;</a>
<a name="ln117">		bool	fAutoRaising;</a>
<a name="ln118">		bool	fAlwaysOnTop;</a>
<a name="ln119">		bool	fHasTitle;</a>
<a name="ln120">		bool	fHasBorder;</a>
<a name="ln121">		bool	fLoaded;</a>
<a name="ln122">};</a>
<a name="ln123"> </a>
<a name="ln124">class WorkspacesView : public BView {</a>
<a name="ln125">	public:</a>
<a name="ln126">		WorkspacesView(BRect frame, bool showDragger);</a>
<a name="ln127">		WorkspacesView(BMessage* archive);</a>
<a name="ln128">		~WorkspacesView();</a>
<a name="ln129"> </a>
<a name="ln130">		static	WorkspacesView* Instantiate(BMessage* archive);</a>
<a name="ln131">		virtual	status_t Archive(BMessage* archive, bool deep = true) const;</a>
<a name="ln132"> </a>
<a name="ln133">		virtual void AttachedToWindow();</a>
<a name="ln134">		virtual void DetachedFromWindow();</a>
<a name="ln135">		virtual void FrameMoved(BPoint newPosition);</a>
<a name="ln136">		virtual void FrameResized(float newWidth, float newHeight);</a>
<a name="ln137">		virtual void MessageReceived(BMessage* message);</a>
<a name="ln138">		virtual void MouseMoved(BPoint where, uint32 transit,</a>
<a name="ln139">			const BMessage* dragMessage);</a>
<a name="ln140">		virtual void MouseDown(BPoint where);</a>
<a name="ln141"> </a>
<a name="ln142">		bool SwitchOnWheel() const { return fSwitchOnWheel; }</a>
<a name="ln143">		void SetSwitchOnWheel(bool enable);</a>
<a name="ln144"> </a>
<a name="ln145">	private:</a>
<a name="ln146">		void _AboutRequested();</a>
<a name="ln147"> </a>
<a name="ln148">		void _UpdateParentClipping();</a>
<a name="ln149">		void _ExcludeFromParentClipping();</a>
<a name="ln150">		void _CleanupParentClipping();</a>
<a name="ln151"> </a>
<a name="ln152">		friend class WorkspacesWindow;</a>
<a name="ln153"> </a>
<a name="ln154">		void _LoadSettings();</a>
<a name="ln155">		void _SaveSettings();</a>
<a name="ln156"> </a>
<a name="ln157">		BView*	fParentWhichDrawsOnChildren;</a>
<a name="ln158">		BRect	fCurrentFrame;</a>
<a name="ln159">		bool	fSwitchOnWheel;</a>
<a name="ln160">};</a>
<a name="ln161"> </a>
<a name="ln162">class WorkspacesWindow : public BWindow {</a>
<a name="ln163">	public:</a>
<a name="ln164">		WorkspacesWindow(WorkspacesSettings *settings);</a>
<a name="ln165">		virtual ~WorkspacesWindow();</a>
<a name="ln166"> </a>
<a name="ln167">		virtual void ScreenChanged(BRect frame, color_space mode);</a>
<a name="ln168">		virtual void FrameMoved(BPoint origin);</a>
<a name="ln169">		virtual void FrameResized(float width, float height);</a>
<a name="ln170">		virtual void Zoom(BPoint origin, float width, float height);</a>
<a name="ln171"> </a>
<a name="ln172">		virtual void MessageReceived(BMessage *msg);</a>
<a name="ln173">		virtual bool QuitRequested();</a>
<a name="ln174"> </a>
<a name="ln175">		void SetAutoRaise(bool enable);</a>
<a name="ln176">		bool IsAutoRaising() const { return fSettings-&gt;AutoRaising(); }</a>
<a name="ln177"> </a>
<a name="ln178">		float GetTabHeight() { return fSettings-&gt;HasTitle() ? fTabHeight : 0; }</a>
<a name="ln179">		float GetBorderWidth() { return fBorderWidth; }</a>
<a name="ln180">		float GetScreenBorderOffset() { return 2.0 * fBorderWidth; }</a>
<a name="ln181"> </a>
<a name="ln182">	private:</a>
<a name="ln183">		WorkspacesSettings *fSettings;</a>
<a name="ln184">		WorkspacesView *fWorkspacesView;</a>
<a name="ln185">		float	fTabHeight;</a>
<a name="ln186">		float	fBorderWidth;</a>
<a name="ln187">};</a>
<a name="ln188"> </a>
<a name="ln189">class WorkspacesApp : public BApplication {</a>
<a name="ln190">	public:</a>
<a name="ln191">		WorkspacesApp();</a>
<a name="ln192">		virtual ~WorkspacesApp();</a>
<a name="ln193"> </a>
<a name="ln194">		virtual void AboutRequested();</a>
<a name="ln195">		virtual void ArgvReceived(int32 argc, char **argv);</a>
<a name="ln196">		virtual void ReadyToRun();</a>
<a name="ln197"> </a>
<a name="ln198">		void Usage(const char *programName);</a>
<a name="ln199"> </a>
<a name="ln200">	private:</a>
<a name="ln201">		WorkspacesWindow*	fWindow;</a>
<a name="ln202">};</a>
<a name="ln203"> </a>
<a name="ln204"> </a>
<a name="ln205">//	#pragma mark - WorkspacesSettings</a>
<a name="ln206"> </a>
<a name="ln207"> </a>
<a name="ln208">WorkspacesSettings::WorkspacesSettings()</a>
<a name="ln209">	:</a>
<a name="ln210">	fAutoRaising(false),</a>
<a name="ln211">	fAlwaysOnTop(false),</a>
<a name="ln212">	fHasTitle(true),</a>
<a name="ln213">	fHasBorder(true),</a>
<a name="ln214">	fLoaded(false)</a>
<a name="ln215">{</a>
<a name="ln216">	UpdateScreenFrame();</a>
<a name="ln217"> </a>
<a name="ln218">	BScreen screen;</a>
<a name="ln219"> </a>
<a name="ln220">	BFile file;</a>
<a name="ln221">	if (OpenSettingsFile(file, B_READ_ONLY) == B_OK) {</a>
<a name="ln222">		BMessage settings;</a>
<a name="ln223">		if (settings.Unflatten(&amp;file) == B_OK) {</a>
<a name="ln224">			fLoaded = settings.FindRect(&quot;window&quot;, &amp;fWindowFrame) == B_OK</a>
<a name="ln225">				&amp;&amp; settings.FindRect(&quot;screen&quot;, &amp;fScreenFrame) == B_OK;</a>
<a name="ln226">			settings.FindBool(&quot;auto-raise&quot;, &amp;fAutoRaising);</a>
<a name="ln227">			settings.FindBool(&quot;always on top&quot;, &amp;fAlwaysOnTop);</a>
<a name="ln228">			if (settings.FindBool(&quot;has title&quot;, &amp;fHasTitle) != B_OK)</a>
<a name="ln229">				fHasTitle = true;</a>
<a name="ln230">			if (settings.FindBool(&quot;has border&quot;, &amp;fHasBorder) != B_OK)</a>
<a name="ln231">				fHasBorder = true;</a>
<a name="ln232">		}</a>
<a name="ln233">	} else {</a>
<a name="ln234">		// try reading BeOS compatible settings</a>
<a name="ln235">		BPath path;</a>
<a name="ln236">		if (find_directory(B_USER_SETTINGS_DIRECTORY, &amp;path) == B_OK) {</a>
<a name="ln237">			path.Append(kOldSettingFile);</a>
<a name="ln238">			BFile file(path.Path(), B_READ_ONLY);</a>
<a name="ln239">			if (file.InitCheck() == B_OK</a>
<a name="ln240">				&amp;&amp; file.Read(&amp;fWindowFrame, sizeof(BRect)) == sizeof(BRect)) {</a>
<a name="ln241">				// we now also store the frame of the screen to know</a>
<a name="ln242">				// in which context the window frame has been chosen</a>
<a name="ln243">				BRect frame;</a>
<a name="ln244">				if (file.Read(&amp;frame, sizeof(BRect)) == sizeof(BRect))</a>
<a name="ln245">					fScreenFrame = frame;</a>
<a name="ln246">				else</a>
<a name="ln247">					fScreenFrame = screen.Frame();</a>
<a name="ln248"> </a>
<a name="ln249">				fLoaded = true;</a>
<a name="ln250">			}</a>
<a name="ln251">		}</a>
<a name="ln252">	}</a>
<a name="ln253"> </a>
<a name="ln254">	if (fLoaded) {</a>
<a name="ln255">		// if the current screen frame is different from the one</a>
<a name="ln256">		// just loaded, we need to alter the window frame accordingly</a>
<a name="ln257">		if (fScreenFrame != screen.Frame())</a>
<a name="ln258">			UpdateFramesForScreen(screen.Frame());</a>
<a name="ln259">	}</a>
<a name="ln260">}</a>
<a name="ln261"> </a>
<a name="ln262"> </a>
<a name="ln263">WorkspacesSettings::~WorkspacesSettings()</a>
<a name="ln264">{</a>
<a name="ln265">	BFile file;</a>
<a name="ln266">	if (OpenSettingsFile(file, B_WRITE_ONLY | B_ERASE_FILE | B_CREATE_FILE)</a>
<a name="ln267">			!= B_OK) {</a>
<a name="ln268">		return;</a>
<a name="ln269">	}</a>
<a name="ln270"> </a>
<a name="ln271">	// switch on wheel saved by view later on</a>
<a name="ln272"> </a>
<a name="ln273">	BMessage settings('wksp');</a>
<a name="ln274">	if (settings.AddRect(&quot;window&quot;, fWindowFrame) == B_OK</a>
<a name="ln275">		&amp;&amp; settings.AddRect(&quot;screen&quot;, fScreenFrame) == B_OK</a>
<a name="ln276">		&amp;&amp; settings.AddBool(&quot;auto-raise&quot;, fAutoRaising) == B_OK</a>
<a name="ln277">		&amp;&amp; settings.AddBool(&quot;always on top&quot;, fAlwaysOnTop) == B_OK</a>
<a name="ln278">		&amp;&amp; settings.AddBool(&quot;has title&quot;, fHasTitle) == B_OK</a>
<a name="ln279">		&amp;&amp; settings.AddBool(&quot;has border&quot;, fHasBorder) == B_OK) {</a>
<a name="ln280">		settings.Flatten(&amp;file);</a>
<a name="ln281">	}</a>
<a name="ln282">}</a>
<a name="ln283"> </a>
<a name="ln284"> </a>
<a name="ln285">void</a>
<a name="ln286">WorkspacesSettings::UpdateFramesForScreen(BRect newScreenFrame)</a>
<a name="ln287">{</a>
<a name="ln288">	// don't change the position if the screen frame hasn't changed</a>
<a name="ln289">	if (newScreenFrame == fScreenFrame)</a>
<a name="ln290">		return;</a>
<a name="ln291"> </a>
<a name="ln292">	// adjust horizontal position</a>
<a name="ln293">	if (fWindowFrame.right &gt; fScreenFrame.right / 2) {</a>
<a name="ln294">		fWindowFrame.OffsetTo(newScreenFrame.right</a>
<a name="ln295">			- (fScreenFrame.right - fWindowFrame.left), fWindowFrame.top);</a>
<a name="ln296">	}</a>
<a name="ln297"> </a>
<a name="ln298">	// adjust vertical position</a>
<a name="ln299">	if (fWindowFrame.bottom &gt; fScreenFrame.bottom / 2) {</a>
<a name="ln300">		fWindowFrame.OffsetTo(fWindowFrame.left,</a>
<a name="ln301">			newScreenFrame.bottom - (fScreenFrame.bottom - fWindowFrame.top));</a>
<a name="ln302">	}</a>
<a name="ln303"> </a>
<a name="ln304">	fScreenFrame = newScreenFrame;</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307"> </a>
<a name="ln308">void</a>
<a name="ln309">WorkspacesSettings::UpdateScreenFrame()</a>
<a name="ln310">{</a>
<a name="ln311">	BScreen screen;</a>
<a name="ln312">	fScreenFrame = screen.Frame();</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315"> </a>
<a name="ln316">void</a>
<a name="ln317">WorkspacesSettings::SetWindowFrame(BRect frame)</a>
<a name="ln318">{</a>
<a name="ln319">	fWindowFrame = frame;</a>
<a name="ln320">}</a>
<a name="ln321"> </a>
<a name="ln322"> </a>
<a name="ln323">//	#pragma mark - WorkspacesView</a>
<a name="ln324"> </a>
<a name="ln325"> </a>
<a name="ln326">WorkspacesView::WorkspacesView(BRect frame, bool showDragger = true)</a>
<a name="ln327">	:</a>
<a name="ln328">	BView(frame, kDeskbarItemName, B_FOLLOW_ALL,</a>
<a name="ln329">		kWorkspacesViewFlag | B_FRAME_EVENTS),</a>
<a name="ln330">	fParentWhichDrawsOnChildren(NULL),</a>
<a name="ln331">	fCurrentFrame(frame),</a>
<a name="ln332">	fSwitchOnWheel(false)</a>
<a name="ln333">{</a>
<a name="ln334">	_LoadSettings();</a>
<a name="ln335"> </a>
<a name="ln336">	if (showDragger) {</a>
<a name="ln337">		frame.OffsetTo(B_ORIGIN);</a>
<a name="ln338">		frame.top = frame.bottom - 7;</a>
<a name="ln339">		frame.left = frame.right - 7;</a>
<a name="ln340">		BDragger* dragger = new BDragger(frame, this,</a>
<a name="ln341">			B_FOLLOW_RIGHT | B_FOLLOW_BOTTOM);</a>
<a name="ln342">		AddChild(dragger);</a>
<a name="ln343">	}</a>
<a name="ln344">}</a>
<a name="ln345"> </a>
<a name="ln346"> </a>
<a name="ln347">WorkspacesView::WorkspacesView(BMessage* archive)</a>
<a name="ln348">	:</a>
<a name="ln349">	BView(archive),</a>
<a name="ln350">	fParentWhichDrawsOnChildren(NULL),</a>
<a name="ln351">	fCurrentFrame(Frame()),</a>
<a name="ln352">	fSwitchOnWheel(false)</a>
<a name="ln353">{</a>
<a name="ln354">	_LoadSettings();</a>
<a name="ln355"> </a>
<a name="ln356">	// Just in case we are instantiated from an older archive...</a>
<a name="ln357">	SetFlags(Flags() | B_FRAME_EVENTS);</a>
<a name="ln358">	// Make sure the auto-raise feature didn't leave any artifacts - this is</a>
<a name="ln359">	// not a good idea to keep enabled for a replicant.</a>
<a name="ln360">	if (EventMask() != 0)</a>
<a name="ln361">		SetEventMask(0);</a>
<a name="ln362">}</a>
<a name="ln363"> </a>
<a name="ln364"> </a>
<a name="ln365">WorkspacesView::~WorkspacesView()</a>
<a name="ln366">{</a>
<a name="ln367">	_SaveSettings();</a>
<a name="ln368">}</a>
<a name="ln369"> </a>
<a name="ln370"> </a>
<a name="ln371">/*static*/ WorkspacesView*</a>
<a name="ln372">WorkspacesView::Instantiate(BMessage* archive)</a>
<a name="ln373">{</a>
<a name="ln374">	if (!validate_instantiation(archive, &quot;WorkspacesView&quot;))</a>
<a name="ln375">		return NULL;</a>
<a name="ln376"> </a>
<a name="ln377">	return new WorkspacesView(archive);</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380"> </a>
<a name="ln381">status_t</a>
<a name="ln382">WorkspacesView::Archive(BMessage* archive, bool deep) const</a>
<a name="ln383">{</a>
<a name="ln384">	status_t status = BView::Archive(archive, deep);</a>
<a name="ln385">	if (status == B_OK)</a>
<a name="ln386">		status = archive-&gt;AddString(&quot;add_on&quot;, kSignature);</a>
<a name="ln387">	if (status == B_OK)</a>
<a name="ln388">		status = archive-&gt;AddString(&quot;class&quot;, &quot;WorkspacesView&quot;);</a>
<a name="ln389"> </a>
<a name="ln390">	return status;</a>
<a name="ln391">}</a>
<a name="ln392"> </a>
<a name="ln393"> </a>
<a name="ln394">void</a>
<a name="ln395">WorkspacesView::_AboutRequested()</a>
<a name="ln396">{</a>
<a name="ln397">	BAboutWindow* window = new BAboutWindow(</a>
<a name="ln398">		B_TRANSLATE_SYSTEM_NAME(&quot;Workspaces&quot;), kSignature);</a>
<a name="ln399"> </a>
<a name="ln400">	const char* authors[] = {</a>
<a name="ln401">		&quot;Axel Dörfler&quot;,</a>
<a name="ln402">		&quot;Oliver \&quot;Madison\&quot; Kohl&quot;,</a>
<a name="ln403">		&quot;Matt Madia&quot;,</a>
<a name="ln404">		&quot;François Revol&quot;,</a>
<a name="ln405">		NULL</a>
<a name="ln406">	};</a>
<a name="ln407"> </a>
<a name="ln408">	const char* extraCopyrights[] = {</a>
<a name="ln409">		&quot;2002 François Revol&quot;,</a>
<a name="ln410">		NULL</a>
<a name="ln411">	};</a>
<a name="ln412"> </a>
<a name="ln413">	const char* extraInfo = &quot;Send windows behind using the Option key. &quot;</a>
<a name="ln414">		&quot;Move windows to front using the Control key.\n&quot;;</a>
<a name="ln415"> </a>
<a name="ln416">	window-&gt;AddCopyright(2002, &quot;Haiku, Inc.&quot;,</a>
<a name="ln417">			extraCopyrights);</a>
<a name="ln418">	window-&gt;AddAuthors(authors);</a>
<a name="ln419">	window-&gt;AddExtraInfo(extraInfo);</a>
<a name="ln420"> </a>
<a name="ln421">	window-&gt;Show();</a>
<a name="ln422">}</a>
<a name="ln423"> </a>
<a name="ln424"> </a>
<a name="ln425">void</a>
<a name="ln426">WorkspacesView::AttachedToWindow()</a>
<a name="ln427">{</a>
<a name="ln428">	BView* parent = Parent();</a>
<a name="ln429">	if (parent != NULL &amp;&amp; (parent-&gt;Flags() &amp; B_DRAW_ON_CHILDREN) != 0) {</a>
<a name="ln430">		fParentWhichDrawsOnChildren = parent;</a>
<a name="ln431">		_ExcludeFromParentClipping();</a>
<a name="ln432">	}</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435"> </a>
<a name="ln436">void</a>
<a name="ln437">WorkspacesView::DetachedFromWindow()</a>
<a name="ln438">{</a>
<a name="ln439">	if (fParentWhichDrawsOnChildren != NULL)</a>
<a name="ln440">		_CleanupParentClipping();</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443"> </a>
<a name="ln444">void</a>
<a name="ln445">WorkspacesView::FrameMoved(BPoint newPosition)</a>
<a name="ln446">{</a>
<a name="ln447">	_UpdateParentClipping();</a>
<a name="ln448">}</a>
<a name="ln449"> </a>
<a name="ln450"> </a>
<a name="ln451">void</a>
<a name="ln452">WorkspacesView::FrameResized(float newWidth, float newHeight)</a>
<a name="ln453">{</a>
<a name="ln454">	_UpdateParentClipping();</a>
<a name="ln455">}</a>
<a name="ln456"> </a>
<a name="ln457"> </a>
<a name="ln458">void</a>
<a name="ln459">WorkspacesView::_UpdateParentClipping()</a>
<a name="ln460">{</a>
<a name="ln461">	if (fParentWhichDrawsOnChildren != NULL) {</a>
<a name="ln462">		_CleanupParentClipping();</a>
<a name="ln463">		_ExcludeFromParentClipping();</a>
<a name="ln464">		fParentWhichDrawsOnChildren-&gt;Invalidate(fCurrentFrame);</a>
<a name="ln465">		fCurrentFrame = Frame();</a>
<a name="ln466">	}</a>
<a name="ln467">}</a>
<a name="ln468"> </a>
<a name="ln469"> </a>
<a name="ln470">void</a>
<a name="ln471">WorkspacesView::_ExcludeFromParentClipping()</a>
<a name="ln472">{</a>
<a name="ln473">	// Prevent the parent view to draw over us. Do so in a way that allows</a>
<a name="ln474">	// restoring the parent to the previous state.</a>
<a name="ln475">	fParentWhichDrawsOnChildren-&gt;PushState();</a>
<a name="ln476"> </a>
<a name="ln477">	BRegion clipping(fParentWhichDrawsOnChildren-&gt;Bounds());</a>
<a name="ln478">	clipping.Exclude(Frame());</a>
<a name="ln479">	fParentWhichDrawsOnChildren-&gt;ConstrainClippingRegion(&amp;clipping);</a>
<a name="ln480">}</a>
<a name="ln481"> </a>
<a name="ln482"> </a>
<a name="ln483">void</a>
<a name="ln484">WorkspacesView::_CleanupParentClipping()</a>
<a name="ln485">{</a>
<a name="ln486">	// Restore the previous parent state. NOTE: This relies on views</a>
<a name="ln487">	// being detached in exactly the opposite order as them being</a>
<a name="ln488">	// attached. Otherwise we would mess up states if a sibbling view did</a>
<a name="ln489">	// the same thing we did in AttachedToWindow()...</a>
<a name="ln490">	fParentWhichDrawsOnChildren-&gt;PopState();</a>
<a name="ln491">}</a>
<a name="ln492"> </a>
<a name="ln493"> </a>
<a name="ln494">void</a>
<a name="ln495">WorkspacesView::_LoadSettings()</a>
<a name="ln496">{</a>
<a name="ln497">	BFile file;</a>
<a name="ln498">	if (OpenSettingsFile(file, B_READ_ONLY) == B_OK) {</a>
<a name="ln499">		BMessage settings;</a>
<a name="ln500">		if (settings.Unflatten(&amp;file) == B_OK)</a>
<a name="ln501">			settings.FindBool(&quot;switch on wheel&quot;, &amp;fSwitchOnWheel);</a>
<a name="ln502">	}</a>
<a name="ln503">}</a>
<a name="ln504"> </a>
<a name="ln505"> </a>
<a name="ln506">void</a>
<a name="ln507">WorkspacesView::_SaveSettings()</a>
<a name="ln508">{</a>
<a name="ln509">	BFile file;</a>
<a name="ln510">	if (OpenSettingsFile(file, B_READ_ONLY | B_CREATE_FILE) != B_OK)</a>
<a name="ln511">		return;</a>
<a name="ln512"> </a>
<a name="ln513">	BMessage settings('wksp');</a>
<a name="ln514">	settings.Unflatten(&amp;file);</a>
<a name="ln515"> </a>
<a name="ln516">	if (OpenSettingsFile(file, B_WRITE_ONLY | B_ERASE_FILE) != B_OK)</a>
<a name="ln517">		return;</a>
<a name="ln518"> </a>
<a name="ln519">	if (settings.ReplaceBool(&quot;switch on wheel&quot;, fSwitchOnWheel) != B_OK)</a>
<a name="ln520">		settings.AddBool(&quot;switch on wheel&quot;, fSwitchOnWheel);</a>
<a name="ln521"> </a>
<a name="ln522">	settings.Flatten(&amp;file);</a>
<a name="ln523">}</a>
<a name="ln524"> </a>
<a name="ln525"> </a>
<a name="ln526">void</a>
<a name="ln527">WorkspacesView::MessageReceived(BMessage* message)</a>
<a name="ln528">{</a>
<a name="ln529">	switch (message-&gt;what) {</a>
<a name="ln530">		case B_ABOUT_REQUESTED:</a>
<a name="ln531">			_AboutRequested();</a>
<a name="ln532">			break;</a>
<a name="ln533"> </a>
<a name="ln534">		case B_MOUSE_WHEEL_CHANGED:</a>
<a name="ln535">		{</a>
<a name="ln536">			if (!fSwitchOnWheel)</a>
<a name="ln537">				break;</a>
<a name="ln538"> </a>
<a name="ln539">			float deltaY = message-&gt;FindFloat(&quot;be:wheel_delta_y&quot;);</a>
<a name="ln540">			if (deltaY &gt; 0.1)</a>
<a name="ln541">				activate_workspace(current_workspace() + 1);</a>
<a name="ln542">			else if (deltaY &lt; -0.1)</a>
<a name="ln543">				activate_workspace(current_workspace() - 1);</a>
<a name="ln544">			break;</a>
<a name="ln545">		}</a>
<a name="ln546"> </a>
<a name="ln547">		case kMsgChangeCount:</a>
<a name="ln548">			be_roster-&gt;Launch(kScreenPrefletSignature);</a>
<a name="ln549">			break;</a>
<a name="ln550"> </a>
<a name="ln551">		case kMsgToggleLiveInDeskbar:</a>
<a name="ln552">		{</a>
<a name="ln553">			// only actually used from the replicant itself</a>
<a name="ln554">			// since HasItem() locks up we just remove directly.</a>
<a name="ln555">			BDeskbar deskbar;</a>
<a name="ln556">			// we shouldn't do this here actually, but it works for now...</a>
<a name="ln557">			deskbar.RemoveItem(kDeskbarItemName);</a>
<a name="ln558">			break;</a>
<a name="ln559">		}</a>
<a name="ln560"> </a>
<a name="ln561">		case kMsgToggleSwitchOnWheel:</a>
<a name="ln562">		{</a>
<a name="ln563">			fSwitchOnWheel = !fSwitchOnWheel;</a>
<a name="ln564">			break;</a>
<a name="ln565">		}</a>
<a name="ln566"> </a>
<a name="ln567">		default:</a>
<a name="ln568">			BView::MessageReceived(message);</a>
<a name="ln569">			break;</a>
<a name="ln570">	}</a>
<a name="ln571">}</a>
<a name="ln572"> </a>
<a name="ln573"> </a>
<a name="ln574">void</a>
<a name="ln575">WorkspacesView::MouseMoved(BPoint where, uint32 transit,</a>
<a name="ln576">	const BMessage* dragMessage)</a>
<a name="ln577">{</a>
<a name="ln578">	WorkspacesWindow* window = dynamic_cast&lt;WorkspacesWindow*&gt;(Window());</a>
<a name="ln579">	if (window == NULL || !window-&gt;IsAutoRaising())</a>
<a name="ln580">		return;</a>
<a name="ln581"> </a>
<a name="ln582">	// Auto-Raise</a>
<a name="ln583"> </a>
<a name="ln584">	where = ConvertToScreen(where);</a>
<a name="ln585">	BScreen screen(window);</a>
<a name="ln586">	BRect screenFrame = screen.Frame();</a>
<a name="ln587">	BRect windowFrame = window-&gt;Frame();</a>
<a name="ln588">	float tabHeight = window-&gt;GetTabHeight();</a>
<a name="ln589">	float borderWidth = window-&gt;GetBorderWidth();</a>
<a name="ln590"> </a>
<a name="ln591">	if (where.x == screenFrame.left || where.x == screenFrame.right</a>
<a name="ln592">			|| where.y == screenFrame.top || where.y == screenFrame.bottom) {</a>
<a name="ln593">		// cursor is on screen edge</a>
<a name="ln594"> </a>
<a name="ln595">		// Stretch frame to also accept mouse moves over the window borders</a>
<a name="ln596">		windowFrame.InsetBy(-borderWidth, -(tabHeight + borderWidth));</a>
<a name="ln597"> </a>
<a name="ln598">		if (windowFrame.Contains(where))</a>
<a name="ln599">			window-&gt;Activate();</a>
<a name="ln600">	}</a>
<a name="ln601">}</a>
<a name="ln602"> </a>
<a name="ln603"> </a>
<a name="ln604">void</a>
<a name="ln605">WorkspacesView::MouseDown(BPoint where)</a>
<a name="ln606">{</a>
<a name="ln607">	// With enabled auto-raise feature, we'll get mouse messages we don't</a>
<a name="ln608">	// want to handle here.</a>
<a name="ln609">	if (!Bounds().Contains(where))</a>
<a name="ln610">		return;</a>
<a name="ln611"> </a>
<a name="ln612">	int32 buttons = 0;</a>
<a name="ln613">	if (Window() != NULL &amp;&amp; Window()-&gt;CurrentMessage() != NULL)</a>
<a name="ln614">		Window()-&gt;CurrentMessage()-&gt;FindInt32(&quot;buttons&quot;, &amp;buttons);</a>
<a name="ln615"> </a>
<a name="ln616">	if ((buttons &amp; B_SECONDARY_MOUSE_BUTTON) == 0)</a>
<a name="ln617">		return;</a>
<a name="ln618"> </a>
<a name="ln619">	// open context menu</a>
<a name="ln620"> </a>
<a name="ln621">	BPopUpMenu *menu = new BPopUpMenu(B_EMPTY_STRING, false, false);</a>
<a name="ln622">	menu-&gt;SetFont(be_plain_font);</a>
<a name="ln623"> </a>
<a name="ln624">	// TODO: alternatively change the count here directly?</a>
<a name="ln625">	BMenuItem* changeItem = new BMenuItem(B_TRANSLATE(&quot;Change workspace count&quot;</a>
<a name="ln626">		B_UTF8_ELLIPSIS), new BMessage(kMsgChangeCount));</a>
<a name="ln627">	menu-&gt;AddItem(changeItem);</a>
<a name="ln628"> </a>
<a name="ln629">	BMenuItem* switchItem = new BMenuItem(B_TRANSLATE(&quot;Switch on mouse wheel&quot;),</a>
<a name="ln630">		new BMessage(kMsgToggleSwitchOnWheel));</a>
<a name="ln631">	menu-&gt;AddItem(switchItem);</a>
<a name="ln632">	switchItem-&gt;SetMarked(fSwitchOnWheel);</a>
<a name="ln633"> </a>
<a name="ln634">	WorkspacesWindow *window = dynamic_cast&lt;WorkspacesWindow*&gt;(Window());</a>
<a name="ln635">	if (window != NULL) {</a>
<a name="ln636">		// inside Workspaces app</a>
<a name="ln637">		BMenuItem* item;</a>
<a name="ln638"> </a>
<a name="ln639">		menu-&gt;AddSeparatorItem();</a>
<a name="ln640">		menu-&gt;AddItem(item = new BMenuItem(B_TRANSLATE(&quot;Show window tab&quot;),</a>
<a name="ln641">			new BMessage(kMsgToggleTitle)));</a>
<a name="ln642">		if (window-&gt;Look() == B_TITLED_WINDOW_LOOK)</a>
<a name="ln643">			item-&gt;SetMarked(true);</a>
<a name="ln644">		menu-&gt;AddItem(item = new BMenuItem(B_TRANSLATE(&quot;Show window border&quot;),</a>
<a name="ln645">			new BMessage(kMsgToggleBorder)));</a>
<a name="ln646">		if (window-&gt;Look() == B_TITLED_WINDOW_LOOK</a>
<a name="ln647">			|| window-&gt;Look() == B_MODAL_WINDOW_LOOK) {</a>
<a name="ln648">			item-&gt;SetMarked(true);</a>
<a name="ln649">		}</a>
<a name="ln650"> </a>
<a name="ln651">		menu-&gt;AddSeparatorItem();</a>
<a name="ln652">		menu-&gt;AddItem(item = new BMenuItem(B_TRANSLATE(&quot;Always on top&quot;),</a>
<a name="ln653">			new BMessage(kMsgToggleAlwaysOnTop)));</a>
<a name="ln654">		if (window-&gt;Feel() == B_FLOATING_ALL_WINDOW_FEEL)</a>
<a name="ln655">			item-&gt;SetMarked(true);</a>
<a name="ln656">		menu-&gt;AddItem(item = new BMenuItem(B_TRANSLATE(&quot;Auto-raise&quot;),</a>
<a name="ln657">			new BMessage(kMsgToggleAutoRaise)));</a>
<a name="ln658">		if (window-&gt;IsAutoRaising())</a>
<a name="ln659">			item-&gt;SetMarked(true);</a>
<a name="ln660">		if (be_roster-&gt;IsRunning(kDeskbarSignature)) {</a>
<a name="ln661">			menu-&gt;AddItem(item = new BMenuItem(</a>
<a name="ln662">				B_TRANSLATE(&quot;Live in the Deskbar&quot;),</a>
<a name="ln663">				new BMessage(kMsgToggleLiveInDeskbar)));</a>
<a name="ln664">			BDeskbar deskbar;</a>
<a name="ln665">			item-&gt;SetMarked(deskbar.HasItem(kDeskbarItemName));</a>
<a name="ln666">		}</a>
<a name="ln667"> </a>
<a name="ln668">		menu-&gt;AddSeparatorItem();</a>
<a name="ln669">		menu-&gt;AddItem(new BMenuItem(B_TRANSLATE(&quot;Quit&quot;),</a>
<a name="ln670">			new BMessage(B_QUIT_REQUESTED)));</a>
<a name="ln671">		menu-&gt;SetTargetForItems(window);</a>
<a name="ln672">	} else {</a>
<a name="ln673">		// we're replicated in some way...</a>
<a name="ln674">		BMenuItem* item;</a>
<a name="ln675"> </a>
<a name="ln676">		menu-&gt;AddSeparatorItem();</a>
<a name="ln677"> </a>
<a name="ln678">		// check which way</a>
<a name="ln679">		BDragger *dragger = dynamic_cast&lt;BDragger*&gt;(ChildAt(0));</a>
<a name="ln680">		if (dragger) {</a>
<a name="ln681">			// replicant</a>
<a name="ln682">			menu-&gt;AddItem(item = new BMenuItem(B_TRANSLATE(&quot;Remove replicant&quot;),</a>
<a name="ln683">				new BMessage(B_TRASH_TARGET)));</a>
<a name="ln684">			item-&gt;SetTarget(dragger);</a>
<a name="ln685">		} else {</a>
<a name="ln686">			// Deskbar item</a>
<a name="ln687">			menu-&gt;AddItem(item = new BMenuItem(B_TRANSLATE(&quot;Remove replicant&quot;),</a>
<a name="ln688">				new BMessage(kMsgToggleLiveInDeskbar)));</a>
<a name="ln689">			item-&gt;SetTarget(this);</a>
<a name="ln690">		}</a>
<a name="ln691">	}</a>
<a name="ln692"> </a>
<a name="ln693">	changeItem-&gt;SetTarget(this);</a>
<a name="ln694">	switchItem-&gt;SetTarget(this);</a>
<a name="ln695"> </a>
<a name="ln696">	ConvertToScreen(&amp;where);</a>
<a name="ln697">	menu-&gt;Go(where, true, true, true);</a>
<a name="ln698">}</a>
<a name="ln699"> </a>
<a name="ln700"> </a>
<a name="ln701">void</a>
<a name="ln702">WorkspacesView::SetSwitchOnWheel(bool enable)</a>
<a name="ln703">{</a>
<a name="ln704">	if (enable == fSwitchOnWheel)</a>
<a name="ln705">		return;</a>
<a name="ln706"> </a>
<a name="ln707">	fSwitchOnWheel = enable;</a>
<a name="ln708">}</a>
<a name="ln709"> </a>
<a name="ln710"> </a>
<a name="ln711">//	#pragma mark - WorkspacesWindow</a>
<a name="ln712"> </a>
<a name="ln713"> </a>
<a name="ln714">WorkspacesWindow::WorkspacesWindow(WorkspacesSettings *settings)</a>
<a name="ln715">	:</a>
<a name="ln716">	BWindow(settings-&gt;WindowFrame(), B_TRANSLATE_SYSTEM_NAME(&quot;Workspaces&quot;),</a>
<a name="ln717">		B_TITLED_WINDOW_LOOK, B_NORMAL_WINDOW_FEEL,</a>
<a name="ln718">		B_AVOID_FRONT | B_WILL_ACCEPT_FIRST_CLICK | B_CLOSE_ON_ESCAPE,</a>
<a name="ln719">		B_ALL_WORKSPACES),</a>
<a name="ln720">	fSettings(settings),</a>
<a name="ln721">	fWorkspacesView(NULL)</a>
<a name="ln722">{</a>
<a name="ln723">	// Turn window decor on to grab decor widths.</a>
<a name="ln724">	BMessage windowSettings;</a>
<a name="ln725">	float borderWidth = 0;</a>
<a name="ln726"> </a>
<a name="ln727">	SetLook(B_TITLED_WINDOW_LOOK);</a>
<a name="ln728">	if (GetDecoratorSettings(&amp;windowSettings) == B_OK) {</a>
<a name="ln729">		BRect tabFrame = windowSettings.FindRect(&quot;tab frame&quot;);</a>
<a name="ln730">		borderWidth = windowSettings.FindFloat(&quot;border width&quot;);</a>
<a name="ln731">		fTabHeight = tabFrame.Height();</a>
<a name="ln732">		fBorderWidth = borderWidth;</a>
<a name="ln733">	}</a>
<a name="ln734"> </a>
<a name="ln735">	if (!fSettings-&gt;SettingsLoaded()) {</a>
<a name="ln736">		// No settings, compute a reasonable default frame.</a>
<a name="ln737">		// We aim for previews at 10% of actual screen size, and matching the</a>
<a name="ln738">		// aspect ratio. We then scale that down, until it fits the screen.</a>
<a name="ln739">		// Finally, we put the window on the bottom right of the screen so the</a>
<a name="ln740">		// auto-raise mode can be used.</a>
<a name="ln741"> </a>
<a name="ln742">		BScreen screen;</a>
<a name="ln743"> </a>
<a name="ln744">		float screenWidth = screen.Frame().Width();</a>
<a name="ln745">		float screenHeight = screen.Frame().Height();</a>
<a name="ln746">		float aspectRatio = screenWidth / screenHeight;</a>
<a name="ln747"> </a>
<a name="ln748">		uint32 columns, rows;</a>
<a name="ln749">		BPrivate::get_workspaces_layout(&amp;columns, &amp;rows);</a>
<a name="ln750"> </a>
<a name="ln751">		// default size of ~1/10 of screen width</a>
<a name="ln752">		float workspaceWidth = screenWidth / 10;</a>
<a name="ln753">		float workspaceHeight = workspaceWidth / aspectRatio;</a>
<a name="ln754"> </a>
<a name="ln755">		float width = floor(workspaceWidth * columns);</a>
<a name="ln756">		float height = floor(workspaceHeight * rows);</a>
<a name="ln757"> </a>
<a name="ln758">		// If you have too many workspaces to fit on the screen, shrink until</a>
<a name="ln759">		// they fit.</a>
<a name="ln760">		while (width + 2 * borderWidth &gt; screenWidth</a>
<a name="ln761">				|| height + 2 * borderWidth + GetTabHeight() &gt; screenHeight) {</a>
<a name="ln762">			width = floor(0.95 * width);</a>
<a name="ln763">			height = floor(0.95 * height);</a>
<a name="ln764">		}</a>
<a name="ln765"> </a>
<a name="ln766">		BRect frame = fSettings-&gt;ScreenFrame();</a>
<a name="ln767">		frame.OffsetBy(-2.0 * borderWidth, -2.0 * borderWidth);</a>
<a name="ln768">		frame.left = frame.right - width;</a>
<a name="ln769">		frame.top = frame.bottom - height;</a>
<a name="ln770">		ResizeTo(frame.Width(), frame.Height());</a>
<a name="ln771"> </a>
<a name="ln772">		// Put it in bottom corner by default.</a>
<a name="ln773">		MoveTo(screenWidth - frame.Width() - borderWidth,</a>
<a name="ln774">			screenHeight - frame.Height() - borderWidth);</a>
<a name="ln775"> </a>
<a name="ln776">		fSettings-&gt;SetWindowFrame(frame);</a>
<a name="ln777">	}</a>
<a name="ln778"> </a>
<a name="ln779">	if (!fSettings-&gt;HasBorder())</a>
<a name="ln780">		SetLook(B_NO_BORDER_WINDOW_LOOK);</a>
<a name="ln781">	else if (!fSettings-&gt;HasTitle())</a>
<a name="ln782">		SetLook(B_MODAL_WINDOW_LOOK);</a>
<a name="ln783"> </a>
<a name="ln784">	fWorkspacesView = new WorkspacesView(Bounds());</a>
<a name="ln785">	AddChild(fWorkspacesView);</a>
<a name="ln786"> </a>
<a name="ln787">	if (fSettings-&gt;AlwaysOnTop())</a>
<a name="ln788">		SetFeel(B_FLOATING_ALL_WINDOW_FEEL);</a>
<a name="ln789">	else</a>
<a name="ln790">		SetAutoRaise(fSettings-&gt;AutoRaising());</a>
<a name="ln791">}</a>
<a name="ln792"> </a>
<a name="ln793"> </a>
<a name="ln794">WorkspacesWindow::~WorkspacesWindow()</a>
<a name="ln795">{</a>
<a name="ln796">	delete fSettings;</a>
<a name="ln797">}</a>
<a name="ln798"> </a>
<a name="ln799"> </a>
<a name="ln800">void</a>
<a name="ln801">WorkspacesWindow::ScreenChanged(BRect rect, color_space mode)</a>
<a name="ln802">{</a>
<a name="ln803">	fSettings-&gt;UpdateFramesForScreen(rect);</a>
<a name="ln804">	MoveTo(fSettings-&gt;WindowFrame().LeftTop());</a>
<a name="ln805">}</a>
<a name="ln806"> </a>
<a name="ln807"> </a>
<a name="ln808">void</a>
<a name="ln809">WorkspacesWindow::FrameMoved(BPoint origin)</a>
<a name="ln810">{</a>
<a name="ln811">	fSettings-&gt;SetWindowFrame(Frame());</a>
<a name="ln812">}</a>
<a name="ln813"> </a>
<a name="ln814"> </a>
<a name="ln815">void</a>
<a name="ln816">WorkspacesWindow::FrameResized(float width, float height)</a>
<a name="ln817">{</a>
<a name="ln818">	if (!(modifiers() &amp; B_SHIFT_KEY)) {</a>
<a name="ln819">		BWindow::FrameResized(width, height);</a>
<a name="ln820">		return;</a>
<a name="ln821">	}</a>
<a name="ln822"> </a>
<a name="ln823">	uint32 columns, rows;</a>
<a name="ln824">	BPrivate::get_workspaces_layout(&amp;columns, &amp;rows);</a>
<a name="ln825"> </a>
<a name="ln826">	BScreen screen;</a>
<a name="ln827">	float screenWidth = screen.Frame().Width();</a>
<a name="ln828">	float screenHeight = screen.Frame().Height();</a>
<a name="ln829"> </a>
<a name="ln830">	float windowAspectRatio</a>
<a name="ln831">		= (columns * screenWidth) / (rows * screenHeight);</a>
<a name="ln832"> </a>
<a name="ln833">	float newHeight = width / windowAspectRatio;</a>
<a name="ln834"> </a>
<a name="ln835">	if (height != newHeight)</a>
<a name="ln836">		ResizeTo(width, newHeight);</a>
<a name="ln837"> </a>
<a name="ln838">	fSettings-&gt;SetWindowFrame(Frame());</a>
<a name="ln839">}</a>
<a name="ln840"> </a>
<a name="ln841"> </a>
<a name="ln842">void</a>
<a name="ln843">WorkspacesWindow::Zoom(BPoint origin, float width, float height)</a>
<a name="ln844">{</a>
<a name="ln845">	BScreen screen;</a>
<a name="ln846">	float screenWidth = screen.Frame().Width();</a>
<a name="ln847">	float screenHeight = screen.Frame().Height();</a>
<a name="ln848">	float aspectRatio = screenWidth / screenHeight;</a>
<a name="ln849"> </a>
<a name="ln850">	uint32 columns, rows;</a>
<a name="ln851">	BPrivate::get_workspaces_layout(&amp;columns, &amp;rows);</a>
<a name="ln852"> </a>
<a name="ln853">	float workspaceWidth = Frame().Width() / columns;</a>
<a name="ln854">	float workspaceHeight = workspaceWidth / aspectRatio;</a>
<a name="ln855"> </a>
<a name="ln856">	width = floor(workspaceWidth * columns);</a>
<a name="ln857">	height = floor(workspaceHeight * rows);</a>
<a name="ln858"> </a>
<a name="ln859">	while (width + 2 * GetScreenBorderOffset() &gt; screenWidth</a>
<a name="ln860">		|| height + 2 * GetScreenBorderOffset() + GetTabHeight()</a>
<a name="ln861">			&gt; screenHeight) {</a>
<a name="ln862">		width = floor(0.95 * width);</a>
<a name="ln863">		height = floor(0.95 * height);</a>
<a name="ln864">	}</a>
<a name="ln865"> </a>
<a name="ln866">	ResizeTo(width, height);</a>
<a name="ln867"> </a>
<a name="ln868">	if (fSettings-&gt;AutoRaising()) {</a>
<a name="ln869">		// The auto-raising mode makes sense only if the window is positionned</a>
<a name="ln870">		// exactly in the bottom-right corner. If the setting is enabled, move</a>
<a name="ln871">		// the window there.</a>
<a name="ln872">		origin = screen.Frame().RightBottom();</a>
<a name="ln873">		origin.x -= GetScreenBorderOffset() + width;</a>
<a name="ln874">		origin.y -= GetScreenBorderOffset() + height;</a>
<a name="ln875"> </a>
<a name="ln876">		MoveTo(origin);</a>
<a name="ln877">	}</a>
<a name="ln878">}</a>
<a name="ln879"> </a>
<a name="ln880"> </a>
<a name="ln881">void</a>
<a name="ln882">WorkspacesWindow::MessageReceived(BMessage *message)</a>
<a name="ln883">{</a>
<a name="ln884">	switch (message-&gt;what) {</a>
<a name="ln885">		case B_SIMPLE_DATA:</a>
<a name="ln886">		{</a>
<a name="ln887">			// Drop from Tracker</a>
<a name="ln888">			entry_ref ref;</a>
<a name="ln889">			for (int i = 0; (message-&gt;FindRef(&quot;refs&quot;, i, &amp;ref) == B_OK); i++)</a>
<a name="ln890">				be_roster-&gt;Launch(&amp;ref);</a>
<a name="ln891">			break;</a>
<a name="ln892">		}</a>
<a name="ln893"> </a>
<a name="ln894">		case B_ABOUT_REQUESTED:</a>
<a name="ln895">			PostMessage(message, ChildAt(0));</a>
<a name="ln896">			break;</a>
<a name="ln897"> </a>
<a name="ln898">		case kMsgToggleBorder:</a>
<a name="ln899">		{</a>
<a name="ln900">			bool enable = false;</a>
<a name="ln901">			if (Look() == B_NO_BORDER_WINDOW_LOOK)</a>
<a name="ln902">				enable = true;</a>
<a name="ln903"> </a>
<a name="ln904">			if (enable)</a>
<a name="ln905">				if (fSettings-&gt;HasTitle())</a>
<a name="ln906">					SetLook(B_TITLED_WINDOW_LOOK);</a>
<a name="ln907">				else</a>
<a name="ln908">					SetLook(B_MODAL_WINDOW_LOOK);</a>
<a name="ln909">			else</a>
<a name="ln910">				SetLook(B_NO_BORDER_WINDOW_LOOK);</a>
<a name="ln911"> </a>
<a name="ln912">			fSettings-&gt;SetHasBorder(enable);</a>
<a name="ln913">			break;</a>
<a name="ln914">		}</a>
<a name="ln915"> </a>
<a name="ln916">		case kMsgToggleTitle:</a>
<a name="ln917">		{</a>
<a name="ln918">			bool enable = false;</a>
<a name="ln919">			if (Look() == B_MODAL_WINDOW_LOOK</a>
<a name="ln920">				|| Look() == B_NO_BORDER_WINDOW_LOOK)</a>
<a name="ln921">				enable = true;</a>
<a name="ln922"> </a>
<a name="ln923">			if (enable)</a>
<a name="ln924">				SetLook(B_TITLED_WINDOW_LOOK);</a>
<a name="ln925">			else</a>
<a name="ln926">				SetLook(B_MODAL_WINDOW_LOOK);</a>
<a name="ln927"> </a>
<a name="ln928">			// No matter what the setting for title, we must force the border on</a>
<a name="ln929">			fSettings-&gt;SetHasBorder(true);</a>
<a name="ln930">			fSettings-&gt;SetHasTitle(enable);</a>
<a name="ln931">			break;</a>
<a name="ln932">		}</a>
<a name="ln933"> </a>
<a name="ln934">		case kMsgToggleAutoRaise:</a>
<a name="ln935">			SetAutoRaise(!IsAutoRaising());</a>
<a name="ln936">			SetFeel(B_NORMAL_WINDOW_FEEL);</a>
<a name="ln937">			break;</a>
<a name="ln938"> </a>
<a name="ln939">		case kMsgToggleAlwaysOnTop:</a>
<a name="ln940">		{</a>
<a name="ln941">			bool enable = false;</a>
<a name="ln942">			if (Feel() != B_FLOATING_ALL_WINDOW_FEEL)</a>
<a name="ln943">				enable = true;</a>
<a name="ln944"> </a>
<a name="ln945">			if (enable)</a>
<a name="ln946">				SetFeel(B_FLOATING_ALL_WINDOW_FEEL);</a>
<a name="ln947">			else</a>
<a name="ln948">				SetFeel(B_NORMAL_WINDOW_FEEL);</a>
<a name="ln949"> </a>
<a name="ln950">			fSettings-&gt;SetAlwaysOnTop(enable);</a>
<a name="ln951">			break;</a>
<a name="ln952">		}</a>
<a name="ln953"> </a>
<a name="ln954">		case kMsgToggleLiveInDeskbar:</a>
<a name="ln955">		{</a>
<a name="ln956">			BDeskbar deskbar;</a>
<a name="ln957">			if (deskbar.HasItem(kDeskbarItemName))</a>
<a name="ln958">				deskbar.RemoveItem(kDeskbarItemName);</a>
<a name="ln959">			else {</a>
<a name="ln960">				fWorkspacesView-&gt;_SaveSettings();</a>
<a name="ln961">					// save &quot;switch on wheel&quot; setting for replicant to load</a>
<a name="ln962">				entry_ref ref;</a>
<a name="ln963">				be_roster-&gt;FindApp(kSignature, &amp;ref);</a>
<a name="ln964">				deskbar.AddItem(&amp;ref);</a>
<a name="ln965">			}</a>
<a name="ln966">			break;</a>
<a name="ln967">		}</a>
<a name="ln968"> </a>
<a name="ln969">		default:</a>
<a name="ln970">			BWindow::MessageReceived(message);</a>
<a name="ln971">			break;</a>
<a name="ln972">	}</a>
<a name="ln973">}</a>
<a name="ln974"> </a>
<a name="ln975"> </a>
<a name="ln976">bool</a>
<a name="ln977">WorkspacesWindow::QuitRequested()</a>
<a name="ln978">{</a>
<a name="ln979">	be_app-&gt;PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln980">	return true;</a>
<a name="ln981">}</a>
<a name="ln982"> </a>
<a name="ln983"> </a>
<a name="ln984">void</a>
<a name="ln985">WorkspacesWindow::SetAutoRaise(bool enable)</a>
<a name="ln986">{</a>
<a name="ln987">	fSettings-&gt;SetAutoRaising(enable);</a>
<a name="ln988"> </a>
<a name="ln989">	if (enable)</a>
<a name="ln990">		ChildAt(0)-&gt;SetEventMask(B_POINTER_EVENTS, B_NO_POINTER_HISTORY);</a>
<a name="ln991">	else</a>
<a name="ln992">		ChildAt(0)-&gt;SetEventMask(0);</a>
<a name="ln993">}</a>
<a name="ln994"> </a>
<a name="ln995"> </a>
<a name="ln996">//	#pragma mark - WorkspacesApp</a>
<a name="ln997"> </a>
<a name="ln998"> </a>
<a name="ln999">WorkspacesApp::WorkspacesApp()</a>
<a name="ln1000">	: BApplication(kSignature)</a>
<a name="ln1001">{</a>
<a name="ln1002">	fWindow = new WorkspacesWindow(new WorkspacesSettings());</a>
<a name="ln1003">}</a>
<a name="ln1004"> </a>
<a name="ln1005"> </a>
<a name="ln1006">WorkspacesApp::~WorkspacesApp()</a>
<a name="ln1007">{</a>
<a name="ln1008">}</a>
<a name="ln1009"> </a>
<a name="ln1010"> </a>
<a name="ln1011">void</a>
<a name="ln1012">WorkspacesApp::AboutRequested()</a>
<a name="ln1013">{</a>
<a name="ln1014">	fWindow-&gt;PostMessage(B_ABOUT_REQUESTED);</a>
<a name="ln1015">}</a>
<a name="ln1016"> </a>
<a name="ln1017"> </a>
<a name="ln1018">void</a>
<a name="ln1019">WorkspacesApp::Usage(const char *programName)</a>
<a name="ln1020">{</a>
<a name="ln1021">	printf(B_TRANSLATE(&quot;Usage: %s [options] [workspace]\n&quot;</a>
<a name="ln1022">		&quot;where \&quot;options\&quot; are:\n&quot;</a>
<a name="ln1023">		&quot;  --notitle\t\ttitle bar removed, border and resize kept\n&quot;</a>
<a name="ln1024">		&quot;  --noborder\t\ttitle, border, and resize removed\n&quot;</a>
<a name="ln1025">		&quot;  --avoidfocus\t\tprevents the window from being the target of &quot;</a>
<a name="ln1026">		&quot;keyboard events\n&quot;</a>
<a name="ln1027">		&quot;  --alwaysontop\t\tkeeps window on top\n&quot;</a>
<a name="ln1028">		&quot;  --notmovable\t\twindow can't be moved around\n&quot;</a>
<a name="ln1029">		&quot;  --autoraise\t\tauto-raise the workspace window when it's at the &quot;</a>
<a name="ln1030">		&quot;screen edge\n&quot;</a>
<a name="ln1031">		&quot;  --help\t\tdisplay this help and exit\n&quot;</a>
<a name="ln1032">		&quot;and \&quot;workspace\&quot; is the number of the Workspace to which to switch &quot;</a>
<a name="ln1033">		&quot;(0-31)\n&quot;),</a>
<a name="ln1034">		programName);</a>
<a name="ln1035"> </a>
<a name="ln1036">	// quit only if we aren't running already</a>
<a name="ln1037">	if (IsLaunching())</a>
<a name="ln1038">		Quit();</a>
<a name="ln1039">}</a>
<a name="ln1040"> </a>
<a name="ln1041"> </a>
<a name="ln1042">void</a>
<a name="ln1043">WorkspacesApp::ArgvReceived(int32 argc, char **argv)</a>
<a name="ln1044">{</a>
<a name="ln1045">	for (int i = 1;  i &lt; argc;  i++) {</a>
<a name="ln1046">		if (argv[i][0] == '-' &amp;&amp; argv[i][1] == '-') {</a>
<a name="ln1047">			// evaluate --arguments</a>
<a name="ln1048">			if (!strcmp(argv[i], &quot;--notitle&quot;))</a>
<a name="ln1049">				fWindow-&gt;SetLook(B_MODAL_WINDOW_LOOK);</a>
<a name="ln1050">			else if (!strcmp(argv[i], &quot;--noborder&quot;))</a>
<a name="ln1051">				fWindow-&gt;SetLook(B_NO_BORDER_WINDOW_LOOK);</a>
<a name="ln1052">			else if (!strcmp(argv[i], &quot;--avoidfocus&quot;))</a>
<a name="ln1053">				fWindow-&gt;SetFlags(fWindow-&gt;Flags() | B_AVOID_FOCUS);</a>
<a name="ln1054">			else if (!strcmp(argv[i], &quot;--notmovable&quot;))</a>
<a name="ln1055">				fWindow-&gt;SetFlags(fWindow-&gt;Flags() | B_NOT_MOVABLE);</a>
<a name="ln1056">			else if (!strcmp(argv[i], &quot;--alwaysontop&quot;))</a>
<a name="ln1057">				fWindow-&gt;SetFeel(B_FLOATING_ALL_WINDOW_FEEL);</a>
<a name="ln1058">			else if (!strcmp(argv[i], &quot;--autoraise&quot;))</a>
<a name="ln1059">				fWindow-&gt;SetAutoRaise(true);</a>
<a name="ln1060">			else {</a>
<a name="ln1061">				const char *programName = strrchr(argv[0], '/');</a>
<a name="ln1062">				programName = programName ? programName + 1 : argv[0];</a>
<a name="ln1063"> </a>
<a name="ln1064">				Usage(programName);</a>
<a name="ln1065">			}</a>
<a name="ln1066">		} else if (isdigit(*argv[i])) {</a>
<a name="ln1067">			// check for a numeric arg, if not already given</a>
<a name="ln1068">			activate_workspace(atoi(argv[i]));</a>
<a name="ln1069"> </a>
<a name="ln1070">			// if the app is running, don't quit</a>
<a name="ln1071">			// but if it isn't, cancel the complete run, so it doesn't</a>
<a name="ln1072">			// open any window</a>
<a name="ln1073">			if (IsLaunching())</a>
<a name="ln1074">				Quit();</a>
<a name="ln1075">		} else if (!strcmp(argv[i], &quot;-&quot;)) {</a>
<a name="ln1076">			activate_workspace(current_workspace() - 1);</a>
<a name="ln1077"> </a>
<a name="ln1078">			if (IsLaunching())</a>
<a name="ln1079">				Quit();</a>
<a name="ln1080">		} else if (!strcmp(argv[i], &quot;+&quot;)) {</a>
<a name="ln1081">			activate_workspace(current_workspace() + 1);</a>
<a name="ln1082"> </a>
<a name="ln1083">			if (IsLaunching())</a>
<a name="ln1084">				Quit();</a>
<a name="ln1085">		} else {</a>
<a name="ln1086">			// some unknown arguments were specified</a>
<a name="ln1087">			fprintf(stderr, B_TRANSLATE(&quot;Invalid argument: %s\n&quot;), argv[i]);</a>
<a name="ln1088"> </a>
<a name="ln1089">			if (IsLaunching())</a>
<a name="ln1090">				Quit();</a>
<a name="ln1091">		}</a>
<a name="ln1092">	}</a>
<a name="ln1093">}</a>
<a name="ln1094"> </a>
<a name="ln1095"> </a>
<a name="ln1096">void</a>
<a name="ln1097">WorkspacesApp::ReadyToRun()</a>
<a name="ln1098">{</a>
<a name="ln1099">	fWindow-&gt;Show();</a>
<a name="ln1100">}</a>
<a name="ln1101"> </a>
<a name="ln1102"> </a>
<a name="ln1103">//	#pragma mark -</a>
<a name="ln1104"> </a>
<a name="ln1105"> </a>
<a name="ln1106">BView*</a>
<a name="ln1107">instantiate_deskbar_item(float maxWidth, float maxHeight)</a>
<a name="ln1108">{</a>
<a name="ln1109">	// Calculate the correct size of the Deskbar replicant first</a>
<a name="ln1110"> </a>
<a name="ln1111">	BScreen screen;</a>
<a name="ln1112">	float screenWidth = screen.Frame().Width();</a>
<a name="ln1113">	float screenHeight = screen.Frame().Height();</a>
<a name="ln1114">	float aspectRatio = screenWidth / screenHeight;</a>
<a name="ln1115">	uint32 columns, rows;</a>
<a name="ln1116">	BPrivate::get_workspaces_layout(&amp;columns, &amp;rows);</a>
<a name="ln1117"> </a>
<a name="ln1118">	// We use 1px for the top and left borders (shown as double)</a>
<a name="ln1119">	// and divide the remainder equally. However, we keep in mind</a>
<a name="ln1120">	// that the actual width and height of each workspace is smaller</a>
<a name="ln1121">	// by 1px, because of bottom/right borders (shown as single).</a>
<a name="ln1122">	// When calculating workspace width, we must ensure that the assumed</a>
<a name="ln1123">	// actual workspace height is not negative. Zero is OK.</a>
<a name="ln1124"> </a>
<a name="ln1125">	float height = maxHeight;</a>
<a name="ln1126">	float rowHeight = floor((height - 1) / rows);</a>
<a name="ln1127">	if (rowHeight &lt; 1)</a>
<a name="ln1128">		rowHeight = 1;</a>
<a name="ln1129"> </a>
<a name="ln1130">	float columnWidth = floor((rowHeight - 1) * aspectRatio) + 1;</a>
<a name="ln1131"> </a>
<a name="ln1132">	float width = columnWidth * columns + 1;</a>
<a name="ln1133">	if (width &gt; maxWidth)</a>
<a name="ln1134">		width = maxWidth;</a>
<a name="ln1135"> </a>
<a name="ln1136">	return new WorkspacesView(BRect (0, 0, width - 1, height - 1), false);</a>
<a name="ln1137">}</a>
<a name="ln1138"> </a>
<a name="ln1139"> </a>
<a name="ln1140">//	#pragma mark -</a>
<a name="ln1141"> </a>
<a name="ln1142"> </a>
<a name="ln1143">int</a>
<a name="ln1144">main(int argc, char **argv)</a>
<a name="ln1145">{</a>
<a name="ln1146">	WorkspacesApp app;</a>
<a name="ln1147">	app.Run();</a>
<a name="ln1148"> </a>
<a name="ln1149">	return 0;</a>
<a name="ln1150">}</a>

</code></pre>
<div class="balloon" rel="857"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v763/" target="_blank">V763</a> Parameter 'height' is always rewritten in function body before being used.</p></div>
<div class="balloon" rel="698"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'menu' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="856"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v763/" target="_blank">V763</a> Parameter 'width' is always rewritten in function body before being used.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
