
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>MouseInputDevice.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2004-2011, Haiku.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Stefano Ceccherini (stefano.ceccherini@gmail.com)</a>
<a name="ln7"> *		Jérôme Duval</a>
<a name="ln8"> *		Axel Dörfler, axeld@pinc-software.de</a>
<a name="ln9"> *		Clemens Zeidler, haiku@clemens-zeidler.de</a>
<a name="ln10"> *		Stephan Aßmus, superstippi@gmx.de</a>
<a name="ln11"> */</a>
<a name="ln12"> </a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;MouseInputDevice.h&quot;</a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;errno.h&gt;</a>
<a name="ln17">#include &lt;new&gt;</a>
<a name="ln18">#include &lt;stdio.h&gt;</a>
<a name="ln19">#include &lt;stdlib.h&gt;</a>
<a name="ln20">#include &lt;unistd.h&gt;</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;Autolock.h&gt;</a>
<a name="ln23">#include &lt;Debug.h&gt;</a>
<a name="ln24">#include &lt;Directory.h&gt;</a>
<a name="ln25">#include &lt;Entry.h&gt;</a>
<a name="ln26">#include &lt;File.h&gt;</a>
<a name="ln27">#include &lt;FindDirectory.h&gt;</a>
<a name="ln28">#include &lt;NodeMonitor.h&gt;</a>
<a name="ln29">#include &lt;Path.h&gt;</a>
<a name="ln30">#include &lt;String.h&gt;</a>
<a name="ln31">#include &lt;View.h&gt;</a>
<a name="ln32"> </a>
<a name="ln33">#include &lt;kb_mouse_settings.h&gt;</a>
<a name="ln34">#include &lt;keyboard_mouse_driver.h&gt;</a>
<a name="ln35">#include &lt;touchpad_settings.h&gt;</a>
<a name="ln36"> </a>
<a name="ln37"> </a>
<a name="ln38">#undef TRACE</a>
<a name="ln39">//#define TRACE_MOUSE_DEVICE</a>
<a name="ln40">#ifdef TRACE_MOUSE_DEVICE</a>
<a name="ln41"> </a>
<a name="ln42">	class FunctionTracer {</a>
<a name="ln43">	public:</a>
<a name="ln44">		FunctionTracer(const void* pointer, const char* className,</a>
<a name="ln45">				const char* functionName,</a>
<a name="ln46">				int32&amp; depth)</a>
<a name="ln47">			: fFunctionName(),</a>
<a name="ln48">			  fPrepend(),</a>
<a name="ln49">			  fFunctionDepth(depth),</a>
<a name="ln50">			  fPointer(pointer)</a>
<a name="ln51">		{</a>
<a name="ln52">			fFunctionDepth++;</a>
<a name="ln53">			fPrepend.Append(' ', fFunctionDepth * 2);</a>
<a name="ln54">			fFunctionName &lt;&lt; className &lt;&lt; &quot;::&quot; &lt;&lt; functionName &lt;&lt; &quot;()&quot;;</a>
<a name="ln55"> </a>
<a name="ln56">			debug_printf(&quot;%p -&gt; %s%s {\n&quot;, fPointer, fPrepend.String(),</a>
<a name="ln57">				fFunctionName.String());</a>
<a name="ln58">		}</a>
<a name="ln59"> </a>
<a name="ln60">		 ~FunctionTracer()</a>
<a name="ln61">		{</a>
<a name="ln62">			debug_printf(&quot;%p -&gt; %s}\n&quot;, fPointer, fPrepend.String());</a>
<a name="ln63">			fFunctionDepth--;</a>
<a name="ln64">		}</a>
<a name="ln65"> </a>
<a name="ln66">	private:</a>
<a name="ln67">		BString	fFunctionName;</a>
<a name="ln68">		BString	fPrepend;</a>
<a name="ln69">		int32&amp;	fFunctionDepth;</a>
<a name="ln70">		const void* fPointer;</a>
<a name="ln71">	};</a>
<a name="ln72"> </a>
<a name="ln73"> </a>
<a name="ln74">	static int32 sFunctionDepth = -1;</a>
<a name="ln75">#	define MD_CALLED(x...)	FunctionTracer _ft(this, &quot;MouseDevice&quot;, \</a>
<a name="ln76">								__FUNCTION__, sFunctionDepth)</a>
<a name="ln77">#	define MID_CALLED(x...)	FunctionTracer _ft(this, &quot;MouseInputDevice&quot;, \</a>
<a name="ln78">								__FUNCTION__, sFunctionDepth)</a>
<a name="ln79">#	define TRACE(x...)	do { BString _to; \</a>
<a name="ln80">							_to.Append(' ', (sFunctionDepth + 1) * 2); \</a>
<a name="ln81">							debug_printf(&quot;%p -&gt; %s&quot;, this, _to.String()); \</a>
<a name="ln82">							debug_printf(x); } while (0)</a>
<a name="ln83">#	define LOG_EVENT(text...) do {} while (0)</a>
<a name="ln84">#	define LOG_ERR(text...) TRACE(text)</a>
<a name="ln85">#else</a>
<a name="ln86">#	define TRACE(x...) do {} while (0)</a>
<a name="ln87">#	define MD_CALLED(x...) TRACE(x)</a>
<a name="ln88">#	define MID_CALLED(x...) TRACE(x)</a>
<a name="ln89">#	define LOG_ERR(x...) debug_printf(x)</a>
<a name="ln90">#	define LOG_EVENT(x...) TRACE(x)</a>
<a name="ln91">#endif</a>
<a name="ln92"> </a>
<a name="ln93"> </a>
<a name="ln94">const static uint32 kMouseThreadPriority = B_FIRST_REAL_TIME_PRIORITY + 4;</a>
<a name="ln95">const static char* kMouseDevicesDirectory = &quot;/dev/input/mouse&quot;;</a>
<a name="ln96">const static char* kTouchpadDevicesDirectory = &quot;/dev/input/touchpad&quot;;</a>
<a name="ln97"> </a>
<a name="ln98"> </a>
<a name="ln99">class MouseDevice {</a>
<a name="ln100">public:</a>
<a name="ln101">								MouseDevice(MouseInputDevice&amp; target,</a>
<a name="ln102">									const char* path);</a>
<a name="ln103">								~MouseDevice();</a>
<a name="ln104"> </a>
<a name="ln105">			status_t			Start();</a>
<a name="ln106">			void				Stop();</a>
<a name="ln107"> </a>
<a name="ln108">			status_t			UpdateSettings();</a>
<a name="ln109">			status_t			UpdateTouchpadSettings(const BMessage* message);</a>
<a name="ln110"> </a>
<a name="ln111">			const char*			Path() const { return fPath.String(); }</a>
<a name="ln112">			input_device_ref*	DeviceRef() { return &amp;fDeviceRef; }</a>
<a name="ln113"> </a>
<a name="ln114">private:</a>
<a name="ln115">			char*				_BuildShortName() const;</a>
<a name="ln116"> </a>
<a name="ln117">	static	status_t			_ControlThreadEntry(void* arg);</a>
<a name="ln118">			void				_ControlThread();</a>
<a name="ln119">			void				_ControlThreadCleanup();</a>
<a name="ln120">			void				_UpdateSettings();</a>
<a name="ln121"> </a>
<a name="ln122">			status_t			_GetTouchpadSettingsPath(BPath&amp; path);</a>
<a name="ln123">			status_t			_ReadTouchpadSettingsMsg(BMessage* message);</a>
<a name="ln124">			status_t			_UpdateTouchpadSettings();</a>
<a name="ln125"> </a>
<a name="ln126">			BMessage*			_BuildMouseMessage(uint32 what,</a>
<a name="ln127">									uint64 when, uint32 buttons,</a>
<a name="ln128">									int32 deltaX, int32 deltaY) const;</a>
<a name="ln129">			void				_ComputeAcceleration(</a>
<a name="ln130">									const mouse_movement&amp; movements,</a>
<a name="ln131">									int32&amp; deltaX, int32&amp; deltaY,</a>
<a name="ln132">									float&amp; historyDeltaX,</a>
<a name="ln133">									float&amp; historyDeltaY) const;</a>
<a name="ln134">			uint32				_RemapButtons(uint32 buttons) const;</a>
<a name="ln135"> </a>
<a name="ln136">private:</a>
<a name="ln137">			MouseInputDevice&amp;	fTarget;</a>
<a name="ln138">			BString				fPath;</a>
<a name="ln139">			int					fDevice;</a>
<a name="ln140"> </a>
<a name="ln141">			input_device_ref	fDeviceRef;</a>
<a name="ln142">			mouse_settings		fSettings;</a>
<a name="ln143">			bool				fDeviceRemapsButtons;</a>
<a name="ln144"> </a>
<a name="ln145">			thread_id			fThread;</a>
<a name="ln146">	volatile bool				fActive;</a>
<a name="ln147">	volatile bool				fUpdateSettings;</a>
<a name="ln148"> </a>
<a name="ln149">			bool				fIsTouchpad;</a>
<a name="ln150">			touchpad_settings	fTouchpadSettings;</a>
<a name="ln151">			BMessage*			fTouchpadSettingsMessage;</a>
<a name="ln152">			BLocker				fTouchpadSettingsLock;</a>
<a name="ln153">};</a>
<a name="ln154"> </a>
<a name="ln155"> </a>
<a name="ln156">extern &quot;C&quot; BInputServerDevice*</a>
<a name="ln157">instantiate_input_device()</a>
<a name="ln158">{</a>
<a name="ln159">	return new(std::nothrow) MouseInputDevice();</a>
<a name="ln160">}</a>
<a name="ln161"> </a>
<a name="ln162"> </a>
<a name="ln163">//	#pragma mark -</a>
<a name="ln164"> </a>
<a name="ln165"> </a>
<a name="ln166">MouseDevice::MouseDevice(MouseInputDevice&amp; target, const char* driverPath)</a>
<a name="ln167">	:</a>
<a name="ln168">	fTarget(target),</a>
<a name="ln169">	fPath(driverPath),</a>
<a name="ln170">	fDevice(-1),</a>
<a name="ln171">	fDeviceRemapsButtons(false),</a>
<a name="ln172">	fThread(-1),</a>
<a name="ln173">	fActive(false),</a>
<a name="ln174">	fUpdateSettings(false),</a>
<a name="ln175">	fIsTouchpad(false),</a>
<a name="ln176">	fTouchpadSettingsMessage(NULL),</a>
<a name="ln177">	fTouchpadSettingsLock(&quot;Touchpad settings lock&quot;)</a>
<a name="ln178">{</a>
<a name="ln179">	MD_CALLED();</a>
<a name="ln180"> </a>
<a name="ln181">	fDeviceRef.name = _BuildShortName();</a>
<a name="ln182">	fDeviceRef.type = B_POINTING_DEVICE;</a>
<a name="ln183">	fDeviceRef.cookie = this;</a>
<a name="ln184"> </a>
<a name="ln185">#ifdef HAIKU_TARGET_PLATFORM_HAIKU</a>
<a name="ln186">	fSettings.map.button[0] = B_PRIMARY_MOUSE_BUTTON;</a>
<a name="ln187">	fSettings.map.button[1] = B_SECONDARY_MOUSE_BUTTON;</a>
<a name="ln188">	fSettings.map.button[2] = B_TERTIARY_MOUSE_BUTTON;</a>
<a name="ln189">#endif</a>
<a name="ln190">};</a>
<a name="ln191"> </a>
<a name="ln192"> </a>
<a name="ln193">MouseDevice::~MouseDevice()</a>
<a name="ln194">{</a>
<a name="ln195">	MD_CALLED();</a>
<a name="ln196">	TRACE(&quot;delete\n&quot;);</a>
<a name="ln197"> </a>
<a name="ln198">	if (fActive)</a>
<a name="ln199">		Stop();</a>
<a name="ln200"> </a>
<a name="ln201">	free(fDeviceRef.name);</a>
<a name="ln202">	delete fTouchpadSettingsMessage;</a>
<a name="ln203">}</a>
<a name="ln204"> </a>
<a name="ln205"> </a>
<a name="ln206">status_t</a>
<a name="ln207">MouseDevice::Start()</a>
<a name="ln208">{</a>
<a name="ln209">	MD_CALLED();</a>
<a name="ln210"> </a>
<a name="ln211">	fDevice = open(fPath.String(), O_RDWR);</a>
<a name="ln212">		// let the control thread handle any error on opening the device</a>
<a name="ln213"> </a>
<a name="ln214">	char threadName[B_OS_NAME_LENGTH];</a>
<a name="ln215">	snprintf(threadName, B_OS_NAME_LENGTH, &quot;%s watcher&quot;, fDeviceRef.name);</a>
<a name="ln216"> </a>
<a name="ln217">	fThread = spawn_thread(_ControlThreadEntry, threadName,</a>
<a name="ln218">		kMouseThreadPriority, (void*)this);</a>
<a name="ln219"> </a>
<a name="ln220">	status_t status;</a>
<a name="ln221">	if (fThread &lt; 0)</a>
<a name="ln222">		status = fThread;</a>
<a name="ln223">	else {</a>
<a name="ln224">		fActive = true;</a>
<a name="ln225">		status = resume_thread(fThread);</a>
<a name="ln226">	}</a>
<a name="ln227"> </a>
<a name="ln228">	if (status &lt; B_OK) {</a>
<a name="ln229">		LOG_ERR(&quot;%s: can't spawn/resume watching thread: %s\n&quot;,</a>
<a name="ln230">			fDeviceRef.name, strerror(status));</a>
<a name="ln231">		if (fDevice &gt;= 0)</a>
<a name="ln232">			close(fDevice);</a>
<a name="ln233"> </a>
<a name="ln234">		return status;</a>
<a name="ln235">	}</a>
<a name="ln236"> </a>
<a name="ln237">	return fDevice &gt;= 0 ? B_OK : B_ERROR;</a>
<a name="ln238">}</a>
<a name="ln239"> </a>
<a name="ln240"> </a>
<a name="ln241">void</a>
<a name="ln242">MouseDevice::Stop()</a>
<a name="ln243">{</a>
<a name="ln244">	MD_CALLED();</a>
<a name="ln245"> </a>
<a name="ln246">	fActive = false;</a>
<a name="ln247">		// this will stop the thread as soon as it reads the next packet</a>
<a name="ln248"> </a>
<a name="ln249">	close(fDevice);</a>
<a name="ln250">	fDevice = -1;</a>
<a name="ln251"> </a>
<a name="ln252">	if (fThread &gt;= 0) {</a>
<a name="ln253">		// unblock the thread, which might wait on a semaphore.</a>
<a name="ln254">		suspend_thread(fThread);</a>
<a name="ln255">		resume_thread(fThread);</a>
<a name="ln256"> </a>
<a name="ln257">		status_t dummy;</a>
<a name="ln258">		wait_for_thread(fThread, &amp;dummy);</a>
<a name="ln259">	}</a>
<a name="ln260">}</a>
<a name="ln261"> </a>
<a name="ln262"> </a>
<a name="ln263">status_t</a>
<a name="ln264">MouseDevice::UpdateSettings()</a>
<a name="ln265">{</a>
<a name="ln266">	MD_CALLED();</a>
<a name="ln267"> </a>
<a name="ln268">	if (fThread &lt; 0)</a>
<a name="ln269">		return B_ERROR;</a>
<a name="ln270"> </a>
<a name="ln271">	// trigger updating the settings in the control thread</a>
<a name="ln272">	fUpdateSettings = true;</a>
<a name="ln273"> </a>
<a name="ln274">	return B_OK;</a>
<a name="ln275">}</a>
<a name="ln276"> </a>
<a name="ln277"> </a>
<a name="ln278">status_t</a>
<a name="ln279">MouseDevice::UpdateTouchpadSettings(const BMessage* message)</a>
<a name="ln280">{</a>
<a name="ln281">	if (!fIsTouchpad)</a>
<a name="ln282">		return B_BAD_TYPE;</a>
<a name="ln283">	if (fThread &lt; 0)</a>
<a name="ln284">		return B_ERROR;</a>
<a name="ln285"> </a>
<a name="ln286">	BAutolock _(fTouchpadSettingsLock);</a>
<a name="ln287"> </a>
<a name="ln288">	// trigger updating the settings in the control thread</a>
<a name="ln289">	fUpdateSettings = true;</a>
<a name="ln290"> </a>
<a name="ln291">	delete fTouchpadSettingsMessage;</a>
<a name="ln292">	fTouchpadSettingsMessage = new BMessage(*message);</a>
<a name="ln293">	if (fTouchpadSettingsMessage == NULL)</a>
<a name="ln294">		return B_NO_MEMORY;</a>
<a name="ln295"> </a>
<a name="ln296">	return B_OK;</a>
<a name="ln297">}</a>
<a name="ln298"> </a>
<a name="ln299"> </a>
<a name="ln300">char*</a>
<a name="ln301">MouseDevice::_BuildShortName() const</a>
<a name="ln302">{</a>
<a name="ln303">	BString string(fPath);</a>
<a name="ln304">	BString name;</a>
<a name="ln305"> </a>
<a name="ln306">	int32 slash = string.FindLast(&quot;/&quot;);</a>
<a name="ln307">	string.CopyInto(name, slash + 1, string.Length() - slash);</a>
<a name="ln308">	int32 index = atoi(name.String()) + 1;</a>
<a name="ln309"> </a>
<a name="ln310">	int32 previousSlash = string.FindLast(&quot;/&quot;, slash);</a>
<a name="ln311">	string.CopyInto(name, previousSlash + 1, slash - previousSlash - 1);</a>
<a name="ln312"> </a>
<a name="ln313">	if (name == &quot;ps2&quot;)</a>
<a name="ln314">		name = &quot;PS/2&quot;;</a>
<a name="ln315"> </a>
<a name="ln316">	if (name.Length() &lt; 4)</a>
<a name="ln317">		name.ToUpper();</a>
<a name="ln318">	else</a>
<a name="ln319">		name.Capitalize();</a>
<a name="ln320"> </a>
<a name="ln321">	if (string.FindFirst(&quot;touchpad&quot;) &gt;= 0) {</a>
<a name="ln322">		name &lt;&lt; &quot; Touchpad &quot;;</a>
<a name="ln323">	} else {</a>
<a name="ln324">		if (string.FindFirst(&quot;intelli&quot;) &gt;= 0)</a>
<a name="ln325">			name.Prepend(&quot;Extended &quot;);</a>
<a name="ln326"> </a>
<a name="ln327">		name &lt;&lt; &quot; Mouse &quot;;</a>
<a name="ln328">	}</a>
<a name="ln329">	name &lt;&lt; index;</a>
<a name="ln330"> </a>
<a name="ln331">	return strdup(name.String());</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334"> </a>
<a name="ln335">// #pragma mark - control thread</a>
<a name="ln336"> </a>
<a name="ln337"> </a>
<a name="ln338">status_t</a>
<a name="ln339">MouseDevice::_ControlThreadEntry(void* arg)</a>
<a name="ln340">{</a>
<a name="ln341">	MouseDevice* device = (MouseDevice*)arg;</a>
<a name="ln342">	device-&gt;_ControlThread();</a>
<a name="ln343">	return B_OK;</a>
<a name="ln344">}</a>
<a name="ln345"> </a>
<a name="ln346"> </a>
<a name="ln347">void</a>
<a name="ln348">MouseDevice::_ControlThread()</a>
<a name="ln349">{</a>
<a name="ln350">	MD_CALLED();</a>
<a name="ln351"> </a>
<a name="ln352">	if (fDevice &lt; 0) {</a>
<a name="ln353">		_ControlThreadCleanup();</a>
<a name="ln354">		// TOAST!</a>
<a name="ln355">		return;</a>
<a name="ln356">	}</a>
<a name="ln357"> </a>
<a name="ln358">	// touchpad settings</a>
<a name="ln359">	if (ioctl(fDevice, MS_IS_TOUCHPAD, NULL) == B_OK) {</a>
<a name="ln360">		TRACE(&quot;is touchpad %s\n&quot;, fPath.String());</a>
<a name="ln361">		fIsTouchpad = true;</a>
<a name="ln362"> </a>
<a name="ln363">		fTouchpadSettings = kDefaultTouchpadSettings;</a>
<a name="ln364"> </a>
<a name="ln365">		BPath path;</a>
<a name="ln366">		status_t status = _GetTouchpadSettingsPath(path);</a>
<a name="ln367">		BFile settingsFile(path.Path(), B_READ_ONLY);</a>
<a name="ln368">		if (status == B_OK &amp;&amp; settingsFile.InitCheck() == B_OK) {</a>
<a name="ln369">			if (settingsFile.Read(&amp;fTouchpadSettings, sizeof(touchpad_settings))</a>
<a name="ln370">					!= sizeof(touchpad_settings)) {</a>
<a name="ln371">				TRACE(&quot;failed to load settings\n&quot;);</a>
<a name="ln372">			}</a>
<a name="ln373">		}</a>
<a name="ln374">		_UpdateTouchpadSettings();</a>
<a name="ln375">	}</a>
<a name="ln376"> </a>
<a name="ln377">	_UpdateSettings();</a>
<a name="ln378"> </a>
<a name="ln379">	uint32 lastButtons = 0;</a>
<a name="ln380">	float historyDeltaX = 0.0;</a>
<a name="ln381">	float historyDeltaY = 0.0;</a>
<a name="ln382"> </a>
<a name="ln383">	static const bigtime_t kTransferDelay = 1000000 / 125;</a>
<a name="ln384">		// 125 transfers per second should be more than enough</a>
<a name="ln385">#define USE_REGULAR_INTERVAL 1</a>
<a name="ln386">#if USE_REGULAR_INTERVAL</a>
<a name="ln387">	bigtime_t nextTransferTime = system_time() + kTransferDelay;</a>
<a name="ln388">#endif</a>
<a name="ln389"> </a>
<a name="ln390">	while (fActive) {</a>
<a name="ln391">		mouse_movement movements;</a>
<a name="ln392"> </a>
<a name="ln393">#if USE_REGULAR_INTERVAL</a>
<a name="ln394">		snooze_until(nextTransferTime, B_SYSTEM_TIMEBASE);</a>
<a name="ln395">		nextTransferTime += kTransferDelay;</a>
<a name="ln396">#endif</a>
<a name="ln397"> </a>
<a name="ln398">		if (ioctl(fDevice, MS_READ, &amp;movements, sizeof(movements)) != B_OK) {</a>
<a name="ln399">			LOG_ERR(&quot;Mouse device exiting, %s\n&quot;, strerror(errno));</a>
<a name="ln400">			_ControlThreadCleanup();</a>
<a name="ln401">			// TOAST!</a>
<a name="ln402">			return;</a>
<a name="ln403">		}</a>
<a name="ln404"> </a>
<a name="ln405">		// take care of updating the settings first, if necessary</a>
<a name="ln406">		if (fUpdateSettings) {</a>
<a name="ln407">			fUpdateSettings = false;</a>
<a name="ln408">			if (fIsTouchpad) {</a>
<a name="ln409">				BAutolock _(fTouchpadSettingsLock);</a>
<a name="ln410">				if (fTouchpadSettingsMessage != NULL) {</a>
<a name="ln411">					_ReadTouchpadSettingsMsg(fTouchpadSettingsMessage);</a>
<a name="ln412">					_UpdateTouchpadSettings();</a>
<a name="ln413">					delete fTouchpadSettingsMessage;</a>
<a name="ln414">					fTouchpadSettingsMessage = NULL;</a>
<a name="ln415">				} else</a>
<a name="ln416">					_UpdateSettings();</a>
<a name="ln417">			} else</a>
<a name="ln418">				_UpdateSettings();</a>
<a name="ln419">		}</a>
<a name="ln420"> </a>
<a name="ln421">		uint32 buttons = lastButtons ^ movements.buttons;</a>
<a name="ln422"> </a>
<a name="ln423">		uint32 remappedButtons = _RemapButtons(movements.buttons);</a>
<a name="ln424">		int32 deltaX, deltaY;</a>
<a name="ln425">		_ComputeAcceleration(movements, deltaX, deltaY, historyDeltaX,</a>
<a name="ln426">			historyDeltaY);</a>
<a name="ln427"> </a>
<a name="ln428">		LOG_EVENT(&quot;%s: buttons: 0x%lx, x: %ld, y: %ld, clicks:%ld, &quot;</a>
<a name="ln429">			&quot;wheel_x:%ld, wheel_y:%ld\n&quot;,</a>
<a name="ln430">			fDeviceRef.name, movements.buttons,</a>
<a name="ln431">			movements.xdelta, movements.ydelta, movements.clicks,</a>
<a name="ln432">			movements.wheel_xdelta, movements.wheel_ydelta);</a>
<a name="ln433">		LOG_EVENT(&quot;%s: x: %ld, y: %ld (%.4f, %.4f)\n&quot;, fDeviceRef.name,</a>
<a name="ln434">			deltaX, deltaY, historyDeltaX, historyDeltaY);</a>
<a name="ln435"> </a>
<a name="ln436">		// Send single messages for each event</a>
<a name="ln437"> </a>
<a name="ln438">		if (buttons != 0) {</a>
<a name="ln439">			bool pressedButton = (buttons &amp; movements.buttons) &gt; 0;</a>
<a name="ln440">			BMessage* message = _BuildMouseMessage(</a>
<a name="ln441">				pressedButton ? B_MOUSE_DOWN : B_MOUSE_UP,</a>
<a name="ln442">				movements.timestamp, remappedButtons, deltaX, deltaY);</a>
<a name="ln443">			if (message != NULL) {</a>
<a name="ln444">				if (pressedButton) {</a>
<a name="ln445">					message-&gt;AddInt32(&quot;clicks&quot;, movements.clicks);</a>
<a name="ln446">					LOG_EVENT(&quot;B_MOUSE_DOWN\n&quot;);</a>
<a name="ln447">				} else</a>
<a name="ln448">					LOG_EVENT(&quot;B_MOUSE_UP\n&quot;);</a>
<a name="ln449"> </a>
<a name="ln450">				fTarget.EnqueueMessage(message);</a>
<a name="ln451">				lastButtons = movements.buttons;</a>
<a name="ln452">			}</a>
<a name="ln453">		}</a>
<a name="ln454"> </a>
<a name="ln455">		if (movements.xdelta != 0 || movements.ydelta != 0) {</a>
<a name="ln456">			BMessage* message = _BuildMouseMessage(B_MOUSE_MOVED,</a>
<a name="ln457">				movements.timestamp, remappedButtons, deltaX, deltaY);</a>
<a name="ln458">			if (message != NULL)</a>
<a name="ln459">				fTarget.EnqueueMessage(message);</a>
<a name="ln460">		}</a>
<a name="ln461"> </a>
<a name="ln462">		if (movements.wheel_ydelta != 0 || movements.wheel_xdelta != 0) {</a>
<a name="ln463">			BMessage* message = new BMessage(B_MOUSE_WHEEL_CHANGED);</a>
<a name="ln464">			if (message == NULL)</a>
<a name="ln465">				continue;</a>
<a name="ln466"> </a>
<a name="ln467">			if (message-&gt;AddInt64(&quot;when&quot;, movements.timestamp) == B_OK</a>
<a name="ln468">				&amp;&amp; message-&gt;AddFloat(&quot;be:wheel_delta_x&quot;,</a>
<a name="ln469">					movements.wheel_xdelta) == B_OK</a>
<a name="ln470">				&amp;&amp; message-&gt;AddFloat(&quot;be:wheel_delta_y&quot;,</a>
<a name="ln471">					movements.wheel_ydelta) == B_OK)</a>
<a name="ln472">				fTarget.EnqueueMessage(message);</a>
<a name="ln473">			else</a>
<a name="ln474">				delete message;</a>
<a name="ln475">		}</a>
<a name="ln476"> </a>
<a name="ln477">#if !USE_REGULAR_INTERVAL</a>
<a name="ln478">		snooze(kTransferDelay);</a>
<a name="ln479">#endif</a>
<a name="ln480">	}</a>
<a name="ln481">}</a>
<a name="ln482"> </a>
<a name="ln483"> </a>
<a name="ln484">void</a>
<a name="ln485">MouseDevice::_ControlThreadCleanup()</a>
<a name="ln486">{</a>
<a name="ln487">	// NOTE: Only executed when the control thread detected an error</a>
<a name="ln488">	// and from within the control thread!</a>
<a name="ln489"> </a>
<a name="ln490">	if (fActive) {</a>
<a name="ln491">		fThread = -1;</a>
<a name="ln492">		fTarget._RemoveDevice(fPath.String());</a>
<a name="ln493">	} else {</a>
<a name="ln494">		// In case active is already false, another thread</a>
<a name="ln495">		// waits for this thread to quit, and may already hold</a>
<a name="ln496">		// locks that _RemoveDevice() wants to acquire. In other</a>
<a name="ln497">		// words, the device is already being removed, so we simply</a>
<a name="ln498">		// quit here.</a>
<a name="ln499">	}</a>
<a name="ln500">}</a>
<a name="ln501"> </a>
<a name="ln502"> </a>
<a name="ln503">void</a>
<a name="ln504">MouseDevice::_UpdateSettings()</a>
<a name="ln505">{</a>
<a name="ln506">	MD_CALLED();</a>
<a name="ln507"> </a>
<a name="ln508">	// retrieve current values</a>
<a name="ln509"> </a>
<a name="ln510">	if (get_mouse_map(&amp;fSettings.map) != B_OK)</a>
<a name="ln511">		LOG_ERR(&quot;error when get_mouse_map\n&quot;);</a>
<a name="ln512">	else {</a>
<a name="ln513">		fDeviceRemapsButtons</a>
<a name="ln514">			= ioctl(fDevice, MS_SET_MAP, &amp;fSettings.map) == B_OK;</a>
<a name="ln515">	}</a>
<a name="ln516"> </a>
<a name="ln517">	if (get_click_speed(&amp;fSettings.click_speed) != B_OK)</a>
<a name="ln518">		LOG_ERR(&quot;error when get_click_speed\n&quot;);</a>
<a name="ln519">	else</a>
<a name="ln520">		ioctl(fDevice, MS_SET_CLICKSPEED, &amp;fSettings.click_speed);</a>
<a name="ln521"> </a>
<a name="ln522">	if (get_mouse_speed(&amp;fSettings.accel.speed) != B_OK)</a>
<a name="ln523">		LOG_ERR(&quot;error when get_mouse_speed\n&quot;);</a>
<a name="ln524">	else {</a>
<a name="ln525">		if (get_mouse_acceleration(&amp;fSettings.accel.accel_factor) != B_OK)</a>
<a name="ln526">			LOG_ERR(&quot;error when get_mouse_acceleration\n&quot;);</a>
<a name="ln527">		else {</a>
<a name="ln528">			mouse_accel accel;</a>
<a name="ln529">			ioctl(fDevice, MS_GET_ACCEL, &amp;accel);</a>
<a name="ln530">			accel.speed = fSettings.accel.speed;</a>
<a name="ln531">			accel.accel_factor = fSettings.accel.accel_factor;</a>
<a name="ln532">			ioctl(fDevice, MS_SET_ACCEL, &amp;fSettings.accel);</a>
<a name="ln533">		}</a>
<a name="ln534">	}</a>
<a name="ln535"> </a>
<a name="ln536">	if (get_mouse_type(&amp;fSettings.type) != B_OK)</a>
<a name="ln537">		LOG_ERR(&quot;error when get_mouse_type\n&quot;);</a>
<a name="ln538">	else</a>
<a name="ln539">		ioctl(fDevice, MS_SET_TYPE, &amp;fSettings.type);</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542"> </a>
<a name="ln543">status_t</a>
<a name="ln544">MouseDevice::_GetTouchpadSettingsPath(BPath&amp; path)</a>
<a name="ln545">{</a>
<a name="ln546">	status_t status = find_directory(B_USER_SETTINGS_DIRECTORY, &amp;path);</a>
<a name="ln547">	if (status &lt; B_OK)</a>
<a name="ln548">		return status;</a>
<a name="ln549">	return path.Append(TOUCHPAD_SETTINGS_FILE);</a>
<a name="ln550">}</a>
<a name="ln551"> </a>
<a name="ln552"> </a>
<a name="ln553">status_t</a>
<a name="ln554">MouseDevice::_ReadTouchpadSettingsMsg(BMessage* message)</a>
<a name="ln555">{</a>
<a name="ln556">	message-&gt;FindBool(&quot;scroll_twofinger&quot;, &amp;fTouchpadSettings.scroll_twofinger);</a>
<a name="ln557">	message-&gt;FindBool(&quot;scroll_twofinger_horizontal&quot;,</a>
<a name="ln558">		&amp;fTouchpadSettings.scroll_twofinger_horizontal);</a>
<a name="ln559">	message-&gt;FindFloat(&quot;scroll_rightrange&quot;,</a>
<a name="ln560">		&amp;fTouchpadSettings.scroll_rightrange);</a>
<a name="ln561">	message-&gt;FindFloat(&quot;scroll_bottomrange&quot;,</a>
<a name="ln562">		&amp;fTouchpadSettings.scroll_bottomrange);</a>
<a name="ln563"> </a>
<a name="ln564">	message-&gt;FindInt16(&quot;scroll_xstepsize&quot;,</a>
<a name="ln565">		(int16*)&amp;fTouchpadSettings.scroll_xstepsize);</a>
<a name="ln566">	message-&gt;FindInt16(&quot;scroll_ystepsize&quot;,</a>
<a name="ln567">		(int16*)&amp;fTouchpadSettings.scroll_ystepsize);</a>
<a name="ln568">	message-&gt;FindInt8(&quot;scroll_acceleration&quot;,</a>
<a name="ln569">		(int8*)&amp;fTouchpadSettings.scroll_acceleration);</a>
<a name="ln570">	message-&gt;FindInt8(&quot;tapgesture_sensibility&quot;,</a>
<a name="ln571">		(int8*)&amp;fTouchpadSettings.tapgesture_sensibility);</a>
<a name="ln572"> </a>
<a name="ln573">	return B_OK;</a>
<a name="ln574">}</a>
<a name="ln575"> </a>
<a name="ln576"> </a>
<a name="ln577">status_t</a>
<a name="ln578">MouseDevice::_UpdateTouchpadSettings()</a>
<a name="ln579">{</a>
<a name="ln580">	if (fIsTouchpad) {</a>
<a name="ln581">		ioctl(fDevice, MS_SET_TOUCHPAD_SETTINGS, &amp;fTouchpadSettings);</a>
<a name="ln582">		return B_OK;</a>
<a name="ln583">	}</a>
<a name="ln584">	return B_ERROR;</a>
<a name="ln585">}</a>
<a name="ln586"> </a>
<a name="ln587"> </a>
<a name="ln588">BMessage*</a>
<a name="ln589">MouseDevice::_BuildMouseMessage(uint32 what, uint64 when, uint32 buttons,</a>
<a name="ln590">	int32 deltaX, int32 deltaY) const</a>
<a name="ln591">{</a>
<a name="ln592">	BMessage* message = new BMessage(what);</a>
<a name="ln593">	if (message == NULL)</a>
<a name="ln594">		return NULL;</a>
<a name="ln595"> </a>
<a name="ln596">	if (message-&gt;AddInt64(&quot;when&quot;, when) &lt; B_OK</a>
<a name="ln597">		|| message-&gt;AddInt32(&quot;buttons&quot;, buttons) &lt; B_OK</a>
<a name="ln598">		|| message-&gt;AddInt32(&quot;x&quot;, deltaX) &lt; B_OK</a>
<a name="ln599">		|| message-&gt;AddInt32(&quot;y&quot;, deltaY) &lt; B_OK) {</a>
<a name="ln600">		delete message;</a>
<a name="ln601">		return NULL;</a>
<a name="ln602">	}</a>
<a name="ln603"> </a>
<a name="ln604">	return message;</a>
<a name="ln605">}</a>
<a name="ln606"> </a>
<a name="ln607"> </a>
<a name="ln608">void</a>
<a name="ln609">MouseDevice::_ComputeAcceleration(const mouse_movement&amp; movements,</a>
<a name="ln610">	int32&amp; _deltaX, int32&amp; _deltaY, float&amp; historyDeltaX,</a>
<a name="ln611">	float&amp; historyDeltaY) const</a>
<a name="ln612">{</a>
<a name="ln613">	// basic mouse speed</a>
<a name="ln614">	float deltaX = (float)movements.xdelta * fSettings.accel.speed / 65536.0</a>
<a name="ln615">		+ historyDeltaX;</a>
<a name="ln616">	float deltaY = (float)movements.ydelta * fSettings.accel.speed / 65536.0</a>
<a name="ln617">		+ historyDeltaY;</a>
<a name="ln618"> </a>
<a name="ln619">	// acceleration</a>
<a name="ln620">	double acceleration = 1;</a>
<a name="ln621">	if (fSettings.accel.accel_factor) {</a>
<a name="ln622">		acceleration = 1 + sqrt(deltaX * deltaX + deltaY * deltaY)</a>
<a name="ln623">			* fSettings.accel.accel_factor / 524288.0;</a>
<a name="ln624">	}</a>
<a name="ln625"> </a>
<a name="ln626">	deltaX *= acceleration;</a>
<a name="ln627">	deltaY *= acceleration;</a>
<a name="ln628"> </a>
<a name="ln629">	if (deltaX &gt;= 0)</a>
<a name="ln630">		_deltaX = (int32)floorf(deltaX);</a>
<a name="ln631">	else</a>
<a name="ln632">		_deltaX = (int32)ceilf(deltaX);</a>
<a name="ln633"> </a>
<a name="ln634">	if (deltaY &gt;= 0)</a>
<a name="ln635">		_deltaY = (int32)floorf(deltaY);</a>
<a name="ln636">	else</a>
<a name="ln637">		_deltaY = (int32)ceilf(deltaY);</a>
<a name="ln638"> </a>
<a name="ln639">	historyDeltaX = deltaX - _deltaX;</a>
<a name="ln640">	historyDeltaY = deltaY - _deltaY;</a>
<a name="ln641">}</a>
<a name="ln642"> </a>
<a name="ln643"> </a>
<a name="ln644">uint32</a>
<a name="ln645">MouseDevice::_RemapButtons(uint32 buttons) const</a>
<a name="ln646">{</a>
<a name="ln647">	if (fDeviceRemapsButtons)</a>
<a name="ln648">		return buttons;</a>
<a name="ln649"> </a>
<a name="ln650">	uint32 newButtons = 0;</a>
<a name="ln651">	for (int32 i = 0; buttons; i++) {</a>
<a name="ln652">		if (buttons &amp; 0x1) {</a>
<a name="ln653">#if defined(HAIKU_TARGET_PLATFORM_HAIKU) || defined(HAIKU_TARGET_PLATFORM_DANO)</a>
<a name="ln654">			newButtons |= fSettings.map.button[i];</a>
<a name="ln655">#else</a>
<a name="ln656">			if (i == 0)</a>
<a name="ln657">				newButtons |= fSettings.map.left;</a>
<a name="ln658">			if (i == 1)</a>
<a name="ln659">				newButtons |= fSettings.map.right;</a>
<a name="ln660">			if (i == 2)</a>
<a name="ln661">				newButtons |= fSettings.map.middle;</a>
<a name="ln662">#endif</a>
<a name="ln663">		}</a>
<a name="ln664">		buttons &gt;&gt;= 1;</a>
<a name="ln665">	}</a>
<a name="ln666"> </a>
<a name="ln667">	return newButtons;</a>
<a name="ln668">}</a>
<a name="ln669"> </a>
<a name="ln670"> </a>
<a name="ln671">//	#pragma mark -</a>
<a name="ln672"> </a>
<a name="ln673"> </a>
<a name="ln674">MouseInputDevice::MouseInputDevice()</a>
<a name="ln675">	:</a>
<a name="ln676">	fDevices(2, true),</a>
<a name="ln677">	fDeviceListLock(&quot;MouseInputDevice list&quot;)</a>
<a name="ln678">{</a>
<a name="ln679">	MID_CALLED();</a>
<a name="ln680"> </a>
<a name="ln681">	StartMonitoringDevice(kMouseDevicesDirectory);</a>
<a name="ln682">	StartMonitoringDevice(kTouchpadDevicesDirectory);</a>
<a name="ln683">	_RecursiveScan(kMouseDevicesDirectory);</a>
<a name="ln684">	_RecursiveScan(kTouchpadDevicesDirectory);</a>
<a name="ln685">}</a>
<a name="ln686"> </a>
<a name="ln687"> </a>
<a name="ln688">MouseInputDevice::~MouseInputDevice()</a>
<a name="ln689">{</a>
<a name="ln690">	MID_CALLED();</a>
<a name="ln691"> </a>
<a name="ln692">	StopMonitoringDevice(kTouchpadDevicesDirectory);</a>
<a name="ln693">	StopMonitoringDevice(kMouseDevicesDirectory);</a>
<a name="ln694">	fDevices.MakeEmpty();</a>
<a name="ln695">}</a>
<a name="ln696"> </a>
<a name="ln697"> </a>
<a name="ln698">status_t</a>
<a name="ln699">MouseInputDevice::InitCheck()</a>
<a name="ln700">{</a>
<a name="ln701">	MID_CALLED();</a>
<a name="ln702"> </a>
<a name="ln703">	return BInputServerDevice::InitCheck();</a>
<a name="ln704">}</a>
<a name="ln705"> </a>
<a name="ln706"> </a>
<a name="ln707">status_t</a>
<a name="ln708">MouseInputDevice::Start(const char* name, void* cookie)</a>
<a name="ln709">{</a>
<a name="ln710">	MID_CALLED();</a>
<a name="ln711"> </a>
<a name="ln712">	MouseDevice* device = (MouseDevice*)cookie;</a>
<a name="ln713"> </a>
<a name="ln714">	return device-&gt;Start();</a>
<a name="ln715">}</a>
<a name="ln716"> </a>
<a name="ln717"> </a>
<a name="ln718">status_t</a>
<a name="ln719">MouseInputDevice::Stop(const char* name, void* cookie)</a>
<a name="ln720">{</a>
<a name="ln721">	TRACE(&quot;%s(%s)\n&quot;, __PRETTY_FUNCTION__, name);</a>
<a name="ln722"> </a>
<a name="ln723">	MouseDevice* device = (MouseDevice*)cookie;</a>
<a name="ln724">	device-&gt;Stop();</a>
<a name="ln725"> </a>
<a name="ln726">	return B_OK;</a>
<a name="ln727">}</a>
<a name="ln728"> </a>
<a name="ln729"> </a>
<a name="ln730">status_t</a>
<a name="ln731">MouseInputDevice::Control(const char* name, void* cookie,</a>
<a name="ln732">	uint32 command, BMessage* message)</a>
<a name="ln733">{</a>
<a name="ln734">	TRACE(&quot;%s(%s, code: %lu)\n&quot;, __PRETTY_FUNCTION__, name, command);</a>
<a name="ln735"> </a>
<a name="ln736">	MouseDevice* device = (MouseDevice*)cookie;</a>
<a name="ln737"> </a>
<a name="ln738">	if (command == B_NODE_MONITOR)</a>
<a name="ln739">		return _HandleMonitor(message);</a>
<a name="ln740"> </a>
<a name="ln741">	if (command == MS_SET_TOUCHPAD_SETTINGS)</a>
<a name="ln742">		return device-&gt;UpdateTouchpadSettings(message);</a>
<a name="ln743"> </a>
<a name="ln744">	if (command &gt;= B_MOUSE_TYPE_CHANGED</a>
<a name="ln745">		&amp;&amp; command &lt;= B_MOUSE_ACCELERATION_CHANGED)</a>
<a name="ln746">		return device-&gt;UpdateSettings();</a>
<a name="ln747"> </a>
<a name="ln748">	return B_BAD_VALUE;</a>
<a name="ln749">}</a>
<a name="ln750"> </a>
<a name="ln751"> </a>
<a name="ln752">status_t</a>
<a name="ln753">MouseInputDevice::_HandleMonitor(BMessage* message)</a>
<a name="ln754">{</a>
<a name="ln755">	MID_CALLED();</a>
<a name="ln756"> </a>
<a name="ln757">	const char* path;</a>
<a name="ln758">	int32 opcode;</a>
<a name="ln759">	if (message-&gt;FindInt32(&quot;opcode&quot;, &amp;opcode) != B_OK</a>
<a name="ln760">		|| (opcode != B_ENTRY_CREATED &amp;&amp; opcode != B_ENTRY_REMOVED)</a>
<a name="ln761">		|| message-&gt;FindString(&quot;path&quot;, &amp;path) != B_OK)</a>
<a name="ln762">		return B_BAD_VALUE;</a>
<a name="ln763"> </a>
<a name="ln764">	if (opcode == B_ENTRY_CREATED)</a>
<a name="ln765">		return _AddDevice(path);</a>
<a name="ln766"> </a>
<a name="ln767">#if 0</a>
<a name="ln768">	return _RemoveDevice(path);</a>
<a name="ln769">#else</a>
<a name="ln770">	// Don't handle B_ENTRY_REMOVED, let the control thread take care of it.</a>
<a name="ln771">	return B_OK;</a>
<a name="ln772">#endif</a>
<a name="ln773">}</a>
<a name="ln774"> </a>
<a name="ln775"> </a>
<a name="ln776">void</a>
<a name="ln777">MouseInputDevice::_RecursiveScan(const char* directory)</a>
<a name="ln778">{</a>
<a name="ln779">	MID_CALLED();</a>
<a name="ln780"> </a>
<a name="ln781">	BEntry entry;</a>
<a name="ln782">	BDirectory dir(directory);</a>
<a name="ln783">	while (dir.GetNextEntry(&amp;entry) == B_OK) {</a>
<a name="ln784">		BPath path;</a>
<a name="ln785">		entry.GetPath(&amp;path);</a>
<a name="ln786"> </a>
<a name="ln787">		if (!strcmp(path.Leaf(), &quot;serial&quot;)) {</a>
<a name="ln788">			// skip serial</a>
<a name="ln789">			continue;</a>
<a name="ln790">		}</a>
<a name="ln791"> </a>
<a name="ln792">		if (entry.IsDirectory())</a>
<a name="ln793">			_RecursiveScan(path.Path());</a>
<a name="ln794">		else</a>
<a name="ln795">			_AddDevice(path.Path());</a>
<a name="ln796">	}</a>
<a name="ln797">}</a>
<a name="ln798"> </a>
<a name="ln799"> </a>
<a name="ln800">MouseDevice*</a>
<a name="ln801">MouseInputDevice::_FindDevice(const char* path) const</a>
<a name="ln802">{</a>
<a name="ln803">	MID_CALLED();</a>
<a name="ln804"> </a>
<a name="ln805">	for (int32 i = fDevices.CountItems() - 1; i &gt;= 0; i--) {</a>
<a name="ln806">		MouseDevice* device = fDevices.ItemAt(i);</a>
<a name="ln807">		if (strcmp(device-&gt;Path(), path) == 0)</a>
<a name="ln808">			return device;</a>
<a name="ln809">	}</a>
<a name="ln810"> </a>
<a name="ln811">	return NULL;</a>
<a name="ln812">}</a>
<a name="ln813"> </a>
<a name="ln814"> </a>
<a name="ln815">status_t</a>
<a name="ln816">MouseInputDevice::_AddDevice(const char* path)</a>
<a name="ln817">{</a>
<a name="ln818">	MID_CALLED();</a>
<a name="ln819"> </a>
<a name="ln820">	BAutolock _(fDeviceListLock);</a>
<a name="ln821"> </a>
<a name="ln822">	_RemoveDevice(path);</a>
<a name="ln823"> </a>
<a name="ln824">	MouseDevice* device = new(std::nothrow) MouseDevice(*this, path);</a>
<a name="ln825">	if (device == NULL) {</a>
<a name="ln826">		TRACE(&quot;No memory\n&quot;);</a>
<a name="ln827">		return B_NO_MEMORY;</a>
<a name="ln828">	}</a>
<a name="ln829"> </a>
<a name="ln830">	if (!fDevices.AddItem(device)) {</a>
<a name="ln831">		TRACE(&quot;No memory in list\n&quot;);</a>
<a name="ln832">		delete device;</a>
<a name="ln833">		return B_NO_MEMORY;</a>
<a name="ln834">	}</a>
<a name="ln835"> </a>
<a name="ln836">	input_device_ref* devices[2];</a>
<a name="ln837">	devices[0] = device-&gt;DeviceRef();</a>
<a name="ln838">	devices[1] = NULL;</a>
<a name="ln839"> </a>
<a name="ln840">	TRACE(&quot;adding path: %s, name: %s\n&quot;, path, devices[0]-&gt;name);</a>
<a name="ln841"> </a>
<a name="ln842">	return RegisterDevices(devices);</a>
<a name="ln843">}</a>
<a name="ln844"> </a>
<a name="ln845"> </a>
<a name="ln846">status_t</a>
<a name="ln847">MouseInputDevice::_RemoveDevice(const char* path)</a>
<a name="ln848">{</a>
<a name="ln849">	MID_CALLED();</a>
<a name="ln850"> </a>
<a name="ln851">	BAutolock _(fDeviceListLock);</a>
<a name="ln852"> </a>
<a name="ln853">	MouseDevice* device = _FindDevice(path);</a>
<a name="ln854">	if (device == NULL) {</a>
<a name="ln855">		TRACE(&quot;%s not found\n&quot;, path);</a>
<a name="ln856">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln857">	}</a>
<a name="ln858"> </a>
<a name="ln859">	input_device_ref* devices[2];</a>
<a name="ln860">	devices[0] = device-&gt;DeviceRef();</a>
<a name="ln861">	devices[1] = NULL;</a>
<a name="ln862"> </a>
<a name="ln863">	TRACE(&quot;removing path: %s, name: %s\n&quot;, path, devices[0]-&gt;name);</a>
<a name="ln864"> </a>
<a name="ln865">	UnregisterDevices(devices);</a>
<a name="ln866"> </a>
<a name="ln867">	fDevices.RemoveItem(device);</a>
<a name="ln868"> </a>
<a name="ln869">	return B_OK;</a>
<a name="ln870">}</a>

</code></pre>
<div class="balloon" rel="166"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fTouchpadSettings.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
