
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>if_sk.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*	$OpenBSD: if_sk.c,v 2.33 2003/08/12 05:23:06 nate Exp $	*/</a>
<a name="ln2"> </a>
<a name="ln3">/*-</a>
<a name="ln4"> * SPDX-License-Identifier: BSD-4-Clause</a>
<a name="ln5"> *</a>
<a name="ln6"> * Copyright (c) 1997, 1998, 1999, 2000</a>
<a name="ln7"> *	Bill Paul &lt;wpaul@ctr.columbia.edu&gt;.  All rights reserved.</a>
<a name="ln8"> *</a>
<a name="ln9"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln10"> * modification, are permitted provided that the following conditions</a>
<a name="ln11"> * are met:</a>
<a name="ln12"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln13"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln14"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln15"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln16"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln17"> * 3. All advertising materials mentioning features or use of this software</a>
<a name="ln18"> *    must display the following acknowledgement:</a>
<a name="ln19"> *	This product includes software developed by Bill Paul.</a>
<a name="ln20"> * 4. Neither the name of the author nor the names of any co-contributors</a>
<a name="ln21"> *    may be used to endorse or promote products derived from this software</a>
<a name="ln22"> *    without specific prior written permission.</a>
<a name="ln23"> *</a>
<a name="ln24"> * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln25"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln26"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln27"> * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD</a>
<a name="ln28"> * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</a>
<a name="ln29"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</a>
<a name="ln30"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</a>
<a name="ln31"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</a>
<a name="ln32"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</a>
<a name="ln33"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF</a>
<a name="ln34"> * THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln35"> */</a>
<a name="ln36">/*-</a>
<a name="ln37"> * Copyright (c) 2003 Nathan L. Binkert &lt;binkertn@umich.edu&gt;</a>
<a name="ln38"> *</a>
<a name="ln39"> * Permission to use, copy, modify, and distribute this software for any</a>
<a name="ln40"> * purpose with or without fee is hereby granted, provided that the above</a>
<a name="ln41"> * copyright notice and this permission notice appear in all copies.</a>
<a name="ln42"> *</a>
<a name="ln43"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES</a>
<a name="ln44"> * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</a>
<a name="ln45"> * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR</a>
<a name="ln46"> * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</a>
<a name="ln47"> * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</a>
<a name="ln48"> * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</a>
<a name="ln49"> * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</a>
<a name="ln50"> */</a>
<a name="ln51"> </a>
<a name="ln52">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln53">__FBSDID(&quot;$FreeBSD: releng/12.0/sys/dev/sk/if_sk.c 336757 2018-07-27 10:40:48Z eadler $&quot;);</a>
<a name="ln54"> </a>
<a name="ln55">/*</a>
<a name="ln56"> * SysKonnect SK-NET gigabit ethernet driver for FreeBSD. Supports</a>
<a name="ln57"> * the SK-984x series adapters, both single port and dual port.</a>
<a name="ln58"> * References:</a>
<a name="ln59"> * 	The XaQti XMAC II datasheet,</a>
<a name="ln60"> *  https://www.freebsd.org/~wpaul/SysKonnect/xmacii_datasheet_rev_c_9-29.pdf</a>
<a name="ln61"> *	The SysKonnect GEnesis manual, http://www.syskonnect.com</a>
<a name="ln62"> *</a>
<a name="ln63"> * Note: XaQti has been acquired by Vitesse, and Vitesse does not have the</a>
<a name="ln64"> * XMAC II datasheet online. I have put my copy at people.freebsd.org as a</a>
<a name="ln65"> * convenience to others until Vitesse corrects this problem:</a>
<a name="ln66"> *</a>
<a name="ln67"> * https://people.freebsd.org/~wpaul/SysKonnect/xmacii_datasheet_rev_c_9-29.pdf</a>
<a name="ln68"> *</a>
<a name="ln69"> * Written by Bill Paul &lt;wpaul@ee.columbia.edu&gt;</a>
<a name="ln70"> * Department of Electrical Engineering</a>
<a name="ln71"> * Columbia University, New York City</a>
<a name="ln72"> */</a>
<a name="ln73">/*</a>
<a name="ln74"> * The SysKonnect gigabit ethernet adapters consist of two main</a>
<a name="ln75"> * components: the SysKonnect GEnesis controller chip and the XaQti Corp.</a>
<a name="ln76"> * XMAC II gigabit ethernet MAC. The XMAC provides all of the MAC</a>
<a name="ln77"> * components and a PHY while the GEnesis controller provides a PCI</a>
<a name="ln78"> * interface with DMA support. Each card may have between 512K and</a>
<a name="ln79"> * 2MB of SRAM on board depending on the configuration.</a>
<a name="ln80"> *</a>
<a name="ln81"> * The SysKonnect GEnesis controller can have either one or two XMAC</a>
<a name="ln82"> * chips connected to it, allowing single or dual port NIC configurations.</a>
<a name="ln83"> * SysKonnect has the distinction of being the only vendor on the market</a>
<a name="ln84"> * with a dual port gigabit ethernet NIC. The GEnesis provides dual FIFOs,</a>
<a name="ln85"> * dual DMA queues, packet/MAC/transmit arbiters and direct access to the</a>
<a name="ln86"> * XMAC registers. This driver takes advantage of these features to allow</a>
<a name="ln87"> * both XMACs to operate as independent interfaces.</a>
<a name="ln88"> */</a>
<a name="ln89"> </a>
<a name="ln90">#include &lt;sys/param.h&gt;</a>
<a name="ln91">#include &lt;sys/systm.h&gt;</a>
<a name="ln92">#include &lt;sys/bus.h&gt;</a>
<a name="ln93">#include &lt;sys/endian.h&gt;</a>
<a name="ln94">#include &lt;sys/mbuf.h&gt;</a>
<a name="ln95">#include &lt;sys/malloc.h&gt;</a>
<a name="ln96">#include &lt;sys/kernel.h&gt;</a>
<a name="ln97">#include &lt;sys/module.h&gt;</a>
<a name="ln98">#include &lt;sys/socket.h&gt;</a>
<a name="ln99">#include &lt;sys/sockio.h&gt;</a>
<a name="ln100">#include &lt;sys/queue.h&gt;</a>
<a name="ln101">#include &lt;sys/sysctl.h&gt;</a>
<a name="ln102"> </a>
<a name="ln103">#include &lt;net/bpf.h&gt;</a>
<a name="ln104">#include &lt;net/ethernet.h&gt;</a>
<a name="ln105">#include &lt;net/if.h&gt;</a>
<a name="ln106">#include &lt;net/if_var.h&gt;</a>
<a name="ln107">#include &lt;net/if_arp.h&gt;</a>
<a name="ln108">#include &lt;net/if_dl.h&gt;</a>
<a name="ln109">#include &lt;net/if_media.h&gt;</a>
<a name="ln110">#include &lt;net/if_types.h&gt;</a>
<a name="ln111">#include &lt;net/if_vlan_var.h&gt;</a>
<a name="ln112"> </a>
<a name="ln113">#include &lt;netinet/in.h&gt;</a>
<a name="ln114">#include &lt;netinet/in_systm.h&gt;</a>
<a name="ln115">#include &lt;netinet/ip.h&gt;</a>
<a name="ln116"> </a>
<a name="ln117">#include &lt;machine/bus.h&gt;</a>
<a name="ln118">#include &lt;machine/in_cksum.h&gt;</a>
<a name="ln119">#include &lt;machine/resource.h&gt;</a>
<a name="ln120">#include &lt;sys/rman.h&gt;</a>
<a name="ln121"> </a>
<a name="ln122">#include &lt;dev/mii/mii.h&gt;</a>
<a name="ln123">#include &lt;dev/mii/miivar.h&gt;</a>
<a name="ln124">#include &lt;dev/mii/brgphyreg.h&gt;</a>
<a name="ln125"> </a>
<a name="ln126">#include &lt;dev/pci/pcireg.h&gt;</a>
<a name="ln127">#include &lt;dev/pci/pcivar.h&gt;</a>
<a name="ln128"> </a>
<a name="ln129">#if 0</a>
<a name="ln130">#define SK_USEIOSPACE</a>
<a name="ln131">#endif</a>
<a name="ln132"> </a>
<a name="ln133">#include &lt;dev/sk/if_skreg.h&gt;</a>
<a name="ln134">#include &lt;dev/sk/xmaciireg.h&gt;</a>
<a name="ln135">#include &lt;dev/sk/yukonreg.h&gt;</a>
<a name="ln136"> </a>
<a name="ln137">MODULE_DEPEND(sk, pci, 1, 1, 1);</a>
<a name="ln138">MODULE_DEPEND(sk, ether, 1, 1, 1);</a>
<a name="ln139">MODULE_DEPEND(sk, miibus, 1, 1, 1);</a>
<a name="ln140"> </a>
<a name="ln141">/* &quot;device miibus&quot; required.  See GENERIC if you get errors here. */</a>
<a name="ln142">#include &quot;miibus_if.h&quot;</a>
<a name="ln143"> </a>
<a name="ln144">static const struct sk_type sk_devs[] = {</a>
<a name="ln145">	{</a>
<a name="ln146">		VENDORID_SK,</a>
<a name="ln147">		DEVICEID_SK_V1,</a>
<a name="ln148">		&quot;SysKonnect Gigabit Ethernet (V1.0)&quot;</a>
<a name="ln149">	},</a>
<a name="ln150">	{</a>
<a name="ln151">		VENDORID_SK,</a>
<a name="ln152">		DEVICEID_SK_V2,</a>
<a name="ln153">		&quot;SysKonnect Gigabit Ethernet (V2.0)&quot;</a>
<a name="ln154">	},</a>
<a name="ln155">	{</a>
<a name="ln156">		VENDORID_MARVELL,</a>
<a name="ln157">		DEVICEID_SK_V2,</a>
<a name="ln158">		&quot;Marvell Gigabit Ethernet&quot;</a>
<a name="ln159">	},</a>
<a name="ln160">	{</a>
<a name="ln161">		VENDORID_MARVELL,</a>
<a name="ln162">		DEVICEID_BELKIN_5005,</a>
<a name="ln163">		&quot;Belkin F5D5005 Gigabit Ethernet&quot;</a>
<a name="ln164">	},</a>
<a name="ln165">	{</a>
<a name="ln166">		VENDORID_3COM,</a>
<a name="ln167">		DEVICEID_3COM_3C940,</a>
<a name="ln168">		&quot;3Com 3C940 Gigabit Ethernet&quot;</a>
<a name="ln169">	},</a>
<a name="ln170">	{</a>
<a name="ln171">		VENDORID_LINKSYS,</a>
<a name="ln172">		DEVICEID_LINKSYS_EG1032,</a>
<a name="ln173">		&quot;Linksys EG1032 Gigabit Ethernet&quot;</a>
<a name="ln174">	},</a>
<a name="ln175">	{</a>
<a name="ln176">		VENDORID_DLINK,</a>
<a name="ln177">		DEVICEID_DLINK_DGE530T_A1,</a>
<a name="ln178">		&quot;D-Link DGE-530T Gigabit Ethernet&quot;</a>
<a name="ln179">	},</a>
<a name="ln180">	{</a>
<a name="ln181">		VENDORID_DLINK,</a>
<a name="ln182">		DEVICEID_DLINK_DGE530T_B1,</a>
<a name="ln183">		&quot;D-Link DGE-530T Gigabit Ethernet&quot;</a>
<a name="ln184">	},</a>
<a name="ln185">	{ 0, 0, NULL }</a>
<a name="ln186">};</a>
<a name="ln187"> </a>
<a name="ln188">static int skc_probe(device_t);</a>
<a name="ln189">static int skc_attach(device_t);</a>
<a name="ln190">static int skc_detach(device_t);</a>
<a name="ln191">static int skc_shutdown(device_t);</a>
<a name="ln192">static int skc_suspend(device_t);</a>
<a name="ln193">static int skc_resume(device_t);</a>
<a name="ln194">static bus_dma_tag_t skc_get_dma_tag(device_t, device_t);</a>
<a name="ln195">static int sk_detach(device_t);</a>
<a name="ln196">static int sk_probe(device_t);</a>
<a name="ln197">static int sk_attach(device_t);</a>
<a name="ln198">static void sk_tick(void *);</a>
<a name="ln199">static void sk_yukon_tick(void *);</a>
<a name="ln200">static void sk_intr(void *);</a>
<a name="ln201">static void sk_intr_xmac(struct sk_if_softc *);</a>
<a name="ln202">static void sk_intr_bcom(struct sk_if_softc *);</a>
<a name="ln203">static void sk_intr_yukon(struct sk_if_softc *);</a>
<a name="ln204">static __inline void sk_rxcksum(struct ifnet *, struct mbuf *, u_int32_t);</a>
<a name="ln205">static __inline int sk_rxvalid(struct sk_softc *, u_int32_t, u_int32_t);</a>
<a name="ln206">static void sk_rxeof(struct sk_if_softc *);</a>
<a name="ln207">static void sk_jumbo_rxeof(struct sk_if_softc *);</a>
<a name="ln208">static void sk_txeof(struct sk_if_softc *);</a>
<a name="ln209">static void sk_txcksum(struct ifnet *, struct mbuf *, struct sk_tx_desc *);</a>
<a name="ln210">static int sk_encap(struct sk_if_softc *, struct mbuf **);</a>
<a name="ln211">static void sk_start(struct ifnet *);</a>
<a name="ln212">static void sk_start_locked(struct ifnet *);</a>
<a name="ln213">static int sk_ioctl(struct ifnet *, u_long, caddr_t);</a>
<a name="ln214">static void sk_init(void *);</a>
<a name="ln215">static void sk_init_locked(struct sk_if_softc *);</a>
<a name="ln216">static void sk_init_xmac(struct sk_if_softc *);</a>
<a name="ln217">static void sk_init_yukon(struct sk_if_softc *);</a>
<a name="ln218">static void sk_stop(struct sk_if_softc *);</a>
<a name="ln219">static void sk_watchdog(void *);</a>
<a name="ln220">static int sk_ifmedia_upd(struct ifnet *);</a>
<a name="ln221">static void sk_ifmedia_sts(struct ifnet *, struct ifmediareq *);</a>
<a name="ln222">static void sk_reset(struct sk_softc *);</a>
<a name="ln223">static __inline void sk_discard_rxbuf(struct sk_if_softc *, int);</a>
<a name="ln224">static __inline void sk_discard_jumbo_rxbuf(struct sk_if_softc *, int);</a>
<a name="ln225">static int sk_newbuf(struct sk_if_softc *, int);</a>
<a name="ln226">static int sk_jumbo_newbuf(struct sk_if_softc *, int);</a>
<a name="ln227">static void sk_dmamap_cb(void *, bus_dma_segment_t *, int, int);</a>
<a name="ln228">static int sk_dma_alloc(struct sk_if_softc *);</a>
<a name="ln229">static int sk_dma_jumbo_alloc(struct sk_if_softc *);</a>
<a name="ln230">static void sk_dma_free(struct sk_if_softc *);</a>
<a name="ln231">static void sk_dma_jumbo_free(struct sk_if_softc *);</a>
<a name="ln232">static int sk_init_rx_ring(struct sk_if_softc *);</a>
<a name="ln233">static int sk_init_jumbo_rx_ring(struct sk_if_softc *);</a>
<a name="ln234">static void sk_init_tx_ring(struct sk_if_softc *);</a>
<a name="ln235">static u_int32_t sk_win_read_4(struct sk_softc *, int);</a>
<a name="ln236">static u_int16_t sk_win_read_2(struct sk_softc *, int);</a>
<a name="ln237">static u_int8_t sk_win_read_1(struct sk_softc *, int);</a>
<a name="ln238">static void sk_win_write_4(struct sk_softc *, int, u_int32_t);</a>
<a name="ln239">static void sk_win_write_2(struct sk_softc *, int, u_int32_t);</a>
<a name="ln240">static void sk_win_write_1(struct sk_softc *, int, u_int32_t);</a>
<a name="ln241"> </a>
<a name="ln242">static int sk_miibus_readreg(device_t, int, int);</a>
<a name="ln243">static int sk_miibus_writereg(device_t, int, int, int);</a>
<a name="ln244">static void sk_miibus_statchg(device_t);</a>
<a name="ln245"> </a>
<a name="ln246">static int sk_xmac_miibus_readreg(struct sk_if_softc *, int, int);</a>
<a name="ln247">static int sk_xmac_miibus_writereg(struct sk_if_softc *, int, int,</a>
<a name="ln248">						int);</a>
<a name="ln249">static void sk_xmac_miibus_statchg(struct sk_if_softc *);</a>
<a name="ln250"> </a>
<a name="ln251">static int sk_marv_miibus_readreg(struct sk_if_softc *, int, int);</a>
<a name="ln252">static int sk_marv_miibus_writereg(struct sk_if_softc *, int, int,</a>
<a name="ln253">						int);</a>
<a name="ln254">static void sk_marv_miibus_statchg(struct sk_if_softc *);</a>
<a name="ln255"> </a>
<a name="ln256">static uint32_t sk_xmchash(const uint8_t *);</a>
<a name="ln257">static void sk_setfilt(struct sk_if_softc *, u_int16_t *, int);</a>
<a name="ln258">static void sk_rxfilter(struct sk_if_softc *);</a>
<a name="ln259">static void sk_rxfilter_genesis(struct sk_if_softc *);</a>
<a name="ln260">static void sk_rxfilter_yukon(struct sk_if_softc *);</a>
<a name="ln261"> </a>
<a name="ln262">static int sysctl_int_range(SYSCTL_HANDLER_ARGS, int low, int high);</a>
<a name="ln263">static int sysctl_hw_sk_int_mod(SYSCTL_HANDLER_ARGS);</a>
<a name="ln264"> </a>
<a name="ln265">/* Tunables. */</a>
<a name="ln266">static int jumbo_disable = 0;</a>
<a name="ln267">TUNABLE_INT(&quot;hw.skc.jumbo_disable&quot;, &amp;jumbo_disable);</a>
<a name="ln268"> </a>
<a name="ln269">#ifdef __HAIKU__</a>
<a name="ln270">static u_short in_addword(u_short a, u_short b);</a>
<a name="ln271">#endif</a>
<a name="ln272"> </a>
<a name="ln273">/*</a>
<a name="ln274"> * It seems that SK-NET GENESIS supports very simple checksum offload</a>
<a name="ln275"> * capability for Tx and I believe it can generate 0 checksum value for</a>
<a name="ln276"> * UDP packets in Tx as the hardware can't differenciate UDP packets from</a>
<a name="ln277"> * TCP packets. 0 chcecksum value for UDP packet is an invalid one as it</a>
<a name="ln278"> * means sender didn't perforam checksum computation. For the safety I</a>
<a name="ln279"> * disabled UDP checksum offload capability at the moment. Alternatively</a>
<a name="ln280"> * we can intrduce a LINK0/LINK1 flag as hme(4) did in its Tx checksum</a>
<a name="ln281"> * offload routine.</a>
<a name="ln282"> */</a>
<a name="ln283">#define SK_CSUM_FEATURES	(CSUM_TCP)</a>
<a name="ln284"> </a>
<a name="ln285">/*</a>
<a name="ln286"> * Note that we have newbus methods for both the GEnesis controller</a>
<a name="ln287"> * itself and the XMAC(s). The XMACs are children of the GEnesis, and</a>
<a name="ln288"> * the miibus code is a child of the XMACs. We need to do it this way</a>
<a name="ln289"> * so that the miibus drivers can access the PHY registers on the</a>
<a name="ln290"> * right PHY. It's not quite what I had in mind, but it's the only</a>
<a name="ln291"> * design that achieves the desired effect.</a>
<a name="ln292"> */</a>
<a name="ln293">static device_method_t skc_methods[] = {</a>
<a name="ln294">	/* Device interface */</a>
<a name="ln295">	DEVMETHOD(device_probe,		skc_probe),</a>
<a name="ln296">	DEVMETHOD(device_attach,	skc_attach),</a>
<a name="ln297">	DEVMETHOD(device_detach,	skc_detach),</a>
<a name="ln298">	DEVMETHOD(device_suspend,	skc_suspend),</a>
<a name="ln299">	DEVMETHOD(device_resume,	skc_resume),</a>
<a name="ln300">	DEVMETHOD(device_shutdown,	skc_shutdown),</a>
<a name="ln301"> </a>
<a name="ln302">	DEVMETHOD(bus_get_dma_tag,	skc_get_dma_tag),</a>
<a name="ln303"> </a>
<a name="ln304">	DEVMETHOD_END</a>
<a name="ln305">};</a>
<a name="ln306"> </a>
<a name="ln307">static driver_t skc_driver = {</a>
<a name="ln308">	&quot;skc&quot;,</a>
<a name="ln309">	skc_methods,</a>
<a name="ln310">	sizeof(struct sk_softc)</a>
<a name="ln311">};</a>
<a name="ln312"> </a>
<a name="ln313">static devclass_t skc_devclass;</a>
<a name="ln314"> </a>
<a name="ln315">static device_method_t sk_methods[] = {</a>
<a name="ln316">	/* Device interface */</a>
<a name="ln317">	DEVMETHOD(device_probe,		sk_probe),</a>
<a name="ln318">	DEVMETHOD(device_attach,	sk_attach),</a>
<a name="ln319">	DEVMETHOD(device_detach,	sk_detach),</a>
<a name="ln320">	DEVMETHOD(device_shutdown,	bus_generic_shutdown),</a>
<a name="ln321"> </a>
<a name="ln322">	/* MII interface */</a>
<a name="ln323">	DEVMETHOD(miibus_readreg,	sk_miibus_readreg),</a>
<a name="ln324">	DEVMETHOD(miibus_writereg,	sk_miibus_writereg),</a>
<a name="ln325">	DEVMETHOD(miibus_statchg,	sk_miibus_statchg),</a>
<a name="ln326"> </a>
<a name="ln327">	DEVMETHOD_END</a>
<a name="ln328">};</a>
<a name="ln329"> </a>
<a name="ln330">static driver_t sk_driver = {</a>
<a name="ln331">	&quot;sk&quot;,</a>
<a name="ln332">	sk_methods,</a>
<a name="ln333">	sizeof(struct sk_if_softc)</a>
<a name="ln334">};</a>
<a name="ln335"> </a>
<a name="ln336">static devclass_t sk_devclass;</a>
<a name="ln337"> </a>
<a name="ln338">DRIVER_MODULE(skc, pci, skc_driver, skc_devclass, NULL, NULL);</a>
<a name="ln339">DRIVER_MODULE(sk, skc, sk_driver, sk_devclass, NULL, NULL);</a>
<a name="ln340">DRIVER_MODULE(miibus, sk, miibus_driver, miibus_devclass, NULL, NULL);</a>
<a name="ln341"> </a>
<a name="ln342">static struct resource_spec sk_res_spec_io[] = {</a>
<a name="ln343">	{ SYS_RES_IOPORT,	PCIR_BAR(1),	RF_ACTIVE },</a>
<a name="ln344">	{ SYS_RES_IRQ,		0,		RF_ACTIVE | RF_SHAREABLE },</a>
<a name="ln345">	{ -1,			0,		0 }</a>
<a name="ln346">};</a>
<a name="ln347"> </a>
<a name="ln348">static struct resource_spec sk_res_spec_mem[] = {</a>
<a name="ln349">	{ SYS_RES_MEMORY,	PCIR_BAR(0),	RF_ACTIVE },</a>
<a name="ln350">	{ SYS_RES_IRQ,		0,		RF_ACTIVE | RF_SHAREABLE },</a>
<a name="ln351">	{ -1,			0,		0 }</a>
<a name="ln352">};</a>
<a name="ln353"> </a>
<a name="ln354">#define SK_SETBIT(sc, reg, x)		\</a>
<a name="ln355">	CSR_WRITE_4(sc, reg, CSR_READ_4(sc, reg) | x)</a>
<a name="ln356"> </a>
<a name="ln357">#define SK_CLRBIT(sc, reg, x)		\</a>
<a name="ln358">	CSR_WRITE_4(sc, reg, CSR_READ_4(sc, reg) &amp; ~x)</a>
<a name="ln359"> </a>
<a name="ln360">#define SK_WIN_SETBIT_4(sc, reg, x)	\</a>
<a name="ln361">	sk_win_write_4(sc, reg, sk_win_read_4(sc, reg) | x)</a>
<a name="ln362"> </a>
<a name="ln363">#define SK_WIN_CLRBIT_4(sc, reg, x)	\</a>
<a name="ln364">	sk_win_write_4(sc, reg, sk_win_read_4(sc, reg) &amp; ~x)</a>
<a name="ln365"> </a>
<a name="ln366">#define SK_WIN_SETBIT_2(sc, reg, x)	\</a>
<a name="ln367">	sk_win_write_2(sc, reg, sk_win_read_2(sc, reg) | x)</a>
<a name="ln368"> </a>
<a name="ln369">#define SK_WIN_CLRBIT_2(sc, reg, x)	\</a>
<a name="ln370">	sk_win_write_2(sc, reg, sk_win_read_2(sc, reg) &amp; ~x)</a>
<a name="ln371"> </a>
<a name="ln372">static u_int32_t</a>
<a name="ln373">sk_win_read_4(sc, reg)</a>
<a name="ln374">	struct sk_softc		*sc;</a>
<a name="ln375">	int			reg;</a>
<a name="ln376">{</a>
<a name="ln377">#ifdef SK_USEIOSPACE</a>
<a name="ln378">	CSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));</a>
<a name="ln379">	return(CSR_READ_4(sc, SK_WIN_BASE + SK_REG(reg)));</a>
<a name="ln380">#else</a>
<a name="ln381">	return(CSR_READ_4(sc, reg));</a>
<a name="ln382">#endif</a>
<a name="ln383">}</a>
<a name="ln384"> </a>
<a name="ln385">static u_int16_t</a>
<a name="ln386">sk_win_read_2(sc, reg)</a>
<a name="ln387">	struct sk_softc		*sc;</a>
<a name="ln388">	int			reg;</a>
<a name="ln389">{</a>
<a name="ln390">#ifdef SK_USEIOSPACE</a>
<a name="ln391">	CSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));</a>
<a name="ln392">	return(CSR_READ_2(sc, SK_WIN_BASE + SK_REG(reg)));</a>
<a name="ln393">#else</a>
<a name="ln394">	return(CSR_READ_2(sc, reg));</a>
<a name="ln395">#endif</a>
<a name="ln396">}</a>
<a name="ln397"> </a>
<a name="ln398">static u_int8_t</a>
<a name="ln399">sk_win_read_1(sc, reg)</a>
<a name="ln400">	struct sk_softc		*sc;</a>
<a name="ln401">	int			reg;</a>
<a name="ln402">{</a>
<a name="ln403">#ifdef SK_USEIOSPACE</a>
<a name="ln404">	CSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));</a>
<a name="ln405">	return(CSR_READ_1(sc, SK_WIN_BASE + SK_REG(reg)));</a>
<a name="ln406">#else</a>
<a name="ln407">	return(CSR_READ_1(sc, reg));</a>
<a name="ln408">#endif</a>
<a name="ln409">}</a>
<a name="ln410"> </a>
<a name="ln411">static void</a>
<a name="ln412">sk_win_write_4(sc, reg, val)</a>
<a name="ln413">	struct sk_softc		*sc;</a>
<a name="ln414">	int			reg;</a>
<a name="ln415">	u_int32_t		val;</a>
<a name="ln416">{</a>
<a name="ln417">#ifdef SK_USEIOSPACE</a>
<a name="ln418">	CSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));</a>
<a name="ln419">	CSR_WRITE_4(sc, SK_WIN_BASE + SK_REG(reg), val);</a>
<a name="ln420">#else</a>
<a name="ln421">	CSR_WRITE_4(sc, reg, val);</a>
<a name="ln422">#endif</a>
<a name="ln423">	return;</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426">static void</a>
<a name="ln427">sk_win_write_2(sc, reg, val)</a>
<a name="ln428">	struct sk_softc		*sc;</a>
<a name="ln429">	int			reg;</a>
<a name="ln430">	u_int32_t		val;</a>
<a name="ln431">{</a>
<a name="ln432">#ifdef SK_USEIOSPACE</a>
<a name="ln433">	CSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));</a>
<a name="ln434">	CSR_WRITE_2(sc, SK_WIN_BASE + SK_REG(reg), val);</a>
<a name="ln435">#else</a>
<a name="ln436">	CSR_WRITE_2(sc, reg, val);</a>
<a name="ln437">#endif</a>
<a name="ln438">	return;</a>
<a name="ln439">}</a>
<a name="ln440"> </a>
<a name="ln441">static void</a>
<a name="ln442">sk_win_write_1(sc, reg, val)</a>
<a name="ln443">	struct sk_softc		*sc;</a>
<a name="ln444">	int			reg;</a>
<a name="ln445">	u_int32_t		val;</a>
<a name="ln446">{</a>
<a name="ln447">#ifdef SK_USEIOSPACE</a>
<a name="ln448">	CSR_WRITE_4(sc, SK_RAP, SK_WIN(reg));</a>
<a name="ln449">	CSR_WRITE_1(sc, SK_WIN_BASE + SK_REG(reg), val);</a>
<a name="ln450">#else</a>
<a name="ln451">	CSR_WRITE_1(sc, reg, val);</a>
<a name="ln452">#endif</a>
<a name="ln453">	return;</a>
<a name="ln454">}</a>
<a name="ln455"> </a>
<a name="ln456">#ifdef __HAIKU__</a>
<a name="ln457">/* stole these from in_cksum.c */</a>
<a name="ln458">#define ADDCARRY(x)  (x &gt; 65535 ? x -= 65535 : x)</a>
<a name="ln459">static u_short</a>
<a name="ln460">in_addword(u_short a, u_short b)</a>
<a name="ln461">{</a>
<a name="ln462">	u_int64_t sum = a + b;</a>
<a name="ln463"> </a>
<a name="ln464">	ADDCARRY(sum);</a>
<a name="ln465">	return (sum);</a>
<a name="ln466">}</a>
<a name="ln467">#endif</a>
<a name="ln468"> </a>
<a name="ln469">static int</a>
<a name="ln470">sk_miibus_readreg(dev, phy, reg)</a>
<a name="ln471">	device_t		dev;</a>
<a name="ln472">	int			phy, reg;</a>
<a name="ln473">{</a>
<a name="ln474">	struct sk_if_softc	*sc_if;</a>
<a name="ln475">	int			v;</a>
<a name="ln476"> </a>
<a name="ln477">	sc_if = device_get_softc(dev);</a>
<a name="ln478"> </a>
<a name="ln479">	SK_IF_MII_LOCK(sc_if);</a>
<a name="ln480">	switch(sc_if-&gt;sk_softc-&gt;sk_type) {</a>
<a name="ln481">	case SK_GENESIS:</a>
<a name="ln482">		v = sk_xmac_miibus_readreg(sc_if, phy, reg);</a>
<a name="ln483">		break;</a>
<a name="ln484">	case SK_YUKON:</a>
<a name="ln485">	case SK_YUKON_LITE:</a>
<a name="ln486">	case SK_YUKON_LP:</a>
<a name="ln487">		v = sk_marv_miibus_readreg(sc_if, phy, reg);</a>
<a name="ln488">		break;</a>
<a name="ln489">	default:</a>
<a name="ln490">		v = 0;</a>
<a name="ln491">		break;</a>
<a name="ln492">	}</a>
<a name="ln493">	SK_IF_MII_UNLOCK(sc_if);</a>
<a name="ln494"> </a>
<a name="ln495">	return (v);</a>
<a name="ln496">}</a>
<a name="ln497"> </a>
<a name="ln498">static int</a>
<a name="ln499">sk_miibus_writereg(dev, phy, reg, val)</a>
<a name="ln500">	device_t		dev;</a>
<a name="ln501">	int			phy, reg, val;</a>
<a name="ln502">{</a>
<a name="ln503">	struct sk_if_softc	*sc_if;</a>
<a name="ln504">	int			v;</a>
<a name="ln505"> </a>
<a name="ln506">	sc_if = device_get_softc(dev);</a>
<a name="ln507"> </a>
<a name="ln508">	SK_IF_MII_LOCK(sc_if);</a>
<a name="ln509">	switch(sc_if-&gt;sk_softc-&gt;sk_type) {</a>
<a name="ln510">	case SK_GENESIS:</a>
<a name="ln511">		v = sk_xmac_miibus_writereg(sc_if, phy, reg, val);</a>
<a name="ln512">		break;</a>
<a name="ln513">	case SK_YUKON:</a>
<a name="ln514">	case SK_YUKON_LITE:</a>
<a name="ln515">	case SK_YUKON_LP:</a>
<a name="ln516">		v = sk_marv_miibus_writereg(sc_if, phy, reg, val);</a>
<a name="ln517">		break;</a>
<a name="ln518">	default:</a>
<a name="ln519">		v = 0;</a>
<a name="ln520">		break;</a>
<a name="ln521">	}</a>
<a name="ln522">	SK_IF_MII_UNLOCK(sc_if);</a>
<a name="ln523"> </a>
<a name="ln524">	return (v);</a>
<a name="ln525">}</a>
<a name="ln526"> </a>
<a name="ln527">static void</a>
<a name="ln528">sk_miibus_statchg(dev)</a>
<a name="ln529">	device_t		dev;</a>
<a name="ln530">{</a>
<a name="ln531">	struct sk_if_softc	*sc_if;</a>
<a name="ln532"> </a>
<a name="ln533">	sc_if = device_get_softc(dev);</a>
<a name="ln534"> </a>
<a name="ln535">	SK_IF_MII_LOCK(sc_if);</a>
<a name="ln536">	switch(sc_if-&gt;sk_softc-&gt;sk_type) {</a>
<a name="ln537">	case SK_GENESIS:</a>
<a name="ln538">		sk_xmac_miibus_statchg(sc_if);</a>
<a name="ln539">		break;</a>
<a name="ln540">	case SK_YUKON:</a>
<a name="ln541">	case SK_YUKON_LITE:</a>
<a name="ln542">	case SK_YUKON_LP:</a>
<a name="ln543">		sk_marv_miibus_statchg(sc_if);</a>
<a name="ln544">		break;</a>
<a name="ln545">	}</a>
<a name="ln546">	SK_IF_MII_UNLOCK(sc_if);</a>
<a name="ln547"> </a>
<a name="ln548">	return;</a>
<a name="ln549">}</a>
<a name="ln550"> </a>
<a name="ln551">static int</a>
<a name="ln552">sk_xmac_miibus_readreg(sc_if, phy, reg)</a>
<a name="ln553">	struct sk_if_softc	*sc_if;</a>
<a name="ln554">	int			phy, reg;</a>
<a name="ln555">{</a>
<a name="ln556">	int			i;</a>
<a name="ln557"> </a>
<a name="ln558">	SK_XM_WRITE_2(sc_if, XM_PHY_ADDR, reg|(phy &lt;&lt; 8));</a>
<a name="ln559">	SK_XM_READ_2(sc_if, XM_PHY_DATA);</a>
<a name="ln560">	if (sc_if-&gt;sk_phytype != SK_PHYTYPE_XMAC) {</a>
<a name="ln561">		for (i = 0; i &lt; SK_TIMEOUT; i++) {</a>
<a name="ln562">			DELAY(1);</a>
<a name="ln563">			if (SK_XM_READ_2(sc_if, XM_MMUCMD) &amp;</a>
<a name="ln564">			    XM_MMUCMD_PHYDATARDY)</a>
<a name="ln565">				break;</a>
<a name="ln566">		}</a>
<a name="ln567"> </a>
<a name="ln568">		if (i == SK_TIMEOUT) {</a>
<a name="ln569">			if_printf(sc_if-&gt;sk_ifp, &quot;phy failed to come ready\n&quot;);</a>
<a name="ln570">			return(0);</a>
<a name="ln571">		}</a>
<a name="ln572">	}</a>
<a name="ln573">	DELAY(1);</a>
<a name="ln574">	i = SK_XM_READ_2(sc_if, XM_PHY_DATA);</a>
<a name="ln575"> </a>
<a name="ln576">	return(i);</a>
<a name="ln577">}</a>
<a name="ln578"> </a>
<a name="ln579">static int</a>
<a name="ln580">sk_xmac_miibus_writereg(sc_if, phy, reg, val)</a>
<a name="ln581">	struct sk_if_softc	*sc_if;</a>
<a name="ln582">	int			phy, reg, val;</a>
<a name="ln583">{</a>
<a name="ln584">	int			i;</a>
<a name="ln585"> </a>
<a name="ln586">	SK_XM_WRITE_2(sc_if, XM_PHY_ADDR, reg|(phy &lt;&lt; 8));</a>
<a name="ln587">	for (i = 0; i &lt; SK_TIMEOUT; i++) {</a>
<a name="ln588">		if (!(SK_XM_READ_2(sc_if, XM_MMUCMD) &amp; XM_MMUCMD_PHYBUSY))</a>
<a name="ln589">			break;</a>
<a name="ln590">	}</a>
<a name="ln591"> </a>
<a name="ln592">	if (i == SK_TIMEOUT) {</a>
<a name="ln593">		if_printf(sc_if-&gt;sk_ifp, &quot;phy failed to come ready\n&quot;);</a>
<a name="ln594">		return (ETIMEDOUT);</a>
<a name="ln595">	}</a>
<a name="ln596"> </a>
<a name="ln597">	SK_XM_WRITE_2(sc_if, XM_PHY_DATA, val);</a>
<a name="ln598">	for (i = 0; i &lt; SK_TIMEOUT; i++) {</a>
<a name="ln599">		DELAY(1);</a>
<a name="ln600">		if (!(SK_XM_READ_2(sc_if, XM_MMUCMD) &amp; XM_MMUCMD_PHYBUSY))</a>
<a name="ln601">			break;</a>
<a name="ln602">	}</a>
<a name="ln603">	if (i == SK_TIMEOUT)</a>
<a name="ln604">		if_printf(sc_if-&gt;sk_ifp, &quot;phy write timed out\n&quot;);</a>
<a name="ln605"> </a>
<a name="ln606">	return(0);</a>
<a name="ln607">}</a>
<a name="ln608"> </a>
<a name="ln609">static void</a>
<a name="ln610">sk_xmac_miibus_statchg(sc_if)</a>
<a name="ln611">	struct sk_if_softc	*sc_if;</a>
<a name="ln612">{</a>
<a name="ln613">	struct mii_data		*mii;</a>
<a name="ln614"> </a>
<a name="ln615">	mii = device_get_softc(sc_if-&gt;sk_miibus);</a>
<a name="ln616"> </a>
<a name="ln617">	/*</a>
<a name="ln618">	 * If this is a GMII PHY, manually set the XMAC's</a>
<a name="ln619">	 * duplex mode accordingly.</a>
<a name="ln620">	 */</a>
<a name="ln621">	if (sc_if-&gt;sk_phytype != SK_PHYTYPE_XMAC) {</a>
<a name="ln622">		if ((mii-&gt;mii_media_active &amp; IFM_GMASK) == IFM_FDX) {</a>
<a name="ln623">			SK_XM_SETBIT_2(sc_if, XM_MMUCMD, XM_MMUCMD_GMIIFDX);</a>
<a name="ln624">		} else {</a>
<a name="ln625">			SK_XM_CLRBIT_2(sc_if, XM_MMUCMD, XM_MMUCMD_GMIIFDX);</a>
<a name="ln626">		}</a>
<a name="ln627">	}</a>
<a name="ln628">}</a>
<a name="ln629"> </a>
<a name="ln630">static int</a>
<a name="ln631">sk_marv_miibus_readreg(sc_if, phy, reg)</a>
<a name="ln632">	struct sk_if_softc	*sc_if;</a>
<a name="ln633">	int			phy, reg;</a>
<a name="ln634">{</a>
<a name="ln635">	u_int16_t		val;</a>
<a name="ln636">	int			i;</a>
<a name="ln637"> </a>
<a name="ln638">	if (sc_if-&gt;sk_phytype != SK_PHYTYPE_MARV_COPPER &amp;&amp;</a>
<a name="ln639">	    sc_if-&gt;sk_phytype != SK_PHYTYPE_MARV_FIBER) {</a>
<a name="ln640">		return(0);</a>
<a name="ln641">	}</a>
<a name="ln642"> </a>
<a name="ln643">        SK_YU_WRITE_2(sc_if, YUKON_SMICR, YU_SMICR_PHYAD(phy) |</a>
<a name="ln644">		      YU_SMICR_REGAD(reg) | YU_SMICR_OP_READ);</a>
<a name="ln645"> </a>
<a name="ln646">	for (i = 0; i &lt; SK_TIMEOUT; i++) {</a>
<a name="ln647">		DELAY(1);</a>
<a name="ln648">		val = SK_YU_READ_2(sc_if, YUKON_SMICR);</a>
<a name="ln649">		if (val &amp; YU_SMICR_READ_VALID)</a>
<a name="ln650">			break;</a>
<a name="ln651">	}</a>
<a name="ln652"> </a>
<a name="ln653">	if (i == SK_TIMEOUT) {</a>
<a name="ln654">		if_printf(sc_if-&gt;sk_ifp, &quot;phy failed to come ready\n&quot;);</a>
<a name="ln655">		return(0);</a>
<a name="ln656">	}</a>
<a name="ln657"> </a>
<a name="ln658">	val = SK_YU_READ_2(sc_if, YUKON_SMIDR);</a>
<a name="ln659"> </a>
<a name="ln660">	return(val);</a>
<a name="ln661">}</a>
<a name="ln662"> </a>
<a name="ln663">static int</a>
<a name="ln664">sk_marv_miibus_writereg(sc_if, phy, reg, val)</a>
<a name="ln665">	struct sk_if_softc	*sc_if;</a>
<a name="ln666">	int			phy, reg, val;</a>
<a name="ln667">{</a>
<a name="ln668">	int			i;</a>
<a name="ln669"> </a>
<a name="ln670">	SK_YU_WRITE_2(sc_if, YUKON_SMIDR, val);</a>
<a name="ln671">	SK_YU_WRITE_2(sc_if, YUKON_SMICR, YU_SMICR_PHYAD(phy) |</a>
<a name="ln672">		      YU_SMICR_REGAD(reg) | YU_SMICR_OP_WRITE);</a>
<a name="ln673"> </a>
<a name="ln674">	for (i = 0; i &lt; SK_TIMEOUT; i++) {</a>
<a name="ln675">		DELAY(1);</a>
<a name="ln676">		if ((SK_YU_READ_2(sc_if, YUKON_SMICR) &amp; YU_SMICR_BUSY) == 0)</a>
<a name="ln677">			break;</a>
<a name="ln678">	}</a>
<a name="ln679">	if (i == SK_TIMEOUT)</a>
<a name="ln680">		if_printf(sc_if-&gt;sk_ifp, &quot;phy write timeout\n&quot;);</a>
<a name="ln681"> </a>
<a name="ln682">	return(0);</a>
<a name="ln683">}</a>
<a name="ln684"> </a>
<a name="ln685">static void</a>
<a name="ln686">sk_marv_miibus_statchg(sc_if)</a>
<a name="ln687">	struct sk_if_softc	*sc_if;</a>
<a name="ln688">{</a>
<a name="ln689">	return;</a>
<a name="ln690">}</a>
<a name="ln691"> </a>
<a name="ln692">#define HASH_BITS		6</a>
<a name="ln693"> </a>
<a name="ln694">static u_int32_t</a>
<a name="ln695">sk_xmchash(addr)</a>
<a name="ln696">	const uint8_t *addr;</a>
<a name="ln697">{</a>
<a name="ln698">	uint32_t crc;</a>
<a name="ln699"> </a>
<a name="ln700">	/* Compute CRC for the address value. */</a>
<a name="ln701">	crc = ether_crc32_le(addr, ETHER_ADDR_LEN);</a>
<a name="ln702"> </a>
<a name="ln703">	return (~crc &amp; ((1 &lt;&lt; HASH_BITS) - 1));</a>
<a name="ln704">}</a>
<a name="ln705"> </a>
<a name="ln706">static void</a>
<a name="ln707">sk_setfilt(sc_if, addr, slot)</a>
<a name="ln708">	struct sk_if_softc	*sc_if;</a>
<a name="ln709">	u_int16_t		*addr;</a>
<a name="ln710">	int			slot;</a>
<a name="ln711">{</a>
<a name="ln712">	int			base;</a>
<a name="ln713"> </a>
<a name="ln714">	base = XM_RXFILT_ENTRY(slot);</a>
<a name="ln715"> </a>
<a name="ln716">	SK_XM_WRITE_2(sc_if, base, addr[0]);</a>
<a name="ln717">	SK_XM_WRITE_2(sc_if, base + 2, addr[1]);</a>
<a name="ln718">	SK_XM_WRITE_2(sc_if, base + 4, addr[2]);</a>
<a name="ln719"> </a>
<a name="ln720">	return;</a>
<a name="ln721">}</a>
<a name="ln722"> </a>
<a name="ln723">static void</a>
<a name="ln724">sk_rxfilter(sc_if)</a>
<a name="ln725">	struct sk_if_softc	*sc_if;</a>
<a name="ln726">{</a>
<a name="ln727">	struct sk_softc		*sc;</a>
<a name="ln728"> </a>
<a name="ln729">	SK_IF_LOCK_ASSERT(sc_if);</a>
<a name="ln730"> </a>
<a name="ln731">	sc = sc_if-&gt;sk_softc;</a>
<a name="ln732">	if (sc-&gt;sk_type == SK_GENESIS)</a>
<a name="ln733">		sk_rxfilter_genesis(sc_if);</a>
<a name="ln734">	else</a>
<a name="ln735">		sk_rxfilter_yukon(sc_if);</a>
<a name="ln736">}</a>
<a name="ln737"> </a>
<a name="ln738">static void</a>
<a name="ln739">sk_rxfilter_genesis(sc_if)</a>
<a name="ln740">	struct sk_if_softc	*sc_if;</a>
<a name="ln741">{</a>
<a name="ln742">	struct ifnet		*ifp = sc_if-&gt;sk_ifp;</a>
<a name="ln743">	u_int32_t		hashes[2] = { 0, 0 }, mode;</a>
<a name="ln744">	int			h = 0, i;</a>
<a name="ln745">	struct ifmultiaddr	*ifma;</a>
<a name="ln746">	u_int16_t		dummy[] = { 0, 0, 0 };</a>
<a name="ln747">	u_int16_t		maddr[(ETHER_ADDR_LEN+1)/2];</a>
<a name="ln748"> </a>
<a name="ln749">	SK_IF_LOCK_ASSERT(sc_if);</a>
<a name="ln750"> </a>
<a name="ln751">	mode = SK_XM_READ_4(sc_if, XM_MODE);</a>
<a name="ln752">	mode &amp;= ~(XM_MODE_RX_PROMISC | XM_MODE_RX_USE_HASH |</a>
<a name="ln753">	    XM_MODE_RX_USE_PERFECT);</a>
<a name="ln754">	/* First, zot all the existing perfect filters. */</a>
<a name="ln755">	for (i = 1; i &lt; XM_RXFILT_MAX; i++)</a>
<a name="ln756">		sk_setfilt(sc_if, dummy, i);</a>
<a name="ln757"> </a>
<a name="ln758">	/* Now program new ones. */</a>
<a name="ln759">	if (ifp-&gt;if_flags &amp; IFF_ALLMULTI || ifp-&gt;if_flags &amp; IFF_PROMISC) {</a>
<a name="ln760">		if (ifp-&gt;if_flags &amp; IFF_ALLMULTI)</a>
<a name="ln761">			mode |= XM_MODE_RX_USE_HASH;</a>
<a name="ln762">		if (ifp-&gt;if_flags &amp; IFF_PROMISC)</a>
<a name="ln763">			mode |= XM_MODE_RX_PROMISC;</a>
<a name="ln764">		hashes[0] = 0xFFFFFFFF;</a>
<a name="ln765">		hashes[1] = 0xFFFFFFFF;</a>
<a name="ln766">	} else {</a>
<a name="ln767">		i = 1;</a>
<a name="ln768">		if_maddr_rlock(ifp);</a>
<a name="ln769">		TAILQ_FOREACH_REVERSE(ifma, &amp;ifp-&gt;if_multiaddrs, ifmultihead,</a>
<a name="ln770">		    ifma_link) {</a>
<a name="ln771">			if (ifma-&gt;ifma_addr-&gt;sa_family != AF_LINK)</a>
<a name="ln772">				continue;</a>
<a name="ln773">			/*</a>
<a name="ln774">			 * Program the first XM_RXFILT_MAX multicast groups</a>
<a name="ln775">			 * into the perfect filter.</a>
<a name="ln776">			 */</a>
<a name="ln777">			bcopy(LLADDR((struct sockaddr_dl *)ifma-&gt;ifma_addr),</a>
<a name="ln778">			    maddr, ETHER_ADDR_LEN);</a>
<a name="ln779">			if (i &lt; XM_RXFILT_MAX) {</a>
<a name="ln780">				sk_setfilt(sc_if, maddr, i);</a>
<a name="ln781">				mode |= XM_MODE_RX_USE_PERFECT;</a>
<a name="ln782">				i++;</a>
<a name="ln783">				continue;</a>
<a name="ln784">			}</a>
<a name="ln785">			h = sk_xmchash((const uint8_t *)maddr);</a>
<a name="ln786">			if (h &lt; 32)</a>
<a name="ln787">				hashes[0] |= (1 &lt;&lt; h);</a>
<a name="ln788">			else</a>
<a name="ln789">				hashes[1] |= (1 &lt;&lt; (h - 32));</a>
<a name="ln790">			mode |= XM_MODE_RX_USE_HASH;</a>
<a name="ln791">		}</a>
<a name="ln792">		if_maddr_runlock(ifp);</a>
<a name="ln793">	}</a>
<a name="ln794"> </a>
<a name="ln795">	SK_XM_WRITE_4(sc_if, XM_MODE, mode);</a>
<a name="ln796">	SK_XM_WRITE_4(sc_if, XM_MAR0, hashes[0]);</a>
<a name="ln797">	SK_XM_WRITE_4(sc_if, XM_MAR2, hashes[1]);</a>
<a name="ln798">}</a>
<a name="ln799"> </a>
<a name="ln800">static void</a>
<a name="ln801">sk_rxfilter_yukon(sc_if)</a>
<a name="ln802">	struct sk_if_softc	*sc_if;</a>
<a name="ln803">{</a>
<a name="ln804">	struct ifnet		*ifp;</a>
<a name="ln805">	u_int32_t		crc, hashes[2] = { 0, 0 }, mode;</a>
<a name="ln806">	struct ifmultiaddr	*ifma;</a>
<a name="ln807"> </a>
<a name="ln808">	SK_IF_LOCK_ASSERT(sc_if);</a>
<a name="ln809"> </a>
<a name="ln810">	ifp = sc_if-&gt;sk_ifp;</a>
<a name="ln811">	mode = SK_YU_READ_2(sc_if, YUKON_RCR);</a>
<a name="ln812">	if (ifp-&gt;if_flags &amp; IFF_PROMISC)</a>
<a name="ln813">		mode &amp;= ~(YU_RCR_UFLEN | YU_RCR_MUFLEN); </a>
<a name="ln814">	else if (ifp-&gt;if_flags &amp; IFF_ALLMULTI) {</a>
<a name="ln815">		mode |= YU_RCR_UFLEN | YU_RCR_MUFLEN; </a>
<a name="ln816">		hashes[0] = 0xFFFFFFFF;</a>
<a name="ln817">		hashes[1] = 0xFFFFFFFF;</a>
<a name="ln818">	} else {</a>
<a name="ln819">		mode |= YU_RCR_UFLEN;</a>
<a name="ln820">		if_maddr_rlock(ifp);</a>
<a name="ln821">		TAILQ_FOREACH(ifma, &amp;ifp-&gt;if_multiaddrs, ifma_link) {</a>
<a name="ln822">			if (ifma-&gt;ifma_addr-&gt;sa_family != AF_LINK)</a>
<a name="ln823">				continue;</a>
<a name="ln824">			crc = ether_crc32_be(LLADDR((struct sockaddr_dl *)</a>
<a name="ln825">			    ifma-&gt;ifma_addr), ETHER_ADDR_LEN);</a>
<a name="ln826">			/* Just want the 6 least significant bits. */</a>
<a name="ln827">			crc &amp;= 0x3f;</a>
<a name="ln828">			/* Set the corresponding bit in the hash table. */</a>
<a name="ln829">			hashes[crc &gt;&gt; 5] |= 1 &lt;&lt; (crc &amp; 0x1f);</a>
<a name="ln830">		}</a>
<a name="ln831">		if_maddr_runlock(ifp);</a>
<a name="ln832">		if (hashes[0] != 0 || hashes[1] != 0)</a>
<a name="ln833">			mode |= YU_RCR_MUFLEN;</a>
<a name="ln834">	}</a>
<a name="ln835"> </a>
<a name="ln836">	SK_YU_WRITE_2(sc_if, YUKON_MCAH1, hashes[0] &amp; 0xffff);</a>
<a name="ln837">	SK_YU_WRITE_2(sc_if, YUKON_MCAH2, (hashes[0] &gt;&gt; 16) &amp; 0xffff);</a>
<a name="ln838">	SK_YU_WRITE_2(sc_if, YUKON_MCAH3, hashes[1] &amp; 0xffff);</a>
<a name="ln839">	SK_YU_WRITE_2(sc_if, YUKON_MCAH4, (hashes[1] &gt;&gt; 16) &amp; 0xffff);</a>
<a name="ln840">	SK_YU_WRITE_2(sc_if, YUKON_RCR, mode);</a>
<a name="ln841">}</a>
<a name="ln842"> </a>
<a name="ln843">static int</a>
<a name="ln844">sk_init_rx_ring(sc_if)</a>
<a name="ln845">	struct sk_if_softc	*sc_if;</a>
<a name="ln846">{</a>
<a name="ln847">	struct sk_ring_data	*rd;</a>
<a name="ln848">	bus_addr_t		addr;</a>
<a name="ln849">	u_int32_t		csum_start;</a>
<a name="ln850">	int			i;</a>
<a name="ln851"> </a>
<a name="ln852">	sc_if-&gt;sk_cdata.sk_rx_cons = 0;</a>
<a name="ln853"> </a>
<a name="ln854">	csum_start = (ETHER_HDR_LEN + sizeof(struct ip))  &lt;&lt; 16 |</a>
<a name="ln855">	    ETHER_HDR_LEN;</a>
<a name="ln856">	rd = &amp;sc_if-&gt;sk_rdata;</a>
<a name="ln857">	bzero(rd-&gt;sk_rx_ring, sizeof(struct sk_rx_desc) * SK_RX_RING_CNT);</a>
<a name="ln858">	for (i = 0; i &lt; SK_RX_RING_CNT; i++) {</a>
<a name="ln859">		if (sk_newbuf(sc_if, i) != 0)</a>
<a name="ln860">			return (ENOBUFS);</a>
<a name="ln861">		if (i == (SK_RX_RING_CNT - 1))</a>
<a name="ln862">			addr = SK_RX_RING_ADDR(sc_if, 0);</a>
<a name="ln863">		else</a>
<a name="ln864">			addr = SK_RX_RING_ADDR(sc_if, i + 1);</a>
<a name="ln865">		rd-&gt;sk_rx_ring[i].sk_next = htole32(SK_ADDR_LO(addr));</a>
<a name="ln866">		rd-&gt;sk_rx_ring[i].sk_csum_start = htole32(csum_start);</a>
<a name="ln867">	}</a>
<a name="ln868"> </a>
<a name="ln869">	bus_dmamap_sync(sc_if-&gt;sk_cdata.sk_rx_ring_tag,</a>
<a name="ln870">	    sc_if-&gt;sk_cdata.sk_rx_ring_map,</a>
<a name="ln871">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln872"> </a>
<a name="ln873">	return(0);</a>
<a name="ln874">}</a>
<a name="ln875"> </a>
<a name="ln876">static int</a>
<a name="ln877">sk_init_jumbo_rx_ring(sc_if)</a>
<a name="ln878">	struct sk_if_softc	*sc_if;</a>
<a name="ln879">{</a>
<a name="ln880">	struct sk_ring_data	*rd;</a>
<a name="ln881">	bus_addr_t		addr;</a>
<a name="ln882">	u_int32_t		csum_start;</a>
<a name="ln883">	int			i;</a>
<a name="ln884"> </a>
<a name="ln885">	sc_if-&gt;sk_cdata.sk_jumbo_rx_cons = 0;</a>
<a name="ln886"> </a>
<a name="ln887">	csum_start = ((ETHER_HDR_LEN + sizeof(struct ip)) &lt;&lt; 16) |</a>
<a name="ln888">	    ETHER_HDR_LEN;</a>
<a name="ln889">	rd = &amp;sc_if-&gt;sk_rdata;</a>
<a name="ln890">	bzero(rd-&gt;sk_jumbo_rx_ring,</a>
<a name="ln891">	    sizeof(struct sk_rx_desc) * SK_JUMBO_RX_RING_CNT);</a>
<a name="ln892">	for (i = 0; i &lt; SK_JUMBO_RX_RING_CNT; i++) {</a>
<a name="ln893">		if (sk_jumbo_newbuf(sc_if, i) != 0)</a>
<a name="ln894">			return (ENOBUFS);</a>
<a name="ln895">		if (i == (SK_JUMBO_RX_RING_CNT - 1))</a>
<a name="ln896">			addr = SK_JUMBO_RX_RING_ADDR(sc_if, 0);</a>
<a name="ln897">		else</a>
<a name="ln898">			addr = SK_JUMBO_RX_RING_ADDR(sc_if, i + 1);</a>
<a name="ln899">		rd-&gt;sk_jumbo_rx_ring[i].sk_next = htole32(SK_ADDR_LO(addr));</a>
<a name="ln900">		rd-&gt;sk_jumbo_rx_ring[i].sk_csum_start = htole32(csum_start);</a>
<a name="ln901">	}</a>
<a name="ln902"> </a>
<a name="ln903">	bus_dmamap_sync(sc_if-&gt;sk_cdata.sk_jumbo_rx_ring_tag,</a>
<a name="ln904">	    sc_if-&gt;sk_cdata.sk_jumbo_rx_ring_map,</a>
<a name="ln905">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln906"> </a>
<a name="ln907">	return (0);</a>
<a name="ln908">}</a>
<a name="ln909"> </a>
<a name="ln910">static void</a>
<a name="ln911">sk_init_tx_ring(sc_if)</a>
<a name="ln912">	struct sk_if_softc	*sc_if;</a>
<a name="ln913">{</a>
<a name="ln914">	struct sk_ring_data	*rd;</a>
<a name="ln915">	struct sk_txdesc	*txd;</a>
<a name="ln916">	bus_addr_t		addr;</a>
<a name="ln917">	int			i;</a>
<a name="ln918"> </a>
<a name="ln919">	STAILQ_INIT(&amp;sc_if-&gt;sk_cdata.sk_txfreeq);</a>
<a name="ln920">	STAILQ_INIT(&amp;sc_if-&gt;sk_cdata.sk_txbusyq);</a>
<a name="ln921"> </a>
<a name="ln922">	sc_if-&gt;sk_cdata.sk_tx_prod = 0;</a>
<a name="ln923">	sc_if-&gt;sk_cdata.sk_tx_cons = 0;</a>
<a name="ln924">	sc_if-&gt;sk_cdata.sk_tx_cnt = 0;</a>
<a name="ln925"> </a>
<a name="ln926">	rd = &amp;sc_if-&gt;sk_rdata;</a>
<a name="ln927">	bzero(rd-&gt;sk_tx_ring, sizeof(struct sk_tx_desc) * SK_TX_RING_CNT);</a>
<a name="ln928">	for (i = 0; i &lt; SK_TX_RING_CNT; i++) {</a>
<a name="ln929">		if (i == (SK_TX_RING_CNT - 1))</a>
<a name="ln930">			addr = SK_TX_RING_ADDR(sc_if, 0);</a>
<a name="ln931">		else</a>
<a name="ln932">			addr = SK_TX_RING_ADDR(sc_if, i + 1);</a>
<a name="ln933">		rd-&gt;sk_tx_ring[i].sk_next = htole32(SK_ADDR_LO(addr));</a>
<a name="ln934">		txd = &amp;sc_if-&gt;sk_cdata.sk_txdesc[i];</a>
<a name="ln935">		STAILQ_INSERT_TAIL(&amp;sc_if-&gt;sk_cdata.sk_txfreeq, txd, tx_q);</a>
<a name="ln936">	}</a>
<a name="ln937"> </a>
<a name="ln938">	bus_dmamap_sync(sc_if-&gt;sk_cdata.sk_tx_ring_tag,</a>
<a name="ln939">	    sc_if-&gt;sk_cdata.sk_tx_ring_map,</a>
<a name="ln940">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln941">}</a>
<a name="ln942"> </a>
<a name="ln943">static __inline void</a>
<a name="ln944">sk_discard_rxbuf(sc_if, idx)</a>
<a name="ln945">	struct sk_if_softc	*sc_if;</a>
<a name="ln946">	int			idx;</a>
<a name="ln947">{</a>
<a name="ln948">	struct sk_rx_desc	*r;</a>
<a name="ln949">	struct sk_rxdesc	*rxd;</a>
<a name="ln950">	struct mbuf		*m;</a>
<a name="ln951"> </a>
<a name="ln952"> </a>
<a name="ln953">	r = &amp;sc_if-&gt;sk_rdata.sk_rx_ring[idx];</a>
<a name="ln954">	rxd = &amp;sc_if-&gt;sk_cdata.sk_rxdesc[idx];</a>
<a name="ln955">	m = rxd-&gt;rx_m;</a>
<a name="ln956">	r-&gt;sk_ctl = htole32(m-&gt;m_len | SK_RXSTAT | SK_OPCODE_CSUM);</a>
<a name="ln957">}</a>
<a name="ln958"> </a>
<a name="ln959">static __inline void</a>
<a name="ln960">sk_discard_jumbo_rxbuf(sc_if, idx)</a>
<a name="ln961">	struct sk_if_softc	*sc_if;</a>
<a name="ln962">	int			idx;</a>
<a name="ln963">{</a>
<a name="ln964">	struct sk_rx_desc	*r;</a>
<a name="ln965">	struct sk_rxdesc	*rxd;</a>
<a name="ln966">	struct mbuf		*m;</a>
<a name="ln967"> </a>
<a name="ln968">	r = &amp;sc_if-&gt;sk_rdata.sk_jumbo_rx_ring[idx];</a>
<a name="ln969">	rxd = &amp;sc_if-&gt;sk_cdata.sk_jumbo_rxdesc[idx];</a>
<a name="ln970">	m = rxd-&gt;rx_m;</a>
<a name="ln971">	r-&gt;sk_ctl = htole32(m-&gt;m_len | SK_RXSTAT | SK_OPCODE_CSUM);</a>
<a name="ln972">}</a>
<a name="ln973"> </a>
<a name="ln974">static int</a>
<a name="ln975">sk_newbuf(sc_if, idx)</a>
<a name="ln976">	struct sk_if_softc	*sc_if;</a>
<a name="ln977">	int 			idx;</a>
<a name="ln978">{</a>
<a name="ln979">	struct sk_rx_desc	*r;</a>
<a name="ln980">	struct sk_rxdesc	*rxd;</a>
<a name="ln981">	struct mbuf		*m;</a>
<a name="ln982">	bus_dma_segment_t	segs[1];</a>
<a name="ln983">	bus_dmamap_t		map;</a>
<a name="ln984">	int			nsegs;</a>
<a name="ln985"> </a>
<a name="ln986">	m = m_getcl(M_NOWAIT, MT_DATA, M_PKTHDR);</a>
<a name="ln987">	if (m == NULL)</a>
<a name="ln988">		return (ENOBUFS);</a>
<a name="ln989">	m-&gt;m_len = m-&gt;m_pkthdr.len = MCLBYTES;</a>
<a name="ln990">	m_adj(m, ETHER_ALIGN);</a>
<a name="ln991"> </a>
<a name="ln992">	if (bus_dmamap_load_mbuf_sg(sc_if-&gt;sk_cdata.sk_rx_tag,</a>
<a name="ln993">	    sc_if-&gt;sk_cdata.sk_rx_sparemap, m, segs, &amp;nsegs, 0) != 0) {</a>
<a name="ln994">		m_freem(m);</a>
<a name="ln995">		return (ENOBUFS);</a>
<a name="ln996">	}</a>
<a name="ln997">	KASSERT(nsegs == 1, (&quot;%s: %d segments returned!&quot;, __func__, nsegs));</a>
<a name="ln998"> </a>
<a name="ln999">	rxd = &amp;sc_if-&gt;sk_cdata.sk_rxdesc[idx];</a>
<a name="ln1000">	if (rxd-&gt;rx_m != NULL) {</a>
<a name="ln1001">		bus_dmamap_sync(sc_if-&gt;sk_cdata.sk_rx_tag, rxd-&gt;rx_dmamap,</a>
<a name="ln1002">		    BUS_DMASYNC_POSTREAD);</a>
<a name="ln1003">		bus_dmamap_unload(sc_if-&gt;sk_cdata.sk_rx_tag, rxd-&gt;rx_dmamap);</a>
<a name="ln1004">	}</a>
<a name="ln1005">	map = rxd-&gt;rx_dmamap;</a>
<a name="ln1006">	rxd-&gt;rx_dmamap = sc_if-&gt;sk_cdata.sk_rx_sparemap;</a>
<a name="ln1007">	sc_if-&gt;sk_cdata.sk_rx_sparemap = map;</a>
<a name="ln1008">	bus_dmamap_sync(sc_if-&gt;sk_cdata.sk_rx_tag, rxd-&gt;rx_dmamap,</a>
<a name="ln1009">	    BUS_DMASYNC_PREREAD);</a>
<a name="ln1010">	rxd-&gt;rx_m = m;</a>
<a name="ln1011">	r = &amp;sc_if-&gt;sk_rdata.sk_rx_ring[idx];</a>
<a name="ln1012">	r-&gt;sk_data_lo = htole32(SK_ADDR_LO(segs[0].ds_addr));</a>
<a name="ln1013">	r-&gt;sk_data_hi = htole32(SK_ADDR_HI(segs[0].ds_addr));</a>
<a name="ln1014">	r-&gt;sk_ctl = htole32(segs[0].ds_len | SK_RXSTAT | SK_OPCODE_CSUM);</a>
<a name="ln1015"> </a>
<a name="ln1016">	return (0);</a>
<a name="ln1017">}</a>
<a name="ln1018"> </a>
<a name="ln1019">static int</a>
<a name="ln1020">sk_jumbo_newbuf(sc_if, idx)</a>
<a name="ln1021">	struct sk_if_softc	*sc_if;</a>
<a name="ln1022">	int			idx;</a>
<a name="ln1023">{</a>
<a name="ln1024">	struct sk_rx_desc	*r;</a>
<a name="ln1025">	struct sk_rxdesc	*rxd;</a>
<a name="ln1026">	struct mbuf		*m;</a>
<a name="ln1027">	bus_dma_segment_t	segs[1];</a>
<a name="ln1028">	bus_dmamap_t		map;</a>
<a name="ln1029">	int			nsegs;</a>
<a name="ln1030"> </a>
<a name="ln1031">	m = m_getjcl(M_NOWAIT, MT_DATA, M_PKTHDR, MJUM9BYTES);</a>
<a name="ln1032">	if (m == NULL)</a>
<a name="ln1033">		return (ENOBUFS);</a>
<a name="ln1034">	m-&gt;m_pkthdr.len = m-&gt;m_len = MJUM9BYTES;</a>
<a name="ln1035">	/*</a>
<a name="ln1036">	 * Adjust alignment so packet payload begins on a</a>
<a name="ln1037">	 * longword boundary. Mandatory for Alpha, useful on</a>
<a name="ln1038">	 * x86 too.</a>
<a name="ln1039">	 */</a>
<a name="ln1040">	m_adj(m, ETHER_ALIGN);</a>
<a name="ln1041"> </a>
<a name="ln1042">	if (bus_dmamap_load_mbuf_sg(sc_if-&gt;sk_cdata.sk_jumbo_rx_tag,</a>
<a name="ln1043">	    sc_if-&gt;sk_cdata.sk_jumbo_rx_sparemap, m, segs, &amp;nsegs, 0) != 0) {</a>
<a name="ln1044">		m_freem(m);</a>
<a name="ln1045">		return (ENOBUFS);</a>
<a name="ln1046">	}</a>
<a name="ln1047">	KASSERT(nsegs == 1, (&quot;%s: %d segments returned!&quot;, __func__, nsegs));</a>
<a name="ln1048"> </a>
<a name="ln1049">	rxd = &amp;sc_if-&gt;sk_cdata.sk_jumbo_rxdesc[idx];</a>
<a name="ln1050">	if (rxd-&gt;rx_m != NULL) {</a>
<a name="ln1051">		bus_dmamap_sync(sc_if-&gt;sk_cdata.sk_jumbo_rx_tag, rxd-&gt;rx_dmamap,</a>
<a name="ln1052">		    BUS_DMASYNC_POSTREAD);</a>
<a name="ln1053">		bus_dmamap_unload(sc_if-&gt;sk_cdata.sk_jumbo_rx_tag,</a>
<a name="ln1054">		    rxd-&gt;rx_dmamap);</a>
<a name="ln1055">	}</a>
<a name="ln1056">	map = rxd-&gt;rx_dmamap;</a>
<a name="ln1057">	rxd-&gt;rx_dmamap = sc_if-&gt;sk_cdata.sk_jumbo_rx_sparemap;</a>
<a name="ln1058">	sc_if-&gt;sk_cdata.sk_jumbo_rx_sparemap = map;</a>
<a name="ln1059">	bus_dmamap_sync(sc_if-&gt;sk_cdata.sk_jumbo_rx_tag, rxd-&gt;rx_dmamap,</a>
<a name="ln1060">	    BUS_DMASYNC_PREREAD);</a>
<a name="ln1061">	rxd-&gt;rx_m = m;</a>
<a name="ln1062">	r = &amp;sc_if-&gt;sk_rdata.sk_jumbo_rx_ring[idx];</a>
<a name="ln1063">	r-&gt;sk_data_lo = htole32(SK_ADDR_LO(segs[0].ds_addr));</a>
<a name="ln1064">	r-&gt;sk_data_hi = htole32(SK_ADDR_HI(segs[0].ds_addr));</a>
<a name="ln1065">	r-&gt;sk_ctl = htole32(segs[0].ds_len | SK_RXSTAT | SK_OPCODE_CSUM);</a>
<a name="ln1066"> </a>
<a name="ln1067">	return (0);</a>
<a name="ln1068">}</a>
<a name="ln1069"> </a>
<a name="ln1070">/*</a>
<a name="ln1071"> * Set media options.</a>
<a name="ln1072"> */</a>
<a name="ln1073">static int</a>
<a name="ln1074">sk_ifmedia_upd(ifp)</a>
<a name="ln1075">	struct ifnet		*ifp;</a>
<a name="ln1076">{</a>
<a name="ln1077">	struct sk_if_softc	*sc_if = ifp-&gt;if_softc;</a>
<a name="ln1078">	struct mii_data		*mii;</a>
<a name="ln1079"> </a>
<a name="ln1080">	mii = device_get_softc(sc_if-&gt;sk_miibus);</a>
<a name="ln1081">	sk_init(sc_if);</a>
<a name="ln1082">	mii_mediachg(mii);</a>
<a name="ln1083"> </a>
<a name="ln1084">	return(0);</a>
<a name="ln1085">}</a>
<a name="ln1086"> </a>
<a name="ln1087">/*</a>
<a name="ln1088"> * Report current media status.</a>
<a name="ln1089"> */</a>
<a name="ln1090">static void</a>
<a name="ln1091">sk_ifmedia_sts(ifp, ifmr)</a>
<a name="ln1092">	struct ifnet		*ifp;</a>
<a name="ln1093">	struct ifmediareq	*ifmr;</a>
<a name="ln1094">{</a>
<a name="ln1095">	struct sk_if_softc	*sc_if;</a>
<a name="ln1096">	struct mii_data		*mii;</a>
<a name="ln1097"> </a>
<a name="ln1098">	sc_if = ifp-&gt;if_softc;</a>
<a name="ln1099">	mii = device_get_softc(sc_if-&gt;sk_miibus);</a>
<a name="ln1100"> </a>
<a name="ln1101">	mii_pollstat(mii);</a>
<a name="ln1102">	ifmr-&gt;ifm_active = mii-&gt;mii_media_active;</a>
<a name="ln1103">	ifmr-&gt;ifm_status = mii-&gt;mii_media_status;</a>
<a name="ln1104"> </a>
<a name="ln1105">	return;</a>
<a name="ln1106">}</a>
<a name="ln1107"> </a>
<a name="ln1108">static int</a>
<a name="ln1109">sk_ioctl(ifp, command, data)</a>
<a name="ln1110">	struct ifnet		*ifp;</a>
<a name="ln1111">	u_long			command;</a>
<a name="ln1112">	caddr_t			data;</a>
<a name="ln1113">{</a>
<a name="ln1114">	struct sk_if_softc	*sc_if = ifp-&gt;if_softc;</a>
<a name="ln1115">	struct ifreq		*ifr = (struct ifreq *) data;</a>
<a name="ln1116">	int			error, mask;</a>
<a name="ln1117">	struct mii_data		*mii;</a>
<a name="ln1118"> </a>
<a name="ln1119">	error = 0;</a>
<a name="ln1120">	switch(command) {</a>
<a name="ln1121">	case SIOCSIFMTU:</a>
<a name="ln1122">		if (ifr-&gt;ifr_mtu &lt; ETHERMIN || ifr-&gt;ifr_mtu &gt; SK_JUMBO_MTU)</a>
<a name="ln1123">			error = EINVAL;</a>
<a name="ln1124">		else if (ifp-&gt;if_mtu != ifr-&gt;ifr_mtu) {</a>
<a name="ln1125">			if (sc_if-&gt;sk_jumbo_disable != 0 &amp;&amp;</a>
<a name="ln1126">			    ifr-&gt;ifr_mtu &gt; SK_MAX_FRAMELEN)</a>
<a name="ln1127">				error = EINVAL;</a>
<a name="ln1128">			else {</a>
<a name="ln1129">				SK_IF_LOCK(sc_if);</a>
<a name="ln1130">				ifp-&gt;if_mtu = ifr-&gt;ifr_mtu;</a>
<a name="ln1131">				if (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) {</a>
<a name="ln1132">					ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_RUNNING;</a>
<a name="ln1133">					sk_init_locked(sc_if);</a>
<a name="ln1134">				}</a>
<a name="ln1135">				SK_IF_UNLOCK(sc_if);</a>
<a name="ln1136">			}</a>
<a name="ln1137">		}</a>
<a name="ln1138">		break;</a>
<a name="ln1139">	case SIOCSIFFLAGS:</a>
<a name="ln1140">		SK_IF_LOCK(sc_if);</a>
<a name="ln1141">		if (ifp-&gt;if_flags &amp; IFF_UP) {</a>
<a name="ln1142">			if (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) {</a>
<a name="ln1143">				if ((ifp-&gt;if_flags ^ sc_if-&gt;sk_if_flags)</a>
<a name="ln1144">				    &amp; (IFF_PROMISC | IFF_ALLMULTI))</a>
<a name="ln1145">					sk_rxfilter(sc_if);</a>
<a name="ln1146">			} else</a>
<a name="ln1147">				sk_init_locked(sc_if);</a>
<a name="ln1148">		} else {</a>
<a name="ln1149">			if (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING)</a>
<a name="ln1150">				sk_stop(sc_if);</a>
<a name="ln1151">		}</a>
<a name="ln1152">		sc_if-&gt;sk_if_flags = ifp-&gt;if_flags;</a>
<a name="ln1153">		SK_IF_UNLOCK(sc_if);</a>
<a name="ln1154">		break;</a>
<a name="ln1155">	case SIOCADDMULTI:</a>
<a name="ln1156">	case SIOCDELMULTI:</a>
<a name="ln1157">		SK_IF_LOCK(sc_if);</a>
<a name="ln1158">		if (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING)</a>
<a name="ln1159">			sk_rxfilter(sc_if);</a>
<a name="ln1160">		SK_IF_UNLOCK(sc_if);</a>
<a name="ln1161">		break;</a>
<a name="ln1162">	case SIOCGIFMEDIA:</a>
<a name="ln1163">	case SIOCSIFMEDIA:</a>
<a name="ln1164">		mii = device_get_softc(sc_if-&gt;sk_miibus);</a>
<a name="ln1165">		error = ifmedia_ioctl(ifp, ifr, &amp;mii-&gt;mii_media, command);</a>
<a name="ln1166">		break;</a>
<a name="ln1167">	case SIOCSIFCAP:</a>
<a name="ln1168">		SK_IF_LOCK(sc_if);</a>
<a name="ln1169">		if (sc_if-&gt;sk_softc-&gt;sk_type == SK_GENESIS) {</a>
<a name="ln1170">			SK_IF_UNLOCK(sc_if);</a>
<a name="ln1171">			break;</a>
<a name="ln1172">		}</a>
<a name="ln1173">		mask = ifr-&gt;ifr_reqcap ^ ifp-&gt;if_capenable;</a>
<a name="ln1174">		if ((mask &amp; IFCAP_TXCSUM) != 0 &amp;&amp;</a>
<a name="ln1175">		    (IFCAP_TXCSUM &amp; ifp-&gt;if_capabilities) != 0) {</a>
<a name="ln1176">			ifp-&gt;if_capenable ^= IFCAP_TXCSUM;</a>
<a name="ln1177">			if ((ifp-&gt;if_capenable &amp; IFCAP_TXCSUM) != 0)</a>
<a name="ln1178">				ifp-&gt;if_hwassist |= SK_CSUM_FEATURES;</a>
<a name="ln1179">			else</a>
<a name="ln1180">				ifp-&gt;if_hwassist &amp;= ~SK_CSUM_FEATURES;</a>
<a name="ln1181">		}</a>
<a name="ln1182">		if ((mask &amp; IFCAP_RXCSUM) != 0 &amp;&amp;</a>
<a name="ln1183">		    (IFCAP_RXCSUM &amp; ifp-&gt;if_capabilities) != 0) </a>
<a name="ln1184">			ifp-&gt;if_capenable ^= IFCAP_RXCSUM;</a>
<a name="ln1185">		SK_IF_UNLOCK(sc_if);</a>
<a name="ln1186">		break;</a>
<a name="ln1187">	default:</a>
<a name="ln1188">		error = ether_ioctl(ifp, command, data);</a>
<a name="ln1189">		break;</a>
<a name="ln1190">	}</a>
<a name="ln1191"> </a>
<a name="ln1192">	return (error);</a>
<a name="ln1193">}</a>
<a name="ln1194"> </a>
<a name="ln1195">/*</a>
<a name="ln1196"> * Probe for a SysKonnect GEnesis chip. Check the PCI vendor and device</a>
<a name="ln1197"> * IDs against our list and return a device name if we find a match.</a>
<a name="ln1198"> */</a>
<a name="ln1199">static int</a>
<a name="ln1200">skc_probe(dev)</a>
<a name="ln1201">	device_t		dev;</a>
<a name="ln1202">{</a>
<a name="ln1203">	const struct sk_type	*t = sk_devs;</a>
<a name="ln1204"> </a>
<a name="ln1205">	while(t-&gt;sk_name != NULL) {</a>
<a name="ln1206">		if ((pci_get_vendor(dev) == t-&gt;sk_vid) &amp;&amp;</a>
<a name="ln1207">		    (pci_get_device(dev) == t-&gt;sk_did)) {</a>
<a name="ln1208">			/*</a>
<a name="ln1209">			 * Only attach to rev. 2 of the Linksys EG1032 adapter.</a>
<a name="ln1210">			 * Rev. 3 is supported by re(4).</a>
<a name="ln1211">			 */</a>
<a name="ln1212">			if ((t-&gt;sk_vid == VENDORID_LINKSYS) &amp;&amp;</a>
<a name="ln1213">				(t-&gt;sk_did == DEVICEID_LINKSYS_EG1032) &amp;&amp;</a>
<a name="ln1214">				(pci_get_subdevice(dev) !=</a>
<a name="ln1215">				 SUBDEVICEID_LINKSYS_EG1032_REV2)) {</a>
<a name="ln1216">				t++;</a>
<a name="ln1217">				continue;</a>
<a name="ln1218">			}</a>
<a name="ln1219">			device_set_desc(dev, t-&gt;sk_name);</a>
<a name="ln1220">			return (BUS_PROBE_DEFAULT);</a>
<a name="ln1221">		}</a>
<a name="ln1222">		t++;</a>
<a name="ln1223">	}</a>
<a name="ln1224"> </a>
<a name="ln1225">	return(ENXIO);</a>
<a name="ln1226">}</a>
<a name="ln1227"> </a>
<a name="ln1228">/*</a>
<a name="ln1229"> * Force the GEnesis into reset, then bring it out of reset.</a>
<a name="ln1230"> */</a>
<a name="ln1231">static void</a>
<a name="ln1232">sk_reset(sc)</a>
<a name="ln1233">	struct sk_softc		*sc;</a>
<a name="ln1234">{</a>
<a name="ln1235"> </a>
<a name="ln1236">	CSR_WRITE_2(sc, SK_CSR, SK_CSR_SW_RESET);</a>
<a name="ln1237">	CSR_WRITE_2(sc, SK_CSR, SK_CSR_MASTER_RESET);</a>
<a name="ln1238">	if (SK_YUKON_FAMILY(sc-&gt;sk_type))</a>
<a name="ln1239">		CSR_WRITE_2(sc, SK_LINK_CTRL, SK_LINK_RESET_SET);</a>
<a name="ln1240"> </a>
<a name="ln1241">	DELAY(1000);</a>
<a name="ln1242">	CSR_WRITE_2(sc, SK_CSR, SK_CSR_SW_UNRESET);</a>
<a name="ln1243">	DELAY(2);</a>
<a name="ln1244">	CSR_WRITE_2(sc, SK_CSR, SK_CSR_MASTER_UNRESET);</a>
<a name="ln1245">	if (SK_YUKON_FAMILY(sc-&gt;sk_type))</a>
<a name="ln1246">		CSR_WRITE_2(sc, SK_LINK_CTRL, SK_LINK_RESET_CLEAR);</a>
<a name="ln1247"> </a>
<a name="ln1248">	if (sc-&gt;sk_type == SK_GENESIS) {</a>
<a name="ln1249">		/* Configure packet arbiter */</a>
<a name="ln1250">		sk_win_write_2(sc, SK_PKTARB_CTL, SK_PKTARBCTL_UNRESET);</a>
<a name="ln1251">		sk_win_write_2(sc, SK_RXPA1_TINIT, SK_PKTARB_TIMEOUT);</a>
<a name="ln1252">		sk_win_write_2(sc, SK_TXPA1_TINIT, SK_PKTARB_TIMEOUT);</a>
<a name="ln1253">		sk_win_write_2(sc, SK_RXPA2_TINIT, SK_PKTARB_TIMEOUT);</a>
<a name="ln1254">		sk_win_write_2(sc, SK_TXPA2_TINIT, SK_PKTARB_TIMEOUT);</a>
<a name="ln1255">	}</a>
<a name="ln1256"> </a>
<a name="ln1257">	/* Enable RAM interface */</a>
<a name="ln1258">	sk_win_write_4(sc, SK_RAMCTL, SK_RAMCTL_UNRESET);</a>
<a name="ln1259"> </a>
<a name="ln1260">	/*</a>
<a name="ln1261">         * Configure interrupt moderation. The moderation timer</a>
<a name="ln1262">	 * defers interrupts specified in the interrupt moderation</a>
<a name="ln1263">	 * timer mask based on the timeout specified in the interrupt</a>
<a name="ln1264">	 * moderation timer init register. Each bit in the timer</a>
<a name="ln1265">	 * register represents one tick, so to specify a timeout in</a>
<a name="ln1266">	 * microseconds, we have to multiply by the correct number of</a>
<a name="ln1267">	 * ticks-per-microsecond.</a>
<a name="ln1268">	 */</a>
<a name="ln1269">	switch (sc-&gt;sk_type) {</a>
<a name="ln1270">	case SK_GENESIS:</a>
<a name="ln1271">		sc-&gt;sk_int_ticks = SK_IMTIMER_TICKS_GENESIS;</a>
<a name="ln1272">		break;</a>
<a name="ln1273">	default:</a>
<a name="ln1274">		sc-&gt;sk_int_ticks = SK_IMTIMER_TICKS_YUKON;</a>
<a name="ln1275">		break;</a>
<a name="ln1276">	}</a>
<a name="ln1277">	if (bootverbose)</a>
<a name="ln1278">		device_printf(sc-&gt;sk_dev, &quot;interrupt moderation is %d us\n&quot;,</a>
<a name="ln1279">		    sc-&gt;sk_int_mod);</a>
<a name="ln1280">	sk_win_write_4(sc, SK_IMTIMERINIT, SK_IM_USECS(sc-&gt;sk_int_mod,</a>
<a name="ln1281">	    sc-&gt;sk_int_ticks));</a>
<a name="ln1282">	sk_win_write_4(sc, SK_IMMR, SK_ISR_TX1_S_EOF|SK_ISR_TX2_S_EOF|</a>
<a name="ln1283">	    SK_ISR_RX1_EOF|SK_ISR_RX2_EOF);</a>
<a name="ln1284">	sk_win_write_1(sc, SK_IMTIMERCTL, SK_IMCTL_START);</a>
<a name="ln1285"> </a>
<a name="ln1286">	return;</a>
<a name="ln1287">}</a>
<a name="ln1288"> </a>
<a name="ln1289">static int</a>
<a name="ln1290">sk_probe(dev)</a>
<a name="ln1291">	device_t		dev;</a>
<a name="ln1292">{</a>
<a name="ln1293">	struct sk_softc		*sc;</a>
<a name="ln1294"> </a>
<a name="ln1295">	sc = device_get_softc(device_get_parent(dev));</a>
<a name="ln1296"> </a>
<a name="ln1297">	/*</a>
<a name="ln1298">	 * Not much to do here. We always know there will be</a>
<a name="ln1299">	 * at least one XMAC present, and if there are two,</a>
<a name="ln1300">	 * skc_attach() will create a second device instance</a>
<a name="ln1301">	 * for us.</a>
<a name="ln1302">	 */</a>
<a name="ln1303">	switch (sc-&gt;sk_type) {</a>
<a name="ln1304">	case SK_GENESIS:</a>
<a name="ln1305">		device_set_desc(dev, &quot;XaQti Corp. XMAC II&quot;);</a>
<a name="ln1306">		break;</a>
<a name="ln1307">	case SK_YUKON:</a>
<a name="ln1308">	case SK_YUKON_LITE:</a>
<a name="ln1309">	case SK_YUKON_LP:</a>
<a name="ln1310">		device_set_desc(dev, &quot;Marvell Semiconductor, Inc. Yukon&quot;);</a>
<a name="ln1311">		break;</a>
<a name="ln1312">	}</a>
<a name="ln1313"> </a>
<a name="ln1314">	return (BUS_PROBE_DEFAULT);</a>
<a name="ln1315">}</a>
<a name="ln1316"> </a>
<a name="ln1317">/*</a>
<a name="ln1318"> * Each XMAC chip is attached as a separate logical IP interface.</a>
<a name="ln1319"> * Single port cards will have only one logical interface of course.</a>
<a name="ln1320"> */</a>
<a name="ln1321">static int</a>
<a name="ln1322">sk_attach(dev)</a>
<a name="ln1323">	device_t		dev;</a>
<a name="ln1324">{</a>
<a name="ln1325">	struct sk_softc		*sc;</a>
<a name="ln1326">	struct sk_if_softc	*sc_if;</a>
<a name="ln1327">	struct ifnet		*ifp;</a>
<a name="ln1328">	u_int32_t		r;</a>
<a name="ln1329">	int			error, i, phy, port;</a>
<a name="ln1330">	u_char			eaddr[6];</a>
<a name="ln1331">	u_char			inv_mac[] = {0, 0, 0, 0, 0, 0};</a>
<a name="ln1332"> </a>
<a name="ln1333">	if (dev == NULL)</a>
<a name="ln1334">		return(EINVAL);</a>
<a name="ln1335"> </a>
<a name="ln1336">	error = 0;</a>
<a name="ln1337">	sc_if = device_get_softc(dev);</a>
<a name="ln1338">	sc = device_get_softc(device_get_parent(dev));</a>
<a name="ln1339">	port = *(int *)device_get_ivars(dev);</a>
<a name="ln1340"> </a>
<a name="ln1341">	sc_if-&gt;sk_if_dev = dev;</a>
<a name="ln1342">	sc_if-&gt;sk_port = port;</a>
<a name="ln1343">	sc_if-&gt;sk_softc = sc;</a>
<a name="ln1344">	sc-&gt;sk_if[port] = sc_if;</a>
<a name="ln1345">	if (port == SK_PORT_A)</a>
<a name="ln1346">		sc_if-&gt;sk_tx_bmu = SK_BMU_TXS_CSR0;</a>
<a name="ln1347">	if (port == SK_PORT_B)</a>
<a name="ln1348">		sc_if-&gt;sk_tx_bmu = SK_BMU_TXS_CSR1;</a>
<a name="ln1349"> </a>
<a name="ln1350">	callout_init_mtx(&amp;sc_if-&gt;sk_tick_ch, &amp;sc_if-&gt;sk_softc-&gt;sk_mtx, 0);</a>
<a name="ln1351">	callout_init_mtx(&amp;sc_if-&gt;sk_watchdog_ch, &amp;sc_if-&gt;sk_softc-&gt;sk_mtx, 0);</a>
<a name="ln1352"> </a>
<a name="ln1353">	if (sk_dma_alloc(sc_if) != 0) {</a>
<a name="ln1354">		error = ENOMEM;</a>
<a name="ln1355">		goto fail;</a>
<a name="ln1356">	}</a>
<a name="ln1357">	sk_dma_jumbo_alloc(sc_if);</a>
<a name="ln1358"> </a>
<a name="ln1359">	ifp = sc_if-&gt;sk_ifp = if_alloc(IFT_ETHER);</a>
<a name="ln1360">	if (ifp == NULL) {</a>
<a name="ln1361">		device_printf(sc_if-&gt;sk_if_dev, &quot;can not if_alloc()\n&quot;);</a>
<a name="ln1362">		error = ENOSPC;</a>
<a name="ln1363">		goto fail;</a>
<a name="ln1364">	}</a>
<a name="ln1365">	ifp-&gt;if_softc = sc_if;</a>
<a name="ln1366">	if_initname(ifp, device_get_name(dev), device_get_unit(dev));</a>
<a name="ln1367">	ifp-&gt;if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;</a>
<a name="ln1368">	/*</a>
<a name="ln1369">	 * SK_GENESIS has a bug in checksum offload - From linux.</a>
<a name="ln1370">	 */</a>
<a name="ln1371">	if (sc_if-&gt;sk_softc-&gt;sk_type != SK_GENESIS) {</a>
<a name="ln1372">		ifp-&gt;if_capabilities = IFCAP_TXCSUM | IFCAP_RXCSUM;</a>
<a name="ln1373">		ifp-&gt;if_hwassist = 0;</a>
<a name="ln1374">	} else {</a>
<a name="ln1375">		ifp-&gt;if_capabilities = 0;</a>
<a name="ln1376">		ifp-&gt;if_hwassist = 0;</a>
<a name="ln1377">	}</a>
<a name="ln1378">	ifp-&gt;if_capenable = ifp-&gt;if_capabilities;</a>
<a name="ln1379">	/*</a>
<a name="ln1380">	 * Some revision of Yukon controller generates corrupted</a>
<a name="ln1381">	 * frame when TX checksum offloading is enabled.  The</a>
<a name="ln1382">	 * frame has a valid checksum value so payload might be</a>
<a name="ln1383">	 * modified during TX checksum calculation. Disable TX</a>
<a name="ln1384">	 * checksum offloading but give users chance to enable it</a>
<a name="ln1385">	 * when they know their controller works without problems</a>
<a name="ln1386">	 * with TX checksum offloading.</a>
<a name="ln1387">	 */</a>
<a name="ln1388">	ifp-&gt;if_capenable &amp;= ~IFCAP_TXCSUM;</a>
<a name="ln1389">	ifp-&gt;if_ioctl = sk_ioctl;</a>
<a name="ln1390">	ifp-&gt;if_start = sk_start;</a>
<a name="ln1391">	ifp-&gt;if_init = sk_init;</a>
<a name="ln1392">	IFQ_SET_MAXLEN(&amp;ifp-&gt;if_snd, SK_TX_RING_CNT - 1);</a>
<a name="ln1393">	ifp-&gt;if_snd.ifq_drv_maxlen = SK_TX_RING_CNT - 1;</a>
<a name="ln1394">	IFQ_SET_READY(&amp;ifp-&gt;if_snd);</a>
<a name="ln1395"> </a>
<a name="ln1396">	/*</a>
<a name="ln1397">	 * Get station address for this interface. Note that</a>
<a name="ln1398">	 * dual port cards actually come with three station</a>
<a name="ln1399">	 * addresses: one for each port, plus an extra. The</a>
<a name="ln1400">	 * extra one is used by the SysKonnect driver software</a>
<a name="ln1401">	 * as a 'virtual' station address for when both ports</a>
<a name="ln1402">	 * are operating in failover mode. Currently we don't</a>
<a name="ln1403">	 * use this extra address.</a>
<a name="ln1404">	 */</a>
<a name="ln1405">	SK_IF_LOCK(sc_if);</a>
<a name="ln1406">	for (i = 0; i &lt; ETHER_ADDR_LEN; i++)</a>
<a name="ln1407">		eaddr[i] =</a>
<a name="ln1408">		    sk_win_read_1(sc, SK_MAC0_0 + (port * 8) + i);</a>
<a name="ln1409"> </a>
<a name="ln1410">	/* Verify whether the station address is invalid or not. */</a>
<a name="ln1411">	if (bcmp(eaddr, inv_mac, sizeof(inv_mac)) == 0) {</a>
<a name="ln1412">		device_printf(sc_if-&gt;sk_if_dev,</a>
<a name="ln1413">		    &quot;Generating random ethernet address\n&quot;);</a>
<a name="ln1414">		r = arc4random();</a>
<a name="ln1415">		/*</a>
<a name="ln1416">		 * Set OUI to convenient locally assigned address.  'b'</a>
<a name="ln1417">		 * is 0x62, which has the locally assigned bit set, and</a>
<a name="ln1418">		 * the broadcast/multicast bit clear.</a>
<a name="ln1419">		 */</a>
<a name="ln1420">		eaddr[0] = 'b';</a>
<a name="ln1421">		eaddr[1] = 's';</a>
<a name="ln1422">		eaddr[2] = 'd';</a>
<a name="ln1423">		eaddr[3] = (r &gt;&gt; 16) &amp; 0xff;</a>
<a name="ln1424">		eaddr[4] = (r &gt;&gt;  8) &amp; 0xff;</a>
<a name="ln1425">		eaddr[5] = (r &gt;&gt;  0) &amp; 0xff;</a>
<a name="ln1426">	}</a>
<a name="ln1427">	/*</a>
<a name="ln1428">	 * Set up RAM buffer addresses. The NIC will have a certain</a>
<a name="ln1429">	 * amount of SRAM on it, somewhere between 512K and 2MB. We</a>
<a name="ln1430">	 * need to divide this up a) between the transmitter and</a>
<a name="ln1431"> 	 * receiver and b) between the two XMACs, if this is a</a>
<a name="ln1432">	 * dual port NIC. Our algotithm is to divide up the memory</a>
<a name="ln1433">	 * evenly so that everyone gets a fair share.</a>
<a name="ln1434">	 *</a>
<a name="ln1435">	 * Just to be contrary, Yukon2 appears to have separate memory</a>
<a name="ln1436">	 * for each MAC.</a>
<a name="ln1437">	 */</a>
<a name="ln1438">	if (sk_win_read_1(sc, SK_CONFIG) &amp; SK_CONFIG_SINGLEMAC) {</a>
<a name="ln1439">		u_int32_t		chunk, val;</a>
<a name="ln1440"> </a>
<a name="ln1441">		chunk = sc-&gt;sk_ramsize / 2;</a>
<a name="ln1442">		val = sc-&gt;sk_rboff / sizeof(u_int64_t);</a>
<a name="ln1443">		sc_if-&gt;sk_rx_ramstart = val;</a>
<a name="ln1444">		val += (chunk / sizeof(u_int64_t));</a>
<a name="ln1445">		sc_if-&gt;sk_rx_ramend = val - 1;</a>
<a name="ln1446">		sc_if-&gt;sk_tx_ramstart = val;</a>
<a name="ln1447">		val += (chunk / sizeof(u_int64_t));</a>
<a name="ln1448">		sc_if-&gt;sk_tx_ramend = val - 1;</a>
<a name="ln1449">	} else {</a>
<a name="ln1450">		u_int32_t		chunk, val;</a>
<a name="ln1451"> </a>
<a name="ln1452">		chunk = sc-&gt;sk_ramsize / 4;</a>
<a name="ln1453">		val = (sc-&gt;sk_rboff + (chunk * 2 * sc_if-&gt;sk_port)) /</a>
<a name="ln1454">		    sizeof(u_int64_t);</a>
<a name="ln1455">		sc_if-&gt;sk_rx_ramstart = val;</a>
<a name="ln1456">		val += (chunk / sizeof(u_int64_t));</a>
<a name="ln1457">		sc_if-&gt;sk_rx_ramend = val - 1;</a>
<a name="ln1458">		sc_if-&gt;sk_tx_ramstart = val;</a>
<a name="ln1459">		val += (chunk / sizeof(u_int64_t));</a>
<a name="ln1460">		sc_if-&gt;sk_tx_ramend = val - 1;</a>
<a name="ln1461">	}</a>
<a name="ln1462"> </a>
<a name="ln1463">	/* Read and save PHY type and set PHY address */</a>
<a name="ln1464">	sc_if-&gt;sk_phytype = sk_win_read_1(sc, SK_EPROM1) &amp; 0xF;</a>
<a name="ln1465">	if (!SK_YUKON_FAMILY(sc-&gt;sk_type)) {</a>
<a name="ln1466">		switch(sc_if-&gt;sk_phytype) {</a>
<a name="ln1467">		case SK_PHYTYPE_XMAC:</a>
<a name="ln1468">			sc_if-&gt;sk_phyaddr = SK_PHYADDR_XMAC;</a>
<a name="ln1469">			break;</a>
<a name="ln1470">		case SK_PHYTYPE_BCOM:</a>
<a name="ln1471">			sc_if-&gt;sk_phyaddr = SK_PHYADDR_BCOM;</a>
<a name="ln1472">			break;</a>
<a name="ln1473">		default:</a>
<a name="ln1474">			device_printf(sc-&gt;sk_dev, &quot;unsupported PHY type: %d\n&quot;,</a>
<a name="ln1475">			    sc_if-&gt;sk_phytype);</a>
<a name="ln1476">			error = ENODEV;</a>
<a name="ln1477">			SK_IF_UNLOCK(sc_if);</a>
<a name="ln1478">			goto fail;</a>
<a name="ln1479">		}</a>
<a name="ln1480">	} else {</a>
<a name="ln1481">		if (sc_if-&gt;sk_phytype &lt; SK_PHYTYPE_MARV_COPPER &amp;&amp;</a>
<a name="ln1482">		    sc-&gt;sk_pmd != 'S') {</a>
<a name="ln1483">			/* not initialized, punt */</a>
<a name="ln1484">			sc_if-&gt;sk_phytype = SK_PHYTYPE_MARV_COPPER;</a>
<a name="ln1485">			sc-&gt;sk_coppertype = 1;</a>
<a name="ln1486">		}</a>
<a name="ln1487"> </a>
<a name="ln1488">		sc_if-&gt;sk_phyaddr = SK_PHYADDR_MARV;</a>
<a name="ln1489"> </a>
<a name="ln1490">		if (!(sc-&gt;sk_coppertype))</a>
<a name="ln1491">			sc_if-&gt;sk_phytype = SK_PHYTYPE_MARV_FIBER;</a>
<a name="ln1492">	}</a>
<a name="ln1493"> </a>
<a name="ln1494">	/*</a>
<a name="ln1495">	 * Call MI attach routine.  Can't hold locks when calling into ether_*.</a>
<a name="ln1496">	 */</a>
<a name="ln1497">	SK_IF_UNLOCK(sc_if);</a>
<a name="ln1498">	ether_ifattach(ifp, eaddr);</a>
<a name="ln1499">	SK_IF_LOCK(sc_if);</a>
<a name="ln1500"> </a>
<a name="ln1501">	/*</a>
<a name="ln1502">	 * The hardware should be ready for VLAN_MTU by default:</a>
<a name="ln1503">	 * XMAC II has 0x8100 in VLAN Tag Level 1 register initially;</a>
<a name="ln1504">	 * YU_SMR_MFL_VLAN is set by this driver in Yukon.</a>
<a name="ln1505">	 *</a>
<a name="ln1506">	 */</a>
<a name="ln1507">        ifp-&gt;if_capabilities |= IFCAP_VLAN_MTU;</a>
<a name="ln1508">        ifp-&gt;if_capenable |= IFCAP_VLAN_MTU;</a>
<a name="ln1509">	/*</a>
<a name="ln1510">	 * Tell the upper layer(s) we support long frames.</a>
<a name="ln1511">	 * Must appear after the call to ether_ifattach() because</a>
<a name="ln1512">	 * ether_ifattach() sets ifi_hdrlen to the default value.</a>
<a name="ln1513">	 */</a>
<a name="ln1514">        ifp-&gt;if_hdrlen = sizeof(struct ether_vlan_header);</a>
<a name="ln1515"> </a>
<a name="ln1516">	/*</a>
<a name="ln1517">	 * Do miibus setup.</a>
<a name="ln1518">	 */</a>
<a name="ln1519">	phy = MII_PHY_ANY;</a>
<a name="ln1520">	switch (sc-&gt;sk_type) {</a>
<a name="ln1521">	case SK_GENESIS:</a>
<a name="ln1522">		sk_init_xmac(sc_if);</a>
<a name="ln1523">		if (sc_if-&gt;sk_phytype == SK_PHYTYPE_XMAC)</a>
<a name="ln1524">			phy = 0;</a>
<a name="ln1525">		break;</a>
<a name="ln1526">	case SK_YUKON:</a>
<a name="ln1527">	case SK_YUKON_LITE:</a>
<a name="ln1528">	case SK_YUKON_LP:</a>
<a name="ln1529">		sk_init_yukon(sc_if);</a>
<a name="ln1530">		phy = 0;</a>
<a name="ln1531">		break;</a>
<a name="ln1532">	}</a>
<a name="ln1533"> </a>
<a name="ln1534">	SK_IF_UNLOCK(sc_if);</a>
<a name="ln1535">	error = mii_attach(dev, &amp;sc_if-&gt;sk_miibus, ifp, sk_ifmedia_upd,</a>
<a name="ln1536">	    sk_ifmedia_sts, BMSR_DEFCAPMASK, phy, MII_OFFSET_ANY, 0);</a>
<a name="ln1537">	if (error != 0) {</a>
<a name="ln1538">		device_printf(sc_if-&gt;sk_if_dev, &quot;attaching PHYs failed\n&quot;);</a>
<a name="ln1539">		ether_ifdetach(ifp);</a>
<a name="ln1540">		goto fail;</a>
<a name="ln1541">	}</a>
<a name="ln1542"> </a>
<a name="ln1543">fail:</a>
<a name="ln1544">	if (error) {</a>
<a name="ln1545">		/* Access should be ok even though lock has been dropped */</a>
<a name="ln1546">		sc-&gt;sk_if[port] = NULL;</a>
<a name="ln1547">		sk_detach(dev);</a>
<a name="ln1548">	}</a>
<a name="ln1549"> </a>
<a name="ln1550">	return(error);</a>
<a name="ln1551">}</a>
<a name="ln1552"> </a>
<a name="ln1553">/*</a>
<a name="ln1554"> * Attach the interface. Allocate softc structures, do ifmedia</a>
<a name="ln1555"> * setup and ethernet/BPF attach.</a>
<a name="ln1556"> */</a>
<a name="ln1557">static int</a>
<a name="ln1558">skc_attach(dev)</a>
<a name="ln1559">	device_t		dev;</a>
<a name="ln1560">{</a>
<a name="ln1561">	struct sk_softc		*sc;</a>
<a name="ln1562">	int			error = 0, *port;</a>
<a name="ln1563">	uint8_t			skrs;</a>
<a name="ln1564">	const char		*pname = NULL;</a>
<a name="ln1565">	char			*revstr;</a>
<a name="ln1566"> </a>
<a name="ln1567">	sc = device_get_softc(dev);</a>
<a name="ln1568">	sc-&gt;sk_dev = dev;</a>
<a name="ln1569"> </a>
<a name="ln1570">	mtx_init(&amp;sc-&gt;sk_mtx, device_get_nameunit(dev), MTX_NETWORK_LOCK,</a>
<a name="ln1571">	    MTX_DEF);</a>
<a name="ln1572">	mtx_init(&amp;sc-&gt;sk_mii_mtx, &quot;sk_mii_mutex&quot;, NULL, MTX_DEF);</a>
<a name="ln1573">	/*</a>
<a name="ln1574">	 * Map control/status registers.</a>
<a name="ln1575">	 */</a>
<a name="ln1576">	pci_enable_busmaster(dev);</a>
<a name="ln1577"> </a>
<a name="ln1578">	/* Allocate resources */</a>
<a name="ln1579">#ifdef SK_USEIOSPACE</a>
<a name="ln1580">	sc-&gt;sk_res_spec = sk_res_spec_io;</a>
<a name="ln1581">#else</a>
<a name="ln1582">	sc-&gt;sk_res_spec = sk_res_spec_mem;</a>
<a name="ln1583">#endif</a>
<a name="ln1584">	error = bus_alloc_resources(dev, sc-&gt;sk_res_spec, sc-&gt;sk_res);</a>
<a name="ln1585">	if (error) {</a>
<a name="ln1586">		if (sc-&gt;sk_res_spec == sk_res_spec_mem)</a>
<a name="ln1587">			sc-&gt;sk_res_spec = sk_res_spec_io;</a>
<a name="ln1588">		else</a>
<a name="ln1589">			sc-&gt;sk_res_spec = sk_res_spec_mem;</a>
<a name="ln1590">		error = bus_alloc_resources(dev, sc-&gt;sk_res_spec, sc-&gt;sk_res);</a>
<a name="ln1591">		if (error) {</a>
<a name="ln1592">			device_printf(dev, &quot;couldn't allocate %s resources\n&quot;,</a>
<a name="ln1593">			    sc-&gt;sk_res_spec == sk_res_spec_mem ? &quot;memory&quot; :</a>
<a name="ln1594">			    &quot;I/O&quot;);</a>
<a name="ln1595">			goto fail;</a>
<a name="ln1596">		}</a>
<a name="ln1597">	}</a>
<a name="ln1598"> </a>
<a name="ln1599">	sc-&gt;sk_type = sk_win_read_1(sc, SK_CHIPVER);</a>
<a name="ln1600">	sc-&gt;sk_rev = (sk_win_read_1(sc, SK_CONFIG) &gt;&gt; 4) &amp; 0xf;</a>
<a name="ln1601"> </a>
<a name="ln1602">	/* Bail out if chip is not recognized. */</a>
<a name="ln1603">	if (sc-&gt;sk_type != SK_GENESIS &amp;&amp; !SK_YUKON_FAMILY(sc-&gt;sk_type)) {</a>
<a name="ln1604">		device_printf(dev, &quot;unknown device: chipver=%02x, rev=%x\n&quot;,</a>
<a name="ln1605">		    sc-&gt;sk_type, sc-&gt;sk_rev);</a>
<a name="ln1606">		error = ENXIO;</a>
<a name="ln1607">		goto fail;</a>
<a name="ln1608">	}</a>
<a name="ln1609"> </a>
<a name="ln1610">	SYSCTL_ADD_PROC(device_get_sysctl_ctx(dev),</a>
<a name="ln1611">		SYSCTL_CHILDREN(device_get_sysctl_tree(dev)),</a>
<a name="ln1612">		OID_AUTO, &quot;int_mod&quot;, CTLTYPE_INT|CTLFLAG_RW,</a>
<a name="ln1613">		&amp;sc-&gt;sk_int_mod, 0, sysctl_hw_sk_int_mod, &quot;I&quot;,</a>
<a name="ln1614">		&quot;SK interrupt moderation&quot;);</a>
<a name="ln1615"> </a>
<a name="ln1616">	/* Pull in device tunables. */</a>
<a name="ln1617">	sc-&gt;sk_int_mod = SK_IM_DEFAULT;</a>
<a name="ln1618">	error = resource_int_value(device_get_name(dev), device_get_unit(dev),</a>
<a name="ln1619">		&quot;int_mod&quot;, &amp;sc-&gt;sk_int_mod);</a>
<a name="ln1620">	if (error == 0) {</a>
<a name="ln1621">		if (sc-&gt;sk_int_mod &lt; SK_IM_MIN ||</a>
<a name="ln1622">		    sc-&gt;sk_int_mod &gt; SK_IM_MAX) {</a>
<a name="ln1623">			device_printf(dev, &quot;int_mod value out of range; &quot;</a>
<a name="ln1624">			    &quot;using default: %d\n&quot;, SK_IM_DEFAULT);</a>
<a name="ln1625">			sc-&gt;sk_int_mod = SK_IM_DEFAULT;</a>
<a name="ln1626">		}</a>
<a name="ln1627">	}</a>
<a name="ln1628"> </a>
<a name="ln1629">	/* Reset the adapter. */</a>
<a name="ln1630">	sk_reset(sc);</a>
<a name="ln1631"> </a>
<a name="ln1632">	skrs = sk_win_read_1(sc, SK_EPROM0);</a>
<a name="ln1633">	if (sc-&gt;sk_type == SK_GENESIS) {</a>
<a name="ln1634">		/* Read and save RAM size and RAMbuffer offset */</a>
<a name="ln1635">		switch(skrs) {</a>
<a name="ln1636">		case SK_RAMSIZE_512K_64:</a>
<a name="ln1637">			sc-&gt;sk_ramsize = 0x80000;</a>
<a name="ln1638">			sc-&gt;sk_rboff = SK_RBOFF_0;</a>
<a name="ln1639">			break;</a>
<a name="ln1640">		case SK_RAMSIZE_1024K_64:</a>
<a name="ln1641">			sc-&gt;sk_ramsize = 0x100000;</a>
<a name="ln1642">			sc-&gt;sk_rboff = SK_RBOFF_80000;</a>
<a name="ln1643">			break;</a>
<a name="ln1644">		case SK_RAMSIZE_1024K_128:</a>
<a name="ln1645">			sc-&gt;sk_ramsize = 0x100000;</a>
<a name="ln1646">			sc-&gt;sk_rboff = SK_RBOFF_0;</a>
<a name="ln1647">			break;</a>
<a name="ln1648">		case SK_RAMSIZE_2048K_128:</a>
<a name="ln1649">			sc-&gt;sk_ramsize = 0x200000;</a>
<a name="ln1650">			sc-&gt;sk_rboff = SK_RBOFF_0;</a>
<a name="ln1651">			break;</a>
<a name="ln1652">		default:</a>
<a name="ln1653">			device_printf(dev, &quot;unknown ram size: %d\n&quot;, skrs);</a>
<a name="ln1654">			error = ENXIO;</a>
<a name="ln1655">			goto fail;</a>
<a name="ln1656">		}</a>
<a name="ln1657">	} else { /* SK_YUKON_FAMILY */</a>
<a name="ln1658">		if (skrs == 0x00)</a>
<a name="ln1659">			sc-&gt;sk_ramsize = 0x20000;</a>
<a name="ln1660">		else</a>
<a name="ln1661">			sc-&gt;sk_ramsize = skrs * (1&lt;&lt;12);</a>
<a name="ln1662">		sc-&gt;sk_rboff = SK_RBOFF_0;</a>
<a name="ln1663">	}</a>
<a name="ln1664"> </a>
<a name="ln1665">	/* Read and save physical media type */</a>
<a name="ln1666">	 sc-&gt;sk_pmd = sk_win_read_1(sc, SK_PMDTYPE);</a>
<a name="ln1667"> </a>
<a name="ln1668">	 if (sc-&gt;sk_pmd == 'T' || sc-&gt;sk_pmd == '1')</a>
<a name="ln1669">		 sc-&gt;sk_coppertype = 1;</a>
<a name="ln1670">	 else</a>
<a name="ln1671">		 sc-&gt;sk_coppertype = 0;</a>
<a name="ln1672"> </a>
<a name="ln1673">	/* Determine whether to name it with VPD PN or just make it up.</a>
<a name="ln1674">	 * Marvell Yukon VPD PN seems to freqently be bogus. */</a>
<a name="ln1675">	switch (pci_get_device(dev)) {</a>
<a name="ln1676">	case DEVICEID_SK_V1:</a>
<a name="ln1677">	case DEVICEID_BELKIN_5005:</a>
<a name="ln1678">	case DEVICEID_3COM_3C940:</a>
<a name="ln1679">	case DEVICEID_LINKSYS_EG1032:</a>
<a name="ln1680">	case DEVICEID_DLINK_DGE530T_A1:</a>
<a name="ln1681">	case DEVICEID_DLINK_DGE530T_B1:</a>
<a name="ln1682">		/* Stay with VPD PN. */</a>
<a name="ln1683">		(void) pci_get_vpd_ident(dev, &amp;pname);</a>
<a name="ln1684">		break;</a>
<a name="ln1685">	case DEVICEID_SK_V2:</a>
<a name="ln1686">		/* YUKON VPD PN might bear no resemblance to reality. */</a>
<a name="ln1687">		switch (sc-&gt;sk_type) {</a>
<a name="ln1688">		case SK_GENESIS:</a>
<a name="ln1689">			/* Stay with VPD PN. */</a>
<a name="ln1690">			(void) pci_get_vpd_ident(dev, &amp;pname);</a>
<a name="ln1691">			break;</a>
<a name="ln1692">		case SK_YUKON:</a>
<a name="ln1693">			pname = &quot;Marvell Yukon Gigabit Ethernet&quot;;</a>
<a name="ln1694">			break;</a>
<a name="ln1695">		case SK_YUKON_LITE:</a>
<a name="ln1696">			pname = &quot;Marvell Yukon Lite Gigabit Ethernet&quot;;</a>
<a name="ln1697">			break;</a>
<a name="ln1698">		case SK_YUKON_LP:</a>
<a name="ln1699">			pname = &quot;Marvell Yukon LP Gigabit Ethernet&quot;;</a>
<a name="ln1700">			break;</a>
<a name="ln1701">		default:</a>
<a name="ln1702">			pname = &quot;Marvell Yukon (Unknown) Gigabit Ethernet&quot;;</a>
<a name="ln1703">			break;</a>
<a name="ln1704">		}</a>
<a name="ln1705"> </a>
<a name="ln1706">		/* Yukon Lite Rev. A0 needs special test. */</a>
<a name="ln1707">		if (sc-&gt;sk_type == SK_YUKON || sc-&gt;sk_type == SK_YUKON_LP) {</a>
<a name="ln1708">			u_int32_t far;</a>
<a name="ln1709">			u_int8_t testbyte;</a>
<a name="ln1710"> </a>
<a name="ln1711">			/* Save flash address register before testing. */</a>
<a name="ln1712">			far = sk_win_read_4(sc, SK_EP_ADDR);</a>
<a name="ln1713"> </a>
<a name="ln1714">			sk_win_write_1(sc, SK_EP_ADDR+0x03, 0xff);</a>
<a name="ln1715">			testbyte = sk_win_read_1(sc, SK_EP_ADDR+0x03);</a>
<a name="ln1716"> </a>
<a name="ln1717">			if (testbyte != 0x00) {</a>
<a name="ln1718">				/* Yukon Lite Rev. A0 detected. */</a>
<a name="ln1719">				sc-&gt;sk_type = SK_YUKON_LITE;</a>
<a name="ln1720">				sc-&gt;sk_rev = SK_YUKON_LITE_REV_A0;</a>
<a name="ln1721">				/* Restore flash address register. */</a>
<a name="ln1722">				sk_win_write_4(sc, SK_EP_ADDR, far);</a>
<a name="ln1723">			}</a>
<a name="ln1724">		}</a>
<a name="ln1725">		break;</a>
<a name="ln1726">	default:</a>
<a name="ln1727">		device_printf(dev, &quot;unknown device: vendor=%04x, device=%04x, &quot;</a>
<a name="ln1728">			&quot;chipver=%02x, rev=%x\n&quot;,</a>
<a name="ln1729">			pci_get_vendor(dev), pci_get_device(dev),</a>
<a name="ln1730">			sc-&gt;sk_type, sc-&gt;sk_rev);</a>
<a name="ln1731">		error = ENXIO;</a>
<a name="ln1732">		goto fail;</a>
<a name="ln1733">	}</a>
<a name="ln1734"> </a>
<a name="ln1735">	if (sc-&gt;sk_type == SK_YUKON_LITE) {</a>
<a name="ln1736">		switch (sc-&gt;sk_rev) {</a>
<a name="ln1737">		case SK_YUKON_LITE_REV_A0:</a>
<a name="ln1738">			revstr = &quot;A0&quot;;</a>
<a name="ln1739">			break;</a>
<a name="ln1740">		case SK_YUKON_LITE_REV_A1:</a>
<a name="ln1741">			revstr = &quot;A1&quot;;</a>
<a name="ln1742">			break;</a>
<a name="ln1743">		case SK_YUKON_LITE_REV_A3:</a>
<a name="ln1744">			revstr = &quot;A3&quot;;</a>
<a name="ln1745">			break;</a>
<a name="ln1746">		default:</a>
<a name="ln1747">			revstr = &quot;&quot;;</a>
<a name="ln1748">			break;</a>
<a name="ln1749">		}</a>
<a name="ln1750">	} else {</a>
<a name="ln1751">		revstr = &quot;&quot;;</a>
<a name="ln1752">	}</a>
<a name="ln1753"> </a>
<a name="ln1754">	/* Announce the product name and more VPD data if there. */</a>
<a name="ln1755">	if (pname != NULL)</a>
<a name="ln1756">		device_printf(dev, &quot;%s rev. %s(0x%x)\n&quot;,</a>
<a name="ln1757">			pname, revstr, sc-&gt;sk_rev);</a>
<a name="ln1758"> </a>
<a name="ln1759">	if (bootverbose) {</a>
<a name="ln1760">		device_printf(dev, &quot;chip ver  = 0x%02x\n&quot;, sc-&gt;sk_type);</a>
<a name="ln1761">		device_printf(dev, &quot;chip rev  = 0x%02x\n&quot;, sc-&gt;sk_rev);</a>
<a name="ln1762">		device_printf(dev, &quot;SK_EPROM0 = 0x%02x\n&quot;, skrs);</a>
<a name="ln1763">		device_printf(dev, &quot;SRAM size = 0x%06x\n&quot;, sc-&gt;sk_ramsize);</a>
<a name="ln1764">	}</a>
<a name="ln1765"> </a>
<a name="ln1766">	sc-&gt;sk_devs[SK_PORT_A] = device_add_child(dev, &quot;sk&quot;, -1);</a>
<a name="ln1767">	if (sc-&gt;sk_devs[SK_PORT_A] == NULL) {</a>
<a name="ln1768">		device_printf(dev, &quot;failed to add child for PORT_A\n&quot;);</a>
<a name="ln1769">		error = ENXIO;</a>
<a name="ln1770">		goto fail;</a>
<a name="ln1771">	}</a>
<a name="ln1772">	port = malloc(sizeof(int), M_DEVBUF, M_NOWAIT);</a>
<a name="ln1773">	if (port == NULL) {</a>
<a name="ln1774">		device_printf(dev, &quot;failed to allocate memory for &quot;</a>
<a name="ln1775">		    &quot;ivars of PORT_A\n&quot;);</a>
<a name="ln1776">		error = ENXIO;</a>
<a name="ln1777">		goto fail;</a>
<a name="ln1778">	}</a>
<a name="ln1779">	*port = SK_PORT_A;</a>
<a name="ln1780">	device_set_ivars(sc-&gt;sk_devs[SK_PORT_A], port);</a>
<a name="ln1781"> </a>
<a name="ln1782">	if (!(sk_win_read_1(sc, SK_CONFIG) &amp; SK_CONFIG_SINGLEMAC)) {</a>
<a name="ln1783">		sc-&gt;sk_devs[SK_PORT_B] = device_add_child(dev, &quot;sk&quot;, -1);</a>
<a name="ln1784">		if (sc-&gt;sk_devs[SK_PORT_B] == NULL) {</a>
<a name="ln1785">			device_printf(dev, &quot;failed to add child for PORT_B\n&quot;);</a>
<a name="ln1786">			error = ENXIO;</a>
<a name="ln1787">			goto fail;</a>
<a name="ln1788">		}</a>
<a name="ln1789">		port = malloc(sizeof(int), M_DEVBUF, M_NOWAIT);</a>
<a name="ln1790">		if (port == NULL) {</a>
<a name="ln1791">			device_printf(dev, &quot;failed to allocate memory for &quot;</a>
<a name="ln1792">			    &quot;ivars of PORT_B\n&quot;);</a>
<a name="ln1793">			error = ENXIO;</a>
<a name="ln1794">			goto fail;</a>
<a name="ln1795">		}</a>
<a name="ln1796">		*port = SK_PORT_B;</a>
<a name="ln1797">		device_set_ivars(sc-&gt;sk_devs[SK_PORT_B], port);</a>
<a name="ln1798">	}</a>
<a name="ln1799"> </a>
<a name="ln1800">	/* Turn on the 'driver is loaded' LED. */</a>
<a name="ln1801">	CSR_WRITE_2(sc, SK_LED, SK_LED_GREEN_ON);</a>
<a name="ln1802"> </a>
<a name="ln1803">	error = bus_generic_attach(dev);</a>
<a name="ln1804">	if (error) {</a>
<a name="ln1805">		device_printf(dev, &quot;failed to attach port(s)\n&quot;);</a>
<a name="ln1806">		goto fail;</a>
<a name="ln1807">	}</a>
<a name="ln1808"> </a>
<a name="ln1809">	/* Hook interrupt last to avoid having to lock softc */</a>
<a name="ln1810">	error = bus_setup_intr(dev, sc-&gt;sk_res[1], INTR_TYPE_NET|INTR_MPSAFE,</a>
<a name="ln1811">	    NULL, sk_intr, sc, &amp;sc-&gt;sk_intrhand);</a>
<a name="ln1812"> </a>
<a name="ln1813">	if (error) {</a>
<a name="ln1814">		device_printf(dev, &quot;couldn't set up irq\n&quot;);</a>
<a name="ln1815">		goto fail;</a>
<a name="ln1816">	}</a>
<a name="ln1817"> </a>
<a name="ln1818">fail:</a>
<a name="ln1819">	if (error)</a>
<a name="ln1820">		skc_detach(dev);</a>
<a name="ln1821"> </a>
<a name="ln1822">	return(error);</a>
<a name="ln1823">}</a>
<a name="ln1824"> </a>
<a name="ln1825">/*</a>
<a name="ln1826"> * Shutdown hardware and free up resources. This can be called any</a>
<a name="ln1827"> * time after the mutex has been initialized. It is called in both</a>
<a name="ln1828"> * the error case in attach and the normal detach case so it needs</a>
<a name="ln1829"> * to be careful about only freeing resources that have actually been</a>
<a name="ln1830"> * allocated.</a>
<a name="ln1831"> */</a>
<a name="ln1832">static int</a>
<a name="ln1833">sk_detach(dev)</a>
<a name="ln1834">	device_t		dev;</a>
<a name="ln1835">{</a>
<a name="ln1836">	struct sk_if_softc	*sc_if;</a>
<a name="ln1837">	struct ifnet		*ifp;</a>
<a name="ln1838"> </a>
<a name="ln1839">	sc_if = device_get_softc(dev);</a>
<a name="ln1840">	KASSERT(mtx_initialized(&amp;sc_if-&gt;sk_softc-&gt;sk_mtx),</a>
<a name="ln1841">	    (&quot;sk mutex not initialized in sk_detach&quot;));</a>
<a name="ln1842">	SK_IF_LOCK(sc_if);</a>
<a name="ln1843"> </a>
<a name="ln1844">	ifp = sc_if-&gt;sk_ifp;</a>
<a name="ln1845">	/* These should only be active if attach_xmac succeeded */</a>
<a name="ln1846">	if (device_is_attached(dev)) {</a>
<a name="ln1847">		sk_stop(sc_if);</a>
<a name="ln1848">		/* Can't hold locks while calling detach */</a>
<a name="ln1849">		SK_IF_UNLOCK(sc_if);</a>
<a name="ln1850">		callout_drain(&amp;sc_if-&gt;sk_tick_ch);</a>
<a name="ln1851">		callout_drain(&amp;sc_if-&gt;sk_watchdog_ch);</a>
<a name="ln1852">		ether_ifdetach(ifp);</a>
<a name="ln1853">		SK_IF_LOCK(sc_if);</a>
<a name="ln1854">	}</a>
<a name="ln1855">	/*</a>
<a name="ln1856">	 * We're generally called from skc_detach() which is using</a>
<a name="ln1857">	 * device_delete_child() to get to here. It's already trashed</a>
<a name="ln1858">	 * miibus for us, so don't do it here or we'll panic.</a>
<a name="ln1859">	 */</a>
<a name="ln1860">	/*</a>
<a name="ln1861">	if (sc_if-&gt;sk_miibus != NULL)</a>
<a name="ln1862">		device_delete_child(dev, sc_if-&gt;sk_miibus);</a>
<a name="ln1863">	*/</a>
<a name="ln1864">	bus_generic_detach(dev);</a>
<a name="ln1865">	sk_dma_jumbo_free(sc_if);</a>
<a name="ln1866">	sk_dma_free(sc_if);</a>
<a name="ln1867">	SK_IF_UNLOCK(sc_if);</a>
<a name="ln1868">	if (ifp)</a>
<a name="ln1869">		if_free(ifp);</a>
<a name="ln1870"> </a>
<a name="ln1871">	return(0);</a>
<a name="ln1872">}</a>
<a name="ln1873"> </a>
<a name="ln1874">static int</a>
<a name="ln1875">skc_detach(dev)</a>
<a name="ln1876">	device_t		dev;</a>
<a name="ln1877">{</a>
<a name="ln1878">	struct sk_softc		*sc;</a>
<a name="ln1879"> </a>
<a name="ln1880">	sc = device_get_softc(dev);</a>
<a name="ln1881">	KASSERT(mtx_initialized(&amp;sc-&gt;sk_mtx), (&quot;sk mutex not initialized&quot;));</a>
<a name="ln1882"> </a>
<a name="ln1883">	if (device_is_alive(dev)) {</a>
<a name="ln1884">		if (sc-&gt;sk_devs[SK_PORT_A] != NULL) {</a>
<a name="ln1885">			free(device_get_ivars(sc-&gt;sk_devs[SK_PORT_A]), M_DEVBUF);</a>
<a name="ln1886">			device_delete_child(dev, sc-&gt;sk_devs[SK_PORT_A]);</a>
<a name="ln1887">		}</a>
<a name="ln1888">		if (sc-&gt;sk_devs[SK_PORT_B] != NULL) {</a>
<a name="ln1889">			free(device_get_ivars(sc-&gt;sk_devs[SK_PORT_B]), M_DEVBUF);</a>
<a name="ln1890">			device_delete_child(dev, sc-&gt;sk_devs[SK_PORT_B]);</a>
<a name="ln1891">		}</a>
<a name="ln1892">		bus_generic_detach(dev);</a>
<a name="ln1893">	}</a>
<a name="ln1894"> </a>
<a name="ln1895">	if (sc-&gt;sk_intrhand)</a>
<a name="ln1896">		bus_teardown_intr(dev, sc-&gt;sk_res[1], sc-&gt;sk_intrhand);</a>
<a name="ln1897">	bus_release_resources(dev, sc-&gt;sk_res_spec, sc-&gt;sk_res);</a>
<a name="ln1898"> </a>
<a name="ln1899">	mtx_destroy(&amp;sc-&gt;sk_mii_mtx);</a>
<a name="ln1900">	mtx_destroy(&amp;sc-&gt;sk_mtx);</a>
<a name="ln1901"> </a>
<a name="ln1902">	return(0);</a>
<a name="ln1903">}</a>
<a name="ln1904"> </a>
<a name="ln1905">static bus_dma_tag_t</a>
<a name="ln1906">skc_get_dma_tag(device_t bus, device_t child __unused)</a>
<a name="ln1907">{</a>
<a name="ln1908"> </a>
<a name="ln1909">	return (bus_get_dma_tag(bus));</a>
<a name="ln1910">}</a>
<a name="ln1911"> </a>
<a name="ln1912">struct sk_dmamap_arg {</a>
<a name="ln1913">	bus_addr_t	sk_busaddr;</a>
<a name="ln1914">};</a>
<a name="ln1915"> </a>
<a name="ln1916">static void</a>
<a name="ln1917">sk_dmamap_cb(arg, segs, nseg, error)</a>
<a name="ln1918">	void			*arg;</a>
<a name="ln1919">	bus_dma_segment_t	*segs;</a>
<a name="ln1920">	int			nseg;</a>
<a name="ln1921">	int			error;</a>
<a name="ln1922">{</a>
<a name="ln1923">	struct sk_dmamap_arg	*ctx;</a>
<a name="ln1924"> </a>
<a name="ln1925">	if (error != 0)</a>
<a name="ln1926">		return;</a>
<a name="ln1927"> </a>
<a name="ln1928">	ctx = arg;</a>
<a name="ln1929">	ctx-&gt;sk_busaddr = segs[0].ds_addr;</a>
<a name="ln1930">}</a>
<a name="ln1931"> </a>
<a name="ln1932">/*</a>
<a name="ln1933"> * Allocate jumbo buffer storage. The SysKonnect adapters support</a>
<a name="ln1934"> * &quot;jumbograms&quot; (9K frames), although SysKonnect doesn't currently</a>
<a name="ln1935"> * use them in their drivers. In order for us to use them, we need</a>
<a name="ln1936"> * large 9K receive buffers, however standard mbuf clusters are only</a>
<a name="ln1937"> * 2048 bytes in size. Consequently, we need to allocate and manage</a>
<a name="ln1938"> * our own jumbo buffer pool. Fortunately, this does not require an</a>
<a name="ln1939"> * excessive amount of additional code.</a>
<a name="ln1940"> */</a>
<a name="ln1941">static int</a>
<a name="ln1942">sk_dma_alloc(sc_if)</a>
<a name="ln1943">	struct sk_if_softc	*sc_if;</a>
<a name="ln1944">{</a>
<a name="ln1945">	struct sk_dmamap_arg	ctx;</a>
<a name="ln1946">	struct sk_txdesc	*txd;</a>
<a name="ln1947">	struct sk_rxdesc	*rxd;</a>
<a name="ln1948">	int			error, i;</a>
<a name="ln1949"> </a>
<a name="ln1950">	/* create parent tag */</a>
<a name="ln1951">	/*</a>
<a name="ln1952">	 * XXX</a>
<a name="ln1953">	 * This driver should use BUS_SPACE_MAXADDR for lowaddr argument</a>
<a name="ln1954">	 * in bus_dma_tag_create(9) as the NIC would support DAC mode.</a>
<a name="ln1955">	 * However bz@ reported that it does not work on amd64 with &gt; 4GB</a>
<a name="ln1956">	 * RAM. Until we have more clues of the breakage, disable DAC mode</a>
<a name="ln1957">	 * by limiting DMA address to be in 32bit address space.</a>
<a name="ln1958">	 */</a>
<a name="ln1959">	error = bus_dma_tag_create(</a>
<a name="ln1960">		    bus_get_dma_tag(sc_if-&gt;sk_if_dev),/* parent */</a>
<a name="ln1961">		    1, 0,			/* algnmnt, boundary */</a>
<a name="ln1962">		    BUS_SPACE_MAXADDR_32BIT,	/* lowaddr */</a>
<a name="ln1963">		    BUS_SPACE_MAXADDR,		/* highaddr */</a>
<a name="ln1964">		    NULL, NULL,			/* filter, filterarg */</a>
<a name="ln1965">		    BUS_SPACE_MAXSIZE_32BIT,	/* maxsize */</a>
<a name="ln1966">		    0,				/* nsegments */</a>
<a name="ln1967">		    BUS_SPACE_MAXSIZE_32BIT,	/* maxsegsize */</a>
<a name="ln1968">		    0,				/* flags */</a>
<a name="ln1969">		    NULL, NULL,			/* lockfunc, lockarg */</a>
<a name="ln1970">		    &amp;sc_if-&gt;sk_cdata.sk_parent_tag);</a>
<a name="ln1971">	if (error != 0) {</a>
<a name="ln1972">		device_printf(sc_if-&gt;sk_if_dev,</a>
<a name="ln1973">		    &quot;failed to create parent DMA tag\n&quot;);</a>
<a name="ln1974">		goto fail;</a>
<a name="ln1975">	}</a>
<a name="ln1976"> </a>
<a name="ln1977">	/* create tag for Tx ring */</a>
<a name="ln1978">	error = bus_dma_tag_create(sc_if-&gt;sk_cdata.sk_parent_tag,/* parent */</a>
<a name="ln1979">		    SK_RING_ALIGN, 0,		/* algnmnt, boundary */</a>
<a name="ln1980">		    BUS_SPACE_MAXADDR_32BIT,	/* lowaddr */</a>
<a name="ln1981">		    BUS_SPACE_MAXADDR,		/* highaddr */</a>
<a name="ln1982">		    NULL, NULL,			/* filter, filterarg */</a>
<a name="ln1983">		    SK_TX_RING_SZ,		/* maxsize */</a>
<a name="ln1984">		    1,				/* nsegments */</a>
<a name="ln1985">		    SK_TX_RING_SZ,		/* maxsegsize */</a>
<a name="ln1986">		    0,				/* flags */</a>
<a name="ln1987">		    NULL, NULL,			/* lockfunc, lockarg */</a>
<a name="ln1988">		    &amp;sc_if-&gt;sk_cdata.sk_tx_ring_tag);</a>
<a name="ln1989">	if (error != 0) {</a>
<a name="ln1990">		device_printf(sc_if-&gt;sk_if_dev,</a>
<a name="ln1991">		    &quot;failed to allocate Tx ring DMA tag\n&quot;);</a>
<a name="ln1992">		goto fail;</a>
<a name="ln1993">	}</a>
<a name="ln1994"> </a>
<a name="ln1995">	/* create tag for Rx ring */</a>
<a name="ln1996">	error = bus_dma_tag_create(sc_if-&gt;sk_cdata.sk_parent_tag,/* parent */</a>
<a name="ln1997">		    SK_RING_ALIGN, 0,		/* algnmnt, boundary */</a>
<a name="ln1998">		    BUS_SPACE_MAXADDR_32BIT,	/* lowaddr */</a>
<a name="ln1999">		    BUS_SPACE_MAXADDR,		/* highaddr */</a>
<a name="ln2000">		    NULL, NULL,			/* filter, filterarg */</a>
<a name="ln2001">		    SK_RX_RING_SZ,		/* maxsize */</a>
<a name="ln2002">		    1,				/* nsegments */</a>
<a name="ln2003">		    SK_RX_RING_SZ,		/* maxsegsize */</a>
<a name="ln2004">		    0,				/* flags */</a>
<a name="ln2005">		    NULL, NULL,			/* lockfunc, lockarg */</a>
<a name="ln2006">		    &amp;sc_if-&gt;sk_cdata.sk_rx_ring_tag);</a>
<a name="ln2007">	if (error != 0) {</a>
<a name="ln2008">		device_printf(sc_if-&gt;sk_if_dev,</a>
<a name="ln2009">		    &quot;failed to allocate Rx ring DMA tag\n&quot;);</a>
<a name="ln2010">		goto fail;</a>
<a name="ln2011">	}</a>
<a name="ln2012"> </a>
<a name="ln2013">	/* create tag for Tx buffers */</a>
<a name="ln2014">	error = bus_dma_tag_create(sc_if-&gt;sk_cdata.sk_parent_tag,/* parent */</a>
<a name="ln2015">		    1, 0,			/* algnmnt, boundary */</a>
<a name="ln2016">		    BUS_SPACE_MAXADDR,		/* lowaddr */</a>
<a name="ln2017">		    BUS_SPACE_MAXADDR,		/* highaddr */</a>
<a name="ln2018">		    NULL, NULL,			/* filter, filterarg */</a>
<a name="ln2019">		    MCLBYTES * SK_MAXTXSEGS,	/* maxsize */</a>
<a name="ln2020">		    SK_MAXTXSEGS,		/* nsegments */</a>
<a name="ln2021">		    MCLBYTES,			/* maxsegsize */</a>
<a name="ln2022">		    0,				/* flags */</a>
<a name="ln2023">		    NULL, NULL,			/* lockfunc, lockarg */</a>
<a name="ln2024">		    &amp;sc_if-&gt;sk_cdata.sk_tx_tag);</a>
<a name="ln2025">	if (error != 0) {</a>
<a name="ln2026">		device_printf(sc_if-&gt;sk_if_dev,</a>
<a name="ln2027">		    &quot;failed to allocate Tx DMA tag\n&quot;);</a>
<a name="ln2028">		goto fail;</a>
<a name="ln2029">	}</a>
<a name="ln2030"> </a>
<a name="ln2031">	/* create tag for Rx buffers */</a>
<a name="ln2032">	error = bus_dma_tag_create(sc_if-&gt;sk_cdata.sk_parent_tag,/* parent */</a>
<a name="ln2033">		    1, 0,			/* algnmnt, boundary */</a>
<a name="ln2034">		    BUS_SPACE_MAXADDR,		/* lowaddr */</a>
<a name="ln2035">		    BUS_SPACE_MAXADDR,		/* highaddr */</a>
<a name="ln2036">		    NULL, NULL,			/* filter, filterarg */</a>
<a name="ln2037">		    MCLBYTES,			/* maxsize */</a>
<a name="ln2038">		    1,				/* nsegments */</a>
<a name="ln2039">		    MCLBYTES,			/* maxsegsize */</a>
<a name="ln2040">		    0,				/* flags */</a>
<a name="ln2041">		    NULL, NULL,			/* lockfunc, lockarg */</a>
<a name="ln2042">		    &amp;sc_if-&gt;sk_cdata.sk_rx_tag);</a>
<a name="ln2043">	if (error != 0) {</a>
<a name="ln2044">		device_printf(sc_if-&gt;sk_if_dev,</a>
<a name="ln2045">		    &quot;failed to allocate Rx DMA tag\n&quot;);</a>
<a name="ln2046">		goto fail;</a>
<a name="ln2047">	}</a>
<a name="ln2048"> </a>
<a name="ln2049">	/* allocate DMA'able memory and load the DMA map for Tx ring */</a>
<a name="ln2050">	error = bus_dmamem_alloc(sc_if-&gt;sk_cdata.sk_tx_ring_tag,</a>
<a name="ln2051">	    (void **)&amp;sc_if-&gt;sk_rdata.sk_tx_ring, BUS_DMA_NOWAIT |</a>
<a name="ln2052">	    BUS_DMA_COHERENT | BUS_DMA_ZERO, &amp;sc_if-&gt;sk_cdata.sk_tx_ring_map);</a>
<a name="ln2053">	if (error != 0) {</a>
<a name="ln2054">		device_printf(sc_if-&gt;sk_if_dev,</a>
<a name="ln2055">		    &quot;failed to allocate DMA'able memory for Tx ring\n&quot;);</a>
<a name="ln2056">		goto fail;</a>
<a name="ln2057">	}</a>
<a name="ln2058"> </a>
<a name="ln2059">	ctx.sk_busaddr = 0;</a>
<a name="ln2060">	error = bus_dmamap_load(sc_if-&gt;sk_cdata.sk_tx_ring_tag,</a>
<a name="ln2061">	    sc_if-&gt;sk_cdata.sk_tx_ring_map, sc_if-&gt;sk_rdata.sk_tx_ring,</a>
<a name="ln2062">	    SK_TX_RING_SZ, sk_dmamap_cb, &amp;ctx, BUS_DMA_NOWAIT);</a>
<a name="ln2063">	if (error != 0) {</a>
<a name="ln2064">		device_printf(sc_if-&gt;sk_if_dev,</a>
<a name="ln2065">		    &quot;failed to load DMA'able memory for Tx ring\n&quot;);</a>
<a name="ln2066">		goto fail;</a>
<a name="ln2067">	}</a>
<a name="ln2068">	sc_if-&gt;sk_rdata.sk_tx_ring_paddr = ctx.sk_busaddr;</a>
<a name="ln2069"> </a>
<a name="ln2070">	/* allocate DMA'able memory and load the DMA map for Rx ring */</a>
<a name="ln2071">	error = bus_dmamem_alloc(sc_if-&gt;sk_cdata.sk_rx_ring_tag,</a>
<a name="ln2072">	    (void **)&amp;sc_if-&gt;sk_rdata.sk_rx_ring, BUS_DMA_NOWAIT |</a>
<a name="ln2073">	    BUS_DMA_COHERENT | BUS_DMA_ZERO, &amp;sc_if-&gt;sk_cdata.sk_rx_ring_map);</a>
<a name="ln2074">	if (error != 0) {</a>
<a name="ln2075">		device_printf(sc_if-&gt;sk_if_dev,</a>
<a name="ln2076">		    &quot;failed to allocate DMA'able memory for Rx ring\n&quot;);</a>
<a name="ln2077">		goto fail;</a>
<a name="ln2078">	}</a>
<a name="ln2079"> </a>
<a name="ln2080">	ctx.sk_busaddr = 0;</a>
<a name="ln2081">	error = bus_dmamap_load(sc_if-&gt;sk_cdata.sk_rx_ring_tag,</a>
<a name="ln2082">	    sc_if-&gt;sk_cdata.sk_rx_ring_map, sc_if-&gt;sk_rdata.sk_rx_ring,</a>
<a name="ln2083">	    SK_RX_RING_SZ, sk_dmamap_cb, &amp;ctx, BUS_DMA_NOWAIT);</a>
<a name="ln2084">	if (error != 0) {</a>
<a name="ln2085">		device_printf(sc_if-&gt;sk_if_dev,</a>
<a name="ln2086">		    &quot;failed to load DMA'able memory for Rx ring\n&quot;);</a>
<a name="ln2087">		goto fail;</a>
<a name="ln2088">	}</a>
<a name="ln2089">	sc_if-&gt;sk_rdata.sk_rx_ring_paddr = ctx.sk_busaddr;</a>
<a name="ln2090"> </a>
<a name="ln2091">	/* create DMA maps for Tx buffers */</a>
<a name="ln2092">	for (i = 0; i &lt; SK_TX_RING_CNT; i++) {</a>
<a name="ln2093">		txd = &amp;sc_if-&gt;sk_cdata.sk_txdesc[i];</a>
<a name="ln2094">		txd-&gt;tx_m = NULL;</a>
<a name="ln2095">		txd-&gt;tx_dmamap = NULL;</a>
<a name="ln2096">		error = bus_dmamap_create(sc_if-&gt;sk_cdata.sk_tx_tag, 0,</a>
<a name="ln2097">		    &amp;txd-&gt;tx_dmamap);</a>
<a name="ln2098">		if (error != 0) {</a>
<a name="ln2099">			device_printf(sc_if-&gt;sk_if_dev,</a>
<a name="ln2100">			    &quot;failed to create Tx dmamap\n&quot;);</a>
<a name="ln2101">			goto fail;</a>
<a name="ln2102">		}</a>
<a name="ln2103">	}</a>
<a name="ln2104"> </a>
<a name="ln2105">	/* create DMA maps for Rx buffers */</a>
<a name="ln2106">	if ((error = bus_dmamap_create(sc_if-&gt;sk_cdata.sk_rx_tag, 0,</a>
<a name="ln2107">	    &amp;sc_if-&gt;sk_cdata.sk_rx_sparemap)) != 0) {</a>
<a name="ln2108">		device_printf(sc_if-&gt;sk_if_dev,</a>
<a name="ln2109">		    &quot;failed to create spare Rx dmamap\n&quot;);</a>
<a name="ln2110">		goto fail;</a>
<a name="ln2111">	}</a>
<a name="ln2112">	for (i = 0; i &lt; SK_RX_RING_CNT; i++) {</a>
<a name="ln2113">		rxd = &amp;sc_if-&gt;sk_cdata.sk_rxdesc[i];</a>
<a name="ln2114">		rxd-&gt;rx_m = NULL;</a>
<a name="ln2115">		rxd-&gt;rx_dmamap = NULL;</a>
<a name="ln2116">		error = bus_dmamap_create(sc_if-&gt;sk_cdata.sk_rx_tag, 0,</a>
<a name="ln2117">		    &amp;rxd-&gt;rx_dmamap);</a>
<a name="ln2118">		if (error != 0) {</a>
<a name="ln2119">			device_printf(sc_if-&gt;sk_if_dev,</a>
<a name="ln2120">			    &quot;failed to create Rx dmamap\n&quot;);</a>
<a name="ln2121">			goto fail;</a>
<a name="ln2122">		}</a>
<a name="ln2123">	}</a>
<a name="ln2124"> </a>
<a name="ln2125">fail:</a>
<a name="ln2126">	return (error);</a>
<a name="ln2127">}</a>
<a name="ln2128"> </a>
<a name="ln2129">static int</a>
<a name="ln2130">sk_dma_jumbo_alloc(sc_if)</a>
<a name="ln2131">	struct sk_if_softc	*sc_if;</a>
<a name="ln2132">{</a>
<a name="ln2133">	struct sk_dmamap_arg	ctx;</a>
<a name="ln2134">	struct sk_rxdesc	*jrxd;</a>
<a name="ln2135">	int			error, i;</a>
<a name="ln2136"> </a>
<a name="ln2137">	if (jumbo_disable != 0) {</a>
<a name="ln2138">		device_printf(sc_if-&gt;sk_if_dev, &quot;disabling jumbo frame support\n&quot;);</a>
<a name="ln2139">		sc_if-&gt;sk_jumbo_disable = 1;</a>
<a name="ln2140">		return (0);</a>
<a name="ln2141">	}</a>
<a name="ln2142">	/* create tag for jumbo Rx ring */</a>
<a name="ln2143">	error = bus_dma_tag_create(sc_if-&gt;sk_cdata.sk_parent_tag,/* parent */</a>
<a name="ln2144">		    SK_RING_ALIGN, 0,		/* algnmnt, boundary */</a>
<a name="ln2145">		    BUS_SPACE_MAXADDR_32BIT,	/* lowaddr */</a>
<a name="ln2146">		    BUS_SPACE_MAXADDR,		/* highaddr */</a>
<a name="ln2147">		    NULL, NULL,			/* filter, filterarg */</a>
<a name="ln2148">		    SK_JUMBO_RX_RING_SZ,	/* maxsize */</a>
<a name="ln2149">		    1,				/* nsegments */</a>
<a name="ln2150">		    SK_JUMBO_RX_RING_SZ,	/* maxsegsize */</a>
<a name="ln2151">		    0,				/* flags */</a>
<a name="ln2152">		    NULL, NULL,			/* lockfunc, lockarg */</a>
<a name="ln2153">		    &amp;sc_if-&gt;sk_cdata.sk_jumbo_rx_ring_tag);</a>
<a name="ln2154">	if (error != 0) {</a>
<a name="ln2155">		device_printf(sc_if-&gt;sk_if_dev,</a>
<a name="ln2156">		    &quot;failed to allocate jumbo Rx ring DMA tag\n&quot;);</a>
<a name="ln2157">		goto jumbo_fail;</a>
<a name="ln2158">	}</a>
<a name="ln2159"> </a>
<a name="ln2160">	/* create tag for jumbo Rx buffers */</a>
<a name="ln2161">	error = bus_dma_tag_create(sc_if-&gt;sk_cdata.sk_parent_tag,/* parent */</a>
<a name="ln2162">		    1, 0,			/* algnmnt, boundary */</a>
<a name="ln2163">		    BUS_SPACE_MAXADDR,		/* lowaddr */</a>
<a name="ln2164">		    BUS_SPACE_MAXADDR,		/* highaddr */</a>
<a name="ln2165">		    NULL, NULL,			/* filter, filterarg */</a>
<a name="ln2166">		    MJUM9BYTES,			/* maxsize */</a>
<a name="ln2167">		    1,				/* nsegments */</a>
<a name="ln2168">		    MJUM9BYTES,			/* maxsegsize */</a>
<a name="ln2169">		    0,				/* flags */</a>
<a name="ln2170">		    NULL, NULL,			/* lockfunc, lockarg */</a>
<a name="ln2171">		    &amp;sc_if-&gt;sk_cdata.sk_jumbo_rx_tag);</a>
<a name="ln2172">	if (error != 0) {</a>
<a name="ln2173">		device_printf(sc_if-&gt;sk_if_dev,</a>
<a name="ln2174">		    &quot;failed to allocate jumbo Rx DMA tag\n&quot;);</a>
<a name="ln2175">		goto jumbo_fail;</a>
<a name="ln2176">	}</a>
<a name="ln2177"> </a>
<a name="ln2178">	/* allocate DMA'able memory and load the DMA map for jumbo Rx ring */</a>
<a name="ln2179">	error = bus_dmamem_alloc(sc_if-&gt;sk_cdata.sk_jumbo_rx_ring_tag,</a>
<a name="ln2180">	    (void **)&amp;sc_if-&gt;sk_rdata.sk_jumbo_rx_ring, BUS_DMA_NOWAIT |</a>
<a name="ln2181">	    BUS_DMA_COHERENT | BUS_DMA_ZERO,</a>
<a name="ln2182">	    &amp;sc_if-&gt;sk_cdata.sk_jumbo_rx_ring_map);</a>
<a name="ln2183">	if (error != 0) {</a>
<a name="ln2184">		device_printf(sc_if-&gt;sk_if_dev,</a>
<a name="ln2185">		    &quot;failed to allocate DMA'able memory for jumbo Rx ring\n&quot;);</a>
<a name="ln2186">		goto jumbo_fail;</a>
<a name="ln2187">	}</a>
<a name="ln2188"> </a>
<a name="ln2189">	ctx.sk_busaddr = 0;</a>
<a name="ln2190">	error = bus_dmamap_load(sc_if-&gt;sk_cdata.sk_jumbo_rx_ring_tag,</a>
<a name="ln2191">	    sc_if-&gt;sk_cdata.sk_jumbo_rx_ring_map,</a>
<a name="ln2192">	    sc_if-&gt;sk_rdata.sk_jumbo_rx_ring, SK_JUMBO_RX_RING_SZ, sk_dmamap_cb,</a>
<a name="ln2193">	    &amp;ctx, BUS_DMA_NOWAIT);</a>
<a name="ln2194">	if (error != 0) {</a>
<a name="ln2195">		device_printf(sc_if-&gt;sk_if_dev,</a>
<a name="ln2196">		    &quot;failed to load DMA'able memory for jumbo Rx ring\n&quot;);</a>
<a name="ln2197">		goto jumbo_fail;</a>
<a name="ln2198">	}</a>
<a name="ln2199">	sc_if-&gt;sk_rdata.sk_jumbo_rx_ring_paddr = ctx.sk_busaddr;</a>
<a name="ln2200"> </a>
<a name="ln2201">	/* create DMA maps for jumbo Rx buffers */</a>
<a name="ln2202">	if ((error = bus_dmamap_create(sc_if-&gt;sk_cdata.sk_jumbo_rx_tag, 0,</a>
<a name="ln2203">	    &amp;sc_if-&gt;sk_cdata.sk_jumbo_rx_sparemap)) != 0) {</a>
<a name="ln2204">		device_printf(sc_if-&gt;sk_if_dev,</a>
<a name="ln2205">		    &quot;failed to create spare jumbo Rx dmamap\n&quot;);</a>
<a name="ln2206">		goto jumbo_fail;</a>
<a name="ln2207">	}</a>
<a name="ln2208">	for (i = 0; i &lt; SK_JUMBO_RX_RING_CNT; i++) {</a>
<a name="ln2209">		jrxd = &amp;sc_if-&gt;sk_cdata.sk_jumbo_rxdesc[i];</a>
<a name="ln2210">		jrxd-&gt;rx_m = NULL;</a>
<a name="ln2211">		jrxd-&gt;rx_dmamap = NULL;</a>
<a name="ln2212">		error = bus_dmamap_create(sc_if-&gt;sk_cdata.sk_jumbo_rx_tag, 0,</a>
<a name="ln2213">		    &amp;jrxd-&gt;rx_dmamap);</a>
<a name="ln2214">		if (error != 0) {</a>
<a name="ln2215">			device_printf(sc_if-&gt;sk_if_dev,</a>
<a name="ln2216">			    &quot;failed to create jumbo Rx dmamap\n&quot;);</a>
<a name="ln2217">			goto jumbo_fail;</a>
<a name="ln2218">		}</a>
<a name="ln2219">	}</a>
<a name="ln2220"> </a>
<a name="ln2221">	return (0);</a>
<a name="ln2222"> </a>
<a name="ln2223">jumbo_fail:</a>
<a name="ln2224">	sk_dma_jumbo_free(sc_if);</a>
<a name="ln2225">	device_printf(sc_if-&gt;sk_if_dev, &quot;disabling jumbo frame support due to &quot;</a>
<a name="ln2226">	    &quot;resource shortage\n&quot;);</a>
<a name="ln2227">	sc_if-&gt;sk_jumbo_disable = 1;</a>
<a name="ln2228">	return (0);</a>
<a name="ln2229">}</a>
<a name="ln2230"> </a>
<a name="ln2231">static void</a>
<a name="ln2232">sk_dma_free(sc_if)</a>
<a name="ln2233">	struct sk_if_softc	*sc_if;</a>
<a name="ln2234">{</a>
<a name="ln2235">	struct sk_txdesc	*txd;</a>
<a name="ln2236">	struct sk_rxdesc	*rxd;</a>
<a name="ln2237">	int			i;</a>
<a name="ln2238"> </a>
<a name="ln2239">	/* Tx ring */</a>
<a name="ln2240">	if (sc_if-&gt;sk_cdata.sk_tx_ring_tag) {</a>
<a name="ln2241">		if (sc_if-&gt;sk_rdata.sk_tx_ring_paddr)</a>
<a name="ln2242">			bus_dmamap_unload(sc_if-&gt;sk_cdata.sk_tx_ring_tag,</a>
<a name="ln2243">			    sc_if-&gt;sk_cdata.sk_tx_ring_map);</a>
<a name="ln2244">		if (sc_if-&gt;sk_rdata.sk_tx_ring)</a>
<a name="ln2245">			bus_dmamem_free(sc_if-&gt;sk_cdata.sk_tx_ring_tag,</a>
<a name="ln2246">			    sc_if-&gt;sk_rdata.sk_tx_ring,</a>
<a name="ln2247">			    sc_if-&gt;sk_cdata.sk_tx_ring_map);</a>
<a name="ln2248">		sc_if-&gt;sk_rdata.sk_tx_ring = NULL;</a>
<a name="ln2249">		sc_if-&gt;sk_rdata.sk_tx_ring_paddr = 0;</a>
<a name="ln2250">		bus_dma_tag_destroy(sc_if-&gt;sk_cdata.sk_tx_ring_tag);</a>
<a name="ln2251">		sc_if-&gt;sk_cdata.sk_tx_ring_tag = NULL;</a>
<a name="ln2252">	}</a>
<a name="ln2253">	/* Rx ring */</a>
<a name="ln2254">	if (sc_if-&gt;sk_cdata.sk_rx_ring_tag) {</a>
<a name="ln2255">		if (sc_if-&gt;sk_rdata.sk_rx_ring_paddr)</a>
<a name="ln2256">			bus_dmamap_unload(sc_if-&gt;sk_cdata.sk_rx_ring_tag,</a>
<a name="ln2257">			    sc_if-&gt;sk_cdata.sk_rx_ring_map);</a>
<a name="ln2258">		if (sc_if-&gt;sk_rdata.sk_rx_ring)</a>
<a name="ln2259">			bus_dmamem_free(sc_if-&gt;sk_cdata.sk_rx_ring_tag,</a>
<a name="ln2260">			    sc_if-&gt;sk_rdata.sk_rx_ring,</a>
<a name="ln2261">			    sc_if-&gt;sk_cdata.sk_rx_ring_map);</a>
<a name="ln2262">		sc_if-&gt;sk_rdata.sk_rx_ring = NULL;</a>
<a name="ln2263">		sc_if-&gt;sk_rdata.sk_rx_ring_paddr = 0;</a>
<a name="ln2264">		bus_dma_tag_destroy(sc_if-&gt;sk_cdata.sk_rx_ring_tag);</a>
<a name="ln2265">		sc_if-&gt;sk_cdata.sk_rx_ring_tag = NULL;</a>
<a name="ln2266">	}</a>
<a name="ln2267">	/* Tx buffers */</a>
<a name="ln2268">	if (sc_if-&gt;sk_cdata.sk_tx_tag) {</a>
<a name="ln2269">		for (i = 0; i &lt; SK_TX_RING_CNT; i++) {</a>
<a name="ln2270">			txd = &amp;sc_if-&gt;sk_cdata.sk_txdesc[i];</a>
<a name="ln2271">			if (txd-&gt;tx_dmamap) {</a>
<a name="ln2272">				bus_dmamap_destroy(sc_if-&gt;sk_cdata.sk_tx_tag,</a>
<a name="ln2273">				    txd-&gt;tx_dmamap);</a>
<a name="ln2274">				txd-&gt;tx_dmamap = NULL;</a>
<a name="ln2275">			}</a>
<a name="ln2276">		}</a>
<a name="ln2277">		bus_dma_tag_destroy(sc_if-&gt;sk_cdata.sk_tx_tag);</a>
<a name="ln2278">		sc_if-&gt;sk_cdata.sk_tx_tag = NULL;</a>
<a name="ln2279">	}</a>
<a name="ln2280">	/* Rx buffers */</a>
<a name="ln2281">	if (sc_if-&gt;sk_cdata.sk_rx_tag) {</a>
<a name="ln2282">		for (i = 0; i &lt; SK_RX_RING_CNT; i++) {</a>
<a name="ln2283">			rxd = &amp;sc_if-&gt;sk_cdata.sk_rxdesc[i];</a>
<a name="ln2284">			if (rxd-&gt;rx_dmamap) {</a>
<a name="ln2285">				bus_dmamap_destroy(sc_if-&gt;sk_cdata.sk_rx_tag,</a>
<a name="ln2286">				    rxd-&gt;rx_dmamap);</a>
<a name="ln2287">				rxd-&gt;rx_dmamap = NULL;</a>
<a name="ln2288">			}</a>
<a name="ln2289">		}</a>
<a name="ln2290">		if (sc_if-&gt;sk_cdata.sk_rx_sparemap) {</a>
<a name="ln2291">			bus_dmamap_destroy(sc_if-&gt;sk_cdata.sk_rx_tag,</a>
<a name="ln2292">			    sc_if-&gt;sk_cdata.sk_rx_sparemap);</a>
<a name="ln2293">			sc_if-&gt;sk_cdata.sk_rx_sparemap = NULL;</a>
<a name="ln2294">		}</a>
<a name="ln2295">		bus_dma_tag_destroy(sc_if-&gt;sk_cdata.sk_rx_tag);</a>
<a name="ln2296">		sc_if-&gt;sk_cdata.sk_rx_tag = NULL;</a>
<a name="ln2297">	}</a>
<a name="ln2298"> </a>
<a name="ln2299">	if (sc_if-&gt;sk_cdata.sk_parent_tag) {</a>
<a name="ln2300">		bus_dma_tag_destroy(sc_if-&gt;sk_cdata.sk_parent_tag);</a>
<a name="ln2301">		sc_if-&gt;sk_cdata.sk_parent_tag = NULL;</a>
<a name="ln2302">	}</a>
<a name="ln2303">}</a>
<a name="ln2304"> </a>
<a name="ln2305">static void</a>
<a name="ln2306">sk_dma_jumbo_free(sc_if)</a>
<a name="ln2307">	struct sk_if_softc	*sc_if;</a>
<a name="ln2308">{</a>
<a name="ln2309">	struct sk_rxdesc	*jrxd;</a>
<a name="ln2310">	int			i;</a>
<a name="ln2311"> </a>
<a name="ln2312">	/* jumbo Rx ring */</a>
<a name="ln2313">	if (sc_if-&gt;sk_cdata.sk_jumbo_rx_ring_tag) {</a>
<a name="ln2314">		if (sc_if-&gt;sk_rdata.sk_jumbo_rx_ring_paddr)</a>
<a name="ln2315">			bus_dmamap_unload(sc_if-&gt;sk_cdata.sk_jumbo_rx_ring_tag,</a>
<a name="ln2316">			    sc_if-&gt;sk_cdata.sk_jumbo_rx_ring_map);</a>
<a name="ln2317">		if (sc_if-&gt;sk_rdata.sk_jumbo_rx_ring)</a>
<a name="ln2318">			bus_dmamem_free(sc_if-&gt;sk_cdata.sk_jumbo_rx_ring_tag,</a>
<a name="ln2319">			    sc_if-&gt;sk_rdata.sk_jumbo_rx_ring,</a>
<a name="ln2320">			    sc_if-&gt;sk_cdata.sk_jumbo_rx_ring_map);</a>
<a name="ln2321">		sc_if-&gt;sk_rdata.sk_jumbo_rx_ring = NULL;</a>
<a name="ln2322">		sc_if-&gt;sk_rdata.sk_jumbo_rx_ring_paddr = 0;</a>
<a name="ln2323">		bus_dma_tag_destroy(sc_if-&gt;sk_cdata.sk_jumbo_rx_ring_tag);</a>
<a name="ln2324">		sc_if-&gt;sk_cdata.sk_jumbo_rx_ring_tag = NULL;</a>
<a name="ln2325">	}</a>
<a name="ln2326"> </a>
<a name="ln2327">	/* jumbo Rx buffers */</a>
<a name="ln2328">	if (sc_if-&gt;sk_cdata.sk_jumbo_rx_tag) {</a>
<a name="ln2329">		for (i = 0; i &lt; SK_JUMBO_RX_RING_CNT; i++) {</a>
<a name="ln2330">			jrxd = &amp;sc_if-&gt;sk_cdata.sk_jumbo_rxdesc[i];</a>
<a name="ln2331">			if (jrxd-&gt;rx_dmamap) {</a>
<a name="ln2332">				bus_dmamap_destroy(</a>
<a name="ln2333">				    sc_if-&gt;sk_cdata.sk_jumbo_rx_tag,</a>
<a name="ln2334">				    jrxd-&gt;rx_dmamap);</a>
<a name="ln2335">				jrxd-&gt;rx_dmamap = NULL;</a>
<a name="ln2336">			}</a>
<a name="ln2337">		}</a>
<a name="ln2338">		if (sc_if-&gt;sk_cdata.sk_jumbo_rx_sparemap) {</a>
<a name="ln2339">			bus_dmamap_destroy(sc_if-&gt;sk_cdata.sk_jumbo_rx_tag,</a>
<a name="ln2340">			    sc_if-&gt;sk_cdata.sk_jumbo_rx_sparemap);</a>
<a name="ln2341">			sc_if-&gt;sk_cdata.sk_jumbo_rx_sparemap = NULL;</a>
<a name="ln2342">		}</a>
<a name="ln2343">		bus_dma_tag_destroy(sc_if-&gt;sk_cdata.sk_jumbo_rx_tag);</a>
<a name="ln2344">		sc_if-&gt;sk_cdata.sk_jumbo_rx_tag = NULL;</a>
<a name="ln2345">	}</a>
<a name="ln2346">}</a>
<a name="ln2347"> </a>
<a name="ln2348">static void</a>
<a name="ln2349">sk_txcksum(ifp, m, f)</a>
<a name="ln2350">	struct ifnet		*ifp;</a>
<a name="ln2351">	struct mbuf		*m;</a>
<a name="ln2352">	struct sk_tx_desc	*f;</a>
<a name="ln2353">{</a>
<a name="ln2354">	struct ip		*ip;</a>
<a name="ln2355">	u_int16_t		offset;</a>
<a name="ln2356">	u_int8_t 		*p;</a>
<a name="ln2357"> </a>
<a name="ln2358">	offset = sizeof(struct ip) + ETHER_HDR_LEN;</a>
<a name="ln2359">	for(; m &amp;&amp; m-&gt;m_len == 0; m = m-&gt;m_next)</a>
<a name="ln2360">		;</a>
<a name="ln2361">	if (m == NULL || m-&gt;m_len &lt; ETHER_HDR_LEN) {</a>
<a name="ln2362">		if_printf(ifp, &quot;%s: m_len &lt; ETHER_HDR_LEN\n&quot;, __func__);</a>
<a name="ln2363">		/* checksum may be corrupted */</a>
<a name="ln2364">		goto sendit;</a>
<a name="ln2365">	}</a>
<a name="ln2366">	if (m-&gt;m_len &lt; ETHER_HDR_LEN + sizeof(u_int32_t)) {</a>
<a name="ln2367">		if (m-&gt;m_len != ETHER_HDR_LEN) {</a>
<a name="ln2368">			if_printf(ifp, &quot;%s: m_len != ETHER_HDR_LEN\n&quot;,</a>
<a name="ln2369">			    __func__);</a>
<a name="ln2370">			/* checksum may be corrupted */</a>
<a name="ln2371">			goto sendit;</a>
<a name="ln2372">		}</a>
<a name="ln2373">		for(m = m-&gt;m_next; m &amp;&amp; m-&gt;m_len == 0; m = m-&gt;m_next)</a>
<a name="ln2374">			;</a>
<a name="ln2375">		if (m == NULL) {</a>
<a name="ln2376">			offset = sizeof(struct ip) + ETHER_HDR_LEN;</a>
<a name="ln2377">			/* checksum may be corrupted */</a>
<a name="ln2378">			goto sendit;</a>
<a name="ln2379">		}</a>
<a name="ln2380">		ip = mtod(m, struct ip *);</a>
<a name="ln2381">	} else {</a>
<a name="ln2382">		p = mtod(m, u_int8_t *);</a>
<a name="ln2383">		p += ETHER_HDR_LEN;</a>
<a name="ln2384">		ip = (struct ip *)p;</a>
<a name="ln2385">	}</a>
<a name="ln2386">	offset = (ip-&gt;ip_hl &lt;&lt; 2) + ETHER_HDR_LEN;</a>
<a name="ln2387"> </a>
<a name="ln2388">sendit:</a>
<a name="ln2389">	f-&gt;sk_csum_startval = 0;</a>
<a name="ln2390">	f-&gt;sk_csum_start = htole32(((offset + m-&gt;m_pkthdr.csum_data) &amp; 0xffff) |</a>
<a name="ln2391">	    (offset &lt;&lt; 16));</a>
<a name="ln2392">}</a>
<a name="ln2393"> </a>
<a name="ln2394">static int</a>
<a name="ln2395">sk_encap(sc_if, m_head)</a>
<a name="ln2396">        struct sk_if_softc	*sc_if;</a>
<a name="ln2397">        struct mbuf		**m_head;</a>
<a name="ln2398">{</a>
<a name="ln2399">	struct sk_txdesc	*txd;</a>
<a name="ln2400">	struct sk_tx_desc	*f = NULL;</a>
<a name="ln2401">	struct mbuf		*m;</a>
<a name="ln2402">	bus_dma_segment_t	txsegs[SK_MAXTXSEGS];</a>
<a name="ln2403">	u_int32_t		cflags, frag, si, sk_ctl;</a>
<a name="ln2404">	int			error, i, nseg;</a>
<a name="ln2405"> </a>
<a name="ln2406">	SK_IF_LOCK_ASSERT(sc_if);</a>
<a name="ln2407"> </a>
<a name="ln2408">	if ((txd = STAILQ_FIRST(&amp;sc_if-&gt;sk_cdata.sk_txfreeq)) == NULL)</a>
<a name="ln2409">		return (ENOBUFS);</a>
<a name="ln2410"> </a>
<a name="ln2411">	error = bus_dmamap_load_mbuf_sg(sc_if-&gt;sk_cdata.sk_tx_tag,</a>
<a name="ln2412">	    txd-&gt;tx_dmamap, *m_head, txsegs, &amp;nseg, 0);</a>
<a name="ln2413">	if (error == EFBIG) {</a>
<a name="ln2414">		m = m_defrag(*m_head, M_NOWAIT);</a>
<a name="ln2415">		if (m == NULL) {</a>
<a name="ln2416">			m_freem(*m_head);</a>
<a name="ln2417">			*m_head = NULL;</a>
<a name="ln2418">			return (ENOMEM);</a>
<a name="ln2419">		}</a>
<a name="ln2420">		*m_head = m;</a>
<a name="ln2421">		error = bus_dmamap_load_mbuf_sg(sc_if-&gt;sk_cdata.sk_tx_tag,</a>
<a name="ln2422">		    txd-&gt;tx_dmamap, *m_head, txsegs, &amp;nseg, 0);</a>
<a name="ln2423">		if (error != 0) {</a>
<a name="ln2424">			m_freem(*m_head);</a>
<a name="ln2425">			*m_head = NULL;</a>
<a name="ln2426">			return (error);</a>
<a name="ln2427">		}</a>
<a name="ln2428">	} else if (error != 0)</a>
<a name="ln2429">		return (error);</a>
<a name="ln2430">	if (nseg == 0) {</a>
<a name="ln2431">		m_freem(*m_head);</a>
<a name="ln2432">		*m_head = NULL;</a>
<a name="ln2433">		return (EIO);</a>
<a name="ln2434">	}</a>
<a name="ln2435">	if (sc_if-&gt;sk_cdata.sk_tx_cnt + nseg &gt;= SK_TX_RING_CNT) {</a>
<a name="ln2436">		bus_dmamap_unload(sc_if-&gt;sk_cdata.sk_tx_tag, txd-&gt;tx_dmamap);</a>
<a name="ln2437">		return (ENOBUFS);</a>
<a name="ln2438">	}</a>
<a name="ln2439"> </a>
<a name="ln2440">	m = *m_head;</a>
<a name="ln2441">	if ((m-&gt;m_pkthdr.csum_flags &amp; sc_if-&gt;sk_ifp-&gt;if_hwassist) != 0)</a>
<a name="ln2442">		cflags = SK_OPCODE_CSUM;</a>
<a name="ln2443">	else</a>
<a name="ln2444">		cflags = SK_OPCODE_DEFAULT;</a>
<a name="ln2445">	si = frag = sc_if-&gt;sk_cdata.sk_tx_prod;</a>
<a name="ln2446">	for (i = 0; i &lt; nseg; i++) {</a>
<a name="ln2447">		f = &amp;sc_if-&gt;sk_rdata.sk_tx_ring[frag];</a>
<a name="ln2448">		f-&gt;sk_data_lo = htole32(SK_ADDR_LO(txsegs[i].ds_addr));</a>
<a name="ln2449">		f-&gt;sk_data_hi = htole32(SK_ADDR_HI(txsegs[i].ds_addr));</a>
<a name="ln2450">		sk_ctl = txsegs[i].ds_len | cflags;</a>
<a name="ln2451">		if (i == 0) {</a>
<a name="ln2452">			if (cflags == SK_OPCODE_CSUM)</a>
<a name="ln2453">				sk_txcksum(sc_if-&gt;sk_ifp, m, f);</a>
<a name="ln2454">			sk_ctl |= SK_TXCTL_FIRSTFRAG;</a>
<a name="ln2455">		} else</a>
<a name="ln2456">			sk_ctl |= SK_TXCTL_OWN;</a>
<a name="ln2457">		f-&gt;sk_ctl = htole32(sk_ctl);</a>
<a name="ln2458">		sc_if-&gt;sk_cdata.sk_tx_cnt++;</a>
<a name="ln2459">		SK_INC(frag, SK_TX_RING_CNT);</a>
<a name="ln2460">	}</a>
<a name="ln2461">	sc_if-&gt;sk_cdata.sk_tx_prod = frag;</a>
<a name="ln2462"> </a>
<a name="ln2463">	/* set EOF on the last desciptor */</a>
<a name="ln2464">	frag = (frag + SK_TX_RING_CNT - 1) % SK_TX_RING_CNT;</a>
<a name="ln2465">	f = &amp;sc_if-&gt;sk_rdata.sk_tx_ring[frag];</a>
<a name="ln2466">	f-&gt;sk_ctl |= htole32(SK_TXCTL_LASTFRAG | SK_TXCTL_EOF_INTR);</a>
<a name="ln2467"> </a>
<a name="ln2468">	/* turn the first descriptor ownership to NIC */</a>
<a name="ln2469">	f = &amp;sc_if-&gt;sk_rdata.sk_tx_ring[si];</a>
<a name="ln2470">	f-&gt;sk_ctl |= htole32(SK_TXCTL_OWN);</a>
<a name="ln2471"> </a>
<a name="ln2472">	STAILQ_REMOVE_HEAD(&amp;sc_if-&gt;sk_cdata.sk_txfreeq, tx_q);</a>
<a name="ln2473">	STAILQ_INSERT_TAIL(&amp;sc_if-&gt;sk_cdata.sk_txbusyq, txd, tx_q);</a>
<a name="ln2474">	txd-&gt;tx_m = m;</a>
<a name="ln2475"> </a>
<a name="ln2476">	/* sync descriptors */</a>
<a name="ln2477">	bus_dmamap_sync(sc_if-&gt;sk_cdata.sk_tx_tag, txd-&gt;tx_dmamap,</a>
<a name="ln2478">	    BUS_DMASYNC_PREWRITE);</a>
<a name="ln2479">	bus_dmamap_sync(sc_if-&gt;sk_cdata.sk_tx_ring_tag,</a>
<a name="ln2480">	    sc_if-&gt;sk_cdata.sk_tx_ring_map,</a>
<a name="ln2481">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln2482"> </a>
<a name="ln2483">	return (0);</a>
<a name="ln2484">}</a>
<a name="ln2485"> </a>
<a name="ln2486">static void</a>
<a name="ln2487">sk_start(ifp)</a>
<a name="ln2488">	struct ifnet		*ifp;</a>
<a name="ln2489">{</a>
<a name="ln2490">	struct sk_if_softc *sc_if;</a>
<a name="ln2491"> </a>
<a name="ln2492">	sc_if = ifp-&gt;if_softc;</a>
<a name="ln2493"> </a>
<a name="ln2494">	SK_IF_LOCK(sc_if);</a>
<a name="ln2495">	sk_start_locked(ifp);</a>
<a name="ln2496">	SK_IF_UNLOCK(sc_if);</a>
<a name="ln2497"> </a>
<a name="ln2498">	return;</a>
<a name="ln2499">}</a>
<a name="ln2500"> </a>
<a name="ln2501">static void</a>
<a name="ln2502">sk_start_locked(ifp)</a>
<a name="ln2503">	struct ifnet		*ifp;</a>
<a name="ln2504">{</a>
<a name="ln2505">        struct sk_softc		*sc;</a>
<a name="ln2506">        struct sk_if_softc	*sc_if;</a>
<a name="ln2507">        struct mbuf		*m_head;</a>
<a name="ln2508">	int			enq;</a>
<a name="ln2509"> </a>
<a name="ln2510">	sc_if = ifp-&gt;if_softc;</a>
<a name="ln2511">	sc = sc_if-&gt;sk_softc;</a>
<a name="ln2512"> </a>
<a name="ln2513">	SK_IF_LOCK_ASSERT(sc_if);</a>
<a name="ln2514"> </a>
<a name="ln2515">	for (enq = 0; !IFQ_DRV_IS_EMPTY(&amp;ifp-&gt;if_snd) &amp;&amp;</a>
<a name="ln2516">	    sc_if-&gt;sk_cdata.sk_tx_cnt &lt; SK_TX_RING_CNT - 1; ) {</a>
<a name="ln2517">		IFQ_DRV_DEQUEUE(&amp;ifp-&gt;if_snd, m_head);</a>
<a name="ln2518">		if (m_head == NULL)</a>
<a name="ln2519">			break;</a>
<a name="ln2520"> </a>
<a name="ln2521">		/*</a>
<a name="ln2522">		 * Pack the data into the transmit ring. If we</a>
<a name="ln2523">		 * don't have room, set the OACTIVE flag and wait</a>
<a name="ln2524">		 * for the NIC to drain the ring.</a>
<a name="ln2525">		 */</a>
<a name="ln2526">		if (sk_encap(sc_if, &amp;m_head)) {</a>
<a name="ln2527">			if (m_head == NULL)</a>
<a name="ln2528">				break;</a>
<a name="ln2529">			IFQ_DRV_PREPEND(&amp;ifp-&gt;if_snd, m_head);</a>
<a name="ln2530">			ifp-&gt;if_drv_flags |= IFF_DRV_OACTIVE;</a>
<a name="ln2531">			break;</a>
<a name="ln2532">		}</a>
<a name="ln2533"> </a>
<a name="ln2534">		enq++;</a>
<a name="ln2535">		/*</a>
<a name="ln2536">		 * If there's a BPF listener, bounce a copy of this frame</a>
<a name="ln2537">		 * to him.</a>
<a name="ln2538">		 */</a>
<a name="ln2539">		BPF_MTAP(ifp, m_head);</a>
<a name="ln2540">	}</a>
<a name="ln2541"> </a>
<a name="ln2542">	if (enq &gt; 0) {</a>
<a name="ln2543">		/* Transmit */</a>
<a name="ln2544">		CSR_WRITE_4(sc, sc_if-&gt;sk_tx_bmu, SK_TXBMU_TX_START);</a>
<a name="ln2545"> </a>
<a name="ln2546">		/* Set a timeout in case the chip goes out to lunch. */</a>
<a name="ln2547">		sc_if-&gt;sk_watchdog_timer = 5;</a>
<a name="ln2548">	}</a>
<a name="ln2549">}</a>
<a name="ln2550"> </a>
<a name="ln2551"> </a>
<a name="ln2552">static void</a>
<a name="ln2553">sk_watchdog(arg)</a>
<a name="ln2554">	void			*arg;</a>
<a name="ln2555">{</a>
<a name="ln2556">	struct sk_if_softc	*sc_if;</a>
<a name="ln2557">	struct ifnet		*ifp;</a>
<a name="ln2558"> </a>
<a name="ln2559">	ifp = arg;</a>
<a name="ln2560">	sc_if = ifp-&gt;if_softc;</a>
<a name="ln2561"> </a>
<a name="ln2562">	SK_IF_LOCK_ASSERT(sc_if);</a>
<a name="ln2563"> </a>
<a name="ln2564">	if (sc_if-&gt;sk_watchdog_timer == 0 || --sc_if-&gt;sk_watchdog_timer)</a>
<a name="ln2565">		goto done;</a>
<a name="ln2566"> </a>
<a name="ln2567">	/*</a>
<a name="ln2568">	 * Reclaim first as there is a possibility of losing Tx completion</a>
<a name="ln2569">	 * interrupts.</a>
<a name="ln2570">	 */</a>
<a name="ln2571">	sk_txeof(sc_if);</a>
<a name="ln2572">	if (sc_if-&gt;sk_cdata.sk_tx_cnt != 0) {</a>
<a name="ln2573">		if_printf(sc_if-&gt;sk_ifp, &quot;watchdog timeout\n&quot;);</a>
<a name="ln2574">		if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln2575">		ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_RUNNING;</a>
<a name="ln2576">		sk_init_locked(sc_if);</a>
<a name="ln2577">	}</a>
<a name="ln2578"> </a>
<a name="ln2579">done:</a>
<a name="ln2580">	callout_reset(&amp;sc_if-&gt;sk_watchdog_ch, hz, sk_watchdog, ifp);</a>
<a name="ln2581"> </a>
<a name="ln2582">	return;</a>
<a name="ln2583">}</a>
<a name="ln2584"> </a>
<a name="ln2585">static int</a>
<a name="ln2586">skc_shutdown(dev)</a>
<a name="ln2587">	device_t		dev;</a>
<a name="ln2588">{</a>
<a name="ln2589">	struct sk_softc		*sc;</a>
<a name="ln2590"> </a>
<a name="ln2591">	sc = device_get_softc(dev);</a>
<a name="ln2592">	SK_LOCK(sc);</a>
<a name="ln2593"> </a>
<a name="ln2594">	/* Turn off the 'driver is loaded' LED. */</a>
<a name="ln2595">	CSR_WRITE_2(sc, SK_LED, SK_LED_GREEN_OFF);</a>
<a name="ln2596"> </a>
<a name="ln2597">	/*</a>
<a name="ln2598">	 * Reset the GEnesis controller. Doing this should also</a>
<a name="ln2599">	 * assert the resets on the attached XMAC(s).</a>
<a name="ln2600">	 */</a>
<a name="ln2601">	sk_reset(sc);</a>
<a name="ln2602">	SK_UNLOCK(sc);</a>
<a name="ln2603"> </a>
<a name="ln2604">	return (0);</a>
<a name="ln2605">}</a>
<a name="ln2606"> </a>
<a name="ln2607">static int</a>
<a name="ln2608">skc_suspend(dev)</a>
<a name="ln2609">	device_t		dev;</a>
<a name="ln2610">{</a>
<a name="ln2611">	struct sk_softc		*sc;</a>
<a name="ln2612">	struct sk_if_softc	*sc_if0, *sc_if1;</a>
<a name="ln2613">	struct ifnet		*ifp0 = NULL, *ifp1 = NULL;</a>
<a name="ln2614"> </a>
<a name="ln2615">	sc = device_get_softc(dev);</a>
<a name="ln2616"> </a>
<a name="ln2617">	SK_LOCK(sc);</a>
<a name="ln2618"> </a>
<a name="ln2619">	sc_if0 = sc-&gt;sk_if[SK_PORT_A];</a>
<a name="ln2620">	sc_if1 = sc-&gt;sk_if[SK_PORT_B];</a>
<a name="ln2621">	if (sc_if0 != NULL)</a>
<a name="ln2622">		ifp0 = sc_if0-&gt;sk_ifp;</a>
<a name="ln2623">	if (sc_if1 != NULL)</a>
<a name="ln2624">		ifp1 = sc_if1-&gt;sk_ifp;</a>
<a name="ln2625">	if (ifp0 != NULL)</a>
<a name="ln2626">		sk_stop(sc_if0);</a>
<a name="ln2627">	if (ifp1 != NULL)</a>
<a name="ln2628">		sk_stop(sc_if1);</a>
<a name="ln2629">	sc-&gt;sk_suspended = 1;</a>
<a name="ln2630"> </a>
<a name="ln2631">	SK_UNLOCK(sc);</a>
<a name="ln2632"> </a>
<a name="ln2633">	return (0);</a>
<a name="ln2634">}</a>
<a name="ln2635"> </a>
<a name="ln2636">static int</a>
<a name="ln2637">skc_resume(dev)</a>
<a name="ln2638">	device_t		dev;</a>
<a name="ln2639">{</a>
<a name="ln2640">	struct sk_softc		*sc;</a>
<a name="ln2641">	struct sk_if_softc	*sc_if0, *sc_if1;</a>
<a name="ln2642">	struct ifnet		*ifp0 = NULL, *ifp1 = NULL;</a>
<a name="ln2643"> </a>
<a name="ln2644">	sc = device_get_softc(dev);</a>
<a name="ln2645"> </a>
<a name="ln2646">	SK_LOCK(sc);</a>
<a name="ln2647"> </a>
<a name="ln2648">	sc_if0 = sc-&gt;sk_if[SK_PORT_A];</a>
<a name="ln2649">	sc_if1 = sc-&gt;sk_if[SK_PORT_B];</a>
<a name="ln2650">	if (sc_if0 != NULL)</a>
<a name="ln2651">		ifp0 = sc_if0-&gt;sk_ifp;</a>
<a name="ln2652">	if (sc_if1 != NULL)</a>
<a name="ln2653">		ifp1 = sc_if1-&gt;sk_ifp;</a>
<a name="ln2654">	if (ifp0 != NULL &amp;&amp; ifp0-&gt;if_flags &amp; IFF_UP)</a>
<a name="ln2655">		sk_init_locked(sc_if0);</a>
<a name="ln2656">	if (ifp1 != NULL &amp;&amp; ifp1-&gt;if_flags &amp; IFF_UP)</a>
<a name="ln2657">		sk_init_locked(sc_if1);</a>
<a name="ln2658">	sc-&gt;sk_suspended = 0;</a>
<a name="ln2659"> </a>
<a name="ln2660">	SK_UNLOCK(sc);</a>
<a name="ln2661"> </a>
<a name="ln2662">	return (0);</a>
<a name="ln2663">}</a>
<a name="ln2664"> </a>
<a name="ln2665">/*</a>
<a name="ln2666"> * According to the data sheet from SK-NET GENESIS the hardware can compute</a>
<a name="ln2667"> * two Rx checksums at the same time(Each checksum start position is</a>
<a name="ln2668"> * programmed in Rx descriptors). However it seems that TCP/UDP checksum</a>
<a name="ln2669"> * does not work at least on my Yukon hardware. I tried every possible ways</a>
<a name="ln2670"> * to get correct checksum value but couldn't get correct one. So TCP/UDP</a>
<a name="ln2671"> * checksum offload was disabled at the moment and only IP checksum offload</a>
<a name="ln2672"> * was enabled.</a>
<a name="ln2673"> * As nomral IP header size is 20 bytes I can't expect it would give an</a>
<a name="ln2674"> * increase in throughput. However it seems it doesn't hurt performance in</a>
<a name="ln2675"> * my testing. If there is a more detailed information for checksum secret</a>
<a name="ln2676"> * of the hardware in question please contact yongari@FreeBSD.org to add</a>
<a name="ln2677"> * TCP/UDP checksum offload support.</a>
<a name="ln2678"> */</a>
<a name="ln2679">static __inline void</a>
<a name="ln2680">sk_rxcksum(ifp, m, csum)</a>
<a name="ln2681">	struct ifnet		*ifp;</a>
<a name="ln2682">	struct mbuf		*m;</a>
<a name="ln2683">	u_int32_t		csum;</a>
<a name="ln2684">{</a>
<a name="ln2685">	struct ether_header	*eh;</a>
<a name="ln2686">	struct ip		*ip;</a>
<a name="ln2687">	int32_t			hlen, len, pktlen;</a>
<a name="ln2688">	u_int16_t		csum1, csum2, ipcsum;</a>
<a name="ln2689"> </a>
<a name="ln2690">	pktlen = m-&gt;m_pkthdr.len;</a>
<a name="ln2691">	if (pktlen &lt; sizeof(struct ether_header) + sizeof(struct ip))</a>
<a name="ln2692">		return;</a>
<a name="ln2693">	eh = mtod(m, struct ether_header *);</a>
<a name="ln2694">	if (eh-&gt;ether_type != htons(ETHERTYPE_IP))</a>
<a name="ln2695">		return;</a>
<a name="ln2696">	ip = (struct ip *)(eh + 1);</a>
<a name="ln2697">	if (ip-&gt;ip_v != IPVERSION)</a>
<a name="ln2698">		return;</a>
<a name="ln2699">	hlen = ip-&gt;ip_hl &lt;&lt; 2;</a>
<a name="ln2700">	pktlen -= sizeof(struct ether_header);</a>
<a name="ln2701">	if (hlen &lt; sizeof(struct ip))</a>
<a name="ln2702">		return;</a>
<a name="ln2703">	if (ntohs(ip-&gt;ip_len) &lt; hlen)</a>
<a name="ln2704">		return;</a>
<a name="ln2705">	if (ntohs(ip-&gt;ip_len) != pktlen)</a>
<a name="ln2706">		return;</a>
<a name="ln2707"> </a>
<a name="ln2708">	csum1 = htons(csum &amp; 0xffff);</a>
<a name="ln2709">	csum2 = htons((csum &gt;&gt; 16) &amp; 0xffff);</a>
<a name="ln2710">	ipcsum = in_addword(csum1, ~csum2 &amp; 0xffff);</a>
<a name="ln2711">	/* checksum fixup for IP options */</a>
<a name="ln2712">	len = hlen - sizeof(struct ip);</a>
<a name="ln2713">	if (len &gt; 0) {</a>
<a name="ln2714">		/*</a>
<a name="ln2715">		 * If the second checksum value is correct we can compute IP</a>
<a name="ln2716">		 * checksum with simple math. Unfortunately the second checksum</a>
<a name="ln2717">		 * value is wrong so we can't verify the checksum from the</a>
<a name="ln2718">		 * value(It seems there is some magic here to get correct</a>
<a name="ln2719">		 * value). If the second checksum value is correct it also</a>
<a name="ln2720">		 * means we can get TCP/UDP checksum) here. However, it still</a>
<a name="ln2721">		 * needs pseudo header checksum calculation due to hardware</a>
<a name="ln2722">		 * limitations.</a>
<a name="ln2723">		 */</a>
<a name="ln2724">		return;</a>
<a name="ln2725">	}</a>
<a name="ln2726">	m-&gt;m_pkthdr.csum_flags = CSUM_IP_CHECKED;</a>
<a name="ln2727">	if (ipcsum == 0xffff)</a>
<a name="ln2728">		m-&gt;m_pkthdr.csum_flags |= CSUM_IP_VALID;</a>
<a name="ln2729">}</a>
<a name="ln2730"> </a>
<a name="ln2731">static __inline int</a>
<a name="ln2732">sk_rxvalid(sc, stat, len)</a>
<a name="ln2733">	struct sk_softc		*sc;</a>
<a name="ln2734">	u_int32_t		stat, len;</a>
<a name="ln2735">{</a>
<a name="ln2736"> </a>
<a name="ln2737">	if (sc-&gt;sk_type == SK_GENESIS) {</a>
<a name="ln2738">		if ((stat &amp; XM_RXSTAT_ERRFRAME) == XM_RXSTAT_ERRFRAME ||</a>
<a name="ln2739">		    XM_RXSTAT_BYTES(stat) != len)</a>
<a name="ln2740">			return (0);</a>
<a name="ln2741">	} else {</a>
<a name="ln2742">		if ((stat &amp; (YU_RXSTAT_CRCERR | YU_RXSTAT_LONGERR |</a>
<a name="ln2743">		    YU_RXSTAT_MIIERR | YU_RXSTAT_BADFC | YU_RXSTAT_GOODFC |</a>
<a name="ln2744">		    YU_RXSTAT_JABBER)) != 0 ||</a>
<a name="ln2745">		    (stat &amp; YU_RXSTAT_RXOK) != YU_RXSTAT_RXOK ||</a>
<a name="ln2746">		    YU_RXSTAT_BYTES(stat) != len)</a>
<a name="ln2747">			return (0);</a>
<a name="ln2748">	}</a>
<a name="ln2749"> </a>
<a name="ln2750">	return (1);</a>
<a name="ln2751">}</a>
<a name="ln2752"> </a>
<a name="ln2753">static void</a>
<a name="ln2754">sk_rxeof(sc_if)</a>
<a name="ln2755">	struct sk_if_softc	*sc_if;</a>
<a name="ln2756">{</a>
<a name="ln2757">	struct sk_softc		*sc;</a>
<a name="ln2758">	struct mbuf		*m;</a>
<a name="ln2759">	struct ifnet		*ifp;</a>
<a name="ln2760">	struct sk_rx_desc	*cur_rx;</a>
<a name="ln2761">	struct sk_rxdesc	*rxd;</a>
<a name="ln2762">	int			cons, prog;</a>
<a name="ln2763">	u_int32_t		csum, rxstat, sk_ctl;</a>
<a name="ln2764"> </a>
<a name="ln2765">	sc = sc_if-&gt;sk_softc;</a>
<a name="ln2766">	ifp = sc_if-&gt;sk_ifp;</a>
<a name="ln2767"> </a>
<a name="ln2768">	SK_IF_LOCK_ASSERT(sc_if);</a>
<a name="ln2769"> </a>
<a name="ln2770">	bus_dmamap_sync(sc_if-&gt;sk_cdata.sk_rx_ring_tag,</a>
<a name="ln2771">	    sc_if-&gt;sk_cdata.sk_rx_ring_map, BUS_DMASYNC_POSTREAD);</a>
<a name="ln2772"> </a>
<a name="ln2773">	prog = 0;</a>
<a name="ln2774">	for (cons = sc_if-&gt;sk_cdata.sk_rx_cons; prog &lt; SK_RX_RING_CNT;</a>
<a name="ln2775">	    prog++, SK_INC(cons, SK_RX_RING_CNT)) {</a>
<a name="ln2776">		cur_rx = &amp;sc_if-&gt;sk_rdata.sk_rx_ring[cons];</a>
<a name="ln2777">		sk_ctl = le32toh(cur_rx-&gt;sk_ctl);</a>
<a name="ln2778">		if ((sk_ctl &amp; SK_RXCTL_OWN) != 0)</a>
<a name="ln2779">			break;</a>
<a name="ln2780">		rxd = &amp;sc_if-&gt;sk_cdata.sk_rxdesc[cons];</a>
<a name="ln2781">		rxstat = le32toh(cur_rx-&gt;sk_xmac_rxstat);</a>
<a name="ln2782"> </a>
<a name="ln2783">		if ((sk_ctl &amp; (SK_RXCTL_STATUS_VALID | SK_RXCTL_FIRSTFRAG |</a>
<a name="ln2784">		    SK_RXCTL_LASTFRAG)) != (SK_RXCTL_STATUS_VALID |</a>
<a name="ln2785">		    SK_RXCTL_FIRSTFRAG | SK_RXCTL_LASTFRAG) ||</a>
<a name="ln2786">		    SK_RXBYTES(sk_ctl) &lt; SK_MIN_FRAMELEN ||</a>
<a name="ln2787">		    SK_RXBYTES(sk_ctl) &gt; SK_MAX_FRAMELEN ||</a>
<a name="ln2788">		    sk_rxvalid(sc, rxstat, SK_RXBYTES(sk_ctl)) == 0) {</a>
<a name="ln2789">			if_inc_counter(ifp, IFCOUNTER_IERRORS, 1);</a>
<a name="ln2790">			sk_discard_rxbuf(sc_if, cons);</a>
<a name="ln2791">			continue;</a>
<a name="ln2792">		}</a>
<a name="ln2793"> </a>
<a name="ln2794">		m = rxd-&gt;rx_m;</a>
<a name="ln2795">		csum = le32toh(cur_rx-&gt;sk_csum);</a>
<a name="ln2796">		if (sk_newbuf(sc_if, cons) != 0) {</a>
<a name="ln2797">			if_inc_counter(ifp, IFCOUNTER_IQDROPS, 1);</a>
<a name="ln2798">			/* reuse old buffer */</a>
<a name="ln2799">			sk_discard_rxbuf(sc_if, cons);</a>
<a name="ln2800">			continue;</a>
<a name="ln2801">		}</a>
<a name="ln2802">		m-&gt;m_pkthdr.rcvif = ifp;</a>
<a name="ln2803">		m-&gt;m_pkthdr.len = m-&gt;m_len = SK_RXBYTES(sk_ctl);</a>
<a name="ln2804">		if_inc_counter(ifp, IFCOUNTER_IPACKETS, 1);</a>
<a name="ln2805">		if ((ifp-&gt;if_capenable &amp; IFCAP_RXCSUM) != 0)</a>
<a name="ln2806">			sk_rxcksum(ifp, m, csum);</a>
<a name="ln2807">		SK_IF_UNLOCK(sc_if);</a>
<a name="ln2808">		(*ifp-&gt;if_input)(ifp, m);</a>
<a name="ln2809">		SK_IF_LOCK(sc_if);</a>
<a name="ln2810">	}</a>
<a name="ln2811"> </a>
<a name="ln2812">	if (prog &gt; 0) {</a>
<a name="ln2813">		sc_if-&gt;sk_cdata.sk_rx_cons = cons;</a>
<a name="ln2814">		bus_dmamap_sync(sc_if-&gt;sk_cdata.sk_rx_ring_tag,</a>
<a name="ln2815">		    sc_if-&gt;sk_cdata.sk_rx_ring_map,</a>
<a name="ln2816">		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln2817">	}</a>
<a name="ln2818">}</a>
<a name="ln2819"> </a>
<a name="ln2820">static void</a>
<a name="ln2821">sk_jumbo_rxeof(sc_if)</a>
<a name="ln2822">	struct sk_if_softc	*sc_if;</a>
<a name="ln2823">{</a>
<a name="ln2824">	struct sk_softc		*sc;</a>
<a name="ln2825">	struct mbuf		*m;</a>
<a name="ln2826">	struct ifnet		*ifp;</a>
<a name="ln2827">	struct sk_rx_desc	*cur_rx;</a>
<a name="ln2828">	struct sk_rxdesc	*jrxd;</a>
<a name="ln2829">	int			cons, prog;</a>
<a name="ln2830">	u_int32_t		csum, rxstat, sk_ctl;</a>
<a name="ln2831"> </a>
<a name="ln2832">	sc = sc_if-&gt;sk_softc;</a>
<a name="ln2833">	ifp = sc_if-&gt;sk_ifp;</a>
<a name="ln2834"> </a>
<a name="ln2835">	SK_IF_LOCK_ASSERT(sc_if);</a>
<a name="ln2836"> </a>
<a name="ln2837">	bus_dmamap_sync(sc_if-&gt;sk_cdata.sk_jumbo_rx_ring_tag,</a>
<a name="ln2838">	    sc_if-&gt;sk_cdata.sk_jumbo_rx_ring_map, BUS_DMASYNC_POSTREAD);</a>
<a name="ln2839"> </a>
<a name="ln2840">	prog = 0;</a>
<a name="ln2841">	for (cons = sc_if-&gt;sk_cdata.sk_jumbo_rx_cons;</a>
<a name="ln2842">	    prog &lt; SK_JUMBO_RX_RING_CNT;</a>
<a name="ln2843">	    prog++, SK_INC(cons, SK_JUMBO_RX_RING_CNT)) {</a>
<a name="ln2844">		cur_rx = &amp;sc_if-&gt;sk_rdata.sk_jumbo_rx_ring[cons];</a>
<a name="ln2845">		sk_ctl = le32toh(cur_rx-&gt;sk_ctl);</a>
<a name="ln2846">		if ((sk_ctl &amp; SK_RXCTL_OWN) != 0)</a>
<a name="ln2847">			break;</a>
<a name="ln2848">		jrxd = &amp;sc_if-&gt;sk_cdata.sk_jumbo_rxdesc[cons];</a>
<a name="ln2849">		rxstat = le32toh(cur_rx-&gt;sk_xmac_rxstat);</a>
<a name="ln2850"> </a>
<a name="ln2851">		if ((sk_ctl &amp; (SK_RXCTL_STATUS_VALID | SK_RXCTL_FIRSTFRAG |</a>
<a name="ln2852">		    SK_RXCTL_LASTFRAG)) != (SK_RXCTL_STATUS_VALID |</a>
<a name="ln2853">		    SK_RXCTL_FIRSTFRAG | SK_RXCTL_LASTFRAG) ||</a>
<a name="ln2854">		    SK_RXBYTES(sk_ctl) &lt; SK_MIN_FRAMELEN ||</a>
<a name="ln2855">		    SK_RXBYTES(sk_ctl) &gt; SK_JUMBO_FRAMELEN ||</a>
<a name="ln2856">		    sk_rxvalid(sc, rxstat, SK_RXBYTES(sk_ctl)) == 0) {</a>
<a name="ln2857">			if_inc_counter(ifp, IFCOUNTER_IERRORS, 1);</a>
<a name="ln2858">			sk_discard_jumbo_rxbuf(sc_if, cons);</a>
<a name="ln2859">			continue;</a>
<a name="ln2860">		}</a>
<a name="ln2861"> </a>
<a name="ln2862">		m = jrxd-&gt;rx_m;</a>
<a name="ln2863">		csum = le32toh(cur_rx-&gt;sk_csum);</a>
<a name="ln2864">		if (sk_jumbo_newbuf(sc_if, cons) != 0) {</a>
<a name="ln2865">			if_inc_counter(ifp, IFCOUNTER_IQDROPS, 1);</a>
<a name="ln2866">			/* reuse old buffer */</a>
<a name="ln2867">			sk_discard_jumbo_rxbuf(sc_if, cons);</a>
<a name="ln2868">			continue;</a>
<a name="ln2869">		}</a>
<a name="ln2870">		m-&gt;m_pkthdr.rcvif = ifp;</a>
<a name="ln2871">		m-&gt;m_pkthdr.len = m-&gt;m_len = SK_RXBYTES(sk_ctl);</a>
<a name="ln2872">		if_inc_counter(ifp, IFCOUNTER_IPACKETS, 1);</a>
<a name="ln2873">		if ((ifp-&gt;if_capenable &amp; IFCAP_RXCSUM) != 0)</a>
<a name="ln2874">			sk_rxcksum(ifp, m, csum);</a>
<a name="ln2875">		SK_IF_UNLOCK(sc_if);</a>
<a name="ln2876">		(*ifp-&gt;if_input)(ifp, m);</a>
<a name="ln2877">		SK_IF_LOCK(sc_if);</a>
<a name="ln2878">	}</a>
<a name="ln2879"> </a>
<a name="ln2880">	if (prog &gt; 0) {</a>
<a name="ln2881">		sc_if-&gt;sk_cdata.sk_jumbo_rx_cons = cons;</a>
<a name="ln2882">		bus_dmamap_sync(sc_if-&gt;sk_cdata.sk_jumbo_rx_ring_tag,</a>
<a name="ln2883">		    sc_if-&gt;sk_cdata.sk_jumbo_rx_ring_map,</a>
<a name="ln2884">		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln2885">	}</a>
<a name="ln2886">}</a>
<a name="ln2887"> </a>
<a name="ln2888">static void</a>
<a name="ln2889">sk_txeof(sc_if)</a>
<a name="ln2890">	struct sk_if_softc	*sc_if;</a>
<a name="ln2891">{</a>
<a name="ln2892">	struct sk_txdesc	*txd;</a>
<a name="ln2893">	struct sk_tx_desc	*cur_tx;</a>
<a name="ln2894">	struct ifnet		*ifp;</a>
<a name="ln2895">	u_int32_t		idx, sk_ctl;</a>
<a name="ln2896"> </a>
<a name="ln2897">	ifp = sc_if-&gt;sk_ifp;</a>
<a name="ln2898"> </a>
<a name="ln2899">	txd = STAILQ_FIRST(&amp;sc_if-&gt;sk_cdata.sk_txbusyq);</a>
<a name="ln2900">	if (txd == NULL)</a>
<a name="ln2901">		return;</a>
<a name="ln2902">	bus_dmamap_sync(sc_if-&gt;sk_cdata.sk_tx_ring_tag,</a>
<a name="ln2903">	    sc_if-&gt;sk_cdata.sk_tx_ring_map, BUS_DMASYNC_POSTREAD);</a>
<a name="ln2904">	/*</a>
<a name="ln2905">	 * Go through our tx ring and free mbufs for those</a>
<a name="ln2906">	 * frames that have been sent.</a>
<a name="ln2907">	 */</a>
<a name="ln2908">	for (idx = sc_if-&gt;sk_cdata.sk_tx_cons;; SK_INC(idx, SK_TX_RING_CNT)) {</a>
<a name="ln2909">		if (sc_if-&gt;sk_cdata.sk_tx_cnt &lt;= 0)</a>
<a name="ln2910">			break;</a>
<a name="ln2911">		cur_tx = &amp;sc_if-&gt;sk_rdata.sk_tx_ring[idx];</a>
<a name="ln2912">		sk_ctl = le32toh(cur_tx-&gt;sk_ctl);</a>
<a name="ln2913">		if (sk_ctl &amp; SK_TXCTL_OWN)</a>
<a name="ln2914">			break;</a>
<a name="ln2915">		sc_if-&gt;sk_cdata.sk_tx_cnt--;</a>
<a name="ln2916">		ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_OACTIVE;</a>
<a name="ln2917">		if ((sk_ctl &amp; SK_TXCTL_LASTFRAG) == 0)</a>
<a name="ln2918">			continue;</a>
<a name="ln2919">		bus_dmamap_sync(sc_if-&gt;sk_cdata.sk_tx_tag, txd-&gt;tx_dmamap,</a>
<a name="ln2920">		    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln2921">		bus_dmamap_unload(sc_if-&gt;sk_cdata.sk_tx_tag, txd-&gt;tx_dmamap);</a>
<a name="ln2922"> </a>
<a name="ln2923">		if_inc_counter(ifp, IFCOUNTER_OPACKETS, 1);</a>
<a name="ln2924">		m_freem(txd-&gt;tx_m);</a>
<a name="ln2925">		txd-&gt;tx_m = NULL;</a>
<a name="ln2926">		STAILQ_REMOVE_HEAD(&amp;sc_if-&gt;sk_cdata.sk_txbusyq, tx_q);</a>
<a name="ln2927">		STAILQ_INSERT_TAIL(&amp;sc_if-&gt;sk_cdata.sk_txfreeq, txd, tx_q);</a>
<a name="ln2928">		txd = STAILQ_FIRST(&amp;sc_if-&gt;sk_cdata.sk_txbusyq);</a>
<a name="ln2929">	}</a>
<a name="ln2930">	sc_if-&gt;sk_cdata.sk_tx_cons = idx;</a>
<a name="ln2931">	sc_if-&gt;sk_watchdog_timer = sc_if-&gt;sk_cdata.sk_tx_cnt &gt; 0 ? 5 : 0;</a>
<a name="ln2932"> </a>
<a name="ln2933">	bus_dmamap_sync(sc_if-&gt;sk_cdata.sk_tx_ring_tag,</a>
<a name="ln2934">	    sc_if-&gt;sk_cdata.sk_tx_ring_map,</a>
<a name="ln2935">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln2936">}</a>
<a name="ln2937"> </a>
<a name="ln2938">static void</a>
<a name="ln2939">sk_tick(xsc_if)</a>
<a name="ln2940">	void			*xsc_if;</a>
<a name="ln2941">{</a>
<a name="ln2942">	struct sk_if_softc	*sc_if;</a>
<a name="ln2943">	struct mii_data		*mii;</a>
<a name="ln2944">	struct ifnet		*ifp;</a>
<a name="ln2945">	int			i;</a>
<a name="ln2946"> </a>
<a name="ln2947">	sc_if = xsc_if;</a>
<a name="ln2948">	ifp = sc_if-&gt;sk_ifp;</a>
<a name="ln2949">	mii = device_get_softc(sc_if-&gt;sk_miibus);</a>
<a name="ln2950"> </a>
<a name="ln2951">	if (!(ifp-&gt;if_flags &amp; IFF_UP))</a>
<a name="ln2952">		return;</a>
<a name="ln2953"> </a>
<a name="ln2954">	if (sc_if-&gt;sk_phytype == SK_PHYTYPE_BCOM) {</a>
<a name="ln2955">		sk_intr_bcom(sc_if);</a>
<a name="ln2956">		return;</a>
<a name="ln2957">	}</a>
<a name="ln2958"> </a>
<a name="ln2959">	/*</a>
<a name="ln2960">	 * According to SysKonnect, the correct way to verify that</a>
<a name="ln2961">	 * the link has come back up is to poll bit 0 of the GPIO</a>
<a name="ln2962">	 * register three times. This pin has the signal from the</a>
<a name="ln2963">	 * link_sync pin connected to it; if we read the same link</a>
<a name="ln2964">	 * state 3 times in a row, we know the link is up.</a>
<a name="ln2965">	 */</a>
<a name="ln2966">	for (i = 0; i &lt; 3; i++) {</a>
<a name="ln2967">		if (SK_XM_READ_2(sc_if, XM_GPIO) &amp; XM_GPIO_GP0_SET)</a>
<a name="ln2968">			break;</a>
<a name="ln2969">	}</a>
<a name="ln2970"> </a>
<a name="ln2971">	if (i != 3) {</a>
<a name="ln2972">		callout_reset(&amp;sc_if-&gt;sk_tick_ch, hz, sk_tick, sc_if);</a>
<a name="ln2973">		return;</a>
<a name="ln2974">	}</a>
<a name="ln2975"> </a>
<a name="ln2976">	/* Turn the GP0 interrupt back on. */</a>
<a name="ln2977">	SK_XM_CLRBIT_2(sc_if, XM_IMR, XM_IMR_GP0_SET);</a>
<a name="ln2978">	SK_XM_READ_2(sc_if, XM_ISR);</a>
<a name="ln2979">	mii_tick(mii);</a>
<a name="ln2980">	callout_stop(&amp;sc_if-&gt;sk_tick_ch);</a>
<a name="ln2981">}</a>
<a name="ln2982"> </a>
<a name="ln2983">static void</a>
<a name="ln2984">sk_yukon_tick(xsc_if)</a>
<a name="ln2985">	void			*xsc_if;</a>
<a name="ln2986">{</a>
<a name="ln2987">	struct sk_if_softc	*sc_if;</a>
<a name="ln2988">	struct mii_data		*mii;</a>
<a name="ln2989"> </a>
<a name="ln2990">	sc_if = xsc_if;</a>
<a name="ln2991">	mii = device_get_softc(sc_if-&gt;sk_miibus);</a>
<a name="ln2992"> </a>
<a name="ln2993">	mii_tick(mii);</a>
<a name="ln2994">	callout_reset(&amp;sc_if-&gt;sk_tick_ch, hz, sk_yukon_tick, sc_if);</a>
<a name="ln2995">}</a>
<a name="ln2996"> </a>
<a name="ln2997">static void</a>
<a name="ln2998">sk_intr_bcom(sc_if)</a>
<a name="ln2999">	struct sk_if_softc	*sc_if;</a>
<a name="ln3000">{</a>
<a name="ln3001">	struct mii_data		*mii;</a>
<a name="ln3002">	struct ifnet		*ifp;</a>
<a name="ln3003">	int			status;</a>
<a name="ln3004">	mii = device_get_softc(sc_if-&gt;sk_miibus);</a>
<a name="ln3005">	ifp = sc_if-&gt;sk_ifp;</a>
<a name="ln3006"> </a>
<a name="ln3007">	SK_XM_CLRBIT_2(sc_if, XM_MMUCMD, XM_MMUCMD_TX_ENB|XM_MMUCMD_RX_ENB);</a>
<a name="ln3008"> </a>
<a name="ln3009">	/*</a>
<a name="ln3010">	 * Read the PHY interrupt register to make sure</a>
<a name="ln3011">	 * we clear any pending interrupts.</a>
<a name="ln3012">	 */</a>
<a name="ln3013">	status = sk_xmac_miibus_readreg(sc_if, SK_PHYADDR_BCOM, BRGPHY_MII_ISR);</a>
<a name="ln3014"> </a>
<a name="ln3015">	if (!(ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING)) {</a>
<a name="ln3016">		sk_init_xmac(sc_if);</a>
<a name="ln3017">		return;</a>
<a name="ln3018">	}</a>
<a name="ln3019"> </a>
<a name="ln3020">	if (status &amp; (BRGPHY_ISR_LNK_CHG|BRGPHY_ISR_AN_PR)) {</a>
<a name="ln3021">		int			lstat;</a>
<a name="ln3022">		lstat = sk_xmac_miibus_readreg(sc_if, SK_PHYADDR_BCOM,</a>
<a name="ln3023">		    BRGPHY_MII_AUXSTS);</a>
<a name="ln3024"> </a>
<a name="ln3025">		if (!(lstat &amp; BRGPHY_AUXSTS_LINK) &amp;&amp; sc_if-&gt;sk_link) {</a>
<a name="ln3026">			mii_mediachg(mii);</a>
<a name="ln3027">			/* Turn off the link LED. */</a>
<a name="ln3028">			SK_IF_WRITE_1(sc_if, 0,</a>
<a name="ln3029">			    SK_LINKLED1_CTL, SK_LINKLED_OFF);</a>
<a name="ln3030">			sc_if-&gt;sk_link = 0;</a>
<a name="ln3031">		} else if (status &amp; BRGPHY_ISR_LNK_CHG) {</a>
<a name="ln3032">			sk_xmac_miibus_writereg(sc_if, SK_PHYADDR_BCOM,</a>
<a name="ln3033">	    		    BRGPHY_MII_IMR, 0xFF00);</a>
<a name="ln3034">			mii_tick(mii);</a>
<a name="ln3035">			sc_if-&gt;sk_link = 1;</a>
<a name="ln3036">			/* Turn on the link LED. */</a>
<a name="ln3037">			SK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL,</a>
<a name="ln3038">			    SK_LINKLED_ON|SK_LINKLED_LINKSYNC_OFF|</a>
<a name="ln3039">			    SK_LINKLED_BLINK_OFF);</a>
<a name="ln3040">		} else {</a>
<a name="ln3041">			mii_tick(mii);</a>
<a name="ln3042">			callout_reset(&amp;sc_if-&gt;sk_tick_ch, hz, sk_tick, sc_if);</a>
<a name="ln3043">		}</a>
<a name="ln3044">	}</a>
<a name="ln3045"> </a>
<a name="ln3046">	SK_XM_SETBIT_2(sc_if, XM_MMUCMD, XM_MMUCMD_TX_ENB|XM_MMUCMD_RX_ENB);</a>
<a name="ln3047"> </a>
<a name="ln3048">	return;</a>
<a name="ln3049">}</a>
<a name="ln3050"> </a>
<a name="ln3051">static void</a>
<a name="ln3052">sk_intr_xmac(sc_if)</a>
<a name="ln3053">	struct sk_if_softc	*sc_if;</a>
<a name="ln3054">{</a>
<a name="ln3055">	struct sk_softc		*sc;</a>
<a name="ln3056">	u_int16_t		status;</a>
<a name="ln3057"> </a>
<a name="ln3058">	sc = sc_if-&gt;sk_softc;</a>
<a name="ln3059">	status = SK_XM_READ_2(sc_if, XM_ISR);</a>
<a name="ln3060"> </a>
<a name="ln3061">	/*</a>
<a name="ln3062">	 * Link has gone down. Start MII tick timeout to</a>
<a name="ln3063">	 * watch for link resync.</a>
<a name="ln3064">	 */</a>
<a name="ln3065">	if (sc_if-&gt;sk_phytype == SK_PHYTYPE_XMAC) {</a>
<a name="ln3066">		if (status &amp; XM_ISR_GP0_SET) {</a>
<a name="ln3067">			SK_XM_SETBIT_2(sc_if, XM_IMR, XM_IMR_GP0_SET);</a>
<a name="ln3068">			callout_reset(&amp;sc_if-&gt;sk_tick_ch, hz, sk_tick, sc_if);</a>
<a name="ln3069">		}</a>
<a name="ln3070"> </a>
<a name="ln3071">		if (status &amp; XM_ISR_AUTONEG_DONE) {</a>
<a name="ln3072">			callout_reset(&amp;sc_if-&gt;sk_tick_ch, hz, sk_tick, sc_if);</a>
<a name="ln3073">		}</a>
<a name="ln3074">	}</a>
<a name="ln3075"> </a>
<a name="ln3076">	if (status &amp; XM_IMR_TX_UNDERRUN)</a>
<a name="ln3077">		SK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_FLUSH_TXFIFO);</a>
<a name="ln3078"> </a>
<a name="ln3079">	if (status &amp; XM_IMR_RX_OVERRUN)</a>
<a name="ln3080">		SK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_FLUSH_RXFIFO);</a>
<a name="ln3081"> </a>
<a name="ln3082">	status = SK_XM_READ_2(sc_if, XM_ISR);</a>
<a name="ln3083"> </a>
<a name="ln3084">	return;</a>
<a name="ln3085">}</a>
<a name="ln3086"> </a>
<a name="ln3087">static void</a>
<a name="ln3088">sk_intr_yukon(sc_if)</a>
<a name="ln3089">	struct sk_if_softc	*sc_if;</a>
<a name="ln3090">{</a>
<a name="ln3091">	u_int8_t status;</a>
<a name="ln3092"> </a>
<a name="ln3093">	status = SK_IF_READ_1(sc_if, 0, SK_GMAC_ISR);</a>
<a name="ln3094">	/* RX overrun */</a>
<a name="ln3095">	if ((status &amp; SK_GMAC_INT_RX_OVER) != 0) {</a>
<a name="ln3096">		SK_IF_WRITE_1(sc_if, 0, SK_RXMF1_CTRL_TEST,</a>
<a name="ln3097">		    SK_RFCTL_RX_FIFO_OVER);</a>
<a name="ln3098">	}</a>
<a name="ln3099">	/* TX underrun */</a>
<a name="ln3100">	if ((status &amp; SK_GMAC_INT_TX_UNDER) != 0) {</a>
<a name="ln3101">		SK_IF_WRITE_1(sc_if, 0, SK_RXMF1_CTRL_TEST,</a>
<a name="ln3102">		    SK_TFCTL_TX_FIFO_UNDER);</a>
<a name="ln3103">	}</a>
<a name="ln3104">}</a>
<a name="ln3105"> </a>
<a name="ln3106">static void</a>
<a name="ln3107">sk_intr(xsc)</a>
<a name="ln3108">	void			*xsc;</a>
<a name="ln3109">{</a>
<a name="ln3110">	struct sk_softc		*sc = xsc;</a>
<a name="ln3111">	struct sk_if_softc	*sc_if0, *sc_if1;</a>
<a name="ln3112">	struct ifnet		*ifp0 = NULL, *ifp1 = NULL;</a>
<a name="ln3113">	u_int32_t		status;</a>
<a name="ln3114"> </a>
<a name="ln3115">	SK_LOCK(sc);</a>
<a name="ln3116"> </a>
<a name="ln3117">#ifndef __HAIKU__</a>
<a name="ln3118">	status = CSR_READ_4(sc, SK_ISSR);</a>
<a name="ln3119">	if (status == 0 || status == 0xffffffff || sc-&gt;sk_suspended)</a>
<a name="ln3120">		goto done_locked;</a>
<a name="ln3121">#endif</a>
<a name="ln3122"> </a>
<a name="ln3123">	sc_if0 = sc-&gt;sk_if[SK_PORT_A];</a>
<a name="ln3124">	sc_if1 = sc-&gt;sk_if[SK_PORT_B];</a>
<a name="ln3125"> </a>
<a name="ln3126">	if (sc_if0 != NULL)</a>
<a name="ln3127">		ifp0 = sc_if0-&gt;sk_ifp;</a>
<a name="ln3128">	if (sc_if1 != NULL)</a>
<a name="ln3129">		ifp1 = sc_if1-&gt;sk_ifp;</a>
<a name="ln3130"> </a>
<a name="ln3131">#ifndef __HAIKU__</a>
<a name="ln3132">	for (; (status &amp;= sc-&gt;sk_intrmask) != 0;) {</a>
<a name="ln3133">#else</a>
<a name="ln3134">	status = atomic_get((int32 *)&amp;sc-&gt;sk_intstatus);</a>
<a name="ln3135">	status &amp;= sc-&gt;sk_intrmask;</a>
<a name="ln3136">	while (true) {</a>
<a name="ln3137"> </a>
<a name="ln3138">		if (status == 0 || status == 0xffffffff || sc-&gt;sk_suspended)</a>
<a name="ln3139">			goto done_locked;</a>
<a name="ln3140">#endif</a>
<a name="ln3141">		/* Handle receive interrupts first. */</a>
<a name="ln3142">		if (status &amp; SK_ISR_RX1_EOF) {</a>
<a name="ln3143">			if (ifp0-&gt;if_mtu &gt; SK_MAX_FRAMELEN)</a>
<a name="ln3144">				sk_jumbo_rxeof(sc_if0);</a>
<a name="ln3145">			else</a>
<a name="ln3146">				sk_rxeof(sc_if0);</a>
<a name="ln3147">			CSR_WRITE_4(sc, SK_BMU_RX_CSR0,</a>
<a name="ln3148">			    SK_RXBMU_CLR_IRQ_EOF|SK_RXBMU_RX_START);</a>
<a name="ln3149">		}</a>
<a name="ln3150">		if (status &amp; SK_ISR_RX2_EOF) {</a>
<a name="ln3151">			if (ifp1-&gt;if_mtu &gt; SK_MAX_FRAMELEN)</a>
<a name="ln3152">				sk_jumbo_rxeof(sc_if1);</a>
<a name="ln3153">			else</a>
<a name="ln3154">				sk_rxeof(sc_if1);</a>
<a name="ln3155">			CSR_WRITE_4(sc, SK_BMU_RX_CSR1,</a>
<a name="ln3156">			    SK_RXBMU_CLR_IRQ_EOF|SK_RXBMU_RX_START);</a>
<a name="ln3157">		}</a>
<a name="ln3158"> </a>
<a name="ln3159">		/* Then transmit interrupts. */</a>
<a name="ln3160">		if (status &amp; SK_ISR_TX1_S_EOF) {</a>
<a name="ln3161">			sk_txeof(sc_if0);</a>
<a name="ln3162">			CSR_WRITE_4(sc, SK_BMU_TXS_CSR0, SK_TXBMU_CLR_IRQ_EOF);</a>
<a name="ln3163">		}</a>
<a name="ln3164">		if (status &amp; SK_ISR_TX2_S_EOF) {</a>
<a name="ln3165">			sk_txeof(sc_if1);</a>
<a name="ln3166">			CSR_WRITE_4(sc, SK_BMU_TXS_CSR1, SK_TXBMU_CLR_IRQ_EOF);</a>
<a name="ln3167">		}</a>
<a name="ln3168"> </a>
<a name="ln3169">		/* Then MAC interrupts. */</a>
<a name="ln3170">		if (status &amp; SK_ISR_MAC1 &amp;&amp;</a>
<a name="ln3171">		    ifp0-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) {</a>
<a name="ln3172">			if (sc-&gt;sk_type == SK_GENESIS)</a>
<a name="ln3173">				sk_intr_xmac(sc_if0);</a>
<a name="ln3174">			else</a>
<a name="ln3175">				sk_intr_yukon(sc_if0);</a>
<a name="ln3176">		}</a>
<a name="ln3177"> </a>
<a name="ln3178">		if (status &amp; SK_ISR_MAC2 &amp;&amp;</a>
<a name="ln3179">		    ifp1-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) {</a>
<a name="ln3180">			if (sc-&gt;sk_type == SK_GENESIS)</a>
<a name="ln3181">				sk_intr_xmac(sc_if1);</a>
<a name="ln3182">			else</a>
<a name="ln3183">				sk_intr_yukon(sc_if1);</a>
<a name="ln3184">		}</a>
<a name="ln3185"> </a>
<a name="ln3186">		if (status &amp; SK_ISR_EXTERNAL_REG) {</a>
<a name="ln3187">			if (ifp0 != NULL &amp;&amp;</a>
<a name="ln3188">			    sc_if0-&gt;sk_phytype == SK_PHYTYPE_BCOM)</a>
<a name="ln3189">				sk_intr_bcom(sc_if0);</a>
<a name="ln3190">			if (ifp1 != NULL &amp;&amp;</a>
<a name="ln3191">			    sc_if1-&gt;sk_phytype == SK_PHYTYPE_BCOM)</a>
<a name="ln3192">				sk_intr_bcom(sc_if1);</a>
<a name="ln3193">		}</a>
<a name="ln3194">		status = CSR_READ_4(sc, SK_ISSR);</a>
<a name="ln3195">#ifdef __HAIKU__</a>
<a name="ln3196">		if (((status &amp; sc-&gt;sk_intrmask) == 0) || status == 0xffffffff || </a>
<a name="ln3197">			sc-&gt;sk_suspended) {</a>
<a name="ln3198">			break;</a>
<a name="ln3199">		}</a>
<a name="ln3200">#endif</a>
<a name="ln3201">	}</a>
<a name="ln3202"> </a>
<a name="ln3203">	CSR_WRITE_4(sc, SK_IMR, sc-&gt;sk_intrmask);</a>
<a name="ln3204"> </a>
<a name="ln3205">	if (ifp0 != NULL &amp;&amp; !IFQ_DRV_IS_EMPTY(&amp;ifp0-&gt;if_snd))</a>
<a name="ln3206">		sk_start_locked(ifp0);</a>
<a name="ln3207">	if (ifp1 != NULL &amp;&amp; !IFQ_DRV_IS_EMPTY(&amp;ifp1-&gt;if_snd))</a>
<a name="ln3208">		sk_start_locked(ifp1);</a>
<a name="ln3209"> </a>
<a name="ln3210">done_locked:</a>
<a name="ln3211">	SK_UNLOCK(sc);</a>
<a name="ln3212">}</a>
<a name="ln3213"> </a>
<a name="ln3214">static void</a>
<a name="ln3215">sk_init_xmac(sc_if)</a>
<a name="ln3216">	struct sk_if_softc	*sc_if;</a>
<a name="ln3217">{</a>
<a name="ln3218">	struct sk_softc		*sc;</a>
<a name="ln3219">	struct ifnet		*ifp;</a>
<a name="ln3220">	u_int16_t		eaddr[(ETHER_ADDR_LEN+1)/2];</a>
<a name="ln3221">	static const struct sk_bcom_hack bhack[] = {</a>
<a name="ln3222">	{ 0x18, 0x0c20 }, { 0x17, 0x0012 }, { 0x15, 0x1104 }, { 0x17, 0x0013 },</a>
<a name="ln3223">	{ 0x15, 0x0404 }, { 0x17, 0x8006 }, { 0x15, 0x0132 }, { 0x17, 0x8006 },</a>
<a name="ln3224">	{ 0x15, 0x0232 }, { 0x17, 0x800D }, { 0x15, 0x000F }, { 0x18, 0x0420 },</a>
<a name="ln3225">	{ 0, 0 } };</a>
<a name="ln3226"> </a>
<a name="ln3227">	SK_IF_LOCK_ASSERT(sc_if);</a>
<a name="ln3228"> </a>
<a name="ln3229">	sc = sc_if-&gt;sk_softc;</a>
<a name="ln3230">	ifp = sc_if-&gt;sk_ifp;</a>
<a name="ln3231"> </a>
<a name="ln3232">	/* Unreset the XMAC. */</a>
<a name="ln3233">	SK_IF_WRITE_2(sc_if, 0, SK_TXF1_MACCTL, SK_TXMACCTL_XMAC_UNRESET);</a>
<a name="ln3234">	DELAY(1000);</a>
<a name="ln3235"> </a>
<a name="ln3236">	/* Reset the XMAC's internal state. */</a>
<a name="ln3237">	SK_XM_SETBIT_2(sc_if, XM_GPIO, XM_GPIO_RESETMAC);</a>
<a name="ln3238"> </a>
<a name="ln3239">	/* Save the XMAC II revision */</a>
<a name="ln3240">	sc_if-&gt;sk_xmac_rev = XM_XMAC_REV(SK_XM_READ_4(sc_if, XM_DEVID));</a>
<a name="ln3241"> </a>
<a name="ln3242">	/*</a>
<a name="ln3243">	 * Perform additional initialization for external PHYs,</a>
<a name="ln3244">	 * namely for the 1000baseTX cards that use the XMAC's</a>
<a name="ln3245">	 * GMII mode.</a>
<a name="ln3246">	 */</a>
<a name="ln3247">	if (sc_if-&gt;sk_phytype == SK_PHYTYPE_BCOM) {</a>
<a name="ln3248">		int			i = 0;</a>
<a name="ln3249">		u_int32_t		val;</a>
<a name="ln3250"> </a>
<a name="ln3251">		/* Take PHY out of reset. */</a>
<a name="ln3252">		val = sk_win_read_4(sc, SK_GPIO);</a>
<a name="ln3253">		if (sc_if-&gt;sk_port == SK_PORT_A)</a>
<a name="ln3254">			val |= SK_GPIO_DIR0|SK_GPIO_DAT0;</a>
<a name="ln3255">		else</a>
<a name="ln3256">			val |= SK_GPIO_DIR2|SK_GPIO_DAT2;</a>
<a name="ln3257">		sk_win_write_4(sc, SK_GPIO, val);</a>
<a name="ln3258"> </a>
<a name="ln3259">		/* Enable GMII mode on the XMAC. */</a>
<a name="ln3260">		SK_XM_SETBIT_2(sc_if, XM_HWCFG, XM_HWCFG_GMIIMODE);</a>
<a name="ln3261"> </a>
<a name="ln3262">		sk_xmac_miibus_writereg(sc_if, SK_PHYADDR_BCOM,</a>
<a name="ln3263">		    BRGPHY_MII_BMCR, BRGPHY_BMCR_RESET);</a>
<a name="ln3264">		DELAY(10000);</a>
<a name="ln3265">		sk_xmac_miibus_writereg(sc_if, SK_PHYADDR_BCOM,</a>
<a name="ln3266">		    BRGPHY_MII_IMR, 0xFFF0);</a>
<a name="ln3267"> </a>
<a name="ln3268">		/*</a>
<a name="ln3269">		 * Early versions of the BCM5400 apparently have</a>
<a name="ln3270">		 * a bug that requires them to have their reserved</a>
<a name="ln3271">		 * registers initialized to some magic values. I don't</a>
<a name="ln3272">		 * know what the numbers do, I'm just the messenger.</a>
<a name="ln3273">		 */</a>
<a name="ln3274">		if (sk_xmac_miibus_readreg(sc_if, SK_PHYADDR_BCOM, 0x03)</a>
<a name="ln3275">		    == 0x6041) {</a>
<a name="ln3276">			while(bhack[i].reg) {</a>
<a name="ln3277">				sk_xmac_miibus_writereg(sc_if, SK_PHYADDR_BCOM,</a>
<a name="ln3278">				    bhack[i].reg, bhack[i].val);</a>
<a name="ln3279">				i++;</a>
<a name="ln3280">			}</a>
<a name="ln3281">		}</a>
<a name="ln3282">	}</a>
<a name="ln3283"> </a>
<a name="ln3284">	/* Set station address */</a>
<a name="ln3285">	bcopy(IF_LLADDR(sc_if-&gt;sk_ifp), eaddr, ETHER_ADDR_LEN);</a>
<a name="ln3286">	SK_XM_WRITE_2(sc_if, XM_PAR0, eaddr[0]);</a>
<a name="ln3287">	SK_XM_WRITE_2(sc_if, XM_PAR1, eaddr[1]);</a>
<a name="ln3288">	SK_XM_WRITE_2(sc_if, XM_PAR2, eaddr[2]);</a>
<a name="ln3289">	SK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_USE_STATION);</a>
<a name="ln3290"> </a>
<a name="ln3291">	if (ifp-&gt;if_flags &amp; IFF_BROADCAST) {</a>
<a name="ln3292">		SK_XM_CLRBIT_4(sc_if, XM_MODE, XM_MODE_RX_NOBROAD);</a>
<a name="ln3293">	} else {</a>
<a name="ln3294">		SK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_NOBROAD);</a>
<a name="ln3295">	}</a>
<a name="ln3296"> </a>
<a name="ln3297">	/* We don't need the FCS appended to the packet. */</a>
<a name="ln3298">	SK_XM_SETBIT_2(sc_if, XM_RXCMD, XM_RXCMD_STRIPFCS);</a>
<a name="ln3299"> </a>
<a name="ln3300">	/* We want short frames padded to 60 bytes. */</a>
<a name="ln3301">	SK_XM_SETBIT_2(sc_if, XM_TXCMD, XM_TXCMD_AUTOPAD);</a>
<a name="ln3302"> </a>
<a name="ln3303">	/*</a>
<a name="ln3304">	 * Enable the reception of all error frames. This is is</a>
<a name="ln3305">	 * a necessary evil due to the design of the XMAC. The</a>
<a name="ln3306">	 * XMAC's receive FIFO is only 8K in size, however jumbo</a>
<a name="ln3307">	 * frames can be up to 9000 bytes in length. When bad</a>
<a name="ln3308">	 * frame filtering is enabled, the XMAC's RX FIFO operates</a>
<a name="ln3309">	 * in 'store and forward' mode. For this to work, the</a>
<a name="ln3310">	 * entire frame has to fit into the FIFO, but that means</a>
<a name="ln3311">	 * that jumbo frames larger than 8192 bytes will be</a>
<a name="ln3312">	 * truncated. Disabling all bad frame filtering causes</a>
<a name="ln3313">	 * the RX FIFO to operate in streaming mode, in which</a>
<a name="ln3314">	 * case the XMAC will start transferring frames out of the</a>
<a name="ln3315">	 * RX FIFO as soon as the FIFO threshold is reached.</a>
<a name="ln3316">	 */</a>
<a name="ln3317">	if (ifp-&gt;if_mtu &gt; SK_MAX_FRAMELEN) {</a>
<a name="ln3318">		SK_XM_SETBIT_4(sc_if, XM_MODE, XM_MODE_RX_BADFRAMES|</a>
<a name="ln3319">		    XM_MODE_RX_GIANTS|XM_MODE_RX_RUNTS|XM_MODE_RX_CRCERRS|</a>
<a name="ln3320">		    XM_MODE_RX_INRANGELEN);</a>
<a name="ln3321">		SK_XM_SETBIT_2(sc_if, XM_RXCMD, XM_RXCMD_BIGPKTOK);</a>
<a name="ln3322">	} else</a>
<a name="ln3323">		SK_XM_CLRBIT_2(sc_if, XM_RXCMD, XM_RXCMD_BIGPKTOK);</a>
<a name="ln3324"> </a>
<a name="ln3325">	/*</a>
<a name="ln3326">	 * Bump up the transmit threshold. This helps hold off transmit</a>
<a name="ln3327">	 * underruns when we're blasting traffic from both ports at once.</a>
<a name="ln3328">	 */</a>
<a name="ln3329">	SK_XM_WRITE_2(sc_if, XM_TX_REQTHRESH, SK_XM_TX_FIFOTHRESH);</a>
<a name="ln3330"> </a>
<a name="ln3331">	/* Set Rx filter */</a>
<a name="ln3332">	sk_rxfilter_genesis(sc_if);</a>
<a name="ln3333"> </a>
<a name="ln3334">	/* Clear and enable interrupts */</a>
<a name="ln3335">	SK_XM_READ_2(sc_if, XM_ISR);</a>
<a name="ln3336">	if (sc_if-&gt;sk_phytype == SK_PHYTYPE_XMAC)</a>
<a name="ln3337">		SK_XM_WRITE_2(sc_if, XM_IMR, XM_INTRS);</a>
<a name="ln3338">	else</a>
<a name="ln3339">		SK_XM_WRITE_2(sc_if, XM_IMR, 0xFFFF);</a>
<a name="ln3340"> </a>
<a name="ln3341">	/* Configure MAC arbiter */</a>
<a name="ln3342">	switch(sc_if-&gt;sk_xmac_rev) {</a>
<a name="ln3343">	case XM_XMAC_REV_B2:</a>
<a name="ln3344">		sk_win_write_1(sc, SK_RCINIT_RX1, SK_RCINIT_XMAC_B2);</a>
<a name="ln3345">		sk_win_write_1(sc, SK_RCINIT_TX1, SK_RCINIT_XMAC_B2);</a>
<a name="ln3346">		sk_win_write_1(sc, SK_RCINIT_RX2, SK_RCINIT_XMAC_B2);</a>
<a name="ln3347">		sk_win_write_1(sc, SK_RCINIT_TX2, SK_RCINIT_XMAC_B2);</a>
<a name="ln3348">		sk_win_write_1(sc, SK_MINIT_RX1, SK_MINIT_XMAC_B2);</a>
<a name="ln3349">		sk_win_write_1(sc, SK_MINIT_TX1, SK_MINIT_XMAC_B2);</a>
<a name="ln3350">		sk_win_write_1(sc, SK_MINIT_RX2, SK_MINIT_XMAC_B2);</a>
<a name="ln3351">		sk_win_write_1(sc, SK_MINIT_TX2, SK_MINIT_XMAC_B2);</a>
<a name="ln3352">		sk_win_write_1(sc, SK_RECOVERY_CTL, SK_RECOVERY_XMAC_B2);</a>
<a name="ln3353">		break;</a>
<a name="ln3354">	case XM_XMAC_REV_C1:</a>
<a name="ln3355">		sk_win_write_1(sc, SK_RCINIT_RX1, SK_RCINIT_XMAC_C1);</a>
<a name="ln3356">		sk_win_write_1(sc, SK_RCINIT_TX1, SK_RCINIT_XMAC_C1);</a>
<a name="ln3357">		sk_win_write_1(sc, SK_RCINIT_RX2, SK_RCINIT_XMAC_C1);</a>
<a name="ln3358">		sk_win_write_1(sc, SK_RCINIT_TX2, SK_RCINIT_XMAC_C1);</a>
<a name="ln3359">		sk_win_write_1(sc, SK_MINIT_RX1, SK_MINIT_XMAC_C1);</a>
<a name="ln3360">		sk_win_write_1(sc, SK_MINIT_TX1, SK_MINIT_XMAC_C1);</a>
<a name="ln3361">		sk_win_write_1(sc, SK_MINIT_RX2, SK_MINIT_XMAC_C1);</a>
<a name="ln3362">		sk_win_write_1(sc, SK_MINIT_TX2, SK_MINIT_XMAC_C1);</a>
<a name="ln3363">		sk_win_write_1(sc, SK_RECOVERY_CTL, SK_RECOVERY_XMAC_B2);</a>
<a name="ln3364">		break;</a>
<a name="ln3365">	default:</a>
<a name="ln3366">		break;</a>
<a name="ln3367">	}</a>
<a name="ln3368">	sk_win_write_2(sc, SK_MACARB_CTL,</a>
<a name="ln3369">	    SK_MACARBCTL_UNRESET|SK_MACARBCTL_FASTOE_OFF);</a>
<a name="ln3370"> </a>
<a name="ln3371">	sc_if-&gt;sk_link = 1;</a>
<a name="ln3372"> </a>
<a name="ln3373">	return;</a>
<a name="ln3374">}</a>
<a name="ln3375"> </a>
<a name="ln3376">static void</a>
<a name="ln3377">sk_init_yukon(sc_if)</a>
<a name="ln3378">	struct sk_if_softc	*sc_if;</a>
<a name="ln3379">{</a>
<a name="ln3380">	u_int32_t		phy, v;</a>
<a name="ln3381">	u_int16_t		reg;</a>
<a name="ln3382">	struct sk_softc		*sc;</a>
<a name="ln3383">	struct ifnet		*ifp;</a>
<a name="ln3384">	u_int8_t		*eaddr;</a>
<a name="ln3385">	int			i;</a>
<a name="ln3386"> </a>
<a name="ln3387">	SK_IF_LOCK_ASSERT(sc_if);</a>
<a name="ln3388"> </a>
<a name="ln3389">	sc = sc_if-&gt;sk_softc;</a>
<a name="ln3390">	ifp = sc_if-&gt;sk_ifp;</a>
<a name="ln3391"> </a>
<a name="ln3392">	if (sc-&gt;sk_type == SK_YUKON_LITE &amp;&amp;</a>
<a name="ln3393">	    sc-&gt;sk_rev &gt;= SK_YUKON_LITE_REV_A3) {</a>
<a name="ln3394">		/*</a>
<a name="ln3395">		 * Workaround code for COMA mode, set PHY reset.</a>
<a name="ln3396">		 * Otherwise it will not correctly take chip out of</a>
<a name="ln3397">		 * powerdown (coma)</a>
<a name="ln3398">		 */</a>
<a name="ln3399">		v = sk_win_read_4(sc, SK_GPIO);</a>
<a name="ln3400">		v |= SK_GPIO_DIR9 | SK_GPIO_DAT9;</a>
<a name="ln3401">		sk_win_write_4(sc, SK_GPIO, v);</a>
<a name="ln3402">	}</a>
<a name="ln3403"> </a>
<a name="ln3404">	/* GMAC and GPHY Reset */</a>
<a name="ln3405">	SK_IF_WRITE_4(sc_if, 0, SK_GPHY_CTRL, SK_GPHY_RESET_SET);</a>
<a name="ln3406">	SK_IF_WRITE_4(sc_if, 0, SK_GMAC_CTRL, SK_GMAC_RESET_SET);</a>
<a name="ln3407">	DELAY(1000);</a>
<a name="ln3408"> </a>
<a name="ln3409">	if (sc-&gt;sk_type == SK_YUKON_LITE &amp;&amp;</a>
<a name="ln3410">	    sc-&gt;sk_rev &gt;= SK_YUKON_LITE_REV_A3) {</a>
<a name="ln3411">		/*</a>
<a name="ln3412">		 * Workaround code for COMA mode, clear PHY reset</a>
<a name="ln3413">		 */</a>
<a name="ln3414">		v = sk_win_read_4(sc, SK_GPIO);</a>
<a name="ln3415">		v |= SK_GPIO_DIR9;</a>
<a name="ln3416">		v &amp;= ~SK_GPIO_DAT9;</a>
<a name="ln3417">		sk_win_write_4(sc, SK_GPIO, v);</a>
<a name="ln3418">	}</a>
<a name="ln3419"> </a>
<a name="ln3420">	phy = SK_GPHY_INT_POL_HI | SK_GPHY_DIS_FC | SK_GPHY_DIS_SLEEP |</a>
<a name="ln3421">		SK_GPHY_ENA_XC | SK_GPHY_ANEG_ALL | SK_GPHY_ENA_PAUSE;</a>
<a name="ln3422"> </a>
<a name="ln3423">	if (sc-&gt;sk_coppertype)</a>
<a name="ln3424">		phy |= SK_GPHY_COPPER;</a>
<a name="ln3425">	else</a>
<a name="ln3426">		phy |= SK_GPHY_FIBER;</a>
<a name="ln3427"> </a>
<a name="ln3428">	SK_IF_WRITE_4(sc_if, 0, SK_GPHY_CTRL, phy | SK_GPHY_RESET_SET);</a>
<a name="ln3429">	DELAY(1000);</a>
<a name="ln3430">	SK_IF_WRITE_4(sc_if, 0, SK_GPHY_CTRL, phy | SK_GPHY_RESET_CLEAR);</a>
<a name="ln3431">	SK_IF_WRITE_4(sc_if, 0, SK_GMAC_CTRL, SK_GMAC_LOOP_OFF |</a>
<a name="ln3432">		      SK_GMAC_PAUSE_ON | SK_GMAC_RESET_CLEAR);</a>
<a name="ln3433"> </a>
<a name="ln3434">	/* unused read of the interrupt source register */</a>
<a name="ln3435">	SK_IF_READ_2(sc_if, 0, SK_GMAC_ISR);</a>
<a name="ln3436"> </a>
<a name="ln3437">	reg = SK_YU_READ_2(sc_if, YUKON_PAR);</a>
<a name="ln3438"> </a>
<a name="ln3439">	/* MIB Counter Clear Mode set */</a>
<a name="ln3440">	reg |= YU_PAR_MIB_CLR;</a>
<a name="ln3441">	SK_YU_WRITE_2(sc_if, YUKON_PAR, reg);</a>
<a name="ln3442"> </a>
<a name="ln3443">	/* MIB Counter Clear Mode clear */</a>
<a name="ln3444">	reg &amp;= ~YU_PAR_MIB_CLR;</a>
<a name="ln3445">	SK_YU_WRITE_2(sc_if, YUKON_PAR, reg);</a>
<a name="ln3446"> </a>
<a name="ln3447">	/* receive control reg */</a>
<a name="ln3448">	SK_YU_WRITE_2(sc_if, YUKON_RCR, YU_RCR_CRCR);</a>
<a name="ln3449"> </a>
<a name="ln3450">	/* transmit parameter register */</a>
<a name="ln3451">	SK_YU_WRITE_2(sc_if, YUKON_TPR, YU_TPR_JAM_LEN(0x3) |</a>
<a name="ln3452">		      YU_TPR_JAM_IPG(0xb) | YU_TPR_JAM2DATA_IPG(0x1a) );</a>
<a name="ln3453"> </a>
<a name="ln3454">	/* serial mode register */</a>
<a name="ln3455">	reg = YU_SMR_DATA_BLIND(0x1c) | YU_SMR_MFL_VLAN | YU_SMR_IPG_DATA(0x1e);</a>
<a name="ln3456">	if (ifp-&gt;if_mtu &gt; SK_MAX_FRAMELEN)</a>
<a name="ln3457">		reg |= YU_SMR_MFL_JUMBO;</a>
<a name="ln3458">	SK_YU_WRITE_2(sc_if, YUKON_SMR, reg);</a>
<a name="ln3459"> </a>
<a name="ln3460">	/* Setup Yukon's station address */</a>
<a name="ln3461">	eaddr = IF_LLADDR(sc_if-&gt;sk_ifp);</a>
<a name="ln3462">	for (i = 0; i &lt; 3; i++)</a>
<a name="ln3463">		SK_YU_WRITE_2(sc_if, SK_MAC0_0 + i * 4,</a>
<a name="ln3464">		    eaddr[i * 2] | eaddr[i * 2 + 1] &lt;&lt; 8);</a>
<a name="ln3465">	/* Set GMAC source address of flow control. */</a>
<a name="ln3466">	for (i = 0; i &lt; 3; i++)</a>
<a name="ln3467">		SK_YU_WRITE_2(sc_if, YUKON_SAL1 + i * 4,</a>
<a name="ln3468">		    eaddr[i * 2] | eaddr[i * 2 + 1] &lt;&lt; 8);</a>
<a name="ln3469">	/* Set GMAC virtual address. */</a>
<a name="ln3470">	for (i = 0; i &lt; 3; i++)</a>
<a name="ln3471">		SK_YU_WRITE_2(sc_if, YUKON_SAL2 + i * 4,</a>
<a name="ln3472">		    eaddr[i * 2] | eaddr[i * 2 + 1] &lt;&lt; 8);</a>
<a name="ln3473"> </a>
<a name="ln3474">	/* Set Rx filter */</a>
<a name="ln3475">	sk_rxfilter_yukon(sc_if);</a>
<a name="ln3476"> </a>
<a name="ln3477">	/* enable interrupt mask for counter overflows */</a>
<a name="ln3478">	SK_YU_WRITE_2(sc_if, YUKON_TIMR, 0);</a>
<a name="ln3479">	SK_YU_WRITE_2(sc_if, YUKON_RIMR, 0);</a>
<a name="ln3480">	SK_YU_WRITE_2(sc_if, YUKON_TRIMR, 0);</a>
<a name="ln3481"> </a>
<a name="ln3482">	/* Configure RX MAC FIFO Flush Mask */</a>
<a name="ln3483">	v = YU_RXSTAT_FOFL | YU_RXSTAT_CRCERR | YU_RXSTAT_MIIERR |</a>
<a name="ln3484">	    YU_RXSTAT_BADFC | YU_RXSTAT_GOODFC | YU_RXSTAT_RUNT |</a>
<a name="ln3485">	    YU_RXSTAT_JABBER;</a>
<a name="ln3486">	SK_IF_WRITE_2(sc_if, 0, SK_RXMF1_FLUSH_MASK, v);</a>
<a name="ln3487"> </a>
<a name="ln3488">	/* Disable RX MAC FIFO Flush for YUKON-Lite Rev. A0 only */</a>
<a name="ln3489">	if (sc-&gt;sk_type == SK_YUKON_LITE &amp;&amp; sc-&gt;sk_rev == SK_YUKON_LITE_REV_A0)</a>
<a name="ln3490">		v = SK_TFCTL_OPERATION_ON;</a>
<a name="ln3491">	else</a>
<a name="ln3492">		v = SK_TFCTL_OPERATION_ON | SK_RFCTL_FIFO_FLUSH_ON;</a>
<a name="ln3493">	/* Configure RX MAC FIFO */</a>
<a name="ln3494">	SK_IF_WRITE_1(sc_if, 0, SK_RXMF1_CTRL_TEST, SK_RFCTL_RESET_CLEAR);</a>
<a name="ln3495">	SK_IF_WRITE_2(sc_if, 0, SK_RXMF1_CTRL_TEST, v);</a>
<a name="ln3496"> </a>
<a name="ln3497">	/* Increase flush threshould to 64 bytes */</a>
<a name="ln3498">	SK_IF_WRITE_2(sc_if, 0, SK_RXMF1_FLUSH_THRESHOLD,</a>
<a name="ln3499">	    SK_RFCTL_FIFO_THRESHOLD + 1);</a>
<a name="ln3500"> </a>
<a name="ln3501">	/* Configure TX MAC FIFO */</a>
<a name="ln3502">	SK_IF_WRITE_1(sc_if, 0, SK_TXMF1_CTRL_TEST, SK_TFCTL_RESET_CLEAR);</a>
<a name="ln3503">	SK_IF_WRITE_2(sc_if, 0, SK_TXMF1_CTRL_TEST, SK_TFCTL_OPERATION_ON);</a>
<a name="ln3504">}</a>
<a name="ln3505"> </a>
<a name="ln3506">/*</a>
<a name="ln3507"> * Note that to properly initialize any part of the GEnesis chip,</a>
<a name="ln3508"> * you first have to take it out of reset mode.</a>
<a name="ln3509"> */</a>
<a name="ln3510">static void</a>
<a name="ln3511">sk_init(xsc)</a>
<a name="ln3512">	void			*xsc;</a>
<a name="ln3513">{</a>
<a name="ln3514">	struct sk_if_softc	*sc_if = xsc;</a>
<a name="ln3515"> </a>
<a name="ln3516">	SK_IF_LOCK(sc_if);</a>
<a name="ln3517">	sk_init_locked(sc_if);</a>
<a name="ln3518">	SK_IF_UNLOCK(sc_if);</a>
<a name="ln3519"> </a>
<a name="ln3520">	return;</a>
<a name="ln3521">}</a>
<a name="ln3522"> </a>
<a name="ln3523">static void</a>
<a name="ln3524">sk_init_locked(sc_if)</a>
<a name="ln3525">	struct sk_if_softc	*sc_if;</a>
<a name="ln3526">{</a>
<a name="ln3527">	struct sk_softc		*sc;</a>
<a name="ln3528">	struct ifnet		*ifp;</a>
<a name="ln3529">	struct mii_data		*mii;</a>
<a name="ln3530">	u_int16_t		reg;</a>
<a name="ln3531">	u_int32_t		imr;</a>
<a name="ln3532">	int			error;</a>
<a name="ln3533"> </a>
<a name="ln3534">	SK_IF_LOCK_ASSERT(sc_if);</a>
<a name="ln3535"> </a>
<a name="ln3536">	ifp = sc_if-&gt;sk_ifp;</a>
<a name="ln3537">	sc = sc_if-&gt;sk_softc;</a>
<a name="ln3538">	mii = device_get_softc(sc_if-&gt;sk_miibus);</a>
<a name="ln3539"> </a>
<a name="ln3540">	if (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING)</a>
<a name="ln3541">		return;</a>
<a name="ln3542"> </a>
<a name="ln3543">	/* Cancel pending I/O and free all RX/TX buffers. */</a>
<a name="ln3544">	sk_stop(sc_if);</a>
<a name="ln3545"> </a>
<a name="ln3546">	if (sc-&gt;sk_type == SK_GENESIS) {</a>
<a name="ln3547">		/* Configure LINK_SYNC LED */</a>
<a name="ln3548">		SK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_ON);</a>
<a name="ln3549">		SK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL,</a>
<a name="ln3550">			SK_LINKLED_LINKSYNC_ON);</a>
<a name="ln3551"> </a>
<a name="ln3552">		/* Configure RX LED */</a>
<a name="ln3553">		SK_IF_WRITE_1(sc_if, 0, SK_RXLED1_CTL,</a>
<a name="ln3554">			SK_RXLEDCTL_COUNTER_START);</a>
<a name="ln3555"> </a>
<a name="ln3556">		/* Configure TX LED */</a>
<a name="ln3557">		SK_IF_WRITE_1(sc_if, 0, SK_TXLED1_CTL,</a>
<a name="ln3558">			SK_TXLEDCTL_COUNTER_START);</a>
<a name="ln3559">	}</a>
<a name="ln3560"> </a>
<a name="ln3561">	/*</a>
<a name="ln3562">	 * Configure descriptor poll timer</a>
<a name="ln3563">	 *</a>
<a name="ln3564">	 * SK-NET GENESIS data sheet says that possibility of losing Start</a>
<a name="ln3565">	 * transmit command due to CPU/cache related interim storage problems</a>
<a name="ln3566">	 * under certain conditions. The document recommends a polling</a>
<a name="ln3567">	 * mechanism to send a Start transmit command to initiate transfer</a>
<a name="ln3568">	 * of ready descriptors regulary. To cope with this issue sk(4) now</a>
<a name="ln3569">	 * enables descriptor poll timer to initiate descriptor processing</a>
<a name="ln3570">	 * periodically as defined by SK_DPT_TIMER_MAX. However sk(4) still</a>
<a name="ln3571">	 * issue SK_TXBMU_TX_START to Tx BMU to get fast execution of Tx</a>
<a name="ln3572">	 * command instead of waiting for next descriptor polling time.</a>
<a name="ln3573">	 * The same rule may apply to Rx side too but it seems that is not</a>
<a name="ln3574">	 * needed at the moment.</a>
<a name="ln3575">	 * Since sk(4) uses descriptor polling as a last resort there is no</a>
<a name="ln3576">	 * need to set smaller polling time than maximum allowable one.</a>
<a name="ln3577">	 */</a>
<a name="ln3578">	SK_IF_WRITE_4(sc_if, 0, SK_DPT_INIT, SK_DPT_TIMER_MAX);</a>
<a name="ln3579"> </a>
<a name="ln3580">	/* Configure I2C registers */</a>
<a name="ln3581"> </a>
<a name="ln3582">	/* Configure XMAC(s) */</a>
<a name="ln3583">	switch (sc-&gt;sk_type) {</a>
<a name="ln3584">	case SK_GENESIS:</a>
<a name="ln3585">		sk_init_xmac(sc_if);</a>
<a name="ln3586">		break;</a>
<a name="ln3587">	case SK_YUKON:</a>
<a name="ln3588">	case SK_YUKON_LITE:</a>
<a name="ln3589">	case SK_YUKON_LP:</a>
<a name="ln3590">		sk_init_yukon(sc_if);</a>
<a name="ln3591">		break;</a>
<a name="ln3592">	}</a>
<a name="ln3593">	mii_mediachg(mii);</a>
<a name="ln3594"> </a>
<a name="ln3595">	if (sc-&gt;sk_type == SK_GENESIS) {</a>
<a name="ln3596">		/* Configure MAC FIFOs */</a>
<a name="ln3597">		SK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_UNRESET);</a>
<a name="ln3598">		SK_IF_WRITE_4(sc_if, 0, SK_RXF1_END, SK_FIFO_END);</a>
<a name="ln3599">		SK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_ON);</a>
<a name="ln3600"> </a>
<a name="ln3601">		SK_IF_WRITE_4(sc_if, 0, SK_TXF1_CTL, SK_FIFO_UNRESET);</a>
<a name="ln3602">		SK_IF_WRITE_4(sc_if, 0, SK_TXF1_END, SK_FIFO_END);</a>
<a name="ln3603">		SK_IF_WRITE_4(sc_if, 0, SK_TXF1_CTL, SK_FIFO_ON);</a>
<a name="ln3604">	}</a>
<a name="ln3605"> </a>
<a name="ln3606">	/* Configure transmit arbiter(s) */</a>
<a name="ln3607">	SK_IF_WRITE_1(sc_if, 0, SK_TXAR1_COUNTERCTL,</a>
<a name="ln3608">	    SK_TXARCTL_ON|SK_TXARCTL_FSYNC_ON);</a>
<a name="ln3609"> </a>
<a name="ln3610">	/* Configure RAMbuffers */</a>
<a name="ln3611">	SK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_UNRESET);</a>
<a name="ln3612">	SK_IF_WRITE_4(sc_if, 0, SK_RXRB1_START, sc_if-&gt;sk_rx_ramstart);</a>
<a name="ln3613">	SK_IF_WRITE_4(sc_if, 0, SK_RXRB1_WR_PTR, sc_if-&gt;sk_rx_ramstart);</a>
<a name="ln3614">	SK_IF_WRITE_4(sc_if, 0, SK_RXRB1_RD_PTR, sc_if-&gt;sk_rx_ramstart);</a>
<a name="ln3615">	SK_IF_WRITE_4(sc_if, 0, SK_RXRB1_END, sc_if-&gt;sk_rx_ramend);</a>
<a name="ln3616">	SK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_ON);</a>
<a name="ln3617"> </a>
<a name="ln3618">	SK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_UNRESET);</a>
<a name="ln3619">	SK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_STORENFWD_ON);</a>
<a name="ln3620">	SK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_START, sc_if-&gt;sk_tx_ramstart);</a>
<a name="ln3621">	SK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_WR_PTR, sc_if-&gt;sk_tx_ramstart);</a>
<a name="ln3622">	SK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_RD_PTR, sc_if-&gt;sk_tx_ramstart);</a>
<a name="ln3623">	SK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_END, sc_if-&gt;sk_tx_ramend);</a>
<a name="ln3624">	SK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_ON);</a>
<a name="ln3625"> </a>
<a name="ln3626">	/* Configure BMUs */</a>
<a name="ln3627">	SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_ONLINE);</a>
<a name="ln3628">	if (ifp-&gt;if_mtu &gt; SK_MAX_FRAMELEN) {</a>
<a name="ln3629">		SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_CURADDR_LO,</a>
<a name="ln3630">		    SK_ADDR_LO(SK_JUMBO_RX_RING_ADDR(sc_if, 0)));</a>
<a name="ln3631">		SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_CURADDR_HI,</a>
<a name="ln3632">		    SK_ADDR_HI(SK_JUMBO_RX_RING_ADDR(sc_if, 0)));</a>
<a name="ln3633">	} else {</a>
<a name="ln3634">		SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_CURADDR_LO,</a>
<a name="ln3635">		    SK_ADDR_LO(SK_RX_RING_ADDR(sc_if, 0)));</a>
<a name="ln3636">		SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_CURADDR_HI,</a>
<a name="ln3637">		    SK_ADDR_HI(SK_RX_RING_ADDR(sc_if, 0)));</a>
<a name="ln3638">	}</a>
<a name="ln3639"> </a>
<a name="ln3640">	SK_IF_WRITE_4(sc_if, 1, SK_TXQS1_BMU_CSR, SK_TXBMU_ONLINE);</a>
<a name="ln3641">	SK_IF_WRITE_4(sc_if, 1, SK_TXQS1_CURADDR_LO,</a>
<a name="ln3642">	    SK_ADDR_LO(SK_TX_RING_ADDR(sc_if, 0)));</a>
<a name="ln3643">	SK_IF_WRITE_4(sc_if, 1, SK_TXQS1_CURADDR_HI,</a>
<a name="ln3644">	    SK_ADDR_HI(SK_TX_RING_ADDR(sc_if, 0)));</a>
<a name="ln3645"> </a>
<a name="ln3646">	/* Init descriptors */</a>
<a name="ln3647">	if (ifp-&gt;if_mtu &gt; SK_MAX_FRAMELEN)</a>
<a name="ln3648">		error = sk_init_jumbo_rx_ring(sc_if);</a>
<a name="ln3649">	else</a>
<a name="ln3650">		error = sk_init_rx_ring(sc_if);</a>
<a name="ln3651">	if (error != 0) {</a>
<a name="ln3652">		device_printf(sc_if-&gt;sk_if_dev,</a>
<a name="ln3653">		    &quot;initialization failed: no memory for rx buffers\n&quot;);</a>
<a name="ln3654">		sk_stop(sc_if);</a>
<a name="ln3655">		return;</a>
<a name="ln3656">	}</a>
<a name="ln3657">	sk_init_tx_ring(sc_if);</a>
<a name="ln3658"> </a>
<a name="ln3659">	/* Set interrupt moderation if changed via sysctl. */</a>
<a name="ln3660">	imr = sk_win_read_4(sc, SK_IMTIMERINIT);</a>
<a name="ln3661">	if (imr != SK_IM_USECS(sc-&gt;sk_int_mod, sc-&gt;sk_int_ticks)) {</a>
<a name="ln3662">		sk_win_write_4(sc, SK_IMTIMERINIT, SK_IM_USECS(sc-&gt;sk_int_mod,</a>
<a name="ln3663">		    sc-&gt;sk_int_ticks));</a>
<a name="ln3664">		if (bootverbose)</a>
<a name="ln3665">			device_printf(sc_if-&gt;sk_if_dev,</a>
<a name="ln3666">			    &quot;interrupt moderation is %d us.\n&quot;,</a>
<a name="ln3667">			    sc-&gt;sk_int_mod);</a>
<a name="ln3668">	}</a>
<a name="ln3669"> </a>
<a name="ln3670">	/* Configure interrupt handling */</a>
<a name="ln3671">	CSR_READ_4(sc, SK_ISSR);</a>
<a name="ln3672">	if (sc_if-&gt;sk_port == SK_PORT_A)</a>
<a name="ln3673">		sc-&gt;sk_intrmask |= SK_INTRS1;</a>
<a name="ln3674">	else</a>
<a name="ln3675">		sc-&gt;sk_intrmask |= SK_INTRS2;</a>
<a name="ln3676"> </a>
<a name="ln3677">	sc-&gt;sk_intrmask |= SK_ISR_EXTERNAL_REG;</a>
<a name="ln3678"> </a>
<a name="ln3679">	CSR_WRITE_4(sc, SK_IMR, sc-&gt;sk_intrmask);</a>
<a name="ln3680"> </a>
<a name="ln3681">	/* Start BMUs. */</a>
<a name="ln3682">	SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_RX_START);</a>
<a name="ln3683"> </a>
<a name="ln3684">	switch(sc-&gt;sk_type) {</a>
<a name="ln3685">	case SK_GENESIS:</a>
<a name="ln3686">		/* Enable XMACs TX and RX state machines */</a>
<a name="ln3687">		SK_XM_CLRBIT_2(sc_if, XM_MMUCMD, XM_MMUCMD_IGNPAUSE);</a>
<a name="ln3688">		SK_XM_SETBIT_2(sc_if, XM_MMUCMD, XM_MMUCMD_TX_ENB|XM_MMUCMD_RX_ENB);</a>
<a name="ln3689">		break;</a>
<a name="ln3690">	case SK_YUKON:</a>
<a name="ln3691">	case SK_YUKON_LITE:</a>
<a name="ln3692">	case SK_YUKON_LP:</a>
<a name="ln3693">		reg = SK_YU_READ_2(sc_if, YUKON_GPCR);</a>
<a name="ln3694">		reg |= YU_GPCR_TXEN | YU_GPCR_RXEN;</a>
<a name="ln3695">#if 0</a>
<a name="ln3696">		/* XXX disable 100Mbps and full duplex mode? */</a>
<a name="ln3697">		reg &amp;= ~(YU_GPCR_SPEED | YU_GPCR_DPLX_DIS);</a>
<a name="ln3698">#endif</a>
<a name="ln3699">		SK_YU_WRITE_2(sc_if, YUKON_GPCR, reg);</a>
<a name="ln3700">	}</a>
<a name="ln3701"> </a>
<a name="ln3702">	/* Activate descriptor polling timer */</a>
<a name="ln3703">	SK_IF_WRITE_4(sc_if, 0, SK_DPT_TIMER_CTRL, SK_DPT_TCTL_START);</a>
<a name="ln3704">	/* start transfer of Tx descriptors */</a>
<a name="ln3705">	CSR_WRITE_4(sc, sc_if-&gt;sk_tx_bmu, SK_TXBMU_TX_START);</a>
<a name="ln3706"> </a>
<a name="ln3707">	ifp-&gt;if_drv_flags |= IFF_DRV_RUNNING;</a>
<a name="ln3708">	ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_OACTIVE;</a>
<a name="ln3709"> </a>
<a name="ln3710">	switch (sc-&gt;sk_type) {</a>
<a name="ln3711">	case SK_YUKON:</a>
<a name="ln3712">	case SK_YUKON_LITE:</a>
<a name="ln3713">	case SK_YUKON_LP:</a>
<a name="ln3714">		callout_reset(&amp;sc_if-&gt;sk_tick_ch, hz, sk_yukon_tick, sc_if);</a>
<a name="ln3715">		break;</a>
<a name="ln3716">	}</a>
<a name="ln3717"> </a>
<a name="ln3718">	callout_reset(&amp;sc_if-&gt;sk_watchdog_ch, hz, sk_watchdog, ifp);</a>
<a name="ln3719"> </a>
<a name="ln3720">	return;</a>
<a name="ln3721">}</a>
<a name="ln3722"> </a>
<a name="ln3723">static void</a>
<a name="ln3724">sk_stop(sc_if)</a>
<a name="ln3725">	struct sk_if_softc	*sc_if;</a>
<a name="ln3726">{</a>
<a name="ln3727">	int			i;</a>
<a name="ln3728">	struct sk_softc		*sc;</a>
<a name="ln3729">	struct sk_txdesc	*txd;</a>
<a name="ln3730">	struct sk_rxdesc	*rxd;</a>
<a name="ln3731">	struct sk_rxdesc	*jrxd;</a>
<a name="ln3732">	struct ifnet		*ifp;</a>
<a name="ln3733">	u_int32_t		val;</a>
<a name="ln3734"> </a>
<a name="ln3735">	SK_IF_LOCK_ASSERT(sc_if);</a>
<a name="ln3736">	sc = sc_if-&gt;sk_softc;</a>
<a name="ln3737">	ifp = sc_if-&gt;sk_ifp;</a>
<a name="ln3738"> </a>
<a name="ln3739">	callout_stop(&amp;sc_if-&gt;sk_tick_ch);</a>
<a name="ln3740">	callout_stop(&amp;sc_if-&gt;sk_watchdog_ch);</a>
<a name="ln3741"> </a>
<a name="ln3742">	/* stop Tx descriptor polling timer */</a>
<a name="ln3743">	SK_IF_WRITE_4(sc_if, 0, SK_DPT_TIMER_CTRL, SK_DPT_TCTL_STOP);</a>
<a name="ln3744">	/* stop transfer of Tx descriptors */</a>
<a name="ln3745">	CSR_WRITE_4(sc, sc_if-&gt;sk_tx_bmu, SK_TXBMU_TX_STOP);</a>
<a name="ln3746">	for (i = 0; i &lt; SK_TIMEOUT; i++) {</a>
<a name="ln3747">		val = CSR_READ_4(sc, sc_if-&gt;sk_tx_bmu);</a>
<a name="ln3748">		if ((val &amp; SK_TXBMU_TX_STOP) == 0)</a>
<a name="ln3749">			break;</a>
<a name="ln3750">		DELAY(1);</a>
<a name="ln3751">	}</a>
<a name="ln3752">	if (i == SK_TIMEOUT)</a>
<a name="ln3753">		device_printf(sc_if-&gt;sk_if_dev,</a>
<a name="ln3754">		    &quot;can not stop transfer of Tx descriptor\n&quot;);</a>
<a name="ln3755">	/* stop transfer of Rx descriptors */</a>
<a name="ln3756">	SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_RX_STOP);</a>
<a name="ln3757">	for (i = 0; i &lt; SK_TIMEOUT; i++) {</a>
<a name="ln3758">		val = SK_IF_READ_4(sc_if, 0, SK_RXQ1_BMU_CSR);</a>
<a name="ln3759">		if ((val &amp; SK_RXBMU_RX_STOP) == 0)</a>
<a name="ln3760">			break;</a>
<a name="ln3761">		DELAY(1);</a>
<a name="ln3762">	}</a>
<a name="ln3763">	if (i == SK_TIMEOUT)</a>
<a name="ln3764">		device_printf(sc_if-&gt;sk_if_dev,</a>
<a name="ln3765">		    &quot;can not stop transfer of Rx descriptor\n&quot;);</a>
<a name="ln3766"> </a>
<a name="ln3767">	if (sc_if-&gt;sk_phytype == SK_PHYTYPE_BCOM) {</a>
<a name="ln3768">		/* Put PHY back into reset. */</a>
<a name="ln3769">		val = sk_win_read_4(sc, SK_GPIO);</a>
<a name="ln3770">		if (sc_if-&gt;sk_port == SK_PORT_A) {</a>
<a name="ln3771">			val |= SK_GPIO_DIR0;</a>
<a name="ln3772">			val &amp;= ~SK_GPIO_DAT0;</a>
<a name="ln3773">		} else {</a>
<a name="ln3774">			val |= SK_GPIO_DIR2;</a>
<a name="ln3775">			val &amp;= ~SK_GPIO_DAT2;</a>
<a name="ln3776">		}</a>
<a name="ln3777">		sk_win_write_4(sc, SK_GPIO, val);</a>
<a name="ln3778">	}</a>
<a name="ln3779"> </a>
<a name="ln3780">	/* Turn off various components of this interface. */</a>
<a name="ln3781">	SK_XM_SETBIT_2(sc_if, XM_GPIO, XM_GPIO_RESETMAC);</a>
<a name="ln3782">	switch (sc-&gt;sk_type) {</a>
<a name="ln3783">	case SK_GENESIS:</a>
<a name="ln3784">		SK_IF_WRITE_2(sc_if, 0, SK_TXF1_MACCTL, SK_TXMACCTL_XMAC_RESET);</a>
<a name="ln3785">		SK_IF_WRITE_4(sc_if, 0, SK_RXF1_CTL, SK_FIFO_RESET);</a>
<a name="ln3786">		break;</a>
<a name="ln3787">	case SK_YUKON:</a>
<a name="ln3788">	case SK_YUKON_LITE:</a>
<a name="ln3789">	case SK_YUKON_LP:</a>
<a name="ln3790">		SK_IF_WRITE_1(sc_if,0, SK_RXMF1_CTRL_TEST, SK_RFCTL_RESET_SET);</a>
<a name="ln3791">		SK_IF_WRITE_1(sc_if,0, SK_TXMF1_CTRL_TEST, SK_TFCTL_RESET_SET);</a>
<a name="ln3792">		break;</a>
<a name="ln3793">	}</a>
<a name="ln3794">	SK_IF_WRITE_4(sc_if, 0, SK_RXQ1_BMU_CSR, SK_RXBMU_OFFLINE);</a>
<a name="ln3795">	SK_IF_WRITE_4(sc_if, 0, SK_RXRB1_CTLTST, SK_RBCTL_RESET|SK_RBCTL_OFF);</a>
<a name="ln3796">	SK_IF_WRITE_4(sc_if, 1, SK_TXQS1_BMU_CSR, SK_TXBMU_OFFLINE);</a>
<a name="ln3797">	SK_IF_WRITE_4(sc_if, 1, SK_TXRBS1_CTLTST, SK_RBCTL_RESET|SK_RBCTL_OFF);</a>
<a name="ln3798">	SK_IF_WRITE_1(sc_if, 0, SK_TXAR1_COUNTERCTL, SK_TXARCTL_OFF);</a>
<a name="ln3799">	SK_IF_WRITE_1(sc_if, 0, SK_RXLED1_CTL, SK_RXLEDCTL_COUNTER_STOP);</a>
<a name="ln3800">	SK_IF_WRITE_1(sc_if, 0, SK_TXLED1_CTL, SK_RXLEDCTL_COUNTER_STOP);</a>
<a name="ln3801">	SK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_OFF);</a>
<a name="ln3802">	SK_IF_WRITE_1(sc_if, 0, SK_LINKLED1_CTL, SK_LINKLED_LINKSYNC_OFF);</a>
<a name="ln3803"> </a>
<a name="ln3804">	/* Disable interrupts */</a>
<a name="ln3805">	if (sc_if-&gt;sk_port == SK_PORT_A)</a>
<a name="ln3806">		sc-&gt;sk_intrmask &amp;= ~SK_INTRS1;</a>
<a name="ln3807">	else</a>
<a name="ln3808">		sc-&gt;sk_intrmask &amp;= ~SK_INTRS2;</a>
<a name="ln3809">	CSR_WRITE_4(sc, SK_IMR, sc-&gt;sk_intrmask);</a>
<a name="ln3810"> </a>
<a name="ln3811">	SK_XM_READ_2(sc_if, XM_ISR);</a>
<a name="ln3812">	SK_XM_WRITE_2(sc_if, XM_IMR, 0xFFFF);</a>
<a name="ln3813"> </a>
<a name="ln3814">	/* Free RX and TX mbufs still in the queues. */</a>
<a name="ln3815">	for (i = 0; i &lt; SK_RX_RING_CNT; i++) {</a>
<a name="ln3816">		rxd = &amp;sc_if-&gt;sk_cdata.sk_rxdesc[i];</a>
<a name="ln3817">		if (rxd-&gt;rx_m != NULL) {</a>
<a name="ln3818">			bus_dmamap_sync(sc_if-&gt;sk_cdata.sk_rx_tag,</a>
<a name="ln3819">			    rxd-&gt;rx_dmamap, BUS_DMASYNC_POSTREAD);</a>
<a name="ln3820">			bus_dmamap_unload(sc_if-&gt;sk_cdata.sk_rx_tag,</a>
<a name="ln3821">			    rxd-&gt;rx_dmamap);</a>
<a name="ln3822">			m_freem(rxd-&gt;rx_m);</a>
<a name="ln3823">			rxd-&gt;rx_m = NULL;</a>
<a name="ln3824">		}</a>
<a name="ln3825">	}</a>
<a name="ln3826">	for (i = 0; i &lt; SK_JUMBO_RX_RING_CNT; i++) {</a>
<a name="ln3827">		jrxd = &amp;sc_if-&gt;sk_cdata.sk_jumbo_rxdesc[i];</a>
<a name="ln3828">		if (jrxd-&gt;rx_m != NULL) {</a>
<a name="ln3829">			bus_dmamap_sync(sc_if-&gt;sk_cdata.sk_jumbo_rx_tag,</a>
<a name="ln3830">			    jrxd-&gt;rx_dmamap, BUS_DMASYNC_POSTREAD);</a>
<a name="ln3831">			bus_dmamap_unload(sc_if-&gt;sk_cdata.sk_jumbo_rx_tag,</a>
<a name="ln3832">			    jrxd-&gt;rx_dmamap);</a>
<a name="ln3833">			m_freem(jrxd-&gt;rx_m);</a>
<a name="ln3834">			jrxd-&gt;rx_m = NULL;</a>
<a name="ln3835">		}</a>
<a name="ln3836">	}</a>
<a name="ln3837">	for (i = 0; i &lt; SK_TX_RING_CNT; i++) {</a>
<a name="ln3838">		txd = &amp;sc_if-&gt;sk_cdata.sk_txdesc[i];</a>
<a name="ln3839">		if (txd-&gt;tx_m != NULL) {</a>
<a name="ln3840">			bus_dmamap_sync(sc_if-&gt;sk_cdata.sk_tx_tag,</a>
<a name="ln3841">			    txd-&gt;tx_dmamap, BUS_DMASYNC_POSTWRITE);</a>
<a name="ln3842">			bus_dmamap_unload(sc_if-&gt;sk_cdata.sk_tx_tag,</a>
<a name="ln3843">			    txd-&gt;tx_dmamap);</a>
<a name="ln3844">			m_freem(txd-&gt;tx_m);</a>
<a name="ln3845">			txd-&gt;tx_m = NULL;</a>
<a name="ln3846">		}</a>
<a name="ln3847">	}</a>
<a name="ln3848"> </a>
<a name="ln3849">	ifp-&gt;if_drv_flags &amp;= ~(IFF_DRV_RUNNING|IFF_DRV_OACTIVE);</a>
<a name="ln3850"> </a>
<a name="ln3851">	return;</a>
<a name="ln3852">}</a>
<a name="ln3853"> </a>
<a name="ln3854">static int</a>
<a name="ln3855">sysctl_int_range(SYSCTL_HANDLER_ARGS, int low, int high)</a>
<a name="ln3856">{</a>
<a name="ln3857">	int error, value;</a>
<a name="ln3858"> </a>
<a name="ln3859">	if (!arg1)</a>
<a name="ln3860">		return (EINVAL);</a>
<a name="ln3861">	value = *(int *)arg1;</a>
<a name="ln3862">	error = sysctl_handle_int(oidp, &amp;value, 0, req);</a>
<a name="ln3863">	if (error || !req-&gt;newptr)</a>
<a name="ln3864">		return (error);</a>
<a name="ln3865">	if (value &lt; low || value &gt; high)</a>
<a name="ln3866">		return (EINVAL);</a>
<a name="ln3867">	*(int *)arg1 = value;</a>
<a name="ln3868">	return (0);</a>
<a name="ln3869">}</a>
<a name="ln3870"> </a>
<a name="ln3871">static int</a>
<a name="ln3872">sysctl_hw_sk_int_mod(SYSCTL_HANDLER_ARGS)</a>
<a name="ln3873">{</a>
<a name="ln3874">	return (sysctl_int_range(oidp, arg1, arg2, req, SK_IM_MIN, SK_IM_MAX));</a>
<a name="ln3875">}</a>

</code></pre>
<div class="balloon" rel="3171"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'ifp0' pointer was utilized before it was verified against nullptr. Check lines: 3171, 3187.</p></div>
<div class="balloon" rel="3179"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'ifp1' pointer was utilized before it was verified against nullptr. Check lines: 3179, 3190.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
