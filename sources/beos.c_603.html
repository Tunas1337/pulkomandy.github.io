
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>beos.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">  Copyright (c) 1990-2002 Info-ZIP.  All rights reserved.</a>
<a name="ln3"> </a>
<a name="ln4">  See the accompanying file LICENSE, version 2000-Apr-09 or later</a>
<a name="ln5">  (the contents of which are also included in unzip.h) for terms of use.</a>
<a name="ln6">  If, for some reason, all these files are missing, the Info-ZIP license</a>
<a name="ln7">  also may be found at:  ftp://ftp.info-zip.org/pub/infozip/license.html</a>
<a name="ln8">*/</a>
<a name="ln9">/*---------------------------------------------------------------------------</a>
<a name="ln10"> </a>
<a name="ln11">  beos.c</a>
<a name="ln12"> </a>
<a name="ln13">  BeOS-specific routines for use with Info-ZIP's UnZip 5.30 and later.</a>
<a name="ln14">  (based on unix/unix.c)</a>
<a name="ln15"> </a>
<a name="ln16">  Contains:  do_wild()           &lt;-- generic enough to put in fileio.c?</a>
<a name="ln17">             mapattr()</a>
<a name="ln18">             mapname()</a>
<a name="ln19">             checkdir()</a>
<a name="ln20">             close_outfile()</a>
<a name="ln21">             set_direc_attribs()</a>
<a name="ln22">             stamp_file()</a>
<a name="ln23">             version()</a>
<a name="ln24">             scanBeOSexfield()</a>
<a name="ln25">             set_file_attrs()</a>
<a name="ln26">             setBeOSexfield()</a>
<a name="ln27">             printBeOSexfield()</a>
<a name="ln28">             assign_MIME()</a>
<a name="ln29"> </a>
<a name="ln30">  ---------------------------------------------------------------------------*/</a>
<a name="ln31"> </a>
<a name="ln32"> </a>
<a name="ln33">#define UNZIP_INTERNAL</a>
<a name="ln34">#include &quot;unzip.h&quot;</a>
<a name="ln35"> </a>
<a name="ln36">#include &quot;beos.h&quot;</a>
<a name="ln37">#include &lt;errno.h&gt;             /* Just make sure we've got a few things... */</a>
<a name="ln38">#include &lt;sys/types.h&gt;</a>
<a name="ln39">#include &lt;sys/stat.h&gt;</a>
<a name="ln40">#include &lt;fcntl.h&gt;</a>
<a name="ln41"> </a>
<a name="ln42">#include &lt;dirent.h&gt;</a>
<a name="ln43"> </a>
<a name="ln44">/* For the new post-DR8 file attributes */</a>
<a name="ln45">#include &lt;fs_attr.h&gt;</a>
<a name="ln46">#include &lt;ByteOrder.h&gt;</a>
<a name="ln47">#include &lt;Mime.h&gt;</a>
<a name="ln48"> </a>
<a name="ln49">static uch *scanBeOSexfield  OF((const uch *ef_ptr, unsigned ef_len));</a>
<a name="ln50">static int  set_file_attrs( const char *, const unsigned char *, const off_t );</a>
<a name="ln51">static void setBeOSexfield   OF((const char *path, uch *extra_field));</a>
<a name="ln52">#ifdef BEOS_USE_PRINTEXFIELD</a>
<a name="ln53">static void printBeOSexfield OF((int isdir, uch *extra_field));</a>
<a name="ln54">#endif</a>
<a name="ln55">#ifdef BEOS_ASSIGN_FILETYPE</a>
<a name="ln56">static void assign_MIME( const char * );</a>
<a name="ln57">#endif</a>
<a name="ln58"> </a>
<a name="ln59">#ifdef ACORN_FTYPE_NFS</a>
<a name="ln60">/* Acorn bits for NFS filetyping */</a>
<a name="ln61">typedef struct {</a>
<a name="ln62">  uch ID[2];</a>
<a name="ln63">  uch size[2];</a>
<a name="ln64">  uch ID_2[4];</a>
<a name="ln65">  uch loadaddr[4];</a>
<a name="ln66">  uch execaddr[4];</a>
<a name="ln67">  uch attr[4];</a>
<a name="ln68">} RO_extra_block;</a>
<a name="ln69"> </a>
<a name="ln70">#endif /* ACORN_FTYPE_NFS */</a>
<a name="ln71"> </a>
<a name="ln72">static int created_dir;        /* used in mapname(), checkdir() */</a>
<a name="ln73">static int renamed_fullpath;   /* ditto */</a>
<a name="ln74"> </a>
<a name="ln75">#ifndef SFX</a>
<a name="ln76"> </a>
<a name="ln77">/**********************/</a>
<a name="ln78">/* Function do_wild() */   /* for porting:  dir separator; match(ignore_case) */</a>
<a name="ln79">/**********************/</a>
<a name="ln80"> </a>
<a name="ln81">char *do_wild(__G__ wildspec)</a>
<a name="ln82">    __GDEF</a>
<a name="ln83">    ZCONST char *wildspec;  /* only used first time on a given dir */</a>
<a name="ln84">{</a>
<a name="ln85">    static DIR *wild_dir = (DIR *)NULL;</a>
<a name="ln86">    static ZCONST char *wildname;</a>
<a name="ln87">    static char *dirname, matchname[FILNAMSIZ];</a>
<a name="ln88">    static int notfirstcall=FALSE, have_dirname, dirnamelen;</a>
<a name="ln89">    struct dirent *file;</a>
<a name="ln90"> </a>
<a name="ln91">    /* Even when we're just returning wildspec, we *always* do so in</a>
<a name="ln92">     * matchname[]--calling routine is allowed to append four characters</a>
<a name="ln93">     * to the returned string, and wildspec may be a pointer to argv[].</a>
<a name="ln94">     */</a>
<a name="ln95">    if (!notfirstcall) {    /* first call:  must initialize everything */</a>
<a name="ln96">        notfirstcall = TRUE;</a>
<a name="ln97"> </a>
<a name="ln98">        if (!iswild(wildspec)) {</a>
<a name="ln99">            strcpy(matchname, wildspec);</a>
<a name="ln100">            have_dirname = FALSE;</a>
<a name="ln101">            wild_dir = NULL;</a>
<a name="ln102">            return matchname;</a>
<a name="ln103">        }</a>
<a name="ln104"> </a>
<a name="ln105">        /* break the wildspec into a directory part and a wildcard filename */</a>
<a name="ln106">        if ((wildname = strrchr(wildspec, '/')) == (ZCONST char *)NULL) {</a>
<a name="ln107">            dirname = &quot;.&quot;;</a>
<a name="ln108">            dirnamelen = 1;</a>
<a name="ln109">            have_dirname = FALSE;</a>
<a name="ln110">            wildname = wildspec;</a>
<a name="ln111">        } else {</a>
<a name="ln112">            ++wildname;     /* point at character after '/' */</a>
<a name="ln113">            dirnamelen = wildname - wildspec;</a>
<a name="ln114">            if ((dirname = (char *)malloc(dirnamelen+1)) == (char *)NULL) {</a>
<a name="ln115">                Info(slide, 0x201, ((char *)slide,</a>
<a name="ln116">                  &quot;warning:  cannot allocate wildcard buffers\n&quot;));</a>
<a name="ln117">                strcpy(matchname, wildspec);</a>
<a name="ln118">                return matchname;   /* but maybe filespec was not a wildcard */</a>
<a name="ln119">            }</a>
<a name="ln120">            strncpy(dirname, wildspec, dirnamelen);</a>
<a name="ln121">            dirname[dirnamelen] = '\0';   /* terminate for strcpy below */</a>
<a name="ln122">            have_dirname = TRUE;</a>
<a name="ln123">        }</a>
<a name="ln124"> </a>
<a name="ln125">        if ((wild_dir = opendir(dirname)) != (DIR *)NULL) {</a>
<a name="ln126">            while ((file = readdir(wild_dir)) != (struct dirent *)NULL) {</a>
<a name="ln127">                if (file-&gt;d_name[0] == '.' &amp;&amp; wildname[0] != '.')</a>
<a name="ln128">                    continue;  /* Unix:  '*' and '?' do not match leading dot */</a>
<a name="ln129">                if (match(file-&gt;d_name, wildname, 0)) {  /* 0 == case sens. */</a>
<a name="ln130">                    if (have_dirname) {</a>
<a name="ln131">                        strcpy(matchname, dirname);</a>
<a name="ln132">                        strcpy(matchname+dirnamelen, file-&gt;d_name);</a>
<a name="ln133">                    } else</a>
<a name="ln134">                        strcpy(matchname, file-&gt;d_name);</a>
<a name="ln135">                    return matchname;</a>
<a name="ln136">                }</a>
<a name="ln137">            }</a>
<a name="ln138">            /* if we get to here directory is exhausted, so close it */</a>
<a name="ln139">            closedir(wild_dir);</a>
<a name="ln140">            wild_dir = (DIR *)NULL;</a>
<a name="ln141">        }</a>
<a name="ln142"> </a>
<a name="ln143">        /* return the raw wildspec in case that works (e.g., directory not</a>
<a name="ln144">         * searchable, but filespec was not wild and file is readable) */</a>
<a name="ln145">        strcpy(matchname, wildspec);</a>
<a name="ln146">        return matchname;</a>
<a name="ln147">    }</a>
<a name="ln148"> </a>
<a name="ln149">    /* last time through, might have failed opendir but returned raw wildspec */</a>
<a name="ln150">    if (wild_dir == (DIR *)NULL) {</a>
<a name="ln151">        notfirstcall = FALSE; /* nothing left to try--reset for new wildspec */</a>
<a name="ln152">        if (have_dirname)</a>
<a name="ln153">            free(dirname);</a>
<a name="ln154">        return (char *)NULL;</a>
<a name="ln155">    }</a>
<a name="ln156"> </a>
<a name="ln157">    /* If we've gotten this far, we've read and matched at least one entry</a>
<a name="ln158">     * successfully (in a previous call), so dirname has been copied into</a>
<a name="ln159">     * matchname already.</a>
<a name="ln160">     */</a>
<a name="ln161">    while ((file = readdir(wild_dir)) != (struct dirent *)NULL) {</a>
<a name="ln162">        if (file-&gt;d_name[0] == '.' &amp;&amp; wildname[0] != '.')</a>
<a name="ln163">            continue;   /* Unix:  '*' and '?' do not match leading dot */</a>
<a name="ln164">        if (match(file-&gt;d_name, wildname, 0)) {   /* 0 == don't ignore case */</a>
<a name="ln165">            if (have_dirname) {</a>
<a name="ln166">                /* strcpy(matchname, dirname); */</a>
<a name="ln167">                strcpy(matchname+dirnamelen, file-&gt;d_name);</a>
<a name="ln168">            } else</a>
<a name="ln169">                strcpy(matchname, file-&gt;d_name);</a>
<a name="ln170">            return matchname;</a>
<a name="ln171">        }</a>
<a name="ln172">    }</a>
<a name="ln173"> </a>
<a name="ln174">    closedir(wild_dir);     /* have read at least one entry; nothing left */</a>
<a name="ln175">    wild_dir = (DIR *)NULL;</a>
<a name="ln176">    notfirstcall = FALSE;   /* reset for new wildspec */</a>
<a name="ln177">    if (have_dirname)</a>
<a name="ln178">        free(dirname);</a>
<a name="ln179">    return (char *)NULL;</a>
<a name="ln180"> </a>
<a name="ln181">} /* end function do_wild() */</a>
<a name="ln182"> </a>
<a name="ln183">#endif /* !SFX */</a>
<a name="ln184"> </a>
<a name="ln185"> </a>
<a name="ln186"> </a>
<a name="ln187"> </a>
<a name="ln188"> </a>
<a name="ln189">/**********************/</a>
<a name="ln190">/* Function mapattr() */</a>
<a name="ln191">/**********************/</a>
<a name="ln192"> </a>
<a name="ln193">int mapattr(__G)</a>
<a name="ln194">    __GDEF</a>
<a name="ln195">{</a>
<a name="ln196">    ulg tmp = G.crec.external_file_attributes;</a>
<a name="ln197"> </a>
<a name="ln198">    switch (G.pInfo-&gt;hostnum) {</a>
<a name="ln199">        case AMIGA_:</a>
<a name="ln200">            tmp = (unsigned)(tmp&gt;&gt;17 &amp; 7);   /* Amiga RWE bits */</a>
<a name="ln201">            G.pInfo-&gt;file_attr = (unsigned)(tmp&lt;&lt;6 | tmp&lt;&lt;3 | tmp);</a>
<a name="ln202">            break;</a>
<a name="ln203">        case THEOS_:</a>
<a name="ln204">            tmp &amp;= 0xF1FFFFFFL;</a>
<a name="ln205">            if ((tmp &amp; 0xF0000000L) != 0x40000000L)</a>
<a name="ln206">                tmp &amp;= 0x01FFFFFFL;     /* not a dir, mask all ftype bits */</a>
<a name="ln207">            else</a>
<a name="ln208">                tmp &amp;= 0x41FFFFFFL;     /* leave directory bit as set */</a>
<a name="ln209">            /* fall through! */</a>
<a name="ln210">        case BEOS_:</a>
<a name="ln211">        case UNIX_:</a>
<a name="ln212">        case VMS_:</a>
<a name="ln213">        case ACORN_:</a>
<a name="ln214">        case ATARI_:</a>
<a name="ln215">        case QDOS_:</a>
<a name="ln216">        case TANDEM_:</a>
<a name="ln217">            G.pInfo-&gt;file_attr = (unsigned)(tmp &gt;&gt; 16);</a>
<a name="ln218">            if (G.pInfo-&gt;file_attr != 0 || !G.extra_field) {</a>
<a name="ln219">                return 0;</a>
<a name="ln220">            } else {</a>
<a name="ln221">                /* Some (non-Info-ZIP) implementations of Zip for Unix and</a>
<a name="ln222">                   VMS (and probably others ??) leave 0 in the upper 16-bit</a>
<a name="ln223">                   part of the external_file_attributes field. Instead, they</a>
<a name="ln224">                   store file permission attributes in some extra field.</a>
<a name="ln225">                   As a work-around, we search for the presence of one of</a>
<a name="ln226">                   these extra fields and fall back to the MSDOS compatible</a>
<a name="ln227">                   part of external_file_attributes if one of the known</a>
<a name="ln228">                   e.f. types has been detected.</a>
<a name="ln229">                   Later, we might implement extraction of the permission</a>
<a name="ln230">                   bits from the VMS extra field. But for now, the work-around</a>
<a name="ln231">                   should be sufficient to provide &quot;readable&quot; extracted files.</a>
<a name="ln232">                   (For ASI Unix e.f., an experimental remap of the e.f.</a>
<a name="ln233">                   mode value IS already provided!)</a>
<a name="ln234">                 */</a>
<a name="ln235">                ush ebID;</a>
<a name="ln236">                unsigned ebLen;</a>
<a name="ln237">                uch *ef = G.extra_field;</a>
<a name="ln238">                unsigned ef_len = G.crec.extra_field_length;</a>
<a name="ln239">                int r = FALSE;</a>
<a name="ln240"> </a>
<a name="ln241">                while (!r &amp;&amp; ef_len &gt;= EB_HEADSIZE) {</a>
<a name="ln242">                    ebID = makeword(ef);</a>
<a name="ln243">                    ebLen = (unsigned)makeword(ef+EB_LEN);</a>
<a name="ln244">                    if (ebLen &gt; (ef_len - EB_HEADSIZE))</a>
<a name="ln245">                        /* discoverd some e.f. inconsistency! */</a>
<a name="ln246">                        break;</a>
<a name="ln247">                    switch (ebID) {</a>
<a name="ln248">                      case EF_ASIUNIX:</a>
<a name="ln249">                        if (ebLen &gt;= (EB_ASI_MODE+2)) {</a>
<a name="ln250">                            G.pInfo-&gt;file_attr =</a>
<a name="ln251">                              (unsigned)makeword(ef+(EB_HEADSIZE+EB_ASI_MODE));</a>
<a name="ln252">                            /* force stop of loop: */</a>
<a name="ln253">                            ef_len = (ebLen + EB_HEADSIZE);</a>
<a name="ln254">                            break;</a>
<a name="ln255">                        }</a>
<a name="ln256">                        /* else: fall through! */</a>
<a name="ln257">                      case EF_PKVMS:</a>
<a name="ln258">                        /* &quot;found nondecypherable e.f. with perm. attr&quot; */</a>
<a name="ln259">                        r = TRUE;</a>
<a name="ln260">                      default:</a>
<a name="ln261">                        break;</a>
<a name="ln262">                    }</a>
<a name="ln263">                    ef_len -= (ebLen + EB_HEADSIZE);</a>
<a name="ln264">                    ef += (ebLen + EB_HEADSIZE);</a>
<a name="ln265">                }</a>
<a name="ln266">                if (!r)</a>
<a name="ln267">                    return 0;</a>
<a name="ln268">            }</a>
<a name="ln269">            /* fall through! */</a>
<a name="ln270">        /* all remaining cases:  expand MSDOS read-only bit into write perms */</a>
<a name="ln271">        case FS_FAT_:</a>
<a name="ln272">            /* PKWARE's PKZip for Unix marks entries as FS_FAT_, but stores the</a>
<a name="ln273">             * Unix attributes in the upper 16 bits of the external attributes</a>
<a name="ln274">             * field, just like Info-ZIP's Zip for Unix.  We try to use that</a>
<a name="ln275">             * value, after a check for consistency with the MSDOS attribute</a>
<a name="ln276">             * bits (see below).</a>
<a name="ln277">             */</a>
<a name="ln278">            G.pInfo-&gt;file_attr = (unsigned)(tmp &gt;&gt; 16);</a>
<a name="ln279">            /* fall through! */</a>
<a name="ln280">        case FS_HPFS_:</a>
<a name="ln281">        case FS_NTFS_:</a>
<a name="ln282">        case MAC_:</a>
<a name="ln283">        case TOPS20_:</a>
<a name="ln284">        default:</a>
<a name="ln285">            /* Ensure that DOS subdir bit is set when the entry's name ends</a>
<a name="ln286">             * in a '/'.  Some third-party Zip programs fail to set the subdir</a>
<a name="ln287">             * bit for directory entries.</a>
<a name="ln288">             */</a>
<a name="ln289">            if ((tmp &amp; 0x10) == 0) {</a>
<a name="ln290">                extent fnlen = strlen(G.filename);</a>
<a name="ln291">                if (fnlen &gt; 0 &amp;&amp; G.filename[fnlen-1] == '/')</a>
<a name="ln292">                    tmp |= 0x10;</a>
<a name="ln293">            }</a>
<a name="ln294">            /* read-only bit --&gt; write perms; subdir bit --&gt; dir exec bit */</a>
<a name="ln295">            tmp = !(tmp &amp; 1) &lt;&lt; 1  |  (tmp &amp; 0x10) &gt;&gt; 4;</a>
<a name="ln296">            if ((G.pInfo-&gt;file_attr &amp; 0700) == (unsigned)(0400 | tmp&lt;&lt;6))</a>
<a name="ln297">                /* keep previous G.pInfo-&gt;file_attr setting, when its &quot;owner&quot;</a>
<a name="ln298">                 * part appears to be consistent with DOS attribute flags!</a>
<a name="ln299">                 */</a>
<a name="ln300">                return 0;</a>
<a name="ln301">            G.pInfo-&gt;file_attr = (unsigned)(0444 | tmp&lt;&lt;6 | tmp&lt;&lt;3 | tmp);</a>
<a name="ln302">            break;</a>
<a name="ln303">    } /* end switch (host-OS-created-by) */</a>
<a name="ln304"> </a>
<a name="ln305">    /* for originating systems with no concept of &quot;group,&quot; &quot;other,&quot; &quot;system&quot;: */</a>
<a name="ln306">    umask( (int)(tmp=umask(0)) );    /* apply mask to expanded r/w(/x) perms */</a>
<a name="ln307">    G.pInfo-&gt;file_attr &amp;= ~tmp;</a>
<a name="ln308"> </a>
<a name="ln309">    return 0;</a>
<a name="ln310"> </a>
<a name="ln311">} /* end function mapattr() */</a>
<a name="ln312"> </a>
<a name="ln313"> </a>
<a name="ln314"> </a>
<a name="ln315"> </a>
<a name="ln316"> </a>
<a name="ln317">/************************/</a>
<a name="ln318">/*  Function mapname()  */</a>
<a name="ln319">/************************/</a>
<a name="ln320"> </a>
<a name="ln321">int mapname(__G__ renamed)</a>
<a name="ln322">    __GDEF</a>
<a name="ln323">    int renamed;</a>
<a name="ln324">/*</a>
<a name="ln325"> * returns:</a>
<a name="ln326"> *  MPN_OK          - no problem detected</a>
<a name="ln327"> *  MPN_INF_TRUNC   - caution (truncated filename)</a>
<a name="ln328"> *  MPN_INF_SKIP    - info &quot;skip entry&quot; (dir doesn't exist)</a>
<a name="ln329"> *  MPN_ERR_SKIP    - error -&gt; skip entry</a>
<a name="ln330"> *  MPN_ERR_TOOLONG - error -&gt; path is too long</a>
<a name="ln331"> *  MPN_NOMEM       - error (memory allocation failed) -&gt; skip entry</a>
<a name="ln332"> *  [also MPN_VOL_LABEL, MPN_CREATED_DIR]</a>
<a name="ln333"> */</a>
<a name="ln334">{</a>
<a name="ln335">    char pathcomp[FILNAMSIZ];      /* path-component buffer */</a>
<a name="ln336">    char *pp, *cp=(char *)NULL;    /* character pointers */</a>
<a name="ln337">    char *lastsemi=(char *)NULL;   /* pointer to last semi-colon in pathcomp */</a>
<a name="ln338">#ifdef ACORN_FTYPE_NFS</a>
<a name="ln339">    char *lastcomma=(char *)NULL;  /* pointer to last comma in pathcomp */</a>
<a name="ln340">    RO_extra_block *ef_spark;      /* pointer Acorn FTYPE ef block */</a>
<a name="ln341">#endif</a>
<a name="ln342">    int quote = FALSE;             /* flags */</a>
<a name="ln343">    int killed_ddot = FALSE;       /* is set when skipping &quot;../&quot; pathcomp */</a>
<a name="ln344">    int error = MPN_OK;</a>
<a name="ln345">    register unsigned workch;      /* hold the character being tested */</a>
<a name="ln346"> </a>
<a name="ln347"> </a>
<a name="ln348">/*---------------------------------------------------------------------------</a>
<a name="ln349">    Initialize various pointers and counters and stuff.</a>
<a name="ln350">  ---------------------------------------------------------------------------*/</a>
<a name="ln351"> </a>
<a name="ln352">    if (G.pInfo-&gt;vollabel)</a>
<a name="ln353">        return MPN_VOL_LABEL;   /* can't set disk volume labels in BeOS */</a>
<a name="ln354"> </a>
<a name="ln355">    /* can create path as long as not just freshening, or if user told us */</a>
<a name="ln356">    G.create_dirs = (!uO.fflag || renamed);</a>
<a name="ln357"> </a>
<a name="ln358">    created_dir = FALSE;        /* not yet */</a>
<a name="ln359"> </a>
<a name="ln360">    /* user gave full pathname:  don't prepend rootpath */</a>
<a name="ln361">    renamed_fullpath = (renamed &amp;&amp; (*G.filename == '/'));</a>
<a name="ln362"> </a>
<a name="ln363">    if (checkdir(__G__ (char *)NULL, INIT) == MPN_NOMEM)</a>
<a name="ln364">        return MPN_NOMEM;       /* initialize path buffer, unless no memory */</a>
<a name="ln365"> </a>
<a name="ln366">    *pathcomp = '\0';           /* initialize translation buffer */</a>
<a name="ln367">    pp = pathcomp;              /* point to translation buffer */</a>
<a name="ln368">    if (uO.jflag)               /* junking directories */</a>
<a name="ln369">        cp = (char *)strrchr(G.filename, '/');</a>
<a name="ln370">    if (cp == (char *)NULL)     /* no '/' or not junking dirs */</a>
<a name="ln371">        cp = G.filename;        /* point to internal zipfile-member pathname */</a>
<a name="ln372">    else</a>
<a name="ln373">        ++cp;                   /* point to start of last component of path */</a>
<a name="ln374"> </a>
<a name="ln375">/*---------------------------------------------------------------------------</a>
<a name="ln376">    Begin main loop through characters in filename.</a>
<a name="ln377">  ---------------------------------------------------------------------------*/</a>
<a name="ln378"> </a>
<a name="ln379">    while ((workch = (uch)*cp++) != 0) {</a>
<a name="ln380"> </a>
<a name="ln381">        if (quote) {                 /* if character quoted, */</a>
<a name="ln382">            *pp++ = (char)workch;    /*  include it literally */</a>
<a name="ln383">            quote = FALSE;</a>
<a name="ln384">        } else</a>
<a name="ln385">            switch (workch) {</a>
<a name="ln386">            case '/':             /* can assume -j flag not given */</a>
<a name="ln387">                *pp = '\0';</a>
<a name="ln388">                if (((error = checkdir(__G__ pathcomp, APPEND_DIR)) &amp; MPN_MASK)</a>
<a name="ln389">                     &gt; MPN_INF_TRUNC)</a>
<a name="ln390">                    return error;</a>
<a name="ln391">                pp = pathcomp;    /* reset conversion buffer for next piece */</a>
<a name="ln392">                lastsemi = (char *)NULL; /* leave directory semi-colons alone */</a>
<a name="ln393">                break;</a>
<a name="ln394"> </a>
<a name="ln395">            case '.':</a>
<a name="ln396">                if (pp == pathcomp) {   /* nothing appended yet... */</a>
<a name="ln397">                    if (*cp == '/') {   /* don't bother appending &quot;./&quot; to */</a>
<a name="ln398">                        ++cp;           /*  the path: skip behind the '/' */</a>
<a name="ln399">                        break;</a>
<a name="ln400">                    } else if (!uO.ddotflag &amp;&amp; *cp == '.' &amp;&amp; cp[1] == '/') {</a>
<a name="ln401">                        /* &quot;../&quot; dir traversal detected */</a>
<a name="ln402">                        cp += 2;        /*  skip over behind the '/' */</a>
<a name="ln403">                        killed_ddot = TRUE; /*  set &quot;show message&quot; flag */</a>
<a name="ln404">                        break;</a>
<a name="ln405">                    }</a>
<a name="ln406">                }</a>
<a name="ln407">                *pp++ = '.';</a>
<a name="ln408">                break;</a>
<a name="ln409"> </a>
<a name="ln410">            case ';':             /* VMS version (or DEC-20 attrib?) */</a>
<a name="ln411">                lastsemi = pp;</a>
<a name="ln412">                *pp++ = ';';      /* keep for now; remove VMS &quot;;##&quot; */</a>
<a name="ln413">                break;            /*  later, if requested */</a>
<a name="ln414"> </a>
<a name="ln415">#ifdef ACORN_FTYPE_NFS</a>
<a name="ln416">            case ',':             /* NFS filetype extension */</a>
<a name="ln417">                lastcomma = pp;</a>
<a name="ln418">                *pp++ = ',';      /* keep for now; may need to remove */</a>
<a name="ln419">                break;            /*  later, if requested */</a>
<a name="ln420">#endif</a>
<a name="ln421"> </a>
<a name="ln422">            case '\026':          /* control-V quote for special chars */</a>
<a name="ln423">                quote = TRUE;     /* set flag for next character */</a>
<a name="ln424">                break;</a>
<a name="ln425"> </a>
<a name="ln426">            default:</a>
<a name="ln427">                /* allow European characters in filenames: */</a>
<a name="ln428">                if (isprint(workch) || (128 &lt;= workch &amp;&amp; workch &lt;= 254))</a>
<a name="ln429">                    *pp++ = (char)workch;</a>
<a name="ln430">            } /* end switch */</a>
<a name="ln431"> </a>
<a name="ln432">    } /* end while loop */</a>
<a name="ln433"> </a>
<a name="ln434">    /* Show warning when stripping insecure &quot;parent dir&quot; path components */</a>
<a name="ln435">    if (killed_ddot &amp;&amp; QCOND2) {</a>
<a name="ln436">        Info(slide, 0, ((char *)slide,</a>
<a name="ln437">          &quot;warning:  skipped \&quot;../\&quot; path component(s) in %s\n&quot;,</a>
<a name="ln438">          FnFilter1(G.filename)));</a>
<a name="ln439">        if (!(error &amp; ~MPN_MASK))</a>
<a name="ln440">            error = (error &amp; MPN_MASK) | PK_WARN;</a>
<a name="ln441">    }</a>
<a name="ln442"> </a>
<a name="ln443">/*---------------------------------------------------------------------------</a>
<a name="ln444">    Report if directory was created (and no file to create:  filename ended</a>
<a name="ln445">    in '/'), check name to be sure it exists, and combine path and name be-</a>
<a name="ln446">    fore exiting.</a>
<a name="ln447">  ---------------------------------------------------------------------------*/</a>
<a name="ln448"> </a>
<a name="ln449">    if (G.filename[strlen(G.filename) - 1] == '/') {</a>
<a name="ln450">        checkdir(__G__ G.filename, GETPATH);</a>
<a name="ln451">        if (created_dir) {</a>
<a name="ln452">            if (QCOND2) {</a>
<a name="ln453">                Info(slide, 0, ((char *)slide, &quot;   creating: %s\n&quot;,</a>
<a name="ln454">                  FnFilter1(G.filename)));</a>
<a name="ln455">            }</a>
<a name="ln456"> </a>
<a name="ln457">            if (!uO.J_flag) {   /* Handle the BeOS extra field if present. */</a>
<a name="ln458">                void *ptr = scanBeOSexfield( G.extra_field,</a>
<a name="ln459">                                             G.lrec.extra_field_length );</a>
<a name="ln460">                if (ptr) {</a>
<a name="ln461">                    setBeOSexfield( G.filename, ptr );</a>
<a name="ln462">                }</a>
<a name="ln463">            }</a>
<a name="ln464"> </a>
<a name="ln465">#ifndef NO_CHMOD</a>
<a name="ln466">            /* set approx. dir perms (make sure can still read/write in dir) */</a>
<a name="ln467">            if (chmod(G.filename, (0xffff &amp; G.pInfo-&gt;file_attr) | 0700))</a>
<a name="ln468">                perror(&quot;chmod (directory attributes) error&quot;);</a>
<a name="ln469">#endif</a>
<a name="ln470"> </a>
<a name="ln471">            /* set dir time (note trailing '/') */</a>
<a name="ln472">            return (error &amp; ~MPN_MASK) | MPN_CREATED_DIR;</a>
<a name="ln473">        }</a>
<a name="ln474">        /* TODO: should we re-write the BeOS extra field data in case it's */</a>
<a name="ln475">        /* changed?  The answer is yes. [Sept 1999 - cjh]                  */</a>
<a name="ln476">        if (!uO.J_flag) {   /* Handle the BeOS extra field if present. */</a>
<a name="ln477">            void *ptr = scanBeOSexfield( G.extra_field,</a>
<a name="ln478">                                         G.lrec.extra_field_length );</a>
<a name="ln479">            if (ptr) {</a>
<a name="ln480">                setBeOSexfield( G.filename, ptr );</a>
<a name="ln481">            }</a>
<a name="ln482">        }</a>
<a name="ln483"> </a>
<a name="ln484">        /* dir existed already; don't look for data to extract */</a>
<a name="ln485">        return (error &amp; ~MPN_MASK) | MPN_INF_SKIP;</a>
<a name="ln486">    }</a>
<a name="ln487"> </a>
<a name="ln488">    *pp = '\0';                   /* done with pathcomp:  terminate it */</a>
<a name="ln489"> </a>
<a name="ln490">    /* if not saving them, remove VMS version numbers (appended &quot;;###&quot;) */</a>
<a name="ln491">    if (!uO.V_flag &amp;&amp; lastsemi) {</a>
<a name="ln492">        pp = lastsemi + 1;</a>
<a name="ln493">        while (isdigit((uch)(*pp)))</a>
<a name="ln494">            ++pp;</a>
<a name="ln495">        if (*pp == '\0')          /* only digits between ';' and end:  nuke */</a>
<a name="ln496">            *lastsemi = '\0';</a>
<a name="ln497">    }</a>
<a name="ln498"> </a>
<a name="ln499">#ifdef ACORN_FTYPE_NFS</a>
<a name="ln500">    /* translate Acorn filetype information if asked to do so */</a>
<a name="ln501">    if (uO.acorn_nfs_ext &amp;&amp;</a>
<a name="ln502">        (ef_spark = (RO_extra_block *)</a>
<a name="ln503">                    getRISCOSexfield(G.extra_field, G.lrec.extra_field_length))</a>
<a name="ln504">        != (RO_extra_block *)NULL)</a>
<a name="ln505">    {</a>
<a name="ln506">        /* file *must* have a RISC OS extra field */</a>
<a name="ln507">        long ft = (long)makelong(ef_spark-&gt;loadaddr);</a>
<a name="ln508">        /*32-bit*/</a>
<a name="ln509">        if (lastcomma) {</a>
<a name="ln510">            pp = lastcomma + 1;</a>
<a name="ln511">            while (isxdigit((uch)(*pp))) ++pp;</a>
<a name="ln512">            if (pp == lastcomma+4 &amp;&amp; *pp == '\0') *lastcomma='\0'; /* nuke */</a>
<a name="ln513">        }</a>
<a name="ln514">        if ((ft &amp; 1&lt;&lt;31)==0) ft=0x000FFD00;</a>
<a name="ln515">        sprintf(pathcomp+strlen(pathcomp), &quot;,%03x&quot;, (int)(ft&gt;&gt;8) &amp; 0xFFF);</a>
<a name="ln516">    }</a>
<a name="ln517">#endif /* ACORN_FTYPE_NFS */</a>
<a name="ln518"> </a>
<a name="ln519">    if (*pathcomp == '\0') {</a>
<a name="ln520">        Info(slide, 1, ((char *)slide, &quot;mapname:  conversion of %s failed\n&quot;,</a>
<a name="ln521">          FnFilter1(G.filename)));</a>
<a name="ln522">        return (error &amp; ~MPN_MASK) | MPN_ERR_SKIP;</a>
<a name="ln523">    }</a>
<a name="ln524"> </a>
<a name="ln525">    checkdir(__G__ pathcomp, APPEND_NAME);  /* returns 1 if truncated: care? */</a>
<a name="ln526">    checkdir(__G__ G.filename, GETPATH);</a>
<a name="ln527"> </a>
<a name="ln528">    return error;</a>
<a name="ln529"> </a>
<a name="ln530">} /* end function mapname() */</a>
<a name="ln531"> </a>
<a name="ln532"> </a>
<a name="ln533"> </a>
<a name="ln534"> </a>
<a name="ln535">/***********************/</a>
<a name="ln536">/* Function checkdir() */</a>
<a name="ln537">/***********************/</a>
<a name="ln538"> </a>
<a name="ln539">int checkdir(__G__ pathcomp, flag)</a>
<a name="ln540">    __GDEF</a>
<a name="ln541">    char *pathcomp;</a>
<a name="ln542">    int flag;</a>
<a name="ln543">/*</a>
<a name="ln544"> * returns:</a>
<a name="ln545"> *  MPN_OK          - no problem detected</a>
<a name="ln546"> *  MPN_INF_TRUNC   - (on APPEND_NAME) truncated filename</a>
<a name="ln547"> *  MPN_INF_SKIP    - path doesn't exist, not allowed to create</a>
<a name="ln548"> *  MPN_ERR_SKIP    - path doesn't exist, tried to create and failed; or path</a>
<a name="ln549"> *                    exists and is not a directory, but is supposed to be</a>
<a name="ln550"> *  MPN_ERR_TOOLONG - path is too long</a>
<a name="ln551"> *  MPN_NOMEM       - can't allocate memory for filename buffers</a>
<a name="ln552"> */</a>
<a name="ln553">{</a>
<a name="ln554">    static int rootlen = 0;   /* length of rootpath */</a>
<a name="ln555">    static char *rootpath;    /* user's &quot;extract-to&quot; directory */</a>
<a name="ln556">    static char *buildpath;   /* full path (so far) to extracted file */</a>
<a name="ln557">    static char *end;         /* pointer to end of buildpath ('\0') */</a>
<a name="ln558"> </a>
<a name="ln559">#   define FN_MASK   7</a>
<a name="ln560">#   define FUNCTION  (flag &amp; FN_MASK)</a>
<a name="ln561"> </a>
<a name="ln562"> </a>
<a name="ln563">/*---------------------------------------------------------------------------</a>
<a name="ln564">    APPEND_DIR:  append the path component to the path being built and check</a>
<a name="ln565">    for its existence.  If doesn't exist and we are creating directories, do</a>
<a name="ln566">    so for this one; else signal success or error as appropriate.</a>
<a name="ln567">  ---------------------------------------------------------------------------*/</a>
<a name="ln568"> </a>
<a name="ln569">    if (FUNCTION == APPEND_DIR) {</a>
<a name="ln570">        int too_long = FALSE;</a>
<a name="ln571">#ifdef SHORT_NAMES</a>
<a name="ln572">        char *old_end = end;</a>
<a name="ln573">#endif</a>
<a name="ln574"> </a>
<a name="ln575">        Trace((stderr, &quot;appending dir segment [%s]\n&quot;, FnFilter1(pathcomp)));</a>
<a name="ln576">        while ((*end = *pathcomp++) != '\0')</a>
<a name="ln577">            ++end;</a>
<a name="ln578">#ifdef SHORT_NAMES   /* path components restricted to 14 chars, typically */</a>
<a name="ln579">        if ((end-old_end) &gt; FILENAME_MAX)  /* GRR:  proper constant? */</a>
<a name="ln580">            *(end = old_end + FILENAME_MAX) = '\0';</a>
<a name="ln581">#endif</a>
<a name="ln582"> </a>
<a name="ln583">        /* GRR:  could do better check, see if overrunning buffer as we go:</a>
<a name="ln584">         * check end-buildpath after each append, set warning variable if</a>
<a name="ln585">         * within 20 of FILNAMSIZ; then if var set, do careful check when</a>
<a name="ln586">         * appending.  Clear variable when begin new path. */</a>
<a name="ln587"> </a>
<a name="ln588">        if ((end-buildpath) &gt; FILNAMSIZ-3)  /* need '/', one-char name, '\0' */</a>
<a name="ln589">            too_long = TRUE;                /* check if extracting directory? */</a>
<a name="ln590">        if (stat(buildpath, &amp;G.statbuf)) {  /* path doesn't exist */</a>
<a name="ln591">            if (!G.create_dirs) { /* told not to create (freshening) */</a>
<a name="ln592">                free(buildpath);</a>
<a name="ln593">                return MPN_INF_SKIP;    /* path doesn't exist: nothing to do */</a>
<a name="ln594">            }</a>
<a name="ln595">            if (too_long) {</a>
<a name="ln596">                Info(slide, 1, ((char *)slide,</a>
<a name="ln597">                  &quot;checkdir error:  path too long: %s\n&quot;,</a>
<a name="ln598">                  FnFilter1(buildpath)));</a>
<a name="ln599">                free(buildpath);</a>
<a name="ln600">                /* no room for filenames:  fatal */</a>
<a name="ln601">                return MPN_ERR_TOOLONG;</a>
<a name="ln602">            }</a>
<a name="ln603">            if (mkdir(buildpath, 0777) == -1) {   /* create the directory */</a>
<a name="ln604">                Info(slide, 1, ((char *)slide,</a>
<a name="ln605">                  &quot;checkdir error:  cannot create %s\n\</a>
<a name="ln606">                 unable to process %s.\n&quot;,</a>
<a name="ln607">                  FnFilter2(buildpath), FnFilter1(G.filename)));</a>
<a name="ln608">                free(buildpath);</a>
<a name="ln609">                /* path didn't exist, tried to create, failed */</a>
<a name="ln610">                return MPN_ERR_SKIP;</a>
<a name="ln611">            }</a>
<a name="ln612">            created_dir = TRUE;</a>
<a name="ln613">        } else if (!S_ISDIR(G.statbuf.st_mode)) {</a>
<a name="ln614">            Info(slide, 1, ((char *)slide,</a>
<a name="ln615">              &quot;checkdir error:  %s exists but is not directory\n\</a>
<a name="ln616">                 unable to process %s.\n&quot;,</a>
<a name="ln617">              FnFilter2(buildpath), FnFilter1(G.filename)));</a>
<a name="ln618">            free(buildpath);</a>
<a name="ln619">            /* path existed but wasn't dir */</a>
<a name="ln620">            return MPN_ERR_SKIP;</a>
<a name="ln621">        }</a>
<a name="ln622">        if (too_long) {</a>
<a name="ln623">            Info(slide, 1, ((char *)slide,</a>
<a name="ln624">              &quot;checkdir error:  path too long: %s\n&quot;, FnFilter1(buildpath)));</a>
<a name="ln625">            free(buildpath);</a>
<a name="ln626">            /* no room for filenames:  fatal */</a>
<a name="ln627">            return MPN_ERR_TOOLONG;</a>
<a name="ln628">        }</a>
<a name="ln629">        *end++ = '/';</a>
<a name="ln630">        *end = '\0';</a>
<a name="ln631">        Trace((stderr, &quot;buildpath now = [%s]\n&quot;, FnFilter1(buildpath)));</a>
<a name="ln632">        return MPN_OK;</a>
<a name="ln633"> </a>
<a name="ln634">    } /* end if (FUNCTION == APPEND_DIR) */</a>
<a name="ln635"> </a>
<a name="ln636">/*---------------------------------------------------------------------------</a>
<a name="ln637">    GETPATH:  copy full path to the string pointed at by pathcomp, and free</a>
<a name="ln638">    buildpath.</a>
<a name="ln639">  ---------------------------------------------------------------------------*/</a>
<a name="ln640"> </a>
<a name="ln641">    if (FUNCTION == GETPATH) {</a>
<a name="ln642">        strcpy(pathcomp, buildpath);</a>
<a name="ln643">        Trace((stderr, &quot;getting and freeing path [%s]\n&quot;,</a>
<a name="ln644">          FnFilter1(pathcomp)));</a>
<a name="ln645">        free(buildpath);</a>
<a name="ln646">        buildpath = end = (char *)NULL;</a>
<a name="ln647">        return MPN_OK;</a>
<a name="ln648">    }</a>
<a name="ln649"> </a>
<a name="ln650">/*---------------------------------------------------------------------------</a>
<a name="ln651">    APPEND_NAME:  assume the path component is the filename; append it and</a>
<a name="ln652">    return without checking for existence.</a>
<a name="ln653">  ---------------------------------------------------------------------------*/</a>
<a name="ln654"> </a>
<a name="ln655">    if (FUNCTION == APPEND_NAME) {</a>
<a name="ln656">#ifdef SHORT_NAMES</a>
<a name="ln657">        char *old_end = end;</a>
<a name="ln658">#endif</a>
<a name="ln659"> </a>
<a name="ln660">        Trace((stderr, &quot;appending filename [%s]\n&quot;, FnFilter1(pathcomp)));</a>
<a name="ln661">        while ((*end = *pathcomp++) != '\0') {</a>
<a name="ln662">            ++end;</a>
<a name="ln663">#ifdef SHORT_NAMES  /* truncate name at 14 characters, typically */</a>
<a name="ln664">            if ((end-old_end) &gt; FILENAME_MAX)      /* GRR:  proper constant? */</a>
<a name="ln665">                *(end = old_end + FILENAME_MAX) = '\0';</a>
<a name="ln666">#endif</a>
<a name="ln667">            if ((end-buildpath) &gt;= FILNAMSIZ) {</a>
<a name="ln668">                *--end = '\0';</a>
<a name="ln669">                Info(slide, 0x201, ((char *)slide,</a>
<a name="ln670">                  &quot;checkdir warning:  path too long; truncating\n\</a>
<a name="ln671">                   %s\n                -&gt; %s\n&quot;,</a>
<a name="ln672">                  FnFilter1(G.filename), FnFilter2(buildpath)));</a>
<a name="ln673">                return MPN_INF_TRUNC;   /* filename truncated */</a>
<a name="ln674">            }</a>
<a name="ln675">        }</a>
<a name="ln676">        Trace((stderr, &quot;buildpath now = [%s]\n&quot;, FnFilter1(buildpath)));</a>
<a name="ln677">        /* could check for existence here, prompt for new name... */</a>
<a name="ln678">        return MPN_OK;</a>
<a name="ln679">    }</a>
<a name="ln680"> </a>
<a name="ln681">/*---------------------------------------------------------------------------</a>
<a name="ln682">    INIT:  allocate and initialize buffer space for the file currently being</a>
<a name="ln683">    extracted.  If file was renamed with an absolute path, don't prepend the</a>
<a name="ln684">    extract-to path.</a>
<a name="ln685">  ---------------------------------------------------------------------------*/</a>
<a name="ln686"> </a>
<a name="ln687">/* GRR:  for VMS and TOPS-20, add up to 13 to strlen */</a>
<a name="ln688"> </a>
<a name="ln689">    if (FUNCTION == INIT) {</a>
<a name="ln690">        Trace((stderr, &quot;initializing buildpath to &quot;));</a>
<a name="ln691">#ifdef ACORN_FTYPE_NFS</a>
<a name="ln692">        if ((buildpath = (char *)malloc(strlen(G.filename)+rootlen+</a>
<a name="ln693">                                        (uO.acorn_nfs_ext ? 5 : 1)))</a>
<a name="ln694">#else</a>
<a name="ln695">        if ((buildpath = (char *)malloc(strlen(G.filename)+rootlen+1))</a>
<a name="ln696">#endif</a>
<a name="ln697">            == (char *)NULL)</a>
<a name="ln698">            return MPN_NOMEM;</a>
<a name="ln699">        if ((rootlen &gt; 0) &amp;&amp; !renamed_fullpath) {</a>
<a name="ln700">            strcpy(buildpath, rootpath);</a>
<a name="ln701">            end = buildpath + rootlen;</a>
<a name="ln702">        } else {</a>
<a name="ln703">            *buildpath = '\0';</a>
<a name="ln704">            end = buildpath;</a>
<a name="ln705">        }</a>
<a name="ln706">        Trace((stderr, &quot;[%s]\n&quot;, FnFilter1(buildpath)));</a>
<a name="ln707">        return MPN_OK;</a>
<a name="ln708">    }</a>
<a name="ln709"> </a>
<a name="ln710">/*---------------------------------------------------------------------------</a>
<a name="ln711">    ROOT:  if appropriate, store the path in rootpath and create it if</a>
<a name="ln712">    necessary; else assume it's a zipfile member and return.  This path</a>
<a name="ln713">    segment gets used in extracting all members from every zipfile specified</a>
<a name="ln714">    on the command line.</a>
<a name="ln715">  ---------------------------------------------------------------------------*/</a>
<a name="ln716"> </a>
<a name="ln717">#if (!defined(SFX) || defined(SFX_EXDIR))</a>
<a name="ln718">    if (FUNCTION == ROOT) {</a>
<a name="ln719">        Trace((stderr, &quot;initializing root path to [%s]\n&quot;,</a>
<a name="ln720">          FnFilter1(pathcomp)));</a>
<a name="ln721">        if (pathcomp == (char *)NULL) {</a>
<a name="ln722">            rootlen = 0;</a>
<a name="ln723">            return MPN_OK;</a>
<a name="ln724">        }</a>
<a name="ln725">        if (rootlen &gt; 0)        /* rootpath was already set, nothing to do */</a>
<a name="ln726">            return MPN_OK;</a>
<a name="ln727">        if ((rootlen = strlen(pathcomp)) &gt; 0) {</a>
<a name="ln728">            char *tmproot;</a>
<a name="ln729"> </a>
<a name="ln730">            if ((tmproot = (char *)malloc(rootlen+2)) == (char *)NULL) {</a>
<a name="ln731">                rootlen = 0;</a>
<a name="ln732">                return MPN_NOMEM;</a>
<a name="ln733">            }</a>
<a name="ln734">            strcpy(tmproot, pathcomp);</a>
<a name="ln735">            if (tmproot[rootlen-1] == '/') {</a>
<a name="ln736">                tmproot[--rootlen] = '\0';</a>
<a name="ln737">            }</a>
<a name="ln738">            if (rootlen &gt; 0 &amp;&amp; (stat(tmproot, &amp;G.statbuf) ||</a>
<a name="ln739">                                !S_ISDIR(G.statbuf.st_mode)))</a>
<a name="ln740">            {   /* path does not exist */</a>
<a name="ln741">                if (!G.create_dirs /* || iswild(tmproot) */ ) {</a>
<a name="ln742">                    free(tmproot);</a>
<a name="ln743">                    rootlen = 0;</a>
<a name="ln744">                    /* skip (or treat as stored file) */</a>
<a name="ln745">                    return MPN_INF_SKIP;</a>
<a name="ln746">                }</a>
<a name="ln747">                /* create the directory (could add loop here scanning tmproot</a>
<a name="ln748">                 * to create more than one level, but why really necessary?) */</a>
<a name="ln749">                if (mkdir(tmproot, 0777) == -1) {</a>
<a name="ln750">                    Info(slide, 1, ((char *)slide,</a>
<a name="ln751">                      &quot;checkdir:  cannot create extraction directory: %s\n&quot;,</a>
<a name="ln752">                      FnFilter1(tmproot)));</a>
<a name="ln753">                    free(tmproot);</a>
<a name="ln754">                    rootlen = 0;</a>
<a name="ln755">                    /* path didn't exist, tried to create, and failed: */</a>
<a name="ln756">                    /* file exists, or 2+ subdir levels required */</a>
<a name="ln757">                    return MPN_ERR_SKIP;</a>
<a name="ln758">                }</a>
<a name="ln759">            }</a>
<a name="ln760">            tmproot[rootlen++] = '/';</a>
<a name="ln761">            tmproot[rootlen] = '\0';</a>
<a name="ln762">            if ((rootpath = (char *)realloc(tmproot, rootlen+1)) == NULL) {</a>
<a name="ln763">                free(tmproot);</a>
<a name="ln764">                rootlen = 0;</a>
<a name="ln765">                return MPN_NOMEM;</a>
<a name="ln766">            }</a>
<a name="ln767">            Trace((stderr, &quot;rootpath now = [%s]\n&quot;, FnFilter1(rootpath)));</a>
<a name="ln768">        }</a>
<a name="ln769">        return MPN_OK;</a>
<a name="ln770">    }</a>
<a name="ln771">#endif /* !SFX || SFX_EXDIR */</a>
<a name="ln772"> </a>
<a name="ln773">/*---------------------------------------------------------------------------</a>
<a name="ln774">    END:  free rootpath, immediately prior to program exit.</a>
<a name="ln775">  ---------------------------------------------------------------------------*/</a>
<a name="ln776"> </a>
<a name="ln777">    if (FUNCTION == END) {</a>
<a name="ln778">        Trace((stderr, &quot;freeing rootpath\n&quot;));</a>
<a name="ln779">        if (rootlen &gt; 0) {</a>
<a name="ln780">            free(rootpath);</a>
<a name="ln781">            rootlen = 0;</a>
<a name="ln782">        }</a>
<a name="ln783">        return MPN_OK;</a>
<a name="ln784">    }</a>
<a name="ln785"> </a>
<a name="ln786">    return MPN_INVALID; /* should never reach */</a>
<a name="ln787"> </a>
<a name="ln788">} /* end function checkdir() */</a>
<a name="ln789"> </a>
<a name="ln790"> </a>
<a name="ln791"> </a>
<a name="ln792"> </a>
<a name="ln793"> </a>
<a name="ln794"> </a>
<a name="ln795">/****************************/</a>
<a name="ln796">/* Function close_outfile() */</a>
<a name="ln797">/****************************/</a>
<a name="ln798"> </a>
<a name="ln799">void close_outfile(__G)    /* GRR: change to return PK-style warning level */</a>
<a name="ln800">    __GDEF</a>
<a name="ln801">{</a>
<a name="ln802">    iztimes zt;</a>
<a name="ln803">    ush z_uidgid[2];</a>
<a name="ln804">    unsigned eb_izux_flg;</a>
<a name="ln805"> </a>
<a name="ln806">/*---------------------------------------------------------------------------</a>
<a name="ln807">    If symbolic links are supported, allocate a storage area, put the uncom-</a>
<a name="ln808">    pressed &quot;data&quot; in it, and create the link.  Since we know it's a symbolic</a>
<a name="ln809">    link to start with, we shouldn't have to worry about overflowing unsigned</a>
<a name="ln810">    ints with unsigned longs.</a>
<a name="ln811">  ---------------------------------------------------------------------------*/</a>
<a name="ln812"> </a>
<a name="ln813">#ifdef SYMLINKS</a>
<a name="ln814">    if (G.symlnk) {</a>
<a name="ln815">        unsigned ucsize = (unsigned)G.lrec.ucsize;</a>
<a name="ln816">        char *linktarget = (char *)malloc((unsigned)G.lrec.ucsize+1);</a>
<a name="ln817"> </a>
<a name="ln818">        fclose(G.outfile);                      /* close &quot;data&quot; file... */</a>
<a name="ln819">        G.outfile = fopen(G.filename, FOPR);    /* ...and reopen for reading */</a>
<a name="ln820">        if (!linktarget</a>
<a name="ln821">        	|| fread(linktarget, 1, ucsize, G.outfile) != (size_t)ucsize) {</a>
<a name="ln822">            Info(slide, 0x201, ((char *)slide,</a>
<a name="ln823">              &quot;warning:  symbolic link (%s) failed\n&quot;, FnFilter1(G.filename)));</a>
<a name="ln824">            if (linktarget)</a>
<a name="ln825">                free(linktarget);</a>
<a name="ln826">            fclose(G.outfile);</a>
<a name="ln827">            return;</a>
<a name="ln828">        }</a>
<a name="ln829">        fclose(G.outfile);                  /* close &quot;data&quot; file for good... */</a>
<a name="ln830">        unlink(G.filename);                 /* ...and delete it */</a>
<a name="ln831">        linktarget[ucsize] = '\0';</a>
<a name="ln832">        if (QCOND2)</a>
<a name="ln833">            Info(slide, 0, ((char *)slide, &quot;-&gt; %s &quot;, FnFilter1(linktarget)));</a>
<a name="ln834">        if (symlink(linktarget, G.filename))  /* create the real link */</a>
<a name="ln835">            perror(&quot;symlink error&quot;);</a>
<a name="ln836"> </a>
<a name="ln837">        if (!uO.J_flag) {</a>
<a name="ln838">            /* Symlinks can have attributes, too. */</a>
<a name="ln839">            void *ptr = scanBeOSexfield( G.extra_field,</a>
<a name="ln840">                                         G.lrec.extra_field_length );</a>
<a name="ln841">            if (ptr) {</a>
<a name="ln842">                setBeOSexfield( G.filename, ptr );</a>
<a name="ln843">            }</a>
<a name="ln844">        }</a>
<a name="ln845"> </a>
<a name="ln846">        free(linktarget);</a>
<a name="ln847">        return;                             /* can't set time on symlinks */</a>
<a name="ln848">    }</a>
<a name="ln849">#endif /* SYMLINKS */</a>
<a name="ln850"> </a>
<a name="ln851">    fclose(G.outfile);</a>
<a name="ln852"> </a>
<a name="ln853">    /* handle the BeOS extra field if present */</a>
<a name="ln854">    if (!uO.J_flag) {</a>
<a name="ln855">        void *ptr = scanBeOSexfield( G.extra_field,</a>
<a name="ln856">                                     G.lrec.extra_field_length );</a>
<a name="ln857"> </a>
<a name="ln858">        if (ptr) {</a>
<a name="ln859">            setBeOSexfield( G.filename, ptr );</a>
<a name="ln860">#ifdef BEOS_ASSIGN_FILETYPE</a>
<a name="ln861">        } else {</a>
<a name="ln862">            /* Otherwise, ask the system to try assigning a MIME type. */</a>
<a name="ln863">            assign_MIME( G.filename );</a>
<a name="ln864">#endif</a>
<a name="ln865">        }</a>
<a name="ln866">    }</a>
<a name="ln867"> </a>
<a name="ln868">/*---------------------------------------------------------------------------</a>
<a name="ln869">    Change the file permissions from default ones to those stored in the</a>
<a name="ln870">    zipfile.</a>
<a name="ln871">  ---------------------------------------------------------------------------*/</a>
<a name="ln872"> </a>
<a name="ln873">#ifndef NO_CHMOD</a>
<a name="ln874">    if (chmod(G.filename, 0xffff &amp; G.pInfo-&gt;file_attr))</a>
<a name="ln875">        perror(&quot;chmod (file attributes) error&quot;);</a>
<a name="ln876">#endif</a>
<a name="ln877"> </a>
<a name="ln878">/*---------------------------------------------------------------------------</a>
<a name="ln879">    Convert from MSDOS-format local time and date to Unix-format 32-bit GMT</a>
<a name="ln880">    time:  adjust base year from 1980 to 1970, do usual conversions from</a>
<a name="ln881">    yy/mm/dd hh:mm:ss to elapsed seconds, and account for timezone and day-</a>
<a name="ln882">    light savings time differences.  If we have a Unix extra field, however,</a>
<a name="ln883">    we're laughing:  both mtime and atime are ours.  On the other hand, we</a>
<a name="ln884">    then have to check for restoration of UID/GID.</a>
<a name="ln885">  ---------------------------------------------------------------------------*/</a>
<a name="ln886"> </a>
<a name="ln887">    eb_izux_flg = (G.extra_field ? ef_scan_for_izux(G.extra_field,</a>
<a name="ln888">                   G.lrec.extra_field_length, 0, G.lrec.last_mod_dos_datetime,</a>
<a name="ln889">#ifdef IZ_CHECK_TZ</a>
<a name="ln890">                   (G.tz_is_valid ? &amp;zt : NULL),</a>
<a name="ln891">#else</a>
<a name="ln892">                   &amp;zt,</a>
<a name="ln893">#endif</a>
<a name="ln894">                   z_uidgid) : 0);</a>
<a name="ln895">    if (eb_izux_flg &amp; EB_UT_FL_MTIME) {</a>
<a name="ln896">        TTrace((stderr, &quot;\nclose_outfile:  Unix e.f. modif. time = %ld\n&quot;,</a>
<a name="ln897">          zt.mtime));</a>
<a name="ln898">    } else {</a>
<a name="ln899">        zt.mtime = dos_to_unix_time(G.lrec.last_mod_dos_datetime);</a>
<a name="ln900">    }</a>
<a name="ln901">    if (eb_izux_flg &amp; EB_UT_FL_ATIME) {</a>
<a name="ln902">        TTrace((stderr, &quot;close_outfile:  Unix e.f. access time = %ld\n&quot;,</a>
<a name="ln903">          zt.atime));</a>
<a name="ln904">    } else {</a>
<a name="ln905">        zt.atime = zt.mtime;</a>
<a name="ln906">        TTrace((stderr, &quot;\nclose_outfile:  modification/access times = %ld\n&quot;,</a>
<a name="ln907">          zt.mtime));</a>
<a name="ln908">    }</a>
<a name="ln909"> </a>
<a name="ln910">    /* if -X option was specified and we have UID/GID info, restore it */</a>
<a name="ln911">    if (uO.X_flag &amp;&amp; eb_izux_flg &amp; EB_UX2_VALID) {</a>
<a name="ln912">        TTrace((stderr, &quot;close_outfile:  restoring Unix UID/GID info\n&quot;));</a>
<a name="ln913">        if (chown(G.filename, (uid_t)z_uidgid[0], (gid_t)z_uidgid[1]))</a>
<a name="ln914">        {</a>
<a name="ln915">            if (uO.qflag)</a>
<a name="ln916">                Info(slide, 0x201, ((char *)slide,</a>
<a name="ln917">                  &quot;warning:  cannot set UID %d and/or GID %d for %s\n&quot;,</a>
<a name="ln918">                  z_uidgid[0], z_uidgid[1], FnFilter1(G.filename)));</a>
<a name="ln919">            else</a>
<a name="ln920">                Info(slide, 0x201, ((char *)slide,</a>
<a name="ln921">                  &quot; (warning) cannot set UID %d and/or GID %d&quot;,</a>
<a name="ln922">                  z_uidgid[0], z_uidgid[1]));</a>
<a name="ln923">        }</a>
<a name="ln924">    }</a>
<a name="ln925"> </a>
<a name="ln926">    /* set the file's access and modification times */</a>
<a name="ln927">    if (utime(G.filename, (struct utimbuf *)&amp;zt)) {</a>
<a name="ln928">        if (uO.qflag)</a>
<a name="ln929">            Info(slide, 0x201, ((char *)slide,</a>
<a name="ln930">              &quot;warning:  cannot set time for %s\n&quot;, FnFilter1(G.filename)));</a>
<a name="ln931">        else</a>
<a name="ln932">            Info(slide, 0x201, ((char *)slide,</a>
<a name="ln933">              &quot; (warning) cannot set time&quot;));</a>
<a name="ln934">    }</a>
<a name="ln935"> </a>
<a name="ln936">} /* end function close_outfile() */</a>
<a name="ln937"> </a>
<a name="ln938"> </a>
<a name="ln939"> </a>
<a name="ln940"> </a>
<a name="ln941">#ifdef SET_DIR_ATTRIB</a>
<a name="ln942">/* messages of code for setting directory attributes */</a>
<a name="ln943">static char Far DirlistUidGidFailed[] =</a>
<a name="ln944">  &quot;warning:  cannot set UID %d and/or GID %d for %s\n&quot;;</a>
<a name="ln945">static char Far DirlistUtimeFailed[] =</a>
<a name="ln946">  &quot;warning:  cannot set modification, access times for %s\n&quot;;</a>
<a name="ln947">#  ifndef NO_CHMOD</a>
<a name="ln948">  static char Far DirlistChmodFailed[] =</a>
<a name="ln949">    &quot;warning:  cannot set permissions for %s\n&quot;;</a>
<a name="ln950">#  endif</a>
<a name="ln951"> </a>
<a name="ln952"> </a>
<a name="ln953">int set_direc_attribs(__G__ d)</a>
<a name="ln954">    __GDEF</a>
<a name="ln955">    dirtime *d;</a>
<a name="ln956">{</a>
<a name="ln957">    int errval = PK_OK;</a>
<a name="ln958"> </a>
<a name="ln959">    if (d-&gt;have_uidgid &amp;&amp;</a>
<a name="ln960">        chown(d-&gt;fn, (uid_t)d-&gt;uidgid[0], (gid_t)d-&gt;uidgid[1]))</a>
<a name="ln961">    {</a>
<a name="ln962">        Info(slide, 0x201, ((char *)slide,</a>
<a name="ln963">          LoadFarString(DirlistUidGidFailed),</a>
<a name="ln964">          d-&gt;uidgid[0], d-&gt;uidgid[1], d-&gt;fn));</a>
<a name="ln965">        if (!errval)</a>
<a name="ln966">            errval = PK_WARN;</a>
<a name="ln967">    }</a>
<a name="ln968">    if (utime(d-&gt;fn, (const struct utimbuf *)&amp;d-&gt;u.t2)) {</a>
<a name="ln969">        Info(slide, 0x201, ((char *)slide,</a>
<a name="ln970">          LoadFarString(DirlistUtimeFailed), FnFilter1(d-&gt;fn)));</a>
<a name="ln971">        if (!errval)</a>
<a name="ln972">            errval = PK_WARN;</a>
<a name="ln973">    }</a>
<a name="ln974">#ifndef NO_CHMOD</a>
<a name="ln975">    if (chmod(d-&gt;fn, 0xffff &amp; d-&gt;perms)) {</a>
<a name="ln976">        Info(slide, 0x201, ((char *)slide,</a>
<a name="ln977">          LoadFarString(DirlistChmodFailed), FnFilter1(d-&gt;fn)));</a>
<a name="ln978">        /* perror(&quot;chmod (file attributes) error&quot;); */</a>
<a name="ln979">        if (!errval)</a>
<a name="ln980">            errval = PK_WARN;</a>
<a name="ln981">    }</a>
<a name="ln982">#endif /* !NO_CHMOD */</a>
<a name="ln983">    return errval;</a>
<a name="ln984">} /* end function set_directory_attributes() */</a>
<a name="ln985"> </a>
<a name="ln986">#endif /* SET_DIR_ATTRIB */</a>
<a name="ln987"> </a>
<a name="ln988"> </a>
<a name="ln989"> </a>
<a name="ln990"> </a>
<a name="ln991">#ifdef TIMESTAMP</a>
<a name="ln992"> </a>
<a name="ln993">/***************************/</a>
<a name="ln994">/*  Function stamp_file()  */</a>
<a name="ln995">/***************************/</a>
<a name="ln996"> </a>
<a name="ln997">int stamp_file(fname, modtime)</a>
<a name="ln998">    ZCONST char *fname;</a>
<a name="ln999">    time_t modtime;</a>
<a name="ln1000">{</a>
<a name="ln1001">    struct utimbuf tp;</a>
<a name="ln1002"> </a>
<a name="ln1003">    tp.modtime = tp.actime = modtime;</a>
<a name="ln1004">    return (utime(fname, &amp;tp));</a>
<a name="ln1005"> </a>
<a name="ln1006">} /* end function stamp_file() */</a>
<a name="ln1007"> </a>
<a name="ln1008">#endif /* TIMESTAMP */</a>
<a name="ln1009"> </a>
<a name="ln1010"> </a>
<a name="ln1011"> </a>
<a name="ln1012"> </a>
<a name="ln1013">#ifndef SFX</a>
<a name="ln1014"> </a>
<a name="ln1015">/************************/</a>
<a name="ln1016">/*  Function version()  */</a>
<a name="ln1017">/************************/</a>
<a name="ln1018"> </a>
<a name="ln1019">void version(__G)</a>
<a name="ln1020">    __GDEF</a>
<a name="ln1021">{</a>
<a name="ln1022">    sprintf((char *)slide, LoadFarString(CompiledWith),</a>
<a name="ln1023">#if defined(__MWERKS__)</a>
<a name="ln1024">      &quot;Metrowerks CodeWarrior&quot;, &quot;&quot;,</a>
<a name="ln1025">#elif defined(__GNUC__)</a>
<a name="ln1026">      &quot;GNU C &quot;, __VERSION__,</a>
<a name="ln1027">#endif</a>
<a name="ln1028">      &quot;BeOS &quot;,</a>
<a name="ln1029"> </a>
<a name="ln1030">#ifdef __POWERPC__</a>
<a name="ln1031">      &quot;(PowerPC)&quot;,</a>
<a name="ln1032">#else</a>
<a name="ln1033"># ifdef __i386__</a>
<a name="ln1034">      &quot;(x86)&quot;,</a>
<a name="ln1035"># else</a>
<a name="ln1036">      &quot;(unknown)&quot;,   /* someday we may have other architectures... */</a>
<a name="ln1037"># endif</a>
<a name="ln1038">#endif</a>
<a name="ln1039"> </a>
<a name="ln1040">#ifdef __DATE__</a>
<a name="ln1041">      &quot; on &quot;, __DATE__</a>
<a name="ln1042">#else</a>
<a name="ln1043">      &quot;&quot;, &quot;&quot;</a>
<a name="ln1044">#endif</a>
<a name="ln1045">    );</a>
<a name="ln1046"> </a>
<a name="ln1047">    (*G.message)((zvoid *)&amp;G, slide, (ulg)strlen((char *)slide), 0);</a>
<a name="ln1048"> </a>
<a name="ln1049">} /* end function version() */</a>
<a name="ln1050"> </a>
<a name="ln1051">#endif /* !SFX */</a>
<a name="ln1052"> </a>
<a name="ln1053"> </a>
<a name="ln1054"> </a>
<a name="ln1055">/******************************/</a>
<a name="ln1056">/* Extra field functions      */</a>
<a name="ln1057">/******************************/</a>
<a name="ln1058"> </a>
<a name="ln1059">/*</a>
<a name="ln1060">** Scan the extra fields in extra_field, and look for a BeOS EF; return a</a>
<a name="ln1061">** pointer to that EF, or NULL if it's not there.</a>
<a name="ln1062">*/</a>
<a name="ln1063">static uch *scanBeOSexfield( const uch *ef_ptr, unsigned ef_len )</a>
<a name="ln1064">{</a>
<a name="ln1065">    while( ef_ptr != NULL &amp;&amp; ef_len &gt;= EB_HEADSIZE ) {</a>
<a name="ln1066">        unsigned eb_id  = makeword(EB_ID + ef_ptr);</a>
<a name="ln1067">        unsigned eb_len = makeword(EB_LEN + ef_ptr);</a>
<a name="ln1068"> </a>
<a name="ln1069">        if (eb_len &gt; (ef_len - EB_HEADSIZE)) {</a>
<a name="ln1070">            Trace((stderr,</a>
<a name="ln1071">              &quot;scanBeOSexfield: block length %u &gt; rest ef_size %u\n&quot;, eb_len,</a>
<a name="ln1072">              ef_len - EB_HEADSIZE));</a>
<a name="ln1073">            break;</a>
<a name="ln1074">        }</a>
<a name="ln1075"> </a>
<a name="ln1076">        if( eb_id == EF_BEOS &amp;&amp; eb_len &gt;= EB_BEOS_HLEN ) {</a>
<a name="ln1077">            return (uch *)ef_ptr;</a>
<a name="ln1078">        }</a>
<a name="ln1079"> </a>
<a name="ln1080">        ef_ptr += (eb_len + EB_HEADSIZE);</a>
<a name="ln1081">        ef_len -= (eb_len + EB_HEADSIZE);</a>
<a name="ln1082">    }</a>
<a name="ln1083"> </a>
<a name="ln1084">    return NULL;</a>
<a name="ln1085">}</a>
<a name="ln1086"> </a>
<a name="ln1087">/* Used by setBeOSexfield():</a>
<a name="ln1088"> </a>
<a name="ln1089">Set a file/directory's attributes to the attributes passed in.</a>
<a name="ln1090"> </a>
<a name="ln1091">If set_file_attrs() fails, an error will be returned:</a>
<a name="ln1092"> </a>
<a name="ln1093">     EOK - no errors occurred</a>
<a name="ln1094"> </a>
<a name="ln1095">(other values will be whatever the failed function returned; no docs</a>
<a name="ln1096">yet, or I'd list a few)</a>
<a name="ln1097">*/</a>
<a name="ln1098">static int set_file_attrs( const char *name,</a>
<a name="ln1099">                           const unsigned char *attr_buff,</a>
<a name="ln1100">                           const off_t total_attr_size )</a>
<a name="ln1101">{</a>
<a name="ln1102">    int                  retval = EOK;</a>
<a name="ln1103">    unsigned char       *ptr;</a>
<a name="ln1104">    const unsigned char *guard;</a>
<a name="ln1105">    int                  fd;</a>
<a name="ln1106"> </a>
<a name="ln1107">    ptr   = (unsigned char *)attr_buff;</a>
<a name="ln1108">    guard = ptr + total_attr_size;</a>
<a name="ln1109"> </a>
<a name="ln1110">#ifdef HAIKU_USE_KERN_OPEN</a>
<a name="ln1111">    fd = _kern_open( -1, name, O_RDONLY | O_NOTRAVERSE, 0 );</a>
<a name="ln1112">	if( fd &lt; 0 )</a>
<a name="ln1113">         return fd;</a>
<a name="ln1114">#else</a>
<a name="ln1115">    fd = open( name, O_RDONLY | O_NOTRAVERSE );</a>
<a name="ln1116">    if( fd &lt; 0 ) {</a>
<a name="ln1117">        return errno; /* should it be -fd ? */</a>
<a name="ln1118">    }</a>
<a name="ln1119">#endif</a>
<a name="ln1120"> </a>
<a name="ln1121">    while( ptr &lt; guard ) {</a>
<a name="ln1122">        ssize_t              wrote_bytes;</a>
<a name="ln1123">        const char          *attr_name;</a>
<a name="ln1124">        unsigned char       *attr_data;</a>
<a name="ln1125">		uint32				attr_type;</a>
<a name="ln1126">		int64				attr_size;</a>
<a name="ln1127"> </a>
<a name="ln1128">        attr_name  = (char *)&amp;(ptr[0]);</a>
<a name="ln1129">        ptr       += strlen( attr_name ) + 1;</a>
<a name="ln1130"> </a>
<a name="ln1131">        /* The attr_info data is stored in big-endian format because the */</a>
<a name="ln1132">        /* PowerPC port was here first.                                  */</a>
<a name="ln1133">		memcpy( &amp;attr_type, ptr, 4 ); ptr += 4;</a>
<a name="ln1134">		memcpy( &amp;attr_size, ptr, 8 ); ptr += 8;</a>
<a name="ln1135"> </a>
<a name="ln1136">        attr_type = (uint32)B_BENDIAN_TO_HOST_INT32( attr_type );</a>
<a name="ln1137">        attr_size = (off_t)B_BENDIAN_TO_HOST_INT64( attr_size );</a>
<a name="ln1138"> </a>
<a name="ln1139">        if( attr_size &lt; 0LL ) {</a>
<a name="ln1140">            Info(slide, 0x201, ((char *)slide,</a>
<a name="ln1141">                 &quot;warning: skipping attribute with invalid length (%&quot; B_PRIdOFF</a>
<a name="ln1142">				 &quot;)\n&quot;, attr_size));</a>
<a name="ln1143">            break;</a>
<a name="ln1144">        }</a>
<a name="ln1145"> </a>
<a name="ln1146">        attr_data  = ptr;</a>
<a name="ln1147">        ptr       += attr_size;</a>
<a name="ln1148"> </a>
<a name="ln1149">        if( ptr &gt; guard ) {</a>
<a name="ln1150">            /* We've got a truncated attribute. */</a>
<a name="ln1151">            Info(slide, 0x201, ((char *)slide,</a>
<a name="ln1152">                 &quot;warning: truncated attribute\n&quot;));</a>
<a name="ln1153">            break;</a>
<a name="ln1154">        }</a>
<a name="ln1155"> </a>
<a name="ln1156">        /* Wave the magic wand... this will swap Be-known types properly. */</a>
<a name="ln1157">        (void)swap_data( attr_type, attr_data, attr_size,</a>
<a name="ln1158">                         B_SWAP_BENDIAN_TO_HOST );</a>
<a name="ln1159"> </a>
<a name="ln1160">        wrote_bytes = fs_write_attr( fd, attr_name, attr_type, 0,</a>
<a name="ln1161">                                     attr_data, attr_size );</a>
<a name="ln1162">        if( wrote_bytes != attr_size ) {</a>
<a name="ln1163">            Info(slide, 0x201, ((char *)slide,</a>
<a name="ln1164">                 &quot;warning: wrote %ld attribute bytes of %ld\n&quot;,</a>
<a name="ln1165">                 (unsigned long)wrote_bytes,(unsigned long)attr_size));</a>
<a name="ln1166">        }</a>
<a name="ln1167">    }</a>
<a name="ln1168"> </a>
<a name="ln1169">    close( fd );</a>
<a name="ln1170"> </a>
<a name="ln1171">    return retval;</a>
<a name="ln1172">}</a>
<a name="ln1173"> </a>
<a name="ln1174">static void setBeOSexfield(const char *path, uch *extra_field)</a>
<a name="ln1175">{</a>
<a name="ln1176">    uch *ptr       = extra_field;</a>
<a name="ln1177">    ush  id        = 0;</a>
<a name="ln1178">    ush  size      = 0;</a>
<a name="ln1179">    ulg  full_size = 0;</a>
<a name="ln1180">    uch  flags     = 0;</a>
<a name="ln1181">    uch *attrbuff  = NULL;</a>
<a name="ln1182">    int retval;</a>
<a name="ln1183"> </a>
<a name="ln1184">    if (extra_field == NULL)</a>
<a name="ln1185">        return;</a>
<a name="ln1186"> </a>
<a name="ln1187">    /* Collect the data from the extra field buffer. */</a>
<a name="ln1188">    id        = makeword( ptr );    ptr += 2;   /* we don't use this... */</a>
<a name="ln1189">    size      = makeword( ptr );    ptr += 2;</a>
<a name="ln1190">    full_size = makelong( ptr );    ptr += 4;</a>
<a name="ln1191">    flags     = *ptr;               ptr++;</a>
<a name="ln1192"> </a>
<a name="ln1193">    /* Do a little sanity checking. */</a>
<a name="ln1194">    if (flags &amp; EB_BE_FL_BADBITS) {</a>
<a name="ln1195">        /* corrupted or unsupported */</a>
<a name="ln1196">        Info(slide, 0x201, ((char *)slide,</a>
<a name="ln1197">             &quot;Unsupported flags set for this BeOS extra field, skipping.\n&quot;));</a>
<a name="ln1198">        return;</a>
<a name="ln1199">    }</a>
<a name="ln1200">    if (size &lt;= EB_BEOS_HLEN) {</a>
<a name="ln1201">        /* corrupted, unsupported, or truncated */</a>
<a name="ln1202">        Info(slide, 0x201, ((char *)slide,</a>
<a name="ln1203">             &quot;BeOS extra field is %d bytes, should be at least %d.\n&quot;, size,</a>
<a name="ln1204">             EB_BEOS_HLEN));</a>
<a name="ln1205">        return;</a>
<a name="ln1206">    }</a>
<a name="ln1207">    if (full_size &lt; (uint32)(size - EB_BEOS_HLEN)) {</a>
<a name="ln1208">        /* possible old archive? will this screw up on valid archives? */</a>
<a name="ln1209">        Info(slide, 0x201, ((char *)slide,</a>
<a name="ln1210">             &quot;Skipping attributes: BeOS extra field is %d bytes, &quot;</a>
<a name="ln1211">             &quot;data size is %ld.\n&quot;, size - EB_BEOS_HLEN, full_size));</a>
<a name="ln1212">        return;</a>
<a name="ln1213">    }</a>
<a name="ln1214"> </a>
<a name="ln1215">    /* Find the BeOS file attribute data. */</a>
<a name="ln1216">    if (flags &amp; EB_BE_FL_UNCMPR) {</a>
<a name="ln1217">        /* Uncompressed data */</a>
<a name="ln1218">        attrbuff = ptr;</a>
<a name="ln1219">    } else {</a>
<a name="ln1220">        /* Compressed data */</a>
<a name="ln1221">        attrbuff = (uch *)malloc(full_size);</a>
<a name="ln1222">        if (attrbuff == NULL) {</a>
<a name="ln1223">            /* No memory to uncompress attributes */</a>
<a name="ln1224">            Info(slide, 0x201, ((char *)slide,</a>
<a name="ln1225">                 &quot;Can't allocate memory to uncompress file attributes.\n&quot;));</a>
<a name="ln1226">            return;</a>
<a name="ln1227">        }</a>
<a name="ln1228"> </a>
<a name="ln1229">        retval = memextract(__G__ attrbuff, full_size, ptr, size - EB_BEOS_HLEN);</a>
<a name="ln1230">        if (retval != PK_OK) {</a>
<a name="ln1231">            /* error uncompressing attributes */</a>
<a name="ln1232">            Info(slide, 0x201, ((char *)slide,</a>
<a name="ln1233">                 &quot;Error uncompressing file attributes.\n&quot;));</a>
<a name="ln1234"> </a>
<a name="ln1235">            /* Some errors here might not be so bad; we should expect */</a>
<a name="ln1236">            /* some truncated data, for example.  If the data was     */</a>
<a name="ln1237">            /* corrupt, we should _not_ attempt to restore the attrs  */</a>
<a name="ln1238">            /* for this file... there's no way to detect what attrs   */</a>
<a name="ln1239">            /* are good and which are bad.                            */</a>
<a name="ln1240">            free(attrbuff);</a>
<a name="ln1241">            return;</a>
<a name="ln1242">        }</a>
<a name="ln1243">    }</a>
<a name="ln1244"> </a>
<a name="ln1245">    /* Now attempt to set the file attributes on the extracted file. */</a>
<a name="ln1246">    retval = set_file_attrs(path, attrbuff, (off_t)full_size);</a>
<a name="ln1247">    if (retval != EOK) {</a>
<a name="ln1248">        Info(slide, 0x201, ((char *)slide,</a>
<a name="ln1249">             &quot;Error writing file attributes.\n&quot;));</a>
<a name="ln1250">    }</a>
<a name="ln1251"> </a>
<a name="ln1252">    /* Clean up, if necessary */</a>
<a name="ln1253">    if (attrbuff != ptr)</a>
<a name="ln1254">        free(attrbuff);</a>
<a name="ln1255">}</a>
<a name="ln1256"> </a>
<a name="ln1257">#ifdef BEOS_USE_PRINTEXFIELD</a>
<a name="ln1258">static void printBeOSexfield( int isdir, uch *extra_field )</a>
<a name="ln1259">{</a>
<a name="ln1260">    uch *ptr       = extra_field;</a>
<a name="ln1261">    ush  id        = 0;</a>
<a name="ln1262">    ush  size      = 0;</a>
<a name="ln1263">    ulg  full_size = 0;</a>
<a name="ln1264">    uch  flags     = 0;</a>
<a name="ln1265"> </a>
<a name="ln1266">    /* Tell picky compilers to be quiet. */</a>
<a name="ln1267">    isdir = isdir;</a>
<a name="ln1268"> </a>
<a name="ln1269">    if( extra_field == NULL ) {</a>
<a name="ln1270">        return;</a>
<a name="ln1271">    }</a>
<a name="ln1272"> </a>
<a name="ln1273">    /* Collect the data from the buffer. */</a>
<a name="ln1274">    id        = makeword( ptr );    ptr += 2;</a>
<a name="ln1275">    size      = makeword( ptr );    ptr += 2;</a>
<a name="ln1276">    full_size = makelong( ptr );    ptr += 4;</a>
<a name="ln1277">    flags     = *ptr;               ptr++;</a>
<a name="ln1278"> </a>
<a name="ln1279">    if( id != EF_BEOS ) {</a>
<a name="ln1280">        /* not a 'Be' field */</a>
<a name="ln1281">        printf(&quot;\t*** Unknown field type (0x%04x, '%c%c')\n&quot;, id,</a>
<a name="ln1282">               (char)(id &gt;&gt; 8), (char)id);</a>
<a name="ln1283">    }</a>
<a name="ln1284"> </a>
<a name="ln1285">    if( flags &amp; EB_BE_FL_BADBITS ) {</a>
<a name="ln1286">        /* corrupted or unsupported */</a>
<a name="ln1287">        printf(&quot;\t*** Corrupted BeOS extra field:\n&quot;);</a>
<a name="ln1288">        printf(&quot;\t*** unknown bits set in the flags\n&quot;);</a>
<a name="ln1289">        printf(&quot;\t*** (Possibly created by an old version of zip for BeOS.\n&quot;);</a>
<a name="ln1290">    }</a>
<a name="ln1291"> </a>
<a name="ln1292">    if( size &lt;= EB_BEOS_HLEN ) {</a>
<a name="ln1293">        /* corrupted, unsupported, or truncated */</a>
<a name="ln1294">        printf(&quot;\t*** Corrupted BeOS extra field:\n&quot;);</a>
<a name="ln1295">        printf(&quot;\t*** size is %d, should be larger than %d\n&quot;, size,</a>
<a name="ln1296">               EB_BEOS_HLEN );</a>
<a name="ln1297">    }</a>
<a name="ln1298"> </a>
<a name="ln1299">    if( flags &amp; EB_BE_FL_UNCMPR ) {</a>
<a name="ln1300">        /* Uncompressed data */</a>
<a name="ln1301">        printf(&quot;\tBeOS extra field data (uncompressed):\n&quot;);</a>
<a name="ln1302">        printf(&quot;\t\t%ld data bytes\n&quot;, full_size);</a>
<a name="ln1303">    } else {</a>
<a name="ln1304">        /* Compressed data */</a>
<a name="ln1305">        printf(&quot;\tBeOS extra field data (compressed):\n&quot;);</a>
<a name="ln1306">        printf(&quot;\t\t%d compressed bytes\n&quot;, size - EB_BEOS_HLEN);</a>
<a name="ln1307">        printf(&quot;\t\t%ld uncompressed bytes\n&quot;, full_size);</a>
<a name="ln1308">    }</a>
<a name="ln1309">}</a>
<a name="ln1310">#endif</a>
<a name="ln1311"> </a>
<a name="ln1312">#ifdef BEOS_ASSIGN_FILETYPE</a>
<a name="ln1313">/* Note: This will no longer be necessary in BeOS PR4; update_mime_info()    */</a>
<a name="ln1314">/* will be updated to build its own absolute pathname if it's not given one. */</a>
<a name="ln1315">static void assign_MIME( const char *file )</a>
<a name="ln1316">{</a>
<a name="ln1317">    char *fullname;</a>
<a name="ln1318">    char buff[PATH_MAX], cwd_buff[PATH_MAX];</a>
<a name="ln1319">    int retval;</a>
<a name="ln1320"> </a>
<a name="ln1321">    if( file[0] == '/' ) {</a>
<a name="ln1322">        fullname = (char *)file;</a>
<a name="ln1323">    } else {</a>
<a name="ln1324">        sprintf( buff, &quot;%s/%s&quot;, getcwd( cwd_buff, PATH_MAX ), file );</a>
<a name="ln1325">        fullname = buff;</a>
<a name="ln1326">    }</a>
<a name="ln1327"> </a>
<a name="ln1328">    retval = update_mime_info( fullname, FALSE, TRUE, TRUE );</a>
<a name="ln1329">}</a>
<a name="ln1330">#endif</a>

</code></pre>
<div class="balloon" rel="1140"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'sprintf' function. The memsize type argument is expected.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
