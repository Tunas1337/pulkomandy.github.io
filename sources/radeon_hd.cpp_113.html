
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>radeon_hd.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2006-2011, Haiku, Inc. All Rights Reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Axel DÃ¶rfler, axeld@pinc-software.de</a>
<a name="ln7"> *		Clemens Zeidler, haiku@clemens-zeidler.de</a>
<a name="ln8"> *		Fredrik Holmqvis, fredrik.holmqvist@gmail.com</a>
<a name="ln9"> *		Alexander von Gluck, kallisti5@unixzen.com</a>
<a name="ln10"> */</a>
<a name="ln11"> </a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;radeon_hd.h&quot;</a>
<a name="ln14">#include &quot;sensors.h&quot;</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;AreaKeeper.h&quot;</a>
<a name="ln17">#include &quot;driver.h&quot;</a>
<a name="ln18">#include &quot;utility.h&quot;</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;unistd.h&gt;</a>
<a name="ln21">#include &lt;stdio.h&gt;</a>
<a name="ln22">#include &lt;string.h&gt;</a>
<a name="ln23">#include &lt;errno.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &lt;boot_item.h&gt;</a>
<a name="ln26">#include &lt;driver_settings.h&gt;</a>
<a name="ln27">#include &lt;util/kernel_cpp.h&gt;</a>
<a name="ln28">#include &lt;vm/vm.h&gt;</a>
<a name="ln29"> </a>
<a name="ln30"> </a>
<a name="ln31">#define TRACE_DEVICE</a>
<a name="ln32">#ifdef TRACE_DEVICE</a>
<a name="ln33">#	define TRACE(x...) dprintf(&quot;radeon_hd: &quot; x)</a>
<a name="ln34">#else</a>
<a name="ln35">#	define TRACE(x) ;</a>
<a name="ln36">#endif</a>
<a name="ln37"> </a>
<a name="ln38">#define ERROR(x...) dprintf(&quot;radeon_hd: &quot; x)</a>
<a name="ln39"> </a>
<a name="ln40"> </a>
<a name="ln41">//	#pragma mark -</a>
<a name="ln42"> </a>
<a name="ln43"> </a>
<a name="ln44">status_t</a>
<a name="ln45">mapAtomBIOS(radeon_info &amp;info, uint32 romBase, uint32 romSize)</a>
<a name="ln46">{</a>
<a name="ln47">	TRACE(&quot;%s: seeking AtomBIOS @ 0x%&quot; B_PRIX32 &quot; [size: 0x%&quot; B_PRIX32 &quot;]\n&quot;,</a>
<a name="ln48">		__func__, romBase, romSize);</a>
<a name="ln49"> </a>
<a name="ln50">	uint8* rom;</a>
<a name="ln51"> </a>
<a name="ln52">	// attempt to access area specified</a>
<a name="ln53">	area_id testArea = map_physical_memory(&quot;radeon hd rom probe&quot;,</a>
<a name="ln54">		romBase, romSize, B_ANY_KERNEL_ADDRESS, B_KERNEL_READ_AREA,</a>
<a name="ln55">		(void**)&amp;rom);</a>
<a name="ln56"> </a>
<a name="ln57">	if (testArea &lt; 0) {</a>
<a name="ln58">		ERROR(&quot;%s: couldn't map potential rom @ 0x%&quot; B_PRIX32</a>
<a name="ln59">			&quot;\n&quot;, __func__, romBase);</a>
<a name="ln60">		return B_NO_MEMORY;</a>
<a name="ln61">	}</a>
<a name="ln62"> </a>
<a name="ln63">	// check for valid BIOS signature</a>
<a name="ln64">	if (rom[0] != 0x55 || rom[1] != 0xAA) {</a>
<a name="ln65">		uint16 id = rom[0] + (rom[1] &lt;&lt; 8);</a>
<a name="ln66">		TRACE(&quot;%s: BIOS signature incorrect @ 0x%&quot; B_PRIX32 &quot; (%X)\n&quot;,</a>
<a name="ln67">			__func__, romBase, id);</a>
<a name="ln68">		delete_area(testArea);</a>
<a name="ln69">		return B_ERROR;</a>
<a name="ln70">	}</a>
<a name="ln71"> </a>
<a name="ln72">	// see if valid AtomBIOS rom</a>
<a name="ln73">	uint16 romHeader = RADEON_BIOS16(rom, 0x48);</a>
<a name="ln74">	bool romValid = !memcmp(&amp;rom[romHeader + 4], &quot;ATOM&quot;, 4)</a>
<a name="ln75">		|| !memcmp(&amp;rom[romHeader + 4], &quot;MOTA&quot;, 4);</a>
<a name="ln76"> </a>
<a name="ln77">	if (romValid == false) {</a>
<a name="ln78">		// FAIL : a PCI VGA bios but not AtomBIOS</a>
<a name="ln79">		uint16 id = rom[0] + (rom[1] &lt;&lt; 8);</a>
<a name="ln80">		TRACE(&quot;%s: not AtomBIOS rom at 0x%&quot; B_PRIX32 &quot;(%X)\n&quot;,</a>
<a name="ln81">			__func__, romBase, id);</a>
<a name="ln82">		delete_area(testArea);</a>
<a name="ln83">		return B_ERROR;</a>
<a name="ln84">	}</a>
<a name="ln85"> </a>
<a name="ln86">	info.rom_area = create_area(&quot;radeon hd AtomBIOS&quot;,</a>
<a name="ln87">		(void**)&amp;info.atom_buffer, B_ANY_KERNEL_ADDRESS,</a>
<a name="ln88">		romSize, B_NO_LOCK,</a>
<a name="ln89">		B_KERNEL_READ_AREA | B_KERNEL_WRITE_AREA | B_USER_CLONEABLE_AREA);</a>
<a name="ln90"> </a>
<a name="ln91">	if (info.rom_area &lt; 0) {</a>
<a name="ln92">		ERROR(&quot;%s: unable to map kernel AtomBIOS space!\n&quot;,</a>
<a name="ln93">			__func__);</a>
<a name="ln94">		delete_area(testArea);</a>
<a name="ln95">		return B_NO_MEMORY;</a>
<a name="ln96">	}</a>
<a name="ln97"> </a>
<a name="ln98">	memset((void*)info.atom_buffer, 0, romSize);</a>
<a name="ln99">		// Prevent unknown code execution by AtomBIOS parser</a>
<a name="ln100">	memcpy(info.atom_buffer, (void*)rom, romSize);</a>
<a name="ln101">		// Copy AtomBIOS to kernel area</a>
<a name="ln102"> </a>
<a name="ln103">	// validate copied rom is valid</a>
<a name="ln104">	romHeader = RADEON_BIOS16(info.atom_buffer, 0x48);</a>
<a name="ln105">	romValid = !memcmp(&amp;info.atom_buffer[romHeader + 4], &quot;ATOM&quot;, 4)</a>
<a name="ln106">		|| !memcmp(&amp;info.atom_buffer[romHeader + 4], &quot;MOTA&quot;, 4);</a>
<a name="ln107"> </a>
<a name="ln108">	if (romValid == true) {</a>
<a name="ln109">		set_area_protection(info.rom_area,</a>
<a name="ln110">			B_KERNEL_READ_AREA | B_USER_CLONEABLE_AREA);</a>
<a name="ln111">		ERROR(&quot;%s: AtomBIOS verified and locked\n&quot;, __func__);</a>
<a name="ln112">	} else</a>
<a name="ln113">		ERROR(&quot;%s: AtomBIOS memcpy failed!\n&quot;, __func__);</a>
<a name="ln114"> </a>
<a name="ln115">	delete_area(testArea);</a>
<a name="ln116">	return romValid ? B_OK : B_ERROR;</a>
<a name="ln117">}</a>
<a name="ln118"> </a>
<a name="ln119"> </a>
<a name="ln120">static status_t</a>
<a name="ln121">radeon_hd_getbios(radeon_info &amp;info)</a>
<a name="ln122">{</a>
<a name="ln123">	TRACE(&quot;card(%ld): %s: called\n&quot;, info.id, __func__);</a>
<a name="ln124"> </a>
<a name="ln125">	uint32 romBase = 0;</a>
<a name="ln126">	uint32 romSize = 0;</a>
<a name="ln127">	uint32 romMethod = 0;</a>
<a name="ln128"> </a>
<a name="ln129">	status_t mapResult = B_ERROR;</a>
<a name="ln130"> </a>
<a name="ln131">	// first we try to find the AtomBIOS rom via various methods</a>
<a name="ln132">	for (romMethod = 0; romMethod &lt; 3; romMethod++) {</a>
<a name="ln133">		switch(romMethod) {</a>
<a name="ln134">			case 0:</a>
<a name="ln135">				// TODO: *** New ACPI method</a>
<a name="ln136">				ERROR(&quot;%s: ACPI ATRM AtomBIOS TODO\n&quot;, __func__);</a>
<a name="ln137">				break;</a>
<a name="ln138">			case 1:</a>
<a name="ln139">				// *** Discreet card on IGP, check PCI BAR 0</a>
<a name="ln140">				// On post, the bios puts a copy of the IGP</a>
<a name="ln141">				// AtomBIOS at the start of the video ram</a>
<a name="ln142">				romBase = info.pci-&gt;u.h0.base_registers[PCI_BAR_FB];</a>
<a name="ln143">				romSize = 256 * 1024;</a>
<a name="ln144"> </a>
<a name="ln145">				if (romBase == 0 || romSize == 0) {</a>
<a name="ln146">					ERROR(&quot;%s: No base found at PCI FB BAR\n&quot;, __func__);</a>
<a name="ln147">				} else {</a>
<a name="ln148">					mapResult = mapAtomBIOS(info, romBase, romSize);</a>
<a name="ln149">				}</a>
<a name="ln150">				break;</a>
<a name="ln151">			case 2:</a>
<a name="ln152">			{</a>
<a name="ln153">				// *** PCI ROM BAR</a>
<a name="ln154">				// Enable ROM decoding for PCI BAR rom</a>
<a name="ln155">				uint32 pciConfig = get_pci_config(info.pci, PCI_rom_base, 4);</a>
<a name="ln156">				pciConfig |= PCI_rom_enable;</a>
<a name="ln157">				set_pci_config(info.pci, PCI_rom_base, 4, pciConfig);</a>
<a name="ln158"> </a>
<a name="ln159">				uint32 flags = get_pci_config(info.pci, PCI_rom_base, 4);</a>
<a name="ln160">				if ((flags &amp; PCI_rom_enable) != 0)</a>
<a name="ln161">					TRACE(&quot;%s: PCI ROM decode enabled\n&quot;, __func__);</a>
<a name="ln162"> </a>
<a name="ln163">				romBase = info.pci-&gt;u.h0.rom_base;</a>
<a name="ln164">				romSize = info.pci-&gt;u.h0.rom_size;</a>
<a name="ln165"> </a>
<a name="ln166">				if (romBase == 0 || romSize == 0) {</a>
<a name="ln167">					ERROR(&quot;%s: No base found at PCI ROM BAR\n&quot;, __func__);</a>
<a name="ln168">				} else {</a>
<a name="ln169">					mapResult = mapAtomBIOS(info, romBase, romSize);</a>
<a name="ln170">				}</a>
<a name="ln171"> </a>
<a name="ln172">				// Disable ROM decoding</a>
<a name="ln173">				pciConfig &amp;= ~PCI_rom_enable;</a>
<a name="ln174">				set_pci_config(info.pci, PCI_rom_base, 4, pciConfig);</a>
<a name="ln175">				break;</a>
<a name="ln176">			}</a>
<a name="ln177">		}</a>
<a name="ln178"> </a>
<a name="ln179">		if (mapResult == B_OK) {</a>
<a name="ln180">			ERROR(&quot;%s: AtomBIOS found using active method %&quot; B_PRIu32</a>
<a name="ln181">				&quot; at 0x%&quot; B_PRIX32 &quot;\n&quot;, __func__, romMethod, romBase);</a>
<a name="ln182">			break;</a>
<a name="ln183">		} else {</a>
<a name="ln184">			ERROR(&quot;%s: AtomBIOS not found using active method %&quot; B_PRIu32</a>
<a name="ln185">				&quot; at 0x%&quot; B_PRIX32 &quot;\n&quot;, __func__, romMethod, romBase);</a>
<a name="ln186">		}</a>
<a name="ln187">	}</a>
<a name="ln188"> </a>
<a name="ln189">	if (mapResult == B_OK) {</a>
<a name="ln190">		info.shared_info-&gt;rom_phys = romBase;</a>
<a name="ln191">		info.shared_info-&gt;rom_size = romSize;</a>
<a name="ln192">	} else</a>
<a name="ln193">		ERROR(&quot;%s: Active AtomBIOS search failed.\n&quot;, __func__);</a>
<a name="ln194"> </a>
<a name="ln195">	return mapResult;</a>
<a name="ln196">}</a>
<a name="ln197"> </a>
<a name="ln198"> </a>
<a name="ln199">static status_t</a>
<a name="ln200">radeon_hd_getbios_ni(radeon_info &amp;info)</a>
<a name="ln201">{</a>
<a name="ln202">	TRACE(&quot;card(%ld): %s: called\n&quot;, info.id, __func__);</a>
<a name="ln203">	uint32 bus_cntl = read32(info.registers + R600_BUS_CNTL);</a>
<a name="ln204">	uint32 d1vga_control = read32(info.registers + AVIVO_D1VGA_CONTROL);</a>
<a name="ln205">	uint32 d2vga_control = read32(info.registers + AVIVO_D2VGA_CONTROL);</a>
<a name="ln206">	uint32 vga_render_control</a>
<a name="ln207">		= read32(info.registers + AVIVO_VGA_RENDER_CONTROL);</a>
<a name="ln208">	uint32 rom_cntl = read32(info.registers + R600_ROM_CNTL);</a>
<a name="ln209"> </a>
<a name="ln210">	// enable the rom</a>
<a name="ln211">	write32(info.registers + R600_BUS_CNTL, (bus_cntl &amp; ~R600_BIOS_ROM_DIS));</a>
<a name="ln212">	// disable VGA mode</a>
<a name="ln213">	write32(info.registers + AVIVO_D1VGA_CONTROL, (d1vga_control</a>
<a name="ln214">		&amp; ~(AVIVO_DVGA_CONTROL_MODE_ENABLE</a>
<a name="ln215">			| AVIVO_DVGA_CONTROL_TIMING_SELECT)));</a>
<a name="ln216">	write32(info.registers + AVIVO_D2VGA_CONTROL, (d2vga_control</a>
<a name="ln217">		&amp; ~(AVIVO_DVGA_CONTROL_MODE_ENABLE</a>
<a name="ln218">			| AVIVO_DVGA_CONTROL_TIMING_SELECT)));</a>
<a name="ln219">	write32(info.registers + AVIVO_VGA_RENDER_CONTROL,</a>
<a name="ln220">		(vga_render_control &amp; ~AVIVO_VGA_VSTATUS_CNTL_MASK));</a>
<a name="ln221"> </a>
<a name="ln222">	write32(info.registers + R600_ROM_CNTL, (rom_cntl | R600_SCK_OVERWRITE));</a>
<a name="ln223"> </a>
<a name="ln224">	// try to grab the bios via PCI ROM bar</a>
<a name="ln225">	// Enable ROM decoding for PCI BAR rom</a>
<a name="ln226">	uint32 pciConfig = get_pci_config(info.pci, PCI_rom_base, 4);</a>
<a name="ln227">	pciConfig |= PCI_rom_enable;</a>
<a name="ln228">	set_pci_config(info.pci, PCI_rom_base, 4, pciConfig);</a>
<a name="ln229"> </a>
<a name="ln230">	uint32 flags = get_pci_config(info.pci, PCI_rom_base, 4);</a>
<a name="ln231">	if (flags &amp; PCI_rom_enable)</a>
<a name="ln232">		TRACE(&quot;%s: PCI ROM decode enabled\n&quot;, __func__);</a>
<a name="ln233"> </a>
<a name="ln234">	uint32 romBase = info.pci-&gt;u.h0.rom_base;</a>
<a name="ln235">	uint32 romSize = info.pci-&gt;u.h0.rom_size;</a>
<a name="ln236"> </a>
<a name="ln237">	status_t result = B_OK;</a>
<a name="ln238">	if (romBase == 0 || romSize == 0) {</a>
<a name="ln239">		ERROR(&quot;%s: No AtomBIOS location found at PCI ROM BAR\n&quot;, __func__);</a>
<a name="ln240">		result = B_ERROR;</a>
<a name="ln241">	} else {</a>
<a name="ln242">		result = mapAtomBIOS(info, romBase, romSize);</a>
<a name="ln243">	}</a>
<a name="ln244"> </a>
<a name="ln245">	if (result == B_OK) {</a>
<a name="ln246">		ERROR(&quot;%s: AtomBIOS found using disabled method at 0x%&quot; B_PRIX32</a>
<a name="ln247">			&quot; [size: 0x%&quot; B_PRIX32 &quot;]\n&quot;, __func__, romBase, romSize);</a>
<a name="ln248">		info.shared_info-&gt;rom_phys = romBase;</a>
<a name="ln249">		info.shared_info-&gt;rom_size = romSize;</a>
<a name="ln250">	}</a>
<a name="ln251"> </a>
<a name="ln252">	// Disable ROM decoding</a>
<a name="ln253">	pciConfig &amp;= ~PCI_rom_enable;</a>
<a name="ln254">	set_pci_config(info.pci, PCI_rom_base, 4, pciConfig);</a>
<a name="ln255"> </a>
<a name="ln256">	// restore regs</a>
<a name="ln257">	write32(info.registers + R600_BUS_CNTL, bus_cntl);</a>
<a name="ln258">	write32(info.registers + AVIVO_D1VGA_CONTROL, d1vga_control);</a>
<a name="ln259">	write32(info.registers + AVIVO_D2VGA_CONTROL, d2vga_control);</a>
<a name="ln260">	write32(info.registers + AVIVO_VGA_RENDER_CONTROL, vga_render_control);</a>
<a name="ln261">	write32(info.registers + R600_ROM_CNTL, rom_cntl);</a>
<a name="ln262"> </a>
<a name="ln263">	return result;</a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266"> </a>
<a name="ln267">static status_t</a>
<a name="ln268">radeon_hd_getbios_r700(radeon_info &amp;info)</a>
<a name="ln269">{</a>
<a name="ln270">	TRACE(&quot;card(%ld): %s: called\n&quot;, info.id, __func__);</a>
<a name="ln271">	uint32 viph_control = read32(info.registers + RADEON_VIPH_CONTROL);</a>
<a name="ln272">	uint32 bus_cntl = read32(info.registers + R600_BUS_CNTL);</a>
<a name="ln273">	uint32 d1vga_control = read32(info.registers + AVIVO_D1VGA_CONTROL);</a>
<a name="ln274">	uint32 d2vga_control = read32(info.registers + AVIVO_D2VGA_CONTROL);</a>
<a name="ln275">	uint32 vga_render_control</a>
<a name="ln276">		= read32(info.registers + AVIVO_VGA_RENDER_CONTROL);</a>
<a name="ln277">	uint32 rom_cntl = read32(info.registers + R600_ROM_CNTL);</a>
<a name="ln278"> </a>
<a name="ln279">	// disable VIP</a>
<a name="ln280">	write32(info.registers + RADEON_VIPH_CONTROL,</a>
<a name="ln281">		(viph_control &amp; ~RADEON_VIPH_EN));</a>
<a name="ln282">	// enable the rom</a>
<a name="ln283">	write32(info.registers + R600_BUS_CNTL, (bus_cntl &amp; ~R600_BIOS_ROM_DIS));</a>
<a name="ln284">	// disable VGA mode</a>
<a name="ln285">	write32(info.registers + AVIVO_D1VGA_CONTROL, (d1vga_control</a>
<a name="ln286">		&amp; ~(AVIVO_DVGA_CONTROL_MODE_ENABLE</a>
<a name="ln287">			| AVIVO_DVGA_CONTROL_TIMING_SELECT)));</a>
<a name="ln288">	write32(info.registers + AVIVO_D2VGA_CONTROL, (d2vga_control</a>
<a name="ln289">		&amp; ~(AVIVO_DVGA_CONTROL_MODE_ENABLE</a>
<a name="ln290">			| AVIVO_DVGA_CONTROL_TIMING_SELECT)));</a>
<a name="ln291">	write32(info.registers + AVIVO_VGA_RENDER_CONTROL,</a>
<a name="ln292">		(vga_render_control &amp; ~AVIVO_VGA_VSTATUS_CNTL_MASK));</a>
<a name="ln293"> </a>
<a name="ln294">	write32(info.registers + R600_ROM_CNTL, (rom_cntl | R600_SCK_OVERWRITE));</a>
<a name="ln295"> </a>
<a name="ln296">	// try to grab the bios via PCI ROM bar</a>
<a name="ln297">	// Enable ROM decoding for PCI BAR rom</a>
<a name="ln298">	uint32 pciConfig = get_pci_config(info.pci, PCI_rom_base, 4);</a>
<a name="ln299">	pciConfig |= PCI_rom_enable;</a>
<a name="ln300">	set_pci_config(info.pci, PCI_rom_base, 4, pciConfig);</a>
<a name="ln301"> </a>
<a name="ln302">	uint32 flags = get_pci_config(info.pci, PCI_rom_base, 4);</a>
<a name="ln303">	if (flags &amp; PCI_rom_enable)</a>
<a name="ln304">		TRACE(&quot;%s: PCI ROM decode enabled\n&quot;, __func__);</a>
<a name="ln305"> </a>
<a name="ln306">	uint32 romBase = info.pci-&gt;u.h0.rom_base;</a>
<a name="ln307">	uint32 romSize = info.pci-&gt;u.h0.rom_size;</a>
<a name="ln308"> </a>
<a name="ln309">	status_t result = B_OK;</a>
<a name="ln310">	if (romBase == 0 || romSize == 0) {</a>
<a name="ln311">		ERROR(&quot;%s: No AtomBIOS location found at PCI ROM BAR\n&quot;, __func__);</a>
<a name="ln312">		result = B_ERROR;</a>
<a name="ln313">	} else {</a>
<a name="ln314">		result = mapAtomBIOS(info, romBase, romSize);</a>
<a name="ln315">	}</a>
<a name="ln316"> </a>
<a name="ln317">	if (result == B_OK) {</a>
<a name="ln318">		ERROR(&quot;%s: AtomBIOS found using disabled method at 0x%&quot; B_PRIX32</a>
<a name="ln319">			&quot; [size: 0x%&quot; B_PRIX32 &quot;]\n&quot;, __func__, romBase, romSize);</a>
<a name="ln320">		info.shared_info-&gt;rom_phys = romBase;</a>
<a name="ln321">		info.shared_info-&gt;rom_size = romSize;</a>
<a name="ln322">	}</a>
<a name="ln323"> </a>
<a name="ln324">	// Disable ROM decoding</a>
<a name="ln325">	pciConfig &amp;= ~PCI_rom_enable;</a>
<a name="ln326">	set_pci_config(info.pci, PCI_rom_base, 4, pciConfig);</a>
<a name="ln327"> </a>
<a name="ln328">	// restore regs</a>
<a name="ln329">	write32(info.registers + RADEON_VIPH_CONTROL, viph_control);</a>
<a name="ln330">	write32(info.registers + R600_BUS_CNTL, bus_cntl);</a>
<a name="ln331">	write32(info.registers + AVIVO_D1VGA_CONTROL, d1vga_control);</a>
<a name="ln332">	write32(info.registers + AVIVO_D2VGA_CONTROL, d2vga_control);</a>
<a name="ln333">	write32(info.registers + AVIVO_VGA_RENDER_CONTROL, vga_render_control);</a>
<a name="ln334">	write32(info.registers + R600_ROM_CNTL, rom_cntl);</a>
<a name="ln335"> </a>
<a name="ln336">	return result;</a>
<a name="ln337">}</a>
<a name="ln338"> </a>
<a name="ln339"> </a>
<a name="ln340">static status_t</a>
<a name="ln341">radeon_hd_getbios_r600(radeon_info &amp;info)</a>
<a name="ln342">{</a>
<a name="ln343">	TRACE(&quot;card(%ld): %s: called\n&quot;, info.id, __func__);</a>
<a name="ln344">	uint32 viph_control = read32(info.registers + RADEON_VIPH_CONTROL);</a>
<a name="ln345">	uint32 bus_cntl = read32(info.registers + R600_BUS_CNTL);</a>
<a name="ln346">	uint32 d1vga_control = read32(info.registers + AVIVO_D1VGA_CONTROL);</a>
<a name="ln347">	uint32 d2vga_control = read32(info.registers + AVIVO_D2VGA_CONTROL);</a>
<a name="ln348">	uint32 vga_render_control</a>
<a name="ln349">		= read32(info.registers + AVIVO_VGA_RENDER_CONTROL);</a>
<a name="ln350">	uint32 rom_cntl = read32(info.registers + R600_ROM_CNTL);</a>
<a name="ln351">	uint32 general_pwrmgt = read32(info.registers + R600_GENERAL_PWRMGT);</a>
<a name="ln352">	uint32 low_vid_lower_gpio_cntl</a>
<a name="ln353">		= read32(info.registers + R600_LOW_VID_LOWER_GPIO_CNTL);</a>
<a name="ln354">	uint32 medium_vid_lower_gpio_cntl</a>
<a name="ln355">		= read32(info.registers + R600_MEDIUM_VID_LOWER_GPIO_CNTL);</a>
<a name="ln356">	uint32 high_vid_lower_gpio_cntl</a>
<a name="ln357">		= read32(info.registers + R600_HIGH_VID_LOWER_GPIO_CNTL);</a>
<a name="ln358">	uint32 ctxsw_vid_lower_gpio_cntl</a>
<a name="ln359">		= read32(info.registers + R600_CTXSW_VID_LOWER_GPIO_CNTL);</a>
<a name="ln360">	uint32 lower_gpio_enable</a>
<a name="ln361">		= read32(info.registers + R600_LOWER_GPIO_ENABLE);</a>
<a name="ln362"> </a>
<a name="ln363">	// disable VIP</a>
<a name="ln364">	write32(info.registers + RADEON_VIPH_CONTROL,</a>
<a name="ln365">		(viph_control &amp; ~RADEON_VIPH_EN));</a>
<a name="ln366">	// enable the rom</a>
<a name="ln367">	write32(info.registers + R600_BUS_CNTL, (bus_cntl &amp; ~R600_BIOS_ROM_DIS));</a>
<a name="ln368">	// disable VGA mode</a>
<a name="ln369">	write32(info.registers + AVIVO_D1VGA_CONTROL, (d1vga_control</a>
<a name="ln370">		&amp; ~(AVIVO_DVGA_CONTROL_MODE_ENABLE</a>
<a name="ln371">			| AVIVO_DVGA_CONTROL_TIMING_SELECT)));</a>
<a name="ln372">	write32(info.registers + AVIVO_D2VGA_CONTROL, (d2vga_control</a>
<a name="ln373">		&amp; ~(AVIVO_DVGA_CONTROL_MODE_ENABLE</a>
<a name="ln374">			| AVIVO_DVGA_CONTROL_TIMING_SELECT)));</a>
<a name="ln375">	write32(info.registers + AVIVO_VGA_RENDER_CONTROL,</a>
<a name="ln376">		(vga_render_control &amp; ~AVIVO_VGA_VSTATUS_CNTL_MASK));</a>
<a name="ln377"> </a>
<a name="ln378">	write32(info.registers + R600_ROM_CNTL,</a>
<a name="ln379">		((rom_cntl &amp; ~R600_SCK_PRESCALE_CRYSTAL_CLK_MASK)</a>
<a name="ln380">		| (1 &lt;&lt; R600_SCK_PRESCALE_CRYSTAL_CLK_SHIFT) | R600_SCK_OVERWRITE));</a>
<a name="ln381"> </a>
<a name="ln382">	write32(info.registers + R600_GENERAL_PWRMGT,</a>
<a name="ln383">		(general_pwrmgt &amp; ~R600_OPEN_DRAIN_PADS));</a>
<a name="ln384">	write32(info.registers + R600_LOW_VID_LOWER_GPIO_CNTL,</a>
<a name="ln385">		(low_vid_lower_gpio_cntl &amp; ~0x400));</a>
<a name="ln386">	write32(info.registers + R600_MEDIUM_VID_LOWER_GPIO_CNTL,</a>
<a name="ln387">		(medium_vid_lower_gpio_cntl &amp; ~0x400));</a>
<a name="ln388">	write32(info.registers + R600_HIGH_VID_LOWER_GPIO_CNTL,</a>
<a name="ln389">		(high_vid_lower_gpio_cntl &amp; ~0x400));</a>
<a name="ln390">	write32(info.registers + R600_CTXSW_VID_LOWER_GPIO_CNTL,</a>
<a name="ln391">		(ctxsw_vid_lower_gpio_cntl &amp; ~0x400));</a>
<a name="ln392">	write32(info.registers + R600_LOWER_GPIO_ENABLE,</a>
<a name="ln393">		(lower_gpio_enable | 0x400));</a>
<a name="ln394"> </a>
<a name="ln395">	// try to grab the bios via PCI ROM bar</a>
<a name="ln396">	// Enable ROM decoding for PCI BAR rom</a>
<a name="ln397">	uint32 pciConfig = get_pci_config(info.pci, PCI_rom_base, 4);</a>
<a name="ln398">	pciConfig |= PCI_rom_enable;</a>
<a name="ln399">	set_pci_config(info.pci, PCI_rom_base, 4, pciConfig);</a>
<a name="ln400"> </a>
<a name="ln401">	uint32 flags = get_pci_config(info.pci, PCI_rom_base, 4);</a>
<a name="ln402">	if (flags &amp; PCI_rom_enable)</a>
<a name="ln403">		TRACE(&quot;%s: PCI ROM decode enabled\n&quot;, __func__);</a>
<a name="ln404"> </a>
<a name="ln405">	uint32 romBase = info.pci-&gt;u.h0.rom_base;</a>
<a name="ln406">	uint32 romSize = info.pci-&gt;u.h0.rom_size;</a>
<a name="ln407"> </a>
<a name="ln408">	status_t result = B_OK;</a>
<a name="ln409">	if (romBase == 0 || romSize == 0) {</a>
<a name="ln410">		ERROR(&quot;%s: No AtomBIOS location found at PCI ROM BAR\n&quot;, __func__);</a>
<a name="ln411">		result = B_ERROR;</a>
<a name="ln412">	} else {</a>
<a name="ln413">		result = mapAtomBIOS(info, romBase, romSize);</a>
<a name="ln414">	}</a>
<a name="ln415"> </a>
<a name="ln416">	if (result == B_OK) {</a>
<a name="ln417">		ERROR(&quot;%s: AtomBIOS found using disabled method at 0x%&quot; B_PRIX32</a>
<a name="ln418">			&quot; [size: 0x%&quot; B_PRIX32 &quot;]\n&quot;, __func__, romBase, romSize);</a>
<a name="ln419">		info.shared_info-&gt;rom_phys = romBase;</a>
<a name="ln420">		info.shared_info-&gt;rom_size = romSize;</a>
<a name="ln421">	}</a>
<a name="ln422"> </a>
<a name="ln423">	// Disable ROM decoding</a>
<a name="ln424">	pciConfig &amp;= ~PCI_rom_enable;</a>
<a name="ln425">	set_pci_config(info.pci, PCI_rom_base, 4, pciConfig);</a>
<a name="ln426"> </a>
<a name="ln427">	// restore regs</a>
<a name="ln428">	write32(info.registers + RADEON_VIPH_CONTROL, viph_control);</a>
<a name="ln429">	write32(info.registers + R600_BUS_CNTL, bus_cntl);</a>
<a name="ln430">	write32(info.registers + AVIVO_D1VGA_CONTROL, d1vga_control);</a>
<a name="ln431">	write32(info.registers + AVIVO_D2VGA_CONTROL, d2vga_control);</a>
<a name="ln432">	write32(info.registers + AVIVO_VGA_RENDER_CONTROL, vga_render_control);</a>
<a name="ln433">	write32(info.registers + R600_ROM_CNTL, rom_cntl);</a>
<a name="ln434">	write32(info.registers + R600_GENERAL_PWRMGT, general_pwrmgt);</a>
<a name="ln435">	write32(info.registers + R600_LOW_VID_LOWER_GPIO_CNTL,</a>
<a name="ln436">		low_vid_lower_gpio_cntl);</a>
<a name="ln437">	write32(info.registers + R600_MEDIUM_VID_LOWER_GPIO_CNTL,</a>
<a name="ln438">		medium_vid_lower_gpio_cntl);</a>
<a name="ln439">	write32(info.registers + R600_HIGH_VID_LOWER_GPIO_CNTL,</a>
<a name="ln440">		high_vid_lower_gpio_cntl);</a>
<a name="ln441">	write32(info.registers + R600_CTXSW_VID_LOWER_GPIO_CNTL,</a>
<a name="ln442">		ctxsw_vid_lower_gpio_cntl);</a>
<a name="ln443">	write32(info.registers + R600_LOWER_GPIO_ENABLE, lower_gpio_enable);</a>
<a name="ln444"> </a>
<a name="ln445">	return result;</a>
<a name="ln446">}</a>
<a name="ln447"> </a>
<a name="ln448"> </a>
<a name="ln449">static status_t</a>
<a name="ln450">radeon_hd_getbios_avivo(radeon_info &amp;info)</a>
<a name="ln451">{</a>
<a name="ln452">	TRACE(&quot;card(%ld): %s: called\n&quot;, info.id, __func__);</a>
<a name="ln453">	uint32 sepromControl = read32(info.registers + RADEON_SEPROM_CNTL1);</a>
<a name="ln454">	uint32 viphControl = read32(info.registers + RADEON_VIPH_CONTROL);</a>
<a name="ln455">	uint32 busControl = read32(info.registers + RV370_BUS_CNTL);</a>
<a name="ln456">	uint32 d1vgaControl = read32(info.registers + AVIVO_D1VGA_CONTROL);</a>
<a name="ln457">	uint32 d2vgaControl = read32(info.registers + AVIVO_D2VGA_CONTROL);</a>
<a name="ln458">	uint32 vgaRenderControl</a>
<a name="ln459">		= read32(info.registers + AVIVO_VGA_RENDER_CONTROL);</a>
<a name="ln460">	uint32 gpioPadA = read32(info.registers + RADEON_GPIOPAD_A);</a>
<a name="ln461">	uint32 gpioPadEN = read32(info.registers + RADEON_GPIOPAD_EN);</a>
<a name="ln462">	uint32 gpioPadMask = read32(info.registers + RADEON_GPIOPAD_MASK);</a>
<a name="ln463"> </a>
<a name="ln464">	write32(info.registers + RADEON_SEPROM_CNTL1,</a>
<a name="ln465">		((sepromControl &amp; ~RADEON_SCK_PRESCALE_MASK)</a>
<a name="ln466">		| (0xc &lt;&lt; RADEON_SCK_PRESCALE_SHIFT)));</a>
<a name="ln467">	write32(info.registers + RADEON_GPIOPAD_A, 0);</a>
<a name="ln468">	write32(info.registers + RADEON_GPIOPAD_EN, 0);</a>
<a name="ln469">	write32(info.registers + RADEON_GPIOPAD_MASK, 0);</a>
<a name="ln470"> </a>
<a name="ln471">	// disable VIP</a>
<a name="ln472">	write32(info.registers + RADEON_VIPH_CONTROL,</a>
<a name="ln473">		(viphControl &amp; ~RADEON_VIPH_EN));</a>
<a name="ln474"> </a>
<a name="ln475">	// enable the ROM</a>
<a name="ln476">	write32(info.registers + RV370_BUS_CNTL,</a>
<a name="ln477">		(busControl &amp; ~RV370_BUS_BIOS_DIS_ROM));</a>
<a name="ln478"> </a>
<a name="ln479">	// disable VGA</a>
<a name="ln480">	write32(info.registers + AVIVO_D1VGA_CONTROL,</a>
<a name="ln481">		(d1vgaControl &amp; ~(AVIVO_DVGA_CONTROL_MODE_ENABLE</a>
<a name="ln482">		| AVIVO_DVGA_CONTROL_TIMING_SELECT)));</a>
<a name="ln483">	write32(info.registers + AVIVO_D2VGA_CONTROL,</a>
<a name="ln484">		(d2vgaControl &amp; ~(AVIVO_DVGA_CONTROL_MODE_ENABLE</a>
<a name="ln485">		| AVIVO_DVGA_CONTROL_TIMING_SELECT)));</a>
<a name="ln486">	write32(info.registers + AVIVO_VGA_RENDER_CONTROL,</a>
<a name="ln487">		(vgaRenderControl &amp; ~AVIVO_VGA_VSTATUS_CNTL_MASK));</a>
<a name="ln488"> </a>
<a name="ln489">	uint32 romBase = info.pci-&gt;u.h0.rom_base;</a>
<a name="ln490">	uint32 romSize = info.pci-&gt;u.h0.rom_size;</a>
<a name="ln491"> </a>
<a name="ln492">	status_t result = B_OK;</a>
<a name="ln493">	if (romBase == 0 || romSize == 0) {</a>
<a name="ln494">		ERROR(&quot;%s: No AtomBIOS location found at PCI ROM BAR\n&quot;, __func__);</a>
<a name="ln495">		result = B_ERROR;</a>
<a name="ln496">	} else {</a>
<a name="ln497">		result = mapAtomBIOS(info, romBase, romSize);</a>
<a name="ln498">	}</a>
<a name="ln499"> </a>
<a name="ln500">	if (result == B_OK) {</a>
<a name="ln501">		ERROR(&quot;%s: AtomBIOS found using disabled method at 0x%&quot; B_PRIX32</a>
<a name="ln502">			&quot; [size: 0x%&quot; B_PRIX32 &quot;]\n&quot;, __func__, romBase, romSize);</a>
<a name="ln503">		info.shared_info-&gt;rom_phys = romBase;</a>
<a name="ln504">		info.shared_info-&gt;rom_size = romSize;</a>
<a name="ln505">	}</a>
<a name="ln506"> </a>
<a name="ln507">	// restore registers</a>
<a name="ln508">	write32(info.registers + RADEON_SEPROM_CNTL1, sepromControl);</a>
<a name="ln509">	write32(info.registers + RADEON_VIPH_CONTROL, viphControl);</a>
<a name="ln510">	write32(info.registers + RV370_BUS_CNTL, busControl);</a>
<a name="ln511">	write32(info.registers + AVIVO_D1VGA_CONTROL, d1vgaControl);</a>
<a name="ln512">	write32(info.registers + AVIVO_D2VGA_CONTROL, d2vgaControl);</a>
<a name="ln513">	write32(info.registers + AVIVO_VGA_RENDER_CONTROL, vgaRenderControl);</a>
<a name="ln514">	write32(info.registers + RADEON_GPIOPAD_A, gpioPadA);</a>
<a name="ln515">	write32(info.registers + RADEON_GPIOPAD_EN, gpioPadEN);</a>
<a name="ln516">	write32(info.registers + RADEON_GPIOPAD_MASK, gpioPadMask);</a>
<a name="ln517"> </a>
<a name="ln518">	return result;</a>
<a name="ln519">}</a>
<a name="ln520"> </a>
<a name="ln521"> </a>
<a name="ln522">static uint32</a>
<a name="ln523">radeon_hd_pci_bar_mmio(uint16 chipsetID)</a>
<a name="ln524">{</a>
<a name="ln525">	if (chipsetID &lt; RADEON_BONAIRE)</a>
<a name="ln526">		return 2;</a>
<a name="ln527">	else</a>
<a name="ln528">		return 5;</a>
<a name="ln529">}</a>
<a name="ln530"> </a>
<a name="ln531"> </a>
<a name="ln532">status_t</a>
<a name="ln533">radeon_hd_init(radeon_info &amp;info)</a>
<a name="ln534">{</a>
<a name="ln535">	TRACE(&quot;card(%ld): %s: called\n&quot;, info.id, __func__);</a>
<a name="ln536"> </a>
<a name="ln537">	ERROR(&quot;%s: card(%ld): &quot;</a>
<a name="ln538">		&quot;Radeon %s 1002:%&quot; B_PRIX32 &quot;\n&quot;, __func__, info.id,</a>
<a name="ln539">		radeon_chip_name[info.chipsetID], info.pciID);</a>
<a name="ln540"> </a>
<a name="ln541">	// *** Map shared info</a>
<a name="ln542">	AreaKeeper sharedCreator;</a>
<a name="ln543">	info.shared_area = sharedCreator.Create(&quot;radeon hd shared info&quot;,</a>
<a name="ln544">		(void**)&amp;info.shared_info, B_ANY_KERNEL_ADDRESS,</a>
<a name="ln545">		ROUND_TO_PAGE_SIZE(sizeof(radeon_shared_info)), B_FULL_LOCK,</a>
<a name="ln546">		B_KERNEL_READ_AREA | B_KERNEL_WRITE_AREA | B_USER_CLONEABLE_AREA);</a>
<a name="ln547">	if (info.shared_area &lt; B_OK) {</a>
<a name="ln548">		ERROR(&quot;%s: card (%ld): couldn't map shared area!\n&quot;,</a>
<a name="ln549">			__func__, info.id);</a>
<a name="ln550">		return info.shared_area;</a>
<a name="ln551">	}</a>
<a name="ln552"> </a>
<a name="ln553">	memset((void*)info.shared_info, 0, sizeof(radeon_shared_info));</a>
<a name="ln554">	sharedCreator.Detach();</a>
<a name="ln555"> </a>
<a name="ln556">	// *** Map Memory mapped IO</a>
<a name="ln557">	AreaKeeper mmioMapper;</a>
<a name="ln558">	const uint32 pciBarMmio = radeon_hd_pci_bar_mmio(info.chipsetID);</a>
<a name="ln559">	info.registers_area = mmioMapper.Map(&quot;radeon hd mmio&quot;,</a>
<a name="ln560">		info.pci-&gt;u.h0.base_registers[pciBarMmio],</a>
<a name="ln561">		info.pci-&gt;u.h0.base_register_sizes[pciBarMmio],</a>
<a name="ln562">		B_ANY_KERNEL_ADDRESS,</a>
<a name="ln563">		B_KERNEL_READ_AREA | B_KERNEL_WRITE_AREA | B_USER_CLONEABLE_AREA,</a>
<a name="ln564">		(void**)&amp;info.registers);</a>
<a name="ln565">	if (mmioMapper.InitCheck() &lt; B_OK) {</a>
<a name="ln566">		ERROR(&quot;%s: card (%ld): couldn't map memory I/O!\n&quot;,</a>
<a name="ln567">			__func__, info.id);</a>
<a name="ln568">		return info.registers_area;</a>
<a name="ln569">	}</a>
<a name="ln570">	mmioMapper.Detach();</a>
<a name="ln571"> </a>
<a name="ln572">	// *** Populate frame buffer information</a>
<a name="ln573">	if (info.chipsetID &gt;= RADEON_CEDAR) {</a>
<a name="ln574">		if ((info.chipsetFlags &amp; CHIP_APU) != 0</a>
<a name="ln575">			|| (info.chipsetFlags &amp; CHIP_IGP) != 0) {</a>
<a name="ln576">			// Evergreen+ fusion in bytes</a>
<a name="ln577">			info.shared_info-&gt;graphics_memory_size</a>
<a name="ln578">				= read32(info.registers + CONFIG_MEMSIZE) / 1024;</a>
<a name="ln579">		} else {</a>
<a name="ln580">			// Evergreen+ has memory stored in MB</a>
<a name="ln581">			info.shared_info-&gt;graphics_memory_size</a>
<a name="ln582">				= read32(info.registers + CONFIG_MEMSIZE) * 1024;</a>
<a name="ln583">		}</a>
<a name="ln584">	} else if (info.chipsetID &gt;= RADEON_R600) {</a>
<a name="ln585">		// R600-R700 has memory stored in bytes</a>
<a name="ln586">		info.shared_info-&gt;graphics_memory_size</a>
<a name="ln587">			= read32(info.registers + CONFIG_MEMSIZE) / 1024;</a>
<a name="ln588">	} else {</a>
<a name="ln589">		// R420 - R600 cards</a>
<a name="ln590">		// older cards use RADEON_CONFIG_MEMSIZE vs CONFIG_MEMSIZE</a>
<a name="ln591">		if ((info.chipsetFlags &amp; CHIP_IGP) != 0) {</a>
<a name="ln592">			// NB_TOM holds amount of ram stolen for GPU</a>
<a name="ln593">			uint32 tom = read32(info.registers + RADEON_NB_TOM);</a>
<a name="ln594">			info.shared_info-&gt;graphics_memory_size</a>
<a name="ln595">				= (((tom &gt;&gt; 16) - (tom &amp; 0xffff) + 1) &lt;&lt; 16);</a>
<a name="ln596">			write32(info.registers + RADEON_CONFIG_MEMSIZE,</a>
<a name="ln597">				info.shared_info-&gt;graphics_memory_size);</a>
<a name="ln598">		} else {</a>
<a name="ln599">			info.shared_info-&gt;graphics_memory_size</a>
<a name="ln600">				= read32(info.registers + RADEON_CONFIG_MEMSIZE);</a>
<a name="ln601">			if (info.shared_info-&gt;graphics_memory_size == 0) {</a>
<a name="ln602">				// known bug if video memory == 8MB</a>
<a name="ln603">				info.shared_info-&gt;graphics_memory_size = 8192;</a>
<a name="ln604">				write32(info.registers + RADEON_CONFIG_MEMSIZE,</a>
<a name="ln605">					info.shared_info-&gt;graphics_memory_size * 1024);</a>
<a name="ln606">			}</a>
<a name="ln607">		}</a>
<a name="ln608">	}</a>
<a name="ln609"> </a>
<a name="ln610">	uint32 barSize = info.pci-&gt;u.h0.base_register_sizes[PCI_BAR_FB] / 1024;</a>
<a name="ln611"> </a>
<a name="ln612">	// if graphics memory is larger then PCI bar, just map bar</a>
<a name="ln613">	if (info.shared_info-&gt;graphics_memory_size == 0) {</a>
<a name="ln614">		// we can recover as we have PCI FB bar, but this should be fixed</a>
<a name="ln615">		ERROR(&quot;%s: Error: found 0MB video ram, using PCI bar size...\n&quot;,</a>
<a name="ln616">			__func__);</a>
<a name="ln617">		info.shared_info-&gt;frame_buffer_size = barSize;</a>
<a name="ln618">	} else if (info.shared_info-&gt;graphics_memory_size &gt; barSize) {</a>
<a name="ln619">		TRACE(&quot;%s: shrinking frame buffer to PCI bar...\n&quot;,</a>
<a name="ln620">			__func__);</a>
<a name="ln621">		info.shared_info-&gt;frame_buffer_size = barSize;</a>
<a name="ln622">	} else {</a>
<a name="ln623">		info.shared_info-&gt;frame_buffer_size</a>
<a name="ln624">			= info.shared_info-&gt;graphics_memory_size;</a>
<a name="ln625">	}</a>
<a name="ln626"> </a>
<a name="ln627">	TRACE(&quot;%s: mapping a frame buffer of %&quot; B_PRIu32 &quot;MB out of %&quot; B_PRIu32</a>
<a name="ln628">		&quot;MB video ram\n&quot;, __func__, info.shared_info-&gt;frame_buffer_size / 1024,</a>
<a name="ln629">		info.shared_info-&gt;graphics_memory_size / 1024);</a>
<a name="ln630"> </a>
<a name="ln631">	// *** Framebuffer mapping</a>
<a name="ln632">	AreaKeeper frambufferMapper;</a>
<a name="ln633">	info.framebuffer_area = frambufferMapper.Map(&quot;radeon hd frame buffer&quot;,</a>
<a name="ln634">		info.pci-&gt;u.h0.base_registers[PCI_BAR_FB],</a>
<a name="ln635">		info.shared_info-&gt;frame_buffer_size * 1024,</a>
<a name="ln636">		B_ANY_KERNEL_ADDRESS, B_READ_AREA | B_WRITE_AREA,</a>
<a name="ln637">		(void**)&amp;info.shared_info-&gt;frame_buffer);</a>
<a name="ln638">	if (frambufferMapper.InitCheck() &lt; B_OK) {</a>
<a name="ln639">		ERROR(&quot;%s: card(%ld): couldn't map frame buffer!\n&quot;,</a>
<a name="ln640">			__func__, info.id);</a>
<a name="ln641">		return info.framebuffer_area;</a>
<a name="ln642">	}</a>
<a name="ln643"> </a>
<a name="ln644">	// Turn on write combining for the frame buffer area</a>
<a name="ln645">	vm_set_area_memory_type(info.framebuffer_area,</a>
<a name="ln646">		info.pci-&gt;u.h0.base_registers[PCI_BAR_FB], B_MTR_WC);</a>
<a name="ln647"> </a>
<a name="ln648">	frambufferMapper.Detach();</a>
<a name="ln649"> </a>
<a name="ln650">	info.shared_info-&gt;frame_buffer_area = info.framebuffer_area;</a>
<a name="ln651">	info.shared_info-&gt;frame_buffer_phys</a>
<a name="ln652">		= info.pci-&gt;u.h0.base_registers[PCI_BAR_FB];</a>
<a name="ln653"> </a>
<a name="ln654">	// Pass common information to accelerant</a>
<a name="ln655">	info.shared_info-&gt;deviceIndex = info.id;</a>
<a name="ln656">	info.shared_info-&gt;pciID = info.pciID;</a>
<a name="ln657">	info.shared_info-&gt;pciRev = info.pci-&gt;revision;</a>
<a name="ln658">	info.shared_info-&gt;chipsetID = info.chipsetID;</a>
<a name="ln659">	info.shared_info-&gt;chipsetFlags = info.chipsetFlags;</a>
<a name="ln660">	info.shared_info-&gt;dceMajor = info.dceMajor;</a>
<a name="ln661">	info.shared_info-&gt;dceMinor = info.dceMinor;</a>
<a name="ln662">	info.shared_info-&gt;registers_area = info.registers_area;</a>
<a name="ln663">	strlcpy(info.shared_info-&gt;deviceName,</a>
<a name="ln664">		info.deviceName, MAX_NAME_LENGTH);</a>
<a name="ln665">	strlcpy(info.shared_info-&gt;chipsetName,</a>
<a name="ln666">		radeon_chip_name[info.chipsetID], MAX_NAME_LENGTH);</a>
<a name="ln667"> </a>
<a name="ln668">	// *** AtomBIOS mapping</a>
<a name="ln669">	// First we try an active bios read</a>
<a name="ln670">	status_t biosStatus = radeon_hd_getbios(info);</a>
<a name="ln671"> </a>
<a name="ln672">	if (biosStatus != B_OK) {</a>
<a name="ln673">		// If the active read fails, we try a disabled read</a>
<a name="ln674">		if (info.chipsetID &gt;= RADEON_CAICOS)</a>
<a name="ln675">			biosStatus = radeon_hd_getbios_ni(info);</a>
<a name="ln676">		else if (info.chipsetID &gt;= RADEON_RV770)</a>
<a name="ln677">			biosStatus = radeon_hd_getbios_r700(info);</a>
<a name="ln678">		else if (info.chipsetID &gt;= RADEON_R600)</a>
<a name="ln679">			biosStatus = radeon_hd_getbios_r600(info);</a>
<a name="ln680">		else if (info.chipsetID &gt;= RADEON_RS600)</a>
<a name="ln681">			biosStatus = radeon_hd_getbios_avivo(info);</a>
<a name="ln682">		// else legacy_read_disabled_bios</a>
<a name="ln683">	}</a>
<a name="ln684"> </a>
<a name="ln685">	if (biosStatus != B_OK) {</a>
<a name="ln686">		// *** very last resort, shadow bios VGA rom</a>
<a name="ln687">		ERROR(&quot;%s: Can't find an AtomBIOS rom! Trying shadow rom...\n&quot;,</a>
<a name="ln688">			__func__);</a>
<a name="ln689"> </a>
<a name="ln690">		// This works as long as the primary card is what this driver</a>
<a name="ln691">		// is loaded for. Multiple cards may pose the risk of loading</a>
<a name="ln692">		// the wrong AtomBIOS for the wrong card.</a>
<a name="ln693"> </a>
<a name="ln694">		uint32 romBase = 0xC0000;</a>
<a name="ln695">		uint32 romSize = 128 * 1024;</a>
<a name="ln696">			// what happens when AtomBIOS goes over 128Kb?</a>
<a name="ln697">			// A Radeon HD 6990 has a 128Kb AtomBIOS</a>
<a name="ln698"> </a>
<a name="ln699">		if (mapAtomBIOS(info, romBase, romSize) == B_OK) {</a>
<a name="ln700">			ERROR(&quot;%s: Found AtomBIOS at VGA shadow rom\n&quot;, __func__);</a>
<a name="ln701">			// Whew!</a>
<a name="ln702">			info.shared_info-&gt;rom_phys = romBase;</a>
<a name="ln703">			info.shared_info-&gt;rom_size = romSize;</a>
<a name="ln704">			biosStatus = B_OK;</a>
<a name="ln705">		}</a>
<a name="ln706">	}</a>
<a name="ln707"> </a>
<a name="ln708">	// Check if a valid AtomBIOS image was found.</a>
<a name="ln709">	if (biosStatus != B_OK) {</a>
<a name="ln710">		ERROR(&quot;%s: card (%ld): couldn't find AtomBIOS rom!\n&quot;,</a>
<a name="ln711">			__func__, info.id);</a>
<a name="ln712">		ERROR(&quot;%s: card (%ld): exiting. Please open a bug ticket&quot;</a>
<a name="ln713">			&quot; at haiku-os.org with your /var/log/syslog\n&quot;,</a>
<a name="ln714">			__func__, info.id);</a>
<a name="ln715">		// Fallback to VESA (more likely crash app_server)</a>
<a name="ln716">		return B_ERROR;</a>
<a name="ln717">	}</a>
<a name="ln718"> </a>
<a name="ln719">	info.shared_info-&gt;has_rom = (biosStatus == B_OK) ? true : false;</a>
<a name="ln720">	info.shared_info-&gt;rom_area = (biosStatus == B_OK) ? info.rom_area : -1;</a>
<a name="ln721"> </a>
<a name="ln722">	// *** Pull active monitor VESA EDID from boot loader</a>
<a name="ln723">	edid1_info* edidInfo</a>
<a name="ln724">		= (edid1_info*)get_boot_item(EDID_BOOT_INFO, NULL);</a>
<a name="ln725"> </a>
<a name="ln726">	if (edidInfo != NULL) {</a>
<a name="ln727">		TRACE(&quot;card(%ld): %s found VESA EDID information.\n&quot;, info.id,</a>
<a name="ln728">			__func__);</a>
<a name="ln729">		info.shared_info-&gt;has_edid = true;</a>
<a name="ln730">		memcpy(&amp;info.shared_info-&gt;edid_info, edidInfo, sizeof(edid1_info));</a>
<a name="ln731">	} else {</a>
<a name="ln732">		TRACE(&quot;card(%ld): %s didn't find VESA EDID modes.\n&quot;, info.id,</a>
<a name="ln733">			__func__);</a>
<a name="ln734">		info.shared_info-&gt;has_edid = false;</a>
<a name="ln735">	}</a>
<a name="ln736"> </a>
<a name="ln737">	TRACE(&quot;card(%ld): %s completed successfully!\n&quot;, info.id, __func__);</a>
<a name="ln738"> </a>
<a name="ln739">	TRACE(&quot;card(%ld): GPU thermal status: %&quot; B_PRId32 &quot;C\n&quot;, info.id,</a>
<a name="ln740">		radeon_thermal_query(info) / 1000);</a>
<a name="ln741"> </a>
<a name="ln742">	return B_OK;</a>
<a name="ln743">}</a>
<a name="ln744"> </a>
<a name="ln745"> </a>
<a name="ln746">void</a>
<a name="ln747">radeon_hd_uninit(radeon_info &amp;info)</a>
<a name="ln748">{</a>
<a name="ln749">	TRACE(&quot;card(%ld): %s called\n&quot;, info.id, __func__);</a>
<a name="ln750"> </a>
<a name="ln751">	delete_area(info.shared_area);</a>
<a name="ln752">	delete_area(info.registers_area);</a>
<a name="ln753">	delete_area(info.framebuffer_area);</a>
<a name="ln754">	delete_area(info.rom_area);</a>
<a name="ln755">}</a>
<a name="ln756"> </a>

</code></pre>
<div class="balloon" rel="639"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="710"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="712"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="732"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="737"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="537"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="566"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="548"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="535"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="727"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="343"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="270"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="202"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="123"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="739"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="720"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'biosStatus == ((int) 0)' is always true.</p></div>
<div class="balloon" rel="719"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'biosStatus == ((int) 0)' is always true.</p></div>
<div class="balloon" rel="452"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="749"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'dprintf' function. The memsize type argument is expected.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
