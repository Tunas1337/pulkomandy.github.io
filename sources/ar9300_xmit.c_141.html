
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ar9300_xmit.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright (c) 2013 Qualcomm Atheros, Inc.</a>
<a name="ln3"> *</a>
<a name="ln4"> * Permission to use, copy, modify, and/or distribute this software for any</a>
<a name="ln5"> * purpose with or without fee is hereby granted, provided that the above</a>
<a name="ln6"> * copyright notice and this permission notice appear in all copies.</a>
<a name="ln7"> *</a>
<a name="ln8"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH</a>
<a name="ln9"> * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY</a>
<a name="ln10"> * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,</a>
<a name="ln11"> * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM</a>
<a name="ln12"> * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR</a>
<a name="ln13"> * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR</a>
<a name="ln14"> * PERFORMANCE OF THIS SOFTWARE.</a>
<a name="ln15"> */</a>
<a name="ln16"> </a>
<a name="ln17">#include &quot;opt_ah.h&quot;</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;ah.h&quot;</a>
<a name="ln20">#include &quot;ah_desc.h&quot;</a>
<a name="ln21">#include &quot;ah_internal.h&quot;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;ar9300/ar9300.h&quot;</a>
<a name="ln24">#include &quot;ar9300/ar9300reg.h&quot;</a>
<a name="ln25">#include &quot;ar9300/ar9300phy.h&quot;</a>
<a name="ln26">#include &quot;ar9300/ar9300desc.h&quot;</a>
<a name="ln27"> </a>
<a name="ln28">#define TU_TO_USEC(_tu)         ((_tu) &lt;&lt; 10)</a>
<a name="ln29">#define ONE_EIGHTH_TU_TO_USEC(_tu8)     ((_tu8) &lt;&lt; 7)</a>
<a name="ln30"> </a>
<a name="ln31">/*</a>
<a name="ln32"> * Update Tx FIFO trigger level.</a>
<a name="ln33"> *</a>
<a name="ln34"> * Set b_inc_trig_level to TRUE to increase the trigger level.</a>
<a name="ln35"> * Set b_inc_trig_level to FALSE to decrease the trigger level.</a>
<a name="ln36"> *</a>
<a name="ln37"> * Returns TRUE if the trigger level was updated</a>
<a name="ln38"> */</a>
<a name="ln39">HAL_BOOL</a>
<a name="ln40">ar9300_update_tx_trig_level(struct ath_hal *ah, HAL_BOOL b_inc_trig_level)</a>
<a name="ln41">{</a>
<a name="ln42">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln43">    u_int32_t txcfg, cur_level, new_level;</a>
<a name="ln44">    HAL_INT omask;</a>
<a name="ln45"> </a>
<a name="ln46">    if (AH9300(ah)-&gt;ah_tx_trig_level &gt;= MAX_TX_FIFO_THRESHOLD &amp;&amp;</a>
<a name="ln47">        b_inc_trig_level)</a>
<a name="ln48">    {</a>
<a name="ln49">        return AH_FALSE;</a>
<a name="ln50">    }</a>
<a name="ln51"> </a>
<a name="ln52">    /*</a>
<a name="ln53">     * Disable interrupts while futzing with the fifo level.</a>
<a name="ln54">     */</a>
<a name="ln55">    omask = ar9300_set_interrupts(ah, ahp-&gt;ah_mask_reg &amp;~ HAL_INT_GLOBAL, 0);</a>
<a name="ln56"> </a>
<a name="ln57">    txcfg = OS_REG_READ(ah, AR_TXCFG);</a>
<a name="ln58">    cur_level = MS(txcfg, AR_FTRIG);</a>
<a name="ln59">    new_level = cur_level;</a>
<a name="ln60"> </a>
<a name="ln61">    if (b_inc_trig_level)  {   /* increase the trigger level */</a>
<a name="ln62">        if (cur_level &lt; MAX_TX_FIFO_THRESHOLD) {</a>
<a name="ln63">            new_level++;</a>
<a name="ln64">        }</a>
<a name="ln65">    } else if (cur_level &gt; MIN_TX_FIFO_THRESHOLD) {</a>
<a name="ln66">        new_level--;</a>
<a name="ln67">    }</a>
<a name="ln68"> </a>
<a name="ln69">    if (new_level != cur_level) {</a>
<a name="ln70">        /* Update the trigger level */</a>
<a name="ln71">        OS_REG_WRITE(ah,</a>
<a name="ln72">            AR_TXCFG, (txcfg &amp;~ AR_FTRIG) | SM(new_level, AR_FTRIG));</a>
<a name="ln73">    }</a>
<a name="ln74"> </a>
<a name="ln75">    /* re-enable chip interrupts */</a>
<a name="ln76">    ar9300_set_interrupts(ah, omask, 0);</a>
<a name="ln77"> </a>
<a name="ln78">    AH9300(ah)-&gt;ah_tx_trig_level = new_level;</a>
<a name="ln79"> </a>
<a name="ln80">    return (new_level != cur_level);</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83">/*</a>
<a name="ln84"> * Returns the value of Tx Trigger Level</a>
<a name="ln85"> */</a>
<a name="ln86">u_int16_t</a>
<a name="ln87">ar9300_get_tx_trig_level(struct ath_hal *ah)</a>
<a name="ln88">{</a>
<a name="ln89">    return (AH9300(ah)-&gt;ah_tx_trig_level);</a>
<a name="ln90">}</a>
<a name="ln91"> </a>
<a name="ln92">/*</a>
<a name="ln93"> * Set the properties of the tx queue with the parameters</a>
<a name="ln94"> * from q_info.</a>
<a name="ln95"> */</a>
<a name="ln96">HAL_BOOL</a>
<a name="ln97">ar9300_set_tx_queue_props(struct ath_hal *ah, int q, const HAL_TXQ_INFO *q_info)</a>
<a name="ln98">{</a>
<a name="ln99">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln100">    HAL_CAPABILITIES *p_cap = &amp;AH_PRIVATE(ah)-&gt;ah_caps;</a>
<a name="ln101"> </a>
<a name="ln102">    if (q &gt;= p_cap-&gt;halTotalQueues) {</a>
<a name="ln103">        HALDEBUG(ah, HAL_DEBUG_QUEUE, &quot;%s: invalid queue num %u\n&quot;, __func__, q);</a>
<a name="ln104">        return AH_FALSE;</a>
<a name="ln105">    }</a>
<a name="ln106">    return ath_hal_setTxQProps(ah, &amp;ahp-&gt;ah_txq[q], q_info);</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109">/*</a>
<a name="ln110"> * Return the properties for the specified tx queue.</a>
<a name="ln111"> */</a>
<a name="ln112">HAL_BOOL</a>
<a name="ln113">ar9300_get_tx_queue_props(struct ath_hal *ah, int q, HAL_TXQ_INFO *q_info)</a>
<a name="ln114">{</a>
<a name="ln115">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln116">    HAL_CAPABILITIES *p_cap = &amp;AH_PRIVATE(ah)-&gt;ah_caps;</a>
<a name="ln117"> </a>
<a name="ln118"> </a>
<a name="ln119">    if (q &gt;= p_cap-&gt;halTotalQueues) {</a>
<a name="ln120">        HALDEBUG(ah, HAL_DEBUG_QUEUE, &quot;%s: invalid queue num %u\n&quot;, __func__, q);</a>
<a name="ln121">        return AH_FALSE;</a>
<a name="ln122">    }</a>
<a name="ln123">    return ath_hal_getTxQProps(ah, q_info, &amp;ahp-&gt;ah_txq[q]);</a>
<a name="ln124">}</a>
<a name="ln125"> </a>
<a name="ln126">enum {</a>
<a name="ln127">    AH_TX_QUEUE_MINUS_OFFSET_BEACON = 1,</a>
<a name="ln128">    AH_TX_QUEUE_MINUS_OFFSET_CAB    = 2,</a>
<a name="ln129">    AH_TX_QUEUE_MINUS_OFFSET_UAPSD  = 3,</a>
<a name="ln130">    AH_TX_QUEUE_MINUS_OFFSET_PAPRD  = 4,</a>
<a name="ln131">};</a>
<a name="ln132"> </a>
<a name="ln133">/*</a>
<a name="ln134"> * Allocate and initialize a tx DCU/QCU combination.</a>
<a name="ln135"> */</a>
<a name="ln136">int</a>
<a name="ln137">ar9300_setup_tx_queue(struct ath_hal *ah, HAL_TX_QUEUE type,</a>
<a name="ln138">        const HAL_TXQ_INFO *q_info)</a>
<a name="ln139">{</a>
<a name="ln140">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln141">    HAL_TX_QUEUE_INFO *qi;</a>
<a name="ln142">    HAL_CAPABILITIES *p_cap = &amp;AH_PRIVATE(ah)-&gt;ah_caps;</a>
<a name="ln143">    int q;</a>
<a name="ln144"> </a>
<a name="ln145">    /* XXX move queue assignment to driver */</a>
<a name="ln146">    switch (type) {</a>
<a name="ln147">    case HAL_TX_QUEUE_BEACON:</a>
<a name="ln148">        /* highest priority */</a>
<a name="ln149">        q = p_cap-&gt;halTotalQueues - AH_TX_QUEUE_MINUS_OFFSET_BEACON;</a>
<a name="ln150">        break;</a>
<a name="ln151">    case HAL_TX_QUEUE_CAB:</a>
<a name="ln152">        /* next highest priority */</a>
<a name="ln153">        q = p_cap-&gt;halTotalQueues - AH_TX_QUEUE_MINUS_OFFSET_CAB;</a>
<a name="ln154">        break;</a>
<a name="ln155">    case HAL_TX_QUEUE_UAPSD:</a>
<a name="ln156">        q = p_cap-&gt;halTotalQueues - AH_TX_QUEUE_MINUS_OFFSET_UAPSD;</a>
<a name="ln157">        break;</a>
<a name="ln158">    case HAL_TX_QUEUE_PAPRD:</a>
<a name="ln159">        q = p_cap-&gt;halTotalQueues - AH_TX_QUEUE_MINUS_OFFSET_PAPRD;</a>
<a name="ln160">        break;</a>
<a name="ln161">    case HAL_TX_QUEUE_DATA:</a>
<a name="ln162">        /*</a>
<a name="ln163">         * don't infringe on top 4 queues, reserved for:</a>
<a name="ln164">         * beacon, CAB, UAPSD, PAPRD</a>
<a name="ln165">         */</a>
<a name="ln166">        for (q = 0;</a>
<a name="ln167">             q &lt; p_cap-&gt;halTotalQueues - AH_TX_QUEUE_MINUS_OFFSET_PAPRD;</a>
<a name="ln168">             q++)</a>
<a name="ln169">        {</a>
<a name="ln170">            if (ahp-&gt;ah_txq[q].tqi_type == HAL_TX_QUEUE_INACTIVE) {</a>
<a name="ln171">                break;</a>
<a name="ln172">            }</a>
<a name="ln173">        }</a>
<a name="ln174">        if (q == p_cap-&gt;halTotalQueues - 3) {</a>
<a name="ln175">            HALDEBUG(ah, HAL_DEBUG_QUEUE,</a>
<a name="ln176">                &quot;%s: no available tx queue\n&quot;, __func__);</a>
<a name="ln177">            return -1;</a>
<a name="ln178">        }</a>
<a name="ln179">        break;</a>
<a name="ln180">    default:</a>
<a name="ln181">        HALDEBUG(ah, HAL_DEBUG_QUEUE,</a>
<a name="ln182">            &quot;%s: bad tx queue type %u\n&quot;, __func__, type);</a>
<a name="ln183">        return -1;</a>
<a name="ln184">    }</a>
<a name="ln185"> </a>
<a name="ln186">    HALDEBUG(ah, HAL_DEBUG_QUEUE, &quot;%s: queue %u\n&quot;, __func__, q);</a>
<a name="ln187"> </a>
<a name="ln188">    qi = &amp;ahp-&gt;ah_txq[q];</a>
<a name="ln189">    if (qi-&gt;tqi_type != HAL_TX_QUEUE_INACTIVE) {</a>
<a name="ln190">        HALDEBUG(ah, HAL_DEBUG_QUEUE,</a>
<a name="ln191">            &quot;%s: tx queue %u already active\n&quot;, __func__, q);</a>
<a name="ln192">        return -1;</a>
<a name="ln193">    }</a>
<a name="ln194"> </a>
<a name="ln195">    OS_MEMZERO(qi, sizeof(HAL_TX_QUEUE_INFO));</a>
<a name="ln196">    qi-&gt;tqi_type = type;</a>
<a name="ln197"> </a>
<a name="ln198">    if (q_info == AH_NULL) {</a>
<a name="ln199">        /* by default enable OK+ERR+DESC+URN interrupts */</a>
<a name="ln200">        qi-&gt;tqi_qflags = HAL_TXQ_TXOKINT_ENABLE</a>
<a name="ln201">                        | HAL_TXQ_TXERRINT_ENABLE</a>
<a name="ln202">                        | HAL_TXQ_TXDESCINT_ENABLE</a>
<a name="ln203">                        | HAL_TXQ_TXURNINT_ENABLE;</a>
<a name="ln204">        qi-&gt;tqi_aifs = INIT_AIFS;</a>
<a name="ln205">        qi-&gt;tqi_cwmin = HAL_TXQ_USEDEFAULT;     /* NB: do at reset */</a>
<a name="ln206">        qi-&gt;tqi_cwmax = INIT_CWMAX;</a>
<a name="ln207">        qi-&gt;tqi_shretry = INIT_SH_RETRY;</a>
<a name="ln208">        qi-&gt;tqi_lgretry = INIT_LG_RETRY;</a>
<a name="ln209">        qi-&gt;tqi_physCompBuf = 0;</a>
<a name="ln210">    } else {</a>
<a name="ln211">        qi-&gt;tqi_physCompBuf = q_info-&gt;tqi_compBuf;</a>
<a name="ln212">        (void) ar9300_set_tx_queue_props(ah, q, q_info);</a>
<a name="ln213">    }</a>
<a name="ln214">    /* NB: must be followed by ar9300_reset_tx_queue */</a>
<a name="ln215">    return q;</a>
<a name="ln216">}</a>
<a name="ln217"> </a>
<a name="ln218">/*</a>
<a name="ln219"> * Update the h/w interrupt registers to reflect a tx q's configuration.</a>
<a name="ln220"> */</a>
<a name="ln221">static void</a>
<a name="ln222">set_tx_q_interrupts(struct ath_hal *ah, HAL_TX_QUEUE_INFO *qi)</a>
<a name="ln223">{</a>
<a name="ln224">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln225"> </a>
<a name="ln226">    HALDEBUG(ah, HAL_DEBUG_INTERRUPT,</a>
<a name="ln227">            &quot;%s: tx ok 0x%x err 0x%x eol 0x%x urn 0x%x\n&quot;,</a>
<a name="ln228">            __func__,</a>
<a name="ln229">            ahp-&gt;ah_tx_ok_interrupt_mask,</a>
<a name="ln230">            ahp-&gt;ah_tx_err_interrupt_mask,</a>
<a name="ln231">            ahp-&gt;ah_tx_eol_interrupt_mask,</a>
<a name="ln232">            ahp-&gt;ah_tx_urn_interrupt_mask);</a>
<a name="ln233"> </a>
<a name="ln234">    OS_REG_WRITE(ah, AR_IMR_S0,</a>
<a name="ln235">              SM(ahp-&gt;ah_tx_ok_interrupt_mask, AR_IMR_S0_QCU_TXOK));</a>
<a name="ln236">    OS_REG_WRITE(ah, AR_IMR_S1,</a>
<a name="ln237">              SM(ahp-&gt;ah_tx_err_interrupt_mask, AR_IMR_S1_QCU_TXERR)</a>
<a name="ln238">            | SM(ahp-&gt;ah_tx_eol_interrupt_mask, AR_IMR_S1_QCU_TXEOL));</a>
<a name="ln239">    OS_REG_RMW_FIELD(ah,</a>
<a name="ln240">        AR_IMR_S2, AR_IMR_S2_QCU_TXURN, ahp-&gt;ah_tx_urn_interrupt_mask);</a>
<a name="ln241">    ahp-&gt;ah_mask2Reg = OS_REG_READ(ah, AR_IMR_S2);</a>
<a name="ln242">}</a>
<a name="ln243"> </a>
<a name="ln244">/*</a>
<a name="ln245"> * Free a tx DCU/QCU combination.</a>
<a name="ln246"> */</a>
<a name="ln247">HAL_BOOL</a>
<a name="ln248">ar9300_release_tx_queue(struct ath_hal *ah, u_int q)</a>
<a name="ln249">{</a>
<a name="ln250">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln251">    HAL_CAPABILITIES *p_cap = &amp;AH_PRIVATE(ah)-&gt;ah_caps;</a>
<a name="ln252">    HAL_TX_QUEUE_INFO *qi;</a>
<a name="ln253"> </a>
<a name="ln254">    if (q &gt;= p_cap-&gt;halTotalQueues) {</a>
<a name="ln255">        HALDEBUG(ah, HAL_DEBUG_QUEUE, &quot;%s: invalid queue num %u\n&quot;, __func__, q);</a>
<a name="ln256">        return AH_FALSE;</a>
<a name="ln257">    }</a>
<a name="ln258"> </a>
<a name="ln259">    qi = &amp;ahp-&gt;ah_txq[q];</a>
<a name="ln260">    if (qi-&gt;tqi_type == HAL_TX_QUEUE_INACTIVE) {</a>
<a name="ln261">        HALDEBUG(ah, HAL_DEBUG_QUEUE, &quot;%s: inactive queue %u\n&quot;, __func__, q);</a>
<a name="ln262">        return AH_FALSE;</a>
<a name="ln263">    }</a>
<a name="ln264"> </a>
<a name="ln265">    HALDEBUG(ah, HAL_DEBUG_QUEUE, &quot;%s: release queue %u\n&quot;, __func__, q);</a>
<a name="ln266"> </a>
<a name="ln267">    qi-&gt;tqi_type = HAL_TX_QUEUE_INACTIVE;</a>
<a name="ln268">    ahp-&gt;ah_tx_ok_interrupt_mask &amp;= ~(1 &lt;&lt; q);</a>
<a name="ln269">    ahp-&gt;ah_tx_err_interrupt_mask &amp;= ~(1 &lt;&lt; q);</a>
<a name="ln270">    ahp-&gt;ah_tx_eol_interrupt_mask &amp;= ~(1 &lt;&lt; q);</a>
<a name="ln271">    ahp-&gt;ah_tx_urn_interrupt_mask &amp;= ~(1 &lt;&lt; q);</a>
<a name="ln272">    set_tx_q_interrupts(ah, qi);</a>
<a name="ln273"> </a>
<a name="ln274">    return AH_TRUE;</a>
<a name="ln275">}</a>
<a name="ln276"> </a>
<a name="ln277">/*</a>
<a name="ln278"> * Set the retry, aifs, cwmin/max, ready_time regs for specified queue</a>
<a name="ln279"> * Assumes:</a>
<a name="ln280"> *  phw_channel has been set to point to the current channel</a>
<a name="ln281"> */</a>
<a name="ln282">HAL_BOOL</a>
<a name="ln283">ar9300_reset_tx_queue(struct ath_hal *ah, u_int q)</a>
<a name="ln284">{</a>
<a name="ln285">    struct ath_hal_9300     *ahp  = AH9300(ah);</a>
<a name="ln286">//    struct ath_hal_private  *ap   = AH_PRIVATE(ah);</a>
<a name="ln287">    HAL_CAPABILITIES        *p_cap = &amp;AH_PRIVATE(ah)-&gt;ah_caps;</a>
<a name="ln288">    const struct ieee80211_channel *chan = AH_PRIVATE(ah)-&gt;ah_curchan;</a>
<a name="ln289">    HAL_TX_QUEUE_INFO       *qi;</a>
<a name="ln290">    u_int32_t               cw_min, chan_cw_min, value;</a>
<a name="ln291">    uint32_t                qmisc, dmisc;</a>
<a name="ln292"> </a>
<a name="ln293">    if (q &gt;= p_cap-&gt;halTotalQueues) {</a>
<a name="ln294">        HALDEBUG(ah, HAL_DEBUG_QUEUE, &quot;%s: invalid queue num %u\n&quot;, __func__, q);</a>
<a name="ln295">        return AH_FALSE;</a>
<a name="ln296">    }</a>
<a name="ln297"> </a>
<a name="ln298">    qi = &amp;ahp-&gt;ah_txq[q];</a>
<a name="ln299">    if (qi-&gt;tqi_type == HAL_TX_QUEUE_INACTIVE) {</a>
<a name="ln300">        HALDEBUG(ah, HAL_DEBUG_QUEUE, &quot;%s: inactive queue %u\n&quot;, __func__, q);</a>
<a name="ln301">        return AH_TRUE;         /* XXX??? */</a>
<a name="ln302">    }</a>
<a name="ln303"> </a>
<a name="ln304">    HALDEBUG(ah, HAL_DEBUG_QUEUE, &quot;%s: reset queue %u\n&quot;, __func__, q);</a>
<a name="ln305"> </a>
<a name="ln306">    if (qi-&gt;tqi_cwmin == HAL_TXQ_USEDEFAULT) {</a>
<a name="ln307">        /*</a>
<a name="ln308">         * Select cwmin according to channel type.</a>
<a name="ln309">         * NB: chan can be NULL during attach</a>
<a name="ln310">         */</a>
<a name="ln311">        if (chan &amp;&amp; IEEE80211_IS_CHAN_B(chan)) {</a>
<a name="ln312">            chan_cw_min = INIT_CWMIN_11B;</a>
<a name="ln313">        } else {</a>
<a name="ln314">            chan_cw_min = INIT_CWMIN;</a>
<a name="ln315">        }</a>
<a name="ln316">        /* make sure that the CWmin is of the form (2^n - 1) */</a>
<a name="ln317">        for (cw_min = 1; cw_min &lt; chan_cw_min; cw_min = (cw_min &lt;&lt; 1) | 1) {}</a>
<a name="ln318">    } else {</a>
<a name="ln319">        cw_min = qi-&gt;tqi_cwmin;</a>
<a name="ln320">    }</a>
<a name="ln321"> </a>
<a name="ln322">    /* set cw_min/Max and AIFS values */</a>
<a name="ln323">    if (q &gt; 3 || (!AH9300(ah)-&gt;ah_fccaifs))</a>
<a name="ln324">       /* values should not be overwritten if domain is FCC and manual rate </a>
<a name="ln325">         less than 24Mb is set, this check  is making sure this */</a>
<a name="ln326">    {</a>
<a name="ln327">        OS_REG_WRITE(ah, AR_DLCL_IFS(q), SM(cw_min, AR_D_LCL_IFS_CWMIN)</a>
<a name="ln328">                | SM(qi-&gt;tqi_cwmax, AR_D_LCL_IFS_CWMAX)</a>
<a name="ln329">                | SM(qi-&gt;tqi_aifs, AR_D_LCL_IFS_AIFS));</a>
<a name="ln330">    }</a>
<a name="ln331"> </a>
<a name="ln332">    /* Set retry limit values */</a>
<a name="ln333">    OS_REG_WRITE(ah, AR_DRETRY_LIMIT(q),</a>
<a name="ln334">        SM(INIT_SSH_RETRY, AR_D_RETRY_LIMIT_STA_SH) |</a>
<a name="ln335">        SM(INIT_SLG_RETRY, AR_D_RETRY_LIMIT_STA_LG) |</a>
<a name="ln336">        SM(qi-&gt;tqi_shretry, AR_D_RETRY_LIMIT_FR_SH));</a>
<a name="ln337"> </a>
<a name="ln338">    /* enable early termination on the QCU */</a>
<a name="ln339">    qmisc = AR_Q_MISC_DCU_EARLY_TERM_REQ;</a>
<a name="ln340"> </a>
<a name="ln341">    /* enable DCU to wait for next fragment from QCU  */</a>
<a name="ln342">    if (AR_SREV_WASP(ah) &amp;&amp; (AH_PRIVATE((ah))-&gt;ah_macRev &lt;= AR_SREV_REVISION_WASP_12)) {</a>
<a name="ln343">        /* WAR for EV#85395: Wasp Rx overrun issue - reduces Tx queue backoff </a>
<a name="ln344">         * threshold to 1 to avoid Rx overruns - Fixed in Wasp 1.3 */</a>
<a name="ln345">        dmisc = AR_D_MISC_CW_BKOFF_EN | AR_D_MISC_FRAG_WAIT_EN | 0x1;</a>
<a name="ln346">    } else {</a>
<a name="ln347">        dmisc = AR_D_MISC_CW_BKOFF_EN | AR_D_MISC_FRAG_WAIT_EN | 0x2;</a>
<a name="ln348">    }</a>
<a name="ln349"> </a>
<a name="ln350">    /* multiqueue support */</a>
<a name="ln351">    if (qi-&gt;tqi_cbrPeriod) {</a>
<a name="ln352">        OS_REG_WRITE(ah,</a>
<a name="ln353">            AR_QCBRCFG(q),</a>
<a name="ln354">            SM(qi-&gt;tqi_cbrPeriod, AR_Q_CBRCFG_INTERVAL) |</a>
<a name="ln355">                SM(qi-&gt;tqi_cbrOverflowLimit,</a>
<a name="ln356">            AR_Q_CBRCFG_OVF_THRESH));</a>
<a name="ln357">        qmisc |= AR_Q_MISC_FSP_CBR |</a>
<a name="ln358">            (qi-&gt;tqi_cbrOverflowLimit ?</a>
<a name="ln359">                AR_Q_MISC_CBR_EXP_CNTR_LIMIT_EN : 0);</a>
<a name="ln360">    }</a>
<a name="ln361"> </a>
<a name="ln362">    if (qi-&gt;tqi_readyTime &amp;&amp; (qi-&gt;tqi_type != HAL_TX_QUEUE_CAB)) {</a>
<a name="ln363">        OS_REG_WRITE(ah, AR_QRDYTIMECFG(q),</a>
<a name="ln364">            SM(qi-&gt;tqi_readyTime, AR_Q_RDYTIMECFG_DURATION) |</a>
<a name="ln365">            AR_Q_RDYTIMECFG_EN);</a>
<a name="ln366">    }</a>
<a name="ln367"> </a>
<a name="ln368">    OS_REG_WRITE(ah, AR_DCHNTIME(q), SM(qi-&gt;tqi_burstTime, AR_D_CHNTIME_DUR) |</a>
<a name="ln369">                (qi-&gt;tqi_burstTime ? AR_D_CHNTIME_EN : 0));</a>
<a name="ln370"> </a>
<a name="ln371">    if (qi-&gt;tqi_readyTime &amp;&amp;</a>
<a name="ln372">      (qi-&gt;tqi_qflags &amp; HAL_TXQ_RDYTIME_EXP_POLICY_ENABLE))</a>
<a name="ln373">        qmisc |= AR_Q_MISC_RDYTIME_EXP_POLICY;</a>
<a name="ln374">    if (qi-&gt;tqi_qflags &amp; HAL_TXQ_DBA_GATED)</a>
<a name="ln375">        qmisc = (qmisc &amp;~ AR_Q_MISC_FSP) | AR_Q_MISC_FSP_DBA_GATED;</a>
<a name="ln376">    if (MS(qmisc, AR_Q_MISC_FSP) != AR_Q_MISC_FSP_ASAP) {</a>
<a name="ln377">        /*</a>
<a name="ln378">        * These are meangingful only when not scheduled asap.</a>
<a name="ln379">        */</a>
<a name="ln380">        if (qi-&gt;tqi_qflags &amp; HAL_TXQ_CBR_DIS_BEMPTY)</a>
<a name="ln381">            qmisc |= AR_Q_MISC_CBR_INCR_DIS0;</a>
<a name="ln382">        else</a>
<a name="ln383">            qmisc &amp;= ~AR_Q_MISC_CBR_INCR_DIS0;</a>
<a name="ln384">        if (qi-&gt;tqi_qflags &amp; HAL_TXQ_CBR_DIS_QEMPTY)</a>
<a name="ln385">            qmisc |= AR_Q_MISC_CBR_INCR_DIS1;</a>
<a name="ln386">        else</a>
<a name="ln387">            qmisc &amp;= ~AR_Q_MISC_CBR_INCR_DIS1;</a>
<a name="ln388">    }</a>
<a name="ln389"> </a>
<a name="ln390">    if (qi-&gt;tqi_qflags &amp; HAL_TXQ_BACKOFF_DISABLE)</a>
<a name="ln391">        dmisc |= AR_D_MISC_POST_FR_BKOFF_DIS;</a>
<a name="ln392">    if (qi-&gt;tqi_qflags &amp; HAL_TXQ_FRAG_BURST_BACKOFF_ENABLE)</a>
<a name="ln393">        dmisc |= AR_D_MISC_FRAG_BKOFF_EN;</a>
<a name="ln394">    if (qi-&gt;tqi_qflags &amp; HAL_TXQ_ARB_LOCKOUT_GLOBAL)</a>
<a name="ln395">        dmisc |= SM(AR_D_MISC_ARB_LOCKOUT_CNTRL_GLOBAL,</a>
<a name="ln396">                    AR_D_MISC_ARB_LOCKOUT_CNTRL);</a>
<a name="ln397">    else if (qi-&gt;tqi_qflags &amp; HAL_TXQ_ARB_LOCKOUT_INTRA)</a>
<a name="ln398">        dmisc |= SM(AR_D_MISC_ARB_LOCKOUT_CNTRL_INTRA_FR,</a>
<a name="ln399">                    AR_D_MISC_ARB_LOCKOUT_CNTRL);</a>
<a name="ln400">    if (qi-&gt;tqi_qflags &amp; HAL_TXQ_IGNORE_VIRTCOL)</a>
<a name="ln401">        dmisc |= SM(AR_D_MISC_VIR_COL_HANDLING_IGNORE,</a>
<a name="ln402">                    AR_D_MISC_VIR_COL_HANDLING);</a>
<a name="ln403">    if (qi-&gt;tqi_qflags &amp; HAL_TXQ_SEQNUM_INC_DIS)</a>
<a name="ln404">        dmisc |= AR_D_MISC_SEQ_NUM_INCR_DIS;</a>
<a name="ln405"> </a>
<a name="ln406">    switch (qi-&gt;tqi_type) {</a>
<a name="ln407">    case HAL_TX_QUEUE_BEACON:               /* beacon frames */</a>
<a name="ln408">        qmisc |= AR_Q_MISC_FSP_DBA_GATED</a>
<a name="ln409">                    | AR_Q_MISC_BEACON_USE</a>
<a name="ln410">                    | AR_Q_MISC_CBR_INCR_DIS1;</a>
<a name="ln411"> </a>
<a name="ln412">        dmisc |= (AR_D_MISC_ARB_LOCKOUT_CNTRL_GLOBAL &lt;&lt;</a>
<a name="ln413">                    AR_D_MISC_ARB_LOCKOUT_CNTRL_S)</a>
<a name="ln414">                    | AR_D_MISC_BEACON_USE</a>
<a name="ln415">                    | AR_D_MISC_POST_FR_BKOFF_DIS;</a>
<a name="ln416">        /* XXX cwmin and cwmax should be 0 for beacon queue */</a>
<a name="ln417">        if (AH_PRIVATE(ah)-&gt;ah_opmode != HAL_M_IBSS) {</a>
<a name="ln418">            OS_REG_WRITE(ah, AR_DLCL_IFS(q), SM(0, AR_D_LCL_IFS_CWMIN)</a>
<a name="ln419">                        | SM(0, AR_D_LCL_IFS_CWMAX)</a>
<a name="ln420">                        | SM(qi-&gt;tqi_aifs, AR_D_LCL_IFS_AIFS));</a>
<a name="ln421">        }</a>
<a name="ln422">        break;</a>
<a name="ln423">    case HAL_TX_QUEUE_CAB:                  /* CAB  frames */</a>
<a name="ln424">        /*</a>
<a name="ln425">         * No longer Enable AR_Q_MISC_RDYTIME_EXP_POLICY,</a>
<a name="ln426">         * bug #6079.  There is an issue with the CAB Queue</a>
<a name="ln427">         * not properly refreshing the Tx descriptor if</a>
<a name="ln428">         * the TXE clear setting is used.</a>
<a name="ln429">         */</a>
<a name="ln430">        qmisc |= AR_Q_MISC_FSP_DBA_GATED</a>
<a name="ln431">                        | AR_Q_MISC_CBR_INCR_DIS1</a>
<a name="ln432">                        | AR_Q_MISC_CBR_INCR_DIS0;</a>
<a name="ln433"> </a>
<a name="ln434">        if (qi-&gt;tqi_readyTime) {</a>
<a name="ln435">            OS_REG_WRITE(ah, AR_QRDYTIMECFG(q),</a>
<a name="ln436">              SM(qi-&gt;tqi_readyTime, AR_Q_RDYTIMECFG_DURATION) |</a>
<a name="ln437">              AR_Q_RDYTIMECFG_EN);</a>
<a name="ln438">        } else {</a>
<a name="ln439"> </a>
<a name="ln440">            value = (ahp-&gt;ah_beaconInterval * 50 / 100)</a>
<a name="ln441">              - ah-&gt;ah_config.ah_additional_swba_backoff</a>
<a name="ln442">              - ah-&gt;ah_config.ah_sw_beacon_response_time</a>
<a name="ln443">              + ah-&gt;ah_config.ah_dma_beacon_response_time;</a>
<a name="ln444">            /*</a>
<a name="ln445">             * XXX Ensure it isn't too low - nothing lower</a>
<a name="ln446">             * XXX than 10 TU</a>
<a name="ln447">             */</a>
<a name="ln448">            if (value &lt; 10)</a>
<a name="ln449">                value = 10;</a>
<a name="ln450">            if (value &lt; 0)</a>
<a name="ln451">                value = 10;</a>
<a name="ln452">            HALDEBUG(ah, HAL_DEBUG_TXQUEUE,</a>
<a name="ln453">              &quot;%s: defaulting to rdytime = %d uS\n&quot;,</a>
<a name="ln454">              __func__, value);</a>
<a name="ln455">            OS_REG_WRITE(ah, AR_QRDYTIMECFG(q),</a>
<a name="ln456">              SM(TU_TO_USEC(value), AR_Q_RDYTIMECFG_DURATION) |</a>
<a name="ln457">              AR_Q_RDYTIMECFG_EN);</a>
<a name="ln458">        }</a>
<a name="ln459">        dmisc |= SM(AR_D_MISC_ARB_LOCKOUT_CNTRL_GLOBAL,</a>
<a name="ln460">                    AR_D_MISC_ARB_LOCKOUT_CNTRL);</a>
<a name="ln461">        break;</a>
<a name="ln462">    case HAL_TX_QUEUE_PSPOLL:</a>
<a name="ln463">        /*</a>
<a name="ln464">         * We may configure ps_poll QCU to be TIM-gated in the</a>
<a name="ln465">         * future; TIM_GATED bit is not enabled currently because</a>
<a name="ln466">         * of a hardware problem in Oahu that overshoots the TIM</a>
<a name="ln467">         * bitmap in beacon and may find matching associd bit in</a>
<a name="ln468">         * non-TIM elements and send PS-poll PS poll processing</a>
<a name="ln469">         * will be done in software</a>
<a name="ln470">         */</a>
<a name="ln471">        qmisc |= AR_Q_MISC_CBR_INCR_DIS1;</a>
<a name="ln472">        break;</a>
<a name="ln473">    case HAL_TX_QUEUE_UAPSD:</a>
<a name="ln474">        dmisc |= AR_D_MISC_POST_FR_BKOFF_DIS;</a>
<a name="ln475">        break;</a>
<a name="ln476">    default:                        /* NB: silence compiler */</a>
<a name="ln477">        break;</a>
<a name="ln478">    }</a>
<a name="ln479"> </a>
<a name="ln480">#ifndef AH_DISABLE_WME</a>
<a name="ln481">    /*</a>
<a name="ln482">     * Yes, this is a hack and not the right way to do it, but</a>
<a name="ln483">     * it does get the lockout bits and backoff set for the</a>
<a name="ln484">     * high-pri WME queues for testing.  We need to either extend</a>
<a name="ln485">     * the meaning of queue_info-&gt;mode, or create something like</a>
<a name="ln486">     * queue_info-&gt;dcumode.</a>
<a name="ln487">     */</a>
<a name="ln488">    if (qi-&gt;tqi_intFlags &amp; HAL_TXQ_USE_LOCKOUT_BKOFF_DIS) {</a>
<a name="ln489">        dmisc |= SM(AR_D_MISC_ARB_LOCKOUT_CNTRL_GLOBAL,</a>
<a name="ln490">                    AR_D_MISC_ARB_LOCKOUT_CNTRL) |</a>
<a name="ln491">                AR_D_MISC_POST_FR_BKOFF_DIS;</a>
<a name="ln492">    }</a>
<a name="ln493">#endif</a>
<a name="ln494"> </a>
<a name="ln495">    OS_REG_WRITE(ah, AR_Q_DESC_CRCCHK, AR_Q_DESC_CRCCHK_EN);</a>
<a name="ln496">    OS_REG_WRITE(ah, AR_QMISC(q), qmisc);</a>
<a name="ln497">    OS_REG_WRITE(ah, AR_DMISC(q), dmisc);</a>
<a name="ln498"> </a>
<a name="ln499">    /*</a>
<a name="ln500">     * Always update the secondary interrupt mask registers - this</a>
<a name="ln501">     * could be a new queue getting enabled in a running system or</a>
<a name="ln502">     * hw getting re-initialized during a reset!</a>
<a name="ln503">     *</a>
<a name="ln504">     * Since we don't differentiate between tx interrupts corresponding</a>
<a name="ln505">     * to individual queues - secondary tx mask regs are always unmasked;</a>
<a name="ln506">     * tx interrupts are enabled/disabled for all queues collectively</a>
<a name="ln507">     * using the primary mask reg</a>
<a name="ln508">     */</a>
<a name="ln509">    if (qi-&gt;tqi_qflags &amp; HAL_TXQ_TXOKINT_ENABLE) {</a>
<a name="ln510">        ahp-&gt;ah_tx_ok_interrupt_mask |=  (1 &lt;&lt; q);</a>
<a name="ln511">    } else {</a>
<a name="ln512">        ahp-&gt;ah_tx_ok_interrupt_mask &amp;= ~(1 &lt;&lt; q);</a>
<a name="ln513">    }</a>
<a name="ln514">    if (qi-&gt;tqi_qflags &amp; HAL_TXQ_TXERRINT_ENABLE) {</a>
<a name="ln515">        ahp-&gt;ah_tx_err_interrupt_mask |=  (1 &lt;&lt; q);</a>
<a name="ln516">    } else {</a>
<a name="ln517">        ahp-&gt;ah_tx_err_interrupt_mask &amp;= ~(1 &lt;&lt; q);</a>
<a name="ln518">    }</a>
<a name="ln519">    if (qi-&gt;tqi_qflags &amp; HAL_TXQ_TXEOLINT_ENABLE) {</a>
<a name="ln520">        ahp-&gt;ah_tx_eol_interrupt_mask |=  (1 &lt;&lt; q);</a>
<a name="ln521">    } else {</a>
<a name="ln522">        ahp-&gt;ah_tx_eol_interrupt_mask &amp;= ~(1 &lt;&lt; q);</a>
<a name="ln523">    }</a>
<a name="ln524">    if (qi-&gt;tqi_qflags &amp; HAL_TXQ_TXURNINT_ENABLE) {</a>
<a name="ln525">        ahp-&gt;ah_tx_urn_interrupt_mask |=  (1 &lt;&lt; q);</a>
<a name="ln526">    } else {</a>
<a name="ln527">        ahp-&gt;ah_tx_urn_interrupt_mask &amp;= ~(1 &lt;&lt; q);</a>
<a name="ln528">    }</a>
<a name="ln529">    set_tx_q_interrupts(ah, qi);</a>
<a name="ln530"> </a>
<a name="ln531">    return AH_TRUE;</a>
<a name="ln532">}</a>
<a name="ln533"> </a>
<a name="ln534">/*</a>
<a name="ln535"> * Get the TXDP for the specified queue</a>
<a name="ln536"> */</a>
<a name="ln537">u_int32_t</a>
<a name="ln538">ar9300_get_tx_dp(struct ath_hal *ah, u_int q)</a>
<a name="ln539">{</a>
<a name="ln540">    HALASSERT(q &lt; AH_PRIVATE(ah)-&gt;ah_caps.halTotalQueues);</a>
<a name="ln541">    return OS_REG_READ(ah, AR_QTXDP(q));</a>
<a name="ln542">}</a>
<a name="ln543"> </a>
<a name="ln544">/*</a>
<a name="ln545"> * Set the tx_dp for the specified queue</a>
<a name="ln546"> */</a>
<a name="ln547">HAL_BOOL</a>
<a name="ln548">ar9300_set_tx_dp(struct ath_hal *ah, u_int q, u_int32_t txdp)</a>
<a name="ln549">{</a>
<a name="ln550">    HALASSERT(q &lt; AH_PRIVATE(ah)-&gt;ah_caps.halTotalQueues);</a>
<a name="ln551">    HALASSERT(AH9300(ah)-&gt;ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE);</a>
<a name="ln552">    HALASSERT(txdp != 0);</a>
<a name="ln553"> </a>
<a name="ln554">    OS_REG_WRITE(ah, AR_QTXDP(q), txdp);</a>
<a name="ln555"> </a>
<a name="ln556">    return AH_TRUE;</a>
<a name="ln557">}</a>
<a name="ln558"> </a>
<a name="ln559">/*</a>
<a name="ln560"> * Transmit Enable is read-only now</a>
<a name="ln561"> */</a>
<a name="ln562">HAL_BOOL</a>
<a name="ln563">ar9300_start_tx_dma(struct ath_hal *ah, u_int q)</a>
<a name="ln564">{</a>
<a name="ln565">    return AH_TRUE;</a>
<a name="ln566">}</a>
<a name="ln567"> </a>
<a name="ln568">/*</a>
<a name="ln569"> * Return the number of pending frames or 0 if the specified</a>
<a name="ln570"> * queue is stopped.</a>
<a name="ln571"> */</a>
<a name="ln572">u_int32_t</a>
<a name="ln573">ar9300_num_tx_pending(struct ath_hal *ah, u_int q)</a>
<a name="ln574">{</a>
<a name="ln575">    u_int32_t npend;</a>
<a name="ln576"> </a>
<a name="ln577">    HALASSERT(q &lt; AH_PRIVATE(ah)-&gt;ah_caps.halTotalQueues);</a>
<a name="ln578"> </a>
<a name="ln579">    npend = OS_REG_READ(ah, AR_QSTS(q)) &amp; AR_Q_STS_PEND_FR_CNT;</a>
<a name="ln580">    if (npend == 0) {</a>
<a name="ln581">        /*</a>
<a name="ln582">         * Pending frame count (PFC) can momentarily go to zero</a>
<a name="ln583">         * while TXE remains asserted.  In other words a PFC of</a>
<a name="ln584">         * zero is not sufficient to say that the queue has stopped.</a>
<a name="ln585">         */</a>
<a name="ln586">        if (OS_REG_READ(ah, AR_Q_TXE) &amp; (1 &lt;&lt; q)) {</a>
<a name="ln587">            npend = 1;              /* arbitrarily return 1 */</a>
<a name="ln588">        }</a>
<a name="ln589">    }</a>
<a name="ln590">#ifdef DEBUG</a>
<a name="ln591">    if (npend &amp;&amp; (AH9300(ah)-&gt;ah_txq[q].tqi_type == HAL_TX_QUEUE_CAB)) {</a>
<a name="ln592">        if (OS_REG_READ(ah, AR_Q_RDYTIMESHDN) &amp; (1 &lt;&lt; q)) {</a>
<a name="ln593">            HALDEBUG(ah, HAL_DEBUG_QUEUE, &quot;RTSD on CAB queue\n&quot;);</a>
<a name="ln594">            /* Clear the ready_time shutdown status bits */</a>
<a name="ln595">            OS_REG_WRITE(ah, AR_Q_RDYTIMESHDN, 1 &lt;&lt; q);</a>
<a name="ln596">        }</a>
<a name="ln597">    }</a>
<a name="ln598">#endif</a>
<a name="ln599">    HALASSERT((npend == 0) ||</a>
<a name="ln600">        (AH9300(ah)-&gt;ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE));</a>
<a name="ln601"> </a>
<a name="ln602">    return npend;</a>
<a name="ln603">}</a>
<a name="ln604"> </a>
<a name="ln605">/*</a>
<a name="ln606"> * Stop transmit on the specified queue</a>
<a name="ln607"> */</a>
<a name="ln608">HAL_BOOL</a>
<a name="ln609">ar9300_stop_tx_dma(struct ath_hal *ah, u_int q, u_int timeout)</a>
<a name="ln610">{</a>
<a name="ln611">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln612"> </a>
<a name="ln613">    /*</a>
<a name="ln614">     * If we call abort txdma instead, no need to stop RX.</a>
<a name="ln615">     * Otherwise, the RX logic might not be restarted properly.</a>
<a name="ln616">     */</a>
<a name="ln617">    ahp-&gt;ah_abort_txdma_norx = AH_FALSE;</a>
<a name="ln618"> </a>
<a name="ln619">    /*</a>
<a name="ln620">     * Directly call abort.  It is better, hardware-wise, to stop all</a>
<a name="ln621">     * queues at once than individual ones.</a>
<a name="ln622">     */</a>
<a name="ln623">    return ar9300_abort_tx_dma(ah);</a>
<a name="ln624"> </a>
<a name="ln625">#if 0</a>
<a name="ln626">#define AH_TX_STOP_DMA_TIMEOUT 4000    /* usec */</a>
<a name="ln627">#define AH_TIME_QUANTUM        100     /* usec */</a>
<a name="ln628">    u_int wait;</a>
<a name="ln629"> </a>
<a name="ln630">    HALASSERT(q &lt; AH_PRIVATE(ah)-&gt;ah_caps.hal_total_queues);</a>
<a name="ln631"> </a>
<a name="ln632">    HALASSERT(AH9300(ah)-&gt;ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE);</a>
<a name="ln633"> </a>
<a name="ln634">    if (timeout == 0) {</a>
<a name="ln635">        timeout = AH_TX_STOP_DMA_TIMEOUT;</a>
<a name="ln636">    }</a>
<a name="ln637"> </a>
<a name="ln638">    OS_REG_WRITE(ah, AR_Q_TXD, 1 &lt;&lt; q);</a>
<a name="ln639"> </a>
<a name="ln640">    for (wait = timeout / AH_TIME_QUANTUM; wait != 0; wait--) {</a>
<a name="ln641">        if (ar9300_num_tx_pending(ah, q) == 0) {</a>
<a name="ln642">            break;</a>
<a name="ln643">        }</a>
<a name="ln644">        OS_DELAY(AH_TIME_QUANTUM);        /* XXX get actual value */</a>
<a name="ln645">    }</a>
<a name="ln646"> </a>
<a name="ln647">#ifdef AH_DEBUG</a>
<a name="ln648">    if (wait == 0) {</a>
<a name="ln649">        HALDEBUG(ah, HAL_DEBUG_QUEUE,</a>
<a name="ln650">            &quot;%s: queue %u DMA did not stop in 100 msec\n&quot;, __func__, q);</a>
<a name="ln651">        HALDEBUG(ah, HAL_DEBUG_QUEUE,</a>
<a name="ln652">            &quot;%s: QSTS 0x%x Q_TXE 0x%x Q_TXD 0x%x Q_CBR 0x%x\n&quot;,</a>
<a name="ln653">            __func__,</a>
<a name="ln654">            OS_REG_READ(ah, AR_QSTS(q)),</a>
<a name="ln655">            OS_REG_READ(ah, AR_Q_TXE),</a>
<a name="ln656">            OS_REG_READ(ah, AR_Q_TXD),</a>
<a name="ln657">            OS_REG_READ(ah, AR_QCBRCFG(q)));</a>
<a name="ln658">        HALDEBUG(ah, HAL_DEBUG_QUEUE,</a>
<a name="ln659">            &quot;%s: Q_MISC 0x%x Q_RDYTIMECFG 0x%x Q_RDYTIMESHDN 0x%x\n&quot;,</a>
<a name="ln660">            __func__,</a>
<a name="ln661">            OS_REG_READ(ah, AR_QMISC(q)),</a>
<a name="ln662">            OS_REG_READ(ah, AR_QRDYTIMECFG(q)),</a>
<a name="ln663">            OS_REG_READ(ah, AR_Q_RDYTIMESHDN));</a>
<a name="ln664">    }</a>
<a name="ln665">#endif /* AH_DEBUG */</a>
<a name="ln666"> </a>
<a name="ln667">    /* 2413+ and up can kill packets at the PCU level */</a>
<a name="ln668">    if (ar9300_num_tx_pending(ah, q)) {</a>
<a name="ln669">        u_int32_t tsf_low, j;</a>
<a name="ln670"> </a>
<a name="ln671">        HALDEBUG(ah, HAL_DEBUG_QUEUE, &quot;%s: Num of pending TX Frames %d on Q %d\n&quot;,</a>
<a name="ln672">                 __func__, ar9300_num_tx_pending(ah, q), q);</a>
<a name="ln673"> </a>
<a name="ln674">        /* Kill last PCU Tx Frame */</a>
<a name="ln675">        /* TODO - save off and restore current values of Q1/Q2? */</a>
<a name="ln676">        for (j = 0; j &lt; 2; j++) {</a>
<a name="ln677">            tsf_low = OS_REG_READ(ah, AR_TSF_L32);</a>
<a name="ln678">            OS_REG_WRITE(ah, AR_QUIET2, SM(10, AR_QUIET2_QUIET_DUR));</a>
<a name="ln679">            OS_REG_WRITE(ah, AR_QUIET_PERIOD, 100);</a>
<a name="ln680">            OS_REG_WRITE(ah, AR_NEXT_QUIET_TIMER, tsf_low &gt;&gt; 10);</a>
<a name="ln681">            OS_REG_SET_BIT(ah, AR_TIMER_MODE, AR_QUIET_TIMER_EN);</a>
<a name="ln682"> </a>
<a name="ln683">            if ((OS_REG_READ(ah, AR_TSF_L32) &gt;&gt; 10) == (tsf_low &gt;&gt; 10)) {</a>
<a name="ln684">                break;</a>
<a name="ln685">            }</a>
<a name="ln686"> </a>
<a name="ln687">            HALDEBUG(ah, HAL_DEBUG_QUEUE,</a>
<a name="ln688">                &quot;%s: TSF have moved while trying to set &quot;</a>
<a name="ln689">                &quot;quiet time TSF: 0x%08x\n&quot;,</a>
<a name="ln690">                __func__, tsf_low);</a>
<a name="ln691">            /* TSF shouldn't count twice or reg access is taking forever */</a>
<a name="ln692">            HALASSERT(j &lt; 1);</a>
<a name="ln693">        }</a>
<a name="ln694"> </a>
<a name="ln695">        OS_REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH);</a>
<a name="ln696"> </a>
<a name="ln697">        /* Allow the quiet mechanism to do its work */</a>
<a name="ln698">        OS_DELAY(200);</a>
<a name="ln699">        OS_REG_CLR_BIT(ah, AR_TIMER_MODE, AR_QUIET_TIMER_EN);</a>
<a name="ln700"> </a>
<a name="ln701">        /* Verify all transmit is dead */</a>
<a name="ln702">        wait = timeout / AH_TIME_QUANTUM;</a>
<a name="ln703">        while (ar9300_num_tx_pending(ah, q)) {</a>
<a name="ln704">            if ((--wait) == 0) {</a>
<a name="ln705">                HALDEBUG(ah, HAL_DEBUG_TX,</a>
<a name="ln706">                    &quot;%s: Failed to stop Tx DMA in %d msec &quot;</a>
<a name="ln707">                    &quot;after killing last frame\n&quot;,</a>
<a name="ln708">                    __func__, timeout / 1000);</a>
<a name="ln709">                break;</a>
<a name="ln710">            }</a>
<a name="ln711">            OS_DELAY(AH_TIME_QUANTUM);</a>
<a name="ln712">        }</a>
<a name="ln713"> </a>
<a name="ln714">        OS_REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH);</a>
<a name="ln715">    }</a>
<a name="ln716"> </a>
<a name="ln717">    OS_REG_WRITE(ah, AR_Q_TXD, 0);</a>
<a name="ln718">    return (wait != 0);</a>
<a name="ln719"> </a>
<a name="ln720">#undef AH_TX_STOP_DMA_TIMEOUT</a>
<a name="ln721">#undef AH_TIME_QUANTUM</a>
<a name="ln722">#endif</a>
<a name="ln723">}</a>
<a name="ln724"> </a>
<a name="ln725">/*</a>
<a name="ln726"> * Really Stop transmit on the specified queue</a>
<a name="ln727"> */</a>
<a name="ln728">HAL_BOOL</a>
<a name="ln729">ar9300_stop_tx_dma_indv_que(struct ath_hal *ah, u_int q, u_int timeout)</a>
<a name="ln730">{</a>
<a name="ln731">#define AH_TX_STOP_DMA_TIMEOUT 4000    /* usec */</a>
<a name="ln732">#define AH_TIME_QUANTUM        100     /* usec */</a>
<a name="ln733">    u_int wait;</a>
<a name="ln734"> </a>
<a name="ln735">    HALASSERT(q &lt; AH_PRIVATE(ah)-&gt;ah_caps.hal_total_queues);</a>
<a name="ln736"> </a>
<a name="ln737">    HALASSERT(AH9300(ah)-&gt;ah_txq[q].tqi_type != HAL_TX_QUEUE_INACTIVE);</a>
<a name="ln738"> </a>
<a name="ln739">    if (timeout == 0) {</a>
<a name="ln740">        timeout = AH_TX_STOP_DMA_TIMEOUT;</a>
<a name="ln741">    }</a>
<a name="ln742"> </a>
<a name="ln743">    OS_REG_WRITE(ah, AR_Q_TXD, 1 &lt;&lt; q);</a>
<a name="ln744"> </a>
<a name="ln745">    for (wait = timeout / AH_TIME_QUANTUM; wait != 0; wait--) {</a>
<a name="ln746">        if (ar9300_num_tx_pending(ah, q) == 0) {</a>
<a name="ln747">            break;</a>
<a name="ln748">        }</a>
<a name="ln749">        OS_DELAY(AH_TIME_QUANTUM);        /* XXX get actual value */</a>
<a name="ln750">    }</a>
<a name="ln751"> </a>
<a name="ln752">#ifdef AH_DEBUG</a>
<a name="ln753">    if (wait == 0) {</a>
<a name="ln754">        HALDEBUG(ah, HAL_DEBUG_QUEUE,</a>
<a name="ln755">            &quot;%s: queue %u DMA did not stop in 100 msec\n&quot;, __func__, q);</a>
<a name="ln756">        HALDEBUG(ah, HAL_DEBUG_QUEUE,</a>
<a name="ln757">            &quot;%s: QSTS 0x%x Q_TXE 0x%x Q_TXD 0x%x Q_CBR 0x%x\n&quot;,</a>
<a name="ln758">            __func__,</a>
<a name="ln759">            OS_REG_READ(ah, AR_QSTS(q)),</a>
<a name="ln760">            OS_REG_READ(ah, AR_Q_TXE),</a>
<a name="ln761">            OS_REG_READ(ah, AR_Q_TXD),</a>
<a name="ln762">            OS_REG_READ(ah, AR_QCBRCFG(q)));</a>
<a name="ln763">        HALDEBUG(ah, HAL_DEBUG_QUEUE,</a>
<a name="ln764">            &quot;%s: Q_MISC 0x%x Q_RDYTIMECFG 0x%x Q_RDYTIMESHDN 0x%x\n&quot;,</a>
<a name="ln765">            __func__,</a>
<a name="ln766">            OS_REG_READ(ah, AR_QMISC(q)),</a>
<a name="ln767">            OS_REG_READ(ah, AR_QRDYTIMECFG(q)),</a>
<a name="ln768">            OS_REG_READ(ah, AR_Q_RDYTIMESHDN));</a>
<a name="ln769">    }</a>
<a name="ln770">#endif /* AH_DEBUG */</a>
<a name="ln771"> </a>
<a name="ln772">    /* 2413+ and up can kill packets at the PCU level */</a>
<a name="ln773">    if (ar9300_num_tx_pending(ah, q)) {</a>
<a name="ln774">        u_int32_t tsf_low, j;</a>
<a name="ln775"> </a>
<a name="ln776">        HALDEBUG(ah, HAL_DEBUG_QUEUE, &quot;%s: Num of pending TX Frames %d on Q %d\n&quot;,</a>
<a name="ln777">                 __func__, ar9300_num_tx_pending(ah, q), q);</a>
<a name="ln778"> </a>
<a name="ln779">        /* Kill last PCU Tx Frame */</a>
<a name="ln780">        /* TODO - save off and restore current values of Q1/Q2? */</a>
<a name="ln781">        for (j = 0; j &lt; 2; j++) {</a>
<a name="ln782">            tsf_low = OS_REG_READ(ah, AR_TSF_L32);</a>
<a name="ln783">            OS_REG_WRITE(ah, AR_QUIET2, SM(10, AR_QUIET2_QUIET_DUR));</a>
<a name="ln784">            OS_REG_WRITE(ah, AR_QUIET_PERIOD, 100);</a>
<a name="ln785">            OS_REG_WRITE(ah, AR_NEXT_QUIET_TIMER, tsf_low &gt;&gt; 10);</a>
<a name="ln786">            OS_REG_SET_BIT(ah, AR_TIMER_MODE, AR_QUIET_TIMER_EN);</a>
<a name="ln787"> </a>
<a name="ln788">            if ((OS_REG_READ(ah, AR_TSF_L32) &gt;&gt; 10) == (tsf_low &gt;&gt; 10)) {</a>
<a name="ln789">                break;</a>
<a name="ln790">            }</a>
<a name="ln791"> </a>
<a name="ln792">            HALDEBUG(ah, HAL_DEBUG_QUEUE,</a>
<a name="ln793">                &quot;%s: TSF have moved while trying to set &quot;</a>
<a name="ln794">                &quot;quiet time TSF: 0x%08x\n&quot;,</a>
<a name="ln795">                __func__, tsf_low);</a>
<a name="ln796">            /* TSF shouldn't count twice or reg access is taking forever */</a>
<a name="ln797">            HALASSERT(j &lt; 1);</a>
<a name="ln798">        }</a>
<a name="ln799"> </a>
<a name="ln800">        OS_REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH);</a>
<a name="ln801"> </a>
<a name="ln802">        /* Allow the quiet mechanism to do its work */</a>
<a name="ln803">        OS_DELAY(200);</a>
<a name="ln804">        OS_REG_CLR_BIT(ah, AR_TIMER_MODE, AR_QUIET_TIMER_EN);</a>
<a name="ln805"> </a>
<a name="ln806">        /* Verify all transmit is dead */</a>
<a name="ln807">        wait = timeout / AH_TIME_QUANTUM;</a>
<a name="ln808">        while (ar9300_num_tx_pending(ah, q)) {</a>
<a name="ln809">            if ((--wait) == 0) {</a>
<a name="ln810">                HALDEBUG(ah, HAL_DEBUG_TX,</a>
<a name="ln811">                    &quot;%s: Failed to stop Tx DMA in %d msec &quot;</a>
<a name="ln812">                    &quot;after killing last frame\n&quot;,</a>
<a name="ln813">                    __func__, timeout / 1000);</a>
<a name="ln814">                break;</a>
<a name="ln815">            }</a>
<a name="ln816">            OS_DELAY(AH_TIME_QUANTUM);</a>
<a name="ln817">        }</a>
<a name="ln818"> </a>
<a name="ln819">        OS_REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH);</a>
<a name="ln820">    }</a>
<a name="ln821"> </a>
<a name="ln822">    OS_REG_WRITE(ah, AR_Q_TXD, 0);</a>
<a name="ln823">    return (wait != 0);</a>
<a name="ln824"> </a>
<a name="ln825">#undef AH_TX_STOP_DMA_TIMEOUT</a>
<a name="ln826">#undef AH_TIME_QUANTUM</a>
<a name="ln827">}</a>
<a name="ln828"> </a>
<a name="ln829">/*</a>
<a name="ln830"> * Abort transmit on all queues</a>
<a name="ln831"> */</a>
<a name="ln832">#define AR9300_ABORT_LOOPS     1000</a>
<a name="ln833">#define AR9300_ABORT_WAIT      5</a>
<a name="ln834">#define NEXT_TBTT_NOW       10</a>
<a name="ln835">HAL_BOOL</a>
<a name="ln836">ar9300_abort_tx_dma(struct ath_hal *ah)</a>
<a name="ln837">{</a>
<a name="ln838">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln839">    int i, q;</a>
<a name="ln840">    u_int32_t nexttbtt, nextdba, tsf_tbtt, tbtt, dba;</a>
<a name="ln841">    HAL_BOOL stopped;</a>
<a name="ln842">    HAL_BOOL status = AH_TRUE;</a>
<a name="ln843"> </a>
<a name="ln844">    if (ahp-&gt;ah_abort_txdma_norx) {</a>
<a name="ln845">        /*</a>
<a name="ln846">         * First of all, make sure RX has been stopped</a>
<a name="ln847">         */</a>
<a name="ln848">        if (ar9300_get_power_mode(ah) != HAL_PM_FULL_SLEEP) {</a>
<a name="ln849">            /* Need to stop RX DMA before reset otherwise chip might hang */</a>
<a name="ln850">            stopped = ar9300_set_rx_abort(ah, AH_TRUE); /* abort and disable PCU */</a>
<a name="ln851">            ar9300_set_rx_filter(ah, 0);</a>
<a name="ln852">            stopped &amp;= ar9300_stop_dma_receive(ah, 0); /* stop and disable RX DMA */</a>
<a name="ln853">            if (!stopped) {</a>
<a name="ln854">                /*</a>
<a name="ln855">                 * During the transition from full sleep to reset,</a>
<a name="ln856">                 * recv DMA regs are not available to be read</a>
<a name="ln857">                 */</a>
<a name="ln858">                HALDEBUG(ah, HAL_DEBUG_UNMASKABLE,</a>
<a name="ln859">                    &quot;%s[%d]: ar9300_stop_dma_receive failed\n&quot;, __func__, __LINE__);</a>
<a name="ln860">                //We still continue to stop TX dma</a>
<a name="ln861">                //return AH_FALSE;</a>
<a name="ln862">            }</a>
<a name="ln863">        } else {</a>
<a name="ln864">            HALDEBUG(ah, HAL_DEBUG_UNMASKABLE,</a>
<a name="ln865">                &quot;%s[%d]: Chip is already in full sleep\n&quot;, __func__, __LINE__);</a>
<a name="ln866">        }</a>
<a name="ln867">    }</a>
<a name="ln868"> </a>
<a name="ln869">    /*</a>
<a name="ln870">     * set txd on all queues</a>
<a name="ln871">     */</a>
<a name="ln872">    OS_REG_WRITE(ah, AR_Q_TXD, AR_Q_TXD_M);</a>
<a name="ln873"> </a>
<a name="ln874">    /*</a>
<a name="ln875">     * set tx abort bits (also disable rx)</a>
<a name="ln876">     */</a>
<a name="ln877">    OS_REG_SET_BIT(ah, AR_PCU_MISC, AR_PCU_FORCE_QUIET_COLL | AR_PCU_CLEAR_VMF);</a>
<a name="ln878">    /* Add a new receipe from K31 code */</a>
<a name="ln879">    OS_REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH | AR_DIAG_RX_DIS |</a>
<a name="ln880">                                   AR_DIAG_RX_ABORT | AR_DIAG_FORCE_RX_CLEAR);</a>
<a name="ln881">     /* beacon Q flush */</a>
<a name="ln882">    nexttbtt = OS_REG_READ(ah, AR_NEXT_TBTT_TIMER);</a>
<a name="ln883">    nextdba = OS_REG_READ(ah, AR_NEXT_DMA_BEACON_ALERT);</a>
<a name="ln884">    //printk(&quot;%s[%d]:dba: %d, nt: %d \n&quot;, __func__, __LINE__, nextdba, nexttbtt);</a>
<a name="ln885">    tsf_tbtt =  OS_REG_READ(ah, AR_TSF_L32);</a>
<a name="ln886">    tbtt = tsf_tbtt + NEXT_TBTT_NOW;</a>
<a name="ln887">    dba = tsf_tbtt;</a>
<a name="ln888">    OS_REG_WRITE(ah, AR_NEXT_DMA_BEACON_ALERT, dba);</a>
<a name="ln889">    OS_REG_WRITE(ah, AR_NEXT_TBTT_TIMER, tbtt);</a>
<a name="ln890">    OS_REG_SET_BIT(ah, AR_D_GBL_IFS_MISC, AR_D_GBL_IFS_MISC_IGNORE_BACKOFF);</a>
<a name="ln891"> </a>
<a name="ln892">    /*</a>
<a name="ln893">     * Let TXE (all queues) clear before waiting for any pending frames </a>
<a name="ln894">     * This is needed before starting the RF_BUS GRANT sequence other wise causes kernel </a>
<a name="ln895">     * panic </a>
<a name="ln896">     */     </a>
<a name="ln897">    for(i = 0; i &lt; AR9300_ABORT_LOOPS; i++) {</a>
<a name="ln898">        if(OS_REG_READ(ah, AR_Q_TXE) == 0) {</a>
<a name="ln899">            break;</a>
<a name="ln900">        }</a>
<a name="ln901">        OS_DELAY(AR9300_ABORT_WAIT);</a>
<a name="ln902">    }</a>
<a name="ln903">    if (i == AR9300_ABORT_LOOPS) {</a>
<a name="ln904">        HALDEBUG(ah, HAL_DEBUG_TX, &quot;%s[%d] reached max wait on TXE\n&quot;,</a>
<a name="ln905">                 __func__, __LINE__);</a>
<a name="ln906">    }</a>
<a name="ln907"> </a>
<a name="ln908">    /*</a>
<a name="ln909">     * wait on all tx queues</a>
<a name="ln910">     * This need to be checked in the last to gain extra 50 usec. on avg. </a>
<a name="ln911">     * Currently checked first since we dont have a previous channel information currently. </a>
<a name="ln912">     * Which is needed to revert the rf changes. </a>
<a name="ln913">     */</a>
<a name="ln914">    for (q = AR_NUM_QCU - 1; q &gt;= 0; q--) {</a>
<a name="ln915">        for (i = 0; i &lt; AR9300_ABORT_LOOPS; i++) {</a>
<a name="ln916">            if (!(ar9300_num_tx_pending(ah, q))) {</a>
<a name="ln917">                break;</a>
<a name="ln918">            }</a>
<a name="ln919">            OS_DELAY(AR9300_ABORT_WAIT);</a>
<a name="ln920">        }</a>
<a name="ln921">        if (i == AR9300_ABORT_LOOPS) {</a>
<a name="ln922">            status = AH_FALSE;</a>
<a name="ln923">            HALDEBUG(ah, HAL_DEBUG_UNMASKABLE,</a>
<a name="ln924">                    &quot;ABORT LOOP finsihsed for Q: %d, num_pending: %d \n&quot;,</a>
<a name="ln925">                    q, ar9300_num_tx_pending(ah, q));</a>
<a name="ln926">            goto exit;</a>
<a name="ln927">        }</a>
<a name="ln928">    }</a>
<a name="ln929"> </a>
<a name="ln930">    /* Updating the beacon alert register with correct value */</a>
<a name="ln931">    OS_REG_WRITE(ah, AR_NEXT_DMA_BEACON_ALERT, nextdba);</a>
<a name="ln932">    OS_REG_WRITE(ah, AR_NEXT_TBTT_TIMER, nexttbtt);</a>
<a name="ln933"> </a>
<a name="ln934">exit:</a>
<a name="ln935">    /*</a>
<a name="ln936">     * clear tx abort bits</a>
<a name="ln937">     */</a>
<a name="ln938">    OS_REG_CLR_BIT(ah, AR_PCU_MISC, AR_PCU_FORCE_QUIET_COLL | AR_PCU_CLEAR_VMF);</a>
<a name="ln939">    /* Added a new receipe from K31 code */</a>
<a name="ln940">    OS_REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_FORCE_CH_IDLE_HIGH | AR_DIAG_RX_DIS |</a>
<a name="ln941">                                   AR_DIAG_RX_ABORT | AR_DIAG_FORCE_RX_CLEAR);</a>
<a name="ln942">    OS_REG_CLR_BIT(ah, AR_D_GBL_IFS_MISC, AR_D_GBL_IFS_MISC_IGNORE_BACKOFF);</a>
<a name="ln943"> </a>
<a name="ln944">    /*</a>
<a name="ln945">     * clear txd</a>
<a name="ln946">     */</a>
<a name="ln947">    OS_REG_WRITE(ah, AR_Q_TXD, 0);</a>
<a name="ln948"> </a>
<a name="ln949">    ahp-&gt;ah_abort_txdma_norx = AH_TRUE;</a>
<a name="ln950"> </a>
<a name="ln951">    return status;</a>
<a name="ln952">}</a>
<a name="ln953"> </a>
<a name="ln954">/*</a>
<a name="ln955"> * Determine which tx queues need interrupt servicing.</a>
<a name="ln956"> */</a>
<a name="ln957">void</a>
<a name="ln958">ar9300_get_tx_intr_queue(struct ath_hal *ah, u_int32_t *txqs)</a>
<a name="ln959">{</a>
<a name="ln960">    HALDEBUG(AH_NULL, HAL_DEBUG_UNMASKABLE,</a>
<a name="ln961">                 &quot;ar9300_get_tx_intr_queue: Should not be called\n&quot;);</a>
<a name="ln962">#if 0</a>
<a name="ln963">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln964">    *txqs &amp;= ahp-&gt;ah_intr_txqs;</a>
<a name="ln965">    ahp-&gt;ah_intr_txqs &amp;= ~(*txqs);</a>
<a name="ln966">#endif</a>
<a name="ln967">}</a>
<a name="ln968"> </a>
<a name="ln969">void</a>
<a name="ln970">ar9300_reset_tx_status_ring(struct ath_hal *ah)</a>
<a name="ln971">{</a>
<a name="ln972">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln973"> </a>
<a name="ln974">    ahp-&gt;ts_tail = 0;</a>
<a name="ln975"> </a>
<a name="ln976">    /* Zero out the status descriptors */</a>
<a name="ln977">    OS_MEMZERO((void *)ahp-&gt;ts_ring, ahp-&gt;ts_size * sizeof(struct ar9300_txs));</a>
<a name="ln978">    HALDEBUG(ah, HAL_DEBUG_QUEUE,</a>
<a name="ln979">        &quot;%s: TS Start 0x%x End 0x%x Virt %p, Size %d\n&quot;, __func__,</a>
<a name="ln980">        ahp-&gt;ts_paddr_start, ahp-&gt;ts_paddr_end, ahp-&gt;ts_ring, ahp-&gt;ts_size);</a>
<a name="ln981"> </a>
<a name="ln982">    OS_REG_WRITE(ah, AR_Q_STATUS_RING_START, ahp-&gt;ts_paddr_start);</a>
<a name="ln983">    OS_REG_WRITE(ah, AR_Q_STATUS_RING_END, ahp-&gt;ts_paddr_end);</a>
<a name="ln984">}</a>
<a name="ln985"> </a>
<a name="ln986">void</a>
<a name="ln987">ar9300_setup_tx_status_ring(struct ath_hal *ah, void *ts_start,</a>
<a name="ln988">    u_int32_t ts_paddr_start, u_int16_t size)</a>
<a name="ln989">{</a>
<a name="ln990">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln991"> </a>
<a name="ln992">    ahp-&gt;ts_paddr_start = ts_paddr_start;</a>
<a name="ln993">    ahp-&gt;ts_paddr_end = ts_paddr_start + (size * sizeof(struct ar9300_txs));</a>
<a name="ln994">    ahp-&gt;ts_size = size;</a>
<a name="ln995">    ahp-&gt;ts_ring = (struct ar9300_txs *)ts_start;</a>
<a name="ln996"> </a>
<a name="ln997">    ar9300_reset_tx_status_ring(ah);</a>
<a name="ln998">}</a>

</code></pre>
<div class="balloon" rel="450"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'value < 0' is always false. Unsigned type value is never < 0.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
