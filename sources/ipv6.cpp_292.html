
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>ipv6.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2006-2011, Haiku, Inc. All Rights Reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Axel DÃ¶rfler, axeld@pinc-software.de</a>
<a name="ln7"> *		Atis Elsts, the.kfx@gmail.com</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10"> </a>
<a name="ln11">#include &quot;ipv6_address.h&quot;</a>
<a name="ln12">#include &quot;ipv6_utils.h&quot;</a>
<a name="ln13">#include &quot;multicast.h&quot;</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;net_datalink.h&gt;</a>
<a name="ln16">#include &lt;net_datalink_protocol.h&gt;</a>
<a name="ln17">#include &lt;net_device.h&gt;</a>
<a name="ln18">#include &lt;net_protocol.h&gt;</a>
<a name="ln19">#include &lt;net_stack.h&gt;</a>
<a name="ln20">#include &lt;NetBufferUtilities.h&gt;</a>
<a name="ln21">#include &lt;ProtocolUtilities.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;ByteOrder.h&gt;</a>
<a name="ln24">#include &lt;KernelExport.h&gt;</a>
<a name="ln25">#include &lt;StackOrHeapArray.h&gt;</a>
<a name="ln26">#include &lt;util/AutoLock.h&gt;</a>
<a name="ln27">#include &lt;util/list.h&gt;</a>
<a name="ln28">#include &lt;util/DoublyLinkedList.h&gt;</a>
<a name="ln29">#include &lt;util/MultiHashTable.h&gt;</a>
<a name="ln30"> </a>
<a name="ln31">#include &lt;netinet6/in6.h&gt;</a>
<a name="ln32">#include &lt;netinet/ip6.h&gt;</a>
<a name="ln33">#include &lt;netinet/icmp6.h&gt;</a>
<a name="ln34">#include &lt;new&gt;</a>
<a name="ln35">#include &lt;stdlib.h&gt;</a>
<a name="ln36">#include &lt;stdio.h&gt;</a>
<a name="ln37">#include &lt;string.h&gt;</a>
<a name="ln38">#include &lt;utility&gt;</a>
<a name="ln39"> </a>
<a name="ln40"> </a>
<a name="ln41">//#define TRACE_IPV6</a>
<a name="ln42">#ifdef TRACE_IPV6</a>
<a name="ln43">	#define TRACE(format, args...) \</a>
<a name="ln44">		dprintf(&quot;IPv6 [%&quot; B_PRIdBIGTIME &quot;] &quot; format &quot;\n&quot;, system_time(), ##args)</a>
<a name="ln45">	#define TRACE_SK(protocol, format, args...) \</a>
<a name="ln46">		dprintf(&quot;IPv6 [%&quot; B_PRIdBIGTIME &quot;] %p &quot; format &quot;\n&quot;, system_time(), \</a>
<a name="ln47">			protocol, ##args)</a>
<a name="ln48">#else</a>
<a name="ln49">	#define TRACE(args...)</a>
<a name="ln50">	#define TRACE_SK(args...)</a>
<a name="ln51">#endif</a>
<a name="ln52"> </a>
<a name="ln53"> </a>
<a name="ln54">#define MAX_HASH_FRAGMENTS 		64</a>
<a name="ln55">	// slots in the fragment packet's hash</a>
<a name="ln56">#define FRAGMENT_TIMEOUT		60000000LL</a>
<a name="ln57">	// discard fragment after 60 seconds [RFC 2460]</a>
<a name="ln58"> </a>
<a name="ln59"> </a>
<a name="ln60">struct IPv6Header {</a>
<a name="ln61">	struct ip6_hdr header;</a>
<a name="ln62"> </a>
<a name="ln63">	uint8 ProtocolVersion() const { return header.ip6_vfc &amp; IPV6_VERSION_MASK; }</a>
<a name="ln64">	uint8 ServiceType() const { return ntohl(header.ip6_flow) &gt;&gt; 20;}</a>
<a name="ln65">	uint16 PayloadLength() const { return ntohs(header.ip6_plen); }</a>
<a name="ln66">	const in6_addr&amp; Dst() const { return header.ip6_dst; }</a>
<a name="ln67">	const in6_addr&amp; Src() const { return header.ip6_src; }</a>
<a name="ln68">	uint8 NextHeader() const { return header.ip6_nxt; }</a>
<a name="ln69">	uint16 GetHeaderOffset(net_buffer* buffer, uint32 headerCode = ~0u) const;</a>
<a name="ln70">};</a>
<a name="ln71"> </a>
<a name="ln72"> </a>
<a name="ln73">typedef DoublyLinkedList&lt;struct net_buffer,</a>
<a name="ln74">	DoublyLinkedListCLink&lt;struct net_buffer&gt; &gt; FragmentList;</a>
<a name="ln75"> </a>
<a name="ln76"> </a>
<a name="ln77">// TODO: make common fragmentation interface for both address families</a>
<a name="ln78">struct ipv6_packet_key {</a>
<a name="ln79">	in6_addr	source;</a>
<a name="ln80">	in6_addr	destination;</a>
<a name="ln81">	// We use uint32 here due to the hash function</a>
<a name="ln82">	uint32		id;</a>
<a name="ln83">	uint32		protocol;</a>
<a name="ln84">};</a>
<a name="ln85"> </a>
<a name="ln86"> </a>
<a name="ln87">class FragmentPacket {</a>
<a name="ln88">public:</a>
<a name="ln89">								FragmentPacket(const ipv6_packet_key&amp; key);</a>
<a name="ln90">								~FragmentPacket();</a>
<a name="ln91"> </a>
<a name="ln92">			status_t			AddFragment(uint16 start, uint16 end,</a>
<a name="ln93">									net_buffer* buffer, bool lastFragment);</a>
<a name="ln94">			status_t			Reassemble(net_buffer* to);</a>
<a name="ln95"> </a>
<a name="ln96">			bool				IsComplete() const</a>
<a name="ln97">									{ return fReceivedLastFragment</a>
<a name="ln98">										&amp;&amp; fBytesLeft == 0; }</a>
<a name="ln99"> </a>
<a name="ln100">			const ipv6_packet_key&amp; Key() const { return fKey; }</a>
<a name="ln101">			FragmentPacket*&amp;	HashTableLink() { return fNext; }</a>
<a name="ln102"> </a>
<a name="ln103">	static	void				StaleTimer(struct net_timer* timer, void* data);</a>
<a name="ln104"> </a>
<a name="ln105">private:</a>
<a name="ln106">			FragmentPacket*		fNext;</a>
<a name="ln107">			struct ipv6_packet_key fKey;</a>
<a name="ln108">			uint32				fIndex;</a>
<a name="ln109">			int32				fBytesLeft;</a>
<a name="ln110">			FragmentList		fFragments;</a>
<a name="ln111">			net_timer			fTimer;</a>
<a name="ln112">			bool				fReceivedLastFragment;</a>
<a name="ln113">};</a>
<a name="ln114"> </a>
<a name="ln115"> </a>
<a name="ln116">struct FragmentHashDefinition {</a>
<a name="ln117">	typedef ipv6_packet_key KeyType;</a>
<a name="ln118">	typedef FragmentPacket ValueType;</a>
<a name="ln119"> </a>
<a name="ln120">	size_t HashKey(const KeyType&amp; key) const</a>
<a name="ln121">	{</a>
<a name="ln122">		return jenkins_hashword((const uint32*)&amp;key,</a>
<a name="ln123">			sizeof(ipv6_packet_key) / sizeof(uint32), 0);</a>
<a name="ln124">	}</a>
<a name="ln125"> </a>
<a name="ln126">	size_t Hash(ValueType* value) const</a>
<a name="ln127">	{</a>
<a name="ln128">		return HashKey(value-&gt;Key());</a>
<a name="ln129">	}</a>
<a name="ln130"> </a>
<a name="ln131">	bool Compare(const KeyType&amp; key, ValueType* value) const</a>
<a name="ln132">	{</a>
<a name="ln133">		const ipv6_packet_key&amp; packetKey = value-&gt;Key();</a>
<a name="ln134"> </a>
<a name="ln135">		return packetKey.id == key.id</a>
<a name="ln136">			&amp;&amp; packetKey.source == key.source</a>
<a name="ln137">			&amp;&amp; packetKey.destination == key.destination</a>
<a name="ln138">			&amp;&amp; packetKey.protocol == key.protocol;</a>
<a name="ln139">	}</a>
<a name="ln140"> </a>
<a name="ln141">	ValueType*&amp; GetLink(ValueType* value) const</a>
<a name="ln142">	{</a>
<a name="ln143">		return value-&gt;HashTableLink();</a>
<a name="ln144">	}</a>
<a name="ln145">};</a>
<a name="ln146"> </a>
<a name="ln147"> </a>
<a name="ln148">typedef BOpenHashTable&lt;FragmentHashDefinition, false, true&gt; FragmentTable;</a>
<a name="ln149"> </a>
<a name="ln150"> </a>
<a name="ln151">class RawSocket</a>
<a name="ln152">	: public DoublyLinkedListLinkImpl&lt;RawSocket&gt;, public DatagramSocket&lt;&gt; {</a>
<a name="ln153">public:</a>
<a name="ln154">							RawSocket(net_socket* socket);</a>
<a name="ln155">};</a>
<a name="ln156"> </a>
<a name="ln157"> </a>
<a name="ln158">typedef DoublyLinkedList&lt;RawSocket&gt; RawSocketList;</a>
<a name="ln159"> </a>
<a name="ln160">typedef MulticastGroupInterface&lt;IPv6Multicast&gt; IPv6GroupInterface;</a>
<a name="ln161">typedef MulticastFilter&lt;IPv6Multicast&gt; IPv6MulticastFilter;</a>
<a name="ln162"> </a>
<a name="ln163">struct MulticastStateHash {</a>
<a name="ln164">	typedef std::pair&lt;const in6_addr*, uint32&gt; KeyType;</a>
<a name="ln165">	typedef IPv6GroupInterface ValueType;</a>
<a name="ln166"> </a>
<a name="ln167">	size_t HashKey(const KeyType &amp;key) const;</a>
<a name="ln168">	size_t Hash(ValueType* value) const</a>
<a name="ln169">		{ return HashKey(std::make_pair(&amp;value-&gt;Address(),</a>
<a name="ln170">			value-&gt;Interface()-&gt;index)); }</a>
<a name="ln171">	bool Compare(const KeyType &amp;key, ValueType* value) const</a>
<a name="ln172">		{ return value-&gt;Interface()-&gt;index == key.second</a>
<a name="ln173">			&amp;&amp; value-&gt;Address() == *key.first; }</a>
<a name="ln174">	bool CompareValues(ValueType* value1, ValueType* value2) const</a>
<a name="ln175">		{ return value1-&gt;Interface()-&gt;index == value2-&gt;Interface()-&gt;index</a>
<a name="ln176">			&amp;&amp; value1-&gt;Address() == value2-&gt;Address(); }</a>
<a name="ln177">	ValueType*&amp; GetLink(ValueType* value) const { return value-&gt;MulticastGroupsHashLink(); }</a>
<a name="ln178">};</a>
<a name="ln179"> </a>
<a name="ln180"> </a>
<a name="ln181">struct ipv6_protocol : net_protocol {</a>
<a name="ln182">	ipv6_protocol()</a>
<a name="ln183">		:</a>
<a name="ln184">		raw(NULL),</a>
<a name="ln185">		multicast_filter(this)</a>
<a name="ln186">	{</a>
<a name="ln187">	}</a>
<a name="ln188"> </a>
<a name="ln189">	~ipv6_protocol()</a>
<a name="ln190">	{</a>
<a name="ln191">		delete raw;</a>
<a name="ln192">	}</a>
<a name="ln193"> </a>
<a name="ln194">	RawSocket	*raw;</a>
<a name="ln195">	uint8		service_type;</a>
<a name="ln196">	uint8		time_to_live;</a>
<a name="ln197">	uint8		multicast_time_to_live;</a>
<a name="ln198">	uint8		receive_hoplimit;</a>
<a name="ln199">	uint8		receive_pktinfo;</a>
<a name="ln200">	struct sockaddr* multicast_address; // for IPV6_MULTICAST_IF</a>
<a name="ln201"> </a>
<a name="ln202">	IPv6MulticastFilter multicast_filter;</a>
<a name="ln203">};</a>
<a name="ln204"> </a>
<a name="ln205"> </a>
<a name="ln206">static const int kDefaultTTL = IPV6_DEFHLIM;</a>
<a name="ln207">static const int kDefaultMulticastTTL = 1;</a>
<a name="ln208"> </a>
<a name="ln209"> </a>
<a name="ln210">extern net_protocol_module_info gIPv6Module;</a>
<a name="ln211">	// we need this in ipv6_std_ops() for registering the AF_INET6 domain</a>
<a name="ln212"> </a>
<a name="ln213">net_stack_module_info* gStackModule;</a>
<a name="ln214">net_buffer_module_info* gBufferModule;</a>
<a name="ln215"> </a>
<a name="ln216">static struct net_domain* sDomain;</a>
<a name="ln217">static net_datalink_module_info* sDatalinkModule;</a>
<a name="ln218">static net_socket_module_info* sSocketModule;</a>
<a name="ln219">static RawSocketList sRawSockets;</a>
<a name="ln220">static mutex sRawSocketsLock;</a>
<a name="ln221">static mutex sFragmentLock;</a>
<a name="ln222">static FragmentTable sFragmentHash;</a>
<a name="ln223">static int32 sFragmentID;</a>
<a name="ln224">static mutex sMulticastGroupsLock;</a>
<a name="ln225"> </a>
<a name="ln226">typedef MultiHashTable&lt;MulticastStateHash&gt; MulticastState;</a>
<a name="ln227">static MulticastState* sMulticastState;</a>
<a name="ln228"> </a>
<a name="ln229">static net_protocol_module_info* sReceivingProtocol[256];</a>
<a name="ln230">static mutex sReceivingProtocolLock;</a>
<a name="ln231"> </a>
<a name="ln232"> </a>
<a name="ln233">uint16</a>
<a name="ln234">IPv6Header::GetHeaderOffset(net_buffer* buffer, uint32 headerCode) const</a>
<a name="ln235">{</a>
<a name="ln236">	uint16 offset = sizeof(struct ip6_hdr);</a>
<a name="ln237">	uint8 next = header.ip6_nxt;</a>
<a name="ln238"> </a>
<a name="ln239">	// these are the extension headers that might be supported one day</a>
<a name="ln240">	while (next != headerCode</a>
<a name="ln241">		&amp;&amp; (next == IPPROTO_HOPOPTS</a>
<a name="ln242">			|| next == IPPROTO_ROUTING</a>
<a name="ln243">			|| next == IPPROTO_FRAGMENT</a>
<a name="ln244">			|| next == IPPROTO_ESP</a>
<a name="ln245">			|| next == IPPROTO_AH</a>
<a name="ln246">			|| next == IPPROTO_DSTOPTS)) {</a>
<a name="ln247">		struct ip6_ext extensionHeader;</a>
<a name="ln248">		status_t status = gBufferModule-&gt;read(buffer, offset,</a>
<a name="ln249">			&amp;extensionHeader, sizeof(ip6_ext));</a>
<a name="ln250">		if (status != B_OK)</a>
<a name="ln251">			break;</a>
<a name="ln252"> </a>
<a name="ln253">		next = extensionHeader.ip6e_nxt;</a>
<a name="ln254">		offset += extensionHeader.ip6e_len;</a>
<a name="ln255">	}</a>
<a name="ln256"> </a>
<a name="ln257">	// were we looking for a specific header?</a>
<a name="ln258">	if (headerCode != ~0u) {</a>
<a name="ln259">		if (next == headerCode) {</a>
<a name="ln260">			// found the specific header</a>
<a name="ln261">			return offset;</a>
<a name="ln262">		}</a>
<a name="ln263">		// return 0 if fragement header is not present</a>
<a name="ln264">		return 0;</a>
<a name="ln265">	}</a>
<a name="ln266"> </a>
<a name="ln267">	// the general transport layer header case</a>
<a name="ln268">	buffer-&gt;protocol = next;</a>
<a name="ln269">	return offset;</a>
<a name="ln270">}</a>
<a name="ln271"> </a>
<a name="ln272"> </a>
<a name="ln273">RawSocket::RawSocket(net_socket* socket)</a>
<a name="ln274">	:</a>
<a name="ln275">	DatagramSocket&lt;&gt;(&quot;ipv6 raw socket&quot;, socket)</a>
<a name="ln276">{</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279"> </a>
<a name="ln280">//	#pragma mark -</a>
<a name="ln281"> </a>
<a name="ln282"> </a>
<a name="ln283">FragmentPacket::FragmentPacket(const ipv6_packet_key &amp;key)</a>
<a name="ln284">	:</a>
<a name="ln285">	fKey(key),</a>
<a name="ln286">	fBytesLeft(IPV6_MAXPACKET),</a>
<a name="ln287">	fReceivedLastFragment(false)</a>
<a name="ln288">{</a>
<a name="ln289">	gStackModule-&gt;init_timer(&amp;fTimer, FragmentPacket::StaleTimer, this);</a>
<a name="ln290">}</a>
<a name="ln291"> </a>
<a name="ln292"> </a>
<a name="ln293">FragmentPacket::~FragmentPacket()</a>
<a name="ln294">{</a>
<a name="ln295">	// cancel the kill timer</a>
<a name="ln296">	gStackModule-&gt;set_timer(&amp;fTimer, -1);</a>
<a name="ln297"> </a>
<a name="ln298">	// delete all fragments</a>
<a name="ln299">	net_buffer* buffer;</a>
<a name="ln300">	while ((buffer = fFragments.RemoveHead()) != NULL) {</a>
<a name="ln301">		gBufferModule-&gt;free(buffer);</a>
<a name="ln302">	}</a>
<a name="ln303">}</a>
<a name="ln304"> </a>
<a name="ln305"> </a>
<a name="ln306">status_t</a>
<a name="ln307">FragmentPacket::AddFragment(uint16 start, uint16 end, net_buffer* buffer,</a>
<a name="ln308">	bool lastFragment)</a>
<a name="ln309">{</a>
<a name="ln310">	// restart the timer</a>
<a name="ln311">	gStackModule-&gt;set_timer(&amp;fTimer, FRAGMENT_TIMEOUT);</a>
<a name="ln312"> </a>
<a name="ln313">	if (start &gt;= end) {</a>
<a name="ln314">		// invalid fragment</a>
<a name="ln315">		return B_BAD_DATA;</a>
<a name="ln316">	}</a>
<a name="ln317"> </a>
<a name="ln318">	// Search for a position in the list to insert the fragment</a>
<a name="ln319"> </a>
<a name="ln320">	FragmentList::ReverseIterator iterator = fFragments.GetReverseIterator();</a>
<a name="ln321">	net_buffer* previous = NULL;</a>
<a name="ln322">	net_buffer* next = NULL;</a>
<a name="ln323">	while ((previous = iterator.Next()) != NULL) {</a>
<a name="ln324">		if (previous-&gt;fragment.start &lt;= start) {</a>
<a name="ln325">			// The new fragment can be inserted after this one</a>
<a name="ln326">			break;</a>
<a name="ln327">		}</a>
<a name="ln328"> </a>
<a name="ln329">		next = previous;</a>
<a name="ln330">	}</a>
<a name="ln331"> </a>
<a name="ln332">	// See if we already have the fragment's data</a>
<a name="ln333"> </a>
<a name="ln334">	if (previous != NULL &amp;&amp; previous-&gt;fragment.start &lt;= start</a>
<a name="ln335">		&amp;&amp; previous-&gt;fragment.end &gt;= end) {</a>
<a name="ln336">		// we do, so we can just drop this fragment</a>
<a name="ln337">		gBufferModule-&gt;free(buffer);</a>
<a name="ln338">		return B_OK;</a>
<a name="ln339">	}</a>
<a name="ln340"> </a>
<a name="ln341">	fIndex = buffer-&gt;index;</a>
<a name="ln342">		// adopt the buffer's device index</a>
<a name="ln343"> </a>
<a name="ln344">	TRACE(&quot;    previous: %p, next: %p&quot;, previous, next);</a>
<a name="ln345"> </a>
<a name="ln346">	// If we have parts of the data already, truncate as needed</a>
<a name="ln347"> </a>
<a name="ln348">	if (previous != NULL &amp;&amp; previous-&gt;fragment.end &gt; start) {</a>
<a name="ln349">		TRACE(&quot;    remove header %d bytes&quot;, previous-&gt;fragment.end - start);</a>
<a name="ln350">		gBufferModule-&gt;remove_header(buffer, previous-&gt;fragment.end - start);</a>
<a name="ln351">		start = previous-&gt;fragment.end;</a>
<a name="ln352">	}</a>
<a name="ln353">	if (next != NULL &amp;&amp; next-&gt;fragment.start &lt; end) {</a>
<a name="ln354">		TRACE(&quot;    remove trailer %d bytes&quot;, next-&gt;fragment.start - end);</a>
<a name="ln355">		gBufferModule-&gt;remove_trailer(buffer, next-&gt;fragment.start - end);</a>
<a name="ln356">		end = next-&gt;fragment.start;</a>
<a name="ln357">	}</a>
<a name="ln358"> </a>
<a name="ln359">	// Now try if we can already merge the fragments together</a>
<a name="ln360"> </a>
<a name="ln361">	// We will always keep the last buffer received, so that we can still</a>
<a name="ln362">	// report an error (in which case we're not responsible for freeing it)</a>
<a name="ln363"> </a>
<a name="ln364">	if (previous != NULL &amp;&amp; previous-&gt;fragment.end == start) {</a>
<a name="ln365">		fFragments.Remove(previous);</a>
<a name="ln366"> </a>
<a name="ln367">		buffer-&gt;fragment.start = previous-&gt;fragment.start;</a>
<a name="ln368">		buffer-&gt;fragment.end = end;</a>
<a name="ln369"> </a>
<a name="ln370">		status_t status = gBufferModule-&gt;merge(buffer, previous, false);</a>
<a name="ln371">		TRACE(&quot;    merge previous: %s&quot;, strerror(status));</a>
<a name="ln372">		if (status != B_OK) {</a>
<a name="ln373">			fFragments.Insert(next, previous);</a>
<a name="ln374">			return status;</a>
<a name="ln375">		}</a>
<a name="ln376"> </a>
<a name="ln377">		fFragments.Insert(next, buffer);</a>
<a name="ln378"> </a>
<a name="ln379">		// cut down existing hole</a>
<a name="ln380">		fBytesLeft -= end - start;</a>
<a name="ln381"> </a>
<a name="ln382">		if (lastFragment &amp;&amp; !fReceivedLastFragment) {</a>
<a name="ln383">			fReceivedLastFragment = true;</a>
<a name="ln384">			fBytesLeft -= IPV6_MAXPACKET - end;</a>
<a name="ln385">		}</a>
<a name="ln386"> </a>
<a name="ln387">		TRACE(&quot;    hole length: %d&quot;, (int)fBytesLeft);</a>
<a name="ln388"> </a>
<a name="ln389">		return B_OK;</a>
<a name="ln390">	} else if (next != NULL &amp;&amp; next-&gt;fragment.start == end) {</a>
<a name="ln391">		net_buffer* afterNext = (net_buffer*)next-&gt;link.next;</a>
<a name="ln392">		fFragments.Remove(next);</a>
<a name="ln393"> </a>
<a name="ln394">		buffer-&gt;fragment.start = start;</a>
<a name="ln395">		buffer-&gt;fragment.end = next-&gt;fragment.end;</a>
<a name="ln396"> </a>
<a name="ln397">		status_t status = gBufferModule-&gt;merge(buffer, next, true);</a>
<a name="ln398">		TRACE(&quot;    merge next: %s&quot;, strerror(status));</a>
<a name="ln399">		if (status != B_OK) {</a>
<a name="ln400">			// Insert &quot;next&quot; at its previous position</a>
<a name="ln401">			fFragments.Insert(afterNext, next);</a>
<a name="ln402">			return status;</a>
<a name="ln403">		}</a>
<a name="ln404"> </a>
<a name="ln405">		fFragments.Insert(afterNext, buffer);</a>
<a name="ln406"> </a>
<a name="ln407">		// cut down existing hole</a>
<a name="ln408">		fBytesLeft -= end - start;</a>
<a name="ln409"> </a>
<a name="ln410">		if (lastFragment &amp;&amp; !fReceivedLastFragment) {</a>
<a name="ln411">			fReceivedLastFragment = true;</a>
<a name="ln412">			fBytesLeft -= IPV6_MAXPACKET - end;</a>
<a name="ln413">		}</a>
<a name="ln414"> </a>
<a name="ln415">		TRACE(&quot;    hole length: %d&quot;, (int)fBytesLeft);</a>
<a name="ln416"> </a>
<a name="ln417">		return B_OK;</a>
<a name="ln418">	}</a>
<a name="ln419"> </a>
<a name="ln420">	// We couldn't merge the fragments, so we need to add it as is</a>
<a name="ln421"> </a>
<a name="ln422">	TRACE(&quot;    new fragment: %p, bytes %d-%d&quot;, buffer, start, end);</a>
<a name="ln423"> </a>
<a name="ln424">	buffer-&gt;fragment.start = start;</a>
<a name="ln425">	buffer-&gt;fragment.end = end;</a>
<a name="ln426">	fFragments.Insert(next, buffer);</a>
<a name="ln427"> </a>
<a name="ln428">	// update length of the hole, if any</a>
<a name="ln429">	fBytesLeft -= end - start;</a>
<a name="ln430"> </a>
<a name="ln431">	if (lastFragment &amp;&amp; !fReceivedLastFragment) {</a>
<a name="ln432">		fReceivedLastFragment = true;</a>
<a name="ln433">		fBytesLeft -= IPV6_MAXPACKET - end;</a>
<a name="ln434">	}</a>
<a name="ln435"> </a>
<a name="ln436">	TRACE(&quot;    hole length: %d&quot;, (int)fBytesLeft);</a>
<a name="ln437"> </a>
<a name="ln438">	return B_OK;</a>
<a name="ln439">}</a>
<a name="ln440"> </a>
<a name="ln441"> </a>
<a name="ln442">/*!	Reassembles the fragments to the specified buffer \a to.</a>
<a name="ln443">	This buffer must have been added via AddFragment() before.</a>
<a name="ln444">*/</a>
<a name="ln445">status_t</a>
<a name="ln446">FragmentPacket::Reassemble(net_buffer* to)</a>
<a name="ln447">{</a>
<a name="ln448">	if (!IsComplete())</a>
<a name="ln449">		return B_ERROR;</a>
<a name="ln450"> </a>
<a name="ln451">	net_buffer* buffer = NULL;</a>
<a name="ln452"> </a>
<a name="ln453">	net_buffer* fragment;</a>
<a name="ln454">	while ((fragment = fFragments.RemoveHead()) != NULL) {</a>
<a name="ln455">		if (buffer != NULL) {</a>
<a name="ln456">			status_t status;</a>
<a name="ln457">			if (to == fragment) {</a>
<a name="ln458">				status = gBufferModule-&gt;merge(fragment, buffer, false);</a>
<a name="ln459">				buffer = fragment;</a>
<a name="ln460">			} else</a>
<a name="ln461">				status = gBufferModule-&gt;merge(buffer, fragment, true);</a>
<a name="ln462">			if (status != B_OK)</a>
<a name="ln463">				return status;</a>
<a name="ln464">		} else</a>
<a name="ln465">			buffer = fragment;</a>
<a name="ln466">	}</a>
<a name="ln467"> </a>
<a name="ln468">	if (buffer != to)</a>
<a name="ln469">		panic(&quot;ipv6 packet reassembly did not work correctly.&quot;);</a>
<a name="ln470"> </a>
<a name="ln471">	to-&gt;index = fIndex;</a>
<a name="ln472">		// reset the buffer's device index</a>
<a name="ln473"> </a>
<a name="ln474">	return B_OK;</a>
<a name="ln475">}</a>
<a name="ln476"> </a>
<a name="ln477"> </a>
<a name="ln478">/*static*/ void</a>
<a name="ln479">FragmentPacket::StaleTimer(struct net_timer* timer, void* data)</a>
<a name="ln480">{</a>
<a name="ln481">	FragmentPacket* packet = (FragmentPacket*)data;</a>
<a name="ln482">	TRACE(&quot;Assembling FragmentPacket %p timed out!&quot;, packet);</a>
<a name="ln483"> </a>
<a name="ln484">	MutexLocker locker(&amp;sFragmentLock);</a>
<a name="ln485">	sFragmentHash.Remove(packet);</a>
<a name="ln486">	locker.Unlock();</a>
<a name="ln487"> </a>
<a name="ln488">	if (!packet-&gt;fFragments.IsEmpty()) {</a>
<a name="ln489">		// Send error: fragment reassembly time exceeded</a>
<a name="ln490">		sDomain-&gt;module-&gt;error_reply(NULL, packet-&gt;fFragments.First(),</a>
<a name="ln491">			B_NET_ERROR_REASSEMBLY_TIME_EXCEEDED, NULL);</a>
<a name="ln492">	}</a>
<a name="ln493"> </a>
<a name="ln494">	delete packet;</a>
<a name="ln495">}</a>
<a name="ln496"> </a>
<a name="ln497"> </a>
<a name="ln498">//	#pragma mark -</a>
<a name="ln499"> </a>
<a name="ln500"> </a>
<a name="ln501">size_t</a>
<a name="ln502">MulticastStateHash::HashKey(const KeyType &amp;key) const</a>
<a name="ln503">{</a>
<a name="ln504">	size_t result = 0;</a>
<a name="ln505">	result = jenkins_hashword((const uint32*)key.first,</a>
<a name="ln506">		sizeof(in6_addr) / sizeof(uint32), result);</a>
<a name="ln507">	result = jenkins_hashword(&amp;key.second, 1, result);</a>
<a name="ln508">	return result;</a>
<a name="ln509">}</a>
<a name="ln510"> </a>
<a name="ln511"> </a>
<a name="ln512">//	#pragma mark -</a>
<a name="ln513"> </a>
<a name="ln514"> </a>
<a name="ln515">static inline void</a>
<a name="ln516">dump_ipv6_header(IPv6Header &amp;header)</a>
<a name="ln517">{</a>
<a name="ln518">#ifdef TRACE_IPV6</a>
<a name="ln519">	char addrbuf[INET6_ADDRSTRLEN];</a>
<a name="ln520">	dprintf(&quot;  version: %d\n&quot;, header.ProtocolVersion() &gt;&gt; 4);</a>
<a name="ln521">	dprintf(&quot;  service_type: %d\n&quot;, header.ServiceType());</a>
<a name="ln522">	dprintf(&quot;  payload_length: %d\n&quot;, header.PayloadLength());</a>
<a name="ln523">	dprintf(&quot;  next_header: %d\n&quot;, header.NextHeader());</a>
<a name="ln524">	dprintf(&quot;  hop_limit: %d\n&quot;, header.header.ip6_hops);</a>
<a name="ln525">	dprintf(&quot;  source: %s\n&quot;, ip6_sprintf(&amp;header.header.ip6_src, addrbuf));</a>
<a name="ln526">	dprintf(&quot;  destination: %s\n&quot;,</a>
<a name="ln527">		ip6_sprintf(&amp;header.header.ip6_dst, addrbuf));</a>
<a name="ln528">#endif</a>
<a name="ln529">}</a>
<a name="ln530"> </a>
<a name="ln531"> </a>
<a name="ln532">/*!	Attempts to re-assemble fragmented packets.</a>
<a name="ln533">	\return B_OK if everything went well; if it could reassemble the packet,</a>
<a name="ln534">		\a _buffer will point to its buffer, otherwise, it will be \c NULL.</a>
<a name="ln535">	\return various error codes if something went wrong (mostly B_NO_MEMORY)</a>
<a name="ln536">*/</a>
<a name="ln537">static status_t</a>
<a name="ln538">reassemble_fragments(const IPv6Header &amp;header, net_buffer** _buffer,</a>
<a name="ln539">	uint16 offset)</a>
<a name="ln540">{</a>
<a name="ln541">	net_buffer* buffer = *_buffer;</a>
<a name="ln542">	status_t status;</a>
<a name="ln543"> </a>
<a name="ln544">	ip6_frag fragmentHeader;</a>
<a name="ln545">	status = gBufferModule-&gt;read(buffer, offset, &amp;fragmentHeader,</a>
<a name="ln546">		sizeof(ip6_frag));</a>
<a name="ln547"> </a>
<a name="ln548">	if (status != B_OK)</a>
<a name="ln549">		return status;</a>
<a name="ln550"> </a>
<a name="ln551">	struct ipv6_packet_key key;</a>
<a name="ln552">	memcpy(&amp;key.source, &amp;header.Src(), sizeof(in6_addr));</a>
<a name="ln553">	memcpy(&amp;key.destination, &amp;header.Dst(), sizeof(in6_addr));</a>
<a name="ln554">	key.id = fragmentHeader.ip6f_ident;</a>
<a name="ln555">	key.protocol = fragmentHeader.ip6f_nxt;</a>
<a name="ln556"> </a>
<a name="ln557">	// TODO: Make locking finer grained.</a>
<a name="ln558">	MutexLocker locker(&amp;sFragmentLock);</a>
<a name="ln559"> </a>
<a name="ln560">	FragmentPacket* packet = sFragmentHash.Lookup(key);</a>
<a name="ln561">	if (packet == NULL) {</a>
<a name="ln562">		// New fragment packet</a>
<a name="ln563">		packet = new (std::nothrow) FragmentPacket(key);</a>
<a name="ln564">		if (packet == NULL)</a>
<a name="ln565">			return B_NO_MEMORY;</a>
<a name="ln566"> </a>
<a name="ln567">		// add packet to hash</a>
<a name="ln568">		status = sFragmentHash.Insert(packet);</a>
<a name="ln569">		if (status != B_OK) {</a>
<a name="ln570">			delete packet;</a>
<a name="ln571">			return status;</a>
<a name="ln572">		}</a>
<a name="ln573">	}</a>
<a name="ln574"> </a>
<a name="ln575">	uint16 start = ntohs(fragmentHeader.ip6f_offlg &amp; IP6F_OFF_MASK);</a>
<a name="ln576">	uint16 end = start + header.PayloadLength();</a>
<a name="ln577">	bool lastFragment = (fragmentHeader.ip6f_offlg &amp; IP6F_MORE_FRAG) == 0;</a>
<a name="ln578"> </a>
<a name="ln579">	TRACE(&quot;   Received IPv6 %sfragment of size %d, offset %d.&quot;,</a>
<a name="ln580">		lastFragment ? &quot;last &quot;: &quot;&quot;, end - start, start);</a>
<a name="ln581"> </a>
<a name="ln582">	// Remove header unless this is the first fragment</a>
<a name="ln583">	if (start != 0)</a>
<a name="ln584">		gBufferModule-&gt;remove_header(buffer, offset);</a>
<a name="ln585"> </a>
<a name="ln586">	status = packet-&gt;AddFragment(start, end, buffer, lastFragment);</a>
<a name="ln587">	if (status != B_OK)</a>
<a name="ln588">		return status;</a>
<a name="ln589"> </a>
<a name="ln590">	if (packet-&gt;IsComplete()) {</a>
<a name="ln591">		sFragmentHash.Remove(packet);</a>
<a name="ln592">			// no matter if reassembling succeeds, we won't need this packet</a>
<a name="ln593">			// anymore</a>
<a name="ln594"> </a>
<a name="ln595">		status = packet-&gt;Reassemble(buffer);</a>
<a name="ln596">		delete packet;</a>
<a name="ln597"> </a>
<a name="ln598">		// _buffer does not change</a>
<a name="ln599">		return status;</a>
<a name="ln600">	}</a>
<a name="ln601"> </a>
<a name="ln602">	// This indicates that the packet is not yet complete</a>
<a name="ln603">	*_buffer = NULL;</a>
<a name="ln604">	return B_OK;</a>
<a name="ln605">}</a>
<a name="ln606"> </a>
<a name="ln607"> </a>
<a name="ln608">/*!	Fragments the incoming buffer and send all fragments via the specified</a>
<a name="ln609">	\a route.</a>
<a name="ln610">*/</a>
<a name="ln611">static status_t</a>
<a name="ln612">send_fragments(ipv6_protocol* protocol, struct net_route* route,</a>
<a name="ln613">	net_buffer* buffer, uint32 mtu)</a>
<a name="ln614">{</a>
<a name="ln615">	TRACE_SK(protocol, &quot;SendFragments(%&quot; B_PRIu32 &quot; bytes, mtu %&quot; B_PRIu32 &quot;)&quot;,</a>
<a name="ln616">		buffer-&gt;size, mtu);</a>
<a name="ln617"> </a>
<a name="ln618">	NetBufferHeaderReader&lt;IPv6Header&gt; originalHeader(buffer);</a>
<a name="ln619">	if (originalHeader.Status() != B_OK)</a>
<a name="ln620">		return originalHeader.Status();</a>
<a name="ln621"> </a>
<a name="ln622">	// TODO: currently FragHeader goes always as the last one, but in theory</a>
<a name="ln623">	// ext. headers like AuthHeader and DestOptions should go after it.</a>
<a name="ln624">	uint16 headersLength = originalHeader-&gt;GetHeaderOffset(buffer);</a>
<a name="ln625">	uint16 extensionHeadersLength = headersLength</a>
<a name="ln626">		- sizeof(ip6_hdr) + sizeof(ip6_frag);</a>
<a name="ln627">	uint32 bytesLeft = buffer-&gt;size - headersLength;</a>
<a name="ln628">	uint32 fragmentOffset = 0;</a>
<a name="ln629">	status_t status = B_OK;</a>
<a name="ln630"> </a>
<a name="ln631">	// TODO: this is rather inefficient</a>
<a name="ln632">	net_buffer* headerBuffer = gBufferModule-&gt;clone(buffer, false);</a>
<a name="ln633">	if (headerBuffer == NULL)</a>
<a name="ln634">		return B_NO_MEMORY;</a>
<a name="ln635"> </a>
<a name="ln636">	status = gBufferModule-&gt;remove_trailer(headerBuffer, bytesLeft);</a>
<a name="ln637">	if (status != B_OK)</a>
<a name="ln638">		return status;</a>
<a name="ln639"> </a>
<a name="ln640">	BStackOrHeapArray&lt;uint8, 128&gt; data(bytesLeft);</a>
<a name="ln641">	if (!data.IsValid())</a>
<a name="ln642">		return B_NO_MEMORY;</a>
<a name="ln643">	status = gBufferModule-&gt;read(buffer, headersLength, data, bytesLeft);</a>
<a name="ln644">	if (status != B_OK)</a>
<a name="ln645">		return status;</a>
<a name="ln646"> </a>
<a name="ln647">	// TODO (from ipv4): we need to make sure all header space is contiguous or</a>
<a name="ln648">	// use another construct.</a>
<a name="ln649">	NetBufferHeaderReader&lt;IPv6Header&gt; bufferHeader(headerBuffer);</a>
<a name="ln650"> </a>
<a name="ln651">	// Adapt MTU to be a multiple of 8 (fragment offsets can only be specified</a>
<a name="ln652">	// this way)</a>
<a name="ln653">	mtu -= headersLength + sizeof(ip6_frag);</a>
<a name="ln654">	mtu &amp;= ~7;</a>
<a name="ln655">	TRACE(&quot;  adjusted MTU to %&quot; B_PRIu32 &quot; bytesLeft %&quot; B_PRIu32, mtu,</a>
<a name="ln656">		bytesLeft);</a>
<a name="ln657"> </a>
<a name="ln658">	while (bytesLeft &gt; 0) {</a>
<a name="ln659">		uint32 fragmentLength = min_c(bytesLeft, mtu);</a>
<a name="ln660">		bytesLeft -= fragmentLength;</a>
<a name="ln661">		bool lastFragment = bytesLeft == 0;</a>
<a name="ln662"> </a>
<a name="ln663">		bufferHeader-&gt;header.ip6_nxt = IPPROTO_FRAGMENT;</a>
<a name="ln664">		bufferHeader-&gt;header.ip6_plen</a>
<a name="ln665">			= htons(fragmentLength + extensionHeadersLength);</a>
<a name="ln666">		bufferHeader.Sync();</a>
<a name="ln667"> </a>
<a name="ln668">		ip6_frag fragmentHeader;</a>
<a name="ln669">		fragmentHeader.ip6f_nxt = originalHeader-&gt;NextHeader();</a>
<a name="ln670">		fragmentHeader.ip6f_reserved = 0;</a>
<a name="ln671">		fragmentHeader.ip6f_offlg = htons(fragmentOffset) &amp; IP6F_OFF_MASK;</a>
<a name="ln672">		if (!lastFragment)</a>
<a name="ln673">			fragmentHeader.ip6f_offlg |= IP6F_MORE_FRAG;</a>
<a name="ln674">		fragmentHeader.ip6f_ident = htonl(atomic_add(&amp;sFragmentID, 1));</a>
<a name="ln675"> </a>
<a name="ln676">		TRACE(&quot;  send fragment of %&quot; B_PRIu32 &quot; bytes (%&quot; B_PRIu32</a>
<a name="ln677">			&quot; bytes left)&quot;, fragmentLength, bytesLeft);</a>
<a name="ln678"> </a>
<a name="ln679">		net_buffer* fragmentBuffer;</a>
<a name="ln680">		if (!lastFragment)</a>
<a name="ln681">			fragmentBuffer = gBufferModule-&gt;clone(headerBuffer, false);</a>
<a name="ln682">		else</a>
<a name="ln683">			fragmentBuffer = buffer;</a>
<a name="ln684"> </a>
<a name="ln685">		if (fragmentBuffer == NULL) {</a>
<a name="ln686">			status = B_NO_MEMORY;</a>
<a name="ln687">			break;</a>
<a name="ln688">		}</a>
<a name="ln689"> </a>
<a name="ln690">		// copy data to fragment</a>
<a name="ln691">		do {</a>
<a name="ln692">			status = gBufferModule-&gt;append(</a>
<a name="ln693">				fragmentBuffer, &amp;fragmentHeader, sizeof(ip6_frag));</a>
<a name="ln694">			if (status != B_OK)</a>
<a name="ln695">				break;</a>
<a name="ln696"> </a>
<a name="ln697">			status = gBufferModule-&gt;append(</a>
<a name="ln698">				fragmentBuffer, &amp;data[fragmentOffset], fragmentLength);</a>
<a name="ln699">			if (status != B_OK)</a>
<a name="ln700">				break;</a>
<a name="ln701"> </a>
<a name="ln702">			// send fragment</a>
<a name="ln703">			status = sDatalinkModule-&gt;send_routed_data(route, fragmentBuffer);</a>
<a name="ln704">		} while (false);</a>
<a name="ln705"> </a>
<a name="ln706">		if (lastFragment) {</a>
<a name="ln707">			// we don't own the last buffer, so we don't have to free it</a>
<a name="ln708">			break;</a>
<a name="ln709">		}</a>
<a name="ln710"> </a>
<a name="ln711">		if (status != B_OK) {</a>
<a name="ln712">			gBufferModule-&gt;free(fragmentBuffer);</a>
<a name="ln713">			break;</a>
<a name="ln714">		}</a>
<a name="ln715"> </a>
<a name="ln716">		fragmentOffset += fragmentLength;</a>
<a name="ln717">	}</a>
<a name="ln718"> </a>
<a name="ln719">	gBufferModule-&gt;free(headerBuffer);</a>
<a name="ln720">	return status;</a>
<a name="ln721">}</a>
<a name="ln722"> </a>
<a name="ln723"> </a>
<a name="ln724">static status_t</a>
<a name="ln725">deliver_multicast(net_protocol_module_info* module, net_buffer* buffer,</a>
<a name="ln726">	bool deliverToRaw, net_interface *interface)</a>
<a name="ln727">{</a>
<a name="ln728">	sockaddr_in6* multicastAddr = (sockaddr_in6*)buffer-&gt;destination;</a>
<a name="ln729"> </a>
<a name="ln730">	MulticastState::ValueIterator it = sMulticastState-&gt;Lookup(std::make_pair(</a>
<a name="ln731">		&amp;multicastAddr-&gt;sin6_addr, interface-&gt;index));</a>
<a name="ln732"> </a>
<a name="ln733">	while (it.HasNext()) {</a>
<a name="ln734">		IPv6GroupInterface* state = it.Next();</a>
<a name="ln735">		ipv6_protocol* ipproto = state-&gt;Parent()-&gt;Socket();</a>
<a name="ln736"> </a>
<a name="ln737">		if (deliverToRaw &amp;&amp; ipproto-&gt;raw == NULL)</a>
<a name="ln738">			continue;</a>
<a name="ln739"> </a>
<a name="ln740">		if (state-&gt;FilterAccepts(buffer)) {</a>
<a name="ln741">			// TODO: do as in IPv4 code</a>
<a name="ln742">			module-&gt;deliver_data(ipproto, buffer);</a>
<a name="ln743">		}</a>
<a name="ln744">	}</a>
<a name="ln745"> </a>
<a name="ln746">	return B_OK;</a>
<a name="ln747">}</a>
<a name="ln748"> </a>
<a name="ln749"> </a>
<a name="ln750">static status_t</a>
<a name="ln751">deliver_multicast(net_protocol_module_info* module, net_buffer* buffer,</a>
<a name="ln752">	bool deliverToRaw)</a>
<a name="ln753">{</a>
<a name="ln754">	if (module-&gt;deliver_data == NULL)</a>
<a name="ln755">		return B_OK;</a>
<a name="ln756"> </a>
<a name="ln757">	MutexLocker _(sMulticastGroupsLock);</a>
<a name="ln758"> </a>
<a name="ln759">	status_t status = B_OK;</a>
<a name="ln760">	if (buffer-&gt;interface_address != NULL) {</a>
<a name="ln761">		status = deliver_multicast(module, buffer, deliverToRaw,</a>
<a name="ln762">			buffer-&gt;interface_address-&gt;interface);</a>
<a name="ln763">	} else {</a>
<a name="ln764">#if 0 //  FIXME: multicast</a>
<a name="ln765">		net_domain_private* domain = (net_domain_private*)sDomain;</a>
<a name="ln766">		RecursiveLocker locker(domain-&gt;lock);</a>
<a name="ln767"> </a>
<a name="ln768">		net_interface* interface = NULL;</a>
<a name="ln769">		while (true) {</a>
<a name="ln770">			interface = (net_interface*)list_get_next_item(</a>
<a name="ln771">				&amp;domain-&gt;interfaces, interface);</a>
<a name="ln772">			if (interface == NULL)</a>
<a name="ln773">				break;</a>
<a name="ln774"> </a>
<a name="ln775">			status = deliver_multicast(module, buffer, deliverToRaw, interface);</a>
<a name="ln776">			if (status &lt; B_OK)</a>
<a name="ln777">				break;</a>
<a name="ln778">		}</a>
<a name="ln779">#endif</a>
<a name="ln780">	}</a>
<a name="ln781">	return status;</a>
<a name="ln782">}</a>
<a name="ln783"> </a>
<a name="ln784"> </a>
<a name="ln785">static void</a>
<a name="ln786">raw_receive_data(net_buffer* buffer)</a>
<a name="ln787">{</a>
<a name="ln788">	MutexLocker locker(sRawSocketsLock);</a>
<a name="ln789"> </a>
<a name="ln790">	if (sRawSockets.IsEmpty())</a>
<a name="ln791">		return;</a>
<a name="ln792"> </a>
<a name="ln793">	TRACE(&quot;RawReceiveData(%i)&quot;, buffer-&gt;protocol);</a>
<a name="ln794"> </a>
<a name="ln795">	if ((buffer-&gt;flags &amp; MSG_MCAST) != 0) {</a>
<a name="ln796">		deliver_multicast(&amp;gIPv6Module, buffer, true);</a>
<a name="ln797">	} else {</a>
<a name="ln798">		RawSocketList::Iterator iterator = sRawSockets.GetIterator();</a>
<a name="ln799"> </a>
<a name="ln800">		while (iterator.HasNext()) {</a>
<a name="ln801">			RawSocket* raw = iterator.Next();</a>
<a name="ln802"> </a>
<a name="ln803">			if (raw-&gt;Socket()-&gt;protocol == buffer-&gt;protocol)</a>
<a name="ln804">				raw-&gt;EnqueueClone(buffer);</a>
<a name="ln805">		}</a>
<a name="ln806">	}</a>
<a name="ln807">}</a>
<a name="ln808"> </a>
<a name="ln809"> </a>
<a name="ln810">static inline sockaddr*</a>
<a name="ln811">fill_sockaddr_in6(sockaddr_in6* target, const in6_addr &amp;address)</a>
<a name="ln812">{</a>
<a name="ln813">	target-&gt;sin6_family = AF_INET6;</a>
<a name="ln814">	target-&gt;sin6_len = sizeof(sockaddr_in6);</a>
<a name="ln815">	target-&gt;sin6_port = 0;</a>
<a name="ln816">	target-&gt;sin6_flowinfo = 0;</a>
<a name="ln817">	memcpy(target-&gt;sin6_addr.s6_addr, address.s6_addr, sizeof(in6_addr));</a>
<a name="ln818">	target-&gt;sin6_scope_id = 0;</a>
<a name="ln819">	return (sockaddr*)target;</a>
<a name="ln820">}</a>
<a name="ln821"> </a>
<a name="ln822"> </a>
<a name="ln823">status_t</a>
<a name="ln824">IPv6Multicast::JoinGroup(IPv6GroupInterface* state)</a>
<a name="ln825">{</a>
<a name="ln826">	MutexLocker _(sMulticastGroupsLock);</a>
<a name="ln827"> </a>
<a name="ln828">	sockaddr_in6 groupAddr;</a>
<a name="ln829">	status_t status = sDatalinkModule-&gt;join_multicast(state-&gt;Interface(),</a>
<a name="ln830">		sDomain, fill_sockaddr_in6(&amp;groupAddr, state-&gt;Address()));</a>
<a name="ln831">	if (status != B_OK)</a>
<a name="ln832">		return status;</a>
<a name="ln833"> </a>
<a name="ln834">	sMulticastState-&gt;Insert(state);</a>
<a name="ln835">	return B_OK;</a>
<a name="ln836">}</a>
<a name="ln837"> </a>
<a name="ln838"> </a>
<a name="ln839">status_t</a>
<a name="ln840">IPv6Multicast::LeaveGroup(IPv6GroupInterface* state)</a>
<a name="ln841">{</a>
<a name="ln842">	MutexLocker _(sMulticastGroupsLock);</a>
<a name="ln843"> </a>
<a name="ln844">	sMulticastState-&gt;Remove(state);</a>
<a name="ln845"> </a>
<a name="ln846">	sockaddr_in6 groupAddr;</a>
<a name="ln847">	return sDatalinkModule-&gt;leave_multicast(state-&gt;Interface(), sDomain,</a>
<a name="ln848">		fill_sockaddr_in6(&amp;groupAddr, state-&gt;Address()));</a>
<a name="ln849">}</a>
<a name="ln850"> </a>
<a name="ln851"> </a>
<a name="ln852">static net_protocol_module_info*</a>
<a name="ln853">receiving_protocol(uint8 protocol)</a>
<a name="ln854">{</a>
<a name="ln855">	net_protocol_module_info* module = sReceivingProtocol[protocol];</a>
<a name="ln856">	if (module != NULL)</a>
<a name="ln857">		return module;</a>
<a name="ln858"> </a>
<a name="ln859">	MutexLocker locker(sReceivingProtocolLock);</a>
<a name="ln860"> </a>
<a name="ln861">	module = sReceivingProtocol[protocol];</a>
<a name="ln862">	if (module != NULL)</a>
<a name="ln863">		return module;</a>
<a name="ln864"> </a>
<a name="ln865">	if (gStackModule-&gt;get_domain_receiving_protocol(sDomain, protocol,</a>
<a name="ln866">			&amp;module) == B_OK)</a>
<a name="ln867">		sReceivingProtocol[protocol] = module;</a>
<a name="ln868"> </a>
<a name="ln869">	return module;</a>
<a name="ln870">}</a>
<a name="ln871"> </a>
<a name="ln872"> </a>
<a name="ln873">static status_t</a>
<a name="ln874">ipv6_delta_group(IPv6GroupInterface* group, int option,</a>
<a name="ln875">	net_interface* interface, const in6_addr* sourceAddr)</a>
<a name="ln876">{</a>
<a name="ln877">	switch (option) {</a>
<a name="ln878">		case IPV6_JOIN_GROUP:</a>
<a name="ln879">			return group-&gt;Add();</a>
<a name="ln880">		case IPV6_LEAVE_GROUP:</a>
<a name="ln881">			return group-&gt;Drop();</a>
<a name="ln882">	}</a>
<a name="ln883"> </a>
<a name="ln884">	return B_ERROR;</a>
<a name="ln885">}</a>
<a name="ln886"> </a>
<a name="ln887"> </a>
<a name="ln888">static status_t</a>
<a name="ln889">ipv6_delta_membership(ipv6_protocol* protocol, int option,</a>
<a name="ln890">	net_interface* interface, const in6_addr* groupAddr,</a>
<a name="ln891">	const in6_addr* sourceAddr)</a>
<a name="ln892">{</a>
<a name="ln893">	IPv6MulticastFilter &amp;filter = protocol-&gt;multicast_filter;</a>
<a name="ln894">	IPv6GroupInterface* state = NULL;</a>
<a name="ln895">	status_t status = B_OK;</a>
<a name="ln896"> </a>
<a name="ln897">	switch (option) {</a>
<a name="ln898">		// TODO: support more options</a>
<a name="ln899">		case IPV6_JOIN_GROUP:</a>
<a name="ln900">			status = filter.GetState(*groupAddr, interface, state, true);</a>
<a name="ln901">			break;</a>
<a name="ln902"> </a>
<a name="ln903">		case IPV6_LEAVE_GROUP:</a>
<a name="ln904">			filter.GetState(*groupAddr, interface, state, false);</a>
<a name="ln905">			if (state == NULL)</a>
<a name="ln906">				return EADDRNOTAVAIL;</a>
<a name="ln907">			break;</a>
<a name="ln908">	}</a>
<a name="ln909"> </a>
<a name="ln910">	if (status != B_OK)</a>
<a name="ln911">		return status;</a>
<a name="ln912"> </a>
<a name="ln913">	status = ipv6_delta_group(state, option, interface, sourceAddr);</a>
<a name="ln914">	filter.ReturnState(state);</a>
<a name="ln915">	return status;</a>
<a name="ln916">}</a>
<a name="ln917"> </a>
<a name="ln918"> </a>
<a name="ln919">static status_t</a>
<a name="ln920">ipv6_delta_membership(ipv6_protocol* protocol, int option,</a>
<a name="ln921">	uint32 interfaceIndex, in6_addr* groupAddr, in6_addr* sourceAddr)</a>
<a name="ln922">{</a>
<a name="ln923">	net_interface* interface;</a>
<a name="ln924"> </a>
<a name="ln925">	// TODO: can the interface be unspecified?</a>
<a name="ln926">	interface = sDatalinkModule-&gt;get_interface(sDomain, interfaceIndex);</a>
<a name="ln927"> </a>
<a name="ln928">	if (interface == NULL)</a>
<a name="ln929">		return B_DEVICE_NOT_FOUND;</a>
<a name="ln930"> </a>
<a name="ln931">	return ipv6_delta_membership(protocol, option, interface,</a>
<a name="ln932">		groupAddr, sourceAddr);</a>
<a name="ln933">}</a>
<a name="ln934"> </a>
<a name="ln935"> </a>
<a name="ln936">static status_t</a>
<a name="ln937">get_int_option(void* target, size_t length, int value)</a>
<a name="ln938">{</a>
<a name="ln939">	if (length != sizeof(int))</a>
<a name="ln940">		return B_BAD_VALUE;</a>
<a name="ln941"> </a>
<a name="ln942">	return user_memcpy(target, &amp;value, sizeof(int));</a>
<a name="ln943">}</a>
<a name="ln944"> </a>
<a name="ln945"> </a>
<a name="ln946">template&lt;typename Type&gt; static status_t</a>
<a name="ln947">set_int_option(Type &amp;target, const void* _value, size_t length)</a>
<a name="ln948">{</a>
<a name="ln949">	int value;</a>
<a name="ln950"> </a>
<a name="ln951">	if (length != sizeof(int))</a>
<a name="ln952">		return B_BAD_VALUE;</a>
<a name="ln953"> </a>
<a name="ln954">	if (user_memcpy(&amp;value, _value, sizeof(int)) != B_OK)</a>
<a name="ln955">		return B_BAD_ADDRESS;</a>
<a name="ln956"> </a>
<a name="ln957">	target = value;</a>
<a name="ln958">	return B_OK;</a>
<a name="ln959">}</a>
<a name="ln960"> </a>
<a name="ln961"> </a>
<a name="ln962">//	#pragma mark -</a>
<a name="ln963"> </a>
<a name="ln964"> </a>
<a name="ln965">net_protocol*</a>
<a name="ln966">ipv6_init_protocol(net_socket* socket)</a>
<a name="ln967">{</a>
<a name="ln968">	ipv6_protocol* protocol = new (std::nothrow) ipv6_protocol();</a>
<a name="ln969">	if (protocol == NULL)</a>
<a name="ln970">		return NULL;</a>
<a name="ln971"> </a>
<a name="ln972">	protocol-&gt;raw = NULL;</a>
<a name="ln973">	protocol-&gt;service_type = 0;</a>
<a name="ln974">	protocol-&gt;time_to_live = kDefaultTTL;</a>
<a name="ln975">	protocol-&gt;multicast_time_to_live = kDefaultMulticastTTL;</a>
<a name="ln976">	protocol-&gt;receive_hoplimit = 0;</a>
<a name="ln977">	protocol-&gt;receive_pktinfo = 0;</a>
<a name="ln978">	protocol-&gt;multicast_address = NULL;</a>
<a name="ln979">	return protocol;</a>
<a name="ln980">}</a>
<a name="ln981"> </a>
<a name="ln982"> </a>
<a name="ln983">status_t</a>
<a name="ln984">ipv6_uninit_protocol(net_protocol* _protocol)</a>
<a name="ln985">{</a>
<a name="ln986">	ipv6_protocol* protocol = (ipv6_protocol*)_protocol;</a>
<a name="ln987"> </a>
<a name="ln988">	delete protocol;</a>
<a name="ln989">	return B_OK;</a>
<a name="ln990">}</a>
<a name="ln991"> </a>
<a name="ln992"> </a>
<a name="ln993">/*!	Since open() is only called on the top level protocol, when we get here</a>
<a name="ln994">	it means we are on a SOCK_RAW socket.</a>
<a name="ln995">*/</a>
<a name="ln996">status_t</a>
<a name="ln997">ipv6_open(net_protocol* _protocol)</a>
<a name="ln998">{</a>
<a name="ln999">	ipv6_protocol* protocol = (ipv6_protocol*)_protocol;</a>
<a name="ln1000"> </a>
<a name="ln1001">	RawSocket* raw = new (std::nothrow) RawSocket(protocol-&gt;socket);</a>
<a name="ln1002">	if (raw == NULL)</a>
<a name="ln1003">		return B_NO_MEMORY;</a>
<a name="ln1004"> </a>
<a name="ln1005">	status_t status = raw-&gt;InitCheck();</a>
<a name="ln1006">	if (status != B_OK) {</a>
<a name="ln1007">		delete raw;</a>
<a name="ln1008">		return status;</a>
<a name="ln1009">	}</a>
<a name="ln1010"> </a>
<a name="ln1011">	TRACE_SK(protocol, &quot;Open()&quot;);</a>
<a name="ln1012"> </a>
<a name="ln1013">	protocol-&gt;raw = raw;</a>
<a name="ln1014"> </a>
<a name="ln1015">	MutexLocker locker(sRawSocketsLock);</a>
<a name="ln1016">	sRawSockets.Add(raw);</a>
<a name="ln1017">	return B_OK;</a>
<a name="ln1018">}</a>
<a name="ln1019"> </a>
<a name="ln1020"> </a>
<a name="ln1021">status_t</a>
<a name="ln1022">ipv6_close(net_protocol* _protocol)</a>
<a name="ln1023">{</a>
<a name="ln1024">	ipv6_protocol* protocol = (ipv6_protocol*)_protocol;</a>
<a name="ln1025">	RawSocket* raw = protocol-&gt;raw;</a>
<a name="ln1026">	if (raw == NULL)</a>
<a name="ln1027">		return B_ERROR;</a>
<a name="ln1028"> </a>
<a name="ln1029">	TRACE_SK(protocol, &quot;Close()&quot;);</a>
<a name="ln1030"> </a>
<a name="ln1031">	MutexLocker locker(sRawSocketsLock);</a>
<a name="ln1032">	sRawSockets.Remove(raw);</a>
<a name="ln1033">	delete raw;</a>
<a name="ln1034">	protocol-&gt;raw = NULL;</a>
<a name="ln1035"> </a>
<a name="ln1036">	return B_OK;</a>
<a name="ln1037">}</a>
<a name="ln1038"> </a>
<a name="ln1039"> </a>
<a name="ln1040">status_t</a>
<a name="ln1041">ipv6_free(net_protocol* protocol)</a>
<a name="ln1042">{</a>
<a name="ln1043">	return B_OK;</a>
<a name="ln1044">}</a>
<a name="ln1045"> </a>
<a name="ln1046"> </a>
<a name="ln1047">status_t</a>
<a name="ln1048">ipv6_connect(net_protocol* protocol, const struct sockaddr* address)</a>
<a name="ln1049">{</a>
<a name="ln1050">	return B_ERROR;</a>
<a name="ln1051">}</a>
<a name="ln1052"> </a>
<a name="ln1053"> </a>
<a name="ln1054">status_t</a>
<a name="ln1055">ipv6_accept(net_protocol* protocol, struct net_socket** _acceptedSocket)</a>
<a name="ln1056">{</a>
<a name="ln1057">	return EOPNOTSUPP;</a>
<a name="ln1058">}</a>
<a name="ln1059"> </a>
<a name="ln1060"> </a>
<a name="ln1061">status_t</a>
<a name="ln1062">ipv6_control(net_protocol* _protocol, int level, int option, void* value,</a>
<a name="ln1063">	size_t* _length)</a>
<a name="ln1064">{</a>
<a name="ln1065">	if ((level &amp; LEVEL_MASK) != IPPROTO_IPV6)</a>
<a name="ln1066">		return sDatalinkModule-&gt;control(sDomain, option, value, _length);</a>
<a name="ln1067"> </a>
<a name="ln1068">	return B_BAD_VALUE;</a>
<a name="ln1069">}</a>
<a name="ln1070"> </a>
<a name="ln1071"> </a>
<a name="ln1072">status_t</a>
<a name="ln1073">ipv6_getsockopt(net_protocol* _protocol, int level, int option, void* value,</a>
<a name="ln1074">	int* _length)</a>
<a name="ln1075">{</a>
<a name="ln1076">	ipv6_protocol* protocol = (ipv6_protocol*)_protocol;</a>
<a name="ln1077"> </a>
<a name="ln1078">	if (level == IPPROTO_IPV6) {</a>
<a name="ln1079">		// TODO: support more of these options</a>
<a name="ln1080"> </a>
<a name="ln1081">		if (option == IPV6_MULTICAST_HOPS) {</a>
<a name="ln1082">			return get_int_option(value, *_length,</a>
<a name="ln1083">				protocol-&gt;multicast_time_to_live);</a>
<a name="ln1084">		}</a>
<a name="ln1085">		if (option == IPV6_MULTICAST_LOOP)</a>
<a name="ln1086">			return EOPNOTSUPP;</a>
<a name="ln1087">		if (option == IPV6_UNICAST_HOPS)</a>
<a name="ln1088">			return get_int_option(value, *_length, protocol-&gt;time_to_live);</a>
<a name="ln1089">		if (option == IPV6_V6ONLY)</a>
<a name="ln1090">			return EOPNOTSUPP;</a>
<a name="ln1091">		if (option == IPV6_RECVPKTINFO)</a>
<a name="ln1092">			return get_int_option(value, *_length, protocol-&gt;receive_pktinfo);</a>
<a name="ln1093">		if (option == IPV6_RECVHOPLIMIT)</a>
<a name="ln1094">			return get_int_option(value, *_length, protocol-&gt;receive_hoplimit);</a>
<a name="ln1095">		if (option == IPV6_JOIN_GROUP</a>
<a name="ln1096">			|| option == IPV6_LEAVE_GROUP)</a>
<a name="ln1097">			return EOPNOTSUPP;</a>
<a name="ln1098"> </a>
<a name="ln1099">		dprintf(&quot;IPv6::getsockopt(): get unknown option: %d\n&quot;, option);</a>
<a name="ln1100">		return ENOPROTOOPT;</a>
<a name="ln1101">	}</a>
<a name="ln1102"> </a>
<a name="ln1103">	return sSocketModule-&gt;get_option(protocol-&gt;socket, level, option, value,</a>
<a name="ln1104">		_length);</a>
<a name="ln1105">}</a>
<a name="ln1106"> </a>
<a name="ln1107"> </a>
<a name="ln1108">status_t</a>
<a name="ln1109">ipv6_setsockopt(net_protocol* _protocol, int level, int option,</a>
<a name="ln1110">	const void* value, int length)</a>
<a name="ln1111">{</a>
<a name="ln1112">	ipv6_protocol* protocol = (ipv6_protocol*)_protocol;</a>
<a name="ln1113"> </a>
<a name="ln1114">	if (level == IPPROTO_IPV6) {</a>
<a name="ln1115">		// TODO: support more of these options</a>
<a name="ln1116"> </a>
<a name="ln1117">		if (option == IPV6_MULTICAST_IF) {</a>
<a name="ln1118">			if (length != sizeof(struct in6_addr))</a>
<a name="ln1119">				return B_BAD_VALUE;</a>
<a name="ln1120"> </a>
<a name="ln1121">			struct sockaddr_in6* address = new (std::nothrow) sockaddr_in6;</a>
<a name="ln1122">			if (address == NULL)</a>
<a name="ln1123">				return B_NO_MEMORY;</a>
<a name="ln1124"> </a>
<a name="ln1125">			if (user_memcpy(&amp;address-&gt;sin6_addr, value, sizeof(in6_addr))</a>
<a name="ln1126">					!= B_OK) {</a>
<a name="ln1127">				delete address;</a>
<a name="ln1128">				return B_BAD_ADDRESS;</a>
<a name="ln1129">			}</a>
<a name="ln1130"> </a>
<a name="ln1131">			// Using the unspecifed address to remove the previous setting.</a>
<a name="ln1132">			if (IN6_IS_ADDR_UNSPECIFIED(&amp;address-&gt;sin6_addr)) {</a>
<a name="ln1133">				delete address;</a>
<a name="ln1134">				delete protocol-&gt;multicast_address;</a>
<a name="ln1135">				protocol-&gt;multicast_address = NULL;</a>
<a name="ln1136">				return B_OK;</a>
<a name="ln1137">			}</a>
<a name="ln1138"> </a>
<a name="ln1139">			struct net_interface* interface</a>
<a name="ln1140">				= sDatalinkModule-&gt;get_interface_with_address(</a>
<a name="ln1141">					(sockaddr*)address);</a>
<a name="ln1142">			if (interface == NULL) {</a>
<a name="ln1143">				delete address;</a>
<a name="ln1144">				return EADDRNOTAVAIL;</a>
<a name="ln1145">			}</a>
<a name="ln1146"> </a>
<a name="ln1147">			delete protocol-&gt;multicast_address;</a>
<a name="ln1148">			protocol-&gt;multicast_address = (struct sockaddr*)address;</a>
<a name="ln1149"> </a>
<a name="ln1150">			sDatalinkModule-&gt;put_interface(interface);</a>
<a name="ln1151">			return B_OK;</a>
<a name="ln1152">		}</a>
<a name="ln1153">		if (option == IPV6_MULTICAST_HOPS) {</a>
<a name="ln1154">			return set_int_option(protocol-&gt;multicast_time_to_live,</a>
<a name="ln1155">				value, length);</a>
<a name="ln1156">		}</a>
<a name="ln1157">		if (option == IPV6_MULTICAST_LOOP)</a>
<a name="ln1158">			return EOPNOTSUPP;</a>
<a name="ln1159">		if (option == IPV6_UNICAST_HOPS)</a>
<a name="ln1160">			return set_int_option(protocol-&gt;time_to_live, value, length);</a>
<a name="ln1161">		if (option == IPV6_V6ONLY)</a>
<a name="ln1162">			return EOPNOTSUPP;</a>
<a name="ln1163">		if (option == IPV6_RECVPKTINFO)</a>
<a name="ln1164">			return set_int_option(protocol-&gt;receive_pktinfo, value, length);</a>
<a name="ln1165">		if (option == IPV6_RECVHOPLIMIT)</a>
<a name="ln1166">			return set_int_option(protocol-&gt;receive_hoplimit, value, length);</a>
<a name="ln1167">		if (option == IPV6_JOIN_GROUP || option == IPV6_LEAVE_GROUP) {</a>
<a name="ln1168">			ipv6_mreq mreq;</a>
<a name="ln1169">			if (length != sizeof(ipv6_mreq))</a>
<a name="ln1170">				return B_BAD_VALUE;</a>
<a name="ln1171">			if (user_memcpy(&amp;mreq, value, sizeof(ipv6_mreq)) != B_OK)</a>
<a name="ln1172">				return B_BAD_ADDRESS;</a>
<a name="ln1173"> </a>
<a name="ln1174">			return ipv6_delta_membership(protocol, option,</a>
<a name="ln1175">				mreq.ipv6mr_interface, &amp;mreq.ipv6mr_multiaddr, NULL);</a>
<a name="ln1176">		}</a>
<a name="ln1177"> </a>
<a name="ln1178">		dprintf(&quot;IPv6::setsockopt(): set unknown option: %d\n&quot;, option);</a>
<a name="ln1179">		return ENOPROTOOPT;</a>
<a name="ln1180">	}</a>
<a name="ln1181"> </a>
<a name="ln1182">	return sSocketModule-&gt;set_option(protocol-&gt;socket, level, option,</a>
<a name="ln1183">		value, length);</a>
<a name="ln1184">}</a>
<a name="ln1185"> </a>
<a name="ln1186"> </a>
<a name="ln1187">status_t</a>
<a name="ln1188">ipv6_bind(net_protocol* protocol, const sockaddr* _address)</a>
<a name="ln1189">{</a>
<a name="ln1190">	if (_address-&gt;sa_family != AF_INET6)</a>
<a name="ln1191">		return EAFNOSUPPORT;</a>
<a name="ln1192"> </a>
<a name="ln1193">	const sockaddr_in6* address = (const sockaddr_in6*)_address;</a>
<a name="ln1194"> </a>
<a name="ln1195">	// only INADDR_ANY and addresses of local interfaces are accepted:</a>
<a name="ln1196">	if (IN6_IS_ADDR_UNSPECIFIED(&amp;address-&gt;sin6_addr)</a>
<a name="ln1197">		|| IN6_IS_ADDR_MULTICAST(&amp;address-&gt;sin6_addr)</a>
<a name="ln1198">		|| sDatalinkModule-&gt;is_local_address(sDomain, _address, NULL, NULL)) {</a>
<a name="ln1199">		memcpy(&amp;protocol-&gt;socket-&gt;address, address, sizeof(sockaddr_in6));</a>
<a name="ln1200">		protocol-&gt;socket-&gt;address.ss_len = sizeof(sockaddr_in6);</a>
<a name="ln1201">			// explicitly set length, as our callers can't be trusted to</a>
<a name="ln1202">			// always provide the correct length!</a>
<a name="ln1203">		return B_OK;</a>
<a name="ln1204">	}</a>
<a name="ln1205"> </a>
<a name="ln1206">	return B_ERROR;</a>
<a name="ln1207">		// address is unknown on this host</a>
<a name="ln1208">}</a>
<a name="ln1209"> </a>
<a name="ln1210"> </a>
<a name="ln1211">status_t</a>
<a name="ln1212">ipv6_unbind(net_protocol* protocol, struct sockaddr* address)</a>
<a name="ln1213">{</a>
<a name="ln1214">	// nothing to do here</a>
<a name="ln1215">	return B_OK;</a>
<a name="ln1216">}</a>
<a name="ln1217"> </a>
<a name="ln1218"> </a>
<a name="ln1219">status_t</a>
<a name="ln1220">ipv6_listen(net_protocol* protocol, int count)</a>
<a name="ln1221">{</a>
<a name="ln1222">	return EOPNOTSUPP;</a>
<a name="ln1223">}</a>
<a name="ln1224"> </a>
<a name="ln1225"> </a>
<a name="ln1226">status_t</a>
<a name="ln1227">ipv6_shutdown(net_protocol* protocol, int direction)</a>
<a name="ln1228">{</a>
<a name="ln1229">	return EOPNOTSUPP;</a>
<a name="ln1230">}</a>
<a name="ln1231"> </a>
<a name="ln1232"> </a>
<a name="ln1233">static uint8</a>
<a name="ln1234">ip6_select_hoplimit(net_protocol* _protocol, net_buffer* buffer)</a>
<a name="ln1235">{</a>
<a name="ln1236">	// TODO: the precedence should be as follows:</a>
<a name="ln1237">	// 1. Hoplimit value specified via ioctl.</a>
<a name="ln1238">	// 2. (If the outgoing interface is detected) the current</a>
<a name="ln1239">	//     hop limit of the interface specified by router advertisement.</a>
<a name="ln1240">	// 3. The system default hoplimit.</a>
<a name="ln1241"> </a>
<a name="ln1242">	ipv6_protocol* protocol = (ipv6_protocol*)_protocol;</a>
<a name="ln1243">	const bool isMulticast = buffer-&gt;flags &amp; MSG_MCAST;</a>
<a name="ln1244"> </a>
<a name="ln1245">	if (protocol) {</a>
<a name="ln1246">		return isMulticast ? protocol-&gt;multicast_time_to_live</a>
<a name="ln1247">			: protocol-&gt;time_to_live;</a>
<a name="ln1248">	}</a>
<a name="ln1249">	return isMulticast ? kDefaultMulticastTTL : kDefaultTTL;</a>
<a name="ln1250">}</a>
<a name="ln1251"> </a>
<a name="ln1252"> </a>
<a name="ln1253">status_t</a>
<a name="ln1254">ipv6_send_routed_data(net_protocol* _protocol, struct net_route* route,</a>
<a name="ln1255">	net_buffer* buffer)</a>
<a name="ln1256">{</a>
<a name="ln1257">	if (route == NULL)</a>
<a name="ln1258">		return B_BAD_VALUE;</a>
<a name="ln1259"> </a>
<a name="ln1260">	ipv6_protocol* protocol = (ipv6_protocol*)_protocol;</a>
<a name="ln1261">	net_interface* interface = route-&gt;interface_address-&gt;interface;</a>
<a name="ln1262">	uint8 protocolNumber;</a>
<a name="ln1263">	if (protocol != NULL &amp;&amp; protocol-&gt;socket != NULL)</a>
<a name="ln1264">		protocolNumber = protocol-&gt;socket-&gt;protocol;</a>
<a name="ln1265">	else</a>
<a name="ln1266">		protocolNumber = buffer-&gt;protocol;</a>
<a name="ln1267"> </a>
<a name="ln1268">	TRACE_SK(protocol, &quot;SendRoutedData(%p, %p [%&quot; B_PRIu32 &quot; bytes])&quot;, route,</a>
<a name="ln1269">		buffer, buffer-&gt;size);</a>
<a name="ln1270"> </a>
<a name="ln1271">	sockaddr_in6&amp; source = *(sockaddr_in6*)buffer-&gt;source;</a>
<a name="ln1272">	sockaddr_in6&amp; destination = *(sockaddr_in6*)buffer-&gt;destination;</a>
<a name="ln1273"> </a>
<a name="ln1274">	buffer-&gt;flags &amp;= ~(MSG_BCAST | MSG_MCAST);</a>
<a name="ln1275"> </a>
<a name="ln1276">	if (IN6_IS_ADDR_UNSPECIFIED(&amp;destination.sin6_addr))</a>
<a name="ln1277">		return EDESTADDRREQ;</a>
<a name="ln1278"> </a>
<a name="ln1279">	if (IN6_IS_ADDR_MULTICAST(&amp;destination.sin6_addr))</a>
<a name="ln1280">		buffer-&gt;flags |= MSG_MCAST;</a>
<a name="ln1281"> </a>
<a name="ln1282">	uint16 dataLength = buffer-&gt;size;</a>
<a name="ln1283"> </a>
<a name="ln1284">	// Add IPv6 header</a>
<a name="ln1285"> </a>
<a name="ln1286">	NetBufferPrepend&lt;ip6_hdr&gt; header(buffer);</a>
<a name="ln1287">	if (header.Status() != B_OK)</a>
<a name="ln1288">		return header.Status();</a>
<a name="ln1289"> </a>
<a name="ln1290">	if (buffer-&gt;size &gt; 0xffff)</a>
<a name="ln1291">		return EMSGSIZE;</a>
<a name="ln1292"> </a>
<a name="ln1293">	uint32 flowinfo = 0;</a>
<a name="ln1294">		// TODO: fill in the flow id from somewhere</a>
<a name="ln1295">	if (protocol) {</a>
<a name="ln1296">		// fill in traffic class</a>
<a name="ln1297">		flowinfo |= htonl(protocol-&gt;service_type &lt;&lt; 20);</a>
<a name="ln1298">	}</a>
<a name="ln1299">	// set lower 28 bits</a>
<a name="ln1300">	header-&gt;ip6_flow = htonl(flowinfo) &amp; IPV6_FLOWINFO_MASK;</a>
<a name="ln1301">	// set upper 4 bits</a>
<a name="ln1302">	header-&gt;ip6_vfc |= IPV6_VERSION;</a>
<a name="ln1303">	header-&gt;ip6_plen = htons(dataLength);</a>
<a name="ln1304">	header-&gt;ip6_nxt = protocolNumber;</a>
<a name="ln1305">	header-&gt;ip6_hlim = ip6_select_hoplimit(protocol, buffer);</a>
<a name="ln1306">	memcpy(&amp;header-&gt;ip6_src, &amp;source.sin6_addr, sizeof(in6_addr));</a>
<a name="ln1307">	memcpy(&amp;header-&gt;ip6_dst, &amp;destination.sin6_addr, sizeof(in6_addr));</a>
<a name="ln1308"> </a>
<a name="ln1309">	header.Sync();</a>
<a name="ln1310"> </a>
<a name="ln1311">	// write the checksum for ICMPv6 sockets</a>
<a name="ln1312">	if (protocolNumber == IPPROTO_ICMPV6</a>
<a name="ln1313">		&amp;&amp; dataLength &gt;= sizeof(struct icmp6_hdr)) {</a>
<a name="ln1314">		NetBufferField&lt;uint16, sizeof(ip6_hdr)</a>
<a name="ln1315">			+ offsetof(icmp6_hdr, icmp6_cksum)&gt;</a>
<a name="ln1316">			icmpChecksum(buffer);</a>
<a name="ln1317">		// first make sure the existing checksum is zero</a>
<a name="ln1318">		*icmpChecksum = 0;</a>
<a name="ln1319">		icmpChecksum.Sync();</a>
<a name="ln1320"> </a>
<a name="ln1321">		uint16 checksum = gBufferModule-&gt;checksum(buffer, sizeof(ip6_hdr),</a>
<a name="ln1322">			buffer-&gt;size - sizeof(ip6_hdr), false);</a>
<a name="ln1323">		checksum = ipv6_checksum(&amp;header-&gt;ip6_src,</a>
<a name="ln1324">			&amp;header-&gt;ip6_dst, dataLength, protocolNumber,</a>
<a name="ln1325">			checksum);</a>
<a name="ln1326">		*icmpChecksum = checksum;</a>
<a name="ln1327">	}</a>
<a name="ln1328"> </a>
<a name="ln1329">	char addrbuf[INET6_ADDRSTRLEN];</a>
<a name="ln1330">	ip6_sprintf(&amp;destination.sin6_addr, addrbuf);</a>
<a name="ln1331">	TRACE_SK(protocol, &quot;  SendRoutedData(): destination: %s&quot;, addrbuf);</a>
<a name="ln1332"> </a>
<a name="ln1333">	uint32 mtu = route-&gt;mtu ? route-&gt;mtu : interface-&gt;mtu;</a>
<a name="ln1334">	if (buffer-&gt;size &gt; mtu) {</a>
<a name="ln1335">		// we need to fragment the packet</a>
<a name="ln1336">		return send_fragments(protocol, route, buffer, mtu);</a>
<a name="ln1337">	}</a>
<a name="ln1338"> </a>
<a name="ln1339">	return sDatalinkModule-&gt;send_routed_data(route, buffer);</a>
<a name="ln1340">}</a>
<a name="ln1341"> </a>
<a name="ln1342"> </a>
<a name="ln1343">status_t</a>
<a name="ln1344">ipv6_send_data(net_protocol* _protocol, net_buffer* buffer)</a>
<a name="ln1345">{</a>
<a name="ln1346">	ipv6_protocol* protocol = (ipv6_protocol*)_protocol;</a>
<a name="ln1347"> </a>
<a name="ln1348">	TRACE_SK(protocol, &quot;SendData(%p [%&quot; B_PRIu32 &quot; bytes])&quot;, buffer,</a>
<a name="ln1349">		buffer-&gt;size);</a>
<a name="ln1350"> </a>
<a name="ln1351">	sockaddr_in6* destination = (sockaddr_in6*)buffer-&gt;destination;</a>
<a name="ln1352"> </a>
<a name="ln1353">	// handle IPV6_MULTICAST_IF</a>
<a name="ln1354">	if (IN6_IS_ADDR_MULTICAST(&amp;destination-&gt;sin6_addr)</a>
<a name="ln1355">		&amp;&amp; protocol-&gt;multicast_address != NULL) {</a>
<a name="ln1356">		net_interface_address* address = sDatalinkModule-&gt;get_interface_address(</a>
<a name="ln1357">			protocol-&gt;multicast_address);</a>
<a name="ln1358">		if (address == NULL || (address-&gt;interface-&gt;flags &amp; IFF_UP) == 0) {</a>
<a name="ln1359">			sDatalinkModule-&gt;put_interface_address(address);</a>
<a name="ln1360">			return EADDRNOTAVAIL;</a>
<a name="ln1361">		}</a>
<a name="ln1362"> </a>
<a name="ln1363">		sDatalinkModule-&gt;put_interface_address(buffer-&gt;interface_address);</a>
<a name="ln1364">		buffer-&gt;interface_address = address;</a>
<a name="ln1365">			// the buffer takes over ownership of the address</a>
<a name="ln1366"> </a>
<a name="ln1367">		net_route* route = sDatalinkModule-&gt;get_route(sDomain, address-&gt;local);</a>
<a name="ln1368">		if (route == NULL)</a>
<a name="ln1369">			return ENETUNREACH;</a>
<a name="ln1370"> </a>
<a name="ln1371">		return sDatalinkModule-&gt;send_routed_data(route, buffer);</a>
<a name="ln1372">	}</a>
<a name="ln1373"> </a>
<a name="ln1374">	return sDatalinkModule-&gt;send_data(protocol, sDomain, buffer);</a>
<a name="ln1375">}</a>
<a name="ln1376"> </a>
<a name="ln1377"> </a>
<a name="ln1378">ssize_t</a>
<a name="ln1379">ipv6_send_avail(net_protocol* protocol)</a>
<a name="ln1380">{</a>
<a name="ln1381">	return B_ERROR;</a>
<a name="ln1382">}</a>
<a name="ln1383"> </a>
<a name="ln1384"> </a>
<a name="ln1385">status_t</a>
<a name="ln1386">ipv6_read_data(net_protocol* _protocol, size_t numBytes, uint32 flags,</a>
<a name="ln1387">	net_buffer** _buffer)</a>
<a name="ln1388">{</a>
<a name="ln1389">	ipv6_protocol* protocol = (ipv6_protocol*)_protocol;</a>
<a name="ln1390">	RawSocket* raw = protocol-&gt;raw;</a>
<a name="ln1391">	if (raw == NULL)</a>
<a name="ln1392">		return B_ERROR;</a>
<a name="ln1393"> </a>
<a name="ln1394">	TRACE_SK(protocol, &quot;ReadData(%&quot; B_PRIuSIZE &quot;, 0x%&quot; B_PRIu32 &quot;)&quot;, numBytes,</a>
<a name="ln1395">		flags);</a>
<a name="ln1396"> </a>
<a name="ln1397">	return raw-&gt;Dequeue(flags, _buffer);</a>
<a name="ln1398">}</a>
<a name="ln1399"> </a>
<a name="ln1400"> </a>
<a name="ln1401">ssize_t</a>
<a name="ln1402">ipv6_read_avail(net_protocol* _protocol)</a>
<a name="ln1403">{</a>
<a name="ln1404">	ipv6_protocol* protocol = (ipv6_protocol*)_protocol;</a>
<a name="ln1405">	RawSocket* raw = protocol-&gt;raw;</a>
<a name="ln1406">	if (raw == NULL)</a>
<a name="ln1407">		return B_ERROR;</a>
<a name="ln1408"> </a>
<a name="ln1409">	return raw-&gt;AvailableData();</a>
<a name="ln1410">}</a>
<a name="ln1411"> </a>
<a name="ln1412"> </a>
<a name="ln1413">struct net_domain*</a>
<a name="ln1414">ipv6_get_domain(net_protocol* protocol)</a>
<a name="ln1415">{</a>
<a name="ln1416">	return sDomain;</a>
<a name="ln1417">}</a>
<a name="ln1418"> </a>
<a name="ln1419"> </a>
<a name="ln1420">size_t</a>
<a name="ln1421">ipv6_get_mtu(net_protocol* protocol, const struct sockaddr* address)</a>
<a name="ln1422">{</a>
<a name="ln1423">	net_route* route = sDatalinkModule-&gt;get_route(sDomain, address);</a>
<a name="ln1424">	if (route == NULL)</a>
<a name="ln1425">		return 0;</a>
<a name="ln1426"> </a>
<a name="ln1427">	size_t mtu;</a>
<a name="ln1428">	if (route-&gt;mtu != 0)</a>
<a name="ln1429">		mtu = route-&gt;mtu;</a>
<a name="ln1430">	else</a>
<a name="ln1431">		mtu = route-&gt;interface_address-&gt;interface-&gt;mtu;</a>
<a name="ln1432"> </a>
<a name="ln1433">	sDatalinkModule-&gt;put_route(sDomain, route);</a>
<a name="ln1434">	// TODO: what about extension headers?</a>
<a name="ln1435">	// this function probably shoud be changed in calling places, not here</a>
<a name="ln1436">	return mtu - sizeof(ip6_hdr);</a>
<a name="ln1437">}</a>
<a name="ln1438"> </a>
<a name="ln1439"> </a>
<a name="ln1440">status_t</a>
<a name="ln1441">ipv6_receive_data(net_buffer* buffer)</a>
<a name="ln1442">{</a>
<a name="ln1443">	TRACE(&quot;ReceiveData(%p [%&quot; B_PRIu32 &quot; bytes])&quot;, buffer, buffer-&gt;size);</a>
<a name="ln1444"> </a>
<a name="ln1445">	NetBufferHeaderReader&lt;IPv6Header&gt; bufferHeader(buffer);</a>
<a name="ln1446">	if (bufferHeader.Status() != B_OK)</a>
<a name="ln1447">		return bufferHeader.Status();</a>
<a name="ln1448"> </a>
<a name="ln1449">	IPv6Header &amp;header = bufferHeader.Data();</a>
<a name="ln1450">	// dump_ipv6_header(header);</a>
<a name="ln1451"> </a>
<a name="ln1452">	if (header.ProtocolVersion() != IPV6_VERSION)</a>
<a name="ln1453">		return B_BAD_TYPE;</a>
<a name="ln1454"> </a>
<a name="ln1455">	uint16 packetLength = header.PayloadLength() + sizeof(ip6_hdr);</a>
<a name="ln1456">	if (packetLength &gt; buffer-&gt;size)</a>
<a name="ln1457">		return B_BAD_DATA;</a>
<a name="ln1458"> </a>
<a name="ln1459">	// lower layers notion of Broadcast or Multicast have no relevance to us</a>
<a name="ln1460">	buffer-&gt;flags &amp;= ~(MSG_BCAST | MSG_MCAST);</a>
<a name="ln1461"> </a>
<a name="ln1462">	sockaddr_in6 destination;</a>
<a name="ln1463">	fill_sockaddr_in6(&amp;destination, header.Dst());</a>
<a name="ln1464"> </a>
<a name="ln1465">	if (IN6_IS_ADDR_MULTICAST(&amp;destination.sin6_addr)) {</a>
<a name="ln1466">		buffer-&gt;flags |= MSG_MCAST;</a>
<a name="ln1467">	} else {</a>
<a name="ln1468">		uint32 matchedAddressType = 0;</a>
<a name="ln1469"> </a>
<a name="ln1470">		// test if the packet is really for us</a>
<a name="ln1471">		if (!sDatalinkModule-&gt;is_local_address(sDomain, (sockaddr*)&amp;destination,</a>
<a name="ln1472">				&amp;buffer-&gt;interface_address, &amp;matchedAddressType)</a>
<a name="ln1473">			&amp;&amp; !sDatalinkModule-&gt;is_local_link_address(sDomain, true,</a>
<a name="ln1474">				buffer-&gt;destination, &amp;buffer-&gt;interface_address)) {</a>
<a name="ln1475"> </a>
<a name="ln1476">			char srcbuf[INET6_ADDRSTRLEN];</a>
<a name="ln1477">			char dstbuf[INET6_ADDRSTRLEN];</a>
<a name="ln1478">			ip6_sprintf(&amp;header.Src(), srcbuf);</a>
<a name="ln1479">			ip6_sprintf(&amp;header.Dst(), dstbuf);</a>
<a name="ln1480">			TRACE(&quot;  ipv6_receive_data(): packet was not for us %s -&gt; %s&quot;,</a>
<a name="ln1481">				srcbuf, dstbuf);</a>
<a name="ln1482"> </a>
<a name="ln1483">			// TODO: Send ICMPv6 error: Host unreachable</a>
<a name="ln1484">			return B_ERROR;</a>
<a name="ln1485">		}</a>
<a name="ln1486"> </a>
<a name="ln1487">		// copy over special address types (MSG_BCAST or MSG_MCAST):</a>
<a name="ln1488">		buffer-&gt;flags |= matchedAddressType;</a>
<a name="ln1489">	}</a>
<a name="ln1490"> </a>
<a name="ln1491">	// set net_buffer's source/destination address</a>
<a name="ln1492">	fill_sockaddr_in6((struct sockaddr_in6*)buffer-&gt;source, header.Src());</a>
<a name="ln1493">	memcpy(buffer-&gt;destination, &amp;destination, sizeof(sockaddr_in6));</a>
<a name="ln1494"> </a>
<a name="ln1495">	// get the transport protocol and transport header offset</a>
<a name="ln1496">	uint16 transportHeaderOffset = header.GetHeaderOffset(buffer);</a>
<a name="ln1497">	uint8 protocol = buffer-&gt;protocol;</a>
<a name="ln1498"> </a>
<a name="ln1499">	// remove any trailing/padding data</a>
<a name="ln1500">	status_t status = gBufferModule-&gt;trim(buffer, packetLength);</a>
<a name="ln1501">	if (status != B_OK)</a>
<a name="ln1502">		return status;</a>
<a name="ln1503"> </a>
<a name="ln1504">	// check for fragmentation</a>
<a name="ln1505">	uint16 fragmentHeaderOffset</a>
<a name="ln1506">		= header.GetHeaderOffset(buffer, IPPROTO_FRAGMENT);</a>
<a name="ln1507"> </a>
<a name="ln1508">	if (fragmentHeaderOffset != 0) {</a>
<a name="ln1509">		// this is a fragment</a>
<a name="ln1510">		TRACE(&quot;  ipv6_receive_data(): Found a Fragment!&quot;);</a>
<a name="ln1511">		status = reassemble_fragments(header, &amp;buffer, fragmentHeaderOffset);</a>
<a name="ln1512">		TRACE(&quot;  ipv6_receive_data():  -&gt; %s&quot;, strerror(status));</a>
<a name="ln1513">		if (status != B_OK)</a>
<a name="ln1514">			return status;</a>
<a name="ln1515"> </a>
<a name="ln1516">		if (buffer == NULL) {</a>
<a name="ln1517">			// buffer was put into fragment packet</a>
<a name="ln1518">			TRACE(&quot;  ipv6_receive_data(): Not yet assembled.&quot;);</a>
<a name="ln1519">			return B_OK;</a>
<a name="ln1520">		}</a>
<a name="ln1521">	}</a>
<a name="ln1522"> </a>
<a name="ln1523">	// tell the buffer to preserve removed ipv6 header - may need it later</a>
<a name="ln1524">	gBufferModule-&gt;store_header(buffer);</a>
<a name="ln1525"> </a>
<a name="ln1526">	// remove ipv6 headers for now</a>
<a name="ln1527">	gBufferModule-&gt;remove_header(buffer, transportHeaderOffset);</a>
<a name="ln1528"> </a>
<a name="ln1529">	// deliver the data to raw sockets</a>
<a name="ln1530">	raw_receive_data(buffer);</a>
<a name="ln1531"> </a>
<a name="ln1532">	net_protocol_module_info* module = receiving_protocol(protocol);</a>
<a name="ln1533">	if (module == NULL) {</a>
<a name="ln1534">		// no handler for this packet</a>
<a name="ln1535">		return EAFNOSUPPORT;</a>
<a name="ln1536">	}</a>
<a name="ln1537"> </a>
<a name="ln1538">	if ((buffer-&gt;flags &amp; MSG_MCAST) != 0) {</a>
<a name="ln1539">		// Unfortunately historical reasons dictate that the IP multicast</a>
<a name="ln1540">		// model be a little different from the unicast one. We deliver</a>
<a name="ln1541">		// this frame directly to all sockets registered with interest</a>
<a name="ln1542">		// for this multicast group.</a>
<a name="ln1543">		return deliver_multicast(module, buffer, false);</a>
<a name="ln1544">	}</a>
<a name="ln1545"> </a>
<a name="ln1546">	return module-&gt;receive_data(buffer);</a>
<a name="ln1547">}</a>
<a name="ln1548"> </a>
<a name="ln1549"> </a>
<a name="ln1550">status_t</a>
<a name="ln1551">ipv6_deliver_data(net_protocol* _protocol, net_buffer* buffer)</a>
<a name="ln1552">{</a>
<a name="ln1553">	ipv6_protocol* protocol = (ipv6_protocol*)_protocol;</a>
<a name="ln1554"> </a>
<a name="ln1555">	if (protocol-&gt;raw == NULL)</a>
<a name="ln1556">		return B_ERROR;</a>
<a name="ln1557"> </a>
<a name="ln1558">	return protocol-&gt;raw-&gt;EnqueueClone(buffer);</a>
<a name="ln1559">}</a>
<a name="ln1560"> </a>
<a name="ln1561"> </a>
<a name="ln1562">status_t</a>
<a name="ln1563">ipv6_error_received(net_error error, net_buffer* data)</a>
<a name="ln1564">{</a>
<a name="ln1565">	return B_ERROR;</a>
<a name="ln1566">}</a>
<a name="ln1567"> </a>
<a name="ln1568"> </a>
<a name="ln1569">status_t</a>
<a name="ln1570">ipv6_error_reply(net_protocol* protocol, net_buffer* cause, net_error error,</a>
<a name="ln1571">	net_error_data* errorData)</a>
<a name="ln1572">{</a>
<a name="ln1573">	return B_ERROR;</a>
<a name="ln1574">}</a>
<a name="ln1575"> </a>
<a name="ln1576"> </a>
<a name="ln1577">ssize_t</a>
<a name="ln1578">ipv6_process_ancillary_data_no_container(net_protocol* _protocol,</a>
<a name="ln1579">	net_buffer* buffer, void* msgControl, size_t msgControlLen)</a>
<a name="ln1580">{</a>
<a name="ln1581">	ipv6_protocol* protocol = (ipv6_protocol*)_protocol;</a>
<a name="ln1582">	ssize_t bytesWritten = 0;</a>
<a name="ln1583"> </a>
<a name="ln1584">	if (protocol-&gt;receive_hoplimit != 0) {</a>
<a name="ln1585">		TRACE(&quot;receive_hoplimit&quot;);</a>
<a name="ln1586"> </a>
<a name="ln1587">		if (msgControlLen &lt; CMSG_SPACE(sizeof(int)))</a>
<a name="ln1588">			return B_NO_MEMORY;</a>
<a name="ln1589"> </a>
<a name="ln1590">		// use some default value (64 at the moment) when the real one fails</a>
<a name="ln1591">		int hopLimit = IPV6_DEFHLIM;</a>
<a name="ln1592"> </a>
<a name="ln1593">		if (gBufferModule-&gt;stored_header_length(buffer)</a>
<a name="ln1594">				&gt;= (int)sizeof(ip6_hdr)) {</a>
<a name="ln1595">			IPv6Header header;</a>
<a name="ln1596">			if (gBufferModule-&gt;restore_header(buffer, 0,</a>
<a name="ln1597">					&amp;header, sizeof(ip6_hdr)) == B_OK</a>
<a name="ln1598">				&amp;&amp; header.ProtocolVersion() != IPV6_VERSION) {</a>
<a name="ln1599">				// header is OK, take hoplimit from it</a>
<a name="ln1600">				hopLimit = header.header.ip6_hlim;</a>
<a name="ln1601">			}</a>
<a name="ln1602">		}</a>
<a name="ln1603"> </a>
<a name="ln1604">		cmsghdr* messageHeader = (cmsghdr*)((char*)msgControl + bytesWritten);</a>
<a name="ln1605">		messageHeader-&gt;cmsg_len = CMSG_LEN(sizeof(int));</a>
<a name="ln1606">		messageHeader-&gt;cmsg_level = IPPROTO_IPV6;</a>
<a name="ln1607">		messageHeader-&gt;cmsg_type = IPV6_HOPLIMIT;</a>
<a name="ln1608"> </a>
<a name="ln1609">		memcpy(CMSG_DATA(messageHeader), &amp;hopLimit, sizeof(int));</a>
<a name="ln1610"> </a>
<a name="ln1611">		bytesWritten += CMSG_SPACE(sizeof(int));</a>
<a name="ln1612">		msgControlLen -= CMSG_SPACE(sizeof(int));</a>
<a name="ln1613">	}</a>
<a name="ln1614"> </a>
<a name="ln1615">	if (protocol-&gt;receive_pktinfo != 0) {</a>
<a name="ln1616">		TRACE(&quot;receive_pktinfo&quot;);</a>
<a name="ln1617"> </a>
<a name="ln1618">		if (msgControlLen &lt; CMSG_SPACE(sizeof(struct in6_pktinfo)))</a>
<a name="ln1619">			return B_NO_MEMORY;</a>
<a name="ln1620"> </a>
<a name="ln1621">		cmsghdr* messageHeader = (cmsghdr*)((char*)msgControl + bytesWritten);</a>
<a name="ln1622">		messageHeader-&gt;cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));</a>
<a name="ln1623">		messageHeader-&gt;cmsg_level = IPPROTO_IPV6;</a>
<a name="ln1624">		messageHeader-&gt;cmsg_type = IPV6_PKTINFO;</a>
<a name="ln1625"> </a>
<a name="ln1626">		struct in6_pktinfo pi;</a>
<a name="ln1627">		memcpy(&amp;pi.ipi6_addr,</a>
<a name="ln1628">			&amp;((struct sockaddr_in6*)buffer-&gt;destination)-&gt;sin6_addr,</a>
<a name="ln1629">			sizeof(struct in6_addr));</a>
<a name="ln1630">		if (buffer-&gt;interface_address != NULL</a>
<a name="ln1631">			&amp;&amp; buffer-&gt;interface_address-&gt;interface != NULL)</a>
<a name="ln1632">			pi.ipi6_ifindex = buffer-&gt;interface_address-&gt;interface-&gt;index;</a>
<a name="ln1633">		else</a>
<a name="ln1634">			pi.ipi6_ifindex = 0;</a>
<a name="ln1635">		memcpy(CMSG_DATA(messageHeader), &amp;pi, sizeof(struct in6_pktinfo));</a>
<a name="ln1636"> </a>
<a name="ln1637">		bytesWritten += CMSG_SPACE(sizeof(struct in6_pktinfo));</a>
<a name="ln1638">		msgControlLen -= CMSG_SPACE(sizeof(struct in6_pktinfo));</a>
<a name="ln1639">	}</a>
<a name="ln1640"> </a>
<a name="ln1641">	return bytesWritten;</a>
<a name="ln1642">}</a>
<a name="ln1643"> </a>
<a name="ln1644"> </a>
<a name="ln1645">//	#pragma mark -</a>
<a name="ln1646"> </a>
<a name="ln1647"> </a>
<a name="ln1648">status_t</a>
<a name="ln1649">init_ipv6()</a>
<a name="ln1650">{</a>
<a name="ln1651">	mutex_init(&amp;sRawSocketsLock, &quot;raw sockets&quot;);</a>
<a name="ln1652">	mutex_init(&amp;sFragmentLock, &quot;IPv4 Fragments&quot;);</a>
<a name="ln1653">	mutex_init(&amp;sMulticastGroupsLock, &quot;IPv6 multicast groups&quot;);</a>
<a name="ln1654">	mutex_init(&amp;sReceivingProtocolLock, &quot;IPv6 receiving protocols&quot;);</a>
<a name="ln1655"> </a>
<a name="ln1656">	status_t status;</a>
<a name="ln1657"> </a>
<a name="ln1658">	sMulticastState = new MulticastState();</a>
<a name="ln1659">	if (sMulticastState == NULL) {</a>
<a name="ln1660">		status = B_NO_MEMORY;</a>
<a name="ln1661">		goto err1;</a>
<a name="ln1662">	}</a>
<a name="ln1663"> </a>
<a name="ln1664">	status = sMulticastState-&gt;Init();</a>
<a name="ln1665">	if (status != B_OK)</a>
<a name="ln1666">		goto err2;</a>
<a name="ln1667"> </a>
<a name="ln1668">	new (&amp;sFragmentHash) FragmentTable();</a>
<a name="ln1669">	status = sFragmentHash.Init(256);</a>
<a name="ln1670">	if (status != B_OK)</a>
<a name="ln1671">		goto err3;</a>
<a name="ln1672"> </a>
<a name="ln1673">	new (&amp;sRawSockets) RawSocketList;</a>
<a name="ln1674">		// static initializers do not work in the kernel,</a>
<a name="ln1675">		// so we have to do it here, manually</a>
<a name="ln1676">		// TODO: for modules, this shouldn't be required</a>
<a name="ln1677"> </a>
<a name="ln1678">	status = gStackModule-&gt;register_domain_protocols(AF_INET6, SOCK_RAW, 0,</a>
<a name="ln1679">		NET_IPV6_MODULE_NAME, NULL);</a>
<a name="ln1680">	if (status != B_OK)</a>
<a name="ln1681">		goto err3;</a>
<a name="ln1682"> </a>
<a name="ln1683">	status = gStackModule-&gt;register_domain(AF_INET6, &quot;internet6&quot;, &amp;gIPv6Module,</a>
<a name="ln1684">		&amp;gIPv6AddressModule, &amp;sDomain);</a>
<a name="ln1685">	if (status != B_OK)</a>
<a name="ln1686">		goto err3;</a>
<a name="ln1687"> </a>
<a name="ln1688">	TRACE(&quot;init_ipv6: OK&quot;);</a>
<a name="ln1689">	return B_OK;</a>
<a name="ln1690"> </a>
<a name="ln1691">err3:</a>
<a name="ln1692">	sFragmentHash.~FragmentTable();</a>
<a name="ln1693">err2:</a>
<a name="ln1694">	delete sMulticastState;</a>
<a name="ln1695">err1:</a>
<a name="ln1696">	mutex_destroy(&amp;sReceivingProtocolLock);</a>
<a name="ln1697">	mutex_destroy(&amp;sMulticastGroupsLock);</a>
<a name="ln1698">	mutex_destroy(&amp;sFragmentLock);</a>
<a name="ln1699">	mutex_destroy(&amp;sRawSocketsLock);</a>
<a name="ln1700">	TRACE(&quot;init_ipv6: error %s&quot;, strerror(status));</a>
<a name="ln1701">	return status;</a>
<a name="ln1702">}</a>
<a name="ln1703"> </a>
<a name="ln1704"> </a>
<a name="ln1705">status_t</a>
<a name="ln1706">uninit_ipv6()</a>
<a name="ln1707">{</a>
<a name="ln1708">	mutex_lock(&amp;sReceivingProtocolLock);</a>
<a name="ln1709"> </a>
<a name="ln1710">	// put all the domain receiving protocols we gathered so far</a>
<a name="ln1711">	for (uint32 i = 0; i &lt; 256; i++) {</a>
<a name="ln1712">		if (sReceivingProtocol[i] != NULL)</a>
<a name="ln1713">			gStackModule-&gt;put_domain_receiving_protocol(sDomain, i);</a>
<a name="ln1714">	}</a>
<a name="ln1715"> </a>
<a name="ln1716">	sFragmentHash.~FragmentTable();</a>
<a name="ln1717">	delete sMulticastState;</a>
<a name="ln1718"> </a>
<a name="ln1719">	gStackModule-&gt;unregister_domain(sDomain);</a>
<a name="ln1720">	mutex_unlock(&amp;sReceivingProtocolLock);</a>
<a name="ln1721"> </a>
<a name="ln1722">	mutex_destroy(&amp;sMulticastGroupsLock);</a>
<a name="ln1723">	mutex_destroy(&amp;sFragmentLock);</a>
<a name="ln1724">	mutex_destroy(&amp;sRawSocketsLock);</a>
<a name="ln1725">	mutex_destroy(&amp;sReceivingProtocolLock);</a>
<a name="ln1726"> </a>
<a name="ln1727">	return B_OK;</a>
<a name="ln1728">}</a>
<a name="ln1729"> </a>
<a name="ln1730"> </a>
<a name="ln1731">static status_t</a>
<a name="ln1732">ipv6_std_ops(int32 op, ...)</a>
<a name="ln1733">{</a>
<a name="ln1734">	switch (op) {</a>
<a name="ln1735">		case B_MODULE_INIT:</a>
<a name="ln1736">			return init_ipv6();</a>
<a name="ln1737">		case B_MODULE_UNINIT:</a>
<a name="ln1738">			return uninit_ipv6();</a>
<a name="ln1739">		default:</a>
<a name="ln1740">			return B_ERROR;</a>
<a name="ln1741">	}</a>
<a name="ln1742">}</a>
<a name="ln1743"> </a>
<a name="ln1744"> </a>
<a name="ln1745">net_protocol_module_info gIPv6Module = {</a>
<a name="ln1746">	{</a>
<a name="ln1747">		NET_IPV6_MODULE_NAME,</a>
<a name="ln1748">		0,</a>
<a name="ln1749">		ipv6_std_ops</a>
<a name="ln1750">	},</a>
<a name="ln1751">	NET_PROTOCOL_ATOMIC_MESSAGES,</a>
<a name="ln1752"> </a>
<a name="ln1753">	ipv6_init_protocol,</a>
<a name="ln1754">	ipv6_uninit_protocol,</a>
<a name="ln1755">	ipv6_open,</a>
<a name="ln1756">	ipv6_close,</a>
<a name="ln1757">	ipv6_free,</a>
<a name="ln1758">	ipv6_connect,</a>
<a name="ln1759">	ipv6_accept,</a>
<a name="ln1760">	ipv6_control,</a>
<a name="ln1761">	ipv6_getsockopt,</a>
<a name="ln1762">	ipv6_setsockopt,</a>
<a name="ln1763">	ipv6_bind,</a>
<a name="ln1764">	ipv6_unbind,</a>
<a name="ln1765">	ipv6_listen,</a>
<a name="ln1766">	ipv6_shutdown,</a>
<a name="ln1767">	ipv6_send_data,</a>
<a name="ln1768">	ipv6_send_routed_data,</a>
<a name="ln1769">	ipv6_send_avail,</a>
<a name="ln1770">	ipv6_read_data,</a>
<a name="ln1771">	ipv6_read_avail,</a>
<a name="ln1772">	ipv6_get_domain,</a>
<a name="ln1773">	ipv6_get_mtu,</a>
<a name="ln1774">	ipv6_receive_data,</a>
<a name="ln1775">	ipv6_deliver_data,</a>
<a name="ln1776">	ipv6_error_received,</a>
<a name="ln1777">	ipv6_error_reply,</a>
<a name="ln1778">	NULL,		// add_ancillary_data()</a>
<a name="ln1779">	NULL,		// process_ancillary_data()</a>
<a name="ln1780">	ipv6_process_ancillary_data_no_container,</a>
<a name="ln1781">	NULL,		// send_data_no_buffer()</a>
<a name="ln1782">	NULL		// read_data_no_buffer()</a>
<a name="ln1783">};</a>
<a name="ln1784"> </a>
<a name="ln1785">module_dependency module_dependencies[] = {</a>
<a name="ln1786">	{NET_STACK_MODULE_NAME, (module_info**)&amp;gStackModule},</a>
<a name="ln1787">	{NET_BUFFER_MODULE_NAME, (module_info**)&amp;gBufferModule},</a>
<a name="ln1788">	{NET_DATALINK_MODULE_NAME, (module_info**)&amp;sDatalinkModule},</a>
<a name="ln1789">	{NET_SOCKET_MODULE_NAME, (module_info**)&amp;sSocketModule},</a>
<a name="ln1790">	{}</a>
<a name="ln1791">};</a>
<a name="ln1792"> </a>
<a name="ln1793">module_info* modules[] = {</a>
<a name="ln1794">	(module_info*)&amp;gIPv6Module,</a>
<a name="ln1795">	NULL</a>
<a name="ln1796">};</a>

</code></pre>
<div class="balloon" rel="1609"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memcpy' function will lead to a buffer overflow.</p></div>
<div class="balloon" rel="1635"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memcpy' function will lead to a buffer overflow.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
