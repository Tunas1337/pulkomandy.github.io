
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>VMKernelAddressSpace.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2009-2011, Ingo Weinhold, ingo_weinhold@gmx.de.</a>
<a name="ln3"> * Copyright 2002-2009, Axel DÃ¶rfler, axeld@pinc-software.de.</a>
<a name="ln4"> * Distributed under the terms of the MIT License.</a>
<a name="ln5"> *</a>
<a name="ln6"> * Copyright 2001-2002, Travis Geiselbrecht. All rights reserved.</a>
<a name="ln7"> * Distributed under the terms of the NewOS License.</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10"> </a>
<a name="ln11">#include &quot;VMKernelAddressSpace.h&quot;</a>
<a name="ln12"> </a>
<a name="ln13">#include &lt;stdlib.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;KernelExport.h&gt;</a>
<a name="ln16"> </a>
<a name="ln17">#include &lt;heap.h&gt;</a>
<a name="ln18">#include &lt;slab/Slab.h&gt;</a>
<a name="ln19">#include &lt;thread.h&gt;</a>
<a name="ln20">#include &lt;vm/vm.h&gt;</a>
<a name="ln21">#include &lt;vm/VMArea.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23"> </a>
<a name="ln24">//#define TRACE_VM</a>
<a name="ln25">#ifdef TRACE_VM</a>
<a name="ln26">#	define TRACE(x...) dprintf(x)</a>
<a name="ln27">#else</a>
<a name="ln28">#	define TRACE(x...) ;</a>
<a name="ln29">#endif</a>
<a name="ln30"> </a>
<a name="ln31"> </a>
<a name="ln32">//#define PARANOIA_CHECKS</a>
<a name="ln33">#ifdef PARANOIA_CHECKS</a>
<a name="ln34">#	define PARANOIA_CHECK_STRUCTURES()	_CheckStructures()</a>
<a name="ln35">#else</a>
<a name="ln36">#	define PARANOIA_CHECK_STRUCTURES()	do {} while (false)</a>
<a name="ln37">#endif</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">static int</a>
<a name="ln41">ld(size_t value)</a>
<a name="ln42">{</a>
<a name="ln43">	int index = -1;</a>
<a name="ln44">	while (value &gt; 0) {</a>
<a name="ln45">		value &gt;&gt;= 1;</a>
<a name="ln46">		index++;</a>
<a name="ln47">	}</a>
<a name="ln48"> </a>
<a name="ln49">	return index;</a>
<a name="ln50">}</a>
<a name="ln51"> </a>
<a name="ln52"> </a>
<a name="ln53">/*!	Verifies that an area with the given aligned base and size fits into</a>
<a name="ln54">	the spot defined by base and limit and checks for overflows.</a>
<a name="ln55">	\param base Minimum base address valid for the area.</a>
<a name="ln56">	\param alignedBase The base address of the range to check.</a>
<a name="ln57">	\param size The size of the area.</a>
<a name="ln58">	\param limit The last (inclusive) addresss of the range to check.</a>
<a name="ln59">*/</a>
<a name="ln60">static inline bool</a>
<a name="ln61">is_valid_spot(addr_t base, addr_t alignedBase, addr_t size, addr_t limit)</a>
<a name="ln62">{</a>
<a name="ln63">	return (alignedBase &gt;= base &amp;&amp; alignedBase + (size - 1) &gt; alignedBase</a>
<a name="ln64">		&amp;&amp; alignedBase + (size - 1) &lt;= limit);</a>
<a name="ln65">}</a>
<a name="ln66"> </a>
<a name="ln67"> </a>
<a name="ln68">// #pragma mark - VMKernelAddressSpace</a>
<a name="ln69"> </a>
<a name="ln70"> </a>
<a name="ln71">VMKernelAddressSpace::VMKernelAddressSpace(team_id id, addr_t base, size_t size)</a>
<a name="ln72">	:</a>
<a name="ln73">	VMAddressSpace(id, base, size, &quot;kernel address space&quot;),</a>
<a name="ln74">	fAreaObjectCache(NULL),</a>
<a name="ln75">	fRangesObjectCache(NULL)</a>
<a name="ln76">{</a>
<a name="ln77">}</a>
<a name="ln78"> </a>
<a name="ln79"> </a>
<a name="ln80">VMKernelAddressSpace::~VMKernelAddressSpace()</a>
<a name="ln81">{</a>
<a name="ln82">	panic(&quot;deleting the kernel aspace!\n&quot;);</a>
<a name="ln83">}</a>
<a name="ln84"> </a>
<a name="ln85"> </a>
<a name="ln86">status_t</a>
<a name="ln87">VMKernelAddressSpace::InitObject()</a>
<a name="ln88">{</a>
<a name="ln89">	fAreaObjectCache = create_object_cache(&quot;kernel areas&quot;,</a>
<a name="ln90">		sizeof(VMKernelArea), 0, NULL, NULL, NULL);</a>
<a name="ln91">	if (fAreaObjectCache == NULL)</a>
<a name="ln92">		return B_NO_MEMORY;</a>
<a name="ln93"> </a>
<a name="ln94">	fRangesObjectCache = create_object_cache(&quot;kernel address ranges&quot;,</a>
<a name="ln95">		sizeof(Range), 0, NULL, NULL, NULL);</a>
<a name="ln96">	if (fRangesObjectCache == NULL)</a>
<a name="ln97">		return B_NO_MEMORY;</a>
<a name="ln98"> </a>
<a name="ln99">	// create the free lists</a>
<a name="ln100">	size_t size = fEndAddress - fBase + 1;</a>
<a name="ln101">	fFreeListCount = ld(size) - PAGE_SHIFT + 1;</a>
<a name="ln102">	fFreeLists = new(std::nothrow) RangeFreeList[fFreeListCount];</a>
<a name="ln103">	if (fFreeLists == NULL)</a>
<a name="ln104">		return B_NO_MEMORY;</a>
<a name="ln105"> </a>
<a name="ln106">	Range* range = new(fRangesObjectCache, 0) Range(fBase, size,</a>
<a name="ln107">		Range::RANGE_FREE);</a>
<a name="ln108">	if (range == NULL)</a>
<a name="ln109">		return B_NO_MEMORY;</a>
<a name="ln110"> </a>
<a name="ln111">	_InsertRange(range);</a>
<a name="ln112"> </a>
<a name="ln113">	TRACE(&quot;VMKernelAddressSpace::InitObject(): address range: %#&quot; B_PRIxADDR</a>
<a name="ln114">		&quot; - %#&quot; B_PRIxADDR &quot;, free lists: %d\n&quot;, fBase, fEndAddress,</a>
<a name="ln115">		fFreeListCount);</a>
<a name="ln116"> </a>
<a name="ln117">	return B_OK;</a>
<a name="ln118">}</a>
<a name="ln119"> </a>
<a name="ln120"> </a>
<a name="ln121">inline VMArea*</a>
<a name="ln122">VMKernelAddressSpace::FirstArea() const</a>
<a name="ln123">{</a>
<a name="ln124">	Range* range = fRangeList.Head();</a>
<a name="ln125">	while (range != NULL &amp;&amp; range-&gt;type != Range::RANGE_AREA)</a>
<a name="ln126">		range = fRangeList.GetNext(range);</a>
<a name="ln127">	return range != NULL ? range-&gt;area : NULL;</a>
<a name="ln128">}</a>
<a name="ln129"> </a>
<a name="ln130"> </a>
<a name="ln131">inline VMArea*</a>
<a name="ln132">VMKernelAddressSpace::NextArea(VMArea* _area) const</a>
<a name="ln133">{</a>
<a name="ln134">	Range* range = static_cast&lt;VMKernelArea*&gt;(_area)-&gt;Range();</a>
<a name="ln135">	do {</a>
<a name="ln136">		range = fRangeList.GetNext(range);</a>
<a name="ln137">	} while (range != NULL &amp;&amp; range-&gt;type != Range::RANGE_AREA);</a>
<a name="ln138">	return range != NULL ? range-&gt;area : NULL;</a>
<a name="ln139">}</a>
<a name="ln140"> </a>
<a name="ln141"> </a>
<a name="ln142">VMArea*</a>
<a name="ln143">VMKernelAddressSpace::CreateArea(const char* name, uint32 wiring,</a>
<a name="ln144">	uint32 protection, uint32 allocationFlags)</a>
<a name="ln145">{</a>
<a name="ln146">	return VMKernelArea::Create(this, name, wiring, protection,</a>
<a name="ln147">		fAreaObjectCache, allocationFlags);</a>
<a name="ln148">}</a>
<a name="ln149"> </a>
<a name="ln150"> </a>
<a name="ln151">void</a>
<a name="ln152">VMKernelAddressSpace::DeleteArea(VMArea* _area, uint32 allocationFlags)</a>
<a name="ln153">{</a>
<a name="ln154">	TRACE(&quot;VMKernelAddressSpace::DeleteArea(%p)\n&quot;, _area);</a>
<a name="ln155"> </a>
<a name="ln156">	VMKernelArea* area = static_cast&lt;VMKernelArea*&gt;(_area);</a>
<a name="ln157">	object_cache_delete(fAreaObjectCache, area);</a>
<a name="ln158">}</a>
<a name="ln159"> </a>
<a name="ln160"> </a>
<a name="ln161">//! You must hold the address space's read lock.</a>
<a name="ln162">VMArea*</a>
<a name="ln163">VMKernelAddressSpace::LookupArea(addr_t address) const</a>
<a name="ln164">{</a>
<a name="ln165">	Range* range = fRangeTree.FindClosest(address, true);</a>
<a name="ln166">	if (range == NULL || range-&gt;type != Range::RANGE_AREA)</a>
<a name="ln167">		return NULL;</a>
<a name="ln168"> </a>
<a name="ln169">	VMKernelArea* area = range-&gt;area;</a>
<a name="ln170">	return area-&gt;ContainsAddress(address) ? area : NULL;</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173"> </a>
<a name="ln174">/*!	This inserts the area you pass into the address space.</a>
<a name="ln175">	It will also set the &quot;_address&quot; argument to its base address when</a>
<a name="ln176">	the call succeeds.</a>
<a name="ln177">	You need to hold the VMAddressSpace write lock.</a>
<a name="ln178">*/</a>
<a name="ln179">status_t</a>
<a name="ln180">VMKernelAddressSpace::InsertArea(VMArea* _area, size_t size,</a>
<a name="ln181">	const virtual_address_restrictions* addressRestrictions,</a>
<a name="ln182">	uint32 allocationFlags, void** _address)</a>
<a name="ln183">{</a>
<a name="ln184">	TRACE(&quot;VMKernelAddressSpace::InsertArea(%p, %&quot; B_PRIu32 &quot;, %#&quot; B_PRIxSIZE</a>
<a name="ln185">		&quot;, %p \&quot;%s\&quot;)\n&quot;, addressRestrictions-&gt;address,</a>
<a name="ln186">		addressRestrictions-&gt;address_specification, size, _area, _area-&gt;name);</a>
<a name="ln187"> </a>
<a name="ln188">	VMKernelArea* area = static_cast&lt;VMKernelArea*&gt;(_area);</a>
<a name="ln189"> </a>
<a name="ln190">	Range* range;</a>
<a name="ln191">	status_t error = _AllocateRange(addressRestrictions, size,</a>
<a name="ln192">		addressRestrictions-&gt;address_specification == B_EXACT_ADDRESS,</a>
<a name="ln193">		allocationFlags, range);</a>
<a name="ln194">	if (error != B_OK)</a>
<a name="ln195">		return error;</a>
<a name="ln196"> </a>
<a name="ln197">	range-&gt;type = Range::RANGE_AREA;</a>
<a name="ln198">	range-&gt;area = area;</a>
<a name="ln199">	area-&gt;SetRange(range);</a>
<a name="ln200">	area-&gt;SetBase(range-&gt;base);</a>
<a name="ln201">	area-&gt;SetSize(range-&gt;size);</a>
<a name="ln202"> </a>
<a name="ln203">	if (_address != NULL)</a>
<a name="ln204">		*_address = (void*)area-&gt;Base();</a>
<a name="ln205">	fFreeSpace -= area-&gt;Size();</a>
<a name="ln206"> </a>
<a name="ln207">	PARANOIA_CHECK_STRUCTURES();</a>
<a name="ln208"> </a>
<a name="ln209">	return B_OK;</a>
<a name="ln210">}</a>
<a name="ln211"> </a>
<a name="ln212"> </a>
<a name="ln213">//! You must hold the address space's write lock.</a>
<a name="ln214">void</a>
<a name="ln215">VMKernelAddressSpace::RemoveArea(VMArea* _area, uint32 allocationFlags)</a>
<a name="ln216">{</a>
<a name="ln217">	TRACE(&quot;VMKernelAddressSpace::RemoveArea(%p)\n&quot;, _area);</a>
<a name="ln218"> </a>
<a name="ln219">	VMKernelArea* area = static_cast&lt;VMKernelArea*&gt;(_area);</a>
<a name="ln220"> </a>
<a name="ln221">	_FreeRange(area-&gt;Range(), allocationFlags);</a>
<a name="ln222"> </a>
<a name="ln223">	fFreeSpace += area-&gt;Size();</a>
<a name="ln224"> </a>
<a name="ln225">	PARANOIA_CHECK_STRUCTURES();</a>
<a name="ln226">}</a>
<a name="ln227"> </a>
<a name="ln228"> </a>
<a name="ln229">bool</a>
<a name="ln230">VMKernelAddressSpace::CanResizeArea(VMArea* area, size_t newSize)</a>
<a name="ln231">{</a>
<a name="ln232">	Range* range = static_cast&lt;VMKernelArea*&gt;(area)-&gt;Range();</a>
<a name="ln233"> </a>
<a name="ln234">	if (newSize &lt;= range-&gt;size)</a>
<a name="ln235">		return true;</a>
<a name="ln236"> </a>
<a name="ln237">	Range* nextRange = fRangeList.GetNext(range);</a>
<a name="ln238">	if (nextRange == NULL || nextRange-&gt;type == Range::RANGE_AREA)</a>
<a name="ln239">		return false;</a>
<a name="ln240"> </a>
<a name="ln241">	if (nextRange-&gt;type == Range::RANGE_RESERVED</a>
<a name="ln242">		&amp;&amp; nextRange-&gt;reserved.base &gt; range-&gt;base) {</a>
<a name="ln243">		return false;</a>
<a name="ln244">	}</a>
<a name="ln245"> </a>
<a name="ln246">	// TODO: If there is free space after a reserved range (or vice versa), it</a>
<a name="ln247">	// could be used as well.</a>
<a name="ln248">	return newSize - range-&gt;size &lt;= nextRange-&gt;size;</a>
<a name="ln249">}</a>
<a name="ln250"> </a>
<a name="ln251"> </a>
<a name="ln252">status_t</a>
<a name="ln253">VMKernelAddressSpace::ResizeArea(VMArea* _area, size_t newSize,</a>
<a name="ln254">	uint32 allocationFlags)</a>
<a name="ln255">{</a>
<a name="ln256">	TRACE(&quot;VMKernelAddressSpace::ResizeArea(%p, %#&quot; B_PRIxSIZE &quot;)\n&quot;, _area,</a>
<a name="ln257">		newSize);</a>
<a name="ln258"> </a>
<a name="ln259">	VMKernelArea* area = static_cast&lt;VMKernelArea*&gt;(_area);</a>
<a name="ln260">	Range* range = area-&gt;Range();</a>
<a name="ln261"> </a>
<a name="ln262">	if (newSize == range-&gt;size)</a>
<a name="ln263">		return B_OK;</a>
<a name="ln264"> </a>
<a name="ln265">	Range* nextRange = fRangeList.GetNext(range);</a>
<a name="ln266"> </a>
<a name="ln267">	if (newSize &lt; range-&gt;size) {</a>
<a name="ln268">		if (nextRange != NULL &amp;&amp; nextRange-&gt;type == Range::RANGE_FREE) {</a>
<a name="ln269">			// a free range is following -- just enlarge it</a>
<a name="ln270">			_FreeListRemoveRange(nextRange, nextRange-&gt;size);</a>
<a name="ln271">			nextRange-&gt;size += range-&gt;size - newSize;</a>
<a name="ln272">			nextRange-&gt;base = range-&gt;base + newSize;</a>
<a name="ln273">			_FreeListInsertRange(nextRange, nextRange-&gt;size);</a>
<a name="ln274">		} else {</a>
<a name="ln275">			// no free range following -- we need to allocate a new one and</a>
<a name="ln276">			// insert it</a>
<a name="ln277">			nextRange = new(fRangesObjectCache, allocationFlags) Range(</a>
<a name="ln278">				range-&gt;base + newSize, range-&gt;size - newSize,</a>
<a name="ln279">				Range::RANGE_FREE);</a>
<a name="ln280">			if (nextRange == NULL)</a>
<a name="ln281">				return B_NO_MEMORY;</a>
<a name="ln282">			_InsertRange(nextRange);</a>
<a name="ln283">		}</a>
<a name="ln284">	} else {</a>
<a name="ln285">		if (nextRange == NULL</a>
<a name="ln286">			|| (nextRange-&gt;type == Range::RANGE_RESERVED</a>
<a name="ln287">				&amp;&amp; nextRange-&gt;reserved.base &gt; range-&gt;base)) {</a>
<a name="ln288">			return B_BAD_VALUE;</a>
<a name="ln289">		}</a>
<a name="ln290">		// TODO: If there is free space after a reserved range (or vice versa),</a>
<a name="ln291">		// it could be used as well.</a>
<a name="ln292">		size_t sizeDiff = newSize - range-&gt;size;</a>
<a name="ln293">		if (sizeDiff &gt; nextRange-&gt;size)</a>
<a name="ln294">			return B_BAD_VALUE;</a>
<a name="ln295"> </a>
<a name="ln296">		if (sizeDiff == nextRange-&gt;size) {</a>
<a name="ln297">			// The next range is completely covered -- remove and delete it.</a>
<a name="ln298">			_RemoveRange(nextRange);</a>
<a name="ln299">			object_cache_delete(fRangesObjectCache, nextRange, allocationFlags);</a>
<a name="ln300">		} else {</a>
<a name="ln301">			// The next range is only partially covered -- shrink it.</a>
<a name="ln302">			if (nextRange-&gt;type == Range::RANGE_FREE)</a>
<a name="ln303">				_FreeListRemoveRange(nextRange, nextRange-&gt;size);</a>
<a name="ln304">			nextRange-&gt;size -= sizeDiff;</a>
<a name="ln305">			nextRange-&gt;base = range-&gt;base + newSize;</a>
<a name="ln306">			if (nextRange-&gt;type == Range::RANGE_FREE)</a>
<a name="ln307">				_FreeListInsertRange(nextRange, nextRange-&gt;size);</a>
<a name="ln308">		}</a>
<a name="ln309">	}</a>
<a name="ln310"> </a>
<a name="ln311">	range-&gt;size = newSize;</a>
<a name="ln312">	area-&gt;SetSize(newSize);</a>
<a name="ln313"> </a>
<a name="ln314">	IncrementChangeCount();</a>
<a name="ln315">	PARANOIA_CHECK_STRUCTURES();</a>
<a name="ln316">	return B_OK;</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319"> </a>
<a name="ln320">status_t</a>
<a name="ln321">VMKernelAddressSpace::ShrinkAreaHead(VMArea* _area, size_t newSize,</a>
<a name="ln322">	uint32 allocationFlags)</a>
<a name="ln323">{</a>
<a name="ln324">	TRACE(&quot;VMKernelAddressSpace::ShrinkAreaHead(%p, %#&quot; B_PRIxSIZE &quot;)\n&quot;, _area,</a>
<a name="ln325">		newSize);</a>
<a name="ln326"> </a>
<a name="ln327">	VMKernelArea* area = static_cast&lt;VMKernelArea*&gt;(_area);</a>
<a name="ln328">	Range* range = area-&gt;Range();</a>
<a name="ln329"> </a>
<a name="ln330">	if (newSize == range-&gt;size)</a>
<a name="ln331">		return B_OK;</a>
<a name="ln332"> </a>
<a name="ln333">	if (newSize &gt; range-&gt;size)</a>
<a name="ln334">		return B_BAD_VALUE;</a>
<a name="ln335"> </a>
<a name="ln336">	Range* previousRange = fRangeList.GetPrevious(range);</a>
<a name="ln337"> </a>
<a name="ln338">	size_t sizeDiff = range-&gt;size - newSize;</a>
<a name="ln339">	if (previousRange != NULL &amp;&amp; previousRange-&gt;type == Range::RANGE_FREE) {</a>
<a name="ln340">		// the previous range is free -- just enlarge it</a>
<a name="ln341">		_FreeListRemoveRange(previousRange, previousRange-&gt;size);</a>
<a name="ln342">		previousRange-&gt;size += sizeDiff;</a>
<a name="ln343">		_FreeListInsertRange(previousRange, previousRange-&gt;size);</a>
<a name="ln344">		range-&gt;base += sizeDiff;</a>
<a name="ln345">		range-&gt;size = newSize;</a>
<a name="ln346">	} else {</a>
<a name="ln347">		// no free range before -- we need to allocate a new one and</a>
<a name="ln348">		// insert it</a>
<a name="ln349">		previousRange = new(fRangesObjectCache, allocationFlags) Range(</a>
<a name="ln350">			range-&gt;base, sizeDiff, Range::RANGE_FREE);</a>
<a name="ln351">		if (previousRange == NULL)</a>
<a name="ln352">			return B_NO_MEMORY;</a>
<a name="ln353">		range-&gt;base += sizeDiff;</a>
<a name="ln354">		range-&gt;size = newSize;</a>
<a name="ln355">		_InsertRange(previousRange);</a>
<a name="ln356">	}</a>
<a name="ln357"> </a>
<a name="ln358">	area-&gt;SetBase(range-&gt;base);</a>
<a name="ln359">	area-&gt;SetSize(range-&gt;size);</a>
<a name="ln360"> </a>
<a name="ln361">	IncrementChangeCount();</a>
<a name="ln362">	PARANOIA_CHECK_STRUCTURES();</a>
<a name="ln363">	return B_OK;</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366"> </a>
<a name="ln367">status_t</a>
<a name="ln368">VMKernelAddressSpace::ShrinkAreaTail(VMArea* area, size_t newSize,</a>
<a name="ln369">	uint32 allocationFlags)</a>
<a name="ln370">{</a>
<a name="ln371">	return ResizeArea(area, newSize, allocationFlags);</a>
<a name="ln372">}</a>
<a name="ln373"> </a>
<a name="ln374"> </a>
<a name="ln375">status_t</a>
<a name="ln376">VMKernelAddressSpace::ReserveAddressRange(size_t size,</a>
<a name="ln377">	const virtual_address_restrictions* addressRestrictions,</a>
<a name="ln378">	uint32 flags, uint32 allocationFlags, void** _address)</a>
<a name="ln379">{</a>
<a name="ln380">	TRACE(&quot;VMKernelAddressSpace::ReserveAddressRange(%p, %&quot; B_PRIu32 &quot;, %#&quot;</a>
<a name="ln381">		B_PRIxSIZE &quot;, %#&quot; B_PRIx32 &quot;)\n&quot;, addressRestrictions-&gt;address,</a>
<a name="ln382">		addressRestrictions-&gt;address_specification, size, flags);</a>
<a name="ln383"> </a>
<a name="ln384">	// Don't allow range reservations, if the address space is about to be</a>
<a name="ln385">	// deleted.</a>
<a name="ln386">	if (fDeleting)</a>
<a name="ln387">		return B_BAD_TEAM_ID;</a>
<a name="ln388"> </a>
<a name="ln389">	Range* range;</a>
<a name="ln390">	status_t error = _AllocateRange(addressRestrictions, size, false,</a>
<a name="ln391">		allocationFlags, range);</a>
<a name="ln392">	if (error != B_OK)</a>
<a name="ln393">		return error;</a>
<a name="ln394"> </a>
<a name="ln395">	range-&gt;type = Range::RANGE_RESERVED;</a>
<a name="ln396">	range-&gt;reserved.base = range-&gt;base;</a>
<a name="ln397">	range-&gt;reserved.flags = flags;</a>
<a name="ln398"> </a>
<a name="ln399">	if (_address != NULL)</a>
<a name="ln400">		*_address = (void*)range-&gt;base;</a>
<a name="ln401"> </a>
<a name="ln402">	Get();</a>
<a name="ln403">	PARANOIA_CHECK_STRUCTURES();</a>
<a name="ln404">	return B_OK;</a>
<a name="ln405">}</a>
<a name="ln406"> </a>
<a name="ln407"> </a>
<a name="ln408">status_t</a>
<a name="ln409">VMKernelAddressSpace::UnreserveAddressRange(addr_t address, size_t size,</a>
<a name="ln410">	uint32 allocationFlags)</a>
<a name="ln411">{</a>
<a name="ln412">	TRACE(&quot;VMKernelAddressSpace::UnreserveAddressRange(%#&quot; B_PRIxADDR &quot;, %#&quot;</a>
<a name="ln413">		B_PRIxSIZE &quot;)\n&quot;, address, size);</a>
<a name="ln414"> </a>
<a name="ln415">	// Don't allow range unreservations, if the address space is about to be</a>
<a name="ln416">	// deleted. UnreserveAllAddressRanges() must be used.</a>
<a name="ln417">	if (fDeleting)</a>
<a name="ln418">		return B_BAD_TEAM_ID;</a>
<a name="ln419"> </a>
<a name="ln420">	// search range list and remove any matching reserved ranges</a>
<a name="ln421">	addr_t endAddress = address + (size - 1);</a>
<a name="ln422">	Range* range = fRangeTree.FindClosest(address, false);</a>
<a name="ln423">	while (range != NULL &amp;&amp; range-&gt;base + (range-&gt;size - 1) &lt;= endAddress) {</a>
<a name="ln424">		// Get the next range for the iteration -- we need to skip free ranges,</a>
<a name="ln425">		// since _FreeRange() might join them with the current range and delete</a>
<a name="ln426">		// them.</a>
<a name="ln427">		Range* nextRange = fRangeList.GetNext(range);</a>
<a name="ln428">		while (nextRange != NULL &amp;&amp; nextRange-&gt;type == Range::RANGE_FREE)</a>
<a name="ln429">			nextRange = fRangeList.GetNext(nextRange);</a>
<a name="ln430"> </a>
<a name="ln431">		if (range-&gt;type == Range::RANGE_RESERVED) {</a>
<a name="ln432">			_FreeRange(range, allocationFlags);</a>
<a name="ln433">			Put();</a>
<a name="ln434">		}</a>
<a name="ln435"> </a>
<a name="ln436">		range = nextRange;</a>
<a name="ln437">	}</a>
<a name="ln438"> </a>
<a name="ln439">	PARANOIA_CHECK_STRUCTURES();</a>
<a name="ln440">	return B_OK;</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443"> </a>
<a name="ln444">void</a>
<a name="ln445">VMKernelAddressSpace::UnreserveAllAddressRanges(uint32 allocationFlags)</a>
<a name="ln446">{</a>
<a name="ln447">	Range* range = fRangeList.Head();</a>
<a name="ln448">	while (range != NULL) {</a>
<a name="ln449">		// Get the next range for the iteration -- we need to skip free ranges,</a>
<a name="ln450">		// since _FreeRange() might join them with the current range and delete</a>
<a name="ln451">		// them.</a>
<a name="ln452">		Range* nextRange = fRangeList.GetNext(range);</a>
<a name="ln453">		while (nextRange != NULL &amp;&amp; nextRange-&gt;type == Range::RANGE_FREE)</a>
<a name="ln454">			nextRange = fRangeList.GetNext(nextRange);</a>
<a name="ln455"> </a>
<a name="ln456">		if (range-&gt;type == Range::RANGE_RESERVED) {</a>
<a name="ln457">			_FreeRange(range, allocationFlags);</a>
<a name="ln458">			Put();</a>
<a name="ln459">		}</a>
<a name="ln460"> </a>
<a name="ln461">		range = nextRange;</a>
<a name="ln462">	}</a>
<a name="ln463"> </a>
<a name="ln464">	PARANOIA_CHECK_STRUCTURES();</a>
<a name="ln465">}</a>
<a name="ln466"> </a>
<a name="ln467"> </a>
<a name="ln468">void</a>
<a name="ln469">VMKernelAddressSpace::Dump() const</a>
<a name="ln470">{</a>
<a name="ln471">	VMAddressSpace::Dump();</a>
<a name="ln472"> </a>
<a name="ln473">	kprintf(&quot;area_list:\n&quot;);</a>
<a name="ln474"> </a>
<a name="ln475">	for (RangeList::ConstIterator it = fRangeList.GetIterator();</a>
<a name="ln476">			Range* range = it.Next();) {</a>
<a name="ln477">		if (range-&gt;type != Range::RANGE_AREA)</a>
<a name="ln478">			continue;</a>
<a name="ln479"> </a>
<a name="ln480">		VMKernelArea* area = range-&gt;area;</a>
<a name="ln481">		kprintf(&quot; area %&quot; B_PRId32 &quot;: &quot;, area-&gt;id);</a>
<a name="ln482">		kprintf(&quot;base_addr = %#&quot; B_PRIxADDR &quot; &quot;, area-&gt;Base());</a>
<a name="ln483">		kprintf(&quot;size = %#&quot; B_PRIxSIZE &quot; &quot;, area-&gt;Size());</a>
<a name="ln484">		kprintf(&quot;name = '%s' &quot;, area-&gt;name);</a>
<a name="ln485">		kprintf(&quot;protection = %#&quot; B_PRIx32 &quot;\n&quot;, area-&gt;protection);</a>
<a name="ln486">	}</a>
<a name="ln487">}</a>
<a name="ln488"> </a>
<a name="ln489"> </a>
<a name="ln490">inline void</a>
<a name="ln491">VMKernelAddressSpace::_FreeListInsertRange(Range* range, size_t size)</a>
<a name="ln492">{</a>
<a name="ln493">	TRACE(&quot;    VMKernelAddressSpace::_FreeListInsertRange(%p (%#&quot; B_PRIxADDR</a>
<a name="ln494">		&quot;, %#&quot; B_PRIxSIZE &quot;, %d), %#&quot; B_PRIxSIZE &quot; (%d))\n&quot;, range, range-&gt;base,</a>
<a name="ln495">		range-&gt;size, range-&gt;type, size, ld(size) - PAGE_SHIFT);</a>
<a name="ln496"> </a>
<a name="ln497">	fFreeLists[ld(size) - PAGE_SHIFT].Add(range);</a>
<a name="ln498">}</a>
<a name="ln499"> </a>
<a name="ln500"> </a>
<a name="ln501">inline void</a>
<a name="ln502">VMKernelAddressSpace::_FreeListRemoveRange(Range* range, size_t size)</a>
<a name="ln503">{</a>
<a name="ln504">	TRACE(&quot;    VMKernelAddressSpace::_FreeListRemoveRange(%p (%#&quot; B_PRIxADDR</a>
<a name="ln505">		&quot;, %#&quot; B_PRIxSIZE &quot;, %d), %#&quot; B_PRIxSIZE &quot; (%d))\n&quot;, range, range-&gt;base,</a>
<a name="ln506">		range-&gt;size, range-&gt;type, size, ld(size) - PAGE_SHIFT);</a>
<a name="ln507"> </a>
<a name="ln508">	fFreeLists[ld(size) - PAGE_SHIFT].Remove(range);</a>
<a name="ln509">}</a>
<a name="ln510"> </a>
<a name="ln511"> </a>
<a name="ln512">void</a>
<a name="ln513">VMKernelAddressSpace::_InsertRange(Range* range)</a>
<a name="ln514">{</a>
<a name="ln515">	TRACE(&quot;    VMKernelAddressSpace::_InsertRange(%p (%#&quot; B_PRIxADDR &quot;, %#&quot;</a>
<a name="ln516">		B_PRIxSIZE &quot;, %d))\n&quot;, range, range-&gt;base, range-&gt;size, range-&gt;type);</a>
<a name="ln517"> </a>
<a name="ln518">	// insert at the correct position in the range list</a>
<a name="ln519">	Range* insertBeforeRange = fRangeTree.FindClosest(range-&gt;base, true);</a>
<a name="ln520">	fRangeList.Insert(</a>
<a name="ln521">		insertBeforeRange != NULL</a>
<a name="ln522">			? fRangeList.GetNext(insertBeforeRange) : fRangeList.Head(),</a>
<a name="ln523">		range);</a>
<a name="ln524"> </a>
<a name="ln525">	// insert into tree</a>
<a name="ln526">	fRangeTree.Insert(range);</a>
<a name="ln527"> </a>
<a name="ln528">	// insert in the free ranges list, if the range is free</a>
<a name="ln529">	if (range-&gt;type == Range::RANGE_FREE)</a>
<a name="ln530">		_FreeListInsertRange(range, range-&gt;size);</a>
<a name="ln531">}</a>
<a name="ln532"> </a>
<a name="ln533"> </a>
<a name="ln534">void</a>
<a name="ln535">VMKernelAddressSpace::_RemoveRange(Range* range)</a>
<a name="ln536">{</a>
<a name="ln537">	TRACE(&quot;    VMKernelAddressSpace::_RemoveRange(%p (%#&quot; B_PRIxADDR &quot;, %#&quot;</a>
<a name="ln538">		B_PRIxSIZE &quot;, %d))\n&quot;, range, range-&gt;base, range-&gt;size, range-&gt;type);</a>
<a name="ln539"> </a>
<a name="ln540">	// remove from tree and range list</a>
<a name="ln541">	// insert at the correct position in the range list</a>
<a name="ln542">	fRangeTree.Remove(range);</a>
<a name="ln543">	fRangeList.Remove(range);</a>
<a name="ln544"> </a>
<a name="ln545">	// if it is a free range, also remove it from the free list</a>
<a name="ln546">	if (range-&gt;type == Range::RANGE_FREE)</a>
<a name="ln547">		_FreeListRemoveRange(range, range-&gt;size);</a>
<a name="ln548">}</a>
<a name="ln549"> </a>
<a name="ln550"> </a>
<a name="ln551">status_t</a>
<a name="ln552">VMKernelAddressSpace::_AllocateRange(</a>
<a name="ln553">	const virtual_address_restrictions* addressRestrictions,</a>
<a name="ln554">	size_t size, bool allowReservedRange, uint32 allocationFlags,</a>
<a name="ln555">	Range*&amp; _range)</a>
<a name="ln556">{</a>
<a name="ln557">	TRACE(&quot;  VMKernelAddressSpace::_AllocateRange(address: %p, size: %#&quot;</a>
<a name="ln558">		B_PRIxSIZE &quot;, addressSpec: %#&quot; B_PRIx32 &quot;, reserved allowed: %d)\n&quot;,</a>
<a name="ln559">		addressRestrictions-&gt;address, size,</a>
<a name="ln560">		addressRestrictions-&gt;address_specification, allowReservedRange);</a>
<a name="ln561"> </a>
<a name="ln562">	// prepare size, alignment and the base address for the range search</a>
<a name="ln563">	addr_t address = (addr_t)addressRestrictions-&gt;address;</a>
<a name="ln564">	size = ROUNDUP(size, B_PAGE_SIZE);</a>
<a name="ln565">	size_t alignment = addressRestrictions-&gt;alignment != 0</a>
<a name="ln566">		? addressRestrictions-&gt;alignment : B_PAGE_SIZE;</a>
<a name="ln567"> </a>
<a name="ln568">	switch (addressRestrictions-&gt;address_specification) {</a>
<a name="ln569">		case B_EXACT_ADDRESS:</a>
<a name="ln570">		{</a>
<a name="ln571">			if (address % B_PAGE_SIZE != 0)</a>
<a name="ln572">				return B_BAD_VALUE;</a>
<a name="ln573">			break;</a>
<a name="ln574">		}</a>
<a name="ln575"> </a>
<a name="ln576">		case B_BASE_ADDRESS:</a>
<a name="ln577">			address = ROUNDUP(address, B_PAGE_SIZE);</a>
<a name="ln578">			break;</a>
<a name="ln579"> </a>
<a name="ln580">		case B_ANY_KERNEL_BLOCK_ADDRESS:</a>
<a name="ln581">			// align the memory to the next power of two of the size</a>
<a name="ln582">			while (alignment &lt; size)</a>
<a name="ln583">				alignment &lt;&lt;= 1;</a>
<a name="ln584"> </a>
<a name="ln585">			// fall through...</a>
<a name="ln586"> </a>
<a name="ln587">		case B_ANY_ADDRESS:</a>
<a name="ln588">		case B_ANY_KERNEL_ADDRESS:</a>
<a name="ln589">			address = fBase;</a>
<a name="ln590">			break;</a>
<a name="ln591"> </a>
<a name="ln592">		default:</a>
<a name="ln593">			return B_BAD_VALUE;</a>
<a name="ln594">	}</a>
<a name="ln595"> </a>
<a name="ln596">	// find a range</a>
<a name="ln597">	Range* range = _FindFreeRange(address, size, alignment,</a>
<a name="ln598">		addressRestrictions-&gt;address_specification, allowReservedRange,</a>
<a name="ln599">		address);</a>
<a name="ln600">	if (range == NULL) {</a>
<a name="ln601">		return addressRestrictions-&gt;address_specification == B_EXACT_ADDRESS</a>
<a name="ln602">			? B_BAD_VALUE : B_NO_MEMORY;</a>
<a name="ln603">	}</a>
<a name="ln604"> </a>
<a name="ln605">	TRACE(&quot;  VMKernelAddressSpace::_AllocateRange() found range:(%p (%#&quot;</a>
<a name="ln606">		B_PRIxADDR &quot;, %#&quot; B_PRIxSIZE &quot;, %d)\n&quot;, range, range-&gt;base, range-&gt;size,</a>
<a name="ln607">		range-&gt;type);</a>
<a name="ln608"> </a>
<a name="ln609">	// We have found a range. It might not be a perfect fit, in which case</a>
<a name="ln610">	// we have to split the range.</a>
<a name="ln611">	size_t rangeSize = range-&gt;size;</a>
<a name="ln612"> </a>
<a name="ln613">	if (address == range-&gt;base) {</a>
<a name="ln614">		// allocation at the beginning of the range</a>
<a name="ln615">		if (range-&gt;size &gt; size) {</a>
<a name="ln616">			// only partial -- split the range</a>
<a name="ln617">			Range* leftOverRange = new(fRangesObjectCache, allocationFlags)</a>
<a name="ln618">				Range(address + size, range-&gt;size - size, range);</a>
<a name="ln619">			if (leftOverRange == NULL)</a>
<a name="ln620">				return B_NO_MEMORY;</a>
<a name="ln621"> </a>
<a name="ln622">			range-&gt;size = size;</a>
<a name="ln623">			_InsertRange(leftOverRange);</a>
<a name="ln624">		}</a>
<a name="ln625">	} else if (address + size == range-&gt;base + range-&gt;size) {</a>
<a name="ln626">		// allocation at the end of the range -- split the range</a>
<a name="ln627">		Range* leftOverRange = new(fRangesObjectCache, allocationFlags) Range(</a>
<a name="ln628">			range-&gt;base, range-&gt;size - size, range);</a>
<a name="ln629">		if (leftOverRange == NULL)</a>
<a name="ln630">			return B_NO_MEMORY;</a>
<a name="ln631"> </a>
<a name="ln632">		range-&gt;base = address;</a>
<a name="ln633">		range-&gt;size = size;</a>
<a name="ln634">		_InsertRange(leftOverRange);</a>
<a name="ln635">	} else {</a>
<a name="ln636">		// allocation in the middle of the range -- split the range in three</a>
<a name="ln637">		Range* leftOverRange1 = new(fRangesObjectCache, allocationFlags) Range(</a>
<a name="ln638">			range-&gt;base, address - range-&gt;base, range);</a>
<a name="ln639">		if (leftOverRange1 == NULL)</a>
<a name="ln640">			return B_NO_MEMORY;</a>
<a name="ln641">		Range* leftOverRange2 = new(fRangesObjectCache, allocationFlags) Range(</a>
<a name="ln642">			address + size, range-&gt;size - size - leftOverRange1-&gt;size, range);</a>
<a name="ln643">		if (leftOverRange2 == NULL) {</a>
<a name="ln644">			object_cache_delete(fRangesObjectCache, leftOverRange1,</a>
<a name="ln645">				allocationFlags);</a>
<a name="ln646">			return B_NO_MEMORY;</a>
<a name="ln647">		}</a>
<a name="ln648"> </a>
<a name="ln649">		range-&gt;base = address;</a>
<a name="ln650">		range-&gt;size = size;</a>
<a name="ln651">		_InsertRange(leftOverRange1);</a>
<a name="ln652">		_InsertRange(leftOverRange2);</a>
<a name="ln653">	}</a>
<a name="ln654"> </a>
<a name="ln655">	// If the range is a free range, remove it from the respective free list.</a>
<a name="ln656">	if (range-&gt;type == Range::RANGE_FREE)</a>
<a name="ln657">		_FreeListRemoveRange(range, rangeSize);</a>
<a name="ln658"> </a>
<a name="ln659">	IncrementChangeCount();</a>
<a name="ln660"> </a>
<a name="ln661">	TRACE(&quot;  VMKernelAddressSpace::_AllocateRange() -&gt; %p (%#&quot; B_PRIxADDR &quot;, %#&quot;</a>
<a name="ln662">		B_PRIxSIZE &quot;)\n&quot;, range, range-&gt;base, range-&gt;size);</a>
<a name="ln663"> </a>
<a name="ln664">	_range = range;</a>
<a name="ln665">	return B_OK;</a>
<a name="ln666">}</a>
<a name="ln667"> </a>
<a name="ln668"> </a>
<a name="ln669">VMKernelAddressSpace::Range*</a>
<a name="ln670">VMKernelAddressSpace::_FindFreeRange(addr_t start, size_t size,</a>
<a name="ln671">	size_t alignment, uint32 addressSpec, bool allowReservedRange,</a>
<a name="ln672">	addr_t&amp; _foundAddress)</a>
<a name="ln673">{</a>
<a name="ln674">	TRACE(&quot;  VMKernelAddressSpace::_FindFreeRange(start: %#&quot; B_PRIxADDR</a>
<a name="ln675">		&quot;, size: %#&quot; B_PRIxSIZE &quot;, alignment: %#&quot; B_PRIxSIZE &quot;, addressSpec: %#&quot;</a>
<a name="ln676">		B_PRIx32 &quot;, reserved allowed: %d)\n&quot;, start, size, alignment,</a>
<a name="ln677">		addressSpec, allowReservedRange);</a>
<a name="ln678"> </a>
<a name="ln679">	switch (addressSpec) {</a>
<a name="ln680">		case B_BASE_ADDRESS:</a>
<a name="ln681">		{</a>
<a name="ln682">			// We have to iterate through the range list starting at the given</a>
<a name="ln683">			// address. This is the most inefficient case.</a>
<a name="ln684">			Range* range = fRangeTree.FindClosest(start, true);</a>
<a name="ln685">			while (range != NULL) {</a>
<a name="ln686">				if (range-&gt;type == Range::RANGE_FREE) {</a>
<a name="ln687">					addr_t alignedBase = ROUNDUP(range-&gt;base, alignment);</a>
<a name="ln688">					if (is_valid_spot(start, alignedBase, size,</a>
<a name="ln689">							range-&gt;base + (range-&gt;size - 1))) {</a>
<a name="ln690">						_foundAddress = alignedBase;</a>
<a name="ln691">						return range;</a>
<a name="ln692">					}</a>
<a name="ln693">				}</a>
<a name="ln694">				range = fRangeList.GetNext(range);</a>
<a name="ln695">			}</a>
<a name="ln696"> </a>
<a name="ln697">			// We didn't find a free spot in the requested range, so we'll</a>
<a name="ln698">			// try again without any restrictions.</a>
<a name="ln699">			start = fBase;</a>
<a name="ln700">			addressSpec = B_ANY_ADDRESS;</a>
<a name="ln701">			// fall through...</a>
<a name="ln702">		}</a>
<a name="ln703"> </a>
<a name="ln704">		case B_ANY_ADDRESS:</a>
<a name="ln705">		case B_ANY_KERNEL_ADDRESS:</a>
<a name="ln706">		case B_ANY_KERNEL_BLOCK_ADDRESS:</a>
<a name="ln707">		{</a>
<a name="ln708">			// We want to allocate from the first non-empty free list that is</a>
<a name="ln709">			// guaranteed to contain the size. Finding a free range is O(1),</a>
<a name="ln710">			// unless there are constraints (min base address, alignment).</a>
<a name="ln711">			int freeListIndex = ld((size * 2 - 1) &gt;&gt; PAGE_SHIFT);</a>
<a name="ln712"> </a>
<a name="ln713">			for (int32 i = freeListIndex; i &lt; fFreeListCount; i++) {</a>
<a name="ln714">				RangeFreeList&amp; freeList = fFreeLists[i];</a>
<a name="ln715">				if (freeList.IsEmpty())</a>
<a name="ln716">					continue;</a>
<a name="ln717"> </a>
<a name="ln718">				for (RangeFreeList::Iterator it = freeList.GetIterator();</a>
<a name="ln719">						Range* range = it.Next();) {</a>
<a name="ln720">					addr_t alignedBase = ROUNDUP(range-&gt;base, alignment);</a>
<a name="ln721">					if (is_valid_spot(start, alignedBase, size,</a>
<a name="ln722">							range-&gt;base + (range-&gt;size - 1))) {</a>
<a name="ln723">						_foundAddress = alignedBase;</a>
<a name="ln724">						return range;</a>
<a name="ln725">					}</a>
<a name="ln726">				}</a>
<a name="ln727">			}</a>
<a name="ln728"> </a>
<a name="ln729">			if (!allowReservedRange)</a>
<a name="ln730">				return NULL;</a>
<a name="ln731"> </a>
<a name="ln732">			// We haven't found any free ranges, but we're supposed to look</a>
<a name="ln733">			// for reserved ones, too. Iterate through the range list starting</a>
<a name="ln734">			// at the given address.</a>
<a name="ln735">			Range* range = fRangeTree.FindClosest(start, true);</a>
<a name="ln736">			while (range != NULL) {</a>
<a name="ln737">				if (range-&gt;type == Range::RANGE_RESERVED) {</a>
<a name="ln738">					addr_t alignedBase = ROUNDUP(range-&gt;base, alignment);</a>
<a name="ln739">					if (is_valid_spot(start, alignedBase, size,</a>
<a name="ln740">							range-&gt;base + (range-&gt;size - 1))) {</a>
<a name="ln741">						// allocation from the back might be preferred</a>
<a name="ln742">						// -- adjust the base accordingly</a>
<a name="ln743">						if ((range-&gt;reserved.flags &amp; RESERVED_AVOID_BASE)</a>
<a name="ln744">								!= 0) {</a>
<a name="ln745">							alignedBase = ROUNDDOWN(</a>
<a name="ln746">								range-&gt;base + (range-&gt;size - size), alignment);</a>
<a name="ln747">						}</a>
<a name="ln748"> </a>
<a name="ln749">						_foundAddress = alignedBase;</a>
<a name="ln750">						return range;</a>
<a name="ln751">					}</a>
<a name="ln752">				}</a>
<a name="ln753">				range = fRangeList.GetNext(range);</a>
<a name="ln754">			}</a>
<a name="ln755"> </a>
<a name="ln756">			return NULL;</a>
<a name="ln757">		}</a>
<a name="ln758"> </a>
<a name="ln759">		case B_EXACT_ADDRESS:</a>
<a name="ln760">		{</a>
<a name="ln761">			Range* range = fRangeTree.FindClosest(start, true);</a>
<a name="ln762">TRACE(&quot;    B_EXACT_ADDRESS: range: %p\n&quot;, range);</a>
<a name="ln763">			if (range == NULL || range-&gt;type == Range::RANGE_AREA</a>
<a name="ln764">				|| range-&gt;base + (range-&gt;size - 1) &lt; start + (size - 1)) {</a>
<a name="ln765">				// TODO: Support allocating if the area range covers multiple</a>
<a name="ln766">				// free and reserved ranges!</a>
<a name="ln767">TRACE(&quot;    -&gt; no suitable range\n&quot;);</a>
<a name="ln768">				return NULL;</a>
<a name="ln769">			}</a>
<a name="ln770"> </a>
<a name="ln771">			if (range-&gt;type != Range::RANGE_FREE &amp;&amp; !allowReservedRange)</a>
<a name="ln772">{</a>
<a name="ln773">TRACE(&quot;    -&gt; reserved range not allowed\n&quot;);</a>
<a name="ln774">				return NULL;</a>
<a name="ln775">}</a>
<a name="ln776"> </a>
<a name="ln777">			_foundAddress = start;</a>
<a name="ln778">			return range;</a>
<a name="ln779">		}</a>
<a name="ln780"> </a>
<a name="ln781">		default:</a>
<a name="ln782">			return NULL;</a>
<a name="ln783">	}</a>
<a name="ln784">}</a>
<a name="ln785"> </a>
<a name="ln786"> </a>
<a name="ln787">void</a>
<a name="ln788">VMKernelAddressSpace::_FreeRange(Range* range, uint32 allocationFlags)</a>
<a name="ln789">{</a>
<a name="ln790">	TRACE(&quot;  VMKernelAddressSpace::_FreeRange(%p (%#&quot; B_PRIxADDR &quot;, %#&quot;</a>
<a name="ln791">		B_PRIxSIZE &quot;, %d))\n&quot;, range, range-&gt;base, range-&gt;size, range-&gt;type);</a>
<a name="ln792"> </a>
<a name="ln793">	// Check whether one or both of the neighboring ranges are free already,</a>
<a name="ln794">	// and join them, if so.</a>
<a name="ln795">	Range* previousRange = fRangeList.GetPrevious(range);</a>
<a name="ln796">	Range* nextRange = fRangeList.GetNext(range);</a>
<a name="ln797"> </a>
<a name="ln798">	if (previousRange != NULL &amp;&amp; previousRange-&gt;type == Range::RANGE_FREE) {</a>
<a name="ln799">		if (nextRange != NULL &amp;&amp; nextRange-&gt;type == Range::RANGE_FREE) {</a>
<a name="ln800">			// join them all -- keep the first one, delete the others</a>
<a name="ln801">			_FreeListRemoveRange(previousRange, previousRange-&gt;size);</a>
<a name="ln802">			_RemoveRange(range);</a>
<a name="ln803">			_RemoveRange(nextRange);</a>
<a name="ln804">			previousRange-&gt;size += range-&gt;size + nextRange-&gt;size;</a>
<a name="ln805">			object_cache_delete(fRangesObjectCache, range, allocationFlags);</a>
<a name="ln806">			object_cache_delete(fRangesObjectCache, nextRange, allocationFlags);</a>
<a name="ln807">			_FreeListInsertRange(previousRange, previousRange-&gt;size);</a>
<a name="ln808">		} else {</a>
<a name="ln809">			// join with the previous range only, delete the supplied one</a>
<a name="ln810">			_FreeListRemoveRange(previousRange, previousRange-&gt;size);</a>
<a name="ln811">			_RemoveRange(range);</a>
<a name="ln812">			previousRange-&gt;size += range-&gt;size;</a>
<a name="ln813">			object_cache_delete(fRangesObjectCache, range, allocationFlags);</a>
<a name="ln814">			_FreeListInsertRange(previousRange, previousRange-&gt;size);</a>
<a name="ln815">		}</a>
<a name="ln816">	} else {</a>
<a name="ln817">		if (nextRange != NULL &amp;&amp; nextRange-&gt;type == Range::RANGE_FREE) {</a>
<a name="ln818">			// join with the next range and delete it</a>
<a name="ln819">			_RemoveRange(nextRange);</a>
<a name="ln820">			range-&gt;size += nextRange-&gt;size;</a>
<a name="ln821">			object_cache_delete(fRangesObjectCache, nextRange, allocationFlags);</a>
<a name="ln822">		}</a>
<a name="ln823"> </a>
<a name="ln824">		// mark the range free and add it to the respective free list</a>
<a name="ln825">		range-&gt;type = Range::RANGE_FREE;</a>
<a name="ln826">		_FreeListInsertRange(range, range-&gt;size);</a>
<a name="ln827">	}</a>
<a name="ln828"> </a>
<a name="ln829">	IncrementChangeCount();</a>
<a name="ln830">}</a>
<a name="ln831"> </a>
<a name="ln832"> </a>
<a name="ln833">#ifdef PARANOIA_CHECKS</a>
<a name="ln834"> </a>
<a name="ln835">void</a>
<a name="ln836">VMKernelAddressSpace::_CheckStructures() const</a>
<a name="ln837">{</a>
<a name="ln838">	// general tree structure check</a>
<a name="ln839">	fRangeTree.CheckTree();</a>
<a name="ln840"> </a>
<a name="ln841">	// check range list and tree</a>
<a name="ln842">	size_t spaceSize = fEndAddress - fBase + 1;</a>
<a name="ln843">	addr_t nextBase = fBase;</a>
<a name="ln844">	Range* previousRange = NULL;</a>
<a name="ln845">	int previousRangeType = Range::RANGE_AREA;</a>
<a name="ln846">	uint64 freeRanges = 0;</a>
<a name="ln847"> </a>
<a name="ln848">	RangeList::ConstIterator listIt = fRangeList.GetIterator();</a>
<a name="ln849">	RangeTree::ConstIterator treeIt = fRangeTree.GetIterator();</a>
<a name="ln850">	while (true) {</a>
<a name="ln851">		Range* range = listIt.Next();</a>
<a name="ln852">		Range* treeRange = treeIt.Next();</a>
<a name="ln853">		if (range != treeRange) {</a>
<a name="ln854">			panic(&quot;VMKernelAddressSpace::_CheckStructures(): list/tree range &quot;</a>
<a name="ln855">				&quot;mismatch: %p vs %p&quot;, range, treeRange);</a>
<a name="ln856">		}</a>
<a name="ln857">		if (range == NULL)</a>
<a name="ln858">			break;</a>
<a name="ln859"> </a>
<a name="ln860">		if (range-&gt;base != nextBase) {</a>
<a name="ln861">			panic(&quot;VMKernelAddressSpace::_CheckStructures(): range base %#&quot;</a>
<a name="ln862">				B_PRIxADDR &quot;, expected: %#&quot; B_PRIxADDR, range-&gt;base, nextBase);</a>
<a name="ln863">		}</a>
<a name="ln864"> </a>
<a name="ln865">		if (range-&gt;size == 0) {</a>
<a name="ln866">			panic(&quot;VMKernelAddressSpace::_CheckStructures(): empty range %p&quot;,</a>
<a name="ln867">				range);</a>
<a name="ln868">		}</a>
<a name="ln869"> </a>
<a name="ln870">		if (range-&gt;size % B_PAGE_SIZE != 0) {</a>
<a name="ln871">			panic(&quot;VMKernelAddressSpace::_CheckStructures(): range %p (%#&quot;</a>
<a name="ln872">				B_PRIxADDR &quot;, %#&quot; B_PRIxSIZE &quot;) not page aligned&quot;, range,</a>
<a name="ln873">				range-&gt;base, range-&gt;size);</a>
<a name="ln874">		}</a>
<a name="ln875"> </a>
<a name="ln876">		if (range-&gt;size &gt; spaceSize - (range-&gt;base - fBase)) {</a>
<a name="ln877">			panic(&quot;VMKernelAddressSpace::_CheckStructures(): range too large: &quot;</a>
<a name="ln878">				&quot;(%#&quot; B_PRIxADDR &quot;, %#&quot; B_PRIxSIZE &quot;), address space end: %#&quot;</a>
<a name="ln879">				B_PRIxADDR, range-&gt;base, range-&gt;size, fEndAddress);</a>
<a name="ln880">		}</a>
<a name="ln881"> </a>
<a name="ln882">		if (range-&gt;type == Range::RANGE_FREE) {</a>
<a name="ln883">			freeRanges++;</a>
<a name="ln884"> </a>
<a name="ln885">			if (previousRangeType == Range::RANGE_FREE) {</a>
<a name="ln886">				panic(&quot;VMKernelAddressSpace::_CheckStructures(): adjoining &quot;</a>
<a name="ln887">					&quot;free ranges: %p (%#&quot; B_PRIxADDR &quot;, %#&quot; B_PRIxSIZE</a>
<a name="ln888">					&quot;), %p (%#&quot; B_PRIxADDR &quot;, %#&quot; B_PRIxSIZE &quot;)&quot;, previousRange,</a>
<a name="ln889">					previousRange-&gt;base, previousRange-&gt;size, range,</a>
<a name="ln890">					range-&gt;base, range-&gt;size);</a>
<a name="ln891">			}</a>
<a name="ln892">		}</a>
<a name="ln893"> </a>
<a name="ln894">		previousRange = range;</a>
<a name="ln895">		nextBase = range-&gt;base + range-&gt;size;</a>
<a name="ln896">		previousRangeType = range-&gt;type;</a>
<a name="ln897">	}</a>
<a name="ln898"> </a>
<a name="ln899">	if (nextBase - 1 != fEndAddress) {</a>
<a name="ln900">		panic(&quot;VMKernelAddressSpace::_CheckStructures(): space not fully &quot;</a>
<a name="ln901">			&quot;covered by ranges: last: %#&quot; B_PRIxADDR &quot;, expected %#&quot; B_PRIxADDR,</a>
<a name="ln902">			nextBase - 1, fEndAddress);</a>
<a name="ln903">	}</a>
<a name="ln904"> </a>
<a name="ln905">	// check free lists</a>
<a name="ln906">	uint64 freeListRanges = 0;</a>
<a name="ln907">	for (int i = 0; i &lt; fFreeListCount; i++) {</a>
<a name="ln908">		RangeFreeList&amp; freeList = fFreeLists[i];</a>
<a name="ln909">		if (freeList.IsEmpty())</a>
<a name="ln910">			continue;</a>
<a name="ln911"> </a>
<a name="ln912">		for (RangeFreeList::Iterator it = freeList.GetIterator();</a>
<a name="ln913">				Range* range = it.Next();) {</a>
<a name="ln914">			if (range-&gt;type != Range::RANGE_FREE) {</a>
<a name="ln915">				panic(&quot;VMKernelAddressSpace::_CheckStructures(): non-free &quot;</a>
<a name="ln916">					&quot;range %p (%#&quot; B_PRIxADDR &quot;, %#&quot; B_PRIxSIZE &quot;, %d) in &quot;</a>
<a name="ln917">					&quot;free list %d&quot;, range, range-&gt;base, range-&gt;size,</a>
<a name="ln918">					range-&gt;type, i);</a>
<a name="ln919">			}</a>
<a name="ln920"> </a>
<a name="ln921">			if (fRangeTree.Find(range-&gt;base) != range) {</a>
<a name="ln922">				panic(&quot;VMKernelAddressSpace::_CheckStructures(): unknown &quot;</a>
<a name="ln923">					&quot;range %p (%#&quot; B_PRIxADDR &quot;, %#&quot; B_PRIxSIZE &quot;, %d) in &quot;</a>
<a name="ln924">					&quot;free list %d&quot;, range, range-&gt;base, range-&gt;size,</a>
<a name="ln925">					range-&gt;type, i);</a>
<a name="ln926">			}</a>
<a name="ln927"> </a>
<a name="ln928">			if (ld(range-&gt;size) - PAGE_SHIFT != i) {</a>
<a name="ln929">				panic(&quot;VMKernelAddressSpace::_CheckStructures(): &quot;</a>
<a name="ln930">					&quot;range %p (%#&quot; B_PRIxADDR &quot;, %#&quot; B_PRIxSIZE &quot;, %d) in &quot;</a>
<a name="ln931">					&quot;wrong free list %d&quot;, range, range-&gt;base, range-&gt;size,</a>
<a name="ln932">					range-&gt;type, i);</a>
<a name="ln933">			}</a>
<a name="ln934"> </a>
<a name="ln935">			freeListRanges++;</a>
<a name="ln936">		}</a>
<a name="ln937">	}</a>
<a name="ln938">}</a>
<a name="ln939"> </a>
<a name="ln940">#endif	// PARANOIA_CHECKS</a>

</code></pre>
<div class="balloon" rel="71"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fFreeLists, fFreeListCount.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
