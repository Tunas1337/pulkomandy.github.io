
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>AppFileInfo.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2002-2014, Haiku, Inc.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Ingo Weinhold, ingo_weinhold@gmx.de</a>
<a name="ln7"> */</a>
<a name="ln8"> </a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;new&gt;</a>
<a name="ln11">#include &lt;set&gt;</a>
<a name="ln12">#include &lt;stdlib.h&gt;</a>
<a name="ln13">#include &lt;string&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;AppFileInfo.h&gt;</a>
<a name="ln16">#include &lt;Bitmap.h&gt;</a>
<a name="ln17">#include &lt;File.h&gt;</a>
<a name="ln18">#include &lt;fs_attr.h&gt;</a>
<a name="ln19">#include &lt;IconUtils.h&gt;</a>
<a name="ln20">#include &lt;MimeType.h&gt;</a>
<a name="ln21">#include &lt;RegistrarDefs.h&gt;</a>
<a name="ln22">#include &lt;Resources.h&gt;</a>
<a name="ln23">#include &lt;Roster.h&gt;</a>
<a name="ln24">#include &lt;String.h&gt;</a>
<a name="ln25"> </a>
<a name="ln26"> </a>
<a name="ln27">// debugging</a>
<a name="ln28">//#define DBG(x) x</a>
<a name="ln29">#define DBG(x)</a>
<a name="ln30">#define OUT	printf</a>
<a name="ln31"> </a>
<a name="ln32"> </a>
<a name="ln33">// type codes</a>
<a name="ln34">enum {</a>
<a name="ln35">	B_APP_FLAGS_TYPE	= 'APPF',</a>
<a name="ln36">	B_VERSION_INFO_TYPE	= 'APPV',</a>
<a name="ln37">};</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">// attributes</a>
<a name="ln41">static const char* kTypeAttribute				= &quot;BEOS:TYPE&quot;;</a>
<a name="ln42">static const char* kSignatureAttribute			= &quot;BEOS:APP_SIG&quot;;</a>
<a name="ln43">static const char* kAppFlagsAttribute			= &quot;BEOS:APP_FLAGS&quot;;</a>
<a name="ln44">static const char* kSupportedTypesAttribute		= &quot;BEOS:FILE_TYPES&quot;;</a>
<a name="ln45">static const char* kVersionInfoAttribute		= &quot;BEOS:APP_VERSION&quot;;</a>
<a name="ln46">static const char* kMiniIconAttribute			= &quot;BEOS:M:&quot;;</a>
<a name="ln47">static const char* kLargeIconAttribute			= &quot;BEOS:L:&quot;;</a>
<a name="ln48">static const char* kIconAttribute				= &quot;BEOS:&quot;;</a>
<a name="ln49">static const char* kStandardIconType			= &quot;STD_ICON&quot;;</a>
<a name="ln50">static const char* kIconType					= &quot;ICON&quot;;</a>
<a name="ln51">static const char* kCatalogEntryAttribute		= &quot;SYS:NAME&quot;;</a>
<a name="ln52"> </a>
<a name="ln53">// resource IDs</a>
<a name="ln54">static const int32 kTypeResourceID				= 2;</a>
<a name="ln55">static const int32 kSignatureResourceID			= 1;</a>
<a name="ln56">static const int32 kAppFlagsResourceID			= 1;</a>
<a name="ln57">static const int32 kSupportedTypesResourceID	= 1;</a>
<a name="ln58">static const int32 kMiniIconResourceID			= 101;</a>
<a name="ln59">static const int32 kLargeIconResourceID			= 101;</a>
<a name="ln60">static const int32 kIconResourceID				= 101;</a>
<a name="ln61">static const int32 kVersionInfoResourceID		= 1;</a>
<a name="ln62">static const int32 kMiniIconForTypeResourceID	= 0;</a>
<a name="ln63">static const int32 kLargeIconForTypeResourceID	= 0;</a>
<a name="ln64">static const int32 kIconForTypeResourceID		= 0;</a>
<a name="ln65">static const int32 kCatalogEntryResourceID		= 1;</a>
<a name="ln66"> </a>
<a name="ln67">// R5 also exports these (Tracker is using them):</a>
<a name="ln68">// (maybe we better want to drop them silently and declare</a>
<a name="ln69">// the above in a public Haiku header - and use that one in</a>
<a name="ln70">// Tracker when compiled for Haiku)</a>
<a name="ln71">extern const uint32 MINI_ICON_TYPE, LARGE_ICON_TYPE;</a>
<a name="ln72">const uint32 MINI_ICON_TYPE = 'MICN';</a>
<a name="ln73">const uint32 LARGE_ICON_TYPE = 'ICON';</a>
<a name="ln74"> </a>
<a name="ln75"> </a>
<a name="ln76">BAppFileInfo::BAppFileInfo()</a>
<a name="ln77">	:</a>
<a name="ln78">	fResources(NULL),</a>
<a name="ln79">	fWhere(B_USE_BOTH_LOCATIONS)</a>
<a name="ln80">{</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83"> </a>
<a name="ln84">BAppFileInfo::BAppFileInfo(BFile* file)</a>
<a name="ln85">	:</a>
<a name="ln86">	fResources(NULL),</a>
<a name="ln87">	fWhere(B_USE_BOTH_LOCATIONS)</a>
<a name="ln88">{</a>
<a name="ln89">	SetTo(file);</a>
<a name="ln90">}</a>
<a name="ln91"> </a>
<a name="ln92"> </a>
<a name="ln93">BAppFileInfo::~BAppFileInfo()</a>
<a name="ln94">{</a>
<a name="ln95">	delete fResources;</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98"> </a>
<a name="ln99">status_t</a>
<a name="ln100">BAppFileInfo::SetTo(BFile* file)</a>
<a name="ln101">{</a>
<a name="ln102">	// unset the old file</a>
<a name="ln103">	BNodeInfo::SetTo(NULL);</a>
<a name="ln104">	if (fResources) {</a>
<a name="ln105">		delete fResources;</a>
<a name="ln106">		fResources = NULL;</a>
<a name="ln107">	}</a>
<a name="ln108"> </a>
<a name="ln109">	// check param</a>
<a name="ln110">	status_t error</a>
<a name="ln111">		= file != NULL &amp;&amp; file-&gt;InitCheck() == B_OK ? B_OK : B_BAD_VALUE;</a>
<a name="ln112"> </a>
<a name="ln113">	info_location where = B_USE_BOTH_LOCATIONS;</a>
<a name="ln114"> </a>
<a name="ln115">	// create resources</a>
<a name="ln116">	if (error == B_OK) {</a>
<a name="ln117">		fResources = new(std::nothrow) BResources();</a>
<a name="ln118">		if (fResources) {</a>
<a name="ln119">			error = fResources-&gt;SetTo(file);</a>
<a name="ln120">			if (error != B_OK) {</a>
<a name="ln121">				// no resources - this is no critical error, we'll just use</a>
<a name="ln122">				// attributes only, then</a>
<a name="ln123">				where = B_USE_ATTRIBUTES;</a>
<a name="ln124">				error = B_OK;</a>
<a name="ln125">			}</a>
<a name="ln126">		} else</a>
<a name="ln127">			error = B_NO_MEMORY;</a>
<a name="ln128">	}</a>
<a name="ln129"> </a>
<a name="ln130">	// set node info</a>
<a name="ln131">	if (error == B_OK)</a>
<a name="ln132">		error = BNodeInfo::SetTo(file);</a>
<a name="ln133"> </a>
<a name="ln134">	if (error != B_OK || (where &amp; B_USE_RESOURCES) == 0) {</a>
<a name="ln135">		delete fResources;</a>
<a name="ln136">		fResources = NULL;</a>
<a name="ln137">	}</a>
<a name="ln138"> </a>
<a name="ln139">	// clean up on error</a>
<a name="ln140">	if (error != B_OK) {</a>
<a name="ln141">		if (InitCheck() == B_OK)</a>
<a name="ln142">			BNodeInfo::SetTo(NULL);</a>
<a name="ln143">	}</a>
<a name="ln144"> </a>
<a name="ln145">	// set data location</a>
<a name="ln146">	if (error == B_OK)</a>
<a name="ln147">		SetInfoLocation(where);</a>
<a name="ln148"> </a>
<a name="ln149">	// set error</a>
<a name="ln150">	fCStatus = error;</a>
<a name="ln151">	return error;</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154"> </a>
<a name="ln155">status_t</a>
<a name="ln156">BAppFileInfo::GetType(char* type) const</a>
<a name="ln157">{</a>
<a name="ln158">	// check param and initialization</a>
<a name="ln159">	status_t error = type != NULL ? B_OK : B_BAD_VALUE;</a>
<a name="ln160">	if (error == B_OK &amp;&amp; InitCheck() != B_OK)</a>
<a name="ln161">		error = B_NO_INIT;</a>
<a name="ln162">	// read the data</a>
<a name="ln163">	size_t read = 0;</a>
<a name="ln164">	if (error == B_OK) {</a>
<a name="ln165">		error = _ReadData(kTypeAttribute, kTypeResourceID, B_MIME_STRING_TYPE,</a>
<a name="ln166">			type, B_MIME_TYPE_LENGTH, read);</a>
<a name="ln167">	}</a>
<a name="ln168">	// check the read data -- null terminate the string</a>
<a name="ln169">	if (error == B_OK &amp;&amp; type[read - 1] != '\0') {</a>
<a name="ln170">		if (read == B_MIME_TYPE_LENGTH)</a>
<a name="ln171">			error = B_ERROR;</a>
<a name="ln172">		else</a>
<a name="ln173">			type[read] = '\0';</a>
<a name="ln174">	}</a>
<a name="ln175">	return error;</a>
<a name="ln176">}</a>
<a name="ln177"> </a>
<a name="ln178"> </a>
<a name="ln179">status_t</a>
<a name="ln180">BAppFileInfo::SetType(const char* type)</a>
<a name="ln181">{</a>
<a name="ln182">	// check initialization</a>
<a name="ln183">	status_t error = B_OK;</a>
<a name="ln184">	if (InitCheck() != B_OK)</a>
<a name="ln185">		error = B_NO_INIT;</a>
<a name="ln186">	if (error == B_OK) {</a>
<a name="ln187">		if (type != NULL) {</a>
<a name="ln188">			// check param</a>
<a name="ln189">			size_t typeLen = strlen(type);</a>
<a name="ln190">			if (typeLen &gt;= B_MIME_TYPE_LENGTH)</a>
<a name="ln191">				error = B_BAD_VALUE;</a>
<a name="ln192">			// write the data</a>
<a name="ln193">			if (error == B_OK) {</a>
<a name="ln194">				error = _WriteData(kTypeAttribute, kTypeResourceID,</a>
<a name="ln195">					B_MIME_STRING_TYPE, type, typeLen + 1);</a>
<a name="ln196">			}</a>
<a name="ln197">		} else</a>
<a name="ln198">			error = _RemoveData(kTypeAttribute, B_MIME_STRING_TYPE);</a>
<a name="ln199">	}</a>
<a name="ln200">	return error;</a>
<a name="ln201">}</a>
<a name="ln202"> </a>
<a name="ln203"> </a>
<a name="ln204">status_t</a>
<a name="ln205">BAppFileInfo::GetSignature(char* signature) const</a>
<a name="ln206">{</a>
<a name="ln207">	// check param and initialization</a>
<a name="ln208">	status_t error = (signature ? B_OK : B_BAD_VALUE);</a>
<a name="ln209">	if (error == B_OK &amp;&amp; InitCheck() != B_OK)</a>
<a name="ln210">		error = B_NO_INIT;</a>
<a name="ln211">	// read the data</a>
<a name="ln212">	size_t read = 0;</a>
<a name="ln213">	if (error == B_OK) {</a>
<a name="ln214">		error = _ReadData(kSignatureAttribute, kSignatureResourceID,</a>
<a name="ln215">			B_MIME_STRING_TYPE, signature, B_MIME_TYPE_LENGTH, read);</a>
<a name="ln216">	}</a>
<a name="ln217">	// check the read data -- null terminate the string</a>
<a name="ln218">	if (error == B_OK &amp;&amp; signature[read - 1] != '\0') {</a>
<a name="ln219">		if (read == B_MIME_TYPE_LENGTH)</a>
<a name="ln220">			error = B_ERROR;</a>
<a name="ln221">		else</a>
<a name="ln222">			signature[read] = '\0';</a>
<a name="ln223">	}</a>
<a name="ln224">	return error;</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227"> </a>
<a name="ln228">status_t</a>
<a name="ln229">BAppFileInfo::SetSignature(const char* signature)</a>
<a name="ln230">{</a>
<a name="ln231">	// check initialization</a>
<a name="ln232">	status_t error = B_OK;</a>
<a name="ln233">	if (InitCheck() != B_OK)</a>
<a name="ln234">		error = B_NO_INIT;</a>
<a name="ln235">	if (error == B_OK) {</a>
<a name="ln236">		if (signature) {</a>
<a name="ln237">			// check param</a>
<a name="ln238">			size_t signatureLen = strlen(signature);</a>
<a name="ln239">			if (signatureLen &gt;= B_MIME_TYPE_LENGTH)</a>
<a name="ln240">				error = B_BAD_VALUE;</a>
<a name="ln241">			// write the data</a>
<a name="ln242">			if (error == B_OK) {</a>
<a name="ln243">				error = _WriteData(kSignatureAttribute, kSignatureResourceID,</a>
<a name="ln244">					B_MIME_STRING_TYPE, signature, signatureLen + 1);</a>
<a name="ln245">			}</a>
<a name="ln246">		} else</a>
<a name="ln247">			error = _RemoveData(kSignatureAttribute, B_MIME_STRING_TYPE);</a>
<a name="ln248">	}</a>
<a name="ln249">	return error;</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252"> </a>
<a name="ln253">status_t</a>
<a name="ln254">BAppFileInfo::GetCatalogEntry(char* catalogEntry) const</a>
<a name="ln255">{</a>
<a name="ln256">	if (catalogEntry == NULL)</a>
<a name="ln257">		return B_BAD_VALUE;</a>
<a name="ln258"> </a>
<a name="ln259">	if (InitCheck() != B_OK)</a>
<a name="ln260">		return B_NO_INIT;</a>
<a name="ln261"> </a>
<a name="ln262">	size_t read = 0;</a>
<a name="ln263">	status_t error = _ReadData(kCatalogEntryAttribute, kCatalogEntryResourceID,</a>
<a name="ln264">		B_STRING_TYPE, catalogEntry, B_MIME_TYPE_LENGTH * 3, read);</a>
<a name="ln265"> </a>
<a name="ln266">	if (error != B_OK)</a>
<a name="ln267">		return error;</a>
<a name="ln268"> </a>
<a name="ln269">	if (read &gt;= B_MIME_TYPE_LENGTH * 3)</a>
<a name="ln270">		return B_ERROR;</a>
<a name="ln271"> </a>
<a name="ln272">	catalogEntry[read] = '\0';</a>
<a name="ln273"> </a>
<a name="ln274">	return B_OK;</a>
<a name="ln275">}</a>
<a name="ln276"> </a>
<a name="ln277"> </a>
<a name="ln278">status_t</a>
<a name="ln279">BAppFileInfo::SetCatalogEntry(const char* catalogEntry)</a>
<a name="ln280">{</a>
<a name="ln281">	if (InitCheck() != B_OK)</a>
<a name="ln282">		return B_NO_INIT;</a>
<a name="ln283"> </a>
<a name="ln284">	if (catalogEntry == NULL)</a>
<a name="ln285">		return _RemoveData(kCatalogEntryAttribute, B_STRING_TYPE);</a>
<a name="ln286"> </a>
<a name="ln287">	size_t nameLength = strlen(catalogEntry);</a>
<a name="ln288">	if (nameLength &gt; B_MIME_TYPE_LENGTH * 3)</a>
<a name="ln289">		return B_BAD_VALUE;</a>
<a name="ln290"> </a>
<a name="ln291">	return _WriteData(kCatalogEntryAttribute, kCatalogEntryResourceID,</a>
<a name="ln292">		B_STRING_TYPE, catalogEntry, nameLength + 1);</a>
<a name="ln293">}</a>
<a name="ln294"> </a>
<a name="ln295"> </a>
<a name="ln296">status_t</a>
<a name="ln297">BAppFileInfo::GetAppFlags(uint32* flags) const</a>
<a name="ln298">{</a>
<a name="ln299">	// check param and initialization</a>
<a name="ln300">	status_t error = flags != NULL ? B_OK : B_BAD_VALUE;</a>
<a name="ln301">	if (error == B_OK &amp;&amp; InitCheck() != B_OK)</a>
<a name="ln302">		error = B_NO_INIT;</a>
<a name="ln303">	// read the data</a>
<a name="ln304">	size_t read = 0;</a>
<a name="ln305">	if (error == B_OK) {</a>
<a name="ln306">		error = _ReadData(kAppFlagsAttribute, kAppFlagsResourceID,</a>
<a name="ln307">			B_APP_FLAGS_TYPE, flags, sizeof(uint32), read);</a>
<a name="ln308">	}</a>
<a name="ln309">	// check the read data</a>
<a name="ln310">	if (error == B_OK &amp;&amp; read != sizeof(uint32))</a>
<a name="ln311">		error = B_ERROR;</a>
<a name="ln312">	return error;</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315"> </a>
<a name="ln316">status_t</a>
<a name="ln317">BAppFileInfo::SetAppFlags(uint32 flags)</a>
<a name="ln318">{</a>
<a name="ln319">	// check initialization</a>
<a name="ln320">	status_t error = B_OK;</a>
<a name="ln321">	if (InitCheck() != B_OK)</a>
<a name="ln322">		error = B_NO_INIT;</a>
<a name="ln323">	if (error == B_OK) {</a>
<a name="ln324">		// write the data</a>
<a name="ln325">		error = _WriteData(kAppFlagsAttribute, kAppFlagsResourceID,</a>
<a name="ln326">			B_APP_FLAGS_TYPE, &amp;flags, sizeof(uint32));</a>
<a name="ln327">	}</a>
<a name="ln328">	return error;</a>
<a name="ln329">}</a>
<a name="ln330"> </a>
<a name="ln331"> </a>
<a name="ln332">status_t</a>
<a name="ln333">BAppFileInfo::RemoveAppFlags()</a>
<a name="ln334">{</a>
<a name="ln335">	// check initialization</a>
<a name="ln336">	status_t error = B_OK;</a>
<a name="ln337">	if (InitCheck() != B_OK)</a>
<a name="ln338">		error = B_NO_INIT;</a>
<a name="ln339">	if (error == B_OK) {</a>
<a name="ln340">		// remove the data</a>
<a name="ln341">		error = _RemoveData(kAppFlagsAttribute, B_APP_FLAGS_TYPE);</a>
<a name="ln342">	}</a>
<a name="ln343">	return error;</a>
<a name="ln344">}</a>
<a name="ln345"> </a>
<a name="ln346"> </a>
<a name="ln347">status_t</a>
<a name="ln348">BAppFileInfo::GetSupportedTypes(BMessage* types) const</a>
<a name="ln349">{</a>
<a name="ln350">	// check param and initialization</a>
<a name="ln351">	status_t error = types != NULL ? B_OK : B_BAD_VALUE;</a>
<a name="ln352">	if (error == B_OK &amp;&amp; InitCheck() != B_OK)</a>
<a name="ln353">		error = B_NO_INIT;</a>
<a name="ln354">	// read the data</a>
<a name="ln355">	size_t read = 0;</a>
<a name="ln356">	void* buffer = NULL;</a>
<a name="ln357">	if (error == B_OK) {</a>
<a name="ln358">		error = _ReadData(kSupportedTypesAttribute, kSupportedTypesResourceID,</a>
<a name="ln359">			B_MESSAGE_TYPE, NULL, 0, read, &amp;buffer);</a>
<a name="ln360">	}</a>
<a name="ln361">	// unflatten the buffer</a>
<a name="ln362">	if (error == B_OK)</a>
<a name="ln363">		error = types-&gt;Unflatten((const char*)buffer);</a>
<a name="ln364">	// clean up</a>
<a name="ln365">	free(buffer);</a>
<a name="ln366">	return error;</a>
<a name="ln367">}</a>
<a name="ln368"> </a>
<a name="ln369"> </a>
<a name="ln370">status_t</a>
<a name="ln371">BAppFileInfo::SetSupportedTypes(const BMessage* types, bool updateMimeDB,</a>
<a name="ln372">	bool syncAll)</a>
<a name="ln373">{</a>
<a name="ln374">	// check initialization</a>
<a name="ln375">	status_t error = B_OK;</a>
<a name="ln376">	if (InitCheck() != B_OK)</a>
<a name="ln377">		error = B_NO_INIT;</a>
<a name="ln378"> </a>
<a name="ln379">	BMimeType mimeType;</a>
<a name="ln380">	if (error == B_OK)</a>
<a name="ln381">		error = GetMetaMime(&amp;mimeType);</a>
<a name="ln382"> </a>
<a name="ln383">	if (error == B_OK || error == B_ENTRY_NOT_FOUND) {</a>
<a name="ln384">		error = B_OK;</a>
<a name="ln385">		if (types) {</a>
<a name="ln386">			// check param -- supported types must be valid</a>
<a name="ln387">			const char* type;</a>
<a name="ln388">			for (int32 i = 0;</a>
<a name="ln389">				 error == B_OK &amp;&amp; types-&gt;FindString(&quot;types&quot;, i, &amp;type) == B_OK;</a>
<a name="ln390">				 i++) {</a>
<a name="ln391">				if (!BMimeType::IsValid(type))</a>
<a name="ln392">					error = B_BAD_VALUE;</a>
<a name="ln393">			}</a>
<a name="ln394"> </a>
<a name="ln395">			// get flattened size</a>
<a name="ln396">			ssize_t size = 0;</a>
<a name="ln397">			if (error == B_OK) {</a>
<a name="ln398">				size = types-&gt;FlattenedSize();</a>
<a name="ln399">				if (size &lt; 0)</a>
<a name="ln400">					error = size;</a>
<a name="ln401">			}</a>
<a name="ln402"> </a>
<a name="ln403">			// allocate a buffer for the flattened data</a>
<a name="ln404">			char* buffer = NULL;</a>
<a name="ln405">			if (error == B_OK) {</a>
<a name="ln406">				buffer = new(std::nothrow) char[size];</a>
<a name="ln407">				if (!buffer)</a>
<a name="ln408">					error = B_NO_MEMORY;</a>
<a name="ln409">			}</a>
<a name="ln410"> </a>
<a name="ln411">			// flatten the message</a>
<a name="ln412">			if (error == B_OK)</a>
<a name="ln413">				error = types-&gt;Flatten(buffer, size);</a>
<a name="ln414"> </a>
<a name="ln415">			// write the data</a>
<a name="ln416">			if (error == B_OK) {</a>
<a name="ln417">				error = _WriteData(kSupportedTypesAttribute,</a>
<a name="ln418">					kSupportedTypesResourceID, B_MESSAGE_TYPE, buffer, size);</a>
<a name="ln419">			}</a>
<a name="ln420"> </a>
<a name="ln421">			delete[] buffer;</a>
<a name="ln422">		} else</a>
<a name="ln423">			error = _RemoveData(kSupportedTypesAttribute, B_MESSAGE_TYPE);</a>
<a name="ln424"> </a>
<a name="ln425">		// update the MIME database, if the app signature is installed</a>
<a name="ln426">#if 0</a>
<a name="ln427">		if (updateMimeDB &amp;&amp; error == B_OK &amp;&amp; mimeType.IsInstalled())</a>
<a name="ln428">			error = mimeType.SetSupportedTypes(types, syncAll);</a>
<a name="ln429">#endif</a>
<a name="ln430">	}</a>
<a name="ln431">	return error;</a>
<a name="ln432">}</a>
<a name="ln433"> </a>
<a name="ln434"> </a>
<a name="ln435">status_t</a>
<a name="ln436">BAppFileInfo::SetSupportedTypes(const BMessage* types, bool syncAll)</a>
<a name="ln437">{</a>
<a name="ln438">	return SetSupportedTypes(types, true, syncAll);</a>
<a name="ln439">}</a>
<a name="ln440"> </a>
<a name="ln441"> </a>
<a name="ln442">status_t</a>
<a name="ln443">BAppFileInfo::SetSupportedTypes(const BMessage* types)</a>
<a name="ln444">{</a>
<a name="ln445">	return SetSupportedTypes(types, true, false);</a>
<a name="ln446">}</a>
<a name="ln447"> </a>
<a name="ln448"> </a>
<a name="ln449">bool</a>
<a name="ln450">BAppFileInfo::IsSupportedType(const char* type) const</a>
<a name="ln451">{</a>
<a name="ln452">	status_t error = type != NULL ? B_OK : B_BAD_VALUE;</a>
<a name="ln453">	// get the supported types</a>
<a name="ln454">	BMessage types;</a>
<a name="ln455">	if (error == B_OK)</a>
<a name="ln456">		error = GetSupportedTypes(&amp;types);</a>
<a name="ln457">	// turn type into a BMimeType</a>
<a name="ln458">	BMimeType mimeType;</a>
<a name="ln459">	if (error == B_OK)</a>
<a name="ln460">		error = mimeType.SetTo(type);</a>
<a name="ln461">	// iterate through the supported types</a>
<a name="ln462">	bool found = false;</a>
<a name="ln463">	if (error == B_OK) {</a>
<a name="ln464">		const char* supportedType;</a>
<a name="ln465">		for (int32 i = 0;</a>
<a name="ln466">			 !found &amp;&amp; types.FindString(&quot;types&quot;, i, &amp;supportedType) == B_OK;</a>
<a name="ln467">			 i++) {</a>
<a name="ln468">			found = strcmp(supportedType, &quot;application/octet-stream&quot;) == 0</a>
<a name="ln469">				|| BMimeType(supportedType).Contains(&amp;mimeType);</a>
<a name="ln470">		}</a>
<a name="ln471">	}</a>
<a name="ln472">	return found;</a>
<a name="ln473">}</a>
<a name="ln474"> </a>
<a name="ln475"> </a>
<a name="ln476">bool</a>
<a name="ln477">BAppFileInfo::Supports(BMimeType* type) const</a>
<a name="ln478">{</a>
<a name="ln479">	status_t error</a>
<a name="ln480">		= type != NULL &amp;&amp; type-&gt;InitCheck() == B_OK ? B_OK : B_BAD_VALUE;</a>
<a name="ln481">	// get the supported types</a>
<a name="ln482">	BMessage types;</a>
<a name="ln483">	if (error == B_OK)</a>
<a name="ln484">		error = GetSupportedTypes(&amp;types);</a>
<a name="ln485">	// iterate through the supported types</a>
<a name="ln486">	bool found = false;</a>
<a name="ln487">	if (error == B_OK) {</a>
<a name="ln488">		const char* supportedType;</a>
<a name="ln489">		for (int32 i = 0;</a>
<a name="ln490">			 !found &amp;&amp; types.FindString(&quot;types&quot;, i, &amp;supportedType) == B_OK;</a>
<a name="ln491">			 i++) {</a>
<a name="ln492">			found = BMimeType(supportedType).Contains(type);</a>
<a name="ln493">		}</a>
<a name="ln494">	}</a>
<a name="ln495">	return found;</a>
<a name="ln496">}</a>
<a name="ln497"> </a>
<a name="ln498"> </a>
<a name="ln499">status_t</a>
<a name="ln500">BAppFileInfo::GetIcon(BBitmap* icon, icon_size which) const</a>
<a name="ln501">{</a>
<a name="ln502">	return GetIconForType(NULL, icon, which);</a>
<a name="ln503">}</a>
<a name="ln504"> </a>
<a name="ln505"> </a>
<a name="ln506">status_t</a>
<a name="ln507">BAppFileInfo::GetIcon(uint8** data, size_t* size) const</a>
<a name="ln508">{</a>
<a name="ln509">	return GetIconForType(NULL, data, size);</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512"> </a>
<a name="ln513">status_t</a>
<a name="ln514">BAppFileInfo::SetIcon(const BBitmap* icon, icon_size which, bool updateMimeDB)</a>
<a name="ln515">{</a>
<a name="ln516">	return SetIconForType(NULL, icon, which, updateMimeDB);</a>
<a name="ln517">}</a>
<a name="ln518"> </a>
<a name="ln519"> </a>
<a name="ln520">status_t</a>
<a name="ln521">BAppFileInfo::SetIcon(const BBitmap* icon, icon_size which)</a>
<a name="ln522">{</a>
<a name="ln523">	return SetIconForType(NULL, icon, which, true);</a>
<a name="ln524">}</a>
<a name="ln525"> </a>
<a name="ln526"> </a>
<a name="ln527">status_t</a>
<a name="ln528">BAppFileInfo::SetIcon(const uint8* data, size_t size, bool updateMimeDB)</a>
<a name="ln529">{</a>
<a name="ln530">	return SetIconForType(NULL, data, size, updateMimeDB);</a>
<a name="ln531">}</a>
<a name="ln532"> </a>
<a name="ln533"> </a>
<a name="ln534">status_t</a>
<a name="ln535">BAppFileInfo::SetIcon(const uint8* data, size_t size)</a>
<a name="ln536">{</a>
<a name="ln537">	return SetIconForType(NULL, data, size, true);</a>
<a name="ln538">}</a>
<a name="ln539"> </a>
<a name="ln540"> </a>
<a name="ln541">status_t</a>
<a name="ln542">BAppFileInfo::GetVersionInfo(version_info* info, version_kind kind) const</a>
<a name="ln543">{</a>
<a name="ln544">	// check params and initialization</a>
<a name="ln545">	if (info == NULL)</a>
<a name="ln546">		return B_BAD_VALUE;</a>
<a name="ln547"> </a>
<a name="ln548">	int32 index = 0;</a>
<a name="ln549">	switch (kind) {</a>
<a name="ln550">		case B_APP_VERSION_KIND:</a>
<a name="ln551">			index = 0;</a>
<a name="ln552">			break;</a>
<a name="ln553">		case B_SYSTEM_VERSION_KIND:</a>
<a name="ln554">			index = 1;</a>
<a name="ln555">			break;</a>
<a name="ln556">		default:</a>
<a name="ln557">			return B_BAD_VALUE;</a>
<a name="ln558">	}</a>
<a name="ln559"> </a>
<a name="ln560">	if (InitCheck() != B_OK)</a>
<a name="ln561">		return B_NO_INIT;</a>
<a name="ln562"> </a>
<a name="ln563">	// read the data</a>
<a name="ln564">	size_t read = 0;</a>
<a name="ln565">	version_info infos[2];</a>
<a name="ln566">	status_t error = _ReadData(kVersionInfoAttribute, kVersionInfoResourceID,</a>
<a name="ln567">		B_VERSION_INFO_TYPE, infos, 2 * sizeof(version_info), read);</a>
<a name="ln568">	if (error != B_OK)</a>
<a name="ln569">		return error;</a>
<a name="ln570"> </a>
<a name="ln571">	// check the read data</a>
<a name="ln572">	if (read == sizeof(version_info)) {</a>
<a name="ln573">		// only the app version info is there -- return a cleared system info</a>
<a name="ln574">		if (index == 0)</a>
<a name="ln575">			*info = infos[index];</a>
<a name="ln576">		else if (index == 1)</a>
<a name="ln577">			memset(info, 0, sizeof(version_info));</a>
<a name="ln578">	} else if (read == 2 * sizeof(version_info)) {</a>
<a name="ln579">		*info = infos[index];</a>
<a name="ln580">	} else</a>
<a name="ln581">		return B_ERROR;</a>
<a name="ln582"> </a>
<a name="ln583">	// return result</a>
<a name="ln584">	return B_OK;</a>
<a name="ln585">}</a>
<a name="ln586"> </a>
<a name="ln587"> </a>
<a name="ln588">status_t</a>
<a name="ln589">BAppFileInfo::SetVersionInfo(const version_info* info, version_kind kind)</a>
<a name="ln590">{</a>
<a name="ln591">	// check initialization</a>
<a name="ln592">	status_t error = B_OK;</a>
<a name="ln593">	if (InitCheck() != B_OK)</a>
<a name="ln594">		error = B_NO_INIT;</a>
<a name="ln595">	if (error == B_OK) {</a>
<a name="ln596">		if (info != NULL) {</a>
<a name="ln597">			// check param</a>
<a name="ln598">			int32 index = 0;</a>
<a name="ln599">			if (error == B_OK) {</a>
<a name="ln600">				switch (kind) {</a>
<a name="ln601">					case B_APP_VERSION_KIND:</a>
<a name="ln602">						index = 0;</a>
<a name="ln603">						break;</a>
<a name="ln604">					case B_SYSTEM_VERSION_KIND:</a>
<a name="ln605">						index = 1;</a>
<a name="ln606">						break;</a>
<a name="ln607">					default:</a>
<a name="ln608">						error = B_BAD_VALUE;</a>
<a name="ln609">						break;</a>
<a name="ln610">				}</a>
<a name="ln611">			}</a>
<a name="ln612">			// read both infos</a>
<a name="ln613">			version_info infos[2];</a>
<a name="ln614">			if (error == B_OK) {</a>
<a name="ln615">				size_t read;</a>
<a name="ln616">				if (_ReadData(kVersionInfoAttribute, kVersionInfoResourceID,</a>
<a name="ln617">						B_VERSION_INFO_TYPE, infos, 2 * sizeof(version_info),</a>
<a name="ln618">						read) == B_OK) {</a>
<a name="ln619">					// clear the part that hasn't been read</a>
<a name="ln620">					if (read &lt; sizeof(infos))</a>
<a name="ln621">						memset((char*)infos + read, 0, sizeof(infos) - read);</a>
<a name="ln622">				} else {</a>
<a name="ln623">					// failed to read -- clear</a>
<a name="ln624">					memset(infos, 0, sizeof(infos));</a>
<a name="ln625">				}</a>
<a name="ln626">			}</a>
<a name="ln627">			infos[index] = *info;</a>
<a name="ln628">			// write the data</a>
<a name="ln629">			if (error == B_OK) {</a>
<a name="ln630">				error = _WriteData(kVersionInfoAttribute,</a>
<a name="ln631">					kVersionInfoResourceID, B_VERSION_INFO_TYPE, infos,</a>
<a name="ln632">					2 * sizeof(version_info));</a>
<a name="ln633">			}</a>
<a name="ln634">		} else</a>
<a name="ln635">			error = _RemoveData(kVersionInfoAttribute, B_VERSION_INFO_TYPE);</a>
<a name="ln636">	}</a>
<a name="ln637">	return error;</a>
<a name="ln638">}</a>
<a name="ln639"> </a>
<a name="ln640"> </a>
<a name="ln641">status_t</a>
<a name="ln642">BAppFileInfo::GetIconForType(const char* type, BBitmap* icon, icon_size size)</a>
<a name="ln643">	const</a>
<a name="ln644">{</a>
<a name="ln645">	if (InitCheck() != B_OK)</a>
<a name="ln646">		return B_NO_INIT;</a>
<a name="ln647"> </a>
<a name="ln648">	if (icon == NULL || icon-&gt;InitCheck() != B_OK)</a>
<a name="ln649">		return B_BAD_VALUE;</a>
<a name="ln650"> </a>
<a name="ln651">	// TODO: for consistency with attribute based icon reading, we</a>
<a name="ln652">	// could also prefer B_CMAP8 icons here if the provided bitmap</a>
<a name="ln653">	// is in that format. Right now, an existing B_CMAP8 icon resource</a>
<a name="ln654">	// would be ignored as soon as a vector icon is present. On the other</a>
<a name="ln655">	// hand, maybe this still results in a more consistent user interface,</a>
<a name="ln656">	// since Tracker/Deskbar would surely show the vector icon.</a>
<a name="ln657"> </a>
<a name="ln658">	// try vector icon first</a>
<a name="ln659">	BString vectorAttributeName(kIconAttribute);</a>
<a name="ln660"> </a>
<a name="ln661">	// check type param</a>
<a name="ln662">	if (type != NULL) {</a>
<a name="ln663">		if (BMimeType::IsValid(type))</a>
<a name="ln664">			vectorAttributeName += type;</a>
<a name="ln665">		else</a>
<a name="ln666">			return B_BAD_VALUE;</a>
<a name="ln667">	} else {</a>
<a name="ln668">		vectorAttributeName += kIconType;</a>
<a name="ln669">	}</a>
<a name="ln670">	const char* attribute = vectorAttributeName.String();</a>
<a name="ln671"> </a>
<a name="ln672">	size_t bytesRead;</a>
<a name="ln673">	void* allocatedBuffer;</a>
<a name="ln674">	status_t error = _ReadData(attribute, -1, B_VECTOR_ICON_TYPE, NULL, 0,</a>
<a name="ln675">		bytesRead, &amp;allocatedBuffer);</a>
<a name="ln676">	if (error == B_OK) {</a>
<a name="ln677">		error = BIconUtils::GetVectorIcon((uint8*)allocatedBuffer,</a>
<a name="ln678">										  bytesRead, icon);</a>
<a name="ln679">		free(allocatedBuffer);</a>
<a name="ln680">		return error;</a>
<a name="ln681">	}</a>
<a name="ln682"> </a>
<a name="ln683">	// no vector icon if we got this far,</a>
<a name="ln684">	// align size argument just in case</a>
<a name="ln685">	if (size &lt; B_LARGE_ICON)</a>
<a name="ln686">		size = B_MINI_ICON;</a>
<a name="ln687">	else</a>
<a name="ln688">		size = B_LARGE_ICON;</a>
<a name="ln689"> </a>
<a name="ln690">	error = B_OK;</a>
<a name="ln691">	// set some icon size related variables</a>
<a name="ln692">	BString attributeString;</a>
<a name="ln693">	BRect bounds;</a>
<a name="ln694">	uint32 attrType = 0;</a>
<a name="ln695">	size_t attrSize = 0;</a>
<a name="ln696">	switch (size) {</a>
<a name="ln697">		case B_MINI_ICON:</a>
<a name="ln698">			attributeString = kMiniIconAttribute;</a>
<a name="ln699">			bounds.Set(0, 0, 15, 15);</a>
<a name="ln700">			attrType = B_MINI_ICON_TYPE;</a>
<a name="ln701">			attrSize = 16 * 16;</a>
<a name="ln702">			break;</a>
<a name="ln703">		case B_LARGE_ICON:</a>
<a name="ln704">			attributeString = kLargeIconAttribute;</a>
<a name="ln705">			bounds.Set(0, 0, 31, 31);</a>
<a name="ln706">			attrType = B_LARGE_ICON_TYPE;</a>
<a name="ln707">			attrSize = 32 * 32;</a>
<a name="ln708">			break;</a>
<a name="ln709">		default:</a>
<a name="ln710">			return B_BAD_VALUE;</a>
<a name="ln711">	}</a>
<a name="ln712"> </a>
<a name="ln713">	// compose attribute name</a>
<a name="ln714">	attributeString += type != NULL ? type : kStandardIconType;</a>
<a name="ln715">	attribute = attributeString.String();</a>
<a name="ln716"> </a>
<a name="ln717">	// check parameters</a>
<a name="ln718">	// currently, scaling B_CMAP8 icons is not supported</a>
<a name="ln719">	if (icon-&gt;ColorSpace() == B_CMAP8 &amp;&amp; icon-&gt;Bounds() != bounds)</a>
<a name="ln720">		return B_BAD_VALUE;</a>
<a name="ln721"> </a>
<a name="ln722">	// read the data</a>
<a name="ln723">	if (error == B_OK) {</a>
<a name="ln724">		bool tempBuffer</a>
<a name="ln725">			= icon-&gt;ColorSpace() != B_CMAP8 || icon-&gt;Bounds() != bounds;</a>
<a name="ln726">		uint8* buffer = NULL;</a>
<a name="ln727">		size_t read;</a>
<a name="ln728">		if (tempBuffer) {</a>
<a name="ln729">			// other color space or bitmap size than stored in attribute</a>
<a name="ln730">			buffer = new(std::nothrow) uint8[attrSize];</a>
<a name="ln731">			if (!buffer) {</a>
<a name="ln732">				error = B_NO_MEMORY;</a>
<a name="ln733">			} else {</a>
<a name="ln734">				error = _ReadData(attribute, -1, attrType, buffer, attrSize,</a>
<a name="ln735">					read);</a>
<a name="ln736">			}</a>
<a name="ln737">		} else {</a>
<a name="ln738">			error = _ReadData(attribute, -1, attrType, icon-&gt;Bits(), attrSize,</a>
<a name="ln739">				read);</a>
<a name="ln740">		}</a>
<a name="ln741">		if (error == B_OK &amp;&amp; read != attrSize)</a>
<a name="ln742">			error = B_ERROR;</a>
<a name="ln743">		if (tempBuffer) {</a>
<a name="ln744">			// other color space than stored in attribute</a>
<a name="ln745">			if (error == B_OK) {</a>
<a name="ln746">				error = BIconUtils::ConvertFromCMAP8(buffer, (uint32)size,</a>
<a name="ln747">					(uint32)size, (uint32)size, icon);</a>
<a name="ln748">			}</a>
<a name="ln749">			delete[] buffer;</a>
<a name="ln750">		}</a>
<a name="ln751">	}</a>
<a name="ln752">	return error;</a>
<a name="ln753">}</a>
<a name="ln754"> </a>
<a name="ln755"> </a>
<a name="ln756">status_t</a>
<a name="ln757">BAppFileInfo::GetIconForType(const char* type, uint8** data, size_t* size) const</a>
<a name="ln758">{</a>
<a name="ln759">	if (InitCheck() != B_OK)</a>
<a name="ln760">		return B_NO_INIT;</a>
<a name="ln761"> </a>
<a name="ln762">	if (data == NULL || size == NULL)</a>
<a name="ln763">		return B_BAD_VALUE;</a>
<a name="ln764"> </a>
<a name="ln765">	// get vector icon</a>
<a name="ln766">	BString attributeName(kIconAttribute);</a>
<a name="ln767"> </a>
<a name="ln768">	// check type param</a>
<a name="ln769">	if (type != NULL) {</a>
<a name="ln770">		if (BMimeType::IsValid(type))</a>
<a name="ln771">			attributeName += type;</a>
<a name="ln772">		else</a>
<a name="ln773">			return B_BAD_VALUE;</a>
<a name="ln774">	} else</a>
<a name="ln775">		attributeName += kIconType;</a>
<a name="ln776"> </a>
<a name="ln777">	void* allocatedBuffer = NULL;</a>
<a name="ln778">	status_t ret = _ReadData(attributeName.String(), -1, B_VECTOR_ICON_TYPE,</a>
<a name="ln779">		NULL, 0, *size, &amp;allocatedBuffer);</a>
<a name="ln780"> </a>
<a name="ln781">	if (ret &lt; B_OK)</a>
<a name="ln782">		return ret;</a>
<a name="ln783"> </a>
<a name="ln784">	*data = (uint8*)allocatedBuffer;</a>
<a name="ln785">	return B_OK;</a>
<a name="ln786">}</a>
<a name="ln787"> </a>
<a name="ln788"> </a>
<a name="ln789">status_t</a>
<a name="ln790">BAppFileInfo::SetIconForType(const char* type, const BBitmap* icon,</a>
<a name="ln791">	icon_size which, bool updateMimeDB)</a>
<a name="ln792">{</a>
<a name="ln793">	status_t error = B_OK;</a>
<a name="ln794"> </a>
<a name="ln795">	// set some icon size related variables</a>
<a name="ln796">	BString attributeString;</a>
<a name="ln797">	BRect bounds;</a>
<a name="ln798">	uint32 attrType = 0;</a>
<a name="ln799">	size_t attrSize = 0;</a>
<a name="ln800">	int32 resourceID = 0;</a>
<a name="ln801">	switch (which) {</a>
<a name="ln802">		case B_MINI_ICON:</a>
<a name="ln803">			attributeString = kMiniIconAttribute;</a>
<a name="ln804">			bounds.Set(0, 0, 15, 15);</a>
<a name="ln805">			attrType = B_MINI_ICON_TYPE;</a>
<a name="ln806">			attrSize = 16 * 16;</a>
<a name="ln807">			resourceID = type != NULL</a>
<a name="ln808">				? kMiniIconForTypeResourceID : kMiniIconResourceID;</a>
<a name="ln809">			break;</a>
<a name="ln810">		case B_LARGE_ICON:</a>
<a name="ln811">			attributeString = kLargeIconAttribute;</a>
<a name="ln812">			bounds.Set(0, 0, 31, 31);</a>
<a name="ln813">			attrType = B_LARGE_ICON_TYPE;</a>
<a name="ln814">			attrSize = 32 * 32;</a>
<a name="ln815">			resourceID = type != NULL</a>
<a name="ln816">				? kLargeIconForTypeResourceID : kLargeIconResourceID;</a>
<a name="ln817">			break;</a>
<a name="ln818">		default:</a>
<a name="ln819">			error = B_BAD_VALUE;</a>
<a name="ln820">			break;</a>
<a name="ln821">	}</a>
<a name="ln822"> </a>
<a name="ln823">	// check type param</a>
<a name="ln824">	if (error == B_OK) {</a>
<a name="ln825">		if (type != NULL) {</a>
<a name="ln826">			if (BMimeType::IsValid(type))</a>
<a name="ln827">				attributeString += type;</a>
<a name="ln828">			else</a>
<a name="ln829">				error = B_BAD_VALUE;</a>
<a name="ln830">		} else</a>
<a name="ln831">			attributeString += kStandardIconType;</a>
<a name="ln832">	}</a>
<a name="ln833">	const char* attribute = attributeString.String();</a>
<a name="ln834"> </a>
<a name="ln835">	// check parameter and initialization</a>
<a name="ln836">	if (error == B_OK &amp;&amp; icon != NULL</a>
<a name="ln837">		&amp;&amp; (icon-&gt;InitCheck() != B_OK || icon-&gt;Bounds() != bounds)) {</a>
<a name="ln838">		error = B_BAD_VALUE;</a>
<a name="ln839">	}</a>
<a name="ln840">	if (error == B_OK &amp;&amp; InitCheck() != B_OK)</a>
<a name="ln841">		error = B_NO_INIT;</a>
<a name="ln842"> </a>
<a name="ln843">	// write/remove the attribute</a>
<a name="ln844">	if (error == B_OK) {</a>
<a name="ln845">		if (icon != NULL) {</a>
<a name="ln846">			bool otherColorSpace = (icon-&gt;ColorSpace() != B_CMAP8);</a>
<a name="ln847">			if (otherColorSpace) {</a>
<a name="ln848">				BBitmap bitmap(bounds, B_BITMAP_NO_SERVER_LINK, B_CMAP8);</a>
<a name="ln849">				error = bitmap.InitCheck();</a>
<a name="ln850">				if (error == B_OK)</a>
<a name="ln851">					error = bitmap.ImportBits(icon);</a>
<a name="ln852">				if (error == B_OK) {</a>
<a name="ln853">					error = _WriteData(attribute, resourceID, attrType,</a>
<a name="ln854">						bitmap.Bits(), attrSize, true);</a>
<a name="ln855">				}</a>
<a name="ln856">			} else {</a>
<a name="ln857">				error = _WriteData(attribute, resourceID, attrType,</a>
<a name="ln858">					icon-&gt;Bits(), attrSize, true);</a>
<a name="ln859">			}</a>
<a name="ln860">		} else	// no icon given =&gt; remove</a>
<a name="ln861">			error = _RemoveData(attribute, attrType);</a>
<a name="ln862">	}</a>
<a name="ln863"> </a>
<a name="ln864">	// set the attribute on the MIME type, if the file has a signature</a>
<a name="ln865">#if 0</a>
<a name="ln866">	BMimeType mimeType;</a>
<a name="ln867">	if (updateMimeDB &amp;&amp; error == B_OK &amp;&amp; GetMetaMime(&amp;mimeType) == B_OK) {</a>
<a name="ln868">		if (!mimeType.IsInstalled())</a>
<a name="ln869">			error = mimeType.Install();</a>
<a name="ln870">		if (error == B_OK)</a>
<a name="ln871">			error = mimeType.SetIconForType(type, icon, which);</a>
<a name="ln872">	}</a>
<a name="ln873">#endif</a>
<a name="ln874">	return error;</a>
<a name="ln875">}</a>
<a name="ln876"> </a>
<a name="ln877"> </a>
<a name="ln878">status_t</a>
<a name="ln879">BAppFileInfo::SetIconForType(const char* type, const BBitmap* icon,</a>
<a name="ln880">	icon_size which)</a>
<a name="ln881">{</a>
<a name="ln882">	return SetIconForType(type, icon, which, true);</a>
<a name="ln883">}</a>
<a name="ln884"> </a>
<a name="ln885"> </a>
<a name="ln886">status_t</a>
<a name="ln887">BAppFileInfo::SetIconForType(const char* type, const uint8* data, size_t size,</a>
<a name="ln888">	bool updateMimeDB)</a>
<a name="ln889">{</a>
<a name="ln890">	if (InitCheck() != B_OK)</a>
<a name="ln891">		return B_NO_INIT;</a>
<a name="ln892"> </a>
<a name="ln893">	// set some icon related variables</a>
<a name="ln894">	BString attributeString = kIconAttribute;</a>
<a name="ln895">	int32 resourceID = type ? kIconForTypeResourceID : kIconResourceID;</a>
<a name="ln896">	uint32 attrType = B_VECTOR_ICON_TYPE;</a>
<a name="ln897"> </a>
<a name="ln898">	// check type param</a>
<a name="ln899">	if (type != NULL) {</a>
<a name="ln900">		if (BMimeType::IsValid(type))</a>
<a name="ln901">			attributeString += type;</a>
<a name="ln902">		else</a>
<a name="ln903">			return B_BAD_VALUE;</a>
<a name="ln904">	} else</a>
<a name="ln905">		attributeString += kIconType;</a>
<a name="ln906"> </a>
<a name="ln907">	const char* attribute = attributeString.String();</a>
<a name="ln908"> </a>
<a name="ln909">	status_t error;</a>
<a name="ln910">	// write/remove the attribute</a>
<a name="ln911">	if (data != NULL)</a>
<a name="ln912">		error = _WriteData(attribute, resourceID, attrType, data, size, true);</a>
<a name="ln913">	else	// no icon given =&gt; remove</a>
<a name="ln914">		error = _RemoveData(attribute, attrType);</a>
<a name="ln915"> </a>
<a name="ln916">	// set the attribute on the MIME type, if the file has a signature</a>
<a name="ln917">#if 0</a>
<a name="ln918">	BMimeType mimeType;</a>
<a name="ln919">	if (updateMimeDB &amp;&amp; error == B_OK &amp;&amp; GetMetaMime(&amp;mimeType) == B_OK) {</a>
<a name="ln920">		if (!mimeType.IsInstalled())</a>
<a name="ln921">			error = mimeType.Install();</a>
<a name="ln922">		if (error == B_OK)</a>
<a name="ln923">			error = mimeType.SetIconForType(type, data, size);</a>
<a name="ln924">	}</a>
<a name="ln925">#endif</a>
<a name="ln926">	return error;</a>
<a name="ln927">}</a>
<a name="ln928"> </a>
<a name="ln929"> </a>
<a name="ln930">status_t</a>
<a name="ln931">BAppFileInfo::SetIconForType(const char* type, const uint8* data, size_t size)</a>
<a name="ln932">{</a>
<a name="ln933">	return SetIconForType(type, data, size, true);</a>
<a name="ln934">}</a>
<a name="ln935"> </a>
<a name="ln936"> </a>
<a name="ln937">void</a>
<a name="ln938">BAppFileInfo::SetInfoLocation(info_location location)</a>
<a name="ln939">{</a>
<a name="ln940">	// if the resources failed to initialize, we must not use them</a>
<a name="ln941">	if (fResources == NULL)</a>
<a name="ln942">		location = info_location(location &amp; ~B_USE_RESOURCES);</a>
<a name="ln943"> </a>
<a name="ln944">	fWhere = location;</a>
<a name="ln945">}</a>
<a name="ln946"> </a>
<a name="ln947">bool</a>
<a name="ln948">BAppFileInfo::IsUsingAttributes() const</a>
<a name="ln949">{</a>
<a name="ln950">	return (fWhere &amp; B_USE_ATTRIBUTES) != 0;</a>
<a name="ln951">}</a>
<a name="ln952"> </a>
<a name="ln953"> </a>
<a name="ln954">bool</a>
<a name="ln955">BAppFileInfo::IsUsingResources() const</a>
<a name="ln956">{</a>
<a name="ln957">	return (fWhere &amp; B_USE_RESOURCES) != 0;</a>
<a name="ln958">}</a>
<a name="ln959"> </a>
<a name="ln960"> </a>
<a name="ln961">// FBC</a>
<a name="ln962">void BAppFileInfo::_ReservedAppFileInfo1() {}</a>
<a name="ln963">void BAppFileInfo::_ReservedAppFileInfo2() {}</a>
<a name="ln964">void BAppFileInfo::_ReservedAppFileInfo3() {}</a>
<a name="ln965"> </a>
<a name="ln966"> </a>
<a name="ln967">BAppFileInfo&amp;</a>
<a name="ln968">BAppFileInfo::operator=(const BAppFileInfo&amp;)</a>
<a name="ln969">{</a>
<a name="ln970">	return *this;</a>
<a name="ln971">}</a>
<a name="ln972"> </a>
<a name="ln973"> </a>
<a name="ln974">BAppFileInfo::BAppFileInfo(const BAppFileInfo&amp;)</a>
<a name="ln975">{</a>
<a name="ln976">}</a>
<a name="ln977"> </a>
<a name="ln978"> </a>
<a name="ln979">status_t</a>
<a name="ln980">BAppFileInfo::GetMetaMime(BMimeType* meta) const</a>
<a name="ln981">{</a>
<a name="ln982">	char signature[B_MIME_TYPE_LENGTH];</a>
<a name="ln983">	status_t error = GetSignature(signature);</a>
<a name="ln984">	if (error == B_OK)</a>
<a name="ln985">		error = meta-&gt;SetTo(signature);</a>
<a name="ln986">	else if (error == B_BAD_VALUE)</a>
<a name="ln987">		error = B_ENTRY_NOT_FOUND;</a>
<a name="ln988">	if (error == B_OK &amp;&amp; !meta-&gt;IsValid())</a>
<a name="ln989">		error = B_BAD_VALUE;</a>
<a name="ln990">	return error;</a>
<a name="ln991">}</a>
<a name="ln992"> </a>
<a name="ln993"> </a>
<a name="ln994">status_t</a>
<a name="ln995">BAppFileInfo::_ReadData(const char* name, int32 id, type_code type,</a>
<a name="ln996">	void* buffer, size_t bufferSize, size_t&amp; bytesRead, void** allocatedBuffer)</a>
<a name="ln997">	const</a>
<a name="ln998">{</a>
<a name="ln999">	status_t error = B_OK;</a>
<a name="ln1000"> </a>
<a name="ln1001">	if (allocatedBuffer)</a>
<a name="ln1002">		buffer = NULL;</a>
<a name="ln1003"> </a>
<a name="ln1004">	bool foundData = false;</a>
<a name="ln1005"> </a>
<a name="ln1006">	if (IsUsingAttributes()) {</a>
<a name="ln1007">		// get an attribute info</a>
<a name="ln1008">		attr_info info;</a>
<a name="ln1009">		if (error == B_OK)</a>
<a name="ln1010">			error = fNode-&gt;GetAttrInfo(name, &amp;info);</a>
<a name="ln1011"> </a>
<a name="ln1012">		// check type and size, allocate a buffer, if required</a>
<a name="ln1013">		if (error == B_OK &amp;&amp; info.type != type)</a>
<a name="ln1014">			error = B_BAD_VALUE;</a>
<a name="ln1015">		if (error == B_OK &amp;&amp; allocatedBuffer != NULL) {</a>
<a name="ln1016">			buffer = malloc(info.size);</a>
<a name="ln1017">			if (buffer == NULL)</a>
<a name="ln1018">				error = B_NO_MEMORY;</a>
<a name="ln1019">			bufferSize = info.size;</a>
<a name="ln1020">		}</a>
<a name="ln1021">		if (error == B_OK &amp;&amp; (off_t)bufferSize &lt; info.size)</a>
<a name="ln1022">			error = B_BAD_VALUE;</a>
<a name="ln1023"> </a>
<a name="ln1024">		// read the data</a>
<a name="ln1025">		if (error == B_OK) {</a>
<a name="ln1026">			ssize_t read = fNode-&gt;ReadAttr(name, type, 0, buffer, info.size);</a>
<a name="ln1027">			if (read &lt; 0)</a>
<a name="ln1028">				error = read;</a>
<a name="ln1029">			else if (read != info.size)</a>
<a name="ln1030">				error = B_ERROR;</a>
<a name="ln1031">			else</a>
<a name="ln1032">				bytesRead = read;</a>
<a name="ln1033">		}</a>
<a name="ln1034"> </a>
<a name="ln1035">		foundData = error == B_OK;</a>
<a name="ln1036"> </a>
<a name="ln1037">		// free the allocated buffer on error</a>
<a name="ln1038">		if (!foundData &amp;&amp; allocatedBuffer != NULL &amp;&amp; buffer != NULL) {</a>
<a name="ln1039">			free(buffer);</a>
<a name="ln1040">			buffer = NULL;</a>
<a name="ln1041">		}</a>
<a name="ln1042">	}</a>
<a name="ln1043"> </a>
<a name="ln1044">	if (!foundData &amp;&amp; IsUsingResources()) {</a>
<a name="ln1045">		// get a resource info</a>
<a name="ln1046">		error = B_OK;</a>
<a name="ln1047">		int32 idFound;</a>
<a name="ln1048">		size_t sizeFound;</a>
<a name="ln1049">		if (error == B_OK) {</a>
<a name="ln1050">			if (!fResources-&gt;GetResourceInfo(type, name, &amp;idFound, &amp;sizeFound))</a>
<a name="ln1051">				error = B_ENTRY_NOT_FOUND;</a>
<a name="ln1052">		}</a>
<a name="ln1053"> </a>
<a name="ln1054">		// check id and size, allocate a buffer, if required</a>
<a name="ln1055">		if (error == B_OK &amp;&amp; id &gt;= 0 &amp;&amp; idFound != id)</a>
<a name="ln1056">			error = B_ENTRY_NOT_FOUND;</a>
<a name="ln1057">		if (error == B_OK &amp;&amp; allocatedBuffer) {</a>
<a name="ln1058">			buffer = malloc(sizeFound);</a>
<a name="ln1059">			if (!buffer)</a>
<a name="ln1060">				error = B_NO_MEMORY;</a>
<a name="ln1061">			bufferSize = sizeFound;</a>
<a name="ln1062">		}</a>
<a name="ln1063">		if (error == B_OK &amp;&amp; bufferSize &lt; sizeFound)</a>
<a name="ln1064">			error = B_BAD_VALUE;</a>
<a name="ln1065"> </a>
<a name="ln1066">		// load resource</a>
<a name="ln1067">		const void* resourceData = NULL;</a>
<a name="ln1068">		if (error == B_OK) {</a>
<a name="ln1069">			resourceData = fResources-&gt;LoadResource(type, name, &amp;bytesRead);</a>
<a name="ln1070">			if (resourceData != NULL &amp;&amp; sizeFound == bytesRead)</a>
<a name="ln1071">				memcpy(buffer, resourceData, bytesRead);</a>
<a name="ln1072">			else</a>
<a name="ln1073">				error = B_ERROR;</a>
<a name="ln1074">		}</a>
<a name="ln1075">	} else if (!foundData)</a>
<a name="ln1076">		error = B_BAD_VALUE;</a>
<a name="ln1077"> </a>
<a name="ln1078">	// return the allocated buffer, or free it on error</a>
<a name="ln1079">	if (allocatedBuffer != NULL) {</a>
<a name="ln1080">		if (error == B_OK)</a>
<a name="ln1081">			*allocatedBuffer = buffer;</a>
<a name="ln1082">		else</a>
<a name="ln1083">			free(buffer);</a>
<a name="ln1084">	}</a>
<a name="ln1085"> </a>
<a name="ln1086">	return error;</a>
<a name="ln1087">}</a>
<a name="ln1088"> </a>
<a name="ln1089"> </a>
<a name="ln1090">status_t</a>
<a name="ln1091">BAppFileInfo::_WriteData(const char* name, int32 id, type_code type,</a>
<a name="ln1092">	const void* buffer, size_t bufferSize, bool findID)</a>
<a name="ln1093">{</a>
<a name="ln1094">	if (!IsUsingAttributes() &amp;&amp; !IsUsingResources())</a>
<a name="ln1095">		return B_NO_INIT;</a>
<a name="ln1096"> </a>
<a name="ln1097">	status_t error = B_OK;</a>
<a name="ln1098"> </a>
<a name="ln1099">	// write to attribute</a>
<a name="ln1100">	if (IsUsingAttributes()) {</a>
<a name="ln1101">		ssize_t written = fNode-&gt;WriteAttr(name, type, 0, buffer, bufferSize);</a>
<a name="ln1102">		if (written &lt; 0)</a>
<a name="ln1103">			error = written;</a>
<a name="ln1104">		else if (written != (ssize_t)bufferSize)</a>
<a name="ln1105">			error = B_ERROR;</a>
<a name="ln1106">	}</a>
<a name="ln1107">	// write to resource</a>
<a name="ln1108">	if (IsUsingResources() &amp;&amp; error == B_OK) {</a>
<a name="ln1109">		if (findID) {</a>
<a name="ln1110">			// get the resource info</a>
<a name="ln1111">			int32 idFound;</a>
<a name="ln1112">			size_t sizeFound;</a>
<a name="ln1113">			if (fResources-&gt;GetResourceInfo(type, name, &amp;idFound, &amp;sizeFound))</a>
<a name="ln1114">				id = idFound;</a>
<a name="ln1115">			else {</a>
<a name="ln1116">				// type-name pair doesn't exist yet -- find unused ID</a>
<a name="ln1117">				while (fResources-&gt;HasResource(type, id))</a>
<a name="ln1118">					id++;</a>
<a name="ln1119">			}</a>
<a name="ln1120">		}</a>
<a name="ln1121">		error = fResources-&gt;AddResource(type, id, buffer, bufferSize, name);</a>
<a name="ln1122">	}</a>
<a name="ln1123">	return error;</a>
<a name="ln1124">}</a>
<a name="ln1125"> </a>
<a name="ln1126"> </a>
<a name="ln1127">status_t</a>
<a name="ln1128">BAppFileInfo::_RemoveData(const char* name, type_code type)</a>
<a name="ln1129">{</a>
<a name="ln1130">	if (!IsUsingAttributes() &amp;&amp; !IsUsingResources())</a>
<a name="ln1131">		return B_NO_INIT;</a>
<a name="ln1132"> </a>
<a name="ln1133">	status_t error = B_OK;</a>
<a name="ln1134"> </a>
<a name="ln1135">	// remove the attribute</a>
<a name="ln1136">	if (IsUsingAttributes()) {</a>
<a name="ln1137">		error = fNode-&gt;RemoveAttr(name);</a>
<a name="ln1138">		// It's no error, if there has been no attribute.</a>
<a name="ln1139">		if (error == B_ENTRY_NOT_FOUND)</a>
<a name="ln1140">			error = B_OK;</a>
<a name="ln1141">	}</a>
<a name="ln1142">	// remove the resource</a>
<a name="ln1143">	if (IsUsingResources() &amp;&amp; error == B_OK) {</a>
<a name="ln1144">		// get a resource info</a>
<a name="ln1145">		int32 idFound;</a>
<a name="ln1146">		size_t sizeFound;</a>
<a name="ln1147">		if (fResources-&gt;GetResourceInfo(type, name, &amp;idFound, &amp;sizeFound))</a>
<a name="ln1148">			error = fResources-&gt;RemoveResource(type, idFound);</a>
<a name="ln1149">	}</a>
<a name="ln1150">	return error;</a>
<a name="ln1151">}</a>

</code></pre>
<div class="balloon" rel="1009"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'error == ((int) 0)' is always true.</p></div>
<div class="balloon" rel="1049"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'error == ((int) 0)' is always true.</p></div>
<div class="balloon" rel="723"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'error == ((int) 0)' is always true.</p></div>
<div class="balloon" rel="599"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'error == ((int) 0)' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
