
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>oce_queue.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * SPDX-License-Identifier: BSD-3-Clause</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (C) 2013 Emulex</a>
<a name="ln5"> * All rights reserved.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln8"> * modification, are permitted provided that the following conditions are met:</a>
<a name="ln9"> *</a>
<a name="ln10"> * 1. Redistributions of source code must retain the above copyright notice,</a>
<a name="ln11"> *    this list of conditions and the following disclaimer.</a>
<a name="ln12"> *</a>
<a name="ln13"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln14"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln15"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln16"> *</a>
<a name="ln17"> * 3. Neither the name of the Emulex Corporation nor the names of its</a>
<a name="ln18"> *    contributors may be used to endorse or promote products derived from</a>
<a name="ln19"> *    this software without specific prior written permission.</a>
<a name="ln20"> *</a>
<a name="ln21"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</a>
<a name="ln22"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln23"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln24"> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</a>
<a name="ln25"> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</a>
<a name="ln26"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</a>
<a name="ln27"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</a>
<a name="ln28"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</a>
<a name="ln29"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</a>
<a name="ln30"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</a>
<a name="ln31"> * POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln32"> *</a>
<a name="ln33"> * Contact Information:</a>
<a name="ln34"> * freebsd-drivers@emulex.com</a>
<a name="ln35"> *</a>
<a name="ln36"> * Emulex</a>
<a name="ln37"> * 3333 Susan Street</a>
<a name="ln38"> * Costa Mesa, CA 92626</a>
<a name="ln39"> */</a>
<a name="ln40"> </a>
<a name="ln41">/* $FreeBSD: releng/12.0/sys/dev/oce/oce_queue.c 326022 2017-11-20 19:36:21Z pfg $ */</a>
<a name="ln42"> </a>
<a name="ln43">#include &quot;oce_if.h&quot;</a>
<a name="ln44"> </a>
<a name="ln45">/*****************************************************</a>
<a name="ln46"> * local queue functions</a>
<a name="ln47"> *****************************************************/</a>
<a name="ln48"> </a>
<a name="ln49">static struct oce_wq *oce_wq_init(POCE_SOFTC sc,</a>
<a name="ln50">				  uint32_t q_len, uint32_t wq_type);</a>
<a name="ln51">static int oce_wq_create(struct oce_wq *wq, struct oce_eq *eq);</a>
<a name="ln52">static void oce_wq_free(struct oce_wq *wq);</a>
<a name="ln53">static void oce_wq_del(struct oce_wq *wq);</a>
<a name="ln54">static struct oce_rq *oce_rq_init(POCE_SOFTC sc,</a>
<a name="ln55">				  uint32_t q_len,</a>
<a name="ln56">				  uint32_t frag_size,</a>
<a name="ln57">				  uint32_t mtu, uint32_t rss);</a>
<a name="ln58">static int oce_rq_create(struct oce_rq *rq, uint32_t if_id, struct oce_eq *eq);</a>
<a name="ln59">static void oce_rq_free(struct oce_rq *rq);</a>
<a name="ln60">static void oce_rq_del(struct oce_rq *rq);</a>
<a name="ln61">static struct oce_eq *oce_eq_create(POCE_SOFTC sc,</a>
<a name="ln62">				    uint32_t q_len,</a>
<a name="ln63">				    uint32_t item_size,</a>
<a name="ln64">				    uint32_t eq_delay,</a>
<a name="ln65">				    uint32_t vector);</a>
<a name="ln66">static void oce_eq_del(struct oce_eq *eq);</a>
<a name="ln67">static struct oce_mq *oce_mq_create(POCE_SOFTC sc,</a>
<a name="ln68">				    struct oce_eq *eq, uint32_t q_len);</a>
<a name="ln69">static void oce_mq_free(struct oce_mq *mq);</a>
<a name="ln70">static int oce_destroy_q(POCE_SOFTC sc, struct oce_mbx</a>
<a name="ln71">			 *mbx, size_t req_size, enum qtype qtype, int version);</a>
<a name="ln72">struct oce_cq *oce_cq_create(POCE_SOFTC sc,</a>
<a name="ln73">			     struct oce_eq *eq,</a>
<a name="ln74">			     uint32_t q_len,</a>
<a name="ln75">			     uint32_t item_size,</a>
<a name="ln76">			     uint32_t sol_event,</a>
<a name="ln77">			     uint32_t is_eventable,</a>
<a name="ln78">			     uint32_t nodelay, uint32_t ncoalesce);</a>
<a name="ln79">static void oce_cq_del(POCE_SOFTC sc, struct oce_cq *cq);</a>
<a name="ln80"> </a>
<a name="ln81"> </a>
<a name="ln82"> </a>
<a name="ln83">/**</a>
<a name="ln84"> * @brief	Create and initialize all the queues on the board</a>
<a name="ln85"> * @param sc	software handle to the device</a>
<a name="ln86"> * @returns 0	if successful, or error</a>
<a name="ln87"> **/</a>
<a name="ln88">int</a>
<a name="ln89">oce_queue_init_all(POCE_SOFTC sc)</a>
<a name="ln90">{</a>
<a name="ln91">	int rc = 0, i, vector;</a>
<a name="ln92">	struct oce_wq *wq;</a>
<a name="ln93">	struct oce_rq *rq;</a>
<a name="ln94">	struct oce_aic_obj *aic;</a>
<a name="ln95"> </a>
<a name="ln96">	/* alloc TX/RX queues */</a>
<a name="ln97">	for_all_wq_queues(sc, wq, i) {</a>
<a name="ln98">		sc-&gt;wq[i] = oce_wq_init(sc, sc-&gt;tx_ring_size,</a>
<a name="ln99">					 NIC_WQ_TYPE_STANDARD);</a>
<a name="ln100">		if (!sc-&gt;wq[i]) </a>
<a name="ln101">			goto error;</a>
<a name="ln102">		</a>
<a name="ln103">	}</a>
<a name="ln104"> </a>
<a name="ln105">	for_all_rq_queues(sc, rq, i) {</a>
<a name="ln106">		sc-&gt;rq[i] = oce_rq_init(sc, sc-&gt;rx_ring_size, sc-&gt;rq_frag_size,</a>
<a name="ln107">					OCE_MAX_JUMBO_FRAME_SIZE,</a>
<a name="ln108">					(i == 0) ? 0 : is_rss_enabled(sc));</a>
<a name="ln109">		if (!sc-&gt;rq[i]) </a>
<a name="ln110">			goto error;</a>
<a name="ln111">	}</a>
<a name="ln112"> </a>
<a name="ln113">	/* Create network interface on card */</a>
<a name="ln114">	if (oce_create_nw_interface(sc))</a>
<a name="ln115">		goto error;</a>
<a name="ln116"> </a>
<a name="ln117">	/* create all of the event queues */</a>
<a name="ln118">	for (vector = 0; vector &lt; sc-&gt;intr_count; vector++) {</a>
<a name="ln119">		/* setup aic defaults for each event queue */</a>
<a name="ln120">		aic = &amp;sc-&gt;aic_obj[vector];</a>
<a name="ln121">		aic-&gt;max_eqd = OCE_MAX_EQD;</a>
<a name="ln122">		aic-&gt;min_eqd = OCE_MIN_EQD;</a>
<a name="ln123">		aic-&gt;et_eqd = OCE_MIN_EQD;</a>
<a name="ln124">		aic-&gt;enable = TRUE;</a>
<a name="ln125">	</a>
<a name="ln126">		sc-&gt;eq[vector] = oce_eq_create(sc, sc-&gt;enable_hwlro ? EQ_LEN_2048 : EQ_LEN_1024,</a>
<a name="ln127">						EQE_SIZE_4,0, vector);	</a>
<a name="ln128"> </a>
<a name="ln129">		if (!sc-&gt;eq[vector])</a>
<a name="ln130">			goto error;</a>
<a name="ln131">	}</a>
<a name="ln132"> </a>
<a name="ln133">	/* create Tx, Rx and mcc queues */</a>
<a name="ln134">	for_all_wq_queues(sc, wq, i) {</a>
<a name="ln135">		rc = oce_wq_create(wq, sc-&gt;eq[i]);</a>
<a name="ln136">		if (rc)</a>
<a name="ln137">			goto error;</a>
<a name="ln138">		wq-&gt;queue_index = i;</a>
<a name="ln139">		TASK_INIT(&amp;wq-&gt;txtask, 1, oce_tx_task, wq);</a>
<a name="ln140">	}</a>
<a name="ln141"> </a>
<a name="ln142">	for_all_rq_queues(sc, rq, i) {</a>
<a name="ln143">		rc = oce_rq_create(rq, sc-&gt;if_id,</a>
<a name="ln144">					sc-&gt;eq[(i == 0) ? 0:(i-1)]);</a>
<a name="ln145">		if (rc)</a>
<a name="ln146">			goto error;</a>
<a name="ln147">		rq-&gt;queue_index = i;</a>
<a name="ln148">	}</a>
<a name="ln149"> </a>
<a name="ln150">	sc-&gt;mq = oce_mq_create(sc, sc-&gt;eq[0], 64);</a>
<a name="ln151">	if (!sc-&gt;mq)</a>
<a name="ln152">		goto error;</a>
<a name="ln153"> </a>
<a name="ln154">	return rc;</a>
<a name="ln155"> </a>
<a name="ln156">error:</a>
<a name="ln157">	oce_queue_release_all(sc);</a>
<a name="ln158">	return 1;</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161"> </a>
<a name="ln162"> </a>
<a name="ln163">/**</a>
<a name="ln164"> * @brief Releases all mailbox queues created</a>
<a name="ln165"> * @param sc		software handle to the device</a>
<a name="ln166"> */</a>
<a name="ln167">void</a>
<a name="ln168">oce_queue_release_all(POCE_SOFTC sc)</a>
<a name="ln169">{</a>
<a name="ln170">	int i = 0;</a>
<a name="ln171">	struct oce_wq *wq;</a>
<a name="ln172">	struct oce_rq *rq;</a>
<a name="ln173">	struct oce_eq *eq;</a>
<a name="ln174"> </a>
<a name="ln175">	/* before deleting lro queues, we have to disable hwlro	*/</a>
<a name="ln176">	if(sc-&gt;enable_hwlro)</a>
<a name="ln177">		oce_mbox_nic_set_iface_lro_config(sc, 0);</a>
<a name="ln178"> </a>
<a name="ln179">	for_all_rq_queues(sc, rq, i) {</a>
<a name="ln180">		if (rq) {</a>
<a name="ln181">			oce_rq_del(sc-&gt;rq[i]);</a>
<a name="ln182">			oce_rq_free(sc-&gt;rq[i]);</a>
<a name="ln183">		}</a>
<a name="ln184">	}</a>
<a name="ln185"> </a>
<a name="ln186">	for_all_wq_queues(sc, wq, i) {</a>
<a name="ln187">		if (wq) {</a>
<a name="ln188">			oce_wq_del(sc-&gt;wq[i]);</a>
<a name="ln189">			oce_wq_free(sc-&gt;wq[i]);</a>
<a name="ln190">		}</a>
<a name="ln191">	}</a>
<a name="ln192"> </a>
<a name="ln193">	if (sc-&gt;mq)</a>
<a name="ln194">		oce_mq_free(sc-&gt;mq);</a>
<a name="ln195"> </a>
<a name="ln196">	for_all_evnt_queues(sc, eq, i) {</a>
<a name="ln197">		if (eq)</a>
<a name="ln198">			oce_eq_del(sc-&gt;eq[i]);</a>
<a name="ln199">	}</a>
<a name="ln200">}</a>
<a name="ln201"> </a>
<a name="ln202"> </a>
<a name="ln203"> </a>
<a name="ln204">/**</a>
<a name="ln205"> * @brief 		Function to create a WQ for NIC Tx</a>
<a name="ln206"> * @param sc 		software handle to the device</a>
<a name="ln207"> * @param qlen		number of entries in the queue</a>
<a name="ln208"> * @param wq_type	work queue type</a>
<a name="ln209"> * @returns		the pointer to the WQ created or NULL on failure</a>
<a name="ln210"> */</a>
<a name="ln211">static struct</a>
<a name="ln212">oce_wq *oce_wq_init(POCE_SOFTC sc, uint32_t q_len, uint32_t wq_type)</a>
<a name="ln213">{</a>
<a name="ln214">	struct oce_wq *wq;</a>
<a name="ln215">	int rc = 0, i;</a>
<a name="ln216"> </a>
<a name="ln217">	/* q_len must be min 256 and max 2k */</a>
<a name="ln218">	if (q_len &lt; 256 || q_len &gt; 2048) {</a>
<a name="ln219">		device_printf(sc-&gt;dev,</a>
<a name="ln220">			  &quot;Invalid q length. Must be &quot;</a>
<a name="ln221">			  &quot;[256, 2000]: 0x%x\n&quot;, q_len);</a>
<a name="ln222">		return NULL;</a>
<a name="ln223">	}</a>
<a name="ln224"> </a>
<a name="ln225">	/* allocate wq */</a>
<a name="ln226">	wq = malloc(sizeof(struct oce_wq), M_DEVBUF, M_NOWAIT | M_ZERO);</a>
<a name="ln227">	if (!wq)</a>
<a name="ln228">		return NULL;</a>
<a name="ln229"> </a>
<a name="ln230">	/* Set the wq config */</a>
<a name="ln231">	wq-&gt;cfg.q_len = q_len;</a>
<a name="ln232">	wq-&gt;cfg.wq_type = (uint8_t) wq_type;</a>
<a name="ln233">	wq-&gt;cfg.eqd = OCE_DEFAULT_WQ_EQD;</a>
<a name="ln234">	wq-&gt;cfg.nbufs = 2 * wq-&gt;cfg.q_len;</a>
<a name="ln235">	wq-&gt;cfg.nhdl = 2 * wq-&gt;cfg.q_len;</a>
<a name="ln236"> </a>
<a name="ln237">	wq-&gt;parent = (void *)sc;</a>
<a name="ln238"> </a>
<a name="ln239">	rc = bus_dma_tag_create(bus_get_dma_tag(sc-&gt;dev),</a>
<a name="ln240">				1, 0,</a>
<a name="ln241">				BUS_SPACE_MAXADDR,</a>
<a name="ln242">				BUS_SPACE_MAXADDR,</a>
<a name="ln243">				NULL, NULL,</a>
<a name="ln244">				OCE_MAX_TX_SIZE,</a>
<a name="ln245">				OCE_MAX_TX_ELEMENTS,</a>
<a name="ln246">				PAGE_SIZE, 0, NULL, NULL, &amp;wq-&gt;tag);</a>
<a name="ln247"> </a>
<a name="ln248">	if (rc)</a>
<a name="ln249">		goto free_wq;</a>
<a name="ln250"> </a>
<a name="ln251"> </a>
<a name="ln252">	for (i = 0; i &lt; OCE_WQ_PACKET_ARRAY_SIZE; i++) {</a>
<a name="ln253">		rc = bus_dmamap_create(wq-&gt;tag, 0, &amp;wq-&gt;pckts[i].map);</a>
<a name="ln254">		if (rc) </a>
<a name="ln255">			goto free_wq;</a>
<a name="ln256">	}</a>
<a name="ln257"> </a>
<a name="ln258">	wq-&gt;ring = oce_create_ring_buffer(sc, q_len, NIC_WQE_SIZE);</a>
<a name="ln259">	if (!wq-&gt;ring)</a>
<a name="ln260">		goto free_wq;</a>
<a name="ln261"> </a>
<a name="ln262"> </a>
<a name="ln263">	LOCK_CREATE(&amp;wq-&gt;tx_lock, &quot;TX_lock&quot;);</a>
<a name="ln264">	LOCK_CREATE(&amp;wq-&gt;tx_compl_lock, &quot;WQ_HANDLER_LOCK&quot;);</a>
<a name="ln265">	</a>
<a name="ln266">#if __FreeBSD_version &gt;= 800000</a>
<a name="ln267">	/* Allocate buf ring for multiqueue*/</a>
<a name="ln268">	wq-&gt;br = buf_ring_alloc(4096, M_DEVBUF,</a>
<a name="ln269">			M_WAITOK, &amp;wq-&gt;tx_lock.mutex);</a>
<a name="ln270">	if (!wq-&gt;br)</a>
<a name="ln271">		goto free_wq;</a>
<a name="ln272">#endif</a>
<a name="ln273">	return wq;</a>
<a name="ln274"> </a>
<a name="ln275"> </a>
<a name="ln276">free_wq:</a>
<a name="ln277">	device_printf(sc-&gt;dev, &quot;Create WQ failed\n&quot;);</a>
<a name="ln278">	oce_wq_free(wq);</a>
<a name="ln279">	return NULL;</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282"> </a>
<a name="ln283"> </a>
<a name="ln284">/**</a>
<a name="ln285"> * @brief 		Frees the work queue</a>
<a name="ln286"> * @param wq		pointer to work queue to free</a>
<a name="ln287"> */</a>
<a name="ln288">static void</a>
<a name="ln289">oce_wq_free(struct oce_wq *wq)</a>
<a name="ln290">{</a>
<a name="ln291">	POCE_SOFTC sc = (POCE_SOFTC) wq-&gt;parent;</a>
<a name="ln292">	int i;</a>
<a name="ln293"> </a>
<a name="ln294">	taskqueue_drain(taskqueue_swi, &amp;wq-&gt;txtask);</a>
<a name="ln295"> </a>
<a name="ln296">	if (wq-&gt;ring != NULL) {</a>
<a name="ln297">		oce_destroy_ring_buffer(sc, wq-&gt;ring);</a>
<a name="ln298">		wq-&gt;ring = NULL;</a>
<a name="ln299">	}</a>
<a name="ln300"> </a>
<a name="ln301">	for (i = 0; i &lt; OCE_WQ_PACKET_ARRAY_SIZE; i++) {</a>
<a name="ln302">		if (wq-&gt;pckts[i].map != NULL) {</a>
<a name="ln303">			bus_dmamap_unload(wq-&gt;tag, wq-&gt;pckts[i].map);</a>
<a name="ln304">			bus_dmamap_destroy(wq-&gt;tag, wq-&gt;pckts[i].map);</a>
<a name="ln305">			wq-&gt;pckts[i].map = NULL;</a>
<a name="ln306">		}</a>
<a name="ln307">	}</a>
<a name="ln308"> </a>
<a name="ln309">	if (wq-&gt;tag != NULL)</a>
<a name="ln310">		bus_dma_tag_destroy(wq-&gt;tag);</a>
<a name="ln311">	if (wq-&gt;br != NULL)</a>
<a name="ln312">		buf_ring_free(wq-&gt;br, M_DEVBUF);</a>
<a name="ln313"> </a>
<a name="ln314">	LOCK_DESTROY(&amp;wq-&gt;tx_lock);</a>
<a name="ln315">	LOCK_DESTROY(&amp;wq-&gt;tx_compl_lock);</a>
<a name="ln316">	free(wq, M_DEVBUF);</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319"> </a>
<a name="ln320"> </a>
<a name="ln321">/**</a>
<a name="ln322"> * @brief 		Create a work queue</a>
<a name="ln323"> * @param wq		pointer to work queue</a>
<a name="ln324"> * @param eq		pointer to associated event queue</a>
<a name="ln325"> */</a>
<a name="ln326">static int</a>
<a name="ln327">oce_wq_create(struct oce_wq *wq, struct oce_eq *eq)</a>
<a name="ln328">{</a>
<a name="ln329">	POCE_SOFTC sc = wq-&gt;parent;</a>
<a name="ln330">	struct oce_cq *cq;</a>
<a name="ln331">	int rc = 0;</a>
<a name="ln332"> </a>
<a name="ln333">	/* create the CQ */</a>
<a name="ln334">	cq = oce_cq_create(sc,</a>
<a name="ln335">			   eq,</a>
<a name="ln336">			   CQ_LEN_1024,</a>
<a name="ln337">			   sizeof(struct oce_nic_tx_cqe), 0, 1, 0, 3);</a>
<a name="ln338">	if (!cq)</a>
<a name="ln339">		return ENXIO;</a>
<a name="ln340"> </a>
<a name="ln341"> </a>
<a name="ln342">	wq-&gt;cq = cq;</a>
<a name="ln343"> </a>
<a name="ln344">	rc = oce_mbox_create_wq(wq);</a>
<a name="ln345">	if (rc)</a>
<a name="ln346">		goto error;</a>
<a name="ln347"> </a>
<a name="ln348">	wq-&gt;qstate = QCREATED;</a>
<a name="ln349">	wq-&gt;wq_free = wq-&gt;cfg.q_len;</a>
<a name="ln350">	wq-&gt;ring-&gt;cidx = 0;</a>
<a name="ln351">	wq-&gt;ring-&gt;pidx = 0;</a>
<a name="ln352"> </a>
<a name="ln353">	eq-&gt;cq[eq-&gt;cq_valid] = cq;</a>
<a name="ln354">	eq-&gt;cq_valid++;</a>
<a name="ln355">	cq-&gt;cb_arg = wq;</a>
<a name="ln356">	cq-&gt;cq_handler = oce_wq_handler;</a>
<a name="ln357"> </a>
<a name="ln358">	return 0;</a>
<a name="ln359"> </a>
<a name="ln360">error:</a>
<a name="ln361">	device_printf(sc-&gt;dev, &quot;WQ create failed\n&quot;);</a>
<a name="ln362">	oce_wq_del(wq);</a>
<a name="ln363">	return rc;</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366"> </a>
<a name="ln367"> </a>
<a name="ln368"> </a>
<a name="ln369">/**</a>
<a name="ln370"> * @brief 		Delete a work queue</a>
<a name="ln371"> * @param wq		pointer to work queue</a>
<a name="ln372"> */</a>
<a name="ln373">static void</a>
<a name="ln374">oce_wq_del(struct oce_wq *wq)</a>
<a name="ln375">{</a>
<a name="ln376">	struct oce_mbx mbx;</a>
<a name="ln377">	struct mbx_delete_nic_wq *fwcmd;</a>
<a name="ln378">	POCE_SOFTC sc = (POCE_SOFTC) wq-&gt;parent;</a>
<a name="ln379"> </a>
<a name="ln380">	if (wq-&gt;qstate == QCREATED) {</a>
<a name="ln381">		bzero(&amp;mbx, sizeof(struct oce_mbx));</a>
<a name="ln382">		/* now fill the command */</a>
<a name="ln383">		fwcmd = (struct mbx_delete_nic_wq *)&amp;mbx.payload;</a>
<a name="ln384">		fwcmd-&gt;params.req.wq_id = wq-&gt;wq_id;</a>
<a name="ln385">		(void)oce_destroy_q(sc, &amp;mbx,</a>
<a name="ln386">				sizeof(struct mbx_delete_nic_wq), QTYPE_WQ, 0);</a>
<a name="ln387">		wq-&gt;qstate = QDELETED;</a>
<a name="ln388">	}</a>
<a name="ln389"> </a>
<a name="ln390">	if (wq-&gt;cq != NULL) {</a>
<a name="ln391">		oce_cq_del(sc, wq-&gt;cq);</a>
<a name="ln392">		wq-&gt;cq = NULL;</a>
<a name="ln393">	}</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396"> </a>
<a name="ln397"> </a>
<a name="ln398">/**</a>
<a name="ln399"> * @brief 		function to allocate receive queue resources</a>
<a name="ln400"> * @param sc		software handle to the device</a>
<a name="ln401"> * @param q_len		length of receive queue</a>
<a name="ln402"> * @param frag_size	size of an receive queue fragment</a>
<a name="ln403"> * @param mtu		maximum transmission unit</a>
<a name="ln404"> * @param rss		is-rss-queue flag</a>
<a name="ln405"> * @returns		the pointer to the RQ created or NULL on failure</a>
<a name="ln406"> */</a>
<a name="ln407">static struct</a>
<a name="ln408">oce_rq *oce_rq_init(POCE_SOFTC sc,</a>
<a name="ln409">				  uint32_t q_len,</a>
<a name="ln410">				  uint32_t frag_size,</a>
<a name="ln411">				  uint32_t mtu, uint32_t rss)</a>
<a name="ln412">{</a>
<a name="ln413">	struct oce_rq *rq;</a>
<a name="ln414">	int rc = 0, i;</a>
<a name="ln415"> </a>
<a name="ln416">	if (OCE_LOG2(frag_size) &lt;= 0)</a>
<a name="ln417">		return NULL;</a>
<a name="ln418">	</a>
<a name="ln419">	if ((q_len == 0) || (q_len &gt; 1024))</a>
<a name="ln420">		return NULL;</a>
<a name="ln421"> </a>
<a name="ln422">	/* allocate the rq */</a>
<a name="ln423">	rq = malloc(sizeof(struct oce_rq), M_DEVBUF, M_NOWAIT | M_ZERO);</a>
<a name="ln424">	if (!rq) </a>
<a name="ln425">		return NULL;</a>
<a name="ln426"> </a>
<a name="ln427">	</a>
<a name="ln428">	rq-&gt;cfg.q_len = q_len;</a>
<a name="ln429">	rq-&gt;cfg.frag_size = frag_size;</a>
<a name="ln430">	rq-&gt;cfg.mtu = mtu;</a>
<a name="ln431">	rq-&gt;cfg.eqd = 0;</a>
<a name="ln432">	rq-&gt;lro_pkts_queued = 0;</a>
<a name="ln433">	rq-&gt;cfg.is_rss_queue = rss;</a>
<a name="ln434">        rq-&gt;pending = 0;</a>
<a name="ln435"> </a>
<a name="ln436">	rq-&gt;parent = (void *)sc;</a>
<a name="ln437"> </a>
<a name="ln438">	rc = bus_dma_tag_create(bus_get_dma_tag(sc-&gt;dev),</a>
<a name="ln439">			1, 0,</a>
<a name="ln440">			BUS_SPACE_MAXADDR,</a>
<a name="ln441">			BUS_SPACE_MAXADDR,</a>
<a name="ln442">			NULL, NULL,</a>
<a name="ln443">			oce_rq_buf_size,</a>
<a name="ln444">			1, oce_rq_buf_size, 0, NULL, NULL, &amp;rq-&gt;tag);</a>
<a name="ln445">	if (rc)</a>
<a name="ln446">		goto free_rq;</a>
<a name="ln447"> </a>
<a name="ln448">	for (i = 0; i &lt; OCE_RQ_PACKET_ARRAY_SIZE; i++) {</a>
<a name="ln449">		rc = bus_dmamap_create(rq-&gt;tag, 0, &amp;rq-&gt;pckts[i].map);</a>
<a name="ln450">		if (rc)</a>
<a name="ln451">			goto free_rq;</a>
<a name="ln452">	}</a>
<a name="ln453"> </a>
<a name="ln454">	/* create the ring buffer */</a>
<a name="ln455">	rq-&gt;ring = oce_create_ring_buffer(sc, q_len,</a>
<a name="ln456">				 sizeof(struct oce_nic_rqe));</a>
<a name="ln457">	if (!rq-&gt;ring)</a>
<a name="ln458">		goto free_rq;</a>
<a name="ln459"> </a>
<a name="ln460">	LOCK_CREATE(&amp;rq-&gt;rx_lock, &quot;RX_lock&quot;);</a>
<a name="ln461"> </a>
<a name="ln462">	return rq;</a>
<a name="ln463"> </a>
<a name="ln464">free_rq:</a>
<a name="ln465">	device_printf(sc-&gt;dev, &quot;Create RQ failed\n&quot;);</a>
<a name="ln466">	oce_rq_free(rq);</a>
<a name="ln467">	return NULL;</a>
<a name="ln468">}</a>
<a name="ln469"> </a>
<a name="ln470"> </a>
<a name="ln471"> </a>
<a name="ln472"> </a>
<a name="ln473">/**</a>
<a name="ln474"> * @brief 		Free a receive queue</a>
<a name="ln475"> * @param rq		pointer to receive queue</a>
<a name="ln476"> */</a>
<a name="ln477">static void</a>
<a name="ln478">oce_rq_free(struct oce_rq *rq)</a>
<a name="ln479">{</a>
<a name="ln480">	POCE_SOFTC sc = (POCE_SOFTC) rq-&gt;parent;</a>
<a name="ln481">	int i = 0 ;</a>
<a name="ln482"> </a>
<a name="ln483">	if (rq-&gt;ring != NULL) {</a>
<a name="ln484">		oce_destroy_ring_buffer(sc, rq-&gt;ring);</a>
<a name="ln485">		rq-&gt;ring = NULL;</a>
<a name="ln486">	}</a>
<a name="ln487">	for (i = 0; i &lt; OCE_RQ_PACKET_ARRAY_SIZE; i++) {</a>
<a name="ln488">		if (rq-&gt;pckts[i].map != NULL) {</a>
<a name="ln489">			bus_dmamap_unload(rq-&gt;tag, rq-&gt;pckts[i].map);</a>
<a name="ln490">			bus_dmamap_destroy(rq-&gt;tag, rq-&gt;pckts[i].map);</a>
<a name="ln491">			rq-&gt;pckts[i].map = NULL;</a>
<a name="ln492">		}</a>
<a name="ln493">		if (rq-&gt;pckts[i].mbuf) {</a>
<a name="ln494">			m_free(rq-&gt;pckts[i].mbuf);</a>
<a name="ln495">			rq-&gt;pckts[i].mbuf = NULL;</a>
<a name="ln496">		}</a>
<a name="ln497">	}</a>
<a name="ln498"> </a>
<a name="ln499">	if (rq-&gt;tag != NULL)</a>
<a name="ln500">		bus_dma_tag_destroy(rq-&gt;tag);</a>
<a name="ln501"> </a>
<a name="ln502">	LOCK_DESTROY(&amp;rq-&gt;rx_lock);</a>
<a name="ln503">	free(rq, M_DEVBUF);</a>
<a name="ln504">}</a>
<a name="ln505"> </a>
<a name="ln506"> </a>
<a name="ln507"> </a>
<a name="ln508"> </a>
<a name="ln509">/**</a>
<a name="ln510"> * @brief 		Create a receive queue</a>
<a name="ln511"> * @param rq 		receive queue</a>
<a name="ln512"> * @param if_id		interface identifier index`</a>
<a name="ln513"> * @param eq		pointer to event queue</a>
<a name="ln514"> */</a>
<a name="ln515">static int</a>
<a name="ln516">oce_rq_create(struct oce_rq *rq, uint32_t if_id, struct oce_eq *eq)</a>
<a name="ln517">{</a>
<a name="ln518">	POCE_SOFTC sc = rq-&gt;parent;</a>
<a name="ln519">	struct oce_cq *cq;</a>
<a name="ln520"> </a>
<a name="ln521">	cq = oce_cq_create(sc, eq,</a>
<a name="ln522">		       	sc-&gt;enable_hwlro ? CQ_LEN_2048 : CQ_LEN_1024,</a>
<a name="ln523">			sizeof(struct oce_nic_rx_cqe), 0, 1, 0, 3);		</a>
<a name="ln524">			</a>
<a name="ln525">	if (!cq)</a>
<a name="ln526">		return ENXIO;</a>
<a name="ln527"> </a>
<a name="ln528">	rq-&gt;cq = cq;</a>
<a name="ln529">	rq-&gt;cfg.if_id = if_id;</a>
<a name="ln530"> </a>
<a name="ln531">	/* Dont create RQ here. Create in if_activate */</a>
<a name="ln532">	rq-&gt;qstate     = 0;</a>
<a name="ln533">	rq-&gt;ring-&gt;cidx = 0;</a>
<a name="ln534">	rq-&gt;ring-&gt;pidx = 0;</a>
<a name="ln535">	eq-&gt;cq[eq-&gt;cq_valid] = cq;</a>
<a name="ln536">	eq-&gt;cq_valid++;</a>
<a name="ln537">	cq-&gt;cb_arg = rq;</a>
<a name="ln538">	cq-&gt;cq_handler = oce_rq_handler;</a>
<a name="ln539"> </a>
<a name="ln540">	return 0;</a>
<a name="ln541"> </a>
<a name="ln542">}</a>
<a name="ln543"> </a>
<a name="ln544"> </a>
<a name="ln545"> </a>
<a name="ln546"> </a>
<a name="ln547">/**</a>
<a name="ln548"> * @brief 		Delete a receive queue</a>
<a name="ln549"> * @param rq		receive queue</a>
<a name="ln550"> */</a>
<a name="ln551">static void</a>
<a name="ln552">oce_rq_del(struct oce_rq *rq)</a>
<a name="ln553">{</a>
<a name="ln554">	POCE_SOFTC sc = (POCE_SOFTC) rq-&gt;parent;</a>
<a name="ln555">	struct oce_mbx mbx;</a>
<a name="ln556">	struct mbx_delete_nic_rq *fwcmd;</a>
<a name="ln557">	struct mbx_delete_nic_rq_v1 *fwcmd1;</a>
<a name="ln558"> </a>
<a name="ln559">	if (rq-&gt;qstate == QCREATED) {</a>
<a name="ln560">		bzero(&amp;mbx, sizeof(mbx));</a>
<a name="ln561">		if(!rq-&gt;islro) {</a>
<a name="ln562">			fwcmd = (struct mbx_delete_nic_rq *)&amp;mbx.payload;</a>
<a name="ln563">			fwcmd-&gt;params.req.rq_id = rq-&gt;rq_id;</a>
<a name="ln564">			(void)oce_destroy_q(sc, &amp;mbx, sizeof(struct mbx_delete_nic_rq), QTYPE_RQ, 0);</a>
<a name="ln565">		}else {</a>
<a name="ln566">			fwcmd1 = (struct mbx_delete_nic_rq_v1 *)&amp;mbx.payload;</a>
<a name="ln567">			fwcmd1-&gt;params.req.rq_id = rq-&gt;rq_id;</a>
<a name="ln568">			fwcmd1-&gt;params.req.rq_flags = (NIC_RQ_FLAGS_RSS | NIC_RQ_FLAGS_LRO);</a>
<a name="ln569">			(void)oce_destroy_q(sc, &amp;mbx, sizeof(struct mbx_delete_nic_rq_v1), QTYPE_RQ, 1);</a>
<a name="ln570">		}</a>
<a name="ln571">		rq-&gt;qstate = QDELETED;</a>
<a name="ln572">	}</a>
<a name="ln573"> </a>
<a name="ln574">	if (rq-&gt;cq != NULL) {</a>
<a name="ln575">		oce_cq_del(sc, rq-&gt;cq);</a>
<a name="ln576">		rq-&gt;cq = NULL;</a>
<a name="ln577">	}</a>
<a name="ln578">}</a>
<a name="ln579"> </a>
<a name="ln580"> </a>
<a name="ln581"> </a>
<a name="ln582">/**</a>
<a name="ln583"> * @brief		function to create an event queue</a>
<a name="ln584"> * @param sc		software handle to the device</a>
<a name="ln585"> * @param q_len		length of event queue</a>
<a name="ln586"> * @param item_size	size of an event queue item</a>
<a name="ln587"> * @param eq_delay	event queue delay</a>
<a name="ln588"> * @retval eq      	success, pointer to event queue</a>
<a name="ln589"> * @retval NULL		failure</a>
<a name="ln590"> */</a>
<a name="ln591">static struct</a>
<a name="ln592">oce_eq *oce_eq_create(POCE_SOFTC sc, uint32_t q_len,</a>
<a name="ln593">				    uint32_t item_size,</a>
<a name="ln594">				    uint32_t eq_delay,</a>
<a name="ln595">				    uint32_t vector)</a>
<a name="ln596">{</a>
<a name="ln597">	struct oce_eq *eq;</a>
<a name="ln598">	int rc = 0;</a>
<a name="ln599"> </a>
<a name="ln600">	/* allocate an eq */</a>
<a name="ln601">	eq = malloc(sizeof(struct oce_eq), M_DEVBUF, M_NOWAIT | M_ZERO);</a>
<a name="ln602">	if (eq == NULL)</a>
<a name="ln603">		return NULL;</a>
<a name="ln604"> </a>
<a name="ln605">	eq-&gt;parent = (void *)sc;</a>
<a name="ln606">	eq-&gt;eq_id = 0xffff;</a>
<a name="ln607">	eq-&gt;ring = oce_create_ring_buffer(sc, q_len, item_size);</a>
<a name="ln608">	if (!eq-&gt;ring)</a>
<a name="ln609">		goto free_eq;</a>
<a name="ln610">	</a>
<a name="ln611">	eq-&gt;eq_cfg.q_len = q_len;</a>
<a name="ln612">	eq-&gt;eq_cfg.item_size = item_size;</a>
<a name="ln613">	eq-&gt;eq_cfg.cur_eqd = (uint8_t) eq_delay;</a>
<a name="ln614"> </a>
<a name="ln615">	rc = oce_mbox_create_eq(eq);</a>
<a name="ln616">	if (rc)</a>
<a name="ln617">		goto free_eq;</a>
<a name="ln618"> </a>
<a name="ln619">	sc-&gt;intrs[sc-&gt;neqs++].eq = eq;</a>
<a name="ln620"> </a>
<a name="ln621">	return eq;</a>
<a name="ln622"> </a>
<a name="ln623">free_eq:</a>
<a name="ln624">	oce_eq_del(eq);</a>
<a name="ln625">	return NULL;</a>
<a name="ln626">}</a>
<a name="ln627"> </a>
<a name="ln628"> </a>
<a name="ln629"> </a>
<a name="ln630"> </a>
<a name="ln631">/**</a>
<a name="ln632"> * @brief 		Function to delete an event queue</a>
<a name="ln633"> * @param eq		pointer to an event queue</a>
<a name="ln634"> */</a>
<a name="ln635">static void</a>
<a name="ln636">oce_eq_del(struct oce_eq *eq)</a>
<a name="ln637">{</a>
<a name="ln638">	struct oce_mbx mbx;</a>
<a name="ln639">	struct mbx_destroy_common_eq *fwcmd;</a>
<a name="ln640">	POCE_SOFTC sc = (POCE_SOFTC) eq-&gt;parent;</a>
<a name="ln641"> </a>
<a name="ln642">	if (eq-&gt;eq_id != 0xffff) {</a>
<a name="ln643">		bzero(&amp;mbx, sizeof(mbx));</a>
<a name="ln644">		fwcmd = (struct mbx_destroy_common_eq *)&amp;mbx.payload;</a>
<a name="ln645">		fwcmd-&gt;params.req.id = eq-&gt;eq_id;</a>
<a name="ln646">		(void)oce_destroy_q(sc, &amp;mbx,</a>
<a name="ln647">			sizeof(struct mbx_destroy_common_eq), QTYPE_EQ, 0);</a>
<a name="ln648">	}</a>
<a name="ln649"> </a>
<a name="ln650">	if (eq-&gt;ring != NULL) {</a>
<a name="ln651">		oce_destroy_ring_buffer(sc, eq-&gt;ring);</a>
<a name="ln652">		eq-&gt;ring = NULL;</a>
<a name="ln653">	}</a>
<a name="ln654"> </a>
<a name="ln655">	free(eq, M_DEVBUF);</a>
<a name="ln656"> </a>
<a name="ln657">}</a>
<a name="ln658"> </a>
<a name="ln659"> </a>
<a name="ln660"> </a>
<a name="ln661"> </a>
<a name="ln662">/**</a>
<a name="ln663"> * @brief		Function to create an MQ</a>
<a name="ln664"> * @param sc		software handle to the device</a>
<a name="ln665"> * @param eq		the EQ to associate with the MQ for event notification</a>
<a name="ln666"> * @param q_len		the number of entries to create in the MQ</a>
<a name="ln667"> * @returns		pointer to the created MQ, failure otherwise</a>
<a name="ln668"> */</a>
<a name="ln669">static struct oce_mq *</a>
<a name="ln670">oce_mq_create(POCE_SOFTC sc, struct oce_eq *eq, uint32_t q_len)</a>
<a name="ln671">{</a>
<a name="ln672">	struct oce_mbx mbx;</a>
<a name="ln673">	struct mbx_create_common_mq_ex *fwcmd = NULL;</a>
<a name="ln674">	struct oce_mq *mq = NULL;</a>
<a name="ln675">	int rc = 0;</a>
<a name="ln676">	struct oce_cq *cq;</a>
<a name="ln677">	oce_mq_ext_ctx_t *ctx;</a>
<a name="ln678">	uint32_t num_pages;</a>
<a name="ln679">	uint32_t page_size;</a>
<a name="ln680">	int version;</a>
<a name="ln681"> </a>
<a name="ln682">	cq = oce_cq_create(sc, eq, CQ_LEN_256,</a>
<a name="ln683">			sizeof(struct oce_mq_cqe), 1, 1, 0, 0);</a>
<a name="ln684">	if (!cq)</a>
<a name="ln685">		return NULL;</a>
<a name="ln686"> </a>
<a name="ln687">	/* allocate the mq */</a>
<a name="ln688">	mq = malloc(sizeof(struct oce_mq), M_DEVBUF, M_NOWAIT | M_ZERO);</a>
<a name="ln689">	if (!mq) {</a>
<a name="ln690">		oce_cq_del(sc, cq);</a>
<a name="ln691">		goto error;</a>
<a name="ln692">	}</a>
<a name="ln693"> </a>
<a name="ln694">	mq-&gt;parent = sc;</a>
<a name="ln695"> </a>
<a name="ln696">	mq-&gt;ring = oce_create_ring_buffer(sc, q_len, sizeof(struct oce_mbx));</a>
<a name="ln697">	if (!mq-&gt;ring)</a>
<a name="ln698">		goto error;</a>
<a name="ln699"> </a>
<a name="ln700">	bzero(&amp;mbx, sizeof(struct oce_mbx));</a>
<a name="ln701"> </a>
<a name="ln702">	IS_XE201(sc) ? (version = OCE_MBX_VER_V1) : (version = OCE_MBX_VER_V0);</a>
<a name="ln703">	fwcmd = (struct mbx_create_common_mq_ex *)&amp;mbx.payload;</a>
<a name="ln704">	mbx_common_req_hdr_init(&amp;fwcmd-&gt;hdr, 0, 0,</a>
<a name="ln705">				MBX_SUBSYSTEM_COMMON,</a>
<a name="ln706">				OPCODE_COMMON_CREATE_MQ_EXT,</a>
<a name="ln707">				MBX_TIMEOUT_SEC,</a>
<a name="ln708">				sizeof(struct mbx_create_common_mq_ex),</a>
<a name="ln709">				version);</a>
<a name="ln710"> </a>
<a name="ln711">	num_pages = oce_page_list(mq-&gt;ring, &amp;fwcmd-&gt;params.req.pages[0]);</a>
<a name="ln712">	page_size = mq-&gt;ring-&gt;num_items * mq-&gt;ring-&gt;item_size;</a>
<a name="ln713"> </a>
<a name="ln714">	ctx = &amp;fwcmd-&gt;params.req.context;</a>
<a name="ln715"> </a>
<a name="ln716">	if (IS_XE201(sc)) {</a>
<a name="ln717">		ctx-&gt;v1.num_pages = num_pages;</a>
<a name="ln718">		ctx-&gt;v1.ring_size = OCE_LOG2(q_len) + 1;</a>
<a name="ln719">		ctx-&gt;v1.cq_id = cq-&gt;cq_id;</a>
<a name="ln720">		ctx-&gt;v1.valid = 1;</a>
<a name="ln721">		ctx-&gt;v1.async_cq_id = cq-&gt;cq_id;</a>
<a name="ln722">		ctx-&gt;v1.async_cq_valid = 1;</a>
<a name="ln723">		/* Subscribe to Link State and Group 5 Events(bits 1 &amp; 5 set) */</a>
<a name="ln724">		ctx-&gt;v1.async_evt_bitmap |= LE_32(0x00000022);</a>
<a name="ln725">		ctx-&gt;v1.async_evt_bitmap |= LE_32(1 &lt;&lt; ASYNC_EVENT_CODE_DEBUG);</a>
<a name="ln726">		ctx-&gt;v1.async_evt_bitmap |=</a>
<a name="ln727">					LE_32(1 &lt;&lt; ASYNC_EVENT_CODE_SLIPORT);</a>
<a name="ln728">	}</a>
<a name="ln729">	else {</a>
<a name="ln730">		ctx-&gt;v0.num_pages = num_pages;</a>
<a name="ln731">		ctx-&gt;v0.cq_id = cq-&gt;cq_id;</a>
<a name="ln732">		ctx-&gt;v0.ring_size = OCE_LOG2(q_len) + 1;</a>
<a name="ln733">		ctx-&gt;v0.valid = 1;</a>
<a name="ln734">		/* Subscribe to Link State and Group5 Events(bits 1 &amp; 5 set) */</a>
<a name="ln735">		ctx-&gt;v0.async_evt_bitmap = 0xffffffff;</a>
<a name="ln736">	}</a>
<a name="ln737"> </a>
<a name="ln738">	mbx.u0.s.embedded = 1;</a>
<a name="ln739">	mbx.payload_length = sizeof(struct mbx_create_common_mq_ex);</a>
<a name="ln740">	DW_SWAP(u32ptr(&amp;mbx), mbx.payload_length + OCE_BMBX_RHDR_SZ);</a>
<a name="ln741"> </a>
<a name="ln742">	rc = oce_mbox_post(sc, &amp;mbx, NULL);</a>
<a name="ln743">	if (!rc)</a>
<a name="ln744">                rc = fwcmd-&gt;hdr.u0.rsp.status;</a>
<a name="ln745">	if (rc) {</a>
<a name="ln746">		device_printf(sc-&gt;dev,&quot;%s failed - cmd status: %d\n&quot;,</a>
<a name="ln747">			      __FUNCTION__, rc);</a>
<a name="ln748">		goto error;</a>
<a name="ln749">	}</a>
<a name="ln750">	mq-&gt;mq_id = LE_16(fwcmd-&gt;params.rsp.mq_id);</a>
<a name="ln751">	mq-&gt;cq = cq;</a>
<a name="ln752">	eq-&gt;cq[eq-&gt;cq_valid] = cq;</a>
<a name="ln753">	eq-&gt;cq_valid++;</a>
<a name="ln754">	mq-&gt;cq-&gt;eq = eq;</a>
<a name="ln755">	mq-&gt;cfg.q_len = (uint8_t) q_len;</a>
<a name="ln756">	mq-&gt;cfg.eqd = 0;</a>
<a name="ln757">	mq-&gt;qstate = QCREATED;</a>
<a name="ln758"> </a>
<a name="ln759">	mq-&gt;cq-&gt;cb_arg = mq;</a>
<a name="ln760">	mq-&gt;cq-&gt;cq_handler = oce_mq_handler;</a>
<a name="ln761"> </a>
<a name="ln762">	return mq;</a>
<a name="ln763"> </a>
<a name="ln764">error:</a>
<a name="ln765">	device_printf(sc-&gt;dev, &quot;MQ create failed\n&quot;);</a>
<a name="ln766">	oce_mq_free(mq);</a>
<a name="ln767">	mq = NULL;</a>
<a name="ln768">	return mq;</a>
<a name="ln769">}</a>
<a name="ln770"> </a>
<a name="ln771"> </a>
<a name="ln772"> </a>
<a name="ln773"> </a>
<a name="ln774"> </a>
<a name="ln775">/**</a>
<a name="ln776"> * @brief		Function to free a mailbox queue</a>
<a name="ln777"> * @param mq		pointer to a mailbox queue</a>
<a name="ln778"> */</a>
<a name="ln779">static void</a>
<a name="ln780">oce_mq_free(struct oce_mq *mq)</a>
<a name="ln781">{</a>
<a name="ln782">	POCE_SOFTC sc = (POCE_SOFTC) mq-&gt;parent;</a>
<a name="ln783">	struct oce_mbx mbx;</a>
<a name="ln784">	struct mbx_destroy_common_mq *fwcmd;</a>
<a name="ln785"> </a>
<a name="ln786">	if (!mq)</a>
<a name="ln787">		return;</a>
<a name="ln788"> </a>
<a name="ln789">	if (mq-&gt;ring != NULL) {</a>
<a name="ln790">		oce_destroy_ring_buffer(sc, mq-&gt;ring);</a>
<a name="ln791">		mq-&gt;ring = NULL;</a>
<a name="ln792">		if (mq-&gt;qstate == QCREATED) {</a>
<a name="ln793">			bzero(&amp;mbx, sizeof (struct oce_mbx));</a>
<a name="ln794">			fwcmd = (struct mbx_destroy_common_mq *)&amp;mbx.payload;</a>
<a name="ln795">			fwcmd-&gt;params.req.id = mq-&gt;mq_id;</a>
<a name="ln796">			(void) oce_destroy_q(sc, &amp;mbx,</a>
<a name="ln797">				sizeof (struct mbx_destroy_common_mq),</a>
<a name="ln798">				QTYPE_MQ, 0);</a>
<a name="ln799">		}</a>
<a name="ln800">		mq-&gt;qstate = QDELETED;</a>
<a name="ln801">	}</a>
<a name="ln802"> </a>
<a name="ln803">	if (mq-&gt;cq != NULL) {</a>
<a name="ln804">		oce_cq_del(sc, mq-&gt;cq);</a>
<a name="ln805">		mq-&gt;cq = NULL;</a>
<a name="ln806">	}</a>
<a name="ln807"> </a>
<a name="ln808">	free(mq, M_DEVBUF);</a>
<a name="ln809">	mq = NULL;</a>
<a name="ln810">}</a>
<a name="ln811"> </a>
<a name="ln812"> </a>
<a name="ln813"> </a>
<a name="ln814">/**</a>
<a name="ln815"> * @brief		Function to delete a EQ, CQ, MQ, WQ or RQ</a>
<a name="ln816"> * @param sc		sofware handle to the device</a>
<a name="ln817"> * @param mbx		mailbox command to send to the fw to delete the queue</a>
<a name="ln818"> *			(mbx contains the queue information to delete)</a>
<a name="ln819"> * @param req_size	the size of the mbx payload dependent on the qtype</a>
<a name="ln820"> * @param qtype		the type of queue i.e. EQ, CQ, MQ, WQ or RQ</a>
<a name="ln821"> * @returns 		0 on success, failure otherwise</a>
<a name="ln822"> */</a>
<a name="ln823">static int</a>
<a name="ln824">oce_destroy_q(POCE_SOFTC sc, struct oce_mbx *mbx, size_t req_size,</a>
<a name="ln825">		enum qtype qtype, int version)</a>
<a name="ln826">{</a>
<a name="ln827">	struct mbx_hdr *hdr = (struct mbx_hdr *)&amp;mbx-&gt;payload;</a>
<a name="ln828">	int opcode;</a>
<a name="ln829">	int subsys;</a>
<a name="ln830">	int rc = 0;</a>
<a name="ln831"> </a>
<a name="ln832">	switch (qtype) {</a>
<a name="ln833">	case QTYPE_EQ:</a>
<a name="ln834">		opcode = OPCODE_COMMON_DESTROY_EQ;</a>
<a name="ln835">		subsys = MBX_SUBSYSTEM_COMMON;</a>
<a name="ln836">		break;</a>
<a name="ln837">	case QTYPE_CQ:</a>
<a name="ln838">		opcode = OPCODE_COMMON_DESTROY_CQ;</a>
<a name="ln839">		subsys = MBX_SUBSYSTEM_COMMON;</a>
<a name="ln840">		break;</a>
<a name="ln841">	case QTYPE_MQ:</a>
<a name="ln842">		opcode = OPCODE_COMMON_DESTROY_MQ;</a>
<a name="ln843">		subsys = MBX_SUBSYSTEM_COMMON;</a>
<a name="ln844">		break;</a>
<a name="ln845">	case QTYPE_WQ:</a>
<a name="ln846">		opcode = NIC_DELETE_WQ;</a>
<a name="ln847">		subsys = MBX_SUBSYSTEM_NIC;</a>
<a name="ln848">		break;</a>
<a name="ln849">	case QTYPE_RQ:</a>
<a name="ln850">		opcode = NIC_DELETE_RQ;</a>
<a name="ln851">		subsys = MBX_SUBSYSTEM_NIC;</a>
<a name="ln852">		break;</a>
<a name="ln853">	default:</a>
<a name="ln854">		return EINVAL;</a>
<a name="ln855">	}</a>
<a name="ln856"> </a>
<a name="ln857">	mbx_common_req_hdr_init(hdr, 0, 0, subsys,</a>
<a name="ln858">				opcode, MBX_TIMEOUT_SEC, req_size,</a>
<a name="ln859">				version);</a>
<a name="ln860"> </a>
<a name="ln861">	mbx-&gt;u0.s.embedded = 1;</a>
<a name="ln862">	mbx-&gt;payload_length = (uint32_t) req_size;</a>
<a name="ln863">	DW_SWAP(u32ptr(mbx), mbx-&gt;payload_length + OCE_BMBX_RHDR_SZ);</a>
<a name="ln864"> </a>
<a name="ln865">	rc = oce_mbox_post(sc, mbx, NULL);</a>
<a name="ln866">	if (!rc)</a>
<a name="ln867">                rc = hdr-&gt;u0.rsp.status;</a>
<a name="ln868">	if (rc)</a>
<a name="ln869">		device_printf(sc-&gt;dev,&quot;%s failed - cmd status: %d\n&quot;,</a>
<a name="ln870">			      __FUNCTION__, rc);</a>
<a name="ln871">	return rc;</a>
<a name="ln872">}</a>
<a name="ln873"> </a>
<a name="ln874"> </a>
<a name="ln875"> </a>
<a name="ln876">/**</a>
<a name="ln877"> * @brief		Function to create a completion queue</a>
<a name="ln878"> * @param sc		software handle to the device</a>
<a name="ln879"> * @param eq		optional eq to be associated with to the cq</a>
<a name="ln880"> * @param q_len		length of completion queue</a>
<a name="ln881"> * @param item_size	size of completion queue items</a>
<a name="ln882"> * @param sol_event	command context event</a>
<a name="ln883"> * @param is_eventable	event table</a>
<a name="ln884"> * @param nodelay	no delay flag</a>
<a name="ln885"> * @param ncoalesce	no coalescence flag</a>
<a name="ln886"> * @returns 		pointer to the cq created, NULL on failure</a>
<a name="ln887"> */</a>
<a name="ln888">struct oce_cq *</a>
<a name="ln889">oce_cq_create(POCE_SOFTC sc, struct oce_eq *eq,</a>
<a name="ln890">			     uint32_t q_len,</a>
<a name="ln891">			     uint32_t item_size,</a>
<a name="ln892">			     uint32_t sol_event,</a>
<a name="ln893">			     uint32_t is_eventable,</a>
<a name="ln894">			     uint32_t nodelay, uint32_t ncoalesce)</a>
<a name="ln895">{</a>
<a name="ln896">	struct oce_cq *cq = NULL;</a>
<a name="ln897">	int rc = 0;</a>
<a name="ln898"> </a>
<a name="ln899">	cq = malloc(sizeof(struct oce_cq), M_DEVBUF, M_NOWAIT | M_ZERO);</a>
<a name="ln900">	if (!cq)</a>
<a name="ln901">		return NULL;</a>
<a name="ln902"> </a>
<a name="ln903">	cq-&gt;ring = oce_create_ring_buffer(sc, q_len, item_size);</a>
<a name="ln904">	if (!cq-&gt;ring)</a>
<a name="ln905">		goto error;</a>
<a name="ln906">	</a>
<a name="ln907">	cq-&gt;parent = sc;</a>
<a name="ln908">	cq-&gt;eq = eq;</a>
<a name="ln909">	cq-&gt;cq_cfg.q_len = q_len;</a>
<a name="ln910">	cq-&gt;cq_cfg.item_size = item_size;</a>
<a name="ln911">	cq-&gt;cq_cfg.nodelay = (uint8_t) nodelay;</a>
<a name="ln912"> </a>
<a name="ln913">	rc = oce_mbox_cq_create(cq, ncoalesce, is_eventable);</a>
<a name="ln914">	if (rc)</a>
<a name="ln915">		goto error;</a>
<a name="ln916"> </a>
<a name="ln917">	sc-&gt;cq[sc-&gt;ncqs++] = cq;</a>
<a name="ln918"> </a>
<a name="ln919">	return cq;</a>
<a name="ln920"> </a>
<a name="ln921">error:</a>
<a name="ln922">	device_printf(sc-&gt;dev, &quot;CQ create failed\n&quot;);</a>
<a name="ln923">	oce_cq_del(sc, cq);</a>
<a name="ln924">	return NULL;</a>
<a name="ln925">}</a>
<a name="ln926"> </a>
<a name="ln927"> </a>
<a name="ln928"> </a>
<a name="ln929">/**</a>
<a name="ln930"> * @brief		Deletes the completion queue</a>
<a name="ln931"> * @param sc		software handle to the device</a>
<a name="ln932"> * @param cq		pointer to a completion queue</a>
<a name="ln933"> */</a>
<a name="ln934">static void </a>
<a name="ln935">oce_cq_del(POCE_SOFTC sc, struct oce_cq *cq)</a>
<a name="ln936">{</a>
<a name="ln937">	struct oce_mbx mbx;</a>
<a name="ln938">	struct mbx_destroy_common_cq *fwcmd;</a>
<a name="ln939"> </a>
<a name="ln940">	if (cq-&gt;ring != NULL) {</a>
<a name="ln941"> </a>
<a name="ln942">		bzero(&amp;mbx, sizeof(struct oce_mbx));</a>
<a name="ln943">		/* now fill the command */</a>
<a name="ln944">		fwcmd = (struct mbx_destroy_common_cq *)&amp;mbx.payload;</a>
<a name="ln945">		fwcmd-&gt;params.req.id = cq-&gt;cq_id;</a>
<a name="ln946">		(void)oce_destroy_q(sc, &amp;mbx,</a>
<a name="ln947">			sizeof(struct mbx_destroy_common_cq), QTYPE_CQ, 0);</a>
<a name="ln948">		/*NOW destroy the ring */</a>
<a name="ln949">		oce_destroy_ring_buffer(sc, cq-&gt;ring);</a>
<a name="ln950">		cq-&gt;ring = NULL;</a>
<a name="ln951">	}</a>
<a name="ln952"> </a>
<a name="ln953">	free(cq, M_DEVBUF);</a>
<a name="ln954">	cq = NULL;</a>
<a name="ln955">}</a>
<a name="ln956"> </a>
<a name="ln957"> </a>
<a name="ln958"> </a>
<a name="ln959">/**</a>
<a name="ln960"> * @brief		Start a receive queue</a>
<a name="ln961"> * @param rq		pointer to a receive queue</a>
<a name="ln962"> */</a>
<a name="ln963">int</a>
<a name="ln964">oce_start_rq(struct oce_rq *rq)</a>
<a name="ln965">{</a>
<a name="ln966">	POCE_SOFTC sc = (POCE_SOFTC) rq-&gt;parent;</a>
<a name="ln967">	int rc;</a>
<a name="ln968"> </a>
<a name="ln969">	if(sc-&gt;enable_hwlro)</a>
<a name="ln970">		rc = oce_alloc_rx_bufs(rq, 960);</a>
<a name="ln971">	else</a>
<a name="ln972">		rc = oce_alloc_rx_bufs(rq, rq-&gt;cfg.q_len - 1);</a>
<a name="ln973"> </a>
<a name="ln974">	if (rc == 0)</a>
<a name="ln975">		oce_arm_cq(rq-&gt;parent, rq-&gt;cq-&gt;cq_id, 0, TRUE);</a>
<a name="ln976"> </a>
<a name="ln977">	return rc;</a>
<a name="ln978">}</a>
<a name="ln979"> </a>
<a name="ln980"> </a>
<a name="ln981"> </a>
<a name="ln982">/**</a>
<a name="ln983"> * @brief		Start a work queue</a>
<a name="ln984"> * @param wq		pointer to a work queue</a>
<a name="ln985"> */</a>
<a name="ln986">int</a>
<a name="ln987">oce_start_wq(struct oce_wq *wq)</a>
<a name="ln988">{</a>
<a name="ln989">	oce_arm_cq(wq-&gt;parent, wq-&gt;cq-&gt;cq_id, 0, TRUE);</a>
<a name="ln990">	return 0;</a>
<a name="ln991">}</a>
<a name="ln992"> </a>
<a name="ln993"> </a>
<a name="ln994"> </a>
<a name="ln995">/**</a>
<a name="ln996"> * @brief		Start a mailbox queue</a>
<a name="ln997"> * @param mq		pointer to a mailbox queue</a>
<a name="ln998"> */</a>
<a name="ln999">int</a>
<a name="ln1000">oce_start_mq(struct oce_mq *mq)</a>
<a name="ln1001">{</a>
<a name="ln1002">	oce_arm_cq(mq-&gt;parent, mq-&gt;cq-&gt;cq_id, 0, TRUE);</a>
<a name="ln1003">	return 0;</a>
<a name="ln1004">}</a>
<a name="ln1005"> </a>
<a name="ln1006"> </a>
<a name="ln1007"> </a>
<a name="ln1008">/**</a>
<a name="ln1009"> * @brief		Function to arm an EQ so that it can generate events</a>
<a name="ln1010"> * @param sc		software handle to the device</a>
<a name="ln1011"> * @param qid		id of the EQ returned by the fw at the time of creation</a>
<a name="ln1012"> * @param npopped	number of EQEs to arm</a>
<a name="ln1013"> * @param rearm		rearm bit enable/disable</a>
<a name="ln1014"> * @param clearint	bit to clear the interrupt condition because of which</a>
<a name="ln1015"> *			EQEs are generated</a>
<a name="ln1016"> */</a>
<a name="ln1017">void</a>
<a name="ln1018">oce_arm_eq(POCE_SOFTC sc,</a>
<a name="ln1019">	   int16_t qid, int npopped, uint32_t rearm, uint32_t clearint)</a>
<a name="ln1020">{</a>
<a name="ln1021">	eq_db_t eq_db = { 0 };</a>
<a name="ln1022"> </a>
<a name="ln1023">	eq_db.bits.rearm = rearm;</a>
<a name="ln1024">	eq_db.bits.event = 1;</a>
<a name="ln1025">	eq_db.bits.num_popped = npopped;</a>
<a name="ln1026">	eq_db.bits.clrint = clearint;</a>
<a name="ln1027">	eq_db.bits.qid = qid;</a>
<a name="ln1028">	OCE_WRITE_REG32(sc, db, PD_EQ_DB, eq_db.dw0);</a>
<a name="ln1029"> </a>
<a name="ln1030">}</a>
<a name="ln1031"> </a>
<a name="ln1032"> </a>
<a name="ln1033"> </a>
<a name="ln1034"> </a>
<a name="ln1035">/**</a>
<a name="ln1036"> * @brief		Function to arm a CQ with CQEs</a>
<a name="ln1037"> * @param sc		software handle to the device</a>
<a name="ln1038"> * @param qid		id of the CQ returned by the fw at the time of creation</a>
<a name="ln1039"> * @param npopped	number of CQEs to arm</a>
<a name="ln1040"> * @param rearm		rearm bit enable/disable</a>
<a name="ln1041"> */</a>
<a name="ln1042">void oce_arm_cq(POCE_SOFTC sc, int16_t qid, int npopped, uint32_t rearm)</a>
<a name="ln1043">{</a>
<a name="ln1044">	cq_db_t cq_db = { 0 };</a>
<a name="ln1045"> </a>
<a name="ln1046">	cq_db.bits.rearm = rearm;</a>
<a name="ln1047">	cq_db.bits.num_popped = npopped;</a>
<a name="ln1048">	cq_db.bits.event = 0;</a>
<a name="ln1049">	cq_db.bits.qid = qid;</a>
<a name="ln1050">	OCE_WRITE_REG32(sc, db, PD_CQ_DB, cq_db.dw0);</a>
<a name="ln1051"> </a>
<a name="ln1052">}</a>
<a name="ln1053"> </a>
<a name="ln1054"> </a>
<a name="ln1055"> </a>
<a name="ln1056"> </a>
<a name="ln1057">/*</a>
<a name="ln1058"> * @brief		function to cleanup the eqs used during stop</a>
<a name="ln1059"> * @param eq		pointer to event queue structure</a>
<a name="ln1060"> * @returns		the number of EQs processed</a>
<a name="ln1061"> */</a>
<a name="ln1062">void</a>
<a name="ln1063">oce_drain_eq(struct oce_eq *eq)</a>
<a name="ln1064">{</a>
<a name="ln1065"> </a>
<a name="ln1066">	struct oce_eqe *eqe;</a>
<a name="ln1067">	uint16_t num_eqe = 0;</a>
<a name="ln1068">	POCE_SOFTC sc = eq-&gt;parent;</a>
<a name="ln1069"> </a>
<a name="ln1070">	do {</a>
<a name="ln1071">		eqe = RING_GET_CONSUMER_ITEM_VA(eq-&gt;ring, struct oce_eqe);</a>
<a name="ln1072">		if (eqe-&gt;evnt == 0)</a>
<a name="ln1073">			break;</a>
<a name="ln1074">		eqe-&gt;evnt = 0;</a>
<a name="ln1075">		bus_dmamap_sync(eq-&gt;ring-&gt;dma.tag, eq-&gt;ring-&gt;dma.map,</a>
<a name="ln1076">					BUS_DMASYNC_POSTWRITE);</a>
<a name="ln1077">		num_eqe++;</a>
<a name="ln1078">		RING_GET(eq-&gt;ring, 1);</a>
<a name="ln1079"> </a>
<a name="ln1080">	} while (TRUE);</a>
<a name="ln1081"> </a>
<a name="ln1082">	oce_arm_eq(sc, eq-&gt;eq_id, num_eqe, FALSE, TRUE);</a>
<a name="ln1083">	</a>
<a name="ln1084">}</a>
<a name="ln1085"> </a>
<a name="ln1086"> </a>
<a name="ln1087"> </a>
<a name="ln1088">void</a>
<a name="ln1089">oce_drain_wq_cq(struct oce_wq *wq)</a>
<a name="ln1090">{</a>
<a name="ln1091">        POCE_SOFTC sc = wq-&gt;parent;</a>
<a name="ln1092">        struct oce_cq *cq = wq-&gt;cq;</a>
<a name="ln1093">        struct oce_nic_tx_cqe *cqe;</a>
<a name="ln1094">        int num_cqes = 0;</a>
<a name="ln1095"> </a>
<a name="ln1096">	bus_dmamap_sync(cq-&gt;ring-&gt;dma.tag, cq-&gt;ring-&gt;dma.map,</a>
<a name="ln1097">				 BUS_DMASYNC_POSTWRITE);</a>
<a name="ln1098"> </a>
<a name="ln1099">	do {</a>
<a name="ln1100">		cqe = RING_GET_CONSUMER_ITEM_VA(cq-&gt;ring, struct oce_nic_tx_cqe);</a>
<a name="ln1101">		if (cqe-&gt;u0.dw[3] == 0)</a>
<a name="ln1102">			break;			</a>
<a name="ln1103">		cqe-&gt;u0.dw[3] = 0;</a>
<a name="ln1104">		bus_dmamap_sync(cq-&gt;ring-&gt;dma.tag, cq-&gt;ring-&gt;dma.map,</a>
<a name="ln1105">				 BUS_DMASYNC_POSTWRITE);</a>
<a name="ln1106">		RING_GET(cq-&gt;ring, 1);</a>
<a name="ln1107">		num_cqes++;</a>
<a name="ln1108"> </a>
<a name="ln1109">	} while (TRUE);</a>
<a name="ln1110"> </a>
<a name="ln1111">	oce_arm_cq(sc, cq-&gt;cq_id, num_cqes, FALSE);</a>
<a name="ln1112"> </a>
<a name="ln1113">}</a>
<a name="ln1114"> </a>
<a name="ln1115"> </a>
<a name="ln1116">/*</a>
<a name="ln1117"> * @brief		function to drain a MCQ and process its CQEs</a>
<a name="ln1118"> * @param dev		software handle to the device</a>
<a name="ln1119"> * @param cq		pointer to the cq to drain</a>
<a name="ln1120"> * @returns		the number of CQEs processed</a>
<a name="ln1121"> */</a>
<a name="ln1122">void</a>
<a name="ln1123">oce_drain_mq_cq(void *arg)</a>
<a name="ln1124">{</a>
<a name="ln1125">	/* TODO: additional code. */</a>
<a name="ln1126">	return;</a>
<a name="ln1127">}</a>
<a name="ln1128"> </a>
<a name="ln1129"> </a>
<a name="ln1130"> </a>
<a name="ln1131">/**</a>
<a name="ln1132"> * @brief		function to process a Recieve queue</a>
<a name="ln1133"> * @param arg		pointer to the RQ to charge</a>
<a name="ln1134"> * @return		number of cqes processed</a>
<a name="ln1135"> */</a>
<a name="ln1136">void</a>
<a name="ln1137">oce_drain_rq_cq(struct oce_rq *rq)</a>
<a name="ln1138">{</a>
<a name="ln1139">	struct oce_nic_rx_cqe *cqe;</a>
<a name="ln1140">	uint16_t num_cqe = 0;</a>
<a name="ln1141">	struct oce_cq  *cq;</a>
<a name="ln1142">	POCE_SOFTC sc;</a>
<a name="ln1143"> </a>
<a name="ln1144">	sc = rq-&gt;parent;</a>
<a name="ln1145">	cq = rq-&gt;cq;</a>
<a name="ln1146">	cqe = RING_GET_CONSUMER_ITEM_VA(cq-&gt;ring, struct oce_nic_rx_cqe);</a>
<a name="ln1147">	/* dequeue till you reach an invalid cqe */</a>
<a name="ln1148">	while (RQ_CQE_VALID(cqe)) {</a>
<a name="ln1149">		RQ_CQE_INVALIDATE(cqe);</a>
<a name="ln1150">		RING_GET(cq-&gt;ring, 1);</a>
<a name="ln1151">		cqe = RING_GET_CONSUMER_ITEM_VA(cq-&gt;ring,</a>
<a name="ln1152">		    struct oce_nic_rx_cqe);</a>
<a name="ln1153">		num_cqe++;</a>
<a name="ln1154">	}</a>
<a name="ln1155">	oce_arm_cq(sc, cq-&gt;cq_id, num_cqe, FALSE);</a>
<a name="ln1156"> </a>
<a name="ln1157">	return;</a>
<a name="ln1158">}</a>
<a name="ln1159"> </a>
<a name="ln1160"> </a>
<a name="ln1161">void</a>
<a name="ln1162">oce_free_posted_rxbuf(struct oce_rq *rq)</a>
<a name="ln1163">{</a>
<a name="ln1164">	struct oce_packet_desc *pd;</a>
<a name="ln1165">	</a>
<a name="ln1166">	while (rq-&gt;pending) {</a>
<a name="ln1167"> </a>
<a name="ln1168">		pd = &amp;rq-&gt;pckts[rq-&gt;ring-&gt;cidx];</a>
<a name="ln1169">		bus_dmamap_sync(rq-&gt;tag, pd-&gt;map, BUS_DMASYNC_POSTWRITE);</a>
<a name="ln1170">		bus_dmamap_unload(rq-&gt;tag, pd-&gt;map);</a>
<a name="ln1171">		if (pd-&gt;mbuf != NULL) {</a>
<a name="ln1172">			m_freem(pd-&gt;mbuf);</a>
<a name="ln1173">			pd-&gt;mbuf = NULL;</a>
<a name="ln1174">		}</a>
<a name="ln1175"> </a>
<a name="ln1176">		RING_GET(rq-&gt;ring,1);</a>
<a name="ln1177">                rq-&gt;pending--;</a>
<a name="ln1178">	}</a>
<a name="ln1179"> </a>
<a name="ln1180">}</a>
<a name="ln1181"> </a>
<a name="ln1182">void</a>
<a name="ln1183">oce_rx_cq_clean_hwlro(struct oce_rq *rq)</a>
<a name="ln1184">{</a>
<a name="ln1185">        struct oce_cq *cq = rq-&gt;cq;</a>
<a name="ln1186">        POCE_SOFTC sc = rq-&gt;parent;</a>
<a name="ln1187">        struct nic_hwlro_singleton_cqe *cqe;</a>
<a name="ln1188">        struct nic_hwlro_cqe_part2 *cqe2;</a>
<a name="ln1189">        int flush_wait = 0;</a>
<a name="ln1190">        int flush_compl = 0;</a>
<a name="ln1191">	int num_frags = 0;</a>
<a name="ln1192"> </a>
<a name="ln1193">        for (;;) {</a>
<a name="ln1194">                bus_dmamap_sync(cq-&gt;ring-&gt;dma.tag,cq-&gt;ring-&gt;dma.map, BUS_DMASYNC_POSTWRITE);</a>
<a name="ln1195">                cqe = RING_GET_CONSUMER_ITEM_VA(cq-&gt;ring, struct nic_hwlro_singleton_cqe);</a>
<a name="ln1196">                if(cqe-&gt;valid) {</a>
<a name="ln1197">                        if(cqe-&gt;cqe_type == 0) { /* singleton cqe */</a>
<a name="ln1198">                                /* we should not get singleton cqe after cqe1 on same rq */</a>
<a name="ln1199">                                if(rq-&gt;cqe_firstpart != NULL) {</a>
<a name="ln1200">                                        device_printf(sc-&gt;dev, &quot;Got singleton cqe after cqe1 \n&quot;);</a>
<a name="ln1201">                                        goto exit_rx_cq_clean_hwlro;</a>
<a name="ln1202">                                }</a>
<a name="ln1203">				num_frags = cqe-&gt;pkt_size / rq-&gt;cfg.frag_size;</a>
<a name="ln1204">				if(cqe-&gt;pkt_size % rq-&gt;cfg.frag_size)</a>
<a name="ln1205">					num_frags++;</a>
<a name="ln1206">                                oce_discard_rx_comp(rq, num_frags);</a>
<a name="ln1207">                                /* Check if CQE is flush completion */</a>
<a name="ln1208">                                if(!cqe-&gt;pkt_size) </a>
<a name="ln1209">                                        flush_compl = 1;</a>
<a name="ln1210">                                cqe-&gt;valid = 0;</a>
<a name="ln1211">                                RING_GET(cq-&gt;ring, 1);</a>
<a name="ln1212">                        }else if(cqe-&gt;cqe_type == 0x1) { /* first part */</a>
<a name="ln1213">                                /* we should not get cqe1 after cqe1 on same rq */</a>
<a name="ln1214">                                if(rq-&gt;cqe_firstpart != NULL) {</a>
<a name="ln1215">                                        device_printf(sc-&gt;dev, &quot;Got cqe1 after cqe1 \n&quot;);</a>
<a name="ln1216">                                        goto exit_rx_cq_clean_hwlro;</a>
<a name="ln1217">                                }</a>
<a name="ln1218">                                rq-&gt;cqe_firstpart = (struct nic_hwlro_cqe_part1 *)cqe;</a>
<a name="ln1219">                                RING_GET(cq-&gt;ring, 1);</a>
<a name="ln1220">                        }else if(cqe-&gt;cqe_type == 0x2) { /* second part */</a>
<a name="ln1221">                                cqe2 = (struct nic_hwlro_cqe_part2 *)cqe;</a>
<a name="ln1222">                                /* We should not get cqe2 without cqe1 */</a>
<a name="ln1223">                                if(rq-&gt;cqe_firstpart == NULL) {</a>
<a name="ln1224">                                        device_printf(sc-&gt;dev, &quot;Got cqe2 without cqe1 \n&quot;);</a>
<a name="ln1225">                                        goto exit_rx_cq_clean_hwlro;</a>
<a name="ln1226">                                }</a>
<a name="ln1227">				num_frags = cqe2-&gt;coalesced_size / rq-&gt;cfg.frag_size;</a>
<a name="ln1228">				if(cqe2-&gt;coalesced_size % rq-&gt;cfg.frag_size)</a>
<a name="ln1229">					num_frags++;</a>
<a name="ln1230">				</a>
<a name="ln1231">				/* Flush completion will always come in singleton CQE */</a>
<a name="ln1232">                                oce_discard_rx_comp(rq, num_frags);</a>
<a name="ln1233"> </a>
<a name="ln1234">                                rq-&gt;cqe_firstpart-&gt;valid = 0;</a>
<a name="ln1235">                                cqe2-&gt;valid = 0;</a>
<a name="ln1236">                                rq-&gt;cqe_firstpart = NULL;</a>
<a name="ln1237">                                RING_GET(cq-&gt;ring, 1);</a>
<a name="ln1238">                        }</a>
<a name="ln1239">                        oce_arm_cq(sc, cq-&gt;cq_id, 1, FALSE);</a>
<a name="ln1240">                        if(flush_compl)</a>
<a name="ln1241">                                break;</a>
<a name="ln1242">                }else {</a>
<a name="ln1243">                        if (flush_wait++ &gt; 100) {</a>
<a name="ln1244">                                device_printf(sc-&gt;dev, &quot;did not receive hwlro flush compl\n&quot;);</a>
<a name="ln1245">                                break;</a>
<a name="ln1246">                        }</a>
<a name="ln1247">                        oce_arm_cq(sc, cq-&gt;cq_id, 0, TRUE);</a>
<a name="ln1248">                        DELAY(1000);</a>
<a name="ln1249">                }</a>
<a name="ln1250">        }</a>
<a name="ln1251"> </a>
<a name="ln1252">        /* After cleanup, leave the CQ in unarmed state */</a>
<a name="ln1253">        oce_arm_cq(sc, cq-&gt;cq_id, 0, FALSE);</a>
<a name="ln1254"> </a>
<a name="ln1255">exit_rx_cq_clean_hwlro:</a>
<a name="ln1256">	return;</a>
<a name="ln1257">}</a>
<a name="ln1258"> </a>
<a name="ln1259"> </a>
<a name="ln1260">void</a>
<a name="ln1261">oce_rx_cq_clean(struct oce_rq *rq)</a>
<a name="ln1262">{</a>
<a name="ln1263">	struct oce_nic_rx_cqe *cqe;</a>
<a name="ln1264">        struct oce_cq  *cq;</a>
<a name="ln1265">        POCE_SOFTC sc;</a>
<a name="ln1266">	int flush_wait = 0;</a>
<a name="ln1267">	int flush_compl = 0;</a>
<a name="ln1268">        sc = rq-&gt;parent;</a>
<a name="ln1269">        cq = rq-&gt;cq;</a>
<a name="ln1270">	</a>
<a name="ln1271">	for (;;) {</a>
<a name="ln1272">		bus_dmamap_sync(cq-&gt;ring-&gt;dma.tag,</a>
<a name="ln1273">			cq-&gt;ring-&gt;dma.map, BUS_DMASYNC_POSTWRITE);</a>
<a name="ln1274">        	cqe = RING_GET_CONSUMER_ITEM_VA(cq-&gt;ring, struct oce_nic_rx_cqe);</a>
<a name="ln1275">		if(RQ_CQE_VALID(cqe)) {</a>
<a name="ln1276">			DW_SWAP((uint32_t *) cqe, sizeof(oce_rq_cqe));</a>
<a name="ln1277">                        oce_discard_rx_comp(rq, cqe-&gt;u0.s.num_fragments);</a>
<a name="ln1278">                        /* Check if CQE is flush completion */</a>
<a name="ln1279">                        if((cqe-&gt;u0.s.num_fragments==0)&amp;&amp;(cqe-&gt;u0.s.pkt_size == 0)&amp;&amp;(cqe-&gt;u0.s.error == 0)) </a>
<a name="ln1280">				flush_compl = 1;</a>
<a name="ln1281">                        </a>
<a name="ln1282">                        RQ_CQE_INVALIDATE(cqe);</a>
<a name="ln1283">                        RING_GET(cq-&gt;ring, 1);</a>
<a name="ln1284">#if defined(INET6) || defined(INET)</a>
<a name="ln1285">		        if (IF_LRO_ENABLED(sc))</a>
<a name="ln1286">                		oce_rx_flush_lro(rq);</a>
<a name="ln1287">#endif</a>
<a name="ln1288">                        oce_arm_cq(sc, cq-&gt;cq_id, 1, FALSE);</a>
<a name="ln1289">			if(flush_compl)</a>
<a name="ln1290">				break;</a>
<a name="ln1291">		}else {</a>
<a name="ln1292">			if (flush_wait++ &gt; 100) {</a>
<a name="ln1293">				device_printf(sc-&gt;dev, &quot;did not receive flush compl\n&quot;);</a>
<a name="ln1294">				break;</a>
<a name="ln1295">			}</a>
<a name="ln1296">			oce_arm_cq(sc, cq-&gt;cq_id, 0, TRUE);</a>
<a name="ln1297">			DELAY(1000);</a>
<a name="ln1298">                } </a>
<a name="ln1299">        }</a>
<a name="ln1300"> </a>
<a name="ln1301">	/* After cleanup, leave the CQ in unarmed state */</a>
<a name="ln1302">	oce_arm_cq(sc, cq-&gt;cq_id, 0, FALSE);</a>
<a name="ln1303">}</a>
<a name="ln1304"> </a>
<a name="ln1305">void</a>
<a name="ln1306">oce_stop_rx(POCE_SOFTC sc)</a>
<a name="ln1307">{</a>
<a name="ln1308">        struct oce_mbx mbx;</a>
<a name="ln1309">        struct mbx_delete_nic_rq *fwcmd;</a>
<a name="ln1310">        struct mbx_delete_nic_rq_v1 *fwcmd1;</a>
<a name="ln1311">        struct oce_rq *rq;</a>
<a name="ln1312">        int i = 0;</a>
<a name="ln1313"> </a>
<a name="ln1314">       /* before deleting disable hwlro */</a>
<a name="ln1315">	if(sc-&gt;enable_hwlro)</a>
<a name="ln1316">        	oce_mbox_nic_set_iface_lro_config(sc, 0);</a>
<a name="ln1317"> </a>
<a name="ln1318">        for_all_rq_queues(sc, rq, i) {</a>
<a name="ln1319">                if (rq-&gt;qstate == QCREATED) {</a>
<a name="ln1320">                        /* Delete rxq in firmware */</a>
<a name="ln1321">			LOCK(&amp;rq-&gt;rx_lock);</a>
<a name="ln1322"> </a>
<a name="ln1323">                        bzero(&amp;mbx, sizeof(mbx));</a>
<a name="ln1324">                	if(!rq-&gt;islro) {</a>
<a name="ln1325">                        	fwcmd = (struct mbx_delete_nic_rq *)&amp;mbx.payload;</a>
<a name="ln1326">                        	fwcmd-&gt;params.req.rq_id = rq-&gt;rq_id;</a>
<a name="ln1327">                        	(void)oce_destroy_q(sc, &amp;mbx, sizeof(struct mbx_delete_nic_rq), QTYPE_RQ, 0);</a>
<a name="ln1328">                	}else {</a>
<a name="ln1329">                        	fwcmd1 = (struct mbx_delete_nic_rq_v1 *)&amp;mbx.payload;</a>
<a name="ln1330">                        	fwcmd1-&gt;params.req.rq_id = rq-&gt;rq_id;</a>
<a name="ln1331">                               	fwcmd1-&gt;params.req.rq_flags = (NIC_RQ_FLAGS_RSS | NIC_RQ_FLAGS_LRO);</a>
<a name="ln1332"> </a>
<a name="ln1333">                        	(void)oce_destroy_q(sc,&amp;mbx,sizeof(struct mbx_delete_nic_rq_v1),QTYPE_RQ,1);</a>
<a name="ln1334">                	}</a>
<a name="ln1335">                        rq-&gt;qstate = QDELETED;</a>
<a name="ln1336"> </a>
<a name="ln1337">                        DELAY(1000);</a>
<a name="ln1338">			</a>
<a name="ln1339">			if(!rq-&gt;islro)</a>
<a name="ln1340">				oce_rx_cq_clean(rq);</a>
<a name="ln1341">			else</a>
<a name="ln1342">				oce_rx_cq_clean_hwlro(rq);</a>
<a name="ln1343"> </a>
<a name="ln1344">                        /* Free posted RX buffers that are not used */</a>
<a name="ln1345">                        oce_free_posted_rxbuf(rq);</a>
<a name="ln1346">			UNLOCK(&amp;rq-&gt;rx_lock);</a>
<a name="ln1347">                }</a>
<a name="ln1348">        }</a>
<a name="ln1349">}</a>
<a name="ln1350"> </a>
<a name="ln1351"> </a>
<a name="ln1352"> </a>
<a name="ln1353">int</a>
<a name="ln1354">oce_start_rx(POCE_SOFTC sc)</a>
<a name="ln1355">{</a>
<a name="ln1356">	struct oce_rq *rq;</a>
<a name="ln1357">	int rc = 0, i;</a>
<a name="ln1358">	</a>
<a name="ln1359">	for_all_rq_queues(sc, rq, i) {</a>
<a name="ln1360">		if (rq-&gt;qstate == QCREATED)</a>
<a name="ln1361">			continue;</a>
<a name="ln1362">		if((i == 0) || (!sc-&gt;enable_hwlro)) {</a>
<a name="ln1363">        	        rc = oce_mbox_create_rq(rq);</a>
<a name="ln1364">                        if (rc)</a>
<a name="ln1365">                                goto error;</a>
<a name="ln1366">			rq-&gt;islro = 0;</a>
<a name="ln1367">		}else {</a>
<a name="ln1368">			rc = oce_mbox_create_rq_v2(rq);</a>
<a name="ln1369">                        if (rc)</a>
<a name="ln1370">                                goto error;</a>
<a name="ln1371">                        rq-&gt;islro = 1;</a>
<a name="ln1372">		}</a>
<a name="ln1373">                /* reset queue pointers */</a>
<a name="ln1374">                rq-&gt;qstate       = QCREATED;</a>
<a name="ln1375">                rq-&gt;pending      = 0;</a>
<a name="ln1376">                rq-&gt;ring-&gt;cidx   = 0;</a>
<a name="ln1377">                rq-&gt;ring-&gt;pidx   = 0;</a>
<a name="ln1378">	}</a>
<a name="ln1379">	</a>
<a name="ln1380">	if(sc-&gt;enable_hwlro) {</a>
<a name="ln1381">		rc = oce_mbox_nic_set_iface_lro_config(sc, 1);</a>
<a name="ln1382">		if (rc)</a>
<a name="ln1383">			goto error;</a>
<a name="ln1384">	}</a>
<a name="ln1385"> </a>
<a name="ln1386">	DELAY(1);</a>
<a name="ln1387">	</a>
<a name="ln1388">	/* RSS config */</a>
<a name="ln1389">	if (is_rss_enabled(sc)) {</a>
<a name="ln1390">		rc = oce_config_nic_rss(sc, (uint8_t) sc-&gt;if_id, RSS_ENABLE);</a>
<a name="ln1391">		if (rc)</a>
<a name="ln1392">			goto error;</a>
<a name="ln1393"> </a>
<a name="ln1394">	}</a>
<a name="ln1395"> </a>
<a name="ln1396">	DELAY(1);</a>
<a name="ln1397">	return rc;</a>
<a name="ln1398">error:</a>
<a name="ln1399">	device_printf(sc-&gt;dev, &quot;Start RX failed\n&quot;);</a>
<a name="ln1400">	return rc;</a>
<a name="ln1401"> </a>
<a name="ln1402">}</a>
<a name="ln1403"> </a>
<a name="ln1404"> </a>
<a name="ln1405"> </a>

</code></pre>
<div class="balloon" rel="782"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'mq' pointer was utilized before it was verified against nullptr. Check lines: 782, 786.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
