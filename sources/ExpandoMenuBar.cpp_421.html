
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ExpandoMenuBar.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">Open Tracker License</a>
<a name="ln3"> </a>
<a name="ln4">Terms and Conditions</a>
<a name="ln5"> </a>
<a name="ln6">Copyright (c) 1991-2000, Be Incorporated. All rights reserved.</a>
<a name="ln7"> </a>
<a name="ln8">Permission is hereby granted, free of charge, to any person obtaining a copy of</a>
<a name="ln9">this software and associated documentation files (the &quot;Software&quot;), to deal in</a>
<a name="ln10">the Software without restriction, including without limitation the rights to</a>
<a name="ln11">use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies</a>
<a name="ln12">of the Software, and to permit persons to whom the Software is furnished to do</a>
<a name="ln13">so, subject to the following conditions:</a>
<a name="ln14"> </a>
<a name="ln15">The above copyright notice and this permission notice applies to all licensees</a>
<a name="ln16">and shall be included in all copies or substantial portions of the Software.</a>
<a name="ln17"> </a>
<a name="ln18">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</a>
<a name="ln19">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF TITLE, MERCHANTABILITY,</a>
<a name="ln20">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL</a>
<a name="ln21">BE INCORPORATED BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN</a>
<a name="ln22">AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION</a>
<a name="ln23">WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</a>
<a name="ln24"> </a>
<a name="ln25">Except as contained in this notice, the name of Be Incorporated shall not be</a>
<a name="ln26">used in advertising or otherwise to promote the sale, use or other dealings in</a>
<a name="ln27">this Software without prior written authorization from Be Incorporated.</a>
<a name="ln28"> </a>
<a name="ln29">Tracker(TM), Be(R), BeOS(R), and BeIA(TM) are trademarks or registered</a>
<a name="ln30">trademarks of Be Incorporated in the United States and other countries. Other</a>
<a name="ln31">brand product names are registered trademarks or trademarks of their respective</a>
<a name="ln32">holders.</a>
<a name="ln33">All rights reserved.</a>
<a name="ln34">*/</a>
<a name="ln35"> </a>
<a name="ln36"> </a>
<a name="ln37">#include &quot;ExpandoMenuBar.h&quot;</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;strings.h&gt;</a>
<a name="ln40"> </a>
<a name="ln41">#include &lt;map&gt;</a>
<a name="ln42"> </a>
<a name="ln43">#include &lt;Autolock.h&gt;</a>
<a name="ln44">#include &lt;Bitmap.h&gt;</a>
<a name="ln45">#include &lt;Collator.h&gt;</a>
<a name="ln46">#include &lt;ControlLook.h&gt;</a>
<a name="ln47">#include &lt;Debug.h&gt;</a>
<a name="ln48">#include &lt;MenuPrivate.h&gt;</a>
<a name="ln49">#include &lt;NodeInfo.h&gt;</a>
<a name="ln50">#include &lt;Roster.h&gt;</a>
<a name="ln51">#include &lt;Screen.h&gt;</a>
<a name="ln52">#include &lt;Thread.h&gt;</a>
<a name="ln53">#include &lt;Window.h&gt;</a>
<a name="ln54"> </a>
<a name="ln55">#include &quot;icons.h&quot;</a>
<a name="ln56"> </a>
<a name="ln57">#include &quot;BarApp.h&quot;</a>
<a name="ln58">#include &quot;BarMenuTitle.h&quot;</a>
<a name="ln59">#include &quot;BarView.h&quot;</a>
<a name="ln60">#include &quot;BarWindow.h&quot;</a>
<a name="ln61">#include &quot;DeskbarMenu.h&quot;</a>
<a name="ln62">#include &quot;DeskbarUtils.h&quot;</a>
<a name="ln63">#include &quot;InlineScrollView.h&quot;</a>
<a name="ln64">#include &quot;ResourceSet.h&quot;</a>
<a name="ln65">#include &quot;ShowHideMenuItem.h&quot;</a>
<a name="ln66">#include &quot;StatusView.h&quot;</a>
<a name="ln67">#include &quot;TeamMenu.h&quot;</a>
<a name="ln68">#include &quot;TeamMenuItem.h&quot;</a>
<a name="ln69">#include &quot;WindowMenu.h&quot;</a>
<a name="ln70">#include &quot;WindowMenuItem.h&quot;</a>
<a name="ln71"> </a>
<a name="ln72"> </a>
<a name="ln73">const float kMinMenuItemWidth = 50.0f;</a>
<a name="ln74">const float kSepItemWidth = 5.0f;</a>
<a name="ln75">const float kIconPadding = 8.0f;</a>
<a name="ln76"> </a>
<a name="ln77">const uint32 kMinimizeTeam = 'mntm';</a>
<a name="ln78">const uint32 kBringTeamToFront = 'bftm';</a>
<a name="ln79"> </a>
<a name="ln80">bool TExpandoMenuBar::sDoMonitor = false;</a>
<a name="ln81">thread_id TExpandoMenuBar::sMonThread = B_ERROR;</a>
<a name="ln82">BLocker TExpandoMenuBar::sMonLocker(&quot;expando monitor&quot;);</a>
<a name="ln83"> </a>
<a name="ln84">typedef std::map&lt;BString, TTeamMenuItem*&gt; TeamMenuItemMap;</a>
<a name="ln85"> </a>
<a name="ln86"> </a>
<a name="ln87">//	#pragma mark - TExpandoMenuBar</a>
<a name="ln88"> </a>
<a name="ln89"> </a>
<a name="ln90">TExpandoMenuBar::TExpandoMenuBar(TBarView* barView, bool vertical)</a>
<a name="ln91">	:</a>
<a name="ln92">	BMenuBar(BRect(0, 0, 0, 0), &quot;ExpandoMenuBar&quot;, B_FOLLOW_NONE,</a>
<a name="ln93">		vertical ? B_ITEMS_IN_COLUMN : B_ITEMS_IN_ROW),</a>
<a name="ln94">	fBarView(barView),</a>
<a name="ln95">	fVertical(vertical),</a>
<a name="ln96">	fOverflow(false),</a>
<a name="ln97">	fFirstBuild(true),</a>
<a name="ln98">	fDeskbarMenuWidth(kMinMenuItemWidth),</a>
<a name="ln99">	fPreviousDragTargetItem(NULL),</a>
<a name="ln100">	fLastMousedOverItem(NULL),</a>
<a name="ln101">	fLastClickedItem(NULL)</a>
<a name="ln102">{</a>
<a name="ln103">	SetItemMargins(0.0f, 0.0f, 0.0f, 0.0f);</a>
<a name="ln104">	SetFont(be_plain_font);</a>
<a name="ln105">	SetMaxItemWidth();</a>
<a name="ln106"> </a>
<a name="ln107">	// top or bottom mode, add deskbar menu and sep for menubar tracking</a>
<a name="ln108">	// consistency</a>
<a name="ln109">	// TODO: this is broken code</a>
<a name="ln110">	fDeskbarMenuWidth = 63 + 16;</a>
<a name="ln111">//	const BBitmap* logoBitmap = AppResSet()-&gt;FindBitmap(B_MESSAGE_TYPE,</a>
<a name="ln112">//		R_LeafLogoBitmap);</a>
<a name="ln113">//	if (logoBitmap != NULL)</a>
<a name="ln114">//		fDeskbarMenuWidth = logoBitmap-&gt;Bounds().Width() + 16;</a>
<a name="ln115">}</a>
<a name="ln116"> </a>
<a name="ln117"> </a>
<a name="ln118">void</a>
<a name="ln119">TExpandoMenuBar::AllAttached()</a>
<a name="ln120">{</a>
<a name="ln121">	BMenuBar::AllAttached();</a>
<a name="ln122"> </a>
<a name="ln123">	SizeWindow(0);</a>
<a name="ln124">}</a>
<a name="ln125"> </a>
<a name="ln126"> </a>
<a name="ln127">void</a>
<a name="ln128">TExpandoMenuBar::AttachedToWindow()</a>
<a name="ln129">{</a>
<a name="ln130">	BMenuBar::AttachedToWindow();</a>
<a name="ln131"> </a>
<a name="ln132">	fTeamList.MakeEmpty();</a>
<a name="ln133"> </a>
<a name="ln134">	if (fVertical)</a>
<a name="ln135">		StartMonitoringWindows();</a>
<a name="ln136">}</a>
<a name="ln137"> </a>
<a name="ln138"> </a>
<a name="ln139">void</a>
<a name="ln140">TExpandoMenuBar::DetachedFromWindow()</a>
<a name="ln141">{</a>
<a name="ln142">	BMenuBar::DetachedFromWindow();</a>
<a name="ln143"> </a>
<a name="ln144">	StopMonitoringWindows();</a>
<a name="ln145"> </a>
<a name="ln146">	BMessenger self(this);</a>
<a name="ln147">	BMessage message(kUnsubscribe);</a>
<a name="ln148">	message.AddMessenger(&quot;messenger&quot;, self);</a>
<a name="ln149">	be_app-&gt;PostMessage(&amp;message);</a>
<a name="ln150"> </a>
<a name="ln151">	RemoveItems(0, CountItems(), true);</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154"> </a>
<a name="ln155">void</a>
<a name="ln156">TExpandoMenuBar::MessageReceived(BMessage* message)</a>
<a name="ln157">{</a>
<a name="ln158">	int32 index;</a>
<a name="ln159">	TTeamMenuItem* item;</a>
<a name="ln160"> </a>
<a name="ln161">	switch (message-&gt;what) {</a>
<a name="ln162">		case B_SOME_APP_LAUNCHED:</a>
<a name="ln163">		{</a>
<a name="ln164">			BList* teams = NULL;</a>
<a name="ln165">			message-&gt;FindPointer(&quot;teams&quot;, (void**)&amp;teams);</a>
<a name="ln166"> </a>
<a name="ln167">			BBitmap* icon = NULL;</a>
<a name="ln168">			message-&gt;FindPointer(&quot;icon&quot;, (void**)&amp;icon);</a>
<a name="ln169"> </a>
<a name="ln170">			const char* signature = NULL;</a>
<a name="ln171">			message-&gt;FindString(&quot;sig&quot;, &amp;signature);</a>
<a name="ln172"> </a>
<a name="ln173">			uint32 flags = 0;</a>
<a name="ln174">			message-&gt;FindInt32(&quot;flags&quot;, ((int32*) &amp;flags));</a>
<a name="ln175"> </a>
<a name="ln176">			const char* name = NULL;</a>
<a name="ln177">			message-&gt;FindString(&quot;name&quot;, &amp;name);</a>
<a name="ln178"> </a>
<a name="ln179">			AddTeam(teams, icon, strdup(name), strdup(signature));</a>
<a name="ln180">			break;</a>
<a name="ln181">		}</a>
<a name="ln182"> </a>
<a name="ln183">		case B_MOUSE_WHEEL_CHANGED:</a>
<a name="ln184">		{</a>
<a name="ln185">			float deltaY = 0;</a>
<a name="ln186">			message-&gt;FindFloat(&quot;be:wheel_delta_y&quot;, &amp;deltaY);</a>
<a name="ln187">			if (deltaY == 0)</a>
<a name="ln188">				return;</a>
<a name="ln189"> </a>
<a name="ln190">			TInlineScrollView* scrollView</a>
<a name="ln191">				= dynamic_cast&lt;TInlineScrollView*&gt;(Parent());</a>
<a name="ln192">			if (scrollView == NULL)</a>
<a name="ln193">				return;</a>
<a name="ln194"> </a>
<a name="ln195">			float largeStep;</a>
<a name="ln196">			float smallStep;</a>
<a name="ln197">			scrollView-&gt;GetSteps(&amp;smallStep, &amp;largeStep);</a>
<a name="ln198"> </a>
<a name="ln199">			// pressing the option/command/control key scrolls faster</a>
<a name="ln200">			if (modifiers() &amp; (B_OPTION_KEY | B_COMMAND_KEY | B_CONTROL_KEY))</a>
<a name="ln201">				deltaY *= largeStep;</a>
<a name="ln202">			else</a>
<a name="ln203">				deltaY *= smallStep;</a>
<a name="ln204"> </a>
<a name="ln205">			scrollView-&gt;ScrollBy(deltaY);</a>
<a name="ln206">			break;</a>
<a name="ln207">		}</a>
<a name="ln208"> </a>
<a name="ln209">		case kAddTeam:</a>
<a name="ln210">			AddTeam(message-&gt;FindInt32(&quot;team&quot;), message-&gt;FindString(&quot;sig&quot;));</a>
<a name="ln211">			break;</a>
<a name="ln212"> </a>
<a name="ln213">		case kRemoveTeam:</a>
<a name="ln214">		{</a>
<a name="ln215">			team_id team = -1;</a>
<a name="ln216">			message-&gt;FindInt32(&quot;team&quot;, &amp;team);</a>
<a name="ln217"> </a>
<a name="ln218">			RemoveTeam(team, true);</a>
<a name="ln219">			break;</a>
<a name="ln220">		}</a>
<a name="ln221"> </a>
<a name="ln222">		case B_SOME_APP_QUIT:</a>
<a name="ln223">		{</a>
<a name="ln224">			team_id team = -1;</a>
<a name="ln225">			message-&gt;FindInt32(&quot;team&quot;, &amp;team);</a>
<a name="ln226"> </a>
<a name="ln227">			RemoveTeam(team, false);</a>
<a name="ln228">			break;</a>
<a name="ln229">		}</a>
<a name="ln230"> </a>
<a name="ln231">		case kMinimizeTeam:</a>
<a name="ln232">		{</a>
<a name="ln233">			index = message-&gt;FindInt32(&quot;itemIndex&quot;);</a>
<a name="ln234">			item = dynamic_cast&lt;TTeamMenuItem*&gt;(ItemAt(index));</a>
<a name="ln235">			if (item == NULL)</a>
<a name="ln236">				break;</a>
<a name="ln237"> </a>
<a name="ln238">			TShowHideMenuItem::TeamShowHideCommon(B_MINIMIZE_WINDOW,</a>
<a name="ln239">				item-&gt;Teams(),</a>
<a name="ln240">				item-&gt;Menu()-&gt;ConvertToScreen(item-&gt;Frame()),</a>
<a name="ln241">				true);</a>
<a name="ln242">			break;</a>
<a name="ln243">		}</a>
<a name="ln244"> </a>
<a name="ln245">		case kBringTeamToFront:</a>
<a name="ln246">		{</a>
<a name="ln247">			index = message-&gt;FindInt32(&quot;itemIndex&quot;);</a>
<a name="ln248">			item = dynamic_cast&lt;TTeamMenuItem*&gt;(ItemAt(index));</a>
<a name="ln249">			if (item == NULL)</a>
<a name="ln250">				break;</a>
<a name="ln251"> </a>
<a name="ln252">			TShowHideMenuItem::TeamShowHideCommon(B_BRING_TO_FRONT,</a>
<a name="ln253">				item-&gt;Teams(), item-&gt;Menu()-&gt;ConvertToScreen(item-&gt;Frame()),</a>
<a name="ln254">				true);</a>
<a name="ln255">			break;</a>
<a name="ln256">		}</a>
<a name="ln257"> </a>
<a name="ln258">		default:</a>
<a name="ln259">			BMenuBar::MessageReceived(message);</a>
<a name="ln260">			break;</a>
<a name="ln261">	}</a>
<a name="ln262">}</a>
<a name="ln263"> </a>
<a name="ln264"> </a>
<a name="ln265">void</a>
<a name="ln266">TExpandoMenuBar::MouseDown(BPoint where)</a>
<a name="ln267">{</a>
<a name="ln268">	BMessage* message = Window()-&gt;CurrentMessage();</a>
<a name="ln269">	BMenuItem* menuItem;</a>
<a name="ln270">	TTeamMenuItem* item = TeamItemAtPoint(where, &amp;menuItem);</a>
<a name="ln271"> </a>
<a name="ln272">	if (message == NULL || item == NULL || fBarView-&gt;Dragging()) {</a>
<a name="ln273">		BMenuBar::MouseDown(where);</a>
<a name="ln274">		return;</a>
<a name="ln275">	}</a>
<a name="ln276"> </a>
<a name="ln277">	int32 modifiers = 0;</a>
<a name="ln278">	message-&gt;FindInt32(&quot;modifiers&quot;, &amp;modifiers);</a>
<a name="ln279"> </a>
<a name="ln280">	// check for three finger salute, a.k.a. Vulcan Death Grip</a>
<a name="ln281">	if ((modifiers &amp; B_COMMAND_KEY) != 0</a>
<a name="ln282">		&amp;&amp; (modifiers &amp; B_CONTROL_KEY) != 0</a>
<a name="ln283">		&amp;&amp; (modifiers &amp; B_SHIFT_KEY) != 0) {</a>
<a name="ln284">		const BList* teams = item-&gt;Teams();</a>
<a name="ln285">		int32 teamCount = teams-&gt;CountItems();</a>
<a name="ln286">		team_id teamID;</a>
<a name="ln287">		for (int32 team = 0; team &lt; teamCount; team++) {</a>
<a name="ln288">			teamID = (addr_t)teams-&gt;ItemAt(team);</a>
<a name="ln289">			kill_team(teamID);</a>
<a name="ln290">			RemoveTeam(teamID, false);</a>
<a name="ln291">				// remove the team from display immediately</a>
<a name="ln292">		}</a>
<a name="ln293">		return;</a>
<a name="ln294">			// absorb the message</a>
<a name="ln295">	}</a>
<a name="ln296"> </a>
<a name="ln297">	// control click - show all/hide all shortcut</a>
<a name="ln298">	if ((modifiers &amp; B_CONTROL_KEY) != 0) {</a>
<a name="ln299">		// show/hide item's teams</a>
<a name="ln300">		BMessage showMessage((modifiers &amp; B_SHIFT_KEY) != 0</a>
<a name="ln301">			? kMinimizeTeam : kBringTeamToFront);</a>
<a name="ln302">		showMessage.AddInt32(&quot;itemIndex&quot;, IndexOf(item));</a>
<a name="ln303">		Window()-&gt;PostMessage(&amp;showMessage, this);</a>
<a name="ln304">		return;</a>
<a name="ln305">			// absorb the message</a>
<a name="ln306">	}</a>
<a name="ln307"> </a>
<a name="ln308">	// check if within expander bounds to expand window items</a>
<a name="ln309">	if (fVertical &amp;&amp; static_cast&lt;TBarApp*&gt;(be_app)-&gt;Settings()-&gt;superExpando</a>
<a name="ln310">		&amp;&amp; item-&gt;ExpanderBounds().Contains(where)) {</a>
<a name="ln311">		// start the animation here, finish on mouse up</a>
<a name="ln312">		fLastClickedItem = item;</a>
<a name="ln313">		MouseDownThread&lt;TExpandoMenuBar&gt;::TrackMouse(this,</a>
<a name="ln314">			&amp;TExpandoMenuBar::_DoneTracking, &amp;TExpandoMenuBar::_Track);</a>
<a name="ln315">		Invalidate(item-&gt;ExpanderBounds());</a>
<a name="ln316">		return;</a>
<a name="ln317">			// absorb the message</a>
<a name="ln318">	}</a>
<a name="ln319"> </a>
<a name="ln320">	// double-click on an item brings the team to front</a>
<a name="ln321">	int32 clicks;</a>
<a name="ln322">	if (message-&gt;FindInt32(&quot;clicks&quot;, &amp;clicks) == B_OK &amp;&amp; clicks &gt; 1</a>
<a name="ln323">		&amp;&amp; item == menuItem &amp;&amp; item == fLastClickedItem) {</a>
<a name="ln324">		be_roster-&gt;ActivateApp((addr_t)item-&gt;Teams()-&gt;ItemAt(0));</a>
<a name="ln325">			// activate this team</a>
<a name="ln326">		return;</a>
<a name="ln327">			// absorb the message</a>
<a name="ln328">	}</a>
<a name="ln329"> </a>
<a name="ln330">	fLastClickedItem = item;</a>
<a name="ln331">	BMenuBar::MouseDown(where);</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334"> </a>
<a name="ln335">void</a>
<a name="ln336">TExpandoMenuBar::MouseMoved(BPoint where, uint32 code, const BMessage* message)</a>
<a name="ln337">{</a>
<a name="ln338">	int32 buttons;</a>
<a name="ln339">	BMessage* currentMessage = Window()-&gt;CurrentMessage();</a>
<a name="ln340">	if (currentMessage == NULL</a>
<a name="ln341">		|| currentMessage-&gt;FindInt32(&quot;buttons&quot;, &amp;buttons) != B_OK) {</a>
<a name="ln342">		buttons = 0;</a>
<a name="ln343">	}</a>
<a name="ln344"> </a>
<a name="ln345">	if (message == NULL) {</a>
<a name="ln346">		// force a cleanup</a>
<a name="ln347">		_FinishedDrag();</a>
<a name="ln348"> </a>
<a name="ln349">		switch (code) {</a>
<a name="ln350">			case B_INSIDE_VIEW:</a>
<a name="ln351">			{</a>
<a name="ln352">				BMenuItem* menuItem;</a>
<a name="ln353">				TTeamMenuItem* item = TeamItemAtPoint(where, &amp;menuItem);</a>
<a name="ln354">				TWindowMenuItem* windowMenuItem</a>
<a name="ln355">					= dynamic_cast&lt;TWindowMenuItem*&gt;(menuItem);</a>
<a name="ln356"> </a>
<a name="ln357">				if (item == NULL || menuItem == NULL) {</a>
<a name="ln358">					// item is NULL, remove the tooltip and break out</a>
<a name="ln359">					fLastMousedOverItem = NULL;</a>
<a name="ln360">					SetToolTip((const char*)NULL);</a>
<a name="ln361">					break;</a>
<a name="ln362">				}</a>
<a name="ln363"> </a>
<a name="ln364">				if (menuItem == fLastMousedOverItem) {</a>
<a name="ln365">					// already set the tooltip for this item, break out</a>
<a name="ln366">					break;</a>
<a name="ln367">				}</a>
<a name="ln368"> </a>
<a name="ln369">				if (windowMenuItem != NULL &amp;&amp; fBarView-&gt;Vertical()</a>
<a name="ln370">					&amp;&amp; fBarView-&gt;ExpandoState() &amp;&amp; item-&gt;IsExpanded()) {</a>
<a name="ln371">					// expando mode window menu item</a>
<a name="ln372">					fLastMousedOverItem = menuItem;</a>
<a name="ln373">					if (strcasecmp(windowMenuItem-&gt;TruncatedLabel(),</a>
<a name="ln374">							windowMenuItem-&gt;Label()) &gt; 0) {</a>
<a name="ln375">						// label is truncated, set tooltip</a>
<a name="ln376">						SetToolTip(windowMenuItem-&gt;Label());</a>
<a name="ln377">					} else</a>
<a name="ln378">						SetToolTip((const char*)NULL);</a>
<a name="ln379"> </a>
<a name="ln380">					break;</a>
<a name="ln381">				}</a>
<a name="ln382"> </a>
<a name="ln383">				if (!dynamic_cast&lt;TBarApp*&gt;(be_app)-&gt;Settings()-&gt;hideLabels) {</a>
<a name="ln384">					// item has a visible label, set tool tip if truncated</a>
<a name="ln385">					fLastMousedOverItem = menuItem;</a>
<a name="ln386">					if (strcasecmp(item-&gt;TruncatedLabel(), item-&gt;Label()) &gt; 0) {</a>
<a name="ln387">						// label is truncated, set tooltip</a>
<a name="ln388">						SetToolTip(item-&gt;Label());</a>
<a name="ln389">					} else</a>
<a name="ln390">						SetToolTip((const char*)NULL);</a>
<a name="ln391"> </a>
<a name="ln392">					break;</a>
<a name="ln393">				}</a>
<a name="ln394"> </a>
<a name="ln395">				SetToolTip(item-&gt;Label());</a>
<a name="ln396">					// new item, set the tooltip to the item label</a>
<a name="ln397">				fLastMousedOverItem = menuItem;</a>
<a name="ln398">					// save the current menuitem for the next MouseMoved() call</a>
<a name="ln399">				break;</a>
<a name="ln400">			}</a>
<a name="ln401">		}</a>
<a name="ln402"> </a>
<a name="ln403">		BMenuBar::MouseMoved(where, code, message);</a>
<a name="ln404">		return;</a>
<a name="ln405">	}</a>
<a name="ln406"> </a>
<a name="ln407">	if (buttons == 0)</a>
<a name="ln408">		return;</a>
<a name="ln409"> </a>
<a name="ln410">	switch (code) {</a>
<a name="ln411">		case B_ENTERED_VIEW:</a>
<a name="ln412">			// fPreviousDragTargetItem should always be NULL here anyways.</a>
<a name="ln413">			if (fPreviousDragTargetItem != NULL)</a>
<a name="ln414">				_FinishedDrag();</a>
<a name="ln415"> </a>
<a name="ln416">			fBarView-&gt;CacheDragData(message);</a>
<a name="ln417">			fPreviousDragTargetItem = NULL;</a>
<a name="ln418">			break;</a>
<a name="ln419"> </a>
<a name="ln420">		case B_OUTSIDE_VIEW:</a>
<a name="ln421">			// NOTE: Should not be here, but for the sake of defensive</a>
<a name="ln422">			// programming... fall-through</a>
<a name="ln423">		case B_EXITED_VIEW:</a>
<a name="ln424">			_FinishedDrag();</a>
<a name="ln425">			break;</a>
<a name="ln426"> </a>
<a name="ln427">		case B_INSIDE_VIEW:</a>
<a name="ln428">			if (fBarView-&gt;Dragging()) {</a>
<a name="ln429">				TTeamMenuItem* item = NULL;</a>
<a name="ln430">				int32 itemCount = CountItems();</a>
<a name="ln431">				for (int32 i = 0; i &lt; itemCount; i++) {</a>
<a name="ln432">					BMenuItem* _item = ItemAt(i);</a>
<a name="ln433">					if (_item-&gt;Frame().Contains(where)) {</a>
<a name="ln434">						item = dynamic_cast&lt;TTeamMenuItem*&gt;(_item);</a>
<a name="ln435">						break;</a>
<a name="ln436">					}</a>
<a name="ln437">				}</a>
<a name="ln438">				if (item == fPreviousDragTargetItem)</a>
<a name="ln439">					break;</a>
<a name="ln440">				if (fPreviousDragTargetItem != NULL)</a>
<a name="ln441">					fPreviousDragTargetItem-&gt;SetOverrideSelected(false);</a>
<a name="ln442">				if (item != NULL)</a>
<a name="ln443">					item-&gt;SetOverrideSelected(true);</a>
<a name="ln444">				fPreviousDragTargetItem = item;</a>
<a name="ln445">			}</a>
<a name="ln446">			break;</a>
<a name="ln447">	}</a>
<a name="ln448">}</a>
<a name="ln449"> </a>
<a name="ln450"> </a>
<a name="ln451">void</a>
<a name="ln452">TExpandoMenuBar::MouseUp(BPoint where)</a>
<a name="ln453">{</a>
<a name="ln454">	if (fBarView-&gt;Dragging()) {</a>
<a name="ln455">		_FinishedDrag(true);</a>
<a name="ln456">		return;</a>
<a name="ln457">			// absorb the message</a>
<a name="ln458">	}</a>
<a name="ln459"> </a>
<a name="ln460">	BMenuBar::MouseUp(where);</a>
<a name="ln461">}</a>
<a name="ln462"> </a>
<a name="ln463"> </a>
<a name="ln464">void</a>
<a name="ln465">TExpandoMenuBar::BuildItems()</a>
<a name="ln466">{</a>
<a name="ln467">	BMessenger self(this);</a>
<a name="ln468">	TBarApp::Subscribe(self, &amp;fTeamList);</a>
<a name="ln469"> </a>
<a name="ln470">	int32 iconSize = static_cast&lt;TBarApp*&gt;(be_app)-&gt;IconSize();</a>
<a name="ln471">	desk_settings* settings = static_cast&lt;TBarApp*&gt;(be_app)-&gt;Settings();</a>
<a name="ln472"> </a>
<a name="ln473">	float itemWidth = -1.0f;</a>
<a name="ln474">	if (fVertical) {</a>
<a name="ln475">		itemWidth = Frame().Width();</a>
<a name="ln476">		SetMaxContentWidth(itemWidth);</a>
<a name="ln477">	} else {</a>
<a name="ln478">		itemWidth = iconSize;</a>
<a name="ln479">		if (!settings-&gt;hideLabels)</a>
<a name="ln480">			itemWidth += gMinimumWindowWidth - kMinimumIconSize;</a>
<a name="ln481">		else</a>
<a name="ln482">			itemWidth += kIconPadding * 2;</a>
<a name="ln483">	}</a>
<a name="ln484">	float itemHeight = -1.0f;</a>
<a name="ln485"> </a>
<a name="ln486">	TeamMenuItemMap items;</a>
<a name="ln487">	int32 itemCount = CountItems();</a>
<a name="ln488">	BList itemList(itemCount);</a>
<a name="ln489">	for (int32 i = 0; i &lt; itemCount; i++) {</a>
<a name="ln490">		BMenuItem* menuItem = RemoveItem((int32)0);</a>
<a name="ln491">		itemList.AddItem(menuItem);</a>
<a name="ln492">		TTeamMenuItem* item = dynamic_cast&lt;TTeamMenuItem*&gt;(menuItem);</a>
<a name="ln493">		if (item != NULL)</a>
<a name="ln494">			items[BString(item-&gt;Signature()).ToLower()] = item;</a>
<a name="ln495">	}</a>
<a name="ln496"> </a>
<a name="ln497">	if (settings-&gt;sortRunningApps)</a>
<a name="ln498">		fTeamList.SortItems(TTeamMenu::CompareByName);</a>
<a name="ln499"> </a>
<a name="ln500">	int32 teamCount = fTeamList.CountItems();</a>
<a name="ln501">	for (int32 i = 0; i &lt; teamCount; i++) {</a>
<a name="ln502">		BarTeamInfo* barInfo = (BarTeamInfo*)fTeamList.ItemAt(i);</a>
<a name="ln503">		TeamMenuItemMap::const_iterator iter</a>
<a name="ln504">			= items.find(BString(barInfo-&gt;sig).ToLower());</a>
<a name="ln505">		if (iter == items.end()) {</a>
<a name="ln506">			// new team</a>
<a name="ln507">			TTeamMenuItem* item = new TTeamMenuItem(barInfo-&gt;teams,</a>
<a name="ln508">				barInfo-&gt;icon, barInfo-&gt;name, barInfo-&gt;sig, itemWidth,</a>
<a name="ln509">				itemHeight);</a>
<a name="ln510"> </a>
<a name="ln511">			if (settings-&gt;trackerAlwaysFirst</a>
<a name="ln512">				&amp;&amp; strcasecmp(barInfo-&gt;sig, kTrackerSignature) == 0) {</a>
<a name="ln513">				AddItem(item, 0);</a>
<a name="ln514">			} else</a>
<a name="ln515">				AddItem(item);</a>
<a name="ln516"> </a>
<a name="ln517">			if (fFirstBuild &amp;&amp; fVertical &amp;&amp; settings-&gt;expandNewTeams)</a>
<a name="ln518">				item-&gt;ToggleExpandState(true);</a>
<a name="ln519">		} else {</a>
<a name="ln520">			// existing team, update info and add it</a>
<a name="ln521">			TTeamMenuItem* item = iter-&gt;second;</a>
<a name="ln522">			item-&gt;SetIcon(barInfo-&gt;icon);</a>
<a name="ln523">			item-&gt;SetOverrideWidth(itemWidth);</a>
<a name="ln524">			item-&gt;SetOverrideHeight(itemHeight);</a>
<a name="ln525"> </a>
<a name="ln526">			if (settings-&gt;trackerAlwaysFirst</a>
<a name="ln527">				&amp;&amp; strcasecmp(barInfo-&gt;sig, kTrackerSignature) == 0) {</a>
<a name="ln528">				AddItem(item, 0);</a>
<a name="ln529">			} else</a>
<a name="ln530">				AddItem(item);</a>
<a name="ln531"> </a>
<a name="ln532">			// add window items back</a>
<a name="ln533">			int32 index = itemList.IndexOf(item);</a>
<a name="ln534">			TWindowMenuItem* windowItem;</a>
<a name="ln535">			TWindowMenu* submenu = dynamic_cast&lt;TWindowMenu*&gt;(item-&gt;Submenu());</a>
<a name="ln536">			bool hasWindowItems = false;</a>
<a name="ln537">			while ((windowItem = dynamic_cast&lt;TWindowMenuItem*&gt;(</a>
<a name="ln538">					(BMenuItem*)(itemList.ItemAt(++index)))) != NULL) {</a>
<a name="ln539">				if (fVertical)</a>
<a name="ln540">					AddItem(windowItem);</a>
<a name="ln541">				else {</a>
<a name="ln542">					delete windowItem;</a>
<a name="ln543">					hasWindowItems = submenu != NULL;</a>
<a name="ln544">				}</a>
<a name="ln545">			}</a>
<a name="ln546"> </a>
<a name="ln547">			// unexpand if turn off show team expander</a>
<a name="ln548">			if (fVertical &amp;&amp; !settings-&gt;superExpando &amp;&amp; item-&gt;IsExpanded())</a>
<a name="ln549">				item-&gt;ToggleExpandState(false);</a>
<a name="ln550"> </a>
<a name="ln551">			if (hasWindowItems) {</a>
<a name="ln552">				// add (new) window items in submenu</a>
<a name="ln553">				submenu-&gt;SetExpanded(false, 0);</a>
<a name="ln554">				submenu-&gt;AttachedToWindow();</a>
<a name="ln555">			}</a>
<a name="ln556">		}</a>
<a name="ln557">	}</a>
<a name="ln558"> </a>
<a name="ln559">	if (CountItems() == 0) {</a>
<a name="ln560">		// If we're empty, BMenuBar::AttachedToWindow() resizes us to some</a>
<a name="ln561">		// weird value - we just override it again</a>
<a name="ln562">		ResizeTo(itemWidth, 0);</a>
<a name="ln563">	}</a>
<a name="ln564"> </a>
<a name="ln565">	fFirstBuild = false;</a>
<a name="ln566">}</a>
<a name="ln567"> </a>
<a name="ln568"> </a>
<a name="ln569">bool</a>
<a name="ln570">TExpandoMenuBar::InDeskbarMenu(BPoint loc) const</a>
<a name="ln571">{</a>
<a name="ln572">	TBarWindow* window = dynamic_cast&lt;TBarWindow*&gt;(Window());</a>
<a name="ln573">	if (window != NULL) {</a>
<a name="ln574">		if (TDeskbarMenu* bemenu = window-&gt;DeskbarMenu()) {</a>
<a name="ln575">			bool inDeskbarMenu = false;</a>
<a name="ln576">			if (bemenu-&gt;LockLooper()) {</a>
<a name="ln577">				inDeskbarMenu = bemenu-&gt;Frame().Contains(loc);</a>
<a name="ln578">				bemenu-&gt;UnlockLooper();</a>
<a name="ln579">			}</a>
<a name="ln580">			return inDeskbarMenu;</a>
<a name="ln581">		}</a>
<a name="ln582">	}</a>
<a name="ln583"> </a>
<a name="ln584">	return false;</a>
<a name="ln585">}</a>
<a name="ln586"> </a>
<a name="ln587"> </a>
<a name="ln588">/*!	Returns the team menu item that belongs to the item under the</a>
<a name="ln589">	specified \a point.</a>
<a name="ln590">	If \a _item is given, it will return the exact menu item under</a>
<a name="ln591">	that point (which might be a window item when the expander is on).</a>
<a name="ln592">*/</a>
<a name="ln593">TTeamMenuItem*</a>
<a name="ln594">TExpandoMenuBar::TeamItemAtPoint(BPoint point, BMenuItem** _item)</a>
<a name="ln595">{</a>
<a name="ln596">	TTeamMenuItem* lastApp = NULL;</a>
<a name="ln597">	int32 count = CountItems();</a>
<a name="ln598"> </a>
<a name="ln599">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln600">		BMenuItem* item = ItemAt(i);</a>
<a name="ln601"> </a>
<a name="ln602">		if (dynamic_cast&lt;TTeamMenuItem*&gt;(item) != NULL)</a>
<a name="ln603">			lastApp = (TTeamMenuItem*)item;</a>
<a name="ln604"> </a>
<a name="ln605">		if (item &amp;&amp; item-&gt;Frame().Contains(point)) {</a>
<a name="ln606">			if (_item != NULL)</a>
<a name="ln607">				*_item = item;</a>
<a name="ln608"> </a>
<a name="ln609">			return lastApp;</a>
<a name="ln610">		}</a>
<a name="ln611">	}</a>
<a name="ln612"> </a>
<a name="ln613">	// no item found</a>
<a name="ln614"> </a>
<a name="ln615">	if (_item != NULL)</a>
<a name="ln616">		*_item = NULL;</a>
<a name="ln617"> </a>
<a name="ln618">	return NULL;</a>
<a name="ln619">}</a>
<a name="ln620"> </a>
<a name="ln621"> </a>
<a name="ln622">void</a>
<a name="ln623">TExpandoMenuBar::AddTeam(BList* team, BBitmap* icon, char* name,</a>
<a name="ln624">	char* signature)</a>
<a name="ln625">{</a>
<a name="ln626">	int32 iconSize = static_cast&lt;TBarApp*&gt;(be_app)-&gt;IconSize();</a>
<a name="ln627">	desk_settings* settings = static_cast&lt;TBarApp*&gt;(be_app)-&gt;Settings();</a>
<a name="ln628"> </a>
<a name="ln629">	float itemWidth = -1.0f;</a>
<a name="ln630">	if (fVertical)</a>
<a name="ln631">		itemWidth = fBarView-&gt;Bounds().Width();</a>
<a name="ln632">	else {</a>
<a name="ln633">		itemWidth = iconSize;</a>
<a name="ln634">		if (!settings-&gt;hideLabels)</a>
<a name="ln635">			itemWidth += gMinimumWindowWidth - kMinimumIconSize;</a>
<a name="ln636">		else</a>
<a name="ln637">			itemWidth += kIconPadding * 2;</a>
<a name="ln638">	}</a>
<a name="ln639">	float itemHeight = -1.0f;</a>
<a name="ln640"> </a>
<a name="ln641">	TTeamMenuItem* item = new TTeamMenuItem(team, icon, name, signature,</a>
<a name="ln642">		itemWidth, itemHeight);</a>
<a name="ln643"> </a>
<a name="ln644">	if (settings-&gt;trackerAlwaysFirst</a>
<a name="ln645">		&amp;&amp; strcasecmp(signature, kTrackerSignature) == 0) {</a>
<a name="ln646">		AddItem(item, 0);</a>
<a name="ln647">	} else if (settings-&gt;sortRunningApps) {</a>
<a name="ln648">		TTeamMenuItem* teamItem = dynamic_cast&lt;TTeamMenuItem*&gt;(ItemAt(0));</a>
<a name="ln649">		int32 firstApp = 0;</a>
<a name="ln650"> </a>
<a name="ln651">		// if Tracker should always be the first item, we need to skip it</a>
<a name="ln652">		// when sorting in the current item</a>
<a name="ln653">		if (settings-&gt;trackerAlwaysFirst &amp;&amp; teamItem != NULL</a>
<a name="ln654">			&amp;&amp; strcasecmp(teamItem-&gt;Signature(), kTrackerSignature) == 0) {</a>
<a name="ln655">			firstApp++;</a>
<a name="ln656">		}</a>
<a name="ln657"> </a>
<a name="ln658">		BCollator collator;</a>
<a name="ln659">		BLocale::Default()-&gt;GetCollator(&amp;collator);</a>
<a name="ln660"> </a>
<a name="ln661">		int32 i = firstApp;</a>
<a name="ln662">		int32 itemCount = CountItems();</a>
<a name="ln663">		while (i &lt; itemCount) {</a>
<a name="ln664">			teamItem = dynamic_cast&lt;TTeamMenuItem*&gt;(ItemAt(i));</a>
<a name="ln665">			if (teamItem != NULL &amp;&amp; collator.Compare(teamItem-&gt;Label(), name)</a>
<a name="ln666">					&gt; 0) {</a>
<a name="ln667">				AddItem(item, i);</a>
<a name="ln668">				break;</a>
<a name="ln669">			}</a>
<a name="ln670">			i++;</a>
<a name="ln671">		}</a>
<a name="ln672">		// was the item added to the list yet?</a>
<a name="ln673">		if (i == itemCount)</a>
<a name="ln674">			AddItem(item);</a>
<a name="ln675">	} else</a>
<a name="ln676">		AddItem(item);</a>
<a name="ln677"> </a>
<a name="ln678">	if (fVertical &amp;&amp; settings-&gt;superExpando &amp;&amp; settings-&gt;expandNewTeams)</a>
<a name="ln679">		item-&gt;ToggleExpandState(false);</a>
<a name="ln680"> </a>
<a name="ln681">	SizeWindow(1);</a>
<a name="ln682">	Window()-&gt;UpdateIfNeeded();</a>
<a name="ln683">}</a>
<a name="ln684"> </a>
<a name="ln685"> </a>
<a name="ln686">void</a>
<a name="ln687">TExpandoMenuBar::AddTeam(team_id team, const char* signature)</a>
<a name="ln688">{</a>
<a name="ln689">	int32 itemCount = CountItems();</a>
<a name="ln690">	for (int32 i = 0; i &lt; itemCount; i++) {</a>
<a name="ln691">		// Only add to team menu items</a>
<a name="ln692">		TTeamMenuItem* item = dynamic_cast&lt;TTeamMenuItem*&gt;(ItemAt(i));</a>
<a name="ln693">		if (item != NULL &amp;&amp; strcasecmp(item-&gt;Signature(), signature) == 0</a>
<a name="ln694">			&amp;&amp; !(item-&gt;Teams()-&gt;HasItem((void*)(addr_t)team))) {</a>
<a name="ln695">			item-&gt;Teams()-&gt;AddItem((void*)(addr_t)team);</a>
<a name="ln696">			break;</a>
<a name="ln697">		}</a>
<a name="ln698">	}</a>
<a name="ln699">}</a>
<a name="ln700"> </a>
<a name="ln701"> </a>
<a name="ln702">void</a>
<a name="ln703">TExpandoMenuBar::RemoveTeam(team_id team, bool partial)</a>
<a name="ln704">{</a>
<a name="ln705">	TWindowMenuItem* windowItem = NULL;</a>
<a name="ln706"> </a>
<a name="ln707">	for (int32 i = CountItems() - 1; i &gt;= 0; i--) {</a>
<a name="ln708">		TTeamMenuItem* item = dynamic_cast&lt;TTeamMenuItem*&gt;(ItemAt(i));</a>
<a name="ln709">		if (item != NULL &amp;&amp; item-&gt;Teams()-&gt;HasItem((void*)(addr_t)team)) {</a>
<a name="ln710">			item-&gt;Teams()-&gt;RemoveItem(team);</a>
<a name="ln711">			if (partial)</a>
<a name="ln712">				return;</a>
<a name="ln713"> </a>
<a name="ln714">			BAutolock locker(sMonLocker);</a>
<a name="ln715">				// make the update thread wait</a>
<a name="ln716">			RemoveItem(i);</a>
<a name="ln717">			if (item == fPreviousDragTargetItem)</a>
<a name="ln718">				fPreviousDragTargetItem = NULL;</a>
<a name="ln719"> </a>
<a name="ln720">			if (item == fLastMousedOverItem)</a>
<a name="ln721">				fLastMousedOverItem = NULL;</a>
<a name="ln722"> </a>
<a name="ln723">			if (item == fLastClickedItem)</a>
<a name="ln724">				fLastClickedItem = NULL;</a>
<a name="ln725"> </a>
<a name="ln726">			delete item;</a>
<a name="ln727">			while ((windowItem = dynamic_cast&lt;TWindowMenuItem*&gt;(</a>
<a name="ln728">					ItemAt(i))) != NULL) {</a>
<a name="ln729">				// Also remove window items (if there are any)</a>
<a name="ln730">				RemoveItem(i);</a>
<a name="ln731">				if (windowItem == fLastMousedOverItem)</a>
<a name="ln732">					fLastMousedOverItem = NULL;</a>
<a name="ln733"> </a>
<a name="ln734">				if (windowItem == fLastClickedItem)</a>
<a name="ln735">					fLastClickedItem = NULL;</a>
<a name="ln736"> </a>
<a name="ln737">				delete windowItem;</a>
<a name="ln738">			}</a>
<a name="ln739">			SizeWindow(-1);</a>
<a name="ln740">			Window()-&gt;UpdateIfNeeded();</a>
<a name="ln741">			return;</a>
<a name="ln742">		}</a>
<a name="ln743">	}</a>
<a name="ln744">}</a>
<a name="ln745"> </a>
<a name="ln746"> </a>
<a name="ln747">void</a>
<a name="ln748">TExpandoMenuBar::CheckItemSizes(int32 delta)</a>
<a name="ln749">{</a>
<a name="ln750">	if (fBarView-&gt;Vertical())</a>
<a name="ln751">		return;</a>
<a name="ln752"> </a>
<a name="ln753">	bool drawLabels = !static_cast&lt;TBarApp*&gt;(be_app)-&gt;Settings()-&gt;hideLabels;</a>
<a name="ln754"> </a>
<a name="ln755">	float maxWidth = fBarView-&gt;DragRegion()-&gt;Frame().left</a>
<a name="ln756">		- fDeskbarMenuWidth - kSepItemWidth;</a>
<a name="ln757">	int32 iconSize = static_cast&lt;TBarApp*&gt;(be_app)-&gt;IconSize();</a>
<a name="ln758">	float iconOnlyWidth = kIconPadding + iconSize + kIconPadding;</a>
<a name="ln759">	float minItemWidth = drawLabels</a>
<a name="ln760">		? iconOnlyWidth + kMinMenuItemWidth</a>
<a name="ln761">		: iconOnlyWidth - kIconPadding;</a>
<a name="ln762">	float maxItemWidth = drawLabels</a>
<a name="ln763">		? gMinimumWindowWidth + iconSize - kMinimumIconSize</a>
<a name="ln764">		: iconOnlyWidth;</a>
<a name="ln765">	float menuWidth = maxItemWidth * CountItems() + fDeskbarMenuWidth</a>
<a name="ln766">		+ kSepItemWidth;</a>
<a name="ln767"> </a>
<a name="ln768">	bool reset = false;</a>
<a name="ln769">	float newWidth = -1.0f;</a>
<a name="ln770"> </a>
<a name="ln771">	if (delta &gt;= 0 &amp;&amp; menuWidth &gt; maxWidth) {</a>
<a name="ln772">		fOverflow = true;</a>
<a name="ln773">		reset = true;</a>
<a name="ln774">		newWidth = floorf(maxWidth / CountItems());</a>
<a name="ln775">	} else if (delta &lt; 0 &amp;&amp; fOverflow) {</a>
<a name="ln776">		reset = true;</a>
<a name="ln777">		if (menuWidth &gt; maxWidth)</a>
<a name="ln778">			newWidth = floorf(maxWidth / CountItems());</a>
<a name="ln779">		else</a>
<a name="ln780">			newWidth = maxItemWidth;</a>
<a name="ln781">	}</a>
<a name="ln782"> </a>
<a name="ln783">	if (reset) {</a>
<a name="ln784">		if (newWidth &gt; maxItemWidth)</a>
<a name="ln785">			newWidth = maxItemWidth;</a>
<a name="ln786">		else if (newWidth &lt; minItemWidth)</a>
<a name="ln787">			newWidth = minItemWidth;</a>
<a name="ln788"> </a>
<a name="ln789">		SetMaxContentWidth(newWidth);</a>
<a name="ln790">		if (newWidth == maxItemWidth)</a>
<a name="ln791">			fOverflow = false;</a>
<a name="ln792"> </a>
<a name="ln793">		InvalidateLayout();</a>
<a name="ln794"> </a>
<a name="ln795">		for (int32 index = 0; ; index++) {</a>
<a name="ln796">			TTeamMenuItem* item = (TTeamMenuItem*)ItemAt(index);</a>
<a name="ln797">			if (item == NULL)</a>
<a name="ln798">				break;</a>
<a name="ln799"> </a>
<a name="ln800">			item-&gt;SetOverrideWidth(newWidth);</a>
<a name="ln801">		}</a>
<a name="ln802"> </a>
<a name="ln803">		Invalidate();</a>
<a name="ln804">		Window()-&gt;UpdateIfNeeded();</a>
<a name="ln805">		fBarView-&gt;CheckForScrolling();</a>
<a name="ln806">	}</a>
<a name="ln807">}</a>
<a name="ln808"> </a>
<a name="ln809"> </a>
<a name="ln810">menu_layout</a>
<a name="ln811">TExpandoMenuBar::MenuLayout() const</a>
<a name="ln812">{</a>
<a name="ln813">	return Layout();</a>
<a name="ln814">}</a>
<a name="ln815"> </a>
<a name="ln816"> </a>
<a name="ln817">void</a>
<a name="ln818">TExpandoMenuBar::SetMenuLayout(menu_layout layout)</a>
<a name="ln819">{</a>
<a name="ln820">	fVertical = layout == B_ITEMS_IN_COLUMN;</a>
<a name="ln821">	BPrivate::MenuPrivate(this).SetLayout(layout);</a>
<a name="ln822">	SetMaxItemWidth();</a>
<a name="ln823">		// when the menu layout changes, make sure to set the max width</a>
<a name="ln824">}</a>
<a name="ln825"> </a>
<a name="ln826"> </a>
<a name="ln827">void</a>
<a name="ln828">TExpandoMenuBar::Draw(BRect updateRect)</a>
<a name="ln829">{</a>
<a name="ln830">	BMenu::Draw(updateRect);</a>
<a name="ln831">}</a>
<a name="ln832"> </a>
<a name="ln833"> </a>
<a name="ln834">void</a>
<a name="ln835">TExpandoMenuBar::DrawBackground(BRect updateRect)</a>
<a name="ln836">{</a>
<a name="ln837">	if (fVertical)</a>
<a name="ln838">		return;</a>
<a name="ln839"> </a>
<a name="ln840">	BRect bounds(Bounds());</a>
<a name="ln841">	rgb_color menuColor = ui_color(B_MENU_BACKGROUND_COLOR);</a>
<a name="ln842">	rgb_color hilite = tint_color(menuColor, B_DARKEN_1_TINT);</a>
<a name="ln843">	rgb_color vlight = tint_color(menuColor, B_LIGHTEN_2_TINT);</a>
<a name="ln844"> </a>
<a name="ln845">	int32 count = CountItems() - 1;</a>
<a name="ln846">	if (count &gt;= 0)</a>
<a name="ln847">		bounds.left = ItemAt(count)-&gt;Frame().right + 1;</a>
<a name="ln848">	else</a>
<a name="ln849">		bounds.left = 0;</a>
<a name="ln850"> </a>
<a name="ln851">	if (be_control_look != NULL) {</a>
<a name="ln852">		SetHighColor(tint_color(menuColor, 1.22));</a>
<a name="ln853">		StrokeLine(bounds.LeftTop(), bounds.LeftBottom());</a>
<a name="ln854">		bounds.left++;</a>
<a name="ln855">		uint32 borders = BControlLook::B_TOP_BORDER</a>
<a name="ln856">			| BControlLook::B_BOTTOM_BORDER | BControlLook::B_RIGHT_BORDER;</a>
<a name="ln857"> </a>
<a name="ln858">		be_control_look-&gt;DrawButtonBackground(this, bounds, bounds, menuColor,</a>
<a name="ln859">			0, borders);</a>
<a name="ln860">	} else {</a>
<a name="ln861">		SetHighColor(vlight);</a>
<a name="ln862">		StrokeLine(bounds.LeftTop(), bounds.RightTop());</a>
<a name="ln863">		StrokeLine(BPoint(bounds.left, bounds.top + 1), bounds.LeftBottom());</a>
<a name="ln864">		SetHighColor(hilite);</a>
<a name="ln865">		StrokeLine(BPoint(bounds.left + 1, bounds.bottom),</a>
<a name="ln866">			bounds.RightBottom());</a>
<a name="ln867">	}</a>
<a name="ln868">}</a>
<a name="ln869"> </a>
<a name="ln870"> </a>
<a name="ln871">/*!	Something to help determine if we are showing too many apps</a>
<a name="ln872">	need to add in scrolling functionality.</a>
<a name="ln873">*/</a>
<a name="ln874">bool</a>
<a name="ln875">TExpandoMenuBar::CheckForSizeOverrun()</a>
<a name="ln876">{</a>
<a name="ln877">	if (fVertical) {</a>
<a name="ln878">		if (Window() == NULL)</a>
<a name="ln879">			return false;</a>
<a name="ln880"> </a>
<a name="ln881">		BRect screenFrame = (BScreen(Window())).Frame();</a>
<a name="ln882">		return Window()-&gt;Frame().bottom &gt; screenFrame.bottom;</a>
<a name="ln883">	}</a>
<a name="ln884"> </a>
<a name="ln885">	// horizontal</a>
<a name="ln886">	int32 count = CountItems() - 1;</a>
<a name="ln887">	if (count &lt; 0)</a>
<a name="ln888">		return false;</a>
<a name="ln889"> </a>
<a name="ln890">	int32 iconSize = static_cast&lt;TBarApp*&gt;(be_app)-&gt;IconSize();</a>
<a name="ln891">	float iconOnlyWidth = kIconPadding + iconSize + kIconPadding;</a>
<a name="ln892">	float minItemWidth = !static_cast&lt;TBarApp*&gt;(be_app)-&gt;Settings()-&gt;hideLabels</a>
<a name="ln893">		? iconOnlyWidth + kMinMenuItemWidth</a>
<a name="ln894">		: iconOnlyWidth - kIconPadding;</a>
<a name="ln895">	float menuWidth = minItemWidth * CountItems() + fDeskbarMenuWidth</a>
<a name="ln896">		+ kSepItemWidth;</a>
<a name="ln897">	float maxWidth = fBarView-&gt;DragRegion()-&gt;Frame().left</a>
<a name="ln898">		- fDeskbarMenuWidth - kSepItemWidth;</a>
<a name="ln899"> </a>
<a name="ln900">	return menuWidth &gt; maxWidth;</a>
<a name="ln901">}</a>
<a name="ln902"> </a>
<a name="ln903"> </a>
<a name="ln904">void</a>
<a name="ln905">TExpandoMenuBar::SetMaxItemWidth()</a>
<a name="ln906">{</a>
<a name="ln907">	if (fVertical)</a>
<a name="ln908">		SetMaxContentWidth(static_cast&lt;TBarApp*&gt;(be_app)-&gt;Settings()-&gt;width);</a>
<a name="ln909">	else {</a>
<a name="ln910">		// Make more room for the icon in horizontal mode</a>
<a name="ln911">		int32 iconSize = static_cast&lt;TBarApp*&gt;(be_app)-&gt;IconSize();</a>
<a name="ln912">		SetMaxContentWidth(gMinimumWindowWidth + iconSize</a>
<a name="ln913">			- kMinimumIconSize);</a>
<a name="ln914">	}</a>
<a name="ln915">}</a>
<a name="ln916"> </a>
<a name="ln917"> </a>
<a name="ln918">void</a>
<a name="ln919">TExpandoMenuBar::SizeWindow(int32 delta)</a>
<a name="ln920">{</a>
<a name="ln921">	// instead of resizing the window here and there in the</a>
<a name="ln922">	// code the resize method will be centered in one place</a>
<a name="ln923">	// thus, the same behavior (good or bad) will be used</a>
<a name="ln924">	// wherever window sizing is done</a>
<a name="ln925">	if (fVertical) {</a>
<a name="ln926">		BRect screenFrame = (BScreen(Window())).Frame();</a>
<a name="ln927">		fBarView-&gt;SizeWindow(screenFrame);</a>
<a name="ln928">		fBarView-&gt;PositionWindow(screenFrame);</a>
<a name="ln929">		fBarView-&gt;CheckForScrolling();</a>
<a name="ln930">	} else</a>
<a name="ln931">		CheckItemSizes(delta);</a>
<a name="ln932">}</a>
<a name="ln933"> </a>
<a name="ln934"> </a>
<a name="ln935">void</a>
<a name="ln936">TExpandoMenuBar::StartMonitoringWindows()</a>
<a name="ln937">{</a>
<a name="ln938">	if (sMonThread != B_ERROR)</a>
<a name="ln939">		return;</a>
<a name="ln940"> </a>
<a name="ln941">	sDoMonitor = true;</a>
<a name="ln942">	sMonThread = spawn_thread(monitor_team_windows,</a>
<a name="ln943">		&quot;Expando Window Watcher&quot;, B_LOW_PRIORITY, this);</a>
<a name="ln944">	resume_thread(sMonThread);</a>
<a name="ln945">}</a>
<a name="ln946"> </a>
<a name="ln947"> </a>
<a name="ln948">void</a>
<a name="ln949">TExpandoMenuBar::StopMonitoringWindows()</a>
<a name="ln950">{</a>
<a name="ln951">	if (sMonThread == B_ERROR)</a>
<a name="ln952">		return;</a>
<a name="ln953"> </a>
<a name="ln954">	sDoMonitor = false;</a>
<a name="ln955">	status_t returnCode;</a>
<a name="ln956">	wait_for_thread(sMonThread, &amp;returnCode);</a>
<a name="ln957"> </a>
<a name="ln958">	sMonThread = B_ERROR;</a>
<a name="ln959">}</a>
<a name="ln960"> </a>
<a name="ln961"> </a>
<a name="ln962">int32</a>
<a name="ln963">TExpandoMenuBar::monitor_team_windows(void* arg)</a>
<a name="ln964">{</a>
<a name="ln965">	TExpandoMenuBar* teamMenu = (TExpandoMenuBar*)arg;</a>
<a name="ln966"> </a>
<a name="ln967">	while (teamMenu-&gt;sDoMonitor) {</a>
<a name="ln968">		sMonLocker.Lock();</a>
<a name="ln969"> </a>
<a name="ln970">		if (teamMenu-&gt;Window()-&gt;LockWithTimeout(50000) == B_OK) {</a>
<a name="ln971">			int32 totalItems = teamMenu-&gt;CountItems();</a>
<a name="ln972"> </a>
<a name="ln973">			// Set all WindowMenuItems to require an update.</a>
<a name="ln974">			TWindowMenuItem* item = NULL;</a>
<a name="ln975">			for (int32 i = 0; i &lt; totalItems; i++) {</a>
<a name="ln976">				if (!teamMenu-&gt;SubmenuAt(i)) {</a>
<a name="ln977">					item = static_cast&lt;TWindowMenuItem*&gt;(teamMenu-&gt;ItemAt(i));</a>
<a name="ln978">					item-&gt;SetRequireUpdate(true);</a>
<a name="ln979">				}</a>
<a name="ln980">			}</a>
<a name="ln981"> </a>
<a name="ln982">			// Perform SetTo() on all the items that still exist as well as add</a>
<a name="ln983">			// new items.</a>
<a name="ln984">			bool itemModified = false;</a>
<a name="ln985">			bool resize = false;</a>
<a name="ln986">			TTeamMenuItem* teamItem = NULL;</a>
<a name="ln987"> </a>
<a name="ln988">			for (int32 i = 0; i &lt; totalItems; i++) {</a>
<a name="ln989">				if (teamMenu-&gt;SubmenuAt(i) == NULL)</a>
<a name="ln990">					continue;</a>
<a name="ln991"> </a>
<a name="ln992">				teamItem = static_cast&lt;TTeamMenuItem*&gt;(teamMenu-&gt;ItemAt(i));</a>
<a name="ln993">				if (teamItem-&gt;IsExpanded()) {</a>
<a name="ln994">					int32 teamCount = teamItem-&gt;Teams()-&gt;CountItems();</a>
<a name="ln995">					for (int32 j = 0; j &lt; teamCount; j++) {</a>
<a name="ln996">						// The following code is almost a copy/paste from</a>
<a name="ln997">						// WindowMenu.cpp</a>
<a name="ln998">						team_id theTeam = (addr_t)teamItem-&gt;Teams()-&gt;ItemAt(j);</a>
<a name="ln999">						int32 count = 0;</a>
<a name="ln1000">						int32* tokens = get_token_list(theTeam, &amp;count);</a>
<a name="ln1001"> </a>
<a name="ln1002">						for (int32 k = 0; k &lt; count; k++) {</a>
<a name="ln1003">							client_window_info* wInfo</a>
<a name="ln1004">								= get_window_info(tokens[k]);</a>
<a name="ln1005">							if (wInfo == NULL)</a>
<a name="ln1006">								continue;</a>
<a name="ln1007"> </a>
<a name="ln1008">							BString windowName(wInfo-&gt;name);</a>
<a name="ln1009"> </a>
<a name="ln1010">							BString teamPrefix(teamItem-&gt;Label());</a>
<a name="ln1011">							teamPrefix.Append(&quot;: &quot;);</a>
<a name="ln1012"> </a>
<a name="ln1013">							BString teamSuffix(&quot; - &quot;);</a>
<a name="ln1014">							teamSuffix.Append(teamItem-&gt;Label());</a>
<a name="ln1015"> </a>
<a name="ln1016">							if (windowName.StartsWith(teamPrefix))</a>
<a name="ln1017">								windowName.RemoveFirst(teamPrefix);</a>
<a name="ln1018">							if (windowName.EndsWith(teamSuffix))</a>
<a name="ln1019">								windowName.RemoveLast(teamSuffix);</a>
<a name="ln1020"> </a>
<a name="ln1021">							if (TWindowMenu::WindowShouldBeListed(wInfo)) {</a>
<a name="ln1022">								// Check if we have a matching window item...</a>
<a name="ln1023">								item = teamItem-&gt;ExpandedWindowItem(</a>
<a name="ln1024">									wInfo-&gt;server_token);</a>
<a name="ln1025">								if (item != NULL) {</a>
<a name="ln1026">									item-&gt;SetTo(windowName,</a>
<a name="ln1027">										wInfo-&gt;server_token, wInfo-&gt;is_mini,</a>
<a name="ln1028">										((1 &lt;&lt; current_workspace())</a>
<a name="ln1029">											&amp; wInfo-&gt;workspaces) != 0);</a>
<a name="ln1030"> </a>
<a name="ln1031">									if (strcasecmp(item-&gt;Label(), windowName) &gt; 0)</a>
<a name="ln1032">										item-&gt;SetLabel(windowName);</a>
<a name="ln1033"> </a>
<a name="ln1034">									if (item-&gt;Modified())</a>
<a name="ln1035">										itemModified = true;</a>
<a name="ln1036">								} else if (teamItem-&gt;IsExpanded()) {</a>
<a name="ln1037">									// Add the item</a>
<a name="ln1038">									item = new TWindowMenuItem(windowName,</a>
<a name="ln1039">										wInfo-&gt;server_token, wInfo-&gt;is_mini,</a>
<a name="ln1040">										((1 &lt;&lt; current_workspace())</a>
<a name="ln1041">											&amp; wInfo-&gt;workspaces) != 0, false);</a>
<a name="ln1042">									item-&gt;SetExpanded(true);</a>
<a name="ln1043">									teamMenu-&gt;AddItem(item,</a>
<a name="ln1044">										TWindowMenuItem::InsertIndexFor(</a>
<a name="ln1045">											teamMenu, i + 1, item));</a>
<a name="ln1046">									resize = true;</a>
<a name="ln1047">								}</a>
<a name="ln1048">							}</a>
<a name="ln1049">							free(wInfo);</a>
<a name="ln1050">						}</a>
<a name="ln1051">						free(tokens);</a>
<a name="ln1052">					}</a>
<a name="ln1053">				}</a>
<a name="ln1054">			}</a>
<a name="ln1055"> </a>
<a name="ln1056">			// Remove any remaining items which require an update.</a>
<a name="ln1057">			for (int32 i = 0; i &lt; totalItems; i++) {</a>
<a name="ln1058">				if (!teamMenu-&gt;SubmenuAt(i)) {</a>
<a name="ln1059">					item = static_cast&lt;TWindowMenuItem*&gt;(teamMenu-&gt;ItemAt(i));</a>
<a name="ln1060">					if (item &amp;&amp; item-&gt;RequiresUpdate()) {</a>
<a name="ln1061">						item = static_cast&lt;TWindowMenuItem*&gt;</a>
<a name="ln1062">							(teamMenu-&gt;RemoveItem(i));</a>
<a name="ln1063">						delete item;</a>
<a name="ln1064">						totalItems--;</a>
<a name="ln1065"> </a>
<a name="ln1066">						resize = true;</a>
<a name="ln1067">					}</a>
<a name="ln1068">				}</a>
<a name="ln1069">			}</a>
<a name="ln1070"> </a>
<a name="ln1071">			// If any of the WindowMenuItems changed state, we need to force a</a>
<a name="ln1072">			// repaint.</a>
<a name="ln1073">			if (itemModified || resize) {</a>
<a name="ln1074">				teamMenu-&gt;Invalidate();</a>
<a name="ln1075">				if (resize)</a>
<a name="ln1076">					teamMenu-&gt;SizeWindow(1);</a>
<a name="ln1077">			}</a>
<a name="ln1078"> </a>
<a name="ln1079">			teamMenu-&gt;Window()-&gt;Unlock();</a>
<a name="ln1080">		}</a>
<a name="ln1081"> </a>
<a name="ln1082">		sMonLocker.Unlock();</a>
<a name="ln1083"> </a>
<a name="ln1084">		// sleep for a bit...</a>
<a name="ln1085">		snooze(150000);</a>
<a name="ln1086">	}</a>
<a name="ln1087">	return B_OK;</a>
<a name="ln1088">}</a>
<a name="ln1089"> </a>
<a name="ln1090"> </a>
<a name="ln1091">void</a>
<a name="ln1092">TExpandoMenuBar::_FinishedDrag(bool invoke)</a>
<a name="ln1093">{</a>
<a name="ln1094">	if (fPreviousDragTargetItem != NULL) {</a>
<a name="ln1095">		if (invoke)</a>
<a name="ln1096">			fPreviousDragTargetItem-&gt;Invoke();</a>
<a name="ln1097"> </a>
<a name="ln1098">		fPreviousDragTargetItem-&gt;SetOverrideSelected(false);</a>
<a name="ln1099">		fPreviousDragTargetItem = NULL;</a>
<a name="ln1100">	}</a>
<a name="ln1101"> </a>
<a name="ln1102">	if (!invoke &amp;&amp; fBarView-&gt;Dragging())</a>
<a name="ln1103">		fBarView-&gt;DragStop(true);</a>
<a name="ln1104">}</a>
<a name="ln1105"> </a>
<a name="ln1106"> </a>
<a name="ln1107">void</a>
<a name="ln1108">TExpandoMenuBar::_DoneTracking(BPoint where)</a>
<a name="ln1109">{</a>
<a name="ln1110">	TTeamMenuItem* lastItem = dynamic_cast&lt;TTeamMenuItem*&gt;(fLastClickedItem);</a>
<a name="ln1111">	if (lastItem == NULL)</a>
<a name="ln1112">		return;</a>
<a name="ln1113"> </a>
<a name="ln1114">	if (!lastItem-&gt;ExpanderBounds().Contains(where))</a>
<a name="ln1115">		return;</a>
<a name="ln1116"> </a>
<a name="ln1117">	lastItem-&gt;ToggleExpandState(true);</a>
<a name="ln1118">	lastItem-&gt;SetArrowDirection(lastItem-&gt;IsExpanded()</a>
<a name="ln1119">		? BControlLook::B_DOWN_ARROW</a>
<a name="ln1120">		: BControlLook::B_RIGHT_ARROW);</a>
<a name="ln1121"> </a>
<a name="ln1122">	Invalidate(lastItem-&gt;ExpanderBounds());</a>
<a name="ln1123">}</a>
<a name="ln1124"> </a>
<a name="ln1125"> </a>
<a name="ln1126">void</a>
<a name="ln1127">TExpandoMenuBar::_Track(BPoint where, uint32)</a>
<a name="ln1128">{</a>
<a name="ln1129">	TTeamMenuItem* lastItem = dynamic_cast&lt;TTeamMenuItem*&gt;(fLastClickedItem);</a>
<a name="ln1130">	if (lastItem == NULL)</a>
<a name="ln1131">		return;</a>
<a name="ln1132"> </a>
<a name="ln1133">	if (lastItem-&gt;ExpanderBounds().Contains(where))</a>
<a name="ln1134">		lastItem-&gt;SetArrowDirection(BControlLook::B_RIGHT_DOWN_ARROW);</a>
<a name="ln1135">	else {</a>
<a name="ln1136">		lastItem-&gt;SetArrowDirection(lastItem-&gt;IsExpanded()</a>
<a name="ln1137">			? BControlLook::B_DOWN_ARROW</a>
<a name="ln1138">			: BControlLook::B_RIGHT_ARROW);</a>
<a name="ln1139">	}</a>
<a name="ln1140"> </a>
<a name="ln1141">	Invalidate(lastItem-&gt;ExpanderBounds());</a>
<a name="ln1142">}</a>

</code></pre>
<div class="balloon" rel="355"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v757/" target="_blank">V757</a> It is possible that an incorrect variable is compared with nullptr after type conversion using 'dynamic_cast'. Check lines: 355, 357.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
