
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>Inode.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2001-2017, Axel DÃ¶rfler, axeld@pinc-software.de.</a>
<a name="ln3"> * This file may be used under the terms of the MIT License.</a>
<a name="ln4"> */</a>
<a name="ln5"> </a>
<a name="ln6"> </a>
<a name="ln7">//! Inode access functions</a>
<a name="ln8"> </a>
<a name="ln9"> </a>
<a name="ln10">#include &quot;Debug.h&quot;</a>
<a name="ln11">#include &quot;Inode.h&quot;</a>
<a name="ln12">#include &quot;BPlusTree.h&quot;</a>
<a name="ln13">#include &quot;Index.h&quot;</a>
<a name="ln14"> </a>
<a name="ln15"> </a>
<a name="ln16">#if BFS_TRACING &amp;&amp; !defined(FS_SHELL) &amp;&amp; !defined(_BOOT_MODE)</a>
<a name="ln17">namespace BFSInodeTracing {</a>
<a name="ln18"> </a>
<a name="ln19">class Create : public AbstractTraceEntry {</a>
<a name="ln20">public:</a>
<a name="ln21">	Create(Inode* inode, Inode* parent, const char* name, int32 mode,</a>
<a name="ln22">			int openMode, uint32 type)</a>
<a name="ln23">		:</a>
<a name="ln24">		fInode(inode),</a>
<a name="ln25">		fID(inode-&gt;ID()),</a>
<a name="ln26">		fParent(parent),</a>
<a name="ln27">		fParentID(parent != NULL ? parent-&gt;ID() : 0),</a>
<a name="ln28">		fMode(mode),</a>
<a name="ln29">		fOpenMode(openMode),</a>
<a name="ln30">		fType(type)</a>
<a name="ln31">	{</a>
<a name="ln32">		if (name != NULL)</a>
<a name="ln33">			strlcpy(fName, name, sizeof(fName));</a>
<a name="ln34">		else</a>
<a name="ln35">			fName[0] = '\0';</a>
<a name="ln36"> </a>
<a name="ln37">		Initialized();</a>
<a name="ln38">	}</a>
<a name="ln39"> </a>
<a name="ln40">	virtual void AddDump(TraceOutput&amp; out)</a>
<a name="ln41">	{</a>
<a name="ln42">		out.Print(&quot;bfs:Create %Ld (%p), parent %Ld (%p), \&quot;%s\&quot;, &quot;</a>
<a name="ln43">			&quot;mode %lx, omode %x, type %lx&quot;, fID, fInode, fParentID,</a>
<a name="ln44">			fParent, fName, fMode, fOpenMode, fType);</a>
<a name="ln45">	}</a>
<a name="ln46"> </a>
<a name="ln47">private:</a>
<a name="ln48">	Inode*	fInode;</a>
<a name="ln49">	ino_t	fID;</a>
<a name="ln50">	Inode*	fParent;</a>
<a name="ln51">	ino_t	fParentID;</a>
<a name="ln52">	char	fName[32];</a>
<a name="ln53">	int32	fMode;</a>
<a name="ln54">	int		fOpenMode;</a>
<a name="ln55">	uint32	fType;</a>
<a name="ln56">};</a>
<a name="ln57"> </a>
<a name="ln58">class Remove : public AbstractTraceEntry {</a>
<a name="ln59">public:</a>
<a name="ln60">	Remove(Inode* inode, const char* name)</a>
<a name="ln61">		:</a>
<a name="ln62">		fInode(inode),</a>
<a name="ln63">		fID(inode-&gt;ID())</a>
<a name="ln64">	{</a>
<a name="ln65">		strlcpy(fName, name, sizeof(fName));</a>
<a name="ln66">		Initialized();</a>
<a name="ln67">	}</a>
<a name="ln68"> </a>
<a name="ln69">	virtual void AddDump(TraceOutput&amp; out)</a>
<a name="ln70">	{</a>
<a name="ln71">		out.Print(&quot;bfs:Remove %Ld (%p), \&quot;%s\&quot;&quot;, fID, fInode, fName);</a>
<a name="ln72">	}</a>
<a name="ln73"> </a>
<a name="ln74">private:</a>
<a name="ln75">	Inode*	fInode;</a>
<a name="ln76">	ino_t	fID;</a>
<a name="ln77">	char	fName[32];</a>
<a name="ln78">};</a>
<a name="ln79"> </a>
<a name="ln80">class Action : public AbstractTraceEntry {</a>
<a name="ln81">public:</a>
<a name="ln82">	Action(const char* action, Inode* inode)</a>
<a name="ln83">		:</a>
<a name="ln84">		fInode(inode),</a>
<a name="ln85">		fID(inode-&gt;ID())</a>
<a name="ln86">	{</a>
<a name="ln87">		strlcpy(fAction, action, sizeof(fAction));</a>
<a name="ln88">		Initialized();</a>
<a name="ln89">	}</a>
<a name="ln90"> </a>
<a name="ln91">	virtual void AddDump(TraceOutput&amp; out)</a>
<a name="ln92">	{</a>
<a name="ln93">		out.Print(&quot;bfs:%s %Ld (%p)\n&quot;, fAction, fID, fInode);</a>
<a name="ln94">	}</a>
<a name="ln95"> </a>
<a name="ln96">private:</a>
<a name="ln97">	Inode*	fInode;</a>
<a name="ln98">	ino_t	fID;</a>
<a name="ln99">	char	fAction[16];</a>
<a name="ln100">};</a>
<a name="ln101"> </a>
<a name="ln102">class Resize : public AbstractTraceEntry {</a>
<a name="ln103">public:</a>
<a name="ln104">	Resize(Inode* inode, off_t oldSize, off_t newSize, bool trim)</a>
<a name="ln105">		:</a>
<a name="ln106">		fInode(inode),</a>
<a name="ln107">		fID(inode-&gt;ID()),</a>
<a name="ln108">		fOldSize(oldSize),</a>
<a name="ln109">		fNewSize(newSize),</a>
<a name="ln110">		fTrim(trim)</a>
<a name="ln111">	{</a>
<a name="ln112">		Initialized();</a>
<a name="ln113">	}</a>
<a name="ln114"> </a>
<a name="ln115">	virtual void AddDump(TraceOutput&amp; out)</a>
<a name="ln116">	{</a>
<a name="ln117">		out.Print(&quot;bfs:%s %Ld (%p), %Ld -&gt; %Ld&quot;, fTrim ? &quot;Trim&quot; : &quot;Resize&quot;,</a>
<a name="ln118">			fID, fInode, fOldSize, fNewSize);</a>
<a name="ln119">	}</a>
<a name="ln120"> </a>
<a name="ln121">private:</a>
<a name="ln122">	Inode*	fInode;</a>
<a name="ln123">	ino_t	fID;</a>
<a name="ln124">	off_t	fOldSize;</a>
<a name="ln125">	off_t	fNewSize;</a>
<a name="ln126">	bool	fTrim;</a>
<a name="ln127">};</a>
<a name="ln128"> </a>
<a name="ln129">}	// namespace BFSInodeTracing</a>
<a name="ln130"> </a>
<a name="ln131">#	define T(x) new(std::nothrow) BFSInodeTracing::x;</a>
<a name="ln132">#else</a>
<a name="ln133">#	define T(x) ;</a>
<a name="ln134">#endif</a>
<a name="ln135"> </a>
<a name="ln136"> </a>
<a name="ln137">/*!	A helper class used by Inode::Create() to keep track of the belongings</a>
<a name="ln138">	of an inode creation in progress.</a>
<a name="ln139">	This class will make sure everything is cleaned up properly.</a>
<a name="ln140">*/</a>
<a name="ln141">class InodeAllocator {</a>
<a name="ln142">public:</a>
<a name="ln143">							InodeAllocator(Transaction&amp; transaction);</a>
<a name="ln144">							~InodeAllocator();</a>
<a name="ln145"> </a>
<a name="ln146">			status_t		New(block_run* parentRun, mode_t mode, uint32 flags,</a>
<a name="ln147">								block_run&amp; run, fs_vnode_ops* vnodeOps,</a>
<a name="ln148">								Inode** _inode);</a>
<a name="ln149">			status_t		CreateTree();</a>
<a name="ln150">			status_t		Keep(fs_vnode_ops* vnodeOps, uint32 publishFlags);</a>
<a name="ln151"> </a>
<a name="ln152">private:</a>
<a name="ln153">	static	void			_TransactionListener(int32 id, int32 event,</a>
<a name="ln154">								void* _inode);</a>
<a name="ln155"> </a>
<a name="ln156">			Transaction*	fTransaction;</a>
<a name="ln157">			block_run		fRun;</a>
<a name="ln158">			Inode*			fInode;</a>
<a name="ln159">};</a>
<a name="ln160"> </a>
<a name="ln161"> </a>
<a name="ln162">InodeAllocator::InodeAllocator(Transaction&amp; transaction)</a>
<a name="ln163">	:</a>
<a name="ln164">	fTransaction(&amp;transaction),</a>
<a name="ln165">	fInode(NULL)</a>
<a name="ln166">{</a>
<a name="ln167">}</a>
<a name="ln168"> </a>
<a name="ln169"> </a>
<a name="ln170">InodeAllocator::~InodeAllocator()</a>
<a name="ln171">{</a>
<a name="ln172">	if (fTransaction != NULL) {</a>
<a name="ln173">		Volume* volume = fTransaction-&gt;GetVolume();</a>
<a name="ln174"> </a>
<a name="ln175">		if (fInode != NULL) {</a>
<a name="ln176">			fInode-&gt;Node().flags &amp;= ~HOST_ENDIAN_TO_BFS_INT32(INODE_IN_USE);</a>
<a name="ln177">				// this unblocks any pending bfs_read_vnode() calls</a>
<a name="ln178">			fInode-&gt;Free(*fTransaction);</a>
<a name="ln179"> </a>
<a name="ln180">			if (fInode-&gt;fTree != NULL)</a>
<a name="ln181">				fTransaction-&gt;RemoveListener(fInode-&gt;fTree);</a>
<a name="ln182">			fTransaction-&gt;RemoveListener(fInode);</a>
<a name="ln183"> </a>
<a name="ln184">			remove_vnode(volume-&gt;FSVolume(), fInode-&gt;ID());</a>
<a name="ln185">		} else</a>
<a name="ln186">			volume-&gt;Free(*fTransaction, fRun);</a>
<a name="ln187">	}</a>
<a name="ln188"> </a>
<a name="ln189">	delete fInode;</a>
<a name="ln190">}</a>
<a name="ln191"> </a>
<a name="ln192"> </a>
<a name="ln193">status_t</a>
<a name="ln194">InodeAllocator::New(block_run* parentRun, mode_t mode, uint32 publishFlags,</a>
<a name="ln195">	block_run&amp; run, fs_vnode_ops* vnodeOps, Inode** _inode)</a>
<a name="ln196">{</a>
<a name="ln197">	Volume* volume = fTransaction-&gt;GetVolume();</a>
<a name="ln198"> </a>
<a name="ln199">	status_t status = volume-&gt;AllocateForInode(*fTransaction, parentRun, mode,</a>
<a name="ln200">		fRun);</a>
<a name="ln201">	if (status &lt; B_OK) {</a>
<a name="ln202">		// don't free the space in the destructor, because</a>
<a name="ln203">		// the allocation failed</a>
<a name="ln204">		fTransaction = NULL;</a>
<a name="ln205">		RETURN_ERROR(status);</a>
<a name="ln206">	}</a>
<a name="ln207"> </a>
<a name="ln208">	run = fRun;</a>
<a name="ln209">	fInode = new(std::nothrow) Inode(volume, *fTransaction,</a>
<a name="ln210">		volume-&gt;ToVnode(run), mode, run);</a>
<a name="ln211">	if (fInode == NULL)</a>
<a name="ln212">		RETURN_ERROR(B_NO_MEMORY);</a>
<a name="ln213"> </a>
<a name="ln214">	if (!volume-&gt;IsInitializing()</a>
<a name="ln215">		&amp;&amp; (publishFlags &amp; BFS_DO_NOT_PUBLISH_VNODE) == 0) {</a>
<a name="ln216">		status = new_vnode(volume-&gt;FSVolume(), fInode-&gt;ID(), fInode,</a>
<a name="ln217">			vnodeOps != NULL ? vnodeOps : &amp;gBFSVnodeOps);</a>
<a name="ln218">		if (status &lt; B_OK) {</a>
<a name="ln219">			delete fInode;</a>
<a name="ln220">			fInode = NULL;</a>
<a name="ln221">			RETURN_ERROR(status);</a>
<a name="ln222">		}</a>
<a name="ln223">	}</a>
<a name="ln224"> </a>
<a name="ln225">	fInode-&gt;WriteLockInTransaction(*fTransaction);</a>
<a name="ln226">	*_inode = fInode;</a>
<a name="ln227">	return B_OK;</a>
<a name="ln228">}</a>
<a name="ln229"> </a>
<a name="ln230"> </a>
<a name="ln231">status_t</a>
<a name="ln232">InodeAllocator::CreateTree()</a>
<a name="ln233">{</a>
<a name="ln234">	Volume* volume = fTransaction-&gt;GetVolume();</a>
<a name="ln235"> </a>
<a name="ln236">	// force S_STR_INDEX to be set, if no type is set</a>
<a name="ln237">	if ((fInode-&gt;Mode() &amp; S_INDEX_TYPES) == 0)</a>
<a name="ln238">		fInode-&gt;Node().mode |= HOST_ENDIAN_TO_BFS_INT32(S_STR_INDEX);</a>
<a name="ln239"> </a>
<a name="ln240">	BPlusTree* tree = new(std::nothrow) BPlusTree(*fTransaction, fInode);</a>
<a name="ln241">	if (tree == NULL)</a>
<a name="ln242">		return B_ERROR;</a>
<a name="ln243"> </a>
<a name="ln244">	status_t status = tree-&gt;InitCheck();</a>
<a name="ln245">	if (status != B_OK) {</a>
<a name="ln246">		delete tree;</a>
<a name="ln247">		return status;</a>
<a name="ln248">	}</a>
<a name="ln249"> </a>
<a name="ln250">	fInode-&gt;fTree = tree;</a>
<a name="ln251"> </a>
<a name="ln252">	if (fInode-&gt;IsRegularNode()) {</a>
<a name="ln253">		if (tree-&gt;Insert(*fTransaction, &quot;.&quot;, fInode-&gt;ID()) &lt; B_OK</a>
<a name="ln254">			|| tree-&gt;Insert(*fTransaction, &quot;..&quot;,</a>
<a name="ln255">					volume-&gt;ToVnode(fInode-&gt;Parent())) &lt; B_OK)</a>
<a name="ln256">			return B_ERROR;</a>
<a name="ln257">	}</a>
<a name="ln258">	return B_OK;</a>
<a name="ln259">}</a>
<a name="ln260"> </a>
<a name="ln261"> </a>
<a name="ln262">status_t</a>
<a name="ln263">InodeAllocator::Keep(fs_vnode_ops* vnodeOps, uint32 publishFlags)</a>
<a name="ln264">{</a>
<a name="ln265">	ASSERT(fInode != NULL &amp;&amp; fTransaction != NULL);</a>
<a name="ln266">	Volume* volume = fTransaction-&gt;GetVolume();</a>
<a name="ln267"> </a>
<a name="ln268">	status_t status = fInode-&gt;WriteBack(*fTransaction);</a>
<a name="ln269">	if (status &lt; B_OK) {</a>
<a name="ln270">		FATAL((&quot;writing new inode %&quot; B_PRIdINO &quot; failed!\n&quot;, fInode-&gt;ID()));</a>
<a name="ln271">		return status;</a>
<a name="ln272">	}</a>
<a name="ln273"> </a>
<a name="ln274">	// Symbolic links are not published -- the caller needs to do this once</a>
<a name="ln275">	// the contents have been written.</a>
<a name="ln276">	if (!fInode-&gt;IsSymLink() &amp;&amp; !volume-&gt;IsInitializing()</a>
<a name="ln277">		&amp;&amp; (publishFlags &amp; BFS_DO_NOT_PUBLISH_VNODE) == 0) {</a>
<a name="ln278">		status = publish_vnode(volume-&gt;FSVolume(), fInode-&gt;ID(), fInode,</a>
<a name="ln279">			vnodeOps != NULL ? vnodeOps : &amp;gBFSVnodeOps, fInode-&gt;Mode(),</a>
<a name="ln280">			publishFlags);</a>
<a name="ln281">	}</a>
<a name="ln282"> </a>
<a name="ln283">	if (status == B_OK) {</a>
<a name="ln284">		cache_add_transaction_listener(volume-&gt;BlockCache(), fTransaction-&gt;ID(),</a>
<a name="ln285">			TRANSACTION_ABORTED, &amp;_TransactionListener, fInode);</a>
<a name="ln286">	}</a>
<a name="ln287"> </a>
<a name="ln288">	fTransaction = NULL;</a>
<a name="ln289">	fInode = NULL;</a>
<a name="ln290"> </a>
<a name="ln291">	return status;</a>
<a name="ln292">}</a>
<a name="ln293"> </a>
<a name="ln294"> </a>
<a name="ln295">/*static*/ void</a>
<a name="ln296">InodeAllocator::_TransactionListener(int32 id, int32 event, void* _inode)</a>
<a name="ln297">{</a>
<a name="ln298">	Inode* inode = (Inode*)_inode;</a>
<a name="ln299"> </a>
<a name="ln300">	if (event == TRANSACTION_ABORTED)</a>
<a name="ln301">		panic(&quot;transaction %d aborted, inode %p still around!\n&quot;, (int)id, inode);</a>
<a name="ln302">}</a>
<a name="ln303"> </a>
<a name="ln304"> </a>
<a name="ln305">//	#pragma mark -</a>
<a name="ln306"> </a>
<a name="ln307"> </a>
<a name="ln308">status_t</a>
<a name="ln309">bfs_inode::InitCheck(Volume* volume) const</a>
<a name="ln310">{</a>
<a name="ln311">	if (Magic1() != INODE_MAGIC1</a>
<a name="ln312">		|| !(Flags() &amp; INODE_IN_USE)</a>
<a name="ln313">		|| inode_num.Length() != 1</a>
<a name="ln314">		// matches inode size?</a>
<a name="ln315">		|| (uint32)InodeSize() != volume-&gt;InodeSize()</a>
<a name="ln316">		// parent resides on disk?</a>
<a name="ln317">		|| parent.AllocationGroup() &gt; int32(volume-&gt;AllocationGroups())</a>
<a name="ln318">		|| parent.AllocationGroup() &lt; 0</a>
<a name="ln319">		|| parent.Start() &gt; (1L &lt;&lt; volume-&gt;AllocationGroupShift())</a>
<a name="ln320">		|| parent.Length() != 1</a>
<a name="ln321">		// attributes, too?</a>
<a name="ln322">		|| attributes.AllocationGroup() &gt; int32(volume-&gt;AllocationGroups())</a>
<a name="ln323">		|| attributes.AllocationGroup() &lt; 0</a>
<a name="ln324">		|| attributes.Start() &gt; (1L &lt;&lt; volume-&gt;AllocationGroupShift()))</a>
<a name="ln325">		RETURN_ERROR(B_BAD_DATA);</a>
<a name="ln326"> </a>
<a name="ln327">	if (Flags() &amp; INODE_DELETED)</a>
<a name="ln328">		return B_NOT_ALLOWED;</a>
<a name="ln329"> </a>
<a name="ln330">	// TODO: Add some tests to check the integrity of the other stuff here,</a>
<a name="ln331">	// especially for the data_stream!</a>
<a name="ln332"> </a>
<a name="ln333">	return B_OK;</a>
<a name="ln334">}</a>
<a name="ln335"> </a>
<a name="ln336"> </a>
<a name="ln337">//	#pragma mark - Inode</a>
<a name="ln338"> </a>
<a name="ln339"> </a>
<a name="ln340">Inode::Inode(Volume* volume, ino_t id)</a>
<a name="ln341">	:</a>
<a name="ln342">	fVolume(volume),</a>
<a name="ln343">	fID(id),</a>
<a name="ln344">	fTree(NULL),</a>
<a name="ln345">	fAttributes(NULL),</a>
<a name="ln346">	fCache(NULL),</a>
<a name="ln347">	fMap(NULL)</a>
<a name="ln348">{</a>
<a name="ln349">	PRINT((&quot;Inode::Inode(volume = %p, id = %Ld) @ %p\n&quot;, volume, id, this));</a>
<a name="ln350"> </a>
<a name="ln351">	rw_lock_init(&amp;fLock, &quot;bfs inode&quot;);</a>
<a name="ln352">	recursive_lock_init(&amp;fSmallDataLock, &quot;bfs inode small data&quot;);</a>
<a name="ln353"> </a>
<a name="ln354">	if (UpdateNodeFromDisk() != B_OK) {</a>
<a name="ln355">		// TODO: the error code gets eaten</a>
<a name="ln356">		return;</a>
<a name="ln357">	}</a>
<a name="ln358"> </a>
<a name="ln359">	// these two will help to maintain the indices</a>
<a name="ln360">	fOldSize = Size();</a>
<a name="ln361">	fOldLastModified = LastModified();</a>
<a name="ln362"> </a>
<a name="ln363">	if (IsContainer())</a>
<a name="ln364">		fTree = new(std::nothrow) BPlusTree(this);</a>
<a name="ln365">	if (NeedsFileCache()) {</a>
<a name="ln366">		SetFileCache(file_cache_create(fVolume-&gt;ID(), ID(), Size()));</a>
<a name="ln367">		SetMap(file_map_create(volume-&gt;ID(), ID(), Size()));</a>
<a name="ln368">	}</a>
<a name="ln369">}</a>
<a name="ln370"> </a>
<a name="ln371"> </a>
<a name="ln372">Inode::Inode(Volume* volume, Transaction&amp; transaction, ino_t id, mode_t mode,</a>
<a name="ln373">		block_run&amp; run)</a>
<a name="ln374">	:</a>
<a name="ln375">	fVolume(volume),</a>
<a name="ln376">	fID(id),</a>
<a name="ln377">	fTree(NULL),</a>
<a name="ln378">	fAttributes(NULL),</a>
<a name="ln379">	fCache(NULL),</a>
<a name="ln380">	fMap(NULL)</a>
<a name="ln381">{</a>
<a name="ln382">	PRINT((&quot;Inode::Inode(volume = %p, transaction = %p, id = %Ld) @ %p\n&quot;,</a>
<a name="ln383">		volume, &amp;transaction, id, this));</a>
<a name="ln384"> </a>
<a name="ln385">	rw_lock_init(&amp;fLock, &quot;bfs inode&quot;);</a>
<a name="ln386">	recursive_lock_init(&amp;fSmallDataLock, &quot;bfs inode small data&quot;);</a>
<a name="ln387"> </a>
<a name="ln388">	NodeGetter node(volume, transaction, this, true);</a>
<a name="ln389">	if (node.Node() == NULL) {</a>
<a name="ln390">		FATAL((&quot;Could not read inode block %&quot; B_PRId64 &quot;!\n&quot;, BlockNumber()));</a>
<a name="ln391">		return;</a>
<a name="ln392">	}</a>
<a name="ln393"> </a>
<a name="ln394">	memset(&amp;fNode, 0, sizeof(bfs_inode));</a>
<a name="ln395"> </a>
<a name="ln396">	// Initialize the bfs_inode structure -- it's not written back to disk</a>
<a name="ln397">	// here, because it will be done so already when the inode could be</a>
<a name="ln398">	// created completely.</a>
<a name="ln399"> </a>
<a name="ln400">	Node().magic1 = HOST_ENDIAN_TO_BFS_INT32(INODE_MAGIC1);</a>
<a name="ln401">	Node().inode_num = run;</a>
<a name="ln402">	Node().mode = HOST_ENDIAN_TO_BFS_INT32(mode);</a>
<a name="ln403">	Node().flags = HOST_ENDIAN_TO_BFS_INT32(INODE_IN_USE);</a>
<a name="ln404"> </a>
<a name="ln405">	Node().create_time = Node().last_modified_time = Node().status_change_time</a>
<a name="ln406">		= HOST_ENDIAN_TO_BFS_INT64(bfs_inode::ToInode(real_time_clock_usecs()));</a>
<a name="ln407"> </a>
<a name="ln408">	Node().inode_size = HOST_ENDIAN_TO_BFS_INT32(volume-&gt;InodeSize());</a>
<a name="ln409"> </a>
<a name="ln410">	// these two will help to maintain the indices</a>
<a name="ln411">	fOldSize = Size();</a>
<a name="ln412">	fOldLastModified = LastModified();</a>
<a name="ln413">}</a>
<a name="ln414"> </a>
<a name="ln415"> </a>
<a name="ln416">Inode::~Inode()</a>
<a name="ln417">{</a>
<a name="ln418">	PRINT((&quot;Inode::~Inode() @ %p\n&quot;, this));</a>
<a name="ln419"> </a>
<a name="ln420">	file_cache_delete(FileCache());</a>
<a name="ln421">	file_map_delete(Map());</a>
<a name="ln422">	delete fTree;</a>
<a name="ln423"> </a>
<a name="ln424">	rw_lock_destroy(&amp;fLock);</a>
<a name="ln425">	recursive_lock_destroy(&amp;fSmallDataLock);</a>
<a name="ln426">}</a>
<a name="ln427"> </a>
<a name="ln428"> </a>
<a name="ln429">status_t</a>
<a name="ln430">Inode::InitCheck(bool checkNode) const</a>
<a name="ln431">{</a>
<a name="ln432">	// test inode magic and flags</a>
<a name="ln433">	if (checkNode) {</a>
<a name="ln434">		status_t status = Node().InitCheck(fVolume);</a>
<a name="ln435">		if (status == B_BUSY)</a>
<a name="ln436">			return B_BUSY;</a>
<a name="ln437"> </a>
<a name="ln438">		if (status != B_OK) {</a>
<a name="ln439">			FATAL((&quot;inode at block %&quot; B_PRIdOFF &quot; corrupt!\n&quot;, BlockNumber()));</a>
<a name="ln440">			RETURN_ERROR(B_BAD_DATA);</a>
<a name="ln441">		}</a>
<a name="ln442">	}</a>
<a name="ln443"> </a>
<a name="ln444">	if (IsContainer()) {</a>
<a name="ln445">		// inodes that have a B+tree</a>
<a name="ln446">		if (fTree == NULL)</a>
<a name="ln447">			RETURN_ERROR(B_NO_MEMORY);</a>
<a name="ln448"> </a>
<a name="ln449">		status_t status = fTree-&gt;InitCheck();</a>
<a name="ln450">		if (status != B_OK) {</a>
<a name="ln451">			FATAL((&quot;inode tree at block %&quot; B_PRIdOFF &quot; corrupt!\n&quot;,</a>
<a name="ln452">				BlockNumber()));</a>
<a name="ln453">			RETURN_ERROR(B_BAD_DATA);</a>
<a name="ln454">		}</a>
<a name="ln455">	}</a>
<a name="ln456"> </a>
<a name="ln457">	if (NeedsFileCache() &amp;&amp; (fCache == NULL || fMap == NULL))</a>
<a name="ln458">		return B_NO_MEMORY;</a>
<a name="ln459"> </a>
<a name="ln460">	return B_OK;</a>
<a name="ln461">}</a>
<a name="ln462"> </a>
<a name="ln463"> </a>
<a name="ln464">/*!	Adds this inode to the specified transaction. This means that the inode will</a>
<a name="ln465">	be write locked until the transaction ended.</a>
<a name="ln466">	To ensure that the inode will stay valid until that point, an extra reference</a>
<a name="ln467">	is acquired to it as long as this transaction stays active.</a>
<a name="ln468">*/</a>
<a name="ln469">void</a>
<a name="ln470">Inode::WriteLockInTransaction(Transaction&amp; transaction)</a>
<a name="ln471">{</a>
<a name="ln472">	// These flags can only change while holding the transaction lock</a>
<a name="ln473">	if ((Flags() &amp; INODE_IN_TRANSACTION) != 0)</a>
<a name="ln474">		return;</a>
<a name="ln475"> </a>
<a name="ln476">	// We share the same list link with the removed list, so we have to remove</a>
<a name="ln477">	// the inode from that list here (and add it back when we no longer need it)</a>
<a name="ln478">	if ((Flags() &amp; INODE_DELETED) != 0)</a>
<a name="ln479">		fVolume-&gt;RemovedInodes().Remove(this);</a>
<a name="ln480"> </a>
<a name="ln481">	if (!fVolume-&gt;IsInitializing())</a>
<a name="ln482">		acquire_vnode(fVolume-&gt;FSVolume(), ID());</a>
<a name="ln483"> </a>
<a name="ln484">	rw_lock_write_lock(&amp;Lock());</a>
<a name="ln485">	Node().flags |= HOST_ENDIAN_TO_BFS_INT32(INODE_IN_TRANSACTION);</a>
<a name="ln486"> </a>
<a name="ln487">	transaction.AddListener(this);</a>
<a name="ln488">}</a>
<a name="ln489"> </a>
<a name="ln490"> </a>
<a name="ln491">status_t</a>
<a name="ln492">Inode::WriteBack(Transaction&amp; transaction)</a>
<a name="ln493">{</a>
<a name="ln494">	NodeGetter node(fVolume, transaction, this);</a>
<a name="ln495">	if (node.WritableNode() == NULL)</a>
<a name="ln496">		return B_IO_ERROR;</a>
<a name="ln497"> </a>
<a name="ln498">	memcpy(node.WritableNode(), &amp;Node(), sizeof(bfs_inode));</a>
<a name="ln499">	return B_OK;</a>
<a name="ln500">}</a>
<a name="ln501"> </a>
<a name="ln502"> </a>
<a name="ln503">status_t</a>
<a name="ln504">Inode::UpdateNodeFromDisk()</a>
<a name="ln505">{</a>
<a name="ln506">	NodeGetter node(fVolume, this);</a>
<a name="ln507">	if (node.Node() == NULL) {</a>
<a name="ln508">		FATAL((&quot;Failed to read block %&quot; B_PRId64 &quot; from disk!\n&quot;,</a>
<a name="ln509">			BlockNumber()));</a>
<a name="ln510">		return B_IO_ERROR;</a>
<a name="ln511">	}</a>
<a name="ln512"> </a>
<a name="ln513">	memcpy(&amp;fNode, node.Node(), sizeof(bfs_inode));</a>
<a name="ln514">	fNode.flags &amp;= HOST_ENDIAN_TO_BFS_INT32(INODE_PERMANENT_FLAGS);</a>
<a name="ln515">	return B_OK;</a>
<a name="ln516">}</a>
<a name="ln517"> </a>
<a name="ln518"> </a>
<a name="ln519">status_t</a>
<a name="ln520">Inode::CheckPermissions(int accessMode) const</a>
<a name="ln521">{</a>
<a name="ln522">	// you never have write access to a read-only volume</a>
<a name="ln523">	if ((accessMode &amp; W_OK) != 0 &amp;&amp; fVolume-&gt;IsReadOnly())</a>
<a name="ln524">		return B_READ_ONLY_DEVICE;</a>
<a name="ln525"> </a>
<a name="ln526">	return check_access_permissions(accessMode, Mode(), (gid_t)fNode.GroupID(),</a>
<a name="ln527">		(uid_t)fNode.UserID());</a>
<a name="ln528">}</a>
<a name="ln529"> </a>
<a name="ln530"> </a>
<a name="ln531">//	#pragma mark - attributes</a>
<a name="ln532"> </a>
<a name="ln533"> </a>
<a name="ln534">void</a>
<a name="ln535">Inode::_AddIterator(AttributeIterator* iterator)</a>
<a name="ln536">{</a>
<a name="ln537">	RecursiveLocker _(fSmallDataLock);</a>
<a name="ln538">	fIterators.Add(iterator);</a>
<a name="ln539">}</a>
<a name="ln540"> </a>
<a name="ln541"> </a>
<a name="ln542">void</a>
<a name="ln543">Inode::_RemoveIterator(AttributeIterator* iterator)</a>
<a name="ln544">{</a>
<a name="ln545">	RecursiveLocker _(fSmallDataLock);</a>
<a name="ln546">	fIterators.Remove(iterator);</a>
<a name="ln547">}</a>
<a name="ln548"> </a>
<a name="ln549"> </a>
<a name="ln550">/*!	Tries to free up &quot;bytes&quot; space in the small_data section by moving</a>
<a name="ln551">	attributes to real files. Used for system attributes like the name.</a>
<a name="ln552">	You need to hold the fSmallDataLock when you call this method</a>
<a name="ln553">*/</a>
<a name="ln554">status_t</a>
<a name="ln555">Inode::_MakeSpaceForSmallData(Transaction&amp; transaction, bfs_inode* node,</a>
<a name="ln556">	const char* name, int32 bytes)</a>
<a name="ln557">{</a>
<a name="ln558">	ASSERT_LOCKED_RECURSIVE(&amp;fSmallDataLock);</a>
<a name="ln559"> </a>
<a name="ln560">	while (bytes &gt; 0) {</a>
<a name="ln561">		small_data* item = node-&gt;SmallDataStart();</a>
<a name="ln562">		small_data* max = NULL;</a>
<a name="ln563">		int32 index = 0, maxIndex = 0;</a>
<a name="ln564">		for (; !item-&gt;IsLast(node); item = item-&gt;Next(), index++) {</a>
<a name="ln565">			// should not remove those</a>
<a name="ln566">			if (*item-&gt;Name() == FILE_NAME_NAME || !strcmp(name, item-&gt;Name()))</a>
<a name="ln567">				continue;</a>
<a name="ln568"> </a>
<a name="ln569">			if (max == NULL || max-&gt;Size() &lt; item-&gt;Size()) {</a>
<a name="ln570">				maxIndex = index;</a>
<a name="ln571">				max = item;</a>
<a name="ln572">			}</a>
<a name="ln573"> </a>
<a name="ln574">			// Remove the first one large enough to free the needed amount of</a>
<a name="ln575">			// bytes</a>
<a name="ln576">			if (bytes &lt; (int32)item-&gt;Size())</a>
<a name="ln577">				break;</a>
<a name="ln578">		}</a>
<a name="ln579"> </a>
<a name="ln580">		if (item-&gt;IsLast(node) || (int32)item-&gt;Size() &lt; bytes)</a>
<a name="ln581">			return B_ERROR;</a>
<a name="ln582"> </a>
<a name="ln583">		bytes -= max-&gt;Size();</a>
<a name="ln584"> </a>
<a name="ln585">		// Move the attribute to a real attribute file</a>
<a name="ln586">		// Luckily, this doesn't cause any index updates</a>
<a name="ln587"> </a>
<a name="ln588">		Inode* attribute;</a>
<a name="ln589">		status_t status = CreateAttribute(transaction, item-&gt;Name(),</a>
<a name="ln590">			item-&gt;Type(), &amp;attribute);</a>
<a name="ln591">		if (status != B_OK)</a>
<a name="ln592">			RETURN_ERROR(status);</a>
<a name="ln593"> </a>
<a name="ln594">		size_t length = item-&gt;DataSize();</a>
<a name="ln595">		status = attribute-&gt;WriteAt(transaction, 0, item-&gt;Data(), &amp;length);</a>
<a name="ln596"> </a>
<a name="ln597">		ReleaseAttribute(attribute);</a>
<a name="ln598"> </a>
<a name="ln599">		if (status != B_OK) {</a>
<a name="ln600">			Vnode vnode(fVolume, Attributes());</a>
<a name="ln601">			Inode* attributes;</a>
<a name="ln602">			if (vnode.Get(&amp;attributes) &lt; B_OK</a>
<a name="ln603">				|| attributes-&gt;Remove(transaction, name) &lt; B_OK) {</a>
<a name="ln604">				FATAL((&quot;Could not remove newly created attribute!\n&quot;));</a>
<a name="ln605">			}</a>
<a name="ln606"> </a>
<a name="ln607">			RETURN_ERROR(status);</a>
<a name="ln608">		}</a>
<a name="ln609"> </a>
<a name="ln610">		_RemoveSmallData(node, max, maxIndex);</a>
<a name="ln611">	}</a>
<a name="ln612">	return B_OK;</a>
<a name="ln613">}</a>
<a name="ln614"> </a>
<a name="ln615"> </a>
<a name="ln616">/*!	Private function which removes the given attribute from the small_data</a>
<a name="ln617">	section.</a>
<a name="ln618">	You need to hold the fSmallDataLock when you call this method</a>
<a name="ln619">*/</a>
<a name="ln620">status_t</a>
<a name="ln621">Inode::_RemoveSmallData(bfs_inode* node, small_data* item, int32 index)</a>
<a name="ln622">{</a>
<a name="ln623">	ASSERT_LOCKED_RECURSIVE(&amp;fSmallDataLock);</a>
<a name="ln624"> </a>
<a name="ln625">	small_data* next = item-&gt;Next();</a>
<a name="ln626">	if (!next-&gt;IsLast(node)) {</a>
<a name="ln627">		// find the last attribute</a>
<a name="ln628">		small_data* last = next;</a>
<a name="ln629">		while (!last-&gt;IsLast(node))</a>
<a name="ln630">			last = last-&gt;Next();</a>
<a name="ln631"> </a>
<a name="ln632">		int32 size = (uint8*)last - (uint8*)next;</a>
<a name="ln633">		if (size &lt; 0</a>
<a name="ln634">			|| size &gt; (uint8*)node + fVolume-&gt;BlockSize() - (uint8*)next)</a>
<a name="ln635">			return B_BAD_DATA;</a>
<a name="ln636"> </a>
<a name="ln637">		memmove(item, next, size);</a>
<a name="ln638"> </a>
<a name="ln639">		// Move the &quot;last&quot; one to its new location and</a>
<a name="ln640">		// correctly terminate the small_data section</a>
<a name="ln641">		last = (small_data*)((uint8*)last - ((uint8*)next - (uint8*)item));</a>
<a name="ln642">		memset(last, 0, (uint8*)node + fVolume-&gt;BlockSize() - (uint8*)last);</a>
<a name="ln643">	} else</a>
<a name="ln644">		memset(item, 0, item-&gt;Size());</a>
<a name="ln645"> </a>
<a name="ln646">	// update all current iterators</a>
<a name="ln647">	SinglyLinkedList&lt;AttributeIterator&gt;::Iterator iterator</a>
<a name="ln648">		= fIterators.GetIterator();</a>
<a name="ln649">	while (iterator.HasNext()) {</a>
<a name="ln650">		iterator.Next()-&gt;Update(index, -1);</a>
<a name="ln651">	}</a>
<a name="ln652"> </a>
<a name="ln653">	return B_OK;</a>
<a name="ln654">}</a>
<a name="ln655"> </a>
<a name="ln656"> </a>
<a name="ln657">//!	Removes the given attribute from the small_data section.</a>
<a name="ln658">status_t</a>
<a name="ln659">Inode::_RemoveSmallData(Transaction&amp; transaction, NodeGetter&amp; nodeGetter,</a>
<a name="ln660">	const char* name)</a>
<a name="ln661">{</a>
<a name="ln662">	if (name == NULL)</a>
<a name="ln663">		return B_BAD_VALUE;</a>
<a name="ln664"> </a>
<a name="ln665">	bfs_inode* node = nodeGetter.WritableNode();</a>
<a name="ln666">	RecursiveLocker locker(fSmallDataLock);</a>
<a name="ln667"> </a>
<a name="ln668">	// search for the small_data item</a>
<a name="ln669"> </a>
<a name="ln670">	small_data* item = node-&gt;SmallDataStart();</a>
<a name="ln671">	int32 index = 0;</a>
<a name="ln672">	while (!item-&gt;IsLast(node) &amp;&amp; strcmp(item-&gt;Name(), name)) {</a>
<a name="ln673">		item = item-&gt;Next();</a>
<a name="ln674">		index++;</a>
<a name="ln675">	}</a>
<a name="ln676"> </a>
<a name="ln677">	if (item-&gt;IsLast(node))</a>
<a name="ln678">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln679"> </a>
<a name="ln680">	nodeGetter.MakeWritable(transaction);</a>
<a name="ln681"> </a>
<a name="ln682">	status_t status = _RemoveSmallData(node, item, index);</a>
<a name="ln683">	if (status == B_OK) {</a>
<a name="ln684">		Node().status_change_time = HOST_ENDIAN_TO_BFS_INT64(</a>
<a name="ln685">			bfs_inode::ToInode(real_time_clock_usecs()));</a>
<a name="ln686"> </a>
<a name="ln687">		status = WriteBack(transaction);</a>
<a name="ln688">	}</a>
<a name="ln689"> </a>
<a name="ln690">	return status;</a>
<a name="ln691">}</a>
<a name="ln692"> </a>
<a name="ln693"> </a>
<a name="ln694">/*!	Try to place the given attribute in the small_data section - if the</a>
<a name="ln695">	new attribute is too big to fit in that section, it returns B_DEVICE_FULL.</a>
<a name="ln696">	In that case, the attribute should be written to a real attribute file;</a>
<a name="ln697">	it's the caller's responsibility to remove any existing attributes in the</a>
<a name="ln698">	small data section if that's the case.</a>
<a name="ln699"> </a>
<a name="ln700">	Note that you need to write back the inode yourself after having called that</a>
<a name="ln701">	method - it's a bad API decision that it needs a transaction but enforces</a>
<a name="ln702">	you to write back the inode all by yourself, but it's just more efficient</a>
<a name="ln703">	in most cases...</a>
<a name="ln704">*/</a>
<a name="ln705">status_t</a>
<a name="ln706">Inode::_AddSmallData(Transaction&amp; transaction, NodeGetter&amp; nodeGetter,</a>
<a name="ln707">	const char* name, uint32 type, off_t pos, const uint8* data, size_t length,</a>
<a name="ln708">	bool force)</a>
<a name="ln709">{</a>
<a name="ln710">	bfs_inode* node = nodeGetter.WritableNode();</a>
<a name="ln711"> </a>
<a name="ln712">	if (node == NULL || name == NULL || data == NULL)</a>
<a name="ln713">		return B_BAD_VALUE;</a>
<a name="ln714"> </a>
<a name="ln715">	// reject any requests that can't fit into the small_data section</a>
<a name="ln716">	uint32 nameLength = strlen(name);</a>
<a name="ln717">	uint32 spaceNeeded = sizeof(small_data) + nameLength + 3 + pos + length + 1;</a>
<a name="ln718">	if (spaceNeeded &gt; fVolume-&gt;InodeSize() - sizeof(bfs_inode))</a>
<a name="ln719">		return B_DEVICE_FULL;</a>
<a name="ln720"> </a>
<a name="ln721">	nodeGetter.MakeWritable(transaction);</a>
<a name="ln722">	RecursiveLocker locker(fSmallDataLock);</a>
<a name="ln723"> </a>
<a name="ln724">	// Find the last item or one with the same name we have to add</a>
<a name="ln725">	small_data* item = node-&gt;SmallDataStart();</a>
<a name="ln726">	int32 index = 0;</a>
<a name="ln727">	while (!item-&gt;IsLast(node) &amp;&amp; strcmp(item-&gt;Name(), name)) {</a>
<a name="ln728">		item = item-&gt;Next();</a>
<a name="ln729">		index++;</a>
<a name="ln730">	}</a>
<a name="ln731"> </a>
<a name="ln732">	// is the attribute already in the small_data section?</a>
<a name="ln733">	// then just replace the data part of that one</a>
<a name="ln734">	if (!item-&gt;IsLast(node)) {</a>
<a name="ln735">		// find last attribute</a>
<a name="ln736">		small_data* last = item;</a>
<a name="ln737">		while (!last-&gt;IsLast(node))</a>
<a name="ln738">			last = last-&gt;Next();</a>
<a name="ln739"> </a>
<a name="ln740">		// try to change the attributes value</a>
<a name="ln741">		if (item-&gt;data_size &gt; pos + length</a>
<a name="ln742">			|| force</a>
<a name="ln743">			|| ((uint8*)last + pos + length - item-&gt;DataSize())</a>
<a name="ln744">					&lt;= ((uint8*)node + fVolume-&gt;InodeSize())) {</a>
<a name="ln745">			// Make room for the new attribute if needed (and we are forced</a>
<a name="ln746">			// to do so)</a>
<a name="ln747">			if (force &amp;&amp; ((uint8*)last + pos + length - item-&gt;DataSize())</a>
<a name="ln748">					&gt; ((uint8*)node + fVolume-&gt;InodeSize())) {</a>
<a name="ln749">				// We also take the free space at the end of the small_data</a>
<a name="ln750">				// section into account, and request only what's really needed</a>
<a name="ln751">				uint32 needed = pos + length - item-&gt;DataSize() -</a>
<a name="ln752">					(uint32)((uint8*)node + fVolume-&gt;InodeSize()</a>
<a name="ln753">						- (uint8*)last);</a>
<a name="ln754"> </a>
<a name="ln755">				if (_MakeSpaceForSmallData(transaction, node, name, needed)</a>
<a name="ln756">						!= B_OK)</a>
<a name="ln757">					return B_ERROR;</a>
<a name="ln758"> </a>
<a name="ln759">				// reset our pointers</a>
<a name="ln760">				item = node-&gt;SmallDataStart();</a>
<a name="ln761">				index = 0;</a>
<a name="ln762">				while (!item-&gt;IsLast(node) &amp;&amp; strcmp(item-&gt;Name(), name)) {</a>
<a name="ln763">					item = item-&gt;Next();</a>
<a name="ln764">					index++;</a>
<a name="ln765">				}</a>
<a name="ln766"> </a>
<a name="ln767">				last = item;</a>
<a name="ln768">				while (!last-&gt;IsLast(node))</a>
<a name="ln769">					last = last-&gt;Next();</a>
<a name="ln770">			}</a>
<a name="ln771"> </a>
<a name="ln772">			size_t oldDataSize = item-&gt;DataSize();</a>
<a name="ln773"> </a>
<a name="ln774">			// Normally, we can just overwrite the attribute data as the size</a>
<a name="ln775">			// is specified by the type and does not change that often</a>
<a name="ln776">			if (pos + length != item-&gt;DataSize()) {</a>
<a name="ln777">				// move the attributes after the current one</a>
<a name="ln778">				small_data* next = item-&gt;Next();</a>
<a name="ln779">				if (!next-&gt;IsLast(node)) {</a>
<a name="ln780">					memmove((uint8*)item + spaceNeeded, next,</a>
<a name="ln781">						(uint8*)last - (uint8*)next);</a>
<a name="ln782">				}</a>
<a name="ln783"> </a>
<a name="ln784">				// Move the &quot;last&quot; one to its new location and</a>
<a name="ln785">				// correctly terminate the small_data section</a>
<a name="ln786">				last = (small_data*)((uint8*)last</a>
<a name="ln787">					- ((uint8*)next - ((uint8*)item + spaceNeeded)));</a>
<a name="ln788">				if ((uint8*)last &lt; (uint8*)node + fVolume-&gt;BlockSize()) {</a>
<a name="ln789">					memset(last, 0, (uint8*)node + fVolume-&gt;BlockSize()</a>
<a name="ln790">						- (uint8*)last);</a>
<a name="ln791">				}</a>
<a name="ln792"> </a>
<a name="ln793">				item-&gt;data_size = HOST_ENDIAN_TO_BFS_INT16(pos + length);</a>
<a name="ln794">			}</a>
<a name="ln795"> </a>
<a name="ln796">			item-&gt;type = HOST_ENDIAN_TO_BFS_INT32(type);</a>
<a name="ln797"> </a>
<a name="ln798">			if ((uint64)oldDataSize &lt; (uint64)pos) {</a>
<a name="ln799">				// Fill gap with zeros</a>
<a name="ln800">				memset(item-&gt;Data() + oldDataSize, 0, pos - oldDataSize);</a>
<a name="ln801">			}</a>
<a name="ln802">			if (user_memcpy(item-&gt;Data() + pos, data, length) &lt; B_OK)</a>
<a name="ln803">				return B_BAD_ADDRESS;</a>
<a name="ln804">			item-&gt;Data()[pos + length] = '\0';</a>
<a name="ln805"> </a>
<a name="ln806">			return B_OK;</a>
<a name="ln807">		}</a>
<a name="ln808"> </a>
<a name="ln809">		return B_DEVICE_FULL;</a>
<a name="ln810">	}</a>
<a name="ln811"> </a>
<a name="ln812">	// try to add the new attribute!</a>
<a name="ln813"> </a>
<a name="ln814">	if ((uint8*)item + spaceNeeded &gt; (uint8*)node + fVolume-&gt;InodeSize()) {</a>
<a name="ln815">		// there is not enough space for it!</a>
<a name="ln816">		if (!force)</a>
<a name="ln817">			return B_DEVICE_FULL;</a>
<a name="ln818"> </a>
<a name="ln819">		// make room for the new attribute</a>
<a name="ln820">		if (_MakeSpaceForSmallData(transaction, node, name, spaceNeeded) &lt; B_OK)</a>
<a name="ln821">			return B_ERROR;</a>
<a name="ln822"> </a>
<a name="ln823">		// get new last item!</a>
<a name="ln824">		item = node-&gt;SmallDataStart();</a>
<a name="ln825">		index = 0;</a>
<a name="ln826">		while (!item-&gt;IsLast(node)) {</a>
<a name="ln827">			item = item-&gt;Next();</a>
<a name="ln828">			index++;</a>
<a name="ln829">		}</a>
<a name="ln830">	}</a>
<a name="ln831"> </a>
<a name="ln832">	memset(item, 0, spaceNeeded);</a>
<a name="ln833">	item-&gt;type = HOST_ENDIAN_TO_BFS_INT32(type);</a>
<a name="ln834">	item-&gt;name_size = HOST_ENDIAN_TO_BFS_INT16(nameLength);</a>
<a name="ln835">	item-&gt;data_size = HOST_ENDIAN_TO_BFS_INT16(length);</a>
<a name="ln836">	strcpy(item-&gt;Name(), name);</a>
<a name="ln837">	if (user_memcpy(item-&gt;Data() + pos, data, length) &lt; B_OK)</a>
<a name="ln838">		return B_BAD_ADDRESS;</a>
<a name="ln839"> </a>
<a name="ln840">	// correctly terminate the small_data section</a>
<a name="ln841">	item = item-&gt;Next();</a>
<a name="ln842">	if (!item-&gt;IsLast(node))</a>
<a name="ln843">		memset(item, 0, (uint8*)node + fVolume-&gt;InodeSize() - (uint8*)item);</a>
<a name="ln844"> </a>
<a name="ln845">	// update all current iterators</a>
<a name="ln846">	SinglyLinkedList&lt;AttributeIterator&gt;::Iterator iterator</a>
<a name="ln847">		= fIterators.GetIterator();</a>
<a name="ln848">	while (iterator.HasNext()) {</a>
<a name="ln849">		iterator.Next()-&gt;Update(index, 1);</a>
<a name="ln850">	}</a>
<a name="ln851"> </a>
<a name="ln852">	return B_OK;</a>
<a name="ln853">}</a>
<a name="ln854"> </a>
<a name="ln855"> </a>
<a name="ln856">/*!	Iterates through the small_data section of an inode.</a>
<a name="ln857">	To start at the beginning of this section, you let smallData</a>
<a name="ln858">	point to NULL, like:</a>
<a name="ln859">		small_data* data = NULL;</a>
<a name="ln860">		while (inode-&gt;GetNextSmallData(&amp;data) { ... }</a>
<a name="ln861"> </a>
<a name="ln862">	This function is reentrant and doesn't allocate any memory;</a>
<a name="ln863">	you can safely stop calling it at any point (you don't need</a>
<a name="ln864">	to iterate through the whole list).</a>
<a name="ln865">	You need to hold the fSmallDataLock when you call this method</a>
<a name="ln866">*/</a>
<a name="ln867">status_t</a>
<a name="ln868">Inode::_GetNextSmallData(bfs_inode* node, small_data** _smallData) const</a>
<a name="ln869">{</a>
<a name="ln870">	if (node == NULL)</a>
<a name="ln871">		RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln872"> </a>
<a name="ln873">	ASSERT_LOCKED_RECURSIVE(&amp;fSmallDataLock);</a>
<a name="ln874"> </a>
<a name="ln875">	small_data* data = *_smallData;</a>
<a name="ln876"> </a>
<a name="ln877">	// begin from the start?</a>
<a name="ln878">	if (data == NULL)</a>
<a name="ln879">		data = node-&gt;SmallDataStart();</a>
<a name="ln880">	else</a>
<a name="ln881">		data = data-&gt;Next();</a>
<a name="ln882"> </a>
<a name="ln883">	// is already last item?</a>
<a name="ln884">	if (data-&gt;IsLast(node))</a>
<a name="ln885">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln886"> </a>
<a name="ln887">	*_smallData = data;</a>
<a name="ln888"> </a>
<a name="ln889">	return B_OK;</a>
<a name="ln890">}</a>
<a name="ln891"> </a>
<a name="ln892"> </a>
<a name="ln893">/*!	Finds the attribute &quot;name&quot; in the small data section, and</a>
<a name="ln894">	returns a pointer to it (or NULL if it doesn't exist).</a>
<a name="ln895">	You need to hold the fSmallDataLock when you call this method</a>
<a name="ln896">*/</a>
<a name="ln897">small_data*</a>
<a name="ln898">Inode::FindSmallData(const bfs_inode* node, const char* name) const</a>
<a name="ln899">{</a>
<a name="ln900">	ASSERT_LOCKED_RECURSIVE(&amp;fSmallDataLock);</a>
<a name="ln901"> </a>
<a name="ln902">	small_data* smallData = NULL;</a>
<a name="ln903">	while (_GetNextSmallData(const_cast&lt;bfs_inode*&gt;(node), &amp;smallData)</a>
<a name="ln904">			== B_OK) {</a>
<a name="ln905">		if (!strcmp(smallData-&gt;Name(), name))</a>
<a name="ln906">			return smallData;</a>
<a name="ln907">	}</a>
<a name="ln908">	return NULL;</a>
<a name="ln909">}</a>
<a name="ln910"> </a>
<a name="ln911"> </a>
<a name="ln912">/*!	Returns a pointer to the node's name if present in the small data</a>
<a name="ln913">	section, NULL otherwise.</a>
<a name="ln914">	You need to hold the fSmallDataLock when you call this method</a>
<a name="ln915">*/</a>
<a name="ln916">const char*</a>
<a name="ln917">Inode::Name(const bfs_inode* node) const</a>
<a name="ln918">{</a>
<a name="ln919">	ASSERT_LOCKED_RECURSIVE(&amp;fSmallDataLock);</a>
<a name="ln920"> </a>
<a name="ln921">	small_data* smallData = NULL;</a>
<a name="ln922">	while (_GetNextSmallData((bfs_inode*)node, &amp;smallData) == B_OK) {</a>
<a name="ln923">		if (*smallData-&gt;Name() == FILE_NAME_NAME</a>
<a name="ln924">			&amp;&amp; smallData-&gt;NameSize() == FILE_NAME_NAME_LENGTH)</a>
<a name="ln925">			return (const char*)smallData-&gt;Data();</a>
<a name="ln926">	}</a>
<a name="ln927">	return NULL;</a>
<a name="ln928">}</a>
<a name="ln929"> </a>
<a name="ln930"> </a>
<a name="ln931">/*!	Copies the node's name into the provided buffer.</a>
<a name="ln932">	The buffer should be B_FILE_NAME_LENGTH bytes large.</a>
<a name="ln933">*/</a>
<a name="ln934">status_t</a>
<a name="ln935">Inode::GetName(char* buffer, size_t size) const</a>
<a name="ln936">{</a>
<a name="ln937">	NodeGetter node(fVolume, this);</a>
<a name="ln938">	if (node.Node() == NULL)</a>
<a name="ln939">		return B_IO_ERROR;</a>
<a name="ln940"> </a>
<a name="ln941">	RecursiveLocker locker(fSmallDataLock);</a>
<a name="ln942"> </a>
<a name="ln943">	const char* name = Name(node.Node());</a>
<a name="ln944">	if (name == NULL)</a>
<a name="ln945">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln946"> </a>
<a name="ln947">	strlcpy(buffer, name, size);</a>
<a name="ln948">	return B_OK;</a>
<a name="ln949">}</a>
<a name="ln950"> </a>
<a name="ln951"> </a>
<a name="ln952">/*!	Changes or set the name of a file: in the inode small_data section only, it</a>
<a name="ln953">	doesn't change it in the parent directory's b+tree.</a>
<a name="ln954">	Note that you need to write back the inode yourself after having called</a>
<a name="ln955">	that method. It suffers from the same API decision as AddSmallData() does</a>
<a name="ln956">	(and for the same reason).</a>
<a name="ln957">*/</a>
<a name="ln958">status_t</a>
<a name="ln959">Inode::SetName(Transaction&amp; transaction, const char* name)</a>
<a name="ln960">{</a>
<a name="ln961">	if (name == NULL || *name == '\0')</a>
<a name="ln962">		return B_BAD_VALUE;</a>
<a name="ln963"> </a>
<a name="ln964">	NodeGetter node(fVolume, transaction, this);</a>
<a name="ln965">	if (node.Node() == NULL)</a>
<a name="ln966">		return B_IO_ERROR;</a>
<a name="ln967"> </a>
<a name="ln968">	const char nameTag[2] = {FILE_NAME_NAME, 0};</a>
<a name="ln969"> </a>
<a name="ln970">	return _AddSmallData(transaction, node, nameTag, FILE_NAME_TYPE, 0,</a>
<a name="ln971">		(uint8*)name, strlen(name), true);</a>
<a name="ln972">}</a>
<a name="ln973"> </a>
<a name="ln974"> </a>
<a name="ln975">status_t</a>
<a name="ln976">Inode::_RemoveAttribute(Transaction&amp; transaction, const char* name,</a>
<a name="ln977">	bool hasIndex, Index* index)</a>
<a name="ln978">{</a>
<a name="ln979">	// remove the attribute file if it exists</a>
<a name="ln980">	Vnode vnode(fVolume, Attributes());</a>
<a name="ln981">	Inode* attributes;</a>
<a name="ln982">	status_t status = vnode.Get(&amp;attributes);</a>
<a name="ln983">	if (status &lt; B_OK)</a>
<a name="ln984">		return status;</a>
<a name="ln985"> </a>
<a name="ln986">	// update index</a>
<a name="ln987">	if (index != NULL) {</a>
<a name="ln988">		Inode* attribute;</a>
<a name="ln989">		if ((hasIndex || fVolume-&gt;CheckForLiveQuery(name))</a>
<a name="ln990">			&amp;&amp; GetAttribute(name, &amp;attribute) == B_OK) {</a>
<a name="ln991">			uint8 data[MAX_INDEX_KEY_LENGTH];</a>
<a name="ln992">			size_t length = MAX_INDEX_KEY_LENGTH;</a>
<a name="ln993">			if (attribute-&gt;ReadAt(0, data, &amp;length) == B_OK) {</a>
<a name="ln994">				index-&gt;Update(transaction, name, attribute-&gt;Type(), data,</a>
<a name="ln995">					length, NULL, 0, this);</a>
<a name="ln996">			}</a>
<a name="ln997"> </a>
<a name="ln998">			ReleaseAttribute(attribute);</a>
<a name="ln999">		}</a>
<a name="ln1000">	}</a>
<a name="ln1001"> </a>
<a name="ln1002">	if ((status = attributes-&gt;Remove(transaction, name)) &lt; B_OK)</a>
<a name="ln1003">		return status;</a>
<a name="ln1004"> </a>
<a name="ln1005">	if (attributes-&gt;IsEmpty()) {</a>
<a name="ln1006">		attributes-&gt;WriteLockInTransaction(transaction);</a>
<a name="ln1007"> </a>
<a name="ln1008">		// remove attribute directory (don't fail if that can't be done)</a>
<a name="ln1009">		if (remove_vnode(fVolume-&gt;FSVolume(), attributes-&gt;ID()) == B_OK) {</a>
<a name="ln1010">			// update the inode, so that no one will ever doubt it's deleted :-)</a>
<a name="ln1011">			attributes-&gt;Node().flags |= HOST_ENDIAN_TO_BFS_INT32(INODE_DELETED);</a>
<a name="ln1012">			if (attributes-&gt;WriteBack(transaction) == B_OK) {</a>
<a name="ln1013">				Attributes().SetTo(0, 0, 0);</a>
<a name="ln1014">				WriteBack(transaction);</a>
<a name="ln1015">			} else {</a>
<a name="ln1016">				unremove_vnode(fVolume-&gt;FSVolume(), attributes-&gt;ID());</a>
<a name="ln1017">				attributes-&gt;Node().flags</a>
<a name="ln1018">					&amp;= ~HOST_ENDIAN_TO_BFS_INT32(INODE_DELETED);</a>
<a name="ln1019">			}</a>
<a name="ln1020">		}</a>
<a name="ln1021">	}</a>
<a name="ln1022"> </a>
<a name="ln1023">	return status;</a>
<a name="ln1024">}</a>
<a name="ln1025"> </a>
<a name="ln1026"> </a>
<a name="ln1027">/*!	Reads data from the specified attribute.</a>
<a name="ln1028">	This is a high-level attribute function that understands attributes</a>
<a name="ln1029">	in the small_data section as well as real attribute files.</a>
<a name="ln1030">*/</a>
<a name="ln1031">status_t</a>
<a name="ln1032">Inode::ReadAttribute(const char* name, int32 type, off_t pos, uint8* buffer,</a>
<a name="ln1033">	size_t* _length)</a>
<a name="ln1034">{</a>
<a name="ln1035">	if (pos &lt; 0)</a>
<a name="ln1036">		pos = 0;</a>
<a name="ln1037"> </a>
<a name="ln1038">	// search in the small_data section (which has to be locked first)</a>
<a name="ln1039">	{</a>
<a name="ln1040">		NodeGetter node(fVolume, this);</a>
<a name="ln1041">		if (node.Node() == NULL)</a>
<a name="ln1042">			return B_IO_ERROR;</a>
<a name="ln1043"> </a>
<a name="ln1044">		RecursiveLocker locker(fSmallDataLock);</a>
<a name="ln1045"> </a>
<a name="ln1046">		small_data* smallData = FindSmallData(node.Node(), name);</a>
<a name="ln1047">		if (smallData != NULL) {</a>
<a name="ln1048">			size_t length = *_length;</a>
<a name="ln1049">			if (pos &gt;= smallData-&gt;data_size) {</a>
<a name="ln1050">				*_length = 0;</a>
<a name="ln1051">				return B_OK;</a>
<a name="ln1052">			}</a>
<a name="ln1053">			if (length + pos &gt; smallData-&gt;DataSize())</a>
<a name="ln1054">				length = smallData-&gt;DataSize() - pos;</a>
<a name="ln1055"> </a>
<a name="ln1056">			status_t error = user_memcpy(buffer, smallData-&gt;Data() + pos,</a>
<a name="ln1057">				length);</a>
<a name="ln1058">			*_length = length;</a>
<a name="ln1059">			return error;</a>
<a name="ln1060">		}</a>
<a name="ln1061">	}</a>
<a name="ln1062"> </a>
<a name="ln1063">	// search in the attribute directory</a>
<a name="ln1064">	Inode* attribute;</a>
<a name="ln1065">	status_t status = GetAttribute(name, &amp;attribute);</a>
<a name="ln1066">	if (status == B_OK) {</a>
<a name="ln1067">		status = attribute-&gt;ReadAt(pos, (uint8*)buffer, _length);</a>
<a name="ln1068"> </a>
<a name="ln1069">		ReleaseAttribute(attribute);</a>
<a name="ln1070">	}</a>
<a name="ln1071"> </a>
<a name="ln1072">	RETURN_ERROR(status);</a>
<a name="ln1073">}</a>
<a name="ln1074"> </a>
<a name="ln1075"> </a>
<a name="ln1076">/*!	Writes data to the specified attribute.</a>
<a name="ln1077">	This is a high-level attribute function that understands attributes</a>
<a name="ln1078">	in the small_data section as well as real attribute files.</a>
<a name="ln1079">*/</a>
<a name="ln1080">status_t</a>
<a name="ln1081">Inode::WriteAttribute(Transaction&amp; transaction, const char* name, int32 type,</a>
<a name="ln1082">	off_t pos, const uint8* buffer, size_t* _length, bool* _created)</a>
<a name="ln1083">{</a>
<a name="ln1084">	if (pos &lt; 0)</a>
<a name="ln1085">		return B_BAD_VALUE;</a>
<a name="ln1086"> </a>
<a name="ln1087">	// needed to maintain the index</a>
<a name="ln1088">	uint8 oldBuffer[MAX_INDEX_KEY_LENGTH];</a>
<a name="ln1089">	uint8* oldData = NULL;</a>
<a name="ln1090">	size_t oldLength = 0;</a>
<a name="ln1091">	bool created = false;</a>
<a name="ln1092"> </a>
<a name="ln1093">	// TODO: we actually depend on that the contents of &quot;buffer&quot; are constant.</a>
<a name="ln1094">	// If they get changed during the write (hey, user programs), we may mess</a>
<a name="ln1095">	// up our index trees!</a>
<a name="ln1096">	// TODO: for attribute files, we need to log the first</a>
<a name="ln1097">	// MAX_INDEX_KEY_LENGTH bytes of the data stream, or the same as above</a>
<a name="ln1098">	// might happen.</a>
<a name="ln1099"> </a>
<a name="ln1100">	Index index(fVolume);</a>
<a name="ln1101">	bool hasIndex = index.SetTo(name) == B_OK;</a>
<a name="ln1102"> </a>
<a name="ln1103">	Inode* attribute = NULL;</a>
<a name="ln1104">	status_t status = B_OK;</a>
<a name="ln1105"> </a>
<a name="ln1106">	if (GetAttribute(name, &amp;attribute) != B_OK) {</a>
<a name="ln1107">		// No attribute inode exists yet</a>
<a name="ln1108"> </a>
<a name="ln1109">		// save the old attribute data</a>
<a name="ln1110">		NodeGetter node(fVolume, transaction, this);</a>
<a name="ln1111">		if (node.Node() == NULL)</a>
<a name="ln1112">			return B_IO_ERROR;</a>
<a name="ln1113"> </a>
<a name="ln1114">		recursive_lock_lock(&amp;fSmallDataLock);</a>
<a name="ln1115"> </a>
<a name="ln1116">		small_data* smallData = FindSmallData(node.Node(), name);</a>
<a name="ln1117">		if (smallData != NULL) {</a>
<a name="ln1118">			oldLength = smallData-&gt;DataSize();</a>
<a name="ln1119">			if (oldLength &gt; 0) {</a>
<a name="ln1120">				if (oldLength &gt; MAX_INDEX_KEY_LENGTH)</a>
<a name="ln1121">					oldLength = MAX_INDEX_KEY_LENGTH;</a>
<a name="ln1122">				memcpy(oldData = oldBuffer, smallData-&gt;Data(), oldLength);</a>
<a name="ln1123">			}</a>
<a name="ln1124">		} else</a>
<a name="ln1125">			created = true;</a>
<a name="ln1126"> </a>
<a name="ln1127">		recursive_lock_unlock(&amp;fSmallDataLock);</a>
<a name="ln1128"> </a>
<a name="ln1129">		// if the attribute doesn't exist yet (as a file), try to put it in the</a>
<a name="ln1130">		// small_data section first - if that fails (due to insufficent space),</a>
<a name="ln1131">		// create a real attribute file</a>
<a name="ln1132">		status = _AddSmallData(transaction, node, name, type, pos, buffer,</a>
<a name="ln1133">			*_length);</a>
<a name="ln1134">		if (status == B_DEVICE_FULL) {</a>
<a name="ln1135">			if (smallData != NULL) {</a>
<a name="ln1136">				// remove the old attribute from the small data section - there</a>
<a name="ln1137">				// is no space left for the new data</a>
<a name="ln1138">				status = _RemoveSmallData(transaction, node, name);</a>
<a name="ln1139">			} else</a>
<a name="ln1140">				status = B_OK;</a>
<a name="ln1141"> </a>
<a name="ln1142">			if (status == B_OK)</a>
<a name="ln1143">				status = CreateAttribute(transaction, name, type, &amp;attribute);</a>
<a name="ln1144">			if (status != B_OK)</a>
<a name="ln1145">				RETURN_ERROR(status);</a>
<a name="ln1146"> </a>
<a name="ln1147">			created = true;</a>
<a name="ln1148">		} else if (status == B_OK) {</a>
<a name="ln1149">			// Update status time on attribute write</a>
<a name="ln1150">			Node().status_change_time = HOST_ENDIAN_TO_BFS_INT64(</a>
<a name="ln1151">				bfs_inode::ToInode(real_time_clock_usecs()));</a>
<a name="ln1152"> </a>
<a name="ln1153">			status = WriteBack(transaction);</a>
<a name="ln1154">		}</a>
<a name="ln1155">	}</a>
<a name="ln1156"> </a>
<a name="ln1157">	if (attribute != NULL) {</a>
<a name="ln1158">		WriteLocker writeLocker(attribute-&gt;fLock);</a>
<a name="ln1159"> </a>
<a name="ln1160">		if (hasIndex || fVolume-&gt;CheckForLiveQuery(name)) {</a>
<a name="ln1161">			// Save the old attribute data (if this fails, oldLength will</a>
<a name="ln1162">			// reflect it)</a>
<a name="ln1163">			while (attribute-&gt;Size() &gt; 0) {</a>
<a name="ln1164">				bigtime_t oldModified = attribute-&gt;LastModified();</a>
<a name="ln1165">				writeLocker.Unlock();</a>
<a name="ln1166"> </a>
<a name="ln1167">				oldLength = MAX_INDEX_KEY_LENGTH;</a>
<a name="ln1168">				if (attribute-&gt;ReadAt(0, oldBuffer, &amp;oldLength) == B_OK)</a>
<a name="ln1169">					oldData = oldBuffer;</a>
<a name="ln1170"> </a>
<a name="ln1171">				writeLocker.Lock();</a>
<a name="ln1172"> </a>
<a name="ln1173">				// Read until the data hasn't changed in between</a>
<a name="ln1174">				if (oldModified == attribute-&gt;LastModified())</a>
<a name="ln1175">					break;</a>
<a name="ln1176"> </a>
<a name="ln1177">				oldLength = 0;</a>
<a name="ln1178">			}</a>
<a name="ln1179">		}</a>
<a name="ln1180"> </a>
<a name="ln1181">		// check if the data fits into the small_data section again</a>
<a name="ln1182">		NodeGetter node(fVolume, transaction, this);</a>
<a name="ln1183">		if (node.Node() == NULL)</a>
<a name="ln1184">			return B_IO_ERROR;</a>
<a name="ln1185"> </a>
<a name="ln1186">		status = _AddSmallData(transaction, node, name, type, pos, buffer,</a>
<a name="ln1187">			*_length);</a>
<a name="ln1188"> </a>
<a name="ln1189">		if (status == B_OK) {</a>
<a name="ln1190">			// it does - remove its file</a>
<a name="ln1191">			writeLocker.Unlock();</a>
<a name="ln1192">			status = _RemoveAttribute(transaction, name, false, NULL);</a>
<a name="ln1193">		} else {</a>
<a name="ln1194">			// The attribute type might have been changed - we need to</a>
<a name="ln1195">			// adopt the new one</a>
<a name="ln1196">			attribute-&gt;Node().type = HOST_ENDIAN_TO_BFS_INT32(type);</a>
<a name="ln1197">			status = attribute-&gt;WriteBack(transaction);</a>
<a name="ln1198">			writeLocker.Unlock();</a>
<a name="ln1199"> </a>
<a name="ln1200">			if (status == B_OK) {</a>
<a name="ln1201">				status = attribute-&gt;WriteAt(transaction, pos, buffer,</a>
<a name="ln1202">					_length);</a>
<a name="ln1203">			}</a>
<a name="ln1204">		}</a>
<a name="ln1205"> </a>
<a name="ln1206">		if (status == B_OK) {</a>
<a name="ln1207">			// Update status time on attribute write</a>
<a name="ln1208">			Node().status_change_time = HOST_ENDIAN_TO_BFS_INT64(</a>
<a name="ln1209">				bfs_inode::ToInode(real_time_clock_usecs()));</a>
<a name="ln1210"> </a>
<a name="ln1211">			status = WriteBack(transaction);</a>
<a name="ln1212">		}</a>
<a name="ln1213"> </a>
<a name="ln1214">		attribute-&gt;WriteLockInTransaction(transaction);</a>
<a name="ln1215">		ReleaseAttribute(attribute);</a>
<a name="ln1216">	}</a>
<a name="ln1217"> </a>
<a name="ln1218">	// TODO: find a better way than this &quot;pos&quot; thing (the begin of the old key</a>
<a name="ln1219">	//	must be copied to the start of the new one for a comparison)</a>
<a name="ln1220">	if (status == B_OK &amp;&amp; pos == 0) {</a>
<a name="ln1221">		// Index only the first MAX_INDEX_KEY_LENGTH bytes</a>
<a name="ln1222">		uint16 length = *_length;</a>
<a name="ln1223">		if (length &gt; MAX_INDEX_KEY_LENGTH)</a>
<a name="ln1224">			length = MAX_INDEX_KEY_LENGTH;</a>
<a name="ln1225"> </a>
<a name="ln1226">		uint8 indexBuffer[MAX_INDEX_KEY_LENGTH];</a>
<a name="ln1227">		// _AddSmallData() already read the buffer</a>
<a name="ln1228">		user_memcpy(indexBuffer, buffer, length);</a>
<a name="ln1229"> </a>
<a name="ln1230">		// Update index. Note, Index::Update() may be called even if</a>
<a name="ln1231">		// initializing the index failed - it will just update the live</a>
<a name="ln1232">		// queries in this case</a>
<a name="ln1233">		if (pos &lt; length || (uint64)pos &lt; (uint64)oldLength) {</a>
<a name="ln1234">			index.Update(transaction, name, type, oldData, oldLength,</a>
<a name="ln1235">				indexBuffer, length, this);</a>
<a name="ln1236">		}</a>
<a name="ln1237">	}</a>
<a name="ln1238"> </a>
<a name="ln1239">	if (_created != NULL)</a>
<a name="ln1240">		*_created = created;</a>
<a name="ln1241"> </a>
<a name="ln1242">	return status;</a>
<a name="ln1243">}</a>
<a name="ln1244"> </a>
<a name="ln1245"> </a>
<a name="ln1246">/*!	Removes the specified attribute from the inode.</a>
<a name="ln1247">	This is a high-level attribute function that understands attributes</a>
<a name="ln1248">	in the small_data section as well as real attribute files.</a>
<a name="ln1249">*/</a>
<a name="ln1250">status_t</a>
<a name="ln1251">Inode::RemoveAttribute(Transaction&amp; transaction, const char* name)</a>
<a name="ln1252">{</a>
<a name="ln1253">	Index index(fVolume);</a>
<a name="ln1254">	bool hasIndex = index.SetTo(name) == B_OK;</a>
<a name="ln1255">	NodeGetter node(fVolume, this);</a>
<a name="ln1256">	if (node.Node() == NULL)</a>
<a name="ln1257">		return B_IO_ERROR;</a>
<a name="ln1258"> </a>
<a name="ln1259">	// update index for attributes in the small_data section</a>
<a name="ln1260">	{</a>
<a name="ln1261">		RecursiveLocker _(fSmallDataLock);</a>
<a name="ln1262"> </a>
<a name="ln1263">		small_data* smallData = FindSmallData(node.Node(), name);</a>
<a name="ln1264">		if (smallData != NULL) {</a>
<a name="ln1265">			uint32 length = smallData-&gt;DataSize();</a>
<a name="ln1266">			if (length &gt; MAX_INDEX_KEY_LENGTH)</a>
<a name="ln1267">				length = MAX_INDEX_KEY_LENGTH;</a>
<a name="ln1268">			index.Update(transaction, name, smallData-&gt;Type(),</a>
<a name="ln1269">				smallData-&gt;Data(), length, NULL, 0, this);</a>
<a name="ln1270">		}</a>
<a name="ln1271">	}</a>
<a name="ln1272"> </a>
<a name="ln1273">	status_t status = _RemoveSmallData(transaction, node, name);</a>
<a name="ln1274">	if (status == B_ENTRY_NOT_FOUND &amp;&amp; !Attributes().IsZero()) {</a>
<a name="ln1275">		// remove the attribute file if it exists</a>
<a name="ln1276">		status = _RemoveAttribute(transaction, name, hasIndex, &amp;index);</a>
<a name="ln1277">		if (status == B_OK) {</a>
<a name="ln1278">			Node().status_change_time = HOST_ENDIAN_TO_BFS_INT64(</a>
<a name="ln1279">				bfs_inode::ToInode(real_time_clock_usecs()));</a>
<a name="ln1280">			WriteBack(transaction);</a>
<a name="ln1281">		}</a>
<a name="ln1282">	}</a>
<a name="ln1283"> </a>
<a name="ln1284">	return status;</a>
<a name="ln1285">}</a>
<a name="ln1286"> </a>
<a name="ln1287"> </a>
<a name="ln1288">/*!	Returns the attribute inode with the specified \a name, in case it exists.</a>
<a name="ln1289">	This method can only return real attribute files; the attributes in the</a>
<a name="ln1290">	small data section are ignored.</a>
<a name="ln1291">*/</a>
<a name="ln1292">status_t</a>
<a name="ln1293">Inode::GetAttribute(const char* name, Inode** _attribute)</a>
<a name="ln1294">{</a>
<a name="ln1295">	// does this inode even have attributes?</a>
<a name="ln1296">	if (Attributes().IsZero())</a>
<a name="ln1297">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln1298"> </a>
<a name="ln1299">	Vnode vnode(fVolume, Attributes());</a>
<a name="ln1300">	Inode* attributes;</a>
<a name="ln1301">	if (vnode.Get(&amp;attributes) &lt; B_OK) {</a>
<a name="ln1302">		FATAL((&quot;get_vnode() failed in Inode::GetAttribute(name = \&quot;%s\&quot;)\n&quot;,</a>
<a name="ln1303">			name));</a>
<a name="ln1304">		return B_ERROR;</a>
<a name="ln1305">	}</a>
<a name="ln1306"> </a>
<a name="ln1307">	BPlusTree* tree = attributes-&gt;Tree();</a>
<a name="ln1308">	if (tree == NULL)</a>
<a name="ln1309">		return B_BAD_VALUE;</a>
<a name="ln1310"> </a>
<a name="ln1311">	InodeReadLocker locker(attributes);</a>
<a name="ln1312"> </a>
<a name="ln1313">	ino_t id;</a>
<a name="ln1314">	status_t status = tree-&gt;Find((uint8*)name, (uint16)strlen(name), &amp;id);</a>
<a name="ln1315">	if (status == B_OK) {</a>
<a name="ln1316">		Vnode vnode(fVolume, id);</a>
<a name="ln1317">		Inode* inode;</a>
<a name="ln1318">		// Check if the attribute is really an attribute</a>
<a name="ln1319">		if (vnode.Get(&amp;inode) != B_OK || !inode-&gt;IsAttribute())</a>
<a name="ln1320">			return B_ERROR;</a>
<a name="ln1321"> </a>
<a name="ln1322">		*_attribute = inode;</a>
<a name="ln1323">		vnode.Keep();</a>
<a name="ln1324">		return B_OK;</a>
<a name="ln1325">	}</a>
<a name="ln1326"> </a>
<a name="ln1327">	return status;</a>
<a name="ln1328">}</a>
<a name="ln1329"> </a>
<a name="ln1330"> </a>
<a name="ln1331">void</a>
<a name="ln1332">Inode::ReleaseAttribute(Inode* attribute)</a>
<a name="ln1333">{</a>
<a name="ln1334">	if (attribute == NULL)</a>
<a name="ln1335">		return;</a>
<a name="ln1336"> </a>
<a name="ln1337">	put_vnode(fVolume-&gt;FSVolume(), attribute-&gt;ID());</a>
<a name="ln1338">}</a>
<a name="ln1339"> </a>
<a name="ln1340"> </a>
<a name="ln1341">status_t</a>
<a name="ln1342">Inode::CreateAttribute(Transaction&amp; transaction, const char* name, uint32 type,</a>
<a name="ln1343">	Inode** attribute)</a>
<a name="ln1344">{</a>
<a name="ln1345">	// do we need to create the attribute directory first?</a>
<a name="ln1346">	if (Attributes().IsZero()) {</a>
<a name="ln1347">		status_t status = Inode::Create(transaction, this, NULL,</a>
<a name="ln1348">			S_ATTR_DIR | S_DIRECTORY | 0666, 0, 0, NULL);</a>
<a name="ln1349">		if (status &lt; B_OK)</a>
<a name="ln1350">			RETURN_ERROR(status);</a>
<a name="ln1351">	}</a>
<a name="ln1352">	Vnode vnode(fVolume, Attributes());</a>
<a name="ln1353">	Inode* attributes;</a>
<a name="ln1354">	if (vnode.Get(&amp;attributes) &lt; B_OK)</a>
<a name="ln1355">		return B_ERROR;</a>
<a name="ln1356"> </a>
<a name="ln1357">	// Inode::Create() locks the inode for us</a>
<a name="ln1358">	return Inode::Create(transaction, attributes, name,</a>
<a name="ln1359">		S_ATTR | S_FILE | 0666, 0, type, NULL, NULL, attribute);</a>
<a name="ln1360">}</a>
<a name="ln1361"> </a>
<a name="ln1362"> </a>
<a name="ln1363">//	#pragma mark - directory tree</a>
<a name="ln1364"> </a>
<a name="ln1365"> </a>
<a name="ln1366">bool</a>
<a name="ln1367">Inode::IsEmpty()</a>
<a name="ln1368">{</a>
<a name="ln1369">	TreeIterator iterator(fTree);</a>
<a name="ln1370"> </a>
<a name="ln1371">	uint32 count = 0;</a>
<a name="ln1372">	char name[MAX_INDEX_KEY_LENGTH + 1];</a>
<a name="ln1373">	uint16 length;</a>
<a name="ln1374">	ino_t id;</a>
<a name="ln1375">	while (iterator.GetNextEntry(name, &amp;length, MAX_INDEX_KEY_LENGTH + 1,</a>
<a name="ln1376">			&amp;id) == B_OK) {</a>
<a name="ln1377">		if ((Mode() &amp; (S_ATTR_DIR | S_INDEX_DIR)) != 0)</a>
<a name="ln1378">			return false;</a>
<a name="ln1379"> </a>
<a name="ln1380">		// Unlike index and attribute directories, directories</a>
<a name="ln1381">		// for standard files always contain &quot;.&quot;, and &quot;..&quot;, so</a>
<a name="ln1382">		// we need to ignore those two</a>
<a name="ln1383">		if (++count &gt; 2 || (strcmp(&quot;.&quot;, name) != 0 &amp;&amp; strcmp(&quot;..&quot;, name) != 0))</a>
<a name="ln1384">			return false;</a>
<a name="ln1385">	}</a>
<a name="ln1386">	return true;</a>
<a name="ln1387">}</a>
<a name="ln1388"> </a>
<a name="ln1389"> </a>
<a name="ln1390">status_t</a>
<a name="ln1391">Inode::ContainerContentsChanged(Transaction&amp; transaction)</a>
<a name="ln1392">{</a>
<a name="ln1393">	ASSERT(!InLastModifiedIndex());</a>
<a name="ln1394"> </a>
<a name="ln1395">	Node().last_modified_time = Node().status_change_time</a>
<a name="ln1396">		= HOST_ENDIAN_TO_BFS_INT64(bfs_inode::ToInode(real_time_clock_usecs()));</a>
<a name="ln1397"> </a>
<a name="ln1398">	return WriteBack(transaction);</a>
<a name="ln1399">}</a>
<a name="ln1400"> </a>
<a name="ln1401"> </a>
<a name="ln1402">//	#pragma mark - data stream</a>
<a name="ln1403"> </a>
<a name="ln1404"> </a>
<a name="ln1405">/*!	Computes the number of bytes this inode occupies in the file system.</a>
<a name="ln1406">	This includes the file meta blocks used for maintaining its data stream.</a>
<a name="ln1407"> </a>
<a name="ln1408">	TODO: However, the attributes in extra files are not really accounted for;</a>
<a name="ln1409">	depending on the speed penalty, this should be changed, though (the value</a>
<a name="ln1410">	could be cached in the inode structure or Inode object, though).</a>
<a name="ln1411">*/</a>
<a name="ln1412">off_t</a>
<a name="ln1413">Inode::AllocatedSize() const</a>
<a name="ln1414">{</a>
<a name="ln1415">	if (IsSymLink() &amp;&amp; (Flags() &amp; INODE_LONG_SYMLINK) == 0) {</a>
<a name="ln1416">		// This symlink does not have a data stream</a>
<a name="ln1417">		return Node().InodeSize();</a>
<a name="ln1418">	}</a>
<a name="ln1419"> </a>
<a name="ln1420">	const data_stream&amp; data = Node().data;</a>
<a name="ln1421">	uint32 blockSize = fVolume-&gt;BlockSize();</a>
<a name="ln1422">	off_t size = blockSize;</a>
<a name="ln1423"> </a>
<a name="ln1424">	if (data.MaxDoubleIndirectRange() != 0) {</a>
<a name="ln1425">		off_t doubleIndirectSize = data.MaxDoubleIndirectRange()</a>
<a name="ln1426">			- data.MaxIndirectRange();</a>
<a name="ln1427">		int32 indirectSize = double_indirect_max_indirect_size(</a>
<a name="ln1428">			data.double_indirect.Length(), fVolume-&gt;BlockSize());</a>
<a name="ln1429"> </a>
<a name="ln1430">		size += (2 * data.double_indirect.Length()</a>
<a name="ln1431">				+ doubleIndirectSize / indirectSize)</a>
<a name="ln1432">			* blockSize + data.MaxDoubleIndirectRange();</a>
<a name="ln1433">	} else if (data.MaxIndirectRange() != 0)</a>
<a name="ln1434">		size += data.indirect.Length() + data.MaxIndirectRange();</a>
<a name="ln1435">	else</a>
<a name="ln1436">		size += data.MaxDirectRange();</a>
<a name="ln1437"> </a>
<a name="ln1438">	if (!Node().attributes.IsZero()) {</a>
<a name="ln1439">		// TODO: to make this exact, we'd had to count all attributes</a>
<a name="ln1440">		size += 2 * blockSize;</a>
<a name="ln1441">			// 2 blocks, one for the attributes inode, one for its B+tree</a>
<a name="ln1442">	}</a>
<a name="ln1443"> </a>
<a name="ln1444">	return size;</a>
<a name="ln1445">}</a>
<a name="ln1446"> </a>
<a name="ln1447"> </a>
<a name="ln1448">/*!	Finds the block_run where &quot;pos&quot; is located in the data_stream of</a>
<a name="ln1449">	the inode.</a>
<a name="ln1450">	If successful, &quot;offset&quot; will then be set to the file offset</a>
<a name="ln1451">	of the block_run returned; so &quot;pos - offset&quot; is for the block_run</a>
<a name="ln1452">	what &quot;pos&quot; is for the whole stream.</a>
<a name="ln1453">	The caller has to make sure that &quot;pos&quot; is inside the stream.</a>
<a name="ln1454">*/</a>
<a name="ln1455">status_t</a>
<a name="ln1456">Inode::FindBlockRun(off_t pos, block_run&amp; run, off_t&amp; offset)</a>
<a name="ln1457">{</a>
<a name="ln1458">	data_stream* data = &amp;Node().data;</a>
<a name="ln1459"> </a>
<a name="ln1460">	// find matching block run</a>
<a name="ln1461"> </a>
<a name="ln1462">	if (data-&gt;MaxIndirectRange() &gt; 0 &amp;&amp; pos &gt;= data-&gt;MaxDirectRange()) {</a>
<a name="ln1463">		if (data-&gt;MaxDoubleIndirectRange() &gt; 0</a>
<a name="ln1464">			&amp;&amp; pos &gt;= data-&gt;MaxIndirectRange()) {</a>
<a name="ln1465">			// access to double indirect blocks</a>
<a name="ln1466"> </a>
<a name="ln1467">			CachedBlock cached(fVolume);</a>
<a name="ln1468"> </a>
<a name="ln1469">			int32 runsPerBlock;</a>
<a name="ln1470">			int32 directSize;</a>
<a name="ln1471">			int32 indirectSize;</a>
<a name="ln1472">			get_double_indirect_sizes(data-&gt;double_indirect.Length(),</a>
<a name="ln1473">				fVolume-&gt;BlockSize(), runsPerBlock, directSize, indirectSize);</a>
<a name="ln1474">			if (directSize &lt;= 0 || indirectSize &lt;= 0)</a>
<a name="ln1475">				RETURN_ERROR(B_BAD_DATA);</a>
<a name="ln1476"> </a>
<a name="ln1477">			off_t start = pos - data-&gt;MaxIndirectRange();</a>
<a name="ln1478">			int32 index = start / indirectSize;</a>
<a name="ln1479"> </a>
<a name="ln1480">			block_run* indirect = (block_run*)cached.SetTo(</a>
<a name="ln1481">				fVolume-&gt;ToBlock(data-&gt;double_indirect) + index / runsPerBlock);</a>
<a name="ln1482">			if (indirect == NULL)</a>
<a name="ln1483">				RETURN_ERROR(B_ERROR);</a>
<a name="ln1484"> </a>
<a name="ln1485">			int32 current = (start % indirectSize) / directSize;</a>
<a name="ln1486"> </a>
<a name="ln1487">			indirect = (block_run*)cached.SetTo(</a>
<a name="ln1488">				fVolume-&gt;ToBlock(indirect[index % runsPerBlock])</a>
<a name="ln1489">				+ current / runsPerBlock);</a>
<a name="ln1490">			if (indirect == NULL)</a>
<a name="ln1491">				RETURN_ERROR(B_ERROR);</a>
<a name="ln1492"> </a>
<a name="ln1493">			run = indirect[current % runsPerBlock];</a>
<a name="ln1494">			if (run.Length() != data-&gt;double_indirect.Length())</a>
<a name="ln1495">				RETURN_ERROR(B_BAD_DATA);</a>
<a name="ln1496"> </a>
<a name="ln1497">			offset = data-&gt;MaxIndirectRange() + (index * indirectSize)</a>
<a name="ln1498">				+ (current * directSize);</a>
<a name="ln1499">		} else {</a>
<a name="ln1500">			// access to indirect blocks</a>
<a name="ln1501"> </a>
<a name="ln1502">			int32 runsPerBlock = fVolume-&gt;BlockSize() / sizeof(block_run);</a>
<a name="ln1503">			off_t runBlockEnd = data-&gt;MaxDirectRange();</a>
<a name="ln1504"> </a>
<a name="ln1505">			CachedBlock cached(fVolume);</a>
<a name="ln1506">			off_t block = fVolume-&gt;ToBlock(data-&gt;indirect);</a>
<a name="ln1507"> </a>
<a name="ln1508">			for (int32 i = 0; i &lt; data-&gt;indirect.Length(); i++) {</a>
<a name="ln1509">				block_run* indirect = (block_run*)cached.SetTo(block + i);</a>
<a name="ln1510">				if (indirect == NULL)</a>
<a name="ln1511">					RETURN_ERROR(B_IO_ERROR);</a>
<a name="ln1512"> </a>
<a name="ln1513">				int32 current = -1;</a>
<a name="ln1514">				while (++current &lt; runsPerBlock) {</a>
<a name="ln1515">					if (indirect[current].IsZero())</a>
<a name="ln1516">						break;</a>
<a name="ln1517"> </a>
<a name="ln1518">					runBlockEnd += (uint32)indirect[current].Length()</a>
<a name="ln1519">						&lt;&lt; cached.BlockShift();</a>
<a name="ln1520">					if (runBlockEnd &gt; pos) {</a>
<a name="ln1521">						run = indirect[current];</a>
<a name="ln1522">						offset = runBlockEnd - ((uint32)run.Length()</a>
<a name="ln1523">							&lt;&lt; cached.BlockShift());</a>
<a name="ln1524">						return fVolume-&gt;ValidateBlockRun(run);</a>
<a name="ln1525">					}</a>
<a name="ln1526">				}</a>
<a name="ln1527">			}</a>
<a name="ln1528">			RETURN_ERROR(B_ERROR);</a>
<a name="ln1529">		}</a>
<a name="ln1530">	} else {</a>
<a name="ln1531">		// access from direct blocks</a>
<a name="ln1532"> </a>
<a name="ln1533">		off_t runBlockEnd = 0LL;</a>
<a name="ln1534">		int32 current = -1;</a>
<a name="ln1535"> </a>
<a name="ln1536">		while (++current &lt; NUM_DIRECT_BLOCKS) {</a>
<a name="ln1537">			if (data-&gt;direct[current].IsZero())</a>
<a name="ln1538">				break;</a>
<a name="ln1539"> </a>
<a name="ln1540">			runBlockEnd += (uint32)data-&gt;direct[current].Length()</a>
<a name="ln1541">				&lt;&lt; fVolume-&gt;BlockShift();</a>
<a name="ln1542">			if (runBlockEnd &gt; pos) {</a>
<a name="ln1543">				run = data-&gt;direct[current];</a>
<a name="ln1544">				offset = runBlockEnd</a>
<a name="ln1545">					- ((uint32)run.Length() &lt;&lt; fVolume-&gt;BlockShift());</a>
<a name="ln1546">				return fVolume-&gt;ValidateBlockRun(run);</a>
<a name="ln1547">			}</a>
<a name="ln1548">		}</a>
<a name="ln1549"> </a>
<a name="ln1550">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln1551">	}</a>
<a name="ln1552">	return fVolume-&gt;ValidateBlockRun(run);</a>
<a name="ln1553">}</a>
<a name="ln1554"> </a>
<a name="ln1555"> </a>
<a name="ln1556">status_t</a>
<a name="ln1557">Inode::ReadAt(off_t pos, uint8* buffer, size_t* _length)</a>
<a name="ln1558">{</a>
<a name="ln1559">	return file_cache_read(FileCache(), NULL, pos, buffer, _length);</a>
<a name="ln1560">}</a>
<a name="ln1561"> </a>
<a name="ln1562"> </a>
<a name="ln1563">status_t</a>
<a name="ln1564">Inode::WriteAt(Transaction&amp; transaction, off_t pos, const uint8* buffer,</a>
<a name="ln1565">	size_t* _length)</a>
<a name="ln1566">{</a>
<a name="ln1567">	InodeReadLocker locker(this);</a>
<a name="ln1568"> </a>
<a name="ln1569">	// update the last modification time in memory, it will be written</a>
<a name="ln1570">	// back to the inode, and the index when the file is closed</a>
<a name="ln1571">	// TODO: should update the internal last modified time only at this point!</a>
<a name="ln1572">	Node().last_modified_time = Node().status_change_time</a>
<a name="ln1573">		= HOST_ENDIAN_TO_BFS_INT64(bfs_inode::ToInode(real_time_clock_usecs()));</a>
<a name="ln1574"> </a>
<a name="ln1575">	// TODO: support INODE_LOGGED!</a>
<a name="ln1576"> </a>
<a name="ln1577">	size_t length = *_length;</a>
<a name="ln1578">	bool changeSize = (uint64)pos + (uint64)length &gt; (uint64)Size();</a>
<a name="ln1579"> </a>
<a name="ln1580">	// set/check boundaries for pos/length</a>
<a name="ln1581">	if (pos &lt; 0)</a>
<a name="ln1582">		return B_BAD_VALUE;</a>
<a name="ln1583"> </a>
<a name="ln1584">	locker.Unlock();</a>
<a name="ln1585"> </a>
<a name="ln1586">	// the transaction doesn't have to be started already</a>
<a name="ln1587">	if (changeSize &amp;&amp; !transaction.IsStarted())</a>
<a name="ln1588">		transaction.Start(fVolume, BlockNumber());</a>
<a name="ln1589"> </a>
<a name="ln1590">	WriteLocker writeLocker(fLock);</a>
<a name="ln1591"> </a>
<a name="ln1592">	// Work around possible race condition: Someone might have shrunken the file</a>
<a name="ln1593">	// while we had no lock.</a>
<a name="ln1594">	if (!transaction.IsStarted()</a>
<a name="ln1595">		&amp;&amp; (uint64)pos + (uint64)length &gt; (uint64)Size()) {</a>
<a name="ln1596">		writeLocker.Unlock();</a>
<a name="ln1597">		transaction.Start(fVolume, BlockNumber());</a>
<a name="ln1598">		writeLocker.Lock();</a>
<a name="ln1599">	}</a>
<a name="ln1600"> </a>
<a name="ln1601">	off_t oldSize = Size();</a>
<a name="ln1602"> </a>
<a name="ln1603">	if ((uint64)pos + (uint64)length &gt; (uint64)oldSize) {</a>
<a name="ln1604">		// let's grow the data stream to the size needed</a>
<a name="ln1605">		status_t status = SetFileSize(transaction, pos + length);</a>
<a name="ln1606">		if (status != B_OK) {</a>
<a name="ln1607">			*_length = 0;</a>
<a name="ln1608">			WriteLockInTransaction(transaction);</a>
<a name="ln1609">			RETURN_ERROR(status);</a>
<a name="ln1610">		}</a>
<a name="ln1611">		// TODO: In theory we would need to update the file size</a>
<a name="ln1612">		// index here as part of the current transaction - this might just</a>
<a name="ln1613">		// be a bit too expensive, but worth a try.</a>
<a name="ln1614"> </a>
<a name="ln1615">		// we need to write back the inode here because it has to</a>
<a name="ln1616">		// go into this transaction (we cannot wait until the file</a>
<a name="ln1617">		// is closed)</a>
<a name="ln1618">		status = WriteBack(transaction);</a>
<a name="ln1619">		if (status != B_OK) {</a>
<a name="ln1620">			WriteLockInTransaction(transaction);</a>
<a name="ln1621">			return status;</a>
<a name="ln1622">		}</a>
<a name="ln1623">	}</a>
<a name="ln1624"> </a>
<a name="ln1625">	writeLocker.Unlock();</a>
<a name="ln1626"> </a>
<a name="ln1627">	if (oldSize &lt; pos)</a>
<a name="ln1628">		FillGapWithZeros(oldSize, pos);</a>
<a name="ln1629"> </a>
<a name="ln1630">	// If we don't want to write anything, we can now return (we may</a>
<a name="ln1631">	// just have changed the file size using the position parameter)</a>
<a name="ln1632">	if (length == 0)</a>
<a name="ln1633">		return B_OK;</a>
<a name="ln1634"> </a>
<a name="ln1635">	status_t status = file_cache_write(FileCache(), NULL, pos, buffer, _length);</a>
<a name="ln1636"> </a>
<a name="ln1637">	if (transaction.IsStarted())</a>
<a name="ln1638">		WriteLockInTransaction(transaction);</a>
<a name="ln1639"> </a>
<a name="ln1640">	return status;</a>
<a name="ln1641">}</a>
<a name="ln1642"> </a>
<a name="ln1643"> </a>
<a name="ln1644">/*!	Fills the gap between the old file size and the new file size</a>
<a name="ln1645">	with zeros.</a>
<a name="ln1646">	It's more or less a copy of Inode::WriteAt() but it can handle</a>
<a name="ln1647">	length differences of more than just 4 GB, and it never uses</a>
<a name="ln1648">	the log, even if the INODE_LOGGED flag is set.</a>
<a name="ln1649">*/</a>
<a name="ln1650">status_t</a>
<a name="ln1651">Inode::FillGapWithZeros(off_t pos, off_t newSize)</a>
<a name="ln1652">{</a>
<a name="ln1653">	while (pos &lt; newSize) {</a>
<a name="ln1654">		size_t size;</a>
<a name="ln1655">		if (newSize &gt; pos + 1024 * 1024 * 1024)</a>
<a name="ln1656">			size = 1024 * 1024 * 1024;</a>
<a name="ln1657">		else</a>
<a name="ln1658">			size = newSize - pos;</a>
<a name="ln1659"> </a>
<a name="ln1660">		status_t status = file_cache_write(FileCache(), NULL, pos, NULL, &amp;size);</a>
<a name="ln1661">		if (status &lt; B_OK)</a>
<a name="ln1662">			return status;</a>
<a name="ln1663"> </a>
<a name="ln1664">		pos += size;</a>
<a name="ln1665">	}</a>
<a name="ln1666"> </a>
<a name="ln1667">	return B_OK;</a>
<a name="ln1668">}</a>
<a name="ln1669"> </a>
<a name="ln1670"> </a>
<a name="ln1671">/*!	Allocates \a length blocks, and clears their contents. Growing</a>
<a name="ln1672">	the indirect and double indirect range uses this method.</a>
<a name="ln1673">	The allocated block_run is saved in &quot;run&quot;</a>
<a name="ln1674">*/</a>
<a name="ln1675">status_t</a>
<a name="ln1676">Inode::_AllocateBlockArray(Transaction&amp; transaction, block_run&amp; run,</a>
<a name="ln1677">	size_t length, bool variableSize)</a>
<a name="ln1678">{</a>
<a name="ln1679">	if (!run.IsZero())</a>
<a name="ln1680">		return B_BAD_VALUE;</a>
<a name="ln1681"> </a>
<a name="ln1682">	status_t status = fVolume-&gt;Allocate(transaction, this, length, run,</a>
<a name="ln1683">		variableSize ? 1 : length);</a>
<a name="ln1684">	if (status != B_OK)</a>
<a name="ln1685">		return status;</a>
<a name="ln1686"> </a>
<a name="ln1687">	// make sure those blocks are empty</a>
<a name="ln1688">	CachedBlock cached(fVolume);</a>
<a name="ln1689">	off_t block = fVolume-&gt;ToBlock(run);</a>
<a name="ln1690"> </a>
<a name="ln1691">	for (int32 i = 0; i &lt; run.Length(); i++) {</a>
<a name="ln1692">		block_run* runs = (block_run*)cached.SetToWritable(transaction,</a>
<a name="ln1693">			block + i, true);</a>
<a name="ln1694">		if (runs == NULL)</a>
<a name="ln1695">			return B_IO_ERROR;</a>
<a name="ln1696">	}</a>
<a name="ln1697">	return B_OK;</a>
<a name="ln1698">}</a>
<a name="ln1699"> </a>
<a name="ln1700"> </a>
<a name="ln1701">/*!	Grows the stream to \a size, and fills the direct/indirect/double indirect</a>
<a name="ln1702">	ranges with the runs.</a>
<a name="ln1703">	This method will also determine the size of the preallocation, if any.</a>
<a name="ln1704">*/</a>
<a name="ln1705">status_t</a>
<a name="ln1706">Inode::_GrowStream(Transaction&amp; transaction, off_t size)</a>
<a name="ln1707">{</a>
<a name="ln1708">	data_stream* data = &amp;Node().data;</a>
<a name="ln1709"> </a>
<a name="ln1710">	// is the data stream already large enough to hold the new size?</a>
<a name="ln1711">	// (can be the case with preallocated blocks)</a>
<a name="ln1712">	if (size &lt; data-&gt;MaxDirectRange()</a>
<a name="ln1713">		|| size &lt; data-&gt;MaxIndirectRange()</a>
<a name="ln1714">		|| size &lt; data-&gt;MaxDoubleIndirectRange()) {</a>
<a name="ln1715">		data-&gt;size = HOST_ENDIAN_TO_BFS_INT64(size);</a>
<a name="ln1716">		return B_OK;</a>
<a name="ln1717">	}</a>
<a name="ln1718"> </a>
<a name="ln1719">	// how many bytes are still needed? (unused ranges are always zero)</a>
<a name="ln1720">	uint16 minimum = 1;</a>
<a name="ln1721">	off_t bytes;</a>
<a name="ln1722">	if (data-&gt;Size() &lt; data-&gt;MaxDoubleIndirectRange()) {</a>
<a name="ln1723">		bytes = size - data-&gt;MaxDoubleIndirectRange();</a>
<a name="ln1724">		// The double indirect range can only handle multiples of</a>
<a name="ln1725">		// its base length</a>
<a name="ln1726">		minimum = data-&gt;double_indirect.Length();</a>
<a name="ln1727">	} else if (data-&gt;Size() &lt; data-&gt;MaxIndirectRange())</a>
<a name="ln1728">		bytes = size - data-&gt;MaxIndirectRange();</a>
<a name="ln1729">	else if (data-&gt;Size() &lt; data-&gt;MaxDirectRange())</a>
<a name="ln1730">		bytes = size - data-&gt;MaxDirectRange();</a>
<a name="ln1731">	else {</a>
<a name="ln1732">		// no preallocation left to be used</a>
<a name="ln1733">		bytes = size - data-&gt;Size();</a>
<a name="ln1734">		if (data-&gt;MaxDoubleIndirectRange() &gt; 0)</a>
<a name="ln1735">			minimum = data-&gt;double_indirect.Length();</a>
<a name="ln1736">	}</a>
<a name="ln1737"> </a>
<a name="ln1738">	// do we have enough free blocks on the disk?</a>
<a name="ln1739">	off_t blocksNeeded = (bytes + fVolume-&gt;BlockSize() - 1)</a>
<a name="ln1740">		&gt;&gt; fVolume-&gt;BlockShift();</a>
<a name="ln1741">	if (blocksNeeded &gt; fVolume-&gt;FreeBlocks())</a>
<a name="ln1742">		return B_DEVICE_FULL;</a>
<a name="ln1743"> </a>
<a name="ln1744">	off_t blocksRequested = blocksNeeded;</a>
<a name="ln1745">		// because of preallocations and partial allocations, the number of</a>
<a name="ln1746">		// blocks we need to allocate may be different from the one we request</a>
<a name="ln1747">		// from the block allocator</a>
<a name="ln1748"> </a>
<a name="ln1749">	// Should we preallocate some blocks?</a>
<a name="ln1750">	// Attributes, attribute directories, and long symlinks usually won't get</a>
<a name="ln1751">	// that big, and should stay close to the inode - preallocating could be</a>
<a name="ln1752">	// counterproductive.</a>
<a name="ln1753">	// Also, if free disk space is tight, don't preallocate.</a>
<a name="ln1754">	if (!IsAttribute() &amp;&amp; !IsAttributeDirectory() &amp;&amp; !IsSymLink()</a>
<a name="ln1755">		&amp;&amp; fVolume-&gt;FreeBlocks() &gt; 128) {</a>
<a name="ln1756">		off_t roundTo = 0;</a>
<a name="ln1757">		if (IsFile()) {</a>
<a name="ln1758">			// Request preallocated blocks depending on the file size and growth</a>
<a name="ln1759">			if (size &lt; 1 * 1024 * 1024 &amp;&amp; bytes &lt; 512 * 1024) {</a>
<a name="ln1760">				// Preallocate 64 KB for file sizes &lt;1 MB and grow rates &lt;512 KB</a>
<a name="ln1761">				roundTo = 65536 &gt;&gt; fVolume-&gt;BlockShift();</a>
<a name="ln1762">			} else if (size &lt; 32 * 1024 * 1024 &amp;&amp; bytes &lt;= 1 * 1024 * 1024) {</a>
<a name="ln1763">				// Preallocate 512 KB for file sizes between 1 MB and 32 MB, and</a>
<a name="ln1764">				// grow rates smaller than 1 MB</a>
<a name="ln1765">				roundTo = (512 * 1024) &gt;&gt; fVolume-&gt;BlockShift();</a>
<a name="ln1766">			} else {</a>
<a name="ln1767">				// Preallocate 1/16 of the file size (ie. 4 MB for 64 MB,</a>
<a name="ln1768">				// 64 MB for 1 GB)</a>
<a name="ln1769">				roundTo = size &gt;&gt; (fVolume-&gt;BlockShift() + 4);</a>
<a name="ln1770">			}</a>
<a name="ln1771">		} else if (IsIndex()) {</a>
<a name="ln1772">			// Always preallocate 64 KB for index directories</a>
<a name="ln1773">			roundTo = 65536 &gt;&gt; fVolume-&gt;BlockShift();</a>
<a name="ln1774">		} else {</a>
<a name="ln1775">			// Preallocate only 4 KB - directories only get trimmed when their</a>
<a name="ln1776">			// vnode is flushed, which might not happen very often.</a>
<a name="ln1777">			roundTo = 4096 &gt;&gt; fVolume-&gt;BlockShift();</a>
<a name="ln1778">		}</a>
<a name="ln1779">		if (roundTo &gt; 1) {</a>
<a name="ln1780">			// Round to next &quot;roundTo&quot; block count</a>
<a name="ln1781">			blocksRequested = ((blocksNeeded + roundTo) / roundTo) * roundTo;</a>
<a name="ln1782">		}</a>
<a name="ln1783">	}</a>
<a name="ln1784"> </a>
<a name="ln1785">	while (blocksNeeded &gt; 0) {</a>
<a name="ln1786">		// the requested blocks do not need to be returned with a</a>
<a name="ln1787">		// single allocation, so we need to iterate until we have</a>
<a name="ln1788">		// enough blocks allocated</a>
<a name="ln1789">		if (minimum &gt; 1) {</a>
<a name="ln1790">			// make sure that &quot;blocks&quot; is a multiple of minimum</a>
<a name="ln1791">			blocksRequested = round_up(blocksRequested, minimum);</a>
<a name="ln1792">		}</a>
<a name="ln1793"> </a>
<a name="ln1794">		block_run run;</a>
<a name="ln1795">		status_t status = fVolume-&gt;Allocate(transaction, this, blocksRequested,</a>
<a name="ln1796">			run, minimum);</a>
<a name="ln1797">		if (status != B_OK)</a>
<a name="ln1798">			return status;</a>
<a name="ln1799"> </a>
<a name="ln1800">		// okay, we have the needed blocks, so just distribute them to the</a>
<a name="ln1801">		// different ranges of the stream (direct, indirect &amp; double indirect)</a>
<a name="ln1802"> </a>
<a name="ln1803">		blocksNeeded -= run.Length();</a>
<a name="ln1804">		// don't preallocate if the first allocation was already too small</a>
<a name="ln1805">		blocksRequested = blocksNeeded;</a>
<a name="ln1806"> </a>
<a name="ln1807">		// Direct block range</a>
<a name="ln1808"> </a>
<a name="ln1809">		if (data-&gt;Size() &lt;= data-&gt;MaxDirectRange()) {</a>
<a name="ln1810">			// let's try to put them into the direct block range</a>
<a name="ln1811">			int32 free = 0;</a>
<a name="ln1812">			for (; free &lt; NUM_DIRECT_BLOCKS; free++) {</a>
<a name="ln1813">				if (data-&gt;direct[free].IsZero())</a>
<a name="ln1814">					break;</a>
<a name="ln1815">			}</a>
<a name="ln1816"> </a>
<a name="ln1817">			if (free &lt; NUM_DIRECT_BLOCKS) {</a>
<a name="ln1818">				// can we merge the last allocated run with the new one?</a>
<a name="ln1819">				int32 last = free - 1;</a>
<a name="ln1820">				if (free &gt; 0 &amp;&amp; data-&gt;direct[last].MergeableWith(run)) {</a>
<a name="ln1821">					data-&gt;direct[last].length = HOST_ENDIAN_TO_BFS_INT16(</a>
<a name="ln1822">						data-&gt;direct[last].Length() + run.Length());</a>
<a name="ln1823">				} else</a>
<a name="ln1824">					data-&gt;direct[free] = run;</a>
<a name="ln1825"> </a>
<a name="ln1826">				data-&gt;max_direct_range = HOST_ENDIAN_TO_BFS_INT64(</a>
<a name="ln1827">					data-&gt;MaxDirectRange()</a>
<a name="ln1828">					+ run.Length() * fVolume-&gt;BlockSize());</a>
<a name="ln1829">				data-&gt;size = HOST_ENDIAN_TO_BFS_INT64(blocksNeeded &gt; 0</a>
<a name="ln1830">					? data-&gt;max_direct_range : size);</a>
<a name="ln1831">				continue;</a>
<a name="ln1832">			}</a>
<a name="ln1833">		}</a>
<a name="ln1834"> </a>
<a name="ln1835">		// Indirect block range</a>
<a name="ln1836"> </a>
<a name="ln1837">		if (data-&gt;Size() &lt;= data-&gt;MaxIndirectRange()</a>
<a name="ln1838">			|| !data-&gt;MaxIndirectRange()) {</a>
<a name="ln1839">			CachedBlock cached(fVolume);</a>
<a name="ln1840">			block_run* runs = NULL;</a>
<a name="ln1841">			uint32 free = 0;</a>
<a name="ln1842">			off_t block;</a>
<a name="ln1843"> </a>
<a name="ln1844">			// if there is no indirect block yet, create one</a>
<a name="ln1845">			if (data-&gt;indirect.IsZero()) {</a>
<a name="ln1846">				status = _AllocateBlockArray(transaction, data-&gt;indirect,</a>
<a name="ln1847">					NUM_ARRAY_BLOCKS, true);</a>
<a name="ln1848">				if (status != B_OK)</a>
<a name="ln1849">					return status;</a>
<a name="ln1850"> </a>
<a name="ln1851">				data-&gt;max_indirect_range = HOST_ENDIAN_TO_BFS_INT64(</a>
<a name="ln1852">					data-&gt;MaxDirectRange());</a>
<a name="ln1853">				// insert the block_run in the first block</a>
<a name="ln1854">				runs = (block_run*)cached.SetTo(data-&gt;indirect);</a>
<a name="ln1855">			} else {</a>
<a name="ln1856">				uint32 numberOfRuns = fVolume-&gt;BlockSize() / sizeof(block_run);</a>
<a name="ln1857">				block = fVolume-&gt;ToBlock(data-&gt;indirect);</a>
<a name="ln1858"> </a>
<a name="ln1859">				// search first empty entry</a>
<a name="ln1860">				int32 i = 0;</a>
<a name="ln1861">				for (; i &lt; data-&gt;indirect.Length(); i++) {</a>
<a name="ln1862">					if ((runs = (block_run*)cached.SetTo(block + i)) == NULL)</a>
<a name="ln1863">						return B_IO_ERROR;</a>
<a name="ln1864"> </a>
<a name="ln1865">					for (free = 0; free &lt; numberOfRuns; free++)</a>
<a name="ln1866">						if (runs[free].IsZero())</a>
<a name="ln1867">							break;</a>
<a name="ln1868"> </a>
<a name="ln1869">					if (free &lt; numberOfRuns)</a>
<a name="ln1870">						break;</a>
<a name="ln1871">				}</a>
<a name="ln1872">				if (i == data-&gt;indirect.Length())</a>
<a name="ln1873">					runs = NULL;</a>
<a name="ln1874">			}</a>
<a name="ln1875"> </a>
<a name="ln1876">			if (runs != NULL) {</a>
<a name="ln1877">				// try to insert the run to the last one - note that this</a>
<a name="ln1878">				// doesn't take block borders into account, so it could be</a>
<a name="ln1879">				// further optimized</a>
<a name="ln1880">				cached.MakeWritable(transaction);</a>
<a name="ln1881"> </a>
<a name="ln1882">				int32 last = free - 1;</a>
<a name="ln1883">				if (free &gt; 0 &amp;&amp; runs[last].MergeableWith(run)) {</a>
<a name="ln1884">					runs[last].length = HOST_ENDIAN_TO_BFS_INT16(</a>
<a name="ln1885">						runs[last].Length() + run.Length());</a>
<a name="ln1886">				} else</a>
<a name="ln1887">					runs[free] = run;</a>
<a name="ln1888"> </a>
<a name="ln1889">				data-&gt;max_indirect_range = HOST_ENDIAN_TO_BFS_INT64(</a>
<a name="ln1890">					data-&gt;MaxIndirectRange()</a>
<a name="ln1891">					+ ((uint32)run.Length() &lt;&lt; fVolume-&gt;BlockShift()));</a>
<a name="ln1892">				data-&gt;size = HOST_ENDIAN_TO_BFS_INT64(blocksNeeded &gt; 0</a>
<a name="ln1893">					? data-&gt;MaxIndirectRange() : size);</a>
<a name="ln1894">				continue;</a>
<a name="ln1895">			}</a>
<a name="ln1896">		}</a>
<a name="ln1897"> </a>
<a name="ln1898">		// Double indirect block range</a>
<a name="ln1899"> </a>
<a name="ln1900">		if (data-&gt;Size() &lt;= data-&gt;MaxDoubleIndirectRange()</a>
<a name="ln1901">			|| !data-&gt;max_double_indirect_range) {</a>
<a name="ln1902">			// We make sure here that we have this minimum allocated, so if</a>
<a name="ln1903">			// the allocation succeeds, we don't run into an endless loop.</a>
<a name="ln1904">			if (!data-&gt;max_double_indirect_range)</a>
<a name="ln1905">				minimum = _DoubleIndirectBlockLength();</a>
<a name="ln1906">			else</a>
<a name="ln1907">				minimum = data-&gt;double_indirect.Length();</a>
<a name="ln1908"> </a>
<a name="ln1909">			if ((run.Length() % minimum) != 0) {</a>
<a name="ln1910">				// The number of allocated blocks isn't a multiple of 'minimum',</a>
<a name="ln1911">				// so we have to change this. This can happen the first time the</a>
<a name="ln1912">				// stream grows into the double indirect range.</a>
<a name="ln1913">				// First, free the remaining blocks that don't fit into this</a>
<a name="ln1914">				// multiple.</a>
<a name="ln1915">				int32 rest = run.Length() % minimum;</a>
<a name="ln1916">				run.length = HOST_ENDIAN_TO_BFS_INT16(run.Length() - rest);</a>
<a name="ln1917"> </a>
<a name="ln1918">				status = fVolume-&gt;Free(transaction,</a>
<a name="ln1919">					block_run::Run(run.AllocationGroup(),</a>
<a name="ln1920">					run.Start() + run.Length(), rest));</a>
<a name="ln1921">				if (status != B_OK)</a>
<a name="ln1922">					return status;</a>
<a name="ln1923"> </a>
<a name="ln1924">				blocksNeeded += rest;</a>
<a name="ln1925">				blocksRequested = round_up(blocksNeeded, minimum);</a>
<a name="ln1926"> </a>
<a name="ln1927">				// Are there any blocks left in the run? If not, allocate</a>
<a name="ln1928">				// a new one</a>
<a name="ln1929">				if (run.length == 0)</a>
<a name="ln1930">					continue;</a>
<a name="ln1931">			}</a>
<a name="ln1932"> </a>
<a name="ln1933">			// if there is no double indirect block yet, create one</a>
<a name="ln1934">			if (data-&gt;double_indirect.IsZero()) {</a>
<a name="ln1935">				status = _AllocateBlockArray(transaction,</a>
<a name="ln1936">					data-&gt;double_indirect, _DoubleIndirectBlockLength());</a>
<a name="ln1937">				if (status != B_OK)</a>
<a name="ln1938">					return status;</a>
<a name="ln1939"> </a>
<a name="ln1940">				data-&gt;max_double_indirect_range = data-&gt;max_indirect_range;</a>
<a name="ln1941">			}</a>
<a name="ln1942"> </a>
<a name="ln1943">			// calculate the index where to insert the new blocks</a>
<a name="ln1944"> </a>
<a name="ln1945">			int32 runsPerBlock;</a>
<a name="ln1946">			int32 directSize;</a>
<a name="ln1947">			int32 indirectSize;</a>
<a name="ln1948">			get_double_indirect_sizes(data-&gt;double_indirect.Length(),</a>
<a name="ln1949">				fVolume-&gt;BlockSize(), runsPerBlock, directSize, indirectSize);</a>
<a name="ln1950">			if (directSize &lt;= 0 || indirectSize &lt;= 0)</a>
<a name="ln1951">				return B_BAD_DATA;</a>
<a name="ln1952"> </a>
<a name="ln1953">			off_t start = data-&gt;MaxDoubleIndirectRange()</a>
<a name="ln1954">				- data-&gt;MaxIndirectRange();</a>
<a name="ln1955">			int32 indirectIndex = start / indirectSize;</a>
<a name="ln1956">			int32 index = (start % indirectSize) / directSize;</a>
<a name="ln1957">			int32 runsPerArray = runsPerBlock * minimum;</a>
<a name="ln1958"> </a>
<a name="ln1959">			// distribute the blocks to the array and allocate</a>
<a name="ln1960">			// new array blocks when needed</a>
<a name="ln1961"> </a>
<a name="ln1962">			CachedBlock cached(fVolume);</a>
<a name="ln1963">			CachedBlock cachedDirect(fVolume);</a>
<a name="ln1964">			block_run* array = NULL;</a>
<a name="ln1965">			uint32 runLength = run.Length();</a>
<a name="ln1966"> </a>
<a name="ln1967">			while (run.length != 0) {</a>
<a name="ln1968">				// get the indirect array block</a>
<a name="ln1969">				if (array == NULL) {</a>
<a name="ln1970">					uint32 block = indirectIndex / runsPerBlock;</a>
<a name="ln1971">					if (block &gt;= minimum)</a>
<a name="ln1972">						return EFBIG;</a>
<a name="ln1973"> </a>
<a name="ln1974">					array = (block_run*)cached.SetTo(fVolume-&gt;ToBlock(</a>
<a name="ln1975">						data-&gt;double_indirect) + block);</a>
<a name="ln1976">					if (array == NULL)</a>
<a name="ln1977">						return B_IO_ERROR;</a>
<a name="ln1978">				}</a>
<a name="ln1979"> </a>
<a name="ln1980">				do {</a>
<a name="ln1981">					// do we need a new array block?</a>
<a name="ln1982">					if (array[indirectIndex % runsPerBlock].IsZero()) {</a>
<a name="ln1983">						cached.MakeWritable(transaction);</a>
<a name="ln1984"> </a>
<a name="ln1985">						status = _AllocateBlockArray(transaction,</a>
<a name="ln1986">							array[indirectIndex % runsPerBlock],</a>
<a name="ln1987">							data-&gt;double_indirect.Length());</a>
<a name="ln1988">						if (status != B_OK)</a>
<a name="ln1989">							return status;</a>
<a name="ln1990">					}</a>
<a name="ln1991"> </a>
<a name="ln1992">					block_run* runs = (block_run*)cachedDirect.SetToWritable(</a>
<a name="ln1993">						transaction, fVolume-&gt;ToBlock(array[indirectIndex</a>
<a name="ln1994">							% runsPerBlock]) + index / runsPerBlock);</a>
<a name="ln1995">					if (runs == NULL)</a>
<a name="ln1996">						return B_IO_ERROR;</a>
<a name="ln1997"> </a>
<a name="ln1998">					do {</a>
<a name="ln1999">						// insert the block_run into the array</a>
<a name="ln2000">						runs[index % runsPerBlock] = run;</a>
<a name="ln2001">						runs[index % runsPerBlock].length</a>
<a name="ln2002">							= HOST_ENDIAN_TO_BFS_INT16(minimum);</a>
<a name="ln2003"> </a>
<a name="ln2004">						// alter the remaining block_run</a>
<a name="ln2005">						run.start = HOST_ENDIAN_TO_BFS_INT16(run.Start()</a>
<a name="ln2006">							+ minimum);</a>
<a name="ln2007">						run.length = HOST_ENDIAN_TO_BFS_INT16(run.Length()</a>
<a name="ln2008">							- minimum);</a>
<a name="ln2009">					} while ((++index % runsPerBlock) != 0 &amp;&amp; run.length);</a>
<a name="ln2010">				} while ((index % runsPerArray) != 0 &amp;&amp; run.length);</a>
<a name="ln2011"> </a>
<a name="ln2012">				if (index == runsPerArray)</a>
<a name="ln2013">					index = 0;</a>
<a name="ln2014">				if (++indirectIndex % runsPerBlock == 0) {</a>
<a name="ln2015">					array = NULL;</a>
<a name="ln2016">					index = 0;</a>
<a name="ln2017">				}</a>
<a name="ln2018">			}</a>
<a name="ln2019"> </a>
<a name="ln2020">			data-&gt;max_double_indirect_range = HOST_ENDIAN_TO_BFS_INT64(</a>
<a name="ln2021">				data-&gt;MaxDoubleIndirectRange()</a>
<a name="ln2022">				+ (runLength &lt;&lt; fVolume-&gt;BlockShift()));</a>
<a name="ln2023">			data-&gt;size = blocksNeeded &gt; 0 ? HOST_ENDIAN_TO_BFS_INT64(</a>
<a name="ln2024">				data-&gt;max_double_indirect_range) : size;</a>
<a name="ln2025"> </a>
<a name="ln2026">			continue;</a>
<a name="ln2027">		}</a>
<a name="ln2028"> </a>
<a name="ln2029">		RETURN_ERROR(EFBIG);</a>
<a name="ln2030">	}</a>
<a name="ln2031">	// update the size of the data stream</a>
<a name="ln2032">	data-&gt;size = HOST_ENDIAN_TO_BFS_INT64(size);</a>
<a name="ln2033"> </a>
<a name="ln2034">	return B_OK;</a>
<a name="ln2035">}</a>
<a name="ln2036"> </a>
<a name="ln2037"> </a>
<a name="ln2038">size_t</a>
<a name="ln2039">Inode::_DoubleIndirectBlockLength() const</a>
<a name="ln2040">{</a>
<a name="ln2041">	if (fVolume-&gt;BlockSize() &gt; DOUBLE_INDIRECT_ARRAY_SIZE)</a>
<a name="ln2042">		return 1;</a>
<a name="ln2043"> </a>
<a name="ln2044">	return DOUBLE_INDIRECT_ARRAY_SIZE / fVolume-&gt;BlockSize();</a>
<a name="ln2045">}</a>
<a name="ln2046"> </a>
<a name="ln2047"> </a>
<a name="ln2048">/*!	Frees the statically sized array of the double indirect part of a data</a>
<a name="ln2049">	stream.</a>
<a name="ln2050">*/</a>
<a name="ln2051">status_t</a>
<a name="ln2052">Inode::_FreeStaticStreamArray(Transaction&amp; transaction, int32 level,</a>
<a name="ln2053">	block_run run, off_t size, off_t offset, off_t&amp; max)</a>
<a name="ln2054">{</a>
<a name="ln2055">	int32 indirectSize;</a>
<a name="ln2056">	if (level == 0) {</a>
<a name="ln2057">		indirectSize = double_indirect_max_indirect_size(run.Length(),</a>
<a name="ln2058">			fVolume-&gt;BlockSize());</a>
<a name="ln2059">	} else {</a>
<a name="ln2060">		indirectSize = double_indirect_max_direct_size(run.Length(),</a>
<a name="ln2061">			fVolume-&gt;BlockSize());</a>
<a name="ln2062">	}</a>
<a name="ln2063">	if (indirectSize &lt;= 0)</a>
<a name="ln2064">		return B_BAD_DATA;</a>
<a name="ln2065"> </a>
<a name="ln2066">	off_t start;</a>
<a name="ln2067">	if (size &gt; offset)</a>
<a name="ln2068">		start = size - offset;</a>
<a name="ln2069">	else</a>
<a name="ln2070">		start = 0;</a>
<a name="ln2071"> </a>
<a name="ln2072">	int32 index = start / indirectSize;</a>
<a name="ln2073">	int32 runsPerBlock = fVolume-&gt;BlockSize() / sizeof(block_run);</a>
<a name="ln2074"> </a>
<a name="ln2075">	CachedBlock cached(fVolume);</a>
<a name="ln2076">	off_t blockNumber = fVolume-&gt;ToBlock(run);</a>
<a name="ln2077"> </a>
<a name="ln2078">	// set the file offset to the current block run</a>
<a name="ln2079">	offset += (off_t)index * indirectSize;</a>
<a name="ln2080"> </a>
<a name="ln2081">	for (int32 i = index / runsPerBlock; i &lt; run.Length(); i++) {</a>
<a name="ln2082">		block_run* array = (block_run*)cached.SetToWritable(transaction,</a>
<a name="ln2083">			blockNumber + i);</a>
<a name="ln2084">		if (array == NULL)</a>
<a name="ln2085">			RETURN_ERROR(B_ERROR);</a>
<a name="ln2086"> </a>
<a name="ln2087">		for (index = index % runsPerBlock; index &lt; runsPerBlock; index++) {</a>
<a name="ln2088">			if (array[index].IsZero()) {</a>
<a name="ln2089">				// we also want to break out of the outer loop</a>
<a name="ln2090">				i = run.Length();</a>
<a name="ln2091">				break;</a>
<a name="ln2092">			}</a>
<a name="ln2093"> </a>
<a name="ln2094">			status_t status = B_OK;</a>
<a name="ln2095">			if (level == 0) {</a>
<a name="ln2096">				status = _FreeStaticStreamArray(transaction, 1, array[index],</a>
<a name="ln2097">					size, offset, max);</a>
<a name="ln2098">			} else if (offset &gt;= size)</a>
<a name="ln2099">				status = fVolume-&gt;Free(transaction, array[index]);</a>
<a name="ln2100">			else</a>
<a name="ln2101">				max = HOST_ENDIAN_TO_BFS_INT64(offset + indirectSize);</a>
<a name="ln2102"> </a>
<a name="ln2103">			if (status &lt; B_OK)</a>
<a name="ln2104">				RETURN_ERROR(status);</a>
<a name="ln2105"> </a>
<a name="ln2106">			if (offset &gt;= size)</a>
<a name="ln2107">				array[index].SetTo(0, 0, 0);</a>
<a name="ln2108"> </a>
<a name="ln2109">			offset += indirectSize;</a>
<a name="ln2110">		}</a>
<a name="ln2111">		index = 0;</a>
<a name="ln2112">	}</a>
<a name="ln2113">	return B_OK;</a>
<a name="ln2114">}</a>
<a name="ln2115"> </a>
<a name="ln2116"> </a>
<a name="ln2117">/*!	Frees all block_runs in the array which come after the specified size.</a>
<a name="ln2118">	It also trims the last block_run that contain the size.</a>
<a name="ln2119">	&quot;offset&quot; and &quot;max&quot; are maintained until the last block_run that doesn't</a>
<a name="ln2120">	have to be freed - after this, the values won't be correct anymore, but</a>
<a name="ln2121">	will still assure correct function for all subsequent calls.</a>
<a name="ln2122">	&quot;max&quot; is considered to be in file system byte order.</a>
<a name="ln2123">*/</a>
<a name="ln2124">status_t</a>
<a name="ln2125">Inode::_FreeStreamArray(Transaction&amp; transaction, block_run* array,</a>
<a name="ln2126">	uint32 arrayLength, off_t size, off_t&amp; offset, off_t&amp; max)</a>
<a name="ln2127">{</a>
<a name="ln2128">	PRINT((&quot;FreeStreamArray: arrayLength %lu, size %Ld, offset %Ld, max %Ld\n&quot;,</a>
<a name="ln2129">		arrayLength, size, offset, max));</a>
<a name="ln2130"> </a>
<a name="ln2131">	off_t newOffset = offset;</a>
<a name="ln2132">	uint32 i = 0;</a>
<a name="ln2133">	for (; i &lt; arrayLength; i++, offset = newOffset) {</a>
<a name="ln2134">		if (array[i].IsZero())</a>
<a name="ln2135">			break;</a>
<a name="ln2136"> </a>
<a name="ln2137">		newOffset += (off_t)array[i].Length() &lt;&lt; fVolume-&gt;BlockShift();</a>
<a name="ln2138">		if (newOffset &lt;= size)</a>
<a name="ln2139">			continue;</a>
<a name="ln2140"> </a>
<a name="ln2141">		block_run run = array[i];</a>
<a name="ln2142"> </a>
<a name="ln2143">		// determine the block_run to be freed</a>
<a name="ln2144">		if (newOffset &gt; size &amp;&amp; offset &lt; size) {</a>
<a name="ln2145">			// free partial block_run (and update the original block_run)</a>
<a name="ln2146">			run.start = HOST_ENDIAN_TO_BFS_INT16(array[i].Start()</a>
<a name="ln2147">				+ ((size + fVolume-&gt;BlockSize() - 1 - offset)</a>
<a name="ln2148">					&gt;&gt; fVolume-&gt;BlockShift()));</a>
<a name="ln2149">				// round to next block</a>
<a name="ln2150">			array[i].length = HOST_ENDIAN_TO_BFS_INT16(run.Start()</a>
<a name="ln2151">				- array[i].Start());</a>
<a name="ln2152">			run.length = HOST_ENDIAN_TO_BFS_INT16(run.Length()</a>
<a name="ln2153">				- array[i].Length());</a>
<a name="ln2154"> </a>
<a name="ln2155">			if (run.length == 0)</a>
<a name="ln2156">				continue;</a>
<a name="ln2157"> </a>
<a name="ln2158">			// update maximum range</a>
<a name="ln2159">			max = HOST_ENDIAN_TO_BFS_INT64(offset + ((off_t)array[i].Length()</a>
<a name="ln2160">				&lt;&lt; fVolume-&gt;BlockShift()));</a>
<a name="ln2161">		} else {</a>
<a name="ln2162">			// free the whole block_run</a>
<a name="ln2163">			array[i].SetTo(0, 0, 0);</a>
<a name="ln2164"> </a>
<a name="ln2165">			if ((off_t)BFS_ENDIAN_TO_HOST_INT64(max) &gt; offset)</a>
<a name="ln2166">				max = HOST_ENDIAN_TO_BFS_INT64(offset);</a>
<a name="ln2167">		}</a>
<a name="ln2168"> </a>
<a name="ln2169">		if (fVolume-&gt;Free(transaction, run) &lt; B_OK)</a>
<a name="ln2170">			return B_IO_ERROR;</a>
<a name="ln2171">	}</a>
<a name="ln2172">	return B_OK;</a>
<a name="ln2173">}</a>
<a name="ln2174"> </a>
<a name="ln2175"> </a>
<a name="ln2176">status_t</a>
<a name="ln2177">Inode::_ShrinkStream(Transaction&amp; transaction, off_t size)</a>
<a name="ln2178">{</a>
<a name="ln2179">	data_stream* data = &amp;Node().data;</a>
<a name="ln2180">	status_t status;</a>
<a name="ln2181"> </a>
<a name="ln2182">	if (data-&gt;MaxDoubleIndirectRange() &gt; size) {</a>
<a name="ln2183">		off_t* maxDoubleIndirect = &amp;data-&gt;max_double_indirect_range;</a>
<a name="ln2184">			// gcc 4 work-around: &quot;error: cannot bind packed field</a>
<a name="ln2185">			// 'data-&gt;data_stream::max_double_indirect_range' to 'off_t&amp;'&quot;</a>
<a name="ln2186">		status = _FreeStaticStreamArray(transaction, 0, data-&gt;double_indirect,</a>
<a name="ln2187">			size, data-&gt;MaxIndirectRange(), *maxDoubleIndirect);</a>
<a name="ln2188">		if (status != B_OK)</a>
<a name="ln2189">			return status;</a>
<a name="ln2190"> </a>
<a name="ln2191">		if (size &lt;= data-&gt;MaxIndirectRange()) {</a>
<a name="ln2192">			fVolume-&gt;Free(transaction, data-&gt;double_indirect);</a>
<a name="ln2193">			data-&gt;double_indirect.SetTo(0, 0, 0);</a>
<a name="ln2194">			data-&gt;max_double_indirect_range = 0;</a>
<a name="ln2195">		}</a>
<a name="ln2196">	}</a>
<a name="ln2197"> </a>
<a name="ln2198">	if (data-&gt;MaxIndirectRange() &gt; size) {</a>
<a name="ln2199">		CachedBlock cached(fVolume);</a>
<a name="ln2200">		off_t block = fVolume-&gt;ToBlock(data-&gt;indirect);</a>
<a name="ln2201">		off_t offset = data-&gt;MaxDirectRange();</a>
<a name="ln2202"> </a>
<a name="ln2203">		for (int32 i = 0; i &lt; data-&gt;indirect.Length(); i++) {</a>
<a name="ln2204">			block_run* array = (block_run*)cached.SetToWritable(transaction,</a>
<a name="ln2205">				block + i);</a>
<a name="ln2206">			if (array == NULL)</a>
<a name="ln2207">				break;</a>
<a name="ln2208"> </a>
<a name="ln2209">			off_t* maxIndirect = &amp;data-&gt;max_indirect_range;</a>
<a name="ln2210">				// gcc 4 work-around: &quot;error: cannot bind packed field</a>
<a name="ln2211">				// 'data-&gt;data_stream::max_indirect_range' to 'off_t&amp;'&quot;</a>
<a name="ln2212">			if (_FreeStreamArray(transaction, array, fVolume-&gt;BlockSize()</a>
<a name="ln2213">					/ sizeof(block_run), size, offset, *maxIndirect) != B_OK)</a>
<a name="ln2214">				return B_IO_ERROR;</a>
<a name="ln2215">		}</a>
<a name="ln2216">		if (data-&gt;max_direct_range == data-&gt;max_indirect_range) {</a>
<a name="ln2217">			fVolume-&gt;Free(transaction, data-&gt;indirect);</a>
<a name="ln2218">			data-&gt;indirect.SetTo(0, 0, 0);</a>
<a name="ln2219">			data-&gt;max_indirect_range = 0;</a>
<a name="ln2220">		}</a>
<a name="ln2221">	}</a>
<a name="ln2222"> </a>
<a name="ln2223">	if (data-&gt;MaxDirectRange() &gt; size) {</a>
<a name="ln2224">		off_t offset = 0;</a>
<a name="ln2225">		off_t *maxDirect = &amp;data-&gt;max_direct_range;</a>
<a name="ln2226">			// gcc 4 work-around: &quot;error: cannot bind packed field</a>
<a name="ln2227">			// 'data-&gt;data_stream::max_direct_range' to 'off_t&amp;'&quot;</a>
<a name="ln2228">		status = _FreeStreamArray(transaction, data-&gt;direct, NUM_DIRECT_BLOCKS,</a>
<a name="ln2229">			size, offset, *maxDirect);</a>
<a name="ln2230">		if (status &lt; B_OK)</a>
<a name="ln2231">			return status;</a>
<a name="ln2232">	}</a>
<a name="ln2233"> </a>
<a name="ln2234">	data-&gt;size = HOST_ENDIAN_TO_BFS_INT64(size);</a>
<a name="ln2235">	return B_OK;</a>
<a name="ln2236">}</a>
<a name="ln2237"> </a>
<a name="ln2238"> </a>
<a name="ln2239">status_t</a>
<a name="ln2240">Inode::SetFileSize(Transaction&amp; transaction, off_t size)</a>
<a name="ln2241">{</a>
<a name="ln2242">	if (size &lt; 0)</a>
<a name="ln2243">		return B_BAD_VALUE;</a>
<a name="ln2244"> </a>
<a name="ln2245">	off_t oldSize = Size();</a>
<a name="ln2246"> </a>
<a name="ln2247">	if (size == oldSize)</a>
<a name="ln2248">		return B_OK;</a>
<a name="ln2249"> </a>
<a name="ln2250">	T(Resize(this, oldSize, size, false));</a>
<a name="ln2251"> </a>
<a name="ln2252">	// should the data stream grow or shrink?</a>
<a name="ln2253">	status_t status;</a>
<a name="ln2254">	if (size &gt; oldSize) {</a>
<a name="ln2255">		status = _GrowStream(transaction, size);</a>
<a name="ln2256">		if (status &lt; B_OK) {</a>
<a name="ln2257">			// if the growing of the stream fails, the whole operation</a>
<a name="ln2258">			// fails, so we should shrink the stream to its former size</a>
<a name="ln2259">			_ShrinkStream(transaction, oldSize);</a>
<a name="ln2260">		}</a>
<a name="ln2261">	} else</a>
<a name="ln2262">		status = _ShrinkStream(transaction, size);</a>
<a name="ln2263"> </a>
<a name="ln2264">	if (status &lt; B_OK)</a>
<a name="ln2265">		return status;</a>
<a name="ln2266"> </a>
<a name="ln2267">	file_cache_set_size(FileCache(), size);</a>
<a name="ln2268">	file_map_set_size(Map(), size);</a>
<a name="ln2269"> </a>
<a name="ln2270">	return WriteBack(transaction);</a>
<a name="ln2271">}</a>
<a name="ln2272"> </a>
<a name="ln2273"> </a>
<a name="ln2274">status_t</a>
<a name="ln2275">Inode::Append(Transaction&amp; transaction, off_t bytes)</a>
<a name="ln2276">{</a>
<a name="ln2277">	return SetFileSize(transaction, Size() + bytes);</a>
<a name="ln2278">}</a>
<a name="ln2279"> </a>
<a name="ln2280"> </a>
<a name="ln2281">/*!	Checks whether or not this inode's data stream needs to be trimmed</a>
<a name="ln2282">	because of an earlier preallocation.</a>
<a name="ln2283">	Returns true if there are any blocks to be trimmed.</a>
<a name="ln2284">*/</a>
<a name="ln2285">bool</a>
<a name="ln2286">Inode::NeedsTrimming() const</a>
<a name="ln2287">{</a>
<a name="ln2288">	// We never trim preallocated index blocks to make them grow as smooth as</a>
<a name="ln2289">	// possible. There are only few indices anyway, so this doesn't hurt.</a>
<a name="ln2290">	// Also, if an inode is already in deleted state, we don't bother trimming</a>
<a name="ln2291">	// it.</a>
<a name="ln2292">	if (IsIndex() || IsDeleted()</a>
<a name="ln2293">		|| (IsSymLink() &amp;&amp; (Flags() &amp; INODE_LONG_SYMLINK) == 0))</a>
<a name="ln2294">		return false;</a>
<a name="ln2295"> </a>
<a name="ln2296">	off_t roundedSize = round_up(Size(), fVolume-&gt;BlockSize());</a>
<a name="ln2297"> </a>
<a name="ln2298">	return Node().data.MaxDirectRange() &gt; roundedSize</a>
<a name="ln2299">		|| Node().data.MaxIndirectRange() &gt; roundedSize</a>
<a name="ln2300">		|| Node().data.MaxDoubleIndirectRange() &gt; roundedSize;</a>
<a name="ln2301">}</a>
<a name="ln2302"> </a>
<a name="ln2303"> </a>
<a name="ln2304">status_t</a>
<a name="ln2305">Inode::TrimPreallocation(Transaction&amp; transaction)</a>
<a name="ln2306">{</a>
<a name="ln2307">	T(Resize(this, max_c(Node().data.MaxDirectRange(),</a>
<a name="ln2308">		Node().data.MaxIndirectRange()), Size(), true));</a>
<a name="ln2309"> </a>
<a name="ln2310">	status_t status = _ShrinkStream(transaction, Size());</a>
<a name="ln2311">	if (status &lt; B_OK)</a>
<a name="ln2312">		return status;</a>
<a name="ln2313"> </a>
<a name="ln2314">	return WriteBack(transaction);</a>
<a name="ln2315">}</a>
<a name="ln2316"> </a>
<a name="ln2317"> </a>
<a name="ln2318">//!	Frees the file's data stream and removes all attributes</a>
<a name="ln2319">status_t</a>
<a name="ln2320">Inode::Free(Transaction&amp; transaction)</a>
<a name="ln2321">{</a>
<a name="ln2322">	FUNCTION();</a>
<a name="ln2323"> </a>
<a name="ln2324">	// Perhaps there should be an implementation of Inode::ShrinkStream() that</a>
<a name="ln2325">	// just frees the data_stream, but doesn't change the inode (since it is</a>
<a name="ln2326">	// freed anyway) - that would make an undelete command possible</a>
<a name="ln2327">	if (!IsSymLink() || (Flags() &amp; INODE_LONG_SYMLINK) != 0) {</a>
<a name="ln2328">		status_t status = SetFileSize(transaction, 0);</a>
<a name="ln2329">		if (status &lt; B_OK)</a>
<a name="ln2330">			return status;</a>
<a name="ln2331">	}</a>
<a name="ln2332"> </a>
<a name="ln2333">	// Free all attributes, and remove their indices</a>
<a name="ln2334">	{</a>
<a name="ln2335">		// We have to limit the scope of AttributeIterator, so that its</a>
<a name="ln2336">		// destructor is not called after the inode is deleted</a>
<a name="ln2337">		AttributeIterator iterator(this);</a>
<a name="ln2338"> </a>
<a name="ln2339">		char name[B_FILE_NAME_LENGTH];</a>
<a name="ln2340">		uint32 type;</a>
<a name="ln2341">		size_t length;</a>
<a name="ln2342">		ino_t id;</a>
<a name="ln2343">		while (iterator.GetNext(name, &amp;length, &amp;type, &amp;id) == B_OK) {</a>
<a name="ln2344">			RemoveAttribute(transaction, name);</a>
<a name="ln2345">		}</a>
<a name="ln2346">	}</a>
<a name="ln2347"> </a>
<a name="ln2348">	if (WriteBack(transaction) &lt; B_OK)</a>
<a name="ln2349">		return B_IO_ERROR;</a>
<a name="ln2350"> </a>
<a name="ln2351">	return fVolume-&gt;Free(transaction, BlockRun());</a>
<a name="ln2352">}</a>
<a name="ln2353"> </a>
<a name="ln2354"> </a>
<a name="ln2355">//!	Synchronizes (writes back to disk) the file stream of the inode.</a>
<a name="ln2356">status_t</a>
<a name="ln2357">Inode::Sync()</a>
<a name="ln2358">{</a>
<a name="ln2359">	if (FileCache())</a>
<a name="ln2360">		return file_cache_sync(FileCache());</a>
<a name="ln2361"> </a>
<a name="ln2362">	// We may also want to flush the attribute's data stream to</a>
<a name="ln2363">	// disk here... (do we?)</a>
<a name="ln2364"> </a>
<a name="ln2365">	if (IsSymLink() &amp;&amp; (Flags() &amp; INODE_LONG_SYMLINK) == 0)</a>
<a name="ln2366">		return B_OK;</a>
<a name="ln2367"> </a>
<a name="ln2368">	InodeReadLocker locker(this);</a>
<a name="ln2369"> </a>
<a name="ln2370">	data_stream* data = &amp;Node().data;</a>
<a name="ln2371">	status_t status = B_OK;</a>
<a name="ln2372"> </a>
<a name="ln2373">	// flush direct range</a>
<a name="ln2374"> </a>
<a name="ln2375">	for (int32 i = 0; i &lt; NUM_DIRECT_BLOCKS; i++) {</a>
<a name="ln2376">		if (data-&gt;direct[i].IsZero())</a>
<a name="ln2377">			return B_OK;</a>
<a name="ln2378"> </a>
<a name="ln2379">		status = block_cache_sync_etc(fVolume-&gt;BlockCache(),</a>
<a name="ln2380">			fVolume-&gt;ToBlock(data-&gt;direct[i]), data-&gt;direct[i].Length());</a>
<a name="ln2381">		if (status != B_OK)</a>
<a name="ln2382">			return status;</a>
<a name="ln2383">	}</a>
<a name="ln2384"> </a>
<a name="ln2385">	// flush indirect range</a>
<a name="ln2386"> </a>
<a name="ln2387">	if (data-&gt;max_indirect_range == 0)</a>
<a name="ln2388">		return B_OK;</a>
<a name="ln2389"> </a>
<a name="ln2390">	CachedBlock cached(fVolume);</a>
<a name="ln2391">	off_t block = fVolume-&gt;ToBlock(data-&gt;indirect);</a>
<a name="ln2392">	int32 count = fVolume-&gt;BlockSize() / sizeof(block_run);</a>
<a name="ln2393"> </a>
<a name="ln2394">	for (int32 j = 0; j &lt; data-&gt;indirect.Length(); j++) {</a>
<a name="ln2395">		block_run* runs = (block_run*)cached.SetTo(block + j);</a>
<a name="ln2396">		if (runs == NULL)</a>
<a name="ln2397">			break;</a>
<a name="ln2398"> </a>
<a name="ln2399">		for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln2400">			if (runs[i].IsZero())</a>
<a name="ln2401">				return B_OK;</a>
<a name="ln2402"> </a>
<a name="ln2403">			status = block_cache_sync_etc(fVolume-&gt;BlockCache(),</a>
<a name="ln2404">				fVolume-&gt;ToBlock(runs[i]), runs[i].Length());</a>
<a name="ln2405">			if (status != B_OK)</a>
<a name="ln2406">				return status;</a>
<a name="ln2407">		}</a>
<a name="ln2408">	}</a>
<a name="ln2409"> </a>
<a name="ln2410">	// flush double indirect range</a>
<a name="ln2411"> </a>
<a name="ln2412">	if (data-&gt;max_double_indirect_range == 0)</a>
<a name="ln2413">		return B_OK;</a>
<a name="ln2414"> </a>
<a name="ln2415">	off_t indirectBlock = fVolume-&gt;ToBlock(data-&gt;double_indirect);</a>
<a name="ln2416"> </a>
<a name="ln2417">	for (int32 l = 0; l &lt; data-&gt;double_indirect.Length(); l++) {</a>
<a name="ln2418">		block_run* indirectRuns = (block_run*)cached.SetTo(indirectBlock + l);</a>
<a name="ln2419">		if (indirectRuns == NULL)</a>
<a name="ln2420">			return B_FILE_ERROR;</a>
<a name="ln2421"> </a>
<a name="ln2422">		CachedBlock directCached(fVolume);</a>
<a name="ln2423"> </a>
<a name="ln2424">		for (int32 k = 0; k &lt; count; k++) {</a>
<a name="ln2425">			if (indirectRuns[k].IsZero())</a>
<a name="ln2426">				return B_OK;</a>
<a name="ln2427"> </a>
<a name="ln2428">			block = fVolume-&gt;ToBlock(indirectRuns[k]);</a>
<a name="ln2429">			for (int32 j = 0; j &lt; indirectRuns[k].Length(); j++) {</a>
<a name="ln2430">				block_run* runs = (block_run*)directCached.SetTo(block + j);</a>
<a name="ln2431">				if (runs == NULL)</a>
<a name="ln2432">					return B_FILE_ERROR;</a>
<a name="ln2433"> </a>
<a name="ln2434">				for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln2435">					if (runs[i].IsZero())</a>
<a name="ln2436">						return B_OK;</a>
<a name="ln2437"> </a>
<a name="ln2438">					// TODO: combine single block_runs to bigger ones when</a>
<a name="ln2439">					// they are adjacent</a>
<a name="ln2440">					status = block_cache_sync_etc(fVolume-&gt;BlockCache(),</a>
<a name="ln2441">						fVolume-&gt;ToBlock(runs[i]), runs[i].Length());</a>
<a name="ln2442">					if (status != B_OK)</a>
<a name="ln2443">						return status;</a>
<a name="ln2444">				}</a>
<a name="ln2445">			}</a>
<a name="ln2446">		}</a>
<a name="ln2447">	}</a>
<a name="ln2448">	return B_OK;</a>
<a name="ln2449">}</a>
<a name="ln2450"> </a>
<a name="ln2451"> </a>
<a name="ln2452">//	#pragma mark - TransactionListener implementation</a>
<a name="ln2453"> </a>
<a name="ln2454"> </a>
<a name="ln2455">void</a>
<a name="ln2456">Inode::TransactionDone(bool success)</a>
<a name="ln2457">{</a>
<a name="ln2458">	if (!success) {</a>
<a name="ln2459">		// Revert any changes made to the cached bfs_inode</a>
<a name="ln2460">		// TODO: return code gets eaten</a>
<a name="ln2461">		UpdateNodeFromDisk();</a>
<a name="ln2462">	}</a>
<a name="ln2463">}</a>
<a name="ln2464"> </a>
<a name="ln2465"> </a>
<a name="ln2466">void</a>
<a name="ln2467">Inode::RemovedFromTransaction()</a>
<a name="ln2468">{</a>
<a name="ln2469">	Node().flags &amp;= ~HOST_ENDIAN_TO_BFS_INT32(INODE_IN_TRANSACTION);</a>
<a name="ln2470"> </a>
<a name="ln2471">	// See AddInode() why we do this here</a>
<a name="ln2472">	if ((Flags() &amp; INODE_DELETED) != 0)</a>
<a name="ln2473">		fVolume-&gt;RemovedInodes().Add(this);</a>
<a name="ln2474"> </a>
<a name="ln2475">	rw_lock_write_unlock(&amp;Lock());</a>
<a name="ln2476"> </a>
<a name="ln2477">	if (!fVolume-&gt;IsInitializing())</a>
<a name="ln2478">		put_vnode(fVolume-&gt;FSVolume(), ID());</a>
<a name="ln2479">}</a>
<a name="ln2480"> </a>
<a name="ln2481"> </a>
<a name="ln2482">//	#pragma mark - creation/deletion</a>
<a name="ln2483"> </a>
<a name="ln2484"> </a>
<a name="ln2485">status_t</a>
<a name="ln2486">Inode::Remove(Transaction&amp; transaction, const char* name, ino_t* _id,</a>
<a name="ln2487">	bool isDirectory, bool force)</a>
<a name="ln2488">{</a>
<a name="ln2489">	if (fTree == NULL)</a>
<a name="ln2490">		RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln2491"> </a>
<a name="ln2492">	WriteLockInTransaction(transaction);</a>
<a name="ln2493"> </a>
<a name="ln2494">	// does the file even exist?</a>
<a name="ln2495">	off_t id;</a>
<a name="ln2496">	if (fTree-&gt;Find((uint8*)name, (uint16)strlen(name), &amp;id) &lt; B_OK)</a>
<a name="ln2497">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln2498"> </a>
<a name="ln2499">	if (_id)</a>
<a name="ln2500">		*_id = id;</a>
<a name="ln2501"> </a>
<a name="ln2502">	Vnode vnode(fVolume, id);</a>
<a name="ln2503">	Inode* inode;</a>
<a name="ln2504">	status_t status = vnode.Get(&amp;inode);</a>
<a name="ln2505">	if (status &lt; B_OK) {</a>
<a name="ln2506">		REPORT_ERROR(status);</a>
<a name="ln2507">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln2508">	}</a>
<a name="ln2509"> </a>
<a name="ln2510">	T(Remove(inode, name));</a>
<a name="ln2511">	inode-&gt;WriteLockInTransaction(transaction);</a>
<a name="ln2512"> </a>
<a name="ln2513">	// Inode::IsContainer() is true also for indices (furthermore, the S_IFDIR</a>
<a name="ln2514">	// bit is set for indices in BFS, not for attribute directories) - but you</a>
<a name="ln2515">	// should really be able to do whatever you want with your indices</a>
<a name="ln2516">	// without having to remove all files first :)</a>
<a name="ln2517">	if (!inode-&gt;IsIndex() &amp;&amp; !force) {</a>
<a name="ln2518">		// if it's not of the correct type, don't delete it!</a>
<a name="ln2519">		if (inode-&gt;IsContainer() != isDirectory)</a>
<a name="ln2520">			return isDirectory ? B_NOT_A_DIRECTORY : B_IS_A_DIRECTORY;</a>
<a name="ln2521"> </a>
<a name="ln2522">		// only delete empty directories</a>
<a name="ln2523">		if (isDirectory &amp;&amp; !inode-&gt;IsEmpty())</a>
<a name="ln2524">			return B_DIRECTORY_NOT_EMPTY;</a>
<a name="ln2525">	}</a>
<a name="ln2526"> </a>
<a name="ln2527">	// remove_vnode() allows the inode to be accessed until the last put_vnode()</a>
<a name="ln2528">	status = remove_vnode(fVolume-&gt;FSVolume(), id);</a>
<a name="ln2529">	if (status != B_OK)</a>
<a name="ln2530">		return status;</a>
<a name="ln2531"> </a>
<a name="ln2532">	if (fTree-&gt;Remove(transaction, name, id) != B_OK &amp;&amp; !force) {</a>
<a name="ln2533">		unremove_vnode(fVolume-&gt;FSVolume(), id);</a>
<a name="ln2534">		RETURN_ERROR(B_ERROR);</a>
<a name="ln2535">	}</a>
<a name="ln2536"> </a>
<a name="ln2537">#ifdef DEBUG</a>
<a name="ln2538">	if (fTree-&gt;Find((uint8*)name, (uint16)strlen(name), &amp;id) == B_OK) {</a>
<a name="ln2539">		DIE((&quot;deleted entry still there&quot;));</a>
<a name="ln2540">	}</a>
<a name="ln2541">#endif</a>
<a name="ln2542"> </a>
<a name="ln2543">	ContainerContentsChanged(transaction);</a>
<a name="ln2544"> </a>
<a name="ln2545">	// update the inode, so that no one will ever doubt it's deleted :-)</a>
<a name="ln2546">	inode-&gt;Node().flags |= HOST_ENDIAN_TO_BFS_INT32(INODE_DELETED);</a>
<a name="ln2547">	inode-&gt;Node().flags &amp;= ~HOST_ENDIAN_TO_BFS_INT32(INODE_IN_USE);</a>
<a name="ln2548"> </a>
<a name="ln2549">	// In balance to the Inode::Create() method, the main indices</a>
<a name="ln2550">	// are updated here (name, size, &amp; last_modified)</a>
<a name="ln2551"> </a>
<a name="ln2552">	Index index(fVolume);</a>
<a name="ln2553">	if (inode-&gt;InNameIndex()) {</a>
<a name="ln2554">		index.RemoveName(transaction, name, inode);</a>
<a name="ln2555">			// If removing from the index fails, it is not regarded as a</a>
<a name="ln2556">			// fatal error and will not be reported back!</a>
<a name="ln2557">			// Deleted inodes won't be visible in queries anyway.</a>
<a name="ln2558">	}</a>
<a name="ln2559"> </a>
<a name="ln2560">	if (inode-&gt;InSizeIndex())</a>
<a name="ln2561">		index.RemoveSize(transaction, inode);</a>
<a name="ln2562">	if (inode-&gt;InLastModifiedIndex())</a>
<a name="ln2563">		index.RemoveLastModified(transaction, inode);</a>
<a name="ln2564"> </a>
<a name="ln2565">	return inode-&gt;WriteBack(transaction);</a>
<a name="ln2566">}</a>
<a name="ln2567"> </a>
<a name="ln2568"> </a>
<a name="ln2569">/*!	Creates the inode with the specified \a parent directory, and automatically</a>
<a name="ln2570">	adds the created inode to that parent directory. If an attribute directory</a>
<a name="ln2571">	is created, it will also automatically  be added to the \a parent inode as</a>
<a name="ln2572">	such. However, the indices root node, and the regular root node won't be</a>
<a name="ln2573">	added to the superblock.</a>
<a name="ln2574">	It will also create the initial B+tree for the inode if it's a directory</a>
<a name="ln2575">	of any kind.</a>
<a name="ln2576">	\a name may be \c NULL, but only if no \a parent is given.</a>
<a name="ln2577">	If the &quot;_id&quot; or &quot;_inode&quot; variable is given and non-NULL to store the</a>
<a name="ln2578">	inode's ID, the inode stays locked - you have to call put_vnode() if you</a>
<a name="ln2579">	don't use it anymore.</a>
<a name="ln2580">	If the node already exists, this method will fail if \c O_EXCL is set, or</a>
<a name="ln2581">	it's a directory or a symlink. Otherwise, it will just be returned.</a>
<a name="ln2582">	If \c O_TRUNC has been specified, the file will also be truncated.</a>
<a name="ln2583">*/</a>
<a name="ln2584">status_t</a>
<a name="ln2585">Inode::Create(Transaction&amp; transaction, Inode* parent, const char* name,</a>
<a name="ln2586">	int32 mode, int openMode, uint32 type, bool* _created, ino_t* _id,</a>
<a name="ln2587">	Inode** _inode, fs_vnode_ops* vnodeOps, uint32 publishFlags)</a>
<a name="ln2588">{</a>
<a name="ln2589">	FUNCTION_START((&quot;name = %s, mode = %ld\n&quot;, name, mode));</a>
<a name="ln2590"> </a>
<a name="ln2591">	block_run parentRun = parent ? parent-&gt;BlockRun() : block_run::Run(0, 0, 0);</a>
<a name="ln2592">	Volume* volume = transaction.GetVolume();</a>
<a name="ln2593">	BPlusTree* tree = NULL;</a>
<a name="ln2594"> </a>
<a name="ln2595">	if (parent != NULL &amp;&amp; (mode &amp; S_ATTR_DIR) == 0 &amp;&amp; parent-&gt;IsContainer()) {</a>
<a name="ln2596">		// check if the file already exists in the directory</a>
<a name="ln2597">		tree = parent-&gt;Tree();</a>
<a name="ln2598">	}</a>
<a name="ln2599"> </a>
<a name="ln2600">	if (parent != NULL) {</a>
<a name="ln2601">		// the parent directory is locked during the whole inode creation</a>
<a name="ln2602">		parent-&gt;WriteLockInTransaction(transaction);</a>
<a name="ln2603">	}</a>
<a name="ln2604"> </a>
<a name="ln2605">	if (parent != NULL &amp;&amp; !volume-&gt;IsInitializing() &amp;&amp; parent-&gt;IsContainer()) {</a>
<a name="ln2606">		// don't create anything in removed directories</a>
<a name="ln2607">		bool removed;</a>
<a name="ln2608">		if (get_vnode_removed(volume-&gt;FSVolume(), parent-&gt;ID(), &amp;removed)</a>
<a name="ln2609">				== B_OK &amp;&amp; removed) {</a>
<a name="ln2610">			RETURN_ERROR(B_ENTRY_NOT_FOUND);</a>
<a name="ln2611">		}</a>
<a name="ln2612">	}</a>
<a name="ln2613"> </a>
<a name="ln2614">	if (tree != NULL) {</a>
<a name="ln2615">		// Does the file already exist?</a>
<a name="ln2616">		off_t offset;</a>
<a name="ln2617">		if (tree-&gt;Find((uint8*)name, (uint16)strlen(name), &amp;offset) == B_OK) {</a>
<a name="ln2618">			// Return if the file should be a directory/link or opened in</a>
<a name="ln2619">			// exclusive mode</a>
<a name="ln2620">			if (S_ISDIR(mode) || S_ISLNK(mode) || (openMode &amp; O_EXCL) != 0)</a>
<a name="ln2621">				return B_FILE_EXISTS;</a>
<a name="ln2622"> </a>
<a name="ln2623">			Vnode vnode(volume, offset);</a>
<a name="ln2624">			Inode* inode;</a>
<a name="ln2625">			status_t status = vnode.Get(&amp;inode);</a>
<a name="ln2626">			if (status != B_OK) {</a>
<a name="ln2627">				REPORT_ERROR(status);</a>
<a name="ln2628">				return B_ENTRY_NOT_FOUND;</a>
<a name="ln2629">			}</a>
<a name="ln2630"> </a>
<a name="ln2631">			if (inode-&gt;IsDirectory() &amp;&amp; (openMode &amp; O_RWMASK) != O_RDONLY)</a>
<a name="ln2632">				return B_IS_A_DIRECTORY;</a>
<a name="ln2633">			if ((openMode &amp; O_DIRECTORY) != 0 &amp;&amp; !inode-&gt;IsDirectory())</a>
<a name="ln2634">				return B_NOT_A_DIRECTORY;</a>
<a name="ln2635"> </a>
<a name="ln2636">			// we want to open the file, so we should have the rights to do so</a>
<a name="ln2637">			if (inode-&gt;CheckPermissions(open_mode_to_access(openMode)</a>
<a name="ln2638">					| ((openMode &amp; O_TRUNC) != 0 ? W_OK : 0)) != B_OK)</a>
<a name="ln2639">				return B_NOT_ALLOWED;</a>
<a name="ln2640"> </a>
<a name="ln2641">			if ((openMode &amp; O_TRUNC) != 0) {</a>
<a name="ln2642">				// truncate the existing file</a>
<a name="ln2643">				inode-&gt;WriteLockInTransaction(transaction);</a>
<a name="ln2644"> </a>
<a name="ln2645">				status_t status = inode-&gt;SetFileSize(transaction, 0);</a>
<a name="ln2646">				if (status == B_OK)</a>
<a name="ln2647">					status = inode-&gt;WriteBack(transaction);</a>
<a name="ln2648"> </a>
<a name="ln2649">				if (status != B_OK)</a>
<a name="ln2650">					return status;</a>
<a name="ln2651">			}</a>
<a name="ln2652"> </a>
<a name="ln2653">			if (_created)</a>
<a name="ln2654">				*_created = false;</a>
<a name="ln2655">			if (_id)</a>
<a name="ln2656">				*_id = inode-&gt;ID();</a>
<a name="ln2657">			if (_inode)</a>
<a name="ln2658">				*_inode = inode;</a>
<a name="ln2659"> </a>
<a name="ln2660">			// Only keep the vnode in memory if the _id or _inode pointer is</a>
<a name="ln2661">			// provided</a>
<a name="ln2662">			if (_id != NULL || _inode != NULL)</a>
<a name="ln2663">				vnode.Keep();</a>
<a name="ln2664"> </a>
<a name="ln2665">			return B_OK;</a>
<a name="ln2666">		}</a>
<a name="ln2667">	} else if (parent != NULL &amp;&amp; (mode &amp; S_ATTR_DIR) == 0) {</a>
<a name="ln2668">		return B_BAD_VALUE;</a>
<a name="ln2669">	} else if ((openMode &amp; O_DIRECTORY) != 0) {</a>
<a name="ln2670">		// TODO: we might need to return B_NOT_A_DIRECTORY here</a>
<a name="ln2671">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln2672">	}</a>
<a name="ln2673"> </a>
<a name="ln2674">	status_t status;</a>
<a name="ln2675"> </a>
<a name="ln2676">	// do we have the power to create new files at all?</a>
<a name="ln2677">	if (parent != NULL &amp;&amp; (status = parent-&gt;CheckPermissions(W_OK)) != B_OK)</a>
<a name="ln2678">		RETURN_ERROR(status);</a>
<a name="ln2679"> </a>
<a name="ln2680">	// allocate space for the new inode</a>
<a name="ln2681">	InodeAllocator allocator(transaction);</a>
<a name="ln2682">	block_run run;</a>
<a name="ln2683">	Inode* inode;</a>
<a name="ln2684">	status = allocator.New(&amp;parentRun, mode, publishFlags, run, vnodeOps,</a>
<a name="ln2685">		&amp;inode);</a>
<a name="ln2686">	if (status &lt; B_OK)</a>
<a name="ln2687">		return status;</a>
<a name="ln2688"> </a>
<a name="ln2689">	T(Create(inode, parent, name, mode, openMode, type));</a>
<a name="ln2690"> </a>
<a name="ln2691">	// Initialize the parts of the bfs_inode structure that</a>
<a name="ln2692">	// InodeAllocator::New() hasn't touched yet</a>
<a name="ln2693"> </a>
<a name="ln2694">	bfs_inode* node = &amp;inode-&gt;Node();</a>
<a name="ln2695"> </a>
<a name="ln2696">	if (parent == NULL) {</a>
<a name="ln2697">		// we set the parent to itself in this case</a>
<a name="ln2698">		// (only happens for the root and indices node)</a>
<a name="ln2699">		node-&gt;parent = run;</a>
<a name="ln2700">	} else</a>
<a name="ln2701">		node-&gt;parent = parentRun;</a>
<a name="ln2702"> </a>
<a name="ln2703">	node-&gt;uid = HOST_ENDIAN_TO_BFS_INT32(geteuid());</a>
<a name="ln2704">	node-&gt;gid = HOST_ENDIAN_TO_BFS_INT32(parent</a>
<a name="ln2705">		? parent-&gt;Node().GroupID() : getegid());</a>
<a name="ln2706">		// the group ID is inherited from the parent, if available</a>
<a name="ln2707"> </a>
<a name="ln2708">	node-&gt;type = HOST_ENDIAN_TO_BFS_INT32(type);</a>
<a name="ln2709"> </a>
<a name="ln2710">	inode-&gt;WriteBack(transaction);</a>
<a name="ln2711">		// make sure the initialized node is available to others</a>
<a name="ln2712"> </a>
<a name="ln2713">	// only add the name to regular files, directories, or symlinks</a>
<a name="ln2714">	// don't add it to attributes, or indices</a>
<a name="ln2715">	if (tree &amp;&amp; inode-&gt;IsRegularNode()</a>
<a name="ln2716">		&amp;&amp; inode-&gt;SetName(transaction, name) != B_OK)</a>
<a name="ln2717">		return B_ERROR;</a>
<a name="ln2718"> </a>
<a name="ln2719">	// Initialize b+tree if it's a directory (and add &quot;.&quot; &amp; &quot;..&quot; if it's</a>
<a name="ln2720">	// a standard directory for files - not for attributes or indices)</a>
<a name="ln2721">	if (inode-&gt;IsContainer()) {</a>
<a name="ln2722">		status = allocator.CreateTree();</a>
<a name="ln2723">		if (status != B_OK)</a>
<a name="ln2724">			return status;</a>
<a name="ln2725">	}</a>
<a name="ln2726"> </a>
<a name="ln2727">	// Add a link to the inode from the parent, depending on its type</a>
<a name="ln2728">	// (the vnode is not published yet, so it is safe to make the inode</a>
<a name="ln2729">	// accessable to the file system here)</a>
<a name="ln2730">	if (tree != NULL) {</a>
<a name="ln2731">		status = tree-&gt;Insert(transaction, name, inode-&gt;ID());</a>
<a name="ln2732">	} else if (parent != NULL &amp;&amp; (mode &amp; S_ATTR_DIR) != 0) {</a>
<a name="ln2733">		parent-&gt;Attributes() = run;</a>
<a name="ln2734">		status = parent-&gt;WriteBack(transaction);</a>
<a name="ln2735">	}</a>
<a name="ln2736"> </a>
<a name="ln2737">	// Note, we only care if the inode could be made accessable for the</a>
<a name="ln2738">	// two cases above; the root node or the indices root node must</a>
<a name="ln2739">	// handle this case on their own (or other cases where &quot;parent&quot; is</a>
<a name="ln2740">	// NULL)</a>
<a name="ln2741">	if (status != B_OK)</a>
<a name="ln2742">		RETURN_ERROR(status);</a>
<a name="ln2743"> </a>
<a name="ln2744">	// Update the main indices (name, size &amp; last_modified)</a>
<a name="ln2745">	// (live queries might want to access us after this)</a>
<a name="ln2746"> </a>
<a name="ln2747">	Index index(volume);</a>
<a name="ln2748">	if (inode-&gt;InNameIndex() &amp;&amp; name != NULL) {</a>
<a name="ln2749">		// the name index only contains regular files</a>
<a name="ln2750">		// (but not the root node where name == NULL)</a>
<a name="ln2751">		status = index.InsertName(transaction, name, inode);</a>
<a name="ln2752">		if (status != B_OK &amp;&amp; status != B_BAD_INDEX) {</a>
<a name="ln2753">			// We have to remove the node from the parent at this point,</a>
<a name="ln2754">			// because the InodeAllocator destructor can't handle this</a>
<a name="ln2755">			// case (and if it fails, we can't do anything about it...)</a>
<a name="ln2756">			if (tree)</a>
<a name="ln2757">				tree-&gt;Remove(transaction, name, inode-&gt;ID());</a>
<a name="ln2758">			else if (parent != NULL &amp;&amp; (mode &amp; S_ATTR_DIR) != 0)</a>
<a name="ln2759">				parent-&gt;Node().attributes.SetTo(0, 0, 0);</a>
<a name="ln2760"> </a>
<a name="ln2761">			RETURN_ERROR(status);</a>
<a name="ln2762">		}</a>
<a name="ln2763">	}</a>
<a name="ln2764"> </a>
<a name="ln2765">	if (parent != NULL &amp;&amp; parent-&gt;IsContainer())</a>
<a name="ln2766">		parent-&gt;ContainerContentsChanged(transaction);</a>
<a name="ln2767"> </a>
<a name="ln2768">	inode-&gt;UpdateOldLastModified();</a>
<a name="ln2769"> </a>
<a name="ln2770">	// The &quot;size&quot; &amp; &quot;last_modified&quot; indices don't contain directories.</a>
<a name="ln2771">	// If adding to these indices fails, the inode creation will not be</a>
<a name="ln2772">	// harmed; they are considered less important than the &quot;name&quot; index.</a>
<a name="ln2773">	if (inode-&gt;InSizeIndex())</a>
<a name="ln2774">		index.InsertSize(transaction, inode);</a>
<a name="ln2775">	if (inode-&gt;InLastModifiedIndex())</a>
<a name="ln2776">		index.InsertLastModified(transaction, inode);</a>
<a name="ln2777"> </a>
<a name="ln2778">	if (inode-&gt;NeedsFileCache()) {</a>
<a name="ln2779">		inode-&gt;SetFileCache(file_cache_create(volume-&gt;ID(), inode-&gt;ID(),</a>
<a name="ln2780">			inode-&gt;Size()));</a>
<a name="ln2781">		inode-&gt;SetMap(file_map_create(volume-&gt;ID(), inode-&gt;ID(),</a>
<a name="ln2782">			inode-&gt;Size()));</a>
<a name="ln2783"> </a>
<a name="ln2784">		if (inode-&gt;FileCache() == NULL || inode-&gt;Map() == NULL)</a>
<a name="ln2785">			return B_NO_MEMORY;</a>
<a name="ln2786">	}</a>
<a name="ln2787"> </a>
<a name="ln2788">	// Everything worked well until this point, we have a fully</a>
<a name="ln2789">	// initialized inode, and we want to keep it</a>
<a name="ln2790">	allocator.Keep(vnodeOps, publishFlags);</a>
<a name="ln2791"> </a>
<a name="ln2792">	if (_created)</a>
<a name="ln2793">		*_created = true;</a>
<a name="ln2794">	if (_id != NULL)</a>
<a name="ln2795">		*_id = inode-&gt;ID();</a>
<a name="ln2796">	if (_inode != NULL)</a>
<a name="ln2797">		*_inode = inode;</a>
<a name="ln2798"> </a>
<a name="ln2799">	// if either _id or _inode is passed, we will keep the inode locked</a>
<a name="ln2800">	if (_id == NULL &amp;&amp; _inode == NULL)</a>
<a name="ln2801">		put_vnode(volume-&gt;FSVolume(), inode-&gt;ID());</a>
<a name="ln2802"> </a>
<a name="ln2803">	return B_OK;</a>
<a name="ln2804">}</a>
<a name="ln2805"> </a>
<a name="ln2806"> </a>
<a name="ln2807">//	#pragma mark - AttributeIterator</a>
<a name="ln2808"> </a>
<a name="ln2809"> </a>
<a name="ln2810">AttributeIterator::AttributeIterator(Inode* inode)</a>
<a name="ln2811">	:</a>
<a name="ln2812">	fCurrentSmallData(0),</a>
<a name="ln2813">	fInode(inode),</a>
<a name="ln2814">	fAttributes(NULL),</a>
<a name="ln2815">	fIterator(NULL),</a>
<a name="ln2816">	fBuffer(NULL)</a>
<a name="ln2817">{</a>
<a name="ln2818">	inode-&gt;_AddIterator(this);</a>
<a name="ln2819">}</a>
<a name="ln2820"> </a>
<a name="ln2821"> </a>
<a name="ln2822">AttributeIterator::~AttributeIterator()</a>
<a name="ln2823">{</a>
<a name="ln2824">	if (fAttributes)</a>
<a name="ln2825">		put_vnode(fAttributes-&gt;GetVolume()-&gt;FSVolume(), fAttributes-&gt;ID());</a>
<a name="ln2826"> </a>
<a name="ln2827">	delete fIterator;</a>
<a name="ln2828">	fInode-&gt;_RemoveIterator(this);</a>
<a name="ln2829">}</a>
<a name="ln2830"> </a>
<a name="ln2831"> </a>
<a name="ln2832">status_t</a>
<a name="ln2833">AttributeIterator::Rewind()</a>
<a name="ln2834">{</a>
<a name="ln2835">	fCurrentSmallData = 0;</a>
<a name="ln2836"> </a>
<a name="ln2837">	if (fIterator != NULL)</a>
<a name="ln2838">		fIterator-&gt;Rewind();</a>
<a name="ln2839"> </a>
<a name="ln2840">	return B_OK;</a>
<a name="ln2841">}</a>
<a name="ln2842"> </a>
<a name="ln2843"> </a>
<a name="ln2844">status_t</a>
<a name="ln2845">AttributeIterator::GetNext(char* name, size_t* _length, uint32* _type,</a>
<a name="ln2846">	ino_t* _id)</a>
<a name="ln2847">{</a>
<a name="ln2848">	// read attributes out of the small data section</a>
<a name="ln2849"> </a>
<a name="ln2850">	if (fCurrentSmallData &gt;= 0) {</a>
<a name="ln2851">		NodeGetter nodeGetter(fInode-&gt;GetVolume(), fInode);</a>
<a name="ln2852">		if (nodeGetter.Node() == NULL)</a>
<a name="ln2853">			return B_IO_ERROR;</a>
<a name="ln2854"> </a>
<a name="ln2855">		const bfs_inode* node = nodeGetter.Node();</a>
<a name="ln2856">		const small_data* item = ((bfs_inode*)node)-&gt;SmallDataStart();</a>
<a name="ln2857"> </a>
<a name="ln2858">		RecursiveLocker _(&amp;fInode-&gt;SmallDataLock());</a>
<a name="ln2859"> </a>
<a name="ln2860">		int32 index = 0;</a>
<a name="ln2861">		for (; !item-&gt;IsLast(node); item = item-&gt;Next(), index++) {</a>
<a name="ln2862">			if (item-&gt;NameSize() == FILE_NAME_NAME_LENGTH</a>
<a name="ln2863">				&amp;&amp; *item-&gt;Name() == FILE_NAME_NAME)</a>
<a name="ln2864">				continue;</a>
<a name="ln2865"> </a>
<a name="ln2866">			if (index &gt;= fCurrentSmallData)</a>
<a name="ln2867">				break;</a>
<a name="ln2868">		}</a>
<a name="ln2869"> </a>
<a name="ln2870">		if (!item-&gt;IsLast(node)) {</a>
<a name="ln2871">			strncpy(name, item-&gt;Name(), B_FILE_NAME_LENGTH);</a>
<a name="ln2872">			*_type = item-&gt;Type();</a>
<a name="ln2873">			*_length = item-&gt;NameSize();</a>
<a name="ln2874">			*_id = (ino_t)index;</a>
<a name="ln2875"> </a>
<a name="ln2876">			fCurrentSmallData = index + 1;</a>
<a name="ln2877">			return B_OK;</a>
<a name="ln2878">		}</a>
<a name="ln2879"> </a>
<a name="ln2880">		// stop traversing the small_data section</a>
<a name="ln2881">		fCurrentSmallData = -1;</a>
<a name="ln2882">	}</a>
<a name="ln2883"> </a>
<a name="ln2884">	// read attributes out of the attribute directory</a>
<a name="ln2885"> </a>
<a name="ln2886">	if (fInode-&gt;Attributes().IsZero())</a>
<a name="ln2887">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln2888"> </a>
<a name="ln2889">	Volume* volume = fInode-&gt;GetVolume();</a>
<a name="ln2890"> </a>
<a name="ln2891">	// if you haven't yet access to the attributes directory, get it</a>
<a name="ln2892">	if (fAttributes == NULL) {</a>
<a name="ln2893">		if (get_vnode(volume-&gt;FSVolume(), volume-&gt;ToVnode(fInode-&gt;Attributes()),</a>
<a name="ln2894">				(void**)&amp;fAttributes) != B_OK) {</a>
<a name="ln2895">			FATAL((&quot;get_vnode() failed in AttributeIterator::GetNext(ino_t&quot;</a>
<a name="ln2896">				&quot; = %&quot; B_PRIdINO &quot;,name = \&quot;%s\&quot;)\n&quot;, fInode-&gt;ID(), name));</a>
<a name="ln2897">			return B_ENTRY_NOT_FOUND;</a>
<a name="ln2898">		}</a>
<a name="ln2899"> </a>
<a name="ln2900">		BPlusTree* tree = fAttributes-&gt;Tree();</a>
<a name="ln2901">		if (tree == NULL</a>
<a name="ln2902">			|| (fIterator = new(std::nothrow) TreeIterator(tree)) == NULL) {</a>
<a name="ln2903">			FATAL((&quot;could not get tree in AttributeIterator::GetNext(ino_t&quot;</a>
<a name="ln2904">				&quot; = %&quot; B_PRIdINO &quot;,name = \&quot;%s\&quot;)\n&quot;, fInode-&gt;ID(), name));</a>
<a name="ln2905">			return B_ENTRY_NOT_FOUND;</a>
<a name="ln2906">		}</a>
<a name="ln2907">	}</a>
<a name="ln2908"> </a>
<a name="ln2909">	uint16 length;</a>
<a name="ln2910">	ino_t id;</a>
<a name="ln2911">	status_t status = fIterator-&gt;GetNextEntry(name, &amp;length,</a>
<a name="ln2912">		B_FILE_NAME_LENGTH, &amp;id);</a>
<a name="ln2913">	if (status != B_OK)</a>
<a name="ln2914">		return status;</a>
<a name="ln2915"> </a>
<a name="ln2916">	Vnode vnode(volume, id);</a>
<a name="ln2917">	Inode* attribute;</a>
<a name="ln2918">	if ((status = vnode.Get(&amp;attribute)) == B_OK) {</a>
<a name="ln2919">		*_type = attribute-&gt;Type();</a>
<a name="ln2920">		*_length = length;</a>
<a name="ln2921">		*_id = id;</a>
<a name="ln2922">	}</a>
<a name="ln2923"> </a>
<a name="ln2924">	return status;</a>
<a name="ln2925">}</a>
<a name="ln2926"> </a>
<a name="ln2927"> </a>
<a name="ln2928">void</a>
<a name="ln2929">AttributeIterator::Update(uint16 index, int8 change)</a>
<a name="ln2930">{</a>
<a name="ln2931">	// fCurrentSmallData points already to the next item</a>
<a name="ln2932">	if (index &lt; fCurrentSmallData)</a>
<a name="ln2933">		fCurrentSmallData += change;</a>
<a name="ln2934">}</a>
<a name="ln2935"> </a>

</code></pre>
<div class="balloon" rel="162"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fRun.</p></div>
<div class="balloon" rel="1889"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v629/" target="_blank">V629</a> Consider inspecting the expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type.</p></div>
<div class="balloon" rel="1545"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v629/" target="_blank">V629</a> Consider inspecting the expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type.</p></div>
<div class="balloon" rel="1540"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v629/" target="_blank">V629</a> Consider inspecting the expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type.</p></div>
<div class="balloon" rel="1522"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v629/" target="_blank">V629</a> Consider inspecting the expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type.</p></div>
<div class="balloon" rel="1518"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v629/" target="_blank">V629</a> Consider inspecting the expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type.</p></div>
<div class="balloon" rel="439"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'fssh_dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="2020"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v629/" target="_blank">V629</a> Consider inspecting the 'runLength << fVolume->BlockShift()' expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type.</p></div>
<div class="balloon" rel="270"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'fssh_dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="435"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'status == ((- 0x7fffffff - 1) + 14)' is always false.</p></div>
<div class="balloon" rel="2903"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'fssh_dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="451"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'fssh_dprintf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="2895"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'fssh_dprintf' function. The memsize type argument is expected.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
