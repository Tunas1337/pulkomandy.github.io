
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>if_iwm.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*	$OpenBSD: if_iwm.c,v 1.167 2017/04/04 00:40:52 claudio Exp $	*/</a>
<a name="ln2"> </a>
<a name="ln3">/*</a>
<a name="ln4"> * Copyright (c) 2014 genua mbh &lt;info@genua.de&gt;</a>
<a name="ln5"> * Copyright (c) 2014 Fixup Software Ltd.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Permission to use, copy, modify, and distribute this software for any</a>
<a name="ln8"> * purpose with or without fee is hereby granted, provided that the above</a>
<a name="ln9"> * copyright notice and this permission notice appear in all copies.</a>
<a name="ln10"> *</a>
<a name="ln11"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES</a>
<a name="ln12"> * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</a>
<a name="ln13"> * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR</a>
<a name="ln14"> * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</a>
<a name="ln15"> * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</a>
<a name="ln16"> * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</a>
<a name="ln17"> * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</a>
<a name="ln18"> */</a>
<a name="ln19"> </a>
<a name="ln20">/*-</a>
<a name="ln21"> * Based on BSD-licensed source modules in the Linux iwlwifi driver,</a>
<a name="ln22"> * which were used as the reference documentation for this implementation.</a>
<a name="ln23"> *</a>
<a name="ln24"> * Driver version we are currently based off of is</a>
<a name="ln25"> * Linux 3.14.3 (tag id a2df521e42b1d9a23f620ac79dbfe8655a8391dd)</a>
<a name="ln26"> *</a>
<a name="ln27"> ***********************************************************************</a>
<a name="ln28"> *</a>
<a name="ln29"> * This file is provided under a dual BSD/GPLv2 license.  When using or</a>
<a name="ln30"> * redistributing this file, you may do so under either license.</a>
<a name="ln31"> *</a>
<a name="ln32"> * GPL LICENSE SUMMARY</a>
<a name="ln33"> *</a>
<a name="ln34"> * Copyright(c) 2007 - 2013 Intel Corporation. All rights reserved.</a>
<a name="ln35"> *</a>
<a name="ln36"> * This program is free software; you can redistribute it and/or modify</a>
<a name="ln37"> * it under the terms of version 2 of the GNU General Public License as</a>
<a name="ln38"> * published by the Free Software Foundation.</a>
<a name="ln39"> *</a>
<a name="ln40"> * This program is distributed in the hope that it will be useful, but</a>
<a name="ln41"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln42"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln43"> * General Public License for more details.</a>
<a name="ln44"> *</a>
<a name="ln45"> * You should have received a copy of the GNU General Public License</a>
<a name="ln46"> * along with this program; if not, write to the Free Software</a>
<a name="ln47"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110,</a>
<a name="ln48"> * USA</a>
<a name="ln49"> *</a>
<a name="ln50"> * The full GNU General Public License is included in this distribution</a>
<a name="ln51"> * in the file called COPYING.</a>
<a name="ln52"> *</a>
<a name="ln53"> * Contact Information:</a>
<a name="ln54"> *  Intel Linux Wireless &lt;ilw@linux.intel.com&gt;</a>
<a name="ln55"> * Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497</a>
<a name="ln56"> *</a>
<a name="ln57"> *</a>
<a name="ln58"> * BSD LICENSE</a>
<a name="ln59"> *</a>
<a name="ln60"> * Copyright(c) 2005 - 2013 Intel Corporation. All rights reserved.</a>
<a name="ln61"> * All rights reserved.</a>
<a name="ln62"> *</a>
<a name="ln63"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln64"> * modification, are permitted provided that the following conditions</a>
<a name="ln65"> * are met:</a>
<a name="ln66"> *</a>
<a name="ln67"> *  * Redistributions of source code must retain the above copyright</a>
<a name="ln68"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln69"> *  * Redistributions in binary form must reproduce the above copyright</a>
<a name="ln70"> *    notice, this list of conditions and the following disclaimer in</a>
<a name="ln71"> *    the documentation and/or other materials provided with the</a>
<a name="ln72"> *    distribution.</a>
<a name="ln73"> *  * Neither the name Intel Corporation nor the names of its</a>
<a name="ln74"> *    contributors may be used to endorse or promote products derived</a>
<a name="ln75"> *    from this software without specific prior written permission.</a>
<a name="ln76"> *</a>
<a name="ln77"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</a>
<a name="ln78"> * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</a>
<a name="ln79"> * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</a>
<a name="ln80"> * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</a>
<a name="ln81"> * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</a>
<a name="ln82"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</a>
<a name="ln83"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</a>
<a name="ln84"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</a>
<a name="ln85"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</a>
<a name="ln86"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</a>
<a name="ln87"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln88"> */</a>
<a name="ln89"> </a>
<a name="ln90">/*-</a>
<a name="ln91"> * Copyright (c) 2007-2010 Damien Bergamini &lt;damien.bergamini@free.fr&gt;</a>
<a name="ln92"> *</a>
<a name="ln93"> * Permission to use, copy, modify, and distribute this software for any</a>
<a name="ln94"> * purpose with or without fee is hereby granted, provided that the above</a>
<a name="ln95"> * copyright notice and this permission notice appear in all copies.</a>
<a name="ln96"> *</a>
<a name="ln97"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES</a>
<a name="ln98"> * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</a>
<a name="ln99"> * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR</a>
<a name="ln100"> * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</a>
<a name="ln101"> * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</a>
<a name="ln102"> * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</a>
<a name="ln103"> * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</a>
<a name="ln104"> */</a>
<a name="ln105">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln106">__FBSDID(&quot;$FreeBSD: releng/12.0/sys/dev/iwm/if_iwm.c 339038 2018-10-01 10:44:33Z bz $&quot;);</a>
<a name="ln107"> </a>
<a name="ln108">#include &quot;opt_wlan.h&quot;</a>
<a name="ln109">#include &quot;opt_iwm.h&quot;</a>
<a name="ln110"> </a>
<a name="ln111">#include &lt;sys/param.h&gt;</a>
<a name="ln112">#include &lt;sys/bus.h&gt;</a>
<a name="ln113">#include &lt;sys/conf.h&gt;</a>
<a name="ln114">#include &lt;sys/endian.h&gt;</a>
<a name="ln115">#include &lt;sys/firmware.h&gt;</a>
<a name="ln116">#include &lt;sys/kernel.h&gt;</a>
<a name="ln117">#include &lt;sys/malloc.h&gt;</a>
<a name="ln118">#include &lt;sys/mbuf.h&gt;</a>
<a name="ln119">#include &lt;sys/mutex.h&gt;</a>
<a name="ln120">#include &lt;sys/module.h&gt;</a>
<a name="ln121">#include &lt;sys/proc.h&gt;</a>
<a name="ln122">#include &lt;sys/rman.h&gt;</a>
<a name="ln123">#include &lt;sys/socket.h&gt;</a>
<a name="ln124">#include &lt;sys/sockio.h&gt;</a>
<a name="ln125">#include &lt;sys/sysctl.h&gt;</a>
<a name="ln126">#include &lt;sys/linker.h&gt;</a>
<a name="ln127"> </a>
<a name="ln128">#include &lt;machine/bus.h&gt;</a>
<a name="ln129">#include &lt;machine/endian.h&gt;</a>
<a name="ln130">#include &lt;machine/resource.h&gt;</a>
<a name="ln131"> </a>
<a name="ln132">#include &lt;dev/pci/pcivar.h&gt;</a>
<a name="ln133">#include &lt;dev/pci/pcireg.h&gt;</a>
<a name="ln134"> </a>
<a name="ln135">#include &lt;net/bpf.h&gt;</a>
<a name="ln136"> </a>
<a name="ln137">#include &lt;net/if.h&gt;</a>
<a name="ln138">#include &lt;net/if_var.h&gt;</a>
<a name="ln139">#include &lt;net/if_arp.h&gt;</a>
<a name="ln140">#include &lt;net/if_dl.h&gt;</a>
<a name="ln141">#include &lt;net/if_media.h&gt;</a>
<a name="ln142">#include &lt;net/if_types.h&gt;</a>
<a name="ln143"> </a>
<a name="ln144">#include &lt;netinet/in.h&gt;</a>
<a name="ln145">#include &lt;netinet/in_systm.h&gt;</a>
<a name="ln146">#include &lt;netinet/if_ether.h&gt;</a>
<a name="ln147">#include &lt;netinet/ip.h&gt;</a>
<a name="ln148"> </a>
<a name="ln149">#include &lt;net80211/ieee80211_var.h&gt;</a>
<a name="ln150">#include &lt;net80211/ieee80211_regdomain.h&gt;</a>
<a name="ln151">#include &lt;net80211/ieee80211_ratectl.h&gt;</a>
<a name="ln152">#include &lt;net80211/ieee80211_radiotap.h&gt;</a>
<a name="ln153"> </a>
<a name="ln154">#include &lt;dev/iwm/if_iwmreg.h&gt;</a>
<a name="ln155">#include &lt;dev/iwm/if_iwmvar.h&gt;</a>
<a name="ln156">#include &lt;dev/iwm/if_iwm_config.h&gt;</a>
<a name="ln157">#include &lt;dev/iwm/if_iwm_debug.h&gt;</a>
<a name="ln158">#include &lt;dev/iwm/if_iwm_notif_wait.h&gt;</a>
<a name="ln159">#include &lt;dev/iwm/if_iwm_util.h&gt;</a>
<a name="ln160">#include &lt;dev/iwm/if_iwm_binding.h&gt;</a>
<a name="ln161">#include &lt;dev/iwm/if_iwm_phy_db.h&gt;</a>
<a name="ln162">#include &lt;dev/iwm/if_iwm_mac_ctxt.h&gt;</a>
<a name="ln163">#include &lt;dev/iwm/if_iwm_phy_ctxt.h&gt;</a>
<a name="ln164">#include &lt;dev/iwm/if_iwm_time_event.h&gt;</a>
<a name="ln165">#include &lt;dev/iwm/if_iwm_power.h&gt;</a>
<a name="ln166">#include &lt;dev/iwm/if_iwm_scan.h&gt;</a>
<a name="ln167">#include &lt;dev/iwm/if_iwm_sf.h&gt;</a>
<a name="ln168">#include &lt;dev/iwm/if_iwm_sta.h&gt;</a>
<a name="ln169"> </a>
<a name="ln170">#include &lt;dev/iwm/if_iwm_pcie_trans.h&gt;</a>
<a name="ln171">#include &lt;dev/iwm/if_iwm_led.h&gt;</a>
<a name="ln172">#include &lt;dev/iwm/if_iwm_fw.h&gt;</a>
<a name="ln173"> </a>
<a name="ln174">/* From DragonflyBSD */</a>
<a name="ln175">#define mtodoff(m, t, off)      ((t)((m)-&gt;m_data + (off)))</a>
<a name="ln176"> </a>
<a name="ln177">const uint8_t iwm_nvm_channels[] = {</a>
<a name="ln178">	/* 2.4 GHz */</a>
<a name="ln179">	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,</a>
<a name="ln180">	/* 5 GHz */</a>
<a name="ln181">	36, 40, 44, 48, 52, 56, 60, 64,</a>
<a name="ln182">	100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144,</a>
<a name="ln183">	149, 153, 157, 161, 165</a>
<a name="ln184">};</a>
<a name="ln185">_Static_assert(nitems(iwm_nvm_channels) &lt;= IWM_NUM_CHANNELS,</a>
<a name="ln186">    &quot;IWM_NUM_CHANNELS is too small&quot;);</a>
<a name="ln187"> </a>
<a name="ln188">const uint8_t iwm_nvm_channels_8000[] = {</a>
<a name="ln189">	/* 2.4 GHz */</a>
<a name="ln190">	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,</a>
<a name="ln191">	/* 5 GHz */</a>
<a name="ln192">	36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92,</a>
<a name="ln193">	96, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144,</a>
<a name="ln194">	149, 153, 157, 161, 165, 169, 173, 177, 181</a>
<a name="ln195">};</a>
<a name="ln196">_Static_assert(nitems(iwm_nvm_channels_8000) &lt;= IWM_NUM_CHANNELS_8000,</a>
<a name="ln197">    &quot;IWM_NUM_CHANNELS_8000 is too small&quot;);</a>
<a name="ln198"> </a>
<a name="ln199">#define IWM_NUM_2GHZ_CHANNELS	14</a>
<a name="ln200">#define IWM_N_HW_ADDR_MASK	0xF</a>
<a name="ln201"> </a>
<a name="ln202">/*</a>
<a name="ln203"> * XXX For now, there's simply a fixed set of rate table entries</a>
<a name="ln204"> * that are populated.</a>
<a name="ln205"> */</a>
<a name="ln206">const struct iwm_rate {</a>
<a name="ln207">	uint8_t rate;</a>
<a name="ln208">	uint8_t plcp;</a>
<a name="ln209">} iwm_rates[] = {</a>
<a name="ln210">	{   2,	IWM_RATE_1M_PLCP  },</a>
<a name="ln211">	{   4,	IWM_RATE_2M_PLCP  },</a>
<a name="ln212">	{  11,	IWM_RATE_5M_PLCP  },</a>
<a name="ln213">	{  22,	IWM_RATE_11M_PLCP },</a>
<a name="ln214">	{  12,	IWM_RATE_6M_PLCP  },</a>
<a name="ln215">	{  18,	IWM_RATE_9M_PLCP  },</a>
<a name="ln216">	{  24,	IWM_RATE_12M_PLCP },</a>
<a name="ln217">	{  36,	IWM_RATE_18M_PLCP },</a>
<a name="ln218">	{  48,	IWM_RATE_24M_PLCP },</a>
<a name="ln219">	{  72,	IWM_RATE_36M_PLCP },</a>
<a name="ln220">	{  96,	IWM_RATE_48M_PLCP },</a>
<a name="ln221">	{ 108,	IWM_RATE_54M_PLCP },</a>
<a name="ln222">};</a>
<a name="ln223">#define IWM_RIDX_CCK	0</a>
<a name="ln224">#define IWM_RIDX_OFDM	4</a>
<a name="ln225">#define IWM_RIDX_MAX	(nitems(iwm_rates)-1)</a>
<a name="ln226">#define IWM_RIDX_IS_CCK(_i_) ((_i_) &lt; IWM_RIDX_OFDM)</a>
<a name="ln227">#define IWM_RIDX_IS_OFDM(_i_) ((_i_) &gt;= IWM_RIDX_OFDM)</a>
<a name="ln228"> </a>
<a name="ln229">struct iwm_nvm_section {</a>
<a name="ln230">	uint16_t length;</a>
<a name="ln231">	uint8_t *data;</a>
<a name="ln232">};</a>
<a name="ln233"> </a>
<a name="ln234">#define IWM_MVM_UCODE_ALIVE_TIMEOUT	(5*hz)</a>
<a name="ln235">#define IWM_MVM_UCODE_CALIB_TIMEOUT	(10*hz)</a>
<a name="ln236"> </a>
<a name="ln237">struct iwm_mvm_alive_data {</a>
<a name="ln238">	int valid;</a>
<a name="ln239">	uint32_t scd_base_addr;</a>
<a name="ln240">};</a>
<a name="ln241"> </a>
<a name="ln242">static int	iwm_store_cscheme(struct iwm_softc *, const uint8_t *, size_t);</a>
<a name="ln243">static int	iwm_firmware_store_section(struct iwm_softc *,</a>
<a name="ln244">                                           enum iwm_ucode_type,</a>
<a name="ln245">                                           const uint8_t *, size_t);</a>
<a name="ln246">static int	iwm_set_default_calib(struct iwm_softc *, const void *);</a>
<a name="ln247">static void	iwm_fw_info_free(struct iwm_fw_info *);</a>
<a name="ln248">static int	iwm_read_firmware(struct iwm_softc *);</a>
<a name="ln249">static int	iwm_alloc_fwmem(struct iwm_softc *);</a>
<a name="ln250">static int	iwm_alloc_sched(struct iwm_softc *);</a>
<a name="ln251">static int	iwm_alloc_kw(struct iwm_softc *);</a>
<a name="ln252">static int	iwm_alloc_ict(struct iwm_softc *);</a>
<a name="ln253">static int	iwm_alloc_rx_ring(struct iwm_softc *, struct iwm_rx_ring *);</a>
<a name="ln254">static void	iwm_reset_rx_ring(struct iwm_softc *, struct iwm_rx_ring *);</a>
<a name="ln255">static void	iwm_free_rx_ring(struct iwm_softc *, struct iwm_rx_ring *);</a>
<a name="ln256">static int	iwm_alloc_tx_ring(struct iwm_softc *, struct iwm_tx_ring *,</a>
<a name="ln257">                                  int);</a>
<a name="ln258">static void	iwm_reset_tx_ring(struct iwm_softc *, struct iwm_tx_ring *);</a>
<a name="ln259">static void	iwm_free_tx_ring(struct iwm_softc *, struct iwm_tx_ring *);</a>
<a name="ln260">static void	iwm_enable_interrupts(struct iwm_softc *);</a>
<a name="ln261">static void	iwm_restore_interrupts(struct iwm_softc *);</a>
<a name="ln262">static void	iwm_disable_interrupts(struct iwm_softc *);</a>
<a name="ln263">static void	iwm_ict_reset(struct iwm_softc *);</a>
<a name="ln264">static int	iwm_allow_mcast(struct ieee80211vap *, struct iwm_softc *);</a>
<a name="ln265">static void	iwm_stop_device(struct iwm_softc *);</a>
<a name="ln266">static void	iwm_mvm_nic_config(struct iwm_softc *);</a>
<a name="ln267">static int	iwm_nic_rx_init(struct iwm_softc *);</a>
<a name="ln268">static int	iwm_nic_tx_init(struct iwm_softc *);</a>
<a name="ln269">static int	iwm_nic_init(struct iwm_softc *);</a>
<a name="ln270">static int	iwm_trans_pcie_fw_alive(struct iwm_softc *, uint32_t);</a>
<a name="ln271">static int	iwm_nvm_read_chunk(struct iwm_softc *, uint16_t, uint16_t,</a>
<a name="ln272">                                   uint16_t, uint8_t *, uint16_t *);</a>
<a name="ln273">static int	iwm_nvm_read_section(struct iwm_softc *, uint16_t, uint8_t *,</a>
<a name="ln274">				     uint16_t *, uint32_t);</a>
<a name="ln275">static uint32_t	iwm_eeprom_channel_flags(uint16_t);</a>
<a name="ln276">static void	iwm_add_channel_band(struct iwm_softc *,</a>
<a name="ln277">		    struct ieee80211_channel[], int, int *, int, size_t,</a>
<a name="ln278">		    const uint8_t[]);</a>
<a name="ln279">static void	iwm_init_channel_map(struct ieee80211com *, int, int *,</a>
<a name="ln280">		    struct ieee80211_channel[]);</a>
<a name="ln281">static struct iwm_nvm_data *</a>
<a name="ln282">	iwm_parse_nvm_data(struct iwm_softc *, const uint16_t *,</a>
<a name="ln283">			   const uint16_t *, const uint16_t *,</a>
<a name="ln284">			   const uint16_t *, const uint16_t *,</a>
<a name="ln285">			   const uint16_t *);</a>
<a name="ln286">static void	iwm_free_nvm_data(struct iwm_nvm_data *);</a>
<a name="ln287">static void	iwm_set_hw_address_family_8000(struct iwm_softc *,</a>
<a name="ln288">					       struct iwm_nvm_data *,</a>
<a name="ln289">					       const uint16_t *,</a>
<a name="ln290">					       const uint16_t *);</a>
<a name="ln291">static int	iwm_get_sku(const struct iwm_softc *, const uint16_t *,</a>
<a name="ln292">			    const uint16_t *);</a>
<a name="ln293">static int	iwm_get_nvm_version(const struct iwm_softc *, const uint16_t *);</a>
<a name="ln294">static int	iwm_get_radio_cfg(const struct iwm_softc *, const uint16_t *,</a>
<a name="ln295">				  const uint16_t *);</a>
<a name="ln296">static int	iwm_get_n_hw_addrs(const struct iwm_softc *,</a>
<a name="ln297">				   const uint16_t *);</a>
<a name="ln298">static void	iwm_set_radio_cfg(const struct iwm_softc *,</a>
<a name="ln299">				  struct iwm_nvm_data *, uint32_t);</a>
<a name="ln300">static struct iwm_nvm_data *</a>
<a name="ln301">	iwm_parse_nvm_sections(struct iwm_softc *, struct iwm_nvm_section *);</a>
<a name="ln302">static int	iwm_nvm_init(struct iwm_softc *);</a>
<a name="ln303">static int	iwm_pcie_load_section(struct iwm_softc *, uint8_t,</a>
<a name="ln304">				      const struct iwm_fw_desc *);</a>
<a name="ln305">static int	iwm_pcie_load_firmware_chunk(struct iwm_softc *, uint32_t,</a>
<a name="ln306">					     bus_addr_t, uint32_t);</a>
<a name="ln307">static int	iwm_pcie_load_cpu_sections_8000(struct iwm_softc *sc,</a>
<a name="ln308">						const struct iwm_fw_img *,</a>
<a name="ln309">						int, int *);</a>
<a name="ln310">static int	iwm_pcie_load_cpu_sections(struct iwm_softc *,</a>
<a name="ln311">					   const struct iwm_fw_img *,</a>
<a name="ln312">					   int, int *);</a>
<a name="ln313">static int	iwm_pcie_load_given_ucode_8000(struct iwm_softc *,</a>
<a name="ln314">					       const struct iwm_fw_img *);</a>
<a name="ln315">static int	iwm_pcie_load_given_ucode(struct iwm_softc *,</a>
<a name="ln316">					  const struct iwm_fw_img *);</a>
<a name="ln317">static int	iwm_start_fw(struct iwm_softc *, const struct iwm_fw_img *);</a>
<a name="ln318">static int	iwm_send_tx_ant_cfg(struct iwm_softc *, uint8_t);</a>
<a name="ln319">static int	iwm_send_phy_cfg_cmd(struct iwm_softc *);</a>
<a name="ln320">static int	iwm_mvm_load_ucode_wait_alive(struct iwm_softc *,</a>
<a name="ln321">                                              enum iwm_ucode_type);</a>
<a name="ln322">static int	iwm_run_init_mvm_ucode(struct iwm_softc *, int);</a>
<a name="ln323">static int	iwm_mvm_config_ltr(struct iwm_softc *sc);</a>
<a name="ln324">static int	iwm_rx_addbuf(struct iwm_softc *, int, int);</a>
<a name="ln325">static int	iwm_mvm_get_signal_strength(struct iwm_softc *,</a>
<a name="ln326">					    struct iwm_rx_phy_info *);</a>
<a name="ln327">static void	iwm_mvm_rx_rx_phy_cmd(struct iwm_softc *,</a>
<a name="ln328">                                      struct iwm_rx_packet *);</a>
<a name="ln329">static int	iwm_get_noise(struct iwm_softc *,</a>
<a name="ln330">		    const struct iwm_mvm_statistics_rx_non_phy *);</a>
<a name="ln331">static void	iwm_mvm_handle_rx_statistics(struct iwm_softc *,</a>
<a name="ln332">		    struct iwm_rx_packet *);</a>
<a name="ln333">static boolean_t iwm_mvm_rx_rx_mpdu(struct iwm_softc *, struct mbuf *,</a>
<a name="ln334">				    uint32_t, boolean_t);</a>
<a name="ln335">static int	iwm_mvm_rx_tx_cmd_single(struct iwm_softc *,</a>
<a name="ln336">                                         struct iwm_rx_packet *,</a>
<a name="ln337">				         struct iwm_node *);</a>
<a name="ln338">static void	iwm_mvm_rx_tx_cmd(struct iwm_softc *, struct iwm_rx_packet *);</a>
<a name="ln339">static void	iwm_cmd_done(struct iwm_softc *, struct iwm_rx_packet *);</a>
<a name="ln340">#if 0</a>
<a name="ln341">static void	iwm_update_sched(struct iwm_softc *, int, int, uint8_t,</a>
<a name="ln342">                                 uint16_t);</a>
<a name="ln343">#endif</a>
<a name="ln344">static const struct iwm_rate *</a>
<a name="ln345">	iwm_tx_fill_cmd(struct iwm_softc *, struct iwm_node *,</a>
<a name="ln346">			struct mbuf *, struct iwm_tx_cmd *);</a>
<a name="ln347">static int	iwm_tx(struct iwm_softc *, struct mbuf *,</a>
<a name="ln348">                       struct ieee80211_node *, int);</a>
<a name="ln349">static int	iwm_raw_xmit(struct ieee80211_node *, struct mbuf *,</a>
<a name="ln350">			     const struct ieee80211_bpf_params *);</a>
<a name="ln351">static int	iwm_mvm_update_quotas(struct iwm_softc *, struct iwm_vap *);</a>
<a name="ln352">static int	iwm_auth(struct ieee80211vap *, struct iwm_softc *);</a>
<a name="ln353">static struct ieee80211_node *</a>
<a name="ln354">		iwm_node_alloc(struct ieee80211vap *,</a>
<a name="ln355">		               const uint8_t[IEEE80211_ADDR_LEN]);</a>
<a name="ln356">static uint8_t	iwm_rate_from_ucode_rate(uint32_t);</a>
<a name="ln357">static int	iwm_rate2ridx(struct iwm_softc *, uint8_t);</a>
<a name="ln358">static void	iwm_setrates(struct iwm_softc *, struct iwm_node *, int);</a>
<a name="ln359">static int	iwm_media_change(struct ifnet *);</a>
<a name="ln360">static int	iwm_newstate(struct ieee80211vap *, enum ieee80211_state, int);</a>
<a name="ln361">static void	iwm_endscan_cb(void *, int);</a>
<a name="ln362">static int	iwm_send_bt_init_conf(struct iwm_softc *);</a>
<a name="ln363">static boolean_t iwm_mvm_is_lar_supported(struct iwm_softc *);</a>
<a name="ln364">static boolean_t iwm_mvm_is_wifi_mcc_supported(struct iwm_softc *);</a>
<a name="ln365">static int	iwm_send_update_mcc_cmd(struct iwm_softc *, const char *);</a>
<a name="ln366">static void	iwm_mvm_tt_tx_backoff(struct iwm_softc *, uint32_t);</a>
<a name="ln367">static int	iwm_init_hw(struct iwm_softc *);</a>
<a name="ln368">static void	iwm_init(struct iwm_softc *);</a>
<a name="ln369">static void	iwm_start(struct iwm_softc *);</a>
<a name="ln370">static void	iwm_stop(struct iwm_softc *);</a>
<a name="ln371">static void	iwm_watchdog(void *);</a>
<a name="ln372">static void	iwm_parent(struct ieee80211com *);</a>
<a name="ln373">#ifdef IWM_DEBUG</a>
<a name="ln374">static const char *</a>
<a name="ln375">		iwm_desc_lookup(uint32_t);</a>
<a name="ln376">static void	iwm_nic_error(struct iwm_softc *);</a>
<a name="ln377">static void	iwm_nic_umac_error(struct iwm_softc *);</a>
<a name="ln378">#endif</a>
<a name="ln379">static void	iwm_handle_rxb(struct iwm_softc *, struct mbuf *);</a>
<a name="ln380">static void	iwm_notif_intr(struct iwm_softc *);</a>
<a name="ln381">static void	iwm_intr(void *);</a>
<a name="ln382">static int	iwm_attach(device_t);</a>
<a name="ln383">static int	iwm_is_valid_ether_addr(uint8_t *);</a>
<a name="ln384">static void	iwm_preinit(void *);</a>
<a name="ln385">static int	iwm_detach_local(struct iwm_softc *sc, int);</a>
<a name="ln386">static void	iwm_init_task(void *);</a>
<a name="ln387">static void	iwm_radiotap_attach(struct iwm_softc *);</a>
<a name="ln388">static struct ieee80211vap *</a>
<a name="ln389">		iwm_vap_create(struct ieee80211com *,</a>
<a name="ln390">		               const char [IFNAMSIZ], int,</a>
<a name="ln391">		               enum ieee80211_opmode, int,</a>
<a name="ln392">		               const uint8_t [IEEE80211_ADDR_LEN],</a>
<a name="ln393">		               const uint8_t [IEEE80211_ADDR_LEN]);</a>
<a name="ln394">static void	iwm_vap_delete(struct ieee80211vap *);</a>
<a name="ln395">static void	iwm_xmit_queue_drain(struct iwm_softc *);</a>
<a name="ln396">static void	iwm_scan_start(struct ieee80211com *);</a>
<a name="ln397">static void	iwm_scan_end(struct ieee80211com *);</a>
<a name="ln398">static void	iwm_update_mcast(struct ieee80211com *);</a>
<a name="ln399">static void	iwm_set_channel(struct ieee80211com *);</a>
<a name="ln400">static void	iwm_scan_curchan(struct ieee80211_scan_state *, unsigned long);</a>
<a name="ln401">static void	iwm_scan_mindwell(struct ieee80211_scan_state *);</a>
<a name="ln402">static int	iwm_detach(device_t);</a>
<a name="ln403"> </a>
<a name="ln404">static int	iwm_lar_disable = 0;</a>
<a name="ln405">TUNABLE_INT(&quot;hw.iwm.lar.disable&quot;, &amp;iwm_lar_disable);</a>
<a name="ln406"> </a>
<a name="ln407">/*</a>
<a name="ln408"> * Firmware parser.</a>
<a name="ln409"> */</a>
<a name="ln410"> </a>
<a name="ln411">static int</a>
<a name="ln412">iwm_store_cscheme(struct iwm_softc *sc, const uint8_t *data, size_t dlen)</a>
<a name="ln413">{</a>
<a name="ln414">	const struct iwm_fw_cscheme_list *l = (const void *)data;</a>
<a name="ln415"> </a>
<a name="ln416">	if (dlen &lt; sizeof(*l) ||</a>
<a name="ln417">	    dlen &lt; sizeof(l-&gt;size) + l-&gt;size * sizeof(*l-&gt;cs))</a>
<a name="ln418">		return EINVAL;</a>
<a name="ln419"> </a>
<a name="ln420">	/* we don't actually store anything for now, always use s/w crypto */</a>
<a name="ln421"> </a>
<a name="ln422">	return 0;</a>
<a name="ln423">}</a>
<a name="ln424"> </a>
<a name="ln425">static int</a>
<a name="ln426">iwm_firmware_store_section(struct iwm_softc *sc,</a>
<a name="ln427">    enum iwm_ucode_type type, const uint8_t *data, size_t dlen)</a>
<a name="ln428">{</a>
<a name="ln429">	struct iwm_fw_img *fws;</a>
<a name="ln430">	struct iwm_fw_desc *fwone;</a>
<a name="ln431"> </a>
<a name="ln432">	if (type &gt;= IWM_UCODE_TYPE_MAX)</a>
<a name="ln433">		return EINVAL;</a>
<a name="ln434">	if (dlen &lt; sizeof(uint32_t))</a>
<a name="ln435">		return EINVAL;</a>
<a name="ln436"> </a>
<a name="ln437">	fws = &amp;sc-&gt;sc_fw.img[type];</a>
<a name="ln438">	if (fws-&gt;fw_count &gt;= IWM_UCODE_SECTION_MAX)</a>
<a name="ln439">		return EINVAL;</a>
<a name="ln440"> </a>
<a name="ln441">	fwone = &amp;fws-&gt;sec[fws-&gt;fw_count];</a>
<a name="ln442"> </a>
<a name="ln443">	/* first 32bit are device load offset */</a>
<a name="ln444">	memcpy(&amp;fwone-&gt;offset, data, sizeof(uint32_t));</a>
<a name="ln445"> </a>
<a name="ln446">	/* rest is data */</a>
<a name="ln447">	fwone-&gt;data = data + sizeof(uint32_t);</a>
<a name="ln448">	fwone-&gt;len = dlen - sizeof(uint32_t);</a>
<a name="ln449"> </a>
<a name="ln450">	fws-&gt;fw_count++;</a>
<a name="ln451"> </a>
<a name="ln452">	return 0;</a>
<a name="ln453">}</a>
<a name="ln454"> </a>
<a name="ln455">#define IWM_DEFAULT_SCAN_CHANNELS 40</a>
<a name="ln456"> </a>
<a name="ln457">/* iwlwifi: iwl-drv.c */</a>
<a name="ln458">struct iwm_tlv_calib_data {</a>
<a name="ln459">	uint32_t ucode_type;</a>
<a name="ln460">	struct iwm_tlv_calib_ctrl calib;</a>
<a name="ln461">} __packed;</a>
<a name="ln462"> </a>
<a name="ln463">static int</a>
<a name="ln464">iwm_set_default_calib(struct iwm_softc *sc, const void *data)</a>
<a name="ln465">{</a>
<a name="ln466">	const struct iwm_tlv_calib_data *def_calib = data;</a>
<a name="ln467">	uint32_t ucode_type = le32toh(def_calib-&gt;ucode_type);</a>
<a name="ln468"> </a>
<a name="ln469">	if (ucode_type &gt;= IWM_UCODE_TYPE_MAX) {</a>
<a name="ln470">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln471">		    &quot;Wrong ucode_type %u for default &quot;</a>
<a name="ln472">		    &quot;calibration.\n&quot;, ucode_type);</a>
<a name="ln473">		return EINVAL;</a>
<a name="ln474">	}</a>
<a name="ln475"> </a>
<a name="ln476">	sc-&gt;sc_default_calib[ucode_type].flow_trigger =</a>
<a name="ln477">	    def_calib-&gt;calib.flow_trigger;</a>
<a name="ln478">	sc-&gt;sc_default_calib[ucode_type].event_trigger =</a>
<a name="ln479">	    def_calib-&gt;calib.event_trigger;</a>
<a name="ln480"> </a>
<a name="ln481">	return 0;</a>
<a name="ln482">}</a>
<a name="ln483"> </a>
<a name="ln484">static int</a>
<a name="ln485">iwm_set_ucode_api_flags(struct iwm_softc *sc, const uint8_t *data,</a>
<a name="ln486">			struct iwm_ucode_capabilities *capa)</a>
<a name="ln487">{</a>
<a name="ln488">	const struct iwm_ucode_api *ucode_api = (const void *)data;</a>
<a name="ln489">	uint32_t api_index = le32toh(ucode_api-&gt;api_index);</a>
<a name="ln490">	uint32_t api_flags = le32toh(ucode_api-&gt;api_flags);</a>
<a name="ln491">	int i;</a>
<a name="ln492"> </a>
<a name="ln493">	if (api_index &gt;= howmany(IWM_NUM_UCODE_TLV_API, 32)) {</a>
<a name="ln494">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln495">		    &quot;api flags index %d larger than supported by driver\n&quot;,</a>
<a name="ln496">		    api_index);</a>
<a name="ln497">		/* don't return an error so we can load FW that has more bits */</a>
<a name="ln498">		return 0;</a>
<a name="ln499">	}</a>
<a name="ln500"> </a>
<a name="ln501">	for (i = 0; i &lt; 32; i++) {</a>
<a name="ln502">		if (api_flags &amp; (1U &lt;&lt; i))</a>
<a name="ln503">			setbit(capa-&gt;enabled_api, i + 32 * api_index);</a>
<a name="ln504">	}</a>
<a name="ln505"> </a>
<a name="ln506">	return 0;</a>
<a name="ln507">}</a>
<a name="ln508"> </a>
<a name="ln509">static int</a>
<a name="ln510">iwm_set_ucode_capabilities(struct iwm_softc *sc, const uint8_t *data,</a>
<a name="ln511">			   struct iwm_ucode_capabilities *capa)</a>
<a name="ln512">{</a>
<a name="ln513">	const struct iwm_ucode_capa *ucode_capa = (const void *)data;</a>
<a name="ln514">	uint32_t api_index = le32toh(ucode_capa-&gt;api_index);</a>
<a name="ln515">	uint32_t api_flags = le32toh(ucode_capa-&gt;api_capa);</a>
<a name="ln516">	int i;</a>
<a name="ln517"> </a>
<a name="ln518">	if (api_index &gt;= howmany(IWM_NUM_UCODE_TLV_CAPA, 32)) {</a>
<a name="ln519">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln520">		    &quot;capa flags index %d larger than supported by driver\n&quot;,</a>
<a name="ln521">		    api_index);</a>
<a name="ln522">		/* don't return an error so we can load FW that has more bits */</a>
<a name="ln523">		return 0;</a>
<a name="ln524">	}</a>
<a name="ln525"> </a>
<a name="ln526">	for (i = 0; i &lt; 32; i++) {</a>
<a name="ln527">		if (api_flags &amp; (1U &lt;&lt; i))</a>
<a name="ln528">			setbit(capa-&gt;enabled_capa, i + 32 * api_index);</a>
<a name="ln529">	}</a>
<a name="ln530"> </a>
<a name="ln531">	return 0;</a>
<a name="ln532">}</a>
<a name="ln533"> </a>
<a name="ln534">static void</a>
<a name="ln535">iwm_fw_info_free(struct iwm_fw_info *fw)</a>
<a name="ln536">{</a>
<a name="ln537">	firmware_put(fw-&gt;fw_fp, FIRMWARE_UNLOAD);</a>
<a name="ln538">	fw-&gt;fw_fp = NULL;</a>
<a name="ln539">	memset(fw-&gt;img, 0, sizeof(fw-&gt;img));</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542">static int</a>
<a name="ln543">iwm_read_firmware(struct iwm_softc *sc)</a>
<a name="ln544">{</a>
<a name="ln545">	struct iwm_fw_info *fw = &amp;sc-&gt;sc_fw;</a>
<a name="ln546">	const struct iwm_tlv_ucode_header *uhdr;</a>
<a name="ln547">	const struct iwm_ucode_tlv *tlv;</a>
<a name="ln548">	struct iwm_ucode_capabilities *capa = &amp;sc-&gt;sc_fw.ucode_capa;</a>
<a name="ln549">	enum iwm_ucode_tlv_type tlv_type;</a>
<a name="ln550">	const struct firmware *fwp;</a>
<a name="ln551">	const uint8_t *data;</a>
<a name="ln552">	uint32_t tlv_len;</a>
<a name="ln553">	uint32_t usniffer_img;</a>
<a name="ln554">	const uint8_t *tlv_data;</a>
<a name="ln555">	uint32_t paging_mem_size;</a>
<a name="ln556">	int num_of_cpus;</a>
<a name="ln557">	int error = 0;</a>
<a name="ln558">	size_t len;</a>
<a name="ln559"> </a>
<a name="ln560">	/*</a>
<a name="ln561">	 * Load firmware into driver memory.</a>
<a name="ln562">	 * fw_fp will be set.</a>
<a name="ln563">	 */</a>
<a name="ln564">	fwp = firmware_get(sc-&gt;cfg-&gt;fw_name);</a>
<a name="ln565">	if (fwp == NULL) {</a>
<a name="ln566">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln567">		    &quot;could not read firmware %s (error %d)\n&quot;,</a>
<a name="ln568">		    sc-&gt;cfg-&gt;fw_name, error);</a>
<a name="ln569">		goto out;</a>
<a name="ln570">	}</a>
<a name="ln571">	fw-&gt;fw_fp = fwp;</a>
<a name="ln572"> </a>
<a name="ln573">	/* (Re-)Initialize default values. */</a>
<a name="ln574">	capa-&gt;flags = 0;</a>
<a name="ln575">	capa-&gt;max_probe_length = IWM_DEFAULT_MAX_PROBE_LENGTH;</a>
<a name="ln576">	capa-&gt;n_scan_channels = IWM_DEFAULT_SCAN_CHANNELS;</a>
<a name="ln577">	memset(capa-&gt;enabled_capa, 0, sizeof(capa-&gt;enabled_capa));</a>
<a name="ln578">	memset(capa-&gt;enabled_api, 0, sizeof(capa-&gt;enabled_api));</a>
<a name="ln579">	memset(sc-&gt;sc_fw_mcc, 0, sizeof(sc-&gt;sc_fw_mcc));</a>
<a name="ln580"> </a>
<a name="ln581">	/*</a>
<a name="ln582">	 * Parse firmware contents</a>
<a name="ln583">	 */</a>
<a name="ln584"> </a>
<a name="ln585">	uhdr = (const void *)fw-&gt;fw_fp-&gt;data;</a>
<a name="ln586">	if (*(const uint32_t *)fw-&gt;fw_fp-&gt;data != 0</a>
<a name="ln587">	    || le32toh(uhdr-&gt;magic) != IWM_TLV_UCODE_MAGIC) {</a>
<a name="ln588">		device_printf(sc-&gt;sc_dev, &quot;invalid firmware %s\n&quot;,</a>
<a name="ln589">		    sc-&gt;cfg-&gt;fw_name);</a>
<a name="ln590">		error = EINVAL;</a>
<a name="ln591">		goto out;</a>
<a name="ln592">	}</a>
<a name="ln593"> </a>
<a name="ln594">	snprintf(sc-&gt;sc_fwver, sizeof(sc-&gt;sc_fwver), &quot;%u.%u (API ver %u)&quot;,</a>
<a name="ln595">	    IWM_UCODE_MAJOR(le32toh(uhdr-&gt;ver)),</a>
<a name="ln596">	    IWM_UCODE_MINOR(le32toh(uhdr-&gt;ver)),</a>
<a name="ln597">	    IWM_UCODE_API(le32toh(uhdr-&gt;ver)));</a>
<a name="ln598">	data = uhdr-&gt;data;</a>
<a name="ln599">	len = fw-&gt;fw_fp-&gt;datasize - sizeof(*uhdr);</a>
<a name="ln600"> </a>
<a name="ln601">	while (len &gt;= sizeof(*tlv)) {</a>
<a name="ln602">		len -= sizeof(*tlv);</a>
<a name="ln603">		tlv = (const void *)data;</a>
<a name="ln604"> </a>
<a name="ln605">		tlv_len = le32toh(tlv-&gt;length);</a>
<a name="ln606">		tlv_type = le32toh(tlv-&gt;type);</a>
<a name="ln607">		tlv_data = tlv-&gt;data;</a>
<a name="ln608"> </a>
<a name="ln609">		if (len &lt; tlv_len) {</a>
<a name="ln610">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln611">			    &quot;firmware too short: %zu bytes\n&quot;,</a>
<a name="ln612">			    len);</a>
<a name="ln613">			error = EINVAL;</a>
<a name="ln614">			goto parse_out;</a>
<a name="ln615">		}</a>
<a name="ln616">		len -= roundup2(tlv_len, 4);</a>
<a name="ln617">		data += sizeof(*tlv) + roundup2(tlv_len, 4);</a>
<a name="ln618"> </a>
<a name="ln619">		switch ((int)tlv_type) {</a>
<a name="ln620">		case IWM_UCODE_TLV_PROBE_MAX_LEN:</a>
<a name="ln621">			if (tlv_len != sizeof(uint32_t)) {</a>
<a name="ln622">				device_printf(sc-&gt;sc_dev,</a>
<a name="ln623">				    &quot;%s: PROBE_MAX_LEN (%u) != sizeof(uint32_t)\n&quot;,</a>
<a name="ln624">				    __func__, tlv_len);</a>
<a name="ln625">				error = EINVAL;</a>
<a name="ln626">				goto parse_out;</a>
<a name="ln627">			}</a>
<a name="ln628">			capa-&gt;max_probe_length =</a>
<a name="ln629">			    le32_to_cpup((const uint32_t *)tlv_data);</a>
<a name="ln630">			/* limit it to something sensible */</a>
<a name="ln631">			if (capa-&gt;max_probe_length &gt;</a>
<a name="ln632">			    IWM_SCAN_OFFLOAD_PROBE_REQ_SIZE) {</a>
<a name="ln633">				IWM_DPRINTF(sc, IWM_DEBUG_FIRMWARE_TLV,</a>
<a name="ln634">				    &quot;%s: IWM_UCODE_TLV_PROBE_MAX_LEN &quot;</a>
<a name="ln635">				    &quot;ridiculous\n&quot;, __func__);</a>
<a name="ln636">				error = EINVAL;</a>
<a name="ln637">				goto parse_out;</a>
<a name="ln638">			}</a>
<a name="ln639">			break;</a>
<a name="ln640">		case IWM_UCODE_TLV_PAN:</a>
<a name="ln641">			if (tlv_len) {</a>
<a name="ln642">				device_printf(sc-&gt;sc_dev,</a>
<a name="ln643">				    &quot;%s: IWM_UCODE_TLV_PAN: tlv_len (%u) &gt; 0\n&quot;,</a>
<a name="ln644">				    __func__, tlv_len);</a>
<a name="ln645">				error = EINVAL;</a>
<a name="ln646">				goto parse_out;</a>
<a name="ln647">			}</a>
<a name="ln648">			capa-&gt;flags |= IWM_UCODE_TLV_FLAGS_PAN;</a>
<a name="ln649">			break;</a>
<a name="ln650">		case IWM_UCODE_TLV_FLAGS:</a>
<a name="ln651">			if (tlv_len &lt; sizeof(uint32_t)) {</a>
<a name="ln652">				device_printf(sc-&gt;sc_dev,</a>
<a name="ln653">				    &quot;%s: IWM_UCODE_TLV_FLAGS: tlv_len (%u) &lt; sizeof(uint32_t)\n&quot;,</a>
<a name="ln654">				    __func__, tlv_len);</a>
<a name="ln655">				error = EINVAL;</a>
<a name="ln656">				goto parse_out;</a>
<a name="ln657">			}</a>
<a name="ln658">			if (tlv_len % sizeof(uint32_t)) {</a>
<a name="ln659">				device_printf(sc-&gt;sc_dev,</a>
<a name="ln660">				    &quot;%s: IWM_UCODE_TLV_FLAGS: tlv_len (%u) %% sizeof(uint32_t)\n&quot;,</a>
<a name="ln661">				    __func__, tlv_len);</a>
<a name="ln662">				error = EINVAL;</a>
<a name="ln663">				goto parse_out;</a>
<a name="ln664">			}</a>
<a name="ln665">			/*</a>
<a name="ln666">			 * Apparently there can be many flags, but Linux driver</a>
<a name="ln667">			 * parses only the first one, and so do we.</a>
<a name="ln668">			 *</a>
<a name="ln669">			 * XXX: why does this override IWM_UCODE_TLV_PAN?</a>
<a name="ln670">			 * Intentional or a bug?  Observations from</a>
<a name="ln671">			 * current firmware file:</a>
<a name="ln672">			 *  1) TLV_PAN is parsed first</a>
<a name="ln673">			 *  2) TLV_FLAGS contains TLV_FLAGS_PAN</a>
<a name="ln674">			 * ==&gt; this resets TLV_PAN to itself... hnnnk</a>
<a name="ln675">			 */</a>
<a name="ln676">			capa-&gt;flags = le32_to_cpup((const uint32_t *)tlv_data);</a>
<a name="ln677">			break;</a>
<a name="ln678">		case IWM_UCODE_TLV_CSCHEME:</a>
<a name="ln679">			if ((error = iwm_store_cscheme(sc,</a>
<a name="ln680">			    tlv_data, tlv_len)) != 0) {</a>
<a name="ln681">				device_printf(sc-&gt;sc_dev,</a>
<a name="ln682">				    &quot;%s: iwm_store_cscheme(): returned %d\n&quot;,</a>
<a name="ln683">				    __func__, error);</a>
<a name="ln684">				goto parse_out;</a>
<a name="ln685">			}</a>
<a name="ln686">			break;</a>
<a name="ln687">		case IWM_UCODE_TLV_NUM_OF_CPU:</a>
<a name="ln688">			if (tlv_len != sizeof(uint32_t)) {</a>
<a name="ln689">				device_printf(sc-&gt;sc_dev,</a>
<a name="ln690">				    &quot;%s: IWM_UCODE_TLV_NUM_OF_CPU: tlv_len (%u) != sizeof(uint32_t)\n&quot;,</a>
<a name="ln691">				    __func__, tlv_len);</a>
<a name="ln692">				error = EINVAL;</a>
<a name="ln693">				goto parse_out;</a>
<a name="ln694">			}</a>
<a name="ln695">			num_of_cpus = le32_to_cpup((const uint32_t *)tlv_data);</a>
<a name="ln696">			if (num_of_cpus == 2) {</a>
<a name="ln697">				fw-&gt;img[IWM_UCODE_REGULAR].is_dual_cpus =</a>
<a name="ln698">					TRUE;</a>
<a name="ln699">				fw-&gt;img[IWM_UCODE_INIT].is_dual_cpus =</a>
<a name="ln700">					TRUE;</a>
<a name="ln701">				fw-&gt;img[IWM_UCODE_WOWLAN].is_dual_cpus =</a>
<a name="ln702">					TRUE;</a>
<a name="ln703">			} else if ((num_of_cpus &gt; 2) || (num_of_cpus &lt; 1)) {</a>
<a name="ln704">				device_printf(sc-&gt;sc_dev,</a>
<a name="ln705">				    &quot;%s: Driver supports only 1 or 2 CPUs\n&quot;,</a>
<a name="ln706">				    __func__);</a>
<a name="ln707">				error = EINVAL;</a>
<a name="ln708">				goto parse_out;</a>
<a name="ln709">			}</a>
<a name="ln710">			break;</a>
<a name="ln711">		case IWM_UCODE_TLV_SEC_RT:</a>
<a name="ln712">			if ((error = iwm_firmware_store_section(sc,</a>
<a name="ln713">			    IWM_UCODE_REGULAR, tlv_data, tlv_len)) != 0) {</a>
<a name="ln714">				device_printf(sc-&gt;sc_dev,</a>
<a name="ln715">				    &quot;%s: IWM_UCODE_REGULAR: iwm_firmware_store_section() failed; %d\n&quot;,</a>
<a name="ln716">				    __func__, error);</a>
<a name="ln717">				goto parse_out;</a>
<a name="ln718">			}</a>
<a name="ln719">			break;</a>
<a name="ln720">		case IWM_UCODE_TLV_SEC_INIT:</a>
<a name="ln721">			if ((error = iwm_firmware_store_section(sc,</a>
<a name="ln722">			    IWM_UCODE_INIT, tlv_data, tlv_len)) != 0) {</a>
<a name="ln723">				device_printf(sc-&gt;sc_dev,</a>
<a name="ln724">				    &quot;%s: IWM_UCODE_INIT: iwm_firmware_store_section() failed; %d\n&quot;,</a>
<a name="ln725">				    __func__, error);</a>
<a name="ln726">				goto parse_out;</a>
<a name="ln727">			}</a>
<a name="ln728">			break;</a>
<a name="ln729">		case IWM_UCODE_TLV_SEC_WOWLAN:</a>
<a name="ln730">			if ((error = iwm_firmware_store_section(sc,</a>
<a name="ln731">			    IWM_UCODE_WOWLAN, tlv_data, tlv_len)) != 0) {</a>
<a name="ln732">				device_printf(sc-&gt;sc_dev,</a>
<a name="ln733">				    &quot;%s: IWM_UCODE_WOWLAN: iwm_firmware_store_section() failed; %d\n&quot;,</a>
<a name="ln734">				    __func__, error);</a>
<a name="ln735">				goto parse_out;</a>
<a name="ln736">			}</a>
<a name="ln737">			break;</a>
<a name="ln738">		case IWM_UCODE_TLV_DEF_CALIB:</a>
<a name="ln739">			if (tlv_len != sizeof(struct iwm_tlv_calib_data)) {</a>
<a name="ln740">				device_printf(sc-&gt;sc_dev,</a>
<a name="ln741">				    &quot;%s: IWM_UCODE_TLV_DEV_CALIB: tlv_len (%u) &lt; sizeof(iwm_tlv_calib_data) (%zu)\n&quot;,</a>
<a name="ln742">				    __func__, tlv_len,</a>
<a name="ln743">				    sizeof(struct iwm_tlv_calib_data));</a>
<a name="ln744">				error = EINVAL;</a>
<a name="ln745">				goto parse_out;</a>
<a name="ln746">			}</a>
<a name="ln747">			if ((error = iwm_set_default_calib(sc, tlv_data)) != 0) {</a>
<a name="ln748">				device_printf(sc-&gt;sc_dev,</a>
<a name="ln749">				    &quot;%s: iwm_set_default_calib() failed: %d\n&quot;,</a>
<a name="ln750">				    __func__, error);</a>
<a name="ln751">				goto parse_out;</a>
<a name="ln752">			}</a>
<a name="ln753">			break;</a>
<a name="ln754">		case IWM_UCODE_TLV_PHY_SKU:</a>
<a name="ln755">			if (tlv_len != sizeof(uint32_t)) {</a>
<a name="ln756">				error = EINVAL;</a>
<a name="ln757">				device_printf(sc-&gt;sc_dev,</a>
<a name="ln758">				    &quot;%s: IWM_UCODE_TLV_PHY_SKU: tlv_len (%u) &lt; sizeof(uint32_t)\n&quot;,</a>
<a name="ln759">				    __func__, tlv_len);</a>
<a name="ln760">				goto parse_out;</a>
<a name="ln761">			}</a>
<a name="ln762">			sc-&gt;sc_fw.phy_config =</a>
<a name="ln763">			    le32_to_cpup((const uint32_t *)tlv_data);</a>
<a name="ln764">			sc-&gt;sc_fw.valid_tx_ant = (sc-&gt;sc_fw.phy_config &amp;</a>
<a name="ln765">						  IWM_FW_PHY_CFG_TX_CHAIN) &gt;&gt;</a>
<a name="ln766">						  IWM_FW_PHY_CFG_TX_CHAIN_POS;</a>
<a name="ln767">			sc-&gt;sc_fw.valid_rx_ant = (sc-&gt;sc_fw.phy_config &amp;</a>
<a name="ln768">						  IWM_FW_PHY_CFG_RX_CHAIN) &gt;&gt;</a>
<a name="ln769">						  IWM_FW_PHY_CFG_RX_CHAIN_POS;</a>
<a name="ln770">			break;</a>
<a name="ln771"> </a>
<a name="ln772">		case IWM_UCODE_TLV_API_CHANGES_SET: {</a>
<a name="ln773">			if (tlv_len != sizeof(struct iwm_ucode_api)) {</a>
<a name="ln774">				error = EINVAL;</a>
<a name="ln775">				goto parse_out;</a>
<a name="ln776">			}</a>
<a name="ln777">			if (iwm_set_ucode_api_flags(sc, tlv_data, capa)) {</a>
<a name="ln778">				error = EINVAL;</a>
<a name="ln779">				goto parse_out;</a>
<a name="ln780">			}</a>
<a name="ln781">			break;</a>
<a name="ln782">		}</a>
<a name="ln783"> </a>
<a name="ln784">		case IWM_UCODE_TLV_ENABLED_CAPABILITIES: {</a>
<a name="ln785">			if (tlv_len != sizeof(struct iwm_ucode_capa)) {</a>
<a name="ln786">				error = EINVAL;</a>
<a name="ln787">				goto parse_out;</a>
<a name="ln788">			}</a>
<a name="ln789">			if (iwm_set_ucode_capabilities(sc, tlv_data, capa)) {</a>
<a name="ln790">				error = EINVAL;</a>
<a name="ln791">				goto parse_out;</a>
<a name="ln792">			}</a>
<a name="ln793">			break;</a>
<a name="ln794">		}</a>
<a name="ln795"> </a>
<a name="ln796">		case 48: /* undocumented TLV */</a>
<a name="ln797">		case IWM_UCODE_TLV_SDIO_ADMA_ADDR:</a>
<a name="ln798">		case IWM_UCODE_TLV_FW_GSCAN_CAPA:</a>
<a name="ln799">			/* ignore, not used by current driver */</a>
<a name="ln800">			break;</a>
<a name="ln801"> </a>
<a name="ln802">		case IWM_UCODE_TLV_SEC_RT_USNIFFER:</a>
<a name="ln803">			if ((error = iwm_firmware_store_section(sc,</a>
<a name="ln804">			    IWM_UCODE_REGULAR_USNIFFER, tlv_data,</a>
<a name="ln805">			    tlv_len)) != 0)</a>
<a name="ln806">				goto parse_out;</a>
<a name="ln807">			break;</a>
<a name="ln808"> </a>
<a name="ln809">		case IWM_UCODE_TLV_PAGING:</a>
<a name="ln810">			if (tlv_len != sizeof(uint32_t)) {</a>
<a name="ln811">				error = EINVAL;</a>
<a name="ln812">				goto parse_out;</a>
<a name="ln813">			}</a>
<a name="ln814">			paging_mem_size = le32_to_cpup((const uint32_t *)tlv_data);</a>
<a name="ln815"> </a>
<a name="ln816">			IWM_DPRINTF(sc, IWM_DEBUG_FIRMWARE_TLV,</a>
<a name="ln817">			    &quot;%s: Paging: paging enabled (size = %u bytes)\n&quot;,</a>
<a name="ln818">			    __func__, paging_mem_size);</a>
<a name="ln819">			if (paging_mem_size &gt; IWM_MAX_PAGING_IMAGE_SIZE) {</a>
<a name="ln820">				device_printf(sc-&gt;sc_dev,</a>
<a name="ln821">					&quot;%s: Paging: driver supports up to %u bytes for paging image\n&quot;,</a>
<a name="ln822">					__func__, IWM_MAX_PAGING_IMAGE_SIZE);</a>
<a name="ln823">				error = EINVAL;</a>
<a name="ln824">				goto out;</a>
<a name="ln825">			}</a>
<a name="ln826">			if (paging_mem_size &amp; (IWM_FW_PAGING_SIZE - 1)) {</a>
<a name="ln827">				device_printf(sc-&gt;sc_dev,</a>
<a name="ln828">				    &quot;%s: Paging: image isn't multiple %u\n&quot;,</a>
<a name="ln829">				    __func__, IWM_FW_PAGING_SIZE);</a>
<a name="ln830">				error = EINVAL;</a>
<a name="ln831">				goto out;</a>
<a name="ln832">			}</a>
<a name="ln833"> </a>
<a name="ln834">			sc-&gt;sc_fw.img[IWM_UCODE_REGULAR].paging_mem_size =</a>
<a name="ln835">			    paging_mem_size;</a>
<a name="ln836">			usniffer_img = IWM_UCODE_REGULAR_USNIFFER;</a>
<a name="ln837">			sc-&gt;sc_fw.img[usniffer_img].paging_mem_size =</a>
<a name="ln838">			    paging_mem_size;</a>
<a name="ln839">			break;</a>
<a name="ln840"> </a>
<a name="ln841">		case IWM_UCODE_TLV_N_SCAN_CHANNELS:</a>
<a name="ln842">			if (tlv_len != sizeof(uint32_t)) {</a>
<a name="ln843">				error = EINVAL;</a>
<a name="ln844">				goto parse_out;</a>
<a name="ln845">			}</a>
<a name="ln846">			capa-&gt;n_scan_channels =</a>
<a name="ln847">			    le32_to_cpup((const uint32_t *)tlv_data);</a>
<a name="ln848">			break;</a>
<a name="ln849"> </a>
<a name="ln850">		case IWM_UCODE_TLV_FW_VERSION:</a>
<a name="ln851">			if (tlv_len != sizeof(uint32_t) * 3) {</a>
<a name="ln852">				error = EINVAL;</a>
<a name="ln853">				goto parse_out;</a>
<a name="ln854">			}</a>
<a name="ln855">			snprintf(sc-&gt;sc_fwver, sizeof(sc-&gt;sc_fwver),</a>
<a name="ln856">			    &quot;%d.%d.%d&quot;,</a>
<a name="ln857">			    le32toh(((const uint32_t *)tlv_data)[0]),</a>
<a name="ln858">			    le32toh(((const uint32_t *)tlv_data)[1]),</a>
<a name="ln859">			    le32toh(((const uint32_t *)tlv_data)[2]));</a>
<a name="ln860">			break;</a>
<a name="ln861"> </a>
<a name="ln862">		case IWM_UCODE_TLV_FW_MEM_SEG:</a>
<a name="ln863">			break;</a>
<a name="ln864"> </a>
<a name="ln865">		default:</a>
<a name="ln866">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln867">			    &quot;%s: unknown firmware section %d, abort\n&quot;,</a>
<a name="ln868">			    __func__, tlv_type);</a>
<a name="ln869">			error = EINVAL;</a>
<a name="ln870">			goto parse_out;</a>
<a name="ln871">		}</a>
<a name="ln872">	}</a>
<a name="ln873"> </a>
<a name="ln874">	KASSERT(error == 0, (&quot;unhandled error&quot;));</a>
<a name="ln875"> </a>
<a name="ln876"> parse_out:</a>
<a name="ln877">	if (error) {</a>
<a name="ln878">		device_printf(sc-&gt;sc_dev, &quot;firmware parse error %d, &quot;</a>
<a name="ln879">		    &quot;section type %d\n&quot;, error, tlv_type);</a>
<a name="ln880">	}</a>
<a name="ln881"> </a>
<a name="ln882"> out:</a>
<a name="ln883">	if (error) {</a>
<a name="ln884">		if (fw-&gt;fw_fp != NULL)</a>
<a name="ln885">			iwm_fw_info_free(fw);</a>
<a name="ln886">	}</a>
<a name="ln887"> </a>
<a name="ln888">	return error;</a>
<a name="ln889">}</a>
<a name="ln890"> </a>
<a name="ln891">/*</a>
<a name="ln892"> * DMA resource routines</a>
<a name="ln893"> */</a>
<a name="ln894"> </a>
<a name="ln895">/* fwmem is used to load firmware onto the card */</a>
<a name="ln896">static int</a>
<a name="ln897">iwm_alloc_fwmem(struct iwm_softc *sc)</a>
<a name="ln898">{</a>
<a name="ln899">	/* Must be aligned on a 16-byte boundary. */</a>
<a name="ln900">	return iwm_dma_contig_alloc(sc-&gt;sc_dmat, &amp;sc-&gt;fw_dma,</a>
<a name="ln901">	    IWM_FH_MEM_TB_MAX_LENGTH, 16);</a>
<a name="ln902">}</a>
<a name="ln903"> </a>
<a name="ln904">/* tx scheduler rings.  not used? */</a>
<a name="ln905">static int</a>
<a name="ln906">iwm_alloc_sched(struct iwm_softc *sc)</a>
<a name="ln907">{</a>
<a name="ln908">	/* TX scheduler rings must be aligned on a 1KB boundary. */</a>
<a name="ln909">	return iwm_dma_contig_alloc(sc-&gt;sc_dmat, &amp;sc-&gt;sched_dma,</a>
<a name="ln910">	    nitems(sc-&gt;txq) * sizeof(struct iwm_agn_scd_bc_tbl), 1024);</a>
<a name="ln911">}</a>
<a name="ln912"> </a>
<a name="ln913">/* keep-warm page is used internally by the card.  see iwl-fh.h for more info */</a>
<a name="ln914">static int</a>
<a name="ln915">iwm_alloc_kw(struct iwm_softc *sc)</a>
<a name="ln916">{</a>
<a name="ln917">	return iwm_dma_contig_alloc(sc-&gt;sc_dmat, &amp;sc-&gt;kw_dma, 4096, 4096);</a>
<a name="ln918">}</a>
<a name="ln919"> </a>
<a name="ln920">/* interrupt cause table */</a>
<a name="ln921">static int</a>
<a name="ln922">iwm_alloc_ict(struct iwm_softc *sc)</a>
<a name="ln923">{</a>
<a name="ln924">	return iwm_dma_contig_alloc(sc-&gt;sc_dmat, &amp;sc-&gt;ict_dma,</a>
<a name="ln925">	    IWM_ICT_SIZE, 1&lt;&lt;IWM_ICT_PADDR_SHIFT);</a>
<a name="ln926">}</a>
<a name="ln927"> </a>
<a name="ln928">static int</a>
<a name="ln929">iwm_alloc_rx_ring(struct iwm_softc *sc, struct iwm_rx_ring *ring)</a>
<a name="ln930">{</a>
<a name="ln931">	bus_size_t size;</a>
<a name="ln932">	int i, error;</a>
<a name="ln933"> </a>
<a name="ln934">	ring-&gt;cur = 0;</a>
<a name="ln935"> </a>
<a name="ln936">	/* Allocate RX descriptors (256-byte aligned). */</a>
<a name="ln937">	size = IWM_RX_RING_COUNT * sizeof(uint32_t);</a>
<a name="ln938">	error = iwm_dma_contig_alloc(sc-&gt;sc_dmat, &amp;ring-&gt;desc_dma, size, 256);</a>
<a name="ln939">	if (error != 0) {</a>
<a name="ln940">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln941">		    &quot;could not allocate RX ring DMA memory\n&quot;);</a>
<a name="ln942">		goto fail;</a>
<a name="ln943">	}</a>
<a name="ln944">	ring-&gt;desc = ring-&gt;desc_dma.vaddr;</a>
<a name="ln945"> </a>
<a name="ln946">	/* Allocate RX status area (16-byte aligned). */</a>
<a name="ln947">	error = iwm_dma_contig_alloc(sc-&gt;sc_dmat, &amp;ring-&gt;stat_dma,</a>
<a name="ln948">	    sizeof(*ring-&gt;stat), 16);</a>
<a name="ln949">	if (error != 0) {</a>
<a name="ln950">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln951">		    &quot;could not allocate RX status DMA memory\n&quot;);</a>
<a name="ln952">		goto fail;</a>
<a name="ln953">	}</a>
<a name="ln954">	ring-&gt;stat = ring-&gt;stat_dma.vaddr;</a>
<a name="ln955"> </a>
<a name="ln956">        /* Create RX buffer DMA tag. */</a>
<a name="ln957">        error = bus_dma_tag_create(sc-&gt;sc_dmat, 1, 0,</a>
<a name="ln958">            BUS_SPACE_MAXADDR_32BIT, BUS_SPACE_MAXADDR, NULL, NULL,</a>
<a name="ln959">            IWM_RBUF_SIZE, 1, IWM_RBUF_SIZE, 0, NULL, NULL, &amp;ring-&gt;data_dmat);</a>
<a name="ln960">        if (error != 0) {</a>
<a name="ln961">                device_printf(sc-&gt;sc_dev,</a>
<a name="ln962">                    &quot;%s: could not create RX buf DMA tag, error %d\n&quot;,</a>
<a name="ln963">                    __func__, error);</a>
<a name="ln964">                goto fail;</a>
<a name="ln965">        }</a>
<a name="ln966"> </a>
<a name="ln967">	/* Allocate spare bus_dmamap_t for iwm_rx_addbuf() */</a>
<a name="ln968">	error = bus_dmamap_create(ring-&gt;data_dmat, 0, &amp;ring-&gt;spare_map);</a>
<a name="ln969">	if (error != 0) {</a>
<a name="ln970">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln971">		    &quot;%s: could not create RX buf DMA map, error %d\n&quot;,</a>
<a name="ln972">		    __func__, error);</a>
<a name="ln973">		goto fail;</a>
<a name="ln974">	}</a>
<a name="ln975">	/*</a>
<a name="ln976">	 * Allocate and map RX buffers.</a>
<a name="ln977">	 */</a>
<a name="ln978">	for (i = 0; i &lt; IWM_RX_RING_COUNT; i++) {</a>
<a name="ln979">		struct iwm_rx_data *data = &amp;ring-&gt;data[i];</a>
<a name="ln980">		error = bus_dmamap_create(ring-&gt;data_dmat, 0, &amp;data-&gt;map);</a>
<a name="ln981">		if (error != 0) {</a>
<a name="ln982">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln983">			    &quot;%s: could not create RX buf DMA map, error %d\n&quot;,</a>
<a name="ln984">			    __func__, error);</a>
<a name="ln985">			goto fail;</a>
<a name="ln986">		}</a>
<a name="ln987">		data-&gt;m = NULL;</a>
<a name="ln988"> </a>
<a name="ln989">		if ((error = iwm_rx_addbuf(sc, IWM_RBUF_SIZE, i)) != 0) {</a>
<a name="ln990">			goto fail;</a>
<a name="ln991">		}</a>
<a name="ln992">	}</a>
<a name="ln993">	return 0;</a>
<a name="ln994"> </a>
<a name="ln995">fail:	iwm_free_rx_ring(sc, ring);</a>
<a name="ln996">	return error;</a>
<a name="ln997">}</a>
<a name="ln998"> </a>
<a name="ln999">static void</a>
<a name="ln1000">iwm_reset_rx_ring(struct iwm_softc *sc, struct iwm_rx_ring *ring)</a>
<a name="ln1001">{</a>
<a name="ln1002">	/* Reset the ring state */</a>
<a name="ln1003">	ring-&gt;cur = 0;</a>
<a name="ln1004"> </a>
<a name="ln1005">	/*</a>
<a name="ln1006">	 * The hw rx ring index in shared memory must also be cleared,</a>
<a name="ln1007">	 * otherwise the discrepancy can cause reprocessing chaos.</a>
<a name="ln1008">	 */</a>
<a name="ln1009">	if (sc-&gt;rxq.stat)</a>
<a name="ln1010">		memset(sc-&gt;rxq.stat, 0, sizeof(*sc-&gt;rxq.stat));</a>
<a name="ln1011">}</a>
<a name="ln1012"> </a>
<a name="ln1013">static void</a>
<a name="ln1014">iwm_free_rx_ring(struct iwm_softc *sc, struct iwm_rx_ring *ring)</a>
<a name="ln1015">{</a>
<a name="ln1016">	int i;</a>
<a name="ln1017"> </a>
<a name="ln1018">	iwm_dma_contig_free(&amp;ring-&gt;desc_dma);</a>
<a name="ln1019">	iwm_dma_contig_free(&amp;ring-&gt;stat_dma);</a>
<a name="ln1020"> </a>
<a name="ln1021">	for (i = 0; i &lt; IWM_RX_RING_COUNT; i++) {</a>
<a name="ln1022">		struct iwm_rx_data *data = &amp;ring-&gt;data[i];</a>
<a name="ln1023"> </a>
<a name="ln1024">		if (data-&gt;m != NULL) {</a>
<a name="ln1025">			bus_dmamap_sync(ring-&gt;data_dmat, data-&gt;map,</a>
<a name="ln1026">			    BUS_DMASYNC_POSTREAD);</a>
<a name="ln1027">			bus_dmamap_unload(ring-&gt;data_dmat, data-&gt;map);</a>
<a name="ln1028">			m_freem(data-&gt;m);</a>
<a name="ln1029">			data-&gt;m = NULL;</a>
<a name="ln1030">		}</a>
<a name="ln1031">		if (data-&gt;map != NULL) {</a>
<a name="ln1032">			bus_dmamap_destroy(ring-&gt;data_dmat, data-&gt;map);</a>
<a name="ln1033">			data-&gt;map = NULL;</a>
<a name="ln1034">		}</a>
<a name="ln1035">	}</a>
<a name="ln1036">	if (ring-&gt;spare_map != NULL) {</a>
<a name="ln1037">		bus_dmamap_destroy(ring-&gt;data_dmat, ring-&gt;spare_map);</a>
<a name="ln1038">		ring-&gt;spare_map = NULL;</a>
<a name="ln1039">	}</a>
<a name="ln1040">	if (ring-&gt;data_dmat != NULL) {</a>
<a name="ln1041">		bus_dma_tag_destroy(ring-&gt;data_dmat);</a>
<a name="ln1042">		ring-&gt;data_dmat = NULL;</a>
<a name="ln1043">	}</a>
<a name="ln1044">}</a>
<a name="ln1045"> </a>
<a name="ln1046">static int</a>
<a name="ln1047">iwm_alloc_tx_ring(struct iwm_softc *sc, struct iwm_tx_ring *ring, int qid)</a>
<a name="ln1048">{</a>
<a name="ln1049">	bus_addr_t paddr;</a>
<a name="ln1050">	bus_size_t size;</a>
<a name="ln1051">	size_t maxsize;</a>
<a name="ln1052">	int nsegments;</a>
<a name="ln1053">	int i, error;</a>
<a name="ln1054"> </a>
<a name="ln1055">	ring-&gt;qid = qid;</a>
<a name="ln1056">	ring-&gt;queued = 0;</a>
<a name="ln1057">	ring-&gt;cur = 0;</a>
<a name="ln1058"> </a>
<a name="ln1059">	/* Allocate TX descriptors (256-byte aligned). */</a>
<a name="ln1060">	size = IWM_TX_RING_COUNT * sizeof (struct iwm_tfd);</a>
<a name="ln1061">	error = iwm_dma_contig_alloc(sc-&gt;sc_dmat, &amp;ring-&gt;desc_dma, size, 256);</a>
<a name="ln1062">	if (error != 0) {</a>
<a name="ln1063">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln1064">		    &quot;could not allocate TX ring DMA memory\n&quot;);</a>
<a name="ln1065">		goto fail;</a>
<a name="ln1066">	}</a>
<a name="ln1067">	ring-&gt;desc = ring-&gt;desc_dma.vaddr;</a>
<a name="ln1068"> </a>
<a name="ln1069">	/*</a>
<a name="ln1070">	 * We only use rings 0 through 9 (4 EDCA + cmd) so there is no need</a>
<a name="ln1071">	 * to allocate commands space for other rings.</a>
<a name="ln1072">	 */</a>
<a name="ln1073">	if (qid &gt; IWM_MVM_CMD_QUEUE)</a>
<a name="ln1074">		return 0;</a>
<a name="ln1075"> </a>
<a name="ln1076">	size = IWM_TX_RING_COUNT * sizeof(struct iwm_device_cmd);</a>
<a name="ln1077">	error = iwm_dma_contig_alloc(sc-&gt;sc_dmat, &amp;ring-&gt;cmd_dma, size, 4);</a>
<a name="ln1078">	if (error != 0) {</a>
<a name="ln1079">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln1080">		    &quot;could not allocate TX cmd DMA memory\n&quot;);</a>
<a name="ln1081">		goto fail;</a>
<a name="ln1082">	}</a>
<a name="ln1083">	ring-&gt;cmd = ring-&gt;cmd_dma.vaddr;</a>
<a name="ln1084"> </a>
<a name="ln1085">	/* FW commands may require more mapped space than packets. */</a>
<a name="ln1086">	if (qid == IWM_MVM_CMD_QUEUE) {</a>
<a name="ln1087">		maxsize = IWM_RBUF_SIZE;</a>
<a name="ln1088">		nsegments = 1;</a>
<a name="ln1089">	} else {</a>
<a name="ln1090">		maxsize = MCLBYTES;</a>
<a name="ln1091">		nsegments = IWM_MAX_SCATTER - 2;</a>
<a name="ln1092">	}</a>
<a name="ln1093"> </a>
<a name="ln1094">	error = bus_dma_tag_create(sc-&gt;sc_dmat, 1, 0,</a>
<a name="ln1095">	    BUS_SPACE_MAXADDR_32BIT, BUS_SPACE_MAXADDR, NULL, NULL, maxsize,</a>
<a name="ln1096">            nsegments, maxsize, 0, NULL, NULL, &amp;ring-&gt;data_dmat);</a>
<a name="ln1097">	if (error != 0) {</a>
<a name="ln1098">		device_printf(sc-&gt;sc_dev, &quot;could not create TX buf DMA tag\n&quot;);</a>
<a name="ln1099">		goto fail;</a>
<a name="ln1100">	}</a>
<a name="ln1101"> </a>
<a name="ln1102">	paddr = ring-&gt;cmd_dma.paddr;</a>
<a name="ln1103">	for (i = 0; i &lt; IWM_TX_RING_COUNT; i++) {</a>
<a name="ln1104">		struct iwm_tx_data *data = &amp;ring-&gt;data[i];</a>
<a name="ln1105"> </a>
<a name="ln1106">		data-&gt;cmd_paddr = paddr;</a>
<a name="ln1107">		data-&gt;scratch_paddr = paddr + sizeof(struct iwm_cmd_header)</a>
<a name="ln1108">		    + offsetof(struct iwm_tx_cmd, scratch);</a>
<a name="ln1109">		paddr += sizeof(struct iwm_device_cmd);</a>
<a name="ln1110"> </a>
<a name="ln1111">		error = bus_dmamap_create(ring-&gt;data_dmat, 0, &amp;data-&gt;map);</a>
<a name="ln1112">		if (error != 0) {</a>
<a name="ln1113">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1114">			    &quot;could not create TX buf DMA map\n&quot;);</a>
<a name="ln1115">			goto fail;</a>
<a name="ln1116">		}</a>
<a name="ln1117">	}</a>
<a name="ln1118">	KASSERT(paddr == ring-&gt;cmd_dma.paddr + size,</a>
<a name="ln1119">	    (&quot;invalid physical address&quot;));</a>
<a name="ln1120">	return 0;</a>
<a name="ln1121"> </a>
<a name="ln1122">fail:	iwm_free_tx_ring(sc, ring);</a>
<a name="ln1123">	return error;</a>
<a name="ln1124">}</a>
<a name="ln1125"> </a>
<a name="ln1126">static void</a>
<a name="ln1127">iwm_reset_tx_ring(struct iwm_softc *sc, struct iwm_tx_ring *ring)</a>
<a name="ln1128">{</a>
<a name="ln1129">	int i;</a>
<a name="ln1130"> </a>
<a name="ln1131">	for (i = 0; i &lt; IWM_TX_RING_COUNT; i++) {</a>
<a name="ln1132">		struct iwm_tx_data *data = &amp;ring-&gt;data[i];</a>
<a name="ln1133"> </a>
<a name="ln1134">		if (data-&gt;m != NULL) {</a>
<a name="ln1135">			bus_dmamap_sync(ring-&gt;data_dmat, data-&gt;map,</a>
<a name="ln1136">			    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln1137">			bus_dmamap_unload(ring-&gt;data_dmat, data-&gt;map);</a>
<a name="ln1138">			m_freem(data-&gt;m);</a>
<a name="ln1139">			data-&gt;m = NULL;</a>
<a name="ln1140">		}</a>
<a name="ln1141">	}</a>
<a name="ln1142">	/* Clear TX descriptors. */</a>
<a name="ln1143">	if (ring-&gt;desc)</a>
<a name="ln1144">		memset(ring-&gt;desc, 0, ring-&gt;desc_dma.size);</a>
<a name="ln1145">	bus_dmamap_sync(ring-&gt;desc_dma.tag, ring-&gt;desc_dma.map,</a>
<a name="ln1146">	    BUS_DMASYNC_PREWRITE);</a>
<a name="ln1147">	sc-&gt;qfullmsk &amp;= ~(1 &lt;&lt; ring-&gt;qid);</a>
<a name="ln1148">	ring-&gt;queued = 0;</a>
<a name="ln1149">	ring-&gt;cur = 0;</a>
<a name="ln1150"> </a>
<a name="ln1151">	if (ring-&gt;qid == IWM_MVM_CMD_QUEUE &amp;&amp; sc-&gt;cmd_hold_nic_awake)</a>
<a name="ln1152">		iwm_pcie_clear_cmd_in_flight(sc);</a>
<a name="ln1153">}</a>
<a name="ln1154"> </a>
<a name="ln1155">static void</a>
<a name="ln1156">iwm_free_tx_ring(struct iwm_softc *sc, struct iwm_tx_ring *ring)</a>
<a name="ln1157">{</a>
<a name="ln1158">	int i;</a>
<a name="ln1159"> </a>
<a name="ln1160">	iwm_dma_contig_free(&amp;ring-&gt;desc_dma);</a>
<a name="ln1161">	iwm_dma_contig_free(&amp;ring-&gt;cmd_dma);</a>
<a name="ln1162"> </a>
<a name="ln1163">	for (i = 0; i &lt; IWM_TX_RING_COUNT; i++) {</a>
<a name="ln1164">		struct iwm_tx_data *data = &amp;ring-&gt;data[i];</a>
<a name="ln1165"> </a>
<a name="ln1166">		if (data-&gt;m != NULL) {</a>
<a name="ln1167">			bus_dmamap_sync(ring-&gt;data_dmat, data-&gt;map,</a>
<a name="ln1168">			    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln1169">			bus_dmamap_unload(ring-&gt;data_dmat, data-&gt;map);</a>
<a name="ln1170">			m_freem(data-&gt;m);</a>
<a name="ln1171">			data-&gt;m = NULL;</a>
<a name="ln1172">		}</a>
<a name="ln1173">		if (data-&gt;map != NULL) {</a>
<a name="ln1174">			bus_dmamap_destroy(ring-&gt;data_dmat, data-&gt;map);</a>
<a name="ln1175">			data-&gt;map = NULL;</a>
<a name="ln1176">		}</a>
<a name="ln1177">	}</a>
<a name="ln1178">	if (ring-&gt;data_dmat != NULL) {</a>
<a name="ln1179">		bus_dma_tag_destroy(ring-&gt;data_dmat);</a>
<a name="ln1180">		ring-&gt;data_dmat = NULL;</a>
<a name="ln1181">	}</a>
<a name="ln1182">}</a>
<a name="ln1183"> </a>
<a name="ln1184">/*</a>
<a name="ln1185"> * High-level hardware frobbing routines</a>
<a name="ln1186"> */</a>
<a name="ln1187"> </a>
<a name="ln1188">static void</a>
<a name="ln1189">iwm_enable_interrupts(struct iwm_softc *sc)</a>
<a name="ln1190">{</a>
<a name="ln1191">	sc-&gt;sc_intmask = IWM_CSR_INI_SET_MASK;</a>
<a name="ln1192">	IWM_WRITE(sc, IWM_CSR_INT_MASK, sc-&gt;sc_intmask);</a>
<a name="ln1193">}</a>
<a name="ln1194"> </a>
<a name="ln1195">static void</a>
<a name="ln1196">iwm_restore_interrupts(struct iwm_softc *sc)</a>
<a name="ln1197">{</a>
<a name="ln1198">	IWM_WRITE(sc, IWM_CSR_INT_MASK, sc-&gt;sc_intmask);</a>
<a name="ln1199">}</a>
<a name="ln1200"> </a>
<a name="ln1201">static void</a>
<a name="ln1202">iwm_disable_interrupts(struct iwm_softc *sc)</a>
<a name="ln1203">{</a>
<a name="ln1204">	/* disable interrupts */</a>
<a name="ln1205">	IWM_WRITE(sc, IWM_CSR_INT_MASK, 0);</a>
<a name="ln1206"> </a>
<a name="ln1207">	/* acknowledge all interrupts */</a>
<a name="ln1208">	IWM_WRITE(sc, IWM_CSR_INT, ~0);</a>
<a name="ln1209">	IWM_WRITE(sc, IWM_CSR_FH_INT_STATUS, ~0);</a>
<a name="ln1210">}</a>
<a name="ln1211"> </a>
<a name="ln1212">static void</a>
<a name="ln1213">iwm_ict_reset(struct iwm_softc *sc)</a>
<a name="ln1214">{</a>
<a name="ln1215">	iwm_disable_interrupts(sc);</a>
<a name="ln1216"> </a>
<a name="ln1217">	/* Reset ICT table. */</a>
<a name="ln1218">	memset(sc-&gt;ict_dma.vaddr, 0, IWM_ICT_SIZE);</a>
<a name="ln1219">	sc-&gt;ict_cur = 0;</a>
<a name="ln1220"> </a>
<a name="ln1221">	/* Set physical address of ICT table (4KB aligned). */</a>
<a name="ln1222">	IWM_WRITE(sc, IWM_CSR_DRAM_INT_TBL_REG,</a>
<a name="ln1223">	    IWM_CSR_DRAM_INT_TBL_ENABLE</a>
<a name="ln1224">	    | IWM_CSR_DRAM_INIT_TBL_WRITE_POINTER</a>
<a name="ln1225">	    | IWM_CSR_DRAM_INIT_TBL_WRAP_CHECK</a>
<a name="ln1226">	    | sc-&gt;ict_dma.paddr &gt;&gt; IWM_ICT_PADDR_SHIFT);</a>
<a name="ln1227"> </a>
<a name="ln1228">	/* Switch to ICT interrupt mode in driver. */</a>
<a name="ln1229">	sc-&gt;sc_flags |= IWM_FLAG_USE_ICT;</a>
<a name="ln1230"> </a>
<a name="ln1231">	/* Re-enable interrupts. */</a>
<a name="ln1232">	IWM_WRITE(sc, IWM_CSR_INT, ~0);</a>
<a name="ln1233">	iwm_enable_interrupts(sc);</a>
<a name="ln1234">}</a>
<a name="ln1235"> </a>
<a name="ln1236">/* iwlwifi pcie/trans.c */</a>
<a name="ln1237"> </a>
<a name="ln1238">/*</a>
<a name="ln1239"> * Since this .. hard-resets things, it's time to actually</a>
<a name="ln1240"> * mark the first vap (if any) as having no mac context.</a>
<a name="ln1241"> * It's annoying, but since the driver is potentially being</a>
<a name="ln1242"> * stop/start'ed whilst active (thanks openbsd port!) we</a>
<a name="ln1243"> * have to correctly track this.</a>
<a name="ln1244"> */</a>
<a name="ln1245">static void</a>
<a name="ln1246">iwm_stop_device(struct iwm_softc *sc)</a>
<a name="ln1247">{</a>
<a name="ln1248">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1249">	struct ieee80211vap *vap = TAILQ_FIRST(&amp;ic-&gt;ic_vaps);</a>
<a name="ln1250">	int chnl, qid;</a>
<a name="ln1251">	uint32_t mask = 0;</a>
<a name="ln1252"> </a>
<a name="ln1253">	/* tell the device to stop sending interrupts */</a>
<a name="ln1254">	iwm_disable_interrupts(sc);</a>
<a name="ln1255"> </a>
<a name="ln1256">	/*</a>
<a name="ln1257">	 * FreeBSD-local: mark the first vap as not-uploaded,</a>
<a name="ln1258">	 * so the next transition through auth/assoc</a>
<a name="ln1259">	 * will correctly populate the MAC context.</a>
<a name="ln1260">	 */</a>
<a name="ln1261">	if (vap) {</a>
<a name="ln1262">		struct iwm_vap *iv = IWM_VAP(vap);</a>
<a name="ln1263">		iv-&gt;phy_ctxt = NULL;</a>
<a name="ln1264">		iv-&gt;is_uploaded = 0;</a>
<a name="ln1265">	}</a>
<a name="ln1266">	sc-&gt;sc_firmware_state = 0;</a>
<a name="ln1267">	sc-&gt;sc_flags &amp;= ~IWM_FLAG_TE_ACTIVE;</a>
<a name="ln1268"> </a>
<a name="ln1269">	/* device going down, Stop using ICT table */</a>
<a name="ln1270">	sc-&gt;sc_flags &amp;= ~IWM_FLAG_USE_ICT;</a>
<a name="ln1271"> </a>
<a name="ln1272">	/* stop tx and rx.  tx and rx bits, as usual, are from if_iwn */</a>
<a name="ln1273"> </a>
<a name="ln1274">	if (iwm_nic_lock(sc)) {</a>
<a name="ln1275">		iwm_write_prph(sc, IWM_SCD_TXFACT, 0);</a>
<a name="ln1276"> </a>
<a name="ln1277">		/* Stop each Tx DMA channel */</a>
<a name="ln1278">		for (chnl = 0; chnl &lt; IWM_FH_TCSR_CHNL_NUM; chnl++) {</a>
<a name="ln1279">			IWM_WRITE(sc,</a>
<a name="ln1280">			    IWM_FH_TCSR_CHNL_TX_CONFIG_REG(chnl), 0);</a>
<a name="ln1281">			mask |= IWM_FH_TSSR_TX_STATUS_REG_MSK_CHNL_IDLE(chnl);</a>
<a name="ln1282">		}</a>
<a name="ln1283"> </a>
<a name="ln1284">		/* Wait for DMA channels to be idle */</a>
<a name="ln1285">		if (!iwm_poll_bit(sc, IWM_FH_TSSR_TX_STATUS_REG, mask, mask,</a>
<a name="ln1286">		    5000)) {</a>
<a name="ln1287">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1288">			    &quot;Failing on timeout while stopping DMA channel: [0x%08x]\n&quot;,</a>
<a name="ln1289">			    IWM_READ(sc, IWM_FH_TSSR_TX_STATUS_REG));</a>
<a name="ln1290">		}</a>
<a name="ln1291">		iwm_nic_unlock(sc);</a>
<a name="ln1292">	}</a>
<a name="ln1293">	iwm_pcie_rx_stop(sc);</a>
<a name="ln1294"> </a>
<a name="ln1295">	/* Stop RX ring. */</a>
<a name="ln1296">	iwm_reset_rx_ring(sc, &amp;sc-&gt;rxq);</a>
<a name="ln1297"> </a>
<a name="ln1298">	/* Reset all TX rings. */</a>
<a name="ln1299">	for (qid = 0; qid &lt; nitems(sc-&gt;txq); qid++)</a>
<a name="ln1300">		iwm_reset_tx_ring(sc, &amp;sc-&gt;txq[qid]);</a>
<a name="ln1301"> </a>
<a name="ln1302">	if (sc-&gt;cfg-&gt;device_family == IWM_DEVICE_FAMILY_7000) {</a>
<a name="ln1303">		/* Power-down device's busmaster DMA clocks */</a>
<a name="ln1304">		if (iwm_nic_lock(sc)) {</a>
<a name="ln1305">			iwm_write_prph(sc, IWM_APMG_CLK_DIS_REG,</a>
<a name="ln1306">			    IWM_APMG_CLK_VAL_DMA_CLK_RQT);</a>
<a name="ln1307">			iwm_nic_unlock(sc);</a>
<a name="ln1308">		}</a>
<a name="ln1309">		DELAY(5);</a>
<a name="ln1310">	}</a>
<a name="ln1311"> </a>
<a name="ln1312">	/* Make sure (redundant) we've released our request to stay awake */</a>
<a name="ln1313">	IWM_CLRBITS(sc, IWM_CSR_GP_CNTRL,</a>
<a name="ln1314">	    IWM_CSR_GP_CNTRL_REG_FLAG_MAC_ACCESS_REQ);</a>
<a name="ln1315"> </a>
<a name="ln1316">	/* Stop the device, and put it in low power state */</a>
<a name="ln1317">	iwm_apm_stop(sc);</a>
<a name="ln1318"> </a>
<a name="ln1319">	/* Upon stop, the APM issues an interrupt if HW RF kill is set.</a>
<a name="ln1320">	 * Clean again the interrupt here</a>
<a name="ln1321">	 */</a>
<a name="ln1322">	iwm_disable_interrupts(sc);</a>
<a name="ln1323">	/* stop and reset the on-board processor */</a>
<a name="ln1324">	IWM_WRITE(sc, IWM_CSR_RESET, IWM_CSR_RESET_REG_FLAG_SW_RESET);</a>
<a name="ln1325"> </a>
<a name="ln1326">	/*</a>
<a name="ln1327">	 * Even if we stop the HW, we still want the RF kill</a>
<a name="ln1328">	 * interrupt</a>
<a name="ln1329">	 */</a>
<a name="ln1330">	iwm_enable_rfkill_int(sc);</a>
<a name="ln1331">	iwm_check_rfkill(sc);</a>
<a name="ln1332">}</a>
<a name="ln1333"> </a>
<a name="ln1334">/* iwlwifi: mvm/ops.c */</a>
<a name="ln1335">static void</a>
<a name="ln1336">iwm_mvm_nic_config(struct iwm_softc *sc)</a>
<a name="ln1337">{</a>
<a name="ln1338">	uint8_t radio_cfg_type, radio_cfg_step, radio_cfg_dash;</a>
<a name="ln1339">	uint32_t reg_val = 0;</a>
<a name="ln1340">	uint32_t phy_config = iwm_mvm_get_phy_config(sc);</a>
<a name="ln1341"> </a>
<a name="ln1342">	radio_cfg_type = (phy_config &amp; IWM_FW_PHY_CFG_RADIO_TYPE) &gt;&gt;</a>
<a name="ln1343">	    IWM_FW_PHY_CFG_RADIO_TYPE_POS;</a>
<a name="ln1344">	radio_cfg_step = (phy_config &amp; IWM_FW_PHY_CFG_RADIO_STEP) &gt;&gt;</a>
<a name="ln1345">	    IWM_FW_PHY_CFG_RADIO_STEP_POS;</a>
<a name="ln1346">	radio_cfg_dash = (phy_config &amp; IWM_FW_PHY_CFG_RADIO_DASH) &gt;&gt;</a>
<a name="ln1347">	    IWM_FW_PHY_CFG_RADIO_DASH_POS;</a>
<a name="ln1348"> </a>
<a name="ln1349">	/* SKU control */</a>
<a name="ln1350">	reg_val |= IWM_CSR_HW_REV_STEP(sc-&gt;sc_hw_rev) &lt;&lt;</a>
<a name="ln1351">	    IWM_CSR_HW_IF_CONFIG_REG_POS_MAC_STEP;</a>
<a name="ln1352">	reg_val |= IWM_CSR_HW_REV_DASH(sc-&gt;sc_hw_rev) &lt;&lt;</a>
<a name="ln1353">	    IWM_CSR_HW_IF_CONFIG_REG_POS_MAC_DASH;</a>
<a name="ln1354"> </a>
<a name="ln1355">	/* radio configuration */</a>
<a name="ln1356">	reg_val |= radio_cfg_type &lt;&lt; IWM_CSR_HW_IF_CONFIG_REG_POS_PHY_TYPE;</a>
<a name="ln1357">	reg_val |= radio_cfg_step &lt;&lt; IWM_CSR_HW_IF_CONFIG_REG_POS_PHY_STEP;</a>
<a name="ln1358">	reg_val |= radio_cfg_dash &lt;&lt; IWM_CSR_HW_IF_CONFIG_REG_POS_PHY_DASH;</a>
<a name="ln1359"> </a>
<a name="ln1360">	IWM_WRITE(sc, IWM_CSR_HW_IF_CONFIG_REG, reg_val);</a>
<a name="ln1361"> </a>
<a name="ln1362">	IWM_DPRINTF(sc, IWM_DEBUG_RESET,</a>
<a name="ln1363">	    &quot;Radio type=0x%x-0x%x-0x%x\n&quot;, radio_cfg_type,</a>
<a name="ln1364">	    radio_cfg_step, radio_cfg_dash);</a>
<a name="ln1365"> </a>
<a name="ln1366">	/*</a>
<a name="ln1367">	 * W/A : NIC is stuck in a reset state after Early PCIe power off</a>
<a name="ln1368">	 * (PCIe power is lost before PERST# is asserted), causing ME FW</a>
<a name="ln1369">	 * to lose ownership and not being able to obtain it back.</a>
<a name="ln1370">	 */</a>
<a name="ln1371">	if (sc-&gt;cfg-&gt;device_family == IWM_DEVICE_FAMILY_7000) {</a>
<a name="ln1372">		iwm_set_bits_mask_prph(sc, IWM_APMG_PS_CTRL_REG,</a>
<a name="ln1373">		    IWM_APMG_PS_CTRL_EARLY_PWR_OFF_RESET_DIS,</a>
<a name="ln1374">		    ~IWM_APMG_PS_CTRL_EARLY_PWR_OFF_RESET_DIS);</a>
<a name="ln1375">	}</a>
<a name="ln1376">}</a>
<a name="ln1377"> </a>
<a name="ln1378">static int</a>
<a name="ln1379">iwm_nic_rx_init(struct iwm_softc *sc)</a>
<a name="ln1380">{</a>
<a name="ln1381">	/*</a>
<a name="ln1382">	 * Initialize RX ring.  This is from the iwn driver.</a>
<a name="ln1383">	 */</a>
<a name="ln1384">	memset(sc-&gt;rxq.stat, 0, sizeof(*sc-&gt;rxq.stat));</a>
<a name="ln1385"> </a>
<a name="ln1386">	/* Stop Rx DMA */</a>
<a name="ln1387">	iwm_pcie_rx_stop(sc);</a>
<a name="ln1388"> </a>
<a name="ln1389">	if (!iwm_nic_lock(sc))</a>
<a name="ln1390">		return EBUSY;</a>
<a name="ln1391"> </a>
<a name="ln1392">	/* reset and flush pointers */</a>
<a name="ln1393">	IWM_WRITE(sc, IWM_FH_MEM_RCSR_CHNL0_RBDCB_WPTR, 0);</a>
<a name="ln1394">	IWM_WRITE(sc, IWM_FH_MEM_RCSR_CHNL0_FLUSH_RB_REQ, 0);</a>
<a name="ln1395">	IWM_WRITE(sc, IWM_FH_RSCSR_CHNL0_RDPTR, 0);</a>
<a name="ln1396">	IWM_WRITE(sc, IWM_FH_RSCSR_CHNL0_RBDCB_WPTR_REG, 0);</a>
<a name="ln1397"> </a>
<a name="ln1398">	/* Set physical address of RX ring (256-byte aligned). */</a>
<a name="ln1399">	IWM_WRITE(sc,</a>
<a name="ln1400">	    IWM_FH_RSCSR_CHNL0_RBDCB_BASE_REG, sc-&gt;rxq.desc_dma.paddr &gt;&gt; 8);</a>
<a name="ln1401"> </a>
<a name="ln1402">	/* Set physical address of RX status (16-byte aligned). */</a>
<a name="ln1403">	IWM_WRITE(sc,</a>
<a name="ln1404">	    IWM_FH_RSCSR_CHNL0_STTS_WPTR_REG, sc-&gt;rxq.stat_dma.paddr &gt;&gt; 4);</a>
<a name="ln1405"> </a>
<a name="ln1406">	/* Enable Rx DMA</a>
<a name="ln1407">	 * XXX 5000 HW isn't supported by the iwm(4) driver.</a>
<a name="ln1408">	 * IWM_FH_RCSR_CHNL0_RX_IGNORE_RXF_EMPTY is set because of HW bug in</a>
<a name="ln1409">	 *      the credit mechanism in 5000 HW RX FIFO</a>
<a name="ln1410">	 * Direct rx interrupts to hosts</a>
<a name="ln1411">	 * Rx buffer size 4 or 8k or 12k</a>
<a name="ln1412">	 * RB timeout 0x10</a>
<a name="ln1413">	 * 256 RBDs</a>
<a name="ln1414">	 */</a>
<a name="ln1415">	IWM_WRITE(sc, IWM_FH_MEM_RCSR_CHNL0_CONFIG_REG,</a>
<a name="ln1416">	    IWM_FH_RCSR_RX_CONFIG_CHNL_EN_ENABLE_VAL		|</a>
<a name="ln1417">	    IWM_FH_RCSR_CHNL0_RX_IGNORE_RXF_EMPTY		|  /* HW bug */</a>
<a name="ln1418">//#ifdef __HAIKU__</a>
<a name="ln1419">		/* multi-frame RX seems to cause UAFs and double-frees */</a>
<a name="ln1420">		IWM_FH_RCSR_CHNL0_RX_CONFIG_SINGLE_FRAME_MSK |</a>
<a name="ln1421">//#endif</a>
<a name="ln1422">	    IWM_FH_RCSR_CHNL0_RX_CONFIG_IRQ_DEST_INT_HOST_VAL	|</a>
<a name="ln1423">	    IWM_FH_RCSR_RX_CONFIG_REG_VAL_RB_SIZE_4K		|</a>
<a name="ln1424">	    (IWM_RX_RB_TIMEOUT &lt;&lt; IWM_FH_RCSR_RX_CONFIG_REG_IRQ_RBTH_POS) |</a>
<a name="ln1425">	    IWM_RX_QUEUE_SIZE_LOG &lt;&lt; IWM_FH_RCSR_RX_CONFIG_RBDCB_SIZE_POS);</a>
<a name="ln1426"> </a>
<a name="ln1427">	IWM_WRITE_1(sc, IWM_CSR_INT_COALESCING, IWM_HOST_INT_TIMEOUT_DEF);</a>
<a name="ln1428"> </a>
<a name="ln1429">	/* W/A for interrupt coalescing bug in 7260 and 3160 */</a>
<a name="ln1430">	if (sc-&gt;cfg-&gt;host_interrupt_operation_mode)</a>
<a name="ln1431">		IWM_SETBITS(sc, IWM_CSR_INT_COALESCING, IWM_HOST_INT_OPER_MODE);</a>
<a name="ln1432"> </a>
<a name="ln1433">	/*</a>
<a name="ln1434">	 * Thus sayeth el jefe (iwlwifi) via a comment:</a>
<a name="ln1435">	 *</a>
<a name="ln1436">	 * This value should initially be 0 (before preparing any</a>
<a name="ln1437">	 * RBs), should be 8 after preparing the first 8 RBs (for example)</a>
<a name="ln1438">	 */</a>
<a name="ln1439">	IWM_WRITE(sc, IWM_FH_RSCSR_CHNL0_WPTR, 8);</a>
<a name="ln1440"> </a>
<a name="ln1441">	iwm_nic_unlock(sc);</a>
<a name="ln1442"> </a>
<a name="ln1443">	return 0;</a>
<a name="ln1444">}</a>
<a name="ln1445"> </a>
<a name="ln1446">static int</a>
<a name="ln1447">iwm_nic_tx_init(struct iwm_softc *sc)</a>
<a name="ln1448">{</a>
<a name="ln1449">	int qid;</a>
<a name="ln1450"> </a>
<a name="ln1451">	if (!iwm_nic_lock(sc))</a>
<a name="ln1452">		return EBUSY;</a>
<a name="ln1453"> </a>
<a name="ln1454">	/* Deactivate TX scheduler. */</a>
<a name="ln1455">	iwm_write_prph(sc, IWM_SCD_TXFACT, 0);</a>
<a name="ln1456"> </a>
<a name="ln1457">	/* Set physical address of &quot;keep warm&quot; page (16-byte aligned). */</a>
<a name="ln1458">	IWM_WRITE(sc, IWM_FH_KW_MEM_ADDR_REG, sc-&gt;kw_dma.paddr &gt;&gt; 4);</a>
<a name="ln1459"> </a>
<a name="ln1460">	/* Initialize TX rings. */</a>
<a name="ln1461">	for (qid = 0; qid &lt; nitems(sc-&gt;txq); qid++) {</a>
<a name="ln1462">		struct iwm_tx_ring *txq = &amp;sc-&gt;txq[qid];</a>
<a name="ln1463"> </a>
<a name="ln1464">		/* Set physical address of TX ring (256-byte aligned). */</a>
<a name="ln1465">		IWM_WRITE(sc, IWM_FH_MEM_CBBC_QUEUE(qid),</a>
<a name="ln1466">		    txq-&gt;desc_dma.paddr &gt;&gt; 8);</a>
<a name="ln1467">		IWM_DPRINTF(sc, IWM_DEBUG_XMIT,</a>
<a name="ln1468">		    &quot;%s: loading ring %d descriptors (%p) at %lx\n&quot;,</a>
<a name="ln1469">		    __func__,</a>
<a name="ln1470">		    qid, txq-&gt;desc,</a>
<a name="ln1471">		    (unsigned long) (txq-&gt;desc_dma.paddr &gt;&gt; 8));</a>
<a name="ln1472">	}</a>
<a name="ln1473"> </a>
<a name="ln1474">	iwm_write_prph(sc, IWM_SCD_GP_CTRL, IWM_SCD_GP_CTRL_AUTO_ACTIVE_MODE);</a>
<a name="ln1475"> </a>
<a name="ln1476">	iwm_nic_unlock(sc);</a>
<a name="ln1477"> </a>
<a name="ln1478">	return 0;</a>
<a name="ln1479">}</a>
<a name="ln1480"> </a>
<a name="ln1481">static int</a>
<a name="ln1482">iwm_nic_init(struct iwm_softc *sc)</a>
<a name="ln1483">{</a>
<a name="ln1484">	int error;</a>
<a name="ln1485"> </a>
<a name="ln1486">	iwm_apm_init(sc);</a>
<a name="ln1487">	if (sc-&gt;cfg-&gt;device_family == IWM_DEVICE_FAMILY_7000)</a>
<a name="ln1488">		iwm_set_pwr(sc);</a>
<a name="ln1489"> </a>
<a name="ln1490">	iwm_mvm_nic_config(sc);</a>
<a name="ln1491"> </a>
<a name="ln1492">	if ((error = iwm_nic_rx_init(sc)) != 0)</a>
<a name="ln1493">		return error;</a>
<a name="ln1494"> </a>
<a name="ln1495">	/*</a>
<a name="ln1496">	 * Ditto for TX, from iwn</a>
<a name="ln1497">	 */</a>
<a name="ln1498">	if ((error = iwm_nic_tx_init(sc)) != 0)</a>
<a name="ln1499">		return error;</a>
<a name="ln1500"> </a>
<a name="ln1501">	IWM_DPRINTF(sc, IWM_DEBUG_RESET,</a>
<a name="ln1502">	    &quot;%s: shadow registers enabled\n&quot;, __func__);</a>
<a name="ln1503">	IWM_SETBITS(sc, IWM_CSR_MAC_SHADOW_REG_CTRL, 0x800fffff);</a>
<a name="ln1504"> </a>
<a name="ln1505">	return 0;</a>
<a name="ln1506">}</a>
<a name="ln1507"> </a>
<a name="ln1508">int</a>
<a name="ln1509">iwm_enable_txq(struct iwm_softc *sc, int sta_id, int qid, int fifo)</a>
<a name="ln1510">{</a>
<a name="ln1511">	if (!iwm_nic_lock(sc)) {</a>
<a name="ln1512">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln1513">		    &quot;%s: cannot enable txq %d\n&quot;,</a>
<a name="ln1514">		    __func__,</a>
<a name="ln1515">		    qid);</a>
<a name="ln1516">		return EBUSY;</a>
<a name="ln1517">	}</a>
<a name="ln1518"> </a>
<a name="ln1519">	IWM_WRITE(sc, IWM_HBUS_TARG_WRPTR, qid &lt;&lt; 8 | 0);</a>
<a name="ln1520"> </a>
<a name="ln1521">	if (qid == IWM_MVM_CMD_QUEUE) {</a>
<a name="ln1522">		/* unactivate before configuration */</a>
<a name="ln1523">		iwm_write_prph(sc, IWM_SCD_QUEUE_STATUS_BITS(qid),</a>
<a name="ln1524">		    (0 &lt;&lt; IWM_SCD_QUEUE_STTS_REG_POS_ACTIVE)</a>
<a name="ln1525">		    | (1 &lt;&lt; IWM_SCD_QUEUE_STTS_REG_POS_SCD_ACT_EN));</a>
<a name="ln1526"> </a>
<a name="ln1527">		iwm_nic_unlock(sc);</a>
<a name="ln1528"> </a>
<a name="ln1529">		iwm_clear_bits_prph(sc, IWM_SCD_AGGR_SEL, (1 &lt;&lt; qid));</a>
<a name="ln1530"> </a>
<a name="ln1531">		if (!iwm_nic_lock(sc)) {</a>
<a name="ln1532">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1533">			    &quot;%s: cannot enable txq %d\n&quot;, __func__, qid);</a>
<a name="ln1534">			return EBUSY;</a>
<a name="ln1535">		}</a>
<a name="ln1536">		iwm_write_prph(sc, IWM_SCD_QUEUE_RDPTR(qid), 0);</a>
<a name="ln1537">		iwm_nic_unlock(sc);</a>
<a name="ln1538"> </a>
<a name="ln1539">		iwm_write_mem32(sc, sc-&gt;scd_base_addr + IWM_SCD_CONTEXT_QUEUE_OFFSET(qid), 0);</a>
<a name="ln1540">		/* Set scheduler window size and frame limit. */</a>
<a name="ln1541">		iwm_write_mem32(sc,</a>
<a name="ln1542">		    sc-&gt;scd_base_addr + IWM_SCD_CONTEXT_QUEUE_OFFSET(qid) +</a>
<a name="ln1543">		    sizeof(uint32_t),</a>
<a name="ln1544">		    ((IWM_FRAME_LIMIT &lt;&lt; IWM_SCD_QUEUE_CTX_REG2_WIN_SIZE_POS) &amp;</a>
<a name="ln1545">		    IWM_SCD_QUEUE_CTX_REG2_WIN_SIZE_MSK) |</a>
<a name="ln1546">		    ((IWM_FRAME_LIMIT &lt;&lt; IWM_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_POS) &amp;</a>
<a name="ln1547">		    IWM_SCD_QUEUE_CTX_REG2_FRAME_LIMIT_MSK));</a>
<a name="ln1548"> </a>
<a name="ln1549">		if (!iwm_nic_lock(sc)) {</a>
<a name="ln1550">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1551">			    &quot;%s: cannot enable txq %d\n&quot;, __func__, qid);</a>
<a name="ln1552">			return EBUSY;</a>
<a name="ln1553">		}</a>
<a name="ln1554">		iwm_write_prph(sc, IWM_SCD_QUEUE_STATUS_BITS(qid),</a>
<a name="ln1555">		    (1 &lt;&lt; IWM_SCD_QUEUE_STTS_REG_POS_ACTIVE) |</a>
<a name="ln1556">		    (fifo &lt;&lt; IWM_SCD_QUEUE_STTS_REG_POS_TXF) |</a>
<a name="ln1557">		    (1 &lt;&lt; IWM_SCD_QUEUE_STTS_REG_POS_WSL) |</a>
<a name="ln1558">		    IWM_SCD_QUEUE_STTS_REG_MSK);</a>
<a name="ln1559">	} else {</a>
<a name="ln1560">		struct iwm_scd_txq_cfg_cmd cmd;</a>
<a name="ln1561">		int error;</a>
<a name="ln1562"> </a>
<a name="ln1563">		iwm_nic_unlock(sc);</a>
<a name="ln1564"> </a>
<a name="ln1565">		memset(&amp;cmd, 0, sizeof(cmd));</a>
<a name="ln1566">		cmd.scd_queue = qid;</a>
<a name="ln1567">		cmd.enable = 1;</a>
<a name="ln1568">		cmd.sta_id = sta_id;</a>
<a name="ln1569">		cmd.tx_fifo = fifo;</a>
<a name="ln1570">		cmd.aggregate = 0;</a>
<a name="ln1571">		cmd.window = IWM_FRAME_LIMIT;</a>
<a name="ln1572"> </a>
<a name="ln1573">		error = iwm_mvm_send_cmd_pdu(sc, IWM_SCD_QUEUE_CFG, IWM_CMD_SYNC,</a>
<a name="ln1574">		    sizeof(cmd), &amp;cmd);</a>
<a name="ln1575">		if (error) {</a>
<a name="ln1576">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1577">			    &quot;cannot enable txq %d\n&quot;, qid);</a>
<a name="ln1578">			return error;</a>
<a name="ln1579">		}</a>
<a name="ln1580"> </a>
<a name="ln1581">		if (!iwm_nic_lock(sc))</a>
<a name="ln1582">			return EBUSY;</a>
<a name="ln1583">	}</a>
<a name="ln1584"> </a>
<a name="ln1585">	iwm_write_prph(sc, IWM_SCD_EN_CTRL,</a>
<a name="ln1586">	    iwm_read_prph(sc, IWM_SCD_EN_CTRL) | qid);</a>
<a name="ln1587"> </a>
<a name="ln1588">	iwm_nic_unlock(sc);</a>
<a name="ln1589"> </a>
<a name="ln1590">	IWM_DPRINTF(sc, IWM_DEBUG_XMIT, &quot;%s: enabled txq %d FIFO %d\n&quot;,</a>
<a name="ln1591">	    __func__, qid, fifo);</a>
<a name="ln1592"> </a>
<a name="ln1593">	return 0;</a>
<a name="ln1594">}</a>
<a name="ln1595"> </a>
<a name="ln1596">static int</a>
<a name="ln1597">iwm_trans_pcie_fw_alive(struct iwm_softc *sc, uint32_t scd_base_addr)</a>
<a name="ln1598">{</a>
<a name="ln1599">	int error, chnl;</a>
<a name="ln1600"> </a>
<a name="ln1601">	int clear_dwords = (IWM_SCD_TRANS_TBL_MEM_UPPER_BOUND -</a>
<a name="ln1602">	    IWM_SCD_CONTEXT_MEM_LOWER_BOUND) / sizeof(uint32_t);</a>
<a name="ln1603"> </a>
<a name="ln1604">	if (!iwm_nic_lock(sc))</a>
<a name="ln1605">		return EBUSY;</a>
<a name="ln1606"> </a>
<a name="ln1607">#ifndef __HAIKU__</a>
<a name="ln1608">	iwm_ict_reset(sc);</a>
<a name="ln1609">#endif</a>
<a name="ln1610"> </a>
<a name="ln1611">	sc-&gt;scd_base_addr = iwm_read_prph(sc, IWM_SCD_SRAM_BASE_ADDR);</a>
<a name="ln1612">	if (scd_base_addr != 0 &amp;&amp;</a>
<a name="ln1613">	    scd_base_addr != sc-&gt;scd_base_addr) {</a>
<a name="ln1614">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln1615">		    &quot;%s: sched addr mismatch: alive: 0x%x prph: 0x%x\n&quot;,</a>
<a name="ln1616">		    __func__, sc-&gt;scd_base_addr, scd_base_addr);</a>
<a name="ln1617">	}</a>
<a name="ln1618"> </a>
<a name="ln1619">	iwm_nic_unlock(sc);</a>
<a name="ln1620"> </a>
<a name="ln1621">	/* reset context data, TX status and translation data */</a>
<a name="ln1622">	error = iwm_write_mem(sc,</a>
<a name="ln1623">	    sc-&gt;scd_base_addr + IWM_SCD_CONTEXT_MEM_LOWER_BOUND,</a>
<a name="ln1624">	    NULL, clear_dwords);</a>
<a name="ln1625">	if (error)</a>
<a name="ln1626">		return EBUSY;</a>
<a name="ln1627"> </a>
<a name="ln1628">	if (!iwm_nic_lock(sc))</a>
<a name="ln1629">		return EBUSY;</a>
<a name="ln1630"> </a>
<a name="ln1631">	/* Set physical address of TX scheduler rings (1KB aligned). */</a>
<a name="ln1632">	iwm_write_prph(sc, IWM_SCD_DRAM_BASE_ADDR, sc-&gt;sched_dma.paddr &gt;&gt; 10);</a>
<a name="ln1633"> </a>
<a name="ln1634">	iwm_write_prph(sc, IWM_SCD_CHAINEXT_EN, 0);</a>
<a name="ln1635"> </a>
<a name="ln1636">	iwm_nic_unlock(sc);</a>
<a name="ln1637"> </a>
<a name="ln1638">	/* enable command channel */</a>
<a name="ln1639">	error = iwm_enable_txq(sc, 0 /* unused */, IWM_MVM_CMD_QUEUE, 7);</a>
<a name="ln1640">	if (error)</a>
<a name="ln1641">		return error;</a>
<a name="ln1642"> </a>
<a name="ln1643">	if (!iwm_nic_lock(sc))</a>
<a name="ln1644">		return EBUSY;</a>
<a name="ln1645"> </a>
<a name="ln1646">	iwm_write_prph(sc, IWM_SCD_TXFACT, 0xff);</a>
<a name="ln1647"> </a>
<a name="ln1648">	/* Enable DMA channels. */</a>
<a name="ln1649">	for (chnl = 0; chnl &lt; IWM_FH_TCSR_CHNL_NUM; chnl++) {</a>
<a name="ln1650">		IWM_WRITE(sc, IWM_FH_TCSR_CHNL_TX_CONFIG_REG(chnl),</a>
<a name="ln1651">		    IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_ENABLE |</a>
<a name="ln1652">		    IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_ENABLE);</a>
<a name="ln1653">	}</a>
<a name="ln1654"> </a>
<a name="ln1655">	IWM_SETBITS(sc, IWM_FH_TX_CHICKEN_BITS_REG,</a>
<a name="ln1656">	    IWM_FH_TX_CHICKEN_BITS_SCD_AUTO_RETRY_EN);</a>
<a name="ln1657"> </a>
<a name="ln1658">	iwm_nic_unlock(sc);</a>
<a name="ln1659"> </a>
<a name="ln1660">	/* Enable L1-Active */</a>
<a name="ln1661">	if (sc-&gt;cfg-&gt;device_family != IWM_DEVICE_FAMILY_8000) {</a>
<a name="ln1662">		iwm_clear_bits_prph(sc, IWM_APMG_PCIDEV_STT_REG,</a>
<a name="ln1663">		    IWM_APMG_PCIDEV_STT_VAL_L1_ACT_DIS);</a>
<a name="ln1664">	}</a>
<a name="ln1665"> </a>
<a name="ln1666">	return error;</a>
<a name="ln1667">}</a>
<a name="ln1668"> </a>
<a name="ln1669">/*</a>
<a name="ln1670"> * NVM read access and content parsing.  We do not support</a>
<a name="ln1671"> * external NVM or writing NVM.</a>
<a name="ln1672"> * iwlwifi/mvm/nvm.c</a>
<a name="ln1673"> */</a>
<a name="ln1674"> </a>
<a name="ln1675">/* Default NVM size to read */</a>
<a name="ln1676">#define IWM_NVM_DEFAULT_CHUNK_SIZE	(2*1024)</a>
<a name="ln1677"> </a>
<a name="ln1678">#define IWM_NVM_WRITE_OPCODE 1</a>
<a name="ln1679">#define IWM_NVM_READ_OPCODE 0</a>
<a name="ln1680"> </a>
<a name="ln1681">/* load nvm chunk response */</a>
<a name="ln1682">enum {</a>
<a name="ln1683">	IWM_READ_NVM_CHUNK_SUCCEED = 0,</a>
<a name="ln1684">	IWM_READ_NVM_CHUNK_NOT_VALID_ADDRESS = 1</a>
<a name="ln1685">};</a>
<a name="ln1686"> </a>
<a name="ln1687">static int</a>
<a name="ln1688">iwm_nvm_read_chunk(struct iwm_softc *sc, uint16_t section,</a>
<a name="ln1689">	uint16_t offset, uint16_t length, uint8_t *data, uint16_t *len)</a>
<a name="ln1690">{</a>
<a name="ln1691">	struct iwm_nvm_access_cmd nvm_access_cmd = {</a>
<a name="ln1692">		.offset = htole16(offset),</a>
<a name="ln1693">		.length = htole16(length),</a>
<a name="ln1694">		.type = htole16(section),</a>
<a name="ln1695">		.op_code = IWM_NVM_READ_OPCODE,</a>
<a name="ln1696">	};</a>
<a name="ln1697">	struct iwm_nvm_access_resp *nvm_resp;</a>
<a name="ln1698">	struct iwm_rx_packet *pkt;</a>
<a name="ln1699">	struct iwm_host_cmd cmd = {</a>
<a name="ln1700">		.id = IWM_NVM_ACCESS_CMD,</a>
<a name="ln1701">		.flags = IWM_CMD_WANT_SKB | IWM_CMD_SEND_IN_RFKILL,</a>
<a name="ln1702">		.data = { &amp;nvm_access_cmd, },</a>
<a name="ln1703">	};</a>
<a name="ln1704">	int ret, bytes_read, offset_read;</a>
<a name="ln1705">	uint8_t *resp_data;</a>
<a name="ln1706"> </a>
<a name="ln1707">	cmd.len[0] = sizeof(struct iwm_nvm_access_cmd);</a>
<a name="ln1708"> </a>
<a name="ln1709">	ret = iwm_send_cmd(sc, &amp;cmd);</a>
<a name="ln1710">	if (ret) {</a>
<a name="ln1711">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln1712">		    &quot;Could not send NVM_ACCESS command (error=%d)\n&quot;, ret);</a>
<a name="ln1713">		return ret;</a>
<a name="ln1714">	}</a>
<a name="ln1715"> </a>
<a name="ln1716">	pkt = cmd.resp_pkt;</a>
<a name="ln1717"> </a>
<a name="ln1718">	/* Extract NVM response */</a>
<a name="ln1719">	nvm_resp = (void *)pkt-&gt;data;</a>
<a name="ln1720">	ret = le16toh(nvm_resp-&gt;status);</a>
<a name="ln1721">	bytes_read = le16toh(nvm_resp-&gt;length);</a>
<a name="ln1722">	offset_read = le16toh(nvm_resp-&gt;offset);</a>
<a name="ln1723">	resp_data = nvm_resp-&gt;data;</a>
<a name="ln1724">	if (ret) {</a>
<a name="ln1725">		if ((offset != 0) &amp;&amp;</a>
<a name="ln1726">		    (ret == IWM_READ_NVM_CHUNK_NOT_VALID_ADDRESS)) {</a>
<a name="ln1727">			/*</a>
<a name="ln1728">			 * meaning of NOT_VALID_ADDRESS:</a>
<a name="ln1729">			 * driver try to read chunk from address that is</a>
<a name="ln1730">			 * multiple of 2K and got an error since addr is empty.</a>
<a name="ln1731">			 * meaning of (offset != 0): driver already</a>
<a name="ln1732">			 * read valid data from another chunk so this case</a>
<a name="ln1733">			 * is not an error.</a>
<a name="ln1734">			 */</a>
<a name="ln1735">			IWM_DPRINTF(sc, IWM_DEBUG_EEPROM | IWM_DEBUG_RESET,</a>
<a name="ln1736">				    &quot;NVM access command failed on offset 0x%x since that section size is multiple 2K\n&quot;,</a>
<a name="ln1737">				    offset);</a>
<a name="ln1738">			*len = 0;</a>
<a name="ln1739">			ret = 0;</a>
<a name="ln1740">		} else {</a>
<a name="ln1741">			IWM_DPRINTF(sc, IWM_DEBUG_EEPROM | IWM_DEBUG_RESET,</a>
<a name="ln1742">				    &quot;NVM access command failed with status %d\n&quot;, ret);</a>
<a name="ln1743">			ret = EIO;</a>
<a name="ln1744">		}</a>
<a name="ln1745">		goto exit;</a>
<a name="ln1746">	}</a>
<a name="ln1747"> </a>
<a name="ln1748">	if (offset_read != offset) {</a>
<a name="ln1749">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln1750">		    &quot;NVM ACCESS response with invalid offset %d\n&quot;,</a>
<a name="ln1751">		    offset_read);</a>
<a name="ln1752">		ret = EINVAL;</a>
<a name="ln1753">		goto exit;</a>
<a name="ln1754">	}</a>
<a name="ln1755"> </a>
<a name="ln1756">	if (bytes_read &gt; length) {</a>
<a name="ln1757">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln1758">		    &quot;NVM ACCESS response with too much data &quot;</a>
<a name="ln1759">		    &quot;(%d bytes requested, %d bytes received)\n&quot;,</a>
<a name="ln1760">		    length, bytes_read);</a>
<a name="ln1761">		ret = EINVAL;</a>
<a name="ln1762">		goto exit;</a>
<a name="ln1763">	}</a>
<a name="ln1764"> </a>
<a name="ln1765">	/* Write data to NVM */</a>
<a name="ln1766">	memcpy(data + offset, resp_data, bytes_read);</a>
<a name="ln1767">	*len = bytes_read;</a>
<a name="ln1768"> </a>
<a name="ln1769"> exit:</a>
<a name="ln1770">	iwm_free_resp(sc, &amp;cmd);</a>
<a name="ln1771">	return ret;</a>
<a name="ln1772">}</a>
<a name="ln1773"> </a>
<a name="ln1774">/*</a>
<a name="ln1775"> * Reads an NVM section completely.</a>
<a name="ln1776"> * NICs prior to 7000 family don't have a real NVM, but just read</a>
<a name="ln1777"> * section 0 which is the EEPROM. Because the EEPROM reading is unlimited</a>
<a name="ln1778"> * by uCode, we need to manually check in this case that we don't</a>
<a name="ln1779"> * overflow and try to read more than the EEPROM size.</a>
<a name="ln1780"> * For 7000 family NICs, we supply the maximal size we can read, and</a>
<a name="ln1781"> * the uCode fills the response with as much data as we can,</a>
<a name="ln1782"> * without overflowing, so no check is needed.</a>
<a name="ln1783"> */</a>
<a name="ln1784">static int</a>
<a name="ln1785">iwm_nvm_read_section(struct iwm_softc *sc,</a>
<a name="ln1786">	uint16_t section, uint8_t *data, uint16_t *len, uint32_t size_read)</a>
<a name="ln1787">{</a>
<a name="ln1788">	uint16_t seglen, length, offset = 0;</a>
<a name="ln1789">	int ret;</a>
<a name="ln1790"> </a>
<a name="ln1791">	/* Set nvm section read length */</a>
<a name="ln1792">	length = IWM_NVM_DEFAULT_CHUNK_SIZE;</a>
<a name="ln1793"> </a>
<a name="ln1794">	seglen = length;</a>
<a name="ln1795"> </a>
<a name="ln1796">	/* Read the NVM until exhausted (reading less than requested) */</a>
<a name="ln1797">	while (seglen == length) {</a>
<a name="ln1798">		/* Check no memory assumptions fail and cause an overflow */</a>
<a name="ln1799">		if ((size_read + offset + length) &gt;</a>
<a name="ln1800">		    sc-&gt;cfg-&gt;eeprom_size) {</a>
<a name="ln1801">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1802">			    &quot;EEPROM size is too small for NVM\n&quot;);</a>
<a name="ln1803">			return ENOBUFS;</a>
<a name="ln1804">		}</a>
<a name="ln1805"> </a>
<a name="ln1806">		ret = iwm_nvm_read_chunk(sc, section, offset, length, data, &amp;seglen);</a>
<a name="ln1807">		if (ret) {</a>
<a name="ln1808">			IWM_DPRINTF(sc, IWM_DEBUG_EEPROM | IWM_DEBUG_RESET,</a>
<a name="ln1809">				    &quot;Cannot read NVM from section %d offset %d, length %d\n&quot;,</a>
<a name="ln1810">				    section, offset, length);</a>
<a name="ln1811">			return ret;</a>
<a name="ln1812">		}</a>
<a name="ln1813">		offset += seglen;</a>
<a name="ln1814">	}</a>
<a name="ln1815"> </a>
<a name="ln1816">	IWM_DPRINTF(sc, IWM_DEBUG_EEPROM | IWM_DEBUG_RESET,</a>
<a name="ln1817">		    &quot;NVM section %d read completed\n&quot;, section);</a>
<a name="ln1818">	*len = offset;</a>
<a name="ln1819">	return 0;</a>
<a name="ln1820">}</a>
<a name="ln1821"> </a>
<a name="ln1822">/*</a>
<a name="ln1823"> * BEGIN IWM_NVM_PARSE</a>
<a name="ln1824"> */</a>
<a name="ln1825"> </a>
<a name="ln1826">/* iwlwifi/iwl-nvm-parse.c */</a>
<a name="ln1827"> </a>
<a name="ln1828">/* NVM offsets (in words) definitions */</a>
<a name="ln1829">enum iwm_nvm_offsets {</a>
<a name="ln1830">	/* NVM HW-Section offset (in words) definitions */</a>
<a name="ln1831">	IWM_HW_ADDR = 0x15,</a>
<a name="ln1832"> </a>
<a name="ln1833">/* NVM SW-Section offset (in words) definitions */</a>
<a name="ln1834">	IWM_NVM_SW_SECTION = 0x1C0,</a>
<a name="ln1835">	IWM_NVM_VERSION = 0,</a>
<a name="ln1836">	IWM_RADIO_CFG = 1,</a>
<a name="ln1837">	IWM_SKU = 2,</a>
<a name="ln1838">	IWM_N_HW_ADDRS = 3,</a>
<a name="ln1839">	IWM_NVM_CHANNELS = 0x1E0 - IWM_NVM_SW_SECTION,</a>
<a name="ln1840"> </a>
<a name="ln1841">/* NVM calibration section offset (in words) definitions */</a>
<a name="ln1842">	IWM_NVM_CALIB_SECTION = 0x2B8,</a>
<a name="ln1843">	IWM_XTAL_CALIB = 0x316 - IWM_NVM_CALIB_SECTION</a>
<a name="ln1844">};</a>
<a name="ln1845"> </a>
<a name="ln1846">enum iwm_8000_nvm_offsets {</a>
<a name="ln1847">	/* NVM HW-Section offset (in words) definitions */</a>
<a name="ln1848">	IWM_HW_ADDR0_WFPM_8000 = 0x12,</a>
<a name="ln1849">	IWM_HW_ADDR1_WFPM_8000 = 0x16,</a>
<a name="ln1850">	IWM_HW_ADDR0_PCIE_8000 = 0x8A,</a>
<a name="ln1851">	IWM_HW_ADDR1_PCIE_8000 = 0x8E,</a>
<a name="ln1852">	IWM_MAC_ADDRESS_OVERRIDE_8000 = 1,</a>
<a name="ln1853"> </a>
<a name="ln1854">	/* NVM SW-Section offset (in words) definitions */</a>
<a name="ln1855">	IWM_NVM_SW_SECTION_8000 = 0x1C0,</a>
<a name="ln1856">	IWM_NVM_VERSION_8000 = 0,</a>
<a name="ln1857">	IWM_RADIO_CFG_8000 = 0,</a>
<a name="ln1858">	IWM_SKU_8000 = 2,</a>
<a name="ln1859">	IWM_N_HW_ADDRS_8000 = 3,</a>
<a name="ln1860"> </a>
<a name="ln1861">	/* NVM REGULATORY -Section offset (in words) definitions */</a>
<a name="ln1862">	IWM_NVM_CHANNELS_8000 = 0,</a>
<a name="ln1863">	IWM_NVM_LAR_OFFSET_8000_OLD = 0x4C7,</a>
<a name="ln1864">	IWM_NVM_LAR_OFFSET_8000 = 0x507,</a>
<a name="ln1865">	IWM_NVM_LAR_ENABLED_8000 = 0x7,</a>
<a name="ln1866"> </a>
<a name="ln1867">	/* NVM calibration section offset (in words) definitions */</a>
<a name="ln1868">	IWM_NVM_CALIB_SECTION_8000 = 0x2B8,</a>
<a name="ln1869">	IWM_XTAL_CALIB_8000 = 0x316 - IWM_NVM_CALIB_SECTION_8000</a>
<a name="ln1870">};</a>
<a name="ln1871"> </a>
<a name="ln1872">/* SKU Capabilities (actual values from NVM definition) */</a>
<a name="ln1873">enum nvm_sku_bits {</a>
<a name="ln1874">	IWM_NVM_SKU_CAP_BAND_24GHZ	= (1 &lt;&lt; 0),</a>
<a name="ln1875">	IWM_NVM_SKU_CAP_BAND_52GHZ	= (1 &lt;&lt; 1),</a>
<a name="ln1876">	IWM_NVM_SKU_CAP_11N_ENABLE	= (1 &lt;&lt; 2),</a>
<a name="ln1877">	IWM_NVM_SKU_CAP_11AC_ENABLE	= (1 &lt;&lt; 3),</a>
<a name="ln1878">};</a>
<a name="ln1879"> </a>
<a name="ln1880">/* radio config bits (actual values from NVM definition) */</a>
<a name="ln1881">#define IWM_NVM_RF_CFG_DASH_MSK(x)   (x &amp; 0x3)         /* bits 0-1   */</a>
<a name="ln1882">#define IWM_NVM_RF_CFG_STEP_MSK(x)   ((x &gt;&gt; 2)  &amp; 0x3) /* bits 2-3   */</a>
<a name="ln1883">#define IWM_NVM_RF_CFG_TYPE_MSK(x)   ((x &gt;&gt; 4)  &amp; 0x3) /* bits 4-5   */</a>
<a name="ln1884">#define IWM_NVM_RF_CFG_PNUM_MSK(x)   ((x &gt;&gt; 6)  &amp; 0x3) /* bits 6-7   */</a>
<a name="ln1885">#define IWM_NVM_RF_CFG_TX_ANT_MSK(x) ((x &gt;&gt; 8)  &amp; 0xF) /* bits 8-11  */</a>
<a name="ln1886">#define IWM_NVM_RF_CFG_RX_ANT_MSK(x) ((x &gt;&gt; 12) &amp; 0xF) /* bits 12-15 */</a>
<a name="ln1887"> </a>
<a name="ln1888">#define IWM_NVM_RF_CFG_FLAVOR_MSK_8000(x)	(x &amp; 0xF)</a>
<a name="ln1889">#define IWM_NVM_RF_CFG_DASH_MSK_8000(x)		((x &gt;&gt; 4) &amp; 0xF)</a>
<a name="ln1890">#define IWM_NVM_RF_CFG_STEP_MSK_8000(x)		((x &gt;&gt; 8) &amp; 0xF)</a>
<a name="ln1891">#define IWM_NVM_RF_CFG_TYPE_MSK_8000(x)		((x &gt;&gt; 12) &amp; 0xFFF)</a>
<a name="ln1892">#define IWM_NVM_RF_CFG_TX_ANT_MSK_8000(x)	((x &gt;&gt; 24) &amp; 0xF)</a>
<a name="ln1893">#define IWM_NVM_RF_CFG_RX_ANT_MSK_8000(x)	((x &gt;&gt; 28) &amp; 0xF)</a>
<a name="ln1894"> </a>
<a name="ln1895">/**</a>
<a name="ln1896"> * enum iwm_nvm_channel_flags - channel flags in NVM</a>
<a name="ln1897"> * @IWM_NVM_CHANNEL_VALID: channel is usable for this SKU/geo</a>
<a name="ln1898"> * @IWM_NVM_CHANNEL_IBSS: usable as an IBSS channel</a>
<a name="ln1899"> * @IWM_NVM_CHANNEL_ACTIVE: active scanning allowed</a>
<a name="ln1900"> * @IWM_NVM_CHANNEL_RADAR: radar detection required</a>
<a name="ln1901"> * XXX cannot find this (DFS) flag in iwm-nvm-parse.c</a>
<a name="ln1902"> * @IWM_NVM_CHANNEL_DFS: dynamic freq selection candidate</a>
<a name="ln1903"> * @IWM_NVM_CHANNEL_WIDE: 20 MHz channel okay (?)</a>
<a name="ln1904"> * @IWM_NVM_CHANNEL_40MHZ: 40 MHz channel okay (?)</a>
<a name="ln1905"> * @IWM_NVM_CHANNEL_80MHZ: 80 MHz channel okay (?)</a>
<a name="ln1906"> * @IWM_NVM_CHANNEL_160MHZ: 160 MHz channel okay (?)</a>
<a name="ln1907"> */</a>
<a name="ln1908">enum iwm_nvm_channel_flags {</a>
<a name="ln1909">	IWM_NVM_CHANNEL_VALID = (1 &lt;&lt; 0),</a>
<a name="ln1910">	IWM_NVM_CHANNEL_IBSS = (1 &lt;&lt; 1),</a>
<a name="ln1911">	IWM_NVM_CHANNEL_ACTIVE = (1 &lt;&lt; 3),</a>
<a name="ln1912">	IWM_NVM_CHANNEL_RADAR = (1 &lt;&lt; 4),</a>
<a name="ln1913">	IWM_NVM_CHANNEL_DFS = (1 &lt;&lt; 7),</a>
<a name="ln1914">	IWM_NVM_CHANNEL_WIDE = (1 &lt;&lt; 8),</a>
<a name="ln1915">	IWM_NVM_CHANNEL_40MHZ = (1 &lt;&lt; 9),</a>
<a name="ln1916">	IWM_NVM_CHANNEL_80MHZ = (1 &lt;&lt; 10),</a>
<a name="ln1917">	IWM_NVM_CHANNEL_160MHZ = (1 &lt;&lt; 11),</a>
<a name="ln1918">};</a>
<a name="ln1919"> </a>
<a name="ln1920">/*</a>
<a name="ln1921"> * Translate EEPROM flags to net80211.</a>
<a name="ln1922"> */</a>
<a name="ln1923">static uint32_t</a>
<a name="ln1924">iwm_eeprom_channel_flags(uint16_t ch_flags)</a>
<a name="ln1925">{</a>
<a name="ln1926">	uint32_t nflags;</a>
<a name="ln1927"> </a>
<a name="ln1928">	nflags = 0;</a>
<a name="ln1929">	if ((ch_flags &amp; IWM_NVM_CHANNEL_ACTIVE) == 0)</a>
<a name="ln1930">		nflags |= IEEE80211_CHAN_PASSIVE;</a>
<a name="ln1931">	if ((ch_flags &amp; IWM_NVM_CHANNEL_IBSS) == 0)</a>
<a name="ln1932">		nflags |= IEEE80211_CHAN_NOADHOC;</a>
<a name="ln1933">	if (ch_flags &amp; IWM_NVM_CHANNEL_RADAR) {</a>
<a name="ln1934">		nflags |= IEEE80211_CHAN_DFS;</a>
<a name="ln1935">		/* Just in case. */</a>
<a name="ln1936">		nflags |= IEEE80211_CHAN_NOADHOC;</a>
<a name="ln1937">	}</a>
<a name="ln1938"> </a>
<a name="ln1939">	return (nflags);</a>
<a name="ln1940">}</a>
<a name="ln1941"> </a>
<a name="ln1942">static void</a>
<a name="ln1943">iwm_add_channel_band(struct iwm_softc *sc, struct ieee80211_channel chans[],</a>
<a name="ln1944">    int maxchans, int *nchans, int ch_idx, size_t ch_num,</a>
<a name="ln1945">    const uint8_t bands[])</a>
<a name="ln1946">{</a>
<a name="ln1947">	const uint16_t * const nvm_ch_flags = sc-&gt;nvm_data-&gt;nvm_ch_flags;</a>
<a name="ln1948">	uint32_t nflags;</a>
<a name="ln1949">	uint16_t ch_flags;</a>
<a name="ln1950">	uint8_t ieee;</a>
<a name="ln1951">	int error;</a>
<a name="ln1952"> </a>
<a name="ln1953">	for (; ch_idx &lt; ch_num; ch_idx++) {</a>
<a name="ln1954">		ch_flags = le16_to_cpup(nvm_ch_flags + ch_idx);</a>
<a name="ln1955">		if (sc-&gt;cfg-&gt;device_family == IWM_DEVICE_FAMILY_7000)</a>
<a name="ln1956">			ieee = iwm_nvm_channels[ch_idx];</a>
<a name="ln1957">		else</a>
<a name="ln1958">			ieee = iwm_nvm_channels_8000[ch_idx];</a>
<a name="ln1959"> </a>
<a name="ln1960">		if (!(ch_flags &amp; IWM_NVM_CHANNEL_VALID)) {</a>
<a name="ln1961">			IWM_DPRINTF(sc, IWM_DEBUG_EEPROM,</a>
<a name="ln1962">			    &quot;Ch. %d Flags %x [%sGHz] - No traffic\n&quot;,</a>
<a name="ln1963">			    ieee, ch_flags,</a>
<a name="ln1964">			    (ch_idx &gt;= IWM_NUM_2GHZ_CHANNELS) ?</a>
<a name="ln1965">			    &quot;5.2&quot; : &quot;2.4&quot;);</a>
<a name="ln1966">			continue;</a>
<a name="ln1967">		}</a>
<a name="ln1968"> </a>
<a name="ln1969">		nflags = iwm_eeprom_channel_flags(ch_flags);</a>
<a name="ln1970">		error = ieee80211_add_channel(chans, maxchans, nchans,</a>
<a name="ln1971">		    ieee, 0, 0, nflags, bands);</a>
<a name="ln1972">		if (error != 0)</a>
<a name="ln1973">			break;</a>
<a name="ln1974"> </a>
<a name="ln1975">		IWM_DPRINTF(sc, IWM_DEBUG_EEPROM,</a>
<a name="ln1976">		    &quot;Ch. %d Flags %x [%sGHz] - Added\n&quot;,</a>
<a name="ln1977">		    ieee, ch_flags,</a>
<a name="ln1978">		    (ch_idx &gt;= IWM_NUM_2GHZ_CHANNELS) ?</a>
<a name="ln1979">		    &quot;5.2&quot; : &quot;2.4&quot;);</a>
<a name="ln1980">	}</a>
<a name="ln1981">}</a>
<a name="ln1982"> </a>
<a name="ln1983">static void</a>
<a name="ln1984">iwm_init_channel_map(struct ieee80211com *ic, int maxchans, int *nchans,</a>
<a name="ln1985">    struct ieee80211_channel chans[])</a>
<a name="ln1986">{</a>
<a name="ln1987">	struct iwm_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1988">	struct iwm_nvm_data *data = sc-&gt;nvm_data;</a>
<a name="ln1989">	uint8_t bands[IEEE80211_MODE_BYTES];</a>
<a name="ln1990">	size_t ch_num;</a>
<a name="ln1991"> </a>
<a name="ln1992">	memset(bands, 0, sizeof(bands));</a>
<a name="ln1993">	/* 1-13: 11b/g channels. */</a>
<a name="ln1994">	setbit(bands, IEEE80211_MODE_11B);</a>
<a name="ln1995">	setbit(bands, IEEE80211_MODE_11G);</a>
<a name="ln1996">	iwm_add_channel_band(sc, chans, maxchans, nchans, 0,</a>
<a name="ln1997">	    IWM_NUM_2GHZ_CHANNELS - 1, bands);</a>
<a name="ln1998"> </a>
<a name="ln1999">	/* 14: 11b channel only. */</a>
<a name="ln2000">	clrbit(bands, IEEE80211_MODE_11G);</a>
<a name="ln2001">	iwm_add_channel_band(sc, chans, maxchans, nchans,</a>
<a name="ln2002">	    IWM_NUM_2GHZ_CHANNELS - 1, IWM_NUM_2GHZ_CHANNELS, bands);</a>
<a name="ln2003"> </a>
<a name="ln2004">	if (data-&gt;sku_cap_band_52GHz_enable) {</a>
<a name="ln2005">		if (sc-&gt;cfg-&gt;device_family == IWM_DEVICE_FAMILY_7000)</a>
<a name="ln2006">			ch_num = nitems(iwm_nvm_channels);</a>
<a name="ln2007">		else</a>
<a name="ln2008">			ch_num = nitems(iwm_nvm_channels_8000);</a>
<a name="ln2009">		memset(bands, 0, sizeof(bands));</a>
<a name="ln2010">		setbit(bands, IEEE80211_MODE_11A);</a>
<a name="ln2011">		iwm_add_channel_band(sc, chans, maxchans, nchans,</a>
<a name="ln2012">		    IWM_NUM_2GHZ_CHANNELS, ch_num, bands);</a>
<a name="ln2013">	}</a>
<a name="ln2014">}</a>
<a name="ln2015"> </a>
<a name="ln2016">static void</a>
<a name="ln2017">iwm_set_hw_address_family_8000(struct iwm_softc *sc, struct iwm_nvm_data *data,</a>
<a name="ln2018">	const uint16_t *mac_override, const uint16_t *nvm_hw)</a>
<a name="ln2019">{</a>
<a name="ln2020">	const uint8_t *hw_addr;</a>
<a name="ln2021"> </a>
<a name="ln2022">	if (mac_override) {</a>
<a name="ln2023">		static const uint8_t reserved_mac[] = {</a>
<a name="ln2024">			0x02, 0xcc, 0xaa, 0xff, 0xee, 0x00</a>
<a name="ln2025">		};</a>
<a name="ln2026"> </a>
<a name="ln2027">		hw_addr = (const uint8_t *)(mac_override +</a>
<a name="ln2028">				 IWM_MAC_ADDRESS_OVERRIDE_8000);</a>
<a name="ln2029"> </a>
<a name="ln2030">		/*</a>
<a name="ln2031">		 * Store the MAC address from MAO section.</a>
<a name="ln2032">		 * No byte swapping is required in MAO section</a>
<a name="ln2033">		 */</a>
<a name="ln2034">		IEEE80211_ADDR_COPY(data-&gt;hw_addr, hw_addr);</a>
<a name="ln2035"> </a>
<a name="ln2036">		/*</a>
<a name="ln2037">		 * Force the use of the OTP MAC address in case of reserved MAC</a>
<a name="ln2038">		 * address in the NVM, or if address is given but invalid.</a>
<a name="ln2039">		 */</a>
<a name="ln2040">		if (!IEEE80211_ADDR_EQ(reserved_mac, hw_addr) &amp;&amp;</a>
<a name="ln2041">		    !IEEE80211_ADDR_EQ(ieee80211broadcastaddr, data-&gt;hw_addr) &amp;&amp;</a>
<a name="ln2042">		    iwm_is_valid_ether_addr(data-&gt;hw_addr) &amp;&amp;</a>
<a name="ln2043">		    !IEEE80211_IS_MULTICAST(data-&gt;hw_addr))</a>
<a name="ln2044">			return;</a>
<a name="ln2045"> </a>
<a name="ln2046">		IWM_DPRINTF(sc, IWM_DEBUG_RESET,</a>
<a name="ln2047">		    &quot;%s: mac address from nvm override section invalid\n&quot;,</a>
<a name="ln2048">		    __func__);</a>
<a name="ln2049">	}</a>
<a name="ln2050"> </a>
<a name="ln2051">	if (nvm_hw) {</a>
<a name="ln2052">		/* read the mac address from WFMP registers */</a>
<a name="ln2053">		uint32_t mac_addr0 =</a>
<a name="ln2054">		    htole32(iwm_read_prph(sc, IWM_WFMP_MAC_ADDR_0));</a>
<a name="ln2055">		uint32_t mac_addr1 =</a>
<a name="ln2056">		    htole32(iwm_read_prph(sc, IWM_WFMP_MAC_ADDR_1));</a>
<a name="ln2057"> </a>
<a name="ln2058">		hw_addr = (const uint8_t *)&amp;mac_addr0;</a>
<a name="ln2059">		data-&gt;hw_addr[0] = hw_addr[3];</a>
<a name="ln2060">		data-&gt;hw_addr[1] = hw_addr[2];</a>
<a name="ln2061">		data-&gt;hw_addr[2] = hw_addr[1];</a>
<a name="ln2062">		data-&gt;hw_addr[3] = hw_addr[0];</a>
<a name="ln2063"> </a>
<a name="ln2064">		hw_addr = (const uint8_t *)&amp;mac_addr1;</a>
<a name="ln2065">		data-&gt;hw_addr[4] = hw_addr[1];</a>
<a name="ln2066">		data-&gt;hw_addr[5] = hw_addr[0];</a>
<a name="ln2067"> </a>
<a name="ln2068">		return;</a>
<a name="ln2069">	}</a>
<a name="ln2070"> </a>
<a name="ln2071">	device_printf(sc-&gt;sc_dev, &quot;%s: mac address not found\n&quot;, __func__);</a>
<a name="ln2072">	memset(data-&gt;hw_addr, 0, sizeof(data-&gt;hw_addr));</a>
<a name="ln2073">}</a>
<a name="ln2074"> </a>
<a name="ln2075">static int</a>
<a name="ln2076">iwm_get_sku(const struct iwm_softc *sc, const uint16_t *nvm_sw,</a>
<a name="ln2077">	    const uint16_t *phy_sku)</a>
<a name="ln2078">{</a>
<a name="ln2079">	if (sc-&gt;cfg-&gt;device_family != IWM_DEVICE_FAMILY_8000)</a>
<a name="ln2080">		return le16_to_cpup(nvm_sw + IWM_SKU);</a>
<a name="ln2081"> </a>
<a name="ln2082">	return le32_to_cpup((const uint32_t *)(phy_sku + IWM_SKU_8000));</a>
<a name="ln2083">}</a>
<a name="ln2084"> </a>
<a name="ln2085">static int</a>
<a name="ln2086">iwm_get_nvm_version(const struct iwm_softc *sc, const uint16_t *nvm_sw)</a>
<a name="ln2087">{</a>
<a name="ln2088">	if (sc-&gt;cfg-&gt;device_family != IWM_DEVICE_FAMILY_8000)</a>
<a name="ln2089">		return le16_to_cpup(nvm_sw + IWM_NVM_VERSION);</a>
<a name="ln2090">	else</a>
<a name="ln2091">		return le32_to_cpup((const uint32_t *)(nvm_sw +</a>
<a name="ln2092">						IWM_NVM_VERSION_8000));</a>
<a name="ln2093">}</a>
<a name="ln2094"> </a>
<a name="ln2095">static int</a>
<a name="ln2096">iwm_get_radio_cfg(const struct iwm_softc *sc, const uint16_t *nvm_sw,</a>
<a name="ln2097">		  const uint16_t *phy_sku)</a>
<a name="ln2098">{</a>
<a name="ln2099">        if (sc-&gt;cfg-&gt;device_family != IWM_DEVICE_FAMILY_8000)</a>
<a name="ln2100">                return le16_to_cpup(nvm_sw + IWM_RADIO_CFG);</a>
<a name="ln2101"> </a>
<a name="ln2102">        return le32_to_cpup((const uint32_t *)(phy_sku + IWM_RADIO_CFG_8000));</a>
<a name="ln2103">}</a>
<a name="ln2104"> </a>
<a name="ln2105">static int</a>
<a name="ln2106">iwm_get_n_hw_addrs(const struct iwm_softc *sc, const uint16_t *nvm_sw)</a>
<a name="ln2107">{</a>
<a name="ln2108">	int n_hw_addr;</a>
<a name="ln2109"> </a>
<a name="ln2110">	if (sc-&gt;cfg-&gt;device_family != IWM_DEVICE_FAMILY_8000)</a>
<a name="ln2111">		return le16_to_cpup(nvm_sw + IWM_N_HW_ADDRS);</a>
<a name="ln2112"> </a>
<a name="ln2113">	n_hw_addr = le32_to_cpup((const uint32_t *)(nvm_sw + IWM_N_HW_ADDRS_8000));</a>
<a name="ln2114"> </a>
<a name="ln2115">        return n_hw_addr &amp; IWM_N_HW_ADDR_MASK;</a>
<a name="ln2116">}</a>
<a name="ln2117"> </a>
<a name="ln2118">static void</a>
<a name="ln2119">iwm_set_radio_cfg(const struct iwm_softc *sc, struct iwm_nvm_data *data,</a>
<a name="ln2120">		  uint32_t radio_cfg)</a>
<a name="ln2121">{</a>
<a name="ln2122">	if (sc-&gt;cfg-&gt;device_family != IWM_DEVICE_FAMILY_8000) {</a>
<a name="ln2123">		data-&gt;radio_cfg_type = IWM_NVM_RF_CFG_TYPE_MSK(radio_cfg);</a>
<a name="ln2124">		data-&gt;radio_cfg_step = IWM_NVM_RF_CFG_STEP_MSK(radio_cfg);</a>
<a name="ln2125">		data-&gt;radio_cfg_dash = IWM_NVM_RF_CFG_DASH_MSK(radio_cfg);</a>
<a name="ln2126">		data-&gt;radio_cfg_pnum = IWM_NVM_RF_CFG_PNUM_MSK(radio_cfg);</a>
<a name="ln2127">		return;</a>
<a name="ln2128">	}</a>
<a name="ln2129"> </a>
<a name="ln2130">	/* set the radio configuration for family 8000 */</a>
<a name="ln2131">	data-&gt;radio_cfg_type = IWM_NVM_RF_CFG_TYPE_MSK_8000(radio_cfg);</a>
<a name="ln2132">	data-&gt;radio_cfg_step = IWM_NVM_RF_CFG_STEP_MSK_8000(radio_cfg);</a>
<a name="ln2133">	data-&gt;radio_cfg_dash = IWM_NVM_RF_CFG_DASH_MSK_8000(radio_cfg);</a>
<a name="ln2134">	data-&gt;radio_cfg_pnum = IWM_NVM_RF_CFG_FLAVOR_MSK_8000(radio_cfg);</a>
<a name="ln2135">	data-&gt;valid_tx_ant = IWM_NVM_RF_CFG_TX_ANT_MSK_8000(radio_cfg);</a>
<a name="ln2136">	data-&gt;valid_rx_ant = IWM_NVM_RF_CFG_RX_ANT_MSK_8000(radio_cfg);</a>
<a name="ln2137">}</a>
<a name="ln2138"> </a>
<a name="ln2139">static int</a>
<a name="ln2140">iwm_set_hw_address(struct iwm_softc *sc, struct iwm_nvm_data *data,</a>
<a name="ln2141">		   const uint16_t *nvm_hw, const uint16_t *mac_override)</a>
<a name="ln2142">{</a>
<a name="ln2143">#ifdef notyet /* for FAMILY 9000 */</a>
<a name="ln2144">	if (cfg-&gt;mac_addr_from_csr) {</a>
<a name="ln2145">		iwm_set_hw_address_from_csr(sc, data);</a>
<a name="ln2146">        } else</a>
<a name="ln2147">#endif</a>
<a name="ln2148">	if (sc-&gt;cfg-&gt;device_family != IWM_DEVICE_FAMILY_8000) {</a>
<a name="ln2149">		const uint8_t *hw_addr = (const uint8_t *)(nvm_hw + IWM_HW_ADDR);</a>
<a name="ln2150"> </a>
<a name="ln2151">		/* The byte order is little endian 16 bit, meaning 214365 */</a>
<a name="ln2152">		data-&gt;hw_addr[0] = hw_addr[1];</a>
<a name="ln2153">		data-&gt;hw_addr[1] = hw_addr[0];</a>
<a name="ln2154">		data-&gt;hw_addr[2] = hw_addr[3];</a>
<a name="ln2155">		data-&gt;hw_addr[3] = hw_addr[2];</a>
<a name="ln2156">		data-&gt;hw_addr[4] = hw_addr[5];</a>
<a name="ln2157">		data-&gt;hw_addr[5] = hw_addr[4];</a>
<a name="ln2158">	} else {</a>
<a name="ln2159">		iwm_set_hw_address_family_8000(sc, data, mac_override, nvm_hw);</a>
<a name="ln2160">	}</a>
<a name="ln2161"> </a>
<a name="ln2162">	if (!iwm_is_valid_ether_addr(data-&gt;hw_addr)) {</a>
<a name="ln2163">		device_printf(sc-&gt;sc_dev, &quot;no valid mac address was found\n&quot;);</a>
<a name="ln2164">		return EINVAL;</a>
<a name="ln2165">	}</a>
<a name="ln2166"> </a>
<a name="ln2167">	return 0;</a>
<a name="ln2168">}</a>
<a name="ln2169"> </a>
<a name="ln2170">static struct iwm_nvm_data *</a>
<a name="ln2171">iwm_parse_nvm_data(struct iwm_softc *sc,</a>
<a name="ln2172">		   const uint16_t *nvm_hw, const uint16_t *nvm_sw,</a>
<a name="ln2173">		   const uint16_t *nvm_calib, const uint16_t *mac_override,</a>
<a name="ln2174">		   const uint16_t *phy_sku, const uint16_t *regulatory)</a>
<a name="ln2175">{</a>
<a name="ln2176">	struct iwm_nvm_data *data;</a>
<a name="ln2177">	uint32_t sku, radio_cfg;</a>
<a name="ln2178">	uint16_t lar_config;</a>
<a name="ln2179"> </a>
<a name="ln2180">	if (sc-&gt;cfg-&gt;device_family != IWM_DEVICE_FAMILY_8000) {</a>
<a name="ln2181">		data = malloc(sizeof(*data) +</a>
<a name="ln2182">		    IWM_NUM_CHANNELS * sizeof(uint16_t),</a>
<a name="ln2183">		    M_DEVBUF, M_NOWAIT | M_ZERO);</a>
<a name="ln2184">	} else {</a>
<a name="ln2185">		data = malloc(sizeof(*data) +</a>
<a name="ln2186">		    IWM_NUM_CHANNELS_8000 * sizeof(uint16_t),</a>
<a name="ln2187">		    M_DEVBUF, M_NOWAIT | M_ZERO);</a>
<a name="ln2188">	}</a>
<a name="ln2189">	if (!data)</a>
<a name="ln2190">		return NULL;</a>
<a name="ln2191"> </a>
<a name="ln2192">	data-&gt;nvm_version = iwm_get_nvm_version(sc, nvm_sw);</a>
<a name="ln2193"> </a>
<a name="ln2194">	radio_cfg = iwm_get_radio_cfg(sc, nvm_sw, phy_sku);</a>
<a name="ln2195">	iwm_set_radio_cfg(sc, data, radio_cfg);</a>
<a name="ln2196"> </a>
<a name="ln2197">	sku = iwm_get_sku(sc, nvm_sw, phy_sku);</a>
<a name="ln2198">	data-&gt;sku_cap_band_24GHz_enable = sku &amp; IWM_NVM_SKU_CAP_BAND_24GHZ;</a>
<a name="ln2199">	data-&gt;sku_cap_band_52GHz_enable = sku &amp; IWM_NVM_SKU_CAP_BAND_52GHZ;</a>
<a name="ln2200">	data-&gt;sku_cap_11n_enable = 0;</a>
<a name="ln2201"> </a>
<a name="ln2202">	data-&gt;n_hw_addrs = iwm_get_n_hw_addrs(sc, nvm_sw);</a>
<a name="ln2203"> </a>
<a name="ln2204">	if (sc-&gt;cfg-&gt;device_family == IWM_DEVICE_FAMILY_8000) {</a>
<a name="ln2205">		uint16_t lar_offset = data-&gt;nvm_version &lt; 0xE39 ?</a>
<a name="ln2206">				       IWM_NVM_LAR_OFFSET_8000_OLD :</a>
<a name="ln2207">				       IWM_NVM_LAR_OFFSET_8000;</a>
<a name="ln2208"> </a>
<a name="ln2209">		lar_config = le16_to_cpup(regulatory + lar_offset);</a>
<a name="ln2210">		data-&gt;lar_enabled = !!(lar_config &amp;</a>
<a name="ln2211">				       IWM_NVM_LAR_ENABLED_8000);</a>
<a name="ln2212">	}</a>
<a name="ln2213"> </a>
<a name="ln2214">	/* If no valid mac address was found - bail out */</a>
<a name="ln2215">	if (iwm_set_hw_address(sc, data, nvm_hw, mac_override)) {</a>
<a name="ln2216">		free(data, M_DEVBUF);</a>
<a name="ln2217">		return NULL;</a>
<a name="ln2218">	}</a>
<a name="ln2219"> </a>
<a name="ln2220">	if (sc-&gt;cfg-&gt;device_family == IWM_DEVICE_FAMILY_7000) {</a>
<a name="ln2221">		memcpy(data-&gt;nvm_ch_flags, &amp;nvm_sw[IWM_NVM_CHANNELS],</a>
<a name="ln2222">		    IWM_NUM_CHANNELS * sizeof(uint16_t));</a>
<a name="ln2223">	} else {</a>
<a name="ln2224">		memcpy(data-&gt;nvm_ch_flags, &amp;regulatory[IWM_NVM_CHANNELS_8000],</a>
<a name="ln2225">		    IWM_NUM_CHANNELS_8000 * sizeof(uint16_t));</a>
<a name="ln2226">	}</a>
<a name="ln2227"> </a>
<a name="ln2228">	return data;</a>
<a name="ln2229">}</a>
<a name="ln2230"> </a>
<a name="ln2231">static void</a>
<a name="ln2232">iwm_free_nvm_data(struct iwm_nvm_data *data)</a>
<a name="ln2233">{</a>
<a name="ln2234">	if (data != NULL)</a>
<a name="ln2235">		free(data, M_DEVBUF);</a>
<a name="ln2236">}</a>
<a name="ln2237"> </a>
<a name="ln2238">static struct iwm_nvm_data *</a>
<a name="ln2239">iwm_parse_nvm_sections(struct iwm_softc *sc, struct iwm_nvm_section *sections)</a>
<a name="ln2240">{</a>
<a name="ln2241">	const uint16_t *hw, *sw, *calib, *regulatory, *mac_override, *phy_sku;</a>
<a name="ln2242"> </a>
<a name="ln2243">	/* Checking for required sections */</a>
<a name="ln2244">	if (sc-&gt;cfg-&gt;device_family == IWM_DEVICE_FAMILY_7000) {</a>
<a name="ln2245">		if (!sections[IWM_NVM_SECTION_TYPE_SW].data ||</a>
<a name="ln2246">		    !sections[sc-&gt;cfg-&gt;nvm_hw_section_num].data) {</a>
<a name="ln2247">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln2248">			    &quot;Can't parse empty OTP/NVM sections\n&quot;);</a>
<a name="ln2249">			return NULL;</a>
<a name="ln2250">		}</a>
<a name="ln2251">	} else if (sc-&gt;cfg-&gt;device_family == IWM_DEVICE_FAMILY_8000) {</a>
<a name="ln2252">		/* SW and REGULATORY sections are mandatory */</a>
<a name="ln2253">		if (!sections[IWM_NVM_SECTION_TYPE_SW].data ||</a>
<a name="ln2254">		    !sections[IWM_NVM_SECTION_TYPE_REGULATORY].data) {</a>
<a name="ln2255">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln2256">			    &quot;Can't parse empty OTP/NVM sections\n&quot;);</a>
<a name="ln2257">			return NULL;</a>
<a name="ln2258">		}</a>
<a name="ln2259">		/* MAC_OVERRIDE or at least HW section must exist */</a>
<a name="ln2260">		if (!sections[sc-&gt;cfg-&gt;nvm_hw_section_num].data &amp;&amp;</a>
<a name="ln2261">		    !sections[IWM_NVM_SECTION_TYPE_MAC_OVERRIDE].data) {</a>
<a name="ln2262">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln2263">			    &quot;Can't parse mac_address, empty sections\n&quot;);</a>
<a name="ln2264">			return NULL;</a>
<a name="ln2265">		}</a>
<a name="ln2266"> </a>
<a name="ln2267">		/* PHY_SKU section is mandatory in B0 */</a>
<a name="ln2268">		if (!sections[IWM_NVM_SECTION_TYPE_PHY_SKU].data) {</a>
<a name="ln2269">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln2270">			    &quot;Can't parse phy_sku in B0, empty sections\n&quot;);</a>
<a name="ln2271">			return NULL;</a>
<a name="ln2272">		}</a>
<a name="ln2273">	} else {</a>
<a name="ln2274">		panic(&quot;unknown device family %d\n&quot;, sc-&gt;cfg-&gt;device_family);</a>
<a name="ln2275">	}</a>
<a name="ln2276"> </a>
<a name="ln2277">	hw = (const uint16_t *) sections[sc-&gt;cfg-&gt;nvm_hw_section_num].data;</a>
<a name="ln2278">	sw = (const uint16_t *)sections[IWM_NVM_SECTION_TYPE_SW].data;</a>
<a name="ln2279">	calib = (const uint16_t *)</a>
<a name="ln2280">	    sections[IWM_NVM_SECTION_TYPE_CALIBRATION].data;</a>
<a name="ln2281">	regulatory = (const uint16_t *)</a>
<a name="ln2282">	    sections[IWM_NVM_SECTION_TYPE_REGULATORY].data;</a>
<a name="ln2283">	mac_override = (const uint16_t *)</a>
<a name="ln2284">	    sections[IWM_NVM_SECTION_TYPE_MAC_OVERRIDE].data;</a>
<a name="ln2285">	phy_sku = (const uint16_t *)sections[IWM_NVM_SECTION_TYPE_PHY_SKU].data;</a>
<a name="ln2286"> </a>
<a name="ln2287">	return iwm_parse_nvm_data(sc, hw, sw, calib, mac_override,</a>
<a name="ln2288">	    phy_sku, regulatory);</a>
<a name="ln2289">}</a>
<a name="ln2290"> </a>
<a name="ln2291">static int</a>
<a name="ln2292">iwm_nvm_init(struct iwm_softc *sc)</a>
<a name="ln2293">{</a>
<a name="ln2294">	struct iwm_nvm_section nvm_sections[IWM_NVM_MAX_NUM_SECTIONS];</a>
<a name="ln2295">	int i, ret, section;</a>
<a name="ln2296">	uint32_t size_read = 0;</a>
<a name="ln2297">	uint8_t *nvm_buffer, *temp;</a>
<a name="ln2298">	uint16_t len;</a>
<a name="ln2299"> </a>
<a name="ln2300">	memset(nvm_sections, 0, sizeof(nvm_sections));</a>
<a name="ln2301"> </a>
<a name="ln2302">	if (sc-&gt;cfg-&gt;nvm_hw_section_num &gt;= IWM_NVM_MAX_NUM_SECTIONS)</a>
<a name="ln2303">		return EINVAL;</a>
<a name="ln2304"> </a>
<a name="ln2305">	/* load NVM values from nic */</a>
<a name="ln2306">	/* Read From FW NVM */</a>
<a name="ln2307">	IWM_DPRINTF(sc, IWM_DEBUG_EEPROM, &quot;Read from NVM\n&quot;);</a>
<a name="ln2308"> </a>
<a name="ln2309">	nvm_buffer = malloc(sc-&gt;cfg-&gt;eeprom_size, M_DEVBUF, M_NOWAIT | M_ZERO);</a>
<a name="ln2310">	if (!nvm_buffer)</a>
<a name="ln2311">		return ENOMEM;</a>
<a name="ln2312">	for (section = 0; section &lt; IWM_NVM_MAX_NUM_SECTIONS; section++) {</a>
<a name="ln2313">		/* we override the constness for initial read */</a>
<a name="ln2314">		ret = iwm_nvm_read_section(sc, section, nvm_buffer,</a>
<a name="ln2315">					   &amp;len, size_read);</a>
<a name="ln2316">		if (ret)</a>
<a name="ln2317">			continue;</a>
<a name="ln2318">		size_read += len;</a>
<a name="ln2319">		temp = malloc(len, M_DEVBUF, M_NOWAIT);</a>
<a name="ln2320">		if (!temp) {</a>
<a name="ln2321">			ret = ENOMEM;</a>
<a name="ln2322">			break;</a>
<a name="ln2323">		}</a>
<a name="ln2324">		memcpy(temp, nvm_buffer, len);</a>
<a name="ln2325"> </a>
<a name="ln2326">		nvm_sections[section].data = temp;</a>
<a name="ln2327">		nvm_sections[section].length = len;</a>
<a name="ln2328">	}</a>
<a name="ln2329">	if (!size_read)</a>
<a name="ln2330">		device_printf(sc-&gt;sc_dev, &quot;OTP is blank\n&quot;);</a>
<a name="ln2331">	free(nvm_buffer, M_DEVBUF);</a>
<a name="ln2332"> </a>
<a name="ln2333">	sc-&gt;nvm_data = iwm_parse_nvm_sections(sc, nvm_sections);</a>
<a name="ln2334">	if (!sc-&gt;nvm_data)</a>
<a name="ln2335">		return EINVAL;</a>
<a name="ln2336">	IWM_DPRINTF(sc, IWM_DEBUG_EEPROM | IWM_DEBUG_RESET,</a>
<a name="ln2337">		    &quot;nvm version = %x\n&quot;, sc-&gt;nvm_data-&gt;nvm_version);</a>
<a name="ln2338"> </a>
<a name="ln2339">	for (i = 0; i &lt; IWM_NVM_MAX_NUM_SECTIONS; i++) {</a>
<a name="ln2340">		if (nvm_sections[i].data != NULL)</a>
<a name="ln2341">			free(nvm_sections[i].data, M_DEVBUF);</a>
<a name="ln2342">	}</a>
<a name="ln2343"> </a>
<a name="ln2344">	return 0;</a>
<a name="ln2345">}</a>
<a name="ln2346"> </a>
<a name="ln2347">static int</a>
<a name="ln2348">iwm_pcie_load_section(struct iwm_softc *sc, uint8_t section_num,</a>
<a name="ln2349">	const struct iwm_fw_desc *section)</a>
<a name="ln2350">{</a>
<a name="ln2351">	struct iwm_dma_info *dma = &amp;sc-&gt;fw_dma;</a>
<a name="ln2352">	uint8_t *v_addr;</a>
<a name="ln2353">	bus_addr_t p_addr;</a>
<a name="ln2354">	uint32_t offset, chunk_sz = MIN(IWM_FH_MEM_TB_MAX_LENGTH, section-&gt;len);</a>
<a name="ln2355">	int ret = 0;</a>
<a name="ln2356"> </a>
<a name="ln2357">	IWM_DPRINTF(sc, IWM_DEBUG_RESET,</a>
<a name="ln2358">		    &quot;%s: [%d] uCode section being loaded...\n&quot;,</a>
<a name="ln2359">		    __func__, section_num);</a>
<a name="ln2360"> </a>
<a name="ln2361">	v_addr = dma-&gt;vaddr;</a>
<a name="ln2362">	p_addr = dma-&gt;paddr;</a>
<a name="ln2363"> </a>
<a name="ln2364">	for (offset = 0; offset &lt; section-&gt;len; offset += chunk_sz) {</a>
<a name="ln2365">		uint32_t copy_size, dst_addr;</a>
<a name="ln2366">		int extended_addr = FALSE;</a>
<a name="ln2367"> </a>
<a name="ln2368">		copy_size = MIN(chunk_sz, section-&gt;len - offset);</a>
<a name="ln2369">		dst_addr = section-&gt;offset + offset;</a>
<a name="ln2370"> </a>
<a name="ln2371">		if (dst_addr &gt;= IWM_FW_MEM_EXTENDED_START &amp;&amp;</a>
<a name="ln2372">		    dst_addr &lt;= IWM_FW_MEM_EXTENDED_END)</a>
<a name="ln2373">			extended_addr = TRUE;</a>
<a name="ln2374"> </a>
<a name="ln2375">		if (extended_addr)</a>
<a name="ln2376">			iwm_set_bits_prph(sc, IWM_LMPM_CHICK,</a>
<a name="ln2377">					  IWM_LMPM_CHICK_EXTENDED_ADDR_SPACE);</a>
<a name="ln2378"> </a>
<a name="ln2379">		memcpy(v_addr, (const uint8_t *)section-&gt;data + offset,</a>
<a name="ln2380">		    copy_size);</a>
<a name="ln2381">		bus_dmamap_sync(dma-&gt;tag, dma-&gt;map, BUS_DMASYNC_PREWRITE);</a>
<a name="ln2382">		ret = iwm_pcie_load_firmware_chunk(sc, dst_addr, p_addr,</a>
<a name="ln2383">						   copy_size);</a>
<a name="ln2384"> </a>
<a name="ln2385">		if (extended_addr)</a>
<a name="ln2386">			iwm_clear_bits_prph(sc, IWM_LMPM_CHICK,</a>
<a name="ln2387">					    IWM_LMPM_CHICK_EXTENDED_ADDR_SPACE);</a>
<a name="ln2388"> </a>
<a name="ln2389">		if (ret) {</a>
<a name="ln2390">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln2391">			    &quot;%s: Could not load the [%d] uCode section\n&quot;,</a>
<a name="ln2392">			    __func__, section_num);</a>
<a name="ln2393">			break;</a>
<a name="ln2394">		}</a>
<a name="ln2395">	}</a>
<a name="ln2396"> </a>
<a name="ln2397">	return ret;</a>
<a name="ln2398">}</a>
<a name="ln2399"> </a>
<a name="ln2400">/*</a>
<a name="ln2401"> * ucode</a>
<a name="ln2402"> */</a>
<a name="ln2403">static int</a>
<a name="ln2404">iwm_pcie_load_firmware_chunk(struct iwm_softc *sc, uint32_t dst_addr,</a>
<a name="ln2405">			     bus_addr_t phy_addr, uint32_t byte_cnt)</a>
<a name="ln2406">{</a>
<a name="ln2407">	sc-&gt;sc_fw_chunk_done = 0;</a>
<a name="ln2408"> </a>
<a name="ln2409">	if (!iwm_nic_lock(sc))</a>
<a name="ln2410">		return EBUSY;</a>
<a name="ln2411"> </a>
<a name="ln2412">	IWM_WRITE(sc, IWM_FH_TCSR_CHNL_TX_CONFIG_REG(IWM_FH_SRVC_CHNL),</a>
<a name="ln2413">	    IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_PAUSE);</a>
<a name="ln2414"> </a>
<a name="ln2415">	IWM_WRITE(sc, IWM_FH_SRVC_CHNL_SRAM_ADDR_REG(IWM_FH_SRVC_CHNL),</a>
<a name="ln2416">	    dst_addr);</a>
<a name="ln2417"> </a>
<a name="ln2418">	IWM_WRITE(sc, IWM_FH_TFDIB_CTRL0_REG(IWM_FH_SRVC_CHNL),</a>
<a name="ln2419">	    phy_addr &amp; IWM_FH_MEM_TFDIB_DRAM_ADDR_LSB_MSK);</a>
<a name="ln2420"> </a>
<a name="ln2421">	IWM_WRITE(sc, IWM_FH_TFDIB_CTRL1_REG(IWM_FH_SRVC_CHNL),</a>
<a name="ln2422">	    (iwm_get_dma_hi_addr(phy_addr)</a>
<a name="ln2423">	     &lt;&lt; IWM_FH_MEM_TFDIB_REG1_ADDR_BITSHIFT) | byte_cnt);</a>
<a name="ln2424"> </a>
<a name="ln2425">	IWM_WRITE(sc, IWM_FH_TCSR_CHNL_TX_BUF_STS_REG(IWM_FH_SRVC_CHNL),</a>
<a name="ln2426">	    1 &lt;&lt; IWM_FH_TCSR_CHNL_TX_BUF_STS_REG_POS_TB_NUM |</a>
<a name="ln2427">	    1 &lt;&lt; IWM_FH_TCSR_CHNL_TX_BUF_STS_REG_POS_TB_IDX |</a>
<a name="ln2428">	    IWM_FH_TCSR_CHNL_TX_BUF_STS_REG_VAL_TFDB_VALID);</a>
<a name="ln2429"> </a>
<a name="ln2430">	IWM_WRITE(sc, IWM_FH_TCSR_CHNL_TX_CONFIG_REG(IWM_FH_SRVC_CHNL),</a>
<a name="ln2431">	    IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CHNL_ENABLE    |</a>
<a name="ln2432">	    IWM_FH_TCSR_TX_CONFIG_REG_VAL_DMA_CREDIT_DISABLE |</a>
<a name="ln2433">	    IWM_FH_TCSR_TX_CONFIG_REG_VAL_CIRQ_HOST_ENDTFD);</a>
<a name="ln2434"> </a>
<a name="ln2435">	iwm_nic_unlock(sc);</a>
<a name="ln2436"> </a>
<a name="ln2437">	/* wait up to 5s for this segment to load */</a>
<a name="ln2438">	msleep(&amp;sc-&gt;sc_fw, &amp;sc-&gt;sc_mtx, 0, &quot;iwmfw&quot;, hz * 5);</a>
<a name="ln2439"> </a>
<a name="ln2440">	if (!sc-&gt;sc_fw_chunk_done) {</a>
<a name="ln2441">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln2442">		    &quot;fw chunk addr 0x%x len %d failed to load\n&quot;,</a>
<a name="ln2443">		    dst_addr, byte_cnt);</a>
<a name="ln2444">		return ETIMEDOUT;</a>
<a name="ln2445">	}</a>
<a name="ln2446"> </a>
<a name="ln2447">	return 0;</a>
<a name="ln2448">}</a>
<a name="ln2449"> </a>
<a name="ln2450">static int</a>
<a name="ln2451">iwm_pcie_load_cpu_sections_8000(struct iwm_softc *sc,</a>
<a name="ln2452">	const struct iwm_fw_img *image, int cpu, int *first_ucode_section)</a>
<a name="ln2453">{</a>
<a name="ln2454">	int shift_param;</a>
<a name="ln2455">	int i, ret = 0, sec_num = 0x1;</a>
<a name="ln2456">	uint32_t val, last_read_idx = 0;</a>
<a name="ln2457"> </a>
<a name="ln2458">	if (cpu == 1) {</a>
<a name="ln2459">		shift_param = 0;</a>
<a name="ln2460">		*first_ucode_section = 0;</a>
<a name="ln2461">	} else {</a>
<a name="ln2462">		shift_param = 16;</a>
<a name="ln2463">		(*first_ucode_section)++;</a>
<a name="ln2464">	}</a>
<a name="ln2465"> </a>
<a name="ln2466">	for (i = *first_ucode_section; i &lt; IWM_UCODE_SECTION_MAX; i++) {</a>
<a name="ln2467">		last_read_idx = i;</a>
<a name="ln2468"> </a>
<a name="ln2469">		/*</a>
<a name="ln2470">		 * CPU1_CPU2_SEPARATOR_SECTION delimiter - separate between</a>
<a name="ln2471">		 * CPU1 to CPU2.</a>
<a name="ln2472">		 * PAGING_SEPARATOR_SECTION delimiter - separate between</a>
<a name="ln2473">		 * CPU2 non paged to CPU2 paging sec.</a>
<a name="ln2474">		 */</a>
<a name="ln2475">		if (!image-&gt;sec[i].data ||</a>
<a name="ln2476">		    image-&gt;sec[i].offset == IWM_CPU1_CPU2_SEPARATOR_SECTION ||</a>
<a name="ln2477">		    image-&gt;sec[i].offset == IWM_PAGING_SEPARATOR_SECTION) {</a>
<a name="ln2478">			IWM_DPRINTF(sc, IWM_DEBUG_RESET,</a>
<a name="ln2479">				    &quot;Break since Data not valid or Empty section, sec = %d\n&quot;,</a>
<a name="ln2480">				    i);</a>
<a name="ln2481">			break;</a>
<a name="ln2482">		}</a>
<a name="ln2483">		ret = iwm_pcie_load_section(sc, i, &amp;image-&gt;sec[i]);</a>
<a name="ln2484">		if (ret)</a>
<a name="ln2485">			return ret;</a>
<a name="ln2486"> </a>
<a name="ln2487">		/* Notify the ucode of the loaded section number and status */</a>
<a name="ln2488">		if (iwm_nic_lock(sc)) {</a>
<a name="ln2489">			val = IWM_READ(sc, IWM_FH_UCODE_LOAD_STATUS);</a>
<a name="ln2490">			val = val | (sec_num &lt;&lt; shift_param);</a>
<a name="ln2491">			IWM_WRITE(sc, IWM_FH_UCODE_LOAD_STATUS, val);</a>
<a name="ln2492">			sec_num = (sec_num &lt;&lt; 1) | 0x1;</a>
<a name="ln2493">			iwm_nic_unlock(sc);</a>
<a name="ln2494">		}</a>
<a name="ln2495">	}</a>
<a name="ln2496"> </a>
<a name="ln2497">	*first_ucode_section = last_read_idx;</a>
<a name="ln2498"> </a>
<a name="ln2499">	iwm_enable_interrupts(sc);</a>
<a name="ln2500"> </a>
<a name="ln2501">	if (iwm_nic_lock(sc)) {</a>
<a name="ln2502">		if (cpu == 1)</a>
<a name="ln2503">			IWM_WRITE(sc, IWM_FH_UCODE_LOAD_STATUS, 0xFFFF);</a>
<a name="ln2504">		else</a>
<a name="ln2505">			IWM_WRITE(sc, IWM_FH_UCODE_LOAD_STATUS, 0xFFFFFFFF);</a>
<a name="ln2506">		iwm_nic_unlock(sc);</a>
<a name="ln2507">	}</a>
<a name="ln2508"> </a>
<a name="ln2509">	return 0;</a>
<a name="ln2510">}</a>
<a name="ln2511"> </a>
<a name="ln2512">static int</a>
<a name="ln2513">iwm_pcie_load_cpu_sections(struct iwm_softc *sc,</a>
<a name="ln2514">	const struct iwm_fw_img *image, int cpu, int *first_ucode_section)</a>
<a name="ln2515">{</a>
<a name="ln2516">	int shift_param;</a>
<a name="ln2517">	int i, ret = 0;</a>
<a name="ln2518">	uint32_t last_read_idx = 0;</a>
<a name="ln2519"> </a>
<a name="ln2520">	if (cpu == 1) {</a>
<a name="ln2521">		shift_param = 0;</a>
<a name="ln2522">		*first_ucode_section = 0;</a>
<a name="ln2523">	} else {</a>
<a name="ln2524">		shift_param = 16;</a>
<a name="ln2525">		(*first_ucode_section)++;</a>
<a name="ln2526">	}</a>
<a name="ln2527"> </a>
<a name="ln2528">	for (i = *first_ucode_section; i &lt; IWM_UCODE_SECTION_MAX; i++) {</a>
<a name="ln2529">		last_read_idx = i;</a>
<a name="ln2530"> </a>
<a name="ln2531">		/*</a>
<a name="ln2532">		 * CPU1_CPU2_SEPARATOR_SECTION delimiter - separate between</a>
<a name="ln2533">		 * CPU1 to CPU2.</a>
<a name="ln2534">		 * PAGING_SEPARATOR_SECTION delimiter - separate between</a>
<a name="ln2535">		 * CPU2 non paged to CPU2 paging sec.</a>
<a name="ln2536">		 */</a>
<a name="ln2537">		if (!image-&gt;sec[i].data ||</a>
<a name="ln2538">		    image-&gt;sec[i].offset == IWM_CPU1_CPU2_SEPARATOR_SECTION ||</a>
<a name="ln2539">		    image-&gt;sec[i].offset == IWM_PAGING_SEPARATOR_SECTION) {</a>
<a name="ln2540">			IWM_DPRINTF(sc, IWM_DEBUG_RESET,</a>
<a name="ln2541">				    &quot;Break since Data not valid or Empty section, sec = %d\n&quot;,</a>
<a name="ln2542">				     i);</a>
<a name="ln2543">			break;</a>
<a name="ln2544">		}</a>
<a name="ln2545"> </a>
<a name="ln2546">		ret = iwm_pcie_load_section(sc, i, &amp;image-&gt;sec[i]);</a>
<a name="ln2547">		if (ret)</a>
<a name="ln2548">			return ret;</a>
<a name="ln2549">	}</a>
<a name="ln2550"> </a>
<a name="ln2551">	*first_ucode_section = last_read_idx;</a>
<a name="ln2552"> </a>
<a name="ln2553">	return 0;</a>
<a name="ln2554"> </a>
<a name="ln2555">}</a>
<a name="ln2556"> </a>
<a name="ln2557">static int</a>
<a name="ln2558">iwm_pcie_load_given_ucode(struct iwm_softc *sc, const struct iwm_fw_img *image)</a>
<a name="ln2559">{</a>
<a name="ln2560">	int ret = 0;</a>
<a name="ln2561">	int first_ucode_section;</a>
<a name="ln2562"> </a>
<a name="ln2563">	IWM_DPRINTF(sc, IWM_DEBUG_RESET, &quot;working with %s CPU\n&quot;,</a>
<a name="ln2564">		     image-&gt;is_dual_cpus ? &quot;Dual&quot; : &quot;Single&quot;);</a>
<a name="ln2565"> </a>
<a name="ln2566">	/* load to FW the binary non secured sections of CPU1 */</a>
<a name="ln2567">	ret = iwm_pcie_load_cpu_sections(sc, image, 1, &amp;first_ucode_section);</a>
<a name="ln2568">	if (ret)</a>
<a name="ln2569">		return ret;</a>
<a name="ln2570"> </a>
<a name="ln2571">	if (image-&gt;is_dual_cpus) {</a>
<a name="ln2572">		/* set CPU2 header address */</a>
<a name="ln2573">		if (iwm_nic_lock(sc)) {</a>
<a name="ln2574">			iwm_write_prph(sc,</a>
<a name="ln2575">				       IWM_LMPM_SECURE_UCODE_LOAD_CPU2_HDR_ADDR,</a>
<a name="ln2576">				       IWM_LMPM_SECURE_CPU2_HDR_MEM_SPACE);</a>
<a name="ln2577">			iwm_nic_unlock(sc);</a>
<a name="ln2578">		}</a>
<a name="ln2579"> </a>
<a name="ln2580">		/* load to FW the binary sections of CPU2 */</a>
<a name="ln2581">		ret = iwm_pcie_load_cpu_sections(sc, image, 2,</a>
<a name="ln2582">						 &amp;first_ucode_section);</a>
<a name="ln2583">		if (ret)</a>
<a name="ln2584">			return ret;</a>
<a name="ln2585">	}</a>
<a name="ln2586"> </a>
<a name="ln2587">	iwm_enable_interrupts(sc);</a>
<a name="ln2588"> </a>
<a name="ln2589">	/* release CPU reset */</a>
<a name="ln2590">	IWM_WRITE(sc, IWM_CSR_RESET, 0);</a>
<a name="ln2591"> </a>
<a name="ln2592">	return 0;</a>
<a name="ln2593">}</a>
<a name="ln2594"> </a>
<a name="ln2595">int</a>
<a name="ln2596">iwm_pcie_load_given_ucode_8000(struct iwm_softc *sc,</a>
<a name="ln2597">	const struct iwm_fw_img *image)</a>
<a name="ln2598">{</a>
<a name="ln2599">	int ret = 0;</a>
<a name="ln2600">	int first_ucode_section;</a>
<a name="ln2601"> </a>
<a name="ln2602">	IWM_DPRINTF(sc, IWM_DEBUG_RESET, &quot;working with %s CPU\n&quot;,</a>
<a name="ln2603">		    image-&gt;is_dual_cpus ? &quot;Dual&quot; : &quot;Single&quot;);</a>
<a name="ln2604"> </a>
<a name="ln2605">	/* configure the ucode to be ready to get the secured image */</a>
<a name="ln2606">	/* release CPU reset */</a>
<a name="ln2607">	if (iwm_nic_lock(sc)) {</a>
<a name="ln2608">		iwm_write_prph(sc, IWM_RELEASE_CPU_RESET,</a>
<a name="ln2609">		    IWM_RELEASE_CPU_RESET_BIT);</a>
<a name="ln2610">		iwm_nic_unlock(sc);</a>
<a name="ln2611">	}</a>
<a name="ln2612"> </a>
<a name="ln2613">	/* load to FW the binary Secured sections of CPU1 */</a>
<a name="ln2614">	ret = iwm_pcie_load_cpu_sections_8000(sc, image, 1,</a>
<a name="ln2615">	    &amp;first_ucode_section);</a>
<a name="ln2616">	if (ret)</a>
<a name="ln2617">		return ret;</a>
<a name="ln2618"> </a>
<a name="ln2619">	/* load to FW the binary sections of CPU2 */</a>
<a name="ln2620">	return iwm_pcie_load_cpu_sections_8000(sc, image, 2,</a>
<a name="ln2621">	    &amp;first_ucode_section);</a>
<a name="ln2622">}</a>
<a name="ln2623"> </a>
<a name="ln2624">/* XXX Get rid of this definition */</a>
<a name="ln2625">static inline void</a>
<a name="ln2626">iwm_enable_fw_load_int(struct iwm_softc *sc)</a>
<a name="ln2627">{</a>
<a name="ln2628">	IWM_DPRINTF(sc, IWM_DEBUG_INTR, &quot;Enabling FW load interrupt\n&quot;);</a>
<a name="ln2629">	sc-&gt;sc_intmask = IWM_CSR_INT_BIT_FH_TX;</a>
<a name="ln2630">	IWM_WRITE(sc, IWM_CSR_INT_MASK, sc-&gt;sc_intmask);</a>
<a name="ln2631">}</a>
<a name="ln2632"> </a>
<a name="ln2633">/* XXX Add proper rfkill support code */</a>
<a name="ln2634">static int</a>
<a name="ln2635">iwm_start_fw(struct iwm_softc *sc, const struct iwm_fw_img *fw)</a>
<a name="ln2636">{</a>
<a name="ln2637">	int ret;</a>
<a name="ln2638"> </a>
<a name="ln2639">	/* This may fail if AMT took ownership of the device */</a>
<a name="ln2640">	if (iwm_prepare_card_hw(sc)) {</a>
<a name="ln2641">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln2642">		    &quot;%s: Exit HW not ready\n&quot;, __func__);</a>
<a name="ln2643">		ret = EIO;</a>
<a name="ln2644">		goto out;</a>
<a name="ln2645">	}</a>
<a name="ln2646"> </a>
<a name="ln2647">	IWM_WRITE(sc, IWM_CSR_INT, 0xFFFFFFFF);</a>
<a name="ln2648"> </a>
<a name="ln2649">	iwm_disable_interrupts(sc);</a>
<a name="ln2650"> </a>
<a name="ln2651">	/* make sure rfkill handshake bits are cleared */</a>
<a name="ln2652">	IWM_WRITE(sc, IWM_CSR_UCODE_DRV_GP1_CLR, IWM_CSR_UCODE_SW_BIT_RFKILL);</a>
<a name="ln2653">	IWM_WRITE(sc, IWM_CSR_UCODE_DRV_GP1_CLR,</a>
<a name="ln2654">	    IWM_CSR_UCODE_DRV_GP1_BIT_CMD_BLOCKED);</a>
<a name="ln2655"> </a>
<a name="ln2656">	/* clear (again), then enable host interrupts */</a>
<a name="ln2657">	IWM_WRITE(sc, IWM_CSR_INT, 0xFFFFFFFF);</a>
<a name="ln2658"> </a>
<a name="ln2659">	ret = iwm_nic_init(sc);</a>
<a name="ln2660">	if (ret) {</a>
<a name="ln2661">		device_printf(sc-&gt;sc_dev, &quot;%s: Unable to init nic\n&quot;, __func__);</a>
<a name="ln2662">		goto out;</a>
<a name="ln2663">	}</a>
<a name="ln2664"> </a>
<a name="ln2665">	/*</a>
<a name="ln2666">	 * Now, we load the firmware and don't want to be interrupted, even</a>
<a name="ln2667">	 * by the RF-Kill interrupt (hence mask all the interrupt besides the</a>
<a name="ln2668">	 * FH_TX interrupt which is needed to load the firmware). If the</a>
<a name="ln2669">	 * RF-Kill switch is toggled, we will find out after having loaded</a>
<a name="ln2670">	 * the firmware and return the proper value to the caller.</a>
<a name="ln2671">	 */</a>
<a name="ln2672">	iwm_enable_fw_load_int(sc);</a>
<a name="ln2673"> </a>
<a name="ln2674">	/* really make sure rfkill handshake bits are cleared */</a>
<a name="ln2675">	/* maybe we should write a few times more?  just to make sure */</a>
<a name="ln2676">	IWM_WRITE(sc, IWM_CSR_UCODE_DRV_GP1_CLR, IWM_CSR_UCODE_SW_BIT_RFKILL);</a>
<a name="ln2677">	IWM_WRITE(sc, IWM_CSR_UCODE_DRV_GP1_CLR, IWM_CSR_UCODE_SW_BIT_RFKILL);</a>
<a name="ln2678"> </a>
<a name="ln2679">	/* Load the given image to the HW */</a>
<a name="ln2680">	if (sc-&gt;cfg-&gt;device_family == IWM_DEVICE_FAMILY_8000)</a>
<a name="ln2681">		ret = iwm_pcie_load_given_ucode_8000(sc, fw);</a>
<a name="ln2682">	else</a>
<a name="ln2683">		ret = iwm_pcie_load_given_ucode(sc, fw);</a>
<a name="ln2684"> </a>
<a name="ln2685">	/* XXX re-check RF-Kill state */</a>
<a name="ln2686"> </a>
<a name="ln2687">out:</a>
<a name="ln2688">	return ret;</a>
<a name="ln2689">}</a>
<a name="ln2690"> </a>
<a name="ln2691">static int</a>
<a name="ln2692">iwm_send_tx_ant_cfg(struct iwm_softc *sc, uint8_t valid_tx_ant)</a>
<a name="ln2693">{</a>
<a name="ln2694">	struct iwm_tx_ant_cfg_cmd tx_ant_cmd = {</a>
<a name="ln2695">		.valid = htole32(valid_tx_ant),</a>
<a name="ln2696">	};</a>
<a name="ln2697"> </a>
<a name="ln2698">	return iwm_mvm_send_cmd_pdu(sc, IWM_TX_ANT_CONFIGURATION_CMD,</a>
<a name="ln2699">	    IWM_CMD_SYNC, sizeof(tx_ant_cmd), &amp;tx_ant_cmd);</a>
<a name="ln2700">}</a>
<a name="ln2701"> </a>
<a name="ln2702">/* iwlwifi: mvm/fw.c */</a>
<a name="ln2703">static int</a>
<a name="ln2704">iwm_send_phy_cfg_cmd(struct iwm_softc *sc)</a>
<a name="ln2705">{</a>
<a name="ln2706">	struct iwm_phy_cfg_cmd phy_cfg_cmd;</a>
<a name="ln2707">	enum iwm_ucode_type ucode_type = sc-&gt;cur_ucode;</a>
<a name="ln2708"> </a>
<a name="ln2709">	/* Set parameters */</a>
<a name="ln2710">	phy_cfg_cmd.phy_cfg = htole32(iwm_mvm_get_phy_config(sc));</a>
<a name="ln2711">	phy_cfg_cmd.calib_control.event_trigger =</a>
<a name="ln2712">	    sc-&gt;sc_default_calib[ucode_type].event_trigger;</a>
<a name="ln2713">	phy_cfg_cmd.calib_control.flow_trigger =</a>
<a name="ln2714">	    sc-&gt;sc_default_calib[ucode_type].flow_trigger;</a>
<a name="ln2715"> </a>
<a name="ln2716">	IWM_DPRINTF(sc, IWM_DEBUG_CMD | IWM_DEBUG_RESET,</a>
<a name="ln2717">	    &quot;Sending Phy CFG command: 0x%x\n&quot;, phy_cfg_cmd.phy_cfg);</a>
<a name="ln2718">	return iwm_mvm_send_cmd_pdu(sc, IWM_PHY_CONFIGURATION_CMD, IWM_CMD_SYNC,</a>
<a name="ln2719">	    sizeof(phy_cfg_cmd), &amp;phy_cfg_cmd);</a>
<a name="ln2720">}</a>
<a name="ln2721"> </a>
<a name="ln2722">static int</a>
<a name="ln2723">iwm_alive_fn(struct iwm_softc *sc, struct iwm_rx_packet *pkt, void *data)</a>
<a name="ln2724">{</a>
<a name="ln2725">	struct iwm_mvm_alive_data *alive_data = data;</a>
<a name="ln2726">	struct iwm_mvm_alive_resp_v3 *palive3;</a>
<a name="ln2727">	struct iwm_mvm_alive_resp *palive;</a>
<a name="ln2728">	struct iwm_umac_alive *umac;</a>
<a name="ln2729">	struct iwm_lmac_alive *lmac1;</a>
<a name="ln2730">	struct iwm_lmac_alive *lmac2 = NULL;</a>
<a name="ln2731">	uint16_t status;</a>
<a name="ln2732"> </a>
<a name="ln2733">	if (iwm_rx_packet_payload_len(pkt) == sizeof(*palive)) {</a>
<a name="ln2734">		palive = (void *)pkt-&gt;data;</a>
<a name="ln2735">		umac = &amp;palive-&gt;umac_data;</a>
<a name="ln2736">		lmac1 = &amp;palive-&gt;lmac_data[0];</a>
<a name="ln2737">		lmac2 = &amp;palive-&gt;lmac_data[1];</a>
<a name="ln2738">		status = le16toh(palive-&gt;status);</a>
<a name="ln2739">	} else {</a>
<a name="ln2740">		palive3 = (void *)pkt-&gt;data;</a>
<a name="ln2741">		umac = &amp;palive3-&gt;umac_data;</a>
<a name="ln2742">		lmac1 = &amp;palive3-&gt;lmac_data;</a>
<a name="ln2743">		status = le16toh(palive3-&gt;status);</a>
<a name="ln2744">	}</a>
<a name="ln2745"> </a>
<a name="ln2746">	sc-&gt;error_event_table[0] = le32toh(lmac1-&gt;error_event_table_ptr);</a>
<a name="ln2747">	if (lmac2)</a>
<a name="ln2748">		sc-&gt;error_event_table[1] =</a>
<a name="ln2749">			le32toh(lmac2-&gt;error_event_table_ptr);</a>
<a name="ln2750">	sc-&gt;log_event_table = le32toh(lmac1-&gt;log_event_table_ptr);</a>
<a name="ln2751">	sc-&gt;umac_error_event_table = le32toh(umac-&gt;error_info_addr);</a>
<a name="ln2752">	alive_data-&gt;scd_base_addr = le32toh(lmac1-&gt;scd_base_ptr);</a>
<a name="ln2753">	alive_data-&gt;valid = status == IWM_ALIVE_STATUS_OK;</a>
<a name="ln2754">	if (sc-&gt;umac_error_event_table)</a>
<a name="ln2755">		sc-&gt;support_umac_log = TRUE;</a>
<a name="ln2756"> </a>
<a name="ln2757">	IWM_DPRINTF(sc, IWM_DEBUG_FW,</a>
<a name="ln2758">		    &quot;Alive ucode status 0x%04x revision 0x%01X 0x%01X\n&quot;,</a>
<a name="ln2759">		    status, lmac1-&gt;ver_type, lmac1-&gt;ver_subtype);</a>
<a name="ln2760"> </a>
<a name="ln2761">	if (lmac2)</a>
<a name="ln2762">		IWM_DPRINTF(sc, IWM_DEBUG_FW, &quot;Alive ucode CDB\n&quot;);</a>
<a name="ln2763"> </a>
<a name="ln2764">	IWM_DPRINTF(sc, IWM_DEBUG_FW,</a>
<a name="ln2765">		    &quot;UMAC version: Major - 0x%x, Minor - 0x%x\n&quot;,</a>
<a name="ln2766">		    le32toh(umac-&gt;umac_major),</a>
<a name="ln2767">		    le32toh(umac-&gt;umac_minor));</a>
<a name="ln2768"> </a>
<a name="ln2769">	return TRUE;</a>
<a name="ln2770">}</a>
<a name="ln2771"> </a>
<a name="ln2772">static int</a>
<a name="ln2773">iwm_wait_phy_db_entry(struct iwm_softc *sc,</a>
<a name="ln2774">	struct iwm_rx_packet *pkt, void *data)</a>
<a name="ln2775">{</a>
<a name="ln2776">	struct iwm_phy_db *phy_db = data;</a>
<a name="ln2777"> </a>
<a name="ln2778">	if (pkt-&gt;hdr.code != IWM_CALIB_RES_NOTIF_PHY_DB) {</a>
<a name="ln2779">		if(pkt-&gt;hdr.code != IWM_INIT_COMPLETE_NOTIF) {</a>
<a name="ln2780">			device_printf(sc-&gt;sc_dev, &quot;%s: Unexpected cmd: %d\n&quot;,</a>
<a name="ln2781">			    __func__, pkt-&gt;hdr.code);</a>
<a name="ln2782">		}</a>
<a name="ln2783">		return TRUE;</a>
<a name="ln2784">	}</a>
<a name="ln2785"> </a>
<a name="ln2786">	if (iwm_phy_db_set_section(phy_db, pkt)) {</a>
<a name="ln2787">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln2788">		    &quot;%s: iwm_phy_db_set_section failed\n&quot;, __func__);</a>
<a name="ln2789">	}</a>
<a name="ln2790"> </a>
<a name="ln2791">	return FALSE;</a>
<a name="ln2792">}</a>
<a name="ln2793"> </a>
<a name="ln2794">static int</a>
<a name="ln2795">iwm_mvm_load_ucode_wait_alive(struct iwm_softc *sc,</a>
<a name="ln2796">	enum iwm_ucode_type ucode_type)</a>
<a name="ln2797">{</a>
<a name="ln2798">	struct iwm_notification_wait alive_wait;</a>
<a name="ln2799">	struct iwm_mvm_alive_data alive_data;</a>
<a name="ln2800">	const struct iwm_fw_img *fw;</a>
<a name="ln2801">	enum iwm_ucode_type old_type = sc-&gt;cur_ucode;</a>
<a name="ln2802">	int error;</a>
<a name="ln2803">	static const uint16_t alive_cmd[] = { IWM_MVM_ALIVE };</a>
<a name="ln2804"> </a>
<a name="ln2805">	fw = &amp;sc-&gt;sc_fw.img[ucode_type];</a>
<a name="ln2806">	sc-&gt;cur_ucode = ucode_type;</a>
<a name="ln2807">	sc-&gt;ucode_loaded = FALSE;</a>
<a name="ln2808"> </a>
<a name="ln2809">	memset(&amp;alive_data, 0, sizeof(alive_data));</a>
<a name="ln2810">	iwm_init_notification_wait(sc-&gt;sc_notif_wait, &amp;alive_wait,</a>
<a name="ln2811">				   alive_cmd, nitems(alive_cmd),</a>
<a name="ln2812">				   iwm_alive_fn, &amp;alive_data);</a>
<a name="ln2813"> </a>
<a name="ln2814">	error = iwm_start_fw(sc, fw);</a>
<a name="ln2815">	if (error) {</a>
<a name="ln2816">		device_printf(sc-&gt;sc_dev, &quot;iwm_start_fw: failed %d\n&quot;, error);</a>
<a name="ln2817">		sc-&gt;cur_ucode = old_type;</a>
<a name="ln2818">		iwm_remove_notification(sc-&gt;sc_notif_wait, &amp;alive_wait);</a>
<a name="ln2819">		return error;</a>
<a name="ln2820">	}</a>
<a name="ln2821"> </a>
<a name="ln2822">	/*</a>
<a name="ln2823">	 * Some things may run in the background now, but we</a>
<a name="ln2824">	 * just wait for the ALIVE notification here.</a>
<a name="ln2825">	 */</a>
<a name="ln2826">	IWM_UNLOCK(sc);</a>
<a name="ln2827">	error = iwm_wait_notification(sc-&gt;sc_notif_wait, &amp;alive_wait,</a>
<a name="ln2828">				      IWM_MVM_UCODE_ALIVE_TIMEOUT);</a>
<a name="ln2829">	IWM_LOCK(sc);</a>
<a name="ln2830">	if (error) {</a>
<a name="ln2831">		if (sc-&gt;cfg-&gt;device_family == IWM_DEVICE_FAMILY_8000) {</a>
<a name="ln2832">			uint32_t a = 0x5a5a5a5a, b = 0x5a5a5a5a;</a>
<a name="ln2833">			if (iwm_nic_lock(sc)) {</a>
<a name="ln2834">				a = iwm_read_prph(sc, IWM_SB_CPU_1_STATUS);</a>
<a name="ln2835">				b = iwm_read_prph(sc, IWM_SB_CPU_2_STATUS);</a>
<a name="ln2836">				iwm_nic_unlock(sc);</a>
<a name="ln2837">			}</a>
<a name="ln2838">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln2839">			    &quot;SecBoot CPU1 Status: 0x%x, CPU2 Status: 0x%x\n&quot;,</a>
<a name="ln2840">			    a, b);</a>
<a name="ln2841">		}</a>
<a name="ln2842">		sc-&gt;cur_ucode = old_type;</a>
<a name="ln2843">		return error;</a>
<a name="ln2844">	}</a>
<a name="ln2845"> </a>
<a name="ln2846">	if (!alive_data.valid) {</a>
<a name="ln2847">		device_printf(sc-&gt;sc_dev, &quot;%s: Loaded ucode is not valid\n&quot;,</a>
<a name="ln2848">		    __func__);</a>
<a name="ln2849">		sc-&gt;cur_ucode = old_type;</a>
<a name="ln2850">		return EIO;</a>
<a name="ln2851">	}</a>
<a name="ln2852"> </a>
<a name="ln2853">	iwm_trans_pcie_fw_alive(sc, alive_data.scd_base_addr);</a>
<a name="ln2854"> </a>
<a name="ln2855">	/*</a>
<a name="ln2856">	 * configure and operate fw paging mechanism.</a>
<a name="ln2857">	 * driver configures the paging flow only once, CPU2 paging image</a>
<a name="ln2858">	 * included in the IWM_UCODE_INIT image.</a>
<a name="ln2859">	 */</a>
<a name="ln2860">	if (fw-&gt;paging_mem_size) {</a>
<a name="ln2861">		error = iwm_save_fw_paging(sc, fw);</a>
<a name="ln2862">		if (error) {</a>
<a name="ln2863">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln2864">			    &quot;%s: failed to save the FW paging image\n&quot;,</a>
<a name="ln2865">			    __func__);</a>
<a name="ln2866">			return error;</a>
<a name="ln2867">		}</a>
<a name="ln2868"> </a>
<a name="ln2869">		error = iwm_send_paging_cmd(sc, fw);</a>
<a name="ln2870">		if (error) {</a>
<a name="ln2871">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln2872">			    &quot;%s: failed to send the paging cmd\n&quot;, __func__);</a>
<a name="ln2873">			iwm_free_fw_paging(sc);</a>
<a name="ln2874">			return error;</a>
<a name="ln2875">		}</a>
<a name="ln2876">	}</a>
<a name="ln2877"> </a>
<a name="ln2878">	if (!error)</a>
<a name="ln2879">		sc-&gt;ucode_loaded = TRUE;</a>
<a name="ln2880">	return error;</a>
<a name="ln2881">}</a>
<a name="ln2882"> </a>
<a name="ln2883">/*</a>
<a name="ln2884"> * mvm misc bits</a>
<a name="ln2885"> */</a>
<a name="ln2886"> </a>
<a name="ln2887">/*</a>
<a name="ln2888"> * follows iwlwifi/fw.c</a>
<a name="ln2889"> */</a>
<a name="ln2890">static int</a>
<a name="ln2891">iwm_run_init_mvm_ucode(struct iwm_softc *sc, int justnvm)</a>
<a name="ln2892">{</a>
<a name="ln2893">	struct iwm_notification_wait calib_wait;</a>
<a name="ln2894">	static const uint16_t init_complete[] = {</a>
<a name="ln2895">		IWM_INIT_COMPLETE_NOTIF,</a>
<a name="ln2896">		IWM_CALIB_RES_NOTIF_PHY_DB</a>
<a name="ln2897">	};</a>
<a name="ln2898">	int ret;</a>
<a name="ln2899"> </a>
<a name="ln2900">	/* do not operate with rfkill switch turned on */</a>
<a name="ln2901">	if ((sc-&gt;sc_flags &amp; IWM_FLAG_RFKILL) &amp;&amp; !justnvm) {</a>
<a name="ln2902">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln2903">		    &quot;radio is disabled by hardware switch\n&quot;);</a>
<a name="ln2904">		return EPERM;</a>
<a name="ln2905">	}</a>
<a name="ln2906"> </a>
<a name="ln2907">	iwm_init_notification_wait(sc-&gt;sc_notif_wait,</a>
<a name="ln2908">				   &amp;calib_wait,</a>
<a name="ln2909">				   init_complete,</a>
<a name="ln2910">				   nitems(init_complete),</a>
<a name="ln2911">				   iwm_wait_phy_db_entry,</a>
<a name="ln2912">				   sc-&gt;sc_phy_db);</a>
<a name="ln2913"> </a>
<a name="ln2914">	/* Will also start the device */</a>
<a name="ln2915">	ret = iwm_mvm_load_ucode_wait_alive(sc, IWM_UCODE_INIT);</a>
<a name="ln2916">	if (ret) {</a>
<a name="ln2917">		device_printf(sc-&gt;sc_dev, &quot;Failed to start INIT ucode: %d\n&quot;,</a>
<a name="ln2918">		    ret);</a>
<a name="ln2919">		goto error;</a>
<a name="ln2920">	}</a>
<a name="ln2921"> </a>
<a name="ln2922">	if (justnvm) {</a>
<a name="ln2923">		/* Read nvm */</a>
<a name="ln2924">		ret = iwm_nvm_init(sc);</a>
<a name="ln2925">		if (ret) {</a>
<a name="ln2926">			device_printf(sc-&gt;sc_dev, &quot;failed to read nvm\n&quot;);</a>
<a name="ln2927">			goto error;</a>
<a name="ln2928">		}</a>
<a name="ln2929">		IEEE80211_ADDR_COPY(sc-&gt;sc_ic.ic_macaddr, sc-&gt;nvm_data-&gt;hw_addr);</a>
<a name="ln2930">		goto error;</a>
<a name="ln2931">	}</a>
<a name="ln2932"> </a>
<a name="ln2933">	ret = iwm_send_bt_init_conf(sc);</a>
<a name="ln2934">	if (ret) {</a>
<a name="ln2935">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln2936">		    &quot;failed to send bt coex configuration: %d\n&quot;, ret);</a>
<a name="ln2937">		goto error;</a>
<a name="ln2938">	}</a>
<a name="ln2939"> </a>
<a name="ln2940">	/* Send TX valid antennas before triggering calibrations */</a>
<a name="ln2941">	ret = iwm_send_tx_ant_cfg(sc, iwm_mvm_get_valid_tx_ant(sc));</a>
<a name="ln2942">	if (ret) {</a>
<a name="ln2943">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln2944">		    &quot;failed to send antennas before calibration: %d\n&quot;, ret);</a>
<a name="ln2945">		goto error;</a>
<a name="ln2946">	}</a>
<a name="ln2947"> </a>
<a name="ln2948">	/*</a>
<a name="ln2949">	 * Send phy configurations command to init uCode</a>
<a name="ln2950">	 * to start the 16.0 uCode init image internal calibrations.</a>
<a name="ln2951">	 */</a>
<a name="ln2952">	ret = iwm_send_phy_cfg_cmd(sc);</a>
<a name="ln2953">	if (ret) {</a>
<a name="ln2954">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln2955">		    &quot;%s: Failed to run INIT calibrations: %d\n&quot;,</a>
<a name="ln2956">		    __func__, ret);</a>
<a name="ln2957">		goto error;</a>
<a name="ln2958">	}</a>
<a name="ln2959"> </a>
<a name="ln2960">	/*</a>
<a name="ln2961">	 * Nothing to do but wait for the init complete notification</a>
<a name="ln2962">	 * from the firmware.</a>
<a name="ln2963">	 */</a>
<a name="ln2964">	IWM_UNLOCK(sc);</a>
<a name="ln2965">	ret = iwm_wait_notification(sc-&gt;sc_notif_wait, &amp;calib_wait,</a>
<a name="ln2966">	    IWM_MVM_UCODE_CALIB_TIMEOUT);</a>
<a name="ln2967">	IWM_LOCK(sc);</a>
<a name="ln2968"> </a>
<a name="ln2969"> </a>
<a name="ln2970">	goto out;</a>
<a name="ln2971"> </a>
<a name="ln2972">error:</a>
<a name="ln2973">	iwm_remove_notification(sc-&gt;sc_notif_wait, &amp;calib_wait);</a>
<a name="ln2974">out:</a>
<a name="ln2975">	return ret;</a>
<a name="ln2976">}</a>
<a name="ln2977"> </a>
<a name="ln2978">static int</a>
<a name="ln2979">iwm_mvm_config_ltr(struct iwm_softc *sc)</a>
<a name="ln2980">{</a>
<a name="ln2981">	struct iwm_ltr_config_cmd cmd = {</a>
<a name="ln2982">		.flags = htole32(IWM_LTR_CFG_FLAG_FEATURE_ENABLE),</a>
<a name="ln2983">	};</a>
<a name="ln2984"> </a>
<a name="ln2985">	if (!sc-&gt;sc_ltr_enabled)</a>
<a name="ln2986">		return 0;</a>
<a name="ln2987"> </a>
<a name="ln2988">	return iwm_mvm_send_cmd_pdu(sc, IWM_LTR_CONFIG, 0, sizeof(cmd), &amp;cmd);</a>
<a name="ln2989">}</a>
<a name="ln2990"> </a>
<a name="ln2991">/*</a>
<a name="ln2992"> * receive side</a>
<a name="ln2993"> */</a>
<a name="ln2994"> </a>
<a name="ln2995">/* (re)stock rx ring, called at init-time and at runtime */</a>
<a name="ln2996">static int</a>
<a name="ln2997">iwm_rx_addbuf(struct iwm_softc *sc, int size, int idx)</a>
<a name="ln2998">{</a>
<a name="ln2999">	struct iwm_rx_ring *ring = &amp;sc-&gt;rxq;</a>
<a name="ln3000">	struct iwm_rx_data *data = &amp;ring-&gt;data[idx];</a>
<a name="ln3001">	struct mbuf *m;</a>
<a name="ln3002">	bus_dmamap_t dmamap;</a>
<a name="ln3003">	bus_dma_segment_t seg;</a>
<a name="ln3004">	int nsegs, error;</a>
<a name="ln3005"> </a>
<a name="ln3006">	m = m_getjcl(M_NOWAIT, MT_DATA, M_PKTHDR, IWM_RBUF_SIZE);</a>
<a name="ln3007">	if (m == NULL)</a>
<a name="ln3008">		return ENOBUFS;</a>
<a name="ln3009"> </a>
<a name="ln3010">	m-&gt;m_len = m-&gt;m_pkthdr.len = m-&gt;m_ext.ext_size;</a>
<a name="ln3011">	error = bus_dmamap_load_mbuf_sg(ring-&gt;data_dmat, ring-&gt;spare_map, m,</a>
<a name="ln3012">	    &amp;seg, &amp;nsegs, BUS_DMA_NOWAIT);</a>
<a name="ln3013">	if (error != 0) {</a>
<a name="ln3014">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln3015">		    &quot;%s: can't map mbuf, error %d\n&quot;, __func__, error);</a>
<a name="ln3016">		m_freem(m);</a>
<a name="ln3017">		return error;</a>
<a name="ln3018">	}</a>
<a name="ln3019"> </a>
<a name="ln3020">	if (data-&gt;m != NULL)</a>
<a name="ln3021">		bus_dmamap_unload(ring-&gt;data_dmat, data-&gt;map);</a>
<a name="ln3022"> </a>
<a name="ln3023">	/* Swap ring-&gt;spare_map with data-&gt;map */</a>
<a name="ln3024">	dmamap = data-&gt;map;</a>
<a name="ln3025">	data-&gt;map = ring-&gt;spare_map;</a>
<a name="ln3026">	ring-&gt;spare_map = dmamap;</a>
<a name="ln3027"> </a>
<a name="ln3028">	bus_dmamap_sync(ring-&gt;data_dmat, data-&gt;map, BUS_DMASYNC_PREREAD);</a>
<a name="ln3029">	data-&gt;m = m;</a>
<a name="ln3030"> </a>
<a name="ln3031">	/* Update RX descriptor. */</a>
<a name="ln3032">	KASSERT((seg.ds_addr &amp; 255) == 0, (&quot;seg.ds_addr not aligned&quot;));</a>
<a name="ln3033">	ring-&gt;desc[idx] = htole32(seg.ds_addr &gt;&gt; 8);</a>
<a name="ln3034">	bus_dmamap_sync(ring-&gt;desc_dma.tag, ring-&gt;desc_dma.map,</a>
<a name="ln3035">	    BUS_DMASYNC_PREWRITE);</a>
<a name="ln3036"> </a>
<a name="ln3037">	return 0;</a>
<a name="ln3038">}</a>
<a name="ln3039"> </a>
<a name="ln3040">/* iwlwifi: mvm/rx.c */</a>
<a name="ln3041">/*</a>
<a name="ln3042"> * iwm_mvm_get_signal_strength - use new rx PHY INFO API</a>
<a name="ln3043"> * values are reported by the fw as positive values - need to negate</a>
<a name="ln3044"> * to obtain their dBM.  Account for missing antennas by replacing 0</a>
<a name="ln3045"> * values by -256dBm: practically 0 power and a non-feasible 8 bit value.</a>
<a name="ln3046"> */</a>
<a name="ln3047">static int</a>
<a name="ln3048">iwm_mvm_get_signal_strength(struct iwm_softc *sc, struct iwm_rx_phy_info *phy_info)</a>
<a name="ln3049">{</a>
<a name="ln3050">	int energy_a, energy_b, energy_c, max_energy;</a>
<a name="ln3051">	uint32_t val;</a>
<a name="ln3052"> </a>
<a name="ln3053">	val = le32toh(phy_info-&gt;non_cfg_phy[IWM_RX_INFO_ENERGY_ANT_ABC_IDX]);</a>
<a name="ln3054">	energy_a = (val &amp; IWM_RX_INFO_ENERGY_ANT_A_MSK) &gt;&gt;</a>
<a name="ln3055">	    IWM_RX_INFO_ENERGY_ANT_A_POS;</a>
<a name="ln3056">	energy_a = energy_a ? -energy_a : -256;</a>
<a name="ln3057">	energy_b = (val &amp; IWM_RX_INFO_ENERGY_ANT_B_MSK) &gt;&gt;</a>
<a name="ln3058">	    IWM_RX_INFO_ENERGY_ANT_B_POS;</a>
<a name="ln3059">	energy_b = energy_b ? -energy_b : -256;</a>
<a name="ln3060">	energy_c = (val &amp; IWM_RX_INFO_ENERGY_ANT_C_MSK) &gt;&gt;</a>
<a name="ln3061">	    IWM_RX_INFO_ENERGY_ANT_C_POS;</a>
<a name="ln3062">	energy_c = energy_c ? -energy_c : -256;</a>
<a name="ln3063">	max_energy = MAX(energy_a, energy_b);</a>
<a name="ln3064">	max_energy = MAX(max_energy, energy_c);</a>
<a name="ln3065"> </a>
<a name="ln3066">	IWM_DPRINTF(sc, IWM_DEBUG_RECV,</a>
<a name="ln3067">	    &quot;energy In A %d B %d C %d , and max %d\n&quot;,</a>
<a name="ln3068">	    energy_a, energy_b, energy_c, max_energy);</a>
<a name="ln3069"> </a>
<a name="ln3070">	return max_energy;</a>
<a name="ln3071">}</a>
<a name="ln3072"> </a>
<a name="ln3073">static void</a>
<a name="ln3074">iwm_mvm_rx_rx_phy_cmd(struct iwm_softc *sc, struct iwm_rx_packet *pkt)</a>
<a name="ln3075">{</a>
<a name="ln3076">	struct iwm_rx_phy_info *phy_info = (void *)pkt-&gt;data;</a>
<a name="ln3077"> </a>
<a name="ln3078">	IWM_DPRINTF(sc, IWM_DEBUG_RECV, &quot;received PHY stats\n&quot;);</a>
<a name="ln3079"> </a>
<a name="ln3080">	memcpy(&amp;sc-&gt;sc_last_phy_info, phy_info, sizeof(sc-&gt;sc_last_phy_info));</a>
<a name="ln3081">}</a>
<a name="ln3082"> </a>
<a name="ln3083">/*</a>
<a name="ln3084"> * Retrieve the average noise (in dBm) among receivers.</a>
<a name="ln3085"> */</a>
<a name="ln3086">static int</a>
<a name="ln3087">iwm_get_noise(struct iwm_softc *sc,</a>
<a name="ln3088">    const struct iwm_mvm_statistics_rx_non_phy *stats)</a>
<a name="ln3089">{</a>
<a name="ln3090">	int i, total, nbant, noise;</a>
<a name="ln3091"> </a>
<a name="ln3092">	total = nbant = noise = 0;</a>
<a name="ln3093">	for (i = 0; i &lt; 3; i++) {</a>
<a name="ln3094">		noise = le32toh(stats-&gt;beacon_silence_rssi[i]) &amp; 0xff;</a>
<a name="ln3095">		IWM_DPRINTF(sc, IWM_DEBUG_RECV, &quot;%s: i=%d, noise=%d\n&quot;,</a>
<a name="ln3096">		    __func__,</a>
<a name="ln3097">		    i,</a>
<a name="ln3098">		    noise);</a>
<a name="ln3099"> </a>
<a name="ln3100">		if (noise) {</a>
<a name="ln3101">			total += noise;</a>
<a name="ln3102">			nbant++;</a>
<a name="ln3103">		}</a>
<a name="ln3104">	}</a>
<a name="ln3105"> </a>
<a name="ln3106">	IWM_DPRINTF(sc, IWM_DEBUG_RECV, &quot;%s: nbant=%d, total=%d\n&quot;,</a>
<a name="ln3107">	    __func__, nbant, total);</a>
<a name="ln3108">#if 0</a>
<a name="ln3109">	/* There should be at least one antenna but check anyway. */</a>
<a name="ln3110">	return (nbant == 0) ? -127 : (total / nbant) - 107;</a>
<a name="ln3111">#else</a>
<a name="ln3112">	/* For now, just hard-code it to -96 to be safe */</a>
<a name="ln3113">	return (-96);</a>
<a name="ln3114">#endif</a>
<a name="ln3115">}</a>
<a name="ln3116"> </a>
<a name="ln3117">static void</a>
<a name="ln3118">iwm_mvm_handle_rx_statistics(struct iwm_softc *sc, struct iwm_rx_packet *pkt)</a>
<a name="ln3119">{</a>
<a name="ln3120">	struct iwm_notif_statistics_v10 *stats = (void *)&amp;pkt-&gt;data;</a>
<a name="ln3121"> </a>
<a name="ln3122">	memcpy(&amp;sc-&gt;sc_stats, stats, sizeof(sc-&gt;sc_stats));</a>
<a name="ln3123">	sc-&gt;sc_noise = iwm_get_noise(sc, &amp;stats-&gt;rx.general);</a>
<a name="ln3124">}</a>
<a name="ln3125"> </a>
<a name="ln3126">/*</a>
<a name="ln3127"> * iwm_mvm_rx_rx_mpdu - IWM_REPLY_RX_MPDU_CMD handler</a>
<a name="ln3128"> *</a>
<a name="ln3129"> * Handles the actual data of the Rx packet from the fw</a>
<a name="ln3130"> */</a>
<a name="ln3131">static boolean_t</a>
<a name="ln3132">iwm_mvm_rx_rx_mpdu(struct iwm_softc *sc, struct mbuf *m, uint32_t offset,</a>
<a name="ln3133">	boolean_t stolen)</a>
<a name="ln3134">{</a>
<a name="ln3135">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln3136">	struct ieee80211vap *vap = TAILQ_FIRST(&amp;ic-&gt;ic_vaps);</a>
<a name="ln3137">	struct ieee80211_frame *wh;</a>
<a name="ln3138">	struct ieee80211_node *ni;</a>
<a name="ln3139">	struct ieee80211_rx_stats rxs;</a>
<a name="ln3140">	struct iwm_rx_phy_info *phy_info;</a>
<a name="ln3141">	struct iwm_rx_mpdu_res_start *rx_res;</a>
<a name="ln3142">	struct iwm_rx_packet *pkt = mtodoff(m, struct iwm_rx_packet *, offset);</a>
<a name="ln3143">	uint32_t len;</a>
<a name="ln3144">	uint32_t rx_pkt_status;</a>
<a name="ln3145">	int rssi;</a>
<a name="ln3146"> </a>
<a name="ln3147">	phy_info = &amp;sc-&gt;sc_last_phy_info;</a>
<a name="ln3148">	rx_res = (struct iwm_rx_mpdu_res_start *)pkt-&gt;data;</a>
<a name="ln3149">	wh = (struct ieee80211_frame *)(pkt-&gt;data + sizeof(*rx_res));</a>
<a name="ln3150">	len = le16toh(rx_res-&gt;byte_count);</a>
<a name="ln3151">	rx_pkt_status = le32toh(*(uint32_t *)(pkt-&gt;data + sizeof(*rx_res) + len));</a>
<a name="ln3152"> </a>
<a name="ln3153">	if (__predict_false(phy_info-&gt;cfg_phy_cnt &gt; 20)) {</a>
<a name="ln3154">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln3155">		    &quot;dsp size out of range [0,20]: %d\n&quot;,</a>
<a name="ln3156">		    phy_info-&gt;cfg_phy_cnt);</a>
<a name="ln3157">		goto fail;</a>
<a name="ln3158">	}</a>
<a name="ln3159"> </a>
<a name="ln3160">	if (!(rx_pkt_status &amp; IWM_RX_MPDU_RES_STATUS_CRC_OK) ||</a>
<a name="ln3161">	    !(rx_pkt_status &amp; IWM_RX_MPDU_RES_STATUS_OVERRUN_OK)) {</a>
<a name="ln3162">		IWM_DPRINTF(sc, IWM_DEBUG_RECV,</a>
<a name="ln3163">		    &quot;Bad CRC or FIFO: 0x%08X.\n&quot;, rx_pkt_status);</a>
<a name="ln3164">		goto fail;</a>
<a name="ln3165">	}</a>
<a name="ln3166"> </a>
<a name="ln3167">	rssi = iwm_mvm_get_signal_strength(sc, phy_info);</a>
<a name="ln3168"> </a>
<a name="ln3169">	/* Map it to relative value */</a>
<a name="ln3170">	rssi = rssi - sc-&gt;sc_noise;</a>
<a name="ln3171"> </a>
<a name="ln3172">	/* replenish ring for the buffer we're going to feed to the sharks */</a>
<a name="ln3173">	if (!stolen &amp;&amp; iwm_rx_addbuf(sc, IWM_RBUF_SIZE, sc-&gt;rxq.cur) != 0) {</a>
<a name="ln3174">		device_printf(sc-&gt;sc_dev, &quot;%s: unable to add more buffers\n&quot;,</a>
<a name="ln3175">		    __func__);</a>
<a name="ln3176">		goto fail;</a>
<a name="ln3177">	}</a>
<a name="ln3178"> </a>
<a name="ln3179">	m-&gt;m_data = pkt-&gt;data + sizeof(*rx_res);</a>
<a name="ln3180">	m-&gt;m_pkthdr.len = m-&gt;m_len = len;</a>
<a name="ln3181"> </a>
<a name="ln3182">	IWM_DPRINTF(sc, IWM_DEBUG_RECV,</a>
<a name="ln3183">	    &quot;%s: rssi=%d, noise=%d\n&quot;, __func__, rssi, sc-&gt;sc_noise);</a>
<a name="ln3184"> </a>
<a name="ln3185">	ni = ieee80211_find_rxnode(ic, (struct ieee80211_frame_min *)wh);</a>
<a name="ln3186"> </a>
<a name="ln3187">	IWM_DPRINTF(sc, IWM_DEBUG_RECV,</a>
<a name="ln3188">	    &quot;%s: phy_info: channel=%d, flags=0x%08x\n&quot;,</a>
<a name="ln3189">	    __func__,</a>
<a name="ln3190">	    le16toh(phy_info-&gt;channel),</a>
<a name="ln3191">	    le16toh(phy_info-&gt;phy_flags));</a>
<a name="ln3192"> </a>
<a name="ln3193">	/*</a>
<a name="ln3194">	 * Populate an RX state struct with the provided information.</a>
<a name="ln3195">	 */</a>
<a name="ln3196">	bzero(&amp;rxs, sizeof(rxs));</a>
<a name="ln3197">	rxs.r_flags |= IEEE80211_R_IEEE | IEEE80211_R_FREQ;</a>
<a name="ln3198">	rxs.r_flags |= IEEE80211_R_NF | IEEE80211_R_RSSI;</a>
<a name="ln3199">	rxs.c_ieee = le16toh(phy_info-&gt;channel);</a>
<a name="ln3200">	if (le16toh(phy_info-&gt;phy_flags &amp; IWM_RX_RES_PHY_FLAGS_BAND_24)) {</a>
<a name="ln3201">		rxs.c_freq = ieee80211_ieee2mhz(rxs.c_ieee, IEEE80211_CHAN_2GHZ);</a>
<a name="ln3202">	} else {</a>
<a name="ln3203">		rxs.c_freq = ieee80211_ieee2mhz(rxs.c_ieee, IEEE80211_CHAN_5GHZ);</a>
<a name="ln3204">	}</a>
<a name="ln3205"> </a>
<a name="ln3206">	/* rssi is in 1/2db units */</a>
<a name="ln3207">	rxs.c_rssi = rssi * 2;</a>
<a name="ln3208">	rxs.c_nf = sc-&gt;sc_noise;</a>
<a name="ln3209">	if (ieee80211_add_rx_params(m, &amp;rxs) == 0) {</a>
<a name="ln3210">		if (ni)</a>
<a name="ln3211">			ieee80211_free_node(ni);</a>
<a name="ln3212">		goto fail;</a>
<a name="ln3213">	}</a>
<a name="ln3214"> </a>
<a name="ln3215">	if (ieee80211_radiotap_active_vap(vap)) {</a>
<a name="ln3216">		struct iwm_rx_radiotap_header *tap = &amp;sc-&gt;sc_rxtap;</a>
<a name="ln3217"> </a>
<a name="ln3218">		tap-&gt;wr_flags = 0;</a>
<a name="ln3219">		if (phy_info-&gt;phy_flags &amp; htole16(IWM_PHY_INFO_FLAG_SHPREAMBLE))</a>
<a name="ln3220">			tap-&gt;wr_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;</a>
<a name="ln3221">		tap-&gt;wr_chan_freq = htole16(rxs.c_freq);</a>
<a name="ln3222">		/* XXX only if ic-&gt;ic_curchan-&gt;ic_ieee == rxs.c_ieee */</a>
<a name="ln3223">		tap-&gt;wr_chan_flags = htole16(ic-&gt;ic_curchan-&gt;ic_flags);</a>
<a name="ln3224">		tap-&gt;wr_dbm_antsignal = (int8_t)rssi;</a>
<a name="ln3225">		tap-&gt;wr_dbm_antnoise = (int8_t)sc-&gt;sc_noise;</a>
<a name="ln3226">		tap-&gt;wr_tsft = phy_info-&gt;system_timestamp;</a>
<a name="ln3227">		switch (phy_info-&gt;rate) {</a>
<a name="ln3228">		/* CCK rates. */</a>
<a name="ln3229">		case  10: tap-&gt;wr_rate =   2; break;</a>
<a name="ln3230">		case  20: tap-&gt;wr_rate =   4; break;</a>
<a name="ln3231">		case  55: tap-&gt;wr_rate =  11; break;</a>
<a name="ln3232">		case 110: tap-&gt;wr_rate =  22; break;</a>
<a name="ln3233">		/* OFDM rates. */</a>
<a name="ln3234">		case 0xd: tap-&gt;wr_rate =  12; break;</a>
<a name="ln3235">		case 0xf: tap-&gt;wr_rate =  18; break;</a>
<a name="ln3236">		case 0x5: tap-&gt;wr_rate =  24; break;</a>
<a name="ln3237">		case 0x7: tap-&gt;wr_rate =  36; break;</a>
<a name="ln3238">		case 0x9: tap-&gt;wr_rate =  48; break;</a>
<a name="ln3239">		case 0xb: tap-&gt;wr_rate =  72; break;</a>
<a name="ln3240">		case 0x1: tap-&gt;wr_rate =  96; break;</a>
<a name="ln3241">		case 0x3: tap-&gt;wr_rate = 108; break;</a>
<a name="ln3242">		/* Unknown rate: should not happen. */</a>
<a name="ln3243">		default:  tap-&gt;wr_rate =   0;</a>
<a name="ln3244">		}</a>
<a name="ln3245">	}</a>
<a name="ln3246"> </a>
<a name="ln3247">	IWM_UNLOCK(sc);</a>
<a name="ln3248">	if (ni != NULL) {</a>
<a name="ln3249">		IWM_DPRINTF(sc, IWM_DEBUG_RECV, &quot;input m %p\n&quot;, m);</a>
<a name="ln3250">		ieee80211_input_mimo(ni, m);</a>
<a name="ln3251">		ieee80211_free_node(ni);</a>
<a name="ln3252">	} else {</a>
<a name="ln3253">		IWM_DPRINTF(sc, IWM_DEBUG_RECV, &quot;inputall m %p\n&quot;, m);</a>
<a name="ln3254">		ieee80211_input_mimo_all(ic, m);</a>
<a name="ln3255">	}</a>
<a name="ln3256">	IWM_LOCK(sc);</a>
<a name="ln3257"> </a>
<a name="ln3258">	return TRUE;</a>
<a name="ln3259"> </a>
<a name="ln3260">fail:</a>
<a name="ln3261">	counter_u64_add(ic-&gt;ic_ierrors, 1);</a>
<a name="ln3262">	return FALSE;</a>
<a name="ln3263">}</a>
<a name="ln3264"> </a>
<a name="ln3265">static int</a>
<a name="ln3266">iwm_mvm_rx_tx_cmd_single(struct iwm_softc *sc, struct iwm_rx_packet *pkt,</a>
<a name="ln3267">	struct iwm_node *in)</a>
<a name="ln3268">{</a>
<a name="ln3269">	struct iwm_mvm_tx_resp *tx_resp = (void *)pkt-&gt;data;</a>
<a name="ln3270">	struct ieee80211_ratectl_tx_status *txs = &amp;sc-&gt;sc_txs;</a>
<a name="ln3271">	struct ieee80211_node *ni = &amp;in-&gt;in_ni;</a>
<a name="ln3272">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln3273">	int status = le16toh(tx_resp-&gt;status.status) &amp; IWM_TX_STATUS_MSK;</a>
<a name="ln3274">	int new_rate, cur_rate = vap-&gt;iv_bss-&gt;ni_txrate;</a>
<a name="ln3275">	boolean_t rate_matched;</a>
<a name="ln3276">	uint8_t tx_resp_rate;</a>
<a name="ln3277"> </a>
<a name="ln3278">	KASSERT(tx_resp-&gt;frame_count == 1, (&quot;too many frames&quot;));</a>
<a name="ln3279"> </a>
<a name="ln3280">	/* Update rate control statistics. */</a>
<a name="ln3281">	IWM_DPRINTF(sc, IWM_DEBUG_XMIT, &quot;%s: status=0x%04x, seq=%d, fc=%d, btc=%d, frts=%d, ff=%d, irate=%08x, wmt=%d\n&quot;,</a>
<a name="ln3282">	    __func__,</a>
<a name="ln3283">	    (int) le16toh(tx_resp-&gt;status.status),</a>
<a name="ln3284">	    (int) le16toh(tx_resp-&gt;status.sequence),</a>
<a name="ln3285">	    tx_resp-&gt;frame_count,</a>
<a name="ln3286">	    tx_resp-&gt;bt_kill_count,</a>
<a name="ln3287">	    tx_resp-&gt;failure_rts,</a>
<a name="ln3288">	    tx_resp-&gt;failure_frame,</a>
<a name="ln3289">	    le32toh(tx_resp-&gt;initial_rate),</a>
<a name="ln3290">	    (int) le16toh(tx_resp-&gt;wireless_media_time));</a>
<a name="ln3291"> </a>
<a name="ln3292">	tx_resp_rate = iwm_rate_from_ucode_rate(le32toh(tx_resp-&gt;initial_rate));</a>
<a name="ln3293"> </a>
<a name="ln3294">	/* For rate control, ignore frames sent at different initial rate */</a>
<a name="ln3295">	rate_matched = (tx_resp_rate != 0 &amp;&amp; tx_resp_rate == cur_rate);</a>
<a name="ln3296"> </a>
<a name="ln3297">	if (tx_resp_rate != 0 &amp;&amp; cur_rate != 0 &amp;&amp; !rate_matched) {</a>
<a name="ln3298">		IWM_DPRINTF(sc, IWM_DEBUG_TXRATE,</a>
<a name="ln3299">		    &quot;tx_resp_rate doesn't match ni_txrate (tx_resp_rate=%u &quot;</a>
<a name="ln3300">		    &quot;ni_txrate=%d)\n&quot;, tx_resp_rate, cur_rate);</a>
<a name="ln3301">	}</a>
<a name="ln3302"> </a>
<a name="ln3303">	txs-&gt;flags = IEEE80211_RATECTL_STATUS_SHORT_RETRY |</a>
<a name="ln3304">		     IEEE80211_RATECTL_STATUS_LONG_RETRY;</a>
<a name="ln3305">	txs-&gt;short_retries = tx_resp-&gt;failure_rts;</a>
<a name="ln3306">	txs-&gt;long_retries = tx_resp-&gt;failure_frame;</a>
<a name="ln3307">	if (status != IWM_TX_STATUS_SUCCESS &amp;&amp;</a>
<a name="ln3308">	    status != IWM_TX_STATUS_DIRECT_DONE) {</a>
<a name="ln3309">		switch (status) {</a>
<a name="ln3310">		case IWM_TX_STATUS_FAIL_SHORT_LIMIT:</a>
<a name="ln3311">			txs-&gt;status = IEEE80211_RATECTL_TX_FAIL_SHORT;</a>
<a name="ln3312">			break;</a>
<a name="ln3313">		case IWM_TX_STATUS_FAIL_LONG_LIMIT:</a>
<a name="ln3314">			txs-&gt;status = IEEE80211_RATECTL_TX_FAIL_LONG;</a>
<a name="ln3315">			break;</a>
<a name="ln3316">		case IWM_TX_STATUS_FAIL_LIFE_EXPIRE:</a>
<a name="ln3317">			txs-&gt;status = IEEE80211_RATECTL_TX_FAIL_EXPIRED;</a>
<a name="ln3318">			break;</a>
<a name="ln3319">		default:</a>
<a name="ln3320">			txs-&gt;status = IEEE80211_RATECTL_TX_FAIL_UNSPECIFIED;</a>
<a name="ln3321">			break;</a>
<a name="ln3322">		}</a>
<a name="ln3323">	} else {</a>
<a name="ln3324">		txs-&gt;status = IEEE80211_RATECTL_TX_SUCCESS;</a>
<a name="ln3325">	}</a>
<a name="ln3326"> </a>
<a name="ln3327">	if (rate_matched) {</a>
<a name="ln3328">		int rix;</a>
<a name="ln3329">		ieee80211_ratectl_tx_complete(ni, txs);</a>
<a name="ln3330"> </a>
<a name="ln3331">		rix = ieee80211_ratectl_rate(vap-&gt;iv_bss, NULL, 0);</a>
<a name="ln3332">		new_rate = vap-&gt;iv_bss-&gt;ni_txrate;</a>
<a name="ln3333">		if (new_rate != 0 &amp;&amp; new_rate != cur_rate) {</a>
<a name="ln3334">			struct iwm_node *in = IWM_NODE(vap-&gt;iv_bss);</a>
<a name="ln3335">			iwm_setrates(sc, in, rix);</a>
<a name="ln3336">			iwm_mvm_send_lq_cmd(sc, &amp;in-&gt;in_lq, FALSE);</a>
<a name="ln3337">		}</a>
<a name="ln3338"> 	}</a>
<a name="ln3339"> </a>
<a name="ln3340">	return (txs-&gt;status != IEEE80211_RATECTL_TX_SUCCESS);</a>
<a name="ln3341">}</a>
<a name="ln3342"> </a>
<a name="ln3343">static void</a>
<a name="ln3344">iwm_mvm_rx_tx_cmd(struct iwm_softc *sc, struct iwm_rx_packet *pkt)</a>
<a name="ln3345">{</a>
<a name="ln3346">	struct iwm_cmd_header *cmd_hdr = &amp;pkt-&gt;hdr;</a>
<a name="ln3347">	int idx = cmd_hdr-&gt;idx;</a>
<a name="ln3348">	int qid = cmd_hdr-&gt;qid;</a>
<a name="ln3349">	struct iwm_tx_ring *ring = &amp;sc-&gt;txq[qid];</a>
<a name="ln3350">	struct iwm_tx_data *txd = &amp;ring-&gt;data[idx];</a>
<a name="ln3351">	struct iwm_node *in = txd-&gt;in;</a>
<a name="ln3352">	struct mbuf *m = txd-&gt;m;</a>
<a name="ln3353">	int status;</a>
<a name="ln3354"> </a>
<a name="ln3355">	KASSERT(txd-&gt;done == 0, (&quot;txd not done&quot;));</a>
<a name="ln3356">	KASSERT(txd-&gt;in != NULL, (&quot;txd without node&quot;));</a>
<a name="ln3357">	KASSERT(txd-&gt;m != NULL, (&quot;txd without mbuf&quot;));</a>
<a name="ln3358"> </a>
<a name="ln3359">	sc-&gt;sc_tx_timer = 0;</a>
<a name="ln3360"> </a>
<a name="ln3361">	status = iwm_mvm_rx_tx_cmd_single(sc, pkt, in);</a>
<a name="ln3362"> </a>
<a name="ln3363">	/* Unmap and free mbuf. */</a>
<a name="ln3364">	bus_dmamap_sync(ring-&gt;data_dmat, txd-&gt;map, BUS_DMASYNC_POSTWRITE);</a>
<a name="ln3365">	bus_dmamap_unload(ring-&gt;data_dmat, txd-&gt;map);</a>
<a name="ln3366"> </a>
<a name="ln3367">	IWM_DPRINTF(sc, IWM_DEBUG_XMIT,</a>
<a name="ln3368">	    &quot;free txd %p, in %p\n&quot;, txd, txd-&gt;in);</a>
<a name="ln3369">	txd-&gt;done = 1;</a>
<a name="ln3370">	txd-&gt;m = NULL;</a>
<a name="ln3371">	txd-&gt;in = NULL;</a>
<a name="ln3372"> </a>
<a name="ln3373">	ieee80211_tx_complete(&amp;in-&gt;in_ni, m, status);</a>
<a name="ln3374"> </a>
<a name="ln3375">	if (--ring-&gt;queued &lt; IWM_TX_RING_LOMARK) {</a>
<a name="ln3376">		sc-&gt;qfullmsk &amp;= ~(1 &lt;&lt; ring-&gt;qid);</a>
<a name="ln3377">		if (sc-&gt;qfullmsk == 0) {</a>
<a name="ln3378">			iwm_start(sc);</a>
<a name="ln3379">		}</a>
<a name="ln3380">	}</a>
<a name="ln3381">}</a>
<a name="ln3382"> </a>
<a name="ln3383">/*</a>
<a name="ln3384"> * transmit side</a>
<a name="ln3385"> */</a>
<a name="ln3386"> </a>
<a name="ln3387">/*</a>
<a name="ln3388"> * Process a &quot;command done&quot; firmware notification.  This is where we wakeup</a>
<a name="ln3389"> * processes waiting for a synchronous command completion.</a>
<a name="ln3390"> * from if_iwn</a>
<a name="ln3391"> */</a>
<a name="ln3392">static void</a>
<a name="ln3393">iwm_cmd_done(struct iwm_softc *sc, struct iwm_rx_packet *pkt)</a>
<a name="ln3394">{</a>
<a name="ln3395">	struct iwm_tx_ring *ring = &amp;sc-&gt;txq[IWM_MVM_CMD_QUEUE];</a>
<a name="ln3396">	struct iwm_tx_data *data;</a>
<a name="ln3397"> </a>
<a name="ln3398">	if (pkt-&gt;hdr.qid != IWM_MVM_CMD_QUEUE) {</a>
<a name="ln3399">		return;	/* Not a command ack. */</a>
<a name="ln3400">	}</a>
<a name="ln3401"> </a>
<a name="ln3402">	/* XXX wide commands? */</a>
<a name="ln3403">	IWM_DPRINTF(sc, IWM_DEBUG_CMD,</a>
<a name="ln3404">	    &quot;cmd notification type 0x%x qid %d idx %d\n&quot;,</a>
<a name="ln3405">	    pkt-&gt;hdr.code, pkt-&gt;hdr.qid, pkt-&gt;hdr.idx);</a>
<a name="ln3406"> </a>
<a name="ln3407">	data = &amp;ring-&gt;data[pkt-&gt;hdr.idx];</a>
<a name="ln3408"> </a>
<a name="ln3409">	/* If the command was mapped in an mbuf, free it. */</a>
<a name="ln3410">	if (data-&gt;m != NULL) {</a>
<a name="ln3411">		bus_dmamap_sync(ring-&gt;data_dmat, data-&gt;map,</a>
<a name="ln3412">		    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln3413">		bus_dmamap_unload(ring-&gt;data_dmat, data-&gt;map);</a>
<a name="ln3414">		m_freem(data-&gt;m);</a>
<a name="ln3415">		data-&gt;m = NULL;</a>
<a name="ln3416">	}</a>
<a name="ln3417">	wakeup(&amp;ring-&gt;desc[pkt-&gt;hdr.idx]);</a>
<a name="ln3418"> </a>
<a name="ln3419">	if (((pkt-&gt;hdr.idx + ring-&gt;queued) % IWM_TX_RING_COUNT) != ring-&gt;cur) {</a>
<a name="ln3420">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln3421">		    &quot;%s: Some HCMDs skipped?: idx=%d queued=%d cur=%d\n&quot;,</a>
<a name="ln3422">		    __func__, pkt-&gt;hdr.idx, ring-&gt;queued, ring-&gt;cur);</a>
<a name="ln3423">		/* XXX call iwm_force_nmi() */</a>
<a name="ln3424">	}</a>
<a name="ln3425"> </a>
<a name="ln3426">	KASSERT(ring-&gt;queued &gt; 0, (&quot;ring-&gt;queued is empty?&quot;));</a>
<a name="ln3427">	ring-&gt;queued--;</a>
<a name="ln3428">	if (ring-&gt;queued == 0)</a>
<a name="ln3429">		iwm_pcie_clear_cmd_in_flight(sc);</a>
<a name="ln3430">}</a>
<a name="ln3431"> </a>
<a name="ln3432">#if 0</a>
<a name="ln3433">/*</a>
<a name="ln3434"> * necessary only for block ack mode</a>
<a name="ln3435"> */</a>
<a name="ln3436">void</a>
<a name="ln3437">iwm_update_sched(struct iwm_softc *sc, int qid, int idx, uint8_t sta_id,</a>
<a name="ln3438">	uint16_t len)</a>
<a name="ln3439">{</a>
<a name="ln3440">	struct iwm_agn_scd_bc_tbl *scd_bc_tbl;</a>
<a name="ln3441">	uint16_t w_val;</a>
<a name="ln3442"> </a>
<a name="ln3443">	scd_bc_tbl = sc-&gt;sched_dma.vaddr;</a>
<a name="ln3444"> </a>
<a name="ln3445">	len += 8; /* magic numbers came naturally from paris */</a>
<a name="ln3446">	len = roundup(len, 4) / 4;</a>
<a name="ln3447"> </a>
<a name="ln3448">	w_val = htole16(sta_id &lt;&lt; 12 | len);</a>
<a name="ln3449"> </a>
<a name="ln3450">	/* Update TX scheduler. */</a>
<a name="ln3451">	scd_bc_tbl[qid].tfd_offset[idx] = w_val;</a>
<a name="ln3452">	bus_dmamap_sync(sc-&gt;sched_dma.tag, sc-&gt;sched_dma.map,</a>
<a name="ln3453">	    BUS_DMASYNC_PREWRITE);</a>
<a name="ln3454"> </a>
<a name="ln3455">	/* I really wonder what this is ?!? */</a>
<a name="ln3456">	if (idx &lt; IWM_TFD_QUEUE_SIZE_BC_DUP) {</a>
<a name="ln3457">		scd_bc_tbl[qid].tfd_offset[IWM_TFD_QUEUE_SIZE_MAX + idx] = w_val;</a>
<a name="ln3458">		bus_dmamap_sync(sc-&gt;sched_dma.tag, sc-&gt;sched_dma.map,</a>
<a name="ln3459">		    BUS_DMASYNC_PREWRITE);</a>
<a name="ln3460">	}</a>
<a name="ln3461">}</a>
<a name="ln3462">#endif</a>
<a name="ln3463"> </a>
<a name="ln3464">static int</a>
<a name="ln3465">iwm_tx_rateidx_global_lookup(struct iwm_softc *sc, uint8_t rate)</a>
<a name="ln3466">{</a>
<a name="ln3467">	int i;</a>
<a name="ln3468"> </a>
<a name="ln3469">	for (i = 0; i &lt; nitems(iwm_rates); i++) {</a>
<a name="ln3470">		if (iwm_rates[i].rate == rate)</a>
<a name="ln3471">			return (i);</a>
<a name="ln3472">	}</a>
<a name="ln3473">	/* XXX error? */</a>
<a name="ln3474">	IWM_DPRINTF(sc, IWM_DEBUG_XMIT | IWM_DEBUG_TXRATE,</a>
<a name="ln3475">	    &quot;%s: couldn't find an entry for rate=%d\n&quot;,</a>
<a name="ln3476">	    __func__,</a>
<a name="ln3477">	    rate);</a>
<a name="ln3478">	return (0);</a>
<a name="ln3479">}</a>
<a name="ln3480"> </a>
<a name="ln3481">/*</a>
<a name="ln3482"> * Fill in the rate related information for a transmit command.</a>
<a name="ln3483"> */</a>
<a name="ln3484">static const struct iwm_rate *</a>
<a name="ln3485">iwm_tx_fill_cmd(struct iwm_softc *sc, struct iwm_node *in,</a>
<a name="ln3486">	struct mbuf *m, struct iwm_tx_cmd *tx)</a>
<a name="ln3487">{</a>
<a name="ln3488">	struct ieee80211_node *ni = &amp;in-&gt;in_ni;</a>
<a name="ln3489">	struct ieee80211_frame *wh;</a>
<a name="ln3490">	const struct ieee80211_txparam *tp = ni-&gt;ni_txparms;</a>
<a name="ln3491">	const struct iwm_rate *rinfo;</a>
<a name="ln3492">	int type;</a>
<a name="ln3493">	int ridx, rate_flags;</a>
<a name="ln3494"> </a>
<a name="ln3495">	wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln3496">	type = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_TYPE_MASK;</a>
<a name="ln3497"> </a>
<a name="ln3498">	tx-&gt;rts_retry_limit = IWM_RTS_DFAULT_RETRY_LIMIT;</a>
<a name="ln3499">	tx-&gt;data_retry_limit = IWM_DEFAULT_TX_RETRY;</a>
<a name="ln3500"> </a>
<a name="ln3501">	if (type == IEEE80211_FC0_TYPE_MGT ||</a>
<a name="ln3502">	    type == IEEE80211_FC0_TYPE_CTL ||</a>
<a name="ln3503">	    (m-&gt;m_flags &amp; M_EAPOL) != 0) {</a>
<a name="ln3504">		ridx = iwm_tx_rateidx_global_lookup(sc, tp-&gt;mgmtrate);</a>
<a name="ln3505">		IWM_DPRINTF(sc, IWM_DEBUG_TXRATE,</a>
<a name="ln3506">		    &quot;%s: MGT (%d)\n&quot;, __func__, tp-&gt;mgmtrate);</a>
<a name="ln3507">	} else if (IEEE80211_IS_MULTICAST(wh-&gt;i_addr1)) {</a>
<a name="ln3508">		ridx = iwm_tx_rateidx_global_lookup(sc, tp-&gt;mcastrate);</a>
<a name="ln3509">		IWM_DPRINTF(sc, IWM_DEBUG_TXRATE,</a>
<a name="ln3510">		    &quot;%s: MCAST (%d)\n&quot;, __func__, tp-&gt;mcastrate);</a>
<a name="ln3511">	} else if (tp-&gt;ucastrate != IEEE80211_FIXED_RATE_NONE) {</a>
<a name="ln3512">		ridx = iwm_tx_rateidx_global_lookup(sc, tp-&gt;ucastrate);</a>
<a name="ln3513">		IWM_DPRINTF(sc, IWM_DEBUG_TXRATE,</a>
<a name="ln3514">		    &quot;%s: FIXED_RATE (%d)\n&quot;, __func__, tp-&gt;ucastrate);</a>
<a name="ln3515">	} else {</a>
<a name="ln3516">		/* for data frames, use RS table */</a>
<a name="ln3517">		IWM_DPRINTF(sc, IWM_DEBUG_TXRATE, &quot;%s: DATA\n&quot;, __func__);</a>
<a name="ln3518">		ridx = iwm_rate2ridx(sc, ni-&gt;ni_txrate);</a>
<a name="ln3519">		if (ridx == -1)</a>
<a name="ln3520">			ridx = 0;</a>
<a name="ln3521"> </a>
<a name="ln3522">		/* This is the index into the programmed table */</a>
<a name="ln3523">		tx-&gt;initial_rate_index = 0;</a>
<a name="ln3524">		tx-&gt;tx_flags |= htole32(IWM_TX_CMD_FLG_STA_RATE);</a>
<a name="ln3525">	}</a>
<a name="ln3526"> </a>
<a name="ln3527">	IWM_DPRINTF(sc, IWM_DEBUG_XMIT | IWM_DEBUG_TXRATE,</a>
<a name="ln3528">	    &quot;%s: frame type=%d txrate %d\n&quot;,</a>
<a name="ln3529">	        __func__, type, iwm_rates[ridx].rate);</a>
<a name="ln3530"> </a>
<a name="ln3531">	rinfo = &amp;iwm_rates[ridx];</a>
<a name="ln3532"> </a>
<a name="ln3533">	IWM_DPRINTF(sc, IWM_DEBUG_TXRATE, &quot;%s: ridx=%d; rate=%d, CCK=%d\n&quot;,</a>
<a name="ln3534">	    __func__, ridx,</a>
<a name="ln3535">	    rinfo-&gt;rate,</a>
<a name="ln3536">	    !! (IWM_RIDX_IS_CCK(ridx))</a>
<a name="ln3537">	    );</a>
<a name="ln3538"> </a>
<a name="ln3539">	/* XXX TODO: hard-coded TX antenna? */</a>
<a name="ln3540">	rate_flags = 1 &lt;&lt; IWM_RATE_MCS_ANT_POS;</a>
<a name="ln3541">	if (IWM_RIDX_IS_CCK(ridx))</a>
<a name="ln3542">		rate_flags |= IWM_RATE_MCS_CCK_MSK;</a>
<a name="ln3543">	tx-&gt;rate_n_flags = htole32(rate_flags | rinfo-&gt;plcp);</a>
<a name="ln3544"> </a>
<a name="ln3545">	return rinfo;</a>
<a name="ln3546">}</a>
<a name="ln3547"> </a>
<a name="ln3548">#define TB0_SIZE 16</a>
<a name="ln3549">static int</a>
<a name="ln3550">iwm_tx(struct iwm_softc *sc, struct mbuf *m, struct ieee80211_node *ni, int ac)</a>
<a name="ln3551">{</a>
<a name="ln3552">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln3553">	struct ieee80211vap *vap = TAILQ_FIRST(&amp;ic-&gt;ic_vaps);</a>
<a name="ln3554">	struct iwm_node *in = IWM_NODE(ni);</a>
<a name="ln3555">	struct iwm_tx_ring *ring;</a>
<a name="ln3556">	struct iwm_tx_data *data;</a>
<a name="ln3557">	struct iwm_tfd *desc;</a>
<a name="ln3558">	struct iwm_device_cmd *cmd;</a>
<a name="ln3559">	struct iwm_tx_cmd *tx;</a>
<a name="ln3560">	struct ieee80211_frame *wh;</a>
<a name="ln3561">	struct ieee80211_key *k = NULL;</a>
<a name="ln3562">	struct mbuf *m1;</a>
<a name="ln3563">	const struct iwm_rate *rinfo;</a>
<a name="ln3564">	uint32_t flags;</a>
<a name="ln3565">	u_int hdrlen;</a>
<a name="ln3566">	bus_dma_segment_t *seg, segs[IWM_MAX_SCATTER];</a>
<a name="ln3567">	int nsegs;</a>
<a name="ln3568">	uint8_t tid, type;</a>
<a name="ln3569">	int i, totlen, error, pad;</a>
<a name="ln3570"> </a>
<a name="ln3571">	wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln3572">	hdrlen = ieee80211_anyhdrsize(wh);</a>
<a name="ln3573">	type = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_TYPE_MASK;</a>
<a name="ln3574">	tid = 0;</a>
<a name="ln3575">	ring = &amp;sc-&gt;txq[ac];</a>
<a name="ln3576">	desc = &amp;ring-&gt;desc[ring-&gt;cur];</a>
<a name="ln3577">	memset(desc, 0, sizeof(*desc));</a>
<a name="ln3578">	data = &amp;ring-&gt;data[ring-&gt;cur];</a>
<a name="ln3579"> </a>
<a name="ln3580">	/* Fill out iwm_tx_cmd to send to the firmware */</a>
<a name="ln3581">	cmd = &amp;ring-&gt;cmd[ring-&gt;cur];</a>
<a name="ln3582">	cmd-&gt;hdr.code = IWM_TX_CMD;</a>
<a name="ln3583">	cmd-&gt;hdr.flags = 0;</a>
<a name="ln3584">	cmd-&gt;hdr.qid = ring-&gt;qid;</a>
<a name="ln3585">	cmd-&gt;hdr.idx = ring-&gt;cur;</a>
<a name="ln3586"> </a>
<a name="ln3587">	tx = (void *)cmd-&gt;data;</a>
<a name="ln3588">	memset(tx, 0, sizeof(*tx));</a>
<a name="ln3589"> </a>
<a name="ln3590">	rinfo = iwm_tx_fill_cmd(sc, in, m, tx);</a>
<a name="ln3591"> </a>
<a name="ln3592">	/* Encrypt the frame if need be. */</a>
<a name="ln3593">	if (wh-&gt;i_fc[1] &amp; IEEE80211_FC1_PROTECTED) {</a>
<a name="ln3594">		/* Retrieve key for TX &amp;&amp; do software encryption. */</a>
<a name="ln3595">		k = ieee80211_crypto_encap(ni, m);</a>
<a name="ln3596">		if (k == NULL) {</a>
<a name="ln3597">			m_freem(m);</a>
<a name="ln3598">			return (ENOBUFS);</a>
<a name="ln3599">		}</a>
<a name="ln3600">		/* 802.11 header may have moved. */</a>
<a name="ln3601">		wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln3602">	}</a>
<a name="ln3603"> </a>
<a name="ln3604">	if (ieee80211_radiotap_active_vap(vap)) {</a>
<a name="ln3605">		struct iwm_tx_radiotap_header *tap = &amp;sc-&gt;sc_txtap;</a>
<a name="ln3606"> </a>
<a name="ln3607">		tap-&gt;wt_flags = 0;</a>
<a name="ln3608">		tap-&gt;wt_chan_freq = htole16(ni-&gt;ni_chan-&gt;ic_freq);</a>
<a name="ln3609">		tap-&gt;wt_chan_flags = htole16(ni-&gt;ni_chan-&gt;ic_flags);</a>
<a name="ln3610">		tap-&gt;wt_rate = rinfo-&gt;rate;</a>
<a name="ln3611">		if (k != NULL)</a>
<a name="ln3612">			tap-&gt;wt_flags |= IEEE80211_RADIOTAP_F_WEP;</a>
<a name="ln3613">		ieee80211_radiotap_tx(vap, m);</a>
<a name="ln3614">	}</a>
<a name="ln3615"> </a>
<a name="ln3616"> </a>
<a name="ln3617">	totlen = m-&gt;m_pkthdr.len;</a>
<a name="ln3618"> </a>
<a name="ln3619">	flags = 0;</a>
<a name="ln3620">	if (!IEEE80211_IS_MULTICAST(wh-&gt;i_addr1)) {</a>
<a name="ln3621">		flags |= IWM_TX_CMD_FLG_ACK;</a>
<a name="ln3622">	}</a>
<a name="ln3623"> </a>
<a name="ln3624">	if (type == IEEE80211_FC0_TYPE_DATA</a>
<a name="ln3625">	    &amp;&amp; (totlen + IEEE80211_CRC_LEN &gt; vap-&gt;iv_rtsthreshold)</a>
<a name="ln3626">	    &amp;&amp; !IEEE80211_IS_MULTICAST(wh-&gt;i_addr1)) {</a>
<a name="ln3627">		flags |= IWM_TX_CMD_FLG_PROT_REQUIRE;</a>
<a name="ln3628">	}</a>
<a name="ln3629"> </a>
<a name="ln3630">	if (IEEE80211_IS_MULTICAST(wh-&gt;i_addr1) ||</a>
<a name="ln3631">	    type != IEEE80211_FC0_TYPE_DATA)</a>
<a name="ln3632">		tx-&gt;sta_id = sc-&gt;sc_aux_sta.sta_id;</a>
<a name="ln3633">	else</a>
<a name="ln3634">		tx-&gt;sta_id = IWM_STATION_ID;</a>
<a name="ln3635"> </a>
<a name="ln3636">	if (type == IEEE80211_FC0_TYPE_MGT) {</a>
<a name="ln3637">		uint8_t subtype = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_SUBTYPE_MASK;</a>
<a name="ln3638"> </a>
<a name="ln3639">		if (subtype == IEEE80211_FC0_SUBTYPE_ASSOC_REQ ||</a>
<a name="ln3640">		    subtype == IEEE80211_FC0_SUBTYPE_REASSOC_REQ) {</a>
<a name="ln3641">			tx-&gt;pm_frame_timeout = htole16(IWM_PM_FRAME_ASSOC);</a>
<a name="ln3642">		} else if (subtype == IEEE80211_FC0_SUBTYPE_ACTION) {</a>
<a name="ln3643">			tx-&gt;pm_frame_timeout = htole16(IWM_PM_FRAME_NONE);</a>
<a name="ln3644">		} else {</a>
<a name="ln3645">			tx-&gt;pm_frame_timeout = htole16(IWM_PM_FRAME_MGMT);</a>
<a name="ln3646">		}</a>
<a name="ln3647">	} else {</a>
<a name="ln3648">		tx-&gt;pm_frame_timeout = htole16(IWM_PM_FRAME_NONE);</a>
<a name="ln3649">	}</a>
<a name="ln3650"> </a>
<a name="ln3651">	if (hdrlen &amp; 3) {</a>
<a name="ln3652">		/* First segment length must be a multiple of 4. */</a>
<a name="ln3653">		flags |= IWM_TX_CMD_FLG_MH_PAD;</a>
<a name="ln3654">		pad = 4 - (hdrlen &amp; 3);</a>
<a name="ln3655">	} else</a>
<a name="ln3656">		pad = 0;</a>
<a name="ln3657"> </a>
<a name="ln3658">	tx-&gt;driver_txop = 0;</a>
<a name="ln3659">	tx-&gt;next_frame_len = 0;</a>
<a name="ln3660"> </a>
<a name="ln3661">	tx-&gt;len = htole16(totlen);</a>
<a name="ln3662">	tx-&gt;tid_tspec = tid;</a>
<a name="ln3663">	tx-&gt;life_time = htole32(IWM_TX_CMD_LIFE_TIME_INFINITE);</a>
<a name="ln3664"> </a>
<a name="ln3665">	/* Set physical address of &quot;scratch area&quot;. */</a>
<a name="ln3666">	tx-&gt;dram_lsb_ptr = htole32(data-&gt;scratch_paddr);</a>
<a name="ln3667">	tx-&gt;dram_msb_ptr = iwm_get_dma_hi_addr(data-&gt;scratch_paddr);</a>
<a name="ln3668"> </a>
<a name="ln3669">	/* Copy 802.11 header in TX command. */</a>
<a name="ln3670">	memcpy(((uint8_t *)tx) + sizeof(*tx), wh, hdrlen);</a>
<a name="ln3671"> </a>
<a name="ln3672">	flags |= IWM_TX_CMD_FLG_BT_DIS | IWM_TX_CMD_FLG_SEQ_CTL;</a>
<a name="ln3673"> </a>
<a name="ln3674">	tx-&gt;sec_ctl = 0;</a>
<a name="ln3675">	tx-&gt;tx_flags |= htole32(flags);</a>
<a name="ln3676"> </a>
<a name="ln3677">	/* Trim 802.11 header. */</a>
<a name="ln3678">	m_adj(m, hdrlen);</a>
<a name="ln3679">	error = bus_dmamap_load_mbuf_sg(ring-&gt;data_dmat, data-&gt;map, m,</a>
<a name="ln3680">	    segs, &amp;nsegs, BUS_DMA_NOWAIT);</a>
<a name="ln3681">	if (error != 0) {</a>
<a name="ln3682">		if (error != EFBIG) {</a>
<a name="ln3683">			device_printf(sc-&gt;sc_dev, &quot;can't map mbuf (error %d)\n&quot;,</a>
<a name="ln3684">			    error);</a>
<a name="ln3685">			m_freem(m);</a>
<a name="ln3686">			return error;</a>
<a name="ln3687">		}</a>
<a name="ln3688">		/* Too many DMA segments, linearize mbuf. */</a>
<a name="ln3689">		m1 = m_collapse(m, M_NOWAIT, IWM_MAX_SCATTER - 2);</a>
<a name="ln3690">		if (m1 == NULL) {</a>
<a name="ln3691">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln3692">			    &quot;%s: could not defrag mbuf\n&quot;, __func__);</a>
<a name="ln3693">			m_freem(m);</a>
<a name="ln3694">			return (ENOBUFS);</a>
<a name="ln3695">		}</a>
<a name="ln3696">		m = m1;</a>
<a name="ln3697"> </a>
<a name="ln3698">		error = bus_dmamap_load_mbuf_sg(ring-&gt;data_dmat, data-&gt;map, m,</a>
<a name="ln3699">		    segs, &amp;nsegs, BUS_DMA_NOWAIT);</a>
<a name="ln3700">		if (error != 0) {</a>
<a name="ln3701">			device_printf(sc-&gt;sc_dev, &quot;can't map mbuf (error %d)\n&quot;,</a>
<a name="ln3702">			    error);</a>
<a name="ln3703">			m_freem(m);</a>
<a name="ln3704">			return error;</a>
<a name="ln3705">		}</a>
<a name="ln3706">	}</a>
<a name="ln3707">	data-&gt;m = m;</a>
<a name="ln3708">	data-&gt;in = in;</a>
<a name="ln3709">	data-&gt;done = 0;</a>
<a name="ln3710"> </a>
<a name="ln3711">	IWM_DPRINTF(sc, IWM_DEBUG_XMIT,</a>
<a name="ln3712">	    &quot;sending txd %p, in %p\n&quot;, data, data-&gt;in);</a>
<a name="ln3713">	KASSERT(data-&gt;in != NULL, (&quot;node is NULL&quot;));</a>
<a name="ln3714"> </a>
<a name="ln3715">	IWM_DPRINTF(sc, IWM_DEBUG_XMIT,</a>
<a name="ln3716">	    &quot;sending data: qid=%d idx=%d len=%d nsegs=%d txflags=0x%08x rate_n_flags=0x%08x rateidx=%u\n&quot;,</a>
<a name="ln3717">	    ring-&gt;qid, ring-&gt;cur, totlen, nsegs,</a>
<a name="ln3718">	    le32toh(tx-&gt;tx_flags),</a>
<a name="ln3719">	    le32toh(tx-&gt;rate_n_flags),</a>
<a name="ln3720">	    tx-&gt;initial_rate_index</a>
<a name="ln3721">	    );</a>
<a name="ln3722"> </a>
<a name="ln3723">	/* Fill TX descriptor. */</a>
<a name="ln3724">	desc-&gt;num_tbs = 2 + nsegs;</a>
<a name="ln3725"> </a>
<a name="ln3726">	desc-&gt;tbs[0].lo = htole32(data-&gt;cmd_paddr);</a>
<a name="ln3727">	desc-&gt;tbs[0].hi_n_len = htole16(iwm_get_dma_hi_addr(data-&gt;cmd_paddr)) |</a>
<a name="ln3728">	    (TB0_SIZE &lt;&lt; 4);</a>
<a name="ln3729">	desc-&gt;tbs[1].lo = htole32(data-&gt;cmd_paddr + TB0_SIZE);</a>
<a name="ln3730">	desc-&gt;tbs[1].hi_n_len = htole16(iwm_get_dma_hi_addr(data-&gt;cmd_paddr)) |</a>
<a name="ln3731">	    ((sizeof(struct iwm_cmd_header) + sizeof(*tx)</a>
<a name="ln3732">	      + hdrlen + pad - TB0_SIZE) &lt;&lt; 4);</a>
<a name="ln3733"> </a>
<a name="ln3734">	/* Other DMA segments are for data payload. */</a>
<a name="ln3735">	for (i = 0; i &lt; nsegs; i++) {</a>
<a name="ln3736">		seg = &amp;segs[i];</a>
<a name="ln3737">		desc-&gt;tbs[i+2].lo = htole32(seg-&gt;ds_addr);</a>
<a name="ln3738">		desc-&gt;tbs[i+2].hi_n_len = \</a>
<a name="ln3739">		    htole16(iwm_get_dma_hi_addr(seg-&gt;ds_addr))</a>
<a name="ln3740">		    | ((seg-&gt;ds_len) &lt;&lt; 4);</a>
<a name="ln3741">	}</a>
<a name="ln3742"> </a>
<a name="ln3743">	bus_dmamap_sync(ring-&gt;data_dmat, data-&gt;map,</a>
<a name="ln3744">	    BUS_DMASYNC_PREWRITE);</a>
<a name="ln3745">	bus_dmamap_sync(ring-&gt;cmd_dma.tag, ring-&gt;cmd_dma.map,</a>
<a name="ln3746">	    BUS_DMASYNC_PREWRITE);</a>
<a name="ln3747">	bus_dmamap_sync(ring-&gt;desc_dma.tag, ring-&gt;desc_dma.map,</a>
<a name="ln3748">	    BUS_DMASYNC_PREWRITE);</a>
<a name="ln3749"> </a>
<a name="ln3750">#if 0</a>
<a name="ln3751">	iwm_update_sched(sc, ring-&gt;qid, ring-&gt;cur, tx-&gt;sta_id, le16toh(tx-&gt;len));</a>
<a name="ln3752">#endif</a>
<a name="ln3753"> </a>
<a name="ln3754">	/* Kick TX ring. */</a>
<a name="ln3755">	ring-&gt;cur = (ring-&gt;cur + 1) % IWM_TX_RING_COUNT;</a>
<a name="ln3756">	IWM_WRITE(sc, IWM_HBUS_TARG_WRPTR, ring-&gt;qid &lt;&lt; 8 | ring-&gt;cur);</a>
<a name="ln3757"> </a>
<a name="ln3758">	/* Mark TX ring as full if we reach a certain threshold. */</a>
<a name="ln3759">	if (++ring-&gt;queued &gt; IWM_TX_RING_HIMARK) {</a>
<a name="ln3760">		sc-&gt;qfullmsk |= 1 &lt;&lt; ring-&gt;qid;</a>
<a name="ln3761">	}</a>
<a name="ln3762"> </a>
<a name="ln3763">	return 0;</a>
<a name="ln3764">}</a>
<a name="ln3765"> </a>
<a name="ln3766">static int</a>
<a name="ln3767">iwm_raw_xmit(struct ieee80211_node *ni, struct mbuf *m,</a>
<a name="ln3768">    const struct ieee80211_bpf_params *params)</a>
<a name="ln3769">{</a>
<a name="ln3770">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln3771">	struct iwm_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln3772">	int error = 0;</a>
<a name="ln3773"> </a>
<a name="ln3774">	IWM_DPRINTF(sc, IWM_DEBUG_XMIT,</a>
<a name="ln3775">	    &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln3776"> </a>
<a name="ln3777">	if ((sc-&gt;sc_flags &amp; IWM_FLAG_HW_INITED) == 0) {</a>
<a name="ln3778">		m_freem(m);</a>
<a name="ln3779">		IWM_DPRINTF(sc, IWM_DEBUG_XMIT,</a>
<a name="ln3780">		    &quot;&lt;-%s not RUNNING\n&quot;, __func__);</a>
<a name="ln3781">		return (ENETDOWN);</a>
<a name="ln3782">        }</a>
<a name="ln3783"> </a>
<a name="ln3784">	IWM_LOCK(sc);</a>
<a name="ln3785">	/* XXX fix this */</a>
<a name="ln3786">        if (params == NULL) {</a>
<a name="ln3787">		error = iwm_tx(sc, m, ni, 0);</a>
<a name="ln3788">	} else {</a>
<a name="ln3789">		error = iwm_tx(sc, m, ni, 0);</a>
<a name="ln3790">	}</a>
<a name="ln3791">	if (sc-&gt;sc_tx_timer == 0)</a>
<a name="ln3792">		callout_reset(&amp;sc-&gt;sc_watchdog_to, hz, iwm_watchdog, sc);</a>
<a name="ln3793">	sc-&gt;sc_tx_timer = 5;</a>
<a name="ln3794">	IWM_UNLOCK(sc);</a>
<a name="ln3795"> </a>
<a name="ln3796">        return (error);</a>
<a name="ln3797">}</a>
<a name="ln3798"> </a>
<a name="ln3799">/*</a>
<a name="ln3800"> * mvm/tx.c</a>
<a name="ln3801"> */</a>
<a name="ln3802"> </a>
<a name="ln3803">/*</a>
<a name="ln3804"> * Note that there are transports that buffer frames before they reach</a>
<a name="ln3805"> * the firmware. This means that after flush_tx_path is called, the</a>
<a name="ln3806"> * queue might not be empty. The race-free way to handle this is to:</a>
<a name="ln3807"> * 1) set the station as draining</a>
<a name="ln3808"> * 2) flush the Tx path</a>
<a name="ln3809"> * 3) wait for the transport queues to be empty</a>
<a name="ln3810"> */</a>
<a name="ln3811">int</a>
<a name="ln3812">iwm_mvm_flush_tx_path(struct iwm_softc *sc, uint32_t tfd_msk, uint32_t flags)</a>
<a name="ln3813">{</a>
<a name="ln3814">	int ret;</a>
<a name="ln3815">	struct iwm_tx_path_flush_cmd flush_cmd = {</a>
<a name="ln3816">		.queues_ctl = htole32(tfd_msk),</a>
<a name="ln3817">		.flush_ctl = htole16(IWM_DUMP_TX_FIFO_FLUSH),</a>
<a name="ln3818">	};</a>
<a name="ln3819"> </a>
<a name="ln3820">	ret = iwm_mvm_send_cmd_pdu(sc, IWM_TXPATH_FLUSH, flags,</a>
<a name="ln3821">	    sizeof(flush_cmd), &amp;flush_cmd);</a>
<a name="ln3822">	if (ret)</a>
<a name="ln3823">                device_printf(sc-&gt;sc_dev,</a>
<a name="ln3824">		    &quot;Flushing tx queue failed: %d\n&quot;, ret);</a>
<a name="ln3825">	return ret;</a>
<a name="ln3826">}</a>
<a name="ln3827"> </a>
<a name="ln3828">/*</a>
<a name="ln3829"> * BEGIN mvm/quota.c</a>
<a name="ln3830"> */</a>
<a name="ln3831"> </a>
<a name="ln3832">static int</a>
<a name="ln3833">iwm_mvm_update_quotas(struct iwm_softc *sc, struct iwm_vap *ivp)</a>
<a name="ln3834">{</a>
<a name="ln3835">	struct iwm_time_quota_cmd cmd;</a>
<a name="ln3836">	int i, idx, ret, num_active_macs, quota, quota_rem;</a>
<a name="ln3837">	int colors[IWM_MAX_BINDINGS] = { -1, -1, -1, -1, };</a>
<a name="ln3838">	int n_ifs[IWM_MAX_BINDINGS] = {0, };</a>
<a name="ln3839">	uint16_t id;</a>
<a name="ln3840"> </a>
<a name="ln3841">	memset(&amp;cmd, 0, sizeof(cmd));</a>
<a name="ln3842"> </a>
<a name="ln3843">	/* currently, PHY ID == binding ID */</a>
<a name="ln3844">	if (ivp) {</a>
<a name="ln3845">		id = ivp-&gt;phy_ctxt-&gt;id;</a>
<a name="ln3846">		KASSERT(id &lt; IWM_MAX_BINDINGS, (&quot;invalid id&quot;));</a>
<a name="ln3847">		colors[id] = ivp-&gt;phy_ctxt-&gt;color;</a>
<a name="ln3848"> </a>
<a name="ln3849">		if (1)</a>
<a name="ln3850">			n_ifs[id] = 1;</a>
<a name="ln3851">	}</a>
<a name="ln3852"> </a>
<a name="ln3853">	/*</a>
<a name="ln3854">	 * The FW's scheduling session consists of</a>
<a name="ln3855">	 * IWM_MVM_MAX_QUOTA fragments. Divide these fragments</a>
<a name="ln3856">	 * equally between all the bindings that require quota</a>
<a name="ln3857">	 */</a>
<a name="ln3858">	num_active_macs = 0;</a>
<a name="ln3859">	for (i = 0; i &lt; IWM_MAX_BINDINGS; i++) {</a>
<a name="ln3860">		cmd.quotas[i].id_and_color = htole32(IWM_FW_CTXT_INVALID);</a>
<a name="ln3861">		num_active_macs += n_ifs[i];</a>
<a name="ln3862">	}</a>
<a name="ln3863"> </a>
<a name="ln3864">	quota = 0;</a>
<a name="ln3865">	quota_rem = 0;</a>
<a name="ln3866">	if (num_active_macs) {</a>
<a name="ln3867">		quota = IWM_MVM_MAX_QUOTA / num_active_macs;</a>
<a name="ln3868">		quota_rem = IWM_MVM_MAX_QUOTA % num_active_macs;</a>
<a name="ln3869">	}</a>
<a name="ln3870"> </a>
<a name="ln3871">	for (idx = 0, i = 0; i &lt; IWM_MAX_BINDINGS; i++) {</a>
<a name="ln3872">		if (colors[i] &lt; 0)</a>
<a name="ln3873">			continue;</a>
<a name="ln3874"> </a>
<a name="ln3875">		cmd.quotas[idx].id_and_color =</a>
<a name="ln3876">			htole32(IWM_FW_CMD_ID_AND_COLOR(i, colors[i]));</a>
<a name="ln3877"> </a>
<a name="ln3878">		if (n_ifs[i] &lt;= 0) {</a>
<a name="ln3879">			cmd.quotas[idx].quota = htole32(0);</a>
<a name="ln3880">			cmd.quotas[idx].max_duration = htole32(0);</a>
<a name="ln3881">		} else {</a>
<a name="ln3882">			cmd.quotas[idx].quota = htole32(quota * n_ifs[i]);</a>
<a name="ln3883">			cmd.quotas[idx].max_duration = htole32(0);</a>
<a name="ln3884">		}</a>
<a name="ln3885">		idx++;</a>
<a name="ln3886">	}</a>
<a name="ln3887"> </a>
<a name="ln3888">	/* Give the remainder of the session to the first binding */</a>
<a name="ln3889">	cmd.quotas[0].quota = htole32(le32toh(cmd.quotas[0].quota) + quota_rem);</a>
<a name="ln3890"> </a>
<a name="ln3891">	ret = iwm_mvm_send_cmd_pdu(sc, IWM_TIME_QUOTA_CMD, IWM_CMD_SYNC,</a>
<a name="ln3892">	    sizeof(cmd), &amp;cmd);</a>
<a name="ln3893">	if (ret)</a>
<a name="ln3894">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln3895">		    &quot;%s: Failed to send quota: %d\n&quot;, __func__, ret);</a>
<a name="ln3896">	return ret;</a>
<a name="ln3897">}</a>
<a name="ln3898"> </a>
<a name="ln3899">/*</a>
<a name="ln3900"> * END mvm/quota.c</a>
<a name="ln3901"> */</a>
<a name="ln3902"> </a>
<a name="ln3903">/*</a>
<a name="ln3904"> * ieee80211 routines</a>
<a name="ln3905"> */</a>
<a name="ln3906"> </a>
<a name="ln3907">/*</a>
<a name="ln3908"> * Change to AUTH state in 80211 state machine.  Roughly matches what</a>
<a name="ln3909"> * Linux does in bss_info_changed().</a>
<a name="ln3910"> */</a>
<a name="ln3911">static int</a>
<a name="ln3912">iwm_auth(struct ieee80211vap *vap, struct iwm_softc *sc)</a>
<a name="ln3913">{</a>
<a name="ln3914">	struct ieee80211_node *ni;</a>
<a name="ln3915">	struct iwm_node *in;</a>
<a name="ln3916">	struct iwm_vap *iv = IWM_VAP(vap);</a>
<a name="ln3917">	uint32_t duration;</a>
<a name="ln3918">	int error;</a>
<a name="ln3919"> </a>
<a name="ln3920">	/*</a>
<a name="ln3921">	 * XXX i have a feeling that the vap node is being</a>
<a name="ln3922">	 * freed from underneath us. Grr.</a>
<a name="ln3923">	 */</a>
<a name="ln3924">	ni = ieee80211_ref_node(vap-&gt;iv_bss);</a>
<a name="ln3925">	in = IWM_NODE(ni);</a>
<a name="ln3926">	IWM_DPRINTF(sc, IWM_DEBUG_RESET | IWM_DEBUG_STATE,</a>
<a name="ln3927">	    &quot;%s: called; vap=%p, bss ni=%p\n&quot;,</a>
<a name="ln3928">	    __func__,</a>
<a name="ln3929">	    vap,</a>
<a name="ln3930">	    ni);</a>
<a name="ln3931">	IWM_DPRINTF(sc, IWM_DEBUG_STATE, &quot;%s: Current node bssid: %s\n&quot;,</a>
<a name="ln3932">	    __func__, ether_sprintf(ni-&gt;ni_bssid));</a>
<a name="ln3933"> </a>
<a name="ln3934">	in-&gt;in_assoc = 0;</a>
<a name="ln3935">	iv-&gt;iv_auth = 1;</a>
<a name="ln3936"> </a>
<a name="ln3937">	/*</a>
<a name="ln3938">	 * Firmware bug - it'll crash if the beacon interval is less</a>
<a name="ln3939">	 * than 16. We can't avoid connecting at all, so refuse the</a>
<a name="ln3940">	 * station state change, this will cause net80211 to abandon</a>
<a name="ln3941">	 * attempts to connect to this AP, and eventually wpa_s will</a>
<a name="ln3942">	 * blacklist the AP...</a>
<a name="ln3943">	 */</a>
<a name="ln3944">	if (ni-&gt;ni_intval &lt; 16) {</a>
<a name="ln3945">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln3946">		    &quot;AP %s beacon interval is %d, refusing due to firmware bug!\n&quot;,</a>
<a name="ln3947">		    ether_sprintf(ni-&gt;ni_bssid), ni-&gt;ni_intval);</a>
<a name="ln3948">		error = EINVAL;</a>
<a name="ln3949">		goto out;</a>
<a name="ln3950">	}</a>
<a name="ln3951"> </a>
<a name="ln3952">	error = iwm_allow_mcast(vap, sc);</a>
<a name="ln3953">	if (error) {</a>
<a name="ln3954">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln3955">		    &quot;%s: failed to set multicast\n&quot;, __func__);</a>
<a name="ln3956">		goto out;</a>
<a name="ln3957">	}</a>
<a name="ln3958"> </a>
<a name="ln3959">	/*</a>
<a name="ln3960">	 * This is where it deviates from what Linux does.</a>
<a name="ln3961">	 *</a>
<a name="ln3962">	 * Linux iwlwifi doesn't reset the nic each time, nor does it</a>
<a name="ln3963">	 * call ctxt_add() here.  Instead, it adds it during vap creation,</a>
<a name="ln3964">	 * and always does a mac_ctx_changed().</a>
<a name="ln3965">	 *</a>
<a name="ln3966">	 * The openbsd port doesn't attempt to do that - it reset things</a>
<a name="ln3967">	 * at odd states and does the add here.</a>
<a name="ln3968">	 *</a>
<a name="ln3969">	 * So, until the state handling is fixed (ie, we never reset</a>
<a name="ln3970">	 * the NIC except for a firmware failure, which should drag</a>
<a name="ln3971">	 * the NIC back to IDLE, re-setup and re-add all the mac/phy</a>
<a name="ln3972">	 * contexts that are required), let's do a dirty hack here.</a>
<a name="ln3973">	 */</a>
<a name="ln3974">	if (iv-&gt;is_uploaded) {</a>
<a name="ln3975">		if ((error = iwm_mvm_mac_ctxt_changed(sc, vap)) != 0) {</a>
<a name="ln3976">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln3977">			    &quot;%s: failed to update MAC\n&quot;, __func__);</a>
<a name="ln3978">			goto out;</a>
<a name="ln3979">		}</a>
<a name="ln3980">	} else {</a>
<a name="ln3981">		if ((error = iwm_mvm_mac_ctxt_add(sc, vap)) != 0) {</a>
<a name="ln3982">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln3983">			    &quot;%s: failed to add MAC\n&quot;, __func__);</a>
<a name="ln3984">			goto out;</a>
<a name="ln3985">		}</a>
<a name="ln3986">	}</a>
<a name="ln3987">	sc-&gt;sc_firmware_state = 1;</a>
<a name="ln3988"> </a>
<a name="ln3989">	if ((error = iwm_mvm_phy_ctxt_changed(sc, &amp;sc-&gt;sc_phyctxt[0],</a>
<a name="ln3990">	    in-&gt;in_ni.ni_chan, 1, 1)) != 0) {</a>
<a name="ln3991">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln3992">		    &quot;%s: failed update phy ctxt\n&quot;, __func__);</a>
<a name="ln3993">		goto out;</a>
<a name="ln3994">	}</a>
<a name="ln3995">	iv-&gt;phy_ctxt = &amp;sc-&gt;sc_phyctxt[0];</a>
<a name="ln3996"> </a>
<a name="ln3997">	if ((error = iwm_mvm_binding_add_vif(sc, iv)) != 0) {</a>
<a name="ln3998">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln3999">		    &quot;%s: binding update cmd\n&quot;, __func__);</a>
<a name="ln4000">		goto out;</a>
<a name="ln4001">	}</a>
<a name="ln4002">	sc-&gt;sc_firmware_state = 2;</a>
<a name="ln4003">	/*</a>
<a name="ln4004">	 * Authentication becomes unreliable when powersaving is left enabled</a>
<a name="ln4005">	 * here. Powersaving will be activated again when association has</a>
<a name="ln4006">	 * finished or is aborted.</a>
<a name="ln4007">	 */</a>
<a name="ln4008">	iv-&gt;ps_disabled = TRUE;</a>
<a name="ln4009">	error = iwm_mvm_power_update_mac(sc);</a>
<a name="ln4010">	iv-&gt;ps_disabled = FALSE;</a>
<a name="ln4011">	if (error != 0) {</a>
<a name="ln4012">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln4013">		    &quot;%s: failed to update power management\n&quot;,</a>
<a name="ln4014">		    __func__);</a>
<a name="ln4015">		goto out;</a>
<a name="ln4016">	}</a>
<a name="ln4017">	if ((error = iwm_mvm_add_sta(sc, in)) != 0) {</a>
<a name="ln4018">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln4019">		    &quot;%s: failed to add sta\n&quot;, __func__);</a>
<a name="ln4020">		goto out;</a>
<a name="ln4021">	}</a>
<a name="ln4022">	sc-&gt;sc_firmware_state = 3;</a>
<a name="ln4023"> </a>
<a name="ln4024">	/*</a>
<a name="ln4025">	 * Prevent the FW from wandering off channel during association</a>
<a name="ln4026">	 * by &quot;protecting&quot; the session with a time event.</a>
<a name="ln4027">	 */</a>
<a name="ln4028">	/* XXX duration is in units of TU, not MS */</a>
<a name="ln4029">	duration = IWM_MVM_TE_SESSION_PROTECTION_MAX_TIME_MS;</a>
<a name="ln4030">	iwm_mvm_protect_session(sc, iv, duration, 500 /* XXX magic number */, TRUE);</a>
<a name="ln4031"> </a>
<a name="ln4032">	error = 0;</a>
<a name="ln4033">out:</a>
<a name="ln4034">	if (error != 0)</a>
<a name="ln4035">		iv-&gt;iv_auth = 0;</a>
<a name="ln4036">	ieee80211_free_node(ni);</a>
<a name="ln4037">	return (error);</a>
<a name="ln4038">}</a>
<a name="ln4039"> </a>
<a name="ln4040">static struct ieee80211_node *</a>
<a name="ln4041">iwm_node_alloc(struct ieee80211vap *vap, const uint8_t mac[IEEE80211_ADDR_LEN])</a>
<a name="ln4042">{</a>
<a name="ln4043">	return malloc(sizeof (struct iwm_node), M_80211_NODE,</a>
<a name="ln4044">	    M_NOWAIT | M_ZERO);</a>
<a name="ln4045">}</a>
<a name="ln4046"> </a>
<a name="ln4047">static uint8_t</a>
<a name="ln4048">iwm_rate_from_ucode_rate(uint32_t rate_n_flags)</a>
<a name="ln4049">{</a>
<a name="ln4050">	uint8_t plcp = rate_n_flags &amp; 0xff;</a>
<a name="ln4051">	int i;</a>
<a name="ln4052"> </a>
<a name="ln4053">	for (i = 0; i &lt;= IWM_RIDX_MAX; i++) {</a>
<a name="ln4054">		if (iwm_rates[i].plcp == plcp)</a>
<a name="ln4055">			return iwm_rates[i].rate;</a>
<a name="ln4056">	}</a>
<a name="ln4057">	return 0;</a>
<a name="ln4058">}</a>
<a name="ln4059"> </a>
<a name="ln4060">uint8_t</a>
<a name="ln4061">iwm_ridx2rate(struct ieee80211_rateset *rs, int ridx)</a>
<a name="ln4062">{</a>
<a name="ln4063">	int i;</a>
<a name="ln4064">	uint8_t rval;</a>
<a name="ln4065"> </a>
<a name="ln4066">	for (i = 0; i &lt; rs-&gt;rs_nrates; i++) {</a>
<a name="ln4067">		rval = (rs-&gt;rs_rates[i] &amp; IEEE80211_RATE_VAL);</a>
<a name="ln4068">		if (rval == iwm_rates[ridx].rate)</a>
<a name="ln4069">			return rs-&gt;rs_rates[i];</a>
<a name="ln4070">	}</a>
<a name="ln4071"> </a>
<a name="ln4072">	return 0;</a>
<a name="ln4073">}</a>
<a name="ln4074"> </a>
<a name="ln4075">static int</a>
<a name="ln4076">iwm_rate2ridx(struct iwm_softc *sc, uint8_t rate)</a>
<a name="ln4077">{</a>
<a name="ln4078">	int i;</a>
<a name="ln4079"> </a>
<a name="ln4080">	for (i = 0; i &lt;= IWM_RIDX_MAX; i++) {</a>
<a name="ln4081">		if (iwm_rates[i].rate == rate)</a>
<a name="ln4082">			return i;</a>
<a name="ln4083">	}</a>
<a name="ln4084"> </a>
<a name="ln4085">	device_printf(sc-&gt;sc_dev,</a>
<a name="ln4086">	    &quot;%s: WARNING: device rate for %u not found!\n&quot;,</a>
<a name="ln4087">	    __func__, rate);</a>
<a name="ln4088"> </a>
<a name="ln4089">	return -1;</a>
<a name="ln4090">}</a>
<a name="ln4091"> </a>
<a name="ln4092"> </a>
<a name="ln4093">static void</a>
<a name="ln4094">iwm_setrates(struct iwm_softc *sc, struct iwm_node *in, int rix)</a>
<a name="ln4095">{</a>
<a name="ln4096">	struct ieee80211_node *ni = &amp;in-&gt;in_ni;</a>
<a name="ln4097">	struct iwm_lq_cmd *lq = &amp;in-&gt;in_lq;</a>
<a name="ln4098">	struct ieee80211_rateset *rs = &amp;ni-&gt;ni_rates;</a>
<a name="ln4099">	int nrates = rs-&gt;rs_nrates;</a>
<a name="ln4100">	int i, ridx, tab = 0;</a>
<a name="ln4101">//	int txant = 0;</a>
<a name="ln4102"> </a>
<a name="ln4103">	KASSERT(rix &gt;= 0 &amp;&amp; rix &lt; nrates, (&quot;invalid rix&quot;));</a>
<a name="ln4104"> </a>
<a name="ln4105">	if (nrates &gt; nitems(lq-&gt;rs_table)) {</a>
<a name="ln4106">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln4107">		    &quot;%s: node supports %d rates, driver handles &quot;</a>
<a name="ln4108">		    &quot;only %zu\n&quot;, __func__, nrates, nitems(lq-&gt;rs_table));</a>
<a name="ln4109">		return;</a>
<a name="ln4110">	}</a>
<a name="ln4111">	if (nrates == 0) {</a>
<a name="ln4112">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln4113">		    &quot;%s: node supports 0 rates, odd!\n&quot;, __func__);</a>
<a name="ln4114">		return;</a>
<a name="ln4115">	}</a>
<a name="ln4116">	nrates = imin(rix + 1, nrates);</a>
<a name="ln4117"> </a>
<a name="ln4118">	IWM_DPRINTF(sc, IWM_DEBUG_TXRATE,</a>
<a name="ln4119">	    &quot;%s: nrates=%d\n&quot;, __func__, nrates);</a>
<a name="ln4120"> </a>
<a name="ln4121">	/* then construct a lq_cmd based on those */</a>
<a name="ln4122">	memset(lq, 0, sizeof(*lq));</a>
<a name="ln4123">	lq-&gt;sta_id = IWM_STATION_ID;</a>
<a name="ln4124"> </a>
<a name="ln4125">	/* For HT, always enable RTS/CTS to avoid excessive retries. */</a>
<a name="ln4126">	if (ni-&gt;ni_flags &amp; IEEE80211_NODE_HT)</a>
<a name="ln4127">		lq-&gt;flags |= IWM_LQ_FLAG_USE_RTS_MSK;</a>
<a name="ln4128"> </a>
<a name="ln4129">	/*</a>
<a name="ln4130">	 * are these used? (we don't do SISO or MIMO)</a>
<a name="ln4131">	 * need to set them to non-zero, though, or we get an error.</a>
<a name="ln4132">	 */</a>
<a name="ln4133">	lq-&gt;single_stream_ant_msk = 1;</a>
<a name="ln4134">	lq-&gt;dual_stream_ant_msk = 1;</a>
<a name="ln4135"> </a>
<a name="ln4136">	/*</a>
<a name="ln4137">	 * Build the actual rate selection table.</a>
<a name="ln4138">	 * The lowest bits are the rates.  Additionally,</a>
<a name="ln4139">	 * CCK needs bit 9 to be set.  The rest of the bits</a>
<a name="ln4140">	 * we add to the table select the tx antenna</a>
<a name="ln4141">	 * Note that we add the rates in the highest rate first</a>
<a name="ln4142">	 * (opposite of ni_rates).</a>
<a name="ln4143">	 */</a>
<a name="ln4144">	for (i = 0; i &lt; nrates; i++) {</a>
<a name="ln4145">		int rate = rs-&gt;rs_rates[rix - i] &amp; IEEE80211_RATE_VAL;</a>
<a name="ln4146">		int nextant;</a>
<a name="ln4147"> </a>
<a name="ln4148">		/* Map 802.11 rate to HW rate index. */</a>
<a name="ln4149">		ridx = iwm_rate2ridx(sc, rate);</a>
<a name="ln4150">		if (ridx == -1)</a>
<a name="ln4151">			continue;</a>
<a name="ln4152"> </a>
<a name="ln4153">#if 0</a>
<a name="ln4154">		if (txant == 0)</a>
<a name="ln4155">			txant = iwm_mvm_get_valid_tx_ant(sc);</a>
<a name="ln4156">		nextant = 1&lt;&lt;(ffs(txant)-1);</a>
<a name="ln4157">		txant &amp;= ~nextant;</a>
<a name="ln4158">#else</a>
<a name="ln4159">		nextant = iwm_mvm_get_valid_tx_ant(sc);</a>
<a name="ln4160">#endif</a>
<a name="ln4161">		tab = iwm_rates[ridx].plcp;</a>
<a name="ln4162">		tab |= nextant &lt;&lt; IWM_RATE_MCS_ANT_POS;</a>
<a name="ln4163">		if (IWM_RIDX_IS_CCK(ridx))</a>
<a name="ln4164">			tab |= IWM_RATE_MCS_CCK_MSK;</a>
<a name="ln4165">		IWM_DPRINTF(sc, IWM_DEBUG_TXRATE,</a>
<a name="ln4166">		    &quot;station rate i=%d, rate=%d, hw=%x\n&quot;,</a>
<a name="ln4167">		    i, iwm_rates[ridx].rate, tab);</a>
<a name="ln4168">		lq-&gt;rs_table[i] = htole32(tab);</a>
<a name="ln4169">	}</a>
<a name="ln4170">	/* then fill the rest with the lowest possible rate */</a>
<a name="ln4171">	for (i = nrates; i &lt; nitems(lq-&gt;rs_table); i++) {</a>
<a name="ln4172">		KASSERT(tab != 0, (&quot;invalid tab&quot;));</a>
<a name="ln4173">		lq-&gt;rs_table[i] = htole32(tab);</a>
<a name="ln4174">	}</a>
<a name="ln4175">}</a>
<a name="ln4176"> </a>
<a name="ln4177">static int</a>
<a name="ln4178">iwm_media_change(struct ifnet *ifp)</a>
<a name="ln4179">{</a>
<a name="ln4180">	struct ieee80211vap *vap = ifp-&gt;if_softc;</a>
<a name="ln4181">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln4182">	struct iwm_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln4183">	int error;</a>
<a name="ln4184"> </a>
<a name="ln4185">	error = ieee80211_media_change(ifp);</a>
<a name="ln4186">	if (error != ENETRESET)</a>
<a name="ln4187">		return error;</a>
<a name="ln4188"> </a>
<a name="ln4189">	IWM_LOCK(sc);</a>
<a name="ln4190">	if (ic-&gt;ic_nrunning &gt; 0) {</a>
<a name="ln4191">		iwm_stop(sc);</a>
<a name="ln4192">		iwm_init(sc);</a>
<a name="ln4193">	}</a>
<a name="ln4194">	IWM_UNLOCK(sc);</a>
<a name="ln4195">	return error;</a>
<a name="ln4196">}</a>
<a name="ln4197"> </a>
<a name="ln4198">static void</a>
<a name="ln4199">iwm_bring_down_firmware(struct iwm_softc *sc, struct ieee80211vap *vap)</a>
<a name="ln4200">{</a>
<a name="ln4201">	struct iwm_vap *ivp = IWM_VAP(vap);</a>
<a name="ln4202">	int error;</a>
<a name="ln4203"> </a>
<a name="ln4204">	/* Avoid Tx watchdog triggering, when transfers get dropped here. */</a>
<a name="ln4205">	sc-&gt;sc_tx_timer = 0;</a>
<a name="ln4206"> </a>
<a name="ln4207">	ivp-&gt;iv_auth = 0;</a>
<a name="ln4208">	if (sc-&gt;sc_firmware_state == 3) {</a>
<a name="ln4209">		iwm_xmit_queue_drain(sc);</a>
<a name="ln4210">//		iwm_mvm_flush_tx_path(sc, 0xf, IWM_CMD_SYNC);</a>
<a name="ln4211">		error = iwm_mvm_rm_sta(sc, vap, TRUE);</a>
<a name="ln4212">		if (error) {</a>
<a name="ln4213">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln4214">			    &quot;%s: Failed to remove station: %d\n&quot;,</a>
<a name="ln4215">			    __func__, error);</a>
<a name="ln4216">		}</a>
<a name="ln4217">	}</a>
<a name="ln4218">	if (sc-&gt;sc_firmware_state == 3) {</a>
<a name="ln4219">		error = iwm_mvm_mac_ctxt_changed(sc, vap);</a>
<a name="ln4220">		if (error) {</a>
<a name="ln4221">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln4222">			    &quot;%s: Failed to change mac context: %d\n&quot;,</a>
<a name="ln4223">			    __func__, error);</a>
<a name="ln4224">		}</a>
<a name="ln4225">	}</a>
<a name="ln4226">	if (sc-&gt;sc_firmware_state == 3) {</a>
<a name="ln4227">		error = iwm_mvm_sf_update(sc, vap, FALSE);</a>
<a name="ln4228">		if (error) {</a>
<a name="ln4229">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln4230">			    &quot;%s: Failed to update smart FIFO: %d\n&quot;,</a>
<a name="ln4231">			    __func__, error);</a>
<a name="ln4232">		}</a>
<a name="ln4233">	}</a>
<a name="ln4234">	if (sc-&gt;sc_firmware_state == 3) {</a>
<a name="ln4235">		error = iwm_mvm_rm_sta_id(sc, vap);</a>
<a name="ln4236">		if (error) {</a>
<a name="ln4237">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln4238">			    &quot;%s: Failed to remove station id: %d\n&quot;,</a>
<a name="ln4239">			    __func__, error);</a>
<a name="ln4240">		}</a>
<a name="ln4241">	}</a>
<a name="ln4242">	if (sc-&gt;sc_firmware_state == 3) {</a>
<a name="ln4243">		error = iwm_mvm_update_quotas(sc, NULL);</a>
<a name="ln4244">		if (error) {</a>
<a name="ln4245">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln4246">			    &quot;%s: Failed to update PHY quota: %d\n&quot;,</a>
<a name="ln4247">			    __func__, error);</a>
<a name="ln4248">		}</a>
<a name="ln4249">	}</a>
<a name="ln4250">	if (sc-&gt;sc_firmware_state == 3) {</a>
<a name="ln4251">		/* XXX Might need to specify bssid correctly. */</a>
<a name="ln4252">		error = iwm_mvm_mac_ctxt_changed(sc, vap);</a>
<a name="ln4253">		if (error) {</a>
<a name="ln4254">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln4255">			    &quot;%s: Failed to change mac context: %d\n&quot;,</a>
<a name="ln4256">			    __func__, error);</a>
<a name="ln4257">		}</a>
<a name="ln4258">	}</a>
<a name="ln4259">	if (sc-&gt;sc_firmware_state == 3) {</a>
<a name="ln4260">		sc-&gt;sc_firmware_state = 2;</a>
<a name="ln4261">	}</a>
<a name="ln4262">	if (sc-&gt;sc_firmware_state &gt; 1) {</a>
<a name="ln4263">		error = iwm_mvm_binding_remove_vif(sc, ivp);</a>
<a name="ln4264">		if (error) {</a>
<a name="ln4265">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln4266">			    &quot;%s: Failed to remove channel ctx: %d\n&quot;,</a>
<a name="ln4267">			    __func__, error);</a>
<a name="ln4268">		}</a>
<a name="ln4269">	}</a>
<a name="ln4270">	if (sc-&gt;sc_firmware_state &gt; 1) {</a>
<a name="ln4271">		sc-&gt;sc_firmware_state = 1;</a>
<a name="ln4272">	}</a>
<a name="ln4273">	ivp-&gt;phy_ctxt = NULL;</a>
<a name="ln4274">	if (sc-&gt;sc_firmware_state &gt; 0) {</a>
<a name="ln4275">		error = iwm_mvm_mac_ctxt_changed(sc, vap);</a>
<a name="ln4276">		if (error) {</a>
<a name="ln4277">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln4278">			    &quot;%s: Failed to change mac context: %d\n&quot;,</a>
<a name="ln4279">			    __func__, error);</a>
<a name="ln4280">		}</a>
<a name="ln4281">	}</a>
<a name="ln4282">	if (sc-&gt;sc_firmware_state &gt; 0) {</a>
<a name="ln4283">		error = iwm_mvm_power_update_mac(sc);</a>
<a name="ln4284">		if (error != 0) {</a>
<a name="ln4285">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln4286">			    &quot;%s: failed to update power management\n&quot;,</a>
<a name="ln4287">			    __func__);</a>
<a name="ln4288">		}</a>
<a name="ln4289">	}</a>
<a name="ln4290">	sc-&gt;sc_firmware_state = 0;</a>
<a name="ln4291">}</a>
<a name="ln4292"> </a>
<a name="ln4293">static int</a>
<a name="ln4294">iwm_newstate(struct ieee80211vap *vap, enum ieee80211_state nstate, int arg)</a>
<a name="ln4295">{</a>
<a name="ln4296">	struct iwm_vap *ivp = IWM_VAP(vap);</a>
<a name="ln4297">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln4298">	struct iwm_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln4299">	struct iwm_node *in;</a>
<a name="ln4300">	int error;</a>
<a name="ln4301"> </a>
<a name="ln4302">	IWM_DPRINTF(sc, IWM_DEBUG_STATE,</a>
<a name="ln4303">	    &quot;switching state %s -&gt; %s arg=0x%x\n&quot;,</a>
<a name="ln4304">	    ieee80211_state_name[vap-&gt;iv_state],</a>
<a name="ln4305">	    ieee80211_state_name[nstate],</a>
<a name="ln4306">	    arg);</a>
<a name="ln4307"> </a>
<a name="ln4308">	IEEE80211_UNLOCK(ic);</a>
<a name="ln4309">	IWM_LOCK(sc);</a>
<a name="ln4310"> </a>
<a name="ln4311">	if ((sc-&gt;sc_flags &amp; IWM_FLAG_SCAN_RUNNING) &amp;&amp;</a>
<a name="ln4312">	    (nstate == IEEE80211_S_AUTH ||</a>
<a name="ln4313">	     nstate == IEEE80211_S_ASSOC ||</a>
<a name="ln4314">	     nstate == IEEE80211_S_RUN)) {</a>
<a name="ln4315">		/* Stop blinking for a scan, when authenticating. */</a>
<a name="ln4316">		iwm_led_blink_stop(sc);</a>
<a name="ln4317">	}</a>
<a name="ln4318"> </a>
<a name="ln4319">	if (vap-&gt;iv_state == IEEE80211_S_RUN &amp;&amp; nstate != IEEE80211_S_RUN) {</a>
<a name="ln4320">		iwm_mvm_led_disable(sc);</a>
<a name="ln4321">		/* disable beacon filtering if we're hopping out of RUN */</a>
<a name="ln4322">		iwm_mvm_disable_beacon_filter(sc);</a>
<a name="ln4323">		if (((in = IWM_NODE(vap-&gt;iv_bss)) != NULL))</a>
<a name="ln4324">			in-&gt;in_assoc = 0;</a>
<a name="ln4325">	}</a>
<a name="ln4326"> </a>
<a name="ln4327">	if ((vap-&gt;iv_state == IEEE80211_S_AUTH ||</a>
<a name="ln4328">	     vap-&gt;iv_state == IEEE80211_S_ASSOC ||</a>
<a name="ln4329">	     vap-&gt;iv_state == IEEE80211_S_RUN) &amp;&amp;</a>
<a name="ln4330">	    (nstate == IEEE80211_S_INIT ||</a>
<a name="ln4331">	     nstate == IEEE80211_S_SCAN ||</a>
<a name="ln4332">	     nstate == IEEE80211_S_AUTH)) {</a>
<a name="ln4333">		iwm_mvm_stop_session_protection(sc, ivp);</a>
<a name="ln4334">	}</a>
<a name="ln4335"> </a>
<a name="ln4336">	if ((vap-&gt;iv_state == IEEE80211_S_RUN ||</a>
<a name="ln4337">	     vap-&gt;iv_state == IEEE80211_S_ASSOC) &amp;&amp;</a>
<a name="ln4338">	    nstate == IEEE80211_S_INIT) {</a>
<a name="ln4339">		/*</a>
<a name="ln4340">		 * In this case, iv_newstate() wants to send an 80211 frame on</a>
<a name="ln4341">		 * the network that we are leaving. So we need to call it,</a>
<a name="ln4342">		 * before tearing down all the firmware state.</a>
<a name="ln4343">		 */</a>
<a name="ln4344">		IWM_UNLOCK(sc);</a>
<a name="ln4345">		IEEE80211_LOCK(ic);</a>
<a name="ln4346">		ivp-&gt;iv_newstate(vap, nstate, arg);</a>
<a name="ln4347">		IEEE80211_UNLOCK(ic);</a>
<a name="ln4348">		IWM_LOCK(sc);</a>
<a name="ln4349">		iwm_bring_down_firmware(sc, vap);</a>
<a name="ln4350">		IWM_UNLOCK(sc);</a>
<a name="ln4351">		IEEE80211_LOCK(ic);</a>
<a name="ln4352">		return 0;</a>
<a name="ln4353">	}</a>
<a name="ln4354"> </a>
<a name="ln4355">	switch (nstate) {</a>
<a name="ln4356">	case IEEE80211_S_INIT:</a>
<a name="ln4357">	case IEEE80211_S_SCAN:</a>
<a name="ln4358">		break;</a>
<a name="ln4359"> </a>
<a name="ln4360">	case IEEE80211_S_AUTH:</a>
<a name="ln4361">		iwm_bring_down_firmware(sc, vap);</a>
<a name="ln4362">		if ((error = iwm_auth(vap, sc)) != 0) {</a>
<a name="ln4363">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln4364">			    &quot;%s: could not move to auth state: %d\n&quot;,</a>
<a name="ln4365">			    __func__, error);</a>
<a name="ln4366">			iwm_bring_down_firmware(sc, vap);</a>
<a name="ln4367">			IWM_UNLOCK(sc);</a>
<a name="ln4368">			IEEE80211_LOCK(ic);</a>
<a name="ln4369">			return 1;</a>
<a name="ln4370">		}</a>
<a name="ln4371">		break;</a>
<a name="ln4372"> </a>
<a name="ln4373">	case IEEE80211_S_ASSOC:</a>
<a name="ln4374">		/*</a>
<a name="ln4375">		 * EBS may be disabled due to previous failures reported by FW.</a>
<a name="ln4376">		 * Reset EBS status here assuming environment has been changed.</a>
<a name="ln4377">		 */</a>
<a name="ln4378">		sc-&gt;last_ebs_successful = TRUE;</a>
<a name="ln4379">		break;</a>
<a name="ln4380"> </a>
<a name="ln4381">	case IEEE80211_S_RUN:</a>
<a name="ln4382">		in = IWM_NODE(vap-&gt;iv_bss);</a>
<a name="ln4383">		/* Update the association state, now we have it all */</a>
<a name="ln4384">		/* (eg associd comes in at this point */</a>
<a name="ln4385">		error = iwm_mvm_update_sta(sc, in);</a>
<a name="ln4386">		if (error != 0) {</a>
<a name="ln4387">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln4388">			    &quot;%s: failed to update STA\n&quot;, __func__);</a>
<a name="ln4389">			IWM_UNLOCK(sc);</a>
<a name="ln4390">			IEEE80211_LOCK(ic);</a>
<a name="ln4391">			return error;</a>
<a name="ln4392">		}</a>
<a name="ln4393">		in-&gt;in_assoc = 1;</a>
<a name="ln4394">		error = iwm_mvm_mac_ctxt_changed(sc, vap);</a>
<a name="ln4395">		if (error != 0) {</a>
<a name="ln4396">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln4397">			    &quot;%s: failed to update MAC: %d\n&quot;, __func__, error);</a>
<a name="ln4398">		}</a>
<a name="ln4399"> </a>
<a name="ln4400">		iwm_mvm_sf_update(sc, vap, FALSE);</a>
<a name="ln4401">		iwm_mvm_enable_beacon_filter(sc, ivp);</a>
<a name="ln4402">		iwm_mvm_power_update_mac(sc);</a>
<a name="ln4403">		iwm_mvm_update_quotas(sc, ivp);</a>
<a name="ln4404">		{</a>
<a name="ln4405">		int rix = ieee80211_ratectl_rate(&amp;in-&gt;in_ni, NULL, 0);</a>
<a name="ln4406">		iwm_setrates(sc, in, rix);</a>
<a name="ln4407"> </a>
<a name="ln4408">		if ((error = iwm_mvm_send_lq_cmd(sc, &amp;in-&gt;in_lq, TRUE)) != 0) {</a>
<a name="ln4409">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln4410">			    &quot;%s: IWM_LQ_CMD failed: %d\n&quot;, __func__, error);</a>
<a name="ln4411">		}</a>
<a name="ln4412"> </a>
<a name="ln4413">		iwm_mvm_led_enable(sc);</a>
<a name="ln4414">		}</a>
<a name="ln4415">		break;</a>
<a name="ln4416"> </a>
<a name="ln4417">	default:</a>
<a name="ln4418">		break;</a>
<a name="ln4419">	}</a>
<a name="ln4420">	IWM_UNLOCK(sc);</a>
<a name="ln4421">	IEEE80211_LOCK(ic);</a>
<a name="ln4422"> </a>
<a name="ln4423">	return (ivp-&gt;iv_newstate(vap, nstate, arg));</a>
<a name="ln4424">}</a>
<a name="ln4425"> </a>
<a name="ln4426">void</a>
<a name="ln4427">iwm_endscan_cb(void *arg, int pending)</a>
<a name="ln4428">{</a>
<a name="ln4429">	struct iwm_softc *sc = arg;</a>
<a name="ln4430">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln4431"> </a>
<a name="ln4432">	IWM_DPRINTF(sc, IWM_DEBUG_SCAN | IWM_DEBUG_TRACE,</a>
<a name="ln4433">	    &quot;%s: scan ended\n&quot;,</a>
<a name="ln4434">	    __func__);</a>
<a name="ln4435"> </a>
<a name="ln4436">	ieee80211_scan_done(TAILQ_FIRST(&amp;ic-&gt;ic_vaps));</a>
<a name="ln4437">}</a>
<a name="ln4438"> </a>
<a name="ln4439">static int</a>
<a name="ln4440">iwm_send_bt_init_conf(struct iwm_softc *sc)</a>
<a name="ln4441">{</a>
<a name="ln4442">	struct iwm_bt_coex_cmd bt_cmd;</a>
<a name="ln4443"> </a>
<a name="ln4444">	bt_cmd.mode = htole32(IWM_BT_COEX_WIFI);</a>
<a name="ln4445">	bt_cmd.enabled_modules = htole32(IWM_BT_COEX_HIGH_BAND_RET);</a>
<a name="ln4446"> </a>
<a name="ln4447">	return iwm_mvm_send_cmd_pdu(sc, IWM_BT_CONFIG, 0, sizeof(bt_cmd),</a>
<a name="ln4448">	    &amp;bt_cmd);</a>
<a name="ln4449">}</a>
<a name="ln4450"> </a>
<a name="ln4451">static boolean_t</a>
<a name="ln4452">iwm_mvm_is_lar_supported(struct iwm_softc *sc)</a>
<a name="ln4453">{</a>
<a name="ln4454">	boolean_t nvm_lar = sc-&gt;nvm_data-&gt;lar_enabled;</a>
<a name="ln4455">	boolean_t tlv_lar = fw_has_capa(&amp;sc-&gt;sc_fw.ucode_capa,</a>
<a name="ln4456">					IWM_UCODE_TLV_CAPA_LAR_SUPPORT);</a>
<a name="ln4457"> </a>
<a name="ln4458">	if (iwm_lar_disable)</a>
<a name="ln4459">		return FALSE;</a>
<a name="ln4460"> </a>
<a name="ln4461">	/*</a>
<a name="ln4462">	 * Enable LAR only if it is supported by the FW (TLV) &amp;&amp;</a>
<a name="ln4463">	 * enabled in the NVM</a>
<a name="ln4464">	 */</a>
<a name="ln4465">	if (sc-&gt;cfg-&gt;device_family == IWM_DEVICE_FAMILY_8000)</a>
<a name="ln4466">		return nvm_lar &amp;&amp; tlv_lar;</a>
<a name="ln4467">	else</a>
<a name="ln4468">		return tlv_lar;</a>
<a name="ln4469">}</a>
<a name="ln4470"> </a>
<a name="ln4471">static boolean_t</a>
<a name="ln4472">iwm_mvm_is_wifi_mcc_supported(struct iwm_softc *sc)</a>
<a name="ln4473">{</a>
<a name="ln4474">	return fw_has_api(&amp;sc-&gt;sc_fw.ucode_capa,</a>
<a name="ln4475">			  IWM_UCODE_TLV_API_WIFI_MCC_UPDATE) ||</a>
<a name="ln4476">	       fw_has_capa(&amp;sc-&gt;sc_fw.ucode_capa,</a>
<a name="ln4477">			   IWM_UCODE_TLV_CAPA_LAR_MULTI_MCC);</a>
<a name="ln4478">}</a>
<a name="ln4479"> </a>
<a name="ln4480">static int</a>
<a name="ln4481">iwm_send_update_mcc_cmd(struct iwm_softc *sc, const char *alpha2)</a>
<a name="ln4482">{</a>
<a name="ln4483">	struct iwm_mcc_update_cmd mcc_cmd;</a>
<a name="ln4484">	struct iwm_host_cmd hcmd = {</a>
<a name="ln4485">		.id = IWM_MCC_UPDATE_CMD,</a>
<a name="ln4486">		.flags = (IWM_CMD_SYNC | IWM_CMD_WANT_SKB),</a>
<a name="ln4487">		.data = { &amp;mcc_cmd },</a>
<a name="ln4488">	};</a>
<a name="ln4489">	int ret;</a>
<a name="ln4490">#ifdef IWM_DEBUG</a>
<a name="ln4491">	struct iwm_rx_packet *pkt;</a>
<a name="ln4492">	struct iwm_mcc_update_resp_v1 *mcc_resp_v1 = NULL;</a>
<a name="ln4493">	struct iwm_mcc_update_resp *mcc_resp;</a>
<a name="ln4494">	int n_channels;</a>
<a name="ln4495">	uint16_t mcc;</a>
<a name="ln4496">#endif</a>
<a name="ln4497">	int resp_v2 = fw_has_capa(&amp;sc-&gt;sc_fw.ucode_capa,</a>
<a name="ln4498">	    IWM_UCODE_TLV_CAPA_LAR_SUPPORT_V2);</a>
<a name="ln4499"> </a>
<a name="ln4500">	if (!iwm_mvm_is_lar_supported(sc)) {</a>
<a name="ln4501">		IWM_DPRINTF(sc, IWM_DEBUG_LAR, &quot;%s: no LAR support\n&quot;,</a>
<a name="ln4502">		    __func__);</a>
<a name="ln4503">		return 0;</a>
<a name="ln4504">	}</a>
<a name="ln4505"> </a>
<a name="ln4506">	memset(&amp;mcc_cmd, 0, sizeof(mcc_cmd));</a>
<a name="ln4507">	mcc_cmd.mcc = htole16(alpha2[0] &lt;&lt; 8 | alpha2[1]);</a>
<a name="ln4508">	if (iwm_mvm_is_wifi_mcc_supported(sc))</a>
<a name="ln4509">		mcc_cmd.source_id = IWM_MCC_SOURCE_GET_CURRENT;</a>
<a name="ln4510">	else</a>
<a name="ln4511">		mcc_cmd.source_id = IWM_MCC_SOURCE_OLD_FW;</a>
<a name="ln4512"> </a>
<a name="ln4513">	if (resp_v2)</a>
<a name="ln4514">		hcmd.len[0] = sizeof(struct iwm_mcc_update_cmd);</a>
<a name="ln4515">	else</a>
<a name="ln4516">		hcmd.len[0] = sizeof(struct iwm_mcc_update_cmd_v1);</a>
<a name="ln4517"> </a>
<a name="ln4518">	IWM_DPRINTF(sc, IWM_DEBUG_LAR,</a>
<a name="ln4519">	    &quot;send MCC update to FW with '%c%c' src = %d\n&quot;,</a>
<a name="ln4520">	    alpha2[0], alpha2[1], mcc_cmd.source_id);</a>
<a name="ln4521"> </a>
<a name="ln4522">	ret = iwm_send_cmd(sc, &amp;hcmd);</a>
<a name="ln4523">	if (ret)</a>
<a name="ln4524">		return ret;</a>
<a name="ln4525"> </a>
<a name="ln4526">#ifdef IWM_DEBUG</a>
<a name="ln4527">	pkt = hcmd.resp_pkt;</a>
<a name="ln4528"> </a>
<a name="ln4529">	/* Extract MCC response */</a>
<a name="ln4530">	if (resp_v2) {</a>
<a name="ln4531">		mcc_resp = (void *)pkt-&gt;data;</a>
<a name="ln4532">		mcc = mcc_resp-&gt;mcc;</a>
<a name="ln4533">		n_channels =  le32toh(mcc_resp-&gt;n_channels);</a>
<a name="ln4534">	} else {</a>
<a name="ln4535">		mcc_resp_v1 = (void *)pkt-&gt;data;</a>
<a name="ln4536">		mcc = mcc_resp_v1-&gt;mcc;</a>
<a name="ln4537">		n_channels =  le32toh(mcc_resp_v1-&gt;n_channels);</a>
<a name="ln4538">	}</a>
<a name="ln4539"> </a>
<a name="ln4540">	/* W/A for a FW/NVM issue - returns 0x00 for the world domain */</a>
<a name="ln4541">	if (mcc == 0)</a>
<a name="ln4542">		mcc = 0x3030;  /* &quot;00&quot; - world */</a>
<a name="ln4543"> </a>
<a name="ln4544">	IWM_DPRINTF(sc, IWM_DEBUG_LAR,</a>
<a name="ln4545">	    &quot;regulatory domain '%c%c' (%d channels available)\n&quot;,</a>
<a name="ln4546">	    mcc &gt;&gt; 8, mcc &amp; 0xff, n_channels);</a>
<a name="ln4547">#endif</a>
<a name="ln4548">	iwm_free_resp(sc, &amp;hcmd);</a>
<a name="ln4549"> </a>
<a name="ln4550">	return 0;</a>
<a name="ln4551">}</a>
<a name="ln4552"> </a>
<a name="ln4553">static void</a>
<a name="ln4554">iwm_mvm_tt_tx_backoff(struct iwm_softc *sc, uint32_t backoff)</a>
<a name="ln4555">{</a>
<a name="ln4556">	struct iwm_host_cmd cmd = {</a>
<a name="ln4557">		.id = IWM_REPLY_THERMAL_MNG_BACKOFF,</a>
<a name="ln4558">		.len = { sizeof(uint32_t), },</a>
<a name="ln4559">		.data = { &amp;backoff, },</a>
<a name="ln4560">	};</a>
<a name="ln4561"> </a>
<a name="ln4562">	if (iwm_send_cmd(sc, &amp;cmd) != 0) {</a>
<a name="ln4563">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln4564">		    &quot;failed to change thermal tx backoff\n&quot;);</a>
<a name="ln4565">	}</a>
<a name="ln4566">}</a>
<a name="ln4567"> </a>
<a name="ln4568">static int</a>
<a name="ln4569">iwm_init_hw(struct iwm_softc *sc)</a>
<a name="ln4570">{</a>
<a name="ln4571">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln4572">	int error, i, ac;</a>
<a name="ln4573"> </a>
<a name="ln4574">	sc-&gt;sf_state = IWM_SF_UNINIT;</a>
<a name="ln4575"> </a>
<a name="ln4576">	if ((error = iwm_start_hw(sc)) != 0) {</a>
<a name="ln4577">		printf(&quot;iwm_start_hw: failed %d\n&quot;, error);</a>
<a name="ln4578">		return error;</a>
<a name="ln4579">	}</a>
<a name="ln4580"> </a>
<a name="ln4581">	if ((error = iwm_run_init_mvm_ucode(sc, 0)) != 0) {</a>
<a name="ln4582">		printf(&quot;iwm_run_init_mvm_ucode: failed %d\n&quot;, error);</a>
<a name="ln4583">		return error;</a>
<a name="ln4584">	}</a>
<a name="ln4585"> </a>
<a name="ln4586">	/*</a>
<a name="ln4587">	 * should stop and start HW since that INIT</a>
<a name="ln4588">	 * image just loaded</a>
<a name="ln4589">	 */</a>
<a name="ln4590">	iwm_stop_device(sc);</a>
<a name="ln4591">	sc-&gt;sc_ps_disabled = FALSE;</a>
<a name="ln4592">	if ((error = iwm_start_hw(sc)) != 0) {</a>
<a name="ln4593">		device_printf(sc-&gt;sc_dev, &quot;could not initialize hardware\n&quot;);</a>
<a name="ln4594">		return error;</a>
<a name="ln4595">	}</a>
<a name="ln4596"> </a>
<a name="ln4597">	/* omstart, this time with the regular firmware */</a>
<a name="ln4598">	error = iwm_mvm_load_ucode_wait_alive(sc, IWM_UCODE_REGULAR);</a>
<a name="ln4599">	if (error) {</a>
<a name="ln4600">		device_printf(sc-&gt;sc_dev, &quot;could not load firmware\n&quot;);</a>
<a name="ln4601">		goto error;</a>
<a name="ln4602">	}</a>
<a name="ln4603"> </a>
<a name="ln4604">	error = iwm_mvm_sf_update(sc, NULL, FALSE);</a>
<a name="ln4605">	if (error)</a>
<a name="ln4606">		device_printf(sc-&gt;sc_dev, &quot;Failed to initialize Smart Fifo\n&quot;);</a>
<a name="ln4607"> </a>
<a name="ln4608">	if ((error = iwm_send_bt_init_conf(sc)) != 0) {</a>
<a name="ln4609">		device_printf(sc-&gt;sc_dev, &quot;bt init conf failed\n&quot;);</a>
<a name="ln4610">		goto error;</a>
<a name="ln4611">	}</a>
<a name="ln4612"> </a>
<a name="ln4613">	error = iwm_send_tx_ant_cfg(sc, iwm_mvm_get_valid_tx_ant(sc));</a>
<a name="ln4614">	if (error != 0) {</a>
<a name="ln4615">		device_printf(sc-&gt;sc_dev, &quot;antenna config failed\n&quot;);</a>
<a name="ln4616">		goto error;</a>
<a name="ln4617">	}</a>
<a name="ln4618"> </a>
<a name="ln4619">	/* Send phy db control command and then phy db calibration */</a>
<a name="ln4620">	if ((error = iwm_send_phy_db_data(sc-&gt;sc_phy_db)) != 0)</a>
<a name="ln4621">		goto error;</a>
<a name="ln4622"> </a>
<a name="ln4623">	if ((error = iwm_send_phy_cfg_cmd(sc)) != 0) {</a>
<a name="ln4624">		device_printf(sc-&gt;sc_dev, &quot;phy_cfg_cmd failed\n&quot;);</a>
<a name="ln4625">		goto error;</a>
<a name="ln4626">	}</a>
<a name="ln4627"> </a>
<a name="ln4628">	/* Add auxiliary station for scanning */</a>
<a name="ln4629">	if ((error = iwm_mvm_add_aux_sta(sc)) != 0) {</a>
<a name="ln4630">		device_printf(sc-&gt;sc_dev, &quot;add_aux_sta failed\n&quot;);</a>
<a name="ln4631">		goto error;</a>
<a name="ln4632">	}</a>
<a name="ln4633"> </a>
<a name="ln4634">	for (i = 0; i &lt; IWM_NUM_PHY_CTX; i++) {</a>
<a name="ln4635">		/*</a>
<a name="ln4636">		 * The channel used here isn't relevant as it's</a>
<a name="ln4637">		 * going to be overwritten in the other flows.</a>
<a name="ln4638">		 * For now use the first channel we have.</a>
<a name="ln4639">		 */</a>
<a name="ln4640">		if ((error = iwm_mvm_phy_ctxt_add(sc,</a>
<a name="ln4641">		    &amp;sc-&gt;sc_phyctxt[i], &amp;ic-&gt;ic_channels[1], 1, 1)) != 0)</a>
<a name="ln4642">			goto error;</a>
<a name="ln4643">	}</a>
<a name="ln4644"> </a>
<a name="ln4645">	/* Initialize tx backoffs to the minimum. */</a>
<a name="ln4646">	if (sc-&gt;cfg-&gt;device_family == IWM_DEVICE_FAMILY_7000)</a>
<a name="ln4647">		iwm_mvm_tt_tx_backoff(sc, 0);</a>
<a name="ln4648"> </a>
<a name="ln4649">	if (iwm_mvm_config_ltr(sc) != 0)</a>
<a name="ln4650">		device_printf(sc-&gt;sc_dev, &quot;PCIe LTR configuration failed\n&quot;);</a>
<a name="ln4651"> </a>
<a name="ln4652">	error = iwm_mvm_power_update_device(sc);</a>
<a name="ln4653">	if (error)</a>
<a name="ln4654">		goto error;</a>
<a name="ln4655"> </a>
<a name="ln4656">	if ((error = iwm_send_update_mcc_cmd(sc, &quot;ZZ&quot;)) != 0)</a>
<a name="ln4657">		goto error;</a>
<a name="ln4658"> </a>
<a name="ln4659">	if (fw_has_capa(&amp;sc-&gt;sc_fw.ucode_capa, IWM_UCODE_TLV_CAPA_UMAC_SCAN)) {</a>
<a name="ln4660">		if ((error = iwm_mvm_config_umac_scan(sc)) != 0)</a>
<a name="ln4661">			goto error;</a>
<a name="ln4662">	}</a>
<a name="ln4663"> </a>
<a name="ln4664">	/* Enable Tx queues. */</a>
<a name="ln4665">	for (ac = 0; ac &lt; WME_NUM_AC; ac++) {</a>
<a name="ln4666">		error = iwm_enable_txq(sc, IWM_STATION_ID, ac,</a>
<a name="ln4667">		    iwm_mvm_ac_to_tx_fifo[ac]);</a>
<a name="ln4668">		if (error)</a>
<a name="ln4669">			goto error;</a>
<a name="ln4670">	}</a>
<a name="ln4671"> </a>
<a name="ln4672">	if ((error = iwm_mvm_disable_beacon_filter(sc)) != 0) {</a>
<a name="ln4673">		device_printf(sc-&gt;sc_dev, &quot;failed to disable beacon filter\n&quot;);</a>
<a name="ln4674">		goto error;</a>
<a name="ln4675">	}</a>
<a name="ln4676"> </a>
<a name="ln4677">	return 0;</a>
<a name="ln4678"> </a>
<a name="ln4679"> error:</a>
<a name="ln4680">	iwm_stop_device(sc);</a>
<a name="ln4681">	return error;</a>
<a name="ln4682">}</a>
<a name="ln4683"> </a>
<a name="ln4684">/* Allow multicast from our BSSID. */</a>
<a name="ln4685">static int</a>
<a name="ln4686">iwm_allow_mcast(struct ieee80211vap *vap, struct iwm_softc *sc)</a>
<a name="ln4687">{</a>
<a name="ln4688">	struct ieee80211_node *ni = vap-&gt;iv_bss;</a>
<a name="ln4689">	struct iwm_mcast_filter_cmd *cmd;</a>
<a name="ln4690">	size_t size;</a>
<a name="ln4691">	int error;</a>
<a name="ln4692"> </a>
<a name="ln4693">	size = roundup(sizeof(*cmd), 4);</a>
<a name="ln4694">	cmd = malloc(size, M_DEVBUF, M_NOWAIT | M_ZERO);</a>
<a name="ln4695">	if (cmd == NULL)</a>
<a name="ln4696">		return ENOMEM;</a>
<a name="ln4697">	cmd-&gt;filter_own = 1;</a>
<a name="ln4698">	cmd-&gt;port_id = 0;</a>
<a name="ln4699">	cmd-&gt;count = 0;</a>
<a name="ln4700">	cmd-&gt;pass_all = 1;</a>
<a name="ln4701">	IEEE80211_ADDR_COPY(cmd-&gt;bssid, ni-&gt;ni_bssid);</a>
<a name="ln4702"> </a>
<a name="ln4703">	error = iwm_mvm_send_cmd_pdu(sc, IWM_MCAST_FILTER_CMD,</a>
<a name="ln4704">	    IWM_CMD_SYNC, size, cmd);</a>
<a name="ln4705">	free(cmd, M_DEVBUF);</a>
<a name="ln4706"> </a>
<a name="ln4707">	return (error);</a>
<a name="ln4708">}</a>
<a name="ln4709"> </a>
<a name="ln4710">/*</a>
<a name="ln4711"> * ifnet interfaces</a>
<a name="ln4712"> */</a>
<a name="ln4713"> </a>
<a name="ln4714">static void</a>
<a name="ln4715">iwm_init(struct iwm_softc *sc)</a>
<a name="ln4716">{</a>
<a name="ln4717">	int error;</a>
<a name="ln4718"> </a>
<a name="ln4719">	if (sc-&gt;sc_flags &amp; IWM_FLAG_HW_INITED) {</a>
<a name="ln4720">		return;</a>
<a name="ln4721">	}</a>
<a name="ln4722">	sc-&gt;sc_generation++;</a>
<a name="ln4723">	sc-&gt;sc_flags &amp;= ~IWM_FLAG_STOPPED;</a>
<a name="ln4724"> </a>
<a name="ln4725">	if ((error = iwm_init_hw(sc)) != 0) {</a>
<a name="ln4726">		printf(&quot;iwm_init_hw failed %d\n&quot;, error);</a>
<a name="ln4727">		iwm_stop(sc);</a>
<a name="ln4728">		return;</a>
<a name="ln4729">	}</a>
<a name="ln4730"> </a>
<a name="ln4731">	/*</a>
<a name="ln4732">	 * Ok, firmware loaded and we are jogging</a>
<a name="ln4733">	 */</a>
<a name="ln4734">	sc-&gt;sc_flags |= IWM_FLAG_HW_INITED;</a>
<a name="ln4735">}</a>
<a name="ln4736"> </a>
<a name="ln4737">static int</a>
<a name="ln4738">iwm_transmit(struct ieee80211com *ic, struct mbuf *m)</a>
<a name="ln4739">{</a>
<a name="ln4740">	struct iwm_softc *sc;</a>
<a name="ln4741">	int error;</a>
<a name="ln4742"> </a>
<a name="ln4743">	sc = ic-&gt;ic_softc;</a>
<a name="ln4744"> </a>
<a name="ln4745">	IWM_LOCK(sc);</a>
<a name="ln4746">	if ((sc-&gt;sc_flags &amp; IWM_FLAG_HW_INITED) == 0) {</a>
<a name="ln4747">		IWM_UNLOCK(sc);</a>
<a name="ln4748">		return (ENXIO);</a>
<a name="ln4749">	}</a>
<a name="ln4750">	error = mbufq_enqueue(&amp;sc-&gt;sc_snd, m);</a>
<a name="ln4751">	if (error) {</a>
<a name="ln4752">		IWM_UNLOCK(sc);</a>
<a name="ln4753">		return (error);</a>
<a name="ln4754">	}</a>
<a name="ln4755">	iwm_start(sc);</a>
<a name="ln4756">	IWM_UNLOCK(sc);</a>
<a name="ln4757">	return (0);</a>
<a name="ln4758">}</a>
<a name="ln4759"> </a>
<a name="ln4760">/*</a>
<a name="ln4761"> * Dequeue packets from sendq and call send.</a>
<a name="ln4762"> */</a>
<a name="ln4763">static void</a>
<a name="ln4764">iwm_start(struct iwm_softc *sc)</a>
<a name="ln4765">{</a>
<a name="ln4766">	struct ieee80211_node *ni;</a>
<a name="ln4767">	struct mbuf *m;</a>
<a name="ln4768">	int ac = 0;</a>
<a name="ln4769"> </a>
<a name="ln4770">	IWM_DPRINTF(sc, IWM_DEBUG_XMIT | IWM_DEBUG_TRACE, &quot;-&gt;%s\n&quot;, __func__);</a>
<a name="ln4771">	while (sc-&gt;qfullmsk == 0 &amp;&amp;</a>
<a name="ln4772">		(m = mbufq_dequeue(&amp;sc-&gt;sc_snd)) != NULL) {</a>
<a name="ln4773">		ni = (struct ieee80211_node *)m-&gt;m_pkthdr.rcvif;</a>
<a name="ln4774">		if (iwm_tx(sc, m, ni, ac) != 0) {</a>
<a name="ln4775">			if_inc_counter(ni-&gt;ni_vap-&gt;iv_ifp,</a>
<a name="ln4776">			    IFCOUNTER_OERRORS, 1);</a>
<a name="ln4777">			ieee80211_free_node(ni);</a>
<a name="ln4778">			continue;</a>
<a name="ln4779">		}</a>
<a name="ln4780">		if (sc-&gt;sc_tx_timer == 0) {</a>
<a name="ln4781">			callout_reset(&amp;sc-&gt;sc_watchdog_to, hz, iwm_watchdog,</a>
<a name="ln4782">			    sc);</a>
<a name="ln4783">		}</a>
<a name="ln4784">		sc-&gt;sc_tx_timer = 15;</a>
<a name="ln4785">	}</a>
<a name="ln4786">	IWM_DPRINTF(sc, IWM_DEBUG_XMIT | IWM_DEBUG_TRACE, &quot;&lt;-%s\n&quot;, __func__);</a>
<a name="ln4787">}</a>
<a name="ln4788"> </a>
<a name="ln4789">static void</a>
<a name="ln4790">iwm_stop(struct iwm_softc *sc)</a>
<a name="ln4791">{</a>
<a name="ln4792"> </a>
<a name="ln4793">	sc-&gt;sc_flags &amp;= ~IWM_FLAG_HW_INITED;</a>
<a name="ln4794">	sc-&gt;sc_flags |= IWM_FLAG_STOPPED;</a>
<a name="ln4795">	sc-&gt;sc_generation++;</a>
<a name="ln4796">	iwm_led_blink_stop(sc);</a>
<a name="ln4797">	sc-&gt;sc_tx_timer = 0;</a>
<a name="ln4798">	iwm_stop_device(sc);</a>
<a name="ln4799">	sc-&gt;sc_flags &amp;= ~IWM_FLAG_SCAN_RUNNING;</a>
<a name="ln4800">}</a>
<a name="ln4801"> </a>
<a name="ln4802">static void</a>
<a name="ln4803">iwm_watchdog(void *arg)</a>
<a name="ln4804">{</a>
<a name="ln4805">	struct iwm_softc *sc = arg;</a>
<a name="ln4806">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln4807"> </a>
<a name="ln4808">	if (sc-&gt;sc_attached == 0)</a>
<a name="ln4809">		return;</a>
<a name="ln4810"> </a>
<a name="ln4811">	if (sc-&gt;sc_tx_timer &gt; 0) {</a>
<a name="ln4812">		if (--sc-&gt;sc_tx_timer == 0) {</a>
<a name="ln4813">			device_printf(sc-&gt;sc_dev, &quot;device timeout\n&quot;);</a>
<a name="ln4814">#ifdef IWM_DEBUG</a>
<a name="ln4815">			iwm_nic_error(sc);</a>
<a name="ln4816">#endif</a>
<a name="ln4817">			ieee80211_restart_all(ic);</a>
<a name="ln4818">			counter_u64_add(sc-&gt;sc_ic.ic_oerrors, 1);</a>
<a name="ln4819">			return;</a>
<a name="ln4820">		}</a>
<a name="ln4821">		callout_reset(&amp;sc-&gt;sc_watchdog_to, hz, iwm_watchdog, sc);</a>
<a name="ln4822">	}</a>
<a name="ln4823">}</a>
<a name="ln4824"> </a>
<a name="ln4825">static void</a>
<a name="ln4826">iwm_parent(struct ieee80211com *ic)</a>
<a name="ln4827">{</a>
<a name="ln4828">	struct iwm_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln4829">	int startall = 0;</a>
<a name="ln4830"> </a>
<a name="ln4831">	IWM_LOCK(sc);</a>
<a name="ln4832">	if (ic-&gt;ic_nrunning &gt; 0) {</a>
<a name="ln4833">		if (!(sc-&gt;sc_flags &amp; IWM_FLAG_HW_INITED)) {</a>
<a name="ln4834">			iwm_init(sc);</a>
<a name="ln4835">			startall = 1;</a>
<a name="ln4836">		}</a>
<a name="ln4837">	} else if (sc-&gt;sc_flags &amp; IWM_FLAG_HW_INITED)</a>
<a name="ln4838">		iwm_stop(sc);</a>
<a name="ln4839">	IWM_UNLOCK(sc);</a>
<a name="ln4840">	if (startall)</a>
<a name="ln4841">		ieee80211_start_all(ic);</a>
<a name="ln4842">}</a>
<a name="ln4843"> </a>
<a name="ln4844">/*</a>
<a name="ln4845"> * The interrupt side of things</a>
<a name="ln4846"> */</a>
<a name="ln4847"> </a>
<a name="ln4848">/*</a>
<a name="ln4849"> * error dumping routines are from iwlwifi/mvm/utils.c</a>
<a name="ln4850"> */</a>
<a name="ln4851"> </a>
<a name="ln4852">/*</a>
<a name="ln4853"> * Note: This structure is read from the device with IO accesses,</a>
<a name="ln4854"> * and the reading already does the endian conversion. As it is</a>
<a name="ln4855"> * read with uint32_t-sized accesses, any members with a different size</a>
<a name="ln4856"> * need to be ordered correctly though!</a>
<a name="ln4857"> */</a>
<a name="ln4858">struct iwm_error_event_table {</a>
<a name="ln4859">	uint32_t valid;		/* (nonzero) valid, (0) log is empty */</a>
<a name="ln4860">	uint32_t error_id;		/* type of error */</a>
<a name="ln4861">	uint32_t trm_hw_status0;	/* TRM HW status */</a>
<a name="ln4862">	uint32_t trm_hw_status1;	/* TRM HW status */</a>
<a name="ln4863">	uint32_t blink2;		/* branch link */</a>
<a name="ln4864">	uint32_t ilink1;		/* interrupt link */</a>
<a name="ln4865">	uint32_t ilink2;		/* interrupt link */</a>
<a name="ln4866">	uint32_t data1;		/* error-specific data */</a>
<a name="ln4867">	uint32_t data2;		/* error-specific data */</a>
<a name="ln4868">	uint32_t data3;		/* error-specific data */</a>
<a name="ln4869">	uint32_t bcon_time;		/* beacon timer */</a>
<a name="ln4870">	uint32_t tsf_low;		/* network timestamp function timer */</a>
<a name="ln4871">	uint32_t tsf_hi;		/* network timestamp function timer */</a>
<a name="ln4872">	uint32_t gp1;		/* GP1 timer register */</a>
<a name="ln4873">	uint32_t gp2;		/* GP2 timer register */</a>
<a name="ln4874">	uint32_t fw_rev_type;	/* firmware revision type */</a>
<a name="ln4875">	uint32_t major;		/* uCode version major */</a>
<a name="ln4876">	uint32_t minor;		/* uCode version minor */</a>
<a name="ln4877">	uint32_t hw_ver;		/* HW Silicon version */</a>
<a name="ln4878">	uint32_t brd_ver;		/* HW board version */</a>
<a name="ln4879">	uint32_t log_pc;		/* log program counter */</a>
<a name="ln4880">	uint32_t frame_ptr;		/* frame pointer */</a>
<a name="ln4881">	uint32_t stack_ptr;		/* stack pointer */</a>
<a name="ln4882">	uint32_t hcmd;		/* last host command header */</a>
<a name="ln4883">	uint32_t isr0;		/* isr status register LMPM_NIC_ISR0:</a>
<a name="ln4884">				 * rxtx_flag */</a>
<a name="ln4885">	uint32_t isr1;		/* isr status register LMPM_NIC_ISR1:</a>
<a name="ln4886">				 * host_flag */</a>
<a name="ln4887">	uint32_t isr2;		/* isr status register LMPM_NIC_ISR2:</a>
<a name="ln4888">				 * enc_flag */</a>
<a name="ln4889">	uint32_t isr3;		/* isr status register LMPM_NIC_ISR3:</a>
<a name="ln4890">				 * time_flag */</a>
<a name="ln4891">	uint32_t isr4;		/* isr status register LMPM_NIC_ISR4:</a>
<a name="ln4892">				 * wico interrupt */</a>
<a name="ln4893">	uint32_t last_cmd_id;	/* last HCMD id handled by the firmware */</a>
<a name="ln4894">	uint32_t wait_event;		/* wait event() caller address */</a>
<a name="ln4895">	uint32_t l2p_control;	/* L2pControlField */</a>
<a name="ln4896">	uint32_t l2p_duration;	/* L2pDurationField */</a>
<a name="ln4897">	uint32_t l2p_mhvalid;	/* L2pMhValidBits */</a>
<a name="ln4898">	uint32_t l2p_addr_match;	/* L2pAddrMatchStat */</a>
<a name="ln4899">	uint32_t lmpm_pmg_sel;	/* indicate which clocks are turned on</a>
<a name="ln4900">				 * (LMPM_PMG_SEL) */</a>
<a name="ln4901">	uint32_t u_timestamp;	/* indicate when the date and time of the</a>
<a name="ln4902">				 * compilation */</a>
<a name="ln4903">	uint32_t flow_handler;	/* FH read/write pointers, RX credit */</a>
<a name="ln4904">} __packed /* LOG_ERROR_TABLE_API_S_VER_3 */;</a>
<a name="ln4905"> </a>
<a name="ln4906">/*</a>
<a name="ln4907"> * UMAC error struct - relevant starting from family 8000 chip.</a>
<a name="ln4908"> * Note: This structure is read from the device with IO accesses,</a>
<a name="ln4909"> * and the reading already does the endian conversion. As it is</a>
<a name="ln4910"> * read with u32-sized accesses, any members with a different size</a>
<a name="ln4911"> * need to be ordered correctly though!</a>
<a name="ln4912"> */</a>
<a name="ln4913">struct iwm_umac_error_event_table {</a>
<a name="ln4914">	uint32_t valid;		/* (nonzero) valid, (0) log is empty */</a>
<a name="ln4915">	uint32_t error_id;	/* type of error */</a>
<a name="ln4916">	uint32_t blink1;	/* branch link */</a>
<a name="ln4917">	uint32_t blink2;	/* branch link */</a>
<a name="ln4918">	uint32_t ilink1;	/* interrupt link */</a>
<a name="ln4919">	uint32_t ilink2;	/* interrupt link */</a>
<a name="ln4920">	uint32_t data1;		/* error-specific data */</a>
<a name="ln4921">	uint32_t data2;		/* error-specific data */</a>
<a name="ln4922">	uint32_t data3;		/* error-specific data */</a>
<a name="ln4923">	uint32_t umac_major;</a>
<a name="ln4924">	uint32_t umac_minor;</a>
<a name="ln4925">	uint32_t frame_pointer;	/* core register 27*/</a>
<a name="ln4926">	uint32_t stack_pointer;	/* core register 28 */</a>
<a name="ln4927">	uint32_t cmd_header;	/* latest host cmd sent to UMAC */</a>
<a name="ln4928">	uint32_t nic_isr_pref;	/* ISR status register */</a>
<a name="ln4929">} __packed;</a>
<a name="ln4930"> </a>
<a name="ln4931">#define ERROR_START_OFFSET  (1 * sizeof(uint32_t))</a>
<a name="ln4932">#define ERROR_ELEM_SIZE     (7 * sizeof(uint32_t))</a>
<a name="ln4933"> </a>
<a name="ln4934">#ifdef IWM_DEBUG</a>
<a name="ln4935">struct {</a>
<a name="ln4936">	const char *name;</a>
<a name="ln4937">	uint8_t num;</a>
<a name="ln4938">} advanced_lookup[] = {</a>
<a name="ln4939">	{ &quot;NMI_INTERRUPT_WDG&quot;, 0x34 },</a>
<a name="ln4940">	{ &quot;SYSASSERT&quot;, 0x35 },</a>
<a name="ln4941">	{ &quot;UCODE_VERSION_MISMATCH&quot;, 0x37 },</a>
<a name="ln4942">	{ &quot;BAD_COMMAND&quot;, 0x38 },</a>
<a name="ln4943">	{ &quot;NMI_INTERRUPT_DATA_ACTION_PT&quot;, 0x3C },</a>
<a name="ln4944">	{ &quot;FATAL_ERROR&quot;, 0x3D },</a>
<a name="ln4945">	{ &quot;NMI_TRM_HW_ERR&quot;, 0x46 },</a>
<a name="ln4946">	{ &quot;NMI_INTERRUPT_TRM&quot;, 0x4C },</a>
<a name="ln4947">	{ &quot;NMI_INTERRUPT_BREAK_POINT&quot;, 0x54 },</a>
<a name="ln4948">	{ &quot;NMI_INTERRUPT_WDG_RXF_FULL&quot;, 0x5C },</a>
<a name="ln4949">	{ &quot;NMI_INTERRUPT_WDG_NO_RBD_RXF_FULL&quot;, 0x64 },</a>
<a name="ln4950">	{ &quot;NMI_INTERRUPT_HOST&quot;, 0x66 },</a>
<a name="ln4951">	{ &quot;NMI_INTERRUPT_ACTION_PT&quot;, 0x7C },</a>
<a name="ln4952">	{ &quot;NMI_INTERRUPT_UNKNOWN&quot;, 0x84 },</a>
<a name="ln4953">	{ &quot;NMI_INTERRUPT_INST_ACTION_PT&quot;, 0x86 },</a>
<a name="ln4954">	{ &quot;ADVANCED_SYSASSERT&quot;, 0 },</a>
<a name="ln4955">};</a>
<a name="ln4956"> </a>
<a name="ln4957">static const char *</a>
<a name="ln4958">iwm_desc_lookup(uint32_t num)</a>
<a name="ln4959">{</a>
<a name="ln4960">	int i;</a>
<a name="ln4961"> </a>
<a name="ln4962">	for (i = 0; i &lt; nitems(advanced_lookup) - 1; i++)</a>
<a name="ln4963">		if (advanced_lookup[i].num == num)</a>
<a name="ln4964">			return advanced_lookup[i].name;</a>
<a name="ln4965"> </a>
<a name="ln4966">	/* No entry matches 'num', so it is the last: ADVANCED_SYSASSERT */</a>
<a name="ln4967">	return advanced_lookup[i].name;</a>
<a name="ln4968">}</a>
<a name="ln4969"> </a>
<a name="ln4970">static void</a>
<a name="ln4971">iwm_nic_umac_error(struct iwm_softc *sc)</a>
<a name="ln4972">{</a>
<a name="ln4973">	struct iwm_umac_error_event_table table;</a>
<a name="ln4974">	uint32_t base;</a>
<a name="ln4975"> </a>
<a name="ln4976">	base = sc-&gt;umac_error_event_table;</a>
<a name="ln4977"> </a>
<a name="ln4978">	if (base &lt; 0x800000) {</a>
<a name="ln4979">		device_printf(sc-&gt;sc_dev, &quot;Invalid error log pointer 0x%08x\n&quot;,</a>
<a name="ln4980">		    base);</a>
<a name="ln4981">		return;</a>
<a name="ln4982">	}</a>
<a name="ln4983"> </a>
<a name="ln4984">	if (iwm_read_mem(sc, base, &amp;table, sizeof(table)/sizeof(uint32_t))) {</a>
<a name="ln4985">		device_printf(sc-&gt;sc_dev, &quot;reading errlog failed\n&quot;);</a>
<a name="ln4986">		return;</a>
<a name="ln4987">	}</a>
<a name="ln4988"> </a>
<a name="ln4989">	if (ERROR_START_OFFSET &lt;= table.valid * ERROR_ELEM_SIZE) {</a>
<a name="ln4990">		device_printf(sc-&gt;sc_dev, &quot;Start UMAC Error Log Dump:\n&quot;);</a>
<a name="ln4991">		device_printf(sc-&gt;sc_dev, &quot;Status: 0x%x, count: %d\n&quot;,</a>
<a name="ln4992">		    sc-&gt;sc_flags, table.valid);</a>
<a name="ln4993">	}</a>
<a name="ln4994"> </a>
<a name="ln4995">	device_printf(sc-&gt;sc_dev, &quot;0x%08X | %s\n&quot;, table.error_id,</a>
<a name="ln4996">		iwm_desc_lookup(table.error_id));</a>
<a name="ln4997">	device_printf(sc-&gt;sc_dev, &quot;0x%08X | umac branchlink1\n&quot;, table.blink1);</a>
<a name="ln4998">	device_printf(sc-&gt;sc_dev, &quot;0x%08X | umac branchlink2\n&quot;, table.blink2);</a>
<a name="ln4999">	device_printf(sc-&gt;sc_dev, &quot;0x%08X | umac interruptlink1\n&quot;,</a>
<a name="ln5000">	    table.ilink1);</a>
<a name="ln5001">	device_printf(sc-&gt;sc_dev, &quot;0x%08X | umac interruptlink2\n&quot;,</a>
<a name="ln5002">	    table.ilink2);</a>
<a name="ln5003">	device_printf(sc-&gt;sc_dev, &quot;0x%08X | umac data1\n&quot;, table.data1);</a>
<a name="ln5004">	device_printf(sc-&gt;sc_dev, &quot;0x%08X | umac data2\n&quot;, table.data2);</a>
<a name="ln5005">	device_printf(sc-&gt;sc_dev, &quot;0x%08X | umac data3\n&quot;, table.data3);</a>
<a name="ln5006">	device_printf(sc-&gt;sc_dev, &quot;0x%08X | umac major\n&quot;, table.umac_major);</a>
<a name="ln5007">	device_printf(sc-&gt;sc_dev, &quot;0x%08X | umac minor\n&quot;, table.umac_minor);</a>
<a name="ln5008">	device_printf(sc-&gt;sc_dev, &quot;0x%08X | frame pointer\n&quot;,</a>
<a name="ln5009">	    table.frame_pointer);</a>
<a name="ln5010">	device_printf(sc-&gt;sc_dev, &quot;0x%08X | stack pointer\n&quot;,</a>
<a name="ln5011">	    table.stack_pointer);</a>
<a name="ln5012">	device_printf(sc-&gt;sc_dev, &quot;0x%08X | last host cmd\n&quot;, table.cmd_header);</a>
<a name="ln5013">	device_printf(sc-&gt;sc_dev, &quot;0x%08X | isr status reg\n&quot;,</a>
<a name="ln5014">	    table.nic_isr_pref);</a>
<a name="ln5015">}</a>
<a name="ln5016"> </a>
<a name="ln5017">/*</a>
<a name="ln5018"> * Support for dumping the error log seemed like a good idea ...</a>
<a name="ln5019"> * but it's mostly hex junk and the only sensible thing is the</a>
<a name="ln5020"> * hw/ucode revision (which we know anyway).  Since it's here,</a>
<a name="ln5021"> * I'll just leave it in, just in case e.g. the Intel guys want to</a>
<a name="ln5022"> * help us decipher some &quot;ADVANCED_SYSASSERT&quot; later.</a>
<a name="ln5023"> */</a>
<a name="ln5024">static void</a>
<a name="ln5025">iwm_nic_error(struct iwm_softc *sc)</a>
<a name="ln5026">{</a>
<a name="ln5027">	struct iwm_error_event_table table;</a>
<a name="ln5028">	uint32_t base;</a>
<a name="ln5029"> </a>
<a name="ln5030">	device_printf(sc-&gt;sc_dev, &quot;dumping device error log\n&quot;);</a>
<a name="ln5031">	base = sc-&gt;error_event_table[0];</a>
<a name="ln5032">	if (base &lt; 0x800000) {</a>
<a name="ln5033">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln5034">		    &quot;Invalid error log pointer 0x%08x\n&quot;, base);</a>
<a name="ln5035">		return;</a>
<a name="ln5036">	}</a>
<a name="ln5037"> </a>
<a name="ln5038">	if (iwm_read_mem(sc, base, &amp;table, sizeof(table)/sizeof(uint32_t))) {</a>
<a name="ln5039">		device_printf(sc-&gt;sc_dev, &quot;reading errlog failed\n&quot;);</a>
<a name="ln5040">		return;</a>
<a name="ln5041">	}</a>
<a name="ln5042"> </a>
<a name="ln5043">	if (!table.valid) {</a>
<a name="ln5044">		device_printf(sc-&gt;sc_dev, &quot;errlog not found, skipping\n&quot;);</a>
<a name="ln5045">		return;</a>
<a name="ln5046">	}</a>
<a name="ln5047"> </a>
<a name="ln5048">	if (ERROR_START_OFFSET &lt;= table.valid * ERROR_ELEM_SIZE) {</a>
<a name="ln5049">		device_printf(sc-&gt;sc_dev, &quot;Start Error Log Dump:\n&quot;);</a>
<a name="ln5050">		device_printf(sc-&gt;sc_dev, &quot;Status: 0x%x, count: %d\n&quot;,</a>
<a name="ln5051">		    sc-&gt;sc_flags, table.valid);</a>
<a name="ln5052">	}</a>
<a name="ln5053"> </a>
<a name="ln5054">	device_printf(sc-&gt;sc_dev, &quot;0x%08X | %-28s\n&quot;, table.error_id,</a>
<a name="ln5055">	    iwm_desc_lookup(table.error_id));</a>
<a name="ln5056">	device_printf(sc-&gt;sc_dev, &quot;%08X | trm_hw_status0\n&quot;,</a>
<a name="ln5057">	    table.trm_hw_status0);</a>
<a name="ln5058">	device_printf(sc-&gt;sc_dev, &quot;%08X | trm_hw_status1\n&quot;,</a>
<a name="ln5059">	    table.trm_hw_status1);</a>
<a name="ln5060">	device_printf(sc-&gt;sc_dev, &quot;%08X | branchlink2\n&quot;, table.blink2);</a>
<a name="ln5061">	device_printf(sc-&gt;sc_dev, &quot;%08X | interruptlink1\n&quot;, table.ilink1);</a>
<a name="ln5062">	device_printf(sc-&gt;sc_dev, &quot;%08X | interruptlink2\n&quot;, table.ilink2);</a>
<a name="ln5063">	device_printf(sc-&gt;sc_dev, &quot;%08X | data1\n&quot;, table.data1);</a>
<a name="ln5064">	device_printf(sc-&gt;sc_dev, &quot;%08X | data2\n&quot;, table.data2);</a>
<a name="ln5065">	device_printf(sc-&gt;sc_dev, &quot;%08X | data3\n&quot;, table.data3);</a>
<a name="ln5066">	device_printf(sc-&gt;sc_dev, &quot;%08X | beacon time\n&quot;, table.bcon_time);</a>
<a name="ln5067">	device_printf(sc-&gt;sc_dev, &quot;%08X | tsf low\n&quot;, table.tsf_low);</a>
<a name="ln5068">	device_printf(sc-&gt;sc_dev, &quot;%08X | tsf hi\n&quot;, table.tsf_hi);</a>
<a name="ln5069">	device_printf(sc-&gt;sc_dev, &quot;%08X | time gp1\n&quot;, table.gp1);</a>
<a name="ln5070">	device_printf(sc-&gt;sc_dev, &quot;%08X | time gp2\n&quot;, table.gp2);</a>
<a name="ln5071">	device_printf(sc-&gt;sc_dev, &quot;%08X | uCode revision type\n&quot;,</a>
<a name="ln5072">	    table.fw_rev_type);</a>
<a name="ln5073">	device_printf(sc-&gt;sc_dev, &quot;%08X | uCode version major\n&quot;, table.major);</a>
<a name="ln5074">	device_printf(sc-&gt;sc_dev, &quot;%08X | uCode version minor\n&quot;, table.minor);</a>
<a name="ln5075">	device_printf(sc-&gt;sc_dev, &quot;%08X | hw version\n&quot;, table.hw_ver);</a>
<a name="ln5076">	device_printf(sc-&gt;sc_dev, &quot;%08X | board version\n&quot;, table.brd_ver);</a>
<a name="ln5077">	device_printf(sc-&gt;sc_dev, &quot;%08X | hcmd\n&quot;, table.hcmd);</a>
<a name="ln5078">	device_printf(sc-&gt;sc_dev, &quot;%08X | isr0\n&quot;, table.isr0);</a>
<a name="ln5079">	device_printf(sc-&gt;sc_dev, &quot;%08X | isr1\n&quot;, table.isr1);</a>
<a name="ln5080">	device_printf(sc-&gt;sc_dev, &quot;%08X | isr2\n&quot;, table.isr2);</a>
<a name="ln5081">	device_printf(sc-&gt;sc_dev, &quot;%08X | isr3\n&quot;, table.isr3);</a>
<a name="ln5082">	device_printf(sc-&gt;sc_dev, &quot;%08X | isr4\n&quot;, table.isr4);</a>
<a name="ln5083">	device_printf(sc-&gt;sc_dev, &quot;%08X | last cmd Id\n&quot;, table.last_cmd_id);</a>
<a name="ln5084">	device_printf(sc-&gt;sc_dev, &quot;%08X | wait_event\n&quot;, table.wait_event);</a>
<a name="ln5085">	device_printf(sc-&gt;sc_dev, &quot;%08X | l2p_control\n&quot;, table.l2p_control);</a>
<a name="ln5086">	device_printf(sc-&gt;sc_dev, &quot;%08X | l2p_duration\n&quot;, table.l2p_duration);</a>
<a name="ln5087">	device_printf(sc-&gt;sc_dev, &quot;%08X | l2p_mhvalid\n&quot;, table.l2p_mhvalid);</a>
<a name="ln5088">	device_printf(sc-&gt;sc_dev, &quot;%08X | l2p_addr_match\n&quot;, table.l2p_addr_match);</a>
<a name="ln5089">	device_printf(sc-&gt;sc_dev, &quot;%08X | lmpm_pmg_sel\n&quot;, table.lmpm_pmg_sel);</a>
<a name="ln5090">	device_printf(sc-&gt;sc_dev, &quot;%08X | timestamp\n&quot;, table.u_timestamp);</a>
<a name="ln5091">	device_printf(sc-&gt;sc_dev, &quot;%08X | flow_handler\n&quot;, table.flow_handler);</a>
<a name="ln5092"> </a>
<a name="ln5093">	if (sc-&gt;umac_error_event_table)</a>
<a name="ln5094">		iwm_nic_umac_error(sc);</a>
<a name="ln5095">}</a>
<a name="ln5096">#endif</a>
<a name="ln5097"> </a>
<a name="ln5098">static void</a>
<a name="ln5099">iwm_handle_rxb(struct iwm_softc *sc, struct mbuf *m)</a>
<a name="ln5100">{</a>
<a name="ln5101">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln5102">	struct iwm_cmd_response *cresp;</a>
<a name="ln5103">	struct mbuf *m1;</a>
<a name="ln5104">	uint32_t offset = 0;</a>
<a name="ln5105">	uint32_t maxoff = IWM_RBUF_SIZE;</a>
<a name="ln5106">	uint32_t nextoff;</a>
<a name="ln5107">	boolean_t stolen = FALSE;</a>
<a name="ln5108"> </a>
<a name="ln5109">#define HAVEROOM(a)	\</a>
<a name="ln5110">    ((a) + sizeof(uint32_t) + sizeof(struct iwm_cmd_header) &lt; maxoff)</a>
<a name="ln5111"> </a>
<a name="ln5112">	while (HAVEROOM(offset)) {</a>
<a name="ln5113">		struct iwm_rx_packet *pkt = mtodoff(m, struct iwm_rx_packet *,</a>
<a name="ln5114">		    offset);</a>
<a name="ln5115">		int qid, idx, code, len;</a>
<a name="ln5116"> </a>
<a name="ln5117">		qid = pkt-&gt;hdr.qid;</a>
<a name="ln5118">		idx = pkt-&gt;hdr.idx;</a>
<a name="ln5119"> </a>
<a name="ln5120">		code = IWM_WIDE_ID(pkt-&gt;hdr.flags, pkt-&gt;hdr.code);</a>
<a name="ln5121"> </a>
<a name="ln5122">		/*</a>
<a name="ln5123">		 * randomly get these from the firmware, no idea why.</a>
<a name="ln5124">		 * they at least seem harmless, so just ignore them for now</a>
<a name="ln5125">		 */</a>
<a name="ln5126">		if ((pkt-&gt;hdr.code == 0 &amp;&amp; (qid &amp; ~0x80) == 0 &amp;&amp; idx == 0) ||</a>
<a name="ln5127">		    pkt-&gt;len_n_flags == htole32(IWM_FH_RSCSR_FRAME_INVALID)) {</a>
<a name="ln5128">			break;</a>
<a name="ln5129">		}</a>
<a name="ln5130"> </a>
<a name="ln5131">		IWM_DPRINTF(sc, IWM_DEBUG_INTR,</a>
<a name="ln5132">		    &quot;rx packet qid=%d idx=%d type=%x\n&quot;,</a>
<a name="ln5133">		    qid &amp; ~0x80, pkt-&gt;hdr.idx, code);</a>
<a name="ln5134"> </a>
<a name="ln5135">		len = iwm_rx_packet_len(pkt);</a>
<a name="ln5136">		len += sizeof(uint32_t); /* account for status word */</a>
<a name="ln5137">		nextoff = offset + roundup2(len, IWM_FH_RSCSR_FRAME_ALIGN);</a>
<a name="ln5138"> </a>
<a name="ln5139">		iwm_notification_wait_notify(sc-&gt;sc_notif_wait, code, pkt);</a>
<a name="ln5140"> </a>
<a name="ln5141">		switch (code) {</a>
<a name="ln5142">		case IWM_REPLY_RX_PHY_CMD:</a>
<a name="ln5143">			iwm_mvm_rx_rx_phy_cmd(sc, pkt);</a>
<a name="ln5144">			break;</a>
<a name="ln5145"> </a>
<a name="ln5146">		case IWM_REPLY_RX_MPDU_CMD: {</a>
<a name="ln5147">			/*</a>
<a name="ln5148">			 * If this is the last frame in the RX buffer, we</a>
<a name="ln5149">			 * can directly feed the mbuf to the sharks here.</a>
<a name="ln5150">			 */</a>
<a name="ln5151">			struct iwm_rx_packet *nextpkt = mtodoff(m,</a>
<a name="ln5152">			    struct iwm_rx_packet *, nextoff);</a>
<a name="ln5153">			if (!HAVEROOM(nextoff) ||</a>
<a name="ln5154">			    (nextpkt-&gt;hdr.code == 0 &amp;&amp;</a>
<a name="ln5155">			     (nextpkt-&gt;hdr.qid &amp; ~0x80) == 0 &amp;&amp;</a>
<a name="ln5156">			     nextpkt-&gt;hdr.idx == 0) ||</a>
<a name="ln5157">			    (nextpkt-&gt;len_n_flags ==</a>
<a name="ln5158">			     htole32(IWM_FH_RSCSR_FRAME_INVALID))) {</a>
<a name="ln5159">				if (iwm_mvm_rx_rx_mpdu(sc, m, offset, stolen)) {</a>
<a name="ln5160">					stolen = FALSE;</a>
<a name="ln5161">					/* Make sure we abort the loop */</a>
<a name="ln5162">					nextoff = maxoff;</a>
<a name="ln5163">				}</a>
<a name="ln5164">				break;</a>
<a name="ln5165">			}</a>
<a name="ln5166"> </a>
<a name="ln5167">			/*</a>
<a name="ln5168">			 * Use m_copym instead of m_split, because that</a>
<a name="ln5169">			 * makes it easier to keep a valid rx buffer in</a>
<a name="ln5170">			 * the ring, when iwm_mvm_rx_rx_mpdu() fails.</a>
<a name="ln5171">			 *</a>
<a name="ln5172">			 * We need to start m_copym() at offset 0, to get the</a>
<a name="ln5173">			 * M_PKTHDR flag preserved.</a>
<a name="ln5174">			 */</a>
<a name="ln5175">			m1 = m_copym(m, 0, M_COPYALL, M_NOWAIT);</a>
<a name="ln5176">			if (m1) {</a>
<a name="ln5177">				if (iwm_mvm_rx_rx_mpdu(sc, m1, offset, stolen))</a>
<a name="ln5178">					stolen = TRUE;</a>
<a name="ln5179">				else</a>
<a name="ln5180">					m_freem(m1);</a>
<a name="ln5181">			}</a>
<a name="ln5182">			break;</a>
<a name="ln5183">		}</a>
<a name="ln5184"> </a>
<a name="ln5185">		case IWM_TX_CMD:</a>
<a name="ln5186">			iwm_mvm_rx_tx_cmd(sc, pkt);</a>
<a name="ln5187">			break;</a>
<a name="ln5188"> </a>
<a name="ln5189">		case IWM_MISSED_BEACONS_NOTIFICATION: {</a>
<a name="ln5190">			struct iwm_missed_beacons_notif *resp;</a>
<a name="ln5191">			int missed;</a>
<a name="ln5192"> </a>
<a name="ln5193">			/* XXX look at mac_id to determine interface ID */</a>
<a name="ln5194">			struct ieee80211vap *vap = TAILQ_FIRST(&amp;ic-&gt;ic_vaps);</a>
<a name="ln5195"> </a>
<a name="ln5196">			resp = (void *)pkt-&gt;data;</a>
<a name="ln5197">			missed = le32toh(resp-&gt;consec_missed_beacons);</a>
<a name="ln5198"> </a>
<a name="ln5199">			IWM_DPRINTF(sc, IWM_DEBUG_BEACON | IWM_DEBUG_STATE,</a>
<a name="ln5200">			    &quot;%s: MISSED_BEACON: mac_id=%d, &quot;</a>
<a name="ln5201">			    &quot;consec_since_last_rx=%d, consec=%d, num_expect=%d &quot;</a>
<a name="ln5202">			    &quot;num_rx=%d\n&quot;,</a>
<a name="ln5203">			    __func__,</a>
<a name="ln5204">			    le32toh(resp-&gt;mac_id),</a>
<a name="ln5205">			    le32toh(resp-&gt;consec_missed_beacons_since_last_rx),</a>
<a name="ln5206">			    le32toh(resp-&gt;consec_missed_beacons),</a>
<a name="ln5207">			    le32toh(resp-&gt;num_expected_beacons),</a>
<a name="ln5208">			    le32toh(resp-&gt;num_recvd_beacons));</a>
<a name="ln5209"> </a>
<a name="ln5210">			/* Be paranoid */</a>
<a name="ln5211">			if (vap == NULL)</a>
<a name="ln5212">				break;</a>
<a name="ln5213"> </a>
<a name="ln5214">			/* XXX no net80211 locking? */</a>
<a name="ln5215">			if (vap-&gt;iv_state == IEEE80211_S_RUN &amp;&amp;</a>
<a name="ln5216">			    (ic-&gt;ic_flags &amp; IEEE80211_F_SCAN) == 0) {</a>
<a name="ln5217">				if (missed &gt; vap-&gt;iv_bmissthreshold) {</a>
<a name="ln5218">					/* XXX bad locking; turn into task */</a>
<a name="ln5219">					IWM_UNLOCK(sc);</a>
<a name="ln5220">					ieee80211_beacon_miss(ic);</a>
<a name="ln5221">					IWM_LOCK(sc);</a>
<a name="ln5222">				}</a>
<a name="ln5223">			}</a>
<a name="ln5224"> </a>
<a name="ln5225">			break;</a>
<a name="ln5226">		}</a>
<a name="ln5227"> </a>
<a name="ln5228">		case IWM_MFUART_LOAD_NOTIFICATION:</a>
<a name="ln5229">			break;</a>
<a name="ln5230"> </a>
<a name="ln5231">		case IWM_MVM_ALIVE:</a>
<a name="ln5232">			break;</a>
<a name="ln5233"> </a>
<a name="ln5234">		case IWM_CALIB_RES_NOTIF_PHY_DB:</a>
<a name="ln5235">			break;</a>
<a name="ln5236"> </a>
<a name="ln5237">		case IWM_STATISTICS_NOTIFICATION:</a>
<a name="ln5238">			iwm_mvm_handle_rx_statistics(sc, pkt);</a>
<a name="ln5239">			break;</a>
<a name="ln5240"> </a>
<a name="ln5241">		case IWM_NVM_ACCESS_CMD:</a>
<a name="ln5242">		case IWM_MCC_UPDATE_CMD:</a>
<a name="ln5243">			if (sc-&gt;sc_wantresp == (((qid &amp; ~0x80) &lt;&lt; 16) | idx)) {</a>
<a name="ln5244">				memcpy(sc-&gt;sc_cmd_resp,</a>
<a name="ln5245">				    pkt, sizeof(sc-&gt;sc_cmd_resp));</a>
<a name="ln5246">			}</a>
<a name="ln5247">			break;</a>
<a name="ln5248"> </a>
<a name="ln5249">		case IWM_MCC_CHUB_UPDATE_CMD: {</a>
<a name="ln5250">			struct iwm_mcc_chub_notif *notif;</a>
<a name="ln5251">			notif = (void *)pkt-&gt;data;</a>
<a name="ln5252"> </a>
<a name="ln5253">			sc-&gt;sc_fw_mcc[0] = (notif-&gt;mcc &amp; 0xff00) &gt;&gt; 8;</a>
<a name="ln5254">			sc-&gt;sc_fw_mcc[1] = notif-&gt;mcc &amp; 0xff;</a>
<a name="ln5255">			sc-&gt;sc_fw_mcc[2] = '\0';</a>
<a name="ln5256">			IWM_DPRINTF(sc, IWM_DEBUG_LAR,</a>
<a name="ln5257">			    &quot;fw source %d sent CC '%s'\n&quot;,</a>
<a name="ln5258">			    notif-&gt;source_id, sc-&gt;sc_fw_mcc);</a>
<a name="ln5259">			break;</a>
<a name="ln5260">		}</a>
<a name="ln5261"> </a>
<a name="ln5262">		case IWM_DTS_MEASUREMENT_NOTIFICATION:</a>
<a name="ln5263">		case IWM_WIDE_ID(IWM_PHY_OPS_GROUP,</a>
<a name="ln5264">				 IWM_DTS_MEASUREMENT_NOTIF_WIDE): {</a>
<a name="ln5265">			struct iwm_dts_measurement_notif_v1 *notif;</a>
<a name="ln5266"> </a>
<a name="ln5267">			if (iwm_rx_packet_payload_len(pkt) &lt; sizeof(*notif)) {</a>
<a name="ln5268">				device_printf(sc-&gt;sc_dev,</a>
<a name="ln5269">				    &quot;Invalid DTS_MEASUREMENT_NOTIFICATION\n&quot;);</a>
<a name="ln5270">				break;</a>
<a name="ln5271">			}</a>
<a name="ln5272">			notif = (void *)pkt-&gt;data;</a>
<a name="ln5273">			IWM_DPRINTF(sc, IWM_DEBUG_TEMP,</a>
<a name="ln5274">			    &quot;IWM_DTS_MEASUREMENT_NOTIFICATION - %d\n&quot;,</a>
<a name="ln5275">			    notif-&gt;temp);</a>
<a name="ln5276">			break;</a>
<a name="ln5277">		}</a>
<a name="ln5278"> </a>
<a name="ln5279">		case IWM_PHY_CONFIGURATION_CMD:</a>
<a name="ln5280">		case IWM_TX_ANT_CONFIGURATION_CMD:</a>
<a name="ln5281">		case IWM_ADD_STA:</a>
<a name="ln5282">		case IWM_MAC_CONTEXT_CMD:</a>
<a name="ln5283">		case IWM_REPLY_SF_CFG_CMD:</a>
<a name="ln5284">		case IWM_POWER_TABLE_CMD:</a>
<a name="ln5285">		case IWM_LTR_CONFIG:</a>
<a name="ln5286">		case IWM_PHY_CONTEXT_CMD:</a>
<a name="ln5287">		case IWM_BINDING_CONTEXT_CMD:</a>
<a name="ln5288">		case IWM_TIME_EVENT_CMD:</a>
<a name="ln5289">		case IWM_WIDE_ID(IWM_ALWAYS_LONG_GROUP, IWM_SCAN_CFG_CMD):</a>
<a name="ln5290">		case IWM_WIDE_ID(IWM_ALWAYS_LONG_GROUP, IWM_SCAN_REQ_UMAC):</a>
<a name="ln5291">		case IWM_WIDE_ID(IWM_ALWAYS_LONG_GROUP, IWM_SCAN_ABORT_UMAC):</a>
<a name="ln5292">		case IWM_SCAN_OFFLOAD_REQUEST_CMD:</a>
<a name="ln5293">		case IWM_SCAN_OFFLOAD_ABORT_CMD:</a>
<a name="ln5294">		case IWM_REPLY_BEACON_FILTERING_CMD:</a>
<a name="ln5295">		case IWM_MAC_PM_POWER_TABLE:</a>
<a name="ln5296">		case IWM_TIME_QUOTA_CMD:</a>
<a name="ln5297">		case IWM_REMOVE_STA:</a>
<a name="ln5298">		case IWM_TXPATH_FLUSH:</a>
<a name="ln5299">		case IWM_LQ_CMD:</a>
<a name="ln5300">		case IWM_WIDE_ID(IWM_ALWAYS_LONG_GROUP,</a>
<a name="ln5301">				 IWM_FW_PAGING_BLOCK_CMD):</a>
<a name="ln5302">		case IWM_BT_CONFIG:</a>
<a name="ln5303">		case IWM_REPLY_THERMAL_MNG_BACKOFF:</a>
<a name="ln5304">			cresp = (void *)pkt-&gt;data;</a>
<a name="ln5305">			if (sc-&gt;sc_wantresp == (((qid &amp; ~0x80) &lt;&lt; 16) | idx)) {</a>
<a name="ln5306">				memcpy(sc-&gt;sc_cmd_resp,</a>
<a name="ln5307">				    pkt, sizeof(*pkt)+sizeof(*cresp));</a>
<a name="ln5308">			}</a>
<a name="ln5309">			break;</a>
<a name="ln5310"> </a>
<a name="ln5311">		/* ignore */</a>
<a name="ln5312">		case IWM_PHY_DB_CMD:</a>
<a name="ln5313">			break;</a>
<a name="ln5314"> </a>
<a name="ln5315">		case IWM_INIT_COMPLETE_NOTIF:</a>
<a name="ln5316">			break;</a>
<a name="ln5317"> </a>
<a name="ln5318">		case IWM_SCAN_OFFLOAD_COMPLETE:</a>
<a name="ln5319">			iwm_mvm_rx_lmac_scan_complete_notif(sc, pkt);</a>
<a name="ln5320">			if (sc-&gt;sc_flags &amp; IWM_FLAG_SCAN_RUNNING) {</a>
<a name="ln5321">				sc-&gt;sc_flags &amp;= ~IWM_FLAG_SCAN_RUNNING;</a>
<a name="ln5322">				ieee80211_runtask(ic, &amp;sc-&gt;sc_es_task);</a>
<a name="ln5323">			}</a>
<a name="ln5324">			break;</a>
<a name="ln5325"> </a>
<a name="ln5326">		case IWM_SCAN_ITERATION_COMPLETE: {</a>
<a name="ln5327">			struct iwm_lmac_scan_complete_notif *notif;</a>
<a name="ln5328">			notif = (void *)pkt-&gt;data;</a>
<a name="ln5329">			break;</a>
<a name="ln5330">		}</a>
<a name="ln5331"> </a>
<a name="ln5332">		case IWM_SCAN_COMPLETE_UMAC:</a>
<a name="ln5333">			iwm_mvm_rx_umac_scan_complete_notif(sc, pkt);</a>
<a name="ln5334">			if (sc-&gt;sc_flags &amp; IWM_FLAG_SCAN_RUNNING) {</a>
<a name="ln5335">				sc-&gt;sc_flags &amp;= ~IWM_FLAG_SCAN_RUNNING;</a>
<a name="ln5336">				ieee80211_runtask(ic, &amp;sc-&gt;sc_es_task);</a>
<a name="ln5337">			}</a>
<a name="ln5338">			break;</a>
<a name="ln5339"> </a>
<a name="ln5340">		case IWM_SCAN_ITERATION_COMPLETE_UMAC: {</a>
<a name="ln5341">			struct iwm_umac_scan_iter_complete_notif *notif;</a>
<a name="ln5342">			notif = (void *)pkt-&gt;data;</a>
<a name="ln5343"> </a>
<a name="ln5344">			IWM_DPRINTF(sc, IWM_DEBUG_SCAN, &quot;UMAC scan iteration &quot;</a>
<a name="ln5345">			    &quot;complete, status=0x%x, %d channels scanned\n&quot;,</a>
<a name="ln5346">			    notif-&gt;status, notif-&gt;scanned_channels);</a>
<a name="ln5347">			break;</a>
<a name="ln5348">		}</a>
<a name="ln5349"> </a>
<a name="ln5350">		case IWM_REPLY_ERROR: {</a>
<a name="ln5351">			struct iwm_error_resp *resp;</a>
<a name="ln5352">			resp = (void *)pkt-&gt;data;</a>
<a name="ln5353"> </a>
<a name="ln5354">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln5355">			    &quot;firmware error 0x%x, cmd 0x%x\n&quot;,</a>
<a name="ln5356">			    le32toh(resp-&gt;error_type),</a>
<a name="ln5357">			    resp-&gt;cmd_id);</a>
<a name="ln5358">			break;</a>
<a name="ln5359">		}</a>
<a name="ln5360"> </a>
<a name="ln5361">		case IWM_TIME_EVENT_NOTIFICATION:</a>
<a name="ln5362">			iwm_mvm_rx_time_event_notif(sc, pkt);</a>
<a name="ln5363">			break;</a>
<a name="ln5364"> </a>
<a name="ln5365">		/*</a>
<a name="ln5366">		 * Firmware versions 21 and 22 generate some DEBUG_LOG_MSG</a>
<a name="ln5367">		 * messages. Just ignore them for now.</a>
<a name="ln5368">		 */</a>
<a name="ln5369">		case IWM_DEBUG_LOG_MSG:</a>
<a name="ln5370">			break;</a>
<a name="ln5371"> </a>
<a name="ln5372">		case IWM_MCAST_FILTER_CMD:</a>
<a name="ln5373">			break;</a>
<a name="ln5374"> </a>
<a name="ln5375">		case IWM_SCD_QUEUE_CFG: {</a>
<a name="ln5376">			struct iwm_scd_txq_cfg_rsp *rsp;</a>
<a name="ln5377">			rsp = (void *)pkt-&gt;data;</a>
<a name="ln5378"> </a>
<a name="ln5379">			IWM_DPRINTF(sc, IWM_DEBUG_CMD,</a>
<a name="ln5380">			    &quot;queue cfg token=0x%x sta_id=%d &quot;</a>
<a name="ln5381">			    &quot;tid=%d scd_queue=%d\n&quot;,</a>
<a name="ln5382">			    rsp-&gt;token, rsp-&gt;sta_id, rsp-&gt;tid,</a>
<a name="ln5383">			    rsp-&gt;scd_queue);</a>
<a name="ln5384">			break;</a>
<a name="ln5385">		}</a>
<a name="ln5386"> </a>
<a name="ln5387">		default:</a>
<a name="ln5388">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln5389">			    &quot;frame %d/%d %x UNHANDLED (this should &quot;</a>
<a name="ln5390">			    &quot;not happen)\n&quot;, qid &amp; ~0x80, idx,</a>
<a name="ln5391">			    pkt-&gt;len_n_flags);</a>
<a name="ln5392">			break;</a>
<a name="ln5393">		}</a>
<a name="ln5394"> </a>
<a name="ln5395">		/*</a>
<a name="ln5396">		 * Why test bit 0x80?  The Linux driver:</a>
<a name="ln5397">		 *</a>
<a name="ln5398">		 * There is one exception:  uCode sets bit 15 when it</a>
<a name="ln5399">		 * originates the response/notification, i.e. when the</a>
<a name="ln5400">		 * response/notification is not a direct response to a</a>
<a name="ln5401">		 * command sent by the driver.  For example, uCode issues</a>
<a name="ln5402">		 * IWM_REPLY_RX when it sends a received frame to the driver;</a>
<a name="ln5403">		 * it is not a direct response to any driver command.</a>
<a name="ln5404">		 *</a>
<a name="ln5405">		 * Ok, so since when is 7 == 15?  Well, the Linux driver</a>
<a name="ln5406">		 * uses a slightly different format for pkt-&gt;hdr, and &quot;qid&quot;</a>
<a name="ln5407">		 * is actually the upper byte of a two-byte field.</a>
<a name="ln5408">		 */</a>
<a name="ln5409">		if (!(qid &amp; (1 &lt;&lt; 7)))</a>
<a name="ln5410">			iwm_cmd_done(sc, pkt);</a>
<a name="ln5411"> </a>
<a name="ln5412">		offset = nextoff;</a>
<a name="ln5413">	}</a>
<a name="ln5414">	if (stolen)</a>
<a name="ln5415">		m_freem(m);</a>
<a name="ln5416">#undef HAVEROOM</a>
<a name="ln5417">}</a>
<a name="ln5418"> </a>
<a name="ln5419">/*</a>
<a name="ln5420"> * Process an IWM_CSR_INT_BIT_FH_RX or IWM_CSR_INT_BIT_SW_RX interrupt.</a>
<a name="ln5421"> * Basic structure from if_iwn</a>
<a name="ln5422"> */</a>
<a name="ln5423">static void</a>
<a name="ln5424">iwm_notif_intr(struct iwm_softc *sc)</a>
<a name="ln5425">{</a>
<a name="ln5426">	uint16_t hw;</a>
<a name="ln5427"> </a>
<a name="ln5428">	bus_dmamap_sync(sc-&gt;rxq.stat_dma.tag, sc-&gt;rxq.stat_dma.map,</a>
<a name="ln5429">	    BUS_DMASYNC_POSTREAD);</a>
<a name="ln5430"> </a>
<a name="ln5431">	hw = le16toh(sc-&gt;rxq.stat-&gt;closed_rb_num) &amp; 0xfff;</a>
<a name="ln5432"> </a>
<a name="ln5433">	/*</a>
<a name="ln5434">	 * Process responses</a>
<a name="ln5435">	 */</a>
<a name="ln5436">	while (sc-&gt;rxq.cur != hw) {</a>
<a name="ln5437">		struct iwm_rx_ring *ring = &amp;sc-&gt;rxq;</a>
<a name="ln5438">		struct iwm_rx_data *data = &amp;ring-&gt;data[ring-&gt;cur];</a>
<a name="ln5439"> </a>
<a name="ln5440">		bus_dmamap_sync(ring-&gt;data_dmat, data-&gt;map,</a>
<a name="ln5441">		    BUS_DMASYNC_POSTREAD);</a>
<a name="ln5442"> </a>
<a name="ln5443">		IWM_DPRINTF(sc, IWM_DEBUG_INTR,</a>
<a name="ln5444">		    &quot;%s: hw = %d cur = %d\n&quot;, __func__, hw, ring-&gt;cur);</a>
<a name="ln5445">		iwm_handle_rxb(sc, data-&gt;m);</a>
<a name="ln5446"> </a>
<a name="ln5447">		ring-&gt;cur = (ring-&gt;cur + 1) % IWM_RX_RING_COUNT;</a>
<a name="ln5448">	}</a>
<a name="ln5449"> </a>
<a name="ln5450">	/*</a>
<a name="ln5451">	 * Tell the firmware that it can reuse the ring entries that</a>
<a name="ln5452">	 * we have just processed.</a>
<a name="ln5453">	 * Seems like the hardware gets upset unless we align</a>
<a name="ln5454">	 * the write by 8??</a>
<a name="ln5455">	 */</a>
<a name="ln5456">	hw = (hw == 0) ? IWM_RX_RING_COUNT - 1 : hw - 1;</a>
<a name="ln5457">	IWM_WRITE(sc, IWM_FH_RSCSR_CHNL0_WPTR, rounddown2(hw, 8));</a>
<a name="ln5458">}</a>
<a name="ln5459"> </a>
<a name="ln5460">static void</a>
<a name="ln5461">iwm_intr(void *arg)</a>
<a name="ln5462">{</a>
<a name="ln5463">	struct iwm_softc *sc = arg;</a>
<a name="ln5464">	int handled = 0;</a>
<a name="ln5465">	int r1, r2, rv = 0;</a>
<a name="ln5466">	int isperiodic = 0;</a>
<a name="ln5467"> </a>
<a name="ln5468">	IWM_LOCK(sc);</a>
<a name="ln5469">#ifndef __HAIKU__</a>
<a name="ln5470">	IWM_WRITE(sc, IWM_CSR_INT_MASK, 0);</a>
<a name="ln5471"> </a>
<a name="ln5472">	if (sc-&gt;sc_flags &amp; IWM_FLAG_USE_ICT) {</a>
<a name="ln5473">		uint32_t *ict = sc-&gt;ict_dma.vaddr;</a>
<a name="ln5474">		int tmp;</a>
<a name="ln5475"> </a>
<a name="ln5476">		tmp = htole32(ict[sc-&gt;ict_cur]);</a>
<a name="ln5477">		if (!tmp)</a>
<a name="ln5478">			goto out_ena;</a>
<a name="ln5479"> </a>
<a name="ln5480">		/*</a>
<a name="ln5481">		 * ok, there was something.  keep plowing until we have all.</a>
<a name="ln5482">		 */</a>
<a name="ln5483">		r1 = r2 = 0;</a>
<a name="ln5484">		while (tmp) {</a>
<a name="ln5485">			r1 |= tmp;</a>
<a name="ln5486">			ict[sc-&gt;ict_cur] = 0;</a>
<a name="ln5487">			sc-&gt;ict_cur = (sc-&gt;ict_cur+1) % IWM_ICT_COUNT;</a>
<a name="ln5488">			tmp = htole32(ict[sc-&gt;ict_cur]);</a>
<a name="ln5489">		}</a>
<a name="ln5490"> </a>
<a name="ln5491">		/* this is where the fun begins.  don't ask */</a>
<a name="ln5492">		if (r1 == 0xffffffff)</a>
<a name="ln5493">			r1 = 0;</a>
<a name="ln5494"> </a>
<a name="ln5495">		/* i am not expected to understand this */</a>
<a name="ln5496">		if (r1 &amp; 0xc0000)</a>
<a name="ln5497">			r1 |= 0x8000;</a>
<a name="ln5498">		r1 = (0xff &amp; r1) | ((0xff00 &amp; r1) &lt;&lt; 16);</a>
<a name="ln5499">	} else {</a>
<a name="ln5500">		r1 = IWM_READ(sc, IWM_CSR_INT);</a>
<a name="ln5501">		/* &quot;hardware gone&quot; (where, fishing?) */</a>
<a name="ln5502">		if (r1 == 0xffffffff || (r1 &amp; 0xfffffff0) == 0xa5a5a5a0)</a>
<a name="ln5503">			goto out;</a>
<a name="ln5504">		r2 = IWM_READ(sc, IWM_CSR_FH_INT_STATUS);</a>
<a name="ln5505">	}</a>
<a name="ln5506">	if (r1 == 0 &amp;&amp; r2 == 0) {</a>
<a name="ln5507">		goto out_ena;</a>
<a name="ln5508">	}</a>
<a name="ln5509">#else</a>
<a name="ln5510">	r1 = atomic_get((int32 *)&amp;sc-&gt;sc_intr_status_1);</a>
<a name="ln5511">	r2 = atomic_get((int32 *)&amp;sc-&gt;sc_intr_status_2);</a>
<a name="ln5512">#endif</a>
<a name="ln5513"> </a>
<a name="ln5514">	IWM_WRITE(sc, IWM_CSR_INT, r1 | ~sc-&gt;sc_intmask);</a>
<a name="ln5515"> </a>
<a name="ln5516">	/* Safely ignore these bits for debug checks below */</a>
<a name="ln5517">	r1 &amp;= ~(IWM_CSR_INT_BIT_ALIVE | IWM_CSR_INT_BIT_SCD);</a>
<a name="ln5518"> </a>
<a name="ln5519">	if (r1 &amp; IWM_CSR_INT_BIT_SW_ERR) {</a>
<a name="ln5520">		int i;</a>
<a name="ln5521">		struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln5522">		struct ieee80211vap *vap = TAILQ_FIRST(&amp;ic-&gt;ic_vaps);</a>
<a name="ln5523"> </a>
<a name="ln5524">#ifdef IWM_DEBUG</a>
<a name="ln5525">		iwm_nic_error(sc);</a>
<a name="ln5526">#endif</a>
<a name="ln5527">		/* Dump driver status (TX and RX rings) while we're here. */</a>
<a name="ln5528">		device_printf(sc-&gt;sc_dev, &quot;driver status:\n&quot;);</a>
<a name="ln5529">		for (i = 0; i &lt; IWM_MVM_MAX_QUEUES; i++) {</a>
<a name="ln5530">			struct iwm_tx_ring *ring = &amp;sc-&gt;txq[i];</a>
<a name="ln5531">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln5532">			    &quot;  tx ring %2d: qid=%-2d cur=%-3d &quot;</a>
<a name="ln5533">			    &quot;queued=%-3d\n&quot;,</a>
<a name="ln5534">			    i, ring-&gt;qid, ring-&gt;cur, ring-&gt;queued);</a>
<a name="ln5535">		}</a>
<a name="ln5536">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln5537">		    &quot;  rx ring: cur=%d\n&quot;, sc-&gt;rxq.cur);</a>
<a name="ln5538">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln5539">		    &quot;  802.11 state %d\n&quot;, (vap == NULL) ? -1 : vap-&gt;iv_state);</a>
<a name="ln5540"> </a>
<a name="ln5541">		/* Reset our firmware state tracking. */</a>
<a name="ln5542">		sc-&gt;sc_firmware_state = 0;</a>
<a name="ln5543">		/* Don't stop the device; just do a VAP restart */</a>
<a name="ln5544">		IWM_UNLOCK(sc);</a>
<a name="ln5545"> </a>
<a name="ln5546">		if (vap == NULL) {</a>
<a name="ln5547">			printf(&quot;%s: null vap\n&quot;, __func__);</a>
<a name="ln5548">			return;</a>
<a name="ln5549">		}</a>
<a name="ln5550"> </a>
<a name="ln5551">		device_printf(sc-&gt;sc_dev, &quot;%s: controller panicked, iv_state = %d; &quot;</a>
<a name="ln5552">		    &quot;restarting\n&quot;, __func__, vap-&gt;iv_state);</a>
<a name="ln5553"> </a>
<a name="ln5554">		ieee80211_restart_all(ic);</a>
<a name="ln5555">		return;</a>
<a name="ln5556">	}</a>
<a name="ln5557"> </a>
<a name="ln5558">	if (r1 &amp; IWM_CSR_INT_BIT_HW_ERR) {</a>
<a name="ln5559">		handled |= IWM_CSR_INT_BIT_HW_ERR;</a>
<a name="ln5560">		device_printf(sc-&gt;sc_dev, &quot;hardware error, stopping device\n&quot;);</a>
<a name="ln5561">		iwm_stop(sc);</a>
<a name="ln5562">		rv = 1;</a>
<a name="ln5563">		goto out;</a>
<a name="ln5564">	}</a>
<a name="ln5565"> </a>
<a name="ln5566">	/* firmware chunk loaded */</a>
<a name="ln5567">	if (r1 &amp; IWM_CSR_INT_BIT_FH_TX) {</a>
<a name="ln5568">		IWM_WRITE(sc, IWM_CSR_FH_INT_STATUS, IWM_CSR_FH_INT_TX_MASK);</a>
<a name="ln5569">		handled |= IWM_CSR_INT_BIT_FH_TX;</a>
<a name="ln5570">		sc-&gt;sc_fw_chunk_done = 1;</a>
<a name="ln5571">		wakeup(&amp;sc-&gt;sc_fw);</a>
<a name="ln5572">	}</a>
<a name="ln5573"> </a>
<a name="ln5574">	if (r1 &amp; IWM_CSR_INT_BIT_RF_KILL) {</a>
<a name="ln5575">		handled |= IWM_CSR_INT_BIT_RF_KILL;</a>
<a name="ln5576">		if (iwm_check_rfkill(sc)) {</a>
<a name="ln5577">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln5578">			    &quot;%s: rfkill switch, disabling interface\n&quot;,</a>
<a name="ln5579">			    __func__);</a>
<a name="ln5580">			iwm_stop(sc);</a>
<a name="ln5581">		}</a>
<a name="ln5582">	}</a>
<a name="ln5583"> </a>
<a name="ln5584">	/*</a>
<a name="ln5585">	 * The Linux driver uses periodic interrupts to avoid races.</a>
<a name="ln5586">	 * We cargo-cult like it's going out of fashion.</a>
<a name="ln5587">	 */</a>
<a name="ln5588">	if (r1 &amp; IWM_CSR_INT_BIT_RX_PERIODIC) {</a>
<a name="ln5589">		handled |= IWM_CSR_INT_BIT_RX_PERIODIC;</a>
<a name="ln5590">		IWM_WRITE(sc, IWM_CSR_INT, IWM_CSR_INT_BIT_RX_PERIODIC);</a>
<a name="ln5591">		if ((r1 &amp; (IWM_CSR_INT_BIT_FH_RX | IWM_CSR_INT_BIT_SW_RX)) == 0)</a>
<a name="ln5592">			IWM_WRITE_1(sc,</a>
<a name="ln5593">			    IWM_CSR_INT_PERIODIC_REG, IWM_CSR_INT_PERIODIC_DIS);</a>
<a name="ln5594">		isperiodic = 1;</a>
<a name="ln5595">	}</a>
<a name="ln5596"> </a>
<a name="ln5597">	if ((r1 &amp; (IWM_CSR_INT_BIT_FH_RX | IWM_CSR_INT_BIT_SW_RX)) || isperiodic) {</a>
<a name="ln5598">		handled |= (IWM_CSR_INT_BIT_FH_RX | IWM_CSR_INT_BIT_SW_RX);</a>
<a name="ln5599">		IWM_WRITE(sc, IWM_CSR_FH_INT_STATUS, IWM_CSR_FH_INT_RX_MASK);</a>
<a name="ln5600"> </a>
<a name="ln5601">		iwm_notif_intr(sc);</a>
<a name="ln5602"> </a>
<a name="ln5603">		/* enable periodic interrupt, see above */</a>
<a name="ln5604">		if (r1 &amp; (IWM_CSR_INT_BIT_FH_RX | IWM_CSR_INT_BIT_SW_RX) &amp;&amp; !isperiodic)</a>
<a name="ln5605">			IWM_WRITE_1(sc, IWM_CSR_INT_PERIODIC_REG,</a>
<a name="ln5606">			    IWM_CSR_INT_PERIODIC_ENA);</a>
<a name="ln5607">	}</a>
<a name="ln5608"> </a>
<a name="ln5609">	if (__predict_false(r1 &amp; ~handled))</a>
<a name="ln5610">		IWM_DPRINTF(sc, IWM_DEBUG_INTR,</a>
<a name="ln5611">		    &quot;%s: unhandled interrupts: %x\n&quot;, __func__, r1);</a>
<a name="ln5612">	rv = 1;</a>
<a name="ln5613"> </a>
<a name="ln5614"> out_ena:</a>
<a name="ln5615">	iwm_restore_interrupts(sc);</a>
<a name="ln5616"> out:</a>
<a name="ln5617">	IWM_UNLOCK(sc);</a>
<a name="ln5618">	return;</a>
<a name="ln5619">}</a>
<a name="ln5620"> </a>
<a name="ln5621">/*</a>
<a name="ln5622"> * Autoconf glue-sniffing</a>
<a name="ln5623"> */</a>
<a name="ln5624">#define	PCI_VENDOR_INTEL		0x8086</a>
<a name="ln5625">#define	PCI_PRODUCT_INTEL_WL_3160_1	0x08b3</a>
<a name="ln5626">#define	PCI_PRODUCT_INTEL_WL_3160_2	0x08b4</a>
<a name="ln5627">#define	PCI_PRODUCT_INTEL_WL_3165_1	0x3165</a>
<a name="ln5628">#define	PCI_PRODUCT_INTEL_WL_3165_2	0x3166</a>
<a name="ln5629">#define	PCI_PRODUCT_INTEL_WL_3168_1	0x24fb</a>
<a name="ln5630">#define	PCI_PRODUCT_INTEL_WL_7260_1	0x08b1</a>
<a name="ln5631">#define	PCI_PRODUCT_INTEL_WL_7260_2	0x08b2</a>
<a name="ln5632">#define	PCI_PRODUCT_INTEL_WL_7265_1	0x095a</a>
<a name="ln5633">#define	PCI_PRODUCT_INTEL_WL_7265_2	0x095b</a>
<a name="ln5634">#define	PCI_PRODUCT_INTEL_WL_8260_1	0x24f3</a>
<a name="ln5635">#define	PCI_PRODUCT_INTEL_WL_8260_2	0x24f4</a>
<a name="ln5636">#define	PCI_PRODUCT_INTEL_WL_8265_1	0x24fd</a>
<a name="ln5637"> </a>
<a name="ln5638">static const struct iwm_devices {</a>
<a name="ln5639">	uint16_t		device;</a>
<a name="ln5640">	const struct iwm_cfg	*cfg;</a>
<a name="ln5641">} iwm_devices[] = {</a>
<a name="ln5642">	{ PCI_PRODUCT_INTEL_WL_3160_1, &amp;iwm3160_cfg },</a>
<a name="ln5643">	{ PCI_PRODUCT_INTEL_WL_3160_2, &amp;iwm3160_cfg },</a>
<a name="ln5644">	{ PCI_PRODUCT_INTEL_WL_3165_1, &amp;iwm3165_cfg },</a>
<a name="ln5645">	{ PCI_PRODUCT_INTEL_WL_3165_2, &amp;iwm3165_cfg },</a>
<a name="ln5646">	{ PCI_PRODUCT_INTEL_WL_3168_1, &amp;iwm3168_cfg },</a>
<a name="ln5647">	{ PCI_PRODUCT_INTEL_WL_7260_1, &amp;iwm7260_cfg },</a>
<a name="ln5648">	{ PCI_PRODUCT_INTEL_WL_7260_2, &amp;iwm7260_cfg },</a>
<a name="ln5649">	{ PCI_PRODUCT_INTEL_WL_7265_1, &amp;iwm7265_cfg },</a>
<a name="ln5650">	{ PCI_PRODUCT_INTEL_WL_7265_2, &amp;iwm7265_cfg },</a>
<a name="ln5651">	{ PCI_PRODUCT_INTEL_WL_8260_1, &amp;iwm8260_cfg },</a>
<a name="ln5652">	{ PCI_PRODUCT_INTEL_WL_8260_2, &amp;iwm8260_cfg },</a>
<a name="ln5653">	{ PCI_PRODUCT_INTEL_WL_8265_1, &amp;iwm8265_cfg },</a>
<a name="ln5654">};</a>
<a name="ln5655"> </a>
<a name="ln5656">static int</a>
<a name="ln5657">iwm_probe(device_t dev)</a>
<a name="ln5658">{</a>
<a name="ln5659">	int i;</a>
<a name="ln5660"> </a>
<a name="ln5661">	for (i = 0; i &lt; nitems(iwm_devices); i++) {</a>
<a name="ln5662">		if (pci_get_vendor(dev) == PCI_VENDOR_INTEL &amp;&amp;</a>
<a name="ln5663">		    pci_get_device(dev) == iwm_devices[i].device) {</a>
<a name="ln5664">			device_set_desc(dev, iwm_devices[i].cfg-&gt;name);</a>
<a name="ln5665">			return (BUS_PROBE_DEFAULT);</a>
<a name="ln5666">		}</a>
<a name="ln5667">	}</a>
<a name="ln5668"> </a>
<a name="ln5669">	return (ENXIO);</a>
<a name="ln5670">}</a>
<a name="ln5671"> </a>
<a name="ln5672">static int</a>
<a name="ln5673">iwm_dev_check(device_t dev)</a>
<a name="ln5674">{</a>
<a name="ln5675">	struct iwm_softc *sc;</a>
<a name="ln5676">	uint16_t devid;</a>
<a name="ln5677">	int i;</a>
<a name="ln5678"> </a>
<a name="ln5679">	sc = device_get_softc(dev);</a>
<a name="ln5680"> </a>
<a name="ln5681">	devid = pci_get_device(dev);</a>
<a name="ln5682">	for (i = 0; i &lt; nitems(iwm_devices); i++) {</a>
<a name="ln5683">		if (iwm_devices[i].device == devid) {</a>
<a name="ln5684">			sc-&gt;cfg = iwm_devices[i].cfg;</a>
<a name="ln5685">			return (0);</a>
<a name="ln5686">		}</a>
<a name="ln5687">	}</a>
<a name="ln5688">	device_printf(dev, &quot;unknown adapter type\n&quot;);</a>
<a name="ln5689">	return ENXIO;</a>
<a name="ln5690">}</a>
<a name="ln5691"> </a>
<a name="ln5692">/* PCI registers */</a>
<a name="ln5693">#define PCI_CFG_RETRY_TIMEOUT	0x041</a>
<a name="ln5694"> </a>
<a name="ln5695">static int</a>
<a name="ln5696">iwm_pci_attach(device_t dev)</a>
<a name="ln5697">{</a>
<a name="ln5698">	struct iwm_softc *sc;</a>
<a name="ln5699">	int count, error, rid;</a>
<a name="ln5700">	uint16_t reg;</a>
<a name="ln5701"> </a>
<a name="ln5702">	sc = device_get_softc(dev);</a>
<a name="ln5703"> </a>
<a name="ln5704">	/* We disable the RETRY_TIMEOUT register (0x41) to keep</a>
<a name="ln5705">	 * PCI Tx retries from interfering with C3 CPU state */</a>
<a name="ln5706">	pci_write_config(dev, PCI_CFG_RETRY_TIMEOUT, 0x00, 1);</a>
<a name="ln5707"> </a>
<a name="ln5708">	/* Enable bus-mastering and hardware bug workaround. */</a>
<a name="ln5709">	pci_enable_busmaster(dev);</a>
<a name="ln5710">	reg = pci_read_config(dev, PCIR_STATUS, sizeof(reg));</a>
<a name="ln5711">	/* if !MSI */</a>
<a name="ln5712">	if (reg &amp; PCIM_STATUS_INTxSTATE) {</a>
<a name="ln5713">		reg &amp;= ~PCIM_STATUS_INTxSTATE;</a>
<a name="ln5714">	}</a>
<a name="ln5715">	pci_write_config(dev, PCIR_STATUS, reg, sizeof(reg));</a>
<a name="ln5716"> </a>
<a name="ln5717">	rid = PCIR_BAR(0);</a>
<a name="ln5718">	sc-&gt;sc_mem = bus_alloc_resource_any(dev, SYS_RES_MEMORY, &amp;rid,</a>
<a name="ln5719">	    RF_ACTIVE);</a>
<a name="ln5720">	if (sc-&gt;sc_mem == NULL) {</a>
<a name="ln5721">		device_printf(sc-&gt;sc_dev, &quot;can't map mem space\n&quot;);</a>
<a name="ln5722">		return (ENXIO);</a>
<a name="ln5723">	}</a>
<a name="ln5724">	sc-&gt;sc_st = rman_get_bustag(sc-&gt;sc_mem);</a>
<a name="ln5725">	sc-&gt;sc_sh = rman_get_bushandle(sc-&gt;sc_mem);</a>
<a name="ln5726"> </a>
<a name="ln5727">	/* Install interrupt handler. */</a>
<a name="ln5728">	count = 1;</a>
<a name="ln5729">	rid = 0;</a>
<a name="ln5730">	if (pci_alloc_msi(dev, &amp;count) == 0)</a>
<a name="ln5731">		rid = 1;</a>
<a name="ln5732">	sc-&gt;sc_irq = bus_alloc_resource_any(dev, SYS_RES_IRQ, &amp;rid, RF_ACTIVE |</a>
<a name="ln5733">	    (rid != 0 ? 0 : RF_SHAREABLE));</a>
<a name="ln5734">	if (sc-&gt;sc_irq == NULL) {</a>
<a name="ln5735">		device_printf(dev, &quot;can't map interrupt\n&quot;);</a>
<a name="ln5736">			return (ENXIO);</a>
<a name="ln5737">	}</a>
<a name="ln5738">	error = bus_setup_intr(dev, sc-&gt;sc_irq, INTR_TYPE_NET | INTR_MPSAFE,</a>
<a name="ln5739">	    NULL, iwm_intr, sc, &amp;sc-&gt;sc_ih);</a>
<a name="ln5740">	if (sc-&gt;sc_ih == NULL) {</a>
<a name="ln5741">		device_printf(dev, &quot;can't establish interrupt&quot;);</a>
<a name="ln5742">			return (ENXIO);</a>
<a name="ln5743">	}</a>
<a name="ln5744">	sc-&gt;sc_dmat = bus_get_dma_tag(sc-&gt;sc_dev);</a>
<a name="ln5745"> </a>
<a name="ln5746">	return (0);</a>
<a name="ln5747">}</a>
<a name="ln5748"> </a>
<a name="ln5749">static void</a>
<a name="ln5750">iwm_pci_detach(device_t dev)</a>
<a name="ln5751">{</a>
<a name="ln5752">	struct iwm_softc *sc = device_get_softc(dev);</a>
<a name="ln5753"> </a>
<a name="ln5754">	if (sc-&gt;sc_irq != NULL) {</a>
<a name="ln5755">		bus_teardown_intr(dev, sc-&gt;sc_irq, sc-&gt;sc_ih);</a>
<a name="ln5756">		bus_release_resource(dev, SYS_RES_IRQ,</a>
<a name="ln5757">		    rman_get_rid(sc-&gt;sc_irq), sc-&gt;sc_irq);</a>
<a name="ln5758">		pci_release_msi(dev);</a>
<a name="ln5759">        }</a>
<a name="ln5760">	if (sc-&gt;sc_mem != NULL)</a>
<a name="ln5761">		bus_release_resource(dev, SYS_RES_MEMORY,</a>
<a name="ln5762">		    rman_get_rid(sc-&gt;sc_mem), sc-&gt;sc_mem);</a>
<a name="ln5763">}</a>
<a name="ln5764"> </a>
<a name="ln5765"> </a>
<a name="ln5766"> </a>
<a name="ln5767">static int</a>
<a name="ln5768">iwm_attach(device_t dev)</a>
<a name="ln5769">{</a>
<a name="ln5770">	struct iwm_softc *sc = device_get_softc(dev);</a>
<a name="ln5771">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln5772">	int error;</a>
<a name="ln5773">	int txq_i, i;</a>
<a name="ln5774"> </a>
<a name="ln5775">	sc-&gt;sc_dev = dev;</a>
<a name="ln5776">	sc-&gt;sc_attached = 1;</a>
<a name="ln5777">	IWM_LOCK_INIT(sc);</a>
<a name="ln5778">	mbufq_init(&amp;sc-&gt;sc_snd, ifqmaxlen);</a>
<a name="ln5779">	callout_init_mtx(&amp;sc-&gt;sc_watchdog_to, &amp;sc-&gt;sc_mtx, 0);</a>
<a name="ln5780">	callout_init_mtx(&amp;sc-&gt;sc_led_blink_to, &amp;sc-&gt;sc_mtx, 0);</a>
<a name="ln5781">	TASK_INIT(&amp;sc-&gt;sc_es_task, 0, iwm_endscan_cb, sc);</a>
<a name="ln5782"> </a>
<a name="ln5783">	sc-&gt;sc_notif_wait = iwm_notification_wait_init(sc);</a>
<a name="ln5784">	if (sc-&gt;sc_notif_wait == NULL) {</a>
<a name="ln5785">		device_printf(dev, &quot;failed to init notification wait struct\n&quot;);</a>
<a name="ln5786">		goto fail;</a>
<a name="ln5787">	}</a>
<a name="ln5788"> </a>
<a name="ln5789">	sc-&gt;sf_state = IWM_SF_UNINIT;</a>
<a name="ln5790"> </a>
<a name="ln5791">	/* Init phy db */</a>
<a name="ln5792">	sc-&gt;sc_phy_db = iwm_phy_db_init(sc);</a>
<a name="ln5793">	if (!sc-&gt;sc_phy_db) {</a>
<a name="ln5794">		device_printf(dev, &quot;Cannot init phy_db\n&quot;);</a>
<a name="ln5795">		goto fail;</a>
<a name="ln5796">	}</a>
<a name="ln5797"> </a>
<a name="ln5798">	/* Set EBS as successful as long as not stated otherwise by the FW. */</a>
<a name="ln5799">	sc-&gt;last_ebs_successful = TRUE;</a>
<a name="ln5800"> </a>
<a name="ln5801">	/* PCI attach */</a>
<a name="ln5802">	error = iwm_pci_attach(dev);</a>
<a name="ln5803">	if (error != 0)</a>
<a name="ln5804">		goto fail;</a>
<a name="ln5805"> </a>
<a name="ln5806">	sc-&gt;sc_wantresp = -1;</a>
<a name="ln5807"> </a>
<a name="ln5808">	/* Match device id */</a>
<a name="ln5809">	error = iwm_dev_check(dev);</a>
<a name="ln5810">	if (error != 0)</a>
<a name="ln5811">		goto fail;</a>
<a name="ln5812"> </a>
<a name="ln5813">	sc-&gt;sc_hw_rev = IWM_READ(sc, IWM_CSR_HW_REV);</a>
<a name="ln5814">	/*</a>
<a name="ln5815">	 * In the 8000 HW family the format of the 4 bytes of CSR_HW_REV have</a>
<a name="ln5816">	 * changed, and now the revision step also includes bit 0-1 (no more</a>
<a name="ln5817">	 * &quot;dash&quot; value). To keep hw_rev backwards compatible - we'll store it</a>
<a name="ln5818">	 * in the old format.</a>
<a name="ln5819">	 */</a>
<a name="ln5820">	if (sc-&gt;cfg-&gt;device_family == IWM_DEVICE_FAMILY_8000) {</a>
<a name="ln5821">		int ret;</a>
<a name="ln5822">		uint32_t hw_step;</a>
<a name="ln5823"> </a>
<a name="ln5824">		sc-&gt;sc_hw_rev = (sc-&gt;sc_hw_rev &amp; 0xfff0) |</a>
<a name="ln5825">				(IWM_CSR_HW_REV_STEP(sc-&gt;sc_hw_rev &lt;&lt; 2) &lt;&lt; 2);</a>
<a name="ln5826"> </a>
<a name="ln5827">		if (iwm_prepare_card_hw(sc) != 0) {</a>
<a name="ln5828">			device_printf(dev, &quot;could not initialize hardware\n&quot;);</a>
<a name="ln5829">			goto fail;</a>
<a name="ln5830">		}</a>
<a name="ln5831"> </a>
<a name="ln5832">		/*</a>
<a name="ln5833">		 * In order to recognize C step the driver should read the</a>
<a name="ln5834">		 * chip version id located at the AUX bus MISC address.</a>
<a name="ln5835">		 */</a>
<a name="ln5836">		IWM_SETBITS(sc, IWM_CSR_GP_CNTRL,</a>
<a name="ln5837">			    IWM_CSR_GP_CNTRL_REG_FLAG_INIT_DONE);</a>
<a name="ln5838">		DELAY(2);</a>
<a name="ln5839"> </a>
<a name="ln5840">		ret = iwm_poll_bit(sc, IWM_CSR_GP_CNTRL,</a>
<a name="ln5841">				   IWM_CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY,</a>
<a name="ln5842">				   IWM_CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY,</a>
<a name="ln5843">				   25000);</a>
<a name="ln5844">		if (!ret) {</a>
<a name="ln5845">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln5846">			    &quot;Failed to wake up the nic\n&quot;);</a>
<a name="ln5847">			goto fail;</a>
<a name="ln5848">		}</a>
<a name="ln5849"> </a>
<a name="ln5850">		if (iwm_nic_lock(sc)) {</a>
<a name="ln5851">			hw_step = iwm_read_prph(sc, IWM_WFPM_CTRL_REG);</a>
<a name="ln5852">			hw_step |= IWM_ENABLE_WFPM;</a>
<a name="ln5853">			iwm_write_prph(sc, IWM_WFPM_CTRL_REG, hw_step);</a>
<a name="ln5854">			hw_step = iwm_read_prph(sc, IWM_AUX_MISC_REG);</a>
<a name="ln5855">			hw_step = (hw_step &gt;&gt; IWM_HW_STEP_LOCATION_BITS) &amp; 0xF;</a>
<a name="ln5856">			if (hw_step == 0x3)</a>
<a name="ln5857">				sc-&gt;sc_hw_rev = (sc-&gt;sc_hw_rev &amp; 0xFFFFFFF3) |</a>
<a name="ln5858">						(IWM_SILICON_C_STEP &lt;&lt; 2);</a>
<a name="ln5859">			iwm_nic_unlock(sc);</a>
<a name="ln5860">		} else {</a>
<a name="ln5861">			device_printf(sc-&gt;sc_dev, &quot;Failed to lock the nic\n&quot;);</a>
<a name="ln5862">			goto fail;</a>
<a name="ln5863">		}</a>
<a name="ln5864">	}</a>
<a name="ln5865"> </a>
<a name="ln5866">	/* special-case 7265D, it has the same PCI IDs. */</a>
<a name="ln5867">	if (sc-&gt;cfg == &amp;iwm7265_cfg &amp;&amp;</a>
<a name="ln5868">	    (sc-&gt;sc_hw_rev &amp; IWM_CSR_HW_REV_TYPE_MSK) == IWM_CSR_HW_REV_TYPE_7265D) {</a>
<a name="ln5869">		sc-&gt;cfg = &amp;iwm7265d_cfg;</a>
<a name="ln5870">	}</a>
<a name="ln5871"> </a>
<a name="ln5872">	/* Allocate DMA memory for firmware transfers. */</a>
<a name="ln5873">	if ((error = iwm_alloc_fwmem(sc)) != 0) {</a>
<a name="ln5874">		device_printf(dev, &quot;could not allocate memory for firmware\n&quot;);</a>
<a name="ln5875">		goto fail;</a>
<a name="ln5876">	}</a>
<a name="ln5877"> </a>
<a name="ln5878">	/* Allocate &quot;Keep Warm&quot; page. */</a>
<a name="ln5879">	if ((error = iwm_alloc_kw(sc)) != 0) {</a>
<a name="ln5880">		device_printf(dev, &quot;could not allocate keep warm page\n&quot;);</a>
<a name="ln5881">		goto fail;</a>
<a name="ln5882">	}</a>
<a name="ln5883"> </a>
<a name="ln5884">	/* We use ICT interrupts */</a>
<a name="ln5885">	if ((error = iwm_alloc_ict(sc)) != 0) {</a>
<a name="ln5886">		device_printf(dev, &quot;could not allocate ICT table\n&quot;);</a>
<a name="ln5887">		goto fail;</a>
<a name="ln5888">	}</a>
<a name="ln5889"> </a>
<a name="ln5890">	/* Allocate TX scheduler &quot;rings&quot;. */</a>
<a name="ln5891">	if ((error = iwm_alloc_sched(sc)) != 0) {</a>
<a name="ln5892">		device_printf(dev, &quot;could not allocate TX scheduler rings\n&quot;);</a>
<a name="ln5893">		goto fail;</a>
<a name="ln5894">	}</a>
<a name="ln5895"> </a>
<a name="ln5896">	/* Allocate TX rings */</a>
<a name="ln5897">	for (txq_i = 0; txq_i &lt; nitems(sc-&gt;txq); txq_i++) {</a>
<a name="ln5898">		if ((error = iwm_alloc_tx_ring(sc,</a>
<a name="ln5899">		    &amp;sc-&gt;txq[txq_i], txq_i)) != 0) {</a>
<a name="ln5900">			device_printf(dev,</a>
<a name="ln5901">			    &quot;could not allocate TX ring %d\n&quot;,</a>
<a name="ln5902">			    txq_i);</a>
<a name="ln5903">			goto fail;</a>
<a name="ln5904">		}</a>
<a name="ln5905">	}</a>
<a name="ln5906"> </a>
<a name="ln5907">	/* Allocate RX ring. */</a>
<a name="ln5908">	if ((error = iwm_alloc_rx_ring(sc, &amp;sc-&gt;rxq)) != 0) {</a>
<a name="ln5909">		device_printf(dev, &quot;could not allocate RX ring\n&quot;);</a>
<a name="ln5910">		goto fail;</a>
<a name="ln5911">	}</a>
<a name="ln5912"> </a>
<a name="ln5913">	/* Clear pending interrupts. */</a>
<a name="ln5914">	IWM_WRITE(sc, IWM_CSR_INT, 0xffffffff);</a>
<a name="ln5915"> </a>
<a name="ln5916">	ic-&gt;ic_softc = sc;</a>
<a name="ln5917">	ic-&gt;ic_name = device_get_nameunit(sc-&gt;sc_dev);</a>
<a name="ln5918">	ic-&gt;ic_phytype = IEEE80211_T_OFDM;	/* not only, but not used */</a>
<a name="ln5919">	ic-&gt;ic_opmode = IEEE80211_M_STA;	/* default to BSS mode */</a>
<a name="ln5920"> </a>
<a name="ln5921">	/* Set device capabilities. */</a>
<a name="ln5922">	ic-&gt;ic_caps =</a>
<a name="ln5923">	    IEEE80211_C_STA |</a>
<a name="ln5924">	    IEEE80211_C_WPA |		/* WPA/RSN */</a>
<a name="ln5925">	    IEEE80211_C_WME |</a>
<a name="ln5926">	    IEEE80211_C_PMGT |</a>
<a name="ln5927">	    IEEE80211_C_SHSLOT |	/* short slot time supported */</a>
<a name="ln5928">	    IEEE80211_C_SHPREAMBLE	/* short preamble supported */</a>
<a name="ln5929">//	    IEEE80211_C_BGSCAN		/* capable of bg scanning */</a>
<a name="ln5930">	    ;</a>
<a name="ln5931">	/* Advertise full-offload scanning */</a>
<a name="ln5932">	ic-&gt;ic_flags_ext = IEEE80211_FEXT_SCAN_OFFLOAD;</a>
<a name="ln5933">	for (i = 0; i &lt; nitems(sc-&gt;sc_phyctxt); i++) {</a>
<a name="ln5934">		sc-&gt;sc_phyctxt[i].id = i;</a>
<a name="ln5935">		sc-&gt;sc_phyctxt[i].color = 0;</a>
<a name="ln5936">		sc-&gt;sc_phyctxt[i].ref = 0;</a>
<a name="ln5937">		sc-&gt;sc_phyctxt[i].channel = NULL;</a>
<a name="ln5938">	}</a>
<a name="ln5939"> </a>
<a name="ln5940">	/* Default noise floor */</a>
<a name="ln5941">	sc-&gt;sc_noise = -96;</a>
<a name="ln5942"> </a>
<a name="ln5943">	/* Max RSSI */</a>
<a name="ln5944">	sc-&gt;sc_max_rssi = IWM_MAX_DBM - IWM_MIN_DBM;</a>
<a name="ln5945"> </a>
<a name="ln5946">#ifdef IWM_DEBUG</a>
<a name="ln5947">	SYSCTL_ADD_INT(device_get_sysctl_ctx(dev),</a>
<a name="ln5948">	    SYSCTL_CHILDREN(device_get_sysctl_tree(dev)), OID_AUTO, &quot;debug&quot;,</a>
<a name="ln5949">	    CTLFLAG_RW, &amp;sc-&gt;sc_debug, 0, &quot;control debugging&quot;);</a>
<a name="ln5950">#endif</a>
<a name="ln5951"> </a>
<a name="ln5952">	error = iwm_read_firmware(sc);</a>
<a name="ln5953">	if (error) {</a>
<a name="ln5954">		goto fail;</a>
<a name="ln5955">	} else if (sc-&gt;sc_fw.fw_fp == NULL) {</a>
<a name="ln5956">		/*</a>
<a name="ln5957">		 * XXX Add a solution for properly deferring firmware load</a>
<a name="ln5958">		 *     during bootup.</a>
<a name="ln5959">		 */</a>
<a name="ln5960">		goto fail;</a>
<a name="ln5961">	} else {</a>
<a name="ln5962">		sc-&gt;sc_preinit_hook.ich_func = iwm_preinit;</a>
<a name="ln5963">		sc-&gt;sc_preinit_hook.ich_arg = sc;</a>
<a name="ln5964">		if (config_intrhook_establish(&amp;sc-&gt;sc_preinit_hook) != 0) {</a>
<a name="ln5965">			device_printf(dev,</a>
<a name="ln5966">			    &quot;config_intrhook_establish failed\n&quot;);</a>
<a name="ln5967">			goto fail;</a>
<a name="ln5968">		}</a>
<a name="ln5969">	}</a>
<a name="ln5970"> </a>
<a name="ln5971">	IWM_DPRINTF(sc, IWM_DEBUG_RESET | IWM_DEBUG_TRACE,</a>
<a name="ln5972">	    &quot;&lt;-%s\n&quot;, __func__);</a>
<a name="ln5973"> </a>
<a name="ln5974">	return 0;</a>
<a name="ln5975"> </a>
<a name="ln5976">	/* Free allocated memory if something failed during attachment. */</a>
<a name="ln5977">fail:</a>
<a name="ln5978">	iwm_detach_local(sc, 0);</a>
<a name="ln5979"> </a>
<a name="ln5980">	return ENXIO;</a>
<a name="ln5981">}</a>
<a name="ln5982"> </a>
<a name="ln5983">static int</a>
<a name="ln5984">iwm_is_valid_ether_addr(uint8_t *addr)</a>
<a name="ln5985">{</a>
<a name="ln5986">	char zero_addr[IEEE80211_ADDR_LEN] = { 0, 0, 0, 0, 0, 0 };</a>
<a name="ln5987"> </a>
<a name="ln5988">	if ((addr[0] &amp; 1) || IEEE80211_ADDR_EQ(zero_addr, addr))</a>
<a name="ln5989">		return (FALSE);</a>
<a name="ln5990"> </a>
<a name="ln5991">	return (TRUE);</a>
<a name="ln5992">}</a>
<a name="ln5993"> </a>
<a name="ln5994">static int</a>
<a name="ln5995">iwm_wme_update(struct ieee80211com *ic)</a>
<a name="ln5996">{</a>
<a name="ln5997">#define IWM_EXP2(x)	((1 &lt;&lt; (x)) - 1)	/* CWmin = 2^ECWmin - 1 */</a>
<a name="ln5998">	struct iwm_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln5999">	struct chanAccParams chp;</a>
<a name="ln6000">	struct ieee80211vap *vap = TAILQ_FIRST(&amp;ic-&gt;ic_vaps);</a>
<a name="ln6001">	struct iwm_vap *ivp = IWM_VAP(vap);</a>
<a name="ln6002">	struct iwm_node *in;</a>
<a name="ln6003">	struct wmeParams tmp[WME_NUM_AC];</a>
<a name="ln6004">	int aci, error;</a>
<a name="ln6005"> </a>
<a name="ln6006">	if (vap == NULL)</a>
<a name="ln6007">		return (0);</a>
<a name="ln6008"> </a>
<a name="ln6009">	ieee80211_wme_ic_getparams(ic, &amp;chp);</a>
<a name="ln6010"> </a>
<a name="ln6011">	IEEE80211_LOCK(ic);</a>
<a name="ln6012">	for (aci = 0; aci &lt; WME_NUM_AC; aci++)</a>
<a name="ln6013">		tmp[aci] = chp.cap_wmeParams[aci];</a>
<a name="ln6014">	IEEE80211_UNLOCK(ic);</a>
<a name="ln6015"> </a>
<a name="ln6016">	IWM_LOCK(sc);</a>
<a name="ln6017">	for (aci = 0; aci &lt; WME_NUM_AC; aci++) {</a>
<a name="ln6018">		const struct wmeParams *ac = &amp;tmp[aci];</a>
<a name="ln6019">		ivp-&gt;queue_params[aci].aifsn = ac-&gt;wmep_aifsn;</a>
<a name="ln6020">		ivp-&gt;queue_params[aci].cw_min = IWM_EXP2(ac-&gt;wmep_logcwmin);</a>
<a name="ln6021">		ivp-&gt;queue_params[aci].cw_max = IWM_EXP2(ac-&gt;wmep_logcwmax);</a>
<a name="ln6022">		ivp-&gt;queue_params[aci].edca_txop =</a>
<a name="ln6023">		    IEEE80211_TXOP_TO_US(ac-&gt;wmep_txopLimit);</a>
<a name="ln6024">	}</a>
<a name="ln6025">	ivp-&gt;have_wme = TRUE;</a>
<a name="ln6026">	if (ivp-&gt;is_uploaded &amp;&amp; vap-&gt;iv_bss != NULL) {</a>
<a name="ln6027">		in = IWM_NODE(vap-&gt;iv_bss);</a>
<a name="ln6028">		if (in-&gt;in_assoc) {</a>
<a name="ln6029">			if ((error = iwm_mvm_mac_ctxt_changed(sc, vap)) != 0) {</a>
<a name="ln6030">				device_printf(sc-&gt;sc_dev,</a>
<a name="ln6031">				    &quot;%s: failed to update MAC\n&quot;, __func__);</a>
<a name="ln6032">			}</a>
<a name="ln6033">		}</a>
<a name="ln6034">	}</a>
<a name="ln6035">	IWM_UNLOCK(sc);</a>
<a name="ln6036"> </a>
<a name="ln6037">	return (0);</a>
<a name="ln6038">#undef IWM_EXP2</a>
<a name="ln6039">}</a>
<a name="ln6040"> </a>
<a name="ln6041">static void</a>
<a name="ln6042">iwm_preinit(void *arg)</a>
<a name="ln6043">{</a>
<a name="ln6044">	struct iwm_softc *sc = arg;</a>
<a name="ln6045">	device_t dev = sc-&gt;sc_dev;</a>
<a name="ln6046">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln6047">	int error;</a>
<a name="ln6048"> </a>
<a name="ln6049">	IWM_DPRINTF(sc, IWM_DEBUG_RESET | IWM_DEBUG_TRACE,</a>
<a name="ln6050">	    &quot;-&gt;%s\n&quot;, __func__);</a>
<a name="ln6051"> </a>
<a name="ln6052">	IWM_LOCK(sc);</a>
<a name="ln6053">	if ((error = iwm_start_hw(sc)) != 0) {</a>
<a name="ln6054">		device_printf(dev, &quot;could not initialize hardware\n&quot;);</a>
<a name="ln6055">		IWM_UNLOCK(sc);</a>
<a name="ln6056">		goto fail;</a>
<a name="ln6057">	}</a>
<a name="ln6058"> </a>
<a name="ln6059">	error = iwm_run_init_mvm_ucode(sc, 1);</a>
<a name="ln6060">	iwm_stop_device(sc);</a>
<a name="ln6061">	if (error) {</a>
<a name="ln6062">		IWM_UNLOCK(sc);</a>
<a name="ln6063">		goto fail;</a>
<a name="ln6064">	}</a>
<a name="ln6065">#ifndef __HAIKU__ /* This printf causes a KDL. Not sure why... */</a>
<a name="ln6066">	device_printf(dev,</a>
<a name="ln6067">	    &quot;hw rev 0x%x, fw ver %s, address %s\n&quot;,</a>
<a name="ln6068">	    sc-&gt;sc_hw_rev &amp; IWM_CSR_HW_REV_TYPE_MSK,</a>
<a name="ln6069">	    sc-&gt;sc_fwver, ether_sprintf(sc-&gt;nvm_data-&gt;hw_addr));</a>
<a name="ln6070">#endif</a>
<a name="ln6071"> </a>
<a name="ln6072">	/* not all hardware can do 5GHz band */</a>
<a name="ln6073">	if (!sc-&gt;nvm_data-&gt;sku_cap_band_52GHz_enable)</a>
<a name="ln6074">		memset(&amp;ic-&gt;ic_sup_rates[IEEE80211_MODE_11A], 0,</a>
<a name="ln6075">		    sizeof(ic-&gt;ic_sup_rates[IEEE80211_MODE_11A]));</a>
<a name="ln6076">	IWM_UNLOCK(sc);</a>
<a name="ln6077"> </a>
<a name="ln6078">	iwm_init_channel_map(ic, IEEE80211_CHAN_MAX, &amp;ic-&gt;ic_nchans,</a>
<a name="ln6079">	    ic-&gt;ic_channels);</a>
<a name="ln6080"> </a>
<a name="ln6081">	/*</a>
<a name="ln6082">	 * At this point we've committed - if we fail to do setup,</a>
<a name="ln6083">	 * we now also have to tear down the net80211 state.</a>
<a name="ln6084">	 */</a>
<a name="ln6085">	ieee80211_ifattach(ic);</a>
<a name="ln6086">	ic-&gt;ic_vap_create = iwm_vap_create;</a>
<a name="ln6087">	ic-&gt;ic_vap_delete = iwm_vap_delete;</a>
<a name="ln6088">	ic-&gt;ic_raw_xmit = iwm_raw_xmit;</a>
<a name="ln6089">	ic-&gt;ic_node_alloc = iwm_node_alloc;</a>
<a name="ln6090">	ic-&gt;ic_scan_start = iwm_scan_start;</a>
<a name="ln6091">	ic-&gt;ic_scan_end = iwm_scan_end;</a>
<a name="ln6092">	ic-&gt;ic_update_mcast = iwm_update_mcast;</a>
<a name="ln6093">	ic-&gt;ic_getradiocaps = iwm_init_channel_map;</a>
<a name="ln6094">	ic-&gt;ic_set_channel = iwm_set_channel;</a>
<a name="ln6095">	ic-&gt;ic_scan_curchan = iwm_scan_curchan;</a>
<a name="ln6096">	ic-&gt;ic_scan_mindwell = iwm_scan_mindwell;</a>
<a name="ln6097">	ic-&gt;ic_wme.wme_update = iwm_wme_update;</a>
<a name="ln6098">	ic-&gt;ic_parent = iwm_parent;</a>
<a name="ln6099">	ic-&gt;ic_transmit = iwm_transmit;</a>
<a name="ln6100">	iwm_radiotap_attach(sc);</a>
<a name="ln6101">	if (bootverbose)</a>
<a name="ln6102">		ieee80211_announce(ic);</a>
<a name="ln6103"> </a>
<a name="ln6104">	IWM_DPRINTF(sc, IWM_DEBUG_RESET | IWM_DEBUG_TRACE,</a>
<a name="ln6105">	    &quot;&lt;-%s\n&quot;, __func__);</a>
<a name="ln6106">	config_intrhook_disestablish(&amp;sc-&gt;sc_preinit_hook);</a>
<a name="ln6107"> </a>
<a name="ln6108">	return;</a>
<a name="ln6109">fail:</a>
<a name="ln6110">	config_intrhook_disestablish(&amp;sc-&gt;sc_preinit_hook);</a>
<a name="ln6111">	iwm_detach_local(sc, 0);</a>
<a name="ln6112">}</a>
<a name="ln6113"> </a>
<a name="ln6114">/*</a>
<a name="ln6115"> * Attach the interface to 802.11 radiotap.</a>
<a name="ln6116"> */</a>
<a name="ln6117">static void</a>
<a name="ln6118">iwm_radiotap_attach(struct iwm_softc *sc)</a>
<a name="ln6119">{</a>
<a name="ln6120">        struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln6121"> </a>
<a name="ln6122">	IWM_DPRINTF(sc, IWM_DEBUG_RESET | IWM_DEBUG_TRACE,</a>
<a name="ln6123">	    &quot;-&gt;%s begin\n&quot;, __func__);</a>
<a name="ln6124">        ieee80211_radiotap_attach(ic,</a>
<a name="ln6125">            &amp;sc-&gt;sc_txtap.wt_ihdr, sizeof(sc-&gt;sc_txtap),</a>
<a name="ln6126">                IWM_TX_RADIOTAP_PRESENT,</a>
<a name="ln6127">            &amp;sc-&gt;sc_rxtap.wr_ihdr, sizeof(sc-&gt;sc_rxtap),</a>
<a name="ln6128">                IWM_RX_RADIOTAP_PRESENT);</a>
<a name="ln6129">	IWM_DPRINTF(sc, IWM_DEBUG_RESET | IWM_DEBUG_TRACE,</a>
<a name="ln6130">	    &quot;-&gt;%s end\n&quot;, __func__);</a>
<a name="ln6131">}</a>
<a name="ln6132"> </a>
<a name="ln6133">static struct ieee80211vap *</a>
<a name="ln6134">iwm_vap_create(struct ieee80211com *ic, const char name[IFNAMSIZ], int unit,</a>
<a name="ln6135">    enum ieee80211_opmode opmode, int flags,</a>
<a name="ln6136">    const uint8_t bssid[IEEE80211_ADDR_LEN],</a>
<a name="ln6137">    const uint8_t mac[IEEE80211_ADDR_LEN])</a>
<a name="ln6138">{</a>
<a name="ln6139">	struct iwm_vap *ivp;</a>
<a name="ln6140">	struct ieee80211vap *vap;</a>
<a name="ln6141"> </a>
<a name="ln6142">	if (!TAILQ_EMPTY(&amp;ic-&gt;ic_vaps))         /* only one at a time */</a>
<a name="ln6143">		return NULL;</a>
<a name="ln6144">	ivp = malloc(sizeof(struct iwm_vap), M_80211_VAP, M_WAITOK | M_ZERO);</a>
<a name="ln6145">	vap = &amp;ivp-&gt;iv_vap;</a>
<a name="ln6146">	ieee80211_vap_setup(ic, vap, name, unit, opmode, flags, bssid);</a>
<a name="ln6147">	vap-&gt;iv_bmissthreshold = 10;            /* override default */</a>
<a name="ln6148">	/* Override with driver methods. */</a>
<a name="ln6149">	ivp-&gt;iv_newstate = vap-&gt;iv_newstate;</a>
<a name="ln6150">	vap-&gt;iv_newstate = iwm_newstate;</a>
<a name="ln6151"> </a>
<a name="ln6152">	ivp-&gt;id = IWM_DEFAULT_MACID;</a>
<a name="ln6153">	ivp-&gt;color = IWM_DEFAULT_COLOR;</a>
<a name="ln6154"> </a>
<a name="ln6155">	ivp-&gt;have_wme = FALSE;</a>
<a name="ln6156">	ivp-&gt;ps_disabled = FALSE;</a>
<a name="ln6157"> </a>
<a name="ln6158">	ieee80211_ratectl_init(vap);</a>
<a name="ln6159">	/* Complete setup. */</a>
<a name="ln6160">	ieee80211_vap_attach(vap, iwm_media_change, ieee80211_media_status,</a>
<a name="ln6161">	    mac);</a>
<a name="ln6162">	ic-&gt;ic_opmode = opmode;</a>
<a name="ln6163"> </a>
<a name="ln6164">	return vap;</a>
<a name="ln6165">}</a>
<a name="ln6166"> </a>
<a name="ln6167">static void</a>
<a name="ln6168">iwm_vap_delete(struct ieee80211vap *vap)</a>
<a name="ln6169">{</a>
<a name="ln6170">	struct iwm_vap *ivp = IWM_VAP(vap);</a>
<a name="ln6171"> </a>
<a name="ln6172">	ieee80211_ratectl_deinit(vap);</a>
<a name="ln6173">	ieee80211_vap_detach(vap);</a>
<a name="ln6174">	free(ivp, M_80211_VAP);</a>
<a name="ln6175">}</a>
<a name="ln6176"> </a>
<a name="ln6177">static void</a>
<a name="ln6178">iwm_xmit_queue_drain(struct iwm_softc *sc)</a>
<a name="ln6179">{</a>
<a name="ln6180">	struct mbuf *m;</a>
<a name="ln6181">	struct ieee80211_node *ni;</a>
<a name="ln6182"> </a>
<a name="ln6183">	while ((m = mbufq_dequeue(&amp;sc-&gt;sc_snd)) != NULL) {</a>
<a name="ln6184">		ni = (struct ieee80211_node *)m-&gt;m_pkthdr.rcvif;</a>
<a name="ln6185">		ieee80211_free_node(ni);</a>
<a name="ln6186">		m_freem(m);</a>
<a name="ln6187">	}</a>
<a name="ln6188">}</a>
<a name="ln6189"> </a>
<a name="ln6190">static void</a>
<a name="ln6191">iwm_scan_start(struct ieee80211com *ic)</a>
<a name="ln6192">{</a>
<a name="ln6193">	struct ieee80211vap *vap = TAILQ_FIRST(&amp;ic-&gt;ic_vaps);</a>
<a name="ln6194">	struct iwm_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln6195">	int error;</a>
<a name="ln6196"> </a>
<a name="ln6197">	IWM_LOCK(sc);</a>
<a name="ln6198">	if (sc-&gt;sc_flags &amp; IWM_FLAG_SCAN_RUNNING) {</a>
<a name="ln6199">		/* This should not be possible */</a>
<a name="ln6200">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln6201">		    &quot;%s: Previous scan not completed yet\n&quot;, __func__);</a>
<a name="ln6202">	}</a>
<a name="ln6203">	if (fw_has_capa(&amp;sc-&gt;sc_fw.ucode_capa, IWM_UCODE_TLV_CAPA_UMAC_SCAN))</a>
<a name="ln6204">		error = iwm_mvm_umac_scan(sc);</a>
<a name="ln6205">	else</a>
<a name="ln6206">		error = iwm_mvm_lmac_scan(sc);</a>
<a name="ln6207">	if (error != 0) {</a>
<a name="ln6208">		device_printf(sc-&gt;sc_dev, &quot;could not initiate scan\n&quot;);</a>
<a name="ln6209">		IWM_UNLOCK(sc);</a>
<a name="ln6210">		ieee80211_cancel_scan(vap);</a>
<a name="ln6211">	} else {</a>
<a name="ln6212">		sc-&gt;sc_flags |= IWM_FLAG_SCAN_RUNNING;</a>
<a name="ln6213">		iwm_led_blink_start(sc);</a>
<a name="ln6214">		IWM_UNLOCK(sc);</a>
<a name="ln6215">	}</a>
<a name="ln6216">}</a>
<a name="ln6217"> </a>
<a name="ln6218">static void</a>
<a name="ln6219">iwm_scan_end(struct ieee80211com *ic)</a>
<a name="ln6220">{</a>
<a name="ln6221">	struct ieee80211vap *vap = TAILQ_FIRST(&amp;ic-&gt;ic_vaps);</a>
<a name="ln6222">	struct iwm_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln6223"> </a>
<a name="ln6224">	IWM_LOCK(sc);</a>
<a name="ln6225">	iwm_led_blink_stop(sc);</a>
<a name="ln6226">	if (vap-&gt;iv_state == IEEE80211_S_RUN)</a>
<a name="ln6227">		iwm_mvm_led_enable(sc);</a>
<a name="ln6228">	if (sc-&gt;sc_flags &amp; IWM_FLAG_SCAN_RUNNING) {</a>
<a name="ln6229">		/*</a>
<a name="ln6230">		 * Removing IWM_FLAG_SCAN_RUNNING now, is fine because</a>
<a name="ln6231">		 * both iwm_scan_end and iwm_scan_start run in the ic-&gt;ic_tq</a>
<a name="ln6232">		 * taskqueue.</a>
<a name="ln6233">		 */</a>
<a name="ln6234">		sc-&gt;sc_flags &amp;= ~IWM_FLAG_SCAN_RUNNING;</a>
<a name="ln6235">		iwm_mvm_scan_stop_wait(sc);</a>
<a name="ln6236">	}</a>
<a name="ln6237">	IWM_UNLOCK(sc);</a>
<a name="ln6238"> </a>
<a name="ln6239">	/*</a>
<a name="ln6240">	 * Make sure we don't race, if sc_es_task is still enqueued here.</a>
<a name="ln6241">	 * This is to make sure that it won't call ieee80211_scan_done</a>
<a name="ln6242">	 * when we have already started the next scan.</a>
<a name="ln6243">	 */</a>
<a name="ln6244">	taskqueue_cancel(ic-&gt;ic_tq, &amp;sc-&gt;sc_es_task, NULL);</a>
<a name="ln6245">}</a>
<a name="ln6246"> </a>
<a name="ln6247">static void</a>
<a name="ln6248">iwm_update_mcast(struct ieee80211com *ic)</a>
<a name="ln6249">{</a>
<a name="ln6250">}</a>
<a name="ln6251"> </a>
<a name="ln6252">static void</a>
<a name="ln6253">iwm_set_channel(struct ieee80211com *ic)</a>
<a name="ln6254">{</a>
<a name="ln6255">}</a>
<a name="ln6256"> </a>
<a name="ln6257">static void</a>
<a name="ln6258">iwm_scan_curchan(struct ieee80211_scan_state *ss, unsigned long maxdwell)</a>
<a name="ln6259">{</a>
<a name="ln6260">}</a>
<a name="ln6261"> </a>
<a name="ln6262">static void</a>
<a name="ln6263">iwm_scan_mindwell(struct ieee80211_scan_state *ss)</a>
<a name="ln6264">{</a>
<a name="ln6265">	return;</a>
<a name="ln6266">}</a>
<a name="ln6267"> </a>
<a name="ln6268">void</a>
<a name="ln6269">iwm_init_task(void *arg1)</a>
<a name="ln6270">{</a>
<a name="ln6271">	struct iwm_softc *sc = arg1;</a>
<a name="ln6272"> </a>
<a name="ln6273">	IWM_LOCK(sc);</a>
<a name="ln6274">	while (sc-&gt;sc_flags &amp; IWM_FLAG_BUSY)</a>
<a name="ln6275">		msleep(&amp;sc-&gt;sc_flags, &amp;sc-&gt;sc_mtx, 0, &quot;iwmpwr&quot;, 0);</a>
<a name="ln6276">	sc-&gt;sc_flags |= IWM_FLAG_BUSY;</a>
<a name="ln6277">	iwm_stop(sc);</a>
<a name="ln6278">	if (sc-&gt;sc_ic.ic_nrunning &gt; 0)</a>
<a name="ln6279">		iwm_init(sc);</a>
<a name="ln6280">	sc-&gt;sc_flags &amp;= ~IWM_FLAG_BUSY;</a>
<a name="ln6281">	wakeup(&amp;sc-&gt;sc_flags);</a>
<a name="ln6282">	IWM_UNLOCK(sc);</a>
<a name="ln6283">}</a>
<a name="ln6284"> </a>
<a name="ln6285">static int</a>
<a name="ln6286">iwm_resume(device_t dev)</a>
<a name="ln6287">{</a>
<a name="ln6288">	struct iwm_softc *sc = device_get_softc(dev);</a>
<a name="ln6289">	int do_reinit = 0;</a>
<a name="ln6290"> </a>
<a name="ln6291">	/*</a>
<a name="ln6292">	 * We disable the RETRY_TIMEOUT register (0x41) to keep</a>
<a name="ln6293">	 * PCI Tx retries from interfering with C3 CPU state.</a>
<a name="ln6294">	 */</a>
<a name="ln6295">	pci_write_config(dev, PCI_CFG_RETRY_TIMEOUT, 0x00, 1);</a>
<a name="ln6296"> </a>
<a name="ln6297">	if (!sc-&gt;sc_attached)</a>
<a name="ln6298">		return 0;</a>
<a name="ln6299"> </a>
<a name="ln6300">	iwm_init_task(device_get_softc(dev));</a>
<a name="ln6301"> </a>
<a name="ln6302">	IWM_LOCK(sc);</a>
<a name="ln6303">	if (sc-&gt;sc_flags &amp; IWM_FLAG_SCANNING) {</a>
<a name="ln6304">		sc-&gt;sc_flags &amp;= ~IWM_FLAG_SCANNING;</a>
<a name="ln6305">		do_reinit = 1;</a>
<a name="ln6306">	}</a>
<a name="ln6307">	IWM_UNLOCK(sc);</a>
<a name="ln6308"> </a>
<a name="ln6309">	if (do_reinit)</a>
<a name="ln6310">		ieee80211_resume_all(&amp;sc-&gt;sc_ic);</a>
<a name="ln6311"> </a>
<a name="ln6312">	return 0;</a>
<a name="ln6313">}</a>
<a name="ln6314"> </a>
<a name="ln6315">static int</a>
<a name="ln6316">iwm_suspend(device_t dev)</a>
<a name="ln6317">{</a>
<a name="ln6318">	int do_stop = 0;</a>
<a name="ln6319">	struct iwm_softc *sc = device_get_softc(dev);</a>
<a name="ln6320"> </a>
<a name="ln6321">	do_stop = !! (sc-&gt;sc_ic.ic_nrunning &gt; 0);</a>
<a name="ln6322"> </a>
<a name="ln6323">	if (!sc-&gt;sc_attached)</a>
<a name="ln6324">		return (0);</a>
<a name="ln6325"> </a>
<a name="ln6326">	ieee80211_suspend_all(&amp;sc-&gt;sc_ic);</a>
<a name="ln6327"> </a>
<a name="ln6328">	if (do_stop) {</a>
<a name="ln6329">		IWM_LOCK(sc);</a>
<a name="ln6330">		iwm_stop(sc);</a>
<a name="ln6331">		sc-&gt;sc_flags |= IWM_FLAG_SCANNING;</a>
<a name="ln6332">		IWM_UNLOCK(sc);</a>
<a name="ln6333">	}</a>
<a name="ln6334"> </a>
<a name="ln6335">	return (0);</a>
<a name="ln6336">}</a>
<a name="ln6337"> </a>
<a name="ln6338">static int</a>
<a name="ln6339">iwm_detach_local(struct iwm_softc *sc, int do_net80211)</a>
<a name="ln6340">{</a>
<a name="ln6341">	struct iwm_fw_info *fw = &amp;sc-&gt;sc_fw;</a>
<a name="ln6342">	device_t dev = sc-&gt;sc_dev;</a>
<a name="ln6343">	int i;</a>
<a name="ln6344"> </a>
<a name="ln6345">	if (!sc-&gt;sc_attached)</a>
<a name="ln6346">		return 0;</a>
<a name="ln6347">	sc-&gt;sc_attached = 0;</a>
<a name="ln6348"> </a>
<a name="ln6349">	if (do_net80211)</a>
<a name="ln6350">		ieee80211_draintask(&amp;sc-&gt;sc_ic, &amp;sc-&gt;sc_es_task);</a>
<a name="ln6351"> </a>
<a name="ln6352">	callout_drain(&amp;sc-&gt;sc_led_blink_to);</a>
<a name="ln6353">	callout_drain(&amp;sc-&gt;sc_watchdog_to);</a>
<a name="ln6354">	iwm_stop_device(sc);</a>
<a name="ln6355">	if (do_net80211) {</a>
<a name="ln6356">		IWM_LOCK(sc);</a>
<a name="ln6357">		iwm_xmit_queue_drain(sc);</a>
<a name="ln6358">		IWM_UNLOCK(sc);</a>
<a name="ln6359">		ieee80211_ifdetach(&amp;sc-&gt;sc_ic);</a>
<a name="ln6360">	}</a>
<a name="ln6361"> </a>
<a name="ln6362">	iwm_phy_db_free(sc-&gt;sc_phy_db);</a>
<a name="ln6363">	sc-&gt;sc_phy_db = NULL;</a>
<a name="ln6364"> </a>
<a name="ln6365">	iwm_free_nvm_data(sc-&gt;nvm_data);</a>
<a name="ln6366"> </a>
<a name="ln6367">	/* Free descriptor rings */</a>
<a name="ln6368">	iwm_free_rx_ring(sc, &amp;sc-&gt;rxq);</a>
<a name="ln6369">	for (i = 0; i &lt; nitems(sc-&gt;txq); i++)</a>
<a name="ln6370">		iwm_free_tx_ring(sc, &amp;sc-&gt;txq[i]);</a>
<a name="ln6371"> </a>
<a name="ln6372">	/* Free firmware */</a>
<a name="ln6373">	if (fw-&gt;fw_fp != NULL)</a>
<a name="ln6374">		iwm_fw_info_free(fw);</a>
<a name="ln6375"> </a>
<a name="ln6376">	/* Free scheduler */</a>
<a name="ln6377">	iwm_dma_contig_free(&amp;sc-&gt;sched_dma);</a>
<a name="ln6378">	iwm_dma_contig_free(&amp;sc-&gt;ict_dma);</a>
<a name="ln6379">	iwm_dma_contig_free(&amp;sc-&gt;kw_dma);</a>
<a name="ln6380">	iwm_dma_contig_free(&amp;sc-&gt;fw_dma);</a>
<a name="ln6381"> </a>
<a name="ln6382">	iwm_free_fw_paging(sc);</a>
<a name="ln6383"> </a>
<a name="ln6384">	/* Finished with the hardware - detach things */</a>
<a name="ln6385">	iwm_pci_detach(dev);</a>
<a name="ln6386"> </a>
<a name="ln6387">	if (sc-&gt;sc_notif_wait != NULL) {</a>
<a name="ln6388">		iwm_notification_wait_free(sc-&gt;sc_notif_wait);</a>
<a name="ln6389">		sc-&gt;sc_notif_wait = NULL;</a>
<a name="ln6390">	}</a>
<a name="ln6391"> </a>
<a name="ln6392">	IWM_LOCK_DESTROY(sc);</a>
<a name="ln6393"> </a>
<a name="ln6394">	return (0);</a>
<a name="ln6395">}</a>
<a name="ln6396"> </a>
<a name="ln6397">static int</a>
<a name="ln6398">iwm_detach(device_t dev)</a>
<a name="ln6399">{</a>
<a name="ln6400">	struct iwm_softc *sc = device_get_softc(dev);</a>
<a name="ln6401"> </a>
<a name="ln6402">	return (iwm_detach_local(sc, 1));</a>
<a name="ln6403">}</a>
<a name="ln6404"> </a>
<a name="ln6405">static device_method_t iwm_pci_methods[] = {</a>
<a name="ln6406">        /* Device interface */</a>
<a name="ln6407">        DEVMETHOD(device_probe,         iwm_probe),</a>
<a name="ln6408">        DEVMETHOD(device_attach,        iwm_attach),</a>
<a name="ln6409">        DEVMETHOD(device_detach,        iwm_detach),</a>
<a name="ln6410">        DEVMETHOD(device_suspend,       iwm_suspend),</a>
<a name="ln6411">        DEVMETHOD(device_resume,        iwm_resume),</a>
<a name="ln6412"> </a>
<a name="ln6413">        DEVMETHOD_END</a>
<a name="ln6414">};</a>
<a name="ln6415"> </a>
<a name="ln6416">static driver_t iwm_pci_driver = {</a>
<a name="ln6417">        &quot;iwm&quot;,</a>
<a name="ln6418">        iwm_pci_methods,</a>
<a name="ln6419">        sizeof (struct iwm_softc)</a>
<a name="ln6420">};</a>
<a name="ln6421"> </a>
<a name="ln6422">static devclass_t iwm_devclass;</a>
<a name="ln6423"> </a>
<a name="ln6424">DRIVER_MODULE(iwm, pci, iwm_pci_driver, iwm_devclass, NULL, NULL);</a>
<a name="ln6425">MODULE_PNP_INFO(&quot;U16:device;P:#;T:vendor=0x8086&quot;, pci, iwm_pci_driver,</a>
<a name="ln6426">    iwm_devices, nitems(iwm_devices));</a>
<a name="ln6427">MODULE_DEPEND(iwm, firmware, 1, 1, 1);</a>
<a name="ln6428">MODULE_DEPEND(iwm, pci, 1, 1, 1);</a>
<a name="ln6429">MODULE_DEPEND(iwm, wlan, 1, 1, 1);</a>

</code></pre>
<div class="balloon" rel="3788"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="3945"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'device_printf' function. The pointer to string of char type symbols is expected.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
