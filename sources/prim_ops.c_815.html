
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>prim_ops.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/****************************************************************************</a>
<a name="ln2">*</a>
<a name="ln3">*						Realmode X86 Emulator Library</a>
<a name="ln4">*</a>
<a name="ln5">*            	Copyright (C) 1996-1999 SciTech Software, Inc.</a>
<a name="ln6">* 				     Copyright (C) David Mosberger-Tang</a>
<a name="ln7">* 					   Copyright (C) 1999 Egbert Eich</a>
<a name="ln8">*</a>
<a name="ln9">*  ========================================================================</a>
<a name="ln10">*</a>
<a name="ln11">*  Permission to use, copy, modify, distribute, and sell this software and</a>
<a name="ln12">*  its documentation for any purpose is hereby granted without fee,</a>
<a name="ln13">*  provided that the above copyright notice appear in all copies and that</a>
<a name="ln14">*  both that copyright notice and this permission notice appear in</a>
<a name="ln15">*  supporting documentation, and that the name of the authors not be used</a>
<a name="ln16">*  in advertising or publicity pertaining to distribution of the software</a>
<a name="ln17">*  without specific, written prior permission.  The authors makes no</a>
<a name="ln18">*  representations about the suitability of this software for any purpose.</a>
<a name="ln19">*  It is provided &quot;as is&quot; without express or implied warranty.</a>
<a name="ln20">*</a>
<a name="ln21">*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,</a>
<a name="ln22">*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO</a>
<a name="ln23">*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR</a>
<a name="ln24">*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF</a>
<a name="ln25">*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR</a>
<a name="ln26">*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR</a>
<a name="ln27">*  PERFORMANCE OF THIS SOFTWARE.</a>
<a name="ln28">*</a>
<a name="ln29">*  ========================================================================</a>
<a name="ln30">*</a>
<a name="ln31">* Language:		ANSI C</a>
<a name="ln32">* Environment:	Any</a>
<a name="ln33">* Developer:    Kendall Bennett</a>
<a name="ln34">*</a>
<a name="ln35">* Description:  This file contains the code to implement the primitive</a>
<a name="ln36">*				machine operations used by the emulation code in ops.c</a>
<a name="ln37">*</a>
<a name="ln38">* Carry Chain Calculation</a>
<a name="ln39">*</a>
<a name="ln40">* This represents a somewhat expensive calculation which is</a>
<a name="ln41">* apparently required to emulate the setting of the OF and AF flag.</a>
<a name="ln42">* The latter is not so important, but the former is.  The overflow</a>
<a name="ln43">* flag is the XOR of the top two bits of the carry chain for an</a>
<a name="ln44">* addition (similar for subtraction).  Since we do not want to</a>
<a name="ln45">* simulate the addition in a bitwise manner, we try to calculate the</a>
<a name="ln46">* carry chain given the two operands and the result.</a>
<a name="ln47">*</a>
<a name="ln48">* So, given the following table, which represents the addition of two</a>
<a name="ln49">* bits, we can derive a formula for the carry chain.</a>
<a name="ln50">*</a>
<a name="ln51">* a   b   cin   r     cout</a>
<a name="ln52">* 0   0   0     0     0</a>
<a name="ln53">* 0   0   1     1     0</a>
<a name="ln54">* 0   1   0     1     0</a>
<a name="ln55">* 0   1   1     0     1</a>
<a name="ln56">* 1   0   0     1     0</a>
<a name="ln57">* 1   0   1     0     1</a>
<a name="ln58">* 1   1   0     0     1</a>
<a name="ln59">* 1   1   1     1     1</a>
<a name="ln60">*</a>
<a name="ln61">* Construction of table for cout:</a>
<a name="ln62">*</a>
<a name="ln63">* ab</a>
<a name="ln64">* r  \  00   01   11  10</a>
<a name="ln65">* |------------------</a>
<a name="ln66">* 0  |   0    1    1   1</a>
<a name="ln67">* 1  |   0    0    1   0</a>
<a name="ln68">*</a>
<a name="ln69">* By inspection, one gets:  cc = ab +  r'(a + b)</a>
<a name="ln70">*</a>
<a name="ln71">* That represents alot of operations, but NO CHOICE....</a>
<a name="ln72">*</a>
<a name="ln73">* Borrow Chain Calculation.</a>
<a name="ln74">*</a>
<a name="ln75">* The following table represents the subtraction of two bits, from</a>
<a name="ln76">* which we can derive a formula for the borrow chain.</a>
<a name="ln77">*</a>
<a name="ln78">* a   b   bin   r     bout</a>
<a name="ln79">* 0   0   0     0     0</a>
<a name="ln80">* 0   0   1     1     1</a>
<a name="ln81">* 0   1   0     1     1</a>
<a name="ln82">* 0   1   1     0     1</a>
<a name="ln83">* 1   0   0     1     0</a>
<a name="ln84">* 1   0   1     0     0</a>
<a name="ln85">* 1   1   0     0     0</a>
<a name="ln86">* 1   1   1     1     1</a>
<a name="ln87">*</a>
<a name="ln88">* Construction of table for cout:</a>
<a name="ln89">*</a>
<a name="ln90">* ab</a>
<a name="ln91">* r  \  00   01   11  10</a>
<a name="ln92">* |------------------</a>
<a name="ln93">* 0  |   0    1    0   0</a>
<a name="ln94">* 1  |   1    1    1   0</a>
<a name="ln95">*</a>
<a name="ln96">* By inspection, one gets:  bc = a'b +  r(a' + b)</a>
<a name="ln97">*</a>
<a name="ln98">****************************************************************************/</a>
<a name="ln99"> </a>
<a name="ln100">#include &lt;stdlib.h&gt;</a>
<a name="ln101"> </a>
<a name="ln102">#define	PRIM_OPS_NO_REDEFINE_ASM</a>
<a name="ln103">#include &quot;x86emu/x86emui.h&quot;</a>
<a name="ln104"> </a>
<a name="ln105">#if defined(__GNUC__)</a>
<a name="ln106">#if defined (__i386__) || defined(__i386) || defined(__AMD64__) || defined(__amd64__)</a>
<a name="ln107">#include &quot;x86emu/prim_x86_gcc.h&quot;</a>
<a name="ln108">#endif</a>
<a name="ln109">#endif</a>
<a name="ln110"> </a>
<a name="ln111">/*------------------------- Global Variables ------------------------------*/</a>
<a name="ln112"> </a>
<a name="ln113">static u32 x86emu_parity_tab[8] = {</a>
<a name="ln114">    0x96696996,</a>
<a name="ln115">    0x69969669,</a>
<a name="ln116">    0x69969669,</a>
<a name="ln117">    0x96696996,</a>
<a name="ln118">    0x69969669,</a>
<a name="ln119">    0x96696996,</a>
<a name="ln120">    0x96696996,</a>
<a name="ln121">    0x69969669,</a>
<a name="ln122">};</a>
<a name="ln123"> </a>
<a name="ln124">#define PARITY(x)   (((x86emu_parity_tab[(x) / 32] &gt;&gt; ((x) % 32)) &amp; 1) == 0)</a>
<a name="ln125">#define XOR2(x) 	(((x) ^ ((x)&gt;&gt;1)) &amp; 0x1)</a>
<a name="ln126"> </a>
<a name="ln127">/*----------------------------- Implementation ----------------------------*/</a>
<a name="ln128"> </a>
<a name="ln129">/****************************************************************************</a>
<a name="ln130">REMARKS:</a>
<a name="ln131">Implements the AAA instruction and side effects.</a>
<a name="ln132">****************************************************************************/</a>
<a name="ln133">u16</a>
<a name="ln134">aaa_word(u16 d)</a>
<a name="ln135">{</a>
<a name="ln136">    u16 res;</a>
<a name="ln137"> </a>
<a name="ln138">    if ((d &amp; 0xf) &gt; 0x9 || ACCESS_FLAG(F_AF)) {</a>
<a name="ln139">        d += 0x6;</a>
<a name="ln140">        d += 0x100;</a>
<a name="ln141">        SET_FLAG(F_AF);</a>
<a name="ln142">        SET_FLAG(F_CF);</a>
<a name="ln143">    }</a>
<a name="ln144">    else {</a>
<a name="ln145">        CLEAR_FLAG(F_CF);</a>
<a name="ln146">        CLEAR_FLAG(F_AF);</a>
<a name="ln147">    }</a>
<a name="ln148">    res = (u16) (d &amp; 0xFF0F);</a>
<a name="ln149">    CLEAR_FLAG(F_SF);</a>
<a name="ln150">    CONDITIONAL_SET_FLAG(res == 0, F_ZF);</a>
<a name="ln151">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln152">    return res;</a>
<a name="ln153">}</a>
<a name="ln154"> </a>
<a name="ln155">/****************************************************************************</a>
<a name="ln156">REMARKS:</a>
<a name="ln157">Implements the AAA instruction and side effects.</a>
<a name="ln158">****************************************************************************/</a>
<a name="ln159">u16</a>
<a name="ln160">aas_word(u16 d)</a>
<a name="ln161">{</a>
<a name="ln162">    u16 res;</a>
<a name="ln163"> </a>
<a name="ln164">    if ((d &amp; 0xf) &gt; 0x9 || ACCESS_FLAG(F_AF)) {</a>
<a name="ln165">        d -= 0x6;</a>
<a name="ln166">        d -= 0x100;</a>
<a name="ln167">        SET_FLAG(F_AF);</a>
<a name="ln168">        SET_FLAG(F_CF);</a>
<a name="ln169">    }</a>
<a name="ln170">    else {</a>
<a name="ln171">        CLEAR_FLAG(F_CF);</a>
<a name="ln172">        CLEAR_FLAG(F_AF);</a>
<a name="ln173">    }</a>
<a name="ln174">    res = (u16) (d &amp; 0xFF0F);</a>
<a name="ln175">    CLEAR_FLAG(F_SF);</a>
<a name="ln176">    CONDITIONAL_SET_FLAG(res == 0, F_ZF);</a>
<a name="ln177">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln178">    return res;</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181">/****************************************************************************</a>
<a name="ln182">REMARKS:</a>
<a name="ln183">Implements the AAD instruction and side effects.</a>
<a name="ln184">****************************************************************************/</a>
<a name="ln185">u16</a>
<a name="ln186">aad_word(u16 d)</a>
<a name="ln187">{</a>
<a name="ln188">    u16 l;</a>
<a name="ln189">    u8 hb, lb;</a>
<a name="ln190"> </a>
<a name="ln191">    hb = (u8) ((d &gt;&gt; 8) &amp; 0xff);</a>
<a name="ln192">    lb = (u8) ((d &amp; 0xff));</a>
<a name="ln193">    l = (u16) ((lb + 10 * hb) &amp; 0xFF);</a>
<a name="ln194"> </a>
<a name="ln195">    CLEAR_FLAG(F_CF);</a>
<a name="ln196">    CLEAR_FLAG(F_AF);</a>
<a name="ln197">    CLEAR_FLAG(F_OF);</a>
<a name="ln198">    CONDITIONAL_SET_FLAG(l &amp; 0x80, F_SF);</a>
<a name="ln199">    CONDITIONAL_SET_FLAG(l == 0, F_ZF);</a>
<a name="ln200">    CONDITIONAL_SET_FLAG(PARITY(l &amp; 0xff), F_PF);</a>
<a name="ln201">    return l;</a>
<a name="ln202">}</a>
<a name="ln203"> </a>
<a name="ln204">/****************************************************************************</a>
<a name="ln205">REMARKS:</a>
<a name="ln206">Implements the AAM instruction and side effects.</a>
<a name="ln207">****************************************************************************/</a>
<a name="ln208">u16</a>
<a name="ln209">aam_word(u8 d)</a>
<a name="ln210">{</a>
<a name="ln211">    u16 h, l;</a>
<a name="ln212"> </a>
<a name="ln213">    h = (u16) (d / 10);</a>
<a name="ln214">    l = (u16) (d % 10);</a>
<a name="ln215">    l |= (u16) (h &lt;&lt; 8);</a>
<a name="ln216"> </a>
<a name="ln217">    CLEAR_FLAG(F_CF);</a>
<a name="ln218">    CLEAR_FLAG(F_AF);</a>
<a name="ln219">    CLEAR_FLAG(F_OF);</a>
<a name="ln220">    CONDITIONAL_SET_FLAG(l &amp; 0x80, F_SF);</a>
<a name="ln221">    CONDITIONAL_SET_FLAG(l == 0, F_ZF);</a>
<a name="ln222">    CONDITIONAL_SET_FLAG(PARITY(l &amp; 0xff), F_PF);</a>
<a name="ln223">    return l;</a>
<a name="ln224">}</a>
<a name="ln225"> </a>
<a name="ln226">/****************************************************************************</a>
<a name="ln227">REMARKS:</a>
<a name="ln228">Implements the ADC instruction and side effects.</a>
<a name="ln229">****************************************************************************/</a>
<a name="ln230">u8</a>
<a name="ln231">adc_byte(u8 d, u8 s)</a>
<a name="ln232">{</a>
<a name="ln233">    register u32 res;           /* all operands in native machine order */</a>
<a name="ln234">    register u32 cc;</a>
<a name="ln235"> </a>
<a name="ln236">    if (ACCESS_FLAG(F_CF))</a>
<a name="ln237">        res = 1 + d + s;</a>
<a name="ln238">    else</a>
<a name="ln239">        res = d + s;</a>
<a name="ln240"> </a>
<a name="ln241">    CONDITIONAL_SET_FLAG(res &amp; 0x100, F_CF);</a>
<a name="ln242">    CONDITIONAL_SET_FLAG((res &amp; 0xff) == 0, F_ZF);</a>
<a name="ln243">    CONDITIONAL_SET_FLAG(res &amp; 0x80, F_SF);</a>
<a name="ln244">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln245"> </a>
<a name="ln246">    /* calculate the carry chain  SEE NOTE AT TOP. */</a>
<a name="ln247">    cc = (s &amp; d) | ((~res) &amp; (s | d));</a>
<a name="ln248">    CONDITIONAL_SET_FLAG(XOR2(cc &gt;&gt; 6), F_OF);</a>
<a name="ln249">    CONDITIONAL_SET_FLAG(cc &amp; 0x8, F_AF);</a>
<a name="ln250">    return (u8) res;</a>
<a name="ln251">}</a>
<a name="ln252"> </a>
<a name="ln253">/****************************************************************************</a>
<a name="ln254">REMARKS:</a>
<a name="ln255">Implements the ADC instruction and side effects.</a>
<a name="ln256">****************************************************************************/</a>
<a name="ln257">u16</a>
<a name="ln258">adc_word(u16 d, u16 s)</a>
<a name="ln259">{</a>
<a name="ln260">    register u32 res;           /* all operands in native machine order */</a>
<a name="ln261">    register u32 cc;</a>
<a name="ln262"> </a>
<a name="ln263">    if (ACCESS_FLAG(F_CF))</a>
<a name="ln264">        res = 1 + d + s;</a>
<a name="ln265">    else</a>
<a name="ln266">        res = d + s;</a>
<a name="ln267"> </a>
<a name="ln268">    CONDITIONAL_SET_FLAG(res &amp; 0x10000, F_CF);</a>
<a name="ln269">    CONDITIONAL_SET_FLAG((res &amp; 0xffff) == 0, F_ZF);</a>
<a name="ln270">    CONDITIONAL_SET_FLAG(res &amp; 0x8000, F_SF);</a>
<a name="ln271">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln272"> </a>
<a name="ln273">    /* calculate the carry chain  SEE NOTE AT TOP. */</a>
<a name="ln274">    cc = (s &amp; d) | ((~res) &amp; (s | d));</a>
<a name="ln275">    CONDITIONAL_SET_FLAG(XOR2(cc &gt;&gt; 14), F_OF);</a>
<a name="ln276">    CONDITIONAL_SET_FLAG(cc &amp; 0x8, F_AF);</a>
<a name="ln277">    return (u16) res;</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280">/****************************************************************************</a>
<a name="ln281">REMARKS:</a>
<a name="ln282">Implements the ADC instruction and side effects.</a>
<a name="ln283">****************************************************************************/</a>
<a name="ln284">u32</a>
<a name="ln285">adc_long(u32 d, u32 s)</a>
<a name="ln286">{</a>
<a name="ln287">    register u32 lo;            /* all operands in native machine order */</a>
<a name="ln288">    register u32 hi;</a>
<a name="ln289">    register u32 res;</a>
<a name="ln290">    register u32 cc;</a>
<a name="ln291"> </a>
<a name="ln292">    if (ACCESS_FLAG(F_CF)) {</a>
<a name="ln293">        lo = 1 + (d &amp; 0xFFFF) + (s &amp; 0xFFFF);</a>
<a name="ln294">        res = 1 + d + s;</a>
<a name="ln295">    }</a>
<a name="ln296">    else {</a>
<a name="ln297">        lo = (d &amp; 0xFFFF) + (s &amp; 0xFFFF);</a>
<a name="ln298">        res = d + s;</a>
<a name="ln299">    }</a>
<a name="ln300">    hi = (lo &gt;&gt; 16) + (d &gt;&gt; 16) + (s &gt;&gt; 16);</a>
<a name="ln301"> </a>
<a name="ln302">    CONDITIONAL_SET_FLAG(hi &amp; 0x10000, F_CF);</a>
<a name="ln303">    CONDITIONAL_SET_FLAG((res &amp; 0xffffffff) == 0, F_ZF);</a>
<a name="ln304">    CONDITIONAL_SET_FLAG(res &amp; 0x80000000, F_SF);</a>
<a name="ln305">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln306"> </a>
<a name="ln307">    /* calculate the carry chain  SEE NOTE AT TOP. */</a>
<a name="ln308">    cc = (s &amp; d) | ((~res) &amp; (s | d));</a>
<a name="ln309">    CONDITIONAL_SET_FLAG(XOR2(cc &gt;&gt; 30), F_OF);</a>
<a name="ln310">    CONDITIONAL_SET_FLAG(cc &amp; 0x8, F_AF);</a>
<a name="ln311">    return res;</a>
<a name="ln312">}</a>
<a name="ln313"> </a>
<a name="ln314">/****************************************************************************</a>
<a name="ln315">REMARKS:</a>
<a name="ln316">Implements the ADD instruction and side effects.</a>
<a name="ln317">****************************************************************************/</a>
<a name="ln318">u8</a>
<a name="ln319">add_byte(u8 d, u8 s)</a>
<a name="ln320">{</a>
<a name="ln321">    register u32 res;           /* all operands in native machine order */</a>
<a name="ln322">    register u32 cc;</a>
<a name="ln323"> </a>
<a name="ln324">    res = d + s;</a>
<a name="ln325">    CONDITIONAL_SET_FLAG(res &amp; 0x100, F_CF);</a>
<a name="ln326">    CONDITIONAL_SET_FLAG((res &amp; 0xff) == 0, F_ZF);</a>
<a name="ln327">    CONDITIONAL_SET_FLAG(res &amp; 0x80, F_SF);</a>
<a name="ln328">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln329"> </a>
<a name="ln330">    /* calculate the carry chain  SEE NOTE AT TOP. */</a>
<a name="ln331">    cc = (s &amp; d) | ((~res) &amp; (s | d));</a>
<a name="ln332">    CONDITIONAL_SET_FLAG(XOR2(cc &gt;&gt; 6), F_OF);</a>
<a name="ln333">    CONDITIONAL_SET_FLAG(cc &amp; 0x8, F_AF);</a>
<a name="ln334">    return (u8) res;</a>
<a name="ln335">}</a>
<a name="ln336"> </a>
<a name="ln337">/****************************************************************************</a>
<a name="ln338">REMARKS:</a>
<a name="ln339">Implements the ADD instruction and side effects.</a>
<a name="ln340">****************************************************************************/</a>
<a name="ln341">u16</a>
<a name="ln342">add_word(u16 d, u16 s)</a>
<a name="ln343">{</a>
<a name="ln344">    register u32 res;           /* all operands in native machine order */</a>
<a name="ln345">    register u32 cc;</a>
<a name="ln346"> </a>
<a name="ln347">    res = d + s;</a>
<a name="ln348">    CONDITIONAL_SET_FLAG(res &amp; 0x10000, F_CF);</a>
<a name="ln349">    CONDITIONAL_SET_FLAG((res &amp; 0xffff) == 0, F_ZF);</a>
<a name="ln350">    CONDITIONAL_SET_FLAG(res &amp; 0x8000, F_SF);</a>
<a name="ln351">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln352"> </a>
<a name="ln353">    /* calculate the carry chain  SEE NOTE AT TOP. */</a>
<a name="ln354">    cc = (s &amp; d) | ((~res) &amp; (s | d));</a>
<a name="ln355">    CONDITIONAL_SET_FLAG(XOR2(cc &gt;&gt; 14), F_OF);</a>
<a name="ln356">    CONDITIONAL_SET_FLAG(cc &amp; 0x8, F_AF);</a>
<a name="ln357">    return (u16) res;</a>
<a name="ln358">}</a>
<a name="ln359"> </a>
<a name="ln360">/****************************************************************************</a>
<a name="ln361">REMARKS:</a>
<a name="ln362">Implements the ADD instruction and side effects.</a>
<a name="ln363">****************************************************************************/</a>
<a name="ln364">u32</a>
<a name="ln365">add_long(u32 d, u32 s)</a>
<a name="ln366">{</a>
<a name="ln367">    register u32 lo;            /* all operands in native machine order */</a>
<a name="ln368">    register u32 hi;</a>
<a name="ln369">    register u32 res;</a>
<a name="ln370">    register u32 cc;</a>
<a name="ln371"> </a>
<a name="ln372">    lo = (d &amp; 0xFFFF) + (s &amp; 0xFFFF);</a>
<a name="ln373">    res = d + s;</a>
<a name="ln374">    hi = (lo &gt;&gt; 16) + (d &gt;&gt; 16) + (s &gt;&gt; 16);</a>
<a name="ln375"> </a>
<a name="ln376">    CONDITIONAL_SET_FLAG(hi &amp; 0x10000, F_CF);</a>
<a name="ln377">    CONDITIONAL_SET_FLAG((res &amp; 0xffffffff) == 0, F_ZF);</a>
<a name="ln378">    CONDITIONAL_SET_FLAG(res &amp; 0x80000000, F_SF);</a>
<a name="ln379">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln380"> </a>
<a name="ln381">    /* calculate the carry chain  SEE NOTE AT TOP. */</a>
<a name="ln382">    cc = (s &amp; d) | ((~res) &amp; (s | d));</a>
<a name="ln383">    CONDITIONAL_SET_FLAG(XOR2(cc &gt;&gt; 30), F_OF);</a>
<a name="ln384">    CONDITIONAL_SET_FLAG(cc &amp; 0x8, F_AF);</a>
<a name="ln385"> </a>
<a name="ln386">    return res;</a>
<a name="ln387">}</a>
<a name="ln388"> </a>
<a name="ln389">/****************************************************************************</a>
<a name="ln390">REMARKS:</a>
<a name="ln391">Implements the AND instruction and side effects.</a>
<a name="ln392">****************************************************************************/</a>
<a name="ln393">u8</a>
<a name="ln394">and_byte(u8 d, u8 s)</a>
<a name="ln395">{</a>
<a name="ln396">    register u8 res;            /* all operands in native machine order */</a>
<a name="ln397"> </a>
<a name="ln398">    res = d &amp; s;</a>
<a name="ln399"> </a>
<a name="ln400">    /* set the flags  */</a>
<a name="ln401">    CLEAR_FLAG(F_OF);</a>
<a name="ln402">    CLEAR_FLAG(F_CF);</a>
<a name="ln403">    CLEAR_FLAG(F_AF);</a>
<a name="ln404">    CONDITIONAL_SET_FLAG(res &amp; 0x80, F_SF);</a>
<a name="ln405">    CONDITIONAL_SET_FLAG(res == 0, F_ZF);</a>
<a name="ln406">    CONDITIONAL_SET_FLAG(PARITY(res), F_PF);</a>
<a name="ln407">    return res;</a>
<a name="ln408">}</a>
<a name="ln409"> </a>
<a name="ln410">/****************************************************************************</a>
<a name="ln411">REMARKS:</a>
<a name="ln412">Implements the AND instruction and side effects.</a>
<a name="ln413">****************************************************************************/</a>
<a name="ln414">u16</a>
<a name="ln415">and_word(u16 d, u16 s)</a>
<a name="ln416">{</a>
<a name="ln417">    register u16 res;           /* all operands in native machine order */</a>
<a name="ln418"> </a>
<a name="ln419">    res = d &amp; s;</a>
<a name="ln420"> </a>
<a name="ln421">    /* set the flags  */</a>
<a name="ln422">    CLEAR_FLAG(F_OF);</a>
<a name="ln423">    CLEAR_FLAG(F_CF);</a>
<a name="ln424">    CLEAR_FLAG(F_AF);</a>
<a name="ln425">    CONDITIONAL_SET_FLAG(res &amp; 0x8000, F_SF);</a>
<a name="ln426">    CONDITIONAL_SET_FLAG(res == 0, F_ZF);</a>
<a name="ln427">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln428">    return res;</a>
<a name="ln429">}</a>
<a name="ln430"> </a>
<a name="ln431">/****************************************************************************</a>
<a name="ln432">REMARKS:</a>
<a name="ln433">Implements the AND instruction and side effects.</a>
<a name="ln434">****************************************************************************/</a>
<a name="ln435">u32</a>
<a name="ln436">and_long(u32 d, u32 s)</a>
<a name="ln437">{</a>
<a name="ln438">    register u32 res;           /* all operands in native machine order */</a>
<a name="ln439"> </a>
<a name="ln440">    res = d &amp; s;</a>
<a name="ln441"> </a>
<a name="ln442">    /* set the flags  */</a>
<a name="ln443">    CLEAR_FLAG(F_OF);</a>
<a name="ln444">    CLEAR_FLAG(F_CF);</a>
<a name="ln445">    CLEAR_FLAG(F_AF);</a>
<a name="ln446">    CONDITIONAL_SET_FLAG(res &amp; 0x80000000, F_SF);</a>
<a name="ln447">    CONDITIONAL_SET_FLAG(res == 0, F_ZF);</a>
<a name="ln448">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln449">    return res;</a>
<a name="ln450">}</a>
<a name="ln451"> </a>
<a name="ln452">/****************************************************************************</a>
<a name="ln453">REMARKS:</a>
<a name="ln454">Implements the CMP instruction and side effects.</a>
<a name="ln455">****************************************************************************/</a>
<a name="ln456">u8</a>
<a name="ln457">cmp_byte(u8 d, u8 s)</a>
<a name="ln458">{</a>
<a name="ln459">    register u32 res;           /* all operands in native machine order */</a>
<a name="ln460">    register u32 bc;</a>
<a name="ln461"> </a>
<a name="ln462">    res = d - s;</a>
<a name="ln463">    CLEAR_FLAG(F_CF);</a>
<a name="ln464">    CONDITIONAL_SET_FLAG(res &amp; 0x80, F_SF);</a>
<a name="ln465">    CONDITIONAL_SET_FLAG((res &amp; 0xff) == 0, F_ZF);</a>
<a name="ln466">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln467"> </a>
<a name="ln468">    /* calculate the borrow chain.  See note at top */</a>
<a name="ln469">    bc = (res &amp; (~d | s)) | (~d &amp; s);</a>
<a name="ln470">    CONDITIONAL_SET_FLAG(bc &amp; 0x80, F_CF);</a>
<a name="ln471">    CONDITIONAL_SET_FLAG(XOR2(bc &gt;&gt; 6), F_OF);</a>
<a name="ln472">    CONDITIONAL_SET_FLAG(bc &amp; 0x8, F_AF);</a>
<a name="ln473">    return d;</a>
<a name="ln474">}</a>
<a name="ln475"> </a>
<a name="ln476">/****************************************************************************</a>
<a name="ln477">REMARKS:</a>
<a name="ln478">Implements the CMP instruction and side effects.</a>
<a name="ln479">****************************************************************************/</a>
<a name="ln480">u16</a>
<a name="ln481">cmp_word(u16 d, u16 s)</a>
<a name="ln482">{</a>
<a name="ln483">    register u32 res;           /* all operands in native machine order */</a>
<a name="ln484">    register u32 bc;</a>
<a name="ln485"> </a>
<a name="ln486">    res = d - s;</a>
<a name="ln487">    CONDITIONAL_SET_FLAG(res &amp; 0x8000, F_SF);</a>
<a name="ln488">    CONDITIONAL_SET_FLAG((res &amp; 0xffff) == 0, F_ZF);</a>
<a name="ln489">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln490"> </a>
<a name="ln491">    /* calculate the borrow chain.  See note at top */</a>
<a name="ln492">    bc = (res &amp; (~d | s)) | (~d &amp; s);</a>
<a name="ln493">    CONDITIONAL_SET_FLAG(bc &amp; 0x8000, F_CF);</a>
<a name="ln494">    CONDITIONAL_SET_FLAG(XOR2(bc &gt;&gt; 14), F_OF);</a>
<a name="ln495">    CONDITIONAL_SET_FLAG(bc &amp; 0x8, F_AF);</a>
<a name="ln496">    return d;</a>
<a name="ln497">}</a>
<a name="ln498"> </a>
<a name="ln499">/****************************************************************************</a>
<a name="ln500">REMARKS:</a>
<a name="ln501">Implements the CMP instruction and side effects.</a>
<a name="ln502">****************************************************************************/</a>
<a name="ln503">u32</a>
<a name="ln504">cmp_long(u32 d, u32 s)</a>
<a name="ln505">{</a>
<a name="ln506">    register u32 res;           /* all operands in native machine order */</a>
<a name="ln507">    register u32 bc;</a>
<a name="ln508"> </a>
<a name="ln509">    res = d - s;</a>
<a name="ln510">    CONDITIONAL_SET_FLAG(res &amp; 0x80000000, F_SF);</a>
<a name="ln511">    CONDITIONAL_SET_FLAG((res &amp; 0xffffffff) == 0, F_ZF);</a>
<a name="ln512">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln513"> </a>
<a name="ln514">    /* calculate the borrow chain.  See note at top */</a>
<a name="ln515">    bc = (res &amp; (~d | s)) | (~d &amp; s);</a>
<a name="ln516">    CONDITIONAL_SET_FLAG(bc &amp; 0x80000000, F_CF);</a>
<a name="ln517">    CONDITIONAL_SET_FLAG(XOR2(bc &gt;&gt; 30), F_OF);</a>
<a name="ln518">    CONDITIONAL_SET_FLAG(bc &amp; 0x8, F_AF);</a>
<a name="ln519">    return d;</a>
<a name="ln520">}</a>
<a name="ln521"> </a>
<a name="ln522">/****************************************************************************</a>
<a name="ln523">REMARKS:</a>
<a name="ln524">Implements the DAA instruction and side effects.</a>
<a name="ln525">****************************************************************************/</a>
<a name="ln526">u8</a>
<a name="ln527">daa_byte(u8 d)</a>
<a name="ln528">{</a>
<a name="ln529">    u32 res = d;</a>
<a name="ln530"> </a>
<a name="ln531">    if ((d &amp; 0xf) &gt; 9 || ACCESS_FLAG(F_AF)) {</a>
<a name="ln532">        res += 6;</a>
<a name="ln533">        SET_FLAG(F_AF);</a>
<a name="ln534">    }</a>
<a name="ln535">    if (res &gt; 0x9F || ACCESS_FLAG(F_CF)) {</a>
<a name="ln536">        res += 0x60;</a>
<a name="ln537">        SET_FLAG(F_CF);</a>
<a name="ln538">    }</a>
<a name="ln539">    CONDITIONAL_SET_FLAG(res &amp; 0x80, F_SF);</a>
<a name="ln540">    CONDITIONAL_SET_FLAG((res &amp; 0xFF) == 0, F_ZF);</a>
<a name="ln541">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln542">    return (u8) res;</a>
<a name="ln543">}</a>
<a name="ln544"> </a>
<a name="ln545">/****************************************************************************</a>
<a name="ln546">REMARKS:</a>
<a name="ln547">Implements the DAS instruction and side effects.</a>
<a name="ln548">****************************************************************************/</a>
<a name="ln549">u8</a>
<a name="ln550">das_byte(u8 d)</a>
<a name="ln551">{</a>
<a name="ln552">    if ((d &amp; 0xf) &gt; 9 || ACCESS_FLAG(F_AF)) {</a>
<a name="ln553">        d -= 6;</a>
<a name="ln554">        SET_FLAG(F_AF);</a>
<a name="ln555">    }</a>
<a name="ln556">    if (d &gt; 0x9F || ACCESS_FLAG(F_CF)) {</a>
<a name="ln557">        d -= 0x60;</a>
<a name="ln558">        SET_FLAG(F_CF);</a>
<a name="ln559">    }</a>
<a name="ln560">    CONDITIONAL_SET_FLAG(d &amp; 0x80, F_SF);</a>
<a name="ln561">    CONDITIONAL_SET_FLAG(d == 0, F_ZF);</a>
<a name="ln562">    CONDITIONAL_SET_FLAG(PARITY(d &amp; 0xff), F_PF);</a>
<a name="ln563">    return d;</a>
<a name="ln564">}</a>
<a name="ln565"> </a>
<a name="ln566">/****************************************************************************</a>
<a name="ln567">REMARKS:</a>
<a name="ln568">Implements the DEC instruction and side effects.</a>
<a name="ln569">****************************************************************************/</a>
<a name="ln570">u8</a>
<a name="ln571">dec_byte(u8 d)</a>
<a name="ln572">{</a>
<a name="ln573">    register u32 res;           /* all operands in native machine order */</a>
<a name="ln574">    register u32 bc;</a>
<a name="ln575"> </a>
<a name="ln576">    res = d - 1;</a>
<a name="ln577">    CONDITIONAL_SET_FLAG(res &amp; 0x80, F_SF);</a>
<a name="ln578">    CONDITIONAL_SET_FLAG((res &amp; 0xff) == 0, F_ZF);</a>
<a name="ln579">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln580"> </a>
<a name="ln581">    /* calculate the borrow chain.  See note at top */</a>
<a name="ln582">    /* based on sub_byte, uses s==1.  */</a>
<a name="ln583">    bc = (res &amp; (~d | 1)) | (~d &amp; 1);</a>
<a name="ln584">    /* carry flag unchanged */</a>
<a name="ln585">    CONDITIONAL_SET_FLAG(XOR2(bc &gt;&gt; 6), F_OF);</a>
<a name="ln586">    CONDITIONAL_SET_FLAG(bc &amp; 0x8, F_AF);</a>
<a name="ln587">    return (u8) res;</a>
<a name="ln588">}</a>
<a name="ln589"> </a>
<a name="ln590">/****************************************************************************</a>
<a name="ln591">REMARKS:</a>
<a name="ln592">Implements the DEC instruction and side effects.</a>
<a name="ln593">****************************************************************************/</a>
<a name="ln594">u16</a>
<a name="ln595">dec_word(u16 d)</a>
<a name="ln596">{</a>
<a name="ln597">    register u32 res;           /* all operands in native machine order */</a>
<a name="ln598">    register u32 bc;</a>
<a name="ln599"> </a>
<a name="ln600">    res = d - 1;</a>
<a name="ln601">    CONDITIONAL_SET_FLAG(res &amp; 0x8000, F_SF);</a>
<a name="ln602">    CONDITIONAL_SET_FLAG((res &amp; 0xffff) == 0, F_ZF);</a>
<a name="ln603">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln604"> </a>
<a name="ln605">    /* calculate the borrow chain.  See note at top */</a>
<a name="ln606">    /* based on the sub_byte routine, with s==1 */</a>
<a name="ln607">    bc = (res &amp; (~d | 1)) | (~d &amp; 1);</a>
<a name="ln608">    /* carry flag unchanged */</a>
<a name="ln609">    CONDITIONAL_SET_FLAG(XOR2(bc &gt;&gt; 14), F_OF);</a>
<a name="ln610">    CONDITIONAL_SET_FLAG(bc &amp; 0x8, F_AF);</a>
<a name="ln611">    return (u16) res;</a>
<a name="ln612">}</a>
<a name="ln613"> </a>
<a name="ln614">/****************************************************************************</a>
<a name="ln615">REMARKS:</a>
<a name="ln616">Implements the DEC instruction and side effects.</a>
<a name="ln617">****************************************************************************/</a>
<a name="ln618">u32</a>
<a name="ln619">dec_long(u32 d)</a>
<a name="ln620">{</a>
<a name="ln621">    register u32 res;           /* all operands in native machine order */</a>
<a name="ln622">    register u32 bc;</a>
<a name="ln623"> </a>
<a name="ln624">    res = d - 1;</a>
<a name="ln625"> </a>
<a name="ln626">    CONDITIONAL_SET_FLAG(res &amp; 0x80000000, F_SF);</a>
<a name="ln627">    CONDITIONAL_SET_FLAG((res &amp; 0xffffffff) == 0, F_ZF);</a>
<a name="ln628">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln629"> </a>
<a name="ln630">    /* calculate the borrow chain.  See note at top */</a>
<a name="ln631">    bc = (res &amp; (~d | 1)) | (~d &amp; 1);</a>
<a name="ln632">    /* carry flag unchanged */</a>
<a name="ln633">    CONDITIONAL_SET_FLAG(XOR2(bc &gt;&gt; 30), F_OF);</a>
<a name="ln634">    CONDITIONAL_SET_FLAG(bc &amp; 0x8, F_AF);</a>
<a name="ln635">    return res;</a>
<a name="ln636">}</a>
<a name="ln637"> </a>
<a name="ln638">/****************************************************************************</a>
<a name="ln639">REMARKS:</a>
<a name="ln640">Implements the INC instruction and side effects.</a>
<a name="ln641">****************************************************************************/</a>
<a name="ln642">u8</a>
<a name="ln643">inc_byte(u8 d)</a>
<a name="ln644">{</a>
<a name="ln645">    register u32 res;           /* all operands in native machine order */</a>
<a name="ln646">    register u32 cc;</a>
<a name="ln647"> </a>
<a name="ln648">    res = d + 1;</a>
<a name="ln649">    CONDITIONAL_SET_FLAG((res &amp; 0xff) == 0, F_ZF);</a>
<a name="ln650">    CONDITIONAL_SET_FLAG(res &amp; 0x80, F_SF);</a>
<a name="ln651">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln652"> </a>
<a name="ln653">    /* calculate the carry chain  SEE NOTE AT TOP. */</a>
<a name="ln654">    cc = ((1 &amp; d) | (~res)) &amp; (1 | d);</a>
<a name="ln655">    CONDITIONAL_SET_FLAG(XOR2(cc &gt;&gt; 6), F_OF);</a>
<a name="ln656">    CONDITIONAL_SET_FLAG(cc &amp; 0x8, F_AF);</a>
<a name="ln657">    return (u8) res;</a>
<a name="ln658">}</a>
<a name="ln659"> </a>
<a name="ln660">/****************************************************************************</a>
<a name="ln661">REMARKS:</a>
<a name="ln662">Implements the INC instruction and side effects.</a>
<a name="ln663">****************************************************************************/</a>
<a name="ln664">u16</a>
<a name="ln665">inc_word(u16 d)</a>
<a name="ln666">{</a>
<a name="ln667">    register u32 res;           /* all operands in native machine order */</a>
<a name="ln668">    register u32 cc;</a>
<a name="ln669"> </a>
<a name="ln670">    res = d + 1;</a>
<a name="ln671">    CONDITIONAL_SET_FLAG((res &amp; 0xffff) == 0, F_ZF);</a>
<a name="ln672">    CONDITIONAL_SET_FLAG(res &amp; 0x8000, F_SF);</a>
<a name="ln673">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln674"> </a>
<a name="ln675">    /* calculate the carry chain  SEE NOTE AT TOP. */</a>
<a name="ln676">    cc = (1 &amp; d) | ((~res) &amp; (1 | d));</a>
<a name="ln677">    CONDITIONAL_SET_FLAG(XOR2(cc &gt;&gt; 14), F_OF);</a>
<a name="ln678">    CONDITIONAL_SET_FLAG(cc &amp; 0x8, F_AF);</a>
<a name="ln679">    return (u16) res;</a>
<a name="ln680">}</a>
<a name="ln681"> </a>
<a name="ln682">/****************************************************************************</a>
<a name="ln683">REMARKS:</a>
<a name="ln684">Implements the INC instruction and side effects.</a>
<a name="ln685">****************************************************************************/</a>
<a name="ln686">u32</a>
<a name="ln687">inc_long(u32 d)</a>
<a name="ln688">{</a>
<a name="ln689">    register u32 res;           /* all operands in native machine order */</a>
<a name="ln690">    register u32 cc;</a>
<a name="ln691"> </a>
<a name="ln692">    res = d + 1;</a>
<a name="ln693">    CONDITIONAL_SET_FLAG((res &amp; 0xffffffff) == 0, F_ZF);</a>
<a name="ln694">    CONDITIONAL_SET_FLAG(res &amp; 0x80000000, F_SF);</a>
<a name="ln695">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln696"> </a>
<a name="ln697">    /* calculate the carry chain  SEE NOTE AT TOP. */</a>
<a name="ln698">    cc = (1 &amp; d) | ((~res) &amp; (1 | d));</a>
<a name="ln699">    CONDITIONAL_SET_FLAG(XOR2(cc &gt;&gt; 30), F_OF);</a>
<a name="ln700">    CONDITIONAL_SET_FLAG(cc &amp; 0x8, F_AF);</a>
<a name="ln701">    return res;</a>
<a name="ln702">}</a>
<a name="ln703"> </a>
<a name="ln704">/****************************************************************************</a>
<a name="ln705">REMARKS:</a>
<a name="ln706">Implements the OR instruction and side effects.</a>
<a name="ln707">****************************************************************************/</a>
<a name="ln708">u8</a>
<a name="ln709">or_byte(u8 d, u8 s)</a>
<a name="ln710">{</a>
<a name="ln711">    register u8 res;            /* all operands in native machine order */</a>
<a name="ln712"> </a>
<a name="ln713">    res = d | s;</a>
<a name="ln714">    CLEAR_FLAG(F_OF);</a>
<a name="ln715">    CLEAR_FLAG(F_CF);</a>
<a name="ln716">    CLEAR_FLAG(F_AF);</a>
<a name="ln717">    CONDITIONAL_SET_FLAG(res &amp; 0x80, F_SF);</a>
<a name="ln718">    CONDITIONAL_SET_FLAG(res == 0, F_ZF);</a>
<a name="ln719">    CONDITIONAL_SET_FLAG(PARITY(res), F_PF);</a>
<a name="ln720">    return res;</a>
<a name="ln721">}</a>
<a name="ln722"> </a>
<a name="ln723">/****************************************************************************</a>
<a name="ln724">REMARKS:</a>
<a name="ln725">Implements the OR instruction and side effects.</a>
<a name="ln726">****************************************************************************/</a>
<a name="ln727">u16</a>
<a name="ln728">or_word(u16 d, u16 s)</a>
<a name="ln729">{</a>
<a name="ln730">    register u16 res;           /* all operands in native machine order */</a>
<a name="ln731"> </a>
<a name="ln732">    res = d | s;</a>
<a name="ln733">    /* set the carry flag to be bit 8 */</a>
<a name="ln734">    CLEAR_FLAG(F_OF);</a>
<a name="ln735">    CLEAR_FLAG(F_CF);</a>
<a name="ln736">    CLEAR_FLAG(F_AF);</a>
<a name="ln737">    CONDITIONAL_SET_FLAG(res &amp; 0x8000, F_SF);</a>
<a name="ln738">    CONDITIONAL_SET_FLAG(res == 0, F_ZF);</a>
<a name="ln739">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln740">    return res;</a>
<a name="ln741">}</a>
<a name="ln742"> </a>
<a name="ln743">/****************************************************************************</a>
<a name="ln744">REMARKS:</a>
<a name="ln745">Implements the OR instruction and side effects.</a>
<a name="ln746">****************************************************************************/</a>
<a name="ln747">u32</a>
<a name="ln748">or_long(u32 d, u32 s)</a>
<a name="ln749">{</a>
<a name="ln750">    register u32 res;           /* all operands in native machine order */</a>
<a name="ln751"> </a>
<a name="ln752">    res = d | s;</a>
<a name="ln753"> </a>
<a name="ln754">    /* set the carry flag to be bit 8 */</a>
<a name="ln755">    CLEAR_FLAG(F_OF);</a>
<a name="ln756">    CLEAR_FLAG(F_CF);</a>
<a name="ln757">    CLEAR_FLAG(F_AF);</a>
<a name="ln758">    CONDITIONAL_SET_FLAG(res &amp; 0x80000000, F_SF);</a>
<a name="ln759">    CONDITIONAL_SET_FLAG(res == 0, F_ZF);</a>
<a name="ln760">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln761">    return res;</a>
<a name="ln762">}</a>
<a name="ln763"> </a>
<a name="ln764">/****************************************************************************</a>
<a name="ln765">REMARKS:</a>
<a name="ln766">Implements the OR instruction and side effects.</a>
<a name="ln767">****************************************************************************/</a>
<a name="ln768">u8</a>
<a name="ln769">neg_byte(u8 s)</a>
<a name="ln770">{</a>
<a name="ln771">    register u8 res;</a>
<a name="ln772">    register u8 bc;</a>
<a name="ln773"> </a>
<a name="ln774">    CONDITIONAL_SET_FLAG(s != 0, F_CF);</a>
<a name="ln775">    res = (u8) - s;</a>
<a name="ln776">    CONDITIONAL_SET_FLAG((res &amp; 0xff) == 0, F_ZF);</a>
<a name="ln777">    CONDITIONAL_SET_FLAG(res &amp; 0x80, F_SF);</a>
<a name="ln778">    CONDITIONAL_SET_FLAG(PARITY(res), F_PF);</a>
<a name="ln779">    /* calculate the borrow chain --- modified such that d=0.</a>
<a name="ln780">       substitutiing d=0 into     bc= res&amp;(~d|s)|(~d&amp;s);</a>
<a name="ln781">       (the one used for sub) and simplifying, since ~d=0xff...,</a>
<a name="ln782">       ~d|s == 0xffff..., and res&amp;0xfff... == res.  Similarly</a>
<a name="ln783">       ~d&amp;s == s.  So the simplified result is: */</a>
<a name="ln784">    bc = res | s;</a>
<a name="ln785">    CONDITIONAL_SET_FLAG(XOR2(bc &gt;&gt; 6), F_OF);</a>
<a name="ln786">    CONDITIONAL_SET_FLAG(bc &amp; 0x8, F_AF);</a>
<a name="ln787">    return res;</a>
<a name="ln788">}</a>
<a name="ln789"> </a>
<a name="ln790">/****************************************************************************</a>
<a name="ln791">REMARKS:</a>
<a name="ln792">Implements the OR instruction and side effects.</a>
<a name="ln793">****************************************************************************/</a>
<a name="ln794">u16</a>
<a name="ln795">neg_word(u16 s)</a>
<a name="ln796">{</a>
<a name="ln797">    register u16 res;</a>
<a name="ln798">    register u16 bc;</a>
<a name="ln799"> </a>
<a name="ln800">    CONDITIONAL_SET_FLAG(s != 0, F_CF);</a>
<a name="ln801">    res = (u16) - s;</a>
<a name="ln802">    CONDITIONAL_SET_FLAG((res &amp; 0xffff) == 0, F_ZF);</a>
<a name="ln803">    CONDITIONAL_SET_FLAG(res &amp; 0x8000, F_SF);</a>
<a name="ln804">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln805"> </a>
<a name="ln806">    /* calculate the borrow chain --- modified such that d=0.</a>
<a name="ln807">       substitutiing d=0 into     bc= res&amp;(~d|s)|(~d&amp;s);</a>
<a name="ln808">       (the one used for sub) and simplifying, since ~d=0xff...,</a>
<a name="ln809">       ~d|s == 0xffff..., and res&amp;0xfff... == res.  Similarly</a>
<a name="ln810">       ~d&amp;s == s.  So the simplified result is: */</a>
<a name="ln811">    bc = res | s;</a>
<a name="ln812">    CONDITIONAL_SET_FLAG(XOR2(bc &gt;&gt; 14), F_OF);</a>
<a name="ln813">    CONDITIONAL_SET_FLAG(bc &amp; 0x8, F_AF);</a>
<a name="ln814">    return res;</a>
<a name="ln815">}</a>
<a name="ln816"> </a>
<a name="ln817">/****************************************************************************</a>
<a name="ln818">REMARKS:</a>
<a name="ln819">Implements the OR instruction and side effects.</a>
<a name="ln820">****************************************************************************/</a>
<a name="ln821">u32</a>
<a name="ln822">neg_long(u32 s)</a>
<a name="ln823">{</a>
<a name="ln824">    register u32 res;</a>
<a name="ln825">    register u32 bc;</a>
<a name="ln826"> </a>
<a name="ln827">    CONDITIONAL_SET_FLAG(s != 0, F_CF);</a>
<a name="ln828">    res = (u32) - s;</a>
<a name="ln829">    CONDITIONAL_SET_FLAG((res &amp; 0xffffffff) == 0, F_ZF);</a>
<a name="ln830">    CONDITIONAL_SET_FLAG(res &amp; 0x80000000, F_SF);</a>
<a name="ln831">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln832"> </a>
<a name="ln833">    /* calculate the borrow chain --- modified such that d=0.</a>
<a name="ln834">       substitutiing d=0 into     bc= res&amp;(~d|s)|(~d&amp;s);</a>
<a name="ln835">       (the one used for sub) and simplifying, since ~d=0xff...,</a>
<a name="ln836">       ~d|s == 0xffff..., and res&amp;0xfff... == res.  Similarly</a>
<a name="ln837">       ~d&amp;s == s.  So the simplified result is: */</a>
<a name="ln838">    bc = res | s;</a>
<a name="ln839">    CONDITIONAL_SET_FLAG(XOR2(bc &gt;&gt; 30), F_OF);</a>
<a name="ln840">    CONDITIONAL_SET_FLAG(bc &amp; 0x8, F_AF);</a>
<a name="ln841">    return res;</a>
<a name="ln842">}</a>
<a name="ln843"> </a>
<a name="ln844">/****************************************************************************</a>
<a name="ln845">REMARKS:</a>
<a name="ln846">Implements the NOT instruction and side effects.</a>
<a name="ln847">****************************************************************************/</a>
<a name="ln848">u8</a>
<a name="ln849">not_byte(u8 s)</a>
<a name="ln850">{</a>
<a name="ln851">    return ~s;</a>
<a name="ln852">}</a>
<a name="ln853"> </a>
<a name="ln854">/****************************************************************************</a>
<a name="ln855">REMARKS:</a>
<a name="ln856">Implements the NOT instruction and side effects.</a>
<a name="ln857">****************************************************************************/</a>
<a name="ln858">u16</a>
<a name="ln859">not_word(u16 s)</a>
<a name="ln860">{</a>
<a name="ln861">    return ~s;</a>
<a name="ln862">}</a>
<a name="ln863"> </a>
<a name="ln864">/****************************************************************************</a>
<a name="ln865">REMARKS:</a>
<a name="ln866">Implements the NOT instruction and side effects.</a>
<a name="ln867">****************************************************************************/</a>
<a name="ln868">u32</a>
<a name="ln869">not_long(u32 s)</a>
<a name="ln870">{</a>
<a name="ln871">    return ~s;</a>
<a name="ln872">}</a>
<a name="ln873"> </a>
<a name="ln874">/****************************************************************************</a>
<a name="ln875">REMARKS:</a>
<a name="ln876">Implements the RCL instruction and side effects.</a>
<a name="ln877">****************************************************************************/</a>
<a name="ln878">u8</a>
<a name="ln879">rcl_byte(u8 d, u8 s)</a>
<a name="ln880">{</a>
<a name="ln881">    register unsigned int res, cnt, mask, cf;</a>
<a name="ln882"> </a>
<a name="ln883">    /* s is the rotate distance.  It varies from 0 - 8. */</a>
<a name="ln884">    /* have</a>
<a name="ln885"> </a>
<a name="ln886">       CF  B_7 B_6 B_5 B_4 B_3 B_2 B_1 B_0</a>
<a name="ln887"> </a>
<a name="ln888">       want to rotate through the carry by &quot;s&quot; bits.  We could</a>
<a name="ln889">       loop, but that's inefficient.  So the width is 9,</a>
<a name="ln890">       and we split into three parts:</a>
<a name="ln891"> </a>
<a name="ln892">       The new carry flag   (was B_n)</a>
<a name="ln893">       the stuff in B_n-1 .. B_0</a>
<a name="ln894">       the stuff in B_7 .. B_n+1</a>
<a name="ln895"> </a>
<a name="ln896">       The new rotate is done mod 9, and given this,</a>
<a name="ln897">       for a rotation of n bits (mod 9) the new carry flag is</a>
<a name="ln898">       then located n bits from the MSB.  The low part is</a>
<a name="ln899">       then shifted up cnt bits, and the high part is or'd</a>
<a name="ln900">       in.  Using CAPS for new values, and lowercase for the</a>
<a name="ln901">       original values, this can be expressed as:</a>
<a name="ln902"> </a>
<a name="ln903">       IF n &gt; 0</a>
<a name="ln904">       1) CF &lt;-  b_(8-n)</a>
<a name="ln905">       2) B_(7) .. B_(n)  &lt;-  b_(8-(n+1)) .. b_0</a>
<a name="ln906">       3) B_(n-1) &lt;- cf</a>
<a name="ln907">       4) B_(n-2) .. B_0 &lt;-  b_7 .. b_(8-(n-1))</a>
<a name="ln908">     */</a>
<a name="ln909">    res = d;</a>
<a name="ln910">    if ((cnt = s % 9) != 0) {</a>
<a name="ln911">        /* extract the new CARRY FLAG. */</a>
<a name="ln912">        /* CF &lt;-  b_(8-n)             */</a>
<a name="ln913">        cf = (d &gt;&gt; (8 - cnt)) &amp; 0x1;</a>
<a name="ln914"> </a>
<a name="ln915">        /* get the low stuff which rotated</a>
<a name="ln916">           into the range B_7 .. B_cnt */</a>
<a name="ln917">        /* B_(7) .. B_(n)  &lt;-  b_(8-(n+1)) .. b_0  */</a>
<a name="ln918">        /* note that the right hand side done by the mask */</a>
<a name="ln919">        res = (d &lt;&lt; cnt) &amp; 0xff;</a>
<a name="ln920"> </a>
<a name="ln921">        /* now the high stuff which rotated around</a>
<a name="ln922">           into the positions B_cnt-2 .. B_0 */</a>
<a name="ln923">        /* B_(n-2) .. B_0 &lt;-  b_7 .. b_(8-(n-1)) */</a>
<a name="ln924">        /* shift it downward, 7-(n-2) = 9-n positions.</a>
<a name="ln925">           and mask off the result before or'ing in.</a>
<a name="ln926">         */</a>
<a name="ln927">        mask = (1 &lt;&lt; (cnt - 1)) - 1;</a>
<a name="ln928">        res |= (d &gt;&gt; (9 - cnt)) &amp; mask;</a>
<a name="ln929"> </a>
<a name="ln930">        /* if the carry flag was set, or it in.  */</a>
<a name="ln931">        if (ACCESS_FLAG(F_CF)) {        /* carry flag is set */</a>
<a name="ln932">            /*  B_(n-1) &lt;- cf */</a>
<a name="ln933">            res |= 1 &lt;&lt; (cnt - 1);</a>
<a name="ln934">        }</a>
<a name="ln935">        /* set the new carry flag, based on the variable &quot;cf&quot; */</a>
<a name="ln936">        CONDITIONAL_SET_FLAG(cf, F_CF);</a>
<a name="ln937">        /* OVERFLOW is set *IFF* cnt==1, then it is the</a>
<a name="ln938">           xor of CF and the most significant bit.  Blecck. */</a>
<a name="ln939">        /* parenthesized this expression since it appears to</a>
<a name="ln940">           be causing OF to be misset */</a>
<a name="ln941">        CONDITIONAL_SET_FLAG(cnt == 1 &amp;&amp; XOR2(cf + ((res &gt;&gt; 6) &amp; 0x2)), F_OF);</a>
<a name="ln942"> </a>
<a name="ln943">    }</a>
<a name="ln944">    return (u8) res;</a>
<a name="ln945">}</a>
<a name="ln946"> </a>
<a name="ln947">/****************************************************************************</a>
<a name="ln948">REMARKS:</a>
<a name="ln949">Implements the RCL instruction and side effects.</a>
<a name="ln950">****************************************************************************/</a>
<a name="ln951">u16</a>
<a name="ln952">rcl_word(u16 d, u8 s)</a>
<a name="ln953">{</a>
<a name="ln954">    register unsigned int res, cnt, mask, cf;</a>
<a name="ln955"> </a>
<a name="ln956">    res = d;</a>
<a name="ln957">    if ((cnt = s % 17) != 0) {</a>
<a name="ln958">        cf = (d &gt;&gt; (16 - cnt)) &amp; 0x1;</a>
<a name="ln959">        res = (d &lt;&lt; cnt) &amp; 0xffff;</a>
<a name="ln960">        mask = (1 &lt;&lt; (cnt - 1)) - 1;</a>
<a name="ln961">        res |= (d &gt;&gt; (17 - cnt)) &amp; mask;</a>
<a name="ln962">        if (ACCESS_FLAG(F_CF)) {</a>
<a name="ln963">            res |= 1 &lt;&lt; (cnt - 1);</a>
<a name="ln964">        }</a>
<a name="ln965">        CONDITIONAL_SET_FLAG(cf, F_CF);</a>
<a name="ln966">        CONDITIONAL_SET_FLAG(cnt == 1 &amp;&amp; XOR2(cf + ((res &gt;&gt; 14) &amp; 0x2)), F_OF);</a>
<a name="ln967">    }</a>
<a name="ln968">    return (u16) res;</a>
<a name="ln969">}</a>
<a name="ln970"> </a>
<a name="ln971">/****************************************************************************</a>
<a name="ln972">REMARKS:</a>
<a name="ln973">Implements the RCL instruction and side effects.</a>
<a name="ln974">****************************************************************************/</a>
<a name="ln975">u32</a>
<a name="ln976">rcl_long(u32 d, u8 s)</a>
<a name="ln977">{</a>
<a name="ln978">    register u32 res, cnt, mask, cf;</a>
<a name="ln979"> </a>
<a name="ln980">    res = d;</a>
<a name="ln981">    if ((cnt = s % 33) != 0) {</a>
<a name="ln982">        cf = (d &gt;&gt; (32 - cnt)) &amp; 0x1;</a>
<a name="ln983">        res = (d &lt;&lt; cnt) &amp; 0xffffffff;</a>
<a name="ln984">        mask = (1 &lt;&lt; (cnt - 1)) - 1;</a>
<a name="ln985">        res |= (d &gt;&gt; (33 - cnt)) &amp; mask;</a>
<a name="ln986">        if (ACCESS_FLAG(F_CF)) {        /* carry flag is set */</a>
<a name="ln987">            res |= 1 &lt;&lt; (cnt - 1);</a>
<a name="ln988">        }</a>
<a name="ln989">        CONDITIONAL_SET_FLAG(cf, F_CF);</a>
<a name="ln990">        CONDITIONAL_SET_FLAG(cnt == 1 &amp;&amp; XOR2(cf + ((res &gt;&gt; 30) &amp; 0x2)), F_OF);</a>
<a name="ln991">    }</a>
<a name="ln992">    return res;</a>
<a name="ln993">}</a>
<a name="ln994"> </a>
<a name="ln995">/****************************************************************************</a>
<a name="ln996">REMARKS:</a>
<a name="ln997">Implements the RCR instruction and side effects.</a>
<a name="ln998">****************************************************************************/</a>
<a name="ln999">u8</a>
<a name="ln1000">rcr_byte(u8 d, u8 s)</a>
<a name="ln1001">{</a>
<a name="ln1002">    u32 res, cnt;</a>
<a name="ln1003">    u32 mask, cf, ocf = 0;</a>
<a name="ln1004"> </a>
<a name="ln1005">    /* rotate right through carry */</a>
<a name="ln1006">    /*</a>
<a name="ln1007">       s is the rotate distance.  It varies from 0 - 8.</a>
<a name="ln1008">       d is the byte object rotated.</a>
<a name="ln1009"> </a>
<a name="ln1010">       have</a>
<a name="ln1011"> </a>
<a name="ln1012">       CF  B_7 B_6 B_5 B_4 B_3 B_2 B_1 B_0</a>
<a name="ln1013"> </a>
<a name="ln1014">       The new rotate is done mod 9, and given this,</a>
<a name="ln1015">       for a rotation of n bits (mod 9) the new carry flag is</a>
<a name="ln1016">       then located n bits from the LSB.  The low part is</a>
<a name="ln1017">       then shifted up cnt bits, and the high part is or'd</a>
<a name="ln1018">       in.  Using CAPS for new values, and lowercase for the</a>
<a name="ln1019">       original values, this can be expressed as:</a>
<a name="ln1020"> </a>
<a name="ln1021">       IF n &gt; 0</a>
<a name="ln1022">       1) CF &lt;-  b_(n-1)</a>
<a name="ln1023">       2) B_(8-(n+1)) .. B_(0)  &lt;-  b_(7) .. b_(n)</a>
<a name="ln1024">       3) B_(8-n) &lt;- cf</a>
<a name="ln1025">       4) B_(7) .. B_(8-(n-1)) &lt;-  b_(n-2) .. b_(0)</a>
<a name="ln1026">     */</a>
<a name="ln1027">    res = d;</a>
<a name="ln1028">    if ((cnt = s % 9) != 0) {</a>
<a name="ln1029">        /* extract the new CARRY FLAG. */</a>
<a name="ln1030">        /* CF &lt;-  b_(n-1)              */</a>
<a name="ln1031">        if (cnt == 1) {</a>
<a name="ln1032">            cf = d &amp; 0x1;</a>
<a name="ln1033">            /* note hackery here.  Access_flag(..) evaluates to either</a>
<a name="ln1034">               0 if flag not set</a>
<a name="ln1035">               non-zero if flag is set.</a>
<a name="ln1036">               doing access_flag(..) != 0 casts that into either</a>
<a name="ln1037">               0..1 in any representation of the flags register</a>
<a name="ln1038">               (i.e. packed bit array or unpacked.)</a>
<a name="ln1039">             */</a>
<a name="ln1040">            ocf = ACCESS_FLAG(F_CF) != 0;</a>
<a name="ln1041">        }</a>
<a name="ln1042">        else</a>
<a name="ln1043">            cf = (d &gt;&gt; (cnt - 1)) &amp; 0x1;</a>
<a name="ln1044"> </a>
<a name="ln1045">        /* B_(8-(n+1)) .. B_(0)  &lt;-  b_(7) .. b_n  */</a>
<a name="ln1046">        /* note that the right hand side done by the mask</a>
<a name="ln1047">           This is effectively done by shifting the</a>
<a name="ln1048">           object to the right.  The result must be masked,</a>
<a name="ln1049">           in case the object came in and was treated</a>
<a name="ln1050">           as a negative number.  Needed??? */</a>
<a name="ln1051"> </a>
<a name="ln1052">        mask = (1 &lt;&lt; (8 - cnt)) - 1;</a>
<a name="ln1053">        res = (d &gt;&gt; cnt) &amp; mask;</a>
<a name="ln1054"> </a>
<a name="ln1055">        /* now the high stuff which rotated around</a>
<a name="ln1056">           into the positions B_cnt-2 .. B_0 */</a>
<a name="ln1057">        /* B_(7) .. B_(8-(n-1)) &lt;-  b_(n-2) .. b_(0) */</a>
<a name="ln1058">        /* shift it downward, 7-(n-2) = 9-n positions.</a>
<a name="ln1059">           and mask off the result before or'ing in.</a>
<a name="ln1060">         */</a>
<a name="ln1061">        res |= (d &lt;&lt; (9 - cnt));</a>
<a name="ln1062"> </a>
<a name="ln1063">        /* if the carry flag was set, or it in.  */</a>
<a name="ln1064">        if (ACCESS_FLAG(F_CF)) {        /* carry flag is set */</a>
<a name="ln1065">            /*  B_(8-n) &lt;- cf */</a>
<a name="ln1066">            res |= 1 &lt;&lt; (8 - cnt);</a>
<a name="ln1067">        }</a>
<a name="ln1068">        /* set the new carry flag, based on the variable &quot;cf&quot; */</a>
<a name="ln1069">        CONDITIONAL_SET_FLAG(cf, F_CF);</a>
<a name="ln1070">        /* OVERFLOW is set *IFF* cnt==1, then it is the</a>
<a name="ln1071">           xor of CF and the most significant bit.  Blecck. */</a>
<a name="ln1072">        /* parenthesized... */</a>
<a name="ln1073">        if (cnt == 1) {</a>
<a name="ln1074">            CONDITIONAL_SET_FLAG(XOR2(ocf + ((d &gt;&gt; 6) &amp; 0x2)), F_OF);</a>
<a name="ln1075">        }</a>
<a name="ln1076">    }</a>
<a name="ln1077">    return (u8) res;</a>
<a name="ln1078">}</a>
<a name="ln1079"> </a>
<a name="ln1080">/****************************************************************************</a>
<a name="ln1081">REMARKS:</a>
<a name="ln1082">Implements the RCR instruction and side effects.</a>
<a name="ln1083">****************************************************************************/</a>
<a name="ln1084">u16</a>
<a name="ln1085">rcr_word(u16 d, u8 s)</a>
<a name="ln1086">{</a>
<a name="ln1087">    u32 res, cnt;</a>
<a name="ln1088">    u32 mask, cf, ocf = 0;</a>
<a name="ln1089"> </a>
<a name="ln1090">    /* rotate right through carry */</a>
<a name="ln1091">    res = d;</a>
<a name="ln1092">    if ((cnt = s % 17) != 0) {</a>
<a name="ln1093">        if (cnt == 1) {</a>
<a name="ln1094">            cf = d &amp; 0x1;</a>
<a name="ln1095">            ocf = ACCESS_FLAG(F_CF) != 0;</a>
<a name="ln1096">        }</a>
<a name="ln1097">        else</a>
<a name="ln1098">            cf = (d &gt;&gt; (cnt - 1)) &amp; 0x1;</a>
<a name="ln1099">        mask = (1 &lt;&lt; (16 - cnt)) - 1;</a>
<a name="ln1100">        res = (d &gt;&gt; cnt) &amp; mask;</a>
<a name="ln1101">        res |= (d &lt;&lt; (17 - cnt));</a>
<a name="ln1102">        if (ACCESS_FLAG(F_CF)) {</a>
<a name="ln1103">            res |= 1 &lt;&lt; (16 - cnt);</a>
<a name="ln1104">        }</a>
<a name="ln1105">        CONDITIONAL_SET_FLAG(cf, F_CF);</a>
<a name="ln1106">        if (cnt == 1) {</a>
<a name="ln1107">            CONDITIONAL_SET_FLAG(XOR2(ocf + ((d &gt;&gt; 14) &amp; 0x2)), F_OF);</a>
<a name="ln1108">        }</a>
<a name="ln1109">    }</a>
<a name="ln1110">    return (u16) res;</a>
<a name="ln1111">}</a>
<a name="ln1112"> </a>
<a name="ln1113">/****************************************************************************</a>
<a name="ln1114">REMARKS:</a>
<a name="ln1115">Implements the RCR instruction and side effects.</a>
<a name="ln1116">****************************************************************************/</a>
<a name="ln1117">u32</a>
<a name="ln1118">rcr_long(u32 d, u8 s)</a>
<a name="ln1119">{</a>
<a name="ln1120">    u32 res, cnt;</a>
<a name="ln1121">    u32 mask, cf, ocf = 0;</a>
<a name="ln1122"> </a>
<a name="ln1123">    /* rotate right through carry */</a>
<a name="ln1124">    res = d;</a>
<a name="ln1125">    if ((cnt = s % 33) != 0) {</a>
<a name="ln1126">        if (cnt == 1) {</a>
<a name="ln1127">            cf = d &amp; 0x1;</a>
<a name="ln1128">            ocf = ACCESS_FLAG(F_CF) != 0;</a>
<a name="ln1129">        }</a>
<a name="ln1130">        else</a>
<a name="ln1131">            cf = (d &gt;&gt; (cnt - 1)) &amp; 0x1;</a>
<a name="ln1132">        mask = (1 &lt;&lt; (32 - cnt)) - 1;</a>
<a name="ln1133">        res = (d &gt;&gt; cnt) &amp; mask;</a>
<a name="ln1134">        if (cnt != 1)</a>
<a name="ln1135">            res |= (d &lt;&lt; (33 - cnt));</a>
<a name="ln1136">        if (ACCESS_FLAG(F_CF)) {        /* carry flag is set */</a>
<a name="ln1137">            res |= 1 &lt;&lt; (32 - cnt);</a>
<a name="ln1138">        }</a>
<a name="ln1139">        CONDITIONAL_SET_FLAG(cf, F_CF);</a>
<a name="ln1140">        if (cnt == 1) {</a>
<a name="ln1141">            CONDITIONAL_SET_FLAG(XOR2(ocf + ((d &gt;&gt; 30) &amp; 0x2)), F_OF);</a>
<a name="ln1142">        }</a>
<a name="ln1143">    }</a>
<a name="ln1144">    return res;</a>
<a name="ln1145">}</a>
<a name="ln1146"> </a>
<a name="ln1147">/****************************************************************************</a>
<a name="ln1148">REMARKS:</a>
<a name="ln1149">Implements the ROL instruction and side effects.</a>
<a name="ln1150">****************************************************************************/</a>
<a name="ln1151">u8</a>
<a name="ln1152">rol_byte(u8 d, u8 s)</a>
<a name="ln1153">{</a>
<a name="ln1154">    register unsigned int res, cnt, mask;</a>
<a name="ln1155"> </a>
<a name="ln1156">    /* rotate left */</a>
<a name="ln1157">    /*</a>
<a name="ln1158">       s is the rotate distance.  It varies from 0 - 8.</a>
<a name="ln1159">       d is the byte object rotated.</a>
<a name="ln1160"> </a>
<a name="ln1161">       have</a>
<a name="ln1162"> </a>
<a name="ln1163">       CF  B_7 ... B_0</a>
<a name="ln1164"> </a>
<a name="ln1165">       The new rotate is done mod 8.</a>
<a name="ln1166">       Much simpler than the &quot;rcl&quot; or &quot;rcr&quot; operations.</a>
<a name="ln1167"> </a>
<a name="ln1168">       IF n &gt; 0</a>
<a name="ln1169">       1) B_(7) .. B_(n)  &lt;-  b_(8-(n+1)) .. b_(0)</a>
<a name="ln1170">       2) B_(n-1) .. B_(0) &lt;-  b_(7) .. b_(8-n)</a>
<a name="ln1171">     */</a>
<a name="ln1172">    res = d;</a>
<a name="ln1173">    if ((cnt = s % 8) != 0) {</a>
<a name="ln1174">        /* B_(7) .. B_(n)  &lt;-  b_(8-(n+1)) .. b_(0) */</a>
<a name="ln1175">        res = (d &lt;&lt; cnt);</a>
<a name="ln1176"> </a>
<a name="ln1177">        /* B_(n-1) .. B_(0) &lt;-  b_(7) .. b_(8-n) */</a>
<a name="ln1178">        mask = (1 &lt;&lt; cnt) - 1;</a>
<a name="ln1179">        res |= (d &gt;&gt; (8 - cnt)) &amp; mask;</a>
<a name="ln1180"> </a>
<a name="ln1181">        /* set the new carry flag, Note that it is the low order</a>
<a name="ln1182">           bit of the result!!!                               */</a>
<a name="ln1183">        CONDITIONAL_SET_FLAG(res &amp; 0x1, F_CF);</a>
<a name="ln1184">        /* OVERFLOW is set *IFF* s==1, then it is the</a>
<a name="ln1185">           xor of CF and the most significant bit.  Blecck. */</a>
<a name="ln1186">        CONDITIONAL_SET_FLAG(s == 1 &amp;&amp;</a>
<a name="ln1187">                             XOR2((res &amp; 0x1) + ((res &gt;&gt; 6) &amp; 0x2)), F_OF);</a>
<a name="ln1188">    }</a>
<a name="ln1189">    if (s != 0) {</a>
<a name="ln1190">        /* set the new carry flag, Note that it is the low order</a>
<a name="ln1191">           bit of the result!!!                               */</a>
<a name="ln1192">        CONDITIONAL_SET_FLAG(res &amp; 0x1, F_CF);</a>
<a name="ln1193">    }</a>
<a name="ln1194">    return (u8) res;</a>
<a name="ln1195">}</a>
<a name="ln1196"> </a>
<a name="ln1197">/****************************************************************************</a>
<a name="ln1198">REMARKS:</a>
<a name="ln1199">Implements the ROL instruction and side effects.</a>
<a name="ln1200">****************************************************************************/</a>
<a name="ln1201">u16</a>
<a name="ln1202">rol_word(u16 d, u8 s)</a>
<a name="ln1203">{</a>
<a name="ln1204">    register unsigned int res, cnt, mask;</a>
<a name="ln1205"> </a>
<a name="ln1206">    res = d;</a>
<a name="ln1207">    if ((cnt = s % 16) != 0) {</a>
<a name="ln1208">        res = (d &lt;&lt; cnt);</a>
<a name="ln1209">        mask = (1 &lt;&lt; cnt) - 1;</a>
<a name="ln1210">        res |= (d &gt;&gt; (16 - cnt)) &amp; mask;</a>
<a name="ln1211">        CONDITIONAL_SET_FLAG(res &amp; 0x1, F_CF);</a>
<a name="ln1212">        CONDITIONAL_SET_FLAG(s == 1 &amp;&amp;</a>
<a name="ln1213">                             XOR2((res &amp; 0x1) + ((res &gt;&gt; 14) &amp; 0x2)), F_OF);</a>
<a name="ln1214">    }</a>
<a name="ln1215">    if (s != 0) {</a>
<a name="ln1216">        /* set the new carry flag, Note that it is the low order</a>
<a name="ln1217">           bit of the result!!!                               */</a>
<a name="ln1218">        CONDITIONAL_SET_FLAG(res &amp; 0x1, F_CF);</a>
<a name="ln1219">    }</a>
<a name="ln1220">    return (u16) res;</a>
<a name="ln1221">}</a>
<a name="ln1222"> </a>
<a name="ln1223">/****************************************************************************</a>
<a name="ln1224">REMARKS:</a>
<a name="ln1225">Implements the ROL instruction and side effects.</a>
<a name="ln1226">****************************************************************************/</a>
<a name="ln1227">u32</a>
<a name="ln1228">rol_long(u32 d, u8 s)</a>
<a name="ln1229">{</a>
<a name="ln1230">    register u32 res, cnt, mask;</a>
<a name="ln1231"> </a>
<a name="ln1232">    res = d;</a>
<a name="ln1233">    if ((cnt = s % 32) != 0) {</a>
<a name="ln1234">        res = (d &lt;&lt; cnt);</a>
<a name="ln1235">        mask = (1 &lt;&lt; cnt) - 1;</a>
<a name="ln1236">        res |= (d &gt;&gt; (32 - cnt)) &amp; mask;</a>
<a name="ln1237">        CONDITIONAL_SET_FLAG(res &amp; 0x1, F_CF);</a>
<a name="ln1238">        CONDITIONAL_SET_FLAG(s == 1 &amp;&amp;</a>
<a name="ln1239">                             XOR2((res &amp; 0x1) + ((res &gt;&gt; 30) &amp; 0x2)), F_OF);</a>
<a name="ln1240">    }</a>
<a name="ln1241">    if (s != 0) {</a>
<a name="ln1242">        /* set the new carry flag, Note that it is the low order</a>
<a name="ln1243">           bit of the result!!!                               */</a>
<a name="ln1244">        CONDITIONAL_SET_FLAG(res &amp; 0x1, F_CF);</a>
<a name="ln1245">    }</a>
<a name="ln1246">    return res;</a>
<a name="ln1247">}</a>
<a name="ln1248"> </a>
<a name="ln1249">/****************************************************************************</a>
<a name="ln1250">REMARKS:</a>
<a name="ln1251">Implements the ROR instruction and side effects.</a>
<a name="ln1252">****************************************************************************/</a>
<a name="ln1253">u8</a>
<a name="ln1254">ror_byte(u8 d, u8 s)</a>
<a name="ln1255">{</a>
<a name="ln1256">    register unsigned int res, cnt, mask;</a>
<a name="ln1257"> </a>
<a name="ln1258">    /* rotate right */</a>
<a name="ln1259">    /*</a>
<a name="ln1260">       s is the rotate distance.  It varies from 0 - 8.</a>
<a name="ln1261">       d is the byte object rotated.</a>
<a name="ln1262"> </a>
<a name="ln1263">       have</a>
<a name="ln1264"> </a>
<a name="ln1265">       B_7 ... B_0</a>
<a name="ln1266"> </a>
<a name="ln1267">       The rotate is done mod 8.</a>
<a name="ln1268"> </a>
<a name="ln1269">       IF n &gt; 0</a>
<a name="ln1270">       1) B_(8-(n+1)) .. B_(0)  &lt;-  b_(7) .. b_(n)</a>
<a name="ln1271">       2) B_(7) .. B_(8-n) &lt;-  b_(n-1) .. b_(0)</a>
<a name="ln1272">     */</a>
<a name="ln1273">    res = d;</a>
<a name="ln1274">    if ((cnt = s % 8) != 0) {   /* not a typo, do nada if cnt==0 */</a>
<a name="ln1275">        /* B_(7) .. B_(8-n) &lt;-  b_(n-1) .. b_(0) */</a>
<a name="ln1276">        res = (d &lt;&lt; (8 - cnt));</a>
<a name="ln1277"> </a>
<a name="ln1278">        /* B_(8-(n+1)) .. B_(0)  &lt;-  b_(7) .. b_(n) */</a>
<a name="ln1279">        mask = (1 &lt;&lt; (8 - cnt)) - 1;</a>
<a name="ln1280">        res |= (d &gt;&gt; (cnt)) &amp; mask;</a>
<a name="ln1281"> </a>
<a name="ln1282">        /* set the new carry flag, Note that it is the low order</a>
<a name="ln1283">           bit of the result!!!                               */</a>
<a name="ln1284">        CONDITIONAL_SET_FLAG(res &amp; 0x80, F_CF);</a>
<a name="ln1285">        /* OVERFLOW is set *IFF* s==1, then it is the</a>
<a name="ln1286">           xor of the two most significant bits.  Blecck. */</a>
<a name="ln1287">        CONDITIONAL_SET_FLAG(s == 1 &amp;&amp; XOR2(res &gt;&gt; 6), F_OF);</a>
<a name="ln1288">    }</a>
<a name="ln1289">    else if (s != 0) {</a>
<a name="ln1290">        /* set the new carry flag, Note that it is the low order</a>
<a name="ln1291">           bit of the result!!!                               */</a>
<a name="ln1292">        CONDITIONAL_SET_FLAG(res &amp; 0x80, F_CF);</a>
<a name="ln1293">    }</a>
<a name="ln1294">    return (u8) res;</a>
<a name="ln1295">}</a>
<a name="ln1296"> </a>
<a name="ln1297">/****************************************************************************</a>
<a name="ln1298">REMARKS:</a>
<a name="ln1299">Implements the ROR instruction and side effects.</a>
<a name="ln1300">****************************************************************************/</a>
<a name="ln1301">u16</a>
<a name="ln1302">ror_word(u16 d, u8 s)</a>
<a name="ln1303">{</a>
<a name="ln1304">    register unsigned int res, cnt, mask;</a>
<a name="ln1305"> </a>
<a name="ln1306">    res = d;</a>
<a name="ln1307">    if ((cnt = s % 16) != 0) {</a>
<a name="ln1308">        res = (d &lt;&lt; (16 - cnt));</a>
<a name="ln1309">        mask = (1 &lt;&lt; (16 - cnt)) - 1;</a>
<a name="ln1310">        res |= (d &gt;&gt; (cnt)) &amp; mask;</a>
<a name="ln1311">        CONDITIONAL_SET_FLAG(res &amp; 0x8000, F_CF);</a>
<a name="ln1312">        CONDITIONAL_SET_FLAG(s == 1 &amp;&amp; XOR2(res &gt;&gt; 14), F_OF);</a>
<a name="ln1313">    }</a>
<a name="ln1314">    else if (s != 0) {</a>
<a name="ln1315">        /* set the new carry flag, Note that it is the low order</a>
<a name="ln1316">           bit of the result!!!                               */</a>
<a name="ln1317">        CONDITIONAL_SET_FLAG(res &amp; 0x8000, F_CF);</a>
<a name="ln1318">    }</a>
<a name="ln1319">    return (u16) res;</a>
<a name="ln1320">}</a>
<a name="ln1321"> </a>
<a name="ln1322">/****************************************************************************</a>
<a name="ln1323">REMARKS:</a>
<a name="ln1324">Implements the ROR instruction and side effects.</a>
<a name="ln1325">****************************************************************************/</a>
<a name="ln1326">u32</a>
<a name="ln1327">ror_long(u32 d, u8 s)</a>
<a name="ln1328">{</a>
<a name="ln1329">    register u32 res, cnt, mask;</a>
<a name="ln1330"> </a>
<a name="ln1331">    res = d;</a>
<a name="ln1332">    if ((cnt = s % 32) != 0) {</a>
<a name="ln1333">        res = (d &lt;&lt; (32 - cnt));</a>
<a name="ln1334">        mask = (1 &lt;&lt; (32 - cnt)) - 1;</a>
<a name="ln1335">        res |= (d &gt;&gt; (cnt)) &amp; mask;</a>
<a name="ln1336">        CONDITIONAL_SET_FLAG(res &amp; 0x80000000, F_CF);</a>
<a name="ln1337">        CONDITIONAL_SET_FLAG(s == 1 &amp;&amp; XOR2(res &gt;&gt; 30), F_OF);</a>
<a name="ln1338">    }</a>
<a name="ln1339">    else if (s != 0) {</a>
<a name="ln1340">        /* set the new carry flag, Note that it is the low order</a>
<a name="ln1341">           bit of the result!!!                               */</a>
<a name="ln1342">        CONDITIONAL_SET_FLAG(res &amp; 0x80000000, F_CF);</a>
<a name="ln1343">    }</a>
<a name="ln1344">    return res;</a>
<a name="ln1345">}</a>
<a name="ln1346"> </a>
<a name="ln1347">/****************************************************************************</a>
<a name="ln1348">REMARKS:</a>
<a name="ln1349">Implements the SHL instruction and side effects.</a>
<a name="ln1350">****************************************************************************/</a>
<a name="ln1351">u8</a>
<a name="ln1352">shl_byte(u8 d, u8 s)</a>
<a name="ln1353">{</a>
<a name="ln1354">    unsigned int cnt, res, cf;</a>
<a name="ln1355"> </a>
<a name="ln1356">    if (s &lt; 8) {</a>
<a name="ln1357">        cnt = s % 8;</a>
<a name="ln1358"> </a>
<a name="ln1359">        /* last bit shifted out goes into carry flag */</a>
<a name="ln1360">        if (cnt &gt; 0) {</a>
<a name="ln1361">            res = d &lt;&lt; cnt;</a>
<a name="ln1362">            cf = d &amp; (1 &lt;&lt; (8 - cnt));</a>
<a name="ln1363">            CONDITIONAL_SET_FLAG(cf, F_CF);</a>
<a name="ln1364">            CONDITIONAL_SET_FLAG((res &amp; 0xff) == 0, F_ZF);</a>
<a name="ln1365">            CONDITIONAL_SET_FLAG(res &amp; 0x80, F_SF);</a>
<a name="ln1366">            CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln1367">        }</a>
<a name="ln1368">        else {</a>
<a name="ln1369">            res = (u8) d;</a>
<a name="ln1370">        }</a>
<a name="ln1371"> </a>
<a name="ln1372">        if (cnt == 1) {</a>
<a name="ln1373">            /* Needs simplification. */</a>
<a name="ln1374">            CONDITIONAL_SET_FLAG((((res &amp; 0x80) == 0x80) ^</a>
<a name="ln1375">                                  (ACCESS_FLAG(F_CF) != 0)),</a>
<a name="ln1376">                                 /* was (M.x86.R_FLG&amp;F_CF)==F_CF)), */</a>
<a name="ln1377">                                 F_OF);</a>
<a name="ln1378">        }</a>
<a name="ln1379">        else {</a>
<a name="ln1380">            CLEAR_FLAG(F_OF);</a>
<a name="ln1381">        }</a>
<a name="ln1382">    }</a>
<a name="ln1383">    else {</a>
<a name="ln1384">        res = 0;</a>
<a name="ln1385">        CONDITIONAL_SET_FLAG((d &lt;&lt; (s - 1)) &amp; 0x80, F_CF);</a>
<a name="ln1386">        CLEAR_FLAG(F_OF);</a>
<a name="ln1387">        CLEAR_FLAG(F_SF);</a>
<a name="ln1388">        SET_FLAG(F_PF);</a>
<a name="ln1389">        SET_FLAG(F_ZF);</a>
<a name="ln1390">    }</a>
<a name="ln1391">    return (u8) res;</a>
<a name="ln1392">}</a>
<a name="ln1393"> </a>
<a name="ln1394">/****************************************************************************</a>
<a name="ln1395">REMARKS:</a>
<a name="ln1396">Implements the SHL instruction and side effects.</a>
<a name="ln1397">****************************************************************************/</a>
<a name="ln1398">u16</a>
<a name="ln1399">shl_word(u16 d, u8 s)</a>
<a name="ln1400">{</a>
<a name="ln1401">    unsigned int cnt, res, cf;</a>
<a name="ln1402"> </a>
<a name="ln1403">    if (s &lt; 16) {</a>
<a name="ln1404">        cnt = s % 16;</a>
<a name="ln1405">        if (cnt &gt; 0) {</a>
<a name="ln1406">            res = d &lt;&lt; cnt;</a>
<a name="ln1407">            cf = d &amp; (1 &lt;&lt; (16 - cnt));</a>
<a name="ln1408">            CONDITIONAL_SET_FLAG(cf, F_CF);</a>
<a name="ln1409">            CONDITIONAL_SET_FLAG((res &amp; 0xffff) == 0, F_ZF);</a>
<a name="ln1410">            CONDITIONAL_SET_FLAG(res &amp; 0x8000, F_SF);</a>
<a name="ln1411">            CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln1412">        }</a>
<a name="ln1413">        else {</a>
<a name="ln1414">            res = (u16) d;</a>
<a name="ln1415">        }</a>
<a name="ln1416"> </a>
<a name="ln1417">        if (cnt == 1) {</a>
<a name="ln1418">            CONDITIONAL_SET_FLAG((((res &amp; 0x8000) == 0x8000) ^</a>
<a name="ln1419">                                  (ACCESS_FLAG(F_CF) != 0)), F_OF);</a>
<a name="ln1420">        }</a>
<a name="ln1421">        else {</a>
<a name="ln1422">            CLEAR_FLAG(F_OF);</a>
<a name="ln1423">        }</a>
<a name="ln1424">    }</a>
<a name="ln1425">    else {</a>
<a name="ln1426">        res = 0;</a>
<a name="ln1427">        CONDITIONAL_SET_FLAG((d &lt;&lt; (s - 1)) &amp; 0x8000, F_CF);</a>
<a name="ln1428">        CLEAR_FLAG(F_OF);</a>
<a name="ln1429">        CLEAR_FLAG(F_SF);</a>
<a name="ln1430">        SET_FLAG(F_PF);</a>
<a name="ln1431">        SET_FLAG(F_ZF);</a>
<a name="ln1432">    }</a>
<a name="ln1433">    return (u16) res;</a>
<a name="ln1434">}</a>
<a name="ln1435"> </a>
<a name="ln1436">/****************************************************************************</a>
<a name="ln1437">REMARKS:</a>
<a name="ln1438">Implements the SHL instruction and side effects.</a>
<a name="ln1439">****************************************************************************/</a>
<a name="ln1440">u32</a>
<a name="ln1441">shl_long(u32 d, u8 s)</a>
<a name="ln1442">{</a>
<a name="ln1443">    unsigned int cnt, res, cf;</a>
<a name="ln1444"> </a>
<a name="ln1445">    if (s &lt; 32) {</a>
<a name="ln1446">        cnt = s % 32;</a>
<a name="ln1447">        if (cnt &gt; 0) {</a>
<a name="ln1448">            res = d &lt;&lt; cnt;</a>
<a name="ln1449">            cf = d &amp; (1 &lt;&lt; (32 - cnt));</a>
<a name="ln1450">            CONDITIONAL_SET_FLAG(cf, F_CF);</a>
<a name="ln1451">            CONDITIONAL_SET_FLAG((res &amp; 0xffffffff) == 0, F_ZF);</a>
<a name="ln1452">            CONDITIONAL_SET_FLAG(res &amp; 0x80000000, F_SF);</a>
<a name="ln1453">            CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln1454">        }</a>
<a name="ln1455">        else {</a>
<a name="ln1456">            res = d;</a>
<a name="ln1457">        }</a>
<a name="ln1458">        if (cnt == 1) {</a>
<a name="ln1459">            CONDITIONAL_SET_FLAG((((res &amp; 0x80000000) == 0x80000000) ^</a>
<a name="ln1460">                                  (ACCESS_FLAG(F_CF) != 0)), F_OF);</a>
<a name="ln1461">        }</a>
<a name="ln1462">        else {</a>
<a name="ln1463">            CLEAR_FLAG(F_OF);</a>
<a name="ln1464">        }</a>
<a name="ln1465">    }</a>
<a name="ln1466">    else {</a>
<a name="ln1467">        res = 0;</a>
<a name="ln1468">        CONDITIONAL_SET_FLAG((d &lt;&lt; (s - 1)) &amp; 0x80000000, F_CF);</a>
<a name="ln1469">        CLEAR_FLAG(F_OF);</a>
<a name="ln1470">        CLEAR_FLAG(F_SF);</a>
<a name="ln1471">        SET_FLAG(F_PF);</a>
<a name="ln1472">        SET_FLAG(F_ZF);</a>
<a name="ln1473">    }</a>
<a name="ln1474">    return res;</a>
<a name="ln1475">}</a>
<a name="ln1476"> </a>
<a name="ln1477">/****************************************************************************</a>
<a name="ln1478">REMARKS:</a>
<a name="ln1479">Implements the SHR instruction and side effects.</a>
<a name="ln1480">****************************************************************************/</a>
<a name="ln1481">u8</a>
<a name="ln1482">shr_byte(u8 d, u8 s)</a>
<a name="ln1483">{</a>
<a name="ln1484">    unsigned int cnt, res, cf;</a>
<a name="ln1485"> </a>
<a name="ln1486">    if (s &lt; 8) {</a>
<a name="ln1487">        cnt = s % 8;</a>
<a name="ln1488">        if (cnt &gt; 0) {</a>
<a name="ln1489">            cf = d &amp; (1 &lt;&lt; (cnt - 1));</a>
<a name="ln1490">            res = d &gt;&gt; cnt;</a>
<a name="ln1491">            CONDITIONAL_SET_FLAG(cf, F_CF);</a>
<a name="ln1492">            CONDITIONAL_SET_FLAG((res &amp; 0xff) == 0, F_ZF);</a>
<a name="ln1493">            CONDITIONAL_SET_FLAG(res &amp; 0x80, F_SF);</a>
<a name="ln1494">            CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln1495">        }</a>
<a name="ln1496">        else {</a>
<a name="ln1497">            res = (u8) d;</a>
<a name="ln1498">        }</a>
<a name="ln1499"> </a>
<a name="ln1500">        if (cnt == 1) {</a>
<a name="ln1501">            CONDITIONAL_SET_FLAG(XOR2(res &gt;&gt; 6), F_OF);</a>
<a name="ln1502">        }</a>
<a name="ln1503">        else {</a>
<a name="ln1504">            CLEAR_FLAG(F_OF);</a>
<a name="ln1505">        }</a>
<a name="ln1506">    }</a>
<a name="ln1507">    else {</a>
<a name="ln1508">        res = 0;</a>
<a name="ln1509">        CONDITIONAL_SET_FLAG((d &gt;&gt; (s - 1)) &amp; 0x1, F_CF);</a>
<a name="ln1510">        CLEAR_FLAG(F_OF);</a>
<a name="ln1511">        CLEAR_FLAG(F_SF);</a>
<a name="ln1512">        SET_FLAG(F_PF);</a>
<a name="ln1513">        SET_FLAG(F_ZF);</a>
<a name="ln1514">    }</a>
<a name="ln1515">    return (u8) res;</a>
<a name="ln1516">}</a>
<a name="ln1517"> </a>
<a name="ln1518">/****************************************************************************</a>
<a name="ln1519">REMARKS:</a>
<a name="ln1520">Implements the SHR instruction and side effects.</a>
<a name="ln1521">****************************************************************************/</a>
<a name="ln1522">u16</a>
<a name="ln1523">shr_word(u16 d, u8 s)</a>
<a name="ln1524">{</a>
<a name="ln1525">    unsigned int cnt, res, cf;</a>
<a name="ln1526"> </a>
<a name="ln1527">    if (s &lt; 16) {</a>
<a name="ln1528">        cnt = s % 16;</a>
<a name="ln1529">        if (cnt &gt; 0) {</a>
<a name="ln1530">            cf = d &amp; (1 &lt;&lt; (cnt - 1));</a>
<a name="ln1531">            res = d &gt;&gt; cnt;</a>
<a name="ln1532">            CONDITIONAL_SET_FLAG(cf, F_CF);</a>
<a name="ln1533">            CONDITIONAL_SET_FLAG((res &amp; 0xffff) == 0, F_ZF);</a>
<a name="ln1534">            CONDITIONAL_SET_FLAG(res &amp; 0x8000, F_SF);</a>
<a name="ln1535">            CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln1536">        }</a>
<a name="ln1537">        else {</a>
<a name="ln1538">            res = d;</a>
<a name="ln1539">        }</a>
<a name="ln1540"> </a>
<a name="ln1541">        if (cnt == 1) {</a>
<a name="ln1542">            CONDITIONAL_SET_FLAG(XOR2(res &gt;&gt; 14), F_OF);</a>
<a name="ln1543">        }</a>
<a name="ln1544">        else {</a>
<a name="ln1545">            CLEAR_FLAG(F_OF);</a>
<a name="ln1546">        }</a>
<a name="ln1547">    }</a>
<a name="ln1548">    else {</a>
<a name="ln1549">        res = 0;</a>
<a name="ln1550">        CLEAR_FLAG(F_CF);</a>
<a name="ln1551">        CLEAR_FLAG(F_OF);</a>
<a name="ln1552">        SET_FLAG(F_ZF);</a>
<a name="ln1553">        CLEAR_FLAG(F_SF);</a>
<a name="ln1554">        CLEAR_FLAG(F_PF);</a>
<a name="ln1555">    }</a>
<a name="ln1556">    return (u16) res;</a>
<a name="ln1557">}</a>
<a name="ln1558"> </a>
<a name="ln1559">/****************************************************************************</a>
<a name="ln1560">REMARKS:</a>
<a name="ln1561">Implements the SHR instruction and side effects.</a>
<a name="ln1562">****************************************************************************/</a>
<a name="ln1563">u32</a>
<a name="ln1564">shr_long(u32 d, u8 s)</a>
<a name="ln1565">{</a>
<a name="ln1566">    unsigned int cnt, res, cf;</a>
<a name="ln1567"> </a>
<a name="ln1568">    if (s &lt; 32) {</a>
<a name="ln1569">        cnt = s % 32;</a>
<a name="ln1570">        if (cnt &gt; 0) {</a>
<a name="ln1571">            cf = d &amp; (1 &lt;&lt; (cnt - 1));</a>
<a name="ln1572">            res = d &gt;&gt; cnt;</a>
<a name="ln1573">            CONDITIONAL_SET_FLAG(cf, F_CF);</a>
<a name="ln1574">            CONDITIONAL_SET_FLAG((res &amp; 0xffffffff) == 0, F_ZF);</a>
<a name="ln1575">            CONDITIONAL_SET_FLAG(res &amp; 0x80000000, F_SF);</a>
<a name="ln1576">            CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln1577">        }</a>
<a name="ln1578">        else {</a>
<a name="ln1579">            res = d;</a>
<a name="ln1580">        }</a>
<a name="ln1581">        if (cnt == 1) {</a>
<a name="ln1582">            CONDITIONAL_SET_FLAG(XOR2(res &gt;&gt; 30), F_OF);</a>
<a name="ln1583">        }</a>
<a name="ln1584">        else {</a>
<a name="ln1585">            CLEAR_FLAG(F_OF);</a>
<a name="ln1586">        }</a>
<a name="ln1587">    }</a>
<a name="ln1588">    else {</a>
<a name="ln1589">        res = 0;</a>
<a name="ln1590">        CLEAR_FLAG(F_CF);</a>
<a name="ln1591">        CLEAR_FLAG(F_OF);</a>
<a name="ln1592">        SET_FLAG(F_ZF);</a>
<a name="ln1593">        CLEAR_FLAG(F_SF);</a>
<a name="ln1594">        CLEAR_FLAG(F_PF);</a>
<a name="ln1595">    }</a>
<a name="ln1596">    return res;</a>
<a name="ln1597">}</a>
<a name="ln1598"> </a>
<a name="ln1599">/****************************************************************************</a>
<a name="ln1600">REMARKS:</a>
<a name="ln1601">Implements the SAR instruction and side effects.</a>
<a name="ln1602">****************************************************************************/</a>
<a name="ln1603">u8</a>
<a name="ln1604">sar_byte(u8 d, u8 s)</a>
<a name="ln1605">{</a>
<a name="ln1606">    unsigned int cnt, res, cf, mask, sf;</a>
<a name="ln1607"> </a>
<a name="ln1608">    res = d;</a>
<a name="ln1609">    sf = d &amp; 0x80;</a>
<a name="ln1610">    cnt = s % 8;</a>
<a name="ln1611">    if (cnt &gt; 0 &amp;&amp; cnt &lt; 8) {</a>
<a name="ln1612">        mask = (1 &lt;&lt; (8 - cnt)) - 1;</a>
<a name="ln1613">        cf = d &amp; (1 &lt;&lt; (cnt - 1));</a>
<a name="ln1614">        res = (d &gt;&gt; cnt) &amp; mask;</a>
<a name="ln1615">        CONDITIONAL_SET_FLAG(cf, F_CF);</a>
<a name="ln1616">        if (sf) {</a>
<a name="ln1617">            res |= ~mask;</a>
<a name="ln1618">        }</a>
<a name="ln1619">        CONDITIONAL_SET_FLAG((res &amp; 0xff) == 0, F_ZF);</a>
<a name="ln1620">        CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln1621">        CONDITIONAL_SET_FLAG(res &amp; 0x80, F_SF);</a>
<a name="ln1622">    }</a>
<a name="ln1623">    else if (cnt &gt;= 8) {</a>
<a name="ln1624">        if (sf) {</a>
<a name="ln1625">            res = 0xff;</a>
<a name="ln1626">            SET_FLAG(F_CF);</a>
<a name="ln1627">            CLEAR_FLAG(F_ZF);</a>
<a name="ln1628">            SET_FLAG(F_SF);</a>
<a name="ln1629">            SET_FLAG(F_PF);</a>
<a name="ln1630">        }</a>
<a name="ln1631">        else {</a>
<a name="ln1632">            res = 0;</a>
<a name="ln1633">            CLEAR_FLAG(F_CF);</a>
<a name="ln1634">            SET_FLAG(F_ZF);</a>
<a name="ln1635">            CLEAR_FLAG(F_SF);</a>
<a name="ln1636">            CLEAR_FLAG(F_PF);</a>
<a name="ln1637">        }</a>
<a name="ln1638">    }</a>
<a name="ln1639">    return (u8) res;</a>
<a name="ln1640">}</a>
<a name="ln1641"> </a>
<a name="ln1642">/****************************************************************************</a>
<a name="ln1643">REMARKS:</a>
<a name="ln1644">Implements the SAR instruction and side effects.</a>
<a name="ln1645">****************************************************************************/</a>
<a name="ln1646">u16</a>
<a name="ln1647">sar_word(u16 d, u8 s)</a>
<a name="ln1648">{</a>
<a name="ln1649">    unsigned int cnt, res, cf, mask, sf;</a>
<a name="ln1650"> </a>
<a name="ln1651">    sf = d &amp; 0x8000;</a>
<a name="ln1652">    cnt = s % 16;</a>
<a name="ln1653">    res = d;</a>
<a name="ln1654">    if (cnt &gt; 0 &amp;&amp; cnt &lt; 16) {</a>
<a name="ln1655">        mask = (1 &lt;&lt; (16 - cnt)) - 1;</a>
<a name="ln1656">        cf = d &amp; (1 &lt;&lt; (cnt - 1));</a>
<a name="ln1657">        res = (d &gt;&gt; cnt) &amp; mask;</a>
<a name="ln1658">        CONDITIONAL_SET_FLAG(cf, F_CF);</a>
<a name="ln1659">        if (sf) {</a>
<a name="ln1660">            res |= ~mask;</a>
<a name="ln1661">        }</a>
<a name="ln1662">        CONDITIONAL_SET_FLAG((res &amp; 0xffff) == 0, F_ZF);</a>
<a name="ln1663">        CONDITIONAL_SET_FLAG(res &amp; 0x8000, F_SF);</a>
<a name="ln1664">        CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln1665">    }</a>
<a name="ln1666">    else if (cnt &gt;= 16) {</a>
<a name="ln1667">        if (sf) {</a>
<a name="ln1668">            res = 0xffff;</a>
<a name="ln1669">            SET_FLAG(F_CF);</a>
<a name="ln1670">            CLEAR_FLAG(F_ZF);</a>
<a name="ln1671">            SET_FLAG(F_SF);</a>
<a name="ln1672">            SET_FLAG(F_PF);</a>
<a name="ln1673">        }</a>
<a name="ln1674">        else {</a>
<a name="ln1675">            res = 0;</a>
<a name="ln1676">            CLEAR_FLAG(F_CF);</a>
<a name="ln1677">            SET_FLAG(F_ZF);</a>
<a name="ln1678">            CLEAR_FLAG(F_SF);</a>
<a name="ln1679">            CLEAR_FLAG(F_PF);</a>
<a name="ln1680">        }</a>
<a name="ln1681">    }</a>
<a name="ln1682">    return (u16) res;</a>
<a name="ln1683">}</a>
<a name="ln1684"> </a>
<a name="ln1685">/****************************************************************************</a>
<a name="ln1686">REMARKS:</a>
<a name="ln1687">Implements the SAR instruction and side effects.</a>
<a name="ln1688">****************************************************************************/</a>
<a name="ln1689">u32</a>
<a name="ln1690">sar_long(u32 d, u8 s)</a>
<a name="ln1691">{</a>
<a name="ln1692">    u32 cnt, res, cf, mask, sf;</a>
<a name="ln1693"> </a>
<a name="ln1694">    sf = d &amp; 0x80000000;</a>
<a name="ln1695">    cnt = s % 32;</a>
<a name="ln1696">    res = d;</a>
<a name="ln1697">    if (cnt &gt; 0 &amp;&amp; cnt &lt; 32) {</a>
<a name="ln1698">        mask = (1 &lt;&lt; (32 - cnt)) - 1;</a>
<a name="ln1699">        cf = d &amp; (1 &lt;&lt; (cnt - 1));</a>
<a name="ln1700">        res = (d &gt;&gt; cnt) &amp; mask;</a>
<a name="ln1701">        CONDITIONAL_SET_FLAG(cf, F_CF);</a>
<a name="ln1702">        if (sf) {</a>
<a name="ln1703">            res |= ~mask;</a>
<a name="ln1704">        }</a>
<a name="ln1705">        CONDITIONAL_SET_FLAG((res &amp; 0xffffffff) == 0, F_ZF);</a>
<a name="ln1706">        CONDITIONAL_SET_FLAG(res &amp; 0x80000000, F_SF);</a>
<a name="ln1707">        CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln1708">    }</a>
<a name="ln1709">    else if (cnt &gt;= 32) {</a>
<a name="ln1710">        if (sf) {</a>
<a name="ln1711">            res = 0xffffffff;</a>
<a name="ln1712">            SET_FLAG(F_CF);</a>
<a name="ln1713">            CLEAR_FLAG(F_ZF);</a>
<a name="ln1714">            SET_FLAG(F_SF);</a>
<a name="ln1715">            SET_FLAG(F_PF);</a>
<a name="ln1716">        }</a>
<a name="ln1717">        else {</a>
<a name="ln1718">            res = 0;</a>
<a name="ln1719">            CLEAR_FLAG(F_CF);</a>
<a name="ln1720">            SET_FLAG(F_ZF);</a>
<a name="ln1721">            CLEAR_FLAG(F_SF);</a>
<a name="ln1722">            CLEAR_FLAG(F_PF);</a>
<a name="ln1723">        }</a>
<a name="ln1724">    }</a>
<a name="ln1725">    return res;</a>
<a name="ln1726">}</a>
<a name="ln1727"> </a>
<a name="ln1728">/****************************************************************************</a>
<a name="ln1729">REMARKS:</a>
<a name="ln1730">Implements the SHLD instruction and side effects.</a>
<a name="ln1731">****************************************************************************/</a>
<a name="ln1732">u16</a>
<a name="ln1733">shld_word(u16 d, u16 fill, u8 s)</a>
<a name="ln1734">{</a>
<a name="ln1735">    unsigned int cnt, res, cf;</a>
<a name="ln1736"> </a>
<a name="ln1737">    if (s &lt; 16) {</a>
<a name="ln1738">        cnt = s % 16;</a>
<a name="ln1739">        if (cnt &gt; 0) {</a>
<a name="ln1740">            res = (d &lt;&lt; cnt) | (fill &gt;&gt; (16 - cnt));</a>
<a name="ln1741">            cf = d &amp; (1 &lt;&lt; (16 - cnt));</a>
<a name="ln1742">            CONDITIONAL_SET_FLAG(cf, F_CF);</a>
<a name="ln1743">            CONDITIONAL_SET_FLAG((res &amp; 0xffff) == 0, F_ZF);</a>
<a name="ln1744">            CONDITIONAL_SET_FLAG(res &amp; 0x8000, F_SF);</a>
<a name="ln1745">            CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln1746">        }</a>
<a name="ln1747">        else {</a>
<a name="ln1748">            res = d;</a>
<a name="ln1749">        }</a>
<a name="ln1750">        if (cnt == 1) {</a>
<a name="ln1751">            CONDITIONAL_SET_FLAG((((res &amp; 0x8000) == 0x8000) ^</a>
<a name="ln1752">                                  (ACCESS_FLAG(F_CF) != 0)), F_OF);</a>
<a name="ln1753">        }</a>
<a name="ln1754">        else {</a>
<a name="ln1755">            CLEAR_FLAG(F_OF);</a>
<a name="ln1756">        }</a>
<a name="ln1757">    }</a>
<a name="ln1758">    else {</a>
<a name="ln1759">        res = 0;</a>
<a name="ln1760">        CONDITIONAL_SET_FLAG((d &lt;&lt; (s - 1)) &amp; 0x8000, F_CF);</a>
<a name="ln1761">        CLEAR_FLAG(F_OF);</a>
<a name="ln1762">        CLEAR_FLAG(F_SF);</a>
<a name="ln1763">        SET_FLAG(F_PF);</a>
<a name="ln1764">        SET_FLAG(F_ZF);</a>
<a name="ln1765">    }</a>
<a name="ln1766">    return (u16) res;</a>
<a name="ln1767">}</a>
<a name="ln1768"> </a>
<a name="ln1769">/****************************************************************************</a>
<a name="ln1770">REMARKS:</a>
<a name="ln1771">Implements the SHLD instruction and side effects.</a>
<a name="ln1772">****************************************************************************/</a>
<a name="ln1773">u32</a>
<a name="ln1774">shld_long(u32 d, u32 fill, u8 s)</a>
<a name="ln1775">{</a>
<a name="ln1776">    unsigned int cnt, res, cf;</a>
<a name="ln1777"> </a>
<a name="ln1778">    if (s &lt; 32) {</a>
<a name="ln1779">        cnt = s % 32;</a>
<a name="ln1780">        if (cnt &gt; 0) {</a>
<a name="ln1781">            res = (d &lt;&lt; cnt) | (fill &gt;&gt; (32 - cnt));</a>
<a name="ln1782">            cf = d &amp; (1 &lt;&lt; (32 - cnt));</a>
<a name="ln1783">            CONDITIONAL_SET_FLAG(cf, F_CF);</a>
<a name="ln1784">            CONDITIONAL_SET_FLAG((res &amp; 0xffffffff) == 0, F_ZF);</a>
<a name="ln1785">            CONDITIONAL_SET_FLAG(res &amp; 0x80000000, F_SF);</a>
<a name="ln1786">            CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln1787">        }</a>
<a name="ln1788">        else {</a>
<a name="ln1789">            res = d;</a>
<a name="ln1790">        }</a>
<a name="ln1791">        if (cnt == 1) {</a>
<a name="ln1792">            CONDITIONAL_SET_FLAG((((res &amp; 0x80000000) == 0x80000000) ^</a>
<a name="ln1793">                                  (ACCESS_FLAG(F_CF) != 0)), F_OF);</a>
<a name="ln1794">        }</a>
<a name="ln1795">        else {</a>
<a name="ln1796">            CLEAR_FLAG(F_OF);</a>
<a name="ln1797">        }</a>
<a name="ln1798">    }</a>
<a name="ln1799">    else {</a>
<a name="ln1800">        res = 0;</a>
<a name="ln1801">        CONDITIONAL_SET_FLAG((d &lt;&lt; (s - 1)) &amp; 0x80000000, F_CF);</a>
<a name="ln1802">        CLEAR_FLAG(F_OF);</a>
<a name="ln1803">        CLEAR_FLAG(F_SF);</a>
<a name="ln1804">        SET_FLAG(F_PF);</a>
<a name="ln1805">        SET_FLAG(F_ZF);</a>
<a name="ln1806">    }</a>
<a name="ln1807">    return res;</a>
<a name="ln1808">}</a>
<a name="ln1809"> </a>
<a name="ln1810">/****************************************************************************</a>
<a name="ln1811">REMARKS:</a>
<a name="ln1812">Implements the SHRD instruction and side effects.</a>
<a name="ln1813">****************************************************************************/</a>
<a name="ln1814">u16</a>
<a name="ln1815">shrd_word(u16 d, u16 fill, u8 s)</a>
<a name="ln1816">{</a>
<a name="ln1817">    unsigned int cnt, res, cf;</a>
<a name="ln1818"> </a>
<a name="ln1819">    if (s &lt; 16) {</a>
<a name="ln1820">        cnt = s % 16;</a>
<a name="ln1821">        if (cnt &gt; 0) {</a>
<a name="ln1822">            cf = d &amp; (1 &lt;&lt; (cnt - 1));</a>
<a name="ln1823">            res = (d &gt;&gt; cnt) | (fill &lt;&lt; (16 - cnt));</a>
<a name="ln1824">            CONDITIONAL_SET_FLAG(cf, F_CF);</a>
<a name="ln1825">            CONDITIONAL_SET_FLAG((res &amp; 0xffff) == 0, F_ZF);</a>
<a name="ln1826">            CONDITIONAL_SET_FLAG(res &amp; 0x8000, F_SF);</a>
<a name="ln1827">            CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln1828">        }</a>
<a name="ln1829">        else {</a>
<a name="ln1830">            res = d;</a>
<a name="ln1831">        }</a>
<a name="ln1832"> </a>
<a name="ln1833">        if (cnt == 1) {</a>
<a name="ln1834">            CONDITIONAL_SET_FLAG(XOR2(res &gt;&gt; 14), F_OF);</a>
<a name="ln1835">        }</a>
<a name="ln1836">        else {</a>
<a name="ln1837">            CLEAR_FLAG(F_OF);</a>
<a name="ln1838">        }</a>
<a name="ln1839">    }</a>
<a name="ln1840">    else {</a>
<a name="ln1841">        res = 0;</a>
<a name="ln1842">        CLEAR_FLAG(F_CF);</a>
<a name="ln1843">        CLEAR_FLAG(F_OF);</a>
<a name="ln1844">        SET_FLAG(F_ZF);</a>
<a name="ln1845">        CLEAR_FLAG(F_SF);</a>
<a name="ln1846">        CLEAR_FLAG(F_PF);</a>
<a name="ln1847">    }</a>
<a name="ln1848">    return (u16) res;</a>
<a name="ln1849">}</a>
<a name="ln1850"> </a>
<a name="ln1851">/****************************************************************************</a>
<a name="ln1852">REMARKS:</a>
<a name="ln1853">Implements the SHRD instruction and side effects.</a>
<a name="ln1854">****************************************************************************/</a>
<a name="ln1855">u32</a>
<a name="ln1856">shrd_long(u32 d, u32 fill, u8 s)</a>
<a name="ln1857">{</a>
<a name="ln1858">    unsigned int cnt, res, cf;</a>
<a name="ln1859"> </a>
<a name="ln1860">    if (s &lt; 32) {</a>
<a name="ln1861">        cnt = s % 32;</a>
<a name="ln1862">        if (cnt &gt; 0) {</a>
<a name="ln1863">            cf = d &amp; (1 &lt;&lt; (cnt - 1));</a>
<a name="ln1864">            res = (d &gt;&gt; cnt) | (fill &lt;&lt; (32 - cnt));</a>
<a name="ln1865">            CONDITIONAL_SET_FLAG(cf, F_CF);</a>
<a name="ln1866">            CONDITIONAL_SET_FLAG((res &amp; 0xffffffff) == 0, F_ZF);</a>
<a name="ln1867">            CONDITIONAL_SET_FLAG(res &amp; 0x80000000, F_SF);</a>
<a name="ln1868">            CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln1869">        }</a>
<a name="ln1870">        else {</a>
<a name="ln1871">            res = d;</a>
<a name="ln1872">        }</a>
<a name="ln1873">        if (cnt == 1) {</a>
<a name="ln1874">            CONDITIONAL_SET_FLAG(XOR2(res &gt;&gt; 30), F_OF);</a>
<a name="ln1875">        }</a>
<a name="ln1876">        else {</a>
<a name="ln1877">            CLEAR_FLAG(F_OF);</a>
<a name="ln1878">        }</a>
<a name="ln1879">    }</a>
<a name="ln1880">    else {</a>
<a name="ln1881">        res = 0;</a>
<a name="ln1882">        CLEAR_FLAG(F_CF);</a>
<a name="ln1883">        CLEAR_FLAG(F_OF);</a>
<a name="ln1884">        SET_FLAG(F_ZF);</a>
<a name="ln1885">        CLEAR_FLAG(F_SF);</a>
<a name="ln1886">        CLEAR_FLAG(F_PF);</a>
<a name="ln1887">    }</a>
<a name="ln1888">    return res;</a>
<a name="ln1889">}</a>
<a name="ln1890"> </a>
<a name="ln1891">/****************************************************************************</a>
<a name="ln1892">REMARKS:</a>
<a name="ln1893">Implements the SBB instruction and side effects.</a>
<a name="ln1894">****************************************************************************/</a>
<a name="ln1895">u8</a>
<a name="ln1896">sbb_byte(u8 d, u8 s)</a>
<a name="ln1897">{</a>
<a name="ln1898">    register u32 res;           /* all operands in native machine order */</a>
<a name="ln1899">    register u32 bc;</a>
<a name="ln1900"> </a>
<a name="ln1901">    if (ACCESS_FLAG(F_CF))</a>
<a name="ln1902">        res = d - s - 1;</a>
<a name="ln1903">    else</a>
<a name="ln1904">        res = d - s;</a>
<a name="ln1905">    CONDITIONAL_SET_FLAG(res &amp; 0x80, F_SF);</a>
<a name="ln1906">    CONDITIONAL_SET_FLAG((res &amp; 0xff) == 0, F_ZF);</a>
<a name="ln1907">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln1908"> </a>
<a name="ln1909">    /* calculate the borrow chain.  See note at top */</a>
<a name="ln1910">    bc = (res &amp; (~d | s)) | (~d &amp; s);</a>
<a name="ln1911">    CONDITIONAL_SET_FLAG(bc &amp; 0x80, F_CF);</a>
<a name="ln1912">    CONDITIONAL_SET_FLAG(XOR2(bc &gt;&gt; 6), F_OF);</a>
<a name="ln1913">    CONDITIONAL_SET_FLAG(bc &amp; 0x8, F_AF);</a>
<a name="ln1914">    return (u8) res;</a>
<a name="ln1915">}</a>
<a name="ln1916"> </a>
<a name="ln1917">/****************************************************************************</a>
<a name="ln1918">REMARKS:</a>
<a name="ln1919">Implements the SBB instruction and side effects.</a>
<a name="ln1920">****************************************************************************/</a>
<a name="ln1921">u16</a>
<a name="ln1922">sbb_word(u16 d, u16 s)</a>
<a name="ln1923">{</a>
<a name="ln1924">    register u32 res;           /* all operands in native machine order */</a>
<a name="ln1925">    register u32 bc;</a>
<a name="ln1926"> </a>
<a name="ln1927">    if (ACCESS_FLAG(F_CF))</a>
<a name="ln1928">        res = d - s - 1;</a>
<a name="ln1929">    else</a>
<a name="ln1930">        res = d - s;</a>
<a name="ln1931">    CONDITIONAL_SET_FLAG(res &amp; 0x8000, F_SF);</a>
<a name="ln1932">    CONDITIONAL_SET_FLAG((res &amp; 0xffff) == 0, F_ZF);</a>
<a name="ln1933">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln1934"> </a>
<a name="ln1935">    /* calculate the borrow chain.  See note at top */</a>
<a name="ln1936">    bc = (res &amp; (~d | s)) | (~d &amp; s);</a>
<a name="ln1937">    CONDITIONAL_SET_FLAG(bc &amp; 0x8000, F_CF);</a>
<a name="ln1938">    CONDITIONAL_SET_FLAG(XOR2(bc &gt;&gt; 14), F_OF);</a>
<a name="ln1939">    CONDITIONAL_SET_FLAG(bc &amp; 0x8, F_AF);</a>
<a name="ln1940">    return (u16) res;</a>
<a name="ln1941">}</a>
<a name="ln1942"> </a>
<a name="ln1943">/****************************************************************************</a>
<a name="ln1944">REMARKS:</a>
<a name="ln1945">Implements the SBB instruction and side effects.</a>
<a name="ln1946">****************************************************************************/</a>
<a name="ln1947">u32</a>
<a name="ln1948">sbb_long(u32 d, u32 s)</a>
<a name="ln1949">{</a>
<a name="ln1950">    register u32 res;           /* all operands in native machine order */</a>
<a name="ln1951">    register u32 bc;</a>
<a name="ln1952"> </a>
<a name="ln1953">    if (ACCESS_FLAG(F_CF))</a>
<a name="ln1954">        res = d - s - 1;</a>
<a name="ln1955">    else</a>
<a name="ln1956">        res = d - s;</a>
<a name="ln1957">    CONDITIONAL_SET_FLAG(res &amp; 0x80000000, F_SF);</a>
<a name="ln1958">    CONDITIONAL_SET_FLAG((res &amp; 0xffffffff) == 0, F_ZF);</a>
<a name="ln1959">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln1960"> </a>
<a name="ln1961">    /* calculate the borrow chain.  See note at top */</a>
<a name="ln1962">    bc = (res &amp; (~d | s)) | (~d &amp; s);</a>
<a name="ln1963">    CONDITIONAL_SET_FLAG(bc &amp; 0x80000000, F_CF);</a>
<a name="ln1964">    CONDITIONAL_SET_FLAG(XOR2(bc &gt;&gt; 30), F_OF);</a>
<a name="ln1965">    CONDITIONAL_SET_FLAG(bc &amp; 0x8, F_AF);</a>
<a name="ln1966">    return res;</a>
<a name="ln1967">}</a>
<a name="ln1968"> </a>
<a name="ln1969">/****************************************************************************</a>
<a name="ln1970">REMARKS:</a>
<a name="ln1971">Implements the SUB instruction and side effects.</a>
<a name="ln1972">****************************************************************************/</a>
<a name="ln1973">u8</a>
<a name="ln1974">sub_byte(u8 d, u8 s)</a>
<a name="ln1975">{</a>
<a name="ln1976">    register u32 res;           /* all operands in native machine order */</a>
<a name="ln1977">    register u32 bc;</a>
<a name="ln1978"> </a>
<a name="ln1979">    res = d - s;</a>
<a name="ln1980">    CONDITIONAL_SET_FLAG(res &amp; 0x80, F_SF);</a>
<a name="ln1981">    CONDITIONAL_SET_FLAG((res &amp; 0xff) == 0, F_ZF);</a>
<a name="ln1982">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln1983"> </a>
<a name="ln1984">    /* calculate the borrow chain.  See note at top */</a>
<a name="ln1985">    bc = (res &amp; (~d | s)) | (~d &amp; s);</a>
<a name="ln1986">    CONDITIONAL_SET_FLAG(bc &amp; 0x80, F_CF);</a>
<a name="ln1987">    CONDITIONAL_SET_FLAG(XOR2(bc &gt;&gt; 6), F_OF);</a>
<a name="ln1988">    CONDITIONAL_SET_FLAG(bc &amp; 0x8, F_AF);</a>
<a name="ln1989">    return (u8) res;</a>
<a name="ln1990">}</a>
<a name="ln1991"> </a>
<a name="ln1992">/****************************************************************************</a>
<a name="ln1993">REMARKS:</a>
<a name="ln1994">Implements the SUB instruction and side effects.</a>
<a name="ln1995">****************************************************************************/</a>
<a name="ln1996">u16</a>
<a name="ln1997">sub_word(u16 d, u16 s)</a>
<a name="ln1998">{</a>
<a name="ln1999">    register u32 res;           /* all operands in native machine order */</a>
<a name="ln2000">    register u32 bc;</a>
<a name="ln2001"> </a>
<a name="ln2002">    res = d - s;</a>
<a name="ln2003">    CONDITIONAL_SET_FLAG(res &amp; 0x8000, F_SF);</a>
<a name="ln2004">    CONDITIONAL_SET_FLAG((res &amp; 0xffff) == 0, F_ZF);</a>
<a name="ln2005">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln2006"> </a>
<a name="ln2007">    /* calculate the borrow chain.  See note at top */</a>
<a name="ln2008">    bc = (res &amp; (~d | s)) | (~d &amp; s);</a>
<a name="ln2009">    CONDITIONAL_SET_FLAG(bc &amp; 0x8000, F_CF);</a>
<a name="ln2010">    CONDITIONAL_SET_FLAG(XOR2(bc &gt;&gt; 14), F_OF);</a>
<a name="ln2011">    CONDITIONAL_SET_FLAG(bc &amp; 0x8, F_AF);</a>
<a name="ln2012">    return (u16) res;</a>
<a name="ln2013">}</a>
<a name="ln2014"> </a>
<a name="ln2015">/****************************************************************************</a>
<a name="ln2016">REMARKS:</a>
<a name="ln2017">Implements the SUB instruction and side effects.</a>
<a name="ln2018">****************************************************************************/</a>
<a name="ln2019">u32</a>
<a name="ln2020">sub_long(u32 d, u32 s)</a>
<a name="ln2021">{</a>
<a name="ln2022">    register u32 res;           /* all operands in native machine order */</a>
<a name="ln2023">    register u32 bc;</a>
<a name="ln2024"> </a>
<a name="ln2025">    res = d - s;</a>
<a name="ln2026">    CONDITIONAL_SET_FLAG(res &amp; 0x80000000, F_SF);</a>
<a name="ln2027">    CONDITIONAL_SET_FLAG((res &amp; 0xffffffff) == 0, F_ZF);</a>
<a name="ln2028">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln2029"> </a>
<a name="ln2030">    /* calculate the borrow chain.  See note at top */</a>
<a name="ln2031">    bc = (res &amp; (~d | s)) | (~d &amp; s);</a>
<a name="ln2032">    CONDITIONAL_SET_FLAG(bc &amp; 0x80000000, F_CF);</a>
<a name="ln2033">    CONDITIONAL_SET_FLAG(XOR2(bc &gt;&gt; 30), F_OF);</a>
<a name="ln2034">    CONDITIONAL_SET_FLAG(bc &amp; 0x8, F_AF);</a>
<a name="ln2035">    return res;</a>
<a name="ln2036">}</a>
<a name="ln2037"> </a>
<a name="ln2038">/****************************************************************************</a>
<a name="ln2039">REMARKS:</a>
<a name="ln2040">Implements the TEST instruction and side effects.</a>
<a name="ln2041">****************************************************************************/</a>
<a name="ln2042">void</a>
<a name="ln2043">test_byte(u8 d, u8 s)</a>
<a name="ln2044">{</a>
<a name="ln2045">    register u32 res;           /* all operands in native machine order */</a>
<a name="ln2046"> </a>
<a name="ln2047">    res = d &amp; s;</a>
<a name="ln2048"> </a>
<a name="ln2049">    CLEAR_FLAG(F_OF);</a>
<a name="ln2050">    CONDITIONAL_SET_FLAG(res &amp; 0x80, F_SF);</a>
<a name="ln2051">    CONDITIONAL_SET_FLAG(res == 0, F_ZF);</a>
<a name="ln2052">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln2053">    /* AF == dont care */</a>
<a name="ln2054">    CLEAR_FLAG(F_CF);</a>
<a name="ln2055">}</a>
<a name="ln2056"> </a>
<a name="ln2057">/****************************************************************************</a>
<a name="ln2058">REMARKS:</a>
<a name="ln2059">Implements the TEST instruction and side effects.</a>
<a name="ln2060">****************************************************************************/</a>
<a name="ln2061">void</a>
<a name="ln2062">test_word(u16 d, u16 s)</a>
<a name="ln2063">{</a>
<a name="ln2064">    register u32 res;           /* all operands in native machine order */</a>
<a name="ln2065"> </a>
<a name="ln2066">    res = d &amp; s;</a>
<a name="ln2067"> </a>
<a name="ln2068">    CLEAR_FLAG(F_OF);</a>
<a name="ln2069">    CONDITIONAL_SET_FLAG(res &amp; 0x8000, F_SF);</a>
<a name="ln2070">    CONDITIONAL_SET_FLAG(res == 0, F_ZF);</a>
<a name="ln2071">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln2072">    /* AF == dont care */</a>
<a name="ln2073">    CLEAR_FLAG(F_CF);</a>
<a name="ln2074">}</a>
<a name="ln2075"> </a>
<a name="ln2076">/****************************************************************************</a>
<a name="ln2077">REMARKS:</a>
<a name="ln2078">Implements the TEST instruction and side effects.</a>
<a name="ln2079">****************************************************************************/</a>
<a name="ln2080">void</a>
<a name="ln2081">test_long(u32 d, u32 s)</a>
<a name="ln2082">{</a>
<a name="ln2083">    register u32 res;           /* all operands in native machine order */</a>
<a name="ln2084"> </a>
<a name="ln2085">    res = d &amp; s;</a>
<a name="ln2086"> </a>
<a name="ln2087">    CLEAR_FLAG(F_OF);</a>
<a name="ln2088">    CONDITIONAL_SET_FLAG(res &amp; 0x80000000, F_SF);</a>
<a name="ln2089">    CONDITIONAL_SET_FLAG(res == 0, F_ZF);</a>
<a name="ln2090">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln2091">    /* AF == dont care */</a>
<a name="ln2092">    CLEAR_FLAG(F_CF);</a>
<a name="ln2093">}</a>
<a name="ln2094"> </a>
<a name="ln2095">/****************************************************************************</a>
<a name="ln2096">REMARKS:</a>
<a name="ln2097">Implements the XOR instruction and side effects.</a>
<a name="ln2098">****************************************************************************/</a>
<a name="ln2099">u8</a>
<a name="ln2100">xor_byte(u8 d, u8 s)</a>
<a name="ln2101">{</a>
<a name="ln2102">    register u8 res;            /* all operands in native machine order */</a>
<a name="ln2103"> </a>
<a name="ln2104">    res = d ^ s;</a>
<a name="ln2105">    CLEAR_FLAG(F_OF);</a>
<a name="ln2106">    CONDITIONAL_SET_FLAG(res &amp; 0x80, F_SF);</a>
<a name="ln2107">    CONDITIONAL_SET_FLAG(res == 0, F_ZF);</a>
<a name="ln2108">    CONDITIONAL_SET_FLAG(PARITY(res), F_PF);</a>
<a name="ln2109">    CLEAR_FLAG(F_CF);</a>
<a name="ln2110">    CLEAR_FLAG(F_AF);</a>
<a name="ln2111">    return res;</a>
<a name="ln2112">}</a>
<a name="ln2113"> </a>
<a name="ln2114">/****************************************************************************</a>
<a name="ln2115">REMARKS:</a>
<a name="ln2116">Implements the XOR instruction and side effects.</a>
<a name="ln2117">****************************************************************************/</a>
<a name="ln2118">u16</a>
<a name="ln2119">xor_word(u16 d, u16 s)</a>
<a name="ln2120">{</a>
<a name="ln2121">    register u16 res;           /* all operands in native machine order */</a>
<a name="ln2122"> </a>
<a name="ln2123">    res = d ^ s;</a>
<a name="ln2124">    CLEAR_FLAG(F_OF);</a>
<a name="ln2125">    CONDITIONAL_SET_FLAG(res &amp; 0x8000, F_SF);</a>
<a name="ln2126">    CONDITIONAL_SET_FLAG(res == 0, F_ZF);</a>
<a name="ln2127">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln2128">    CLEAR_FLAG(F_CF);</a>
<a name="ln2129">    CLEAR_FLAG(F_AF);</a>
<a name="ln2130">    return res;</a>
<a name="ln2131">}</a>
<a name="ln2132"> </a>
<a name="ln2133">/****************************************************************************</a>
<a name="ln2134">REMARKS:</a>
<a name="ln2135">Implements the XOR instruction and side effects.</a>
<a name="ln2136">****************************************************************************/</a>
<a name="ln2137">u32</a>
<a name="ln2138">xor_long(u32 d, u32 s)</a>
<a name="ln2139">{</a>
<a name="ln2140">    register u32 res;           /* all operands in native machine order */</a>
<a name="ln2141"> </a>
<a name="ln2142">    res = d ^ s;</a>
<a name="ln2143">    CLEAR_FLAG(F_OF);</a>
<a name="ln2144">    CONDITIONAL_SET_FLAG(res &amp; 0x80000000, F_SF);</a>
<a name="ln2145">    CONDITIONAL_SET_FLAG(res == 0, F_ZF);</a>
<a name="ln2146">    CONDITIONAL_SET_FLAG(PARITY(res &amp; 0xff), F_PF);</a>
<a name="ln2147">    CLEAR_FLAG(F_CF);</a>
<a name="ln2148">    CLEAR_FLAG(F_AF);</a>
<a name="ln2149">    return res;</a>
<a name="ln2150">}</a>
<a name="ln2151"> </a>
<a name="ln2152">/****************************************************************************</a>
<a name="ln2153">REMARKS:</a>
<a name="ln2154">Implements the IMUL instruction and side effects.</a>
<a name="ln2155">****************************************************************************/</a>
<a name="ln2156">void</a>
<a name="ln2157">imul_byte(u8 s)</a>
<a name="ln2158">{</a>
<a name="ln2159">    s16 res = (s16) ((s8) M.x86.R_AL * (s8) s);</a>
<a name="ln2160"> </a>
<a name="ln2161">    M.x86.R_AX = res;</a>
<a name="ln2162">    if (((M.x86.R_AL &amp; 0x80) == 0 &amp;&amp; M.x86.R_AH == 0x00) ||</a>
<a name="ln2163">        ((M.x86.R_AL &amp; 0x80) != 0 &amp;&amp; M.x86.R_AH == 0xFF)) {</a>
<a name="ln2164">        CLEAR_FLAG(F_CF);</a>
<a name="ln2165">        CLEAR_FLAG(F_OF);</a>
<a name="ln2166">    }</a>
<a name="ln2167">    else {</a>
<a name="ln2168">        SET_FLAG(F_CF);</a>
<a name="ln2169">        SET_FLAG(F_OF);</a>
<a name="ln2170">    }</a>
<a name="ln2171">}</a>
<a name="ln2172"> </a>
<a name="ln2173">/****************************************************************************</a>
<a name="ln2174">REMARKS:</a>
<a name="ln2175">Implements the IMUL instruction and side effects.</a>
<a name="ln2176">****************************************************************************/</a>
<a name="ln2177">void</a>
<a name="ln2178">imul_word(u16 s)</a>
<a name="ln2179">{</a>
<a name="ln2180">    s32 res = (s16) M.x86.R_AX * (s16) s;</a>
<a name="ln2181"> </a>
<a name="ln2182">    M.x86.R_AX = (u16) res;</a>
<a name="ln2183">    M.x86.R_DX = (u16) (res &gt;&gt; 16);</a>
<a name="ln2184">    if (((M.x86.R_AX &amp; 0x8000) == 0 &amp;&amp; M.x86.R_DX == 0x00) ||</a>
<a name="ln2185">        ((M.x86.R_AX &amp; 0x8000) != 0 &amp;&amp; M.x86.R_DX == 0xFF)) {</a>
<a name="ln2186">        CLEAR_FLAG(F_CF);</a>
<a name="ln2187">        CLEAR_FLAG(F_OF);</a>
<a name="ln2188">    }</a>
<a name="ln2189">    else {</a>
<a name="ln2190">        SET_FLAG(F_CF);</a>
<a name="ln2191">        SET_FLAG(F_OF);</a>
<a name="ln2192">    }</a>
<a name="ln2193">}</a>
<a name="ln2194"> </a>
<a name="ln2195">/****************************************************************************</a>
<a name="ln2196">REMARKS:</a>
<a name="ln2197">Implements the IMUL instruction and side effects.</a>
<a name="ln2198">****************************************************************************/</a>
<a name="ln2199">void</a>
<a name="ln2200">imul_long_direct(u32 * res_lo, u32 * res_hi, u32 d, u32 s)</a>
<a name="ln2201">{</a>
<a name="ln2202">#ifdef	__HAS_LONG_LONG__</a>
<a name="ln2203">    s64 res = (s64) (s32) d * (s32) s;</a>
<a name="ln2204"> </a>
<a name="ln2205">    *res_lo = (u32) res;</a>
<a name="ln2206">    *res_hi = (u32) (res &gt;&gt; 32);</a>
<a name="ln2207">#else</a>
<a name="ln2208">    u32 d_lo, d_hi, d_sign;</a>
<a name="ln2209">    u32 s_lo, s_hi, s_sign;</a>
<a name="ln2210">    u32 rlo_lo, rlo_hi, rhi_lo;</a>
<a name="ln2211"> </a>
<a name="ln2212">    if ((d_sign = d &amp; 0x80000000) != 0)</a>
<a name="ln2213">        d = -d;</a>
<a name="ln2214">    d_lo = d &amp; 0xFFFF;</a>
<a name="ln2215">    d_hi = d &gt;&gt; 16;</a>
<a name="ln2216">    if ((s_sign = s &amp; 0x80000000) != 0)</a>
<a name="ln2217">        s = -s;</a>
<a name="ln2218">    s_lo = s &amp; 0xFFFF;</a>
<a name="ln2219">    s_hi = s &gt;&gt; 16;</a>
<a name="ln2220">    rlo_lo = d_lo * s_lo;</a>
<a name="ln2221">    rlo_hi = (d_hi * s_lo + d_lo * s_hi) + (rlo_lo &gt;&gt; 16);</a>
<a name="ln2222">    rhi_lo = d_hi * s_hi + (rlo_hi &gt;&gt; 16);</a>
<a name="ln2223">    *res_lo = (rlo_hi &lt;&lt; 16) | (rlo_lo &amp; 0xFFFF);</a>
<a name="ln2224">    *res_hi = rhi_lo;</a>
<a name="ln2225">    if (d_sign != s_sign) {</a>
<a name="ln2226">        d = ~*res_lo;</a>
<a name="ln2227">        s = (((d &amp; 0xFFFF) + 1) &gt;&gt; 16) + (d &gt;&gt; 16);</a>
<a name="ln2228">        *res_lo = ~*res_lo + 1;</a>
<a name="ln2229">        *res_hi = ~*res_hi + (s &gt;&gt; 16);</a>
<a name="ln2230">    }</a>
<a name="ln2231">#endif</a>
<a name="ln2232">}</a>
<a name="ln2233"> </a>
<a name="ln2234">/****************************************************************************</a>
<a name="ln2235">REMARKS:</a>
<a name="ln2236">Implements the IMUL instruction and side effects.</a>
<a name="ln2237">****************************************************************************/</a>
<a name="ln2238">void</a>
<a name="ln2239">imul_long(u32 s)</a>
<a name="ln2240">{</a>
<a name="ln2241">    imul_long_direct(&amp;M.x86.R_EAX, &amp;M.x86.R_EDX, M.x86.R_EAX, s);</a>
<a name="ln2242">    if (((M.x86.R_EAX &amp; 0x80000000) == 0 &amp;&amp; M.x86.R_EDX == 0x00) ||</a>
<a name="ln2243">        ((M.x86.R_EAX &amp; 0x80000000) != 0 &amp;&amp; M.x86.R_EDX == 0xFF)) {</a>
<a name="ln2244">        CLEAR_FLAG(F_CF);</a>
<a name="ln2245">        CLEAR_FLAG(F_OF);</a>
<a name="ln2246">    }</a>
<a name="ln2247">    else {</a>
<a name="ln2248">        SET_FLAG(F_CF);</a>
<a name="ln2249">        SET_FLAG(F_OF);</a>
<a name="ln2250">    }</a>
<a name="ln2251">}</a>
<a name="ln2252"> </a>
<a name="ln2253">/****************************************************************************</a>
<a name="ln2254">REMARKS:</a>
<a name="ln2255">Implements the MUL instruction and side effects.</a>
<a name="ln2256">****************************************************************************/</a>
<a name="ln2257">void</a>
<a name="ln2258">mul_byte(u8 s)</a>
<a name="ln2259">{</a>
<a name="ln2260">    u16 res = (u16) (M.x86.R_AL * s);</a>
<a name="ln2261"> </a>
<a name="ln2262">    M.x86.R_AX = res;</a>
<a name="ln2263">    if (M.x86.R_AH == 0) {</a>
<a name="ln2264">        CLEAR_FLAG(F_CF);</a>
<a name="ln2265">        CLEAR_FLAG(F_OF);</a>
<a name="ln2266">    }</a>
<a name="ln2267">    else {</a>
<a name="ln2268">        SET_FLAG(F_CF);</a>
<a name="ln2269">        SET_FLAG(F_OF);</a>
<a name="ln2270">    }</a>
<a name="ln2271">}</a>
<a name="ln2272"> </a>
<a name="ln2273">/****************************************************************************</a>
<a name="ln2274">REMARKS:</a>
<a name="ln2275">Implements the MUL instruction and side effects.</a>
<a name="ln2276">****************************************************************************/</a>
<a name="ln2277">void</a>
<a name="ln2278">mul_word(u16 s)</a>
<a name="ln2279">{</a>
<a name="ln2280">    u32 res = M.x86.R_AX * s;</a>
<a name="ln2281"> </a>
<a name="ln2282">    M.x86.R_AX = (u16) res;</a>
<a name="ln2283">    M.x86.R_DX = (u16) (res &gt;&gt; 16);</a>
<a name="ln2284">    if (M.x86.R_DX == 0) {</a>
<a name="ln2285">        CLEAR_FLAG(F_CF);</a>
<a name="ln2286">        CLEAR_FLAG(F_OF);</a>
<a name="ln2287">    }</a>
<a name="ln2288">    else {</a>
<a name="ln2289">        SET_FLAG(F_CF);</a>
<a name="ln2290">        SET_FLAG(F_OF);</a>
<a name="ln2291">    }</a>
<a name="ln2292">}</a>
<a name="ln2293"> </a>
<a name="ln2294">/****************************************************************************</a>
<a name="ln2295">REMARKS:</a>
<a name="ln2296">Implements the MUL instruction and side effects.</a>
<a name="ln2297">****************************************************************************/</a>
<a name="ln2298">void</a>
<a name="ln2299">mul_long(u32 s)</a>
<a name="ln2300">{</a>
<a name="ln2301">#ifdef	__HAS_LONG_LONG__</a>
<a name="ln2302">    u64 res = (u64) M.x86.R_EAX * s;</a>
<a name="ln2303"> </a>
<a name="ln2304">    M.x86.R_EAX = (u32) res;</a>
<a name="ln2305">    M.x86.R_EDX = (u32) (res &gt;&gt; 32);</a>
<a name="ln2306">#else</a>
<a name="ln2307">    u32 a, a_lo, a_hi;</a>
<a name="ln2308">    u32 s_lo, s_hi;</a>
<a name="ln2309">    u32 rlo_lo, rlo_hi, rhi_lo;</a>
<a name="ln2310"> </a>
<a name="ln2311">    a = M.x86.R_EAX;</a>
<a name="ln2312">    a_lo = a &amp; 0xFFFF;</a>
<a name="ln2313">    a_hi = a &gt;&gt; 16;</a>
<a name="ln2314">    s_lo = s &amp; 0xFFFF;</a>
<a name="ln2315">    s_hi = s &gt;&gt; 16;</a>
<a name="ln2316">    rlo_lo = a_lo * s_lo;</a>
<a name="ln2317">    rlo_hi = (a_hi * s_lo + a_lo * s_hi) + (rlo_lo &gt;&gt; 16);</a>
<a name="ln2318">    rhi_lo = a_hi * s_hi + (rlo_hi &gt;&gt; 16);</a>
<a name="ln2319">    M.x86.R_EAX = (rlo_hi &lt;&lt; 16) | (rlo_lo &amp; 0xFFFF);</a>
<a name="ln2320">    M.x86.R_EDX = rhi_lo;</a>
<a name="ln2321">#endif</a>
<a name="ln2322"> </a>
<a name="ln2323">    if (M.x86.R_EDX == 0) {</a>
<a name="ln2324">        CLEAR_FLAG(F_CF);</a>
<a name="ln2325">        CLEAR_FLAG(F_OF);</a>
<a name="ln2326">    }</a>
<a name="ln2327">    else {</a>
<a name="ln2328">        SET_FLAG(F_CF);</a>
<a name="ln2329">        SET_FLAG(F_OF);</a>
<a name="ln2330">    }</a>
<a name="ln2331">}</a>
<a name="ln2332"> </a>
<a name="ln2333">/****************************************************************************</a>
<a name="ln2334">REMARKS:</a>
<a name="ln2335">Implements the IDIV instruction and side effects.</a>
<a name="ln2336">****************************************************************************/</a>
<a name="ln2337">void</a>
<a name="ln2338">idiv_byte(u8 s)</a>
<a name="ln2339">{</a>
<a name="ln2340">    s32 dvd, div, mod;</a>
<a name="ln2341"> </a>
<a name="ln2342">    dvd = (s16) M.x86.R_AX;</a>
<a name="ln2343">    if (s == 0) {</a>
<a name="ln2344">        x86emu_intr_raise(0);</a>
<a name="ln2345">        return;</a>
<a name="ln2346">    }</a>
<a name="ln2347">    div = dvd / (s8) s;</a>
<a name="ln2348">    mod = dvd % (s8) s;</a>
<a name="ln2349">    if (abs(div) &gt; 0x7f) {</a>
<a name="ln2350">        x86emu_intr_raise(0);</a>
<a name="ln2351">        return;</a>
<a name="ln2352">    }</a>
<a name="ln2353">    M.x86.R_AL = (s8) div;</a>
<a name="ln2354">    M.x86.R_AH = (s8) mod;</a>
<a name="ln2355">}</a>
<a name="ln2356"> </a>
<a name="ln2357">/****************************************************************************</a>
<a name="ln2358">REMARKS:</a>
<a name="ln2359">Implements the IDIV instruction and side effects.</a>
<a name="ln2360">****************************************************************************/</a>
<a name="ln2361">void</a>
<a name="ln2362">idiv_word(u16 s)</a>
<a name="ln2363">{</a>
<a name="ln2364">    s32 dvd, div, mod;</a>
<a name="ln2365"> </a>
<a name="ln2366">    dvd = (((s32) M.x86.R_DX) &lt;&lt; 16) | M.x86.R_AX;</a>
<a name="ln2367">    if (s == 0) {</a>
<a name="ln2368">        x86emu_intr_raise(0);</a>
<a name="ln2369">        return;</a>
<a name="ln2370">    }</a>
<a name="ln2371">    div = dvd / (s16) s;</a>
<a name="ln2372">    mod = dvd % (s16) s;</a>
<a name="ln2373">    if (abs(div) &gt; 0x7fff) {</a>
<a name="ln2374">        x86emu_intr_raise(0);</a>
<a name="ln2375">        return;</a>
<a name="ln2376">    }</a>
<a name="ln2377">    CLEAR_FLAG(F_CF);</a>
<a name="ln2378">    CLEAR_FLAG(F_SF);</a>
<a name="ln2379">    CONDITIONAL_SET_FLAG(div == 0, F_ZF);</a>
<a name="ln2380">    CONDITIONAL_SET_FLAG(PARITY(mod &amp; 0xff), F_PF);</a>
<a name="ln2381"> </a>
<a name="ln2382">    M.x86.R_AX = (u16) div;</a>
<a name="ln2383">    M.x86.R_DX = (u16) mod;</a>
<a name="ln2384">}</a>
<a name="ln2385"> </a>
<a name="ln2386">/****************************************************************************</a>
<a name="ln2387">REMARKS:</a>
<a name="ln2388">Implements the IDIV instruction and side effects.</a>
<a name="ln2389">****************************************************************************/</a>
<a name="ln2390">void</a>
<a name="ln2391">idiv_long(u32 s)</a>
<a name="ln2392">{</a>
<a name="ln2393">#ifdef	__HAS_LONG_LONG__</a>
<a name="ln2394">    s64 dvd, div, mod;</a>
<a name="ln2395"> </a>
<a name="ln2396">    dvd = (((s64) M.x86.R_EDX) &lt;&lt; 32) | M.x86.R_EAX;</a>
<a name="ln2397">    if (s == 0) {</a>
<a name="ln2398">        x86emu_intr_raise(0);</a>
<a name="ln2399">        return;</a>
<a name="ln2400">    }</a>
<a name="ln2401">    div = dvd / (s32) s;</a>
<a name="ln2402">    mod = dvd % (s32) s;</a>
<a name="ln2403">    if (abs(div) &gt; 0x7fffffff) {</a>
<a name="ln2404">        x86emu_intr_raise(0);</a>
<a name="ln2405">        return;</a>
<a name="ln2406">    }</a>
<a name="ln2407">#else</a>
<a name="ln2408">    s32 div = 0, mod;</a>
<a name="ln2409">    s32 h_dvd = M.x86.R_EDX;</a>
<a name="ln2410">    u32 l_dvd = M.x86.R_EAX;</a>
<a name="ln2411">    u32 abs_s = s &amp; 0x7FFFFFFF;</a>
<a name="ln2412">    u32 abs_h_dvd = h_dvd &amp; 0x7FFFFFFF;</a>
<a name="ln2413">    u32 h_s = abs_s &gt;&gt; 1;</a>
<a name="ln2414">    u32 l_s = abs_s &lt;&lt; 31;</a>
<a name="ln2415">    int counter = 31;</a>
<a name="ln2416">    int carry;</a>
<a name="ln2417"> </a>
<a name="ln2418">    if (s == 0) {</a>
<a name="ln2419">        x86emu_intr_raise(0);</a>
<a name="ln2420">        return;</a>
<a name="ln2421">    }</a>
<a name="ln2422">    do {</a>
<a name="ln2423">        div &lt;&lt;= 1;</a>
<a name="ln2424">        carry = (l_dvd &gt;= l_s) ? 0 : 1;</a>
<a name="ln2425"> </a>
<a name="ln2426">        if (abs_h_dvd &lt; (h_s + carry)) {</a>
<a name="ln2427">            h_s &gt;&gt;= 1;</a>
<a name="ln2428">            l_s = abs_s &lt;&lt; (--counter);</a>
<a name="ln2429">            continue;</a>
<a name="ln2430">        }</a>
<a name="ln2431">        else {</a>
<a name="ln2432">            abs_h_dvd -= (h_s + carry);</a>
<a name="ln2433">            l_dvd = carry ? ((0xFFFFFFFF - l_s) + l_dvd + 1)</a>
<a name="ln2434">                : (l_dvd - l_s);</a>
<a name="ln2435">            h_s &gt;&gt;= 1;</a>
<a name="ln2436">            l_s = abs_s &lt;&lt; (--counter);</a>
<a name="ln2437">            div |= 1;</a>
<a name="ln2438">            continue;</a>
<a name="ln2439">        }</a>
<a name="ln2440"> </a>
<a name="ln2441">    } while (counter &gt; -1);</a>
<a name="ln2442">    /* overflow */</a>
<a name="ln2443">    if (abs_h_dvd || (l_dvd &gt; abs_s)) {</a>
<a name="ln2444">        x86emu_intr_raise(0);</a>
<a name="ln2445">        return;</a>
<a name="ln2446">    }</a>
<a name="ln2447">    /* sign */</a>
<a name="ln2448">    div |= ((h_dvd &amp; 0x10000000) ^ (s &amp; 0x10000000));</a>
<a name="ln2449">    mod = l_dvd;</a>
<a name="ln2450"> </a>
<a name="ln2451">#endif</a>
<a name="ln2452">    CLEAR_FLAG(F_CF);</a>
<a name="ln2453">    CLEAR_FLAG(F_AF);</a>
<a name="ln2454">    CLEAR_FLAG(F_SF);</a>
<a name="ln2455">    SET_FLAG(F_ZF);</a>
<a name="ln2456">    CONDITIONAL_SET_FLAG(PARITY(mod &amp; 0xff), F_PF);</a>
<a name="ln2457"> </a>
<a name="ln2458">    M.x86.R_EAX = (u32) div;</a>
<a name="ln2459">    M.x86.R_EDX = (u32) mod;</a>
<a name="ln2460">}</a>
<a name="ln2461"> </a>
<a name="ln2462">/****************************************************************************</a>
<a name="ln2463">REMARKS:</a>
<a name="ln2464">Implements the DIV instruction and side effects.</a>
<a name="ln2465">****************************************************************************/</a>
<a name="ln2466">void</a>
<a name="ln2467">div_byte(u8 s)</a>
<a name="ln2468">{</a>
<a name="ln2469">    u32 dvd, div, mod;</a>
<a name="ln2470"> </a>
<a name="ln2471">    dvd = M.x86.R_AX;</a>
<a name="ln2472">    if (s == 0) {</a>
<a name="ln2473">        x86emu_intr_raise(0);</a>
<a name="ln2474">        return;</a>
<a name="ln2475">    }</a>
<a name="ln2476">    div = dvd / (u8) s;</a>
<a name="ln2477">    mod = dvd % (u8) s;</a>
<a name="ln2478">    if (abs(div) &gt; 0xff) {</a>
<a name="ln2479">        x86emu_intr_raise(0);</a>
<a name="ln2480">        return;</a>
<a name="ln2481">    }</a>
<a name="ln2482">    M.x86.R_AL = (u8) div;</a>
<a name="ln2483">    M.x86.R_AH = (u8) mod;</a>
<a name="ln2484">}</a>
<a name="ln2485"> </a>
<a name="ln2486">/****************************************************************************</a>
<a name="ln2487">REMARKS:</a>
<a name="ln2488">Implements the DIV instruction and side effects.</a>
<a name="ln2489">****************************************************************************/</a>
<a name="ln2490">void</a>
<a name="ln2491">div_word(u16 s)</a>
<a name="ln2492">{</a>
<a name="ln2493">    u32 dvd, div, mod;</a>
<a name="ln2494"> </a>
<a name="ln2495">    dvd = (((u32) M.x86.R_DX) &lt;&lt; 16) | M.x86.R_AX;</a>
<a name="ln2496">    if (s == 0) {</a>
<a name="ln2497">        x86emu_intr_raise(0);</a>
<a name="ln2498">        return;</a>
<a name="ln2499">    }</a>
<a name="ln2500">    div = dvd / (u16) s;</a>
<a name="ln2501">    mod = dvd % (u16) s;</a>
<a name="ln2502">    if (abs(div) &gt; 0xffff) {</a>
<a name="ln2503">        x86emu_intr_raise(0);</a>
<a name="ln2504">        return;</a>
<a name="ln2505">    }</a>
<a name="ln2506">    CLEAR_FLAG(F_CF);</a>
<a name="ln2507">    CLEAR_FLAG(F_SF);</a>
<a name="ln2508">    CONDITIONAL_SET_FLAG(div == 0, F_ZF);</a>
<a name="ln2509">    CONDITIONAL_SET_FLAG(PARITY(mod &amp; 0xff), F_PF);</a>
<a name="ln2510"> </a>
<a name="ln2511">    M.x86.R_AX = (u16) div;</a>
<a name="ln2512">    M.x86.R_DX = (u16) mod;</a>
<a name="ln2513">}</a>
<a name="ln2514"> </a>
<a name="ln2515">/****************************************************************************</a>
<a name="ln2516">REMARKS:</a>
<a name="ln2517">Implements the DIV instruction and side effects.</a>
<a name="ln2518">****************************************************************************/</a>
<a name="ln2519">void</a>
<a name="ln2520">div_long(u32 s)</a>
<a name="ln2521">{</a>
<a name="ln2522">#ifdef	__HAS_LONG_LONG__</a>
<a name="ln2523">    u64 dvd, div, mod;</a>
<a name="ln2524"> </a>
<a name="ln2525">    dvd = (((u64) M.x86.R_EDX) &lt;&lt; 32) | M.x86.R_EAX;</a>
<a name="ln2526">    if (s == 0) {</a>
<a name="ln2527">        x86emu_intr_raise(0);</a>
<a name="ln2528">        return;</a>
<a name="ln2529">    }</a>
<a name="ln2530">    div = dvd / (u32) s;</a>
<a name="ln2531">    mod = dvd % (u32) s;</a>
<a name="ln2532">    if (abs(div) &gt; 0xffffffff) {</a>
<a name="ln2533">        x86emu_intr_raise(0);</a>
<a name="ln2534">        return;</a>
<a name="ln2535">    }</a>
<a name="ln2536">#else</a>
<a name="ln2537">    s32 div = 0, mod;</a>
<a name="ln2538">    s32 h_dvd = M.x86.R_EDX;</a>
<a name="ln2539">    u32 l_dvd = M.x86.R_EAX;</a>
<a name="ln2540"> </a>
<a name="ln2541">    u32 h_s = s;</a>
<a name="ln2542">    u32 l_s = 0;</a>
<a name="ln2543">    int counter = 32;</a>
<a name="ln2544">    int carry;</a>
<a name="ln2545"> </a>
<a name="ln2546">    if (s == 0) {</a>
<a name="ln2547">        x86emu_intr_raise(0);</a>
<a name="ln2548">        return;</a>
<a name="ln2549">    }</a>
<a name="ln2550">    do {</a>
<a name="ln2551">        div &lt;&lt;= 1;</a>
<a name="ln2552">        carry = (l_dvd &gt;= l_s) ? 0 : 1;</a>
<a name="ln2553"> </a>
<a name="ln2554">        if (h_dvd &lt; (s32)(h_s + carry)) {</a>
<a name="ln2555">            h_s &gt;&gt;= 1;</a>
<a name="ln2556">            l_s = s &lt;&lt; (--counter);</a>
<a name="ln2557">            continue;</a>
<a name="ln2558">        }</a>
<a name="ln2559">        else {</a>
<a name="ln2560">            h_dvd -= (h_s + carry);</a>
<a name="ln2561">            l_dvd = carry ? ((0xFFFFFFFF - l_s) + l_dvd + 1)</a>
<a name="ln2562">                : (l_dvd - l_s);</a>
<a name="ln2563">            h_s &gt;&gt;= 1;</a>
<a name="ln2564">            l_s = s &lt;&lt; (--counter);</a>
<a name="ln2565">            div |= 1;</a>
<a name="ln2566">            continue;</a>
<a name="ln2567">        }</a>
<a name="ln2568"> </a>
<a name="ln2569">    } while (counter &gt; -1);</a>
<a name="ln2570">    /* overflow */</a>
<a name="ln2571">    if (h_dvd || (l_dvd &gt; s)) {</a>
<a name="ln2572">        x86emu_intr_raise(0);</a>
<a name="ln2573">        return;</a>
<a name="ln2574">    }</a>
<a name="ln2575">    mod = l_dvd;</a>
<a name="ln2576">#endif</a>
<a name="ln2577">    CLEAR_FLAG(F_CF);</a>
<a name="ln2578">    CLEAR_FLAG(F_AF);</a>
<a name="ln2579">    CLEAR_FLAG(F_SF);</a>
<a name="ln2580">    SET_FLAG(F_ZF);</a>
<a name="ln2581">    CONDITIONAL_SET_FLAG(PARITY(mod &amp; 0xff), F_PF);</a>
<a name="ln2582"> </a>
<a name="ln2583">    M.x86.R_EAX = (u32) div;</a>
<a name="ln2584">    M.x86.R_EDX = (u32) mod;</a>
<a name="ln2585">}</a>
<a name="ln2586"> </a>
<a name="ln2587">/****************************************************************************</a>
<a name="ln2588">REMARKS:</a>
<a name="ln2589">Implements the IN string instruction and side effects.</a>
<a name="ln2590">****************************************************************************/</a>
<a name="ln2591">void</a>
<a name="ln2592">ins(int size)</a>
<a name="ln2593">{</a>
<a name="ln2594">    int inc = size;</a>
<a name="ln2595"> </a>
<a name="ln2596">    if (ACCESS_FLAG(F_DF)) {</a>
<a name="ln2597">        inc = -size;</a>
<a name="ln2598">    }</a>
<a name="ln2599">    if (M.x86.mode &amp; (SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE)) {</a>
<a name="ln2600">        /* dont care whether REPE or REPNE */</a>
<a name="ln2601">        /* in until CX is ZERO. */</a>
<a name="ln2602">        u32 count = ((M.x86.mode &amp; SYSMODE_PREFIX_DATA) ?</a>
<a name="ln2603">                     M.x86.R_ECX : M.x86.R_CX);</a>
<a name="ln2604">        switch (size) {</a>
<a name="ln2605">        case 1:</a>
<a name="ln2606">            while (count--) {</a>
<a name="ln2607">                store_data_byte_abs(M.x86.R_ES, M.x86.R_DI,</a>
<a name="ln2608">                                    (*sys_inb) (M.x86.R_DX));</a>
<a name="ln2609">                M.x86.R_DI += inc;</a>
<a name="ln2610">            }</a>
<a name="ln2611">            break;</a>
<a name="ln2612"> </a>
<a name="ln2613">        case 2:</a>
<a name="ln2614">            while (count--) {</a>
<a name="ln2615">                store_data_word_abs(M.x86.R_ES, M.x86.R_DI,</a>
<a name="ln2616">                                    (*sys_inw) (M.x86.R_DX));</a>
<a name="ln2617">                M.x86.R_DI += inc;</a>
<a name="ln2618">            }</a>
<a name="ln2619">            break;</a>
<a name="ln2620">        case 4:</a>
<a name="ln2621">            while (count--) {</a>
<a name="ln2622">                store_data_long_abs(M.x86.R_ES, M.x86.R_DI,</a>
<a name="ln2623">                                    (*sys_inl) (M.x86.R_DX));</a>
<a name="ln2624">                M.x86.R_DI += inc;</a>
<a name="ln2625">                break;</a>
<a name="ln2626">            }</a>
<a name="ln2627">        }</a>
<a name="ln2628">        M.x86.R_CX = 0;</a>
<a name="ln2629">        if (M.x86.mode &amp; SYSMODE_PREFIX_DATA) {</a>
<a name="ln2630">            M.x86.R_ECX = 0;</a>
<a name="ln2631">        }</a>
<a name="ln2632">        M.x86.mode &amp;= ~(SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE);</a>
<a name="ln2633">    }</a>
<a name="ln2634">    else {</a>
<a name="ln2635">        switch (size) {</a>
<a name="ln2636">        case 1:</a>
<a name="ln2637">            store_data_byte_abs(M.x86.R_ES, M.x86.R_DI,</a>
<a name="ln2638">                                (*sys_inb) (M.x86.R_DX));</a>
<a name="ln2639">            break;</a>
<a name="ln2640">        case 2:</a>
<a name="ln2641">            store_data_word_abs(M.x86.R_ES, M.x86.R_DI,</a>
<a name="ln2642">                                (*sys_inw) (M.x86.R_DX));</a>
<a name="ln2643">            break;</a>
<a name="ln2644">        case 4:</a>
<a name="ln2645">            store_data_long_abs(M.x86.R_ES, M.x86.R_DI,</a>
<a name="ln2646">                                (*sys_inl) (M.x86.R_DX));</a>
<a name="ln2647">            break;</a>
<a name="ln2648">        }</a>
<a name="ln2649">        M.x86.R_DI += inc;</a>
<a name="ln2650">    }</a>
<a name="ln2651">}</a>
<a name="ln2652"> </a>
<a name="ln2653">/****************************************************************************</a>
<a name="ln2654">REMARKS:</a>
<a name="ln2655">Implements the OUT string instruction and side effects.</a>
<a name="ln2656">****************************************************************************/</a>
<a name="ln2657">void</a>
<a name="ln2658">outs(int size)</a>
<a name="ln2659">{</a>
<a name="ln2660">    int inc = size;</a>
<a name="ln2661"> </a>
<a name="ln2662">    if (ACCESS_FLAG(F_DF)) {</a>
<a name="ln2663">        inc = -size;</a>
<a name="ln2664">    }</a>
<a name="ln2665">    if (M.x86.mode &amp; (SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE)) {</a>
<a name="ln2666">        /* dont care whether REPE or REPNE */</a>
<a name="ln2667">        /* out until CX is ZERO. */</a>
<a name="ln2668">        u32 count = ((M.x86.mode &amp; SYSMODE_PREFIX_DATA) ?</a>
<a name="ln2669">                     M.x86.R_ECX : M.x86.R_CX);</a>
<a name="ln2670">        switch (size) {</a>
<a name="ln2671">        case 1:</a>
<a name="ln2672">            while (count--) {</a>
<a name="ln2673">                (*sys_outb) (M.x86.R_DX,</a>
<a name="ln2674">                             fetch_data_byte_abs(M.x86.R_ES, M.x86.R_SI));</a>
<a name="ln2675">                M.x86.R_SI += inc;</a>
<a name="ln2676">            }</a>
<a name="ln2677">            break;</a>
<a name="ln2678"> </a>
<a name="ln2679">        case 2:</a>
<a name="ln2680">            while (count--) {</a>
<a name="ln2681">                (*sys_outw) (M.x86.R_DX,</a>
<a name="ln2682">                             fetch_data_word_abs(M.x86.R_ES, M.x86.R_SI));</a>
<a name="ln2683">                M.x86.R_SI += inc;</a>
<a name="ln2684">            }</a>
<a name="ln2685">            break;</a>
<a name="ln2686">        case 4:</a>
<a name="ln2687">            while (count--) {</a>
<a name="ln2688">                (*sys_outl) (M.x86.R_DX,</a>
<a name="ln2689">                             fetch_data_long_abs(M.x86.R_ES, M.x86.R_SI));</a>
<a name="ln2690">                M.x86.R_SI += inc;</a>
<a name="ln2691">                break;</a>
<a name="ln2692">            }</a>
<a name="ln2693">        }</a>
<a name="ln2694">        M.x86.R_CX = 0;</a>
<a name="ln2695">        if (M.x86.mode &amp; SYSMODE_PREFIX_DATA) {</a>
<a name="ln2696">            M.x86.R_ECX = 0;</a>
<a name="ln2697">        }</a>
<a name="ln2698">        M.x86.mode &amp;= ~(SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE);</a>
<a name="ln2699">    }</a>
<a name="ln2700">    else {</a>
<a name="ln2701">        switch (size) {</a>
<a name="ln2702">        case 1:</a>
<a name="ln2703">            (*sys_outb) (M.x86.R_DX,</a>
<a name="ln2704">                         fetch_data_byte_abs(M.x86.R_ES, M.x86.R_SI));</a>
<a name="ln2705">            break;</a>
<a name="ln2706">        case 2:</a>
<a name="ln2707">            (*sys_outw) (M.x86.R_DX,</a>
<a name="ln2708">                         fetch_data_word_abs(M.x86.R_ES, M.x86.R_SI));</a>
<a name="ln2709">            break;</a>
<a name="ln2710">        case 4:</a>
<a name="ln2711">            (*sys_outl) (M.x86.R_DX,</a>
<a name="ln2712">                         fetch_data_long_abs(M.x86.R_ES, M.x86.R_SI));</a>
<a name="ln2713">            break;</a>
<a name="ln2714">        }</a>
<a name="ln2715">        M.x86.R_SI += inc;</a>
<a name="ln2716">    }</a>
<a name="ln2717">}</a>
<a name="ln2718"> </a>
<a name="ln2719">/****************************************************************************</a>
<a name="ln2720">PARAMETERS:</a>
<a name="ln2721">addr	- Address to fetch word from</a>
<a name="ln2722"> </a>
<a name="ln2723">REMARKS:</a>
<a name="ln2724">Fetches a word from emulator memory using an absolute address.</a>
<a name="ln2725">****************************************************************************/</a>
<a name="ln2726">u16</a>
<a name="ln2727">mem_access_word(int addr)</a>
<a name="ln2728">{</a>
<a name="ln2729">    DB(if (CHECK_MEM_ACCESS())</a>
<a name="ln2730">       x86emu_check_mem_access(addr);)</a>
<a name="ln2731">        return (*sys_rdw) (addr);</a>
<a name="ln2732">}</a>
<a name="ln2733"> </a>
<a name="ln2734">/****************************************************************************</a>
<a name="ln2735">REMARKS:</a>
<a name="ln2736">Pushes a word onto the stack.</a>
<a name="ln2737"> </a>
<a name="ln2738">NOTE: Do not inline this, as (*sys_wrX) is already inline!</a>
<a name="ln2739">****************************************************************************/</a>
<a name="ln2740">void</a>
<a name="ln2741">push_word(u16 w)</a>
<a name="ln2742">{</a>
<a name="ln2743">    DB(if (CHECK_SP_ACCESS())</a>
<a name="ln2744">       x86emu_check_sp_access();)</a>
<a name="ln2745">        M.x86.R_SP -= 2;</a>
<a name="ln2746">    (*sys_wrw) (((u32) M.x86.R_SS &lt;&lt; 4) + M.x86.R_SP, w);</a>
<a name="ln2747">}</a>
<a name="ln2748"> </a>
<a name="ln2749">/****************************************************************************</a>
<a name="ln2750">REMARKS:</a>
<a name="ln2751">Pushes a long onto the stack.</a>
<a name="ln2752"> </a>
<a name="ln2753">NOTE: Do not inline this, as (*sys_wrX) is already inline!</a>
<a name="ln2754">****************************************************************************/</a>
<a name="ln2755">void</a>
<a name="ln2756">push_long(u32 w)</a>
<a name="ln2757">{</a>
<a name="ln2758">    DB(if (CHECK_SP_ACCESS())</a>
<a name="ln2759">       x86emu_check_sp_access();)</a>
<a name="ln2760">        M.x86.R_SP -= 4;</a>
<a name="ln2761">    (*sys_wrl) (((u32) M.x86.R_SS &lt;&lt; 4) + M.x86.R_SP, w);</a>
<a name="ln2762">}</a>
<a name="ln2763"> </a>
<a name="ln2764">/****************************************************************************</a>
<a name="ln2765">REMARKS:</a>
<a name="ln2766">Pops a word from the stack.</a>
<a name="ln2767"> </a>
<a name="ln2768">NOTE: Do not inline this, as (*sys_rdX) is already inline!</a>
<a name="ln2769">****************************************************************************/</a>
<a name="ln2770">u16</a>
<a name="ln2771">pop_word(void)</a>
<a name="ln2772">{</a>
<a name="ln2773">    register u16 res;</a>
<a name="ln2774"> </a>
<a name="ln2775">    DB(if (CHECK_SP_ACCESS())</a>
<a name="ln2776">       x86emu_check_sp_access();)</a>
<a name="ln2777">        res = (*sys_rdw) (((u32) M.x86.R_SS &lt;&lt; 4) + M.x86.R_SP);</a>
<a name="ln2778">    M.x86.R_SP += 2;</a>
<a name="ln2779">    return res;</a>
<a name="ln2780">}</a>
<a name="ln2781"> </a>
<a name="ln2782">/****************************************************************************</a>
<a name="ln2783">REMARKS:</a>
<a name="ln2784">Pops a long from the stack.</a>
<a name="ln2785"> </a>
<a name="ln2786">NOTE: Do not inline this, as (*sys_rdX) is already inline!</a>
<a name="ln2787">****************************************************************************/</a>
<a name="ln2788">u32</a>
<a name="ln2789">pop_long(void)</a>
<a name="ln2790">{</a>
<a name="ln2791">    register u32 res;</a>
<a name="ln2792"> </a>
<a name="ln2793">    DB(if (CHECK_SP_ACCESS())</a>
<a name="ln2794">       x86emu_check_sp_access();)</a>
<a name="ln2795">        res = (*sys_rdl) (((u32) M.x86.R_SS &lt;&lt; 4) + M.x86.R_SP);</a>
<a name="ln2796">    M.x86.R_SP += 4;</a>
<a name="ln2797">    return res;</a>
<a name="ln2798">}</a>
<a name="ln2799"> </a>
<a name="ln2800">/****************************************************************************</a>
<a name="ln2801">REMARKS:</a>
<a name="ln2802">CPUID takes EAX/ECX as inputs, writes EAX/EBX/ECX/EDX as output</a>
<a name="ln2803">****************************************************************************/</a>
<a name="ln2804">void</a>
<a name="ln2805">cpuid(void)</a>
<a name="ln2806">{</a>
<a name="ln2807">    u32 feature = M.x86.R_EAX;</a>
<a name="ln2808"> </a>
<a name="ln2809">#ifdef X86EMU_HAS_HW_CPUID</a>
<a name="ln2810">    /* If the platform allows it, we will base our values on the real</a>
<a name="ln2811">     * results from the CPUID instruction.  We limit support to the</a>
<a name="ln2812">     * first two features, and the results of those are sanitized.</a>
<a name="ln2813">     */</a>
<a name="ln2814">    if (feature &lt;= 1)</a>
<a name="ln2815">        hw_cpuid(&amp;M.x86.R_EAX, &amp;M.x86.R_EBX, &amp;M.x86.R_ECX, &amp;M.x86.R_EDX);</a>
<a name="ln2816">#endif</a>
<a name="ln2817"> </a>
<a name="ln2818">    switch (feature) {</a>
<a name="ln2819">    case 0:</a>
<a name="ln2820">        /* Regardless if we have real data from the hardware, the emulator</a>
<a name="ln2821">         * will only support upto feature 1, which we set in register EAX.</a>
<a name="ln2822">         * Registers EBX:EDX:ECX contain a string identifying the CPU.</a>
<a name="ln2823">         */</a>
<a name="ln2824">        M.x86.R_EAX = 1;</a>
<a name="ln2825">#ifndef X86EMU_HAS_HW_CPUID</a>
<a name="ln2826">        /* EBX:EDX:ECX = &quot;GenuineIntel&quot; */</a>
<a name="ln2827">        M.x86.R_EBX = 0x756e6547;</a>
<a name="ln2828">        M.x86.R_EDX = 0x49656e69;</a>
<a name="ln2829">        M.x86.R_ECX = 0x6c65746e;</a>
<a name="ln2830">#endif</a>
<a name="ln2831">        break;</a>
<a name="ln2832">    case 1:</a>
<a name="ln2833">#ifndef X86EMU_HAS_HW_CPUID</a>
<a name="ln2834">        /* If we don't have x86 compatible hardware, we return values from an</a>
<a name="ln2835">         * Intel 486dx4; which was one of the first processors to have CPUID.</a>
<a name="ln2836">         */</a>
<a name="ln2837">        M.x86.R_EAX = 0x00000480;</a>
<a name="ln2838">        M.x86.R_EBX = 0x00000000;</a>
<a name="ln2839">        M.x86.R_ECX = 0x00000000;</a>
<a name="ln2840">        M.x86.R_EDX = 0x00000002;       /* VME */</a>
<a name="ln2841">#else</a>
<a name="ln2842">        /* In the case that we have hardware CPUID instruction, we make sure</a>
<a name="ln2843">         * that the features reported are limited to TSC and VME.</a>
<a name="ln2844">         */</a>
<a name="ln2845">        M.x86.R_EDX &amp;= 0x00000012;</a>
<a name="ln2846">#endif</a>
<a name="ln2847">        break;</a>
<a name="ln2848">    default:</a>
<a name="ln2849">        /* Finally, we don't support any additional features.  Most CPUs</a>
<a name="ln2850">         * return all zeros when queried for invalid or unsupported feature</a>
<a name="ln2851">         * numbers.</a>
<a name="ln2852">         */</a>
<a name="ln2853">        M.x86.R_EAX = 0;</a>
<a name="ln2854">        M.x86.R_EBX = 0;</a>
<a name="ln2855">        M.x86.R_ECX = 0;</a>
<a name="ln2856">        M.x86.R_EDX = 0;</a>
<a name="ln2857">        break;</a>
<a name="ln2858">    }</a>
<a name="ln2859">}</a>

</code></pre>
<div class="balloon" rel="1623"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'cnt >= 8' is always false.</p></div>
<div class="balloon" rel="1666"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'cnt >= 16' is always false.</p></div>
<div class="balloon" rel="983"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v610/" target="_blank">V610</a> Undefined behavior. Check the shift operator '<<'. The right operand ('cnt' = [1..32]) is greater than or equal to the length in bits of the promoted left operand.</p></div>
<div class="balloon" rel="985"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v610/" target="_blank">V610</a> Undefined behavior. Check the shift operator '>>'. The right operand ('(33 - cnt)' = [1..32]) is greater than or equal to the length in bits of the promoted left operand.</p></div>
<div class="balloon" rel="1709"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'cnt >= 32' is always false.</p></div>
<div class="balloon" rel="1133"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v610/" target="_blank">V610</a> Undefined behavior. Check the shift operator '>>'. The right operand ('cnt' = [1..32]) is greater than or equal to the length in bits of the promoted left operand.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
