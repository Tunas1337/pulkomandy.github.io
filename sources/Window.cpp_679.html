
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>Window.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2001-2016 Haiku, Inc. All rights reserved</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Stephan Aßmus, superstippi@gmx.de</a>
<a name="ln7"> *		Axel Dörfler, axeld@pinc-software.de</a>
<a name="ln8"> *		Adrian Oanca, adioanca@cotty.iren.ro</a>
<a name="ln9"> *		John Scipione, jscipione@gmail.com</a>
<a name="ln10"> */</a>
<a name="ln11"> </a>
<a name="ln12"> </a>
<a name="ln13">#include &lt;Window.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;ctype.h&gt;</a>
<a name="ln16">#include &lt;math.h&gt;</a>
<a name="ln17">#include &lt;stdio.h&gt;</a>
<a name="ln18">#include &lt;stdlib.h&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;Application.h&gt;</a>
<a name="ln21">#include &lt;AppMisc.h&gt;</a>
<a name="ln22">#include &lt;AppServerLink.h&gt;</a>
<a name="ln23">#include &lt;ApplicationPrivate.h&gt;</a>
<a name="ln24">#include &lt;Autolock.h&gt;</a>
<a name="ln25">#include &lt;Bitmap.h&gt;</a>
<a name="ln26">#include &lt;Button.h&gt;</a>
<a name="ln27">#include &lt;Deskbar.h&gt;</a>
<a name="ln28">#include &lt;DirectMessageTarget.h&gt;</a>
<a name="ln29">#include &lt;FindDirectory.h&gt;</a>
<a name="ln30">#include &lt;InputServerTypes.h&gt;</a>
<a name="ln31">#include &lt;Layout.h&gt;</a>
<a name="ln32">#include &lt;LayoutUtils.h&gt;</a>
<a name="ln33">#include &lt;MenuBar.h&gt;</a>
<a name="ln34">#include &lt;MenuItem.h&gt;</a>
<a name="ln35">#include &lt;MenuPrivate.h&gt;</a>
<a name="ln36">#include &lt;MessagePrivate.h&gt;</a>
<a name="ln37">#include &lt;MessageQueue.h&gt;</a>
<a name="ln38">#include &lt;MessageRunner.h&gt;</a>
<a name="ln39">#include &lt;Path.h&gt;</a>
<a name="ln40">#include &lt;PortLink.h&gt;</a>
<a name="ln41">#include &lt;PropertyInfo.h&gt;</a>
<a name="ln42">#include &lt;Roster.h&gt;</a>
<a name="ln43">#include &lt;RosterPrivate.h&gt;</a>
<a name="ln44">#include &lt;Screen.h&gt;</a>
<a name="ln45">#include &lt;ServerProtocol.h&gt;</a>
<a name="ln46">#include &lt;String.h&gt;</a>
<a name="ln47">#include &lt;TextView.h&gt;</a>
<a name="ln48">#include &lt;TokenSpace.h&gt;</a>
<a name="ln49">#include &lt;ToolTipManager.h&gt;</a>
<a name="ln50">#include &lt;ToolTipWindow.h&gt;</a>
<a name="ln51">#include &lt;UnicodeChar.h&gt;</a>
<a name="ln52">#include &lt;WindowPrivate.h&gt;</a>
<a name="ln53"> </a>
<a name="ln54">#include &lt;binary_compatibility/Interface.h&gt;</a>
<a name="ln55">#include &lt;input_globals.h&gt;</a>
<a name="ln56">#include &lt;tracker_private.h&gt;</a>
<a name="ln57"> </a>
<a name="ln58"> </a>
<a name="ln59">//#define DEBUG_WIN</a>
<a name="ln60">#ifdef DEBUG_WIN</a>
<a name="ln61">#	define STRACE(x) printf x</a>
<a name="ln62">#else</a>
<a name="ln63">#	define STRACE(x) ;</a>
<a name="ln64">#endif</a>
<a name="ln65"> </a>
<a name="ln66">#define B_HIDE_APPLICATION '_AHD'</a>
<a name="ln67">	// if we ever move this to a public namespace, we should also move the</a>
<a name="ln68">	// handling of this message into BApplication</a>
<a name="ln69"> </a>
<a name="ln70">#define _MINIMIZE_			'_WMZ'</a>
<a name="ln71">#define _ZOOM_				'_WZO'</a>
<a name="ln72">#define _SEND_BEHIND_		'_WSB'</a>
<a name="ln73">#define _SEND_TO_FRONT_		'_WSF'</a>
<a name="ln74"> </a>
<a name="ln75"> </a>
<a name="ln76">void do_minimize_team(BRect zoomRect, team_id team, bool zoom);</a>
<a name="ln77"> </a>
<a name="ln78"> </a>
<a name="ln79">struct BWindow::unpack_cookie {</a>
<a name="ln80">	unpack_cookie();</a>
<a name="ln81"> </a>
<a name="ln82">	BMessage*	message;</a>
<a name="ln83">	int32		index;</a>
<a name="ln84">	BHandler*	focus;</a>
<a name="ln85">	int32		focus_token;</a>
<a name="ln86">	int32		last_view_token;</a>
<a name="ln87">	bool		found_focus;</a>
<a name="ln88">	bool		tokens_scanned;</a>
<a name="ln89">};</a>
<a name="ln90"> </a>
<a name="ln91"> </a>
<a name="ln92">class BWindow::Shortcut {</a>
<a name="ln93">public:</a>
<a name="ln94">							Shortcut(uint32 key, uint32 modifiers,</a>
<a name="ln95">								BMenuItem* item);</a>
<a name="ln96">							Shortcut(uint32 key, uint32 modifiers,</a>
<a name="ln97">								BMessage* message, BHandler* target);</a>
<a name="ln98">							~Shortcut();</a>
<a name="ln99"> </a>
<a name="ln100">			bool			Matches(uint32 key, uint32 modifiers) const;</a>
<a name="ln101"> </a>
<a name="ln102">			BMenuItem*		MenuItem() const { return fMenuItem; }</a>
<a name="ln103">			BMessage*		Message() const { return fMessage; }</a>
<a name="ln104">			BHandler*		Target() const { return fTarget; }</a>
<a name="ln105"> </a>
<a name="ln106">	static	uint32			AllowedModifiers();</a>
<a name="ln107">	static	uint32			PrepareKey(uint32 key);</a>
<a name="ln108">	static	uint32			PrepareModifiers(uint32 modifiers);</a>
<a name="ln109"> </a>
<a name="ln110">private:</a>
<a name="ln111">			uint32			fKey;</a>
<a name="ln112">			uint32			fModifiers;</a>
<a name="ln113">			BMenuItem*		fMenuItem;</a>
<a name="ln114">			BMessage*		fMessage;</a>
<a name="ln115">			BHandler*		fTarget;</a>
<a name="ln116">};</a>
<a name="ln117"> </a>
<a name="ln118"> </a>
<a name="ln119">using BPrivate::gDefaultTokens;</a>
<a name="ln120">using BPrivate::MenuPrivate;</a>
<a name="ln121"> </a>
<a name="ln122">static property_info sWindowPropInfo[] = {</a>
<a name="ln123">	{</a>
<a name="ln124">		&quot;Active&quot;, { B_GET_PROPERTY, B_SET_PROPERTY },</a>
<a name="ln125">		{ B_DIRECT_SPECIFIER }, NULL, 0, { B_BOOL_TYPE }</a>
<a name="ln126">	},</a>
<a name="ln127"> </a>
<a name="ln128">	{</a>
<a name="ln129">		&quot;Feel&quot;, { B_GET_PROPERTY, B_SET_PROPERTY },</a>
<a name="ln130">		{ B_DIRECT_SPECIFIER }, NULL, 0, { B_INT32_TYPE }</a>
<a name="ln131">	},</a>
<a name="ln132"> </a>
<a name="ln133">	{</a>
<a name="ln134">		&quot;Flags&quot;, { B_GET_PROPERTY, B_SET_PROPERTY },</a>
<a name="ln135">		{ B_DIRECT_SPECIFIER }, NULL, 0, { B_INT32_TYPE }</a>
<a name="ln136">	},</a>
<a name="ln137"> </a>
<a name="ln138">	{</a>
<a name="ln139">		&quot;Frame&quot;, { B_GET_PROPERTY, B_SET_PROPERTY },</a>
<a name="ln140">		{ B_DIRECT_SPECIFIER }, NULL, 0, { B_RECT_TYPE }</a>
<a name="ln141">	},</a>
<a name="ln142"> </a>
<a name="ln143">	{</a>
<a name="ln144">		&quot;Hidden&quot;, { B_GET_PROPERTY, B_SET_PROPERTY },</a>
<a name="ln145">		{ B_DIRECT_SPECIFIER }, NULL, 0, { B_BOOL_TYPE }</a>
<a name="ln146">	},</a>
<a name="ln147"> </a>
<a name="ln148">	{</a>
<a name="ln149">		&quot;Look&quot;, { B_GET_PROPERTY, B_SET_PROPERTY },</a>
<a name="ln150">		{ B_DIRECT_SPECIFIER }, NULL, 0, { B_INT32_TYPE }</a>
<a name="ln151">	},</a>
<a name="ln152"> </a>
<a name="ln153">	{</a>
<a name="ln154">		&quot;Title&quot;, { B_GET_PROPERTY, B_SET_PROPERTY },</a>
<a name="ln155">		{ B_DIRECT_SPECIFIER }, NULL, 0, { B_STRING_TYPE }</a>
<a name="ln156">	},</a>
<a name="ln157"> </a>
<a name="ln158">	{</a>
<a name="ln159">		&quot;Workspaces&quot;, { B_GET_PROPERTY, B_SET_PROPERTY },</a>
<a name="ln160">		{ B_DIRECT_SPECIFIER }, NULL, 0, { B_INT32_TYPE }</a>
<a name="ln161">	},</a>
<a name="ln162"> </a>
<a name="ln163">	{</a>
<a name="ln164">		&quot;MenuBar&quot;, {},</a>
<a name="ln165">		{ B_DIRECT_SPECIFIER }, NULL, 0, {}</a>
<a name="ln166">	},</a>
<a name="ln167"> </a>
<a name="ln168">	{</a>
<a name="ln169">		&quot;View&quot;, { B_COUNT_PROPERTIES },</a>
<a name="ln170">		{ B_DIRECT_SPECIFIER }, NULL, 0, { B_INT32_TYPE }</a>
<a name="ln171">	},</a>
<a name="ln172"> </a>
<a name="ln173">	{</a>
<a name="ln174">		&quot;View&quot;, {}, {}, NULL, 0, {}</a>
<a name="ln175">	},</a>
<a name="ln176"> </a>
<a name="ln177">	{</a>
<a name="ln178">		&quot;Minimize&quot;, { B_GET_PROPERTY, B_SET_PROPERTY },</a>
<a name="ln179">		{ B_DIRECT_SPECIFIER }, NULL, 0, { B_BOOL_TYPE }</a>
<a name="ln180">	},</a>
<a name="ln181"> </a>
<a name="ln182">	{</a>
<a name="ln183">		&quot;TabFrame&quot;, { B_GET_PROPERTY },</a>
<a name="ln184">		{ B_DIRECT_SPECIFIER }, NULL, 0, { B_RECT_TYPE }</a>
<a name="ln185">	},</a>
<a name="ln186"> </a>
<a name="ln187">	{ 0 }</a>
<a name="ln188">};</a>
<a name="ln189"> </a>
<a name="ln190">static value_info sWindowValueInfo[] = {</a>
<a name="ln191">	{</a>
<a name="ln192">		&quot;MoveTo&quot;, 'WDMT', B_COMMAND_KIND,</a>
<a name="ln193">		&quot;Moves to the position in the BPoint data&quot;</a>
<a name="ln194">	},</a>
<a name="ln195"> </a>
<a name="ln196">	{</a>
<a name="ln197">		&quot;MoveBy&quot;, 'WDMB', B_COMMAND_KIND,</a>
<a name="ln198">		&quot;Moves by the offsets in the BPoint data&quot;</a>
<a name="ln199">	},</a>
<a name="ln200"> </a>
<a name="ln201">	{</a>
<a name="ln202">		&quot;ResizeTo&quot;, 'WDRT', B_COMMAND_KIND,</a>
<a name="ln203">		&quot;Resize to the size in the BPoint data&quot;</a>
<a name="ln204">	},</a>
<a name="ln205"> </a>
<a name="ln206">	{</a>
<a name="ln207">		&quot;ResizeBy&quot;, 'WDRB', B_COMMAND_KIND,</a>
<a name="ln208">		&quot;Resize by the offsets in the BPoint data&quot;</a>
<a name="ln209">	},</a>
<a name="ln210"> </a>
<a name="ln211">	{ 0 }</a>
<a name="ln212">};</a>
<a name="ln213"> </a>
<a name="ln214"> </a>
<a name="ln215">void</a>
<a name="ln216">_set_menu_sem_(BWindow* window, sem_id sem)</a>
<a name="ln217">{</a>
<a name="ln218">	if (window != NULL)</a>
<a name="ln219">		window-&gt;fMenuSem = sem;</a>
<a name="ln220">}</a>
<a name="ln221"> </a>
<a name="ln222"> </a>
<a name="ln223">//	#pragma mark -</a>
<a name="ln224"> </a>
<a name="ln225"> </a>
<a name="ln226">BWindow::unpack_cookie::unpack_cookie()</a>
<a name="ln227">	:</a>
<a name="ln228">	message((BMessage*)~0UL),</a>
<a name="ln229">		// message == NULL is our exit condition</a>
<a name="ln230">	index(0),</a>
<a name="ln231">	focus_token(B_NULL_TOKEN),</a>
<a name="ln232">	last_view_token(B_NULL_TOKEN),</a>
<a name="ln233">	found_focus(false),</a>
<a name="ln234">	tokens_scanned(false)</a>
<a name="ln235">{</a>
<a name="ln236">}</a>
<a name="ln237"> </a>
<a name="ln238"> </a>
<a name="ln239">//	#pragma mark - BWindow::Shortcut</a>
<a name="ln240"> </a>
<a name="ln241"> </a>
<a name="ln242">BWindow::Shortcut::Shortcut(uint32 key, uint32 modifiers, BMenuItem* item)</a>
<a name="ln243">	:</a>
<a name="ln244">	fKey(PrepareKey(key)),</a>
<a name="ln245">	fModifiers(PrepareModifiers(modifiers)),</a>
<a name="ln246">	fMenuItem(item),</a>
<a name="ln247">	fMessage(NULL),</a>
<a name="ln248">	fTarget(NULL)</a>
<a name="ln249">{</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252"> </a>
<a name="ln253">BWindow::Shortcut::Shortcut(uint32 key, uint32 modifiers, BMessage* message,</a>
<a name="ln254">	BHandler* target)</a>
<a name="ln255">	:</a>
<a name="ln256">	fKey(PrepareKey(key)),</a>
<a name="ln257">	fModifiers(PrepareModifiers(modifiers)),</a>
<a name="ln258">	fMenuItem(NULL),</a>
<a name="ln259">	fMessage(message),</a>
<a name="ln260">	fTarget(target)</a>
<a name="ln261">{</a>
<a name="ln262">}</a>
<a name="ln263"> </a>
<a name="ln264"> </a>
<a name="ln265">BWindow::Shortcut::~Shortcut()</a>
<a name="ln266">{</a>
<a name="ln267">	// we own the message, if any</a>
<a name="ln268">	delete fMessage;</a>
<a name="ln269">}</a>
<a name="ln270"> </a>
<a name="ln271"> </a>
<a name="ln272">bool</a>
<a name="ln273">BWindow::Shortcut::Matches(uint32 key, uint32 modifiers) const</a>
<a name="ln274">{</a>
<a name="ln275">	return fKey == key &amp;&amp; fModifiers == modifiers;</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278"> </a>
<a name="ln279">/*static*/</a>
<a name="ln280">uint32</a>
<a name="ln281">BWindow::Shortcut::AllowedModifiers()</a>
<a name="ln282">{</a>
<a name="ln283">	return B_COMMAND_KEY | B_OPTION_KEY | B_SHIFT_KEY | B_CONTROL_KEY</a>
<a name="ln284">		| B_MENU_KEY;</a>
<a name="ln285">}</a>
<a name="ln286"> </a>
<a name="ln287"> </a>
<a name="ln288">/*static*/</a>
<a name="ln289">uint32</a>
<a name="ln290">BWindow::Shortcut::PrepareModifiers(uint32 modifiers)</a>
<a name="ln291">{</a>
<a name="ln292">	return (modifiers &amp; AllowedModifiers()) | B_COMMAND_KEY;</a>
<a name="ln293">}</a>
<a name="ln294"> </a>
<a name="ln295"> </a>
<a name="ln296">/*static*/</a>
<a name="ln297">uint32</a>
<a name="ln298">BWindow::Shortcut::PrepareKey(uint32 key)</a>
<a name="ln299">{</a>
<a name="ln300">	return BUnicodeChar::ToLower(key);</a>
<a name="ln301">}</a>
<a name="ln302"> </a>
<a name="ln303"> </a>
<a name="ln304">//	#pragma mark - BWindow</a>
<a name="ln305"> </a>
<a name="ln306"> </a>
<a name="ln307">BWindow::BWindow(BRect frame, const char* title, window_type type,</a>
<a name="ln308">		uint32 flags, uint32 workspace)</a>
<a name="ln309">	:</a>
<a name="ln310">	BLooper(title, B_DISPLAY_PRIORITY)</a>
<a name="ln311">{</a>
<a name="ln312">	window_look look;</a>
<a name="ln313">	window_feel feel;</a>
<a name="ln314">	_DecomposeType(type, &amp;look, &amp;feel);</a>
<a name="ln315"> </a>
<a name="ln316">	_InitData(frame, title, look, feel, flags, workspace);</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319"> </a>
<a name="ln320">BWindow::BWindow(BRect frame, const char* title, window_look look,</a>
<a name="ln321">		window_feel feel, uint32 flags, uint32 workspace)</a>
<a name="ln322">	:</a>
<a name="ln323">	BLooper(title, B_DISPLAY_PRIORITY)</a>
<a name="ln324">{</a>
<a name="ln325">	_InitData(frame, title, look, feel, flags, workspace);</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328"> </a>
<a name="ln329">BWindow::BWindow(BMessage* data)</a>
<a name="ln330">	:</a>
<a name="ln331">	BLooper(data)</a>
<a name="ln332">{</a>
<a name="ln333">	data-&gt;FindRect(&quot;_frame&quot;, &amp;fFrame);</a>
<a name="ln334"> </a>
<a name="ln335">	const char* title;</a>
<a name="ln336">	data-&gt;FindString(&quot;_title&quot;, &amp;title);</a>
<a name="ln337"> </a>
<a name="ln338">	window_look look;</a>
<a name="ln339">	data-&gt;FindInt32(&quot;_wlook&quot;, (int32*)&amp;look);</a>
<a name="ln340"> </a>
<a name="ln341">	window_feel feel;</a>
<a name="ln342">	data-&gt;FindInt32(&quot;_wfeel&quot;, (int32*)&amp;feel);</a>
<a name="ln343"> </a>
<a name="ln344">	if (data-&gt;FindInt32(&quot;_flags&quot;, (int32*)&amp;fFlags) != B_OK)</a>
<a name="ln345">		fFlags = 0;</a>
<a name="ln346"> </a>
<a name="ln347">	uint32 workspaces;</a>
<a name="ln348">	data-&gt;FindInt32(&quot;_wspace&quot;, (int32*)&amp;workspaces);</a>
<a name="ln349"> </a>
<a name="ln350">	uint32 type;</a>
<a name="ln351">	if (data-&gt;FindInt32(&quot;_type&quot;, (int32*)&amp;type) == B_OK)</a>
<a name="ln352">		_DecomposeType((window_type)type, &amp;fLook, &amp;fFeel);</a>
<a name="ln353"> </a>
<a name="ln354">		// connect to app_server and initialize data</a>
<a name="ln355">	_InitData(fFrame, title, look, feel, fFlags, workspaces);</a>
<a name="ln356"> </a>
<a name="ln357">	if (data-&gt;FindFloat(&quot;_zoom&quot;, 0, &amp;fMaxZoomWidth) == B_OK</a>
<a name="ln358">		&amp;&amp; data-&gt;FindFloat(&quot;_zoom&quot;, 1, &amp;fMaxZoomHeight) == B_OK)</a>
<a name="ln359">		SetZoomLimits(fMaxZoomWidth, fMaxZoomHeight);</a>
<a name="ln360"> </a>
<a name="ln361">	if (data-&gt;FindFloat(&quot;_sizel&quot;, 0, &amp;fMinWidth) == B_OK</a>
<a name="ln362">		&amp;&amp; data-&gt;FindFloat(&quot;_sizel&quot;, 1, &amp;fMinHeight) == B_OK</a>
<a name="ln363">		&amp;&amp; data-&gt;FindFloat(&quot;_sizel&quot;, 2, &amp;fMaxWidth) == B_OK</a>
<a name="ln364">		&amp;&amp; data-&gt;FindFloat(&quot;_sizel&quot;, 3, &amp;fMaxHeight) == B_OK)</a>
<a name="ln365">		SetSizeLimits(fMinWidth, fMaxWidth,</a>
<a name="ln366">			fMinHeight, fMaxHeight);</a>
<a name="ln367"> </a>
<a name="ln368">	if (data-&gt;FindInt64(&quot;_pulse&quot;, &amp;fPulseRate) == B_OK)</a>
<a name="ln369">		SetPulseRate(fPulseRate);</a>
<a name="ln370"> </a>
<a name="ln371">	BMessage msg;</a>
<a name="ln372">	int32 i = 0;</a>
<a name="ln373">	while (data-&gt;FindMessage(&quot;_views&quot;, i++, &amp;msg) == B_OK) {</a>
<a name="ln374">		BArchivable* obj = instantiate_object(&amp;msg);</a>
<a name="ln375">		if (BView* child = dynamic_cast&lt;BView*&gt;(obj))</a>
<a name="ln376">			AddChild(child);</a>
<a name="ln377">	}</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380"> </a>
<a name="ln381">BWindow::BWindow(BRect frame, int32 bitmapToken)</a>
<a name="ln382">	:</a>
<a name="ln383">	BLooper(&quot;offscreen bitmap&quot;)</a>
<a name="ln384">{</a>
<a name="ln385">	_DecomposeType(B_UNTYPED_WINDOW, &amp;fLook, &amp;fFeel);</a>
<a name="ln386">	_InitData(frame, &quot;offscreen&quot;, fLook, fFeel, 0, 0, bitmapToken);</a>
<a name="ln387">}</a>
<a name="ln388"> </a>
<a name="ln389"> </a>
<a name="ln390">BWindow::~BWindow()</a>
<a name="ln391">{</a>
<a name="ln392">	if (BMenu* menu = dynamic_cast&lt;BMenu*&gt;(fFocus)) {</a>
<a name="ln393">		MenuPrivate(menu).QuitTracking();</a>
<a name="ln394">	}</a>
<a name="ln395"> </a>
<a name="ln396">	// The BWindow is locked when the destructor is called,</a>
<a name="ln397">	// we need to unlock because the menubar thread tries</a>
<a name="ln398">	// to post a message, which will deadlock otherwise.</a>
<a name="ln399">	// TODO: I replaced Unlock() with UnlockFully() because the window</a>
<a name="ln400">	// was kept locked after that in case it was closed using ALT-W.</a>
<a name="ln401">	// There might be an extra Lock() somewhere in the quitting path...</a>
<a name="ln402">	UnlockFully();</a>
<a name="ln403"> </a>
<a name="ln404">	// Wait if a menu is still tracking</a>
<a name="ln405">	if (fMenuSem &gt; 0) {</a>
<a name="ln406">		while (acquire_sem(fMenuSem) == B_INTERRUPTED)</a>
<a name="ln407">			;</a>
<a name="ln408">	}</a>
<a name="ln409"> </a>
<a name="ln410">	Lock();</a>
<a name="ln411"> </a>
<a name="ln412">	fTopView-&gt;RemoveSelf();</a>
<a name="ln413">	delete fTopView;</a>
<a name="ln414"> </a>
<a name="ln415">	// remove all remaining shortcuts</a>
<a name="ln416">	int32 shortCutCount = fShortcuts.CountItems();</a>
<a name="ln417">	for (int32 i = 0; i &lt; shortCutCount; i++) {</a>
<a name="ln418">		delete (Shortcut*)fShortcuts.ItemAtFast(i);</a>
<a name="ln419">	}</a>
<a name="ln420"> </a>
<a name="ln421">	// TODO: release other dynamically-allocated objects</a>
<a name="ln422">	free(fTitle);</a>
<a name="ln423"> </a>
<a name="ln424">	// disable pulsing</a>
<a name="ln425">	SetPulseRate(0);</a>
<a name="ln426"> </a>
<a name="ln427">	// tell app_server about our demise</a>
<a name="ln428">	fLink-&gt;StartMessage(AS_DELETE_WINDOW);</a>
<a name="ln429">	// sync with the server so that for example</a>
<a name="ln430">	// a BBitmap can be sure that there are no</a>
<a name="ln431">	// more pending messages that are executed</a>
<a name="ln432">	// after the bitmap is deleted (which uses</a>
<a name="ln433">	// a different link and server side thread)</a>
<a name="ln434">	int32 code;</a>
<a name="ln435">	fLink-&gt;FlushWithReply(code);</a>
<a name="ln436"> </a>
<a name="ln437">	// the sender port belongs to the app_server</a>
<a name="ln438">	delete_port(fLink-&gt;ReceiverPort());</a>
<a name="ln439">	delete fLink;</a>
<a name="ln440">}</a>
<a name="ln441"> </a>
<a name="ln442"> </a>
<a name="ln443">BArchivable*</a>
<a name="ln444">BWindow::Instantiate(BMessage* data)</a>
<a name="ln445">{</a>
<a name="ln446">	if (!validate_instantiation(data, &quot;BWindow&quot;))</a>
<a name="ln447">		return NULL;</a>
<a name="ln448"> </a>
<a name="ln449">	return new(std::nothrow) BWindow(data);</a>
<a name="ln450">}</a>
<a name="ln451"> </a>
<a name="ln452"> </a>
<a name="ln453">status_t</a>
<a name="ln454">BWindow::Archive(BMessage* data, bool deep) const</a>
<a name="ln455">{</a>
<a name="ln456">	status_t ret = BLooper::Archive(data, deep);</a>
<a name="ln457"> </a>
<a name="ln458">	if (ret == B_OK)</a>
<a name="ln459">		ret = data-&gt;AddRect(&quot;_frame&quot;, fFrame);</a>
<a name="ln460">	if (ret == B_OK)</a>
<a name="ln461">		ret = data-&gt;AddString(&quot;_title&quot;, fTitle);</a>
<a name="ln462">	if (ret == B_OK)</a>
<a name="ln463">		ret = data-&gt;AddInt32(&quot;_wlook&quot;, fLook);</a>
<a name="ln464">	if (ret == B_OK)</a>
<a name="ln465">		ret = data-&gt;AddInt32(&quot;_wfeel&quot;, fFeel);</a>
<a name="ln466">	if (ret == B_OK &amp;&amp; fFlags != 0)</a>
<a name="ln467">		ret = data-&gt;AddInt32(&quot;_flags&quot;, fFlags);</a>
<a name="ln468">	if (ret == B_OK)</a>
<a name="ln469">		ret = data-&gt;AddInt32(&quot;_wspace&quot;, (uint32)Workspaces());</a>
<a name="ln470"> </a>
<a name="ln471">	if (ret == B_OK &amp;&amp; !_ComposeType(fLook, fFeel))</a>
<a name="ln472">		ret = data-&gt;AddInt32(&quot;_type&quot;, (uint32)Type());</a>
<a name="ln473"> </a>
<a name="ln474">	if (fMaxZoomWidth != 32768.0 || fMaxZoomHeight != 32768.0) {</a>
<a name="ln475">		if (ret == B_OK)</a>
<a name="ln476">			ret = data-&gt;AddFloat(&quot;_zoom&quot;, fMaxZoomWidth);</a>
<a name="ln477">		if (ret == B_OK)</a>
<a name="ln478">			ret = data-&gt;AddFloat(&quot;_zoom&quot;, fMaxZoomHeight);</a>
<a name="ln479">	}</a>
<a name="ln480"> </a>
<a name="ln481">	if (fMinWidth != 0.0 || fMinHeight != 0.0</a>
<a name="ln482">		|| fMaxWidth != 32768.0 || fMaxHeight != 32768.0) {</a>
<a name="ln483">		if (ret == B_OK)</a>
<a name="ln484">			ret = data-&gt;AddFloat(&quot;_sizel&quot;, fMinWidth);</a>
<a name="ln485">		if (ret == B_OK)</a>
<a name="ln486">			ret = data-&gt;AddFloat(&quot;_sizel&quot;, fMinHeight);</a>
<a name="ln487">		if (ret == B_OK)</a>
<a name="ln488">			ret = data-&gt;AddFloat(&quot;_sizel&quot;, fMaxWidth);</a>
<a name="ln489">		if (ret == B_OK)</a>
<a name="ln490">			ret = data-&gt;AddFloat(&quot;_sizel&quot;, fMaxHeight);</a>
<a name="ln491">	}</a>
<a name="ln492"> </a>
<a name="ln493">	if (ret == B_OK &amp;&amp; fPulseRate != 500000)</a>
<a name="ln494">		data-&gt;AddInt64(&quot;_pulse&quot;, fPulseRate);</a>
<a name="ln495"> </a>
<a name="ln496">	if (ret == B_OK &amp;&amp; deep) {</a>
<a name="ln497">		int32 noOfViews = CountChildren();</a>
<a name="ln498">		for (int32 i = 0; i &lt; noOfViews; i++){</a>
<a name="ln499">			BMessage childArchive;</a>
<a name="ln500">			ret = ChildAt(i)-&gt;Archive(&amp;childArchive, true);</a>
<a name="ln501">			if (ret == B_OK)</a>
<a name="ln502">				ret = data-&gt;AddMessage(&quot;_views&quot;, &amp;childArchive);</a>
<a name="ln503">			if (ret != B_OK)</a>
<a name="ln504">				break;</a>
<a name="ln505">		}</a>
<a name="ln506">	}</a>
<a name="ln507"> </a>
<a name="ln508">	return ret;</a>
<a name="ln509">}</a>
<a name="ln510"> </a>
<a name="ln511"> </a>
<a name="ln512">void</a>
<a name="ln513">BWindow::Quit()</a>
<a name="ln514">{</a>
<a name="ln515">	if (!IsLocked()) {</a>
<a name="ln516">		const char* name = Name();</a>
<a name="ln517">		if (name == NULL)</a>
<a name="ln518">			name = &quot;no-name&quot;;</a>
<a name="ln519"> </a>
<a name="ln520">		printf(&quot;ERROR - you must Lock a looper before calling Quit(), &quot;</a>
<a name="ln521">			   &quot;team=%&quot; B_PRId32 &quot;, looper=%s\n&quot;, Team(), name);</a>
<a name="ln522">	}</a>
<a name="ln523"> </a>
<a name="ln524">	// Try to lock</a>
<a name="ln525">	if (!Lock()){</a>
<a name="ln526">		// We're toast already</a>
<a name="ln527">		return;</a>
<a name="ln528">	}</a>
<a name="ln529"> </a>
<a name="ln530">	while (!IsHidden())	{</a>
<a name="ln531">		Hide();</a>
<a name="ln532">	}</a>
<a name="ln533"> </a>
<a name="ln534">	if (fFlags &amp; B_QUIT_ON_WINDOW_CLOSE)</a>
<a name="ln535">		be_app-&gt;PostMessage(B_QUIT_REQUESTED);</a>
<a name="ln536"> </a>
<a name="ln537">	BLooper::Quit();</a>
<a name="ln538">}</a>
<a name="ln539"> </a>
<a name="ln540"> </a>
<a name="ln541">void</a>
<a name="ln542">BWindow::AddChild(BView* child, BView* before)</a>
<a name="ln543">{</a>
<a name="ln544">	BAutolock locker(this);</a>
<a name="ln545">	if (locker.IsLocked())</a>
<a name="ln546">		fTopView-&gt;AddChild(child, before);</a>
<a name="ln547">}</a>
<a name="ln548"> </a>
<a name="ln549"> </a>
<a name="ln550">void</a>
<a name="ln551">BWindow::AddChild(BLayoutItem* child)</a>
<a name="ln552">{</a>
<a name="ln553">	BAutolock locker(this);</a>
<a name="ln554">	if (locker.IsLocked())</a>
<a name="ln555">		fTopView-&gt;AddChild(child);</a>
<a name="ln556">}</a>
<a name="ln557"> </a>
<a name="ln558"> </a>
<a name="ln559">bool</a>
<a name="ln560">BWindow::RemoveChild(BView* child)</a>
<a name="ln561">{</a>
<a name="ln562">	BAutolock locker(this);</a>
<a name="ln563">	if (!locker.IsLocked())</a>
<a name="ln564">		return false;</a>
<a name="ln565"> </a>
<a name="ln566">	return fTopView-&gt;RemoveChild(child);</a>
<a name="ln567">}</a>
<a name="ln568"> </a>
<a name="ln569"> </a>
<a name="ln570">int32</a>
<a name="ln571">BWindow::CountChildren() const</a>
<a name="ln572">{</a>
<a name="ln573">	BAutolock locker(const_cast&lt;BWindow*&gt;(this));</a>
<a name="ln574">	if (!locker.IsLocked())</a>
<a name="ln575">		return 0;</a>
<a name="ln576"> </a>
<a name="ln577">	return fTopView-&gt;CountChildren();</a>
<a name="ln578">}</a>
<a name="ln579"> </a>
<a name="ln580"> </a>
<a name="ln581">BView*</a>
<a name="ln582">BWindow::ChildAt(int32 index) const</a>
<a name="ln583">{</a>
<a name="ln584">	BAutolock locker(const_cast&lt;BWindow*&gt;(this));</a>
<a name="ln585">	if (!locker.IsLocked())</a>
<a name="ln586">		return NULL;</a>
<a name="ln587"> </a>
<a name="ln588">	return fTopView-&gt;ChildAt(index);</a>
<a name="ln589">}</a>
<a name="ln590"> </a>
<a name="ln591"> </a>
<a name="ln592">void</a>
<a name="ln593">BWindow::Minimize(bool minimize)</a>
<a name="ln594">{</a>
<a name="ln595">	if (IsModal() || IsFloating() || IsHidden() || fMinimized == minimize</a>
<a name="ln596">		|| !Lock())</a>
<a name="ln597">		return;</a>
<a name="ln598"> </a>
<a name="ln599">	fMinimized = minimize;</a>
<a name="ln600"> </a>
<a name="ln601">	fLink-&gt;StartMessage(AS_MINIMIZE_WINDOW);</a>
<a name="ln602">	fLink-&gt;Attach&lt;bool&gt;(minimize);</a>
<a name="ln603">	fLink-&gt;Flush();</a>
<a name="ln604"> </a>
<a name="ln605">	Unlock();</a>
<a name="ln606">}</a>
<a name="ln607"> </a>
<a name="ln608"> </a>
<a name="ln609">status_t</a>
<a name="ln610">BWindow::SendBehind(const BWindow* window)</a>
<a name="ln611">{</a>
<a name="ln612">	if (!Lock())</a>
<a name="ln613">		return B_ERROR;</a>
<a name="ln614"> </a>
<a name="ln615">	fLink-&gt;StartMessage(AS_SEND_BEHIND);</a>
<a name="ln616">	fLink-&gt;Attach&lt;int32&gt;(window != NULL ? _get_object_token_(window) : -1);</a>
<a name="ln617">	fLink-&gt;Attach&lt;team_id&gt;(Team());</a>
<a name="ln618"> </a>
<a name="ln619">	status_t status = B_ERROR;</a>
<a name="ln620">	fLink-&gt;FlushWithReply(status);</a>
<a name="ln621"> </a>
<a name="ln622">	Unlock();</a>
<a name="ln623"> </a>
<a name="ln624">	return status;</a>
<a name="ln625">}</a>
<a name="ln626"> </a>
<a name="ln627"> </a>
<a name="ln628">void</a>
<a name="ln629">BWindow::Flush() const</a>
<a name="ln630">{</a>
<a name="ln631">	if (const_cast&lt;BWindow*&gt;(this)-&gt;Lock()) {</a>
<a name="ln632">		fLink-&gt;Flush();</a>
<a name="ln633">		const_cast&lt;BWindow*&gt;(this)-&gt;Unlock();</a>
<a name="ln634">	}</a>
<a name="ln635">}</a>
<a name="ln636"> </a>
<a name="ln637"> </a>
<a name="ln638">void</a>
<a name="ln639">BWindow::Sync() const</a>
<a name="ln640">{</a>
<a name="ln641">	if (!const_cast&lt;BWindow*&gt;(this)-&gt;Lock())</a>
<a name="ln642">		return;</a>
<a name="ln643"> </a>
<a name="ln644">	fLink-&gt;StartMessage(AS_SYNC);</a>
<a name="ln645"> </a>
<a name="ln646">	// waiting for the reply is the actual syncing</a>
<a name="ln647">	int32 code;</a>
<a name="ln648">	fLink-&gt;FlushWithReply(code);</a>
<a name="ln649"> </a>
<a name="ln650">	const_cast&lt;BWindow*&gt;(this)-&gt;Unlock();</a>
<a name="ln651">}</a>
<a name="ln652"> </a>
<a name="ln653"> </a>
<a name="ln654">void</a>
<a name="ln655">BWindow::DisableUpdates()</a>
<a name="ln656">{</a>
<a name="ln657">	if (Lock()) {</a>
<a name="ln658">		fLink-&gt;StartMessage(AS_DISABLE_UPDATES);</a>
<a name="ln659">		fLink-&gt;Flush();</a>
<a name="ln660">		Unlock();</a>
<a name="ln661">	}</a>
<a name="ln662">}</a>
<a name="ln663"> </a>
<a name="ln664"> </a>
<a name="ln665">void</a>
<a name="ln666">BWindow::EnableUpdates()</a>
<a name="ln667">{</a>
<a name="ln668">	if (Lock()) {</a>
<a name="ln669">		fLink-&gt;StartMessage(AS_ENABLE_UPDATES);</a>
<a name="ln670">		fLink-&gt;Flush();</a>
<a name="ln671">		Unlock();</a>
<a name="ln672">	}</a>
<a name="ln673">}</a>
<a name="ln674"> </a>
<a name="ln675"> </a>
<a name="ln676">void</a>
<a name="ln677">BWindow::BeginViewTransaction()</a>
<a name="ln678">{</a>
<a name="ln679">	if (Lock()) {</a>
<a name="ln680">		fInTransaction = true;</a>
<a name="ln681">		Unlock();</a>
<a name="ln682">	}</a>
<a name="ln683">}</a>
<a name="ln684"> </a>
<a name="ln685"> </a>
<a name="ln686">void</a>
<a name="ln687">BWindow::EndViewTransaction()</a>
<a name="ln688">{</a>
<a name="ln689">	if (Lock()) {</a>
<a name="ln690">		if (fInTransaction)</a>
<a name="ln691">			fLink-&gt;Flush();</a>
<a name="ln692">		fInTransaction = false;</a>
<a name="ln693">		Unlock();</a>
<a name="ln694">	}</a>
<a name="ln695">}</a>
<a name="ln696"> </a>
<a name="ln697"> </a>
<a name="ln698">bool</a>
<a name="ln699">BWindow::InViewTransaction() const</a>
<a name="ln700">{</a>
<a name="ln701">	BAutolock locker(const_cast&lt;BWindow*&gt;(this));</a>
<a name="ln702">	return fInTransaction;</a>
<a name="ln703">}</a>
<a name="ln704"> </a>
<a name="ln705"> </a>
<a name="ln706">bool</a>
<a name="ln707">BWindow::IsFront() const</a>
<a name="ln708">{</a>
<a name="ln709">	BAutolock locker(const_cast&lt;BWindow*&gt;(this));</a>
<a name="ln710">	if (!locker.IsLocked())</a>
<a name="ln711">		return false;</a>
<a name="ln712"> </a>
<a name="ln713">	fLink-&gt;StartMessage(AS_IS_FRONT_WINDOW);</a>
<a name="ln714"> </a>
<a name="ln715">	status_t status;</a>
<a name="ln716">	if (fLink-&gt;FlushWithReply(status) == B_OK)</a>
<a name="ln717">		return status &gt;= B_OK;</a>
<a name="ln718"> </a>
<a name="ln719">	return false;</a>
<a name="ln720">}</a>
<a name="ln721"> </a>
<a name="ln722"> </a>
<a name="ln723">void</a>
<a name="ln724">BWindow::MessageReceived(BMessage* message)</a>
<a name="ln725">{</a>
<a name="ln726">	if (!message-&gt;HasSpecifiers()) {</a>
<a name="ln727">		if (message-&gt;what == B_KEY_DOWN)</a>
<a name="ln728">			_KeyboardNavigation();</a>
<a name="ln729"> </a>
<a name="ln730">		if (message-&gt;what == (int32)kMsgAppServerRestarted) {</a>
<a name="ln731">			fLink-&gt;SetSenderPort(</a>
<a name="ln732">				BApplication::Private::ServerLink()-&gt;SenderPort());</a>
<a name="ln733"> </a>
<a name="ln734">			BPrivate::AppServerLink lockLink;</a>
<a name="ln735">				// we're talking to the server application using our own</a>
<a name="ln736">				// communication channel (fLink) - we better make sure no one</a>
<a name="ln737">				// interferes by locking that channel (which AppServerLink does</a>
<a name="ln738">				// implicitly)</a>
<a name="ln739"> </a>
<a name="ln740">			fLink-&gt;StartMessage(AS_CREATE_WINDOW);</a>
<a name="ln741"> </a>
<a name="ln742">			fLink-&gt;Attach&lt;BRect&gt;(fFrame);</a>
<a name="ln743">			fLink-&gt;Attach&lt;uint32&gt;((uint32)fLook);</a>
<a name="ln744">			fLink-&gt;Attach&lt;uint32&gt;((uint32)fFeel);</a>
<a name="ln745">			fLink-&gt;Attach&lt;uint32&gt;(fFlags);</a>
<a name="ln746">			fLink-&gt;Attach&lt;uint32&gt;(0);</a>
<a name="ln747">			fLink-&gt;Attach&lt;int32&gt;(_get_object_token_(this));</a>
<a name="ln748">			fLink-&gt;Attach&lt;port_id&gt;(fLink-&gt;ReceiverPort());</a>
<a name="ln749">			fLink-&gt;Attach&lt;port_id&gt;(fMsgPort);</a>
<a name="ln750">			fLink-&gt;AttachString(fTitle);</a>
<a name="ln751"> </a>
<a name="ln752">			port_id sendPort;</a>
<a name="ln753">			int32 code;</a>
<a name="ln754">			if (fLink-&gt;FlushWithReply(code) == B_OK</a>
<a name="ln755">				&amp;&amp; code == B_OK</a>
<a name="ln756">				&amp;&amp; fLink-&gt;Read&lt;port_id&gt;(&amp;sendPort) == B_OK) {</a>
<a name="ln757">				// read the frame size and its limits that were really</a>
<a name="ln758">				// enforced on the server side</a>
<a name="ln759"> </a>
<a name="ln760">				fLink-&gt;Read&lt;BRect&gt;(&amp;fFrame);</a>
<a name="ln761">				fLink-&gt;Read&lt;float&gt;(&amp;fMinWidth);</a>
<a name="ln762">				fLink-&gt;Read&lt;float&gt;(&amp;fMaxWidth);</a>
<a name="ln763">				fLink-&gt;Read&lt;float&gt;(&amp;fMinHeight);</a>
<a name="ln764">				fLink-&gt;Read&lt;float&gt;(&amp;fMaxHeight);</a>
<a name="ln765"> </a>
<a name="ln766">				fMaxZoomWidth = fMaxWidth;</a>
<a name="ln767">				fMaxZoomHeight = fMaxHeight;</a>
<a name="ln768">			} else</a>
<a name="ln769">				sendPort = -1;</a>
<a name="ln770"> </a>
<a name="ln771">			// Redirect our link to the new window connection</a>
<a name="ln772">			fLink-&gt;SetSenderPort(sendPort);</a>
<a name="ln773"> </a>
<a name="ln774">			// connect all views to the server again</a>
<a name="ln775">			fTopView-&gt;_CreateSelf();</a>
<a name="ln776"> </a>
<a name="ln777">			_SendShowOrHideMessage();</a>
<a name="ln778">		}</a>
<a name="ln779"> </a>
<a name="ln780">		return BLooper::MessageReceived(message);</a>
<a name="ln781">	}</a>
<a name="ln782"> </a>
<a name="ln783">	BMessage replyMsg(B_REPLY);</a>
<a name="ln784">	bool handled = false;</a>
<a name="ln785"> </a>
<a name="ln786">	BMessage specifier;</a>
<a name="ln787">	int32 what;</a>
<a name="ln788">	const char* prop;</a>
<a name="ln789">	int32 index;</a>
<a name="ln790"> </a>
<a name="ln791">	if (message-&gt;GetCurrentSpecifier(&amp;index, &amp;specifier, &amp;what, &amp;prop) != B_OK)</a>
<a name="ln792">		return BLooper::MessageReceived(message);</a>
<a name="ln793"> </a>
<a name="ln794">	BPropertyInfo propertyInfo(sWindowPropInfo);</a>
<a name="ln795">	switch (propertyInfo.FindMatch(message, index, &amp;specifier, what, prop)) {</a>
<a name="ln796">		case 0:</a>
<a name="ln797">			if (message-&gt;what == B_GET_PROPERTY) {</a>
<a name="ln798">				replyMsg.AddBool(&quot;result&quot;, IsActive());</a>
<a name="ln799">				handled = true;</a>
<a name="ln800">			} else if (message-&gt;what == B_SET_PROPERTY) {</a>
<a name="ln801">				bool newActive;</a>
<a name="ln802">				if (message-&gt;FindBool(&quot;data&quot;, &amp;newActive) == B_OK) {</a>
<a name="ln803">					Activate(newActive);</a>
<a name="ln804">					handled = true;</a>
<a name="ln805">				}</a>
<a name="ln806">			}</a>
<a name="ln807">			break;</a>
<a name="ln808">		case 1:</a>
<a name="ln809">			if (message-&gt;what == B_GET_PROPERTY) {</a>
<a name="ln810">				replyMsg.AddInt32(&quot;result&quot;, (uint32)Feel());</a>
<a name="ln811">				handled = true;</a>
<a name="ln812">			} else {</a>
<a name="ln813">				uint32 newFeel;</a>
<a name="ln814">				if (message-&gt;FindInt32(&quot;data&quot;, (int32*)&amp;newFeel) == B_OK) {</a>
<a name="ln815">					SetFeel((window_feel)newFeel);</a>
<a name="ln816">					handled = true;</a>
<a name="ln817">				}</a>
<a name="ln818">			}</a>
<a name="ln819">			break;</a>
<a name="ln820">		case 2:</a>
<a name="ln821">			if (message-&gt;what == B_GET_PROPERTY) {</a>
<a name="ln822">				replyMsg.AddInt32(&quot;result&quot;, Flags());</a>
<a name="ln823">				handled = true;</a>
<a name="ln824">			} else {</a>
<a name="ln825">				uint32 newFlags;</a>
<a name="ln826">				if (message-&gt;FindInt32(&quot;data&quot;, (int32*)&amp;newFlags) == B_OK) {</a>
<a name="ln827">					SetFlags(newFlags);</a>
<a name="ln828">					handled = true;</a>
<a name="ln829">				}</a>
<a name="ln830">			}</a>
<a name="ln831">			break;</a>
<a name="ln832">		case 3:</a>
<a name="ln833">			if (message-&gt;what == B_GET_PROPERTY) {</a>
<a name="ln834">				replyMsg.AddRect(&quot;result&quot;, Frame());</a>
<a name="ln835">				handled = true;</a>
<a name="ln836">			} else {</a>
<a name="ln837">				BRect newFrame;</a>
<a name="ln838">				if (message-&gt;FindRect(&quot;data&quot;, &amp;newFrame) == B_OK) {</a>
<a name="ln839">					MoveTo(newFrame.LeftTop());</a>
<a name="ln840">					ResizeTo(newFrame.Width(), newFrame.Height());</a>
<a name="ln841">					handled = true;</a>
<a name="ln842">				}</a>
<a name="ln843">			}</a>
<a name="ln844">			break;</a>
<a name="ln845">		case 4:</a>
<a name="ln846">			if (message-&gt;what == B_GET_PROPERTY) {</a>
<a name="ln847">				replyMsg.AddBool(&quot;result&quot;, IsHidden());</a>
<a name="ln848">				handled = true;</a>
<a name="ln849">			} else {</a>
<a name="ln850">				bool hide;</a>
<a name="ln851">				if (message-&gt;FindBool(&quot;data&quot;, &amp;hide) == B_OK) {</a>
<a name="ln852">					if (hide) {</a>
<a name="ln853">						if (!IsHidden())</a>
<a name="ln854">							Hide();</a>
<a name="ln855">					} else if (IsHidden())</a>
<a name="ln856">						Show();</a>
<a name="ln857">					handled = true;</a>
<a name="ln858">				}</a>
<a name="ln859">			}</a>
<a name="ln860">			break;</a>
<a name="ln861">		case 5:</a>
<a name="ln862">			if (message-&gt;what == B_GET_PROPERTY) {</a>
<a name="ln863">				replyMsg.AddInt32(&quot;result&quot;, (uint32)Look());</a>
<a name="ln864">				handled = true;</a>
<a name="ln865">			} else {</a>
<a name="ln866">				uint32 newLook;</a>
<a name="ln867">				if (message-&gt;FindInt32(&quot;data&quot;, (int32*)&amp;newLook) == B_OK) {</a>
<a name="ln868">					SetLook((window_look)newLook);</a>
<a name="ln869">					handled = true;</a>
<a name="ln870">				}</a>
<a name="ln871">			}</a>
<a name="ln872">			break;</a>
<a name="ln873">		case 6:</a>
<a name="ln874">			if (message-&gt;what == B_GET_PROPERTY) {</a>
<a name="ln875">				replyMsg.AddString(&quot;result&quot;, Title());</a>
<a name="ln876">				handled = true;</a>
<a name="ln877">			} else {</a>
<a name="ln878">				const char* newTitle = NULL;</a>
<a name="ln879">				if (message-&gt;FindString(&quot;data&quot;, &amp;newTitle) == B_OK) {</a>
<a name="ln880">					SetTitle(newTitle);</a>
<a name="ln881">					handled = true;</a>
<a name="ln882">				}</a>
<a name="ln883">			}</a>
<a name="ln884">			break;</a>
<a name="ln885">		case 7:</a>
<a name="ln886">			if (message-&gt;what == B_GET_PROPERTY) {</a>
<a name="ln887">				replyMsg.AddInt32( &quot;result&quot;, Workspaces());</a>
<a name="ln888">				handled = true;</a>
<a name="ln889">			} else {</a>
<a name="ln890">				uint32 newWorkspaces;</a>
<a name="ln891">				if (message-&gt;FindInt32(&quot;data&quot;, (int32*)&amp;newWorkspaces) == B_OK) {</a>
<a name="ln892">					SetWorkspaces(newWorkspaces);</a>
<a name="ln893">					handled = true;</a>
<a name="ln894">				}</a>
<a name="ln895">			}</a>
<a name="ln896">			break;</a>
<a name="ln897">		case 11:</a>
<a name="ln898">			if (message-&gt;what == B_GET_PROPERTY) {</a>
<a name="ln899">				replyMsg.AddBool(&quot;result&quot;, IsMinimized());</a>
<a name="ln900">				handled = true;</a>
<a name="ln901">			} else {</a>
<a name="ln902">				bool minimize;</a>
<a name="ln903">				if (message-&gt;FindBool(&quot;data&quot;, &amp;minimize) == B_OK) {</a>
<a name="ln904">					Minimize(minimize);</a>
<a name="ln905">					handled = true;</a>
<a name="ln906">				}</a>
<a name="ln907">			}</a>
<a name="ln908">			break;</a>
<a name="ln909">		case 12:</a>
<a name="ln910">			if (message-&gt;what == B_GET_PROPERTY) {</a>
<a name="ln911">				BMessage settings;</a>
<a name="ln912">				if (GetDecoratorSettings(&amp;settings) == B_OK) {</a>
<a name="ln913">					BRect frame;</a>
<a name="ln914">					if (settings.FindRect(&quot;tab frame&quot;, &amp;frame) == B_OK) {</a>
<a name="ln915">						replyMsg.AddRect(&quot;result&quot;, frame);</a>
<a name="ln916">						handled = true;</a>
<a name="ln917">					}</a>
<a name="ln918">				}</a>
<a name="ln919">			}</a>
<a name="ln920">			break;</a>
<a name="ln921">		default:</a>
<a name="ln922">			return BLooper::MessageReceived(message);</a>
<a name="ln923">	}</a>
<a name="ln924"> </a>
<a name="ln925">	if (handled) {</a>
<a name="ln926">		if (message-&gt;what == B_SET_PROPERTY)</a>
<a name="ln927">			replyMsg.AddInt32(&quot;error&quot;, B_OK);</a>
<a name="ln928">	} else {</a>
<a name="ln929">		replyMsg.what = B_MESSAGE_NOT_UNDERSTOOD;</a>
<a name="ln930">		replyMsg.AddInt32(&quot;error&quot;, B_BAD_SCRIPT_SYNTAX);</a>
<a name="ln931">		replyMsg.AddString(&quot;message&quot;, &quot;Didn't understand the specifier(s)&quot;);</a>
<a name="ln932">	}</a>
<a name="ln933">	message-&gt;SendReply(&amp;replyMsg);</a>
<a name="ln934">}</a>
<a name="ln935"> </a>
<a name="ln936"> </a>
<a name="ln937">void</a>
<a name="ln938">BWindow::DispatchMessage(BMessage* message, BHandler* target)</a>
<a name="ln939">{</a>
<a name="ln940">	if (message == NULL)</a>
<a name="ln941">		return;</a>
<a name="ln942"> </a>
<a name="ln943">	switch (message-&gt;what) {</a>
<a name="ln944">		case B_ZOOM:</a>
<a name="ln945">			Zoom();</a>
<a name="ln946">			break;</a>
<a name="ln947"> </a>
<a name="ln948">		case _MINIMIZE_:</a>
<a name="ln949">			// Used by the minimize shortcut</a>
<a name="ln950">			if ((Flags() &amp; B_NOT_MINIMIZABLE) == 0)</a>
<a name="ln951">				Minimize(true);</a>
<a name="ln952">			break;</a>
<a name="ln953"> </a>
<a name="ln954">		case _ZOOM_:</a>
<a name="ln955">			// Used by the zoom shortcut</a>
<a name="ln956">			if ((Flags() &amp; B_NOT_ZOOMABLE) == 0)</a>
<a name="ln957">				Zoom();</a>
<a name="ln958">			break;</a>
<a name="ln959"> </a>
<a name="ln960">		case _SEND_BEHIND_:</a>
<a name="ln961">			SendBehind(NULL);</a>
<a name="ln962">			break;</a>
<a name="ln963"> </a>
<a name="ln964">		case _SEND_TO_FRONT_:</a>
<a name="ln965">			Activate();</a>
<a name="ln966">			break;</a>
<a name="ln967"> </a>
<a name="ln968">		case B_MINIMIZE:</a>
<a name="ln969">		{</a>
<a name="ln970">			bool minimize;</a>
<a name="ln971">			if (message-&gt;FindBool(&quot;minimize&quot;, &amp;minimize) == B_OK)</a>
<a name="ln972">				Minimize(minimize);</a>
<a name="ln973">			break;</a>
<a name="ln974">		}</a>
<a name="ln975"> </a>
<a name="ln976">		case B_HIDE_APPLICATION:</a>
<a name="ln977">		{</a>
<a name="ln978">			// Hide all applications with the same signature</a>
<a name="ln979">			// (ie. those that are part of the same group to be consistent</a>
<a name="ln980">			// to what the Deskbar shows you).</a>
<a name="ln981">			app_info info;</a>
<a name="ln982">			be_app-&gt;GetAppInfo(&amp;info);</a>
<a name="ln983"> </a>
<a name="ln984">			BList list;</a>
<a name="ln985">			be_roster-&gt;GetAppList(info.signature, &amp;list);</a>
<a name="ln986"> </a>
<a name="ln987">			for (int32 i = 0; i &lt; list.CountItems(); i++) {</a>
<a name="ln988">				do_minimize_team(BRect(), (team_id)(addr_t)list.ItemAt(i),</a>
<a name="ln989">					false);</a>
<a name="ln990">			}</a>
<a name="ln991">			break;</a>
<a name="ln992">		}</a>
<a name="ln993"> </a>
<a name="ln994">		case B_WINDOW_RESIZED:</a>
<a name="ln995">		{</a>
<a name="ln996">			int32 width, height;</a>
<a name="ln997">			if (message-&gt;FindInt32(&quot;width&quot;, &amp;width) == B_OK</a>
<a name="ln998">				&amp;&amp; message-&gt;FindInt32(&quot;height&quot;, &amp;height) == B_OK) {</a>
<a name="ln999">				// combine with pending resize notifications</a>
<a name="ln1000">				BMessage* pendingMessage;</a>
<a name="ln1001">				while ((pendingMessage</a>
<a name="ln1002">						= MessageQueue()-&gt;FindMessage(B_WINDOW_RESIZED, 0))) {</a>
<a name="ln1003">					int32 nextWidth;</a>
<a name="ln1004">					if (pendingMessage-&gt;FindInt32(&quot;width&quot;, &amp;nextWidth) == B_OK)</a>
<a name="ln1005">						width = nextWidth;</a>
<a name="ln1006"> </a>
<a name="ln1007">					int32 nextHeight;</a>
<a name="ln1008">					if (pendingMessage-&gt;FindInt32(&quot;height&quot;, &amp;nextHeight)</a>
<a name="ln1009">							== B_OK) {</a>
<a name="ln1010">						height = nextHeight;</a>
<a name="ln1011">					}</a>
<a name="ln1012"> </a>
<a name="ln1013">					MessageQueue()-&gt;RemoveMessage(pendingMessage);</a>
<a name="ln1014">					delete pendingMessage;</a>
<a name="ln1015">						// this deletes the first *additional* message</a>
<a name="ln1016">						// fCurrentMessage is safe</a>
<a name="ln1017">				}</a>
<a name="ln1018">				if (width != fFrame.Width() || height != fFrame.Height()) {</a>
<a name="ln1019">					// NOTE: we might have already handled the resize</a>
<a name="ln1020">					// in an _UPDATE_ message</a>
<a name="ln1021">					fFrame.right = fFrame.left + width;</a>
<a name="ln1022">					fFrame.bottom = fFrame.top + height;</a>
<a name="ln1023"> </a>
<a name="ln1024">					_AdoptResize();</a>
<a name="ln1025">//					FrameResized(width, height);</a>
<a name="ln1026">				}</a>
<a name="ln1027">// call hook function anyways</a>
<a name="ln1028">// TODO: When a window is resized programmatically,</a>
<a name="ln1029">// it receives this message, and maybe it is wise to</a>
<a name="ln1030">// keep the asynchronous nature of this process to</a>
<a name="ln1031">// not risk breaking any apps.</a>
<a name="ln1032">FrameResized(width, height);</a>
<a name="ln1033">			}</a>
<a name="ln1034">			break;</a>
<a name="ln1035">		}</a>
<a name="ln1036"> </a>
<a name="ln1037">		case B_WINDOW_MOVED:</a>
<a name="ln1038">		{</a>
<a name="ln1039">			BPoint origin;</a>
<a name="ln1040">			if (message-&gt;FindPoint(&quot;where&quot;, &amp;origin) == B_OK) {</a>
<a name="ln1041">				if (fFrame.LeftTop() != origin) {</a>
<a name="ln1042">					// NOTE: we might have already handled the move</a>
<a name="ln1043">					// in an _UPDATE_ message</a>
<a name="ln1044">					fFrame.OffsetTo(origin);</a>
<a name="ln1045"> </a>
<a name="ln1046">//					FrameMoved(origin);</a>
<a name="ln1047">				}</a>
<a name="ln1048">// call hook function anyways</a>
<a name="ln1049">// TODO: When a window is moved programmatically,</a>
<a name="ln1050">// it receives this message, and maybe it is wise to</a>
<a name="ln1051">// keep the asynchronous nature of this process to</a>
<a name="ln1052">// not risk breaking any apps.</a>
<a name="ln1053">FrameMoved(origin);</a>
<a name="ln1054">			}</a>
<a name="ln1055">			break;</a>
<a name="ln1056">		}</a>
<a name="ln1057"> </a>
<a name="ln1058">		case B_WINDOW_ACTIVATED:</a>
<a name="ln1059">			if (target != this) {</a>
<a name="ln1060">				target-&gt;MessageReceived(message);</a>
<a name="ln1061">				break;</a>
<a name="ln1062">			}</a>
<a name="ln1063"> </a>
<a name="ln1064">			bool active;</a>
<a name="ln1065">			if (message-&gt;FindBool(&quot;active&quot;, &amp;active) != B_OK)</a>
<a name="ln1066">				break;</a>
<a name="ln1067"> </a>
<a name="ln1068">			// find latest activation message</a>
<a name="ln1069"> </a>
<a name="ln1070">			while (true) {</a>
<a name="ln1071">				BMessage* pendingMessage = MessageQueue()-&gt;FindMessage(</a>
<a name="ln1072">					B_WINDOW_ACTIVATED, 0);</a>
<a name="ln1073">				if (pendingMessage == NULL)</a>
<a name="ln1074">					break;</a>
<a name="ln1075"> </a>
<a name="ln1076">				bool nextActive;</a>
<a name="ln1077">				if (pendingMessage-&gt;FindBool(&quot;active&quot;, &amp;nextActive) == B_OK)</a>
<a name="ln1078">					active = nextActive;</a>
<a name="ln1079"> </a>
<a name="ln1080">				MessageQueue()-&gt;RemoveMessage(pendingMessage);</a>
<a name="ln1081">				delete pendingMessage;</a>
<a name="ln1082">			}</a>
<a name="ln1083"> </a>
<a name="ln1084">			if (active != fActive) {</a>
<a name="ln1085">				fActive = active;</a>
<a name="ln1086"> </a>
<a name="ln1087">				WindowActivated(active);</a>
<a name="ln1088"> </a>
<a name="ln1089">				// call hook function 'WindowActivated(bool)' for all</a>
<a name="ln1090">				// views attached to this window.</a>
<a name="ln1091">				fTopView-&gt;_Activate(active);</a>
<a name="ln1092"> </a>
<a name="ln1093">				// we notify the input server if we are gaining or losing focus</a>
<a name="ln1094">				// from a view which has the B_INPUT_METHOD_AWARE on a window</a>
<a name="ln1095">				// activation</a>
<a name="ln1096">				if (!active)</a>
<a name="ln1097">					break;</a>
<a name="ln1098">				bool inputMethodAware = false;</a>
<a name="ln1099">				if (fFocus)</a>
<a name="ln1100">					inputMethodAware = fFocus-&gt;Flags() &amp; B_INPUT_METHOD_AWARE;</a>
<a name="ln1101">				BMessage message(inputMethodAware ? IS_FOCUS_IM_AWARE_VIEW : IS_UNFOCUS_IM_AWARE_VIEW);</a>
<a name="ln1102">				BMessenger messenger(fFocus);</a>
<a name="ln1103">				BMessage reply;</a>
<a name="ln1104">				if (fFocus)</a>
<a name="ln1105">					message.AddMessenger(&quot;view&quot;, messenger);</a>
<a name="ln1106">				_control_input_server_(&amp;message, &amp;reply);</a>
<a name="ln1107">			}</a>
<a name="ln1108">			break;</a>
<a name="ln1109"> </a>
<a name="ln1110">		case B_SCREEN_CHANGED:</a>
<a name="ln1111">			if (target == this) {</a>
<a name="ln1112">				BRect frame;</a>
<a name="ln1113">				uint32 mode;</a>
<a name="ln1114">				if (message-&gt;FindRect(&quot;frame&quot;, &amp;frame) == B_OK</a>
<a name="ln1115">					&amp;&amp; message-&gt;FindInt32(&quot;mode&quot;, (int32*)&amp;mode) == B_OK) {</a>
<a name="ln1116">					// propegate message to child views</a>
<a name="ln1117">					int32 childCount = CountChildren();</a>
<a name="ln1118">					for (int32 i = 0; i &lt; childCount; i++) {</a>
<a name="ln1119">						BView* view = ChildAt(i);</a>
<a name="ln1120">						if (view != NULL)</a>
<a name="ln1121">							view-&gt;MessageReceived(message);</a>
<a name="ln1122">					}</a>
<a name="ln1123">					// call hook method</a>
<a name="ln1124">					ScreenChanged(frame, (color_space)mode);</a>
<a name="ln1125">				}</a>
<a name="ln1126">			} else</a>
<a name="ln1127">				target-&gt;MessageReceived(message);</a>
<a name="ln1128">			break;</a>
<a name="ln1129"> </a>
<a name="ln1130">		case B_WORKSPACE_ACTIVATED:</a>
<a name="ln1131">			if (target == this) {</a>
<a name="ln1132">				uint32 workspace;</a>
<a name="ln1133">				bool active;</a>
<a name="ln1134">				if (message-&gt;FindInt32(&quot;workspace&quot;, (int32*)&amp;workspace) == B_OK</a>
<a name="ln1135">					&amp;&amp; message-&gt;FindBool(&quot;active&quot;, &amp;active) == B_OK)</a>
<a name="ln1136">					WorkspaceActivated(workspace, active);</a>
<a name="ln1137">			} else</a>
<a name="ln1138">				target-&gt;MessageReceived(message);</a>
<a name="ln1139">			break;</a>
<a name="ln1140"> </a>
<a name="ln1141">		case B_WORKSPACES_CHANGED:</a>
<a name="ln1142">			if (target == this) {</a>
<a name="ln1143">				uint32 oldWorkspace, newWorkspace;</a>
<a name="ln1144">				if (message-&gt;FindInt32(&quot;old&quot;, (int32*)&amp;oldWorkspace) == B_OK</a>
<a name="ln1145">					&amp;&amp; message-&gt;FindInt32(&quot;new&quot;, (int32*)&amp;newWorkspace) == B_OK)</a>
<a name="ln1146">					WorkspacesChanged(oldWorkspace, newWorkspace);</a>
<a name="ln1147">			} else</a>
<a name="ln1148">				target-&gt;MessageReceived(message);</a>
<a name="ln1149">			break;</a>
<a name="ln1150"> </a>
<a name="ln1151">		case B_INVALIDATE:</a>
<a name="ln1152">		{</a>
<a name="ln1153">			if (BView* view = dynamic_cast&lt;BView*&gt;(target)) {</a>
<a name="ln1154">				BRect rect;</a>
<a name="ln1155">				if (message-&gt;FindRect(&quot;be:area&quot;, &amp;rect) == B_OK)</a>
<a name="ln1156">					view-&gt;Invalidate(rect);</a>
<a name="ln1157">				else</a>
<a name="ln1158">					view-&gt;Invalidate();</a>
<a name="ln1159">			} else</a>
<a name="ln1160">				target-&gt;MessageReceived(message);</a>
<a name="ln1161">			break;</a>
<a name="ln1162">		}</a>
<a name="ln1163"> </a>
<a name="ln1164">		case B_KEY_DOWN:</a>
<a name="ln1165">		{</a>
<a name="ln1166">			if (!_HandleKeyDown(message)) {</a>
<a name="ln1167">				if (BView* view = dynamic_cast&lt;BView*&gt;(target)) {</a>
<a name="ln1168">					// TODO: cannot use &quot;string&quot; here if we support having</a>
<a name="ln1169">					// different font encoding per view (it's supposed to be</a>
<a name="ln1170">					// converted by _HandleKeyDown() one day)</a>
<a name="ln1171">					const char* string;</a>
<a name="ln1172">					ssize_t bytes;</a>
<a name="ln1173">					if (message-&gt;FindData(&quot;bytes&quot;, B_STRING_TYPE,</a>
<a name="ln1174">						(const void**)&amp;string, &amp;bytes) == B_OK) {</a>
<a name="ln1175">						view-&gt;KeyDown(string, bytes - 1);</a>
<a name="ln1176">					}</a>
<a name="ln1177">				} else</a>
<a name="ln1178">					target-&gt;MessageReceived(message);</a>
<a name="ln1179">			}</a>
<a name="ln1180">			break;</a>
<a name="ln1181">		}</a>
<a name="ln1182"> </a>
<a name="ln1183">		case B_KEY_UP:</a>
<a name="ln1184">		{</a>
<a name="ln1185">			// TODO: same as above</a>
<a name="ln1186">			if (BView* view = dynamic_cast&lt;BView*&gt;(target)) {</a>
<a name="ln1187">				const char* string;</a>
<a name="ln1188">				ssize_t bytes;</a>
<a name="ln1189">				if (message-&gt;FindData(&quot;bytes&quot;, B_STRING_TYPE,</a>
<a name="ln1190">					(const void**)&amp;string, &amp;bytes) == B_OK) {</a>
<a name="ln1191">					view-&gt;KeyUp(string, bytes - 1);</a>
<a name="ln1192">				}</a>
<a name="ln1193">			} else</a>
<a name="ln1194">				target-&gt;MessageReceived(message);</a>
<a name="ln1195">			break;</a>
<a name="ln1196">		}</a>
<a name="ln1197"> </a>
<a name="ln1198">		case B_UNMAPPED_KEY_DOWN:</a>
<a name="ln1199">		{</a>
<a name="ln1200">			if (!_HandleUnmappedKeyDown(message))</a>
<a name="ln1201">				target-&gt;MessageReceived(message);</a>
<a name="ln1202">			break;</a>
<a name="ln1203">		}</a>
<a name="ln1204"> </a>
<a name="ln1205">		case B_MOUSE_DOWN:</a>
<a name="ln1206">		{</a>
<a name="ln1207">			BView* view = dynamic_cast&lt;BView*&gt;(target);</a>
<a name="ln1208"> </a>
<a name="ln1209">			if (view != NULL) {</a>
<a name="ln1210">				BPoint where;</a>
<a name="ln1211">				message-&gt;FindPoint(&quot;be:view_where&quot;, &amp;where);</a>
<a name="ln1212">				view-&gt;MouseDown(where);</a>
<a name="ln1213">			} else</a>
<a name="ln1214">				target-&gt;MessageReceived(message);</a>
<a name="ln1215"> </a>
<a name="ln1216">			break;</a>
<a name="ln1217">		}</a>
<a name="ln1218"> </a>
<a name="ln1219">		case B_MOUSE_UP:</a>
<a name="ln1220">		{</a>
<a name="ln1221">			if (BView* view = dynamic_cast&lt;BView*&gt;(target)) {</a>
<a name="ln1222">				BPoint where;</a>
<a name="ln1223">				message-&gt;FindPoint(&quot;be:view_where&quot;, &amp;where);</a>
<a name="ln1224">				view-&gt;fMouseEventOptions = 0;</a>
<a name="ln1225">				view-&gt;MouseUp(where);</a>
<a name="ln1226">			} else</a>
<a name="ln1227">				target-&gt;MessageReceived(message);</a>
<a name="ln1228"> </a>
<a name="ln1229">			break;</a>
<a name="ln1230">		}</a>
<a name="ln1231"> </a>
<a name="ln1232">		case B_MOUSE_MOVED:</a>
<a name="ln1233">		{</a>
<a name="ln1234">			if (BView* view = dynamic_cast&lt;BView*&gt;(target)) {</a>
<a name="ln1235">				uint32 eventOptions = view-&gt;fEventOptions</a>
<a name="ln1236">					| view-&gt;fMouseEventOptions;</a>
<a name="ln1237">				bool noHistory = eventOptions &amp; B_NO_POINTER_HISTORY;</a>
<a name="ln1238">				bool dropIfLate = !(eventOptions &amp; B_FULL_POINTER_HISTORY);</a>
<a name="ln1239"> </a>
<a name="ln1240">				bigtime_t eventTime;</a>
<a name="ln1241">				if (message-&gt;FindInt64(&quot;when&quot;, (int64*)&amp;eventTime) &lt; B_OK)</a>
<a name="ln1242">					eventTime = system_time();</a>
<a name="ln1243"> </a>
<a name="ln1244">				uint32 transit;</a>
<a name="ln1245">				message-&gt;FindInt32(&quot;be:transit&quot;, (int32*)&amp;transit);</a>
<a name="ln1246">				// don't drop late messages with these important transit values</a>
<a name="ln1247">				if (transit == B_ENTERED_VIEW || transit == B_EXITED_VIEW)</a>
<a name="ln1248">					dropIfLate = false;</a>
<a name="ln1249"> </a>
<a name="ln1250">				// TODO: The dropping code may have the following problem:</a>
<a name="ln1251">				// On slower computers, 20ms may just be to abitious a delay.</a>
<a name="ln1252">				// There, we might constantly check the message queue for a</a>
<a name="ln1253">				// newer message, not find any, and still use the only but</a>
<a name="ln1254">				// later than 20ms message, which of course makes the whole</a>
<a name="ln1255">				// thing later than need be. An adaptive delay would be</a>
<a name="ln1256">				// kind of neat, but would probably use additional BWindow</a>
<a name="ln1257">				// members to count the successful versus fruitless queue</a>
<a name="ln1258">				// searches and the delay value itself or something similar.</a>
<a name="ln1259"> </a>
<a name="ln1260">				if (noHistory</a>
<a name="ln1261">					|| (dropIfLate &amp;&amp; (system_time() - eventTime &gt; 20000))) {</a>
<a name="ln1262">					// filter out older mouse moved messages in the queue</a>
<a name="ln1263">					_DequeueAll();</a>
<a name="ln1264">					BMessageQueue* queue = MessageQueue();</a>
<a name="ln1265">					queue-&gt;Lock();</a>
<a name="ln1266"> </a>
<a name="ln1267">					BMessage* moved;</a>
<a name="ln1268">					for (int32 i = 0; (moved = queue-&gt;FindMessage(i)) != NULL;</a>
<a name="ln1269">							i++) {</a>
<a name="ln1270">						if (moved != message &amp;&amp; moved-&gt;what == B_MOUSE_MOVED) {</a>
<a name="ln1271">							// there is a newer mouse moved message in the</a>
<a name="ln1272">							// queue, just ignore the current one, the newer one</a>
<a name="ln1273">							// will be handled here eventually</a>
<a name="ln1274">							queue-&gt;Unlock();</a>
<a name="ln1275">							return;</a>
<a name="ln1276">						}</a>
<a name="ln1277">					}</a>
<a name="ln1278">					queue-&gt;Unlock();</a>
<a name="ln1279">				}</a>
<a name="ln1280"> </a>
<a name="ln1281">				BPoint where;</a>
<a name="ln1282">				uint32 buttons;</a>
<a name="ln1283">				message-&gt;FindPoint(&quot;be:view_where&quot;, &amp;where);</a>
<a name="ln1284">				message-&gt;FindInt32(&quot;buttons&quot;, (int32*)&amp;buttons);</a>
<a name="ln1285"> </a>
<a name="ln1286">				if (transit == B_EXITED_VIEW || transit == B_OUTSIDE_VIEW) {</a>
<a name="ln1287">					if (dynamic_cast&lt;BPrivate::ToolTipWindow*&gt;(this) == NULL)</a>
<a name="ln1288">						BToolTipManager::Manager()-&gt;HideTip();</a>
<a name="ln1289">				}</a>
<a name="ln1290"> </a>
<a name="ln1291">				BMessage* dragMessage = NULL;</a>
<a name="ln1292">				if (message-&gt;HasMessage(&quot;be:drag_message&quot;)) {</a>
<a name="ln1293">					dragMessage = new BMessage();</a>
<a name="ln1294">					if (message-&gt;FindMessage(&quot;be:drag_message&quot;, dragMessage)</a>
<a name="ln1295">							!= B_OK) {</a>
<a name="ln1296">						delete dragMessage;</a>
<a name="ln1297">						dragMessage = NULL;</a>
<a name="ln1298">					}</a>
<a name="ln1299">				}</a>
<a name="ln1300"> </a>
<a name="ln1301">				view-&gt;MouseMoved(where, transit, dragMessage);</a>
<a name="ln1302">				delete dragMessage;</a>
<a name="ln1303">			} else</a>
<a name="ln1304">				target-&gt;MessageReceived(message);</a>
<a name="ln1305"> </a>
<a name="ln1306">			break;</a>
<a name="ln1307">		}</a>
<a name="ln1308"> </a>
<a name="ln1309">		case B_PULSE:</a>
<a name="ln1310">			if (target == this &amp;&amp; fPulseRunner) {</a>
<a name="ln1311">				fTopView-&gt;_Pulse();</a>
<a name="ln1312">				fLink-&gt;Flush();</a>
<a name="ln1313">			} else</a>
<a name="ln1314">				target-&gt;MessageReceived(message);</a>
<a name="ln1315">			break;</a>
<a name="ln1316"> </a>
<a name="ln1317">		case _UPDATE_:</a>
<a name="ln1318">		{</a>
<a name="ln1319">//bigtime_t now = system_time();</a>
<a name="ln1320">//bigtime_t drawTime = 0;</a>
<a name="ln1321">			STRACE((&quot;info:BWindow handling _UPDATE_.\n&quot;));</a>
<a name="ln1322"> </a>
<a name="ln1323">			fLink-&gt;StartMessage(AS_BEGIN_UPDATE);</a>
<a name="ln1324">			fInTransaction = true;</a>
<a name="ln1325"> </a>
<a name="ln1326">			int32 code;</a>
<a name="ln1327">			if (fLink-&gt;FlushWithReply(code) == B_OK</a>
<a name="ln1328">				&amp;&amp; code == B_OK) {</a>
<a name="ln1329">				// read current window position and size first,</a>
<a name="ln1330">				// the update rect is in screen coordinates...</a>
<a name="ln1331">				// so we need to be up to date</a>
<a name="ln1332">				BPoint origin;</a>
<a name="ln1333">				fLink-&gt;Read&lt;BPoint&gt;(&amp;origin);</a>
<a name="ln1334">				float width;</a>
<a name="ln1335">				float height;</a>
<a name="ln1336">				fLink-&gt;Read&lt;float&gt;(&amp;width);</a>
<a name="ln1337">				fLink-&gt;Read&lt;float&gt;(&amp;height);</a>
<a name="ln1338">				if (origin != fFrame.LeftTop()) {</a>
<a name="ln1339">					// TODO: remove code duplicatation with</a>
<a name="ln1340">					// B_WINDOW_MOVED case...</a>
<a name="ln1341">					//printf(&quot;window position was not up to date\n&quot;);</a>
<a name="ln1342">					fFrame.OffsetTo(origin);</a>
<a name="ln1343">					FrameMoved(origin);</a>
<a name="ln1344">				}</a>
<a name="ln1345">				if (width != fFrame.Width() || height != fFrame.Height()) {</a>
<a name="ln1346">					// TODO: remove code duplicatation with</a>
<a name="ln1347">					// B_WINDOW_RESIZED case...</a>
<a name="ln1348">					//printf(&quot;window size was not up to date\n&quot;);</a>
<a name="ln1349">					fFrame.right = fFrame.left + width;</a>
<a name="ln1350">					fFrame.bottom = fFrame.top + height;</a>
<a name="ln1351"> </a>
<a name="ln1352">					_AdoptResize();</a>
<a name="ln1353">					FrameResized(width, height);</a>
<a name="ln1354">				}</a>
<a name="ln1355"> </a>
<a name="ln1356">				// read tokens for views that need to be drawn</a>
<a name="ln1357">				// NOTE: we need to read the tokens completely</a>
<a name="ln1358">				// first, we cannot draw views in between reading</a>
<a name="ln1359">				// the tokens, since other communication would likely</a>
<a name="ln1360">				// mess up the data in the link.</a>
<a name="ln1361">				struct ViewUpdateInfo {</a>
<a name="ln1362">					int32 token;</a>
<a name="ln1363">					BRect updateRect;</a>
<a name="ln1364">				};</a>
<a name="ln1365">				BList infos(20);</a>
<a name="ln1366">				while (true) {</a>
<a name="ln1367">					// read next token and create/add ViewUpdateInfo</a>
<a name="ln1368">					int32 token;</a>
<a name="ln1369">					status_t error = fLink-&gt;Read&lt;int32&gt;(&amp;token);</a>
<a name="ln1370">					if (error &lt; B_OK || token == B_NULL_TOKEN)</a>
<a name="ln1371">						break;</a>
<a name="ln1372">					ViewUpdateInfo* info = new(std::nothrow) ViewUpdateInfo;</a>
<a name="ln1373">					if (info == NULL || !infos.AddItem(info)) {</a>
<a name="ln1374">						delete info;</a>
<a name="ln1375">						break;</a>
<a name="ln1376">					}</a>
<a name="ln1377">					info-&gt;token = token;</a>
<a name="ln1378">					// read culmulated update rect (is in screen coords)</a>
<a name="ln1379">					error = fLink-&gt;Read&lt;BRect&gt;(&amp;(info-&gt;updateRect));</a>
<a name="ln1380">					if (error &lt; B_OK)</a>
<a name="ln1381">						break;</a>
<a name="ln1382">				}</a>
<a name="ln1383">				// draw</a>
<a name="ln1384">				int32 count = infos.CountItems();</a>
<a name="ln1385">				for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln1386">//bigtime_t drawStart = system_time();</a>
<a name="ln1387">					ViewUpdateInfo* info</a>
<a name="ln1388">						= (ViewUpdateInfo*)infos.ItemAtFast(i);</a>
<a name="ln1389">					if (BView* view = _FindView(info-&gt;token))</a>
<a name="ln1390">						view-&gt;_Draw(info-&gt;updateRect);</a>
<a name="ln1391">					else {</a>
<a name="ln1392">						printf(&quot;_UPDATE_ - didn't find view by token: %&quot;</a>
<a name="ln1393">							B_PRId32 &quot;\n&quot;, info-&gt;token);</a>
<a name="ln1394">					}</a>
<a name="ln1395">//drawTime += system_time() - drawStart;</a>
<a name="ln1396">				}</a>
<a name="ln1397">				// NOTE: The tokens are actually hirachically sorted,</a>
<a name="ln1398">				// so traversing the list in revers and calling</a>
<a name="ln1399">				// child-&gt;_DrawAfterChildren() actually works like intended.</a>
<a name="ln1400">				for (int32 i = count - 1; i &gt;= 0; i--) {</a>
<a name="ln1401">					ViewUpdateInfo* info</a>
<a name="ln1402">						= (ViewUpdateInfo*)infos.ItemAtFast(i);</a>
<a name="ln1403">					if (BView* view = _FindView(info-&gt;token))</a>
<a name="ln1404">						view-&gt;_DrawAfterChildren(info-&gt;updateRect);</a>
<a name="ln1405">					delete info;</a>
<a name="ln1406">				}</a>
<a name="ln1407"> </a>
<a name="ln1408">//printf(&quot;  %ld views drawn, total Draw() time: %lld\n&quot;, count, drawTime);</a>
<a name="ln1409">			}</a>
<a name="ln1410"> </a>
<a name="ln1411">			fLink-&gt;StartMessage(AS_END_UPDATE);</a>
<a name="ln1412">			fLink-&gt;Flush();</a>
<a name="ln1413">			fInTransaction = false;</a>
<a name="ln1414">			fUpdateRequested = false;</a>
<a name="ln1415"> </a>
<a name="ln1416">//printf(&quot;BWindow(%s) - UPDATE took %lld usecs\n&quot;, Title(), system_time() - now);</a>
<a name="ln1417">			break;</a>
<a name="ln1418">		}</a>
<a name="ln1419"> </a>
<a name="ln1420">		case _MENUS_DONE_:</a>
<a name="ln1421">			MenusEnded();</a>
<a name="ln1422">			break;</a>
<a name="ln1423"> </a>
<a name="ln1424">		// These two are obviously some kind of old scripting messages</a>
<a name="ln1425">		// this is NOT an app_server message and we have to be cautious</a>
<a name="ln1426">		case B_WINDOW_MOVE_BY:</a>
<a name="ln1427">		{</a>
<a name="ln1428">			BPoint offset;</a>
<a name="ln1429">			if (message-&gt;FindPoint(&quot;data&quot;, &amp;offset) == B_OK)</a>
<a name="ln1430">				MoveBy(offset.x, offset.y);</a>
<a name="ln1431">			else</a>
<a name="ln1432">				message-&gt;SendReply(B_MESSAGE_NOT_UNDERSTOOD);</a>
<a name="ln1433">			break;</a>
<a name="ln1434">		}</a>
<a name="ln1435"> </a>
<a name="ln1436">		// this is NOT an app_server message and we have to be cautious</a>
<a name="ln1437">		case B_WINDOW_MOVE_TO:</a>
<a name="ln1438">		{</a>
<a name="ln1439">			BPoint origin;</a>
<a name="ln1440">			if (message-&gt;FindPoint(&quot;data&quot;, &amp;origin) == B_OK)</a>
<a name="ln1441">				MoveTo(origin);</a>
<a name="ln1442">			else</a>
<a name="ln1443">				message-&gt;SendReply(B_MESSAGE_NOT_UNDERSTOOD);</a>
<a name="ln1444">			break;</a>
<a name="ln1445">		}</a>
<a name="ln1446"> </a>
<a name="ln1447">		case B_LAYOUT_WINDOW:</a>
<a name="ln1448">		{</a>
<a name="ln1449">			Layout(false);</a>
<a name="ln1450">			break;</a>
<a name="ln1451">		}</a>
<a name="ln1452"> </a>
<a name="ln1453">		case B_COLORS_UPDATED:</a>
<a name="ln1454">		{</a>
<a name="ln1455">			fTopView-&gt;_ColorsUpdated(message);</a>
<a name="ln1456">			target-&gt;MessageReceived(message);</a>
<a name="ln1457">			break;</a>
<a name="ln1458">		}</a>
<a name="ln1459"> </a>
<a name="ln1460">		case B_FONTS_UPDATED:</a>
<a name="ln1461">		{</a>
<a name="ln1462">			fTopView-&gt;_FontsUpdated(message);</a>
<a name="ln1463">			target-&gt;MessageReceived(message);</a>
<a name="ln1464">			break;</a>
<a name="ln1465">		}</a>
<a name="ln1466"> </a>
<a name="ln1467">		default:</a>
<a name="ln1468">			BLooper::DispatchMessage(message, target);</a>
<a name="ln1469">			break;</a>
<a name="ln1470">	}</a>
<a name="ln1471">}</a>
<a name="ln1472"> </a>
<a name="ln1473"> </a>
<a name="ln1474">void</a>
<a name="ln1475">BWindow::FrameMoved(BPoint newPosition)</a>
<a name="ln1476">{</a>
<a name="ln1477">	// does nothing</a>
<a name="ln1478">	// Hook function</a>
<a name="ln1479">}</a>
<a name="ln1480"> </a>
<a name="ln1481"> </a>
<a name="ln1482">void</a>
<a name="ln1483">BWindow::FrameResized(float newWidth, float newHeight)</a>
<a name="ln1484">{</a>
<a name="ln1485">	// does nothing</a>
<a name="ln1486">	// Hook function</a>
<a name="ln1487">}</a>
<a name="ln1488"> </a>
<a name="ln1489"> </a>
<a name="ln1490">void</a>
<a name="ln1491">BWindow::WorkspacesChanged(uint32 oldWorkspaces, uint32 newWorkspaces)</a>
<a name="ln1492">{</a>
<a name="ln1493">	// does nothing</a>
<a name="ln1494">	// Hook function</a>
<a name="ln1495">}</a>
<a name="ln1496"> </a>
<a name="ln1497"> </a>
<a name="ln1498">void</a>
<a name="ln1499">BWindow::WorkspaceActivated(int32 workspace, bool state)</a>
<a name="ln1500">{</a>
<a name="ln1501">	// does nothing</a>
<a name="ln1502">	// Hook function</a>
<a name="ln1503">}</a>
<a name="ln1504"> </a>
<a name="ln1505"> </a>
<a name="ln1506">void</a>
<a name="ln1507">BWindow::MenusBeginning()</a>
<a name="ln1508">{</a>
<a name="ln1509">	// does nothing</a>
<a name="ln1510">	// Hook function</a>
<a name="ln1511">}</a>
<a name="ln1512"> </a>
<a name="ln1513"> </a>
<a name="ln1514">void</a>
<a name="ln1515">BWindow::MenusEnded()</a>
<a name="ln1516">{</a>
<a name="ln1517">	// does nothing</a>
<a name="ln1518">	// Hook function</a>
<a name="ln1519">}</a>
<a name="ln1520"> </a>
<a name="ln1521"> </a>
<a name="ln1522">void</a>
<a name="ln1523">BWindow::SetSizeLimits(float minWidth, float maxWidth,</a>
<a name="ln1524">	float minHeight, float maxHeight)</a>
<a name="ln1525">{</a>
<a name="ln1526">	if (minWidth &gt; maxWidth || minHeight &gt; maxHeight)</a>
<a name="ln1527">		return;</a>
<a name="ln1528"> </a>
<a name="ln1529">	if (!Lock())</a>
<a name="ln1530">		return;</a>
<a name="ln1531"> </a>
<a name="ln1532">	fLink-&gt;StartMessage(AS_SET_SIZE_LIMITS);</a>
<a name="ln1533">	fLink-&gt;Attach&lt;float&gt;(minWidth);</a>
<a name="ln1534">	fLink-&gt;Attach&lt;float&gt;(maxWidth);</a>
<a name="ln1535">	fLink-&gt;Attach&lt;float&gt;(minHeight);</a>
<a name="ln1536">	fLink-&gt;Attach&lt;float&gt;(maxHeight);</a>
<a name="ln1537"> </a>
<a name="ln1538">	int32 code;</a>
<a name="ln1539">	if (fLink-&gt;FlushWithReply(code) == B_OK</a>
<a name="ln1540">		&amp;&amp; code == B_OK) {</a>
<a name="ln1541">		// read the values that were really enforced on</a>
<a name="ln1542">		// the server side (the window frame could have</a>
<a name="ln1543">		// been changed, too)</a>
<a name="ln1544">		fLink-&gt;Read&lt;BRect&gt;(&amp;fFrame);</a>
<a name="ln1545">		fLink-&gt;Read&lt;float&gt;(&amp;fMinWidth);</a>
<a name="ln1546">		fLink-&gt;Read&lt;float&gt;(&amp;fMaxWidth);</a>
<a name="ln1547">		fLink-&gt;Read&lt;float&gt;(&amp;fMinHeight);</a>
<a name="ln1548">		fLink-&gt;Read&lt;float&gt;(&amp;fMaxHeight);</a>
<a name="ln1549"> </a>
<a name="ln1550">		_AdoptResize();</a>
<a name="ln1551">			// TODO: the same has to be done for SetLook() (that can alter</a>
<a name="ln1552">			//		the size limits, and hence, the size of the window</a>
<a name="ln1553">	}</a>
<a name="ln1554">	Unlock();</a>
<a name="ln1555">}</a>
<a name="ln1556"> </a>
<a name="ln1557"> </a>
<a name="ln1558">void</a>
<a name="ln1559">BWindow::GetSizeLimits(float* _minWidth, float* _maxWidth, float* _minHeight,</a>
<a name="ln1560">	float* _maxHeight)</a>
<a name="ln1561">{</a>
<a name="ln1562">	// TODO: What about locking?!?</a>
<a name="ln1563">	if (_minHeight != NULL)</a>
<a name="ln1564">		*_minHeight = fMinHeight;</a>
<a name="ln1565">	if (_minWidth != NULL)</a>
<a name="ln1566">		*_minWidth = fMinWidth;</a>
<a name="ln1567">	if (_maxHeight != NULL)</a>
<a name="ln1568">		*_maxHeight = fMaxHeight;</a>
<a name="ln1569">	if (_maxWidth != NULL)</a>
<a name="ln1570">		*_maxWidth = fMaxWidth;</a>
<a name="ln1571">}</a>
<a name="ln1572"> </a>
<a name="ln1573"> </a>
<a name="ln1574">void</a>
<a name="ln1575">BWindow::UpdateSizeLimits()</a>
<a name="ln1576">{</a>
<a name="ln1577">	BAutolock locker(this);</a>
<a name="ln1578"> </a>
<a name="ln1579">	if ((fFlags &amp; B_AUTO_UPDATE_SIZE_LIMITS) != 0) {</a>
<a name="ln1580">		// Get min/max constraints of the top view and enforce window</a>
<a name="ln1581">		// size limits respectively.</a>
<a name="ln1582">		BSize minSize = fTopView-&gt;MinSize();</a>
<a name="ln1583">		BSize maxSize = fTopView-&gt;MaxSize();</a>
<a name="ln1584">		SetSizeLimits(minSize.width, maxSize.width,</a>
<a name="ln1585">			minSize.height, maxSize.height);</a>
<a name="ln1586">	}</a>
<a name="ln1587">}</a>
<a name="ln1588"> </a>
<a name="ln1589"> </a>
<a name="ln1590">status_t</a>
<a name="ln1591">BWindow::SetDecoratorSettings(const BMessage&amp; settings)</a>
<a name="ln1592">{</a>
<a name="ln1593">	// flatten the given settings into a buffer and send</a>
<a name="ln1594">	// it to the app_server to apply the settings to the</a>
<a name="ln1595">	// decorator</a>
<a name="ln1596"> </a>
<a name="ln1597">	int32 size = settings.FlattenedSize();</a>
<a name="ln1598">	char buffer[size];</a>
<a name="ln1599">	status_t status = settings.Flatten(buffer, size);</a>
<a name="ln1600">	if (status != B_OK)</a>
<a name="ln1601">		return status;</a>
<a name="ln1602"> </a>
<a name="ln1603">	if (!Lock())</a>
<a name="ln1604">		return B_ERROR;</a>
<a name="ln1605"> </a>
<a name="ln1606">	status = fLink-&gt;StartMessage(AS_SET_DECORATOR_SETTINGS);</a>
<a name="ln1607"> </a>
<a name="ln1608">	if (status == B_OK)</a>
<a name="ln1609">		status = fLink-&gt;Attach&lt;int32&gt;(size);</a>
<a name="ln1610"> </a>
<a name="ln1611">	if (status == B_OK)</a>
<a name="ln1612">		status = fLink-&gt;Attach(buffer, size);</a>
<a name="ln1613"> </a>
<a name="ln1614">	if (status == B_OK)</a>
<a name="ln1615">		status = fLink-&gt;Flush();</a>
<a name="ln1616"> </a>
<a name="ln1617">	Unlock();</a>
<a name="ln1618"> </a>
<a name="ln1619">	return status;</a>
<a name="ln1620">}</a>
<a name="ln1621"> </a>
<a name="ln1622"> </a>
<a name="ln1623">status_t</a>
<a name="ln1624">BWindow::GetDecoratorSettings(BMessage* settings) const</a>
<a name="ln1625">{</a>
<a name="ln1626">	// read a flattened settings message from the app_server</a>
<a name="ln1627">	// and put it into settings</a>
<a name="ln1628"> </a>
<a name="ln1629">	if (!const_cast&lt;BWindow*&gt;(this)-&gt;Lock())</a>
<a name="ln1630">		return B_ERROR;</a>
<a name="ln1631"> </a>
<a name="ln1632">	status_t status = fLink-&gt;StartMessage(AS_GET_DECORATOR_SETTINGS);</a>
<a name="ln1633"> </a>
<a name="ln1634">	if (status == B_OK) {</a>
<a name="ln1635">		int32 code;</a>
<a name="ln1636">		status = fLink-&gt;FlushWithReply(code);</a>
<a name="ln1637">		if (status == B_OK &amp;&amp; code != B_OK)</a>
<a name="ln1638">			status = code;</a>
<a name="ln1639">	}</a>
<a name="ln1640"> </a>
<a name="ln1641">	if (status == B_OK) {</a>
<a name="ln1642">		int32 size;</a>
<a name="ln1643">		status = fLink-&gt;Read&lt;int32&gt;(&amp;size);</a>
<a name="ln1644">		if (status == B_OK) {</a>
<a name="ln1645">			char buffer[size];</a>
<a name="ln1646">			status = fLink-&gt;Read(buffer, size);</a>
<a name="ln1647">			if (status == B_OK) {</a>
<a name="ln1648">				status = settings-&gt;Unflatten(buffer);</a>
<a name="ln1649">			}</a>
<a name="ln1650">		}</a>
<a name="ln1651">	}</a>
<a name="ln1652"> </a>
<a name="ln1653">	const_cast&lt;BWindow*&gt;(this)-&gt;Unlock();</a>
<a name="ln1654"> </a>
<a name="ln1655">	return status;</a>
<a name="ln1656">}</a>
<a name="ln1657"> </a>
<a name="ln1658"> </a>
<a name="ln1659">void</a>
<a name="ln1660">BWindow::SetZoomLimits(float maxWidth, float maxHeight)</a>
<a name="ln1661">{</a>
<a name="ln1662">	// TODO: What about locking?!?</a>
<a name="ln1663">	if (maxWidth &gt; fMaxWidth)</a>
<a name="ln1664">		maxWidth = fMaxWidth;</a>
<a name="ln1665">	else</a>
<a name="ln1666">		fMaxZoomWidth = maxWidth;</a>
<a name="ln1667"> </a>
<a name="ln1668">	if (maxHeight &gt; fMaxHeight)</a>
<a name="ln1669">		maxHeight = fMaxHeight;</a>
<a name="ln1670">	else</a>
<a name="ln1671">		fMaxZoomHeight = maxHeight;</a>
<a name="ln1672">}</a>
<a name="ln1673"> </a>
<a name="ln1674"> </a>
<a name="ln1675">void</a>
<a name="ln1676">BWindow::Zoom(BPoint origin, float width, float height)</a>
<a name="ln1677">{</a>
<a name="ln1678">	// the default implementation of this hook function</a>
<a name="ln1679">	// just does the obvious:</a>
<a name="ln1680">	MoveTo(origin);</a>
<a name="ln1681">	ResizeTo(width, height);</a>
<a name="ln1682">}</a>
<a name="ln1683"> </a>
<a name="ln1684"> </a>
<a name="ln1685">void</a>
<a name="ln1686">BWindow::Zoom()</a>
<a name="ln1687">{</a>
<a name="ln1688">	// TODO: What about locking?!?</a>
<a name="ln1689"> </a>
<a name="ln1690">	// From BeBook:</a>
<a name="ln1691">	// The dimensions that non-virtual Zoom() passes to hook Zoom() are deduced</a>
<a name="ln1692">	// from the smallest of three rectangles:</a>
<a name="ln1693"> </a>
<a name="ln1694">	// 1) the rectangle defined by SetZoomLimits() and,</a>
<a name="ln1695">	// 2) the rectangle defined by SetSizeLimits()</a>
<a name="ln1696">	float maxZoomWidth = std::min(fMaxZoomWidth, fMaxWidth);</a>
<a name="ln1697">	float maxZoomHeight = std::min(fMaxZoomHeight, fMaxHeight);</a>
<a name="ln1698"> </a>
<a name="ln1699">	// 3) the screen rectangle</a>
<a name="ln1700">	BRect screenFrame = (BScreen(this)).Frame();</a>
<a name="ln1701">	maxZoomWidth = std::min(maxZoomWidth, screenFrame.Width());</a>
<a name="ln1702">	maxZoomHeight = std::min(maxZoomHeight, screenFrame.Height());</a>
<a name="ln1703"> </a>
<a name="ln1704">	BRect zoomArea = screenFrame; // starts at screen size</a>
<a name="ln1705"> </a>
<a name="ln1706">	BDeskbar deskbar;</a>
<a name="ln1707">	BRect deskbarFrame = deskbar.Frame();</a>
<a name="ln1708">	bool isShiftDown = (modifiers() &amp; B_SHIFT_KEY) != 0;</a>
<a name="ln1709">	if (!isShiftDown &amp;&amp; !deskbar.IsAutoHide()) {</a>
<a name="ln1710">		// remove area taken up by Deskbar unless hidden or shift is held down</a>
<a name="ln1711">		switch (deskbar.Location()) {</a>
<a name="ln1712">			case B_DESKBAR_TOP:</a>
<a name="ln1713">				zoomArea.top = deskbarFrame.bottom + 2;</a>
<a name="ln1714">				break;</a>
<a name="ln1715"> </a>
<a name="ln1716">			case B_DESKBAR_BOTTOM:</a>
<a name="ln1717">				zoomArea.bottom = deskbarFrame.top - 2;</a>
<a name="ln1718">				break;</a>
<a name="ln1719"> </a>
<a name="ln1720">			// in vertical mode, only if not always on top and not auto-raise</a>
<a name="ln1721">			case B_DESKBAR_LEFT_TOP:</a>
<a name="ln1722">			case B_DESKBAR_LEFT_BOTTOM:</a>
<a name="ln1723">				if (!deskbar.IsAlwaysOnTop() &amp;&amp; !deskbar.IsAutoRaise())</a>
<a name="ln1724">					zoomArea.left = deskbarFrame.right + 2;</a>
<a name="ln1725">				break;</a>
<a name="ln1726"> </a>
<a name="ln1727">			default:</a>
<a name="ln1728">			case B_DESKBAR_RIGHT_TOP:</a>
<a name="ln1729">			case B_DESKBAR_RIGHT_BOTTOM:</a>
<a name="ln1730">				if (!deskbar.IsAlwaysOnTop() &amp;&amp; !deskbar.IsAutoRaise())</a>
<a name="ln1731">					zoomArea.right = deskbarFrame.left - 2;</a>
<a name="ln1732">				break;</a>
<a name="ln1733">		}</a>
<a name="ln1734">	}</a>
<a name="ln1735"> </a>
<a name="ln1736">	// TODO: Broken for tab on left side windows...</a>
<a name="ln1737">	float borderWidth;</a>
<a name="ln1738">	float tabHeight;</a>
<a name="ln1739">	_GetDecoratorSize(&amp;borderWidth, &amp;tabHeight);</a>
<a name="ln1740"> </a>
<a name="ln1741">	// remove the area taken up by the tab and border</a>
<a name="ln1742">	zoomArea.left += borderWidth;</a>
<a name="ln1743">	zoomArea.top += borderWidth + tabHeight;</a>
<a name="ln1744">	zoomArea.right -= borderWidth;</a>
<a name="ln1745">	zoomArea.bottom -= borderWidth;</a>
<a name="ln1746"> </a>
<a name="ln1747">	// inset towards center vertically first to see if there will be room</a>
<a name="ln1748">	// above or below Deskbar</a>
<a name="ln1749">	if (zoomArea.Height() &gt; maxZoomHeight)</a>
<a name="ln1750">		zoomArea.InsetBy(0, roundf((zoomArea.Height() - maxZoomHeight) / 2));</a>
<a name="ln1751"> </a>
<a name="ln1752">	if (zoomArea.top &gt; deskbarFrame.bottom</a>
<a name="ln1753">		|| zoomArea.bottom &lt; deskbarFrame.top) {</a>
<a name="ln1754">		// there is room above or below Deskbar, start from screen width</a>
<a name="ln1755">		// minus borders instead of desktop width minus borders</a>
<a name="ln1756">		zoomArea.left = screenFrame.left + borderWidth;</a>
<a name="ln1757">		zoomArea.right = screenFrame.right - borderWidth;</a>
<a name="ln1758">	}</a>
<a name="ln1759"> </a>
<a name="ln1760">	// inset towards center</a>
<a name="ln1761">	if (zoomArea.Width() &gt; maxZoomWidth)</a>
<a name="ln1762">		zoomArea.InsetBy(roundf((zoomArea.Width() - maxZoomWidth) / 2), 0);</a>
<a name="ln1763"> </a>
<a name="ln1764">	// Un-Zoom</a>
<a name="ln1765"> </a>
<a name="ln1766">	if (fPreviousFrame.IsValid()</a>
<a name="ln1767">		// NOTE: don't check for fFrame.LeftTop() == zoomArea.LeftTop()</a>
<a name="ln1768">		// -&gt; makes it easier on the user to get a window back into place</a>
<a name="ln1769">		&amp;&amp; fFrame.Width() == zoomArea.Width()</a>
<a name="ln1770">		&amp;&amp; fFrame.Height() == zoomArea.Height()) {</a>
<a name="ln1771">		// already zoomed!</a>
<a name="ln1772">		Zoom(fPreviousFrame.LeftTop(), fPreviousFrame.Width(),</a>
<a name="ln1773">			fPreviousFrame.Height());</a>
<a name="ln1774">		return;</a>
<a name="ln1775">	}</a>
<a name="ln1776"> </a>
<a name="ln1777">	// Zoom</a>
<a name="ln1778"> </a>
<a name="ln1779">	// remember fFrame for later &quot;unzooming&quot;</a>
<a name="ln1780">	fPreviousFrame = fFrame;</a>
<a name="ln1781"> </a>
<a name="ln1782">	Zoom(zoomArea.LeftTop(), zoomArea.Width(), zoomArea.Height());</a>
<a name="ln1783">}</a>
<a name="ln1784"> </a>
<a name="ln1785"> </a>
<a name="ln1786">void</a>
<a name="ln1787">BWindow::ScreenChanged(BRect screenSize, color_space depth)</a>
<a name="ln1788">{</a>
<a name="ln1789">	// Hook function</a>
<a name="ln1790">}</a>
<a name="ln1791"> </a>
<a name="ln1792"> </a>
<a name="ln1793">void</a>
<a name="ln1794">BWindow::SetPulseRate(bigtime_t rate)</a>
<a name="ln1795">{</a>
<a name="ln1796">	// TODO: What about locking?!?</a>
<a name="ln1797">	if (rate &lt; 0</a>
<a name="ln1798">		|| (rate == fPulseRate &amp;&amp; !((rate == 0) ^ (fPulseRunner == NULL))))</a>
<a name="ln1799">		return;</a>
<a name="ln1800"> </a>
<a name="ln1801">	fPulseRate = rate;</a>
<a name="ln1802"> </a>
<a name="ln1803">	if (rate &gt; 0) {</a>
<a name="ln1804">		if (fPulseRunner == NULL) {</a>
<a name="ln1805">			BMessage message(B_PULSE);</a>
<a name="ln1806">			fPulseRunner = new(std::nothrow) BMessageRunner(BMessenger(this),</a>
<a name="ln1807">				&amp;message, rate);</a>
<a name="ln1808">		} else {</a>
<a name="ln1809">			fPulseRunner-&gt;SetInterval(rate);</a>
<a name="ln1810">		}</a>
<a name="ln1811">	} else {</a>
<a name="ln1812">		// rate == 0</a>
<a name="ln1813">		delete fPulseRunner;</a>
<a name="ln1814">		fPulseRunner = NULL;</a>
<a name="ln1815">	}</a>
<a name="ln1816">}</a>
<a name="ln1817"> </a>
<a name="ln1818"> </a>
<a name="ln1819">bigtime_t</a>
<a name="ln1820">BWindow::PulseRate() const</a>
<a name="ln1821">{</a>
<a name="ln1822">	return fPulseRate;</a>
<a name="ln1823">}</a>
<a name="ln1824"> </a>
<a name="ln1825"> </a>
<a name="ln1826">void</a>
<a name="ln1827">BWindow::AddShortcut(uint32 key, uint32 modifiers, BMenuItem* item)</a>
<a name="ln1828">{</a>
<a name="ln1829">	Shortcut* shortcut = new(std::nothrow) Shortcut(key, modifiers, item);</a>
<a name="ln1830">	if (shortcut == NULL)</a>
<a name="ln1831">		return;</a>
<a name="ln1832"> </a>
<a name="ln1833">	// removes the shortcut if it already exists!</a>
<a name="ln1834">	RemoveShortcut(key, modifiers);</a>
<a name="ln1835"> </a>
<a name="ln1836">	fShortcuts.AddItem(shortcut);</a>
<a name="ln1837">}</a>
<a name="ln1838"> </a>
<a name="ln1839"> </a>
<a name="ln1840">void</a>
<a name="ln1841">BWindow::AddShortcut(uint32 key, uint32 modifiers, BMessage* message)</a>
<a name="ln1842">{</a>
<a name="ln1843">	AddShortcut(key, modifiers, message, this);</a>
<a name="ln1844">}</a>
<a name="ln1845"> </a>
<a name="ln1846"> </a>
<a name="ln1847">void</a>
<a name="ln1848">BWindow::AddShortcut(uint32 key, uint32 modifiers, BMessage* message,</a>
<a name="ln1849">	BHandler* target)</a>
<a name="ln1850">{</a>
<a name="ln1851">	if (message == NULL)</a>
<a name="ln1852">		return;</a>
<a name="ln1853"> </a>
<a name="ln1854">	Shortcut* shortcut = new(std::nothrow) Shortcut(key, modifiers, message,</a>
<a name="ln1855">		target);</a>
<a name="ln1856">	if (shortcut == NULL)</a>
<a name="ln1857">		return;</a>
<a name="ln1858"> </a>
<a name="ln1859">	// removes the shortcut if it already exists!</a>
<a name="ln1860">	RemoveShortcut(key, modifiers);</a>
<a name="ln1861"> </a>
<a name="ln1862">	fShortcuts.AddItem(shortcut);</a>
<a name="ln1863">}</a>
<a name="ln1864"> </a>
<a name="ln1865"> </a>
<a name="ln1866">bool</a>
<a name="ln1867">BWindow::HasShortcut(uint32 key, uint32 modifiers)</a>
<a name="ln1868">{</a>
<a name="ln1869">	return _FindShortcut(key, modifiers) != NULL;</a>
<a name="ln1870">}</a>
<a name="ln1871"> </a>
<a name="ln1872"> </a>
<a name="ln1873">void</a>
<a name="ln1874">BWindow::RemoveShortcut(uint32 key, uint32 modifiers)</a>
<a name="ln1875">{</a>
<a name="ln1876">	Shortcut* shortcut = _FindShortcut(key, modifiers);</a>
<a name="ln1877">	if (shortcut != NULL) {</a>
<a name="ln1878">		fShortcuts.RemoveItem(shortcut);</a>
<a name="ln1879">		delete shortcut;</a>
<a name="ln1880">	} else if ((key == 'q' || key == 'Q') &amp;&amp; modifiers == B_COMMAND_KEY) {</a>
<a name="ln1881">		// the quit shortcut is a fake shortcut</a>
<a name="ln1882">		fNoQuitShortcut = true;</a>
<a name="ln1883">	}</a>
<a name="ln1884">}</a>
<a name="ln1885"> </a>
<a name="ln1886"> </a>
<a name="ln1887">BButton*</a>
<a name="ln1888">BWindow::DefaultButton() const</a>
<a name="ln1889">{</a>
<a name="ln1890">	// TODO: What about locking?!?</a>
<a name="ln1891">	return fDefaultButton;</a>
<a name="ln1892">}</a>
<a name="ln1893"> </a>
<a name="ln1894"> </a>
<a name="ln1895">void</a>
<a name="ln1896">BWindow::SetDefaultButton(BButton* button)</a>
<a name="ln1897">{</a>
<a name="ln1898">	// TODO: What about locking?!?</a>
<a name="ln1899">	if (fDefaultButton == button)</a>
<a name="ln1900">		return;</a>
<a name="ln1901"> </a>
<a name="ln1902">	if (fDefaultButton != NULL) {</a>
<a name="ln1903">		// tell old button it's no longer the default one</a>
<a name="ln1904">		BButton* oldDefault = fDefaultButton;</a>
<a name="ln1905">		oldDefault-&gt;MakeDefault(false);</a>
<a name="ln1906">		oldDefault-&gt;Invalidate();</a>
<a name="ln1907">	}</a>
<a name="ln1908"> </a>
<a name="ln1909">	fDefaultButton = button;</a>
<a name="ln1910"> </a>
<a name="ln1911">	if (button != NULL) {</a>
<a name="ln1912">		// notify new default button</a>
<a name="ln1913">		fDefaultButton-&gt;MakeDefault(true);</a>
<a name="ln1914">		fDefaultButton-&gt;Invalidate();</a>
<a name="ln1915">	}</a>
<a name="ln1916">}</a>
<a name="ln1917"> </a>
<a name="ln1918"> </a>
<a name="ln1919">bool</a>
<a name="ln1920">BWindow::NeedsUpdate() const</a>
<a name="ln1921">{</a>
<a name="ln1922">	if (!const_cast&lt;BWindow*&gt;(this)-&gt;Lock())</a>
<a name="ln1923">		return false;</a>
<a name="ln1924"> </a>
<a name="ln1925">	fLink-&gt;StartMessage(AS_NEEDS_UPDATE);</a>
<a name="ln1926"> </a>
<a name="ln1927">	int32 code = B_ERROR;</a>
<a name="ln1928">	fLink-&gt;FlushWithReply(code);</a>
<a name="ln1929"> </a>
<a name="ln1930">	const_cast&lt;BWindow*&gt;(this)-&gt;Unlock();</a>
<a name="ln1931"> </a>
<a name="ln1932">	return code == B_OK;</a>
<a name="ln1933">}</a>
<a name="ln1934"> </a>
<a name="ln1935"> </a>
<a name="ln1936">void</a>
<a name="ln1937">BWindow::UpdateIfNeeded()</a>
<a name="ln1938">{</a>
<a name="ln1939">	// works only from the window thread</a>
<a name="ln1940">	if (find_thread(NULL) != Thread())</a>
<a name="ln1941">		return;</a>
<a name="ln1942"> </a>
<a name="ln1943">	// if the queue is already locked we are called recursivly</a>
<a name="ln1944">	// from our own dispatched update message</a>
<a name="ln1945">	if (((const BMessageQueue*)MessageQueue())-&gt;IsLocked())</a>
<a name="ln1946">		return;</a>
<a name="ln1947"> </a>
<a name="ln1948">	if (!Lock())</a>
<a name="ln1949">		return;</a>
<a name="ln1950"> </a>
<a name="ln1951">	// make sure all requests that would cause an update have</a>
<a name="ln1952">	// arrived at the server</a>
<a name="ln1953">	Sync();</a>
<a name="ln1954"> </a>
<a name="ln1955">	// Since we're blocking the event loop, we need to retrieve</a>
<a name="ln1956">	// all messages that are pending on the port.</a>
<a name="ln1957">	_DequeueAll();</a>
<a name="ln1958"> </a>
<a name="ln1959">	BMessageQueue* queue = MessageQueue();</a>
<a name="ln1960"> </a>
<a name="ln1961">	// First process and remove any _UPDATE_ message in the queue</a>
<a name="ln1962">	// With the current design, there can only be one at a time</a>
<a name="ln1963"> </a>
<a name="ln1964">	while (true) {</a>
<a name="ln1965">		queue-&gt;Lock();</a>
<a name="ln1966"> </a>
<a name="ln1967">		BMessage* message = queue-&gt;FindMessage(_UPDATE_, 0);</a>
<a name="ln1968">		queue-&gt;RemoveMessage(message);</a>
<a name="ln1969"> </a>
<a name="ln1970">		queue-&gt;Unlock();</a>
<a name="ln1971"> </a>
<a name="ln1972">		if (message == NULL)</a>
<a name="ln1973">			break;</a>
<a name="ln1974"> </a>
<a name="ln1975">		BWindow::DispatchMessage(message, this);</a>
<a name="ln1976">		delete message;</a>
<a name="ln1977">	}</a>
<a name="ln1978"> </a>
<a name="ln1979">	Unlock();</a>
<a name="ln1980">}</a>
<a name="ln1981"> </a>
<a name="ln1982"> </a>
<a name="ln1983">BView*</a>
<a name="ln1984">BWindow::FindView(const char* viewName) const</a>
<a name="ln1985">{</a>
<a name="ln1986">	BAutolock locker(const_cast&lt;BWindow*&gt;(this));</a>
<a name="ln1987">	if (!locker.IsLocked())</a>
<a name="ln1988">		return NULL;</a>
<a name="ln1989"> </a>
<a name="ln1990">	return fTopView-&gt;FindView(viewName);</a>
<a name="ln1991">}</a>
<a name="ln1992"> </a>
<a name="ln1993"> </a>
<a name="ln1994">BView*</a>
<a name="ln1995">BWindow::FindView(BPoint point) const</a>
<a name="ln1996">{</a>
<a name="ln1997">	BAutolock locker(const_cast&lt;BWindow*&gt;(this));</a>
<a name="ln1998">	if (!locker.IsLocked())</a>
<a name="ln1999">		return NULL;</a>
<a name="ln2000"> </a>
<a name="ln2001">	// point is assumed to be in window coordinates,</a>
<a name="ln2002">	// fTopView has same bounds as window</a>
<a name="ln2003">	return _FindView(fTopView, point);</a>
<a name="ln2004">}</a>
<a name="ln2005"> </a>
<a name="ln2006"> </a>
<a name="ln2007">BView*</a>
<a name="ln2008">BWindow::CurrentFocus() const</a>
<a name="ln2009">{</a>
<a name="ln2010">	return fFocus;</a>
<a name="ln2011">}</a>
<a name="ln2012"> </a>
<a name="ln2013"> </a>
<a name="ln2014">void</a>
<a name="ln2015">BWindow::Activate(bool active)</a>
<a name="ln2016">{</a>
<a name="ln2017">	if (!Lock())</a>
<a name="ln2018">		return;</a>
<a name="ln2019"> </a>
<a name="ln2020">	if (!IsHidden()) {</a>
<a name="ln2021">		fMinimized = false;</a>
<a name="ln2022">			// activating a window will also unminimize it</a>
<a name="ln2023"> </a>
<a name="ln2024">		fLink-&gt;StartMessage(AS_ACTIVATE_WINDOW);</a>
<a name="ln2025">		fLink-&gt;Attach&lt;bool&gt;(active);</a>
<a name="ln2026">		fLink-&gt;Flush();</a>
<a name="ln2027">	}</a>
<a name="ln2028"> </a>
<a name="ln2029">	Unlock();</a>
<a name="ln2030">}</a>
<a name="ln2031"> </a>
<a name="ln2032"> </a>
<a name="ln2033">void</a>
<a name="ln2034">BWindow::WindowActivated(bool focus)</a>
<a name="ln2035">{</a>
<a name="ln2036">	// hook function</a>
<a name="ln2037">	// does nothing</a>
<a name="ln2038">}</a>
<a name="ln2039"> </a>
<a name="ln2040"> </a>
<a name="ln2041">void</a>
<a name="ln2042">BWindow::ConvertToScreen(BPoint* point) const</a>
<a name="ln2043">{</a>
<a name="ln2044">	point-&gt;x += fFrame.left;</a>
<a name="ln2045">	point-&gt;y += fFrame.top;</a>
<a name="ln2046">}</a>
<a name="ln2047"> </a>
<a name="ln2048"> </a>
<a name="ln2049">BPoint</a>
<a name="ln2050">BWindow::ConvertToScreen(BPoint point) const</a>
<a name="ln2051">{</a>
<a name="ln2052">	return point + fFrame.LeftTop();</a>
<a name="ln2053">}</a>
<a name="ln2054"> </a>
<a name="ln2055"> </a>
<a name="ln2056">void</a>
<a name="ln2057">BWindow::ConvertFromScreen(BPoint* point) const</a>
<a name="ln2058">{</a>
<a name="ln2059">	point-&gt;x -= fFrame.left;</a>
<a name="ln2060">	point-&gt;y -= fFrame.top;</a>
<a name="ln2061">}</a>
<a name="ln2062"> </a>
<a name="ln2063"> </a>
<a name="ln2064">BPoint</a>
<a name="ln2065">BWindow::ConvertFromScreen(BPoint point) const</a>
<a name="ln2066">{</a>
<a name="ln2067">	return point - fFrame.LeftTop();</a>
<a name="ln2068">}</a>
<a name="ln2069"> </a>
<a name="ln2070"> </a>
<a name="ln2071">void</a>
<a name="ln2072">BWindow::ConvertToScreen(BRect* rect) const</a>
<a name="ln2073">{</a>
<a name="ln2074">	rect-&gt;OffsetBy(fFrame.LeftTop());</a>
<a name="ln2075">}</a>
<a name="ln2076"> </a>
<a name="ln2077"> </a>
<a name="ln2078">BRect</a>
<a name="ln2079">BWindow::ConvertToScreen(BRect rect) const</a>
<a name="ln2080">{</a>
<a name="ln2081">	return rect.OffsetByCopy(fFrame.LeftTop());</a>
<a name="ln2082">}</a>
<a name="ln2083"> </a>
<a name="ln2084"> </a>
<a name="ln2085">void</a>
<a name="ln2086">BWindow::ConvertFromScreen(BRect* rect) const</a>
<a name="ln2087">{</a>
<a name="ln2088">	rect-&gt;OffsetBy(-fFrame.left, -fFrame.top);</a>
<a name="ln2089">}</a>
<a name="ln2090"> </a>
<a name="ln2091"> </a>
<a name="ln2092">BRect</a>
<a name="ln2093">BWindow::ConvertFromScreen(BRect rect) const</a>
<a name="ln2094">{</a>
<a name="ln2095">	return rect.OffsetByCopy(-fFrame.left, -fFrame.top);</a>
<a name="ln2096">}</a>
<a name="ln2097"> </a>
<a name="ln2098"> </a>
<a name="ln2099">bool</a>
<a name="ln2100">BWindow::IsMinimized() const</a>
<a name="ln2101">{</a>
<a name="ln2102">	BAutolock locker(const_cast&lt;BWindow*&gt;(this));</a>
<a name="ln2103">	if (!locker.IsLocked())</a>
<a name="ln2104">		return false;</a>
<a name="ln2105"> </a>
<a name="ln2106">	return fMinimized;</a>
<a name="ln2107">}</a>
<a name="ln2108"> </a>
<a name="ln2109"> </a>
<a name="ln2110">BRect</a>
<a name="ln2111">BWindow::Bounds() const</a>
<a name="ln2112">{</a>
<a name="ln2113">	return BRect(0, 0, fFrame.Width(), fFrame.Height());</a>
<a name="ln2114">}</a>
<a name="ln2115"> </a>
<a name="ln2116"> </a>
<a name="ln2117">BRect</a>
<a name="ln2118">BWindow::Frame() const</a>
<a name="ln2119">{</a>
<a name="ln2120">	return fFrame;</a>
<a name="ln2121">}</a>
<a name="ln2122"> </a>
<a name="ln2123"> </a>
<a name="ln2124">BRect</a>
<a name="ln2125">BWindow::DecoratorFrame() const</a>
<a name="ln2126">{</a>
<a name="ln2127">	BRect decoratorFrame(Frame());</a>
<a name="ln2128">	BRect tabRect(0, 0, 0, 0);</a>
<a name="ln2129"> </a>
<a name="ln2130">	float borderWidth = 5.0;</a>
<a name="ln2131"> </a>
<a name="ln2132">	BMessage settings;</a>
<a name="ln2133">	if (GetDecoratorSettings(&amp;settings) == B_OK) {</a>
<a name="ln2134">		settings.FindRect(&quot;tab frame&quot;, &amp;tabRect);</a>
<a name="ln2135">		settings.FindFloat(&quot;border width&quot;, &amp;borderWidth);</a>
<a name="ln2136">	} else {</a>
<a name="ln2137">		// probably no-border window look</a>
<a name="ln2138">		if (fLook == B_NO_BORDER_WINDOW_LOOK)</a>
<a name="ln2139">			borderWidth = 0.f;</a>
<a name="ln2140">		else if (fLook == B_BORDERED_WINDOW_LOOK)</a>
<a name="ln2141">			borderWidth = 1.f;</a>
<a name="ln2142">		// else use fall-back values from above</a>
<a name="ln2143">	}</a>
<a name="ln2144"> </a>
<a name="ln2145">	if (fLook == kLeftTitledWindowLook) {</a>
<a name="ln2146">		decoratorFrame.top -= borderWidth;</a>
<a name="ln2147">		decoratorFrame.left -= borderWidth + tabRect.Width();</a>
<a name="ln2148">		decoratorFrame.right += borderWidth;</a>
<a name="ln2149">		decoratorFrame.bottom += borderWidth;</a>
<a name="ln2150">	} else {</a>
<a name="ln2151">		decoratorFrame.top -= borderWidth + tabRect.Height();</a>
<a name="ln2152">		decoratorFrame.left -= borderWidth;</a>
<a name="ln2153">		decoratorFrame.right += borderWidth;</a>
<a name="ln2154">		decoratorFrame.bottom += borderWidth;</a>
<a name="ln2155">	}</a>
<a name="ln2156"> </a>
<a name="ln2157">	return decoratorFrame;</a>
<a name="ln2158">}</a>
<a name="ln2159"> </a>
<a name="ln2160"> </a>
<a name="ln2161">BSize</a>
<a name="ln2162">BWindow::Size() const</a>
<a name="ln2163">{</a>
<a name="ln2164">	return BSize(fFrame.Width(), fFrame.Height());</a>
<a name="ln2165">}</a>
<a name="ln2166"> </a>
<a name="ln2167"> </a>
<a name="ln2168">const char*</a>
<a name="ln2169">BWindow::Title() const</a>
<a name="ln2170">{</a>
<a name="ln2171">	return fTitle;</a>
<a name="ln2172">}</a>
<a name="ln2173"> </a>
<a name="ln2174"> </a>
<a name="ln2175">void</a>
<a name="ln2176">BWindow::SetTitle(const char* title)</a>
<a name="ln2177">{</a>
<a name="ln2178">	if (title == NULL)</a>
<a name="ln2179">		title = &quot;&quot;;</a>
<a name="ln2180"> </a>
<a name="ln2181">	free(fTitle);</a>
<a name="ln2182">	fTitle = strdup(title);</a>
<a name="ln2183"> </a>
<a name="ln2184">	_SetName(title);</a>
<a name="ln2185"> </a>
<a name="ln2186">	// we notify the app_server so we can actually see the change</a>
<a name="ln2187">	if (Lock()) {</a>
<a name="ln2188">		fLink-&gt;StartMessage(AS_SET_WINDOW_TITLE);</a>
<a name="ln2189">		fLink-&gt;AttachString(fTitle);</a>
<a name="ln2190">		fLink-&gt;Flush();</a>
<a name="ln2191">		Unlock();</a>
<a name="ln2192">	}</a>
<a name="ln2193">}</a>
<a name="ln2194"> </a>
<a name="ln2195"> </a>
<a name="ln2196">bool</a>
<a name="ln2197">BWindow::IsActive() const</a>
<a name="ln2198">{</a>
<a name="ln2199">	return fActive;</a>
<a name="ln2200">}</a>
<a name="ln2201"> </a>
<a name="ln2202"> </a>
<a name="ln2203">void</a>
<a name="ln2204">BWindow::SetKeyMenuBar(BMenuBar* bar)</a>
<a name="ln2205">{</a>
<a name="ln2206">	fKeyMenuBar = bar;</a>
<a name="ln2207">}</a>
<a name="ln2208"> </a>
<a name="ln2209"> </a>
<a name="ln2210">BMenuBar*</a>
<a name="ln2211">BWindow::KeyMenuBar() const</a>
<a name="ln2212">{</a>
<a name="ln2213">	return fKeyMenuBar;</a>
<a name="ln2214">}</a>
<a name="ln2215"> </a>
<a name="ln2216"> </a>
<a name="ln2217">bool</a>
<a name="ln2218">BWindow::IsModal() const</a>
<a name="ln2219">{</a>
<a name="ln2220">	return fFeel == B_MODAL_SUBSET_WINDOW_FEEL</a>
<a name="ln2221">		|| fFeel == B_MODAL_APP_WINDOW_FEEL</a>
<a name="ln2222">		|| fFeel == B_MODAL_ALL_WINDOW_FEEL</a>
<a name="ln2223">		|| fFeel == kMenuWindowFeel;</a>
<a name="ln2224">}</a>
<a name="ln2225"> </a>
<a name="ln2226"> </a>
<a name="ln2227">bool</a>
<a name="ln2228">BWindow::IsFloating() const</a>
<a name="ln2229">{</a>
<a name="ln2230">	return fFeel == B_FLOATING_SUBSET_WINDOW_FEEL</a>
<a name="ln2231">		|| fFeel == B_FLOATING_APP_WINDOW_FEEL</a>
<a name="ln2232">		|| fFeel == B_FLOATING_ALL_WINDOW_FEEL;</a>
<a name="ln2233">}</a>
<a name="ln2234"> </a>
<a name="ln2235"> </a>
<a name="ln2236">status_t</a>
<a name="ln2237">BWindow::AddToSubset(BWindow* window)</a>
<a name="ln2238">{</a>
<a name="ln2239">	if (window == NULL || window-&gt;Feel() != B_NORMAL_WINDOW_FEEL</a>
<a name="ln2240">		|| (fFeel != B_MODAL_SUBSET_WINDOW_FEEL</a>
<a name="ln2241">			&amp;&amp; fFeel != B_FLOATING_SUBSET_WINDOW_FEEL))</a>
<a name="ln2242">		return B_BAD_VALUE;</a>
<a name="ln2243"> </a>
<a name="ln2244">	if (!Lock())</a>
<a name="ln2245">		return B_ERROR;</a>
<a name="ln2246"> </a>
<a name="ln2247">	status_t status = B_ERROR;</a>
<a name="ln2248">	fLink-&gt;StartMessage(AS_ADD_TO_SUBSET);</a>
<a name="ln2249">	fLink-&gt;Attach&lt;int32&gt;(_get_object_token_(window));</a>
<a name="ln2250">	fLink-&gt;FlushWithReply(status);</a>
<a name="ln2251"> </a>
<a name="ln2252">	Unlock();</a>
<a name="ln2253"> </a>
<a name="ln2254">	return status;</a>
<a name="ln2255">}</a>
<a name="ln2256"> </a>
<a name="ln2257"> </a>
<a name="ln2258">status_t</a>
<a name="ln2259">BWindow::RemoveFromSubset(BWindow* window)</a>
<a name="ln2260">{</a>
<a name="ln2261">	if (window == NULL || window-&gt;Feel() != B_NORMAL_WINDOW_FEEL</a>
<a name="ln2262">		|| (fFeel != B_MODAL_SUBSET_WINDOW_FEEL</a>
<a name="ln2263">			&amp;&amp; fFeel != B_FLOATING_SUBSET_WINDOW_FEEL))</a>
<a name="ln2264">		return B_BAD_VALUE;</a>
<a name="ln2265"> </a>
<a name="ln2266">	if (!Lock())</a>
<a name="ln2267">		return B_ERROR;</a>
<a name="ln2268"> </a>
<a name="ln2269">	status_t status = B_ERROR;</a>
<a name="ln2270">	fLink-&gt;StartMessage(AS_REMOVE_FROM_SUBSET);</a>
<a name="ln2271">	fLink-&gt;Attach&lt;int32&gt;(_get_object_token_(window));</a>
<a name="ln2272">	fLink-&gt;FlushWithReply(status);</a>
<a name="ln2273"> </a>
<a name="ln2274">	Unlock();</a>
<a name="ln2275"> </a>
<a name="ln2276">	return status;</a>
<a name="ln2277">}</a>
<a name="ln2278"> </a>
<a name="ln2279"> </a>
<a name="ln2280">status_t</a>
<a name="ln2281">BWindow::Perform(perform_code code, void* _data)</a>
<a name="ln2282">{</a>
<a name="ln2283">	switch (code) {</a>
<a name="ln2284">		case PERFORM_CODE_SET_LAYOUT:</a>
<a name="ln2285">		{</a>
<a name="ln2286">			perform_data_set_layout* data = (perform_data_set_layout*)_data;</a>
<a name="ln2287">			BWindow::SetLayout(data-&gt;layout);</a>
<a name="ln2288">			return B_OK;</a>
<a name="ln2289">}</a>
<a name="ln2290">	}</a>
<a name="ln2291"> </a>
<a name="ln2292">	return BLooper::Perform(code, _data);</a>
<a name="ln2293">}</a>
<a name="ln2294"> </a>
<a name="ln2295"> </a>
<a name="ln2296">status_t</a>
<a name="ln2297">BWindow::SetType(window_type type)</a>
<a name="ln2298">{</a>
<a name="ln2299">	window_look look;</a>
<a name="ln2300">	window_feel feel;</a>
<a name="ln2301">	_DecomposeType(type, &amp;look, &amp;feel);</a>
<a name="ln2302"> </a>
<a name="ln2303">	status_t status = SetLook(look);</a>
<a name="ln2304">	if (status == B_OK)</a>
<a name="ln2305">		status = SetFeel(feel);</a>
<a name="ln2306"> </a>
<a name="ln2307">	return status;</a>
<a name="ln2308">}</a>
<a name="ln2309"> </a>
<a name="ln2310"> </a>
<a name="ln2311">window_type</a>
<a name="ln2312">BWindow::Type() const</a>
<a name="ln2313">{</a>
<a name="ln2314">	return _ComposeType(fLook, fFeel);</a>
<a name="ln2315">}</a>
<a name="ln2316"> </a>
<a name="ln2317"> </a>
<a name="ln2318">status_t</a>
<a name="ln2319">BWindow::SetLook(window_look look)</a>
<a name="ln2320">{</a>
<a name="ln2321">	BAutolock locker(this);</a>
<a name="ln2322">	if (!locker.IsLocked())</a>
<a name="ln2323">		return B_BAD_VALUE;</a>
<a name="ln2324"> </a>
<a name="ln2325">	fLink-&gt;StartMessage(AS_SET_LOOK);</a>
<a name="ln2326">	fLink-&gt;Attach&lt;int32&gt;((int32)look);</a>
<a name="ln2327"> </a>
<a name="ln2328">	status_t status = B_ERROR;</a>
<a name="ln2329">	if (fLink-&gt;FlushWithReply(status) == B_OK &amp;&amp; status == B_OK)</a>
<a name="ln2330">		fLook = look;</a>
<a name="ln2331"> </a>
<a name="ln2332">	// TODO: this could have changed the window size, and thus, we</a>
<a name="ln2333">	//	need to get it from the server (and call _AdoptResize()).</a>
<a name="ln2334"> </a>
<a name="ln2335">	return status;</a>
<a name="ln2336">}</a>
<a name="ln2337"> </a>
<a name="ln2338"> </a>
<a name="ln2339">window_look</a>
<a name="ln2340">BWindow::Look() const</a>
<a name="ln2341">{</a>
<a name="ln2342">	return fLook;</a>
<a name="ln2343">}</a>
<a name="ln2344"> </a>
<a name="ln2345"> </a>
<a name="ln2346">status_t</a>
<a name="ln2347">BWindow::SetFeel(window_feel feel)</a>
<a name="ln2348">{</a>
<a name="ln2349">	BAutolock locker(this);</a>
<a name="ln2350">	if (!locker.IsLocked())</a>
<a name="ln2351">		return B_BAD_VALUE;</a>
<a name="ln2352"> </a>
<a name="ln2353">	fLink-&gt;StartMessage(AS_SET_FEEL);</a>
<a name="ln2354">	fLink-&gt;Attach&lt;int32&gt;((int32)feel);</a>
<a name="ln2355"> </a>
<a name="ln2356">	status_t status = B_ERROR;</a>
<a name="ln2357">	if (fLink-&gt;FlushWithReply(status) == B_OK &amp;&amp; status == B_OK)</a>
<a name="ln2358">		fFeel = feel;</a>
<a name="ln2359"> </a>
<a name="ln2360">	return status;</a>
<a name="ln2361">}</a>
<a name="ln2362"> </a>
<a name="ln2363"> </a>
<a name="ln2364">window_feel</a>
<a name="ln2365">BWindow::Feel() const</a>
<a name="ln2366">{</a>
<a name="ln2367">	return fFeel;</a>
<a name="ln2368">}</a>
<a name="ln2369"> </a>
<a name="ln2370"> </a>
<a name="ln2371">status_t</a>
<a name="ln2372">BWindow::SetFlags(uint32 flags)</a>
<a name="ln2373">{</a>
<a name="ln2374">	BAutolock locker(this);</a>
<a name="ln2375">	if (!locker.IsLocked())</a>
<a name="ln2376">		return B_BAD_VALUE;</a>
<a name="ln2377"> </a>
<a name="ln2378">	fLink-&gt;StartMessage(AS_SET_FLAGS);</a>
<a name="ln2379">	fLink-&gt;Attach&lt;uint32&gt;(flags);</a>
<a name="ln2380"> </a>
<a name="ln2381">	int32 status = B_ERROR;</a>
<a name="ln2382">	if (fLink-&gt;FlushWithReply(status) == B_OK &amp;&amp; status == B_OK)</a>
<a name="ln2383">		fFlags = flags;</a>
<a name="ln2384"> </a>
<a name="ln2385">	return status;</a>
<a name="ln2386">}</a>
<a name="ln2387"> </a>
<a name="ln2388"> </a>
<a name="ln2389">uint32</a>
<a name="ln2390">BWindow::Flags() const</a>
<a name="ln2391">{</a>
<a name="ln2392">	return fFlags;</a>
<a name="ln2393">}</a>
<a name="ln2394"> </a>
<a name="ln2395"> </a>
<a name="ln2396">status_t</a>
<a name="ln2397">BWindow::SetWindowAlignment(window_alignment mode,</a>
<a name="ln2398">	int32 h, int32 hOffset, int32 width, int32 widthOffset,</a>
<a name="ln2399">	int32 v, int32 vOffset, int32 height, int32 heightOffset)</a>
<a name="ln2400">{</a>
<a name="ln2401">	if ((mode &amp; (B_BYTE_ALIGNMENT | B_PIXEL_ALIGNMENT)) == 0</a>
<a name="ln2402">		|| (hOffset &gt;= 0 &amp;&amp; hOffset &lt;= h)</a>
<a name="ln2403">		|| (vOffset &gt;= 0 &amp;&amp; vOffset &lt;= v)</a>
<a name="ln2404">		|| (widthOffset &gt;= 0 &amp;&amp; widthOffset &lt;= width)</a>
<a name="ln2405">		|| (heightOffset &gt;= 0 &amp;&amp; heightOffset &lt;= height))</a>
<a name="ln2406">		return B_BAD_VALUE;</a>
<a name="ln2407"> </a>
<a name="ln2408">	// TODO: test if hOffset = 0 and set it to 1 if true.</a>
<a name="ln2409"> </a>
<a name="ln2410">	if (!Lock())</a>
<a name="ln2411">		return B_ERROR;</a>
<a name="ln2412"> </a>
<a name="ln2413">	fLink-&gt;StartMessage(AS_SET_ALIGNMENT);</a>
<a name="ln2414">	fLink-&gt;Attach&lt;int32&gt;((int32)mode);</a>
<a name="ln2415">	fLink-&gt;Attach&lt;int32&gt;(h);</a>
<a name="ln2416">	fLink-&gt;Attach&lt;int32&gt;(hOffset);</a>
<a name="ln2417">	fLink-&gt;Attach&lt;int32&gt;(width);</a>
<a name="ln2418">	fLink-&gt;Attach&lt;int32&gt;(widthOffset);</a>
<a name="ln2419">	fLink-&gt;Attach&lt;int32&gt;(v);</a>
<a name="ln2420">	fLink-&gt;Attach&lt;int32&gt;(vOffset);</a>
<a name="ln2421">	fLink-&gt;Attach&lt;int32&gt;(height);</a>
<a name="ln2422">	fLink-&gt;Attach&lt;int32&gt;(heightOffset);</a>
<a name="ln2423"> </a>
<a name="ln2424">	status_t status = B_ERROR;</a>
<a name="ln2425">	fLink-&gt;FlushWithReply(status);</a>
<a name="ln2426"> </a>
<a name="ln2427">	Unlock();</a>
<a name="ln2428"> </a>
<a name="ln2429">	return status;</a>
<a name="ln2430">}</a>
<a name="ln2431"> </a>
<a name="ln2432"> </a>
<a name="ln2433">status_t</a>
<a name="ln2434">BWindow::GetWindowAlignment(window_alignment* mode,</a>
<a name="ln2435">	int32* h, int32* hOffset, int32* width, int32* widthOffset,</a>
<a name="ln2436">	int32* v, int32* vOffset, int32* height, int32* heightOffset) const</a>
<a name="ln2437">{</a>
<a name="ln2438">	if (!const_cast&lt;BWindow*&gt;(this)-&gt;Lock())</a>
<a name="ln2439">		return B_ERROR;</a>
<a name="ln2440"> </a>
<a name="ln2441">	fLink-&gt;StartMessage(AS_GET_ALIGNMENT);</a>
<a name="ln2442"> </a>
<a name="ln2443">	status_t status;</a>
<a name="ln2444">	if (fLink-&gt;FlushWithReply(status) == B_OK &amp;&amp; status == B_OK) {</a>
<a name="ln2445">		fLink-&gt;Read&lt;int32&gt;((int32*)mode);</a>
<a name="ln2446">		fLink-&gt;Read&lt;int32&gt;(h);</a>
<a name="ln2447">		fLink-&gt;Read&lt;int32&gt;(hOffset);</a>
<a name="ln2448">		fLink-&gt;Read&lt;int32&gt;(width);</a>
<a name="ln2449">		fLink-&gt;Read&lt;int32&gt;(widthOffset);</a>
<a name="ln2450">		fLink-&gt;Read&lt;int32&gt;(v);</a>
<a name="ln2451">		fLink-&gt;Read&lt;int32&gt;(hOffset);</a>
<a name="ln2452">		fLink-&gt;Read&lt;int32&gt;(height);</a>
<a name="ln2453">		fLink-&gt;Read&lt;int32&gt;(heightOffset);</a>
<a name="ln2454">	}</a>
<a name="ln2455"> </a>
<a name="ln2456">	const_cast&lt;BWindow*&gt;(this)-&gt;Unlock();</a>
<a name="ln2457">	return status;</a>
<a name="ln2458">}</a>
<a name="ln2459"> </a>
<a name="ln2460"> </a>
<a name="ln2461">uint32</a>
<a name="ln2462">BWindow::Workspaces() const</a>
<a name="ln2463">{</a>
<a name="ln2464">	if (!const_cast&lt;BWindow*&gt;(this)-&gt;Lock())</a>
<a name="ln2465">		return 0;</a>
<a name="ln2466"> </a>
<a name="ln2467">	uint32 workspaces = 0;</a>
<a name="ln2468"> </a>
<a name="ln2469">	fLink-&gt;StartMessage(AS_GET_WORKSPACES);</a>
<a name="ln2470"> </a>
<a name="ln2471">	status_t status;</a>
<a name="ln2472">	if (fLink-&gt;FlushWithReply(status) == B_OK &amp;&amp; status == B_OK)</a>
<a name="ln2473">		fLink-&gt;Read&lt;uint32&gt;(&amp;workspaces);</a>
<a name="ln2474"> </a>
<a name="ln2475">	const_cast&lt;BWindow*&gt;(this)-&gt;Unlock();</a>
<a name="ln2476">	return workspaces;</a>
<a name="ln2477">}</a>
<a name="ln2478"> </a>
<a name="ln2479"> </a>
<a name="ln2480">void</a>
<a name="ln2481">BWindow::SetWorkspaces(uint32 workspaces)</a>
<a name="ln2482">{</a>
<a name="ln2483">	// TODO: don't forget about Tracker's background window.</a>
<a name="ln2484">	if (fFeel != B_NORMAL_WINDOW_FEEL)</a>
<a name="ln2485">		return;</a>
<a name="ln2486"> </a>
<a name="ln2487">	if (Lock()) {</a>
<a name="ln2488">		fLink-&gt;StartMessage(AS_SET_WORKSPACES);</a>
<a name="ln2489">		fLink-&gt;Attach&lt;uint32&gt;(workspaces);</a>
<a name="ln2490">		fLink-&gt;Flush();</a>
<a name="ln2491">		Unlock();</a>
<a name="ln2492">	}</a>
<a name="ln2493">}</a>
<a name="ln2494"> </a>
<a name="ln2495"> </a>
<a name="ln2496">BView*</a>
<a name="ln2497">BWindow::LastMouseMovedView() const</a>
<a name="ln2498">{</a>
<a name="ln2499">	return fLastMouseMovedView;</a>
<a name="ln2500">}</a>
<a name="ln2501"> </a>
<a name="ln2502"> </a>
<a name="ln2503">void</a>
<a name="ln2504">BWindow::MoveBy(float dx, float dy)</a>
<a name="ln2505">{</a>
<a name="ln2506">	if ((dx != 0.0f || dy != 0.0f) &amp;&amp; Lock()) {</a>
<a name="ln2507">		MoveTo(fFrame.left + dx, fFrame.top + dy);</a>
<a name="ln2508">		Unlock();</a>
<a name="ln2509">	}</a>
<a name="ln2510">}</a>
<a name="ln2511"> </a>
<a name="ln2512"> </a>
<a name="ln2513">void</a>
<a name="ln2514">BWindow::MoveTo(BPoint point)</a>
<a name="ln2515">{</a>
<a name="ln2516">	MoveTo(point.x, point.y);</a>
<a name="ln2517">}</a>
<a name="ln2518"> </a>
<a name="ln2519"> </a>
<a name="ln2520">void</a>
<a name="ln2521">BWindow::MoveTo(float x, float y)</a>
<a name="ln2522">{</a>
<a name="ln2523">	if (!Lock())</a>
<a name="ln2524">		return;</a>
<a name="ln2525"> </a>
<a name="ln2526">	x = roundf(x);</a>
<a name="ln2527">	y = roundf(y);</a>
<a name="ln2528"> </a>
<a name="ln2529">	if (fFrame.left != x || fFrame.top != y) {</a>
<a name="ln2530">		fLink-&gt;StartMessage(AS_WINDOW_MOVE);</a>
<a name="ln2531">		fLink-&gt;Attach&lt;float&gt;(x);</a>
<a name="ln2532">		fLink-&gt;Attach&lt;float&gt;(y);</a>
<a name="ln2533"> </a>
<a name="ln2534">		status_t status;</a>
<a name="ln2535">		if (fLink-&gt;FlushWithReply(status) == B_OK &amp;&amp; status == B_OK)</a>
<a name="ln2536">			fFrame.OffsetTo(x, y);</a>
<a name="ln2537">	}</a>
<a name="ln2538"> </a>
<a name="ln2539">	Unlock();</a>
<a name="ln2540">}</a>
<a name="ln2541"> </a>
<a name="ln2542"> </a>
<a name="ln2543">void</a>
<a name="ln2544">BWindow::ResizeBy(float dx, float dy)</a>
<a name="ln2545">{</a>
<a name="ln2546">	if (Lock()) {</a>
<a name="ln2547">		ResizeTo(fFrame.Width() + dx, fFrame.Height() + dy);</a>
<a name="ln2548">		Unlock();</a>
<a name="ln2549">	}</a>
<a name="ln2550">}</a>
<a name="ln2551"> </a>
<a name="ln2552"> </a>
<a name="ln2553">void</a>
<a name="ln2554">BWindow::ResizeTo(float width, float height)</a>
<a name="ln2555">{</a>
<a name="ln2556">	if (!Lock())</a>
<a name="ln2557">		return;</a>
<a name="ln2558"> </a>
<a name="ln2559">	width = roundf(width);</a>
<a name="ln2560">	height = roundf(height);</a>
<a name="ln2561"> </a>
<a name="ln2562">	// stay in minimum &amp; maximum frame limits</a>
<a name="ln2563">	if (width &lt; fMinWidth)</a>
<a name="ln2564">		width = fMinWidth;</a>
<a name="ln2565">	else if (width &gt; fMaxWidth)</a>
<a name="ln2566">		width = fMaxWidth;</a>
<a name="ln2567"> </a>
<a name="ln2568">	if (height &lt; fMinHeight)</a>
<a name="ln2569">		height = fMinHeight;</a>
<a name="ln2570">	else if (height &gt; fMaxHeight)</a>
<a name="ln2571">		height = fMaxHeight;</a>
<a name="ln2572"> </a>
<a name="ln2573">	if (width != fFrame.Width() || height != fFrame.Height()) {</a>
<a name="ln2574">		fLink-&gt;StartMessage(AS_WINDOW_RESIZE);</a>
<a name="ln2575">		fLink-&gt;Attach&lt;float&gt;(width);</a>
<a name="ln2576">		fLink-&gt;Attach&lt;float&gt;(height);</a>
<a name="ln2577"> </a>
<a name="ln2578">		status_t status;</a>
<a name="ln2579">		if (fLink-&gt;FlushWithReply(status) == B_OK &amp;&amp; status == B_OK) {</a>
<a name="ln2580">			fFrame.right = fFrame.left + width;</a>
<a name="ln2581">			fFrame.bottom = fFrame.top + height;</a>
<a name="ln2582">			_AdoptResize();</a>
<a name="ln2583">		}</a>
<a name="ln2584">	}</a>
<a name="ln2585"> </a>
<a name="ln2586">	Unlock();</a>
<a name="ln2587">}</a>
<a name="ln2588"> </a>
<a name="ln2589"> </a>
<a name="ln2590">void</a>
<a name="ln2591">BWindow::ResizeToPreferred()</a>
<a name="ln2592">{</a>
<a name="ln2593">	BAutolock locker(this);</a>
<a name="ln2594">	Layout(false);</a>
<a name="ln2595"> </a>
<a name="ln2596">	float width = fTopView-&gt;PreferredSize().width;</a>
<a name="ln2597">	width = std::min(width, fTopView-&gt;MaxSize().width);</a>
<a name="ln2598">	width = std::max(width, fTopView-&gt;MinSize().width);</a>
<a name="ln2599"> </a>
<a name="ln2600">	float height = fTopView-&gt;PreferredSize().height;</a>
<a name="ln2601">	height = std::min(width, fTopView-&gt;MaxSize().height);</a>
<a name="ln2602">	height = std::max(width, fTopView-&gt;MinSize().height);</a>
<a name="ln2603"> </a>
<a name="ln2604">	if (GetLayout()-&gt;HasHeightForWidth())</a>
<a name="ln2605">		GetLayout()-&gt;GetHeightForWidth(width, NULL, NULL, &amp;height);</a>
<a name="ln2606"> </a>
<a name="ln2607">	ResizeTo(width, height);</a>
<a name="ln2608">}</a>
<a name="ln2609"> </a>
<a name="ln2610"> </a>
<a name="ln2611">void</a>
<a name="ln2612">BWindow::CenterIn(const BRect&amp; rect)</a>
<a name="ln2613">{</a>
<a name="ln2614">	BAutolock locker(this);</a>
<a name="ln2615"> </a>
<a name="ln2616">	// Set size limits now if needed</a>
<a name="ln2617">	UpdateSizeLimits();</a>
<a name="ln2618"> </a>
<a name="ln2619">	MoveTo(BLayoutUtils::AlignInFrame(rect, Size(),</a>
<a name="ln2620">		BAlignment(B_ALIGN_HORIZONTAL_CENTER,</a>
<a name="ln2621">			B_ALIGN_VERTICAL_CENTER)).LeftTop());</a>
<a name="ln2622">	MoveOnScreen(B_DO_NOT_RESIZE_TO_FIT | B_MOVE_IF_PARTIALLY_OFFSCREEN);</a>
<a name="ln2623">}</a>
<a name="ln2624"> </a>
<a name="ln2625"> </a>
<a name="ln2626">void</a>
<a name="ln2627">BWindow::CenterOnScreen()</a>
<a name="ln2628">{</a>
<a name="ln2629">	CenterIn(BScreen(this).Frame());</a>
<a name="ln2630">}</a>
<a name="ln2631"> </a>
<a name="ln2632"> </a>
<a name="ln2633">// Centers the window on the screen with the passed in id.</a>
<a name="ln2634">void</a>
<a name="ln2635">BWindow::CenterOnScreen(screen_id id)</a>
<a name="ln2636">{</a>
<a name="ln2637">	CenterIn(BScreen(id).Frame());</a>
<a name="ln2638">}</a>
<a name="ln2639"> </a>
<a name="ln2640"> </a>
<a name="ln2641">void</a>
<a name="ln2642">BWindow::MoveOnScreen(uint32 flags)</a>
<a name="ln2643">{</a>
<a name="ln2644">	// Set size limits now if needed</a>
<a name="ln2645">	UpdateSizeLimits();</a>
<a name="ln2646"> </a>
<a name="ln2647">	BRect screenFrame = BScreen(this).Frame();</a>
<a name="ln2648">	BRect frame = Frame();</a>
<a name="ln2649"> </a>
<a name="ln2650">	float borderWidth;</a>
<a name="ln2651">	float tabHeight;</a>
<a name="ln2652">	_GetDecoratorSize(&amp;borderWidth, &amp;tabHeight);</a>
<a name="ln2653"> </a>
<a name="ln2654">	frame.InsetBy(-borderWidth, -borderWidth);</a>
<a name="ln2655">	frame.top -= tabHeight;</a>
<a name="ln2656"> </a>
<a name="ln2657">	if ((flags &amp; B_DO_NOT_RESIZE_TO_FIT) == 0) {</a>
<a name="ln2658">		// Make sure the window fits on the screen</a>
<a name="ln2659">		if (frame.Width() &gt; screenFrame.Width())</a>
<a name="ln2660">			frame.right -= frame.Width() - screenFrame.Width();</a>
<a name="ln2661">		if (frame.Height() &gt; screenFrame.Height())</a>
<a name="ln2662">			frame.bottom -= frame.Height() - screenFrame.Height();</a>
<a name="ln2663"> </a>
<a name="ln2664">		BRect innerFrame = frame;</a>
<a name="ln2665">		innerFrame.top += tabHeight;</a>
<a name="ln2666">		innerFrame.InsetBy(borderWidth, borderWidth);</a>
<a name="ln2667">		ResizeTo(innerFrame.Width(), innerFrame.Height());</a>
<a name="ln2668">	}</a>
<a name="ln2669"> </a>
<a name="ln2670">	if (((flags &amp; B_MOVE_IF_PARTIALLY_OFFSCREEN) == 0</a>
<a name="ln2671">			&amp;&amp; !screenFrame.Contains(frame))</a>
<a name="ln2672">		|| !frame.Intersects(screenFrame)) {</a>
<a name="ln2673">		// Off and away</a>
<a name="ln2674">		CenterOnScreen();</a>
<a name="ln2675">		return;</a>
<a name="ln2676">	}</a>
<a name="ln2677"> </a>
<a name="ln2678">	// Move such that the upper left corner, and most of the window</a>
<a name="ln2679">	// will be visible.</a>
<a name="ln2680">	float left = frame.left;</a>
<a name="ln2681">	if (left &lt; screenFrame.left)</a>
<a name="ln2682">		left = screenFrame.left;</a>
<a name="ln2683">	else if (frame.right &gt; screenFrame.right)</a>
<a name="ln2684">		left = std::max(0.f, screenFrame.right - frame.Width());</a>
<a name="ln2685"> </a>
<a name="ln2686">	float top = frame.top;</a>
<a name="ln2687">	if (top &lt; screenFrame.top)</a>
<a name="ln2688">		top = screenFrame.top;</a>
<a name="ln2689">	else if (frame.bottom &gt; screenFrame.bottom)</a>
<a name="ln2690">		top = std::max(0.f, screenFrame.bottom - frame.Height());</a>
<a name="ln2691"> </a>
<a name="ln2692">	if (top != frame.top || left != frame.left)</a>
<a name="ln2693">		MoveTo(left + borderWidth, top + tabHeight + borderWidth);</a>
<a name="ln2694">}</a>
<a name="ln2695"> </a>
<a name="ln2696"> </a>
<a name="ln2697">void</a>
<a name="ln2698">BWindow::Show()</a>
<a name="ln2699">{</a>
<a name="ln2700">	bool runCalled = true;</a>
<a name="ln2701">	if (Lock()) {</a>
<a name="ln2702">		fShowLevel--;</a>
<a name="ln2703"> </a>
<a name="ln2704">		_SendShowOrHideMessage();</a>
<a name="ln2705"> </a>
<a name="ln2706">		runCalled = fRunCalled;</a>
<a name="ln2707"> </a>
<a name="ln2708">		Unlock();</a>
<a name="ln2709">	}</a>
<a name="ln2710"> </a>
<a name="ln2711">	if (!runCalled) {</a>
<a name="ln2712">		// This is the fist time Show() is called, which implicitly runs the</a>
<a name="ln2713">		// looper. NOTE: The window is still locked if it has not been</a>
<a name="ln2714">		// run yet, so accessing members is safe.</a>
<a name="ln2715">		if (fLink-&gt;SenderPort() &lt; B_OK) {</a>
<a name="ln2716">			// We don't have valid app_server connection; there is no point</a>
<a name="ln2717">			// in starting our looper</a>
<a name="ln2718">			fThread = B_ERROR;</a>
<a name="ln2719">			return;</a>
<a name="ln2720">		} else</a>
<a name="ln2721">			Run();</a>
<a name="ln2722">	}</a>
<a name="ln2723">}</a>
<a name="ln2724"> </a>
<a name="ln2725"> </a>
<a name="ln2726">void</a>
<a name="ln2727">BWindow::Hide()</a>
<a name="ln2728">{</a>
<a name="ln2729">	if (Lock()) {</a>
<a name="ln2730">		// If we are minimized and are about to be hidden, unminimize</a>
<a name="ln2731">		if (IsMinimized() &amp;&amp; fShowLevel == 0)</a>
<a name="ln2732">			Minimize(false);</a>
<a name="ln2733"> </a>
<a name="ln2734">		fShowLevel++;</a>
<a name="ln2735"> </a>
<a name="ln2736">		_SendShowOrHideMessage();</a>
<a name="ln2737"> </a>
<a name="ln2738">		Unlock();</a>
<a name="ln2739">	}</a>
<a name="ln2740">}</a>
<a name="ln2741"> </a>
<a name="ln2742"> </a>
<a name="ln2743">bool</a>
<a name="ln2744">BWindow::IsHidden() const</a>
<a name="ln2745">{</a>
<a name="ln2746">	return fShowLevel &gt; 0;</a>
<a name="ln2747">}</a>
<a name="ln2748"> </a>
<a name="ln2749"> </a>
<a name="ln2750">bool</a>
<a name="ln2751">BWindow::QuitRequested()</a>
<a name="ln2752">{</a>
<a name="ln2753">	return BLooper::QuitRequested();</a>
<a name="ln2754">}</a>
<a name="ln2755"> </a>
<a name="ln2756"> </a>
<a name="ln2757">thread_id</a>
<a name="ln2758">BWindow::Run()</a>
<a name="ln2759">{</a>
<a name="ln2760">	return BLooper::Run();</a>
<a name="ln2761">}</a>
<a name="ln2762"> </a>
<a name="ln2763"> </a>
<a name="ln2764">void</a>
<a name="ln2765">BWindow::SetLayout(BLayout* layout)</a>
<a name="ln2766">{</a>
<a name="ln2767">	// Adopt layout's colors for fTopView</a>
<a name="ln2768">	if (layout != NULL)</a>
<a name="ln2769">		fTopView-&gt;AdoptViewColors(layout-&gt;View());</a>
<a name="ln2770"> </a>
<a name="ln2771">	fTopView-&gt;SetLayout(layout);</a>
<a name="ln2772">}</a>
<a name="ln2773"> </a>
<a name="ln2774"> </a>
<a name="ln2775">BLayout*</a>
<a name="ln2776">BWindow::GetLayout() const</a>
<a name="ln2777">{</a>
<a name="ln2778">	return fTopView-&gt;GetLayout();</a>
<a name="ln2779">}</a>
<a name="ln2780"> </a>
<a name="ln2781"> </a>
<a name="ln2782">void</a>
<a name="ln2783">BWindow::InvalidateLayout(bool descendants)</a>
<a name="ln2784">{</a>
<a name="ln2785">	fTopView-&gt;InvalidateLayout(descendants);</a>
<a name="ln2786">}</a>
<a name="ln2787"> </a>
<a name="ln2788"> </a>
<a name="ln2789">void</a>
<a name="ln2790">BWindow::Layout(bool force)</a>
<a name="ln2791">{</a>
<a name="ln2792">	UpdateSizeLimits();</a>
<a name="ln2793"> </a>
<a name="ln2794">	// Do the actual layout</a>
<a name="ln2795">	fTopView-&gt;Layout(force);</a>
<a name="ln2796">}</a>
<a name="ln2797"> </a>
<a name="ln2798"> </a>
<a name="ln2799">bool</a>
<a name="ln2800">BWindow::IsOffscreenWindow() const</a>
<a name="ln2801">{</a>
<a name="ln2802">	return fOffscreen;</a>
<a name="ln2803">}</a>
<a name="ln2804"> </a>
<a name="ln2805"> </a>
<a name="ln2806">status_t</a>
<a name="ln2807">BWindow::GetSupportedSuites(BMessage* data)</a>
<a name="ln2808">{</a>
<a name="ln2809">	if (data == NULL)</a>
<a name="ln2810">		return B_BAD_VALUE;</a>
<a name="ln2811"> </a>
<a name="ln2812">	status_t status = data-&gt;AddString(&quot;suites&quot;, &quot;suite/vnd.Be-window&quot;);</a>
<a name="ln2813">	if (status == B_OK) {</a>
<a name="ln2814">		BPropertyInfo propertyInfo(sWindowPropInfo, sWindowValueInfo);</a>
<a name="ln2815"> </a>
<a name="ln2816">		status = data-&gt;AddFlat(&quot;messages&quot;, &amp;propertyInfo);</a>
<a name="ln2817">		if (status == B_OK)</a>
<a name="ln2818">			status = BLooper::GetSupportedSuites(data);</a>
<a name="ln2819">	}</a>
<a name="ln2820"> </a>
<a name="ln2821">	return status;</a>
<a name="ln2822">}</a>
<a name="ln2823"> </a>
<a name="ln2824"> </a>
<a name="ln2825">BHandler*</a>
<a name="ln2826">BWindow::ResolveSpecifier(BMessage* message, int32 index, BMessage* specifier,</a>
<a name="ln2827">	int32 what, const char* property)</a>
<a name="ln2828">{</a>
<a name="ln2829">	if (message-&gt;what == B_WINDOW_MOVE_BY</a>
<a name="ln2830">		|| message-&gt;what == B_WINDOW_MOVE_TO)</a>
<a name="ln2831">		return this;</a>
<a name="ln2832"> </a>
<a name="ln2833">	BPropertyInfo propertyInfo(sWindowPropInfo);</a>
<a name="ln2834">	if (propertyInfo.FindMatch(message, index, specifier, what, property) &gt;= 0) {</a>
<a name="ln2835">		if (strcmp(property, &quot;View&quot;) == 0) {</a>
<a name="ln2836">			// we will NOT pop the current specifier</a>
<a name="ln2837">			return fTopView;</a>
<a name="ln2838">		} else if (strcmp(property, &quot;MenuBar&quot;) == 0) {</a>
<a name="ln2839">			if (fKeyMenuBar) {</a>
<a name="ln2840">				message-&gt;PopSpecifier();</a>
<a name="ln2841">				return fKeyMenuBar;</a>
<a name="ln2842">			} else {</a>
<a name="ln2843">				BMessage replyMsg(B_MESSAGE_NOT_UNDERSTOOD);</a>
<a name="ln2844">				replyMsg.AddInt32(&quot;error&quot;, B_NAME_NOT_FOUND);</a>
<a name="ln2845">				replyMsg.AddString(&quot;message&quot;,</a>
<a name="ln2846">					&quot;This window doesn't have a main MenuBar&quot;);</a>
<a name="ln2847">				message-&gt;SendReply(&amp;replyMsg);</a>
<a name="ln2848">				return NULL;</a>
<a name="ln2849">			}</a>
<a name="ln2850">		} else</a>
<a name="ln2851">			return this;</a>
<a name="ln2852">	}</a>
<a name="ln2853"> </a>
<a name="ln2854">	return BLooper::ResolveSpecifier(message, index, specifier, what, property);</a>
<a name="ln2855">}</a>
<a name="ln2856"> </a>
<a name="ln2857"> </a>
<a name="ln2858">//	#pragma mark - Private Methods</a>
<a name="ln2859"> </a>
<a name="ln2860"> </a>
<a name="ln2861">void</a>
<a name="ln2862">BWindow::_InitData(BRect frame, const char* title, window_look look,</a>
<a name="ln2863">	window_feel feel, uint32 flags,	uint32 workspace, int32 bitmapToken)</a>
<a name="ln2864">{</a>
<a name="ln2865">	STRACE((&quot;BWindow::InitData()\n&quot;));</a>
<a name="ln2866"> </a>
<a name="ln2867">	if (be_app == NULL) {</a>
<a name="ln2868">		debugger(&quot;You need a valid BApplication object before interacting with &quot;</a>
<a name="ln2869">			&quot;the app_server&quot;);</a>
<a name="ln2870">		return;</a>
<a name="ln2871">	}</a>
<a name="ln2872"> </a>
<a name="ln2873">	frame.left = roundf(frame.left);</a>
<a name="ln2874">	frame.top = roundf(frame.top);</a>
<a name="ln2875">	frame.right = roundf(frame.right);</a>
<a name="ln2876">	frame.bottom = roundf(frame.bottom);</a>
<a name="ln2877"> </a>
<a name="ln2878">	fFrame = frame;</a>
<a name="ln2879"> </a>
<a name="ln2880">	if (title == NULL)</a>
<a name="ln2881">		title = &quot;&quot;;</a>
<a name="ln2882"> </a>
<a name="ln2883">	fTitle = strdup(title);</a>
<a name="ln2884"> </a>
<a name="ln2885">	_SetName(title);</a>
<a name="ln2886"> </a>
<a name="ln2887">	fFeel = feel;</a>
<a name="ln2888">	fLook = look;</a>
<a name="ln2889">	fFlags = flags | B_ASYNCHRONOUS_CONTROLS;</a>
<a name="ln2890"> </a>
<a name="ln2891">	fInTransaction = bitmapToken &gt;= 0;</a>
<a name="ln2892">	fUpdateRequested = false;</a>
<a name="ln2893">	fActive = false;</a>
<a name="ln2894">	fShowLevel = 1;</a>
<a name="ln2895"> </a>
<a name="ln2896">	fTopView = NULL;</a>
<a name="ln2897">	fFocus = NULL;</a>
<a name="ln2898">	fLastMouseMovedView	= NULL;</a>
<a name="ln2899">	fKeyMenuBar = NULL;</a>
<a name="ln2900">	fDefaultButton = NULL;</a>
<a name="ln2901"> </a>
<a name="ln2902">	// Shortcut 'Q' is handled in _HandleKeyDown() directly, as its message</a>
<a name="ln2903">	// get sent to the application, and not one of our handlers.</a>
<a name="ln2904">	// It is only installed for non-modal windows, though.</a>
<a name="ln2905">	fNoQuitShortcut = IsModal();</a>
<a name="ln2906"> </a>
<a name="ln2907">	if ((fFlags &amp; B_NOT_CLOSABLE) == 0 &amp;&amp; !IsModal()) {</a>
<a name="ln2908">		// Modal windows default to non-closable, but you can add the</a>
<a name="ln2909">		// shortcut manually, if a different behaviour is wanted</a>
<a name="ln2910">		AddShortcut('W', B_COMMAND_KEY, new BMessage(B_QUIT_REQUESTED));</a>
<a name="ln2911">	}</a>
<a name="ln2912"> </a>
<a name="ln2913">	// Edit modifier keys</a>
<a name="ln2914"> </a>
<a name="ln2915">	AddShortcut('X', B_COMMAND_KEY, new BMessage(B_CUT), NULL);</a>
<a name="ln2916">	AddShortcut('C', B_COMMAND_KEY, new BMessage(B_COPY), NULL);</a>
<a name="ln2917">	AddShortcut('V', B_COMMAND_KEY, new BMessage(B_PASTE), NULL);</a>
<a name="ln2918">	AddShortcut('A', B_COMMAND_KEY, new BMessage(B_SELECT_ALL), NULL);</a>
<a name="ln2919"> </a>
<a name="ln2920">	// Window modifier keys</a>
<a name="ln2921"> </a>
<a name="ln2922">	AddShortcut('M', B_COMMAND_KEY | B_CONTROL_KEY,</a>
<a name="ln2923">		new BMessage(_MINIMIZE_), NULL);</a>
<a name="ln2924">	AddShortcut('Z', B_COMMAND_KEY | B_CONTROL_KEY,</a>
<a name="ln2925">		new BMessage(_ZOOM_), NULL);</a>
<a name="ln2926">	AddShortcut('Z', B_SHIFT_KEY | B_COMMAND_KEY | B_CONTROL_KEY,</a>
<a name="ln2927">		new BMessage(_ZOOM_), NULL);</a>
<a name="ln2928">	AddShortcut('H', B_COMMAND_KEY | B_CONTROL_KEY,</a>
<a name="ln2929">		new BMessage(B_HIDE_APPLICATION), NULL);</a>
<a name="ln2930">	AddShortcut('F', B_COMMAND_KEY | B_CONTROL_KEY,</a>
<a name="ln2931">		new BMessage(_SEND_TO_FRONT_), NULL);</a>
<a name="ln2932">	AddShortcut('B', B_COMMAND_KEY | B_CONTROL_KEY,</a>
<a name="ln2933">		new BMessage(_SEND_BEHIND_), NULL);</a>
<a name="ln2934"> </a>
<a name="ln2935">	// We set the default pulse rate, but we don't start the pulse</a>
<a name="ln2936">	fPulseRate = 500000;</a>
<a name="ln2937">	fPulseRunner = NULL;</a>
<a name="ln2938"> </a>
<a name="ln2939">	fIsFilePanel = false;</a>
<a name="ln2940"> </a>
<a name="ln2941">	fMenuSem = -1;</a>
<a name="ln2942"> </a>
<a name="ln2943">	fMinimized = false;</a>
<a name="ln2944"> </a>
<a name="ln2945">	fMaxZoomHeight = 32768.0;</a>
<a name="ln2946">	fMaxZoomWidth = 32768.0;</a>
<a name="ln2947">	fMinHeight = 0.0;</a>
<a name="ln2948">	fMinWidth = 0.0;</a>
<a name="ln2949">	fMaxHeight = 32768.0;</a>
<a name="ln2950">	fMaxWidth = 32768.0;</a>
<a name="ln2951"> </a>
<a name="ln2952">	fLastViewToken = B_NULL_TOKEN;</a>
<a name="ln2953"> </a>
<a name="ln2954">	// TODO: other initializations!</a>
<a name="ln2955">	fOffscreen = false;</a>
<a name="ln2956"> </a>
<a name="ln2957">	// Create the server-side window</a>
<a name="ln2958"> </a>
<a name="ln2959">	port_id receivePort = create_port(B_LOOPER_PORT_DEFAULT_CAPACITY,</a>
<a name="ln2960">		&quot;w&lt;app_server&quot;);</a>
<a name="ln2961">	if (receivePort &lt; B_OK) {</a>
<a name="ln2962">		// TODO: huh?</a>
<a name="ln2963">		debugger(&quot;Could not create BWindow's receive port, used for &quot;</a>
<a name="ln2964">				 &quot;interacting with the app_server!&quot;);</a>
<a name="ln2965">		delete this;</a>
<a name="ln2966">		return;</a>
<a name="ln2967">	}</a>
<a name="ln2968"> </a>
<a name="ln2969">	STRACE((&quot;BWindow::InitData(): contacting app_server...\n&quot;));</a>
<a name="ln2970"> </a>
<a name="ln2971">	// let app_server know that a window has been created.</a>
<a name="ln2972">	fLink = new(std::nothrow) BPrivate::PortLink(</a>
<a name="ln2973">		BApplication::Private::ServerLink()-&gt;SenderPort(), receivePort);</a>
<a name="ln2974">	if (fLink == NULL) {</a>
<a name="ln2975">		// Zombie!</a>
<a name="ln2976">		return;</a>
<a name="ln2977">	}</a>
<a name="ln2978"> </a>
<a name="ln2979">	{</a>
<a name="ln2980">		BPrivate::AppServerLink lockLink;</a>
<a name="ln2981">			// we're talking to the server application using our own</a>
<a name="ln2982">			// communication channel (fLink) - we better make sure no one</a>
<a name="ln2983">			// interferes by locking that channel (which AppServerLink does</a>
<a name="ln2984">			// implicetly)</a>
<a name="ln2985"> </a>
<a name="ln2986">		if (bitmapToken &lt; 0) {</a>
<a name="ln2987">			fLink-&gt;StartMessage(AS_CREATE_WINDOW);</a>
<a name="ln2988">		} else {</a>
<a name="ln2989">			fLink-&gt;StartMessage(AS_CREATE_OFFSCREEN_WINDOW);</a>
<a name="ln2990">			fLink-&gt;Attach&lt;int32&gt;(bitmapToken);</a>
<a name="ln2991">			fOffscreen = true;</a>
<a name="ln2992">		}</a>
<a name="ln2993"> </a>
<a name="ln2994">		fLink-&gt;Attach&lt;BRect&gt;(fFrame);</a>
<a name="ln2995">		fLink-&gt;Attach&lt;uint32&gt;((uint32)fLook);</a>
<a name="ln2996">		fLink-&gt;Attach&lt;uint32&gt;((uint32)fFeel);</a>
<a name="ln2997">		fLink-&gt;Attach&lt;uint32&gt;(fFlags);</a>
<a name="ln2998">		fLink-&gt;Attach&lt;uint32&gt;(workspace);</a>
<a name="ln2999">		fLink-&gt;Attach&lt;int32&gt;(_get_object_token_(this));</a>
<a name="ln3000">		fLink-&gt;Attach&lt;port_id&gt;(receivePort);</a>
<a name="ln3001">		fLink-&gt;Attach&lt;port_id&gt;(fMsgPort);</a>
<a name="ln3002">		fLink-&gt;AttachString(title);</a>
<a name="ln3003"> </a>
<a name="ln3004">		port_id sendPort;</a>
<a name="ln3005">		int32 code;</a>
<a name="ln3006">		if (fLink-&gt;FlushWithReply(code) == B_OK</a>
<a name="ln3007">			&amp;&amp; code == B_OK</a>
<a name="ln3008">			&amp;&amp; fLink-&gt;Read&lt;port_id&gt;(&amp;sendPort) == B_OK) {</a>
<a name="ln3009">			// read the frame size and its limits that were really</a>
<a name="ln3010">			// enforced on the server side</a>
<a name="ln3011"> </a>
<a name="ln3012">			fLink-&gt;Read&lt;BRect&gt;(&amp;fFrame);</a>
<a name="ln3013">			fLink-&gt;Read&lt;float&gt;(&amp;fMinWidth);</a>
<a name="ln3014">			fLink-&gt;Read&lt;float&gt;(&amp;fMaxWidth);</a>
<a name="ln3015">			fLink-&gt;Read&lt;float&gt;(&amp;fMinHeight);</a>
<a name="ln3016">			fLink-&gt;Read&lt;float&gt;(&amp;fMaxHeight);</a>
<a name="ln3017"> </a>
<a name="ln3018">			fMaxZoomWidth = fMaxWidth;</a>
<a name="ln3019">			fMaxZoomHeight = fMaxHeight;</a>
<a name="ln3020">		} else</a>
<a name="ln3021">			sendPort = -1;</a>
<a name="ln3022"> </a>
<a name="ln3023">		// Redirect our link to the new window connection</a>
<a name="ln3024">		fLink-&gt;SetSenderPort(sendPort);</a>
<a name="ln3025">		STRACE((&quot;Server says that our send port is %ld\n&quot;, sendPort));</a>
<a name="ln3026">	}</a>
<a name="ln3027"> </a>
<a name="ln3028">	STRACE((&quot;Window locked?: %s\n&quot;, IsLocked() ? &quot;True&quot; : &quot;False&quot;));</a>
<a name="ln3029"> </a>
<a name="ln3030">	_CreateTopView();</a>
<a name="ln3031">}</a>
<a name="ln3032"> </a>
<a name="ln3033"> </a>
<a name="ln3034">//! Rename the handler and its thread</a>
<a name="ln3035">void</a>
<a name="ln3036">BWindow::_SetName(const char* title)</a>
<a name="ln3037">{</a>
<a name="ln3038">	if (title == NULL)</a>
<a name="ln3039">		title = &quot;&quot;;</a>
<a name="ln3040"> </a>
<a name="ln3041">	// we will change BWindow's thread name to &quot;w&gt;window title&quot;</a>
<a name="ln3042"> </a>
<a name="ln3043">	char threadName[B_OS_NAME_LENGTH];</a>
<a name="ln3044">	strcpy(threadName, &quot;w&gt;&quot;);</a>
<a name="ln3045">#ifdef __HAIKU__</a>
<a name="ln3046">	strlcat(threadName, title, B_OS_NAME_LENGTH);</a>
<a name="ln3047">#else</a>
<a name="ln3048">	int32 length = strlen(title);</a>
<a name="ln3049">	length = min_c(length, B_OS_NAME_LENGTH - 3);</a>
<a name="ln3050">	memcpy(threadName + 2, title, length);</a>
<a name="ln3051">	threadName[length + 2] = '\0';</a>
<a name="ln3052">#endif</a>
<a name="ln3053"> </a>
<a name="ln3054">	// change the handler's name</a>
<a name="ln3055">	SetName(threadName);</a>
<a name="ln3056"> </a>
<a name="ln3057">	// if the message loop has been started...</a>
<a name="ln3058">	if (Thread() &gt;= B_OK)</a>
<a name="ln3059">		rename_thread(Thread(), threadName);</a>
<a name="ln3060">}</a>
<a name="ln3061"> </a>
<a name="ln3062"> </a>
<a name="ln3063">//!	Reads all pending messages from the window port and put them into the queue.</a>
<a name="ln3064">void</a>
<a name="ln3065">BWindow::_DequeueAll()</a>
<a name="ln3066">{</a>
<a name="ln3067">	//	Get message count from port</a>
<a name="ln3068">	int32 count = port_count(fMsgPort);</a>
<a name="ln3069"> </a>
<a name="ln3070">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln3071">		BMessage* message = MessageFromPort(0);</a>
<a name="ln3072">		if (message != NULL)</a>
<a name="ln3073">			fDirectTarget-&gt;Queue()-&gt;AddMessage(message);</a>
<a name="ln3074">	}</a>
<a name="ln3075">}</a>
<a name="ln3076"> </a>
<a name="ln3077"> </a>
<a name="ln3078">/*!	This here is an almost complete code duplication to BLooper::task_looper()</a>
<a name="ln3079">	but with some important differences:</a>
<a name="ln3080">	 a)	it uses the _DetermineTarget() method to tell what the later target of</a>
<a name="ln3081">		a message will be, if no explicit target is supplied.</a>
<a name="ln3082">	 b)	it calls _UnpackMessage() and _SanitizeMessage() to duplicate the message</a>
<a name="ln3083">		to all of its intended targets, and to add all fields the target would</a>
<a name="ln3084">		expect in such a message.</a>
<a name="ln3085"> </a>
<a name="ln3086">	This is important because the app_server sends all input events to the</a>
<a name="ln3087">	preferred handler, and expects them to be correctly distributed to their</a>
<a name="ln3088">	intended targets.</a>
<a name="ln3089">*/</a>
<a name="ln3090">void</a>
<a name="ln3091">BWindow::task_looper()</a>
<a name="ln3092">{</a>
<a name="ln3093">	STRACE((&quot;info: BWindow::task_looper() started.\n&quot;));</a>
<a name="ln3094"> </a>
<a name="ln3095">	// Check that looper is locked (should be)</a>
<a name="ln3096">	AssertLocked();</a>
<a name="ln3097">	Unlock();</a>
<a name="ln3098"> </a>
<a name="ln3099">	if (IsLocked())</a>
<a name="ln3100">		debugger(&quot;window must not be locked!&quot;);</a>
<a name="ln3101"> </a>
<a name="ln3102">	while (!fTerminating) {</a>
<a name="ln3103">		// Did we get a message?</a>
<a name="ln3104">		BMessage* msg = MessageFromPort();</a>
<a name="ln3105">		if (msg)</a>
<a name="ln3106">			_AddMessagePriv(msg);</a>
<a name="ln3107"> </a>
<a name="ln3108">		//	Get message count from port</a>
<a name="ln3109">		int32 msgCount = port_count(fMsgPort);</a>
<a name="ln3110">		for (int32 i = 0; i &lt; msgCount; ++i) {</a>
<a name="ln3111">			// Read 'count' messages from port (so we will not block)</a>
<a name="ln3112">			// We use zero as our timeout since we know there is stuff there</a>
<a name="ln3113">			msg = MessageFromPort(0);</a>
<a name="ln3114">			// Add messages to queue</a>
<a name="ln3115">			if (msg)</a>
<a name="ln3116">				_AddMessagePriv(msg);</a>
<a name="ln3117">		}</a>
<a name="ln3118"> </a>
<a name="ln3119">		bool dispatchNextMessage = true;</a>
<a name="ln3120">		while (!fTerminating &amp;&amp; dispatchNextMessage) {</a>
<a name="ln3121">			// Get next message from queue (assign to fLastMessage after</a>
<a name="ln3122">			// locking)</a>
<a name="ln3123">			BMessage* message = fDirectTarget-&gt;Queue()-&gt;NextMessage();</a>
<a name="ln3124"> </a>
<a name="ln3125">			// Lock the looper</a>
<a name="ln3126">			if (!Lock()) {</a>
<a name="ln3127">				delete message;</a>
<a name="ln3128">				break;</a>
<a name="ln3129">			}</a>
<a name="ln3130"> </a>
<a name="ln3131">			fLastMessage = message;</a>
<a name="ln3132"> </a>
<a name="ln3133">			if (fLastMessage == NULL) {</a>
<a name="ln3134">				// No more messages: Unlock the looper and terminate the</a>
<a name="ln3135">				// dispatch loop.</a>
<a name="ln3136">				dispatchNextMessage = false;</a>
<a name="ln3137">			} else {</a>
<a name="ln3138">				// Get the target handler</a>
<a name="ln3139">				BMessage::Private messagePrivate(fLastMessage);</a>
<a name="ln3140">				bool usePreferred = messagePrivate.UsePreferredTarget();</a>
<a name="ln3141">				BHandler* handler = NULL;</a>
<a name="ln3142">				bool dropMessage = false;</a>
<a name="ln3143"> </a>
<a name="ln3144">				if (usePreferred) {</a>
<a name="ln3145">					handler = PreferredHandler();</a>
<a name="ln3146">					if (handler == NULL)</a>
<a name="ln3147">						handler = this;</a>
<a name="ln3148">				} else {</a>
<a name="ln3149">					gDefaultTokens.GetToken(messagePrivate.GetTarget(),</a>
<a name="ln3150">						B_HANDLER_TOKEN, (void**)&amp;handler);</a>
<a name="ln3151"> </a>
<a name="ln3152">					// if this handler doesn't belong to us, we drop the message</a>
<a name="ln3153">					if (handler != NULL &amp;&amp; handler-&gt;Looper() != this) {</a>
<a name="ln3154">						dropMessage = true;</a>
<a name="ln3155">						handler = NULL;</a>
<a name="ln3156">					}</a>
<a name="ln3157">				}</a>
<a name="ln3158"> </a>
<a name="ln3159">				if ((handler == NULL &amp;&amp; !dropMessage) || usePreferred)</a>
<a name="ln3160">					handler = _DetermineTarget(fLastMessage, handler);</a>
<a name="ln3161"> </a>
<a name="ln3162">				unpack_cookie cookie;</a>
<a name="ln3163">				while (_UnpackMessage(cookie, &amp;fLastMessage, &amp;handler, &amp;usePreferred)) {</a>
<a name="ln3164">					// if there is no target handler, the message is dropped</a>
<a name="ln3165">					if (handler != NULL) {</a>
<a name="ln3166">						_SanitizeMessage(fLastMessage, handler, usePreferred);</a>
<a name="ln3167"> </a>
<a name="ln3168">						// Is this a scripting message?</a>
<a name="ln3169">						if (fLastMessage-&gt;HasSpecifiers()) {</a>
<a name="ln3170">							int32 index = 0;</a>
<a name="ln3171">							// Make sure the current specifier is kosher</a>
<a name="ln3172">							if (fLastMessage-&gt;GetCurrentSpecifier(&amp;index) == B_OK)</a>
<a name="ln3173">								handler = resolve_specifier(handler, fLastMessage);</a>
<a name="ln3174">						}</a>
<a name="ln3175"> </a>
<a name="ln3176">						if (handler != NULL)</a>
<a name="ln3177">							handler = _TopLevelFilter(fLastMessage, handler);</a>
<a name="ln3178"> </a>
<a name="ln3179">						if (handler != NULL)</a>
<a name="ln3180">							DispatchMessage(fLastMessage, handler);</a>
<a name="ln3181">					}</a>
<a name="ln3182"> </a>
<a name="ln3183">					// Delete the current message</a>
<a name="ln3184">					delete fLastMessage;</a>
<a name="ln3185">					fLastMessage = NULL;</a>
<a name="ln3186">				}</a>
<a name="ln3187">			}</a>
<a name="ln3188"> </a>
<a name="ln3189">			if (fTerminating) {</a>
<a name="ln3190">				// we leave the looper locked when we quit</a>
<a name="ln3191">				return;</a>
<a name="ln3192">			}</a>
<a name="ln3193"> </a>
<a name="ln3194">			Unlock();</a>
<a name="ln3195"> </a>
<a name="ln3196">			// Are any messages on the port?</a>
<a name="ln3197">			if (port_count(fMsgPort) &gt; 0) {</a>
<a name="ln3198">				// Do outer loop</a>
<a name="ln3199">				dispatchNextMessage = false;</a>
<a name="ln3200">			}</a>
<a name="ln3201">		}</a>
<a name="ln3202">	}</a>
<a name="ln3203">}</a>
<a name="ln3204"> </a>
<a name="ln3205"> </a>
<a name="ln3206">window_type</a>
<a name="ln3207">BWindow::_ComposeType(window_look look, window_feel feel) const</a>
<a name="ln3208">{</a>
<a name="ln3209">	switch (feel) {</a>
<a name="ln3210">		case B_NORMAL_WINDOW_FEEL:</a>
<a name="ln3211">			switch (look) {</a>
<a name="ln3212">				case B_TITLED_WINDOW_LOOK:</a>
<a name="ln3213">					return B_TITLED_WINDOW;</a>
<a name="ln3214"> </a>
<a name="ln3215">				case B_DOCUMENT_WINDOW_LOOK:</a>
<a name="ln3216">					return B_DOCUMENT_WINDOW;</a>
<a name="ln3217"> </a>
<a name="ln3218">				case B_BORDERED_WINDOW_LOOK:</a>
<a name="ln3219">					return B_BORDERED_WINDOW;</a>
<a name="ln3220"> </a>
<a name="ln3221">				default:</a>
<a name="ln3222">					return B_UNTYPED_WINDOW;</a>
<a name="ln3223">			}</a>
<a name="ln3224">			break;</a>
<a name="ln3225"> </a>
<a name="ln3226">		case B_MODAL_APP_WINDOW_FEEL:</a>
<a name="ln3227">			if (look == B_MODAL_WINDOW_LOOK)</a>
<a name="ln3228">				return B_MODAL_WINDOW;</a>
<a name="ln3229">			break;</a>
<a name="ln3230"> </a>
<a name="ln3231">		case B_FLOATING_APP_WINDOW_FEEL:</a>
<a name="ln3232">			if (look == B_FLOATING_WINDOW_LOOK)</a>
<a name="ln3233">				return B_FLOATING_WINDOW;</a>
<a name="ln3234">			break;</a>
<a name="ln3235"> </a>
<a name="ln3236">		default:</a>
<a name="ln3237">			return B_UNTYPED_WINDOW;</a>
<a name="ln3238">	}</a>
<a name="ln3239"> </a>
<a name="ln3240">	return B_UNTYPED_WINDOW;</a>
<a name="ln3241">}</a>
<a name="ln3242"> </a>
<a name="ln3243"> </a>
<a name="ln3244">void</a>
<a name="ln3245">BWindow::_DecomposeType(window_type type, window_look* _look,</a>
<a name="ln3246">	window_feel* _feel) const</a>
<a name="ln3247">{</a>
<a name="ln3248">	switch (type) {</a>
<a name="ln3249">		case B_DOCUMENT_WINDOW:</a>
<a name="ln3250">			*_look = B_DOCUMENT_WINDOW_LOOK;</a>
<a name="ln3251">			*_feel = B_NORMAL_WINDOW_FEEL;</a>
<a name="ln3252">			break;</a>
<a name="ln3253"> </a>
<a name="ln3254">		case B_MODAL_WINDOW:</a>
<a name="ln3255">			*_look = B_MODAL_WINDOW_LOOK;</a>
<a name="ln3256">			*_feel = B_MODAL_APP_WINDOW_FEEL;</a>
<a name="ln3257">			break;</a>
<a name="ln3258"> </a>
<a name="ln3259">		case B_FLOATING_WINDOW:</a>
<a name="ln3260">			*_look = B_FLOATING_WINDOW_LOOK;</a>
<a name="ln3261">			*_feel = B_FLOATING_APP_WINDOW_FEEL;</a>
<a name="ln3262">			break;</a>
<a name="ln3263"> </a>
<a name="ln3264">		case B_BORDERED_WINDOW:</a>
<a name="ln3265">			*_look = B_BORDERED_WINDOW_LOOK;</a>
<a name="ln3266">			*_feel = B_NORMAL_WINDOW_FEEL;</a>
<a name="ln3267">			break;</a>
<a name="ln3268"> </a>
<a name="ln3269">		case B_TITLED_WINDOW:</a>
<a name="ln3270">		case B_UNTYPED_WINDOW:</a>
<a name="ln3271">		default:</a>
<a name="ln3272">			*_look = B_TITLED_WINDOW_LOOK;</a>
<a name="ln3273">			*_feel = B_NORMAL_WINDOW_FEEL;</a>
<a name="ln3274">			break;</a>
<a name="ln3275">	}</a>
<a name="ln3276">}</a>
<a name="ln3277"> </a>
<a name="ln3278"> </a>
<a name="ln3279">void</a>
<a name="ln3280">BWindow::_CreateTopView()</a>
<a name="ln3281">{</a>
<a name="ln3282">	STRACE((&quot;_CreateTopView(): enter\n&quot;));</a>
<a name="ln3283"> </a>
<a name="ln3284">	BRect frame = fFrame.OffsetToCopy(B_ORIGIN);</a>
<a name="ln3285">	// TODO: what to do here about std::nothrow?</a>
<a name="ln3286">	fTopView = new BView(frame, &quot;fTopView&quot;, B_FOLLOW_ALL, B_WILL_DRAW);</a>
<a name="ln3287">	fTopView-&gt;fTopLevelView = true;</a>
<a name="ln3288"> </a>
<a name="ln3289">	//inhibit check_lock()</a>
<a name="ln3290">	fLastViewToken = _get_object_token_(fTopView);</a>
<a name="ln3291"> </a>
<a name="ln3292">	// set fTopView's owner, add it to window's eligible handler list</a>
<a name="ln3293">	// and also set its next handler to be this window.</a>
<a name="ln3294"> </a>
<a name="ln3295">	STRACE((&quot;Calling setowner fTopView = %p this = %p.\n&quot;,</a>
<a name="ln3296">		fTopView, this));</a>
<a name="ln3297"> </a>
<a name="ln3298">	fTopView-&gt;_SetOwner(this);</a>
<a name="ln3299"> </a>
<a name="ln3300">	// we can't use AddChild() because this is the top view</a>
<a name="ln3301">	fTopView-&gt;_CreateSelf();</a>
<a name="ln3302">	STRACE((&quot;BuildTopView ended\n&quot;));</a>
<a name="ln3303">}</a>
<a name="ln3304"> </a>
<a name="ln3305"> </a>
<a name="ln3306">/*!</a>
<a name="ln3307">	Resizes the top view to match the window size. This will also</a>
<a name="ln3308">	adapt the size of all its child views as needed.</a>
<a name="ln3309">	This method has to be called whenever the frame of the window</a>
<a name="ln3310">	changes.</a>
<a name="ln3311">*/</a>
<a name="ln3312">void</a>
<a name="ln3313">BWindow::_AdoptResize()</a>
<a name="ln3314">{</a>
<a name="ln3315">	// Resize views according to their resize modes - this</a>
<a name="ln3316">	// saves us some server communication, as the server</a>
<a name="ln3317">	// does the same with our views on its side.</a>
<a name="ln3318"> </a>
<a name="ln3319">	int32 deltaWidth = (int32)(fFrame.Width() - fTopView-&gt;Bounds().Width());</a>
<a name="ln3320">	int32 deltaHeight = (int32)(fFrame.Height() - fTopView-&gt;Bounds().Height());</a>
<a name="ln3321">	if (deltaWidth == 0 &amp;&amp; deltaHeight == 0)</a>
<a name="ln3322">		return;</a>
<a name="ln3323"> </a>
<a name="ln3324">	fTopView-&gt;_ResizeBy(deltaWidth, deltaHeight);</a>
<a name="ln3325">}</a>
<a name="ln3326"> </a>
<a name="ln3327"> </a>
<a name="ln3328">void</a>
<a name="ln3329">BWindow::_SetFocus(BView* focusView, bool notifyInputServer)</a>
<a name="ln3330">{</a>
<a name="ln3331">	if (fFocus == focusView)</a>
<a name="ln3332">		return;</a>
<a name="ln3333"> </a>
<a name="ln3334">	// we notify the input server if we are passing focus</a>
<a name="ln3335">	// from a view which has the B_INPUT_METHOD_AWARE to a one</a>
<a name="ln3336">	// which does not, or vice-versa</a>
<a name="ln3337">	if (notifyInputServer &amp;&amp; fActive) {</a>
<a name="ln3338">		bool inputMethodAware = false;</a>
<a name="ln3339">		if (focusView)</a>
<a name="ln3340">			inputMethodAware = focusView-&gt;Flags() &amp; B_INPUT_METHOD_AWARE;</a>
<a name="ln3341">		BMessage msg(inputMethodAware ? IS_FOCUS_IM_AWARE_VIEW : IS_UNFOCUS_IM_AWARE_VIEW);</a>
<a name="ln3342">		BMessenger messenger(focusView);</a>
<a name="ln3343">		BMessage reply;</a>
<a name="ln3344">		if (focusView)</a>
<a name="ln3345">			msg.AddMessenger(&quot;view&quot;, messenger);</a>
<a name="ln3346">		_control_input_server_(&amp;msg, &amp;reply);</a>
<a name="ln3347">	}</a>
<a name="ln3348"> </a>
<a name="ln3349">	fFocus = focusView;</a>
<a name="ln3350">	SetPreferredHandler(focusView);</a>
<a name="ln3351">}</a>
<a name="ln3352"> </a>
<a name="ln3353"> </a>
<a name="ln3354">/*!</a>
<a name="ln3355">	\brief Determines the target of a message received for the</a>
<a name="ln3356">		focus view.</a>
<a name="ln3357">*/</a>
<a name="ln3358">BHandler*</a>
<a name="ln3359">BWindow::_DetermineTarget(BMessage* message, BHandler* target)</a>
<a name="ln3360">{</a>
<a name="ln3361">	if (target == NULL)</a>
<a name="ln3362">		target = this;</a>
<a name="ln3363"> </a>
<a name="ln3364">	switch (message-&gt;what) {</a>
<a name="ln3365">		case B_KEY_DOWN:</a>
<a name="ln3366">		case B_KEY_UP:</a>
<a name="ln3367">		{</a>
<a name="ln3368">			// if we have a default button, it might want to hear</a>
<a name="ln3369">			// about pressing the &lt;enter&gt; key</a>
<a name="ln3370">			const int32 kNonLockModifierKeys = B_SHIFT_KEY | B_COMMAND_KEY</a>
<a name="ln3371">				| B_CONTROL_KEY | B_OPTION_KEY | B_MENU_KEY;</a>
<a name="ln3372">			int32 rawChar;</a>
<a name="ln3373">			if (DefaultButton() != NULL</a>
<a name="ln3374">				&amp;&amp; message-&gt;FindInt32(&quot;raw_char&quot;, &amp;rawChar) == B_OK</a>
<a name="ln3375">				&amp;&amp; rawChar == B_ENTER</a>
<a name="ln3376">				&amp;&amp; (modifiers() &amp; kNonLockModifierKeys) == 0)</a>
<a name="ln3377">				return DefaultButton();</a>
<a name="ln3378"> </a>
<a name="ln3379">			// supposed to fall through</a>
<a name="ln3380">		}</a>
<a name="ln3381">		case B_UNMAPPED_KEY_DOWN:</a>
<a name="ln3382">		case B_UNMAPPED_KEY_UP:</a>
<a name="ln3383">		case B_MODIFIERS_CHANGED:</a>
<a name="ln3384">			// these messages should be dispatched by the focus view</a>
<a name="ln3385">			if (CurrentFocus() != NULL)</a>
<a name="ln3386">				return CurrentFocus();</a>
<a name="ln3387">			break;</a>
<a name="ln3388"> </a>
<a name="ln3389">		case B_MOUSE_DOWN:</a>
<a name="ln3390">		case B_MOUSE_UP:</a>
<a name="ln3391">		case B_MOUSE_MOVED:</a>
<a name="ln3392">		case B_MOUSE_WHEEL_CHANGED:</a>
<a name="ln3393">		case B_MOUSE_IDLE:</a>
<a name="ln3394">			// is there a token of the view that is currently under the mouse?</a>
<a name="ln3395">			int32 token;</a>
<a name="ln3396">			if (message-&gt;FindInt32(&quot;_view_token&quot;, &amp;token) == B_OK) {</a>
<a name="ln3397">				BView* view = _FindView(token);</a>
<a name="ln3398">				if (view != NULL)</a>
<a name="ln3399">					return view;</a>
<a name="ln3400">			}</a>
<a name="ln3401"> </a>
<a name="ln3402">			// if there is no valid token in the message, we try our</a>
<a name="ln3403">			// luck with the last target, if available</a>
<a name="ln3404">			if (fLastMouseMovedView != NULL)</a>
<a name="ln3405">				return fLastMouseMovedView;</a>
<a name="ln3406">			break;</a>
<a name="ln3407"> </a>
<a name="ln3408">		case B_PULSE:</a>
<a name="ln3409">		case B_QUIT_REQUESTED:</a>
<a name="ln3410">			// TODO: test whether R5 will let BView dispatch these messages</a>
<a name="ln3411">			return this;</a>
<a name="ln3412"> </a>
<a name="ln3413">		case _MESSAGE_DROPPED_:</a>
<a name="ln3414">			if (fLastMouseMovedView != NULL)</a>
<a name="ln3415">				return fLastMouseMovedView;</a>
<a name="ln3416">			break;</a>
<a name="ln3417"> </a>
<a name="ln3418">		default:</a>
<a name="ln3419">			break;</a>
<a name="ln3420">	}</a>
<a name="ln3421"> </a>
<a name="ln3422">	return target;</a>
<a name="ln3423">}</a>
<a name="ln3424"> </a>
<a name="ln3425"> </a>
<a name="ln3426">/*!	\brief Determines whether or not this message has targeted the focus view.</a>
<a name="ln3427"> </a>
<a name="ln3428">	This will return \c false only if the message did not go to the preferred</a>
<a name="ln3429">	handler, or if the packed message does not contain address the focus view</a>
<a name="ln3430">	at all.</a>
<a name="ln3431">*/</a>
<a name="ln3432">bool</a>
<a name="ln3433">BWindow::_IsFocusMessage(BMessage* message)</a>
<a name="ln3434">{</a>
<a name="ln3435">	BMessage::Private messagePrivate(message);</a>
<a name="ln3436">	if (!messagePrivate.UsePreferredTarget())</a>
<a name="ln3437">		return false;</a>
<a name="ln3438"> </a>
<a name="ln3439">	bool feedFocus;</a>
<a name="ln3440">	if (message-&gt;HasInt32(&quot;_token&quot;)</a>
<a name="ln3441">		&amp;&amp; (message-&gt;FindBool(&quot;_feed_focus&quot;, &amp;feedFocus) != B_OK || !feedFocus))</a>
<a name="ln3442">		return false;</a>
<a name="ln3443"> </a>
<a name="ln3444">	return true;</a>
<a name="ln3445">}</a>
<a name="ln3446"> </a>
<a name="ln3447"> </a>
<a name="ln3448">/*!	\brief Distributes the message to its intended targets. This is done for</a>
<a name="ln3449">		all messages that should go to the preferred handler.</a>
<a name="ln3450"> </a>
<a name="ln3451">	Returns \c true in case the message should still be dispatched</a>
<a name="ln3452">*/</a>
<a name="ln3453">bool</a>
<a name="ln3454">BWindow::_UnpackMessage(unpack_cookie&amp; cookie, BMessage** _message,</a>
<a name="ln3455">	BHandler** _target, bool* _usePreferred)</a>
<a name="ln3456">{</a>
<a name="ln3457">	if (cookie.message == NULL)</a>
<a name="ln3458">		return false;</a>
<a name="ln3459"> </a>
<a name="ln3460">	if (cookie.index == 0 &amp;&amp; !cookie.tokens_scanned) {</a>
<a name="ln3461">		// We were called the first time for this message</a>
<a name="ln3462"> </a>
<a name="ln3463">		if (!*_usePreferred) {</a>
<a name="ln3464">			// only consider messages targeted at the preferred handler</a>
<a name="ln3465">			cookie.message = NULL;</a>
<a name="ln3466">			return true;</a>
<a name="ln3467">		}</a>
<a name="ln3468"> </a>
<a name="ln3469">		// initialize our cookie</a>
<a name="ln3470">		cookie.message = *_message;</a>
<a name="ln3471">		cookie.focus = *_target;</a>
<a name="ln3472"> </a>
<a name="ln3473">		if (cookie.focus != NULL)</a>
<a name="ln3474">			cookie.focus_token = _get_object_token_(*_target);</a>
<a name="ln3475"> </a>
<a name="ln3476">		if (fLastMouseMovedView != NULL &amp;&amp; cookie.message-&gt;what == B_MOUSE_MOVED)</a>
<a name="ln3477">			cookie.last_view_token = _get_object_token_(fLastMouseMovedView);</a>
<a name="ln3478"> </a>
<a name="ln3479">		*_usePreferred = false;</a>
<a name="ln3480">	}</a>
<a name="ln3481"> </a>
<a name="ln3482">	_DequeueAll();</a>
<a name="ln3483"> </a>
<a name="ln3484">	// distribute the message to all targets specified in the</a>
<a name="ln3485">	// message directly (but not to the focus view)</a>
<a name="ln3486"> </a>
<a name="ln3487">	for (int32 token; !cookie.tokens_scanned</a>
<a name="ln3488">			&amp;&amp; cookie.message-&gt;FindInt32(&quot;_token&quot;, cookie.index, &amp;token)</a>
<a name="ln3489">				== B_OK;</a>
<a name="ln3490">			cookie.index++) {</a>
<a name="ln3491">		// focus view is preferred and should get its message directly</a>
<a name="ln3492">		if (token == cookie.focus_token) {</a>
<a name="ln3493">			cookie.found_focus = true;</a>
<a name="ln3494">			continue;</a>
<a name="ln3495">		}</a>
<a name="ln3496">		if (token == cookie.last_view_token)</a>
<a name="ln3497">			continue;</a>
<a name="ln3498"> </a>
<a name="ln3499">		BView* target = _FindView(token);</a>
<a name="ln3500">		if (target == NULL)</a>
<a name="ln3501">			continue;</a>
<a name="ln3502"> </a>
<a name="ln3503">		*_message = new BMessage(*cookie.message);</a>
<a name="ln3504">		// the secondary copies of the message should not be treated as focus</a>
<a name="ln3505">		// messages, otherwise there will be unintended side effects, i.e.</a>
<a name="ln3506">		// keyboard shortcuts getting processed multiple times.</a>
<a name="ln3507">		(*_message)-&gt;RemoveName(&quot;_feed_focus&quot;);</a>
<a name="ln3508">		*_target = target;</a>
<a name="ln3509">		cookie.index++;</a>
<a name="ln3510">		return true;</a>
<a name="ln3511">	}</a>
<a name="ln3512"> </a>
<a name="ln3513">	cookie.tokens_scanned = true;</a>
<a name="ln3514"> </a>
<a name="ln3515">	// if there is a last mouse moved view, and the new focus is</a>
<a name="ln3516">	// different, the previous view wants to get its B_EXITED_VIEW</a>
<a name="ln3517">	// message</a>
<a name="ln3518">	if (cookie.last_view_token != B_NULL_TOKEN &amp;&amp; fLastMouseMovedView != NULL</a>
<a name="ln3519">		&amp;&amp; fLastMouseMovedView != cookie.focus) {</a>
<a name="ln3520">		*_message = new BMessage(*cookie.message);</a>
<a name="ln3521">		*_target = fLastMouseMovedView;</a>
<a name="ln3522">		cookie.last_view_token = B_NULL_TOKEN;</a>
<a name="ln3523">		return true;</a>
<a name="ln3524">	}</a>
<a name="ln3525"> </a>
<a name="ln3526">	bool dispatchToFocus = true;</a>
<a name="ln3527"> </a>
<a name="ln3528">	// check if the focus token is still valid (could have been removed in the mean time)</a>
<a name="ln3529">	BHandler* handler;</a>
<a name="ln3530">	if (gDefaultTokens.GetToken(cookie.focus_token, B_HANDLER_TOKEN, (void**)&amp;handler) != B_OK</a>
<a name="ln3531">		|| handler-&gt;Looper() != this)</a>
<a name="ln3532">		dispatchToFocus = false;</a>
<a name="ln3533"> </a>
<a name="ln3534">	if (dispatchToFocus &amp;&amp; cookie.index &gt; 0) {</a>
<a name="ln3535">		// should this message still be dispatched by the focus view?</a>
<a name="ln3536">		bool feedFocus;</a>
<a name="ln3537">		if (!cookie.found_focus</a>
<a name="ln3538">			&amp;&amp; (cookie.message-&gt;FindBool(&quot;_feed_focus&quot;, &amp;feedFocus) != B_OK</a>
<a name="ln3539">				|| feedFocus == false))</a>
<a name="ln3540">			dispatchToFocus = false;</a>
<a name="ln3541">	}</a>
<a name="ln3542"> </a>
<a name="ln3543">	if (!dispatchToFocus) {</a>
<a name="ln3544">		delete cookie.message;</a>
<a name="ln3545">		cookie.message = NULL;</a>
<a name="ln3546">		return false;</a>
<a name="ln3547">	}</a>
<a name="ln3548"> </a>
<a name="ln3549">	*_message = cookie.message;</a>
<a name="ln3550">	*_target = cookie.focus;</a>
<a name="ln3551">	*_usePreferred = true;</a>
<a name="ln3552">	cookie.message = NULL;</a>
<a name="ln3553">	return true;</a>
<a name="ln3554">}</a>
<a name="ln3555"> </a>
<a name="ln3556"> </a>
<a name="ln3557">/*!	Some messages don't get to the window in a shape an application should see.</a>
<a name="ln3558">	This method is supposed to give a message the last grinding before</a>
<a name="ln3559">	it's acceptable for the receiving application.</a>
<a name="ln3560">*/</a>
<a name="ln3561">void</a>
<a name="ln3562">BWindow::_SanitizeMessage(BMessage* message, BHandler* target, bool usePreferred)</a>
<a name="ln3563">{</a>
<a name="ln3564">	if (target == NULL)</a>
<a name="ln3565">		return;</a>
<a name="ln3566"> </a>
<a name="ln3567">	switch (message-&gt;what) {</a>
<a name="ln3568">		case B_MOUSE_MOVED:</a>
<a name="ln3569">		case B_MOUSE_UP:</a>
<a name="ln3570">		case B_MOUSE_DOWN:</a>
<a name="ln3571">		{</a>
<a name="ln3572">			BPoint where;</a>
<a name="ln3573">			if (message-&gt;FindPoint(&quot;screen_where&quot;, &amp;where) != B_OK)</a>
<a name="ln3574">				break;</a>
<a name="ln3575"> </a>
<a name="ln3576">			BView* view = dynamic_cast&lt;BView*&gt;(target);</a>
<a name="ln3577"> </a>
<a name="ln3578">			if (view == NULL || message-&gt;what == B_MOUSE_MOVED) {</a>
<a name="ln3579">				// add local window coordinates, only</a>
<a name="ln3580">				// for regular mouse moved messages</a>
<a name="ln3581">				message-&gt;AddPoint(&quot;where&quot;, ConvertFromScreen(where));</a>
<a name="ln3582">			}</a>
<a name="ln3583"> </a>
<a name="ln3584">			if (view != NULL) {</a>
<a name="ln3585">				// add local view coordinates</a>
<a name="ln3586">				BPoint viewWhere = view-&gt;ConvertFromScreen(where);</a>
<a name="ln3587">				if (message-&gt;what != B_MOUSE_MOVED) {</a>
<a name="ln3588">					// Yep, the meaning of &quot;where&quot; is different</a>
<a name="ln3589">					// for regular mouse moved messages versus</a>
<a name="ln3590">					// mouse up/down!</a>
<a name="ln3591">					message-&gt;AddPoint(&quot;where&quot;, viewWhere);</a>
<a name="ln3592">				}</a>
<a name="ln3593">				message-&gt;AddPoint(&quot;be:view_where&quot;, viewWhere);</a>
<a name="ln3594"> </a>
<a name="ln3595">				if (message-&gt;what == B_MOUSE_MOVED) {</a>
<a name="ln3596">					// is there a token of the view that is currently under</a>
<a name="ln3597">					// the mouse?</a>
<a name="ln3598">					BView* viewUnderMouse = NULL;</a>
<a name="ln3599">					int32 token;</a>
<a name="ln3600">					if (message-&gt;FindInt32(&quot;_view_token&quot;, &amp;token) == B_OK)</a>
<a name="ln3601">						viewUnderMouse = _FindView(token);</a>
<a name="ln3602"> </a>
<a name="ln3603">					// add transit information</a>
<a name="ln3604">					uint32 transit</a>
<a name="ln3605">						= _TransitForMouseMoved(view, viewUnderMouse);</a>
<a name="ln3606">					message-&gt;AddInt32(&quot;be:transit&quot;, transit);</a>
<a name="ln3607"> </a>
<a name="ln3608">					if (usePreferred)</a>
<a name="ln3609">						fLastMouseMovedView = viewUnderMouse;</a>
<a name="ln3610">				}</a>
<a name="ln3611">			}</a>
<a name="ln3612">			break;</a>
<a name="ln3613">		}</a>
<a name="ln3614"> </a>
<a name="ln3615">		case B_MOUSE_IDLE:</a>
<a name="ln3616">		{</a>
<a name="ln3617">			// App Server sends screen coordinates, convert the point to</a>
<a name="ln3618">			// local view coordinates, then add the point in be:view_where</a>
<a name="ln3619">			BPoint where;</a>
<a name="ln3620">			if (message-&gt;FindPoint(&quot;screen_where&quot;, &amp;where) != B_OK)</a>
<a name="ln3621">				break;</a>
<a name="ln3622"> </a>
<a name="ln3623">			BView* view = dynamic_cast&lt;BView*&gt;(target);</a>
<a name="ln3624">			if (view != NULL) {</a>
<a name="ln3625">				// add local view coordinates</a>
<a name="ln3626">				message-&gt;AddPoint(&quot;be:view_where&quot;,</a>
<a name="ln3627">					view-&gt;ConvertFromScreen(where));</a>
<a name="ln3628">			}</a>
<a name="ln3629">			break;</a>
<a name="ln3630">		}</a>
<a name="ln3631"> </a>
<a name="ln3632">		case _MESSAGE_DROPPED_:</a>
<a name="ln3633">		{</a>
<a name="ln3634">			uint32 originalWhat;</a>
<a name="ln3635">			if (message-&gt;FindInt32(&quot;_original_what&quot;,</a>
<a name="ln3636">					(int32*)&amp;originalWhat) == B_OK) {</a>
<a name="ln3637">				message-&gt;what = originalWhat;</a>
<a name="ln3638">				message-&gt;RemoveName(&quot;_original_what&quot;);</a>
<a name="ln3639">			}</a>
<a name="ln3640">			break;</a>
<a name="ln3641">		}</a>
<a name="ln3642">	}</a>
<a name="ln3643">}</a>
<a name="ln3644"> </a>
<a name="ln3645"> </a>
<a name="ln3646">/*!</a>
<a name="ln3647">	This is called by BView::GetMouse() when a B_MOUSE_MOVED message</a>
<a name="ln3648">	is removed from the queue.</a>
<a name="ln3649">	It allows the window to update the last mouse moved view, and</a>
<a name="ln3650">	let it decide if this message should be kept. It will also remove</a>
<a name="ln3651">	the message from the queue.</a>
<a name="ln3652">	You need to hold the message queue lock when calling this method!</a>
<a name="ln3653"> </a>
<a name="ln3654">	\return true if this message can be used to get the mouse data from,</a>
<a name="ln3655">	\return false if this is not meant for the public.</a>
<a name="ln3656">*/</a>
<a name="ln3657">bool</a>
<a name="ln3658">BWindow::_StealMouseMessage(BMessage* message, bool&amp; deleteMessage)</a>
<a name="ln3659">{</a>
<a name="ln3660">	BMessage::Private messagePrivate(message);</a>
<a name="ln3661">	if (!messagePrivate.UsePreferredTarget()) {</a>
<a name="ln3662">		// this message is targeted at a specific handler, so we should</a>
<a name="ln3663">		// not steal it</a>
<a name="ln3664">		return false;</a>
<a name="ln3665">	}</a>
<a name="ln3666"> </a>
<a name="ln3667">	int32 token;</a>
<a name="ln3668">	if (message-&gt;FindInt32(&quot;_token&quot;, 0, &amp;token) == B_OK) {</a>
<a name="ln3669">		// This message has other targets, so we can't remove it;</a>
<a name="ln3670">		// just prevent it from being sent to the preferred handler</a>
<a name="ln3671">		// again (if it should have gotten it at all).</a>
<a name="ln3672">		bool feedFocus;</a>
<a name="ln3673">		if (message-&gt;FindBool(&quot;_feed_focus&quot;, &amp;feedFocus) != B_OK || !feedFocus)</a>
<a name="ln3674">			return false;</a>
<a name="ln3675"> </a>
<a name="ln3676">		message-&gt;RemoveName(&quot;_feed_focus&quot;);</a>
<a name="ln3677">		deleteMessage = false;</a>
<a name="ln3678">	} else {</a>
<a name="ln3679">		deleteMessage = true;</a>
<a name="ln3680"> </a>
<a name="ln3681">		if (message-&gt;what == B_MOUSE_MOVED) {</a>
<a name="ln3682">			// We need to update the last mouse moved view, as this message</a>
<a name="ln3683">			// won't make it to _SanitizeMessage() anymore.</a>
<a name="ln3684">			BView* viewUnderMouse = NULL;</a>
<a name="ln3685">			int32 token;</a>
<a name="ln3686">			if (message-&gt;FindInt32(&quot;_view_token&quot;, &amp;token) == B_OK)</a>
<a name="ln3687">				viewUnderMouse = _FindView(token);</a>
<a name="ln3688"> </a>
<a name="ln3689">			// Don't remove important transit messages!</a>
<a name="ln3690">			uint32 transit = _TransitForMouseMoved(fLastMouseMovedView,</a>
<a name="ln3691">				viewUnderMouse);</a>
<a name="ln3692">			if (transit == B_ENTERED_VIEW || transit == B_EXITED_VIEW)</a>
<a name="ln3693">				deleteMessage = false;</a>
<a name="ln3694">		}</a>
<a name="ln3695"> </a>
<a name="ln3696">		if (deleteMessage) {</a>
<a name="ln3697">			// The message is only thought for the preferred handler, so we</a>
<a name="ln3698">			// can just remove it.</a>
<a name="ln3699">			MessageQueue()-&gt;RemoveMessage(message);</a>
<a name="ln3700">		}</a>
<a name="ln3701">	}</a>
<a name="ln3702"> </a>
<a name="ln3703">	return true;</a>
<a name="ln3704">}</a>
<a name="ln3705"> </a>
<a name="ln3706"> </a>
<a name="ln3707">uint32</a>
<a name="ln3708">BWindow::_TransitForMouseMoved(BView* view, BView* viewUnderMouse) const</a>
<a name="ln3709">{</a>
<a name="ln3710">	uint32 transit;</a>
<a name="ln3711">	if (viewUnderMouse == view) {</a>
<a name="ln3712">		// the mouse is over the target view</a>
<a name="ln3713">		if (fLastMouseMovedView != view)</a>
<a name="ln3714">			transit = B_ENTERED_VIEW;</a>
<a name="ln3715">		else</a>
<a name="ln3716">			transit = B_INSIDE_VIEW;</a>
<a name="ln3717">	} else {</a>
<a name="ln3718">		// the mouse is not over the target view</a>
<a name="ln3719">		if (view == fLastMouseMovedView)</a>
<a name="ln3720">			transit = B_EXITED_VIEW;</a>
<a name="ln3721">		else</a>
<a name="ln3722">			transit = B_OUTSIDE_VIEW;</a>
<a name="ln3723">	}</a>
<a name="ln3724">	return transit;</a>
<a name="ln3725">}</a>
<a name="ln3726"> </a>
<a name="ln3727"> </a>
<a name="ln3728">/*!	Forwards the key to the switcher</a>
<a name="ln3729">*/</a>
<a name="ln3730">void</a>
<a name="ln3731">BWindow::_Switcher(int32 rawKey, uint32 modifiers, bool repeat)</a>
<a name="ln3732">{</a>
<a name="ln3733">	// only send the first key press, no repeats</a>
<a name="ln3734">	if (repeat)</a>
<a name="ln3735">		return;</a>
<a name="ln3736"> </a>
<a name="ln3737">	BMessenger deskbar(kDeskbarSignature);</a>
<a name="ln3738">	if (!deskbar.IsValid()) {</a>
<a name="ln3739">		// TODO: have some kind of fallback-handling in case the Deskbar is</a>
<a name="ln3740">		// not available?</a>
<a name="ln3741">		return;</a>
<a name="ln3742">	}</a>
<a name="ln3743"> </a>
<a name="ln3744">	BMessage message('TASK');</a>
<a name="ln3745">	message.AddInt32(&quot;key&quot;, rawKey);</a>
<a name="ln3746">	message.AddInt32(&quot;modifiers&quot;, modifiers);</a>
<a name="ln3747">	message.AddInt64(&quot;when&quot;, system_time());</a>
<a name="ln3748">	message.AddInt32(&quot;team&quot;, Team());</a>
<a name="ln3749">	deskbar.SendMessage(&amp;message);</a>
<a name="ln3750">}</a>
<a name="ln3751"> </a>
<a name="ln3752"> </a>
<a name="ln3753">/*!	Handles keyboard input before it gets forwarded to the target handler.</a>
<a name="ln3754">	This includes shortcut evaluation, keyboard navigation, etc.</a>
<a name="ln3755"> </a>
<a name="ln3756">	\return handled if true, the event was already handled, and will not</a>
<a name="ln3757">		be forwarded to the target handler.</a>
<a name="ln3758"> </a>
<a name="ln3759">	TODO: must also convert the incoming key to the font encoding of the target</a>
<a name="ln3760">*/</a>
<a name="ln3761">bool</a>
<a name="ln3762">BWindow::_HandleKeyDown(BMessage* event)</a>
<a name="ln3763">{</a>
<a name="ln3764">	// Only handle special functions when the event targeted the active focus</a>
<a name="ln3765">	// view</a>
<a name="ln3766">	if (!_IsFocusMessage(event))</a>
<a name="ln3767">		return false;</a>
<a name="ln3768"> </a>
<a name="ln3769">	const char* bytes = NULL;</a>
<a name="ln3770">	if (event-&gt;FindString(&quot;bytes&quot;, &amp;bytes) != B_OK)</a>
<a name="ln3771">		return false;</a>
<a name="ln3772"> </a>
<a name="ln3773">	char key = bytes[0];</a>
<a name="ln3774"> </a>
<a name="ln3775">	uint32 modifiers;</a>
<a name="ln3776">	if (event-&gt;FindInt32(&quot;modifiers&quot;, (int32*)&amp;modifiers) != B_OK)</a>
<a name="ln3777">		modifiers = 0;</a>
<a name="ln3778"> </a>
<a name="ln3779">	// handle BMenuBar key</a>
<a name="ln3780">	if (key == B_ESCAPE &amp;&amp; (modifiers &amp; B_COMMAND_KEY) != 0</a>
<a name="ln3781">		&amp;&amp; fKeyMenuBar != NULL) {</a>
<a name="ln3782">		fKeyMenuBar-&gt;StartMenuBar(0, true, false, NULL);</a>
<a name="ln3783">		return true;</a>
<a name="ln3784">	}</a>
<a name="ln3785"> </a>
<a name="ln3786">	// Keyboard navigation through views</a>
<a name="ln3787">	// (B_OPTION_KEY makes BTextViews and friends navigable, even in editing</a>
<a name="ln3788">	// mode)</a>
<a name="ln3789">	if (key == B_TAB &amp;&amp; (modifiers &amp; B_OPTION_KEY) != 0) {</a>
<a name="ln3790">		_KeyboardNavigation();</a>
<a name="ln3791">		return true;</a>
<a name="ln3792">	}</a>
<a name="ln3793"> </a>
<a name="ln3794">	int32 rawKey;</a>
<a name="ln3795">	event-&gt;FindInt32(&quot;key&quot;, &amp;rawKey);</a>
<a name="ln3796"> </a>
<a name="ln3797">	// Deskbar's Switcher</a>
<a name="ln3798">	if ((key == B_TAB || rawKey == 0x11) &amp;&amp; (modifiers &amp; B_CONTROL_KEY) != 0) {</a>
<a name="ln3799">		_Switcher(rawKey, modifiers, event-&gt;HasInt32(&quot;be:key_repeat&quot;));</a>
<a name="ln3800">		return true;</a>
<a name="ln3801">	}</a>
<a name="ln3802"> </a>
<a name="ln3803">	// Optionally close window when the escape key is pressed</a>
<a name="ln3804">	if (key == B_ESCAPE &amp;&amp; (Flags() &amp; B_CLOSE_ON_ESCAPE) != 0) {</a>
<a name="ln3805">		BMessage message(B_QUIT_REQUESTED);</a>
<a name="ln3806">		message.AddBool(&quot;shortcut&quot;, true);</a>
<a name="ln3807"> </a>
<a name="ln3808">		PostMessage(&amp;message);</a>
<a name="ln3809">		return true;</a>
<a name="ln3810">	}</a>
<a name="ln3811"> </a>
<a name="ln3812">	// PrtScr key takes a screenshot</a>
<a name="ln3813">	if (key == B_FUNCTION_KEY &amp;&amp; rawKey == B_PRINT_KEY) {</a>
<a name="ln3814">		// With no modifier keys the best way to get a screenshot is by</a>
<a name="ln3815">		// calling the screenshot CLI</a>
<a name="ln3816">		if (modifiers == 0) {</a>
<a name="ln3817">			be_roster-&gt;Launch(&quot;application/x-vnd.haiku-screenshot-cli&quot;);</a>
<a name="ln3818">			return true;</a>
<a name="ln3819">		}</a>
<a name="ln3820"> </a>
<a name="ln3821">		// Prepare a message based on the modifier keys pressed and launch the</a>
<a name="ln3822">		// screenshot GUI</a>
<a name="ln3823">		BMessage message(B_ARGV_RECEIVED);</a>
<a name="ln3824">		int32 argc = 1;</a>
<a name="ln3825">		message.AddString(&quot;argv&quot;, &quot;Screenshot&quot;);</a>
<a name="ln3826">		if ((modifiers &amp; B_CONTROL_KEY) != 0) {</a>
<a name="ln3827">			argc++;</a>
<a name="ln3828">			message.AddString(&quot;argv&quot;, &quot;--clipboard&quot;);</a>
<a name="ln3829">		}</a>
<a name="ln3830">		if ((modifiers &amp; B_SHIFT_KEY) != 0) {</a>
<a name="ln3831">			argc++;</a>
<a name="ln3832">			message.AddString(&quot;argv&quot;, &quot;--silent&quot;);</a>
<a name="ln3833">		}</a>
<a name="ln3834">		message.AddInt32(&quot;argc&quot;, argc);</a>
<a name="ln3835">		be_roster-&gt;Launch(&quot;application/x-vnd.haiku-screenshot&quot;, &amp;message);</a>
<a name="ln3836">		return true;</a>
<a name="ln3837">	}</a>
<a name="ln3838"> </a>
<a name="ln3839">	// Handle shortcuts</a>
<a name="ln3840">	if ((modifiers &amp; B_COMMAND_KEY) != 0) {</a>
<a name="ln3841">		// Command+q has been pressed, so, we will quit</a>
<a name="ln3842">		// the shortcut mechanism doesn't allow handlers outside the window</a>
<a name="ln3843">		if (!fNoQuitShortcut &amp;&amp; (key == 'Q' || key == 'q')) {</a>
<a name="ln3844">			BMessage message(B_QUIT_REQUESTED);</a>
<a name="ln3845">			message.AddBool(&quot;shortcut&quot;, true);</a>
<a name="ln3846"> </a>
<a name="ln3847">			be_app-&gt;PostMessage(&amp;message);</a>
<a name="ln3848">			// eat the event</a>
<a name="ln3849">			return true;</a>
<a name="ln3850">		}</a>
<a name="ln3851"> </a>
<a name="ln3852">		// Send Command+Left and Command+Right to textview if it has focus</a>
<a name="ln3853">		if (key == B_LEFT_ARROW || key == B_RIGHT_ARROW) {</a>
<a name="ln3854">			// check key before doing expensive dynamic_cast</a>
<a name="ln3855">			BTextView* textView = dynamic_cast&lt;BTextView*&gt;(CurrentFocus());</a>
<a name="ln3856">			if (textView != NULL) {</a>
<a name="ln3857">				textView-&gt;KeyDown(bytes, modifiers);</a>
<a name="ln3858">				// eat the event</a>
<a name="ln3859">				return true;</a>
<a name="ln3860">			}</a>
<a name="ln3861">		}</a>
<a name="ln3862"> </a>
<a name="ln3863">		// Pretend that the user opened a menu, to give the subclass a</a>
<a name="ln3864">		// chance to update it's menus. This may install new shortcuts,</a>
<a name="ln3865">		// which is why we have to call it here, before trying to find</a>
<a name="ln3866">		// a shortcut for the given key.</a>
<a name="ln3867">		MenusBeginning();</a>
<a name="ln3868"> </a>
<a name="ln3869">		Shortcut* shortcut = _FindShortcut(key, modifiers);</a>
<a name="ln3870">		if (shortcut != NULL) {</a>
<a name="ln3871">			// TODO: would be nice to move this functionality to</a>
<a name="ln3872">			//	a Shortcut::Invoke() method - but since BMenu::InvokeItem()</a>
<a name="ln3873">			//	(and BMenuItem::Invoke()) are private, I didn't want</a>
<a name="ln3874">			//	to mess with them (BMenuItem::Invoke() is public in</a>
<a name="ln3875">			//	Dano/Zeta, though, maybe we should just follow their</a>
<a name="ln3876">			//	example)</a>
<a name="ln3877">			if (shortcut-&gt;MenuItem() != NULL) {</a>
<a name="ln3878">				BMenu* menu = shortcut-&gt;MenuItem()-&gt;Menu();</a>
<a name="ln3879">				if (menu != NULL)</a>
<a name="ln3880">					MenuPrivate(menu).InvokeItem(shortcut-&gt;MenuItem(), true);</a>
<a name="ln3881">			} else {</a>
<a name="ln3882">				BHandler* target = shortcut-&gt;Target();</a>
<a name="ln3883">				if (target == NULL)</a>
<a name="ln3884">					target = CurrentFocus();</a>
<a name="ln3885"> </a>
<a name="ln3886">				if (shortcut-&gt;Message() != NULL) {</a>
<a name="ln3887">					BMessage message(*shortcut-&gt;Message());</a>
<a name="ln3888"> </a>
<a name="ln3889">					if (message.ReplaceInt64(&quot;when&quot;, system_time()) != B_OK)</a>
<a name="ln3890">						message.AddInt64(&quot;when&quot;, system_time());</a>
<a name="ln3891">					if (message.ReplaceBool(&quot;shortcut&quot;, true) != B_OK)</a>
<a name="ln3892">						message.AddBool(&quot;shortcut&quot;, true);</a>
<a name="ln3893"> </a>
<a name="ln3894">					PostMessage(&amp;message, target);</a>
<a name="ln3895">				}</a>
<a name="ln3896">			}</a>
<a name="ln3897">		}</a>
<a name="ln3898"> </a>
<a name="ln3899">		MenusEnded();</a>
<a name="ln3900"> </a>
<a name="ln3901">		// we always eat the event if the command key was pressed</a>
<a name="ln3902">		return true;</a>
<a name="ln3903">	}</a>
<a name="ln3904"> </a>
<a name="ln3905">	// TODO: convert keys to the encoding of the target view</a>
<a name="ln3906"> </a>
<a name="ln3907">	return false;</a>
<a name="ln3908">}</a>
<a name="ln3909"> </a>
<a name="ln3910"> </a>
<a name="ln3911">bool</a>
<a name="ln3912">BWindow::_HandleUnmappedKeyDown(BMessage* event)</a>
<a name="ln3913">{</a>
<a name="ln3914">	// Only handle special functions when the event targeted the active focus</a>
<a name="ln3915">	// view</a>
<a name="ln3916">	if (!_IsFocusMessage(event))</a>
<a name="ln3917">		return false;</a>
<a name="ln3918"> </a>
<a name="ln3919">	uint32 modifiers;</a>
<a name="ln3920">	int32 rawKey;</a>
<a name="ln3921">	if (event-&gt;FindInt32(&quot;modifiers&quot;, (int32*)&amp;modifiers) != B_OK</a>
<a name="ln3922">		|| event-&gt;FindInt32(&quot;key&quot;, &amp;rawKey))</a>
<a name="ln3923">		return false;</a>
<a name="ln3924"> </a>
<a name="ln3925">	// Deskbar's Switcher</a>
<a name="ln3926">	if (rawKey == 0x11 &amp;&amp; (modifiers &amp; B_CONTROL_KEY) != 0) {</a>
<a name="ln3927">		_Switcher(rawKey, modifiers, event-&gt;HasInt32(&quot;be:key_repeat&quot;));</a>
<a name="ln3928">		return true;</a>
<a name="ln3929">	}</a>
<a name="ln3930"> </a>
<a name="ln3931">	return false;</a>
<a name="ln3932">}</a>
<a name="ln3933"> </a>
<a name="ln3934"> </a>
<a name="ln3935">void</a>
<a name="ln3936">BWindow::_KeyboardNavigation()</a>
<a name="ln3937">{</a>
<a name="ln3938">	BMessage* message = CurrentMessage();</a>
<a name="ln3939">	if (message == NULL)</a>
<a name="ln3940">		return;</a>
<a name="ln3941"> </a>
<a name="ln3942">	const char* bytes;</a>
<a name="ln3943">	uint32 modifiers;</a>
<a name="ln3944">	if (message-&gt;FindString(&quot;bytes&quot;, &amp;bytes) != B_OK || bytes[0] != B_TAB)</a>
<a name="ln3945">		return;</a>
<a name="ln3946"> </a>
<a name="ln3947">	message-&gt;FindInt32(&quot;modifiers&quot;, (int32*)&amp;modifiers);</a>
<a name="ln3948"> </a>
<a name="ln3949">	BView* nextFocus;</a>
<a name="ln3950">	int32 jumpGroups = (modifiers &amp; B_OPTION_KEY) != 0</a>
<a name="ln3951">		? B_NAVIGABLE_JUMP : B_NAVIGABLE;</a>
<a name="ln3952">	if (modifiers &amp; B_SHIFT_KEY)</a>
<a name="ln3953">		nextFocus = _FindPreviousNavigable(fFocus, jumpGroups);</a>
<a name="ln3954">	else</a>
<a name="ln3955">		nextFocus = _FindNextNavigable(fFocus, jumpGroups);</a>
<a name="ln3956"> </a>
<a name="ln3957">	if (nextFocus != NULL &amp;&amp; nextFocus != fFocus)</a>
<a name="ln3958">		nextFocus-&gt;MakeFocus(true);</a>
<a name="ln3959">}</a>
<a name="ln3960"> </a>
<a name="ln3961"> </a>
<a name="ln3962">/*!</a>
<a name="ln3963">	\brief Return the position of the window centered horizontally to the passed</a>
<a name="ln3964">           in \a frame and vertically 3/4 from the top of \a frame.</a>
<a name="ln3965"> </a>
<a name="ln3966">	If the window is on the borders</a>
<a name="ln3967"> </a>
<a name="ln3968">	\param width The width of the window.</a>
<a name="ln3969">	\param height The height of the window.</a>
<a name="ln3970">	\param frame The \a frame to center the window in.</a>
<a name="ln3971"> </a>
<a name="ln3972">	\return The new window position.</a>
<a name="ln3973">*/</a>
<a name="ln3974">BPoint</a>
<a name="ln3975">BWindow::AlertPosition(const BRect&amp; frame)</a>
<a name="ln3976">{</a>
<a name="ln3977">	float width = Bounds().Width();</a>
<a name="ln3978">	float height = Bounds().Height();</a>
<a name="ln3979"> </a>
<a name="ln3980">	BPoint point(frame.left + (frame.Width() / 2.0f) - (width / 2.0f),</a>
<a name="ln3981">		frame.top + (frame.Height() / 4.0f) - ceil(height / 3.0f));</a>
<a name="ln3982"> </a>
<a name="ln3983">	BRect screenFrame = BScreen(this).Frame();</a>
<a name="ln3984">	if (frame == screenFrame) {</a>
<a name="ln3985">		// reference frame is screen frame, skip the below adjustments</a>
<a name="ln3986">		return point;</a>
<a name="ln3987">	}</a>
<a name="ln3988"> </a>
<a name="ln3989">	float borderWidth;</a>
<a name="ln3990">	float tabHeight;</a>
<a name="ln3991">	_GetDecoratorSize(&amp;borderWidth, &amp;tabHeight);</a>
<a name="ln3992"> </a>
<a name="ln3993">	// clip the x position within the horizontal edges of the screen</a>
<a name="ln3994">	if (point.x &lt; screenFrame.left + borderWidth)</a>
<a name="ln3995">		point.x = screenFrame.left + borderWidth;</a>
<a name="ln3996">	else if (point.x + width &gt; screenFrame.right - borderWidth)</a>
<a name="ln3997">		point.x = screenFrame.right - borderWidth - width;</a>
<a name="ln3998"> </a>
<a name="ln3999">	// lower the window down if it is covering the window tab</a>
<a name="ln4000">	float tabPosition = frame.LeftTop().y + tabHeight + borderWidth;</a>
<a name="ln4001">	if (point.y &lt; tabPosition)</a>
<a name="ln4002">		point.y = tabPosition;</a>
<a name="ln4003"> </a>
<a name="ln4004">	// clip the y position within the vertical edges of the screen</a>
<a name="ln4005">	if (point.y &lt; screenFrame.top + borderWidth)</a>
<a name="ln4006">		point.y = screenFrame.top + borderWidth;</a>
<a name="ln4007">	else if (point.y + height &gt; screenFrame.bottom - borderWidth)</a>
<a name="ln4008">		point.y = screenFrame.bottom - borderWidth - height;</a>
<a name="ln4009"> </a>
<a name="ln4010">	return point;</a>
<a name="ln4011">}</a>
<a name="ln4012"> </a>
<a name="ln4013"> </a>
<a name="ln4014">BMessage*</a>
<a name="ln4015">BWindow::ConvertToMessage(void* raw, int32 code)</a>
<a name="ln4016">{</a>
<a name="ln4017">	return BLooper::ConvertToMessage(raw, code);</a>
<a name="ln4018">}</a>
<a name="ln4019"> </a>
<a name="ln4020"> </a>
<a name="ln4021">BWindow::Shortcut*</a>
<a name="ln4022">BWindow::_FindShortcut(uint32 key, uint32 modifiers)</a>
<a name="ln4023">{</a>
<a name="ln4024">	int32 count = fShortcuts.CountItems();</a>
<a name="ln4025"> </a>
<a name="ln4026">	key = Shortcut::PrepareKey(key);</a>
<a name="ln4027">	modifiers = Shortcut::PrepareModifiers(modifiers);</a>
<a name="ln4028"> </a>
<a name="ln4029">	for (int32 index = 0; index &lt; count; index++) {</a>
<a name="ln4030">		Shortcut* shortcut = (Shortcut*)fShortcuts.ItemAt(index);</a>
<a name="ln4031"> </a>
<a name="ln4032">		if (shortcut-&gt;Matches(key, modifiers))</a>
<a name="ln4033">			return shortcut;</a>
<a name="ln4034">	}</a>
<a name="ln4035"> </a>
<a name="ln4036">	return NULL;</a>
<a name="ln4037">}</a>
<a name="ln4038"> </a>
<a name="ln4039"> </a>
<a name="ln4040">BView*</a>
<a name="ln4041">BWindow::_FindView(int32 token)</a>
<a name="ln4042">{</a>
<a name="ln4043">	BHandler* handler;</a>
<a name="ln4044">	if (gDefaultTokens.GetToken(token, B_HANDLER_TOKEN,</a>
<a name="ln4045">			(void**)&amp;handler) != B_OK) {</a>
<a name="ln4046">		return NULL;</a>
<a name="ln4047">	}</a>
<a name="ln4048"> </a>
<a name="ln4049">	// the view must belong to us in order to be found by this method</a>
<a name="ln4050">	BView* view = dynamic_cast&lt;BView*&gt;(handler);</a>
<a name="ln4051">	if (view != NULL &amp;&amp; view-&gt;Window() == this)</a>
<a name="ln4052">		return view;</a>
<a name="ln4053"> </a>
<a name="ln4054">	return NULL;</a>
<a name="ln4055">}</a>
<a name="ln4056"> </a>
<a name="ln4057"> </a>
<a name="ln4058">BView*</a>
<a name="ln4059">BWindow::_FindView(BView* view, BPoint point) const</a>
<a name="ln4060">{</a>
<a name="ln4061">	// point is assumed to be already in view's coordinates</a>
<a name="ln4062">	if (!view-&gt;IsHidden(view) &amp;&amp; view-&gt;Bounds().Contains(point)) {</a>
<a name="ln4063">		if (view-&gt;fFirstChild == NULL)</a>
<a name="ln4064">			return view;</a>
<a name="ln4065">		else {</a>
<a name="ln4066">			BView* child = view-&gt;fFirstChild;</a>
<a name="ln4067">			while (child != NULL) {</a>
<a name="ln4068">				BPoint childPoint = point - child-&gt;Frame().LeftTop();</a>
<a name="ln4069">				BView* subView  = _FindView(child, childPoint);</a>
<a name="ln4070">				if (subView != NULL)</a>
<a name="ln4071">					return subView;</a>
<a name="ln4072"> </a>
<a name="ln4073">				child = child-&gt;fNextSibling;</a>
<a name="ln4074">			}</a>
<a name="ln4075">		}</a>
<a name="ln4076">		return view;</a>
<a name="ln4077">	}</a>
<a name="ln4078">	return NULL;</a>
<a name="ln4079">}</a>
<a name="ln4080"> </a>
<a name="ln4081"> </a>
<a name="ln4082">BView*</a>
<a name="ln4083">BWindow::_FindNextNavigable(BView* focus, uint32 flags)</a>
<a name="ln4084">{</a>
<a name="ln4085">	if (focus == NULL)</a>
<a name="ln4086">		focus = fTopView;</a>
<a name="ln4087"> </a>
<a name="ln4088">	BView* nextFocus = focus;</a>
<a name="ln4089"> </a>
<a name="ln4090">	// Search the tree for views that accept focus (depth search)</a>
<a name="ln4091">	while (true) {</a>
<a name="ln4092">		if (nextFocus-&gt;fFirstChild)</a>
<a name="ln4093">			nextFocus = nextFocus-&gt;fFirstChild;</a>
<a name="ln4094">		else if (nextFocus-&gt;fNextSibling)</a>
<a name="ln4095">			nextFocus = nextFocus-&gt;fNextSibling;</a>
<a name="ln4096">		else {</a>
<a name="ln4097">			// go to the nearest parent with a next sibling</a>
<a name="ln4098">			while (!nextFocus-&gt;fNextSibling &amp;&amp; nextFocus-&gt;fParent) {</a>
<a name="ln4099">				nextFocus = nextFocus-&gt;fParent;</a>
<a name="ln4100">			}</a>
<a name="ln4101"> </a>
<a name="ln4102">			if (nextFocus == fTopView) {</a>
<a name="ln4103">				// if we started with the top view, we traversed the whole tree already</a>
<a name="ln4104">				if (nextFocus == focus)</a>
<a name="ln4105">					return NULL;</a>
<a name="ln4106"> </a>
<a name="ln4107">				nextFocus = nextFocus-&gt;fFirstChild;</a>
<a name="ln4108">			} else</a>
<a name="ln4109">				nextFocus = nextFocus-&gt;fNextSibling;</a>
<a name="ln4110">		}</a>
<a name="ln4111"> </a>
<a name="ln4112">		if (nextFocus == focus || nextFocus == NULL) {</a>
<a name="ln4113">			// When we get here it means that the hole tree has been</a>
<a name="ln4114">			// searched and there is no view with B_NAVIGABLE(_JUMP) flag set!</a>
<a name="ln4115">			return NULL;</a>
<a name="ln4116">		}</a>
<a name="ln4117"> </a>
<a name="ln4118">		if (!nextFocus-&gt;IsHidden() &amp;&amp; (nextFocus-&gt;Flags() &amp; flags) != 0)</a>
<a name="ln4119">			return nextFocus;</a>
<a name="ln4120">	}</a>
<a name="ln4121">}</a>
<a name="ln4122"> </a>
<a name="ln4123"> </a>
<a name="ln4124">BView*</a>
<a name="ln4125">BWindow::_FindPreviousNavigable(BView* focus, uint32 flags)</a>
<a name="ln4126">{</a>
<a name="ln4127">	if (focus == NULL)</a>
<a name="ln4128">		focus = fTopView;</a>
<a name="ln4129"> </a>
<a name="ln4130">	BView* previousFocus = focus;</a>
<a name="ln4131"> </a>
<a name="ln4132">	// Search the tree for the previous view that accept focus</a>
<a name="ln4133">	while (true) {</a>
<a name="ln4134">		if (previousFocus-&gt;fPreviousSibling) {</a>
<a name="ln4135">			// find the last child in the previous sibling</a>
<a name="ln4136">			previousFocus = _LastViewChild(previousFocus-&gt;fPreviousSibling);</a>
<a name="ln4137">		} else {</a>
<a name="ln4138">			previousFocus = previousFocus-&gt;fParent;</a>
<a name="ln4139">			if (previousFocus == fTopView)</a>
<a name="ln4140">				previousFocus = _LastViewChild(fTopView);</a>
<a name="ln4141">		}</a>
<a name="ln4142"> </a>
<a name="ln4143">		if (previousFocus == focus || previousFocus == NULL) {</a>
<a name="ln4144">			// When we get here it means that the hole tree has been</a>
<a name="ln4145">			// searched and there is no view with B_NAVIGABLE(_JUMP) flag set!</a>
<a name="ln4146">			return NULL;</a>
<a name="ln4147">		}</a>
<a name="ln4148"> </a>
<a name="ln4149">		if (!previousFocus-&gt;IsHidden() &amp;&amp; (previousFocus-&gt;Flags() &amp; flags) != 0)</a>
<a name="ln4150">			return previousFocus;</a>
<a name="ln4151">	}</a>
<a name="ln4152">}</a>
<a name="ln4153"> </a>
<a name="ln4154"> </a>
<a name="ln4155">/*!</a>
<a name="ln4156">	Returns the last child in a view hierarchy.</a>
<a name="ln4157">	Needed only by _FindPreviousNavigable().</a>
<a name="ln4158">*/</a>
<a name="ln4159">BView*</a>
<a name="ln4160">BWindow::_LastViewChild(BView* parent)</a>
<a name="ln4161">{</a>
<a name="ln4162">	while (true) {</a>
<a name="ln4163">		BView* last = parent-&gt;fFirstChild;</a>
<a name="ln4164">		if (last == NULL)</a>
<a name="ln4165">			return parent;</a>
<a name="ln4166"> </a>
<a name="ln4167">		while (last-&gt;fNextSibling) {</a>
<a name="ln4168">			last = last-&gt;fNextSibling;</a>
<a name="ln4169">		}</a>
<a name="ln4170"> </a>
<a name="ln4171">		parent = last;</a>
<a name="ln4172">	}</a>
<a name="ln4173">}</a>
<a name="ln4174"> </a>
<a name="ln4175"> </a>
<a name="ln4176">void</a>
<a name="ln4177">BWindow::SetIsFilePanel(bool isFilePanel)</a>
<a name="ln4178">{</a>
<a name="ln4179">	fIsFilePanel = isFilePanel;</a>
<a name="ln4180">}</a>
<a name="ln4181"> </a>
<a name="ln4182"> </a>
<a name="ln4183">bool</a>
<a name="ln4184">BWindow::IsFilePanel() const</a>
<a name="ln4185">{</a>
<a name="ln4186">	return fIsFilePanel;</a>
<a name="ln4187">}</a>
<a name="ln4188"> </a>
<a name="ln4189"> </a>
<a name="ln4190">void</a>
<a name="ln4191">BWindow::_GetDecoratorSize(float* _borderWidth, float* _tabHeight) const</a>
<a name="ln4192">{</a>
<a name="ln4193">	// fallback in case retrieving the decorator settings fails</a>
<a name="ln4194">	// (highly unlikely)</a>
<a name="ln4195">	float borderWidth = 5.0;</a>
<a name="ln4196">	float tabHeight = 21.0;</a>
<a name="ln4197"> </a>
<a name="ln4198">	BMessage settings;</a>
<a name="ln4199">	if (GetDecoratorSettings(&amp;settings) == B_OK) {</a>
<a name="ln4200">		BRect tabRect;</a>
<a name="ln4201">		if (settings.FindRect(&quot;tab frame&quot;, &amp;tabRect) == B_OK)</a>
<a name="ln4202">			tabHeight = tabRect.Height();</a>
<a name="ln4203">		settings.FindFloat(&quot;border width&quot;, &amp;borderWidth);</a>
<a name="ln4204">	} else {</a>
<a name="ln4205">		// probably no-border window look</a>
<a name="ln4206">		if (fLook == B_NO_BORDER_WINDOW_LOOK) {</a>
<a name="ln4207">			borderWidth = 0.0;</a>
<a name="ln4208">			tabHeight = 0.0;</a>
<a name="ln4209">		}</a>
<a name="ln4210">		// else use fall-back values from above</a>
<a name="ln4211">	}</a>
<a name="ln4212"> </a>
<a name="ln4213">	if (_borderWidth != NULL)</a>
<a name="ln4214">		*_borderWidth = borderWidth;</a>
<a name="ln4215">	if (_tabHeight != NULL)</a>
<a name="ln4216">		*_tabHeight = tabHeight;</a>
<a name="ln4217">}</a>
<a name="ln4218"> </a>
<a name="ln4219"> </a>
<a name="ln4220">void</a>
<a name="ln4221">BWindow::_SendShowOrHideMessage()</a>
<a name="ln4222">{</a>
<a name="ln4223">	fLink-&gt;StartMessage(AS_SHOW_OR_HIDE_WINDOW);</a>
<a name="ln4224">	fLink-&gt;Attach&lt;int32&gt;(fShowLevel);</a>
<a name="ln4225">	fLink-&gt;Flush();</a>
<a name="ln4226">}</a>
<a name="ln4227"> </a>
<a name="ln4228"> </a>
<a name="ln4229">//	#pragma mark - C++ binary compatibility kludge</a>
<a name="ln4230"> </a>
<a name="ln4231"> </a>
<a name="ln4232">extern &quot;C&quot; void</a>
<a name="ln4233">_ReservedWindow1__7BWindow(BWindow* window, BLayout* layout)</a>
<a name="ln4234">{</a>
<a name="ln4235">	// SetLayout()</a>
<a name="ln4236">	perform_data_set_layout data;</a>
<a name="ln4237">	data.layout = layout;</a>
<a name="ln4238">	window-&gt;Perform(PERFORM_CODE_SET_LAYOUT, &amp;data);</a>
<a name="ln4239">}</a>
<a name="ln4240"> </a>
<a name="ln4241"> </a>
<a name="ln4242">void BWindow::_ReservedWindow2() {}</a>
<a name="ln4243">void BWindow::_ReservedWindow3() {}</a>
<a name="ln4244">void BWindow::_ReservedWindow4() {}</a>
<a name="ln4245">void BWindow::_ReservedWindow5() {}</a>
<a name="ln4246">void BWindow::_ReservedWindow6() {}</a>
<a name="ln4247">void BWindow::_ReservedWindow7() {}</a>
<a name="ln4248">void BWindow::_ReservedWindow8() {}</a>
<a name="ln4249"> </a>

</code></pre>
<div class="balloon" rel="226"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: focus.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
