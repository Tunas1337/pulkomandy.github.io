
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>LoggingConsumer.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 1991-1999, Be Incorporated.</a>
<a name="ln3"> * Copyright (c) 1999-2000, Eric Moon.</a>
<a name="ln4"> * All rights reserved.</a>
<a name="ln5"> *</a>
<a name="ln6"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln7"> * modification, are permitted provided that the following conditions</a>
<a name="ln8"> * are met:</a>
<a name="ln9"> *</a>
<a name="ln10"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln11"> *    notice, this list of conditions, and the following disclaimer.</a>
<a name="ln12"> *</a>
<a name="ln13"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln14"> *    notice, this list of conditions, and the following disclaimer in the</a>
<a name="ln15"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln16"> *</a>
<a name="ln17"> * 3. The name of the author may not be used to endorse or promote products</a>
<a name="ln18"> *    derived from this software without specific prior written permission.</a>
<a name="ln19"> *</a>
<a name="ln20"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR &quot;AS IS&quot; AND ANY EXPRESS OR</a>
<a name="ln21"> * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</a>
<a name="ln22"> * OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR</a>
<a name="ln23"> * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY</a>
<a name="ln24"> * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</a>
<a name="ln25"> * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</a>
<a name="ln26"> * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED</a>
<a name="ln27"> * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR</a>
<a name="ln28"> * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</a>
<a name="ln29"> * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln30"> */</a>
<a name="ln31"> </a>
<a name="ln32"> </a>
<a name="ln33">// LoggingConsumer.cpp</a>
<a name="ln34"> </a>
<a name="ln35">#include &quot;LoggingConsumer.h&quot;</a>
<a name="ln36">#include &quot;LogWriter.h&quot;</a>
<a name="ln37">#include &lt;media/MediaRoster.h&gt;</a>
<a name="ln38">#include &lt;media/TimeSource.h&gt;</a>
<a name="ln39">#include &lt;media/ParameterWeb.h&gt;</a>
<a name="ln40">#include &lt;media/Buffer.h&gt;</a>
<a name="ln41">#include &lt;kernel/OS.h&gt;</a>
<a name="ln42">#include &lt;stdio.h&gt;</a>
<a name="ln43">#include &lt;string.h&gt;</a>
<a name="ln44"> </a>
<a name="ln45">// e.moon [11jun99]</a>
<a name="ln46">#include &lt;Debug.h&gt;</a>
<a name="ln47"> </a>
<a name="ln48">// id's of the node's BParameters</a>
<a name="ln49">const int32 INPUT_NULL_PARAM = 1;</a>
<a name="ln50">const int32 LATENCY_PARAM = 2;</a>
<a name="ln51">const int32 OUTPUT_NULL_PARAM = 3;</a>
<a name="ln52">const int32 CPU_NULL_PARAM = 11;</a>
<a name="ln53">const int32 CPU_SPIN_PARAM = 12;</a>
<a name="ln54">const int32 PRIO_NULL_PARAM = 21;</a>
<a name="ln55">const int32 PRIORITY_PARAM = 22;</a>
<a name="ln56"> </a>
<a name="ln57">// build the LoggingConsumer's BParameterWeb</a>
<a name="ln58">static BParameterWeb* build_parameter_web()</a>
<a name="ln59">{</a>
<a name="ln60">	BParameterWeb* web = new BParameterWeb;</a>
<a name="ln61"> </a>
<a name="ln62">	BParameterGroup* mainGroup = web-&gt;MakeGroup(&quot;LoggingConsumer Parameters&quot;);</a>
<a name="ln63">	BParameterGroup* group = mainGroup-&gt;MakeGroup(&quot;Latency control&quot;);</a>
<a name="ln64">	BParameter* nullParam = group-&gt;MakeNullParameter(INPUT_NULL_PARAM, B_MEDIA_NO_TYPE, &quot;Latency&quot;, B_GENERIC);</a>
<a name="ln65">	BParameter* latencyParam = group-&gt;MakeContinuousParameter(LATENCY_PARAM, B_MEDIA_NO_TYPE, &quot;&quot;,</a>
<a name="ln66">		B_GAIN, &quot;ms&quot;, 5, 100, 5);</a>
<a name="ln67">	nullParam-&gt;AddOutput(latencyParam);</a>
<a name="ln68">	latencyParam-&gt;AddInput(nullParam);</a>
<a name="ln69"> </a>
<a name="ln70">	group = mainGroup-&gt;MakeGroup(&quot;CPU percentage&quot;);</a>
<a name="ln71">	nullParam = group-&gt;MakeNullParameter(CPU_NULL_PARAM, B_MEDIA_NO_TYPE, &quot;CPU spin percentage&quot;, B_GENERIC);</a>
<a name="ln72">	BContinuousParameter* cpuParam = group-&gt;MakeContinuousParameter(CPU_SPIN_PARAM, B_MEDIA_NO_TYPE, &quot;&quot;,</a>
<a name="ln73">		B_GAIN, &quot;percent&quot;, 5, 80, 5);</a>
<a name="ln74">	nullParam-&gt;AddOutput(cpuParam);</a>
<a name="ln75">	cpuParam-&gt;AddInput(nullParam);</a>
<a name="ln76"> </a>
<a name="ln77">	group = mainGroup-&gt;MakeGroup(&quot;Priority&quot;);</a>
<a name="ln78">	nullParam = group-&gt;MakeNullParameter(PRIO_NULL_PARAM, B_MEDIA_NO_TYPE, &quot;Thread priority&quot;, B_GENERIC);</a>
<a name="ln79">	BDiscreteParameter* prioParam = group-&gt;MakeDiscreteParameter(PRIORITY_PARAM, B_MEDIA_NO_TYPE, &quot;&quot;, B_GENERIC);</a>
<a name="ln80">	prioParam-&gt;AddItem(5, &quot;B_LOW_PRIORITY&quot;);</a>
<a name="ln81">	prioParam-&gt;AddItem(10, &quot;B_NORMAL_PRIORITY&quot;);</a>
<a name="ln82">	prioParam-&gt;AddItem(15, &quot;B_DISPLAY_PRIORITY&quot;);</a>
<a name="ln83">	prioParam-&gt;AddItem(20, &quot;B_URGENT_DISPLAY_PRIORITY&quot;);</a>
<a name="ln84">	prioParam-&gt;AddItem(100, &quot;B_REAL_TIME_DISPLAY_PRIORITY&quot;);</a>
<a name="ln85">	prioParam-&gt;AddItem(110, &quot;B_URGENT_PRIORITY&quot;);</a>
<a name="ln86">	prioParam-&gt;AddItem(120, &quot;B_REAL_TIME_PRIORITY&quot;);</a>
<a name="ln87"> </a>
<a name="ln88">	return web;</a>
<a name="ln89">}</a>
<a name="ln90"> </a>
<a name="ln91">// --------------------</a>
<a name="ln92">// LoggingConsumer class implementation</a>
<a name="ln93">LoggingConsumer::LoggingConsumer(</a>
<a name="ln94">	const entry_ref&amp; logFile,</a>
<a name="ln95">	BMediaAddOn* pAddOn)</a>
<a name="ln96"> </a>
<a name="ln97">	:	BMediaNode(&quot;LoggingConsumer&quot;),</a>
<a name="ln98">		BBufferConsumer(B_MEDIA_UNKNOWN_TYPE),</a>
<a name="ln99">		BControllable(),</a>
<a name="ln100">		BMediaEventLooper(),</a>
<a name="ln101">		mLogRef(logFile),</a>
<a name="ln102">		mWeb(NULL),</a>
<a name="ln103">		mLateBuffers(0),</a>
<a name="ln104">		mLatency(50 * 1000),		// default to 50 milliseconds</a>
<a name="ln105">		mSpinPercentage(0.10),		// default to spinning 10% of total latency</a>
<a name="ln106">		mPriority(B_URGENT_DISPLAY_PRIORITY),		// !!! testing; will be B_REAL_TIME_PRIORITY for release</a>
<a name="ln107">		mLastLatencyChange(0),</a>
<a name="ln108">		mLastSpinChange(0),</a>
<a name="ln109">		mLastPrioChange(0),</a>
<a name="ln110">		m_pAddOn(pAddOn)</a>
<a name="ln111">{</a>
<a name="ln112">	// spin off the logging thread</a>
<a name="ln113">	mLogger = new LogWriter(logFile);</a>
<a name="ln114"> </a>
<a name="ln115">	// parameter-web init moved to NodeRegistered()</a>
<a name="ln116">	// e.moon [11jun99]</a>
<a name="ln117">}</a>
<a name="ln118"> </a>
<a name="ln119">LoggingConsumer::~LoggingConsumer()</a>
<a name="ln120">{</a>
<a name="ln121">	PRINT((&quot;~LoggingConsumer()\n&quot;));</a>
<a name="ln122">	BMediaEventLooper::Quit();</a>
<a name="ln123">// ahem:</a>
<a name="ln124">// &quot;Once you've called BControllable::SetParameterWeb(), the node takes</a>
<a name="ln125">//  responsibility for the parameter web object and you shouldn't delete it. &quot;</a>
<a name="ln126">//	SetParameterWeb(NULL);</a>
<a name="ln127">//	delete mWeb;</a>
<a name="ln128"> </a>
<a name="ln129">	// delete the logging thread only after the looper thread has quit, otherwise there's</a>
<a name="ln130">	// a potential race condition with the looper thread trying to write to the now-</a>
<a name="ln131">	// deleted log</a>
<a name="ln132">	delete mLogger;</a>
<a name="ln133">}</a>
<a name="ln134"> </a>
<a name="ln135">//</a>
<a name="ln136">// Log message filtering control</a>
<a name="ln137">//</a>
<a name="ln138"> </a>
<a name="ln139">void</a>
<a name="ln140">LoggingConsumer::SetEnabled(log_what what, bool enable)</a>
<a name="ln141">{</a>
<a name="ln142">	mLogger-&gt;SetEnabled(what, enable);</a>
<a name="ln143">}</a>
<a name="ln144"> </a>
<a name="ln145">void</a>
<a name="ln146">LoggingConsumer::EnableAllMessages()</a>
<a name="ln147">{</a>
<a name="ln148">	mLogger-&gt;EnableAllMessages();</a>
<a name="ln149">}</a>
<a name="ln150"> </a>
<a name="ln151">void</a>
<a name="ln152">LoggingConsumer::DisableAllMessages()</a>
<a name="ln153">{</a>
<a name="ln154">	mLogger-&gt;DisableAllMessages();</a>
<a name="ln155">}</a>
<a name="ln156"> </a>
<a name="ln157">//</a>
<a name="ln158">// BMediaNode methods</a>
<a name="ln159">//</a>
<a name="ln160"> </a>
<a name="ln161"> </a>
<a name="ln162">BMediaAddOn*</a>
<a name="ln163">LoggingConsumer::AddOn(int32 *internal_id) const</a>
<a name="ln164">{</a>
<a name="ln165">	PRINT((&quot;~LoggingConsumer::AddOn()\n&quot;));</a>
<a name="ln166">	// e.moon [11jun99]</a>
<a name="ln167">	if(m_pAddOn) {</a>
<a name="ln168">		*internal_id = 0;</a>
<a name="ln169">		return m_pAddOn;</a>
<a name="ln170">	} else</a>
<a name="ln171">		return NULL;</a>
<a name="ln172">}</a>
<a name="ln173"> </a>
<a name="ln174">void</a>
<a name="ln175">LoggingConsumer::SetRunMode(run_mode mode)</a>
<a name="ln176">{</a>
<a name="ln177">	// !!! Need to handle offline mode etc. properly!</a>
<a name="ln178">	log_message logMsg;</a>
<a name="ln179">	logMsg.now = TimeSource()-&gt;Now();</a>
<a name="ln180">	mLogger-&gt;Log(LOG_SET_RUN_MODE, logMsg);</a>
<a name="ln181"> </a>
<a name="ln182">	BMediaEventLooper::SetRunMode(mode);</a>
<a name="ln183">}</a>
<a name="ln184"> </a>
<a name="ln185">void</a>
<a name="ln186">LoggingConsumer::Preroll()</a>
<a name="ln187">{</a>
<a name="ln188">	log_message logMsg;</a>
<a name="ln189">	logMsg.now = TimeSource()-&gt;Now();</a>
<a name="ln190">	mLogger-&gt;Log(LOG_PREROLL, logMsg);</a>
<a name="ln191"> </a>
<a name="ln192">	BMediaEventLooper::Preroll();</a>
<a name="ln193">}</a>
<a name="ln194"> </a>
<a name="ln195">void</a>
<a name="ln196">LoggingConsumer::SetTimeSource(BTimeSource* time_source)</a>
<a name="ln197">{</a>
<a name="ln198">	log_message logMsg;</a>
<a name="ln199">	logMsg.now = TimeSource()-&gt;Now();</a>
<a name="ln200">	mLogger-&gt;Log(LOG_SET_TIME_SOURCE, logMsg);</a>
<a name="ln201"> </a>
<a name="ln202">	BMediaNode::SetTimeSource(time_source);</a>
<a name="ln203">}</a>
<a name="ln204"> </a>
<a name="ln205">status_t</a>
<a name="ln206">LoggingConsumer::RequestCompleted(const media_request_info &amp;info)</a>
<a name="ln207">{</a>
<a name="ln208">	log_message logMsg;</a>
<a name="ln209">	logMsg.now = TimeSource()-&gt;Now();</a>
<a name="ln210">	mLogger-&gt;Log(LOG_REQUEST_COMPLETED, logMsg);</a>
<a name="ln211"> </a>
<a name="ln212">	return BMediaNode::RequestCompleted(info);</a>
<a name="ln213">}</a>
<a name="ln214"> </a>
<a name="ln215">// e.moon [11jun99; testing add-on]</a>
<a name="ln216">status_t</a>
<a name="ln217">LoggingConsumer::DeleteHook(BMediaNode* pNode) {</a>
<a name="ln218">	PRINT((&quot;LoggingConsumer::DeleteHook(%p)\n&quot;, pNode));</a>
<a name="ln219">	return BBufferConsumer::DeleteHook(pNode);</a>
<a name="ln220">//	ASSERT(pNode == this);</a>
<a name="ln221">//	delete this;</a>
<a name="ln222">//	return B_OK;</a>
<a name="ln223">}</a>
<a name="ln224"> </a>
<a name="ln225">//</a>
<a name="ln226">// BControllable methods</a>
<a name="ln227">//</a>
<a name="ln228"> </a>
<a name="ln229">status_t</a>
<a name="ln230">LoggingConsumer::GetParameterValue(int32 id, bigtime_t* last_change, void* value, size_t* ioSize)</a>
<a name="ln231">{</a>
<a name="ln232">	log_message logMsg;</a>
<a name="ln233">	logMsg.now = TimeSource()-&gt;Now();</a>
<a name="ln234">	logMsg.param.id = id;</a>
<a name="ln235">	mLogger-&gt;Log(LOG_GET_PARAM_VALUE, logMsg);</a>
<a name="ln236"> </a>
<a name="ln237">	// return an error if the caller hasn't reserved enough space for the parameter data.</a>
<a name="ln238">	// we know that all of our parameters fit in a float or int32 (4 bytes), so we can just</a>
<a name="ln239">	// check for it once here, instead of on a per-parameter basis</a>
<a name="ln240">	if (*ioSize &lt; sizeof(float)) return B_ERROR;</a>
<a name="ln241"> </a>
<a name="ln242">	// write out the designated parameter data</a>
<a name="ln243">	switch (id)</a>
<a name="ln244">	{</a>
<a name="ln245">	case LATENCY_PARAM:</a>
<a name="ln246">		*last_change = mLastLatencyChange;</a>
<a name="ln247">		*((float*) value) = mLatency / 1000;		// the BParameter reads milliseconds, not microseconds</a>
<a name="ln248">		*ioSize = sizeof(float);</a>
<a name="ln249">		break;</a>
<a name="ln250"> </a>
<a name="ln251">	case CPU_SPIN_PARAM:</a>
<a name="ln252">		*last_change = mLastSpinChange;</a>
<a name="ln253">		*((float*) value) = mSpinPercentage;</a>
<a name="ln254">		*ioSize = sizeof(float);</a>
<a name="ln255">		break;</a>
<a name="ln256"> </a>
<a name="ln257">	case PRIORITY_PARAM:</a>
<a name="ln258">		*last_change = mLastPrioChange;</a>
<a name="ln259">		*((int32*) value) = mPriority;</a>
<a name="ln260">		*ioSize = sizeof(int32);</a>
<a name="ln261">		break;</a>
<a name="ln262"> </a>
<a name="ln263">	default:</a>
<a name="ln264">		return B_ERROR;</a>
<a name="ln265">	}</a>
<a name="ln266"> </a>
<a name="ln267">	return B_OK;</a>
<a name="ln268">}</a>
<a name="ln269"> </a>
<a name="ln270">void</a>
<a name="ln271">LoggingConsumer::SetParameterValue(int32 id, bigtime_t performance_time, const void* value, size_t size)</a>
<a name="ln272">{</a>
<a name="ln273">	log_message logMsg;</a>
<a name="ln274">	logMsg.now = TimeSource()-&gt;Now();</a>
<a name="ln275">	logMsg.param.id = id;</a>
<a name="ln276">	mLogger-&gt;Log(LOG_SET_PARAM_VALUE, logMsg);</a>
<a name="ln277"> </a>
<a name="ln278">	// if it's one of our parameters, enqueue a &quot;set parameter&quot; event for handling at the appropriate time</a>
<a name="ln279">	switch (id)</a>
<a name="ln280">	{</a>
<a name="ln281">	case LATENCY_PARAM:</a>
<a name="ln282">	case CPU_SPIN_PARAM:</a>
<a name="ln283">	case PRIORITY_PARAM:</a>
<a name="ln284">		{</a>
<a name="ln285">			// !!! Change from B_USER_EVENT to B_SET_PARAMETER once it's defined</a>
<a name="ln286">			media_timed_event event(performance_time, BTimedEventQueue::B_USER_EVENT,</a>
<a name="ln287">				(void*) value, BTimedEventQueue::B_NO_CLEANUP, size, id, NULL);</a>
<a name="ln288">			EventQueue()-&gt;AddEvent(event);</a>
<a name="ln289">		}</a>
<a name="ln290">		break;</a>
<a name="ln291"> </a>
<a name="ln292">	default:		// do nothing for other parameter IDs</a>
<a name="ln293">		break;</a>
<a name="ln294">	}</a>
<a name="ln295">	return;</a>
<a name="ln296">}</a>
<a name="ln297"> </a>
<a name="ln298">//</a>
<a name="ln299">// BBufferConsumer methods</a>
<a name="ln300">//</a>
<a name="ln301"> </a>
<a name="ln302">status_t</a>
<a name="ln303">LoggingConsumer::HandleMessage(int32 message, const void *data, size_t size)</a>
<a name="ln304">{</a>
<a name="ln305">	log_message logMsg;</a>
<a name="ln306">	logMsg.now = TimeSource()-&gt;Now();</a>
<a name="ln307">	mLogger-&gt;Log(LOG_HANDLE_MESSAGE, logMsg);</a>
<a name="ln308"> </a>
<a name="ln309">	// try each of our superclasses to handle the message</a>
<a name="ln310">	status_t err;</a>
<a name="ln311">	err = BControllable::HandleMessage(message, data, size);</a>
<a name="ln312">	if (err) err = BBufferConsumer::HandleMessage(message, data, size);</a>
<a name="ln313">	if (err) err = BMediaNode::HandleMessage(message, data, size);</a>
<a name="ln314">	return err;</a>
<a name="ln315">}</a>
<a name="ln316"> </a>
<a name="ln317">// all of these next methods are pure virtual in BBufferConsumer</a>
<a name="ln318"> </a>
<a name="ln319">status_t</a>
<a name="ln320">LoggingConsumer::AcceptFormat(const media_destination&amp; dest, media_format* format)</a>
<a name="ln321">{</a>
<a name="ln322">	char formatStr[256];</a>
<a name="ln323">	string_for_format(*format, formatStr, 255);</a>
<a name="ln324">	PRINT((&quot;LoggingConsumer::AcceptFormat:\n\tformat %s\n&quot;, formatStr));</a>
<a name="ln325"> </a>
<a name="ln326">	log_message logMsg;</a>
<a name="ln327">	logMsg.now = TimeSource()-&gt;Now();</a>
<a name="ln328">	mLogger-&gt;Log(LOG_ACCEPT_FORMAT, logMsg);</a>
<a name="ln329"> </a>
<a name="ln330">	// return an error if this isn't really our one input's destination</a>
<a name="ln331">	if (dest != mInput.destination) return B_MEDIA_BAD_DESTINATION;</a>
<a name="ln332"> </a>
<a name="ln333">	// the destination given really is our input, and we accept any kind of media data,</a>
<a name="ln334">	// so now we just confirm that we can handle whatever the producer asked for.</a>
<a name="ln335">	return B_OK;</a>
<a name="ln336">}</a>
<a name="ln337"> </a>
<a name="ln338">status_t</a>
<a name="ln339">LoggingConsumer::GetNextInput(int32* cookie, media_input* out_input)</a>
<a name="ln340">{</a>
<a name="ln341">	// we have a single hardcoded input that can accept any kind of media data</a>
<a name="ln342">	if (0 == *cookie)</a>
<a name="ln343">	{</a>
<a name="ln344">		mInput.format.type = B_MEDIA_UNKNOWN_TYPE;		// accept any format</a>
<a name="ln345"> </a>
<a name="ln346">		*out_input = mInput;</a>
<a name="ln347">		*cookie = 1;</a>
<a name="ln348">		return B_OK;</a>
<a name="ln349">	}</a>
<a name="ln350">	else return B_BAD_INDEX;</a>
<a name="ln351">}</a>
<a name="ln352"> </a>
<a name="ln353">void</a>
<a name="ln354">LoggingConsumer::DisposeInputCookie(int32 /*cookie*/ )</a>
<a name="ln355">{</a>
<a name="ln356">	// we don't use any kind of state or extra storage for iterating over our</a>
<a name="ln357">	// inputs, so we don't have to do any special disposal of input cookies.</a>
<a name="ln358">}</a>
<a name="ln359"> </a>
<a name="ln360">void</a>
<a name="ln361">LoggingConsumer::BufferReceived(BBuffer* buffer)</a>
<a name="ln362">{</a>
<a name="ln363">	bigtime_t bufferStart = buffer-&gt;Header()-&gt;start_time;</a>
<a name="ln364">	bigtime_t now = TimeSource()-&gt;Now();</a>
<a name="ln365">	bigtime_t how_early = bufferStart - EventLatency() - SchedulingLatency() - now;</a>
<a name="ln366"> </a>
<a name="ln367">	log_message logMsg;</a>
<a name="ln368">	logMsg.now = now;</a>
<a name="ln369">	logMsg.buffer_data.start_time = bufferStart;</a>
<a name="ln370">	logMsg.buffer_data.offset = how_early;</a>
<a name="ln371">	mLogger-&gt;Log(LOG_BUFFER_RECEIVED, logMsg);</a>
<a name="ln372"> </a>
<a name="ln373">	// There's a special case here with handling B_MEDIA_PARAMETERS buffers.</a>
<a name="ln374">	// These contain sets of parameter value changes, with their own performance</a>
<a name="ln375">	// times embedded in the buffers.  So, we want to dispatch those parameter</a>
<a name="ln376">	// changes as their own events rather than pushing this buffer on the queue to</a>
<a name="ln377">	// be handled later.</a>
<a name="ln378">	if (B_MEDIA_PARAMETERS == buffer-&gt;Header()-&gt;type)</a>
<a name="ln379">	{</a>
<a name="ln380">		ApplyParameterData(buffer-&gt;Data(), buffer-&gt;SizeUsed());</a>
<a name="ln381">		buffer-&gt;Recycle();</a>
<a name="ln382">	}</a>
<a name="ln383">	else		// ahh, it's a regular media buffer, so push it on the event queue</a>
<a name="ln384">	{</a>
<a name="ln385">		status_t err;</a>
<a name="ln386">		media_timed_event event(buffer-&gt;Header()-&gt;start_time, BTimedEventQueue::B_HANDLE_BUFFER,</a>
<a name="ln387">			buffer, BTimedEventQueue::B_RECYCLE_BUFFER);</a>
<a name="ln388">		err = EventQueue()-&gt;AddEvent(event);</a>
<a name="ln389"> </a>
<a name="ln390">		// HandleEvent() will recycle the buffer.  However, if we incurred an error trying to</a>
<a name="ln391">		// put the event into the queue, we have to recycle it ourselves, since HandleEvent()</a>
<a name="ln392">		// will never see the buffer in that case.</a>
<a name="ln393">		if (err) buffer-&gt;Recycle();</a>
<a name="ln394">	}</a>
<a name="ln395">}</a>
<a name="ln396"> </a>
<a name="ln397">void</a>
<a name="ln398">LoggingConsumer::ProducerDataStatus(const media_destination&amp; for_whom, int32 status, bigtime_t at_performance_time)</a>
<a name="ln399">{</a>
<a name="ln400">	log_message logMsg;</a>
<a name="ln401">	logMsg.now = TimeSource()-&gt;Now();</a>
<a name="ln402">	logMsg.data_status.status = status;</a>
<a name="ln403">	mLogger-&gt;Log(LOG_PRODUCER_DATA_STATUS, logMsg);</a>
<a name="ln404"> </a>
<a name="ln405">	if (for_whom == mInput.destination)</a>
<a name="ln406">	{</a>
<a name="ln407">		media_timed_event event(at_performance_time, BTimedEventQueue::B_DATA_STATUS,</a>
<a name="ln408">			&amp;mInput, BTimedEventQueue::B_NO_CLEANUP, status, 0, NULL);</a>
<a name="ln409">		EventQueue()-&gt;AddEvent(event);</a>
<a name="ln410">	}</a>
<a name="ln411">}</a>
<a name="ln412"> </a>
<a name="ln413">status_t</a>
<a name="ln414">LoggingConsumer::GetLatencyFor(const media_destination&amp; for_whom, bigtime_t* out_latency, media_node_id* out_timesource)</a>
<a name="ln415">{</a>
<a name="ln416">	// make sure this is one of my valid inputs</a>
<a name="ln417">	if (for_whom != mInput.destination) return B_MEDIA_BAD_DESTINATION;</a>
<a name="ln418"> </a>
<a name="ln419">	// report internal latency + downstream latency here, NOT including scheduling latency.</a>
<a name="ln420">	// we're a final consumer (no outputs), so we have no downstream latency.</a>
<a name="ln421">	*out_latency = mLatency;</a>
<a name="ln422">	*out_timesource = TimeSource()-&gt;ID();</a>
<a name="ln423">	return B_OK;</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426">status_t</a>
<a name="ln427">LoggingConsumer::Connected(</a>
<a name="ln428">	const media_source&amp; producer,</a>
<a name="ln429">	const media_destination&amp; where,</a>
<a name="ln430">	const media_format&amp; with_format,</a>
<a name="ln431">	media_input* out_input)</a>
<a name="ln432">{</a>
<a name="ln433"> </a>
<a name="ln434">	char formatStr[256];</a>
<a name="ln435">	string_for_format(with_format, formatStr, 255);</a>
<a name="ln436">	PRINT((&quot;LoggingConsumer::Connected:\n\tformat %s\n&quot;, formatStr));</a>
<a name="ln437">	string_for_format(mInput.format, formatStr, 255);</a>
<a name="ln438">	PRINT((&quot;\tinput format %s\n&quot;, formatStr));</a>
<a name="ln439"> </a>
<a name="ln440">	log_message logMsg;</a>
<a name="ln441">	logMsg.now = TimeSource()-&gt;Now();</a>
<a name="ln442">	mLogger-&gt;Log(LOG_CONNECTED, logMsg);</a>
<a name="ln443"> </a>
<a name="ln444">	if (where != mInput.destination) return B_MEDIA_BAD_DESTINATION;</a>
<a name="ln445"> </a>
<a name="ln446">	// calculate my latency here, because it may depend on buffer sizes/durations, then</a>
<a name="ln447">	// tell the BMediaEventLooper how early we need to get the buffers</a>
<a name="ln448">	SetEventLatency(mLatency);</a>
<a name="ln449"> </a>
<a name="ln450">	// record useful information about the connection, and return success</a>
<a name="ln451">	// * e.moon [14jun99]: stores format</a>
<a name="ln452">	mInput.format = with_format;</a>
<a name="ln453">	mInput.source = producer;</a>
<a name="ln454">	*out_input = mInput;</a>
<a name="ln455">	return B_OK;</a>
<a name="ln456">}</a>
<a name="ln457"> </a>
<a name="ln458">void</a>
<a name="ln459">LoggingConsumer::Disconnected(</a>
<a name="ln460">	const media_source&amp; producer,</a>
<a name="ln461">	const media_destination&amp; where)</a>
<a name="ln462">{</a>
<a name="ln463">	log_message logMsg;</a>
<a name="ln464">	logMsg.now = TimeSource()-&gt;Now();</a>
<a name="ln465">	mLogger-&gt;Log(LOG_DISCONNECTED, logMsg);</a>
<a name="ln466"> </a>
<a name="ln467">	// wipe out our input record</a>
<a name="ln468">	mInput = media_input();</a>
<a name="ln469">}</a>
<a name="ln470"> </a>
<a name="ln471">status_t</a>
<a name="ln472">LoggingConsumer::FormatChanged(</a>
<a name="ln473">	const media_source&amp; producer,</a>
<a name="ln474">	const media_destination&amp; consumer,</a>
<a name="ln475">	int32 change_tag,</a>
<a name="ln476">	const media_format&amp; format)</a>
<a name="ln477">{</a>
<a name="ln478">	log_message logMsg;</a>
<a name="ln479">	logMsg.now = TimeSource()-&gt;Now();</a>
<a name="ln480">	mLogger-&gt;Log(LOG_FORMAT_CHANGED, logMsg);</a>
<a name="ln481"> </a>
<a name="ln482">	return B_OK;</a>
<a name="ln483">}</a>
<a name="ln484"> </a>
<a name="ln485">status_t</a>
<a name="ln486">LoggingConsumer::SeekTagRequested(</a>
<a name="ln487">	const media_destination&amp; destination,</a>
<a name="ln488">	bigtime_t in_target_time,</a>
<a name="ln489">	uint32 in_flags,</a>
<a name="ln490">	media_seek_tag* out_seek_tag,</a>
<a name="ln491">	bigtime_t* out_tagged_time,</a>
<a name="ln492">	uint32* out_flags)</a>
<a name="ln493">{</a>
<a name="ln494">	log_message logMsg;</a>
<a name="ln495">	logMsg.now = TimeSource()-&gt;Now();</a>
<a name="ln496">	mLogger-&gt;Log(LOG_SEEK_TAG, logMsg);</a>
<a name="ln497"> </a>
<a name="ln498">	return B_OK;</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501">//</a>
<a name="ln502">// BMediaEventLooper virtual methods</a>
<a name="ln503">//</a>
<a name="ln504"> </a>
<a name="ln505">void</a>
<a name="ln506">LoggingConsumer::NodeRegistered()</a>
<a name="ln507">{</a>
<a name="ln508">	log_message logMsg;</a>
<a name="ln509">	logMsg.now = TimeSource()-&gt;Now();</a>
<a name="ln510">	mLogger-&gt;Log(LOG_REGISTERED, logMsg);</a>
<a name="ln511"> </a>
<a name="ln512">	// publish our parameter web</a>
<a name="ln513">	mWeb = build_parameter_web();</a>
<a name="ln514">	SetParameterWeb(mWeb);</a>
<a name="ln515"> </a>
<a name="ln516">	// Set our priority and start the BMediaEventLooper's thread</a>
<a name="ln517">	SetPriority(mPriority);</a>
<a name="ln518">	Run();</a>
<a name="ln519"> </a>
<a name="ln520">	// Initialize as much of our input as we can, now that the Media Kit really &quot;knows&quot; about us</a>
<a name="ln521">	mInput.destination.port = ControlPort();</a>
<a name="ln522">	mInput.destination.id = 0;</a>
<a name="ln523">	mInput.node = Node();</a>
<a name="ln524">	strcpy(mInput.name, &quot;Logged input&quot;);</a>
<a name="ln525">}</a>
<a name="ln526"> </a>
<a name="ln527">void</a>
<a name="ln528">LoggingConsumer::Start(bigtime_t performance_time)</a>
<a name="ln529">{</a>
<a name="ln530">	PRINT((&quot;LoggingConsumer::Start(%&quot; B_PRIdBIGTIME &quot;): now %&quot; B_PRIdBIGTIME &quot;\n&quot;,</a>
<a name="ln531">		performance_time, TimeSource()-&gt;Now()));</a>
<a name="ln532"> </a>
<a name="ln533">	log_message logMsg;</a>
<a name="ln534">	logMsg.now = TimeSource()-&gt;Now();</a>
<a name="ln535">	mLogger-&gt;Log(LOG_START, logMsg);</a>
<a name="ln536"> </a>
<a name="ln537">	BMediaEventLooper::Start(performance_time);</a>
<a name="ln538">}</a>
<a name="ln539"> </a>
<a name="ln540">void</a>
<a name="ln541">LoggingConsumer::Stop(bigtime_t performance_time, bool immediate)</a>
<a name="ln542">{</a>
<a name="ln543">	log_message logMsg;</a>
<a name="ln544">	logMsg.now = TimeSource()-&gt;Now();</a>
<a name="ln545">	mLogger-&gt;Log(LOG_STOP, logMsg);</a>
<a name="ln546"> </a>
<a name="ln547">	BMediaEventLooper::Stop(performance_time, immediate);</a>
<a name="ln548">}</a>
<a name="ln549"> </a>
<a name="ln550">void</a>
<a name="ln551">LoggingConsumer::Seek(bigtime_t media_time, bigtime_t performance_time)</a>
<a name="ln552">{</a>
<a name="ln553">	log_message logMsg;</a>
<a name="ln554">	logMsg.now = TimeSource()-&gt;Now();</a>
<a name="ln555">	mLogger-&gt;Log(LOG_SEEK, logMsg);</a>
<a name="ln556"> </a>
<a name="ln557">	BMediaEventLooper::Seek(media_time, performance_time);</a>
<a name="ln558">}</a>
<a name="ln559"> </a>
<a name="ln560">void</a>
<a name="ln561">LoggingConsumer::TimeWarp(bigtime_t at_real_time, bigtime_t to_performance_time)</a>
<a name="ln562">{</a>
<a name="ln563">	log_message logMsg;</a>
<a name="ln564">	logMsg.now = TimeSource()-&gt;Now();</a>
<a name="ln565">	mLogger-&gt;Log(LOG_TIMEWARP, logMsg);</a>
<a name="ln566"> </a>
<a name="ln567">	BMediaEventLooper::TimeWarp(at_real_time, to_performance_time);</a>
<a name="ln568">}</a>
<a name="ln569"> </a>
<a name="ln570">void</a>
<a name="ln571">LoggingConsumer::HandleEvent(const media_timed_event *event, bigtime_t /* lateness */, bool /* realTimeEvent */)</a>
<a name="ln572">{</a>
<a name="ln573">	log_message logMsg;</a>
<a name="ln574">	logMsg.now = TimeSource()-&gt;Now();</a>
<a name="ln575">	mLogger-&gt;Log(LOG_HANDLE_EVENT, logMsg);</a>
<a name="ln576"> </a>
<a name="ln577">	switch (event-&gt;type)</a>
<a name="ln578">	{</a>
<a name="ln579">	case BTimedEventQueue::B_HANDLE_BUFFER:</a>
<a name="ln580">		{</a>
<a name="ln581">			BBuffer* buffer = const_cast&lt;BBuffer*&gt;((BBuffer*) event-&gt;pointer);</a>
<a name="ln582">			if (buffer)</a>
<a name="ln583">			{</a>
<a name="ln584">				media_header* hdr = buffer-&gt;Header();</a>
<a name="ln585">				if (hdr-&gt;destination == mInput.destination.id)</a>
<a name="ln586">				{</a>
<a name="ln587">					bigtime_t now = TimeSource()-&gt;Now();</a>
<a name="ln588">					bigtime_t perf_time = hdr-&gt;start_time;</a>
<a name="ln589"> </a>
<a name="ln590">					// the how_early calculated here doesn't include scheduling latency because</a>
<a name="ln591">					// we've already been scheduled to handle the buffer</a>
<a name="ln592">					bigtime_t how_early = perf_time - mLatency - now;</a>
<a name="ln593"> </a>
<a name="ln594">					// logMsg.now is already set</a>
<a name="ln595">					logMsg.buffer_data.start_time = perf_time;</a>
<a name="ln596">					logMsg.buffer_data.offset = how_early;</a>
<a name="ln597">					mLogger-&gt;Log(LOG_BUFFER_HANDLED, logMsg);</a>
<a name="ln598"> </a>
<a name="ln599">					// if the buffer is late, we ignore it and report the fact to the producer</a>
<a name="ln600">					// who sent it to us</a>
<a name="ln601">					if (how_early &lt; 0)</a>
<a name="ln602">					{</a>
<a name="ln603">						mLateBuffers++;</a>
<a name="ln604">						NotifyLateProducer(mInput.source, -how_early, perf_time);</a>
<a name="ln605">					}</a>
<a name="ln606">					else</a>
<a name="ln607">					{</a>
<a name="ln608">						// burn some percentage of our stated latency in CPU time (controlled by</a>
<a name="ln609">						// a BParameter).  this simulates a user-configurable amount of CPU cost</a>
<a name="ln610">						// associated with the consumer.</a>
<a name="ln611">						bigtime_t spin_start = ::system_time();</a>
<a name="ln612">						bigtime_t spin_now = spin_start;</a>
<a name="ln613">						bigtime_t usecToSpin = bigtime_t(mSpinPercentage / 100.0 * mLatency);</a>
<a name="ln614">						while (spin_now - spin_start &lt; usecToSpin)</a>
<a name="ln615">						{</a>
<a name="ln616">							for (long k = 0; k &lt; 1000000; k++) { /* intentionally blank */ }</a>
<a name="ln617">							spin_now = ::system_time();</a>
<a name="ln618">						}</a>
<a name="ln619">					}</a>
<a name="ln620"> </a>
<a name="ln621">					// we're done &quot;processing the buffer;&quot; now we recycle it and return to the loop</a>
<a name="ln622">					buffer-&gt;Recycle();</a>
<a name="ln623">				}</a>
<a name="ln624">				else</a>
<a name="ln625">				{</a>
<a name="ln626">					//fprintf(stderr, &quot;* Woah!  Got a buffer for a different destination!\n&quot;);</a>
<a name="ln627">				}</a>
<a name="ln628">			}</a>
<a name="ln629">		}</a>
<a name="ln630">		break;</a>
<a name="ln631"> </a>
<a name="ln632">	// !!! change to B_PARAMETER as soon as it's available</a>
<a name="ln633"> </a>
<a name="ln634">	// +++++ e.moon [16jun99]</a>
<a name="ln635">	// !!! this can't be right: the parameter value is accessed by the pointer</a>
<a name="ln636">	//     originally passed to SetParameterValue().  there's no guarantee that</a>
<a name="ln637">	//     value's still valid, is there?</a>
<a name="ln638"> </a>
<a name="ln639">	case BTimedEventQueue::B_USER_EVENT:</a>
<a name="ln640">		{</a>
<a name="ln641">			size_t dataSize = size_t(event-&gt;data);</a>
<a name="ln642">			int32 param = int32(event-&gt;bigdata);</a>
<a name="ln643">			logMsg.param.id = param;</a>
<a name="ln644"> </a>
<a name="ln645">			// handle the message if there's sufficient data provided.  we only check against</a>
<a name="ln646">			// sizeof(float) because all of our parameters happen to be 4 bytes.  if various</a>
<a name="ln647">			// parameters took different amounts of data, we'd check the size on a per-parameter</a>
<a name="ln648">			// basis.</a>
<a name="ln649">			if (dataSize &gt;= sizeof(float)) switch (param)</a>
<a name="ln650">			{</a>
<a name="ln651">			case LATENCY_PARAM:</a>
<a name="ln652">				{</a>
<a name="ln653">					float value = *((float*) event-&gt;pointer);</a>
<a name="ln654">					mLatency = bigtime_t(value* 1000);</a>
<a name="ln655">					mLastLatencyChange = logMsg.now;</a>
<a name="ln656"> </a>
<a name="ln657">					// my latency just changed, so reconfigure the BMediaEventLooper</a>
<a name="ln658">					// to give me my events at the proper time</a>
<a name="ln659">					SetEventLatency(mLatency);</a>
<a name="ln660"> </a>
<a name="ln661">					// tell the producer that my latency changed, and broadcast a message</a>
<a name="ln662">					// about the parameter change to any applications that may be looking</a>
<a name="ln663">					// for it through the BMediaRoster::StartWatching() mechanism.</a>
<a name="ln664">					//</a>
<a name="ln665">					// if we had more than one input, we'd need to tell *all* producers about</a>
<a name="ln666">					// the change in our latency.</a>
<a name="ln667">					SendLatencyChange(mInput.source, mInput.destination, EventLatency() + SchedulingLatency());</a>
<a name="ln668">					BroadcastNewParameterValue(logMsg.now, param, &amp;value, sizeof(value));</a>
<a name="ln669"> </a>
<a name="ln670">					// log the new latency value, for recordkeeping</a>
<a name="ln671">					logMsg.param.value = value;</a>
<a name="ln672">					mLogger-&gt;Log(LOG_SET_PARAM_HANDLED, logMsg);</a>
<a name="ln673">				}</a>
<a name="ln674">				break;</a>
<a name="ln675"> </a>
<a name="ln676">			case CPU_SPIN_PARAM:</a>
<a name="ln677">				{</a>
<a name="ln678">					float value = *((float*) event-&gt;pointer);</a>
<a name="ln679">					mSpinPercentage = value;</a>
<a name="ln680">					mLastSpinChange = logMsg.now;</a>
<a name="ln681">					BroadcastNewParameterValue(logMsg.now, param, &amp;value, sizeof(value));</a>
<a name="ln682">					logMsg.param.value = value;</a>
<a name="ln683">					mLogger-&gt;Log(LOG_SET_PARAM_HANDLED, logMsg);</a>
<a name="ln684">				}</a>
<a name="ln685">				break;</a>
<a name="ln686"> </a>
<a name="ln687">			case PRIORITY_PARAM:</a>
<a name="ln688">				{</a>
<a name="ln689">					mPriority = *((int32*) event-&gt;pointer);</a>
<a name="ln690">					// DO NOT use ::set_thead_priority() to directly alter the node's control</a>
<a name="ln691">					// thread priority.  BMediaEventLooper tracks the priority itself and recalculates</a>
<a name="ln692">					// the node's scheduling latency whenever SetPriority() is called.  This is VERY</a>
<a name="ln693">					// important for correct functioning of a node chain.  You should *only* alter a</a>
<a name="ln694">					// BMediaEventLooper's priority by calling its SetPriority() method.</a>
<a name="ln695">					SetPriority(mPriority);</a>
<a name="ln696"> </a>
<a name="ln697">					mLastPrioChange = logMsg.now;</a>
<a name="ln698">					BroadcastNewParameterValue(logMsg.now, param, &amp;mPriority, sizeof(mPriority));</a>
<a name="ln699">					logMsg.param.value = (float) mPriority;</a>
<a name="ln700">					mLogger-&gt;Log(LOG_SET_PARAM_HANDLED, logMsg);</a>
<a name="ln701">				}</a>
<a name="ln702">				break;</a>
<a name="ln703"> </a>
<a name="ln704">			// log the fact that we &quot;handled&quot; a &quot;set parameter&quot; event for a</a>
<a name="ln705">			// nonexistent parameter</a>
<a name="ln706">			default:</a>
<a name="ln707">				mLogger-&gt;Log(LOG_INVALID_PARAM_HANDLED, logMsg);</a>
<a name="ln708">				break;</a>
<a name="ln709">			}</a>
<a name="ln710">		}</a>
<a name="ln711">		break;</a>
<a name="ln712"> </a>
<a name="ln713">	case BTimedEventQueue::B_START:</a>
<a name="ln714">		// okay, let's go!</a>
<a name="ln715">		mLogger-&gt;Log(LOG_START_HANDLED, logMsg);</a>
<a name="ln716">		break;</a>
<a name="ln717"> </a>
<a name="ln718">	case BTimedEventQueue::B_STOP:</a>
<a name="ln719">		mLogger-&gt;Log(LOG_STOP_HANDLED, logMsg);</a>
<a name="ln720">		// stopping implies not handling any more buffers.  So, we flush all pending</a>
<a name="ln721">		// buffers out of the event queue before returning to the event loop.</a>
<a name="ln722">		EventQueue()-&gt;FlushEvents(0, BTimedEventQueue::B_ALWAYS, true, BTimedEventQueue::B_HANDLE_BUFFER);</a>
<a name="ln723">		break;</a>
<a name="ln724"> </a>
<a name="ln725">	case BTimedEventQueue::B_SEEK:</a>
<a name="ln726">		// seeking the log doesn't make any sense, so we just log that we handled the seek</a>
<a name="ln727">		// and return without doing anything else</a>
<a name="ln728">		mLogger-&gt;Log(LOG_SEEK_HANDLED, logMsg);</a>
<a name="ln729">		break;</a>
<a name="ln730"> </a>
<a name="ln731">	case BTimedEventQueue::B_WARP:</a>
<a name="ln732">		// similarly, time warps aren't meaningful to the logger, so just record it and return</a>
<a name="ln733">		mLogger-&gt;Log(LOG_WARP_HANDLED, logMsg);</a>
<a name="ln734">		break;</a>
<a name="ln735"> </a>
<a name="ln736">	case BTimedEventQueue::B_DATA_STATUS:</a>
<a name="ln737">		// we really don't care about the producer's data status, but this is where</a>
<a name="ln738">		// we'd do something about it if we did.</a>
<a name="ln739">		logMsg.data_status.status = event-&gt;data;</a>
<a name="ln740">		mLogger-&gt;Log(LOG_DATA_STATUS_HANDLED, logMsg);</a>
<a name="ln741">		break;</a>
<a name="ln742"> </a>
<a name="ln743">	default:</a>
<a name="ln744">		// hmm, someone enqueued a message that we don't understand.  log and ignore it.</a>
<a name="ln745">		logMsg.unknown.what = event-&gt;type;</a>
<a name="ln746">		mLogger-&gt;Log(LOG_HANDLE_UNKNOWN, logMsg);</a>
<a name="ln747">		break;</a>
<a name="ln748">	}</a>
<a name="ln749">}</a>

</code></pre>
<div class="balloon" rel="93"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: mSchedulingLatency.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
