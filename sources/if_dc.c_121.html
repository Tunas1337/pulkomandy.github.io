
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>if_dc.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * SPDX-License-Identifier: BSD-4-Clause</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 1997, 1998, 1999</a>
<a name="ln5"> *	Bill Paul &lt;wpaul@ee.columbia.edu&gt;.  All rights reserved.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln8"> * modification, are permitted provided that the following conditions</a>
<a name="ln9"> * are met:</a>
<a name="ln10"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln11"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln12"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln13"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln14"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln15"> * 3. All advertising materials mentioning features or use of this software</a>
<a name="ln16"> *    must display the following acknowledgement:</a>
<a name="ln17"> *	This product includes software developed by Bill Paul.</a>
<a name="ln18"> * 4. Neither the name of the author nor the names of any co-contributors</a>
<a name="ln19"> *    may be used to endorse or promote products derived from this software</a>
<a name="ln20"> *    without specific prior written permission.</a>
<a name="ln21"> *</a>
<a name="ln22"> * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln23"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln24"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln25"> * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD</a>
<a name="ln26"> * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</a>
<a name="ln27"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</a>
<a name="ln28"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</a>
<a name="ln29"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</a>
<a name="ln30"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</a>
<a name="ln31"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF</a>
<a name="ln32"> * THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln33"> */</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln36">__FBSDID(&quot;$FreeBSD: releng/12.0/sys/dev/dc/if_dc.c 338948 2018-09-26 17:12:14Z imp $&quot;);</a>
<a name="ln37"> </a>
<a name="ln38">/*</a>
<a name="ln39"> * DEC &quot;tulip&quot; clone ethernet driver. Supports the DEC/Intel 21143</a>
<a name="ln40"> * series chips and several workalikes including the following:</a>
<a name="ln41"> *</a>
<a name="ln42"> * Macronix 98713/98715/98725/98727/98732 PMAC (www.macronix.com)</a>
<a name="ln43"> * Macronix/Lite-On 82c115 PNIC II (www.macronix.com)</a>
<a name="ln44"> * Lite-On 82c168/82c169 PNIC (www.litecom.com)</a>
<a name="ln45"> * ASIX Electronics AX88140A (www.asix.com.tw)</a>
<a name="ln46"> * ASIX Electronics AX88141 (www.asix.com.tw)</a>
<a name="ln47"> * ADMtek AL981 (www.admtek.com.tw)</a>
<a name="ln48"> * ADMtek AN983 (www.admtek.com.tw)</a>
<a name="ln49"> * ADMtek CardBus AN985 (www.admtek.com.tw)</a>
<a name="ln50"> * Netgear FA511 (www.netgear.com) Appears to be rebadged ADMTek CardBus AN985</a>
<a name="ln51"> * Davicom DM9100, DM9102, DM9102A (www.davicom8.com)</a>
<a name="ln52"> * Accton EN1217 (www.accton.com)</a>
<a name="ln53"> * Xircom X3201 (www.xircom.com)</a>
<a name="ln54"> * Abocom FE2500</a>
<a name="ln55"> * Conexant LANfinity (www.conexant.com)</a>
<a name="ln56"> * 3Com OfficeConnect 10/100B 3CSOHO100B (www.3com.com)</a>
<a name="ln57"> *</a>
<a name="ln58"> * Datasheets for the 21143 are available at developer.intel.com.</a>
<a name="ln59"> * Datasheets for the clone parts can be found at their respective sites.</a>
<a name="ln60"> * (Except for the PNIC; see www.freebsd.org/~wpaul/PNIC/pnic.ps.gz.)</a>
<a name="ln61"> * The PNIC II is essentially a Macronix 98715A chip; the only difference</a>
<a name="ln62"> * worth noting is that its multicast hash table is only 128 bits wide</a>
<a name="ln63"> * instead of 512.</a>
<a name="ln64"> *</a>
<a name="ln65"> * Written by Bill Paul &lt;wpaul@ee.columbia.edu&gt;</a>
<a name="ln66"> * Electrical Engineering Department</a>
<a name="ln67"> * Columbia University, New York City</a>
<a name="ln68"> */</a>
<a name="ln69">/*</a>
<a name="ln70"> * The Intel 21143 is the successor to the DEC 21140. It is basically</a>
<a name="ln71"> * the same as the 21140 but with a few new features. The 21143 supports</a>
<a name="ln72"> * three kinds of media attachments:</a>
<a name="ln73"> *</a>
<a name="ln74"> * o MII port, for 10Mbps and 100Mbps support and NWAY</a>
<a name="ln75"> *   autonegotiation provided by an external PHY.</a>
<a name="ln76"> * o SYM port, for symbol mode 100Mbps support.</a>
<a name="ln77"> * o 10baseT port.</a>
<a name="ln78"> * o AUI/BNC port.</a>
<a name="ln79"> *</a>
<a name="ln80"> * The 100Mbps SYM port and 10baseT port can be used together in</a>
<a name="ln81"> * combination with the internal NWAY support to create a 10/100</a>
<a name="ln82"> * autosensing configuration.</a>
<a name="ln83"> *</a>
<a name="ln84"> * Note that not all tulip workalikes are handled in this driver: we only</a>
<a name="ln85"> * deal with those which are relatively well behaved. The Winbond is</a>
<a name="ln86"> * handled separately due to its different register offsets and the</a>
<a name="ln87"> * special handling needed for its various bugs. The PNIC is handled</a>
<a name="ln88"> * here, but I'm not thrilled about it.</a>
<a name="ln89"> *</a>
<a name="ln90"> * All of the workalike chips use some form of MII transceiver support</a>
<a name="ln91"> * with the exception of the Macronix chips, which also have a SYM port.</a>
<a name="ln92"> * The ASIX AX88140A is also documented to have a SYM port, but all</a>
<a name="ln93"> * the cards I've seen use an MII transceiver, probably because the</a>
<a name="ln94"> * AX88140A doesn't support internal NWAY.</a>
<a name="ln95"> */</a>
<a name="ln96"> </a>
<a name="ln97">#ifdef HAVE_KERNEL_OPTION_HEADERS</a>
<a name="ln98">#include &quot;opt_device_polling.h&quot;</a>
<a name="ln99">#endif</a>
<a name="ln100"> </a>
<a name="ln101">#include &lt;sys/param.h&gt;</a>
<a name="ln102">#include &lt;sys/endian.h&gt;</a>
<a name="ln103">#include &lt;sys/systm.h&gt;</a>
<a name="ln104">#include &lt;sys/sockio.h&gt;</a>
<a name="ln105">#include &lt;sys/mbuf.h&gt;</a>
<a name="ln106">#include &lt;sys/malloc.h&gt;</a>
<a name="ln107">#include &lt;sys/kernel.h&gt;</a>
<a name="ln108">#include &lt;sys/module.h&gt;</a>
<a name="ln109">#include &lt;sys/socket.h&gt;</a>
<a name="ln110"> </a>
<a name="ln111">#include &lt;net/if.h&gt;</a>
<a name="ln112">#include &lt;net/if_var.h&gt;</a>
<a name="ln113">#include &lt;net/if_arp.h&gt;</a>
<a name="ln114">#include &lt;net/ethernet.h&gt;</a>
<a name="ln115">#include &lt;net/if_dl.h&gt;</a>
<a name="ln116">#include &lt;net/if_media.h&gt;</a>
<a name="ln117">#include &lt;net/if_types.h&gt;</a>
<a name="ln118">#include &lt;net/if_vlan_var.h&gt;</a>
<a name="ln119"> </a>
<a name="ln120">#include &lt;net/bpf.h&gt;</a>
<a name="ln121"> </a>
<a name="ln122">#include &lt;machine/bus.h&gt;</a>
<a name="ln123">#include &lt;machine/resource.h&gt;</a>
<a name="ln124">#include &lt;sys/bus.h&gt;</a>
<a name="ln125">#include &lt;sys/rman.h&gt;</a>
<a name="ln126"> </a>
<a name="ln127">#include &lt;dev/mii/mii.h&gt;</a>
<a name="ln128">#include &lt;dev/mii/mii_bitbang.h&gt;</a>
<a name="ln129">#include &lt;dev/mii/miivar.h&gt;</a>
<a name="ln130"> </a>
<a name="ln131">#include &lt;dev/pci/pcireg.h&gt;</a>
<a name="ln132">#include &lt;dev/pci/pcivar.h&gt;</a>
<a name="ln133"> </a>
<a name="ln134">#define	DC_USEIOSPACE</a>
<a name="ln135"> </a>
<a name="ln136">#include &lt;dev/dc/if_dcreg.h&gt;</a>
<a name="ln137"> </a>
<a name="ln138">#ifdef __sparc64__</a>
<a name="ln139">#include &lt;dev/ofw/openfirm.h&gt;</a>
<a name="ln140">#include &lt;machine/ofw_machdep.h&gt;</a>
<a name="ln141">#endif</a>
<a name="ln142"> </a>
<a name="ln143">MODULE_DEPEND(dc, pci, 1, 1, 1);</a>
<a name="ln144">MODULE_DEPEND(dc, ether, 1, 1, 1);</a>
<a name="ln145">MODULE_DEPEND(dc, miibus, 1, 1, 1);</a>
<a name="ln146"> </a>
<a name="ln147">/*</a>
<a name="ln148"> * &quot;device miibus&quot; is required in kernel config.  See GENERIC if you get</a>
<a name="ln149"> * errors here.</a>
<a name="ln150"> */</a>
<a name="ln151">#include &quot;miibus_if.h&quot;</a>
<a name="ln152"> </a>
<a name="ln153">/*</a>
<a name="ln154"> * Various supported device vendors/types and their names.</a>
<a name="ln155"> */</a>
<a name="ln156">static const struct dc_type dc_devs[] = {</a>
<a name="ln157">	{ DC_DEVID(DC_VENDORID_DEC, DC_DEVICEID_21143), 0,</a>
<a name="ln158">		&quot;Intel 21143 10/100BaseTX&quot; },</a>
<a name="ln159">	{ DC_DEVID(DC_VENDORID_DAVICOM, DC_DEVICEID_DM9009), 0,</a>
<a name="ln160">		&quot;Davicom DM9009 10/100BaseTX&quot; },</a>
<a name="ln161">	{ DC_DEVID(DC_VENDORID_DAVICOM, DC_DEVICEID_DM9100), 0,</a>
<a name="ln162">		&quot;Davicom DM9100 10/100BaseTX&quot; },</a>
<a name="ln163">	{ DC_DEVID(DC_VENDORID_DAVICOM, DC_DEVICEID_DM9102), DC_REVISION_DM9102A,</a>
<a name="ln164">		&quot;Davicom DM9102A 10/100BaseTX&quot; },</a>
<a name="ln165">	{ DC_DEVID(DC_VENDORID_DAVICOM, DC_DEVICEID_DM9102), 0,</a>
<a name="ln166">		&quot;Davicom DM9102 10/100BaseTX&quot; },</a>
<a name="ln167">	{ DC_DEVID(DC_VENDORID_ADMTEK, DC_DEVICEID_AL981), 0,</a>
<a name="ln168">		&quot;ADMtek AL981 10/100BaseTX&quot; },</a>
<a name="ln169">	{ DC_DEVID(DC_VENDORID_ADMTEK, DC_DEVICEID_AN983), 0,</a>
<a name="ln170">		&quot;ADMtek AN983 10/100BaseTX&quot; },</a>
<a name="ln171">	{ DC_DEVID(DC_VENDORID_ADMTEK, DC_DEVICEID_AN985), 0,</a>
<a name="ln172">		&quot;ADMtek AN985 CardBus 10/100BaseTX or clone&quot; },</a>
<a name="ln173">	{ DC_DEVID(DC_VENDORID_ADMTEK, DC_DEVICEID_ADM9511), 0,</a>
<a name="ln174">		&quot;ADMtek ADM9511 10/100BaseTX&quot; },</a>
<a name="ln175">	{ DC_DEVID(DC_VENDORID_ADMTEK, DC_DEVICEID_ADM9513), 0,</a>
<a name="ln176">		&quot;ADMtek ADM9513 10/100BaseTX&quot; },</a>
<a name="ln177">	{ DC_DEVID(DC_VENDORID_ASIX, DC_DEVICEID_AX88140A), DC_REVISION_88141,</a>
<a name="ln178">		&quot;ASIX AX88141 10/100BaseTX&quot; },</a>
<a name="ln179">	{ DC_DEVID(DC_VENDORID_ASIX, DC_DEVICEID_AX88140A), 0,</a>
<a name="ln180">		&quot;ASIX AX88140A 10/100BaseTX&quot; },</a>
<a name="ln181">	{ DC_DEVID(DC_VENDORID_MX, DC_DEVICEID_98713), DC_REVISION_98713A,</a>
<a name="ln182">		&quot;Macronix 98713A 10/100BaseTX&quot; },</a>
<a name="ln183">	{ DC_DEVID(DC_VENDORID_MX, DC_DEVICEID_98713), 0,</a>
<a name="ln184">		&quot;Macronix 98713 10/100BaseTX&quot; },</a>
<a name="ln185">	{ DC_DEVID(DC_VENDORID_CP, DC_DEVICEID_98713_CP), DC_REVISION_98713A,</a>
<a name="ln186">		&quot;Compex RL100-TX 10/100BaseTX&quot; },</a>
<a name="ln187">	{ DC_DEVID(DC_VENDORID_CP, DC_DEVICEID_98713_CP), 0,</a>
<a name="ln188">		&quot;Compex RL100-TX 10/100BaseTX&quot; },</a>
<a name="ln189">	{ DC_DEVID(DC_VENDORID_MX, DC_DEVICEID_987x5), DC_REVISION_98725,</a>
<a name="ln190">		&quot;Macronix 98725 10/100BaseTX&quot; },</a>
<a name="ln191">	{ DC_DEVID(DC_VENDORID_MX, DC_DEVICEID_987x5), DC_REVISION_98715AEC_C,</a>
<a name="ln192">		&quot;Macronix 98715AEC-C 10/100BaseTX&quot; },</a>
<a name="ln193">	{ DC_DEVID(DC_VENDORID_MX, DC_DEVICEID_987x5), 0,</a>
<a name="ln194">		&quot;Macronix 98715/98715A 10/100BaseTX&quot; },</a>
<a name="ln195">	{ DC_DEVID(DC_VENDORID_MX, DC_DEVICEID_98727), 0,</a>
<a name="ln196">		&quot;Macronix 98727/98732 10/100BaseTX&quot; },</a>
<a name="ln197">	{ DC_DEVID(DC_VENDORID_LO, DC_DEVICEID_82C115), 0,</a>
<a name="ln198">		&quot;LC82C115 PNIC II 10/100BaseTX&quot; },</a>
<a name="ln199">	{ DC_DEVID(DC_VENDORID_LO, DC_DEVICEID_82C168), DC_REVISION_82C169,</a>
<a name="ln200">		&quot;82c169 PNIC 10/100BaseTX&quot; },</a>
<a name="ln201">	{ DC_DEVID(DC_VENDORID_LO, DC_DEVICEID_82C168), 0,</a>
<a name="ln202">		&quot;82c168 PNIC 10/100BaseTX&quot; },</a>
<a name="ln203">	{ DC_DEVID(DC_VENDORID_ACCTON, DC_DEVICEID_EN1217), 0,</a>
<a name="ln204">		&quot;Accton EN1217 10/100BaseTX&quot; },</a>
<a name="ln205">	{ DC_DEVID(DC_VENDORID_ACCTON, DC_DEVICEID_EN2242), 0,</a>
<a name="ln206">		&quot;Accton EN2242 MiniPCI 10/100BaseTX&quot; },</a>
<a name="ln207">	{ DC_DEVID(DC_VENDORID_XIRCOM, DC_DEVICEID_X3201), 0,</a>
<a name="ln208">		&quot;Xircom X3201 10/100BaseTX&quot; },</a>
<a name="ln209">	{ DC_DEVID(DC_VENDORID_DLINK, DC_DEVICEID_DRP32TXD), 0,</a>
<a name="ln210">		&quot;Neteasy DRP-32TXD Cardbus 10/100&quot; },</a>
<a name="ln211">	{ DC_DEVID(DC_VENDORID_ABOCOM, DC_DEVICEID_FE2500), 0,</a>
<a name="ln212">		&quot;Abocom FE2500 10/100BaseTX&quot; },</a>
<a name="ln213">	{ DC_DEVID(DC_VENDORID_ABOCOM, DC_DEVICEID_FE2500MX), 0,</a>
<a name="ln214">		&quot;Abocom FE2500MX 10/100BaseTX&quot; },</a>
<a name="ln215">	{ DC_DEVID(DC_VENDORID_CONEXANT, DC_DEVICEID_RS7112), 0,</a>
<a name="ln216">		&quot;Conexant LANfinity MiniPCI 10/100BaseTX&quot; },</a>
<a name="ln217">	{ DC_DEVID(DC_VENDORID_HAWKING, DC_DEVICEID_HAWKING_PN672TX), 0,</a>
<a name="ln218">		&quot;Hawking CB102 CardBus 10/100&quot; },</a>
<a name="ln219">	{ DC_DEVID(DC_VENDORID_PLANEX, DC_DEVICEID_FNW3602T), 0,</a>
<a name="ln220">		&quot;PlaneX FNW-3602-T CardBus 10/100&quot; },</a>
<a name="ln221">	{ DC_DEVID(DC_VENDORID_3COM, DC_DEVICEID_3CSOHOB), 0,</a>
<a name="ln222">		&quot;3Com OfficeConnect 10/100B&quot; },</a>
<a name="ln223">	{ DC_DEVID(DC_VENDORID_MICROSOFT, DC_DEVICEID_MSMN120), 0,</a>
<a name="ln224">		&quot;Microsoft MN-120 CardBus 10/100&quot; },</a>
<a name="ln225">	{ DC_DEVID(DC_VENDORID_MICROSOFT, DC_DEVICEID_MSMN130), 0,</a>
<a name="ln226">		&quot;Microsoft MN-130 10/100&quot; },</a>
<a name="ln227">	{ DC_DEVID(DC_VENDORID_LINKSYS, DC_DEVICEID_PCMPC200_AB08), 0,</a>
<a name="ln228">		&quot;Linksys PCMPC200 CardBus 10/100&quot; },</a>
<a name="ln229">	{ DC_DEVID(DC_VENDORID_LINKSYS, DC_DEVICEID_PCMPC200_AB09), 0,</a>
<a name="ln230">		&quot;Linksys PCMPC200 CardBus 10/100&quot; },</a>
<a name="ln231">	{ DC_DEVID(DC_VENDORID_ULI, DC_DEVICEID_M5261), 0,</a>
<a name="ln232">		&quot;ULi M5261 FastEthernet&quot; },</a>
<a name="ln233">	{ DC_DEVID(DC_VENDORID_ULI, DC_DEVICEID_M5263), 0,</a>
<a name="ln234">		&quot;ULi M5263 FastEthernet&quot; },</a>
<a name="ln235">	{ 0, 0, NULL }</a>
<a name="ln236">};</a>
<a name="ln237"> </a>
<a name="ln238">static int dc_probe(device_t);</a>
<a name="ln239">static int dc_attach(device_t);</a>
<a name="ln240">static int dc_detach(device_t);</a>
<a name="ln241">static int dc_suspend(device_t);</a>
<a name="ln242">static int dc_resume(device_t);</a>
<a name="ln243">static const struct dc_type *dc_devtype(device_t);</a>
<a name="ln244">static void dc_discard_rxbuf(struct dc_softc *, int);</a>
<a name="ln245">static int dc_newbuf(struct dc_softc *, int);</a>
<a name="ln246">static int dc_encap(struct dc_softc *, struct mbuf **);</a>
<a name="ln247">static void dc_pnic_rx_bug_war(struct dc_softc *, int);</a>
<a name="ln248">static int dc_rx_resync(struct dc_softc *);</a>
<a name="ln249">static int dc_rxeof(struct dc_softc *);</a>
<a name="ln250">static void dc_txeof(struct dc_softc *);</a>
<a name="ln251">static void dc_tick(void *);</a>
<a name="ln252">static void dc_tx_underrun(struct dc_softc *);</a>
<a name="ln253">static void dc_intr(void *);</a>
<a name="ln254">static void dc_start(struct ifnet *);</a>
<a name="ln255">static void dc_start_locked(struct ifnet *);</a>
<a name="ln256">static int dc_ioctl(struct ifnet *, u_long, caddr_t);</a>
<a name="ln257">static void dc_init(void *);</a>
<a name="ln258">static void dc_init_locked(struct dc_softc *);</a>
<a name="ln259">static void dc_stop(struct dc_softc *);</a>
<a name="ln260">static void dc_watchdog(void *);</a>
<a name="ln261">static int dc_shutdown(device_t);</a>
<a name="ln262">static int dc_ifmedia_upd(struct ifnet *);</a>
<a name="ln263">static int dc_ifmedia_upd_locked(struct dc_softc *);</a>
<a name="ln264">static void dc_ifmedia_sts(struct ifnet *, struct ifmediareq *);</a>
<a name="ln265"> </a>
<a name="ln266">static int dc_dma_alloc(struct dc_softc *);</a>
<a name="ln267">static void dc_dma_free(struct dc_softc *);</a>
<a name="ln268">static void dc_dma_map_addr(void *, bus_dma_segment_t *, int, int);</a>
<a name="ln269"> </a>
<a name="ln270">static void dc_delay(struct dc_softc *);</a>
<a name="ln271">static void dc_eeprom_idle(struct dc_softc *);</a>
<a name="ln272">static void dc_eeprom_putbyte(struct dc_softc *, int);</a>
<a name="ln273">static void dc_eeprom_getword(struct dc_softc *, int, uint16_t *);</a>
<a name="ln274">static void dc_eeprom_getword_pnic(struct dc_softc *, int, uint16_t *);</a>
<a name="ln275">static void dc_eeprom_getword_xircom(struct dc_softc *, int, uint16_t *);</a>
<a name="ln276">static void dc_eeprom_width(struct dc_softc *);</a>
<a name="ln277">static void dc_read_eeprom(struct dc_softc *, caddr_t, int, int, int);</a>
<a name="ln278"> </a>
<a name="ln279">static int dc_miibus_readreg(device_t, int, int);</a>
<a name="ln280">static int dc_miibus_writereg(device_t, int, int, int);</a>
<a name="ln281">static void dc_miibus_statchg(device_t);</a>
<a name="ln282">static void dc_miibus_mediainit(device_t);</a>
<a name="ln283"> </a>
<a name="ln284">static void dc_setcfg(struct dc_softc *, int);</a>
<a name="ln285">static void dc_netcfg_wait(struct dc_softc *);</a>
<a name="ln286">static uint32_t dc_mchash_le(struct dc_softc *, const uint8_t *);</a>
<a name="ln287">static uint32_t dc_mchash_be(const uint8_t *);</a>
<a name="ln288">static void dc_setfilt_21143(struct dc_softc *);</a>
<a name="ln289">static void dc_setfilt_asix(struct dc_softc *);</a>
<a name="ln290">static void dc_setfilt_admtek(struct dc_softc *);</a>
<a name="ln291">static void dc_setfilt_uli(struct dc_softc *);</a>
<a name="ln292">static void dc_setfilt_xircom(struct dc_softc *);</a>
<a name="ln293"> </a>
<a name="ln294">static void dc_setfilt(struct dc_softc *);</a>
<a name="ln295"> </a>
<a name="ln296">static void dc_reset(struct dc_softc *);</a>
<a name="ln297">static int dc_list_rx_init(struct dc_softc *);</a>
<a name="ln298">static int dc_list_tx_init(struct dc_softc *);</a>
<a name="ln299"> </a>
<a name="ln300">static int dc_read_srom(struct dc_softc *, int);</a>
<a name="ln301">static int dc_parse_21143_srom(struct dc_softc *);</a>
<a name="ln302">static int dc_decode_leaf_sia(struct dc_softc *, struct dc_eblock_sia *);</a>
<a name="ln303">static int dc_decode_leaf_mii(struct dc_softc *, struct dc_eblock_mii *);</a>
<a name="ln304">static int dc_decode_leaf_sym(struct dc_softc *, struct dc_eblock_sym *);</a>
<a name="ln305">static void dc_apply_fixup(struct dc_softc *, int);</a>
<a name="ln306">static int dc_check_multiport(struct dc_softc *);</a>
<a name="ln307"> </a>
<a name="ln308">/*</a>
<a name="ln309"> * MII bit-bang glue</a>
<a name="ln310"> */</a>
<a name="ln311">static uint32_t dc_mii_bitbang_read(device_t);</a>
<a name="ln312">static void dc_mii_bitbang_write(device_t, uint32_t);</a>
<a name="ln313"> </a>
<a name="ln314">static const struct mii_bitbang_ops dc_mii_bitbang_ops = {</a>
<a name="ln315">	dc_mii_bitbang_read,</a>
<a name="ln316">	dc_mii_bitbang_write,</a>
<a name="ln317">	{</a>
<a name="ln318">		DC_SIO_MII_DATAOUT,	/* MII_BIT_MDO */</a>
<a name="ln319">		DC_SIO_MII_DATAIN,	/* MII_BIT_MDI */</a>
<a name="ln320">		DC_SIO_MII_CLK,		/* MII_BIT_MDC */</a>
<a name="ln321">		0,			/* MII_BIT_DIR_HOST_PHY */</a>
<a name="ln322">		DC_SIO_MII_DIR,		/* MII_BIT_DIR_PHY_HOST */</a>
<a name="ln323">	}</a>
<a name="ln324">};</a>
<a name="ln325"> </a>
<a name="ln326">#ifdef DC_USEIOSPACE</a>
<a name="ln327">#define	DC_RES			SYS_RES_IOPORT</a>
<a name="ln328">#define	DC_RID			DC_PCI_CFBIO</a>
<a name="ln329">#else</a>
<a name="ln330">#define	DC_RES			SYS_RES_MEMORY</a>
<a name="ln331">#define	DC_RID			DC_PCI_CFBMA</a>
<a name="ln332">#endif</a>
<a name="ln333"> </a>
<a name="ln334">static device_method_t dc_methods[] = {</a>
<a name="ln335">	/* Device interface */</a>
<a name="ln336">	DEVMETHOD(device_probe,		dc_probe),</a>
<a name="ln337">	DEVMETHOD(device_attach,	dc_attach),</a>
<a name="ln338">	DEVMETHOD(device_detach,	dc_detach),</a>
<a name="ln339">	DEVMETHOD(device_suspend,	dc_suspend),</a>
<a name="ln340">	DEVMETHOD(device_resume,	dc_resume),</a>
<a name="ln341">	DEVMETHOD(device_shutdown,	dc_shutdown),</a>
<a name="ln342"> </a>
<a name="ln343">	/* MII interface */</a>
<a name="ln344">	DEVMETHOD(miibus_readreg,	dc_miibus_readreg),</a>
<a name="ln345">	DEVMETHOD(miibus_writereg,	dc_miibus_writereg),</a>
<a name="ln346">	DEVMETHOD(miibus_statchg,	dc_miibus_statchg),</a>
<a name="ln347">	DEVMETHOD(miibus_mediainit,	dc_miibus_mediainit),</a>
<a name="ln348"> </a>
<a name="ln349">	DEVMETHOD_END</a>
<a name="ln350">};</a>
<a name="ln351"> </a>
<a name="ln352">static driver_t dc_driver = {</a>
<a name="ln353">	&quot;dc&quot;,</a>
<a name="ln354">	dc_methods,</a>
<a name="ln355">	sizeof(struct dc_softc)</a>
<a name="ln356">};</a>
<a name="ln357"> </a>
<a name="ln358">static devclass_t dc_devclass;</a>
<a name="ln359"> </a>
<a name="ln360">DRIVER_MODULE_ORDERED(dc, pci, dc_driver, dc_devclass, NULL, NULL,</a>
<a name="ln361">    SI_ORDER_ANY);</a>
<a name="ln362">MODULE_PNP_INFO(&quot;W32:vendor/device;U8:revision;D:#&quot;, pci, dc, dc_devs,</a>
<a name="ln363">    nitems(dc_devs) - 1);</a>
<a name="ln364">DRIVER_MODULE(miibus, dc, miibus_driver, miibus_devclass, NULL, NULL);</a>
<a name="ln365"> </a>
<a name="ln366">#define	DC_SETBIT(sc, reg, x)				\</a>
<a name="ln367">	CSR_WRITE_4(sc, reg, CSR_READ_4(sc, reg) | (x))</a>
<a name="ln368"> </a>
<a name="ln369">#define	DC_CLRBIT(sc, reg, x)				\</a>
<a name="ln370">	CSR_WRITE_4(sc, reg, CSR_READ_4(sc, reg) &amp; ~(x))</a>
<a name="ln371"> </a>
<a name="ln372">#define	SIO_SET(x)	DC_SETBIT(sc, DC_SIO, (x))</a>
<a name="ln373">#define	SIO_CLR(x)	DC_CLRBIT(sc, DC_SIO, (x))</a>
<a name="ln374"> </a>
<a name="ln375">static void</a>
<a name="ln376">dc_delay(struct dc_softc *sc)</a>
<a name="ln377">{</a>
<a name="ln378">	int idx;</a>
<a name="ln379"> </a>
<a name="ln380">	for (idx = (300 / 33) + 1; idx &gt; 0; idx--)</a>
<a name="ln381">		CSR_READ_4(sc, DC_BUSCTL);</a>
<a name="ln382">}</a>
<a name="ln383"> </a>
<a name="ln384">static void</a>
<a name="ln385">dc_eeprom_width(struct dc_softc *sc)</a>
<a name="ln386">{</a>
<a name="ln387">	int i;</a>
<a name="ln388"> </a>
<a name="ln389">	/* Force EEPROM to idle state. */</a>
<a name="ln390">	dc_eeprom_idle(sc);</a>
<a name="ln391"> </a>
<a name="ln392">	/* Enter EEPROM access mode. */</a>
<a name="ln393">	CSR_WRITE_4(sc, DC_SIO, DC_SIO_EESEL);</a>
<a name="ln394">	dc_delay(sc);</a>
<a name="ln395">	DC_SETBIT(sc, DC_SIO, DC_SIO_ROMCTL_READ);</a>
<a name="ln396">	dc_delay(sc);</a>
<a name="ln397">	DC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);</a>
<a name="ln398">	dc_delay(sc);</a>
<a name="ln399">	DC_SETBIT(sc, DC_SIO, DC_SIO_EE_CS);</a>
<a name="ln400">	dc_delay(sc);</a>
<a name="ln401"> </a>
<a name="ln402">	for (i = 3; i--;) {</a>
<a name="ln403">		if (6 &amp; (1 &lt;&lt; i))</a>
<a name="ln404">			DC_SETBIT(sc, DC_SIO, DC_SIO_EE_DATAIN);</a>
<a name="ln405">		else</a>
<a name="ln406">			DC_CLRBIT(sc, DC_SIO, DC_SIO_EE_DATAIN);</a>
<a name="ln407">		dc_delay(sc);</a>
<a name="ln408">		DC_SETBIT(sc, DC_SIO, DC_SIO_EE_CLK);</a>
<a name="ln409">		dc_delay(sc);</a>
<a name="ln410">		DC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);</a>
<a name="ln411">		dc_delay(sc);</a>
<a name="ln412">	}</a>
<a name="ln413"> </a>
<a name="ln414">	for (i = 1; i &lt;= 12; i++) {</a>
<a name="ln415">		DC_SETBIT(sc, DC_SIO, DC_SIO_EE_CLK);</a>
<a name="ln416">		dc_delay(sc);</a>
<a name="ln417">		if (!(CSR_READ_4(sc, DC_SIO) &amp; DC_SIO_EE_DATAOUT)) {</a>
<a name="ln418">			DC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);</a>
<a name="ln419">			dc_delay(sc);</a>
<a name="ln420">			break;</a>
<a name="ln421">		}</a>
<a name="ln422">		DC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);</a>
<a name="ln423">		dc_delay(sc);</a>
<a name="ln424">	}</a>
<a name="ln425"> </a>
<a name="ln426">	/* Turn off EEPROM access mode. */</a>
<a name="ln427">	dc_eeprom_idle(sc);</a>
<a name="ln428"> </a>
<a name="ln429">	if (i &lt; 4 || i &gt; 12)</a>
<a name="ln430">		sc-&gt;dc_romwidth = 6;</a>
<a name="ln431">	else</a>
<a name="ln432">		sc-&gt;dc_romwidth = i;</a>
<a name="ln433"> </a>
<a name="ln434">	/* Enter EEPROM access mode. */</a>
<a name="ln435">	CSR_WRITE_4(sc, DC_SIO, DC_SIO_EESEL);</a>
<a name="ln436">	dc_delay(sc);</a>
<a name="ln437">	DC_SETBIT(sc, DC_SIO, DC_SIO_ROMCTL_READ);</a>
<a name="ln438">	dc_delay(sc);</a>
<a name="ln439">	DC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);</a>
<a name="ln440">	dc_delay(sc);</a>
<a name="ln441">	DC_SETBIT(sc, DC_SIO, DC_SIO_EE_CS);</a>
<a name="ln442">	dc_delay(sc);</a>
<a name="ln443"> </a>
<a name="ln444">	/* Turn off EEPROM access mode. */</a>
<a name="ln445">	dc_eeprom_idle(sc);</a>
<a name="ln446">}</a>
<a name="ln447"> </a>
<a name="ln448">static void</a>
<a name="ln449">dc_eeprom_idle(struct dc_softc *sc)</a>
<a name="ln450">{</a>
<a name="ln451">	int i;</a>
<a name="ln452"> </a>
<a name="ln453">	CSR_WRITE_4(sc, DC_SIO, DC_SIO_EESEL);</a>
<a name="ln454">	dc_delay(sc);</a>
<a name="ln455">	DC_SETBIT(sc, DC_SIO, DC_SIO_ROMCTL_READ);</a>
<a name="ln456">	dc_delay(sc);</a>
<a name="ln457">	DC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);</a>
<a name="ln458">	dc_delay(sc);</a>
<a name="ln459">	DC_SETBIT(sc, DC_SIO, DC_SIO_EE_CS);</a>
<a name="ln460">	dc_delay(sc);</a>
<a name="ln461"> </a>
<a name="ln462">	for (i = 0; i &lt; 25; i++) {</a>
<a name="ln463">		DC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);</a>
<a name="ln464">		dc_delay(sc);</a>
<a name="ln465">		DC_SETBIT(sc, DC_SIO, DC_SIO_EE_CLK);</a>
<a name="ln466">		dc_delay(sc);</a>
<a name="ln467">	}</a>
<a name="ln468"> </a>
<a name="ln469">	DC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);</a>
<a name="ln470">	dc_delay(sc);</a>
<a name="ln471">	DC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CS);</a>
<a name="ln472">	dc_delay(sc);</a>
<a name="ln473">	CSR_WRITE_4(sc, DC_SIO, 0x00000000);</a>
<a name="ln474">}</a>
<a name="ln475"> </a>
<a name="ln476">/*</a>
<a name="ln477"> * Send a read command and address to the EEPROM, check for ACK.</a>
<a name="ln478"> */</a>
<a name="ln479">static void</a>
<a name="ln480">dc_eeprom_putbyte(struct dc_softc *sc, int addr)</a>
<a name="ln481">{</a>
<a name="ln482">	int d, i;</a>
<a name="ln483"> </a>
<a name="ln484">	d = DC_EECMD_READ &gt;&gt; 6;</a>
<a name="ln485">	for (i = 3; i--; ) {</a>
<a name="ln486">		if (d &amp; (1 &lt;&lt; i))</a>
<a name="ln487">			DC_SETBIT(sc, DC_SIO, DC_SIO_EE_DATAIN);</a>
<a name="ln488">		else</a>
<a name="ln489">			DC_CLRBIT(sc, DC_SIO, DC_SIO_EE_DATAIN);</a>
<a name="ln490">		dc_delay(sc);</a>
<a name="ln491">		DC_SETBIT(sc, DC_SIO, DC_SIO_EE_CLK);</a>
<a name="ln492">		dc_delay(sc);</a>
<a name="ln493">		DC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);</a>
<a name="ln494">		dc_delay(sc);</a>
<a name="ln495">	}</a>
<a name="ln496"> </a>
<a name="ln497">	/*</a>
<a name="ln498">	 * Feed in each bit and strobe the clock.</a>
<a name="ln499">	 */</a>
<a name="ln500">	for (i = sc-&gt;dc_romwidth; i--;) {</a>
<a name="ln501">		if (addr &amp; (1 &lt;&lt; i)) {</a>
<a name="ln502">			SIO_SET(DC_SIO_EE_DATAIN);</a>
<a name="ln503">		} else {</a>
<a name="ln504">			SIO_CLR(DC_SIO_EE_DATAIN);</a>
<a name="ln505">		}</a>
<a name="ln506">		dc_delay(sc);</a>
<a name="ln507">		SIO_SET(DC_SIO_EE_CLK);</a>
<a name="ln508">		dc_delay(sc);</a>
<a name="ln509">		SIO_CLR(DC_SIO_EE_CLK);</a>
<a name="ln510">		dc_delay(sc);</a>
<a name="ln511">	}</a>
<a name="ln512">}</a>
<a name="ln513"> </a>
<a name="ln514">/*</a>
<a name="ln515"> * Read a word of data stored in the EEPROM at address 'addr.'</a>
<a name="ln516"> * The PNIC 82c168/82c169 has its own non-standard way to read</a>
<a name="ln517"> * the EEPROM.</a>
<a name="ln518"> */</a>
<a name="ln519">static void</a>
<a name="ln520">dc_eeprom_getword_pnic(struct dc_softc *sc, int addr, uint16_t *dest)</a>
<a name="ln521">{</a>
<a name="ln522">	int i;</a>
<a name="ln523">	uint32_t r;</a>
<a name="ln524"> </a>
<a name="ln525">	CSR_WRITE_4(sc, DC_PN_SIOCTL, DC_PN_EEOPCODE_READ | addr);</a>
<a name="ln526"> </a>
<a name="ln527">	for (i = 0; i &lt; DC_TIMEOUT; i++) {</a>
<a name="ln528">		DELAY(1);</a>
<a name="ln529">		r = CSR_READ_4(sc, DC_SIO);</a>
<a name="ln530">		if (!(r &amp; DC_PN_SIOCTL_BUSY)) {</a>
<a name="ln531">			*dest = (uint16_t)(r &amp; 0xFFFF);</a>
<a name="ln532">			return;</a>
<a name="ln533">		}</a>
<a name="ln534">	}</a>
<a name="ln535">}</a>
<a name="ln536"> </a>
<a name="ln537">/*</a>
<a name="ln538"> * Read a word of data stored in the EEPROM at address 'addr.'</a>
<a name="ln539"> * The Xircom X3201 has its own non-standard way to read</a>
<a name="ln540"> * the EEPROM, too.</a>
<a name="ln541"> */</a>
<a name="ln542">static void</a>
<a name="ln543">dc_eeprom_getword_xircom(struct dc_softc *sc, int addr, uint16_t *dest)</a>
<a name="ln544">{</a>
<a name="ln545"> </a>
<a name="ln546">	SIO_SET(DC_SIO_ROMSEL | DC_SIO_ROMCTL_READ);</a>
<a name="ln547"> </a>
<a name="ln548">	addr *= 2;</a>
<a name="ln549">	CSR_WRITE_4(sc, DC_ROM, addr | 0x160);</a>
<a name="ln550">	*dest = (uint16_t)CSR_READ_4(sc, DC_SIO) &amp; 0xff;</a>
<a name="ln551">	addr += 1;</a>
<a name="ln552">	CSR_WRITE_4(sc, DC_ROM, addr | 0x160);</a>
<a name="ln553">	*dest |= ((uint16_t)CSR_READ_4(sc, DC_SIO) &amp; 0xff) &lt;&lt; 8;</a>
<a name="ln554"> </a>
<a name="ln555">	SIO_CLR(DC_SIO_ROMSEL | DC_SIO_ROMCTL_READ);</a>
<a name="ln556">}</a>
<a name="ln557"> </a>
<a name="ln558">/*</a>
<a name="ln559"> * Read a word of data stored in the EEPROM at address 'addr.'</a>
<a name="ln560"> */</a>
<a name="ln561">static void</a>
<a name="ln562">dc_eeprom_getword(struct dc_softc *sc, int addr, uint16_t *dest)</a>
<a name="ln563">{</a>
<a name="ln564">	int i;</a>
<a name="ln565">	uint16_t word = 0;</a>
<a name="ln566"> </a>
<a name="ln567">	/* Force EEPROM to idle state. */</a>
<a name="ln568">	dc_eeprom_idle(sc);</a>
<a name="ln569"> </a>
<a name="ln570">	/* Enter EEPROM access mode. */</a>
<a name="ln571">	CSR_WRITE_4(sc, DC_SIO, DC_SIO_EESEL);</a>
<a name="ln572">	dc_delay(sc);</a>
<a name="ln573">	DC_SETBIT(sc, DC_SIO,  DC_SIO_ROMCTL_READ);</a>
<a name="ln574">	dc_delay(sc);</a>
<a name="ln575">	DC_CLRBIT(sc, DC_SIO, DC_SIO_EE_CLK);</a>
<a name="ln576">	dc_delay(sc);</a>
<a name="ln577">	DC_SETBIT(sc, DC_SIO, DC_SIO_EE_CS);</a>
<a name="ln578">	dc_delay(sc);</a>
<a name="ln579"> </a>
<a name="ln580">	/*</a>
<a name="ln581">	 * Send address of word we want to read.</a>
<a name="ln582">	 */</a>
<a name="ln583">	dc_eeprom_putbyte(sc, addr);</a>
<a name="ln584"> </a>
<a name="ln585">	/*</a>
<a name="ln586">	 * Start reading bits from EEPROM.</a>
<a name="ln587">	 */</a>
<a name="ln588">	for (i = 0x8000; i; i &gt;&gt;= 1) {</a>
<a name="ln589">		SIO_SET(DC_SIO_EE_CLK);</a>
<a name="ln590">		dc_delay(sc);</a>
<a name="ln591">		if (CSR_READ_4(sc, DC_SIO) &amp; DC_SIO_EE_DATAOUT)</a>
<a name="ln592">			word |= i;</a>
<a name="ln593">		dc_delay(sc);</a>
<a name="ln594">		SIO_CLR(DC_SIO_EE_CLK);</a>
<a name="ln595">		dc_delay(sc);</a>
<a name="ln596">	}</a>
<a name="ln597"> </a>
<a name="ln598">	/* Turn off EEPROM access mode. */</a>
<a name="ln599">	dc_eeprom_idle(sc);</a>
<a name="ln600"> </a>
<a name="ln601">	*dest = word;</a>
<a name="ln602">}</a>
<a name="ln603"> </a>
<a name="ln604">/*</a>
<a name="ln605"> * Read a sequence of words from the EEPROM.</a>
<a name="ln606"> */</a>
<a name="ln607">static void</a>
<a name="ln608">dc_read_eeprom(struct dc_softc *sc, caddr_t dest, int off, int cnt, int be)</a>
<a name="ln609">{</a>
<a name="ln610">	int i;</a>
<a name="ln611">	uint16_t word = 0, *ptr;</a>
<a name="ln612"> </a>
<a name="ln613">	for (i = 0; i &lt; cnt; i++) {</a>
<a name="ln614">		if (DC_IS_PNIC(sc))</a>
<a name="ln615">			dc_eeprom_getword_pnic(sc, off + i, &amp;word);</a>
<a name="ln616">		else if (DC_IS_XIRCOM(sc))</a>
<a name="ln617">			dc_eeprom_getword_xircom(sc, off + i, &amp;word);</a>
<a name="ln618">		else</a>
<a name="ln619">			dc_eeprom_getword(sc, off + i, &amp;word);</a>
<a name="ln620">		ptr = (uint16_t *)(dest + (i * 2));</a>
<a name="ln621">		if (be)</a>
<a name="ln622">			*ptr = be16toh(word);</a>
<a name="ln623">		else</a>
<a name="ln624">			*ptr = le16toh(word);</a>
<a name="ln625">	}</a>
<a name="ln626">}</a>
<a name="ln627"> </a>
<a name="ln628">/*</a>
<a name="ln629"> * Write the MII serial port for the MII bit-bang module.</a>
<a name="ln630"> */</a>
<a name="ln631">static void</a>
<a name="ln632">dc_mii_bitbang_write(device_t dev, uint32_t val)</a>
<a name="ln633">{</a>
<a name="ln634">	struct dc_softc *sc;</a>
<a name="ln635"> </a>
<a name="ln636">	sc = device_get_softc(dev);</a>
<a name="ln637"> </a>
<a name="ln638">	CSR_WRITE_4(sc, DC_SIO, val);</a>
<a name="ln639">	CSR_BARRIER_4(sc, DC_SIO,</a>
<a name="ln640">	    BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);</a>
<a name="ln641">}</a>
<a name="ln642"> </a>
<a name="ln643">/*</a>
<a name="ln644"> * Read the MII serial port for the MII bit-bang module.</a>
<a name="ln645"> */</a>
<a name="ln646">static uint32_t</a>
<a name="ln647">dc_mii_bitbang_read(device_t dev)</a>
<a name="ln648">{</a>
<a name="ln649">	struct dc_softc *sc;</a>
<a name="ln650">	uint32_t val;</a>
<a name="ln651"> </a>
<a name="ln652">	sc = device_get_softc(dev);</a>
<a name="ln653"> </a>
<a name="ln654">	val = CSR_READ_4(sc, DC_SIO);</a>
<a name="ln655">	CSR_BARRIER_4(sc, DC_SIO,</a>
<a name="ln656">	    BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE);</a>
<a name="ln657"> </a>
<a name="ln658">	return (val);</a>
<a name="ln659">}</a>
<a name="ln660"> </a>
<a name="ln661">static int</a>
<a name="ln662">dc_miibus_readreg(device_t dev, int phy, int reg)</a>
<a name="ln663">{</a>
<a name="ln664">	struct dc_softc *sc;</a>
<a name="ln665">	int i, rval, phy_reg = 0;</a>
<a name="ln666"> </a>
<a name="ln667">	sc = device_get_softc(dev);</a>
<a name="ln668"> </a>
<a name="ln669">	if (sc-&gt;dc_pmode != DC_PMODE_MII) {</a>
<a name="ln670">		if (phy == (MII_NPHY - 1)) {</a>
<a name="ln671">			switch (reg) {</a>
<a name="ln672">			case MII_BMSR:</a>
<a name="ln673">			/*</a>
<a name="ln674">			 * Fake something to make the probe</a>
<a name="ln675">			 * code think there's a PHY here.</a>
<a name="ln676">			 */</a>
<a name="ln677">				return (BMSR_MEDIAMASK);</a>
<a name="ln678">			case MII_PHYIDR1:</a>
<a name="ln679">				if (DC_IS_PNIC(sc))</a>
<a name="ln680">					return (DC_VENDORID_LO);</a>
<a name="ln681">				return (DC_VENDORID_DEC);</a>
<a name="ln682">			case MII_PHYIDR2:</a>
<a name="ln683">				if (DC_IS_PNIC(sc))</a>
<a name="ln684">					return (DC_DEVICEID_82C168);</a>
<a name="ln685">				return (DC_DEVICEID_21143);</a>
<a name="ln686">			default:</a>
<a name="ln687">				return (0);</a>
<a name="ln688">			}</a>
<a name="ln689">		} else</a>
<a name="ln690">			return (0);</a>
<a name="ln691">	}</a>
<a name="ln692"> </a>
<a name="ln693">	if (DC_IS_PNIC(sc)) {</a>
<a name="ln694">		CSR_WRITE_4(sc, DC_PN_MII, DC_PN_MIIOPCODE_READ |</a>
<a name="ln695">		    (phy &lt;&lt; 23) | (reg &lt;&lt; 18));</a>
<a name="ln696">		for (i = 0; i &lt; DC_TIMEOUT; i++) {</a>
<a name="ln697">			DELAY(1);</a>
<a name="ln698">			rval = CSR_READ_4(sc, DC_PN_MII);</a>
<a name="ln699">			if (!(rval &amp; DC_PN_MII_BUSY)) {</a>
<a name="ln700">				rval &amp;= 0xFFFF;</a>
<a name="ln701">				return (rval == 0xFFFF ? 0 : rval);</a>
<a name="ln702">			}</a>
<a name="ln703">		}</a>
<a name="ln704">		return (0);</a>
<a name="ln705">	}</a>
<a name="ln706"> </a>
<a name="ln707">	if (sc-&gt;dc_type == DC_TYPE_ULI_M5263) {</a>
<a name="ln708">		CSR_WRITE_4(sc, DC_ROM,</a>
<a name="ln709">		    ((phy &lt;&lt; DC_ULI_PHY_ADDR_SHIFT) &amp; DC_ULI_PHY_ADDR_MASK) |</a>
<a name="ln710">		    ((reg &lt;&lt; DC_ULI_PHY_REG_SHIFT) &amp; DC_ULI_PHY_REG_MASK) |</a>
<a name="ln711">		    DC_ULI_PHY_OP_READ);</a>
<a name="ln712">		for (i = 0; i &lt; DC_TIMEOUT; i++) {</a>
<a name="ln713">			DELAY(1);</a>
<a name="ln714">			rval = CSR_READ_4(sc, DC_ROM);</a>
<a name="ln715">			if ((rval &amp; DC_ULI_PHY_OP_DONE) != 0) {</a>
<a name="ln716">				return (rval &amp; DC_ULI_PHY_DATA_MASK);</a>
<a name="ln717">			}</a>
<a name="ln718">		}</a>
<a name="ln719">		if (i == DC_TIMEOUT)</a>
<a name="ln720">			device_printf(dev, &quot;phy read timed out\n&quot;);</a>
<a name="ln721">		return (0);</a>
<a name="ln722">	}</a>
<a name="ln723"> </a>
<a name="ln724">	if (DC_IS_COMET(sc)) {</a>
<a name="ln725">		switch (reg) {</a>
<a name="ln726">		case MII_BMCR:</a>
<a name="ln727">			phy_reg = DC_AL_BMCR;</a>
<a name="ln728">			break;</a>
<a name="ln729">		case MII_BMSR:</a>
<a name="ln730">			phy_reg = DC_AL_BMSR;</a>
<a name="ln731">			break;</a>
<a name="ln732">		case MII_PHYIDR1:</a>
<a name="ln733">			phy_reg = DC_AL_VENID;</a>
<a name="ln734">			break;</a>
<a name="ln735">		case MII_PHYIDR2:</a>
<a name="ln736">			phy_reg = DC_AL_DEVID;</a>
<a name="ln737">			break;</a>
<a name="ln738">		case MII_ANAR:</a>
<a name="ln739">			phy_reg = DC_AL_ANAR;</a>
<a name="ln740">			break;</a>
<a name="ln741">		case MII_ANLPAR:</a>
<a name="ln742">			phy_reg = DC_AL_LPAR;</a>
<a name="ln743">			break;</a>
<a name="ln744">		case MII_ANER:</a>
<a name="ln745">			phy_reg = DC_AL_ANER;</a>
<a name="ln746">			break;</a>
<a name="ln747">		default:</a>
<a name="ln748">			device_printf(dev, &quot;phy_read: bad phy register %x\n&quot;,</a>
<a name="ln749">			    reg);</a>
<a name="ln750">			return (0);</a>
<a name="ln751">		}</a>
<a name="ln752"> </a>
<a name="ln753">		rval = CSR_READ_4(sc, phy_reg) &amp; 0x0000FFFF;</a>
<a name="ln754">		if (rval == 0xFFFF)</a>
<a name="ln755">			return (0);</a>
<a name="ln756">		return (rval);</a>
<a name="ln757">	}</a>
<a name="ln758"> </a>
<a name="ln759">	if (sc-&gt;dc_type == DC_TYPE_98713) {</a>
<a name="ln760">		phy_reg = CSR_READ_4(sc, DC_NETCFG);</a>
<a name="ln761">		CSR_WRITE_4(sc, DC_NETCFG, phy_reg &amp; ~DC_NETCFG_PORTSEL);</a>
<a name="ln762">	}</a>
<a name="ln763">	rval = mii_bitbang_readreg(dev, &amp;dc_mii_bitbang_ops, phy, reg);</a>
<a name="ln764">	if (sc-&gt;dc_type == DC_TYPE_98713)</a>
<a name="ln765">		CSR_WRITE_4(sc, DC_NETCFG, phy_reg);</a>
<a name="ln766"> </a>
<a name="ln767">	return (rval);</a>
<a name="ln768">}</a>
<a name="ln769"> </a>
<a name="ln770">static int</a>
<a name="ln771">dc_miibus_writereg(device_t dev, int phy, int reg, int data)</a>
<a name="ln772">{</a>
<a name="ln773">	struct dc_softc *sc;</a>
<a name="ln774">	int i, phy_reg = 0;</a>
<a name="ln775"> </a>
<a name="ln776">	sc = device_get_softc(dev);</a>
<a name="ln777"> </a>
<a name="ln778">	if (DC_IS_PNIC(sc)) {</a>
<a name="ln779">		CSR_WRITE_4(sc, DC_PN_MII, DC_PN_MIIOPCODE_WRITE |</a>
<a name="ln780">		    (phy &lt;&lt; 23) | (reg &lt;&lt; 10) | data);</a>
<a name="ln781">		for (i = 0; i &lt; DC_TIMEOUT; i++) {</a>
<a name="ln782">			if (!(CSR_READ_4(sc, DC_PN_MII) &amp; DC_PN_MII_BUSY))</a>
<a name="ln783">				break;</a>
<a name="ln784">		}</a>
<a name="ln785">		return (0);</a>
<a name="ln786">	}</a>
<a name="ln787"> </a>
<a name="ln788">	if (sc-&gt;dc_type == DC_TYPE_ULI_M5263) {</a>
<a name="ln789">		CSR_WRITE_4(sc, DC_ROM,</a>
<a name="ln790">		    ((phy &lt;&lt; DC_ULI_PHY_ADDR_SHIFT) &amp; DC_ULI_PHY_ADDR_MASK) |</a>
<a name="ln791">		    ((reg &lt;&lt; DC_ULI_PHY_REG_SHIFT) &amp; DC_ULI_PHY_REG_MASK) |</a>
<a name="ln792">		    ((data &lt;&lt; DC_ULI_PHY_DATA_SHIFT) &amp; DC_ULI_PHY_DATA_MASK) |</a>
<a name="ln793">		    DC_ULI_PHY_OP_WRITE);</a>
<a name="ln794">		DELAY(1);</a>
<a name="ln795">		return (0);</a>
<a name="ln796">	}</a>
<a name="ln797"> </a>
<a name="ln798">	if (DC_IS_COMET(sc)) {</a>
<a name="ln799">		switch (reg) {</a>
<a name="ln800">		case MII_BMCR:</a>
<a name="ln801">			phy_reg = DC_AL_BMCR;</a>
<a name="ln802">			break;</a>
<a name="ln803">		case MII_BMSR:</a>
<a name="ln804">			phy_reg = DC_AL_BMSR;</a>
<a name="ln805">			break;</a>
<a name="ln806">		case MII_PHYIDR1:</a>
<a name="ln807">			phy_reg = DC_AL_VENID;</a>
<a name="ln808">			break;</a>
<a name="ln809">		case MII_PHYIDR2:</a>
<a name="ln810">			phy_reg = DC_AL_DEVID;</a>
<a name="ln811">			break;</a>
<a name="ln812">		case MII_ANAR:</a>
<a name="ln813">			phy_reg = DC_AL_ANAR;</a>
<a name="ln814">			break;</a>
<a name="ln815">		case MII_ANLPAR:</a>
<a name="ln816">			phy_reg = DC_AL_LPAR;</a>
<a name="ln817">			break;</a>
<a name="ln818">		case MII_ANER:</a>
<a name="ln819">			phy_reg = DC_AL_ANER;</a>
<a name="ln820">			break;</a>
<a name="ln821">		default:</a>
<a name="ln822">			device_printf(dev, &quot;phy_write: bad phy register %x\n&quot;,</a>
<a name="ln823">			    reg);</a>
<a name="ln824">			return (0);</a>
<a name="ln825">			break;</a>
<a name="ln826">		}</a>
<a name="ln827"> </a>
<a name="ln828">		CSR_WRITE_4(sc, phy_reg, data);</a>
<a name="ln829">		return (0);</a>
<a name="ln830">	}</a>
<a name="ln831"> </a>
<a name="ln832">	if (sc-&gt;dc_type == DC_TYPE_98713) {</a>
<a name="ln833">		phy_reg = CSR_READ_4(sc, DC_NETCFG);</a>
<a name="ln834">		CSR_WRITE_4(sc, DC_NETCFG, phy_reg &amp; ~DC_NETCFG_PORTSEL);</a>
<a name="ln835">	}</a>
<a name="ln836">	mii_bitbang_writereg(dev, &amp;dc_mii_bitbang_ops, phy, reg, data);</a>
<a name="ln837">	if (sc-&gt;dc_type == DC_TYPE_98713)</a>
<a name="ln838">		CSR_WRITE_4(sc, DC_NETCFG, phy_reg);</a>
<a name="ln839"> </a>
<a name="ln840">	return (0);</a>
<a name="ln841">}</a>
<a name="ln842"> </a>
<a name="ln843">static void</a>
<a name="ln844">dc_miibus_statchg(device_t dev)</a>
<a name="ln845">{</a>
<a name="ln846">	struct dc_softc *sc;</a>
<a name="ln847">	struct ifnet *ifp;</a>
<a name="ln848">	struct mii_data *mii;</a>
<a name="ln849">	struct ifmedia *ifm;</a>
<a name="ln850"> </a>
<a name="ln851">	sc = device_get_softc(dev);</a>
<a name="ln852"> </a>
<a name="ln853">	mii = device_get_softc(sc-&gt;dc_miibus);</a>
<a name="ln854">	ifp = sc-&gt;dc_ifp;</a>
<a name="ln855">	if (mii == NULL || ifp == NULL ||</a>
<a name="ln856">	    (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) == 0)</a>
<a name="ln857">		return;</a>
<a name="ln858"> </a>
<a name="ln859">	ifm = &amp;mii-&gt;mii_media;</a>
<a name="ln860">	if (DC_IS_DAVICOM(sc) &amp;&amp; IFM_SUBTYPE(ifm-&gt;ifm_media) == IFM_HPNA_1) {</a>
<a name="ln861">		dc_setcfg(sc, ifm-&gt;ifm_media);</a>
<a name="ln862">		return;</a>
<a name="ln863">	} else if (!DC_IS_ADMTEK(sc))</a>
<a name="ln864">		dc_setcfg(sc, mii-&gt;mii_media_active);</a>
<a name="ln865"> </a>
<a name="ln866">	sc-&gt;dc_link = 0;</a>
<a name="ln867">	if ((mii-&gt;mii_media_status &amp; (IFM_ACTIVE | IFM_AVALID)) ==</a>
<a name="ln868">	    (IFM_ACTIVE | IFM_AVALID)) {</a>
<a name="ln869">		switch (IFM_SUBTYPE(mii-&gt;mii_media_active)) {</a>
<a name="ln870">		case IFM_10_T:</a>
<a name="ln871">		case IFM_100_TX:</a>
<a name="ln872">			sc-&gt;dc_link = 1;</a>
<a name="ln873">			break;</a>
<a name="ln874">		}</a>
<a name="ln875">	}</a>
<a name="ln876">}</a>
<a name="ln877"> </a>
<a name="ln878">/*</a>
<a name="ln879"> * Special support for DM9102A cards with HomePNA PHYs. Note:</a>
<a name="ln880"> * with the Davicom DM9102A/DM9801 eval board that I have, it seems</a>
<a name="ln881"> * to be impossible to talk to the management interface of the DM9801</a>
<a name="ln882"> * PHY (its MDIO pin is not connected to anything). Consequently,</a>
<a name="ln883"> * the driver has to just 'know' about the additional mode and deal</a>
<a name="ln884"> * with it itself. *sigh*</a>
<a name="ln885"> */</a>
<a name="ln886">static void</a>
<a name="ln887">dc_miibus_mediainit(device_t dev)</a>
<a name="ln888">{</a>
<a name="ln889">	struct dc_softc *sc;</a>
<a name="ln890">	struct mii_data *mii;</a>
<a name="ln891">	struct ifmedia *ifm;</a>
<a name="ln892">	int rev;</a>
<a name="ln893"> </a>
<a name="ln894">	rev = pci_get_revid(dev);</a>
<a name="ln895"> </a>
<a name="ln896">	sc = device_get_softc(dev);</a>
<a name="ln897">	mii = device_get_softc(sc-&gt;dc_miibus);</a>
<a name="ln898">	ifm = &amp;mii-&gt;mii_media;</a>
<a name="ln899"> </a>
<a name="ln900">	if (DC_IS_DAVICOM(sc) &amp;&amp; rev &gt;= DC_REVISION_DM9102A)</a>
<a name="ln901">		ifmedia_add(ifm, IFM_ETHER | IFM_HPNA_1, 0, NULL);</a>
<a name="ln902">}</a>
<a name="ln903"> </a>
<a name="ln904">#define	DC_BITS_512	9</a>
<a name="ln905">#define	DC_BITS_128	7</a>
<a name="ln906">#define	DC_BITS_64	6</a>
<a name="ln907"> </a>
<a name="ln908">static uint32_t</a>
<a name="ln909">dc_mchash_le(struct dc_softc *sc, const uint8_t *addr)</a>
<a name="ln910">{</a>
<a name="ln911">	uint32_t crc;</a>
<a name="ln912"> </a>
<a name="ln913">	/* Compute CRC for the address value. */</a>
<a name="ln914">	crc = ether_crc32_le(addr, ETHER_ADDR_LEN);</a>
<a name="ln915"> </a>
<a name="ln916">	/*</a>
<a name="ln917">	 * The hash table on the PNIC II and the MX98715AEC-C/D/E</a>
<a name="ln918">	 * chips is only 128 bits wide.</a>
<a name="ln919">	 */</a>
<a name="ln920">	if (sc-&gt;dc_flags &amp; DC_128BIT_HASH)</a>
<a name="ln921">		return (crc &amp; ((1 &lt;&lt; DC_BITS_128) - 1));</a>
<a name="ln922"> </a>
<a name="ln923">	/* The hash table on the MX98715BEC is only 64 bits wide. */</a>
<a name="ln924">	if (sc-&gt;dc_flags &amp; DC_64BIT_HASH)</a>
<a name="ln925">		return (crc &amp; ((1 &lt;&lt; DC_BITS_64) - 1));</a>
<a name="ln926"> </a>
<a name="ln927">	/* Xircom's hash filtering table is different (read: weird) */</a>
<a name="ln928">	/* Xircom uses the LEAST significant bits */</a>
<a name="ln929">	if (DC_IS_XIRCOM(sc)) {</a>
<a name="ln930">		if ((crc &amp; 0x180) == 0x180)</a>
<a name="ln931">			return ((crc &amp; 0x0F) + (crc &amp; 0x70) * 3 + (14 &lt;&lt; 4));</a>
<a name="ln932">		else</a>
<a name="ln933">			return ((crc &amp; 0x1F) + ((crc &gt;&gt; 1) &amp; 0xF0) * 3 +</a>
<a name="ln934">			    (12 &lt;&lt; 4));</a>
<a name="ln935">	}</a>
<a name="ln936"> </a>
<a name="ln937">	return (crc &amp; ((1 &lt;&lt; DC_BITS_512) - 1));</a>
<a name="ln938">}</a>
<a name="ln939"> </a>
<a name="ln940">/*</a>
<a name="ln941"> * Calculate CRC of a multicast group address, return the lower 6 bits.</a>
<a name="ln942"> */</a>
<a name="ln943">static uint32_t</a>
<a name="ln944">dc_mchash_be(const uint8_t *addr)</a>
<a name="ln945">{</a>
<a name="ln946">	uint32_t crc;</a>
<a name="ln947"> </a>
<a name="ln948">	/* Compute CRC for the address value. */</a>
<a name="ln949">	crc = ether_crc32_be(addr, ETHER_ADDR_LEN);</a>
<a name="ln950"> </a>
<a name="ln951">	/* Return the filter bit position. */</a>
<a name="ln952">	return ((crc &gt;&gt; 26) &amp; 0x0000003F);</a>
<a name="ln953">}</a>
<a name="ln954"> </a>
<a name="ln955">/*</a>
<a name="ln956"> * 21143-style RX filter setup routine. Filter programming is done by</a>
<a name="ln957"> * downloading a special setup frame into the TX engine. 21143, Macronix,</a>
<a name="ln958"> * PNIC, PNIC II and Davicom chips are programmed this way.</a>
<a name="ln959"> *</a>
<a name="ln960"> * We always program the chip using 'hash perfect' mode, i.e. one perfect</a>
<a name="ln961"> * address (our node address) and a 512-bit hash filter for multicast</a>
<a name="ln962"> * frames. We also sneak the broadcast address into the hash filter since</a>
<a name="ln963"> * we need that too.</a>
<a name="ln964"> */</a>
<a name="ln965">static void</a>
<a name="ln966">dc_setfilt_21143(struct dc_softc *sc)</a>
<a name="ln967">{</a>
<a name="ln968">	uint16_t eaddr[(ETHER_ADDR_LEN+1)/2];</a>
<a name="ln969">	struct dc_desc *sframe;</a>
<a name="ln970">	uint32_t h, *sp;</a>
<a name="ln971">	struct ifmultiaddr *ifma;</a>
<a name="ln972">	struct ifnet *ifp;</a>
<a name="ln973">	int i;</a>
<a name="ln974"> </a>
<a name="ln975">	ifp = sc-&gt;dc_ifp;</a>
<a name="ln976"> </a>
<a name="ln977">	i = sc-&gt;dc_cdata.dc_tx_prod;</a>
<a name="ln978">	DC_INC(sc-&gt;dc_cdata.dc_tx_prod, DC_TX_LIST_CNT);</a>
<a name="ln979">	sc-&gt;dc_cdata.dc_tx_cnt++;</a>
<a name="ln980">	sframe = &amp;sc-&gt;dc_ldata.dc_tx_list[i];</a>
<a name="ln981">	sp = sc-&gt;dc_cdata.dc_sbuf;</a>
<a name="ln982">	bzero(sp, DC_SFRAME_LEN);</a>
<a name="ln983"> </a>
<a name="ln984">	sframe-&gt;dc_data = htole32(DC_ADDR_LO(sc-&gt;dc_saddr));</a>
<a name="ln985">	sframe-&gt;dc_ctl = htole32(DC_SFRAME_LEN | DC_TXCTL_SETUP |</a>
<a name="ln986">	    DC_TXCTL_TLINK | DC_FILTER_HASHPERF | DC_TXCTL_FINT);</a>
<a name="ln987"> </a>
<a name="ln988">	sc-&gt;dc_cdata.dc_tx_chain[i] = (struct mbuf *)sc-&gt;dc_cdata.dc_sbuf;</a>
<a name="ln989"> </a>
<a name="ln990">	/* If we want promiscuous mode, set the allframes bit. */</a>
<a name="ln991">	if (ifp-&gt;if_flags &amp; IFF_PROMISC)</a>
<a name="ln992">		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);</a>
<a name="ln993">	else</a>
<a name="ln994">		DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);</a>
<a name="ln995"> </a>
<a name="ln996">	if (ifp-&gt;if_flags &amp; IFF_ALLMULTI)</a>
<a name="ln997">		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);</a>
<a name="ln998">	else</a>
<a name="ln999">		DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);</a>
<a name="ln1000"> </a>
<a name="ln1001">	if_maddr_rlock(ifp);</a>
<a name="ln1002">	TAILQ_FOREACH(ifma, &amp;ifp-&gt;if_multiaddrs, ifma_link) {</a>
<a name="ln1003">		if (ifma-&gt;ifma_addr-&gt;sa_family != AF_LINK)</a>
<a name="ln1004">			continue;</a>
<a name="ln1005">		h = dc_mchash_le(sc,</a>
<a name="ln1006">		    LLADDR((struct sockaddr_dl *)ifma-&gt;ifma_addr));</a>
<a name="ln1007">		sp[h &gt;&gt; 4] |= htole32(1 &lt;&lt; (h &amp; 0xF));</a>
<a name="ln1008">	}</a>
<a name="ln1009">	if_maddr_runlock(ifp);</a>
<a name="ln1010"> </a>
<a name="ln1011">	if (ifp-&gt;if_flags &amp; IFF_BROADCAST) {</a>
<a name="ln1012">		h = dc_mchash_le(sc, ifp-&gt;if_broadcastaddr);</a>
<a name="ln1013">		sp[h &gt;&gt; 4] |= htole32(1 &lt;&lt; (h &amp; 0xF));</a>
<a name="ln1014">	}</a>
<a name="ln1015"> </a>
<a name="ln1016">	/* Set our MAC address. */</a>
<a name="ln1017">	bcopy(IF_LLADDR(sc-&gt;dc_ifp), eaddr, ETHER_ADDR_LEN);</a>
<a name="ln1018">	sp[39] = DC_SP_MAC(eaddr[0]);</a>
<a name="ln1019">	sp[40] = DC_SP_MAC(eaddr[1]);</a>
<a name="ln1020">	sp[41] = DC_SP_MAC(eaddr[2]);</a>
<a name="ln1021"> </a>
<a name="ln1022">	sframe-&gt;dc_status = htole32(DC_TXSTAT_OWN);</a>
<a name="ln1023">	bus_dmamap_sync(sc-&gt;dc_tx_ltag, sc-&gt;dc_tx_lmap, BUS_DMASYNC_PREREAD |</a>
<a name="ln1024">	    BUS_DMASYNC_PREWRITE);</a>
<a name="ln1025">	bus_dmamap_sync(sc-&gt;dc_stag, sc-&gt;dc_smap, BUS_DMASYNC_PREWRITE);</a>
<a name="ln1026">	CSR_WRITE_4(sc, DC_TXSTART, 0xFFFFFFFF);</a>
<a name="ln1027"> </a>
<a name="ln1028">	/*</a>
<a name="ln1029">	 * The PNIC takes an exceedingly long time to process its</a>
<a name="ln1030">	 * setup frame; wait 10ms after posting the setup frame</a>
<a name="ln1031">	 * before proceeding, just so it has time to swallow its</a>
<a name="ln1032">	 * medicine.</a>
<a name="ln1033">	 */</a>
<a name="ln1034">	DELAY(10000);</a>
<a name="ln1035"> </a>
<a name="ln1036">	sc-&gt;dc_wdog_timer = 5;</a>
<a name="ln1037">}</a>
<a name="ln1038"> </a>
<a name="ln1039">static void</a>
<a name="ln1040">dc_setfilt_admtek(struct dc_softc *sc)</a>
<a name="ln1041">{</a>
<a name="ln1042">	uint8_t eaddr[ETHER_ADDR_LEN];</a>
<a name="ln1043">	struct ifnet *ifp;</a>
<a name="ln1044">	struct ifmultiaddr *ifma;</a>
<a name="ln1045">	int h = 0;</a>
<a name="ln1046">	uint32_t hashes[2] = { 0, 0 };</a>
<a name="ln1047"> </a>
<a name="ln1048">	ifp = sc-&gt;dc_ifp;</a>
<a name="ln1049"> </a>
<a name="ln1050">	/* Init our MAC address. */</a>
<a name="ln1051">	bcopy(IF_LLADDR(sc-&gt;dc_ifp), eaddr, ETHER_ADDR_LEN);</a>
<a name="ln1052">	CSR_WRITE_4(sc, DC_AL_PAR0, eaddr[3] &lt;&lt; 24 | eaddr[2] &lt;&lt; 16 |</a>
<a name="ln1053">	    eaddr[1] &lt;&lt; 8 | eaddr[0]);</a>
<a name="ln1054">	CSR_WRITE_4(sc, DC_AL_PAR1, eaddr[5] &lt;&lt; 8 | eaddr[4]);</a>
<a name="ln1055"> </a>
<a name="ln1056">	/* If we want promiscuous mode, set the allframes bit. */</a>
<a name="ln1057">	if (ifp-&gt;if_flags &amp; IFF_PROMISC)</a>
<a name="ln1058">		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);</a>
<a name="ln1059">	else</a>
<a name="ln1060">		DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);</a>
<a name="ln1061"> </a>
<a name="ln1062">	if (ifp-&gt;if_flags &amp; IFF_ALLMULTI)</a>
<a name="ln1063">		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);</a>
<a name="ln1064">	else</a>
<a name="ln1065">		DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);</a>
<a name="ln1066"> </a>
<a name="ln1067">	/* First, zot all the existing hash bits. */</a>
<a name="ln1068">	CSR_WRITE_4(sc, DC_AL_MAR0, 0);</a>
<a name="ln1069">	CSR_WRITE_4(sc, DC_AL_MAR1, 0);</a>
<a name="ln1070"> </a>
<a name="ln1071">	/*</a>
<a name="ln1072">	 * If we're already in promisc or allmulti mode, we</a>
<a name="ln1073">	 * don't have to bother programming the multicast filter.</a>
<a name="ln1074">	 */</a>
<a name="ln1075">	if (ifp-&gt;if_flags &amp; (IFF_PROMISC | IFF_ALLMULTI))</a>
<a name="ln1076">		return;</a>
<a name="ln1077"> </a>
<a name="ln1078">	/* Now program new ones. */</a>
<a name="ln1079">	if_maddr_rlock(ifp);</a>
<a name="ln1080">	TAILQ_FOREACH(ifma, &amp;ifp-&gt;if_multiaddrs, ifma_link) {</a>
<a name="ln1081">		if (ifma-&gt;ifma_addr-&gt;sa_family != AF_LINK)</a>
<a name="ln1082">			continue;</a>
<a name="ln1083">		if (DC_IS_CENTAUR(sc))</a>
<a name="ln1084">			h = dc_mchash_le(sc,</a>
<a name="ln1085">			    LLADDR((struct sockaddr_dl *)ifma-&gt;ifma_addr));</a>
<a name="ln1086">		else</a>
<a name="ln1087">			h = dc_mchash_be(</a>
<a name="ln1088">			    LLADDR((struct sockaddr_dl *)ifma-&gt;ifma_addr));</a>
<a name="ln1089">		if (h &lt; 32)</a>
<a name="ln1090">			hashes[0] |= (1 &lt;&lt; h);</a>
<a name="ln1091">		else</a>
<a name="ln1092">			hashes[1] |= (1 &lt;&lt; (h - 32));</a>
<a name="ln1093">	}</a>
<a name="ln1094">	if_maddr_runlock(ifp);</a>
<a name="ln1095"> </a>
<a name="ln1096">	CSR_WRITE_4(sc, DC_AL_MAR0, hashes[0]);</a>
<a name="ln1097">	CSR_WRITE_4(sc, DC_AL_MAR1, hashes[1]);</a>
<a name="ln1098">}</a>
<a name="ln1099"> </a>
<a name="ln1100">static void</a>
<a name="ln1101">dc_setfilt_asix(struct dc_softc *sc)</a>
<a name="ln1102">{</a>
<a name="ln1103">	uint32_t eaddr[(ETHER_ADDR_LEN+3)/4];</a>
<a name="ln1104">	struct ifnet *ifp;</a>
<a name="ln1105">	struct ifmultiaddr *ifma;</a>
<a name="ln1106">	int h = 0;</a>
<a name="ln1107">	uint32_t hashes[2] = { 0, 0 };</a>
<a name="ln1108"> </a>
<a name="ln1109">	ifp = sc-&gt;dc_ifp;</a>
<a name="ln1110"> </a>
<a name="ln1111">	/* Init our MAC address. */</a>
<a name="ln1112">	bcopy(IF_LLADDR(sc-&gt;dc_ifp), eaddr, ETHER_ADDR_LEN);</a>
<a name="ln1113">	CSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_PAR0);</a>
<a name="ln1114">	CSR_WRITE_4(sc, DC_AX_FILTDATA, eaddr[0]);</a>
<a name="ln1115">	CSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_PAR1);</a>
<a name="ln1116">	CSR_WRITE_4(sc, DC_AX_FILTDATA, eaddr[1]);</a>
<a name="ln1117"> </a>
<a name="ln1118">	/* If we want promiscuous mode, set the allframes bit. */</a>
<a name="ln1119">	if (ifp-&gt;if_flags &amp; IFF_PROMISC)</a>
<a name="ln1120">		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);</a>
<a name="ln1121">	else</a>
<a name="ln1122">		DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);</a>
<a name="ln1123"> </a>
<a name="ln1124">	if (ifp-&gt;if_flags &amp; IFF_ALLMULTI)</a>
<a name="ln1125">		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);</a>
<a name="ln1126">	else</a>
<a name="ln1127">		DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);</a>
<a name="ln1128"> </a>
<a name="ln1129">	/*</a>
<a name="ln1130">	 * The ASIX chip has a special bit to enable reception</a>
<a name="ln1131">	 * of broadcast frames.</a>
<a name="ln1132">	 */</a>
<a name="ln1133">	if (ifp-&gt;if_flags &amp; IFF_BROADCAST)</a>
<a name="ln1134">		DC_SETBIT(sc, DC_NETCFG, DC_AX_NETCFG_RX_BROAD);</a>
<a name="ln1135">	else</a>
<a name="ln1136">		DC_CLRBIT(sc, DC_NETCFG, DC_AX_NETCFG_RX_BROAD);</a>
<a name="ln1137"> </a>
<a name="ln1138">	/* first, zot all the existing hash bits */</a>
<a name="ln1139">	CSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_MAR0);</a>
<a name="ln1140">	CSR_WRITE_4(sc, DC_AX_FILTDATA, 0);</a>
<a name="ln1141">	CSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_MAR1);</a>
<a name="ln1142">	CSR_WRITE_4(sc, DC_AX_FILTDATA, 0);</a>
<a name="ln1143"> </a>
<a name="ln1144">	/*</a>
<a name="ln1145">	 * If we're already in promisc or allmulti mode, we</a>
<a name="ln1146">	 * don't have to bother programming the multicast filter.</a>
<a name="ln1147">	 */</a>
<a name="ln1148">	if (ifp-&gt;if_flags &amp; (IFF_PROMISC | IFF_ALLMULTI))</a>
<a name="ln1149">		return;</a>
<a name="ln1150"> </a>
<a name="ln1151">	/* now program new ones */</a>
<a name="ln1152">	if_maddr_rlock(ifp);</a>
<a name="ln1153">	TAILQ_FOREACH(ifma, &amp;ifp-&gt;if_multiaddrs, ifma_link) {</a>
<a name="ln1154">		if (ifma-&gt;ifma_addr-&gt;sa_family != AF_LINK)</a>
<a name="ln1155">			continue;</a>
<a name="ln1156">		h = dc_mchash_be(LLADDR((struct sockaddr_dl *)ifma-&gt;ifma_addr));</a>
<a name="ln1157">		if (h &lt; 32)</a>
<a name="ln1158">			hashes[0] |= (1 &lt;&lt; h);</a>
<a name="ln1159">		else</a>
<a name="ln1160">			hashes[1] |= (1 &lt;&lt; (h - 32));</a>
<a name="ln1161">	}</a>
<a name="ln1162">	if_maddr_runlock(ifp);</a>
<a name="ln1163"> </a>
<a name="ln1164">	CSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_MAR0);</a>
<a name="ln1165">	CSR_WRITE_4(sc, DC_AX_FILTDATA, hashes[0]);</a>
<a name="ln1166">	CSR_WRITE_4(sc, DC_AX_FILTIDX, DC_AX_FILTIDX_MAR1);</a>
<a name="ln1167">	CSR_WRITE_4(sc, DC_AX_FILTDATA, hashes[1]);</a>
<a name="ln1168">}</a>
<a name="ln1169"> </a>
<a name="ln1170">static void</a>
<a name="ln1171">dc_setfilt_uli(struct dc_softc *sc)</a>
<a name="ln1172">{</a>
<a name="ln1173">	uint8_t eaddr[ETHER_ADDR_LEN];</a>
<a name="ln1174">	struct ifnet *ifp;</a>
<a name="ln1175">	struct ifmultiaddr *ifma;</a>
<a name="ln1176">	struct dc_desc *sframe;</a>
<a name="ln1177">	uint32_t filter, *sp;</a>
<a name="ln1178">	uint8_t *ma;</a>
<a name="ln1179">	int i, mcnt;</a>
<a name="ln1180"> </a>
<a name="ln1181">	ifp = sc-&gt;dc_ifp;</a>
<a name="ln1182"> </a>
<a name="ln1183">	i = sc-&gt;dc_cdata.dc_tx_prod;</a>
<a name="ln1184">	DC_INC(sc-&gt;dc_cdata.dc_tx_prod, DC_TX_LIST_CNT);</a>
<a name="ln1185">	sc-&gt;dc_cdata.dc_tx_cnt++;</a>
<a name="ln1186">	sframe = &amp;sc-&gt;dc_ldata.dc_tx_list[i];</a>
<a name="ln1187">	sp = sc-&gt;dc_cdata.dc_sbuf;</a>
<a name="ln1188">	bzero(sp, DC_SFRAME_LEN);</a>
<a name="ln1189"> </a>
<a name="ln1190">	sframe-&gt;dc_data = htole32(DC_ADDR_LO(sc-&gt;dc_saddr));</a>
<a name="ln1191">	sframe-&gt;dc_ctl = htole32(DC_SFRAME_LEN | DC_TXCTL_SETUP |</a>
<a name="ln1192">	    DC_TXCTL_TLINK | DC_FILTER_PERFECT | DC_TXCTL_FINT);</a>
<a name="ln1193"> </a>
<a name="ln1194">	sc-&gt;dc_cdata.dc_tx_chain[i] = (struct mbuf *)sc-&gt;dc_cdata.dc_sbuf;</a>
<a name="ln1195"> </a>
<a name="ln1196">	/* Set station address. */</a>
<a name="ln1197">	bcopy(IF_LLADDR(sc-&gt;dc_ifp), eaddr, ETHER_ADDR_LEN);</a>
<a name="ln1198">	*sp++ = DC_SP_MAC(eaddr[1] &lt;&lt; 8 | eaddr[0]);</a>
<a name="ln1199">	*sp++ = DC_SP_MAC(eaddr[3] &lt;&lt; 8 | eaddr[2]);</a>
<a name="ln1200">	*sp++ = DC_SP_MAC(eaddr[5] &lt;&lt; 8 | eaddr[4]);</a>
<a name="ln1201"> </a>
<a name="ln1202">	/* Set broadcast address. */</a>
<a name="ln1203">	*sp++ = DC_SP_MAC(0xFFFF);</a>
<a name="ln1204">	*sp++ = DC_SP_MAC(0xFFFF);</a>
<a name="ln1205">	*sp++ = DC_SP_MAC(0xFFFF);</a>
<a name="ln1206"> </a>
<a name="ln1207">	/* Extract current filter configuration. */</a>
<a name="ln1208">	filter = CSR_READ_4(sc, DC_NETCFG);</a>
<a name="ln1209">	filter &amp;= ~(DC_NETCFG_RX_PROMISC | DC_NETCFG_RX_ALLMULTI);</a>
<a name="ln1210"> </a>
<a name="ln1211">	/* Now build perfect filters. */</a>
<a name="ln1212">	mcnt = 0;</a>
<a name="ln1213">	if_maddr_rlock(ifp);</a>
<a name="ln1214">	TAILQ_FOREACH(ifma, &amp;ifp-&gt;if_multiaddrs, ifma_link) {</a>
<a name="ln1215">		if (ifma-&gt;ifma_addr-&gt;sa_family != AF_LINK)</a>
<a name="ln1216">			continue;</a>
<a name="ln1217">		if (mcnt &gt;= DC_ULI_FILTER_NPERF) {</a>
<a name="ln1218">			filter |= DC_NETCFG_RX_ALLMULTI;</a>
<a name="ln1219">			break;</a>
<a name="ln1220">		}</a>
<a name="ln1221">		ma = LLADDR((struct sockaddr_dl *)ifma-&gt;ifma_addr);</a>
<a name="ln1222">		*sp++ = DC_SP_MAC(ma[1] &lt;&lt; 8 | ma[0]);</a>
<a name="ln1223">		*sp++ = DC_SP_MAC(ma[3] &lt;&lt; 8 | ma[2]);</a>
<a name="ln1224">		*sp++ = DC_SP_MAC(ma[5] &lt;&lt; 8 | ma[4]);</a>
<a name="ln1225">		mcnt++;</a>
<a name="ln1226">	}</a>
<a name="ln1227">	if_maddr_runlock(ifp);</a>
<a name="ln1228"> </a>
<a name="ln1229">	for (; mcnt &lt; DC_ULI_FILTER_NPERF; mcnt++) {</a>
<a name="ln1230">		*sp++ = DC_SP_MAC(0xFFFF);</a>
<a name="ln1231">		*sp++ = DC_SP_MAC(0xFFFF);</a>
<a name="ln1232">		*sp++ = DC_SP_MAC(0xFFFF);</a>
<a name="ln1233">	}</a>
<a name="ln1234"> </a>
<a name="ln1235">	if (filter &amp; (DC_NETCFG_TX_ON | DC_NETCFG_RX_ON))</a>
<a name="ln1236">		CSR_WRITE_4(sc, DC_NETCFG,</a>
<a name="ln1237">		    filter &amp; ~(DC_NETCFG_TX_ON | DC_NETCFG_RX_ON));</a>
<a name="ln1238">	if (ifp-&gt;if_flags &amp; IFF_PROMISC)</a>
<a name="ln1239">		filter |= DC_NETCFG_RX_PROMISC | DC_NETCFG_RX_ALLMULTI;</a>
<a name="ln1240">	if (ifp-&gt;if_flags &amp; IFF_ALLMULTI)</a>
<a name="ln1241">		filter |= DC_NETCFG_RX_ALLMULTI;</a>
<a name="ln1242">	CSR_WRITE_4(sc, DC_NETCFG,</a>
<a name="ln1243">	    filter &amp; ~(DC_NETCFG_TX_ON | DC_NETCFG_RX_ON));</a>
<a name="ln1244">	if (filter &amp; (DC_NETCFG_TX_ON | DC_NETCFG_RX_ON))</a>
<a name="ln1245">		CSR_WRITE_4(sc, DC_NETCFG, filter);</a>
<a name="ln1246"> </a>
<a name="ln1247">	sframe-&gt;dc_status = htole32(DC_TXSTAT_OWN);</a>
<a name="ln1248">	bus_dmamap_sync(sc-&gt;dc_tx_ltag, sc-&gt;dc_tx_lmap, BUS_DMASYNC_PREREAD |</a>
<a name="ln1249">	    BUS_DMASYNC_PREWRITE);</a>
<a name="ln1250">	bus_dmamap_sync(sc-&gt;dc_stag, sc-&gt;dc_smap, BUS_DMASYNC_PREWRITE);</a>
<a name="ln1251">	CSR_WRITE_4(sc, DC_TXSTART, 0xFFFFFFFF);</a>
<a name="ln1252"> </a>
<a name="ln1253">	/*</a>
<a name="ln1254">	 * Wait some time...</a>
<a name="ln1255">	 */</a>
<a name="ln1256">	DELAY(1000);</a>
<a name="ln1257"> </a>
<a name="ln1258">	sc-&gt;dc_wdog_timer = 5;</a>
<a name="ln1259">}</a>
<a name="ln1260"> </a>
<a name="ln1261">static void</a>
<a name="ln1262">dc_setfilt_xircom(struct dc_softc *sc)</a>
<a name="ln1263">{</a>
<a name="ln1264">	uint16_t eaddr[(ETHER_ADDR_LEN+1)/2];</a>
<a name="ln1265">	struct ifnet *ifp;</a>
<a name="ln1266">	struct ifmultiaddr *ifma;</a>
<a name="ln1267">	struct dc_desc *sframe;</a>
<a name="ln1268">	uint32_t h, *sp;</a>
<a name="ln1269">	int i;</a>
<a name="ln1270"> </a>
<a name="ln1271">	ifp = sc-&gt;dc_ifp;</a>
<a name="ln1272">	DC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_TX_ON | DC_NETCFG_RX_ON));</a>
<a name="ln1273"> </a>
<a name="ln1274">	i = sc-&gt;dc_cdata.dc_tx_prod;</a>
<a name="ln1275">	DC_INC(sc-&gt;dc_cdata.dc_tx_prod, DC_TX_LIST_CNT);</a>
<a name="ln1276">	sc-&gt;dc_cdata.dc_tx_cnt++;</a>
<a name="ln1277">	sframe = &amp;sc-&gt;dc_ldata.dc_tx_list[i];</a>
<a name="ln1278">	sp = sc-&gt;dc_cdata.dc_sbuf;</a>
<a name="ln1279">	bzero(sp, DC_SFRAME_LEN);</a>
<a name="ln1280"> </a>
<a name="ln1281">	sframe-&gt;dc_data = htole32(DC_ADDR_LO(sc-&gt;dc_saddr));</a>
<a name="ln1282">	sframe-&gt;dc_ctl = htole32(DC_SFRAME_LEN | DC_TXCTL_SETUP |</a>
<a name="ln1283">	    DC_TXCTL_TLINK | DC_FILTER_HASHPERF | DC_TXCTL_FINT);</a>
<a name="ln1284"> </a>
<a name="ln1285">	sc-&gt;dc_cdata.dc_tx_chain[i] = (struct mbuf *)sc-&gt;dc_cdata.dc_sbuf;</a>
<a name="ln1286"> </a>
<a name="ln1287">	/* If we want promiscuous mode, set the allframes bit. */</a>
<a name="ln1288">	if (ifp-&gt;if_flags &amp; IFF_PROMISC)</a>
<a name="ln1289">		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);</a>
<a name="ln1290">	else</a>
<a name="ln1291">		DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_PROMISC);</a>
<a name="ln1292"> </a>
<a name="ln1293">	if (ifp-&gt;if_flags &amp; IFF_ALLMULTI)</a>
<a name="ln1294">		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);</a>
<a name="ln1295">	else</a>
<a name="ln1296">		DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_RX_ALLMULTI);</a>
<a name="ln1297"> </a>
<a name="ln1298">	if_maddr_rlock(ifp);</a>
<a name="ln1299">	TAILQ_FOREACH(ifma, &amp;ifp-&gt;if_multiaddrs, ifma_link) {</a>
<a name="ln1300">		if (ifma-&gt;ifma_addr-&gt;sa_family != AF_LINK)</a>
<a name="ln1301">			continue;</a>
<a name="ln1302">		h = dc_mchash_le(sc,</a>
<a name="ln1303">		    LLADDR((struct sockaddr_dl *)ifma-&gt;ifma_addr));</a>
<a name="ln1304">		sp[h &gt;&gt; 4] |= htole32(1 &lt;&lt; (h &amp; 0xF));</a>
<a name="ln1305">	}</a>
<a name="ln1306">	if_maddr_runlock(ifp);</a>
<a name="ln1307"> </a>
<a name="ln1308">	if (ifp-&gt;if_flags &amp; IFF_BROADCAST) {</a>
<a name="ln1309">		h = dc_mchash_le(sc, ifp-&gt;if_broadcastaddr);</a>
<a name="ln1310">		sp[h &gt;&gt; 4] |= htole32(1 &lt;&lt; (h &amp; 0xF));</a>
<a name="ln1311">	}</a>
<a name="ln1312"> </a>
<a name="ln1313">	/* Set our MAC address. */</a>
<a name="ln1314">	bcopy(IF_LLADDR(sc-&gt;dc_ifp), eaddr, ETHER_ADDR_LEN);</a>
<a name="ln1315">	sp[0] = DC_SP_MAC(eaddr[0]);</a>
<a name="ln1316">	sp[1] = DC_SP_MAC(eaddr[1]);</a>
<a name="ln1317">	sp[2] = DC_SP_MAC(eaddr[2]);</a>
<a name="ln1318"> </a>
<a name="ln1319">	DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON);</a>
<a name="ln1320">	DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ON);</a>
<a name="ln1321">	sframe-&gt;dc_status = htole32(DC_TXSTAT_OWN);</a>
<a name="ln1322">	bus_dmamap_sync(sc-&gt;dc_tx_ltag, sc-&gt;dc_tx_lmap, BUS_DMASYNC_PREREAD |</a>
<a name="ln1323">	    BUS_DMASYNC_PREWRITE);</a>
<a name="ln1324">	bus_dmamap_sync(sc-&gt;dc_stag, sc-&gt;dc_smap, BUS_DMASYNC_PREWRITE);</a>
<a name="ln1325">	CSR_WRITE_4(sc, DC_TXSTART, 0xFFFFFFFF);</a>
<a name="ln1326"> </a>
<a name="ln1327">	/*</a>
<a name="ln1328">	 * Wait some time...</a>
<a name="ln1329">	 */</a>
<a name="ln1330">	DELAY(1000);</a>
<a name="ln1331"> </a>
<a name="ln1332">	sc-&gt;dc_wdog_timer = 5;</a>
<a name="ln1333">}</a>
<a name="ln1334"> </a>
<a name="ln1335">static void</a>
<a name="ln1336">dc_setfilt(struct dc_softc *sc)</a>
<a name="ln1337">{</a>
<a name="ln1338"> </a>
<a name="ln1339">	if (DC_IS_INTEL(sc) || DC_IS_MACRONIX(sc) || DC_IS_PNIC(sc) ||</a>
<a name="ln1340">	    DC_IS_PNICII(sc) || DC_IS_DAVICOM(sc) || DC_IS_CONEXANT(sc))</a>
<a name="ln1341">		dc_setfilt_21143(sc);</a>
<a name="ln1342"> </a>
<a name="ln1343">	if (DC_IS_ASIX(sc))</a>
<a name="ln1344">		dc_setfilt_asix(sc);</a>
<a name="ln1345"> </a>
<a name="ln1346">	if (DC_IS_ADMTEK(sc))</a>
<a name="ln1347">		dc_setfilt_admtek(sc);</a>
<a name="ln1348"> </a>
<a name="ln1349">	if (DC_IS_ULI(sc))</a>
<a name="ln1350">		dc_setfilt_uli(sc);</a>
<a name="ln1351"> </a>
<a name="ln1352">	if (DC_IS_XIRCOM(sc))</a>
<a name="ln1353">		dc_setfilt_xircom(sc);</a>
<a name="ln1354">}</a>
<a name="ln1355"> </a>
<a name="ln1356">static void</a>
<a name="ln1357">dc_netcfg_wait(struct dc_softc *sc)</a>
<a name="ln1358">{</a>
<a name="ln1359">	uint32_t isr;</a>
<a name="ln1360">	int i;</a>
<a name="ln1361"> </a>
<a name="ln1362">	for (i = 0; i &lt; DC_TIMEOUT; i++) {</a>
<a name="ln1363">		isr = CSR_READ_4(sc, DC_ISR);</a>
<a name="ln1364">		if (isr &amp; DC_ISR_TX_IDLE &amp;&amp;</a>
<a name="ln1365">		    ((isr &amp; DC_ISR_RX_STATE) == DC_RXSTATE_STOPPED ||</a>
<a name="ln1366">		    (isr &amp; DC_ISR_RX_STATE) == DC_RXSTATE_WAIT))</a>
<a name="ln1367">			break;</a>
<a name="ln1368">		DELAY(10);</a>
<a name="ln1369">	}</a>
<a name="ln1370">	if (i == DC_TIMEOUT &amp;&amp; bus_child_present(sc-&gt;dc_dev)) {</a>
<a name="ln1371">		if (!(isr &amp; DC_ISR_TX_IDLE) &amp;&amp; !DC_IS_ASIX(sc))</a>
<a name="ln1372">			device_printf(sc-&gt;dc_dev,</a>
<a name="ln1373">			    &quot;%s: failed to force tx to idle state\n&quot;, __func__);</a>
<a name="ln1374">		if (!((isr &amp; DC_ISR_RX_STATE) == DC_RXSTATE_STOPPED ||</a>
<a name="ln1375">		    (isr &amp; DC_ISR_RX_STATE) == DC_RXSTATE_WAIT) &amp;&amp;</a>
<a name="ln1376">		    !DC_HAS_BROKEN_RXSTATE(sc))</a>
<a name="ln1377">			device_printf(sc-&gt;dc_dev,</a>
<a name="ln1378">			    &quot;%s: failed to force rx to idle state\n&quot;, __func__);</a>
<a name="ln1379">	}</a>
<a name="ln1380">}</a>
<a name="ln1381"> </a>
<a name="ln1382">/*</a>
<a name="ln1383"> * In order to fiddle with the 'full-duplex' and '100Mbps' bits in</a>
<a name="ln1384"> * the netconfig register, we first have to put the transmit and/or</a>
<a name="ln1385"> * receive logic in the idle state.</a>
<a name="ln1386"> */</a>
<a name="ln1387">static void</a>
<a name="ln1388">dc_setcfg(struct dc_softc *sc, int media)</a>
<a name="ln1389">{</a>
<a name="ln1390">	int restart = 0, watchdogreg;</a>
<a name="ln1391"> </a>
<a name="ln1392">	if (IFM_SUBTYPE(media) == IFM_NONE)</a>
<a name="ln1393">		return;</a>
<a name="ln1394"> </a>
<a name="ln1395">	if (CSR_READ_4(sc, DC_NETCFG) &amp; (DC_NETCFG_TX_ON | DC_NETCFG_RX_ON)) {</a>
<a name="ln1396">		restart = 1;</a>
<a name="ln1397">		DC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_TX_ON | DC_NETCFG_RX_ON));</a>
<a name="ln1398">		dc_netcfg_wait(sc);</a>
<a name="ln1399">	}</a>
<a name="ln1400"> </a>
<a name="ln1401">	if (IFM_SUBTYPE(media) == IFM_100_TX) {</a>
<a name="ln1402">		DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_SPEEDSEL);</a>
<a name="ln1403">		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_HEARTBEAT);</a>
<a name="ln1404">		if (sc-&gt;dc_pmode == DC_PMODE_MII) {</a>
<a name="ln1405">			if (DC_IS_INTEL(sc)) {</a>
<a name="ln1406">			/* There's a write enable bit here that reads as 1. */</a>
<a name="ln1407">				watchdogreg = CSR_READ_4(sc, DC_WATCHDOG);</a>
<a name="ln1408">				watchdogreg &amp;= ~DC_WDOG_CTLWREN;</a>
<a name="ln1409">				watchdogreg |= DC_WDOG_JABBERDIS;</a>
<a name="ln1410">				CSR_WRITE_4(sc, DC_WATCHDOG, watchdogreg);</a>
<a name="ln1411">			} else {</a>
<a name="ln1412">				DC_SETBIT(sc, DC_WATCHDOG, DC_WDOG_JABBERDIS);</a>
<a name="ln1413">			}</a>
<a name="ln1414">			DC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_PCS |</a>
<a name="ln1415">			    DC_NETCFG_PORTSEL | DC_NETCFG_SCRAMBLER));</a>
<a name="ln1416">			if (sc-&gt;dc_type == DC_TYPE_98713)</a>
<a name="ln1417">				DC_SETBIT(sc, DC_NETCFG, (DC_NETCFG_PCS |</a>
<a name="ln1418">				    DC_NETCFG_SCRAMBLER));</a>
<a name="ln1419">			if (!DC_IS_DAVICOM(sc))</a>
<a name="ln1420">				DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);</a>
<a name="ln1421">			DC_CLRBIT(sc, DC_10BTCTRL, 0xFFFF);</a>
<a name="ln1422">		} else {</a>
<a name="ln1423">			if (DC_IS_PNIC(sc)) {</a>
<a name="ln1424">				DC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_SPEEDSEL);</a>
<a name="ln1425">				DC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_100TX_LOOP);</a>
<a name="ln1426">				DC_SETBIT(sc, DC_PN_NWAY, DC_PN_NWAY_SPEEDSEL);</a>
<a name="ln1427">			}</a>
<a name="ln1428">			DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);</a>
<a name="ln1429">			DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PCS);</a>
<a name="ln1430">			DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_SCRAMBLER);</a>
<a name="ln1431">		}</a>
<a name="ln1432">	}</a>
<a name="ln1433"> </a>
<a name="ln1434">	if (IFM_SUBTYPE(media) == IFM_10_T) {</a>
<a name="ln1435">		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_SPEEDSEL);</a>
<a name="ln1436">		DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_HEARTBEAT);</a>
<a name="ln1437">		if (sc-&gt;dc_pmode == DC_PMODE_MII) {</a>
<a name="ln1438">			/* There's a write enable bit here that reads as 1. */</a>
<a name="ln1439">			if (DC_IS_INTEL(sc)) {</a>
<a name="ln1440">				watchdogreg = CSR_READ_4(sc, DC_WATCHDOG);</a>
<a name="ln1441">				watchdogreg &amp;= ~DC_WDOG_CTLWREN;</a>
<a name="ln1442">				watchdogreg |= DC_WDOG_JABBERDIS;</a>
<a name="ln1443">				CSR_WRITE_4(sc, DC_WATCHDOG, watchdogreg);</a>
<a name="ln1444">			} else {</a>
<a name="ln1445">				DC_SETBIT(sc, DC_WATCHDOG, DC_WDOG_JABBERDIS);</a>
<a name="ln1446">			}</a>
<a name="ln1447">			DC_CLRBIT(sc, DC_NETCFG, (DC_NETCFG_PCS |</a>
<a name="ln1448">			    DC_NETCFG_PORTSEL | DC_NETCFG_SCRAMBLER));</a>
<a name="ln1449">			if (sc-&gt;dc_type == DC_TYPE_98713)</a>
<a name="ln1450">				DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PCS);</a>
<a name="ln1451">			if (!DC_IS_DAVICOM(sc))</a>
<a name="ln1452">				DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);</a>
<a name="ln1453">			DC_CLRBIT(sc, DC_10BTCTRL, 0xFFFF);</a>
<a name="ln1454">		} else {</a>
<a name="ln1455">			if (DC_IS_PNIC(sc)) {</a>
<a name="ln1456">				DC_PN_GPIO_CLRBIT(sc, DC_PN_GPIO_SPEEDSEL);</a>
<a name="ln1457">				DC_PN_GPIO_SETBIT(sc, DC_PN_GPIO_100TX_LOOP);</a>
<a name="ln1458">				DC_CLRBIT(sc, DC_PN_NWAY, DC_PN_NWAY_SPEEDSEL);</a>
<a name="ln1459">			}</a>
<a name="ln1460">			DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);</a>
<a name="ln1461">			DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PCS);</a>
<a name="ln1462">			DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_SCRAMBLER);</a>
<a name="ln1463">			if (DC_IS_INTEL(sc)) {</a>
<a name="ln1464">				DC_CLRBIT(sc, DC_SIARESET, DC_SIA_RESET);</a>
<a name="ln1465">				DC_CLRBIT(sc, DC_10BTCTRL, 0xFFFF);</a>
<a name="ln1466">				if ((media &amp; IFM_GMASK) == IFM_FDX)</a>
<a name="ln1467">					DC_SETBIT(sc, DC_10BTCTRL, 0x7F3D);</a>
<a name="ln1468">				else</a>
<a name="ln1469">					DC_SETBIT(sc, DC_10BTCTRL, 0x7F3F);</a>
<a name="ln1470">				DC_SETBIT(sc, DC_SIARESET, DC_SIA_RESET);</a>
<a name="ln1471">				DC_CLRBIT(sc, DC_10BTCTRL,</a>
<a name="ln1472">				    DC_TCTL_AUTONEGENBL);</a>
<a name="ln1473">				DELAY(20000);</a>
<a name="ln1474">			}</a>
<a name="ln1475">		}</a>
<a name="ln1476">	}</a>
<a name="ln1477"> </a>
<a name="ln1478">	/*</a>
<a name="ln1479">	 * If this is a Davicom DM9102A card with a DM9801 HomePNA</a>
<a name="ln1480">	 * PHY and we want HomePNA mode, set the portsel bit to turn</a>
<a name="ln1481">	 * on the external MII port.</a>
<a name="ln1482">	 */</a>
<a name="ln1483">	if (DC_IS_DAVICOM(sc)) {</a>
<a name="ln1484">		if (IFM_SUBTYPE(media) == IFM_HPNA_1) {</a>
<a name="ln1485">			DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);</a>
<a name="ln1486">			sc-&gt;dc_link = 1;</a>
<a name="ln1487">		} else {</a>
<a name="ln1488">			DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_PORTSEL);</a>
<a name="ln1489">		}</a>
<a name="ln1490">	}</a>
<a name="ln1491"> </a>
<a name="ln1492">	if ((media &amp; IFM_GMASK) == IFM_FDX) {</a>
<a name="ln1493">		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_FULLDUPLEX);</a>
<a name="ln1494">		if (sc-&gt;dc_pmode == DC_PMODE_SYM &amp;&amp; DC_IS_PNIC(sc))</a>
<a name="ln1495">			DC_SETBIT(sc, DC_PN_NWAY, DC_PN_NWAY_DUPLEX);</a>
<a name="ln1496">	} else {</a>
<a name="ln1497">		DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_FULLDUPLEX);</a>
<a name="ln1498">		if (sc-&gt;dc_pmode == DC_PMODE_SYM &amp;&amp; DC_IS_PNIC(sc))</a>
<a name="ln1499">			DC_CLRBIT(sc, DC_PN_NWAY, DC_PN_NWAY_DUPLEX);</a>
<a name="ln1500">	}</a>
<a name="ln1501"> </a>
<a name="ln1502">	if (restart)</a>
<a name="ln1503">		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON | DC_NETCFG_RX_ON);</a>
<a name="ln1504">}</a>
<a name="ln1505"> </a>
<a name="ln1506">static void</a>
<a name="ln1507">dc_reset(struct dc_softc *sc)</a>
<a name="ln1508">{</a>
<a name="ln1509">	int i;</a>
<a name="ln1510"> </a>
<a name="ln1511">	DC_SETBIT(sc, DC_BUSCTL, DC_BUSCTL_RESET);</a>
<a name="ln1512"> </a>
<a name="ln1513">	for (i = 0; i &lt; DC_TIMEOUT; i++) {</a>
<a name="ln1514">		DELAY(10);</a>
<a name="ln1515">		if (!(CSR_READ_4(sc, DC_BUSCTL) &amp; DC_BUSCTL_RESET))</a>
<a name="ln1516">			break;</a>
<a name="ln1517">	}</a>
<a name="ln1518"> </a>
<a name="ln1519">	if (DC_IS_ASIX(sc) || DC_IS_ADMTEK(sc) || DC_IS_CONEXANT(sc) ||</a>
<a name="ln1520">	    DC_IS_XIRCOM(sc) || DC_IS_INTEL(sc) || DC_IS_ULI(sc)) {</a>
<a name="ln1521">		DELAY(10000);</a>
<a name="ln1522">		DC_CLRBIT(sc, DC_BUSCTL, DC_BUSCTL_RESET);</a>
<a name="ln1523">		i = 0;</a>
<a name="ln1524">	}</a>
<a name="ln1525"> </a>
<a name="ln1526">	if (i == DC_TIMEOUT)</a>
<a name="ln1527">		device_printf(sc-&gt;dc_dev, &quot;reset never completed!\n&quot;);</a>
<a name="ln1528"> </a>
<a name="ln1529">	/* Wait a little while for the chip to get its brains in order. */</a>
<a name="ln1530">	DELAY(1000);</a>
<a name="ln1531"> </a>
<a name="ln1532">	CSR_WRITE_4(sc, DC_IMR, 0x00000000);</a>
<a name="ln1533">	CSR_WRITE_4(sc, DC_BUSCTL, 0x00000000);</a>
<a name="ln1534">	CSR_WRITE_4(sc, DC_NETCFG, 0x00000000);</a>
<a name="ln1535"> </a>
<a name="ln1536">	/*</a>
<a name="ln1537">	 * Bring the SIA out of reset. In some cases, it looks</a>
<a name="ln1538">	 * like failing to unreset the SIA soon enough gets it</a>
<a name="ln1539">	 * into a state where it will never come out of reset</a>
<a name="ln1540">	 * until we reset the whole chip again.</a>
<a name="ln1541">	 */</a>
<a name="ln1542">	if (DC_IS_INTEL(sc)) {</a>
<a name="ln1543">		DC_SETBIT(sc, DC_SIARESET, DC_SIA_RESET);</a>
<a name="ln1544">		CSR_WRITE_4(sc, DC_10BTCTRL, 0xFFFFFFFF);</a>
<a name="ln1545">		CSR_WRITE_4(sc, DC_WATCHDOG, 0);</a>
<a name="ln1546">	}</a>
<a name="ln1547">}</a>
<a name="ln1548"> </a>
<a name="ln1549">static const struct dc_type *</a>
<a name="ln1550">dc_devtype(device_t dev)</a>
<a name="ln1551">{</a>
<a name="ln1552">	const struct dc_type *t;</a>
<a name="ln1553">	uint32_t devid;</a>
<a name="ln1554">	uint8_t rev;</a>
<a name="ln1555"> </a>
<a name="ln1556">	t = dc_devs;</a>
<a name="ln1557">	devid = pci_get_devid(dev);</a>
<a name="ln1558">	rev = pci_get_revid(dev);</a>
<a name="ln1559"> </a>
<a name="ln1560">	while (t-&gt;dc_name != NULL) {</a>
<a name="ln1561">		if (devid == t-&gt;dc_devid &amp;&amp; rev &gt;= t-&gt;dc_minrev)</a>
<a name="ln1562">			return (t);</a>
<a name="ln1563">		t++;</a>
<a name="ln1564">	}</a>
<a name="ln1565"> </a>
<a name="ln1566">	return (NULL);</a>
<a name="ln1567">}</a>
<a name="ln1568"> </a>
<a name="ln1569">/*</a>
<a name="ln1570"> * Probe for a 21143 or clone chip. Check the PCI vendor and device</a>
<a name="ln1571"> * IDs against our list and return a device name if we find a match.</a>
<a name="ln1572"> * We do a little bit of extra work to identify the exact type of</a>
<a name="ln1573"> * chip. The MX98713 and MX98713A have the same PCI vendor/device ID,</a>
<a name="ln1574"> * but different revision IDs. The same is true for 98715/98715A</a>
<a name="ln1575"> * chips and the 98725, as well as the ASIX and ADMtek chips. In some</a>
<a name="ln1576"> * cases, the exact chip revision affects driver behavior.</a>
<a name="ln1577"> */</a>
<a name="ln1578">static int</a>
<a name="ln1579">dc_probe(device_t dev)</a>
<a name="ln1580">{</a>
<a name="ln1581">	const struct dc_type *t;</a>
<a name="ln1582"> </a>
<a name="ln1583">	t = dc_devtype(dev);</a>
<a name="ln1584"> </a>
<a name="ln1585">	if (t != NULL) {</a>
<a name="ln1586">		device_set_desc(dev, t-&gt;dc_name);</a>
<a name="ln1587">		return (BUS_PROBE_DEFAULT);</a>
<a name="ln1588">	}</a>
<a name="ln1589"> </a>
<a name="ln1590">	return (ENXIO);</a>
<a name="ln1591">}</a>
<a name="ln1592"> </a>
<a name="ln1593">static void</a>
<a name="ln1594">dc_apply_fixup(struct dc_softc *sc, int media)</a>
<a name="ln1595">{</a>
<a name="ln1596">	struct dc_mediainfo *m;</a>
<a name="ln1597">	uint8_t *p;</a>
<a name="ln1598">	int i;</a>
<a name="ln1599">	uint32_t reg;</a>
<a name="ln1600"> </a>
<a name="ln1601">	m = sc-&gt;dc_mi;</a>
<a name="ln1602"> </a>
<a name="ln1603">	while (m != NULL) {</a>
<a name="ln1604">		if (m-&gt;dc_media == media)</a>
<a name="ln1605">			break;</a>
<a name="ln1606">		m = m-&gt;dc_next;</a>
<a name="ln1607">	}</a>
<a name="ln1608"> </a>
<a name="ln1609">	if (m == NULL)</a>
<a name="ln1610">		return;</a>
<a name="ln1611"> </a>
<a name="ln1612">	for (i = 0, p = m-&gt;dc_reset_ptr; i &lt; m-&gt;dc_reset_len; i++, p += 2) {</a>
<a name="ln1613">		reg = (p[0] | (p[1] &lt;&lt; 8)) &lt;&lt; 16;</a>
<a name="ln1614">		CSR_WRITE_4(sc, DC_WATCHDOG, reg);</a>
<a name="ln1615">	}</a>
<a name="ln1616"> </a>
<a name="ln1617">	for (i = 0, p = m-&gt;dc_gp_ptr; i &lt; m-&gt;dc_gp_len; i++, p += 2) {</a>
<a name="ln1618">		reg = (p[0] | (p[1] &lt;&lt; 8)) &lt;&lt; 16;</a>
<a name="ln1619">		CSR_WRITE_4(sc, DC_WATCHDOG, reg);</a>
<a name="ln1620">	}</a>
<a name="ln1621">}</a>
<a name="ln1622"> </a>
<a name="ln1623">static int</a>
<a name="ln1624">dc_decode_leaf_sia(struct dc_softc *sc, struct dc_eblock_sia *l)</a>
<a name="ln1625">{</a>
<a name="ln1626">	struct dc_mediainfo *m;</a>
<a name="ln1627"> </a>
<a name="ln1628">	m = malloc(sizeof(struct dc_mediainfo), M_DEVBUF, M_NOWAIT | M_ZERO);</a>
<a name="ln1629">	if (m == NULL) {</a>
<a name="ln1630">		device_printf(sc-&gt;dc_dev, &quot;Could not allocate mediainfo\n&quot;);</a>
<a name="ln1631">		return (ENOMEM);</a>
<a name="ln1632">	}</a>
<a name="ln1633">	switch (l-&gt;dc_sia_code &amp; ~DC_SIA_CODE_EXT) {</a>
<a name="ln1634">	case DC_SIA_CODE_10BT:</a>
<a name="ln1635">		m-&gt;dc_media = IFM_10_T;</a>
<a name="ln1636">		break;</a>
<a name="ln1637">	case DC_SIA_CODE_10BT_FDX:</a>
<a name="ln1638">		m-&gt;dc_media = IFM_10_T | IFM_FDX;</a>
<a name="ln1639">		break;</a>
<a name="ln1640">	case DC_SIA_CODE_10B2:</a>
<a name="ln1641">		m-&gt;dc_media = IFM_10_2;</a>
<a name="ln1642">		break;</a>
<a name="ln1643">	case DC_SIA_CODE_10B5:</a>
<a name="ln1644">		m-&gt;dc_media = IFM_10_5;</a>
<a name="ln1645">		break;</a>
<a name="ln1646">	default:</a>
<a name="ln1647">		break;</a>
<a name="ln1648">	}</a>
<a name="ln1649"> </a>
<a name="ln1650">	/*</a>
<a name="ln1651">	 * We need to ignore CSR13, CSR14, CSR15 for SIA mode.</a>
<a name="ln1652">	 * Things apparently already work for cards that do</a>
<a name="ln1653">	 * supply Media Specific Data.</a>
<a name="ln1654">	 */</a>
<a name="ln1655">	if (l-&gt;dc_sia_code &amp; DC_SIA_CODE_EXT) {</a>
<a name="ln1656">		m-&gt;dc_gp_len = 2;</a>
<a name="ln1657">		m-&gt;dc_gp_ptr =</a>
<a name="ln1658">		(uint8_t *)&amp;l-&gt;dc_un.dc_sia_ext.dc_sia_gpio_ctl;</a>
<a name="ln1659">	} else {</a>
<a name="ln1660">		m-&gt;dc_gp_len = 2;</a>
<a name="ln1661">		m-&gt;dc_gp_ptr =</a>
<a name="ln1662">		(uint8_t *)&amp;l-&gt;dc_un.dc_sia_noext.dc_sia_gpio_ctl;</a>
<a name="ln1663">	}</a>
<a name="ln1664"> </a>
<a name="ln1665">	m-&gt;dc_next = sc-&gt;dc_mi;</a>
<a name="ln1666">	sc-&gt;dc_mi = m;</a>
<a name="ln1667"> </a>
<a name="ln1668">	sc-&gt;dc_pmode = DC_PMODE_SIA;</a>
<a name="ln1669">	return (0);</a>
<a name="ln1670">}</a>
<a name="ln1671"> </a>
<a name="ln1672">static int</a>
<a name="ln1673">dc_decode_leaf_sym(struct dc_softc *sc, struct dc_eblock_sym *l)</a>
<a name="ln1674">{</a>
<a name="ln1675">	struct dc_mediainfo *m;</a>
<a name="ln1676"> </a>
<a name="ln1677">	m = malloc(sizeof(struct dc_mediainfo), M_DEVBUF, M_NOWAIT | M_ZERO);</a>
<a name="ln1678">	if (m == NULL) {</a>
<a name="ln1679">		device_printf(sc-&gt;dc_dev, &quot;Could not allocate mediainfo\n&quot;);</a>
<a name="ln1680">		return (ENOMEM);</a>
<a name="ln1681">	}</a>
<a name="ln1682">	if (l-&gt;dc_sym_code == DC_SYM_CODE_100BT)</a>
<a name="ln1683">		m-&gt;dc_media = IFM_100_TX;</a>
<a name="ln1684"> </a>
<a name="ln1685">	if (l-&gt;dc_sym_code == DC_SYM_CODE_100BT_FDX)</a>
<a name="ln1686">		m-&gt;dc_media = IFM_100_TX | IFM_FDX;</a>
<a name="ln1687"> </a>
<a name="ln1688">	m-&gt;dc_gp_len = 2;</a>
<a name="ln1689">	m-&gt;dc_gp_ptr = (uint8_t *)&amp;l-&gt;dc_sym_gpio_ctl;</a>
<a name="ln1690"> </a>
<a name="ln1691">	m-&gt;dc_next = sc-&gt;dc_mi;</a>
<a name="ln1692">	sc-&gt;dc_mi = m;</a>
<a name="ln1693"> </a>
<a name="ln1694">	sc-&gt;dc_pmode = DC_PMODE_SYM;</a>
<a name="ln1695">	return (0);</a>
<a name="ln1696">}</a>
<a name="ln1697"> </a>
<a name="ln1698">static int</a>
<a name="ln1699">dc_decode_leaf_mii(struct dc_softc *sc, struct dc_eblock_mii *l)</a>
<a name="ln1700">{</a>
<a name="ln1701">	struct dc_mediainfo *m;</a>
<a name="ln1702">	uint8_t *p;</a>
<a name="ln1703"> </a>
<a name="ln1704">	m = malloc(sizeof(struct dc_mediainfo), M_DEVBUF, M_NOWAIT | M_ZERO);</a>
<a name="ln1705">	if (m == NULL) {</a>
<a name="ln1706">		device_printf(sc-&gt;dc_dev, &quot;Could not allocate mediainfo\n&quot;);</a>
<a name="ln1707">		return (ENOMEM);</a>
<a name="ln1708">	}</a>
<a name="ln1709">	/* We abuse IFM_AUTO to represent MII. */</a>
<a name="ln1710">	m-&gt;dc_media = IFM_AUTO;</a>
<a name="ln1711">	m-&gt;dc_gp_len = l-&gt;dc_gpr_len;</a>
<a name="ln1712"> </a>
<a name="ln1713">	p = (uint8_t *)l;</a>
<a name="ln1714">	p += sizeof(struct dc_eblock_mii);</a>
<a name="ln1715">	m-&gt;dc_gp_ptr = p;</a>
<a name="ln1716">	p += 2 * l-&gt;dc_gpr_len;</a>
<a name="ln1717">	m-&gt;dc_reset_len = *p;</a>
<a name="ln1718">	p++;</a>
<a name="ln1719">	m-&gt;dc_reset_ptr = p;</a>
<a name="ln1720"> </a>
<a name="ln1721">	m-&gt;dc_next = sc-&gt;dc_mi;</a>
<a name="ln1722">	sc-&gt;dc_mi = m;</a>
<a name="ln1723">	return (0);</a>
<a name="ln1724">}</a>
<a name="ln1725"> </a>
<a name="ln1726">static int</a>
<a name="ln1727">dc_read_srom(struct dc_softc *sc, int bits)</a>
<a name="ln1728">{</a>
<a name="ln1729">	int size;</a>
<a name="ln1730"> </a>
<a name="ln1731">	size = DC_ROM_SIZE(bits);</a>
<a name="ln1732">	sc-&gt;dc_srom = malloc(size, M_DEVBUF, M_NOWAIT | M_ZERO);</a>
<a name="ln1733">	if (sc-&gt;dc_srom == NULL) {</a>
<a name="ln1734">		device_printf(sc-&gt;dc_dev, &quot;Could not allocate SROM buffer\n&quot;);</a>
<a name="ln1735">		return (ENOMEM);</a>
<a name="ln1736">	}</a>
<a name="ln1737">	dc_read_eeprom(sc, (caddr_t)sc-&gt;dc_srom, 0, (size / 2), 0);</a>
<a name="ln1738">	return (0);</a>
<a name="ln1739">}</a>
<a name="ln1740"> </a>
<a name="ln1741">static int</a>
<a name="ln1742">dc_parse_21143_srom(struct dc_softc *sc)</a>
<a name="ln1743">{</a>
<a name="ln1744">	struct dc_leaf_hdr *lhdr;</a>
<a name="ln1745">	struct dc_eblock_hdr *hdr;</a>
<a name="ln1746">	int error, have_mii, i, loff;</a>
<a name="ln1747">	char *ptr;</a>
<a name="ln1748"> </a>
<a name="ln1749">	have_mii = 0;</a>
<a name="ln1750">	loff = sc-&gt;dc_srom[27];</a>
<a name="ln1751">	lhdr = (struct dc_leaf_hdr *)&amp;(sc-&gt;dc_srom[loff]);</a>
<a name="ln1752"> </a>
<a name="ln1753">	ptr = (char *)lhdr;</a>
<a name="ln1754">	ptr += sizeof(struct dc_leaf_hdr) - 1;</a>
<a name="ln1755">	/*</a>
<a name="ln1756">	 * Look if we got a MII media block.</a>
<a name="ln1757">	 */</a>
<a name="ln1758">	for (i = 0; i &lt; lhdr-&gt;dc_mcnt; i++) {</a>
<a name="ln1759">		hdr = (struct dc_eblock_hdr *)ptr;</a>
<a name="ln1760">		if (hdr-&gt;dc_type == DC_EBLOCK_MII)</a>
<a name="ln1761">		    have_mii++;</a>
<a name="ln1762"> </a>
<a name="ln1763">		ptr += (hdr-&gt;dc_len &amp; 0x7F);</a>
<a name="ln1764">		ptr++;</a>
<a name="ln1765">	}</a>
<a name="ln1766"> </a>
<a name="ln1767">	/*</a>
<a name="ln1768">	 * Do the same thing again. Only use SIA and SYM media</a>
<a name="ln1769">	 * blocks if no MII media block is available.</a>
<a name="ln1770">	 */</a>
<a name="ln1771">	ptr = (char *)lhdr;</a>
<a name="ln1772">	ptr += sizeof(struct dc_leaf_hdr) - 1;</a>
<a name="ln1773">	error = 0;</a>
<a name="ln1774">	for (i = 0; i &lt; lhdr-&gt;dc_mcnt; i++) {</a>
<a name="ln1775">		hdr = (struct dc_eblock_hdr *)ptr;</a>
<a name="ln1776">		switch (hdr-&gt;dc_type) {</a>
<a name="ln1777">		case DC_EBLOCK_MII:</a>
<a name="ln1778">			error = dc_decode_leaf_mii(sc, (struct dc_eblock_mii *)hdr);</a>
<a name="ln1779">			break;</a>
<a name="ln1780">		case DC_EBLOCK_SIA:</a>
<a name="ln1781">			if (! have_mii)</a>
<a name="ln1782">				error = dc_decode_leaf_sia(sc,</a>
<a name="ln1783">				    (struct dc_eblock_sia *)hdr);</a>
<a name="ln1784">			break;</a>
<a name="ln1785">		case DC_EBLOCK_SYM:</a>
<a name="ln1786">			if (! have_mii)</a>
<a name="ln1787">				error = dc_decode_leaf_sym(sc,</a>
<a name="ln1788">				    (struct dc_eblock_sym *)hdr);</a>
<a name="ln1789">			break;</a>
<a name="ln1790">		default:</a>
<a name="ln1791">			/* Don't care. Yet. */</a>
<a name="ln1792">			break;</a>
<a name="ln1793">		}</a>
<a name="ln1794">		ptr += (hdr-&gt;dc_len &amp; 0x7F);</a>
<a name="ln1795">		ptr++;</a>
<a name="ln1796">	}</a>
<a name="ln1797">	return (error);</a>
<a name="ln1798">}</a>
<a name="ln1799"> </a>
<a name="ln1800">static void</a>
<a name="ln1801">dc_dma_map_addr(void *arg, bus_dma_segment_t *segs, int nseg, int error)</a>
<a name="ln1802">{</a>
<a name="ln1803">	bus_addr_t *paddr;</a>
<a name="ln1804"> </a>
<a name="ln1805">	KASSERT(nseg == 1,</a>
<a name="ln1806">	    (&quot;%s: wrong number of segments (%d)&quot;, __func__, nseg));</a>
<a name="ln1807">	paddr = arg;</a>
<a name="ln1808">	*paddr = segs-&gt;ds_addr;</a>
<a name="ln1809">}</a>
<a name="ln1810"> </a>
<a name="ln1811">static int</a>
<a name="ln1812">dc_dma_alloc(struct dc_softc *sc)</a>
<a name="ln1813">{</a>
<a name="ln1814">	int error, i;</a>
<a name="ln1815"> </a>
<a name="ln1816">	error = bus_dma_tag_create(bus_get_dma_tag(sc-&gt;dc_dev), 1, 0,</a>
<a name="ln1817">	    BUS_SPACE_MAXADDR_32BIT, BUS_SPACE_MAXADDR, NULL, NULL,</a>
<a name="ln1818">	    BUS_SPACE_MAXSIZE_32BIT, 0, BUS_SPACE_MAXSIZE_32BIT, 0,</a>
<a name="ln1819">	    NULL, NULL, &amp;sc-&gt;dc_ptag);</a>
<a name="ln1820">	if (error) {</a>
<a name="ln1821">		device_printf(sc-&gt;dc_dev,</a>
<a name="ln1822">		    &quot;failed to allocate parent DMA tag\n&quot;);</a>
<a name="ln1823">		goto fail;</a>
<a name="ln1824">	}</a>
<a name="ln1825"> </a>
<a name="ln1826">	/* Allocate a busdma tag and DMA safe memory for TX/RX descriptors. */</a>
<a name="ln1827">	error = bus_dma_tag_create(sc-&gt;dc_ptag, DC_LIST_ALIGN, 0,</a>
<a name="ln1828">	    BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR, NULL, NULL, DC_RX_LIST_SZ, 1,</a>
<a name="ln1829">	    DC_RX_LIST_SZ, 0, NULL, NULL, &amp;sc-&gt;dc_rx_ltag);</a>
<a name="ln1830">	if (error) {</a>
<a name="ln1831">		device_printf(sc-&gt;dc_dev, &quot;failed to create RX list DMA tag\n&quot;);</a>
<a name="ln1832">		goto fail;</a>
<a name="ln1833">	}</a>
<a name="ln1834"> </a>
<a name="ln1835">	error = bus_dma_tag_create(sc-&gt;dc_ptag, DC_LIST_ALIGN, 0,</a>
<a name="ln1836">	    BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR, NULL, NULL, DC_TX_LIST_SZ, 1,</a>
<a name="ln1837">	    DC_TX_LIST_SZ, 0, NULL, NULL, &amp;sc-&gt;dc_tx_ltag);</a>
<a name="ln1838">	if (error) {</a>
<a name="ln1839">		device_printf(sc-&gt;dc_dev, &quot;failed to create TX list DMA tag\n&quot;);</a>
<a name="ln1840">		goto fail;</a>
<a name="ln1841">	}</a>
<a name="ln1842"> </a>
<a name="ln1843">	/* RX descriptor list. */</a>
<a name="ln1844">	error = bus_dmamem_alloc(sc-&gt;dc_rx_ltag,</a>
<a name="ln1845">	    (void **)&amp;sc-&gt;dc_ldata.dc_rx_list, BUS_DMA_NOWAIT |</a>
<a name="ln1846">	    BUS_DMA_ZERO | BUS_DMA_COHERENT, &amp;sc-&gt;dc_rx_lmap);</a>
<a name="ln1847">	if (error) {</a>
<a name="ln1848">		device_printf(sc-&gt;dc_dev,</a>
<a name="ln1849">		    &quot;failed to allocate DMA'able memory for RX list\n&quot;);</a>
<a name="ln1850">		goto fail;</a>
<a name="ln1851">	}</a>
<a name="ln1852">	error = bus_dmamap_load(sc-&gt;dc_rx_ltag, sc-&gt;dc_rx_lmap,</a>
<a name="ln1853">	    sc-&gt;dc_ldata.dc_rx_list, DC_RX_LIST_SZ, dc_dma_map_addr,</a>
<a name="ln1854">	    &amp;sc-&gt;dc_ldata.dc_rx_list_paddr, BUS_DMA_NOWAIT);</a>
<a name="ln1855">	if (error) {</a>
<a name="ln1856">		device_printf(sc-&gt;dc_dev,</a>
<a name="ln1857">		    &quot;failed to load DMA'able memory for RX list\n&quot;);</a>
<a name="ln1858">		goto fail;</a>
<a name="ln1859">	}</a>
<a name="ln1860">	/* TX descriptor list. */</a>
<a name="ln1861">	error = bus_dmamem_alloc(sc-&gt;dc_tx_ltag,</a>
<a name="ln1862">	    (void **)&amp;sc-&gt;dc_ldata.dc_tx_list, BUS_DMA_NOWAIT |</a>
<a name="ln1863">	    BUS_DMA_ZERO | BUS_DMA_COHERENT, &amp;sc-&gt;dc_tx_lmap);</a>
<a name="ln1864">	if (error) {</a>
<a name="ln1865">		device_printf(sc-&gt;dc_dev,</a>
<a name="ln1866">		    &quot;failed to allocate DMA'able memory for TX list\n&quot;);</a>
<a name="ln1867">		goto fail;</a>
<a name="ln1868">	}</a>
<a name="ln1869">	error = bus_dmamap_load(sc-&gt;dc_tx_ltag, sc-&gt;dc_tx_lmap,</a>
<a name="ln1870">	    sc-&gt;dc_ldata.dc_tx_list, DC_TX_LIST_SZ, dc_dma_map_addr,</a>
<a name="ln1871">	    &amp;sc-&gt;dc_ldata.dc_tx_list_paddr, BUS_DMA_NOWAIT);</a>
<a name="ln1872">	if (error) {</a>
<a name="ln1873">		device_printf(sc-&gt;dc_dev,</a>
<a name="ln1874">		    &quot;cannot load DMA'able memory for TX list\n&quot;);</a>
<a name="ln1875">		goto fail;</a>
<a name="ln1876">	}</a>
<a name="ln1877"> </a>
<a name="ln1878">	/*</a>
<a name="ln1879">	 * Allocate a busdma tag and DMA safe memory for the multicast</a>
<a name="ln1880">	 * setup frame.</a>
<a name="ln1881">	 */</a>
<a name="ln1882">	error = bus_dma_tag_create(sc-&gt;dc_ptag, DC_LIST_ALIGN, 0,</a>
<a name="ln1883">	    BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR, NULL, NULL,</a>
<a name="ln1884">	    DC_SFRAME_LEN + DC_MIN_FRAMELEN, 1, DC_SFRAME_LEN + DC_MIN_FRAMELEN,</a>
<a name="ln1885">	    0, NULL, NULL, &amp;sc-&gt;dc_stag);</a>
<a name="ln1886">	if (error) {</a>
<a name="ln1887">		device_printf(sc-&gt;dc_dev,</a>
<a name="ln1888">		    &quot;failed to create DMA tag for setup frame\n&quot;);</a>
<a name="ln1889">		goto fail;</a>
<a name="ln1890">	}</a>
<a name="ln1891">	error = bus_dmamem_alloc(sc-&gt;dc_stag, (void **)&amp;sc-&gt;dc_cdata.dc_sbuf,</a>
<a name="ln1892">	    BUS_DMA_NOWAIT, &amp;sc-&gt;dc_smap);</a>
<a name="ln1893">	if (error) {</a>
<a name="ln1894">		device_printf(sc-&gt;dc_dev,</a>
<a name="ln1895">		    &quot;failed to allocate DMA'able memory for setup frame\n&quot;);</a>
<a name="ln1896">		goto fail;</a>
<a name="ln1897">	}</a>
<a name="ln1898">	error = bus_dmamap_load(sc-&gt;dc_stag, sc-&gt;dc_smap, sc-&gt;dc_cdata.dc_sbuf,</a>
<a name="ln1899">	    DC_SFRAME_LEN, dc_dma_map_addr, &amp;sc-&gt;dc_saddr, BUS_DMA_NOWAIT);</a>
<a name="ln1900">	if (error) {</a>
<a name="ln1901">		device_printf(sc-&gt;dc_dev,</a>
<a name="ln1902">		    &quot;cannot load DMA'able memory for setup frame\n&quot;);</a>
<a name="ln1903">		goto fail;</a>
<a name="ln1904">	}</a>
<a name="ln1905"> </a>
<a name="ln1906">	/* Allocate a busdma tag for RX mbufs. */</a>
<a name="ln1907">	error = bus_dma_tag_create(sc-&gt;dc_ptag, DC_RXBUF_ALIGN, 0,</a>
<a name="ln1908">	    BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR, NULL, NULL,</a>
<a name="ln1909">	    MCLBYTES, 1, MCLBYTES, 0, NULL, NULL, &amp;sc-&gt;dc_rx_mtag);</a>
<a name="ln1910">	if (error) {</a>
<a name="ln1911">		device_printf(sc-&gt;dc_dev, &quot;failed to create RX mbuf tag\n&quot;);</a>
<a name="ln1912">		goto fail;</a>
<a name="ln1913">	}</a>
<a name="ln1914"> </a>
<a name="ln1915">	/* Allocate a busdma tag for TX mbufs. */</a>
<a name="ln1916">	error = bus_dma_tag_create(sc-&gt;dc_ptag, 1, 0,</a>
<a name="ln1917">	    BUS_SPACE_MAXADDR, BUS_SPACE_MAXADDR, NULL, NULL,</a>
<a name="ln1918">	    MCLBYTES * DC_MAXFRAGS, DC_MAXFRAGS, MCLBYTES,</a>
<a name="ln1919">	    0, NULL, NULL, &amp;sc-&gt;dc_tx_mtag);</a>
<a name="ln1920">	if (error) {</a>
<a name="ln1921">		device_printf(sc-&gt;dc_dev, &quot;failed to create TX mbuf tag\n&quot;);</a>
<a name="ln1922">		goto fail;</a>
<a name="ln1923">	}</a>
<a name="ln1924"> </a>
<a name="ln1925">	/* Create the TX/RX busdma maps. */</a>
<a name="ln1926">	for (i = 0; i &lt; DC_TX_LIST_CNT; i++) {</a>
<a name="ln1927">		error = bus_dmamap_create(sc-&gt;dc_tx_mtag, 0,</a>
<a name="ln1928">		    &amp;sc-&gt;dc_cdata.dc_tx_map[i]);</a>
<a name="ln1929">		if (error) {</a>
<a name="ln1930">			device_printf(sc-&gt;dc_dev,</a>
<a name="ln1931">			    &quot;failed to create TX mbuf dmamap\n&quot;);</a>
<a name="ln1932">			goto fail;</a>
<a name="ln1933">		}</a>
<a name="ln1934">	}</a>
<a name="ln1935">	for (i = 0; i &lt; DC_RX_LIST_CNT; i++) {</a>
<a name="ln1936">		error = bus_dmamap_create(sc-&gt;dc_rx_mtag, 0,</a>
<a name="ln1937">		    &amp;sc-&gt;dc_cdata.dc_rx_map[i]);</a>
<a name="ln1938">		if (error) {</a>
<a name="ln1939">			device_printf(sc-&gt;dc_dev,</a>
<a name="ln1940">			    &quot;failed to create RX mbuf dmamap\n&quot;);</a>
<a name="ln1941">			goto fail;</a>
<a name="ln1942">		}</a>
<a name="ln1943">	}</a>
<a name="ln1944">	error = bus_dmamap_create(sc-&gt;dc_rx_mtag, 0, &amp;sc-&gt;dc_sparemap);</a>
<a name="ln1945">	if (error) {</a>
<a name="ln1946">		device_printf(sc-&gt;dc_dev,</a>
<a name="ln1947">		    &quot;failed to create spare RX mbuf dmamap\n&quot;);</a>
<a name="ln1948">		goto fail;</a>
<a name="ln1949">	}</a>
<a name="ln1950"> </a>
<a name="ln1951">fail:</a>
<a name="ln1952">	return (error);</a>
<a name="ln1953">}</a>
<a name="ln1954"> </a>
<a name="ln1955">static void</a>
<a name="ln1956">dc_dma_free(struct dc_softc *sc)</a>
<a name="ln1957">{</a>
<a name="ln1958">	int i;</a>
<a name="ln1959"> </a>
<a name="ln1960">	/* RX buffers. */</a>
<a name="ln1961">	if (sc-&gt;dc_rx_mtag != NULL) {</a>
<a name="ln1962">		for (i = 0; i &lt; DC_RX_LIST_CNT; i++) {</a>
<a name="ln1963">			if (sc-&gt;dc_cdata.dc_rx_map[i] != NULL)</a>
<a name="ln1964">				bus_dmamap_destroy(sc-&gt;dc_rx_mtag,</a>
<a name="ln1965">				    sc-&gt;dc_cdata.dc_rx_map[i]);</a>
<a name="ln1966">		}</a>
<a name="ln1967">		if (sc-&gt;dc_sparemap != NULL)</a>
<a name="ln1968">			bus_dmamap_destroy(sc-&gt;dc_rx_mtag, sc-&gt;dc_sparemap);</a>
<a name="ln1969">		bus_dma_tag_destroy(sc-&gt;dc_rx_mtag);</a>
<a name="ln1970">	}</a>
<a name="ln1971"> </a>
<a name="ln1972">	/* TX buffers. */</a>
<a name="ln1973">	if (sc-&gt;dc_rx_mtag != NULL) {</a>
<a name="ln1974">		for (i = 0; i &lt; DC_TX_LIST_CNT; i++) {</a>
<a name="ln1975">			if (sc-&gt;dc_cdata.dc_tx_map[i] != NULL)</a>
<a name="ln1976">				bus_dmamap_destroy(sc-&gt;dc_tx_mtag,</a>
<a name="ln1977">				    sc-&gt;dc_cdata.dc_tx_map[i]);</a>
<a name="ln1978">		}</a>
<a name="ln1979">		bus_dma_tag_destroy(sc-&gt;dc_tx_mtag);</a>
<a name="ln1980">	}</a>
<a name="ln1981"> </a>
<a name="ln1982">	/* RX descriptor list. */</a>
<a name="ln1983">	if (sc-&gt;dc_rx_ltag) {</a>
<a name="ln1984">		if (sc-&gt;dc_ldata.dc_rx_list_paddr != 0)</a>
<a name="ln1985">			bus_dmamap_unload(sc-&gt;dc_rx_ltag, sc-&gt;dc_rx_lmap);</a>
<a name="ln1986">		if (sc-&gt;dc_ldata.dc_rx_list != NULL)</a>
<a name="ln1987">			bus_dmamem_free(sc-&gt;dc_rx_ltag, sc-&gt;dc_ldata.dc_rx_list,</a>
<a name="ln1988">			    sc-&gt;dc_rx_lmap);</a>
<a name="ln1989">		bus_dma_tag_destroy(sc-&gt;dc_rx_ltag);</a>
<a name="ln1990">	}</a>
<a name="ln1991"> </a>
<a name="ln1992">	/* TX descriptor list. */</a>
<a name="ln1993">	if (sc-&gt;dc_tx_ltag) {</a>
<a name="ln1994">		if (sc-&gt;dc_ldata.dc_tx_list_paddr != 0)</a>
<a name="ln1995">			bus_dmamap_unload(sc-&gt;dc_tx_ltag, sc-&gt;dc_tx_lmap);</a>
<a name="ln1996">		if (sc-&gt;dc_ldata.dc_tx_list != NULL)</a>
<a name="ln1997">			bus_dmamem_free(sc-&gt;dc_tx_ltag, sc-&gt;dc_ldata.dc_tx_list,</a>
<a name="ln1998">			    sc-&gt;dc_tx_lmap);</a>
<a name="ln1999">		bus_dma_tag_destroy(sc-&gt;dc_tx_ltag);</a>
<a name="ln2000">	}</a>
<a name="ln2001"> </a>
<a name="ln2002">	/* multicast setup frame. */</a>
<a name="ln2003">	if (sc-&gt;dc_stag) {</a>
<a name="ln2004">		if (sc-&gt;dc_saddr != 0)</a>
<a name="ln2005">			bus_dmamap_unload(sc-&gt;dc_stag, sc-&gt;dc_smap);</a>
<a name="ln2006">		if (sc-&gt;dc_cdata.dc_sbuf != NULL)</a>
<a name="ln2007">			bus_dmamem_free(sc-&gt;dc_stag, sc-&gt;dc_cdata.dc_sbuf,</a>
<a name="ln2008">			    sc-&gt;dc_smap);</a>
<a name="ln2009">		bus_dma_tag_destroy(sc-&gt;dc_stag);</a>
<a name="ln2010">	}</a>
<a name="ln2011">}</a>
<a name="ln2012"> </a>
<a name="ln2013">/*</a>
<a name="ln2014"> * Attach the interface. Allocate softc structures, do ifmedia</a>
<a name="ln2015"> * setup and ethernet/BPF attach.</a>
<a name="ln2016"> */</a>
<a name="ln2017">static int</a>
<a name="ln2018">dc_attach(device_t dev)</a>
<a name="ln2019">{</a>
<a name="ln2020">	uint32_t eaddr[(ETHER_ADDR_LEN+3)/4];</a>
<a name="ln2021">	uint32_t command;</a>
<a name="ln2022">	struct dc_softc *sc;</a>
<a name="ln2023">	struct ifnet *ifp;</a>
<a name="ln2024">	struct dc_mediainfo *m;</a>
<a name="ln2025">	uint32_t reg, revision;</a>
<a name="ln2026">	uint16_t *srom;</a>
<a name="ln2027">	int error, mac_offset, n, phy, rid, tmp;</a>
<a name="ln2028">	uint8_t *mac;</a>
<a name="ln2029"> </a>
<a name="ln2030">	sc = device_get_softc(dev);</a>
<a name="ln2031">	sc-&gt;dc_dev = dev;</a>
<a name="ln2032"> </a>
<a name="ln2033">	mtx_init(&amp;sc-&gt;dc_mtx, device_get_nameunit(dev), MTX_NETWORK_LOCK,</a>
<a name="ln2034">	    MTX_DEF);</a>
<a name="ln2035"> </a>
<a name="ln2036">	/*</a>
<a name="ln2037">	 * Map control/status registers.</a>
<a name="ln2038">	 */</a>
<a name="ln2039">	pci_enable_busmaster(dev);</a>
<a name="ln2040"> </a>
<a name="ln2041">	rid = DC_RID;</a>
<a name="ln2042">	sc-&gt;dc_res = bus_alloc_resource_any(dev, DC_RES, &amp;rid, RF_ACTIVE);</a>
<a name="ln2043"> </a>
<a name="ln2044">	if (sc-&gt;dc_res == NULL) {</a>
<a name="ln2045">		device_printf(dev, &quot;couldn't map ports/memory\n&quot;);</a>
<a name="ln2046">		error = ENXIO;</a>
<a name="ln2047">		goto fail;</a>
<a name="ln2048">	}</a>
<a name="ln2049"> </a>
<a name="ln2050">	sc-&gt;dc_btag = rman_get_bustag(sc-&gt;dc_res);</a>
<a name="ln2051">	sc-&gt;dc_bhandle = rman_get_bushandle(sc-&gt;dc_res);</a>
<a name="ln2052"> </a>
<a name="ln2053">	/* Allocate interrupt. */</a>
<a name="ln2054">	rid = 0;</a>
<a name="ln2055">	sc-&gt;dc_irq = bus_alloc_resource_any(dev, SYS_RES_IRQ, &amp;rid,</a>
<a name="ln2056">	    RF_SHAREABLE | RF_ACTIVE);</a>
<a name="ln2057"> </a>
<a name="ln2058">	if (sc-&gt;dc_irq == NULL) {</a>
<a name="ln2059">		device_printf(dev, &quot;couldn't map interrupt\n&quot;);</a>
<a name="ln2060">		error = ENXIO;</a>
<a name="ln2061">		goto fail;</a>
<a name="ln2062">	}</a>
<a name="ln2063"> </a>
<a name="ln2064">	/* Need this info to decide on a chip type. */</a>
<a name="ln2065">	sc-&gt;dc_info = dc_devtype(dev);</a>
<a name="ln2066">	revision = pci_get_revid(dev);</a>
<a name="ln2067"> </a>
<a name="ln2068">	error = 0;</a>
<a name="ln2069">	/* Get the eeprom width, but PNIC and XIRCOM have diff eeprom */</a>
<a name="ln2070">	if (sc-&gt;dc_info-&gt;dc_devid !=</a>
<a name="ln2071">	    DC_DEVID(DC_VENDORID_LO, DC_DEVICEID_82C168) &amp;&amp;</a>
<a name="ln2072">	    sc-&gt;dc_info-&gt;dc_devid !=</a>
<a name="ln2073">	    DC_DEVID(DC_VENDORID_XIRCOM, DC_DEVICEID_X3201))</a>
<a name="ln2074">		dc_eeprom_width(sc);</a>
<a name="ln2075"> </a>
<a name="ln2076">	switch (sc-&gt;dc_info-&gt;dc_devid) {</a>
<a name="ln2077">	case DC_DEVID(DC_VENDORID_DEC, DC_DEVICEID_21143):</a>
<a name="ln2078">		sc-&gt;dc_type = DC_TYPE_21143;</a>
<a name="ln2079">		sc-&gt;dc_flags |= DC_TX_POLL | DC_TX_USE_TX_INTR;</a>
<a name="ln2080">		sc-&gt;dc_flags |= DC_REDUCED_MII_POLL;</a>
<a name="ln2081">		/* Save EEPROM contents so we can parse them later. */</a>
<a name="ln2082">		error = dc_read_srom(sc, sc-&gt;dc_romwidth);</a>
<a name="ln2083">		if (error != 0)</a>
<a name="ln2084">			goto fail;</a>
<a name="ln2085">		break;</a>
<a name="ln2086">	case DC_DEVID(DC_VENDORID_DAVICOM, DC_DEVICEID_DM9009):</a>
<a name="ln2087">	case DC_DEVID(DC_VENDORID_DAVICOM, DC_DEVICEID_DM9100):</a>
<a name="ln2088">	case DC_DEVID(DC_VENDORID_DAVICOM, DC_DEVICEID_DM9102):</a>
<a name="ln2089">		sc-&gt;dc_type = DC_TYPE_DM9102;</a>
<a name="ln2090">		sc-&gt;dc_flags |= DC_TX_COALESCE | DC_TX_INTR_ALWAYS;</a>
<a name="ln2091">		sc-&gt;dc_flags |= DC_REDUCED_MII_POLL | DC_TX_STORENFWD;</a>
<a name="ln2092">		sc-&gt;dc_flags |= DC_TX_ALIGN;</a>
<a name="ln2093">		sc-&gt;dc_pmode = DC_PMODE_MII;</a>
<a name="ln2094"> </a>
<a name="ln2095">		/* Increase the latency timer value. */</a>
<a name="ln2096">		pci_write_config(dev, PCIR_LATTIMER, 0x80, 1);</a>
<a name="ln2097">		break;</a>
<a name="ln2098">	case DC_DEVID(DC_VENDORID_ADMTEK, DC_DEVICEID_AL981):</a>
<a name="ln2099">		sc-&gt;dc_type = DC_TYPE_AL981;</a>
<a name="ln2100">		sc-&gt;dc_flags |= DC_TX_USE_TX_INTR;</a>
<a name="ln2101">		sc-&gt;dc_flags |= DC_TX_ADMTEK_WAR;</a>
<a name="ln2102">		sc-&gt;dc_pmode = DC_PMODE_MII;</a>
<a name="ln2103">		error = dc_read_srom(sc, sc-&gt;dc_romwidth);</a>
<a name="ln2104">		if (error != 0)</a>
<a name="ln2105">			goto fail;</a>
<a name="ln2106">		break;</a>
<a name="ln2107">	case DC_DEVID(DC_VENDORID_ADMTEK, DC_DEVICEID_AN983):</a>
<a name="ln2108">	case DC_DEVID(DC_VENDORID_ADMTEK, DC_DEVICEID_AN985):</a>
<a name="ln2109">	case DC_DEVID(DC_VENDORID_ADMTEK, DC_DEVICEID_ADM9511):</a>
<a name="ln2110">	case DC_DEVID(DC_VENDORID_ADMTEK, DC_DEVICEID_ADM9513):</a>
<a name="ln2111">	case DC_DEVID(DC_VENDORID_DLINK, DC_DEVICEID_DRP32TXD):</a>
<a name="ln2112">	case DC_DEVID(DC_VENDORID_ABOCOM, DC_DEVICEID_FE2500):</a>
<a name="ln2113">	case DC_DEVID(DC_VENDORID_ABOCOM, DC_DEVICEID_FE2500MX):</a>
<a name="ln2114">	case DC_DEVID(DC_VENDORID_ACCTON, DC_DEVICEID_EN2242):</a>
<a name="ln2115">	case DC_DEVID(DC_VENDORID_HAWKING, DC_DEVICEID_HAWKING_PN672TX):</a>
<a name="ln2116">	case DC_DEVID(DC_VENDORID_PLANEX, DC_DEVICEID_FNW3602T):</a>
<a name="ln2117">	case DC_DEVID(DC_VENDORID_3COM, DC_DEVICEID_3CSOHOB):</a>
<a name="ln2118">	case DC_DEVID(DC_VENDORID_MICROSOFT, DC_DEVICEID_MSMN120):</a>
<a name="ln2119">	case DC_DEVID(DC_VENDORID_MICROSOFT, DC_DEVICEID_MSMN130):</a>
<a name="ln2120">	case DC_DEVID(DC_VENDORID_LINKSYS, DC_DEVICEID_PCMPC200_AB08):</a>
<a name="ln2121">	case DC_DEVID(DC_VENDORID_LINKSYS, DC_DEVICEID_PCMPC200_AB09):</a>
<a name="ln2122">		sc-&gt;dc_type = DC_TYPE_AN983;</a>
<a name="ln2123">		sc-&gt;dc_flags |= DC_64BIT_HASH;</a>
<a name="ln2124">		sc-&gt;dc_flags |= DC_TX_USE_TX_INTR;</a>
<a name="ln2125">		sc-&gt;dc_flags |= DC_TX_ADMTEK_WAR;</a>
<a name="ln2126">		sc-&gt;dc_pmode = DC_PMODE_MII;</a>
<a name="ln2127">		/* Don't read SROM for - auto-loaded on reset */</a>
<a name="ln2128">		break;</a>
<a name="ln2129">	case DC_DEVID(DC_VENDORID_MX, DC_DEVICEID_98713):</a>
<a name="ln2130">	case DC_DEVID(DC_VENDORID_CP, DC_DEVICEID_98713_CP):</a>
<a name="ln2131">		if (revision &lt; DC_REVISION_98713A) {</a>
<a name="ln2132">			sc-&gt;dc_type = DC_TYPE_98713;</a>
<a name="ln2133">		}</a>
<a name="ln2134">		if (revision &gt;= DC_REVISION_98713A) {</a>
<a name="ln2135">			sc-&gt;dc_type = DC_TYPE_98713A;</a>
<a name="ln2136">			sc-&gt;dc_flags |= DC_21143_NWAY;</a>
<a name="ln2137">		}</a>
<a name="ln2138">		sc-&gt;dc_flags |= DC_REDUCED_MII_POLL;</a>
<a name="ln2139">		sc-&gt;dc_flags |= DC_TX_POLL | DC_TX_USE_TX_INTR;</a>
<a name="ln2140">		break;</a>
<a name="ln2141">	case DC_DEVID(DC_VENDORID_MX, DC_DEVICEID_987x5):</a>
<a name="ln2142">	case DC_DEVID(DC_VENDORID_ACCTON, DC_DEVICEID_EN1217):</a>
<a name="ln2143">		/*</a>
<a name="ln2144">		 * Macronix MX98715AEC-C/D/E parts have only a</a>
<a name="ln2145">		 * 128-bit hash table. We need to deal with these</a>
<a name="ln2146">		 * in the same manner as the PNIC II so that we</a>
<a name="ln2147">		 * get the right number of bits out of the</a>
<a name="ln2148">		 * CRC routine.</a>
<a name="ln2149">		 */</a>
<a name="ln2150">		if (revision &gt;= DC_REVISION_98715AEC_C &amp;&amp;</a>
<a name="ln2151">		    revision &lt; DC_REVISION_98725)</a>
<a name="ln2152">			sc-&gt;dc_flags |= DC_128BIT_HASH;</a>
<a name="ln2153">		sc-&gt;dc_type = DC_TYPE_987x5;</a>
<a name="ln2154">		sc-&gt;dc_flags |= DC_TX_POLL | DC_TX_USE_TX_INTR;</a>
<a name="ln2155">		sc-&gt;dc_flags |= DC_REDUCED_MII_POLL | DC_21143_NWAY;</a>
<a name="ln2156">		break;</a>
<a name="ln2157">	case DC_DEVID(DC_VENDORID_MX, DC_DEVICEID_98727):</a>
<a name="ln2158">		sc-&gt;dc_type = DC_TYPE_987x5;</a>
<a name="ln2159">		sc-&gt;dc_flags |= DC_TX_POLL | DC_TX_USE_TX_INTR;</a>
<a name="ln2160">		sc-&gt;dc_flags |= DC_REDUCED_MII_POLL | DC_21143_NWAY;</a>
<a name="ln2161">		break;</a>
<a name="ln2162">	case DC_DEVID(DC_VENDORID_LO, DC_DEVICEID_82C115):</a>
<a name="ln2163">		sc-&gt;dc_type = DC_TYPE_PNICII;</a>
<a name="ln2164">		sc-&gt;dc_flags |= DC_TX_POLL | DC_TX_USE_TX_INTR | DC_128BIT_HASH;</a>
<a name="ln2165">		sc-&gt;dc_flags |= DC_REDUCED_MII_POLL | DC_21143_NWAY;</a>
<a name="ln2166">		break;</a>
<a name="ln2167">	case DC_DEVID(DC_VENDORID_LO, DC_DEVICEID_82C168):</a>
<a name="ln2168">		sc-&gt;dc_type = DC_TYPE_PNIC;</a>
<a name="ln2169">		sc-&gt;dc_flags |= DC_TX_STORENFWD | DC_TX_INTR_ALWAYS;</a>
<a name="ln2170">		sc-&gt;dc_flags |= DC_PNIC_RX_BUG_WAR;</a>
<a name="ln2171">		sc-&gt;dc_pnic_rx_buf = malloc(DC_RXLEN * 5, M_DEVBUF, M_NOWAIT);</a>
<a name="ln2172">		if (sc-&gt;dc_pnic_rx_buf == NULL) {</a>
<a name="ln2173">			device_printf(sc-&gt;dc_dev,</a>
<a name="ln2174">			    &quot;Could not allocate PNIC RX buffer\n&quot;);</a>
<a name="ln2175">			error = ENOMEM;</a>
<a name="ln2176">			goto fail;</a>
<a name="ln2177">		}</a>
<a name="ln2178">		if (revision &lt; DC_REVISION_82C169)</a>
<a name="ln2179">			sc-&gt;dc_pmode = DC_PMODE_SYM;</a>
<a name="ln2180">		break;</a>
<a name="ln2181">	case DC_DEVID(DC_VENDORID_ASIX, DC_DEVICEID_AX88140A):</a>
<a name="ln2182">		sc-&gt;dc_type = DC_TYPE_ASIX;</a>
<a name="ln2183">		sc-&gt;dc_flags |= DC_TX_USE_TX_INTR | DC_TX_INTR_FIRSTFRAG;</a>
<a name="ln2184">		sc-&gt;dc_flags |= DC_REDUCED_MII_POLL;</a>
<a name="ln2185">		sc-&gt;dc_pmode = DC_PMODE_MII;</a>
<a name="ln2186">		break;</a>
<a name="ln2187">	case DC_DEVID(DC_VENDORID_XIRCOM, DC_DEVICEID_X3201):</a>
<a name="ln2188">		sc-&gt;dc_type = DC_TYPE_XIRCOM;</a>
<a name="ln2189">		sc-&gt;dc_flags |= DC_TX_INTR_ALWAYS | DC_TX_COALESCE |</a>
<a name="ln2190">				DC_TX_ALIGN;</a>
<a name="ln2191">		/*</a>
<a name="ln2192">		 * We don't actually need to coalesce, but we're doing</a>
<a name="ln2193">		 * it to obtain a double word aligned buffer.</a>
<a name="ln2194">		 * The DC_TX_COALESCE flag is required.</a>
<a name="ln2195">		 */</a>
<a name="ln2196">		sc-&gt;dc_pmode = DC_PMODE_MII;</a>
<a name="ln2197">		break;</a>
<a name="ln2198">	case DC_DEVID(DC_VENDORID_CONEXANT, DC_DEVICEID_RS7112):</a>
<a name="ln2199">		sc-&gt;dc_type = DC_TYPE_CONEXANT;</a>
<a name="ln2200">		sc-&gt;dc_flags |= DC_TX_INTR_ALWAYS;</a>
<a name="ln2201">		sc-&gt;dc_flags |= DC_REDUCED_MII_POLL;</a>
<a name="ln2202">		sc-&gt;dc_pmode = DC_PMODE_MII;</a>
<a name="ln2203">		error = dc_read_srom(sc, sc-&gt;dc_romwidth);</a>
<a name="ln2204">		if (error != 0)</a>
<a name="ln2205">			goto fail;</a>
<a name="ln2206">		break;</a>
<a name="ln2207">	case DC_DEVID(DC_VENDORID_ULI, DC_DEVICEID_M5261):</a>
<a name="ln2208">	case DC_DEVID(DC_VENDORID_ULI, DC_DEVICEID_M5263):</a>
<a name="ln2209">		if (sc-&gt;dc_info-&gt;dc_devid ==</a>
<a name="ln2210">		    DC_DEVID(DC_VENDORID_ULI, DC_DEVICEID_M5261))</a>
<a name="ln2211">			sc-&gt;dc_type = DC_TYPE_ULI_M5261;</a>
<a name="ln2212">		else</a>
<a name="ln2213">			sc-&gt;dc_type = DC_TYPE_ULI_M5263;</a>
<a name="ln2214">		/* TX buffers should be aligned on 4 byte boundary. */</a>
<a name="ln2215">		sc-&gt;dc_flags |= DC_TX_INTR_ALWAYS | DC_TX_COALESCE |</a>
<a name="ln2216">		    DC_TX_ALIGN;</a>
<a name="ln2217">		sc-&gt;dc_pmode = DC_PMODE_MII;</a>
<a name="ln2218">		error = dc_read_srom(sc, sc-&gt;dc_romwidth);</a>
<a name="ln2219">		if (error != 0)</a>
<a name="ln2220">			goto fail;</a>
<a name="ln2221">		break;</a>
<a name="ln2222">	default:</a>
<a name="ln2223">		device_printf(dev, &quot;unknown device: %x\n&quot;,</a>
<a name="ln2224">		    sc-&gt;dc_info-&gt;dc_devid);</a>
<a name="ln2225">		break;</a>
<a name="ln2226">	}</a>
<a name="ln2227"> </a>
<a name="ln2228">	/* Save the cache line size. */</a>
<a name="ln2229">	if (DC_IS_DAVICOM(sc))</a>
<a name="ln2230">		sc-&gt;dc_cachesize = 0;</a>
<a name="ln2231">	else</a>
<a name="ln2232">		sc-&gt;dc_cachesize = pci_get_cachelnsz(dev);</a>
<a name="ln2233"> </a>
<a name="ln2234">	/* Reset the adapter. */</a>
<a name="ln2235">	dc_reset(sc);</a>
<a name="ln2236"> </a>
<a name="ln2237">	/* Take 21143 out of snooze mode */</a>
<a name="ln2238">	if (DC_IS_INTEL(sc) || DC_IS_XIRCOM(sc)) {</a>
<a name="ln2239">		command = pci_read_config(dev, DC_PCI_CFDD, 4);</a>
<a name="ln2240">		command &amp;= ~(DC_CFDD_SNOOZE_MODE | DC_CFDD_SLEEP_MODE);</a>
<a name="ln2241">		pci_write_config(dev, DC_PCI_CFDD, command, 4);</a>
<a name="ln2242">	}</a>
<a name="ln2243"> </a>
<a name="ln2244">	/*</a>
<a name="ln2245">	 * Try to learn something about the supported media.</a>
<a name="ln2246">	 * We know that ASIX and ADMtek and Davicom devices</a>
<a name="ln2247">	 * will *always* be using MII media, so that's a no-brainer.</a>
<a name="ln2248">	 * The tricky ones are the Macronix/PNIC II and the</a>
<a name="ln2249">	 * Intel 21143.</a>
<a name="ln2250">	 */</a>
<a name="ln2251">	if (DC_IS_INTEL(sc)) {</a>
<a name="ln2252">		error = dc_parse_21143_srom(sc);</a>
<a name="ln2253">		if (error != 0)</a>
<a name="ln2254">			goto fail;</a>
<a name="ln2255">	} else if (DC_IS_MACRONIX(sc) || DC_IS_PNICII(sc)) {</a>
<a name="ln2256">		if (sc-&gt;dc_type == DC_TYPE_98713)</a>
<a name="ln2257">			sc-&gt;dc_pmode = DC_PMODE_MII;</a>
<a name="ln2258">		else</a>
<a name="ln2259">			sc-&gt;dc_pmode = DC_PMODE_SYM;</a>
<a name="ln2260">	} else if (!sc-&gt;dc_pmode)</a>
<a name="ln2261">		sc-&gt;dc_pmode = DC_PMODE_MII;</a>
<a name="ln2262"> </a>
<a name="ln2263">	/*</a>
<a name="ln2264">	 * Get station address from the EEPROM.</a>
<a name="ln2265">	 */</a>
<a name="ln2266">	switch(sc-&gt;dc_type) {</a>
<a name="ln2267">	case DC_TYPE_98713:</a>
<a name="ln2268">	case DC_TYPE_98713A:</a>
<a name="ln2269">	case DC_TYPE_987x5:</a>
<a name="ln2270">	case DC_TYPE_PNICII:</a>
<a name="ln2271">		dc_read_eeprom(sc, (caddr_t)&amp;mac_offset,</a>
<a name="ln2272">		    (DC_EE_NODEADDR_OFFSET / 2), 1, 0);</a>
<a name="ln2273">		dc_read_eeprom(sc, (caddr_t)&amp;eaddr, (mac_offset / 2), 3, 0);</a>
<a name="ln2274">		break;</a>
<a name="ln2275">	case DC_TYPE_PNIC:</a>
<a name="ln2276">		dc_read_eeprom(sc, (caddr_t)&amp;eaddr, 0, 3, 1);</a>
<a name="ln2277">		break;</a>
<a name="ln2278">	case DC_TYPE_DM9102:</a>
<a name="ln2279">		dc_read_eeprom(sc, (caddr_t)&amp;eaddr, DC_EE_NODEADDR, 3, 0);</a>
<a name="ln2280">#ifdef __sparc64__</a>
<a name="ln2281">		/*</a>
<a name="ln2282">		 * If this is an onboard dc(4) the station address read from</a>
<a name="ln2283">		 * the EEPROM is all zero and we have to get it from the FCode.</a>
<a name="ln2284">		 */</a>
<a name="ln2285">		if (eaddr[0] == 0 &amp;&amp; (eaddr[1] &amp; ~0xffff) == 0)</a>
<a name="ln2286">			OF_getetheraddr(dev, (caddr_t)&amp;eaddr);</a>
<a name="ln2287">#endif</a>
<a name="ln2288">		break;</a>
<a name="ln2289">	case DC_TYPE_21143:</a>
<a name="ln2290">	case DC_TYPE_ASIX:</a>
<a name="ln2291">		dc_read_eeprom(sc, (caddr_t)&amp;eaddr, DC_EE_NODEADDR, 3, 0);</a>
<a name="ln2292">		break;</a>
<a name="ln2293">	case DC_TYPE_AL981:</a>
<a name="ln2294">	case DC_TYPE_AN983:</a>
<a name="ln2295">		reg = CSR_READ_4(sc, DC_AL_PAR0);</a>
<a name="ln2296">		mac = (uint8_t *)&amp;eaddr[0];</a>
<a name="ln2297">		mac[0] = (reg &gt;&gt; 0) &amp; 0xff;</a>
<a name="ln2298">		mac[1] = (reg &gt;&gt; 8) &amp; 0xff;</a>
<a name="ln2299">		mac[2] = (reg &gt;&gt; 16) &amp; 0xff;</a>
<a name="ln2300">		mac[3] = (reg &gt;&gt; 24) &amp; 0xff;</a>
<a name="ln2301">		reg = CSR_READ_4(sc, DC_AL_PAR1);</a>
<a name="ln2302">		mac[4] = (reg &gt;&gt; 0) &amp; 0xff;</a>
<a name="ln2303">		mac[5] = (reg &gt;&gt; 8) &amp; 0xff;</a>
<a name="ln2304">		break;</a>
<a name="ln2305">	case DC_TYPE_CONEXANT:</a>
<a name="ln2306">		bcopy(sc-&gt;dc_srom + DC_CONEXANT_EE_NODEADDR, &amp;eaddr,</a>
<a name="ln2307">		    ETHER_ADDR_LEN);</a>
<a name="ln2308">		break;</a>
<a name="ln2309">	case DC_TYPE_XIRCOM:</a>
<a name="ln2310">		/* The MAC comes from the CIS. */</a>
<a name="ln2311">		mac = pci_get_ether(dev);</a>
<a name="ln2312">		if (!mac) {</a>
<a name="ln2313">			device_printf(dev, &quot;No station address in CIS!\n&quot;);</a>
<a name="ln2314">			error = ENXIO;</a>
<a name="ln2315">			goto fail;</a>
<a name="ln2316">		}</a>
<a name="ln2317">		bcopy(mac, eaddr, ETHER_ADDR_LEN);</a>
<a name="ln2318">		break;</a>
<a name="ln2319">	case DC_TYPE_ULI_M5261:</a>
<a name="ln2320">	case DC_TYPE_ULI_M5263:</a>
<a name="ln2321">		srom = (uint16_t *)sc-&gt;dc_srom;</a>
<a name="ln2322">		if (srom == NULL || *srom == 0xFFFF || *srom == 0) {</a>
<a name="ln2323">			/*</a>
<a name="ln2324">			 * No valid SROM present, read station address</a>
<a name="ln2325">			 * from ID Table.</a>
<a name="ln2326">			 */</a>
<a name="ln2327">			device_printf(dev,</a>
<a name="ln2328">			    &quot;Reading station address from ID Table.\n&quot;);</a>
<a name="ln2329">			CSR_WRITE_4(sc, DC_BUSCTL, 0x10000);</a>
<a name="ln2330">			CSR_WRITE_4(sc, DC_SIARESET, 0x01C0);</a>
<a name="ln2331">			CSR_WRITE_4(sc, DC_10BTCTRL, 0x0000);</a>
<a name="ln2332">			CSR_WRITE_4(sc, DC_10BTCTRL, 0x0010);</a>
<a name="ln2333">			CSR_WRITE_4(sc, DC_10BTCTRL, 0x0000);</a>
<a name="ln2334">			CSR_WRITE_4(sc, DC_SIARESET, 0x0000);</a>
<a name="ln2335">			CSR_WRITE_4(sc, DC_SIARESET, 0x01B0);</a>
<a name="ln2336">			mac = (uint8_t *)eaddr;</a>
<a name="ln2337">			for (n = 0; n &lt; ETHER_ADDR_LEN; n++)</a>
<a name="ln2338">				mac[n] = (uint8_t)CSR_READ_4(sc, DC_10BTCTRL);</a>
<a name="ln2339">			CSR_WRITE_4(sc, DC_SIARESET, 0x0000);</a>
<a name="ln2340">			CSR_WRITE_4(sc, DC_BUSCTL, 0x0000);</a>
<a name="ln2341">			DELAY(10);</a>
<a name="ln2342">		} else</a>
<a name="ln2343">			dc_read_eeprom(sc, (caddr_t)&amp;eaddr, DC_EE_NODEADDR, 3,</a>
<a name="ln2344">			    0);</a>
<a name="ln2345">		break;</a>
<a name="ln2346">	default:</a>
<a name="ln2347">		dc_read_eeprom(sc, (caddr_t)&amp;eaddr, DC_EE_NODEADDR, 3, 0);</a>
<a name="ln2348">		break;</a>
<a name="ln2349">	}</a>
<a name="ln2350"> </a>
<a name="ln2351">	bcopy(eaddr, sc-&gt;dc_eaddr, sizeof(eaddr));</a>
<a name="ln2352">	/*</a>
<a name="ln2353">	 * If we still have invalid station address, see whether we can</a>
<a name="ln2354">	 * find station address for chip 0.  Some multi-port controllers</a>
<a name="ln2355">	 * just store station address for chip 0 if they have a shared</a>
<a name="ln2356">	 * SROM.</a>
<a name="ln2357">	 */</a>
<a name="ln2358">	if ((sc-&gt;dc_eaddr[0] == 0 &amp;&amp; (sc-&gt;dc_eaddr[1] &amp; ~0xffff) == 0) ||</a>
<a name="ln2359">	    (sc-&gt;dc_eaddr[0] == 0xffffffff &amp;&amp;</a>
<a name="ln2360">	    (sc-&gt;dc_eaddr[1] &amp; 0xffff) == 0xffff)) {</a>
<a name="ln2361">		error = dc_check_multiport(sc);</a>
<a name="ln2362">		if (error == 0) {</a>
<a name="ln2363">			bcopy(sc-&gt;dc_eaddr, eaddr, sizeof(eaddr));</a>
<a name="ln2364">			/* Extract media information. */</a>
<a name="ln2365">			if (DC_IS_INTEL(sc) &amp;&amp; sc-&gt;dc_srom != NULL) {</a>
<a name="ln2366">				while (sc-&gt;dc_mi != NULL) {</a>
<a name="ln2367">					m = sc-&gt;dc_mi-&gt;dc_next;</a>
<a name="ln2368">					free(sc-&gt;dc_mi, M_DEVBUF);</a>
<a name="ln2369">					sc-&gt;dc_mi = m;</a>
<a name="ln2370">				}</a>
<a name="ln2371">				error = dc_parse_21143_srom(sc);</a>
<a name="ln2372">				if (error != 0)</a>
<a name="ln2373">					goto fail;</a>
<a name="ln2374">			}</a>
<a name="ln2375">		} else if (error == ENOMEM)</a>
<a name="ln2376">			goto fail;</a>
<a name="ln2377">		else</a>
<a name="ln2378">			error = 0;</a>
<a name="ln2379">	}</a>
<a name="ln2380"> </a>
<a name="ln2381">	if ((error = dc_dma_alloc(sc)) != 0)</a>
<a name="ln2382">		goto fail;</a>
<a name="ln2383"> </a>
<a name="ln2384">	ifp = sc-&gt;dc_ifp = if_alloc(IFT_ETHER);</a>
<a name="ln2385">	if (ifp == NULL) {</a>
<a name="ln2386">		device_printf(dev, &quot;can not if_alloc()\n&quot;);</a>
<a name="ln2387">		error = ENOSPC;</a>
<a name="ln2388">		goto fail;</a>
<a name="ln2389">	}</a>
<a name="ln2390">	ifp-&gt;if_softc = sc;</a>
<a name="ln2391">	if_initname(ifp, device_get_name(dev), device_get_unit(dev));</a>
<a name="ln2392">	ifp-&gt;if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;</a>
<a name="ln2393">	ifp-&gt;if_ioctl = dc_ioctl;</a>
<a name="ln2394">	ifp-&gt;if_start = dc_start;</a>
<a name="ln2395">	ifp-&gt;if_init = dc_init;</a>
<a name="ln2396">	IFQ_SET_MAXLEN(&amp;ifp-&gt;if_snd, DC_TX_LIST_CNT - 1);</a>
<a name="ln2397">	ifp-&gt;if_snd.ifq_drv_maxlen = DC_TX_LIST_CNT - 1;</a>
<a name="ln2398">	IFQ_SET_READY(&amp;ifp-&gt;if_snd);</a>
<a name="ln2399"> </a>
<a name="ln2400">	/*</a>
<a name="ln2401">	 * Do MII setup. If this is a 21143, check for a PHY on the</a>
<a name="ln2402">	 * MII bus after applying any necessary fixups to twiddle the</a>
<a name="ln2403">	 * GPIO bits. If we don't end up finding a PHY, restore the</a>
<a name="ln2404">	 * old selection (SIA only or SIA/SYM) and attach the dcphy</a>
<a name="ln2405">	 * driver instead.</a>
<a name="ln2406">	 */</a>
<a name="ln2407">	tmp = 0;</a>
<a name="ln2408">	if (DC_IS_INTEL(sc)) {</a>
<a name="ln2409">		dc_apply_fixup(sc, IFM_AUTO);</a>
<a name="ln2410">		tmp = sc-&gt;dc_pmode;</a>
<a name="ln2411">		sc-&gt;dc_pmode = DC_PMODE_MII;</a>
<a name="ln2412">	}</a>
<a name="ln2413"> </a>
<a name="ln2414">	/*</a>
<a name="ln2415">	 * Setup General Purpose port mode and data so the tulip can talk</a>
<a name="ln2416">	 * to the MII.  This needs to be done before mii_attach so that</a>
<a name="ln2417">	 * we can actually see them.</a>
<a name="ln2418">	 */</a>
<a name="ln2419">	if (DC_IS_XIRCOM(sc)) {</a>
<a name="ln2420">		CSR_WRITE_4(sc, DC_SIAGP, DC_SIAGP_WRITE_EN | DC_SIAGP_INT1_EN |</a>
<a name="ln2421">		    DC_SIAGP_MD_GP2_OUTPUT | DC_SIAGP_MD_GP0_OUTPUT);</a>
<a name="ln2422">		DELAY(10);</a>
<a name="ln2423">		CSR_WRITE_4(sc, DC_SIAGP, DC_SIAGP_INT1_EN |</a>
<a name="ln2424">		    DC_SIAGP_MD_GP2_OUTPUT | DC_SIAGP_MD_GP0_OUTPUT);</a>
<a name="ln2425">		DELAY(10);</a>
<a name="ln2426">	}</a>
<a name="ln2427"> </a>
<a name="ln2428">	phy = MII_PHY_ANY;</a>
<a name="ln2429">	/*</a>
<a name="ln2430">	 * Note: both the AL981 and AN983 have internal PHYs, however the</a>
<a name="ln2431">	 * AL981 provides direct access to the PHY registers while the AN983</a>
<a name="ln2432">	 * uses a serial MII interface. The AN983's MII interface is also</a>
<a name="ln2433">	 * buggy in that you can read from any MII address (0 to 31), but</a>
<a name="ln2434">	 * only address 1 behaves normally. To deal with both cases, we</a>
<a name="ln2435">	 * pretend that the PHY is at MII address 1.</a>
<a name="ln2436">	 */</a>
<a name="ln2437">	if (DC_IS_ADMTEK(sc))</a>
<a name="ln2438">		phy = DC_ADMTEK_PHYADDR;</a>
<a name="ln2439"> </a>
<a name="ln2440">	/*</a>
<a name="ln2441">	 * Note: the ukphy probes of the RS7112 report a PHY at MII address</a>
<a name="ln2442">	 * 0 (possibly HomePNA?) and 1 (ethernet) so we only respond to the</a>
<a name="ln2443">	 * correct one.</a>
<a name="ln2444">	 */</a>
<a name="ln2445">	if (DC_IS_CONEXANT(sc))</a>
<a name="ln2446">		phy = DC_CONEXANT_PHYADDR;</a>
<a name="ln2447"> </a>
<a name="ln2448">	error = mii_attach(dev, &amp;sc-&gt;dc_miibus, ifp, dc_ifmedia_upd,</a>
<a name="ln2449">	    dc_ifmedia_sts, BMSR_DEFCAPMASK, phy, MII_OFFSET_ANY, 0);</a>
<a name="ln2450"> </a>
<a name="ln2451">	if (error &amp;&amp; DC_IS_INTEL(sc)) {</a>
<a name="ln2452">		sc-&gt;dc_pmode = tmp;</a>
<a name="ln2453">		if (sc-&gt;dc_pmode != DC_PMODE_SIA)</a>
<a name="ln2454">			sc-&gt;dc_pmode = DC_PMODE_SYM;</a>
<a name="ln2455">		sc-&gt;dc_flags |= DC_21143_NWAY;</a>
<a name="ln2456">		/*</a>
<a name="ln2457">		 * For non-MII cards, we need to have the 21143</a>
<a name="ln2458">		 * drive the LEDs. Except there are some systems</a>
<a name="ln2459">		 * like the NEC VersaPro NoteBook PC which have no</a>
<a name="ln2460">		 * LEDs, and twiddling these bits has adverse effects</a>
<a name="ln2461">		 * on them. (I.e. you suddenly can't get a link.)</a>
<a name="ln2462">		 */</a>
<a name="ln2463">		if (!(pci_get_subvendor(dev) == 0x1033 &amp;&amp;</a>
<a name="ln2464">		    pci_get_subdevice(dev) == 0x8028))</a>
<a name="ln2465">			sc-&gt;dc_flags |= DC_TULIP_LEDS;</a>
<a name="ln2466">		error = mii_attach(dev, &amp;sc-&gt;dc_miibus, ifp, dc_ifmedia_upd,</a>
<a name="ln2467">		    dc_ifmedia_sts, BMSR_DEFCAPMASK, MII_PHY_ANY,</a>
<a name="ln2468">		    MII_OFFSET_ANY, 0);</a>
<a name="ln2469">	}</a>
<a name="ln2470"> </a>
<a name="ln2471">	if (error) {</a>
<a name="ln2472">		device_printf(dev, &quot;attaching PHYs failed\n&quot;);</a>
<a name="ln2473">		goto fail;</a>
<a name="ln2474">	}</a>
<a name="ln2475"> </a>
<a name="ln2476">	if (DC_IS_ADMTEK(sc)) {</a>
<a name="ln2477">		/*</a>
<a name="ln2478">		 * Set automatic TX underrun recovery for the ADMtek chips</a>
<a name="ln2479">		 */</a>
<a name="ln2480">		DC_SETBIT(sc, DC_AL_CR, DC_AL_CR_ATUR);</a>
<a name="ln2481">	}</a>
<a name="ln2482"> </a>
<a name="ln2483">	/*</a>
<a name="ln2484">	 * Tell the upper layer(s) we support long frames.</a>
<a name="ln2485">	 */</a>
<a name="ln2486">	ifp-&gt;if_hdrlen = sizeof(struct ether_vlan_header);</a>
<a name="ln2487">	ifp-&gt;if_capabilities |= IFCAP_VLAN_MTU;</a>
<a name="ln2488">	ifp-&gt;if_capenable = ifp-&gt;if_capabilities;</a>
<a name="ln2489">#ifdef DEVICE_POLLING</a>
<a name="ln2490">	ifp-&gt;if_capabilities |= IFCAP_POLLING;</a>
<a name="ln2491">#endif</a>
<a name="ln2492"> </a>
<a name="ln2493">	callout_init_mtx(&amp;sc-&gt;dc_stat_ch, &amp;sc-&gt;dc_mtx, 0);</a>
<a name="ln2494">	callout_init_mtx(&amp;sc-&gt;dc_wdog_ch, &amp;sc-&gt;dc_mtx, 0);</a>
<a name="ln2495"> </a>
<a name="ln2496">	/*</a>
<a name="ln2497">	 * Call MI attach routine.</a>
<a name="ln2498">	 */</a>
<a name="ln2499">	ether_ifattach(ifp, (caddr_t)eaddr);</a>
<a name="ln2500"> </a>
<a name="ln2501">	/* Hook interrupt last to avoid having to lock softc */</a>
<a name="ln2502">	error = bus_setup_intr(dev, sc-&gt;dc_irq, INTR_TYPE_NET | INTR_MPSAFE,</a>
<a name="ln2503">	    NULL, dc_intr, sc, &amp;sc-&gt;dc_intrhand);</a>
<a name="ln2504"> </a>
<a name="ln2505">	if (error) {</a>
<a name="ln2506">		device_printf(dev, &quot;couldn't set up irq\n&quot;);</a>
<a name="ln2507">		ether_ifdetach(ifp);</a>
<a name="ln2508">		goto fail;</a>
<a name="ln2509">	}</a>
<a name="ln2510"> </a>
<a name="ln2511">fail:</a>
<a name="ln2512">	if (error)</a>
<a name="ln2513">		dc_detach(dev);</a>
<a name="ln2514">	return (error);</a>
<a name="ln2515">}</a>
<a name="ln2516"> </a>
<a name="ln2517">/*</a>
<a name="ln2518"> * Shutdown hardware and free up resources. This can be called any</a>
<a name="ln2519"> * time after the mutex has been initialized. It is called in both</a>
<a name="ln2520"> * the error case in attach and the normal detach case so it needs</a>
<a name="ln2521"> * to be careful about only freeing resources that have actually been</a>
<a name="ln2522"> * allocated.</a>
<a name="ln2523"> */</a>
<a name="ln2524">static int</a>
<a name="ln2525">dc_detach(device_t dev)</a>
<a name="ln2526">{</a>
<a name="ln2527">	struct dc_softc *sc;</a>
<a name="ln2528">	struct ifnet *ifp;</a>
<a name="ln2529">	struct dc_mediainfo *m;</a>
<a name="ln2530"> </a>
<a name="ln2531">	sc = device_get_softc(dev);</a>
<a name="ln2532">	KASSERT(mtx_initialized(&amp;sc-&gt;dc_mtx), (&quot;dc mutex not initialized&quot;));</a>
<a name="ln2533"> </a>
<a name="ln2534">	ifp = sc-&gt;dc_ifp;</a>
<a name="ln2535"> </a>
<a name="ln2536">#ifdef DEVICE_POLLING</a>
<a name="ln2537">	if (ifp != NULL &amp;&amp; ifp-&gt;if_capenable &amp; IFCAP_POLLING)</a>
<a name="ln2538">		ether_poll_deregister(ifp);</a>
<a name="ln2539">#endif</a>
<a name="ln2540"> </a>
<a name="ln2541">	/* These should only be active if attach succeeded */</a>
<a name="ln2542">	if (device_is_attached(dev)) {</a>
<a name="ln2543">		DC_LOCK(sc);</a>
<a name="ln2544">		dc_stop(sc);</a>
<a name="ln2545">		DC_UNLOCK(sc);</a>
<a name="ln2546">		callout_drain(&amp;sc-&gt;dc_stat_ch);</a>
<a name="ln2547">		callout_drain(&amp;sc-&gt;dc_wdog_ch);</a>
<a name="ln2548">		ether_ifdetach(ifp);</a>
<a name="ln2549">	}</a>
<a name="ln2550">	if (sc-&gt;dc_miibus)</a>
<a name="ln2551">		device_delete_child(dev, sc-&gt;dc_miibus);</a>
<a name="ln2552">	bus_generic_detach(dev);</a>
<a name="ln2553"> </a>
<a name="ln2554">	if (sc-&gt;dc_intrhand)</a>
<a name="ln2555">		bus_teardown_intr(dev, sc-&gt;dc_irq, sc-&gt;dc_intrhand);</a>
<a name="ln2556">	if (sc-&gt;dc_irq)</a>
<a name="ln2557">		bus_release_resource(dev, SYS_RES_IRQ, 0, sc-&gt;dc_irq);</a>
<a name="ln2558">	if (sc-&gt;dc_res)</a>
<a name="ln2559">		bus_release_resource(dev, DC_RES, DC_RID, sc-&gt;dc_res);</a>
<a name="ln2560"> </a>
<a name="ln2561">	if (ifp != NULL)</a>
<a name="ln2562">		if_free(ifp);</a>
<a name="ln2563"> </a>
<a name="ln2564">	dc_dma_free(sc);</a>
<a name="ln2565"> </a>
<a name="ln2566">	free(sc-&gt;dc_pnic_rx_buf, M_DEVBUF);</a>
<a name="ln2567"> </a>
<a name="ln2568">	while (sc-&gt;dc_mi != NULL) {</a>
<a name="ln2569">		m = sc-&gt;dc_mi-&gt;dc_next;</a>
<a name="ln2570">		free(sc-&gt;dc_mi, M_DEVBUF);</a>
<a name="ln2571">		sc-&gt;dc_mi = m;</a>
<a name="ln2572">	}</a>
<a name="ln2573">	free(sc-&gt;dc_srom, M_DEVBUF);</a>
<a name="ln2574"> </a>
<a name="ln2575">	mtx_destroy(&amp;sc-&gt;dc_mtx);</a>
<a name="ln2576"> </a>
<a name="ln2577">	return (0);</a>
<a name="ln2578">}</a>
<a name="ln2579"> </a>
<a name="ln2580">/*</a>
<a name="ln2581"> * Initialize the transmit descriptors.</a>
<a name="ln2582"> */</a>
<a name="ln2583">static int</a>
<a name="ln2584">dc_list_tx_init(struct dc_softc *sc)</a>
<a name="ln2585">{</a>
<a name="ln2586">	struct dc_chain_data *cd;</a>
<a name="ln2587">	struct dc_list_data *ld;</a>
<a name="ln2588">	int i, nexti;</a>
<a name="ln2589"> </a>
<a name="ln2590">	cd = &amp;sc-&gt;dc_cdata;</a>
<a name="ln2591">	ld = &amp;sc-&gt;dc_ldata;</a>
<a name="ln2592">	for (i = 0; i &lt; DC_TX_LIST_CNT; i++) {</a>
<a name="ln2593">		if (i == DC_TX_LIST_CNT - 1)</a>
<a name="ln2594">			nexti = 0;</a>
<a name="ln2595">		else</a>
<a name="ln2596">			nexti = i + 1;</a>
<a name="ln2597">		ld-&gt;dc_tx_list[i].dc_status = 0;</a>
<a name="ln2598">		ld-&gt;dc_tx_list[i].dc_ctl = 0;</a>
<a name="ln2599">		ld-&gt;dc_tx_list[i].dc_data = 0;</a>
<a name="ln2600">		ld-&gt;dc_tx_list[i].dc_next = htole32(DC_TXDESC(sc, nexti));</a>
<a name="ln2601">		cd-&gt;dc_tx_chain[i] = NULL;</a>
<a name="ln2602">	}</a>
<a name="ln2603"> </a>
<a name="ln2604">	cd-&gt;dc_tx_prod = cd-&gt;dc_tx_cons = cd-&gt;dc_tx_cnt = 0;</a>
<a name="ln2605">	cd-&gt;dc_tx_pkts = 0;</a>
<a name="ln2606">	bus_dmamap_sync(sc-&gt;dc_tx_ltag, sc-&gt;dc_tx_lmap,</a>
<a name="ln2607">	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);</a>
<a name="ln2608">	return (0);</a>
<a name="ln2609">}</a>
<a name="ln2610"> </a>
<a name="ln2611">/*</a>
<a name="ln2612"> * Initialize the RX descriptors and allocate mbufs for them. Note that</a>
<a name="ln2613"> * we arrange the descriptors in a closed ring, so that the last descriptor</a>
<a name="ln2614"> * points back to the first.</a>
<a name="ln2615"> */</a>
<a name="ln2616">static int</a>
<a name="ln2617">dc_list_rx_init(struct dc_softc *sc)</a>
<a name="ln2618">{</a>
<a name="ln2619">	struct dc_chain_data *cd;</a>
<a name="ln2620">	struct dc_list_data *ld;</a>
<a name="ln2621">	int i, nexti;</a>
<a name="ln2622"> </a>
<a name="ln2623">	cd = &amp;sc-&gt;dc_cdata;</a>
<a name="ln2624">	ld = &amp;sc-&gt;dc_ldata;</a>
<a name="ln2625"> </a>
<a name="ln2626">	for (i = 0; i &lt; DC_RX_LIST_CNT; i++) {</a>
<a name="ln2627">		if (dc_newbuf(sc, i) != 0)</a>
<a name="ln2628">			return (ENOBUFS);</a>
<a name="ln2629">		if (i == DC_RX_LIST_CNT - 1)</a>
<a name="ln2630">			nexti = 0;</a>
<a name="ln2631">		else</a>
<a name="ln2632">			nexti = i + 1;</a>
<a name="ln2633">		ld-&gt;dc_rx_list[i].dc_next = htole32(DC_RXDESC(sc, nexti));</a>
<a name="ln2634">	}</a>
<a name="ln2635"> </a>
<a name="ln2636">	cd-&gt;dc_rx_prod = 0;</a>
<a name="ln2637">	bus_dmamap_sync(sc-&gt;dc_rx_ltag, sc-&gt;dc_rx_lmap,</a>
<a name="ln2638">	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);</a>
<a name="ln2639">	return (0);</a>
<a name="ln2640">}</a>
<a name="ln2641"> </a>
<a name="ln2642">/*</a>
<a name="ln2643"> * Initialize an RX descriptor and attach an MBUF cluster.</a>
<a name="ln2644"> */</a>
<a name="ln2645">static int</a>
<a name="ln2646">dc_newbuf(struct dc_softc *sc, int i)</a>
<a name="ln2647">{</a>
<a name="ln2648">	struct mbuf *m;</a>
<a name="ln2649">	bus_dmamap_t map;</a>
<a name="ln2650">	bus_dma_segment_t segs[1];</a>
<a name="ln2651">	int error, nseg;</a>
<a name="ln2652"> </a>
<a name="ln2653">	m = m_getcl(M_NOWAIT, MT_DATA, M_PKTHDR);</a>
<a name="ln2654">	if (m == NULL)</a>
<a name="ln2655">		return (ENOBUFS);</a>
<a name="ln2656">	m-&gt;m_len = m-&gt;m_pkthdr.len = MCLBYTES;</a>
<a name="ln2657">	m_adj(m, sizeof(u_int64_t));</a>
<a name="ln2658"> </a>
<a name="ln2659">	/*</a>
<a name="ln2660">	 * If this is a PNIC chip, zero the buffer. This is part</a>
<a name="ln2661">	 * of the workaround for the receive bug in the 82c168 and</a>
<a name="ln2662">	 * 82c169 chips.</a>
<a name="ln2663">	 */</a>
<a name="ln2664">	if (sc-&gt;dc_flags &amp; DC_PNIC_RX_BUG_WAR)</a>
<a name="ln2665">		bzero(mtod(m, char *), m-&gt;m_len);</a>
<a name="ln2666"> </a>
<a name="ln2667">	error = bus_dmamap_load_mbuf_sg(sc-&gt;dc_rx_mtag, sc-&gt;dc_sparemap,</a>
<a name="ln2668">	    m, segs, &amp;nseg, 0);</a>
<a name="ln2669">	if (error) {</a>
<a name="ln2670">		m_freem(m);</a>
<a name="ln2671">		return (error);</a>
<a name="ln2672">	}</a>
<a name="ln2673">	KASSERT(nseg == 1, (&quot;%s: wrong number of segments (%d)&quot;, __func__,</a>
<a name="ln2674">	    nseg));</a>
<a name="ln2675">	if (sc-&gt;dc_cdata.dc_rx_chain[i] != NULL)</a>
<a name="ln2676">		bus_dmamap_unload(sc-&gt;dc_rx_mtag, sc-&gt;dc_cdata.dc_rx_map[i]);</a>
<a name="ln2677"> </a>
<a name="ln2678">	map = sc-&gt;dc_cdata.dc_rx_map[i];</a>
<a name="ln2679">	sc-&gt;dc_cdata.dc_rx_map[i] = sc-&gt;dc_sparemap;</a>
<a name="ln2680">	sc-&gt;dc_sparemap = map;</a>
<a name="ln2681">	sc-&gt;dc_cdata.dc_rx_chain[i] = m;</a>
<a name="ln2682">	bus_dmamap_sync(sc-&gt;dc_rx_mtag, sc-&gt;dc_cdata.dc_rx_map[i],</a>
<a name="ln2683">	    BUS_DMASYNC_PREREAD);</a>
<a name="ln2684"> </a>
<a name="ln2685">	sc-&gt;dc_ldata.dc_rx_list[i].dc_ctl = htole32(DC_RXCTL_RLINK | DC_RXLEN);</a>
<a name="ln2686">	sc-&gt;dc_ldata.dc_rx_list[i].dc_data =</a>
<a name="ln2687">	    htole32(DC_ADDR_LO(segs[0].ds_addr));</a>
<a name="ln2688">	sc-&gt;dc_ldata.dc_rx_list[i].dc_status = htole32(DC_RXSTAT_OWN);</a>
<a name="ln2689">	bus_dmamap_sync(sc-&gt;dc_rx_ltag, sc-&gt;dc_rx_lmap,</a>
<a name="ln2690">	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);</a>
<a name="ln2691">	return (0);</a>
<a name="ln2692">}</a>
<a name="ln2693"> </a>
<a name="ln2694">/*</a>
<a name="ln2695"> * Grrrrr.</a>
<a name="ln2696"> * The PNIC chip has a terrible bug in it that manifests itself during</a>
<a name="ln2697"> * periods of heavy activity. The exact mode of failure if difficult to</a>
<a name="ln2698"> * pinpoint: sometimes it only happens in promiscuous mode, sometimes it</a>
<a name="ln2699"> * will happen on slow machines. The bug is that sometimes instead of</a>
<a name="ln2700"> * uploading one complete frame during reception, it uploads what looks</a>
<a name="ln2701"> * like the entire contents of its FIFO memory. The frame we want is at</a>
<a name="ln2702"> * the end of the whole mess, but we never know exactly how much data has</a>
<a name="ln2703"> * been uploaded, so salvaging the frame is hard.</a>
<a name="ln2704"> *</a>
<a name="ln2705"> * There is only one way to do it reliably, and it's disgusting.</a>
<a name="ln2706"> * Here's what we know:</a>
<a name="ln2707"> *</a>
<a name="ln2708"> * - We know there will always be somewhere between one and three extra</a>
<a name="ln2709"> *   descriptors uploaded.</a>
<a name="ln2710"> *</a>
<a name="ln2711"> * - We know the desired received frame will always be at the end of the</a>
<a name="ln2712"> *   total data upload.</a>
<a name="ln2713"> *</a>
<a name="ln2714"> * - We know the size of the desired received frame because it will be</a>
<a name="ln2715"> *   provided in the length field of the status word in the last descriptor.</a>
<a name="ln2716"> *</a>
<a name="ln2717"> * Here's what we do:</a>
<a name="ln2718"> *</a>
<a name="ln2719"> * - When we allocate buffers for the receive ring, we bzero() them.</a>
<a name="ln2720"> *   This means that we know that the buffer contents should be all</a>
<a name="ln2721"> *   zeros, except for data uploaded by the chip.</a>
<a name="ln2722"> *</a>
<a name="ln2723"> * - We also force the PNIC chip to upload frames that include the</a>
<a name="ln2724"> *   ethernet CRC at the end.</a>
<a name="ln2725"> *</a>
<a name="ln2726"> * - We gather all of the bogus frame data into a single buffer.</a>
<a name="ln2727"> *</a>
<a name="ln2728"> * - We then position a pointer at the end of this buffer and scan</a>
<a name="ln2729"> *   backwards until we encounter the first non-zero byte of data.</a>
<a name="ln2730"> *   This is the end of the received frame. We know we will encounter</a>
<a name="ln2731"> *   some data at the end of the frame because the CRC will always be</a>
<a name="ln2732"> *   there, so even if the sender transmits a packet of all zeros,</a>
<a name="ln2733"> *   we won't be fooled.</a>
<a name="ln2734"> *</a>
<a name="ln2735"> * - We know the size of the actual received frame, so we subtract</a>
<a name="ln2736"> *   that value from the current pointer location. This brings us</a>
<a name="ln2737"> *   to the start of the actual received packet.</a>
<a name="ln2738"> *</a>
<a name="ln2739"> * - We copy this into an mbuf and pass it on, along with the actual</a>
<a name="ln2740"> *   frame length.</a>
<a name="ln2741"> *</a>
<a name="ln2742"> * The performance hit is tremendous, but it beats dropping frames all</a>
<a name="ln2743"> * the time.</a>
<a name="ln2744"> */</a>
<a name="ln2745"> </a>
<a name="ln2746">#define	DC_WHOLEFRAME	(DC_RXSTAT_FIRSTFRAG | DC_RXSTAT_LASTFRAG)</a>
<a name="ln2747">static void</a>
<a name="ln2748">dc_pnic_rx_bug_war(struct dc_softc *sc, int idx)</a>
<a name="ln2749">{</a>
<a name="ln2750">	struct dc_desc *cur_rx;</a>
<a name="ln2751">	struct dc_desc *c = NULL;</a>
<a name="ln2752">	struct mbuf *m = NULL;</a>
<a name="ln2753">	unsigned char *ptr;</a>
<a name="ln2754">	int i, total_len;</a>
<a name="ln2755">	uint32_t rxstat = 0;</a>
<a name="ln2756"> </a>
<a name="ln2757">	i = sc-&gt;dc_pnic_rx_bug_save;</a>
<a name="ln2758">	cur_rx = &amp;sc-&gt;dc_ldata.dc_rx_list[idx];</a>
<a name="ln2759">	ptr = sc-&gt;dc_pnic_rx_buf;</a>
<a name="ln2760">	bzero(ptr, DC_RXLEN * 5);</a>
<a name="ln2761"> </a>
<a name="ln2762">	/* Copy all the bytes from the bogus buffers. */</a>
<a name="ln2763">	while (1) {</a>
<a name="ln2764">		c = &amp;sc-&gt;dc_ldata.dc_rx_list[i];</a>
<a name="ln2765">		rxstat = le32toh(c-&gt;dc_status);</a>
<a name="ln2766">		m = sc-&gt;dc_cdata.dc_rx_chain[i];</a>
<a name="ln2767">		bcopy(mtod(m, char *), ptr, DC_RXLEN);</a>
<a name="ln2768">		ptr += DC_RXLEN;</a>
<a name="ln2769">		/* If this is the last buffer, break out. */</a>
<a name="ln2770">		if (i == idx || rxstat &amp; DC_RXSTAT_LASTFRAG)</a>
<a name="ln2771">			break;</a>
<a name="ln2772">		dc_discard_rxbuf(sc, i);</a>
<a name="ln2773">		DC_INC(i, DC_RX_LIST_CNT);</a>
<a name="ln2774">	}</a>
<a name="ln2775"> </a>
<a name="ln2776">	/* Find the length of the actual receive frame. */</a>
<a name="ln2777">	total_len = DC_RXBYTES(rxstat);</a>
<a name="ln2778"> </a>
<a name="ln2779">	/* Scan backwards until we hit a non-zero byte. */</a>
<a name="ln2780">	while (*ptr == 0x00)</a>
<a name="ln2781">		ptr--;</a>
<a name="ln2782"> </a>
<a name="ln2783">	/* Round off. */</a>
<a name="ln2784">	if ((uintptr_t)(ptr) &amp; 0x3)</a>
<a name="ln2785">		ptr -= 1;</a>
<a name="ln2786"> </a>
<a name="ln2787">	/* Now find the start of the frame. */</a>
<a name="ln2788">	ptr -= total_len;</a>
<a name="ln2789">	if (ptr &lt; sc-&gt;dc_pnic_rx_buf)</a>
<a name="ln2790">		ptr = sc-&gt;dc_pnic_rx_buf;</a>
<a name="ln2791"> </a>
<a name="ln2792">	/*</a>
<a name="ln2793">	 * Now copy the salvaged frame to the last mbuf and fake up</a>
<a name="ln2794">	 * the status word to make it look like a successful</a>
<a name="ln2795">	 * frame reception.</a>
<a name="ln2796">	 */</a>
<a name="ln2797">	bcopy(ptr, mtod(m, char *), total_len);</a>
<a name="ln2798">	cur_rx-&gt;dc_status = htole32(rxstat | DC_RXSTAT_FIRSTFRAG);</a>
<a name="ln2799">}</a>
<a name="ln2800"> </a>
<a name="ln2801">/*</a>
<a name="ln2802"> * This routine searches the RX ring for dirty descriptors in the</a>
<a name="ln2803"> * event that the rxeof routine falls out of sync with the chip's</a>
<a name="ln2804"> * current descriptor pointer. This may happen sometimes as a result</a>
<a name="ln2805"> * of a &quot;no RX buffer available&quot; condition that happens when the chip</a>
<a name="ln2806"> * consumes all of the RX buffers before the driver has a chance to</a>
<a name="ln2807"> * process the RX ring. This routine may need to be called more than</a>
<a name="ln2808"> * once to bring the driver back in sync with the chip, however we</a>
<a name="ln2809"> * should still be getting RX DONE interrupts to drive the search</a>
<a name="ln2810"> * for new packets in the RX ring, so we should catch up eventually.</a>
<a name="ln2811"> */</a>
<a name="ln2812">static int</a>
<a name="ln2813">dc_rx_resync(struct dc_softc *sc)</a>
<a name="ln2814">{</a>
<a name="ln2815">	struct dc_desc *cur_rx;</a>
<a name="ln2816">	int i, pos;</a>
<a name="ln2817"> </a>
<a name="ln2818">	pos = sc-&gt;dc_cdata.dc_rx_prod;</a>
<a name="ln2819"> </a>
<a name="ln2820">	for (i = 0; i &lt; DC_RX_LIST_CNT; i++) {</a>
<a name="ln2821">		cur_rx = &amp;sc-&gt;dc_ldata.dc_rx_list[pos];</a>
<a name="ln2822">		if (!(le32toh(cur_rx-&gt;dc_status) &amp; DC_RXSTAT_OWN))</a>
<a name="ln2823">			break;</a>
<a name="ln2824">		DC_INC(pos, DC_RX_LIST_CNT);</a>
<a name="ln2825">	}</a>
<a name="ln2826"> </a>
<a name="ln2827">	/* If the ring really is empty, then just return. */</a>
<a name="ln2828">	if (i == DC_RX_LIST_CNT)</a>
<a name="ln2829">		return (0);</a>
<a name="ln2830"> </a>
<a name="ln2831">	/* We've fallen behing the chip: catch it. */</a>
<a name="ln2832">	sc-&gt;dc_cdata.dc_rx_prod = pos;</a>
<a name="ln2833"> </a>
<a name="ln2834">	return (EAGAIN);</a>
<a name="ln2835">}</a>
<a name="ln2836"> </a>
<a name="ln2837">static void</a>
<a name="ln2838">dc_discard_rxbuf(struct dc_softc *sc, int i)</a>
<a name="ln2839">{</a>
<a name="ln2840">	struct mbuf *m;</a>
<a name="ln2841"> </a>
<a name="ln2842">	if (sc-&gt;dc_flags &amp; DC_PNIC_RX_BUG_WAR) {</a>
<a name="ln2843">		m = sc-&gt;dc_cdata.dc_rx_chain[i];</a>
<a name="ln2844">		bzero(mtod(m, char *), m-&gt;m_len);</a>
<a name="ln2845">	}</a>
<a name="ln2846"> </a>
<a name="ln2847">	sc-&gt;dc_ldata.dc_rx_list[i].dc_ctl = htole32(DC_RXCTL_RLINK | DC_RXLEN);</a>
<a name="ln2848">	sc-&gt;dc_ldata.dc_rx_list[i].dc_status = htole32(DC_RXSTAT_OWN);</a>
<a name="ln2849">	bus_dmamap_sync(sc-&gt;dc_rx_ltag, sc-&gt;dc_rx_lmap, BUS_DMASYNC_PREREAD |</a>
<a name="ln2850">	    BUS_DMASYNC_PREWRITE);</a>
<a name="ln2851">}</a>
<a name="ln2852"> </a>
<a name="ln2853">/*</a>
<a name="ln2854"> * A frame has been uploaded: pass the resulting mbuf chain up to</a>
<a name="ln2855"> * the higher level protocols.</a>
<a name="ln2856"> */</a>
<a name="ln2857">static int</a>
<a name="ln2858">dc_rxeof(struct dc_softc *sc)</a>
<a name="ln2859">{</a>
<a name="ln2860">	struct mbuf *m;</a>
<a name="ln2861">	struct ifnet *ifp;</a>
<a name="ln2862">	struct dc_desc *cur_rx;</a>
<a name="ln2863">	int i, total_len, rx_npkts;</a>
<a name="ln2864">	uint32_t rxstat;</a>
<a name="ln2865"> </a>
<a name="ln2866">	DC_LOCK_ASSERT(sc);</a>
<a name="ln2867"> </a>
<a name="ln2868">	ifp = sc-&gt;dc_ifp;</a>
<a name="ln2869">	rx_npkts = 0;</a>
<a name="ln2870"> </a>
<a name="ln2871">	bus_dmamap_sync(sc-&gt;dc_rx_ltag, sc-&gt;dc_rx_lmap, BUS_DMASYNC_POSTREAD |</a>
<a name="ln2872">	    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln2873">	for (i = sc-&gt;dc_cdata.dc_rx_prod;</a>
<a name="ln2874">	    (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) != 0;</a>
<a name="ln2875">	    DC_INC(i, DC_RX_LIST_CNT)) {</a>
<a name="ln2876">#ifdef DEVICE_POLLING</a>
<a name="ln2877">		if (ifp-&gt;if_capenable &amp; IFCAP_POLLING) {</a>
<a name="ln2878">			if (sc-&gt;rxcycles &lt;= 0)</a>
<a name="ln2879">				break;</a>
<a name="ln2880">			sc-&gt;rxcycles--;</a>
<a name="ln2881">		}</a>
<a name="ln2882">#endif</a>
<a name="ln2883">		cur_rx = &amp;sc-&gt;dc_ldata.dc_rx_list[i];</a>
<a name="ln2884">		rxstat = le32toh(cur_rx-&gt;dc_status);</a>
<a name="ln2885">		if ((rxstat &amp; DC_RXSTAT_OWN) != 0)</a>
<a name="ln2886">			break;</a>
<a name="ln2887">		m = sc-&gt;dc_cdata.dc_rx_chain[i];</a>
<a name="ln2888">		bus_dmamap_sync(sc-&gt;dc_rx_mtag, sc-&gt;dc_cdata.dc_rx_map[i],</a>
<a name="ln2889">		    BUS_DMASYNC_POSTREAD);</a>
<a name="ln2890">		total_len = DC_RXBYTES(rxstat);</a>
<a name="ln2891">		rx_npkts++;</a>
<a name="ln2892"> </a>
<a name="ln2893">		if (sc-&gt;dc_flags &amp; DC_PNIC_RX_BUG_WAR) {</a>
<a name="ln2894">			if ((rxstat &amp; DC_WHOLEFRAME) != DC_WHOLEFRAME) {</a>
<a name="ln2895">				if (rxstat &amp; DC_RXSTAT_FIRSTFRAG)</a>
<a name="ln2896">					sc-&gt;dc_pnic_rx_bug_save = i;</a>
<a name="ln2897">				if ((rxstat &amp; DC_RXSTAT_LASTFRAG) == 0)</a>
<a name="ln2898">					continue;</a>
<a name="ln2899">				dc_pnic_rx_bug_war(sc, i);</a>
<a name="ln2900">				rxstat = le32toh(cur_rx-&gt;dc_status);</a>
<a name="ln2901">				total_len = DC_RXBYTES(rxstat);</a>
<a name="ln2902">			}</a>
<a name="ln2903">		}</a>
<a name="ln2904"> </a>
<a name="ln2905">		/*</a>
<a name="ln2906">		 * If an error occurs, update stats, clear the</a>
<a name="ln2907">		 * status word and leave the mbuf cluster in place:</a>
<a name="ln2908">		 * it should simply get re-used next time this descriptor</a>
<a name="ln2909">		 * comes up in the ring.  However, don't report long</a>
<a name="ln2910">		 * frames as errors since they could be vlans.</a>
<a name="ln2911">		 */</a>
<a name="ln2912">		if ((rxstat &amp; DC_RXSTAT_RXERR)) {</a>
<a name="ln2913">			if (!(rxstat &amp; DC_RXSTAT_GIANT) ||</a>
<a name="ln2914">			    (rxstat &amp; (DC_RXSTAT_CRCERR | DC_RXSTAT_DRIBBLE |</a>
<a name="ln2915">				       DC_RXSTAT_MIIERE | DC_RXSTAT_COLLSEEN |</a>
<a name="ln2916">				       DC_RXSTAT_RUNT   | DC_RXSTAT_DE))) {</a>
<a name="ln2917">				if_inc_counter(ifp, IFCOUNTER_IERRORS, 1);</a>
<a name="ln2918">				if (rxstat &amp; DC_RXSTAT_COLLSEEN)</a>
<a name="ln2919">					if_inc_counter(ifp, IFCOUNTER_COLLISIONS, 1);</a>
<a name="ln2920">				dc_discard_rxbuf(sc, i);</a>
<a name="ln2921">				if (rxstat &amp; DC_RXSTAT_CRCERR)</a>
<a name="ln2922">					continue;</a>
<a name="ln2923">				else {</a>
<a name="ln2924">					ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_RUNNING;</a>
<a name="ln2925">					dc_init_locked(sc);</a>
<a name="ln2926">					return (rx_npkts);</a>
<a name="ln2927">				}</a>
<a name="ln2928">			}</a>
<a name="ln2929">		}</a>
<a name="ln2930"> </a>
<a name="ln2931">		/* No errors; receive the packet. */</a>
<a name="ln2932">		total_len -= ETHER_CRC_LEN;</a>
<a name="ln2933">#ifdef __NO_STRICT_ALIGNMENT</a>
<a name="ln2934">		/*</a>
<a name="ln2935">		 * On architectures without alignment problems we try to</a>
<a name="ln2936">		 * allocate a new buffer for the receive ring, and pass up</a>
<a name="ln2937">		 * the one where the packet is already, saving the expensive</a>
<a name="ln2938">		 * copy done in m_devget().</a>
<a name="ln2939">		 * If we are on an architecture with alignment problems, or</a>
<a name="ln2940">		 * if the allocation fails, then use m_devget and leave the</a>
<a name="ln2941">		 * existing buffer in the receive ring.</a>
<a name="ln2942">		 */</a>
<a name="ln2943">		if (dc_newbuf(sc, i) != 0) {</a>
<a name="ln2944">			dc_discard_rxbuf(sc, i);</a>
<a name="ln2945">			if_inc_counter(ifp, IFCOUNTER_IQDROPS, 1);</a>
<a name="ln2946">			continue;</a>
<a name="ln2947">		}</a>
<a name="ln2948">		m-&gt;m_pkthdr.rcvif = ifp;</a>
<a name="ln2949">		m-&gt;m_pkthdr.len = m-&gt;m_len = total_len;</a>
<a name="ln2950">#else</a>
<a name="ln2951">		{</a>
<a name="ln2952">			struct mbuf *m0;</a>
<a name="ln2953"> </a>
<a name="ln2954">			m0 = m_devget(mtod(m, char *), total_len,</a>
<a name="ln2955">				ETHER_ALIGN, ifp, NULL);</a>
<a name="ln2956">			dc_discard_rxbuf(sc, i);</a>
<a name="ln2957">			if (m0 == NULL) {</a>
<a name="ln2958">				if_inc_counter(ifp, IFCOUNTER_IQDROPS, 1);</a>
<a name="ln2959">				continue;</a>
<a name="ln2960">			}</a>
<a name="ln2961">			m = m0;</a>
<a name="ln2962">		}</a>
<a name="ln2963">#endif</a>
<a name="ln2964"> </a>
<a name="ln2965">		if_inc_counter(ifp, IFCOUNTER_IPACKETS, 1);</a>
<a name="ln2966">		DC_UNLOCK(sc);</a>
<a name="ln2967">		(*ifp-&gt;if_input)(ifp, m);</a>
<a name="ln2968">		DC_LOCK(sc);</a>
<a name="ln2969">	}</a>
<a name="ln2970"> </a>
<a name="ln2971">	sc-&gt;dc_cdata.dc_rx_prod = i;</a>
<a name="ln2972">	return (rx_npkts);</a>
<a name="ln2973">}</a>
<a name="ln2974"> </a>
<a name="ln2975">/*</a>
<a name="ln2976"> * A frame was downloaded to the chip. It's safe for us to clean up</a>
<a name="ln2977"> * the list buffers.</a>
<a name="ln2978"> */</a>
<a name="ln2979">static void</a>
<a name="ln2980">dc_txeof(struct dc_softc *sc)</a>
<a name="ln2981">{</a>
<a name="ln2982">	struct dc_desc *cur_tx;</a>
<a name="ln2983">	struct ifnet *ifp;</a>
<a name="ln2984">	int idx, setup;</a>
<a name="ln2985">	uint32_t ctl, txstat;</a>
<a name="ln2986"> </a>
<a name="ln2987">	if (sc-&gt;dc_cdata.dc_tx_cnt == 0)</a>
<a name="ln2988">		return;</a>
<a name="ln2989"> </a>
<a name="ln2990">	ifp = sc-&gt;dc_ifp;</a>
<a name="ln2991"> </a>
<a name="ln2992">	/*</a>
<a name="ln2993">	 * Go through our tx list and free mbufs for those</a>
<a name="ln2994">	 * frames that have been transmitted.</a>
<a name="ln2995">	 */</a>
<a name="ln2996">	bus_dmamap_sync(sc-&gt;dc_tx_ltag, sc-&gt;dc_tx_lmap, BUS_DMASYNC_POSTREAD |</a>
<a name="ln2997">	    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln2998">	setup = 0;</a>
<a name="ln2999">	for (idx = sc-&gt;dc_cdata.dc_tx_cons; idx != sc-&gt;dc_cdata.dc_tx_prod;</a>
<a name="ln3000">	    DC_INC(idx, DC_TX_LIST_CNT), sc-&gt;dc_cdata.dc_tx_cnt--) {</a>
<a name="ln3001">		cur_tx = &amp;sc-&gt;dc_ldata.dc_tx_list[idx];</a>
<a name="ln3002">		txstat = le32toh(cur_tx-&gt;dc_status);</a>
<a name="ln3003">		ctl = le32toh(cur_tx-&gt;dc_ctl);</a>
<a name="ln3004"> </a>
<a name="ln3005">		if (txstat &amp; DC_TXSTAT_OWN)</a>
<a name="ln3006">			break;</a>
<a name="ln3007"> </a>
<a name="ln3008">		if (sc-&gt;dc_cdata.dc_tx_chain[idx] == NULL)</a>
<a name="ln3009">			continue;</a>
<a name="ln3010"> </a>
<a name="ln3011">		if (ctl &amp; DC_TXCTL_SETUP) {</a>
<a name="ln3012">			cur_tx-&gt;dc_ctl = htole32(ctl &amp; ~DC_TXCTL_SETUP);</a>
<a name="ln3013">			setup++;</a>
<a name="ln3014">			bus_dmamap_sync(sc-&gt;dc_stag, sc-&gt;dc_smap,</a>
<a name="ln3015">			    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln3016">			/*</a>
<a name="ln3017">			 * Yes, the PNIC is so brain damaged</a>
<a name="ln3018">			 * that it will sometimes generate a TX</a>
<a name="ln3019">			 * underrun error while DMAing the RX</a>
<a name="ln3020">			 * filter setup frame. If we detect this,</a>
<a name="ln3021">			 * we have to send the setup frame again,</a>
<a name="ln3022">			 * or else the filter won't be programmed</a>
<a name="ln3023">			 * correctly.</a>
<a name="ln3024">			 */</a>
<a name="ln3025">			if (DC_IS_PNIC(sc)) {</a>
<a name="ln3026">				if (txstat &amp; DC_TXSTAT_ERRSUM)</a>
<a name="ln3027">					dc_setfilt(sc);</a>
<a name="ln3028">			}</a>
<a name="ln3029">			sc-&gt;dc_cdata.dc_tx_chain[idx] = NULL;</a>
<a name="ln3030">			continue;</a>
<a name="ln3031">		}</a>
<a name="ln3032"> </a>
<a name="ln3033">		if (DC_IS_XIRCOM(sc) || DC_IS_CONEXANT(sc)) {</a>
<a name="ln3034">			/*</a>
<a name="ln3035">			 * XXX: Why does my Xircom taunt me so?</a>
<a name="ln3036">			 * For some reason it likes setting the CARRLOST flag</a>
<a name="ln3037">			 * even when the carrier is there. wtf?!?</a>
<a name="ln3038">			 * Who knows, but Conexant chips have the</a>
<a name="ln3039">			 * same problem. Maybe they took lessons</a>
<a name="ln3040">			 * from Xircom.</a>
<a name="ln3041">			 */</a>
<a name="ln3042">			if (/*sc-&gt;dc_type == DC_TYPE_21143 &amp;&amp;*/</a>
<a name="ln3043">			    sc-&gt;dc_pmode == DC_PMODE_MII &amp;&amp;</a>
<a name="ln3044">			    ((txstat &amp; 0xFFFF) &amp; ~(DC_TXSTAT_ERRSUM |</a>
<a name="ln3045">			    DC_TXSTAT_NOCARRIER)))</a>
<a name="ln3046">				txstat &amp;= ~DC_TXSTAT_ERRSUM;</a>
<a name="ln3047">		} else {</a>
<a name="ln3048">			if (/*sc-&gt;dc_type == DC_TYPE_21143 &amp;&amp;*/</a>
<a name="ln3049">			    sc-&gt;dc_pmode == DC_PMODE_MII &amp;&amp;</a>
<a name="ln3050">			    ((txstat &amp; 0xFFFF) &amp; ~(DC_TXSTAT_ERRSUM |</a>
<a name="ln3051">			    DC_TXSTAT_NOCARRIER | DC_TXSTAT_CARRLOST)))</a>
<a name="ln3052">				txstat &amp;= ~DC_TXSTAT_ERRSUM;</a>
<a name="ln3053">		}</a>
<a name="ln3054"> </a>
<a name="ln3055">		if (txstat &amp; DC_TXSTAT_ERRSUM) {</a>
<a name="ln3056">			if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln3057">			if (txstat &amp; DC_TXSTAT_EXCESSCOLL)</a>
<a name="ln3058">				if_inc_counter(ifp, IFCOUNTER_COLLISIONS, 1);</a>
<a name="ln3059">			if (txstat &amp; DC_TXSTAT_LATECOLL)</a>
<a name="ln3060">				if_inc_counter(ifp, IFCOUNTER_COLLISIONS, 1);</a>
<a name="ln3061">			if (!(txstat &amp; DC_TXSTAT_UNDERRUN)) {</a>
<a name="ln3062">				ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_RUNNING;</a>
<a name="ln3063">				dc_init_locked(sc);</a>
<a name="ln3064">				return;</a>
<a name="ln3065">			}</a>
<a name="ln3066">		} else</a>
<a name="ln3067">			if_inc_counter(ifp, IFCOUNTER_OPACKETS, 1);</a>
<a name="ln3068">		if_inc_counter(ifp, IFCOUNTER_COLLISIONS, (txstat &amp; DC_TXSTAT_COLLCNT) &gt;&gt; 3);</a>
<a name="ln3069"> </a>
<a name="ln3070">		bus_dmamap_sync(sc-&gt;dc_tx_mtag, sc-&gt;dc_cdata.dc_tx_map[idx],</a>
<a name="ln3071">		    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln3072">		bus_dmamap_unload(sc-&gt;dc_tx_mtag, sc-&gt;dc_cdata.dc_tx_map[idx]);</a>
<a name="ln3073">		m_freem(sc-&gt;dc_cdata.dc_tx_chain[idx]);</a>
<a name="ln3074">		sc-&gt;dc_cdata.dc_tx_chain[idx] = NULL;</a>
<a name="ln3075">	}</a>
<a name="ln3076">	sc-&gt;dc_cdata.dc_tx_cons = idx;</a>
<a name="ln3077"> </a>
<a name="ln3078">	if (sc-&gt;dc_cdata.dc_tx_cnt &lt;= DC_TX_LIST_CNT - DC_TX_LIST_RSVD) {</a>
<a name="ln3079">		ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_OACTIVE;</a>
<a name="ln3080">		if (sc-&gt;dc_cdata.dc_tx_cnt == 0)</a>
<a name="ln3081">			sc-&gt;dc_wdog_timer = 0;</a>
<a name="ln3082">	}</a>
<a name="ln3083">	if (setup &gt; 0)</a>
<a name="ln3084">		bus_dmamap_sync(sc-&gt;dc_tx_ltag, sc-&gt;dc_tx_lmap,</a>
<a name="ln3085">		    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln3086">}</a>
<a name="ln3087"> </a>
<a name="ln3088">static void</a>
<a name="ln3089">dc_tick(void *xsc)</a>
<a name="ln3090">{</a>
<a name="ln3091">	struct dc_softc *sc;</a>
<a name="ln3092">	struct mii_data *mii;</a>
<a name="ln3093">	struct ifnet *ifp;</a>
<a name="ln3094">	uint32_t r;</a>
<a name="ln3095"> </a>
<a name="ln3096">	sc = xsc;</a>
<a name="ln3097">	DC_LOCK_ASSERT(sc);</a>
<a name="ln3098">	ifp = sc-&gt;dc_ifp;</a>
<a name="ln3099">	mii = device_get_softc(sc-&gt;dc_miibus);</a>
<a name="ln3100"> </a>
<a name="ln3101">	/*</a>
<a name="ln3102">	 * Reclaim transmitted frames for controllers that do</a>
<a name="ln3103">	 * not generate TX completion interrupt for every frame.</a>
<a name="ln3104">	 */</a>
<a name="ln3105">	if (sc-&gt;dc_flags &amp; DC_TX_USE_TX_INTR)</a>
<a name="ln3106">		dc_txeof(sc);</a>
<a name="ln3107"> </a>
<a name="ln3108">	if (sc-&gt;dc_flags &amp; DC_REDUCED_MII_POLL) {</a>
<a name="ln3109">		if (sc-&gt;dc_flags &amp; DC_21143_NWAY) {</a>
<a name="ln3110">			r = CSR_READ_4(sc, DC_10BTSTAT);</a>
<a name="ln3111">			if (IFM_SUBTYPE(mii-&gt;mii_media_active) ==</a>
<a name="ln3112">			    IFM_100_TX &amp;&amp; (r &amp; DC_TSTAT_LS100)) {</a>
<a name="ln3113">				sc-&gt;dc_link = 0;</a>
<a name="ln3114">				mii_mediachg(mii);</a>
<a name="ln3115">			}</a>
<a name="ln3116">			if (IFM_SUBTYPE(mii-&gt;mii_media_active) ==</a>
<a name="ln3117">			    IFM_10_T &amp;&amp; (r &amp; DC_TSTAT_LS10)) {</a>
<a name="ln3118">				sc-&gt;dc_link = 0;</a>
<a name="ln3119">				mii_mediachg(mii);</a>
<a name="ln3120">			}</a>
<a name="ln3121">			if (sc-&gt;dc_link == 0)</a>
<a name="ln3122">				mii_tick(mii);</a>
<a name="ln3123">		} else {</a>
<a name="ln3124">			/*</a>
<a name="ln3125">			 * For NICs which never report DC_RXSTATE_WAIT, we</a>
<a name="ln3126">			 * have to bite the bullet...</a>
<a name="ln3127">			 */</a>
<a name="ln3128">			if ((DC_HAS_BROKEN_RXSTATE(sc) || (CSR_READ_4(sc,</a>
<a name="ln3129">			    DC_ISR) &amp; DC_ISR_RX_STATE) == DC_RXSTATE_WAIT) &amp;&amp;</a>
<a name="ln3130">			    sc-&gt;dc_cdata.dc_tx_cnt == 0)</a>
<a name="ln3131">				mii_tick(mii);</a>
<a name="ln3132">		}</a>
<a name="ln3133">	} else</a>
<a name="ln3134">		mii_tick(mii);</a>
<a name="ln3135"> </a>
<a name="ln3136">	/*</a>
<a name="ln3137">	 * When the init routine completes, we expect to be able to send</a>
<a name="ln3138">	 * packets right away, and in fact the network code will send a</a>
<a name="ln3139">	 * gratuitous ARP the moment the init routine marks the interface</a>
<a name="ln3140">	 * as running. However, even though the MAC may have been initialized,</a>
<a name="ln3141">	 * there may be a delay of a few seconds before the PHY completes</a>
<a name="ln3142">	 * autonegotiation and the link is brought up. Any transmissions</a>
<a name="ln3143">	 * made during that delay will be lost. Dealing with this is tricky:</a>
<a name="ln3144">	 * we can't just pause in the init routine while waiting for the</a>
<a name="ln3145">	 * PHY to come ready since that would bring the whole system to</a>
<a name="ln3146">	 * a screeching halt for several seconds.</a>
<a name="ln3147">	 *</a>
<a name="ln3148">	 * What we do here is prevent the TX start routine from sending</a>
<a name="ln3149">	 * any packets until a link has been established. After the</a>
<a name="ln3150">	 * interface has been initialized, the tick routine will poll</a>
<a name="ln3151">	 * the state of the PHY until the IFM_ACTIVE flag is set. Until</a>
<a name="ln3152">	 * that time, packets will stay in the send queue, and once the</a>
<a name="ln3153">	 * link comes up, they will be flushed out to the wire.</a>
<a name="ln3154">	 */</a>
<a name="ln3155">	if (sc-&gt;dc_link != 0 &amp;&amp; !IFQ_DRV_IS_EMPTY(&amp;ifp-&gt;if_snd))</a>
<a name="ln3156">		dc_start_locked(ifp);</a>
<a name="ln3157"> </a>
<a name="ln3158">	if (sc-&gt;dc_flags &amp; DC_21143_NWAY &amp;&amp; !sc-&gt;dc_link)</a>
<a name="ln3159">		callout_reset(&amp;sc-&gt;dc_stat_ch, hz/10, dc_tick, sc);</a>
<a name="ln3160">	else</a>
<a name="ln3161">		callout_reset(&amp;sc-&gt;dc_stat_ch, hz, dc_tick, sc);</a>
<a name="ln3162">}</a>
<a name="ln3163"> </a>
<a name="ln3164">/*</a>
<a name="ln3165"> * A transmit underrun has occurred.  Back off the transmit threshold,</a>
<a name="ln3166"> * or switch to store and forward mode if we have to.</a>
<a name="ln3167"> */</a>
<a name="ln3168">static void</a>
<a name="ln3169">dc_tx_underrun(struct dc_softc *sc)</a>
<a name="ln3170">{</a>
<a name="ln3171">	uint32_t netcfg, isr;</a>
<a name="ln3172">	int i, reinit;</a>
<a name="ln3173"> </a>
<a name="ln3174">	reinit = 0;</a>
<a name="ln3175">	netcfg = CSR_READ_4(sc, DC_NETCFG);</a>
<a name="ln3176">	device_printf(sc-&gt;dc_dev, &quot;TX underrun -- &quot;);</a>
<a name="ln3177">	if ((sc-&gt;dc_flags &amp; DC_TX_STORENFWD) == 0) {</a>
<a name="ln3178">		if (sc-&gt;dc_txthresh + DC_TXTHRESH_INC &gt; DC_TXTHRESH_MAX) {</a>
<a name="ln3179">			printf(&quot;using store and forward mode\n&quot;);</a>
<a name="ln3180">			netcfg |= DC_NETCFG_STORENFWD;</a>
<a name="ln3181">		} else {</a>
<a name="ln3182">			printf(&quot;increasing TX threshold\n&quot;);</a>
<a name="ln3183">			sc-&gt;dc_txthresh += DC_TXTHRESH_INC;</a>
<a name="ln3184">			netcfg &amp;= ~DC_NETCFG_TX_THRESH;</a>
<a name="ln3185">			netcfg |= sc-&gt;dc_txthresh;</a>
<a name="ln3186">		}</a>
<a name="ln3187"> </a>
<a name="ln3188">		if (DC_IS_INTEL(sc)) {</a>
<a name="ln3189">			/*</a>
<a name="ln3190">			 * The real 21143 requires that the transmitter be idle</a>
<a name="ln3191">			 * in order to change the transmit threshold or store</a>
<a name="ln3192">			 * and forward state.</a>
<a name="ln3193">			 */</a>
<a name="ln3194">			CSR_WRITE_4(sc, DC_NETCFG, netcfg &amp; ~DC_NETCFG_TX_ON);</a>
<a name="ln3195"> </a>
<a name="ln3196">			for (i = 0; i &lt; DC_TIMEOUT; i++) {</a>
<a name="ln3197">				isr = CSR_READ_4(sc, DC_ISR);</a>
<a name="ln3198">				if (isr &amp; DC_ISR_TX_IDLE)</a>
<a name="ln3199">					break;</a>
<a name="ln3200">				DELAY(10);</a>
<a name="ln3201">			}</a>
<a name="ln3202">			if (i == DC_TIMEOUT) {</a>
<a name="ln3203">				device_printf(sc-&gt;dc_dev,</a>
<a name="ln3204">				    &quot;%s: failed to force tx to idle state\n&quot;,</a>
<a name="ln3205">				    __func__);</a>
<a name="ln3206">				reinit++;</a>
<a name="ln3207">			}</a>
<a name="ln3208">		}</a>
<a name="ln3209">	} else {</a>
<a name="ln3210">		printf(&quot;resetting\n&quot;);</a>
<a name="ln3211">		reinit++;</a>
<a name="ln3212">	}</a>
<a name="ln3213"> </a>
<a name="ln3214">	if (reinit == 0) {</a>
<a name="ln3215">		CSR_WRITE_4(sc, DC_NETCFG, netcfg);</a>
<a name="ln3216">		if (DC_IS_INTEL(sc))</a>
<a name="ln3217">			CSR_WRITE_4(sc, DC_NETCFG, netcfg | DC_NETCFG_TX_ON);</a>
<a name="ln3218">	} else {</a>
<a name="ln3219">		sc-&gt;dc_ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_RUNNING;</a>
<a name="ln3220">		dc_init_locked(sc);</a>
<a name="ln3221">	}</a>
<a name="ln3222">}</a>
<a name="ln3223"> </a>
<a name="ln3224">#ifdef DEVICE_POLLING</a>
<a name="ln3225">static poll_handler_t dc_poll;</a>
<a name="ln3226"> </a>
<a name="ln3227">static int</a>
<a name="ln3228">dc_poll(struct ifnet *ifp, enum poll_cmd cmd, int count)</a>
<a name="ln3229">{</a>
<a name="ln3230">	struct dc_softc *sc = ifp-&gt;if_softc;</a>
<a name="ln3231">	int rx_npkts = 0;</a>
<a name="ln3232"> </a>
<a name="ln3233">	DC_LOCK(sc);</a>
<a name="ln3234"> </a>
<a name="ln3235">	if (!(ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING)) {</a>
<a name="ln3236">		DC_UNLOCK(sc);</a>
<a name="ln3237">		return (rx_npkts);</a>
<a name="ln3238">	}</a>
<a name="ln3239"> </a>
<a name="ln3240">	sc-&gt;rxcycles = count;</a>
<a name="ln3241">	rx_npkts = dc_rxeof(sc);</a>
<a name="ln3242">	dc_txeof(sc);</a>
<a name="ln3243">	if (!IFQ_IS_EMPTY(&amp;ifp-&gt;if_snd) &amp;&amp;</a>
<a name="ln3244">	    !(ifp-&gt;if_drv_flags &amp; IFF_DRV_OACTIVE))</a>
<a name="ln3245">		dc_start_locked(ifp);</a>
<a name="ln3246"> </a>
<a name="ln3247">	if (cmd == POLL_AND_CHECK_STATUS) { /* also check status register */</a>
<a name="ln3248">		uint32_t	status;</a>
<a name="ln3249"> </a>
<a name="ln3250">		status = CSR_READ_4(sc, DC_ISR);</a>
<a name="ln3251">		status &amp;= (DC_ISR_RX_WATDOGTIMEO | DC_ISR_RX_NOBUF |</a>
<a name="ln3252">			DC_ISR_TX_NOBUF | DC_ISR_TX_IDLE | DC_ISR_TX_UNDERRUN |</a>
<a name="ln3253">			DC_ISR_BUS_ERR);</a>
<a name="ln3254">		if (!status) {</a>
<a name="ln3255">			DC_UNLOCK(sc);</a>
<a name="ln3256">			return (rx_npkts);</a>
<a name="ln3257">		}</a>
<a name="ln3258">		/* ack what we have */</a>
<a name="ln3259">		CSR_WRITE_4(sc, DC_ISR, status);</a>
<a name="ln3260"> </a>
<a name="ln3261">		if (status &amp; (DC_ISR_RX_WATDOGTIMEO | DC_ISR_RX_NOBUF)) {</a>
<a name="ln3262">			uint32_t r = CSR_READ_4(sc, DC_FRAMESDISCARDED);</a>
<a name="ln3263">			if_inc_counter(ifp, IFCOUNTER_IERRORS, (r &amp; 0xffff) + ((r &gt;&gt; 17) &amp; 0x7ff));</a>
<a name="ln3264"> </a>
<a name="ln3265">			if (dc_rx_resync(sc))</a>
<a name="ln3266">				dc_rxeof(sc);</a>
<a name="ln3267">		}</a>
<a name="ln3268">		/* restart transmit unit if necessary */</a>
<a name="ln3269">		if (status &amp; DC_ISR_TX_IDLE &amp;&amp; sc-&gt;dc_cdata.dc_tx_cnt)</a>
<a name="ln3270">			CSR_WRITE_4(sc, DC_TXSTART, 0xFFFFFFFF);</a>
<a name="ln3271"> </a>
<a name="ln3272">		if (status &amp; DC_ISR_TX_UNDERRUN)</a>
<a name="ln3273">			dc_tx_underrun(sc);</a>
<a name="ln3274"> </a>
<a name="ln3275">		if (status &amp; DC_ISR_BUS_ERR) {</a>
<a name="ln3276">			if_printf(ifp, &quot;%s: bus error\n&quot;, __func__);</a>
<a name="ln3277">			ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_RUNNING;</a>
<a name="ln3278">			dc_init_locked(sc);</a>
<a name="ln3279">		}</a>
<a name="ln3280">	}</a>
<a name="ln3281">	DC_UNLOCK(sc);</a>
<a name="ln3282">	return (rx_npkts);</a>
<a name="ln3283">}</a>
<a name="ln3284">#endif /* DEVICE_POLLING */</a>
<a name="ln3285"> </a>
<a name="ln3286">static void</a>
<a name="ln3287">dc_intr(void *arg)</a>
<a name="ln3288">{</a>
<a name="ln3289">	struct dc_softc *sc;</a>
<a name="ln3290">	struct ifnet *ifp;</a>
<a name="ln3291">	uint32_t r, status;</a>
<a name="ln3292">	int n;</a>
<a name="ln3293"> </a>
<a name="ln3294">	sc = arg;</a>
<a name="ln3295"> </a>
<a name="ln3296">	if (sc-&gt;suspended)</a>
<a name="ln3297">		return;</a>
<a name="ln3298"> </a>
<a name="ln3299">	DC_LOCK(sc);</a>
<a name="ln3300">	status = CSR_READ_4(sc, DC_ISR);</a>
<a name="ln3301">	if (status == 0xFFFFFFFF || (status &amp; DC_INTRS) == 0) {</a>
<a name="ln3302">		DC_UNLOCK(sc);</a>
<a name="ln3303">		return;</a>
<a name="ln3304">	}</a>
<a name="ln3305">	ifp = sc-&gt;dc_ifp;</a>
<a name="ln3306">#ifdef DEVICE_POLLING</a>
<a name="ln3307">	if (ifp-&gt;if_capenable &amp; IFCAP_POLLING) {</a>
<a name="ln3308">		DC_UNLOCK(sc);</a>
<a name="ln3309">		return;</a>
<a name="ln3310">	}</a>
<a name="ln3311">#endif</a>
<a name="ln3312">	/* Disable interrupts. */</a>
<a name="ln3313">	CSR_WRITE_4(sc, DC_IMR, 0x00000000);</a>
<a name="ln3314"> </a>
<a name="ln3315">	for (n = 16; n &gt; 0; n--) {</a>
<a name="ln3316">		if ((ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) == 0)</a>
<a name="ln3317">			break;</a>
<a name="ln3318">		/* Ack interrupts. */</a>
<a name="ln3319">		CSR_WRITE_4(sc, DC_ISR, status);</a>
<a name="ln3320"> </a>
<a name="ln3321">		if (status &amp; DC_ISR_RX_OK) {</a>
<a name="ln3322">			if (dc_rxeof(sc) == 0) {</a>
<a name="ln3323">				while (dc_rx_resync(sc))</a>
<a name="ln3324">					dc_rxeof(sc);</a>
<a name="ln3325">			}</a>
<a name="ln3326">		}</a>
<a name="ln3327"> </a>
<a name="ln3328">		if (status &amp; (DC_ISR_TX_OK | DC_ISR_TX_NOBUF))</a>
<a name="ln3329">			dc_txeof(sc);</a>
<a name="ln3330"> </a>
<a name="ln3331">		if (status &amp; DC_ISR_TX_IDLE) {</a>
<a name="ln3332">			dc_txeof(sc);</a>
<a name="ln3333">			if (sc-&gt;dc_cdata.dc_tx_cnt) {</a>
<a name="ln3334">				DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON);</a>
<a name="ln3335">				CSR_WRITE_4(sc, DC_TXSTART, 0xFFFFFFFF);</a>
<a name="ln3336">			}</a>
<a name="ln3337">		}</a>
<a name="ln3338"> </a>
<a name="ln3339">		if (status &amp; DC_ISR_TX_UNDERRUN)</a>
<a name="ln3340">			dc_tx_underrun(sc);</a>
<a name="ln3341"> </a>
<a name="ln3342">		if ((status &amp; DC_ISR_RX_WATDOGTIMEO)</a>
<a name="ln3343">		    || (status &amp; DC_ISR_RX_NOBUF)) {</a>
<a name="ln3344">			r = CSR_READ_4(sc, DC_FRAMESDISCARDED);</a>
<a name="ln3345">			if_inc_counter(ifp, IFCOUNTER_IERRORS, (r &amp; 0xffff) + ((r &gt;&gt; 17) &amp; 0x7ff));</a>
<a name="ln3346">			if (dc_rxeof(sc) == 0) {</a>
<a name="ln3347">				while (dc_rx_resync(sc))</a>
<a name="ln3348">					dc_rxeof(sc);</a>
<a name="ln3349">			}</a>
<a name="ln3350">		}</a>
<a name="ln3351"> </a>
<a name="ln3352">		if (!IFQ_DRV_IS_EMPTY(&amp;ifp-&gt;if_snd))</a>
<a name="ln3353">			dc_start_locked(ifp);</a>
<a name="ln3354"> </a>
<a name="ln3355">		if (status &amp; DC_ISR_BUS_ERR) {</a>
<a name="ln3356">			ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_RUNNING;</a>
<a name="ln3357">			dc_init_locked(sc);</a>
<a name="ln3358">			DC_UNLOCK(sc);</a>
<a name="ln3359">			return;</a>
<a name="ln3360">		}</a>
<a name="ln3361">		status = CSR_READ_4(sc, DC_ISR);</a>
<a name="ln3362">		if (status == 0xFFFFFFFF || (status &amp; DC_INTRS) == 0)</a>
<a name="ln3363">			break;</a>
<a name="ln3364">	}</a>
<a name="ln3365"> </a>
<a name="ln3366">	/* Re-enable interrupts. */</a>
<a name="ln3367">	if (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING)</a>
<a name="ln3368">		CSR_WRITE_4(sc, DC_IMR, DC_INTRS);</a>
<a name="ln3369"> </a>
<a name="ln3370">	DC_UNLOCK(sc);</a>
<a name="ln3371">}</a>
<a name="ln3372"> </a>
<a name="ln3373">/*</a>
<a name="ln3374"> * Encapsulate an mbuf chain in a descriptor by coupling the mbuf data</a>
<a name="ln3375"> * pointers to the fragment pointers.</a>
<a name="ln3376"> */</a>
<a name="ln3377">static int</a>
<a name="ln3378">dc_encap(struct dc_softc *sc, struct mbuf **m_head)</a>
<a name="ln3379">{</a>
<a name="ln3380">	bus_dma_segment_t segs[DC_MAXFRAGS];</a>
<a name="ln3381">	bus_dmamap_t map;</a>
<a name="ln3382">	struct dc_desc *f;</a>
<a name="ln3383">	struct mbuf *m;</a>
<a name="ln3384">	int cur, defragged, error, first, frag, i, idx, nseg;</a>
<a name="ln3385"> </a>
<a name="ln3386">	m = NULL;</a>
<a name="ln3387">	defragged = 0;</a>
<a name="ln3388">	if (sc-&gt;dc_flags &amp; DC_TX_COALESCE &amp;&amp;</a>
<a name="ln3389">	    ((*m_head)-&gt;m_next != NULL || sc-&gt;dc_flags &amp; DC_TX_ALIGN)) {</a>
<a name="ln3390">		m = m_defrag(*m_head, M_NOWAIT);</a>
<a name="ln3391">		defragged = 1;</a>
<a name="ln3392">	} else {</a>
<a name="ln3393">		/*</a>
<a name="ln3394">		 * Count the number of frags in this chain to see if we</a>
<a name="ln3395">		 * need to m_collapse.  Since the descriptor list is shared</a>
<a name="ln3396">		 * by all packets, we'll m_collapse long chains so that they</a>
<a name="ln3397">		 * do not use up the entire list, even if they would fit.</a>
<a name="ln3398">		 */</a>
<a name="ln3399">		i = 0;</a>
<a name="ln3400">		for (m = *m_head; m != NULL; m = m-&gt;m_next)</a>
<a name="ln3401">			i++;</a>
<a name="ln3402">		if (i &gt; DC_TX_LIST_CNT / 4 ||</a>
<a name="ln3403">		    DC_TX_LIST_CNT - i + sc-&gt;dc_cdata.dc_tx_cnt &lt;=</a>
<a name="ln3404">		    DC_TX_LIST_RSVD) {</a>
<a name="ln3405">			m = m_collapse(*m_head, M_NOWAIT, DC_MAXFRAGS);</a>
<a name="ln3406">			defragged = 1;</a>
<a name="ln3407">		}</a>
<a name="ln3408">	}</a>
<a name="ln3409">	if (defragged != 0) {</a>
<a name="ln3410">		if (m == NULL) {</a>
<a name="ln3411">			m_freem(*m_head);</a>
<a name="ln3412">			*m_head = NULL;</a>
<a name="ln3413">			return (ENOBUFS);</a>
<a name="ln3414">		}</a>
<a name="ln3415">		*m_head = m;</a>
<a name="ln3416">	}</a>
<a name="ln3417"> </a>
<a name="ln3418">	idx = sc-&gt;dc_cdata.dc_tx_prod;</a>
<a name="ln3419">	error = bus_dmamap_load_mbuf_sg(sc-&gt;dc_tx_mtag,</a>
<a name="ln3420">	    sc-&gt;dc_cdata.dc_tx_map[idx], *m_head, segs, &amp;nseg, 0);</a>
<a name="ln3421">	if (error == EFBIG) {</a>
<a name="ln3422">		if (defragged != 0 || (m = m_collapse(*m_head, M_NOWAIT,</a>
<a name="ln3423">		    DC_MAXFRAGS)) == NULL) {</a>
<a name="ln3424">			m_freem(*m_head);</a>
<a name="ln3425">			*m_head = NULL;</a>
<a name="ln3426">			return (defragged != 0 ? error : ENOBUFS);</a>
<a name="ln3427">		}</a>
<a name="ln3428">		*m_head = m;</a>
<a name="ln3429">		error = bus_dmamap_load_mbuf_sg(sc-&gt;dc_tx_mtag,</a>
<a name="ln3430">		    sc-&gt;dc_cdata.dc_tx_map[idx], *m_head, segs, &amp;nseg, 0);</a>
<a name="ln3431">		if (error != 0) {</a>
<a name="ln3432">			m_freem(*m_head);</a>
<a name="ln3433">			*m_head = NULL;</a>
<a name="ln3434">			return (error);</a>
<a name="ln3435">		}</a>
<a name="ln3436">	} else if (error != 0)</a>
<a name="ln3437">		return (error);</a>
<a name="ln3438">	KASSERT(nseg &lt;= DC_MAXFRAGS,</a>
<a name="ln3439">	    (&quot;%s: wrong number of segments (%d)&quot;, __func__, nseg));</a>
<a name="ln3440">	if (nseg == 0) {</a>
<a name="ln3441">		m_freem(*m_head);</a>
<a name="ln3442">		*m_head = NULL;</a>
<a name="ln3443">		return (EIO);</a>
<a name="ln3444">	}</a>
<a name="ln3445"> </a>
<a name="ln3446">	/* Check descriptor overruns. */</a>
<a name="ln3447">	if (sc-&gt;dc_cdata.dc_tx_cnt + nseg &gt; DC_TX_LIST_CNT - DC_TX_LIST_RSVD) {</a>
<a name="ln3448">		bus_dmamap_unload(sc-&gt;dc_tx_mtag, sc-&gt;dc_cdata.dc_tx_map[idx]);</a>
<a name="ln3449">		return (ENOBUFS);</a>
<a name="ln3450">	}</a>
<a name="ln3451">	bus_dmamap_sync(sc-&gt;dc_tx_mtag, sc-&gt;dc_cdata.dc_tx_map[idx],</a>
<a name="ln3452">	    BUS_DMASYNC_PREWRITE);</a>
<a name="ln3453"> </a>
<a name="ln3454">	first = cur = frag = sc-&gt;dc_cdata.dc_tx_prod;</a>
<a name="ln3455">	for (i = 0; i &lt; nseg; i++) {</a>
<a name="ln3456">		if ((sc-&gt;dc_flags &amp; DC_TX_ADMTEK_WAR) &amp;&amp;</a>
<a name="ln3457">		    (frag == (DC_TX_LIST_CNT - 1)) &amp;&amp;</a>
<a name="ln3458">		    (first != sc-&gt;dc_cdata.dc_tx_first)) {</a>
<a name="ln3459">			bus_dmamap_unload(sc-&gt;dc_tx_mtag,</a>
<a name="ln3460">			    sc-&gt;dc_cdata.dc_tx_map[first]);</a>
<a name="ln3461">			m_freem(*m_head);</a>
<a name="ln3462">			*m_head = NULL;</a>
<a name="ln3463">			return (ENOBUFS);</a>
<a name="ln3464">		}</a>
<a name="ln3465"> </a>
<a name="ln3466">		f = &amp;sc-&gt;dc_ldata.dc_tx_list[frag];</a>
<a name="ln3467">		f-&gt;dc_ctl = htole32(DC_TXCTL_TLINK | segs[i].ds_len);</a>
<a name="ln3468">		if (i == 0) {</a>
<a name="ln3469">			f-&gt;dc_status = 0;</a>
<a name="ln3470">			f-&gt;dc_ctl |= htole32(DC_TXCTL_FIRSTFRAG);</a>
<a name="ln3471">		} else</a>
<a name="ln3472">			f-&gt;dc_status = htole32(DC_TXSTAT_OWN);</a>
<a name="ln3473">		f-&gt;dc_data = htole32(DC_ADDR_LO(segs[i].ds_addr));</a>
<a name="ln3474">		cur = frag;</a>
<a name="ln3475">		DC_INC(frag, DC_TX_LIST_CNT);</a>
<a name="ln3476">	}</a>
<a name="ln3477"> </a>
<a name="ln3478">	sc-&gt;dc_cdata.dc_tx_prod = frag;</a>
<a name="ln3479">	sc-&gt;dc_cdata.dc_tx_cnt += nseg;</a>
<a name="ln3480">	sc-&gt;dc_cdata.dc_tx_chain[cur] = *m_head;</a>
<a name="ln3481">	sc-&gt;dc_ldata.dc_tx_list[cur].dc_ctl |= htole32(DC_TXCTL_LASTFRAG);</a>
<a name="ln3482">	if (sc-&gt;dc_flags &amp; DC_TX_INTR_FIRSTFRAG)</a>
<a name="ln3483">		sc-&gt;dc_ldata.dc_tx_list[first].dc_ctl |=</a>
<a name="ln3484">		    htole32(DC_TXCTL_FINT);</a>
<a name="ln3485">	if (sc-&gt;dc_flags &amp; DC_TX_INTR_ALWAYS)</a>
<a name="ln3486">		sc-&gt;dc_ldata.dc_tx_list[cur].dc_ctl |= htole32(DC_TXCTL_FINT);</a>
<a name="ln3487">	if (sc-&gt;dc_flags &amp; DC_TX_USE_TX_INTR &amp;&amp;</a>
<a name="ln3488">	    ++sc-&gt;dc_cdata.dc_tx_pkts &gt;= 8) {</a>
<a name="ln3489">		sc-&gt;dc_cdata.dc_tx_pkts = 0;</a>
<a name="ln3490">		sc-&gt;dc_ldata.dc_tx_list[cur].dc_ctl |= htole32(DC_TXCTL_FINT);</a>
<a name="ln3491">	}</a>
<a name="ln3492">	sc-&gt;dc_ldata.dc_tx_list[first].dc_status = htole32(DC_TXSTAT_OWN);</a>
<a name="ln3493"> </a>
<a name="ln3494">	bus_dmamap_sync(sc-&gt;dc_tx_ltag, sc-&gt;dc_tx_lmap,</a>
<a name="ln3495">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln3496"> </a>
<a name="ln3497">	/*</a>
<a name="ln3498">	 * Swap the last and the first dmamaps to ensure the map for</a>
<a name="ln3499">	 * this transmission is placed at the last descriptor.</a>
<a name="ln3500">	 */</a>
<a name="ln3501">	map = sc-&gt;dc_cdata.dc_tx_map[cur];</a>
<a name="ln3502">	sc-&gt;dc_cdata.dc_tx_map[cur] = sc-&gt;dc_cdata.dc_tx_map[first];</a>
<a name="ln3503">	sc-&gt;dc_cdata.dc_tx_map[first] = map;</a>
<a name="ln3504"> </a>
<a name="ln3505">	return (0);</a>
<a name="ln3506">}</a>
<a name="ln3507"> </a>
<a name="ln3508">static void</a>
<a name="ln3509">dc_start(struct ifnet *ifp)</a>
<a name="ln3510">{</a>
<a name="ln3511">	struct dc_softc *sc;</a>
<a name="ln3512"> </a>
<a name="ln3513">	sc = ifp-&gt;if_softc;</a>
<a name="ln3514">	DC_LOCK(sc);</a>
<a name="ln3515">	dc_start_locked(ifp);</a>
<a name="ln3516">	DC_UNLOCK(sc);</a>
<a name="ln3517">}</a>
<a name="ln3518"> </a>
<a name="ln3519">/*</a>
<a name="ln3520"> * Main transmit routine</a>
<a name="ln3521"> * To avoid having to do mbuf copies, we put pointers to the mbuf data</a>
<a name="ln3522"> * regions directly in the transmit lists.  We also save a copy of the</a>
<a name="ln3523"> * pointers since the transmit list fragment pointers are physical</a>
<a name="ln3524"> * addresses.</a>
<a name="ln3525"> */</a>
<a name="ln3526">static void</a>
<a name="ln3527">dc_start_locked(struct ifnet *ifp)</a>
<a name="ln3528">{</a>
<a name="ln3529">	struct dc_softc *sc;</a>
<a name="ln3530">	struct mbuf *m_head;</a>
<a name="ln3531">	int queued;</a>
<a name="ln3532"> </a>
<a name="ln3533">	sc = ifp-&gt;if_softc;</a>
<a name="ln3534"> </a>
<a name="ln3535">	DC_LOCK_ASSERT(sc);</a>
<a name="ln3536"> </a>
<a name="ln3537">	if ((ifp-&gt;if_drv_flags &amp; (IFF_DRV_RUNNING | IFF_DRV_OACTIVE)) !=</a>
<a name="ln3538">	    IFF_DRV_RUNNING || sc-&gt;dc_link == 0)</a>
<a name="ln3539">		return;</a>
<a name="ln3540"> </a>
<a name="ln3541">	sc-&gt;dc_cdata.dc_tx_first = sc-&gt;dc_cdata.dc_tx_prod;</a>
<a name="ln3542"> </a>
<a name="ln3543">	for (queued = 0; !IFQ_DRV_IS_EMPTY(&amp;ifp-&gt;if_snd); ) {</a>
<a name="ln3544">		/*</a>
<a name="ln3545">		 * If there's no way we can send any packets, return now.</a>
<a name="ln3546">		 */</a>
<a name="ln3547">		if (sc-&gt;dc_cdata.dc_tx_cnt &gt; DC_TX_LIST_CNT - DC_TX_LIST_RSVD) {</a>
<a name="ln3548">			ifp-&gt;if_drv_flags |= IFF_DRV_OACTIVE;</a>
<a name="ln3549">			break;</a>
<a name="ln3550">		}</a>
<a name="ln3551">		IFQ_DRV_DEQUEUE(&amp;ifp-&gt;if_snd, m_head);</a>
<a name="ln3552">		if (m_head == NULL)</a>
<a name="ln3553">			break;</a>
<a name="ln3554"> </a>
<a name="ln3555">		if (dc_encap(sc, &amp;m_head)) {</a>
<a name="ln3556">			if (m_head == NULL)</a>
<a name="ln3557">				break;</a>
<a name="ln3558">			IFQ_DRV_PREPEND(&amp;ifp-&gt;if_snd, m_head);</a>
<a name="ln3559">			ifp-&gt;if_drv_flags |= IFF_DRV_OACTIVE;</a>
<a name="ln3560">			break;</a>
<a name="ln3561">		}</a>
<a name="ln3562"> </a>
<a name="ln3563">		queued++;</a>
<a name="ln3564">		/*</a>
<a name="ln3565">		 * If there's a BPF listener, bounce a copy of this frame</a>
<a name="ln3566">		 * to him.</a>
<a name="ln3567">		 */</a>
<a name="ln3568">		BPF_MTAP(ifp, m_head);</a>
<a name="ln3569">	}</a>
<a name="ln3570"> </a>
<a name="ln3571">	if (queued &gt; 0) {</a>
<a name="ln3572">		/* Transmit */</a>
<a name="ln3573">		if (!(sc-&gt;dc_flags &amp; DC_TX_POLL))</a>
<a name="ln3574">			CSR_WRITE_4(sc, DC_TXSTART, 0xFFFFFFFF);</a>
<a name="ln3575"> </a>
<a name="ln3576">		/*</a>
<a name="ln3577">		 * Set a timeout in case the chip goes out to lunch.</a>
<a name="ln3578">		 */</a>
<a name="ln3579">		sc-&gt;dc_wdog_timer = 5;</a>
<a name="ln3580">	}</a>
<a name="ln3581">}</a>
<a name="ln3582"> </a>
<a name="ln3583">static void</a>
<a name="ln3584">dc_init(void *xsc)</a>
<a name="ln3585">{</a>
<a name="ln3586">	struct dc_softc *sc = xsc;</a>
<a name="ln3587"> </a>
<a name="ln3588">	DC_LOCK(sc);</a>
<a name="ln3589">	dc_init_locked(sc);</a>
<a name="ln3590">	DC_UNLOCK(sc);</a>
<a name="ln3591">}</a>
<a name="ln3592"> </a>
<a name="ln3593">static void</a>
<a name="ln3594">dc_init_locked(struct dc_softc *sc)</a>
<a name="ln3595">{</a>
<a name="ln3596">	struct ifnet *ifp = sc-&gt;dc_ifp;</a>
<a name="ln3597">	struct mii_data *mii;</a>
<a name="ln3598">	struct ifmedia *ifm;</a>
<a name="ln3599"> </a>
<a name="ln3600">	DC_LOCK_ASSERT(sc);</a>
<a name="ln3601"> </a>
<a name="ln3602">	if ((ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) != 0)</a>
<a name="ln3603">		return;</a>
<a name="ln3604"> </a>
<a name="ln3605">	mii = device_get_softc(sc-&gt;dc_miibus);</a>
<a name="ln3606"> </a>
<a name="ln3607">	/*</a>
<a name="ln3608">	 * Cancel pending I/O and free all RX/TX buffers.</a>
<a name="ln3609">	 */</a>
<a name="ln3610">	dc_stop(sc);</a>
<a name="ln3611">	dc_reset(sc);</a>
<a name="ln3612">	if (DC_IS_INTEL(sc)) {</a>
<a name="ln3613">		ifm = &amp;mii-&gt;mii_media;</a>
<a name="ln3614">		dc_apply_fixup(sc, ifm-&gt;ifm_media);</a>
<a name="ln3615">	}</a>
<a name="ln3616"> </a>
<a name="ln3617">	/*</a>
<a name="ln3618">	 * Set cache alignment and burst length.</a>
<a name="ln3619">	 */</a>
<a name="ln3620">	if (DC_IS_ASIX(sc) || DC_IS_DAVICOM(sc) || DC_IS_ULI(sc))</a>
<a name="ln3621">		CSR_WRITE_4(sc, DC_BUSCTL, 0);</a>
<a name="ln3622">	else</a>
<a name="ln3623">		CSR_WRITE_4(sc, DC_BUSCTL, DC_BUSCTL_MRME | DC_BUSCTL_MRLE);</a>
<a name="ln3624">	/*</a>
<a name="ln3625">	 * Evenly share the bus between receive and transmit process.</a>
<a name="ln3626">	 */</a>
<a name="ln3627">	if (DC_IS_INTEL(sc))</a>
<a name="ln3628">		DC_SETBIT(sc, DC_BUSCTL, DC_BUSCTL_ARBITRATION);</a>
<a name="ln3629">	if (DC_IS_DAVICOM(sc) || DC_IS_INTEL(sc)) {</a>
<a name="ln3630">		DC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_USECA);</a>
<a name="ln3631">	} else {</a>
<a name="ln3632">		DC_SETBIT(sc, DC_BUSCTL, DC_BURSTLEN_16LONG);</a>
<a name="ln3633">	}</a>
<a name="ln3634">	if (sc-&gt;dc_flags &amp; DC_TX_POLL)</a>
<a name="ln3635">		DC_SETBIT(sc, DC_BUSCTL, DC_TXPOLL_1);</a>
<a name="ln3636">	switch(sc-&gt;dc_cachesize) {</a>
<a name="ln3637">	case 32:</a>
<a name="ln3638">		DC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_32LONG);</a>
<a name="ln3639">		break;</a>
<a name="ln3640">	case 16:</a>
<a name="ln3641">		DC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_16LONG);</a>
<a name="ln3642">		break;</a>
<a name="ln3643">	case 8:</a>
<a name="ln3644">		DC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_8LONG);</a>
<a name="ln3645">		break;</a>
<a name="ln3646">	case 0:</a>
<a name="ln3647">	default:</a>
<a name="ln3648">		DC_SETBIT(sc, DC_BUSCTL, DC_CACHEALIGN_NONE);</a>
<a name="ln3649">		break;</a>
<a name="ln3650">	}</a>
<a name="ln3651"> </a>
<a name="ln3652">	if (sc-&gt;dc_flags &amp; DC_TX_STORENFWD)</a>
<a name="ln3653">		DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);</a>
<a name="ln3654">	else {</a>
<a name="ln3655">		if (sc-&gt;dc_txthresh &gt; DC_TXTHRESH_MAX) {</a>
<a name="ln3656">			DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);</a>
<a name="ln3657">		} else {</a>
<a name="ln3658">			DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_STORENFWD);</a>
<a name="ln3659">			DC_SETBIT(sc, DC_NETCFG, sc-&gt;dc_txthresh);</a>
<a name="ln3660">		}</a>
<a name="ln3661">	}</a>
<a name="ln3662"> </a>
<a name="ln3663">	DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_NO_RXCRC);</a>
<a name="ln3664">	DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_BACKOFF);</a>
<a name="ln3665"> </a>
<a name="ln3666">	if (DC_IS_MACRONIX(sc) || DC_IS_PNICII(sc)) {</a>
<a name="ln3667">		/*</a>
<a name="ln3668">		 * The app notes for the 98713 and 98715A say that</a>
<a name="ln3669">		 * in order to have the chips operate properly, a magic</a>
<a name="ln3670">		 * number must be written to CSR16. Macronix does not</a>
<a name="ln3671">		 * document the meaning of these bits so there's no way</a>
<a name="ln3672">		 * to know exactly what they do. The 98713 has a magic</a>
<a name="ln3673">		 * number all its own; the rest all use a different one.</a>
<a name="ln3674">		 */</a>
<a name="ln3675">		DC_CLRBIT(sc, DC_MX_MAGICPACKET, 0xFFFF0000);</a>
<a name="ln3676">		if (sc-&gt;dc_type == DC_TYPE_98713)</a>
<a name="ln3677">			DC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98713);</a>
<a name="ln3678">		else</a>
<a name="ln3679">			DC_SETBIT(sc, DC_MX_MAGICPACKET, DC_MX_MAGIC_98715);</a>
<a name="ln3680">	}</a>
<a name="ln3681"> </a>
<a name="ln3682">	if (DC_IS_XIRCOM(sc)) {</a>
<a name="ln3683">		/*</a>
<a name="ln3684">		 * setup General Purpose Port mode and data so the tulip</a>
<a name="ln3685">		 * can talk to the MII.</a>
<a name="ln3686">		 */</a>
<a name="ln3687">		CSR_WRITE_4(sc, DC_SIAGP, DC_SIAGP_WRITE_EN | DC_SIAGP_INT1_EN |</a>
<a name="ln3688">			   DC_SIAGP_MD_GP2_OUTPUT | DC_SIAGP_MD_GP0_OUTPUT);</a>
<a name="ln3689">		DELAY(10);</a>
<a name="ln3690">		CSR_WRITE_4(sc, DC_SIAGP, DC_SIAGP_INT1_EN |</a>
<a name="ln3691">			   DC_SIAGP_MD_GP2_OUTPUT | DC_SIAGP_MD_GP0_OUTPUT);</a>
<a name="ln3692">		DELAY(10);</a>
<a name="ln3693">	}</a>
<a name="ln3694"> </a>
<a name="ln3695">	DC_CLRBIT(sc, DC_NETCFG, DC_NETCFG_TX_THRESH);</a>
<a name="ln3696">	DC_SETBIT(sc, DC_NETCFG, DC_TXTHRESH_MIN);</a>
<a name="ln3697"> </a>
<a name="ln3698">	/* Init circular RX list. */</a>
<a name="ln3699">	if (dc_list_rx_init(sc) == ENOBUFS) {</a>
<a name="ln3700">		device_printf(sc-&gt;dc_dev,</a>
<a name="ln3701">		    &quot;initialization failed: no memory for rx buffers\n&quot;);</a>
<a name="ln3702">		dc_stop(sc);</a>
<a name="ln3703">		return;</a>
<a name="ln3704">	}</a>
<a name="ln3705"> </a>
<a name="ln3706">	/*</a>
<a name="ln3707">	 * Init TX descriptors.</a>
<a name="ln3708">	 */</a>
<a name="ln3709">	dc_list_tx_init(sc);</a>
<a name="ln3710"> </a>
<a name="ln3711">	/*</a>
<a name="ln3712">	 * Load the address of the RX list.</a>
<a name="ln3713">	 */</a>
<a name="ln3714">	CSR_WRITE_4(sc, DC_RXADDR, DC_RXDESC(sc, 0));</a>
<a name="ln3715">	CSR_WRITE_4(sc, DC_TXADDR, DC_TXDESC(sc, 0));</a>
<a name="ln3716"> </a>
<a name="ln3717">	/*</a>
<a name="ln3718">	 * Enable interrupts.</a>
<a name="ln3719">	 */</a>
<a name="ln3720">#ifdef DEVICE_POLLING</a>
<a name="ln3721">	/*</a>
<a name="ln3722">	 * ... but only if we are not polling, and make sure they are off in</a>
<a name="ln3723">	 * the case of polling. Some cards (e.g. fxp) turn interrupts on</a>
<a name="ln3724">	 * after a reset.</a>
<a name="ln3725">	 */</a>
<a name="ln3726">	if (ifp-&gt;if_capenable &amp; IFCAP_POLLING)</a>
<a name="ln3727">		CSR_WRITE_4(sc, DC_IMR, 0x00000000);</a>
<a name="ln3728">	else</a>
<a name="ln3729">#endif</a>
<a name="ln3730">	CSR_WRITE_4(sc, DC_IMR, DC_INTRS);</a>
<a name="ln3731">	CSR_WRITE_4(sc, DC_ISR, 0xFFFFFFFF);</a>
<a name="ln3732"> </a>
<a name="ln3733">	/* Initialize TX jabber and RX watchdog timer. */</a>
<a name="ln3734">	if (DC_IS_ULI(sc))</a>
<a name="ln3735">		CSR_WRITE_4(sc, DC_WATCHDOG, DC_WDOG_JABBERCLK |</a>
<a name="ln3736">		    DC_WDOG_HOSTUNJAB);</a>
<a name="ln3737"> </a>
<a name="ln3738">	/* Enable transmitter. */</a>
<a name="ln3739">	DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_TX_ON);</a>
<a name="ln3740"> </a>
<a name="ln3741">	/*</a>
<a name="ln3742">	 * If this is an Intel 21143 and we're not using the</a>
<a name="ln3743">	 * MII port, program the LED control pins so we get</a>
<a name="ln3744">	 * link and activity indications.</a>
<a name="ln3745">	 */</a>
<a name="ln3746">	if (sc-&gt;dc_flags &amp; DC_TULIP_LEDS) {</a>
<a name="ln3747">		CSR_WRITE_4(sc, DC_WATCHDOG,</a>
<a name="ln3748">		    DC_WDOG_CTLWREN | DC_WDOG_LINK | DC_WDOG_ACTIVITY);</a>
<a name="ln3749">		CSR_WRITE_4(sc, DC_WATCHDOG, 0);</a>
<a name="ln3750">	}</a>
<a name="ln3751"> </a>
<a name="ln3752">	/*</a>
<a name="ln3753">	 * Load the RX/multicast filter. We do this sort of late</a>
<a name="ln3754">	 * because the filter programming scheme on the 21143 and</a>
<a name="ln3755">	 * some clones requires DMAing a setup frame via the TX</a>
<a name="ln3756">	 * engine, and we need the transmitter enabled for that.</a>
<a name="ln3757">	 */</a>
<a name="ln3758">	dc_setfilt(sc);</a>
<a name="ln3759"> </a>
<a name="ln3760">	/* Enable receiver. */</a>
<a name="ln3761">	DC_SETBIT(sc, DC_NETCFG, DC_NETCFG_RX_ON);</a>
<a name="ln3762">	CSR_WRITE_4(sc, DC_RXSTART, 0xFFFFFFFF);</a>
<a name="ln3763"> </a>
<a name="ln3764">	ifp-&gt;if_drv_flags |= IFF_DRV_RUNNING;</a>
<a name="ln3765">	ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_OACTIVE;</a>
<a name="ln3766"> </a>
<a name="ln3767">	dc_ifmedia_upd_locked(sc);</a>
<a name="ln3768"> </a>
<a name="ln3769">	/* Clear missed frames and overflow counter. */</a>
<a name="ln3770">	CSR_READ_4(sc, DC_FRAMESDISCARDED);</a>
<a name="ln3771"> </a>
<a name="ln3772">	/* Don't start the ticker if this is a homePNA link. */</a>
<a name="ln3773">	if (IFM_SUBTYPE(mii-&gt;mii_media.ifm_media) == IFM_HPNA_1)</a>
<a name="ln3774">		sc-&gt;dc_link = 1;</a>
<a name="ln3775">	else {</a>
<a name="ln3776">		if (sc-&gt;dc_flags &amp; DC_21143_NWAY)</a>
<a name="ln3777">			callout_reset(&amp;sc-&gt;dc_stat_ch, hz/10, dc_tick, sc);</a>
<a name="ln3778">		else</a>
<a name="ln3779">			callout_reset(&amp;sc-&gt;dc_stat_ch, hz, dc_tick, sc);</a>
<a name="ln3780">	}</a>
<a name="ln3781"> </a>
<a name="ln3782">	sc-&gt;dc_wdog_timer = 0;</a>
<a name="ln3783">	callout_reset(&amp;sc-&gt;dc_wdog_ch, hz, dc_watchdog, sc);</a>
<a name="ln3784">}</a>
<a name="ln3785"> </a>
<a name="ln3786">/*</a>
<a name="ln3787"> * Set media options.</a>
<a name="ln3788"> */</a>
<a name="ln3789">static int</a>
<a name="ln3790">dc_ifmedia_upd(struct ifnet *ifp)</a>
<a name="ln3791">{</a>
<a name="ln3792">	struct dc_softc *sc;</a>
<a name="ln3793">	int error;</a>
<a name="ln3794"> </a>
<a name="ln3795">	sc = ifp-&gt;if_softc;</a>
<a name="ln3796">	DC_LOCK(sc);</a>
<a name="ln3797">	error = dc_ifmedia_upd_locked(sc);</a>
<a name="ln3798">	DC_UNLOCK(sc);</a>
<a name="ln3799">	return (error);</a>
<a name="ln3800">}</a>
<a name="ln3801"> </a>
<a name="ln3802">static int</a>
<a name="ln3803">dc_ifmedia_upd_locked(struct dc_softc *sc)</a>
<a name="ln3804">{</a>
<a name="ln3805">	struct mii_data *mii;</a>
<a name="ln3806">	struct ifmedia *ifm;</a>
<a name="ln3807">	int error;</a>
<a name="ln3808"> </a>
<a name="ln3809">	DC_LOCK_ASSERT(sc);</a>
<a name="ln3810"> </a>
<a name="ln3811">	sc-&gt;dc_link = 0;</a>
<a name="ln3812">	mii = device_get_softc(sc-&gt;dc_miibus);</a>
<a name="ln3813">	error = mii_mediachg(mii);</a>
<a name="ln3814">	if (error == 0) {</a>
<a name="ln3815">		ifm = &amp;mii-&gt;mii_media;</a>
<a name="ln3816">		if (DC_IS_INTEL(sc))</a>
<a name="ln3817">			dc_setcfg(sc, ifm-&gt;ifm_media);</a>
<a name="ln3818">		else if (DC_IS_DAVICOM(sc) &amp;&amp;</a>
<a name="ln3819">		    IFM_SUBTYPE(ifm-&gt;ifm_media) == IFM_HPNA_1)</a>
<a name="ln3820">			dc_setcfg(sc, ifm-&gt;ifm_media);</a>
<a name="ln3821">	}</a>
<a name="ln3822"> </a>
<a name="ln3823">	return (error);</a>
<a name="ln3824">}</a>
<a name="ln3825"> </a>
<a name="ln3826">/*</a>
<a name="ln3827"> * Report current media status.</a>
<a name="ln3828"> */</a>
<a name="ln3829">static void</a>
<a name="ln3830">dc_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)</a>
<a name="ln3831">{</a>
<a name="ln3832">	struct dc_softc *sc;</a>
<a name="ln3833">	struct mii_data *mii;</a>
<a name="ln3834">	struct ifmedia *ifm;</a>
<a name="ln3835"> </a>
<a name="ln3836">	sc = ifp-&gt;if_softc;</a>
<a name="ln3837">	mii = device_get_softc(sc-&gt;dc_miibus);</a>
<a name="ln3838">	DC_LOCK(sc);</a>
<a name="ln3839">	mii_pollstat(mii);</a>
<a name="ln3840">	ifm = &amp;mii-&gt;mii_media;</a>
<a name="ln3841">	if (DC_IS_DAVICOM(sc)) {</a>
<a name="ln3842">		if (IFM_SUBTYPE(ifm-&gt;ifm_media) == IFM_HPNA_1) {</a>
<a name="ln3843">			ifmr-&gt;ifm_active = ifm-&gt;ifm_media;</a>
<a name="ln3844">			ifmr-&gt;ifm_status = 0;</a>
<a name="ln3845">			DC_UNLOCK(sc);</a>
<a name="ln3846">			return;</a>
<a name="ln3847">		}</a>
<a name="ln3848">	}</a>
<a name="ln3849">	ifmr-&gt;ifm_active = mii-&gt;mii_media_active;</a>
<a name="ln3850">	ifmr-&gt;ifm_status = mii-&gt;mii_media_status;</a>
<a name="ln3851">	DC_UNLOCK(sc);</a>
<a name="ln3852">}</a>
<a name="ln3853"> </a>
<a name="ln3854">static int</a>
<a name="ln3855">dc_ioctl(struct ifnet *ifp, u_long command, caddr_t data)</a>
<a name="ln3856">{</a>
<a name="ln3857">	struct dc_softc *sc = ifp-&gt;if_softc;</a>
<a name="ln3858">	struct ifreq *ifr = (struct ifreq *)data;</a>
<a name="ln3859">	struct mii_data *mii;</a>
<a name="ln3860">	int error = 0;</a>
<a name="ln3861"> </a>
<a name="ln3862">	switch (command) {</a>
<a name="ln3863">	case SIOCSIFFLAGS:</a>
<a name="ln3864">		DC_LOCK(sc);</a>
<a name="ln3865">		if (ifp-&gt;if_flags &amp; IFF_UP) {</a>
<a name="ln3866">			int need_setfilt = (ifp-&gt;if_flags ^ sc-&gt;dc_if_flags) &amp;</a>
<a name="ln3867">				(IFF_PROMISC | IFF_ALLMULTI);</a>
<a name="ln3868"> </a>
<a name="ln3869">			if (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING) {</a>
<a name="ln3870">				if (need_setfilt)</a>
<a name="ln3871">					dc_setfilt(sc);</a>
<a name="ln3872">			} else {</a>
<a name="ln3873">				ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_RUNNING;</a>
<a name="ln3874">				dc_init_locked(sc);</a>
<a name="ln3875">			}</a>
<a name="ln3876">		} else {</a>
<a name="ln3877">			if (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING)</a>
<a name="ln3878">				dc_stop(sc);</a>
<a name="ln3879">		}</a>
<a name="ln3880">		sc-&gt;dc_if_flags = ifp-&gt;if_flags;</a>
<a name="ln3881">		DC_UNLOCK(sc);</a>
<a name="ln3882">		break;</a>
<a name="ln3883">	case SIOCADDMULTI:</a>
<a name="ln3884">	case SIOCDELMULTI:</a>
<a name="ln3885">		DC_LOCK(sc);</a>
<a name="ln3886">		if (ifp-&gt;if_drv_flags &amp; IFF_DRV_RUNNING)</a>
<a name="ln3887">			dc_setfilt(sc);</a>
<a name="ln3888">		DC_UNLOCK(sc);</a>
<a name="ln3889">		break;</a>
<a name="ln3890">	case SIOCGIFMEDIA:</a>
<a name="ln3891">	case SIOCSIFMEDIA:</a>
<a name="ln3892">		mii = device_get_softc(sc-&gt;dc_miibus);</a>
<a name="ln3893">		error = ifmedia_ioctl(ifp, ifr, &amp;mii-&gt;mii_media, command);</a>
<a name="ln3894">		break;</a>
<a name="ln3895">	case SIOCSIFCAP:</a>
<a name="ln3896">#ifdef DEVICE_POLLING</a>
<a name="ln3897">		if (ifr-&gt;ifr_reqcap &amp; IFCAP_POLLING &amp;&amp;</a>
<a name="ln3898">		    !(ifp-&gt;if_capenable &amp; IFCAP_POLLING)) {</a>
<a name="ln3899">			error = ether_poll_register(dc_poll, ifp);</a>
<a name="ln3900">			if (error)</a>
<a name="ln3901">				return(error);</a>
<a name="ln3902">			DC_LOCK(sc);</a>
<a name="ln3903">			/* Disable interrupts */</a>
<a name="ln3904">			CSR_WRITE_4(sc, DC_IMR, 0x00000000);</a>
<a name="ln3905">			ifp-&gt;if_capenable |= IFCAP_POLLING;</a>
<a name="ln3906">			DC_UNLOCK(sc);</a>
<a name="ln3907">			return (error);</a>
<a name="ln3908">		}</a>
<a name="ln3909">		if (!(ifr-&gt;ifr_reqcap &amp; IFCAP_POLLING) &amp;&amp;</a>
<a name="ln3910">		    ifp-&gt;if_capenable &amp; IFCAP_POLLING) {</a>
<a name="ln3911">			error = ether_poll_deregister(ifp);</a>
<a name="ln3912">			/* Enable interrupts. */</a>
<a name="ln3913">			DC_LOCK(sc);</a>
<a name="ln3914">			CSR_WRITE_4(sc, DC_IMR, DC_INTRS);</a>
<a name="ln3915">			ifp-&gt;if_capenable &amp;= ~IFCAP_POLLING;</a>
<a name="ln3916">			DC_UNLOCK(sc);</a>
<a name="ln3917">			return (error);</a>
<a name="ln3918">		}</a>
<a name="ln3919">#endif /* DEVICE_POLLING */</a>
<a name="ln3920">		break;</a>
<a name="ln3921">	default:</a>
<a name="ln3922">		error = ether_ioctl(ifp, command, data);</a>
<a name="ln3923">		break;</a>
<a name="ln3924">	}</a>
<a name="ln3925"> </a>
<a name="ln3926">	return (error);</a>
<a name="ln3927">}</a>
<a name="ln3928"> </a>
<a name="ln3929">static void</a>
<a name="ln3930">dc_watchdog(void *xsc)</a>
<a name="ln3931">{</a>
<a name="ln3932">	struct dc_softc *sc = xsc;</a>
<a name="ln3933">	struct ifnet *ifp;</a>
<a name="ln3934"> </a>
<a name="ln3935">	DC_LOCK_ASSERT(sc);</a>
<a name="ln3936"> </a>
<a name="ln3937">	if (sc-&gt;dc_wdog_timer == 0 || --sc-&gt;dc_wdog_timer != 0) {</a>
<a name="ln3938">		callout_reset(&amp;sc-&gt;dc_wdog_ch, hz, dc_watchdog, sc);</a>
<a name="ln3939">		return;</a>
<a name="ln3940">	}</a>
<a name="ln3941"> </a>
<a name="ln3942">	ifp = sc-&gt;dc_ifp;</a>
<a name="ln3943">	if_inc_counter(ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln3944">	device_printf(sc-&gt;dc_dev, &quot;watchdog timeout\n&quot;);</a>
<a name="ln3945"> </a>
<a name="ln3946">	ifp-&gt;if_drv_flags &amp;= ~IFF_DRV_RUNNING;</a>
<a name="ln3947">	dc_init_locked(sc);</a>
<a name="ln3948"> </a>
<a name="ln3949">	if (!IFQ_DRV_IS_EMPTY(&amp;ifp-&gt;if_snd))</a>
<a name="ln3950">		dc_start_locked(ifp);</a>
<a name="ln3951">}</a>
<a name="ln3952"> </a>
<a name="ln3953">/*</a>
<a name="ln3954"> * Stop the adapter and free any mbufs allocated to the</a>
<a name="ln3955"> * RX and TX lists.</a>
<a name="ln3956"> */</a>
<a name="ln3957">static void</a>
<a name="ln3958">dc_stop(struct dc_softc *sc)</a>
<a name="ln3959">{</a>
<a name="ln3960">	struct ifnet *ifp;</a>
<a name="ln3961">	struct dc_list_data *ld;</a>
<a name="ln3962">	struct dc_chain_data *cd;</a>
<a name="ln3963">	int i;</a>
<a name="ln3964">	uint32_t ctl, netcfg;</a>
<a name="ln3965"> </a>
<a name="ln3966">	DC_LOCK_ASSERT(sc);</a>
<a name="ln3967"> </a>
<a name="ln3968">	ifp = sc-&gt;dc_ifp;</a>
<a name="ln3969">	ld = &amp;sc-&gt;dc_ldata;</a>
<a name="ln3970">	cd = &amp;sc-&gt;dc_cdata;</a>
<a name="ln3971"> </a>
<a name="ln3972">	callout_stop(&amp;sc-&gt;dc_stat_ch);</a>
<a name="ln3973">	callout_stop(&amp;sc-&gt;dc_wdog_ch);</a>
<a name="ln3974">	sc-&gt;dc_wdog_timer = 0;</a>
<a name="ln3975">	sc-&gt;dc_link = 0;</a>
<a name="ln3976"> </a>
<a name="ln3977">	ifp-&gt;if_drv_flags &amp;= ~(IFF_DRV_RUNNING | IFF_DRV_OACTIVE);</a>
<a name="ln3978"> </a>
<a name="ln3979">	netcfg = CSR_READ_4(sc, DC_NETCFG);</a>
<a name="ln3980">	if (netcfg &amp; (DC_NETCFG_RX_ON | DC_NETCFG_TX_ON))</a>
<a name="ln3981">		CSR_WRITE_4(sc, DC_NETCFG,</a>
<a name="ln3982">		   netcfg &amp; ~(DC_NETCFG_RX_ON | DC_NETCFG_TX_ON));</a>
<a name="ln3983">	CSR_WRITE_4(sc, DC_IMR, 0x00000000);</a>
<a name="ln3984">	/* Wait the completion of TX/RX SM. */</a>
<a name="ln3985">	if (netcfg &amp; (DC_NETCFG_RX_ON | DC_NETCFG_TX_ON))</a>
<a name="ln3986">		dc_netcfg_wait(sc);</a>
<a name="ln3987"> </a>
<a name="ln3988">	CSR_WRITE_4(sc, DC_TXADDR, 0x00000000);</a>
<a name="ln3989">	CSR_WRITE_4(sc, DC_RXADDR, 0x00000000);</a>
<a name="ln3990"> </a>
<a name="ln3991">	/*</a>
<a name="ln3992">	 * Free data in the RX lists.</a>
<a name="ln3993">	 */</a>
<a name="ln3994">	for (i = 0; i &lt; DC_RX_LIST_CNT; i++) {</a>
<a name="ln3995">		if (cd-&gt;dc_rx_chain[i] != NULL) {</a>
<a name="ln3996">			bus_dmamap_sync(sc-&gt;dc_rx_mtag,</a>
<a name="ln3997">			    cd-&gt;dc_rx_map[i], BUS_DMASYNC_POSTREAD);</a>
<a name="ln3998">			bus_dmamap_unload(sc-&gt;dc_rx_mtag,</a>
<a name="ln3999">			    cd-&gt;dc_rx_map[i]);</a>
<a name="ln4000">			m_freem(cd-&gt;dc_rx_chain[i]);</a>
<a name="ln4001">			cd-&gt;dc_rx_chain[i] = NULL;</a>
<a name="ln4002">		}</a>
<a name="ln4003">	}</a>
<a name="ln4004">	bzero(ld-&gt;dc_rx_list, DC_RX_LIST_SZ);</a>
<a name="ln4005">	bus_dmamap_sync(sc-&gt;dc_rx_ltag, sc-&gt;dc_rx_lmap,</a>
<a name="ln4006">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln4007"> </a>
<a name="ln4008">	/*</a>
<a name="ln4009">	 * Free the TX list buffers.</a>
<a name="ln4010">	 */</a>
<a name="ln4011">	for (i = 0; i &lt; DC_TX_LIST_CNT; i++) {</a>
<a name="ln4012">		if (cd-&gt;dc_tx_chain[i] != NULL) {</a>
<a name="ln4013">			ctl = le32toh(ld-&gt;dc_tx_list[i].dc_ctl);</a>
<a name="ln4014">			if (ctl &amp; DC_TXCTL_SETUP) {</a>
<a name="ln4015">				bus_dmamap_sync(sc-&gt;dc_stag, sc-&gt;dc_smap,</a>
<a name="ln4016">				    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln4017">			} else {</a>
<a name="ln4018">				bus_dmamap_sync(sc-&gt;dc_tx_mtag,</a>
<a name="ln4019">				    cd-&gt;dc_tx_map[i], BUS_DMASYNC_POSTWRITE);</a>
<a name="ln4020">				bus_dmamap_unload(sc-&gt;dc_tx_mtag,</a>
<a name="ln4021">				    cd-&gt;dc_tx_map[i]);</a>
<a name="ln4022">				m_freem(cd-&gt;dc_tx_chain[i]);</a>
<a name="ln4023">			}</a>
<a name="ln4024">			cd-&gt;dc_tx_chain[i] = NULL;</a>
<a name="ln4025">		}</a>
<a name="ln4026">	}</a>
<a name="ln4027">	bzero(ld-&gt;dc_tx_list, DC_TX_LIST_SZ);</a>
<a name="ln4028">	bus_dmamap_sync(sc-&gt;dc_tx_ltag, sc-&gt;dc_tx_lmap,</a>
<a name="ln4029">	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln4030">}</a>
<a name="ln4031"> </a>
<a name="ln4032">/*</a>
<a name="ln4033"> * Device suspend routine.  Stop the interface and save some PCI</a>
<a name="ln4034"> * settings in case the BIOS doesn't restore them properly on</a>
<a name="ln4035"> * resume.</a>
<a name="ln4036"> */</a>
<a name="ln4037">static int</a>
<a name="ln4038">dc_suspend(device_t dev)</a>
<a name="ln4039">{</a>
<a name="ln4040">	struct dc_softc *sc;</a>
<a name="ln4041"> </a>
<a name="ln4042">	sc = device_get_softc(dev);</a>
<a name="ln4043">	DC_LOCK(sc);</a>
<a name="ln4044">	dc_stop(sc);</a>
<a name="ln4045">	sc-&gt;suspended = 1;</a>
<a name="ln4046">	DC_UNLOCK(sc);</a>
<a name="ln4047"> </a>
<a name="ln4048">	return (0);</a>
<a name="ln4049">}</a>
<a name="ln4050"> </a>
<a name="ln4051">/*</a>
<a name="ln4052"> * Device resume routine.  Restore some PCI settings in case the BIOS</a>
<a name="ln4053"> * doesn't, re-enable busmastering, and restart the interface if</a>
<a name="ln4054"> * appropriate.</a>
<a name="ln4055"> */</a>
<a name="ln4056">static int</a>
<a name="ln4057">dc_resume(device_t dev)</a>
<a name="ln4058">{</a>
<a name="ln4059">	struct dc_softc *sc;</a>
<a name="ln4060">	struct ifnet *ifp;</a>
<a name="ln4061"> </a>
<a name="ln4062">	sc = device_get_softc(dev);</a>
<a name="ln4063">	ifp = sc-&gt;dc_ifp;</a>
<a name="ln4064"> </a>
<a name="ln4065">	/* reinitialize interface if necessary */</a>
<a name="ln4066">	DC_LOCK(sc);</a>
<a name="ln4067">	if (ifp-&gt;if_flags &amp; IFF_UP)</a>
<a name="ln4068">		dc_init_locked(sc);</a>
<a name="ln4069"> </a>
<a name="ln4070">	sc-&gt;suspended = 0;</a>
<a name="ln4071">	DC_UNLOCK(sc);</a>
<a name="ln4072"> </a>
<a name="ln4073">	return (0);</a>
<a name="ln4074">}</a>
<a name="ln4075"> </a>
<a name="ln4076">/*</a>
<a name="ln4077"> * Stop all chip I/O so that the kernel's probe routines don't</a>
<a name="ln4078"> * get confused by errant DMAs when rebooting.</a>
<a name="ln4079"> */</a>
<a name="ln4080">static int</a>
<a name="ln4081">dc_shutdown(device_t dev)</a>
<a name="ln4082">{</a>
<a name="ln4083">	struct dc_softc *sc;</a>
<a name="ln4084"> </a>
<a name="ln4085">	sc = device_get_softc(dev);</a>
<a name="ln4086"> </a>
<a name="ln4087">	DC_LOCK(sc);</a>
<a name="ln4088">	dc_stop(sc);</a>
<a name="ln4089">	DC_UNLOCK(sc);</a>
<a name="ln4090"> </a>
<a name="ln4091">	return (0);</a>
<a name="ln4092">}</a>
<a name="ln4093"> </a>
<a name="ln4094">static int</a>
<a name="ln4095">dc_check_multiport(struct dc_softc *sc)</a>
<a name="ln4096">{</a>
<a name="ln4097">#ifndef __HAIKU__</a>
<a name="ln4098">	struct dc_softc *dsc;</a>
<a name="ln4099">	devclass_t dc;</a>
<a name="ln4100">	device_t child;</a>
<a name="ln4101">	uint8_t *eaddr;</a>
<a name="ln4102">	int unit;</a>
<a name="ln4103"> </a>
<a name="ln4104">	dc = devclass_find(&quot;dc&quot;);</a>
<a name="ln4105">	for (unit = 0; unit &lt; devclass_get_maxunit(dc); unit++) {</a>
<a name="ln4106">		child = devclass_get_device(dc, unit);</a>
<a name="ln4107">		if (child == NULL)</a>
<a name="ln4108">			continue;</a>
<a name="ln4109">		if (child == sc-&gt;dc_dev)</a>
<a name="ln4110">			continue;</a>
<a name="ln4111">		if (device_get_parent(child) != device_get_parent(sc-&gt;dc_dev))</a>
<a name="ln4112">			continue;</a>
<a name="ln4113">		if (unit &gt; device_get_unit(sc-&gt;dc_dev))</a>
<a name="ln4114">			continue;</a>
<a name="ln4115">		if (device_is_attached(child) == 0)</a>
<a name="ln4116">			continue;</a>
<a name="ln4117">		dsc = device_get_softc(child);</a>
<a name="ln4118">		device_printf(sc-&gt;dc_dev,</a>
<a name="ln4119">		    &quot;Using station address of %s as base\n&quot;,</a>
<a name="ln4120">		    device_get_nameunit(child));</a>
<a name="ln4121">		bcopy(dsc-&gt;dc_eaddr, sc-&gt;dc_eaddr, ETHER_ADDR_LEN);</a>
<a name="ln4122">		eaddr = (uint8_t *)sc-&gt;dc_eaddr;</a>
<a name="ln4123">		eaddr[5]++;</a>
<a name="ln4124">		/* Prepare SROM to parse again. */</a>
<a name="ln4125">		if (DC_IS_INTEL(sc) &amp;&amp; dsc-&gt;dc_srom != NULL &amp;&amp;</a>
<a name="ln4126">		    sc-&gt;dc_romwidth != 0) {</a>
<a name="ln4127">			free(sc-&gt;dc_srom, M_DEVBUF);</a>
<a name="ln4128">			sc-&gt;dc_romwidth = dsc-&gt;dc_romwidth;</a>
<a name="ln4129">			sc-&gt;dc_srom = malloc(DC_ROM_SIZE(sc-&gt;dc_romwidth),</a>
<a name="ln4130">			    M_DEVBUF, M_NOWAIT);</a>
<a name="ln4131">			if (sc-&gt;dc_srom == NULL) {</a>
<a name="ln4132">				device_printf(sc-&gt;dc_dev,</a>
<a name="ln4133">				    &quot;Could not allocate SROM buffer\n&quot;);</a>
<a name="ln4134">				return (ENOMEM);</a>
<a name="ln4135">			}</a>
<a name="ln4136">			bcopy(dsc-&gt;dc_srom, sc-&gt;dc_srom,</a>
<a name="ln4137">			    DC_ROM_SIZE(sc-&gt;dc_romwidth));</a>
<a name="ln4138">		}</a>
<a name="ln4139">		return (0);</a>
<a name="ln4140">	}</a>
<a name="ln4141">#endif</a>
<a name="ln4142">	return (ENOENT);</a>
<a name="ln4143">}</a>

</code></pre>
<div class="balloon" rel="2317"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memmove' function will lead to underflow of the buffer 'eaddr'.</p></div>
<div class="balloon" rel="2306"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memmove' function will lead to underflow of the buffer '& eaddr'.</p></div>
<div class="balloon" rel="1112"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memmove' function will lead to underflow of the buffer 'eaddr'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
