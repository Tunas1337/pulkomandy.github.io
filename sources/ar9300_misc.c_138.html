
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ar9300_misc.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright (c) 2013 Qualcomm Atheros, Inc.</a>
<a name="ln3"> *</a>
<a name="ln4"> * Permission to use, copy, modify, and/or distribute this software for any</a>
<a name="ln5"> * purpose with or without fee is hereby granted, provided that the above</a>
<a name="ln6"> * copyright notice and this permission notice appear in all copies.</a>
<a name="ln7"> *</a>
<a name="ln8"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH</a>
<a name="ln9"> * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY</a>
<a name="ln10"> * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,</a>
<a name="ln11"> * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM</a>
<a name="ln12"> * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR</a>
<a name="ln13"> * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR</a>
<a name="ln14"> * PERFORMANCE OF THIS SOFTWARE.</a>
<a name="ln15"> */</a>
<a name="ln16"> </a>
<a name="ln17">#include &quot;opt_ah.h&quot;</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;ah.h&quot;</a>
<a name="ln20">#include &quot;ah_internal.h&quot;</a>
<a name="ln21">#include &quot;ah_devid.h&quot;</a>
<a name="ln22">#ifdef AH_DEBUG</a>
<a name="ln23">#include &quot;ah_desc.h&quot;                    /* NB: for HAL_PHYERR* */</a>
<a name="ln24">#endif</a>
<a name="ln25"> </a>
<a name="ln26">#include &quot;ar9300/ar9300.h&quot;</a>
<a name="ln27">#include &quot;ar9300/ar9300reg.h&quot;</a>
<a name="ln28">#include &quot;ar9300/ar9300phy.h&quot;</a>
<a name="ln29">#include &quot;ar9300/ar9300desc.h&quot;</a>
<a name="ln30"> </a>
<a name="ln31">static u_int32_t ar9300_read_loc_timer(struct ath_hal *ah);</a>
<a name="ln32"> </a>
<a name="ln33">void</a>
<a name="ln34">ar9300_get_hw_hangs(struct ath_hal *ah, hal_hw_hangs_t *hangs)</a>
<a name="ln35">{</a>
<a name="ln36">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln37">    *hangs = 0;</a>
<a name="ln38"> </a>
<a name="ln39">    if (ar9300_get_capability(ah, HAL_CAP_BB_RIFS_HANG, 0, AH_NULL) == HAL_OK) {</a>
<a name="ln40">        *hangs |= HAL_RIFS_BB_HANG_WAR;</a>
<a name="ln41">    }</a>
<a name="ln42">    if (ar9300_get_capability(ah, HAL_CAP_BB_DFS_HANG, 0, AH_NULL) == HAL_OK) {</a>
<a name="ln43">        *hangs |= HAL_DFS_BB_HANG_WAR;</a>
<a name="ln44">    }</a>
<a name="ln45">    if (ar9300_get_capability(ah, HAL_CAP_BB_RX_CLEAR_STUCK_HANG, 0, AH_NULL)</a>
<a name="ln46">        == HAL_OK)</a>
<a name="ln47">    {</a>
<a name="ln48">        *hangs |= HAL_RX_STUCK_LOW_BB_HANG_WAR;</a>
<a name="ln49">    }</a>
<a name="ln50">    if (ar9300_get_capability(ah, HAL_CAP_MAC_HANG, 0, AH_NULL) == HAL_OK) {</a>
<a name="ln51">        *hangs |= HAL_MAC_HANG_WAR;</a>
<a name="ln52">    }</a>
<a name="ln53">    if (ar9300_get_capability(ah, HAL_CAP_PHYRESTART_CLR_WAR, 0, AH_NULL)</a>
<a name="ln54">        == HAL_OK)</a>
<a name="ln55">    {</a>
<a name="ln56">        *hangs |= HAL_PHYRESTART_CLR_WAR;</a>
<a name="ln57">    }</a>
<a name="ln58"> </a>
<a name="ln59">    ahp-&gt;ah_hang_wars = *hangs;</a>
<a name="ln60">}</a>
<a name="ln61"> </a>
<a name="ln62">/*</a>
<a name="ln63"> * XXX FreeBSD: the HAL version of ath_hal_mac_usec() knows about</a>
<a name="ln64"> * HT20, HT40, fast-clock, turbo mode, etc.</a>
<a name="ln65"> */</a>
<a name="ln66">static u_int</a>
<a name="ln67">ar9300_mac_to_usec(struct ath_hal *ah, u_int clks)</a>
<a name="ln68">{</a>
<a name="ln69">#if 0</a>
<a name="ln70">    const struct ieee80211_channel *chan = AH_PRIVATE(ah)-&gt;ah_curchan;</a>
<a name="ln71"> </a>
<a name="ln72">    if (chan &amp;&amp; IEEE80211_IS_CHAN_HT40(chan)) {</a>
<a name="ln73">        return (ath_hal_mac_usec(ah, clks) / 2);</a>
<a name="ln74">    } else {</a>
<a name="ln75">        return (ath_hal_mac_usec(ah, clks));</a>
<a name="ln76">    }</a>
<a name="ln77">#endif</a>
<a name="ln78">    return (ath_hal_mac_usec(ah, clks));</a>
<a name="ln79">}</a>
<a name="ln80"> </a>
<a name="ln81">u_int</a>
<a name="ln82">ar9300_mac_to_clks(struct ath_hal *ah, u_int usecs)</a>
<a name="ln83">{</a>
<a name="ln84">#if 0</a>
<a name="ln85">    const struct ieee80211_channel *chan = AH_PRIVATE(ah)-&gt;ah_curchan;</a>
<a name="ln86"> </a>
<a name="ln87">    if (chan &amp;&amp; IEEE80211_IS_CHAN_HT40(chan)) {</a>
<a name="ln88">        return (ath_hal_mac_clks(ah, usecs) * 2);</a>
<a name="ln89">    } else {</a>
<a name="ln90">        return (ath_hal_mac_clks(ah, usecs));</a>
<a name="ln91">    }</a>
<a name="ln92">#endif</a>
<a name="ln93">    return (ath_hal_mac_clks(ah, usecs));</a>
<a name="ln94">}</a>
<a name="ln95"> </a>
<a name="ln96">void</a>
<a name="ln97">ar9300_get_mac_address(struct ath_hal *ah, u_int8_t *mac)</a>
<a name="ln98">{</a>
<a name="ln99">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln100"> </a>
<a name="ln101">    OS_MEMCPY(mac, ahp-&gt;ah_macaddr, IEEE80211_ADDR_LEN);</a>
<a name="ln102">}</a>
<a name="ln103"> </a>
<a name="ln104">HAL_BOOL</a>
<a name="ln105">ar9300_set_mac_address(struct ath_hal *ah, const u_int8_t *mac)</a>
<a name="ln106">{</a>
<a name="ln107">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln108"> </a>
<a name="ln109">    OS_MEMCPY(ahp-&gt;ah_macaddr, mac, IEEE80211_ADDR_LEN);</a>
<a name="ln110">    return AH_TRUE;</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113">void</a>
<a name="ln114">ar9300_get_bss_id_mask(struct ath_hal *ah, u_int8_t *mask)</a>
<a name="ln115">{</a>
<a name="ln116">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln117"> </a>
<a name="ln118">    OS_MEMCPY(mask, ahp-&gt;ah_bssid_mask, IEEE80211_ADDR_LEN);</a>
<a name="ln119">}</a>
<a name="ln120"> </a>
<a name="ln121">HAL_BOOL</a>
<a name="ln122">ar9300_set_bss_id_mask(struct ath_hal *ah, const u_int8_t *mask)</a>
<a name="ln123">{</a>
<a name="ln124">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln125"> </a>
<a name="ln126">    /* save it since it must be rewritten on reset */</a>
<a name="ln127">    OS_MEMCPY(ahp-&gt;ah_bssid_mask, mask, IEEE80211_ADDR_LEN);</a>
<a name="ln128"> </a>
<a name="ln129">    OS_REG_WRITE(ah, AR_BSSMSKL, LE_READ_4(ahp-&gt;ah_bssid_mask));</a>
<a name="ln130">    OS_REG_WRITE(ah, AR_BSSMSKU, LE_READ_2(ahp-&gt;ah_bssid_mask + 4));</a>
<a name="ln131">    return AH_TRUE;</a>
<a name="ln132">}</a>
<a name="ln133"> </a>
<a name="ln134">/*</a>
<a name="ln135"> * Attempt to change the cards operating regulatory domain to the given value</a>
<a name="ln136"> * Returns: A_EINVAL for an unsupported regulatory domain.</a>
<a name="ln137"> *          A_HARDWARE for an unwritable EEPROM or bad EEPROM version</a>
<a name="ln138"> */</a>
<a name="ln139">HAL_BOOL</a>
<a name="ln140">ar9300_set_regulatory_domain(struct ath_hal *ah,</a>
<a name="ln141">        u_int16_t reg_domain, HAL_STATUS *status)</a>
<a name="ln142">{</a>
<a name="ln143">    HAL_STATUS ecode;</a>
<a name="ln144"> </a>
<a name="ln145">    if (AH_PRIVATE(ah)-&gt;ah_currentRD == 0) {</a>
<a name="ln146">        AH_PRIVATE(ah)-&gt;ah_currentRD = reg_domain;</a>
<a name="ln147">        return AH_TRUE;</a>
<a name="ln148">    }</a>
<a name="ln149">    ecode = HAL_EIO;</a>
<a name="ln150"> </a>
<a name="ln151">#if 0</a>
<a name="ln152">bad:</a>
<a name="ln153">#endif</a>
<a name="ln154">    if (status) {</a>
<a name="ln155">        *status = ecode;</a>
<a name="ln156">    }</a>
<a name="ln157">    return AH_FALSE;</a>
<a name="ln158">}</a>
<a name="ln159"> </a>
<a name="ln160">/*</a>
<a name="ln161"> * Return the wireless modes (a,b,g,t) supported by hardware.</a>
<a name="ln162"> *</a>
<a name="ln163"> * This value is what is actually supported by the hardware</a>
<a name="ln164"> * and is unaffected by regulatory/country code settings.</a>
<a name="ln165"> *</a>
<a name="ln166"> */</a>
<a name="ln167">u_int</a>
<a name="ln168">ar9300_get_wireless_modes(struct ath_hal *ah)</a>
<a name="ln169">{</a>
<a name="ln170">    return AH_PRIVATE(ah)-&gt;ah_caps.halWirelessModes;</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">/*</a>
<a name="ln174"> * Set the interrupt and GPIO values so the ISR can disable RF</a>
<a name="ln175"> * on a switch signal.  Assumes GPIO port and interrupt polarity</a>
<a name="ln176"> * are set prior to call.</a>
<a name="ln177"> */</a>
<a name="ln178">void</a>
<a name="ln179">ar9300_enable_rf_kill(struct ath_hal *ah)</a>
<a name="ln180">{</a>
<a name="ln181">    /* TODO - can this really be above the hal on the GPIO interface for</a>
<a name="ln182">     * TODO - the client only?</a>
<a name="ln183">     */</a>
<a name="ln184">    struct ath_hal_9300    *ahp = AH9300(ah);</a>
<a name="ln185"> </a>
<a name="ln186">    if (AR_SREV_JUPITER(ah) || AR_SREV_APHRODITE(ah)) {</a>
<a name="ln187">    	/* Check RF kill GPIO before set/clear RFSILENT bits. */</a>
<a name="ln188">    	if (ar9300_gpio_get(ah, ahp-&gt;ah_gpio_select) == ahp-&gt;ah_polarity) {</a>
<a name="ln189">            OS_REG_SET_BIT(ah, AR_HOSTIF_REG(ah, AR_RFSILENT), </a>
<a name="ln190">                           AR_RFSILENT_FORCE);</a>
<a name="ln191">            OS_REG_SET_BIT(ah, AR_PHY_TEST, RFSILENT_BB);</a>
<a name="ln192">        }</a>
<a name="ln193">        else {</a>
<a name="ln194">            OS_REG_CLR_BIT(ah, AR_HOSTIF_REG(ah, AR_RFSILENT), </a>
<a name="ln195">                           AR_RFSILENT_FORCE);</a>
<a name="ln196">            OS_REG_CLR_BIT(ah, AR_PHY_TEST, RFSILENT_BB);</a>
<a name="ln197">        }</a>
<a name="ln198">    }</a>
<a name="ln199">    else {</a>
<a name="ln200">        /* Connect rfsilent_bb_l to baseband */</a>
<a name="ln201">        OS_REG_SET_BIT(ah, AR_HOSTIF_REG(ah, AR_GPIO_INPUT_EN_VAL),</a>
<a name="ln202">            AR_GPIO_INPUT_EN_VAL_RFSILENT_BB);</a>
<a name="ln203"> </a>
<a name="ln204">        /* Set input mux for rfsilent_bb_l to GPIO #0 */</a>
<a name="ln205">        OS_REG_CLR_BIT(ah, AR_HOSTIF_REG(ah, AR_GPIO_INPUT_MUX2),</a>
<a name="ln206">            AR_GPIO_INPUT_MUX2_RFSILENT);</a>
<a name="ln207">        OS_REG_SET_BIT(ah, AR_HOSTIF_REG(ah, AR_GPIO_INPUT_MUX2),</a>
<a name="ln208">            (ahp-&gt;ah_gpio_select &amp; 0x0f) &lt;&lt; 4);</a>
<a name="ln209"> </a>
<a name="ln210">        /*</a>
<a name="ln211">         * Configure the desired GPIO port for input and</a>
<a name="ln212">         * enable baseband rf silence</a>
<a name="ln213">         */</a>
<a name="ln214">        ath_hal_gpioCfgInput(ah, ahp-&gt;ah_gpio_select);</a>
<a name="ln215">        OS_REG_SET_BIT(ah, AR_PHY_TEST, RFSILENT_BB);</a>
<a name="ln216">    }</a>
<a name="ln217"> </a>
<a name="ln218">    /*</a>
<a name="ln219">     * If radio disable switch connection to GPIO bit x is enabled</a>
<a name="ln220">     * program GPIO interrupt.</a>
<a name="ln221">     * If rfkill bit on eeprom is 1, setupeeprommap routine has already</a>
<a name="ln222">     * verified that it is a later version of eeprom, it has a place for</a>
<a name="ln223">     * rfkill bit and it is set to 1, indicating that GPIO bit x hardware</a>
<a name="ln224">     * connection is present.</a>
<a name="ln225">     */</a>
<a name="ln226">     /*</a>
<a name="ln227">      * RFKill uses polling not interrupt,</a>
<a name="ln228">      * disable interrupt to avoid Eee PC 2.6.21.4 hang up issue</a>
<a name="ln229">      */</a>
<a name="ln230">    if (ath_hal_hasrfkill_int(ah)) {</a>
<a name="ln231">        if (ahp-&gt;ah_gpio_bit == ar9300_gpio_get(ah, ahp-&gt;ah_gpio_select)) {</a>
<a name="ln232">            /* switch already closed, set to interrupt upon open */</a>
<a name="ln233">            ar9300_gpio_set_intr(ah, ahp-&gt;ah_gpio_select, !ahp-&gt;ah_gpio_bit);</a>
<a name="ln234">        } else {</a>
<a name="ln235">            ar9300_gpio_set_intr(ah, ahp-&gt;ah_gpio_select, ahp-&gt;ah_gpio_bit);</a>
<a name="ln236">        }</a>
<a name="ln237">    }</a>
<a name="ln238">}</a>
<a name="ln239"> </a>
<a name="ln240">/*</a>
<a name="ln241"> * Change the LED blinking pattern to correspond to the connectivity</a>
<a name="ln242"> */</a>
<a name="ln243">void</a>
<a name="ln244">ar9300_set_led_state(struct ath_hal *ah, HAL_LED_STATE state)</a>
<a name="ln245">{</a>
<a name="ln246">    static const u_int32_t ledbits[8] = {</a>
<a name="ln247">        AR_CFG_LED_ASSOC_NONE,     /* HAL_LED_RESET */</a>
<a name="ln248">        AR_CFG_LED_ASSOC_PENDING,  /* HAL_LED_INIT  */</a>
<a name="ln249">        AR_CFG_LED_ASSOC_PENDING,  /* HAL_LED_READY */</a>
<a name="ln250">        AR_CFG_LED_ASSOC_PENDING,  /* HAL_LED_SCAN  */</a>
<a name="ln251">        AR_CFG_LED_ASSOC_PENDING,  /* HAL_LED_AUTH  */</a>
<a name="ln252">        AR_CFG_LED_ASSOC_ACTIVE,   /* HAL_LED_ASSOC */</a>
<a name="ln253">        AR_CFG_LED_ASSOC_ACTIVE,   /* HAL_LED_RUN   */</a>
<a name="ln254">        AR_CFG_LED_ASSOC_NONE,</a>
<a name="ln255">    };</a>
<a name="ln256"> </a>
<a name="ln257">    OS_REG_RMW_FIELD(ah, AR_CFG_LED, AR_CFG_LED_ASSOC_CTL, ledbits[state]);</a>
<a name="ln258">}</a>
<a name="ln259"> </a>
<a name="ln260">/*</a>
<a name="ln261"> * Sets the Power LED on the cardbus without affecting the Network LED.</a>
<a name="ln262"> */</a>
<a name="ln263">void</a>
<a name="ln264">ar9300_set_power_led_state(struct ath_hal *ah, u_int8_t enabled)</a>
<a name="ln265">{</a>
<a name="ln266">    u_int32_t    val;</a>
<a name="ln267"> </a>
<a name="ln268">    val = enabled ? AR_CFG_LED_MODE_POWER_ON : AR_CFG_LED_MODE_POWER_OFF;</a>
<a name="ln269">    OS_REG_RMW_FIELD(ah, AR_CFG_LED, AR_CFG_LED_POWER, val);</a>
<a name="ln270">}</a>
<a name="ln271"> </a>
<a name="ln272">/*</a>
<a name="ln273"> * Sets the Network LED on the cardbus without affecting the Power LED.</a>
<a name="ln274"> */</a>
<a name="ln275">void</a>
<a name="ln276">ar9300_set_network_led_state(struct ath_hal *ah, u_int8_t enabled)</a>
<a name="ln277">{</a>
<a name="ln278">    u_int32_t    val;</a>
<a name="ln279"> </a>
<a name="ln280">    val = enabled ? AR_CFG_LED_MODE_NETWORK_ON : AR_CFG_LED_MODE_NETWORK_OFF;</a>
<a name="ln281">    OS_REG_RMW_FIELD(ah, AR_CFG_LED, AR_CFG_LED_NETWORK, val);</a>
<a name="ln282">}</a>
<a name="ln283"> </a>
<a name="ln284">/*</a>
<a name="ln285"> * Change association related fields programmed into the hardware.</a>
<a name="ln286"> * Writing a valid BSSID to the hardware effectively enables the hardware</a>
<a name="ln287"> * to synchronize its TSF to the correct beacons and receive frames coming</a>
<a name="ln288"> * from that BSSID. It is called by the SME JOIN operation.</a>
<a name="ln289"> */</a>
<a name="ln290">void</a>
<a name="ln291">ar9300_write_associd(struct ath_hal *ah, const u_int8_t *bssid,</a>
<a name="ln292">    u_int16_t assoc_id)</a>
<a name="ln293">{</a>
<a name="ln294">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln295"> </a>
<a name="ln296">    /* save bssid and assoc_id for restore on reset */</a>
<a name="ln297">    OS_MEMCPY(ahp-&gt;ah_bssid, bssid, IEEE80211_ADDR_LEN);</a>
<a name="ln298">    ahp-&gt;ah_assoc_id = assoc_id;</a>
<a name="ln299"> </a>
<a name="ln300">    OS_REG_WRITE(ah, AR_BSS_ID0, LE_READ_4(ahp-&gt;ah_bssid));</a>
<a name="ln301">    OS_REG_WRITE(ah, AR_BSS_ID1, LE_READ_2(ahp-&gt;ah_bssid + 4) |</a>
<a name="ln302">                                 ((assoc_id &amp; 0x3fff) &lt;&lt; AR_BSS_ID1_AID_S));</a>
<a name="ln303">}</a>
<a name="ln304"> </a>
<a name="ln305">/*</a>
<a name="ln306"> * Get the current hardware tsf for stamlme</a>
<a name="ln307"> */</a>
<a name="ln308">u_int64_t</a>
<a name="ln309">ar9300_get_tsf64(struct ath_hal *ah)</a>
<a name="ln310">{</a>
<a name="ln311">    u_int64_t tsf;</a>
<a name="ln312"> </a>
<a name="ln313">    /* XXX sync multi-word read? */</a>
<a name="ln314">    tsf = OS_REG_READ(ah, AR_TSF_U32);</a>
<a name="ln315">    tsf = (tsf &lt;&lt; 32) | OS_REG_READ(ah, AR_TSF_L32);</a>
<a name="ln316">    return tsf;</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">void</a>
<a name="ln320">ar9300_set_tsf64(struct ath_hal *ah, u_int64_t tsf)</a>
<a name="ln321">{</a>
<a name="ln322">    OS_REG_WRITE(ah, AR_TSF_L32, (tsf &amp; 0xffffffff));</a>
<a name="ln323">    OS_REG_WRITE(ah, AR_TSF_U32, ((tsf &gt;&gt; 32) &amp; 0xffffffff));</a>
<a name="ln324">}</a>
<a name="ln325"> </a>
<a name="ln326">/*</a>
<a name="ln327"> * Get the current hardware tsf for stamlme</a>
<a name="ln328"> */</a>
<a name="ln329">u_int32_t</a>
<a name="ln330">ar9300_get_tsf32(struct ath_hal *ah)</a>
<a name="ln331">{</a>
<a name="ln332">    return OS_REG_READ(ah, AR_TSF_L32);</a>
<a name="ln333">}</a>
<a name="ln334"> </a>
<a name="ln335">u_int32_t</a>
<a name="ln336">ar9300_get_tsf2_32(struct ath_hal *ah)</a>
<a name="ln337">{</a>
<a name="ln338">    return OS_REG_READ(ah, AR_TSF2_L32);</a>
<a name="ln339">}</a>
<a name="ln340"> </a>
<a name="ln341">/*</a>
<a name="ln342"> * Reset the current hardware tsf for stamlme.</a>
<a name="ln343"> */</a>
<a name="ln344">void</a>
<a name="ln345">ar9300_reset_tsf(struct ath_hal *ah)</a>
<a name="ln346">{</a>
<a name="ln347">    int count;</a>
<a name="ln348"> </a>
<a name="ln349">    count = 0;</a>
<a name="ln350">    while (OS_REG_READ(ah, AR_SLP32_MODE) &amp; AR_SLP32_TSF_WRITE_STATUS) {</a>
<a name="ln351">        count++;</a>
<a name="ln352">        if (count &gt; 10) {</a>
<a name="ln353">            HALDEBUG(ah, HAL_DEBUG_RESET,</a>
<a name="ln354">                &quot;%s: AR_SLP32_TSF_WRITE_STATUS limit exceeded\n&quot;, __func__);</a>
<a name="ln355">            break;</a>
<a name="ln356">        }</a>
<a name="ln357">        OS_DELAY(10);</a>
<a name="ln358">    }</a>
<a name="ln359">    OS_REG_WRITE(ah, AR_RESET_TSF, AR_RESET_TSF_ONCE);</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362">/*</a>
<a name="ln363"> * Set or clear hardware basic rate bit</a>
<a name="ln364"> * Set hardware basic rate set if basic rate is found</a>
<a name="ln365"> * and basic rate is equal or less than 2Mbps</a>
<a name="ln366"> */</a>
<a name="ln367">void</a>
<a name="ln368">ar9300_set_basic_rate(struct ath_hal *ah, HAL_RATE_SET *rs)</a>
<a name="ln369">{</a>
<a name="ln370">    const struct ieee80211_channel *chan = AH_PRIVATE(ah)-&gt;ah_curchan;</a>
<a name="ln371">    u_int32_t reg;</a>
<a name="ln372">    u_int8_t xset;</a>
<a name="ln373">    int i;</a>
<a name="ln374"> </a>
<a name="ln375">    if (chan == AH_NULL || !IEEE80211_IS_CHAN_CCK(chan)) {</a>
<a name="ln376">        return;</a>
<a name="ln377">    }</a>
<a name="ln378">    xset = 0;</a>
<a name="ln379">    for (i = 0; i &lt; rs-&gt;rs_count; i++) {</a>
<a name="ln380">        u_int8_t rset = rs-&gt;rs_rates[i];</a>
<a name="ln381">        /* Basic rate defined? */</a>
<a name="ln382">        if ((rset &amp; 0x80) &amp;&amp; (rset &amp;= 0x7f) &gt;= xset) {</a>
<a name="ln383">            xset = rset;</a>
<a name="ln384">        }</a>
<a name="ln385">    }</a>
<a name="ln386">    /*</a>
<a name="ln387">     * Set the h/w bit to reflect whether or not the basic</a>
<a name="ln388">     * rate is found to be equal or less than 2Mbps.</a>
<a name="ln389">     */</a>
<a name="ln390">    reg = OS_REG_READ(ah, AR_STA_ID1);</a>
<a name="ln391">    if (xset &amp;&amp; xset / 2 &lt;= 2) {</a>
<a name="ln392">        OS_REG_WRITE(ah, AR_STA_ID1, reg | AR_STA_ID1_BASE_RATE_11B);</a>
<a name="ln393">    } else {</a>
<a name="ln394">        OS_REG_WRITE(ah, AR_STA_ID1, reg &amp;~ AR_STA_ID1_BASE_RATE_11B);</a>
<a name="ln395">    }</a>
<a name="ln396">}</a>
<a name="ln397"> </a>
<a name="ln398">/*</a>
<a name="ln399"> * Grab a semi-random value from hardware registers - may not</a>
<a name="ln400"> * change often</a>
<a name="ln401"> */</a>
<a name="ln402">u_int32_t</a>
<a name="ln403">ar9300_get_random_seed(struct ath_hal *ah)</a>
<a name="ln404">{</a>
<a name="ln405">    u_int32_t nf;</a>
<a name="ln406"> </a>
<a name="ln407">    nf = (OS_REG_READ(ah, AR_PHY(25)) &gt;&gt; 19) &amp; 0x1ff;</a>
<a name="ln408">    if (nf &amp; 0x100) {</a>
<a name="ln409">        nf = 0 - ((nf ^ 0x1ff) + 1);</a>
<a name="ln410">    }</a>
<a name="ln411">    return (OS_REG_READ(ah, AR_TSF_U32) ^</a>
<a name="ln412">        OS_REG_READ(ah, AR_TSF_L32) ^ nf);</a>
<a name="ln413">}</a>
<a name="ln414"> </a>
<a name="ln415">/*</a>
<a name="ln416"> * Detect if our card is present</a>
<a name="ln417"> */</a>
<a name="ln418">HAL_BOOL</a>
<a name="ln419">ar9300_detect_card_present(struct ath_hal *ah)</a>
<a name="ln420">{</a>
<a name="ln421">    u_int16_t mac_version, mac_rev;</a>
<a name="ln422">    u_int32_t v;</a>
<a name="ln423"> </a>
<a name="ln424">    /*</a>
<a name="ln425">     * Read the Silicon Revision register and compare that</a>
<a name="ln426">     * to what we read at attach time.  If the same, we say</a>
<a name="ln427">     * a card/device is present.</a>
<a name="ln428">     */</a>
<a name="ln429">    v = OS_REG_READ(ah, AR_HOSTIF_REG(ah, AR_SREV)) &amp; AR_SREV_ID;</a>
<a name="ln430">    if (v == 0xFF) {</a>
<a name="ln431">        /* new SREV format */</a>
<a name="ln432">        v = OS_REG_READ(ah, AR_HOSTIF_REG(ah, AR_SREV));</a>
<a name="ln433">        /*</a>
<a name="ln434">         * Include 6-bit Chip Type (masked to 0) to differentiate</a>
<a name="ln435">         * from pre-Sowl versions</a>
<a name="ln436">         */</a>
<a name="ln437">        mac_version = (v &amp; AR_SREV_VERSION2) &gt;&gt; AR_SREV_TYPE2_S;</a>
<a name="ln438">        mac_rev = MS(v, AR_SREV_REVISION2);</a>
<a name="ln439">    } else {</a>
<a name="ln440">        mac_version = MS(v, AR_SREV_VERSION);</a>
<a name="ln441">        mac_rev = v &amp; AR_SREV_REVISION;</a>
<a name="ln442">    }</a>
<a name="ln443">    return (AH_PRIVATE(ah)-&gt;ah_macVersion == mac_version &amp;&amp;</a>
<a name="ln444">            AH_PRIVATE(ah)-&gt;ah_macRev == mac_rev);</a>
<a name="ln445">}</a>
<a name="ln446"> </a>
<a name="ln447">/*</a>
<a name="ln448"> * Update MIB Counters</a>
<a name="ln449"> */</a>
<a name="ln450">void</a>
<a name="ln451">ar9300_update_mib_mac_stats(struct ath_hal *ah)</a>
<a name="ln452">{</a>
<a name="ln453">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln454">    HAL_MIB_STATS* stats = &amp;ahp-&gt;ah_stats.ast_mibstats;</a>
<a name="ln455"> </a>
<a name="ln456">    stats-&gt;ackrcv_bad += OS_REG_READ(ah, AR_ACK_FAIL);</a>
<a name="ln457">    stats-&gt;rts_bad    += OS_REG_READ(ah, AR_RTS_FAIL);</a>
<a name="ln458">    stats-&gt;fcs_bad    += OS_REG_READ(ah, AR_FCS_FAIL);</a>
<a name="ln459">    stats-&gt;rts_good   += OS_REG_READ(ah, AR_RTS_OK);</a>
<a name="ln460">    stats-&gt;beacons    += OS_REG_READ(ah, AR_BEACON_CNT);</a>
<a name="ln461">}</a>
<a name="ln462"> </a>
<a name="ln463">void</a>
<a name="ln464">ar9300_get_mib_mac_stats(struct ath_hal *ah, HAL_MIB_STATS* stats)</a>
<a name="ln465">{</a>
<a name="ln466">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln467">    HAL_MIB_STATS* istats = &amp;ahp-&gt;ah_stats.ast_mibstats;</a>
<a name="ln468"> </a>
<a name="ln469">    stats-&gt;ackrcv_bad = istats-&gt;ackrcv_bad;</a>
<a name="ln470">    stats-&gt;rts_bad    = istats-&gt;rts_bad;</a>
<a name="ln471">    stats-&gt;fcs_bad    = istats-&gt;fcs_bad;</a>
<a name="ln472">    stats-&gt;rts_good   = istats-&gt;rts_good;</a>
<a name="ln473">    stats-&gt;beacons    = istats-&gt;beacons;</a>
<a name="ln474">}</a>
<a name="ln475"> </a>
<a name="ln476">/*</a>
<a name="ln477"> * Detect if the HW supports spreading a CCK signal on channel 14</a>
<a name="ln478"> */</a>
<a name="ln479">HAL_BOOL</a>
<a name="ln480">ar9300_is_japan_channel_spread_supported(struct ath_hal *ah)</a>
<a name="ln481">{</a>
<a name="ln482">    return AH_TRUE;</a>
<a name="ln483">}</a>
<a name="ln484"> </a>
<a name="ln485">/*</a>
<a name="ln486"> * Get the rssi of frame curently being received.</a>
<a name="ln487"> */</a>
<a name="ln488">u_int32_t</a>
<a name="ln489">ar9300_get_cur_rssi(struct ath_hal *ah)</a>
<a name="ln490">{</a>
<a name="ln491">    /* XXX return (OS_REG_READ(ah, AR_PHY_CURRENT_RSSI) &amp; 0xff); */</a>
<a name="ln492">    /* get combined RSSI */</a>
<a name="ln493">    return (OS_REG_READ(ah, AR_PHY_RSSI_3) &amp; 0xff);</a>
<a name="ln494">}</a>
<a name="ln495"> </a>
<a name="ln496">#if ATH_GEN_RANDOMNESS</a>
<a name="ln497">/*</a>
<a name="ln498"> * Get the rssi value from BB on ctl chain0.</a>
<a name="ln499"> */</a>
<a name="ln500">u_int32_t</a>
<a name="ln501">ar9300_get_rssi_chain0(struct ath_hal *ah)</a>
<a name="ln502">{</a>
<a name="ln503">    /* get ctl chain0 RSSI */</a>
<a name="ln504">    return OS_REG_READ(ah, AR_PHY_RSSI_0) &amp; 0xff;</a>
<a name="ln505">}</a>
<a name="ln506">#endif</a>
<a name="ln507"> </a>
<a name="ln508">u_int</a>
<a name="ln509">ar9300_get_def_antenna(struct ath_hal *ah)</a>
<a name="ln510">{</a>
<a name="ln511">    return (OS_REG_READ(ah, AR_DEF_ANTENNA) &amp; 0x7);</a>
<a name="ln512">}</a>
<a name="ln513"> </a>
<a name="ln514">/* Setup coverage class */</a>
<a name="ln515">void</a>
<a name="ln516">ar9300_set_coverage_class(struct ath_hal *ah, u_int8_t coverageclass, int now)</a>
<a name="ln517">{</a>
<a name="ln518">}</a>
<a name="ln519"> </a>
<a name="ln520">void</a>
<a name="ln521">ar9300_set_def_antenna(struct ath_hal *ah, u_int antenna)</a>
<a name="ln522">{</a>
<a name="ln523">    OS_REG_WRITE(ah, AR_DEF_ANTENNA, (antenna &amp; 0x7));</a>
<a name="ln524">}</a>
<a name="ln525"> </a>
<a name="ln526">HAL_BOOL</a>
<a name="ln527">ar9300_set_antenna_switch(struct ath_hal *ah,</a>
<a name="ln528">    HAL_ANT_SETTING settings, const struct ieee80211_channel *chan,</a>
<a name="ln529">    u_int8_t *tx_chainmask, u_int8_t *rx_chainmask, u_int8_t *antenna_cfgd)</a>
<a name="ln530">{</a>
<a name="ln531">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln532"> </a>
<a name="ln533">    /*</a>
<a name="ln534">     * Owl does not support diversity or changing antennas.</a>
<a name="ln535">     *</a>
<a name="ln536">     * Instead this API and function are defined differently for AR9300.</a>
<a name="ln537">     * To support Tablet PC's, this interface allows the system</a>
<a name="ln538">     * to dramatically reduce the TX power on a particular chain.</a>
<a name="ln539">     *</a>
<a name="ln540">     * Based on the value of (redefined) diversity_control, the</a>
<a name="ln541">     * reset code will decrease power on chain 0 or chain 1/2.</a>
<a name="ln542">     *</a>
<a name="ln543">     * Based on the value of bit 0 of antenna_switch_swap,</a>
<a name="ln544">     * the mapping between OID call and chain is defined as:</a>
<a name="ln545">     *  0:  map A -&gt; 0, B -&gt; 1;</a>
<a name="ln546">     *  1:  map A -&gt; 1, B -&gt; 0;</a>
<a name="ln547">     *</a>
<a name="ln548">     * NOTE:</a>
<a name="ln549">     *   The devices that use this OID should use a tx_chain_mask and</a>
<a name="ln550">     *   tx_chain_select_legacy setting of 5 or 3 if ANTENNA_FIXED_B is</a>
<a name="ln551">     *   used in order to ensure an active transmit antenna.  This</a>
<a name="ln552">     *   API will allow the host to turn off the only transmitting</a>
<a name="ln553">     *   antenna to ensure the antenna closest to the user's body is</a>
<a name="ln554">     *   powered-down.</a>
<a name="ln555">     */</a>
<a name="ln556">    /*</a>
<a name="ln557">     * Set antenna control for use during reset sequence by</a>
<a name="ln558">     * ar9300_decrease_chain_power()</a>
<a name="ln559">     */</a>
<a name="ln560">    ahp-&gt;ah_diversity_control = settings;</a>
<a name="ln561"> </a>
<a name="ln562">    return AH_TRUE;</a>
<a name="ln563">}</a>
<a name="ln564"> </a>
<a name="ln565">HAL_BOOL</a>
<a name="ln566">ar9300_is_sleep_after_beacon_broken(struct ath_hal *ah)</a>
<a name="ln567">{</a>
<a name="ln568">    return AH_TRUE;</a>
<a name="ln569">}</a>
<a name="ln570"> </a>
<a name="ln571">HAL_BOOL</a>
<a name="ln572">ar9300_set_slot_time(struct ath_hal *ah, u_int us)</a>
<a name="ln573">{</a>
<a name="ln574">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln575">    if (us &lt; HAL_SLOT_TIME_9 || us &gt; ar9300_mac_to_usec(ah, 0xffff)) {</a>
<a name="ln576">        HALDEBUG(ah, HAL_DEBUG_RESET, &quot;%s: bad slot time %u\n&quot;, __func__, us);</a>
<a name="ln577">        ahp-&gt;ah_slot_time = (u_int) -1;  /* restore default handling */</a>
<a name="ln578">        return AH_FALSE;</a>
<a name="ln579">    } else {</a>
<a name="ln580">        /* convert to system clocks */</a>
<a name="ln581">        OS_REG_WRITE(ah, AR_D_GBL_IFS_SLOT, ar9300_mac_to_clks(ah, us));</a>
<a name="ln582">        ahp-&gt;ah_slot_time = us;</a>
<a name="ln583">        return AH_TRUE;</a>
<a name="ln584">    }</a>
<a name="ln585">}</a>
<a name="ln586"> </a>
<a name="ln587">HAL_BOOL</a>
<a name="ln588">ar9300_set_ack_timeout(struct ath_hal *ah, u_int us)</a>
<a name="ln589">{</a>
<a name="ln590">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln591"> </a>
<a name="ln592">    if (us &gt; ar9300_mac_to_usec(ah, MS(0xffffffff, AR_TIME_OUT_ACK))) {</a>
<a name="ln593">        HALDEBUG(ah, HAL_DEBUG_RESET, &quot;%s: bad ack timeout %u\n&quot;, __func__, us);</a>
<a name="ln594">        ahp-&gt;ah_ack_timeout = (u_int) -1; /* restore default handling */</a>
<a name="ln595">        return AH_FALSE;</a>
<a name="ln596">    } else {</a>
<a name="ln597">        /* convert to system clocks */</a>
<a name="ln598">        OS_REG_RMW_FIELD(ah,</a>
<a name="ln599">            AR_TIME_OUT, AR_TIME_OUT_ACK, ar9300_mac_to_clks(ah, us));</a>
<a name="ln600">        ahp-&gt;ah_ack_timeout = us;</a>
<a name="ln601">        return AH_TRUE;</a>
<a name="ln602">    }</a>
<a name="ln603">}</a>
<a name="ln604"> </a>
<a name="ln605">u_int</a>
<a name="ln606">ar9300_get_ack_timeout(struct ath_hal *ah)</a>
<a name="ln607">{</a>
<a name="ln608">    u_int clks = MS(OS_REG_READ(ah, AR_TIME_OUT), AR_TIME_OUT_ACK);</a>
<a name="ln609">    return ar9300_mac_to_usec(ah, clks);      /* convert from system clocks */</a>
<a name="ln610">}</a>
<a name="ln611"> </a>
<a name="ln612">HAL_STATUS</a>
<a name="ln613">ar9300_set_quiet(struct ath_hal *ah, u_int32_t period, u_int32_t duration,</a>
<a name="ln614">                 u_int32_t next_start, HAL_QUIET_FLAG flag)</a>
<a name="ln615">{</a>
<a name="ln616">#define	TU_TO_USEC(_tu)		((_tu) &lt;&lt; 10)</a>
<a name="ln617">    HAL_STATUS status = HAL_EIO;</a>
<a name="ln618">    u_int32_t tsf = 0, j, next_start_us = 0;</a>
<a name="ln619">    if (flag &amp; HAL_QUIET_ENABLE) {</a>
<a name="ln620">        for (j = 0; j &lt; 2; j++) {</a>
<a name="ln621">            next_start_us = TU_TO_USEC(next_start);</a>
<a name="ln622">            tsf = OS_REG_READ(ah, AR_TSF_L32);</a>
<a name="ln623">            if ((!next_start) || (flag &amp; HAL_QUIET_ADD_CURRENT_TSF)) {</a>
<a name="ln624">                next_start_us += tsf;</a>
<a name="ln625">            }</a>
<a name="ln626">            if (flag &amp; HAL_QUIET_ADD_SWBA_RESP_TIME) {</a>
<a name="ln627">                next_start_us += </a>
<a name="ln628">                    ah-&gt;ah_config.ah_sw_beacon_response_time;</a>
<a name="ln629">            }</a>
<a name="ln630">            OS_REG_RMW_FIELD(ah, AR_QUIET1, AR_QUIET1_QUIET_ACK_CTS_ENABLE, 1); </a>
<a name="ln631">            OS_REG_WRITE(ah, AR_QUIET2, SM(duration, AR_QUIET2_QUIET_DUR));</a>
<a name="ln632">            OS_REG_WRITE(ah, AR_QUIET_PERIOD, TU_TO_USEC(period));</a>
<a name="ln633">            OS_REG_WRITE(ah, AR_NEXT_QUIET_TIMER, next_start_us);</a>
<a name="ln634">            OS_REG_SET_BIT(ah, AR_TIMER_MODE, AR_QUIET_TIMER_EN);</a>
<a name="ln635">            if ((OS_REG_READ(ah, AR_TSF_L32) &gt;&gt; 10) == tsf &gt;&gt; 10) {</a>
<a name="ln636">                status = HAL_OK;</a>
<a name="ln637">                break;</a>
<a name="ln638">            }</a>
<a name="ln639">            HALDEBUG(ah, HAL_DEBUG_QUEUE, &quot;%s: TSF have moved &quot;</a>
<a name="ln640">                &quot;while trying to set quiet time TSF: 0x%08x\n&quot;, __func__, tsf);</a>
<a name="ln641">            /* TSF shouldn't count twice or reg access is taking forever */</a>
<a name="ln642">            HALASSERT(j &lt; 1);</a>
<a name="ln643">        }</a>
<a name="ln644">    } else {</a>
<a name="ln645">        OS_REG_CLR_BIT(ah, AR_TIMER_MODE, AR_QUIET_TIMER_EN);</a>
<a name="ln646">        status = HAL_OK;</a>
<a name="ln647">    }</a>
<a name="ln648"> </a>
<a name="ln649">    return status;</a>
<a name="ln650">#undef	TU_TO_USEC</a>
<a name="ln651">}</a>
<a name="ln652"> </a>
<a name="ln653">//#ifdef ATH_SUPPORT_DFS</a>
<a name="ln654">void</a>
<a name="ln655">ar9300_cac_tx_quiet(struct ath_hal *ah, HAL_BOOL enable)</a>
<a name="ln656">{</a>
<a name="ln657">    uint32_t reg1, reg2;</a>
<a name="ln658"> </a>
<a name="ln659">    reg1 = OS_REG_READ(ah, AR_MAC_PCU_OFFSET(MAC_PCU_MISC_MODE));</a>
<a name="ln660">    reg2 = OS_REG_READ(ah, AR_MAC_PCU_OFFSET(MAC_PCU_QUIET_TIME_1));</a>
<a name="ln661">    AH9300(ah)-&gt;ah_cac_quiet_enabled = enable;</a>
<a name="ln662"> </a>
<a name="ln663">    if (enable) {</a>
<a name="ln664">        OS_REG_WRITE(ah, AR_MAC_PCU_OFFSET(MAC_PCU_MISC_MODE),</a>
<a name="ln665">                     reg1 | AR_PCU_FORCE_QUIET_COLL);</a>
<a name="ln666">        OS_REG_WRITE(ah, AR_MAC_PCU_OFFSET(MAC_PCU_QUIET_TIME_1),</a>
<a name="ln667">                     reg2 &amp; ~AR_QUIET1_QUIET_ACK_CTS_ENABLE);</a>
<a name="ln668">    } else {</a>
<a name="ln669">        OS_REG_WRITE(ah, AR_MAC_PCU_OFFSET(MAC_PCU_MISC_MODE),</a>
<a name="ln670">                     reg1 &amp; ~AR_PCU_FORCE_QUIET_COLL);</a>
<a name="ln671">        OS_REG_WRITE(ah, AR_MAC_PCU_OFFSET(MAC_PCU_QUIET_TIME_1),</a>
<a name="ln672">                     reg2 | AR_QUIET1_QUIET_ACK_CTS_ENABLE);</a>
<a name="ln673">    }</a>
<a name="ln674">}</a>
<a name="ln675">//#endif /* ATH_SUPPORT_DFS */</a>
<a name="ln676"> </a>
<a name="ln677">void</a>
<a name="ln678">ar9300_set_pcu_config(struct ath_hal *ah)</a>
<a name="ln679">{</a>
<a name="ln680">    ar9300_set_operating_mode(ah, AH_PRIVATE(ah)-&gt;ah_opmode);</a>
<a name="ln681">}</a>
<a name="ln682"> </a>
<a name="ln683">HAL_STATUS</a>
<a name="ln684">ar9300_get_capability(struct ath_hal *ah, HAL_CAPABILITY_TYPE type,</a>
<a name="ln685">    u_int32_t capability, u_int32_t *result)</a>
<a name="ln686">{</a>
<a name="ln687">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln688">    const HAL_CAPABILITIES *p_cap = &amp;AH_PRIVATE(ah)-&gt;ah_caps;</a>
<a name="ln689">    struct ar9300_ani_state *ani;</a>
<a name="ln690"> </a>
<a name="ln691">    switch (type) {</a>
<a name="ln692">    case HAL_CAP_CIPHER:            /* cipher handled in hardware */</a>
<a name="ln693">        switch (capability) {</a>
<a name="ln694">        case HAL_CIPHER_AES_CCM:</a>
<a name="ln695">        case HAL_CIPHER_AES_OCB:</a>
<a name="ln696">        case HAL_CIPHER_TKIP:</a>
<a name="ln697">        case HAL_CIPHER_WEP:</a>
<a name="ln698">        case HAL_CIPHER_MIC:</a>
<a name="ln699">        case HAL_CIPHER_CLR:</a>
<a name="ln700">            return HAL_OK;</a>
<a name="ln701">        default:</a>
<a name="ln702">            return HAL_ENOTSUPP;</a>
<a name="ln703">        }</a>
<a name="ln704">    case HAL_CAP_TKIP_MIC:          /* handle TKIP MIC in hardware */</a>
<a name="ln705">        switch (capability) {</a>
<a name="ln706">        case 0:         /* hardware capability */</a>
<a name="ln707">            return HAL_OK;</a>
<a name="ln708">        case 1:</a>
<a name="ln709">            return (ahp-&gt;ah_sta_id1_defaults &amp;</a>
<a name="ln710">                    AR_STA_ID1_CRPT_MIC_ENABLE) ?  HAL_OK : HAL_ENXIO;</a>
<a name="ln711">        default:</a>
<a name="ln712">            return HAL_ENOTSUPP;</a>
<a name="ln713">        }</a>
<a name="ln714">    case HAL_CAP_TKIP_SPLIT:        /* hardware TKIP uses split keys */</a>
<a name="ln715">        switch (capability) {</a>
<a name="ln716">        case 0: /* hardware capability */</a>
<a name="ln717">            return p_cap-&gt;halTkipMicTxRxKeySupport ? HAL_ENXIO : HAL_OK;</a>
<a name="ln718">        case 1: /* current setting */</a>
<a name="ln719">            return (ahp-&gt;ah_misc_mode &amp; AR_PCU_MIC_NEW_LOC_ENA) ?</a>
<a name="ln720">                HAL_ENXIO : HAL_OK;</a>
<a name="ln721">        default:</a>
<a name="ln722">            return HAL_ENOTSUPP;</a>
<a name="ln723">        }</a>
<a name="ln724">    case HAL_CAP_WME_TKIPMIC:</a>
<a name="ln725">        /* hardware can do TKIP MIC when WMM is turned on */</a>
<a name="ln726">        return HAL_OK;</a>
<a name="ln727">    case HAL_CAP_PHYCOUNTERS:       /* hardware PHY error counters */</a>
<a name="ln728">        return HAL_OK;</a>
<a name="ln729">    case HAL_CAP_DIVERSITY:         /* hardware supports fast diversity */</a>
<a name="ln730">        switch (capability) {</a>
<a name="ln731">        case 0:                 /* hardware capability */</a>
<a name="ln732">            return HAL_OK;</a>
<a name="ln733">        case 1:                 /* current setting */</a>
<a name="ln734">            return (OS_REG_READ(ah, AR_PHY_CCK_DETECT) &amp;</a>
<a name="ln735">                            AR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV) ?</a>
<a name="ln736">                            HAL_OK : HAL_ENXIO;</a>
<a name="ln737">        }</a>
<a name="ln738">        return HAL_EINVAL;</a>
<a name="ln739">    case HAL_CAP_TPC:</a>
<a name="ln740">        switch (capability) {</a>
<a name="ln741">        case 0:                 /* hardware capability */</a>
<a name="ln742">            return HAL_OK;</a>
<a name="ln743">        case 1:</a>
<a name="ln744">            return ah-&gt;ah_config.ath_hal_desc_tpc ?</a>
<a name="ln745">                               HAL_OK : HAL_ENXIO;</a>
<a name="ln746">        }</a>
<a name="ln747">        return HAL_OK;</a>
<a name="ln748">    case HAL_CAP_PHYDIAG:           /* radar pulse detection capability */</a>
<a name="ln749">        return HAL_OK;</a>
<a name="ln750">    case HAL_CAP_MCAST_KEYSRCH:     /* multicast frame keycache search */</a>
<a name="ln751">        switch (capability) {</a>
<a name="ln752">        case 0:                 /* hardware capability */</a>
<a name="ln753">            return HAL_OK;</a>
<a name="ln754">        case 1:</a>
<a name="ln755">            if (OS_REG_READ(ah, AR_STA_ID1) &amp; AR_STA_ID1_ADHOC) {</a>
<a name="ln756">                /*</a>
<a name="ln757">                 * Owl and Merlin have problems in mcast key search.</a>
<a name="ln758">                 * Disable this cap. in Ad-hoc mode. see Bug 25776 and</a>
<a name="ln759">                 * 26802</a>
<a name="ln760">                 */</a>
<a name="ln761">                return HAL_ENXIO;</a>
<a name="ln762">            } else {</a>
<a name="ln763">                return (ahp-&gt;ah_sta_id1_defaults &amp;</a>
<a name="ln764">                        AR_STA_ID1_MCAST_KSRCH) ? HAL_OK : HAL_ENXIO;</a>
<a name="ln765">            }</a>
<a name="ln766">        }</a>
<a name="ln767">        return HAL_EINVAL;</a>
<a name="ln768">    case HAL_CAP_TSF_ADJUST:        /* hardware has beacon tsf adjust */</a>
<a name="ln769">        switch (capability) {</a>
<a name="ln770">        case 0:                 /* hardware capability */</a>
<a name="ln771">            return p_cap-&gt;halTsfAddSupport ? HAL_OK : HAL_ENOTSUPP;</a>
<a name="ln772">        case 1:</a>
<a name="ln773">            return (ahp-&gt;ah_misc_mode &amp; AR_PCU_TX_ADD_TSF) ?</a>
<a name="ln774">                HAL_OK : HAL_ENXIO;</a>
<a name="ln775">        }</a>
<a name="ln776">        return HAL_EINVAL;</a>
<a name="ln777">    case HAL_CAP_RFSILENT:      /* rfsilent support  */</a>
<a name="ln778">        if (capability == 3) {  /* rfkill interrupt */</a>
<a name="ln779">            /*</a>
<a name="ln780">             * XXX: Interrupt-based notification of RF Kill state</a>
<a name="ln781">             *      changes not working yet. Report that this feature</a>
<a name="ln782">             *      is not supported so that polling is used instead.</a>
<a name="ln783">             */</a>
<a name="ln784">            return (HAL_ENOTSUPP);</a>
<a name="ln785">        }</a>
<a name="ln786">        return ath_hal_getcapability(ah, type, capability, result);</a>
<a name="ln787">    case HAL_CAP_4ADDR_AGGR:</a>
<a name="ln788">        return HAL_OK;</a>
<a name="ln789">    case HAL_CAP_BB_RIFS_HANG:</a>
<a name="ln790">        return HAL_ENOTSUPP;</a>
<a name="ln791">    case HAL_CAP_BB_DFS_HANG:</a>
<a name="ln792">        return HAL_ENOTSUPP;</a>
<a name="ln793">    case HAL_CAP_BB_RX_CLEAR_STUCK_HANG:</a>
<a name="ln794">        /* Track chips that are known to have BB hangs related</a>
<a name="ln795">         * to rx_clear stuck low.</a>
<a name="ln796">         */</a>
<a name="ln797">        return HAL_ENOTSUPP;</a>
<a name="ln798">    case HAL_CAP_MAC_HANG:</a>
<a name="ln799">        /* Track chips that are known to have MAC hangs.</a>
<a name="ln800">         */</a>
<a name="ln801">        return HAL_OK;</a>
<a name="ln802">    case HAL_CAP_RIFS_RX_ENABLED:</a>
<a name="ln803">        /* Is RIFS RX currently enabled */</a>
<a name="ln804">        return (ahp-&gt;ah_rifs_enabled == AH_TRUE) ?  HAL_OK : HAL_ENOTSUPP;</a>
<a name="ln805">#if 0</a>
<a name="ln806">    case HAL_CAP_ANT_CFG_2GHZ:</a>
<a name="ln807">        *result = p_cap-&gt;halNumAntCfg2Ghz;</a>
<a name="ln808">        return HAL_OK;</a>
<a name="ln809">    case HAL_CAP_ANT_CFG_5GHZ:</a>
<a name="ln810">        *result = p_cap-&gt;halNumAntCfg5Ghz;</a>
<a name="ln811">        return HAL_OK;</a>
<a name="ln812">    case HAL_CAP_RX_STBC:</a>
<a name="ln813">        *result = p_cap-&gt;hal_rx_stbc_support;</a>
<a name="ln814">        return HAL_OK;</a>
<a name="ln815">    case HAL_CAP_TX_STBC:</a>
<a name="ln816">        *result = p_cap-&gt;hal_tx_stbc_support;</a>
<a name="ln817">        return HAL_OK;</a>
<a name="ln818">#endif</a>
<a name="ln819">    case HAL_CAP_LDPC:</a>
<a name="ln820">        *result = p_cap-&gt;halLDPCSupport;</a>
<a name="ln821">        return HAL_OK;</a>
<a name="ln822">    case HAL_CAP_DYNAMIC_SMPS:</a>
<a name="ln823">        return HAL_OK;</a>
<a name="ln824">    case HAL_CAP_DS:</a>
<a name="ln825">        return (AR_SREV_HORNET(ah) || AR_SREV_POSEIDON(ah) || AR_SREV_APHRODITE(ah) ||</a>
<a name="ln826">                (p_cap-&gt;halTxChainMask &amp; 0x3) != 0x3 ||</a>
<a name="ln827">                (p_cap-&gt;halRxChainMask &amp; 0x3) != 0x3) ?</a>
<a name="ln828">            HAL_ENOTSUPP : HAL_OK;</a>
<a name="ln829">    case HAL_CAP_TS:</a>
<a name="ln830">        return (AR_SREV_HORNET(ah) || AR_SREV_POSEIDON(ah) || AR_SREV_APHRODITE(ah) ||</a>
<a name="ln831">                (p_cap-&gt;halTxChainMask &amp; 0x7) != 0x7 ||</a>
<a name="ln832">                (p_cap-&gt;halRxChainMask &amp; 0x7) != 0x7) ?</a>
<a name="ln833">            HAL_ENOTSUPP : HAL_OK;</a>
<a name="ln834">    case HAL_CAP_OL_PWRCTRL:</a>
<a name="ln835">        return (ar9300_eeprom_get(ahp, EEP_OL_PWRCTRL)) ?</a>
<a name="ln836">            HAL_OK : HAL_ENOTSUPP;</a>
<a name="ln837">    case HAL_CAP_CRDC:</a>
<a name="ln838">#if ATH_SUPPORT_CRDC</a>
<a name="ln839">        return (AR_SREV_WASP(ah) &amp;&amp; </a>
<a name="ln840">                ah-&gt;ah_config.ath_hal_crdc_enable) ? </a>
<a name="ln841">                    HAL_OK : HAL_ENOTSUPP;</a>
<a name="ln842">#else</a>
<a name="ln843">        return HAL_ENOTSUPP;</a>
<a name="ln844">#endif</a>
<a name="ln845">#if 0</a>
<a name="ln846">    case HAL_CAP_MAX_WEP_TKIP_HT20_TX_RATEKBPS:</a>
<a name="ln847">        *result = (u_int32_t)(-1);</a>
<a name="ln848">        return HAL_OK;</a>
<a name="ln849">    case HAL_CAP_MAX_WEP_TKIP_HT40_TX_RATEKBPS:</a>
<a name="ln850">        *result = (u_int32_t)(-1);</a>
<a name="ln851">        return HAL_OK;</a>
<a name="ln852">#endif</a>
<a name="ln853">    case HAL_CAP_BB_PANIC_WATCHDOG:</a>
<a name="ln854">        return HAL_OK;</a>
<a name="ln855">    case HAL_CAP_PHYRESTART_CLR_WAR:</a>
<a name="ln856">        if ((AH_PRIVATE((ah))-&gt;ah_macVersion == AR_SREV_VERSION_OSPREY) &amp;&amp;</a>
<a name="ln857">            (AH_PRIVATE((ah))-&gt;ah_macRev &lt; AR_SREV_REVISION_AR9580_10)) </a>
<a name="ln858">        {</a>
<a name="ln859">            return HAL_OK;</a>
<a name="ln860">        }</a>
<a name="ln861">        else</a>
<a name="ln862">        {</a>
<a name="ln863">            return HAL_ENOTSUPP;</a>
<a name="ln864">        }</a>
<a name="ln865">    case HAL_CAP_ENTERPRISE_MODE:</a>
<a name="ln866">        *result = ahp-&gt;ah_enterprise_mode &gt;&gt; 16;</a>
<a name="ln867">        /*</a>
<a name="ln868">         * WAR for EV 77658 - Add delimiters to first sub-frame when using</a>
<a name="ln869">         * RTS/CTS with aggregation and non-enterprise Osprey.</a>
<a name="ln870">         *</a>
<a name="ln871">         * Bug fixed in AR9580/Peacock, Wasp1.1 and later</a>
<a name="ln872">         */</a>
<a name="ln873">        if ((ahp-&gt;ah_enterprise_mode &amp; AR_ENT_OTP_MIN_PKT_SIZE_DISABLE) &amp;&amp;</a>
<a name="ln874">                !AR_SREV_AR9580_10_OR_LATER(ah) &amp;&amp; (!AR_SREV_WASP(ah) ||</a>
<a name="ln875">                AR_SREV_WASP_10(ah))) {</a>
<a name="ln876">            *result |= AH_ENT_RTSCTS_DELIM_WAR;</a>
<a name="ln877">        }</a>
<a name="ln878">        return HAL_OK;</a>
<a name="ln879">    case HAL_CAP_LDPCWAR:</a>
<a name="ln880">        /* WAR for RIFS+LDPC issue is required for all chips currently </a>
<a name="ln881">         * supported by ar9300 HAL.</a>
<a name="ln882">         */</a>
<a name="ln883">        return HAL_OK;    </a>
<a name="ln884">    case HAL_CAP_ENABLE_APM:</a>
<a name="ln885">        *result = p_cap-&gt;halApmEnable;</a>
<a name="ln886">        return HAL_OK;</a>
<a name="ln887">    case HAL_CAP_PCIE_LCR_EXTSYNC_EN:</a>
<a name="ln888">        return (p_cap-&gt;hal_pcie_lcr_extsync_en == AH_TRUE) ? HAL_OK : HAL_ENOTSUPP;</a>
<a name="ln889">    case HAL_CAP_PCIE_LCR_OFFSET:</a>
<a name="ln890">        *result = p_cap-&gt;hal_pcie_lcr_offset;</a>
<a name="ln891">        return HAL_OK;</a>
<a name="ln892">    case HAL_CAP_SMARTANTENNA:</a>
<a name="ln893">        /* FIXME A request is pending with h/w team to add feature bit in</a>
<a name="ln894">         * caldata to detect if board has smart antenna or not, once added</a>
<a name="ln895">         * we need to fix his piece of code to read and return value without</a>
<a name="ln896">         * any compile flags</a>
<a name="ln897">         */</a>
<a name="ln898">#if UMAC_SUPPORT_SMARTANTENNA</a>
<a name="ln899">        /* enable smart antenna for  Peacock, Wasp and scorpion </a>
<a name="ln900">           for future chips need to modify */</a>
<a name="ln901">        if (AR_SREV_AR9580_10(ah) || (AR_SREV_WASP(ah)) || AR_SREV_SCORPION(ah)) {</a>
<a name="ln902">            return HAL_OK;</a>
<a name="ln903">        } else {</a>
<a name="ln904">            return HAL_ENOTSUPP;</a>
<a name="ln905">        }</a>
<a name="ln906">#else</a>
<a name="ln907">        return HAL_ENOTSUPP;</a>
<a name="ln908">#endif</a>
<a name="ln909"> </a>
<a name="ln910">#ifdef ATH_TRAFFIC_FAST_RECOVER</a>
<a name="ln911">    case HAL_CAP_TRAFFIC_FAST_RECOVER:</a>
<a name="ln912">        if (AR_SREV_HORNET(ah) || AR_SREV_POSEIDON(ah) || AR_SREV_WASP_11(ah)) {</a>
<a name="ln913">            return HAL_OK;</a>
<a name="ln914">        } else {</a>
<a name="ln915">            return HAL_ENOTSUPP;</a>
<a name="ln916">        }</a>
<a name="ln917">#endif</a>
<a name="ln918"> </a>
<a name="ln919">    /* FreeBSD ANI */</a>
<a name="ln920">    case HAL_CAP_INTMIT:            /* interference mitigation */</a>
<a name="ln921">            switch (capability) {</a>
<a name="ln922">            case HAL_CAP_INTMIT_PRESENT:            /* hardware capability */</a>
<a name="ln923">                    return HAL_OK;</a>
<a name="ln924">            case HAL_CAP_INTMIT_ENABLE:</a>
<a name="ln925">                    return (ahp-&gt;ah_proc_phy_err &amp; HAL_PROCESS_ANI) ?</a>
<a name="ln926">                            HAL_OK : HAL_ENXIO;</a>
<a name="ln927">            case HAL_CAP_INTMIT_NOISE_IMMUNITY_LEVEL:</a>
<a name="ln928">            case HAL_CAP_INTMIT_OFDM_WEAK_SIGNAL_LEVEL:</a>
<a name="ln929">//            case HAL_CAP_INTMIT_CCK_WEAK_SIGNAL_THR:</a>
<a name="ln930">            case HAL_CAP_INTMIT_FIRSTEP_LEVEL:</a>
<a name="ln931">            case HAL_CAP_INTMIT_SPUR_IMMUNITY_LEVEL:</a>
<a name="ln932">                    ani = ar9300_ani_get_current_state(ah);</a>
<a name="ln933">                    if (ani == AH_NULL)</a>
<a name="ln934">                            return HAL_ENXIO;</a>
<a name="ln935">                    switch (capability) {</a>
<a name="ln936">                    /* XXX AR9300 HAL has OFDM/CCK noise immunity level params? */</a>
<a name="ln937">                    case 2: *result = ani-&gt;ofdm_noise_immunity_level; break;</a>
<a name="ln938">                    case 3: *result = !ani-&gt;ofdm_weak_sig_detect_off; break;</a>
<a name="ln939"> //                   case 4: *result = ani-&gt;cck_weak_sig_threshold; break;</a>
<a name="ln940">                    case 5: *result = ani-&gt;firstep_level; break;</a>
<a name="ln941">                    case 6: *result = ani-&gt;spur_immunity_level; break;</a>
<a name="ln942">                    }</a>
<a name="ln943">                    return HAL_OK;</a>
<a name="ln944">            }</a>
<a name="ln945">            return HAL_EINVAL;</a>
<a name="ln946">    case HAL_CAP_ENFORCE_TXOP:</a>
<a name="ln947">        if (capability == 0)</a>
<a name="ln948">            return (HAL_OK);</a>
<a name="ln949">        if (capability != 1)</a>
<a name="ln950">            return (HAL_ENOTSUPP);</a>
<a name="ln951">        (*result) = !! (ahp-&gt;ah_misc_mode &amp; AR_PCU_TXOP_TBTT_LIMIT_ENA);</a>
<a name="ln952">        return (HAL_OK);</a>
<a name="ln953">    case HAL_CAP_TOA_LOCATIONING:</a>
<a name="ln954">        if (capability == 0)</a>
<a name="ln955">            return HAL_OK;</a>
<a name="ln956">        if (capability == 2) {</a>
<a name="ln957">            *result = ar9300_read_loc_timer(ah);</a>
<a name="ln958">            return (HAL_OK);</a>
<a name="ln959">        }</a>
<a name="ln960">        return HAL_ENOTSUPP;</a>
<a name="ln961">    default:</a>
<a name="ln962">        return ath_hal_getcapability(ah, type, capability, result);</a>
<a name="ln963">    }</a>
<a name="ln964">}</a>
<a name="ln965"> </a>
<a name="ln966">HAL_BOOL</a>
<a name="ln967">ar9300_set_capability(struct ath_hal *ah, HAL_CAPABILITY_TYPE type,</a>
<a name="ln968">        u_int32_t capability, u_int32_t setting, HAL_STATUS *status)</a>
<a name="ln969">{</a>
<a name="ln970">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln971">    const HAL_CAPABILITIES *p_cap = &amp;AH_PRIVATE(ah)-&gt;ah_caps;</a>
<a name="ln972">    u_int32_t v;</a>
<a name="ln973"> </a>
<a name="ln974">    switch (type) {</a>
<a name="ln975">    case HAL_CAP_TKIP_SPLIT:        /* hardware TKIP uses split keys */</a>
<a name="ln976">        if (! p_cap-&gt;halTkipMicTxRxKeySupport)</a>
<a name="ln977">            return AH_FALSE;</a>
<a name="ln978"> </a>
<a name="ln979">        if (setting)</a>
<a name="ln980">            ahp-&gt;ah_misc_mode &amp;= ~AR_PCU_MIC_NEW_LOC_ENA;</a>
<a name="ln981">        else</a>
<a name="ln982">            ahp-&gt;ah_misc_mode |= AR_PCU_MIC_NEW_LOC_ENA;</a>
<a name="ln983"> </a>
<a name="ln984">        OS_REG_WRITE(ah, AR_PCU_MISC, ahp-&gt;ah_misc_mode);</a>
<a name="ln985">        return AH_TRUE;</a>
<a name="ln986"> </a>
<a name="ln987">    case HAL_CAP_TKIP_MIC:          /* handle TKIP MIC in hardware */</a>
<a name="ln988">        if (setting) {</a>
<a name="ln989">            ahp-&gt;ah_sta_id1_defaults |= AR_STA_ID1_CRPT_MIC_ENABLE;</a>
<a name="ln990">        } else {</a>
<a name="ln991">            ahp-&gt;ah_sta_id1_defaults &amp;= ~AR_STA_ID1_CRPT_MIC_ENABLE;</a>
<a name="ln992">        }</a>
<a name="ln993">        return AH_TRUE;</a>
<a name="ln994">    case HAL_CAP_DIVERSITY:</a>
<a name="ln995">        v = OS_REG_READ(ah, AR_PHY_CCK_DETECT);</a>
<a name="ln996">        if (setting) {</a>
<a name="ln997">            v |= AR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV;</a>
<a name="ln998">        } else {</a>
<a name="ln999">            v &amp;= ~AR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV;</a>
<a name="ln1000">        }</a>
<a name="ln1001">        OS_REG_WRITE(ah, AR_PHY_CCK_DETECT, v);</a>
<a name="ln1002">        return AH_TRUE;</a>
<a name="ln1003">    case HAL_CAP_DIAG:              /* hardware diagnostic support */</a>
<a name="ln1004">        /*</a>
<a name="ln1005">         * NB: could split this up into virtual capabilities,</a>
<a name="ln1006">         *     (e.g. 1 =&gt; ACK, 2 =&gt; CTS, etc.) but it hardly</a>
<a name="ln1007">         *     seems worth the additional complexity.</a>
<a name="ln1008">         */</a>
<a name="ln1009">#ifdef AH_DEBUG</a>
<a name="ln1010">        AH_PRIVATE(ah)-&gt;ah_diagreg = setting;</a>
<a name="ln1011">#else</a>
<a name="ln1012">        AH_PRIVATE(ah)-&gt;ah_diagreg = setting &amp; 0x6;     /* ACK+CTS */</a>
<a name="ln1013">#endif</a>
<a name="ln1014">        OS_REG_WRITE(ah, AR_DIAG_SW, AH_PRIVATE(ah)-&gt;ah_diagreg);</a>
<a name="ln1015">        return AH_TRUE;</a>
<a name="ln1016">    case HAL_CAP_TPC:</a>
<a name="ln1017">        ah-&gt;ah_config.ath_hal_desc_tpc = (setting != 0);</a>
<a name="ln1018">        return AH_TRUE;</a>
<a name="ln1019">    case HAL_CAP_MCAST_KEYSRCH:     /* multicast frame keycache search */</a>
<a name="ln1020">        if (setting) {</a>
<a name="ln1021">            ahp-&gt;ah_sta_id1_defaults |= AR_STA_ID1_MCAST_KSRCH;</a>
<a name="ln1022">        } else {</a>
<a name="ln1023">            ahp-&gt;ah_sta_id1_defaults &amp;= ~AR_STA_ID1_MCAST_KSRCH;</a>
<a name="ln1024">        }</a>
<a name="ln1025">        return AH_TRUE;</a>
<a name="ln1026">    case HAL_CAP_TSF_ADJUST:        /* hardware has beacon tsf adjust */</a>
<a name="ln1027">        if (p_cap-&gt;halTsfAddSupport) {</a>
<a name="ln1028">            if (setting) {</a>
<a name="ln1029">                ahp-&gt;ah_misc_mode |= AR_PCU_TX_ADD_TSF;</a>
<a name="ln1030">            } else {</a>
<a name="ln1031">                ahp-&gt;ah_misc_mode &amp;= ~AR_PCU_TX_ADD_TSF;</a>
<a name="ln1032">            }</a>
<a name="ln1033">            return AH_TRUE;</a>
<a name="ln1034">        }</a>
<a name="ln1035">        return AH_FALSE;</a>
<a name="ln1036"> </a>
<a name="ln1037">    /* FreeBSD interrupt mitigation / ANI */</a>
<a name="ln1038">    case HAL_CAP_INTMIT: {          /* interference mitigation */</a>
<a name="ln1039">            /* This maps the public ANI commands to the internal ANI commands */</a>
<a name="ln1040">            /* Private: HAL_ANI_CMD; Public: HAL_CAP_INTMIT_CMD */</a>
<a name="ln1041">            static const HAL_ANI_CMD cmds[] = {</a>
<a name="ln1042">                    HAL_ANI_PRESENT,</a>
<a name="ln1043">                    HAL_ANI_MODE,</a>
<a name="ln1044">                    HAL_ANI_NOISE_IMMUNITY_LEVEL,</a>
<a name="ln1045">                    HAL_ANI_OFDM_WEAK_SIGNAL_DETECTION,</a>
<a name="ln1046">                    HAL_ANI_CCK_WEAK_SIGNAL_THR,</a>
<a name="ln1047">                    HAL_ANI_FIRSTEP_LEVEL,</a>
<a name="ln1048">                    HAL_ANI_SPUR_IMMUNITY_LEVEL,</a>
<a name="ln1049">            };</a>
<a name="ln1050">#define N(a)    (sizeof(a) / sizeof(a[0]))</a>
<a name="ln1051">            return capability &lt; N(cmds) ?</a>
<a name="ln1052">                    ar9300_ani_control(ah, cmds[capability], setting) :</a>
<a name="ln1053">                    AH_FALSE;</a>
<a name="ln1054">#undef N</a>
<a name="ln1055">    }</a>
<a name="ln1056"> </a>
<a name="ln1057">    case HAL_CAP_RXBUFSIZE:         /* set MAC receive buffer size */</a>
<a name="ln1058">        ahp-&gt;rx_buf_size = setting &amp; AR_DATABUF_MASK;</a>
<a name="ln1059">        OS_REG_WRITE(ah, AR_DATABUF, ahp-&gt;rx_buf_size);</a>
<a name="ln1060">        return AH_TRUE;</a>
<a name="ln1061"> </a>
<a name="ln1062">    case HAL_CAP_ENFORCE_TXOP:</a>
<a name="ln1063">        if (capability != 1)</a>
<a name="ln1064">            return AH_FALSE;</a>
<a name="ln1065">        if (setting) {</a>
<a name="ln1066">            ahp-&gt;ah_misc_mode |= AR_PCU_TXOP_TBTT_LIMIT_ENA;</a>
<a name="ln1067">            OS_REG_SET_BIT(ah, AR_PCU_MISC, AR_PCU_TXOP_TBTT_LIMIT_ENA);</a>
<a name="ln1068">        } else {</a>
<a name="ln1069">            ahp-&gt;ah_misc_mode &amp;= ~AR_PCU_TXOP_TBTT_LIMIT_ENA;</a>
<a name="ln1070">            OS_REG_CLR_BIT(ah, AR_PCU_MISC, AR_PCU_TXOP_TBTT_LIMIT_ENA);</a>
<a name="ln1071">        }</a>
<a name="ln1072">        return AH_TRUE;</a>
<a name="ln1073"> </a>
<a name="ln1074">    case HAL_CAP_TOA_LOCATIONING:</a>
<a name="ln1075">        if (capability == 0)</a>
<a name="ln1076">            return AH_TRUE;</a>
<a name="ln1077">        if (capability == 1) {</a>
<a name="ln1078">            ar9300_update_loc_ctl_reg(ah, setting);</a>
<a name="ln1079">            return AH_TRUE;</a>
<a name="ln1080">        }</a>
<a name="ln1081">        return AH_FALSE;</a>
<a name="ln1082">        /* fall thru... */</a>
<a name="ln1083">    default:</a>
<a name="ln1084">        return ath_hal_setcapability(ah, type, capability, setting, status);</a>
<a name="ln1085">    }</a>
<a name="ln1086">}</a>
<a name="ln1087"> </a>
<a name="ln1088">#ifdef AH_DEBUG</a>
<a name="ln1089">static void</a>
<a name="ln1090">ar9300_print_reg(struct ath_hal *ah, u_int32_t args)</a>
<a name="ln1091">{</a>
<a name="ln1092">    u_int32_t i = 0;</a>
<a name="ln1093"> </a>
<a name="ln1094">    /* Read 0x80d0 to trigger pcie analyzer */</a>
<a name="ln1095">    HALDEBUG(ah, HAL_DEBUG_PRINT_REG,</a>
<a name="ln1096">        &quot;0x%04x 0x%08x\n&quot;, 0x80d0, OS_REG_READ(ah, 0x80d0));</a>
<a name="ln1097"> </a>
<a name="ln1098">    if (args &amp; HAL_DIAG_PRINT_REG_COUNTER) {</a>
<a name="ln1099">        struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln1100">        u_int32_t tf, rf, rc, cc;</a>
<a name="ln1101"> </a>
<a name="ln1102">        tf = OS_REG_READ(ah, AR_TFCNT);</a>
<a name="ln1103">        rf = OS_REG_READ(ah, AR_RFCNT);</a>
<a name="ln1104">        rc = OS_REG_READ(ah, AR_RCCNT);</a>
<a name="ln1105">        cc = OS_REG_READ(ah, AR_CCCNT);</a>
<a name="ln1106"> </a>
<a name="ln1107">        HALDEBUG(ah, HAL_DEBUG_PRINT_REG,</a>
<a name="ln1108">            &quot;AR_TFCNT Diff= 0x%x\n&quot;, tf - ahp-&gt;last_tf);</a>
<a name="ln1109">        HALDEBUG(ah, HAL_DEBUG_PRINT_REG,</a>
<a name="ln1110">            &quot;AR_RFCNT Diff= 0x%x\n&quot;, rf - ahp-&gt;last_rf);</a>
<a name="ln1111">        HALDEBUG(ah, HAL_DEBUG_PRINT_REG,</a>
<a name="ln1112">            &quot;AR_RCCNT Diff= 0x%x\n&quot;, rc - ahp-&gt;last_rc);</a>
<a name="ln1113">        HALDEBUG(ah, HAL_DEBUG_PRINT_REG,</a>
<a name="ln1114">            &quot;AR_CCCNT Diff= 0x%x\n&quot;, cc - ahp-&gt;last_cc);</a>
<a name="ln1115"> </a>
<a name="ln1116">        ahp-&gt;last_tf = tf;</a>
<a name="ln1117">        ahp-&gt;last_rf = rf;</a>
<a name="ln1118">        ahp-&gt;last_rc = rc;</a>
<a name="ln1119">        ahp-&gt;last_cc = cc;</a>
<a name="ln1120"> </a>
<a name="ln1121">        HALDEBUG(ah, HAL_DEBUG_PRINT_REG,</a>
<a name="ln1122">            &quot;DMADBG0 = 0x%x\n&quot;, OS_REG_READ(ah, AR_DMADBG_0));</a>
<a name="ln1123">        HALDEBUG(ah, HAL_DEBUG_PRINT_REG,</a>
<a name="ln1124">            &quot;DMADBG1 = 0x%x\n&quot;, OS_REG_READ(ah, AR_DMADBG_1));</a>
<a name="ln1125">        HALDEBUG(ah, HAL_DEBUG_PRINT_REG,</a>
<a name="ln1126">            &quot;DMADBG2 = 0x%x\n&quot;, OS_REG_READ(ah, AR_DMADBG_2));</a>
<a name="ln1127">        HALDEBUG(ah, HAL_DEBUG_PRINT_REG,</a>
<a name="ln1128">            &quot;DMADBG3 = 0x%x\n&quot;, OS_REG_READ(ah, AR_DMADBG_3));</a>
<a name="ln1129">        HALDEBUG(ah, HAL_DEBUG_PRINT_REG,</a>
<a name="ln1130">            &quot;DMADBG4 = 0x%x\n&quot;, OS_REG_READ(ah, AR_DMADBG_4));</a>
<a name="ln1131">        HALDEBUG(ah, HAL_DEBUG_PRINT_REG,</a>
<a name="ln1132">            &quot;DMADBG5 = 0x%x\n&quot;, OS_REG_READ(ah, AR_DMADBG_5));</a>
<a name="ln1133">        HALDEBUG(ah, HAL_DEBUG_PRINT_REG,</a>
<a name="ln1134">            &quot;DMADBG6 = 0x%x\n&quot;, OS_REG_READ(ah, AR_DMADBG_6));</a>
<a name="ln1135">        HALDEBUG(ah, HAL_DEBUG_PRINT_REG,</a>
<a name="ln1136">            &quot;DMADBG7 = 0x%x\n&quot;, OS_REG_READ(ah, AR_DMADBG_7));</a>
<a name="ln1137">    }</a>
<a name="ln1138"> </a>
<a name="ln1139">    if (args &amp; HAL_DIAG_PRINT_REG_ALL) {</a>
<a name="ln1140">        for (i = 0x8; i &lt;= 0xB8; i += sizeof(u_int32_t)) {</a>
<a name="ln1141">            HALDEBUG(ah, HAL_DEBUG_PRINT_REG, &quot;0x%04x 0x%08x\n&quot;,</a>
<a name="ln1142">                i, OS_REG_READ(ah, i));</a>
<a name="ln1143">        }</a>
<a name="ln1144"> </a>
<a name="ln1145">        for (i = 0x800; i &lt;= (0x800 + (10 &lt;&lt; 2)); i += sizeof(u_int32_t)) {</a>
<a name="ln1146">            HALDEBUG(ah, HAL_DEBUG_PRINT_REG, &quot;0x%04x 0x%08x\n&quot;,</a>
<a name="ln1147">                i, OS_REG_READ(ah, i));</a>
<a name="ln1148">        }</a>
<a name="ln1149"> </a>
<a name="ln1150">        HALDEBUG(ah, HAL_DEBUG_PRINT_REG,</a>
<a name="ln1151">            &quot;0x%04x 0x%08x\n&quot;, 0x840, OS_REG_READ(ah, i));</a>
<a name="ln1152"> </a>
<a name="ln1153">        HALDEBUG(ah, HAL_DEBUG_PRINT_REG,</a>
<a name="ln1154">            &quot;0x%04x 0x%08x\n&quot;, 0x880, OS_REG_READ(ah, i));</a>
<a name="ln1155"> </a>
<a name="ln1156">        for (i = 0x8C0; i &lt;= (0x8C0 + (10 &lt;&lt; 2)); i += sizeof(u_int32_t)) {</a>
<a name="ln1157">            HALDEBUG(ah, HAL_DEBUG_PRINT_REG, &quot;0x%04x 0x%08x\n&quot;,</a>
<a name="ln1158">                i, OS_REG_READ(ah, i));</a>
<a name="ln1159">        }</a>
<a name="ln1160"> </a>
<a name="ln1161">        for (i = 0x1F00; i &lt;= 0x1F04; i += sizeof(u_int32_t)) {</a>
<a name="ln1162">            HALDEBUG(ah, HAL_DEBUG_PRINT_REG, &quot;0x%04x 0x%08x\n&quot;,</a>
<a name="ln1163">                i, OS_REG_READ(ah, i));</a>
<a name="ln1164">        }</a>
<a name="ln1165"> </a>
<a name="ln1166">        for (i = 0x4000; i &lt;= 0x408C; i += sizeof(u_int32_t)) {</a>
<a name="ln1167">            HALDEBUG(ah, HAL_DEBUG_PRINT_REG, &quot;0x%04x 0x%08x\n&quot;,</a>
<a name="ln1168">                i, OS_REG_READ(ah, i));</a>
<a name="ln1169">        }</a>
<a name="ln1170"> </a>
<a name="ln1171">        for (i = 0x5000; i &lt;= 0x503C; i += sizeof(u_int32_t)) {</a>
<a name="ln1172">            HALDEBUG(ah, HAL_DEBUG_PRINT_REG, &quot;0x%04x 0x%08x\n&quot;,</a>
<a name="ln1173">                i, OS_REG_READ(ah, i));</a>
<a name="ln1174">        }</a>
<a name="ln1175"> </a>
<a name="ln1176">        for (i = 0x7040; i &lt;= 0x7058; i += sizeof(u_int32_t)) {</a>
<a name="ln1177">            HALDEBUG(ah, HAL_DEBUG_PRINT_REG, &quot;0x%04x 0x%08x\n&quot;,</a>
<a name="ln1178">                i, OS_REG_READ(ah, i));</a>
<a name="ln1179">        }</a>
<a name="ln1180"> </a>
<a name="ln1181">        for (i = 0x8000; i &lt;= 0x8098; i += sizeof(u_int32_t)) {</a>
<a name="ln1182">            HALDEBUG(ah, HAL_DEBUG_PRINT_REG, &quot;0x%04x 0x%08x\n&quot;,</a>
<a name="ln1183">                i, OS_REG_READ(ah, i));</a>
<a name="ln1184">        }</a>
<a name="ln1185"> </a>
<a name="ln1186">        for (i = 0x80D4; i &lt;= 0x8200; i += sizeof(u_int32_t)) {</a>
<a name="ln1187">            HALDEBUG(ah, HAL_DEBUG_PRINT_REG, &quot;0x%04x 0x%08x\n&quot;,</a>
<a name="ln1188">                i, OS_REG_READ(ah, i));</a>
<a name="ln1189">        }</a>
<a name="ln1190"> </a>
<a name="ln1191">        for (i = 0x8240; i &lt;= 0x97FC; i += sizeof(u_int32_t)) {</a>
<a name="ln1192">            HALDEBUG(ah, HAL_DEBUG_PRINT_REG, &quot;0x%04x 0x%08x\n&quot;,</a>
<a name="ln1193">                i, OS_REG_READ(ah, i));</a>
<a name="ln1194">        }</a>
<a name="ln1195"> </a>
<a name="ln1196">        for (i = 0x9800; i &lt;= 0x99f0; i += sizeof(u_int32_t)) {</a>
<a name="ln1197">            HALDEBUG(ah, HAL_DEBUG_PRINT_REG, &quot;0x%04x 0x%08x\n&quot;,</a>
<a name="ln1198">                i, OS_REG_READ(ah, i));</a>
<a name="ln1199">        }</a>
<a name="ln1200"> </a>
<a name="ln1201">        for (i = 0x9c10; i &lt;= 0x9CFC; i += sizeof(u_int32_t)) {</a>
<a name="ln1202">            HALDEBUG(ah, HAL_DEBUG_PRINT_REG, &quot;0x%04x 0x%08x\n&quot;,</a>
<a name="ln1203">                i, OS_REG_READ(ah, i));</a>
<a name="ln1204">        }</a>
<a name="ln1205"> </a>
<a name="ln1206">        for (i = 0xA200; i &lt;= 0xA26C; i += sizeof(u_int32_t)) {</a>
<a name="ln1207">            HALDEBUG(ah, HAL_DEBUG_PRINT_REG, &quot;0x%04x 0x%08x\n&quot;,</a>
<a name="ln1208">                i, OS_REG_READ(ah, i));</a>
<a name="ln1209">        }</a>
<a name="ln1210">    }</a>
<a name="ln1211">}</a>
<a name="ln1212">#endif</a>
<a name="ln1213"> </a>
<a name="ln1214">HAL_BOOL</a>
<a name="ln1215">ar9300_get_diag_state(struct ath_hal *ah, int request,</a>
<a name="ln1216">        const void *args, u_int32_t argsize,</a>
<a name="ln1217">        void **result, u_int32_t *resultsize)</a>
<a name="ln1218">{</a>
<a name="ln1219">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln1220">    struct ar9300_ani_state *ani;</a>
<a name="ln1221"> </a>
<a name="ln1222">    (void) ahp;</a>
<a name="ln1223">    if (ath_hal_getdiagstate(ah, request, args, argsize, result, resultsize)) {</a>
<a name="ln1224">        return AH_TRUE;</a>
<a name="ln1225">    }</a>
<a name="ln1226">    switch (request) {</a>
<a name="ln1227">#ifdef AH_PRIVATE_DIAG</a>
<a name="ln1228">    case HAL_DIAG_EEPROM:</a>
<a name="ln1229">        *result = &amp;ahp-&gt;ah_eeprom;</a>
<a name="ln1230">        *resultsize = sizeof(ar9300_eeprom_t);</a>
<a name="ln1231">        return AH_TRUE;</a>
<a name="ln1232"> </a>
<a name="ln1233">#if 0   /* XXX - TODO */</a>
<a name="ln1234">    case HAL_DIAG_EEPROM_EXP_11A:</a>
<a name="ln1235">    case HAL_DIAG_EEPROM_EXP_11B:</a>
<a name="ln1236">    case HAL_DIAG_EEPROM_EXP_11G:</a>
<a name="ln1237">        pe = &amp;ahp-&gt;ah_mode_power_array2133[request - HAL_DIAG_EEPROM_EXP_11A];</a>
<a name="ln1238">        *result = pe-&gt;p_channels;</a>
<a name="ln1239">        *resultsize = (*result == AH_NULL) ? 0 :</a>
<a name="ln1240">            roundup(sizeof(u_int16_t) * pe-&gt;num_channels,</a>
<a name="ln1241">            sizeof(u_int32_t)) +</a>
<a name="ln1242">                sizeof(EXPN_DATA_PER_CHANNEL_2133) * pe-&gt;num_channels;</a>
<a name="ln1243">        return AH_TRUE;</a>
<a name="ln1244">#endif</a>
<a name="ln1245">    case HAL_DIAG_RFGAIN:</a>
<a name="ln1246">        *result = &amp;ahp-&gt;ah_gain_values;</a>
<a name="ln1247">        *resultsize = sizeof(GAIN_VALUES);</a>
<a name="ln1248">        return AH_TRUE;</a>
<a name="ln1249">    case HAL_DIAG_RFGAIN_CURSTEP:</a>
<a name="ln1250">        *result = (void *) ahp-&gt;ah_gain_values.curr_step;</a>
<a name="ln1251">        *resultsize = (*result == AH_NULL) ?</a>
<a name="ln1252">                0 : sizeof(GAIN_OPTIMIZATION_STEP);</a>
<a name="ln1253">        return AH_TRUE;</a>
<a name="ln1254">#if 0   /* XXX - TODO */</a>
<a name="ln1255">    case HAL_DIAG_PCDAC:</a>
<a name="ln1256">        *result = ahp-&gt;ah_pcdac_table;</a>
<a name="ln1257">        *resultsize = ahp-&gt;ah_pcdac_table_size;</a>
<a name="ln1258">        return AH_TRUE;</a>
<a name="ln1259">#endif</a>
<a name="ln1260">    case HAL_DIAG_ANI_CURRENT:</a>
<a name="ln1261"> </a>
<a name="ln1262">        ani = ar9300_ani_get_current_state(ah);</a>
<a name="ln1263">        if (ani == AH_NULL)</a>
<a name="ln1264">            return AH_FALSE;</a>
<a name="ln1265">        /* Convert ar9300 HAL to FreeBSD HAL ANI state */</a>
<a name="ln1266">        /* XXX TODO: add all of these to the HAL ANI state structure */</a>
<a name="ln1267">        bzero(&amp;ahp-&gt;ext_ani_state, sizeof(ahp-&gt;ext_ani_state));</a>
<a name="ln1268">        /* XXX should this be OFDM or CCK noise immunity level? */</a>
<a name="ln1269">        ahp-&gt;ext_ani_state.noiseImmunityLevel = ani-&gt;ofdm_noise_immunity_level;</a>
<a name="ln1270">        ahp-&gt;ext_ani_state.spurImmunityLevel = ani-&gt;spur_immunity_level;</a>
<a name="ln1271">        ahp-&gt;ext_ani_state.firstepLevel = ani-&gt;firstep_level;</a>
<a name="ln1272">        ahp-&gt;ext_ani_state.ofdmWeakSigDetectOff = ani-&gt;ofdm_weak_sig_detect_off;</a>
<a name="ln1273">        /* mrc_cck_off */</a>
<a name="ln1274">        /* cck_noise_immunity_level */</a>
<a name="ln1275"> </a>
<a name="ln1276">        ahp-&gt;ext_ani_state.listenTime = ani-&gt;listen_time;</a>
<a name="ln1277"> </a>
<a name="ln1278">        *result = &amp;ahp-&gt;ext_ani_state;</a>
<a name="ln1279">        *resultsize = sizeof(ahp-&gt;ext_ani_state);</a>
<a name="ln1280">#if 0</a>
<a name="ln1281">        *result = ar9300_ani_get_current_state(ah);</a>
<a name="ln1282">        *resultsize = (*result == AH_NULL) ?</a>
<a name="ln1283">            0 : sizeof(struct ar9300_ani_state);</a>
<a name="ln1284">#endif</a>
<a name="ln1285">        return AH_TRUE;</a>
<a name="ln1286">    case HAL_DIAG_ANI_STATS:</a>
<a name="ln1287">        *result = ar9300_ani_get_current_stats(ah);</a>
<a name="ln1288">        *resultsize = (*result == AH_NULL) ?</a>
<a name="ln1289">            0 : sizeof(HAL_ANI_STATS);</a>
<a name="ln1290">        return AH_TRUE;</a>
<a name="ln1291">    case HAL_DIAG_ANI_CMD:</a>
<a name="ln1292">        if (argsize != 2*sizeof(u_int32_t)) {</a>
<a name="ln1293">            return AH_FALSE;</a>
<a name="ln1294">        }</a>
<a name="ln1295">        ar9300_ani_control(</a>
<a name="ln1296">            ah, ((const u_int32_t *)args)[0], ((const u_int32_t *)args)[1]);</a>
<a name="ln1297">        return AH_TRUE;</a>
<a name="ln1298">#if 0</a>
<a name="ln1299">    case HAL_DIAG_TXCONT:</a>
<a name="ln1300">        /*AR9300_CONTTXMODE(ah, (struct ath_desc *)args, argsize );*/</a>
<a name="ln1301">        return AH_TRUE;</a>
<a name="ln1302">#endif /* 0 */</a>
<a name="ln1303">#endif /* AH_PRIVATE_DIAG */</a>
<a name="ln1304">    case HAL_DIAG_CHANNELS:</a>
<a name="ln1305">#if 0</a>
<a name="ln1306">        *result = &amp;(ahp-&gt;ah_priv.ah_channels[0]);</a>
<a name="ln1307">        *resultsize =</a>
<a name="ln1308">            sizeof(ahp-&gt;ah_priv.ah_channels[0]) * ahp-&gt;ah_priv.priv.ah_nchan;</a>
<a name="ln1309">#endif</a>
<a name="ln1310">        return AH_TRUE;</a>
<a name="ln1311">#ifdef AH_DEBUG</a>
<a name="ln1312">    case HAL_DIAG_PRINT_REG:</a>
<a name="ln1313">        ar9300_print_reg(ah, *((const u_int32_t *)args));</a>
<a name="ln1314">        return AH_TRUE;</a>
<a name="ln1315">#endif</a>
<a name="ln1316">    default:</a>
<a name="ln1317">        break;</a>
<a name="ln1318">    }</a>
<a name="ln1319"> </a>
<a name="ln1320">    return AH_FALSE;</a>
<a name="ln1321">}</a>
<a name="ln1322"> </a>
<a name="ln1323">void</a>
<a name="ln1324">ar9300_dma_reg_dump(struct ath_hal *ah)</a>
<a name="ln1325">{</a>
<a name="ln1326">#ifdef AH_DEBUG</a>
<a name="ln1327">#define NUM_DMA_DEBUG_REGS  8</a>
<a name="ln1328">#define NUM_QUEUES          10</a>
<a name="ln1329"> </a>
<a name="ln1330">    u_int32_t val[NUM_DMA_DEBUG_REGS];</a>
<a name="ln1331">    int       qcu_offset = 0, dcu_offset = 0;</a>
<a name="ln1332">    u_int32_t *qcu_base  = &amp;val[0], *dcu_base = &amp;val[4], reg;</a>
<a name="ln1333">    int       i, j, k;</a>
<a name="ln1334">    int16_t nfarray[HAL_NUM_NF_READINGS];</a>
<a name="ln1335">#ifdef	ATH_NF_PER_CHAN</a>
<a name="ln1336">    HAL_CHANNEL_INTERNAL *ichan = ath_hal_checkchannel(ah, AH_PRIVATE(ah)-&gt;ah_curchan);</a>
<a name="ln1337">#endif	/* ATH_NF_PER_CHAN */</a>
<a name="ln1338">    HAL_NFCAL_HIST_FULL *h = AH_HOME_CHAN_NFCAL_HIST(ah, ichan);</a>
<a name="ln1339"> </a>
<a name="ln1340">     /* selecting DMA OBS 8 */</a>
<a name="ln1341">    OS_REG_WRITE(ah, AR_MACMISC, </a>
<a name="ln1342">        ((AR_MACMISC_DMA_OBS_LINE_8 &lt;&lt; AR_MACMISC_DMA_OBS_S) | </a>
<a name="ln1343">         (AR_MACMISC_MISC_OBS_BUS_1 &lt;&lt; AR_MACMISC_MISC_OBS_BUS_MSB_S)));</a>
<a name="ln1344"> </a>
<a name="ln1345">    ath_hal_printf(ah, &quot;Raw DMA Debug values:\n&quot;);</a>
<a name="ln1346">    for (i = 0; i &lt; NUM_DMA_DEBUG_REGS; i++) {</a>
<a name="ln1347">        if (i % 4 == 0) {</a>
<a name="ln1348">            ath_hal_printf(ah, &quot;\n&quot;);</a>
<a name="ln1349">        }</a>
<a name="ln1350"> </a>
<a name="ln1351">        val[i] = OS_REG_READ(ah, AR_DMADBG_0 + (i * sizeof(u_int32_t)));</a>
<a name="ln1352">        ath_hal_printf(ah, &quot;%d: %08x &quot;, i, val[i]);</a>
<a name="ln1353">    }</a>
<a name="ln1354"> </a>
<a name="ln1355">    ath_hal_printf(ah, &quot;\n\n&quot;);</a>
<a name="ln1356">    ath_hal_printf(ah, &quot;Num QCU: chain_st fsp_ok fsp_st DCU: chain_st\n&quot;);</a>
<a name="ln1357"> </a>
<a name="ln1358">    for (i = 0; i &lt; NUM_QUEUES; i++, qcu_offset += 4, dcu_offset += 5) {</a>
<a name="ln1359">        if (i == 8) {</a>
<a name="ln1360">            /* only 8 QCU entries in val[0] */</a>
<a name="ln1361">            qcu_offset = 0;</a>
<a name="ln1362">            qcu_base++;</a>
<a name="ln1363">        }</a>
<a name="ln1364"> </a>
<a name="ln1365">        if (i == 6) {</a>
<a name="ln1366">            /* only 6 DCU entries in val[4] */</a>
<a name="ln1367">            dcu_offset = 0;</a>
<a name="ln1368">            dcu_base++;</a>
<a name="ln1369">        }</a>
<a name="ln1370"> </a>
<a name="ln1371">        ath_hal_printf(ah,</a>
<a name="ln1372">            &quot;%2d          %2x      %1x     %2x           %2x\n&quot;,</a>
<a name="ln1373">            i,</a>
<a name="ln1374">            (*qcu_base &amp; (0x7 &lt;&lt; qcu_offset)) &gt;&gt; qcu_offset,</a>
<a name="ln1375">            (*qcu_base &amp; (0x8 &lt;&lt; qcu_offset)) &gt;&gt; (qcu_offset + 3),</a>
<a name="ln1376">            val[2] &amp; (0x7 &lt;&lt; (i * 3)) &gt;&gt; (i * 3),</a>
<a name="ln1377">            (*dcu_base &amp; (0x1f &lt;&lt; dcu_offset)) &gt;&gt; dcu_offset);</a>
<a name="ln1378">    }</a>
<a name="ln1379"> </a>
<a name="ln1380">    ath_hal_printf(ah, &quot;\n&quot;);</a>
<a name="ln1381">    ath_hal_printf(ah,</a>
<a name="ln1382">        &quot;qcu_stitch state:   %2x    qcu_fetch state:        %2x\n&quot;,</a>
<a name="ln1383">        (val[3] &amp; 0x003c0000) &gt;&gt; 18, (val[3] &amp; 0x03c00000) &gt;&gt; 22);</a>
<a name="ln1384">    ath_hal_printf(ah,</a>
<a name="ln1385">        &quot;qcu_complete state: %2x    dcu_complete state:     %2x\n&quot;,</a>
<a name="ln1386">        (val[3] &amp; 0x1c000000) &gt;&gt; 26, (val[6] &amp; 0x3));</a>
<a name="ln1387">    ath_hal_printf(ah,</a>
<a name="ln1388">        &quot;dcu_arb state:      %2x    dcu_fp state:           %2x\n&quot;,</a>
<a name="ln1389">        (val[5] &amp; 0x06000000) &gt;&gt; 25, (val[5] &amp; 0x38000000) &gt;&gt; 27);</a>
<a name="ln1390">    ath_hal_printf(ah,</a>
<a name="ln1391">        &quot;chan_idle_dur:     %3d    chan_idle_dur_valid:     %1d\n&quot;,</a>
<a name="ln1392">        (val[6] &amp; 0x000003fc) &gt;&gt; 2, (val[6] &amp; 0x00000400) &gt;&gt; 10);</a>
<a name="ln1393">    ath_hal_printf(ah,</a>
<a name="ln1394">        &quot;txfifo_valid_0:      %1d    txfifo_valid_1:          %1d\n&quot;,</a>
<a name="ln1395">        (val[6] &amp; 0x00000800) &gt;&gt; 11, (val[6] &amp; 0x00001000) &gt;&gt; 12);</a>
<a name="ln1396">    ath_hal_printf(ah,</a>
<a name="ln1397">        &quot;txfifo_dcu_num_0:   %2d    txfifo_dcu_num_1:       %2d\n&quot;,</a>
<a name="ln1398">        (val[6] &amp; 0x0001e000) &gt;&gt; 13, (val[6] &amp; 0x001e0000) &gt;&gt; 17);</a>
<a name="ln1399">    ath_hal_printf(ah, &quot;pcu observe 0x%x \n&quot;, OS_REG_READ(ah, AR_OBS_BUS_1)); </a>
<a name="ln1400">    ath_hal_printf(ah, &quot;AR_CR 0x%x \n&quot;, OS_REG_READ(ah, AR_CR));</a>
<a name="ln1401"> </a>
<a name="ln1402">    ar9300_upload_noise_floor(ah, 1, nfarray);</a>
<a name="ln1403">    ath_hal_printf(ah, &quot;2G:\n&quot;);</a>
<a name="ln1404">    ath_hal_printf(ah, &quot;Min CCA Out:\n&quot;);</a>
<a name="ln1405">    ath_hal_printf(ah, &quot;\t\tChain 0\t\tChain 1\t\tChain 2\n&quot;);</a>
<a name="ln1406">    ath_hal_printf(ah, &quot;Control:\t%8d\t%8d\t%8d\n&quot;,</a>
<a name="ln1407">                   nfarray[0], nfarray[1], nfarray[2]);</a>
<a name="ln1408">    ath_hal_printf(ah, &quot;Extension:\t%8d\t%8d\t%8d\n\n&quot;,</a>
<a name="ln1409">                   nfarray[3], nfarray[4], nfarray[5]);</a>
<a name="ln1410"> </a>
<a name="ln1411">    ar9300_upload_noise_floor(ah, 0, nfarray);</a>
<a name="ln1412">    ath_hal_printf(ah, &quot;5G:\n&quot;);</a>
<a name="ln1413">    ath_hal_printf(ah, &quot;Min CCA Out:\n&quot;);</a>
<a name="ln1414">    ath_hal_printf(ah, &quot;\t\tChain 0\t\tChain 1\t\tChain 2\n&quot;);</a>
<a name="ln1415">    ath_hal_printf(ah, &quot;Control:\t%8d\t%8d\t%8d\n&quot;,</a>
<a name="ln1416">                   nfarray[0], nfarray[1], nfarray[2]);</a>
<a name="ln1417">    ath_hal_printf(ah, &quot;Extension:\t%8d\t%8d\t%8d\n\n&quot;,</a>
<a name="ln1418">                   nfarray[3], nfarray[4], nfarray[5]);</a>
<a name="ln1419"> </a>
<a name="ln1420">    for (i = 0; i &lt; HAL_NUM_NF_READINGS; i++) {</a>
<a name="ln1421">        ath_hal_printf(ah, &quot;%s Chain %d NF History:\n&quot;,</a>
<a name="ln1422">                       ((i &lt; 3) ? &quot;Control &quot; : &quot;Extension &quot;), i%3);</a>
<a name="ln1423">        for (j = 0, k = h-&gt;base.curr_index;</a>
<a name="ln1424">             j &lt; HAL_NF_CAL_HIST_LEN_FULL;</a>
<a name="ln1425">             j++, k++) {</a>
<a name="ln1426">            ath_hal_printf(ah, &quot;Element %d: %d\n&quot;,</a>
<a name="ln1427">                j, h-&gt;nf_cal_buffer[k % HAL_NF_CAL_HIST_LEN_FULL][i]);</a>
<a name="ln1428">        }</a>
<a name="ln1429">        ath_hal_printf(ah, &quot;Last Programmed NF: %d\n\n&quot;, h-&gt;base.priv_nf[i]);</a>
<a name="ln1430">    }</a>
<a name="ln1431"> </a>
<a name="ln1432">    reg = OS_REG_READ(ah, AR_PHY_FIND_SIG_LOW);</a>
<a name="ln1433">    ath_hal_printf(ah, &quot;FIRStep Low = 0x%x (%d)\n&quot;,</a>
<a name="ln1434">                   MS(reg, AR_PHY_FIND_SIG_LOW_FIRSTEP_LOW),</a>
<a name="ln1435">                   MS(reg, AR_PHY_FIND_SIG_LOW_FIRSTEP_LOW));</a>
<a name="ln1436">    reg = OS_REG_READ(ah, AR_PHY_DESIRED_SZ);</a>
<a name="ln1437">    ath_hal_printf(ah, &quot;Total Desired = 0x%x (%d)\n&quot;,</a>
<a name="ln1438">                   MS(reg, AR_PHY_DESIRED_SZ_TOT_DES),</a>
<a name="ln1439">                   MS(reg, AR_PHY_DESIRED_SZ_TOT_DES));</a>
<a name="ln1440">    ath_hal_printf(ah, &quot;ADC Desired = 0x%x (%d)\n&quot;,</a>
<a name="ln1441">                   MS(reg, AR_PHY_DESIRED_SZ_ADC),</a>
<a name="ln1442">                   MS(reg, AR_PHY_DESIRED_SZ_ADC));</a>
<a name="ln1443">    reg = OS_REG_READ(ah, AR_PHY_FIND_SIG);</a>
<a name="ln1444">    ath_hal_printf(ah, &quot;FIRStep = 0x%x (%d)\n&quot;,</a>
<a name="ln1445">                   MS(reg, AR_PHY_FIND_SIG_FIRSTEP),</a>
<a name="ln1446">                   MS(reg, AR_PHY_FIND_SIG_FIRSTEP));</a>
<a name="ln1447">    reg = OS_REG_READ(ah, AR_PHY_AGC);</a>
<a name="ln1448">    ath_hal_printf(ah, &quot;Coarse High = 0x%x (%d)\n&quot;,</a>
<a name="ln1449">                   MS(reg, AR_PHY_AGC_COARSE_HIGH),</a>
<a name="ln1450">                   MS(reg, AR_PHY_AGC_COARSE_HIGH));</a>
<a name="ln1451">    ath_hal_printf(ah, &quot;Coarse Low = 0x%x (%d)\n&quot;,</a>
<a name="ln1452">                   MS(reg, AR_PHY_AGC_COARSE_LOW),</a>
<a name="ln1453">                   MS(reg, AR_PHY_AGC_COARSE_LOW));</a>
<a name="ln1454">    ath_hal_printf(ah, &quot;Coarse Power Constant = 0x%x (%d)\n&quot;,</a>
<a name="ln1455">                   MS(reg, AR_PHY_AGC_COARSE_PWR_CONST),</a>
<a name="ln1456">                   MS(reg, AR_PHY_AGC_COARSE_PWR_CONST));</a>
<a name="ln1457">    reg = OS_REG_READ(ah, AR_PHY_TIMING5);</a>
<a name="ln1458">    ath_hal_printf(ah, &quot;Enable Cyclic Power Thresh = %d\n&quot;,</a>
<a name="ln1459">                   MS(reg, AR_PHY_TIMING5_CYCPWR_THR1_ENABLE));</a>
<a name="ln1460">    ath_hal_printf(ah, &quot;Cyclic Power Thresh = 0x%x (%d)\n&quot;,</a>
<a name="ln1461">                   MS(reg, AR_PHY_TIMING5_CYCPWR_THR1),</a>
<a name="ln1462">                   MS(reg, AR_PHY_TIMING5_CYCPWR_THR1));</a>
<a name="ln1463">    ath_hal_printf(ah, &quot;Cyclic Power Thresh 1A= 0x%x (%d)\n&quot;,</a>
<a name="ln1464">                   MS(reg, AR_PHY_TIMING5_CYCPWR_THR1A),</a>
<a name="ln1465">                   MS(reg, AR_PHY_TIMING5_CYCPWR_THR1A));</a>
<a name="ln1466">    reg = OS_REG_READ(ah, AR_PHY_DAG_CTRLCCK);</a>
<a name="ln1467">    ath_hal_printf(ah, &quot;Barker RSSI Thresh Enable = %d\n&quot;,</a>
<a name="ln1468">                   MS(reg, AR_PHY_DAG_CTRLCCK_EN_RSSI_THR));</a>
<a name="ln1469">    ath_hal_printf(ah, &quot;Barker RSSI Thresh = 0x%x (%d)\n&quot;,</a>
<a name="ln1470">                   MS(reg, AR_PHY_DAG_CTRLCCK_RSSI_THR),</a>
<a name="ln1471">                   MS(reg, AR_PHY_DAG_CTRLCCK_RSSI_THR));</a>
<a name="ln1472"> </a>
<a name="ln1473"> </a>
<a name="ln1474">    /* Step 1a: Set bit 23 of register 0xa360 to 0 */</a>
<a name="ln1475">    reg = OS_REG_READ(ah, 0xa360);</a>
<a name="ln1476">    reg &amp;= ~0x00800000;</a>
<a name="ln1477">    OS_REG_WRITE(ah, 0xa360, reg);</a>
<a name="ln1478"> </a>
<a name="ln1479">    /* Step 2a: Set register 0xa364 to 0x1000 */</a>
<a name="ln1480">    reg = 0x1000;</a>
<a name="ln1481">    OS_REG_WRITE(ah, 0xa364, reg);</a>
<a name="ln1482"> </a>
<a name="ln1483">    /* Step 3a: Read bits 17:0 of register 0x9c20 */</a>
<a name="ln1484">    reg = OS_REG_READ(ah, 0x9c20);</a>
<a name="ln1485">    reg &amp;= 0x0003ffff;</a>
<a name="ln1486">    ath_hal_printf(ah,</a>
<a name="ln1487">        &quot;%s: Test Control Status [0x1000] 0x9c20[17:0] = 0x%x\n&quot;,</a>
<a name="ln1488">        __func__, reg);</a>
<a name="ln1489"> </a>
<a name="ln1490">    /* Step 1b: Set bit 23 of register 0xa360 to 0 */</a>
<a name="ln1491">    reg = OS_REG_READ(ah, 0xa360);</a>
<a name="ln1492">    reg &amp;= ~0x00800000;</a>
<a name="ln1493">    OS_REG_WRITE(ah, 0xa360, reg);</a>
<a name="ln1494"> </a>
<a name="ln1495">    /* Step 2b: Set register 0xa364 to 0x1400 */</a>
<a name="ln1496">    reg = 0x1400;</a>
<a name="ln1497">    OS_REG_WRITE(ah, 0xa364, reg);</a>
<a name="ln1498"> </a>
<a name="ln1499">    /* Step 3b: Read bits 17:0 of register 0x9c20 */</a>
<a name="ln1500">    reg = OS_REG_READ(ah, 0x9c20);</a>
<a name="ln1501">    reg &amp;= 0x0003ffff;</a>
<a name="ln1502">    ath_hal_printf(ah,</a>
<a name="ln1503">        &quot;%s: Test Control Status [0x1400] 0x9c20[17:0] = 0x%x\n&quot;,</a>
<a name="ln1504">        __func__, reg);</a>
<a name="ln1505"> </a>
<a name="ln1506">    /* Step 1c: Set bit 23 of register 0xa360 to 0 */</a>
<a name="ln1507">    reg = OS_REG_READ(ah, 0xa360);</a>
<a name="ln1508">    reg &amp;= ~0x00800000;</a>
<a name="ln1509">    OS_REG_WRITE(ah, 0xa360, reg);</a>
<a name="ln1510"> </a>
<a name="ln1511">    /* Step 2c: Set register 0xa364 to 0x3C00 */</a>
<a name="ln1512">    reg = 0x3c00;</a>
<a name="ln1513">    OS_REG_WRITE(ah, 0xa364, reg);</a>
<a name="ln1514"> </a>
<a name="ln1515">    /* Step 3c: Read bits 17:0 of register 0x9c20 */</a>
<a name="ln1516">    reg = OS_REG_READ(ah, 0x9c20);</a>
<a name="ln1517">    reg &amp;= 0x0003ffff;</a>
<a name="ln1518">    ath_hal_printf(ah,</a>
<a name="ln1519">        &quot;%s: Test Control Status [0x3C00] 0x9c20[17:0] = 0x%x\n&quot;,</a>
<a name="ln1520">        __func__, reg);</a>
<a name="ln1521"> </a>
<a name="ln1522">    /* Step 1d: Set bit 24 of register 0xa360 to 0 */</a>
<a name="ln1523">    reg = OS_REG_READ(ah, 0xa360);</a>
<a name="ln1524">    reg &amp;= ~0x001040000;</a>
<a name="ln1525">    OS_REG_WRITE(ah, 0xa360, reg);</a>
<a name="ln1526"> </a>
<a name="ln1527">    /* Step 2d: Set register 0xa364 to 0x5005D */</a>
<a name="ln1528">    reg = 0x5005D;</a>
<a name="ln1529">    OS_REG_WRITE(ah, 0xa364, reg);</a>
<a name="ln1530"> </a>
<a name="ln1531">    /* Step 3d: Read bits 17:0 of register 0xa368 */</a>
<a name="ln1532">    reg = OS_REG_READ(ah, 0xa368);</a>
<a name="ln1533">    reg &amp;= 0x0003ffff;</a>
<a name="ln1534">    ath_hal_printf(ah,</a>
<a name="ln1535">        &quot;%s: Test Control Status [0x5005D] 0xa368[17:0] = 0x%x\n&quot;,</a>
<a name="ln1536">        __func__, reg);</a>
<a name="ln1537"> </a>
<a name="ln1538">    /* Step 1e: Set bit 24 of register 0xa360 to 0 */</a>
<a name="ln1539">    reg = OS_REG_READ(ah, 0xa360);</a>
<a name="ln1540">    reg &amp;= ~0x001040000;</a>
<a name="ln1541">    OS_REG_WRITE(ah, 0xa360, reg);</a>
<a name="ln1542"> </a>
<a name="ln1543">    /* Step 2e: Set register 0xa364 to 0x7005D */</a>
<a name="ln1544">    reg = 0x7005D;</a>
<a name="ln1545">    OS_REG_WRITE(ah, 0xa364, reg);</a>
<a name="ln1546"> </a>
<a name="ln1547">    /* Step 3e: Read bits 17:0 of register 0xa368 */</a>
<a name="ln1548">    reg = OS_REG_READ(ah, 0xa368);</a>
<a name="ln1549">    reg &amp;= 0x0003ffff;</a>
<a name="ln1550">    ath_hal_printf(ah,</a>
<a name="ln1551">        &quot;%s: Test Control Status [0x7005D] 0xa368[17:0] = 0x%x\n&quot;,</a>
<a name="ln1552">       __func__, reg);</a>
<a name="ln1553"> </a>
<a name="ln1554">    /* Step 1f: Set bit 24 of register 0xa360 to 0 */</a>
<a name="ln1555">    reg = OS_REG_READ(ah, 0xa360);</a>
<a name="ln1556">    reg &amp;= ~0x001000000;</a>
<a name="ln1557">    reg |= 0x40000;</a>
<a name="ln1558">    OS_REG_WRITE(ah, 0xa360, reg);</a>
<a name="ln1559"> </a>
<a name="ln1560">    /* Step 2f: Set register 0xa364 to 0x3005D */</a>
<a name="ln1561">    reg = 0x3005D;</a>
<a name="ln1562">    OS_REG_WRITE(ah, 0xa364, reg);</a>
<a name="ln1563"> </a>
<a name="ln1564">    /* Step 3f: Read bits 17:0 of register 0xa368 */</a>
<a name="ln1565">    reg = OS_REG_READ(ah, 0xa368);</a>
<a name="ln1566">    reg &amp;= 0x0003ffff;</a>
<a name="ln1567">    ath_hal_printf(ah,</a>
<a name="ln1568">        &quot;%s: Test Control Status [0x3005D] 0xa368[17:0] = 0x%x\n&quot;,</a>
<a name="ln1569">        __func__, reg);</a>
<a name="ln1570"> </a>
<a name="ln1571">    /* Step 1g: Set bit 24 of register 0xa360 to 0 */</a>
<a name="ln1572">    reg = OS_REG_READ(ah, 0xa360);</a>
<a name="ln1573">    reg &amp;= ~0x001000000;</a>
<a name="ln1574">    reg |= 0x40000;</a>
<a name="ln1575">    OS_REG_WRITE(ah, 0xa360, reg);</a>
<a name="ln1576"> </a>
<a name="ln1577">    /* Step 2g: Set register 0xa364 to 0x6005D */</a>
<a name="ln1578">    reg = 0x6005D;</a>
<a name="ln1579">    OS_REG_WRITE(ah, 0xa364, reg);</a>
<a name="ln1580"> </a>
<a name="ln1581">    /* Step 3g: Read bits 17:0 of register 0xa368 */</a>
<a name="ln1582">    reg = OS_REG_READ(ah, 0xa368);</a>
<a name="ln1583">    reg &amp;= 0x0003ffff;</a>
<a name="ln1584">    ath_hal_printf(ah,</a>
<a name="ln1585">        &quot;%s: Test Control Status [0x6005D] 0xa368[17:0] = 0x%x\n&quot;,</a>
<a name="ln1586">        __func__, reg);</a>
<a name="ln1587">#endif /* AH_DEBUG */</a>
<a name="ln1588">}</a>
<a name="ln1589"> </a>
<a name="ln1590">/*</a>
<a name="ln1591"> * Return the busy for rx_frame, rx_clear, and tx_frame</a>
<a name="ln1592"> */</a>
<a name="ln1593">u_int32_t</a>
<a name="ln1594">ar9300_get_mib_cycle_counts_pct(struct ath_hal *ah, u_int32_t *rxc_pcnt,</a>
<a name="ln1595">    u_int32_t *rxf_pcnt, u_int32_t *txf_pcnt)</a>
<a name="ln1596">{</a>
<a name="ln1597">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln1598">    u_int32_t good = 1;</a>
<a name="ln1599"> </a>
<a name="ln1600">    u_int32_t rc = OS_REG_READ(ah, AR_RCCNT);</a>
<a name="ln1601">    u_int32_t rf = OS_REG_READ(ah, AR_RFCNT);</a>
<a name="ln1602">    u_int32_t tf = OS_REG_READ(ah, AR_TFCNT);</a>
<a name="ln1603">    u_int32_t cc = OS_REG_READ(ah, AR_CCCNT); /* read cycles last */</a>
<a name="ln1604"> </a>
<a name="ln1605">    if (ahp-&gt;ah_cycles == 0 || ahp-&gt;ah_cycles &gt; cc) {</a>
<a name="ln1606">        /*</a>
<a name="ln1607">         * Cycle counter wrap (or initial call); it's not possible</a>
<a name="ln1608">         * to accurately calculate a value because the registers</a>
<a name="ln1609">         * right shift rather than wrap--so punt and return 0.</a>
<a name="ln1610">         */</a>
<a name="ln1611">        HALDEBUG(ah, HAL_DEBUG_CHANNEL,</a>
<a name="ln1612">            &quot;%s: cycle counter wrap. ExtBusy = 0\n&quot;, __func__);</a>
<a name="ln1613">        good = 0;</a>
<a name="ln1614">    } else {</a>
<a name="ln1615">        u_int32_t cc_d = cc - ahp-&gt;ah_cycles;</a>
<a name="ln1616">        u_int32_t rc_d = rc - ahp-&gt;ah_rx_clear;</a>
<a name="ln1617">        u_int32_t rf_d = rf - ahp-&gt;ah_rx_frame;</a>
<a name="ln1618">        u_int32_t tf_d = tf - ahp-&gt;ah_tx_frame;</a>
<a name="ln1619"> </a>
<a name="ln1620">        if (cc_d != 0) {</a>
<a name="ln1621">            *rxc_pcnt = rc_d * 100 / cc_d;</a>
<a name="ln1622">            *rxf_pcnt = rf_d * 100 / cc_d;</a>
<a name="ln1623">            *txf_pcnt = tf_d * 100 / cc_d;</a>
<a name="ln1624">        } else {</a>
<a name="ln1625">            good = 0;</a>
<a name="ln1626">        }</a>
<a name="ln1627">    }</a>
<a name="ln1628"> </a>
<a name="ln1629">    ahp-&gt;ah_cycles = cc;</a>
<a name="ln1630">    ahp-&gt;ah_rx_frame = rf;</a>
<a name="ln1631">    ahp-&gt;ah_rx_clear = rc;</a>
<a name="ln1632">    ahp-&gt;ah_tx_frame = tf;</a>
<a name="ln1633"> </a>
<a name="ln1634">    return good;</a>
<a name="ln1635">}</a>
<a name="ln1636"> </a>
<a name="ln1637">/*</a>
<a name="ln1638"> * Return approximation of extension channel busy over an time interval</a>
<a name="ln1639"> * 0% (clear) -&gt; 100% (busy)</a>
<a name="ln1640"> * -1 for invalid estimate </a>
<a name="ln1641"> */</a>
<a name="ln1642">uint32_t</a>
<a name="ln1643">ar9300_get_11n_ext_busy(struct ath_hal *ah)</a>
<a name="ln1644">{</a>
<a name="ln1645">    /*</a>
<a name="ln1646">     * Overflow condition to check before multiplying to get %</a>
<a name="ln1647">     * (x * 100 &gt; 0xFFFFFFFF ) =&gt; (x &gt; 0x28F5C28)</a>
<a name="ln1648">     */</a>
<a name="ln1649">#define OVERFLOW_LIMIT  0x28F5C28</a>
<a name="ln1650">#define ERROR_CODE      -1    </a>
<a name="ln1651"> </a>
<a name="ln1652">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln1653">    u_int32_t busy = 0; /* percentage */</a>
<a name="ln1654">    int8_t busyper = 0;</a>
<a name="ln1655">    u_int32_t cycle_count, ctl_busy, ext_busy;</a>
<a name="ln1656"> </a>
<a name="ln1657">    /* cycle_count will always be the first to wrap; therefore, read it last</a>
<a name="ln1658">     * This sequence of reads is not atomic, and MIB counter wrap</a>
<a name="ln1659">     * could happen during it ?</a>
<a name="ln1660">     */</a>
<a name="ln1661">    ctl_busy = OS_REG_READ(ah, AR_RCCNT);</a>
<a name="ln1662">    ext_busy = OS_REG_READ(ah, AR_EXTRCCNT);</a>
<a name="ln1663">    cycle_count = OS_REG_READ(ah, AR_CCCNT);</a>
<a name="ln1664"> </a>
<a name="ln1665">    if ((ahp-&gt;ah_cycle_count == 0) || (ahp-&gt;ah_cycle_count &gt; cycle_count) ||</a>
<a name="ln1666">        (ahp-&gt;ah_ctl_busy &gt; ctl_busy) || (ahp-&gt;ah_ext_busy &gt; ext_busy))</a>
<a name="ln1667">    {</a>
<a name="ln1668">        /*</a>
<a name="ln1669">         * Cycle counter wrap (or initial call); it's not possible</a>
<a name="ln1670">         * to accurately calculate a value because the registers</a>
<a name="ln1671">         * right shift rather than wrap--so punt and return 0.</a>
<a name="ln1672">         */</a>
<a name="ln1673">        busyper = ERROR_CODE;</a>
<a name="ln1674">        HALDEBUG(ah, HAL_DEBUG_CHANNEL,</a>
<a name="ln1675">            &quot;%s: cycle counter wrap. ExtBusy = 0\n&quot;, __func__);</a>
<a name="ln1676">    } else {</a>
<a name="ln1677">        u_int32_t cycle_delta = cycle_count - ahp-&gt;ah_cycle_count;</a>
<a name="ln1678">        u_int32_t ext_busy_delta = ext_busy - ahp-&gt;ah_ext_busy;</a>
<a name="ln1679"> </a>
<a name="ln1680">        /*</a>
<a name="ln1681">         * Compute extension channel busy percentage</a>
<a name="ln1682">         * Overflow condition: 0xFFFFFFFF &lt; ext_busy_delta * 100</a>
<a name="ln1683">         * Underflow condition/Divide-by-zero: check that cycle_delta &gt;&gt; 7 != 0</a>
<a name="ln1684">         * Will never happen, since (ext_busy_delta &lt; cycle_delta) always,</a>
<a name="ln1685">         * and shift necessitated by large ext_busy_delta.</a>
<a name="ln1686">         * Due to timing difference to read the registers and counter overflow,</a>
<a name="ln1687">         * it may still happen that cycle_delta &gt;&gt; 7 = 0.</a>
<a name="ln1688">         *</a>
<a name="ln1689">         */</a>
<a name="ln1690">        if (cycle_delta) {</a>
<a name="ln1691">            if (ext_busy_delta &gt; OVERFLOW_LIMIT) {</a>
<a name="ln1692">                if (cycle_delta &gt;&gt; 7) {</a>
<a name="ln1693">                    busy = ((ext_busy_delta &gt;&gt; 7) * 100) / (cycle_delta  &gt;&gt; 7);</a>
<a name="ln1694">                } else {</a>
<a name="ln1695">                    busyper = ERROR_CODE;</a>
<a name="ln1696">                }</a>
<a name="ln1697">            } else {</a>
<a name="ln1698">                busy = (ext_busy_delta * 100) / cycle_delta;</a>
<a name="ln1699">            }</a>
<a name="ln1700">        } else {</a>
<a name="ln1701">            busyper = ERROR_CODE;</a>
<a name="ln1702">        }</a>
<a name="ln1703"> </a>
<a name="ln1704">        if (busy &gt; 100) {</a>
<a name="ln1705">            busy = 100;</a>
<a name="ln1706">        }</a>
<a name="ln1707">        if ( busyper != ERROR_CODE ) {</a>
<a name="ln1708">            busyper = busy;</a>
<a name="ln1709">        }</a>
<a name="ln1710">    }</a>
<a name="ln1711"> </a>
<a name="ln1712">    ahp-&gt;ah_cycle_count = cycle_count;</a>
<a name="ln1713">    ahp-&gt;ah_ctl_busy = ctl_busy;</a>
<a name="ln1714">    ahp-&gt;ah_ext_busy = ext_busy;</a>
<a name="ln1715"> </a>
<a name="ln1716">    return busyper;</a>
<a name="ln1717">#undef OVERFLOW_LIMIT</a>
<a name="ln1718">#undef ERROR_CODE    </a>
<a name="ln1719">}</a>
<a name="ln1720"> </a>
<a name="ln1721">/* BB Panic Watchdog declarations */</a>
<a name="ln1722">#define HAL_BB_PANIC_WD_HT20_FACTOR         74  /* 0.74 */</a>
<a name="ln1723">#define HAL_BB_PANIC_WD_HT40_FACTOR         37  /* 0.37 */</a>
<a name="ln1724"> </a>
<a name="ln1725">void</a>
<a name="ln1726">ar9300_config_bb_panic_watchdog(struct ath_hal *ah)</a>
<a name="ln1727">{</a>
<a name="ln1728">#define HAL_BB_PANIC_IDLE_TIME_OUT 0x0a8c0000</a>
<a name="ln1729">    const struct ieee80211_channel *chan = AH_PRIVATE(ah)-&gt;ah_curchan;</a>
<a name="ln1730">    u_int32_t idle_tmo_ms = AH9300(ah)-&gt;ah_bb_panic_timeout_ms;</a>
<a name="ln1731">    u_int32_t val, idle_count;</a>
<a name="ln1732"> </a>
<a name="ln1733">    if (idle_tmo_ms != 0) {</a>
<a name="ln1734">        /* enable IRQ, disable chip-reset for BB panic */</a>
<a name="ln1735">        val = OS_REG_READ(ah, AR_PHY_PANIC_WD_CTL_2) &amp;</a>
<a name="ln1736">            AR_PHY_BB_PANIC_CNTL2_MASK;</a>
<a name="ln1737">        OS_REG_WRITE(ah, AR_PHY_PANIC_WD_CTL_2,</a>
<a name="ln1738">            (val | AR_PHY_BB_PANIC_IRQ_ENABLE) &amp; ~AR_PHY_BB_PANIC_RST_ENABLE);</a>
<a name="ln1739">        /* bound limit to 10 secs */</a>
<a name="ln1740">        if (idle_tmo_ms &gt; 10000) {</a>
<a name="ln1741">            idle_tmo_ms = 10000;</a>
<a name="ln1742">        }</a>
<a name="ln1743">        if (chan != AH_NULL &amp;&amp; IEEE80211_IS_CHAN_HT40(chan)) {</a>
<a name="ln1744">            idle_count = (100 * idle_tmo_ms) / HAL_BB_PANIC_WD_HT40_FACTOR;</a>
<a name="ln1745">        } else {</a>
<a name="ln1746">            idle_count = (100 * idle_tmo_ms) / HAL_BB_PANIC_WD_HT20_FACTOR;</a>
<a name="ln1747">        }</a>
<a name="ln1748">        /*</a>
<a name="ln1749">         * enable panic in non-IDLE mode,</a>
<a name="ln1750">         * disable in IDLE mode,</a>
<a name="ln1751">         * set idle time-out</a>
<a name="ln1752">         */</a>
<a name="ln1753"> </a>
<a name="ln1754">        // EV92527 : Enable IDLE mode panic</a>
<a name="ln1755"> </a>
<a name="ln1756">        OS_REG_WRITE(ah, AR_PHY_PANIC_WD_CTL_1, </a>
<a name="ln1757">                     AR_PHY_BB_PANIC_NON_IDLE_ENABLE | </a>
<a name="ln1758">                     AR_PHY_BB_PANIC_IDLE_ENABLE |</a>
<a name="ln1759">                     (AR_PHY_BB_PANIC_IDLE_MASK &amp; HAL_BB_PANIC_IDLE_TIME_OUT) |</a>
<a name="ln1760">                     (AR_PHY_BB_PANIC_NON_IDLE_MASK &amp; (idle_count &lt;&lt; 2)));</a>
<a name="ln1761">    } else {</a>
<a name="ln1762">        /* disable IRQ, disable chip-reset for BB panic */</a>
<a name="ln1763">        OS_REG_WRITE(ah, AR_PHY_PANIC_WD_CTL_2, </a>
<a name="ln1764">            OS_REG_READ(ah, AR_PHY_PANIC_WD_CTL_2) &amp;</a>
<a name="ln1765">            ~(AR_PHY_BB_PANIC_RST_ENABLE | AR_PHY_BB_PANIC_IRQ_ENABLE));</a>
<a name="ln1766">        /* disable panic in non-IDLE mode, disable in IDLE mode */</a>
<a name="ln1767">        OS_REG_WRITE(ah, AR_PHY_PANIC_WD_CTL_1, </a>
<a name="ln1768">            OS_REG_READ(ah, AR_PHY_PANIC_WD_CTL_1) &amp;</a>
<a name="ln1769">            ~(AR_PHY_BB_PANIC_NON_IDLE_ENABLE | AR_PHY_BB_PANIC_IDLE_ENABLE));</a>
<a name="ln1770">    }</a>
<a name="ln1771"> </a>
<a name="ln1772">    HALDEBUG(ah, HAL_DEBUG_RFPARAM, &quot;%s: %s BB Panic Watchdog tmo=%ums\n&quot;, </a>
<a name="ln1773">             __func__, idle_tmo_ms ? &quot;Enabled&quot; : &quot;Disabled&quot;, idle_tmo_ms);</a>
<a name="ln1774">#undef HAL_BB_PANIC_IDLE_TIME_OUT</a>
<a name="ln1775">}</a>
<a name="ln1776"> </a>
<a name="ln1777"> </a>
<a name="ln1778">void</a>
<a name="ln1779">ar9300_handle_bb_panic(struct ath_hal *ah)</a>
<a name="ln1780">{</a>
<a name="ln1781">    u_int32_t status;</a>
<a name="ln1782">    /*</a>
<a name="ln1783">     * we want to avoid printing in ISR context so we save </a>
<a name="ln1784">     * panic watchdog status to be printed later in DPC context</a>
<a name="ln1785">     */</a>
<a name="ln1786">    AH9300(ah)-&gt;ah_bb_panic_last_status = status =</a>
<a name="ln1787">        OS_REG_READ(ah, AR_PHY_PANIC_WD_STATUS);</a>
<a name="ln1788">    /*</a>
<a name="ln1789">     * panic watchdog timer should reset on status read</a>
<a name="ln1790">     * but to make sure we write 0 to the watchdog status bit</a>
<a name="ln1791">     */</a>
<a name="ln1792">    OS_REG_WRITE(ah, AR_PHY_PANIC_WD_STATUS, status &amp; ~AR_PHY_BB_WD_STATUS_CLR);</a>
<a name="ln1793">}</a>
<a name="ln1794"> </a>
<a name="ln1795">int</a>
<a name="ln1796">ar9300_get_bb_panic_info(struct ath_hal *ah, struct hal_bb_panic_info *bb_panic)</a>
<a name="ln1797">{</a>
<a name="ln1798">    bb_panic-&gt;status = AH9300(ah)-&gt;ah_bb_panic_last_status;</a>
<a name="ln1799"> </a>
<a name="ln1800">    /*</a>
<a name="ln1801">     * For signature 04000539 do not print anything.</a>
<a name="ln1802">     * This is a very common occurence as a compromise between</a>
<a name="ln1803">     * BB Panic and AH_FALSE detects (EV71009). It indicates </a>
<a name="ln1804">     * radar hang, which can be cleared by reprogramming</a>
<a name="ln1805">     * radar related register and does not requre a chip reset </a>
<a name="ln1806">     */</a>
<a name="ln1807"> </a>
<a name="ln1808">    /* Suppress BB Status mesg following signature */</a>
<a name="ln1809">    switch (bb_panic-&gt;status) {</a>
<a name="ln1810">        case 0x04000539:</a>
<a name="ln1811">        case 0x04008009:    </a>
<a name="ln1812">        case 0x04000b09:</a>
<a name="ln1813">        case 0x1300000a:</a>
<a name="ln1814">        return -1;</a>
<a name="ln1815">    }</a>
<a name="ln1816"> </a>
<a name="ln1817">    bb_panic-&gt;tsf = ar9300_get_tsf32(ah);</a>
<a name="ln1818">    bb_panic-&gt;wd = MS(bb_panic-&gt;status, AR_PHY_BB_WD_STATUS);</a>
<a name="ln1819">    bb_panic-&gt;det = MS(bb_panic-&gt;status, AR_PHY_BB_WD_DET_HANG);</a>
<a name="ln1820">    bb_panic-&gt;rdar = MS(bb_panic-&gt;status, AR_PHY_BB_WD_RADAR_SM);</a>
<a name="ln1821">    bb_panic-&gt;r_odfm = MS(bb_panic-&gt;status, AR_PHY_BB_WD_RX_OFDM_SM);</a>
<a name="ln1822">    bb_panic-&gt;r_cck = MS(bb_panic-&gt;status, AR_PHY_BB_WD_RX_CCK_SM);</a>
<a name="ln1823">    bb_panic-&gt;t_odfm = MS(bb_panic-&gt;status, AR_PHY_BB_WD_TX_OFDM_SM);</a>
<a name="ln1824">    bb_panic-&gt;t_cck = MS(bb_panic-&gt;status, AR_PHY_BB_WD_TX_CCK_SM);</a>
<a name="ln1825">    bb_panic-&gt;agc = MS(bb_panic-&gt;status, AR_PHY_BB_WD_AGC_SM);</a>
<a name="ln1826">    bb_panic-&gt;src = MS(bb_panic-&gt;status, AR_PHY_BB_WD_SRCH_SM);</a>
<a name="ln1827">    bb_panic-&gt;phy_panic_wd_ctl1 = OS_REG_READ(ah, AR_PHY_PANIC_WD_CTL_1);</a>
<a name="ln1828">    bb_panic-&gt;phy_panic_wd_ctl2 = OS_REG_READ(ah, AR_PHY_PANIC_WD_CTL_2);</a>
<a name="ln1829">    bb_panic-&gt;phy_gen_ctrl = OS_REG_READ(ah, AR_PHY_GEN_CTRL);</a>
<a name="ln1830">    bb_panic-&gt;rxc_pcnt = bb_panic-&gt;rxf_pcnt = bb_panic-&gt;txf_pcnt = 0;</a>
<a name="ln1831">    bb_panic-&gt;cycles = ar9300_get_mib_cycle_counts_pct(ah, </a>
<a name="ln1832">                                        &amp;bb_panic-&gt;rxc_pcnt,</a>
<a name="ln1833">                                        &amp;bb_panic-&gt;rxf_pcnt, </a>
<a name="ln1834">                                        &amp;bb_panic-&gt;txf_pcnt);</a>
<a name="ln1835"> </a>
<a name="ln1836">    if (ah-&gt;ah_config.ath_hal_show_bb_panic) {</a>
<a name="ln1837">        ath_hal_printf(ah, &quot;\n==== BB update: BB status=0x%08x, &quot;</a>
<a name="ln1838">            &quot;tsf=0x%08x ====\n&quot;, bb_panic-&gt;status, bb_panic-&gt;tsf);</a>
<a name="ln1839">        ath_hal_printf(ah, &quot;** BB state: wd=%u det=%u rdar=%u rOFDM=%d &quot;</a>
<a name="ln1840">            &quot;rCCK=%u tOFDM=%u tCCK=%u agc=%u src=%u **\n&quot;,</a>
<a name="ln1841">            bb_panic-&gt;wd, bb_panic-&gt;det, bb_panic-&gt;rdar,</a>
<a name="ln1842">            bb_panic-&gt;r_odfm, bb_panic-&gt;r_cck, bb_panic-&gt;t_odfm,</a>
<a name="ln1843">            bb_panic-&gt;t_cck, bb_panic-&gt;agc, bb_panic-&gt;src);</a>
<a name="ln1844">        ath_hal_printf(ah, &quot;** BB WD cntl: cntl1=0x%08x cntl2=0x%08x **\n&quot;,</a>
<a name="ln1845">            bb_panic-&gt;phy_panic_wd_ctl1, bb_panic-&gt;phy_panic_wd_ctl2);</a>
<a name="ln1846">        ath_hal_printf(ah, &quot;** BB mode: BB_gen_controls=0x%08x **\n&quot;, </a>
<a name="ln1847">            bb_panic-&gt;phy_gen_ctrl);</a>
<a name="ln1848">        if (bb_panic-&gt;cycles) {</a>
<a name="ln1849">            ath_hal_printf(ah, &quot;** BB busy times: rx_clear=%d%%, &quot;</a>
<a name="ln1850">                &quot;rx_frame=%d%%, tx_frame=%d%% **\n&quot;, bb_panic-&gt;rxc_pcnt, </a>
<a name="ln1851">                bb_panic-&gt;rxf_pcnt, bb_panic-&gt;txf_pcnt);</a>
<a name="ln1852">        }</a>
<a name="ln1853">        ath_hal_printf(ah, &quot;==== BB update: done ====\n\n&quot;);</a>
<a name="ln1854">    }</a>
<a name="ln1855"> </a>
<a name="ln1856">    return 0; //The returned data will be stored for athstats to retrieve it</a>
<a name="ln1857">}</a>
<a name="ln1858"> </a>
<a name="ln1859">/* set the reason for HAL reset */</a>
<a name="ln1860">void </a>
<a name="ln1861">ar9300_set_hal_reset_reason(struct ath_hal *ah, u_int8_t resetreason)</a>
<a name="ln1862">{</a>
<a name="ln1863">    AH9300(ah)-&gt;ah_reset_reason = resetreason;</a>
<a name="ln1864">}</a>
<a name="ln1865"> </a>
<a name="ln1866">/*</a>
<a name="ln1867"> * Configure 20/40 operation</a>
<a name="ln1868"> *</a>
<a name="ln1869"> * 20/40 = joint rx clear (control and extension)</a>
<a name="ln1870"> * 20    = rx clear (control)</a>
<a name="ln1871"> *</a>
<a name="ln1872"> * - NOTE: must stop MAC (tx) and requeue 40 MHz packets as 20 MHz</a>
<a name="ln1873"> *         when changing from 20/40 =&gt; 20 only</a>
<a name="ln1874"> */</a>
<a name="ln1875">void</a>
<a name="ln1876">ar9300_set_11n_mac2040(struct ath_hal *ah, HAL_HT_MACMODE mode)</a>
<a name="ln1877">{</a>
<a name="ln1878">    u_int32_t macmode;</a>
<a name="ln1879"> </a>
<a name="ln1880">    /* Configure MAC for 20/40 operation */</a>
<a name="ln1881">    if (mode == HAL_HT_MACMODE_2040 &amp;&amp;</a>
<a name="ln1882">        !ah-&gt;ah_config.ath_hal_cwm_ignore_ext_cca) {</a>
<a name="ln1883">        macmode = AR_2040_JOINED_RX_CLEAR;</a>
<a name="ln1884">    } else {</a>
<a name="ln1885">        macmode = 0;</a>
<a name="ln1886">    }</a>
<a name="ln1887">    OS_REG_WRITE(ah, AR_2040_MODE, macmode);</a>
<a name="ln1888">}</a>
<a name="ln1889"> </a>
<a name="ln1890">/*</a>
<a name="ln1891"> * Get Rx clear (control/extension channel)</a>
<a name="ln1892"> *</a>
<a name="ln1893"> * Returns active low (busy) for ctrl/ext channel</a>
<a name="ln1894"> * Owl 2.0</a>
<a name="ln1895"> */</a>
<a name="ln1896">HAL_HT_RXCLEAR</a>
<a name="ln1897">ar9300_get_11n_rx_clear(struct ath_hal *ah)</a>
<a name="ln1898">{</a>
<a name="ln1899">    HAL_HT_RXCLEAR rxclear = 0;</a>
<a name="ln1900">    u_int32_t val;</a>
<a name="ln1901"> </a>
<a name="ln1902">    val = OS_REG_READ(ah, AR_DIAG_SW);</a>
<a name="ln1903"> </a>
<a name="ln1904">    /* control channel */</a>
<a name="ln1905">    if (val &amp; AR_DIAG_RX_CLEAR_CTL_LOW) {</a>
<a name="ln1906">        rxclear |= HAL_RX_CLEAR_CTL_LOW;</a>
<a name="ln1907">    }</a>
<a name="ln1908">    /* extension channel */</a>
<a name="ln1909">    if (val &amp; AR_DIAG_RX_CLEAR_EXT_LOW) {</a>
<a name="ln1910">        rxclear |= HAL_RX_CLEAR_EXT_LOW;</a>
<a name="ln1911">    }</a>
<a name="ln1912">    return rxclear;</a>
<a name="ln1913">}</a>
<a name="ln1914"> </a>
<a name="ln1915">/*</a>
<a name="ln1916"> * Set Rx clear (control/extension channel)</a>
<a name="ln1917"> *</a>
<a name="ln1918"> * Useful for forcing the channel to appear busy for</a>
<a name="ln1919"> * debugging/diagnostics</a>
<a name="ln1920"> * Owl 2.0</a>
<a name="ln1921"> */</a>
<a name="ln1922">void</a>
<a name="ln1923">ar9300_set_11n_rx_clear(struct ath_hal *ah, HAL_HT_RXCLEAR rxclear)</a>
<a name="ln1924">{</a>
<a name="ln1925">    /* control channel */</a>
<a name="ln1926">    if (rxclear &amp; HAL_RX_CLEAR_CTL_LOW) {</a>
<a name="ln1927">        OS_REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_CLEAR_CTL_LOW);</a>
<a name="ln1928">    } else {</a>
<a name="ln1929">        OS_REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_CLEAR_CTL_LOW);</a>
<a name="ln1930">    }</a>
<a name="ln1931">    /* extension channel */</a>
<a name="ln1932">    if (rxclear &amp; HAL_RX_CLEAR_EXT_LOW) {</a>
<a name="ln1933">        OS_REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_CLEAR_EXT_LOW);</a>
<a name="ln1934">    } else {</a>
<a name="ln1935">        OS_REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_CLEAR_EXT_LOW);</a>
<a name="ln1936">    }</a>
<a name="ln1937">}</a>
<a name="ln1938"> </a>
<a name="ln1939"> </a>
<a name="ln1940">/*</a>
<a name="ln1941"> * HAL support code for force ppm tracking workaround.</a>
<a name="ln1942"> */</a>
<a name="ln1943"> </a>
<a name="ln1944">u_int32_t</a>
<a name="ln1945">ar9300_ppm_get_rssi_dump(struct ath_hal *ah)</a>
<a name="ln1946">{</a>
<a name="ln1947">    u_int32_t retval;</a>
<a name="ln1948">    u_int32_t off1;</a>
<a name="ln1949">    u_int32_t off2;</a>
<a name="ln1950"> </a>
<a name="ln1951">    if (OS_REG_READ(ah, AR_PHY_ANALOG_SWAP) &amp; AR_PHY_SWAP_ALT_CHAIN) {</a>
<a name="ln1952">        off1 = 0x2000;</a>
<a name="ln1953">        off2 = 0x1000;</a>
<a name="ln1954">    } else {</a>
<a name="ln1955">        off1 = 0x1000;</a>
<a name="ln1956">        off2 = 0x2000;</a>
<a name="ln1957">    }</a>
<a name="ln1958"> </a>
<a name="ln1959">    retval = ((0xff &amp; OS_REG_READ(ah, AR_PHY_CHAN_INFO_GAIN_0       )) &lt;&lt; 0) |</a>
<a name="ln1960">             ((0xff &amp; OS_REG_READ(ah, AR_PHY_CHAN_INFO_GAIN_0 + off1)) &lt;&lt; 8) |</a>
<a name="ln1961">             ((0xff &amp; OS_REG_READ(ah, AR_PHY_CHAN_INFO_GAIN_0 + off2)) &lt;&lt; 16);</a>
<a name="ln1962"> </a>
<a name="ln1963">    return retval;</a>
<a name="ln1964">}</a>
<a name="ln1965"> </a>
<a name="ln1966">u_int32_t</a>
<a name="ln1967">ar9300_ppm_force(struct ath_hal *ah)</a>
<a name="ln1968">{</a>
<a name="ln1969">    u_int32_t data_fine;</a>
<a name="ln1970">    u_int32_t data4;</a>
<a name="ln1971">    //u_int32_t off1;</a>
<a name="ln1972">    //u_int32_t off2;</a>
<a name="ln1973">    HAL_BOOL signed_val = AH_FALSE;</a>
<a name="ln1974"> </a>
<a name="ln1975">//    if (OS_REG_READ(ah, AR_PHY_ANALOG_SWAP) &amp; AR_PHY_SWAP_ALT_CHAIN) {</a>
<a name="ln1976">//        off1 = 0x2000;</a>
<a name="ln1977">//        off2 = 0x1000;</a>
<a name="ln1978">//    } else {</a>
<a name="ln1979">//        off1 = 0x1000;</a>
<a name="ln1980">//        off2 = 0x2000;</a>
<a name="ln1981">//    }</a>
<a name="ln1982">    data_fine =</a>
<a name="ln1983">        AR_PHY_CHAN_INFO_GAIN_DIFF_PPM_MASK &amp;</a>
<a name="ln1984">        OS_REG_READ(ah, AR_PHY_CHNINFO_GAINDIFF);</a>
<a name="ln1985"> </a>
<a name="ln1986">    /*</a>
<a name="ln1987">     * bit [11-0] is new ppm value. bit 11 is the signed bit.</a>
<a name="ln1988">     * So check value from bit[10:0].</a>
<a name="ln1989">     * Now get the abs val of the ppm value read in bit[0:11].</a>
<a name="ln1990">     * After that do bound check on abs value.</a>
<a name="ln1991">     * if value is off limit, CAP the value and and restore signed bit.</a>
<a name="ln1992">     */</a>
<a name="ln1993">    if (data_fine &amp; AR_PHY_CHAN_INFO_GAIN_DIFF_PPM_SIGNED_BIT)</a>
<a name="ln1994">    {</a>
<a name="ln1995">        /* get the positive value */</a>
<a name="ln1996">        data_fine = (~data_fine + 1) &amp; AR_PHY_CHAN_INFO_GAIN_DIFF_PPM_MASK;</a>
<a name="ln1997">        signed_val = AH_TRUE;</a>
<a name="ln1998">    }</a>
<a name="ln1999">    if (data_fine &gt; AR_PHY_CHAN_INFO_GAIN_DIFF_UPPER_LIMIT)</a>
<a name="ln2000">    {</a>
<a name="ln2001">        HALDEBUG(ah, HAL_DEBUG_REGIO,</a>
<a name="ln2002">            &quot;%s Correcting ppm out of range %x\n&quot;,</a>
<a name="ln2003">            __func__, (data_fine &amp; 0x7ff));</a>
<a name="ln2004">        data_fine = AR_PHY_CHAN_INFO_GAIN_DIFF_UPPER_LIMIT;</a>
<a name="ln2005">    }</a>
<a name="ln2006">    /*</a>
<a name="ln2007">     * Restore signed value if changed above.</a>
<a name="ln2008">     * Use typecast to avoid compilation errors</a>
<a name="ln2009">     */</a>
<a name="ln2010">    if (signed_val) {</a>
<a name="ln2011">        data_fine = (-(int32_t)data_fine) &amp;</a>
<a name="ln2012">            AR_PHY_CHAN_INFO_GAIN_DIFF_PPM_MASK;</a>
<a name="ln2013">    }</a>
<a name="ln2014"> </a>
<a name="ln2015">    /* write value */</a>
<a name="ln2016">    data4 = OS_REG_READ(ah, AR_PHY_TIMING2) &amp;</a>
<a name="ln2017">        ~(AR_PHY_TIMING2_USE_FORCE_PPM | AR_PHY_TIMING2_FORCE_PPM_VAL);</a>
<a name="ln2018">    OS_REG_WRITE(ah, AR_PHY_TIMING2,</a>
<a name="ln2019">        data4 | data_fine | AR_PHY_TIMING2_USE_FORCE_PPM);</a>
<a name="ln2020"> </a>
<a name="ln2021">    return data_fine;</a>
<a name="ln2022">}</a>
<a name="ln2023"> </a>
<a name="ln2024">void</a>
<a name="ln2025">ar9300_ppm_un_force(struct ath_hal *ah)</a>
<a name="ln2026">{</a>
<a name="ln2027">    u_int32_t data4;</a>
<a name="ln2028"> </a>
<a name="ln2029">    data4 = OS_REG_READ(ah, AR_PHY_TIMING2) &amp; ~AR_PHY_TIMING2_USE_FORCE_PPM;</a>
<a name="ln2030">    OS_REG_WRITE(ah, AR_PHY_TIMING2, data4);</a>
<a name="ln2031">}</a>
<a name="ln2032"> </a>
<a name="ln2033">u_int32_t</a>
<a name="ln2034">ar9300_ppm_arm_trigger(struct ath_hal *ah)</a>
<a name="ln2035">{</a>
<a name="ln2036">    u_int32_t val;</a>
<a name="ln2037">    u_int32_t ret;</a>
<a name="ln2038"> </a>
<a name="ln2039">    val = OS_REG_READ(ah, AR_PHY_CHAN_INFO_MEMORY);</a>
<a name="ln2040">    ret = OS_REG_READ(ah, AR_TSF_L32);</a>
<a name="ln2041">    OS_REG_WRITE(ah, AR_PHY_CHAN_INFO_MEMORY,</a>
<a name="ln2042">        val | AR_PHY_CHAN_INFO_MEMORY_CAPTURE_MASK);</a>
<a name="ln2043"> </a>
<a name="ln2044">    /* return low word of TSF at arm time */</a>
<a name="ln2045">    return ret;</a>
<a name="ln2046">}</a>
<a name="ln2047"> </a>
<a name="ln2048">int</a>
<a name="ln2049">ar9300_ppm_get_trigger(struct ath_hal *ah)</a>
<a name="ln2050">{</a>
<a name="ln2051">    if (OS_REG_READ(ah, AR_PHY_CHAN_INFO_MEMORY) &amp;</a>
<a name="ln2052">        AR_PHY_CHAN_INFO_MEMORY_CAPTURE_MASK)</a>
<a name="ln2053">    {</a>
<a name="ln2054">        /* has not triggered yet, return AH_FALSE */</a>
<a name="ln2055">        return 0;</a>
<a name="ln2056">    }</a>
<a name="ln2057"> </a>
<a name="ln2058">    /* else triggered, return AH_TRUE */</a>
<a name="ln2059">    return 1;</a>
<a name="ln2060">}</a>
<a name="ln2061"> </a>
<a name="ln2062">void</a>
<a name="ln2063">ar9300_mark_phy_inactive(struct ath_hal *ah)</a>
<a name="ln2064">{</a>
<a name="ln2065">    OS_REG_WRITE(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_DIS);</a>
<a name="ln2066">}</a>
<a name="ln2067"> </a>
<a name="ln2068">/* DEBUG */</a>
<a name="ln2069">u_int32_t</a>
<a name="ln2070">ar9300_ppm_get_force_state(struct ath_hal *ah)</a>
<a name="ln2071">{</a>
<a name="ln2072">    return</a>
<a name="ln2073">        OS_REG_READ(ah, AR_PHY_TIMING2) &amp;</a>
<a name="ln2074">        (AR_PHY_TIMING2_USE_FORCE_PPM | AR_PHY_TIMING2_FORCE_PPM_VAL);</a>
<a name="ln2075">}</a>
<a name="ln2076"> </a>
<a name="ln2077">/*</a>
<a name="ln2078"> * Return the Cycle counts for rx_frame, rx_clear, and tx_frame</a>
<a name="ln2079"> */</a>
<a name="ln2080">HAL_BOOL</a>
<a name="ln2081">ar9300_get_mib_cycle_counts(struct ath_hal *ah, HAL_SURVEY_SAMPLE *hs)</a>
<a name="ln2082">{</a>
<a name="ln2083">    /*</a>
<a name="ln2084">     * XXX FreeBSD todo: reimplement this</a>
<a name="ln2085">     */</a>
<a name="ln2086">#if 0</a>
<a name="ln2087">    p_cnts-&gt;tx_frame_count = OS_REG_READ(ah, AR_TFCNT);</a>
<a name="ln2088">    p_cnts-&gt;rx_frame_count = OS_REG_READ(ah, AR_RFCNT);</a>
<a name="ln2089">    p_cnts-&gt;rx_clear_count = OS_REG_READ(ah, AR_RCCNT);</a>
<a name="ln2090">    p_cnts-&gt;cycle_count   = OS_REG_READ(ah, AR_CCCNT);</a>
<a name="ln2091">    p_cnts-&gt;is_tx_active   = (OS_REG_READ(ah, AR_TFCNT) ==</a>
<a name="ln2092">                           p_cnts-&gt;tx_frame_count) ? AH_FALSE : AH_TRUE;</a>
<a name="ln2093">    p_cnts-&gt;is_rx_active   = (OS_REG_READ(ah, AR_RFCNT) ==</a>
<a name="ln2094">                           p_cnts-&gt;rx_frame_count) ? AH_FALSE : AH_TRUE;</a>
<a name="ln2095">#endif</a>
<a name="ln2096">    return AH_FALSE;</a>
<a name="ln2097">}</a>
<a name="ln2098"> </a>
<a name="ln2099">void</a>
<a name="ln2100">ar9300_clear_mib_counters(struct ath_hal *ah)</a>
<a name="ln2101">{</a>
<a name="ln2102">    u_int32_t reg_val;</a>
<a name="ln2103"> </a>
<a name="ln2104">    reg_val = OS_REG_READ(ah, AR_MIBC);</a>
<a name="ln2105">    OS_REG_WRITE(ah, AR_MIBC, reg_val | AR_MIBC_CMC);</a>
<a name="ln2106">    OS_REG_WRITE(ah, AR_MIBC, reg_val &amp; ~AR_MIBC_CMC);</a>
<a name="ln2107">}</a>
<a name="ln2108"> </a>
<a name="ln2109"> </a>
<a name="ln2110">/* Enable or Disable RIFS Rx capability as part of SW WAR for Bug 31602 */</a>
<a name="ln2111">HAL_BOOL</a>
<a name="ln2112">ar9300_set_rifs_delay(struct ath_hal *ah, HAL_BOOL enable)</a>
<a name="ln2113">{</a>
<a name="ln2114">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2115">    HAL_CHANNEL_INTERNAL *ichan =</a>
<a name="ln2116">      ath_hal_checkchannel(ah, AH_PRIVATE(ah)-&gt;ah_curchan);</a>
<a name="ln2117">    HAL_BOOL is_chan_2g = IS_CHAN_2GHZ(ichan);</a>
<a name="ln2118">    u_int32_t tmp = 0;</a>
<a name="ln2119"> </a>
<a name="ln2120">    if (enable) {</a>
<a name="ln2121">        if (ahp-&gt;ah_rifs_enabled == AH_TRUE) {</a>
<a name="ln2122">            return AH_TRUE;</a>
<a name="ln2123">        }</a>
<a name="ln2124"> </a>
<a name="ln2125">        OS_REG_WRITE(ah, AR_PHY_SEARCH_START_DELAY, ahp-&gt;ah_rifs_reg[0]);</a>
<a name="ln2126">        OS_REG_WRITE(ah, AR_PHY_RIFS_SRCH,</a>
<a name="ln2127">                     ahp-&gt;ah_rifs_reg[1]);</a>
<a name="ln2128"> </a>
<a name="ln2129">        ahp-&gt;ah_rifs_enabled = AH_TRUE;</a>
<a name="ln2130">        OS_MEMZERO(ahp-&gt;ah_rifs_reg, sizeof(ahp-&gt;ah_rifs_reg));</a>
<a name="ln2131">    } else {</a>
<a name="ln2132">        if (ahp-&gt;ah_rifs_enabled == AH_TRUE) {</a>
<a name="ln2133">            ahp-&gt;ah_rifs_reg[0] = OS_REG_READ(ah,</a>
<a name="ln2134">                                              AR_PHY_SEARCH_START_DELAY);</a>
<a name="ln2135">            ahp-&gt;ah_rifs_reg[1] = OS_REG_READ(ah, AR_PHY_RIFS_SRCH);</a>
<a name="ln2136">        }</a>
<a name="ln2137">        /* Change rifs init delay to 0 */</a>
<a name="ln2138">        OS_REG_WRITE(ah, AR_PHY_RIFS_SRCH,</a>
<a name="ln2139">                     (ahp-&gt;ah_rifs_reg[1] &amp; ~(AR_PHY_RIFS_INIT_DELAY)));</a>
<a name="ln2140">        tmp = 0xfffff000 &amp; OS_REG_READ(ah, AR_PHY_SEARCH_START_DELAY);        </a>
<a name="ln2141">        if (is_chan_2g) {</a>
<a name="ln2142">            if (IEEE80211_IS_CHAN_HT40(AH_PRIVATE(ah)-&gt;ah_curchan)) {</a>
<a name="ln2143">                OS_REG_WRITE(ah, AR_PHY_SEARCH_START_DELAY, tmp | 500);</a>
<a name="ln2144">            } else { /* Sowl 2G HT-20 default is 0x134 for search start delay */</a>
<a name="ln2145">                OS_REG_WRITE(ah, AR_PHY_SEARCH_START_DELAY, tmp | 250);</a>
<a name="ln2146">            }</a>
<a name="ln2147">        } else {</a>
<a name="ln2148">            if (IEEE80211_IS_CHAN_HT40(AH_PRIVATE(ah)-&gt;ah_curchan)) {</a>
<a name="ln2149">                OS_REG_WRITE(ah, AR_PHY_SEARCH_START_DELAY, tmp | 0x370);</a>
<a name="ln2150">            } else { /* Sowl 5G HT-20 default is 0x1b8 for search start delay */</a>
<a name="ln2151">                OS_REG_WRITE(ah, AR_PHY_SEARCH_START_DELAY, tmp | 0x1b8);</a>
<a name="ln2152">            }</a>
<a name="ln2153">        }</a>
<a name="ln2154"> </a>
<a name="ln2155">        ahp-&gt;ah_rifs_enabled = AH_FALSE;</a>
<a name="ln2156">    }</a>
<a name="ln2157">    return AH_TRUE;</a>
<a name="ln2158"> </a>
<a name="ln2159">} /* ar9300_set_rifs_delay () */</a>
<a name="ln2160"> </a>
<a name="ln2161">/* Set the current RIFS Rx setting */</a>
<a name="ln2162">HAL_BOOL</a>
<a name="ln2163">ar9300_set_11n_rx_rifs(struct ath_hal *ah, HAL_BOOL enable)</a>
<a name="ln2164">{</a>
<a name="ln2165">    /* Non-Owl 11n chips */</a>
<a name="ln2166">    if ((ath_hal_getcapability(ah, HAL_CAP_RIFS_RX, 0, AH_NULL) == HAL_OK)) {</a>
<a name="ln2167">        if (ar9300_get_capability(ah, HAL_CAP_LDPCWAR, 0, AH_NULL) == HAL_OK) {</a>
<a name="ln2168">            return ar9300_set_rifs_delay(ah, enable);</a>
<a name="ln2169">        }</a>
<a name="ln2170">        return AH_FALSE;</a>
<a name="ln2171">    }</a>
<a name="ln2172"> </a>
<a name="ln2173">    return AH_TRUE;</a>
<a name="ln2174">} /* ar9300_set_11n_rx_rifs () */</a>
<a name="ln2175"> </a>
<a name="ln2176">static hal_mac_hangs_t</a>
<a name="ln2177">ar9300_compare_dbg_hang(struct ath_hal *ah, mac_dbg_regs_t mac_dbg,</a>
<a name="ln2178">  hal_mac_hang_check_t hang_check, hal_mac_hangs_t hangs, u_int8_t *dcu_chain)</a>
<a name="ln2179">{</a>
<a name="ln2180">    int i = 0;</a>
<a name="ln2181">    hal_mac_hangs_t found_hangs = 0;</a>
<a name="ln2182"> </a>
<a name="ln2183">    if (hangs &amp; dcu_chain_state) {</a>
<a name="ln2184">        for (i = 0; i &lt; 6; i++) {</a>
<a name="ln2185">            if (((mac_dbg.dma_dbg_4 &gt;&gt; (5 * i)) &amp; 0x1f) ==</a>
<a name="ln2186">                 hang_check.dcu_chain_state)</a>
<a name="ln2187">            {</a>
<a name="ln2188">                found_hangs |= dcu_chain_state;</a>
<a name="ln2189">                *dcu_chain = i;</a>
<a name="ln2190">            }</a>
<a name="ln2191">        }</a>
<a name="ln2192">        for (i = 0; i &lt; 4; i++) {</a>
<a name="ln2193">            if (((mac_dbg.dma_dbg_5 &gt;&gt; (5 * i)) &amp; 0x1f) ==</a>
<a name="ln2194">                  hang_check.dcu_chain_state)</a>
<a name="ln2195">            {</a>
<a name="ln2196">                found_hangs |= dcu_chain_state;</a>
<a name="ln2197">                *dcu_chain = i + 6;</a>
<a name="ln2198">            }</a>
<a name="ln2199">        }</a>
<a name="ln2200">    }</a>
<a name="ln2201"> </a>
<a name="ln2202">    if (hangs &amp; dcu_complete_state) {</a>
<a name="ln2203">        if ((mac_dbg.dma_dbg_6 &amp; 0x3) == hang_check.dcu_complete_state) {</a>
<a name="ln2204">            found_hangs |= dcu_complete_state;</a>
<a name="ln2205">        }</a>
<a name="ln2206">    }</a>
<a name="ln2207"> </a>
<a name="ln2208">    return found_hangs;</a>
<a name="ln2209"> </a>
<a name="ln2210">} /* end - ar9300_compare_dbg_hang */</a>
<a name="ln2211"> </a>
<a name="ln2212">#define NUM_STATUS_READS 50</a>
<a name="ln2213">HAL_BOOL</a>
<a name="ln2214">ar9300_detect_mac_hang(struct ath_hal *ah)</a>
<a name="ln2215">{</a>
<a name="ln2216">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2217">    mac_dbg_regs_t mac_dbg;</a>
<a name="ln2218">    hal_mac_hang_check_t hang_sig1_val = {0x6, 0x1, 0, 0, 0, 0, 0, 0};</a>
<a name="ln2219">    hal_mac_hangs_t      hang_sig1 = (dcu_chain_state | dcu_complete_state);</a>
<a name="ln2220">    int i = 0;</a>
<a name="ln2221">    u_int8_t dcu_chain = 0, current_dcu_chain_state, shift_val;</a>
<a name="ln2222"> </a>
<a name="ln2223">    if (!(ahp-&gt;ah_hang_wars &amp; HAL_MAC_HANG_WAR)) {</a>
<a name="ln2224">        return AH_FALSE;</a>
<a name="ln2225">    }</a>
<a name="ln2226"> </a>
<a name="ln2227">    OS_MEMZERO(&amp;mac_dbg, sizeof(mac_dbg));</a>
<a name="ln2228"> </a>
<a name="ln2229">    mac_dbg.dma_dbg_4 = OS_REG_READ(ah, AR_DMADBG_4);</a>
<a name="ln2230">    mac_dbg.dma_dbg_5 = OS_REG_READ(ah, AR_DMADBG_5);</a>
<a name="ln2231">    mac_dbg.dma_dbg_6 = OS_REG_READ(ah, AR_DMADBG_6);</a>
<a name="ln2232"> </a>
<a name="ln2233">    HALDEBUG(ah, HAL_DEBUG_DFS, &quot; dma regs: %X %X %X \n&quot;,</a>
<a name="ln2234">            mac_dbg.dma_dbg_4, mac_dbg.dma_dbg_5,</a>
<a name="ln2235">            mac_dbg.dma_dbg_6);</a>
<a name="ln2236"> </a>
<a name="ln2237">    if (hang_sig1 != </a>
<a name="ln2238">            ar9300_compare_dbg_hang(ah, mac_dbg,</a>
<a name="ln2239">                 hang_sig1_val, hang_sig1, &amp;dcu_chain))</a>
<a name="ln2240">    {</a>
<a name="ln2241">        HALDEBUG(ah, HAL_DEBUG_DFS, &quot; hang sig1 not found \n&quot;);</a>
<a name="ln2242">        return AH_FALSE;</a>
<a name="ln2243">    }</a>
<a name="ln2244"> </a>
<a name="ln2245">    shift_val = (dcu_chain &gt;= 6) ? (dcu_chain-6) : (dcu_chain); </a>
<a name="ln2246">    shift_val *= 5;</a>
<a name="ln2247"> </a>
<a name="ln2248">    for (i = 1; i &lt;= NUM_STATUS_READS; i++) {</a>
<a name="ln2249">        if (dcu_chain &lt; 6) {</a>
<a name="ln2250">            mac_dbg.dma_dbg_4 = OS_REG_READ(ah, AR_DMADBG_4);</a>
<a name="ln2251">            current_dcu_chain_state = </a>
<a name="ln2252">                     ((mac_dbg.dma_dbg_4 &gt;&gt; shift_val) &amp; 0x1f); </a>
<a name="ln2253">        } else {</a>
<a name="ln2254">            mac_dbg.dma_dbg_5 = OS_REG_READ(ah, AR_DMADBG_5);</a>
<a name="ln2255">            current_dcu_chain_state = ((mac_dbg.dma_dbg_5 &gt;&gt; shift_val) &amp; 0x1f);</a>
<a name="ln2256">        }</a>
<a name="ln2257">        mac_dbg.dma_dbg_6 = OS_REG_READ(ah, AR_DMADBG_6);</a>
<a name="ln2258"> </a>
<a name="ln2259">        if (((mac_dbg.dma_dbg_6 &amp; 0x3) != hang_sig1_val.dcu_complete_state) </a>
<a name="ln2260">            || (current_dcu_chain_state != hang_sig1_val.dcu_chain_state)) {</a>
<a name="ln2261">            return AH_FALSE;</a>
<a name="ln2262">        }</a>
<a name="ln2263">    }</a>
<a name="ln2264">    HALDEBUG(ah, HAL_DEBUG_DFS, &quot;%s sig5count=%d sig6count=%d &quot;, __func__,</a>
<a name="ln2265">             ahp-&gt;ah_hang[MAC_HANG_SIG1], ahp-&gt;ah_hang[MAC_HANG_SIG2]);</a>
<a name="ln2266">    ahp-&gt;ah_hang[MAC_HANG_SIG1]++;</a>
<a name="ln2267">    return AH_TRUE;</a>
<a name="ln2268"> </a>
<a name="ln2269">} /* end - ar9300_detect_mac_hang */</a>
<a name="ln2270"> </a>
<a name="ln2271">/* Determine if the baseband is hung by reading the Observation Bus Register */</a>
<a name="ln2272">HAL_BOOL</a>
<a name="ln2273">ar9300_detect_bb_hang(struct ath_hal *ah)</a>
<a name="ln2274">{</a>
<a name="ln2275">#define N(a) (sizeof(a) / sizeof(a[0]))</a>
<a name="ln2276">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2277">    u_int32_t hang_sig = 0;</a>
<a name="ln2278">    int i = 0;</a>
<a name="ln2279">    /* Check the PCU Observation Bus 1 register (0x806c) NUM_STATUS_READS times</a>
<a name="ln2280">     *</a>
<a name="ln2281">     * 4 known BB hang signatures -</a>
<a name="ln2282">     * [1] bits 8,9,11 are 0. State machine state (bits 25-31) is 0x1E</a>
<a name="ln2283">     * [2] bits 8,9 are 1, bit 11 is 0. State machine state (bits 25-31) is 0x52</a>
<a name="ln2284">     * [3] bits 8,9 are 1, bit 11 is 0. State machine state (bits 25-31) is 0x18</a>
<a name="ln2285">     * [4] bit 10 is 1, bit 11 is 0. WEP state (bits 12-17) is 0x2,</a>
<a name="ln2286">     *     Rx State (bits 20-24) is 0x7.</a>
<a name="ln2287">     */</a>
<a name="ln2288">    hal_hw_hang_check_t hang_list [] =</a>
<a name="ln2289">    {</a>
<a name="ln2290">     /* Offset        Reg Value   Reg Mask    Hang Offset */</a>
<a name="ln2291">       {AR_OBS_BUS_1, 0x1E000000, 0x7E000B00, BB_HANG_SIG1},</a>
<a name="ln2292">       {AR_OBS_BUS_1, 0x52000B00, 0x7E000B00, BB_HANG_SIG2},</a>
<a name="ln2293">       {AR_OBS_BUS_1, 0x18000B00, 0x7E000B00, BB_HANG_SIG3},</a>
<a name="ln2294">       {AR_OBS_BUS_1, 0x00702400, 0x7E7FFFEF, BB_HANG_SIG4}</a>
<a name="ln2295">    };</a>
<a name="ln2296"> </a>
<a name="ln2297">    if (!(ahp-&gt;ah_hang_wars &amp; (HAL_RIFS_BB_HANG_WAR |</a>
<a name="ln2298">                               HAL_DFS_BB_HANG_WAR |</a>
<a name="ln2299">                               HAL_RX_STUCK_LOW_BB_HANG_WAR))) {</a>
<a name="ln2300">        return AH_FALSE;</a>
<a name="ln2301">    }</a>
<a name="ln2302"> </a>
<a name="ln2303">    hang_sig = OS_REG_READ(ah, AR_OBS_BUS_1);</a>
<a name="ln2304">    for (i = 1; i &lt;= NUM_STATUS_READS; i++) {</a>
<a name="ln2305">        if (hang_sig != OS_REG_READ(ah, AR_OBS_BUS_1)) {</a>
<a name="ln2306">            return AH_FALSE;</a>
<a name="ln2307">        }</a>
<a name="ln2308">    }</a>
<a name="ln2309"> </a>
<a name="ln2310">    for (i = 0; i &lt; N(hang_list); i++) {</a>
<a name="ln2311">        if ((hang_sig &amp; hang_list[i].hang_mask) == hang_list[i].hang_val) {</a>
<a name="ln2312">            ahp-&gt;ah_hang[hang_list[i].hang_offset]++;</a>
<a name="ln2313">            HALDEBUG(ah, HAL_DEBUG_DFS, &quot;%s sig1count=%d sig2count=%d &quot;</a>
<a name="ln2314">                     &quot;sig3count=%d sig4count=%d\n&quot;, __func__,</a>
<a name="ln2315">                     ahp-&gt;ah_hang[BB_HANG_SIG1], ahp-&gt;ah_hang[BB_HANG_SIG2],</a>
<a name="ln2316">                     ahp-&gt;ah_hang[BB_HANG_SIG3], ahp-&gt;ah_hang[BB_HANG_SIG4]);</a>
<a name="ln2317">            return AH_TRUE;</a>
<a name="ln2318">        }</a>
<a name="ln2319">    }</a>
<a name="ln2320"> </a>
<a name="ln2321">    HALDEBUG(ah, HAL_DEBUG_DFS, &quot;%s Found an unknown BB hang signature! &quot;</a>
<a name="ln2322">                              &quot;&lt;0x806c&gt;=0x%x\n&quot;, __func__, hang_sig);</a>
<a name="ln2323"> </a>
<a name="ln2324">    return AH_FALSE;</a>
<a name="ln2325"> </a>
<a name="ln2326">#undef N</a>
<a name="ln2327">} /* end - ar9300_detect_bb_hang () */</a>
<a name="ln2328"> </a>
<a name="ln2329">#undef NUM_STATUS_READS</a>
<a name="ln2330"> </a>
<a name="ln2331">HAL_STATUS</a>
<a name="ln2332">ar9300_select_ant_config(struct ath_hal *ah, u_int32_t cfg)</a>
<a name="ln2333">{</a>
<a name="ln2334">    struct ath_hal_9300     *ahp = AH9300(ah);</a>
<a name="ln2335">    const struct ieee80211_channel *chan = AH_PRIVATE(ah)-&gt;ah_curchan;</a>
<a name="ln2336">    HAL_CHANNEL_INTERNAL    *ichan = ath_hal_checkchannel(ah, chan);</a>
<a name="ln2337">    const HAL_CAPABILITIES  *p_cap = &amp;AH_PRIVATE(ah)-&gt;ah_caps;</a>
<a name="ln2338">    u_int16_t               ant_config;</a>
<a name="ln2339">    u_int32_t               hal_num_ant_config;</a>
<a name="ln2340"> </a>
<a name="ln2341">    hal_num_ant_config = IS_CHAN_2GHZ(ichan) ?</a>
<a name="ln2342">        p_cap-&gt;halNumAntCfg2GHz: p_cap-&gt;halNumAntCfg5GHz;</a>
<a name="ln2343"> </a>
<a name="ln2344">    if (cfg &lt; hal_num_ant_config) {</a>
<a name="ln2345">        if (HAL_OK == ar9300_eeprom_get_ant_cfg(ahp, chan, cfg, &amp;ant_config)) {</a>
<a name="ln2346">            OS_REG_WRITE(ah, AR_PHY_SWITCH_COM, ant_config);</a>
<a name="ln2347">            return HAL_OK;</a>
<a name="ln2348">        }</a>
<a name="ln2349">    }</a>
<a name="ln2350"> </a>
<a name="ln2351">    return HAL_EINVAL;</a>
<a name="ln2352">}</a>
<a name="ln2353"> </a>
<a name="ln2354">/*</a>
<a name="ln2355"> * Functions to get/set DCS mode</a>
<a name="ln2356"> */</a>
<a name="ln2357">void</a>
<a name="ln2358">ar9300_set_dcs_mode(struct ath_hal *ah, u_int32_t mode)</a>
<a name="ln2359">{</a>
<a name="ln2360">    AH9300(ah)-&gt;ah_dcs_enable = mode;</a>
<a name="ln2361">}</a>
<a name="ln2362"> </a>
<a name="ln2363">u_int32_t</a>
<a name="ln2364">ar9300_get_dcs_mode(struct ath_hal *ah)</a>
<a name="ln2365">{</a>
<a name="ln2366">    return AH9300(ah)-&gt;ah_dcs_enable;</a>
<a name="ln2367">}</a>
<a name="ln2368"> </a>
<a name="ln2369">#if ATH_BT_COEX</a>
<a name="ln2370">void</a>
<a name="ln2371">ar9300_set_bt_coex_info(struct ath_hal *ah, HAL_BT_COEX_INFO *btinfo)</a>
<a name="ln2372">{</a>
<a name="ln2373">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2374"> </a>
<a name="ln2375">    ahp-&gt;ah_bt_module = btinfo-&gt;bt_module;</a>
<a name="ln2376">    ahp-&gt;ah_bt_coex_config_type = btinfo-&gt;bt_coex_config;</a>
<a name="ln2377">    ahp-&gt;ah_bt_active_gpio_select = btinfo-&gt;bt_gpio_bt_active;</a>
<a name="ln2378">    ahp-&gt;ah_bt_priority_gpio_select = btinfo-&gt;bt_gpio_bt_priority;</a>
<a name="ln2379">    ahp-&gt;ah_wlan_active_gpio_select = btinfo-&gt;bt_gpio_wlan_active;</a>
<a name="ln2380">    ahp-&gt;ah_bt_active_polarity = btinfo-&gt;bt_active_polarity;</a>
<a name="ln2381">    ahp-&gt;ah_bt_coex_single_ant = btinfo-&gt;bt_single_ant;</a>
<a name="ln2382">    ahp-&gt;ah_bt_wlan_isolation = btinfo-&gt;bt_isolation;</a>
<a name="ln2383">}</a>
<a name="ln2384"> </a>
<a name="ln2385">void</a>
<a name="ln2386">ar9300_bt_coex_config(struct ath_hal *ah, HAL_BT_COEX_CONFIG *btconf)</a>
<a name="ln2387">{</a>
<a name="ln2388">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2389">    HAL_BOOL rx_clear_polarity;</a>
<a name="ln2390"> </a>
<a name="ln2391">    /*</a>
<a name="ln2392">     * For Kiwi and Osprey, the polarity of rx_clear is active high.</a>
<a name="ln2393">     * The bt_rxclear_polarity flag from ath_dev needs to be inverted.</a>
<a name="ln2394">     */</a>
<a name="ln2395">    rx_clear_polarity = !btconf-&gt;bt_rxclear_polarity;</a>
<a name="ln2396"> </a>
<a name="ln2397">    ahp-&gt;ah_bt_coex_mode = (ahp-&gt;ah_bt_coex_mode &amp; AR_BT_QCU_THRESH) |</a>
<a name="ln2398">        SM(btconf-&gt;bt_time_extend, AR_BT_TIME_EXTEND) |</a>
<a name="ln2399">        SM(btconf-&gt;bt_txstate_extend, AR_BT_TXSTATE_EXTEND) |</a>
<a name="ln2400">        SM(btconf-&gt;bt_txframe_extend, AR_BT_TX_FRAME_EXTEND) |</a>
<a name="ln2401">        SM(btconf-&gt;bt_mode, AR_BT_MODE) |</a>
<a name="ln2402">        SM(btconf-&gt;bt_quiet_collision, AR_BT_QUIET) |</a>
<a name="ln2403">        SM(rx_clear_polarity, AR_BT_RX_CLEAR_POLARITY) |</a>
<a name="ln2404">        SM(btconf-&gt;bt_priority_time, AR_BT_PRIORITY_TIME) |</a>
<a name="ln2405">        SM(btconf-&gt;bt_first_slot_time, AR_BT_FIRST_SLOT_TIME);</a>
<a name="ln2406"> </a>
<a name="ln2407">    ahp-&gt;ah_bt_coex_mode2 |= SM(btconf-&gt;bt_hold_rxclear, AR_BT_HOLD_RX_CLEAR);</a>
<a name="ln2408"> </a>
<a name="ln2409">    if (ahp-&gt;ah_bt_coex_single_ant == AH_FALSE) {</a>
<a name="ln2410">        /* Enable ACK to go out even though BT has higher priority. */</a>
<a name="ln2411">        ahp-&gt;ah_bt_coex_mode2 |= AR_BT_DISABLE_BT_ANT;</a>
<a name="ln2412">    }</a>
<a name="ln2413">}</a>
<a name="ln2414"> </a>
<a name="ln2415">void</a>
<a name="ln2416">ar9300_bt_coex_set_qcu_thresh(struct ath_hal *ah, int qnum)</a>
<a name="ln2417">{</a>
<a name="ln2418">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2419"> </a>
<a name="ln2420">    /* clear the old value, then set the new value */</a>
<a name="ln2421">    ahp-&gt;ah_bt_coex_mode &amp;= ~AR_BT_QCU_THRESH;</a>
<a name="ln2422">    ahp-&gt;ah_bt_coex_mode |= SM(qnum, AR_BT_QCU_THRESH);</a>
<a name="ln2423">}</a>
<a name="ln2424"> </a>
<a name="ln2425">void</a>
<a name="ln2426">ar9300_bt_coex_set_weights(struct ath_hal *ah, u_int32_t stomp_type)</a>
<a name="ln2427">{</a>
<a name="ln2428">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2429"> </a>
<a name="ln2430">    ahp-&gt;ah_bt_coex_bt_weight[0] = AR9300_BT_WGHT;</a>
<a name="ln2431">    ahp-&gt;ah_bt_coex_bt_weight[1] = AR9300_BT_WGHT;</a>
<a name="ln2432">    ahp-&gt;ah_bt_coex_bt_weight[2] = AR9300_BT_WGHT;</a>
<a name="ln2433">    ahp-&gt;ah_bt_coex_bt_weight[3] = AR9300_BT_WGHT;</a>
<a name="ln2434"> </a>
<a name="ln2435">    switch (stomp_type) {</a>
<a name="ln2436">    case HAL_BT_COEX_STOMP_ALL:</a>
<a name="ln2437">        ahp-&gt;ah_bt_coex_wlan_weight[0] = AR9300_STOMP_ALL_WLAN_WGHT0;</a>
<a name="ln2438">        ahp-&gt;ah_bt_coex_wlan_weight[1] = AR9300_STOMP_ALL_WLAN_WGHT1;</a>
<a name="ln2439">        break;</a>
<a name="ln2440">    case HAL_BT_COEX_STOMP_LOW:</a>
<a name="ln2441">        ahp-&gt;ah_bt_coex_wlan_weight[0] = AR9300_STOMP_LOW_WLAN_WGHT0;</a>
<a name="ln2442">        ahp-&gt;ah_bt_coex_wlan_weight[1] = AR9300_STOMP_LOW_WLAN_WGHT1;</a>
<a name="ln2443">        break;</a>
<a name="ln2444">    case HAL_BT_COEX_STOMP_ALL_FORCE:</a>
<a name="ln2445">        ahp-&gt;ah_bt_coex_wlan_weight[0] = AR9300_STOMP_ALL_FORCE_WLAN_WGHT0;</a>
<a name="ln2446">        ahp-&gt;ah_bt_coex_wlan_weight[1] = AR9300_STOMP_ALL_FORCE_WLAN_WGHT1;</a>
<a name="ln2447">        break;</a>
<a name="ln2448">    case HAL_BT_COEX_STOMP_LOW_FORCE:</a>
<a name="ln2449">        ahp-&gt;ah_bt_coex_wlan_weight[0] = AR9300_STOMP_LOW_FORCE_WLAN_WGHT0;</a>
<a name="ln2450">        ahp-&gt;ah_bt_coex_wlan_weight[1] = AR9300_STOMP_LOW_FORCE_WLAN_WGHT1;</a>
<a name="ln2451">        break;</a>
<a name="ln2452">    case HAL_BT_COEX_STOMP_NONE:</a>
<a name="ln2453">    case HAL_BT_COEX_NO_STOMP:</a>
<a name="ln2454">        ahp-&gt;ah_bt_coex_wlan_weight[0] = AR9300_STOMP_NONE_WLAN_WGHT0;</a>
<a name="ln2455">        ahp-&gt;ah_bt_coex_wlan_weight[1] = AR9300_STOMP_NONE_WLAN_WGHT1;</a>
<a name="ln2456">        break;</a>
<a name="ln2457">    default:</a>
<a name="ln2458">        /* There is a force_weight from registry */</a>
<a name="ln2459">        ahp-&gt;ah_bt_coex_wlan_weight[0] = stomp_type;</a>
<a name="ln2460">        ahp-&gt;ah_bt_coex_wlan_weight[1] = stomp_type;</a>
<a name="ln2461">        break;</a>
<a name="ln2462">    }</a>
<a name="ln2463">}</a>
<a name="ln2464"> </a>
<a name="ln2465">void</a>
<a name="ln2466">ar9300_bt_coex_setup_bmiss_thresh(struct ath_hal *ah, u_int32_t thresh)</a>
<a name="ln2467">{</a>
<a name="ln2468">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2469"> </a>
<a name="ln2470">    /* clear the old value, then set the new value */</a>
<a name="ln2471">    ahp-&gt;ah_bt_coex_mode2 &amp;= ~AR_BT_BCN_MISS_THRESH;</a>
<a name="ln2472">    ahp-&gt;ah_bt_coex_mode2 |= SM(thresh, AR_BT_BCN_MISS_THRESH);</a>
<a name="ln2473">}</a>
<a name="ln2474"> </a>
<a name="ln2475">static void</a>
<a name="ln2476">ar9300_bt_coex_antenna_diversity(struct ath_hal *ah, u_int32_t value)</a>
<a name="ln2477">{</a>
<a name="ln2478">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2479">#if ATH_ANT_DIV_COMB</a>
<a name="ln2480">    //struct ath_hal_private *ahpriv = AH_PRIVATE(ah);</a>
<a name="ln2481">    const struct ieee80211_channel *chan = AH_PRIVATE(ah)-&gt;ah_curchan;</a>
<a name="ln2482">#endif</a>
<a name="ln2483"> </a>
<a name="ln2484">    HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;%s: called, value=%d\n&quot;, __func__, value);</a>
<a name="ln2485"> </a>
<a name="ln2486">    if (ahp-&gt;ah_bt_coex_flag &amp; HAL_BT_COEX_FLAG_ANT_DIV_ALLOW)</a>
<a name="ln2487">    {</a>
<a name="ln2488">        if (ahp-&gt;ah_diversity_control == HAL_ANT_VARIABLE)</a>
<a name="ln2489">        {</a>
<a name="ln2490">            /* Config antenna diversity */</a>
<a name="ln2491">#if ATH_ANT_DIV_COMB</a>
<a name="ln2492">            ar9300_ant_ctrl_set_lna_div_use_bt_ant(ah, value, chan);</a>
<a name="ln2493">#endif</a>
<a name="ln2494">        }</a>
<a name="ln2495">    }</a>
<a name="ln2496">}</a>
<a name="ln2497"> </a>
<a name="ln2498"> </a>
<a name="ln2499">void</a>
<a name="ln2500">ar9300_bt_coex_set_parameter(struct ath_hal *ah, u_int32_t type,</a>
<a name="ln2501">    u_int32_t value)</a>
<a name="ln2502">{</a>
<a name="ln2503">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2504">    struct ath_hal_private *ahpriv = AH_PRIVATE(ah);</a>
<a name="ln2505"> </a>
<a name="ln2506">    switch (type) {</a>
<a name="ln2507">        case HAL_BT_COEX_SET_ACK_PWR:</a>
<a name="ln2508">            if (value) {</a>
<a name="ln2509">                ahp-&gt;ah_bt_coex_flag |= HAL_BT_COEX_FLAG_LOW_ACK_PWR;</a>
<a name="ln2510">            } else {</a>
<a name="ln2511">                ahp-&gt;ah_bt_coex_flag &amp;= ~HAL_BT_COEX_FLAG_LOW_ACK_PWR;</a>
<a name="ln2512">            }</a>
<a name="ln2513">            ar9300_set_tx_power_limit(ah, ahpriv-&gt;ah_powerLimit,</a>
<a name="ln2514">                ahpriv-&gt;ah_extraTxPow, 0);</a>
<a name="ln2515">            break;</a>
<a name="ln2516"> </a>
<a name="ln2517">        case HAL_BT_COEX_ANTENNA_DIVERSITY:</a>
<a name="ln2518">            if (AR_SREV_POSEIDON(ah) || AR_SREV_APHRODITE(ah)) {</a>
<a name="ln2519">                ahp-&gt;ah_bt_coex_flag |= HAL_BT_COEX_FLAG_ANT_DIV_ALLOW;</a>
<a name="ln2520">                if (value) {</a>
<a name="ln2521">                    ahp-&gt;ah_bt_coex_flag |= HAL_BT_COEX_FLAG_ANT_DIV_ENABLE;</a>
<a name="ln2522">                }</a>
<a name="ln2523">                else {</a>
<a name="ln2524">                    ahp-&gt;ah_bt_coex_flag &amp;= ~HAL_BT_COEX_FLAG_ANT_DIV_ENABLE;</a>
<a name="ln2525">                }</a>
<a name="ln2526">                ar9300_bt_coex_antenna_diversity(ah, value);</a>
<a name="ln2527">            }</a>
<a name="ln2528">            break;</a>
<a name="ln2529">        case HAL_BT_COEX_LOWER_TX_PWR:</a>
<a name="ln2530">            if (value) {</a>
<a name="ln2531">                ahp-&gt;ah_bt_coex_flag |= HAL_BT_COEX_FLAG_LOWER_TX_PWR;</a>
<a name="ln2532">            }</a>
<a name="ln2533">            else {</a>
<a name="ln2534">                ahp-&gt;ah_bt_coex_flag &amp;= ~HAL_BT_COEX_FLAG_LOWER_TX_PWR;</a>
<a name="ln2535">            }</a>
<a name="ln2536">            ar9300_set_tx_power_limit(ah, ahpriv-&gt;ah_powerLimit,</a>
<a name="ln2537">                                      ahpriv-&gt;ah_extraTxPow, 0);</a>
<a name="ln2538">            break;</a>
<a name="ln2539">#if ATH_SUPPORT_MCI</a>
<a name="ln2540">        case HAL_BT_COEX_MCI_MAX_TX_PWR:</a>
<a name="ln2541">            if ((ah-&gt;ah_config.ath_hal_mci_config &amp; </a>
<a name="ln2542">                 ATH_MCI_CONFIG_CONCUR_TX) == ATH_MCI_CONCUR_TX_SHARED_CHN)</a>
<a name="ln2543">            {</a>
<a name="ln2544">                if (value) {</a>
<a name="ln2545">                    ahp-&gt;ah_bt_coex_flag |= HAL_BT_COEX_FLAG_MCI_MAX_TX_PWR;</a>
<a name="ln2546">                    ahp-&gt;ah_mci_concur_tx_en = AH_TRUE;</a>
<a name="ln2547">                }</a>
<a name="ln2548">                else {</a>
<a name="ln2549">                    ahp-&gt;ah_bt_coex_flag &amp;= ~HAL_BT_COEX_FLAG_MCI_MAX_TX_PWR;</a>
<a name="ln2550">                    ahp-&gt;ah_mci_concur_tx_en = AH_FALSE;</a>
<a name="ln2551">                }</a>
<a name="ln2552">                ar9300_set_tx_power_limit(ah, ahpriv-&gt;ah_powerLimit,</a>
<a name="ln2553">                                          ahpriv-&gt;ah_extraTxPow, 0);</a>
<a name="ln2554">            }</a>
<a name="ln2555">            HALDEBUG(ah, HAL_DEBUG_BT_COEX, &quot;(MCI) concur_tx_en = %d\n&quot;, </a>
<a name="ln2556">                     ahp-&gt;ah_mci_concur_tx_en);</a>
<a name="ln2557">            break;</a>
<a name="ln2558">        case HAL_BT_COEX_MCI_FTP_STOMP_RX:</a>
<a name="ln2559">            if (value) {</a>
<a name="ln2560">                ahp-&gt;ah_bt_coex_flag |= HAL_BT_COEX_FLAG_MCI_FTP_STOMP_RX;</a>
<a name="ln2561">            }</a>
<a name="ln2562">            else {</a>
<a name="ln2563">                ahp-&gt;ah_bt_coex_flag &amp;= ~HAL_BT_COEX_FLAG_MCI_FTP_STOMP_RX;</a>
<a name="ln2564">            }</a>
<a name="ln2565">            break;</a>
<a name="ln2566">#endif</a>
<a name="ln2567">        default:</a>
<a name="ln2568">            break;</a>
<a name="ln2569">    }</a>
<a name="ln2570">}</a>
<a name="ln2571"> </a>
<a name="ln2572">void</a>
<a name="ln2573">ar9300_bt_coex_disable(struct ath_hal *ah)</a>
<a name="ln2574">{</a>
<a name="ln2575">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2576"> </a>
<a name="ln2577">    /* Always drive rx_clear_external output as 0 */</a>
<a name="ln2578">    ath_hal_gpioCfgOutput(ah, ahp-&gt;ah_wlan_active_gpio_select,</a>
<a name="ln2579">        HAL_GPIO_OUTPUT_MUX_AS_OUTPUT);</a>
<a name="ln2580"> </a>
<a name="ln2581">    if (ahp-&gt;ah_bt_coex_single_ant == AH_TRUE) {</a>
<a name="ln2582">        OS_REG_RMW_FIELD(ah, AR_QUIET1, AR_QUIET1_QUIET_ACK_CTS_ENABLE, 1); </a>
<a name="ln2583">        OS_REG_RMW_FIELD(ah, AR_PCU_MISC, AR_PCU_BT_ANT_PREVENT_RX, 0);</a>
<a name="ln2584">    }</a>
<a name="ln2585"> </a>
<a name="ln2586">    OS_REG_WRITE(ah, AR_BT_COEX_MODE, AR_BT_QUIET | AR_BT_MODE);</a>
<a name="ln2587">    OS_REG_WRITE(ah, AR_BT_COEX_MODE2, 0);</a>
<a name="ln2588">    OS_REG_WRITE(ah, AR_BT_COEX_WL_WEIGHTS0, 0);</a>
<a name="ln2589">    OS_REG_WRITE(ah, AR_BT_COEX_WL_WEIGHTS1, 0);</a>
<a name="ln2590">    OS_REG_WRITE(ah, AR_BT_COEX_BT_WEIGHTS0, 0);</a>
<a name="ln2591">    OS_REG_WRITE(ah, AR_BT_COEX_BT_WEIGHTS1, 0);</a>
<a name="ln2592">    OS_REG_WRITE(ah, AR_BT_COEX_BT_WEIGHTS2, 0);</a>
<a name="ln2593">    OS_REG_WRITE(ah, AR_BT_COEX_BT_WEIGHTS3, 0);</a>
<a name="ln2594"> </a>
<a name="ln2595">    ahp-&gt;ah_bt_coex_enabled = AH_FALSE;</a>
<a name="ln2596">}</a>
<a name="ln2597"> </a>
<a name="ln2598">int</a>
<a name="ln2599">ar9300_bt_coex_enable(struct ath_hal *ah)</a>
<a name="ln2600">{</a>
<a name="ln2601">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2602"> </a>
<a name="ln2603">    /* Program coex mode and weight registers to actually enable coex */</a>
<a name="ln2604">    OS_REG_WRITE(ah, AR_BT_COEX_MODE, ahp-&gt;ah_bt_coex_mode);</a>
<a name="ln2605">    OS_REG_WRITE(ah, AR_BT_COEX_MODE2, ahp-&gt;ah_bt_coex_mode2);</a>
<a name="ln2606">    OS_REG_WRITE(ah, AR_BT_COEX_WL_WEIGHTS0, ahp-&gt;ah_bt_coex_wlan_weight[0]);</a>
<a name="ln2607">    OS_REG_WRITE(ah, AR_BT_COEX_WL_WEIGHTS1, ahp-&gt;ah_bt_coex_wlan_weight[1]);</a>
<a name="ln2608">    OS_REG_WRITE(ah, AR_BT_COEX_BT_WEIGHTS0, ahp-&gt;ah_bt_coex_bt_weight[0]);</a>
<a name="ln2609">    OS_REG_WRITE(ah, AR_BT_COEX_BT_WEIGHTS1, ahp-&gt;ah_bt_coex_bt_weight[1]);</a>
<a name="ln2610">    OS_REG_WRITE(ah, AR_BT_COEX_BT_WEIGHTS2, ahp-&gt;ah_bt_coex_bt_weight[2]);</a>
<a name="ln2611">    OS_REG_WRITE(ah, AR_BT_COEX_BT_WEIGHTS3, ahp-&gt;ah_bt_coex_bt_weight[3]);</a>
<a name="ln2612"> </a>
<a name="ln2613">    if (ahp-&gt;ah_bt_coex_flag &amp; HAL_BT_COEX_FLAG_LOW_ACK_PWR) {</a>
<a name="ln2614">        OS_REG_WRITE(ah, AR_TPC, HAL_BT_COEX_LOW_ACK_POWER);</a>
<a name="ln2615">    } else {</a>
<a name="ln2616">        OS_REG_WRITE(ah, AR_TPC, HAL_BT_COEX_HIGH_ACK_POWER);</a>
<a name="ln2617">    }</a>
<a name="ln2618"> </a>
<a name="ln2619">    OS_REG_RMW_FIELD(ah, AR_QUIET1, AR_QUIET1_QUIET_ACK_CTS_ENABLE, 1);</a>
<a name="ln2620">    if (ahp-&gt;ah_bt_coex_single_ant == AH_TRUE) {       </a>
<a name="ln2621">        OS_REG_RMW_FIELD(ah, AR_PCU_MISC, AR_PCU_BT_ANT_PREVENT_RX, 1);</a>
<a name="ln2622">    } else {</a>
<a name="ln2623">        OS_REG_RMW_FIELD(ah, AR_PCU_MISC, AR_PCU_BT_ANT_PREVENT_RX, 0);</a>
<a name="ln2624">    }</a>
<a name="ln2625"> </a>
<a name="ln2626">    if (ahp-&gt;ah_bt_coex_config_type == HAL_BT_COEX_CFG_3WIRE) {</a>
<a name="ln2627">        /* For 3-wire, configure the desired GPIO port for rx_clear */</a>
<a name="ln2628">        ath_hal_gpioCfgOutput(ah,</a>
<a name="ln2629">            ahp-&gt;ah_wlan_active_gpio_select,</a>
<a name="ln2630">            HAL_GPIO_OUTPUT_MUX_AS_WLAN_ACTIVE);</a>
<a name="ln2631">    }</a>
<a name="ln2632">    else if ((ahp-&gt;ah_bt_coex_config_type &gt;= HAL_BT_COEX_CFG_2WIRE_2CH) &amp;&amp;</a>
<a name="ln2633">        (ahp-&gt;ah_bt_coex_config_type &lt;= HAL_BT_COEX_CFG_2WIRE_CH0))</a>
<a name="ln2634">    {</a>
<a name="ln2635">        /* For 2-wire, configure the desired GPIO port for TX_FRAME output */</a>
<a name="ln2636">        ath_hal_gpioCfgOutput(ah,</a>
<a name="ln2637">            ahp-&gt;ah_wlan_active_gpio_select,</a>
<a name="ln2638">            HAL_GPIO_OUTPUT_MUX_AS_TX_FRAME);</a>
<a name="ln2639">    }</a>
<a name="ln2640"> </a>
<a name="ln2641">    /*</a>
<a name="ln2642">     * Enable a weak pull down on BT_ACTIVE.</a>
<a name="ln2643">     * When BT device is disabled, BT_ACTIVE might be floating.</a>
<a name="ln2644">     */</a>
<a name="ln2645">    OS_REG_RMW(ah, AR_HOSTIF_REG(ah, AR_GPIO_PDPU),</a>
<a name="ln2646">        (AR_GPIO_PULL_DOWN &lt;&lt; (ahp-&gt;ah_bt_active_gpio_select * 2)), </a>
<a name="ln2647">        (AR_GPIO_PDPU_OPTION &lt;&lt; (ahp-&gt;ah_bt_active_gpio_select * 2)));</a>
<a name="ln2648"> </a>
<a name="ln2649">    ahp-&gt;ah_bt_coex_enabled = AH_TRUE;</a>
<a name="ln2650"> </a>
<a name="ln2651">    return 0;</a>
<a name="ln2652">}</a>
<a name="ln2653"> </a>
<a name="ln2654">u_int32_t ar9300_get_bt_active_gpio(struct ath_hal *ah, u_int32_t reg)</a>
<a name="ln2655">{</a>
<a name="ln2656">    return 0;</a>
<a name="ln2657">}</a>
<a name="ln2658"> </a>
<a name="ln2659">u_int32_t ar9300_get_wlan_active_gpio(struct ath_hal *ah, u_int32_t reg,u_int32_t bOn)</a>
<a name="ln2660">{</a>
<a name="ln2661">    return bOn;</a>
<a name="ln2662">}</a>
<a name="ln2663"> </a>
<a name="ln2664">void</a>
<a name="ln2665">ar9300_init_bt_coex(struct ath_hal *ah)</a>
<a name="ln2666">{</a>
<a name="ln2667">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2668"> </a>
<a name="ln2669">    if (ahp-&gt;ah_bt_coex_config_type == HAL_BT_COEX_CFG_3WIRE) {</a>
<a name="ln2670">        OS_REG_SET_BIT(ah, AR_HOSTIF_REG(ah, AR_GPIO_INPUT_EN_VAL),</a>
<a name="ln2671">                   (AR_GPIO_INPUT_EN_VAL_BT_PRIORITY_BB |</a>
<a name="ln2672">                    AR_GPIO_INPUT_EN_VAL_BT_ACTIVE_BB));</a>
<a name="ln2673"> </a>
<a name="ln2674">        /*</a>
<a name="ln2675">         * Set input mux for bt_prority_async and</a>
<a name="ln2676">         * bt_active_async to GPIO pins</a>
<a name="ln2677">         */</a>
<a name="ln2678">        OS_REG_RMW_FIELD(ah,</a>
<a name="ln2679">            AR_HOSTIF_REG(ah, AR_GPIO_INPUT_MUX1),</a>
<a name="ln2680">            AR_GPIO_INPUT_MUX1_BT_ACTIVE,</a>
<a name="ln2681">            ahp-&gt;ah_bt_active_gpio_select);</a>
<a name="ln2682">        OS_REG_RMW_FIELD(ah,</a>
<a name="ln2683">            AR_HOSTIF_REG(ah, AR_GPIO_INPUT_MUX1),</a>
<a name="ln2684">            AR_GPIO_INPUT_MUX1_BT_PRIORITY,</a>
<a name="ln2685">            ahp-&gt;ah_bt_priority_gpio_select);</a>
<a name="ln2686"> </a>
<a name="ln2687">        /* Configure the desired GPIO ports for input */</a>
<a name="ln2688">        ath_hal_gpioCfgInput(ah, ahp-&gt;ah_bt_active_gpio_select);</a>
<a name="ln2689">        ath_hal_gpioCfgInput(ah, ahp-&gt;ah_bt_priority_gpio_select);</a>
<a name="ln2690"> </a>
<a name="ln2691">        if (ahp-&gt;ah_bt_coex_enabled) {</a>
<a name="ln2692">            ar9300_bt_coex_enable(ah);</a>
<a name="ln2693">        } else {</a>
<a name="ln2694">            ar9300_bt_coex_disable(ah);</a>
<a name="ln2695">        }</a>
<a name="ln2696">    }</a>
<a name="ln2697">    else if ((ahp-&gt;ah_bt_coex_config_type &gt;= HAL_BT_COEX_CFG_2WIRE_2CH) &amp;&amp;</a>
<a name="ln2698">        (ahp-&gt;ah_bt_coex_config_type &lt;= HAL_BT_COEX_CFG_2WIRE_CH0))</a>
<a name="ln2699">    {</a>
<a name="ln2700">        /* 2-wire */</a>
<a name="ln2701">        if (ahp-&gt;ah_bt_coex_enabled) {</a>
<a name="ln2702">            /* Connect bt_active_async to baseband */</a>
<a name="ln2703">            OS_REG_CLR_BIT(ah,</a>
<a name="ln2704">                AR_HOSTIF_REG(ah, AR_GPIO_INPUT_EN_VAL), </a>
<a name="ln2705">                (AR_GPIO_INPUT_EN_VAL_BT_PRIORITY_DEF |</a>
<a name="ln2706">                 AR_GPIO_INPUT_EN_VAL_BT_FREQUENCY_DEF));</a>
<a name="ln2707">            OS_REG_SET_BIT(ah,</a>
<a name="ln2708">                AR_HOSTIF_REG(ah, AR_GPIO_INPUT_EN_VAL),</a>
<a name="ln2709">                AR_GPIO_INPUT_EN_VAL_BT_ACTIVE_BB);</a>
<a name="ln2710"> </a>
<a name="ln2711">            /*</a>
<a name="ln2712">             * Set input mux for bt_prority_async and</a>
<a name="ln2713">             * bt_active_async to GPIO pins</a>
<a name="ln2714">             */</a>
<a name="ln2715">            OS_REG_RMW_FIELD(ah,</a>
<a name="ln2716">                AR_HOSTIF_REG(ah, AR_GPIO_INPUT_MUX1),</a>
<a name="ln2717">                AR_GPIO_INPUT_MUX1_BT_ACTIVE,</a>
<a name="ln2718">                ahp-&gt;ah_bt_active_gpio_select);</a>
<a name="ln2719"> </a>
<a name="ln2720">            /* Configure the desired GPIO ports for input */</a>
<a name="ln2721">            ath_hal_gpioCfgInput(ah, ahp-&gt;ah_bt_active_gpio_select);</a>
<a name="ln2722"> </a>
<a name="ln2723">            /* Enable coexistence on initialization */</a>
<a name="ln2724">            ar9300_bt_coex_enable(ah);</a>
<a name="ln2725">        }</a>
<a name="ln2726">    }</a>
<a name="ln2727">#if ATH_SUPPORT_MCI</a>
<a name="ln2728">    else if (ahp-&gt;ah_bt_coex_config_type == HAL_BT_COEX_CFG_MCI) {</a>
<a name="ln2729">        if (ahp-&gt;ah_bt_coex_enabled) {</a>
<a name="ln2730">            ar9300_mci_bt_coex_enable(ah);</a>
<a name="ln2731">        }</a>
<a name="ln2732">        else {</a>
<a name="ln2733">            ar9300_mci_bt_coex_disable(ah);</a>
<a name="ln2734">        }</a>
<a name="ln2735">    }</a>
<a name="ln2736">#endif /* ATH_SUPPORT_MCI */</a>
<a name="ln2737">}</a>
<a name="ln2738"> </a>
<a name="ln2739">#endif /* ATH_BT_COEX */</a>
<a name="ln2740"> </a>
<a name="ln2741">HAL_STATUS ar9300_set_proxy_sta(struct ath_hal *ah, HAL_BOOL enable)</a>
<a name="ln2742">{</a>
<a name="ln2743">    u_int32_t val;</a>
<a name="ln2744">    int wasp_mm_rev;</a>
<a name="ln2745"> </a>
<a name="ln2746">#define AR_SOC_RST_REVISION_ID      0xB8060090</a>
<a name="ln2747">#define REG_READ(_reg)              *((volatile u_int32_t *)(_reg))</a>
<a name="ln2748">    wasp_mm_rev = (REG_READ(AR_SOC_RST_REVISION_ID) &amp;</a>
<a name="ln2749">            AR_SREV_REVISION_WASP_MINOR_MINOR_MASK) &gt;&gt;</a>
<a name="ln2750">            AR_SREV_REVISION_WASP_MINOR_MINOR_SHIFT;</a>
<a name="ln2751">#undef AR_SOC_RST_REVISION_ID</a>
<a name="ln2752">#undef REG_READ</a>
<a name="ln2753"> </a>
<a name="ln2754">    /*</a>
<a name="ln2755">     * Azimuth (ProxySTA) Mode is only supported correctly by</a>
<a name="ln2756">     * Peacock or WASP 1.3.0.1 or later (hopefully) chips.</a>
<a name="ln2757">     *</a>
<a name="ln2758">     * Enable this feature for Scorpion at this time. The silicon</a>
<a name="ln2759">     * still needs to be validated.</a>
<a name="ln2760">     */</a>
<a name="ln2761">    if (!(AH_PRIVATE((ah))-&gt;ah_macVersion == AR_SREV_VERSION_AR9580) &amp;&amp; </a>
<a name="ln2762">        !(AH_PRIVATE((ah))-&gt;ah_macVersion == AR_SREV_VERSION_SCORPION) &amp;&amp; </a>
<a name="ln2763">        !((AH_PRIVATE((ah))-&gt;ah_macVersion == AR_SREV_VERSION_WASP) &amp;&amp;  </a>
<a name="ln2764">          ((AH_PRIVATE((ah))-&gt;ah_macRev &gt; AR_SREV_REVISION_WASP_13) ||</a>
<a name="ln2765">           (AH_PRIVATE((ah))-&gt;ah_macRev == AR_SREV_REVISION_WASP_13 &amp;&amp; </a>
<a name="ln2766">            wasp_mm_rev &gt;= 0 /* 1 */))))</a>
<a name="ln2767">    {</a>
<a name="ln2768">        HALDEBUG(ah, HAL_DEBUG_UNMASKABLE, &quot;%s error: current chip (ver 0x%x, &quot;</a>
<a name="ln2769">                &quot;rev 0x%x, minor minor rev 0x%x) cannot support Azimuth Mode\n&quot;,</a>
<a name="ln2770">                __func__, AH_PRIVATE((ah))-&gt;ah_macVersion,</a>
<a name="ln2771">                AH_PRIVATE((ah))-&gt;ah_macRev, wasp_mm_rev);</a>
<a name="ln2772">        return HAL_ENOTSUPP;</a>
<a name="ln2773">    }</a>
<a name="ln2774"> </a>
<a name="ln2775">    OS_REG_WRITE(ah,</a>
<a name="ln2776">        AR_MAC_PCU_LOGIC_ANALYZER, AR_MAC_PCU_LOGIC_ANALYZER_PSTABUG75996);</a>
<a name="ln2777"> </a>
<a name="ln2778">    /* turn on mode bit[24] for proxy sta */</a>
<a name="ln2779">    OS_REG_WRITE(ah, AR_PCU_MISC_MODE2, </a>
<a name="ln2780">        OS_REG_READ(ah, AR_PCU_MISC_MODE2) | AR_PCU_MISC_MODE2_PROXY_STA);</a>
<a name="ln2781"> </a>
<a name="ln2782">    val = OS_REG_READ(ah, AR_AZIMUTH_MODE);</a>
<a name="ln2783">    if (enable) {</a>
<a name="ln2784">        val |= AR_AZIMUTH_KEY_SEARCH_AD1 | </a>
<a name="ln2785">               AR_AZIMUTH_CTS_MATCH_TX_AD2 | </a>
<a name="ln2786">               AR_AZIMUTH_BA_USES_AD1;</a>
<a name="ln2787">        /* turn off filter pass hold (bit 9) */</a>
<a name="ln2788">        val &amp;= ~AR_AZIMUTH_FILTER_PASS_HOLD;</a>
<a name="ln2789">    } else {</a>
<a name="ln2790">        val &amp;= ~(AR_AZIMUTH_KEY_SEARCH_AD1 | </a>
<a name="ln2791">                 AR_AZIMUTH_CTS_MATCH_TX_AD2 | </a>
<a name="ln2792">                 AR_AZIMUTH_BA_USES_AD1);</a>
<a name="ln2793">    }</a>
<a name="ln2794">    OS_REG_WRITE(ah, AR_AZIMUTH_MODE, val);</a>
<a name="ln2795"> </a>
<a name="ln2796">    /* enable promiscous mode */</a>
<a name="ln2797">    OS_REG_WRITE(ah, AR_RX_FILTER, </a>
<a name="ln2798">        OS_REG_READ(ah, AR_RX_FILTER) | HAL_RX_FILTER_PROM);</a>
<a name="ln2799">    /* enable promiscous in azimuth mode */</a>
<a name="ln2800">    OS_REG_WRITE(ah, AR_PCU_MISC_MODE2, AR_PCU_MISC_MODE2_PROM_VC_MODE);</a>
<a name="ln2801">    OS_REG_WRITE(ah, AR_MAC_PCU_LOGIC_ANALYZER, AR_MAC_PCU_LOGIC_ANALYZER_VC_MODE);</a>
<a name="ln2802"> </a>
<a name="ln2803">    /* turn on filter pass hold (bit 9) */</a>
<a name="ln2804">    OS_REG_WRITE(ah, AR_AZIMUTH_MODE,</a>
<a name="ln2805">        OS_REG_READ(ah, AR_AZIMUTH_MODE) | AR_AZIMUTH_FILTER_PASS_HOLD);</a>
<a name="ln2806"> </a>
<a name="ln2807">    return HAL_OK;</a>
<a name="ln2808">}</a>
<a name="ln2809"> </a>
<a name="ln2810">#if 0</a>
<a name="ln2811">void ar9300_mat_enable(struct ath_hal *ah, int enable)</a>
<a name="ln2812">{</a>
<a name="ln2813">    /*</a>
<a name="ln2814">     * MAT (s/w ProxySTA) implementation requires to turn off interrupt</a>
<a name="ln2815">     * mitigation and turn on key search always for better performance.</a>
<a name="ln2816">     */</a>
<a name="ln2817">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2818">    struct ath_hal_private *ap = AH_PRIVATE(ah);</a>
<a name="ln2819"> </a>
<a name="ln2820">    ahp-&gt;ah_intr_mitigation_rx = !enable;</a>
<a name="ln2821">    if (ahp-&gt;ah_intr_mitigation_rx) {</a>
<a name="ln2822">        /*</a>
<a name="ln2823">         * Enable Interrupt Mitigation for Rx.</a>
<a name="ln2824">         * If no build-specific limits for the rx interrupt mitigation</a>
<a name="ln2825">         * timer have been specified, use conservative defaults.</a>
<a name="ln2826">         */</a>
<a name="ln2827">        #ifndef AH_RIMT_VAL_LAST</a>
<a name="ln2828">            #define AH_RIMT_LAST_MICROSEC 500</a>
<a name="ln2829">        #endif</a>
<a name="ln2830">        #ifndef AH_RIMT_VAL_FIRST</a>
<a name="ln2831">            #define AH_RIMT_FIRST_MICROSEC 2000</a>
<a name="ln2832">        #endif</a>
<a name="ln2833">        OS_REG_RMW_FIELD(ah, AR_RIMT, AR_RIMT_LAST, AH_RIMT_LAST_MICROSEC);</a>
<a name="ln2834">        OS_REG_RMW_FIELD(ah, AR_RIMT, AR_RIMT_FIRST, AH_RIMT_FIRST_MICROSEC);</a>
<a name="ln2835">    } else {</a>
<a name="ln2836">        OS_REG_WRITE(ah, AR_RIMT, 0);</a>
<a name="ln2837">    }</a>
<a name="ln2838"> </a>
<a name="ln2839">    ahp-&gt;ah_enable_keysearch_always = !!enable;</a>
<a name="ln2840">    ar9300_enable_keysearch_always(ah, ahp-&gt;ah_enable_keysearch_always);</a>
<a name="ln2841">}</a>
<a name="ln2842">#endif</a>
<a name="ln2843"> </a>
<a name="ln2844">void ar9300_enable_tpc(struct ath_hal *ah)</a>
<a name="ln2845">{</a>
<a name="ln2846">    u_int32_t val = 0;</a>
<a name="ln2847"> </a>
<a name="ln2848">    ah-&gt;ah_config.ath_hal_desc_tpc = 1;</a>
<a name="ln2849"> </a>
<a name="ln2850">    /* Enable TPC */</a>
<a name="ln2851">    OS_REG_RMW_FIELD(ah, AR_PHY_PWRTX_MAX, AR_PHY_PER_PACKET_POWERTX_MAX, 1);</a>
<a name="ln2852"> </a>
<a name="ln2853">    /*</a>
<a name="ln2854">     * Disable per chain power reduction since we are already</a>
<a name="ln2855">     * accounting for this in our calculations</a>
<a name="ln2856">     */</a>
<a name="ln2857">    val = OS_REG_READ(ah, AR_PHY_POWER_TX_SUB);</a>
<a name="ln2858">    if (AR_SREV_WASP(ah)) {</a>
<a name="ln2859">        OS_REG_WRITE(ah, AR_PHY_POWER_TX_SUB,</a>
<a name="ln2860">                         val &amp; AR_PHY_POWER_TX_SUB_2_DISABLE);</a>
<a name="ln2861">    } else {</a>
<a name="ln2862">        OS_REG_WRITE(ah, AR_PHY_POWER_TX_SUB,</a>
<a name="ln2863">                         val &amp; AR_PHY_POWER_TX_SUB_3_DISABLE);</a>
<a name="ln2864">    }</a>
<a name="ln2865">}</a>
<a name="ln2866"> </a>
<a name="ln2867"> </a>
<a name="ln2868">/*</a>
<a name="ln2869"> * ar9300_force_tsf_sync </a>
<a name="ln2870"> * This function forces the TSF sync to the given bssid, this is implemented</a>
<a name="ln2871"> * as a temp hack to get the AoW demo, and is primarily used in the WDS client</a>
<a name="ln2872"> * mode of operation, where we sync the TSF to RootAP TSF values</a>
<a name="ln2873"> */</a>
<a name="ln2874">void</a>
<a name="ln2875">ar9300_force_tsf_sync(struct ath_hal *ah, const u_int8_t *bssid,</a>
<a name="ln2876">    u_int16_t assoc_id)</a>
<a name="ln2877">{</a>
<a name="ln2878">    ar9300_set_operating_mode(ah, HAL_M_STA);</a>
<a name="ln2879">    ar9300_write_associd(ah, bssid, assoc_id);</a>
<a name="ln2880">}</a>
<a name="ln2881"> </a>
<a name="ln2882">void ar9300_chk_rssi_update_tx_pwr(struct ath_hal *ah, int rssi)</a>
<a name="ln2883">{</a>
<a name="ln2884">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln2885">    u_int32_t           temp_obdb_reg_val = 0, temp_tcp_reg_val;</a>
<a name="ln2886">    u_int32_t           temp_powertx_rate9_reg_val;</a>
<a name="ln2887">    int8_t              olpc_power_offset = 0;</a>
<a name="ln2888">    int8_t              tmp_olpc_val = 0;</a>
<a name="ln2889">    HAL_RSSI_TX_POWER   old_greentx_status;</a>
<a name="ln2890">    u_int8_t            target_power_val_t[ar9300_rate_size];</a>
<a name="ln2891">    int8_t              tmp_rss1_thr1, tmp_rss1_thr2;</a>
<a name="ln2892"> </a>
<a name="ln2893">    if ((AH_PRIVATE(ah)-&gt;ah_opmode != HAL_M_STA) || </a>
<a name="ln2894">        !ah-&gt;ah_config.ath_hal_sta_update_tx_pwr_enable) {</a>
<a name="ln2895">        return;</a>
<a name="ln2896">    }</a>
<a name="ln2897">    </a>
<a name="ln2898">    old_greentx_status = AH9300(ah)-&gt;green_tx_status;</a>
<a name="ln2899">    if (ahp-&gt;ah_hw_green_tx_enable) {</a>
<a name="ln2900">        tmp_rss1_thr1 = AR9485_HW_GREEN_TX_THRES1_DB;</a>
<a name="ln2901">        tmp_rss1_thr2 = AR9485_HW_GREEN_TX_THRES2_DB;</a>
<a name="ln2902">    } else {</a>
<a name="ln2903">        tmp_rss1_thr1 = WB225_SW_GREEN_TX_THRES1_DB;</a>
<a name="ln2904">        tmp_rss1_thr2 = WB225_SW_GREEN_TX_THRES2_DB;</a>
<a name="ln2905">    }</a>
<a name="ln2906">    </a>
<a name="ln2907">    if ((ah-&gt;ah_config.ath_hal_sta_update_tx_pwr_enable_S1) </a>
<a name="ln2908">        &amp;&amp; (rssi &gt; tmp_rss1_thr1)) </a>
<a name="ln2909">    {</a>
<a name="ln2910">        if (old_greentx_status != HAL_RSSI_TX_POWER_SHORT) {</a>
<a name="ln2911">            AH9300(ah)-&gt;green_tx_status = HAL_RSSI_TX_POWER_SHORT;</a>
<a name="ln2912">        }</a>
<a name="ln2913">    } else if (ah-&gt;ah_config.ath_hal_sta_update_tx_pwr_enable_S2 </a>
<a name="ln2914">        &amp;&amp; (rssi &gt; tmp_rss1_thr2)) </a>
<a name="ln2915">    {</a>
<a name="ln2916">        if (old_greentx_status != HAL_RSSI_TX_POWER_MIDDLE) {</a>
<a name="ln2917">            AH9300(ah)-&gt;green_tx_status = HAL_RSSI_TX_POWER_MIDDLE;</a>
<a name="ln2918">        }</a>
<a name="ln2919">    } else if (ah-&gt;ah_config.ath_hal_sta_update_tx_pwr_enable_S3) {</a>
<a name="ln2920">        if (old_greentx_status != HAL_RSSI_TX_POWER_LONG) {</a>
<a name="ln2921">            AH9300(ah)-&gt;green_tx_status = HAL_RSSI_TX_POWER_LONG;</a>
<a name="ln2922">        }</a>
<a name="ln2923">    }</a>
<a name="ln2924"> </a>
<a name="ln2925">    /* If status is not change, don't do anything */</a>
<a name="ln2926">    if (old_greentx_status == AH9300(ah)-&gt;green_tx_status) {</a>
<a name="ln2927">        return;</a>
<a name="ln2928">    }</a>
<a name="ln2929">    </a>
<a name="ln2930">    /* for Poseidon which ath_hal_sta_update_tx_pwr_enable is enabled */</a>
<a name="ln2931">    if ((AH9300(ah)-&gt;green_tx_status != HAL_RSSI_TX_POWER_NONE) </a>
<a name="ln2932">        &amp;&amp; AR_SREV_POSEIDON(ah)) </a>
<a name="ln2933">    {</a>
<a name="ln2934">        if (ahp-&gt;ah_hw_green_tx_enable) {</a>
<a name="ln2935">            switch (AH9300(ah)-&gt;green_tx_status) {</a>
<a name="ln2936">            case HAL_RSSI_TX_POWER_SHORT:</a>
<a name="ln2937">                /* 1. TxPower Config */</a>
<a name="ln2938">                OS_MEMCPY(target_power_val_t, ar9485_hw_gtx_tp_distance_short,</a>
<a name="ln2939">                    sizeof(target_power_val_t));</a>
<a name="ln2940">                /* 1.1 Store OLPC Delta Calibration Offset*/</a>
<a name="ln2941">                olpc_power_offset = 0;</a>
<a name="ln2942">                /* 2. Store OB/DB */</a>
<a name="ln2943">                /* 3. Store TPC settting */</a>
<a name="ln2944">                temp_tcp_reg_val = (SM(14, AR_TPC_ACK) |</a>
<a name="ln2945">                                    SM(14, AR_TPC_CTS) |</a>
<a name="ln2946">                                    SM(14, AR_TPC_CHIRP) |</a>
<a name="ln2947">                                    SM(14, AR_TPC_RPT));</a>
<a name="ln2948">                /* 4. Store BB_powertx_rate9 value */</a>
<a name="ln2949">                temp_powertx_rate9_reg_val = </a>
<a name="ln2950">                    AR9485_BBPWRTXRATE9_HW_GREEN_TX_SHORT_VALUE;</a>
<a name="ln2951">                break;</a>
<a name="ln2952">            case HAL_RSSI_TX_POWER_MIDDLE:</a>
<a name="ln2953">                /* 1. TxPower Config */</a>
<a name="ln2954">                OS_MEMCPY(target_power_val_t, ar9485_hw_gtx_tp_distance_middle,</a>
<a name="ln2955">                    sizeof(target_power_val_t));</a>
<a name="ln2956">                /* 1.1 Store OLPC Delta Calibration Offset*/</a>
<a name="ln2957">                olpc_power_offset = 0;</a>
<a name="ln2958">                /* 2. Store OB/DB */</a>
<a name="ln2959">                /* 3. Store TPC settting */</a>
<a name="ln2960">                temp_tcp_reg_val = (SM(18, AR_TPC_ACK) |</a>
<a name="ln2961">                                    SM(18, AR_TPC_CTS) |</a>
<a name="ln2962">                                    SM(18, AR_TPC_CHIRP) |</a>
<a name="ln2963">                                    SM(18, AR_TPC_RPT));</a>
<a name="ln2964">                /* 4. Store BB_powertx_rate9 value */</a>
<a name="ln2965">                temp_powertx_rate9_reg_val = </a>
<a name="ln2966">                    AR9485_BBPWRTXRATE9_HW_GREEN_TX_MIDDLE_VALUE;</a>
<a name="ln2967">                break;</a>
<a name="ln2968">            case HAL_RSSI_TX_POWER_LONG:</a>
<a name="ln2969">            default:</a>
<a name="ln2970">                /* 1. TxPower Config */</a>
<a name="ln2971">                OS_MEMCPY(target_power_val_t, ahp-&gt;ah_default_tx_power,</a>
<a name="ln2972">                    sizeof(target_power_val_t));</a>
<a name="ln2973">                /* 1.1 Store OLPC Delta Calibration Offset*/</a>
<a name="ln2974">                olpc_power_offset = 0;</a>
<a name="ln2975">                /* 2. Store OB/DB1/DB2 */</a>
<a name="ln2976">                /* 3. Store TPC settting */</a>
<a name="ln2977">                temp_tcp_reg_val = </a>
<a name="ln2978">                    AH9300(ah)-&gt;ah_ob_db1[POSEIDON_STORED_REG_TPC];</a>
<a name="ln2979">                /* 4. Store BB_powertx_rate9 value */</a>
<a name="ln2980">                temp_powertx_rate9_reg_val = </a>
<a name="ln2981">                  AH9300(ah)-&gt;ah_ob_db1[POSEIDON_STORED_REG_BB_PWRTX_RATE9];</a>
<a name="ln2982">                break;</a>
<a name="ln2983">            }</a>
<a name="ln2984">        } else {</a>
<a name="ln2985">            switch (AH9300(ah)-&gt;green_tx_status) {</a>
<a name="ln2986">            case HAL_RSSI_TX_POWER_SHORT:</a>
<a name="ln2987">                /* 1. TxPower Config */</a>
<a name="ln2988">                OS_MEMCPY(target_power_val_t, wb225_sw_gtx_tp_distance_short,</a>
<a name="ln2989">                    sizeof(target_power_val_t));</a>
<a name="ln2990">                /* 1.1 Store OLPC Delta Calibration Offset*/</a>
<a name="ln2991">                olpc_power_offset = </a>
<a name="ln2992">                    wb225_gtx_olpc_cal_offset[WB225_OB_GREEN_TX_SHORT_VALUE] -</a>
<a name="ln2993">                    wb225_gtx_olpc_cal_offset[WB225_OB_CALIBRATION_VALUE];</a>
<a name="ln2994">                /* 2. Store OB/DB */</a>
<a name="ln2995">                temp_obdb_reg_val =</a>
<a name="ln2996">                    AH9300(ah)-&gt;ah_ob_db1[POSEIDON_STORED_REG_OBDB];</a>
<a name="ln2997">                temp_obdb_reg_val &amp;= ~(AR_PHY_65NM_CH0_TXRF2_DB2G | </a>
<a name="ln2998">                                       AR_PHY_65NM_CH0_TXRF2_OB2G_CCK |</a>
<a name="ln2999">                                       AR_PHY_65NM_CH0_TXRF2_OB2G_PSK |</a>
<a name="ln3000">                                       AR_PHY_65NM_CH0_TXRF2_OB2G_QAM);</a>
<a name="ln3001">                temp_obdb_reg_val |= (SM(5, AR_PHY_65NM_CH0_TXRF2_DB2G) |</a>
<a name="ln3002">                SM(WB225_OB_GREEN_TX_SHORT_VALUE,</a>
<a name="ln3003">                    AR_PHY_65NM_CH0_TXRF2_OB2G_CCK) |</a>
<a name="ln3004">                SM(WB225_OB_GREEN_TX_SHORT_VALUE,</a>
<a name="ln3005">                    AR_PHY_65NM_CH0_TXRF2_OB2G_PSK) |</a>
<a name="ln3006">                SM(WB225_OB_GREEN_TX_SHORT_VALUE,</a>
<a name="ln3007">                    AR_PHY_65NM_CH0_TXRF2_OB2G_QAM));</a>
<a name="ln3008">                /* 3. Store TPC settting */</a>
<a name="ln3009">                temp_tcp_reg_val = (SM(6, AR_TPC_ACK) |</a>
<a name="ln3010">                                    SM(6, AR_TPC_CTS) |</a>
<a name="ln3011">                                    SM(6, AR_TPC_CHIRP) |</a>
<a name="ln3012">                                    SM(6, AR_TPC_RPT));</a>
<a name="ln3013">                /* 4. Store BB_powertx_rate9 value */</a>
<a name="ln3014">                temp_powertx_rate9_reg_val = </a>
<a name="ln3015">                    WB225_BBPWRTXRATE9_SW_GREEN_TX_SHORT_VALUE;</a>
<a name="ln3016">                break;</a>
<a name="ln3017">            case HAL_RSSI_TX_POWER_MIDDLE:</a>
<a name="ln3018">                /* 1. TxPower Config */</a>
<a name="ln3019">                OS_MEMCPY(target_power_val_t, wb225_sw_gtx_tp_distance_middle,</a>
<a name="ln3020">                    sizeof(target_power_val_t));</a>
<a name="ln3021">                /* 1.1 Store OLPC Delta Calibration Offset*/</a>
<a name="ln3022">                olpc_power_offset = </a>
<a name="ln3023">                    wb225_gtx_olpc_cal_offset[WB225_OB_GREEN_TX_MIDDLE_VALUE] -</a>
<a name="ln3024">                    wb225_gtx_olpc_cal_offset[WB225_OB_CALIBRATION_VALUE];</a>
<a name="ln3025">                /* 2. Store OB/DB */</a>
<a name="ln3026">                temp_obdb_reg_val =</a>
<a name="ln3027">                    AH9300(ah)-&gt;ah_ob_db1[POSEIDON_STORED_REG_OBDB];</a>
<a name="ln3028">                temp_obdb_reg_val &amp;= ~(AR_PHY_65NM_CH0_TXRF2_DB2G | </a>
<a name="ln3029">                                       AR_PHY_65NM_CH0_TXRF2_OB2G_CCK |</a>
<a name="ln3030">                                       AR_PHY_65NM_CH0_TXRF2_OB2G_PSK |</a>
<a name="ln3031">                                       AR_PHY_65NM_CH0_TXRF2_OB2G_QAM);</a>
<a name="ln3032">                temp_obdb_reg_val |= (SM(5, AR_PHY_65NM_CH0_TXRF2_DB2G) |</a>
<a name="ln3033">                    SM(WB225_OB_GREEN_TX_MIDDLE_VALUE,</a>
<a name="ln3034">                        AR_PHY_65NM_CH0_TXRF2_OB2G_CCK) |</a>
<a name="ln3035">                    SM(WB225_OB_GREEN_TX_MIDDLE_VALUE,</a>
<a name="ln3036">                        AR_PHY_65NM_CH0_TXRF2_OB2G_PSK) |</a>
<a name="ln3037">                    SM(WB225_OB_GREEN_TX_MIDDLE_VALUE,</a>
<a name="ln3038">                        AR_PHY_65NM_CH0_TXRF2_OB2G_QAM));</a>
<a name="ln3039">                /* 3. Store TPC settting */</a>
<a name="ln3040">                temp_tcp_reg_val = (SM(14, AR_TPC_ACK) |</a>
<a name="ln3041">                                    SM(14, AR_TPC_CTS) |</a>
<a name="ln3042">                                    SM(14, AR_TPC_CHIRP) |</a>
<a name="ln3043">                                    SM(14, AR_TPC_RPT));</a>
<a name="ln3044">                /* 4. Store BB_powertx_rate9 value */</a>
<a name="ln3045">                temp_powertx_rate9_reg_val = </a>
<a name="ln3046">                    WB225_BBPWRTXRATE9_SW_GREEN_TX_MIDDLE_VALUE;</a>
<a name="ln3047">                break;</a>
<a name="ln3048">            case HAL_RSSI_TX_POWER_LONG:</a>
<a name="ln3049">            default:</a>
<a name="ln3050">                /* 1. TxPower Config */</a>
<a name="ln3051">                OS_MEMCPY(target_power_val_t, ahp-&gt;ah_default_tx_power,</a>
<a name="ln3052">                    sizeof(target_power_val_t));</a>
<a name="ln3053">                /* 1.1 Store OLPC Delta Calibration Offset*/</a>
<a name="ln3054">                olpc_power_offset = </a>
<a name="ln3055">                    wb225_gtx_olpc_cal_offset[WB225_OB_GREEN_TX_LONG_VALUE] -</a>
<a name="ln3056">                    wb225_gtx_olpc_cal_offset[WB225_OB_CALIBRATION_VALUE];</a>
<a name="ln3057">                /* 2. Store OB/DB1/DB2 */</a>
<a name="ln3058">                temp_obdb_reg_val =</a>
<a name="ln3059">                    AH9300(ah)-&gt;ah_ob_db1[POSEIDON_STORED_REG_OBDB];</a>
<a name="ln3060">                /* 3. Store TPC settting */</a>
<a name="ln3061">                temp_tcp_reg_val =</a>
<a name="ln3062">                    AH9300(ah)-&gt;ah_ob_db1[POSEIDON_STORED_REG_TPC];</a>
<a name="ln3063">                /* 4. Store BB_powertx_rate9 value */</a>
<a name="ln3064">                temp_powertx_rate9_reg_val = </a>
<a name="ln3065">                  AH9300(ah)-&gt;ah_ob_db1[POSEIDON_STORED_REG_BB_PWRTX_RATE9];</a>
<a name="ln3066">                break;</a>
<a name="ln3067">            }</a>
<a name="ln3068">        }</a>
<a name="ln3069">        /* 1.1 Do OLPC Delta Calibration Offset */</a>
<a name="ln3070">        tmp_olpc_val = </a>
<a name="ln3071">            (int8_t) AH9300(ah)-&gt;ah_db2[POSEIDON_STORED_REG_G2_OLPC_OFFSET];</a>
<a name="ln3072">        tmp_olpc_val += olpc_power_offset;</a>
<a name="ln3073">        OS_REG_RMW(ah, AR_PHY_TPC_11_B0, </a>
<a name="ln3074">            (tmp_olpc_val &lt;&lt; AR_PHY_TPC_OLPC_GAIN_DELTA_S), </a>
<a name="ln3075">            AR_PHY_TPC_OLPC_GAIN_DELTA);</a>
<a name="ln3076"> </a>
<a name="ln3077">        /* 1.2 TxPower Config */</a>
<a name="ln3078">        ar9300_transmit_power_reg_write(ah, target_power_val_t);     </a>
<a name="ln3079">        /* 2. Config OB/DB */</a>
<a name="ln3080">        if (!ahp-&gt;ah_hw_green_tx_enable) {</a>
<a name="ln3081">            OS_REG_WRITE(ah, AR_PHY_65NM_CH0_TXRF2, temp_obdb_reg_val);</a>
<a name="ln3082">        }</a>
<a name="ln3083">        /* 3. config TPC settting */</a>
<a name="ln3084">        OS_REG_WRITE(ah, AR_TPC, temp_tcp_reg_val);</a>
<a name="ln3085">        /* 4. config BB_powertx_rate9 value */</a>
<a name="ln3086">        OS_REG_WRITE(ah, AR_PHY_BB_POWERTX_RATE9, temp_powertx_rate9_reg_val);</a>
<a name="ln3087">    }</a>
<a name="ln3088">}</a>
<a name="ln3089"> </a>
<a name="ln3090">#if 0</a>
<a name="ln3091">void</a>
<a name="ln3092">ar9300_get_vow_stats(</a>
<a name="ln3093">    struct ath_hal *ah, HAL_VOWSTATS* p_stats, u_int8_t vow_reg_flags)</a>
<a name="ln3094">{</a>
<a name="ln3095">    if (vow_reg_flags &amp; AR_REG_TX_FRM_CNT) {</a>
<a name="ln3096">        p_stats-&gt;tx_frame_count = OS_REG_READ(ah, AR_TFCNT);</a>
<a name="ln3097">    }</a>
<a name="ln3098">    if (vow_reg_flags &amp; AR_REG_RX_FRM_CNT) {</a>
<a name="ln3099">        p_stats-&gt;rx_frame_count = OS_REG_READ(ah, AR_RFCNT);</a>
<a name="ln3100">    }</a>
<a name="ln3101">    if (vow_reg_flags &amp; AR_REG_RX_CLR_CNT) {</a>
<a name="ln3102">        p_stats-&gt;rx_clear_count = OS_REG_READ(ah, AR_RCCNT);</a>
<a name="ln3103">    }</a>
<a name="ln3104">    if (vow_reg_flags &amp; AR_REG_CYCLE_CNT) {</a>
<a name="ln3105">        p_stats-&gt;cycle_count   = OS_REG_READ(ah, AR_CCCNT);</a>
<a name="ln3106">    }</a>
<a name="ln3107">    if (vow_reg_flags &amp; AR_REG_EXT_CYCLE_CNT) {</a>
<a name="ln3108">        p_stats-&gt;ext_cycle_count   = OS_REG_READ(ah, AR_EXTRCCNT);</a>
<a name="ln3109">    }</a>
<a name="ln3110">}</a>
<a name="ln3111">#endif</a>
<a name="ln3112"> </a>
<a name="ln3113">/*</a>
<a name="ln3114"> * ar9300_is_skip_paprd_by_greentx</a>
<a name="ln3115"> *</a>
<a name="ln3116"> * This function check if we need to skip PAPRD tuning </a>
<a name="ln3117"> * when GreenTx in specific state.</a>
<a name="ln3118"> */</a>
<a name="ln3119">HAL_BOOL</a>
<a name="ln3120">ar9300_is_skip_paprd_by_greentx(struct ath_hal *ah)</a>
<a name="ln3121">{</a>
<a name="ln3122">    if (AR_SREV_POSEIDON(ah) &amp;&amp; </a>
<a name="ln3123">        ah-&gt;ah_config.ath_hal_sta_update_tx_pwr_enable &amp;&amp;</a>
<a name="ln3124">        ((AH9300(ah)-&gt;green_tx_status == HAL_RSSI_TX_POWER_SHORT) || </a>
<a name="ln3125">         (AH9300(ah)-&gt;green_tx_status == HAL_RSSI_TX_POWER_MIDDLE))) </a>
<a name="ln3126">    {</a>
<a name="ln3127">        return AH_TRUE;</a>
<a name="ln3128">    }</a>
<a name="ln3129">    return AH_FALSE;</a>
<a name="ln3130">}</a>
<a name="ln3131"> </a>
<a name="ln3132">void</a>
<a name="ln3133">ar9300_control_signals_for_green_tx_mode(struct ath_hal *ah)</a>
<a name="ln3134">{</a>
<a name="ln3135">    unsigned int valid_obdb_0_b0 = 0x2d; // 5,5 - dB[0:2],oB[5:3]  </a>
<a name="ln3136">    unsigned int valid_obdb_1_b0 = 0x25; // 4,5 - dB[0:2],oB[5:3]  </a>
<a name="ln3137">    unsigned int valid_obdb_2_b0 = 0x1d; // 3,5 - dB[0:2],oB[5:3] </a>
<a name="ln3138">    unsigned int valid_obdb_3_b0 = 0x15; // 2,5 - dB[0:2],oB[5:3] </a>
<a name="ln3139">    unsigned int valid_obdb_4_b0 = 0xd;  // 1,5 - dB[0:2],oB[5:3]</a>
<a name="ln3140">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln3141"> </a>
<a name="ln3142">    if (AR_SREV_POSEIDON(ah) &amp;&amp; ahp-&gt;ah_hw_green_tx_enable) {</a>
<a name="ln3143">        OS_REG_RMW_FIELD_ALT(ah, AR_PHY_PAPRD_VALID_OBDB_POSEIDON, </a>
<a name="ln3144">                             AR_PHY_PAPRD_VALID_OBDB_0, valid_obdb_0_b0);</a>
<a name="ln3145">        OS_REG_RMW_FIELD_ALT(ah, AR_PHY_PAPRD_VALID_OBDB_POSEIDON, </a>
<a name="ln3146">                             AR_PHY_PAPRD_VALID_OBDB_1, valid_obdb_1_b0);</a>
<a name="ln3147">        OS_REG_RMW_FIELD_ALT(ah, AR_PHY_PAPRD_VALID_OBDB_POSEIDON, </a>
<a name="ln3148">                             AR_PHY_PAPRD_VALID_OBDB_2, valid_obdb_2_b0);</a>
<a name="ln3149">        OS_REG_RMW_FIELD_ALT(ah, AR_PHY_PAPRD_VALID_OBDB_POSEIDON, </a>
<a name="ln3150">                             AR_PHY_PAPRD_VALID_OBDB_3, valid_obdb_3_b0);</a>
<a name="ln3151">        OS_REG_RMW_FIELD_ALT(ah, AR_PHY_PAPRD_VALID_OBDB_POSEIDON, </a>
<a name="ln3152">                             AR_PHY_PAPRD_VALID_OBDB_4, valid_obdb_4_b0);</a>
<a name="ln3153">    }</a>
<a name="ln3154">}</a>
<a name="ln3155"> </a>
<a name="ln3156">void ar9300_hwgreentx_set_pal_spare(struct ath_hal *ah, int value)</a>
<a name="ln3157">{</a>
<a name="ln3158">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln3159"> </a>
<a name="ln3160">    if (AR_SREV_POSEIDON(ah) &amp;&amp; ahp-&gt;ah_hw_green_tx_enable) {</a>
<a name="ln3161">        if ((value == 0) || (value == 1)) {</a>
<a name="ln3162">            OS_REG_RMW_FIELD(ah, AR_PHY_65NM_CH0_TXRF3, </a>
<a name="ln3163">                             AR_PHY_65NM_CH0_TXRF3_OLD_PAL_SPARE, value);</a>
<a name="ln3164">        }</a>
<a name="ln3165">    }</a>
<a name="ln3166">}</a>
<a name="ln3167"> </a>
<a name="ln3168">void ar9300_reset_hw_beacon_proc_crc(struct ath_hal *ah)</a>
<a name="ln3169">{</a>
<a name="ln3170">    OS_REG_SET_BIT(ah, AR_HWBCNPROC1, AR_HWBCNPROC1_RESET_CRC);</a>
<a name="ln3171">}</a>
<a name="ln3172"> </a>
<a name="ln3173">int32_t ar9300_get_hw_beacon_rssi(struct ath_hal *ah)</a>
<a name="ln3174">{</a>
<a name="ln3175">    int32_t val = OS_REG_READ_FIELD(ah, AR_BCN_RSSI_AVE, AR_BCN_RSSI_AVE_VAL);</a>
<a name="ln3176"> </a>
<a name="ln3177">    /* RSSI format is 8.4.  Ignore lowest four bits */</a>
<a name="ln3178">    val = val &gt;&gt; 4;</a>
<a name="ln3179">    return val;</a>
<a name="ln3180">}</a>
<a name="ln3181"> </a>
<a name="ln3182">void ar9300_set_hw_beacon_rssi_threshold(struct ath_hal *ah,</a>
<a name="ln3183">                                        u_int32_t rssi_threshold)</a>
<a name="ln3184">{</a>
<a name="ln3185">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln3186"> </a>
<a name="ln3187">    OS_REG_RMW_FIELD(ah, AR_RSSI_THR, AR_RSSI_THR_VAL, rssi_threshold);</a>
<a name="ln3188"> </a>
<a name="ln3189">    /* save value for restoring after chip reset */</a>
<a name="ln3190">    ahp-&gt;ah_beacon_rssi_threshold = rssi_threshold;</a>
<a name="ln3191">}</a>
<a name="ln3192"> </a>
<a name="ln3193">void ar9300_reset_hw_beacon_rssi(struct ath_hal *ah)</a>
<a name="ln3194">{</a>
<a name="ln3195">    OS_REG_SET_BIT(ah, AR_RSSI_THR, AR_RSSI_BCN_RSSI_RST);</a>
<a name="ln3196">}</a>
<a name="ln3197"> </a>
<a name="ln3198">void ar9300_set_hw_beacon_proc(struct ath_hal *ah, HAL_BOOL on)</a>
<a name="ln3199">{</a>
<a name="ln3200">    if (on) {</a>
<a name="ln3201">        OS_REG_SET_BIT(ah, AR_HWBCNPROC1, AR_HWBCNPROC1_CRC_ENABLE |</a>
<a name="ln3202">                       AR_HWBCNPROC1_EXCLUDE_TIM_ELM);</a>
<a name="ln3203">    }</a>
<a name="ln3204">    else {</a>
<a name="ln3205">        OS_REG_CLR_BIT(ah, AR_HWBCNPROC1, AR_HWBCNPROC1_CRC_ENABLE |</a>
<a name="ln3206">                       AR_HWBCNPROC1_EXCLUDE_TIM_ELM);</a>
<a name="ln3207">    }</a>
<a name="ln3208">}</a>
<a name="ln3209">/*</a>
<a name="ln3210"> * Gets the contents of the specified key cache entry.</a>
<a name="ln3211"> */</a>
<a name="ln3212">HAL_BOOL</a>
<a name="ln3213">ar9300_print_keycache(struct ath_hal *ah)</a>
<a name="ln3214">{</a>
<a name="ln3215"> </a>
<a name="ln3216">    const HAL_CAPABILITIES *p_cap = &amp;AH_PRIVATE(ah)-&gt;ah_caps;</a>
<a name="ln3217">    u_int32_t key0, key1, key2, key3, key4;</a>
<a name="ln3218">    u_int32_t mac_hi, mac_lo;</a>
<a name="ln3219">    u_int16_t entry = 0;</a>
<a name="ln3220">    u_int32_t valid = 0;</a>
<a name="ln3221">    u_int32_t key_type;</a>
<a name="ln3222"> </a>
<a name="ln3223">    ath_hal_printf(ah, &quot;Slot   Key\t\t\t          Valid  Type  Mac  \n&quot;);</a>
<a name="ln3224"> </a>
<a name="ln3225">    for (entry = 0 ; entry &lt; p_cap-&gt;halKeyCacheSize; entry++) {</a>
<a name="ln3226">        key0 = OS_REG_READ(ah, AR_KEYTABLE_KEY0(entry));</a>
<a name="ln3227">        key1 = OS_REG_READ(ah, AR_KEYTABLE_KEY1(entry));</a>
<a name="ln3228">        key2 = OS_REG_READ(ah, AR_KEYTABLE_KEY2(entry));</a>
<a name="ln3229">        key3 = OS_REG_READ(ah, AR_KEYTABLE_KEY3(entry));</a>
<a name="ln3230">        key4 = OS_REG_READ(ah, AR_KEYTABLE_KEY4(entry));</a>
<a name="ln3231"> </a>
<a name="ln3232">        key_type = OS_REG_READ(ah, AR_KEYTABLE_TYPE(entry));</a>
<a name="ln3233"> </a>
<a name="ln3234">        mac_lo = OS_REG_READ(ah, AR_KEYTABLE_MAC0(entry));</a>
<a name="ln3235">        mac_hi = OS_REG_READ(ah, AR_KEYTABLE_MAC1(entry));</a>
<a name="ln3236"> </a>
<a name="ln3237">        if (mac_hi &amp; AR_KEYTABLE_VALID) {</a>
<a name="ln3238">            valid = 1;</a>
<a name="ln3239">        } else {</a>
<a name="ln3240">            valid = 0;</a>
<a name="ln3241">        }</a>
<a name="ln3242"> </a>
<a name="ln3243">        if ((mac_hi != 0) &amp;&amp; (mac_lo != 0)) {</a>
<a name="ln3244">            mac_hi &amp;= ~0x8000;</a>
<a name="ln3245">            mac_hi &lt;&lt;= 1;</a>
<a name="ln3246">            mac_hi |= ((mac_lo &amp; (1 &lt;&lt; 31) )) &gt;&gt; 31;</a>
<a name="ln3247">            mac_lo &lt;&lt;= 1;</a>
<a name="ln3248">        }</a>
<a name="ln3249"> </a>
<a name="ln3250">        ath_hal_printf(ah,</a>
<a name="ln3251">            &quot;%03d    &quot;</a>
<a name="ln3252">            &quot;%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x&quot;</a>
<a name="ln3253">            &quot;   %02d     %02d    &quot;</a>
<a name="ln3254">            &quot;%02x:%02x:%02x:%02x:%02x:%02x \n&quot;,</a>
<a name="ln3255">            entry,</a>
<a name="ln3256">            (key0 &lt;&lt; 24) &gt;&gt; 24, (key0 &lt;&lt; 16) &gt;&gt; 24,</a>
<a name="ln3257">            (key0 &lt;&lt; 8) &gt;&gt; 24, key0 &gt;&gt; 24,</a>
<a name="ln3258">            (key1 &lt;&lt; 24) &gt;&gt; 24, (key1 &lt;&lt; 16) &gt;&gt; 24,</a>
<a name="ln3259">            //(key1 &lt;&lt; 8) &gt;&gt; 24, key1 &gt;&gt; 24,</a>
<a name="ln3260">            (key2 &lt;&lt; 24) &gt;&gt; 24, (key2 &lt;&lt; 16) &gt;&gt; 24,</a>
<a name="ln3261">            (key2 &lt;&lt; 8) &gt;&gt; 24, key2 &gt;&gt; 24,</a>
<a name="ln3262">            (key3 &lt;&lt; 24) &gt;&gt; 24, (key3 &lt;&lt; 16) &gt;&gt; 24,</a>
<a name="ln3263">            //(key3 &lt;&lt; 8) &gt;&gt; 24, key3 &gt;&gt; 24,</a>
<a name="ln3264">            (key4 &lt;&lt; 24) &gt;&gt; 24, (key4 &lt;&lt; 16) &gt;&gt; 24,</a>
<a name="ln3265">            (key4 &lt;&lt; 8) &gt;&gt; 24, key4 &gt;&gt; 24,</a>
<a name="ln3266">            valid, key_type,</a>
<a name="ln3267">            (mac_lo &lt;&lt; 24) &gt;&gt; 24, (mac_lo &lt;&lt; 16) &gt;&gt; 24, (mac_lo &lt;&lt; 8) &gt;&gt; 24,</a>
<a name="ln3268">            (mac_lo) &gt;&gt; 24, (mac_hi &lt;&lt; 24) &gt;&gt; 24, (mac_hi &lt;&lt; 16) &gt;&gt; 24 );</a>
<a name="ln3269">    }</a>
<a name="ln3270"> </a>
<a name="ln3271">    return AH_TRUE;</a>
<a name="ln3272">}</a>
<a name="ln3273"> </a>
<a name="ln3274">/* enable/disable smart antenna mode */</a>
<a name="ln3275">HAL_BOOL</a>
<a name="ln3276">ar9300_set_smart_antenna(struct ath_hal *ah, HAL_BOOL enable)</a>
<a name="ln3277">{</a>
<a name="ln3278">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln3279"> </a>
<a name="ln3280">    if (enable) {</a>
<a name="ln3281">        OS_REG_SET_BIT(ah, AR_XRTO, AR_ENABLE_SMARTANTENNA);</a>
<a name="ln3282">    } else {</a>
<a name="ln3283">        OS_REG_CLR_BIT(ah, AR_XRTO, AR_ENABLE_SMARTANTENNA);</a>
<a name="ln3284">    }</a>
<a name="ln3285"> </a>
<a name="ln3286">    /* if scropion and smart antenna is enabled, write swcom1 with 0x440</a>
<a name="ln3287">     * and swcom2 with 0</a>
<a name="ln3288">     * FIXME Ideally these registers need to be made read from caldata.</a>
<a name="ln3289">     * Until the calibration team gets them, keep them along with board</a>
<a name="ln3290">     * configuration.</a>
<a name="ln3291">     */</a>
<a name="ln3292">    if (enable &amp;&amp; AR_SREV_SCORPION(ah) &amp;&amp;</a>
<a name="ln3293">           (HAL_OK == ar9300_get_capability(ah, HAL_CAP_SMARTANTENNA, 0,0))) {</a>
<a name="ln3294"> </a>
<a name="ln3295">       OS_REG_WRITE(ah, AR_PHY_SWITCH_COM, 0x440);</a>
<a name="ln3296">       OS_REG_WRITE(ah, AR_PHY_SWITCH_COM_2, 0);</a>
<a name="ln3297">    }</a>
<a name="ln3298"> </a>
<a name="ln3299">    ahp-&gt;ah_smartantenna_enable = enable;</a>
<a name="ln3300">    return 1;</a>
<a name="ln3301">}</a>
<a name="ln3302"> </a>
<a name="ln3303">#ifdef ATH_TX99_DIAG</a>
<a name="ln3304">#ifndef ATH_SUPPORT_HTC</a>
<a name="ln3305">void</a>
<a name="ln3306">ar9300_tx99_channel_pwr_update(struct ath_hal *ah, HAL_CHANNEL *c, </a>
<a name="ln3307">    u_int32_t txpower)</a>
<a name="ln3308">{</a>
<a name="ln3309">#define PWR_MAS(_r, _s)     (((_r) &amp; 0x3f) &lt;&lt; (_s))</a>
<a name="ln3310">    static int16_t p_pwr_array[ar9300_rate_size] = { 0 };</a>
<a name="ln3311">    int32_t i;</a>
<a name="ln3312">     </a>
<a name="ln3313">    /* The max power is limited to 63 */</a>
<a name="ln3314">    if (txpower &lt;= AR9300_MAX_RATE_POWER) {</a>
<a name="ln3315">        for (i = 0; i &lt; ar9300_rate_size; i++) {</a>
<a name="ln3316">            p_pwr_array[i] = txpower;</a>
<a name="ln3317">        }</a>
<a name="ln3318">    } else {</a>
<a name="ln3319">        for (i = 0; i &lt; ar9300_rate_size; i++) {</a>
<a name="ln3320">            p_pwr_array[i] = AR9300_MAX_RATE_POWER;</a>
<a name="ln3321">        }</a>
<a name="ln3322">    }</a>
<a name="ln3323"> </a>
<a name="ln3324">    OS_REG_WRITE(ah, 0xa458, 0);</a>
<a name="ln3325"> </a>
<a name="ln3326">    /* Write the OFDM power per rate set */</a>
<a name="ln3327">    /* 6 (LSB), 9, 12, 18 (MSB) */</a>
<a name="ln3328">    OS_REG_WRITE(ah, 0xa3c0,</a>
<a name="ln3329">        PWR_MAS(p_pwr_array[ALL_TARGET_LEGACY_6_24], 24)</a>
<a name="ln3330">          | PWR_MAS(p_pwr_array[ALL_TARGET_LEGACY_6_24], 16)</a>
<a name="ln3331">          | PWR_MAS(p_pwr_array[ALL_TARGET_LEGACY_6_24],  8)</a>
<a name="ln3332">          | PWR_MAS(p_pwr_array[ALL_TARGET_LEGACY_6_24],  0)</a>
<a name="ln3333">    );</a>
<a name="ln3334">    /* 24 (LSB), 36, 48, 54 (MSB) */</a>
<a name="ln3335">    OS_REG_WRITE(ah, 0xa3c4,</a>
<a name="ln3336">        PWR_MAS(p_pwr_array[ALL_TARGET_LEGACY_54], 24)</a>
<a name="ln3337">          | PWR_MAS(p_pwr_array[ALL_TARGET_LEGACY_48], 16)</a>
<a name="ln3338">          | PWR_MAS(p_pwr_array[ALL_TARGET_LEGACY_36],  8)</a>
<a name="ln3339">          | PWR_MAS(p_pwr_array[ALL_TARGET_LEGACY_6_24],  0)</a>
<a name="ln3340">    );</a>
<a name="ln3341"> </a>
<a name="ln3342">    /* Write the CCK power per rate set */</a>
<a name="ln3343">    /* 1L (LSB), reserved, 2L, 2S (MSB) */  </a>
<a name="ln3344">    OS_REG_WRITE(ah, 0xa3c8,</a>
<a name="ln3345">        PWR_MAS(p_pwr_array[ALL_TARGET_LEGACY_1L_5L], 24)</a>
<a name="ln3346">          | PWR_MAS(p_pwr_array[ALL_TARGET_LEGACY_1L_5L],  16)</a>
<a name="ln3347">          /* | PWR_MAS(txPowerTimes2,  8) */ /* this is reserved for Osprey */</a>
<a name="ln3348">          | PWR_MAS(p_pwr_array[ALL_TARGET_LEGACY_1L_5L],   0)</a>
<a name="ln3349">    );</a>
<a name="ln3350">    /* 5.5L (LSB), 5.5S, 11L, 11S (MSB) */</a>
<a name="ln3351">    OS_REG_WRITE(ah, 0xa3cc,</a>
<a name="ln3352">        PWR_MAS(p_pwr_array[ALL_TARGET_LEGACY_11S], 24)</a>
<a name="ln3353">          | PWR_MAS(p_pwr_array[ALL_TARGET_LEGACY_11L], 16)</a>
<a name="ln3354">          | PWR_MAS(p_pwr_array[ALL_TARGET_LEGACY_5S],  8)</a>
<a name="ln3355">          | PWR_MAS(p_pwr_array[ALL_TARGET_LEGACY_1L_5L],  0)</a>
<a name="ln3356">    );</a>
<a name="ln3357"> </a>
<a name="ln3358">    /* Write the HT20 power per rate set */</a>
<a name="ln3359">    /* 0/8/16 (LSB), 1-3/9-11/17-19, 4, 5 (MSB) */</a>
<a name="ln3360">    OS_REG_WRITE(ah, 0xa3d0,</a>
<a name="ln3361">        PWR_MAS(p_pwr_array[ALL_TARGET_HT20_5], 24)</a>
<a name="ln3362">          | PWR_MAS(p_pwr_array[ALL_TARGET_HT20_4],  16)</a>
<a name="ln3363">          | PWR_MAS(p_pwr_array[ALL_TARGET_HT20_1_3_9_11_17_19],  8)</a>
<a name="ln3364">          | PWR_MAS(p_pwr_array[ALL_TARGET_HT20_0_8_16],   0)</a>
<a name="ln3365">    );</a>
<a name="ln3366">    </a>
<a name="ln3367">    /* 6 (LSB), 7, 12, 13 (MSB) */</a>
<a name="ln3368">    OS_REG_WRITE(ah, 0xa3d4,</a>
<a name="ln3369">        PWR_MAS(p_pwr_array[ALL_TARGET_HT20_13], 24)</a>
<a name="ln3370">          | PWR_MAS(p_pwr_array[ALL_TARGET_HT20_12],  16)</a>
<a name="ln3371">          | PWR_MAS(p_pwr_array[ALL_TARGET_HT20_7],  8)</a>
<a name="ln3372">          | PWR_MAS(p_pwr_array[ALL_TARGET_HT20_6],   0)</a>
<a name="ln3373">    );</a>
<a name="ln3374"> </a>
<a name="ln3375">    /* 14 (LSB), 15, 20, 21 */</a>
<a name="ln3376">    OS_REG_WRITE(ah, 0xa3e4,</a>
<a name="ln3377">        PWR_MAS(p_pwr_array[ALL_TARGET_HT20_21], 24)</a>
<a name="ln3378">          | PWR_MAS(p_pwr_array[ALL_TARGET_HT20_20],  16)</a>
<a name="ln3379">          | PWR_MAS(p_pwr_array[ALL_TARGET_HT20_15],  8)</a>
<a name="ln3380">          | PWR_MAS(p_pwr_array[ALL_TARGET_HT20_14],   0)</a>
<a name="ln3381">    );</a>
<a name="ln3382"> </a>
<a name="ln3383">    /* Mixed HT20 and HT40 rates */</a>
<a name="ln3384">    /* HT20 22 (LSB), HT20 23, HT40 22, HT40 23 (MSB) */</a>
<a name="ln3385">    OS_REG_WRITE(ah, 0xa3e8,</a>
<a name="ln3386">        PWR_MAS(p_pwr_array[ALL_TARGET_HT40_23], 24)</a>
<a name="ln3387">          | PWR_MAS(p_pwr_array[ALL_TARGET_HT40_22],  16)</a>
<a name="ln3388">          | PWR_MAS(p_pwr_array[ALL_TARGET_HT20_23],  8)</a>
<a name="ln3389">          | PWR_MAS(p_pwr_array[ALL_TARGET_HT20_22],   0)</a>
<a name="ln3390">    );</a>
<a name="ln3391">    </a>
<a name="ln3392">    /* Write the HT40 power per rate set */</a>
<a name="ln3393">    /* correct PAR difference between HT40 and HT20/LEGACY */</a>
<a name="ln3394">    /* 0/8/16 (LSB), 1-3/9-11/17-19, 4, 5 (MSB) */</a>
<a name="ln3395">    OS_REG_WRITE(ah, 0xa3d8,</a>
<a name="ln3396">        PWR_MAS(p_pwr_array[ALL_TARGET_HT40_5], 24)</a>
<a name="ln3397">          | PWR_MAS(p_pwr_array[ALL_TARGET_HT40_4],  16)</a>
<a name="ln3398">          | PWR_MAS(p_pwr_array[ALL_TARGET_HT40_1_3_9_11_17_19],  8)</a>
<a name="ln3399">          | PWR_MAS(p_pwr_array[ALL_TARGET_HT40_0_8_16],   0)</a>
<a name="ln3400">    );</a>
<a name="ln3401"> </a>
<a name="ln3402">    /* 6 (LSB), 7, 12, 13 (MSB) */</a>
<a name="ln3403">    OS_REG_WRITE(ah, 0xa3dc,</a>
<a name="ln3404">        PWR_MAS(p_pwr_array[ALL_TARGET_HT40_13], 24)</a>
<a name="ln3405">          | PWR_MAS(p_pwr_array[ALL_TARGET_HT40_12],  16)</a>
<a name="ln3406">          | PWR_MAS(p_pwr_array[ALL_TARGET_HT40_7], 8)</a>
<a name="ln3407">          | PWR_MAS(p_pwr_array[ALL_TARGET_HT40_6], 0)</a>
<a name="ln3408">    );</a>
<a name="ln3409"> </a>
<a name="ln3410">    /* 14 (LSB), 15, 20, 21 */</a>
<a name="ln3411">    OS_REG_WRITE(ah, 0xa3ec,</a>
<a name="ln3412">        PWR_MAS(p_pwr_array[ALL_TARGET_HT40_21], 24)</a>
<a name="ln3413">          | PWR_MAS(p_pwr_array[ALL_TARGET_HT40_20],  16)</a>
<a name="ln3414">          | PWR_MAS(p_pwr_array[ALL_TARGET_HT40_15],  8)</a>
<a name="ln3415">          | PWR_MAS(p_pwr_array[ALL_TARGET_HT40_14],   0)</a>
<a name="ln3416">    );  </a>
<a name="ln3417">#undef PWR_MAS</a>
<a name="ln3418">}</a>
<a name="ln3419"> </a>
<a name="ln3420">void</a>
<a name="ln3421">ar9300_tx99_chainmsk_setup(struct ath_hal *ah, int tx_chainmask)</a>
<a name="ln3422">{</a>
<a name="ln3423">    if (tx_chainmask == 0x5) {</a>
<a name="ln3424">        OS_REG_WRITE(ah, AR_PHY_ANALOG_SWAP, </a>
<a name="ln3425">            OS_REG_READ(ah, AR_PHY_ANALOG_SWAP) | AR_PHY_SWAP_ALT_CHAIN);</a>
<a name="ln3426">    }</a>
<a name="ln3427">    OS_REG_WRITE(ah, AR_PHY_RX_CHAINMASK, tx_chainmask);</a>
<a name="ln3428">    OS_REG_WRITE(ah, AR_PHY_CAL_CHAINMASK, tx_chainmask);</a>
<a name="ln3429"> </a>
<a name="ln3430">    OS_REG_WRITE(ah, AR_SELFGEN_MASK, tx_chainmask);</a>
<a name="ln3431">    if (tx_chainmask == 0x5) {</a>
<a name="ln3432">        OS_REG_WRITE(ah, AR_PHY_ANALOG_SWAP, </a>
<a name="ln3433">            OS_REG_READ(ah, AR_PHY_ANALOG_SWAP) | AR_PHY_SWAP_ALT_CHAIN);</a>
<a name="ln3434">    }</a>
<a name="ln3435">}</a>
<a name="ln3436"> </a>
<a name="ln3437">void</a>
<a name="ln3438">ar9300_tx99_set_single_carrier(struct ath_hal *ah, int tx_chain_mask, </a>
<a name="ln3439">    int chtype)</a>
<a name="ln3440">{</a>
<a name="ln3441">    OS_REG_WRITE(ah, 0x98a4, OS_REG_READ(ah, 0x98a4) | (0x7ff &lt;&lt; 11) | 0x7ff);</a>
<a name="ln3442">    OS_REG_WRITE(ah, 0xa364, OS_REG_READ(ah, 0xa364) | (1 &lt;&lt; 7) | (1 &lt;&lt; 1));</a>
<a name="ln3443">    OS_REG_WRITE(ah, 0xa350, </a>
<a name="ln3444">        (OS_REG_READ(ah, 0xa350) | (1 &lt;&lt; 31) | (1 &lt;&lt; 15)) &amp; ~(1 &lt;&lt; 13));</a>
<a name="ln3445">    </a>
<a name="ln3446">    /* 11G mode */</a>
<a name="ln3447">    if (!chtype) {</a>
<a name="ln3448">        OS_REG_WRITE(ah, AR_PHY_65NM_CH0_RXTX2, </a>
<a name="ln3449">            OS_REG_READ(ah, AR_PHY_65NM_CH0_RXTX2) | (0x1 &lt;&lt; 3) | (0x1 &lt;&lt; 2));</a>
<a name="ln3450">        if (AR_SREV_OSPREY(ah) || AR_SREV_WASP(ah)) {</a>
<a name="ln3451">            OS_REG_WRITE(ah, AR_PHY_65NM_CH0_TOP, </a>
<a name="ln3452">                OS_REG_READ(ah, AR_PHY_65NM_CH0_TOP) &amp; ~(0x1 &lt;&lt; 4)); </a>
<a name="ln3453">            OS_REG_WRITE(ah, AR_PHY_65NM_CH0_TOP2, </a>
<a name="ln3454">                (OS_REG_READ(ah, AR_PHY_65NM_CH0_TOP2)</a>
<a name="ln3455">                        | (0x1 &lt;&lt; 26)  | (0x7 &lt;&lt; 24)) </a>
<a name="ln3456">                        &amp; ~(0x1 &lt;&lt; 22));</a>
<a name="ln3457">        } else {</a>
<a name="ln3458">            OS_REG_WRITE(ah, AR_HORNET_CH0_TOP, </a>
<a name="ln3459">                OS_REG_READ(ah, AR_HORNET_CH0_TOP) &amp; ~(0x1 &lt;&lt; 4)); </a>
<a name="ln3460">            OS_REG_WRITE(ah, AR_HORNET_CH0_TOP2, </a>
<a name="ln3461">                (OS_REG_READ(ah, AR_HORNET_CH0_TOP2)</a>
<a name="ln3462">                        | (0x1 &lt;&lt; 26)  | (0x7 &lt;&lt; 24)) </a>
<a name="ln3463">                        &amp; ~(0x1 &lt;&lt; 22));</a>
<a name="ln3464">        }                                                    </a>
<a name="ln3465">        </a>
<a name="ln3466">        /* chain zero */</a>
<a name="ln3467">        if ((tx_chain_mask &amp; 0x01) == 0x01) {</a>
<a name="ln3468">            OS_REG_WRITE(ah, AR_PHY_65NM_CH0_RXTX1, </a>
<a name="ln3469">                (OS_REG_READ(ah, AR_PHY_65NM_CH0_RXTX1)</a>
<a name="ln3470">                      | (0x1 &lt;&lt; 31) | (0x5 &lt;&lt; 15) </a>
<a name="ln3471">                      | (0x3 &lt;&lt; 9)) &amp; ~(0x1 &lt;&lt; 27) </a>
<a name="ln3472">                      &amp; ~(0x1 &lt;&lt; 12));</a>
<a name="ln3473">            OS_REG_WRITE(ah, AR_PHY_65NM_CH0_RXTX2, </a>
<a name="ln3474">                (OS_REG_READ(ah, AR_PHY_65NM_CH0_RXTX2)</a>
<a name="ln3475">                      | (0x1 &lt;&lt; 12) | (0x1 &lt;&lt; 10) </a>
<a name="ln3476">                      | (0x1 &lt;&lt; 9)  | (0x1 &lt;&lt; 8)  </a>
<a name="ln3477">                      | (0x1 &lt;&lt; 7)) &amp; ~(0x1 &lt;&lt; 11));</a>
<a name="ln3478">            OS_REG_WRITE(ah, AR_PHY_65NM_CH0_RXTX3, </a>
<a name="ln3479">                (OS_REG_READ(ah, AR_PHY_65NM_CH0_RXTX3)</a>
<a name="ln3480">                      | (0x1 &lt;&lt; 29) | (0x1 &lt;&lt; 25) </a>
<a name="ln3481">                      | (0x1 &lt;&lt; 23) | (0x1 &lt;&lt; 19) </a>
<a name="ln3482">                      | (0x1 &lt;&lt; 10) | (0x1 &lt;&lt; 9)  </a>
<a name="ln3483">                      | (0x1 &lt;&lt; 8)  | (0x1 &lt;&lt; 3))</a>
<a name="ln3484">                      &amp; ~(0x1 &lt;&lt; 28)&amp; ~(0x1 &lt;&lt; 24)</a>
<a name="ln3485">                      &amp; ~(0x1 &lt;&lt; 22)&amp; ~(0x1 &lt;&lt; 7));</a>
<a name="ln3486">            OS_REG_WRITE(ah, AR_PHY_65NM_CH0_TXRF1, </a>
<a name="ln3487">                (OS_REG_READ(ah, AR_PHY_65NM_CH0_TXRF1)</a>
<a name="ln3488">                      | (0x1 &lt;&lt; 23))&amp; ~(0x1 &lt;&lt; 21));</a>
<a name="ln3489">            OS_REG_WRITE(ah, AR_PHY_65NM_CH0_BB1, </a>
<a name="ln3490">                OS_REG_READ(ah, AR_PHY_65NM_CH0_BB1)</a>
<a name="ln3491">                      | (0x1 &lt;&lt; 12) | (0x1 &lt;&lt; 10)</a>
<a name="ln3492">                      | (0x1 &lt;&lt; 9)  | (0x1 &lt;&lt; 8)</a>
<a name="ln3493">                      | (0x1 &lt;&lt; 6)  | (0x1 &lt;&lt; 5)</a>
<a name="ln3494">                      | (0x1 &lt;&lt; 4)  | (0x1 &lt;&lt; 3)</a>
<a name="ln3495">                      | (0x1 &lt;&lt; 2));</a>
<a name="ln3496">            OS_REG_WRITE(ah, AR_PHY_65NM_CH0_BB2, </a>
<a name="ln3497">                OS_REG_READ(ah, AR_PHY_65NM_CH0_BB2) | (0x1 &lt;&lt; 31));</a>
<a name="ln3498">        }</a>
<a name="ln3499">        if (AR_SREV_OSPREY(ah) || AR_SREV_WASP(ah)) {</a>
<a name="ln3500">            /* chain one */</a>
<a name="ln3501">            if ((tx_chain_mask &amp; 0x02) == 0x02 ) {</a>
<a name="ln3502">                OS_REG_WRITE(ah, AR_PHY_65NM_CH1_RXTX1, </a>
<a name="ln3503">                    (OS_REG_READ(ah, AR_PHY_65NM_CH1_RXTX1)</a>
<a name="ln3504">                          | (0x1 &lt;&lt; 31) | (0x5 &lt;&lt; 15) </a>
<a name="ln3505">                          | (0x3 &lt;&lt; 9)) &amp; ~(0x1 &lt;&lt; 27) </a>
<a name="ln3506">                          &amp; ~(0x1 &lt;&lt; 12));</a>
<a name="ln3507">                OS_REG_WRITE(ah, AR_PHY_65NM_CH1_RXTX2, </a>
<a name="ln3508">                    (OS_REG_READ(ah, AR_PHY_65NM_CH1_RXTX2)</a>
<a name="ln3509">                          | (0x1 &lt;&lt; 12) | (0x1 &lt;&lt; 10) </a>
<a name="ln3510">                          | (0x1 &lt;&lt; 9)  | (0x1 &lt;&lt; 8)  </a>
<a name="ln3511">                          | (0x1 &lt;&lt; 7)) &amp; ~(0x1 &lt;&lt; 11));</a>
<a name="ln3512">                OS_REG_WRITE(ah, AR_PHY_65NM_CH1_RXTX3, </a>
<a name="ln3513">                    (OS_REG_READ(ah, AR_PHY_65NM_CH1_RXTX3)</a>
<a name="ln3514">                          | (0x1 &lt;&lt; 29) | (0x1 &lt;&lt; 25) </a>
<a name="ln3515">                          | (0x1 &lt;&lt; 23) | (0x1 &lt;&lt; 19) </a>
<a name="ln3516">                          | (0x1 &lt;&lt; 10) | (0x1 &lt;&lt; 9)  </a>
<a name="ln3517">                          | (0x1 &lt;&lt; 8)  | (0x1 &lt;&lt; 3))</a>
<a name="ln3518">                          &amp; ~(0x1 &lt;&lt; 28)&amp; ~(0x1 &lt;&lt; 24)</a>
<a name="ln3519">                          &amp; ~(0x1 &lt;&lt; 22)&amp; ~(0x1 &lt;&lt; 7));</a>
<a name="ln3520">                OS_REG_WRITE(ah, AR_PHY_65NM_CH1_TXRF1, </a>
<a name="ln3521">                    (OS_REG_READ(ah, AR_PHY_65NM_CH1_TXRF1)</a>
<a name="ln3522">                          | (0x1 &lt;&lt; 23))&amp; ~(0x1 &lt;&lt; 21));</a>
<a name="ln3523">                OS_REG_WRITE(ah, AR_PHY_65NM_CH1_BB1, </a>
<a name="ln3524">                    OS_REG_READ(ah, AR_PHY_65NM_CH1_BB1)</a>
<a name="ln3525">                          | (0x1 &lt;&lt; 12) | (0x1 &lt;&lt; 10)</a>
<a name="ln3526">                          | (0x1 &lt;&lt; 9)  | (0x1 &lt;&lt; 8)</a>
<a name="ln3527">                          | (0x1 &lt;&lt; 6)  | (0x1 &lt;&lt; 5)</a>
<a name="ln3528">                          | (0x1 &lt;&lt; 4)  | (0x1 &lt;&lt; 3)</a>
<a name="ln3529">                          | (0x1 &lt;&lt; 2));</a>
<a name="ln3530">                OS_REG_WRITE(ah, AR_PHY_65NM_CH1_BB2, </a>
<a name="ln3531">                    OS_REG_READ(ah, AR_PHY_65NM_CH1_BB2) | (0x1 &lt;&lt; 31));</a>
<a name="ln3532">            }</a>
<a name="ln3533">        }</a>
<a name="ln3534">        if (AR_SREV_OSPREY(ah)) {</a>
<a name="ln3535">            /* chain two */</a>
<a name="ln3536">            if ((tx_chain_mask &amp; 0x04) == 0x04 ) {</a>
<a name="ln3537">                OS_REG_WRITE(ah, AR_PHY_65NM_CH2_RXTX1, </a>
<a name="ln3538">                    (OS_REG_READ(ah, AR_PHY_65NM_CH2_RXTX1)</a>
<a name="ln3539">                          | (0x1 &lt;&lt; 31) | (0x5 &lt;&lt; 15) </a>
<a name="ln3540">                          | (0x3 &lt;&lt; 9)) &amp; ~(0x1 &lt;&lt; 27)</a>
<a name="ln3541">                          &amp; ~(0x1 &lt;&lt; 12));</a>
<a name="ln3542">                OS_REG_WRITE(ah, AR_PHY_65NM_CH2_RXTX2, </a>
<a name="ln3543">                    (OS_REG_READ(ah, AR_PHY_65NM_CH2_RXTX2)</a>
<a name="ln3544">                          | (0x1 &lt;&lt; 12) | (0x1 &lt;&lt; 10) </a>
<a name="ln3545">                          | (0x1 &lt;&lt; 9)  | (0x1 &lt;&lt; 8)  </a>
<a name="ln3546">                          | (0x1 &lt;&lt; 7)) &amp; ~(0x1 &lt;&lt; 11));</a>
<a name="ln3547">                OS_REG_WRITE(ah, AR_PHY_65NM_CH2_RXTX3, </a>
<a name="ln3548">                    (OS_REG_READ(ah, AR_PHY_65NM_CH2_RXTX3)</a>
<a name="ln3549">                          | (0x1 &lt;&lt; 29) | (0x1 &lt;&lt; 25) </a>
<a name="ln3550">                          | (0x1 &lt;&lt; 23) | (0x1 &lt;&lt; 19) </a>
<a name="ln3551">                          | (0x1 &lt;&lt; 10) | (0x1 &lt;&lt; 9)  </a>
<a name="ln3552">                          | (0x1 &lt;&lt; 8)  | (0x1 &lt;&lt; 3)) </a>
<a name="ln3553">                          &amp; ~(0x1 &lt;&lt; 28)&amp; ~(0x1 &lt;&lt; 24) </a>
<a name="ln3554">                          &amp; ~(0x1 &lt;&lt; 22)&amp; ~(0x1 &lt;&lt; 7));</a>
<a name="ln3555">                OS_REG_WRITE(ah, AR_PHY_65NM_CH2_TXRF1, </a>
<a name="ln3556">                    (OS_REG_READ(ah, AR_PHY_65NM_CH2_TXRF1)</a>
<a name="ln3557">                          | (0x1 &lt;&lt; 23))&amp; ~(0x1 &lt;&lt; 21));</a>
<a name="ln3558">                OS_REG_WRITE(ah, AR_PHY_65NM_CH2_BB1, </a>
<a name="ln3559">                    OS_REG_READ(ah, AR_PHY_65NM_CH2_BB1)</a>
<a name="ln3560">                          | (0x1 &lt;&lt; 12) | (0x1 &lt;&lt; 10)</a>
<a name="ln3561">                          | (0x1 &lt;&lt; 9)  | (0x1 &lt;&lt; 8)</a>
<a name="ln3562">                          | (0x1 &lt;&lt; 6)  | (0x1 &lt;&lt; 5)</a>
<a name="ln3563">                          | (0x1 &lt;&lt; 4)  | (0x1 &lt;&lt; 3)</a>
<a name="ln3564">                          | (0x1 &lt;&lt; 2));</a>
<a name="ln3565">                OS_REG_WRITE(ah, AR_PHY_65NM_CH2_BB2, </a>
<a name="ln3566">                    OS_REG_READ(ah, AR_PHY_65NM_CH2_BB2) | (0x1 &lt;&lt; 31));</a>
<a name="ln3567">            }</a>
<a name="ln3568">        }</a>
<a name="ln3569"> </a>
<a name="ln3570">        OS_REG_WRITE(ah, 0xa28c, 0x11111);</a>
<a name="ln3571">        OS_REG_WRITE(ah, 0xa288, 0x111);      </a>
<a name="ln3572">    } else {</a>
<a name="ln3573">        /* chain zero */</a>
<a name="ln3574">        if ((tx_chain_mask &amp; 0x01) == 0x01) {</a>
<a name="ln3575">            OS_REG_WRITE(ah, AR_PHY_65NM_CH0_RXTX1, </a>
<a name="ln3576">                (OS_REG_READ(ah, AR_PHY_65NM_CH0_RXTX1)</a>
<a name="ln3577">                      | (0x1 &lt;&lt; 31) | (0x1 &lt;&lt; 27)</a>
<a name="ln3578">                      | (0x3 &lt;&lt; 23) | (0x1 &lt;&lt; 19)</a>
<a name="ln3579">                      | (0x1 &lt;&lt; 15) | (0x3 &lt;&lt; 9))</a>
<a name="ln3580">                      &amp; ~(0x1 &lt;&lt; 12));</a>
<a name="ln3581">            OS_REG_WRITE(ah, AR_PHY_65NM_CH0_RXTX2, </a>
<a name="ln3582">                (OS_REG_READ(ah, AR_PHY_65NM_CH0_RXTX2)</a>
<a name="ln3583">                      | (0x1 &lt;&lt; 12) | (0x1 &lt;&lt; 10) </a>
<a name="ln3584">                      | (0x1 &lt;&lt; 9)  | (0x1 &lt;&lt; 8)  </a>
<a name="ln3585">                      | (0x1 &lt;&lt; 7)  | (0x1 &lt;&lt; 3)  </a>
<a name="ln3586">                      | (0x1 &lt;&lt; 2)  | (0x1 &lt;&lt; 1)) </a>
<a name="ln3587">                      &amp; ~(0x1 &lt;&lt; 11)&amp; ~(0x1 &lt;&lt; 0));</a>
<a name="ln3588">            OS_REG_WRITE(ah, AR_PHY_65NM_CH0_RXTX3, </a>
<a name="ln3589">                (OS_REG_READ(ah, AR_PHY_65NM_CH0_RXTX3)</a>
<a name="ln3590">                      | (0x1 &lt;&lt; 29) | (0x1 &lt;&lt; 25) </a>
<a name="ln3591">                      | (0x1 &lt;&lt; 23) | (0x1 &lt;&lt; 19) </a>
<a name="ln3592">                      | (0x1 &lt;&lt; 10) | (0x1 &lt;&lt; 9)  </a>
<a name="ln3593">                      | (0x1 &lt;&lt; 8)  | (0x1 &lt;&lt; 3))</a>
<a name="ln3594">                      &amp; ~(0x1 &lt;&lt; 28)&amp; ~(0x1 &lt;&lt; 24)</a>
<a name="ln3595">                      &amp; ~(0x1 &lt;&lt; 22)&amp; ~(0x1 &lt;&lt; 7));</a>
<a name="ln3596">            OS_REG_WRITE(ah, AR_PHY_65NM_CH0_TXRF1, </a>
<a name="ln3597">                (OS_REG_READ(ah, AR_PHY_65NM_CH0_TXRF1)</a>
<a name="ln3598">                      | (0x1 &lt;&lt; 23))&amp; ~(0x1 &lt;&lt; 21));</a>
<a name="ln3599">            OS_REG_WRITE(ah, AR_PHY_65NM_CH0_TXRF2, </a>
<a name="ln3600">                OS_REG_READ(ah, AR_PHY_65NM_CH0_TXRF2)</a>
<a name="ln3601">                      | (0x3 &lt;&lt; 3)  | (0x3 &lt;&lt; 0));</a>
<a name="ln3602">            OS_REG_WRITE(ah, AR_PHY_65NM_CH0_TXRF3, </a>
<a name="ln3603">                (OS_REG_READ(ah, AR_PHY_65NM_CH0_TXRF3)</a>
<a name="ln3604">                      | (0x3 &lt;&lt; 29) | (0x3 &lt;&lt; 26)</a>
<a name="ln3605">                      | (0x2 &lt;&lt; 23) | (0x2 &lt;&lt; 20)</a>
<a name="ln3606">                      | (0x2 &lt;&lt; 17))&amp; ~(0x1 &lt;&lt; 14));</a>
<a name="ln3607">            OS_REG_WRITE(ah, AR_PHY_65NM_CH0_BB1, </a>
<a name="ln3608">                OS_REG_READ(ah, AR_PHY_65NM_CH0_BB1)</a>
<a name="ln3609">                      | (0x1 &lt;&lt; 12) | (0x1 &lt;&lt; 10)</a>
<a name="ln3610">                      | (0x1 &lt;&lt; 9)  | (0x1 &lt;&lt; 8)</a>
<a name="ln3611">                      | (0x1 &lt;&lt; 6)  | (0x1 &lt;&lt; 5)</a>
<a name="ln3612">                      | (0x1 &lt;&lt; 4)  | (0x1 &lt;&lt; 3)</a>
<a name="ln3613">                      | (0x1 &lt;&lt; 2));</a>
<a name="ln3614">            OS_REG_WRITE(ah, AR_PHY_65NM_CH0_BB2, </a>
<a name="ln3615">                OS_REG_READ(ah, AR_PHY_65NM_CH0_BB2) | (0x1 &lt;&lt; 31));</a>
<a name="ln3616">            if (AR_SREV_OSPREY(ah) || AR_SREV_WASP(ah)) {</a>
<a name="ln3617">                OS_REG_WRITE(ah, AR_PHY_65NM_CH0_TOP, </a>
<a name="ln3618">                    OS_REG_READ(ah, AR_PHY_65NM_CH0_TOP) &amp; ~(0x1 &lt;&lt; 4));</a>
<a name="ln3619">                OS_REG_WRITE(ah, AR_PHY_65NM_CH0_TOP2, </a>
<a name="ln3620">                    OS_REG_READ(ah, AR_PHY_65NM_CH0_TOP2)</a>
<a name="ln3621">                          | (0x1 &lt;&lt; 26) | (0x7 &lt;&lt; 24)</a>
<a name="ln3622">                          | (0x3 &lt;&lt; 22));</a>
<a name="ln3623">            } else {</a>
<a name="ln3624">                OS_REG_WRITE(ah, AR_HORNET_CH0_TOP, </a>
<a name="ln3625">                    OS_REG_READ(ah, AR_HORNET_CH0_TOP) &amp; ~(0x1 &lt;&lt; 4));</a>
<a name="ln3626">                OS_REG_WRITE(ah, AR_HORNET_CH0_TOP2, </a>
<a name="ln3627">                    OS_REG_READ(ah, AR_HORNET_CH0_TOP2)</a>
<a name="ln3628">                          | (0x1 &lt;&lt; 26) | (0x7 &lt;&lt; 24)</a>
<a name="ln3629">                          | (0x3 &lt;&lt; 22));</a>
<a name="ln3630">            }</a>
<a name="ln3631">                                    </a>
<a name="ln3632">            if (AR_SREV_OSPREY(ah) || AR_SREV_WASP(ah)) {</a>
<a name="ln3633">                OS_REG_WRITE(ah, AR_PHY_65NM_CH1_RXTX2, </a>
<a name="ln3634">                    (OS_REG_READ(ah, AR_PHY_65NM_CH1_RXTX2)</a>
<a name="ln3635">                          | (0x1 &lt;&lt; 3)  | (0x1 &lt;&lt; 2)</a>
<a name="ln3636">                          | (0x1 &lt;&lt; 1)) &amp; ~(0x1 &lt;&lt; 0));</a>
<a name="ln3637">                OS_REG_WRITE(ah, AR_PHY_65NM_CH1_RXTX3, </a>
<a name="ln3638">                    OS_REG_READ(ah, AR_PHY_65NM_CH1_RXTX3)</a>
<a name="ln3639">                          | (0x1 &lt;&lt; 19) | (0x1 &lt;&lt; 3));</a>
<a name="ln3640">                OS_REG_WRITE(ah, AR_PHY_65NM_CH1_TXRF1, </a>
<a name="ln3641">                    OS_REG_READ(ah, AR_PHY_65NM_CH1_TXRF1) | (0x1 &lt;&lt; 23));</a>
<a name="ln3642">            }</a>
<a name="ln3643">            if (AR_SREV_OSPREY(ah)) { </a>
<a name="ln3644">                OS_REG_WRITE(ah, AR_PHY_65NM_CH2_RXTX2, </a>
<a name="ln3645">                    (OS_REG_READ(ah, AR_PHY_65NM_CH2_RXTX2)</a>
<a name="ln3646">                          | (0x1 &lt;&lt; 3)  | (0x1 &lt;&lt; 2)</a>
<a name="ln3647">                          | (0x1 &lt;&lt; 1)) &amp; ~(0x1 &lt;&lt; 0));</a>
<a name="ln3648">                OS_REG_WRITE(ah, AR_PHY_65NM_CH2_RXTX3, </a>
<a name="ln3649">                    OS_REG_READ(ah, AR_PHY_65NM_CH2_RXTX3)</a>
<a name="ln3650">                          | (0x1 &lt;&lt; 19) | (0x1 &lt;&lt; 3));</a>
<a name="ln3651">                OS_REG_WRITE(ah, AR_PHY_65NM_CH2_TXRF1, </a>
<a name="ln3652">                    OS_REG_READ(ah, AR_PHY_65NM_CH2_TXRF1) | (0x1 &lt;&lt; 23));</a>
<a name="ln3653">            }</a>
<a name="ln3654">        }</a>
<a name="ln3655">        if (AR_SREV_OSPREY(ah) || AR_SREV_WASP(ah)) {</a>
<a name="ln3656">            /* chain one */</a>
<a name="ln3657">            if ((tx_chain_mask &amp; 0x02) == 0x02 ) {</a>
<a name="ln3658">                OS_REG_WRITE(ah, AR_PHY_65NM_CH0_RXTX2, </a>
<a name="ln3659">                    (OS_REG_READ(ah, AR_PHY_65NM_CH0_RXTX2)</a>
<a name="ln3660">                          | (0x1 &lt;&lt; 3)  | (0x1 &lt;&lt; 2)</a>
<a name="ln3661">                          | (0x1 &lt;&lt; 1)) &amp; ~(0x1 &lt;&lt; 0));</a>
<a name="ln3662">                OS_REG_WRITE(ah, AR_PHY_65NM_CH0_RXTX3, </a>
<a name="ln3663">                    OS_REG_READ(ah, AR_PHY_65NM_CH0_RXTX3)</a>
<a name="ln3664">                          | (0x1 &lt;&lt; 19) | (0x1 &lt;&lt; 3));</a>
<a name="ln3665">                OS_REG_WRITE(ah, AR_PHY_65NM_CH0_TXRF1, </a>
<a name="ln3666">                    OS_REG_READ(ah, AR_PHY_65NM_CH0_TXRF1) | (0x1 &lt;&lt; 23));</a>
<a name="ln3667">                if (AR_SREV_OSPREY(ah) || AR_SREV_WASP(ah)) {</a>
<a name="ln3668">                    OS_REG_WRITE(ah, AR_PHY_65NM_CH0_TOP, </a>
<a name="ln3669">                        OS_REG_READ(ah, AR_PHY_65NM_CH0_TOP) &amp; ~(0x1 &lt;&lt; 4));</a>
<a name="ln3670">                    OS_REG_WRITE(ah, AR_PHY_65NM_CH0_TOP2, </a>
<a name="ln3671">                        OS_REG_READ(ah, AR_PHY_65NM_CH0_TOP2)</a>
<a name="ln3672">                              | (0x1 &lt;&lt; 26) | (0x7 &lt;&lt; 24)</a>
<a name="ln3673">                              | (0x3 &lt;&lt; 22));</a>
<a name="ln3674">                } else {</a>
<a name="ln3675">                    OS_REG_WRITE(ah, AR_HORNET_CH0_TOP, </a>
<a name="ln3676">                        OS_REG_READ(ah, AR_HORNET_CH0_TOP) &amp; ~(0x1 &lt;&lt; 4));</a>
<a name="ln3677">                    OS_REG_WRITE(ah, AR_HORNET_CH0_TOP2, </a>
<a name="ln3678">                        OS_REG_READ(ah, AR_HORNET_CH0_TOP2)</a>
<a name="ln3679">                              | (0x1 &lt;&lt; 26) | (0x7 &lt;&lt; 24)</a>
<a name="ln3680">                              | (0x3 &lt;&lt; 22));</a>
<a name="ln3681">                }</a>
<a name="ln3682">                </a>
<a name="ln3683">                OS_REG_WRITE(ah, AR_PHY_65NM_CH1_RXTX1, </a>
<a name="ln3684">                    (OS_REG_READ(ah, AR_PHY_65NM_CH1_RXTX1)</a>
<a name="ln3685">                          | (0x1 &lt;&lt; 31) | (0x1 &lt;&lt; 27)</a>
<a name="ln3686">                          | (0x3 &lt;&lt; 23) | (0x1 &lt;&lt; 19)</a>
<a name="ln3687">                          | (0x1 &lt;&lt; 15) | (0x3 &lt;&lt; 9)) </a>
<a name="ln3688">                          &amp; ~(0x1 &lt;&lt; 12));</a>
<a name="ln3689">                OS_REG_WRITE(ah, AR_PHY_65NM_CH1_RXTX2, </a>
<a name="ln3690">                    (OS_REG_READ(ah, AR_PHY_65NM_CH1_RXTX2)</a>
<a name="ln3691">                          | (0x1 &lt;&lt; 12) | (0x1 &lt;&lt; 10) </a>
<a name="ln3692">                          | (0x1 &lt;&lt; 9)  | (0x1 &lt;&lt; 8)  </a>
<a name="ln3693">                          | (0x1 &lt;&lt; 7)  | (0x1 &lt;&lt; 3)  </a>
<a name="ln3694">                          | (0x1 &lt;&lt; 2)  | (0x1 &lt;&lt; 1))  </a>
<a name="ln3695">                          &amp; ~(0x1 &lt;&lt; 11)&amp; ~(0x1 &lt;&lt; 0));</a>
<a name="ln3696">                OS_REG_WRITE(ah, AR_PHY_65NM_CH1_RXTX3, </a>
<a name="ln3697">                    (OS_REG_READ(ah, AR_PHY_65NM_CH1_RXTX3)</a>
<a name="ln3698">                          | (0x1 &lt;&lt; 29) | (0x1 &lt;&lt; 25) </a>
<a name="ln3699">                          | (0x1 &lt;&lt; 23) | (0x1 &lt;&lt; 19) </a>
<a name="ln3700">                          | (0x1 &lt;&lt; 10) | (0x1 &lt;&lt; 9)  </a>
<a name="ln3701">                          | (0x1 &lt;&lt; 8)  | (0x1 &lt;&lt; 3))</a>
<a name="ln3702">                          &amp; ~(0x1 &lt;&lt; 28)&amp; ~(0x1 &lt;&lt; 24)</a>
<a name="ln3703">                          &amp; ~(0x1 &lt;&lt; 22)&amp; ~(0x1 &lt;&lt; 7));</a>
<a name="ln3704">                OS_REG_WRITE(ah, AR_PHY_65NM_CH1_TXRF1, </a>
<a name="ln3705">                    (OS_REG_READ(ah, AR_PHY_65NM_CH1_TXRF1)</a>
<a name="ln3706">                          | (0x1 &lt;&lt; 23))&amp; ~(0x1 &lt;&lt; 21));</a>
<a name="ln3707">                OS_REG_WRITE(ah, AR_PHY_65NM_CH1_TXRF2, </a>
<a name="ln3708">                    OS_REG_READ(ah, AR_PHY_65NM_CH1_TXRF2)</a>
<a name="ln3709">                          | (0x3 &lt;&lt; 3)  | (0x3 &lt;&lt; 0));</a>
<a name="ln3710">                OS_REG_WRITE(ah, AR_PHY_65NM_CH1_TXRF3, </a>
<a name="ln3711">                    (OS_REG_READ(ah, AR_PHY_65NM_CH1_TXRF3)</a>
<a name="ln3712">                          | (0x3 &lt;&lt; 29) | (0x3 &lt;&lt; 26)</a>
<a name="ln3713">                          | (0x2 &lt;&lt; 23) | (0x2 &lt;&lt; 20)</a>
<a name="ln3714">                          | (0x2 &lt;&lt; 17))&amp; ~(0x1 &lt;&lt; 14));</a>
<a name="ln3715">                OS_REG_WRITE(ah, AR_PHY_65NM_CH1_BB1, </a>
<a name="ln3716">                    OS_REG_READ(ah, AR_PHY_65NM_CH1_BB1)</a>
<a name="ln3717">                          | (0x1 &lt;&lt; 12) | (0x1 &lt;&lt; 10)</a>
<a name="ln3718">                          | (0x1 &lt;&lt; 9)  | (0x1 &lt;&lt; 8)</a>
<a name="ln3719">                          | (0x1 &lt;&lt; 6)  | (0x1 &lt;&lt; 5)</a>
<a name="ln3720">                          | (0x1 &lt;&lt; 4)  | (0x1 &lt;&lt; 3)</a>
<a name="ln3721">                          | (0x1 &lt;&lt; 2));</a>
<a name="ln3722">                OS_REG_WRITE(ah, AR_PHY_65NM_CH1_BB2, </a>
<a name="ln3723">                    OS_REG_READ(ah, AR_PHY_65NM_CH1_BB2) | (0x1 &lt;&lt; 31));</a>
<a name="ln3724"> </a>
<a name="ln3725">                if (AR_SREV_OSPREY(ah)) {</a>
<a name="ln3726">                    OS_REG_WRITE(ah, AR_PHY_65NM_CH2_RXTX2, </a>
<a name="ln3727">                        (OS_REG_READ(ah, AR_PHY_65NM_CH2_RXTX2)</a>
<a name="ln3728">                              | (0x1 &lt;&lt; 3)  | (0x1 &lt;&lt; 2)</a>
<a name="ln3729">                              | (0x1 &lt;&lt; 1)) &amp; ~(0x1 &lt;&lt; 0));</a>
<a name="ln3730">                    OS_REG_WRITE(ah, AR_PHY_65NM_CH2_RXTX3, </a>
<a name="ln3731">                        OS_REG_READ(ah, AR_PHY_65NM_CH2_RXTX3)</a>
<a name="ln3732">                              | (0x1 &lt;&lt; 19) | (0x1 &lt;&lt; 3));</a>
<a name="ln3733">                    OS_REG_WRITE(ah, AR_PHY_65NM_CH2_TXRF1, </a>
<a name="ln3734">                        OS_REG_READ(ah, AR_PHY_65NM_CH2_TXRF1) | (0x1 &lt;&lt; 23));</a>
<a name="ln3735">                }</a>
<a name="ln3736">            }</a>
<a name="ln3737">        }</a>
<a name="ln3738">        if (AR_SREV_OSPREY(ah)) {</a>
<a name="ln3739">            /* chain two */</a>
<a name="ln3740">            if ((tx_chain_mask &amp; 0x04) == 0x04 ) {</a>
<a name="ln3741">                OS_REG_WRITE(ah, AR_PHY_65NM_CH0_RXTX2, </a>
<a name="ln3742">                    (OS_REG_READ(ah, AR_PHY_65NM_CH0_RXTX2)</a>
<a name="ln3743">                          | (0x1 &lt;&lt; 3)  | (0x1 &lt;&lt; 2)</a>
<a name="ln3744">                          | (0x1 &lt;&lt; 1)) &amp; ~(0x1 &lt;&lt; 0));</a>
<a name="ln3745">                OS_REG_WRITE(ah, AR_PHY_65NM_CH0_RXTX3, </a>
<a name="ln3746">                    OS_REG_READ(ah, AR_PHY_65NM_CH0_RXTX3)</a>
<a name="ln3747">                          | (0x1 &lt;&lt; 19) | (0x1 &lt;&lt; 3));</a>
<a name="ln3748">                OS_REG_WRITE(ah, AR_PHY_65NM_CH0_TXRF1, </a>
<a name="ln3749">                    OS_REG_READ(ah, AR_PHY_65NM_CH0_TXRF1) | (0x1 &lt;&lt; 23));</a>
<a name="ln3750">                if (AR_SREV_OSPREY(ah) || AR_SREV_WASP(ah)) {</a>
<a name="ln3751">                    OS_REG_WRITE(ah, AR_PHY_65NM_CH0_TOP, </a>
<a name="ln3752">                        OS_REG_READ(ah, AR_PHY_65NM_CH0_TOP) &amp; ~(0x1 &lt;&lt; 4));</a>
<a name="ln3753">                    OS_REG_WRITE(ah, AR_PHY_65NM_CH0_TOP2, </a>
<a name="ln3754">                        OS_REG_READ(ah, AR_PHY_65NM_CH0_TOP2)</a>
<a name="ln3755">                              | (0x1 &lt;&lt; 26) | (0x7 &lt;&lt; 24)</a>
<a name="ln3756">                              | (0x3 &lt;&lt; 22));</a>
<a name="ln3757">                } else {</a>
<a name="ln3758">                    OS_REG_WRITE(ah, AR_HORNET_CH0_TOP, </a>
<a name="ln3759">                        OS_REG_READ(ah, AR_HORNET_CH0_TOP) &amp; ~(0x1 &lt;&lt; 4));</a>
<a name="ln3760">                    OS_REG_WRITE(ah, AR_HORNET_CH0_TOP2, </a>
<a name="ln3761">                        OS_REG_READ(ah, AR_HORNET_CH0_TOP2)</a>
<a name="ln3762">                              | (0x1 &lt;&lt; 26) | (0x7 &lt;&lt; 24)</a>
<a name="ln3763">                              | (0x3 &lt;&lt; 22));</a>
<a name="ln3764">                }</a>
<a name="ln3765"> </a>
<a name="ln3766">                OS_REG_WRITE(ah, AR_PHY_65NM_CH1_RXTX2, </a>
<a name="ln3767">                    (OS_REG_READ(ah, AR_PHY_65NM_CH1_RXTX2)</a>
<a name="ln3768">                          | (0x1 &lt;&lt; 3)  | (0x1 &lt;&lt; 2)</a>
<a name="ln3769">                          | (0x1 &lt;&lt; 1)) &amp; ~(0x1 &lt;&lt; 0));</a>
<a name="ln3770">                OS_REG_WRITE(ah, AR_PHY_65NM_CH1_RXTX3, </a>
<a name="ln3771">                    OS_REG_READ(ah, AR_PHY_65NM_CH1_RXTX3)</a>
<a name="ln3772">                          | (0x1 &lt;&lt; 19) | (0x1 &lt;&lt; 3));</a>
<a name="ln3773">                OS_REG_WRITE(ah, AR_PHY_65NM_CH1_TXRF1, </a>
<a name="ln3774">                    OS_REG_READ(ah, AR_PHY_65NM_CH1_TXRF1) | (0x1 &lt;&lt; 23));</a>
<a name="ln3775"> </a>
<a name="ln3776">                OS_REG_WRITE(ah, AR_PHY_65NM_CH2_RXTX1, </a>
<a name="ln3777">                    (OS_REG_READ(ah, AR_PHY_65NM_CH2_RXTX1)</a>
<a name="ln3778">                          | (0x1 &lt;&lt; 31) | (0x1 &lt;&lt; 27)</a>
<a name="ln3779">                          | (0x3 &lt;&lt; 23) | (0x1 &lt;&lt; 19)</a>
<a name="ln3780">                          | (0x1 &lt;&lt; 15) | (0x3 &lt;&lt; 9)) </a>
<a name="ln3781">                          &amp; ~(0x1 &lt;&lt; 12));</a>
<a name="ln3782">                OS_REG_WRITE(ah, AR_PHY_65NM_CH2_RXTX2, </a>
<a name="ln3783">                    (OS_REG_READ(ah, AR_PHY_65NM_CH2_RXTX2)</a>
<a name="ln3784">                          | (0x1 &lt;&lt; 12) | (0x1 &lt;&lt; 10) </a>
<a name="ln3785">                          | (0x1 &lt;&lt; 9)  | (0x1 &lt;&lt; 8)  </a>
<a name="ln3786">                          | (0x1 &lt;&lt; 7)  | (0x1 &lt;&lt; 3)  </a>
<a name="ln3787">                          | (0x1 &lt;&lt; 2)  | (0x1 &lt;&lt; 1))  </a>
<a name="ln3788">                          &amp; ~(0x1 &lt;&lt; 11)&amp; ~(0x1 &lt;&lt; 0));</a>
<a name="ln3789">                OS_REG_WRITE(ah, AR_PHY_65NM_CH2_RXTX3, </a>
<a name="ln3790">                    (OS_REG_READ(ah, AR_PHY_65NM_CH2_RXTX3)</a>
<a name="ln3791">                          | (0x1 &lt;&lt; 29) | (0x1 &lt;&lt; 25) </a>
<a name="ln3792">                          | (0x1 &lt;&lt; 23) | (0x1 &lt;&lt; 19) </a>
<a name="ln3793">                          | (0x1 &lt;&lt; 10) | (0x1 &lt;&lt; 9)  </a>
<a name="ln3794">                          | (0x1 &lt;&lt; 8)  | (0x1 &lt;&lt; 3))</a>
<a name="ln3795">                          &amp; ~(0x1 &lt;&lt; 28)&amp; ~(0x1 &lt;&lt; 24)</a>
<a name="ln3796">                          &amp; ~(0x1 &lt;&lt; 22)&amp; ~(0x1 &lt;&lt; 7));</a>
<a name="ln3797">                OS_REG_WRITE(ah, AR_PHY_65NM_CH2_TXRF1, </a>
<a name="ln3798">                    (OS_REG_READ(ah, AR_PHY_65NM_CH2_TXRF1)</a>
<a name="ln3799">                          | (0x1 &lt;&lt; 23))&amp; ~(0x1 &lt;&lt; 21));</a>
<a name="ln3800">                OS_REG_WRITE(ah, AR_PHY_65NM_CH2_TXRF2, </a>
<a name="ln3801">                    OS_REG_READ(ah, AR_PHY_65NM_CH2_TXRF2)</a>
<a name="ln3802">                          | (0x3 &lt;&lt; 3)  | (0x3 &lt;&lt; 0));</a>
<a name="ln3803">                OS_REG_WRITE(ah, AR_PHY_65NM_CH2_TXRF3, </a>
<a name="ln3804">                    (OS_REG_READ(ah, AR_PHY_65NM_CH2_TXRF3)</a>
<a name="ln3805">                          | (0x3 &lt;&lt; 29) | (0x3 &lt;&lt; 26)</a>
<a name="ln3806">                          | (0x2 &lt;&lt; 23) | (0x2 &lt;&lt; 20)</a>
<a name="ln3807">                          | (0x2 &lt;&lt; 17))&amp; ~(0x1 &lt;&lt; 14));</a>
<a name="ln3808">                OS_REG_WRITE(ah, AR_PHY_65NM_CH2_BB1, </a>
<a name="ln3809">                    OS_REG_READ(ah, AR_PHY_65NM_CH2_BB1)</a>
<a name="ln3810">                          | (0x1 &lt;&lt; 12) | (0x1 &lt;&lt; 10)</a>
<a name="ln3811">                          | (0x1 &lt;&lt; 9)  | (0x1 &lt;&lt; 8)</a>
<a name="ln3812">                          | (0x1 &lt;&lt; 6)  | (0x1 &lt;&lt; 5)</a>
<a name="ln3813">                          | (0x1 &lt;&lt; 4)  | (0x1 &lt;&lt; 3)</a>
<a name="ln3814">                          | (0x1 &lt;&lt; 2));</a>
<a name="ln3815">                OS_REG_WRITE(ah, AR_PHY_65NM_CH2_BB2, </a>
<a name="ln3816">                    OS_REG_READ(ah, AR_PHY_65NM_CH2_BB2) | (0x1 &lt;&lt; 31));</a>
<a name="ln3817">            }</a>
<a name="ln3818">        }</a>
<a name="ln3819"> </a>
<a name="ln3820">        OS_REG_WRITE(ah, 0xa28c, 0x22222);</a>
<a name="ln3821">        OS_REG_WRITE(ah, 0xa288, 0x222);</a>
<a name="ln3822">    }</a>
<a name="ln3823">}</a>
<a name="ln3824"> </a>
<a name="ln3825">void </a>
<a name="ln3826">ar9300_tx99_start(struct ath_hal *ah, u_int8_t *data)</a>
<a name="ln3827">{</a>
<a name="ln3828">    u_int32_t val;</a>
<a name="ln3829">    u_int32_t qnum = (u_int32_t)data;</a>
<a name="ln3830"> </a>
<a name="ln3831">    /* Disable AGC to A2 */</a>
<a name="ln3832">    OS_REG_WRITE(ah, AR_PHY_TEST, (OS_REG_READ(ah, AR_PHY_TEST) | PHY_AGC_CLR));</a>
<a name="ln3833">    OS_REG_WRITE(ah, AR_DIAG_SW, OS_REG_READ(ah, AR_DIAG_SW) &amp;~ AR_DIAG_RX_DIS);</a>
<a name="ln3834"> </a>
<a name="ln3835">    OS_REG_WRITE(ah, AR_CR, AR_CR_RXD);     /* set receive disable */</a>
<a name="ln3836">    /* set CW_MIN and CW_MAX both to 0, AIFS=2 */</a>
<a name="ln3837">    OS_REG_WRITE(ah, AR_DLCL_IFS(qnum), 0);</a>
<a name="ln3838">    OS_REG_WRITE(ah, AR_D_GBL_IFS_SIFS, 20); /* 50 OK */</a>
<a name="ln3839">    OS_REG_WRITE(ah, AR_D_GBL_IFS_EIFS, 20);</a>
<a name="ln3840">    /* 200 ok for HT20, 400 ok for HT40 */</a>
<a name="ln3841">    OS_REG_WRITE(ah, AR_TIME_OUT, 0x00000400);</a>
<a name="ln3842">    OS_REG_WRITE(ah, AR_DRETRY_LIMIT(qnum), 0xffffffff);</a>
<a name="ln3843">    </a>
<a name="ln3844">    /* set QCU modes to early termination */</a>
<a name="ln3845">    val = OS_REG_READ(ah, AR_QMISC(qnum));</a>
<a name="ln3846">    OS_REG_WRITE(ah, AR_QMISC(qnum), val | AR_Q_MISC_DCU_EARLY_TERM_REQ);</a>
<a name="ln3847">}</a>
<a name="ln3848"> </a>
<a name="ln3849">void </a>
<a name="ln3850">ar9300_tx99_stop(struct ath_hal *ah)</a>
<a name="ln3851">{</a>
<a name="ln3852">    /* this should follow the setting of start */</a>
<a name="ln3853">    OS_REG_WRITE(ah, AR_PHY_TEST, OS_REG_READ(ah, AR_PHY_TEST) &amp;~ PHY_AGC_CLR);</a>
<a name="ln3854">    OS_REG_WRITE(ah, AR_DIAG_SW, OS_REG_READ(ah, AR_DIAG_SW) | AR_DIAG_RX_DIS);</a>
<a name="ln3855">}</a>
<a name="ln3856">#endif /* ATH_TX99_DIAG */</a>
<a name="ln3857">#endif /* ATH_SUPPORT_HTC */</a>
<a name="ln3858"> </a>
<a name="ln3859">HAL_BOOL </a>
<a name="ln3860">ar9300Get3StreamSignature(struct ath_hal *ah)</a>
<a name="ln3861">{</a>
<a name="ln3862">    return AH_FALSE;</a>
<a name="ln3863">}</a>
<a name="ln3864"> </a>
<a name="ln3865">HAL_BOOL</a>
<a name="ln3866">ar9300ForceVCS(struct ath_hal *ah)</a>
<a name="ln3867">{</a>
<a name="ln3868">   return AH_FALSE;</a>
<a name="ln3869">}</a>
<a name="ln3870"> </a>
<a name="ln3871">HAL_BOOL</a>
<a name="ln3872">ar9300SetDfs3StreamFix(struct ath_hal *ah, u_int32_t val)</a>
<a name="ln3873">{</a>
<a name="ln3874">   return AH_FALSE;</a>
<a name="ln3875">}</a>
<a name="ln3876"> </a>
<a name="ln3877">static u_int32_t</a>
<a name="ln3878">ar9300_read_loc_timer(struct ath_hal *ah)</a>
<a name="ln3879">{</a>
<a name="ln3880"> </a>
<a name="ln3881">    return OS_REG_READ(ah, AR_LOC_TIMER_REG);</a>
<a name="ln3882">}</a>
<a name="ln3883"> </a>
<a name="ln3884">HAL_BOOL</a>
<a name="ln3885">ar9300_set_ctl_pwr(struct ath_hal *ah, u_int8_t *ctl_array)</a>
<a name="ln3886">{</a>
<a name="ln3887">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln3888">    ar9300_eeprom_t *p_eep_data = &amp;ahp-&gt;ah_eeprom;</a>
<a name="ln3889">    u_int8_t *ctl_index;</a>
<a name="ln3890">    u_int32_t offset = 0;</a>
<a name="ln3891"> </a>
<a name="ln3892">    if (!ctl_array)</a>
<a name="ln3893">        return AH_FALSE;</a>
<a name="ln3894"> </a>
<a name="ln3895">    /* copy 2G ctl freqbin and power data */</a>
<a name="ln3896">    ctl_index = p_eep_data-&gt;ctl_index_2g;</a>
<a name="ln3897">    OS_MEMCPY(ctl_index + OSPREY_NUM_CTLS_2G, ctl_array,</a>
<a name="ln3898">                OSPREY_NUM_CTLS_2G * OSPREY_NUM_BAND_EDGES_2G +     /* ctl_freqbin_2G */</a>
<a name="ln3899">                OSPREY_NUM_CTLS_2G * sizeof(OSP_CAL_CTL_DATA_2G));  /* ctl_power_data_2g */</a>
<a name="ln3900">    offset = (OSPREY_NUM_CTLS_2G * OSPREY_NUM_BAND_EDGES_2G) +</a>
<a name="ln3901">            ( OSPREY_NUM_CTLS_2G * sizeof(OSP_CAL_CTL_DATA_2G));</a>
<a name="ln3902"> </a>
<a name="ln3903"> </a>
<a name="ln3904">    /* copy 2G ctl freqbin and power data */</a>
<a name="ln3905">    ctl_index = p_eep_data-&gt;ctl_index_5g;</a>
<a name="ln3906">    OS_MEMCPY(ctl_index + OSPREY_NUM_CTLS_5G, ctl_array + offset,</a>
<a name="ln3907">                OSPREY_NUM_CTLS_5G * OSPREY_NUM_BAND_EDGES_5G +     /* ctl_freqbin_5G */</a>
<a name="ln3908">                OSPREY_NUM_CTLS_5G * sizeof(OSP_CAL_CTL_DATA_5G));  /* ctl_power_data_5g */</a>
<a name="ln3909"> </a>
<a name="ln3910">    return AH_FALSE;</a>
<a name="ln3911">}</a>
<a name="ln3912"> </a>
<a name="ln3913">void</a>
<a name="ln3914">ar9300_set_txchainmaskopt(struct ath_hal *ah, u_int8_t mask)</a>
<a name="ln3915">{</a>
<a name="ln3916">    struct ath_hal_9300 *ahp = AH9300(ah);</a>
<a name="ln3917"> </a>
<a name="ln3918">    /* optional txchainmask should be subset of primary txchainmask */</a>
<a name="ln3919">    if ((mask &amp; ahp-&gt;ah_tx_chainmask) != mask) {</a>
<a name="ln3920">        ahp-&gt;ah_tx_chainmaskopt = 0;</a>
<a name="ln3921">        ath_hal_printf(ah, &quot;Error: ah_tx_chainmask=%d, mask=%d\n&quot;, ahp-&gt;ah_tx_chainmask, mask);</a>
<a name="ln3922">        return;</a>
<a name="ln3923">    }</a>
<a name="ln3924">    </a>
<a name="ln3925">    ahp-&gt;ah_tx_chainmaskopt = mask;</a>
<a name="ln3926">}</a>

</code></pre>
<div class="balloon" rel="3897"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memcpy' function will lead to overflow of the buffer 'ctl_index + 12'.</p></div>
<div class="balloon" rel="3906"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the 'memcpy' function will lead to overflow of the buffer 'ctl_index + 9'.</p></div>
<div class="balloon" rel="2902"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
