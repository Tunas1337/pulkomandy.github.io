
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>DwarfFile.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2009-2012, Ingo Weinhold, ingo_weinhold@gmx.de.</a>
<a name="ln3"> * Copyright 2012-2014, Rene Gollent, rene@gollent.com.</a>
<a name="ln4"> * Distributed under the terms of the MIT License.</a>
<a name="ln5"> */</a>
<a name="ln6"> </a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;DwarfFile.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;algorithm&gt;</a>
<a name="ln11">#include &lt;new&gt;</a>
<a name="ln12"> </a>
<a name="ln13">#include &lt;AutoDeleter.h&gt;</a>
<a name="ln14">#include &lt;Entry.h&gt;</a>
<a name="ln15">#include &lt;FindDirectory.h&gt;</a>
<a name="ln16">#include &lt;Path.h&gt;</a>
<a name="ln17">#include &lt;PathFinder.h&gt;</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;AttributeClasses.h&quot;</a>
<a name="ln20">#include &quot;AttributeValue.h&quot;</a>
<a name="ln21">#include &quot;AbbreviationTable.h&quot;</a>
<a name="ln22">#include &quot;CfaContext.h&quot;</a>
<a name="ln23">#include &quot;CompilationUnit.h&quot;</a>
<a name="ln24">#include &quot;DataReader.h&quot;</a>
<a name="ln25">#include &quot;DwarfExpressionEvaluator.h&quot;</a>
<a name="ln26">#include &quot;DwarfTargetInterface.h&quot;</a>
<a name="ln27">#include &quot;ElfFile.h&quot;</a>
<a name="ln28">#include &quot;TagNames.h&quot;</a>
<a name="ln29">#include &quot;TargetAddressRangeList.h&quot;</a>
<a name="ln30">#include &quot;Tracing.h&quot;</a>
<a name="ln31">#include &quot;Variant.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33"> </a>
<a name="ln34">// #pragma mark - AutoSectionPutter</a>
<a name="ln35"> </a>
<a name="ln36"> </a>
<a name="ln37">class AutoSectionPutter {</a>
<a name="ln38">public:</a>
<a name="ln39">	AutoSectionPutter(ElfFile* elfFile, ElfSection* elfSection)</a>
<a name="ln40">		:</a>
<a name="ln41">		fElfFile(elfFile),</a>
<a name="ln42">		fElfSection(elfSection)</a>
<a name="ln43">	{</a>
<a name="ln44">	}</a>
<a name="ln45"> </a>
<a name="ln46">	~AutoSectionPutter()</a>
<a name="ln47">	{</a>
<a name="ln48">		if (fElfSection != NULL)</a>
<a name="ln49">			fElfFile-&gt;PutSection(fElfSection);</a>
<a name="ln50">	}</a>
<a name="ln51"> </a>
<a name="ln52">private:</a>
<a name="ln53">	ElfFile*			fElfFile;</a>
<a name="ln54">	ElfSection*			fElfSection;</a>
<a name="ln55">};</a>
<a name="ln56"> </a>
<a name="ln57"> </a>
<a name="ln58">// #pragma mark - ExpressionEvaluationContext</a>
<a name="ln59"> </a>
<a name="ln60"> </a>
<a name="ln61">struct DwarfFile::ExpressionEvaluationContext</a>
<a name="ln62">	: DwarfExpressionEvaluationContext {</a>
<a name="ln63">public:</a>
<a name="ln64">	ExpressionEvaluationContext(DwarfFile* file, CompilationUnit* unit,</a>
<a name="ln65">		uint8 addressSize, DIESubprogram* subprogramEntry,</a>
<a name="ln66">		const DwarfTargetInterface* targetInterface,</a>
<a name="ln67">		target_addr_t instructionPointer, target_addr_t objectPointer,</a>
<a name="ln68">		bool hasObjectPointer, target_addr_t framePointer,</a>
<a name="ln69">		target_addr_t relocationDelta)</a>
<a name="ln70">		:</a>
<a name="ln71">		DwarfExpressionEvaluationContext(targetInterface, addressSize,</a>
<a name="ln72">			relocationDelta),</a>
<a name="ln73">		fFile(file),</a>
<a name="ln74">		fUnit(unit),</a>
<a name="ln75">		fSubprogramEntry(subprogramEntry),</a>
<a name="ln76">		fInstructionPointer(instructionPointer),</a>
<a name="ln77">		fObjectPointer(objectPointer),</a>
<a name="ln78">		fHasObjectPointer(hasObjectPointer),</a>
<a name="ln79">		fFramePointer(framePointer),</a>
<a name="ln80">		fFrameBasePointer(0),</a>
<a name="ln81">		fFrameBaseEvaluated(false)</a>
<a name="ln82">	{</a>
<a name="ln83">	}</a>
<a name="ln84"> </a>
<a name="ln85">	virtual bool GetObjectAddress(target_addr_t&amp; _address)</a>
<a name="ln86">	{</a>
<a name="ln87">		if (!fHasObjectPointer)</a>
<a name="ln88">			return false;</a>
<a name="ln89"> </a>
<a name="ln90">		_address = fObjectPointer;</a>
<a name="ln91">		return true;</a>
<a name="ln92">	}</a>
<a name="ln93"> </a>
<a name="ln94">	virtual bool GetFrameAddress(target_addr_t&amp; _address)</a>
<a name="ln95">	{</a>
<a name="ln96">		if (fFramePointer == 0)</a>
<a name="ln97">			return false;</a>
<a name="ln98"> </a>
<a name="ln99">		_address = fFramePointer;</a>
<a name="ln100">		return true;</a>
<a name="ln101">	}</a>
<a name="ln102"> </a>
<a name="ln103">	virtual bool GetFrameBaseAddress(target_addr_t&amp; _address)</a>
<a name="ln104">	{</a>
<a name="ln105">		if (fFrameBaseEvaluated) {</a>
<a name="ln106">			if (fFrameBasePointer == 0)</a>
<a name="ln107">				return false;</a>
<a name="ln108"> </a>
<a name="ln109">			_address = fFrameBasePointer;</a>
<a name="ln110">			return true;</a>
<a name="ln111">		}</a>
<a name="ln112"> </a>
<a name="ln113">		// set flag already to prevent recursion for a buggy expression</a>
<a name="ln114">		fFrameBaseEvaluated = true;</a>
<a name="ln115"> </a>
<a name="ln116">		// get the subprogram's frame base location</a>
<a name="ln117">		if (fSubprogramEntry == NULL)</a>
<a name="ln118">			return false;</a>
<a name="ln119">		const LocationDescription* location = fSubprogramEntry-&gt;FrameBase();</a>
<a name="ln120">		if (!location-&gt;IsValid())</a>
<a name="ln121">			return false;</a>
<a name="ln122"> </a>
<a name="ln123">		// get the expression</a>
<a name="ln124">		const void* expression;</a>
<a name="ln125">		off_t expressionLength;</a>
<a name="ln126">		status_t error = fFile-&gt;_GetLocationExpression(fUnit, location,</a>
<a name="ln127">			fInstructionPointer, expression, expressionLength);</a>
<a name="ln128">		if (error != B_OK)</a>
<a name="ln129">			return false;</a>
<a name="ln130"> </a>
<a name="ln131">		// evaluate the expression</a>
<a name="ln132">		DwarfExpressionEvaluator evaluator(this);</a>
<a name="ln133">		error = evaluator.Evaluate(expression, expressionLength,</a>
<a name="ln134">			fFrameBasePointer);</a>
<a name="ln135">		if (error != B_OK)</a>
<a name="ln136">			return false;</a>
<a name="ln137"> </a>
<a name="ln138">		TRACE_EXPR(&quot;  -&gt; frame base: %&quot; B_PRIx64 &quot;\n&quot;, fFrameBasePointer);</a>
<a name="ln139"> </a>
<a name="ln140">		_address = fFrameBasePointer;</a>
<a name="ln141">		return true;</a>
<a name="ln142">	}</a>
<a name="ln143"> </a>
<a name="ln144">	virtual bool GetTLSAddress(target_addr_t localAddress,</a>
<a name="ln145">		target_addr_t&amp; _address)</a>
<a name="ln146">	{</a>
<a name="ln147">		// TODO:...</a>
<a name="ln148">		return false;</a>
<a name="ln149">	}</a>
<a name="ln150"> </a>
<a name="ln151">	virtual status_t GetCallTarget(uint64 offset, uint8 refType,</a>
<a name="ln152">		const void*&amp; _block, off_t&amp; _size)</a>
<a name="ln153">	{</a>
<a name="ln154">		// resolve the entry</a>
<a name="ln155">		DebugInfoEntry* entry = fFile-&gt;_ResolveReference(fUnit, offset, refType);</a>
<a name="ln156">		if (entry == NULL)</a>
<a name="ln157">			return B_ENTRY_NOT_FOUND;</a>
<a name="ln158"> </a>
<a name="ln159">		// get the location description</a>
<a name="ln160">		LocationDescription* location = entry-&gt;GetLocationDescription();</a>
<a name="ln161">		if (location == NULL || !location-&gt;IsValid()) {</a>
<a name="ln162">			_block = NULL;</a>
<a name="ln163">			_size = 0;</a>
<a name="ln164">			return B_OK;</a>
<a name="ln165">		}</a>
<a name="ln166"> </a>
<a name="ln167">		// get the expression</a>
<a name="ln168">		return fFile-&gt;_GetLocationExpression(fUnit, location,</a>
<a name="ln169">			fInstructionPointer, _block, _size);</a>
<a name="ln170">	}</a>
<a name="ln171"> </a>
<a name="ln172">private:</a>
<a name="ln173">	DwarfFile*			fFile;</a>
<a name="ln174">	CompilationUnit*	fUnit;</a>
<a name="ln175">	DIESubprogram*		fSubprogramEntry;</a>
<a name="ln176">	target_addr_t		fInstructionPointer;</a>
<a name="ln177">	target_addr_t		fObjectPointer;</a>
<a name="ln178">	bool				fHasObjectPointer;</a>
<a name="ln179">	target_addr_t		fFramePointer;</a>
<a name="ln180">	target_addr_t		fFrameBasePointer;</a>
<a name="ln181">	bool				fFrameBaseEvaluated;</a>
<a name="ln182">};</a>
<a name="ln183"> </a>
<a name="ln184"> </a>
<a name="ln185">// #pragma mark - FDEAugmentation</a>
<a name="ln186"> </a>
<a name="ln187"> </a>
<a name="ln188">struct DwarfFile::FDEAugmentation {</a>
<a name="ln189">	// Currently we're ignoring all augmentation data.</a>
<a name="ln190">};</a>
<a name="ln191"> </a>
<a name="ln192"> </a>
<a name="ln193">// #pragma mark - CIEAugmentation</a>
<a name="ln194"> </a>
<a name="ln195"> </a>
<a name="ln196">enum {</a>
<a name="ln197">	CFI_AUGMENTATION_DATA					= 0x01,</a>
<a name="ln198">	CFI_AUGMENTATION_LANGUAGE_SPECIFIC_DATA	= 0x02,</a>
<a name="ln199">	CFI_AUGMENTATION_PERSONALITY			= 0x04,</a>
<a name="ln200">	CFI_AUGMENTATION_ADDRESS_POINTER_FORMAT	= 0x08,</a>
<a name="ln201">};</a>
<a name="ln202"> </a>
<a name="ln203"> </a>
<a name="ln204">// encodings for CFI_AUGMENTATION_ADDRESS_POINTER_FORMAT</a>
<a name="ln205">enum {</a>
<a name="ln206">	CFI_ADDRESS_FORMAT_ABSOLUTE			= 0x00,</a>
<a name="ln207">	CFI_ADDRESS_FORMAT_UNSIGNED_LEB128	= 0x01,</a>
<a name="ln208">	CFI_ADDRESS_FORMAT_UNSIGNED_16		= 0x02,</a>
<a name="ln209">	CFI_ADDRESS_FORMAT_UNSIGNED_32		= 0x03,</a>
<a name="ln210">	CFI_ADDRESS_FORMAT_UNSIGNED_64		= 0x04,</a>
<a name="ln211">	CFI_ADDRESS_FORMAT_SIGNED			= 0x08,</a>
<a name="ln212">	CFI_ADDRESS_FORMAT_SIGNED_LEB128	=</a>
<a name="ln213">		CFI_ADDRESS_FORMAT_UNSIGNED_LEB128 | CFI_ADDRESS_FORMAT_SIGNED,</a>
<a name="ln214">	CFI_ADDRESS_FORMAT_SIGNED_16		=</a>
<a name="ln215">		CFI_ADDRESS_FORMAT_UNSIGNED_16 | CFI_ADDRESS_FORMAT_SIGNED,</a>
<a name="ln216">	CFI_ADDRESS_FORMAT_SIGNED_32		=</a>
<a name="ln217">		CFI_ADDRESS_FORMAT_UNSIGNED_32 | CFI_ADDRESS_FORMAT_SIGNED,</a>
<a name="ln218">	CFI_ADDRESS_FORMAT_SIGNED_64		=</a>
<a name="ln219">		CFI_ADDRESS_FORMAT_UNSIGNED_64 | CFI_ADDRESS_FORMAT_SIGNED</a>
<a name="ln220">};</a>
<a name="ln221"> </a>
<a name="ln222"> </a>
<a name="ln223">enum {</a>
<a name="ln224">	CFI_ADDRESS_TYPE_PC_RELATIVE		= 0x10,</a>
<a name="ln225">	CFI_ADDRESS_TYPE_TEXT_RELATIVE		= 0x20,</a>
<a name="ln226">	CFI_ADDRESS_TYPE_DATA_RELATIVE		= 0x30,</a>
<a name="ln227">	CFI_ADDRESS_TYPE_FUNCTION_RELATIVE	= 0x40,</a>
<a name="ln228">	CFI_ADDRESS_TYPE_ALIGNED			= 0x50,</a>
<a name="ln229">	CFI_ADDRESS_TYPE_INDIRECT			= 0x80</a>
<a name="ln230">};</a>
<a name="ln231"> </a>
<a name="ln232"> </a>
<a name="ln233">struct DwarfFile::CIEAugmentation {</a>
<a name="ln234">	CIEAugmentation()</a>
<a name="ln235">		:</a>
<a name="ln236">		fString(NULL),</a>
<a name="ln237">		fFlags(0),</a>
<a name="ln238">		fAddressEncoding(CFI_ADDRESS_FORMAT_ABSOLUTE)</a>
<a name="ln239">	{</a>
<a name="ln240">		// we default to absolute address format since that corresponds</a>
<a name="ln241">		// to the DWARF standard for .debug_frame. In gcc's case, however,</a>
<a name="ln242">		// .eh_frame will generally override that via augmentation 'R'</a>
<a name="ln243">	}</a>
<a name="ln244"> </a>
<a name="ln245">	void Init(DataReader&amp; dataReader)</a>
<a name="ln246">	{</a>
<a name="ln247">		fFlags = 0;</a>
<a name="ln248">		fString = dataReader.ReadString();</a>
<a name="ln249">	}</a>
<a name="ln250"> </a>
<a name="ln251">	status_t Read(DataReader&amp; dataReader)</a>
<a name="ln252">	{</a>
<a name="ln253">		if (fString == NULL || *fString == '\0')</a>
<a name="ln254">			return B_OK;</a>
<a name="ln255"> </a>
<a name="ln256">		if (*fString == 'z') {</a>
<a name="ln257">			// There are augmentation data.</a>
<a name="ln258">			fFlags |= CFI_AUGMENTATION_DATA;</a>
<a name="ln259">			const char* string = fString + 1;</a>
<a name="ln260"> </a>
<a name="ln261">			// read the augmentation data block -- it is preceeded by an</a>
<a name="ln262">			// LEB128 indicating the length of the data block</a>
<a name="ln263">			uint64 length = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln264">			uint64 remaining = length;</a>
<a name="ln265">			// let's see what data we have to expect</a>
<a name="ln266"> </a>
<a name="ln267">			TRACE_CFI(&quot;    %&quot; B_PRIu64 &quot; bytes of augmentation data\n&quot;, length);</a>
<a name="ln268">			while (*string != '\0') {</a>
<a name="ln269">				switch (*string) {</a>
<a name="ln270">					case 'L':</a>
<a name="ln271">						fFlags |= CFI_AUGMENTATION_LANGUAGE_SPECIFIC_DATA;</a>
<a name="ln272">						dataReader.Read&lt;char&gt;(0);</a>
<a name="ln273">						--remaining;</a>
<a name="ln274">						break;</a>
<a name="ln275">					case 'P':</a>
<a name="ln276">					{</a>
<a name="ln277">						char tempEncoding = fAddressEncoding;</a>
<a name="ln278">						fAddressEncoding = dataReader.Read&lt;char&gt;(0);</a>
<a name="ln279">						off_t offset = dataReader.Offset();</a>
<a name="ln280">						ReadEncodedAddress(dataReader, NULL, NULL, true);</a>
<a name="ln281">						fAddressEncoding = tempEncoding;</a>
<a name="ln282">						remaining -= dataReader.Offset() - offset + 1;</a>
<a name="ln283"> 						break;</a>
<a name="ln284">					}</a>
<a name="ln285">					case 'R':</a>
<a name="ln286">						fFlags |= CFI_AUGMENTATION_ADDRESS_POINTER_FORMAT;</a>
<a name="ln287">						fAddressEncoding = dataReader.Read&lt;char&gt;(0);</a>
<a name="ln288">						--remaining;</a>
<a name="ln289">						break;</a>
<a name="ln290">					default:</a>
<a name="ln291">						WARNING(&quot;Encountered unsupported augmentation '%c' &quot;</a>
<a name="ln292">							&quot; while parsing CIE augmentation string %s\n&quot;,</a>
<a name="ln293">							*string, fString);</a>
<a name="ln294">						return B_UNSUPPORTED;</a>
<a name="ln295">				}</a>
<a name="ln296">				string++;</a>
<a name="ln297">			}</a>
<a name="ln298"> </a>
<a name="ln299">			// we should have read through all of the augmentation data</a>
<a name="ln300">			// at this point, if not, something is wrong.</a>
<a name="ln301">			if (remaining != 0 || dataReader.HasOverflow()) {</a>
<a name="ln302">				WARNING(&quot;Error while reading CIE Augmentation, expected &quot;</a>
<a name="ln303">					&quot;%&quot; B_PRIu64 &quot; bytes of augmentation data, but read &quot;</a>
<a name="ln304">					&quot;%&quot; B_PRIu64 &quot; bytes.\n&quot;, length, length - remaining);</a>
<a name="ln305">				return B_BAD_DATA;</a>
<a name="ln306">			}</a>
<a name="ln307"> </a>
<a name="ln308">			return B_OK;</a>
<a name="ln309">		}</a>
<a name="ln310"> </a>
<a name="ln311">		// nothing to do</a>
<a name="ln312">		if (strcmp(fString, &quot;eh&quot;) == 0)</a>
<a name="ln313">			return B_OK;</a>
<a name="ln314"> </a>
<a name="ln315">		// something we can't handle</a>
<a name="ln316">		return B_UNSUPPORTED;</a>
<a name="ln317">	}</a>
<a name="ln318"> </a>
<a name="ln319">	status_t ReadFDEData(DataReader&amp; dataReader,</a>
<a name="ln320">		FDEAugmentation&amp; fdeAugmentation)</a>
<a name="ln321">	{</a>
<a name="ln322">		if (!HasData())</a>
<a name="ln323">			return B_OK;</a>
<a name="ln324"> </a>
<a name="ln325">		// read the augmentation data block -- it is preceeded by an LEB128</a>
<a name="ln326">		// indicating the length of the data block</a>
<a name="ln327">		uint64 length = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln328">		dataReader.Skip(length);</a>
<a name="ln329">			// TODO: Actually read what is interesting for us!</a>
<a name="ln330"> </a>
<a name="ln331">		TRACE_CFI(&quot;    %&quot; B_PRIu64 &quot; bytes of augmentation data\n&quot;, length);</a>
<a name="ln332"> </a>
<a name="ln333">		if (dataReader.HasOverflow())</a>
<a name="ln334">			return B_BAD_DATA;</a>
<a name="ln335"> </a>
<a name="ln336">		return B_OK;</a>
<a name="ln337">	}</a>
<a name="ln338"> </a>
<a name="ln339">	const char* String() const</a>
<a name="ln340">	{</a>
<a name="ln341">		return fString;</a>
<a name="ln342">	}</a>
<a name="ln343"> </a>
<a name="ln344">	bool HasData() const</a>
<a name="ln345">	{</a>
<a name="ln346">		return (fFlags &amp; CFI_AUGMENTATION_DATA) != 0;</a>
<a name="ln347">	}</a>
<a name="ln348"> </a>
<a name="ln349">	bool HasFDEAddressFormat() const</a>
<a name="ln350">	{</a>
<a name="ln351">		return (fFlags &amp; CFI_AUGMENTATION_ADDRESS_POINTER_FORMAT) != 0;</a>
<a name="ln352">	}</a>
<a name="ln353"> </a>
<a name="ln354">	target_addr_t FDEAddressOffset(ElfFile* file,</a>
<a name="ln355">		ElfSection* debugFrameSection) const</a>
<a name="ln356">	{</a>
<a name="ln357">		switch (FDEAddressType()) {</a>
<a name="ln358">			case CFI_ADDRESS_FORMAT_ABSOLUTE:</a>
<a name="ln359">				TRACE_CFI(&quot;FDE address format: absolute, &quot;);</a>
<a name="ln360">				return 0;</a>
<a name="ln361">			case CFI_ADDRESS_TYPE_PC_RELATIVE:</a>
<a name="ln362">				TRACE_CFI(&quot;FDE address format: PC relative, &quot;);</a>
<a name="ln363">				return debugFrameSection-&gt;LoadAddress();</a>
<a name="ln364">			case CFI_ADDRESS_TYPE_FUNCTION_RELATIVE:</a>
<a name="ln365">				TRACE_CFI(&quot;FDE address format: function relative, &quot;);</a>
<a name="ln366">				return 0;</a>
<a name="ln367">			case CFI_ADDRESS_TYPE_TEXT_RELATIVE:</a>
<a name="ln368">				TRACE_CFI(&quot;FDE address format: text relative, &quot;);</a>
<a name="ln369">				return file-&gt;TextSegment()-&gt;LoadAddress();</a>
<a name="ln370">			case CFI_ADDRESS_TYPE_DATA_RELATIVE:</a>
<a name="ln371">				TRACE_CFI(&quot;FDE address format: data relative, &quot;);</a>
<a name="ln372">				return file-&gt;DataSegment()-&gt;LoadAddress();</a>
<a name="ln373">			case CFI_ADDRESS_TYPE_ALIGNED:</a>
<a name="ln374">			case CFI_ADDRESS_TYPE_INDIRECT:</a>
<a name="ln375">				TRACE_CFI(&quot;FDE address format: UNIMPLEMENTED, &quot;);</a>
<a name="ln376">				// TODO: implement</a>
<a name="ln377">				// -- note: type indirect is currently not generated</a>
<a name="ln378">				return 0;</a>
<a name="ln379">		}</a>
<a name="ln380"> </a>
<a name="ln381">		return 0;</a>
<a name="ln382">	}</a>
<a name="ln383"> </a>
<a name="ln384">	uint8 FDEAddressType() const</a>
<a name="ln385">	{</a>
<a name="ln386">		return fAddressEncoding &amp; 0x70;</a>
<a name="ln387">	}</a>
<a name="ln388"> </a>
<a name="ln389">	target_addr_t ReadEncodedAddress(DataReader &amp;reader,</a>
<a name="ln390">		ElfFile* file, ElfSection* debugFrameSection,</a>
<a name="ln391">		bool valueOnly = false) const</a>
<a name="ln392">	{</a>
<a name="ln393">		target_addr_t address = valueOnly ? 0 : FDEAddressOffset(file,</a>
<a name="ln394">			debugFrameSection);</a>
<a name="ln395">		switch (fAddressEncoding &amp; 0x0f) {</a>
<a name="ln396">			case CFI_ADDRESS_FORMAT_ABSOLUTE:</a>
<a name="ln397">				address += reader.ReadAddress(0);</a>
<a name="ln398">				TRACE_CFI(&quot; target address: %&quot; B_PRId64 &quot;\n&quot;, address);</a>
<a name="ln399">				break;</a>
<a name="ln400">			case CFI_ADDRESS_FORMAT_UNSIGNED_LEB128:</a>
<a name="ln401">				address += reader.ReadUnsignedLEB128(0);</a>
<a name="ln402">				TRACE_CFI(&quot; unsigned LEB128: %&quot; B_PRId64 &quot;\n&quot;, address);</a>
<a name="ln403">				break;</a>
<a name="ln404">			case CFI_ADDRESS_FORMAT_SIGNED_LEB128:</a>
<a name="ln405">				address += reader.ReadSignedLEB128(0);</a>
<a name="ln406">				TRACE_CFI(&quot; signed LEB128: %&quot; B_PRId64 &quot;\n&quot;, address);</a>
<a name="ln407">				break;</a>
<a name="ln408">			case CFI_ADDRESS_FORMAT_UNSIGNED_16:</a>
<a name="ln409">				address += reader.Read&lt;uint16&gt;(0);</a>
<a name="ln410">				TRACE_CFI(&quot; unsigned 16-bit: %&quot; B_PRId64 &quot;\n&quot;, address);</a>
<a name="ln411">				break;</a>
<a name="ln412">			case CFI_ADDRESS_FORMAT_SIGNED_16:</a>
<a name="ln413">				address += reader.Read&lt;int16&gt;(0);</a>
<a name="ln414">				TRACE_CFI(&quot; signed 16-bit: %&quot; B_PRId64 &quot;\n&quot;, address);</a>
<a name="ln415">				break;</a>
<a name="ln416">			case CFI_ADDRESS_FORMAT_UNSIGNED_32:</a>
<a name="ln417">				address += reader.Read&lt;uint32&gt;(0);</a>
<a name="ln418">				TRACE_CFI(&quot; unsigned 32-bit: %&quot; B_PRId64 &quot;\n&quot;, address);</a>
<a name="ln419">				break;</a>
<a name="ln420">			case CFI_ADDRESS_FORMAT_SIGNED_32:</a>
<a name="ln421">				address += reader.Read&lt;int32&gt;(0);</a>
<a name="ln422">				TRACE_CFI(&quot; signed 32-bit: %&quot; B_PRId64 &quot;\n&quot;, address);</a>
<a name="ln423">				break;</a>
<a name="ln424">			case CFI_ADDRESS_FORMAT_UNSIGNED_64:</a>
<a name="ln425">				address += reader.Read&lt;uint64&gt;(0);</a>
<a name="ln426">				TRACE_CFI(&quot; unsigned 64-bit: %&quot; B_PRId64 &quot;\n&quot;, address);</a>
<a name="ln427">				break;</a>
<a name="ln428">			case CFI_ADDRESS_FORMAT_SIGNED_64:</a>
<a name="ln429">				address += reader.Read&lt;int64&gt;(0);</a>
<a name="ln430">				TRACE_CFI(&quot; signed 64-bit: %&quot; B_PRId64 &quot;\n&quot;, address);</a>
<a name="ln431">				break;</a>
<a name="ln432">		}</a>
<a name="ln433"> </a>
<a name="ln434">		return address;</a>
<a name="ln435">	}</a>
<a name="ln436"> </a>
<a name="ln437"> </a>
<a name="ln438">private:</a>
<a name="ln439">	const char*	fString;</a>
<a name="ln440">	uint32		fFlags;</a>
<a name="ln441">	int8		fAddressEncoding;</a>
<a name="ln442">};</a>
<a name="ln443"> </a>
<a name="ln444"> </a>
<a name="ln445">// #pragma mark - FDELookupInfo</a>
<a name="ln446"> </a>
<a name="ln447"> </a>
<a name="ln448">struct DwarfFile::FDELookupInfo {</a>
<a name="ln449">public:</a>
<a name="ln450">	FDELookupInfo(target_addr_t start, target_addr_t end,</a>
<a name="ln451">		uint64 fdeOffset, uint64 cieOffset, bool ehFrame)</a>
<a name="ln452">	:</a>
<a name="ln453">	start(start),</a>
<a name="ln454">	end(end),</a>
<a name="ln455">	fdeOffset(fdeOffset),</a>
<a name="ln456">	cieOffset(cieOffset),</a>
<a name="ln457">	ehFrame(ehFrame)</a>
<a name="ln458">	{</a>
<a name="ln459">	}</a>
<a name="ln460"> </a>
<a name="ln461">	static int CompareFDEInfos(const FDELookupInfo* a, const FDELookupInfo* b)</a>
<a name="ln462">	{</a>
<a name="ln463">		if (a-&gt;start &lt; b-&gt;start)</a>
<a name="ln464">			return -1;</a>
<a name="ln465">		else if (a-&gt;start &gt; b-&gt;start)</a>
<a name="ln466">			return 1;</a>
<a name="ln467"> </a>
<a name="ln468">		return 0;</a>
<a name="ln469">	}</a>
<a name="ln470"> </a>
<a name="ln471">	inline bool ContainsAddress(target_addr_t address) const</a>
<a name="ln472">	{</a>
<a name="ln473">		return address &gt;= start &amp;&amp; address &lt; end;</a>
<a name="ln474">	}</a>
<a name="ln475"> </a>
<a name="ln476">	target_addr_t 		start;</a>
<a name="ln477">	target_addr_t 		end;</a>
<a name="ln478">	uint64				fdeOffset;</a>
<a name="ln479">	uint64				cieOffset;</a>
<a name="ln480">	bool				ehFrame;</a>
<a name="ln481">};</a>
<a name="ln482"> </a>
<a name="ln483"> </a>
<a name="ln484">// #pragma mark - DwarfFile</a>
<a name="ln485"> </a>
<a name="ln486"> </a>
<a name="ln487">DwarfFile::DwarfFile()</a>
<a name="ln488">	:</a>
<a name="ln489">	fName(NULL),</a>
<a name="ln490">	fAlternateName(NULL),</a>
<a name="ln491">	fElfFile(NULL),</a>
<a name="ln492">	fAlternateElfFile(NULL),</a>
<a name="ln493">	fDebugInfoSection(NULL),</a>
<a name="ln494">	fDebugAbbrevSection(NULL),</a>
<a name="ln495">	fDebugStringSection(NULL),</a>
<a name="ln496">	fDebugRangesSection(NULL),</a>
<a name="ln497">	fDebugLineSection(NULL),</a>
<a name="ln498">	fDebugFrameSection(NULL),</a>
<a name="ln499">	fEHFrameSection(NULL),</a>
<a name="ln500">	fDebugLocationSection(NULL),</a>
<a name="ln501">	fDebugPublicTypesSection(NULL),</a>
<a name="ln502">	fDebugTypesSection(NULL),</a>
<a name="ln503">	fCompilationUnits(20, true),</a>
<a name="ln504">	fTypeUnits(),</a>
<a name="ln505">	fDebugFrameInfos(100, true),</a>
<a name="ln506">	fEHFrameInfos(100, true),</a>
<a name="ln507">	fTypesSectionRequired(false),</a>
<a name="ln508">	fFinished(false),</a>
<a name="ln509">	fItaniumEHFrameFormat(false),</a>
<a name="ln510">	fFinishError(B_OK)</a>
<a name="ln511">{</a>
<a name="ln512">}</a>
<a name="ln513"> </a>
<a name="ln514"> </a>
<a name="ln515">DwarfFile::~DwarfFile()</a>
<a name="ln516">{</a>
<a name="ln517">	while (AbbreviationTable* table = fAbbreviationTables.RemoveHead())</a>
<a name="ln518">		delete table;</a>
<a name="ln519"> </a>
<a name="ln520">	if (fElfFile != NULL) {</a>
<a name="ln521">		ElfFile* debugInfoFile = fAlternateElfFile != NULL</a>
<a name="ln522">			? fAlternateElfFile : fElfFile;</a>
<a name="ln523"> </a>
<a name="ln524">		debugInfoFile-&gt;PutSection(fDebugInfoSection);</a>
<a name="ln525">		debugInfoFile-&gt;PutSection(fDebugAbbrevSection);</a>
<a name="ln526">		debugInfoFile-&gt;PutSection(fDebugStringSection);</a>
<a name="ln527">		debugInfoFile-&gt;PutSection(fDebugRangesSection);</a>
<a name="ln528">		debugInfoFile-&gt;PutSection(fDebugLineSection);</a>
<a name="ln529">		debugInfoFile-&gt;PutSection(fDebugFrameSection);</a>
<a name="ln530">		fElfFile-&gt;PutSection(fEHFrameSection);</a>
<a name="ln531">		debugInfoFile-&gt;PutSection(fDebugLocationSection);</a>
<a name="ln532">		debugInfoFile-&gt;PutSection(fDebugPublicTypesSection);</a>
<a name="ln533">		delete fElfFile;</a>
<a name="ln534">		delete fAlternateElfFile;</a>
<a name="ln535">	}</a>
<a name="ln536"> </a>
<a name="ln537">	TypeUnitTableEntry* entry = fTypeUnits.Clear(true);</a>
<a name="ln538">	while (entry != NULL) {</a>
<a name="ln539">		TypeUnitTableEntry* nextEntry = entry-&gt;next;</a>
<a name="ln540">		delete entry;</a>
<a name="ln541">		entry = nextEntry;</a>
<a name="ln542">	}</a>
<a name="ln543"> </a>
<a name="ln544">	free(fName);</a>
<a name="ln545">	free(fAlternateName);</a>
<a name="ln546">}</a>
<a name="ln547"> </a>
<a name="ln548"> </a>
<a name="ln549">status_t</a>
<a name="ln550">DwarfFile::StartLoading(const char* fileName, BString&amp; _requiredExternalFile)</a>
<a name="ln551">{</a>
<a name="ln552">	fName = strdup(fileName);</a>
<a name="ln553">	if (fName == NULL)</a>
<a name="ln554">		return B_NO_MEMORY;</a>
<a name="ln555"> </a>
<a name="ln556">	status_t error = fTypeUnits.Init();</a>
<a name="ln557">	if (error != B_OK)</a>
<a name="ln558">		return error;</a>
<a name="ln559"> </a>
<a name="ln560">	// load the ELF file</a>
<a name="ln561">	fElfFile = new(std::nothrow) ElfFile;</a>
<a name="ln562">	if (fElfFile == NULL)</a>
<a name="ln563">		return B_NO_MEMORY;</a>
<a name="ln564"> </a>
<a name="ln565">	error = fElfFile-&gt;Init(fileName);</a>
<a name="ln566">	if (error != B_OK)</a>
<a name="ln567">		return error;</a>
<a name="ln568"> </a>
<a name="ln569">	return _LocateDebugInfo(_requiredExternalFile);</a>
<a name="ln570">}</a>
<a name="ln571"> </a>
<a name="ln572"> </a>
<a name="ln573">status_t</a>
<a name="ln574">DwarfFile::Load(uint8 addressSize, const BString&amp; externalInfoFilePath)</a>
<a name="ln575">{</a>
<a name="ln576">	status_t error = B_OK;</a>
<a name="ln577">	if (fDebugInfoSection == NULL) {</a>
<a name="ln578">		BString path;</a>
<a name="ln579">		error = _LocateDebugInfo(path, externalInfoFilePath.IsEmpty()</a>
<a name="ln580">				? NULL : externalInfoFilePath.String());</a>
<a name="ln581">		if (error != B_OK)</a>
<a name="ln582">			return error;</a>
<a name="ln583">	}</a>
<a name="ln584"> </a>
<a name="ln585">	ElfFile* debugInfoFile = fAlternateElfFile != NULL</a>
<a name="ln586">		? fAlternateElfFile : fElfFile;</a>
<a name="ln587"> </a>
<a name="ln588">	// non mandatory sections</a>
<a name="ln589">	fDebugStringSection = debugInfoFile-&gt;GetSection(&quot;.debug_str&quot;);</a>
<a name="ln590">	fDebugRangesSection = debugInfoFile-&gt;GetSection(&quot;.debug_ranges&quot;);</a>
<a name="ln591">	fDebugLineSection = debugInfoFile-&gt;GetSection(&quot;.debug_line&quot;);</a>
<a name="ln592">	fDebugFrameSection = debugInfoFile-&gt;GetSection(&quot;.debug_frame&quot;);</a>
<a name="ln593"> </a>
<a name="ln594">	if (fDebugFrameSection != NULL) {</a>
<a name="ln595">		error = _ParseFrameSection(fDebugFrameSection, addressSize, false,</a>
<a name="ln596">			fDebugFrameInfos);</a>
<a name="ln597">		if (error != B_OK)</a>
<a name="ln598">			return error;</a>
<a name="ln599">	}</a>
<a name="ln600"> </a>
<a name="ln601">	// .eh_frame doesn't appear to get copied into separate debug</a>
<a name="ln602">	// info files properly, therefore always use it off the main</a>
<a name="ln603">	// executable image</a>
<a name="ln604">	if (fEHFrameSection == NULL)</a>
<a name="ln605">		fEHFrameSection = fElfFile-&gt;GetSection(&quot;.eh_frame&quot;);</a>
<a name="ln606"> </a>
<a name="ln607">	if (fEHFrameSection != NULL) {</a>
<a name="ln608">		error = _ParseFrameSection(fEHFrameSection, addressSize, true,</a>
<a name="ln609">			fEHFrameInfos);</a>
<a name="ln610">		if (error != B_OK)</a>
<a name="ln611">			return error;</a>
<a name="ln612">	}</a>
<a name="ln613"> </a>
<a name="ln614">	fDebugLocationSection = debugInfoFile-&gt;GetSection(&quot;.debug_loc&quot;);</a>
<a name="ln615">	fDebugPublicTypesSection = debugInfoFile-&gt;GetSection(&quot;.debug_pubtypes&quot;);</a>
<a name="ln616"> </a>
<a name="ln617">	if (fDebugInfoSection == NULL) {</a>
<a name="ln618">		fFinished = true;</a>
<a name="ln619">		return B_OK;</a>
<a name="ln620">	}</a>
<a name="ln621"> </a>
<a name="ln622">	error = _ParseDebugInfoSection();</a>
<a name="ln623">	if (error != B_OK)</a>
<a name="ln624">		return error;</a>
<a name="ln625"> </a>
<a name="ln626">	if (fTypesSectionRequired) {</a>
<a name="ln627">		fDebugTypesSection = debugInfoFile-&gt;GetSection(&quot;.debug_types&quot;);</a>
<a name="ln628">		if (fDebugTypesSection == NULL) {</a>
<a name="ln629">			WARNING(&quot;.debug_types section required but missing.\n&quot;);</a>
<a name="ln630">			return B_BAD_DATA;</a>
<a name="ln631">		}</a>
<a name="ln632">		error = _ParseTypesSection();</a>
<a name="ln633">		if (error != B_OK)</a>
<a name="ln634">			return error;</a>
<a name="ln635">	}</a>
<a name="ln636"> </a>
<a name="ln637">	return B_OK;</a>
<a name="ln638">}</a>
<a name="ln639"> </a>
<a name="ln640"> </a>
<a name="ln641">status_t</a>
<a name="ln642">DwarfFile::FinishLoading()</a>
<a name="ln643">{</a>
<a name="ln644">	if (fFinished)</a>
<a name="ln645">		return B_OK;</a>
<a name="ln646">	if (fFinishError != B_OK)</a>
<a name="ln647">		return fFinishError;</a>
<a name="ln648"> </a>
<a name="ln649">	status_t error;</a>
<a name="ln650">	for (TypeUnitTable::Iterator it = fTypeUnits.GetIterator();</a>
<a name="ln651">		TypeUnitTableEntry* entry = it.Next();) {</a>
<a name="ln652">		error = _FinishUnit(entry-&gt;unit);</a>
<a name="ln653">		if (error != B_OK)</a>
<a name="ln654">			return fFinishError = error;</a>
<a name="ln655">	}</a>
<a name="ln656"> </a>
<a name="ln657">	for (int32 i = 0; CompilationUnit* unit = fCompilationUnits.ItemAt(i);</a>
<a name="ln658">			i++) {</a>
<a name="ln659">		error = _FinishUnit(unit);</a>
<a name="ln660">		if (error != B_OK)</a>
<a name="ln661">			return fFinishError = error;</a>
<a name="ln662">	}</a>
<a name="ln663"> </a>
<a name="ln664">	_ParsePublicTypesInfo();</a>
<a name="ln665"> </a>
<a name="ln666">	fFinished = true;</a>
<a name="ln667">	return B_OK;</a>
<a name="ln668">}</a>
<a name="ln669"> </a>
<a name="ln670"> </a>
<a name="ln671">int32</a>
<a name="ln672">DwarfFile::CountCompilationUnits() const</a>
<a name="ln673">{</a>
<a name="ln674">	return fCompilationUnits.CountItems();</a>
<a name="ln675">}</a>
<a name="ln676"> </a>
<a name="ln677"> </a>
<a name="ln678">CompilationUnit*</a>
<a name="ln679">DwarfFile::CompilationUnitAt(int32 index) const</a>
<a name="ln680">{</a>
<a name="ln681">	return fCompilationUnits.ItemAt(index);</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684"> </a>
<a name="ln685">CompilationUnit*</a>
<a name="ln686">DwarfFile::CompilationUnitForDIE(const DebugInfoEntry* entry) const</a>
<a name="ln687">{</a>
<a name="ln688">	// find the root of the tree the entry lives in</a>
<a name="ln689">	while (entry != NULL &amp;&amp; entry-&gt;Parent() != NULL)</a>
<a name="ln690">		entry = entry-&gt;Parent();</a>
<a name="ln691"> </a>
<a name="ln692">	// that should be the compilation unit entry</a>
<a name="ln693">	const DIECompileUnitBase* unitEntry</a>
<a name="ln694">		= dynamic_cast&lt;const DIECompileUnitBase*&gt;(entry);</a>
<a name="ln695">	if (unitEntry == NULL)</a>
<a name="ln696">		return NULL;</a>
<a name="ln697"> </a>
<a name="ln698">	// find the compilation unit</a>
<a name="ln699">	for (int32 i = 0; CompilationUnit* unit = fCompilationUnits.ItemAt(i);</a>
<a name="ln700">			i++) {</a>
<a name="ln701">		if (unit-&gt;UnitEntry() == unitEntry)</a>
<a name="ln702">			return unit;</a>
<a name="ln703">	}</a>
<a name="ln704"> </a>
<a name="ln705">	return NULL;</a>
<a name="ln706">}</a>
<a name="ln707"> </a>
<a name="ln708"> </a>
<a name="ln709">TargetAddressRangeList*</a>
<a name="ln710">DwarfFile::ResolveRangeList(CompilationUnit* unit, uint64 offset) const</a>
<a name="ln711">{</a>
<a name="ln712">	if (unit == NULL || fDebugRangesSection == NULL)</a>
<a name="ln713">		return NULL;</a>
<a name="ln714"> </a>
<a name="ln715">	if (offset &gt;= (uint64)fDebugRangesSection-&gt;Size())</a>
<a name="ln716">		return NULL;</a>
<a name="ln717"> </a>
<a name="ln718">	TargetAddressRangeList* ranges = new(std::nothrow) TargetAddressRangeList;</a>
<a name="ln719">	if (ranges == NULL) {</a>
<a name="ln720">		ERROR(&quot;Out of memory.\n&quot;);</a>
<a name="ln721">		return NULL;</a>
<a name="ln722">	}</a>
<a name="ln723">	BReference&lt;TargetAddressRangeList&gt; rangesReference(ranges, true);</a>
<a name="ln724"> </a>
<a name="ln725">	target_addr_t baseAddress = unit-&gt;AddressRangeBase();</a>
<a name="ln726">	target_addr_t maxAddress = unit-&gt;MaxAddress();</a>
<a name="ln727"> </a>
<a name="ln728">	DataReader dataReader((uint8*)fDebugRangesSection-&gt;Data() + offset,</a>
<a name="ln729">		fDebugRangesSection-&gt;Size() - offset, unit-&gt;AddressSize());</a>
<a name="ln730">	while (true) {</a>
<a name="ln731">		target_addr_t start = dataReader.ReadAddress(0);</a>
<a name="ln732">		target_addr_t end = dataReader.ReadAddress(0);</a>
<a name="ln733">		if (dataReader.HasOverflow())</a>
<a name="ln734">			return NULL;</a>
<a name="ln735"> </a>
<a name="ln736">		if (start == 0 &amp;&amp; end == 0)</a>
<a name="ln737">			break;</a>
<a name="ln738">		if (start == maxAddress) {</a>
<a name="ln739">			baseAddress = end;</a>
<a name="ln740">			continue;</a>
<a name="ln741">		}</a>
<a name="ln742">		if (start == end)</a>
<a name="ln743">			continue;</a>
<a name="ln744"> </a>
<a name="ln745">		if (!ranges-&gt;AddRange(baseAddress + start, end - start)) {</a>
<a name="ln746">			ERROR(&quot;Out of memory.\n&quot;);</a>
<a name="ln747">			return NULL;</a>
<a name="ln748">		}</a>
<a name="ln749">	}</a>
<a name="ln750"> </a>
<a name="ln751">	return rangesReference.Detach();</a>
<a name="ln752">}</a>
<a name="ln753"> </a>
<a name="ln754"> </a>
<a name="ln755">status_t</a>
<a name="ln756">DwarfFile::UnwindCallFrame(CompilationUnit* unit, uint8 addressSize,</a>
<a name="ln757">	DIESubprogram* subprogramEntry, target_addr_t location,</a>
<a name="ln758">	const DwarfTargetInterface* inputInterface,</a>
<a name="ln759">	DwarfTargetInterface* outputInterface, target_addr_t&amp; _framePointer)</a>
<a name="ln760">{</a>
<a name="ln761">	FDELookupInfo* info = _GetContainingFDEInfo(location);</a>
<a name="ln762">	if (info == NULL)</a>
<a name="ln763">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln764"> </a>
<a name="ln765">	return _UnwindCallFrame(unit, addressSize, subprogramEntry, location, info,</a>
<a name="ln766">		inputInterface, outputInterface, _framePointer);</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769"> </a>
<a name="ln770">status_t</a>
<a name="ln771">DwarfFile::EvaluateExpression(CompilationUnit* unit, uint8 addressSize,</a>
<a name="ln772">	DIESubprogram* subprogramEntry, const void* expression,</a>
<a name="ln773">	off_t expressionLength, const DwarfTargetInterface* targetInterface,</a>
<a name="ln774">	target_addr_t instructionPointer, target_addr_t framePointer,</a>
<a name="ln775">	target_addr_t valueToPush, bool pushValue, target_addr_t&amp; _result)</a>
<a name="ln776">{</a>
<a name="ln777">	ExpressionEvaluationContext context(this, unit, addressSize,</a>
<a name="ln778">		subprogramEntry, targetInterface, instructionPointer, 0, false,</a>
<a name="ln779">		framePointer, 0);</a>
<a name="ln780">	DwarfExpressionEvaluator evaluator(&amp;context);</a>
<a name="ln781"> </a>
<a name="ln782">	if (pushValue &amp;&amp; evaluator.Push(valueToPush) != B_OK)</a>
<a name="ln783">		return B_NO_MEMORY;</a>
<a name="ln784"> </a>
<a name="ln785">	return evaluator.Evaluate(expression, expressionLength, _result);</a>
<a name="ln786">}</a>
<a name="ln787"> </a>
<a name="ln788"> </a>
<a name="ln789">status_t</a>
<a name="ln790">DwarfFile::ResolveLocation(CompilationUnit* unit, uint8 addressSize,</a>
<a name="ln791">	DIESubprogram* subprogramEntry, const LocationDescription* location,</a>
<a name="ln792">	const DwarfTargetInterface* targetInterface,</a>
<a name="ln793">	target_addr_t instructionPointer, target_addr_t objectPointer,</a>
<a name="ln794">	bool hasObjectPointer, target_addr_t framePointer,</a>
<a name="ln795">	target_addr_t relocationDelta, ValueLocation&amp; _result)</a>
<a name="ln796">{</a>
<a name="ln797">	// get the expression</a>
<a name="ln798">	const void* expression;</a>
<a name="ln799">	off_t expressionLength;</a>
<a name="ln800">	status_t error = _GetLocationExpression(unit, location, instructionPointer,</a>
<a name="ln801">		expression, expressionLength);</a>
<a name="ln802">	if (error != B_OK)</a>
<a name="ln803">		return error;</a>
<a name="ln804"> </a>
<a name="ln805">	// evaluate it</a>
<a name="ln806">	ExpressionEvaluationContext context(this, unit, addressSize,</a>
<a name="ln807">		subprogramEntry, targetInterface, instructionPointer, objectPointer,</a>
<a name="ln808">		hasObjectPointer, framePointer, relocationDelta);</a>
<a name="ln809">	DwarfExpressionEvaluator evaluator(&amp;context);</a>
<a name="ln810">	return evaluator.EvaluateLocation(expression, expressionLength,</a>
<a name="ln811">		_result);</a>
<a name="ln812">}</a>
<a name="ln813"> </a>
<a name="ln814"> </a>
<a name="ln815">status_t</a>
<a name="ln816">DwarfFile::EvaluateConstantValue(CompilationUnit* unit, uint8 addressSize,</a>
<a name="ln817">	DIESubprogram* subprogramEntry, const ConstantAttributeValue* value,</a>
<a name="ln818">	const DwarfTargetInterface* targetInterface,</a>
<a name="ln819">	target_addr_t instructionPointer, target_addr_t framePointer,</a>
<a name="ln820">	BVariant&amp; _result)</a>
<a name="ln821">{</a>
<a name="ln822">	if (!value-&gt;IsValid())</a>
<a name="ln823">		return B_BAD_VALUE;</a>
<a name="ln824"> </a>
<a name="ln825">	switch (value-&gt;attributeClass) {</a>
<a name="ln826">		case ATTRIBUTE_CLASS_CONSTANT:</a>
<a name="ln827">			_result.SetTo(value-&gt;constant);</a>
<a name="ln828">			return B_OK;</a>
<a name="ln829">		case ATTRIBUTE_CLASS_STRING:</a>
<a name="ln830">			_result.SetTo(value-&gt;string);</a>
<a name="ln831">			return B_OK;</a>
<a name="ln832">		case ATTRIBUTE_CLASS_BLOCK:</a>
<a name="ln833">		{</a>
<a name="ln834">			target_addr_t result;</a>
<a name="ln835">			status_t error = EvaluateExpression(unit, addressSize,</a>
<a name="ln836">				subprogramEntry, value-&gt;block.data, value-&gt;block.length,</a>
<a name="ln837">				targetInterface, instructionPointer, framePointer, 0, false,</a>
<a name="ln838">				result);</a>
<a name="ln839">			if (error != B_OK)</a>
<a name="ln840">				return error;</a>
<a name="ln841"> </a>
<a name="ln842">			_result.SetTo(result);</a>
<a name="ln843">			return B_OK;</a>
<a name="ln844">		}</a>
<a name="ln845">		default:</a>
<a name="ln846">			return B_BAD_VALUE;</a>
<a name="ln847">	}</a>
<a name="ln848">}</a>
<a name="ln849"> </a>
<a name="ln850"> </a>
<a name="ln851">status_t</a>
<a name="ln852">DwarfFile::EvaluateDynamicValue(CompilationUnit* unit, uint8 addressSize,</a>
<a name="ln853">	DIESubprogram* subprogramEntry, const DynamicAttributeValue* value,</a>
<a name="ln854">	const DwarfTargetInterface* targetInterface,</a>
<a name="ln855">	target_addr_t instructionPointer, target_addr_t framePointer,</a>
<a name="ln856">	BVariant&amp; _result, DIEType** _type)</a>
<a name="ln857">{</a>
<a name="ln858">	if (!value-&gt;IsValid())</a>
<a name="ln859">		return B_BAD_VALUE;</a>
<a name="ln860"> </a>
<a name="ln861">	DIEType* dummyType;</a>
<a name="ln862">	if (_type == NULL)</a>
<a name="ln863">		_type = &amp;dummyType;</a>
<a name="ln864"> </a>
<a name="ln865">	switch (value-&gt;attributeClass) {</a>
<a name="ln866">		case ATTRIBUTE_CLASS_CONSTANT:</a>
<a name="ln867">			_result.SetTo(value-&gt;constant);</a>
<a name="ln868">			*_type = NULL;</a>
<a name="ln869">			return B_OK;</a>
<a name="ln870"> </a>
<a name="ln871">		case ATTRIBUTE_CLASS_REFERENCE:</a>
<a name="ln872">		{</a>
<a name="ln873">			// TODO: The specs are a bit fuzzy on this one: &quot;the value is a</a>
<a name="ln874">			// reference to another entity whose value is the value of the</a>
<a name="ln875">			// attribute&quot;. Supposedly that also means e.g. if the referenced</a>
<a name="ln876">			// entity is a variable, we should read the value of that variable.</a>
<a name="ln877">			// ATM we only check for the types that can have a DW_AT_const_value</a>
<a name="ln878">			// attribute and evaluate it, if present.</a>
<a name="ln879">			DebugInfoEntry* entry = value-&gt;reference;</a>
<a name="ln880">			if (entry == NULL)</a>
<a name="ln881">				return B_BAD_VALUE;</a>
<a name="ln882"> </a>
<a name="ln883">			const ConstantAttributeValue* constantValue = NULL;</a>
<a name="ln884">			DIEType* type = NULL;</a>
<a name="ln885"> </a>
<a name="ln886">			switch (entry-&gt;Tag()) {</a>
<a name="ln887">				case DW_TAG_constant:</a>
<a name="ln888">				{</a>
<a name="ln889">					DIEConstant* constantEntry</a>
<a name="ln890">						= dynamic_cast&lt;DIEConstant*&gt;(entry);</a>
<a name="ln891">					constantValue = constantEntry-&gt;ConstValue();</a>
<a name="ln892">					type = constantEntry-&gt;GetType();</a>
<a name="ln893">					break;</a>
<a name="ln894">				}</a>
<a name="ln895">				case DW_TAG_enumerator:</a>
<a name="ln896">					constantValue = dynamic_cast&lt;DIEEnumerator*&gt;(entry)</a>
<a name="ln897">						-&gt;ConstValue();</a>
<a name="ln898">					if (DIEEnumerationType* enumerationType</a>
<a name="ln899">							= dynamic_cast&lt;DIEEnumerationType*&gt;(</a>
<a name="ln900">								entry-&gt;Parent())) {</a>
<a name="ln901">						type = enumerationType-&gt;GetType();</a>
<a name="ln902">					}</a>
<a name="ln903">					break;</a>
<a name="ln904">				case DW_TAG_formal_parameter:</a>
<a name="ln905">				{</a>
<a name="ln906">					DIEFormalParameter* parameterEntry</a>
<a name="ln907">						= dynamic_cast&lt;DIEFormalParameter*&gt;(entry);</a>
<a name="ln908">					constantValue = parameterEntry-&gt;ConstValue();</a>
<a name="ln909">					type = parameterEntry-&gt;GetType();</a>
<a name="ln910">					break;</a>
<a name="ln911">				}</a>
<a name="ln912">				case DW_TAG_template_value_parameter:</a>
<a name="ln913">				{</a>
<a name="ln914">					DIETemplateValueParameter* parameterEntry</a>
<a name="ln915">						= dynamic_cast&lt;DIETemplateValueParameter*&gt;(entry);</a>
<a name="ln916">					constantValue = parameterEntry-&gt;ConstValue();</a>
<a name="ln917">					type = parameterEntry-&gt;GetType();</a>
<a name="ln918">					break;</a>
<a name="ln919">				}</a>
<a name="ln920">				case DW_TAG_variable:</a>
<a name="ln921">				{</a>
<a name="ln922">					DIEVariable* variableEntry</a>
<a name="ln923">						= dynamic_cast&lt;DIEVariable*&gt;(entry);</a>
<a name="ln924">					constantValue = variableEntry-&gt;ConstValue();</a>
<a name="ln925">					type = variableEntry-&gt;GetType();</a>
<a name="ln926">					break;</a>
<a name="ln927">				}</a>
<a name="ln928">				default:</a>
<a name="ln929">					return B_BAD_VALUE;</a>
<a name="ln930">			}</a>
<a name="ln931"> </a>
<a name="ln932">			if (constantValue == NULL || !constantValue-&gt;IsValid())</a>
<a name="ln933">				return B_BAD_VALUE;</a>
<a name="ln934"> </a>
<a name="ln935">			status_t error = EvaluateConstantValue(unit, addressSize,</a>
<a name="ln936">				subprogramEntry, constantValue, targetInterface,</a>
<a name="ln937">				instructionPointer, framePointer, _result);</a>
<a name="ln938">			if (error != B_OK)</a>
<a name="ln939">				return error;</a>
<a name="ln940"> </a>
<a name="ln941">			*_type = type;</a>
<a name="ln942">			return B_OK;</a>
<a name="ln943">		}</a>
<a name="ln944"> </a>
<a name="ln945">		case ATTRIBUTE_CLASS_BLOCK:</a>
<a name="ln946">		{</a>
<a name="ln947">			target_addr_t result;</a>
<a name="ln948">			status_t error = EvaluateExpression(unit, addressSize,</a>
<a name="ln949">				subprogramEntry, value-&gt;block.data, value-&gt;block.length,</a>
<a name="ln950">				targetInterface, instructionPointer, framePointer, 0, false,</a>
<a name="ln951">				result);</a>
<a name="ln952">			if (error != B_OK)</a>
<a name="ln953">				return error;</a>
<a name="ln954"> </a>
<a name="ln955">			_result.SetTo(result);</a>
<a name="ln956">			*_type = NULL;</a>
<a name="ln957">			return B_OK;</a>
<a name="ln958">		}</a>
<a name="ln959"> </a>
<a name="ln960">		default:</a>
<a name="ln961">			return B_BAD_VALUE;</a>
<a name="ln962">	}</a>
<a name="ln963">}</a>
<a name="ln964"> </a>
<a name="ln965"> </a>
<a name="ln966">status_t</a>
<a name="ln967">DwarfFile::_ParseDebugInfoSection()</a>
<a name="ln968">{</a>
<a name="ln969">	// iterate through the debug info section</a>
<a name="ln970">	DataReader dataReader(fDebugInfoSection-&gt;Data(),</a>
<a name="ln971">		fDebugInfoSection-&gt;Size(), 4);</a>
<a name="ln972">			// address size doesn't matter here</a>
<a name="ln973">	while (dataReader.HasData()) {</a>
<a name="ln974">		off_t unitHeaderOffset = dataReader.Offset();</a>
<a name="ln975">		bool dwarf64;</a>
<a name="ln976">		uint64 unitLength = dataReader.ReadInitialLength(dwarf64);</a>
<a name="ln977"> </a>
<a name="ln978">		off_t unitLengthOffset = dataReader.Offset();</a>
<a name="ln979">			// the unitLength starts here</a>
<a name="ln980"> </a>
<a name="ln981">		if (unitLengthOffset + unitLength</a>
<a name="ln982">				&gt; (uint64)fDebugInfoSection-&gt;Size()) {</a>
<a name="ln983">			WARNING(&quot;\&quot;%s\&quot;: Invalid compilation unit length.\n&quot;, fName);</a>
<a name="ln984">			break;</a>
<a name="ln985">		}</a>
<a name="ln986"> </a>
<a name="ln987">		int version = dataReader.Read&lt;uint16&gt;(0);</a>
<a name="ln988">		off_t abbrevOffset = dwarf64</a>
<a name="ln989">			? dataReader.Read&lt;uint64&gt;(0)</a>
<a name="ln990">			: dataReader.Read&lt;uint32&gt;(0);</a>
<a name="ln991">		uint8 addressSize = dataReader.Read&lt;uint8&gt;(0);</a>
<a name="ln992"> </a>
<a name="ln993">		if (dataReader.HasOverflow()) {</a>
<a name="ln994">			WARNING(&quot;\&quot;%s\&quot;: Unexpected end of data in compilation unit &quot;</a>
<a name="ln995">				&quot;header.\n&quot;, fName);</a>
<a name="ln996">			break;</a>
<a name="ln997">		}</a>
<a name="ln998"> </a>
<a name="ln999">		TRACE_DIE(&quot;DWARF%d compilation unit: version %d, length: %&quot; B_PRIu64</a>
<a name="ln1000">			&quot;, abbrevOffset: %&quot; B_PRIdOFF &quot;, address size: %d\n&quot;,</a>
<a name="ln1001">			dwarf64 ? 64 : 32, version, unitLength, abbrevOffset, addressSize);</a>
<a name="ln1002"> </a>
<a name="ln1003">		if (version &lt; 2 || version &gt; 4) {</a>
<a name="ln1004">			WARNING(&quot;\&quot;%s\&quot;: Unsupported compilation unit version: %d\n&quot;,</a>
<a name="ln1005">				fName, version);</a>
<a name="ln1006">			break;</a>
<a name="ln1007">		}</a>
<a name="ln1008"> </a>
<a name="ln1009">		if (addressSize != 4 &amp;&amp; addressSize != 8) {</a>
<a name="ln1010">			WARNING(&quot;\&quot;%s\&quot;: Unsupported address size: %d\n&quot;, fName,</a>
<a name="ln1011">				addressSize);</a>
<a name="ln1012">			break;</a>
<a name="ln1013">		}</a>
<a name="ln1014">		dataReader.SetAddressSize(addressSize);</a>
<a name="ln1015"> </a>
<a name="ln1016">		off_t unitContentOffset = dataReader.Offset();</a>
<a name="ln1017"> </a>
<a name="ln1018">		// create a compilation unit object</a>
<a name="ln1019">		CompilationUnit* unit = new(std::nothrow) CompilationUnit(</a>
<a name="ln1020">			unitHeaderOffset, unitContentOffset,</a>
<a name="ln1021">			unitLength + (unitLengthOffset - unitHeaderOffset),</a>
<a name="ln1022">			abbrevOffset, addressSize, dwarf64);</a>
<a name="ln1023">		if (unit == NULL || !fCompilationUnits.AddItem(unit)) {</a>
<a name="ln1024">			delete unit;</a>
<a name="ln1025">			return B_NO_MEMORY;</a>
<a name="ln1026">		}</a>
<a name="ln1027"> </a>
<a name="ln1028">		// parse the debug info for the unit</a>
<a name="ln1029">		status_t error = _ParseCompilationUnit(unit);</a>
<a name="ln1030">		if (error != B_OK)</a>
<a name="ln1031">			return error;</a>
<a name="ln1032"> </a>
<a name="ln1033">		dataReader.SeekAbsolute(unitLengthOffset + unitLength);</a>
<a name="ln1034">	}</a>
<a name="ln1035"> </a>
<a name="ln1036">	return B_OK;</a>
<a name="ln1037">}</a>
<a name="ln1038"> </a>
<a name="ln1039"> </a>
<a name="ln1040">status_t</a>
<a name="ln1041">DwarfFile::_ParseTypesSection()</a>
<a name="ln1042">{</a>
<a name="ln1043">	DataReader dataReader(fDebugTypesSection-&gt;Data(),</a>
<a name="ln1044">		fDebugTypesSection-&gt;Size(), 4);</a>
<a name="ln1045">	while (dataReader.HasData()) {</a>
<a name="ln1046">		off_t unitHeaderOffset = dataReader.Offset();</a>
<a name="ln1047">		bool dwarf64;</a>
<a name="ln1048">		uint64 unitLength = dataReader.ReadInitialLength(dwarf64);</a>
<a name="ln1049"> </a>
<a name="ln1050">		off_t unitLengthOffset = dataReader.Offset();</a>
<a name="ln1051">			// the unitLength starts here</a>
<a name="ln1052"> </a>
<a name="ln1053">		if (unitLengthOffset + unitLength</a>
<a name="ln1054">				&gt; (uint64)fDebugTypesSection-&gt;Size()) {</a>
<a name="ln1055">			WARNING(&quot;Invalid type unit length, offset %#&quot; B_PRIx64 &quot;.\n&quot;,</a>
<a name="ln1056">				unitHeaderOffset);</a>
<a name="ln1057">			break;</a>
<a name="ln1058">		}</a>
<a name="ln1059"> </a>
<a name="ln1060">		int version = dataReader.Read&lt;uint16&gt;(0);</a>
<a name="ln1061">		off_t abbrevOffset = dwarf64</a>
<a name="ln1062">			? dataReader.Read&lt;uint64&gt;(0)</a>
<a name="ln1063">			: dataReader.Read&lt;uint32&gt;(0);</a>
<a name="ln1064">		uint8 addressSize = dataReader.Read&lt;uint8&gt;(0);</a>
<a name="ln1065"> </a>
<a name="ln1066">		if (dataReader.HasOverflow()) {</a>
<a name="ln1067">			WARNING(&quot;Unexpected end of data in type unit header at %#&quot;</a>
<a name="ln1068">				B_PRIx64 &quot;.\n&quot;, unitHeaderOffset);</a>
<a name="ln1069">			break;</a>
<a name="ln1070">		}</a>
<a name="ln1071"> </a>
<a name="ln1072">		dataReader.SetAddressSize(addressSize);</a>
<a name="ln1073"> </a>
<a name="ln1074">		uint64 signature = dataReader.Read&lt;uint64&gt;(0);</a>
<a name="ln1075"> </a>
<a name="ln1076">		off_t typeOffset = dwarf64</a>
<a name="ln1077">			? dataReader.Read&lt;uint64&gt;(0)</a>
<a name="ln1078">			: dataReader.Read&lt;uint32&gt;(0);</a>
<a name="ln1079"> </a>
<a name="ln1080">		off_t unitContentOffset = dataReader.Offset();</a>
<a name="ln1081"> </a>
<a name="ln1082">		TRACE_DIE(&quot;DWARF%d type unit: version %d, length: %&quot; B_PRIu64</a>
<a name="ln1083">			&quot;, abbrevOffset: %&quot; B_PRIdOFF &quot;, address size: %d, &quot;</a>
<a name="ln1084">			&quot;signature: %#&quot; B_PRIx64 &quot;, type offset: %&quot; B_PRIu64 &quot;\n&quot;,</a>
<a name="ln1085">			dwarf64 ? 64 : 32, version, unitLength, abbrevOffset, addressSize,</a>
<a name="ln1086">			signature, typeOffset);</a>
<a name="ln1087"> </a>
<a name="ln1088">		if (version &gt; 4) {</a>
<a name="ln1089">			WARNING(&quot;\&quot;%s\&quot;: Unsupported type unit version: %d\n&quot;,</a>
<a name="ln1090">				fName, version);</a>
<a name="ln1091">			break;</a>
<a name="ln1092">		}</a>
<a name="ln1093"> </a>
<a name="ln1094">		if (addressSize != 4 &amp;&amp; addressSize != 8) {</a>
<a name="ln1095">			WARNING(&quot;\&quot;%s\&quot;: Unsupported address size: %d\n&quot;, fName,</a>
<a name="ln1096">				addressSize);</a>
<a name="ln1097">			break;</a>
<a name="ln1098">		}</a>
<a name="ln1099"> </a>
<a name="ln1100">		// create a type unit object</a>
<a name="ln1101">		TypeUnit* unit = new(std::nothrow) TypeUnit(</a>
<a name="ln1102">			unitHeaderOffset, unitContentOffset,</a>
<a name="ln1103">			unitLength + (unitLengthOffset - unitHeaderOffset),</a>
<a name="ln1104">			abbrevOffset, typeOffset, addressSize, signature, dwarf64);</a>
<a name="ln1105">		if (unit == NULL)</a>
<a name="ln1106">			return B_NO_MEMORY;</a>
<a name="ln1107"> </a>
<a name="ln1108">		// parse the debug info for the unit</a>
<a name="ln1109">		status_t error = _ParseTypeUnit(unit);</a>
<a name="ln1110">		if (error != B_OK)</a>
<a name="ln1111">			return error;</a>
<a name="ln1112"> </a>
<a name="ln1113">		// TODO: it should theoretically never happen that we get a duplicate,</a>
<a name="ln1114">		// but it wouldn't hurt to check since that situation would potentially</a>
<a name="ln1115">		// be problematic.</a>
<a name="ln1116">		if (fTypeUnits.Lookup(signature) == NULL) {</a>
<a name="ln1117">			TypeUnitTableEntry* entry = new(std::nothrow)</a>
<a name="ln1118">				TypeUnitTableEntry(signature, unit);</a>
<a name="ln1119">			if (entry == NULL)</a>
<a name="ln1120">				return B_NO_MEMORY;</a>
<a name="ln1121"> </a>
<a name="ln1122">			fTypeUnits.Insert(entry);</a>
<a name="ln1123">		}</a>
<a name="ln1124"> </a>
<a name="ln1125">		dataReader.SeekAbsolute(unitLengthOffset + unitLength);</a>
<a name="ln1126">	}</a>
<a name="ln1127"> </a>
<a name="ln1128">	return B_OK;</a>
<a name="ln1129">}</a>
<a name="ln1130"> </a>
<a name="ln1131"> </a>
<a name="ln1132">status_t</a>
<a name="ln1133">DwarfFile::_ParseFrameSection(ElfSection* section, uint8 addressSize,</a>
<a name="ln1134">	bool ehFrame, FDEInfoList&amp; infos)</a>
<a name="ln1135">{</a>
<a name="ln1136">	if (ehFrame) {</a>
<a name="ln1137">		fItaniumEHFrameFormat = section-&gt;IsWritable();</a>
<a name="ln1138">			// Crude heuristic for recognizing GCC 4 (Itanium ABI) style</a>
<a name="ln1139">			// .eh_frame sections. The ones generated by GCC 2 are writable,</a>
<a name="ln1140">			// the ones generated by GCC 4 aren't.</a>
<a name="ln1141">	}</a>
<a name="ln1142"> </a>
<a name="ln1143">	DataReader dataReader((uint8*)section-&gt;Data(),</a>
<a name="ln1144">		section-&gt;Size(), addressSize);</a>
<a name="ln1145"> </a>
<a name="ln1146">	while (dataReader.BytesRemaining() &gt; 0) {</a>
<a name="ln1147">		// length</a>
<a name="ln1148">		bool dwarf64;</a>
<a name="ln1149">		off_t entryOffset = dataReader.Offset();</a>
<a name="ln1150">		uint64 length = dataReader.ReadInitialLength(dwarf64);</a>
<a name="ln1151"> </a>
<a name="ln1152">		TRACE_CFI(&quot;DwarfFile::_ParseFrameSection(): offset: %&quot; B_PRIdOFF</a>
<a name="ln1153">			&quot;, length: %&quot; B_PRId64 &quot;\n&quot;, entryOffset, length);</a>
<a name="ln1154"> </a>
<a name="ln1155">		if (length &gt; (uint64)dataReader.BytesRemaining())</a>
<a name="ln1156">			return B_BAD_DATA;</a>
<a name="ln1157">		off_t lengthOffset = dataReader.Offset();</a>
<a name="ln1158"> </a>
<a name="ln1159">		// CIE ID/CIE pointer</a>
<a name="ln1160">		uint64 cieID = dwarf64</a>
<a name="ln1161">			? dataReader.Read&lt;uint64&gt;(0) : dataReader.Read&lt;uint32&gt;(0);</a>
<a name="ln1162"> </a>
<a name="ln1163">		// In .debug_frame ~0 indicates a CIE, in .eh_frame 0 does.</a>
<a name="ln1164">		if (ehFrame</a>
<a name="ln1165">			? cieID == 0</a>
<a name="ln1166">			: (dwarf64</a>
<a name="ln1167">				? cieID == 0xffffffffffffffffULL</a>
<a name="ln1168">				: cieID == 0xffffffff)) {</a>
<a name="ln1169">			// this is a CIE -- skip it</a>
<a name="ln1170">		} else {</a>
<a name="ln1171">			// this is a FDE</a>
<a name="ln1172">			uint64 initialLocationOffset = dataReader.Offset();</a>
<a name="ln1173">			// In .eh_frame the CIE offset is a relative back offset.</a>
<a name="ln1174">			if (ehFrame) {</a>
<a name="ln1175">				if (cieID &gt; (uint64)lengthOffset) {</a>
<a name="ln1176">					TRACE_CFI(&quot;Invalid CIE offset: %&quot; B_PRIu64 &quot;, max &quot;</a>
<a name="ln1177">						&quot;possible: %&quot; B_PRIu64 &quot;\n&quot;, cieID, lengthOffset);</a>
<a name="ln1178">					break;</a>
<a name="ln1179">				}</a>
<a name="ln1180">				// convert to a section relative offset</a>
<a name="ln1181">				cieID = lengthOffset - cieID;</a>
<a name="ln1182">			}</a>
<a name="ln1183"> </a>
<a name="ln1184"> </a>
<a name="ln1185">			CfaContext context;</a>
<a name="ln1186">			CIEAugmentation cieAugmentation;</a>
<a name="ln1187">			// when using .eh_frame format, we need to parse the CIE's</a>
<a name="ln1188">			// augmentation up front in order to know how the FDE's addresses</a>
<a name="ln1189">			//  will be represented</a>
<a name="ln1190">			DataReader cieReader;</a>
<a name="ln1191">			off_t cieRemaining;</a>
<a name="ln1192">			status_t error = _ParseCIEHeader(section, ehFrame, NULL,</a>
<a name="ln1193">				addressSize, context, cieID, cieAugmentation, cieReader,</a>
<a name="ln1194">				cieRemaining);</a>
<a name="ln1195">			if (error != B_OK)</a>
<a name="ln1196">				return error;</a>
<a name="ln1197">			if (cieReader.HasOverflow())</a>
<a name="ln1198">				return B_BAD_DATA;</a>
<a name="ln1199">			if (cieRemaining &lt; 0)</a>
<a name="ln1200">				return B_BAD_DATA;</a>
<a name="ln1201"> </a>
<a name="ln1202">			target_addr_t initialLocation = cieAugmentation.ReadEncodedAddress(</a>
<a name="ln1203">				dataReader, fElfFile, section);</a>
<a name="ln1204">			target_addr_t addressRange = cieAugmentation.ReadEncodedAddress(</a>
<a name="ln1205">				dataReader, fElfFile, section, true);</a>
<a name="ln1206"> </a>
<a name="ln1207">			if (dataReader.HasOverflow())</a>
<a name="ln1208">				return B_BAD_DATA;</a>
<a name="ln1209"> </a>
<a name="ln1210">			if ((cieAugmentation.FDEAddressType()</a>
<a name="ln1211">					&amp; CFI_ADDRESS_TYPE_PC_RELATIVE) != 0) {</a>
<a name="ln1212">				initialLocation += initialLocationOffset;</a>
<a name="ln1213">			}</a>
<a name="ln1214"> </a>
<a name="ln1215">			// for unknown reasons, the debug frame sections generated by gcc</a>
<a name="ln1216">			// sometimes contain duplicates at different offsets within the</a>
<a name="ln1217">			// section. In such a case, simply skip the duplicates.</a>
<a name="ln1218">			FDELookupInfo* temp = _GetContainingFDEInfo(initialLocation,</a>
<a name="ln1219">				infos);</a>
<a name="ln1220">			if (temp == NULL) {</a>
<a name="ln1221">				FDELookupInfo* info = new(std::nothrow)FDELookupInfo(</a>
<a name="ln1222">					initialLocation, initialLocation + addressRange - 1,</a>
<a name="ln1223">					entryOffset, cieID, ehFrame);</a>
<a name="ln1224">				if (info == NULL)</a>
<a name="ln1225">					return B_NO_MEMORY;</a>
<a name="ln1226"> </a>
<a name="ln1227">				ObjectDeleter&lt;FDELookupInfo&gt; infoDeleter(info);</a>
<a name="ln1228">				if (!infos.BinaryInsert(info, FDELookupInfo::CompareFDEInfos))</a>
<a name="ln1229">					return B_NO_MEMORY;</a>
<a name="ln1230"> </a>
<a name="ln1231">				infoDeleter.Detach();</a>
<a name="ln1232">			}</a>
<a name="ln1233">		}</a>
<a name="ln1234"> </a>
<a name="ln1235">		dataReader.SeekAbsolute(lengthOffset + length);</a>
<a name="ln1236">	}</a>
<a name="ln1237"> </a>
<a name="ln1238">	return B_OK;</a>
<a name="ln1239">}</a>
<a name="ln1240"> </a>
<a name="ln1241"> </a>
<a name="ln1242">status_t</a>
<a name="ln1243">DwarfFile::_ParseCompilationUnit(CompilationUnit* unit)</a>
<a name="ln1244">{</a>
<a name="ln1245">	AbbreviationTable* abbreviationTable;</a>
<a name="ln1246">	status_t error = _GetAbbreviationTable(unit-&gt;AbbreviationOffset(),</a>
<a name="ln1247">		abbreviationTable);</a>
<a name="ln1248">	if (error != B_OK)</a>
<a name="ln1249">		return error;</a>
<a name="ln1250"> </a>
<a name="ln1251">	unit-&gt;SetAbbreviationTable(abbreviationTable);</a>
<a name="ln1252"> </a>
<a name="ln1253">	DataReader dataReader(</a>
<a name="ln1254">		(const uint8*)fDebugInfoSection-&gt;Data() + unit-&gt;ContentOffset(),</a>
<a name="ln1255">		unit-&gt;ContentSize(), unit-&gt;AddressSize());</a>
<a name="ln1256"> </a>
<a name="ln1257">	DebugInfoEntry* entry;</a>
<a name="ln1258">	bool endOfEntryList;</a>
<a name="ln1259">	error = _ParseDebugInfoEntry(dataReader, unit, abbreviationTable, entry,</a>
<a name="ln1260">		endOfEntryList);</a>
<a name="ln1261">	if (error != B_OK)</a>
<a name="ln1262">		return error;</a>
<a name="ln1263"> </a>
<a name="ln1264">	DIECompileUnitBase* unitEntry = dynamic_cast&lt;DIECompileUnitBase*&gt;(entry);</a>
<a name="ln1265">	if (unitEntry == NULL) {</a>
<a name="ln1266">		WARNING(&quot;No compilation unit entry in .debug_info section.\n&quot;);</a>
<a name="ln1267">		return B_BAD_DATA;</a>
<a name="ln1268">	}</a>
<a name="ln1269"> </a>
<a name="ln1270">	unit-&gt;SetUnitEntry(unitEntry);</a>
<a name="ln1271"> </a>
<a name="ln1272">	TRACE_DIE_ONLY(</a>
<a name="ln1273">		TRACE_DIE(&quot;remaining bytes in unit: %&quot; B_PRIdOFF &quot;\n&quot;,</a>
<a name="ln1274">			dataReader.BytesRemaining());</a>
<a name="ln1275">		if (dataReader.HasData()) {</a>
<a name="ln1276">			TRACE_DIE(&quot;  &quot;);</a>
<a name="ln1277">			while (dataReader.HasData())</a>
<a name="ln1278">				TRACE_DIE(&quot;%02x&quot;, dataReader.Read&lt;uint8&gt;(0));</a>
<a name="ln1279">			TRACE_DIE(&quot;\n&quot;);</a>
<a name="ln1280">		}</a>
<a name="ln1281">	)</a>
<a name="ln1282">	return B_OK;</a>
<a name="ln1283">}</a>
<a name="ln1284"> </a>
<a name="ln1285"> </a>
<a name="ln1286">status_t</a>
<a name="ln1287">DwarfFile::_ParseTypeUnit(TypeUnit* unit)</a>
<a name="ln1288">{</a>
<a name="ln1289">	AbbreviationTable* abbreviationTable;</a>
<a name="ln1290">	status_t error = _GetAbbreviationTable(unit-&gt;AbbreviationOffset(),</a>
<a name="ln1291">		abbreviationTable);</a>
<a name="ln1292">	if (error != B_OK)</a>
<a name="ln1293">		return error;</a>
<a name="ln1294"> </a>
<a name="ln1295">	unit-&gt;SetAbbreviationTable(abbreviationTable);</a>
<a name="ln1296"> </a>
<a name="ln1297">	DataReader dataReader(</a>
<a name="ln1298">		(const uint8*)fDebugTypesSection-&gt;Data() + unit-&gt;ContentOffset(),</a>
<a name="ln1299">		unit-&gt;ContentSize(), unit-&gt;AddressSize());</a>
<a name="ln1300"> </a>
<a name="ln1301">	DebugInfoEntry* entry;</a>
<a name="ln1302">	bool endOfEntryList;</a>
<a name="ln1303">	error = _ParseDebugInfoEntry(dataReader, unit, abbreviationTable, entry,</a>
<a name="ln1304">		endOfEntryList);</a>
<a name="ln1305">	if (error != B_OK)</a>
<a name="ln1306">		return error;</a>
<a name="ln1307"> </a>
<a name="ln1308">	DIETypeUnit* unitEntry = dynamic_cast&lt;DIETypeUnit*&gt;(entry);</a>
<a name="ln1309">	if (unitEntry == NULL) {</a>
<a name="ln1310">		WARNING(&quot;No type unit entry in .debug_types section.\n&quot;);</a>
<a name="ln1311">		return B_BAD_DATA;</a>
<a name="ln1312">	}</a>
<a name="ln1313"> </a>
<a name="ln1314">	unit-&gt;SetUnitEntry(unitEntry);</a>
<a name="ln1315">	DebugInfoEntry* typeEntry = unit-&gt;EntryForOffset(unit-&gt;TypeOffset());</a>
<a name="ln1316">	if (typeEntry == NULL) {</a>
<a name="ln1317">		WARNING(&quot;No type found for type unit %p at specified offset %&quot;</a>
<a name="ln1318">			B_PRId64 &quot;.\n&quot;, unit, unit-&gt;TypeOffset());</a>
<a name="ln1319">		return B_BAD_DATA;</a>
<a name="ln1320">	}</a>
<a name="ln1321">	unit-&gt;SetTypeEntry(typeEntry);</a>
<a name="ln1322"> </a>
<a name="ln1323">	TRACE_DIE_ONLY(</a>
<a name="ln1324">		TRACE_DIE(&quot;remaining bytes in unit: %&quot; B_PRIdOFF &quot;\n&quot;,</a>
<a name="ln1325">			dataReader.BytesRemaining());</a>
<a name="ln1326">		if (dataReader.HasData()) {</a>
<a name="ln1327">			TRACE_DIE(&quot;  &quot;);</a>
<a name="ln1328">			while (dataReader.HasData())</a>
<a name="ln1329">				TRACE_DIE(&quot;%02x&quot;, dataReader.Read&lt;uint8&gt;(0));</a>
<a name="ln1330">			TRACE_DIE(&quot;\n&quot;);</a>
<a name="ln1331">		}</a>
<a name="ln1332">	)</a>
<a name="ln1333">	return B_OK;</a>
<a name="ln1334">}</a>
<a name="ln1335"> </a>
<a name="ln1336"> </a>
<a name="ln1337">status_t</a>
<a name="ln1338">DwarfFile::_ParseDebugInfoEntry(DataReader&amp; dataReader,</a>
<a name="ln1339">	BaseUnit* unit, AbbreviationTable* abbreviationTable,</a>
<a name="ln1340">	DebugInfoEntry*&amp; _entry, bool&amp; _endOfEntryList, int level)</a>
<a name="ln1341">{</a>
<a name="ln1342">	off_t entryOffset = dataReader.Offset()</a>
<a name="ln1343">		+ unit-&gt;RelativeContentOffset();</a>
<a name="ln1344"> </a>
<a name="ln1345">	uint32 code = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln1346">	if (code == 0) {</a>
<a name="ln1347">		if (dataReader.HasOverflow()) {</a>
<a name="ln1348">			WARNING(&quot;Unexpected end of .debug_info section.\n&quot;);</a>
<a name="ln1349">			return B_BAD_DATA;</a>
<a name="ln1350">		}</a>
<a name="ln1351">		_entry = NULL;</a>
<a name="ln1352">		_endOfEntryList = true;</a>
<a name="ln1353">		return B_OK;</a>
<a name="ln1354">	}</a>
<a name="ln1355"> </a>
<a name="ln1356">	// get the corresponding abbreviation entry</a>
<a name="ln1357">	AbbreviationEntry abbreviationEntry;</a>
<a name="ln1358">	if (!abbreviationTable-&gt;GetAbbreviationEntry(code, abbreviationEntry)) {</a>
<a name="ln1359">		WARNING(&quot;No abbreviation entry for code %&quot; B_PRIx32 &quot;\n&quot;, code);</a>
<a name="ln1360">		return B_BAD_DATA;</a>
<a name="ln1361">	}</a>
<a name="ln1362"> </a>
<a name="ln1363">	DebugInfoEntry* entry;</a>
<a name="ln1364">	status_t error = fDebugInfoFactory.CreateDebugInfoEntry(</a>
<a name="ln1365">		abbreviationEntry.Tag(), entry);</a>
<a name="ln1366">	if (error != B_OK) {</a>
<a name="ln1367">		WARNING(&quot;Failed to generate entry for tag %&quot; B_PRIu32 &quot;, code %&quot;</a>
<a name="ln1368">			B_PRIu32 &quot;\n&quot;, abbreviationEntry.Tag(), code);</a>
<a name="ln1369">		return error;</a>
<a name="ln1370">	}</a>
<a name="ln1371"> </a>
<a name="ln1372">	ObjectDeleter&lt;DebugInfoEntry&gt; entryDeleter(entry);</a>
<a name="ln1373"> </a>
<a name="ln1374">	TRACE_DIE(&quot;%*sentry %p at %&quot; B_PRIdOFF &quot;: %&quot; B_PRIu32 &quot;, tag: %s (%&quot;</a>
<a name="ln1375">		B_PRIu32 &quot;), children: %d\n&quot;, level * 2, &quot;&quot;, entry, entryOffset,</a>
<a name="ln1376">		abbreviationEntry.Code(), get_entry_tag_name(abbreviationEntry.Tag()),</a>
<a name="ln1377">		abbreviationEntry.Tag(), abbreviationEntry.HasChildren());</a>
<a name="ln1378"> </a>
<a name="ln1379">	error = unit-&gt;AddDebugInfoEntry(entry, entryOffset);</a>
<a name="ln1380"> </a>
<a name="ln1381">	if (error != B_OK)</a>
<a name="ln1382">		return error;</a>
<a name="ln1383"> </a>
<a name="ln1384">	// parse the attributes (supply NULL entry to avoid adding them yet)</a>
<a name="ln1385">	error = _ParseEntryAttributes(dataReader, unit, NULL, abbreviationEntry);</a>
<a name="ln1386">	if (error != B_OK)</a>
<a name="ln1387">		return error;</a>
<a name="ln1388"> </a>
<a name="ln1389">	// parse children, if the entry has any</a>
<a name="ln1390">	if (abbreviationEntry.HasChildren()) {</a>
<a name="ln1391">		while (true) {</a>
<a name="ln1392">			DebugInfoEntry* childEntry;</a>
<a name="ln1393">			bool endOfEntryList;</a>
<a name="ln1394">			status_t error = _ParseDebugInfoEntry(dataReader,</a>
<a name="ln1395">				unit, abbreviationTable, childEntry, endOfEntryList, level + 1);</a>
<a name="ln1396">			if (error != B_OK)</a>
<a name="ln1397">				return error;</a>
<a name="ln1398"> </a>
<a name="ln1399">			// add the child to our entry</a>
<a name="ln1400">			if (childEntry != NULL) {</a>
<a name="ln1401">				if (entry != NULL) {</a>
<a name="ln1402">					error = entry-&gt;AddChild(childEntry);</a>
<a name="ln1403">					if (error == B_OK) {</a>
<a name="ln1404">						childEntry-&gt;SetParent(entry);</a>
<a name="ln1405">					} else if (error == ENTRY_NOT_HANDLED) {</a>
<a name="ln1406">						error = B_OK;</a>
<a name="ln1407">						TRACE_DIE(&quot;%*s  -&gt; child unhandled\n&quot;, level * 2, &quot;&quot;);</a>
<a name="ln1408">					}</a>
<a name="ln1409"> </a>
<a name="ln1410">					if (error != B_OK) {</a>
<a name="ln1411">						delete childEntry;</a>
<a name="ln1412">						return error;</a>
<a name="ln1413">					}</a>
<a name="ln1414">				} else</a>
<a name="ln1415">					delete childEntry;</a>
<a name="ln1416">			}</a>
<a name="ln1417"> </a>
<a name="ln1418">			if (endOfEntryList)</a>
<a name="ln1419">				break;</a>
<a name="ln1420">		}</a>
<a name="ln1421">	}</a>
<a name="ln1422"> </a>
<a name="ln1423">	entryDeleter.Detach();</a>
<a name="ln1424">	_entry = entry;</a>
<a name="ln1425">	_endOfEntryList = false;</a>
<a name="ln1426">	return B_OK;</a>
<a name="ln1427">}</a>
<a name="ln1428"> </a>
<a name="ln1429"> </a>
<a name="ln1430">status_t</a>
<a name="ln1431">DwarfFile::_FinishUnit(BaseUnit* unit)</a>
<a name="ln1432">{</a>
<a name="ln1433">	CompilationUnit* compilationUnit = dynamic_cast&lt;CompilationUnit*&gt;(unit);</a>
<a name="ln1434">	bool isTypeUnit = compilationUnit == NULL;</a>
<a name="ln1435">	TRACE_DIE(&quot;\nfinishing %s unit %p\n&quot;,</a>
<a name="ln1436">		isTypeUnit ? &quot;type&quot; : &quot;compilation&quot;, unit);</a>
<a name="ln1437"> </a>
<a name="ln1438"> </a>
<a name="ln1439">	AbbreviationTable* abbreviationTable = unit-&gt;GetAbbreviationTable();</a>
<a name="ln1440"> </a>
<a name="ln1441">	ElfSection* section = isTypeUnit</a>
<a name="ln1442">			? fDebugTypesSection : fDebugInfoSection;</a>
<a name="ln1443">	DataReader dataReader(</a>
<a name="ln1444">		(const uint8*)section-&gt;Data() + unit-&gt;HeaderOffset(),</a>
<a name="ln1445">		unit-&gt;TotalSize(), unit-&gt;AddressSize());</a>
<a name="ln1446"> </a>
<a name="ln1447">	DebugInfoEntryInitInfo entryInitInfo;</a>
<a name="ln1448"> </a>
<a name="ln1449">	int entryCount = unit-&gt;CountEntries();</a>
<a name="ln1450">	for (int i = 0; i &lt; entryCount; i++) {</a>
<a name="ln1451">		// get the entry</a>
<a name="ln1452">		DebugInfoEntry* entry;</a>
<a name="ln1453">		off_t offset;</a>
<a name="ln1454">		unit-&gt;GetEntryAt(i, entry, offset);</a>
<a name="ln1455"> </a>
<a name="ln1456">		TRACE_DIE(&quot;entry %p at %&quot; B_PRIdOFF &quot;\n&quot;, entry, offset);</a>
<a name="ln1457"> </a>
<a name="ln1458">		// seek the reader to the entry</a>
<a name="ln1459">		dataReader.SeekAbsolute(offset);</a>
<a name="ln1460"> </a>
<a name="ln1461">		// read the entry code</a>
<a name="ln1462">		uint32 code = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln1463"> </a>
<a name="ln1464">		// get the respective abbreviation entry</a>
<a name="ln1465">		AbbreviationEntry abbreviationEntry;</a>
<a name="ln1466">		abbreviationTable-&gt;GetAbbreviationEntry(code, abbreviationEntry);</a>
<a name="ln1467"> </a>
<a name="ln1468">		// initialization before setting the attributes</a>
<a name="ln1469">		status_t error = entry-&gt;InitAfterHierarchy(entryInitInfo);</a>
<a name="ln1470">		if (error != B_OK) {</a>
<a name="ln1471">			WARNING(&quot;Init after hierarchy failed!\n&quot;);</a>
<a name="ln1472">			return error;</a>
<a name="ln1473">		}</a>
<a name="ln1474"> </a>
<a name="ln1475">		// parse the attributes -- this time pass the entry, so that the</a>
<a name="ln1476">		// attribute get set on it</a>
<a name="ln1477">		error = _ParseEntryAttributes(dataReader, unit, entry,</a>
<a name="ln1478">			abbreviationEntry);</a>
<a name="ln1479">		if (error != B_OK)</a>
<a name="ln1480">			return error;</a>
<a name="ln1481"> </a>
<a name="ln1482">		// initialization after setting the attributes</a>
<a name="ln1483">		error = entry-&gt;InitAfterAttributes(entryInitInfo);</a>
<a name="ln1484">		if (error != B_OK) {</a>
<a name="ln1485">			WARNING(&quot;Init after attributes failed!\n&quot;);</a>
<a name="ln1486">			return error;</a>
<a name="ln1487">		}</a>
<a name="ln1488">	}</a>
<a name="ln1489"> </a>
<a name="ln1490">	// set the compilation unit's source language</a>
<a name="ln1491">	unit-&gt;SetSourceLanguage(entryInitInfo.languageInfo);</a>
<a name="ln1492"> </a>
<a name="ln1493">	if (isTypeUnit)</a>
<a name="ln1494">		return B_OK;</a>
<a name="ln1495"> </a>
<a name="ln1496">	// resolve the compilation unit's address range list</a>
<a name="ln1497">	if (TargetAddressRangeList* ranges = ResolveRangeList(compilationUnit,</a>
<a name="ln1498">			compilationUnit-&gt;UnitEntry()-&gt;AddressRangesOffset())) {</a>
<a name="ln1499">		compilationUnit-&gt;SetAddressRanges(ranges);</a>
<a name="ln1500">		ranges-&gt;ReleaseReference();</a>
<a name="ln1501">	}</a>
<a name="ln1502"> </a>
<a name="ln1503">	// add compilation dir to directory list</a>
<a name="ln1504">	const char* compilationDir = compilationUnit-&gt;UnitEntry()</a>
<a name="ln1505">		-&gt;CompilationDir();</a>
<a name="ln1506">	if (!compilationUnit-&gt;AddDirectory(compilationDir != NULL</a>
<a name="ln1507">				? compilationDir : &quot;.&quot;)) {</a>
<a name="ln1508">		return B_NO_MEMORY;</a>
<a name="ln1509">	}</a>
<a name="ln1510"> </a>
<a name="ln1511">	// parse line info header</a>
<a name="ln1512">	if (fDebugLineSection != NULL)</a>
<a name="ln1513">		_ParseLineInfo(compilationUnit);</a>
<a name="ln1514"> </a>
<a name="ln1515">	return B_OK;</a>
<a name="ln1516">}</a>
<a name="ln1517"> </a>
<a name="ln1518"> </a>
<a name="ln1519">status_t</a>
<a name="ln1520">DwarfFile::_ParseEntryAttributes(DataReader&amp; dataReader,</a>
<a name="ln1521">	BaseUnit* unit, DebugInfoEntry* entry, AbbreviationEntry&amp; abbreviationEntry)</a>
<a name="ln1522">{</a>
<a name="ln1523">	uint32 attributeName;</a>
<a name="ln1524">	uint32 attributeForm;</a>
<a name="ln1525">	while (abbreviationEntry.GetNextAttribute(attributeName,</a>
<a name="ln1526">			attributeForm)) {</a>
<a name="ln1527">		// resolve attribute form indirection</a>
<a name="ln1528">		if (attributeForm == DW_FORM_indirect)</a>
<a name="ln1529">			attributeForm = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln1530"> </a>
<a name="ln1531">		// prepare an AttributeValue</a>
<a name="ln1532">		AttributeValue attributeValue;</a>
<a name="ln1533">		attributeValue.attributeForm = attributeForm;</a>
<a name="ln1534">		bool isSigned = false;</a>
<a name="ln1535"> </a>
<a name="ln1536">		// Read the attribute value according to the attribute's form. For</a>
<a name="ln1537">		// the forms that don't map to a single attribute class only or</a>
<a name="ln1538">		// those that need additional processing, we read a temporary value</a>
<a name="ln1539">		// first.</a>
<a name="ln1540">		uint64 value = 0;</a>
<a name="ln1541">		off_t blockLength = 0;</a>
<a name="ln1542">		off_t valueOffset = dataReader.Offset() + unit-&gt;ContentOffset();</a>
<a name="ln1543">		uint8 refType = dwarf_reference_type_local;</a>
<a name="ln1544"> </a>
<a name="ln1545">		switch (attributeForm) {</a>
<a name="ln1546">			case DW_FORM_addr:</a>
<a name="ln1547">				value = dataReader.ReadAddress(0);</a>
<a name="ln1548">				break;</a>
<a name="ln1549">			case DW_FORM_block2:</a>
<a name="ln1550">				blockLength = dataReader.Read&lt;uint16&gt;(0);</a>
<a name="ln1551">				break;</a>
<a name="ln1552">			case DW_FORM_block4:</a>
<a name="ln1553">				blockLength = dataReader.Read&lt;uint32&gt;(0);</a>
<a name="ln1554">				break;</a>
<a name="ln1555">			case DW_FORM_data2:</a>
<a name="ln1556">				value = dataReader.Read&lt;uint16&gt;(0);</a>
<a name="ln1557">				break;</a>
<a name="ln1558">			case DW_FORM_data4:</a>
<a name="ln1559">				value = dataReader.Read&lt;uint32&gt;(0);</a>
<a name="ln1560">				break;</a>
<a name="ln1561">			case DW_FORM_data8:</a>
<a name="ln1562">				value = dataReader.Read&lt;uint64&gt;(0);</a>
<a name="ln1563">				break;</a>
<a name="ln1564">			case DW_FORM_string:</a>
<a name="ln1565">				attributeValue.SetToString(dataReader.ReadString());</a>
<a name="ln1566">				break;</a>
<a name="ln1567">			case DW_FORM_block:</a>
<a name="ln1568">			case DW_FORM_exprloc:</a>
<a name="ln1569">				blockLength = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln1570">				break;</a>
<a name="ln1571">			case DW_FORM_block1:</a>
<a name="ln1572">				blockLength = dataReader.Read&lt;uint8&gt;(0);</a>
<a name="ln1573">				break;</a>
<a name="ln1574">			case DW_FORM_data1:</a>
<a name="ln1575">				value = dataReader.Read&lt;uint8&gt;(0);</a>
<a name="ln1576">				break;</a>
<a name="ln1577">			case DW_FORM_flag:</a>
<a name="ln1578">				attributeValue.SetToFlag(dataReader.Read&lt;uint8&gt;(0) != 0);</a>
<a name="ln1579">				break;</a>
<a name="ln1580">			case DW_FORM_sdata:</a>
<a name="ln1581">				value = dataReader.ReadSignedLEB128(0);</a>
<a name="ln1582">				isSigned = true;</a>
<a name="ln1583">				break;</a>
<a name="ln1584">			case DW_FORM_strp:</a>
<a name="ln1585">			{</a>
<a name="ln1586">				if (fDebugStringSection != NULL) {</a>
<a name="ln1587">					uint64 offset = unit-&gt;IsDwarf64()</a>
<a name="ln1588">						? dataReader.Read&lt;uint64&gt;(0)</a>
<a name="ln1589">						: dataReader.Read&lt;uint32&gt;(0);</a>
<a name="ln1590">					if (offset &gt;= fDebugStringSection-&gt;Size()) {</a>
<a name="ln1591">						WARNING(&quot;Invalid DW_FORM_strp offset: %&quot; B_PRIu64 &quot;\n&quot;,</a>
<a name="ln1592">							offset);</a>
<a name="ln1593">						return B_BAD_DATA;</a>
<a name="ln1594">					}</a>
<a name="ln1595">					attributeValue.SetToString(</a>
<a name="ln1596">						(const char*)fDebugStringSection-&gt;Data() + offset);</a>
<a name="ln1597">				} else {</a>
<a name="ln1598">					WARNING(&quot;Invalid DW_FORM_strp: no string section!\n&quot;);</a>
<a name="ln1599">					return B_BAD_DATA;</a>
<a name="ln1600">				}</a>
<a name="ln1601">				break;</a>
<a name="ln1602">			}</a>
<a name="ln1603">			case DW_FORM_udata:</a>
<a name="ln1604">				value = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln1605">				break;</a>
<a name="ln1606">			case DW_FORM_ref_addr:</a>
<a name="ln1607">				value = unit-&gt;IsDwarf64()</a>
<a name="ln1608">					? dataReader.Read&lt;uint64&gt;(0)</a>
<a name="ln1609">					: (uint64)dataReader.Read&lt;uint32&gt;(0);</a>
<a name="ln1610">				refType = dwarf_reference_type_global;</a>
<a name="ln1611">				break;</a>
<a name="ln1612">			case DW_FORM_ref1:</a>
<a name="ln1613">				value = dataReader.Read&lt;uint8&gt;(0);</a>
<a name="ln1614">				break;</a>
<a name="ln1615">			case DW_FORM_ref2:</a>
<a name="ln1616">				value = dataReader.Read&lt;uint16&gt;(0);</a>
<a name="ln1617">				break;</a>
<a name="ln1618">			case DW_FORM_ref4:</a>
<a name="ln1619">				value = dataReader.Read&lt;uint32&gt;(0);</a>
<a name="ln1620">				break;</a>
<a name="ln1621">			case DW_FORM_ref8:</a>
<a name="ln1622">				value = dataReader.Read&lt;uint64&gt;(0);</a>
<a name="ln1623">				break;</a>
<a name="ln1624">			case DW_FORM_ref_udata:</a>
<a name="ln1625">				value = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln1626">				break;</a>
<a name="ln1627">			case DW_FORM_flag_present:</a>
<a name="ln1628">				attributeValue.SetToFlag(true);</a>
<a name="ln1629">				break;</a>
<a name="ln1630">			case DW_FORM_ref_sig8:</a>
<a name="ln1631">				fTypesSectionRequired = true;</a>
<a name="ln1632">				value = dataReader.Read&lt;uint64&gt;(0);</a>
<a name="ln1633">				refType = dwarf_reference_type_signature;</a>
<a name="ln1634">				break;</a>
<a name="ln1635">			case DW_FORM_sec_offset:</a>
<a name="ln1636">				value = unit-&gt;IsDwarf64()</a>
<a name="ln1637">					? dataReader.Read&lt;uint64&gt;(0)</a>
<a name="ln1638">					: (uint64)dataReader.Read&lt;uint32&gt;(0);</a>
<a name="ln1639">				break;</a>
<a name="ln1640">			case DW_FORM_indirect:</a>
<a name="ln1641">			default:</a>
<a name="ln1642">				WARNING(&quot;Unsupported attribute form: %&quot; B_PRIu32 &quot;\n&quot;,</a>
<a name="ln1643">					attributeForm);</a>
<a name="ln1644">				return B_BAD_DATA;</a>
<a name="ln1645">		}</a>
<a name="ln1646"> </a>
<a name="ln1647">		// get the attribute class -- skip the attribute, if we can't handle</a>
<a name="ln1648">		// it</a>
<a name="ln1649">		uint8 attributeClass = get_attribute_class(attributeName,</a>
<a name="ln1650">			attributeForm);</a>
<a name="ln1651"> </a>
<a name="ln1652">		if (attributeClass == ATTRIBUTE_CLASS_UNKNOWN) {</a>
<a name="ln1653">			TRACE_DIE(&quot;skipping attribute with unrecognized class: %s (%#&quot;</a>
<a name="ln1654">				B_PRIx32 &quot;) %s (%#&quot; B_PRIx32 &quot;)\n&quot;,</a>
<a name="ln1655">				get_attribute_name_name(attributeName), attributeName,</a>
<a name="ln1656">				get_attribute_form_name(attributeForm), attributeForm);</a>
<a name="ln1657">			continue;</a>
<a name="ln1658">		}</a>
<a name="ln1659"> </a>
<a name="ln1660">		// set the attribute value according to the attribute's class</a>
<a name="ln1661">		switch (attributeClass) {</a>
<a name="ln1662">			case ATTRIBUTE_CLASS_ADDRESS:</a>
<a name="ln1663">				attributeValue.SetToAddress(value);</a>
<a name="ln1664">				break;</a>
<a name="ln1665">			case ATTRIBUTE_CLASS_BLOCK:</a>
<a name="ln1666">				attributeValue.SetToBlock(dataReader.Data(), blockLength);</a>
<a name="ln1667">				dataReader.Skip(blockLength);</a>
<a name="ln1668">				break;</a>
<a name="ln1669">			case ATTRIBUTE_CLASS_CONSTANT:</a>
<a name="ln1670">				attributeValue.SetToConstant(value, isSigned);</a>
<a name="ln1671">				break;</a>
<a name="ln1672">			case ATTRIBUTE_CLASS_LINEPTR:</a>
<a name="ln1673">				attributeValue.SetToLinePointer(value);</a>
<a name="ln1674">				break;</a>
<a name="ln1675">			case ATTRIBUTE_CLASS_LOCLISTPTR:</a>
<a name="ln1676">				attributeValue.SetToLocationListPointer(value);</a>
<a name="ln1677">				break;</a>
<a name="ln1678">			case ATTRIBUTE_CLASS_MACPTR:</a>
<a name="ln1679">				attributeValue.SetToMacroPointer(value);</a>
<a name="ln1680">				break;</a>
<a name="ln1681">			case ATTRIBUTE_CLASS_RANGELISTPTR:</a>
<a name="ln1682">				attributeValue.SetToRangeListPointer(value);</a>
<a name="ln1683">				break;</a>
<a name="ln1684">			case ATTRIBUTE_CLASS_REFERENCE:</a>
<a name="ln1685">				if (entry != NULL) {</a>
<a name="ln1686">					attributeValue.SetToReference(_ResolveReference(</a>
<a name="ln1687">						unit, value, refType));</a>
<a name="ln1688">					if (attributeValue.reference == NULL) {</a>
<a name="ln1689">						// gcc 2 apparently somtimes produces DW_AT_sibling</a>
<a name="ln1690">						// attributes pointing to the end of the sibling list.</a>
<a name="ln1691">						// Just ignore those.</a>
<a name="ln1692">						if (attributeName == DW_AT_sibling)</a>
<a name="ln1693">							continue;</a>
<a name="ln1694"> </a>
<a name="ln1695">						WARNING(&quot;Failed to resolve reference on entry %p: &quot;</a>
<a name="ln1696">							&quot;(%#&quot; B_PRIx64 &quot;) %s (%#&quot; B_PRIx32 &quot;) %s &quot;</a>
<a name="ln1697">							&quot;(%#&quot; B_PRIx32 &quot;): value: %#&quot; B_PRIx64 &quot;\n&quot;,</a>
<a name="ln1698">							entry,</a>
<a name="ln1699">							valueOffset,</a>
<a name="ln1700">							get_attribute_name_name(attributeName),</a>
<a name="ln1701">							attributeName,</a>
<a name="ln1702">							get_attribute_form_name(attributeForm),</a>
<a name="ln1703">							attributeForm, value);</a>
<a name="ln1704">						return B_ENTRY_NOT_FOUND;</a>
<a name="ln1705">					}</a>
<a name="ln1706">				}</a>
<a name="ln1707">				break;</a>
<a name="ln1708">			case ATTRIBUTE_CLASS_FLAG:</a>
<a name="ln1709">			case ATTRIBUTE_CLASS_STRING:</a>
<a name="ln1710">				// already set</a>
<a name="ln1711">				break;</a>
<a name="ln1712">		}</a>
<a name="ln1713"> </a>
<a name="ln1714">		if (dataReader.HasOverflow()) {</a>
<a name="ln1715">			WARNING(&quot;Unexpected end of .debug_info section.\n&quot;);</a>
<a name="ln1716">			return B_BAD_DATA;</a>
<a name="ln1717">		}</a>
<a name="ln1718"> </a>
<a name="ln1719">		TRACE_DIE_ONLY(</a>
<a name="ln1720">			char buffer[1024];</a>
<a name="ln1721">			TRACE_DIE(&quot;  attr (%#&quot; B_PRIx64 &quot;) %s %s (%d): %s\n&quot;,</a>
<a name="ln1722">				valueOffset,</a>
<a name="ln1723">				get_attribute_name_name(attributeName),</a>
<a name="ln1724">				get_attribute_form_name(attributeForm), attributeClass,</a>
<a name="ln1725">				attributeValue.ToString(buffer, sizeof(buffer)));</a>
<a name="ln1726">		)</a>
<a name="ln1727"> </a>
<a name="ln1728">		// add the attribute</a>
<a name="ln1729">		if (entry != NULL) {</a>
<a name="ln1730">			DebugInfoEntrySetter attributeSetter</a>
<a name="ln1731">				= get_attribute_name_setter(attributeName);</a>
<a name="ln1732">			if (attributeSetter != 0) {</a>
<a name="ln1733">				status_t error = (entry-&gt;*attributeSetter)(attributeName,</a>
<a name="ln1734">					attributeValue);</a>
<a name="ln1735"> </a>
<a name="ln1736">				if (error == ATTRIBUTE_NOT_HANDLED) {</a>
<a name="ln1737">					error = B_OK;</a>
<a name="ln1738">					TRACE_DIE(&quot;    -&gt; unhandled\n&quot;);</a>
<a name="ln1739">				}</a>
<a name="ln1740"> </a>
<a name="ln1741">				if (error != B_OK) {</a>
<a name="ln1742">					WARNING(&quot;Failed to set attribute: name: %s, form: %s: %s\n&quot;,</a>
<a name="ln1743">						get_attribute_name_name(attributeName),</a>
<a name="ln1744">						get_attribute_form_name(attributeForm),</a>
<a name="ln1745">						strerror(error));</a>
<a name="ln1746">				}</a>
<a name="ln1747">			} else</a>
<a name="ln1748">				TRACE_DIE(&quot;    -&gt; no attribute setter!\n&quot;);</a>
<a name="ln1749">		}</a>
<a name="ln1750">	}</a>
<a name="ln1751"> </a>
<a name="ln1752">	return B_OK;</a>
<a name="ln1753">}</a>
<a name="ln1754"> </a>
<a name="ln1755"> </a>
<a name="ln1756">status_t</a>
<a name="ln1757">DwarfFile::_ParseLineInfo(CompilationUnit* unit)</a>
<a name="ln1758">{</a>
<a name="ln1759">	off_t offset = unit-&gt;UnitEntry()-&gt;StatementListOffset();</a>
<a name="ln1760"> </a>
<a name="ln1761">	TRACE_LINES(&quot;DwarfFile::_ParseLineInfo(%p), offset: %&quot; B_PRIdOFF &quot;\n&quot;, unit,</a>
<a name="ln1762">		offset);</a>
<a name="ln1763"> </a>
<a name="ln1764">	DataReader dataReader((uint8*)fDebugLineSection-&gt;Data() + offset,</a>
<a name="ln1765">		fDebugLineSection-&gt;Size() - offset, unit-&gt;AddressSize());</a>
<a name="ln1766"> </a>
<a name="ln1767">	// unit length</a>
<a name="ln1768">	bool dwarf64;</a>
<a name="ln1769">	uint64 unitLength = dataReader.ReadInitialLength(dwarf64);</a>
<a name="ln1770">	if (unitLength &gt; (uint64)dataReader.BytesRemaining())</a>
<a name="ln1771">		return B_BAD_DATA;</a>
<a name="ln1772">	off_t unitOffset = dataReader.Offset();</a>
<a name="ln1773"> </a>
<a name="ln1774">	// version (uhalf)</a>
<a name="ln1775">	uint16 version = dataReader.Read&lt;uint16&gt;(0);</a>
<a name="ln1776"> </a>
<a name="ln1777">	// header_length (4/8)</a>
<a name="ln1778">	uint64 headerLength = dwarf64</a>
<a name="ln1779">		? dataReader.Read&lt;uint64&gt;(0) : (uint64)dataReader.Read&lt;uint32&gt;(0);</a>
<a name="ln1780">	off_t headerOffset = dataReader.Offset();</a>
<a name="ln1781"> </a>
<a name="ln1782">	if ((uint64)dataReader.BytesRemaining() &lt; headerLength)</a>
<a name="ln1783">		return B_BAD_DATA;</a>
<a name="ln1784"> </a>
<a name="ln1785">	// minimum instruction length</a>
<a name="ln1786">	uint8 minInstructionLength = dataReader.Read&lt;uint8&gt;(0);</a>
<a name="ln1787"> </a>
<a name="ln1788">	// default is statement</a>
<a name="ln1789">	bool defaultIsStatement = dataReader.Read&lt;uint8&gt;(0) != 0;</a>
<a name="ln1790"> </a>
<a name="ln1791">	// line_base (sbyte)</a>
<a name="ln1792">	int8 lineBase = (int8)dataReader.Read&lt;uint8&gt;(0);</a>
<a name="ln1793"> </a>
<a name="ln1794">	// line_range (ubyte)</a>
<a name="ln1795">	uint8 lineRange = dataReader.Read&lt;uint8&gt;(0);</a>
<a name="ln1796"> </a>
<a name="ln1797">	// opcode_base (ubyte)</a>
<a name="ln1798">	uint8 opcodeBase = dataReader.Read&lt;uint8&gt;(0);</a>
<a name="ln1799"> </a>
<a name="ln1800">	// standard_opcode_lengths (ubyte[])</a>
<a name="ln1801">	const uint8* standardOpcodeLengths = (const uint8*)dataReader.Data();</a>
<a name="ln1802">	dataReader.Skip(opcodeBase - 1);</a>
<a name="ln1803"> </a>
<a name="ln1804">	if (dataReader.HasOverflow())</a>
<a name="ln1805">		return B_BAD_DATA;</a>
<a name="ln1806"> </a>
<a name="ln1807">	if (version != 2 &amp;&amp; version != 3)</a>
<a name="ln1808">		return B_UNSUPPORTED;</a>
<a name="ln1809"> </a>
<a name="ln1810">	TRACE_LINES(&quot;  unitLength:           %&quot; B_PRIu64 &quot;\n&quot;, unitLength);</a>
<a name="ln1811">	TRACE_LINES(&quot;  version:              %u\n&quot;, version);</a>
<a name="ln1812">	TRACE_LINES(&quot;  headerLength:         %&quot; B_PRIu64 &quot;\n&quot;, headerLength);</a>
<a name="ln1813">	TRACE_LINES(&quot;  minInstructionLength: %u\n&quot;, minInstructionLength);</a>
<a name="ln1814">	TRACE_LINES(&quot;  defaultIsStatement:   %d\n&quot;, defaultIsStatement);</a>
<a name="ln1815">	TRACE_LINES(&quot;  lineBase:             %d\n&quot;, lineBase);</a>
<a name="ln1816">	TRACE_LINES(&quot;  lineRange:            %u\n&quot;, lineRange);</a>
<a name="ln1817">	TRACE_LINES(&quot;  opcodeBase:           %u\n&quot;, opcodeBase);</a>
<a name="ln1818"> </a>
<a name="ln1819">	// include directories</a>
<a name="ln1820">	TRACE_LINES(&quot;  include directories:\n&quot;);</a>
<a name="ln1821">	while (const char* directory = dataReader.ReadString()) {</a>
<a name="ln1822">		if (*directory == '\0')</a>
<a name="ln1823">			break;</a>
<a name="ln1824">		TRACE_LINES(&quot;    \&quot;%s\&quot;\n&quot;, directory);</a>
<a name="ln1825"> </a>
<a name="ln1826">		if (!unit-&gt;AddDirectory(directory))</a>
<a name="ln1827">			return B_NO_MEMORY;</a>
<a name="ln1828">	}</a>
<a name="ln1829"> </a>
<a name="ln1830">	// file names</a>
<a name="ln1831">	TRACE_LINES(&quot;  files:\n&quot;);</a>
<a name="ln1832">	while (const char* file = dataReader.ReadString()) {</a>
<a name="ln1833">		if (*file == '\0')</a>
<a name="ln1834">			break;</a>
<a name="ln1835">		uint64 dirIndex = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln1836">		TRACE_LINES_ONLY(uint64 modificationTime =)</a>
<a name="ln1837">			dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln1838">		TRACE_LINES_ONLY(uint64 fileLength =)</a>
<a name="ln1839">			dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln1840"> </a>
<a name="ln1841">		if (dataReader.HasOverflow())</a>
<a name="ln1842">			return B_BAD_DATA;</a>
<a name="ln1843"> </a>
<a name="ln1844">		TRACE_LINES(&quot;    \&quot;%s\&quot;, dir index: %&quot; B_PRIu64 &quot;, mtime: %&quot; B_PRIu64</a>
<a name="ln1845">			&quot;, length: %&quot; B_PRIu64 &quot;\n&quot;, file, dirIndex, modificationTime,</a>
<a name="ln1846">			fileLength);</a>
<a name="ln1847"> </a>
<a name="ln1848">		if (!unit-&gt;AddFile(file, dirIndex))</a>
<a name="ln1849">			return B_NO_MEMORY;</a>
<a name="ln1850">	}</a>
<a name="ln1851"> </a>
<a name="ln1852">	off_t readerOffset = dataReader.Offset();</a>
<a name="ln1853">	if ((uint64)readerOffset &gt; readerOffset + headerLength)</a>
<a name="ln1854">		return B_BAD_DATA;</a>
<a name="ln1855">	off_t offsetToProgram = headerOffset + headerLength - readerOffset;</a>
<a name="ln1856"> </a>
<a name="ln1857">	const uint8* program = (uint8*)dataReader.Data() + offsetToProgram;</a>
<a name="ln1858">	size_t programSize = unitLength - (readerOffset - unitOffset);</a>
<a name="ln1859"> </a>
<a name="ln1860">	return unit-&gt;GetLineNumberProgram().Init(program, programSize,</a>
<a name="ln1861">		minInstructionLength, defaultIsStatement, lineBase, lineRange,</a>
<a name="ln1862">			opcodeBase, standardOpcodeLengths);</a>
<a name="ln1863">}</a>
<a name="ln1864"> </a>
<a name="ln1865"> </a>
<a name="ln1866">status_t</a>
<a name="ln1867">DwarfFile::_UnwindCallFrame(CompilationUnit* unit, uint8 addressSize,</a>
<a name="ln1868">	DIESubprogram* subprogramEntry, target_addr_t location,</a>
<a name="ln1869">	const FDELookupInfo* info, const DwarfTargetInterface* inputInterface,</a>
<a name="ln1870">	DwarfTargetInterface* outputInterface, target_addr_t&amp; _framePointer)</a>
<a name="ln1871">{</a>
<a name="ln1872">	ElfSection* currentFrameSection = (info-&gt;ehFrame)</a>
<a name="ln1873">		? fEHFrameSection : fDebugFrameSection;</a>
<a name="ln1874"> </a>
<a name="ln1875">	TRACE_CFI(&quot;DwarfFile::_UnwindCallFrame(%#&quot; B_PRIx64 &quot;)\n&quot;, location);</a>
<a name="ln1876"> </a>
<a name="ln1877">	DataReader dataReader((uint8*)currentFrameSection-&gt;Data(),</a>
<a name="ln1878">		currentFrameSection-&gt;Size(), unit != NULL</a>
<a name="ln1879">			? unit-&gt;AddressSize() : addressSize);</a>
<a name="ln1880">	dataReader.SeekAbsolute(info-&gt;fdeOffset);</a>
<a name="ln1881"> </a>
<a name="ln1882">	bool dwarf64;</a>
<a name="ln1883">	uint64 length = dataReader.ReadInitialLength(dwarf64);</a>
<a name="ln1884">	uint64 lengthOffset = dataReader.Offset();</a>
<a name="ln1885"> </a>
<a name="ln1886">	CfaContext context;</a>
<a name="ln1887">	CIEAugmentation cieAugmentation;</a>
<a name="ln1888">	// when using .eh_frame format, we need to parse the CIE's</a>
<a name="ln1889">	// augmentation up front in order to know how the FDE's addresses</a>
<a name="ln1890">	//  will be represented</a>
<a name="ln1891">	DataReader cieReader;</a>
<a name="ln1892">	off_t cieRemaining;</a>
<a name="ln1893">	status_t error = _ParseCIEHeader(currentFrameSection,</a>
<a name="ln1894">		info-&gt;ehFrame, unit, addressSize, context, info-&gt;cieOffset,</a>
<a name="ln1895">		cieAugmentation, cieReader, cieRemaining);</a>
<a name="ln1896">	if (error != B_OK)</a>
<a name="ln1897">		return error;</a>
<a name="ln1898">	if (cieReader.HasOverflow())</a>
<a name="ln1899">		return B_BAD_DATA;</a>
<a name="ln1900">	if (cieRemaining &lt; 0)</a>
<a name="ln1901">		return B_BAD_DATA;</a>
<a name="ln1902"> </a>
<a name="ln1903">	// skip CIE ID, initial offset and range, since we already know those</a>
<a name="ln1904">	// from FDELookupInfo.</a>
<a name="ln1905">	dwarf64	? dataReader.Read&lt;uint64&gt;(0) : dataReader.Read&lt;uint32&gt;(0);</a>
<a name="ln1906">	cieAugmentation.ReadEncodedAddress(dataReader, fElfFile,</a>
<a name="ln1907">		currentFrameSection);</a>
<a name="ln1908">	cieAugmentation.ReadEncodedAddress(dataReader, fElfFile,</a>
<a name="ln1909">		currentFrameSection, true);</a>
<a name="ln1910"> </a>
<a name="ln1911">	TRACE_CFI(&quot;  found fde: length: %&quot; B_PRIu64 &quot; (%&quot; B_PRIdOFF</a>
<a name="ln1912">		&quot;), CIE offset: %#&quot; B_PRIx64 &quot;, location: %#&quot; B_PRIx64 &quot;, &quot;</a>
<a name="ln1913">		&quot;range: %#&quot; B_PRIx64 &quot;\n&quot;, length, dataReader.BytesRemaining(),</a>
<a name="ln1914">		info-&gt;cieOffset, info-&gt;start, info-&gt;end - info-&gt;start);</a>
<a name="ln1915"> </a>
<a name="ln1916">	context.SetLocation(location, info-&gt;start);</a>
<a name="ln1917">	uint32 registerCount = outputInterface-&gt;CountRegisters();</a>
<a name="ln1918">	error = context.Init(registerCount);</a>
<a name="ln1919">	if (error != B_OK)</a>
<a name="ln1920">		return error;</a>
<a name="ln1921"> </a>
<a name="ln1922">	error = outputInterface-&gt;InitRegisterRules(context);</a>
<a name="ln1923">	if (error != B_OK)</a>
<a name="ln1924">		return error;</a>
<a name="ln1925"> </a>
<a name="ln1926">	// process the CIE's frame info instructions</a>
<a name="ln1927">	cieReader = cieReader.RestrictedReader(cieRemaining);</a>
<a name="ln1928">	error = _ParseFrameInfoInstructions(unit, context,</a>
<a name="ln1929">		cieReader, cieAugmentation);</a>
<a name="ln1930">	if (error != B_OK)</a>
<a name="ln1931">		return error;</a>
<a name="ln1932"> </a>
<a name="ln1933">	// read the FDE augmentation data (if any)</a>
<a name="ln1934">	FDEAugmentation fdeAugmentation;</a>
<a name="ln1935">	error = cieAugmentation.ReadFDEData(dataReader,</a>
<a name="ln1936">		fdeAugmentation);</a>
<a name="ln1937">	if (error != B_OK) {</a>
<a name="ln1938">		TRACE_CFI(&quot;  failed to read FDE augmentation data!\n&quot;);</a>
<a name="ln1939">		return error;</a>
<a name="ln1940">	}</a>
<a name="ln1941"> </a>
<a name="ln1942">	error = context.SaveInitialRuleSet();</a>
<a name="ln1943">	if (error != B_OK)</a>
<a name="ln1944">		return error;</a>
<a name="ln1945"> </a>
<a name="ln1946">	uint64 remaining = lengthOffset + length - dataReader.Offset();</a>
<a name="ln1947">	if (remaining &lt; 0)</a>
<a name="ln1948">		return B_BAD_DATA;</a>
<a name="ln1949"> </a>
<a name="ln1950">	DataReader restrictedReader =</a>
<a name="ln1951">		dataReader.RestrictedReader(remaining);</a>
<a name="ln1952">	error = _ParseFrameInfoInstructions(unit, context,</a>
<a name="ln1953">		restrictedReader, cieAugmentation);</a>
<a name="ln1954">	if (error != B_OK)</a>
<a name="ln1955">		return error;</a>
<a name="ln1956"> </a>
<a name="ln1957">	TRACE_CFI(&quot;  found row!\n&quot;);</a>
<a name="ln1958"> </a>
<a name="ln1959">	// apply the rules of the final row</a>
<a name="ln1960">	// get the frameAddress first</a>
<a name="ln1961">	target_addr_t frameAddress;</a>
<a name="ln1962">	CfaCfaRule* cfaCfaRule = context.GetCfaCfaRule();</a>
<a name="ln1963">	switch (cfaCfaRule-&gt;Type()) {</a>
<a name="ln1964">		case CFA_CFA_RULE_REGISTER_OFFSET:</a>
<a name="ln1965">		{</a>
<a name="ln1966">			BVariant value;</a>
<a name="ln1967">			if (!inputInterface-&gt;GetRegisterValue(</a>
<a name="ln1968">					cfaCfaRule-&gt;Register(), value)</a>
<a name="ln1969">				|| !value.IsNumber()) {</a>
<a name="ln1970">				return B_UNSUPPORTED;</a>
<a name="ln1971">			}</a>
<a name="ln1972">			frameAddress = value.ToUInt64() + cfaCfaRule-&gt;Offset();</a>
<a name="ln1973">			break;</a>
<a name="ln1974">		}</a>
<a name="ln1975">		case CFA_CFA_RULE_EXPRESSION:</a>
<a name="ln1976">		{</a>
<a name="ln1977">			error = EvaluateExpression(unit, addressSize,</a>
<a name="ln1978">				subprogramEntry,</a>
<a name="ln1979">				cfaCfaRule-&gt;Expression().block,</a>
<a name="ln1980">				cfaCfaRule-&gt;Expression().size,</a>
<a name="ln1981">				inputInterface, location, 0, 0, false,</a>
<a name="ln1982">				frameAddress);</a>
<a name="ln1983">			if (error != B_OK)</a>
<a name="ln1984">				return error;</a>
<a name="ln1985">			break;</a>
<a name="ln1986">		}</a>
<a name="ln1987">		case CFA_CFA_RULE_UNDEFINED:</a>
<a name="ln1988">		default:</a>
<a name="ln1989">			return B_BAD_VALUE;</a>
<a name="ln1990">	}</a>
<a name="ln1991"> </a>
<a name="ln1992">	TRACE_CFI(&quot;  frame address: %#&quot; B_PRIx64 &quot;\n&quot;, frameAddress);</a>
<a name="ln1993"> </a>
<a name="ln1994">	// apply the register rules</a>
<a name="ln1995">	for (uint32 i = 0; i &lt; registerCount; i++) {</a>
<a name="ln1996">		TRACE_CFI(&quot;  reg %&quot; B_PRIu32 &quot;\n&quot;, i);</a>
<a name="ln1997"> </a>
<a name="ln1998">		uint32 valueType = outputInterface-&gt;RegisterValueType(i);</a>
<a name="ln1999">		if (valueType == 0)</a>
<a name="ln2000">			continue;</a>
<a name="ln2001"> </a>
<a name="ln2002">		CfaRule* rule = context.RegisterRule(i);</a>
<a name="ln2003">		if (rule == NULL)</a>
<a name="ln2004">			continue;</a>
<a name="ln2005"> </a>
<a name="ln2006">		// apply the rule</a>
<a name="ln2007">		switch (rule-&gt;Type()) {</a>
<a name="ln2008">			case CFA_RULE_SAME_VALUE:</a>
<a name="ln2009">			{</a>
<a name="ln2010">				TRACE_CFI(&quot;  -&gt; CFA_RULE_SAME_VALUE\n&quot;);</a>
<a name="ln2011"> </a>
<a name="ln2012">				BVariant value;</a>
<a name="ln2013">				if (inputInterface-&gt;GetRegisterValue(i, value))</a>
<a name="ln2014">					outputInterface-&gt;SetRegisterValue(i, value);</a>
<a name="ln2015">				break;</a>
<a name="ln2016">			}</a>
<a name="ln2017">			case CFA_RULE_LOCATION_OFFSET:</a>
<a name="ln2018">			{</a>
<a name="ln2019">				TRACE_CFI(&quot;  -&gt; CFA_RULE_LOCATION_OFFSET: %&quot;</a>
<a name="ln2020">					B_PRId64 &quot;\n&quot;, rule-&gt;Offset());</a>
<a name="ln2021"> </a>
<a name="ln2022">				BVariant value;</a>
<a name="ln2023">				if (inputInterface-&gt;ReadValueFromMemory(</a>
<a name="ln2024">						frameAddress + rule-&gt;Offset(), valueType,</a>
<a name="ln2025">						value)) {</a>
<a name="ln2026">					outputInterface-&gt;SetRegisterValue(i, value);</a>
<a name="ln2027">				}</a>
<a name="ln2028">				break;</a>
<a name="ln2029">			}</a>
<a name="ln2030">			case CFA_RULE_VALUE_OFFSET:</a>
<a name="ln2031">				TRACE_CFI(&quot;  -&gt; CFA_RULE_VALUE_OFFSET\n&quot;);</a>
<a name="ln2032"> </a>
<a name="ln2033">				outputInterface-&gt;SetRegisterValue(i,</a>
<a name="ln2034">					frameAddress + rule-&gt;Offset());</a>
<a name="ln2035">				break;</a>
<a name="ln2036">			case CFA_RULE_REGISTER:</a>
<a name="ln2037">			{</a>
<a name="ln2038">				TRACE_CFI(&quot;  -&gt; CFA_RULE_REGISTER\n&quot;);</a>
<a name="ln2039"> </a>
<a name="ln2040">				BVariant value;</a>
<a name="ln2041">				if (inputInterface-&gt;GetRegisterValue(</a>
<a name="ln2042">						rule-&gt;Register(), value)) {</a>
<a name="ln2043">					outputInterface-&gt;SetRegisterValue(i, value);</a>
<a name="ln2044">				}</a>
<a name="ln2045">				break;</a>
<a name="ln2046">			}</a>
<a name="ln2047">			case CFA_RULE_LOCATION_EXPRESSION:</a>
<a name="ln2048">			{</a>
<a name="ln2049">				TRACE_CFI(&quot;  -&gt; CFA_RULE_LOCATION_EXPRESSION\n&quot;);</a>
<a name="ln2050"> </a>
<a name="ln2051">				target_addr_t address;</a>
<a name="ln2052">				error = EvaluateExpression(unit, addressSize,</a>
<a name="ln2053">					subprogramEntry,</a>
<a name="ln2054">					rule-&gt;Expression().block,</a>
<a name="ln2055">					rule-&gt;Expression().size,</a>
<a name="ln2056">					inputInterface, location, frameAddress,</a>
<a name="ln2057">					frameAddress, true, address);</a>
<a name="ln2058">				BVariant value;</a>
<a name="ln2059">				if (error == B_OK</a>
<a name="ln2060">					&amp;&amp; inputInterface-&gt;ReadValueFromMemory(address,</a>
<a name="ln2061">						valueType, value)) {</a>
<a name="ln2062">					outputInterface-&gt;SetRegisterValue(i, value);</a>
<a name="ln2063">				}</a>
<a name="ln2064">				break;</a>
<a name="ln2065">			}</a>
<a name="ln2066">			case CFA_RULE_VALUE_EXPRESSION:</a>
<a name="ln2067">			{</a>
<a name="ln2068">				TRACE_CFI(&quot;  -&gt; CFA_RULE_VALUE_EXPRESSION\n&quot;);</a>
<a name="ln2069"> </a>
<a name="ln2070">				target_addr_t value;</a>
<a name="ln2071">				error = EvaluateExpression(unit, addressSize,</a>
<a name="ln2072">					subprogramEntry,</a>
<a name="ln2073">					rule-&gt;Expression().block,</a>
<a name="ln2074">					rule-&gt;Expression().size,</a>
<a name="ln2075">					inputInterface, location, frameAddress,</a>
<a name="ln2076">					frameAddress, true, value);</a>
<a name="ln2077">				if (error == B_OK)</a>
<a name="ln2078">					outputInterface-&gt;SetRegisterValue(i, value);</a>
<a name="ln2079">				break;</a>
<a name="ln2080">			}</a>
<a name="ln2081">			case CFA_RULE_UNDEFINED:</a>
<a name="ln2082">				TRACE_CFI(&quot;  -&gt; CFA_RULE_UNDEFINED\n&quot;);</a>
<a name="ln2083">			default:</a>
<a name="ln2084">				break;</a>
<a name="ln2085">		}</a>
<a name="ln2086">	}</a>
<a name="ln2087"> </a>
<a name="ln2088">	_framePointer = frameAddress;</a>
<a name="ln2089"> </a>
<a name="ln2090">	return B_OK;</a>
<a name="ln2091">}</a>
<a name="ln2092"> </a>
<a name="ln2093"> </a>
<a name="ln2094">status_t</a>
<a name="ln2095">DwarfFile::_ParseCIEHeader(ElfSection* debugFrameSection,</a>
<a name="ln2096">	bool usingEHFrameSection, CompilationUnit* unit, uint8 addressSize,</a>
<a name="ln2097">	CfaContext&amp; context, off_t cieOffset, CIEAugmentation&amp; cieAugmentation,</a>
<a name="ln2098">	DataReader&amp; dataReader, off_t&amp; _cieRemaining)</a>
<a name="ln2099">{</a>
<a name="ln2100">	if (cieOffset &lt; 0 || (uint64)cieOffset &gt;= debugFrameSection-&gt;Size())</a>
<a name="ln2101">		return B_BAD_DATA;</a>
<a name="ln2102"> </a>
<a name="ln2103">	dataReader.SetTo((uint8*)debugFrameSection-&gt;Data() + cieOffset,</a>
<a name="ln2104">		debugFrameSection-&gt;Size() - cieOffset, unit != NULL</a>
<a name="ln2105">			? unit-&gt;AddressSize() : addressSize);</a>
<a name="ln2106"> </a>
<a name="ln2107">	// length</a>
<a name="ln2108">	bool dwarf64;</a>
<a name="ln2109">	uint64 length = dataReader.ReadInitialLength(dwarf64);</a>
<a name="ln2110">	if (length &gt; (uint64)dataReader.BytesRemaining())</a>
<a name="ln2111">		return B_BAD_DATA;</a>
<a name="ln2112"> </a>
<a name="ln2113">	off_t lengthOffset = dataReader.Offset();</a>
<a name="ln2114"> </a>
<a name="ln2115">	// CIE ID/CIE pointer</a>
<a name="ln2116">	uint64 cieID = dwarf64</a>
<a name="ln2117">		? dataReader.Read&lt;uint64&gt;(0) : dataReader.Read&lt;uint32&gt;(0);</a>
<a name="ln2118">	if (usingEHFrameSection) {</a>
<a name="ln2119">		if (cieID != 0)</a>
<a name="ln2120">			return B_BAD_DATA;</a>
<a name="ln2121">	} else {</a>
<a name="ln2122">		if (dwarf64 ? cieID != 0xffffffffffffffffULL : cieID != 0xffffffff)</a>
<a name="ln2123">			return B_BAD_DATA;</a>
<a name="ln2124">	}</a>
<a name="ln2125"> </a>
<a name="ln2126">	uint8 version = dataReader.Read&lt;uint8&gt;(0);</a>
<a name="ln2127">	if (version != 1) {</a>
<a name="ln2128">		TRACE_CFI(&quot;  cie: length: %&quot; B_PRIu64 &quot;, offset: %#&quot; B_PRIx64 &quot;, &quot;</a>
<a name="ln2129">			&quot;version: %u -- unsupported\n&quot;,	length, (uint64)cieOffset, version);</a>
<a name="ln2130">		return B_UNSUPPORTED;</a>
<a name="ln2131">	}</a>
<a name="ln2132"> </a>
<a name="ln2133">	// read the augmentation string</a>
<a name="ln2134">	cieAugmentation.Init(dataReader);</a>
<a name="ln2135"> </a>
<a name="ln2136">	// in the cause of augmentation string &quot;eh&quot;,</a>
<a name="ln2137">	// the exception table pointer is located immediately before the</a>
<a name="ln2138">	// code/data alignment values. We have no use for it so simply skip.</a>
<a name="ln2139">	if (strcmp(cieAugmentation.String(), &quot;eh&quot;) == 0)</a>
<a name="ln2140">		dataReader.Skip(dwarf64 ? sizeof(uint64) : sizeof(uint32));</a>
<a name="ln2141"> </a>
<a name="ln2142">	context.SetCodeAlignment(dataReader.ReadUnsignedLEB128(0));</a>
<a name="ln2143">	context.SetDataAlignment(dataReader.ReadSignedLEB128(0));</a>
<a name="ln2144">	context.SetReturnAddressRegister(dataReader.ReadUnsignedLEB128(0));</a>
<a name="ln2145"> </a>
<a name="ln2146">	TRACE_CFI(&quot;  cie: length: %&quot; B_PRIu64 &quot;, offset: %#&quot; B_PRIx64 &quot;, version: &quot;</a>
<a name="ln2147">		&quot;%u, augmentation: \&quot;%s\&quot;, aligment: code: %&quot; B_PRIu32 &quot;, data: %&quot;</a>
<a name="ln2148">		B_PRId32 &quot;, return address reg: %&quot; B_PRIu32 &quot;\n&quot;, length,</a>
<a name="ln2149">		(uint64)cieOffset, version, cieAugmentation.String(),</a>
<a name="ln2150">		context.CodeAlignment(), context.DataAlignment(),</a>
<a name="ln2151">		context.ReturnAddressRegister());</a>
<a name="ln2152"> </a>
<a name="ln2153">	status_t error = cieAugmentation.Read(dataReader);</a>
<a name="ln2154">	if (error != B_OK) {</a>
<a name="ln2155">		TRACE_CFI(&quot;  cie: length: %&quot; B_PRIu64 &quot;, version: %u, augmentation: &quot;</a>
<a name="ln2156">			&quot;\&quot;%s\&quot; -- unsupported\n&quot;, length, version,</a>
<a name="ln2157">			cieAugmentation.String());</a>
<a name="ln2158">		return error;</a>
<a name="ln2159">	}</a>
<a name="ln2160"> </a>
<a name="ln2161">	if (dataReader.HasOverflow())</a>
<a name="ln2162">		return B_BAD_DATA;</a>
<a name="ln2163"> </a>
<a name="ln2164">	_cieRemaining = length -(dataReader.Offset() - lengthOffset);</a>
<a name="ln2165">	if (_cieRemaining &lt; 0)</a>
<a name="ln2166">		return B_BAD_DATA;</a>
<a name="ln2167"> </a>
<a name="ln2168">	return B_OK;</a>
<a name="ln2169">}</a>
<a name="ln2170"> </a>
<a name="ln2171"> </a>
<a name="ln2172">status_t</a>
<a name="ln2173">DwarfFile::_ParseFrameInfoInstructions(CompilationUnit* unit,</a>
<a name="ln2174">	CfaContext&amp; context, DataReader&amp; dataReader, CIEAugmentation&amp; augmentation)</a>
<a name="ln2175">{</a>
<a name="ln2176">	while (dataReader.BytesRemaining() &gt; 0) {</a>
<a name="ln2177">		TRACE_CFI(&quot;    [%2&quot; B_PRId64 &quot;]&quot;, dataReader.BytesRemaining());</a>
<a name="ln2178"> </a>
<a name="ln2179">		uint8 opcode = dataReader.Read&lt;uint8&gt;(0);</a>
<a name="ln2180">		if ((opcode &gt;&gt; 6) != 0) {</a>
<a name="ln2181">			uint32 operand = opcode &amp; 0x3f;</a>
<a name="ln2182"> </a>
<a name="ln2183">			switch (opcode &gt;&gt; 6) {</a>
<a name="ln2184">				case DW_CFA_advance_loc:</a>
<a name="ln2185">				{</a>
<a name="ln2186">					TRACE_CFI(&quot;    DW_CFA_advance_loc: %#&quot; B_PRIx32 &quot;\n&quot;,</a>
<a name="ln2187">						operand);</a>
<a name="ln2188"> </a>
<a name="ln2189">					target_addr_t location = context.Location()</a>
<a name="ln2190">						+ operand * context.CodeAlignment();</a>
<a name="ln2191">					if (location &gt; context.TargetLocation())</a>
<a name="ln2192">						return B_OK;</a>
<a name="ln2193">					context.SetLocation(location);</a>
<a name="ln2194">					break;</a>
<a name="ln2195">				}</a>
<a name="ln2196">				case DW_CFA_offset:</a>
<a name="ln2197">				{</a>
<a name="ln2198">					uint64 offset = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln2199">					TRACE_CFI(&quot;    DW_CFA_offset: reg: %&quot; B_PRIu32 &quot;, offset: &quot;</a>
<a name="ln2200">						&quot;%&quot; B_PRIu64 &quot;\n&quot;, operand, offset);</a>
<a name="ln2201"> </a>
<a name="ln2202">					if (CfaRule* rule = context.RegisterRule(operand)) {</a>
<a name="ln2203">						rule-&gt;SetToLocationOffset(</a>
<a name="ln2204">							offset * context.DataAlignment());</a>
<a name="ln2205">					}</a>
<a name="ln2206">					break;</a>
<a name="ln2207">				}</a>
<a name="ln2208">				case DW_CFA_restore:</a>
<a name="ln2209">				{</a>
<a name="ln2210">					TRACE_CFI(&quot;    DW_CFA_restore: %#&quot; B_PRIx32 &quot;\n&quot;, operand);</a>
<a name="ln2211"> </a>
<a name="ln2212">					context.RestoreRegisterRule(operand);</a>
<a name="ln2213">					break;</a>
<a name="ln2214">				}</a>
<a name="ln2215">			}</a>
<a name="ln2216">		} else {</a>
<a name="ln2217">			switch (opcode) {</a>
<a name="ln2218">				case DW_CFA_nop:</a>
<a name="ln2219">				{</a>
<a name="ln2220">					TRACE_CFI(&quot;    DW_CFA_nop\n&quot;);</a>
<a name="ln2221">					break;</a>
<a name="ln2222">				}</a>
<a name="ln2223">				case DW_CFA_set_loc:</a>
<a name="ln2224">				{</a>
<a name="ln2225">					target_addr_t location = augmentation.ReadEncodedAddress(</a>
<a name="ln2226">							dataReader, fElfFile, fDebugFrameSection);</a>
<a name="ln2227"> </a>
<a name="ln2228">					TRACE_CFI(&quot;    DW_CFA_set_loc: %#&quot; B_PRIx64 &quot;\n&quot;, location);</a>
<a name="ln2229"> </a>
<a name="ln2230">					if (location &lt; context.Location())</a>
<a name="ln2231">						return B_BAD_VALUE;</a>
<a name="ln2232">					if (location &gt; context.TargetLocation())</a>
<a name="ln2233">						return B_OK;</a>
<a name="ln2234">					context.SetLocation(location);</a>
<a name="ln2235">					break;</a>
<a name="ln2236">				}</a>
<a name="ln2237">				case DW_CFA_advance_loc1:</a>
<a name="ln2238">				{</a>
<a name="ln2239">					uint32 delta = dataReader.Read&lt;uint8&gt;(0);</a>
<a name="ln2240"> </a>
<a name="ln2241">					TRACE_CFI(&quot;    DW_CFA_advance_loc1: %#&quot; B_PRIx32 &quot;\n&quot;,</a>
<a name="ln2242">						delta);</a>
<a name="ln2243"> </a>
<a name="ln2244">					target_addr_t location = context.Location()</a>
<a name="ln2245">						+ delta * context.CodeAlignment();</a>
<a name="ln2246">					if (location &gt; context.TargetLocation())</a>
<a name="ln2247">						return B_OK;</a>
<a name="ln2248">					context.SetLocation(location);</a>
<a name="ln2249">					break;</a>
<a name="ln2250">				}</a>
<a name="ln2251">				case DW_CFA_advance_loc2:</a>
<a name="ln2252">				{</a>
<a name="ln2253">					uint32 delta = dataReader.Read&lt;uint16&gt;(0);</a>
<a name="ln2254"> </a>
<a name="ln2255">					TRACE_CFI(&quot;    DW_CFA_advance_loc2: %#&quot; B_PRIx32 &quot;\n&quot;,</a>
<a name="ln2256">						delta);</a>
<a name="ln2257"> </a>
<a name="ln2258">					target_addr_t location = context.Location()</a>
<a name="ln2259">						+ delta * context.CodeAlignment();</a>
<a name="ln2260">					if (location &gt; context.TargetLocation())</a>
<a name="ln2261">						return B_OK;</a>
<a name="ln2262">					context.SetLocation(location);</a>
<a name="ln2263">					break;</a>
<a name="ln2264">				}</a>
<a name="ln2265">				case DW_CFA_advance_loc4:</a>
<a name="ln2266">				{</a>
<a name="ln2267">					uint32 delta = dataReader.Read&lt;uint32&gt;(0);</a>
<a name="ln2268"> </a>
<a name="ln2269">					TRACE_CFI(&quot;    DW_CFA_advance_loc4: %#&quot; B_PRIx32 &quot;\n&quot;,</a>
<a name="ln2270">						delta);</a>
<a name="ln2271"> </a>
<a name="ln2272">					target_addr_t location = context.Location()</a>
<a name="ln2273">						+ delta * context.CodeAlignment();</a>
<a name="ln2274">					if (location &gt; context.TargetLocation())</a>
<a name="ln2275">						return B_OK;</a>
<a name="ln2276">					context.SetLocation(location);</a>
<a name="ln2277">					break;</a>
<a name="ln2278">				}</a>
<a name="ln2279">				case DW_CFA_offset_extended:</a>
<a name="ln2280">				{</a>
<a name="ln2281">					uint32 reg = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln2282">					uint64 offset = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln2283"> </a>
<a name="ln2284">					TRACE_CFI(&quot;    DW_CFA_offset_extended: reg: %&quot; B_PRIu32 &quot;, &quot;</a>
<a name="ln2285">						&quot;offset: %&quot; B_PRIu64 &quot;\n&quot;, reg, offset);</a>
<a name="ln2286"> </a>
<a name="ln2287">					if (CfaRule* rule = context.RegisterRule(reg)) {</a>
<a name="ln2288">						rule-&gt;SetToLocationOffset(</a>
<a name="ln2289">							offset * context.DataAlignment());</a>
<a name="ln2290">					}</a>
<a name="ln2291">					break;</a>
<a name="ln2292">				}</a>
<a name="ln2293">				case DW_CFA_restore_extended:</a>
<a name="ln2294">				{</a>
<a name="ln2295">					uint32 reg = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln2296"> </a>
<a name="ln2297">					TRACE_CFI(&quot;    DW_CFA_restore_extended: %#&quot; B_PRIx32 &quot;\n&quot;,</a>
<a name="ln2298">						reg);</a>
<a name="ln2299"> </a>
<a name="ln2300">					context.RestoreRegisterRule(reg);</a>
<a name="ln2301">					break;</a>
<a name="ln2302">				}</a>
<a name="ln2303">				case DW_CFA_undefined:</a>
<a name="ln2304">				{</a>
<a name="ln2305">					uint32 reg = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln2306"> </a>
<a name="ln2307">					TRACE_CFI(&quot;    DW_CFA_undefined: %&quot; B_PRIu32 &quot;\n&quot;, reg);</a>
<a name="ln2308"> </a>
<a name="ln2309">					if (CfaRule* rule = context.RegisterRule(reg))</a>
<a name="ln2310">						rule-&gt;SetToUndefined();</a>
<a name="ln2311">					break;</a>
<a name="ln2312">				}</a>
<a name="ln2313">				case DW_CFA_same_value:</a>
<a name="ln2314">				{</a>
<a name="ln2315">					uint32 reg = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln2316"> </a>
<a name="ln2317">					TRACE_CFI(&quot;    DW_CFA_same_value: %&quot; B_PRIu32 &quot;\n&quot;, reg);</a>
<a name="ln2318"> </a>
<a name="ln2319">					if (CfaRule* rule = context.RegisterRule(reg))</a>
<a name="ln2320">						rule-&gt;SetToSameValue();</a>
<a name="ln2321">					break;</a>
<a name="ln2322">				}</a>
<a name="ln2323">				case DW_CFA_register:</a>
<a name="ln2324">				{</a>
<a name="ln2325">					uint32 reg1 = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln2326">					uint32 reg2 = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln2327"> </a>
<a name="ln2328">					TRACE_CFI(&quot;    DW_CFA_register: reg1: %&quot; B_PRIu32 &quot;, reg2: &quot;</a>
<a name="ln2329">						&quot;%&quot; B_PRIu32 &quot;\n&quot;, reg1, reg2);</a>
<a name="ln2330"> </a>
<a name="ln2331">					if (CfaRule* rule = context.RegisterRule(reg1))</a>
<a name="ln2332">						rule-&gt;SetToValueOffset(reg2);</a>
<a name="ln2333">					break;</a>
<a name="ln2334">				}</a>
<a name="ln2335">				case DW_CFA_remember_state:</a>
<a name="ln2336">				{</a>
<a name="ln2337">					TRACE_CFI(&quot;    DW_CFA_remember_state\n&quot;);</a>
<a name="ln2338"> </a>
<a name="ln2339">					status_t error = context.PushRuleSet();</a>
<a name="ln2340">					if (error != B_OK)</a>
<a name="ln2341">						return error;</a>
<a name="ln2342">					break;</a>
<a name="ln2343">				}</a>
<a name="ln2344">				case DW_CFA_restore_state:</a>
<a name="ln2345">				{</a>
<a name="ln2346">					TRACE_CFI(&quot;    DW_CFA_restore_state\n&quot;);</a>
<a name="ln2347"> </a>
<a name="ln2348">					status_t error = context.PopRuleSet();</a>
<a name="ln2349">					if (error != B_OK)</a>
<a name="ln2350">						return error;</a>
<a name="ln2351">					break;</a>
<a name="ln2352">				}</a>
<a name="ln2353">				case DW_CFA_def_cfa:</a>
<a name="ln2354">				{</a>
<a name="ln2355">					uint32 reg = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln2356">					uint64 offset = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln2357"> </a>
<a name="ln2358">					TRACE_CFI(&quot;    DW_CFA_def_cfa: reg: %&quot; B_PRIu32 &quot;, offset: &quot;</a>
<a name="ln2359">						&quot;%&quot; B_PRIu64 &quot;\n&quot;, reg, offset);</a>
<a name="ln2360"> </a>
<a name="ln2361">					context.GetCfaCfaRule()-&gt;SetToRegisterOffset(reg, offset);</a>
<a name="ln2362">					break;</a>
<a name="ln2363">				}</a>
<a name="ln2364">				case DW_CFA_def_cfa_register:</a>
<a name="ln2365">				{</a>
<a name="ln2366">					uint32 reg = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln2367"> </a>
<a name="ln2368">					TRACE_CFI(&quot;    DW_CFA_def_cfa_register: %&quot; B_PRIu32 &quot;\n&quot;,</a>
<a name="ln2369">						reg);</a>
<a name="ln2370"> </a>
<a name="ln2371">					if (context.GetCfaCfaRule()-&gt;Type()</a>
<a name="ln2372">							!= CFA_CFA_RULE_REGISTER_OFFSET) {</a>
<a name="ln2373">						return B_BAD_DATA;</a>
<a name="ln2374">					}</a>
<a name="ln2375">					context.GetCfaCfaRule()-&gt;SetRegister(reg);</a>
<a name="ln2376">					break;</a>
<a name="ln2377">				}</a>
<a name="ln2378">				case DW_CFA_def_cfa_offset:</a>
<a name="ln2379">				{</a>
<a name="ln2380">					uint64 offset = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln2381"> </a>
<a name="ln2382">					TRACE_CFI(&quot;    DW_CFA_def_cfa_offset: %&quot; B_PRIu64 &quot;\n&quot;,</a>
<a name="ln2383">						offset);</a>
<a name="ln2384"> </a>
<a name="ln2385">					if (context.GetCfaCfaRule()-&gt;Type()</a>
<a name="ln2386">							!= CFA_CFA_RULE_REGISTER_OFFSET) {</a>
<a name="ln2387">						return B_BAD_DATA;</a>
<a name="ln2388">					}</a>
<a name="ln2389">					context.GetCfaCfaRule()-&gt;SetOffset(offset);</a>
<a name="ln2390">					break;</a>
<a name="ln2391">				}</a>
<a name="ln2392">				case DW_CFA_def_cfa_expression:</a>
<a name="ln2393">				{</a>
<a name="ln2394">					uint64 blockLength = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln2395">					uint8* block = (uint8*)dataReader.Data();</a>
<a name="ln2396">					dataReader.Skip(blockLength);</a>
<a name="ln2397"> </a>
<a name="ln2398">					TRACE_CFI(&quot;    DW_CFA_def_cfa_expression: %p, %&quot; B_PRIu64</a>
<a name="ln2399">						&quot;\n&quot;, block, blockLength);</a>
<a name="ln2400"> </a>
<a name="ln2401">					context.GetCfaCfaRule()-&gt;SetToExpression(block,</a>
<a name="ln2402">						blockLength);</a>
<a name="ln2403">					break;</a>
<a name="ln2404">				}</a>
<a name="ln2405">				case DW_CFA_expression:</a>
<a name="ln2406">				{</a>
<a name="ln2407">					uint32 reg = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln2408">					uint64 blockLength = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln2409">					uint8* block = (uint8*)dataReader.Data();</a>
<a name="ln2410">					dataReader.Skip(blockLength);</a>
<a name="ln2411"> </a>
<a name="ln2412">					TRACE_CFI(&quot;    DW_CFA_expression: reg: %&quot; B_PRIu32 &quot;, &quot;</a>
<a name="ln2413">						&quot;block: %p, %&quot; B_PRIu64 &quot;\n&quot;, reg, block, blockLength);</a>
<a name="ln2414"> </a>
<a name="ln2415">					if (CfaRule* rule = context.RegisterRule(reg))</a>
<a name="ln2416">						rule-&gt;SetToLocationExpression(block, blockLength);</a>
<a name="ln2417">					break;</a>
<a name="ln2418">				}</a>
<a name="ln2419">				case DW_CFA_offset_extended_sf:</a>
<a name="ln2420">				{</a>
<a name="ln2421">					uint32 reg = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln2422">					int64 offset = dataReader.ReadSignedLEB128(0);</a>
<a name="ln2423"> </a>
<a name="ln2424">					TRACE_CFI(&quot;    DW_CFA_offset_extended: reg: %&quot; B_PRIu32 &quot;, &quot;</a>
<a name="ln2425">						&quot;offset: %&quot; B_PRId64 &quot;\n&quot;, reg, offset);</a>
<a name="ln2426"> </a>
<a name="ln2427">					if (CfaRule* rule = context.RegisterRule(reg)) {</a>
<a name="ln2428">						rule-&gt;SetToLocationOffset(</a>
<a name="ln2429">							offset * (int32)context.DataAlignment());</a>
<a name="ln2430">					}</a>
<a name="ln2431">					break;</a>
<a name="ln2432">				}</a>
<a name="ln2433">				case DW_CFA_def_cfa_sf:</a>
<a name="ln2434">				{</a>
<a name="ln2435">					uint32 reg = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln2436">					int64 offset = dataReader.ReadSignedLEB128(0);</a>
<a name="ln2437"> </a>
<a name="ln2438">					TRACE_CFI(&quot;    DW_CFA_def_cfa_sf: reg: %&quot; B_PRIu32 &quot;, &quot;</a>
<a name="ln2439">						&quot;offset: %&quot; B_PRId64 &quot;\n&quot;, reg, offset);</a>
<a name="ln2440"> </a>
<a name="ln2441">					context.GetCfaCfaRule()-&gt;SetToRegisterOffset(reg,</a>
<a name="ln2442">						offset * (int32)context.DataAlignment());</a>
<a name="ln2443">					break;</a>
<a name="ln2444">				}</a>
<a name="ln2445">				case DW_CFA_def_cfa_offset_sf:</a>
<a name="ln2446">				{</a>
<a name="ln2447">					int64 offset = dataReader.ReadSignedLEB128(0);</a>
<a name="ln2448"> </a>
<a name="ln2449">					TRACE_CFI(&quot;    DW_CFA_def_cfa_offset: %&quot; B_PRId64 &quot;\n&quot;,</a>
<a name="ln2450">						offset);</a>
<a name="ln2451"> </a>
<a name="ln2452">					if (context.GetCfaCfaRule()-&gt;Type()</a>
<a name="ln2453">							!= CFA_CFA_RULE_REGISTER_OFFSET) {</a>
<a name="ln2454">						return B_BAD_DATA;</a>
<a name="ln2455">					}</a>
<a name="ln2456">					context.GetCfaCfaRule()-&gt;SetOffset(</a>
<a name="ln2457">						offset * (int32)context.DataAlignment());</a>
<a name="ln2458">					break;</a>
<a name="ln2459">				}</a>
<a name="ln2460">				case DW_CFA_val_offset:</a>
<a name="ln2461">				{</a>
<a name="ln2462">					uint32 reg = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln2463">					uint64 offset = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln2464"> </a>
<a name="ln2465">					TRACE_CFI(&quot;    DW_CFA_val_offset: reg: %&quot; B_PRIu32 &quot;, &quot;</a>
<a name="ln2466">						&quot;offset: %&quot; B_PRIu64 &quot;\n&quot;, reg, offset);</a>
<a name="ln2467"> </a>
<a name="ln2468">					if (CfaRule* rule = context.RegisterRule(reg)) {</a>
<a name="ln2469">						rule-&gt;SetToValueOffset(</a>
<a name="ln2470">							offset * context.DataAlignment());</a>
<a name="ln2471">					}</a>
<a name="ln2472">					break;</a>
<a name="ln2473">				}</a>
<a name="ln2474">				case DW_CFA_val_offset_sf:</a>
<a name="ln2475">				{</a>
<a name="ln2476">					uint32 reg = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln2477">					int64 offset = dataReader.ReadSignedLEB128(0);</a>
<a name="ln2478"> </a>
<a name="ln2479">					TRACE_CFI(&quot;    DW_CFA_val_offset_sf: reg: %&quot; B_PRIu32 &quot;, &quot;</a>
<a name="ln2480">						&quot;offset: %&quot; B_PRId64 &quot;\n&quot;, reg, offset);</a>
<a name="ln2481"> </a>
<a name="ln2482">					if (CfaRule* rule = context.RegisterRule(reg)) {</a>
<a name="ln2483">						rule-&gt;SetToValueOffset(</a>
<a name="ln2484">							offset * (int32)context.DataAlignment());</a>
<a name="ln2485">					}</a>
<a name="ln2486">					break;</a>
<a name="ln2487">				}</a>
<a name="ln2488">				case DW_CFA_val_expression:</a>
<a name="ln2489">				{</a>
<a name="ln2490">					uint32 reg = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln2491">					uint64 blockLength = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln2492">					uint8* block = (uint8*)dataReader.Data();</a>
<a name="ln2493">					dataReader.Skip(blockLength);</a>
<a name="ln2494"> </a>
<a name="ln2495">					TRACE_CFI(&quot;    DW_CFA_val_expression: reg: %&quot; B_PRIu32 &quot;, &quot;</a>
<a name="ln2496">						&quot;block: %p, %&quot; B_PRIu64 &quot;\n&quot;, reg, block, blockLength);</a>
<a name="ln2497"> </a>
<a name="ln2498">					if (CfaRule* rule = context.RegisterRule(reg))</a>
<a name="ln2499">						rule-&gt;SetToValueExpression(block, blockLength);</a>
<a name="ln2500">					break;</a>
<a name="ln2501">				}</a>
<a name="ln2502"> </a>
<a name="ln2503">				// extensions</a>
<a name="ln2504">				case DW_CFA_MIPS_advance_loc8:</a>
<a name="ln2505">				{</a>
<a name="ln2506">					uint64 delta = dataReader.Read&lt;uint64&gt;(0);</a>
<a name="ln2507"> </a>
<a name="ln2508">					TRACE_CFI(&quot;    DW_CFA_MIPS_advance_loc8: %#&quot; B_PRIx64 &quot;\n&quot;,</a>
<a name="ln2509">						delta);</a>
<a name="ln2510"> </a>
<a name="ln2511">					target_addr_t location = context.Location()</a>
<a name="ln2512">						+ delta * context.CodeAlignment();</a>
<a name="ln2513">					if (location &gt; context.TargetLocation())</a>
<a name="ln2514">						return B_OK;</a>
<a name="ln2515">					context.SetLocation(location);</a>
<a name="ln2516">					break;</a>
<a name="ln2517">				}</a>
<a name="ln2518">				case DW_CFA_GNU_window_save:</a>
<a name="ln2519">				{</a>
<a name="ln2520">					// SPARC specific, no args</a>
<a name="ln2521">					TRACE_CFI(&quot;    DW_CFA_GNU_window_save\n&quot;);</a>
<a name="ln2522"> </a>
<a name="ln2523">					// TODO: Implement once we have SPARC support!</a>
<a name="ln2524">					break;</a>
<a name="ln2525">				}</a>
<a name="ln2526">				case DW_CFA_GNU_args_size:</a>
<a name="ln2527">				{</a>
<a name="ln2528">					// Updates the total size of arguments on the stack.</a>
<a name="ln2529">					TRACE_CFI_ONLY(uint64 size =)</a>
<a name="ln2530">						dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln2531"> </a>
<a name="ln2532">					TRACE_CFI(&quot;    DW_CFA_GNU_args_size: %&quot; B_PRIu64 &quot;\n&quot;,</a>
<a name="ln2533">						size);</a>
<a name="ln2534">// TODO: Implement!</a>
<a name="ln2535">					break;</a>
<a name="ln2536">				}</a>
<a name="ln2537">				case DW_CFA_GNU_negative_offset_extended:</a>
<a name="ln2538">				{</a>
<a name="ln2539">					// obsolete</a>
<a name="ln2540">					uint32 reg = dataReader.ReadUnsignedLEB128(0);</a>
<a name="ln2541">					int64 offset = dataReader.ReadSignedLEB128(0);</a>
<a name="ln2542"> </a>
<a name="ln2543">					TRACE_CFI(&quot;    DW_CFA_GNU_negative_offset_extended: &quot;</a>
<a name="ln2544">						&quot;reg: %&quot; B_PRIu32 &quot;, offset: %&quot; B_PRId64 &quot;\n&quot;, reg,</a>
<a name="ln2545">						offset);</a>
<a name="ln2546"> </a>
<a name="ln2547">					if (CfaRule* rule = context.RegisterRule(reg)) {</a>
<a name="ln2548">						rule-&gt;SetToLocationOffset(</a>
<a name="ln2549">							offset * (int32)context.DataAlignment());</a>
<a name="ln2550">					}</a>
<a name="ln2551">					break;</a>
<a name="ln2552">				}</a>
<a name="ln2553"> </a>
<a name="ln2554">				default:</a>
<a name="ln2555">					TRACE_CFI(&quot;    unknown opcode %u!\n&quot;, opcode);</a>
<a name="ln2556">					return B_BAD_DATA;</a>
<a name="ln2557">			}</a>
<a name="ln2558">		}</a>
<a name="ln2559">	}</a>
<a name="ln2560"> </a>
<a name="ln2561">	return B_OK;</a>
<a name="ln2562">}</a>
<a name="ln2563"> </a>
<a name="ln2564"> </a>
<a name="ln2565">status_t</a>
<a name="ln2566">DwarfFile::_ParsePublicTypesInfo()</a>
<a name="ln2567">{</a>
<a name="ln2568">	TRACE_PUBTYPES(&quot;DwarfFile::_ParsePublicTypesInfo()\n&quot;);</a>
<a name="ln2569">	if (fDebugPublicTypesSection == NULL) {</a>
<a name="ln2570">		TRACE_PUBTYPES(&quot;  -&gt; no public types section\n&quot;);</a>
<a name="ln2571">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln2572">	}</a>
<a name="ln2573"> </a>
<a name="ln2574">	DataReader dataReader((uint8*)fDebugPublicTypesSection-&gt;Data(),</a>
<a name="ln2575">		fDebugPublicTypesSection-&gt;Size(), 4);</a>
<a name="ln2576">		// address size doesn't matter at this point</a>
<a name="ln2577"> </a>
<a name="ln2578">	while (dataReader.BytesRemaining() &gt; 0) {</a>
<a name="ln2579">		bool dwarf64;</a>
<a name="ln2580">		uint64 unitLength = dataReader.ReadInitialLength(dwarf64);</a>
<a name="ln2581"> </a>
<a name="ln2582">		off_t unitLengthOffset = dataReader.Offset();</a>
<a name="ln2583">			// the unitLength starts here</a>
<a name="ln2584"> </a>
<a name="ln2585">		if (dataReader.HasOverflow())</a>
<a name="ln2586">			return B_BAD_DATA;</a>
<a name="ln2587"> </a>
<a name="ln2588">		if (unitLengthOffset + unitLength</a>
<a name="ln2589">				&gt; (uint64)fDebugPublicTypesSection-&gt;Size()) {</a>
<a name="ln2590">			WARNING(&quot;Invalid public types set unit length.\n&quot;);</a>
<a name="ln2591">			break;</a>
<a name="ln2592">		}</a>
<a name="ln2593"> </a>
<a name="ln2594">		DataReader unitDataReader(dataReader.Data(), unitLength, 4);</a>
<a name="ln2595">			// address size doesn't matter</a>
<a name="ln2596">		_ParsePublicTypesInfo(unitDataReader, dwarf64);</a>
<a name="ln2597"> </a>
<a name="ln2598">		dataReader.SeekAbsolute(unitLengthOffset + unitLength);</a>
<a name="ln2599">	}</a>
<a name="ln2600"> </a>
<a name="ln2601">	return B_OK;</a>
<a name="ln2602">}</a>
<a name="ln2603"> </a>
<a name="ln2604"> </a>
<a name="ln2605">status_t</a>
<a name="ln2606">DwarfFile::_ParsePublicTypesInfo(DataReader&amp; dataReader, bool dwarf64)</a>
<a name="ln2607">{</a>
<a name="ln2608">	int version = dataReader.Read&lt;uint16&gt;(0);</a>
<a name="ln2609">	if (version != 2) {</a>
<a name="ln2610">		TRACE_PUBTYPES(&quot;  pubtypes version %d unsupported\n&quot;, version);</a>
<a name="ln2611">		return B_UNSUPPORTED;</a>
<a name="ln2612">	}</a>
<a name="ln2613"> </a>
<a name="ln2614">	TRACE_PUBTYPES_ONLY(off_t debugInfoOffset =) dwarf64</a>
<a name="ln2615">		? dataReader.Read&lt;uint64&gt;(0)</a>
<a name="ln2616">		: (uint64)dataReader.Read&lt;uint32&gt;(0);</a>
<a name="ln2617">	TRACE_PUBTYPES_ONLY(off_t debugInfoSize =) dwarf64</a>
<a name="ln2618">		? dataReader.Read&lt;uint64&gt;(0)</a>
<a name="ln2619">		: (uint64)dataReader.Read&lt;uint32&gt;(0);</a>
<a name="ln2620"> </a>
<a name="ln2621">	if (dataReader.HasOverflow())</a>
<a name="ln2622">		return B_BAD_DATA;</a>
<a name="ln2623"> </a>
<a name="ln2624">	TRACE_PUBTYPES(&quot;DwarfFile::_ParsePublicTypesInfo(): compilation unit debug &quot;</a>
<a name="ln2625">		&quot;info: (%&quot; B_PRIdOFF &quot;, %&quot; B_PRIdOFF &quot;)\n&quot;, debugInfoOffset,</a>
<a name="ln2626">		debugInfoSize);</a>
<a name="ln2627"> </a>
<a name="ln2628">	while (dataReader.BytesRemaining() &gt; 0) {</a>
<a name="ln2629">		off_t entryOffset = dwarf64</a>
<a name="ln2630">			? dataReader.Read&lt;uint64&gt;(0)</a>
<a name="ln2631">			: (uint64)dataReader.Read&lt;uint32&gt;(0);</a>
<a name="ln2632">		if (entryOffset == 0)</a>
<a name="ln2633">			return B_OK;</a>
<a name="ln2634"> </a>
<a name="ln2635">		TRACE_PUBTYPES_ONLY(const char* name =) dataReader.ReadString();</a>
<a name="ln2636"> </a>
<a name="ln2637">		TRACE_PUBTYPES(&quot;  \&quot;%s\&quot; -&gt; %&quot; B_PRIdOFF &quot;\n&quot;, name, entryOffset);</a>
<a name="ln2638">	}</a>
<a name="ln2639"> </a>
<a name="ln2640">	return B_OK;</a>
<a name="ln2641">}</a>
<a name="ln2642"> </a>
<a name="ln2643"> </a>
<a name="ln2644">status_t</a>
<a name="ln2645">DwarfFile::_GetAbbreviationTable(off_t offset, AbbreviationTable*&amp; _table)</a>
<a name="ln2646">{</a>
<a name="ln2647">	// check, whether we've already loaded it</a>
<a name="ln2648">	for (AbbreviationTableList::Iterator it</a>
<a name="ln2649">				= fAbbreviationTables.GetIterator();</a>
<a name="ln2650">			AbbreviationTable* table = it.Next();) {</a>
<a name="ln2651">		if (offset == table-&gt;Offset()) {</a>
<a name="ln2652">			_table = table;</a>
<a name="ln2653">			return B_OK;</a>
<a name="ln2654">		}</a>
<a name="ln2655">	}</a>
<a name="ln2656"> </a>
<a name="ln2657">	// create a new table</a>
<a name="ln2658">	AbbreviationTable* table = new(std::nothrow) AbbreviationTable(offset);</a>
<a name="ln2659">	if (table == NULL)</a>
<a name="ln2660">		return B_NO_MEMORY;</a>
<a name="ln2661"> </a>
<a name="ln2662">	status_t error = table-&gt;Init(fDebugAbbrevSection-&gt;Data(),</a>
<a name="ln2663">		fDebugAbbrevSection-&gt;Size());</a>
<a name="ln2664">	if (error != B_OK) {</a>
<a name="ln2665">		delete table;</a>
<a name="ln2666">		return error;</a>
<a name="ln2667">	}</a>
<a name="ln2668"> </a>
<a name="ln2669">	fAbbreviationTables.Add(table);</a>
<a name="ln2670">	_table = table;</a>
<a name="ln2671">	return B_OK;</a>
<a name="ln2672">}</a>
<a name="ln2673"> </a>
<a name="ln2674"> </a>
<a name="ln2675">DebugInfoEntry*</a>
<a name="ln2676">DwarfFile::_ResolveReference(BaseUnit* unit, uint64 offset,</a>
<a name="ln2677">	uint8 refType) const</a>
<a name="ln2678">{</a>
<a name="ln2679">	switch (refType) {</a>
<a name="ln2680">		case dwarf_reference_type_local:</a>
<a name="ln2681">			return unit-&gt;EntryForOffset(offset);</a>
<a name="ln2682">			break;</a>
<a name="ln2683">		case dwarf_reference_type_global:</a>
<a name="ln2684">		{</a>
<a name="ln2685">			CompilationUnit* unit = _GetContainingCompilationUnit(offset);</a>
<a name="ln2686">			if (unit == NULL)</a>
<a name="ln2687">				break;</a>
<a name="ln2688"> </a>
<a name="ln2689">			offset -= unit-&gt;HeaderOffset();</a>
<a name="ln2690">			DebugInfoEntry* entry = unit-&gt;EntryForOffset(offset);</a>
<a name="ln2691">			if (entry != NULL)</a>
<a name="ln2692">				return entry;</a>
<a name="ln2693">			break;</a>
<a name="ln2694">		}</a>
<a name="ln2695">		case dwarf_reference_type_signature:</a>
<a name="ln2696">		{</a>
<a name="ln2697">			TRACE_DIE(&quot;Resolving signature %#&quot; B_PRIx64 &quot;\n&quot;, offset);</a>
<a name="ln2698">			TypeUnitTableEntry* entry = fTypeUnits.Lookup(offset);</a>
<a name="ln2699">			if (entry != NULL &amp;&amp; entry-&gt;unit != NULL)</a>
<a name="ln2700">				return entry-&gt;unit-&gt;TypeEntry();</a>
<a name="ln2701">			break;</a>
<a name="ln2702">		}</a>
<a name="ln2703">	}</a>
<a name="ln2704"> </a>
<a name="ln2705">	return NULL;</a>
<a name="ln2706">}</a>
<a name="ln2707"> </a>
<a name="ln2708"> </a>
<a name="ln2709">status_t</a>
<a name="ln2710">DwarfFile::_GetLocationExpression(CompilationUnit* unit,</a>
<a name="ln2711">	const LocationDescription* location, target_addr_t instructionPointer,</a>
<a name="ln2712">	const void*&amp; _expression, off_t&amp; _length) const</a>
<a name="ln2713">{</a>
<a name="ln2714">	if (!location-&gt;IsValid())</a>
<a name="ln2715">		return B_BAD_VALUE;</a>
<a name="ln2716"> </a>
<a name="ln2717">	if (location-&gt;IsExpression()) {</a>
<a name="ln2718">		_expression = location-&gt;expression.data;</a>
<a name="ln2719">		_length = location-&gt;expression.length;</a>
<a name="ln2720">		return B_OK;</a>
<a name="ln2721">	}</a>
<a name="ln2722"> </a>
<a name="ln2723">	if (location-&gt;IsLocationList() &amp;&amp; instructionPointer != 0) {</a>
<a name="ln2724">		return _FindLocationExpression(unit, location-&gt;listOffset,</a>
<a name="ln2725">			instructionPointer, _expression, _length);</a>
<a name="ln2726">	}</a>
<a name="ln2727"> </a>
<a name="ln2728">	return B_BAD_VALUE;</a>
<a name="ln2729">}</a>
<a name="ln2730"> </a>
<a name="ln2731"> </a>
<a name="ln2732">status_t</a>
<a name="ln2733">DwarfFile::_FindLocationExpression(CompilationUnit* unit, uint64 offset,</a>
<a name="ln2734">	target_addr_t address, const void*&amp; _expression, off_t&amp; _length) const</a>
<a name="ln2735">{</a>
<a name="ln2736">	if (unit == NULL)</a>
<a name="ln2737">		return B_BAD_VALUE;</a>
<a name="ln2738"> </a>
<a name="ln2739">	if (fDebugLocationSection == NULL)</a>
<a name="ln2740">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln2741"> </a>
<a name="ln2742">	if (offset &lt; 0 || offset &gt;= (uint64)fDebugLocationSection-&gt;Size())</a>
<a name="ln2743">		return B_BAD_DATA;</a>
<a name="ln2744"> </a>
<a name="ln2745">	target_addr_t baseAddress = unit-&gt;AddressRangeBase();</a>
<a name="ln2746">	target_addr_t maxAddress = unit-&gt;MaxAddress();</a>
<a name="ln2747"> </a>
<a name="ln2748">	DataReader dataReader((uint8*)fDebugLocationSection-&gt;Data() + offset,</a>
<a name="ln2749">		fDebugLocationSection-&gt;Size() - offset, unit-&gt;AddressSize());</a>
<a name="ln2750">	while (true) {</a>
<a name="ln2751">		target_addr_t start = dataReader.ReadAddress(0);</a>
<a name="ln2752">		target_addr_t end = dataReader.ReadAddress(0);</a>
<a name="ln2753">		if (dataReader.HasOverflow())</a>
<a name="ln2754">			return B_BAD_DATA;</a>
<a name="ln2755"> </a>
<a name="ln2756">		if (start == 0 &amp;&amp; end == 0)</a>
<a name="ln2757">			return B_ENTRY_NOT_FOUND;</a>
<a name="ln2758"> </a>
<a name="ln2759">		if (start == maxAddress) {</a>
<a name="ln2760">			baseAddress = end;</a>
<a name="ln2761">			continue;</a>
<a name="ln2762">		}</a>
<a name="ln2763"> </a>
<a name="ln2764">		uint16 expressionLength = dataReader.Read&lt;uint16&gt;(0);</a>
<a name="ln2765">		const void* expression = dataReader.Data();</a>
<a name="ln2766">		if (!dataReader.Skip(expressionLength))</a>
<a name="ln2767">			return B_BAD_DATA;</a>
<a name="ln2768"> </a>
<a name="ln2769">		if (start == end)</a>
<a name="ln2770">			continue;</a>
<a name="ln2771"> </a>
<a name="ln2772">		start += baseAddress;</a>
<a name="ln2773">		end += baseAddress;</a>
<a name="ln2774"> </a>
<a name="ln2775">		if (address &gt;= start &amp;&amp; address &lt; end) {</a>
<a name="ln2776">			_expression = expression;</a>
<a name="ln2777">			_length = expressionLength;</a>
<a name="ln2778">			return B_OK;</a>
<a name="ln2779">		}</a>
<a name="ln2780">	}</a>
<a name="ln2781">}</a>
<a name="ln2782"> </a>
<a name="ln2783"> </a>
<a name="ln2784">status_t</a>
<a name="ln2785">DwarfFile::_LocateDebugInfo(BString&amp; _requiredExternalFileName,</a>
<a name="ln2786">	const char* locatedFilePath)</a>
<a name="ln2787">{</a>
<a name="ln2788">	ElfFile* debugInfoFile = fElfFile;</a>
<a name="ln2789">	ElfSection* debugLinkSection = fElfFile-&gt;GetSection(&quot;.gnu_debuglink&quot;);</a>
<a name="ln2790">	if (debugLinkSection != NULL) {</a>
<a name="ln2791">		AutoSectionPutter putter(fElfFile, debugLinkSection);</a>
<a name="ln2792"> </a>
<a name="ln2793">		// the file specifies a debug link, look at its target instead</a>
<a name="ln2794">		// for debug information.</a>
<a name="ln2795">		// Format: null-terminated filename, as many 0 padding bytes as</a>
<a name="ln2796">		// needed to reach the next 32-bit address boundary, followed</a>
<a name="ln2797">		// by a 32-bit CRC</a>
<a name="ln2798"> </a>
<a name="ln2799">		BString debugPath;</a>
<a name="ln2800">		if (locatedFilePath)</a>
<a name="ln2801">			debugPath = locatedFilePath;</a>
<a name="ln2802">		else {</a>
<a name="ln2803">			status_t result = _GetDebugInfoPath(</a>
<a name="ln2804">				(const char*)debugLinkSection-&gt;Data(),</a>
<a name="ln2805">				_requiredExternalFileName);</a>
<a name="ln2806">			if (result != B_OK)</a>
<a name="ln2807">				return result;</a>
<a name="ln2808">			debugPath = _requiredExternalFileName;</a>
<a name="ln2809">		}</a>
<a name="ln2810"> </a>
<a name="ln2811">		if (fAlternateName != NULL)</a>
<a name="ln2812">			free(fAlternateName);</a>
<a name="ln2813"> </a>
<a name="ln2814">		fAlternateName = strdup(debugPath.String());</a>
<a name="ln2815"> </a>
<a name="ln2816">		if (fAlternateName == NULL)</a>
<a name="ln2817">			return B_NO_MEMORY;</a>
<a name="ln2818"> </a>
<a name="ln2819">/*</a>
<a name="ln2820">		// TODO: validate CRC</a>
<a name="ln2821">		int32 debugCRC = *(int32*)((char*)debugLinkSection-&gt;Data()</a>
<a name="ln2822">			+ debugLinkSection-&gt;Size() - sizeof(int32));</a>
<a name="ln2823">*/</a>
<a name="ln2824">		if (fAlternateElfFile == NULL) {</a>
<a name="ln2825">			fAlternateElfFile = new(std::nothrow) ElfFile;</a>
<a name="ln2826">			if (fAlternateElfFile == NULL)</a>
<a name="ln2827">				return B_NO_MEMORY;</a>
<a name="ln2828">		}</a>
<a name="ln2829"> </a>
<a name="ln2830">		status_t result = fAlternateElfFile-&gt;Init(fAlternateName);</a>
<a name="ln2831">		if (result != B_OK)</a>
<a name="ln2832">			return result;</a>
<a name="ln2833"> </a>
<a name="ln2834">		debugInfoFile = fAlternateElfFile;</a>
<a name="ln2835">	}</a>
<a name="ln2836"> </a>
<a name="ln2837">	// get the interesting sections</a>
<a name="ln2838">	fDebugInfoSection = debugInfoFile-&gt;GetSection(&quot;.debug_info&quot;);</a>
<a name="ln2839">	fDebugAbbrevSection = debugInfoFile-&gt;GetSection(&quot;.debug_abbrev&quot;);</a>
<a name="ln2840">	if (fDebugInfoSection == NULL || fDebugAbbrevSection == NULL) {</a>
<a name="ln2841">		WARNING(&quot;DwarfManager::File::Load(\&quot;%s\&quot;): no &quot;</a>
<a name="ln2842">			&quot;.debug_info or .debug_abbrev.\n&quot;, fName);</a>
<a name="ln2843"> </a>
<a name="ln2844">		// if we at least have an EH frame, use that for stack unwinding</a>
<a name="ln2845">		// if nothing else.</a>
<a name="ln2846">		fEHFrameSection = fElfFile-&gt;GetSection(&quot;.eh_frame&quot;);</a>
<a name="ln2847">		if (fEHFrameSection == NULL)</a>
<a name="ln2848">			return B_ERROR;</a>
<a name="ln2849">	}</a>
<a name="ln2850"> </a>
<a name="ln2851">	return B_OK;</a>
<a name="ln2852">}</a>
<a name="ln2853"> </a>
<a name="ln2854"> </a>
<a name="ln2855">status_t</a>
<a name="ln2856">DwarfFile::_GetDebugInfoPath(const char* debugFileName,</a>
<a name="ln2857">	BString&amp; _infoPath) const</a>
<a name="ln2858">{</a>
<a name="ln2859">	// first, see if we have a relative match to our local directory</a>
<a name="ln2860">	BPath basePath;</a>
<a name="ln2861">	status_t result = basePath.SetTo(fName);</a>
<a name="ln2862">	if (result != B_OK)</a>
<a name="ln2863">		return result;</a>
<a name="ln2864">	basePath.GetParent(&amp;basePath);</a>
<a name="ln2865">	if (strcmp(basePath.Leaf(), &quot;lib&quot;) == 0 || strcmp(basePath.Leaf(),</a>
<a name="ln2866">			&quot;add-ons&quot;) == 0) {</a>
<a name="ln2867">		_infoPath.SetToFormat(&quot;%s/../debug/%s&quot;, basePath.Path(),</a>
<a name="ln2868">			debugFileName);</a>
<a name="ln2869">	} else</a>
<a name="ln2870">		_infoPath.SetToFormat(&quot;%s/debug/%s&quot;, basePath.Path(), debugFileName);</a>
<a name="ln2871"> </a>
<a name="ln2872">	BEntry entry(_infoPath.String());</a>
<a name="ln2873">	result = entry.InitCheck();</a>
<a name="ln2874">	if (result != B_OK &amp;&amp; result != B_ENTRY_NOT_FOUND)</a>
<a name="ln2875">		return result;</a>
<a name="ln2876">	if (entry.Exists())</a>
<a name="ln2877">		return B_OK;</a>
<a name="ln2878"> </a>
<a name="ln2879">	// If the above search failed, check if our image is located in any</a>
<a name="ln2880">	// of the system installation paths, and attempt to locate the debug info</a>
<a name="ln2881">	// file in the corresponding well-known location</a>
<a name="ln2882">	BString pathSuffix;</a>
<a name="ln2883">	pathSuffix.SetToFormat(&quot;debug/%s&quot;, debugFileName);</a>
<a name="ln2884"> </a>
<a name="ln2885">	BPathFinder finder(fName);</a>
<a name="ln2886">	result = finder.FindPath(B_FIND_PATH_DEVELOP_DIRECTORY,</a>
<a name="ln2887">		pathSuffix.String(), B_FIND_PATH_EXISTING_ONLY, basePath);</a>
<a name="ln2888">	if (result == B_OK) {</a>
<a name="ln2889">		_infoPath = basePath.Path();</a>
<a name="ln2890">		return B_OK;</a>
<a name="ln2891">	} else {</a>
<a name="ln2892">		// if we failed to find a match, then it's up to the user to</a>
<a name="ln2893">		// locate it. As such, return the external info file name</a>
<a name="ln2894">		// for user interface purposes.</a>
<a name="ln2895">		_infoPath.SetTo(debugFileName);</a>
<a name="ln2896">	}</a>
<a name="ln2897"> </a>
<a name="ln2898">	return B_ENTRY_NOT_FOUND;</a>
<a name="ln2899">}</a>
<a name="ln2900"> </a>
<a name="ln2901"> </a>
<a name="ln2902">TypeUnitTableEntry*</a>
<a name="ln2903">DwarfFile::_GetTypeUnit(uint64 signature) const</a>
<a name="ln2904">{</a>
<a name="ln2905">	return fTypeUnits.Lookup(signature);</a>
<a name="ln2906">}</a>
<a name="ln2907"> </a>
<a name="ln2908"> </a>
<a name="ln2909">CompilationUnit*</a>
<a name="ln2910">DwarfFile::_GetContainingCompilationUnit(off_t refAddr) const</a>
<a name="ln2911">{</a>
<a name="ln2912">	if (fCompilationUnits.IsEmpty())</a>
<a name="ln2913">		return NULL;</a>
<a name="ln2914"> </a>
<a name="ln2915">	// binary search</a>
<a name="ln2916">	int lower = 0;</a>
<a name="ln2917">	int upper = fCompilationUnits.CountItems() - 1;</a>
<a name="ln2918">	while (lower &lt; upper) {</a>
<a name="ln2919">		int mid = (lower + upper + 1) / 2;</a>
<a name="ln2920">		if (fCompilationUnits.ItemAt(mid)-&gt;HeaderOffset() &gt; refAddr)</a>
<a name="ln2921">			upper = mid - 1;</a>
<a name="ln2922">		else</a>
<a name="ln2923">			lower = mid;</a>
<a name="ln2924">	}</a>
<a name="ln2925"> </a>
<a name="ln2926">	CompilationUnit* unit = fCompilationUnits.ItemAt(lower);</a>
<a name="ln2927">	return unit-&gt;ContainsAbsoluteOffset(refAddr) ? unit : NULL;</a>
<a name="ln2928">}</a>
<a name="ln2929"> </a>
<a name="ln2930"> </a>
<a name="ln2931">DwarfFile::FDELookupInfo*</a>
<a name="ln2932">DwarfFile::_GetContainingFDEInfo(target_addr_t offset) const</a>
<a name="ln2933">{</a>
<a name="ln2934">	FDELookupInfo* info = NULL;</a>
<a name="ln2935">	if (fDebugFrameSection != NULL) {</a>
<a name="ln2936">		info = _GetContainingFDEInfo(offset, fDebugFrameInfos);</a>
<a name="ln2937">		if (info != NULL)</a>
<a name="ln2938">			return info;</a>
<a name="ln2939">	}</a>
<a name="ln2940"> </a>
<a name="ln2941">	return _GetContainingFDEInfo(offset, fEHFrameInfos);</a>
<a name="ln2942">}</a>
<a name="ln2943"> </a>
<a name="ln2944"> </a>
<a name="ln2945">DwarfFile::FDELookupInfo*</a>
<a name="ln2946">DwarfFile::_GetContainingFDEInfo(target_addr_t offset,</a>
<a name="ln2947">	const FDEInfoList&amp; infoList) const</a>
<a name="ln2948">{</a>
<a name="ln2949">	// binary search</a>
<a name="ln2950">	int lower = 0;</a>
<a name="ln2951">	int upper = infoList.CountItems() - 1;</a>
<a name="ln2952">	if (upper &lt; 0)</a>
<a name="ln2953">		return NULL;</a>
<a name="ln2954"> </a>
<a name="ln2955">	while (lower &lt; upper) {</a>
<a name="ln2956">		int mid = (lower + upper + 1) / 2;</a>
<a name="ln2957">		if (offset &lt; infoList.ItemAt(mid)-&gt;start)</a>
<a name="ln2958">			upper = mid - 1;</a>
<a name="ln2959">		else</a>
<a name="ln2960">			lower = mid;</a>
<a name="ln2961">	}</a>
<a name="ln2962"> </a>
<a name="ln2963">	FDELookupInfo* info = infoList.ItemAt(lower);</a>
<a name="ln2964">	return info-&gt;ContainsAddress(offset) ? info : NULL;</a>
<a name="ln2965">}</a>

</code></pre>
<div class="balloon" rel="1947"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'remaining < 0' is always false. Unsigned type value is never < 0.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
