
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>if_ath.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting</a>
<a name="ln5"> * All rights reserved.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln8"> * modification, are permitted provided that the following conditions</a>
<a name="ln9"> * are met:</a>
<a name="ln10"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln11"> *    notice, this list of conditions and the following disclaimer,</a>
<a name="ln12"> *    without modification.</a>
<a name="ln13"> * 2. Redistributions in binary form must reproduce at minimum a disclaimer</a>
<a name="ln14"> *    similar to the &quot;NO WARRANTY&quot; disclaimer below (&quot;Disclaimer&quot;) and any</a>
<a name="ln15"> *    redistribution must be conditioned upon including a substantially</a>
<a name="ln16"> *    similar Disclaimer requirement for further binary redistribution.</a>
<a name="ln17"> *</a>
<a name="ln18"> * NO WARRANTY</a>
<a name="ln19"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</a>
<a name="ln20"> * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</a>
<a name="ln21"> * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY</a>
<a name="ln22"> * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL</a>
<a name="ln23"> * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,</a>
<a name="ln24"> * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</a>
<a name="ln25"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</a>
<a name="ln26"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER</a>
<a name="ln27"> * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</a>
<a name="ln28"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF</a>
<a name="ln29"> * THE POSSIBILITY OF SUCH DAMAGES.</a>
<a name="ln30"> */</a>
<a name="ln31"> </a>
<a name="ln32">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln33">__FBSDID(&quot;$FreeBSD: releng/12.0/sys/dev/ath/if_ath.c 336016 2018-07-05 21:38:54Z cem $&quot;);</a>
<a name="ln34"> </a>
<a name="ln35">/*</a>
<a name="ln36"> * Driver for the Atheros Wireless LAN controller.</a>
<a name="ln37"> *</a>
<a name="ln38"> * This software is derived from work of Atsushi Onoe; his contribution</a>
<a name="ln39"> * is greatly appreciated.</a>
<a name="ln40"> */</a>
<a name="ln41"> </a>
<a name="ln42">#include &quot;opt_inet.h&quot;</a>
<a name="ln43">#include &quot;opt_ath.h&quot;</a>
<a name="ln44">/*</a>
<a name="ln45"> * This is needed for register operations which are performed</a>
<a name="ln46"> * by the driver - eg, calls to ath_hal_gettsf32().</a>
<a name="ln47"> *</a>
<a name="ln48"> * It's also required for any AH_DEBUG checks in here, eg the</a>
<a name="ln49"> * module dependencies.</a>
<a name="ln50"> */</a>
<a name="ln51">#include &quot;opt_ah.h&quot;</a>
<a name="ln52">#include &quot;opt_wlan.h&quot;</a>
<a name="ln53"> </a>
<a name="ln54">#include &lt;sys/param.h&gt;</a>
<a name="ln55">#include &lt;sys/systm.h&gt;</a>
<a name="ln56">#include &lt;sys/sysctl.h&gt;</a>
<a name="ln57">#include &lt;sys/mbuf.h&gt;</a>
<a name="ln58">#include &lt;sys/malloc.h&gt;</a>
<a name="ln59">#include &lt;sys/lock.h&gt;</a>
<a name="ln60">#include &lt;sys/mutex.h&gt;</a>
<a name="ln61">#include &lt;sys/kernel.h&gt;</a>
<a name="ln62">#include &lt;sys/socket.h&gt;</a>
<a name="ln63">#include &lt;sys/sockio.h&gt;</a>
<a name="ln64">#include &lt;sys/errno.h&gt;</a>
<a name="ln65">#include &lt;sys/callout.h&gt;</a>
<a name="ln66">#include &lt;sys/bus.h&gt;</a>
<a name="ln67">#include &lt;sys/endian.h&gt;</a>
<a name="ln68">#include &lt;sys/kthread.h&gt;</a>
<a name="ln69">#include &lt;sys/taskqueue.h&gt;</a>
<a name="ln70">#include &lt;sys/priv.h&gt;</a>
<a name="ln71">#include &lt;sys/module.h&gt;</a>
<a name="ln72">#include &lt;sys/ktr.h&gt;</a>
<a name="ln73">#include &lt;sys/smp.h&gt;	/* for mp_ncpus */</a>
<a name="ln74"> </a>
<a name="ln75">#include &lt;machine/bus.h&gt;</a>
<a name="ln76"> </a>
<a name="ln77">#include &lt;net/if.h&gt;</a>
<a name="ln78">#include &lt;net/if_var.h&gt;</a>
<a name="ln79">#include &lt;net/if_dl.h&gt;</a>
<a name="ln80">#include &lt;net/if_media.h&gt;</a>
<a name="ln81">#include &lt;net/if_types.h&gt;</a>
<a name="ln82">#include &lt;net/if_arp.h&gt;</a>
<a name="ln83">#include &lt;net/ethernet.h&gt;</a>
<a name="ln84">#include &lt;net/if_llc.h&gt;</a>
<a name="ln85"> </a>
<a name="ln86">#include &lt;net80211/ieee80211_var.h&gt;</a>
<a name="ln87">#include &lt;net80211/ieee80211_regdomain.h&gt;</a>
<a name="ln88">#ifdef IEEE80211_SUPPORT_SUPERG</a>
<a name="ln89">#include &lt;net80211/ieee80211_superg.h&gt;</a>
<a name="ln90">#endif</a>
<a name="ln91">#ifdef IEEE80211_SUPPORT_TDMA</a>
<a name="ln92">#include &lt;net80211/ieee80211_tdma.h&gt;</a>
<a name="ln93">#endif</a>
<a name="ln94"> </a>
<a name="ln95">#include &lt;net/bpf.h&gt;</a>
<a name="ln96"> </a>
<a name="ln97">#ifdef INET</a>
<a name="ln98">#include &lt;netinet/in.h&gt;</a>
<a name="ln99">#include &lt;netinet/if_ether.h&gt;</a>
<a name="ln100">#endif</a>
<a name="ln101"> </a>
<a name="ln102">#include &lt;dev/ath/if_athvar.h&gt;</a>
<a name="ln103">#include &lt;dev/ath/ath_hal/ah_devid.h&gt;		/* XXX for softled */</a>
<a name="ln104">#include &lt;dev/ath/ath_hal/ah_diagcodes.h&gt;</a>
<a name="ln105"> </a>
<a name="ln106">#include &lt;dev/ath/if_ath_debug.h&gt;</a>
<a name="ln107">#include &lt;dev/ath/if_ath_misc.h&gt;</a>
<a name="ln108">#include &lt;dev/ath/if_ath_tsf.h&gt;</a>
<a name="ln109">#include &lt;dev/ath/if_ath_tx.h&gt;</a>
<a name="ln110">#include &lt;dev/ath/if_ath_sysctl.h&gt;</a>
<a name="ln111">#include &lt;dev/ath/if_ath_led.h&gt;</a>
<a name="ln112">#include &lt;dev/ath/if_ath_keycache.h&gt;</a>
<a name="ln113">#include &lt;dev/ath/if_ath_rx.h&gt;</a>
<a name="ln114">#include &lt;dev/ath/if_ath_rx_edma.h&gt;</a>
<a name="ln115">#include &lt;dev/ath/if_ath_tx_edma.h&gt;</a>
<a name="ln116">#include &lt;dev/ath/if_ath_beacon.h&gt;</a>
<a name="ln117">#include &lt;dev/ath/if_ath_btcoex.h&gt;</a>
<a name="ln118">#include &lt;dev/ath/if_ath_btcoex_mci.h&gt;</a>
<a name="ln119">#include &lt;dev/ath/if_ath_spectral.h&gt;</a>
<a name="ln120">#include &lt;dev/ath/if_ath_lna_div.h&gt;</a>
<a name="ln121">#include &lt;dev/ath/if_athdfs.h&gt;</a>
<a name="ln122">#include &lt;dev/ath/if_ath_ioctl.h&gt;</a>
<a name="ln123">#include &lt;dev/ath/if_ath_descdma.h&gt;</a>
<a name="ln124"> </a>
<a name="ln125">#ifdef ATH_TX99_DIAG</a>
<a name="ln126">#include &lt;dev/ath/ath_tx99/ath_tx99.h&gt;</a>
<a name="ln127">#endif</a>
<a name="ln128"> </a>
<a name="ln129">#ifdef	ATH_DEBUG_ALQ</a>
<a name="ln130">#include &lt;dev/ath/if_ath_alq.h&gt;</a>
<a name="ln131">#endif</a>
<a name="ln132"> </a>
<a name="ln133">/*</a>
<a name="ln134"> * Only enable this if you're working on PS-POLL support.</a>
<a name="ln135"> */</a>
<a name="ln136">#define	ATH_SW_PSQ</a>
<a name="ln137"> </a>
<a name="ln138">/*</a>
<a name="ln139"> * ATH_BCBUF determines the number of vap's that can transmit</a>
<a name="ln140"> * beacons and also (currently) the number of vap's that can</a>
<a name="ln141"> * have unique mac addresses/bssid.  When staggering beacons</a>
<a name="ln142"> * 4 is probably a good max as otherwise the beacons become</a>
<a name="ln143"> * very closely spaced and there is limited time for cab q traffic</a>
<a name="ln144"> * to go out.  You can burst beacons instead but that is not good</a>
<a name="ln145"> * for stations in power save and at some point you really want</a>
<a name="ln146"> * another radio (and channel).</a>
<a name="ln147"> *</a>
<a name="ln148"> * The limit on the number of mac addresses is tied to our use of</a>
<a name="ln149"> * the U/L bit and tracking addresses in a byte; it would be</a>
<a name="ln150"> * worthwhile to allow more for applications like proxy sta.</a>
<a name="ln151"> */</a>
<a name="ln152">CTASSERT(ATH_BCBUF &lt;= 8);</a>
<a name="ln153"> </a>
<a name="ln154">static struct ieee80211vap *ath_vap_create(struct ieee80211com *,</a>
<a name="ln155">		    const char [IFNAMSIZ], int, enum ieee80211_opmode, int,</a>
<a name="ln156">		    const uint8_t [IEEE80211_ADDR_LEN],</a>
<a name="ln157">		    const uint8_t [IEEE80211_ADDR_LEN]);</a>
<a name="ln158">static void	ath_vap_delete(struct ieee80211vap *);</a>
<a name="ln159">static int	ath_init(struct ath_softc *);</a>
<a name="ln160">static void	ath_stop(struct ath_softc *);</a>
<a name="ln161">static int	ath_reset_vap(struct ieee80211vap *, u_long);</a>
<a name="ln162">static int	ath_transmit(struct ieee80211com *, struct mbuf *);</a>
<a name="ln163">static int	ath_media_change(struct ifnet *);</a>
<a name="ln164">static void	ath_watchdog(void *);</a>
<a name="ln165">static void	ath_parent(struct ieee80211com *);</a>
<a name="ln166">static void	ath_fatal_proc(void *, int);</a>
<a name="ln167">static void	ath_bmiss_vap(struct ieee80211vap *);</a>
<a name="ln168">static void	ath_bmiss_proc(void *, int);</a>
<a name="ln169">static void	ath_key_update_begin(struct ieee80211vap *);</a>
<a name="ln170">static void	ath_key_update_end(struct ieee80211vap *);</a>
<a name="ln171">static void	ath_update_mcast_hw(struct ath_softc *);</a>
<a name="ln172">static void	ath_update_mcast(struct ieee80211com *);</a>
<a name="ln173">static void	ath_update_promisc(struct ieee80211com *);</a>
<a name="ln174">static void	ath_updateslot(struct ieee80211com *);</a>
<a name="ln175">static void	ath_bstuck_proc(void *, int);</a>
<a name="ln176">static void	ath_reset_proc(void *, int);</a>
<a name="ln177">static int	ath_desc_alloc(struct ath_softc *);</a>
<a name="ln178">static void	ath_desc_free(struct ath_softc *);</a>
<a name="ln179">static struct ieee80211_node *ath_node_alloc(struct ieee80211vap *,</a>
<a name="ln180">			const uint8_t [IEEE80211_ADDR_LEN]);</a>
<a name="ln181">static void	ath_node_cleanup(struct ieee80211_node *);</a>
<a name="ln182">static void	ath_node_free(struct ieee80211_node *);</a>
<a name="ln183">static void	ath_node_getsignal(const struct ieee80211_node *,</a>
<a name="ln184">			int8_t *, int8_t *);</a>
<a name="ln185">static void	ath_txq_init(struct ath_softc *sc, struct ath_txq *, int);</a>
<a name="ln186">static struct ath_txq *ath_txq_setup(struct ath_softc*, int qtype, int subtype);</a>
<a name="ln187">static int	ath_tx_setup(struct ath_softc *, int, int);</a>
<a name="ln188">static void	ath_tx_cleanupq(struct ath_softc *, struct ath_txq *);</a>
<a name="ln189">static void	ath_tx_cleanup(struct ath_softc *);</a>
<a name="ln190">static int	ath_tx_processq(struct ath_softc *sc, struct ath_txq *txq,</a>
<a name="ln191">		    int dosched);</a>
<a name="ln192">static void	ath_tx_proc_q0(void *, int);</a>
<a name="ln193">static void	ath_tx_proc_q0123(void *, int);</a>
<a name="ln194">static void	ath_tx_proc(void *, int);</a>
<a name="ln195">static void	ath_txq_sched_tasklet(void *, int);</a>
<a name="ln196">static int	ath_chan_set(struct ath_softc *, struct ieee80211_channel *);</a>
<a name="ln197">static void	ath_chan_change(struct ath_softc *, struct ieee80211_channel *);</a>
<a name="ln198">static void	ath_scan_start(struct ieee80211com *);</a>
<a name="ln199">static void	ath_scan_end(struct ieee80211com *);</a>
<a name="ln200">static void	ath_set_channel(struct ieee80211com *);</a>
<a name="ln201">#ifdef	ATH_ENABLE_11N</a>
<a name="ln202">static void	ath_update_chw(struct ieee80211com *);</a>
<a name="ln203">#endif	/* ATH_ENABLE_11N */</a>
<a name="ln204">static int	ath_set_quiet_ie(struct ieee80211_node *, uint8_t *);</a>
<a name="ln205">static void	ath_calibrate(void *);</a>
<a name="ln206">static int	ath_newstate(struct ieee80211vap *, enum ieee80211_state, int);</a>
<a name="ln207">static void	ath_setup_stationkey(struct ieee80211_node *);</a>
<a name="ln208">static void	ath_newassoc(struct ieee80211_node *, int);</a>
<a name="ln209">static int	ath_setregdomain(struct ieee80211com *,</a>
<a name="ln210">		    struct ieee80211_regdomain *, int,</a>
<a name="ln211">		    struct ieee80211_channel []);</a>
<a name="ln212">static void	ath_getradiocaps(struct ieee80211com *, int, int *,</a>
<a name="ln213">		    struct ieee80211_channel []);</a>
<a name="ln214">static int	ath_getchannels(struct ath_softc *);</a>
<a name="ln215"> </a>
<a name="ln216">static int	ath_rate_setup(struct ath_softc *, u_int mode);</a>
<a name="ln217">static void	ath_setcurmode(struct ath_softc *, enum ieee80211_phymode);</a>
<a name="ln218"> </a>
<a name="ln219">static void	ath_announce(struct ath_softc *);</a>
<a name="ln220"> </a>
<a name="ln221">static void	ath_dfs_tasklet(void *, int);</a>
<a name="ln222">static void	ath_node_powersave(struct ieee80211_node *, int);</a>
<a name="ln223">static int	ath_node_set_tim(struct ieee80211_node *, int);</a>
<a name="ln224">static void	ath_node_recv_pspoll(struct ieee80211_node *, struct mbuf *);</a>
<a name="ln225"> </a>
<a name="ln226">#ifdef IEEE80211_SUPPORT_TDMA</a>
<a name="ln227">#include &lt;dev/ath/if_ath_tdma.h&gt;</a>
<a name="ln228">#endif</a>
<a name="ln229"> </a>
<a name="ln230">SYSCTL_DECL(_hw_ath);</a>
<a name="ln231"> </a>
<a name="ln232">/* XXX validate sysctl values */</a>
<a name="ln233">static	int ath_longcalinterval = 30;		/* long cals every 30 secs */</a>
<a name="ln234">SYSCTL_INT(_hw_ath, OID_AUTO, longcal, CTLFLAG_RW, &amp;ath_longcalinterval,</a>
<a name="ln235">	    0, &quot;long chip calibration interval (secs)&quot;);</a>
<a name="ln236">static	int ath_shortcalinterval = 100;		/* short cals every 100 ms */</a>
<a name="ln237">SYSCTL_INT(_hw_ath, OID_AUTO, shortcal, CTLFLAG_RW, &amp;ath_shortcalinterval,</a>
<a name="ln238">	    0, &quot;short chip calibration interval (msecs)&quot;);</a>
<a name="ln239">static	int ath_resetcalinterval = 20*60;	/* reset cal state 20 mins */</a>
<a name="ln240">SYSCTL_INT(_hw_ath, OID_AUTO, resetcal, CTLFLAG_RW, &amp;ath_resetcalinterval,</a>
<a name="ln241">	    0, &quot;reset chip calibration results (secs)&quot;);</a>
<a name="ln242">static	int ath_anicalinterval = 100;		/* ANI calibration - 100 msec */</a>
<a name="ln243">SYSCTL_INT(_hw_ath, OID_AUTO, anical, CTLFLAG_RW, &amp;ath_anicalinterval,</a>
<a name="ln244">	    0, &quot;ANI calibration (msecs)&quot;);</a>
<a name="ln245"> </a>
<a name="ln246">int ath_rxbuf = ATH_RXBUF;		/* # rx buffers to allocate */</a>
<a name="ln247">SYSCTL_INT(_hw_ath, OID_AUTO, rxbuf, CTLFLAG_RWTUN, &amp;ath_rxbuf,</a>
<a name="ln248">	    0, &quot;rx buffers allocated&quot;);</a>
<a name="ln249">int ath_txbuf = ATH_TXBUF;		/* # tx buffers to allocate */</a>
<a name="ln250">SYSCTL_INT(_hw_ath, OID_AUTO, txbuf, CTLFLAG_RWTUN, &amp;ath_txbuf,</a>
<a name="ln251">	    0, &quot;tx buffers allocated&quot;);</a>
<a name="ln252">int ath_txbuf_mgmt = ATH_MGMT_TXBUF;	/* # mgmt tx buffers to allocate */</a>
<a name="ln253">SYSCTL_INT(_hw_ath, OID_AUTO, txbuf_mgmt, CTLFLAG_RWTUN, &amp;ath_txbuf_mgmt,</a>
<a name="ln254">	    0, &quot;tx (mgmt) buffers allocated&quot;);</a>
<a name="ln255"> </a>
<a name="ln256">int ath_bstuck_threshold = 4;		/* max missed beacons */</a>
<a name="ln257">SYSCTL_INT(_hw_ath, OID_AUTO, bstuck, CTLFLAG_RW, &amp;ath_bstuck_threshold,</a>
<a name="ln258">	    0, &quot;max missed beacon xmits before chip reset&quot;);</a>
<a name="ln259"> </a>
<a name="ln260">MALLOC_DEFINE(M_ATHDEV, &quot;athdev&quot;, &quot;ath driver dma buffers&quot;);</a>
<a name="ln261"> </a>
<a name="ln262">void</a>
<a name="ln263">ath_legacy_attach_comp_func(struct ath_softc *sc)</a>
<a name="ln264">{</a>
<a name="ln265"> </a>
<a name="ln266">	/*</a>
<a name="ln267">	 * Special case certain configurations.  Note the</a>
<a name="ln268">	 * CAB queue is handled by these specially so don't</a>
<a name="ln269">	 * include them when checking the txq setup mask.</a>
<a name="ln270">	 */</a>
<a name="ln271">	switch (sc-&gt;sc_txqsetup &amp;~ (1&lt;&lt;sc-&gt;sc_cabq-&gt;axq_qnum)) {</a>
<a name="ln272">	case 0x01:</a>
<a name="ln273">		TASK_INIT(&amp;sc-&gt;sc_txtask, 0, ath_tx_proc_q0, sc);</a>
<a name="ln274">		break;</a>
<a name="ln275">	case 0x0f:</a>
<a name="ln276">		TASK_INIT(&amp;sc-&gt;sc_txtask, 0, ath_tx_proc_q0123, sc);</a>
<a name="ln277">		break;</a>
<a name="ln278">	default:</a>
<a name="ln279">		TASK_INIT(&amp;sc-&gt;sc_txtask, 0, ath_tx_proc, sc);</a>
<a name="ln280">		break;</a>
<a name="ln281">	}</a>
<a name="ln282">}</a>
<a name="ln283"> </a>
<a name="ln284">/*</a>
<a name="ln285"> * Set the target power mode.</a>
<a name="ln286"> *</a>
<a name="ln287"> * If this is called during a point in time where</a>
<a name="ln288"> * the hardware is being programmed elsewhere, it will</a>
<a name="ln289"> * simply store it away and update it when all current</a>
<a name="ln290"> * uses of the hardware are completed.</a>
<a name="ln291"> *</a>
<a name="ln292"> * If the chip is going into network sleep or power off, then</a>
<a name="ln293"> * we will wait until all uses of the chip are done before</a>
<a name="ln294"> * going into network sleep or power off.</a>
<a name="ln295"> *</a>
<a name="ln296"> * If the chip is being programmed full-awake, then immediately</a>
<a name="ln297"> * program it full-awake so we can actually stay awake rather than</a>
<a name="ln298"> * the chip potentially going to sleep underneath us.</a>
<a name="ln299"> */</a>
<a name="ln300">void</a>
<a name="ln301">_ath_power_setpower(struct ath_softc *sc, int power_state, int selfgen,</a>
<a name="ln302">    const char *file, int line)</a>
<a name="ln303">{</a>
<a name="ln304">	ATH_LOCK_ASSERT(sc);</a>
<a name="ln305"> </a>
<a name="ln306">	DPRINTF(sc, ATH_DEBUG_PWRSAVE, &quot;%s: (%s:%d) state=%d, refcnt=%d, target=%d, cur=%d\n&quot;,</a>
<a name="ln307">	    __func__,</a>
<a name="ln308">	    file,</a>
<a name="ln309">	    line,</a>
<a name="ln310">	    power_state,</a>
<a name="ln311">	    sc-&gt;sc_powersave_refcnt,</a>
<a name="ln312">	    sc-&gt;sc_target_powerstate,</a>
<a name="ln313">	    sc-&gt;sc_cur_powerstate);</a>
<a name="ln314"> </a>
<a name="ln315">	sc-&gt;sc_target_powerstate = power_state;</a>
<a name="ln316"> </a>
<a name="ln317">	/*</a>
<a name="ln318">	 * Don't program the chip into network sleep if the chip</a>
<a name="ln319">	 * is being programmed elsewhere.</a>
<a name="ln320">	 *</a>
<a name="ln321">	 * However, if the chip is being programmed /awake/, force</a>
<a name="ln322">	 * the chip awake so we stay awake.</a>
<a name="ln323">	 */</a>
<a name="ln324">	if ((sc-&gt;sc_powersave_refcnt == 0 || power_state == HAL_PM_AWAKE) &amp;&amp;</a>
<a name="ln325">	    power_state != sc-&gt;sc_cur_powerstate) {</a>
<a name="ln326">		sc-&gt;sc_cur_powerstate = power_state;</a>
<a name="ln327">		ath_hal_setpower(sc-&gt;sc_ah, power_state);</a>
<a name="ln328"> </a>
<a name="ln329">		/*</a>
<a name="ln330">		 * If the NIC is force-awake, then set the</a>
<a name="ln331">		 * self-gen frame state appropriately.</a>
<a name="ln332">		 *</a>
<a name="ln333">		 * If the nic is in network sleep or full-sleep,</a>
<a name="ln334">		 * we let the above call leave the self-gen</a>
<a name="ln335">		 * state as &quot;sleep&quot;.</a>
<a name="ln336">		 */</a>
<a name="ln337">		if (selfgen &amp;&amp;</a>
<a name="ln338">		    sc-&gt;sc_cur_powerstate == HAL_PM_AWAKE &amp;&amp;</a>
<a name="ln339">		    sc-&gt;sc_target_selfgen_state != HAL_PM_AWAKE) {</a>
<a name="ln340">			ath_hal_setselfgenpower(sc-&gt;sc_ah,</a>
<a name="ln341">			    sc-&gt;sc_target_selfgen_state);</a>
<a name="ln342">		}</a>
<a name="ln343">	}</a>
<a name="ln344">}</a>
<a name="ln345"> </a>
<a name="ln346">/*</a>
<a name="ln347"> * Set the current self-generated frames state.</a>
<a name="ln348"> *</a>
<a name="ln349"> * This is separate from the target power mode.  The chip may be</a>
<a name="ln350"> * awake but the desired state is &quot;sleep&quot;, so frames sent to the</a>
<a name="ln351"> * destination has PWRMGT=1 in the 802.11 header.  The NIC also</a>
<a name="ln352"> * needs to know to set PWRMGT=1 in self-generated frames.</a>
<a name="ln353"> */</a>
<a name="ln354">void</a>
<a name="ln355">_ath_power_set_selfgen(struct ath_softc *sc, int power_state, const char *file, int line)</a>
<a name="ln356">{</a>
<a name="ln357"> </a>
<a name="ln358">	ATH_LOCK_ASSERT(sc);</a>
<a name="ln359"> </a>
<a name="ln360">	DPRINTF(sc, ATH_DEBUG_PWRSAVE, &quot;%s: (%s:%d) state=%d, refcnt=%d\n&quot;,</a>
<a name="ln361">	    __func__,</a>
<a name="ln362">	    file,</a>
<a name="ln363">	    line,</a>
<a name="ln364">	    power_state,</a>
<a name="ln365">	    sc-&gt;sc_target_selfgen_state);</a>
<a name="ln366"> </a>
<a name="ln367">	sc-&gt;sc_target_selfgen_state = power_state;</a>
<a name="ln368"> </a>
<a name="ln369">	/*</a>
<a name="ln370">	 * If the NIC is force-awake, then set the power state.</a>
<a name="ln371">	 * Network-state and full-sleep will already transition it to</a>
<a name="ln372">	 * mark self-gen frames as sleeping - and we can't</a>
<a name="ln373">	 * guarantee the NIC is awake to program the self-gen frame</a>
<a name="ln374">	 * setting anyway.</a>
<a name="ln375">	 */</a>
<a name="ln376">	if (sc-&gt;sc_cur_powerstate == HAL_PM_AWAKE) {</a>
<a name="ln377">		ath_hal_setselfgenpower(sc-&gt;sc_ah, power_state);</a>
<a name="ln378">	}</a>
<a name="ln379">}</a>
<a name="ln380"> </a>
<a name="ln381">/*</a>
<a name="ln382"> * Set the hardware power mode and take a reference.</a>
<a name="ln383"> *</a>
<a name="ln384"> * This doesn't update the target power mode in the driver;</a>
<a name="ln385"> * it just updates the hardware power state.</a>
<a name="ln386"> *</a>
<a name="ln387"> * XXX it should only ever force the hardware awake; it should</a>
<a name="ln388"> * never be called to set it asleep.</a>
<a name="ln389"> */</a>
<a name="ln390">void</a>
<a name="ln391">_ath_power_set_power_state(struct ath_softc *sc, int power_state, const char *file, int line)</a>
<a name="ln392">{</a>
<a name="ln393">	ATH_LOCK_ASSERT(sc);</a>
<a name="ln394"> </a>
<a name="ln395">	DPRINTF(sc, ATH_DEBUG_PWRSAVE, &quot;%s: (%s:%d) state=%d, refcnt=%d\n&quot;,</a>
<a name="ln396">	    __func__,</a>
<a name="ln397">	    file,</a>
<a name="ln398">	    line,</a>
<a name="ln399">	    power_state,</a>
<a name="ln400">	    sc-&gt;sc_powersave_refcnt);</a>
<a name="ln401"> </a>
<a name="ln402">	sc-&gt;sc_powersave_refcnt++;</a>
<a name="ln403"> </a>
<a name="ln404">	/*</a>
<a name="ln405">	 * Only do the power state change if we're not programming</a>
<a name="ln406">	 * it elsewhere.</a>
<a name="ln407">	 */</a>
<a name="ln408">	if (power_state != sc-&gt;sc_cur_powerstate) {</a>
<a name="ln409">		ath_hal_setpower(sc-&gt;sc_ah, power_state);</a>
<a name="ln410">		sc-&gt;sc_cur_powerstate = power_state;</a>
<a name="ln411">		/*</a>
<a name="ln412">		 * Adjust the self-gen powerstate if appropriate.</a>
<a name="ln413">		 */</a>
<a name="ln414">		if (sc-&gt;sc_cur_powerstate == HAL_PM_AWAKE &amp;&amp;</a>
<a name="ln415">		    sc-&gt;sc_target_selfgen_state != HAL_PM_AWAKE) {</a>
<a name="ln416">			ath_hal_setselfgenpower(sc-&gt;sc_ah,</a>
<a name="ln417">			    sc-&gt;sc_target_selfgen_state);</a>
<a name="ln418">		}</a>
<a name="ln419">	}</a>
<a name="ln420">}</a>
<a name="ln421"> </a>
<a name="ln422">/*</a>
<a name="ln423"> * Restore the power save mode to what it once was.</a>
<a name="ln424"> *</a>
<a name="ln425"> * This will decrement the reference counter and once it hits</a>
<a name="ln426"> * zero, it'll restore the powersave state.</a>
<a name="ln427"> */</a>
<a name="ln428">void</a>
<a name="ln429">_ath_power_restore_power_state(struct ath_softc *sc, const char *file, int line)</a>
<a name="ln430">{</a>
<a name="ln431"> </a>
<a name="ln432">	ATH_LOCK_ASSERT(sc);</a>
<a name="ln433"> </a>
<a name="ln434">	DPRINTF(sc, ATH_DEBUG_PWRSAVE, &quot;%s: (%s:%d) refcnt=%d, target state=%d\n&quot;,</a>
<a name="ln435">	    __func__,</a>
<a name="ln436">	    file,</a>
<a name="ln437">	    line,</a>
<a name="ln438">	    sc-&gt;sc_powersave_refcnt,</a>
<a name="ln439">	    sc-&gt;sc_target_powerstate);</a>
<a name="ln440"> </a>
<a name="ln441">	if (sc-&gt;sc_powersave_refcnt == 0)</a>
<a name="ln442">		device_printf(sc-&gt;sc_dev, &quot;%s: refcnt=0?\n&quot;, __func__);</a>
<a name="ln443">	else</a>
<a name="ln444">		sc-&gt;sc_powersave_refcnt--;</a>
<a name="ln445"> </a>
<a name="ln446">	if (sc-&gt;sc_powersave_refcnt == 0 &amp;&amp;</a>
<a name="ln447">	    sc-&gt;sc_target_powerstate != sc-&gt;sc_cur_powerstate) {</a>
<a name="ln448">		sc-&gt;sc_cur_powerstate = sc-&gt;sc_target_powerstate;</a>
<a name="ln449">		ath_hal_setpower(sc-&gt;sc_ah, sc-&gt;sc_target_powerstate);</a>
<a name="ln450">	}</a>
<a name="ln451"> </a>
<a name="ln452">	/*</a>
<a name="ln453">	 * Adjust the self-gen powerstate if appropriate.</a>
<a name="ln454">	 */</a>
<a name="ln455">	if (sc-&gt;sc_cur_powerstate == HAL_PM_AWAKE &amp;&amp;</a>
<a name="ln456">	    sc-&gt;sc_target_selfgen_state != HAL_PM_AWAKE) {</a>
<a name="ln457">		ath_hal_setselfgenpower(sc-&gt;sc_ah,</a>
<a name="ln458">		    sc-&gt;sc_target_selfgen_state);</a>
<a name="ln459">	}</a>
<a name="ln460"> </a>
<a name="ln461">}</a>
<a name="ln462"> </a>
<a name="ln463">/*</a>
<a name="ln464"> * Configure the initial HAL configuration values based on bus</a>
<a name="ln465"> * specific parameters.</a>
<a name="ln466"> *</a>
<a name="ln467"> * Some PCI IDs and other information may need tweaking.</a>
<a name="ln468"> *</a>
<a name="ln469"> * XXX TODO: ath9k and the Atheros HAL only program comm2g_switch_enable</a>
<a name="ln470"> * if BT antenna diversity isn't enabled.</a>
<a name="ln471"> *</a>
<a name="ln472"> * So, let's also figure out how to enable BT diversity for AR9485.</a>
<a name="ln473"> */</a>
<a name="ln474">static void</a>
<a name="ln475">ath_setup_hal_config(struct ath_softc *sc, HAL_OPS_CONFIG *ah_config)</a>
<a name="ln476">{</a>
<a name="ln477">	/* XXX TODO: only for PCI devices? */</a>
<a name="ln478"> </a>
<a name="ln479">	if (sc-&gt;sc_pci_devinfo &amp; (ATH_PCI_CUS198 | ATH_PCI_CUS230)) {</a>
<a name="ln480">		ah_config-&gt;ath_hal_ext_lna_ctl_gpio = 0x200; /* bit 9 */</a>
<a name="ln481">		ah_config-&gt;ath_hal_ext_atten_margin_cfg = AH_TRUE;</a>
<a name="ln482">		ah_config-&gt;ath_hal_min_gainidx = AH_TRUE;</a>
<a name="ln483">		ah_config-&gt;ath_hal_ant_ctrl_comm2g_switch_enable = 0x000bbb88;</a>
<a name="ln484">		/* XXX low_rssi_thresh */</a>
<a name="ln485">		/* XXX fast_div_bias */</a>
<a name="ln486">		device_printf(sc-&gt;sc_dev, &quot;configuring for %s\n&quot;,</a>
<a name="ln487">		    (sc-&gt;sc_pci_devinfo &amp; ATH_PCI_CUS198) ?</a>
<a name="ln488">		    &quot;CUS198&quot; : &quot;CUS230&quot;);</a>
<a name="ln489">	}</a>
<a name="ln490"> </a>
<a name="ln491">	if (sc-&gt;sc_pci_devinfo &amp; ATH_PCI_CUS217)</a>
<a name="ln492">		device_printf(sc-&gt;sc_dev, &quot;CUS217 card detected\n&quot;);</a>
<a name="ln493"> </a>
<a name="ln494">	if (sc-&gt;sc_pci_devinfo &amp; ATH_PCI_CUS252)</a>
<a name="ln495">		device_printf(sc-&gt;sc_dev, &quot;CUS252 card detected\n&quot;);</a>
<a name="ln496"> </a>
<a name="ln497">	if (sc-&gt;sc_pci_devinfo &amp; ATH_PCI_AR9565_1ANT)</a>
<a name="ln498">		device_printf(sc-&gt;sc_dev, &quot;WB335 1-ANT card detected\n&quot;);</a>
<a name="ln499"> </a>
<a name="ln500">	if (sc-&gt;sc_pci_devinfo &amp; ATH_PCI_AR9565_2ANT)</a>
<a name="ln501">		device_printf(sc-&gt;sc_dev, &quot;WB335 2-ANT card detected\n&quot;);</a>
<a name="ln502"> </a>
<a name="ln503">	if (sc-&gt;sc_pci_devinfo &amp; ATH_PCI_BT_ANT_DIV)</a>
<a name="ln504">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln505">		    &quot;Bluetooth Antenna Diversity card detected\n&quot;);</a>
<a name="ln506"> </a>
<a name="ln507">	if (sc-&gt;sc_pci_devinfo &amp; ATH_PCI_KILLER)</a>
<a name="ln508">		device_printf(sc-&gt;sc_dev, &quot;Killer Wireless card detected\n&quot;);</a>
<a name="ln509"> </a>
<a name="ln510">#if 0</a>
<a name="ln511">        /*</a>
<a name="ln512">         * Some WB335 cards do not support antenna diversity. Since</a>
<a name="ln513">         * we use a hardcoded value for AR9565 instead of using the</a>
<a name="ln514">         * EEPROM/OTP data, remove the combining feature from</a>
<a name="ln515">         * the HW capabilities bitmap.</a>
<a name="ln516">         */</a>
<a name="ln517">        if (sc-&gt;sc_pci_devinfo &amp; (ATH9K_PCI_AR9565_1ANT | ATH9K_PCI_AR9565_2ANT)) {</a>
<a name="ln518">                if (!(sc-&gt;sc_pci_devinfo &amp; ATH9K_PCI_BT_ANT_DIV))</a>
<a name="ln519">                        pCap-&gt;hw_caps &amp;= ~ATH9K_HW_CAP_ANT_DIV_COMB;</a>
<a name="ln520">        }</a>
<a name="ln521"> </a>
<a name="ln522">        if (sc-&gt;sc_pci_devinfo &amp; ATH9K_PCI_BT_ANT_DIV) {</a>
<a name="ln523">                pCap-&gt;hw_caps |= ATH9K_HW_CAP_BT_ANT_DIV;</a>
<a name="ln524">                device_printf(sc-&gt;sc_dev, &quot;Set BT/WLAN RX diversity capability\n&quot;);</a>
<a name="ln525">        }</a>
<a name="ln526">#endif</a>
<a name="ln527"> </a>
<a name="ln528">        if (sc-&gt;sc_pci_devinfo &amp; ATH_PCI_D3_L1_WAR) {</a>
<a name="ln529">                ah_config-&gt;ath_hal_pcie_waen = 0x0040473b;</a>
<a name="ln530">                device_printf(sc-&gt;sc_dev, &quot;Enable WAR for ASPM D3/L1\n&quot;);</a>
<a name="ln531">        }</a>
<a name="ln532"> </a>
<a name="ln533">#if 0</a>
<a name="ln534">        if (sc-&gt;sc_pci_devinfo &amp; ATH9K_PCI_NO_PLL_PWRSAVE) {</a>
<a name="ln535">                ah-&gt;config.no_pll_pwrsave = true;</a>
<a name="ln536">                device_printf(sc-&gt;sc_dev, &quot;Disable PLL PowerSave\n&quot;);</a>
<a name="ln537">        }</a>
<a name="ln538">#endif</a>
<a name="ln539"> </a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542">/*</a>
<a name="ln543"> * Attempt to fetch the MAC address from the kernel environment.</a>
<a name="ln544"> *</a>
<a name="ln545"> * Returns 0, macaddr in macaddr if successful; -1 otherwise.</a>
<a name="ln546"> */</a>
<a name="ln547">static int</a>
<a name="ln548">ath_fetch_mac_kenv(struct ath_softc *sc, uint8_t *macaddr)</a>
<a name="ln549">{</a>
<a name="ln550">	char devid_str[32];</a>
<a name="ln551">	int local_mac = 0;</a>
<a name="ln552">	char *local_macstr;</a>
<a name="ln553"> </a>
<a name="ln554">	/*</a>
<a name="ln555">	 * Fetch from the kenv rather than using hints.</a>
<a name="ln556">	 *</a>
<a name="ln557">	 * Hints would be nice but the transition to dynamic</a>
<a name="ln558">	 * hints/kenv doesn't happen early enough for this</a>
<a name="ln559">	 * to work reliably (eg on anything embedded.)</a>
<a name="ln560">	 */</a>
<a name="ln561">	snprintf(devid_str, 32, &quot;hint.%s.%d.macaddr&quot;,</a>
<a name="ln562">	    device_get_name(sc-&gt;sc_dev),</a>
<a name="ln563">	    device_get_unit(sc-&gt;sc_dev));</a>
<a name="ln564"> </a>
<a name="ln565">#ifndef __HAIKU__</a>
<a name="ln566">	if ((local_macstr = kern_getenv(devid_str)) != NULL) {</a>
<a name="ln567">		uint32_t tmpmac[ETHER_ADDR_LEN];</a>
<a name="ln568">		int count;</a>
<a name="ln569">		int i;</a>
<a name="ln570"> </a>
<a name="ln571">		/* Have a MAC address; should use it */</a>
<a name="ln572">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln573">		    &quot;Overriding MAC address from environment: '%s'\n&quot;,</a>
<a name="ln574">		    local_macstr);</a>
<a name="ln575"> </a>
<a name="ln576">		/* Extract out the MAC address */</a>
<a name="ln577">		count = sscanf(local_macstr, &quot;%x%*c%x%*c%x%*c%x%*c%x%*c%x&quot;,</a>
<a name="ln578">		    &amp;tmpmac[0], &amp;tmpmac[1],</a>
<a name="ln579">		    &amp;tmpmac[2], &amp;tmpmac[3],</a>
<a name="ln580">		    &amp;tmpmac[4], &amp;tmpmac[5]);</a>
<a name="ln581">		if (count == 6) {</a>
<a name="ln582">			/* Valid! */</a>
<a name="ln583">			local_mac = 1;</a>
<a name="ln584">			for (i = 0; i &lt; ETHER_ADDR_LEN; i++)</a>
<a name="ln585">				macaddr[i] = tmpmac[i];</a>
<a name="ln586">		}</a>
<a name="ln587">		/* Done! */</a>
<a name="ln588">		freeenv(local_macstr);</a>
<a name="ln589">		local_macstr = NULL;</a>
<a name="ln590">	}</a>
<a name="ln591">#endif</a>
<a name="ln592"> </a>
<a name="ln593">	if (local_mac)</a>
<a name="ln594">		return (0);</a>
<a name="ln595">	return (-1);</a>
<a name="ln596">}</a>
<a name="ln597"> </a>
<a name="ln598">#define	HAL_MODE_HT20 (HAL_MODE_11NG_HT20 | HAL_MODE_11NA_HT20)</a>
<a name="ln599">#define	HAL_MODE_HT40 \</a>
<a name="ln600">	(HAL_MODE_11NG_HT40PLUS | HAL_MODE_11NG_HT40MINUS | \</a>
<a name="ln601">	HAL_MODE_11NA_HT40PLUS | HAL_MODE_11NA_HT40MINUS)</a>
<a name="ln602">int</a>
<a name="ln603">ath_attach(u_int16_t devid, struct ath_softc *sc)</a>
<a name="ln604">{</a>
<a name="ln605">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln606">	struct ath_hal *ah = NULL;</a>
<a name="ln607">	HAL_STATUS status;</a>
<a name="ln608">	int error = 0, i;</a>
<a name="ln609">	u_int wmodes;</a>
<a name="ln610">	int rx_chainmask, tx_chainmask;</a>
<a name="ln611">	HAL_OPS_CONFIG ah_config;</a>
<a name="ln612"> </a>
<a name="ln613">	DPRINTF(sc, ATH_DEBUG_ANY, &quot;%s: devid 0x%x\n&quot;, __func__, devid);</a>
<a name="ln614"> </a>
<a name="ln615">	ic-&gt;ic_softc = sc;</a>
<a name="ln616">	ic-&gt;ic_name = device_get_nameunit(sc-&gt;sc_dev);</a>
<a name="ln617"> </a>
<a name="ln618">	/*</a>
<a name="ln619">	 * Configure the initial configuration data.</a>
<a name="ln620">	 *</a>
<a name="ln621">	 * This is stuff that may be needed early during attach</a>
<a name="ln622">	 * rather than done via configuration calls later.</a>
<a name="ln623">	 */</a>
<a name="ln624">	bzero(&amp;ah_config, sizeof(ah_config));</a>
<a name="ln625">	ath_setup_hal_config(sc, &amp;ah_config);</a>
<a name="ln626"> </a>
<a name="ln627">	ah = ath_hal_attach(devid, sc, sc-&gt;sc_st, sc-&gt;sc_sh,</a>
<a name="ln628">	    sc-&gt;sc_eepromdata, &amp;ah_config, &amp;status);</a>
<a name="ln629">	if (ah == NULL) {</a>
<a name="ln630">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln631">		    &quot;unable to attach hardware; HAL status %u\n&quot;, status);</a>
<a name="ln632">		error = ENXIO;</a>
<a name="ln633">		goto bad;</a>
<a name="ln634">	}</a>
<a name="ln635">	sc-&gt;sc_ah = ah;</a>
<a name="ln636">	sc-&gt;sc_invalid = 0;	/* ready to go, enable interrupt handling */</a>
<a name="ln637">#ifdef	ATH_DEBUG</a>
<a name="ln638">	sc-&gt;sc_debug = ath_debug;</a>
<a name="ln639">#endif</a>
<a name="ln640"> </a>
<a name="ln641">	/*</a>
<a name="ln642">	 * Force the chip awake during setup, just to keep</a>
<a name="ln643">	 * the HAL/driver power tracking happy.</a>
<a name="ln644">	 *</a>
<a name="ln645">	 * There are some methods (eg ath_hal_setmac())</a>
<a name="ln646">	 * that poke the hardware.</a>
<a name="ln647">	 */</a>
<a name="ln648">	ATH_LOCK(sc);</a>
<a name="ln649">	ath_power_setpower(sc, HAL_PM_AWAKE, 1);</a>
<a name="ln650">	ATH_UNLOCK(sc);</a>
<a name="ln651"> </a>
<a name="ln652">	/*</a>
<a name="ln653">	 * Setup the DMA/EDMA functions based on the current</a>
<a name="ln654">	 * hardware support.</a>
<a name="ln655">	 *</a>
<a name="ln656">	 * This is required before the descriptors are allocated.</a>
<a name="ln657">	 */</a>
<a name="ln658">	if (ath_hal_hasedma(sc-&gt;sc_ah)) {</a>
<a name="ln659">		sc-&gt;sc_isedma = 1;</a>
<a name="ln660">		ath_recv_setup_edma(sc);</a>
<a name="ln661">		ath_xmit_setup_edma(sc);</a>
<a name="ln662">	} else {</a>
<a name="ln663">		ath_recv_setup_legacy(sc);</a>
<a name="ln664">		ath_xmit_setup_legacy(sc);</a>
<a name="ln665">	}</a>
<a name="ln666"> </a>
<a name="ln667">	if (ath_hal_hasmybeacon(sc-&gt;sc_ah)) {</a>
<a name="ln668">		sc-&gt;sc_do_mybeacon = 1;</a>
<a name="ln669">	}</a>
<a name="ln670"> </a>
<a name="ln671">	/*</a>
<a name="ln672">	 * Check if the MAC has multi-rate retry support.</a>
<a name="ln673">	 * We do this by trying to setup a fake extended</a>
<a name="ln674">	 * descriptor.  MAC's that don't have support will</a>
<a name="ln675">	 * return false w/o doing anything.  MAC's that do</a>
<a name="ln676">	 * support it will return true w/o doing anything.</a>
<a name="ln677">	 */</a>
<a name="ln678">	sc-&gt;sc_mrretry = ath_hal_setupxtxdesc(ah, NULL, 0,0, 0,0, 0,0);</a>
<a name="ln679"> </a>
<a name="ln680">	/*</a>
<a name="ln681">	 * Check if the device has hardware counters for PHY</a>
<a name="ln682">	 * errors.  If so we need to enable the MIB interrupt</a>
<a name="ln683">	 * so we can act on stat triggers.</a>
<a name="ln684">	 */</a>
<a name="ln685">	if (ath_hal_hwphycounters(ah))</a>
<a name="ln686">		sc-&gt;sc_needmib = 1;</a>
<a name="ln687"> </a>
<a name="ln688">	/*</a>
<a name="ln689">	 * Get the hardware key cache size.</a>
<a name="ln690">	 */</a>
<a name="ln691">	sc-&gt;sc_keymax = ath_hal_keycachesize(ah);</a>
<a name="ln692">	if (sc-&gt;sc_keymax &gt; ATH_KEYMAX) {</a>
<a name="ln693">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln694">		    &quot;Warning, using only %u of %u key cache slots\n&quot;,</a>
<a name="ln695">		    ATH_KEYMAX, sc-&gt;sc_keymax);</a>
<a name="ln696">		sc-&gt;sc_keymax = ATH_KEYMAX;</a>
<a name="ln697">	}</a>
<a name="ln698">	/*</a>
<a name="ln699">	 * Reset the key cache since some parts do not</a>
<a name="ln700">	 * reset the contents on initial power up.</a>
<a name="ln701">	 */</a>
<a name="ln702">	for (i = 0; i &lt; sc-&gt;sc_keymax; i++)</a>
<a name="ln703">		ath_hal_keyreset(ah, i);</a>
<a name="ln704"> </a>
<a name="ln705">	/*</a>
<a name="ln706">	 * Collect the default channel list.</a>
<a name="ln707">	 */</a>
<a name="ln708">	error = ath_getchannels(sc);</a>
<a name="ln709">	if (error != 0)</a>
<a name="ln710">		goto bad;</a>
<a name="ln711"> </a>
<a name="ln712">	/*</a>
<a name="ln713">	 * Setup rate tables for all potential media types.</a>
<a name="ln714">	 */</a>
<a name="ln715">	ath_rate_setup(sc, IEEE80211_MODE_11A);</a>
<a name="ln716">	ath_rate_setup(sc, IEEE80211_MODE_11B);</a>
<a name="ln717">	ath_rate_setup(sc, IEEE80211_MODE_11G);</a>
<a name="ln718">	ath_rate_setup(sc, IEEE80211_MODE_TURBO_A);</a>
<a name="ln719">	ath_rate_setup(sc, IEEE80211_MODE_TURBO_G);</a>
<a name="ln720">	ath_rate_setup(sc, IEEE80211_MODE_STURBO_A);</a>
<a name="ln721">	ath_rate_setup(sc, IEEE80211_MODE_11NA);</a>
<a name="ln722">	ath_rate_setup(sc, IEEE80211_MODE_11NG);</a>
<a name="ln723">	ath_rate_setup(sc, IEEE80211_MODE_HALF);</a>
<a name="ln724">	ath_rate_setup(sc, IEEE80211_MODE_QUARTER);</a>
<a name="ln725"> </a>
<a name="ln726">	/* NB: setup here so ath_rate_update is happy */</a>
<a name="ln727">	ath_setcurmode(sc, IEEE80211_MODE_11A);</a>
<a name="ln728"> </a>
<a name="ln729">	/*</a>
<a name="ln730">	 * Allocate TX descriptors and populate the lists.</a>
<a name="ln731">	 */</a>
<a name="ln732">	error = ath_desc_alloc(sc);</a>
<a name="ln733">	if (error != 0) {</a>
<a name="ln734">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln735">		    &quot;failed to allocate TX descriptors: %d\n&quot;, error);</a>
<a name="ln736">		goto bad;</a>
<a name="ln737">	}</a>
<a name="ln738">	error = ath_txdma_setup(sc);</a>
<a name="ln739">	if (error != 0) {</a>
<a name="ln740">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln741">		    &quot;failed to allocate TX descriptors: %d\n&quot;, error);</a>
<a name="ln742">		goto bad;</a>
<a name="ln743">	}</a>
<a name="ln744"> </a>
<a name="ln745">	/*</a>
<a name="ln746">	 * Allocate RX descriptors and populate the lists.</a>
<a name="ln747">	 */</a>
<a name="ln748">	error = ath_rxdma_setup(sc);</a>
<a name="ln749">	if (error != 0) {</a>
<a name="ln750">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln751">		     &quot;failed to allocate RX descriptors: %d\n&quot;, error);</a>
<a name="ln752">		goto bad;</a>
<a name="ln753">	}</a>
<a name="ln754"> </a>
<a name="ln755">	callout_init_mtx(&amp;sc-&gt;sc_cal_ch, &amp;sc-&gt;sc_mtx, 0);</a>
<a name="ln756">	callout_init_mtx(&amp;sc-&gt;sc_wd_ch, &amp;sc-&gt;sc_mtx, 0);</a>
<a name="ln757"> </a>
<a name="ln758">	ATH_TXBUF_LOCK_INIT(sc);</a>
<a name="ln759"> </a>
<a name="ln760">	sc-&gt;sc_tq = taskqueue_create(&quot;ath_taskq&quot;, M_NOWAIT,</a>
<a name="ln761">		taskqueue_thread_enqueue, &amp;sc-&gt;sc_tq);</a>
<a name="ln762">	taskqueue_start_threads(&amp;sc-&gt;sc_tq, 1, PI_NET, &quot;%s taskq&quot;,</a>
<a name="ln763">	    device_get_nameunit(sc-&gt;sc_dev));</a>
<a name="ln764"> </a>
<a name="ln765">	TASK_INIT(&amp;sc-&gt;sc_rxtask, 0, sc-&gt;sc_rx.recv_tasklet, sc);</a>
<a name="ln766">	TASK_INIT(&amp;sc-&gt;sc_bmisstask, 0, ath_bmiss_proc, sc);</a>
<a name="ln767">	TASK_INIT(&amp;sc-&gt;sc_bstucktask,0, ath_bstuck_proc, sc);</a>
<a name="ln768">	TASK_INIT(&amp;sc-&gt;sc_resettask,0, ath_reset_proc, sc);</a>
<a name="ln769">	TASK_INIT(&amp;sc-&gt;sc_txqtask, 0, ath_txq_sched_tasklet, sc);</a>
<a name="ln770">	TASK_INIT(&amp;sc-&gt;sc_fataltask, 0, ath_fatal_proc, sc);</a>
<a name="ln771"> </a>
<a name="ln772">	/*</a>
<a name="ln773">	 * Allocate hardware transmit queues: one queue for</a>
<a name="ln774">	 * beacon frames and one data queue for each QoS</a>
<a name="ln775">	 * priority.  Note that the hal handles resetting</a>
<a name="ln776">	 * these queues at the needed time.</a>
<a name="ln777">	 *</a>
<a name="ln778">	 * XXX PS-Poll</a>
<a name="ln779">	 */</a>
<a name="ln780">	sc-&gt;sc_bhalq = ath_beaconq_setup(sc);</a>
<a name="ln781">	if (sc-&gt;sc_bhalq == (u_int) -1) {</a>
<a name="ln782">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln783">		    &quot;unable to setup a beacon xmit queue!\n&quot;);</a>
<a name="ln784">		error = EIO;</a>
<a name="ln785">		goto bad2;</a>
<a name="ln786">	}</a>
<a name="ln787">	sc-&gt;sc_cabq = ath_txq_setup(sc, HAL_TX_QUEUE_CAB, 0);</a>
<a name="ln788">	if (sc-&gt;sc_cabq == NULL) {</a>
<a name="ln789">		device_printf(sc-&gt;sc_dev, &quot;unable to setup CAB xmit queue!\n&quot;);</a>
<a name="ln790">		error = EIO;</a>
<a name="ln791">		goto bad2;</a>
<a name="ln792">	}</a>
<a name="ln793">	/* NB: insure BK queue is the lowest priority h/w queue */</a>
<a name="ln794">	if (!ath_tx_setup(sc, WME_AC_BK, HAL_WME_AC_BK)) {</a>
<a name="ln795">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln796">		    &quot;unable to setup xmit queue for %s traffic!\n&quot;,</a>
<a name="ln797">		    ieee80211_wme_acnames[WME_AC_BK]);</a>
<a name="ln798">		error = EIO;</a>
<a name="ln799">		goto bad2;</a>
<a name="ln800">	}</a>
<a name="ln801">	if (!ath_tx_setup(sc, WME_AC_BE, HAL_WME_AC_BE) ||</a>
<a name="ln802">	    !ath_tx_setup(sc, WME_AC_VI, HAL_WME_AC_VI) ||</a>
<a name="ln803">	    !ath_tx_setup(sc, WME_AC_VO, HAL_WME_AC_VO)) {</a>
<a name="ln804">		/*</a>
<a name="ln805">		 * Not enough hardware tx queues to properly do WME;</a>
<a name="ln806">		 * just punt and assign them all to the same h/w queue.</a>
<a name="ln807">		 * We could do a better job of this if, for example,</a>
<a name="ln808">		 * we allocate queues when we switch from station to</a>
<a name="ln809">		 * AP mode.</a>
<a name="ln810">		 */</a>
<a name="ln811">		if (sc-&gt;sc_ac2q[WME_AC_VI] != NULL)</a>
<a name="ln812">			ath_tx_cleanupq(sc, sc-&gt;sc_ac2q[WME_AC_VI]);</a>
<a name="ln813">		if (sc-&gt;sc_ac2q[WME_AC_BE] != NULL)</a>
<a name="ln814">			ath_tx_cleanupq(sc, sc-&gt;sc_ac2q[WME_AC_BE]);</a>
<a name="ln815">		sc-&gt;sc_ac2q[WME_AC_BE] = sc-&gt;sc_ac2q[WME_AC_BK];</a>
<a name="ln816">		sc-&gt;sc_ac2q[WME_AC_VI] = sc-&gt;sc_ac2q[WME_AC_BK];</a>
<a name="ln817">		sc-&gt;sc_ac2q[WME_AC_VO] = sc-&gt;sc_ac2q[WME_AC_BK];</a>
<a name="ln818">	}</a>
<a name="ln819"> </a>
<a name="ln820">	/*</a>
<a name="ln821">	 * Attach the TX completion function.</a>
<a name="ln822">	 *</a>
<a name="ln823">	 * The non-EDMA chips may have some special case optimisations;</a>
<a name="ln824">	 * this method gives everyone a chance to attach cleanly.</a>
<a name="ln825">	 */</a>
<a name="ln826">	sc-&gt;sc_tx.xmit_attach_comp_func(sc);</a>
<a name="ln827"> </a>
<a name="ln828">	/*</a>
<a name="ln829">	 * Setup rate control.  Some rate control modules</a>
<a name="ln830">	 * call back to change the anntena state so expose</a>
<a name="ln831">	 * the necessary entry points.</a>
<a name="ln832">	 * XXX maybe belongs in struct ath_ratectrl?</a>
<a name="ln833">	 */</a>
<a name="ln834">	sc-&gt;sc_setdefantenna = ath_setdefantenna;</a>
<a name="ln835">	sc-&gt;sc_rc = ath_rate_attach(sc);</a>
<a name="ln836">	if (sc-&gt;sc_rc == NULL) {</a>
<a name="ln837">		error = EIO;</a>
<a name="ln838">		goto bad2;</a>
<a name="ln839">	}</a>
<a name="ln840"> </a>
<a name="ln841">	/* Attach DFS module */</a>
<a name="ln842">	if (! ath_dfs_attach(sc)) {</a>
<a name="ln843">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln844">		    &quot;%s: unable to attach DFS\n&quot;, __func__);</a>
<a name="ln845">		error = EIO;</a>
<a name="ln846">		goto bad2;</a>
<a name="ln847">	}</a>
<a name="ln848"> </a>
<a name="ln849">	/* Attach spectral module */</a>
<a name="ln850">	if (ath_spectral_attach(sc) &lt; 0) {</a>
<a name="ln851">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln852">		    &quot;%s: unable to attach spectral\n&quot;, __func__);</a>
<a name="ln853">		error = EIO;</a>
<a name="ln854">		goto bad2;</a>
<a name="ln855">	}</a>
<a name="ln856"> </a>
<a name="ln857">	/* Attach bluetooth coexistence module */</a>
<a name="ln858">	if (ath_btcoex_attach(sc) &lt; 0) {</a>
<a name="ln859">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln860">		    &quot;%s: unable to attach bluetooth coexistence\n&quot;, __func__);</a>
<a name="ln861">		error = EIO;</a>
<a name="ln862">		goto bad2;</a>
<a name="ln863">	}</a>
<a name="ln864"> </a>
<a name="ln865">	/* Attach LNA diversity module */</a>
<a name="ln866">	if (ath_lna_div_attach(sc) &lt; 0) {</a>
<a name="ln867">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln868">		    &quot;%s: unable to attach LNA diversity\n&quot;, __func__);</a>
<a name="ln869">		error = EIO;</a>
<a name="ln870">		goto bad2;</a>
<a name="ln871">	}</a>
<a name="ln872"> </a>
<a name="ln873">	/* Start DFS processing tasklet */</a>
<a name="ln874">	TASK_INIT(&amp;sc-&gt;sc_dfstask, 0, ath_dfs_tasklet, sc);</a>
<a name="ln875"> </a>
<a name="ln876">	/* Configure LED state */</a>
<a name="ln877">	sc-&gt;sc_blinking = 0;</a>
<a name="ln878">	sc-&gt;sc_ledstate = 1;</a>
<a name="ln879">	sc-&gt;sc_ledon = 0;			/* low true */</a>
<a name="ln880">	sc-&gt;sc_ledidle = (2700*hz)/1000;	/* 2.7sec */</a>
<a name="ln881">	callout_init(&amp;sc-&gt;sc_ledtimer, 1);</a>
<a name="ln882"> </a>
<a name="ln883">	/*</a>
<a name="ln884">	 * Don't setup hardware-based blinking.</a>
<a name="ln885">	 *</a>
<a name="ln886">	 * Although some NICs may have this configured in the</a>
<a name="ln887">	 * default reset register values, the user may wish</a>
<a name="ln888">	 * to alter which pins have which function.</a>
<a name="ln889">	 *</a>
<a name="ln890">	 * The reference driver attaches the MAC network LED to GPIO1 and</a>
<a name="ln891">	 * the MAC power LED to GPIO2.  However, the DWA-552 cardbus</a>
<a name="ln892">	 * NIC has these reversed.</a>
<a name="ln893">	 */</a>
<a name="ln894">	sc-&gt;sc_hardled = (1 == 0);</a>
<a name="ln895">	sc-&gt;sc_led_net_pin = -1;</a>
<a name="ln896">	sc-&gt;sc_led_pwr_pin = -1;</a>
<a name="ln897">	/*</a>
<a name="ln898">	 * Auto-enable soft led processing for IBM cards and for</a>
<a name="ln899">	 * 5211 minipci cards.  Users can also manually enable/disable</a>
<a name="ln900">	 * support with a sysctl.</a>
<a name="ln901">	 */</a>
<a name="ln902">	sc-&gt;sc_softled = (devid == AR5212_DEVID_IBM || devid == AR5211_DEVID);</a>
<a name="ln903">	ath_led_config(sc);</a>
<a name="ln904">	ath_hal_setledstate(ah, HAL_LED_INIT);</a>
<a name="ln905"> </a>
<a name="ln906">	/* XXX not right but it's not used anywhere important */</a>
<a name="ln907">	ic-&gt;ic_phytype = IEEE80211_T_OFDM;</a>
<a name="ln908">	ic-&gt;ic_opmode = IEEE80211_M_STA;</a>
<a name="ln909">	ic-&gt;ic_caps =</a>
<a name="ln910">		  IEEE80211_C_STA		/* station mode */</a>
<a name="ln911">		| IEEE80211_C_IBSS		/* ibss, nee adhoc, mode */</a>
<a name="ln912">		| IEEE80211_C_HOSTAP		/* hostap mode */</a>
<a name="ln913">		| IEEE80211_C_MONITOR		/* monitor mode */</a>
<a name="ln914">		| IEEE80211_C_AHDEMO		/* adhoc demo mode */</a>
<a name="ln915">		| IEEE80211_C_WDS		/* 4-address traffic works */</a>
<a name="ln916">		| IEEE80211_C_MBSS		/* mesh point link mode */</a>
<a name="ln917">		| IEEE80211_C_SHPREAMBLE	/* short preamble supported */</a>
<a name="ln918">		| IEEE80211_C_SHSLOT		/* short slot time supported */</a>
<a name="ln919">		| IEEE80211_C_WPA		/* capable of WPA1+WPA2 */</a>
<a name="ln920">#ifndef	ATH_ENABLE_11N</a>
<a name="ln921">		| IEEE80211_C_BGSCAN		/* capable of bg scanning */</a>
<a name="ln922">#endif</a>
<a name="ln923">		| IEEE80211_C_TXFRAG		/* handle tx frags */</a>
<a name="ln924">#ifdef	ATH_ENABLE_DFS</a>
<a name="ln925">		| IEEE80211_C_DFS		/* Enable radar detection */</a>
<a name="ln926">#endif</a>
<a name="ln927">		| IEEE80211_C_PMGT		/* Station side power mgmt */</a>
<a name="ln928">		| IEEE80211_C_SWSLEEP</a>
<a name="ln929">		;</a>
<a name="ln930">	/*</a>
<a name="ln931">	 * Query the hal to figure out h/w crypto support.</a>
<a name="ln932">	 */</a>
<a name="ln933">	if (ath_hal_ciphersupported(ah, HAL_CIPHER_WEP))</a>
<a name="ln934">		ic-&gt;ic_cryptocaps |= IEEE80211_CRYPTO_WEP;</a>
<a name="ln935">	if (ath_hal_ciphersupported(ah, HAL_CIPHER_AES_OCB))</a>
<a name="ln936">		ic-&gt;ic_cryptocaps |= IEEE80211_CRYPTO_AES_OCB;</a>
<a name="ln937">	if (ath_hal_ciphersupported(ah, HAL_CIPHER_AES_CCM))</a>
<a name="ln938">		ic-&gt;ic_cryptocaps |= IEEE80211_CRYPTO_AES_CCM;</a>
<a name="ln939">	if (ath_hal_ciphersupported(ah, HAL_CIPHER_CKIP))</a>
<a name="ln940">		ic-&gt;ic_cryptocaps |= IEEE80211_CRYPTO_CKIP;</a>
<a name="ln941">	if (ath_hal_ciphersupported(ah, HAL_CIPHER_TKIP)) {</a>
<a name="ln942">		ic-&gt;ic_cryptocaps |= IEEE80211_CRYPTO_TKIP;</a>
<a name="ln943">		/*</a>
<a name="ln944">		 * Check if h/w does the MIC and/or whether the</a>
<a name="ln945">		 * separate key cache entries are required to</a>
<a name="ln946">		 * handle both tx+rx MIC keys.</a>
<a name="ln947">		 */</a>
<a name="ln948">		if (ath_hal_ciphersupported(ah, HAL_CIPHER_MIC))</a>
<a name="ln949">			ic-&gt;ic_cryptocaps |= IEEE80211_CRYPTO_TKIPMIC;</a>
<a name="ln950">		/*</a>
<a name="ln951">		 * If the h/w supports storing tx+rx MIC keys</a>
<a name="ln952">		 * in one cache slot automatically enable use.</a>
<a name="ln953">		 */</a>
<a name="ln954">		if (ath_hal_hastkipsplit(ah) ||</a>
<a name="ln955">		    !ath_hal_settkipsplit(ah, AH_FALSE))</a>
<a name="ln956">			sc-&gt;sc_splitmic = 1;</a>
<a name="ln957">		/*</a>
<a name="ln958">		 * If the h/w can do TKIP MIC together with WME then</a>
<a name="ln959">		 * we use it; otherwise we force the MIC to be done</a>
<a name="ln960">		 * in software by the net80211 layer.</a>
<a name="ln961">		 */</a>
<a name="ln962">		if (ath_hal_haswmetkipmic(ah))</a>
<a name="ln963">			sc-&gt;sc_wmetkipmic = 1;</a>
<a name="ln964">	}</a>
<a name="ln965">	sc-&gt;sc_hasclrkey = ath_hal_ciphersupported(ah, HAL_CIPHER_CLR);</a>
<a name="ln966">	/*</a>
<a name="ln967">	 * Check for multicast key search support.</a>
<a name="ln968">	 */</a>
<a name="ln969">	if (ath_hal_hasmcastkeysearch(sc-&gt;sc_ah) &amp;&amp;</a>
<a name="ln970">	    !ath_hal_getmcastkeysearch(sc-&gt;sc_ah)) {</a>
<a name="ln971">		ath_hal_setmcastkeysearch(sc-&gt;sc_ah, 1);</a>
<a name="ln972">	}</a>
<a name="ln973">	sc-&gt;sc_mcastkey = ath_hal_getmcastkeysearch(ah);</a>
<a name="ln974">	/*</a>
<a name="ln975">	 * Mark key cache slots associated with global keys</a>
<a name="ln976">	 * as in use.  If we knew TKIP was not to be used we</a>
<a name="ln977">	 * could leave the +32, +64, and +32+64 slots free.</a>
<a name="ln978">	 */</a>
<a name="ln979">	for (i = 0; i &lt; IEEE80211_WEP_NKID; i++) {</a>
<a name="ln980">		setbit(sc-&gt;sc_keymap, i);</a>
<a name="ln981">		setbit(sc-&gt;sc_keymap, i+64);</a>
<a name="ln982">		if (sc-&gt;sc_splitmic) {</a>
<a name="ln983">			setbit(sc-&gt;sc_keymap, i+32);</a>
<a name="ln984">			setbit(sc-&gt;sc_keymap, i+32+64);</a>
<a name="ln985">		}</a>
<a name="ln986">	}</a>
<a name="ln987">	/*</a>
<a name="ln988">	 * TPC support can be done either with a global cap or</a>
<a name="ln989">	 * per-packet support.  The latter is not available on</a>
<a name="ln990">	 * all parts.  We're a bit pedantic here as all parts</a>
<a name="ln991">	 * support a global cap.</a>
<a name="ln992">	 */</a>
<a name="ln993">	if (ath_hal_hastpc(ah) || ath_hal_hastxpowlimit(ah))</a>
<a name="ln994">		ic-&gt;ic_caps |= IEEE80211_C_TXPMGT;</a>
<a name="ln995"> </a>
<a name="ln996">	/*</a>
<a name="ln997">	 * Mark WME capability only if we have sufficient</a>
<a name="ln998">	 * hardware queues to do proper priority scheduling.</a>
<a name="ln999">	 */</a>
<a name="ln1000">	if (sc-&gt;sc_ac2q[WME_AC_BE] != sc-&gt;sc_ac2q[WME_AC_BK])</a>
<a name="ln1001">		ic-&gt;ic_caps |= IEEE80211_C_WME;</a>
<a name="ln1002">	/*</a>
<a name="ln1003">	 * Check for misc other capabilities.</a>
<a name="ln1004">	 */</a>
<a name="ln1005">	if (ath_hal_hasbursting(ah))</a>
<a name="ln1006">		ic-&gt;ic_caps |= IEEE80211_C_BURST;</a>
<a name="ln1007">	sc-&gt;sc_hasbmask = ath_hal_hasbssidmask(ah);</a>
<a name="ln1008">	sc-&gt;sc_hasbmatch = ath_hal_hasbssidmatch(ah);</a>
<a name="ln1009">	sc-&gt;sc_hastsfadd = ath_hal_hastsfadjust(ah);</a>
<a name="ln1010">	sc-&gt;sc_rxslink = ath_hal_self_linked_final_rxdesc(ah);</a>
<a name="ln1011"> </a>
<a name="ln1012">	/* XXX TODO: just make this a &quot;store tx/rx timestamp length&quot; operation */</a>
<a name="ln1013">	if (ath_hal_get_rx_tsf_prec(ah, &amp;i)) {</a>
<a name="ln1014">		if (i == 32) {</a>
<a name="ln1015">			sc-&gt;sc_rxtsf32 = 1;</a>
<a name="ln1016">		}</a>
<a name="ln1017">		if (bootverbose)</a>
<a name="ln1018">			device_printf(sc-&gt;sc_dev, &quot;RX timestamp: %d bits\n&quot;, i);</a>
<a name="ln1019">	}</a>
<a name="ln1020">	if (ath_hal_get_tx_tsf_prec(ah, &amp;i)) {</a>
<a name="ln1021">		if (bootverbose)</a>
<a name="ln1022">			device_printf(sc-&gt;sc_dev, &quot;TX timestamp: %d bits\n&quot;, i);</a>
<a name="ln1023">	}</a>
<a name="ln1024"> </a>
<a name="ln1025">	sc-&gt;sc_hasenforcetxop = ath_hal_hasenforcetxop(ah);</a>
<a name="ln1026">	sc-&gt;sc_rx_lnamixer = ath_hal_hasrxlnamixer(ah);</a>
<a name="ln1027">	sc-&gt;sc_hasdivcomb = ath_hal_hasdivantcomb(ah);</a>
<a name="ln1028"> </a>
<a name="ln1029">	/*</a>
<a name="ln1030">	 * Some WB335 cards do not support antenna diversity. Since</a>
<a name="ln1031">	 * we use a hardcoded value for AR9565 instead of using the</a>
<a name="ln1032">	 * EEPROM/OTP data, remove the combining feature from</a>
<a name="ln1033">	 * the HW capabilities bitmap.</a>
<a name="ln1034">	 */</a>
<a name="ln1035">	/*</a>
<a name="ln1036">	 * XXX TODO: check reference driver and ath9k for what to do</a>
<a name="ln1037">	 * here for WB335.  I think we have to actually disable the</a>
<a name="ln1038">	 * LNA div processing in the HAL and instead use the hard</a>
<a name="ln1039">	 * coded values; and then use BT diversity.</a>
<a name="ln1040">	 *</a>
<a name="ln1041">	 * .. but also need to setup MCI too for WB335..</a>
<a name="ln1042">	 */</a>
<a name="ln1043">#if 0</a>
<a name="ln1044">	if (sc-&gt;sc_pci_devinfo &amp; (ATH9K_PCI_AR9565_1ANT | ATH9K_PCI_AR9565_2ANT)) {</a>
<a name="ln1045">		device_printf(sc-&gt;sc_dev, &quot;%s: WB335: disabling LNA mixer diversity\n&quot;,</a>
<a name="ln1046">		    __func__);</a>
<a name="ln1047">		sc-&gt;sc_dolnadiv = 0;</a>
<a name="ln1048">	}</a>
<a name="ln1049">#endif</a>
<a name="ln1050"> </a>
<a name="ln1051">	if (ath_hal_hasfastframes(ah))</a>
<a name="ln1052">		ic-&gt;ic_caps |= IEEE80211_C_FF;</a>
<a name="ln1053">	wmodes = ath_hal_getwirelessmodes(ah);</a>
<a name="ln1054">	if (wmodes &amp; (HAL_MODE_108G|HAL_MODE_TURBO))</a>
<a name="ln1055">		ic-&gt;ic_caps |= IEEE80211_C_TURBOP;</a>
<a name="ln1056">#ifdef IEEE80211_SUPPORT_TDMA</a>
<a name="ln1057">	if (ath_hal_macversion(ah) &gt; 0x78) {</a>
<a name="ln1058">		ic-&gt;ic_caps |= IEEE80211_C_TDMA; /* capable of TDMA */</a>
<a name="ln1059">		ic-&gt;ic_tdma_update = ath_tdma_update;</a>
<a name="ln1060">	}</a>
<a name="ln1061">#endif</a>
<a name="ln1062"> </a>
<a name="ln1063">	/*</a>
<a name="ln1064">	 * TODO: enforce that at least this many frames are available</a>
<a name="ln1065">	 * in the txbuf list before allowing data frames (raw or</a>
<a name="ln1066">	 * otherwise) to be transmitted.</a>
<a name="ln1067">	 */</a>
<a name="ln1068">	sc-&gt;sc_txq_data_minfree = 10;</a>
<a name="ln1069"> </a>
<a name="ln1070">	/*</a>
<a name="ln1071">	 * Shorten this to 64 packets, or 1/4 ath_txbuf, whichever</a>
<a name="ln1072">	 * is smaller.</a>
<a name="ln1073">	 *</a>
<a name="ln1074">	 * Anything bigger can potentially see the cabq consume</a>
<a name="ln1075">	 * almost all buffers, starving everything else, only to</a>
<a name="ln1076">	 * see most fail to transmit in the given beacon interval.</a>
<a name="ln1077">	 */</a>
<a name="ln1078">	sc-&gt;sc_txq_mcastq_maxdepth = MIN(64, ath_txbuf / 4);</a>
<a name="ln1079"> </a>
<a name="ln1080">	/*</a>
<a name="ln1081">	 * How deep can the node software TX queue get whilst it's asleep.</a>
<a name="ln1082">	 */</a>
<a name="ln1083">	sc-&gt;sc_txq_node_psq_maxdepth = 16;</a>
<a name="ln1084"> </a>
<a name="ln1085">	/*</a>
<a name="ln1086">	 * Default the maximum queue to 1/4'th the TX buffers, or</a>
<a name="ln1087">	 * 64, whichever is smaller.</a>
<a name="ln1088">	 */</a>
<a name="ln1089">	sc-&gt;sc_txq_node_maxdepth = MIN(64, ath_txbuf / 4);</a>
<a name="ln1090"> </a>
<a name="ln1091">	/* Enable CABQ by default */</a>
<a name="ln1092">	sc-&gt;sc_cabq_enable = 1;</a>
<a name="ln1093"> </a>
<a name="ln1094">	/*</a>
<a name="ln1095">	 * Allow the TX and RX chainmasks to be overridden by</a>
<a name="ln1096">	 * environment variables and/or device.hints.</a>
<a name="ln1097">	 *</a>
<a name="ln1098">	 * This must be done early - before the hardware is</a>
<a name="ln1099">	 * calibrated or before the 802.11n stream calculation</a>
<a name="ln1100">	 * is done.</a>
<a name="ln1101">	 */</a>
<a name="ln1102">	if (resource_int_value(device_get_name(sc-&gt;sc_dev),</a>
<a name="ln1103">	    device_get_unit(sc-&gt;sc_dev), &quot;rx_chainmask&quot;,</a>
<a name="ln1104">	    &amp;rx_chainmask) == 0) {</a>
<a name="ln1105">		device_printf(sc-&gt;sc_dev, &quot;Setting RX chainmask to 0x%x\n&quot;,</a>
<a name="ln1106">		    rx_chainmask);</a>
<a name="ln1107">		(void) ath_hal_setrxchainmask(sc-&gt;sc_ah, rx_chainmask);</a>
<a name="ln1108">	}</a>
<a name="ln1109">	if (resource_int_value(device_get_name(sc-&gt;sc_dev),</a>
<a name="ln1110">	    device_get_unit(sc-&gt;sc_dev), &quot;tx_chainmask&quot;,</a>
<a name="ln1111">	    &amp;tx_chainmask) == 0) {</a>
<a name="ln1112">		device_printf(sc-&gt;sc_dev, &quot;Setting TX chainmask to 0x%x\n&quot;,</a>
<a name="ln1113">		    tx_chainmask);</a>
<a name="ln1114">		(void) ath_hal_settxchainmask(sc-&gt;sc_ah, tx_chainmask);</a>
<a name="ln1115">	}</a>
<a name="ln1116"> </a>
<a name="ln1117">	/*</a>
<a name="ln1118">	 * Query the TX/RX chainmask configuration.</a>
<a name="ln1119">	 *</a>
<a name="ln1120">	 * This is only relevant for 11n devices.</a>
<a name="ln1121">	 */</a>
<a name="ln1122">	ath_hal_getrxchainmask(ah, &amp;sc-&gt;sc_rxchainmask);</a>
<a name="ln1123">	ath_hal_gettxchainmask(ah, &amp;sc-&gt;sc_txchainmask);</a>
<a name="ln1124"> </a>
<a name="ln1125">	/*</a>
<a name="ln1126">	 * Disable MRR with protected frames by default.</a>
<a name="ln1127">	 * Only 802.11n series NICs can handle this.</a>
<a name="ln1128">	 */</a>
<a name="ln1129">	sc-&gt;sc_mrrprot = 0;	/* XXX should be a capability */</a>
<a name="ln1130"> </a>
<a name="ln1131">	/*</a>
<a name="ln1132">	 * Query the enterprise mode information the HAL.</a>
<a name="ln1133">	 */</a>
<a name="ln1134">	if (ath_hal_getcapability(ah, HAL_CAP_ENTERPRISE_MODE, 0,</a>
<a name="ln1135">	    &amp;sc-&gt;sc_ent_cfg) == HAL_OK)</a>
<a name="ln1136">		sc-&gt;sc_use_ent = 1;</a>
<a name="ln1137"> </a>
<a name="ln1138">#ifdef	ATH_ENABLE_11N</a>
<a name="ln1139">	/*</a>
<a name="ln1140">	 * Query HT capabilities</a>
<a name="ln1141">	 */</a>
<a name="ln1142">	if (ath_hal_getcapability(ah, HAL_CAP_HT, 0, NULL) == HAL_OK &amp;&amp;</a>
<a name="ln1143">	    (wmodes &amp; (HAL_MODE_HT20 | HAL_MODE_HT40))) {</a>
<a name="ln1144">		uint32_t rxs, txs;</a>
<a name="ln1145">		uint32_t ldpc;</a>
<a name="ln1146"> </a>
<a name="ln1147">		device_printf(sc-&gt;sc_dev, &quot;[HT] enabling HT modes\n&quot;);</a>
<a name="ln1148"> </a>
<a name="ln1149">		sc-&gt;sc_mrrprot = 1;	/* XXX should be a capability */</a>
<a name="ln1150"> </a>
<a name="ln1151">		ic-&gt;ic_htcaps = IEEE80211_HTC_HT	/* HT operation */</a>
<a name="ln1152">			    | IEEE80211_HTC_AMPDU	/* A-MPDU tx/rx */</a>
<a name="ln1153">			    | IEEE80211_HTC_AMSDU	/* A-MSDU tx/rx */</a>
<a name="ln1154">			    | IEEE80211_HTCAP_MAXAMSDU_3839</a>
<a name="ln1155">			    				/* max A-MSDU length */</a>
<a name="ln1156">			    | IEEE80211_HTCAP_SMPS_OFF;	/* SM power save off */</a>
<a name="ln1157"> </a>
<a name="ln1158">		/*</a>
<a name="ln1159">		 * Enable short-GI for HT20 only if the hardware</a>
<a name="ln1160">		 * advertises support.</a>
<a name="ln1161">		 * Notably, anything earlier than the AR9287 doesn't.</a>
<a name="ln1162">		 */</a>
<a name="ln1163">		if ((ath_hal_getcapability(ah,</a>
<a name="ln1164">		    HAL_CAP_HT20_SGI, 0, NULL) == HAL_OK) &amp;&amp;</a>
<a name="ln1165">		    (wmodes &amp; HAL_MODE_HT20)) {</a>
<a name="ln1166">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1167">			    &quot;[HT] enabling short-GI in 20MHz mode\n&quot;);</a>
<a name="ln1168">			ic-&gt;ic_htcaps |= IEEE80211_HTCAP_SHORTGI20;</a>
<a name="ln1169">		}</a>
<a name="ln1170"> </a>
<a name="ln1171">		if (wmodes &amp; HAL_MODE_HT40)</a>
<a name="ln1172">			ic-&gt;ic_htcaps |= IEEE80211_HTCAP_CHWIDTH40</a>
<a name="ln1173">			    |  IEEE80211_HTCAP_SHORTGI40;</a>
<a name="ln1174"> </a>
<a name="ln1175">		/*</a>
<a name="ln1176">		 * TX/RX streams need to be taken into account when</a>
<a name="ln1177">		 * negotiating which MCS rates it'll receive and</a>
<a name="ln1178">		 * what MCS rates are available for TX.</a>
<a name="ln1179">		 */</a>
<a name="ln1180">		(void) ath_hal_getcapability(ah, HAL_CAP_STREAMS, 0, &amp;txs);</a>
<a name="ln1181">		(void) ath_hal_getcapability(ah, HAL_CAP_STREAMS, 1, &amp;rxs);</a>
<a name="ln1182">		ic-&gt;ic_txstream = txs;</a>
<a name="ln1183">		ic-&gt;ic_rxstream = rxs;</a>
<a name="ln1184"> </a>
<a name="ln1185">		/*</a>
<a name="ln1186">		 * Setup TX and RX STBC based on what the HAL allows and</a>
<a name="ln1187">		 * the currently configured chainmask set.</a>
<a name="ln1188">		 * Ie - don't enable STBC TX if only one chain is enabled.</a>
<a name="ln1189">		 * STBC RX is fine on a single RX chain; it just won't</a>
<a name="ln1190">		 * provide any real benefit.</a>
<a name="ln1191">		 */</a>
<a name="ln1192">		if (ath_hal_getcapability(ah, HAL_CAP_RX_STBC, 0,</a>
<a name="ln1193">		    NULL) == HAL_OK) {</a>
<a name="ln1194">			sc-&gt;sc_rx_stbc = 1;</a>
<a name="ln1195">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1196">			    &quot;[HT] 1 stream STBC receive enabled\n&quot;);</a>
<a name="ln1197">			ic-&gt;ic_htcaps |= IEEE80211_HTCAP_RXSTBC_1STREAM;</a>
<a name="ln1198">		}</a>
<a name="ln1199">		if (txs &gt; 1 &amp;&amp; ath_hal_getcapability(ah, HAL_CAP_TX_STBC, 0,</a>
<a name="ln1200">		    NULL) == HAL_OK) {</a>
<a name="ln1201">			sc-&gt;sc_tx_stbc = 1;</a>
<a name="ln1202">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1203">			    &quot;[HT] 1 stream STBC transmit enabled\n&quot;);</a>
<a name="ln1204">			ic-&gt;ic_htcaps |= IEEE80211_HTCAP_TXSTBC;</a>
<a name="ln1205">		}</a>
<a name="ln1206"> </a>
<a name="ln1207">		(void) ath_hal_getcapability(ah, HAL_CAP_RTS_AGGR_LIMIT, 1,</a>
<a name="ln1208">		    &amp;sc-&gt;sc_rts_aggr_limit);</a>
<a name="ln1209">		if (sc-&gt;sc_rts_aggr_limit != (64 * 1024))</a>
<a name="ln1210">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1211">			    &quot;[HT] RTS aggregates limited to %d KiB\n&quot;,</a>
<a name="ln1212">			    sc-&gt;sc_rts_aggr_limit / 1024);</a>
<a name="ln1213"> </a>
<a name="ln1214">		/*</a>
<a name="ln1215">		 * LDPC</a>
<a name="ln1216">		 */</a>
<a name="ln1217">		if ((ath_hal_getcapability(ah, HAL_CAP_LDPC, 0, &amp;ldpc))</a>
<a name="ln1218">		    == HAL_OK &amp;&amp; (ldpc == 1)) {</a>
<a name="ln1219">			sc-&gt;sc_has_ldpc = 1;</a>
<a name="ln1220">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1221">			    &quot;[HT] LDPC transmit/receive enabled\n&quot;);</a>
<a name="ln1222">			ic-&gt;ic_htcaps |= IEEE80211_HTCAP_LDPC |</a>
<a name="ln1223">					 IEEE80211_HTC_TXLDPC;</a>
<a name="ln1224">		}</a>
<a name="ln1225"> </a>
<a name="ln1226"> </a>
<a name="ln1227">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln1228">		    &quot;[HT] %d RX streams; %d TX streams\n&quot;, rxs, txs);</a>
<a name="ln1229">	}</a>
<a name="ln1230">#endif</a>
<a name="ln1231"> </a>
<a name="ln1232">	/*</a>
<a name="ln1233">	 * Initial aggregation settings.</a>
<a name="ln1234">	 */</a>
<a name="ln1235">	sc-&gt;sc_hwq_limit_aggr = ATH_AGGR_MIN_QDEPTH;</a>
<a name="ln1236">	sc-&gt;sc_hwq_limit_nonaggr = ATH_NONAGGR_MIN_QDEPTH;</a>
<a name="ln1237">	sc-&gt;sc_tid_hwq_lo = ATH_AGGR_SCHED_LOW;</a>
<a name="ln1238">	sc-&gt;sc_tid_hwq_hi = ATH_AGGR_SCHED_HIGH;</a>
<a name="ln1239">	sc-&gt;sc_aggr_limit = ATH_AGGR_MAXSIZE;</a>
<a name="ln1240">	sc-&gt;sc_delim_min_pad = 0;</a>
<a name="ln1241"> </a>
<a name="ln1242">	/*</a>
<a name="ln1243">	 * Check if the hardware requires PCI register serialisation.</a>
<a name="ln1244">	 * Some of the Owl based MACs require this.</a>
<a name="ln1245">	 */</a>
<a name="ln1246">	if (mp_ncpus &gt; 1 &amp;&amp;</a>
<a name="ln1247">	    ath_hal_getcapability(ah, HAL_CAP_SERIALISE_WAR,</a>
<a name="ln1248">	     0, NULL) == HAL_OK) {</a>
<a name="ln1249">		sc-&gt;sc_ah-&gt;ah_config.ah_serialise_reg_war = 1;</a>
<a name="ln1250">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln1251">		    &quot;Enabling register serialisation\n&quot;);</a>
<a name="ln1252">	}</a>
<a name="ln1253"> </a>
<a name="ln1254">	/*</a>
<a name="ln1255">	 * Initialise the deferred completed RX buffer list.</a>
<a name="ln1256">	 */</a>
<a name="ln1257">	TAILQ_INIT(&amp;sc-&gt;sc_rx_rxlist[HAL_RX_QUEUE_HP]);</a>
<a name="ln1258">	TAILQ_INIT(&amp;sc-&gt;sc_rx_rxlist[HAL_RX_QUEUE_LP]);</a>
<a name="ln1259"> </a>
<a name="ln1260">	/*</a>
<a name="ln1261">	 * Indicate we need the 802.11 header padded to a</a>
<a name="ln1262">	 * 32-bit boundary for 4-address and QoS frames.</a>
<a name="ln1263">	 */</a>
<a name="ln1264">	ic-&gt;ic_flags |= IEEE80211_F_DATAPAD;</a>
<a name="ln1265"> </a>
<a name="ln1266">	/*</a>
<a name="ln1267">	 * Query the hal about antenna support.</a>
<a name="ln1268">	 */</a>
<a name="ln1269">	sc-&gt;sc_defant = ath_hal_getdefantenna(ah);</a>
<a name="ln1270"> </a>
<a name="ln1271">	/*</a>
<a name="ln1272">	 * Not all chips have the VEOL support we want to</a>
<a name="ln1273">	 * use with IBSS beacons; check here for it.</a>
<a name="ln1274">	 */</a>
<a name="ln1275">	sc-&gt;sc_hasveol = ath_hal_hasveol(ah);</a>
<a name="ln1276"> </a>
<a name="ln1277">	/* get mac address from kenv first, then hardware */</a>
<a name="ln1278">	if (ath_fetch_mac_kenv(sc, ic-&gt;ic_macaddr) == 0) {</a>
<a name="ln1279">		/* Tell the HAL now about the new MAC */</a>
<a name="ln1280">		ath_hal_setmac(ah, ic-&gt;ic_macaddr);</a>
<a name="ln1281">	} else {</a>
<a name="ln1282">		ath_hal_getmac(ah, ic-&gt;ic_macaddr);</a>
<a name="ln1283">	}</a>
<a name="ln1284"> </a>
<a name="ln1285">	if (sc-&gt;sc_hasbmask)</a>
<a name="ln1286">		ath_hal_getbssidmask(ah, sc-&gt;sc_hwbssidmask);</a>
<a name="ln1287"> </a>
<a name="ln1288">	/* NB: used to size node table key mapping array */</a>
<a name="ln1289">	ic-&gt;ic_max_keyix = sc-&gt;sc_keymax;</a>
<a name="ln1290">	/* call MI attach routine. */</a>
<a name="ln1291">	ieee80211_ifattach(ic);</a>
<a name="ln1292">	ic-&gt;ic_setregdomain = ath_setregdomain;</a>
<a name="ln1293">	ic-&gt;ic_getradiocaps = ath_getradiocaps;</a>
<a name="ln1294">	sc-&gt;sc_opmode = HAL_M_STA;</a>
<a name="ln1295"> </a>
<a name="ln1296">	/* override default methods */</a>
<a name="ln1297">	ic-&gt;ic_ioctl = ath_ioctl;</a>
<a name="ln1298">	ic-&gt;ic_parent = ath_parent;</a>
<a name="ln1299">	ic-&gt;ic_transmit = ath_transmit;</a>
<a name="ln1300">	ic-&gt;ic_newassoc = ath_newassoc;</a>
<a name="ln1301">	ic-&gt;ic_updateslot = ath_updateslot;</a>
<a name="ln1302">	ic-&gt;ic_wme.wme_update = ath_wme_update;</a>
<a name="ln1303">	ic-&gt;ic_vap_create = ath_vap_create;</a>
<a name="ln1304">	ic-&gt;ic_vap_delete = ath_vap_delete;</a>
<a name="ln1305">	ic-&gt;ic_raw_xmit = ath_raw_xmit;</a>
<a name="ln1306">	ic-&gt;ic_update_mcast = ath_update_mcast;</a>
<a name="ln1307">	ic-&gt;ic_update_promisc = ath_update_promisc;</a>
<a name="ln1308">	ic-&gt;ic_node_alloc = ath_node_alloc;</a>
<a name="ln1309">	sc-&gt;sc_node_free = ic-&gt;ic_node_free;</a>
<a name="ln1310">	ic-&gt;ic_node_free = ath_node_free;</a>
<a name="ln1311">	sc-&gt;sc_node_cleanup = ic-&gt;ic_node_cleanup;</a>
<a name="ln1312">	ic-&gt;ic_node_cleanup = ath_node_cleanup;</a>
<a name="ln1313">	ic-&gt;ic_node_getsignal = ath_node_getsignal;</a>
<a name="ln1314">	ic-&gt;ic_scan_start = ath_scan_start;</a>
<a name="ln1315">	ic-&gt;ic_scan_end = ath_scan_end;</a>
<a name="ln1316">	ic-&gt;ic_set_channel = ath_set_channel;</a>
<a name="ln1317">#ifdef	ATH_ENABLE_11N</a>
<a name="ln1318">	/* 802.11n specific - but just override anyway */</a>
<a name="ln1319">	sc-&gt;sc_addba_request = ic-&gt;ic_addba_request;</a>
<a name="ln1320">	sc-&gt;sc_addba_response = ic-&gt;ic_addba_response;</a>
<a name="ln1321">	sc-&gt;sc_addba_stop = ic-&gt;ic_addba_stop;</a>
<a name="ln1322">	sc-&gt;sc_bar_response = ic-&gt;ic_bar_response;</a>
<a name="ln1323">	sc-&gt;sc_addba_response_timeout = ic-&gt;ic_addba_response_timeout;</a>
<a name="ln1324"> </a>
<a name="ln1325">	ic-&gt;ic_addba_request = ath_addba_request;</a>
<a name="ln1326">	ic-&gt;ic_addba_response = ath_addba_response;</a>
<a name="ln1327">	ic-&gt;ic_addba_response_timeout = ath_addba_response_timeout;</a>
<a name="ln1328">	ic-&gt;ic_addba_stop = ath_addba_stop;</a>
<a name="ln1329">	ic-&gt;ic_bar_response = ath_bar_response;</a>
<a name="ln1330"> </a>
<a name="ln1331">	ic-&gt;ic_update_chw = ath_update_chw;</a>
<a name="ln1332">#endif	/* ATH_ENABLE_11N */</a>
<a name="ln1333">	ic-&gt;ic_set_quiet = ath_set_quiet_ie;</a>
<a name="ln1334"> </a>
<a name="ln1335">#ifdef	ATH_ENABLE_RADIOTAP_VENDOR_EXT</a>
<a name="ln1336">	/*</a>
<a name="ln1337">	 * There's one vendor bitmap entry in the RX radiotap</a>
<a name="ln1338">	 * header; make sure that's taken into account.</a>
<a name="ln1339">	 */</a>
<a name="ln1340">	ieee80211_radiotap_attachv(ic,</a>
<a name="ln1341">	    &amp;sc-&gt;sc_tx_th.wt_ihdr, sizeof(sc-&gt;sc_tx_th), 0,</a>
<a name="ln1342">		ATH_TX_RADIOTAP_PRESENT,</a>
<a name="ln1343">	    &amp;sc-&gt;sc_rx_th.wr_ihdr, sizeof(sc-&gt;sc_rx_th), 1,</a>
<a name="ln1344">		ATH_RX_RADIOTAP_PRESENT);</a>
<a name="ln1345">#else</a>
<a name="ln1346">	/*</a>
<a name="ln1347">	 * No vendor bitmap/extensions are present.</a>
<a name="ln1348">	 */</a>
<a name="ln1349">	ieee80211_radiotap_attach(ic,</a>
<a name="ln1350">	    &amp;sc-&gt;sc_tx_th.wt_ihdr, sizeof(sc-&gt;sc_tx_th),</a>
<a name="ln1351">		ATH_TX_RADIOTAP_PRESENT,</a>
<a name="ln1352">	    &amp;sc-&gt;sc_rx_th.wr_ihdr, sizeof(sc-&gt;sc_rx_th),</a>
<a name="ln1353">		ATH_RX_RADIOTAP_PRESENT);</a>
<a name="ln1354">#endif	/* ATH_ENABLE_RADIOTAP_VENDOR_EXT */</a>
<a name="ln1355"> </a>
<a name="ln1356">	/*</a>
<a name="ln1357">	 * Setup the ALQ logging if required</a>
<a name="ln1358">	 */</a>
<a name="ln1359">#ifdef	ATH_DEBUG_ALQ</a>
<a name="ln1360">	if_ath_alq_init(&amp;sc-&gt;sc_alq, device_get_nameunit(sc-&gt;sc_dev));</a>
<a name="ln1361">	if_ath_alq_setcfg(&amp;sc-&gt;sc_alq,</a>
<a name="ln1362">	    sc-&gt;sc_ah-&gt;ah_macVersion,</a>
<a name="ln1363">	    sc-&gt;sc_ah-&gt;ah_macRev,</a>
<a name="ln1364">	    sc-&gt;sc_ah-&gt;ah_phyRev,</a>
<a name="ln1365">	    sc-&gt;sc_ah-&gt;ah_magic);</a>
<a name="ln1366">#endif</a>
<a name="ln1367"> </a>
<a name="ln1368">	/*</a>
<a name="ln1369">	 * Setup dynamic sysctl's now that country code and</a>
<a name="ln1370">	 * regdomain are available from the hal.</a>
<a name="ln1371">	 */</a>
<a name="ln1372">	ath_sysctlattach(sc);</a>
<a name="ln1373">	ath_sysctl_stats_attach(sc);</a>
<a name="ln1374">	ath_sysctl_hal_attach(sc);</a>
<a name="ln1375"> </a>
<a name="ln1376">	if (bootverbose)</a>
<a name="ln1377">		ieee80211_announce(ic);</a>
<a name="ln1378">	ath_announce(sc);</a>
<a name="ln1379"> </a>
<a name="ln1380">	/*</a>
<a name="ln1381">	 * Put it to sleep for now.</a>
<a name="ln1382">	 */</a>
<a name="ln1383">	ATH_LOCK(sc);</a>
<a name="ln1384">	ath_power_setpower(sc, HAL_PM_FULL_SLEEP, 1);</a>
<a name="ln1385">	ATH_UNLOCK(sc);</a>
<a name="ln1386"> </a>
<a name="ln1387">	return 0;</a>
<a name="ln1388">bad2:</a>
<a name="ln1389">	ath_tx_cleanup(sc);</a>
<a name="ln1390">	ath_desc_free(sc);</a>
<a name="ln1391">	ath_txdma_teardown(sc);</a>
<a name="ln1392">	ath_rxdma_teardown(sc);</a>
<a name="ln1393"> </a>
<a name="ln1394">bad:</a>
<a name="ln1395">	if (ah)</a>
<a name="ln1396">		ath_hal_detach(ah);</a>
<a name="ln1397">	sc-&gt;sc_invalid = 1;</a>
<a name="ln1398">	return error;</a>
<a name="ln1399">}</a>
<a name="ln1400"> </a>
<a name="ln1401">int</a>
<a name="ln1402">ath_detach(struct ath_softc *sc)</a>
<a name="ln1403">{</a>
<a name="ln1404"> </a>
<a name="ln1405">	/*</a>
<a name="ln1406">	 * NB: the order of these is important:</a>
<a name="ln1407">	 * o stop the chip so no more interrupts will fire</a>
<a name="ln1408">	 * o call the 802.11 layer before detaching the hal to</a>
<a name="ln1409">	 *   insure callbacks into the driver to delete global</a>
<a name="ln1410">	 *   key cache entries can be handled</a>
<a name="ln1411">	 * o free the taskqueue which drains any pending tasks</a>
<a name="ln1412">	 * o reclaim the tx queue data structures after calling</a>
<a name="ln1413">	 *   the 802.11 layer as we'll get called back to reclaim</a>
<a name="ln1414">	 *   node state and potentially want to use them</a>
<a name="ln1415">	 * o to cleanup the tx queues the hal is called, so detach</a>
<a name="ln1416">	 *   it last</a>
<a name="ln1417">	 * Other than that, it's straightforward...</a>
<a name="ln1418">	 */</a>
<a name="ln1419"> </a>
<a name="ln1420">	/*</a>
<a name="ln1421">	 * XXX Wake the hardware up first.  ath_stop() will still</a>
<a name="ln1422">	 * wake it up first, but I'd rather do it here just to</a>
<a name="ln1423">	 * ensure it's awake.</a>
<a name="ln1424">	 */</a>
<a name="ln1425">	ATH_LOCK(sc);</a>
<a name="ln1426">	ath_power_set_power_state(sc, HAL_PM_AWAKE);</a>
<a name="ln1427">	ath_power_setpower(sc, HAL_PM_AWAKE, 1);</a>
<a name="ln1428"> </a>
<a name="ln1429">	/*</a>
<a name="ln1430">	 * Stop things cleanly.</a>
<a name="ln1431">	 */</a>
<a name="ln1432">	ath_stop(sc);</a>
<a name="ln1433">	ATH_UNLOCK(sc);</a>
<a name="ln1434"> </a>
<a name="ln1435">	ieee80211_ifdetach(&amp;sc-&gt;sc_ic);</a>
<a name="ln1436">	taskqueue_free(sc-&gt;sc_tq);</a>
<a name="ln1437">#ifdef ATH_TX99_DIAG</a>
<a name="ln1438">	if (sc-&gt;sc_tx99 != NULL)</a>
<a name="ln1439">		sc-&gt;sc_tx99-&gt;detach(sc-&gt;sc_tx99);</a>
<a name="ln1440">#endif</a>
<a name="ln1441">	ath_rate_detach(sc-&gt;sc_rc);</a>
<a name="ln1442">#ifdef	ATH_DEBUG_ALQ</a>
<a name="ln1443">	if_ath_alq_tidyup(&amp;sc-&gt;sc_alq);</a>
<a name="ln1444">#endif</a>
<a name="ln1445">	ath_lna_div_detach(sc);</a>
<a name="ln1446">	ath_btcoex_detach(sc);</a>
<a name="ln1447">	ath_spectral_detach(sc);</a>
<a name="ln1448">	ath_dfs_detach(sc);</a>
<a name="ln1449">	ath_desc_free(sc);</a>
<a name="ln1450">	ath_txdma_teardown(sc);</a>
<a name="ln1451">	ath_rxdma_teardown(sc);</a>
<a name="ln1452">	ath_tx_cleanup(sc);</a>
<a name="ln1453">	ath_hal_detach(sc-&gt;sc_ah);	/* NB: sets chip in full sleep */</a>
<a name="ln1454"> </a>
<a name="ln1455">	return 0;</a>
<a name="ln1456">}</a>
<a name="ln1457"> </a>
<a name="ln1458">/*</a>
<a name="ln1459"> * MAC address handling for multiple BSS on the same radio.</a>
<a name="ln1460"> * The first vap uses the MAC address from the EEPROM.  For</a>
<a name="ln1461"> * subsequent vap's we set the U/L bit (bit 1) in the MAC</a>
<a name="ln1462"> * address and use the next six bits as an index.</a>
<a name="ln1463"> */</a>
<a name="ln1464">static void</a>
<a name="ln1465">assign_address(struct ath_softc *sc, uint8_t mac[IEEE80211_ADDR_LEN], int clone)</a>
<a name="ln1466">{</a>
<a name="ln1467">	int i;</a>
<a name="ln1468"> </a>
<a name="ln1469">	if (clone &amp;&amp; sc-&gt;sc_hasbmask) {</a>
<a name="ln1470">		/* NB: we only do this if h/w supports multiple bssid */</a>
<a name="ln1471">		for (i = 0; i &lt; 8; i++)</a>
<a name="ln1472">			if ((sc-&gt;sc_bssidmask &amp; (1&lt;&lt;i)) == 0)</a>
<a name="ln1473">				break;</a>
<a name="ln1474">		if (i != 0)</a>
<a name="ln1475">			mac[0] |= (i &lt;&lt; 2)|0x2;</a>
<a name="ln1476">	} else</a>
<a name="ln1477">		i = 0;</a>
<a name="ln1478">	sc-&gt;sc_bssidmask |= 1&lt;&lt;i;</a>
<a name="ln1479">	sc-&gt;sc_hwbssidmask[0] &amp;= ~mac[0];</a>
<a name="ln1480">	if (i == 0)</a>
<a name="ln1481">		sc-&gt;sc_nbssid0++;</a>
<a name="ln1482">}</a>
<a name="ln1483"> </a>
<a name="ln1484">static void</a>
<a name="ln1485">reclaim_address(struct ath_softc *sc, const uint8_t mac[IEEE80211_ADDR_LEN])</a>
<a name="ln1486">{</a>
<a name="ln1487">	int i = mac[0] &gt;&gt; 2;</a>
<a name="ln1488">	uint8_t mask;</a>
<a name="ln1489"> </a>
<a name="ln1490">	if (i != 0 || --sc-&gt;sc_nbssid0 == 0) {</a>
<a name="ln1491">		sc-&gt;sc_bssidmask &amp;= ~(1&lt;&lt;i);</a>
<a name="ln1492">		/* recalculate bssid mask from remaining addresses */</a>
<a name="ln1493">		mask = 0xff;</a>
<a name="ln1494">		for (i = 1; i &lt; 8; i++)</a>
<a name="ln1495">			if (sc-&gt;sc_bssidmask &amp; (1&lt;&lt;i))</a>
<a name="ln1496">				mask &amp;= ~((i&lt;&lt;2)|0x2);</a>
<a name="ln1497">		sc-&gt;sc_hwbssidmask[0] |= mask;</a>
<a name="ln1498">	}</a>
<a name="ln1499">}</a>
<a name="ln1500"> </a>
<a name="ln1501">/*</a>
<a name="ln1502"> * Assign a beacon xmit slot.  We try to space out</a>
<a name="ln1503"> * assignments so when beacons are staggered the</a>
<a name="ln1504"> * traffic coming out of the cab q has maximal time</a>
<a name="ln1505"> * to go out before the next beacon is scheduled.</a>
<a name="ln1506"> */</a>
<a name="ln1507">static int</a>
<a name="ln1508">assign_bslot(struct ath_softc *sc)</a>
<a name="ln1509">{</a>
<a name="ln1510">	u_int slot, free;</a>
<a name="ln1511"> </a>
<a name="ln1512">	free = 0;</a>
<a name="ln1513">	for (slot = 0; slot &lt; ATH_BCBUF; slot++)</a>
<a name="ln1514">		if (sc-&gt;sc_bslot[slot] == NULL) {</a>
<a name="ln1515">			if (sc-&gt;sc_bslot[(slot+1)%ATH_BCBUF] == NULL &amp;&amp;</a>
<a name="ln1516">			    sc-&gt;sc_bslot[(slot-1)%ATH_BCBUF] == NULL)</a>
<a name="ln1517">				return slot;</a>
<a name="ln1518">			free = slot;</a>
<a name="ln1519">			/* NB: keep looking for a double slot */</a>
<a name="ln1520">		}</a>
<a name="ln1521">	return free;</a>
<a name="ln1522">}</a>
<a name="ln1523"> </a>
<a name="ln1524">static struct ieee80211vap *</a>
<a name="ln1525">ath_vap_create(struct ieee80211com *ic, const char name[IFNAMSIZ], int unit,</a>
<a name="ln1526">    enum ieee80211_opmode opmode, int flags,</a>
<a name="ln1527">    const uint8_t bssid[IEEE80211_ADDR_LEN],</a>
<a name="ln1528">    const uint8_t mac0[IEEE80211_ADDR_LEN])</a>
<a name="ln1529">{</a>
<a name="ln1530">	struct ath_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1531">	struct ath_vap *avp;</a>
<a name="ln1532">	struct ieee80211vap *vap;</a>
<a name="ln1533">	uint8_t mac[IEEE80211_ADDR_LEN];</a>
<a name="ln1534">	int needbeacon, error;</a>
<a name="ln1535">	enum ieee80211_opmode ic_opmode;</a>
<a name="ln1536"> </a>
<a name="ln1537">	avp = malloc(sizeof(struct ath_vap), M_80211_VAP, M_WAITOK | M_ZERO);</a>
<a name="ln1538">	needbeacon = 0;</a>
<a name="ln1539">	IEEE80211_ADDR_COPY(mac, mac0);</a>
<a name="ln1540"> </a>
<a name="ln1541">	ATH_LOCK(sc);</a>
<a name="ln1542">	ic_opmode = opmode;		/* default to opmode of new vap */</a>
<a name="ln1543">	switch (opmode) {</a>
<a name="ln1544">	case IEEE80211_M_STA:</a>
<a name="ln1545">		if (sc-&gt;sc_nstavaps != 0) {	/* XXX only 1 for now */</a>
<a name="ln1546">			device_printf(sc-&gt;sc_dev, &quot;only 1 sta vap supported\n&quot;);</a>
<a name="ln1547">			goto bad;</a>
<a name="ln1548">		}</a>
<a name="ln1549">		if (sc-&gt;sc_nvaps) {</a>
<a name="ln1550">			/*</a>
<a name="ln1551">			 * With multiple vaps we must fall back</a>
<a name="ln1552">			 * to s/w beacon miss handling.</a>
<a name="ln1553">			 */</a>
<a name="ln1554">			flags |= IEEE80211_CLONE_NOBEACONS;</a>
<a name="ln1555">		}</a>
<a name="ln1556">		if (flags &amp; IEEE80211_CLONE_NOBEACONS) {</a>
<a name="ln1557">			/*</a>
<a name="ln1558">			 * Station mode w/o beacons are implemented w/ AP mode.</a>
<a name="ln1559">			 */</a>
<a name="ln1560">			ic_opmode = IEEE80211_M_HOSTAP;</a>
<a name="ln1561">		}</a>
<a name="ln1562">		break;</a>
<a name="ln1563">	case IEEE80211_M_IBSS:</a>
<a name="ln1564">		if (sc-&gt;sc_nvaps != 0) {	/* XXX only 1 for now */</a>
<a name="ln1565">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1566">			    &quot;only 1 ibss vap supported\n&quot;);</a>
<a name="ln1567">			goto bad;</a>
<a name="ln1568">		}</a>
<a name="ln1569">		needbeacon = 1;</a>
<a name="ln1570">		break;</a>
<a name="ln1571">	case IEEE80211_M_AHDEMO:</a>
<a name="ln1572">#ifdef IEEE80211_SUPPORT_TDMA</a>
<a name="ln1573">		if (flags &amp; IEEE80211_CLONE_TDMA) {</a>
<a name="ln1574">			if (sc-&gt;sc_nvaps != 0) {</a>
<a name="ln1575">				device_printf(sc-&gt;sc_dev,</a>
<a name="ln1576">				    &quot;only 1 tdma vap supported\n&quot;);</a>
<a name="ln1577">				goto bad;</a>
<a name="ln1578">			}</a>
<a name="ln1579">			needbeacon = 1;</a>
<a name="ln1580">			flags |= IEEE80211_CLONE_NOBEACONS;</a>
<a name="ln1581">		}</a>
<a name="ln1582">		/* fall thru... */</a>
<a name="ln1583">#endif</a>
<a name="ln1584">	case IEEE80211_M_MONITOR:</a>
<a name="ln1585">		if (sc-&gt;sc_nvaps != 0 &amp;&amp; ic-&gt;ic_opmode != opmode) {</a>
<a name="ln1586">			/*</a>
<a name="ln1587">			 * Adopt existing mode.  Adding a monitor or ahdemo</a>
<a name="ln1588">			 * vap to an existing configuration is of dubious</a>
<a name="ln1589">			 * value but should be ok.</a>
<a name="ln1590">			 */</a>
<a name="ln1591">			/* XXX not right for monitor mode */</a>
<a name="ln1592">			ic_opmode = ic-&gt;ic_opmode;</a>
<a name="ln1593">		}</a>
<a name="ln1594">		break;</a>
<a name="ln1595">	case IEEE80211_M_HOSTAP:</a>
<a name="ln1596">	case IEEE80211_M_MBSS:</a>
<a name="ln1597">		needbeacon = 1;</a>
<a name="ln1598">		break;</a>
<a name="ln1599">	case IEEE80211_M_WDS:</a>
<a name="ln1600">		if (sc-&gt;sc_nvaps != 0 &amp;&amp; ic-&gt;ic_opmode == IEEE80211_M_STA) {</a>
<a name="ln1601">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1602">			    &quot;wds not supported in sta mode\n&quot;);</a>
<a name="ln1603">			goto bad;</a>
<a name="ln1604">		}</a>
<a name="ln1605">		/*</a>
<a name="ln1606">		 * Silently remove any request for a unique</a>
<a name="ln1607">		 * bssid; WDS vap's always share the local</a>
<a name="ln1608">		 * mac address.</a>
<a name="ln1609">		 */</a>
<a name="ln1610">		flags &amp;= ~IEEE80211_CLONE_BSSID;</a>
<a name="ln1611">		if (sc-&gt;sc_nvaps == 0)</a>
<a name="ln1612">			ic_opmode = IEEE80211_M_HOSTAP;</a>
<a name="ln1613">		else</a>
<a name="ln1614">			ic_opmode = ic-&gt;ic_opmode;</a>
<a name="ln1615">		break;</a>
<a name="ln1616">	default:</a>
<a name="ln1617">		device_printf(sc-&gt;sc_dev, &quot;unknown opmode %d\n&quot;, opmode);</a>
<a name="ln1618">		goto bad;</a>
<a name="ln1619">	}</a>
<a name="ln1620">	/*</a>
<a name="ln1621">	 * Check that a beacon buffer is available; the code below assumes it.</a>
<a name="ln1622">	 */</a>
<a name="ln1623">	if (needbeacon &amp; TAILQ_EMPTY(&amp;sc-&gt;sc_bbuf)) {</a>
<a name="ln1624">		device_printf(sc-&gt;sc_dev, &quot;no beacon buffer available\n&quot;);</a>
<a name="ln1625">		goto bad;</a>
<a name="ln1626">	}</a>
<a name="ln1627"> </a>
<a name="ln1628">	/* STA, AHDEMO? */</a>
<a name="ln1629">	if (opmode == IEEE80211_M_HOSTAP || opmode == IEEE80211_M_MBSS || opmode == IEEE80211_M_STA) {</a>
<a name="ln1630">		assign_address(sc, mac, flags &amp; IEEE80211_CLONE_BSSID);</a>
<a name="ln1631">		ath_hal_setbssidmask(sc-&gt;sc_ah, sc-&gt;sc_hwbssidmask);</a>
<a name="ln1632">	}</a>
<a name="ln1633"> </a>
<a name="ln1634">	vap = &amp;avp-&gt;av_vap;</a>
<a name="ln1635">	/* XXX can't hold mutex across if_alloc */</a>
<a name="ln1636">	ATH_UNLOCK(sc);</a>
<a name="ln1637">	error = ieee80211_vap_setup(ic, vap, name, unit, opmode, flags, bssid);</a>
<a name="ln1638">	ATH_LOCK(sc);</a>
<a name="ln1639">	if (error != 0) {</a>
<a name="ln1640">		device_printf(sc-&gt;sc_dev, &quot;%s: error %d creating vap\n&quot;,</a>
<a name="ln1641">		    __func__, error);</a>
<a name="ln1642">		goto bad2;</a>
<a name="ln1643">	}</a>
<a name="ln1644"> </a>
<a name="ln1645">	/* h/w crypto support */</a>
<a name="ln1646">	vap-&gt;iv_key_alloc = ath_key_alloc;</a>
<a name="ln1647">	vap-&gt;iv_key_delete = ath_key_delete;</a>
<a name="ln1648">	vap-&gt;iv_key_set = ath_key_set;</a>
<a name="ln1649">	vap-&gt;iv_key_update_begin = ath_key_update_begin;</a>
<a name="ln1650">	vap-&gt;iv_key_update_end = ath_key_update_end;</a>
<a name="ln1651"> </a>
<a name="ln1652">	/* override various methods */</a>
<a name="ln1653">	avp-&gt;av_recv_mgmt = vap-&gt;iv_recv_mgmt;</a>
<a name="ln1654">	vap-&gt;iv_recv_mgmt = ath_recv_mgmt;</a>
<a name="ln1655">	vap-&gt;iv_reset = ath_reset_vap;</a>
<a name="ln1656">	vap-&gt;iv_update_beacon = ath_beacon_update;</a>
<a name="ln1657">	avp-&gt;av_newstate = vap-&gt;iv_newstate;</a>
<a name="ln1658">	vap-&gt;iv_newstate = ath_newstate;</a>
<a name="ln1659">	avp-&gt;av_bmiss = vap-&gt;iv_bmiss;</a>
<a name="ln1660">	vap-&gt;iv_bmiss = ath_bmiss_vap;</a>
<a name="ln1661"> </a>
<a name="ln1662">	avp-&gt;av_node_ps = vap-&gt;iv_node_ps;</a>
<a name="ln1663">	vap-&gt;iv_node_ps = ath_node_powersave;</a>
<a name="ln1664"> </a>
<a name="ln1665">	avp-&gt;av_set_tim = vap-&gt;iv_set_tim;</a>
<a name="ln1666">	vap-&gt;iv_set_tim = ath_node_set_tim;</a>
<a name="ln1667"> </a>
<a name="ln1668">	avp-&gt;av_recv_pspoll = vap-&gt;iv_recv_pspoll;</a>
<a name="ln1669">	vap-&gt;iv_recv_pspoll = ath_node_recv_pspoll;</a>
<a name="ln1670"> </a>
<a name="ln1671">	/* Set default parameters */</a>
<a name="ln1672"> </a>
<a name="ln1673">	/*</a>
<a name="ln1674">	 * Anything earlier than some AR9300 series MACs don't</a>
<a name="ln1675">	 * support a smaller MPDU density.</a>
<a name="ln1676">	 */</a>
<a name="ln1677">	vap-&gt;iv_ampdu_density = IEEE80211_HTCAP_MPDUDENSITY_8;</a>
<a name="ln1678">	/*</a>
<a name="ln1679">	 * All NICs can handle the maximum size, however</a>
<a name="ln1680">	 * AR5416 based MACs can only TX aggregates w/ RTS</a>
<a name="ln1681">	 * protection when the total aggregate size is &lt;= 8k.</a>
<a name="ln1682">	 * However, for now that's enforced by the TX path.</a>
<a name="ln1683">	 */</a>
<a name="ln1684">	vap-&gt;iv_ampdu_rxmax = IEEE80211_HTCAP_MAXRXAMPDU_64K;</a>
<a name="ln1685">	vap-&gt;iv_ampdu_limit = IEEE80211_HTCAP_MAXRXAMPDU_64K;</a>
<a name="ln1686"> </a>
<a name="ln1687">	avp-&gt;av_bslot = -1;</a>
<a name="ln1688">	if (needbeacon) {</a>
<a name="ln1689">		/*</a>
<a name="ln1690">		 * Allocate beacon state and setup the q for buffered</a>
<a name="ln1691">		 * multicast frames.  We know a beacon buffer is</a>
<a name="ln1692">		 * available because we checked above.</a>
<a name="ln1693">		 */</a>
<a name="ln1694">		avp-&gt;av_bcbuf = TAILQ_FIRST(&amp;sc-&gt;sc_bbuf);</a>
<a name="ln1695">		TAILQ_REMOVE(&amp;sc-&gt;sc_bbuf, avp-&gt;av_bcbuf, bf_list);</a>
<a name="ln1696">		if (opmode != IEEE80211_M_IBSS || !sc-&gt;sc_hasveol) {</a>
<a name="ln1697">			/*</a>
<a name="ln1698">			 * Assign the vap to a beacon xmit slot.  As above</a>
<a name="ln1699">			 * this cannot fail to find a free one.</a>
<a name="ln1700">			 */</a>
<a name="ln1701">			avp-&gt;av_bslot = assign_bslot(sc);</a>
<a name="ln1702">			KASSERT(sc-&gt;sc_bslot[avp-&gt;av_bslot] == NULL,</a>
<a name="ln1703">			    (&quot;beacon slot %u not empty&quot;, avp-&gt;av_bslot));</a>
<a name="ln1704">			sc-&gt;sc_bslot[avp-&gt;av_bslot] = vap;</a>
<a name="ln1705">			sc-&gt;sc_nbcnvaps++;</a>
<a name="ln1706">		}</a>
<a name="ln1707">		if (sc-&gt;sc_hastsfadd &amp;&amp; sc-&gt;sc_nbcnvaps &gt; 0) {</a>
<a name="ln1708">			/*</a>
<a name="ln1709">			 * Multple vaps are to transmit beacons and we</a>
<a name="ln1710">			 * have h/w support for TSF adjusting; enable</a>
<a name="ln1711">			 * use of staggered beacons.</a>
<a name="ln1712">			 */</a>
<a name="ln1713">			sc-&gt;sc_stagbeacons = 1;</a>
<a name="ln1714">		}</a>
<a name="ln1715">		ath_txq_init(sc, &amp;avp-&gt;av_mcastq, ATH_TXQ_SWQ);</a>
<a name="ln1716">	}</a>
<a name="ln1717"> </a>
<a name="ln1718">	ic-&gt;ic_opmode = ic_opmode;</a>
<a name="ln1719">	if (opmode != IEEE80211_M_WDS) {</a>
<a name="ln1720">		sc-&gt;sc_nvaps++;</a>
<a name="ln1721">		if (opmode == IEEE80211_M_STA)</a>
<a name="ln1722">			sc-&gt;sc_nstavaps++;</a>
<a name="ln1723">		if (opmode == IEEE80211_M_MBSS)</a>
<a name="ln1724">			sc-&gt;sc_nmeshvaps++;</a>
<a name="ln1725">	}</a>
<a name="ln1726">	switch (ic_opmode) {</a>
<a name="ln1727">	case IEEE80211_M_IBSS:</a>
<a name="ln1728">		sc-&gt;sc_opmode = HAL_M_IBSS;</a>
<a name="ln1729">		break;</a>
<a name="ln1730">	case IEEE80211_M_STA:</a>
<a name="ln1731">		sc-&gt;sc_opmode = HAL_M_STA;</a>
<a name="ln1732">		break;</a>
<a name="ln1733">	case IEEE80211_M_AHDEMO:</a>
<a name="ln1734">#ifdef IEEE80211_SUPPORT_TDMA</a>
<a name="ln1735">		if (vap-&gt;iv_caps &amp; IEEE80211_C_TDMA) {</a>
<a name="ln1736">			sc-&gt;sc_tdma = 1;</a>
<a name="ln1737">			/* NB: disable tsf adjust */</a>
<a name="ln1738">			sc-&gt;sc_stagbeacons = 0;</a>
<a name="ln1739">		}</a>
<a name="ln1740">		/*</a>
<a name="ln1741">		 * NB: adhoc demo mode is a pseudo mode; to the hal it's</a>
<a name="ln1742">		 * just ap mode.</a>
<a name="ln1743">		 */</a>
<a name="ln1744">		/* fall thru... */</a>
<a name="ln1745">#endif</a>
<a name="ln1746">	case IEEE80211_M_HOSTAP:</a>
<a name="ln1747">	case IEEE80211_M_MBSS:</a>
<a name="ln1748">		sc-&gt;sc_opmode = HAL_M_HOSTAP;</a>
<a name="ln1749">		break;</a>
<a name="ln1750">	case IEEE80211_M_MONITOR:</a>
<a name="ln1751">		sc-&gt;sc_opmode = HAL_M_MONITOR;</a>
<a name="ln1752">		break;</a>
<a name="ln1753">	default:</a>
<a name="ln1754">		/* XXX should not happen */</a>
<a name="ln1755">		break;</a>
<a name="ln1756">	}</a>
<a name="ln1757">	if (sc-&gt;sc_hastsfadd) {</a>
<a name="ln1758">		/*</a>
<a name="ln1759">		 * Configure whether or not TSF adjust should be done.</a>
<a name="ln1760">		 */</a>
<a name="ln1761">		ath_hal_settsfadjust(sc-&gt;sc_ah, sc-&gt;sc_stagbeacons);</a>
<a name="ln1762">	}</a>
<a name="ln1763">	if (flags &amp; IEEE80211_CLONE_NOBEACONS) {</a>
<a name="ln1764">		/*</a>
<a name="ln1765">		 * Enable s/w beacon miss handling.</a>
<a name="ln1766">		 */</a>
<a name="ln1767">		sc-&gt;sc_swbmiss = 1;</a>
<a name="ln1768">	}</a>
<a name="ln1769">	ATH_UNLOCK(sc);</a>
<a name="ln1770"> </a>
<a name="ln1771">	/* complete setup */</a>
<a name="ln1772">	ieee80211_vap_attach(vap, ath_media_change, ieee80211_media_status,</a>
<a name="ln1773">	    mac);</a>
<a name="ln1774">	return vap;</a>
<a name="ln1775">bad2:</a>
<a name="ln1776">	reclaim_address(sc, mac);</a>
<a name="ln1777">	ath_hal_setbssidmask(sc-&gt;sc_ah, sc-&gt;sc_hwbssidmask);</a>
<a name="ln1778">bad:</a>
<a name="ln1779">	free(avp, M_80211_VAP);</a>
<a name="ln1780">	ATH_UNLOCK(sc);</a>
<a name="ln1781">	return NULL;</a>
<a name="ln1782">}</a>
<a name="ln1783"> </a>
<a name="ln1784">static void</a>
<a name="ln1785">ath_vap_delete(struct ieee80211vap *vap)</a>
<a name="ln1786">{</a>
<a name="ln1787">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln1788">	struct ath_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1789">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln1790">	struct ath_vap *avp = ATH_VAP(vap);</a>
<a name="ln1791"> </a>
<a name="ln1792">	ATH_LOCK(sc);</a>
<a name="ln1793">	ath_power_set_power_state(sc, HAL_PM_AWAKE);</a>
<a name="ln1794">	ATH_UNLOCK(sc);</a>
<a name="ln1795"> </a>
<a name="ln1796">	DPRINTF(sc, ATH_DEBUG_RESET, &quot;%s: called\n&quot;, __func__);</a>
<a name="ln1797">	if (sc-&gt;sc_running) {</a>
<a name="ln1798">		/*</a>
<a name="ln1799">		 * Quiesce the hardware while we remove the vap.  In</a>
<a name="ln1800">		 * particular we need to reclaim all references to</a>
<a name="ln1801">		 * the vap state by any frames pending on the tx queues.</a>
<a name="ln1802">		 */</a>
<a name="ln1803">		ath_hal_intrset(ah, 0);		/* disable interrupts */</a>
<a name="ln1804">		/* XXX Do all frames from all vaps/nodes need draining here? */</a>
<a name="ln1805">		ath_stoprecv(sc, 1);		/* stop recv side */</a>
<a name="ln1806">		ath_draintxq(sc, ATH_RESET_DEFAULT);		/* stop hw xmit side */</a>
<a name="ln1807">	}</a>
<a name="ln1808"> </a>
<a name="ln1809">	/* .. leave the hardware awake for now. */</a>
<a name="ln1810"> </a>
<a name="ln1811">	ieee80211_vap_detach(vap);</a>
<a name="ln1812"> </a>
<a name="ln1813">	/*</a>
<a name="ln1814">	 * XXX Danger Will Robinson! Danger!</a>
<a name="ln1815">	 *</a>
<a name="ln1816">	 * Because ieee80211_vap_detach() can queue a frame (the station</a>
<a name="ln1817">	 * diassociate message?) after we've drained the TXQ and</a>
<a name="ln1818">	 * flushed the software TXQ, we will end up with a frame queued</a>
<a name="ln1819">	 * to a node whose vap is about to be freed.</a>
<a name="ln1820">	 *</a>
<a name="ln1821">	 * To work around this, flush the hardware/software again.</a>
<a name="ln1822">	 * This may be racy - the ath task may be running and the packet</a>
<a name="ln1823">	 * may be being scheduled between sw-&gt;hw txq. Tsk.</a>
<a name="ln1824">	 *</a>
<a name="ln1825">	 * TODO: figure out why a new node gets allocated somewhere around</a>
<a name="ln1826">	 * here (after the ath_tx_swq() call; and after an ath_stop()</a>
<a name="ln1827">	 * call!)</a>
<a name="ln1828">	 */</a>
<a name="ln1829"> </a>
<a name="ln1830">	ath_draintxq(sc, ATH_RESET_DEFAULT);</a>
<a name="ln1831"> </a>
<a name="ln1832">	ATH_LOCK(sc);</a>
<a name="ln1833">	/*</a>
<a name="ln1834">	 * Reclaim beacon state.  Note this must be done before</a>
<a name="ln1835">	 * the vap instance is reclaimed as we may have a reference</a>
<a name="ln1836">	 * to it in the buffer for the beacon frame.</a>
<a name="ln1837">	 */</a>
<a name="ln1838">	if (avp-&gt;av_bcbuf != NULL) {</a>
<a name="ln1839">		if (avp-&gt;av_bslot != -1) {</a>
<a name="ln1840">			sc-&gt;sc_bslot[avp-&gt;av_bslot] = NULL;</a>
<a name="ln1841">			sc-&gt;sc_nbcnvaps--;</a>
<a name="ln1842">		}</a>
<a name="ln1843">		ath_beacon_return(sc, avp-&gt;av_bcbuf);</a>
<a name="ln1844">		avp-&gt;av_bcbuf = NULL;</a>
<a name="ln1845">		if (sc-&gt;sc_nbcnvaps == 0) {</a>
<a name="ln1846">			sc-&gt;sc_stagbeacons = 0;</a>
<a name="ln1847">			if (sc-&gt;sc_hastsfadd)</a>
<a name="ln1848">				ath_hal_settsfadjust(sc-&gt;sc_ah, 0);</a>
<a name="ln1849">		}</a>
<a name="ln1850">		/*</a>
<a name="ln1851">		 * Reclaim any pending mcast frames for the vap.</a>
<a name="ln1852">		 */</a>
<a name="ln1853">		ath_tx_draintxq(sc, &amp;avp-&gt;av_mcastq);</a>
<a name="ln1854">	}</a>
<a name="ln1855">	/*</a>
<a name="ln1856">	 * Update bookkeeping.</a>
<a name="ln1857">	 */</a>
<a name="ln1858">	if (vap-&gt;iv_opmode == IEEE80211_M_STA) {</a>
<a name="ln1859">		sc-&gt;sc_nstavaps--;</a>
<a name="ln1860">		if (sc-&gt;sc_nstavaps == 0 &amp;&amp; sc-&gt;sc_swbmiss)</a>
<a name="ln1861">			sc-&gt;sc_swbmiss = 0;</a>
<a name="ln1862">	} else if (vap-&gt;iv_opmode == IEEE80211_M_HOSTAP ||</a>
<a name="ln1863">	    vap-&gt;iv_opmode == IEEE80211_M_STA ||</a>
<a name="ln1864">	    vap-&gt;iv_opmode == IEEE80211_M_MBSS) {</a>
<a name="ln1865">		reclaim_address(sc, vap-&gt;iv_myaddr);</a>
<a name="ln1866">		ath_hal_setbssidmask(ah, sc-&gt;sc_hwbssidmask);</a>
<a name="ln1867">		if (vap-&gt;iv_opmode == IEEE80211_M_MBSS)</a>
<a name="ln1868">			sc-&gt;sc_nmeshvaps--;</a>
<a name="ln1869">	}</a>
<a name="ln1870">	if (vap-&gt;iv_opmode != IEEE80211_M_WDS)</a>
<a name="ln1871">		sc-&gt;sc_nvaps--;</a>
<a name="ln1872">#ifdef IEEE80211_SUPPORT_TDMA</a>
<a name="ln1873">	/* TDMA operation ceases when the last vap is destroyed */</a>
<a name="ln1874">	if (sc-&gt;sc_tdma &amp;&amp; sc-&gt;sc_nvaps == 0) {</a>
<a name="ln1875">		sc-&gt;sc_tdma = 0;</a>
<a name="ln1876">		sc-&gt;sc_swbmiss = 0;</a>
<a name="ln1877">	}</a>
<a name="ln1878">#endif</a>
<a name="ln1879">	free(avp, M_80211_VAP);</a>
<a name="ln1880"> </a>
<a name="ln1881">	if (sc-&gt;sc_running) {</a>
<a name="ln1882">		/*</a>
<a name="ln1883">		 * Restart rx+tx machines if still running (RUNNING will</a>
<a name="ln1884">		 * be reset if we just destroyed the last vap).</a>
<a name="ln1885">		 */</a>
<a name="ln1886">		if (ath_startrecv(sc) != 0)</a>
<a name="ln1887">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln1888">			    &quot;%s: unable to restart recv logic\n&quot;, __func__);</a>
<a name="ln1889">		if (sc-&gt;sc_beacons) {		/* restart beacons */</a>
<a name="ln1890">#ifdef IEEE80211_SUPPORT_TDMA</a>
<a name="ln1891">			if (sc-&gt;sc_tdma)</a>
<a name="ln1892">				ath_tdma_config(sc, NULL);</a>
<a name="ln1893">			else</a>
<a name="ln1894">#endif</a>
<a name="ln1895">				ath_beacon_config(sc, NULL);</a>
<a name="ln1896">		}</a>
<a name="ln1897">		ath_hal_intrset(ah, sc-&gt;sc_imask);</a>
<a name="ln1898">	}</a>
<a name="ln1899"> </a>
<a name="ln1900">	/* Ok, let the hardware asleep. */</a>
<a name="ln1901">	ath_power_restore_power_state(sc);</a>
<a name="ln1902">	ATH_UNLOCK(sc);</a>
<a name="ln1903">}</a>
<a name="ln1904"> </a>
<a name="ln1905">void</a>
<a name="ln1906">ath_suspend(struct ath_softc *sc)</a>
<a name="ln1907">{</a>
<a name="ln1908">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1909"> </a>
<a name="ln1910">	sc-&gt;sc_resume_up = ic-&gt;ic_nrunning != 0;</a>
<a name="ln1911"> </a>
<a name="ln1912">	ieee80211_suspend_all(ic);</a>
<a name="ln1913">	/*</a>
<a name="ln1914">	 * NB: don't worry about putting the chip in low power</a>
<a name="ln1915">	 * mode; pci will power off our socket on suspend and</a>
<a name="ln1916">	 * CardBus detaches the device.</a>
<a name="ln1917">	 *</a>
<a name="ln1918">	 * XXX TODO: well, that's great, except for non-cardbus</a>
<a name="ln1919">	 * devices!</a>
<a name="ln1920">	 */</a>
<a name="ln1921"> </a>
<a name="ln1922">	/*</a>
<a name="ln1923">	 * XXX This doesn't wait until all pending taskqueue</a>
<a name="ln1924">	 * items and parallel transmit/receive/other threads</a>
<a name="ln1925">	 * are running!</a>
<a name="ln1926">	 */</a>
<a name="ln1927">	ath_hal_intrset(sc-&gt;sc_ah, 0);</a>
<a name="ln1928">	taskqueue_block(sc-&gt;sc_tq);</a>
<a name="ln1929"> </a>
<a name="ln1930">	ATH_LOCK(sc);</a>
<a name="ln1931">	callout_stop(&amp;sc-&gt;sc_cal_ch);</a>
<a name="ln1932">	ATH_UNLOCK(sc);</a>
<a name="ln1933"> </a>
<a name="ln1934">	/*</a>
<a name="ln1935">	 * XXX ensure sc_invalid is 1</a>
<a name="ln1936">	 */</a>
<a name="ln1937"> </a>
<a name="ln1938">	/* Disable the PCIe PHY, complete with workarounds */</a>
<a name="ln1939">	ath_hal_enablepcie(sc-&gt;sc_ah, 1, 1);</a>
<a name="ln1940">}</a>
<a name="ln1941"> </a>
<a name="ln1942">/*</a>
<a name="ln1943"> * Reset the key cache since some parts do not reset the</a>
<a name="ln1944"> * contents on resume.  First we clear all entries, then</a>
<a name="ln1945"> * re-load keys that the 802.11 layer assumes are setup</a>
<a name="ln1946"> * in h/w.</a>
<a name="ln1947"> */</a>
<a name="ln1948">static void</a>
<a name="ln1949">ath_reset_keycache(struct ath_softc *sc)</a>
<a name="ln1950">{</a>
<a name="ln1951">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1952">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln1953">	int i;</a>
<a name="ln1954"> </a>
<a name="ln1955">	ATH_LOCK(sc);</a>
<a name="ln1956">	ath_power_set_power_state(sc, HAL_PM_AWAKE);</a>
<a name="ln1957">	for (i = 0; i &lt; sc-&gt;sc_keymax; i++)</a>
<a name="ln1958">		ath_hal_keyreset(ah, i);</a>
<a name="ln1959">	ath_power_restore_power_state(sc);</a>
<a name="ln1960">	ATH_UNLOCK(sc);</a>
<a name="ln1961">	ieee80211_crypto_reload_keys(ic);</a>
<a name="ln1962">}</a>
<a name="ln1963"> </a>
<a name="ln1964">/*</a>
<a name="ln1965"> * Fetch the current chainmask configuration based on the current</a>
<a name="ln1966"> * operating channel and options.</a>
<a name="ln1967"> */</a>
<a name="ln1968">static void</a>
<a name="ln1969">ath_update_chainmasks(struct ath_softc *sc, struct ieee80211_channel *chan)</a>
<a name="ln1970">{</a>
<a name="ln1971"> </a>
<a name="ln1972">	/*</a>
<a name="ln1973">	 * Set TX chainmask to the currently configured chainmask;</a>
<a name="ln1974">	 * the TX chainmask depends upon the current operating mode.</a>
<a name="ln1975">	 */</a>
<a name="ln1976">	sc-&gt;sc_cur_rxchainmask = sc-&gt;sc_rxchainmask;</a>
<a name="ln1977">	if (IEEE80211_IS_CHAN_HT(chan)) {</a>
<a name="ln1978">		sc-&gt;sc_cur_txchainmask = sc-&gt;sc_txchainmask;</a>
<a name="ln1979">	} else {</a>
<a name="ln1980">		sc-&gt;sc_cur_txchainmask = 1;</a>
<a name="ln1981">	}</a>
<a name="ln1982"> </a>
<a name="ln1983">	DPRINTF(sc, ATH_DEBUG_RESET,</a>
<a name="ln1984">	    &quot;%s: TX chainmask is now 0x%x, RX is now 0x%x\n&quot;,</a>
<a name="ln1985">	    __func__,</a>
<a name="ln1986">	    sc-&gt;sc_cur_txchainmask,</a>
<a name="ln1987">	    sc-&gt;sc_cur_rxchainmask);</a>
<a name="ln1988">}</a>
<a name="ln1989"> </a>
<a name="ln1990">void</a>
<a name="ln1991">ath_resume(struct ath_softc *sc)</a>
<a name="ln1992">{</a>
<a name="ln1993">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1994">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln1995">	HAL_STATUS status;</a>
<a name="ln1996"> </a>
<a name="ln1997">	ath_hal_enablepcie(ah, 0, 0);</a>
<a name="ln1998"> </a>
<a name="ln1999">	/*</a>
<a name="ln2000">	 * Must reset the chip before we reload the</a>
<a name="ln2001">	 * keycache as we were powered down on suspend.</a>
<a name="ln2002">	 */</a>
<a name="ln2003">	ath_update_chainmasks(sc,</a>
<a name="ln2004">	    sc-&gt;sc_curchan != NULL ? sc-&gt;sc_curchan : ic-&gt;ic_curchan);</a>
<a name="ln2005">	ath_hal_setchainmasks(sc-&gt;sc_ah, sc-&gt;sc_cur_txchainmask,</a>
<a name="ln2006">	    sc-&gt;sc_cur_rxchainmask);</a>
<a name="ln2007"> </a>
<a name="ln2008">	/* Ensure we set the current power state to on */</a>
<a name="ln2009">	ATH_LOCK(sc);</a>
<a name="ln2010">	ath_power_setselfgen(sc, HAL_PM_AWAKE);</a>
<a name="ln2011">	ath_power_set_power_state(sc, HAL_PM_AWAKE);</a>
<a name="ln2012">	ath_power_setpower(sc, HAL_PM_AWAKE, 1);</a>
<a name="ln2013">	ATH_UNLOCK(sc);</a>
<a name="ln2014"> </a>
<a name="ln2015">	ath_hal_reset(ah, sc-&gt;sc_opmode,</a>
<a name="ln2016">	    sc-&gt;sc_curchan != NULL ? sc-&gt;sc_curchan : ic-&gt;ic_curchan,</a>
<a name="ln2017">	    AH_FALSE, HAL_RESET_NORMAL, &amp;status);</a>
<a name="ln2018">	ath_reset_keycache(sc);</a>
<a name="ln2019"> </a>
<a name="ln2020">	ATH_RX_LOCK(sc);</a>
<a name="ln2021">	sc-&gt;sc_rx_stopped = 1;</a>
<a name="ln2022">	sc-&gt;sc_rx_resetted = 1;</a>
<a name="ln2023">	ATH_RX_UNLOCK(sc);</a>
<a name="ln2024"> </a>
<a name="ln2025">	/* Let DFS at it in case it's a DFS channel */</a>
<a name="ln2026">	ath_dfs_radar_enable(sc, ic-&gt;ic_curchan);</a>
<a name="ln2027"> </a>
<a name="ln2028">	/* Let spectral at in case spectral is enabled */</a>
<a name="ln2029">	ath_spectral_enable(sc, ic-&gt;ic_curchan);</a>
<a name="ln2030"> </a>
<a name="ln2031">	/*</a>
<a name="ln2032">	 * Let bluetooth coexistence at in case it's needed for this channel</a>
<a name="ln2033">	 */</a>
<a name="ln2034">	ath_btcoex_enable(sc, ic-&gt;ic_curchan);</a>
<a name="ln2035"> </a>
<a name="ln2036">	/*</a>
<a name="ln2037">	 * If we're doing TDMA, enforce the TXOP limitation for chips that</a>
<a name="ln2038">	 * support it.</a>
<a name="ln2039">	 */</a>
<a name="ln2040">	if (sc-&gt;sc_hasenforcetxop &amp;&amp; sc-&gt;sc_tdma)</a>
<a name="ln2041">		ath_hal_setenforcetxop(sc-&gt;sc_ah, 1);</a>
<a name="ln2042">	else</a>
<a name="ln2043">		ath_hal_setenforcetxop(sc-&gt;sc_ah, 0);</a>
<a name="ln2044"> </a>
<a name="ln2045">	/* Restore the LED configuration */</a>
<a name="ln2046">	ath_led_config(sc);</a>
<a name="ln2047">	ath_hal_setledstate(ah, HAL_LED_INIT);</a>
<a name="ln2048"> </a>
<a name="ln2049">	if (sc-&gt;sc_resume_up)</a>
<a name="ln2050">		ieee80211_resume_all(ic);</a>
<a name="ln2051"> </a>
<a name="ln2052">	ATH_LOCK(sc);</a>
<a name="ln2053">	ath_power_restore_power_state(sc);</a>
<a name="ln2054">	ATH_UNLOCK(sc);</a>
<a name="ln2055"> </a>
<a name="ln2056">	/* XXX beacons ? */</a>
<a name="ln2057">}</a>
<a name="ln2058"> </a>
<a name="ln2059">void</a>
<a name="ln2060">ath_shutdown(struct ath_softc *sc)</a>
<a name="ln2061">{</a>
<a name="ln2062"> </a>
<a name="ln2063">	ATH_LOCK(sc);</a>
<a name="ln2064">	ath_stop(sc);</a>
<a name="ln2065">	ATH_UNLOCK(sc);</a>
<a name="ln2066">	/* NB: no point powering down chip as we're about to reboot */</a>
<a name="ln2067">}</a>
<a name="ln2068"> </a>
<a name="ln2069">/*</a>
<a name="ln2070"> * Interrupt handler.  Most of the actual processing is deferred.</a>
<a name="ln2071"> */</a>
<a name="ln2072">void</a>
<a name="ln2073">ath_intr(void *arg)</a>
<a name="ln2074">{</a>
<a name="ln2075">	struct ath_softc *sc = arg;</a>
<a name="ln2076">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln2077">	HAL_INT status = 0;</a>
<a name="ln2078">	uint32_t txqs;</a>
<a name="ln2079"> </a>
<a name="ln2080">	/*</a>
<a name="ln2081">	 * If we're inside a reset path, just print a warning and</a>
<a name="ln2082">	 * clear the ISR. The reset routine will finish it for us.</a>
<a name="ln2083">	 */</a>
<a name="ln2084">	ATH_PCU_LOCK(sc);</a>
<a name="ln2085">	if (sc-&gt;sc_inreset_cnt) {</a>
<a name="ln2086">		HAL_INT status;</a>
<a name="ln2087">		ath_hal_getisr(ah, &amp;status);	/* clear ISR */</a>
<a name="ln2088">		ath_hal_intrset(ah, 0);		/* disable further intr's */</a>
<a name="ln2089">		DPRINTF(sc, ATH_DEBUG_ANY,</a>
<a name="ln2090">		    &quot;%s: in reset, ignoring: status=0x%x\n&quot;,</a>
<a name="ln2091">		    __func__, status);</a>
<a name="ln2092">		ATH_PCU_UNLOCK(sc);</a>
<a name="ln2093">		return;</a>
<a name="ln2094">	}</a>
<a name="ln2095"> </a>
<a name="ln2096">#if !defined(__HAIKU__)</a>
<a name="ln2097">	if (sc-&gt;sc_invalid) {</a>
<a name="ln2098">		/*</a>
<a name="ln2099">		 * The hardware is not ready/present, don't touch anything.</a>
<a name="ln2100">		 * Note this can happen early on if the IRQ is shared.</a>
<a name="ln2101">		 */</a>
<a name="ln2102">		DPRINTF(sc, ATH_DEBUG_ANY, &quot;%s: invalid; ignored\n&quot;, __func__);</a>
<a name="ln2103">		ATH_PCU_UNLOCK(sc);</a>
<a name="ln2104">		return;</a>
<a name="ln2105">	}</a>
<a name="ln2106">	if (!ath_hal_intrpend(ah)) {		/* shared irq, not for us */</a>
<a name="ln2107">		ATH_PCU_UNLOCK(sc);</a>
<a name="ln2108">		return;</a>
<a name="ln2109">	}</a>
<a name="ln2110">#endif</a>
<a name="ln2111"> </a>
<a name="ln2112">	ATH_LOCK(sc);</a>
<a name="ln2113">	ath_power_set_power_state(sc, HAL_PM_AWAKE);</a>
<a name="ln2114">	ATH_UNLOCK(sc);</a>
<a name="ln2115"> </a>
<a name="ln2116">	if (sc-&gt;sc_ic.ic_nrunning == 0 &amp;&amp; sc-&gt;sc_running == 0) {</a>
<a name="ln2117">		HAL_INT status;</a>
<a name="ln2118"> </a>
<a name="ln2119">		DPRINTF(sc, ATH_DEBUG_ANY, &quot;%s: ic_nrunning %d sc_running %d\n&quot;,</a>
<a name="ln2120">		    __func__, sc-&gt;sc_ic.ic_nrunning, sc-&gt;sc_running);</a>
<a name="ln2121">		ath_hal_getisr(ah, &amp;status);	/* clear ISR */</a>
<a name="ln2122">		ath_hal_intrset(ah, 0);		/* disable further intr's */</a>
<a name="ln2123">		ATH_PCU_UNLOCK(sc);</a>
<a name="ln2124"> </a>
<a name="ln2125">		ATH_LOCK(sc);</a>
<a name="ln2126">		ath_power_restore_power_state(sc);</a>
<a name="ln2127">		ATH_UNLOCK(sc);</a>
<a name="ln2128">		return;</a>
<a name="ln2129">	}</a>
<a name="ln2130"> </a>
<a name="ln2131">	/*</a>
<a name="ln2132">	 * Figure out the reason(s) for the interrupt.  Note</a>
<a name="ln2133">	 * that the hal returns a pseudo-ISR that may include</a>
<a name="ln2134">	 * bits we haven't explicitly enabled so we mask the</a>
<a name="ln2135">	 * value to insure we only process bits we requested.</a>
<a name="ln2136">	 */</a>
<a name="ln2137">#if defined(__HAIKU__)</a>
<a name="ln2138">	status = atomic_get((int32 *)&amp;sc-&gt;sc_intr_status);</a>
<a name="ln2139">#else</a>
<a name="ln2140">	ath_hal_getisr(ah, &amp;status);		/* NB: clears ISR too */</a>
<a name="ln2141">#endif</a>
<a name="ln2142">	DPRINTF(sc, ATH_DEBUG_INTR, &quot;%s: status 0x%x\n&quot;, __func__, status);</a>
<a name="ln2143">	ATH_KTR(sc, ATH_KTR_INTERRUPTS, 1, &quot;ath_intr: mask=0x%.8x&quot;, status);</a>
<a name="ln2144">#ifdef	ATH_DEBUG_ALQ</a>
<a name="ln2145">	if_ath_alq_post_intr(&amp;sc-&gt;sc_alq, status, ah-&gt;ah_intrstate,</a>
<a name="ln2146">	    ah-&gt;ah_syncstate);</a>
<a name="ln2147">#endif	/* ATH_DEBUG_ALQ */</a>
<a name="ln2148">#ifdef	ATH_KTR_INTR_DEBUG</a>
<a name="ln2149">	ATH_KTR(sc, ATH_KTR_INTERRUPTS, 5,</a>
<a name="ln2150">	    &quot;ath_intr: ISR=0x%.8x, ISR_S0=0x%.8x, ISR_S1=0x%.8x, ISR_S2=0x%.8x, ISR_S5=0x%.8x&quot;,</a>
<a name="ln2151">	    ah-&gt;ah_intrstate[0],</a>
<a name="ln2152">	    ah-&gt;ah_intrstate[1],</a>
<a name="ln2153">	    ah-&gt;ah_intrstate[2],</a>
<a name="ln2154">	    ah-&gt;ah_intrstate[3],</a>
<a name="ln2155">	    ah-&gt;ah_intrstate[6]);</a>
<a name="ln2156">#endif</a>
<a name="ln2157"> </a>
<a name="ln2158">	/* Squirrel away SYNC interrupt debugging */</a>
<a name="ln2159">	if (ah-&gt;ah_syncstate != 0) {</a>
<a name="ln2160">		int i;</a>
<a name="ln2161">		for (i = 0; i &lt; 32; i++)</a>
<a name="ln2162">			if (ah-&gt;ah_syncstate &amp; (1 &lt;&lt; i))</a>
<a name="ln2163">				sc-&gt;sc_intr_stats.sync_intr[i]++;</a>
<a name="ln2164">	}</a>
<a name="ln2165"> </a>
<a name="ln2166">	status &amp;= sc-&gt;sc_imask;			/* discard unasked for bits */</a>
<a name="ln2167"> </a>
<a name="ln2168">	/* Short-circuit un-handled interrupts */</a>
<a name="ln2169">	if (status == 0x0) {</a>
<a name="ln2170">		ATH_PCU_UNLOCK(sc);</a>
<a name="ln2171"> </a>
<a name="ln2172">		ATH_LOCK(sc);</a>
<a name="ln2173">		ath_power_restore_power_state(sc);</a>
<a name="ln2174">		ATH_UNLOCK(sc);</a>
<a name="ln2175"> </a>
<a name="ln2176">		return;</a>
<a name="ln2177">	}</a>
<a name="ln2178"> </a>
<a name="ln2179">	/*</a>
<a name="ln2180">	 * Take a note that we're inside the interrupt handler, so</a>
<a name="ln2181">	 * the reset routines know to wait.</a>
<a name="ln2182">	 */</a>
<a name="ln2183">	sc-&gt;sc_intr_cnt++;</a>
<a name="ln2184">	ATH_PCU_UNLOCK(sc);</a>
<a name="ln2185"> </a>
<a name="ln2186">	/*</a>
<a name="ln2187">	 * Handle the interrupt. We won't run concurrent with the reset</a>
<a name="ln2188">	 * or channel change routines as they'll wait for sc_intr_cnt</a>
<a name="ln2189">	 * to be 0 before continuing.</a>
<a name="ln2190">	 */</a>
<a name="ln2191">	if (status &amp; HAL_INT_FATAL) {</a>
<a name="ln2192">		sc-&gt;sc_stats.ast_hardware++;</a>
<a name="ln2193">		ath_hal_intrset(ah, 0);		/* disable intr's until reset */</a>
<a name="ln2194">		taskqueue_enqueue(sc-&gt;sc_tq, &amp;sc-&gt;sc_fataltask);</a>
<a name="ln2195">	} else {</a>
<a name="ln2196">		if (status &amp; HAL_INT_SWBA) {</a>
<a name="ln2197">			/*</a>
<a name="ln2198">			 * Software beacon alert--time to send a beacon.</a>
<a name="ln2199">			 * Handle beacon transmission directly; deferring</a>
<a name="ln2200">			 * this is too slow to meet timing constraints</a>
<a name="ln2201">			 * under load.</a>
<a name="ln2202">			 */</a>
<a name="ln2203">#ifdef IEEE80211_SUPPORT_TDMA</a>
<a name="ln2204">			if (sc-&gt;sc_tdma) {</a>
<a name="ln2205">				if (sc-&gt;sc_tdmaswba == 0) {</a>
<a name="ln2206">					struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln2207">					struct ieee80211vap *vap =</a>
<a name="ln2208">					    TAILQ_FIRST(&amp;ic-&gt;ic_vaps);</a>
<a name="ln2209">					ath_tdma_beacon_send(sc, vap);</a>
<a name="ln2210">					sc-&gt;sc_tdmaswba =</a>
<a name="ln2211">					    vap-&gt;iv_tdma-&gt;tdma_bintval;</a>
<a name="ln2212">				} else</a>
<a name="ln2213">					sc-&gt;sc_tdmaswba--;</a>
<a name="ln2214">			} else</a>
<a name="ln2215">#endif</a>
<a name="ln2216">			{</a>
<a name="ln2217">				ath_beacon_proc(sc, 0);</a>
<a name="ln2218">#ifdef IEEE80211_SUPPORT_SUPERG</a>
<a name="ln2219">				/*</a>
<a name="ln2220">				 * Schedule the rx taskq in case there's no</a>
<a name="ln2221">				 * traffic so any frames held on the staging</a>
<a name="ln2222">				 * queue are aged and potentially flushed.</a>
<a name="ln2223">				 */</a>
<a name="ln2224">				sc-&gt;sc_rx.recv_sched(sc, 1);</a>
<a name="ln2225">#endif</a>
<a name="ln2226">			}</a>
<a name="ln2227">		}</a>
<a name="ln2228">		if (status &amp; HAL_INT_RXEOL) {</a>
<a name="ln2229">			int imask;</a>
<a name="ln2230">			ATH_KTR(sc, ATH_KTR_ERROR, 0, &quot;ath_intr: RXEOL&quot;);</a>
<a name="ln2231">			if (! sc-&gt;sc_isedma) {</a>
<a name="ln2232">				ATH_PCU_LOCK(sc);</a>
<a name="ln2233">				/*</a>
<a name="ln2234">				 * NB: the hardware should re-read the link when</a>
<a name="ln2235">				 *     RXE bit is written, but it doesn't work at</a>
<a name="ln2236">				 *     least on older hardware revs.</a>
<a name="ln2237">				 */</a>
<a name="ln2238">				sc-&gt;sc_stats.ast_rxeol++;</a>
<a name="ln2239">				/*</a>
<a name="ln2240">				 * Disable RXEOL/RXORN - prevent an interrupt</a>
<a name="ln2241">				 * storm until the PCU logic can be reset.</a>
<a name="ln2242">				 * In case the interface is reset some other</a>
<a name="ln2243">				 * way before &quot;sc_kickpcu&quot; is called, don't</a>
<a name="ln2244">				 * modify sc_imask - that way if it is reset</a>
<a name="ln2245">				 * by a call to ath_reset() somehow, the</a>
<a name="ln2246">				 * interrupt mask will be correctly reprogrammed.</a>
<a name="ln2247">				 */</a>
<a name="ln2248">				imask = sc-&gt;sc_imask;</a>
<a name="ln2249">				imask &amp;= ~(HAL_INT_RXEOL | HAL_INT_RXORN);</a>
<a name="ln2250">				ath_hal_intrset(ah, imask);</a>
<a name="ln2251">				/*</a>
<a name="ln2252">				 * Only blank sc_rxlink if we've not yet kicked</a>
<a name="ln2253">				 * the PCU.</a>
<a name="ln2254">				 *</a>
<a name="ln2255">				 * This isn't entirely correct - the correct solution</a>
<a name="ln2256">				 * would be to have a PCU lock and engage that for</a>
<a name="ln2257">				 * the duration of the PCU fiddling; which would include</a>
<a name="ln2258">				 * running the RX process. Otherwise we could end up</a>
<a name="ln2259">				 * messing up the RX descriptor chain and making the</a>
<a name="ln2260">				 * RX desc list much shorter.</a>
<a name="ln2261">				 */</a>
<a name="ln2262">				if (! sc-&gt;sc_kickpcu)</a>
<a name="ln2263">					sc-&gt;sc_rxlink = NULL;</a>
<a name="ln2264">				sc-&gt;sc_kickpcu = 1;</a>
<a name="ln2265">				ATH_PCU_UNLOCK(sc);</a>
<a name="ln2266">			}</a>
<a name="ln2267">			/*</a>
<a name="ln2268">			 * Enqueue an RX proc to handle whatever</a>
<a name="ln2269">			 * is in the RX queue.</a>
<a name="ln2270">			 * This will then kick the PCU if required.</a>
<a name="ln2271">			 */</a>
<a name="ln2272">			sc-&gt;sc_rx.recv_sched(sc, 1);</a>
<a name="ln2273">		}</a>
<a name="ln2274">		if (status &amp; HAL_INT_TXURN) {</a>
<a name="ln2275">			sc-&gt;sc_stats.ast_txurn++;</a>
<a name="ln2276">			/* bump tx trigger level */</a>
<a name="ln2277">			ath_hal_updatetxtriglevel(ah, AH_TRUE);</a>
<a name="ln2278">		}</a>
<a name="ln2279">		/*</a>
<a name="ln2280">		 * Handle both the legacy and RX EDMA interrupt bits.</a>
<a name="ln2281">		 * Note that HAL_INT_RXLP is also HAL_INT_RXDESC.</a>
<a name="ln2282">		 */</a>
<a name="ln2283">		if (status &amp; (HAL_INT_RX | HAL_INT_RXHP | HAL_INT_RXLP)) {</a>
<a name="ln2284">			sc-&gt;sc_stats.ast_rx_intr++;</a>
<a name="ln2285">			sc-&gt;sc_rx.recv_sched(sc, 1);</a>
<a name="ln2286">		}</a>
<a name="ln2287">		if (status &amp; HAL_INT_TX) {</a>
<a name="ln2288">			sc-&gt;sc_stats.ast_tx_intr++;</a>
<a name="ln2289">			/*</a>
<a name="ln2290">			 * Grab all the currently set bits in the HAL txq bitmap</a>
<a name="ln2291">			 * and blank them. This is the only place we should be</a>
<a name="ln2292">			 * doing this.</a>
<a name="ln2293">			 */</a>
<a name="ln2294">			if (! sc-&gt;sc_isedma) {</a>
<a name="ln2295">				ATH_PCU_LOCK(sc);</a>
<a name="ln2296">				txqs = 0xffffffff;</a>
<a name="ln2297">				ath_hal_gettxintrtxqs(sc-&gt;sc_ah, &amp;txqs);</a>
<a name="ln2298">				ATH_KTR(sc, ATH_KTR_INTERRUPTS, 3,</a>
<a name="ln2299">				    &quot;ath_intr: TX; txqs=0x%08x, txq_active was 0x%08x, now 0x%08x&quot;,</a>
<a name="ln2300">				    txqs,</a>
<a name="ln2301">				    sc-&gt;sc_txq_active,</a>
<a name="ln2302">				    sc-&gt;sc_txq_active | txqs);</a>
<a name="ln2303">				sc-&gt;sc_txq_active |= txqs;</a>
<a name="ln2304">				ATH_PCU_UNLOCK(sc);</a>
<a name="ln2305">			}</a>
<a name="ln2306">			taskqueue_enqueue(sc-&gt;sc_tq, &amp;sc-&gt;sc_txtask);</a>
<a name="ln2307">		}</a>
<a name="ln2308">		if (status &amp; HAL_INT_BMISS) {</a>
<a name="ln2309">			sc-&gt;sc_stats.ast_bmiss++;</a>
<a name="ln2310">			taskqueue_enqueue(sc-&gt;sc_tq, &amp;sc-&gt;sc_bmisstask);</a>
<a name="ln2311">		}</a>
<a name="ln2312">		if (status &amp; HAL_INT_GTT)</a>
<a name="ln2313">			sc-&gt;sc_stats.ast_tx_timeout++;</a>
<a name="ln2314">		if (status &amp; HAL_INT_CST)</a>
<a name="ln2315">			sc-&gt;sc_stats.ast_tx_cst++;</a>
<a name="ln2316">		if (status &amp; HAL_INT_MIB) {</a>
<a name="ln2317">			sc-&gt;sc_stats.ast_mib++;</a>
<a name="ln2318">			ATH_PCU_LOCK(sc);</a>
<a name="ln2319">			/*</a>
<a name="ln2320">			 * Disable interrupts until we service the MIB</a>
<a name="ln2321">			 * interrupt; otherwise it will continue to fire.</a>
<a name="ln2322">			 */</a>
<a name="ln2323">			ath_hal_intrset(ah, 0);</a>
<a name="ln2324">			/*</a>
<a name="ln2325">			 * Let the hal handle the event.  We assume it will</a>
<a name="ln2326">			 * clear whatever condition caused the interrupt.</a>
<a name="ln2327">			 */</a>
<a name="ln2328">			ath_hal_mibevent(ah, &amp;sc-&gt;sc_halstats);</a>
<a name="ln2329">			/*</a>
<a name="ln2330">			 * Don't reset the interrupt if we've just</a>
<a name="ln2331">			 * kicked the PCU, or we may get a nested</a>
<a name="ln2332">			 * RXEOL before the rxproc has had a chance</a>
<a name="ln2333">			 * to run.</a>
<a name="ln2334">			 */</a>
<a name="ln2335">			if (sc-&gt;sc_kickpcu == 0)</a>
<a name="ln2336">				ath_hal_intrset(ah, sc-&gt;sc_imask);</a>
<a name="ln2337">			ATH_PCU_UNLOCK(sc);</a>
<a name="ln2338">		}</a>
<a name="ln2339">		if (status &amp; HAL_INT_RXORN) {</a>
<a name="ln2340">			/* NB: hal marks HAL_INT_FATAL when RXORN is fatal */</a>
<a name="ln2341">			ATH_KTR(sc, ATH_KTR_ERROR, 0, &quot;ath_intr: RXORN&quot;);</a>
<a name="ln2342">			sc-&gt;sc_stats.ast_rxorn++;</a>
<a name="ln2343">		}</a>
<a name="ln2344">		if (status &amp; HAL_INT_TSFOOR) {</a>
<a name="ln2345">			/* out of range beacon - wake the chip up,</a>
<a name="ln2346">			 * but don't modify self-gen frame config */</a>
<a name="ln2347">			device_printf(sc-&gt;sc_dev, &quot;%s: TSFOOR\n&quot;, __func__);</a>
<a name="ln2348">			sc-&gt;sc_syncbeacon = 1;</a>
<a name="ln2349">			ATH_LOCK(sc);</a>
<a name="ln2350">			ath_power_setpower(sc, HAL_PM_AWAKE, 0);</a>
<a name="ln2351">			ATH_UNLOCK(sc);</a>
<a name="ln2352">		}</a>
<a name="ln2353">		if (status &amp; HAL_INT_MCI) {</a>
<a name="ln2354">			ath_btcoex_mci_intr(sc);</a>
<a name="ln2355">		}</a>
<a name="ln2356">	}</a>
<a name="ln2357">	ATH_PCU_LOCK(sc);</a>
<a name="ln2358">	sc-&gt;sc_intr_cnt--;</a>
<a name="ln2359">	ATH_PCU_UNLOCK(sc);</a>
<a name="ln2360"> </a>
<a name="ln2361">	ATH_LOCK(sc);</a>
<a name="ln2362">	ath_power_restore_power_state(sc);</a>
<a name="ln2363">	ATH_UNLOCK(sc);</a>
<a name="ln2364">}</a>
<a name="ln2365"> </a>
<a name="ln2366">static void</a>
<a name="ln2367">ath_fatal_proc(void *arg, int pending)</a>
<a name="ln2368">{</a>
<a name="ln2369">	struct ath_softc *sc = arg;</a>
<a name="ln2370">	u_int32_t *state;</a>
<a name="ln2371">	u_int32_t len;</a>
<a name="ln2372">	void *sp;</a>
<a name="ln2373"> </a>
<a name="ln2374">	if (sc-&gt;sc_invalid)</a>
<a name="ln2375">		return;</a>
<a name="ln2376"> </a>
<a name="ln2377">	device_printf(sc-&gt;sc_dev, &quot;hardware error; resetting\n&quot;);</a>
<a name="ln2378">	/*</a>
<a name="ln2379">	 * Fatal errors are unrecoverable.  Typically these</a>
<a name="ln2380">	 * are caused by DMA errors.  Collect h/w state from</a>
<a name="ln2381">	 * the hal so we can diagnose what's going on.</a>
<a name="ln2382">	 */</a>
<a name="ln2383">	if (ath_hal_getfatalstate(sc-&gt;sc_ah, &amp;sp, &amp;len)) {</a>
<a name="ln2384">		KASSERT(len &gt;= 6*sizeof(u_int32_t), (&quot;len %u bytes&quot;, len));</a>
<a name="ln2385">		state = sp;</a>
<a name="ln2386">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln2387">		    &quot;0x%08x 0x%08x 0x%08x, 0x%08x 0x%08x 0x%08x\n&quot;, state[0],</a>
<a name="ln2388">		    state[1] , state[2], state[3], state[4], state[5]);</a>
<a name="ln2389">	}</a>
<a name="ln2390">	ath_reset(sc, ATH_RESET_NOLOSS);</a>
<a name="ln2391">}</a>
<a name="ln2392"> </a>
<a name="ln2393">static void</a>
<a name="ln2394">ath_bmiss_vap(struct ieee80211vap *vap)</a>
<a name="ln2395">{</a>
<a name="ln2396">	struct ath_softc *sc = vap-&gt;iv_ic-&gt;ic_softc;</a>
<a name="ln2397"> </a>
<a name="ln2398">	/*</a>
<a name="ln2399">	 * Workaround phantom bmiss interrupts by sanity-checking</a>
<a name="ln2400">	 * the time of our last rx'd frame.  If it is within the</a>
<a name="ln2401">	 * beacon miss interval then ignore the interrupt.  If it's</a>
<a name="ln2402">	 * truly a bmiss we'll get another interrupt soon and that'll</a>
<a name="ln2403">	 * be dispatched up for processing.  Note this applies only</a>
<a name="ln2404">	 * for h/w beacon miss events.</a>
<a name="ln2405">	 */</a>
<a name="ln2406"> </a>
<a name="ln2407">	/*</a>
<a name="ln2408">	 * XXX TODO: Just read the TSF during the interrupt path;</a>
<a name="ln2409">	 * that way we don't have to wake up again just to read it</a>
<a name="ln2410">	 * again.</a>
<a name="ln2411">	 */</a>
<a name="ln2412">	ATH_LOCK(sc);</a>
<a name="ln2413">	ath_power_set_power_state(sc, HAL_PM_AWAKE);</a>
<a name="ln2414">	ATH_UNLOCK(sc);</a>
<a name="ln2415"> </a>
<a name="ln2416">	if ((vap-&gt;iv_flags_ext &amp; IEEE80211_FEXT_SWBMISS) == 0) {</a>
<a name="ln2417">		u_int64_t lastrx = sc-&gt;sc_lastrx;</a>
<a name="ln2418">		u_int64_t tsf = ath_hal_gettsf64(sc-&gt;sc_ah);</a>
<a name="ln2419">		/* XXX should take a locked ref to iv_bss */</a>
<a name="ln2420">		u_int bmisstimeout =</a>
<a name="ln2421">			vap-&gt;iv_bmissthreshold * vap-&gt;iv_bss-&gt;ni_intval * 1024;</a>
<a name="ln2422"> </a>
<a name="ln2423">		DPRINTF(sc, ATH_DEBUG_BEACON,</a>
<a name="ln2424">		    &quot;%s: tsf %llu lastrx %lld (%llu) bmiss %u\n&quot;,</a>
<a name="ln2425">		    __func__, (unsigned long long) tsf,</a>
<a name="ln2426">		    (unsigned long long)(tsf - lastrx),</a>
<a name="ln2427">		    (unsigned long long) lastrx, bmisstimeout);</a>
<a name="ln2428"> </a>
<a name="ln2429">		if (tsf - lastrx &lt;= bmisstimeout) {</a>
<a name="ln2430">			sc-&gt;sc_stats.ast_bmiss_phantom++;</a>
<a name="ln2431"> </a>
<a name="ln2432">			ATH_LOCK(sc);</a>
<a name="ln2433">			ath_power_restore_power_state(sc);</a>
<a name="ln2434">			ATH_UNLOCK(sc);</a>
<a name="ln2435"> </a>
<a name="ln2436">			return;</a>
<a name="ln2437">		}</a>
<a name="ln2438">	}</a>
<a name="ln2439"> </a>
<a name="ln2440">	/*</a>
<a name="ln2441">	 * Keep the hardware awake if it's asleep (and leave self-gen</a>
<a name="ln2442">	 * frame config alone) until the next beacon, so we can resync</a>
<a name="ln2443">	 * against the next beacon.</a>
<a name="ln2444">	 *</a>
<a name="ln2445">	 * This handles three common beacon miss cases in STA powersave mode -</a>
<a name="ln2446">	 * (a) the beacon TBTT isnt a multiple of bintval;</a>
<a name="ln2447">	 * (b) the beacon was missed; and</a>
<a name="ln2448">	 * (c) the beacons are being delayed because the AP is busy and</a>
<a name="ln2449">	 *     isn't reliably able to meet its TBTT.</a>
<a name="ln2450">	 */</a>
<a name="ln2451">	ATH_LOCK(sc);</a>
<a name="ln2452">	ath_power_setpower(sc, HAL_PM_AWAKE, 0);</a>
<a name="ln2453">	ath_power_restore_power_state(sc);</a>
<a name="ln2454">	ATH_UNLOCK(sc);</a>
<a name="ln2455">	DPRINTF(sc, ATH_DEBUG_BEACON,</a>
<a name="ln2456">	    &quot;%s: forced awake; force syncbeacon=1\n&quot;, __func__);</a>
<a name="ln2457"> </a>
<a name="ln2458">	/*</a>
<a name="ln2459">	 * Attempt to force a beacon resync.</a>
<a name="ln2460">	 */</a>
<a name="ln2461">	sc-&gt;sc_syncbeacon = 1;</a>
<a name="ln2462"> </a>
<a name="ln2463">	ATH_VAP(vap)-&gt;av_bmiss(vap);</a>
<a name="ln2464">}</a>
<a name="ln2465"> </a>
<a name="ln2466">/* XXX this needs a force wakeup! */</a>
<a name="ln2467">int</a>
<a name="ln2468">ath_hal_gethangstate(struct ath_hal *ah, uint32_t mask, uint32_t *hangs)</a>
<a name="ln2469">{</a>
<a name="ln2470">	uint32_t rsize;</a>
<a name="ln2471">	void *sp;</a>
<a name="ln2472"> </a>
<a name="ln2473">	if (!ath_hal_getdiagstate(ah, HAL_DIAG_CHECK_HANGS, &amp;mask, sizeof(mask), &amp;sp, &amp;rsize))</a>
<a name="ln2474">		return 0;</a>
<a name="ln2475">	KASSERT(rsize == sizeof(uint32_t), (&quot;resultsize %u&quot;, rsize));</a>
<a name="ln2476">	*hangs = *(uint32_t *)sp;</a>
<a name="ln2477">	return 1;</a>
<a name="ln2478">}</a>
<a name="ln2479"> </a>
<a name="ln2480">static void</a>
<a name="ln2481">ath_bmiss_proc(void *arg, int pending)</a>
<a name="ln2482">{</a>
<a name="ln2483">	struct ath_softc *sc = arg;</a>
<a name="ln2484">	uint32_t hangs;</a>
<a name="ln2485"> </a>
<a name="ln2486">	DPRINTF(sc, ATH_DEBUG_ANY, &quot;%s: pending %u\n&quot;, __func__, pending);</a>
<a name="ln2487"> </a>
<a name="ln2488">	ATH_LOCK(sc);</a>
<a name="ln2489">	ath_power_set_power_state(sc, HAL_PM_AWAKE);</a>
<a name="ln2490">	ATH_UNLOCK(sc);</a>
<a name="ln2491"> </a>
<a name="ln2492">	ath_beacon_miss(sc);</a>
<a name="ln2493"> </a>
<a name="ln2494">	/*</a>
<a name="ln2495">	 * Do a reset upon any becaon miss event.</a>
<a name="ln2496">	 *</a>
<a name="ln2497">	 * It may be a non-recognised RX clear hang which needs a reset</a>
<a name="ln2498">	 * to clear.</a>
<a name="ln2499">	 */</a>
<a name="ln2500">	if (ath_hal_gethangstate(sc-&gt;sc_ah, 0xff, &amp;hangs) &amp;&amp; hangs != 0) {</a>
<a name="ln2501">		ath_reset(sc, ATH_RESET_NOLOSS);</a>
<a name="ln2502">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln2503">		    &quot;bb hang detected (0x%x), resetting\n&quot;, hangs);</a>
<a name="ln2504">	} else {</a>
<a name="ln2505">		ath_reset(sc, ATH_RESET_NOLOSS);</a>
<a name="ln2506">		ieee80211_beacon_miss(&amp;sc-&gt;sc_ic);</a>
<a name="ln2507">	}</a>
<a name="ln2508"> </a>
<a name="ln2509">	/* Force a beacon resync, in case they've drifted */</a>
<a name="ln2510">	sc-&gt;sc_syncbeacon = 1;</a>
<a name="ln2511"> </a>
<a name="ln2512">	ATH_LOCK(sc);</a>
<a name="ln2513">	ath_power_restore_power_state(sc);</a>
<a name="ln2514">	ATH_UNLOCK(sc);</a>
<a name="ln2515">}</a>
<a name="ln2516"> </a>
<a name="ln2517">/*</a>
<a name="ln2518"> * Handle TKIP MIC setup to deal hardware that doesn't do MIC</a>
<a name="ln2519"> * calcs together with WME.  If necessary disable the crypto</a>
<a name="ln2520"> * hardware and mark the 802.11 state so keys will be setup</a>
<a name="ln2521"> * with the MIC work done in software.</a>
<a name="ln2522"> */</a>
<a name="ln2523">static void</a>
<a name="ln2524">ath_settkipmic(struct ath_softc *sc)</a>
<a name="ln2525">{</a>
<a name="ln2526">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln2527"> </a>
<a name="ln2528">	if ((ic-&gt;ic_cryptocaps &amp; IEEE80211_CRYPTO_TKIP) &amp;&amp; !sc-&gt;sc_wmetkipmic) {</a>
<a name="ln2529">		if (ic-&gt;ic_flags &amp; IEEE80211_F_WME) {</a>
<a name="ln2530">			ath_hal_settkipmic(sc-&gt;sc_ah, AH_FALSE);</a>
<a name="ln2531">			ic-&gt;ic_cryptocaps &amp;= ~IEEE80211_CRYPTO_TKIPMIC;</a>
<a name="ln2532">		} else {</a>
<a name="ln2533">			ath_hal_settkipmic(sc-&gt;sc_ah, AH_TRUE);</a>
<a name="ln2534">			ic-&gt;ic_cryptocaps |= IEEE80211_CRYPTO_TKIPMIC;</a>
<a name="ln2535">		}</a>
<a name="ln2536">	}</a>
<a name="ln2537">}</a>
<a name="ln2538"> </a>
<a name="ln2539">static void</a>
<a name="ln2540">ath_vap_clear_quiet_ie(struct ath_softc *sc)</a>
<a name="ln2541">{</a>
<a name="ln2542">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln2543">	struct ieee80211vap *vap;</a>
<a name="ln2544">	struct ath_vap *avp;</a>
<a name="ln2545"> </a>
<a name="ln2546">	TAILQ_FOREACH(vap, &amp;ic-&gt;ic_vaps, iv_next) {</a>
<a name="ln2547">		avp = ATH_VAP(vap);</a>
<a name="ln2548">		/* Quiet time handling - ensure we resync */</a>
<a name="ln2549">		memset(&amp;avp-&gt;quiet_ie, 0, sizeof(avp-&gt;quiet_ie));</a>
<a name="ln2550">	}</a>
<a name="ln2551">}</a>
<a name="ln2552"> </a>
<a name="ln2553">static int</a>
<a name="ln2554">ath_init(struct ath_softc *sc)</a>
<a name="ln2555">{</a>
<a name="ln2556">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln2557">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln2558">	HAL_STATUS status;</a>
<a name="ln2559"> </a>
<a name="ln2560">	ATH_LOCK_ASSERT(sc);</a>
<a name="ln2561"> </a>
<a name="ln2562">	/*</a>
<a name="ln2563">	 * Force the sleep state awake.</a>
<a name="ln2564">	 */</a>
<a name="ln2565">	ath_power_setselfgen(sc, HAL_PM_AWAKE);</a>
<a name="ln2566">	ath_power_set_power_state(sc, HAL_PM_AWAKE);</a>
<a name="ln2567">	ath_power_setpower(sc, HAL_PM_AWAKE, 1);</a>
<a name="ln2568"> </a>
<a name="ln2569">	/*</a>
<a name="ln2570">	 * Stop anything previously setup.  This is safe</a>
<a name="ln2571">	 * whether this is the first time through or not.</a>
<a name="ln2572">	 */</a>
<a name="ln2573">	ath_stop(sc);</a>
<a name="ln2574"> </a>
<a name="ln2575">	/*</a>
<a name="ln2576">	 * The basic interface to setting the hardware in a good</a>
<a name="ln2577">	 * state is ``reset''.  On return the hardware is known to</a>
<a name="ln2578">	 * be powered up and with interrupts disabled.  This must</a>
<a name="ln2579">	 * be followed by initialization of the appropriate bits</a>
<a name="ln2580">	 * and then setup of the interrupt mask.</a>
<a name="ln2581">	 */</a>
<a name="ln2582">	ath_settkipmic(sc);</a>
<a name="ln2583">	ath_update_chainmasks(sc, ic-&gt;ic_curchan);</a>
<a name="ln2584">	ath_hal_setchainmasks(sc-&gt;sc_ah, sc-&gt;sc_cur_txchainmask,</a>
<a name="ln2585">	    sc-&gt;sc_cur_rxchainmask);</a>
<a name="ln2586"> </a>
<a name="ln2587">	if (!ath_hal_reset(ah, sc-&gt;sc_opmode, ic-&gt;ic_curchan, AH_FALSE,</a>
<a name="ln2588">	    HAL_RESET_NORMAL, &amp;status)) {</a>
<a name="ln2589">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln2590">		    &quot;unable to reset hardware; hal status %u\n&quot;, status);</a>
<a name="ln2591">		return (ENODEV);</a>
<a name="ln2592">	}</a>
<a name="ln2593"> </a>
<a name="ln2594">	ATH_RX_LOCK(sc);</a>
<a name="ln2595">	sc-&gt;sc_rx_stopped = 1;</a>
<a name="ln2596">	sc-&gt;sc_rx_resetted = 1;</a>
<a name="ln2597">	ATH_RX_UNLOCK(sc);</a>
<a name="ln2598"> </a>
<a name="ln2599">	/* Clear quiet IE state for each VAP */</a>
<a name="ln2600">	ath_vap_clear_quiet_ie(sc);</a>
<a name="ln2601"> </a>
<a name="ln2602">	ath_chan_change(sc, ic-&gt;ic_curchan);</a>
<a name="ln2603"> </a>
<a name="ln2604">	/* Let DFS at it in case it's a DFS channel */</a>
<a name="ln2605">	ath_dfs_radar_enable(sc, ic-&gt;ic_curchan);</a>
<a name="ln2606"> </a>
<a name="ln2607">	/* Let spectral at in case spectral is enabled */</a>
<a name="ln2608">	ath_spectral_enable(sc, ic-&gt;ic_curchan);</a>
<a name="ln2609"> </a>
<a name="ln2610">	/*</a>
<a name="ln2611">	 * Let bluetooth coexistence at in case it's needed for this channel</a>
<a name="ln2612">	 */</a>
<a name="ln2613">	ath_btcoex_enable(sc, ic-&gt;ic_curchan);</a>
<a name="ln2614"> </a>
<a name="ln2615">	/*</a>
<a name="ln2616">	 * If we're doing TDMA, enforce the TXOP limitation for chips that</a>
<a name="ln2617">	 * support it.</a>
<a name="ln2618">	 */</a>
<a name="ln2619">	if (sc-&gt;sc_hasenforcetxop &amp;&amp; sc-&gt;sc_tdma)</a>
<a name="ln2620">		ath_hal_setenforcetxop(sc-&gt;sc_ah, 1);</a>
<a name="ln2621">	else</a>
<a name="ln2622">		ath_hal_setenforcetxop(sc-&gt;sc_ah, 0);</a>
<a name="ln2623"> </a>
<a name="ln2624">	/*</a>
<a name="ln2625">	 * Likewise this is set during reset so update</a>
<a name="ln2626">	 * state cached in the driver.</a>
<a name="ln2627">	 */</a>
<a name="ln2628">	sc-&gt;sc_diversity = ath_hal_getdiversity(ah);</a>
<a name="ln2629">	sc-&gt;sc_lastlongcal = ticks;</a>
<a name="ln2630">	sc-&gt;sc_resetcal = 1;</a>
<a name="ln2631">	sc-&gt;sc_lastcalreset = 0;</a>
<a name="ln2632">	sc-&gt;sc_lastani = ticks;</a>
<a name="ln2633">	sc-&gt;sc_lastshortcal = ticks;</a>
<a name="ln2634">	sc-&gt;sc_doresetcal = AH_FALSE;</a>
<a name="ln2635">	/*</a>
<a name="ln2636">	 * Beacon timers were cleared here; give ath_newstate()</a>
<a name="ln2637">	 * a hint that the beacon timers should be poked when</a>
<a name="ln2638">	 * things transition to the RUN state.</a>
<a name="ln2639">	 */</a>
<a name="ln2640">	sc-&gt;sc_beacons = 0;</a>
<a name="ln2641"> </a>
<a name="ln2642">	/*</a>
<a name="ln2643">	 * Setup the hardware after reset: the key cache</a>
<a name="ln2644">	 * is filled as needed and the receive engine is</a>
<a name="ln2645">	 * set going.  Frame transmit is handled entirely</a>
<a name="ln2646">	 * in the frame output path; there's nothing to do</a>
<a name="ln2647">	 * here except setup the interrupt mask.</a>
<a name="ln2648">	 */</a>
<a name="ln2649">	if (ath_startrecv(sc) != 0) {</a>
<a name="ln2650">		device_printf(sc-&gt;sc_dev, &quot;unable to start recv logic\n&quot;);</a>
<a name="ln2651">		ath_power_restore_power_state(sc);</a>
<a name="ln2652">		return (ENODEV);</a>
<a name="ln2653">	}</a>
<a name="ln2654"> </a>
<a name="ln2655">	/*</a>
<a name="ln2656">	 * Enable interrupts.</a>
<a name="ln2657">	 */</a>
<a name="ln2658">	sc-&gt;sc_imask = HAL_INT_RX | HAL_INT_TX</a>
<a name="ln2659">		  | HAL_INT_RXORN | HAL_INT_TXURN</a>
<a name="ln2660">		  | HAL_INT_FATAL | HAL_INT_GLOBAL;</a>
<a name="ln2661"> </a>
<a name="ln2662">	/*</a>
<a name="ln2663">	 * Enable RX EDMA bits.  Note these overlap with</a>
<a name="ln2664">	 * HAL_INT_RX and HAL_INT_RXDESC respectively.</a>
<a name="ln2665">	 */</a>
<a name="ln2666">	if (sc-&gt;sc_isedma)</a>
<a name="ln2667">		sc-&gt;sc_imask |= (HAL_INT_RXHP | HAL_INT_RXLP);</a>
<a name="ln2668"> </a>
<a name="ln2669">	/*</a>
<a name="ln2670">	 * If we're an EDMA NIC, we don't care about RXEOL.</a>
<a name="ln2671">	 * Writing a new descriptor in will simply restart</a>
<a name="ln2672">	 * RX DMA.</a>
<a name="ln2673">	 */</a>
<a name="ln2674">	if (! sc-&gt;sc_isedma)</a>
<a name="ln2675">		sc-&gt;sc_imask |= HAL_INT_RXEOL;</a>
<a name="ln2676"> </a>
<a name="ln2677">	/*</a>
<a name="ln2678">	 * Enable MCI interrupt for MCI devices.</a>
<a name="ln2679">	 */</a>
<a name="ln2680">	if (sc-&gt;sc_btcoex_mci)</a>
<a name="ln2681">		sc-&gt;sc_imask |= HAL_INT_MCI;</a>
<a name="ln2682"> </a>
<a name="ln2683">	/*</a>
<a name="ln2684">	 * Enable MIB interrupts when there are hardware phy counters.</a>
<a name="ln2685">	 * Note we only do this (at the moment) for station mode.</a>
<a name="ln2686">	 */</a>
<a name="ln2687">	if (sc-&gt;sc_needmib &amp;&amp; ic-&gt;ic_opmode == IEEE80211_M_STA)</a>
<a name="ln2688">		sc-&gt;sc_imask |= HAL_INT_MIB;</a>
<a name="ln2689"> </a>
<a name="ln2690">	/*</a>
<a name="ln2691">	 * XXX add capability for this.</a>
<a name="ln2692">	 *</a>
<a name="ln2693">	 * If we're in STA mode (and maybe IBSS?) then register for</a>
<a name="ln2694">	 * TSFOOR interrupts.</a>
<a name="ln2695">	 */</a>
<a name="ln2696">	if (ic-&gt;ic_opmode == IEEE80211_M_STA)</a>
<a name="ln2697">		sc-&gt;sc_imask |= HAL_INT_TSFOOR;</a>
<a name="ln2698"> </a>
<a name="ln2699">	/* Enable global TX timeout and carrier sense timeout if available */</a>
<a name="ln2700">	if (ath_hal_gtxto_supported(ah))</a>
<a name="ln2701">		sc-&gt;sc_imask |= HAL_INT_GTT;</a>
<a name="ln2702"> </a>
<a name="ln2703">	DPRINTF(sc, ATH_DEBUG_RESET, &quot;%s: imask=0x%x\n&quot;,</a>
<a name="ln2704">		__func__, sc-&gt;sc_imask);</a>
<a name="ln2705"> </a>
<a name="ln2706">	sc-&gt;sc_running = 1;</a>
<a name="ln2707">	callout_reset(&amp;sc-&gt;sc_wd_ch, hz, ath_watchdog, sc);</a>
<a name="ln2708">	ath_hal_intrset(ah, sc-&gt;sc_imask);</a>
<a name="ln2709"> </a>
<a name="ln2710">	ath_power_restore_power_state(sc);</a>
<a name="ln2711"> </a>
<a name="ln2712">	return (0);</a>
<a name="ln2713">}</a>
<a name="ln2714"> </a>
<a name="ln2715">static void</a>
<a name="ln2716">ath_stop(struct ath_softc *sc)</a>
<a name="ln2717">{</a>
<a name="ln2718">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln2719"> </a>
<a name="ln2720">	ATH_LOCK_ASSERT(sc);</a>
<a name="ln2721"> </a>
<a name="ln2722">	/*</a>
<a name="ln2723">	 * Wake the hardware up before fiddling with it.</a>
<a name="ln2724">	 */</a>
<a name="ln2725">	ath_power_set_power_state(sc, HAL_PM_AWAKE);</a>
<a name="ln2726"> </a>
<a name="ln2727">	if (sc-&gt;sc_running) {</a>
<a name="ln2728">		/*</a>
<a name="ln2729">		 * Shutdown the hardware and driver:</a>
<a name="ln2730">		 *    reset 802.11 state machine</a>
<a name="ln2731">		 *    turn off timers</a>
<a name="ln2732">		 *    disable interrupts</a>
<a name="ln2733">		 *    turn off the radio</a>
<a name="ln2734">		 *    clear transmit machinery</a>
<a name="ln2735">		 *    clear receive machinery</a>
<a name="ln2736">		 *    drain and release tx queues</a>
<a name="ln2737">		 *    reclaim beacon resources</a>
<a name="ln2738">		 *    power down hardware</a>
<a name="ln2739">		 *</a>
<a name="ln2740">		 * Note that some of this work is not possible if the</a>
<a name="ln2741">		 * hardware is gone (invalid).</a>
<a name="ln2742">		 */</a>
<a name="ln2743">#ifdef ATH_TX99_DIAG</a>
<a name="ln2744">		if (sc-&gt;sc_tx99 != NULL)</a>
<a name="ln2745">			sc-&gt;sc_tx99-&gt;stop(sc-&gt;sc_tx99);</a>
<a name="ln2746">#endif</a>
<a name="ln2747">		callout_stop(&amp;sc-&gt;sc_wd_ch);</a>
<a name="ln2748">		sc-&gt;sc_wd_timer = 0;</a>
<a name="ln2749">		sc-&gt;sc_running = 0;</a>
<a name="ln2750">		if (!sc-&gt;sc_invalid) {</a>
<a name="ln2751">			if (sc-&gt;sc_softled) {</a>
<a name="ln2752">				callout_stop(&amp;sc-&gt;sc_ledtimer);</a>
<a name="ln2753">				ath_hal_gpioset(ah, sc-&gt;sc_ledpin,</a>
<a name="ln2754">					!sc-&gt;sc_ledon);</a>
<a name="ln2755">				sc-&gt;sc_blinking = 0;</a>
<a name="ln2756">			}</a>
<a name="ln2757">			ath_hal_intrset(ah, 0);</a>
<a name="ln2758">		}</a>
<a name="ln2759">		/* XXX we should stop RX regardless of whether it's valid */</a>
<a name="ln2760">		if (!sc-&gt;sc_invalid) {</a>
<a name="ln2761">			ath_stoprecv(sc, 1);</a>
<a name="ln2762">			ath_hal_phydisable(ah);</a>
<a name="ln2763">		} else</a>
<a name="ln2764">			sc-&gt;sc_rxlink = NULL;</a>
<a name="ln2765">		ath_draintxq(sc, ATH_RESET_DEFAULT);</a>
<a name="ln2766">		ath_beacon_free(sc);	/* XXX not needed */</a>
<a name="ln2767">	}</a>
<a name="ln2768"> </a>
<a name="ln2769">	/* And now, restore the current power state */</a>
<a name="ln2770">	ath_power_restore_power_state(sc);</a>
<a name="ln2771">}</a>
<a name="ln2772"> </a>
<a name="ln2773">/*</a>
<a name="ln2774"> * Wait until all pending TX/RX has completed.</a>
<a name="ln2775"> *</a>
<a name="ln2776"> * This waits until all existing transmit, receive and interrupts</a>
<a name="ln2777"> * have completed.  It's assumed that the caller has first</a>
<a name="ln2778"> * grabbed the reset lock so it doesn't try to do overlapping</a>
<a name="ln2779"> * chip resets.</a>
<a name="ln2780"> */</a>
<a name="ln2781">#define	MAX_TXRX_ITERATIONS	100</a>
<a name="ln2782">static void</a>
<a name="ln2783">ath_txrx_stop_locked(struct ath_softc *sc)</a>
<a name="ln2784">{</a>
<a name="ln2785">	int i = MAX_TXRX_ITERATIONS;</a>
<a name="ln2786"> </a>
<a name="ln2787">	ATH_UNLOCK_ASSERT(sc);</a>
<a name="ln2788">	ATH_PCU_LOCK_ASSERT(sc);</a>
<a name="ln2789"> </a>
<a name="ln2790">	/*</a>
<a name="ln2791">	 * Sleep until all the pending operations have completed.</a>
<a name="ln2792">	 *</a>
<a name="ln2793">	 * The caller must ensure that reset has been incremented</a>
<a name="ln2794">	 * or the pending operations may continue being queued.</a>
<a name="ln2795">	 */</a>
<a name="ln2796">	while (sc-&gt;sc_rxproc_cnt || sc-&gt;sc_txproc_cnt ||</a>
<a name="ln2797">	    sc-&gt;sc_txstart_cnt || sc-&gt;sc_intr_cnt) {</a>
<a name="ln2798">		if (i &lt;= 0)</a>
<a name="ln2799">			break;</a>
<a name="ln2800">		msleep(sc, &amp;sc-&gt;sc_pcu_mtx, 0, &quot;ath_txrx_stop&quot;,</a>
<a name="ln2801">		    msecs_to_ticks(10));</a>
<a name="ln2802">		i--;</a>
<a name="ln2803">	}</a>
<a name="ln2804"> </a>
<a name="ln2805">	if (i &lt;= 0)</a>
<a name="ln2806">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln2807">		    &quot;%s: didn't finish after %d iterations\n&quot;,</a>
<a name="ln2808">		    __func__, MAX_TXRX_ITERATIONS);</a>
<a name="ln2809">}</a>
<a name="ln2810">#undef	MAX_TXRX_ITERATIONS</a>
<a name="ln2811"> </a>
<a name="ln2812">#if 0</a>
<a name="ln2813">static void</a>
<a name="ln2814">ath_txrx_stop(struct ath_softc *sc)</a>
<a name="ln2815">{</a>
<a name="ln2816">	ATH_UNLOCK_ASSERT(sc);</a>
<a name="ln2817">	ATH_PCU_UNLOCK_ASSERT(sc);</a>
<a name="ln2818"> </a>
<a name="ln2819">	ATH_PCU_LOCK(sc);</a>
<a name="ln2820">	ath_txrx_stop_locked(sc);</a>
<a name="ln2821">	ATH_PCU_UNLOCK(sc);</a>
<a name="ln2822">}</a>
<a name="ln2823">#endif</a>
<a name="ln2824"> </a>
<a name="ln2825">static void</a>
<a name="ln2826">ath_txrx_start(struct ath_softc *sc)</a>
<a name="ln2827">{</a>
<a name="ln2828"> </a>
<a name="ln2829">	taskqueue_unblock(sc-&gt;sc_tq);</a>
<a name="ln2830">}</a>
<a name="ln2831"> </a>
<a name="ln2832">/*</a>
<a name="ln2833"> * Grab the reset lock, and wait around until no one else</a>
<a name="ln2834"> * is trying to do anything with it.</a>
<a name="ln2835"> *</a>
<a name="ln2836"> * This is totally horrible but we can't hold this lock for</a>
<a name="ln2837"> * long enough to do TX/RX or we end up with net80211/ip stack</a>
<a name="ln2838"> * LORs and eventual deadlock.</a>
<a name="ln2839"> *</a>
<a name="ln2840"> * &quot;dowait&quot; signals whether to spin, waiting for the reset</a>
<a name="ln2841"> * lock count to reach 0. This should (for now) only be used</a>
<a name="ln2842"> * during the reset path, as the rest of the code may not</a>
<a name="ln2843"> * be locking-reentrant enough to behave correctly.</a>
<a name="ln2844"> *</a>
<a name="ln2845"> * Another, cleaner way should be found to serialise all of</a>
<a name="ln2846"> * these operations.</a>
<a name="ln2847"> */</a>
<a name="ln2848">#define	MAX_RESET_ITERATIONS	25</a>
<a name="ln2849">static int</a>
<a name="ln2850">ath_reset_grablock(struct ath_softc *sc, int dowait)</a>
<a name="ln2851">{</a>
<a name="ln2852">	int w = 0;</a>
<a name="ln2853">	int i = MAX_RESET_ITERATIONS;</a>
<a name="ln2854"> </a>
<a name="ln2855">	ATH_PCU_LOCK_ASSERT(sc);</a>
<a name="ln2856">	do {</a>
<a name="ln2857">		if (sc-&gt;sc_inreset_cnt == 0) {</a>
<a name="ln2858">			w = 1;</a>
<a name="ln2859">			break;</a>
<a name="ln2860">		}</a>
<a name="ln2861">		if (dowait == 0) {</a>
<a name="ln2862">			w = 0;</a>
<a name="ln2863">			break;</a>
<a name="ln2864">		}</a>
<a name="ln2865">		ATH_PCU_UNLOCK(sc);</a>
<a name="ln2866">		/*</a>
<a name="ln2867">		 * 1 tick is likely not enough time for long calibrations</a>
<a name="ln2868">		 * to complete.  So we should wait quite a while.</a>
<a name="ln2869">		 */</a>
<a name="ln2870">		pause(&quot;ath_reset_grablock&quot;, msecs_to_ticks(100));</a>
<a name="ln2871">		i--;</a>
<a name="ln2872">		ATH_PCU_LOCK(sc);</a>
<a name="ln2873">	} while (i &gt; 0);</a>
<a name="ln2874"> </a>
<a name="ln2875">	/*</a>
<a name="ln2876">	 * We always increment the refcounter, regardless</a>
<a name="ln2877">	 * of whether we succeeded to get it in an exclusive</a>
<a name="ln2878">	 * way.</a>
<a name="ln2879">	 */</a>
<a name="ln2880">	sc-&gt;sc_inreset_cnt++;</a>
<a name="ln2881"> </a>
<a name="ln2882">	if (i &lt;= 0)</a>
<a name="ln2883">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln2884">		    &quot;%s: didn't finish after %d iterations\n&quot;,</a>
<a name="ln2885">		    __func__, MAX_RESET_ITERATIONS);</a>
<a name="ln2886"> </a>
<a name="ln2887">	if (w == 0)</a>
<a name="ln2888">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln2889">		    &quot;%s: warning, recursive reset path!\n&quot;,</a>
<a name="ln2890">		    __func__);</a>
<a name="ln2891"> </a>
<a name="ln2892">	return w;</a>
<a name="ln2893">}</a>
<a name="ln2894">#undef MAX_RESET_ITERATIONS</a>
<a name="ln2895"> </a>
<a name="ln2896">/*</a>
<a name="ln2897"> * Reset the hardware w/o losing operational state.  This is</a>
<a name="ln2898"> * basically a more efficient way of doing ath_stop, ath_init,</a>
<a name="ln2899"> * followed by state transitions to the current 802.11</a>
<a name="ln2900"> * operational state.  Used to recover from various errors and</a>
<a name="ln2901"> * to reset or reload hardware state.</a>
<a name="ln2902"> */</a>
<a name="ln2903">int</a>
<a name="ln2904">ath_reset(struct ath_softc *sc, ATH_RESET_TYPE reset_type)</a>
<a name="ln2905">{</a>
<a name="ln2906">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln2907">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln2908">	HAL_STATUS status;</a>
<a name="ln2909">	int i;</a>
<a name="ln2910"> </a>
<a name="ln2911">	DPRINTF(sc, ATH_DEBUG_RESET, &quot;%s: called\n&quot;, __func__);</a>
<a name="ln2912"> </a>
<a name="ln2913">	/* Ensure ATH_LOCK isn't held; ath_rx_proc can't be locked */</a>
<a name="ln2914">	ATH_PCU_UNLOCK_ASSERT(sc);</a>
<a name="ln2915">	ATH_UNLOCK_ASSERT(sc);</a>
<a name="ln2916"> </a>
<a name="ln2917">	/* Try to (stop any further TX/RX from occurring */</a>
<a name="ln2918">	taskqueue_block(sc-&gt;sc_tq);</a>
<a name="ln2919"> </a>
<a name="ln2920">	/*</a>
<a name="ln2921">	 * Wake the hardware up.</a>
<a name="ln2922">	 */</a>
<a name="ln2923">	ATH_LOCK(sc);</a>
<a name="ln2924">	ath_power_set_power_state(sc, HAL_PM_AWAKE);</a>
<a name="ln2925">	ATH_UNLOCK(sc);</a>
<a name="ln2926"> </a>
<a name="ln2927">	ATH_PCU_LOCK(sc);</a>
<a name="ln2928"> </a>
<a name="ln2929">	/*</a>
<a name="ln2930">	 * Grab the reset lock before TX/RX is stopped.</a>
<a name="ln2931">	 *</a>
<a name="ln2932">	 * This is needed to ensure that when the TX/RX actually does finish,</a>
<a name="ln2933">	 * no further TX/RX/reset runs in parallel with this.</a>
<a name="ln2934">	 */</a>
<a name="ln2935">	if (ath_reset_grablock(sc, 1) == 0) {</a>
<a name="ln2936">		device_printf(sc-&gt;sc_dev, &quot;%s: concurrent reset! Danger!\n&quot;,</a>
<a name="ln2937">		    __func__);</a>
<a name="ln2938">	}</a>
<a name="ln2939"> </a>
<a name="ln2940">	/* disable interrupts */</a>
<a name="ln2941">	ath_hal_intrset(ah, 0);</a>
<a name="ln2942"> </a>
<a name="ln2943">	/*</a>
<a name="ln2944">	 * Now, ensure that any in progress TX/RX completes before we</a>
<a name="ln2945">	 * continue.</a>
<a name="ln2946">	 */</a>
<a name="ln2947">	ath_txrx_stop_locked(sc);</a>
<a name="ln2948"> </a>
<a name="ln2949">	ATH_PCU_UNLOCK(sc);</a>
<a name="ln2950"> </a>
<a name="ln2951">	/*</a>
<a name="ln2952">	 * Regardless of whether we're doing a no-loss flush or</a>
<a name="ln2953">	 * not, stop the PCU and handle what's in the RX queue.</a>
<a name="ln2954">	 * That way frames aren't dropped which shouldn't be.</a>
<a name="ln2955">	 */</a>
<a name="ln2956">	ath_stoprecv(sc, (reset_type != ATH_RESET_NOLOSS));</a>
<a name="ln2957">	ath_rx_flush(sc);</a>
<a name="ln2958"> </a>
<a name="ln2959">	/*</a>
<a name="ln2960">	 * Should now wait for pending TX/RX to complete</a>
<a name="ln2961">	 * and block future ones from occurring. This needs to be</a>
<a name="ln2962">	 * done before the TX queue is drained.</a>
<a name="ln2963">	 */</a>
<a name="ln2964">	ath_draintxq(sc, reset_type);	/* stop xmit side */</a>
<a name="ln2965"> </a>
<a name="ln2966">	ath_settkipmic(sc);		/* configure TKIP MIC handling */</a>
<a name="ln2967">	/* NB: indicate channel change so we do a full reset */</a>
<a name="ln2968">	ath_update_chainmasks(sc, ic-&gt;ic_curchan);</a>
<a name="ln2969">	ath_hal_setchainmasks(sc-&gt;sc_ah, sc-&gt;sc_cur_txchainmask,</a>
<a name="ln2970">	    sc-&gt;sc_cur_rxchainmask);</a>
<a name="ln2971">	if (!ath_hal_reset(ah, sc-&gt;sc_opmode, ic-&gt;ic_curchan, AH_TRUE,</a>
<a name="ln2972">	    HAL_RESET_NORMAL, &amp;status))</a>
<a name="ln2973">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln2974">		    &quot;%s: unable to reset hardware; hal status %u\n&quot;,</a>
<a name="ln2975">		    __func__, status);</a>
<a name="ln2976">	sc-&gt;sc_diversity = ath_hal_getdiversity(ah);</a>
<a name="ln2977"> </a>
<a name="ln2978">	ATH_RX_LOCK(sc);</a>
<a name="ln2979">	sc-&gt;sc_rx_stopped = 1;</a>
<a name="ln2980">	sc-&gt;sc_rx_resetted = 1;</a>
<a name="ln2981">	ATH_RX_UNLOCK(sc);</a>
<a name="ln2982"> </a>
<a name="ln2983">	/* Quiet time handling - ensure we resync */</a>
<a name="ln2984">	ath_vap_clear_quiet_ie(sc);</a>
<a name="ln2985"> </a>
<a name="ln2986">	/* Let DFS at it in case it's a DFS channel */</a>
<a name="ln2987">	ath_dfs_radar_enable(sc, ic-&gt;ic_curchan);</a>
<a name="ln2988"> </a>
<a name="ln2989">	/* Let spectral at in case spectral is enabled */</a>
<a name="ln2990">	ath_spectral_enable(sc, ic-&gt;ic_curchan);</a>
<a name="ln2991"> </a>
<a name="ln2992">	/*</a>
<a name="ln2993">	 * Let bluetooth coexistence at in case it's needed for this channel</a>
<a name="ln2994">	 */</a>
<a name="ln2995">	ath_btcoex_enable(sc, ic-&gt;ic_curchan);</a>
<a name="ln2996"> </a>
<a name="ln2997">	/*</a>
<a name="ln2998">	 * If we're doing TDMA, enforce the TXOP limitation for chips that</a>
<a name="ln2999">	 * support it.</a>
<a name="ln3000">	 */</a>
<a name="ln3001">	if (sc-&gt;sc_hasenforcetxop &amp;&amp; sc-&gt;sc_tdma)</a>
<a name="ln3002">		ath_hal_setenforcetxop(sc-&gt;sc_ah, 1);</a>
<a name="ln3003">	else</a>
<a name="ln3004">		ath_hal_setenforcetxop(sc-&gt;sc_ah, 0);</a>
<a name="ln3005"> </a>
<a name="ln3006">	if (ath_startrecv(sc) != 0)	/* restart recv */</a>
<a name="ln3007">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln3008">		    &quot;%s: unable to start recv logic\n&quot;, __func__);</a>
<a name="ln3009">	/*</a>
<a name="ln3010">	 * We may be doing a reset in response to an ioctl</a>
<a name="ln3011">	 * that changes the channel so update any state that</a>
<a name="ln3012">	 * might change as a result.</a>
<a name="ln3013">	 */</a>
<a name="ln3014">	ath_chan_change(sc, ic-&gt;ic_curchan);</a>
<a name="ln3015">	if (sc-&gt;sc_beacons) {		/* restart beacons */</a>
<a name="ln3016">#ifdef IEEE80211_SUPPORT_TDMA</a>
<a name="ln3017">		if (sc-&gt;sc_tdma)</a>
<a name="ln3018">			ath_tdma_config(sc, NULL);</a>
<a name="ln3019">		else</a>
<a name="ln3020">#endif</a>
<a name="ln3021">			ath_beacon_config(sc, NULL);</a>
<a name="ln3022">	}</a>
<a name="ln3023"> </a>
<a name="ln3024">	/*</a>
<a name="ln3025">	 * Release the reset lock and re-enable interrupts here.</a>
<a name="ln3026">	 * If an interrupt was being processed in ath_intr(),</a>
<a name="ln3027">	 * it would disable interrupts at this point. So we have</a>
<a name="ln3028">	 * to atomically enable interrupts and decrement the</a>
<a name="ln3029">	 * reset counter - this way ath_intr() doesn't end up</a>
<a name="ln3030">	 * disabling interrupts without a corresponding enable</a>
<a name="ln3031">	 * in the rest or channel change path.</a>
<a name="ln3032">	 *</a>
<a name="ln3033">	 * Grab the TX reference in case we need to transmit.</a>
<a name="ln3034">	 * That way a parallel transmit doesn't.</a>
<a name="ln3035">	 */</a>
<a name="ln3036">	ATH_PCU_LOCK(sc);</a>
<a name="ln3037">	sc-&gt;sc_inreset_cnt--;</a>
<a name="ln3038">	sc-&gt;sc_txstart_cnt++;</a>
<a name="ln3039">	/* XXX only do this if sc_inreset_cnt == 0? */</a>
<a name="ln3040">	ath_hal_intrset(ah, sc-&gt;sc_imask);</a>
<a name="ln3041">	ATH_PCU_UNLOCK(sc);</a>
<a name="ln3042"> </a>
<a name="ln3043">	/*</a>
<a name="ln3044">	 * TX and RX can be started here. If it were started with</a>
<a name="ln3045">	 * sc_inreset_cnt &gt; 0, the TX and RX path would abort.</a>
<a name="ln3046">	 * Thus if this is a nested call through the reset or</a>
<a name="ln3047">	 * channel change code, TX completion will occur but</a>
<a name="ln3048">	 * RX completion and ath_start / ath_tx_start will not</a>
<a name="ln3049">	 * run.</a>
<a name="ln3050">	 */</a>
<a name="ln3051"> </a>
<a name="ln3052">	/* Restart TX/RX as needed */</a>
<a name="ln3053">	ath_txrx_start(sc);</a>
<a name="ln3054"> </a>
<a name="ln3055">	/* XXX TODO: we need to hold the tx refcount here! */</a>
<a name="ln3056"> </a>
<a name="ln3057">	/* Restart TX completion and pending TX */</a>
<a name="ln3058">	if (reset_type == ATH_RESET_NOLOSS) {</a>
<a name="ln3059">		for (i = 0; i &lt; HAL_NUM_TX_QUEUES; i++) {</a>
<a name="ln3060">			if (ATH_TXQ_SETUP(sc, i)) {</a>
<a name="ln3061">				ATH_TXQ_LOCK(&amp;sc-&gt;sc_txq[i]);</a>
<a name="ln3062">				ath_txq_restart_dma(sc, &amp;sc-&gt;sc_txq[i]);</a>
<a name="ln3063">				ATH_TXQ_UNLOCK(&amp;sc-&gt;sc_txq[i]);</a>
<a name="ln3064"> </a>
<a name="ln3065">				ATH_TX_LOCK(sc);</a>
<a name="ln3066">				ath_txq_sched(sc, &amp;sc-&gt;sc_txq[i]);</a>
<a name="ln3067">				ATH_TX_UNLOCK(sc);</a>
<a name="ln3068">			}</a>
<a name="ln3069">		}</a>
<a name="ln3070">	}</a>
<a name="ln3071"> </a>
<a name="ln3072">	ATH_LOCK(sc);</a>
<a name="ln3073">	ath_power_restore_power_state(sc);</a>
<a name="ln3074">	ATH_UNLOCK(sc);</a>
<a name="ln3075"> </a>
<a name="ln3076">	ATH_PCU_LOCK(sc);</a>
<a name="ln3077">	sc-&gt;sc_txstart_cnt--;</a>
<a name="ln3078">	ATH_PCU_UNLOCK(sc);</a>
<a name="ln3079"> </a>
<a name="ln3080">	/* Handle any frames in the TX queue */</a>
<a name="ln3081">	/*</a>
<a name="ln3082">	 * XXX should this be done by the caller, rather than</a>
<a name="ln3083">	 * ath_reset() ?</a>
<a name="ln3084">	 */</a>
<a name="ln3085">	ath_tx_kick(sc);		/* restart xmit */</a>
<a name="ln3086">	return 0;</a>
<a name="ln3087">}</a>
<a name="ln3088"> </a>
<a name="ln3089">static int</a>
<a name="ln3090">ath_reset_vap(struct ieee80211vap *vap, u_long cmd)</a>
<a name="ln3091">{</a>
<a name="ln3092">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln3093">	struct ath_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln3094">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln3095"> </a>
<a name="ln3096">	switch (cmd) {</a>
<a name="ln3097">	case IEEE80211_IOC_TXPOWER:</a>
<a name="ln3098">		/*</a>
<a name="ln3099">		 * If per-packet TPC is enabled, then we have nothing</a>
<a name="ln3100">		 * to do; otherwise we need to force the global limit.</a>
<a name="ln3101">		 * All this can happen directly; no need to reset.</a>
<a name="ln3102">		 */</a>
<a name="ln3103">		if (!ath_hal_gettpc(ah))</a>
<a name="ln3104">			ath_hal_settxpowlimit(ah, ic-&gt;ic_txpowlimit);</a>
<a name="ln3105">		return 0;</a>
<a name="ln3106">	}</a>
<a name="ln3107">	/* XXX? Full or NOLOSS? */</a>
<a name="ln3108">	return ath_reset(sc, ATH_RESET_FULL);</a>
<a name="ln3109">}</a>
<a name="ln3110"> </a>
<a name="ln3111">struct ath_buf *</a>
<a name="ln3112">_ath_getbuf_locked(struct ath_softc *sc, ath_buf_type_t btype)</a>
<a name="ln3113">{</a>
<a name="ln3114">	struct ath_buf *bf;</a>
<a name="ln3115"> </a>
<a name="ln3116">	ATH_TXBUF_LOCK_ASSERT(sc);</a>
<a name="ln3117"> </a>
<a name="ln3118">	if (btype == ATH_BUFTYPE_MGMT)</a>
<a name="ln3119">		bf = TAILQ_FIRST(&amp;sc-&gt;sc_txbuf_mgmt);</a>
<a name="ln3120">	else</a>
<a name="ln3121">		bf = TAILQ_FIRST(&amp;sc-&gt;sc_txbuf);</a>
<a name="ln3122"> </a>
<a name="ln3123">	if (bf == NULL) {</a>
<a name="ln3124">		sc-&gt;sc_stats.ast_tx_getnobuf++;</a>
<a name="ln3125">	} else {</a>
<a name="ln3126">		if (bf-&gt;bf_flags &amp; ATH_BUF_BUSY) {</a>
<a name="ln3127">			sc-&gt;sc_stats.ast_tx_getbusybuf++;</a>
<a name="ln3128">			bf = NULL;</a>
<a name="ln3129">		}</a>
<a name="ln3130">	}</a>
<a name="ln3131"> </a>
<a name="ln3132">	if (bf != NULL &amp;&amp; (bf-&gt;bf_flags &amp; ATH_BUF_BUSY) == 0) {</a>
<a name="ln3133">		if (btype == ATH_BUFTYPE_MGMT)</a>
<a name="ln3134">			TAILQ_REMOVE(&amp;sc-&gt;sc_txbuf_mgmt, bf, bf_list);</a>
<a name="ln3135">		else {</a>
<a name="ln3136">			TAILQ_REMOVE(&amp;sc-&gt;sc_txbuf, bf, bf_list);</a>
<a name="ln3137">			sc-&gt;sc_txbuf_cnt--;</a>
<a name="ln3138"> </a>
<a name="ln3139">			/*</a>
<a name="ln3140">			 * This shuldn't happen; however just to be</a>
<a name="ln3141">			 * safe print a warning and fudge the txbuf</a>
<a name="ln3142">			 * count.</a>
<a name="ln3143">			 */</a>
<a name="ln3144">			if (sc-&gt;sc_txbuf_cnt &lt; 0) {</a>
<a name="ln3145">				device_printf(sc-&gt;sc_dev,</a>
<a name="ln3146">				    &quot;%s: sc_txbuf_cnt &lt; 0?\n&quot;,</a>
<a name="ln3147">				    __func__);</a>
<a name="ln3148">				sc-&gt;sc_txbuf_cnt = 0;</a>
<a name="ln3149">			}</a>
<a name="ln3150">		}</a>
<a name="ln3151">	} else</a>
<a name="ln3152">		bf = NULL;</a>
<a name="ln3153"> </a>
<a name="ln3154">	if (bf == NULL) {</a>
<a name="ln3155">		/* XXX should check which list, mgmt or otherwise */</a>
<a name="ln3156">		DPRINTF(sc, ATH_DEBUG_XMIT, &quot;%s: %s\n&quot;, __func__,</a>
<a name="ln3157">		    TAILQ_FIRST(&amp;sc-&gt;sc_txbuf) == NULL ?</a>
<a name="ln3158">			&quot;out of xmit buffers&quot; : &quot;xmit buffer busy&quot;);</a>
<a name="ln3159">		return NULL;</a>
<a name="ln3160">	}</a>
<a name="ln3161"> </a>
<a name="ln3162">	/* XXX TODO: should do this at buffer list initialisation */</a>
<a name="ln3163">	/* XXX (then, ensure the buffer has the right flag set) */</a>
<a name="ln3164">	bf-&gt;bf_flags = 0;</a>
<a name="ln3165">	if (btype == ATH_BUFTYPE_MGMT)</a>
<a name="ln3166">		bf-&gt;bf_flags |= ATH_BUF_MGMT;</a>
<a name="ln3167">	else</a>
<a name="ln3168">		bf-&gt;bf_flags &amp;= (~ATH_BUF_MGMT);</a>
<a name="ln3169"> </a>
<a name="ln3170">	/* Valid bf here; clear some basic fields */</a>
<a name="ln3171">	bf-&gt;bf_next = NULL;	/* XXX just to be sure */</a>
<a name="ln3172">	bf-&gt;bf_last = NULL;	/* XXX again, just to be sure */</a>
<a name="ln3173">	bf-&gt;bf_comp = NULL;	/* XXX again, just to be sure */</a>
<a name="ln3174">	bzero(&amp;bf-&gt;bf_state, sizeof(bf-&gt;bf_state));</a>
<a name="ln3175"> </a>
<a name="ln3176">	/*</a>
<a name="ln3177">	 * Track the descriptor ID only if doing EDMA</a>
<a name="ln3178">	 */</a>
<a name="ln3179">	if (sc-&gt;sc_isedma) {</a>
<a name="ln3180">		bf-&gt;bf_descid = sc-&gt;sc_txbuf_descid;</a>
<a name="ln3181">		sc-&gt;sc_txbuf_descid++;</a>
<a name="ln3182">	}</a>
<a name="ln3183"> </a>
<a name="ln3184">	return bf;</a>
<a name="ln3185">}</a>
<a name="ln3186"> </a>
<a name="ln3187">/*</a>
<a name="ln3188"> * When retrying a software frame, buffers marked ATH_BUF_BUSY</a>
<a name="ln3189"> * can't be thrown back on the queue as they could still be</a>
<a name="ln3190"> * in use by the hardware.</a>
<a name="ln3191"> *</a>
<a name="ln3192"> * This duplicates the buffer, or returns NULL.</a>
<a name="ln3193"> *</a>
<a name="ln3194"> * The descriptor is also copied but the link pointers and</a>
<a name="ln3195"> * the DMA segments aren't copied; this frame should thus</a>
<a name="ln3196"> * be again passed through the descriptor setup/chain routines</a>
<a name="ln3197"> * so the link is correct.</a>
<a name="ln3198"> *</a>
<a name="ln3199"> * The caller must free the buffer using ath_freebuf().</a>
<a name="ln3200"> */</a>
<a name="ln3201">struct ath_buf *</a>
<a name="ln3202">ath_buf_clone(struct ath_softc *sc, struct ath_buf *bf)</a>
<a name="ln3203">{</a>
<a name="ln3204">	struct ath_buf *tbf;</a>
<a name="ln3205"> </a>
<a name="ln3206">	tbf = ath_getbuf(sc,</a>
<a name="ln3207">	    (bf-&gt;bf_flags &amp; ATH_BUF_MGMT) ?</a>
<a name="ln3208">	     ATH_BUFTYPE_MGMT : ATH_BUFTYPE_NORMAL);</a>
<a name="ln3209">	if (tbf == NULL)</a>
<a name="ln3210">		return NULL;	/* XXX failure? Why? */</a>
<a name="ln3211"> </a>
<a name="ln3212">	/* Copy basics */</a>
<a name="ln3213">	tbf-&gt;bf_next = NULL;</a>
<a name="ln3214">	tbf-&gt;bf_nseg = bf-&gt;bf_nseg;</a>
<a name="ln3215">	tbf-&gt;bf_flags = bf-&gt;bf_flags &amp; ATH_BUF_FLAGS_CLONE;</a>
<a name="ln3216">	tbf-&gt;bf_status = bf-&gt;bf_status;</a>
<a name="ln3217">	tbf-&gt;bf_m = bf-&gt;bf_m;</a>
<a name="ln3218">	tbf-&gt;bf_node = bf-&gt;bf_node;</a>
<a name="ln3219">	KASSERT((bf-&gt;bf_node != NULL), (&quot;%s: bf_node=NULL!&quot;, __func__));</a>
<a name="ln3220">	/* will be setup by the chain/setup function */</a>
<a name="ln3221">	tbf-&gt;bf_lastds = NULL;</a>
<a name="ln3222">	/* for now, last == self */</a>
<a name="ln3223">	tbf-&gt;bf_last = tbf;</a>
<a name="ln3224">	tbf-&gt;bf_comp = bf-&gt;bf_comp;</a>
<a name="ln3225"> </a>
<a name="ln3226">	/* NOTE: DMA segments will be setup by the setup/chain functions */</a>
<a name="ln3227"> </a>
<a name="ln3228">	/* The caller has to re-init the descriptor + links */</a>
<a name="ln3229"> </a>
<a name="ln3230">	/*</a>
<a name="ln3231">	 * Free the DMA mapping here, before we NULL the mbuf.</a>
<a name="ln3232">	 * We must only call bus_dmamap_unload() once per mbuf chain</a>
<a name="ln3233">	 * or behaviour is undefined.</a>
<a name="ln3234">	 */</a>
<a name="ln3235">	if (bf-&gt;bf_m != NULL) {</a>
<a name="ln3236">		/*</a>
<a name="ln3237">		 * XXX is this POSTWRITE call required?</a>
<a name="ln3238">		 */</a>
<a name="ln3239">		bus_dmamap_sync(sc-&gt;sc_dmat, bf-&gt;bf_dmamap,</a>
<a name="ln3240">		    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln3241">		bus_dmamap_unload(sc-&gt;sc_dmat, bf-&gt;bf_dmamap);</a>
<a name="ln3242">	}</a>
<a name="ln3243"> </a>
<a name="ln3244">	bf-&gt;bf_m = NULL;</a>
<a name="ln3245">	bf-&gt;bf_node = NULL;</a>
<a name="ln3246"> </a>
<a name="ln3247">	/* Copy state */</a>
<a name="ln3248">	memcpy(&amp;tbf-&gt;bf_state, &amp;bf-&gt;bf_state, sizeof(bf-&gt;bf_state));</a>
<a name="ln3249"> </a>
<a name="ln3250">	return tbf;</a>
<a name="ln3251">}</a>
<a name="ln3252"> </a>
<a name="ln3253">struct ath_buf *</a>
<a name="ln3254">ath_getbuf(struct ath_softc *sc, ath_buf_type_t btype)</a>
<a name="ln3255">{</a>
<a name="ln3256">	struct ath_buf *bf;</a>
<a name="ln3257"> </a>
<a name="ln3258">	ATH_TXBUF_LOCK(sc);</a>
<a name="ln3259">	bf = _ath_getbuf_locked(sc, btype);</a>
<a name="ln3260">	/*</a>
<a name="ln3261">	 * If a mgmt buffer was requested but we're out of those,</a>
<a name="ln3262">	 * try requesting a normal one.</a>
<a name="ln3263">	 */</a>
<a name="ln3264">	if (bf == NULL &amp;&amp; btype == ATH_BUFTYPE_MGMT)</a>
<a name="ln3265">		bf = _ath_getbuf_locked(sc, ATH_BUFTYPE_NORMAL);</a>
<a name="ln3266">	ATH_TXBUF_UNLOCK(sc);</a>
<a name="ln3267">	if (bf == NULL) {</a>
<a name="ln3268">		DPRINTF(sc, ATH_DEBUG_XMIT, &quot;%s: stop queue\n&quot;, __func__);</a>
<a name="ln3269">		sc-&gt;sc_stats.ast_tx_qstop++;</a>
<a name="ln3270">	}</a>
<a name="ln3271">	return bf;</a>
<a name="ln3272">}</a>
<a name="ln3273"> </a>
<a name="ln3274">/*</a>
<a name="ln3275"> * Transmit a single frame.</a>
<a name="ln3276"> *</a>
<a name="ln3277"> * net80211 will free the node reference if the transmit</a>
<a name="ln3278"> * fails, so don't free the node reference here.</a>
<a name="ln3279"> */</a>
<a name="ln3280">static int</a>
<a name="ln3281">ath_transmit(struct ieee80211com *ic, struct mbuf *m)</a>
<a name="ln3282">{</a>
<a name="ln3283">	struct ath_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln3284">	struct ieee80211_node *ni;</a>
<a name="ln3285">	struct mbuf *next;</a>
<a name="ln3286">	struct ath_buf *bf;</a>
<a name="ln3287">	ath_bufhead frags;</a>
<a name="ln3288">	int retval = 0;</a>
<a name="ln3289"> </a>
<a name="ln3290">	/*</a>
<a name="ln3291">	 * Tell the reset path that we're currently transmitting.</a>
<a name="ln3292">	 */</a>
<a name="ln3293">	ATH_PCU_LOCK(sc);</a>
<a name="ln3294">	if (sc-&gt;sc_inreset_cnt &gt; 0) {</a>
<a name="ln3295">		DPRINTF(sc, ATH_DEBUG_XMIT,</a>
<a name="ln3296">		    &quot;%s: sc_inreset_cnt &gt; 0; bailing\n&quot;, __func__);</a>
<a name="ln3297">		ATH_PCU_UNLOCK(sc);</a>
<a name="ln3298">		sc-&gt;sc_stats.ast_tx_qstop++;</a>
<a name="ln3299">		ATH_KTR(sc, ATH_KTR_TX, 0, &quot;ath_start_task: OACTIVE, finish&quot;);</a>
<a name="ln3300">		return (ENOBUFS);	/* XXX should be EINVAL or? */</a>
<a name="ln3301">	}</a>
<a name="ln3302">	sc-&gt;sc_txstart_cnt++;</a>
<a name="ln3303">	ATH_PCU_UNLOCK(sc);</a>
<a name="ln3304"> </a>
<a name="ln3305">	/* Wake the hardware up already */</a>
<a name="ln3306">	ATH_LOCK(sc);</a>
<a name="ln3307">	ath_power_set_power_state(sc, HAL_PM_AWAKE);</a>
<a name="ln3308">	ATH_UNLOCK(sc);</a>
<a name="ln3309"> </a>
<a name="ln3310">	ATH_KTR(sc, ATH_KTR_TX, 0, &quot;ath_transmit: start&quot;);</a>
<a name="ln3311">	/*</a>
<a name="ln3312">	 * Grab the TX lock - it's ok to do this here; we haven't</a>
<a name="ln3313">	 * yet started transmitting.</a>
<a name="ln3314">	 */</a>
<a name="ln3315">	ATH_TX_LOCK(sc);</a>
<a name="ln3316"> </a>
<a name="ln3317">	/*</a>
<a name="ln3318">	 * Node reference, if there's one.</a>
<a name="ln3319">	 */</a>
<a name="ln3320">	ni = (struct ieee80211_node *) m-&gt;m_pkthdr.rcvif;</a>
<a name="ln3321"> </a>
<a name="ln3322">	/*</a>
<a name="ln3323">	 * Enforce how deep a node queue can get.</a>
<a name="ln3324">	 *</a>
<a name="ln3325">	 * XXX it would be nicer if we kept an mbuf queue per</a>
<a name="ln3326">	 * node and only whacked them into ath_bufs when we</a>
<a name="ln3327">	 * are ready to schedule some traffic from them.</a>
<a name="ln3328">	 * .. that may come later.</a>
<a name="ln3329">	 *</a>
<a name="ln3330">	 * XXX we should also track the per-node hardware queue</a>
<a name="ln3331">	 * depth so it is easy to limit the _SUM_ of the swq and</a>
<a name="ln3332">	 * hwq frames.  Since we only schedule two HWQ frames</a>
<a name="ln3333">	 * at a time, this should be OK for now.</a>
<a name="ln3334">	 */</a>
<a name="ln3335">	if ((!(m-&gt;m_flags &amp; M_EAPOL)) &amp;&amp;</a>
<a name="ln3336">	    (ATH_NODE(ni)-&gt;an_swq_depth &gt; sc-&gt;sc_txq_node_maxdepth)) {</a>
<a name="ln3337">		sc-&gt;sc_stats.ast_tx_nodeq_overflow++;</a>
<a name="ln3338">		retval = ENOBUFS;</a>
<a name="ln3339">		goto finish;</a>
<a name="ln3340">	}</a>
<a name="ln3341"> </a>
<a name="ln3342">	/*</a>
<a name="ln3343">	 * Check how many TX buffers are available.</a>
<a name="ln3344">	 *</a>
<a name="ln3345">	 * If this is for non-EAPOL traffic, just leave some</a>
<a name="ln3346">	 * space free in order for buffer cloning and raw</a>
<a name="ln3347">	 * frame transmission to occur.</a>
<a name="ln3348">	 *</a>
<a name="ln3349">	 * If it's for EAPOL traffic, ignore this for now.</a>
<a name="ln3350">	 * Management traffic will be sent via the raw transmit</a>
<a name="ln3351">	 * method which bypasses this check.</a>
<a name="ln3352">	 *</a>
<a name="ln3353">	 * This is needed to ensure that EAPOL frames during</a>
<a name="ln3354">	 * (re) keying have a chance to go out.</a>
<a name="ln3355">	 *</a>
<a name="ln3356">	 * See kern/138379 for more information.</a>
<a name="ln3357">	 */</a>
<a name="ln3358">	if ((!(m-&gt;m_flags &amp; M_EAPOL)) &amp;&amp;</a>
<a name="ln3359">	    (sc-&gt;sc_txbuf_cnt &lt;= sc-&gt;sc_txq_data_minfree)) {</a>
<a name="ln3360">		sc-&gt;sc_stats.ast_tx_nobuf++;</a>
<a name="ln3361">		retval = ENOBUFS;</a>
<a name="ln3362">		goto finish;</a>
<a name="ln3363">	}</a>
<a name="ln3364"> </a>
<a name="ln3365">	/*</a>
<a name="ln3366">	 * Grab a TX buffer and associated resources.</a>
<a name="ln3367">	 *</a>
<a name="ln3368">	 * If it's an EAPOL frame, allocate a MGMT ath_buf.</a>
<a name="ln3369">	 * That way even with temporary buffer exhaustion due to</a>
<a name="ln3370">	 * the data path doesn't leave us without the ability</a>
<a name="ln3371">	 * to transmit management frames.</a>
<a name="ln3372">	 *</a>
<a name="ln3373">	 * Otherwise allocate a normal buffer.</a>
<a name="ln3374">	 */</a>
<a name="ln3375">	if (m-&gt;m_flags &amp; M_EAPOL)</a>
<a name="ln3376">		bf = ath_getbuf(sc, ATH_BUFTYPE_MGMT);</a>
<a name="ln3377">	else</a>
<a name="ln3378">		bf = ath_getbuf(sc, ATH_BUFTYPE_NORMAL);</a>
<a name="ln3379"> </a>
<a name="ln3380">	if (bf == NULL) {</a>
<a name="ln3381">		/*</a>
<a name="ln3382">		 * If we failed to allocate a buffer, fail.</a>
<a name="ln3383">		 *</a>
<a name="ln3384">		 * We shouldn't fail normally, due to the check</a>
<a name="ln3385">		 * above.</a>
<a name="ln3386">		 */</a>
<a name="ln3387">		sc-&gt;sc_stats.ast_tx_nobuf++;</a>
<a name="ln3388">		retval = ENOBUFS;</a>
<a name="ln3389">		goto finish;</a>
<a name="ln3390">	}</a>
<a name="ln3391"> </a>
<a name="ln3392">	/*</a>
<a name="ln3393">	 * At this point we have a buffer; so we need to free it</a>
<a name="ln3394">	 * if we hit any error conditions.</a>
<a name="ln3395">	 */</a>
<a name="ln3396"> </a>
<a name="ln3397">	/*</a>
<a name="ln3398">	 * Check for fragmentation.  If this frame</a>
<a name="ln3399">	 * has been broken up verify we have enough</a>
<a name="ln3400">	 * buffers to send all the fragments so all</a>
<a name="ln3401">	 * go out or none...</a>
<a name="ln3402">	 */</a>
<a name="ln3403">	TAILQ_INIT(&amp;frags);</a>
<a name="ln3404">	if ((m-&gt;m_flags &amp; M_FRAG) &amp;&amp;</a>
<a name="ln3405">	    !ath_txfrag_setup(sc, &amp;frags, m, ni)) {</a>
<a name="ln3406">		DPRINTF(sc, ATH_DEBUG_XMIT,</a>
<a name="ln3407">		    &quot;%s: out of txfrag buffers\n&quot;, __func__);</a>
<a name="ln3408">		sc-&gt;sc_stats.ast_tx_nofrag++;</a>
<a name="ln3409">		if_inc_counter(ni-&gt;ni_vap-&gt;iv_ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln3410">		/*</a>
<a name="ln3411">		 * XXXGL: is mbuf valid after ath_txfrag_setup? If yes,</a>
<a name="ln3412">		 * we shouldn't free it but return back.</a>
<a name="ln3413">		 */</a>
<a name="ln3414">		ieee80211_free_mbuf(m);</a>
<a name="ln3415">		m = NULL;</a>
<a name="ln3416">		goto bad;</a>
<a name="ln3417">	}</a>
<a name="ln3418"> </a>
<a name="ln3419">	/*</a>
<a name="ln3420">	 * At this point if we have any TX fragments, then we will</a>
<a name="ln3421">	 * have bumped the node reference once for each of those.</a>
<a name="ln3422">	 */</a>
<a name="ln3423"> </a>
<a name="ln3424">	/*</a>
<a name="ln3425">	 * XXX Is there anything actually _enforcing_ that the</a>
<a name="ln3426">	 * fragments are being transmitted in one hit, rather than</a>
<a name="ln3427">	 * being interleaved with other transmissions on that</a>
<a name="ln3428">	 * hardware queue?</a>
<a name="ln3429">	 *</a>
<a name="ln3430">	 * The ATH TX output lock is the only thing serialising this</a>
<a name="ln3431">	 * right now.</a>
<a name="ln3432">	 */</a>
<a name="ln3433"> </a>
<a name="ln3434">	/*</a>
<a name="ln3435">	 * Calculate the &quot;next fragment&quot; length field in ath_buf</a>
<a name="ln3436">	 * in order to let the transmit path know enough about</a>
<a name="ln3437">	 * what to next write to the hardware.</a>
<a name="ln3438">	 */</a>
<a name="ln3439">	if (m-&gt;m_flags &amp; M_FRAG) {</a>
<a name="ln3440">		struct ath_buf *fbf = bf;</a>
<a name="ln3441">		struct ath_buf *n_fbf = NULL;</a>
<a name="ln3442">		struct mbuf *fm = m-&gt;m_nextpkt;</a>
<a name="ln3443"> </a>
<a name="ln3444">		/*</a>
<a name="ln3445">		 * We need to walk the list of fragments and set</a>
<a name="ln3446">		 * the next size to the following buffer.</a>
<a name="ln3447">		 * However, the first buffer isn't in the frag</a>
<a name="ln3448">		 * list, so we have to do some gymnastics here.</a>
<a name="ln3449">		 */</a>
<a name="ln3450">		TAILQ_FOREACH(n_fbf, &amp;frags, bf_list) {</a>
<a name="ln3451">			fbf-&gt;bf_nextfraglen = fm-&gt;m_pkthdr.len;</a>
<a name="ln3452">			fbf = n_fbf;</a>
<a name="ln3453">			fm = fm-&gt;m_nextpkt;</a>
<a name="ln3454">		}</a>
<a name="ln3455">	}</a>
<a name="ln3456"> </a>
<a name="ln3457">nextfrag:</a>
<a name="ln3458">	/*</a>
<a name="ln3459">	 * Pass the frame to the h/w for transmission.</a>
<a name="ln3460">	 * Fragmented frames have each frag chained together</a>
<a name="ln3461">	 * with m_nextpkt.  We know there are sufficient ath_buf's</a>
<a name="ln3462">	 * to send all the frags because of work done by</a>
<a name="ln3463">	 * ath_txfrag_setup.  We leave m_nextpkt set while</a>
<a name="ln3464">	 * calling ath_tx_start so it can use it to extend the</a>
<a name="ln3465">	 * the tx duration to cover the subsequent frag and</a>
<a name="ln3466">	 * so it can reclaim all the mbufs in case of an error;</a>
<a name="ln3467">	 * ath_tx_start clears m_nextpkt once it commits to</a>
<a name="ln3468">	 * handing the frame to the hardware.</a>
<a name="ln3469">	 *</a>
<a name="ln3470">	 * Note: if this fails, then the mbufs are freed but</a>
<a name="ln3471">	 * not the node reference.</a>
<a name="ln3472">	 *</a>
<a name="ln3473">	 * So, we now have to free the node reference ourselves here</a>
<a name="ln3474">	 * and return OK up to the stack.</a>
<a name="ln3475">	 */</a>
<a name="ln3476">	next = m-&gt;m_nextpkt;</a>
<a name="ln3477">	if (ath_tx_start(sc, ni, bf, m)) {</a>
<a name="ln3478">bad:</a>
<a name="ln3479">		if_inc_counter(ni-&gt;ni_vap-&gt;iv_ifp, IFCOUNTER_OERRORS, 1);</a>
<a name="ln3480">reclaim:</a>
<a name="ln3481">		bf-&gt;bf_m = NULL;</a>
<a name="ln3482">		bf-&gt;bf_node = NULL;</a>
<a name="ln3483">		ATH_TXBUF_LOCK(sc);</a>
<a name="ln3484">		ath_returnbuf_head(sc, bf);</a>
<a name="ln3485">		/*</a>
<a name="ln3486">		 * Free the rest of the node references and</a>
<a name="ln3487">		 * buffers for the fragment list.</a>
<a name="ln3488">		 */</a>
<a name="ln3489">		ath_txfrag_cleanup(sc, &amp;frags, ni);</a>
<a name="ln3490">		ATH_TXBUF_UNLOCK(sc);</a>
<a name="ln3491"> </a>
<a name="ln3492">		/*</a>
<a name="ln3493">		 * XXX: And free the node/return OK; ath_tx_start() may have</a>
<a name="ln3494">		 *      modified the buffer.  We currently have no way to</a>
<a name="ln3495">		 *      signify that the mbuf was freed but there was an error.</a>
<a name="ln3496">		 */</a>
<a name="ln3497">		ieee80211_free_node(ni);</a>
<a name="ln3498">		retval = 0;</a>
<a name="ln3499">		goto finish;</a>
<a name="ln3500">	}</a>
<a name="ln3501"> </a>
<a name="ln3502">	/*</a>
<a name="ln3503">	 * Check here if the node is in power save state.</a>
<a name="ln3504">	 */</a>
<a name="ln3505">	ath_tx_update_tim(sc, ni, 1);</a>
<a name="ln3506"> </a>
<a name="ln3507">	if (next != NULL) {</a>
<a name="ln3508">		/*</a>
<a name="ln3509">		 * Beware of state changing between frags.</a>
<a name="ln3510">		 * XXX check sta power-save state?</a>
<a name="ln3511">		 */</a>
<a name="ln3512">		if (ni-&gt;ni_vap-&gt;iv_state != IEEE80211_S_RUN) {</a>
<a name="ln3513">			DPRINTF(sc, ATH_DEBUG_XMIT,</a>
<a name="ln3514">			    &quot;%s: flush fragmented packet, state %s\n&quot;,</a>
<a name="ln3515">			    __func__,</a>
<a name="ln3516">			    ieee80211_state_name[ni-&gt;ni_vap-&gt;iv_state]);</a>
<a name="ln3517">			/* XXX dmamap */</a>
<a name="ln3518">			ieee80211_free_mbuf(next);</a>
<a name="ln3519">			goto reclaim;</a>
<a name="ln3520">		}</a>
<a name="ln3521">		m = next;</a>
<a name="ln3522">		bf = TAILQ_FIRST(&amp;frags);</a>
<a name="ln3523">		KASSERT(bf != NULL, (&quot;no buf for txfrag&quot;));</a>
<a name="ln3524">		TAILQ_REMOVE(&amp;frags, bf, bf_list);</a>
<a name="ln3525">		goto nextfrag;</a>
<a name="ln3526">	}</a>
<a name="ln3527"> </a>
<a name="ln3528">	/*</a>
<a name="ln3529">	 * Bump watchdog timer.</a>
<a name="ln3530">	 */</a>
<a name="ln3531">	sc-&gt;sc_wd_timer = 5;</a>
<a name="ln3532"> </a>
<a name="ln3533">finish:</a>
<a name="ln3534">	ATH_TX_UNLOCK(sc);</a>
<a name="ln3535"> </a>
<a name="ln3536">	/*</a>
<a name="ln3537">	 * Finished transmitting!</a>
<a name="ln3538">	 */</a>
<a name="ln3539">	ATH_PCU_LOCK(sc);</a>
<a name="ln3540">	sc-&gt;sc_txstart_cnt--;</a>
<a name="ln3541">	ATH_PCU_UNLOCK(sc);</a>
<a name="ln3542"> </a>
<a name="ln3543">	/* Sleep the hardware if required */</a>
<a name="ln3544">	ATH_LOCK(sc);</a>
<a name="ln3545">	ath_power_restore_power_state(sc);</a>
<a name="ln3546">	ATH_UNLOCK(sc);</a>
<a name="ln3547"> </a>
<a name="ln3548">	ATH_KTR(sc, ATH_KTR_TX, 0, &quot;ath_transmit: finished&quot;);</a>
<a name="ln3549"> </a>
<a name="ln3550">	return (retval);</a>
<a name="ln3551">}</a>
<a name="ln3552"> </a>
<a name="ln3553">static int</a>
<a name="ln3554">ath_media_change(struct ifnet *ifp)</a>
<a name="ln3555">{</a>
<a name="ln3556">	int error = ieee80211_media_change(ifp);</a>
<a name="ln3557">	/* NB: only the fixed rate can change and that doesn't need a reset */</a>
<a name="ln3558">	return (error == ENETRESET ? 0 : error);</a>
<a name="ln3559">}</a>
<a name="ln3560"> </a>
<a name="ln3561">/*</a>
<a name="ln3562"> * Block/unblock tx+rx processing while a key change is done.</a>
<a name="ln3563"> * We assume the caller serializes key management operations</a>
<a name="ln3564"> * so we only need to worry about synchronization with other</a>
<a name="ln3565"> * uses that originate in the driver.</a>
<a name="ln3566"> */</a>
<a name="ln3567">static void</a>
<a name="ln3568">ath_key_update_begin(struct ieee80211vap *vap)</a>
<a name="ln3569">{</a>
<a name="ln3570">	struct ath_softc *sc = vap-&gt;iv_ic-&gt;ic_softc;</a>
<a name="ln3571"> </a>
<a name="ln3572">	DPRINTF(sc, ATH_DEBUG_KEYCACHE, &quot;%s:\n&quot;, __func__);</a>
<a name="ln3573">	taskqueue_block(sc-&gt;sc_tq);</a>
<a name="ln3574">}</a>
<a name="ln3575"> </a>
<a name="ln3576">static void</a>
<a name="ln3577">ath_key_update_end(struct ieee80211vap *vap)</a>
<a name="ln3578">{</a>
<a name="ln3579">	struct ath_softc *sc = vap-&gt;iv_ic-&gt;ic_softc;</a>
<a name="ln3580"> </a>
<a name="ln3581">	DPRINTF(sc, ATH_DEBUG_KEYCACHE, &quot;%s:\n&quot;, __func__);</a>
<a name="ln3582">	taskqueue_unblock(sc-&gt;sc_tq);</a>
<a name="ln3583">}</a>
<a name="ln3584"> </a>
<a name="ln3585">static void</a>
<a name="ln3586">ath_update_promisc(struct ieee80211com *ic)</a>
<a name="ln3587">{</a>
<a name="ln3588">	struct ath_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln3589">	u_int32_t rfilt;</a>
<a name="ln3590"> </a>
<a name="ln3591">	/* configure rx filter */</a>
<a name="ln3592">	ATH_LOCK(sc);</a>
<a name="ln3593">	ath_power_set_power_state(sc, HAL_PM_AWAKE);</a>
<a name="ln3594">	rfilt = ath_calcrxfilter(sc);</a>
<a name="ln3595">	ath_hal_setrxfilter(sc-&gt;sc_ah, rfilt);</a>
<a name="ln3596">	ath_power_restore_power_state(sc);</a>
<a name="ln3597">	ATH_UNLOCK(sc);</a>
<a name="ln3598"> </a>
<a name="ln3599">	DPRINTF(sc, ATH_DEBUG_MODE, &quot;%s: RX filter 0x%x\n&quot;, __func__, rfilt);</a>
<a name="ln3600">}</a>
<a name="ln3601"> </a>
<a name="ln3602">/*</a>
<a name="ln3603"> * Driver-internal mcast update call.</a>
<a name="ln3604"> *</a>
<a name="ln3605"> * Assumes the hardware is already awake.</a>
<a name="ln3606"> */</a>
<a name="ln3607">static void</a>
<a name="ln3608">ath_update_mcast_hw(struct ath_softc *sc)</a>
<a name="ln3609">{</a>
<a name="ln3610">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln3611">	u_int32_t mfilt[2];</a>
<a name="ln3612"> </a>
<a name="ln3613">	/* calculate and install multicast filter */</a>
<a name="ln3614">	if (ic-&gt;ic_allmulti == 0) {</a>
<a name="ln3615">		struct ieee80211vap *vap;</a>
<a name="ln3616">		struct ifnet *ifp;</a>
<a name="ln3617">		struct ifmultiaddr *ifma;</a>
<a name="ln3618"> </a>
<a name="ln3619">		/*</a>
<a name="ln3620">		 * Merge multicast addresses to form the hardware filter.</a>
<a name="ln3621">		 */</a>
<a name="ln3622">		mfilt[0] = mfilt[1] = 0;</a>
<a name="ln3623">		TAILQ_FOREACH(vap, &amp;ic-&gt;ic_vaps, iv_next) {</a>
<a name="ln3624">			ifp = vap-&gt;iv_ifp;</a>
<a name="ln3625">			if_maddr_rlock(ifp);</a>
<a name="ln3626">			TAILQ_FOREACH(ifma, &amp;ifp-&gt;if_multiaddrs, ifma_link) {</a>
<a name="ln3627">				caddr_t dl;</a>
<a name="ln3628">				uint32_t val;</a>
<a name="ln3629">				uint8_t pos;</a>
<a name="ln3630"> </a>
<a name="ln3631">				/* calculate XOR of eight 6bit values */</a>
<a name="ln3632">				dl = LLADDR((struct sockaddr_dl *)</a>
<a name="ln3633">				    ifma-&gt;ifma_addr);</a>
<a name="ln3634">				val = le32dec(dl + 0);</a>
<a name="ln3635">				pos = (val &gt;&gt; 18) ^ (val &gt;&gt; 12) ^ (val &gt;&gt; 6) ^</a>
<a name="ln3636">				    val;</a>
<a name="ln3637">				val = le32dec(dl + 3);</a>
<a name="ln3638">				pos ^= (val &gt;&gt; 18) ^ (val &gt;&gt; 12) ^ (val &gt;&gt; 6) ^</a>
<a name="ln3639">				    val;</a>
<a name="ln3640">				pos &amp;= 0x3f;</a>
<a name="ln3641">				mfilt[pos / 32] |= (1 &lt;&lt; (pos % 32));</a>
<a name="ln3642">			}</a>
<a name="ln3643">			if_maddr_runlock(ifp);</a>
<a name="ln3644">		}</a>
<a name="ln3645">	} else</a>
<a name="ln3646">		mfilt[0] = mfilt[1] = ~0;</a>
<a name="ln3647"> </a>
<a name="ln3648">	ath_hal_setmcastfilter(sc-&gt;sc_ah, mfilt[0], mfilt[1]);</a>
<a name="ln3649"> </a>
<a name="ln3650">	DPRINTF(sc, ATH_DEBUG_MODE, &quot;%s: MC filter %08x:%08x\n&quot;,</a>
<a name="ln3651">		__func__, mfilt[0], mfilt[1]);</a>
<a name="ln3652">}</a>
<a name="ln3653"> </a>
<a name="ln3654">/*</a>
<a name="ln3655"> * Called from the net80211 layer - force the hardware</a>
<a name="ln3656"> * awake before operating.</a>
<a name="ln3657"> */</a>
<a name="ln3658">static void</a>
<a name="ln3659">ath_update_mcast(struct ieee80211com *ic)</a>
<a name="ln3660">{</a>
<a name="ln3661">	struct ath_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln3662"> </a>
<a name="ln3663">	ATH_LOCK(sc);</a>
<a name="ln3664">	ath_power_set_power_state(sc, HAL_PM_AWAKE);</a>
<a name="ln3665">	ATH_UNLOCK(sc);</a>
<a name="ln3666"> </a>
<a name="ln3667">	ath_update_mcast_hw(sc);</a>
<a name="ln3668"> </a>
<a name="ln3669">	ATH_LOCK(sc);</a>
<a name="ln3670">	ath_power_restore_power_state(sc);</a>
<a name="ln3671">	ATH_UNLOCK(sc);</a>
<a name="ln3672">}</a>
<a name="ln3673"> </a>
<a name="ln3674">void</a>
<a name="ln3675">ath_mode_init(struct ath_softc *sc)</a>
<a name="ln3676">{</a>
<a name="ln3677">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln3678">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln3679">	u_int32_t rfilt;</a>
<a name="ln3680"> </a>
<a name="ln3681">	/* XXX power state? */</a>
<a name="ln3682"> </a>
<a name="ln3683">	/* configure rx filter */</a>
<a name="ln3684">	rfilt = ath_calcrxfilter(sc);</a>
<a name="ln3685">	ath_hal_setrxfilter(ah, rfilt);</a>
<a name="ln3686"> </a>
<a name="ln3687">	/* configure operational mode */</a>
<a name="ln3688">	ath_hal_setopmode(ah);</a>
<a name="ln3689"> </a>
<a name="ln3690">	/* handle any link-level address change */</a>
<a name="ln3691">	ath_hal_setmac(ah, ic-&gt;ic_macaddr);</a>
<a name="ln3692"> </a>
<a name="ln3693">	/* calculate and install multicast filter */</a>
<a name="ln3694">	ath_update_mcast_hw(sc);</a>
<a name="ln3695">}</a>
<a name="ln3696"> </a>
<a name="ln3697">/*</a>
<a name="ln3698"> * Set the slot time based on the current setting.</a>
<a name="ln3699"> */</a>
<a name="ln3700">void</a>
<a name="ln3701">ath_setslottime(struct ath_softc *sc)</a>
<a name="ln3702">{</a>
<a name="ln3703">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln3704">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln3705">	u_int usec;</a>
<a name="ln3706"> </a>
<a name="ln3707">	if (IEEE80211_IS_CHAN_HALF(ic-&gt;ic_curchan))</a>
<a name="ln3708">		usec = 13;</a>
<a name="ln3709">	else if (IEEE80211_IS_CHAN_QUARTER(ic-&gt;ic_curchan))</a>
<a name="ln3710">		usec = 21;</a>
<a name="ln3711">	else if (IEEE80211_IS_CHAN_ANYG(ic-&gt;ic_curchan)) {</a>
<a name="ln3712">		/* honor short/long slot time only in 11g */</a>
<a name="ln3713">		/* XXX shouldn't honor on pure g or turbo g channel */</a>
<a name="ln3714">		if (ic-&gt;ic_flags &amp; IEEE80211_F_SHSLOT)</a>
<a name="ln3715">			usec = HAL_SLOT_TIME_9;</a>
<a name="ln3716">		else</a>
<a name="ln3717">			usec = HAL_SLOT_TIME_20;</a>
<a name="ln3718">	} else</a>
<a name="ln3719">		usec = HAL_SLOT_TIME_9;</a>
<a name="ln3720"> </a>
<a name="ln3721">	DPRINTF(sc, ATH_DEBUG_RESET,</a>
<a name="ln3722">	    &quot;%s: chan %u MHz flags 0x%x %s slot, %u usec\n&quot;,</a>
<a name="ln3723">	    __func__, ic-&gt;ic_curchan-&gt;ic_freq, ic-&gt;ic_curchan-&gt;ic_flags,</a>
<a name="ln3724">	    ic-&gt;ic_flags &amp; IEEE80211_F_SHSLOT ? &quot;short&quot; : &quot;long&quot;, usec);</a>
<a name="ln3725"> </a>
<a name="ln3726">	/* Wake up the hardware first before updating the slot time */</a>
<a name="ln3727">	ATH_LOCK(sc);</a>
<a name="ln3728">	ath_power_set_power_state(sc, HAL_PM_AWAKE);</a>
<a name="ln3729">	ath_hal_setslottime(ah, usec);</a>
<a name="ln3730">	ath_power_restore_power_state(sc);</a>
<a name="ln3731">	sc-&gt;sc_updateslot = OK;</a>
<a name="ln3732">	ATH_UNLOCK(sc);</a>
<a name="ln3733">}</a>
<a name="ln3734"> </a>
<a name="ln3735">/*</a>
<a name="ln3736"> * Callback from the 802.11 layer to update the</a>
<a name="ln3737"> * slot time based on the current setting.</a>
<a name="ln3738"> */</a>
<a name="ln3739">static void</a>
<a name="ln3740">ath_updateslot(struct ieee80211com *ic)</a>
<a name="ln3741">{</a>
<a name="ln3742">	struct ath_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln3743"> </a>
<a name="ln3744">	/*</a>
<a name="ln3745">	 * When not coordinating the BSS, change the hardware</a>
<a name="ln3746">	 * immediately.  For other operation we defer the change</a>
<a name="ln3747">	 * until beacon updates have propagated to the stations.</a>
<a name="ln3748">	 *</a>
<a name="ln3749">	 * XXX sc_updateslot isn't changed behind a lock?</a>
<a name="ln3750">	 */</a>
<a name="ln3751">	if (ic-&gt;ic_opmode == IEEE80211_M_HOSTAP ||</a>
<a name="ln3752">	    ic-&gt;ic_opmode == IEEE80211_M_MBSS)</a>
<a name="ln3753">		sc-&gt;sc_updateslot = UPDATE;</a>
<a name="ln3754">	else</a>
<a name="ln3755">		ath_setslottime(sc);</a>
<a name="ln3756">}</a>
<a name="ln3757"> </a>
<a name="ln3758">/*</a>
<a name="ln3759"> * Append the contents of src to dst; both queues</a>
<a name="ln3760"> * are assumed to be locked.</a>
<a name="ln3761"> */</a>
<a name="ln3762">void</a>
<a name="ln3763">ath_txqmove(struct ath_txq *dst, struct ath_txq *src)</a>
<a name="ln3764">{</a>
<a name="ln3765"> </a>
<a name="ln3766">	ATH_TXQ_LOCK_ASSERT(src);</a>
<a name="ln3767">	ATH_TXQ_LOCK_ASSERT(dst);</a>
<a name="ln3768"> </a>
<a name="ln3769">	TAILQ_CONCAT(&amp;dst-&gt;axq_q, &amp;src-&gt;axq_q, bf_list);</a>
<a name="ln3770">	dst-&gt;axq_link = src-&gt;axq_link;</a>
<a name="ln3771">	src-&gt;axq_link = NULL;</a>
<a name="ln3772">	dst-&gt;axq_depth += src-&gt;axq_depth;</a>
<a name="ln3773">	dst-&gt;axq_aggr_depth += src-&gt;axq_aggr_depth;</a>
<a name="ln3774">	src-&gt;axq_depth = 0;</a>
<a name="ln3775">	src-&gt;axq_aggr_depth = 0;</a>
<a name="ln3776">}</a>
<a name="ln3777"> </a>
<a name="ln3778">/*</a>
<a name="ln3779"> * Reset the hardware, with no loss.</a>
<a name="ln3780"> *</a>
<a name="ln3781"> * This can't be used for a general case reset.</a>
<a name="ln3782"> */</a>
<a name="ln3783">static void</a>
<a name="ln3784">ath_reset_proc(void *arg, int pending)</a>
<a name="ln3785">{</a>
<a name="ln3786">	struct ath_softc *sc = arg;</a>
<a name="ln3787"> </a>
<a name="ln3788">#if 0</a>
<a name="ln3789">	device_printf(sc-&gt;sc_dev, &quot;%s: resetting\n&quot;, __func__);</a>
<a name="ln3790">#endif</a>
<a name="ln3791">	ath_reset(sc, ATH_RESET_NOLOSS);</a>
<a name="ln3792">}</a>
<a name="ln3793"> </a>
<a name="ln3794">/*</a>
<a name="ln3795"> * Reset the hardware after detecting beacons have stopped.</a>
<a name="ln3796"> */</a>
<a name="ln3797">static void</a>
<a name="ln3798">ath_bstuck_proc(void *arg, int pending)</a>
<a name="ln3799">{</a>
<a name="ln3800">	struct ath_softc *sc = arg;</a>
<a name="ln3801">	uint32_t hangs = 0;</a>
<a name="ln3802"> </a>
<a name="ln3803">	if (ath_hal_gethangstate(sc-&gt;sc_ah, 0xff, &amp;hangs) &amp;&amp; hangs != 0)</a>
<a name="ln3804">		device_printf(sc-&gt;sc_dev, &quot;bb hang detected (0x%x)\n&quot;, hangs);</a>
<a name="ln3805"> </a>
<a name="ln3806">#ifdef	ATH_DEBUG_ALQ</a>
<a name="ln3807">	if (if_ath_alq_checkdebug(&amp;sc-&gt;sc_alq, ATH_ALQ_STUCK_BEACON))</a>
<a name="ln3808">		if_ath_alq_post(&amp;sc-&gt;sc_alq, ATH_ALQ_STUCK_BEACON, 0, NULL);</a>
<a name="ln3809">#endif</a>
<a name="ln3810"> </a>
<a name="ln3811">	device_printf(sc-&gt;sc_dev, &quot;stuck beacon; resetting (bmiss count %u)\n&quot;,</a>
<a name="ln3812">	    sc-&gt;sc_bmisscount);</a>
<a name="ln3813">	sc-&gt;sc_stats.ast_bstuck++;</a>
<a name="ln3814">	/*</a>
<a name="ln3815">	 * This assumes that there's no simultaneous channel mode change</a>
<a name="ln3816">	 * occurring.</a>
<a name="ln3817">	 */</a>
<a name="ln3818">	ath_reset(sc, ATH_RESET_NOLOSS);</a>
<a name="ln3819">}</a>
<a name="ln3820"> </a>
<a name="ln3821">static int</a>
<a name="ln3822">ath_desc_alloc(struct ath_softc *sc)</a>
<a name="ln3823">{</a>
<a name="ln3824">	int error;</a>
<a name="ln3825"> </a>
<a name="ln3826">	error = ath_descdma_setup(sc, &amp;sc-&gt;sc_txdma, &amp;sc-&gt;sc_txbuf,</a>
<a name="ln3827">		    &quot;tx&quot;, sc-&gt;sc_tx_desclen, ath_txbuf, ATH_MAX_SCATTER);</a>
<a name="ln3828">	if (error != 0) {</a>
<a name="ln3829">		return error;</a>
<a name="ln3830">	}</a>
<a name="ln3831">	sc-&gt;sc_txbuf_cnt = ath_txbuf;</a>
<a name="ln3832"> </a>
<a name="ln3833">	error = ath_descdma_setup(sc, &amp;sc-&gt;sc_txdma_mgmt, &amp;sc-&gt;sc_txbuf_mgmt,</a>
<a name="ln3834">		    &quot;tx_mgmt&quot;, sc-&gt;sc_tx_desclen, ath_txbuf_mgmt,</a>
<a name="ln3835">		    ATH_TXDESC);</a>
<a name="ln3836">	if (error != 0) {</a>
<a name="ln3837">		ath_descdma_cleanup(sc, &amp;sc-&gt;sc_txdma, &amp;sc-&gt;sc_txbuf);</a>
<a name="ln3838">		return error;</a>
<a name="ln3839">	}</a>
<a name="ln3840"> </a>
<a name="ln3841">	/*</a>
<a name="ln3842">	 * XXX mark txbuf_mgmt frames with ATH_BUF_MGMT, so the</a>
<a name="ln3843">	 * flag doesn't have to be set in ath_getbuf_locked().</a>
<a name="ln3844">	 */</a>
<a name="ln3845"> </a>
<a name="ln3846">	error = ath_descdma_setup(sc, &amp;sc-&gt;sc_bdma, &amp;sc-&gt;sc_bbuf,</a>
<a name="ln3847">			&quot;beacon&quot;, sc-&gt;sc_tx_desclen, ATH_BCBUF, 1);</a>
<a name="ln3848">	if (error != 0) {</a>
<a name="ln3849">		ath_descdma_cleanup(sc, &amp;sc-&gt;sc_txdma, &amp;sc-&gt;sc_txbuf);</a>
<a name="ln3850">		ath_descdma_cleanup(sc, &amp;sc-&gt;sc_txdma_mgmt,</a>
<a name="ln3851">		    &amp;sc-&gt;sc_txbuf_mgmt);</a>
<a name="ln3852">		return error;</a>
<a name="ln3853">	}</a>
<a name="ln3854">	return 0;</a>
<a name="ln3855">}</a>
<a name="ln3856"> </a>
<a name="ln3857">static void</a>
<a name="ln3858">ath_desc_free(struct ath_softc *sc)</a>
<a name="ln3859">{</a>
<a name="ln3860"> </a>
<a name="ln3861">	if (sc-&gt;sc_bdma.dd_desc_len != 0)</a>
<a name="ln3862">		ath_descdma_cleanup(sc, &amp;sc-&gt;sc_bdma, &amp;sc-&gt;sc_bbuf);</a>
<a name="ln3863">	if (sc-&gt;sc_txdma.dd_desc_len != 0)</a>
<a name="ln3864">		ath_descdma_cleanup(sc, &amp;sc-&gt;sc_txdma, &amp;sc-&gt;sc_txbuf);</a>
<a name="ln3865">	if (sc-&gt;sc_txdma_mgmt.dd_desc_len != 0)</a>
<a name="ln3866">		ath_descdma_cleanup(sc, &amp;sc-&gt;sc_txdma_mgmt,</a>
<a name="ln3867">		    &amp;sc-&gt;sc_txbuf_mgmt);</a>
<a name="ln3868">}</a>
<a name="ln3869"> </a>
<a name="ln3870">static struct ieee80211_node *</a>
<a name="ln3871">ath_node_alloc(struct ieee80211vap *vap, const uint8_t mac[IEEE80211_ADDR_LEN])</a>
<a name="ln3872">{</a>
<a name="ln3873">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln3874">	struct ath_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln3875">	const size_t space = sizeof(struct ath_node) + sc-&gt;sc_rc-&gt;arc_space;</a>
<a name="ln3876">	struct ath_node *an;</a>
<a name="ln3877"> </a>
<a name="ln3878">	an = malloc(space, M_80211_NODE, M_NOWAIT|M_ZERO);</a>
<a name="ln3879">	if (an == NULL) {</a>
<a name="ln3880">		/* XXX stat+msg */</a>
<a name="ln3881">		return NULL;</a>
<a name="ln3882">	}</a>
<a name="ln3883">	ath_rate_node_init(sc, an);</a>
<a name="ln3884"> </a>
<a name="ln3885">	/* Setup the mutex - there's no associd yet so set the name to NULL */</a>
<a name="ln3886">	snprintf(an-&gt;an_name, sizeof(an-&gt;an_name), &quot;%s: node %p&quot;,</a>
<a name="ln3887">	    device_get_nameunit(sc-&gt;sc_dev), an);</a>
<a name="ln3888">	mtx_init(&amp;an-&gt;an_mtx, an-&gt;an_name, NULL, MTX_DEF);</a>
<a name="ln3889"> </a>
<a name="ln3890">	/* XXX setup ath_tid */</a>
<a name="ln3891">	ath_tx_tid_init(sc, an);</a>
<a name="ln3892"> </a>
<a name="ln3893">	DPRINTF(sc, ATH_DEBUG_NODE, &quot;%s: %6D: an %p\n&quot;, __func__, mac, &quot;:&quot;, an);</a>
<a name="ln3894">	return &amp;an-&gt;an_node;</a>
<a name="ln3895">}</a>
<a name="ln3896"> </a>
<a name="ln3897">static void</a>
<a name="ln3898">ath_node_cleanup(struct ieee80211_node *ni)</a>
<a name="ln3899">{</a>
<a name="ln3900">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln3901">	struct ath_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln3902"> </a>
<a name="ln3903">	DPRINTF(sc, ATH_DEBUG_NODE, &quot;%s: %6D: an %p\n&quot;, __func__,</a>
<a name="ln3904">	    ni-&gt;ni_macaddr, &quot;:&quot;, ATH_NODE(ni));</a>
<a name="ln3905"> </a>
<a name="ln3906">	/* Cleanup ath_tid, free unused bufs, unlink bufs in TXQ */</a>
<a name="ln3907">	ath_tx_node_flush(sc, ATH_NODE(ni));</a>
<a name="ln3908">	ath_rate_node_cleanup(sc, ATH_NODE(ni));</a>
<a name="ln3909">	sc-&gt;sc_node_cleanup(ni);</a>
<a name="ln3910">}</a>
<a name="ln3911"> </a>
<a name="ln3912">static void</a>
<a name="ln3913">ath_node_free(struct ieee80211_node *ni)</a>
<a name="ln3914">{</a>
<a name="ln3915">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln3916">	struct ath_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln3917"> </a>
<a name="ln3918">	DPRINTF(sc, ATH_DEBUG_NODE, &quot;%s: %6D: an %p\n&quot;, __func__,</a>
<a name="ln3919">	    ni-&gt;ni_macaddr, &quot;:&quot;, ATH_NODE(ni));</a>
<a name="ln3920">	mtx_destroy(&amp;ATH_NODE(ni)-&gt;an_mtx);</a>
<a name="ln3921">	sc-&gt;sc_node_free(ni);</a>
<a name="ln3922">}</a>
<a name="ln3923"> </a>
<a name="ln3924">static void</a>
<a name="ln3925">ath_node_getsignal(const struct ieee80211_node *ni, int8_t *rssi, int8_t *noise)</a>
<a name="ln3926">{</a>
<a name="ln3927">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln3928">	struct ath_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln3929">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln3930"> </a>
<a name="ln3931">	*rssi = ic-&gt;ic_node_getrssi(ni);</a>
<a name="ln3932">	if (ni-&gt;ni_chan != IEEE80211_CHAN_ANYC)</a>
<a name="ln3933">		*noise = ath_hal_getchannoise(ah, ni-&gt;ni_chan);</a>
<a name="ln3934">	else</a>
<a name="ln3935">		*noise = -95;		/* nominally correct */</a>
<a name="ln3936">}</a>
<a name="ln3937"> </a>
<a name="ln3938">/*</a>
<a name="ln3939"> * Set the default antenna.</a>
<a name="ln3940"> */</a>
<a name="ln3941">void</a>
<a name="ln3942">ath_setdefantenna(struct ath_softc *sc, u_int antenna)</a>
<a name="ln3943">{</a>
<a name="ln3944">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln3945"> </a>
<a name="ln3946">	/* XXX block beacon interrupts */</a>
<a name="ln3947">	ath_hal_setdefantenna(ah, antenna);</a>
<a name="ln3948">	if (sc-&gt;sc_defant != antenna)</a>
<a name="ln3949">		sc-&gt;sc_stats.ast_ant_defswitch++;</a>
<a name="ln3950">	sc-&gt;sc_defant = antenna;</a>
<a name="ln3951">	sc-&gt;sc_rxotherant = 0;</a>
<a name="ln3952">}</a>
<a name="ln3953"> </a>
<a name="ln3954">static void</a>
<a name="ln3955">ath_txq_init(struct ath_softc *sc, struct ath_txq *txq, int qnum)</a>
<a name="ln3956">{</a>
<a name="ln3957">	txq-&gt;axq_qnum = qnum;</a>
<a name="ln3958">	txq-&gt;axq_ac = 0;</a>
<a name="ln3959">	txq-&gt;axq_depth = 0;</a>
<a name="ln3960">	txq-&gt;axq_aggr_depth = 0;</a>
<a name="ln3961">	txq-&gt;axq_intrcnt = 0;</a>
<a name="ln3962">	txq-&gt;axq_link = NULL;</a>
<a name="ln3963">	txq-&gt;axq_softc = sc;</a>
<a name="ln3964">	TAILQ_INIT(&amp;txq-&gt;axq_q);</a>
<a name="ln3965">	TAILQ_INIT(&amp;txq-&gt;axq_tidq);</a>
<a name="ln3966">	TAILQ_INIT(&amp;txq-&gt;fifo.axq_q);</a>
<a name="ln3967">	ATH_TXQ_LOCK_INIT(sc, txq);</a>
<a name="ln3968">}</a>
<a name="ln3969"> </a>
<a name="ln3970">/*</a>
<a name="ln3971"> * Setup a h/w transmit queue.</a>
<a name="ln3972"> */</a>
<a name="ln3973">static struct ath_txq *</a>
<a name="ln3974">ath_txq_setup(struct ath_softc *sc, int qtype, int subtype)</a>
<a name="ln3975">{</a>
<a name="ln3976">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln3977">	HAL_TXQ_INFO qi;</a>
<a name="ln3978">	int qnum;</a>
<a name="ln3979"> </a>
<a name="ln3980">	memset(&amp;qi, 0, sizeof(qi));</a>
<a name="ln3981">	qi.tqi_subtype = subtype;</a>
<a name="ln3982">	qi.tqi_aifs = HAL_TXQ_USEDEFAULT;</a>
<a name="ln3983">	qi.tqi_cwmin = HAL_TXQ_USEDEFAULT;</a>
<a name="ln3984">	qi.tqi_cwmax = HAL_TXQ_USEDEFAULT;</a>
<a name="ln3985">	/*</a>
<a name="ln3986">	 * Enable interrupts only for EOL and DESC conditions.</a>
<a name="ln3987">	 * We mark tx descriptors to receive a DESC interrupt</a>
<a name="ln3988">	 * when a tx queue gets deep; otherwise waiting for the</a>
<a name="ln3989">	 * EOL to reap descriptors.  Note that this is done to</a>
<a name="ln3990">	 * reduce interrupt load and this only defers reaping</a>
<a name="ln3991">	 * descriptors, never transmitting frames.  Aside from</a>
<a name="ln3992">	 * reducing interrupts this also permits more concurrency.</a>
<a name="ln3993">	 * The only potential downside is if the tx queue backs</a>
<a name="ln3994">	 * up in which case the top half of the kernel may backup</a>
<a name="ln3995">	 * due to a lack of tx descriptors.</a>
<a name="ln3996">	 */</a>
<a name="ln3997">	if (sc-&gt;sc_isedma)</a>
<a name="ln3998">		qi.tqi_qflags = HAL_TXQ_TXEOLINT_ENABLE |</a>
<a name="ln3999">		    HAL_TXQ_TXOKINT_ENABLE;</a>
<a name="ln4000">	else</a>
<a name="ln4001">		qi.tqi_qflags = HAL_TXQ_TXEOLINT_ENABLE |</a>
<a name="ln4002">		    HAL_TXQ_TXDESCINT_ENABLE;</a>
<a name="ln4003"> </a>
<a name="ln4004">	qnum = ath_hal_setuptxqueue(ah, qtype, &amp;qi);</a>
<a name="ln4005">	if (qnum == -1) {</a>
<a name="ln4006">		/*</a>
<a name="ln4007">		 * NB: don't print a message, this happens</a>
<a name="ln4008">		 * normally on parts with too few tx queues</a>
<a name="ln4009">		 */</a>
<a name="ln4010">		return NULL;</a>
<a name="ln4011">	}</a>
<a name="ln4012">	if (qnum &gt;= nitems(sc-&gt;sc_txq)) {</a>
<a name="ln4013">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln4014">			&quot;hal qnum %u out of range, max %zu!\n&quot;,</a>
<a name="ln4015">			qnum, nitems(sc-&gt;sc_txq));</a>
<a name="ln4016">		ath_hal_releasetxqueue(ah, qnum);</a>
<a name="ln4017">		return NULL;</a>
<a name="ln4018">	}</a>
<a name="ln4019">	if (!ATH_TXQ_SETUP(sc, qnum)) {</a>
<a name="ln4020">		ath_txq_init(sc, &amp;sc-&gt;sc_txq[qnum], qnum);</a>
<a name="ln4021">		sc-&gt;sc_txqsetup |= 1&lt;&lt;qnum;</a>
<a name="ln4022">	}</a>
<a name="ln4023">	return &amp;sc-&gt;sc_txq[qnum];</a>
<a name="ln4024">}</a>
<a name="ln4025"> </a>
<a name="ln4026">/*</a>
<a name="ln4027"> * Setup a hardware data transmit queue for the specified</a>
<a name="ln4028"> * access control.  The hal may not support all requested</a>
<a name="ln4029"> * queues in which case it will return a reference to a</a>
<a name="ln4030"> * previously setup queue.  We record the mapping from ac's</a>
<a name="ln4031"> * to h/w queues for use by ath_tx_start and also track</a>
<a name="ln4032"> * the set of h/w queues being used to optimize work in the</a>
<a name="ln4033"> * transmit interrupt handler and related routines.</a>
<a name="ln4034"> */</a>
<a name="ln4035">static int</a>
<a name="ln4036">ath_tx_setup(struct ath_softc *sc, int ac, int haltype)</a>
<a name="ln4037">{</a>
<a name="ln4038">	struct ath_txq *txq;</a>
<a name="ln4039"> </a>
<a name="ln4040">	if (ac &gt;= nitems(sc-&gt;sc_ac2q)) {</a>
<a name="ln4041">		device_printf(sc-&gt;sc_dev, &quot;AC %u out of range, max %zu!\n&quot;,</a>
<a name="ln4042">			ac, nitems(sc-&gt;sc_ac2q));</a>
<a name="ln4043">		return 0;</a>
<a name="ln4044">	}</a>
<a name="ln4045">	txq = ath_txq_setup(sc, HAL_TX_QUEUE_DATA, haltype);</a>
<a name="ln4046">	if (txq != NULL) {</a>
<a name="ln4047">		txq-&gt;axq_ac = ac;</a>
<a name="ln4048">		sc-&gt;sc_ac2q[ac] = txq;</a>
<a name="ln4049">		return 1;</a>
<a name="ln4050">	} else</a>
<a name="ln4051">		return 0;</a>
<a name="ln4052">}</a>
<a name="ln4053"> </a>
<a name="ln4054">/*</a>
<a name="ln4055"> * Update WME parameters for a transmit queue.</a>
<a name="ln4056"> */</a>
<a name="ln4057">static int</a>
<a name="ln4058">ath_txq_update(struct ath_softc *sc, int ac)</a>
<a name="ln4059">{</a>
<a name="ln4060">#define	ATH_EXPONENT_TO_VALUE(v)	((1&lt;&lt;v)-1)</a>
<a name="ln4061">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln4062">	struct ath_txq *txq = sc-&gt;sc_ac2q[ac];</a>
<a name="ln4063">	struct chanAccParams chp;</a>
<a name="ln4064">	struct wmeParams *wmep;</a>
<a name="ln4065">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln4066">	HAL_TXQ_INFO qi;</a>
<a name="ln4067"> </a>
<a name="ln4068">	ieee80211_wme_ic_getparams(ic, &amp;chp);</a>
<a name="ln4069">	wmep = &amp;chp.cap_wmeParams[ac];</a>
<a name="ln4070"> </a>
<a name="ln4071">	ath_hal_gettxqueueprops(ah, txq-&gt;axq_qnum, &amp;qi);</a>
<a name="ln4072">#ifdef IEEE80211_SUPPORT_TDMA</a>
<a name="ln4073">	if (sc-&gt;sc_tdma) {</a>
<a name="ln4074">		/*</a>
<a name="ln4075">		 * AIFS is zero so there's no pre-transmit wait.  The</a>
<a name="ln4076">		 * burst time defines the slot duration and is configured</a>
<a name="ln4077">		 * through net80211.  The QCU is setup to not do post-xmit</a>
<a name="ln4078">		 * back off, lockout all lower-priority QCU's, and fire</a>
<a name="ln4079">		 * off the DMA beacon alert timer which is setup based</a>
<a name="ln4080">		 * on the slot configuration.</a>
<a name="ln4081">		 */</a>
<a name="ln4082">		qi.tqi_qflags = HAL_TXQ_TXOKINT_ENABLE</a>
<a name="ln4083">			      | HAL_TXQ_TXERRINT_ENABLE</a>
<a name="ln4084">			      | HAL_TXQ_TXURNINT_ENABLE</a>
<a name="ln4085">			      | HAL_TXQ_TXEOLINT_ENABLE</a>
<a name="ln4086">			      | HAL_TXQ_DBA_GATED</a>
<a name="ln4087">			      | HAL_TXQ_BACKOFF_DISABLE</a>
<a name="ln4088">			      | HAL_TXQ_ARB_LOCKOUT_GLOBAL</a>
<a name="ln4089">			      ;</a>
<a name="ln4090">		qi.tqi_aifs = 0;</a>
<a name="ln4091">		/* XXX +dbaprep? */</a>
<a name="ln4092">		qi.tqi_readyTime = sc-&gt;sc_tdmaslotlen;</a>
<a name="ln4093">		qi.tqi_burstTime = qi.tqi_readyTime;</a>
<a name="ln4094">	} else {</a>
<a name="ln4095">#endif</a>
<a name="ln4096">		/*</a>
<a name="ln4097">		 * XXX shouldn't this just use the default flags</a>
<a name="ln4098">		 * used in the previous queue setup?</a>
<a name="ln4099">		 */</a>
<a name="ln4100">		qi.tqi_qflags = HAL_TXQ_TXOKINT_ENABLE</a>
<a name="ln4101">			      | HAL_TXQ_TXERRINT_ENABLE</a>
<a name="ln4102">			      | HAL_TXQ_TXDESCINT_ENABLE</a>
<a name="ln4103">			      | HAL_TXQ_TXURNINT_ENABLE</a>
<a name="ln4104">			      | HAL_TXQ_TXEOLINT_ENABLE</a>
<a name="ln4105">			      ;</a>
<a name="ln4106">		qi.tqi_aifs = wmep-&gt;wmep_aifsn;</a>
<a name="ln4107">		qi.tqi_cwmin = ATH_EXPONENT_TO_VALUE(wmep-&gt;wmep_logcwmin);</a>
<a name="ln4108">		qi.tqi_cwmax = ATH_EXPONENT_TO_VALUE(wmep-&gt;wmep_logcwmax);</a>
<a name="ln4109">		qi.tqi_readyTime = 0;</a>
<a name="ln4110">		qi.tqi_burstTime = IEEE80211_TXOP_TO_US(wmep-&gt;wmep_txopLimit);</a>
<a name="ln4111">#ifdef IEEE80211_SUPPORT_TDMA</a>
<a name="ln4112">	}</a>
<a name="ln4113">#endif</a>
<a name="ln4114"> </a>
<a name="ln4115">	DPRINTF(sc, ATH_DEBUG_RESET,</a>
<a name="ln4116">	    &quot;%s: Q%u qflags 0x%x aifs %u cwmin %u cwmax %u burstTime %u\n&quot;,</a>
<a name="ln4117">	    __func__, txq-&gt;axq_qnum, qi.tqi_qflags,</a>
<a name="ln4118">	    qi.tqi_aifs, qi.tqi_cwmin, qi.tqi_cwmax, qi.tqi_burstTime);</a>
<a name="ln4119"> </a>
<a name="ln4120">	if (!ath_hal_settxqueueprops(ah, txq-&gt;axq_qnum, &amp;qi)) {</a>
<a name="ln4121">		device_printf(sc-&gt;sc_dev, &quot;unable to update hardware queue &quot;</a>
<a name="ln4122">		    &quot;parameters for %s traffic!\n&quot;, ieee80211_wme_acnames[ac]);</a>
<a name="ln4123">		return 0;</a>
<a name="ln4124">	} else {</a>
<a name="ln4125">		ath_hal_resettxqueue(ah, txq-&gt;axq_qnum); /* push to h/w */</a>
<a name="ln4126">		return 1;</a>
<a name="ln4127">	}</a>
<a name="ln4128">#undef ATH_EXPONENT_TO_VALUE</a>
<a name="ln4129">}</a>
<a name="ln4130"> </a>
<a name="ln4131">/*</a>
<a name="ln4132"> * Callback from the 802.11 layer to update WME parameters.</a>
<a name="ln4133"> */</a>
<a name="ln4134">int</a>
<a name="ln4135">ath_wme_update(struct ieee80211com *ic)</a>
<a name="ln4136">{</a>
<a name="ln4137">	struct ath_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln4138"> </a>
<a name="ln4139">	return !ath_txq_update(sc, WME_AC_BE) ||</a>
<a name="ln4140">	    !ath_txq_update(sc, WME_AC_BK) ||</a>
<a name="ln4141">	    !ath_txq_update(sc, WME_AC_VI) ||</a>
<a name="ln4142">	    !ath_txq_update(sc, WME_AC_VO) ? EIO : 0;</a>
<a name="ln4143">}</a>
<a name="ln4144"> </a>
<a name="ln4145">/*</a>
<a name="ln4146"> * Reclaim resources for a setup queue.</a>
<a name="ln4147"> */</a>
<a name="ln4148">static void</a>
<a name="ln4149">ath_tx_cleanupq(struct ath_softc *sc, struct ath_txq *txq)</a>
<a name="ln4150">{</a>
<a name="ln4151"> </a>
<a name="ln4152">	ath_hal_releasetxqueue(sc-&gt;sc_ah, txq-&gt;axq_qnum);</a>
<a name="ln4153">	sc-&gt;sc_txqsetup &amp;= ~(1&lt;&lt;txq-&gt;axq_qnum);</a>
<a name="ln4154">	ATH_TXQ_LOCK_DESTROY(txq);</a>
<a name="ln4155">}</a>
<a name="ln4156"> </a>
<a name="ln4157">/*</a>
<a name="ln4158"> * Reclaim all tx queue resources.</a>
<a name="ln4159"> */</a>
<a name="ln4160">static void</a>
<a name="ln4161">ath_tx_cleanup(struct ath_softc *sc)</a>
<a name="ln4162">{</a>
<a name="ln4163">	int i;</a>
<a name="ln4164"> </a>
<a name="ln4165">	ATH_TXBUF_LOCK_DESTROY(sc);</a>
<a name="ln4166">	for (i = 0; i &lt; HAL_NUM_TX_QUEUES; i++)</a>
<a name="ln4167">		if (ATH_TXQ_SETUP(sc, i))</a>
<a name="ln4168">			ath_tx_cleanupq(sc, &amp;sc-&gt;sc_txq[i]);</a>
<a name="ln4169">}</a>
<a name="ln4170"> </a>
<a name="ln4171">/*</a>
<a name="ln4172"> * Return h/w rate index for an IEEE rate (w/o basic rate bit)</a>
<a name="ln4173"> * using the current rates in sc_rixmap.</a>
<a name="ln4174"> */</a>
<a name="ln4175">int</a>
<a name="ln4176">ath_tx_findrix(const struct ath_softc *sc, uint8_t rate)</a>
<a name="ln4177">{</a>
<a name="ln4178">	int rix = sc-&gt;sc_rixmap[rate];</a>
<a name="ln4179">	/* NB: return lowest rix for invalid rate */</a>
<a name="ln4180">	return (rix == 0xff ? 0 : rix);</a>
<a name="ln4181">}</a>
<a name="ln4182"> </a>
<a name="ln4183">static void</a>
<a name="ln4184">ath_tx_update_stats(struct ath_softc *sc, struct ath_tx_status *ts,</a>
<a name="ln4185">    struct ath_buf *bf)</a>
<a name="ln4186">{</a>
<a name="ln4187">	struct ieee80211_node *ni = bf-&gt;bf_node;</a>
<a name="ln4188">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln4189">	int sr, lr, pri;</a>
<a name="ln4190"> </a>
<a name="ln4191">	if (ts-&gt;ts_status == 0) {</a>
<a name="ln4192">		u_int8_t txant = ts-&gt;ts_antenna;</a>
<a name="ln4193">		sc-&gt;sc_stats.ast_ant_tx[txant]++;</a>
<a name="ln4194">		sc-&gt;sc_ant_tx[txant]++;</a>
<a name="ln4195">		if (ts-&gt;ts_finaltsi != 0)</a>
<a name="ln4196">			sc-&gt;sc_stats.ast_tx_altrate++;</a>
<a name="ln4197"> </a>
<a name="ln4198">		/* XXX TODO: should do per-pri conuters */</a>
<a name="ln4199">		pri = M_WME_GETAC(bf-&gt;bf_m);</a>
<a name="ln4200">		if (pri &gt;= WME_AC_VO)</a>
<a name="ln4201">			ic-&gt;ic_wme.wme_hipri_traffic++;</a>
<a name="ln4202"> </a>
<a name="ln4203">		if ((bf-&gt;bf_state.bfs_txflags &amp; HAL_TXDESC_NOACK) == 0)</a>
<a name="ln4204">			ni-&gt;ni_inact = ni-&gt;ni_inact_reload;</a>
<a name="ln4205">	} else {</a>
<a name="ln4206">		if (ts-&gt;ts_status &amp; HAL_TXERR_XRETRY)</a>
<a name="ln4207">			sc-&gt;sc_stats.ast_tx_xretries++;</a>
<a name="ln4208">		if (ts-&gt;ts_status &amp; HAL_TXERR_FIFO)</a>
<a name="ln4209">			sc-&gt;sc_stats.ast_tx_fifoerr++;</a>
<a name="ln4210">		if (ts-&gt;ts_status &amp; HAL_TXERR_FILT)</a>
<a name="ln4211">			sc-&gt;sc_stats.ast_tx_filtered++;</a>
<a name="ln4212">		if (ts-&gt;ts_status &amp; HAL_TXERR_XTXOP)</a>
<a name="ln4213">			sc-&gt;sc_stats.ast_tx_xtxop++;</a>
<a name="ln4214">		if (ts-&gt;ts_status &amp; HAL_TXERR_TIMER_EXPIRED)</a>
<a name="ln4215">			sc-&gt;sc_stats.ast_tx_timerexpired++;</a>
<a name="ln4216"> </a>
<a name="ln4217">		if (bf-&gt;bf_m-&gt;m_flags &amp; M_FF)</a>
<a name="ln4218">			sc-&gt;sc_stats.ast_ff_txerr++;</a>
<a name="ln4219">	}</a>
<a name="ln4220">	/* XXX when is this valid? */</a>
<a name="ln4221">	if (ts-&gt;ts_flags &amp; HAL_TX_DESC_CFG_ERR)</a>
<a name="ln4222">		sc-&gt;sc_stats.ast_tx_desccfgerr++;</a>
<a name="ln4223">	/*</a>
<a name="ln4224">	 * This can be valid for successful frame transmission!</a>
<a name="ln4225">	 * If there's a TX FIFO underrun during aggregate transmission,</a>
<a name="ln4226">	 * the MAC will pad the rest of the aggregate with delimiters.</a>
<a name="ln4227">	 * If a BA is returned, the frame is marked as &quot;OK&quot; and it's up</a>
<a name="ln4228">	 * to the TX completion code to notice which frames weren't</a>
<a name="ln4229">	 * successfully transmitted.</a>
<a name="ln4230">	 */</a>
<a name="ln4231">	if (ts-&gt;ts_flags &amp; HAL_TX_DATA_UNDERRUN)</a>
<a name="ln4232">		sc-&gt;sc_stats.ast_tx_data_underrun++;</a>
<a name="ln4233">	if (ts-&gt;ts_flags &amp; HAL_TX_DELIM_UNDERRUN)</a>
<a name="ln4234">		sc-&gt;sc_stats.ast_tx_delim_underrun++;</a>
<a name="ln4235"> </a>
<a name="ln4236">	sr = ts-&gt;ts_shortretry;</a>
<a name="ln4237">	lr = ts-&gt;ts_longretry;</a>
<a name="ln4238">	sc-&gt;sc_stats.ast_tx_shortretry += sr;</a>
<a name="ln4239">	sc-&gt;sc_stats.ast_tx_longretry += lr;</a>
<a name="ln4240"> </a>
<a name="ln4241">}</a>
<a name="ln4242"> </a>
<a name="ln4243">/*</a>
<a name="ln4244"> * The default completion. If fail is 1, this means</a>
<a name="ln4245"> * &quot;please don't retry the frame, and just return -1 status</a>
<a name="ln4246"> * to the net80211 stack.</a>
<a name="ln4247"> */</a>
<a name="ln4248">void</a>
<a name="ln4249">ath_tx_default_comp(struct ath_softc *sc, struct ath_buf *bf, int fail)</a>
<a name="ln4250">{</a>
<a name="ln4251">	struct ath_tx_status *ts = &amp;bf-&gt;bf_status.ds_txstat;</a>
<a name="ln4252">	int st;</a>
<a name="ln4253"> </a>
<a name="ln4254">	if (fail == 1)</a>
<a name="ln4255">		st = -1;</a>
<a name="ln4256">	else</a>
<a name="ln4257">		st = ((bf-&gt;bf_state.bfs_txflags &amp; HAL_TXDESC_NOACK) == 0) ?</a>
<a name="ln4258">		    ts-&gt;ts_status : HAL_TXERR_XRETRY;</a>
<a name="ln4259"> </a>
<a name="ln4260">#if 0</a>
<a name="ln4261">	if (bf-&gt;bf_state.bfs_dobaw)</a>
<a name="ln4262">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln4263">		    &quot;%s: bf %p: seqno %d: dobaw should've been cleared!\n&quot;,</a>
<a name="ln4264">		    __func__,</a>
<a name="ln4265">		    bf,</a>
<a name="ln4266">		    SEQNO(bf-&gt;bf_state.bfs_seqno));</a>
<a name="ln4267">#endif</a>
<a name="ln4268">	if (bf-&gt;bf_next != NULL)</a>
<a name="ln4269">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln4270">		    &quot;%s: bf %p: seqno %d: bf_next not NULL!\n&quot;,</a>
<a name="ln4271">		    __func__,</a>
<a name="ln4272">		    bf,</a>
<a name="ln4273">		    SEQNO(bf-&gt;bf_state.bfs_seqno));</a>
<a name="ln4274"> </a>
<a name="ln4275">	/*</a>
<a name="ln4276">	 * Check if the node software queue is empty; if so</a>
<a name="ln4277">	 * then clear the TIM.</a>
<a name="ln4278">	 *</a>
<a name="ln4279">	 * This needs to be done before the buffer is freed as</a>
<a name="ln4280">	 * otherwise the node reference will have been released</a>
<a name="ln4281">	 * and the node may not actually exist any longer.</a>
<a name="ln4282">	 *</a>
<a name="ln4283">	 * XXX I don't like this belonging here, but it's cleaner</a>
<a name="ln4284">	 * to do it here right now then all the other places</a>
<a name="ln4285">	 * where ath_tx_default_comp() is called.</a>
<a name="ln4286">	 *</a>
<a name="ln4287">	 * XXX TODO: during drain, ensure that the callback is</a>
<a name="ln4288">	 * being called so we get a chance to update the TIM.</a>
<a name="ln4289">	 */</a>
<a name="ln4290">	if (bf-&gt;bf_node) {</a>
<a name="ln4291">		ATH_TX_LOCK(sc);</a>
<a name="ln4292">		ath_tx_update_tim(sc, bf-&gt;bf_node, 0);</a>
<a name="ln4293">		ATH_TX_UNLOCK(sc);</a>
<a name="ln4294">	}</a>
<a name="ln4295"> </a>
<a name="ln4296">	/*</a>
<a name="ln4297">	 * Do any tx complete callback.  Note this must</a>
<a name="ln4298">	 * be done before releasing the node reference.</a>
<a name="ln4299">	 * This will free the mbuf, release the net80211</a>
<a name="ln4300">	 * node and recycle the ath_buf.</a>
<a name="ln4301">	 */</a>
<a name="ln4302">	ath_tx_freebuf(sc, bf, st);</a>
<a name="ln4303">}</a>
<a name="ln4304"> </a>
<a name="ln4305">/*</a>
<a name="ln4306"> * Update rate control with the given completion status.</a>
<a name="ln4307"> */</a>
<a name="ln4308">void</a>
<a name="ln4309">ath_tx_update_ratectrl(struct ath_softc *sc, struct ieee80211_node *ni,</a>
<a name="ln4310">    struct ath_rc_series *rc, struct ath_tx_status *ts, int frmlen,</a>
<a name="ln4311">    int nframes, int nbad)</a>
<a name="ln4312">{</a>
<a name="ln4313">	struct ath_node *an;</a>
<a name="ln4314"> </a>
<a name="ln4315">	/* Only for unicast frames */</a>
<a name="ln4316">	if (ni == NULL)</a>
<a name="ln4317">		return;</a>
<a name="ln4318"> </a>
<a name="ln4319">	an = ATH_NODE(ni);</a>
<a name="ln4320">	ATH_NODE_UNLOCK_ASSERT(an);</a>
<a name="ln4321"> </a>
<a name="ln4322">	if ((ts-&gt;ts_status &amp; HAL_TXERR_FILT) == 0) {</a>
<a name="ln4323">		ATH_NODE_LOCK(an);</a>
<a name="ln4324">		ath_rate_tx_complete(sc, an, rc, ts, frmlen, nframes, nbad);</a>
<a name="ln4325">		ATH_NODE_UNLOCK(an);</a>
<a name="ln4326">	}</a>
<a name="ln4327">}</a>
<a name="ln4328"> </a>
<a name="ln4329">/*</a>
<a name="ln4330"> * Process the completion of the given buffer.</a>
<a name="ln4331"> *</a>
<a name="ln4332"> * This calls the rate control update and then the buffer completion.</a>
<a name="ln4333"> * This will either free the buffer or requeue it.  In any case, the</a>
<a name="ln4334"> * bf pointer should be treated as invalid after this function is called.</a>
<a name="ln4335"> */</a>
<a name="ln4336">void</a>
<a name="ln4337">ath_tx_process_buf_completion(struct ath_softc *sc, struct ath_txq *txq,</a>
<a name="ln4338">    struct ath_tx_status *ts, struct ath_buf *bf)</a>
<a name="ln4339">{</a>
<a name="ln4340">	struct ieee80211_node *ni = bf-&gt;bf_node;</a>
<a name="ln4341"> </a>
<a name="ln4342">	ATH_TX_UNLOCK_ASSERT(sc);</a>
<a name="ln4343">	ATH_TXQ_UNLOCK_ASSERT(txq);</a>
<a name="ln4344"> </a>
<a name="ln4345">	/* If unicast frame, update general statistics */</a>
<a name="ln4346">	if (ni != NULL) {</a>
<a name="ln4347">		/* update statistics */</a>
<a name="ln4348">		ath_tx_update_stats(sc, ts, bf);</a>
<a name="ln4349">	}</a>
<a name="ln4350"> </a>
<a name="ln4351">	/*</a>
<a name="ln4352">	 * Call the completion handler.</a>
<a name="ln4353">	 * The completion handler is responsible for</a>
<a name="ln4354">	 * calling the rate control code.</a>
<a name="ln4355">	 *</a>
<a name="ln4356">	 * Frames with no completion handler get the</a>
<a name="ln4357">	 * rate control code called here.</a>
<a name="ln4358">	 */</a>
<a name="ln4359">	if (bf-&gt;bf_comp == NULL) {</a>
<a name="ln4360">		if ((ts-&gt;ts_status &amp; HAL_TXERR_FILT) == 0 &amp;&amp;</a>
<a name="ln4361">		    (bf-&gt;bf_state.bfs_txflags &amp; HAL_TXDESC_NOACK) == 0) {</a>
<a name="ln4362">			/*</a>
<a name="ln4363">			 * XXX assume this isn't an aggregate</a>
<a name="ln4364">			 * frame.</a>
<a name="ln4365">			 */</a>
<a name="ln4366">			ath_tx_update_ratectrl(sc, ni,</a>
<a name="ln4367">			     bf-&gt;bf_state.bfs_rc, ts,</a>
<a name="ln4368">			    bf-&gt;bf_state.bfs_pktlen, 1,</a>
<a name="ln4369">			    (ts-&gt;ts_status == 0 ? 0 : 1));</a>
<a name="ln4370">		}</a>
<a name="ln4371">		ath_tx_default_comp(sc, bf, 0);</a>
<a name="ln4372">	} else</a>
<a name="ln4373">		bf-&gt;bf_comp(sc, bf, 0);</a>
<a name="ln4374">}</a>
<a name="ln4375"> </a>
<a name="ln4376"> </a>
<a name="ln4377"> </a>
<a name="ln4378">/*</a>
<a name="ln4379"> * Process completed xmit descriptors from the specified queue.</a>
<a name="ln4380"> * Kick the packet scheduler if needed. This can occur from this</a>
<a name="ln4381"> * particular task.</a>
<a name="ln4382"> */</a>
<a name="ln4383">static int</a>
<a name="ln4384">ath_tx_processq(struct ath_softc *sc, struct ath_txq *txq, int dosched)</a>
<a name="ln4385">{</a>
<a name="ln4386">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln4387">	struct ath_buf *bf;</a>
<a name="ln4388">	struct ath_desc *ds;</a>
<a name="ln4389">	struct ath_tx_status *ts;</a>
<a name="ln4390">	struct ieee80211_node *ni;</a>
<a name="ln4391">#ifdef	IEEE80211_SUPPORT_SUPERG</a>
<a name="ln4392">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln4393">#endif	/* IEEE80211_SUPPORT_SUPERG */</a>
<a name="ln4394">	int nacked;</a>
<a name="ln4395">	HAL_STATUS status;</a>
<a name="ln4396"> </a>
<a name="ln4397">	DPRINTF(sc, ATH_DEBUG_TX_PROC, &quot;%s: tx queue %u head %p link %p\n&quot;,</a>
<a name="ln4398">		__func__, txq-&gt;axq_qnum,</a>
<a name="ln4399">		(caddr_t)(uintptr_t) ath_hal_gettxbuf(sc-&gt;sc_ah, txq-&gt;axq_qnum),</a>
<a name="ln4400">		txq-&gt;axq_link);</a>
<a name="ln4401"> </a>
<a name="ln4402">	ATH_KTR(sc, ATH_KTR_TXCOMP, 4,</a>
<a name="ln4403">	    &quot;ath_tx_processq: txq=%u head %p link %p depth %p&quot;,</a>
<a name="ln4404">	    txq-&gt;axq_qnum,</a>
<a name="ln4405">	    (caddr_t)(uintptr_t) ath_hal_gettxbuf(sc-&gt;sc_ah, txq-&gt;axq_qnum),</a>
<a name="ln4406">	    txq-&gt;axq_link,</a>
<a name="ln4407">	    txq-&gt;axq_depth);</a>
<a name="ln4408"> </a>
<a name="ln4409">	nacked = 0;</a>
<a name="ln4410">	for (;;) {</a>
<a name="ln4411">		ATH_TXQ_LOCK(txq);</a>
<a name="ln4412">		txq-&gt;axq_intrcnt = 0;	/* reset periodic desc intr count */</a>
<a name="ln4413">		bf = TAILQ_FIRST(&amp;txq-&gt;axq_q);</a>
<a name="ln4414">		if (bf == NULL) {</a>
<a name="ln4415">			ATH_TXQ_UNLOCK(txq);</a>
<a name="ln4416">			break;</a>
<a name="ln4417">		}</a>
<a name="ln4418">		ds = bf-&gt;bf_lastds;	/* XXX must be setup correctly! */</a>
<a name="ln4419">		ts = &amp;bf-&gt;bf_status.ds_txstat;</a>
<a name="ln4420"> </a>
<a name="ln4421">		status = ath_hal_txprocdesc(ah, ds, ts);</a>
<a name="ln4422">#ifdef ATH_DEBUG</a>
<a name="ln4423">		if (sc-&gt;sc_debug &amp; ATH_DEBUG_XMIT_DESC)</a>
<a name="ln4424">			ath_printtxbuf(sc, bf, txq-&gt;axq_qnum, 0,</a>
<a name="ln4425">			    status == HAL_OK);</a>
<a name="ln4426">		else if ((sc-&gt;sc_debug &amp; ATH_DEBUG_RESET) &amp;&amp; (dosched == 0))</a>
<a name="ln4427">			ath_printtxbuf(sc, bf, txq-&gt;axq_qnum, 0,</a>
<a name="ln4428">			    status == HAL_OK);</a>
<a name="ln4429">#endif</a>
<a name="ln4430">#ifdef	ATH_DEBUG_ALQ</a>
<a name="ln4431">		if (if_ath_alq_checkdebug(&amp;sc-&gt;sc_alq,</a>
<a name="ln4432">		    ATH_ALQ_EDMA_TXSTATUS)) {</a>
<a name="ln4433">			if_ath_alq_post(&amp;sc-&gt;sc_alq, ATH_ALQ_EDMA_TXSTATUS,</a>
<a name="ln4434">			sc-&gt;sc_tx_statuslen,</a>
<a name="ln4435">			(char *) ds);</a>
<a name="ln4436">		}</a>
<a name="ln4437">#endif</a>
<a name="ln4438"> </a>
<a name="ln4439">		if (status == HAL_EINPROGRESS) {</a>
<a name="ln4440">			ATH_KTR(sc, ATH_KTR_TXCOMP, 3,</a>
<a name="ln4441">			    &quot;ath_tx_processq: txq=%u, bf=%p ds=%p, HAL_EINPROGRESS&quot;,</a>
<a name="ln4442">			    txq-&gt;axq_qnum, bf, ds);</a>
<a name="ln4443">			ATH_TXQ_UNLOCK(txq);</a>
<a name="ln4444">			break;</a>
<a name="ln4445">		}</a>
<a name="ln4446">		ATH_TXQ_REMOVE(txq, bf, bf_list);</a>
<a name="ln4447"> </a>
<a name="ln4448">		/*</a>
<a name="ln4449">		 * Sanity check.</a>
<a name="ln4450">		 */</a>
<a name="ln4451">		if (txq-&gt;axq_qnum != bf-&gt;bf_state.bfs_tx_queue) {</a>
<a name="ln4452">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln4453">			    &quot;%s: TXQ=%d: bf=%p, bfs_tx_queue=%d\n&quot;,</a>
<a name="ln4454">			    __func__,</a>
<a name="ln4455">			    txq-&gt;axq_qnum,</a>
<a name="ln4456">			    bf,</a>
<a name="ln4457">			    bf-&gt;bf_state.bfs_tx_queue);</a>
<a name="ln4458">		}</a>
<a name="ln4459">		if (txq-&gt;axq_qnum != bf-&gt;bf_last-&gt;bf_state.bfs_tx_queue) {</a>
<a name="ln4460">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln4461">			    &quot;%s: TXQ=%d: bf_last=%p, bfs_tx_queue=%d\n&quot;,</a>
<a name="ln4462">			    __func__,</a>
<a name="ln4463">			    txq-&gt;axq_qnum,</a>
<a name="ln4464">			    bf-&gt;bf_last,</a>
<a name="ln4465">			    bf-&gt;bf_last-&gt;bf_state.bfs_tx_queue);</a>
<a name="ln4466">		}</a>
<a name="ln4467"> </a>
<a name="ln4468">#if 0</a>
<a name="ln4469">		if (txq-&gt;axq_depth &gt; 0) {</a>
<a name="ln4470">			/*</a>
<a name="ln4471">			 * More frames follow.  Mark the buffer busy</a>
<a name="ln4472">			 * so it's not re-used while the hardware may</a>
<a name="ln4473">			 * still re-read the link field in the descriptor.</a>
<a name="ln4474">			 *</a>
<a name="ln4475">			 * Use the last buffer in an aggregate as that</a>
<a name="ln4476">			 * is where the hardware may be - intermediate</a>
<a name="ln4477">			 * descriptors won't be &quot;busy&quot;.</a>
<a name="ln4478">			 */</a>
<a name="ln4479">			bf-&gt;bf_last-&gt;bf_flags |= ATH_BUF_BUSY;</a>
<a name="ln4480">		} else</a>
<a name="ln4481">			txq-&gt;axq_link = NULL;</a>
<a name="ln4482">#else</a>
<a name="ln4483">		bf-&gt;bf_last-&gt;bf_flags |= ATH_BUF_BUSY;</a>
<a name="ln4484">#endif</a>
<a name="ln4485">		if (bf-&gt;bf_state.bfs_aggr)</a>
<a name="ln4486">			txq-&gt;axq_aggr_depth--;</a>
<a name="ln4487"> </a>
<a name="ln4488">		ni = bf-&gt;bf_node;</a>
<a name="ln4489"> </a>
<a name="ln4490">		ATH_KTR(sc, ATH_KTR_TXCOMP, 5,</a>
<a name="ln4491">		    &quot;ath_tx_processq: txq=%u, bf=%p, ds=%p, ni=%p, ts_status=0x%08x&quot;,</a>
<a name="ln4492">		    txq-&gt;axq_qnum, bf, ds, ni, ts-&gt;ts_status);</a>
<a name="ln4493">		/*</a>
<a name="ln4494">		 * If unicast frame was ack'd update RSSI,</a>
<a name="ln4495">		 * including the last rx time used to</a>
<a name="ln4496">		 * workaround phantom bmiss interrupts.</a>
<a name="ln4497">		 */</a>
<a name="ln4498">		if (ni != NULL &amp;&amp; ts-&gt;ts_status == 0 &amp;&amp;</a>
<a name="ln4499">		    ((bf-&gt;bf_state.bfs_txflags &amp; HAL_TXDESC_NOACK) == 0)) {</a>
<a name="ln4500">			nacked++;</a>
<a name="ln4501">			sc-&gt;sc_stats.ast_tx_rssi = ts-&gt;ts_rssi;</a>
<a name="ln4502">			ATH_RSSI_LPF(sc-&gt;sc_halstats.ns_avgtxrssi,</a>
<a name="ln4503">				ts-&gt;ts_rssi);</a>
<a name="ln4504">		}</a>
<a name="ln4505">		ATH_TXQ_UNLOCK(txq);</a>
<a name="ln4506"> </a>
<a name="ln4507">		/*</a>
<a name="ln4508">		 * Update statistics and call completion</a>
<a name="ln4509">		 */</a>
<a name="ln4510">		ath_tx_process_buf_completion(sc, txq, ts, bf);</a>
<a name="ln4511"> </a>
<a name="ln4512">		/* XXX at this point, bf and ni may be totally invalid */</a>
<a name="ln4513">	}</a>
<a name="ln4514">#ifdef IEEE80211_SUPPORT_SUPERG</a>
<a name="ln4515">	/*</a>
<a name="ln4516">	 * Flush fast-frame staging queue when traffic slows.</a>
<a name="ln4517">	 */</a>
<a name="ln4518">	if (txq-&gt;axq_depth &lt;= 1)</a>
<a name="ln4519">		ieee80211_ff_flush(ic, txq-&gt;axq_ac);</a>
<a name="ln4520">#endif</a>
<a name="ln4521"> </a>
<a name="ln4522">	/* Kick the software TXQ scheduler */</a>
<a name="ln4523">	if (dosched) {</a>
<a name="ln4524">		ATH_TX_LOCK(sc);</a>
<a name="ln4525">		ath_txq_sched(sc, txq);</a>
<a name="ln4526">		ATH_TX_UNLOCK(sc);</a>
<a name="ln4527">	}</a>
<a name="ln4528"> </a>
<a name="ln4529">	ATH_KTR(sc, ATH_KTR_TXCOMP, 1,</a>
<a name="ln4530">	    &quot;ath_tx_processq: txq=%u: done&quot;,</a>
<a name="ln4531">	    txq-&gt;axq_qnum);</a>
<a name="ln4532"> </a>
<a name="ln4533">	return nacked;</a>
<a name="ln4534">}</a>
<a name="ln4535"> </a>
<a name="ln4536">#define	TXQACTIVE(t, q)		( (t) &amp; (1 &lt;&lt; (q)))</a>
<a name="ln4537"> </a>
<a name="ln4538">/*</a>
<a name="ln4539"> * Deferred processing of transmit interrupt; special-cased</a>
<a name="ln4540"> * for a single hardware transmit queue (e.g. 5210 and 5211).</a>
<a name="ln4541"> */</a>
<a name="ln4542">static void</a>
<a name="ln4543">ath_tx_proc_q0(void *arg, int npending)</a>
<a name="ln4544">{</a>
<a name="ln4545">	struct ath_softc *sc = arg;</a>
<a name="ln4546">	uint32_t txqs;</a>
<a name="ln4547"> </a>
<a name="ln4548">	ATH_PCU_LOCK(sc);</a>
<a name="ln4549">	sc-&gt;sc_txproc_cnt++;</a>
<a name="ln4550">	txqs = sc-&gt;sc_txq_active;</a>
<a name="ln4551">	sc-&gt;sc_txq_active &amp;= ~txqs;</a>
<a name="ln4552">	ATH_PCU_UNLOCK(sc);</a>
<a name="ln4553"> </a>
<a name="ln4554">	ATH_LOCK(sc);</a>
<a name="ln4555">	ath_power_set_power_state(sc, HAL_PM_AWAKE);</a>
<a name="ln4556">	ATH_UNLOCK(sc);</a>
<a name="ln4557"> </a>
<a name="ln4558">	ATH_KTR(sc, ATH_KTR_TXCOMP, 1,</a>
<a name="ln4559">	    &quot;ath_tx_proc_q0: txqs=0x%08x&quot;, txqs);</a>
<a name="ln4560"> </a>
<a name="ln4561">	if (TXQACTIVE(txqs, 0) &amp;&amp; ath_tx_processq(sc, &amp;sc-&gt;sc_txq[0], 1))</a>
<a name="ln4562">		/* XXX why is lastrx updated in tx code? */</a>
<a name="ln4563">		sc-&gt;sc_lastrx = ath_hal_gettsf64(sc-&gt;sc_ah);</a>
<a name="ln4564">	if (TXQACTIVE(txqs, sc-&gt;sc_cabq-&gt;axq_qnum))</a>
<a name="ln4565">		ath_tx_processq(sc, sc-&gt;sc_cabq, 1);</a>
<a name="ln4566">	sc-&gt;sc_wd_timer = 0;</a>
<a name="ln4567"> </a>
<a name="ln4568">	if (sc-&gt;sc_softled)</a>
<a name="ln4569">		ath_led_event(sc, sc-&gt;sc_txrix);</a>
<a name="ln4570"> </a>
<a name="ln4571">	ATH_PCU_LOCK(sc);</a>
<a name="ln4572">	sc-&gt;sc_txproc_cnt--;</a>
<a name="ln4573">	ATH_PCU_UNLOCK(sc);</a>
<a name="ln4574"> </a>
<a name="ln4575">	ATH_LOCK(sc);</a>
<a name="ln4576">	ath_power_restore_power_state(sc);</a>
<a name="ln4577">	ATH_UNLOCK(sc);</a>
<a name="ln4578"> </a>
<a name="ln4579">	ath_tx_kick(sc);</a>
<a name="ln4580">}</a>
<a name="ln4581"> </a>
<a name="ln4582">/*</a>
<a name="ln4583"> * Deferred processing of transmit interrupt; special-cased</a>
<a name="ln4584"> * for four hardware queues, 0-3 (e.g. 5212 w/ WME support).</a>
<a name="ln4585"> */</a>
<a name="ln4586">static void</a>
<a name="ln4587">ath_tx_proc_q0123(void *arg, int npending)</a>
<a name="ln4588">{</a>
<a name="ln4589">	struct ath_softc *sc = arg;</a>
<a name="ln4590">	int nacked;</a>
<a name="ln4591">	uint32_t txqs;</a>
<a name="ln4592"> </a>
<a name="ln4593">	ATH_PCU_LOCK(sc);</a>
<a name="ln4594">	sc-&gt;sc_txproc_cnt++;</a>
<a name="ln4595">	txqs = sc-&gt;sc_txq_active;</a>
<a name="ln4596">	sc-&gt;sc_txq_active &amp;= ~txqs;</a>
<a name="ln4597">	ATH_PCU_UNLOCK(sc);</a>
<a name="ln4598"> </a>
<a name="ln4599">	ATH_LOCK(sc);</a>
<a name="ln4600">	ath_power_set_power_state(sc, HAL_PM_AWAKE);</a>
<a name="ln4601">	ATH_UNLOCK(sc);</a>
<a name="ln4602"> </a>
<a name="ln4603">	ATH_KTR(sc, ATH_KTR_TXCOMP, 1,</a>
<a name="ln4604">	    &quot;ath_tx_proc_q0123: txqs=0x%08x&quot;, txqs);</a>
<a name="ln4605"> </a>
<a name="ln4606">	/*</a>
<a name="ln4607">	 * Process each active queue.</a>
<a name="ln4608">	 */</a>
<a name="ln4609">	nacked = 0;</a>
<a name="ln4610">	if (TXQACTIVE(txqs, 0))</a>
<a name="ln4611">		nacked += ath_tx_processq(sc, &amp;sc-&gt;sc_txq[0], 1);</a>
<a name="ln4612">	if (TXQACTIVE(txqs, 1))</a>
<a name="ln4613">		nacked += ath_tx_processq(sc, &amp;sc-&gt;sc_txq[1], 1);</a>
<a name="ln4614">	if (TXQACTIVE(txqs, 2))</a>
<a name="ln4615">		nacked += ath_tx_processq(sc, &amp;sc-&gt;sc_txq[2], 1);</a>
<a name="ln4616">	if (TXQACTIVE(txqs, 3))</a>
<a name="ln4617">		nacked += ath_tx_processq(sc, &amp;sc-&gt;sc_txq[3], 1);</a>
<a name="ln4618">	if (TXQACTIVE(txqs, sc-&gt;sc_cabq-&gt;axq_qnum))</a>
<a name="ln4619">		ath_tx_processq(sc, sc-&gt;sc_cabq, 1);</a>
<a name="ln4620">	if (nacked)</a>
<a name="ln4621">		sc-&gt;sc_lastrx = ath_hal_gettsf64(sc-&gt;sc_ah);</a>
<a name="ln4622"> </a>
<a name="ln4623">	sc-&gt;sc_wd_timer = 0;</a>
<a name="ln4624"> </a>
<a name="ln4625">	if (sc-&gt;sc_softled)</a>
<a name="ln4626">		ath_led_event(sc, sc-&gt;sc_txrix);</a>
<a name="ln4627"> </a>
<a name="ln4628">	ATH_PCU_LOCK(sc);</a>
<a name="ln4629">	sc-&gt;sc_txproc_cnt--;</a>
<a name="ln4630">	ATH_PCU_UNLOCK(sc);</a>
<a name="ln4631"> </a>
<a name="ln4632">	ATH_LOCK(sc);</a>
<a name="ln4633">	ath_power_restore_power_state(sc);</a>
<a name="ln4634">	ATH_UNLOCK(sc);</a>
<a name="ln4635"> </a>
<a name="ln4636">	ath_tx_kick(sc);</a>
<a name="ln4637">}</a>
<a name="ln4638"> </a>
<a name="ln4639">/*</a>
<a name="ln4640"> * Deferred processing of transmit interrupt.</a>
<a name="ln4641"> */</a>
<a name="ln4642">static void</a>
<a name="ln4643">ath_tx_proc(void *arg, int npending)</a>
<a name="ln4644">{</a>
<a name="ln4645">	struct ath_softc *sc = arg;</a>
<a name="ln4646">	int i, nacked;</a>
<a name="ln4647">	uint32_t txqs;</a>
<a name="ln4648"> </a>
<a name="ln4649">	ATH_PCU_LOCK(sc);</a>
<a name="ln4650">	sc-&gt;sc_txproc_cnt++;</a>
<a name="ln4651">	txqs = sc-&gt;sc_txq_active;</a>
<a name="ln4652">	sc-&gt;sc_txq_active &amp;= ~txqs;</a>
<a name="ln4653">	ATH_PCU_UNLOCK(sc);</a>
<a name="ln4654"> </a>
<a name="ln4655">	ATH_LOCK(sc);</a>
<a name="ln4656">	ath_power_set_power_state(sc, HAL_PM_AWAKE);</a>
<a name="ln4657">	ATH_UNLOCK(sc);</a>
<a name="ln4658"> </a>
<a name="ln4659">	ATH_KTR(sc, ATH_KTR_TXCOMP, 1, &quot;ath_tx_proc: txqs=0x%08x&quot;, txqs);</a>
<a name="ln4660"> </a>
<a name="ln4661">	/*</a>
<a name="ln4662">	 * Process each active queue.</a>
<a name="ln4663">	 */</a>
<a name="ln4664">	nacked = 0;</a>
<a name="ln4665">	for (i = 0; i &lt; HAL_NUM_TX_QUEUES; i++)</a>
<a name="ln4666">		if (ATH_TXQ_SETUP(sc, i) &amp;&amp; TXQACTIVE(txqs, i))</a>
<a name="ln4667">			nacked += ath_tx_processq(sc, &amp;sc-&gt;sc_txq[i], 1);</a>
<a name="ln4668">	if (nacked)</a>
<a name="ln4669">		sc-&gt;sc_lastrx = ath_hal_gettsf64(sc-&gt;sc_ah);</a>
<a name="ln4670"> </a>
<a name="ln4671">	sc-&gt;sc_wd_timer = 0;</a>
<a name="ln4672"> </a>
<a name="ln4673">	if (sc-&gt;sc_softled)</a>
<a name="ln4674">		ath_led_event(sc, sc-&gt;sc_txrix);</a>
<a name="ln4675"> </a>
<a name="ln4676">	ATH_PCU_LOCK(sc);</a>
<a name="ln4677">	sc-&gt;sc_txproc_cnt--;</a>
<a name="ln4678">	ATH_PCU_UNLOCK(sc);</a>
<a name="ln4679"> </a>
<a name="ln4680">	ATH_LOCK(sc);</a>
<a name="ln4681">	ath_power_restore_power_state(sc);</a>
<a name="ln4682">	ATH_UNLOCK(sc);</a>
<a name="ln4683"> </a>
<a name="ln4684">	ath_tx_kick(sc);</a>
<a name="ln4685">}</a>
<a name="ln4686">#undef	TXQACTIVE</a>
<a name="ln4687"> </a>
<a name="ln4688">/*</a>
<a name="ln4689"> * Deferred processing of TXQ rescheduling.</a>
<a name="ln4690"> */</a>
<a name="ln4691">static void</a>
<a name="ln4692">ath_txq_sched_tasklet(void *arg, int npending)</a>
<a name="ln4693">{</a>
<a name="ln4694">	struct ath_softc *sc = arg;</a>
<a name="ln4695">	int i;</a>
<a name="ln4696"> </a>
<a name="ln4697">	/* XXX is skipping ok? */</a>
<a name="ln4698">	ATH_PCU_LOCK(sc);</a>
<a name="ln4699">#if 0</a>
<a name="ln4700">	if (sc-&gt;sc_inreset_cnt &gt; 0) {</a>
<a name="ln4701">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln4702">		    &quot;%s: sc_inreset_cnt &gt; 0; skipping\n&quot;, __func__);</a>
<a name="ln4703">		ATH_PCU_UNLOCK(sc);</a>
<a name="ln4704">		return;</a>
<a name="ln4705">	}</a>
<a name="ln4706">#endif</a>
<a name="ln4707">	sc-&gt;sc_txproc_cnt++;</a>
<a name="ln4708">	ATH_PCU_UNLOCK(sc);</a>
<a name="ln4709"> </a>
<a name="ln4710">	ATH_LOCK(sc);</a>
<a name="ln4711">	ath_power_set_power_state(sc, HAL_PM_AWAKE);</a>
<a name="ln4712">	ATH_UNLOCK(sc);</a>
<a name="ln4713"> </a>
<a name="ln4714">	ATH_TX_LOCK(sc);</a>
<a name="ln4715">	for (i = 0; i &lt; HAL_NUM_TX_QUEUES; i++) {</a>
<a name="ln4716">		if (ATH_TXQ_SETUP(sc, i)) {</a>
<a name="ln4717">			ath_txq_sched(sc, &amp;sc-&gt;sc_txq[i]);</a>
<a name="ln4718">		}</a>
<a name="ln4719">	}</a>
<a name="ln4720">	ATH_TX_UNLOCK(sc);</a>
<a name="ln4721"> </a>
<a name="ln4722">	ATH_LOCK(sc);</a>
<a name="ln4723">	ath_power_restore_power_state(sc);</a>
<a name="ln4724">	ATH_UNLOCK(sc);</a>
<a name="ln4725"> </a>
<a name="ln4726">	ATH_PCU_LOCK(sc);</a>
<a name="ln4727">	sc-&gt;sc_txproc_cnt--;</a>
<a name="ln4728">	ATH_PCU_UNLOCK(sc);</a>
<a name="ln4729">}</a>
<a name="ln4730"> </a>
<a name="ln4731">void</a>
<a name="ln4732">ath_returnbuf_tail(struct ath_softc *sc, struct ath_buf *bf)</a>
<a name="ln4733">{</a>
<a name="ln4734"> </a>
<a name="ln4735">	ATH_TXBUF_LOCK_ASSERT(sc);</a>
<a name="ln4736"> </a>
<a name="ln4737">	if (bf-&gt;bf_flags &amp; ATH_BUF_MGMT)</a>
<a name="ln4738">		TAILQ_INSERT_TAIL(&amp;sc-&gt;sc_txbuf_mgmt, bf, bf_list);</a>
<a name="ln4739">	else {</a>
<a name="ln4740">		TAILQ_INSERT_TAIL(&amp;sc-&gt;sc_txbuf, bf, bf_list);</a>
<a name="ln4741">		sc-&gt;sc_txbuf_cnt++;</a>
<a name="ln4742">		if (sc-&gt;sc_txbuf_cnt &gt; ath_txbuf) {</a>
<a name="ln4743">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln4744">			    &quot;%s: sc_txbuf_cnt &gt; %d?\n&quot;,</a>
<a name="ln4745">			    __func__,</a>
<a name="ln4746">			    ath_txbuf);</a>
<a name="ln4747">			sc-&gt;sc_txbuf_cnt = ath_txbuf;</a>
<a name="ln4748">		}</a>
<a name="ln4749">	}</a>
<a name="ln4750">}</a>
<a name="ln4751"> </a>
<a name="ln4752">void</a>
<a name="ln4753">ath_returnbuf_head(struct ath_softc *sc, struct ath_buf *bf)</a>
<a name="ln4754">{</a>
<a name="ln4755"> </a>
<a name="ln4756">	ATH_TXBUF_LOCK_ASSERT(sc);</a>
<a name="ln4757"> </a>
<a name="ln4758">	if (bf-&gt;bf_flags &amp; ATH_BUF_MGMT)</a>
<a name="ln4759">		TAILQ_INSERT_HEAD(&amp;sc-&gt;sc_txbuf_mgmt, bf, bf_list);</a>
<a name="ln4760">	else {</a>
<a name="ln4761">		TAILQ_INSERT_HEAD(&amp;sc-&gt;sc_txbuf, bf, bf_list);</a>
<a name="ln4762">		sc-&gt;sc_txbuf_cnt++;</a>
<a name="ln4763">		if (sc-&gt;sc_txbuf_cnt &gt; ATH_TXBUF) {</a>
<a name="ln4764">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln4765">			    &quot;%s: sc_txbuf_cnt &gt; %d?\n&quot;,</a>
<a name="ln4766">			    __func__,</a>
<a name="ln4767">			    ATH_TXBUF);</a>
<a name="ln4768">			sc-&gt;sc_txbuf_cnt = ATH_TXBUF;</a>
<a name="ln4769">		}</a>
<a name="ln4770">	}</a>
<a name="ln4771">}</a>
<a name="ln4772"> </a>
<a name="ln4773">/*</a>
<a name="ln4774"> * Free the holding buffer if it exists</a>
<a name="ln4775"> */</a>
<a name="ln4776">void</a>
<a name="ln4777">ath_txq_freeholdingbuf(struct ath_softc *sc, struct ath_txq *txq)</a>
<a name="ln4778">{</a>
<a name="ln4779">	ATH_TXBUF_UNLOCK_ASSERT(sc);</a>
<a name="ln4780">	ATH_TXQ_LOCK_ASSERT(txq);</a>
<a name="ln4781"> </a>
<a name="ln4782">	if (txq-&gt;axq_holdingbf == NULL)</a>
<a name="ln4783">		return;</a>
<a name="ln4784"> </a>
<a name="ln4785">	txq-&gt;axq_holdingbf-&gt;bf_flags &amp;= ~ATH_BUF_BUSY;</a>
<a name="ln4786"> </a>
<a name="ln4787">	ATH_TXBUF_LOCK(sc);</a>
<a name="ln4788">	ath_returnbuf_tail(sc, txq-&gt;axq_holdingbf);</a>
<a name="ln4789">	ATH_TXBUF_UNLOCK(sc);</a>
<a name="ln4790"> </a>
<a name="ln4791">	txq-&gt;axq_holdingbf = NULL;</a>
<a name="ln4792">}</a>
<a name="ln4793"> </a>
<a name="ln4794">/*</a>
<a name="ln4795"> * Add this buffer to the holding queue, freeing the previous</a>
<a name="ln4796"> * one if it exists.</a>
<a name="ln4797"> */</a>
<a name="ln4798">static void</a>
<a name="ln4799">ath_txq_addholdingbuf(struct ath_softc *sc, struct ath_buf *bf)</a>
<a name="ln4800">{</a>
<a name="ln4801">	struct ath_txq *txq;</a>
<a name="ln4802"> </a>
<a name="ln4803">	txq = &amp;sc-&gt;sc_txq[bf-&gt;bf_state.bfs_tx_queue];</a>
<a name="ln4804"> </a>
<a name="ln4805">	ATH_TXBUF_UNLOCK_ASSERT(sc);</a>
<a name="ln4806">	ATH_TXQ_LOCK_ASSERT(txq);</a>
<a name="ln4807"> </a>
<a name="ln4808">	/* XXX assert ATH_BUF_BUSY is set */</a>
<a name="ln4809"> </a>
<a name="ln4810">	/* XXX assert the tx queue is under the max number */</a>
<a name="ln4811">	if (bf-&gt;bf_state.bfs_tx_queue &gt; HAL_NUM_TX_QUEUES) {</a>
<a name="ln4812">		device_printf(sc-&gt;sc_dev, &quot;%s: bf=%p: invalid tx queue (%d)\n&quot;,</a>
<a name="ln4813">		    __func__,</a>
<a name="ln4814">		    bf,</a>
<a name="ln4815">		    bf-&gt;bf_state.bfs_tx_queue);</a>
<a name="ln4816">		bf-&gt;bf_flags &amp;= ~ATH_BUF_BUSY;</a>
<a name="ln4817">		ath_returnbuf_tail(sc, bf);</a>
<a name="ln4818">		return;</a>
<a name="ln4819">	}</a>
<a name="ln4820">	ath_txq_freeholdingbuf(sc, txq);</a>
<a name="ln4821">	txq-&gt;axq_holdingbf = bf;</a>
<a name="ln4822">}</a>
<a name="ln4823"> </a>
<a name="ln4824">/*</a>
<a name="ln4825"> * Return a buffer to the pool and update the 'busy' flag on the</a>
<a name="ln4826"> * previous 'tail' entry.</a>
<a name="ln4827"> *</a>
<a name="ln4828"> * This _must_ only be called when the buffer is involved in a completed</a>
<a name="ln4829"> * TX. The logic is that if it was part of an active TX, the previous</a>
<a name="ln4830"> * buffer on the list is now not involved in a halted TX DMA queue, waiting</a>
<a name="ln4831"> * for restart (eg for TDMA.)</a>
<a name="ln4832"> *</a>
<a name="ln4833"> * The caller must free the mbuf and recycle the node reference.</a>
<a name="ln4834"> *</a>
<a name="ln4835"> * XXX This method of handling busy / holding buffers is insanely stupid.</a>
<a name="ln4836"> * It requires bf_state.bfs_tx_queue to be correctly assigned.  It would</a>
<a name="ln4837"> * be much nicer if buffers in the processq() methods would instead be</a>
<a name="ln4838"> * always completed there (pushed onto a txq or ath_bufhead) so we knew</a>
<a name="ln4839"> * exactly what hardware queue they came from in the first place.</a>
<a name="ln4840"> */</a>
<a name="ln4841">void</a>
<a name="ln4842">ath_freebuf(struct ath_softc *sc, struct ath_buf *bf)</a>
<a name="ln4843">{</a>
<a name="ln4844">	struct ath_txq *txq;</a>
<a name="ln4845"> </a>
<a name="ln4846">	txq = &amp;sc-&gt;sc_txq[bf-&gt;bf_state.bfs_tx_queue];</a>
<a name="ln4847"> </a>
<a name="ln4848">	KASSERT((bf-&gt;bf_node == NULL), (&quot;%s: bf-&gt;bf_node != NULL\n&quot;, __func__));</a>
<a name="ln4849">	KASSERT((bf-&gt;bf_m == NULL), (&quot;%s: bf-&gt;bf_m != NULL\n&quot;, __func__));</a>
<a name="ln4850"> </a>
<a name="ln4851">	/*</a>
<a name="ln4852">	 * If this buffer is busy, push it onto the holding queue.</a>
<a name="ln4853">	 */</a>
<a name="ln4854">	if (bf-&gt;bf_flags &amp; ATH_BUF_BUSY) {</a>
<a name="ln4855">		ATH_TXQ_LOCK(txq);</a>
<a name="ln4856">		ath_txq_addholdingbuf(sc, bf);</a>
<a name="ln4857">		ATH_TXQ_UNLOCK(txq);</a>
<a name="ln4858">		return;</a>
<a name="ln4859">	}</a>
<a name="ln4860"> </a>
<a name="ln4861">	/*</a>
<a name="ln4862">	 * Not a busy buffer, so free normally</a>
<a name="ln4863">	 */</a>
<a name="ln4864">	ATH_TXBUF_LOCK(sc);</a>
<a name="ln4865">	ath_returnbuf_tail(sc, bf);</a>
<a name="ln4866">	ATH_TXBUF_UNLOCK(sc);</a>
<a name="ln4867">}</a>
<a name="ln4868"> </a>
<a name="ln4869">/*</a>
<a name="ln4870"> * This is currently used by ath_tx_draintxq() and</a>
<a name="ln4871"> * ath_tx_tid_free_pkts().</a>
<a name="ln4872"> *</a>
<a name="ln4873"> * It recycles a single ath_buf.</a>
<a name="ln4874"> */</a>
<a name="ln4875">void</a>
<a name="ln4876">ath_tx_freebuf(struct ath_softc *sc, struct ath_buf *bf, int status)</a>
<a name="ln4877">{</a>
<a name="ln4878">	struct ieee80211_node *ni = bf-&gt;bf_node;</a>
<a name="ln4879">	struct mbuf *m0 = bf-&gt;bf_m;</a>
<a name="ln4880"> </a>
<a name="ln4881">	/*</a>
<a name="ln4882">	 * Make sure that we only sync/unload if there's an mbuf.</a>
<a name="ln4883">	 * If not (eg we cloned a buffer), the unload will have already</a>
<a name="ln4884">	 * occurred.</a>
<a name="ln4885">	 */</a>
<a name="ln4886">	if (bf-&gt;bf_m != NULL) {</a>
<a name="ln4887">		bus_dmamap_sync(sc-&gt;sc_dmat, bf-&gt;bf_dmamap,</a>
<a name="ln4888">		    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln4889">		bus_dmamap_unload(sc-&gt;sc_dmat, bf-&gt;bf_dmamap);</a>
<a name="ln4890">	}</a>
<a name="ln4891"> </a>
<a name="ln4892">	bf-&gt;bf_node = NULL;</a>
<a name="ln4893">	bf-&gt;bf_m = NULL;</a>
<a name="ln4894"> </a>
<a name="ln4895">	/* Free the buffer, it's not needed any longer */</a>
<a name="ln4896">	ath_freebuf(sc, bf);</a>
<a name="ln4897"> </a>
<a name="ln4898">	/* Pass the buffer back to net80211 - completing it */</a>
<a name="ln4899">	ieee80211_tx_complete(ni, m0, status);</a>
<a name="ln4900">}</a>
<a name="ln4901"> </a>
<a name="ln4902">static struct ath_buf *</a>
<a name="ln4903">ath_tx_draintxq_get_one(struct ath_softc *sc, struct ath_txq *txq)</a>
<a name="ln4904">{</a>
<a name="ln4905">	struct ath_buf *bf;</a>
<a name="ln4906"> </a>
<a name="ln4907">	ATH_TXQ_LOCK_ASSERT(txq);</a>
<a name="ln4908"> </a>
<a name="ln4909">	/*</a>
<a name="ln4910">	 * Drain the FIFO queue first, then if it's</a>
<a name="ln4911">	 * empty, move to the normal frame queue.</a>
<a name="ln4912">	 */</a>
<a name="ln4913">	bf = TAILQ_FIRST(&amp;txq-&gt;fifo.axq_q);</a>
<a name="ln4914">	if (bf != NULL) {</a>
<a name="ln4915">		/*</a>
<a name="ln4916">		 * Is it the last buffer in this set?</a>
<a name="ln4917">		 * Decrement the FIFO counter.</a>
<a name="ln4918">		 */</a>
<a name="ln4919">		if (bf-&gt;bf_flags &amp; ATH_BUF_FIFOEND) {</a>
<a name="ln4920">			if (txq-&gt;axq_fifo_depth == 0) {</a>
<a name="ln4921">				device_printf(sc-&gt;sc_dev,</a>
<a name="ln4922">				    &quot;%s: Q%d: fifo_depth=0, fifo.axq_depth=%d?\n&quot;,</a>
<a name="ln4923">				    __func__,</a>
<a name="ln4924">				    txq-&gt;axq_qnum,</a>
<a name="ln4925">				    txq-&gt;fifo.axq_depth);</a>
<a name="ln4926">			} else</a>
<a name="ln4927">				txq-&gt;axq_fifo_depth--;</a>
<a name="ln4928">		}</a>
<a name="ln4929">		ATH_TXQ_REMOVE(&amp;txq-&gt;fifo, bf, bf_list);</a>
<a name="ln4930">		return (bf);</a>
<a name="ln4931">	}</a>
<a name="ln4932"> </a>
<a name="ln4933">	/*</a>
<a name="ln4934">	 * Debugging!</a>
<a name="ln4935">	 */</a>
<a name="ln4936">	if (txq-&gt;axq_fifo_depth != 0 || txq-&gt;fifo.axq_depth != 0) {</a>
<a name="ln4937">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln4938">		    &quot;%s: Q%d: fifo_depth=%d, fifo.axq_depth=%d\n&quot;,</a>
<a name="ln4939">		    __func__,</a>
<a name="ln4940">		    txq-&gt;axq_qnum,</a>
<a name="ln4941">		    txq-&gt;axq_fifo_depth,</a>
<a name="ln4942">		    txq-&gt;fifo.axq_depth);</a>
<a name="ln4943">	}</a>
<a name="ln4944"> </a>
<a name="ln4945">	/*</a>
<a name="ln4946">	 * Now drain the pending queue.</a>
<a name="ln4947">	 */</a>
<a name="ln4948">	bf = TAILQ_FIRST(&amp;txq-&gt;axq_q);</a>
<a name="ln4949">	if (bf == NULL) {</a>
<a name="ln4950">		txq-&gt;axq_link = NULL;</a>
<a name="ln4951">		return (NULL);</a>
<a name="ln4952">	}</a>
<a name="ln4953">	ATH_TXQ_REMOVE(txq, bf, bf_list);</a>
<a name="ln4954">	return (bf);</a>
<a name="ln4955">}</a>
<a name="ln4956"> </a>
<a name="ln4957">void</a>
<a name="ln4958">ath_tx_draintxq(struct ath_softc *sc, struct ath_txq *txq)</a>
<a name="ln4959">{</a>
<a name="ln4960">#ifdef ATH_DEBUG</a>
<a name="ln4961">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln4962">#endif</a>
<a name="ln4963">	struct ath_buf *bf;</a>
<a name="ln4964">	u_int ix;</a>
<a name="ln4965"> </a>
<a name="ln4966">	/*</a>
<a name="ln4967">	 * NB: this assumes output has been stopped and</a>
<a name="ln4968">	 *     we do not need to block ath_tx_proc</a>
<a name="ln4969">	 */</a>
<a name="ln4970">	for (ix = 0;; ix++) {</a>
<a name="ln4971">		ATH_TXQ_LOCK(txq);</a>
<a name="ln4972">		bf = ath_tx_draintxq_get_one(sc, txq);</a>
<a name="ln4973">		if (bf == NULL) {</a>
<a name="ln4974">			ATH_TXQ_UNLOCK(txq);</a>
<a name="ln4975">			break;</a>
<a name="ln4976">		}</a>
<a name="ln4977">		if (bf-&gt;bf_state.bfs_aggr)</a>
<a name="ln4978">			txq-&gt;axq_aggr_depth--;</a>
<a name="ln4979">#ifdef ATH_DEBUG</a>
<a name="ln4980">		if (sc-&gt;sc_debug &amp; ATH_DEBUG_RESET) {</a>
<a name="ln4981">			struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln4982">			int status = 0;</a>
<a name="ln4983"> </a>
<a name="ln4984">			/*</a>
<a name="ln4985">			 * EDMA operation has a TX completion FIFO</a>
<a name="ln4986">			 * separate from the TX descriptor, so this</a>
<a name="ln4987">			 * method of checking the &quot;completion&quot; status</a>
<a name="ln4988">			 * is wrong.</a>
<a name="ln4989">			 */</a>
<a name="ln4990">			if (! sc-&gt;sc_isedma) {</a>
<a name="ln4991">				status = (ath_hal_txprocdesc(ah,</a>
<a name="ln4992">				    bf-&gt;bf_lastds,</a>
<a name="ln4993">				    &amp;bf-&gt;bf_status.ds_txstat) == HAL_OK);</a>
<a name="ln4994">			}</a>
<a name="ln4995">			ath_printtxbuf(sc, bf, txq-&gt;axq_qnum, ix, status);</a>
<a name="ln4996">			ieee80211_dump_pkt(ic, mtod(bf-&gt;bf_m, const uint8_t *),</a>
<a name="ln4997">			    bf-&gt;bf_m-&gt;m_len, 0, -1);</a>
<a name="ln4998">		}</a>
<a name="ln4999">#endif /* ATH_DEBUG */</a>
<a name="ln5000">		/*</a>
<a name="ln5001">		 * Since we're now doing magic in the completion</a>
<a name="ln5002">		 * functions, we -must- call it for aggregation</a>
<a name="ln5003">		 * destinations or BAW tracking will get upset.</a>
<a name="ln5004">		 */</a>
<a name="ln5005">		/*</a>
<a name="ln5006">		 * Clear ATH_BUF_BUSY; the completion handler</a>
<a name="ln5007">		 * will free the buffer.</a>
<a name="ln5008">		 */</a>
<a name="ln5009">		ATH_TXQ_UNLOCK(txq);</a>
<a name="ln5010">		bf-&gt;bf_flags &amp;= ~ATH_BUF_BUSY;</a>
<a name="ln5011">		if (bf-&gt;bf_comp)</a>
<a name="ln5012">			bf-&gt;bf_comp(sc, bf, 1);</a>
<a name="ln5013">		else</a>
<a name="ln5014">			ath_tx_default_comp(sc, bf, 1);</a>
<a name="ln5015">	}</a>
<a name="ln5016"> </a>
<a name="ln5017">	/*</a>
<a name="ln5018">	 * Free the holding buffer if it exists</a>
<a name="ln5019">	 */</a>
<a name="ln5020">	ATH_TXQ_LOCK(txq);</a>
<a name="ln5021">	ath_txq_freeholdingbuf(sc, txq);</a>
<a name="ln5022">	ATH_TXQ_UNLOCK(txq);</a>
<a name="ln5023"> </a>
<a name="ln5024">	/*</a>
<a name="ln5025">	 * Drain software queued frames which are on</a>
<a name="ln5026">	 * active TIDs.</a>
<a name="ln5027">	 */</a>
<a name="ln5028">	ath_tx_txq_drain(sc, txq);</a>
<a name="ln5029">}</a>
<a name="ln5030"> </a>
<a name="ln5031">static void</a>
<a name="ln5032">ath_tx_stopdma(struct ath_softc *sc, struct ath_txq *txq)</a>
<a name="ln5033">{</a>
<a name="ln5034">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln5035"> </a>
<a name="ln5036">	ATH_TXQ_LOCK_ASSERT(txq);</a>
<a name="ln5037"> </a>
<a name="ln5038">	DPRINTF(sc, ATH_DEBUG_RESET,</a>
<a name="ln5039">	    &quot;%s: tx queue [%u] %p, active=%d, hwpending=%d, flags 0x%08x, &quot;</a>
<a name="ln5040">	    &quot;link %p, holdingbf=%p\n&quot;,</a>
<a name="ln5041">	    __func__,</a>
<a name="ln5042">	    txq-&gt;axq_qnum,</a>
<a name="ln5043">	    (caddr_t)(uintptr_t) ath_hal_gettxbuf(ah, txq-&gt;axq_qnum),</a>
<a name="ln5044">	    (int) (!! ath_hal_txqenabled(ah, txq-&gt;axq_qnum)),</a>
<a name="ln5045">	    (int) ath_hal_numtxpending(ah, txq-&gt;axq_qnum),</a>
<a name="ln5046">	    txq-&gt;axq_flags,</a>
<a name="ln5047">	    txq-&gt;axq_link,</a>
<a name="ln5048">	    txq-&gt;axq_holdingbf);</a>
<a name="ln5049"> </a>
<a name="ln5050">	(void) ath_hal_stoptxdma(ah, txq-&gt;axq_qnum);</a>
<a name="ln5051">	/* We've stopped TX DMA, so mark this as stopped. */</a>
<a name="ln5052">	txq-&gt;axq_flags &amp;= ~ATH_TXQ_PUTRUNNING;</a>
<a name="ln5053"> </a>
<a name="ln5054">#ifdef	ATH_DEBUG</a>
<a name="ln5055">	if ((sc-&gt;sc_debug &amp; ATH_DEBUG_RESET)</a>
<a name="ln5056">	    &amp;&amp; (txq-&gt;axq_holdingbf != NULL)) {</a>
<a name="ln5057">		ath_printtxbuf(sc, txq-&gt;axq_holdingbf, txq-&gt;axq_qnum, 0, 0);</a>
<a name="ln5058">	}</a>
<a name="ln5059">#endif</a>
<a name="ln5060">}</a>
<a name="ln5061"> </a>
<a name="ln5062">int</a>
<a name="ln5063">ath_stoptxdma(struct ath_softc *sc)</a>
<a name="ln5064">{</a>
<a name="ln5065">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln5066">	int i;</a>
<a name="ln5067"> </a>
<a name="ln5068">	/* XXX return value */</a>
<a name="ln5069">	if (sc-&gt;sc_invalid)</a>
<a name="ln5070">		return 0;</a>
<a name="ln5071"> </a>
<a name="ln5072">	if (!sc-&gt;sc_invalid) {</a>
<a name="ln5073">		/* don't touch the hardware if marked invalid */</a>
<a name="ln5074">		DPRINTF(sc, ATH_DEBUG_RESET, &quot;%s: tx queue [%u] %p, link %p\n&quot;,</a>
<a name="ln5075">		    __func__, sc-&gt;sc_bhalq,</a>
<a name="ln5076">		    (caddr_t)(uintptr_t) ath_hal_gettxbuf(ah, sc-&gt;sc_bhalq),</a>
<a name="ln5077">		    NULL);</a>
<a name="ln5078"> </a>
<a name="ln5079">		/* stop the beacon queue */</a>
<a name="ln5080">		(void) ath_hal_stoptxdma(ah, sc-&gt;sc_bhalq);</a>
<a name="ln5081"> </a>
<a name="ln5082">		/* Stop the data queues */</a>
<a name="ln5083">		for (i = 0; i &lt; HAL_NUM_TX_QUEUES; i++) {</a>
<a name="ln5084">			if (ATH_TXQ_SETUP(sc, i)) {</a>
<a name="ln5085">				ATH_TXQ_LOCK(&amp;sc-&gt;sc_txq[i]);</a>
<a name="ln5086">				ath_tx_stopdma(sc, &amp;sc-&gt;sc_txq[i]);</a>
<a name="ln5087">				ATH_TXQ_UNLOCK(&amp;sc-&gt;sc_txq[i]);</a>
<a name="ln5088">			}</a>
<a name="ln5089">		}</a>
<a name="ln5090">	}</a>
<a name="ln5091"> </a>
<a name="ln5092">	return 1;</a>
<a name="ln5093">}</a>
<a name="ln5094"> </a>
<a name="ln5095">#ifdef	ATH_DEBUG</a>
<a name="ln5096">void</a>
<a name="ln5097">ath_tx_dump(struct ath_softc *sc, struct ath_txq *txq)</a>
<a name="ln5098">{</a>
<a name="ln5099">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln5100">	struct ath_buf *bf;</a>
<a name="ln5101">	int i = 0;</a>
<a name="ln5102"> </a>
<a name="ln5103">	if (! (sc-&gt;sc_debug &amp; ATH_DEBUG_RESET))</a>
<a name="ln5104">		return;</a>
<a name="ln5105"> </a>
<a name="ln5106">	device_printf(sc-&gt;sc_dev, &quot;%s: Q%d: begin\n&quot;,</a>
<a name="ln5107">	    __func__, txq-&gt;axq_qnum);</a>
<a name="ln5108">	TAILQ_FOREACH(bf, &amp;txq-&gt;axq_q, bf_list) {</a>
<a name="ln5109">		ath_printtxbuf(sc, bf, txq-&gt;axq_qnum, i,</a>
<a name="ln5110">			ath_hal_txprocdesc(ah, bf-&gt;bf_lastds,</a>
<a name="ln5111">			    &amp;bf-&gt;bf_status.ds_txstat) == HAL_OK);</a>
<a name="ln5112">		i++;</a>
<a name="ln5113">	}</a>
<a name="ln5114">	device_printf(sc-&gt;sc_dev, &quot;%s: Q%d: end\n&quot;,</a>
<a name="ln5115">	    __func__, txq-&gt;axq_qnum);</a>
<a name="ln5116">}</a>
<a name="ln5117">#endif /* ATH_DEBUG */</a>
<a name="ln5118"> </a>
<a name="ln5119">/*</a>
<a name="ln5120"> * Drain the transmit queues and reclaim resources.</a>
<a name="ln5121"> */</a>
<a name="ln5122">void</a>
<a name="ln5123">ath_legacy_tx_drain(struct ath_softc *sc, ATH_RESET_TYPE reset_type)</a>
<a name="ln5124">{</a>
<a name="ln5125">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln5126">	struct ath_buf *bf_last;</a>
<a name="ln5127">	int i;</a>
<a name="ln5128"> </a>
<a name="ln5129">	(void) ath_stoptxdma(sc);</a>
<a name="ln5130"> </a>
<a name="ln5131">	/*</a>
<a name="ln5132">	 * Dump the queue contents</a>
<a name="ln5133">	 */</a>
<a name="ln5134">	for (i = 0; i &lt; HAL_NUM_TX_QUEUES; i++) {</a>
<a name="ln5135">		/*</a>
<a name="ln5136">		 * XXX TODO: should we just handle the completed TX frames</a>
<a name="ln5137">		 * here, whether or not the reset is a full one or not?</a>
<a name="ln5138">		 */</a>
<a name="ln5139">		if (ATH_TXQ_SETUP(sc, i)) {</a>
<a name="ln5140">#ifdef	ATH_DEBUG</a>
<a name="ln5141">			if (sc-&gt;sc_debug &amp; ATH_DEBUG_RESET)</a>
<a name="ln5142">				ath_tx_dump(sc, &amp;sc-&gt;sc_txq[i]);</a>
<a name="ln5143">#endif	/* ATH_DEBUG */</a>
<a name="ln5144">			if (reset_type == ATH_RESET_NOLOSS) {</a>
<a name="ln5145">				ath_tx_processq(sc, &amp;sc-&gt;sc_txq[i], 0);</a>
<a name="ln5146">				ATH_TXQ_LOCK(&amp;sc-&gt;sc_txq[i]);</a>
<a name="ln5147">				/*</a>
<a name="ln5148">				 * Free the holding buffer; DMA is now</a>
<a name="ln5149">				 * stopped.</a>
<a name="ln5150">				 */</a>
<a name="ln5151">				ath_txq_freeholdingbuf(sc, &amp;sc-&gt;sc_txq[i]);</a>
<a name="ln5152">				/*</a>
<a name="ln5153">				 * Setup the link pointer to be the</a>
<a name="ln5154">				 * _last_ buffer/descriptor in the list.</a>
<a name="ln5155">				 * If there's nothing in the list, set it</a>
<a name="ln5156">				 * to NULL.</a>
<a name="ln5157">				 */</a>
<a name="ln5158">				bf_last = ATH_TXQ_LAST(&amp;sc-&gt;sc_txq[i],</a>
<a name="ln5159">				    axq_q_s);</a>
<a name="ln5160">				if (bf_last != NULL) {</a>
<a name="ln5161">					ath_hal_gettxdesclinkptr(ah,</a>
<a name="ln5162">					    bf_last-&gt;bf_lastds,</a>
<a name="ln5163">					    &amp;sc-&gt;sc_txq[i].axq_link);</a>
<a name="ln5164">				} else {</a>
<a name="ln5165">					sc-&gt;sc_txq[i].axq_link = NULL;</a>
<a name="ln5166">				}</a>
<a name="ln5167">				ATH_TXQ_UNLOCK(&amp;sc-&gt;sc_txq[i]);</a>
<a name="ln5168">			} else</a>
<a name="ln5169">				ath_tx_draintxq(sc, &amp;sc-&gt;sc_txq[i]);</a>
<a name="ln5170">		}</a>
<a name="ln5171">	}</a>
<a name="ln5172">#ifdef ATH_DEBUG</a>
<a name="ln5173">	if (sc-&gt;sc_debug &amp; ATH_DEBUG_RESET) {</a>
<a name="ln5174">		struct ath_buf *bf = TAILQ_FIRST(&amp;sc-&gt;sc_bbuf);</a>
<a name="ln5175">		if (bf != NULL &amp;&amp; bf-&gt;bf_m != NULL) {</a>
<a name="ln5176">			ath_printtxbuf(sc, bf, sc-&gt;sc_bhalq, 0,</a>
<a name="ln5177">				ath_hal_txprocdesc(ah, bf-&gt;bf_lastds,</a>
<a name="ln5178">				    &amp;bf-&gt;bf_status.ds_txstat) == HAL_OK);</a>
<a name="ln5179">			ieee80211_dump_pkt(&amp;sc-&gt;sc_ic,</a>
<a name="ln5180">			    mtod(bf-&gt;bf_m, const uint8_t *), bf-&gt;bf_m-&gt;m_len,</a>
<a name="ln5181">			    0, -1);</a>
<a name="ln5182">		}</a>
<a name="ln5183">	}</a>
<a name="ln5184">#endif /* ATH_DEBUG */</a>
<a name="ln5185">	sc-&gt;sc_wd_timer = 0;</a>
<a name="ln5186">}</a>
<a name="ln5187"> </a>
<a name="ln5188">/*</a>
<a name="ln5189"> * Update internal state after a channel change.</a>
<a name="ln5190"> */</a>
<a name="ln5191">static void</a>
<a name="ln5192">ath_chan_change(struct ath_softc *sc, struct ieee80211_channel *chan)</a>
<a name="ln5193">{</a>
<a name="ln5194">	enum ieee80211_phymode mode;</a>
<a name="ln5195"> </a>
<a name="ln5196">	/*</a>
<a name="ln5197">	 * Change channels and update the h/w rate map</a>
<a name="ln5198">	 * if we're switching; e.g. 11a to 11b/g.</a>
<a name="ln5199">	 */</a>
<a name="ln5200">	mode = ieee80211_chan2mode(chan);</a>
<a name="ln5201">	if (mode != sc-&gt;sc_curmode)</a>
<a name="ln5202">		ath_setcurmode(sc, mode);</a>
<a name="ln5203">	sc-&gt;sc_curchan = chan;</a>
<a name="ln5204">}</a>
<a name="ln5205"> </a>
<a name="ln5206">/*</a>
<a name="ln5207"> * Set/change channels.  If the channel is really being changed,</a>
<a name="ln5208"> * it's done by resetting the chip.  To accomplish this we must</a>
<a name="ln5209"> * first cleanup any pending DMA, then restart stuff after a la</a>
<a name="ln5210"> * ath_init.</a>
<a name="ln5211"> */</a>
<a name="ln5212">static int</a>
<a name="ln5213">ath_chan_set(struct ath_softc *sc, struct ieee80211_channel *chan)</a>
<a name="ln5214">{</a>
<a name="ln5215">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln5216">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln5217">	int ret = 0;</a>
<a name="ln5218"> </a>
<a name="ln5219">	/* Treat this as an interface reset */</a>
<a name="ln5220">	ATH_PCU_UNLOCK_ASSERT(sc);</a>
<a name="ln5221">	ATH_UNLOCK_ASSERT(sc);</a>
<a name="ln5222"> </a>
<a name="ln5223">	/* (Try to) stop TX/RX from occurring */</a>
<a name="ln5224">	taskqueue_block(sc-&gt;sc_tq);</a>
<a name="ln5225"> </a>
<a name="ln5226">	ATH_PCU_LOCK(sc);</a>
<a name="ln5227"> </a>
<a name="ln5228">	/* Disable interrupts */</a>
<a name="ln5229">	ath_hal_intrset(ah, 0);</a>
<a name="ln5230"> </a>
<a name="ln5231">	/* Stop new RX/TX/interrupt completion */</a>
<a name="ln5232">	if (ath_reset_grablock(sc, 1) == 0) {</a>
<a name="ln5233">		device_printf(sc-&gt;sc_dev, &quot;%s: concurrent reset! Danger!\n&quot;,</a>
<a name="ln5234">		    __func__);</a>
<a name="ln5235">	}</a>
<a name="ln5236"> </a>
<a name="ln5237">	/* Stop pending RX/TX completion */</a>
<a name="ln5238">	ath_txrx_stop_locked(sc);</a>
<a name="ln5239"> </a>
<a name="ln5240">	ATH_PCU_UNLOCK(sc);</a>
<a name="ln5241"> </a>
<a name="ln5242">	DPRINTF(sc, ATH_DEBUG_RESET, &quot;%s: %u (%u MHz, flags 0x%x)\n&quot;,</a>
<a name="ln5243">	    __func__, ieee80211_chan2ieee(ic, chan),</a>
<a name="ln5244">	    chan-&gt;ic_freq, chan-&gt;ic_flags);</a>
<a name="ln5245">	if (chan != sc-&gt;sc_curchan) {</a>
<a name="ln5246">		HAL_STATUS status;</a>
<a name="ln5247">		/*</a>
<a name="ln5248">		 * To switch channels clear any pending DMA operations;</a>
<a name="ln5249">		 * wait long enough for the RX fifo to drain, reset the</a>
<a name="ln5250">		 * hardware at the new frequency, and then re-enable</a>
<a name="ln5251">		 * the relevant bits of the h/w.</a>
<a name="ln5252">		 */</a>
<a name="ln5253">#if 0</a>
<a name="ln5254">		ath_hal_intrset(ah, 0);		/* disable interrupts */</a>
<a name="ln5255">#endif</a>
<a name="ln5256">		ath_stoprecv(sc, 1);		/* turn off frame recv */</a>
<a name="ln5257">		/*</a>
<a name="ln5258">		 * First, handle completed TX/RX frames.</a>
<a name="ln5259">		 */</a>
<a name="ln5260">		ath_rx_flush(sc);</a>
<a name="ln5261">		ath_draintxq(sc, ATH_RESET_NOLOSS);</a>
<a name="ln5262">		/*</a>
<a name="ln5263">		 * Next, flush the non-scheduled frames.</a>
<a name="ln5264">		 */</a>
<a name="ln5265">		ath_draintxq(sc, ATH_RESET_FULL);	/* clear pending tx frames */</a>
<a name="ln5266"> </a>
<a name="ln5267">		ath_update_chainmasks(sc, chan);</a>
<a name="ln5268">		ath_hal_setchainmasks(sc-&gt;sc_ah, sc-&gt;sc_cur_txchainmask,</a>
<a name="ln5269">		    sc-&gt;sc_cur_rxchainmask);</a>
<a name="ln5270">		if (!ath_hal_reset(ah, sc-&gt;sc_opmode, chan, AH_TRUE,</a>
<a name="ln5271">		    HAL_RESET_NORMAL, &amp;status)) {</a>
<a name="ln5272">			device_printf(sc-&gt;sc_dev, &quot;%s: unable to reset &quot;</a>
<a name="ln5273">			    &quot;channel %u (%u MHz, flags 0x%x), hal status %u\n&quot;,</a>
<a name="ln5274">			    __func__, ieee80211_chan2ieee(ic, chan),</a>
<a name="ln5275">			    chan-&gt;ic_freq, chan-&gt;ic_flags, status);</a>
<a name="ln5276">			ret = EIO;</a>
<a name="ln5277">			goto finish;</a>
<a name="ln5278">		}</a>
<a name="ln5279">		sc-&gt;sc_diversity = ath_hal_getdiversity(ah);</a>
<a name="ln5280"> </a>
<a name="ln5281">		ATH_RX_LOCK(sc);</a>
<a name="ln5282">		sc-&gt;sc_rx_stopped = 1;</a>
<a name="ln5283">		sc-&gt;sc_rx_resetted = 1;</a>
<a name="ln5284">		ATH_RX_UNLOCK(sc);</a>
<a name="ln5285"> </a>
<a name="ln5286">		/* Quiet time handling - ensure we resync */</a>
<a name="ln5287">		ath_vap_clear_quiet_ie(sc);</a>
<a name="ln5288"> </a>
<a name="ln5289">		/* Let DFS at it in case it's a DFS channel */</a>
<a name="ln5290">		ath_dfs_radar_enable(sc, chan);</a>
<a name="ln5291"> </a>
<a name="ln5292">		/* Let spectral at in case spectral is enabled */</a>
<a name="ln5293">		ath_spectral_enable(sc, chan);</a>
<a name="ln5294"> </a>
<a name="ln5295">		/*</a>
<a name="ln5296">		 * Let bluetooth coexistence at in case it's needed for this</a>
<a name="ln5297">		 * channel</a>
<a name="ln5298">		 */</a>
<a name="ln5299">		ath_btcoex_enable(sc, ic-&gt;ic_curchan);</a>
<a name="ln5300"> </a>
<a name="ln5301">		/*</a>
<a name="ln5302">		 * If we're doing TDMA, enforce the TXOP limitation for chips</a>
<a name="ln5303">		 * that support it.</a>
<a name="ln5304">		 */</a>
<a name="ln5305">		if (sc-&gt;sc_hasenforcetxop &amp;&amp; sc-&gt;sc_tdma)</a>
<a name="ln5306">			ath_hal_setenforcetxop(sc-&gt;sc_ah, 1);</a>
<a name="ln5307">		else</a>
<a name="ln5308">			ath_hal_setenforcetxop(sc-&gt;sc_ah, 0);</a>
<a name="ln5309"> </a>
<a name="ln5310">		/*</a>
<a name="ln5311">		 * Re-enable rx framework.</a>
<a name="ln5312">		 */</a>
<a name="ln5313">		if (ath_startrecv(sc) != 0) {</a>
<a name="ln5314">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln5315">			    &quot;%s: unable to restart recv logic\n&quot;, __func__);</a>
<a name="ln5316">			ret = EIO;</a>
<a name="ln5317">			goto finish;</a>
<a name="ln5318">		}</a>
<a name="ln5319"> </a>
<a name="ln5320">		/*</a>
<a name="ln5321">		 * Change channels and update the h/w rate map</a>
<a name="ln5322">		 * if we're switching; e.g. 11a to 11b/g.</a>
<a name="ln5323">		 */</a>
<a name="ln5324">		ath_chan_change(sc, chan);</a>
<a name="ln5325"> </a>
<a name="ln5326">		/*</a>
<a name="ln5327">		 * Reset clears the beacon timers; reset them</a>
<a name="ln5328">		 * here if needed.</a>
<a name="ln5329">		 */</a>
<a name="ln5330">		if (sc-&gt;sc_beacons) {		/* restart beacons */</a>
<a name="ln5331">#ifdef IEEE80211_SUPPORT_TDMA</a>
<a name="ln5332">			if (sc-&gt;sc_tdma)</a>
<a name="ln5333">				ath_tdma_config(sc, NULL);</a>
<a name="ln5334">			else</a>
<a name="ln5335">#endif</a>
<a name="ln5336">			ath_beacon_config(sc, NULL);</a>
<a name="ln5337">		}</a>
<a name="ln5338"> </a>
<a name="ln5339">		/*</a>
<a name="ln5340">		 * Re-enable interrupts.</a>
<a name="ln5341">		 */</a>
<a name="ln5342">#if 0</a>
<a name="ln5343">		ath_hal_intrset(ah, sc-&gt;sc_imask);</a>
<a name="ln5344">#endif</a>
<a name="ln5345">	}</a>
<a name="ln5346"> </a>
<a name="ln5347">finish:</a>
<a name="ln5348">	ATH_PCU_LOCK(sc);</a>
<a name="ln5349">	sc-&gt;sc_inreset_cnt--;</a>
<a name="ln5350">	/* XXX only do this if sc_inreset_cnt == 0? */</a>
<a name="ln5351">	ath_hal_intrset(ah, sc-&gt;sc_imask);</a>
<a name="ln5352">	ATH_PCU_UNLOCK(sc);</a>
<a name="ln5353"> </a>
<a name="ln5354">	ath_txrx_start(sc);</a>
<a name="ln5355">	/* XXX ath_start? */</a>
<a name="ln5356"> </a>
<a name="ln5357">	return ret;</a>
<a name="ln5358">}</a>
<a name="ln5359"> </a>
<a name="ln5360">/*</a>
<a name="ln5361"> * Periodically recalibrate the PHY to account</a>
<a name="ln5362"> * for temperature/environment changes.</a>
<a name="ln5363"> */</a>
<a name="ln5364">static void</a>
<a name="ln5365">ath_calibrate(void *arg)</a>
<a name="ln5366">{</a>
<a name="ln5367">	struct ath_softc *sc = arg;</a>
<a name="ln5368">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln5369">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln5370">	HAL_BOOL longCal, isCalDone = AH_TRUE;</a>
<a name="ln5371">	HAL_BOOL aniCal, shortCal = AH_FALSE;</a>
<a name="ln5372">	int nextcal;</a>
<a name="ln5373"> </a>
<a name="ln5374">	ATH_LOCK_ASSERT(sc);</a>
<a name="ln5375"> </a>
<a name="ln5376">	/*</a>
<a name="ln5377">	 * Force the hardware awake for ANI work.</a>
<a name="ln5378">	 */</a>
<a name="ln5379">	ath_power_set_power_state(sc, HAL_PM_AWAKE);</a>
<a name="ln5380"> </a>
<a name="ln5381">	/* Skip trying to do this if we're in reset */</a>
<a name="ln5382">	if (sc-&gt;sc_inreset_cnt)</a>
<a name="ln5383">		goto restart;</a>
<a name="ln5384"> </a>
<a name="ln5385">	if (ic-&gt;ic_flags &amp; IEEE80211_F_SCAN)	/* defer, off channel */</a>
<a name="ln5386">		goto restart;</a>
<a name="ln5387">	longCal = (ticks - sc-&gt;sc_lastlongcal &gt;= ath_longcalinterval*hz);</a>
<a name="ln5388">	aniCal = (ticks - sc-&gt;sc_lastani &gt;= ath_anicalinterval*hz/1000);</a>
<a name="ln5389">	if (sc-&gt;sc_doresetcal)</a>
<a name="ln5390">		shortCal = (ticks - sc-&gt;sc_lastshortcal &gt;= ath_shortcalinterval*hz/1000);</a>
<a name="ln5391"> </a>
<a name="ln5392">	DPRINTF(sc, ATH_DEBUG_CALIBRATE, &quot;%s: shortCal=%d; longCal=%d; aniCal=%d\n&quot;, __func__, shortCal, longCal, aniCal);</a>
<a name="ln5393">	if (aniCal) {</a>
<a name="ln5394">		sc-&gt;sc_stats.ast_ani_cal++;</a>
<a name="ln5395">		sc-&gt;sc_lastani = ticks;</a>
<a name="ln5396">		ath_hal_ani_poll(ah, sc-&gt;sc_curchan);</a>
<a name="ln5397">	}</a>
<a name="ln5398"> </a>
<a name="ln5399">	if (longCal) {</a>
<a name="ln5400">		sc-&gt;sc_stats.ast_per_cal++;</a>
<a name="ln5401">		sc-&gt;sc_lastlongcal = ticks;</a>
<a name="ln5402">		if (ath_hal_getrfgain(ah) == HAL_RFGAIN_NEED_CHANGE) {</a>
<a name="ln5403">			/*</a>
<a name="ln5404">			 * Rfgain is out of bounds, reset the chip</a>
<a name="ln5405">			 * to load new gain values.</a>
<a name="ln5406">			 */</a>
<a name="ln5407">			DPRINTF(sc, ATH_DEBUG_CALIBRATE,</a>
<a name="ln5408">				&quot;%s: rfgain change\n&quot;, __func__);</a>
<a name="ln5409">			sc-&gt;sc_stats.ast_per_rfgain++;</a>
<a name="ln5410">			sc-&gt;sc_resetcal = 0;</a>
<a name="ln5411">			sc-&gt;sc_doresetcal = AH_TRUE;</a>
<a name="ln5412">			taskqueue_enqueue(sc-&gt;sc_tq, &amp;sc-&gt;sc_resettask);</a>
<a name="ln5413">			callout_reset(&amp;sc-&gt;sc_cal_ch, 1, ath_calibrate, sc);</a>
<a name="ln5414">			ath_power_restore_power_state(sc);</a>
<a name="ln5415">			return;</a>
<a name="ln5416">		}</a>
<a name="ln5417">		/*</a>
<a name="ln5418">		 * If this long cal is after an idle period, then</a>
<a name="ln5419">		 * reset the data collection state so we start fresh.</a>
<a name="ln5420">		 */</a>
<a name="ln5421">		if (sc-&gt;sc_resetcal) {</a>
<a name="ln5422">			(void) ath_hal_calreset(ah, sc-&gt;sc_curchan);</a>
<a name="ln5423">			sc-&gt;sc_lastcalreset = ticks;</a>
<a name="ln5424">			sc-&gt;sc_lastshortcal = ticks;</a>
<a name="ln5425">			sc-&gt;sc_resetcal = 0;</a>
<a name="ln5426">			sc-&gt;sc_doresetcal = AH_TRUE;</a>
<a name="ln5427">		}</a>
<a name="ln5428">	}</a>
<a name="ln5429"> </a>
<a name="ln5430">	/* Only call if we're doing a short/long cal, not for ANI calibration */</a>
<a name="ln5431">	if (shortCal || longCal) {</a>
<a name="ln5432">		isCalDone = AH_FALSE;</a>
<a name="ln5433">		if (ath_hal_calibrateN(ah, sc-&gt;sc_curchan, longCal, &amp;isCalDone)) {</a>
<a name="ln5434">			if (longCal) {</a>
<a name="ln5435">				/*</a>
<a name="ln5436">				 * Calibrate noise floor data again in case of change.</a>
<a name="ln5437">				 */</a>
<a name="ln5438">				ath_hal_process_noisefloor(ah);</a>
<a name="ln5439">			}</a>
<a name="ln5440">		} else {</a>
<a name="ln5441">			DPRINTF(sc, ATH_DEBUG_ANY,</a>
<a name="ln5442">				&quot;%s: calibration of channel %u failed\n&quot;,</a>
<a name="ln5443">				__func__, sc-&gt;sc_curchan-&gt;ic_freq);</a>
<a name="ln5444">			sc-&gt;sc_stats.ast_per_calfail++;</a>
<a name="ln5445">		}</a>
<a name="ln5446">		if (shortCal)</a>
<a name="ln5447">			sc-&gt;sc_lastshortcal = ticks;</a>
<a name="ln5448">	}</a>
<a name="ln5449">	if (!isCalDone) {</a>
<a name="ln5450">restart:</a>
<a name="ln5451">		/*</a>
<a name="ln5452">		 * Use a shorter interval to potentially collect multiple</a>
<a name="ln5453">		 * data samples required to complete calibration.  Once</a>
<a name="ln5454">		 * we're told the work is done we drop back to a longer</a>
<a name="ln5455">		 * interval between requests.  We're more aggressive doing</a>
<a name="ln5456">		 * work when operating as an AP to improve operation right</a>
<a name="ln5457">		 * after startup.</a>
<a name="ln5458">		 */</a>
<a name="ln5459">		sc-&gt;sc_lastshortcal = ticks;</a>
<a name="ln5460">		nextcal = ath_shortcalinterval*hz/1000;</a>
<a name="ln5461">		if (sc-&gt;sc_opmode != HAL_M_HOSTAP)</a>
<a name="ln5462">			nextcal *= 10;</a>
<a name="ln5463">		sc-&gt;sc_doresetcal = AH_TRUE;</a>
<a name="ln5464">	} else {</a>
<a name="ln5465">		/* nextcal should be the shortest time for next event */</a>
<a name="ln5466">		nextcal = ath_longcalinterval*hz;</a>
<a name="ln5467">		if (sc-&gt;sc_lastcalreset == 0)</a>
<a name="ln5468">			sc-&gt;sc_lastcalreset = sc-&gt;sc_lastlongcal;</a>
<a name="ln5469">		else if (ticks - sc-&gt;sc_lastcalreset &gt;= ath_resetcalinterval*hz)</a>
<a name="ln5470">			sc-&gt;sc_resetcal = 1;	/* setup reset next trip */</a>
<a name="ln5471">		sc-&gt;sc_doresetcal = AH_FALSE;</a>
<a name="ln5472">	}</a>
<a name="ln5473">	/* ANI calibration may occur more often than short/long/resetcal */</a>
<a name="ln5474">	if (ath_anicalinterval &gt; 0)</a>
<a name="ln5475">		nextcal = MIN(nextcal, ath_anicalinterval*hz/1000);</a>
<a name="ln5476"> </a>
<a name="ln5477">	if (nextcal != 0) {</a>
<a name="ln5478">		DPRINTF(sc, ATH_DEBUG_CALIBRATE, &quot;%s: next +%u (%sisCalDone)\n&quot;,</a>
<a name="ln5479">		    __func__, nextcal, isCalDone ? &quot;&quot; : &quot;!&quot;);</a>
<a name="ln5480">		callout_reset(&amp;sc-&gt;sc_cal_ch, nextcal, ath_calibrate, sc);</a>
<a name="ln5481">	} else {</a>
<a name="ln5482">		DPRINTF(sc, ATH_DEBUG_CALIBRATE, &quot;%s: calibration disabled\n&quot;,</a>
<a name="ln5483">		    __func__);</a>
<a name="ln5484">		/* NB: don't rearm timer */</a>
<a name="ln5485">	}</a>
<a name="ln5486">	/*</a>
<a name="ln5487">	 * Restore power state now that we're done.</a>
<a name="ln5488">	 */</a>
<a name="ln5489">	ath_power_restore_power_state(sc);</a>
<a name="ln5490">}</a>
<a name="ln5491"> </a>
<a name="ln5492">static void</a>
<a name="ln5493">ath_scan_start(struct ieee80211com *ic)</a>
<a name="ln5494">{</a>
<a name="ln5495">	struct ath_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln5496">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln5497">	u_int32_t rfilt;</a>
<a name="ln5498"> </a>
<a name="ln5499">	/* XXX calibration timer? */</a>
<a name="ln5500">	/* XXXGL: is constant ieee80211broadcastaddr a correct choice? */</a>
<a name="ln5501"> </a>
<a name="ln5502">	ATH_LOCK(sc);</a>
<a name="ln5503">	sc-&gt;sc_scanning = 1;</a>
<a name="ln5504">	sc-&gt;sc_syncbeacon = 0;</a>
<a name="ln5505">	rfilt = ath_calcrxfilter(sc);</a>
<a name="ln5506">	ATH_UNLOCK(sc);</a>
<a name="ln5507"> </a>
<a name="ln5508">	ATH_PCU_LOCK(sc);</a>
<a name="ln5509">	ath_hal_setrxfilter(ah, rfilt);</a>
<a name="ln5510">	ath_hal_setassocid(ah, ieee80211broadcastaddr, 0);</a>
<a name="ln5511">	ATH_PCU_UNLOCK(sc);</a>
<a name="ln5512"> </a>
<a name="ln5513">	DPRINTF(sc, ATH_DEBUG_STATE, &quot;%s: RX filter 0x%x bssid %s aid 0\n&quot;,</a>
<a name="ln5514">		 __func__, rfilt, ether_sprintf(ieee80211broadcastaddr));</a>
<a name="ln5515">}</a>
<a name="ln5516"> </a>
<a name="ln5517">static void</a>
<a name="ln5518">ath_scan_end(struct ieee80211com *ic)</a>
<a name="ln5519">{</a>
<a name="ln5520">	struct ath_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln5521">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln5522">	u_int32_t rfilt;</a>
<a name="ln5523"> </a>
<a name="ln5524">	ATH_LOCK(sc);</a>
<a name="ln5525">	sc-&gt;sc_scanning = 0;</a>
<a name="ln5526">	rfilt = ath_calcrxfilter(sc);</a>
<a name="ln5527">	ATH_UNLOCK(sc);</a>
<a name="ln5528"> </a>
<a name="ln5529">	ATH_PCU_LOCK(sc);</a>
<a name="ln5530">	ath_hal_setrxfilter(ah, rfilt);</a>
<a name="ln5531">	ath_hal_setassocid(ah, sc-&gt;sc_curbssid, sc-&gt;sc_curaid);</a>
<a name="ln5532"> </a>
<a name="ln5533">	ath_hal_process_noisefloor(ah);</a>
<a name="ln5534">	ATH_PCU_UNLOCK(sc);</a>
<a name="ln5535"> </a>
<a name="ln5536">	DPRINTF(sc, ATH_DEBUG_STATE, &quot;%s: RX filter 0x%x bssid %s aid 0x%x\n&quot;,</a>
<a name="ln5537">		 __func__, rfilt, ether_sprintf(sc-&gt;sc_curbssid),</a>
<a name="ln5538">		 sc-&gt;sc_curaid);</a>
<a name="ln5539">}</a>
<a name="ln5540"> </a>
<a name="ln5541">#ifdef	ATH_ENABLE_11N</a>
<a name="ln5542">/*</a>
<a name="ln5543"> * For now, just do a channel change.</a>
<a name="ln5544"> *</a>
<a name="ln5545"> * Later, we'll go through the hard slog of suspending tx/rx, changing rate</a>
<a name="ln5546"> * control state and resetting the hardware without dropping frames out</a>
<a name="ln5547"> * of the queue.</a>
<a name="ln5548"> *</a>
<a name="ln5549"> * The unfortunate trouble here is making absolutely sure that the</a>
<a name="ln5550"> * channel width change has propagated enough so the hardware</a>
<a name="ln5551"> * absolutely isn't handed bogus frames for it's current operating</a>
<a name="ln5552"> * mode. (Eg, 40MHz frames in 20MHz mode.) Since TX and RX can and</a>
<a name="ln5553"> * does occur in parallel, we need to make certain we've blocked</a>
<a name="ln5554"> * any further ongoing TX (and RX, that can cause raw TX)</a>
<a name="ln5555"> * before we do this.</a>
<a name="ln5556"> */</a>
<a name="ln5557">static void</a>
<a name="ln5558">ath_update_chw(struct ieee80211com *ic)</a>
<a name="ln5559">{</a>
<a name="ln5560">	struct ath_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln5561"> </a>
<a name="ln5562">	//DPRINTF(sc, ATH_DEBUG_STATE, &quot;%s: called\n&quot;, __func__);</a>
<a name="ln5563">	device_printf(sc-&gt;sc_dev, &quot;%s: called\n&quot;, __func__);</a>
<a name="ln5564"> </a>
<a name="ln5565">	/*</a>
<a name="ln5566">	 * XXX TODO: schedule a tasklet that stops things without freeing,</a>
<a name="ln5567">	 * walks the now stopped TX queue(s) looking for frames to retry</a>
<a name="ln5568">	 * as if we TX filtered them (whch may mean dropping non-ampdu frames!)</a>
<a name="ln5569">	 * but okay) then place them back on the software queue so they</a>
<a name="ln5570">	 * can have the rate control lookup done again.</a>
<a name="ln5571">	 */</a>
<a name="ln5572">	ath_set_channel(ic);</a>
<a name="ln5573">}</a>
<a name="ln5574">#endif	/* ATH_ENABLE_11N */</a>
<a name="ln5575"> </a>
<a name="ln5576">/*</a>
<a name="ln5577"> * This is called by the beacon parsing routine in the receive</a>
<a name="ln5578"> * path to update the current quiet time information provided by</a>
<a name="ln5579"> * an AP.</a>
<a name="ln5580"> *</a>
<a name="ln5581"> * This is STA specific, it doesn't take the AP TBTT/beacon slot</a>
<a name="ln5582"> * offset into account.</a>
<a name="ln5583"> *</a>
<a name="ln5584"> * The quiet IE doesn't control the /now/ beacon interval - it</a>
<a name="ln5585"> * controls the upcoming beacon interval.  So, when tbtt=1,</a>
<a name="ln5586"> * the quiet element programming shall be for the next beacon</a>
<a name="ln5587"> * interval.  There's no tbtt=0 behaviour defined, so don't.</a>
<a name="ln5588"> *</a>
<a name="ln5589"> * Since we're programming the next quiet interval, we have</a>
<a name="ln5590"> * to keep in mind what we will see when the next beacon</a>
<a name="ln5591"> * is received with potentially a quiet IE.  For example, if</a>
<a name="ln5592"> * quiet_period is 1, then we are always getting a quiet interval</a>
<a name="ln5593"> * each TBTT - so if we just program it in upon each beacon received,</a>
<a name="ln5594"> * it will constantly reflect the &quot;next&quot; TBTT and we will never</a>
<a name="ln5595"> * let the counter stay programmed correctly.</a>
<a name="ln5596"> *</a>
<a name="ln5597"> * So:</a>
<a name="ln5598"> * + the first time we see the quiet IE, program it and store</a>
<a name="ln5599"> *   the details somewhere;</a>
<a name="ln5600"> * + if the quiet parameters don't change (ie, period/duration/offset)</a>
<a name="ln5601"> *   then just leave the programming enabled;</a>
<a name="ln5602"> * + (we can &quot;skip&quot; beacons, so don't try to enforce tbttcount unless</a>
<a name="ln5603"> *   you're willing to also do the skipped beacon math);</a>
<a name="ln5604"> * + if the quiet IE is removed, then halt quiet time.</a>
<a name="ln5605"> */</a>
<a name="ln5606">static int</a>
<a name="ln5607">ath_set_quiet_ie(struct ieee80211_node *ni, uint8_t *ie)</a>
<a name="ln5608">{</a>
<a name="ln5609">	struct ieee80211_quiet_ie *q;</a>
<a name="ln5610">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln5611">	struct ath_vap *avp = ATH_VAP(vap);</a>
<a name="ln5612">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln5613">	struct ath_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln5614"> </a>
<a name="ln5615">	if (vap-&gt;iv_opmode != IEEE80211_M_STA)</a>
<a name="ln5616">		return (0);</a>
<a name="ln5617"> </a>
<a name="ln5618">	/* Verify we have a quiet time IE */</a>
<a name="ln5619">	if (ie == NULL) {</a>
<a name="ln5620">		DPRINTF(sc, ATH_DEBUG_QUIETIE,</a>
<a name="ln5621">		    &quot;%s: called; NULL IE, disabling\n&quot;, __func__);</a>
<a name="ln5622"> </a>
<a name="ln5623">		ath_hal_set_quiet(sc-&gt;sc_ah, 0, 0, 0, HAL_QUIET_DISABLE);</a>
<a name="ln5624">		memset(&amp;avp-&gt;quiet_ie, 0, sizeof(avp-&gt;quiet_ie));</a>
<a name="ln5625">		return (0);</a>
<a name="ln5626">	}</a>
<a name="ln5627"> </a>
<a name="ln5628">	/* If we do, verify it's actually legit */</a>
<a name="ln5629">	if (ie[0] != IEEE80211_ELEMID_QUIET)</a>
<a name="ln5630">		return 0;</a>
<a name="ln5631">	if (ie[1] != 6)</a>
<a name="ln5632">		return 0;</a>
<a name="ln5633"> </a>
<a name="ln5634">	/* Note: this belongs in net80211, parsed out and everything */</a>
<a name="ln5635">	q = (void *) ie;</a>
<a name="ln5636"> </a>
<a name="ln5637">	/*</a>
<a name="ln5638">	 * Compare what we have stored to what we last saw.</a>
<a name="ln5639">	 * If they're the same then don't program in anything.</a>
<a name="ln5640">	 */</a>
<a name="ln5641">	if ((q-&gt;period == avp-&gt;quiet_ie.period) &amp;&amp;</a>
<a name="ln5642">	    (le16dec(&amp;q-&gt;duration) == le16dec(&amp;avp-&gt;quiet_ie.duration)) &amp;&amp;</a>
<a name="ln5643">	    (le16dec(&amp;q-&gt;offset) == le16dec(&amp;avp-&gt;quiet_ie.offset)))</a>
<a name="ln5644">		return (0);</a>
<a name="ln5645"> </a>
<a name="ln5646">	DPRINTF(sc, ATH_DEBUG_QUIETIE,</a>
<a name="ln5647">	    &quot;%s: called; tbttcount=%d, period=%d, duration=%d, offset=%d\n&quot;,</a>
<a name="ln5648">	    __func__,</a>
<a name="ln5649">	    (int) q-&gt;tbttcount,</a>
<a name="ln5650">	    (int) q-&gt;period,</a>
<a name="ln5651">	    (int) le16dec(&amp;q-&gt;duration),</a>
<a name="ln5652">	    (int) le16dec(&amp;q-&gt;offset));</a>
<a name="ln5653"> </a>
<a name="ln5654">	/*</a>
<a name="ln5655">	 * Don't program in garbage values.</a>
<a name="ln5656">	 */</a>
<a name="ln5657">	if ((le16dec(&amp;q-&gt;duration) == 0) ||</a>
<a name="ln5658">	    (le16dec(&amp;q-&gt;duration) &gt;= ni-&gt;ni_intval)) {</a>
<a name="ln5659">		DPRINTF(sc, ATH_DEBUG_QUIETIE,</a>
<a name="ln5660">		    &quot;%s: invalid duration (%d)\n&quot;, __func__,</a>
<a name="ln5661">		    le16dec(&amp;q-&gt;duration));</a>
<a name="ln5662">		    return (0);</a>
<a name="ln5663">	}</a>
<a name="ln5664">	/*</a>
<a name="ln5665">	 * Can have a 0 offset, but not a duration - so just check</a>
<a name="ln5666">	 * they don't exceed the intval.</a>
<a name="ln5667">	 */</a>
<a name="ln5668">	if (le16dec(&amp;q-&gt;duration) + le16dec(&amp;q-&gt;offset) &gt;= ni-&gt;ni_intval) {</a>
<a name="ln5669">		DPRINTF(sc, ATH_DEBUG_QUIETIE,</a>
<a name="ln5670">		    &quot;%s: invalid duration + offset (%d+%d)\n&quot;, __func__,</a>
<a name="ln5671">		    le16dec(&amp;q-&gt;duration),</a>
<a name="ln5672">		    le16dec(&amp;q-&gt;offset));</a>
<a name="ln5673">		    return (0);</a>
<a name="ln5674">	}</a>
<a name="ln5675">	if (q-&gt;tbttcount == 0) {</a>
<a name="ln5676">		DPRINTF(sc, ATH_DEBUG_QUIETIE,</a>
<a name="ln5677">		    &quot;%s: invalid tbttcount (0)\n&quot;, __func__);</a>
<a name="ln5678">		    return (0);</a>
<a name="ln5679">	}</a>
<a name="ln5680">	if (q-&gt;period == 0) {</a>
<a name="ln5681">		DPRINTF(sc, ATH_DEBUG_QUIETIE,</a>
<a name="ln5682">		    &quot;%s: invalid period (0)\n&quot;, __func__);</a>
<a name="ln5683">		    return (0);</a>
<a name="ln5684">	}</a>
<a name="ln5685"> </a>
<a name="ln5686">	/*</a>
<a name="ln5687">	 * This is a new quiet time IE config, so wait until tbttcount</a>
<a name="ln5688">	 * is equal to 1, and program it in.</a>
<a name="ln5689">	 */</a>
<a name="ln5690">	if (q-&gt;tbttcount == 1) {</a>
<a name="ln5691">		DPRINTF(sc, ATH_DEBUG_QUIETIE,</a>
<a name="ln5692">		    &quot;%s: programming\n&quot;, __func__);</a>
<a name="ln5693">		ath_hal_set_quiet(sc-&gt;sc_ah,</a>
<a name="ln5694">		    q-&gt;period * ni-&gt;ni_intval,	/* convert to TU */</a>
<a name="ln5695">		    le16dec(&amp;q-&gt;duration),	/* already in TU */</a>
<a name="ln5696">		    le16dec(&amp;q-&gt;offset) + ni-&gt;ni_intval,</a>
<a name="ln5697">		    HAL_QUIET_ENABLE | HAL_QUIET_ADD_CURRENT_TSF);</a>
<a name="ln5698">		/*</a>
<a name="ln5699">		 * Note: no HAL_QUIET_ADD_SWBA_RESP_TIME; as this is for</a>
<a name="ln5700">		 * STA mode</a>
<a name="ln5701">		 */</a>
<a name="ln5702"> </a>
<a name="ln5703">		/* Update local state */</a>
<a name="ln5704">		memcpy(&amp;avp-&gt;quiet_ie, ie, sizeof(struct ieee80211_quiet_ie));</a>
<a name="ln5705">	}</a>
<a name="ln5706"> </a>
<a name="ln5707">	return (0);</a>
<a name="ln5708">}</a>
<a name="ln5709"> </a>
<a name="ln5710">static void</a>
<a name="ln5711">ath_set_channel(struct ieee80211com *ic)</a>
<a name="ln5712">{</a>
<a name="ln5713">	struct ath_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln5714"> </a>
<a name="ln5715">	ATH_LOCK(sc);</a>
<a name="ln5716">	ath_power_set_power_state(sc, HAL_PM_AWAKE);</a>
<a name="ln5717">	ATH_UNLOCK(sc);</a>
<a name="ln5718"> </a>
<a name="ln5719">	(void) ath_chan_set(sc, ic-&gt;ic_curchan);</a>
<a name="ln5720">	/*</a>
<a name="ln5721">	 * If we are returning to our bss channel then mark state</a>
<a name="ln5722">	 * so the next recv'd beacon's tsf will be used to sync the</a>
<a name="ln5723">	 * beacon timers.  Note that since we only hear beacons in</a>
<a name="ln5724">	 * sta/ibss mode this has no effect in other operating modes.</a>
<a name="ln5725">	 */</a>
<a name="ln5726">	ATH_LOCK(sc);</a>
<a name="ln5727">	if (!sc-&gt;sc_scanning &amp;&amp; ic-&gt;ic_curchan == ic-&gt;ic_bsschan)</a>
<a name="ln5728">		sc-&gt;sc_syncbeacon = 1;</a>
<a name="ln5729">	ath_power_restore_power_state(sc);</a>
<a name="ln5730">	ATH_UNLOCK(sc);</a>
<a name="ln5731">}</a>
<a name="ln5732"> </a>
<a name="ln5733">/*</a>
<a name="ln5734"> * Walk the vap list and check if there any vap's in RUN state.</a>
<a name="ln5735"> */</a>
<a name="ln5736">static int</a>
<a name="ln5737">ath_isanyrunningvaps(struct ieee80211vap *this)</a>
<a name="ln5738">{</a>
<a name="ln5739">	struct ieee80211com *ic = this-&gt;iv_ic;</a>
<a name="ln5740">	struct ieee80211vap *vap;</a>
<a name="ln5741"> </a>
<a name="ln5742">	IEEE80211_LOCK_ASSERT(ic);</a>
<a name="ln5743"> </a>
<a name="ln5744">	TAILQ_FOREACH(vap, &amp;ic-&gt;ic_vaps, iv_next) {</a>
<a name="ln5745">		if (vap != this &amp;&amp; vap-&gt;iv_state &gt;= IEEE80211_S_RUN)</a>
<a name="ln5746">			return 1;</a>
<a name="ln5747">	}</a>
<a name="ln5748">	return 0;</a>
<a name="ln5749">}</a>
<a name="ln5750"> </a>
<a name="ln5751">static int</a>
<a name="ln5752">ath_newstate(struct ieee80211vap *vap, enum ieee80211_state nstate, int arg)</a>
<a name="ln5753">{</a>
<a name="ln5754">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln5755">	struct ath_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln5756">	struct ath_vap *avp = ATH_VAP(vap);</a>
<a name="ln5757">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln5758">	struct ieee80211_node *ni = NULL;</a>
<a name="ln5759">	int i, error, stamode;</a>
<a name="ln5760">	u_int32_t rfilt;</a>
<a name="ln5761">	int csa_run_transition = 0;</a>
<a name="ln5762">	enum ieee80211_state ostate = vap-&gt;iv_state;</a>
<a name="ln5763"> </a>
<a name="ln5764">	static const HAL_LED_STATE leds[] = {</a>
<a name="ln5765">	    HAL_LED_INIT,	/* IEEE80211_S_INIT */</a>
<a name="ln5766">	    HAL_LED_SCAN,	/* IEEE80211_S_SCAN */</a>
<a name="ln5767">	    HAL_LED_AUTH,	/* IEEE80211_S_AUTH */</a>
<a name="ln5768">	    HAL_LED_ASSOC, 	/* IEEE80211_S_ASSOC */</a>
<a name="ln5769">	    HAL_LED_RUN, 	/* IEEE80211_S_CAC */</a>
<a name="ln5770">	    HAL_LED_RUN, 	/* IEEE80211_S_RUN */</a>
<a name="ln5771">	    HAL_LED_RUN, 	/* IEEE80211_S_CSA */</a>
<a name="ln5772">	    HAL_LED_RUN, 	/* IEEE80211_S_SLEEP */</a>
<a name="ln5773">	};</a>
<a name="ln5774"> </a>
<a name="ln5775">	DPRINTF(sc, ATH_DEBUG_STATE, &quot;%s: %s -&gt; %s\n&quot;, __func__,</a>
<a name="ln5776">		ieee80211_state_name[ostate],</a>
<a name="ln5777">		ieee80211_state_name[nstate]);</a>
<a name="ln5778"> </a>
<a name="ln5779">	/*</a>
<a name="ln5780">	 * net80211 _should_ have the comlock asserted at this point.</a>
<a name="ln5781">	 * There are some comments around the calls to vap-&gt;iv_newstate</a>
<a name="ln5782">	 * which indicate that it (newstate) may end up dropping the</a>
<a name="ln5783">	 * lock.  This and the subsequent lock assert check after newstate</a>
<a name="ln5784">	 * are an attempt to catch these and figure out how/why.</a>
<a name="ln5785">	 */</a>
<a name="ln5786">	IEEE80211_LOCK_ASSERT(ic);</a>
<a name="ln5787"> </a>
<a name="ln5788">	/* Before we touch the hardware - wake it up */</a>
<a name="ln5789">	ATH_LOCK(sc);</a>
<a name="ln5790">	/*</a>
<a name="ln5791">	 * If the NIC is in anything other than SLEEP state,</a>
<a name="ln5792">	 * we need to ensure that self-generated frames are</a>
<a name="ln5793">	 * set for PWRMGT=0.  Otherwise we may end up with</a>
<a name="ln5794">	 * strange situations.</a>
<a name="ln5795">	 *</a>
<a name="ln5796">	 * XXX TODO: is this actually the case? :-)</a>
<a name="ln5797">	 */</a>
<a name="ln5798">	if (nstate != IEEE80211_S_SLEEP)</a>
<a name="ln5799">		ath_power_setselfgen(sc, HAL_PM_AWAKE);</a>
<a name="ln5800"> </a>
<a name="ln5801">	/*</a>
<a name="ln5802">	 * Now, wake the thing up.</a>
<a name="ln5803">	 */</a>
<a name="ln5804">	ath_power_set_power_state(sc, HAL_PM_AWAKE);</a>
<a name="ln5805"> </a>
<a name="ln5806">	/*</a>
<a name="ln5807">	 * And stop the calibration callout whilst we have</a>
<a name="ln5808">	 * ATH_LOCK held.</a>
<a name="ln5809">	 */</a>
<a name="ln5810">	callout_stop(&amp;sc-&gt;sc_cal_ch);</a>
<a name="ln5811">	ATH_UNLOCK(sc);</a>
<a name="ln5812"> </a>
<a name="ln5813">	if (ostate == IEEE80211_S_CSA &amp;&amp; nstate == IEEE80211_S_RUN)</a>
<a name="ln5814">		csa_run_transition = 1;</a>
<a name="ln5815"> </a>
<a name="ln5816">	ath_hal_setledstate(ah, leds[nstate]);	/* set LED */</a>
<a name="ln5817"> </a>
<a name="ln5818">	if (nstate == IEEE80211_S_SCAN) {</a>
<a name="ln5819">		/*</a>
<a name="ln5820">		 * Scanning: turn off beacon miss and don't beacon.</a>
<a name="ln5821">		 * Mark beacon state so when we reach RUN state we'll</a>
<a name="ln5822">		 * [re]setup beacons.  Unblock the task q thread so</a>
<a name="ln5823">		 * deferred interrupt processing is done.</a>
<a name="ln5824">		 */</a>
<a name="ln5825"> </a>
<a name="ln5826">		/* Ensure we stay awake during scan */</a>
<a name="ln5827">		ATH_LOCK(sc);</a>
<a name="ln5828">		ath_power_setselfgen(sc, HAL_PM_AWAKE);</a>
<a name="ln5829">		ath_power_setpower(sc, HAL_PM_AWAKE, 1);</a>
<a name="ln5830">		ATH_UNLOCK(sc);</a>
<a name="ln5831"> </a>
<a name="ln5832">		ath_hal_intrset(ah,</a>
<a name="ln5833">		    sc-&gt;sc_imask &amp;~ (HAL_INT_SWBA | HAL_INT_BMISS));</a>
<a name="ln5834">		sc-&gt;sc_imask &amp;= ~(HAL_INT_SWBA | HAL_INT_BMISS);</a>
<a name="ln5835">		sc-&gt;sc_beacons = 0;</a>
<a name="ln5836">		taskqueue_unblock(sc-&gt;sc_tq);</a>
<a name="ln5837">	}</a>
<a name="ln5838"> </a>
<a name="ln5839">	ni = ieee80211_ref_node(vap-&gt;iv_bss);</a>
<a name="ln5840">	rfilt = ath_calcrxfilter(sc);</a>
<a name="ln5841">	stamode = (vap-&gt;iv_opmode == IEEE80211_M_STA ||</a>
<a name="ln5842">		   vap-&gt;iv_opmode == IEEE80211_M_AHDEMO ||</a>
<a name="ln5843">		   vap-&gt;iv_opmode == IEEE80211_M_IBSS);</a>
<a name="ln5844"> </a>
<a name="ln5845">	/*</a>
<a name="ln5846">	 * XXX Dont need to do this (and others) if we've transitioned</a>
<a name="ln5847">	 * from SLEEP-&gt;RUN.</a>
<a name="ln5848">	 */</a>
<a name="ln5849">	if (stamode &amp;&amp; nstate == IEEE80211_S_RUN) {</a>
<a name="ln5850">		sc-&gt;sc_curaid = ni-&gt;ni_associd;</a>
<a name="ln5851">		IEEE80211_ADDR_COPY(sc-&gt;sc_curbssid, ni-&gt;ni_bssid);</a>
<a name="ln5852">		ath_hal_setassocid(ah, sc-&gt;sc_curbssid, sc-&gt;sc_curaid);</a>
<a name="ln5853">	}</a>
<a name="ln5854">	DPRINTF(sc, ATH_DEBUG_STATE, &quot;%s: RX filter 0x%x bssid %s aid 0x%x\n&quot;,</a>
<a name="ln5855">	   __func__, rfilt, ether_sprintf(sc-&gt;sc_curbssid), sc-&gt;sc_curaid);</a>
<a name="ln5856">	ath_hal_setrxfilter(ah, rfilt);</a>
<a name="ln5857"> </a>
<a name="ln5858">	/* XXX is this to restore keycache on resume? */</a>
<a name="ln5859">	if (vap-&gt;iv_opmode != IEEE80211_M_STA &amp;&amp;</a>
<a name="ln5860">	    (vap-&gt;iv_flags &amp; IEEE80211_F_PRIVACY)) {</a>
<a name="ln5861">		for (i = 0; i &lt; IEEE80211_WEP_NKID; i++)</a>
<a name="ln5862">			if (ath_hal_keyisvalid(ah, i))</a>
<a name="ln5863">				ath_hal_keysetmac(ah, i, ni-&gt;ni_bssid);</a>
<a name="ln5864">	}</a>
<a name="ln5865"> </a>
<a name="ln5866">	/*</a>
<a name="ln5867">	 * Invoke the parent method to do net80211 work.</a>
<a name="ln5868">	 */</a>
<a name="ln5869">	error = avp-&gt;av_newstate(vap, nstate, arg);</a>
<a name="ln5870">	if (error != 0)</a>
<a name="ln5871">		goto bad;</a>
<a name="ln5872"> </a>
<a name="ln5873">	/*</a>
<a name="ln5874">	 * See above: ensure av_newstate() doesn't drop the lock</a>
<a name="ln5875">	 * on us.</a>
<a name="ln5876">	 */</a>
<a name="ln5877">	IEEE80211_LOCK_ASSERT(ic);</a>
<a name="ln5878"> </a>
<a name="ln5879">	/*</a>
<a name="ln5880">	 * XXX TODO: if nstate is _S_CAC, then we should disable</a>
<a name="ln5881">	 * ACK processing until CAC is completed.</a>
<a name="ln5882">	 */</a>
<a name="ln5883"> </a>
<a name="ln5884">	/*</a>
<a name="ln5885">	 * XXX TODO: if we're on a passive channel, then we should</a>
<a name="ln5886">	 * not allow any ACKs or self-generated frames until we hear</a>
<a name="ln5887">	 * a beacon.  Unfortunately there isn't a notification from</a>
<a name="ln5888">	 * net80211 so perhaps we could slot that particular check</a>
<a name="ln5889">	 * into the mgmt receive path and just ensure that we clear</a>
<a name="ln5890">	 * it on RX of beacons in passive mode (and only clear it</a>
<a name="ln5891">	 * once, obviously.)</a>
<a name="ln5892">	 */</a>
<a name="ln5893"> </a>
<a name="ln5894">	/*</a>
<a name="ln5895">	 * XXX TODO: net80211 should be tracking whether channels</a>
<a name="ln5896">	 * have heard beacons and are thus considered &quot;OK&quot; for</a>
<a name="ln5897">	 * transmitting - and then inform the driver about this</a>
<a name="ln5898">	 * state change.  That way if we hear an AP go quiet</a>
<a name="ln5899">	 * (and nothing else is beaconing on a channel) the</a>
<a name="ln5900">	 * channel can go back to being passive until another</a>
<a name="ln5901">	 * beacon is heard.</a>
<a name="ln5902">	 */</a>
<a name="ln5903"> </a>
<a name="ln5904">	/*</a>
<a name="ln5905">	 * XXX TODO: if nstate is _S_CAC, then we should disable</a>
<a name="ln5906">	 * ACK processing until CAC is completed.</a>
<a name="ln5907">	 */</a>
<a name="ln5908"> </a>
<a name="ln5909">	/*</a>
<a name="ln5910">	 * XXX TODO: if we're on a passive channel, then we should</a>
<a name="ln5911">	 * not allow any ACKs or self-generated frames until we hear</a>
<a name="ln5912">	 * a beacon.  Unfortunately there isn't a notification from</a>
<a name="ln5913">	 * net80211 so perhaps we could slot that particular check</a>
<a name="ln5914">	 * into the mgmt receive path and just ensure that we clear</a>
<a name="ln5915">	 * it on RX of beacons in passive mode (and only clear it</a>
<a name="ln5916">	 * once, obviously.)</a>
<a name="ln5917">	 */</a>
<a name="ln5918"> </a>
<a name="ln5919">	/*</a>
<a name="ln5920">	 * XXX TODO: net80211 should be tracking whether channels</a>
<a name="ln5921">	 * have heard beacons and are thus considered &quot;OK&quot; for</a>
<a name="ln5922">	 * transmitting - and then inform the driver about this</a>
<a name="ln5923">	 * state change.  That way if we hear an AP go quiet</a>
<a name="ln5924">	 * (and nothing else is beaconing on a channel) the</a>
<a name="ln5925">	 * channel can go back to being passive until another</a>
<a name="ln5926">	 * beacon is heard.</a>
<a name="ln5927">	 */</a>
<a name="ln5928"> </a>
<a name="ln5929">	if (nstate == IEEE80211_S_RUN) {</a>
<a name="ln5930">		/* NB: collect bss node again, it may have changed */</a>
<a name="ln5931">		ieee80211_free_node(ni);</a>
<a name="ln5932">		ni = ieee80211_ref_node(vap-&gt;iv_bss);</a>
<a name="ln5933"> </a>
<a name="ln5934">		DPRINTF(sc, ATH_DEBUG_STATE,</a>
<a name="ln5935">		    &quot;%s(RUN): iv_flags 0x%08x bintvl %d bssid %s &quot;</a>
<a name="ln5936">		    &quot;capinfo 0x%04x chan %d\n&quot;, __func__,</a>
<a name="ln5937">		    vap-&gt;iv_flags, ni-&gt;ni_intval, ether_sprintf(ni-&gt;ni_bssid),</a>
<a name="ln5938">		    ni-&gt;ni_capinfo, ieee80211_chan2ieee(ic, ic-&gt;ic_curchan));</a>
<a name="ln5939"> </a>
<a name="ln5940">		switch (vap-&gt;iv_opmode) {</a>
<a name="ln5941">#ifdef IEEE80211_SUPPORT_TDMA</a>
<a name="ln5942">		case IEEE80211_M_AHDEMO:</a>
<a name="ln5943">			if ((vap-&gt;iv_caps &amp; IEEE80211_C_TDMA) == 0)</a>
<a name="ln5944">				break;</a>
<a name="ln5945">			/* fall thru... */</a>
<a name="ln5946">#endif</a>
<a name="ln5947">		case IEEE80211_M_HOSTAP:</a>
<a name="ln5948">		case IEEE80211_M_IBSS:</a>
<a name="ln5949">		case IEEE80211_M_MBSS:</a>
<a name="ln5950"> </a>
<a name="ln5951">			/*</a>
<a name="ln5952">			 * TODO: Enable ACK processing (ie, clear AR_DIAG_ACK_DIS.)</a>
<a name="ln5953">			 * For channels that are in CAC, we may have disabled</a>
<a name="ln5954">			 * this during CAC to ensure we don't ACK frames</a>
<a name="ln5955">			 * sent to us.</a>
<a name="ln5956">			 */</a>
<a name="ln5957"> </a>
<a name="ln5958">			/*</a>
<a name="ln5959">			 * Allocate and setup the beacon frame.</a>
<a name="ln5960">			 *</a>
<a name="ln5961">			 * Stop any previous beacon DMA.  This may be</a>
<a name="ln5962">			 * necessary, for example, when an ibss merge</a>
<a name="ln5963">			 * causes reconfiguration; there will be a state</a>
<a name="ln5964">			 * transition from RUN-&gt;RUN that means we may</a>
<a name="ln5965">			 * be called with beacon transmission active.</a>
<a name="ln5966">			 */</a>
<a name="ln5967">			ath_hal_stoptxdma(ah, sc-&gt;sc_bhalq);</a>
<a name="ln5968"> </a>
<a name="ln5969">			error = ath_beacon_alloc(sc, ni);</a>
<a name="ln5970">			if (error != 0)</a>
<a name="ln5971">				goto bad;</a>
<a name="ln5972">			/*</a>
<a name="ln5973">			 * If joining an adhoc network defer beacon timer</a>
<a name="ln5974">			 * configuration to the next beacon frame so we</a>
<a name="ln5975">			 * have a current TSF to use.  Otherwise we're</a>
<a name="ln5976">			 * starting an ibss/bss so there's no need to delay;</a>
<a name="ln5977">			 * if this is the first vap moving to RUN state, then</a>
<a name="ln5978">			 * beacon state needs to be [re]configured.</a>
<a name="ln5979">			 */</a>
<a name="ln5980">			if (vap-&gt;iv_opmode == IEEE80211_M_IBSS &amp;&amp;</a>
<a name="ln5981">			    ni-&gt;ni_tstamp.tsf != 0) {</a>
<a name="ln5982">				sc-&gt;sc_syncbeacon = 1;</a>
<a name="ln5983">			} else if (!sc-&gt;sc_beacons) {</a>
<a name="ln5984">#ifdef IEEE80211_SUPPORT_TDMA</a>
<a name="ln5985">				if (vap-&gt;iv_caps &amp; IEEE80211_C_TDMA)</a>
<a name="ln5986">					ath_tdma_config(sc, vap);</a>
<a name="ln5987">				else</a>
<a name="ln5988">#endif</a>
<a name="ln5989">					ath_beacon_config(sc, vap);</a>
<a name="ln5990">				sc-&gt;sc_beacons = 1;</a>
<a name="ln5991">			}</a>
<a name="ln5992">			break;</a>
<a name="ln5993">		case IEEE80211_M_STA:</a>
<a name="ln5994">			/*</a>
<a name="ln5995">			 * Defer beacon timer configuration to the next</a>
<a name="ln5996">			 * beacon frame so we have a current TSF to use</a>
<a name="ln5997">			 * (any TSF collected when scanning is likely old).</a>
<a name="ln5998">			 * However if it's due to a CSA -&gt; RUN transition,</a>
<a name="ln5999">			 * force a beacon update so we pick up a lack of</a>
<a name="ln6000">			 * beacons from an AP in CAC and thus force a</a>
<a name="ln6001">			 * scan.</a>
<a name="ln6002">			 *</a>
<a name="ln6003">			 * And, there's also corner cases here where</a>
<a name="ln6004">			 * after a scan, the AP may have disappeared.</a>
<a name="ln6005">			 * In that case, we may not receive an actual</a>
<a name="ln6006">			 * beacon to update the beacon timer and thus we</a>
<a name="ln6007">			 * won't get notified of the missing beacons.</a>
<a name="ln6008">			 */</a>
<a name="ln6009">			if (ostate != IEEE80211_S_RUN &amp;&amp;</a>
<a name="ln6010">			    ostate != IEEE80211_S_SLEEP) {</a>
<a name="ln6011">				DPRINTF(sc, ATH_DEBUG_BEACON,</a>
<a name="ln6012">				    &quot;%s: STA; syncbeacon=1\n&quot;, __func__);</a>
<a name="ln6013">				sc-&gt;sc_syncbeacon = 1;</a>
<a name="ln6014"> </a>
<a name="ln6015">				/* Quiet time handling - ensure we resync */</a>
<a name="ln6016">				memset(&amp;avp-&gt;quiet_ie, 0, sizeof(avp-&gt;quiet_ie));</a>
<a name="ln6017"> </a>
<a name="ln6018">				if (csa_run_transition)</a>
<a name="ln6019">					ath_beacon_config(sc, vap);</a>
<a name="ln6020"> </a>
<a name="ln6021">			/*</a>
<a name="ln6022">			 * PR: kern/175227</a>
<a name="ln6023">			 *</a>
<a name="ln6024">			 * Reconfigure beacons during reset; as otherwise</a>
<a name="ln6025">			 * we won't get the beacon timers reprogrammed</a>
<a name="ln6026">			 * after a reset and thus we won't pick up a</a>
<a name="ln6027">			 * beacon miss interrupt.</a>
<a name="ln6028">			 *</a>
<a name="ln6029">			 * Hopefully we'll see a beacon before the BMISS</a>
<a name="ln6030">			 * timer fires (too often), leading to a STA</a>
<a name="ln6031">			 * disassociation.</a>
<a name="ln6032">			 */</a>
<a name="ln6033">				sc-&gt;sc_beacons = 1;</a>
<a name="ln6034">			}</a>
<a name="ln6035">			break;</a>
<a name="ln6036">		case IEEE80211_M_MONITOR:</a>
<a name="ln6037">			/*</a>
<a name="ln6038">			 * Monitor mode vaps have only INIT-&gt;RUN and RUN-&gt;RUN</a>
<a name="ln6039">			 * transitions so we must re-enable interrupts here to</a>
<a name="ln6040">			 * handle the case of a single monitor mode vap.</a>
<a name="ln6041">			 */</a>
<a name="ln6042">			ath_hal_intrset(ah, sc-&gt;sc_imask);</a>
<a name="ln6043">			break;</a>
<a name="ln6044">		case IEEE80211_M_WDS:</a>
<a name="ln6045">			break;</a>
<a name="ln6046">		default:</a>
<a name="ln6047">			break;</a>
<a name="ln6048">		}</a>
<a name="ln6049">		/*</a>
<a name="ln6050">		 * Let the hal process statistics collected during a</a>
<a name="ln6051">		 * scan so it can provide calibrated noise floor data.</a>
<a name="ln6052">		 */</a>
<a name="ln6053">		ath_hal_process_noisefloor(ah);</a>
<a name="ln6054">		/*</a>
<a name="ln6055">		 * Reset rssi stats; maybe not the best place...</a>
<a name="ln6056">		 */</a>
<a name="ln6057">		sc-&gt;sc_halstats.ns_avgbrssi = ATH_RSSI_DUMMY_MARKER;</a>
<a name="ln6058">		sc-&gt;sc_halstats.ns_avgrssi = ATH_RSSI_DUMMY_MARKER;</a>
<a name="ln6059">		sc-&gt;sc_halstats.ns_avgtxrssi = ATH_RSSI_DUMMY_MARKER;</a>
<a name="ln6060"> </a>
<a name="ln6061">		/*</a>
<a name="ln6062">		 * Force awake for RUN mode.</a>
<a name="ln6063">		 */</a>
<a name="ln6064">		ATH_LOCK(sc);</a>
<a name="ln6065">		ath_power_setselfgen(sc, HAL_PM_AWAKE);</a>
<a name="ln6066">		ath_power_setpower(sc, HAL_PM_AWAKE, 1);</a>
<a name="ln6067"> </a>
<a name="ln6068">		/*</a>
<a name="ln6069">		 * Finally, start any timers and the task q thread</a>
<a name="ln6070">		 * (in case we didn't go through SCAN state).</a>
<a name="ln6071">		 */</a>
<a name="ln6072">		if (ath_longcalinterval != 0) {</a>
<a name="ln6073">			/* start periodic recalibration timer */</a>
<a name="ln6074">			callout_reset(&amp;sc-&gt;sc_cal_ch, 1, ath_calibrate, sc);</a>
<a name="ln6075">		} else {</a>
<a name="ln6076">			DPRINTF(sc, ATH_DEBUG_CALIBRATE,</a>
<a name="ln6077">			    &quot;%s: calibration disabled\n&quot;, __func__);</a>
<a name="ln6078">		}</a>
<a name="ln6079">		ATH_UNLOCK(sc);</a>
<a name="ln6080"> </a>
<a name="ln6081">		taskqueue_unblock(sc-&gt;sc_tq);</a>
<a name="ln6082">	} else if (nstate == IEEE80211_S_INIT) {</a>
<a name="ln6083"> </a>
<a name="ln6084">		/* Quiet time handling - ensure we resync */</a>
<a name="ln6085">		memset(&amp;avp-&gt;quiet_ie, 0, sizeof(avp-&gt;quiet_ie));</a>
<a name="ln6086"> </a>
<a name="ln6087">		/*</a>
<a name="ln6088">		 * If there are no vaps left in RUN state then</a>
<a name="ln6089">		 * shutdown host/driver operation:</a>
<a name="ln6090">		 * o disable interrupts</a>
<a name="ln6091">		 * o disable the task queue thread</a>
<a name="ln6092">		 * o mark beacon processing as stopped</a>
<a name="ln6093">		 */</a>
<a name="ln6094">		if (!ath_isanyrunningvaps(vap)) {</a>
<a name="ln6095">			sc-&gt;sc_imask &amp;= ~(HAL_INT_SWBA | HAL_INT_BMISS);</a>
<a name="ln6096">			/* disable interrupts  */</a>
<a name="ln6097">			ath_hal_intrset(ah, sc-&gt;sc_imask &amp;~ HAL_INT_GLOBAL);</a>
<a name="ln6098">			taskqueue_block(sc-&gt;sc_tq);</a>
<a name="ln6099">			sc-&gt;sc_beacons = 0;</a>
<a name="ln6100">		}</a>
<a name="ln6101">#ifdef IEEE80211_SUPPORT_TDMA</a>
<a name="ln6102">		ath_hal_setcca(ah, AH_TRUE);</a>
<a name="ln6103">#endif</a>
<a name="ln6104">	} else if (nstate == IEEE80211_S_SLEEP) {</a>
<a name="ln6105">		/* We're going to sleep, so transition appropriately */</a>
<a name="ln6106">		/* For now, only do this if we're a single STA vap */</a>
<a name="ln6107">		if (sc-&gt;sc_nvaps == 1 &amp;&amp;</a>
<a name="ln6108">		    vap-&gt;iv_opmode == IEEE80211_M_STA) {</a>
<a name="ln6109">			DPRINTF(sc, ATH_DEBUG_BEACON, &quot;%s: syncbeacon=%d\n&quot;, __func__, sc-&gt;sc_syncbeacon);</a>
<a name="ln6110">			ATH_LOCK(sc);</a>
<a name="ln6111">			/*</a>
<a name="ln6112">			 * Always at least set the self-generated</a>
<a name="ln6113">			 * frame config to set PWRMGT=1.</a>
<a name="ln6114">			 */</a>
<a name="ln6115">			ath_power_setselfgen(sc, HAL_PM_NETWORK_SLEEP);</a>
<a name="ln6116"> </a>
<a name="ln6117">			/*</a>
<a name="ln6118">			 * If we're not syncing beacons, transition</a>
<a name="ln6119">			 * to NETWORK_SLEEP.</a>
<a name="ln6120">			 *</a>
<a name="ln6121">			 * We stay awake if syncbeacon &gt; 0 in case</a>
<a name="ln6122">			 * we need to listen for some beacons otherwise</a>
<a name="ln6123">			 * our beacon timer config may be wrong.</a>
<a name="ln6124">			 */</a>
<a name="ln6125">			if (sc-&gt;sc_syncbeacon == 0) {</a>
<a name="ln6126">				ath_power_setpower(sc, HAL_PM_NETWORK_SLEEP, 1);</a>
<a name="ln6127">			}</a>
<a name="ln6128">			ATH_UNLOCK(sc);</a>
<a name="ln6129">		}</a>
<a name="ln6130">	} else if (nstate == IEEE80211_S_SCAN) {</a>
<a name="ln6131">		/* Quiet time handling - ensure we resync */</a>
<a name="ln6132">		memset(&amp;avp-&gt;quiet_ie, 0, sizeof(avp-&gt;quiet_ie));</a>
<a name="ln6133">	}</a>
<a name="ln6134">bad:</a>
<a name="ln6135">	ieee80211_free_node(ni);</a>
<a name="ln6136"> </a>
<a name="ln6137">	/*</a>
<a name="ln6138">	 * Restore the power state - either to what it was, or</a>
<a name="ln6139">	 * to network_sleep if it's alright.</a>
<a name="ln6140">	 */</a>
<a name="ln6141">	ATH_LOCK(sc);</a>
<a name="ln6142">	ath_power_restore_power_state(sc);</a>
<a name="ln6143">	ATH_UNLOCK(sc);</a>
<a name="ln6144">	return error;</a>
<a name="ln6145">}</a>
<a name="ln6146"> </a>
<a name="ln6147">/*</a>
<a name="ln6148"> * Allocate a key cache slot to the station so we can</a>
<a name="ln6149"> * setup a mapping from key index to node. The key cache</a>
<a name="ln6150"> * slot is needed for managing antenna state and for</a>
<a name="ln6151"> * compression when stations do not use crypto.  We do</a>
<a name="ln6152"> * it uniliaterally here; if crypto is employed this slot</a>
<a name="ln6153"> * will be reassigned.</a>
<a name="ln6154"> */</a>
<a name="ln6155">static void</a>
<a name="ln6156">ath_setup_stationkey(struct ieee80211_node *ni)</a>
<a name="ln6157">{</a>
<a name="ln6158">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln6159">	struct ath_softc *sc = vap-&gt;iv_ic-&gt;ic_softc;</a>
<a name="ln6160">	ieee80211_keyix keyix, rxkeyix;</a>
<a name="ln6161"> </a>
<a name="ln6162">	/* XXX should take a locked ref to vap-&gt;iv_bss */</a>
<a name="ln6163">	if (!ath_key_alloc(vap, &amp;ni-&gt;ni_ucastkey, &amp;keyix, &amp;rxkeyix)) {</a>
<a name="ln6164">		/*</a>
<a name="ln6165">		 * Key cache is full; we'll fall back to doing</a>
<a name="ln6166">		 * the more expensive lookup in software.  Note</a>
<a name="ln6167">		 * this also means no h/w compression.</a>
<a name="ln6168">		 */</a>
<a name="ln6169">		/* XXX msg+statistic */</a>
<a name="ln6170">	} else {</a>
<a name="ln6171">		/* XXX locking? */</a>
<a name="ln6172">		ni-&gt;ni_ucastkey.wk_keyix = keyix;</a>
<a name="ln6173">		ni-&gt;ni_ucastkey.wk_rxkeyix = rxkeyix;</a>
<a name="ln6174">		/* NB: must mark device key to get called back on delete */</a>
<a name="ln6175">		ni-&gt;ni_ucastkey.wk_flags |= IEEE80211_KEY_DEVKEY;</a>
<a name="ln6176">		IEEE80211_ADDR_COPY(ni-&gt;ni_ucastkey.wk_macaddr, ni-&gt;ni_macaddr);</a>
<a name="ln6177">		/* NB: this will create a pass-thru key entry */</a>
<a name="ln6178">		ath_keyset(sc, vap, &amp;ni-&gt;ni_ucastkey, vap-&gt;iv_bss);</a>
<a name="ln6179">	}</a>
<a name="ln6180">}</a>
<a name="ln6181"> </a>
<a name="ln6182">/*</a>
<a name="ln6183"> * Setup driver-specific state for a newly associated node.</a>
<a name="ln6184"> * Note that we're called also on a re-associate, the isnew</a>
<a name="ln6185"> * param tells us if this is the first time or not.</a>
<a name="ln6186"> */</a>
<a name="ln6187">static void</a>
<a name="ln6188">ath_newassoc(struct ieee80211_node *ni, int isnew)</a>
<a name="ln6189">{</a>
<a name="ln6190">	struct ath_node *an = ATH_NODE(ni);</a>
<a name="ln6191">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln6192">	struct ath_softc *sc = vap-&gt;iv_ic-&gt;ic_softc;</a>
<a name="ln6193">	const struct ieee80211_txparam *tp = ni-&gt;ni_txparms;</a>
<a name="ln6194"> </a>
<a name="ln6195">	an-&gt;an_mcastrix = ath_tx_findrix(sc, tp-&gt;mcastrate);</a>
<a name="ln6196">	an-&gt;an_mgmtrix = ath_tx_findrix(sc, tp-&gt;mgmtrate);</a>
<a name="ln6197"> </a>
<a name="ln6198">	DPRINTF(sc, ATH_DEBUG_NODE, &quot;%s: %6D: reassoc; isnew=%d, is_powersave=%d\n&quot;,</a>
<a name="ln6199">	    __func__,</a>
<a name="ln6200">	    ni-&gt;ni_macaddr,</a>
<a name="ln6201">	    &quot;:&quot;,</a>
<a name="ln6202">	    isnew,</a>
<a name="ln6203">	    an-&gt;an_is_powersave);</a>
<a name="ln6204"> </a>
<a name="ln6205">	ATH_NODE_LOCK(an);</a>
<a name="ln6206">	ath_rate_newassoc(sc, an, isnew);</a>
<a name="ln6207">	ATH_NODE_UNLOCK(an);</a>
<a name="ln6208"> </a>
<a name="ln6209">	if (isnew &amp;&amp;</a>
<a name="ln6210">	    (vap-&gt;iv_flags &amp; IEEE80211_F_PRIVACY) == 0 &amp;&amp; sc-&gt;sc_hasclrkey &amp;&amp;</a>
<a name="ln6211">	    ni-&gt;ni_ucastkey.wk_keyix == IEEE80211_KEYIX_NONE)</a>
<a name="ln6212">		ath_setup_stationkey(ni);</a>
<a name="ln6213"> </a>
<a name="ln6214">	/*</a>
<a name="ln6215">	 * If we're reassociating, make sure that any paused queues</a>
<a name="ln6216">	 * get unpaused.</a>
<a name="ln6217">	 *</a>
<a name="ln6218">	 * Now, we may have frames in the hardware queue for this node.</a>
<a name="ln6219">	 * So if we are reassociating and there are frames in the queue,</a>
<a name="ln6220">	 * we need to go through the cleanup path to ensure that they're</a>
<a name="ln6221">	 * marked as non-aggregate.</a>
<a name="ln6222">	 */</a>
<a name="ln6223">	if (! isnew) {</a>
<a name="ln6224">		DPRINTF(sc, ATH_DEBUG_NODE,</a>
<a name="ln6225">		    &quot;%s: %6D: reassoc; is_powersave=%d\n&quot;,</a>
<a name="ln6226">		    __func__,</a>
<a name="ln6227">		    ni-&gt;ni_macaddr,</a>
<a name="ln6228">		    &quot;:&quot;,</a>
<a name="ln6229">		    an-&gt;an_is_powersave);</a>
<a name="ln6230"> </a>
<a name="ln6231">		/* XXX for now, we can't hold the lock across assoc */</a>
<a name="ln6232">		ath_tx_node_reassoc(sc, an);</a>
<a name="ln6233"> </a>
<a name="ln6234">		/* XXX for now, we can't hold the lock across wakeup */</a>
<a name="ln6235">		if (an-&gt;an_is_powersave)</a>
<a name="ln6236">			ath_tx_node_wakeup(sc, an);</a>
<a name="ln6237">	}</a>
<a name="ln6238">}</a>
<a name="ln6239"> </a>
<a name="ln6240">static int</a>
<a name="ln6241">ath_setregdomain(struct ieee80211com *ic, struct ieee80211_regdomain *reg,</a>
<a name="ln6242">	int nchans, struct ieee80211_channel chans[])</a>
<a name="ln6243">{</a>
<a name="ln6244">	struct ath_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln6245">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln6246">	HAL_STATUS status;</a>
<a name="ln6247"> </a>
<a name="ln6248">	DPRINTF(sc, ATH_DEBUG_REGDOMAIN,</a>
<a name="ln6249">	    &quot;%s: rd %u cc %u location %c%s\n&quot;,</a>
<a name="ln6250">	    __func__, reg-&gt;regdomain, reg-&gt;country, reg-&gt;location,</a>
<a name="ln6251">	    reg-&gt;ecm ? &quot; ecm&quot; : &quot;&quot;);</a>
<a name="ln6252"> </a>
<a name="ln6253">	status = ath_hal_set_channels(ah, chans, nchans,</a>
<a name="ln6254">	    reg-&gt;country, reg-&gt;regdomain);</a>
<a name="ln6255">	if (status != HAL_OK) {</a>
<a name="ln6256">		DPRINTF(sc, ATH_DEBUG_REGDOMAIN, &quot;%s: failed, status %u\n&quot;,</a>
<a name="ln6257">		    __func__, status);</a>
<a name="ln6258">		return EINVAL;		/* XXX */</a>
<a name="ln6259">	}</a>
<a name="ln6260"> </a>
<a name="ln6261">	return 0;</a>
<a name="ln6262">}</a>
<a name="ln6263"> </a>
<a name="ln6264">static void</a>
<a name="ln6265">ath_getradiocaps(struct ieee80211com *ic,</a>
<a name="ln6266">	int maxchans, int *nchans, struct ieee80211_channel chans[])</a>
<a name="ln6267">{</a>
<a name="ln6268">	struct ath_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln6269">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln6270"> </a>
<a name="ln6271">	DPRINTF(sc, ATH_DEBUG_REGDOMAIN, &quot;%s: use rd %u cc %d\n&quot;,</a>
<a name="ln6272">	    __func__, SKU_DEBUG, CTRY_DEFAULT);</a>
<a name="ln6273"> </a>
<a name="ln6274">	/* XXX check return */</a>
<a name="ln6275">	(void) ath_hal_getchannels(ah, chans, maxchans, nchans,</a>
<a name="ln6276">	    HAL_MODE_ALL, CTRY_DEFAULT, SKU_DEBUG, AH_TRUE);</a>
<a name="ln6277"> </a>
<a name="ln6278">}</a>
<a name="ln6279"> </a>
<a name="ln6280">static int</a>
<a name="ln6281">ath_getchannels(struct ath_softc *sc)</a>
<a name="ln6282">{</a>
<a name="ln6283">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln6284">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln6285">	HAL_STATUS status;</a>
<a name="ln6286"> </a>
<a name="ln6287">	/*</a>
<a name="ln6288">	 * Collect channel set based on EEPROM contents.</a>
<a name="ln6289">	 */</a>
<a name="ln6290">	status = ath_hal_init_channels(ah, ic-&gt;ic_channels, IEEE80211_CHAN_MAX,</a>
<a name="ln6291">	    &amp;ic-&gt;ic_nchans, HAL_MODE_ALL, CTRY_DEFAULT, SKU_NONE, AH_TRUE);</a>
<a name="ln6292">	if (status != HAL_OK) {</a>
<a name="ln6293">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln6294">		    &quot;%s: unable to collect channel list from hal, status %d\n&quot;,</a>
<a name="ln6295">		    __func__, status);</a>
<a name="ln6296">		return EINVAL;</a>
<a name="ln6297">	}</a>
<a name="ln6298">	(void) ath_hal_getregdomain(ah, &amp;sc-&gt;sc_eerd);</a>
<a name="ln6299">	ath_hal_getcountrycode(ah, &amp;sc-&gt;sc_eecc);	/* NB: cannot fail */</a>
<a name="ln6300">	/* XXX map Atheros sku's to net80211 SKU's */</a>
<a name="ln6301">	/* XXX net80211 types too small */</a>
<a name="ln6302">	ic-&gt;ic_regdomain.regdomain = (uint16_t) sc-&gt;sc_eerd;</a>
<a name="ln6303">	ic-&gt;ic_regdomain.country = (uint16_t) sc-&gt;sc_eecc;</a>
<a name="ln6304">	ic-&gt;ic_regdomain.isocc[0] = ' ';	/* XXX don't know */</a>
<a name="ln6305">	ic-&gt;ic_regdomain.isocc[1] = ' ';</a>
<a name="ln6306"> </a>
<a name="ln6307">	ic-&gt;ic_regdomain.ecm = 1;</a>
<a name="ln6308">	ic-&gt;ic_regdomain.location = 'I';</a>
<a name="ln6309"> </a>
<a name="ln6310">	DPRINTF(sc, ATH_DEBUG_REGDOMAIN,</a>
<a name="ln6311">	    &quot;%s: eeprom rd %u cc %u (mapped rd %u cc %u) location %c%s\n&quot;,</a>
<a name="ln6312">	    __func__, sc-&gt;sc_eerd, sc-&gt;sc_eecc,</a>
<a name="ln6313">	    ic-&gt;ic_regdomain.regdomain, ic-&gt;ic_regdomain.country,</a>
<a name="ln6314">	    ic-&gt;ic_regdomain.location, ic-&gt;ic_regdomain.ecm ? &quot; ecm&quot; : &quot;&quot;);</a>
<a name="ln6315">	return 0;</a>
<a name="ln6316">}</a>
<a name="ln6317"> </a>
<a name="ln6318">static int</a>
<a name="ln6319">ath_rate_setup(struct ath_softc *sc, u_int mode)</a>
<a name="ln6320">{</a>
<a name="ln6321">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln6322">	const HAL_RATE_TABLE *rt;</a>
<a name="ln6323"> </a>
<a name="ln6324">	switch (mode) {</a>
<a name="ln6325">	case IEEE80211_MODE_11A:</a>
<a name="ln6326">		rt = ath_hal_getratetable(ah, HAL_MODE_11A);</a>
<a name="ln6327">		break;</a>
<a name="ln6328">	case IEEE80211_MODE_HALF:</a>
<a name="ln6329">		rt = ath_hal_getratetable(ah, HAL_MODE_11A_HALF_RATE);</a>
<a name="ln6330">		break;</a>
<a name="ln6331">	case IEEE80211_MODE_QUARTER:</a>
<a name="ln6332">		rt = ath_hal_getratetable(ah, HAL_MODE_11A_QUARTER_RATE);</a>
<a name="ln6333">		break;</a>
<a name="ln6334">	case IEEE80211_MODE_11B:</a>
<a name="ln6335">		rt = ath_hal_getratetable(ah, HAL_MODE_11B);</a>
<a name="ln6336">		break;</a>
<a name="ln6337">	case IEEE80211_MODE_11G:</a>
<a name="ln6338">		rt = ath_hal_getratetable(ah, HAL_MODE_11G);</a>
<a name="ln6339">		break;</a>
<a name="ln6340">	case IEEE80211_MODE_TURBO_A:</a>
<a name="ln6341">		rt = ath_hal_getratetable(ah, HAL_MODE_108A);</a>
<a name="ln6342">		break;</a>
<a name="ln6343">	case IEEE80211_MODE_TURBO_G:</a>
<a name="ln6344">		rt = ath_hal_getratetable(ah, HAL_MODE_108G);</a>
<a name="ln6345">		break;</a>
<a name="ln6346">	case IEEE80211_MODE_STURBO_A:</a>
<a name="ln6347">		rt = ath_hal_getratetable(ah, HAL_MODE_TURBO);</a>
<a name="ln6348">		break;</a>
<a name="ln6349">	case IEEE80211_MODE_11NA:</a>
<a name="ln6350">		rt = ath_hal_getratetable(ah, HAL_MODE_11NA_HT20);</a>
<a name="ln6351">		break;</a>
<a name="ln6352">	case IEEE80211_MODE_11NG:</a>
<a name="ln6353">		rt = ath_hal_getratetable(ah, HAL_MODE_11NG_HT20);</a>
<a name="ln6354">		break;</a>
<a name="ln6355">	default:</a>
<a name="ln6356">		DPRINTF(sc, ATH_DEBUG_ANY, &quot;%s: invalid mode %u\n&quot;,</a>
<a name="ln6357">			__func__, mode);</a>
<a name="ln6358">		return 0;</a>
<a name="ln6359">	}</a>
<a name="ln6360">	sc-&gt;sc_rates[mode] = rt;</a>
<a name="ln6361">	return (rt != NULL);</a>
<a name="ln6362">}</a>
<a name="ln6363"> </a>
<a name="ln6364">static void</a>
<a name="ln6365">ath_setcurmode(struct ath_softc *sc, enum ieee80211_phymode mode)</a>
<a name="ln6366">{</a>
<a name="ln6367">	/* NB: on/off times from the Atheros NDIS driver, w/ permission */</a>
<a name="ln6368">	static const struct {</a>
<a name="ln6369">		u_int		rate;		/* tx/rx 802.11 rate */</a>
<a name="ln6370">		u_int16_t	timeOn;		/* LED on time (ms) */</a>
<a name="ln6371">		u_int16_t	timeOff;	/* LED off time (ms) */</a>
<a name="ln6372">	} blinkrates[] = {</a>
<a name="ln6373">		{ 108,  40,  10 },</a>
<a name="ln6374">		{  96,  44,  11 },</a>
<a name="ln6375">		{  72,  50,  13 },</a>
<a name="ln6376">		{  48,  57,  14 },</a>
<a name="ln6377">		{  36,  67,  16 },</a>
<a name="ln6378">		{  24,  80,  20 },</a>
<a name="ln6379">		{  22, 100,  25 },</a>
<a name="ln6380">		{  18, 133,  34 },</a>
<a name="ln6381">		{  12, 160,  40 },</a>
<a name="ln6382">		{  10, 200,  50 },</a>
<a name="ln6383">		{   6, 240,  58 },</a>
<a name="ln6384">		{   4, 267,  66 },</a>
<a name="ln6385">		{   2, 400, 100 },</a>
<a name="ln6386">		{   0, 500, 130 },</a>
<a name="ln6387">		/* XXX half/quarter rates */</a>
<a name="ln6388">	};</a>
<a name="ln6389">	const HAL_RATE_TABLE *rt;</a>
<a name="ln6390">	int i, j;</a>
<a name="ln6391"> </a>
<a name="ln6392">	memset(sc-&gt;sc_rixmap, 0xff, sizeof(sc-&gt;sc_rixmap));</a>
<a name="ln6393">	rt = sc-&gt;sc_rates[mode];</a>
<a name="ln6394">	KASSERT(rt != NULL, (&quot;no h/w rate set for phy mode %u&quot;, mode));</a>
<a name="ln6395">	for (i = 0; i &lt; rt-&gt;rateCount; i++) {</a>
<a name="ln6396">		uint8_t ieeerate = rt-&gt;info[i].dot11Rate &amp; IEEE80211_RATE_VAL;</a>
<a name="ln6397">		if (rt-&gt;info[i].phy != IEEE80211_T_HT)</a>
<a name="ln6398">			sc-&gt;sc_rixmap[ieeerate] = i;</a>
<a name="ln6399">		else</a>
<a name="ln6400">			sc-&gt;sc_rixmap[ieeerate | IEEE80211_RATE_MCS] = i;</a>
<a name="ln6401">	}</a>
<a name="ln6402">	memset(sc-&gt;sc_hwmap, 0, sizeof(sc-&gt;sc_hwmap));</a>
<a name="ln6403">	for (i = 0; i &lt; nitems(sc-&gt;sc_hwmap); i++) {</a>
<a name="ln6404">		if (i &gt;= rt-&gt;rateCount) {</a>
<a name="ln6405">			sc-&gt;sc_hwmap[i].ledon = (500 * hz) / 1000;</a>
<a name="ln6406">			sc-&gt;sc_hwmap[i].ledoff = (130 * hz) / 1000;</a>
<a name="ln6407">			continue;</a>
<a name="ln6408">		}</a>
<a name="ln6409">		sc-&gt;sc_hwmap[i].ieeerate =</a>
<a name="ln6410">			rt-&gt;info[i].dot11Rate &amp; IEEE80211_RATE_VAL;</a>
<a name="ln6411">		if (rt-&gt;info[i].phy == IEEE80211_T_HT)</a>
<a name="ln6412">			sc-&gt;sc_hwmap[i].ieeerate |= IEEE80211_RATE_MCS;</a>
<a name="ln6413">		sc-&gt;sc_hwmap[i].txflags = IEEE80211_RADIOTAP_F_DATAPAD;</a>
<a name="ln6414">		if (rt-&gt;info[i].shortPreamble ||</a>
<a name="ln6415">		    rt-&gt;info[i].phy == IEEE80211_T_OFDM)</a>
<a name="ln6416">			sc-&gt;sc_hwmap[i].txflags |= IEEE80211_RADIOTAP_F_SHORTPRE;</a>
<a name="ln6417">		sc-&gt;sc_hwmap[i].rxflags = sc-&gt;sc_hwmap[i].txflags;</a>
<a name="ln6418">		for (j = 0; j &lt; nitems(blinkrates)-1; j++)</a>
<a name="ln6419">			if (blinkrates[j].rate == sc-&gt;sc_hwmap[i].ieeerate)</a>
<a name="ln6420">				break;</a>
<a name="ln6421">		/* NB: this uses the last entry if the rate isn't found */</a>
<a name="ln6422">		/* XXX beware of overlow */</a>
<a name="ln6423">		sc-&gt;sc_hwmap[i].ledon = (blinkrates[j].timeOn * hz) / 1000;</a>
<a name="ln6424">		sc-&gt;sc_hwmap[i].ledoff = (blinkrates[j].timeOff * hz) / 1000;</a>
<a name="ln6425">	}</a>
<a name="ln6426">	sc-&gt;sc_currates = rt;</a>
<a name="ln6427">	sc-&gt;sc_curmode = mode;</a>
<a name="ln6428">	/*</a>
<a name="ln6429">	 * All protection frames are transmitted at 2Mb/s for</a>
<a name="ln6430">	 * 11g, otherwise at 1Mb/s.</a>
<a name="ln6431">	 */</a>
<a name="ln6432">	if (mode == IEEE80211_MODE_11G)</a>
<a name="ln6433">		sc-&gt;sc_protrix = ath_tx_findrix(sc, 2*2);</a>
<a name="ln6434">	else</a>
<a name="ln6435">		sc-&gt;sc_protrix = ath_tx_findrix(sc, 2*1);</a>
<a name="ln6436">	/* NB: caller is responsible for resetting rate control state */</a>
<a name="ln6437">}</a>
<a name="ln6438"> </a>
<a name="ln6439">static void</a>
<a name="ln6440">ath_watchdog(void *arg)</a>
<a name="ln6441">{</a>
<a name="ln6442">	struct ath_softc *sc = arg;</a>
<a name="ln6443">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln6444">	int do_reset = 0;</a>
<a name="ln6445"> </a>
<a name="ln6446">	ATH_LOCK_ASSERT(sc);</a>
<a name="ln6447"> </a>
<a name="ln6448">	if (sc-&gt;sc_wd_timer != 0 &amp;&amp; --sc-&gt;sc_wd_timer == 0) {</a>
<a name="ln6449">		uint32_t hangs;</a>
<a name="ln6450"> </a>
<a name="ln6451">		ath_power_set_power_state(sc, HAL_PM_AWAKE);</a>
<a name="ln6452"> </a>
<a name="ln6453">		if (ath_hal_gethangstate(sc-&gt;sc_ah, 0xffff, &amp;hangs) &amp;&amp;</a>
<a name="ln6454">		    hangs != 0) {</a>
<a name="ln6455">			device_printf(sc-&gt;sc_dev, &quot;%s hang detected (0x%x)\n&quot;,</a>
<a name="ln6456">			    hangs &amp; 0xff ? &quot;bb&quot; : &quot;mac&quot;, hangs);</a>
<a name="ln6457">		} else</a>
<a name="ln6458">			device_printf(sc-&gt;sc_dev, &quot;device timeout\n&quot;);</a>
<a name="ln6459">		do_reset = 1;</a>
<a name="ln6460">		counter_u64_add(ic-&gt;ic_oerrors, 1);</a>
<a name="ln6461">		sc-&gt;sc_stats.ast_watchdog++;</a>
<a name="ln6462"> </a>
<a name="ln6463">		ath_power_restore_power_state(sc);</a>
<a name="ln6464">	}</a>
<a name="ln6465"> </a>
<a name="ln6466">	/*</a>
<a name="ln6467">	 * We can't hold the lock across the ath_reset() call.</a>
<a name="ln6468">	 *</a>
<a name="ln6469">	 * And since this routine can't hold a lock and sleep,</a>
<a name="ln6470">	 * do the reset deferred.</a>
<a name="ln6471">	 */</a>
<a name="ln6472">	if (do_reset) {</a>
<a name="ln6473">		taskqueue_enqueue(sc-&gt;sc_tq, &amp;sc-&gt;sc_resettask);</a>
<a name="ln6474">	}</a>
<a name="ln6475"> </a>
<a name="ln6476">	callout_schedule(&amp;sc-&gt;sc_wd_ch, hz);</a>
<a name="ln6477">}</a>
<a name="ln6478"> </a>
<a name="ln6479">static void</a>
<a name="ln6480">ath_parent(struct ieee80211com *ic)</a>
<a name="ln6481">{</a>
<a name="ln6482">	struct ath_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln6483">	int error = EDOOFUS;</a>
<a name="ln6484"> </a>
<a name="ln6485">	ATH_LOCK(sc);</a>
<a name="ln6486">	if (ic-&gt;ic_nrunning &gt; 0) {</a>
<a name="ln6487">		/*</a>
<a name="ln6488">		 * To avoid rescanning another access point,</a>
<a name="ln6489">		 * do not call ath_init() here.  Instead,</a>
<a name="ln6490">		 * only reflect promisc mode settings.</a>
<a name="ln6491">		 */</a>
<a name="ln6492">		if (sc-&gt;sc_running) {</a>
<a name="ln6493">			ath_power_set_power_state(sc, HAL_PM_AWAKE);</a>
<a name="ln6494">			ath_mode_init(sc);</a>
<a name="ln6495">			ath_power_restore_power_state(sc);</a>
<a name="ln6496">		} else if (!sc-&gt;sc_invalid) {</a>
<a name="ln6497">			/*</a>
<a name="ln6498">			 * Beware of being called during attach/detach</a>
<a name="ln6499">			 * to reset promiscuous mode.  In that case we</a>
<a name="ln6500">			 * will still be marked UP but not RUNNING.</a>
<a name="ln6501">			 * However trying to re-init the interface</a>
<a name="ln6502">			 * is the wrong thing to do as we've already</a>
<a name="ln6503">			 * torn down much of our state.  There's</a>
<a name="ln6504">			 * probably a better way to deal with this.</a>
<a name="ln6505">			 */</a>
<a name="ln6506">			error = ath_init(sc);</a>
<a name="ln6507">		}</a>
<a name="ln6508">	} else {</a>
<a name="ln6509">		ath_stop(sc);</a>
<a name="ln6510">		if (!sc-&gt;sc_invalid)</a>
<a name="ln6511">			ath_power_setpower(sc, HAL_PM_FULL_SLEEP, 1);</a>
<a name="ln6512">	}</a>
<a name="ln6513">	ATH_UNLOCK(sc);</a>
<a name="ln6514"> </a>
<a name="ln6515">	if (error == 0) {</a>
<a name="ln6516">#ifdef ATH_TX99_DIAG</a>
<a name="ln6517">		if (sc-&gt;sc_tx99 != NULL)</a>
<a name="ln6518">			sc-&gt;sc_tx99-&gt;start(sc-&gt;sc_tx99);</a>
<a name="ln6519">		else</a>
<a name="ln6520">#endif</a>
<a name="ln6521">		ieee80211_start_all(ic);</a>
<a name="ln6522">	}</a>
<a name="ln6523">}</a>
<a name="ln6524"> </a>
<a name="ln6525">/*</a>
<a name="ln6526"> * Announce various information on device/driver attach.</a>
<a name="ln6527"> */</a>
<a name="ln6528">static void</a>
<a name="ln6529">ath_announce(struct ath_softc *sc)</a>
<a name="ln6530">{</a>
<a name="ln6531">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln6532"> </a>
<a name="ln6533">	device_printf(sc-&gt;sc_dev, &quot;%s mac %d.%d RF%s phy %d.%d\n&quot;,</a>
<a name="ln6534">		ath_hal_mac_name(ah), ah-&gt;ah_macVersion, ah-&gt;ah_macRev,</a>
<a name="ln6535">		ath_hal_rf_name(ah), ah-&gt;ah_phyRev &gt;&gt; 4, ah-&gt;ah_phyRev &amp; 0xf);</a>
<a name="ln6536">	device_printf(sc-&gt;sc_dev, &quot;2GHz radio: 0x%.4x; 5GHz radio: 0x%.4x\n&quot;,</a>
<a name="ln6537">		ah-&gt;ah_analog2GhzRev, ah-&gt;ah_analog5GhzRev);</a>
<a name="ln6538">	if (bootverbose) {</a>
<a name="ln6539">		int i;</a>
<a name="ln6540">		for (i = 0; i &lt;= WME_AC_VO; i++) {</a>
<a name="ln6541">			struct ath_txq *txq = sc-&gt;sc_ac2q[i];</a>
<a name="ln6542">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln6543">			    &quot;Use hw queue %u for %s traffic\n&quot;,</a>
<a name="ln6544">			    txq-&gt;axq_qnum, ieee80211_wme_acnames[i]);</a>
<a name="ln6545">		}</a>
<a name="ln6546">		device_printf(sc-&gt;sc_dev, &quot;Use hw queue %u for CAB traffic\n&quot;,</a>
<a name="ln6547">		    sc-&gt;sc_cabq-&gt;axq_qnum);</a>
<a name="ln6548">		device_printf(sc-&gt;sc_dev, &quot;Use hw queue %u for beacons\n&quot;,</a>
<a name="ln6549">		    sc-&gt;sc_bhalq);</a>
<a name="ln6550">	}</a>
<a name="ln6551">	if (ath_rxbuf != ATH_RXBUF)</a>
<a name="ln6552">		device_printf(sc-&gt;sc_dev, &quot;using %u rx buffers\n&quot;, ath_rxbuf);</a>
<a name="ln6553">	if (ath_txbuf != ATH_TXBUF)</a>
<a name="ln6554">		device_printf(sc-&gt;sc_dev, &quot;using %u tx buffers\n&quot;, ath_txbuf);</a>
<a name="ln6555">	if (sc-&gt;sc_mcastkey &amp;&amp; bootverbose)</a>
<a name="ln6556">		device_printf(sc-&gt;sc_dev, &quot;using multicast key search\n&quot;);</a>
<a name="ln6557">}</a>
<a name="ln6558"> </a>
<a name="ln6559">static void</a>
<a name="ln6560">ath_dfs_tasklet(void *p, int npending)</a>
<a name="ln6561">{</a>
<a name="ln6562">	struct ath_softc *sc = (struct ath_softc *) p;</a>
<a name="ln6563">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln6564"> </a>
<a name="ln6565">	/*</a>
<a name="ln6566">	 * If previous processing has found a radar event,</a>
<a name="ln6567">	 * signal this to the net80211 layer to begin DFS</a>
<a name="ln6568">	 * processing.</a>
<a name="ln6569">	 */</a>
<a name="ln6570">	if (ath_dfs_process_radar_event(sc, sc-&gt;sc_curchan)) {</a>
<a name="ln6571">		/* DFS event found, initiate channel change */</a>
<a name="ln6572"> </a>
<a name="ln6573">		/*</a>
<a name="ln6574">		 * XXX TODO: immediately disable ACK processing</a>
<a name="ln6575">		 * on the current channel.  This would be done</a>
<a name="ln6576">		 * by setting AR_DIAG_ACK_DIS (AR5212; may be</a>
<a name="ln6577">		 * different for others) until we are out of</a>
<a name="ln6578">		 * CAC.</a>
<a name="ln6579">		 */</a>
<a name="ln6580"> </a>
<a name="ln6581">		/*</a>
<a name="ln6582">		 * XXX doesn't currently tell us whether the event</a>
<a name="ln6583">		 * XXX was found in the primary or extension</a>
<a name="ln6584">		 * XXX channel!</a>
<a name="ln6585">		 */</a>
<a name="ln6586">		IEEE80211_LOCK(ic);</a>
<a name="ln6587">		ieee80211_dfs_notify_radar(ic, sc-&gt;sc_curchan);</a>
<a name="ln6588">		IEEE80211_UNLOCK(ic);</a>
<a name="ln6589">	}</a>
<a name="ln6590">}</a>
<a name="ln6591"> </a>
<a name="ln6592">/*</a>
<a name="ln6593"> * Enable/disable power save.  This must be called with</a>
<a name="ln6594"> * no TX driver locks currently held, so it should only</a>
<a name="ln6595"> * be called from the RX path (which doesn't hold any</a>
<a name="ln6596"> * TX driver locks.)</a>
<a name="ln6597"> */</a>
<a name="ln6598">static void</a>
<a name="ln6599">ath_node_powersave(struct ieee80211_node *ni, int enable)</a>
<a name="ln6600">{</a>
<a name="ln6601">#ifdef	ATH_SW_PSQ</a>
<a name="ln6602">	struct ath_node *an = ATH_NODE(ni);</a>
<a name="ln6603">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln6604">	struct ath_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln6605">	struct ath_vap *avp = ATH_VAP(ni-&gt;ni_vap);</a>
<a name="ln6606"> </a>
<a name="ln6607">	/* XXX and no TXQ locks should be held here */</a>
<a name="ln6608"> </a>
<a name="ln6609">	DPRINTF(sc, ATH_DEBUG_NODE_PWRSAVE, &quot;%s: %6D: enable=%d\n&quot;,</a>
<a name="ln6610">	    __func__,</a>
<a name="ln6611">	    ni-&gt;ni_macaddr,</a>
<a name="ln6612">	    &quot;:&quot;,</a>
<a name="ln6613">	    !! enable);</a>
<a name="ln6614"> </a>
<a name="ln6615">	/* Suspend or resume software queue handling */</a>
<a name="ln6616">	if (enable)</a>
<a name="ln6617">		ath_tx_node_sleep(sc, an);</a>
<a name="ln6618">	else</a>
<a name="ln6619">		ath_tx_node_wakeup(sc, an);</a>
<a name="ln6620"> </a>
<a name="ln6621">	/* Update net80211 state */</a>
<a name="ln6622">	avp-&gt;av_node_ps(ni, enable);</a>
<a name="ln6623">#else</a>
<a name="ln6624">	struct ath_vap *avp = ATH_VAP(ni-&gt;ni_vap);</a>
<a name="ln6625"> </a>
<a name="ln6626">	/* Update net80211 state */</a>
<a name="ln6627">	avp-&gt;av_node_ps(ni, enable);</a>
<a name="ln6628">#endif/* ATH_SW_PSQ */</a>
<a name="ln6629">}</a>
<a name="ln6630"> </a>
<a name="ln6631">/*</a>
<a name="ln6632"> * Notification from net80211 that the powersave queue state has</a>
<a name="ln6633"> * changed.</a>
<a name="ln6634"> *</a>
<a name="ln6635"> * Since the software queue also may have some frames:</a>
<a name="ln6636"> *</a>
<a name="ln6637"> * + if the node software queue has frames and the TID state</a>
<a name="ln6638"> *   is 0, we set the TIM;</a>
<a name="ln6639"> * + if the node and the stack are both empty, we clear the TIM bit.</a>
<a name="ln6640"> * + If the stack tries to set the bit, always set it.</a>
<a name="ln6641"> * + If the stack tries to clear the bit, only clear it if the</a>
<a name="ln6642"> *   software queue in question is also cleared.</a>
<a name="ln6643"> *</a>
<a name="ln6644"> * TODO: this is called during node teardown; so let's ensure this</a>
<a name="ln6645"> * is all correctly handled and that the TIM bit is cleared.</a>
<a name="ln6646"> * It may be that the node flush is called _AFTER_ the net80211</a>
<a name="ln6647"> * stack clears the TIM.</a>
<a name="ln6648"> *</a>
<a name="ln6649"> * Here is the racy part.  Since it's possible &gt;1 concurrent,</a>
<a name="ln6650"> * overlapping TXes will appear complete with a TX completion in</a>
<a name="ln6651"> * another thread, it's possible that the concurrent TIM calls will</a>
<a name="ln6652"> * clash.  We can't hold the node lock here because setting the</a>
<a name="ln6653"> * TIM grabs the net80211 comlock and this may cause a LOR.</a>
<a name="ln6654"> * The solution is either to totally serialise _everything_ at</a>
<a name="ln6655"> * this point (ie, all TX, completion and any reset/flush go into</a>
<a name="ln6656"> * one taskqueue) or a new &quot;ath TIM lock&quot; needs to be created that</a>
<a name="ln6657"> * just wraps the driver state change and this call to avp-&gt;av_set_tim().</a>
<a name="ln6658"> *</a>
<a name="ln6659"> * The same race exists in the net80211 power save queue handling</a>
<a name="ln6660"> * as well.  Since multiple transmitting threads may queue frames</a>
<a name="ln6661"> * into the driver, as well as ps-poll and the driver transmitting</a>
<a name="ln6662"> * frames (and thus clearing the psq), it's quite possible that</a>
<a name="ln6663"> * a packet entering the PSQ and a ps-poll being handled will</a>
<a name="ln6664"> * race, causing the TIM to be cleared and not re-set.</a>
<a name="ln6665"> */</a>
<a name="ln6666">static int</a>
<a name="ln6667">ath_node_set_tim(struct ieee80211_node *ni, int enable)</a>
<a name="ln6668">{</a>
<a name="ln6669">#ifdef	ATH_SW_PSQ</a>
<a name="ln6670">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln6671">	struct ath_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln6672">	struct ath_node *an = ATH_NODE(ni);</a>
<a name="ln6673">	struct ath_vap *avp = ATH_VAP(ni-&gt;ni_vap);</a>
<a name="ln6674">	int changed = 0;</a>
<a name="ln6675"> </a>
<a name="ln6676">	ATH_TX_LOCK(sc);</a>
<a name="ln6677">	an-&gt;an_stack_psq = enable;</a>
<a name="ln6678"> </a>
<a name="ln6679">	/*</a>
<a name="ln6680">	 * This will get called for all operating modes,</a>
<a name="ln6681">	 * even if avp-&gt;av_set_tim is unset.</a>
<a name="ln6682">	 * It's currently set for hostap/ibss modes; but</a>
<a name="ln6683">	 * the same infrastructure is used for both STA</a>
<a name="ln6684">	 * and AP/IBSS node power save.</a>
<a name="ln6685">	 */</a>
<a name="ln6686">	if (avp-&gt;av_set_tim == NULL) {</a>
<a name="ln6687">		ATH_TX_UNLOCK(sc);</a>
<a name="ln6688">		return (0);</a>
<a name="ln6689">	}</a>
<a name="ln6690"> </a>
<a name="ln6691">	/*</a>
<a name="ln6692">	 * If setting the bit, always set it here.</a>
<a name="ln6693">	 * If clearing the bit, only clear it if the</a>
<a name="ln6694">	 * software queue is also empty.</a>
<a name="ln6695">	 *</a>
<a name="ln6696">	 * If the node has left power save, just clear the TIM</a>
<a name="ln6697">	 * bit regardless of the state of the power save queue.</a>
<a name="ln6698">	 *</a>
<a name="ln6699">	 * XXX TODO: although atomics are used, it's quite possible</a>
<a name="ln6700">	 * that a race will occur between this and setting/clearing</a>
<a name="ln6701">	 * in another thread.  TX completion will occur always in</a>
<a name="ln6702">	 * one thread, however setting/clearing the TIM bit can come</a>
<a name="ln6703">	 * from a variety of different process contexts!</a>
<a name="ln6704">	 */</a>
<a name="ln6705">	if (enable &amp;&amp; an-&gt;an_tim_set == 1) {</a>
<a name="ln6706">		DPRINTF(sc, ATH_DEBUG_NODE_PWRSAVE,</a>
<a name="ln6707">		    &quot;%s: %6D: enable=%d, tim_set=1, ignoring\n&quot;,</a>
<a name="ln6708">		    __func__,</a>
<a name="ln6709">		    ni-&gt;ni_macaddr,</a>
<a name="ln6710">		    &quot;:&quot;,</a>
<a name="ln6711">		    enable);</a>
<a name="ln6712">		ATH_TX_UNLOCK(sc);</a>
<a name="ln6713">	} else if (enable) {</a>
<a name="ln6714">		DPRINTF(sc, ATH_DEBUG_NODE_PWRSAVE,</a>
<a name="ln6715">		    &quot;%s: %6D: enable=%d, enabling TIM\n&quot;,</a>
<a name="ln6716">		    __func__,</a>
<a name="ln6717">		    ni-&gt;ni_macaddr,</a>
<a name="ln6718">		    &quot;:&quot;,</a>
<a name="ln6719">		    enable);</a>
<a name="ln6720">		an-&gt;an_tim_set = 1;</a>
<a name="ln6721">		ATH_TX_UNLOCK(sc);</a>
<a name="ln6722">		changed = avp-&gt;av_set_tim(ni, enable);</a>
<a name="ln6723">	} else if (an-&gt;an_swq_depth == 0) {</a>
<a name="ln6724">		/* disable */</a>
<a name="ln6725">		DPRINTF(sc, ATH_DEBUG_NODE_PWRSAVE,</a>
<a name="ln6726">		    &quot;%s: %6D: enable=%d, an_swq_depth == 0, disabling\n&quot;,</a>
<a name="ln6727">		    __func__,</a>
<a name="ln6728">		    ni-&gt;ni_macaddr,</a>
<a name="ln6729">		    &quot;:&quot;,</a>
<a name="ln6730">		    enable);</a>
<a name="ln6731">		an-&gt;an_tim_set = 0;</a>
<a name="ln6732">		ATH_TX_UNLOCK(sc);</a>
<a name="ln6733">		changed = avp-&gt;av_set_tim(ni, enable);</a>
<a name="ln6734">	} else if (! an-&gt;an_is_powersave) {</a>
<a name="ln6735">		/*</a>
<a name="ln6736">		 * disable regardless; the node isn't in powersave now</a>
<a name="ln6737">		 */</a>
<a name="ln6738">		DPRINTF(sc, ATH_DEBUG_NODE_PWRSAVE,</a>
<a name="ln6739">		    &quot;%s: %6D: enable=%d, an_pwrsave=0, disabling\n&quot;,</a>
<a name="ln6740">		    __func__,</a>
<a name="ln6741">		    ni-&gt;ni_macaddr,</a>
<a name="ln6742">		    &quot;:&quot;,</a>
<a name="ln6743">		    enable);</a>
<a name="ln6744">		an-&gt;an_tim_set = 0;</a>
<a name="ln6745">		ATH_TX_UNLOCK(sc);</a>
<a name="ln6746">		changed = avp-&gt;av_set_tim(ni, enable);</a>
<a name="ln6747">	} else {</a>
<a name="ln6748">		/*</a>
<a name="ln6749">		 * psq disable, node is currently in powersave, node</a>
<a name="ln6750">		 * software queue isn't empty, so don't clear the TIM bit</a>
<a name="ln6751">		 * for now.</a>
<a name="ln6752">		 */</a>
<a name="ln6753">		ATH_TX_UNLOCK(sc);</a>
<a name="ln6754">		DPRINTF(sc, ATH_DEBUG_NODE_PWRSAVE,</a>
<a name="ln6755">		    &quot;%s: %6D: enable=%d, an_swq_depth &gt; 0, ignoring\n&quot;,</a>
<a name="ln6756">		    __func__,</a>
<a name="ln6757">		    ni-&gt;ni_macaddr,</a>
<a name="ln6758">		    &quot;:&quot;,</a>
<a name="ln6759">		    enable);</a>
<a name="ln6760">		changed = 0;</a>
<a name="ln6761">	}</a>
<a name="ln6762"> </a>
<a name="ln6763">	return (changed);</a>
<a name="ln6764">#else</a>
<a name="ln6765">	struct ath_vap *avp = ATH_VAP(ni-&gt;ni_vap);</a>
<a name="ln6766"> </a>
<a name="ln6767">	/*</a>
<a name="ln6768">	 * Some operating modes don't set av_set_tim(), so don't</a>
<a name="ln6769">	 * update it here.</a>
<a name="ln6770">	 */</a>
<a name="ln6771">	if (avp-&gt;av_set_tim == NULL)</a>
<a name="ln6772">		return (0);</a>
<a name="ln6773"> </a>
<a name="ln6774">	return (avp-&gt;av_set_tim(ni, enable));</a>
<a name="ln6775">#endif /* ATH_SW_PSQ */</a>
<a name="ln6776">}</a>
<a name="ln6777"> </a>
<a name="ln6778">/*</a>
<a name="ln6779"> * Set or update the TIM from the software queue.</a>
<a name="ln6780"> *</a>
<a name="ln6781"> * Check the software queue depth before attempting to do lock</a>
<a name="ln6782"> * anything; that avoids trying to obtain the lock.  Then,</a>
<a name="ln6783"> * re-check afterwards to ensure nothing has changed in the</a>
<a name="ln6784"> * meantime.</a>
<a name="ln6785"> *</a>
<a name="ln6786"> * set:   This is designed to be called from the TX path, after</a>
<a name="ln6787"> *        a frame has been queued; to see if the swq &gt; 0.</a>
<a name="ln6788"> *</a>
<a name="ln6789"> * clear: This is designed to be called from the buffer completion point</a>
<a name="ln6790"> *        (right now it's ath_tx_default_comp()) where the state of</a>
<a name="ln6791"> *        a software queue has changed.</a>
<a name="ln6792"> *</a>
<a name="ln6793"> * It makes sense to place it at buffer free / completion rather</a>
<a name="ln6794"> * than after each software queue operation, as there's no real</a>
<a name="ln6795"> * point in churning the TIM bit as the last frames in the software</a>
<a name="ln6796"> * queue are transmitted.  If they fail and we retry them, we'd</a>
<a name="ln6797"> * just be setting the TIM bit again anyway.</a>
<a name="ln6798"> */</a>
<a name="ln6799">void</a>
<a name="ln6800">ath_tx_update_tim(struct ath_softc *sc, struct ieee80211_node *ni,</a>
<a name="ln6801">     int enable)</a>
<a name="ln6802">{</a>
<a name="ln6803">#ifdef	ATH_SW_PSQ</a>
<a name="ln6804">	struct ath_node *an;</a>
<a name="ln6805">	struct ath_vap *avp;</a>
<a name="ln6806"> </a>
<a name="ln6807">	/* Don't do this for broadcast/etc frames */</a>
<a name="ln6808">	if (ni == NULL)</a>
<a name="ln6809">		return;</a>
<a name="ln6810"> </a>
<a name="ln6811">	an = ATH_NODE(ni);</a>
<a name="ln6812">	avp = ATH_VAP(ni-&gt;ni_vap);</a>
<a name="ln6813"> </a>
<a name="ln6814">	/*</a>
<a name="ln6815">	 * And for operating modes without the TIM handler set, let's</a>
<a name="ln6816">	 * just skip those.</a>
<a name="ln6817">	 */</a>
<a name="ln6818">	if (avp-&gt;av_set_tim == NULL)</a>
<a name="ln6819">		return;</a>
<a name="ln6820"> </a>
<a name="ln6821">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln6822"> </a>
<a name="ln6823">	if (enable) {</a>
<a name="ln6824">		if (an-&gt;an_is_powersave &amp;&amp;</a>
<a name="ln6825">		    an-&gt;an_tim_set == 0 &amp;&amp;</a>
<a name="ln6826">		    an-&gt;an_swq_depth != 0) {</a>
<a name="ln6827">			DPRINTF(sc, ATH_DEBUG_NODE_PWRSAVE,</a>
<a name="ln6828">			    &quot;%s: %6D: swq_depth&gt;0, tim_set=0, set!\n&quot;,</a>
<a name="ln6829">			    __func__,</a>
<a name="ln6830">			    ni-&gt;ni_macaddr,</a>
<a name="ln6831">			    &quot;:&quot;);</a>
<a name="ln6832">			an-&gt;an_tim_set = 1;</a>
<a name="ln6833">			(void) avp-&gt;av_set_tim(ni, 1);</a>
<a name="ln6834">		}</a>
<a name="ln6835">	} else {</a>
<a name="ln6836">		/*</a>
<a name="ln6837">		 * Don't bother grabbing the lock unless the queue is empty.</a>
<a name="ln6838">		 */</a>
<a name="ln6839">		if (an-&gt;an_swq_depth != 0)</a>
<a name="ln6840">			return;</a>
<a name="ln6841"> </a>
<a name="ln6842">		if (an-&gt;an_is_powersave &amp;&amp;</a>
<a name="ln6843">		    an-&gt;an_stack_psq == 0 &amp;&amp;</a>
<a name="ln6844">		    an-&gt;an_tim_set == 1 &amp;&amp;</a>
<a name="ln6845">		    an-&gt;an_swq_depth == 0) {</a>
<a name="ln6846">			DPRINTF(sc, ATH_DEBUG_NODE_PWRSAVE,</a>
<a name="ln6847">			    &quot;%s: %6D: swq_depth=0, tim_set=1, psq_set=0,&quot;</a>
<a name="ln6848">			    &quot; clear!\n&quot;,</a>
<a name="ln6849">			    __func__,</a>
<a name="ln6850">			    ni-&gt;ni_macaddr,</a>
<a name="ln6851">			    &quot;:&quot;);</a>
<a name="ln6852">			an-&gt;an_tim_set = 0;</a>
<a name="ln6853">			(void) avp-&gt;av_set_tim(ni, 0);</a>
<a name="ln6854">		}</a>
<a name="ln6855">	}</a>
<a name="ln6856">#else</a>
<a name="ln6857">	return;</a>
<a name="ln6858">#endif	/* ATH_SW_PSQ */</a>
<a name="ln6859">}</a>
<a name="ln6860"> </a>
<a name="ln6861">/*</a>
<a name="ln6862"> * Received a ps-poll frame from net80211.</a>
<a name="ln6863"> *</a>
<a name="ln6864"> * Here we get a chance to serve out a software-queued frame ourselves</a>
<a name="ln6865"> * before we punt it to net80211 to transmit us one itself - either</a>
<a name="ln6866"> * because there's traffic in the net80211 psq, or a NULL frame to</a>
<a name="ln6867"> * indicate there's nothing else.</a>
<a name="ln6868"> */</a>
<a name="ln6869">static void</a>
<a name="ln6870">ath_node_recv_pspoll(struct ieee80211_node *ni, struct mbuf *m)</a>
<a name="ln6871">{</a>
<a name="ln6872">#ifdef	ATH_SW_PSQ</a>
<a name="ln6873">	struct ath_node *an;</a>
<a name="ln6874">	struct ath_vap *avp;</a>
<a name="ln6875">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln6876">	struct ath_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln6877">	int tid;</a>
<a name="ln6878"> </a>
<a name="ln6879">	/* Just paranoia */</a>
<a name="ln6880">	if (ni == NULL)</a>
<a name="ln6881">		return;</a>
<a name="ln6882"> </a>
<a name="ln6883">	/*</a>
<a name="ln6884">	 * Unassociated (temporary node) station.</a>
<a name="ln6885">	 */</a>
<a name="ln6886">	if (ni-&gt;ni_associd == 0)</a>
<a name="ln6887">		return;</a>
<a name="ln6888"> </a>
<a name="ln6889">	/*</a>
<a name="ln6890">	 * We do have an active node, so let's begin looking into it.</a>
<a name="ln6891">	 */</a>
<a name="ln6892">	an = ATH_NODE(ni);</a>
<a name="ln6893">	avp = ATH_VAP(ni-&gt;ni_vap);</a>
<a name="ln6894"> </a>
<a name="ln6895">	/*</a>
<a name="ln6896">	 * For now, we just call the original ps-poll method.</a>
<a name="ln6897">	 * Once we're ready to flip this on:</a>
<a name="ln6898">	 *</a>
<a name="ln6899">	 * + Set leak to 1, as no matter what we're going to have</a>
<a name="ln6900">	 *   to send a frame;</a>
<a name="ln6901">	 * + Check the software queue and if there's something in it,</a>
<a name="ln6902">	 *   schedule the highest TID thas has traffic from this node.</a>
<a name="ln6903">	 *   Then make sure we schedule the software scheduler to</a>
<a name="ln6904">	 *   run so it picks up said frame.</a>
<a name="ln6905">	 *</a>
<a name="ln6906">	 * That way whatever happens, we'll at least send _a_ frame</a>
<a name="ln6907">	 * to the given node.</a>
<a name="ln6908">	 *</a>
<a name="ln6909">	 * Again, yes, it's crappy QoS if the node has multiple</a>
<a name="ln6910">	 * TIDs worth of traffic - but let's get it working first</a>
<a name="ln6911">	 * before we optimise it.</a>
<a name="ln6912">	 *</a>
<a name="ln6913">	 * Also yes, there's definitely latency here - we're not</a>
<a name="ln6914">	 * direct dispatching to the hardware in this path (and</a>
<a name="ln6915">	 * we're likely being called from the packet receive path,</a>
<a name="ln6916">	 * so going back into TX may be a little hairy!) but again</a>
<a name="ln6917">	 * I'd like to get this working first before optimising</a>
<a name="ln6918">	 * turn-around time.</a>
<a name="ln6919">	 */</a>
<a name="ln6920"> </a>
<a name="ln6921">	ATH_TX_LOCK(sc);</a>
<a name="ln6922"> </a>
<a name="ln6923">	/*</a>
<a name="ln6924">	 * Legacy - we're called and the node isn't asleep.</a>
<a name="ln6925">	 * Immediately punt.</a>
<a name="ln6926">	 */</a>
<a name="ln6927">	if (! an-&gt;an_is_powersave) {</a>
<a name="ln6928">		DPRINTF(sc, ATH_DEBUG_NODE_PWRSAVE,</a>
<a name="ln6929">		    &quot;%s: %6D: not in powersave?\n&quot;,</a>
<a name="ln6930">		    __func__,</a>
<a name="ln6931">		    ni-&gt;ni_macaddr,</a>
<a name="ln6932">		    &quot;:&quot;);</a>
<a name="ln6933">		ATH_TX_UNLOCK(sc);</a>
<a name="ln6934">		avp-&gt;av_recv_pspoll(ni, m);</a>
<a name="ln6935">		return;</a>
<a name="ln6936">	}</a>
<a name="ln6937"> </a>
<a name="ln6938">	/*</a>
<a name="ln6939">	 * We're in powersave.</a>
<a name="ln6940">	 *</a>
<a name="ln6941">	 * Leak a frame.</a>
<a name="ln6942">	 */</a>
<a name="ln6943">	an-&gt;an_leak_count = 1;</a>
<a name="ln6944"> </a>
<a name="ln6945">	/*</a>
<a name="ln6946">	 * Now, if there's no frames in the node, just punt to</a>
<a name="ln6947">	 * recv_pspoll.</a>
<a name="ln6948">	 *</a>
<a name="ln6949">	 * Don't bother checking if the TIM bit is set, we really</a>
<a name="ln6950">	 * only care if there are any frames here!</a>
<a name="ln6951">	 */</a>
<a name="ln6952">	if (an-&gt;an_swq_depth == 0) {</a>
<a name="ln6953">		ATH_TX_UNLOCK(sc);</a>
<a name="ln6954">		DPRINTF(sc, ATH_DEBUG_NODE_PWRSAVE,</a>
<a name="ln6955">		    &quot;%s: %6D: SWQ empty; punting to net80211\n&quot;,</a>
<a name="ln6956">		    __func__,</a>
<a name="ln6957">		    ni-&gt;ni_macaddr,</a>
<a name="ln6958">		    &quot;:&quot;);</a>
<a name="ln6959">		avp-&gt;av_recv_pspoll(ni, m);</a>
<a name="ln6960">		return;</a>
<a name="ln6961">	}</a>
<a name="ln6962"> </a>
<a name="ln6963">	/*</a>
<a name="ln6964">	 * Ok, let's schedule the highest TID that has traffic</a>
<a name="ln6965">	 * and then schedule something.</a>
<a name="ln6966">	 */</a>
<a name="ln6967">	for (tid = IEEE80211_TID_SIZE - 1; tid &gt;= 0; tid--) {</a>
<a name="ln6968">		struct ath_tid *atid = &amp;an-&gt;an_tid[tid];</a>
<a name="ln6969">		/*</a>
<a name="ln6970">		 * No frames? Skip.</a>
<a name="ln6971">		 */</a>
<a name="ln6972">		if (atid-&gt;axq_depth == 0)</a>
<a name="ln6973">			continue;</a>
<a name="ln6974">		ath_tx_tid_sched(sc, atid);</a>
<a name="ln6975">		/*</a>
<a name="ln6976">		 * XXX we could do a direct call to the TXQ</a>
<a name="ln6977">		 * scheduler code here to optimise latency</a>
<a name="ln6978">		 * at the expense of a REALLY deep callstack.</a>
<a name="ln6979">		 */</a>
<a name="ln6980">		ATH_TX_UNLOCK(sc);</a>
<a name="ln6981">		taskqueue_enqueue(sc-&gt;sc_tq, &amp;sc-&gt;sc_txqtask);</a>
<a name="ln6982">		DPRINTF(sc, ATH_DEBUG_NODE_PWRSAVE,</a>
<a name="ln6983">		    &quot;%s: %6D: leaking frame to TID %d\n&quot;,</a>
<a name="ln6984">		    __func__,</a>
<a name="ln6985">		    ni-&gt;ni_macaddr,</a>
<a name="ln6986">		    &quot;:&quot;,</a>
<a name="ln6987">		    tid);</a>
<a name="ln6988">		return;</a>
<a name="ln6989">	}</a>
<a name="ln6990"> </a>
<a name="ln6991">	ATH_TX_UNLOCK(sc);</a>
<a name="ln6992"> </a>
<a name="ln6993">	/*</a>
<a name="ln6994">	 * XXX nothing in the TIDs at this point? Eek.</a>
<a name="ln6995">	 */</a>
<a name="ln6996">	DPRINTF(sc, ATH_DEBUG_NODE_PWRSAVE,</a>
<a name="ln6997">	    &quot;%s: %6D: TIDs empty, but ath_node showed traffic?!\n&quot;,</a>
<a name="ln6998">	    __func__,</a>
<a name="ln6999">	    ni-&gt;ni_macaddr,</a>
<a name="ln7000">	    &quot;:&quot;);</a>
<a name="ln7001">	avp-&gt;av_recv_pspoll(ni, m);</a>
<a name="ln7002">#else</a>
<a name="ln7003">	avp-&gt;av_recv_pspoll(ni, m);</a>
<a name="ln7004">#endif	/* ATH_SW_PSQ */</a>
<a name="ln7005">}</a>
<a name="ln7006"> </a>
<a name="ln7007">MODULE_VERSION(ath_main, 1);</a>
<a name="ln7008">MODULE_DEPEND(ath_main, wlan, 1, 1, 1);          /* 802.11 media layer */</a>
<a name="ln7009">MODULE_DEPEND(ath_main, ath_rate, 1, 1, 1);</a>
<a name="ln7010">MODULE_DEPEND(ath_main, ath_dfs, 1, 1, 1);</a>
<a name="ln7011">MODULE_DEPEND(ath_main, ath_hal, 1, 1, 1);</a>
<a name="ln7012">#if	defined(IEEE80211_ALQ) || defined(AH_DEBUG_ALQ) || defined(ATH_DEBUG_ALQ)</a>
<a name="ln7013">MODULE_DEPEND(ath_main, alq, 1, 1, 1);</a>
<a name="ln7014">#endif</a>

</code></pre>
<div class="balloon" rel="4803"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v781/" target="_blank">V781</a> The value of the 'bf->bf_state.bfs_tx_queue' variable is checked after it was used. Perhaps there is a mistake in program logic. Check lines: 4803, 4811.</p></div>
<div class="balloon" rel="6875"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'ni' pointer was utilized before it was verified against nullptr. Check lines: 6875, 6880.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
