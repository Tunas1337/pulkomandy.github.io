
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>subr_gtaskqueue.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * Copyright (c) 2000 Doug Rabson</a>
<a name="ln3"> * Copyright (c) 2014 Jeff Roberson</a>
<a name="ln4"> * Copyright (c) 2016 Matthew Macy</a>
<a name="ln5"> * All rights reserved.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln8"> * modification, are permitted provided that the following conditions</a>
<a name="ln9"> * are met:</a>
<a name="ln10"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln11"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln12"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln13"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln14"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln15"> *</a>
<a name="ln16"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln17"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln18"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln19"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</a>
<a name="ln20"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln21"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln22"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln23"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln24"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln25"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln26"> * SUCH DAMAGE.</a>
<a name="ln27"> */</a>
<a name="ln28"> </a>
<a name="ln29">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln30">__FBSDID(&quot;$FreeBSD$&quot;);</a>
<a name="ln31"> </a>
<a name="ln32">#include &lt;sys/param.h&gt;</a>
<a name="ln33">#include &lt;sys/systm.h&gt;</a>
<a name="ln34">#include &lt;sys/bus.h&gt;</a>
<a name="ln35">#ifndef __HAIKU__</a>
<a name="ln36">#include &lt;sys/cpuset.h&gt;</a>
<a name="ln37">#include &lt;sys/interrupt.h&gt;</a>
<a name="ln38">#endif</a>
<a name="ln39">#include &lt;sys/kernel.h&gt;</a>
<a name="ln40">#include &lt;sys/kthread.h&gt;</a>
<a name="ln41">#include &lt;sys/libkern.h&gt;</a>
<a name="ln42">#include &lt;sys/limits.h&gt;</a>
<a name="ln43">#include &lt;sys/lock.h&gt;</a>
<a name="ln44">#include &lt;sys/malloc.h&gt;</a>
<a name="ln45">#include &lt;sys/mutex.h&gt;</a>
<a name="ln46">#include &lt;sys/proc.h&gt;</a>
<a name="ln47">#ifndef __HAIKU__</a>
<a name="ln48">#include &lt;sys/sched.h&gt;</a>
<a name="ln49">#endif</a>
<a name="ln50">#include &lt;sys/smp.h&gt;</a>
<a name="ln51">#include &lt;sys/gtaskqueue.h&gt;</a>
<a name="ln52">#ifndef __HAIKU__</a>
<a name="ln53">#include &lt;sys/unistd.h&gt;</a>
<a name="ln54">#endif</a>
<a name="ln55">#include &lt;machine/stdarg.h&gt;</a>
<a name="ln56"> </a>
<a name="ln57">static MALLOC_DEFINE(M_GTASKQUEUE, &quot;gtaskqueue&quot;, &quot;Group Task Queues&quot;);</a>
<a name="ln58">static void	gtaskqueue_thread_enqueue(void *);</a>
<a name="ln59">static void	gtaskqueue_thread_loop(void *arg);</a>
<a name="ln60">static int	task_is_running(struct gtaskqueue *queue, struct gtask *gtask);</a>
<a name="ln61">static void	gtaskqueue_drain_locked(struct gtaskqueue *queue, struct gtask *gtask);</a>
<a name="ln62"> </a>
<a name="ln63">TASKQGROUP_DEFINE(softirq, mp_ncpus, 1);</a>
<a name="ln64">TASKQGROUP_DEFINE(config, 1, 1);</a>
<a name="ln65"> </a>
<a name="ln66">struct gtaskqueue_busy {</a>
<a name="ln67">	struct gtask	*tb_running;</a>
<a name="ln68">	TAILQ_ENTRY(gtaskqueue_busy) tb_link;</a>
<a name="ln69">};</a>
<a name="ln70"> </a>
<a name="ln71">static struct gtask * const TB_DRAIN_WAITER = (struct gtask *)0x1;</a>
<a name="ln72"> </a>
<a name="ln73">typedef void (*gtaskqueue_enqueue_fn)(void *context);</a>
<a name="ln74"> </a>
<a name="ln75">struct gtaskqueue {</a>
<a name="ln76">	STAILQ_HEAD(, gtask)	tq_queue;</a>
<a name="ln77">	gtaskqueue_enqueue_fn	tq_enqueue;</a>
<a name="ln78">	void			*tq_context;</a>
<a name="ln79">	char			*tq_name;</a>
<a name="ln80">	TAILQ_HEAD(, gtaskqueue_busy) tq_active;</a>
<a name="ln81">	struct mtx		tq_mutex;</a>
<a name="ln82">#ifdef __HAIKU__</a>
<a name="ln83">	sem_id 			tq_sem;</a>
<a name="ln84">#endif</a>
<a name="ln85">	struct thread		**tq_threads;</a>
<a name="ln86">	int			tq_tcount;</a>
<a name="ln87">	int			tq_spin;</a>
<a name="ln88">	int			tq_flags;</a>
<a name="ln89">	int			tq_callouts;</a>
<a name="ln90">	taskqueue_callback_fn	tq_callbacks[TASKQUEUE_NUM_CALLBACKS];</a>
<a name="ln91">	void			*tq_cb_contexts[TASKQUEUE_NUM_CALLBACKS];</a>
<a name="ln92">};</a>
<a name="ln93"> </a>
<a name="ln94">#define	TQ_FLAGS_ACTIVE		(1 &lt;&lt; 0)</a>
<a name="ln95">#define	TQ_FLAGS_BLOCKED	(1 &lt;&lt; 1)</a>
<a name="ln96">#define	TQ_FLAGS_UNLOCKED_ENQUEUE	(1 &lt;&lt; 2)</a>
<a name="ln97"> </a>
<a name="ln98">#define	DT_CALLOUT_ARMED	(1 &lt;&lt; 0)</a>
<a name="ln99"> </a>
<a name="ln100">#define	TQ_LOCK(tq)							\</a>
<a name="ln101">	do {								\</a>
<a name="ln102">		if ((tq)-&gt;tq_spin)					\</a>
<a name="ln103">			mtx_lock_spin(&amp;(tq)-&gt;tq_mutex);			\</a>
<a name="ln104">		else							\</a>
<a name="ln105">			mtx_lock(&amp;(tq)-&gt;tq_mutex);			\</a>
<a name="ln106">	} while (0)</a>
<a name="ln107">#define	TQ_ASSERT_LOCKED(tq)	mtx_assert(&amp;(tq)-&gt;tq_mutex, MA_OWNED)</a>
<a name="ln108"> </a>
<a name="ln109">#define	TQ_UNLOCK(tq)							\</a>
<a name="ln110">	do {								\</a>
<a name="ln111">		if ((tq)-&gt;tq_spin)					\</a>
<a name="ln112">			mtx_unlock_spin(&amp;(tq)-&gt;tq_mutex);		\</a>
<a name="ln113">		else							\</a>
<a name="ln114">			mtx_unlock(&amp;(tq)-&gt;tq_mutex);			\</a>
<a name="ln115">	} while (0)</a>
<a name="ln116">#define	TQ_ASSERT_UNLOCKED(tq)	mtx_assert(&amp;(tq)-&gt;tq_mutex, MA_NOTOWNED)</a>
<a name="ln117"> </a>
<a name="ln118">#ifdef INVARIANTS</a>
<a name="ln119">static void</a>
<a name="ln120">gtask_dump(struct gtask *gtask)</a>
<a name="ln121">{</a>
<a name="ln122">	printf(&quot;gtask: %p ta_flags=%x ta_priority=%d ta_func=%p ta_context=%p\n&quot;,</a>
<a name="ln123">	       gtask, gtask-&gt;ta_flags, gtask-&gt;ta_priority, gtask-&gt;ta_func, gtask-&gt;ta_context);</a>
<a name="ln124">}</a>
<a name="ln125">#endif</a>
<a name="ln126"> </a>
<a name="ln127">static __inline int</a>
<a name="ln128">TQ_SLEEP(struct gtaskqueue *tq, void *p, struct mtx *m, int pri, const char *wm,</a>
<a name="ln129">    int t)</a>
<a name="ln130">{</a>
<a name="ln131">	if (tq-&gt;tq_spin)</a>
<a name="ln132">		return (msleep_spin(p, m, wm, t));</a>
<a name="ln133">	return (msleep(p, m, pri, wm, t));</a>
<a name="ln134">}</a>
<a name="ln135"> </a>
<a name="ln136">static struct gtaskqueue *</a>
<a name="ln137">_gtaskqueue_create(const char *name, int mflags,</a>
<a name="ln138">		 taskqueue_enqueue_fn enqueue, void *context,</a>
<a name="ln139">		 int mtxflags, const char *mtxname __unused)</a>
<a name="ln140">{</a>
<a name="ln141">	struct gtaskqueue *queue;</a>
<a name="ln142">	char *tq_name;</a>
<a name="ln143"> </a>
<a name="ln144">	tq_name = malloc(TASKQUEUE_NAMELEN, M_GTASKQUEUE, mflags | M_ZERO);</a>
<a name="ln145">	if (!tq_name)</a>
<a name="ln146">		return (NULL);</a>
<a name="ln147"> </a>
<a name="ln148">	snprintf(tq_name, TASKQUEUE_NAMELEN, &quot;%s&quot;, (name) ? name : &quot;taskqueue&quot;);</a>
<a name="ln149"> </a>
<a name="ln150">	queue = malloc(sizeof(struct gtaskqueue), M_GTASKQUEUE, mflags | M_ZERO);</a>
<a name="ln151">	if (!queue) {</a>
<a name="ln152">		free(tq_name, M_GTASKQUEUE);</a>
<a name="ln153">		return (NULL);</a>
<a name="ln154">	}</a>
<a name="ln155"> </a>
<a name="ln156">	STAILQ_INIT(&amp;queue-&gt;tq_queue);</a>
<a name="ln157">	TAILQ_INIT(&amp;queue-&gt;tq_active);</a>
<a name="ln158">	queue-&gt;tq_enqueue = enqueue;</a>
<a name="ln159">	queue-&gt;tq_context = context;</a>
<a name="ln160">	queue-&gt;tq_name = tq_name;</a>
<a name="ln161">	queue-&gt;tq_spin = (mtxflags &amp; MTX_SPIN) != 0;</a>
<a name="ln162">	queue-&gt;tq_flags |= TQ_FLAGS_ACTIVE;</a>
<a name="ln163">	if (enqueue == gtaskqueue_thread_enqueue)</a>
<a name="ln164">		queue-&gt;tq_flags |= TQ_FLAGS_UNLOCKED_ENQUEUE;</a>
<a name="ln165">	mtx_init(&amp;queue-&gt;tq_mutex, tq_name, NULL, mtxflags);</a>
<a name="ln166">#ifdef __HAIKU__</a>
<a name="ln167">	queue-&gt;tq_sem = create_sem(0, tq_name);</a>
<a name="ln168">#endif</a>
<a name="ln169"> </a>
<a name="ln170">	return (queue);</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173"> </a>
<a name="ln174">/*</a>
<a name="ln175"> * Signal a taskqueue thread to terminate.</a>
<a name="ln176"> */</a>
<a name="ln177">static void</a>
<a name="ln178">gtaskqueue_terminate(struct thread **pp, struct gtaskqueue *tq)</a>
<a name="ln179">{</a>
<a name="ln180"> </a>
<a name="ln181">	while (tq-&gt;tq_tcount &gt; 0 || tq-&gt;tq_callouts &gt; 0) {</a>
<a name="ln182">		wakeup(tq);</a>
<a name="ln183">		TQ_SLEEP(tq, pp, &amp;tq-&gt;tq_mutex, PWAIT, &quot;taskqueue_destroy&quot;, 0);</a>
<a name="ln184">	}</a>
<a name="ln185">}</a>
<a name="ln186"> </a>
<a name="ln187">static void</a>
<a name="ln188">gtaskqueue_free(struct gtaskqueue *queue)</a>
<a name="ln189">{</a>
<a name="ln190"> </a>
<a name="ln191">	TQ_LOCK(queue);</a>
<a name="ln192">	queue-&gt;tq_flags &amp;= ~TQ_FLAGS_ACTIVE;</a>
<a name="ln193">	gtaskqueue_terminate(queue-&gt;tq_threads, queue);</a>
<a name="ln194">	KASSERT(TAILQ_EMPTY(&amp;queue-&gt;tq_active), (&quot;Tasks still running?&quot;));</a>
<a name="ln195">	KASSERT(queue-&gt;tq_callouts == 0, (&quot;Armed timeout tasks&quot;));</a>
<a name="ln196">	mtx_destroy(&amp;queue-&gt;tq_mutex);</a>
<a name="ln197">#ifdef __HAIKU__</a>
<a name="ln198">	delete_sem(queue-&gt;tq_sem);</a>
<a name="ln199">#endif</a>
<a name="ln200">	free(queue-&gt;tq_threads, M_GTASKQUEUE);</a>
<a name="ln201">	free(queue-&gt;tq_name, M_GTASKQUEUE);</a>
<a name="ln202">	free(queue, M_GTASKQUEUE);</a>
<a name="ln203">}</a>
<a name="ln204"> </a>
<a name="ln205">/*</a>
<a name="ln206"> * Wait for all to complete, then prevent it from being enqueued</a>
<a name="ln207"> */</a>
<a name="ln208">void</a>
<a name="ln209">grouptask_block(struct grouptask *grouptask)</a>
<a name="ln210">{</a>
<a name="ln211">	struct gtaskqueue *queue = grouptask-&gt;gt_taskqueue;</a>
<a name="ln212">	struct gtask *gtask = &amp;grouptask-&gt;gt_task;</a>
<a name="ln213"> </a>
<a name="ln214">#ifdef INVARIANTS</a>
<a name="ln215">	if (queue == NULL) {</a>
<a name="ln216">		gtask_dump(gtask);</a>
<a name="ln217">		panic(&quot;queue == NULL&quot;);</a>
<a name="ln218">	}</a>
<a name="ln219">#endif</a>
<a name="ln220">	TQ_LOCK(queue);</a>
<a name="ln221">	gtask-&gt;ta_flags |= TASK_NOENQUEUE;</a>
<a name="ln222">  	gtaskqueue_drain_locked(queue, gtask);</a>
<a name="ln223">	TQ_UNLOCK(queue);</a>
<a name="ln224">}</a>
<a name="ln225"> </a>
<a name="ln226">void</a>
<a name="ln227">grouptask_unblock(struct grouptask *grouptask)</a>
<a name="ln228">{</a>
<a name="ln229">	struct gtaskqueue *queue = grouptask-&gt;gt_taskqueue;</a>
<a name="ln230">	struct gtask *gtask = &amp;grouptask-&gt;gt_task;</a>
<a name="ln231"> </a>
<a name="ln232">#ifdef INVARIANTS</a>
<a name="ln233">	if (queue == NULL) {</a>
<a name="ln234">		gtask_dump(gtask);</a>
<a name="ln235">		panic(&quot;queue == NULL&quot;);</a>
<a name="ln236">	}</a>
<a name="ln237">#endif</a>
<a name="ln238">	TQ_LOCK(queue);</a>
<a name="ln239">	gtask-&gt;ta_flags &amp;= ~TASK_NOENQUEUE;</a>
<a name="ln240">	TQ_UNLOCK(queue);</a>
<a name="ln241">}</a>
<a name="ln242"> </a>
<a name="ln243">int</a>
<a name="ln244">grouptaskqueue_enqueue(struct gtaskqueue *queue, struct gtask *gtask)</a>
<a name="ln245">{</a>
<a name="ln246">#ifdef INVARIANTS</a>
<a name="ln247">	if (queue == NULL) {</a>
<a name="ln248">		gtask_dump(gtask);</a>
<a name="ln249">		panic(&quot;queue == NULL&quot;);</a>
<a name="ln250">	}</a>
<a name="ln251">#endif</a>
<a name="ln252">	TQ_LOCK(queue);</a>
<a name="ln253">	if (gtask-&gt;ta_flags &amp; TASK_ENQUEUED) {</a>
<a name="ln254">		TQ_UNLOCK(queue);</a>
<a name="ln255">		return (0);</a>
<a name="ln256">	}</a>
<a name="ln257">	if (gtask-&gt;ta_flags &amp; TASK_NOENQUEUE) {</a>
<a name="ln258">		TQ_UNLOCK(queue);</a>
<a name="ln259">		return (EAGAIN);</a>
<a name="ln260">	}</a>
<a name="ln261">	STAILQ_INSERT_TAIL(&amp;queue-&gt;tq_queue, gtask, ta_link);</a>
<a name="ln262">	gtask-&gt;ta_flags |= TASK_ENQUEUED;</a>
<a name="ln263">	TQ_UNLOCK(queue);</a>
<a name="ln264">	if ((queue-&gt;tq_flags &amp; TQ_FLAGS_BLOCKED) == 0)</a>
<a name="ln265">		queue-&gt;tq_enqueue(queue-&gt;tq_context);</a>
<a name="ln266">	return (0);</a>
<a name="ln267">}</a>
<a name="ln268"> </a>
<a name="ln269">static void</a>
<a name="ln270">gtaskqueue_task_nop_fn(void *context)</a>
<a name="ln271">{</a>
<a name="ln272">}</a>
<a name="ln273"> </a>
<a name="ln274">/*</a>
<a name="ln275"> * Block until all currently queued tasks in this taskqueue</a>
<a name="ln276"> * have begun execution.  Tasks queued during execution of</a>
<a name="ln277"> * this function are ignored.</a>
<a name="ln278"> */</a>
<a name="ln279">static void</a>
<a name="ln280">gtaskqueue_drain_tq_queue(struct gtaskqueue *queue)</a>
<a name="ln281">{</a>
<a name="ln282">	struct gtask t_barrier;</a>
<a name="ln283"> </a>
<a name="ln284">	if (STAILQ_EMPTY(&amp;queue-&gt;tq_queue))</a>
<a name="ln285">		return;</a>
<a name="ln286"> </a>
<a name="ln287">	/*</a>
<a name="ln288">	 * Enqueue our barrier after all current tasks, but with</a>
<a name="ln289">	 * the highest priority so that newly queued tasks cannot</a>
<a name="ln290">	 * pass it.  Because of the high priority, we can not use</a>
<a name="ln291">	 * taskqueue_enqueue_locked directly (which drops the lock</a>
<a name="ln292">	 * anyway) so just insert it at tail while we have the</a>
<a name="ln293">	 * queue lock.</a>
<a name="ln294">	 */</a>
<a name="ln295">	GTASK_INIT(&amp;t_barrier, 0, USHRT_MAX, gtaskqueue_task_nop_fn, &amp;t_barrier);</a>
<a name="ln296">	STAILQ_INSERT_TAIL(&amp;queue-&gt;tq_queue, &amp;t_barrier, ta_link);</a>
<a name="ln297">	t_barrier.ta_flags |= TASK_ENQUEUED;</a>
<a name="ln298"> </a>
<a name="ln299">	/*</a>
<a name="ln300">	 * Once the barrier has executed, all previously queued tasks</a>
<a name="ln301">	 * have completed or are currently executing.</a>
<a name="ln302">	 */</a>
<a name="ln303">	while (t_barrier.ta_flags &amp; TASK_ENQUEUED)</a>
<a name="ln304">		TQ_SLEEP(queue, &amp;t_barrier, &amp;queue-&gt;tq_mutex, PWAIT, &quot;-&quot;, 0);</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">/*</a>
<a name="ln308"> * Block until all currently executing tasks for this taskqueue</a>
<a name="ln309"> * complete.  Tasks that begin execution during the execution</a>
<a name="ln310"> * of this function are ignored.</a>
<a name="ln311"> */</a>
<a name="ln312">static void</a>
<a name="ln313">gtaskqueue_drain_tq_active(struct gtaskqueue *queue)</a>
<a name="ln314">{</a>
<a name="ln315">	struct gtaskqueue_busy tb_marker, *tb_first;</a>
<a name="ln316"> </a>
<a name="ln317">	if (TAILQ_EMPTY(&amp;queue-&gt;tq_active))</a>
<a name="ln318">		return;</a>
<a name="ln319"> </a>
<a name="ln320">	/* Block taskq_terminate().*/</a>
<a name="ln321">	queue-&gt;tq_callouts++;</a>
<a name="ln322"> </a>
<a name="ln323">	/*</a>
<a name="ln324">	 * Wait for all currently executing taskqueue threads</a>
<a name="ln325">	 * to go idle.</a>
<a name="ln326">	 */</a>
<a name="ln327">	tb_marker.tb_running = TB_DRAIN_WAITER;</a>
<a name="ln328">	TAILQ_INSERT_TAIL(&amp;queue-&gt;tq_active, &amp;tb_marker, tb_link);</a>
<a name="ln329">	while (TAILQ_FIRST(&amp;queue-&gt;tq_active) != &amp;tb_marker)</a>
<a name="ln330">		TQ_SLEEP(queue, &amp;tb_marker, &amp;queue-&gt;tq_mutex, PWAIT, &quot;-&quot;, 0);</a>
<a name="ln331">	TAILQ_REMOVE(&amp;queue-&gt;tq_active, &amp;tb_marker, tb_link);</a>
<a name="ln332"> </a>
<a name="ln333">	/*</a>
<a name="ln334">	 * Wakeup any other drain waiter that happened to queue up</a>
<a name="ln335">	 * without any intervening active thread.</a>
<a name="ln336">	 */</a>
<a name="ln337">	tb_first = TAILQ_FIRST(&amp;queue-&gt;tq_active);</a>
<a name="ln338">	if (tb_first != NULL &amp;&amp; tb_first-&gt;tb_running == TB_DRAIN_WAITER)</a>
<a name="ln339">		wakeup(tb_first);</a>
<a name="ln340"> </a>
<a name="ln341">	/* Release taskqueue_terminate(). */</a>
<a name="ln342">	queue-&gt;tq_callouts--;</a>
<a name="ln343">	if ((queue-&gt;tq_flags &amp; TQ_FLAGS_ACTIVE) == 0)</a>
<a name="ln344">		wakeup_one(queue-&gt;tq_threads);</a>
<a name="ln345">}</a>
<a name="ln346"> </a>
<a name="ln347">void</a>
<a name="ln348">gtaskqueue_block(struct gtaskqueue *queue)</a>
<a name="ln349">{</a>
<a name="ln350"> </a>
<a name="ln351">	TQ_LOCK(queue);</a>
<a name="ln352">	queue-&gt;tq_flags |= TQ_FLAGS_BLOCKED;</a>
<a name="ln353">	TQ_UNLOCK(queue);</a>
<a name="ln354">}</a>
<a name="ln355"> </a>
<a name="ln356">void</a>
<a name="ln357">gtaskqueue_unblock(struct gtaskqueue *queue)</a>
<a name="ln358">{</a>
<a name="ln359"> </a>
<a name="ln360">	TQ_LOCK(queue);</a>
<a name="ln361">	queue-&gt;tq_flags &amp;= ~TQ_FLAGS_BLOCKED;</a>
<a name="ln362">	if (!STAILQ_EMPTY(&amp;queue-&gt;tq_queue))</a>
<a name="ln363">		queue-&gt;tq_enqueue(queue-&gt;tq_context);</a>
<a name="ln364">	TQ_UNLOCK(queue);</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367">static void</a>
<a name="ln368">gtaskqueue_run_locked(struct gtaskqueue *queue)</a>
<a name="ln369">{</a>
<a name="ln370">	struct gtaskqueue_busy tb;</a>
<a name="ln371">	struct gtaskqueue_busy *tb_first;</a>
<a name="ln372">	struct gtask *gtask;</a>
<a name="ln373"> </a>
<a name="ln374">	KASSERT(queue != NULL, (&quot;tq is NULL&quot;));</a>
<a name="ln375">	TQ_ASSERT_LOCKED(queue);</a>
<a name="ln376">	tb.tb_running = NULL;</a>
<a name="ln377"> </a>
<a name="ln378">	while (STAILQ_FIRST(&amp;queue-&gt;tq_queue)) {</a>
<a name="ln379">		TAILQ_INSERT_TAIL(&amp;queue-&gt;tq_active, &amp;tb, tb_link);</a>
<a name="ln380"> </a>
<a name="ln381">		/*</a>
<a name="ln382">		 * Carefully remove the first task from the queue and</a>
<a name="ln383">		 * clear its TASK_ENQUEUED flag</a>
<a name="ln384">		 */</a>
<a name="ln385">		gtask = STAILQ_FIRST(&amp;queue-&gt;tq_queue);</a>
<a name="ln386">		KASSERT(gtask != NULL, (&quot;task is NULL&quot;));</a>
<a name="ln387">		STAILQ_REMOVE_HEAD(&amp;queue-&gt;tq_queue, ta_link);</a>
<a name="ln388">		gtask-&gt;ta_flags &amp;= ~TASK_ENQUEUED;</a>
<a name="ln389">		tb.tb_running = gtask;</a>
<a name="ln390">		TQ_UNLOCK(queue);</a>
<a name="ln391"> </a>
<a name="ln392">		KASSERT(gtask-&gt;ta_func != NULL, (&quot;task-&gt;ta_func is NULL&quot;));</a>
<a name="ln393">		gtask-&gt;ta_func(gtask-&gt;ta_context);</a>
<a name="ln394"> </a>
<a name="ln395">		TQ_LOCK(queue);</a>
<a name="ln396">		tb.tb_running = NULL;</a>
<a name="ln397">		wakeup(gtask);</a>
<a name="ln398"> </a>
<a name="ln399">		TAILQ_REMOVE(&amp;queue-&gt;tq_active, &amp;tb, tb_link);</a>
<a name="ln400">		tb_first = TAILQ_FIRST(&amp;queue-&gt;tq_active);</a>
<a name="ln401">		if (tb_first != NULL &amp;&amp;</a>
<a name="ln402">		    tb_first-&gt;tb_running == TB_DRAIN_WAITER)</a>
<a name="ln403">			wakeup(tb_first);</a>
<a name="ln404">	}</a>
<a name="ln405">}</a>
<a name="ln406"> </a>
<a name="ln407">static int</a>
<a name="ln408">task_is_running(struct gtaskqueue *queue, struct gtask *gtask)</a>
<a name="ln409">{</a>
<a name="ln410">	struct gtaskqueue_busy *tb;</a>
<a name="ln411"> </a>
<a name="ln412">	TQ_ASSERT_LOCKED(queue);</a>
<a name="ln413">	TAILQ_FOREACH(tb, &amp;queue-&gt;tq_active, tb_link) {</a>
<a name="ln414">		if (tb-&gt;tb_running == gtask)</a>
<a name="ln415">			return (1);</a>
<a name="ln416">	}</a>
<a name="ln417">	return (0);</a>
<a name="ln418">}</a>
<a name="ln419"> </a>
<a name="ln420">static int</a>
<a name="ln421">gtaskqueue_cancel_locked(struct gtaskqueue *queue, struct gtask *gtask)</a>
<a name="ln422">{</a>
<a name="ln423"> </a>
<a name="ln424">	if (gtask-&gt;ta_flags &amp; TASK_ENQUEUED)</a>
<a name="ln425">		STAILQ_REMOVE(&amp;queue-&gt;tq_queue, gtask, gtask, ta_link);</a>
<a name="ln426">	gtask-&gt;ta_flags &amp;= ~TASK_ENQUEUED;</a>
<a name="ln427">	return (task_is_running(queue, gtask) ? EBUSY : 0);</a>
<a name="ln428">}</a>
<a name="ln429"> </a>
<a name="ln430">int</a>
<a name="ln431">gtaskqueue_cancel(struct gtaskqueue *queue, struct gtask *gtask)</a>
<a name="ln432">{</a>
<a name="ln433">	int error;</a>
<a name="ln434"> </a>
<a name="ln435">	TQ_LOCK(queue);</a>
<a name="ln436">	error = gtaskqueue_cancel_locked(queue, gtask);</a>
<a name="ln437">	TQ_UNLOCK(queue);</a>
<a name="ln438"> </a>
<a name="ln439">	return (error);</a>
<a name="ln440">}</a>
<a name="ln441"> </a>
<a name="ln442">static void</a>
<a name="ln443">gtaskqueue_drain_locked(struct gtaskqueue *queue, struct gtask *gtask)</a>
<a name="ln444">{</a>
<a name="ln445">	while ((gtask-&gt;ta_flags &amp; TASK_ENQUEUED) || task_is_running(queue, gtask))</a>
<a name="ln446">		TQ_SLEEP(queue, gtask, &amp;queue-&gt;tq_mutex, PWAIT, &quot;-&quot;, 0);</a>
<a name="ln447">}</a>
<a name="ln448"> </a>
<a name="ln449">void</a>
<a name="ln450">gtaskqueue_drain(struct gtaskqueue *queue, struct gtask *gtask)</a>
<a name="ln451">{</a>
<a name="ln452">#ifndef __HAIKU__</a>
<a name="ln453">	if (!queue-&gt;tq_spin)</a>
<a name="ln454">		WITNESS_WARN(WARN_GIANTOK | WARN_SLEEPOK, NULL, __func__);</a>
<a name="ln455">#endif</a>
<a name="ln456"> </a>
<a name="ln457">	TQ_LOCK(queue);</a>
<a name="ln458">	gtaskqueue_drain_locked(queue, gtask);</a>
<a name="ln459">	TQ_UNLOCK(queue);</a>
<a name="ln460">}</a>
<a name="ln461"> </a>
<a name="ln462">void</a>
<a name="ln463">gtaskqueue_drain_all(struct gtaskqueue *queue)</a>
<a name="ln464">{</a>
<a name="ln465">#ifndef __HAIKU__</a>
<a name="ln466">	if (!queue-&gt;tq_spin)</a>
<a name="ln467">		WITNESS_WARN(WARN_GIANTOK | WARN_SLEEPOK, NULL, __func__);</a>
<a name="ln468">#endif</a>
<a name="ln469"> </a>
<a name="ln470">	TQ_LOCK(queue);</a>
<a name="ln471">	gtaskqueue_drain_tq_queue(queue);</a>
<a name="ln472">	gtaskqueue_drain_tq_active(queue);</a>
<a name="ln473">	TQ_UNLOCK(queue);</a>
<a name="ln474">}</a>
<a name="ln475"> </a>
<a name="ln476">static int</a>
<a name="ln477">_gtaskqueue_start_threads(struct gtaskqueue **tqp, int count, int pri,</a>
<a name="ln478">    void* mask, const char *name, va_list ap)</a>
<a name="ln479">{</a>
<a name="ln480">	char ktname[19 + 1];</a>
<a name="ln481">	struct thread *td;</a>
<a name="ln482">	struct gtaskqueue *tq;</a>
<a name="ln483">	int i, error;</a>
<a name="ln484"> </a>
<a name="ln485">	if (count &lt;= 0)</a>
<a name="ln486">		return (EINVAL);</a>
<a name="ln487"> </a>
<a name="ln488">	vsnprintf(ktname, sizeof(ktname), name, ap);</a>
<a name="ln489">	tq = *tqp;</a>
<a name="ln490"> </a>
<a name="ln491">	tq-&gt;tq_threads = malloc(sizeof(struct thread *) * count, M_GTASKQUEUE,</a>
<a name="ln492">	    M_NOWAIT | M_ZERO);</a>
<a name="ln493">	if (tq-&gt;tq_threads == NULL) {</a>
<a name="ln494">		printf(&quot;%s: no memory for %s threads\n&quot;, __func__, ktname);</a>
<a name="ln495">		return (ENOMEM);</a>
<a name="ln496">	}</a>
<a name="ln497"> </a>
<a name="ln498">	for (i = 0; i &lt; count; i++) {</a>
<a name="ln499">		if (count == 1)</a>
<a name="ln500">			error = kthread_add(gtaskqueue_thread_loop, tqp, NULL,</a>
<a name="ln501">			    &amp;tq-&gt;tq_threads[i], 0, 0, &quot;%s&quot;, ktname);</a>
<a name="ln502">		else</a>
<a name="ln503">			error = kthread_add(gtaskqueue_thread_loop, tqp, NULL,</a>
<a name="ln504">			    &amp;tq-&gt;tq_threads[i], 0, 0,</a>
<a name="ln505">			    &quot;%s_%d&quot;, ktname, i);</a>
<a name="ln506">		if (error) {</a>
<a name="ln507">			/* should be ok to continue, taskqueue_free will dtrt */</a>
<a name="ln508">			printf(&quot;%s: kthread_add(%s): error %d&quot;, __func__,</a>
<a name="ln509">			    ktname, error);</a>
<a name="ln510">			tq-&gt;tq_threads[i] = NULL;		/* paranoid */</a>
<a name="ln511">		} else</a>
<a name="ln512">			tq-&gt;tq_tcount++;</a>
<a name="ln513">	}</a>
<a name="ln514">	for (i = 0; i &lt; count; i++) {</a>
<a name="ln515">		if (tq-&gt;tq_threads[i] == NULL)</a>
<a name="ln516">			continue;</a>
<a name="ln517">		td = tq-&gt;tq_threads[i];</a>
<a name="ln518">#ifndef __HAIKU__</a>
<a name="ln519">		if (mask) {</a>
<a name="ln520">			error = cpuset_setthread(td-&gt;td_tid, mask);</a>
<a name="ln521">			/*</a>
<a name="ln522">			 * Failing to pin is rarely an actual fatal error;</a>
<a name="ln523">			 * it'll just affect performance.</a>
<a name="ln524">			 */</a>
<a name="ln525">			if (error)</a>
<a name="ln526">				printf(&quot;%s: curthread=%llu: can't pin; &quot;</a>
<a name="ln527">				    &quot;error=%d\n&quot;,</a>
<a name="ln528">				    __func__,</a>
<a name="ln529">				    (unsigned long long) td-&gt;td_tid,</a>
<a name="ln530">				    error);</a>
<a name="ln531">		}</a>
<a name="ln532">#endif</a>
<a name="ln533">		thread_lock(td);</a>
<a name="ln534">		sched_prio(td, pri);</a>
<a name="ln535">		sched_add(td, SRQ_BORING);</a>
<a name="ln536">		thread_unlock(td);</a>
<a name="ln537">	}</a>
<a name="ln538"> </a>
<a name="ln539">	return (0);</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542">static int</a>
<a name="ln543">gtaskqueue_start_threads(struct gtaskqueue **tqp, int count, int pri,</a>
<a name="ln544">    const char *name, ...)</a>
<a name="ln545">{</a>
<a name="ln546">	va_list ap;</a>
<a name="ln547">	int error;</a>
<a name="ln548"> </a>
<a name="ln549">	va_start(ap, name);</a>
<a name="ln550">	error = _gtaskqueue_start_threads(tqp, count, pri, NULL, name, ap);</a>
<a name="ln551">	va_end(ap);</a>
<a name="ln552">	return (error);</a>
<a name="ln553">}</a>
<a name="ln554"> </a>
<a name="ln555">static inline void</a>
<a name="ln556">gtaskqueue_run_callback(struct gtaskqueue *tq,</a>
<a name="ln557">    enum taskqueue_callback_type cb_type)</a>
<a name="ln558">{</a>
<a name="ln559">	taskqueue_callback_fn tq_callback;</a>
<a name="ln560"> </a>
<a name="ln561">	TQ_ASSERT_UNLOCKED(tq);</a>
<a name="ln562">	tq_callback = tq-&gt;tq_callbacks[cb_type];</a>
<a name="ln563">	if (tq_callback != NULL)</a>
<a name="ln564">		tq_callback(tq-&gt;tq_cb_contexts[cb_type]);</a>
<a name="ln565">}</a>
<a name="ln566"> </a>
<a name="ln567">static void</a>
<a name="ln568">gtaskqueue_thread_loop(void *arg)</a>
<a name="ln569">{</a>
<a name="ln570">	struct gtaskqueue **tqp, *tq;</a>
<a name="ln571"> </a>
<a name="ln572">	tqp = arg;</a>
<a name="ln573">	tq = *tqp;</a>
<a name="ln574">	gtaskqueue_run_callback(tq, TASKQUEUE_CALLBACK_TYPE_INIT);</a>
<a name="ln575">	TQ_LOCK(tq);</a>
<a name="ln576">	while ((tq-&gt;tq_flags &amp; TQ_FLAGS_ACTIVE) != 0) {</a>
<a name="ln577">		/* XXX ? */</a>
<a name="ln578">		gtaskqueue_run_locked(tq);</a>
<a name="ln579">		/*</a>
<a name="ln580">		 * Because taskqueue_run() can drop tq_mutex, we need to</a>
<a name="ln581">		 * check if the TQ_FLAGS_ACTIVE flag wasn't removed in the</a>
<a name="ln582">		 * meantime, which means we missed a wakeup.</a>
<a name="ln583">		 */</a>
<a name="ln584">		if ((tq-&gt;tq_flags &amp; TQ_FLAGS_ACTIVE) == 0)</a>
<a name="ln585">			break;</a>
<a name="ln586">#ifndef __HAIKU__</a>
<a name="ln587">		TQ_SLEEP(tq, tq, &amp;tq-&gt;tq_mutex, 0, &quot;-&quot;, 0);</a>
<a name="ln588">#else</a>
<a name="ln589">		TQ_UNLOCK(tq);</a>
<a name="ln590">		acquire_sem(tq-&gt;tq_sem);</a>
<a name="ln591">		TQ_LOCK(tq);</a>
<a name="ln592">#endif</a>
<a name="ln593">	}</a>
<a name="ln594">	gtaskqueue_run_locked(tq);</a>
<a name="ln595">	/*</a>
<a name="ln596">	 * This thread is on its way out, so just drop the lock temporarily</a>
<a name="ln597">	 * in order to call the shutdown callback.  This allows the callback</a>
<a name="ln598">	 * to look at the taskqueue, even just before it dies.</a>
<a name="ln599">	 */</a>
<a name="ln600">	TQ_UNLOCK(tq);</a>
<a name="ln601">	gtaskqueue_run_callback(tq, TASKQUEUE_CALLBACK_TYPE_SHUTDOWN);</a>
<a name="ln602">	TQ_LOCK(tq);</a>
<a name="ln603"> </a>
<a name="ln604">	/* rendezvous with thread that asked us to terminate */</a>
<a name="ln605">	tq-&gt;tq_tcount--;</a>
<a name="ln606">	wakeup_one(tq-&gt;tq_threads);</a>
<a name="ln607">	TQ_UNLOCK(tq);</a>
<a name="ln608">	kthread_exit();</a>
<a name="ln609">}</a>
<a name="ln610"> </a>
<a name="ln611">static void</a>
<a name="ln612">gtaskqueue_thread_enqueue(void *context)</a>
<a name="ln613">{</a>
<a name="ln614">	struct gtaskqueue **tqp, *tq;</a>
<a name="ln615"> </a>
<a name="ln616">	tqp = context;</a>
<a name="ln617">	tq = *tqp;</a>
<a name="ln618">#ifndef __HAIKU__</a>
<a name="ln619">	wakeup_one(tq);</a>
<a name="ln620">#else</a>
<a name="ln621">	release_sem_etc(tq-&gt;tq_sem, 1, B_DO_NOT_RESCHEDULE);</a>
<a name="ln622">#endif</a>
<a name="ln623">}</a>
<a name="ln624"> </a>
<a name="ln625"> </a>
<a name="ln626">static struct gtaskqueue *</a>
<a name="ln627">gtaskqueue_create_fast(const char *name, int mflags,</a>
<a name="ln628">		 taskqueue_enqueue_fn enqueue, void *context)</a>
<a name="ln629">{</a>
<a name="ln630">	return _gtaskqueue_create(name, mflags, enqueue, context,</a>
<a name="ln631">			MTX_SPIN, &quot;fast_taskqueue&quot;);</a>
<a name="ln632">}</a>
<a name="ln633"> </a>
<a name="ln634"> </a>
<a name="ln635">struct taskqgroup_cpu {</a>
<a name="ln636">	LIST_HEAD(, grouptask)	tgc_tasks;</a>
<a name="ln637">	struct gtaskqueue	*tgc_taskq;</a>
<a name="ln638">	int	tgc_cnt;</a>
<a name="ln639">	int	tgc_cpu;</a>
<a name="ln640">};</a>
<a name="ln641"> </a>
<a name="ln642">struct taskqgroup {</a>
<a name="ln643">	struct taskqgroup_cpu tqg_queue[MAXCPU];</a>
<a name="ln644">	struct mtx	tqg_lock;</a>
<a name="ln645">	const char *	tqg_name;</a>
<a name="ln646">	int		tqg_adjusting;</a>
<a name="ln647">	int		tqg_stride;</a>
<a name="ln648">	int		tqg_cnt;</a>
<a name="ln649">};</a>
<a name="ln650"> </a>
<a name="ln651">struct taskq_bind_task {</a>
<a name="ln652">	struct gtask bt_task;</a>
<a name="ln653">	int	bt_cpuid;</a>
<a name="ln654">};</a>
<a name="ln655"> </a>
<a name="ln656">static void</a>
<a name="ln657">taskqgroup_cpu_create(struct taskqgroup *qgroup, int idx, int cpu)</a>
<a name="ln658">{</a>
<a name="ln659">	struct taskqgroup_cpu *qcpu;</a>
<a name="ln660"> </a>
<a name="ln661">	qcpu = &amp;qgroup-&gt;tqg_queue[idx];</a>
<a name="ln662">	LIST_INIT(&amp;qcpu-&gt;tgc_tasks);</a>
<a name="ln663">	qcpu-&gt;tgc_taskq = gtaskqueue_create_fast(NULL, M_WAITOK,</a>
<a name="ln664">	    gtaskqueue_thread_enqueue, &amp;qcpu-&gt;tgc_taskq);</a>
<a name="ln665">	MPASS(qcpu-&gt;tgc_taskq);</a>
<a name="ln666">	gtaskqueue_start_threads(&amp;qcpu-&gt;tgc_taskq, 1, PI_SOFT,</a>
<a name="ln667">	    &quot;%s_%d&quot;, qgroup-&gt;tqg_name, idx);</a>
<a name="ln668">	qcpu-&gt;tgc_cpu = cpu;</a>
<a name="ln669">}</a>
<a name="ln670"> </a>
<a name="ln671">static void</a>
<a name="ln672">taskqgroup_cpu_remove(struct taskqgroup *qgroup, int idx)</a>
<a name="ln673">{</a>
<a name="ln674"> </a>
<a name="ln675">	gtaskqueue_free(qgroup-&gt;tqg_queue[idx].tgc_taskq);</a>
<a name="ln676">}</a>
<a name="ln677"> </a>
<a name="ln678">/*</a>
<a name="ln679"> * Find the taskq with least # of tasks that doesn't currently have any</a>
<a name="ln680"> * other queues from the uniq identifier.</a>
<a name="ln681"> */</a>
<a name="ln682">static int</a>
<a name="ln683">taskqgroup_find(struct taskqgroup *qgroup, void *uniq)</a>
<a name="ln684">{</a>
<a name="ln685">	struct grouptask *n;</a>
<a name="ln686">	int i, idx, mincnt;</a>
<a name="ln687">	int strict;</a>
<a name="ln688"> </a>
<a name="ln689">	mtx_assert(&amp;qgroup-&gt;tqg_lock, MA_OWNED);</a>
<a name="ln690">#ifndef __HAIKU__</a>
<a name="ln691">	if (qgroup-&gt;tqg_cnt == 0)</a>
<a name="ln692">#else</a>
<a name="ln693">	KASSERT(qgroup-&gt;tqg_cnt &gt; 0, (&quot;qgroup(%p)-&gt;tqg_cnt is %d!&quot;, qgroup, qgroup-&gt;tqg_cnt));</a>
<a name="ln694">	if (qgroup-&gt;tqg_cnt == 1)</a>
<a name="ln695">#endif</a>
<a name="ln696">		return (0);</a>
<a name="ln697">	idx = -1;</a>
<a name="ln698">	mincnt = INT_MAX;</a>
<a name="ln699">	/*</a>
<a name="ln700">	 * Two passes;  First scan for a queue with the least tasks that</a>
<a name="ln701">	 * does not already service this uniq id.  If that fails simply find</a>
<a name="ln702">	 * the queue with the least total tasks;</a>
<a name="ln703">	 */</a>
<a name="ln704">	for (strict = 1; mincnt == INT_MAX; strict = 0) {</a>
<a name="ln705">		for (i = 0; i &lt; qgroup-&gt;tqg_cnt; i++) {</a>
<a name="ln706">			if (qgroup-&gt;tqg_queue[i].tgc_cnt &gt; mincnt)</a>
<a name="ln707">				continue;</a>
<a name="ln708">			if (strict) {</a>
<a name="ln709">				LIST_FOREACH(n,</a>
<a name="ln710">				    &amp;qgroup-&gt;tqg_queue[i].tgc_tasks, gt_list)</a>
<a name="ln711">					if (n-&gt;gt_uniq == uniq)</a>
<a name="ln712">						break;</a>
<a name="ln713">				if (n != NULL)</a>
<a name="ln714">					continue;</a>
<a name="ln715">			}</a>
<a name="ln716">			mincnt = qgroup-&gt;tqg_queue[i].tgc_cnt;</a>
<a name="ln717">			idx = i;</a>
<a name="ln718">		}</a>
<a name="ln719">	}</a>
<a name="ln720">	if (idx == -1)</a>
<a name="ln721">		panic(&quot;%s: failed to pick a qid.&quot;, __func__);</a>
<a name="ln722"> </a>
<a name="ln723">	return (idx);</a>
<a name="ln724">}</a>
<a name="ln725"> </a>
<a name="ln726">/*</a>
<a name="ln727"> * smp_started is unusable since it is not set for UP kernels or even for</a>
<a name="ln728"> * SMP kernels when there is 1 CPU.  This is usually handled by adding a</a>
<a name="ln729"> * (mp_ncpus == 1) test, but that would be broken here since we need to</a>
<a name="ln730"> * to synchronize with the SI_SUB_SMP ordering.  Even in the pure SMP case</a>
<a name="ln731"> * smp_started only gives a fuzzy ordering relative to SI_SUB_SMP.</a>
<a name="ln732"> *</a>
<a name="ln733"> * So maintain our own flag.  It must be set after all CPUs are started</a>
<a name="ln734"> * and before SI_SUB_SMP:SI_ORDER_ANY so that the SYSINIT for delayed</a>
<a name="ln735"> * adjustment is properly delayed.  SI_ORDER_FOURTH is clearly before</a>
<a name="ln736"> * SI_ORDER_ANY and unclearly after the CPUs are started.  It would be</a>
<a name="ln737"> * simpler for adjustment to pass a flag indicating if it is delayed.</a>
<a name="ln738"> */ </a>
<a name="ln739"> </a>
<a name="ln740">static int tqg_smp_started;</a>
<a name="ln741"> </a>
<a name="ln742">static void</a>
<a name="ln743">tqg_record_smp_started(void *arg)</a>
<a name="ln744">{</a>
<a name="ln745">	tqg_smp_started = 1;</a>
<a name="ln746">}</a>
<a name="ln747"> </a>
<a name="ln748">SYSINIT(tqg_record_smp_started, SI_SUB_SMP, SI_ORDER_FOURTH,</a>
<a name="ln749">	tqg_record_smp_started, NULL);</a>
<a name="ln750"> </a>
<a name="ln751">void</a>
<a name="ln752">taskqgroup_attach(struct taskqgroup *qgroup, struct grouptask *gtask,</a>
<a name="ln753">    void *uniq, device_t dev, struct resource *irq, const char *name)</a>
<a name="ln754">{</a>
<a name="ln755">	int cpu, qid, error;</a>
<a name="ln756"> </a>
<a name="ln757">	gtask-&gt;gt_uniq = uniq;</a>
<a name="ln758">	snprintf(gtask-&gt;gt_name, GROUPTASK_NAMELEN, &quot;%s&quot;, name ? name : &quot;grouptask&quot;);</a>
<a name="ln759">	gtask-&gt;gt_dev = dev;</a>
<a name="ln760">	gtask-&gt;gt_irq = irq;</a>
<a name="ln761">	gtask-&gt;gt_cpu = -1;</a>
<a name="ln762">	mtx_lock(&amp;qgroup-&gt;tqg_lock);</a>
<a name="ln763">	qid = taskqgroup_find(qgroup, uniq);</a>
<a name="ln764">	qgroup-&gt;tqg_queue[qid].tgc_cnt++;</a>
<a name="ln765">	LIST_INSERT_HEAD(&amp;qgroup-&gt;tqg_queue[qid].tgc_tasks, gtask, gt_list);</a>
<a name="ln766">	gtask-&gt;gt_taskqueue = qgroup-&gt;tqg_queue[qid].tgc_taskq;</a>
<a name="ln767">	if (dev != NULL &amp;&amp; irq != NULL &amp;&amp; tqg_smp_started) {</a>
<a name="ln768">		cpu = qgroup-&gt;tqg_queue[qid].tgc_cpu;</a>
<a name="ln769">		gtask-&gt;gt_cpu = cpu;</a>
<a name="ln770">		mtx_unlock(&amp;qgroup-&gt;tqg_lock);</a>
<a name="ln771">		error = bus_bind_intr(dev, irq, cpu);</a>
<a name="ln772">		if (error)</a>
<a name="ln773">			printf(&quot;%s: binding interrupt failed for %s: %d\n&quot;,</a>
<a name="ln774">			    __func__, gtask-&gt;gt_name, error);</a>
<a name="ln775">	} else</a>
<a name="ln776">		mtx_unlock(&amp;qgroup-&gt;tqg_lock);</a>
<a name="ln777">}</a>
<a name="ln778"> </a>
<a name="ln779">static void</a>
<a name="ln780">taskqgroup_attach_deferred(struct taskqgroup *qgroup, struct grouptask *gtask)</a>
<a name="ln781">{</a>
<a name="ln782">	int qid, cpu, error;</a>
<a name="ln783"> </a>
<a name="ln784">	mtx_lock(&amp;qgroup-&gt;tqg_lock);</a>
<a name="ln785">	qid = taskqgroup_find(qgroup, gtask-&gt;gt_uniq);</a>
<a name="ln786">	cpu = qgroup-&gt;tqg_queue[qid].tgc_cpu;</a>
<a name="ln787">	if (gtask-&gt;gt_dev != NULL &amp;&amp; gtask-&gt;gt_irq != NULL) {</a>
<a name="ln788">		mtx_unlock(&amp;qgroup-&gt;tqg_lock);</a>
<a name="ln789">		error = bus_bind_intr(gtask-&gt;gt_dev, gtask-&gt;gt_irq, cpu);</a>
<a name="ln790">		mtx_lock(&amp;qgroup-&gt;tqg_lock);</a>
<a name="ln791">		if (error)</a>
<a name="ln792">			printf(&quot;%s: binding interrupt failed for %s: %d\n&quot;,</a>
<a name="ln793">			    __func__, gtask-&gt;gt_name, error);</a>
<a name="ln794"> </a>
<a name="ln795">	}</a>
<a name="ln796">	qgroup-&gt;tqg_queue[qid].tgc_cnt++;</a>
<a name="ln797">	LIST_INSERT_HEAD(&amp;qgroup-&gt;tqg_queue[qid].tgc_tasks, gtask, gt_list);</a>
<a name="ln798">	MPASS(qgroup-&gt;tqg_queue[qid].tgc_taskq != NULL);</a>
<a name="ln799">	gtask-&gt;gt_taskqueue = qgroup-&gt;tqg_queue[qid].tgc_taskq;</a>
<a name="ln800">	mtx_unlock(&amp;qgroup-&gt;tqg_lock);</a>
<a name="ln801">}</a>
<a name="ln802"> </a>
<a name="ln803">int</a>
<a name="ln804">taskqgroup_attach_cpu(struct taskqgroup *qgroup, struct grouptask *gtask,</a>
<a name="ln805">    void *uniq, int cpu, device_t dev, struct resource *irq, const char *name)</a>
<a name="ln806">{</a>
<a name="ln807">	int i, qid, error;</a>
<a name="ln808"> </a>
<a name="ln809">	qid = -1;</a>
<a name="ln810">	gtask-&gt;gt_uniq = uniq;</a>
<a name="ln811">	snprintf(gtask-&gt;gt_name, GROUPTASK_NAMELEN, &quot;%s&quot;, name ? name : &quot;grouptask&quot;);</a>
<a name="ln812">	gtask-&gt;gt_dev = dev;</a>
<a name="ln813">	gtask-&gt;gt_irq = irq;</a>
<a name="ln814">	gtask-&gt;gt_cpu = cpu;</a>
<a name="ln815">	mtx_lock(&amp;qgroup-&gt;tqg_lock);</a>
<a name="ln816">	if (tqg_smp_started) {</a>
<a name="ln817">		for (i = 0; i &lt; qgroup-&gt;tqg_cnt; i++)</a>
<a name="ln818">			if (qgroup-&gt;tqg_queue[i].tgc_cpu == cpu) {</a>
<a name="ln819">				qid = i;</a>
<a name="ln820">				break;</a>
<a name="ln821">			}</a>
<a name="ln822">		if (qid == -1) {</a>
<a name="ln823">			mtx_unlock(&amp;qgroup-&gt;tqg_lock);</a>
<a name="ln824">			printf(&quot;%s: qid not found for %s cpu=%d\n&quot;, __func__, gtask-&gt;gt_name, cpu);</a>
<a name="ln825">			return (EINVAL);</a>
<a name="ln826">		}</a>
<a name="ln827">	} else</a>
<a name="ln828">		qid = 0;</a>
<a name="ln829">	qgroup-&gt;tqg_queue[qid].tgc_cnt++;</a>
<a name="ln830">	LIST_INSERT_HEAD(&amp;qgroup-&gt;tqg_queue[qid].tgc_tasks, gtask, gt_list);</a>
<a name="ln831">	gtask-&gt;gt_taskqueue = qgroup-&gt;tqg_queue[qid].tgc_taskq;</a>
<a name="ln832">	cpu = qgroup-&gt;tqg_queue[qid].tgc_cpu;</a>
<a name="ln833">	mtx_unlock(&amp;qgroup-&gt;tqg_lock);</a>
<a name="ln834"> </a>
<a name="ln835">	if (dev != NULL &amp;&amp; irq != NULL &amp;&amp; tqg_smp_started) {</a>
<a name="ln836">		error = bus_bind_intr(dev, irq, cpu);</a>
<a name="ln837">		if (error)</a>
<a name="ln838">			printf(&quot;%s: binding interrupt failed for %s: %d\n&quot;,</a>
<a name="ln839">			    __func__, gtask-&gt;gt_name, error);</a>
<a name="ln840">	}</a>
<a name="ln841">	return (0);</a>
<a name="ln842">}</a>
<a name="ln843"> </a>
<a name="ln844">static int</a>
<a name="ln845">taskqgroup_attach_cpu_deferred(struct taskqgroup *qgroup, struct grouptask *gtask)</a>
<a name="ln846">{</a>
<a name="ln847">	device_t dev;</a>
<a name="ln848">	struct resource *irq;</a>
<a name="ln849">	int cpu, error, i, qid;</a>
<a name="ln850"> </a>
<a name="ln851">	qid = -1;</a>
<a name="ln852">	dev = gtask-&gt;gt_dev;</a>
<a name="ln853">	irq = gtask-&gt;gt_irq;</a>
<a name="ln854">	cpu = gtask-&gt;gt_cpu;</a>
<a name="ln855">	MPASS(tqg_smp_started);</a>
<a name="ln856">	mtx_lock(&amp;qgroup-&gt;tqg_lock);</a>
<a name="ln857">	for (i = 0; i &lt; qgroup-&gt;tqg_cnt; i++)</a>
<a name="ln858">		if (qgroup-&gt;tqg_queue[i].tgc_cpu == cpu) {</a>
<a name="ln859">			qid = i;</a>
<a name="ln860">			break;</a>
<a name="ln861">		}</a>
<a name="ln862">	if (qid == -1) {</a>
<a name="ln863">		mtx_unlock(&amp;qgroup-&gt;tqg_lock);</a>
<a name="ln864">		printf(&quot;%s: qid not found for %s cpu=%d\n&quot;, __func__, gtask-&gt;gt_name, cpu);</a>
<a name="ln865">		return (EINVAL);</a>
<a name="ln866">	}</a>
<a name="ln867">	qgroup-&gt;tqg_queue[qid].tgc_cnt++;</a>
<a name="ln868">	LIST_INSERT_HEAD(&amp;qgroup-&gt;tqg_queue[qid].tgc_tasks, gtask, gt_list);</a>
<a name="ln869">	MPASS(qgroup-&gt;tqg_queue[qid].tgc_taskq != NULL);</a>
<a name="ln870">	gtask-&gt;gt_taskqueue = qgroup-&gt;tqg_queue[qid].tgc_taskq;</a>
<a name="ln871">	mtx_unlock(&amp;qgroup-&gt;tqg_lock);</a>
<a name="ln872"> </a>
<a name="ln873">	if (dev != NULL &amp;&amp; irq != NULL) {</a>
<a name="ln874">		error = bus_bind_intr(dev, irq, cpu);</a>
<a name="ln875">		if (error)</a>
<a name="ln876">			printf(&quot;%s: binding interrupt failed for %s: %d\n&quot;,</a>
<a name="ln877">			    __func__, gtask-&gt;gt_name, error);</a>
<a name="ln878">	}</a>
<a name="ln879">	return (0);</a>
<a name="ln880">}</a>
<a name="ln881"> </a>
<a name="ln882">void</a>
<a name="ln883">taskqgroup_detach(struct taskqgroup *qgroup, struct grouptask *gtask)</a>
<a name="ln884">{</a>
<a name="ln885">	int i;</a>
<a name="ln886"> </a>
<a name="ln887">	grouptask_block(gtask);</a>
<a name="ln888">	mtx_lock(&amp;qgroup-&gt;tqg_lock);</a>
<a name="ln889">	for (i = 0; i &lt; qgroup-&gt;tqg_cnt; i++)</a>
<a name="ln890">		if (qgroup-&gt;tqg_queue[i].tgc_taskq == gtask-&gt;gt_taskqueue)</a>
<a name="ln891">			break;</a>
<a name="ln892">	if (i == qgroup-&gt;tqg_cnt)</a>
<a name="ln893">		panic(&quot;%s: task %s not in group&quot;, __func__, gtask-&gt;gt_name);</a>
<a name="ln894">	qgroup-&gt;tqg_queue[i].tgc_cnt--;</a>
<a name="ln895">	LIST_REMOVE(gtask, gt_list);</a>
<a name="ln896">	mtx_unlock(&amp;qgroup-&gt;tqg_lock);</a>
<a name="ln897">	gtask-&gt;gt_taskqueue = NULL;</a>
<a name="ln898">	gtask-&gt;gt_task.ta_flags &amp;= ~TASK_NOENQUEUE;</a>
<a name="ln899">}</a>
<a name="ln900"> </a>
<a name="ln901">static void</a>
<a name="ln902">taskqgroup_binder(void *ctx)</a>
<a name="ln903">{</a>
<a name="ln904">	struct taskq_bind_task *gtask = (struct taskq_bind_task *)ctx;</a>
<a name="ln905">#ifndef __HAIKU__</a>
<a name="ln906">	cpuset_t mask;</a>
<a name="ln907">	int error;</a>
<a name="ln908"> </a>
<a name="ln909">	CPU_ZERO(&amp;mask);</a>
<a name="ln910">	CPU_SET(gtask-&gt;bt_cpuid, &amp;mask);</a>
<a name="ln911">	error = cpuset_setthread(curthread-&gt;td_tid, &amp;mask);</a>
<a name="ln912">	thread_lock(curthread);</a>
<a name="ln913">	sched_bind(curthread, gtask-&gt;bt_cpuid);</a>
<a name="ln914">	thread_unlock(curthread);</a>
<a name="ln915"> </a>
<a name="ln916">	if (error)</a>
<a name="ln917">		printf(&quot;%s: binding curthread failed: %d\n&quot;, __func__, error);</a>
<a name="ln918">#endif</a>
<a name="ln919">	free(gtask, M_DEVBUF);</a>
<a name="ln920">}</a>
<a name="ln921"> </a>
<a name="ln922">static void</a>
<a name="ln923">taskqgroup_bind(struct taskqgroup *qgroup)</a>
<a name="ln924">{</a>
<a name="ln925">	struct taskq_bind_task *gtask;</a>
<a name="ln926">	int i;</a>
<a name="ln927"> </a>
<a name="ln928">	/*</a>
<a name="ln929">	 * Bind taskqueue threads to specific CPUs, if they have been assigned</a>
<a name="ln930">	 * one.</a>
<a name="ln931">	 */</a>
<a name="ln932">	if (qgroup-&gt;tqg_cnt == 1)</a>
<a name="ln933">		return;</a>
<a name="ln934"> </a>
<a name="ln935">	for (i = 0; i &lt; qgroup-&gt;tqg_cnt; i++) {</a>
<a name="ln936">		gtask = malloc(sizeof (*gtask), M_DEVBUF, M_WAITOK);</a>
<a name="ln937">		GTASK_INIT(&amp;gtask-&gt;bt_task, 0, 0, taskqgroup_binder, gtask);</a>
<a name="ln938">		gtask-&gt;bt_cpuid = qgroup-&gt;tqg_queue[i].tgc_cpu;</a>
<a name="ln939">		grouptaskqueue_enqueue(qgroup-&gt;tqg_queue[i].tgc_taskq,</a>
<a name="ln940">		    &amp;gtask-&gt;bt_task);</a>
<a name="ln941">	}</a>
<a name="ln942">}</a>
<a name="ln943"> </a>
<a name="ln944">static void</a>
<a name="ln945">taskqgroup_config_init(void *arg)</a>
<a name="ln946">{</a>
<a name="ln947">	struct taskqgroup *qgroup = qgroup_config;</a>
<a name="ln948">	LIST_HEAD(, grouptask) gtask_head = LIST_HEAD_INITIALIZER(NULL);</a>
<a name="ln949"> </a>
<a name="ln950">	LIST_SWAP(&amp;gtask_head, &amp;qgroup-&gt;tqg_queue[0].tgc_tasks,</a>
<a name="ln951">	    grouptask, gt_list);</a>
<a name="ln952">	qgroup-&gt;tqg_queue[0].tgc_cnt = 0;</a>
<a name="ln953">	taskqgroup_cpu_create(qgroup, 0, 0);</a>
<a name="ln954"> </a>
<a name="ln955">	qgroup-&gt;tqg_cnt = 1;</a>
<a name="ln956">	qgroup-&gt;tqg_stride = 1;</a>
<a name="ln957">}</a>
<a name="ln958"> </a>
<a name="ln959">SYSINIT(taskqgroup_config_init, SI_SUB_TASKQ, SI_ORDER_SECOND,</a>
<a name="ln960">	taskqgroup_config_init, NULL);</a>
<a name="ln961"> </a>
<a name="ln962">static int</a>
<a name="ln963">_taskqgroup_adjust(struct taskqgroup *qgroup, int cnt, int stride)</a>
<a name="ln964">{</a>
<a name="ln965">	LIST_HEAD(, grouptask) gtask_head = LIST_HEAD_INITIALIZER(NULL);</a>
<a name="ln966">	struct grouptask *gtask;</a>
<a name="ln967">	int i, k, old_cnt, old_cpu, cpu;</a>
<a name="ln968"> </a>
<a name="ln969">	mtx_assert(&amp;qgroup-&gt;tqg_lock, MA_OWNED);</a>
<a name="ln970"> </a>
<a name="ln971">	if (cnt &lt; 1 || cnt * stride &gt; mp_ncpus || !tqg_smp_started) {</a>
<a name="ln972">		printf(&quot;%s: failed cnt: %d stride: %d &quot;</a>
<a name="ln973">		    &quot;mp_ncpus: %d tqg_smp_started: %d\n&quot;,</a>
<a name="ln974">		    __func__, cnt, stride, mp_ncpus, tqg_smp_started);</a>
<a name="ln975">		return (EINVAL);</a>
<a name="ln976">	}</a>
<a name="ln977">	if (qgroup-&gt;tqg_adjusting) {</a>
<a name="ln978">		printf(&quot;%s failed: adjusting\n&quot;, __func__);</a>
<a name="ln979">		return (EBUSY);</a>
<a name="ln980">	}</a>
<a name="ln981">	qgroup-&gt;tqg_adjusting = 1;</a>
<a name="ln982">	old_cnt = qgroup-&gt;tqg_cnt;</a>
<a name="ln983">	old_cpu = 0;</a>
<a name="ln984">	if (old_cnt &lt; cnt)</a>
<a name="ln985">		old_cpu = qgroup-&gt;tqg_queue[old_cnt].tgc_cpu;</a>
<a name="ln986">	mtx_unlock(&amp;qgroup-&gt;tqg_lock);</a>
<a name="ln987">	/*</a>
<a name="ln988">	 * Set up queue for tasks added before boot.</a>
<a name="ln989">	 */</a>
<a name="ln990">	if (old_cnt == 0) {</a>
<a name="ln991">		LIST_SWAP(&amp;gtask_head, &amp;qgroup-&gt;tqg_queue[0].tgc_tasks,</a>
<a name="ln992">		    grouptask, gt_list);</a>
<a name="ln993">		qgroup-&gt;tqg_queue[0].tgc_cnt = 0;</a>
<a name="ln994">	}</a>
<a name="ln995"> </a>
<a name="ln996">	/*</a>
<a name="ln997">	 * If new taskq threads have been added.</a>
<a name="ln998">	 */</a>
<a name="ln999">	cpu = old_cpu;</a>
<a name="ln1000">	for (i = old_cnt; i &lt; cnt; i++) {</a>
<a name="ln1001">		taskqgroup_cpu_create(qgroup, i, cpu);</a>
<a name="ln1002"> </a>
<a name="ln1003">		for (k = 0; k &lt; stride; k++)</a>
<a name="ln1004">			cpu = CPU_NEXT(cpu);</a>
<a name="ln1005">	}</a>
<a name="ln1006">	mtx_lock(&amp;qgroup-&gt;tqg_lock);</a>
<a name="ln1007">	qgroup-&gt;tqg_cnt = cnt;</a>
<a name="ln1008">	qgroup-&gt;tqg_stride = stride;</a>
<a name="ln1009"> </a>
<a name="ln1010">	/*</a>
<a name="ln1011">	 * Adjust drivers to use new taskqs.</a>
<a name="ln1012">	 */</a>
<a name="ln1013">	for (i = 0; i &lt; old_cnt; i++) {</a>
<a name="ln1014">		while ((gtask = LIST_FIRST(&amp;qgroup-&gt;tqg_queue[i].tgc_tasks))) {</a>
<a name="ln1015">			LIST_REMOVE(gtask, gt_list);</a>
<a name="ln1016">			qgroup-&gt;tqg_queue[i].tgc_cnt--;</a>
<a name="ln1017">			LIST_INSERT_HEAD(&amp;gtask_head, gtask, gt_list);</a>
<a name="ln1018">		}</a>
<a name="ln1019">	}</a>
<a name="ln1020">	mtx_unlock(&amp;qgroup-&gt;tqg_lock);</a>
<a name="ln1021"> </a>
<a name="ln1022">	while ((gtask = LIST_FIRST(&amp;gtask_head))) {</a>
<a name="ln1023">		LIST_REMOVE(gtask, gt_list);</a>
<a name="ln1024">		if (gtask-&gt;gt_cpu == -1)</a>
<a name="ln1025">			taskqgroup_attach_deferred(qgroup, gtask);</a>
<a name="ln1026">		else if (taskqgroup_attach_cpu_deferred(qgroup, gtask))</a>
<a name="ln1027">			taskqgroup_attach_deferred(qgroup, gtask);</a>
<a name="ln1028">	}</a>
<a name="ln1029"> </a>
<a name="ln1030">#ifdef INVARIANTS</a>
<a name="ln1031">	mtx_lock(&amp;qgroup-&gt;tqg_lock);</a>
<a name="ln1032">	for (i = 0; i &lt; qgroup-&gt;tqg_cnt; i++) {</a>
<a name="ln1033">		MPASS(qgroup-&gt;tqg_queue[i].tgc_taskq != NULL);</a>
<a name="ln1034">		LIST_FOREACH(gtask, &amp;qgroup-&gt;tqg_queue[i].tgc_tasks, gt_list)</a>
<a name="ln1035">			MPASS(gtask-&gt;gt_taskqueue != NULL);</a>
<a name="ln1036">	}</a>
<a name="ln1037">	mtx_unlock(&amp;qgroup-&gt;tqg_lock);</a>
<a name="ln1038">#endif</a>
<a name="ln1039">	/*</a>
<a name="ln1040">	 * If taskq thread count has been reduced.</a>
<a name="ln1041">	 */</a>
<a name="ln1042">	for (i = cnt; i &lt; old_cnt; i++)</a>
<a name="ln1043">		taskqgroup_cpu_remove(qgroup, i);</a>
<a name="ln1044"> </a>
<a name="ln1045">	taskqgroup_bind(qgroup);</a>
<a name="ln1046"> </a>
<a name="ln1047">	mtx_lock(&amp;qgroup-&gt;tqg_lock);</a>
<a name="ln1048">	qgroup-&gt;tqg_adjusting = 0;</a>
<a name="ln1049"> </a>
<a name="ln1050">	return (0);</a>
<a name="ln1051">}</a>
<a name="ln1052"> </a>
<a name="ln1053">int</a>
<a name="ln1054">taskqgroup_adjust(struct taskqgroup *qgroup, int cnt, int stride)</a>
<a name="ln1055">{</a>
<a name="ln1056">	int error;</a>
<a name="ln1057"> </a>
<a name="ln1058">	mtx_lock(&amp;qgroup-&gt;tqg_lock);</a>
<a name="ln1059">	error = _taskqgroup_adjust(qgroup, cnt, stride);</a>
<a name="ln1060">	mtx_unlock(&amp;qgroup-&gt;tqg_lock);</a>
<a name="ln1061"> </a>
<a name="ln1062">	return (error);</a>
<a name="ln1063">}</a>
<a name="ln1064"> </a>
<a name="ln1065">struct taskqgroup *</a>
<a name="ln1066">taskqgroup_create(const char *name)</a>
<a name="ln1067">{</a>
<a name="ln1068">	struct taskqgroup *qgroup;</a>
<a name="ln1069"> </a>
<a name="ln1070">	qgroup = malloc(sizeof(*qgroup), M_GTASKQUEUE, M_WAITOK | M_ZERO);</a>
<a name="ln1071">	mtx_init(&amp;qgroup-&gt;tqg_lock, &quot;taskqgroup&quot;, NULL, MTX_DEF);</a>
<a name="ln1072">	qgroup-&gt;tqg_name = name;</a>
<a name="ln1073">	LIST_INIT(&amp;qgroup-&gt;tqg_queue[0].tgc_tasks);</a>
<a name="ln1074"> </a>
<a name="ln1075">	return (qgroup);</a>
<a name="ln1076">}</a>
<a name="ln1077"> </a>
<a name="ln1078">void</a>
<a name="ln1079">taskqgroup_destroy(struct taskqgroup *qgroup)</a>
<a name="ln1080">{</a>
<a name="ln1081"> </a>
<a name="ln1082">}</a>
<a name="ln1083"> </a>
<a name="ln1084">void</a>
<a name="ln1085">taskqgroup_config_gtask_init(void *ctx, struct grouptask *gtask, gtask_fn_t *fn,</a>
<a name="ln1086">    const char *name)</a>
<a name="ln1087">{</a>
<a name="ln1088"> </a>
<a name="ln1089">	GROUPTASK_INIT(gtask, 0, fn, ctx);</a>
<a name="ln1090">	taskqgroup_attach(qgroup_config, gtask, gtask, NULL, NULL, name);</a>
<a name="ln1091">}</a>
<a name="ln1092"> </a>
<a name="ln1093">void</a>
<a name="ln1094">taskqgroup_config_gtask_deinit(struct grouptask *gtask)</a>
<a name="ln1095">{</a>
<a name="ln1096"> </a>
<a name="ln1097">	taskqgroup_detach(qgroup_config, gtask);</a>
<a name="ln1098">}</a>

</code></pre>
<div class="balloon" rel="459"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="470"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="600"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="602"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="607"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="435"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="240"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="395"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="254"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="258"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="263"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="351"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="353"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="360"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="473"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="238"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="252"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="220"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="457"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="364"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="437"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="223"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="589"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="591"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="390"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="575"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>
<div class="balloon" rel="191"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v523/" target="_blank">V523</a> The 'then' statement is equivalent to the 'else' statement.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
