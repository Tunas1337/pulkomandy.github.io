
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>DwarfImageDebugInfo.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2009-2012, Ingo Weinhold, ingo_weinhold@gmx.de.</a>
<a name="ln3"> * Copyright 2012-2018, Rene Gollent, rene@gollent.com.</a>
<a name="ln4"> * Distributed under the terms of the MIT License.</a>
<a name="ln5"> */</a>
<a name="ln6"> </a>
<a name="ln7"> </a>
<a name="ln8">#include &quot;DwarfImageDebugInfo.h&quot;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;errno.h&gt;</a>
<a name="ln11">#include &lt;stdio.h&gt;</a>
<a name="ln12">#include &lt;unistd.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;algorithm&gt;</a>
<a name="ln15">#include &lt;new&gt;</a>
<a name="ln16"> </a>
<a name="ln17">#include &lt;AutoDeleter.h&gt;</a>
<a name="ln18">#include &lt;AutoLocker.h&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;Architecture.h&quot;</a>
<a name="ln21">#include &quot;BasicFunctionDebugInfo.h&quot;</a>
<a name="ln22">#include &quot;CLanguage.h&quot;</a>
<a name="ln23">#include &quot;CompilationUnit.h&quot;</a>
<a name="ln24">#include &quot;CppLanguage.h&quot;</a>
<a name="ln25">#include &quot;CpuState.h&quot;</a>
<a name="ln26">#include &quot;DebuggerInterface.h&quot;</a>
<a name="ln27">#include &quot;DebugInfoEntries.h&quot;</a>
<a name="ln28">#include &quot;Demangler.h&quot;</a>
<a name="ln29">#include &quot;DisassembledCode.h&quot;</a>
<a name="ln30">#include &quot;Dwarf.h&quot;</a>
<a name="ln31">#include &quot;DwarfFile.h&quot;</a>
<a name="ln32">#include &quot;DwarfFunctionDebugInfo.h&quot;</a>
<a name="ln33">#include &quot;DwarfStackFrameDebugInfo.h&quot;</a>
<a name="ln34">#include &quot;DwarfTargetInterface.h&quot;</a>
<a name="ln35">#include &quot;DwarfTypeFactory.h&quot;</a>
<a name="ln36">#include &quot;DwarfTypes.h&quot;</a>
<a name="ln37">#include &quot;DwarfUtils.h&quot;</a>
<a name="ln38">#include &quot;ElfFile.h&quot;</a>
<a name="ln39">#include &quot;FileManager.h&quot;</a>
<a name="ln40">#include &quot;FileSourceCode.h&quot;</a>
<a name="ln41">#include &quot;FunctionID.h&quot;</a>
<a name="ln42">#include &quot;FunctionInstance.h&quot;</a>
<a name="ln43">#include &quot;GlobalTypeLookup.h&quot;</a>
<a name="ln44">#include &quot;Image.h&quot;</a>
<a name="ln45">#include &quot;ImageDebugInfo.h&quot;</a>
<a name="ln46">#include &quot;InstructionInfo.h&quot;</a>
<a name="ln47">#include &quot;LocatableFile.h&quot;</a>
<a name="ln48">#include &quot;Register.h&quot;</a>
<a name="ln49">#include &quot;RegisterMap.h&quot;</a>
<a name="ln50">#include &quot;SourceFile.h&quot;</a>
<a name="ln51">#include &quot;StackFrame.h&quot;</a>
<a name="ln52">#include &quot;Statement.h&quot;</a>
<a name="ln53">#include &quot;StringUtils.h&quot;</a>
<a name="ln54">#include &quot;SymbolInfo.h&quot;</a>
<a name="ln55">#include &quot;TargetAddressRangeList.h&quot;</a>
<a name="ln56">#include &quot;Team.h&quot;</a>
<a name="ln57">#include &quot;TeamFunctionSourceInformation.h&quot;</a>
<a name="ln58">#include &quot;TeamMemory.h&quot;</a>
<a name="ln59">#include &quot;Tracing.h&quot;</a>
<a name="ln60">#include &quot;TypeLookupConstraints.h&quot;</a>
<a name="ln61">#include &quot;UnsupportedLanguage.h&quot;</a>
<a name="ln62">#include &quot;Variable.h&quot;</a>
<a name="ln63">#include &quot;ValueLocation.h&quot;</a>
<a name="ln64"> </a>
<a name="ln65"> </a>
<a name="ln66">namespace {</a>
<a name="ln67"> </a>
<a name="ln68"> </a>
<a name="ln69">// #pragma mark - HasTypePredicate</a>
<a name="ln70"> </a>
<a name="ln71"> </a>
<a name="ln72">template&lt;typename EntryType&gt;</a>
<a name="ln73">struct HasTypePredicate {</a>
<a name="ln74">	inline bool operator()(EntryType* entry) const</a>
<a name="ln75">	{</a>
<a name="ln76">		return entry-&gt;GetType() != NULL;</a>
<a name="ln77">	}</a>
<a name="ln78">};</a>
<a name="ln79"> </a>
<a name="ln80">}</a>
<a name="ln81"> </a>
<a name="ln82"> </a>
<a name="ln83">// #pragma mark - BasicTargetInterface</a>
<a name="ln84"> </a>
<a name="ln85"> </a>
<a name="ln86">struct DwarfImageDebugInfo::BasicTargetInterface : DwarfTargetInterface {</a>
<a name="ln87">	BasicTargetInterface(const Register* registers, int32 registerCount,</a>
<a name="ln88">		RegisterMap* fromDwarfMap, Architecture* architecture,</a>
<a name="ln89">		TeamMemory* teamMemory)</a>
<a name="ln90">		:</a>
<a name="ln91">		fRegisters(registers),</a>
<a name="ln92">		fRegisterCount(registerCount),</a>
<a name="ln93">		fFromDwarfMap(fromDwarfMap),</a>
<a name="ln94">		fArchitecture(architecture),</a>
<a name="ln95">		fTeamMemory(teamMemory)</a>
<a name="ln96">	{</a>
<a name="ln97">		fFromDwarfMap-&gt;AcquireReference();</a>
<a name="ln98">	}</a>
<a name="ln99"> </a>
<a name="ln100">	~BasicTargetInterface()</a>
<a name="ln101">	{</a>
<a name="ln102">		fFromDwarfMap-&gt;ReleaseReference();</a>
<a name="ln103">	}</a>
<a name="ln104"> </a>
<a name="ln105">	virtual uint32 CountRegisters() const</a>
<a name="ln106">	{</a>
<a name="ln107">		return fRegisterCount;</a>
<a name="ln108">	}</a>
<a name="ln109"> </a>
<a name="ln110">	virtual uint32 RegisterValueType(uint32 index) const</a>
<a name="ln111">	{</a>
<a name="ln112">		const Register* reg = _RegisterAt(index);</a>
<a name="ln113">		return reg != NULL ? reg-&gt;ValueType() : 0;</a>
<a name="ln114">	}</a>
<a name="ln115"> </a>
<a name="ln116">	virtual bool GetRegisterValue(uint32 index, BVariant&amp; _value) const</a>
<a name="ln117">	{</a>
<a name="ln118">		return false;</a>
<a name="ln119">	}</a>
<a name="ln120"> </a>
<a name="ln121">	virtual bool SetRegisterValue(uint32 index, const BVariant&amp; value)</a>
<a name="ln122">	{</a>
<a name="ln123">		return false;</a>
<a name="ln124">	}</a>
<a name="ln125"> </a>
<a name="ln126">	virtual bool IsCalleePreservedRegister(uint32 index) const</a>
<a name="ln127">	{</a>
<a name="ln128">		const Register* reg = _RegisterAt(index);</a>
<a name="ln129">		return reg != NULL &amp;&amp; reg-&gt;IsCalleePreserved();</a>
<a name="ln130">	}</a>
<a name="ln131"> </a>
<a name="ln132">	virtual status_t InitRegisterRules(CfaContext&amp; context) const</a>
<a name="ln133">	{</a>
<a name="ln134">		return fArchitecture-&gt;InitRegisterRules(context);</a>
<a name="ln135">	}</a>
<a name="ln136"> </a>
<a name="ln137">	virtual bool ReadMemory(target_addr_t address, void* buffer,</a>
<a name="ln138">		size_t size) const</a>
<a name="ln139">	{</a>
<a name="ln140">		ssize_t bytesRead = fTeamMemory-&gt;ReadMemory(address, buffer, size);</a>
<a name="ln141">		return bytesRead &gt;= 0 &amp;&amp; (size_t)bytesRead == size;</a>
<a name="ln142">	}</a>
<a name="ln143"> </a>
<a name="ln144">	virtual bool ReadValueFromMemory(target_addr_t address,</a>
<a name="ln145">		uint32 valueType, BVariant&amp; _value) const</a>
<a name="ln146">	{</a>
<a name="ln147">		return fArchitecture-&gt;ReadValueFromMemory(address, valueType, _value)</a>
<a name="ln148">			== B_OK;</a>
<a name="ln149">	}</a>
<a name="ln150"> </a>
<a name="ln151">	virtual bool ReadValueFromMemory(target_addr_t addressSpace,</a>
<a name="ln152">		target_addr_t address, uint32 valueType, BVariant&amp; _value) const</a>
<a name="ln153">	{</a>
<a name="ln154">		return fArchitecture-&gt;ReadValueFromMemory(addressSpace, address,</a>
<a name="ln155">			valueType, _value) == B_OK;</a>
<a name="ln156">	}</a>
<a name="ln157"> </a>
<a name="ln158">protected:</a>
<a name="ln159">	const Register* _RegisterAt(uint32 dwarfIndex) const</a>
<a name="ln160">	{</a>
<a name="ln161">		int32 index = fFromDwarfMap-&gt;MapRegisterIndex(dwarfIndex);</a>
<a name="ln162">		return index &gt;= 0 &amp;&amp; index &lt; fRegisterCount ? fRegisters + index : NULL;</a>
<a name="ln163">	}</a>
<a name="ln164"> </a>
<a name="ln165">protected:</a>
<a name="ln166">	const Register*	fRegisters;</a>
<a name="ln167">	int32			fRegisterCount;</a>
<a name="ln168">	RegisterMap*	fFromDwarfMap;</a>
<a name="ln169">	Architecture*	fArchitecture;</a>
<a name="ln170">	TeamMemory*		fTeamMemory;</a>
<a name="ln171">};</a>
<a name="ln172"> </a>
<a name="ln173"> </a>
<a name="ln174">// #pragma mark - UnwindTargetInterface</a>
<a name="ln175"> </a>
<a name="ln176"> </a>
<a name="ln177">struct DwarfImageDebugInfo::UnwindTargetInterface : BasicTargetInterface {</a>
<a name="ln178">	UnwindTargetInterface(const Register* registers, int32 registerCount,</a>
<a name="ln179">		RegisterMap* fromDwarfMap, RegisterMap* toDwarfMap, CpuState* cpuState,</a>
<a name="ln180">		Architecture* architecture, TeamMemory* teamMemory)</a>
<a name="ln181">		:</a>
<a name="ln182">		BasicTargetInterface(registers, registerCount, fromDwarfMap,</a>
<a name="ln183">			architecture, teamMemory),</a>
<a name="ln184">		fToDwarfMap(toDwarfMap),</a>
<a name="ln185">		fCpuState(cpuState)</a>
<a name="ln186">	{</a>
<a name="ln187">		fToDwarfMap-&gt;AcquireReference();</a>
<a name="ln188">		fCpuState-&gt;AcquireReference();</a>
<a name="ln189">	}</a>
<a name="ln190"> </a>
<a name="ln191">	~UnwindTargetInterface()</a>
<a name="ln192">	{</a>
<a name="ln193">		fToDwarfMap-&gt;ReleaseReference();</a>
<a name="ln194">		fCpuState-&gt;ReleaseReference();</a>
<a name="ln195">	}</a>
<a name="ln196"> </a>
<a name="ln197">	virtual bool GetRegisterValue(uint32 index, BVariant&amp; _value) const</a>
<a name="ln198">	{</a>
<a name="ln199">		const Register* reg = _RegisterAt(index);</a>
<a name="ln200">		if (reg == NULL)</a>
<a name="ln201">			return false;</a>
<a name="ln202">		return fCpuState-&gt;GetRegisterValue(reg, _value);</a>
<a name="ln203">	}</a>
<a name="ln204"> </a>
<a name="ln205">	virtual bool SetRegisterValue(uint32 index, const BVariant&amp; value)</a>
<a name="ln206">	{</a>
<a name="ln207">		const Register* reg = _RegisterAt(index);</a>
<a name="ln208">		if (reg == NULL)</a>
<a name="ln209">			return false;</a>
<a name="ln210">		return fCpuState-&gt;SetRegisterValue(reg, value);</a>
<a name="ln211">	}</a>
<a name="ln212"> </a>
<a name="ln213">private:</a>
<a name="ln214">	RegisterMap*	fToDwarfMap;</a>
<a name="ln215">	CpuState*		fCpuState;</a>
<a name="ln216">};</a>
<a name="ln217"> </a>
<a name="ln218"> </a>
<a name="ln219">// #pragma mark - EntryListWrapper</a>
<a name="ln220"> </a>
<a name="ln221"> </a>
<a name="ln222">/*!	Wraps a DebugInfoEntryList, which is a typedef and thus cannot appear in</a>
<a name="ln223">	the header, since our policy disallows us to include DWARF headers there.</a>
<a name="ln224">*/</a>
<a name="ln225">struct DwarfImageDebugInfo::EntryListWrapper {</a>
<a name="ln226">	const DebugInfoEntryList&amp;	list;</a>
<a name="ln227"> </a>
<a name="ln228">	EntryListWrapper(const DebugInfoEntryList&amp; list)</a>
<a name="ln229">		:</a>
<a name="ln230">		list(list)</a>
<a name="ln231">	{</a>
<a name="ln232">	}</a>
<a name="ln233">};</a>
<a name="ln234"> </a>
<a name="ln235"> </a>
<a name="ln236">// #pragma mark - DwarfImageDebugInfo::TypeNameKey</a>
<a name="ln237"> </a>
<a name="ln238"> </a>
<a name="ln239">struct DwarfImageDebugInfo::TypeNameKey {</a>
<a name="ln240">	BString			typeName;</a>
<a name="ln241"> </a>
<a name="ln242">	TypeNameKey(const BString&amp; typeName)</a>
<a name="ln243">		:</a>
<a name="ln244">		typeName(typeName)</a>
<a name="ln245">	{</a>
<a name="ln246">	}</a>
<a name="ln247"> </a>
<a name="ln248">	uint32 HashValue() const</a>
<a name="ln249">	{</a>
<a name="ln250">		return StringUtils::HashValue(typeName);</a>
<a name="ln251">	}</a>
<a name="ln252"> </a>
<a name="ln253">	bool operator==(const TypeNameKey&amp; other) const</a>
<a name="ln254">	{</a>
<a name="ln255">		return typeName == other.typeName;</a>
<a name="ln256">	}</a>
<a name="ln257">};</a>
<a name="ln258"> </a>
<a name="ln259"> </a>
<a name="ln260">// #pragma mark - DwarfImageDebugInfo::TypeNameEntry</a>
<a name="ln261"> </a>
<a name="ln262"> </a>
<a name="ln263">struct DwarfImageDebugInfo::TypeNameEntry : TypeNameKey {</a>
<a name="ln264">	TypeNameEntry* next;</a>
<a name="ln265">	TypeEntryList types;</a>
<a name="ln266"> </a>
<a name="ln267">	TypeNameEntry(const BString&amp; name)</a>
<a name="ln268">		:</a>
<a name="ln269">		TypeNameKey(name),</a>
<a name="ln270">		types(10, true)</a>
<a name="ln271">	{</a>
<a name="ln272">	}</a>
<a name="ln273"> </a>
<a name="ln274">	~TypeNameEntry()</a>
<a name="ln275">	{</a>
<a name="ln276">	}</a>
<a name="ln277"> </a>
<a name="ln278">};</a>
<a name="ln279"> </a>
<a name="ln280"> </a>
<a name="ln281">// #pragma mark - DwarfImageDebugInfo::TypeNameEntryHashDefinition</a>
<a name="ln282"> </a>
<a name="ln283"> </a>
<a name="ln284">struct DwarfImageDebugInfo::TypeNameEntryHashDefinition {</a>
<a name="ln285">	typedef TypeNameKey		KeyType;</a>
<a name="ln286">	typedef	TypeNameEntry	ValueType;</a>
<a name="ln287"> </a>
<a name="ln288">	size_t HashKey(const TypeNameKey&amp; key) const</a>
<a name="ln289">	{</a>
<a name="ln290">		return key.HashValue();</a>
<a name="ln291">	}</a>
<a name="ln292"> </a>
<a name="ln293">	size_t Hash(const TypeNameEntry* value) const</a>
<a name="ln294">	{</a>
<a name="ln295">		return value-&gt;HashValue();</a>
<a name="ln296">	}</a>
<a name="ln297"> </a>
<a name="ln298">	bool Compare(const TypeNameKey&amp; key,</a>
<a name="ln299">		const TypeNameEntry* value) const</a>
<a name="ln300">	{</a>
<a name="ln301">		return key == *value;</a>
<a name="ln302">	}</a>
<a name="ln303"> </a>
<a name="ln304">	TypeNameEntry*&amp; GetLink(TypeNameEntry* value) const</a>
<a name="ln305">	{</a>
<a name="ln306">		return value-&gt;next;</a>
<a name="ln307">	}</a>
<a name="ln308">};</a>
<a name="ln309"> </a>
<a name="ln310"> </a>
<a name="ln311">// #pragma mark - DwarfImageDebugInfo::TypeEntryInfo</a>
<a name="ln312"> </a>
<a name="ln313"> </a>
<a name="ln314">struct DwarfImageDebugInfo::TypeEntryInfo {</a>
<a name="ln315">	DIEType* type;</a>
<a name="ln316">	CompilationUnit* unit;</a>
<a name="ln317"> </a>
<a name="ln318">	TypeEntryInfo(DIEType* type, CompilationUnit* unit)</a>
<a name="ln319">		:</a>
<a name="ln320">		type(type),</a>
<a name="ln321">		unit(unit)</a>
<a name="ln322">	{</a>
<a name="ln323">	}</a>
<a name="ln324">};</a>
<a name="ln325"> </a>
<a name="ln326"> </a>
<a name="ln327">// #pragma mark - DwarfImageDebugInfo</a>
<a name="ln328"> </a>
<a name="ln329"> </a>
<a name="ln330">DwarfImageDebugInfo::DwarfImageDebugInfo(const ImageInfo&amp; imageInfo,</a>
<a name="ln331">	DebuggerInterface* interface, Architecture* architecture,</a>
<a name="ln332">	FileManager* fileManager, GlobalTypeLookup* typeLookup,</a>
<a name="ln333">	GlobalTypeCache* typeCache, TeamFunctionSourceInformation* sourceInfo,</a>
<a name="ln334">	DwarfFile* file)</a>
<a name="ln335">	:</a>
<a name="ln336">	fLock(&quot;dwarf image debug info&quot;),</a>
<a name="ln337">	fImageInfo(imageInfo),</a>
<a name="ln338">	fDebuggerInterface(interface),</a>
<a name="ln339">	fArchitecture(architecture),</a>
<a name="ln340">	fFileManager(fileManager),</a>
<a name="ln341">	fTypeLookup(typeLookup),</a>
<a name="ln342">	fTypeCache(typeCache),</a>
<a name="ln343">	fSourceInfo(sourceInfo),</a>
<a name="ln344">	fTypeNameTable(NULL),</a>
<a name="ln345">	fFile(file),</a>
<a name="ln346">	fTextSegment(NULL),</a>
<a name="ln347">	fRelocationDelta(0),</a>
<a name="ln348">	fTextSectionStart(0),</a>
<a name="ln349">	fTextSectionEnd(0),</a>
<a name="ln350">	fPLTSectionStart(0),</a>
<a name="ln351">	fPLTSectionEnd(0)</a>
<a name="ln352">{</a>
<a name="ln353">	fDebuggerInterface-&gt;AcquireReference();</a>
<a name="ln354">	fFile-&gt;AcquireReference();</a>
<a name="ln355">	fTypeCache-&gt;AcquireReference();</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358"> </a>
<a name="ln359">DwarfImageDebugInfo::~DwarfImageDebugInfo()</a>
<a name="ln360">{</a>
<a name="ln361">	fDebuggerInterface-&gt;ReleaseReference();</a>
<a name="ln362">	fFile-&gt;ReleaseReference();</a>
<a name="ln363">	fTypeCache-&gt;ReleaseReference();</a>
<a name="ln364"> </a>
<a name="ln365">	TypeNameEntry* entry = fTypeNameTable-&gt;Clear(true);</a>
<a name="ln366">	while (entry != NULL) {</a>
<a name="ln367">		TypeNameEntry* next = entry-&gt;next;</a>
<a name="ln368">		delete entry;</a>
<a name="ln369">		entry = next;</a>
<a name="ln370">	}</a>
<a name="ln371">	delete fTypeNameTable;</a>
<a name="ln372">}</a>
<a name="ln373"> </a>
<a name="ln374"> </a>
<a name="ln375">status_t</a>
<a name="ln376">DwarfImageDebugInfo::Init()</a>
<a name="ln377">{</a>
<a name="ln378">	status_t error = fLock.InitCheck();</a>
<a name="ln379">	if (error != B_OK)</a>
<a name="ln380">		return error;</a>
<a name="ln381"> </a>
<a name="ln382">	fTextSegment = fFile-&gt;GetElfFile()-&gt;TextSegment();</a>
<a name="ln383">	if (fTextSegment == NULL)</a>
<a name="ln384">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln385"> </a>
<a name="ln386">	fRelocationDelta = fImageInfo.TextBase() - fTextSegment-&gt;LoadAddress();</a>
<a name="ln387"> </a>
<a name="ln388">	ElfSection* section = fFile-&gt;GetElfFile()-&gt;FindSection(&quot;.text&quot;);</a>
<a name="ln389">	if (section != NULL) {</a>
<a name="ln390">		fTextSectionStart = section-&gt;LoadAddress() + fRelocationDelta;</a>
<a name="ln391">		fTextSectionEnd = fTextSectionStart + section-&gt;Size();</a>
<a name="ln392">	}</a>
<a name="ln393"> </a>
<a name="ln394">	section = fFile-&gt;GetElfFile()-&gt;FindSection(&quot;.plt&quot;);</a>
<a name="ln395">	if (section != NULL) {</a>
<a name="ln396">		fPLTSectionStart = section-&gt;LoadAddress() + fRelocationDelta;</a>
<a name="ln397">		fPLTSectionEnd = fPLTSectionStart + section-&gt;Size();</a>
<a name="ln398">	}</a>
<a name="ln399"> </a>
<a name="ln400">	return _BuildTypeNameTable();</a>
<a name="ln401">}</a>
<a name="ln402"> </a>
<a name="ln403"> </a>
<a name="ln404">status_t</a>
<a name="ln405">DwarfImageDebugInfo::GetFunctions(const BObjectList&lt;SymbolInfo&gt;&amp; symbols,</a>
<a name="ln406">	BObjectList&lt;FunctionDebugInfo&gt;&amp; functions)</a>
<a name="ln407">{</a>
<a name="ln408">	TRACE_IMAGES(&quot;DwarfImageDebugInfo::GetFunctions()\n&quot;);</a>
<a name="ln409">	TRACE_IMAGES(&quot;  %&quot; B_PRId32 &quot; compilation units\n&quot;,</a>
<a name="ln410">		fFile-&gt;CountCompilationUnits());</a>
<a name="ln411"> </a>
<a name="ln412">	status_t error = B_OK;</a>
<a name="ln413">	for (int32 i = 0; CompilationUnit* unit = fFile-&gt;CompilationUnitAt(i);</a>
<a name="ln414">			i++) {</a>
<a name="ln415">		DIECompileUnitBase* unitEntry = unit-&gt;UnitEntry();</a>
<a name="ln416">//		printf(&quot;  %s:\n&quot;, unitEntry-&gt;Name());</a>
<a name="ln417">//		printf(&quot;    address ranges:\n&quot;);</a>
<a name="ln418">//		TargetAddressRangeList* rangeList = unitEntry-&gt;AddressRanges();</a>
<a name="ln419">//		if (rangeList != NULL) {</a>
<a name="ln420">//			int32 count = rangeList-&gt;CountRanges();</a>
<a name="ln421">//			for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln422">//				TargetAddressRange range = rangeList-&gt;RangeAt(i);</a>
<a name="ln423">//				printf(&quot;      %#llx - %#llx\n&quot;, range.Start(), range.End());</a>
<a name="ln424">//			}</a>
<a name="ln425">//		} else {</a>
<a name="ln426">//			printf(&quot;      %#llx - %#llx\n&quot;, (target_addr_t)unitEntry-&gt;LowPC(),</a>
<a name="ln427">//				(target_addr_t)unitEntry-&gt;HighPC());</a>
<a name="ln428">//		}</a>
<a name="ln429"> </a>
<a name="ln430">//		printf(&quot;    functions:\n&quot;);</a>
<a name="ln431">		for (DebugInfoEntryList::ConstIterator it</a>
<a name="ln432">					= unitEntry-&gt;OtherChildren().GetIterator();</a>
<a name="ln433">				DebugInfoEntry* entry = it.Next();) {</a>
<a name="ln434">			if (entry-&gt;Tag() == DW_TAG_subprogram) {</a>
<a name="ln435">				DIESubprogram* subprogramEntry</a>
<a name="ln436">					= static_cast&lt;DIESubprogram*&gt;(entry);</a>
<a name="ln437">				error = _AddFunction(subprogramEntry, unit, functions);</a>
<a name="ln438">				if (error != B_OK)</a>
<a name="ln439">					return error;</a>
<a name="ln440">			}</a>
<a name="ln441"> </a>
<a name="ln442">			DIENamespace* nsEntry = dynamic_cast&lt;DIENamespace*&gt;(entry);</a>
<a name="ln443">			if (nsEntry != NULL) {</a>
<a name="ln444">				error = _RecursiveTraverseNamespaceForFunctions(nsEntry, unit,</a>
<a name="ln445">					functions);</a>
<a name="ln446">				if (error != B_OK)</a>
<a name="ln447">					return error;</a>
<a name="ln448">			}</a>
<a name="ln449">		}</a>
<a name="ln450">	}</a>
<a name="ln451"> </a>
<a name="ln452">	if (fFile-&gt;CountCompilationUnits() != 0)</a>
<a name="ln453">		return B_OK;</a>
<a name="ln454"> </a>
<a name="ln455">	// if we had no compilation units, fall back to providing basic</a>
<a name="ln456">	// debug infos with DWARF-supported call frame unwinding,</a>
<a name="ln457">	// if available.</a>
<a name="ln458">	if (fFile-&gt;HasFrameInformation()) {</a>
<a name="ln459">		return SpecificImageDebugInfo::GetFunctionsFromSymbols(symbols,</a>
<a name="ln460">			functions, fDebuggerInterface, fImageInfo, this);</a>
<a name="ln461">	}</a>
<a name="ln462"> </a>
<a name="ln463">	return B_OK;</a>
<a name="ln464">}</a>
<a name="ln465"> </a>
<a name="ln466"> </a>
<a name="ln467">status_t</a>
<a name="ln468">DwarfImageDebugInfo::GetType(GlobalTypeCache* cache, const BString&amp; name,</a>
<a name="ln469">	const TypeLookupConstraints&amp; constraints, Type*&amp; _type)</a>
<a name="ln470">{</a>
<a name="ln471">	TypeNameEntry* entry = fTypeNameTable-&gt;Lookup(name);</a>
<a name="ln472">	if (entry == NULL)</a>
<a name="ln473">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln474"> </a>
<a name="ln475">	for (int32 i = 0; TypeEntryInfo* info = entry-&gt;types.ItemAt(i); i++) {</a>
<a name="ln476">		DIEType* typeEntry = info-&gt;type;</a>
<a name="ln477">		if (constraints.HasTypeKind()) {</a>
<a name="ln478">			if (dwarf_tag_to_type_kind(typeEntry-&gt;Tag())</a>
<a name="ln479">				!= constraints.TypeKind()) {</a>
<a name="ln480">				continue;</a>
<a name="ln481">			}</a>
<a name="ln482"> </a>
<a name="ln483">			if (!_EvaluateBaseTypeConstraints(typeEntry, constraints))</a>
<a name="ln484">				continue;</a>
<a name="ln485">		}</a>
<a name="ln486"> </a>
<a name="ln487">		if (constraints.HasSubtypeKind()</a>
<a name="ln488">			&amp;&amp; dwarf_tag_to_subtype_kind(typeEntry-&gt;Tag())</a>
<a name="ln489">				!= constraints.SubtypeKind()) {</a>
<a name="ln490">			continue;</a>
<a name="ln491">		}</a>
<a name="ln492"> </a>
<a name="ln493">		int32 registerCount = fArchitecture-&gt;CountRegisters();</a>
<a name="ln494">		const Register* registers = fArchitecture-&gt;Registers();</a>
<a name="ln495"> </a>
<a name="ln496">		// get the DWARF &lt;-&gt; architecture register maps</a>
<a name="ln497">		RegisterMap* toDwarfMap;</a>
<a name="ln498">		RegisterMap* fromDwarfMap;</a>
<a name="ln499">		status_t error = fArchitecture-&gt;GetDwarfRegisterMaps(&amp;toDwarfMap,</a>
<a name="ln500">			&amp;fromDwarfMap);</a>
<a name="ln501">		if (error != B_OK)</a>
<a name="ln502">			return error;</a>
<a name="ln503"> </a>
<a name="ln504">		BReference&lt;RegisterMap&gt; toDwarfMapReference(toDwarfMap, true);</a>
<a name="ln505">		BReference&lt;RegisterMap&gt; fromDwarfMapReference(fromDwarfMap, true);</a>
<a name="ln506"> </a>
<a name="ln507">		// create the target interface</a>
<a name="ln508">		BasicTargetInterface* targetInterface</a>
<a name="ln509">			= new(std::nothrow) BasicTargetInterface(registers, registerCount,</a>
<a name="ln510">				fromDwarfMap, fArchitecture, fDebuggerInterface);</a>
<a name="ln511">		if (targetInterface == NULL)</a>
<a name="ln512">			return B_NO_MEMORY;</a>
<a name="ln513"> </a>
<a name="ln514">		BReference&lt;BasicTargetInterface&gt; targetInterfaceReference(</a>
<a name="ln515">			targetInterface, true);</a>
<a name="ln516"> </a>
<a name="ln517">		DwarfTypeContext* typeContext = new(std::nothrow)</a>
<a name="ln518">			DwarfTypeContext(fArchitecture, fImageInfo.ImageID(), fFile,</a>
<a name="ln519">				info-&gt;unit, NULL, 0, 0, fRelocationDelta, targetInterface, NULL);</a>
<a name="ln520">		if (typeContext == NULL)</a>
<a name="ln521">			return B_NO_MEMORY;</a>
<a name="ln522">		BReference&lt;DwarfTypeContext&gt; typeContextReference(typeContext, true);</a>
<a name="ln523"> </a>
<a name="ln524">		// create the type</a>
<a name="ln525">		DwarfType* type;</a>
<a name="ln526">		DwarfTypeFactory typeFactory(typeContext, fTypeLookup, cache);</a>
<a name="ln527">		error = typeFactory.CreateType(typeEntry, type);</a>
<a name="ln528">		if (error != B_OK)</a>
<a name="ln529">			continue;</a>
<a name="ln530"> </a>
<a name="ln531">		_type = type;</a>
<a name="ln532">		return B_OK;</a>
<a name="ln533">	}</a>
<a name="ln534"> </a>
<a name="ln535">	return B_ENTRY_NOT_FOUND;</a>
<a name="ln536">}</a>
<a name="ln537"> </a>
<a name="ln538"> </a>
<a name="ln539">bool</a>
<a name="ln540">DwarfImageDebugInfo::HasType(const BString&amp; name,</a>
<a name="ln541">	const TypeLookupConstraints&amp; constraints) const</a>
<a name="ln542">{</a>
<a name="ln543">	TypeNameEntry* entry = fTypeNameTable-&gt;Lookup(name);</a>
<a name="ln544">	if (entry == NULL)</a>
<a name="ln545">		return false;</a>
<a name="ln546"> </a>
<a name="ln547">	for (int32 i = 0; TypeEntryInfo* info = entry-&gt;types.ItemAt(i); i++) {</a>
<a name="ln548">		DIEType* typeEntry = info-&gt;type;</a>
<a name="ln549">		if (constraints.HasTypeKind()) {</a>
<a name="ln550">			if (dwarf_tag_to_type_kind(typeEntry-&gt;Tag())</a>
<a name="ln551">				!= constraints.TypeKind()) {</a>
<a name="ln552">				continue;</a>
<a name="ln553">			}</a>
<a name="ln554"> </a>
<a name="ln555">			if (!_EvaluateBaseTypeConstraints(typeEntry, constraints))</a>
<a name="ln556">				continue;</a>
<a name="ln557">		}</a>
<a name="ln558"> </a>
<a name="ln559">		if (constraints.HasSubtypeKind()</a>
<a name="ln560">			&amp;&amp; dwarf_tag_to_subtype_kind(typeEntry-&gt;Tag())</a>
<a name="ln561">				!= constraints.SubtypeKind()) {</a>
<a name="ln562">			continue;</a>
<a name="ln563">		}</a>
<a name="ln564"> </a>
<a name="ln565">		return true;</a>
<a name="ln566">	}</a>
<a name="ln567"> </a>
<a name="ln568">	return false;</a>
<a name="ln569">}</a>
<a name="ln570"> </a>
<a name="ln571"> </a>
<a name="ln572">AddressSectionType</a>
<a name="ln573">DwarfImageDebugInfo::GetAddressSectionType(target_addr_t address)</a>
<a name="ln574">{</a>
<a name="ln575">	if (address &gt;= fTextSectionStart &amp;&amp; address &lt; fTextSectionEnd)</a>
<a name="ln576">		return ADDRESS_SECTION_TYPE_FUNCTION;</a>
<a name="ln577"> </a>
<a name="ln578"> 	if (address &gt;= fPLTSectionStart &amp;&amp; address &lt; fPLTSectionEnd)</a>
<a name="ln579">		return ADDRESS_SECTION_TYPE_PLT;</a>
<a name="ln580"> </a>
<a name="ln581">	return ADDRESS_SECTION_TYPE_UNKNOWN;</a>
<a name="ln582">}</a>
<a name="ln583"> </a>
<a name="ln584"> </a>
<a name="ln585">status_t</a>
<a name="ln586">DwarfImageDebugInfo::CreateFrame(Image* image,</a>
<a name="ln587">	FunctionInstance* functionInstance, CpuState* cpuState,</a>
<a name="ln588">	bool getFullFrameInfo, ReturnValueInfoList* returnValueInfos,</a>
<a name="ln589">	StackFrame*&amp; _frame, CpuState*&amp; _previousCpuState)</a>
<a name="ln590">{</a>
<a name="ln591">	DwarfFunctionDebugInfo* function = dynamic_cast&lt;DwarfFunctionDebugInfo*&gt;(</a>
<a name="ln592">		functionInstance-&gt;GetFunctionDebugInfo());</a>
<a name="ln593"> </a>
<a name="ln594">	FunctionID* functionID = functionInstance-&gt;GetFunctionID();</a>
<a name="ln595">	BReference&lt;FunctionID&gt; functionIDReference;</a>
<a name="ln596">	if (functionID != NULL)</a>
<a name="ln597">		functionIDReference.SetTo(functionID, true);</a>
<a name="ln598"> </a>
<a name="ln599">	DIESubprogram* entry = function != NULL</a>
<a name="ln600">		? function-&gt;SubprogramEntry() : NULL;</a>
<a name="ln601"> </a>
<a name="ln602">	TRACE_CFI(&quot;DwarfImageDebugInfo::CreateFrame(): subprogram DIE: %p, &quot;</a>
<a name="ln603">		&quot;function: %s\n&quot;, entry,</a>
<a name="ln604">		functionID-&gt;FunctionName().String());</a>
<a name="ln605"> </a>
<a name="ln606">	int32 registerCount = fArchitecture-&gt;CountRegisters();</a>
<a name="ln607">	const Register* registers = fArchitecture-&gt;Registers();</a>
<a name="ln608"> </a>
<a name="ln609">	// get the DWARF &lt;-&gt; architecture register maps</a>
<a name="ln610">	RegisterMap* toDwarfMap;</a>
<a name="ln611">	RegisterMap* fromDwarfMap;</a>
<a name="ln612">	status_t error = fArchitecture-&gt;GetDwarfRegisterMaps(&amp;toDwarfMap,</a>
<a name="ln613">		&amp;fromDwarfMap);</a>
<a name="ln614">	if (error != B_OK)</a>
<a name="ln615">		return error;</a>
<a name="ln616">	BReference&lt;RegisterMap&gt; toDwarfMapReference(toDwarfMap, true);</a>
<a name="ln617">	BReference&lt;RegisterMap&gt; fromDwarfMapReference(fromDwarfMap, true);</a>
<a name="ln618"> </a>
<a name="ln619">	// create a clean CPU state for the previous frame</a>
<a name="ln620">	CpuState* previousCpuState;</a>
<a name="ln621">	error = fArchitecture-&gt;CreateCpuState(previousCpuState);</a>
<a name="ln622">	if (error != B_OK)</a>
<a name="ln623">		return error;</a>
<a name="ln624">	BReference&lt;CpuState&gt; previousCpuStateReference(previousCpuState, true);</a>
<a name="ln625"> </a>
<a name="ln626">	// create the target interfaces</a>
<a name="ln627">	UnwindTargetInterface* inputInterface</a>
<a name="ln628">		= new(std::nothrow) UnwindTargetInterface(registers, registerCount,</a>
<a name="ln629">			fromDwarfMap, toDwarfMap, cpuState, fArchitecture,</a>
<a name="ln630">			fDebuggerInterface);</a>
<a name="ln631">	if (inputInterface == NULL)</a>
<a name="ln632">		return B_NO_MEMORY;</a>
<a name="ln633">	BReference&lt;UnwindTargetInterface&gt; inputInterfaceReference(inputInterface,</a>
<a name="ln634">		true);</a>
<a name="ln635"> </a>
<a name="ln636">	UnwindTargetInterface* outputInterface</a>
<a name="ln637">		= new(std::nothrow) UnwindTargetInterface(registers, registerCount,</a>
<a name="ln638">			fromDwarfMap, toDwarfMap, previousCpuState, fArchitecture,</a>
<a name="ln639">			fDebuggerInterface);</a>
<a name="ln640">	if (outputInterface == NULL)</a>
<a name="ln641">		return B_NO_MEMORY;</a>
<a name="ln642">	BReference&lt;UnwindTargetInterface&gt; outputInterfaceReference(outputInterface,</a>
<a name="ln643">		true);</a>
<a name="ln644"> </a>
<a name="ln645">	// do the unwinding</a>
<a name="ln646">	target_addr_t instructionPointer</a>
<a name="ln647">		= cpuState-&gt;InstructionPointer() - fRelocationDelta;</a>
<a name="ln648">	target_addr_t framePointer;</a>
<a name="ln649">	CompilationUnit* unit = function != NULL ? function-&gt;GetCompilationUnit()</a>
<a name="ln650">			: NULL;</a>
<a name="ln651">	error = fFile-&gt;UnwindCallFrame(unit, fArchitecture-&gt;AddressSize(), entry,</a>
<a name="ln652">		instructionPointer, inputInterface, outputInterface, framePointer);</a>
<a name="ln653"> </a>
<a name="ln654">	if (error != B_OK) {</a>
<a name="ln655">		TRACE_CFI(&quot;Failed to unwind call frame: %s\n&quot;, strerror(error));</a>
<a name="ln656">		return B_UNSUPPORTED;</a>
<a name="ln657">	}</a>
<a name="ln658"> </a>
<a name="ln659">	TRACE_CFI_ONLY(</a>
<a name="ln660">		TRACE_CFI(&quot;unwound registers:\n&quot;);</a>
<a name="ln661">		for (int32 i = 0; i &lt; registerCount; i++) {</a>
<a name="ln662">			const Register* reg = registers + i;</a>
<a name="ln663">			BVariant value;</a>
<a name="ln664">			if (previousCpuState-&gt;GetRegisterValue(reg, value)) {</a>
<a name="ln665">				TRACE_CFI(&quot;  %3s: %#&quot; B_PRIx64 &quot;\n&quot;, reg-&gt;Name(),</a>
<a name="ln666">					value.ToUInt64());</a>
<a name="ln667">			} else</a>
<a name="ln668">				TRACE_CFI(&quot;  %3s: undefined\n&quot;, reg-&gt;Name());</a>
<a name="ln669">		}</a>
<a name="ln670">	)</a>
<a name="ln671"> </a>
<a name="ln672">	// create the stack frame debug info</a>
<a name="ln673">	DIESubprogram* subprogramEntry = function != NULL ?</a>
<a name="ln674">		function-&gt;SubprogramEntry() : NULL;</a>
<a name="ln675">	DwarfStackFrameDebugInfo* stackFrameDebugInfo</a>
<a name="ln676">		= new(std::nothrow) DwarfStackFrameDebugInfo(fArchitecture,</a>
<a name="ln677">			fImageInfo.ImageID(), fFile, unit, subprogramEntry, fTypeLookup,</a>
<a name="ln678">			fTypeCache, instructionPointer, framePointer, fRelocationDelta,</a>
<a name="ln679">			inputInterface, fromDwarfMap);</a>
<a name="ln680">	if (stackFrameDebugInfo == NULL)</a>
<a name="ln681">		return B_NO_MEMORY;</a>
<a name="ln682">	BReference&lt;DwarfStackFrameDebugInfo&gt; stackFrameDebugInfoReference(</a>
<a name="ln683">		stackFrameDebugInfo, true);</a>
<a name="ln684"> </a>
<a name="ln685">	error = stackFrameDebugInfo-&gt;Init();</a>
<a name="ln686">	if (error != B_OK)</a>
<a name="ln687">		return error;</a>
<a name="ln688"> </a>
<a name="ln689">	// create the stack frame</a>
<a name="ln690">	StackFrame* frame = new(std::nothrow) StackFrame(STACK_FRAME_TYPE_STANDARD,</a>
<a name="ln691">		cpuState, framePointer, cpuState-&gt;InstructionPointer(),</a>
<a name="ln692">		stackFrameDebugInfo);</a>
<a name="ln693">	if (frame == NULL)</a>
<a name="ln694">		return B_NO_MEMORY;</a>
<a name="ln695">	BReference&lt;StackFrame&gt; frameReference(frame, true);</a>
<a name="ln696"> </a>
<a name="ln697">	error = frame-&gt;Init();</a>
<a name="ln698">	if (error != B_OK)</a>
<a name="ln699">		return error;</a>
<a name="ln700"> </a>
<a name="ln701">	frame-&gt;SetReturnAddress(previousCpuState-&gt;InstructionPointer());</a>
<a name="ln702">		// Note, this is correct, since we actually retrieved the return</a>
<a name="ln703">		// address. Our caller will fix the IP for us.</a>
<a name="ln704"> </a>
<a name="ln705">	// The subprogram entry may not be available since this may be a case</a>
<a name="ln706">	// where .eh_frame was used to unwind the stack without other DWARF</a>
<a name="ln707">	// info being available.</a>
<a name="ln708">	if (subprogramEntry != NULL &amp;&amp; getFullFrameInfo) {</a>
<a name="ln709">		// create function parameter objects</a>
<a name="ln710">		for (DebugInfoEntryList::ConstIterator it</a>
<a name="ln711">			= subprogramEntry-&gt;Parameters().GetIterator();</a>
<a name="ln712">			DebugInfoEntry* entry = it.Next();) {</a>
<a name="ln713">			if (entry-&gt;Tag() != DW_TAG_formal_parameter)</a>
<a name="ln714">				continue;</a>
<a name="ln715"> </a>
<a name="ln716">			BString parameterName;</a>
<a name="ln717">			DwarfUtils::GetDIEName(entry, parameterName);</a>
<a name="ln718">			if (parameterName.Length() == 0)</a>
<a name="ln719">				continue;</a>
<a name="ln720"> </a>
<a name="ln721">			DIEFormalParameter* parameterEntry</a>
<a name="ln722">				= dynamic_cast&lt;DIEFormalParameter*&gt;(entry);</a>
<a name="ln723">			Variable* parameter;</a>
<a name="ln724">			if (stackFrameDebugInfo-&gt;CreateParameter(functionID,</a>
<a name="ln725">				parameterEntry, parameter) != B_OK) {</a>
<a name="ln726">				continue;</a>
<a name="ln727">			}</a>
<a name="ln728">			BReference&lt;Variable&gt; parameterReference(parameter, true);</a>
<a name="ln729"> </a>
<a name="ln730">			if (!frame-&gt;AddParameter(parameter))</a>
<a name="ln731">				return B_NO_MEMORY;</a>
<a name="ln732">		}</a>
<a name="ln733"> </a>
<a name="ln734">		// create objects for the local variables</a>
<a name="ln735">		_CreateLocalVariables(unit, frame, functionID, *stackFrameDebugInfo,</a>
<a name="ln736">			instructionPointer, functionInstance-&gt;Address() - fRelocationDelta,</a>
<a name="ln737">			subprogramEntry-&gt;Variables(), subprogramEntry-&gt;Blocks());</a>
<a name="ln738"> </a>
<a name="ln739">		if (returnValueInfos != NULL &amp;&amp; !returnValueInfos-&gt;IsEmpty()) {</a>
<a name="ln740">			_CreateReturnValues(returnValueInfos, image, frame,</a>
<a name="ln741">				*stackFrameDebugInfo);</a>
<a name="ln742">		}</a>
<a name="ln743">	}</a>
<a name="ln744"> </a>
<a name="ln745">	_frame = frameReference.Detach();</a>
<a name="ln746">	_previousCpuState = previousCpuStateReference.Detach();</a>
<a name="ln747"> </a>
<a name="ln748">	frame-&gt;SetPreviousCpuState(_previousCpuState);</a>
<a name="ln749"> </a>
<a name="ln750">	return B_OK;</a>
<a name="ln751">}</a>
<a name="ln752"> </a>
<a name="ln753"> </a>
<a name="ln754">status_t</a>
<a name="ln755">DwarfImageDebugInfo::GetStatement(FunctionDebugInfo* _function,</a>
<a name="ln756">	target_addr_t address, Statement*&amp; _statement)</a>
<a name="ln757">{</a>
<a name="ln758">	TRACE_CODE(&quot;DwarfImageDebugInfo::GetStatement(function: %p, address: %#&quot;</a>
<a name="ln759">		B_PRIx64 &quot;)\n&quot;, _function, address);</a>
<a name="ln760"> </a>
<a name="ln761">	DwarfFunctionDebugInfo* function</a>
<a name="ln762">		= dynamic_cast&lt;DwarfFunctionDebugInfo*&gt;(_function);</a>
<a name="ln763">	if (function == NULL) {</a>
<a name="ln764">		TRACE_LINES(&quot;  -&gt; no dwarf function\n&quot;);</a>
<a name="ln765">		// fall back to assembly</a>
<a name="ln766">		return fArchitecture-&gt;GetStatement(function, address, _statement);</a>
<a name="ln767">	}</a>
<a name="ln768"> </a>
<a name="ln769">	AutoLocker&lt;BLocker&gt; locker(fLock);</a>
<a name="ln770"> </a>
<a name="ln771">	// check whether we have the source code</a>
<a name="ln772">	CompilationUnit* unit = function-&gt;GetCompilationUnit();</a>
<a name="ln773">	LocatableFile* file = function-&gt;SourceFile();</a>
<a name="ln774">	if (file == NULL) {</a>
<a name="ln775">		TRACE_CODE(&quot;  -&gt; no source file\n&quot;);</a>
<a name="ln776"> </a>
<a name="ln777">		// no source code -- rather return the assembly statement</a>
<a name="ln778">		return fArchitecture-&gt;GetStatement(function, address, _statement);</a>
<a name="ln779">	}</a>
<a name="ln780"> </a>
<a name="ln781">	SourceCode* sourceCode = NULL;</a>
<a name="ln782">	status_t error = fSourceInfo-&gt;GetActiveSourceCode(_function, sourceCode);</a>
<a name="ln783">	BReference&lt;SourceCode&gt; sourceReference(sourceCode, true);</a>
<a name="ln784">	if (error != B_OK || dynamic_cast&lt;DisassembledCode*&gt;(sourceCode) != NULL) {</a>
<a name="ln785">		// either no source code or disassembly is currently active (i.e.</a>
<a name="ln786">		// due to failing to locate the source file on disk or the user</a>
<a name="ln787">		// deliberately switching to disassembly view).</a>
<a name="ln788">		// return the assembly statement.</a>
<a name="ln789">		return fArchitecture-&gt;GetStatement(function, address, _statement);</a>
<a name="ln790">	}</a>
<a name="ln791"> </a>
<a name="ln792">	// get the index of the source file in the compilation unit for cheaper</a>
<a name="ln793">	// comparison below</a>
<a name="ln794">	int32 fileIndex = _GetSourceFileIndex(unit, file);</a>
<a name="ln795"> </a>
<a name="ln796">	// Get the statement by executing the line number program for the</a>
<a name="ln797">	// compilation unit.</a>
<a name="ln798">	LineNumberProgram&amp; program = unit-&gt;GetLineNumberProgram();</a>
<a name="ln799">	if (!program.IsValid()) {</a>
<a name="ln800">		TRACE_CODE(&quot;  -&gt; no line number program\n&quot;);</a>
<a name="ln801">		return B_BAD_DATA;</a>
<a name="ln802">	}</a>
<a name="ln803"> </a>
<a name="ln804">	// adjust address</a>
<a name="ln805">	address -= fRelocationDelta;</a>
<a name="ln806"> </a>
<a name="ln807">	LineNumberProgram::State state;</a>
<a name="ln808">	program.GetInitialState(state);</a>
<a name="ln809"> </a>
<a name="ln810">	target_addr_t statementAddress = 0;</a>
<a name="ln811">	int32 statementLine = -1;</a>
<a name="ln812">	int32 statementColumn = -1;</a>
<a name="ln813">	while (program.GetNextRow(state)) {</a>
<a name="ln814">		// skip statements of other files</a>
<a name="ln815">		if (state.file != fileIndex)</a>
<a name="ln816">			continue;</a>
<a name="ln817"> </a>
<a name="ln818">		if (statementAddress != 0</a>
<a name="ln819">			&amp;&amp; (state.isStatement || state.isSequenceEnd)) {</a>
<a name="ln820">			target_addr_t endAddress = state.address;</a>
<a name="ln821">			if (address &gt;= statementAddress &amp;&amp; address &lt; endAddress) {</a>
<a name="ln822">				ContiguousStatement* statement = new(std::nothrow)</a>
<a name="ln823">					ContiguousStatement(</a>
<a name="ln824">						SourceLocation(statementLine, statementColumn),</a>
<a name="ln825">						TargetAddressRange(fRelocationDelta + statementAddress,</a>
<a name="ln826">							endAddress - statementAddress));</a>
<a name="ln827">				if (statement == NULL)</a>
<a name="ln828">					return B_NO_MEMORY;</a>
<a name="ln829"> </a>
<a name="ln830">				_statement = statement;</a>
<a name="ln831">				return B_OK;</a>
<a name="ln832">			}</a>
<a name="ln833"> </a>
<a name="ln834">			statementAddress = 0;</a>
<a name="ln835">		}</a>
<a name="ln836"> </a>
<a name="ln837">		if (state.isStatement) {</a>
<a name="ln838">			statementAddress = state.address;</a>
<a name="ln839">			statementLine = state.line - 1;</a>
<a name="ln840">			statementColumn = std::max(state.column - 1, (int32)0);</a>
<a name="ln841">		}</a>
<a name="ln842">	}</a>
<a name="ln843"> </a>
<a name="ln844">	TRACE_CODE(&quot;  -&gt; no line number program match\n&quot;);</a>
<a name="ln845">	return B_ENTRY_NOT_FOUND;</a>
<a name="ln846">}</a>
<a name="ln847"> </a>
<a name="ln848"> </a>
<a name="ln849">status_t</a>
<a name="ln850">DwarfImageDebugInfo::GetStatementAtSourceLocation(FunctionDebugInfo* _function,</a>
<a name="ln851">	const SourceLocation&amp; sourceLocation, Statement*&amp; _statement)</a>
<a name="ln852">{</a>
<a name="ln853">	DwarfFunctionDebugInfo* function</a>
<a name="ln854">		= dynamic_cast&lt;DwarfFunctionDebugInfo*&gt;(_function);</a>
<a name="ln855">	if (function == NULL)</a>
<a name="ln856">		return B_BAD_VALUE;</a>
<a name="ln857"> </a>
<a name="ln858">	target_addr_t functionStartAddress = function-&gt;Address() - fRelocationDelta;</a>
<a name="ln859">	target_addr_t functionEndAddress = functionStartAddress + function-&gt;Size();</a>
<a name="ln860"> </a>
<a name="ln861">	TRACE_LINES2(&quot;DwarfImageDebugInfo::GetStatementAtSourceLocation(%p, &quot;</a>
<a name="ln862">		&quot;(%&quot; B_PRId32 &quot;, %&quot; B_PRId32 &quot;)): function range: %#&quot; B_PRIx64 &quot; - %#&quot;</a>
<a name="ln863">		B_PRIx64 &quot;\n&quot;, function, sourceLocation.Line(), sourceLocation.Column(),</a>
<a name="ln864">		functionStartAddress, functionEndAddress);</a>
<a name="ln865"> </a>
<a name="ln866">	AutoLocker&lt;BLocker&gt; locker(fLock);</a>
<a name="ln867"> </a>
<a name="ln868">	// get the source file</a>
<a name="ln869">	LocatableFile* file = function-&gt;SourceFile();</a>
<a name="ln870">	if (file == NULL)</a>
<a name="ln871">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln872"> </a>
<a name="ln873">	CompilationUnit* unit = function-&gt;GetCompilationUnit();</a>
<a name="ln874"> </a>
<a name="ln875">	// get the index of the source file in the compilation unit for cheaper</a>
<a name="ln876">	// comparison below</a>
<a name="ln877">	int32 fileIndex = _GetSourceFileIndex(unit, file);</a>
<a name="ln878"> </a>
<a name="ln879">	// Get the statement by executing the line number program for the</a>
<a name="ln880">	// compilation unit.</a>
<a name="ln881">	LineNumberProgram&amp; program = unit-&gt;GetLineNumberProgram();</a>
<a name="ln882">	if (!program.IsValid())</a>
<a name="ln883">		return B_BAD_DATA;</a>
<a name="ln884"> </a>
<a name="ln885">	LineNumberProgram::State state;</a>
<a name="ln886">	program.GetInitialState(state);</a>
<a name="ln887"> </a>
<a name="ln888">	target_addr_t statementAddress = 0;</a>
<a name="ln889">	int32 statementLine = -1;</a>
<a name="ln890">	int32 statementColumn = -1;</a>
<a name="ln891">	while (program.GetNextRow(state)) {</a>
<a name="ln892">		bool isOurFile = state.file == fileIndex;</a>
<a name="ln893"> </a>
<a name="ln894">		if (statementAddress != 0</a>
<a name="ln895">			&amp;&amp; (!isOurFile || state.isStatement || state.isSequenceEnd)) {</a>
<a name="ln896">			target_addr_t endAddress = state.address;</a>
<a name="ln897"> </a>
<a name="ln898">			if (statementAddress &lt; endAddress) {</a>
<a name="ln899">				TRACE_LINES2(&quot;  statement: %#&quot; B_PRIx64 &quot; - %#&quot; B_PRIx64</a>
<a name="ln900">					&quot;, location: (%&quot; B_PRId32 &quot;, %&quot; B_PRId32 &quot;)\n&quot;,</a>
<a name="ln901">					statementAddress, endAddress, statementLine,</a>
<a name="ln902">				 	statementColumn);</a>
<a name="ln903">			}</a>
<a name="ln904"> </a>
<a name="ln905">			if (statementAddress &lt; endAddress</a>
<a name="ln906">				&amp;&amp; statementAddress &gt;= functionStartAddress</a>
<a name="ln907">				&amp;&amp; statementAddress &lt; functionEndAddress</a>
<a name="ln908">				&amp;&amp; statementLine == (int32)sourceLocation.Line()</a>
<a name="ln909">				&amp;&amp; statementColumn == (int32)sourceLocation.Column()) {</a>
<a name="ln910">				TRACE_LINES2(&quot;  -&gt; found statement!\n&quot;);</a>
<a name="ln911"> </a>
<a name="ln912">				ContiguousStatement* statement = new(std::nothrow)</a>
<a name="ln913">					ContiguousStatement(</a>
<a name="ln914">						SourceLocation(statementLine, statementColumn),</a>
<a name="ln915">						TargetAddressRange(fRelocationDelta + statementAddress,</a>
<a name="ln916">							endAddress - statementAddress));</a>
<a name="ln917">				if (statement == NULL)</a>
<a name="ln918">					return B_NO_MEMORY;</a>
<a name="ln919"> </a>
<a name="ln920">				_statement = statement;</a>
<a name="ln921">				return B_OK;</a>
<a name="ln922">			}</a>
<a name="ln923"> </a>
<a name="ln924">			statementAddress = 0;</a>
<a name="ln925">		}</a>
<a name="ln926"> </a>
<a name="ln927">		// skip statements of other files</a>
<a name="ln928">		if (!isOurFile)</a>
<a name="ln929">			continue;</a>
<a name="ln930"> </a>
<a name="ln931">		if (state.isStatement) {</a>
<a name="ln932">			statementAddress = state.address;</a>
<a name="ln933">			statementLine = state.line - 1;</a>
<a name="ln934">			statementColumn = std::max(state.column - 1, (int32)0);</a>
<a name="ln935">		}</a>
<a name="ln936">	}</a>
<a name="ln937"> </a>
<a name="ln938">	return B_ENTRY_NOT_FOUND;</a>
<a name="ln939">}</a>
<a name="ln940"> </a>
<a name="ln941"> </a>
<a name="ln942">status_t</a>
<a name="ln943">DwarfImageDebugInfo::GetSourceLanguage(FunctionDebugInfo* _function,</a>
<a name="ln944">	SourceLanguage*&amp; _language)</a>
<a name="ln945">{</a>
<a name="ln946">	DwarfFunctionDebugInfo* function</a>
<a name="ln947">		= dynamic_cast&lt;DwarfFunctionDebugInfo*&gt;(_function);</a>
<a name="ln948">	if (function == NULL)</a>
<a name="ln949">		return B_BAD_VALUE;</a>
<a name="ln950"> </a>
<a name="ln951">	SourceLanguage* language;</a>
<a name="ln952">	CompilationUnit* unit = function-&gt;GetCompilationUnit();</a>
<a name="ln953">	switch (unit-&gt;UnitEntry()-&gt;Language()) {</a>
<a name="ln954">		case DW_LANG_C89:</a>
<a name="ln955">		case DW_LANG_C:</a>
<a name="ln956">		case DW_LANG_C99:</a>
<a name="ln957">			language = new(std::nothrow) CLanguage;</a>
<a name="ln958">			break;</a>
<a name="ln959">		case DW_LANG_C_plus_plus:</a>
<a name="ln960">			language = new(std::nothrow) CppLanguage;</a>
<a name="ln961">			break;</a>
<a name="ln962">		case 0:</a>
<a name="ln963">		default:</a>
<a name="ln964">			language = new(std::nothrow) UnsupportedLanguage;</a>
<a name="ln965">			break;</a>
<a name="ln966">	}</a>
<a name="ln967"> </a>
<a name="ln968">	if (language == NULL)</a>
<a name="ln969">		return B_NO_MEMORY;</a>
<a name="ln970"> </a>
<a name="ln971">	_language = language;</a>
<a name="ln972">	return B_OK;</a>
<a name="ln973">}</a>
<a name="ln974"> </a>
<a name="ln975"> </a>
<a name="ln976">ssize_t</a>
<a name="ln977">DwarfImageDebugInfo::ReadCode(target_addr_t address, void* buffer, size_t size)</a>
<a name="ln978">{</a>
<a name="ln979">	target_addr_t offset = address - fRelocationDelta</a>
<a name="ln980">		- fTextSegment-&gt;LoadAddress() + fTextSegment-&gt;FileOffset();</a>
<a name="ln981">	ssize_t bytesRead = pread(fFile-&gt;GetElfFile()-&gt;FD(), buffer, size, offset);</a>
<a name="ln982">	return bytesRead &gt;= 0 ? bytesRead : errno;</a>
<a name="ln983">}</a>
<a name="ln984"> </a>
<a name="ln985"> </a>
<a name="ln986">status_t</a>
<a name="ln987">DwarfImageDebugInfo::AddSourceCodeInfo(LocatableFile* file,</a>
<a name="ln988">	FileSourceCode* sourceCode)</a>
<a name="ln989">{</a>
<a name="ln990">	bool addedAny = false;</a>
<a name="ln991">	for (int32 i = 0; CompilationUnit* unit = fFile-&gt;CompilationUnitAt(i);</a>
<a name="ln992">			i++) {</a>
<a name="ln993">		int32 fileIndex = _GetSourceFileIndex(unit, file);</a>
<a name="ln994">		if (fileIndex &lt; 0)</a>
<a name="ln995">			continue;</a>
<a name="ln996"> </a>
<a name="ln997">		status_t error = _AddSourceCodeInfo(unit, sourceCode, fileIndex);</a>
<a name="ln998">		if (error == B_NO_MEMORY)</a>
<a name="ln999">			return error;</a>
<a name="ln1000">		addedAny |= error == B_OK;</a>
<a name="ln1001">	}</a>
<a name="ln1002"> </a>
<a name="ln1003">	return addedAny ? B_OK : B_ENTRY_NOT_FOUND;</a>
<a name="ln1004">}</a>
<a name="ln1005"> </a>
<a name="ln1006"> </a>
<a name="ln1007">status_t</a>
<a name="ln1008">DwarfImageDebugInfo::_AddSourceCodeInfo(CompilationUnit* unit,</a>
<a name="ln1009">	FileSourceCode* sourceCode, int32 fileIndex)</a>
<a name="ln1010">{</a>
<a name="ln1011">	// Get the statements by executing the line number program for the</a>
<a name="ln1012">	// compilation unit and filtering the rows for our source file.</a>
<a name="ln1013">	LineNumberProgram&amp; program = unit-&gt;GetLineNumberProgram();</a>
<a name="ln1014">	if (!program.IsValid())</a>
<a name="ln1015">		return B_BAD_DATA;</a>
<a name="ln1016"> </a>
<a name="ln1017">	LineNumberProgram::State state;</a>
<a name="ln1018">	program.GetInitialState(state);</a>
<a name="ln1019"> </a>
<a name="ln1020">	target_addr_t statementAddress = 0;</a>
<a name="ln1021">	int32 statementLine = -1;</a>
<a name="ln1022">	int32 statementColumn = -1;</a>
<a name="ln1023">	while (program.GetNextRow(state)) {</a>
<a name="ln1024">		TRACE_LINES2(&quot;  %#&quot; B_PRIx64 &quot;  (%&quot; B_PRId32 &quot;, %&quot; B_PRId32 &quot;, %&quot;</a>
<a name="ln1025">			B_PRId32 &quot;)  %d\n&quot;, state.address, state.file, state.line,</a>
<a name="ln1026">			state.column, state.isStatement);</a>
<a name="ln1027"> </a>
<a name="ln1028">		bool isOurFile = state.file == fileIndex;</a>
<a name="ln1029"> </a>
<a name="ln1030">		if (statementAddress != 0</a>
<a name="ln1031">			&amp;&amp; (!isOurFile || state.isStatement || state.isSequenceEnd)) {</a>
<a name="ln1032">			target_addr_t endAddress = state.address;</a>
<a name="ln1033">			if (endAddress &gt; statementAddress) {</a>
<a name="ln1034">				// add the statement</a>
<a name="ln1035">				status_t error = sourceCode-&gt;AddSourceLocation(</a>
<a name="ln1036">					SourceLocation(statementLine, statementColumn));</a>
<a name="ln1037">				if (error != B_OK)</a>
<a name="ln1038">					return error;</a>
<a name="ln1039"> </a>
<a name="ln1040">				TRACE_LINES2(&quot;  -&gt; statement: %#&quot; B_PRIx64 &quot; - %#&quot; B_PRIx64</a>
<a name="ln1041">					&quot;, source location: (%&quot; B_PRId32 &quot;, %&quot; B_PRId32 &quot;)\n&quot;,</a>
<a name="ln1042">					statementAddress, endAddress, statementLine,</a>
<a name="ln1043">				 	statementColumn);</a>
<a name="ln1044">			}</a>
<a name="ln1045"> </a>
<a name="ln1046">			statementAddress = 0;</a>
<a name="ln1047">		}</a>
<a name="ln1048"> </a>
<a name="ln1049">		// skip statements of other files</a>
<a name="ln1050">		if (!isOurFile)</a>
<a name="ln1051">			continue;</a>
<a name="ln1052"> </a>
<a name="ln1053">		if (state.isStatement) {</a>
<a name="ln1054">			statementAddress = state.address;</a>
<a name="ln1055">			statementLine = state.line - 1;</a>
<a name="ln1056">			statementColumn = std::max(state.column - 1, (int32)0);</a>
<a name="ln1057">		}</a>
<a name="ln1058">	}</a>
<a name="ln1059"> </a>
<a name="ln1060">	return B_OK;</a>
<a name="ln1061">}</a>
<a name="ln1062"> </a>
<a name="ln1063"> </a>
<a name="ln1064">int32</a>
<a name="ln1065">DwarfImageDebugInfo::_GetSourceFileIndex(CompilationUnit* unit,</a>
<a name="ln1066">	LocatableFile* sourceFile) const</a>
<a name="ln1067">{</a>
<a name="ln1068">	// get the index of the source file in the compilation unit for cheaper</a>
<a name="ln1069">	// comparison below</a>
<a name="ln1070">	const char* directory;</a>
<a name="ln1071">	for (int32 i = 0; const char* fileName = unit-&gt;FileAt(i, &amp;directory); i++) {</a>
<a name="ln1072">		LocatableFile* file = fFileManager-&gt;GetSourceFile(directory, fileName);</a>
<a name="ln1073">		if (file != NULL) {</a>
<a name="ln1074">			BReference&lt;LocatableFile&gt; fileReference(file, true);</a>
<a name="ln1075">			if (file == sourceFile) {</a>
<a name="ln1076">				return i + 1;</a>
<a name="ln1077">					// indices are one-based</a>
<a name="ln1078">			}</a>
<a name="ln1079">		}</a>
<a name="ln1080">	}</a>
<a name="ln1081"> </a>
<a name="ln1082">	return -1;</a>
<a name="ln1083">}</a>
<a name="ln1084"> </a>
<a name="ln1085"> </a>
<a name="ln1086">status_t</a>
<a name="ln1087">DwarfImageDebugInfo::_CreateLocalVariables(CompilationUnit* unit,</a>
<a name="ln1088">	StackFrame* frame, FunctionID* functionID,</a>
<a name="ln1089">	DwarfStackFrameDebugInfo&amp; factory, target_addr_t instructionPointer,</a>
<a name="ln1090">	target_addr_t lowPC, const EntryListWrapper&amp; variableEntries,</a>
<a name="ln1091">	const EntryListWrapper&amp; blockEntries)</a>
<a name="ln1092">{</a>
<a name="ln1093">	TRACE_LOCALS(&quot;DwarfImageDebugInfo::_CreateLocalVariables(): ip: %#&quot; B_PRIx64</a>
<a name="ln1094">		&quot;, low PC: %#&quot; B_PRIx64 &quot;\n&quot;, instructionPointer, lowPC);</a>
<a name="ln1095"> </a>
<a name="ln1096">	// iterate through the variables and add the ones in scope</a>
<a name="ln1097">	for (DebugInfoEntryList::ConstIterator it</a>
<a name="ln1098">			= variableEntries.list.GetIterator();</a>
<a name="ln1099">		DIEVariable* variableEntry = dynamic_cast&lt;DIEVariable*&gt;(it.Next());) {</a>
<a name="ln1100"> </a>
<a name="ln1101">		TRACE_LOCALS(&quot;  variableEntry %p, scope start: %&quot; B_PRIu64 &quot;\n&quot;,</a>
<a name="ln1102">			variableEntry, variableEntry-&gt;StartScope());</a>
<a name="ln1103"> </a>
<a name="ln1104">		// check the variable's scope</a>
<a name="ln1105">		if (instructionPointer &lt; lowPC + variableEntry-&gt;StartScope())</a>
<a name="ln1106">			continue;</a>
<a name="ln1107"> </a>
<a name="ln1108">		// add the variable</a>
<a name="ln1109">		Variable* variable;</a>
<a name="ln1110">		if (factory.CreateLocalVariable(functionID, variableEntry, variable)</a>
<a name="ln1111">				!= B_OK) {</a>
<a name="ln1112">			continue;</a>
<a name="ln1113">		}</a>
<a name="ln1114">		BReference&lt;Variable&gt; variableReference(variable, true);</a>
<a name="ln1115"> </a>
<a name="ln1116">		if (!frame-&gt;AddLocalVariable(variable))</a>
<a name="ln1117">			return B_NO_MEMORY;</a>
<a name="ln1118">	}</a>
<a name="ln1119"> </a>
<a name="ln1120">	// iterate through the blocks and find the one we're currently in (if any)</a>
<a name="ln1121">	for (DebugInfoEntryList::ConstIterator it = blockEntries.list.GetIterator();</a>
<a name="ln1122">		DIELexicalBlock* block = dynamic_cast&lt;DIELexicalBlock*&gt;(it.Next());) {</a>
<a name="ln1123"> </a>
<a name="ln1124">		TRACE_LOCALS(&quot;  lexical block: %p\n&quot;, block);</a>
<a name="ln1125"> </a>
<a name="ln1126">		// check whether the block has low/high PC attributes</a>
<a name="ln1127">		if (block-&gt;LowPC() != 0) {</a>
<a name="ln1128">			TRACE_LOCALS(&quot;    has lowPC\n&quot;);</a>
<a name="ln1129"> </a>
<a name="ln1130">			// yep, compare with the instruction pointer</a>
<a name="ln1131">			if (instructionPointer &lt; block-&gt;LowPC()</a>
<a name="ln1132">				|| instructionPointer &gt;= block-&gt;HighPC()) {</a>
<a name="ln1133">				continue;</a>
<a name="ln1134">			}</a>
<a name="ln1135">		} else {</a>
<a name="ln1136">			TRACE_LOCALS(&quot;    no lowPC\n&quot;);</a>
<a name="ln1137"> </a>
<a name="ln1138">			// check the address ranges instead</a>
<a name="ln1139">			TargetAddressRangeList* rangeList = fFile-&gt;ResolveRangeList(unit,</a>
<a name="ln1140">				block-&gt;AddressRangesOffset());</a>
<a name="ln1141">			if (rangeList == NULL) {</a>
<a name="ln1142">				TRACE_LOCALS(&quot;    failed to get ranges\n&quot;);</a>
<a name="ln1143">				continue;</a>
<a name="ln1144">			}</a>
<a name="ln1145">			BReference&lt;TargetAddressRangeList&gt; rangeListReference(rangeList,</a>
<a name="ln1146">				true);</a>
<a name="ln1147"> </a>
<a name="ln1148">			if (!rangeList-&gt;Contains(instructionPointer)) {</a>
<a name="ln1149">				TRACE_LOCALS(&quot;    ranges don't contain IP\n&quot;);</a>
<a name="ln1150">				continue;</a>
<a name="ln1151">			}</a>
<a name="ln1152">		}</a>
<a name="ln1153"> </a>
<a name="ln1154">		// found a block -- recurse</a>
<a name="ln1155">		return _CreateLocalVariables(unit, frame, functionID, factory,</a>
<a name="ln1156">			instructionPointer, lowPC, block-&gt;Variables(), block-&gt;Blocks());</a>
<a name="ln1157">	}</a>
<a name="ln1158"> </a>
<a name="ln1159">	return B_OK;</a>
<a name="ln1160">}</a>
<a name="ln1161"> </a>
<a name="ln1162"> </a>
<a name="ln1163">status_t</a>
<a name="ln1164">DwarfImageDebugInfo::_CreateReturnValues(ReturnValueInfoList* returnValueInfos,</a>
<a name="ln1165">	Image* image, StackFrame* frame, DwarfStackFrameDebugInfo&amp; factory)</a>
<a name="ln1166">{</a>
<a name="ln1167">	for (int32 i = 0; i &lt; returnValueInfos-&gt;CountItems(); i++) {</a>
<a name="ln1168">		Image* targetImage = image;</a>
<a name="ln1169">		ReturnValueInfo* valueInfo = returnValueInfos-&gt;ItemAt(i);</a>
<a name="ln1170">		target_addr_t subroutineAddress = valueInfo-&gt;SubroutineAddress();</a>
<a name="ln1171">		CpuState* subroutineState = valueInfo-&gt;State();</a>
<a name="ln1172">		if (!targetImage-&gt;ContainsAddress(subroutineAddress)) {</a>
<a name="ln1173">			// our current image doesn't contain the target function,</a>
<a name="ln1174">			// locate the one which does.</a>
<a name="ln1175">			targetImage = image-&gt;GetTeam()-&gt;ImageByAddress(subroutineAddress);</a>
<a name="ln1176">			if (targetImage == NULL) {</a>
<a name="ln1177">				// nothing we can do, try the next entry (if any)</a>
<a name="ln1178">				continue;</a>
<a name="ln1179">			}</a>
<a name="ln1180">		}</a>
<a name="ln1181"> </a>
<a name="ln1182">		status_t result = B_OK;</a>
<a name="ln1183">		ImageDebugInfo* imageInfo = targetImage-&gt;GetImageDebugInfo();</a>
<a name="ln1184">		if (imageInfo == NULL) {</a>
<a name="ln1185">			// the subroutine may have resolved to a different image</a>
<a name="ln1186">			// that doesn't have debug information available.</a>
<a name="ln1187">			continue;</a>
<a name="ln1188">		}</a>
<a name="ln1189"> </a>
<a name="ln1190">		FunctionInstance* targetFunction;</a>
<a name="ln1191">		if (imageInfo-&gt;GetAddressSectionType(subroutineAddress)</a>
<a name="ln1192">				== ADDRESS_SECTION_TYPE_PLT) {</a>
<a name="ln1193">			result = fArchitecture-&gt;ResolvePICFunctionAddress(</a>
<a name="ln1194">				subroutineAddress, subroutineState, subroutineAddress);</a>
<a name="ln1195">			if (result != B_OK)</a>
<a name="ln1196">				continue;</a>
<a name="ln1197">			if (!targetImage-&gt;ContainsAddress(subroutineAddress)) {</a>
<a name="ln1198">				// the PLT entry doesn't necessarily point to a function</a>
<a name="ln1199">				// in the same image; as such we may need to try to</a>
<a name="ln1200">				// resolve the target address again.</a>
<a name="ln1201">				targetImage = image-&gt;GetTeam()-&gt;ImageByAddress(</a>
<a name="ln1202">					subroutineAddress);</a>
<a name="ln1203">				if (targetImage == NULL)</a>
<a name="ln1204">					continue;</a>
<a name="ln1205">				imageInfo = targetImage-&gt;GetImageDebugInfo();</a>
<a name="ln1206">				if (imageInfo == NULL) {</a>
<a name="ln1207">					// As above, since the indirection here may have</a>
<a name="ln1208">					// landed us in an entirely different image, there is</a>
<a name="ln1209">					// no guarantee that debug info is available,</a>
<a name="ln1210">					// depending on which image it was.</a>
<a name="ln1211">					continue;</a>
<a name="ln1212">				}</a>
<a name="ln1213"> </a>
<a name="ln1214">			}</a>
<a name="ln1215">		}</a>
<a name="ln1216"> </a>
<a name="ln1217">		targetFunction = imageInfo-&gt;FunctionAtAddress(subroutineAddress);</a>
<a name="ln1218">		if (targetFunction != NULL) {</a>
<a name="ln1219">			DwarfFunctionDebugInfo* targetInfo =</a>
<a name="ln1220">				dynamic_cast&lt;DwarfFunctionDebugInfo*&gt;(</a>
<a name="ln1221">					targetFunction-&gt;GetFunctionDebugInfo());</a>
<a name="ln1222">			if (targetInfo != NULL) {</a>
<a name="ln1223">				DIESubprogram* subProgram = targetInfo-&gt;SubprogramEntry();</a>
<a name="ln1224">				DIEType* returnType = subProgram-&gt;ReturnType();</a>
<a name="ln1225">				if (returnType == NULL) {</a>
<a name="ln1226">					// check if we have a specification, and if so, if that has</a>
<a name="ln1227">					// a return type</a>
<a name="ln1228">					subProgram = dynamic_cast&lt;DIESubprogram*&gt;(</a>
<a name="ln1229">						subProgram-&gt;Specification());</a>
<a name="ln1230">					if (subProgram != NULL)</a>
<a name="ln1231">						returnType = subProgram-&gt;ReturnType();</a>
<a name="ln1232"> </a>
<a name="ln1233">					// function doesn't return a value, we're done.</a>
<a name="ln1234">					if (returnType == NULL)</a>
<a name="ln1235">						return B_OK;</a>
<a name="ln1236">				}</a>
<a name="ln1237"> </a>
<a name="ln1238">				uint32 byteSize = 0;</a>
<a name="ln1239">				if (returnType-&gt;ByteSize() == NULL) {</a>
<a name="ln1240">					if (dynamic_cast&lt;DIEAddressingType*&gt;(returnType) != NULL)</a>
<a name="ln1241">						byteSize = fArchitecture-&gt;AddressSize();</a>
<a name="ln1242">				} else</a>
<a name="ln1243">					byteSize = returnType-&gt;ByteSize()-&gt;constant;</a>
<a name="ln1244"> </a>
<a name="ln1245">				// if we were unable to determine a size for the type,</a>
<a name="ln1246">				// simply default to the architecture's register width.</a>
<a name="ln1247">				if (byteSize == 0)</a>
<a name="ln1248">					byteSize = fArchitecture-&gt;AddressSize();</a>
<a name="ln1249"> </a>
<a name="ln1250">				ValueLocation* location;</a>
<a name="ln1251">				result = fArchitecture-&gt;GetReturnAddressLocation(frame,</a>
<a name="ln1252">					byteSize, location);</a>
<a name="ln1253">				if (result != B_OK)</a>
<a name="ln1254">					return result;</a>
<a name="ln1255"> </a>
<a name="ln1256">				BReference&lt;ValueLocation&gt; locationReference(location, true);</a>
<a name="ln1257">				Variable* variable = NULL;</a>
<a name="ln1258">				BReference&lt;FunctionID&gt; idReference(</a>
<a name="ln1259">					targetFunction-&gt;GetFunctionID(), true);</a>
<a name="ln1260">				result = factory.CreateReturnValue(idReference, returnType,</a>
<a name="ln1261">					location, subroutineState, variable);</a>
<a name="ln1262">				if (result != B_OK)</a>
<a name="ln1263">					return result;</a>
<a name="ln1264"> </a>
<a name="ln1265">				BReference&lt;Variable&gt; variableReference(variable, true);</a>
<a name="ln1266">				if (!frame-&gt;AddLocalVariable(variable))</a>
<a name="ln1267">					return B_NO_MEMORY;</a>
<a name="ln1268">			}</a>
<a name="ln1269">		}</a>
<a name="ln1270">	}</a>
<a name="ln1271"> </a>
<a name="ln1272">	return B_OK;</a>
<a name="ln1273">}</a>
<a name="ln1274"> </a>
<a name="ln1275"> </a>
<a name="ln1276">bool</a>
<a name="ln1277">DwarfImageDebugInfo::_EvaluateBaseTypeConstraints(DIEType* type,</a>
<a name="ln1278">	const TypeLookupConstraints&amp; constraints) const</a>
<a name="ln1279">{</a>
<a name="ln1280">	if (constraints.HasBaseTypeName()) {</a>
<a name="ln1281">		BString baseEntryName;</a>
<a name="ln1282">		DIEType* baseTypeOwnerEntry = NULL;</a>
<a name="ln1283"> </a>
<a name="ln1284">		switch (constraints.TypeKind()) {</a>
<a name="ln1285">			case TYPE_ADDRESS:</a>
<a name="ln1286">			{</a>
<a name="ln1287">				DIEAddressingType* addressType =</a>
<a name="ln1288">					dynamic_cast&lt;DIEAddressingType*&gt;(type);</a>
<a name="ln1289">				if (addressType != NULL) {</a>
<a name="ln1290">					baseTypeOwnerEntry = DwarfUtils::GetDIEByPredicate(</a>
<a name="ln1291">						addressType, HasTypePredicate&lt;DIEAddressingType&gt;());</a>
<a name="ln1292">				}</a>
<a name="ln1293">				break;</a>
<a name="ln1294">			}</a>
<a name="ln1295">			case TYPE_ARRAY:</a>
<a name="ln1296">			{</a>
<a name="ln1297">				DIEArrayType* arrayType =</a>
<a name="ln1298">					dynamic_cast&lt;DIEArrayType*&gt;(type);</a>
<a name="ln1299">				if (arrayType != NULL) {</a>
<a name="ln1300">					baseTypeOwnerEntry = DwarfUtils::GetDIEByPredicate(</a>
<a name="ln1301">						arrayType, HasTypePredicate&lt;DIEArrayType&gt;());</a>
<a name="ln1302">				}</a>
<a name="ln1303">				break;</a>
<a name="ln1304">			}</a>
<a name="ln1305">			default:</a>
<a name="ln1306">				break;</a>
<a name="ln1307">		}</a>
<a name="ln1308"> </a>
<a name="ln1309">		if (baseTypeOwnerEntry != NULL) {</a>
<a name="ln1310">			DwarfUtils::GetFullyQualifiedDIEName(baseTypeOwnerEntry,</a>
<a name="ln1311">				baseEntryName);</a>
<a name="ln1312"> </a>
<a name="ln1313">			if (baseEntryName != constraints.BaseTypeName())</a>
<a name="ln1314">				return false;</a>
<a name="ln1315">		}</a>
<a name="ln1316">	}</a>
<a name="ln1317"> </a>
<a name="ln1318">	return true;</a>
<a name="ln1319">}</a>
<a name="ln1320"> </a>
<a name="ln1321"> </a>
<a name="ln1322">status_t</a>
<a name="ln1323">DwarfImageDebugInfo::_RecursiveTraverseNamespaceForFunctions(</a>
<a name="ln1324">	DIENamespace* nsEntry, CompilationUnit* unit,</a>
<a name="ln1325">	BObjectList&lt;FunctionDebugInfo&gt;&amp; functions)</a>
<a name="ln1326">{</a>
<a name="ln1327">	status_t error = B_OK;</a>
<a name="ln1328">	for (DebugInfoEntryList::ConstIterator it</a>
<a name="ln1329">				= nsEntry-&gt;Children().GetIterator();</a>
<a name="ln1330">			DebugInfoEntry* entry = it.Next();) {</a>
<a name="ln1331">		if (entry-&gt;Tag() == DW_TAG_subprogram) {</a>
<a name="ln1332">			DIESubprogram* subprogramEntry</a>
<a name="ln1333">				= static_cast&lt;DIESubprogram*&gt;(entry);</a>
<a name="ln1334">			error = _AddFunction(subprogramEntry, unit, functions);</a>
<a name="ln1335">			if (error != B_OK)</a>
<a name="ln1336">				return error;</a>
<a name="ln1337">		}</a>
<a name="ln1338"> </a>
<a name="ln1339">		DIENamespace* nsEntry = dynamic_cast&lt;DIENamespace*&gt;(entry);</a>
<a name="ln1340">		if (nsEntry != NULL) {</a>
<a name="ln1341">			error = _RecursiveTraverseNamespaceForFunctions(nsEntry, unit,</a>
<a name="ln1342">				functions);</a>
<a name="ln1343">			if (error != B_OK)</a>
<a name="ln1344">				return error;</a>
<a name="ln1345">			continue;</a>
<a name="ln1346">		}</a>
<a name="ln1347"> </a>
<a name="ln1348">		DIEClassBaseType* classEntry = dynamic_cast&lt;DIEClassBaseType*&gt;(entry);</a>
<a name="ln1349">		if (classEntry != NULL) {</a>
<a name="ln1350">			for (DebugInfoEntryList::ConstIterator it</a>
<a name="ln1351">						= classEntry-&gt;MemberFunctions().GetIterator();</a>
<a name="ln1352">					DebugInfoEntry* memberEntry = it.Next();) {</a>
<a name="ln1353">				error = _AddFunction(static_cast&lt;DIESubprogram*&gt;(memberEntry),</a>
<a name="ln1354">					unit, functions);</a>
<a name="ln1355">				if (error != B_OK)</a>
<a name="ln1356">					return error;</a>
<a name="ln1357">			}</a>
<a name="ln1358">		}</a>
<a name="ln1359">	}</a>
<a name="ln1360"> </a>
<a name="ln1361">	return B_OK;</a>
<a name="ln1362">}</a>
<a name="ln1363"> </a>
<a name="ln1364"> </a>
<a name="ln1365">status_t</a>
<a name="ln1366">DwarfImageDebugInfo::_AddFunction(DIESubprogram* subprogramEntry,</a>
<a name="ln1367">	CompilationUnit* unit, BObjectList&lt;FunctionDebugInfo&gt;&amp; functions)</a>
<a name="ln1368">{</a>
<a name="ln1369">	// ignore declarations and inlined functions</a>
<a name="ln1370">	if (subprogramEntry-&gt;IsDeclaration()</a>
<a name="ln1371">		|| subprogramEntry-&gt;Inline() == DW_INL_inlined</a>
<a name="ln1372">		|| subprogramEntry-&gt;Inline() == DW_INL_declared_inlined) {</a>
<a name="ln1373">		return B_OK;</a>
<a name="ln1374">	}</a>
<a name="ln1375"> </a>
<a name="ln1376">	// get the name</a>
<a name="ln1377">	BString name;</a>
<a name="ln1378">	DwarfUtils::GetFullyQualifiedDIEName(subprogramEntry, name);</a>
<a name="ln1379">	if (name.Length() == 0)</a>
<a name="ln1380">		return B_OK;</a>
<a name="ln1381"> </a>
<a name="ln1382">	// get the address ranges</a>
<a name="ln1383">	TargetAddressRangeList* rangeList = fFile-&gt;ResolveRangeList(unit,</a>
<a name="ln1384">		subprogramEntry-&gt;AddressRangesOffset());</a>
<a name="ln1385">	if (rangeList == NULL) {</a>
<a name="ln1386">		target_addr_t lowPC = subprogramEntry-&gt;LowPC();</a>
<a name="ln1387">		target_addr_t highPC = subprogramEntry-&gt;HighPC();</a>
<a name="ln1388">		if (highPC &lt;= lowPC)</a>
<a name="ln1389">			return B_OK;</a>
<a name="ln1390"> </a>
<a name="ln1391">		rangeList = new(std::nothrow) TargetAddressRangeList(</a>
<a name="ln1392">			TargetAddressRange(lowPC, highPC - lowPC));</a>
<a name="ln1393">		if (rangeList == NULL)</a>
<a name="ln1394">			return B_NO_MEMORY;</a>
<a name="ln1395">				// TODO: Clean up already added functions!</a>
<a name="ln1396">	}</a>
<a name="ln1397">	BReference&lt;TargetAddressRangeList&gt; rangeListReference(rangeList,</a>
<a name="ln1398">		true);</a>
<a name="ln1399"> </a>
<a name="ln1400">	// get the source location</a>
<a name="ln1401">	const char* directoryPath = NULL;</a>
<a name="ln1402">	const char* fileName = NULL;</a>
<a name="ln1403">	int32 line = -1;</a>
<a name="ln1404">	int32 column = -1;</a>
<a name="ln1405">	DwarfUtils::GetDeclarationLocation(fFile, subprogramEntry,</a>
<a name="ln1406">		directoryPath, fileName, line, column);</a>
<a name="ln1407"> </a>
<a name="ln1408">	LocatableFile* file = NULL;</a>
<a name="ln1409">	if (fileName != NULL) {</a>
<a name="ln1410">		file = fFileManager-&gt;GetSourceFile(directoryPath,</a>
<a name="ln1411">			fileName);</a>
<a name="ln1412">	}</a>
<a name="ln1413">	BReference&lt;LocatableFile&gt; fileReference(file, true);</a>
<a name="ln1414"> </a>
<a name="ln1415">	// create and add the functions</a>
<a name="ln1416">	DwarfFunctionDebugInfo* function</a>
<a name="ln1417">		= new(std::nothrow) DwarfFunctionDebugInfo(this, unit,</a>
<a name="ln1418">			subprogramEntry, rangeList, name, file,</a>
<a name="ln1419">			SourceLocation(line, std::max(column, (int32)0)));</a>
<a name="ln1420">	if (function == NULL || !functions.AddItem(function)) {</a>
<a name="ln1421">		delete function;</a>
<a name="ln1422">		return B_NO_MEMORY;</a>
<a name="ln1423">			// TODO: Clean up already added functions!</a>
<a name="ln1424">	}</a>
<a name="ln1425"> </a>
<a name="ln1426">	return B_OK;</a>
<a name="ln1427">}</a>
<a name="ln1428"> </a>
<a name="ln1429"> </a>
<a name="ln1430">status_t</a>
<a name="ln1431">DwarfImageDebugInfo::_BuildTypeNameTable()</a>
<a name="ln1432">{</a>
<a name="ln1433">	fTypeNameTable = new(std::nothrow) TypeNameTable;</a>
<a name="ln1434">	if (fTypeNameTable == NULL)</a>
<a name="ln1435">		return B_NO_MEMORY;</a>
<a name="ln1436"> </a>
<a name="ln1437">	status_t error = fTypeNameTable-&gt;Init();</a>
<a name="ln1438">	if (error != B_OK)</a>
<a name="ln1439">		return error;</a>
<a name="ln1440"> </a>
<a name="ln1441">	// iterate through all compilation units</a>
<a name="ln1442">	for (int32 i = 0; CompilationUnit* unit = fFile-&gt;CompilationUnitAt(i);</a>
<a name="ln1443">		i++) {</a>
<a name="ln1444">		// iterate through all types of the compilation unit</a>
<a name="ln1445">		for (DebugInfoEntryList::ConstIterator it</a>
<a name="ln1446">				= unit-&gt;UnitEntry()-&gt;Types().GetIterator();</a>
<a name="ln1447">			DIEType* typeEntry = dynamic_cast&lt;DIEType*&gt;(it.Next());) {</a>
<a name="ln1448"> </a>
<a name="ln1449">			if (_RecursiveAddTypeNames(typeEntry, unit) != B_OK)</a>
<a name="ln1450">				return B_NO_MEMORY;</a>
<a name="ln1451">		}</a>
<a name="ln1452"> </a>
<a name="ln1453">		for (DebugInfoEntryList::ConstIterator it</a>
<a name="ln1454">			= unit-&gt;UnitEntry()-&gt;OtherChildren().GetIterator();</a>
<a name="ln1455">			DebugInfoEntry* child = it.Next();) {</a>
<a name="ln1456">			DIENamespace* namespaceEntry = dynamic_cast&lt;DIENamespace*&gt;(child);</a>
<a name="ln1457">			if (namespaceEntry == NULL)</a>
<a name="ln1458">				continue;</a>
<a name="ln1459"> </a>
<a name="ln1460">			if (_RecursiveTraverseNamespaceForTypes(namespaceEntry, unit)</a>
<a name="ln1461">					!= B_OK) {</a>
<a name="ln1462">				return B_NO_MEMORY;</a>
<a name="ln1463">			}</a>
<a name="ln1464">		}</a>
<a name="ln1465">	}</a>
<a name="ln1466"> </a>
<a name="ln1467">	return B_OK;</a>
<a name="ln1468">}</a>
<a name="ln1469"> </a>
<a name="ln1470"> </a>
<a name="ln1471">status_t</a>
<a name="ln1472">DwarfImageDebugInfo::_RecursiveAddTypeNames(DIEType* type, CompilationUnit* unit)</a>
<a name="ln1473">{</a>
<a name="ln1474">	if (type-&gt;IsDeclaration())</a>
<a name="ln1475">		return B_OK;</a>
<a name="ln1476"> </a>
<a name="ln1477">	BString typeEntryName;</a>
<a name="ln1478">	DwarfUtils::GetFullyQualifiedDIEName(type, typeEntryName);</a>
<a name="ln1479"> </a>
<a name="ln1480">	status_t error = B_OK;</a>
<a name="ln1481">	TypeNameEntry* entry = fTypeNameTable-&gt;Lookup(typeEntryName);</a>
<a name="ln1482">	if (entry == NULL) {</a>
<a name="ln1483">		entry = new(std::nothrow) TypeNameEntry(typeEntryName);</a>
<a name="ln1484">		if (entry == NULL)</a>
<a name="ln1485">			return B_NO_MEMORY;</a>
<a name="ln1486"> </a>
<a name="ln1487">		error = fTypeNameTable-&gt;Insert(entry);</a>
<a name="ln1488">		if (error != B_OK)</a>
<a name="ln1489">			return error;</a>
<a name="ln1490">	}</a>
<a name="ln1491"> </a>
<a name="ln1492">	TypeEntryInfo* info = new(std::nothrow) TypeEntryInfo(type,	unit);</a>
<a name="ln1493">	if (info == NULL)</a>
<a name="ln1494">		return B_NO_MEMORY;</a>
<a name="ln1495"> </a>
<a name="ln1496">	if (!entry-&gt;types.AddItem(info)) {</a>
<a name="ln1497">		delete info;</a>
<a name="ln1498">		return B_NO_MEMORY;</a>
<a name="ln1499">	}</a>
<a name="ln1500"> </a>
<a name="ln1501">	DIEClassBaseType* classType = dynamic_cast&lt;DIEClassBaseType*&gt;(type);</a>
<a name="ln1502">	if (classType == NULL)</a>
<a name="ln1503">		return B_OK;</a>
<a name="ln1504"> </a>
<a name="ln1505">	for (DebugInfoEntryList::ConstIterator it</a>
<a name="ln1506">			= classType-&gt;InnerTypes().GetIterator();</a>
<a name="ln1507">		DIEType* innerType = dynamic_cast&lt;DIEType*&gt;(it.Next());) {</a>
<a name="ln1508">		error = _RecursiveAddTypeNames(innerType, unit);</a>
<a name="ln1509">		if (error != B_OK)</a>
<a name="ln1510">			return error;</a>
<a name="ln1511">	}</a>
<a name="ln1512"> </a>
<a name="ln1513">	return B_OK;</a>
<a name="ln1514">}</a>
<a name="ln1515"> </a>
<a name="ln1516"> </a>
<a name="ln1517">status_t</a>
<a name="ln1518">DwarfImageDebugInfo::_RecursiveTraverseNamespaceForTypes(DIENamespace* nsEntry,</a>
<a name="ln1519">	CompilationUnit* unit)</a>
<a name="ln1520">{</a>
<a name="ln1521">	for (DebugInfoEntryList::ConstIterator it</a>
<a name="ln1522">				= nsEntry-&gt;Children().GetIterator();</a>
<a name="ln1523">			DebugInfoEntry* child = it.Next();) {</a>
<a name="ln1524"> </a>
<a name="ln1525">		if (child-&gt;IsType()) {</a>
<a name="ln1526">			DIEType* type = dynamic_cast&lt;DIEType*&gt;(child);</a>
<a name="ln1527">			if (_RecursiveAddTypeNames(type, unit) != B_OK)</a>
<a name="ln1528">				return B_NO_MEMORY;</a>
<a name="ln1529">		} else {</a>
<a name="ln1530">			DIENamespace* nameSpace = dynamic_cast&lt;DIENamespace*&gt;(child);</a>
<a name="ln1531">			if (nameSpace == NULL)</a>
<a name="ln1532">				continue;</a>
<a name="ln1533"> </a>
<a name="ln1534">			status_t error = _RecursiveTraverseNamespaceForTypes(nameSpace,</a>
<a name="ln1535">				unit);</a>
<a name="ln1536">			if (error != B_OK)</a>
<a name="ln1537">				return error;</a>
<a name="ln1538">			continue;</a>
<a name="ln1539">		}</a>
<a name="ln1540">	}</a>
<a name="ln1541"> </a>
<a name="ln1542">	return B_OK;</a>
<a name="ln1543">}</a>

</code></pre>
<div class="balloon" rel="267"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: next.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
