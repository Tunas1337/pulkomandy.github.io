
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>Roster.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2001-2015 Haiku, Inc. All rights reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Axel DÃ¶rfler, axeld@pinc-software.de</a>
<a name="ln7"> *		Ingo Weinhold, ingo_weinhold@gmx.de</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10"> </a>
<a name="ln11">#include &lt;Roster.h&gt;</a>
<a name="ln12"> </a>
<a name="ln13">#include &lt;ctype.h&gt;</a>
<a name="ln14">#include &lt;new&gt;</a>
<a name="ln15">#include &lt;stdio.h&gt;</a>
<a name="ln16">#include &lt;stdlib.h&gt;</a>
<a name="ln17">#include &lt;strings.h&gt;</a>
<a name="ln18">#include &lt;unistd.h&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;AppFileInfo.h&gt;</a>
<a name="ln21">#include &lt;Application.h&gt;</a>
<a name="ln22">#include &lt;Bitmap.h&gt;</a>
<a name="ln23">#include &lt;Directory.h&gt;</a>
<a name="ln24">#include &lt;File.h&gt;</a>
<a name="ln25">#include &lt;FindDirectory.h&gt;</a>
<a name="ln26">#include &lt;fs_index.h&gt;</a>
<a name="ln27">#include &lt;fs_info.h&gt;</a>
<a name="ln28">#include &lt;image.h&gt;</a>
<a name="ln29">#include &lt;List.h&gt;</a>
<a name="ln30">#include &lt;Mime.h&gt;</a>
<a name="ln31">#include &lt;Node.h&gt;</a>
<a name="ln32">#include &lt;NodeInfo.h&gt;</a>
<a name="ln33">#include &lt;OS.h&gt;</a>
<a name="ln34">#include &lt;Path.h&gt;</a>
<a name="ln35">#include &lt;Query.h&gt;</a>
<a name="ln36">#include &lt;RegistrarDefs.h&gt;</a>
<a name="ln37">#include &lt;String.h&gt;</a>
<a name="ln38">#include &lt;Volume.h&gt;</a>
<a name="ln39">#include &lt;VolumeRoster.h&gt;</a>
<a name="ln40"> </a>
<a name="ln41">#include &lt;locks.h&gt;</a>
<a name="ln42"> </a>
<a name="ln43">#include &lt;AppMisc.h&gt;</a>
<a name="ln44">#include &lt;DesktopLink.h&gt;</a>
<a name="ln45">#include &lt;LaunchRoster.h&gt;</a>
<a name="ln46">#include &lt;MessengerPrivate.h&gt;</a>
<a name="ln47">#include &lt;PortLink.h&gt;</a>
<a name="ln48">#include &lt;RosterPrivate.h&gt;</a>
<a name="ln49">#include &lt;ServerProtocol.h&gt;</a>
<a name="ln50"> </a>
<a name="ln51"> </a>
<a name="ln52">using namespace std;</a>
<a name="ln53">using namespace BPrivate;</a>
<a name="ln54"> </a>
<a name="ln55"> </a>
<a name="ln56">// debugging</a>
<a name="ln57">//#define DBG(x) x</a>
<a name="ln58">#define DBG(x)</a>
<a name="ln59">#ifdef DEBUG_PRINTF</a>
<a name="ln60">#	define OUT DEBUG_PRINTF</a>
<a name="ln61">#else</a>
<a name="ln62">#	define OUT printf</a>
<a name="ln63">#endif</a>
<a name="ln64"> </a>
<a name="ln65"> </a>
<a name="ln66">const BRoster* be_roster;</a>
<a name="ln67"> </a>
<a name="ln68"> </a>
<a name="ln69">//	#pragma mark - Helper functions</a>
<a name="ln70"> </a>
<a name="ln71"> </a>
<a name="ln72">/*!	Extracts an app_info from a BMessage.</a>
<a name="ln73"> </a>
<a name="ln74">	The function searchs for a field &quot;app_info&quot; typed B_REG_APP_INFO_TYPE</a>
<a name="ln75">	and initializes \a info with the found data.</a>
<a name="ln76"> </a>
<a name="ln77">	\param message The message</a>
<a name="ln78">	\param info A pointer to a pre-allocated app_info to be filled in with the</a>
<a name="ln79">	       info found in the message.</a>
<a name="ln80"> </a>
<a name="ln81">	\return A status code.</a>
<a name="ln82">	\retval B_OK Everything went fine.</a>
<a name="ln83">	\retval B_BAD_VALUE \c NULL \a message or \a info.</a>
<a name="ln84">*/</a>
<a name="ln85">static status_t</a>
<a name="ln86">find_message_app_info(BMessage* message, app_info* info)</a>
<a name="ln87">{</a>
<a name="ln88">	status_t error = (message &amp;&amp; info ? B_OK : B_BAD_VALUE);</a>
<a name="ln89">	const flat_app_info* flatInfo = NULL;</a>
<a name="ln90">	ssize_t size = 0;</a>
<a name="ln91">	// find the flat app info in the message</a>
<a name="ln92">	if (error == B_OK) {</a>
<a name="ln93">		error = message-&gt;FindData(&quot;app_info&quot;, B_REG_APP_INFO_TYPE,</a>
<a name="ln94">			(const void**)&amp;flatInfo, &amp;size);</a>
<a name="ln95">	}</a>
<a name="ln96">	// unflatten the flat info</a>
<a name="ln97">	if (error == B_OK) {</a>
<a name="ln98">		if (size == sizeof(flat_app_info)) {</a>
<a name="ln99">			info-&gt;thread = flatInfo-&gt;thread;</a>
<a name="ln100">			info-&gt;team = flatInfo-&gt;team;</a>
<a name="ln101">			info-&gt;port = flatInfo-&gt;port;</a>
<a name="ln102">			info-&gt;flags = flatInfo-&gt;flags;</a>
<a name="ln103">			info-&gt;ref.device = flatInfo-&gt;ref_device;</a>
<a name="ln104">			info-&gt;ref.directory = flatInfo-&gt;ref_directory;</a>
<a name="ln105">			info-&gt;ref.name = NULL;</a>
<a name="ln106">			memcpy(info-&gt;signature, flatInfo-&gt;signature, B_MIME_TYPE_LENGTH);</a>
<a name="ln107">			if (strlen(flatInfo-&gt;ref_name) &gt; 0)</a>
<a name="ln108">				info-&gt;ref.set_name(flatInfo-&gt;ref_name);</a>
<a name="ln109">		} else</a>
<a name="ln110">			error = B_ERROR;</a>
<a name="ln111">	}</a>
<a name="ln112"> </a>
<a name="ln113">	return error;</a>
<a name="ln114">}</a>
<a name="ln115"> </a>
<a name="ln116"> </a>
<a name="ln117">/*!	Checks whether or not an application can be used.</a>
<a name="ln118"> </a>
<a name="ln119">	Currently it is only checked whether the application is in the trash.</a>
<a name="ln120"> </a>
<a name="ln121">	\param ref An entry_ref referring to the application executable.</a>
<a name="ln122"> </a>
<a name="ln123">	\return A status code, \c B_OK on success oir other error codes specifying</a>
<a name="ln124">	        why the application cannot be used.</a>
<a name="ln125">	\retval B_OK The application can be used.</a>
<a name="ln126">	\retval B_ENTRY_NOT_FOUND \a ref doesn't refer to and existing entry.</a>
<a name="ln127">	\retval B_IS_A_DIRECTORY \a ref refers to a directory.</a>
<a name="ln128">	\retval B_LAUNCH_FAILED_APP_IN_TRASH The application executable is in the</a>
<a name="ln129">	        trash.</a>
<a name="ln130">*/</a>
<a name="ln131">static status_t</a>
<a name="ln132">can_app_be_used(const entry_ref* ref)</a>
<a name="ln133">{</a>
<a name="ln134">	status_t error = (ref ? B_OK : B_BAD_VALUE);</a>
<a name="ln135">	// check whether the file exists and is a file.</a>
<a name="ln136">	BEntry entry;</a>
<a name="ln137">	if (error == B_OK)</a>
<a name="ln138">		error = entry.SetTo(ref, true);</a>
<a name="ln139"> </a>
<a name="ln140">	if (error == B_OK &amp;&amp; !entry.Exists())</a>
<a name="ln141">		error = B_ENTRY_NOT_FOUND;</a>
<a name="ln142"> </a>
<a name="ln143">	if (error == B_OK &amp;&amp; !entry.IsFile())</a>
<a name="ln144">		error = B_IS_A_DIRECTORY;</a>
<a name="ln145"> </a>
<a name="ln146">	// check whether the file is in trash</a>
<a name="ln147">	BPath trashPath;</a>
<a name="ln148">	BDirectory directory;</a>
<a name="ln149">	BVolume volume;</a>
<a name="ln150">	if (error == B_OK</a>
<a name="ln151">		&amp;&amp; volume.SetTo(ref-&gt;device) == B_OK</a>
<a name="ln152">		&amp;&amp; find_directory(B_TRASH_DIRECTORY, &amp;trashPath, false, &amp;volume)</a>
<a name="ln153">			== B_OK</a>
<a name="ln154">		&amp;&amp; directory.SetTo(trashPath.Path()) == B_OK</a>
<a name="ln155">		&amp;&amp; directory.Contains(&amp;entry)) {</a>
<a name="ln156">		error = B_LAUNCH_FAILED_APP_IN_TRASH;</a>
<a name="ln157">	}</a>
<a name="ln158"> </a>
<a name="ln159">	return error;</a>
<a name="ln160">}</a>
<a name="ln161"> </a>
<a name="ln162"> </a>
<a name="ln163">/*!	Compares the supplied version infos.</a>
<a name="ln164"> </a>
<a name="ln165">	\param info1 The first info.</a>
<a name="ln166">	\param info2 The second info.</a>
<a name="ln167"> </a>
<a name="ln168">	\return \c -1, if the first info is less than the second one, \c 1, if</a>
<a name="ln169">	        the first one is greater than the second one, and \c 0, if both</a>
<a name="ln170">	        are equal.</a>
<a name="ln171">*/</a>
<a name="ln172">static int32</a>
<a name="ln173">compare_version_infos(const version_info&amp; info1, const version_info&amp; info2)</a>
<a name="ln174">{</a>
<a name="ln175">	int32 result = 0;</a>
<a name="ln176">	if (info1.major &lt; info2.major)</a>
<a name="ln177">		result = -1;</a>
<a name="ln178">	else if (info1.major &gt; info2.major)</a>
<a name="ln179">		result = 1;</a>
<a name="ln180">	else if (info1.middle &lt; info2.middle)</a>
<a name="ln181">		result = -1;</a>
<a name="ln182">	else if (info1.middle &gt; info2.middle)</a>
<a name="ln183">		result = 1;</a>
<a name="ln184">	else if (info1.minor &lt; info2.minor)</a>
<a name="ln185">		result = -1;</a>
<a name="ln186">	else if (info1.minor &gt; info2.minor)</a>
<a name="ln187">		result = 1;</a>
<a name="ln188">	else if (info1.variety &lt; info2.variety)</a>
<a name="ln189">		result = -1;</a>
<a name="ln190">	else if (info1.variety &gt; info2.variety)</a>
<a name="ln191">		result = 1;</a>
<a name="ln192">	else if (info1.internal &lt; info2.internal)</a>
<a name="ln193">		result = -1;</a>
<a name="ln194">	else if (info1.internal &gt; info2.internal)</a>
<a name="ln195">		result = 1;</a>
<a name="ln196"> </a>
<a name="ln197">	return result;</a>
<a name="ln198">}</a>
<a name="ln199"> </a>
<a name="ln200"> </a>
<a name="ln201">/*!	Compares two applications to decide which one should be rather</a>
<a name="ln202">	returned as a query result.</a>
<a name="ln203"> </a>
<a name="ln204">	First, it checks if both apps are in the path, and prefers the app that</a>
<a name="ln205">	appears earlier.</a>
<a name="ln206"> </a>
<a name="ln207">	If both files have a version info, then those are compared.</a>
<a name="ln208">	If one file has a version info, it is said to be greater. If both</a>
<a name="ln209">	files have no version info, their modification times are compared.</a>
<a name="ln210"> </a>
<a name="ln211">	\param app1 An entry_ref referring to the first application.</a>
<a name="ln212">	\param app2 An entry_ref referring to the second application.</a>
<a name="ln213">	\return \c -1, if the first application version is less than the second</a>
<a name="ln214">	        one, \c 1, if the first one is greater than the second one, and</a>
<a name="ln215">	        \c 0, if both are equal.</a>
<a name="ln216">*/</a>
<a name="ln217">static int32</a>
<a name="ln218">compare_queried_apps(const entry_ref* app1, const entry_ref* app2)</a>
<a name="ln219">{</a>
<a name="ln220">	BPath path1(app1);</a>
<a name="ln221">	BPath path2(app2);</a>
<a name="ln222"> </a>
<a name="ln223">	// Check search path</a>
<a name="ln224"> </a>
<a name="ln225">	const char* searchPathes = getenv(&quot;PATH&quot;);</a>
<a name="ln226">	if (searchPathes != NULL) {</a>
<a name="ln227">		char* searchBuffer = strdup(searchPathes);</a>
<a name="ln228">		if (searchBuffer != NULL) {</a>
<a name="ln229">			char* last;</a>
<a name="ln230">			const char* path = strtok_r(searchBuffer, &quot;:&quot;, &amp;last);</a>
<a name="ln231">			while (path != NULL) {</a>
<a name="ln232">				// Check if any app path matches</a>
<a name="ln233">				size_t length = strlen(path);</a>
<a name="ln234">				bool found1 = !strncmp(path, path1.Path(), length)</a>
<a name="ln235">					&amp;&amp; path1.Path()[length] == '/';</a>
<a name="ln236">				bool found2 = !strncmp(path, path2.Path(), length)</a>
<a name="ln237">					&amp;&amp; path2.Path()[length] == '/';;</a>
<a name="ln238"> </a>
<a name="ln239">				if (found1 != found2) {</a>
<a name="ln240">					free(searchBuffer);</a>
<a name="ln241">					return found1 ? 1 : -1;</a>
<a name="ln242">				}</a>
<a name="ln243"> </a>
<a name="ln244">				path = strtok_r(NULL, &quot;:&quot;, &amp;last);</a>
<a name="ln245">			}</a>
<a name="ln246"> </a>
<a name="ln247">			free(searchBuffer);</a>
<a name="ln248">		}</a>
<a name="ln249">	}</a>
<a name="ln250"> </a>
<a name="ln251">	// Check system servers folder</a>
<a name="ln252">	BPath path;</a>
<a name="ln253">	find_directory(B_SYSTEM_SERVERS_DIRECTORY, &amp;path);</a>
<a name="ln254">	BString serverPath(path.Path());</a>
<a name="ln255">	serverPath &lt;&lt; '/';</a>
<a name="ln256">	size_t length = serverPath.Length();</a>
<a name="ln257"> </a>
<a name="ln258">	bool inSystem1 = !strncmp(serverPath.String(), path1.Path(), length);</a>
<a name="ln259">	bool inSystem2 = !strncmp(serverPath.String(), path2.Path(), length);</a>
<a name="ln260">	if (inSystem1 != inSystem2)</a>
<a name="ln261">		return inSystem1 ? 1 : -1;</a>
<a name="ln262"> </a>
<a name="ln263">	// Check version info</a>
<a name="ln264"> </a>
<a name="ln265">	BFile file1;</a>
<a name="ln266">	file1.SetTo(app1, B_READ_ONLY);</a>
<a name="ln267">	BFile file2;</a>
<a name="ln268">	file2.SetTo(app2, B_READ_ONLY);</a>
<a name="ln269"> </a>
<a name="ln270">	BAppFileInfo appFileInfo1;</a>
<a name="ln271">	appFileInfo1.SetTo(&amp;file1);</a>
<a name="ln272">	BAppFileInfo appFileInfo2;</a>
<a name="ln273">	appFileInfo2.SetTo(&amp;file2);</a>
<a name="ln274"> </a>
<a name="ln275">	time_t modificationTime1 = 0;</a>
<a name="ln276">	time_t modificationTime2 = 0;</a>
<a name="ln277"> </a>
<a name="ln278">	file1.GetModificationTime(&amp;modificationTime1);</a>
<a name="ln279">	file2.GetModificationTime(&amp;modificationTime2);</a>
<a name="ln280"> </a>
<a name="ln281">	int32 result = 0;</a>
<a name="ln282"> </a>
<a name="ln283">	version_info versionInfo1;</a>
<a name="ln284">	version_info versionInfo2;</a>
<a name="ln285">	bool hasVersionInfo1 = (appFileInfo1.GetVersionInfo(</a>
<a name="ln286">		&amp;versionInfo1, B_APP_VERSION_KIND) == B_OK);</a>
<a name="ln287">	bool hasVersionInfo2 = (appFileInfo2.GetVersionInfo(</a>
<a name="ln288">		&amp;versionInfo2, B_APP_VERSION_KIND) == B_OK);</a>
<a name="ln289"> </a>
<a name="ln290">	if (hasVersionInfo1) {</a>
<a name="ln291">		if (hasVersionInfo2)</a>
<a name="ln292">			result = compare_version_infos(versionInfo1, versionInfo2);</a>
<a name="ln293">		else</a>
<a name="ln294">			result = 1;</a>
<a name="ln295">	} else {</a>
<a name="ln296">		if (hasVersionInfo2)</a>
<a name="ln297">			result = -1;</a>
<a name="ln298">		else if (modificationTime1 &lt; modificationTime2)</a>
<a name="ln299">			result = -1;</a>
<a name="ln300">		else if (modificationTime1 &gt; modificationTime2)</a>
<a name="ln301">			result = 1;</a>
<a name="ln302">	}</a>
<a name="ln303"> </a>
<a name="ln304">	return result;</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307"> </a>
<a name="ln308">/*!	Finds an app by signature on any mounted volume.</a>
<a name="ln309"> </a>
<a name="ln310">	\param signature The app's signature.</a>
<a name="ln311">	\param appRef A pointer to a pre-allocated entry_ref to be filled with</a>
<a name="ln312">	       a reference to the found application's executable.</a>
<a name="ln313"> </a>
<a name="ln314">	\return A status code.</a>
<a name="ln315">	\retval B_OK Everything went fine.</a>
<a name="ln316">	\retval B_BAD_VALUE: \c NULL \a signature or \a appRef.</a>
<a name="ln317">	\retval B_LAUNCH_FAILED_APP_NOT_FOUND: An application with this signature</a>
<a name="ln318">	        could not be found.</a>
<a name="ln319">*/</a>
<a name="ln320">static status_t</a>
<a name="ln321">query_for_app(const char* signature, entry_ref* appRef)</a>
<a name="ln322">{</a>
<a name="ln323">	if (signature == NULL || appRef == NULL)</a>
<a name="ln324">		return B_BAD_VALUE;</a>
<a name="ln325"> </a>
<a name="ln326">	status_t error = B_LAUNCH_FAILED_APP_NOT_FOUND;</a>
<a name="ln327">	bool caseInsensitive = false;</a>
<a name="ln328"> </a>
<a name="ln329">	while (true) {</a>
<a name="ln330">		// search on all volumes</a>
<a name="ln331">		BVolumeRoster volumeRoster;</a>
<a name="ln332">		BVolume volume;</a>
<a name="ln333">		while (volumeRoster.GetNextVolume(&amp;volume) == B_OK) {</a>
<a name="ln334">			if (!volume.KnowsQuery())</a>
<a name="ln335">				continue;</a>
<a name="ln336"> </a>
<a name="ln337">			index_info info;</a>
<a name="ln338">			if (fs_stat_index(volume.Device(), &quot;BEOS:APP_SIG&quot;, &amp;info) != 0) {</a>
<a name="ln339">				// This volume doesn't seem to have the index we're looking for;</a>
<a name="ln340">				// querying it might need a long time, and we don't care *that*</a>
<a name="ln341">				// much...</a>
<a name="ln342">				continue;</a>
<a name="ln343">			}</a>
<a name="ln344"> </a>
<a name="ln345">			BQuery query;</a>
<a name="ln346">			query.SetVolume(&amp;volume);</a>
<a name="ln347">			query.PushAttr(&quot;BEOS:APP_SIG&quot;);</a>
<a name="ln348">			if (!caseInsensitive)</a>
<a name="ln349">				query.PushString(signature);</a>
<a name="ln350">			else {</a>
<a name="ln351">				// second pass, create a case insensitive query string</a>
<a name="ln352">				char string[B_MIME_TYPE_LENGTH * 4];</a>
<a name="ln353">				strlcpy(string, &quot;application/&quot;, sizeof(string));</a>
<a name="ln354"> </a>
<a name="ln355">				int32 length = strlen(string);</a>
<a name="ln356">				const char* from = signature + length;</a>
<a name="ln357">				char* to = string + length;</a>
<a name="ln358"> </a>
<a name="ln359">				for (; from[0]; from++) {</a>
<a name="ln360">					if (isalpha(from[0])) {</a>
<a name="ln361">						*to++ = '[';</a>
<a name="ln362">						*to++ = tolower(from[0]);</a>
<a name="ln363">						*to++ = toupper(from[0]);</a>
<a name="ln364">						*to++ = ']';</a>
<a name="ln365">					} else</a>
<a name="ln366">						*to++ = from[0];</a>
<a name="ln367">				}</a>
<a name="ln368"> </a>
<a name="ln369">				to[0] = '\0';</a>
<a name="ln370">				query.PushString(string);</a>
<a name="ln371">			}</a>
<a name="ln372">			query.PushOp(B_EQ);</a>
<a name="ln373"> </a>
<a name="ln374">			query.Fetch();</a>
<a name="ln375"> </a>
<a name="ln376">			// walk through the query</a>
<a name="ln377">			bool appFound = false;</a>
<a name="ln378">			status_t foundAppError = B_OK;</a>
<a name="ln379">			entry_ref ref;</a>
<a name="ln380">			while (query.GetNextRef(&amp;ref) == B_OK) {</a>
<a name="ln381">				if ((!appFound || compare_queried_apps(appRef, &amp;ref) &lt; 0)</a>
<a name="ln382">					&amp;&amp; (foundAppError = can_app_be_used(&amp;ref)) == B_OK) {</a>
<a name="ln383">					*appRef = ref;</a>
<a name="ln384">					appFound = true;</a>
<a name="ln385">				}</a>
<a name="ln386">			}</a>
<a name="ln387">			if (!appFound) {</a>
<a name="ln388">				// If the query didn't return any hits, the error is</a>
<a name="ln389">				// B_LAUNCH_FAILED_APP_NOT_FOUND, otherwise we return the</a>
<a name="ln390">				// result of the last can_app_be_used().</a>
<a name="ln391">				error = foundAppError != B_OK</a>
<a name="ln392">					? foundAppError : B_LAUNCH_FAILED_APP_NOT_FOUND;</a>
<a name="ln393">			} else</a>
<a name="ln394">				return B_OK;</a>
<a name="ln395">		}</a>
<a name="ln396"> </a>
<a name="ln397">		if (!caseInsensitive)</a>
<a name="ln398">			caseInsensitive = true;</a>
<a name="ln399">		else</a>
<a name="ln400">			break;</a>
<a name="ln401">	}</a>
<a name="ln402"> </a>
<a name="ln403">	return error;</a>
<a name="ln404">}</a>
<a name="ln405"> </a>
<a name="ln406"> </a>
<a name="ln407">//	#pragma mark - app_info</a>
<a name="ln408"> </a>
<a name="ln409"> </a>
<a name="ln410">app_info::app_info()</a>
<a name="ln411">	:</a>
<a name="ln412">	thread(-1),</a>
<a name="ln413">	team(-1),</a>
<a name="ln414">	port(-1),</a>
<a name="ln415">	flags(B_REG_DEFAULT_APP_FLAGS),</a>
<a name="ln416">	ref()</a>
<a name="ln417">{</a>
<a name="ln418">	signature[0] = '\0';</a>
<a name="ln419">}</a>
<a name="ln420"> </a>
<a name="ln421"> </a>
<a name="ln422">app_info::~app_info()</a>
<a name="ln423">{</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426"> </a>
<a name="ln427">//	#pragma mark - BRoster::ArgVector</a>
<a name="ln428"> </a>
<a name="ln429"> </a>
<a name="ln430">class BRoster::ArgVector {</a>
<a name="ln431">public:</a>
<a name="ln432">								ArgVector();</a>
<a name="ln433">								~ArgVector();</a>
<a name="ln434"> </a>
<a name="ln435">			status_t			Init(int argc, const char* const* args,</a>
<a name="ln436">									const entry_ref* appRef,</a>
<a name="ln437">									const entry_ref* docRef);</a>
<a name="ln438">			void				Unset();</a>
<a name="ln439">	inline	int					Count() const { return fArgc; }</a>
<a name="ln440">	inline	const char* const*	Args() const { return fArgs; }</a>
<a name="ln441"> </a>
<a name="ln442">private:</a>
<a name="ln443">			int					fArgc;</a>
<a name="ln444">			const char**		fArgs;</a>
<a name="ln445">			BPath				fAppPath;</a>
<a name="ln446">			BPath				fDocPath;</a>
<a name="ln447">};</a>
<a name="ln448"> </a>
<a name="ln449"> </a>
<a name="ln450">//!	Creates an uninitialized ArgVector.</a>
<a name="ln451">BRoster::ArgVector::ArgVector()</a>
<a name="ln452">	:</a>
<a name="ln453">	fArgc(0),</a>
<a name="ln454">	fArgs(NULL),</a>
<a name="ln455">	fAppPath(),</a>
<a name="ln456">	fDocPath()</a>
<a name="ln457">{</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460"> </a>
<a name="ln461">//!	Frees all resources associated with the ArgVector.</a>
<a name="ln462">BRoster::ArgVector::~ArgVector()</a>
<a name="ln463">{</a>
<a name="ln464">	Unset();</a>
<a name="ln465">}</a>
<a name="ln466"> </a>
<a name="ln467"> </a>
<a name="ln468">/*!	Initilizes the object according to the supplied parameters.</a>
<a name="ln469"> </a>
<a name="ln470">	If the initialization succeeds, the methods Count() and Args() grant</a>
<a name="ln471">	access to the argument count and vector created by this methods.</a>
<a name="ln472">	\note The returned vector is valid only as long as the elements of the</a>
<a name="ln473">	supplied \a args (if any) are valid and this object is not destroyed.</a>
<a name="ln474">	This object retains ownership of the vector returned by Args().</a>
<a name="ln475">	In case of error, the value returned by Args() is invalid (or \c NULL).</a>
<a name="ln476"> </a>
<a name="ln477">	The argument vector is created as follows: First element is the path</a>
<a name="ln478">	of the entry \a appRef refers to, then follow all elements of \a args</a>
<a name="ln479">	and then, if \a args has at least one element and \a docRef can be</a>
<a name="ln480">	resolved to a path, the path of the entry \a docRef refers to. That is,</a>
<a name="ln481">	if no or an empty \a args vector is supplied, the resulting argument</a>
<a name="ln482">	vector contains only one element, the path associated with \a appRef.</a>
<a name="ln483"> </a>
<a name="ln484">	\param argc Specifies the number of elements \a args contains.</a>
<a name="ln485">	\param args Argument vector. May be \c NULL.</a>
<a name="ln486">	\param appRef entry_ref referring to the entry whose path shall be the</a>
<a name="ln487">	       first element of the resulting argument vector.</a>
<a name="ln488">	\param docRef entry_ref referring to the entry whose path shall be the</a>
<a name="ln489">	       last element of the resulting argument vector. May be \c NULL.</a>
<a name="ln490">	\return</a>
<a name="ln491">	- \c B_OK: Everything went fine.</a>
<a name="ln492">	- \c B_BAD_VALUE: \c NULL \a appRef.</a>
<a name="ln493">	- \c B_ENTRY_NOT_FOUND or other file system error codes: \a appRef could</a>
<a name="ln494">	  not be resolved to a path.</a>
<a name="ln495">	- \c B_NO_MEMORY: Not enough memory to allocate for this operation.</a>
<a name="ln496">*/</a>
<a name="ln497">status_t</a>
<a name="ln498">BRoster::ArgVector::Init(int argc, const char* const* args,</a>
<a name="ln499">	const entry_ref* appRef, const entry_ref* docRef)</a>
<a name="ln500">{</a>
<a name="ln501">	// unset old values</a>
<a name="ln502">	Unset();</a>
<a name="ln503">	status_t error = appRef ? B_OK : B_BAD_VALUE;</a>
<a name="ln504">	// get app path</a>
<a name="ln505">	if (error == B_OK)</a>
<a name="ln506">		error = fAppPath.SetTo(appRef);</a>
<a name="ln507">	// determine number of arguments</a>
<a name="ln508">	bool hasDocArg = false;</a>
<a name="ln509">	if (error == B_OK) {</a>
<a name="ln510">		fArgc = 1;</a>
<a name="ln511">		if (argc &gt; 0 &amp;&amp; args) {</a>
<a name="ln512">			fArgc += argc;</a>
<a name="ln513">			if (docRef != NULL &amp;&amp; fDocPath.SetTo(docRef) == B_OK) {</a>
<a name="ln514">				fArgc++;</a>
<a name="ln515">				hasDocArg = true;</a>
<a name="ln516">			}</a>
<a name="ln517">		}</a>
<a name="ln518">		fArgs = new(nothrow) const char*[fArgc + 1];</a>
<a name="ln519">			// + 1 for the terminating NULL</a>
<a name="ln520">		if (!fArgs)</a>
<a name="ln521">			error = B_NO_MEMORY;</a>
<a name="ln522">	}</a>
<a name="ln523">	// init vector</a>
<a name="ln524">	if (error == B_OK) {</a>
<a name="ln525">		fArgs[0] = fAppPath.Path();</a>
<a name="ln526">		if (argc &gt; 0 &amp;&amp; args != NULL) {</a>
<a name="ln527">			for (int i = 0; i &lt; argc; i++)</a>
<a name="ln528">				fArgs[i + 1] = args[i];</a>
<a name="ln529">			if (hasDocArg)</a>
<a name="ln530">				fArgs[fArgc - 1] = fDocPath.Path();</a>
<a name="ln531">		}</a>
<a name="ln532">		// NULL terminate (e.g. required by load_image())</a>
<a name="ln533">		fArgs[fArgc] = NULL;</a>
<a name="ln534">	}</a>
<a name="ln535">	return error;</a>
<a name="ln536">}</a>
<a name="ln537"> </a>
<a name="ln538"> </a>
<a name="ln539">//!	Uninitializes the object.</a>
<a name="ln540">void</a>
<a name="ln541">BRoster::ArgVector::Unset()</a>
<a name="ln542">{</a>
<a name="ln543">	fArgc = 0;</a>
<a name="ln544">	delete[] fArgs;</a>
<a name="ln545">	fArgs = NULL;</a>
<a name="ln546">	fAppPath.Unset();</a>
<a name="ln547">	fDocPath.Unset();</a>
<a name="ln548">}</a>
<a name="ln549"> </a>
<a name="ln550"> </a>
<a name="ln551">//	#pragma mark - BRoster</a>
<a name="ln552"> </a>
<a name="ln553"> </a>
<a name="ln554">BRoster::BRoster()</a>
<a name="ln555">	:</a>
<a name="ln556">	fMessenger(),</a>
<a name="ln557">	fMimeMessenger(),</a>
<a name="ln558">	fMimeMessengerInitOnce(INIT_ONCE_UNINITIALIZED),</a>
<a name="ln559">	fNoRegistrar(false)</a>
<a name="ln560">{</a>
<a name="ln561">	_InitMessenger();</a>
<a name="ln562">}</a>
<a name="ln563"> </a>
<a name="ln564"> </a>
<a name="ln565">BRoster::~BRoster()</a>
<a name="ln566">{</a>
<a name="ln567">}</a>
<a name="ln568"> </a>
<a name="ln569"> </a>
<a name="ln570">//	#pragma mark - Querying for apps</a>
<a name="ln571"> </a>
<a name="ln572"> </a>
<a name="ln573">bool</a>
<a name="ln574">BRoster::IsRunning(const char* signature) const</a>
<a name="ln575">{</a>
<a name="ln576">	return (TeamFor(signature) &gt;= 0);</a>
<a name="ln577">}</a>
<a name="ln578"> </a>
<a name="ln579"> </a>
<a name="ln580">bool</a>
<a name="ln581">BRoster::IsRunning(entry_ref* ref) const</a>
<a name="ln582">{</a>
<a name="ln583">	return (TeamFor(ref) &gt;= 0);</a>
<a name="ln584">}</a>
<a name="ln585"> </a>
<a name="ln586"> </a>
<a name="ln587">team_id</a>
<a name="ln588">BRoster::TeamFor(const char* signature) const</a>
<a name="ln589">{</a>
<a name="ln590">	team_id team;</a>
<a name="ln591">	app_info info;</a>
<a name="ln592">	status_t error = GetAppInfo(signature, &amp;info);</a>
<a name="ln593">	if (error == B_OK)</a>
<a name="ln594">		team = info.team;</a>
<a name="ln595">	else</a>
<a name="ln596">		team = error;</a>
<a name="ln597"> </a>
<a name="ln598">	return team;</a>
<a name="ln599">}</a>
<a name="ln600"> </a>
<a name="ln601"> </a>
<a name="ln602">team_id</a>
<a name="ln603">BRoster::TeamFor(entry_ref* ref) const</a>
<a name="ln604">{</a>
<a name="ln605">	team_id team;</a>
<a name="ln606">	app_info info;</a>
<a name="ln607">	status_t error = GetAppInfo(ref, &amp;info);</a>
<a name="ln608">	if (error == B_OK)</a>
<a name="ln609">		team = info.team;</a>
<a name="ln610">	else</a>
<a name="ln611">		team = error;</a>
<a name="ln612">	return team;</a>
<a name="ln613">}</a>
<a name="ln614"> </a>
<a name="ln615"> </a>
<a name="ln616">void</a>
<a name="ln617">BRoster::GetAppList(BList* teamIDList) const</a>
<a name="ln618">{</a>
<a name="ln619">	status_t error = (teamIDList ? B_OK : B_BAD_VALUE);</a>
<a name="ln620">	// compose the request message</a>
<a name="ln621">	BMessage request(B_REG_GET_APP_LIST);</a>
<a name="ln622"> </a>
<a name="ln623">	// send the request</a>
<a name="ln624">	BMessage reply;</a>
<a name="ln625">	if (error == B_OK)</a>
<a name="ln626">		error = fMessenger.SendMessage(&amp;request, &amp;reply);</a>
<a name="ln627"> </a>
<a name="ln628">	// evaluate the reply</a>
<a name="ln629">	if (error == B_OK) {</a>
<a name="ln630">		if (reply.what == B_REG_SUCCESS) {</a>
<a name="ln631">			team_id team;</a>
<a name="ln632">			for (int32 i = 0; reply.FindInt32(&quot;teams&quot;, i, &amp;team) == B_OK; i++)</a>
<a name="ln633">				teamIDList-&gt;AddItem((void*)(addr_t)team);</a>
<a name="ln634">		} else {</a>
<a name="ln635">			if (reply.FindInt32(&quot;error&quot;, &amp;error) != B_OK)</a>
<a name="ln636">				error = B_ERROR;</a>
<a name="ln637">			DBG(OUT(&quot;Roster request unsuccessful: %s\n&quot;, strerror(error)));</a>
<a name="ln638">			DBG(reply.PrintToStream());</a>
<a name="ln639">		}</a>
<a name="ln640">	} else {</a>
<a name="ln641">		DBG(OUT(&quot;Sending message to roster failed: %s\n&quot;, strerror(error)));</a>
<a name="ln642">	}</a>
<a name="ln643">}</a>
<a name="ln644"> </a>
<a name="ln645"> </a>
<a name="ln646">void</a>
<a name="ln647">BRoster::GetAppList(const char* signature, BList* teamIDList) const</a>
<a name="ln648">{</a>
<a name="ln649">	status_t error = B_OK;</a>
<a name="ln650">	if (signature == NULL || teamIDList == NULL)</a>
<a name="ln651">		error = B_BAD_VALUE;</a>
<a name="ln652"> </a>
<a name="ln653">	// compose the request message</a>
<a name="ln654">	BMessage request(B_REG_GET_APP_LIST);</a>
<a name="ln655">	if (error == B_OK)</a>
<a name="ln656">		error = request.AddString(&quot;signature&quot;, signature);</a>
<a name="ln657"> </a>
<a name="ln658">	// send the request</a>
<a name="ln659">	BMessage reply;</a>
<a name="ln660">	if (error == B_OK)</a>
<a name="ln661">		error = fMessenger.SendMessage(&amp;request, &amp;reply);</a>
<a name="ln662"> </a>
<a name="ln663">	// evaluate the reply</a>
<a name="ln664">	if (error == B_OK) {</a>
<a name="ln665">		if (reply.what == B_REG_SUCCESS) {</a>
<a name="ln666">			team_id team;</a>
<a name="ln667">			for (int32 i = 0; reply.FindInt32(&quot;teams&quot;, i, &amp;team) == B_OK; i++)</a>
<a name="ln668">				teamIDList-&gt;AddItem((void*)(addr_t)team);</a>
<a name="ln669">		} else if (reply.FindInt32(&quot;error&quot;, &amp;error) != B_OK)</a>
<a name="ln670">			error = B_ERROR;</a>
<a name="ln671">	}</a>
<a name="ln672">}</a>
<a name="ln673"> </a>
<a name="ln674"> </a>
<a name="ln675">status_t</a>
<a name="ln676">BRoster::GetAppInfo(const char* signature, app_info* info) const</a>
<a name="ln677">{</a>
<a name="ln678">	status_t error = B_OK;</a>
<a name="ln679">	if (signature == NULL || info == NULL)</a>
<a name="ln680">		error = B_BAD_VALUE;</a>
<a name="ln681"> </a>
<a name="ln682">	// compose the request message</a>
<a name="ln683">	BMessage request(B_REG_GET_APP_INFO);</a>
<a name="ln684">	if (error == B_OK)</a>
<a name="ln685">		error = request.AddString(&quot;signature&quot;, signature);</a>
<a name="ln686"> </a>
<a name="ln687">	// send the request</a>
<a name="ln688">	BMessage reply;</a>
<a name="ln689">	if (error == B_OK)</a>
<a name="ln690">		error = fMessenger.SendMessage(&amp;request, &amp;reply);</a>
<a name="ln691"> </a>
<a name="ln692">	// evaluate the reply</a>
<a name="ln693">	if (error == B_OK) {</a>
<a name="ln694">		if (reply.what == B_REG_SUCCESS)</a>
<a name="ln695">			error = find_message_app_info(&amp;reply, info);</a>
<a name="ln696">		else if (reply.FindInt32(&quot;error&quot;, &amp;error) != B_OK)</a>
<a name="ln697">			error = B_ERROR;</a>
<a name="ln698">	}</a>
<a name="ln699"> </a>
<a name="ln700">	return error;</a>
<a name="ln701">}</a>
<a name="ln702"> </a>
<a name="ln703"> </a>
<a name="ln704">status_t</a>
<a name="ln705">BRoster::GetAppInfo(entry_ref* ref, app_info* info) const</a>
<a name="ln706">{</a>
<a name="ln707">	status_t error = (ref &amp;&amp; info ? B_OK : B_BAD_VALUE);</a>
<a name="ln708">	// compose the request message</a>
<a name="ln709">	BMessage request(B_REG_GET_APP_INFO);</a>
<a name="ln710">	if (error == B_OK)</a>
<a name="ln711">		error = request.AddRef(&quot;ref&quot;, ref);</a>
<a name="ln712"> </a>
<a name="ln713">	// send the request</a>
<a name="ln714">	BMessage reply;</a>
<a name="ln715">	if (error == B_OK)</a>
<a name="ln716">		error = fMessenger.SendMessage(&amp;request, &amp;reply);</a>
<a name="ln717"> </a>
<a name="ln718">	// evaluate the reply</a>
<a name="ln719">	if (error == B_OK) {</a>
<a name="ln720">		if (reply.what == B_REG_SUCCESS)</a>
<a name="ln721">			error = find_message_app_info(&amp;reply, info);</a>
<a name="ln722">		else if (reply.FindInt32(&quot;error&quot;, &amp;error) != B_OK)</a>
<a name="ln723">			error = B_ERROR;</a>
<a name="ln724">	}</a>
<a name="ln725">	return error;</a>
<a name="ln726">}</a>
<a name="ln727"> </a>
<a name="ln728"> </a>
<a name="ln729">status_t</a>
<a name="ln730">BRoster::GetRunningAppInfo(team_id team, app_info* info) const</a>
<a name="ln731">{</a>
<a name="ln732">	status_t error = (info ? B_OK : B_BAD_VALUE);</a>
<a name="ln733">	if (error == B_OK &amp;&amp; team &lt; 0)</a>
<a name="ln734">		error = B_BAD_TEAM_ID;</a>
<a name="ln735">	// compose the request message</a>
<a name="ln736">	BMessage request(B_REG_GET_APP_INFO);</a>
<a name="ln737">	if (error == B_OK)</a>
<a name="ln738">		error = request.AddInt32(&quot;team&quot;, team);</a>
<a name="ln739">	// send the request</a>
<a name="ln740">	BMessage reply;</a>
<a name="ln741">	if (error == B_OK)</a>
<a name="ln742">		error = fMessenger.SendMessage(&amp;request, &amp;reply);</a>
<a name="ln743"> </a>
<a name="ln744">	// evaluate the reply</a>
<a name="ln745">	if (error == B_OK) {</a>
<a name="ln746">		if (reply.what == B_REG_SUCCESS)</a>
<a name="ln747">			error = find_message_app_info(&amp;reply, info);</a>
<a name="ln748">		else if (reply.FindInt32(&quot;error&quot;, &amp;error) != B_OK)</a>
<a name="ln749">			error = B_ERROR;</a>
<a name="ln750">	}</a>
<a name="ln751">	return error;</a>
<a name="ln752">}</a>
<a name="ln753"> </a>
<a name="ln754"> </a>
<a name="ln755">status_t</a>
<a name="ln756">BRoster::GetActiveAppInfo(app_info* info) const</a>
<a name="ln757">{</a>
<a name="ln758">	if (info == NULL)</a>
<a name="ln759">		return B_BAD_VALUE;</a>
<a name="ln760"> </a>
<a name="ln761">	// compose the request message</a>
<a name="ln762">	BMessage request(B_REG_GET_APP_INFO);</a>
<a name="ln763">	// send the request</a>
<a name="ln764">	BMessage reply;</a>
<a name="ln765">	status_t error = fMessenger.SendMessage(&amp;request, &amp;reply);</a>
<a name="ln766">	// evaluate the reply</a>
<a name="ln767">	if (error == B_OK) {</a>
<a name="ln768">		if (reply.what == B_REG_SUCCESS)</a>
<a name="ln769">			error = find_message_app_info(&amp;reply, info);</a>
<a name="ln770">		else if (reply.FindInt32(&quot;error&quot;, &amp;error) != B_OK)</a>
<a name="ln771">			error = B_ERROR;</a>
<a name="ln772">	}</a>
<a name="ln773">	return error;</a>
<a name="ln774">}</a>
<a name="ln775"> </a>
<a name="ln776"> </a>
<a name="ln777">status_t</a>
<a name="ln778">BRoster::FindApp(const char* mimeType, entry_ref* app) const</a>
<a name="ln779">{</a>
<a name="ln780">	if (mimeType == NULL || app == NULL)</a>
<a name="ln781">		return B_BAD_VALUE;</a>
<a name="ln782"> </a>
<a name="ln783">	return _ResolveApp(mimeType, NULL, app, NULL, NULL, NULL);</a>
<a name="ln784">}</a>
<a name="ln785"> </a>
<a name="ln786"> </a>
<a name="ln787">status_t</a>
<a name="ln788">BRoster::FindApp(entry_ref* ref, entry_ref* app) const</a>
<a name="ln789">{</a>
<a name="ln790">	if (ref == NULL || app == NULL)</a>
<a name="ln791">		return B_BAD_VALUE;</a>
<a name="ln792"> </a>
<a name="ln793">	entry_ref _ref(*ref);</a>
<a name="ln794">	return _ResolveApp(NULL, &amp;_ref, app, NULL, NULL, NULL);</a>
<a name="ln795">}</a>
<a name="ln796"> </a>
<a name="ln797"> </a>
<a name="ln798">//	#pragma mark - Launching, activating, and broadcasting to apps</a>
<a name="ln799"> </a>
<a name="ln800"> </a>
<a name="ln801">status_t</a>
<a name="ln802">BRoster::Broadcast(BMessage* message) const</a>
<a name="ln803">{</a>
<a name="ln804">	return Broadcast(message, be_app_messenger);</a>
<a name="ln805">}</a>
<a name="ln806"> </a>
<a name="ln807"> </a>
<a name="ln808">status_t</a>
<a name="ln809">BRoster::Broadcast(BMessage* message, BMessenger replyTo) const</a>
<a name="ln810">{</a>
<a name="ln811">	status_t error = (message ? B_OK : B_BAD_VALUE);</a>
<a name="ln812">	// compose the request message</a>
<a name="ln813">	BMessage request(B_REG_BROADCAST);</a>
<a name="ln814">	if (error == B_OK)</a>
<a name="ln815">		error = request.AddInt32(&quot;team&quot;, BPrivate::current_team());</a>
<a name="ln816">	if (error == B_OK)</a>
<a name="ln817">		error = request.AddMessage(&quot;message&quot;, message);</a>
<a name="ln818">	if (error == B_OK)</a>
<a name="ln819">		error = request.AddMessenger(&quot;reply_target&quot;, replyTo);</a>
<a name="ln820"> </a>
<a name="ln821">	// send the request</a>
<a name="ln822">	BMessage reply;</a>
<a name="ln823">	if (error == B_OK)</a>
<a name="ln824">		error = fMessenger.SendMessage(&amp;request, &amp;reply);</a>
<a name="ln825"> </a>
<a name="ln826">	// evaluate the reply</a>
<a name="ln827">	if (error == B_OK &amp;&amp; reply.what != B_REG_SUCCESS</a>
<a name="ln828">		&amp;&amp; reply.FindInt32(&quot;error&quot;, &amp;error) != B_OK)</a>
<a name="ln829">		error = B_ERROR;</a>
<a name="ln830"> </a>
<a name="ln831">	return error;</a>
<a name="ln832">}</a>
<a name="ln833"> </a>
<a name="ln834"> </a>
<a name="ln835">status_t</a>
<a name="ln836">BRoster::StartWatching(BMessenger target, uint32 eventMask) const</a>
<a name="ln837">{</a>
<a name="ln838">	status_t error = B_OK;</a>
<a name="ln839">	// compose the request message</a>
<a name="ln840">	BMessage request(B_REG_START_WATCHING);</a>
<a name="ln841">	if (error == B_OK)</a>
<a name="ln842">		error = request.AddMessenger(&quot;target&quot;, target);</a>
<a name="ln843">	if (error == B_OK)</a>
<a name="ln844">		error = request.AddInt32(&quot;events&quot;, (int32)eventMask);</a>
<a name="ln845"> </a>
<a name="ln846">	// send the request</a>
<a name="ln847">	BMessage reply;</a>
<a name="ln848">	if (error == B_OK)</a>
<a name="ln849">		error = fMessenger.SendMessage(&amp;request, &amp;reply);</a>
<a name="ln850"> </a>
<a name="ln851">	// evaluate the reply</a>
<a name="ln852">	if (error == B_OK &amp;&amp; reply.what != B_REG_SUCCESS</a>
<a name="ln853">		&amp;&amp; reply.FindInt32(&quot;error&quot;, &amp;error) != B_OK)</a>
<a name="ln854">		error = B_ERROR;</a>
<a name="ln855"> </a>
<a name="ln856">	return error;</a>
<a name="ln857">}</a>
<a name="ln858"> </a>
<a name="ln859"> </a>
<a name="ln860">status_t</a>
<a name="ln861">BRoster::StopWatching(BMessenger target) const</a>
<a name="ln862">{</a>
<a name="ln863">	status_t error = B_OK;</a>
<a name="ln864">	// compose the request message</a>
<a name="ln865">	BMessage request(B_REG_STOP_WATCHING);</a>
<a name="ln866">	if (error == B_OK)</a>
<a name="ln867">		error = request.AddMessenger(&quot;target&quot;, target);</a>
<a name="ln868"> </a>
<a name="ln869">	// send the request</a>
<a name="ln870">	BMessage reply;</a>
<a name="ln871">	if (error == B_OK)</a>
<a name="ln872">		error = fMessenger.SendMessage(&amp;request, &amp;reply);</a>
<a name="ln873"> </a>
<a name="ln874">	// evaluate the reply</a>
<a name="ln875">	if (error == B_OK &amp;&amp; reply.what != B_REG_SUCCESS</a>
<a name="ln876">		&amp;&amp; reply.FindInt32(&quot;error&quot;, &amp;error) != B_OK)</a>
<a name="ln877">		error = B_ERROR;</a>
<a name="ln878"> </a>
<a name="ln879">	return error;</a>
<a name="ln880">}</a>
<a name="ln881"> </a>
<a name="ln882"> </a>
<a name="ln883">status_t</a>
<a name="ln884">BRoster::ActivateApp(team_id team) const</a>
<a name="ln885">{</a>
<a name="ln886">	BPrivate::DesktopLink link;</a>
<a name="ln887"> </a>
<a name="ln888">	status_t status = link.InitCheck();</a>
<a name="ln889">	if (status &lt; B_OK)</a>
<a name="ln890">		return status;</a>
<a name="ln891"> </a>
<a name="ln892">	// prepare the message</a>
<a name="ln893">	status_t error = link.StartMessage(AS_ACTIVATE_APP);</a>
<a name="ln894">	if (error != B_OK)</a>
<a name="ln895">		return error;</a>
<a name="ln896"> </a>
<a name="ln897">	error = link.Attach(link.ReceiverPort());</a>
<a name="ln898">	if (error != B_OK)</a>
<a name="ln899">		return error;</a>
<a name="ln900"> </a>
<a name="ln901">	error = link.Attach(team);</a>
<a name="ln902">	if (error != B_OK)</a>
<a name="ln903">		return error;</a>
<a name="ln904"> </a>
<a name="ln905">	// send it</a>
<a name="ln906">	status_t code;</a>
<a name="ln907">	error = link.FlushWithReply(code);</a>
<a name="ln908">	if (error != B_OK)</a>
<a name="ln909">		return error;</a>
<a name="ln910"> </a>
<a name="ln911">	return code;</a>
<a name="ln912">}</a>
<a name="ln913"> </a>
<a name="ln914"> </a>
<a name="ln915">status_t</a>
<a name="ln916">BRoster::Launch(const char* mimeType, BMessage* initialMessage,</a>
<a name="ln917">	team_id* _appTeam) const</a>
<a name="ln918">{</a>
<a name="ln919">	if (mimeType == NULL)</a>
<a name="ln920">		return B_BAD_VALUE;</a>
<a name="ln921"> </a>
<a name="ln922">	BList messageList;</a>
<a name="ln923">	if (initialMessage != NULL)</a>
<a name="ln924">		messageList.AddItem(initialMessage);</a>
<a name="ln925"> </a>
<a name="ln926">	return _LaunchApp(mimeType, NULL, &amp;messageList, 0, NULL,</a>
<a name="ln927">		(const char**)environ, _appTeam, NULL, NULL, NULL, false);</a>
<a name="ln928">}</a>
<a name="ln929"> </a>
<a name="ln930"> </a>
<a name="ln931">status_t</a>
<a name="ln932">BRoster::Launch(const char* mimeType, BList* messageList,</a>
<a name="ln933">	team_id* _appTeam) const</a>
<a name="ln934">{</a>
<a name="ln935">	if (mimeType == NULL)</a>
<a name="ln936">		return B_BAD_VALUE;</a>
<a name="ln937"> </a>
<a name="ln938">	return _LaunchApp(mimeType, NULL, messageList, 0, NULL,</a>
<a name="ln939">		(const char**)environ, _appTeam, NULL, NULL, NULL, false);</a>
<a name="ln940">}</a>
<a name="ln941"> </a>
<a name="ln942"> </a>
<a name="ln943">status_t</a>
<a name="ln944">BRoster::Launch(const char* mimeType, int argc, const char* const* args,</a>
<a name="ln945">	team_id* _appTeam) const</a>
<a name="ln946">{</a>
<a name="ln947">	if (mimeType == NULL)</a>
<a name="ln948">		return B_BAD_VALUE;</a>
<a name="ln949"> </a>
<a name="ln950">	return _LaunchApp(mimeType, NULL, NULL, argc, args, (const char**)environ,</a>
<a name="ln951">		_appTeam, NULL, NULL, NULL, false);</a>
<a name="ln952">}</a>
<a name="ln953"> </a>
<a name="ln954"> </a>
<a name="ln955">status_t</a>
<a name="ln956">BRoster::Launch(const entry_ref* ref, const BMessage* initialMessage,</a>
<a name="ln957">	team_id* _appTeam) const</a>
<a name="ln958">{</a>
<a name="ln959">	if (ref == NULL)</a>
<a name="ln960">		return B_BAD_VALUE;</a>
<a name="ln961"> </a>
<a name="ln962">	BList messageList;</a>
<a name="ln963">	if (initialMessage != NULL)</a>
<a name="ln964">		messageList.AddItem(const_cast&lt;BMessage*&gt;(initialMessage));</a>
<a name="ln965"> </a>
<a name="ln966">	return _LaunchApp(NULL, ref, &amp;messageList, 0, NULL, (const char**)environ,</a>
<a name="ln967">		_appTeam, NULL, NULL, NULL, false);</a>
<a name="ln968">}</a>
<a name="ln969"> </a>
<a name="ln970"> </a>
<a name="ln971">status_t</a>
<a name="ln972">BRoster::Launch(const entry_ref* ref, const BList* messageList,</a>
<a name="ln973">	team_id* appTeam) const</a>
<a name="ln974">{</a>
<a name="ln975">	if (ref == NULL)</a>
<a name="ln976">		return B_BAD_VALUE;</a>
<a name="ln977"> </a>
<a name="ln978">	return _LaunchApp(NULL, ref, messageList, 0, NULL, (const char**)environ,</a>
<a name="ln979">		appTeam, NULL, NULL, NULL, false);</a>
<a name="ln980">}</a>
<a name="ln981"> </a>
<a name="ln982"> </a>
<a name="ln983">status_t</a>
<a name="ln984">BRoster::Launch(const entry_ref* ref, int argc, const char* const* args,</a>
<a name="ln985">	team_id* appTeam) const</a>
<a name="ln986">{</a>
<a name="ln987">	if (ref == NULL)</a>
<a name="ln988">		return B_BAD_VALUE;</a>
<a name="ln989"> </a>
<a name="ln990">	return _LaunchApp(NULL, ref, NULL, argc, args, (const char**)environ,</a>
<a name="ln991">		appTeam, NULL, NULL, NULL, false);</a>
<a name="ln992">}</a>
<a name="ln993"> </a>
<a name="ln994"> </a>
<a name="ln995">#if __GNUC__ == 2</a>
<a name="ln996">// #pragma mark - Binary compatibility</a>
<a name="ln997"> </a>
<a name="ln998"> </a>
<a name="ln999">extern &quot;C&quot; status_t</a>
<a name="ln1000">Launch__C7BRosterP9entry_refP8BMessagePl(BRoster* roster, entry_ref* ref,</a>
<a name="ln1001">	BMessage* initialMessage)</a>
<a name="ln1002">{</a>
<a name="ln1003">	return roster-&gt;BRoster::Launch(ref, initialMessage, NULL);</a>
<a name="ln1004">}</a>
<a name="ln1005"> </a>
<a name="ln1006"> </a>
<a name="ln1007">extern &quot;C&quot; status_t</a>
<a name="ln1008">Launch__C7BRosterPCciPPcPl(BRoster* roster, const char* mimeType,</a>
<a name="ln1009">	int argc, char** args, team_id* _appTeam)</a>
<a name="ln1010">{</a>
<a name="ln1011">	return roster-&gt;BRoster::Launch(mimeType, argc, args, _appTeam);</a>
<a name="ln1012">}</a>
<a name="ln1013"> </a>
<a name="ln1014"> </a>
<a name="ln1015">extern &quot;C&quot; status_t</a>
<a name="ln1016">Launch__C7BRosterP9entry_refiPPcPl(BRoster* roster, entry_ref* ref,</a>
<a name="ln1017">	int argc, char* const* args, team_id* _appTeam)</a>
<a name="ln1018">{</a>
<a name="ln1019">	return roster-&gt;BRoster::Launch(ref, argc, args, _appTeam);</a>
<a name="ln1020">}</a>
<a name="ln1021">#endif	// __GNUC__ == 2</a>
<a name="ln1022"> </a>
<a name="ln1023"> </a>
<a name="ln1024">//	#pragma mark - Recent document and app support</a>
<a name="ln1025"> </a>
<a name="ln1026"> </a>
<a name="ln1027">void</a>
<a name="ln1028">BRoster::GetRecentDocuments(BMessage* refList, int32 maxCount,</a>
<a name="ln1029">	const char* fileType, const char* signature) const</a>
<a name="ln1030">{</a>
<a name="ln1031">	if (refList == NULL)</a>
<a name="ln1032">		return;</a>
<a name="ln1033"> </a>
<a name="ln1034">	status_t error = maxCount &gt; 0 ? B_OK : B_BAD_VALUE;</a>
<a name="ln1035"> </a>
<a name="ln1036">	// Use the message we've been given for both request and reply</a>
<a name="ln1037">	BMessage&amp; message = *refList;</a>
<a name="ln1038">	BMessage&amp; reply = *refList;</a>
<a name="ln1039">	status_t result;</a>
<a name="ln1040"> </a>
<a name="ln1041">	// Build and send the message, read the reply</a>
<a name="ln1042">	if (error == B_OK) {</a>
<a name="ln1043">		message.what = B_REG_GET_RECENT_DOCUMENTS;</a>
<a name="ln1044">		error = message.AddInt32(&quot;max count&quot;, maxCount);</a>
<a name="ln1045">	}</a>
<a name="ln1046">	if (error == B_OK &amp;&amp; fileType)</a>
<a name="ln1047">		error = message.AddString(&quot;file type&quot;, fileType);</a>
<a name="ln1048"> </a>
<a name="ln1049">	if (error == B_OK &amp;&amp; signature)</a>
<a name="ln1050">		error = message.AddString(&quot;app sig&quot;, signature);</a>
<a name="ln1051"> </a>
<a name="ln1052">	fMessenger.SendMessage(&amp;message, &amp;reply);</a>
<a name="ln1053">	if (error == B_OK) {</a>
<a name="ln1054">		error = reply.what == B_REG_RESULT</a>
<a name="ln1055">			? (status_t)B_OK : (status_t)B_BAD_REPLY;</a>
<a name="ln1056">	}</a>
<a name="ln1057"> </a>
<a name="ln1058">	if (error == B_OK)</a>
<a name="ln1059">		error = reply.FindInt32(&quot;result&quot;, &amp;result);</a>
<a name="ln1060"> </a>
<a name="ln1061">	if (error == B_OK)</a>
<a name="ln1062">		error = result;</a>
<a name="ln1063"> </a>
<a name="ln1064">	// Clear the result if an error occured</a>
<a name="ln1065">	if (error != B_OK &amp;&amp; refList != NULL)</a>
<a name="ln1066">		refList-&gt;MakeEmpty();</a>
<a name="ln1067"> </a>
<a name="ln1068">	// No return value, how sad :-(</a>
<a name="ln1069">	//return error;</a>
<a name="ln1070">}</a>
<a name="ln1071"> </a>
<a name="ln1072"> </a>
<a name="ln1073">void</a>
<a name="ln1074">BRoster::GetRecentDocuments(BMessage* refList, int32 maxCount,</a>
<a name="ln1075">	const char* fileTypes[], int32 fileTypesCount,</a>
<a name="ln1076">	const char* signature) const</a>
<a name="ln1077">{</a>
<a name="ln1078">	if (refList == NULL)</a>
<a name="ln1079">		return;</a>
<a name="ln1080"> </a>
<a name="ln1081">	status_t error = maxCount &gt; 0 ? B_OK : B_BAD_VALUE;</a>
<a name="ln1082"> </a>
<a name="ln1083">	// Use the message we've been given for both request and reply</a>
<a name="ln1084">	BMessage&amp; message = *refList;</a>
<a name="ln1085">	BMessage&amp; reply = *refList;</a>
<a name="ln1086">	status_t result;</a>
<a name="ln1087"> </a>
<a name="ln1088">	// Build and send the message, read the reply</a>
<a name="ln1089">	if (error == B_OK) {</a>
<a name="ln1090">		message.what = B_REG_GET_RECENT_DOCUMENTS;</a>
<a name="ln1091">		error = message.AddInt32(&quot;max count&quot;, maxCount);</a>
<a name="ln1092">	}</a>
<a name="ln1093">	if (error == B_OK &amp;&amp; fileTypes) {</a>
<a name="ln1094">		for (int i = 0; i &lt; fileTypesCount &amp;&amp; error == B_OK; i++)</a>
<a name="ln1095">			error = message.AddString(&quot;file type&quot;, fileTypes[i]);</a>
<a name="ln1096">	}</a>
<a name="ln1097">	if (error == B_OK &amp;&amp; signature)</a>
<a name="ln1098">		error = message.AddString(&quot;app sig&quot;, signature);</a>
<a name="ln1099"> </a>
<a name="ln1100">	fMessenger.SendMessage(&amp;message, &amp;reply);</a>
<a name="ln1101">	if (error == B_OK) {</a>
<a name="ln1102">		error = reply.what == B_REG_RESULT</a>
<a name="ln1103">			? (status_t)B_OK : (status_t)B_BAD_REPLY;</a>
<a name="ln1104">	}</a>
<a name="ln1105">	if (error == B_OK)</a>
<a name="ln1106">		error = reply.FindInt32(&quot;result&quot;, &amp;result);</a>
<a name="ln1107"> </a>
<a name="ln1108">	if (error == B_OK)</a>
<a name="ln1109">		error = result;</a>
<a name="ln1110"> </a>
<a name="ln1111">	// Clear the result if an error occured</a>
<a name="ln1112">	if (error != B_OK &amp;&amp; refList != NULL)</a>
<a name="ln1113">		refList-&gt;MakeEmpty();</a>
<a name="ln1114"> </a>
<a name="ln1115">	// No return value, how sad :-(</a>
<a name="ln1116">	//return error;</a>
<a name="ln1117">}</a>
<a name="ln1118"> </a>
<a name="ln1119"> </a>
<a name="ln1120">void</a>
<a name="ln1121">BRoster::GetRecentFolders(BMessage* refList, int32 maxCount,</a>
<a name="ln1122">	const char* signature) const</a>
<a name="ln1123">{</a>
<a name="ln1124">	if (refList == NULL)</a>
<a name="ln1125">		return;</a>
<a name="ln1126"> </a>
<a name="ln1127">	status_t error = maxCount &gt; 0 ? B_OK : B_BAD_VALUE;</a>
<a name="ln1128"> </a>
<a name="ln1129">	// Use the message we've been given for both request and reply</a>
<a name="ln1130">	BMessage&amp; message = *refList;</a>
<a name="ln1131">	BMessage&amp; reply = *refList;</a>
<a name="ln1132">	status_t result;</a>
<a name="ln1133"> </a>
<a name="ln1134">	// Build and send the message, read the reply</a>
<a name="ln1135">	if (error == B_OK) {</a>
<a name="ln1136">		message.what = B_REG_GET_RECENT_FOLDERS;</a>
<a name="ln1137">		error = message.AddInt32(&quot;max count&quot;, maxCount);</a>
<a name="ln1138">	}</a>
<a name="ln1139">	if (error == B_OK &amp;&amp; signature)</a>
<a name="ln1140">		error = message.AddString(&quot;app sig&quot;, signature);</a>
<a name="ln1141"> </a>
<a name="ln1142">	fMessenger.SendMessage(&amp;message, &amp;reply);</a>
<a name="ln1143">	if (error == B_OK) {</a>
<a name="ln1144">		error = reply.what == B_REG_RESULT</a>
<a name="ln1145">			? (status_t)B_OK : (status_t)B_BAD_REPLY;</a>
<a name="ln1146">	}</a>
<a name="ln1147"> </a>
<a name="ln1148">	if (error == B_OK)</a>
<a name="ln1149">		error = reply.FindInt32(&quot;result&quot;, &amp;result);</a>
<a name="ln1150"> </a>
<a name="ln1151">	if (error == B_OK)</a>
<a name="ln1152">		error = result;</a>
<a name="ln1153"> </a>
<a name="ln1154">	// Clear the result if an error occured</a>
<a name="ln1155">	if (error != B_OK &amp;&amp; refList != NULL)</a>
<a name="ln1156">		refList-&gt;MakeEmpty();</a>
<a name="ln1157"> </a>
<a name="ln1158">	// No return value, how sad :-(</a>
<a name="ln1159">	//return error;</a>
<a name="ln1160">}</a>
<a name="ln1161"> </a>
<a name="ln1162"> </a>
<a name="ln1163">void</a>
<a name="ln1164">BRoster::GetRecentApps(BMessage* refList, int32 maxCount) const</a>
<a name="ln1165">{</a>
<a name="ln1166">	if (refList == NULL)</a>
<a name="ln1167">		return;</a>
<a name="ln1168"> </a>
<a name="ln1169">	status_t err = maxCount &gt; 0 ? B_OK : B_BAD_VALUE;</a>
<a name="ln1170"> </a>
<a name="ln1171">	// Use the message we've been given for both request and reply</a>
<a name="ln1172">	BMessage&amp; message = *refList;</a>
<a name="ln1173">	BMessage&amp; reply = *refList;</a>
<a name="ln1174">	status_t result;</a>
<a name="ln1175"> </a>
<a name="ln1176">	// Build and send the message, read the reply</a>
<a name="ln1177">	if (!err) {</a>
<a name="ln1178">		message.what = B_REG_GET_RECENT_APPS;</a>
<a name="ln1179">		err = message.AddInt32(&quot;max count&quot;, maxCount);</a>
<a name="ln1180">	}</a>
<a name="ln1181">	fMessenger.SendMessage(&amp;message, &amp;reply);</a>
<a name="ln1182">	if (!err) {</a>
<a name="ln1183">		err = reply.what == B_REG_RESULT</a>
<a name="ln1184">			? (status_t)B_OK : (status_t)B_BAD_REPLY;</a>
<a name="ln1185">	}</a>
<a name="ln1186">	if (!err)</a>
<a name="ln1187">		err = reply.FindInt32(&quot;result&quot;, &amp;result);</a>
<a name="ln1188"> </a>
<a name="ln1189">	if (!err)</a>
<a name="ln1190">		err = result;</a>
<a name="ln1191"> </a>
<a name="ln1192">	// Clear the result if an error occured</a>
<a name="ln1193">	if (err &amp;&amp; refList)</a>
<a name="ln1194">		refList-&gt;MakeEmpty();</a>
<a name="ln1195"> </a>
<a name="ln1196">	// No return value, how sad :-(</a>
<a name="ln1197">	//return err;</a>
<a name="ln1198">}</a>
<a name="ln1199"> </a>
<a name="ln1200"> </a>
<a name="ln1201">void</a>
<a name="ln1202">BRoster::AddToRecentDocuments(const entry_ref* document,</a>
<a name="ln1203">	const char* signature) const</a>
<a name="ln1204">{</a>
<a name="ln1205">	status_t error = document ? B_OK : B_BAD_VALUE;</a>
<a name="ln1206"> </a>
<a name="ln1207">	// Use the message we've been given for both request and reply</a>
<a name="ln1208">	BMessage message(B_REG_ADD_TO_RECENT_DOCUMENTS);</a>
<a name="ln1209">	BMessage reply;</a>
<a name="ln1210">	status_t result;</a>
<a name="ln1211">	char* callingApplicationSignature = NULL;</a>
<a name="ln1212"> </a>
<a name="ln1213">	// If no signature is supplied, look up the signature of</a>
<a name="ln1214">	// the calling app</a>
<a name="ln1215">	if (error == B_OK &amp;&amp; signature == NULL) {</a>
<a name="ln1216">		app_info info;</a>
<a name="ln1217">		error = GetRunningAppInfo(be_app-&gt;Team(), &amp;info);</a>
<a name="ln1218">		if (error == B_OK)</a>
<a name="ln1219">			callingApplicationSignature = info.signature;</a>
<a name="ln1220">	}</a>
<a name="ln1221"> </a>
<a name="ln1222">	// Build and send the message, read the reply</a>
<a name="ln1223">	if (error == B_OK)</a>
<a name="ln1224">		error = message.AddRef(&quot;ref&quot;, document);</a>
<a name="ln1225"> </a>
<a name="ln1226">	if (error == B_OK) {</a>
<a name="ln1227">		error = message.AddString(&quot;app sig&quot;, signature != NULL</a>
<a name="ln1228">			? signature : callingApplicationSignature);</a>
<a name="ln1229">	}</a>
<a name="ln1230">	fMessenger.SendMessage(&amp;message, &amp;reply);</a>
<a name="ln1231">	if (error == B_OK) {</a>
<a name="ln1232">		error = reply.what == B_REG_RESULT</a>
<a name="ln1233">			? (status_t)B_OK : (status_t)B_BAD_REPLY;</a>
<a name="ln1234">	}</a>
<a name="ln1235">	if (error == B_OK)</a>
<a name="ln1236">		error = reply.FindInt32(&quot;result&quot;, &amp;result);</a>
<a name="ln1237"> </a>
<a name="ln1238">	if (error == B_OK)</a>
<a name="ln1239">		error = result;</a>
<a name="ln1240"> </a>
<a name="ln1241">	if (error != B_OK) {</a>
<a name="ln1242">		DBG(OUT(&quot;WARNING: BRoster::AddToRecentDocuments() failed with error &quot;</a>
<a name="ln1243">			&quot;0x%&quot; B_PRIx32 &quot;\n&quot;, error));</a>
<a name="ln1244">	}</a>
<a name="ln1245">}</a>
<a name="ln1246"> </a>
<a name="ln1247"> </a>
<a name="ln1248">void</a>
<a name="ln1249">BRoster::AddToRecentFolders(const entry_ref* folder,</a>
<a name="ln1250">	const char* signature) const</a>
<a name="ln1251">{</a>
<a name="ln1252">	status_t error = folder ? B_OK : B_BAD_VALUE;</a>
<a name="ln1253"> </a>
<a name="ln1254">	// Use the message we've been given for both request and reply</a>
<a name="ln1255">	BMessage message(B_REG_ADD_TO_RECENT_FOLDERS);</a>
<a name="ln1256">	BMessage reply;</a>
<a name="ln1257">	status_t result;</a>
<a name="ln1258">	char* callingApplicationSignature = NULL;</a>
<a name="ln1259"> </a>
<a name="ln1260">	// If no signature is supplied, look up the signature of</a>
<a name="ln1261">	// the calling app</a>
<a name="ln1262">	if (error == B_OK &amp;&amp; signature == NULL) {</a>
<a name="ln1263">		app_info info;</a>
<a name="ln1264">		error = GetRunningAppInfo(be_app-&gt;Team(), &amp;info);</a>
<a name="ln1265">		if (error == B_OK)</a>
<a name="ln1266">			callingApplicationSignature = info.signature;</a>
<a name="ln1267">	}</a>
<a name="ln1268"> </a>
<a name="ln1269">	// Build and send the message, read the reply</a>
<a name="ln1270">	if (error == B_OK)</a>
<a name="ln1271">		error = message.AddRef(&quot;ref&quot;, folder);</a>
<a name="ln1272"> </a>
<a name="ln1273">	if (error == B_OK) {</a>
<a name="ln1274">		error = message.AddString(&quot;app sig&quot;,</a>
<a name="ln1275">			signature != NULL ? signature : callingApplicationSignature);</a>
<a name="ln1276">	}</a>
<a name="ln1277">	fMessenger.SendMessage(&amp;message, &amp;reply);</a>
<a name="ln1278">	if (error == B_OK) {</a>
<a name="ln1279">		error = reply.what == B_REG_RESULT</a>
<a name="ln1280">			? (status_t)B_OK : (status_t)B_BAD_REPLY;</a>
<a name="ln1281">	}</a>
<a name="ln1282">	if (error == B_OK)</a>
<a name="ln1283">		error = reply.FindInt32(&quot;result&quot;, &amp;result);</a>
<a name="ln1284"> </a>
<a name="ln1285">	if (error == B_OK)</a>
<a name="ln1286">		error = result;</a>
<a name="ln1287"> </a>
<a name="ln1288">	if (error != B_OK) {</a>
<a name="ln1289">		DBG(OUT(&quot;WARNING: BRoster::AddToRecentDocuments() failed with error &quot;</a>
<a name="ln1290">			&quot;0x%&quot; B_PRIx32 &quot;\n&quot;, error));</a>
<a name="ln1291">	}</a>
<a name="ln1292">}</a>
<a name="ln1293"> </a>
<a name="ln1294">//	#pragma mark - Private or reserved</a>
<a name="ln1295"> </a>
<a name="ln1296"> </a>
<a name="ln1297">/*!	Shuts down the system.</a>
<a name="ln1298"> </a>
<a name="ln1299">	When \c synchronous is \c true and the method succeeds, it doesn't return.</a>
<a name="ln1300"> </a>
<a name="ln1301">	\param reboot If \c true, the system will be rebooted instead of being</a>
<a name="ln1302">	       powered off.</a>
<a name="ln1303">	\param confirm If \c true, the user will be asked to confirm to shut down</a>
<a name="ln1304">	       the system.</a>
<a name="ln1305">	\param synchronous If \c false, the method will return as soon as the</a>
<a name="ln1306">	       shutdown process has been initiated successfully (or an error</a>
<a name="ln1307">	       occurred). Otherwise the method doesn't return, if successfully.</a>
<a name="ln1308"> </a>
<a name="ln1309">	\return A status code, \c B_OK on success or another error code in case</a>
<a name="ln1310">	        something went wrong.</a>
<a name="ln1311">	\retval B_SHUTTING_DOWN, when there's already a shutdown process in</a>
<a name="ln1312">	        progress,</a>
<a name="ln1313">	\retval B_SHUTDOWN_CANCELLED, when the user cancelled the shutdown process,</a>
<a name="ln1314">*/</a>
<a name="ln1315">status_t</a>
<a name="ln1316">BRoster::_ShutDown(bool reboot, bool confirm, bool synchronous)</a>
<a name="ln1317">{</a>
<a name="ln1318">	status_t error = B_OK;</a>
<a name="ln1319"> </a>
<a name="ln1320">	// compose the request message</a>
<a name="ln1321">	BMessage request(B_REG_SHUT_DOWN);</a>
<a name="ln1322">	if (error == B_OK)</a>
<a name="ln1323">		error = request.AddBool(&quot;reboot&quot;, reboot);</a>
<a name="ln1324"> </a>
<a name="ln1325">	if (error == B_OK)</a>
<a name="ln1326">		error = request.AddBool(&quot;confirm&quot;, confirm);</a>
<a name="ln1327"> </a>
<a name="ln1328">	if (error == B_OK)</a>
<a name="ln1329">		error = request.AddBool(&quot;synchronous&quot;, synchronous);</a>
<a name="ln1330"> </a>
<a name="ln1331">	// send the request</a>
<a name="ln1332">	BMessage reply;</a>
<a name="ln1333">	if (error == B_OK)</a>
<a name="ln1334">		error = fMessenger.SendMessage(&amp;request, &amp;reply);</a>
<a name="ln1335"> </a>
<a name="ln1336">	// evaluate the reply</a>
<a name="ln1337">	if (error == B_OK &amp;&amp; reply.what != B_REG_SUCCESS</a>
<a name="ln1338">		&amp;&amp; reply.FindInt32(&quot;error&quot;, &amp;error) != B_OK) {</a>
<a name="ln1339">		error = B_ERROR;</a>
<a name="ln1340">	}</a>
<a name="ln1341"> </a>
<a name="ln1342">	return error;</a>
<a name="ln1343">}</a>
<a name="ln1344"> </a>
<a name="ln1345"> </a>
<a name="ln1346">/*!	(Pre-)Registers an application with the registrar.</a>
<a name="ln1347"> </a>
<a name="ln1348">	This methods is invoked either to register or to pre-register an</a>
<a name="ln1349">	application. Full registration is requested by supplying \c true via</a>
<a name="ln1350">	\a fullRegistration.</a>
<a name="ln1351"> </a>
<a name="ln1352">	A full registration requires \a signature, \a ref, \a flags, \a team,</a>
<a name="ln1353">	\a thread and \a port to contain valid values. No token will be return</a>
<a name="ln1354">	via \a pToken.</a>
<a name="ln1355"> </a>
<a name="ln1356">	For a pre-registration \a signature, \a ref, \a flags must be valid.</a>
<a name="ln1357">	\a team and \a thread are optional and should be set to -1, if they are</a>
<a name="ln1358">	unknown. If no team ID is supplied, \a pToken should be valid and, if the</a>
<a name="ln1359">	the pre-registration succeeds, will be filled with a unique token assigned</a>
<a name="ln1360">	by the roster.</a>
<a name="ln1361"> </a>
<a name="ln1362">	In both cases the registration may fail, if single/exclusive launch is</a>
<a name="ln1363">	requested and an instance of the application is already running. Then</a>
<a name="ln1364">	\c B_ALREADY_RUNNING is returned and the team ID of the running instance</a>
<a name="ln1365">	is passed back via \a otherTeam, if supplied.</a>
<a name="ln1366"> </a>
<a name="ln1367">	\param signature The application's signature</a>
<a name="ln1368">	\param ref An entry_ref referring to the app's executable</a>
<a name="ln1369">	\param flags The application's flags</a>
<a name="ln1370">	\param team The application's team ID</a>
<a name="ln1371">	\param thread The application's main thread</a>
<a name="ln1372">	\param port The application's looper port</a>
<a name="ln1373">	\param fullRegistration \c true for full, \c false for pre-registration</a>
<a name="ln1374">	\param pToken A pointer to a pre-allocated uint32 into which the token</a>
<a name="ln1375">	       assigned by the registrar is written (may be \c NULL)</a>
<a name="ln1376">	\param otherTeam A pointer to a pre-allocated team_id into which the</a>
<a name="ln1377">	       team ID of the already running instance of a single/exclusive</a>
<a name="ln1378">	       launch application is written (may be \c NULL)</a>
<a name="ln1379"> </a>
<a name="ln1380">	\return A status code</a>
<a name="ln1381">	\retval B_OK Everything went fine.</a>
<a name="ln1382">	\retval B_ENTRY_NOT_FOUND \a ref didn't refer to a file.</a>
<a name="ln1383">	\retval B_ALREADY_RUNNING The application requested a single/exclusive</a>
<a name="ln1384">	        launch and an instance was already running.</a>
<a name="ln1385">	\retval B_REG_ALREADY_REGISTERED An application with the team ID \a team</a>
<a name="ln1386">	        was already registered.</a>
<a name="ln1387">*/</a>
<a name="ln1388">status_t</a>
<a name="ln1389">BRoster::_AddApplication(const char* signature, const entry_ref* ref,</a>
<a name="ln1390">	uint32 flags, team_id team, thread_id thread, port_id port,</a>
<a name="ln1391">	bool fullRegistration, uint32* pToken, team_id* otherTeam) const</a>
<a name="ln1392">{</a>
<a name="ln1393">	status_t error = B_OK;</a>
<a name="ln1394"> </a>
<a name="ln1395">	// compose the request message</a>
<a name="ln1396">	BMessage request(B_REG_ADD_APP);</a>
<a name="ln1397">	if (error == B_OK &amp;&amp; signature != NULL)</a>
<a name="ln1398">		error = request.AddString(&quot;signature&quot;, signature);</a>
<a name="ln1399"> </a>
<a name="ln1400">	if (error == B_OK &amp;&amp; ref != NULL)</a>
<a name="ln1401">		error = request.AddRef(&quot;ref&quot;, ref);</a>
<a name="ln1402"> </a>
<a name="ln1403">	if (error == B_OK)</a>
<a name="ln1404">		error = request.AddInt32(&quot;flags&quot;, (int32)flags);</a>
<a name="ln1405"> </a>
<a name="ln1406">	if (error == B_OK &amp;&amp; team &gt;= 0)</a>
<a name="ln1407">		error = request.AddInt32(&quot;team&quot;, team);</a>
<a name="ln1408"> </a>
<a name="ln1409">	if (error == B_OK &amp;&amp; thread &gt;= 0)</a>
<a name="ln1410">		error = request.AddInt32(&quot;thread&quot;, thread);</a>
<a name="ln1411"> </a>
<a name="ln1412">	if (error == B_OK &amp;&amp; port &gt;= 0)</a>
<a name="ln1413">		error = request.AddInt32(&quot;port&quot;, port);</a>
<a name="ln1414"> </a>
<a name="ln1415">	if (error == B_OK)</a>
<a name="ln1416">		error = request.AddBool(&quot;full_registration&quot;, fullRegistration);</a>
<a name="ln1417"> </a>
<a name="ln1418">	// send the request</a>
<a name="ln1419">	BMessage reply;</a>
<a name="ln1420">	if (error == B_OK)</a>
<a name="ln1421">		error = fMessenger.SendMessage(&amp;request, &amp;reply);</a>
<a name="ln1422"> </a>
<a name="ln1423">	// evaluate the reply</a>
<a name="ln1424">	if (error == B_OK) {</a>
<a name="ln1425">		if (reply.what == B_REG_SUCCESS) {</a>
<a name="ln1426">			if (!fullRegistration &amp;&amp; team &lt; 0) {</a>
<a name="ln1427">				uint32 token;</a>
<a name="ln1428">				if (reply.FindInt32(&quot;token&quot;, (int32*)&amp;token) == B_OK) {</a>
<a name="ln1429">					if (pToken != NULL)</a>
<a name="ln1430">						*pToken = token;</a>
<a name="ln1431">				} else</a>
<a name="ln1432">					error = B_ERROR;</a>
<a name="ln1433">			}</a>
<a name="ln1434">		} else {</a>
<a name="ln1435">			if (reply.FindInt32(&quot;error&quot;, &amp;error) != B_OK)</a>
<a name="ln1436">				error = B_ERROR;</a>
<a name="ln1437"> </a>
<a name="ln1438">			// get team and token from the reply</a>
<a name="ln1439">			if (otherTeam != NULL</a>
<a name="ln1440">				&amp;&amp; reply.FindInt32(&quot;other_team&quot;, otherTeam) != B_OK) {</a>
<a name="ln1441">				*otherTeam = -1;</a>
<a name="ln1442">			}</a>
<a name="ln1443">			if (pToken != NULL</a>
<a name="ln1444">				&amp;&amp; reply.FindInt32(&quot;token&quot;, (int32*)pToken) != B_OK) {</a>
<a name="ln1445">				*pToken = 0;</a>
<a name="ln1446">			}</a>
<a name="ln1447">		}</a>
<a name="ln1448">	}</a>
<a name="ln1449"> </a>
<a name="ln1450">	return error;</a>
<a name="ln1451">}</a>
<a name="ln1452"> </a>
<a name="ln1453"> </a>
<a name="ln1454">/*!	Sets an application's signature.</a>
<a name="ln1455"> </a>
<a name="ln1456">	The application must be registered or at pre-registered with a valid</a>
<a name="ln1457">	team ID.</a>
<a name="ln1458"> </a>
<a name="ln1459">	\param team The app's team ID.</a>
<a name="ln1460">	\param signature The app's new signature.</a>
<a name="ln1461"> </a>
<a name="ln1462">	\return A status code.</a>
<a name="ln1463">	\retval B_OK Everything went fine.</a>
<a name="ln1464">	\retval B_REG_APP_NOT_REGISTERED The supplied team ID did not identify a</a>
<a name="ln1465">	        registered application.</a>
<a name="ln1466">*/</a>
<a name="ln1467">status_t</a>
<a name="ln1468">BRoster::_SetSignature(team_id team, const char* signature) const</a>
<a name="ln1469">{</a>
<a name="ln1470">	status_t error = B_OK;</a>
<a name="ln1471"> </a>
<a name="ln1472">	// compose the request message</a>
<a name="ln1473">	BMessage request(B_REG_SET_SIGNATURE);</a>
<a name="ln1474">	if (team &gt;= 0)</a>
<a name="ln1475">		error = request.AddInt32(&quot;team&quot;, team);</a>
<a name="ln1476"> </a>
<a name="ln1477">	if (error == B_OK &amp;&amp; signature)</a>
<a name="ln1478">		error = request.AddString(&quot;signature&quot;, signature);</a>
<a name="ln1479"> </a>
<a name="ln1480">	// send the request</a>
<a name="ln1481">	BMessage reply;</a>
<a name="ln1482">	if (error == B_OK)</a>
<a name="ln1483">		error = fMessenger.SendMessage(&amp;request, &amp;reply);</a>
<a name="ln1484"> </a>
<a name="ln1485">	// evaluate the reply</a>
<a name="ln1486">	if (error == B_OK &amp;&amp; reply.what != B_REG_SUCCESS</a>
<a name="ln1487">		&amp;&amp; reply.FindInt32(&quot;error&quot;, &amp;error) != B_OK) {</a>
<a name="ln1488">		error = B_ERROR;</a>
<a name="ln1489">	}</a>
<a name="ln1490"> </a>
<a name="ln1491">	return error;</a>
<a name="ln1492">}</a>
<a name="ln1493"> </a>
<a name="ln1494"> </a>
<a name="ln1495">//!	\todo Really needed?</a>
<a name="ln1496">void</a>
<a name="ln1497">BRoster::_SetThread(team_id team, thread_id thread) const</a>
<a name="ln1498">{</a>
<a name="ln1499">}</a>
<a name="ln1500"> </a>
<a name="ln1501"> </a>
<a name="ln1502">/*!	Sets the team and thread IDs of a pre-registered application.</a>
<a name="ln1503"> </a>
<a name="ln1504">	After an application has been pre-registered via AddApplication(), without</a>
<a name="ln1505">	supplying a team ID, the team and thread IDs have to be set using this</a>
<a name="ln1506">	method.</a>
<a name="ln1507"> </a>
<a name="ln1508">	\param entryToken The token identifying the application (returned by</a>
<a name="ln1509">	       AddApplication())</a>
<a name="ln1510">	\param thread The app's thread ID</a>
<a name="ln1511">	\param team The app's team ID</a>
<a name="ln1512"> </a>
<a name="ln1513">	\return A status code.</a>
<a name="ln1514">	\retval B_OK Everything went fine.</a>
<a name="ln1515">	\retval B_REG_APP_NOT_PRE_REGISTERED The supplied token did not identify a</a>
<a name="ln1516">	        pre-registered application.</a>
<a name="ln1517">*/</a>
<a name="ln1518">status_t</a>
<a name="ln1519">BRoster::_SetThreadAndTeam(uint32 entryToken, thread_id thread,</a>
<a name="ln1520">	team_id team, port_id* _port) const</a>
<a name="ln1521">{</a>
<a name="ln1522">	status_t error = B_OK;</a>
<a name="ln1523"> </a>
<a name="ln1524">	// compose the request message</a>
<a name="ln1525">	BMessage request(B_REG_SET_THREAD_AND_TEAM);</a>
<a name="ln1526">	if (error == B_OK)</a>
<a name="ln1527">		error = request.AddInt32(&quot;token&quot;, (int32)entryToken);</a>
<a name="ln1528"> </a>
<a name="ln1529">	if (error == B_OK &amp;&amp; team &gt;= 0)</a>
<a name="ln1530">		error = request.AddInt32(&quot;team&quot;, team);</a>
<a name="ln1531"> </a>
<a name="ln1532">	if (error == B_OK &amp;&amp; thread &gt;= 0)</a>
<a name="ln1533">		error = request.AddInt32(&quot;thread&quot;, thread);</a>
<a name="ln1534"> </a>
<a name="ln1535">	// send the request</a>
<a name="ln1536">	BMessage reply;</a>
<a name="ln1537">	if (error == B_OK)</a>
<a name="ln1538">		error = fMessenger.SendMessage(&amp;request, &amp;reply);</a>
<a name="ln1539"> </a>
<a name="ln1540">	// evaluate the reply</a>
<a name="ln1541">	if (error == B_OK &amp;&amp; reply.what != B_REG_SUCCESS</a>
<a name="ln1542">		&amp;&amp; reply.FindInt32(&quot;error&quot;, &amp;error) != B_OK)</a>
<a name="ln1543">		error = B_ERROR;</a>
<a name="ln1544"> </a>
<a name="ln1545">	if (error == B_OK &amp;&amp; _port != NULL)</a>
<a name="ln1546">		*_port = reply.GetInt32(&quot;port&quot;, -1);</a>
<a name="ln1547"> </a>
<a name="ln1548">	return error;</a>
<a name="ln1549">}</a>
<a name="ln1550"> </a>
<a name="ln1551"> </a>
<a name="ln1552">/*!	Completes the registration process for a pre-registered application.</a>
<a name="ln1553"> </a>
<a name="ln1554">	After an application has been pre-registered via AddApplication() and</a>
<a name="ln1555">	after assigning it a team ID (via SetThreadAndTeam()) the application is</a>
<a name="ln1556">	still pre-registered and must complete the registration.</a>
<a name="ln1557"> </a>
<a name="ln1558">	\param team The app's team ID</a>
<a name="ln1559">	\param thread The app's thread ID</a>
<a name="ln1560">	\param thread The app looper port</a>
<a name="ln1561"> </a>
<a name="ln1562">	\return A status code.</a>
<a name="ln1563">	\retval B_OK Everything went fine.</a>
<a name="ln1564">	\retval B_REG_APP_NOT_PRE_REGISTERED \a team did not identify an existing</a>
<a name="ln1565">	        application or the identified application was already fully</a>
<a name="ln1566">	        registered.</a>
<a name="ln1567">*/</a>
<a name="ln1568">status_t</a>
<a name="ln1569">BRoster::_CompleteRegistration(team_id team, thread_id thread,</a>
<a name="ln1570">	port_id port) const</a>
<a name="ln1571">{</a>
<a name="ln1572">	status_t error = B_OK;</a>
<a name="ln1573"> </a>
<a name="ln1574">	// compose the request message</a>
<a name="ln1575">	BMessage request(B_REG_COMPLETE_REGISTRATION);</a>
<a name="ln1576">	if (team &gt;= 0)</a>
<a name="ln1577">		error = request.AddInt32(&quot;team&quot;, team);</a>
<a name="ln1578"> </a>
<a name="ln1579">	if (error == B_OK &amp;&amp; thread &gt;= 0)</a>
<a name="ln1580">		error = request.AddInt32(&quot;thread&quot;, thread);</a>
<a name="ln1581"> </a>
<a name="ln1582">	if (error == B_OK &amp;&amp; port &gt;= 0)</a>
<a name="ln1583">		error = request.AddInt32(&quot;port&quot;, port);</a>
<a name="ln1584"> </a>
<a name="ln1585">	// send the request</a>
<a name="ln1586">	BMessage reply;</a>
<a name="ln1587">	if (error == B_OK)</a>
<a name="ln1588">		error = fMessenger.SendMessage(&amp;request, &amp;reply);</a>
<a name="ln1589"> </a>
<a name="ln1590">	// evaluate the reply</a>
<a name="ln1591">	if (error == B_OK &amp;&amp; reply.what != B_REG_SUCCESS</a>
<a name="ln1592">		&amp;&amp; reply.FindInt32(&quot;error&quot;, &amp;error) != B_OK) {</a>
<a name="ln1593">		error = B_ERROR;</a>
<a name="ln1594">	}</a>
<a name="ln1595"> </a>
<a name="ln1596">	return error;</a>
<a name="ln1597">}</a>
<a name="ln1598"> </a>
<a name="ln1599"> </a>
<a name="ln1600">/*!	Returns whether an application is registered.</a>
<a name="ln1601"> </a>
<a name="ln1602">	If the application is indeed pre-registered and \a info is not \c NULL,</a>
<a name="ln1603">	the methods fills in the app_info structure pointed to by \a info.</a>
<a name="ln1604"> </a>
<a name="ln1605">	\param ref An entry_ref referring to the app's executable</a>
<a name="ln1606">	\param team The app's team ID. May be -1, if \a token is given.</a>
<a name="ln1607">	\param token The app's pre-registration token. May be 0, if \a team is</a>
<a name="ln1608">	       given.</a>
<a name="ln1609">	\param preRegistered: Pointer to a pre-allocated bool to be filled in</a>
<a name="ln1610">	       by this method, indicating whether or not the app was</a>
<a name="ln1611">	       pre-registered.</a>
<a name="ln1612">	\param info A pointer to a pre-allocated app_info structure to be filled</a>
<a name="ln1613">	       in by this method (may be \c NULL)</a>
<a name="ln1614"> </a>
<a name="ln1615">	\return \c B_OK, if the application is registered and all requested</a>
<a name="ln1616">	        information could be retrieved, or another error code, if the app</a>
<a name="ln1617">	        is not registered or an error occurred.</a>
<a name="ln1618">*/</a>
<a name="ln1619">status_t</a>
<a name="ln1620">BRoster::_IsAppRegistered(const entry_ref* ref, team_id team,</a>
<a name="ln1621">	uint32 token, bool* preRegistered, app_info* info) const</a>
<a name="ln1622">{</a>
<a name="ln1623">	status_t error = B_OK;</a>
<a name="ln1624"> </a>
<a name="ln1625">	// compose the request message</a>
<a name="ln1626">	BMessage request(B_REG_IS_APP_REGISTERED);</a>
<a name="ln1627">	if (ref)</a>
<a name="ln1628">		error = request.AddRef(&quot;ref&quot;, ref);</a>
<a name="ln1629">	if (error == B_OK &amp;&amp; team &gt;= 0)</a>
<a name="ln1630">		error = request.AddInt32(&quot;team&quot;, team);</a>
<a name="ln1631">	if (error == B_OK &amp;&amp; token &gt; 0)</a>
<a name="ln1632">		error = request.AddInt32(&quot;token&quot;, (int32)token);</a>
<a name="ln1633"> </a>
<a name="ln1634">	// send the request</a>
<a name="ln1635">	BMessage reply;</a>
<a name="ln1636">	if (error == B_OK)</a>
<a name="ln1637">		error = fMessenger.SendMessage(&amp;request, &amp;reply);</a>
<a name="ln1638"> </a>
<a name="ln1639">	// evaluate the reply</a>
<a name="ln1640">	bool isRegistered = false;</a>
<a name="ln1641">	bool isPreRegistered = false;</a>
<a name="ln1642">	if (error == B_OK) {</a>
<a name="ln1643">		if (reply.what == B_REG_SUCCESS) {</a>
<a name="ln1644">			if (reply.FindBool(&quot;registered&quot;, &amp;isRegistered) != B_OK</a>
<a name="ln1645">				|| !isRegistered</a>
<a name="ln1646">				|| reply.FindBool(&quot;pre-registered&quot;, &amp;isPreRegistered) != B_OK) {</a>
<a name="ln1647">				error = B_ERROR;</a>
<a name="ln1648">			}</a>
<a name="ln1649"> </a>
<a name="ln1650">			if (error == B_OK &amp;&amp; preRegistered)</a>
<a name="ln1651">				*preRegistered = isPreRegistered;</a>
<a name="ln1652">			if (error == B_OK &amp;&amp; info)</a>
<a name="ln1653">				error = find_message_app_info(&amp;reply, info);</a>
<a name="ln1654">		} else if (reply.FindInt32(&quot;error&quot;, &amp;error) != B_OK)</a>
<a name="ln1655">			error = B_ERROR;</a>
<a name="ln1656">	}</a>
<a name="ln1657"> </a>
<a name="ln1658">	return error;</a>
<a name="ln1659">}</a>
<a name="ln1660"> </a>
<a name="ln1661"> </a>
<a name="ln1662">/*!	Completely unregisters a pre-registered application.</a>
<a name="ln1663"> </a>
<a name="ln1664">	This method can only be used to unregister applications that don't have</a>
<a name="ln1665">	a team ID assigned yet. All other applications must be unregistered via</a>
<a name="ln1666">	RemoveApp().</a>
<a name="ln1667"> </a>
<a name="ln1668">	\param entryToken The token identifying the application (returned by</a>
<a name="ln1669">	       AddApplication())</a>
<a name="ln1670"> </a>
<a name="ln1671">	\return A status code.</a>
<a name="ln1672">	\retval B_OK Everything went fine.</a>
<a name="ln1673">	\retval B_REG_APP_NOT_PRE_REGISTERED The supplied token did not identify</a>
<a name="ln1674">	        a pre-registered application.</a>
<a name="ln1675">*/</a>
<a name="ln1676">status_t</a>
<a name="ln1677">BRoster::_RemovePreRegApp(uint32 entryToken) const</a>
<a name="ln1678">{</a>
<a name="ln1679">	status_t error = B_OK;</a>
<a name="ln1680"> </a>
<a name="ln1681">	// compose the request message</a>
<a name="ln1682">	BMessage request(B_REG_REMOVE_PRE_REGISTERED_APP);</a>
<a name="ln1683">	if (error == B_OK)</a>
<a name="ln1684">		error = request.AddInt32(&quot;token&quot;, (int32)entryToken);</a>
<a name="ln1685"> </a>
<a name="ln1686">	// send the request</a>
<a name="ln1687">	BMessage reply;</a>
<a name="ln1688">	if (error == B_OK)</a>
<a name="ln1689">		error = fMessenger.SendMessage(&amp;request, &amp;reply);</a>
<a name="ln1690"> </a>
<a name="ln1691">	// evaluate the reply</a>
<a name="ln1692">	if (error == B_OK &amp;&amp; reply.what != B_REG_SUCCESS</a>
<a name="ln1693">		&amp;&amp; reply.FindInt32(&quot;error&quot;, &amp;error) != B_OK) {</a>
<a name="ln1694">		error = B_ERROR;</a>
<a name="ln1695">	}</a>
<a name="ln1696"> </a>
<a name="ln1697">	return error;</a>
<a name="ln1698">}</a>
<a name="ln1699"> </a>
<a name="ln1700"> </a>
<a name="ln1701">/*!	Unregisters a (pre-)registered application.</a>
<a name="ln1702"> </a>
<a name="ln1703">	This method must be used to unregister applications that already have</a>
<a name="ln1704">	a team ID assigned, i.e. also for pre-registered application for which</a>
<a name="ln1705">	SetThreadAndTeam() has already been invoked.</a>
<a name="ln1706"> </a>
<a name="ln1707">	\param team The app's team ID</a>
<a name="ln1708"> </a>
<a name="ln1709">	\return A status code.</a>
<a name="ln1710">	\retval B_OK Everything went fine.</a>
<a name="ln1711">	\retval B_REG_APP_NOT_REGISTERED The supplied team ID does not identify a</a>
<a name="ln1712">	        (pre-)registered application.</a>
<a name="ln1713">*/</a>
<a name="ln1714">status_t</a>
<a name="ln1715">BRoster::_RemoveApp(team_id team) const</a>
<a name="ln1716">{</a>
<a name="ln1717">	status_t error = B_OK;</a>
<a name="ln1718"> </a>
<a name="ln1719">	// compose the request message</a>
<a name="ln1720">	BMessage request(B_REG_REMOVE_APP);</a>
<a name="ln1721">	if (team &gt;= 0)</a>
<a name="ln1722">		error = request.AddInt32(&quot;team&quot;, team);</a>
<a name="ln1723"> </a>
<a name="ln1724">	// send the request</a>
<a name="ln1725">	BMessage reply;</a>
<a name="ln1726">	if (error == B_OK)</a>
<a name="ln1727">		error = fMessenger.SendMessage(&amp;request, &amp;reply);</a>
<a name="ln1728"> </a>
<a name="ln1729">	// evaluate the reply</a>
<a name="ln1730">	if (error == B_OK &amp;&amp; reply.what != B_REG_SUCCESS</a>
<a name="ln1731">		&amp;&amp; reply.FindInt32(&quot;error&quot;, &amp;error) != B_OK) {</a>
<a name="ln1732">		error = B_ERROR;</a>
<a name="ln1733">	}</a>
<a name="ln1734"> </a>
<a name="ln1735">	return error;</a>
<a name="ln1736">}</a>
<a name="ln1737"> </a>
<a name="ln1738"> </a>
<a name="ln1739">void</a>
<a name="ln1740">BRoster::_ApplicationCrashed(team_id team)</a>
<a name="ln1741">{</a>
<a name="ln1742">	BPrivate::DesktopLink link;</a>
<a name="ln1743">	if (link.InitCheck() != B_OK)</a>
<a name="ln1744">		return;</a>
<a name="ln1745"> </a>
<a name="ln1746">	if (link.StartMessage(AS_APP_CRASHED) == B_OK</a>
<a name="ln1747">		&amp;&amp; link.Attach(team) == B_OK) {</a>
<a name="ln1748">		link.Flush();</a>
<a name="ln1749">	}</a>
<a name="ln1750">}</a>
<a name="ln1751"> </a>
<a name="ln1752"> </a>
<a name="ln1753">/*!	Tells the registrar which application is currently active.</a>
<a name="ln1754"> </a>
<a name="ln1755">	It's called from within the app_server when the active application is</a>
<a name="ln1756">	changed.</a>
<a name="ln1757"> </a>
<a name="ln1758">	As it's called in the event loop, it must run asynchronously and cannot</a>
<a name="ln1759">	wait for a reply.</a>
<a name="ln1760">*/</a>
<a name="ln1761">status_t</a>
<a name="ln1762">BRoster::_UpdateActiveApp(team_id team) const</a>
<a name="ln1763">{</a>
<a name="ln1764">	if (team &lt; B_OK)</a>
<a name="ln1765">		return B_BAD_TEAM_ID;</a>
<a name="ln1766"> </a>
<a name="ln1767">	// compose the request message</a>
<a name="ln1768">	BMessage request(B_REG_UPDATE_ACTIVE_APP);</a>
<a name="ln1769">	status_t status = request.AddInt32(&quot;team&quot;, team);</a>
<a name="ln1770">	if (status &lt; B_OK)</a>
<a name="ln1771">		return status;</a>
<a name="ln1772"> </a>
<a name="ln1773">	// send the request</a>
<a name="ln1774">	return fMessenger.SendMessage(&amp;request);</a>
<a name="ln1775">}</a>
<a name="ln1776"> </a>
<a name="ln1777"> </a>
<a name="ln1778">/*!	Launches the application associated with the supplied MIME type or</a>
<a name="ln1779">	the entry referred to by the supplied entry_ref.</a>
<a name="ln1780"> </a>
<a name="ln1781">	The application to be started is searched the same way FindApp() does it.</a>
<a name="ln1782"> </a>
<a name="ln1783">	At least one of \a mimeType or \a ref must not be \c NULL. If \a mimeType</a>
<a name="ln1784">	is supplied, \a ref is ignored for finding the application.</a>
<a name="ln1785"> </a>
<a name="ln1786">	If \a ref does refer to an application executable, that application is</a>
<a name="ln1787">	launched. Otherwise the respective application is searched and launched,</a>
<a name="ln1788">	and \a ref is sent to it in a \c B_REFS_RECEIVED message, unless other</a>
<a name="ln1789">	arguments are passed via \a argc and \a args -- then the entry_ref is</a>
<a name="ln1790">	converted into a path (C-string) and added to the argument vector.</a>
<a name="ln1791"> </a>
<a name="ln1792">	\a messageList contains messages to be sent to the application</a>
<a name="ln1793">	&quot;on launch&quot;, i.e. before ReadyToRun() is invoked on the BApplication</a>
<a name="ln1794">	object. The caller retains ownership of the supplied BList and the</a>
<a name="ln1795">	contained BMessages. In case the method fails with \c B_ALREADY_RUNNING</a>
<a name="ln1796">	the messages are delivered to the already running instance. The same</a>
<a name="ln1797">	applies to the \c B_REFS_RECEIVED message.</a>
<a name="ln1798"> </a>
<a name="ln1799">	The supplied \a argc and \a args are (if containing at least one argument)</a>
<a name="ln1800">	put into a \c B_ARGV_RECEIVED message and sent to the launched application</a>
<a name="ln1801">	&quot;on launch&quot;. The caller retains ownership of the supplied \a args.</a>
<a name="ln1802">	In case the method fails with \c B_ALREADY_RUNNING the message is</a>
<a name="ln1803">	delivered to the already running instance. The same applies to the</a>
<a name="ln1804">	\c B_REFS_RECEIVED message, if no arguments are supplied via \a argc and</a>
<a name="ln1805">	\args.</a>
<a name="ln1806"> </a>
<a name="ln1807">	If \a launchSuspended is set to true, the main thread of the loaded app</a>
<a name="ln1808">	(returned in \a appThread) is kept in the suspended state and not</a>
<a name="ln1809">	automatically resumed.</a>
<a name="ln1810"> </a>
<a name="ln1811">	\param mimeType MIME type for which the application shall be launched.</a>
<a name="ln1812">	       May be \c NULL.</a>
<a name="ln1813">	\param ref entry_ref referring to the file for which an application shall</a>
<a name="ln1814">	       be launched. May be \c NULL.</a>
<a name="ln1815">	\param messageList Optional list of messages to be sent to the application</a>
<a name="ln1816">	       &quot;on launch&quot;. May be \c NULL.</a>
<a name="ln1817">	\param argc Specifies the number of elements in \a args.</a>
<a name="ln1818">	\param args An array of C-strings to be sent as B_ARGV_RECEIVED messaged</a>
<a name="ln1819">	       to the launched application.</a>
<a name="ln1820">	\param appTeam Pointer to a pre-allocated team_id variable to be set to</a>
<a name="ln1821">	       the team ID of the launched application.</a>
<a name="ln1822">	\param appThread Pointer to a pre-allocated thread_id variable to</a>
<a name="ln1823">		   be set to the thread ID of the launched main thread.</a>
<a name="ln1824">	\param launchSuspended Indicates whether to keep the app thread in the</a>
<a name="ln1825">		   suspended state or resume it.</a>
<a name="ln1826"> </a>
<a name="ln1827">	\return A status code.</a>
<a name="ln1828">	\retval B_OK Everything went fine.</a>
<a name="ln1829">	\retval B_BAD_VALUE \c NULL \a mimeType</a>
<a name="ln1830">	\retval B_LAUNCH_FAILED_NO_PREFERRED_APP Neither with the supplied type</a>
<a name="ln1831">	        nor with its supertype (if the supplied isn't a supertype itself)</a>
<a name="ln1832">	        a preferred application is associated.</a>
<a name="ln1833">	\retval B_LAUNCH_FAILED_APP_NOT_FOUND The supplied type is not installed</a>
<a name="ln1834">	        or its preferred application could not be found.</a>
<a name="ln1835">	\retval B_LAUNCH_FAILED_APP_IN_TRASH The supplied type's preferred</a>
<a name="ln1836">	        application was in the trash.</a>
<a name="ln1837">	\retval B_LAUNCH_FAILED_EXECUTABLE The found application was not</a>
<a name="ln1838">	        executable.</a>
<a name="ln1839">*/</a>
<a name="ln1840">status_t</a>
<a name="ln1841">BRoster::_LaunchApp(const char* mimeType, const entry_ref* ref,</a>
<a name="ln1842">	const BList* messageList, int argc, const char* const* args,</a>
<a name="ln1843">	const char** environment, team_id* _appTeam, thread_id* _appThread,</a>
<a name="ln1844">	port_id* _appPort, uint32* _appToken, bool launchSuspended) const</a>
<a name="ln1845">{</a>
<a name="ln1846">	DBG(OUT(&quot;BRoster::_LaunchApp()&quot;));</a>
<a name="ln1847"> </a>
<a name="ln1848">	if (_appTeam != NULL) {</a>
<a name="ln1849">		// we're supposed to set _appTeam to -1 on error; we'll</a>
<a name="ln1850">		// reset it later if everything goes well</a>
<a name="ln1851">		*_appTeam = -1;</a>
<a name="ln1852">	}</a>
<a name="ln1853"> </a>
<a name="ln1854">	if (mimeType == NULL &amp;&amp; ref == NULL)</a>
<a name="ln1855">		return B_BAD_VALUE;</a>
<a name="ln1856"> </a>
<a name="ln1857">	// use a mutable copy of the document entry_ref</a>
<a name="ln1858">	entry_ref _docRef;</a>
<a name="ln1859">	entry_ref* docRef = NULL;</a>
<a name="ln1860">	if (ref != NULL) {</a>
<a name="ln1861">		_docRef = *ref;</a>
<a name="ln1862">		docRef = &amp;_docRef;</a>
<a name="ln1863">	}</a>
<a name="ln1864"> </a>
<a name="ln1865">	uint32 otherAppFlags = B_REG_DEFAULT_APP_FLAGS;</a>
<a name="ln1866">	uint32 appFlags = B_REG_DEFAULT_APP_FLAGS;</a>
<a name="ln1867">	bool alreadyRunning = false;</a>
<a name="ln1868">	bool wasDocument = true;</a>
<a name="ln1869">	status_t error = B_OK;</a>
<a name="ln1870">	ArgVector argVector;</a>
<a name="ln1871">	team_id team = -1;</a>
<a name="ln1872">	thread_id appThread = -1;</a>
<a name="ln1873">	port_id appPort = -1;</a>
<a name="ln1874">	uint32 appToken = 0;</a>
<a name="ln1875"> </a>
<a name="ln1876">	while (true) {</a>
<a name="ln1877">		// find the app</a>
<a name="ln1878">		entry_ref appRef;</a>
<a name="ln1879">		char signature[B_MIME_TYPE_LENGTH];</a>
<a name="ln1880">		error = _ResolveApp(mimeType, docRef, &amp;appRef, signature,</a>
<a name="ln1881">			&amp;appFlags, &amp;wasDocument);</a>
<a name="ln1882">		DBG(OUT(&quot;  find app: %s (%&quot; B_PRIx32 &quot;) %s \n&quot;, strerror(error), error,</a>
<a name="ln1883">			signature));</a>
<a name="ln1884">		if (error != B_OK)</a>
<a name="ln1885">			return error;</a>
<a name="ln1886"> </a>
<a name="ln1887">		// build an argument vector</a>
<a name="ln1888">		error = argVector.Init(argc, args, &amp;appRef,</a>
<a name="ln1889">			wasDocument ? docRef : NULL);</a>
<a name="ln1890">		DBG(OUT(&quot;  build argv: %s (%&quot; B_PRIx32 &quot;)\n&quot;, strerror(error), error));</a>
<a name="ln1891">		if (error != B_OK)</a>
<a name="ln1892">			return error;</a>
<a name="ln1893"> </a>
<a name="ln1894">		// pre-register the app (but ignore scipts)</a>
<a name="ln1895">		app_info appInfo;</a>
<a name="ln1896">		bool isScript = wasDocument &amp;&amp; docRef != NULL &amp;&amp; *docRef == appRef;</a>
<a name="ln1897">		if (!isScript &amp;&amp; !fNoRegistrar) {</a>
<a name="ln1898">			error = _AddApplication(signature, &amp;appRef, appFlags, -1, -1, -1,</a>
<a name="ln1899">				false, &amp;appToken, &amp;team);</a>
<a name="ln1900">			if (error == B_ALREADY_RUNNING) {</a>
<a name="ln1901">				DBG(OUT(&quot;  already running\n&quot;));</a>
<a name="ln1902">				alreadyRunning = true;</a>
<a name="ln1903"> </a>
<a name="ln1904">				// get the app flags for the running application</a>
<a name="ln1905">				error = _IsAppRegistered(&amp;appRef, team, appToken, NULL,</a>
<a name="ln1906">					&amp;appInfo);</a>
<a name="ln1907">				if (error == B_OK) {</a>
<a name="ln1908">					otherAppFlags = appInfo.flags;</a>
<a name="ln1909">					appPort = appInfo.port;</a>
<a name="ln1910">					team = appInfo.team;</a>
<a name="ln1911">				}</a>
<a name="ln1912">			}</a>
<a name="ln1913">			DBG(OUT(&quot;  pre-register: %s (%&quot; B_PRIx32 &quot;)\n&quot;, strerror(error),</a>
<a name="ln1914">				error));</a>
<a name="ln1915">		}</a>
<a name="ln1916"> </a>
<a name="ln1917">		// launch the app</a>
<a name="ln1918">		if (error == B_OK &amp;&amp; !alreadyRunning) {</a>
<a name="ln1919">			DBG(OUT(&quot;  token: %&quot; B_PRIu32 &quot;\n&quot;, appToken));</a>
<a name="ln1920">			// load the app image</a>
<a name="ln1921">			appThread = load_image(argVector.Count(),</a>
<a name="ln1922">				const_cast&lt;const char**&gt;(argVector.Args()), environment);</a>
<a name="ln1923"> </a>
<a name="ln1924">			// get the app team</a>
<a name="ln1925">			if (appThread &gt;= 0) {</a>
<a name="ln1926">				thread_info threadInfo;</a>
<a name="ln1927">				error = get_thread_info(appThread, &amp;threadInfo);</a>
<a name="ln1928">				if (error == B_OK)</a>
<a name="ln1929">					team = threadInfo.team;</a>
<a name="ln1930">			} else if (wasDocument &amp;&amp; appThread == B_NOT_AN_EXECUTABLE)</a>
<a name="ln1931">				error = B_LAUNCH_FAILED_EXECUTABLE;</a>
<a name="ln1932">			else</a>
<a name="ln1933">				error = appThread;</a>
<a name="ln1934"> </a>
<a name="ln1935">			DBG(OUT(&quot;  load image: %s (%&quot; B_PRIx32 &quot;)\n&quot;, strerror(error),</a>
<a name="ln1936">				error));</a>
<a name="ln1937">			// finish the registration</a>
<a name="ln1938">			if (error == B_OK &amp;&amp; !isScript &amp;&amp; !fNoRegistrar)</a>
<a name="ln1939">				error = _SetThreadAndTeam(appToken, appThread, team, &amp;appPort);</a>
<a name="ln1940"> </a>
<a name="ln1941">			DBG(OUT(&quot;  set thread and team: %s (%&quot; B_PRIx32 &quot;)\n&quot;,</a>
<a name="ln1942">				strerror(error), error));</a>
<a name="ln1943">			// resume the launched team</a>
<a name="ln1944">			if (error == B_OK &amp;&amp; !launchSuspended)</a>
<a name="ln1945">				error = resume_thread(appThread);</a>
<a name="ln1946"> </a>
<a name="ln1947">			DBG(OUT(&quot;  resume thread: %s (%&quot; B_PRIx32 &quot;)\n&quot;, strerror(error),</a>
<a name="ln1948">				error));</a>
<a name="ln1949">			// on error: kill the launched team and unregister the app</a>
<a name="ln1950">			if (error != B_OK) {</a>
<a name="ln1951">				if (appThread &gt;= 0)</a>
<a name="ln1952">					kill_thread(appThread);</a>
<a name="ln1953"> </a>
<a name="ln1954">				if (!isScript) {</a>
<a name="ln1955">					if (!fNoRegistrar)</a>
<a name="ln1956">						_RemovePreRegApp(appToken);</a>
<a name="ln1957"> </a>
<a name="ln1958">					if (!wasDocument) {</a>
<a name="ln1959">						// Remove app hint if it's this one</a>
<a name="ln1960">						BMimeType appType(signature);</a>
<a name="ln1961">						entry_ref hintRef;</a>
<a name="ln1962"> </a>
<a name="ln1963">						if (appType.InitCheck() == B_OK</a>
<a name="ln1964">							&amp;&amp; appType.GetAppHint(&amp;hintRef) == B_OK</a>
<a name="ln1965">							&amp;&amp; appRef == hintRef) {</a>
<a name="ln1966">							appType.SetAppHint(NULL);</a>
<a name="ln1967">							// try again</a>
<a name="ln1968">							continue;</a>
<a name="ln1969">						}</a>
<a name="ln1970">					}</a>
<a name="ln1971">				}</a>
<a name="ln1972">			}</a>
<a name="ln1973">		}</a>
<a name="ln1974">		// Don't try again</a>
<a name="ln1975">		break;</a>
<a name="ln1976">	}</a>
<a name="ln1977"> </a>
<a name="ln1978">	if (alreadyRunning &amp;&amp; current_team() == team) {</a>
<a name="ln1979">		// The target team is calling us, so we don't send it the message</a>
<a name="ln1980">		// to prevent an endless loop</a>
<a name="ln1981">		error = B_BAD_VALUE;</a>
<a name="ln1982">	}</a>
<a name="ln1983"> </a>
<a name="ln1984">	// send &quot;on launch&quot; messages</a>
<a name="ln1985">	if (error == B_OK &amp;&amp; !fNoRegistrar) {</a>
<a name="ln1986">		// If the target app is B_ARGV_ONLY, only if it is newly launched</a>
<a name="ln1987">		// messages are sent to it (namely B_ARGV_RECEIVED and B_READY_TO_RUN).</a>
<a name="ln1988">		// An already running B_ARGV_ONLY app won't get any messages.</a>
<a name="ln1989">		bool argvOnly = (appFlags &amp; B_ARGV_ONLY) != 0</a>
<a name="ln1990">			|| (alreadyRunning &amp;&amp; (otherAppFlags &amp; B_ARGV_ONLY) != 0);</a>
<a name="ln1991">		const BList* _messageList = (argvOnly ? NULL : messageList);</a>
<a name="ln1992">		// don't send ref, if it refers to the app or is included in the</a>
<a name="ln1993">		// argument vector</a>
<a name="ln1994">		const entry_ref* _ref = argvOnly || !wasDocument</a>
<a name="ln1995">			|| argVector.Count() &gt; 1 ? NULL : docRef;</a>
<a name="ln1996">		if (!(argvOnly &amp;&amp; alreadyRunning)) {</a>
<a name="ln1997">			_SendToRunning(team, argVector.Count(), argVector.Args(),</a>
<a name="ln1998">				_messageList, _ref, alreadyRunning);</a>
<a name="ln1999">		}</a>
<a name="ln2000">	}</a>
<a name="ln2001"> </a>
<a name="ln2002">	// set return values</a>
<a name="ln2003">	if (error == B_OK) {</a>
<a name="ln2004">		if (alreadyRunning)</a>
<a name="ln2005">			error = B_ALREADY_RUNNING;</a>
<a name="ln2006">		else if (_appTeam)</a>
<a name="ln2007">			*_appTeam = team;</a>
<a name="ln2008"> </a>
<a name="ln2009">		if (_appThread != NULL)</a>
<a name="ln2010">			*_appThread = appThread;</a>
<a name="ln2011">		if (_appPort != NULL)</a>
<a name="ln2012">			*_appPort = appPort;</a>
<a name="ln2013">		if (_appToken != NULL)</a>
<a name="ln2014">			*_appToken = appToken;</a>
<a name="ln2015">	}</a>
<a name="ln2016"> </a>
<a name="ln2017">	DBG(OUT(&quot;BRoster::_LaunchApp() done: %s (%&quot; B_PRIx32 &quot;)\n&quot;,</a>
<a name="ln2018">		strerror(error), error));</a>
<a name="ln2019"> </a>
<a name="ln2020">	return error;</a>
<a name="ln2021">}</a>
<a name="ln2022"> </a>
<a name="ln2023"> </a>
<a name="ln2024">void</a>
<a name="ln2025">BRoster::_SetAppFlags(team_id team, uint32 flags) const</a>
<a name="ln2026">{</a>
<a name="ln2027">}</a>
<a name="ln2028"> </a>
<a name="ln2029"> </a>
<a name="ln2030">void</a>
<a name="ln2031">BRoster::_DumpRoster() const</a>
<a name="ln2032">{</a>
<a name="ln2033">}</a>
<a name="ln2034"> </a>
<a name="ln2035"> </a>
<a name="ln2036">/*!	Finds an application associated with a MIME type or a file.</a>
<a name="ln2037"> </a>
<a name="ln2038">	It does also supply the caller with some more information about the</a>
<a name="ln2039">	application, like signature, app flags and whether the supplied</a>
<a name="ln2040">	MIME type/entry_ref already identified an application.</a>
<a name="ln2041"> </a>
<a name="ln2042">	At least one of \a inType or \a ref must not be \c NULL. If \a inType is</a>
<a name="ln2043">	supplied, \a ref is ignored.</a>
<a name="ln2044"> </a>
<a name="ln2045">	If \a ref refers to a link, it is updated with the entry_ref for the</a>
<a name="ln2046">	resolved entry.</a>
<a name="ln2047"> </a>
<a name="ln2048">	\see FindApp() for how the application is searched.</a>
<a name="ln2049"> </a>
<a name="ln2050">	\a signature is set to a string with length 0, if the found</a>
<a name="ln2051">	application has no signature.</a>
<a name="ln2052"> </a>
<a name="ln2053">	\param inType The MIME type for which an application shall be found.</a>
<a name="ln2054">	       May be \c NULL.</a>
<a name="ln2055">	\param ref The file for which an application shall be found.</a>
<a name="ln2056">	       May be \c NULL.</a>
<a name="ln2057">	\param appRef A pointer to a pre-allocated entry_ref to be filled with</a>
<a name="ln2058">	       a reference to the found application's executable. May be \c NULL.</a>
<a name="ln2059">	\param signature A pointer to a pre-allocated char buffer of at</a>
<a name="ln2060">	       least size \c B_MIME_TYPE_LENGTH to be filled with the signature of</a>
<a name="ln2061">	       the found application. May be \c NULL.</a>
<a name="ln2062">	\param appFlags A pointer to a pre-allocated uint32 variable to be filled</a>
<a name="ln2063">	       with the app flags of the found application. May be \c NULL.</a>
<a name="ln2064">	\param wasDocument A pointer to a pre-allocated bool variable to be set to</a>
<a name="ln2065">	       \c true, if the supplied file was not identifying an application,</a>
<a name="ln2066">	       to \c false otherwise. Has no meaning, if a \a inType is supplied.</a>
<a name="ln2067">	       May be \c NULL.</a>
<a name="ln2068"> </a>
<a name="ln2069">	\return A status code.</a>
<a name="ln2070">	\retval B_OK Everything went fine.</a>
<a name="ln2071">	\retval B_BAD_VALUE \c NULL \a inType and \a ref.</a>
<a name="ln2072"> </a>
<a name="ln2073">	\see FindApp() for other error codes.</a>
<a name="ln2074">*/</a>
<a name="ln2075">status_t</a>
<a name="ln2076">BRoster::_ResolveApp(const char* inType, entry_ref* ref,</a>
<a name="ln2077">	entry_ref* _appRef, char* _signature, uint32* _appFlags,</a>
<a name="ln2078">	bool* _wasDocument) const</a>
<a name="ln2079">{</a>
<a name="ln2080">	if ((inType == NULL &amp;&amp; ref == NULL)</a>
<a name="ln2081">		|| (inType != NULL &amp;&amp; strlen(inType) &gt;= B_MIME_TYPE_LENGTH))</a>
<a name="ln2082">		return B_BAD_VALUE;</a>
<a name="ln2083"> </a>
<a name="ln2084">	// find the app</a>
<a name="ln2085">	BMimeType appMeta;</a>
<a name="ln2086">	BFile appFile;</a>
<a name="ln2087">	entry_ref appRef;</a>
<a name="ln2088">	status_t error;</a>
<a name="ln2089"> </a>
<a name="ln2090">	if (inType != NULL) {</a>
<a name="ln2091">		error = _TranslateType(inType, &amp;appMeta, &amp;appRef, &amp;appFile);</a>
<a name="ln2092">		if (_wasDocument != NULL)</a>
<a name="ln2093">			*_wasDocument = !(appMeta == inType);</a>
<a name="ln2094">	} else {</a>
<a name="ln2095">		error = _TranslateRef(ref, &amp;appMeta, &amp;appRef, &amp;appFile,</a>
<a name="ln2096">			_wasDocument);</a>
<a name="ln2097">	}</a>
<a name="ln2098"> </a>
<a name="ln2099">	// create meta mime</a>
<a name="ln2100">	if (!fNoRegistrar &amp;&amp; error == B_OK) {</a>
<a name="ln2101">		BPath path;</a>
<a name="ln2102">		if (path.SetTo(&amp;appRef) == B_OK)</a>
<a name="ln2103">			create_app_meta_mime(path.Path(), false, true, false);</a>
<a name="ln2104">	}</a>
<a name="ln2105"> </a>
<a name="ln2106">	// set the app hint on the type -- but only if the file has the</a>
<a name="ln2107">	// respective signature, otherwise unset the app hint</a>
<a name="ln2108">	BAppFileInfo appFileInfo;</a>
<a name="ln2109">	if (!fNoRegistrar &amp;&amp; error == B_OK) {</a>
<a name="ln2110">		char signature[B_MIME_TYPE_LENGTH];</a>
<a name="ln2111">		if (appFileInfo.SetTo(&amp;appFile) == B_OK</a>
<a name="ln2112">			&amp;&amp; appFileInfo.GetSignature(signature) == B_OK) {</a>
<a name="ln2113">			if (!strcasecmp(appMeta.Type(), signature)) {</a>
<a name="ln2114">				// Only set the app hint if there is none yet</a>
<a name="ln2115">				entry_ref dummyRef;</a>
<a name="ln2116">				if (appMeta.GetAppHint(&amp;dummyRef) != B_OK)</a>
<a name="ln2117">					appMeta.SetAppHint(&amp;appRef);</a>
<a name="ln2118">			} else {</a>
<a name="ln2119">				appMeta.SetAppHint(NULL);</a>
<a name="ln2120">				appMeta.SetTo(signature);</a>
<a name="ln2121">			}</a>
<a name="ln2122">		} else</a>
<a name="ln2123">			appMeta.SetAppHint(NULL);</a>
<a name="ln2124">	}</a>
<a name="ln2125"> </a>
<a name="ln2126">	// set the return values</a>
<a name="ln2127">	if (error == B_OK) {</a>
<a name="ln2128">		if (_appRef)</a>
<a name="ln2129">			*_appRef = appRef;</a>
<a name="ln2130"> </a>
<a name="ln2131">		if (_signature != NULL) {</a>
<a name="ln2132">			// there's no warranty, that appMeta is valid</a>
<a name="ln2133">			if (appMeta.IsValid()) {</a>
<a name="ln2134">				strlcpy(_signature, appMeta.Type(),</a>
<a name="ln2135">					B_MIME_TYPE_LENGTH);</a>
<a name="ln2136">			} else</a>
<a name="ln2137">				_signature[0] = '\0';</a>
<a name="ln2138">		}</a>
<a name="ln2139"> </a>
<a name="ln2140">		if (_appFlags != NULL) {</a>
<a name="ln2141">			// if an error occurs here, we don't care and just set a default</a>
<a name="ln2142">			// value</a>
<a name="ln2143">			if (appFileInfo.InitCheck() != B_OK</a>
<a name="ln2144">				|| appFileInfo.GetAppFlags(_appFlags) != B_OK) {</a>
<a name="ln2145">				*_appFlags = B_REG_DEFAULT_APP_FLAGS;</a>
<a name="ln2146">			}</a>
<a name="ln2147">		}</a>
<a name="ln2148">	} else {</a>
<a name="ln2149">		// unset the ref on error</a>
<a name="ln2150">		if (_appRef != NULL)</a>
<a name="ln2151">			*_appRef = appRef;</a>
<a name="ln2152">	}</a>
<a name="ln2153"> </a>
<a name="ln2154">	return error;</a>
<a name="ln2155">}</a>
<a name="ln2156"> </a>
<a name="ln2157"> </a>
<a name="ln2158">/*!	\brief Finds an application associated with a file.</a>
<a name="ln2159"> </a>
<a name="ln2160">	\a appMeta is left unmodified, if the file is executable, but has no</a>
<a name="ln2161">	signature.</a>
<a name="ln2162"> </a>
<a name="ln2163">	\see FindApp() for how the application is searched.</a>
<a name="ln2164"> </a>
<a name="ln2165">	If \a ref refers to a link, it is updated with the entry_ref for the</a>
<a name="ln2166">	resolved entry.</a>
<a name="ln2167"> </a>
<a name="ln2168">	\param ref The file for which an application shall be found.</a>
<a name="ln2169">	\param appMeta A pointer to a pre-allocated BMimeType to be set to the</a>
<a name="ln2170">	       signature of the found application.</a>
<a name="ln2171">	\param appRef A pointer to a pre-allocated entry_ref to be filled with</a>
<a name="ln2172">	       a reference to the found application's executable.</a>
<a name="ln2173">	\param appFile A pointer to a pre-allocated BFile to be set to the</a>
<a name="ln2174">	       executable of the found application.</a>
<a name="ln2175">	\param wasDocument A pointer to a pre-allocated bool variable to be set to</a>
<a name="ln2176">	       \c true, if the supplied file was not identifying an application,</a>
<a name="ln2177">	       to \c false otherwise. May be \c NULL.</a>
<a name="ln2178"> </a>
<a name="ln2179">	\return A status code.</a>
<a name="ln2180">	\retval B_OK: Everything went fine.</a>
<a name="ln2181">	\retval B_BAD_VALUE: \c NULL \a ref, \a appMeta, \a appRef or \a appFile.</a>
<a name="ln2182"> </a>
<a name="ln2183">	\see FindApp() for other error codes.</a>
<a name="ln2184">*/</a>
<a name="ln2185">status_t</a>
<a name="ln2186">BRoster::_TranslateRef(entry_ref* ref, BMimeType* appMeta,</a>
<a name="ln2187">	entry_ref* appRef, BFile* appFile, bool* _wasDocument) const</a>
<a name="ln2188">{</a>
<a name="ln2189">	if (ref == NULL || appMeta == NULL || appRef == NULL || appFile == NULL)</a>
<a name="ln2190">		return B_BAD_VALUE;</a>
<a name="ln2191"> </a>
<a name="ln2192">	// resolve ref, if necessary</a>
<a name="ln2193">	BEntry entry;</a>
<a name="ln2194">	status_t error = entry.SetTo(ref, false);</a>
<a name="ln2195">	if (error != B_OK)</a>
<a name="ln2196">		return error;</a>
<a name="ln2197"> </a>
<a name="ln2198">	if (entry.IsSymLink()) {</a>
<a name="ln2199">		// ref refers to a link</a>
<a name="ln2200">		if (entry.SetTo(ref, true) != B_OK || entry.GetRef(ref) != B_OK)</a>
<a name="ln2201">			return B_LAUNCH_FAILED_NO_RESOLVE_LINK;</a>
<a name="ln2202">	}</a>
<a name="ln2203"> </a>
<a name="ln2204">	// init node</a>
<a name="ln2205">	BNode node;</a>
<a name="ln2206">	error = node.SetTo(ref);</a>
<a name="ln2207">	if (error != B_OK)</a>
<a name="ln2208">		return error;</a>
<a name="ln2209"> </a>
<a name="ln2210">	// get permissions</a>
<a name="ln2211">	mode_t permissions;</a>
<a name="ln2212">	error = node.GetPermissions(&amp;permissions);</a>
<a name="ln2213">	if (error != B_OK)</a>
<a name="ln2214">		return error;</a>
<a name="ln2215"> </a>
<a name="ln2216">	if ((permissions &amp; S_IXUSR) != 0 &amp;&amp; node.IsFile()) {</a>
<a name="ln2217">		// node is executable and a file</a>
<a name="ln2218">		error = appFile-&gt;SetTo(ref, B_READ_ONLY);</a>
<a name="ln2219">		if (error != B_OK)</a>
<a name="ln2220">			return error;</a>
<a name="ln2221"> </a>
<a name="ln2222">		// get the app's signature via a BAppFileInfo</a>
<a name="ln2223">		BAppFileInfo appFileInfo;</a>
<a name="ln2224">		error = appFileInfo.SetTo(appFile);</a>
<a name="ln2225">		if (error != B_OK)</a>
<a name="ln2226">			return error;</a>
<a name="ln2227"> </a>
<a name="ln2228">		// don't worry, if the file doesn't have a signature, just</a>
<a name="ln2229">		// unset the supplied object</a>
<a name="ln2230">		char type[B_MIME_TYPE_LENGTH];</a>
<a name="ln2231">		if (appFileInfo.GetSignature(type) == B_OK) {</a>
<a name="ln2232">			error = appMeta-&gt;SetTo(type);</a>
<a name="ln2233">			if (error != B_OK)</a>
<a name="ln2234">				return error;</a>
<a name="ln2235">		} else</a>
<a name="ln2236">			appMeta-&gt;Unset();</a>
<a name="ln2237"> </a>
<a name="ln2238">		// If the file type indicates that the file is an application, we've</a>
<a name="ln2239">		// definitely got what we're looking for.</a>
<a name="ln2240">		bool isDocument = true;</a>
<a name="ln2241">		if (_GetFileType(ref, &amp;appFileInfo, type) == B_OK</a>
<a name="ln2242">			&amp;&amp; strcasecmp(type, B_APP_MIME_TYPE) == 0) {</a>
<a name="ln2243">			isDocument = false;</a>
<a name="ln2244">		}</a>
<a name="ln2245"> </a>
<a name="ln2246">		// If our file is not an application executable, we probably have a</a>
<a name="ln2247">		// script. Check whether the file has a preferred application set. If</a>
<a name="ln2248">		// so, we fall through and use the preferred app instead. Otherwise</a>
<a name="ln2249">		// we're done.</a>
<a name="ln2250">		char preferredApp[B_MIME_TYPE_LENGTH];</a>
<a name="ln2251">		if (!isDocument || appFileInfo.GetPreferredApp(preferredApp) != B_OK) {</a>
<a name="ln2252">			*appRef = *ref;</a>
<a name="ln2253">			if (_wasDocument != NULL)</a>
<a name="ln2254">				*_wasDocument = isDocument;</a>
<a name="ln2255"> </a>
<a name="ln2256">			return B_OK;</a>
<a name="ln2257">		}</a>
<a name="ln2258"> </a>
<a name="ln2259">		// Executable file, but not an application, and it has a preferred</a>
<a name="ln2260">		// application set. Fall through...</a>
<a name="ln2261">	}</a>
<a name="ln2262"> </a>
<a name="ln2263">	// the node is not exectuable or not a file</a>
<a name="ln2264">	// init a node info</a>
<a name="ln2265">	BNodeInfo nodeInfo;</a>
<a name="ln2266">	error = nodeInfo.SetTo(&amp;node);</a>
<a name="ln2267">	if (error != B_OK)</a>
<a name="ln2268">		return error;</a>
<a name="ln2269"> </a>
<a name="ln2270">	// if the file has a preferred app, let _TranslateType() find</a>
<a name="ln2271">	// it for us</a>
<a name="ln2272">	char preferredApp[B_MIME_TYPE_LENGTH];</a>
<a name="ln2273">	if (nodeInfo.GetPreferredApp(preferredApp) == B_OK</a>
<a name="ln2274">		&amp;&amp; _TranslateType(preferredApp, appMeta, appRef, appFile) == B_OK) {</a>
<a name="ln2275">		if (_wasDocument != NULL)</a>
<a name="ln2276">			*_wasDocument = true;</a>
<a name="ln2277"> </a>
<a name="ln2278">		return B_OK;</a>
<a name="ln2279">	}</a>
<a name="ln2280"> </a>
<a name="ln2281">	// no preferred app or existing one was not found -- we</a>
<a name="ln2282">	// need to get the file's type</a>
<a name="ln2283"> </a>
<a name="ln2284">	// get the type from the file</a>
<a name="ln2285">	char fileType[B_MIME_TYPE_LENGTH];</a>
<a name="ln2286">	error = _GetFileType(ref, &amp;nodeInfo, fileType);</a>
<a name="ln2287">	if (error != B_OK)</a>
<a name="ln2288">		return error;</a>
<a name="ln2289"> </a>
<a name="ln2290">	// now let _TranslateType() do the actual work</a>
<a name="ln2291">	error = _TranslateType(fileType, appMeta, appRef, appFile);</a>
<a name="ln2292">	if (error != B_OK)</a>
<a name="ln2293">		return error;</a>
<a name="ln2294"> </a>
<a name="ln2295">	if (_wasDocument != NULL)</a>
<a name="ln2296">		*_wasDocument = true;</a>
<a name="ln2297"> </a>
<a name="ln2298">	return B_OK;</a>
<a name="ln2299">}</a>
<a name="ln2300"> </a>
<a name="ln2301"> </a>
<a name="ln2302">/*!	Finds an application associated with a MIME type.</a>
<a name="ln2303"> </a>
<a name="ln2304">	\see FindApp() for how the application is searched.</a>
<a name="ln2305"> </a>
<a name="ln2306">	\param mimeType The MIME type for which an application shall be found.</a>
<a name="ln2307">	\param appMeta A pointer to a pre-allocated BMimeType to be set to the</a>
<a name="ln2308">	       signature of the found application.</a>
<a name="ln2309">	\param appRef A pointer to a pre-allocated entry_ref to be filled with</a>
<a name="ln2310">	       a reference to the found application's executable.</a>
<a name="ln2311">	\param appFile A pointer to a pre-allocated BFile to be set to the</a>
<a name="ln2312">	       executable of the found application.</a>
<a name="ln2313"> </a>
<a name="ln2314">	\return A status code.</a>
<a name="ln2315">	\retval B_OK Everything went fine.</a>
<a name="ln2316">	\retval B_BAD_VALUE \c NULL \a mimeType, \a appMeta, \a appRef or</a>
<a name="ln2317">	        \a appFile.</a>
<a name="ln2318"> </a>
<a name="ln2319">	\see FindApp() for other error codes.</a>
<a name="ln2320">*/</a>
<a name="ln2321">status_t</a>
<a name="ln2322">BRoster::_TranslateType(const char* mimeType, BMimeType* appMeta,</a>
<a name="ln2323">	entry_ref* appRef, BFile* appFile) const</a>
<a name="ln2324">{</a>
<a name="ln2325">	if (mimeType == NULL || appMeta == NULL || appRef == NULL</a>
<a name="ln2326">		|| appFile == NULL || strlen(mimeType) &gt;= B_MIME_TYPE_LENGTH) {</a>
<a name="ln2327">		return B_BAD_VALUE;</a>
<a name="ln2328">	}</a>
<a name="ln2329"> </a>
<a name="ln2330">	// Create a BMimeType and check, if the type is installed.</a>
<a name="ln2331">	BMimeType type;</a>
<a name="ln2332">	status_t error = type.SetTo(mimeType);</a>
<a name="ln2333"> </a>
<a name="ln2334">	// Get the preferred apps from the sub and super type.</a>
<a name="ln2335">	char primarySignature[B_MIME_TYPE_LENGTH];</a>
<a name="ln2336">	char secondarySignature[B_MIME_TYPE_LENGTH];</a>
<a name="ln2337">	primarySignature[0] = '\0';</a>
<a name="ln2338">	secondarySignature[0] = '\0';</a>
<a name="ln2339"> </a>
<a name="ln2340">	if (error == B_OK) {</a>
<a name="ln2341">		BMimeType superType;</a>
<a name="ln2342">		if (type.GetSupertype(&amp;superType) == B_OK)</a>
<a name="ln2343">			superType.GetPreferredApp(secondarySignature);</a>
<a name="ln2344">		if (type.IsInstalled()) {</a>
<a name="ln2345">			if (type.GetPreferredApp(primarySignature) != B_OK) {</a>
<a name="ln2346">				// The type is installed, but has no preferred app.</a>
<a name="ln2347">				primarySignature[0] = '\0';</a>
<a name="ln2348">			} else if (!strcmp(primarySignature, secondarySignature)) {</a>
<a name="ln2349">				// Both types have the same preferred app, there is</a>
<a name="ln2350">				// no point in testing it twice.</a>
<a name="ln2351">				secondarySignature[0] = '\0';</a>
<a name="ln2352">			}</a>
<a name="ln2353">		} else {</a>
<a name="ln2354">			// The type is not installed. We assume it is an app signature.</a>
<a name="ln2355">			strlcpy(primarySignature, mimeType, sizeof(primarySignature));</a>
<a name="ln2356">		}</a>
<a name="ln2357">	}</a>
<a name="ln2358"> </a>
<a name="ln2359">	// We will use this BMessage &quot;signatures&quot; to hold all supporting apps</a>
<a name="ln2360">	// so we can iterator over them in the preferred order. We include</a>
<a name="ln2361">	// the supporting apps in such a way that the configured preferred</a>
<a name="ln2362">	// applications for the MIME type are in front of other supporting</a>
<a name="ln2363">	// applications for the sub and the super type respectively.</a>
<a name="ln2364">	const char* kSigField = &quot;applications&quot;;</a>
<a name="ln2365">	BMessage signatures;</a>
<a name="ln2366">	bool addedSecondarySignature = false;</a>
<a name="ln2367">	if (error == B_OK) {</a>
<a name="ln2368">		if (primarySignature[0] != '\0')</a>
<a name="ln2369">			error = signatures.AddString(kSigField, primarySignature);</a>
<a name="ln2370">		else {</a>
<a name="ln2371">			// If there is a preferred app configured for the super type,</a>
<a name="ln2372">			// but no preferred type for the sub-type, add the preferred</a>
<a name="ln2373">			// super type handler in front of any other handlers. This way</a>
<a name="ln2374">			// we fall-back to non-preferred but supporting apps only in the</a>
<a name="ln2375">			// case when there is a preferred handler for the sub-type but</a>
<a name="ln2376">			// it cannot be resolved (misconfiguration).</a>
<a name="ln2377">			if (secondarySignature[0] != '\0') {</a>
<a name="ln2378">				error = signatures.AddString(kSigField, secondarySignature);</a>
<a name="ln2379">				addedSecondarySignature = true;</a>
<a name="ln2380">			}</a>
<a name="ln2381">		}</a>
<a name="ln2382">	}</a>
<a name="ln2383"> </a>
<a name="ln2384">	BMessage supportingSignatures;</a>
<a name="ln2385">	if (error == B_OK</a>
<a name="ln2386">		&amp;&amp; type.GetSupportingApps(&amp;supportingSignatures) == B_OK) {</a>
<a name="ln2387">		int32 subCount;</a>
<a name="ln2388">		if (supportingSignatures.FindInt32(&quot;be:sub&quot;, &amp;subCount) != B_OK)</a>
<a name="ln2389">			subCount = 0;</a>
<a name="ln2390">		// Add all signatures with direct support for the sub-type.</a>
<a name="ln2391">		const char* supportingType;</a>
<a name="ln2392">		if (!addedSecondarySignature) {</a>
<a name="ln2393">			// Try to add the secondarySignature in front of all other</a>
<a name="ln2394">			// supporting apps, if we find it among those.</a>
<a name="ln2395">			for (int32 i = 0; error == B_OK &amp;&amp; i &lt; subCount</a>
<a name="ln2396">					&amp;&amp; supportingSignatures.FindString(kSigField, i,</a>
<a name="ln2397">						&amp;supportingType) == B_OK; i++) {</a>
<a name="ln2398">				if (strcmp(primarySignature, supportingType) != 0</a>
<a name="ln2399">					&amp;&amp; strcmp(secondarySignature, supportingType) == 0) {</a>
<a name="ln2400">					error = signatures.AddString(kSigField, supportingType);</a>
<a name="ln2401">					addedSecondarySignature = true;</a>
<a name="ln2402">					break;</a>
<a name="ln2403">				}</a>
<a name="ln2404">			}</a>
<a name="ln2405">		}</a>
<a name="ln2406"> </a>
<a name="ln2407">		for (int32 i = 0; error == B_OK &amp;&amp; i &lt; subCount</a>
<a name="ln2408">				&amp;&amp; supportingSignatures.FindString(kSigField, i,</a>
<a name="ln2409">					&amp;supportingType) == B_OK; i++) {</a>
<a name="ln2410">			if (strcmp(primarySignature, supportingType) != 0</a>
<a name="ln2411">				&amp;&amp; strcmp(secondarySignature, supportingType) != 0) {</a>
<a name="ln2412">				error = signatures.AddString(kSigField, supportingType);</a>
<a name="ln2413">			}</a>
<a name="ln2414">		}</a>
<a name="ln2415"> </a>
<a name="ln2416">		// Add the preferred type of the super type here before adding</a>
<a name="ln2417">		// the other types supporting the super type, but only if we have</a>
<a name="ln2418">		// not already added it in case there was no preferred app for the</a>
<a name="ln2419">		// sub-type configured.</a>
<a name="ln2420">		if (error == B_OK &amp;&amp; !addedSecondarySignature</a>
<a name="ln2421">			&amp;&amp; secondarySignature[0] != '\0') {</a>
<a name="ln2422">			error = signatures.AddString(kSigField, secondarySignature);</a>
<a name="ln2423">		}</a>
<a name="ln2424"> </a>
<a name="ln2425">		// Add all signatures with support for the super-type.</a>
<a name="ln2426">		for (int32 i = subCount; error == B_OK</a>
<a name="ln2427">				&amp;&amp; supportingSignatures.FindString(kSigField, i,</a>
<a name="ln2428">					&amp;supportingType) == B_OK; i++) {</a>
<a name="ln2429">			// Don't add the signature if it's one of the preferred apps</a>
<a name="ln2430">			// already.</a>
<a name="ln2431">			if (strcmp(primarySignature, supportingType) != 0</a>
<a name="ln2432">				&amp;&amp; strcmp(secondarySignature, supportingType) != 0) {</a>
<a name="ln2433">				error = signatures.AddString(kSigField, supportingType);</a>
<a name="ln2434">			}</a>
<a name="ln2435">		}</a>
<a name="ln2436">	} else {</a>
<a name="ln2437">		// Failed to get supporting apps, just add the preferred apps.</a>
<a name="ln2438">		if (error == B_OK &amp;&amp; secondarySignature[0] != '\0')</a>
<a name="ln2439">			error = signatures.AddString(kSigField, secondarySignature);</a>
<a name="ln2440">	}</a>
<a name="ln2441"> </a>
<a name="ln2442">	if (error != B_OK)</a>
<a name="ln2443">		return error;</a>
<a name="ln2444"> </a>
<a name="ln2445">	// Set an error in case we can't resolve a single supporting app.</a>
<a name="ln2446">	error = B_LAUNCH_FAILED_NO_PREFERRED_APP;</a>
<a name="ln2447"> </a>
<a name="ln2448">	// See if we can find a good application that is valid from the messege.</a>
<a name="ln2449">	const char* signature;</a>
<a name="ln2450">	for (int32 i = 0;</a>
<a name="ln2451">		signatures.FindString(kSigField, i, &amp;signature) == B_OK; i++) {</a>
<a name="ln2452">		if (signature[0] == '\0')</a>
<a name="ln2453">			continue;</a>
<a name="ln2454"> </a>
<a name="ln2455">		error = appMeta-&gt;SetTo(signature);</a>
<a name="ln2456"> </a>
<a name="ln2457">		// Check, whether the signature is installed and has an app hint</a>
<a name="ln2458">		bool appFound = false;</a>
<a name="ln2459">		if (error == B_OK &amp;&amp; appMeta-&gt;GetAppHint(appRef) == B_OK) {</a>
<a name="ln2460">			// Resolve symbolic links, if necessary</a>
<a name="ln2461">			BEntry entry;</a>
<a name="ln2462">			if (entry.SetTo(appRef, true) == B_OK &amp;&amp; entry.IsFile()</a>
<a name="ln2463">				&amp;&amp; entry.GetRef(appRef) == B_OK) {</a>
<a name="ln2464">				appFound = true;</a>
<a name="ln2465">			} else {</a>
<a name="ln2466">				// Bad app hint -- remove it</a>
<a name="ln2467">				appMeta-&gt;SetAppHint(NULL);</a>
<a name="ln2468">			}</a>
<a name="ln2469">		}</a>
<a name="ln2470"> </a>
<a name="ln2471">		// In case there is no app hint or it is invalid, we need to query for</a>
<a name="ln2472">		// the app.</a>
<a name="ln2473">		if (error == B_OK &amp;&amp; !appFound)</a>
<a name="ln2474">			error = query_for_app(appMeta-&gt;Type(), appRef);</a>
<a name="ln2475"> </a>
<a name="ln2476">		if (error == B_OK)</a>
<a name="ln2477">			error = appFile-&gt;SetTo(appRef, B_READ_ONLY);</a>
<a name="ln2478"> </a>
<a name="ln2479">		// check, whether the app can be used</a>
<a name="ln2480">		if (error == B_OK)</a>
<a name="ln2481">			error = can_app_be_used(appRef);</a>
<a name="ln2482"> </a>
<a name="ln2483">		if (error == B_OK)</a>
<a name="ln2484">			break;</a>
<a name="ln2485">	}</a>
<a name="ln2486"> </a>
<a name="ln2487">	return error;</a>
<a name="ln2488">}</a>
<a name="ln2489"> </a>
<a name="ln2490"> </a>
<a name="ln2491">/*!	Gets the type of a file either from the node info or by sniffing.</a>
<a name="ln2492"> </a>
<a name="ln2493">	The method first tries to get the file type from the supplied node info. If</a>
<a name="ln2494">	that didn't work, the given entry ref is sniffed.</a>
<a name="ln2495"> </a>
<a name="ln2496">	\param file An entry_ref referring to the file in question.</a>
<a name="ln2497">	\param nodeInfo A BNodeInfo initialized to the file.</a>
<a name="ln2498">	\param mimeType A pointer to a pre-allocated char buffer of at least size</a>
<a name="ln2499">	       \c B_MIME_TYPE_LENGTH to be filled with the MIME type sniffed for</a>
<a name="ln2500">	       the file.</a>
<a name="ln2501"> </a>
<a name="ln2502">	\return A status code.</a>
<a name="ln2503">	\retval B_OK Everything went fine.</a>
<a name="ln2504">	\retval B_BAD_VALUE \c NULL \a file, \a nodeInfo or \a mimeType.</a>
<a name="ln2505">*/</a>
<a name="ln2506">status_t</a>
<a name="ln2507">BRoster::_GetFileType(const entry_ref* file, BNodeInfo* nodeInfo,</a>
<a name="ln2508">	char* mimeType) const</a>
<a name="ln2509">{</a>
<a name="ln2510">	// first try the node info</a>
<a name="ln2511">	if (nodeInfo-&gt;GetType(mimeType) == B_OK)</a>
<a name="ln2512">		return B_OK;</a>
<a name="ln2513"> </a>
<a name="ln2514">	if (fNoRegistrar)</a>
<a name="ln2515">		return B_NO_INIT;</a>
<a name="ln2516"> </a>
<a name="ln2517">	// Try to update the file's MIME info and just read the updated type.</a>
<a name="ln2518">	// If that fails, sniff manually.</a>
<a name="ln2519">	BPath path;</a>
<a name="ln2520">	if (path.SetTo(file) != B_OK</a>
<a name="ln2521">		|| update_mime_info(path.Path(), false, true, false) != B_OK</a>
<a name="ln2522">		|| nodeInfo-&gt;GetType(mimeType) != B_OK) {</a>
<a name="ln2523">		BMimeType type;</a>
<a name="ln2524">		status_t error = BMimeType::GuessMimeType(file, &amp;type);</a>
<a name="ln2525">		if (error != B_OK)</a>
<a name="ln2526">			return error;</a>
<a name="ln2527"> </a>
<a name="ln2528">		if (!type.IsValid())</a>
<a name="ln2529">			return B_BAD_VALUE;</a>
<a name="ln2530"> </a>
<a name="ln2531">		strlcpy(mimeType, type.Type(), B_MIME_TYPE_LENGTH);</a>
<a name="ln2532">	}</a>
<a name="ln2533"> </a>
<a name="ln2534">	return B_OK;</a>
<a name="ln2535">}</a>
<a name="ln2536"> </a>
<a name="ln2537"> </a>
<a name="ln2538">/*!	Sends messages to a running team.</a>
<a name="ln2539"> </a>
<a name="ln2540">	In particular those messages are \c B_ARGV_RECEIVED, \c B_REFS_RECEIVED,</a>
<a name="ln2541">	\c B_READY_TO_RUN and other, arbitrary, ones.</a>
<a name="ln2542"> </a>
<a name="ln2543">	If \a messageList is not \c NULL or empty, those messages are sent first,</a>
<a name="ln2544">	then follow \c B_ARGV_RECEIVED, \c B_REFS_RECEIVED and finally</a>
<a name="ln2545">	\c B_READ_TO_RUN.</a>
<a name="ln2546"> </a>
<a name="ln2547">	\c B_ARGV_RECEIVED is sent only, if \a args is not \c NULL and contains</a>
<a name="ln2548">	more than one element. \c B_REFS_RECEIVED is sent only, if \a ref is not</a>
<a name="ln2549">	\c NULL.</a>
<a name="ln2550"> </a>
<a name="ln2551">	The ownership of all supplied objects retains to the caller.</a>
<a name="ln2552"> </a>
<a name="ln2553">	\param team The team ID of the target application.</a>
<a name="ln2554">	\param argc Number of elements in \a args.</a>
<a name="ln2555">	\param args Argument vector to be sent to the target. May be \c NULL.</a>
<a name="ln2556">	\param messageList List of BMessages to be sent to the target. May be</a>
<a name="ln2557">	       \c NULL or empty.</a>
<a name="ln2558">	\param ref entry_ref to be sent to the target. May be \c NULL.</a>
<a name="ln2559">	\param alreadyRunning \c true, if the target app is not newly launched,</a>
<a name="ln2560">	       but was already running, \c false otherwise (a \c B_READY_TO_RUN</a>
<a name="ln2561">	       message will be sent in this case).</a>
<a name="ln2562"> </a>
<a name="ln2563">	\return \c B_OK if everything went fine, or an error code otherwise.</a>
<a name="ln2564">*/</a>
<a name="ln2565">status_t</a>
<a name="ln2566">BRoster::_SendToRunning(team_id team, int argc, const char* const* args,</a>
<a name="ln2567">	const BList* messageList, const entry_ref* ref,</a>
<a name="ln2568">	bool alreadyRunning) const</a>
<a name="ln2569">{</a>
<a name="ln2570">	status_t error = B_OK;</a>
<a name="ln2571"> </a>
<a name="ln2572">	// Construct a messenger to the app: We can't use the public constructor,</a>
<a name="ln2573">	// since the target application may be B_ARGV_ONLY.</a>
<a name="ln2574">	app_info info;</a>
<a name="ln2575">	error = GetRunningAppInfo(team, &amp;info);</a>
<a name="ln2576">	if (error == B_OK) {</a>
<a name="ln2577">		BMessenger messenger;</a>
<a name="ln2578">		BMessenger::Private(messenger).SetTo(team, info.port,</a>
<a name="ln2579">			B_PREFERRED_TOKEN);</a>
<a name="ln2580"> </a>
<a name="ln2581">		// send messages from the list</a>
<a name="ln2582">		if (messageList != NULL) {</a>
<a name="ln2583">			for (int32 i = 0;</a>
<a name="ln2584">					BMessage* message = (BMessage*)messageList-&gt;ItemAt(i);</a>
<a name="ln2585">					i++) {</a>
<a name="ln2586">				messenger.SendMessage(message);</a>
<a name="ln2587">			}</a>
<a name="ln2588">		}</a>
<a name="ln2589"> </a>
<a name="ln2590">		// send B_ARGV_RECEIVED or B_REFS_RECEIVED or B_SILENT_RELAUNCH</a>
<a name="ln2591">		// (if already running)</a>
<a name="ln2592">		if (args != NULL &amp;&amp; argc &gt; 1) {</a>
<a name="ln2593">			BMessage message(B_ARGV_RECEIVED);</a>
<a name="ln2594">			message.AddInt32(&quot;argc&quot;, argc);</a>
<a name="ln2595">			for (int32 i = 0; i &lt; argc; i++)</a>
<a name="ln2596">				message.AddString(&quot;argv&quot;, args[i]);</a>
<a name="ln2597"> </a>
<a name="ln2598">			// also add current working directory</a>
<a name="ln2599">			char cwd[B_PATH_NAME_LENGTH];</a>
<a name="ln2600">			if (getcwd(cwd, B_PATH_NAME_LENGTH) != NULL)</a>
<a name="ln2601">				message.AddString(&quot;cwd&quot;, cwd);</a>
<a name="ln2602"> </a>
<a name="ln2603">			messenger.SendMessage(&amp;message);</a>
<a name="ln2604">		} else if (ref != NULL) {</a>
<a name="ln2605">			DBG(OUT(&quot;_SendToRunning : B_REFS_RECEIVED\n&quot;));</a>
<a name="ln2606">			BMessage message(B_REFS_RECEIVED);</a>
<a name="ln2607">			message.AddRef(&quot;refs&quot;, ref);</a>
<a name="ln2608">			messenger.SendMessage(&amp;message);</a>
<a name="ln2609">		} else if (alreadyRunning &amp;&amp; (!messageList || messageList-&gt;IsEmpty()))</a>
<a name="ln2610">			messenger.SendMessage(B_SILENT_RELAUNCH);</a>
<a name="ln2611"> </a>
<a name="ln2612">		if (!alreadyRunning) {</a>
<a name="ln2613">			// send B_READY_TO_RUN</a>
<a name="ln2614">			DBG(OUT(&quot;_SendToRunning : B_READY_TO_RUN\n&quot;));</a>
<a name="ln2615">			messenger.SendMessage(B_READY_TO_RUN);</a>
<a name="ln2616">		}</a>
<a name="ln2617">	}</a>
<a name="ln2618"> </a>
<a name="ln2619">	return error;</a>
<a name="ln2620">}</a>
<a name="ln2621"> </a>
<a name="ln2622"> </a>
<a name="ln2623">/*!	Allows to use certain functionality of the BRoster class without</a>
<a name="ln2624">	accessing the registrar.</a>
<a name="ln2625">*/</a>
<a name="ln2626">void</a>
<a name="ln2627">BRoster::_SetWithoutRegistrar(bool noRegistrar)</a>
<a name="ln2628">{</a>
<a name="ln2629">	fNoRegistrar = noRegistrar;</a>
<a name="ln2630">}</a>
<a name="ln2631"> </a>
<a name="ln2632"> </a>
<a name="ln2633">void</a>
<a name="ln2634">BRoster::_InitMessenger()</a>
<a name="ln2635">{</a>
<a name="ln2636">	DBG(OUT(&quot;BRoster::InitMessengers()\n&quot;));</a>
<a name="ln2637"> </a>
<a name="ln2638">	// find the registrar port</a>
<a name="ln2639"> </a>
<a name="ln2640">#ifndef HAIKU_TARGET_PLATFORM_LIBBE_TEST</a>
<a name="ln2641">	BMessage data;</a>
<a name="ln2642">	if (BLaunchRoster().GetData(B_REGISTRAR_SIGNATURE, data) == B_OK) {</a>
<a name="ln2643">		port_id port = data.GetInt32(&quot;port&quot;, -1);</a>
<a name="ln2644">		team_id team = data.GetInt32(&quot;team&quot;, -1);</a>
<a name="ln2645"> </a>
<a name="ln2646">		if (port &gt;= 0 &amp;&amp; team != current_team()) {</a>
<a name="ln2647">			// Make sure we aren't the registrar ourselves.</a>
<a name="ln2648"> </a>
<a name="ln2649">			DBG(OUT(&quot;  found roster port\n&quot;));</a>
<a name="ln2650"> </a>
<a name="ln2651">			BMessenger::Private(fMessenger).SetTo(team, port,</a>
<a name="ln2652">				B_PREFERRED_TOKEN);</a>
<a name="ln2653">		}</a>
<a name="ln2654">	}</a>
<a name="ln2655">#else</a>
<a name="ln2656">	port_id rosterPort = find_port(B_REGISTRAR_PORT_NAME);</a>
<a name="ln2657">	port_info info;</a>
<a name="ln2658">	if (rosterPort &gt;= 0 &amp;&amp; get_port_info(rosterPort, &amp;info) == B_OK) {</a>
<a name="ln2659">		DBG(OUT(&quot;  found roster port\n&quot;));</a>
<a name="ln2660"> </a>
<a name="ln2661">		BMessenger::Private(fMessenger).SetTo(info.team, rosterPort,</a>
<a name="ln2662">			B_PREFERRED_TOKEN);</a>
<a name="ln2663">	}</a>
<a name="ln2664">#endif</a>
<a name="ln2665"> </a>
<a name="ln2666">	DBG(OUT(&quot;BRoster::InitMessengers() done\n&quot;));</a>
<a name="ln2667">}</a>
<a name="ln2668"> </a>
<a name="ln2669"> </a>
<a name="ln2670">/*static*/ status_t</a>
<a name="ln2671">BRoster::_InitMimeMessenger(void* data)</a>
<a name="ln2672">{</a>
<a name="ln2673">	BRoster* roster = (BRoster*)data;</a>
<a name="ln2674"> </a>
<a name="ln2675">	// ask for the MIME messenger</a>
<a name="ln2676">	// Generous 1s + 5s timeouts. It could actually be synchronous, but</a>
<a name="ln2677">	// timeouts allow us to debug the registrar main thread.</a>
<a name="ln2678">	BMessage request(B_REG_GET_MIME_MESSENGER);</a>
<a name="ln2679">	BMessage reply;</a>
<a name="ln2680">	status_t error = roster-&gt;fMessenger.SendMessage(&amp;request, &amp;reply,</a>
<a name="ln2681">		1000000LL, 5000000LL);</a>
<a name="ln2682">	if (error == B_OK &amp;&amp; reply.what == B_REG_SUCCESS) {</a>
<a name="ln2683">		DBG(OUT(&quot;  got reply from roster\n&quot;));</a>
<a name="ln2684">			reply.FindMessenger(&quot;messenger&quot;, &amp;roster-&gt;fMimeMessenger);</a>
<a name="ln2685">	} else {</a>
<a name="ln2686">		DBG(OUT(&quot;  no (useful) reply from roster: error: %&quot; B_PRIx32 &quot;: %s\n&quot;,</a>
<a name="ln2687">			error, strerror(error)));</a>
<a name="ln2688">		if (error == B_OK)</a>
<a name="ln2689">			DBG(reply.PrintToStream());</a>
<a name="ln2690">	}</a>
<a name="ln2691"> </a>
<a name="ln2692">	return error;</a>
<a name="ln2693">}</a>
<a name="ln2694"> </a>
<a name="ln2695"> </a>
<a name="ln2696">BMessenger&amp;</a>
<a name="ln2697">BRoster::_MimeMessenger()</a>
<a name="ln2698">{</a>
<a name="ln2699">	__init_once(&amp;fMimeMessengerInitOnce, &amp;_InitMimeMessenger, this);</a>
<a name="ln2700">	return fMimeMessenger;</a>
<a name="ln2701">}</a>
<a name="ln2702"> </a>
<a name="ln2703"> </a>
<a name="ln2704">/*!	Sends a request to the roster to add the application with the</a>
<a name="ln2705">	given signature to the front of the recent apps list.</a>
<a name="ln2706">*/</a>
<a name="ln2707">void</a>
<a name="ln2708">BRoster::_AddToRecentApps(const char* signature) const</a>
<a name="ln2709">{</a>
<a name="ln2710">	status_t error = B_OK;</a>
<a name="ln2711">	// compose the request message</a>
<a name="ln2712">	BMessage request(B_REG_ADD_TO_RECENT_APPS);</a>
<a name="ln2713">	if (error == B_OK)</a>
<a name="ln2714">		error = request.AddString(&quot;app sig&quot;, signature);</a>
<a name="ln2715"> </a>
<a name="ln2716">	// send the request</a>
<a name="ln2717">	BMessage reply;</a>
<a name="ln2718">	if (error == B_OK)</a>
<a name="ln2719">		error = fMessenger.SendMessage(&amp;request, &amp;reply);</a>
<a name="ln2720"> </a>
<a name="ln2721">	// evaluate the reply</a>
<a name="ln2722">	status_t result;</a>
<a name="ln2723">	if (error == B_OK) {</a>
<a name="ln2724">		error = reply.what == B_REG_RESULT</a>
<a name="ln2725">			? (status_t)B_OK : (status_t)B_BAD_REPLY;</a>
<a name="ln2726">	}</a>
<a name="ln2727"> </a>
<a name="ln2728">	if (error == B_OK)</a>
<a name="ln2729">		error = reply.FindInt32(&quot;result&quot;, &amp;result);</a>
<a name="ln2730"> </a>
<a name="ln2731">	if (error == B_OK)</a>
<a name="ln2732">		error = result;</a>
<a name="ln2733"> </a>
<a name="ln2734">	// Nothing to return... how sad :-(</a>
<a name="ln2735">	//return error;</a>
<a name="ln2736">}</a>
<a name="ln2737"> </a>
<a name="ln2738"> </a>
<a name="ln2739">//!	Sends a request to the roster to clear the recent documents list.</a>
<a name="ln2740">void</a>
<a name="ln2741">BRoster::_ClearRecentDocuments() const</a>
<a name="ln2742">{</a>
<a name="ln2743">	BMessage request(B_REG_CLEAR_RECENT_DOCUMENTS);</a>
<a name="ln2744">	BMessage reply;</a>
<a name="ln2745">	fMessenger.SendMessage(&amp;request, &amp;reply);</a>
<a name="ln2746">}</a>
<a name="ln2747"> </a>
<a name="ln2748"> </a>
<a name="ln2749">//!	Sends a request to the roster to clear the recent documents list.</a>
<a name="ln2750">void</a>
<a name="ln2751">BRoster::_ClearRecentFolders() const</a>
<a name="ln2752">{</a>
<a name="ln2753">	BMessage request(B_REG_CLEAR_RECENT_FOLDERS);</a>
<a name="ln2754">	BMessage reply;</a>
<a name="ln2755">	fMessenger.SendMessage(&amp;request, &amp;reply);</a>
<a name="ln2756">}</a>
<a name="ln2757"> </a>
<a name="ln2758"> </a>
<a name="ln2759">//! \brief Sends a request to the roster to clear the recent documents list.</a>
<a name="ln2760">void</a>
<a name="ln2761">BRoster::_ClearRecentApps() const</a>
<a name="ln2762">{</a>
<a name="ln2763">	BMessage request(B_REG_CLEAR_RECENT_APPS);</a>
<a name="ln2764">	BMessage reply;</a>
<a name="ln2765">	fMessenger.SendMessage(&amp;request, &amp;reply);</a>
<a name="ln2766">}</a>
<a name="ln2767"> </a>
<a name="ln2768"> </a>
<a name="ln2769">/*!	Loads the system's recently used document, folder, and</a>
<a name="ln2770">	application lists from the specified file.</a>
<a name="ln2771"> </a>
<a name="ln2772">	\note The current lists are cleared before loading the new lists</a>
<a name="ln2773"> </a>
<a name="ln2774">	\param filename The name of the file to load from</a>
<a name="ln2775">*/</a>
<a name="ln2776">void</a>
<a name="ln2777">BRoster::_LoadRecentLists(const char* filename) const</a>
<a name="ln2778">{</a>
<a name="ln2779">	status_t error = B_OK;</a>
<a name="ln2780"> </a>
<a name="ln2781">	// compose the request message</a>
<a name="ln2782">	BMessage request(B_REG_LOAD_RECENT_LISTS);</a>
<a name="ln2783">	if (error == B_OK)</a>
<a name="ln2784">		error = request.AddString(&quot;filename&quot;, filename);</a>
<a name="ln2785"> </a>
<a name="ln2786">	// send the request</a>
<a name="ln2787">	BMessage reply;</a>
<a name="ln2788">	if (error == B_OK)</a>
<a name="ln2789">		error = fMessenger.SendMessage(&amp;request, &amp;reply);</a>
<a name="ln2790"> </a>
<a name="ln2791">	// evaluate the reply</a>
<a name="ln2792">	status_t result;</a>
<a name="ln2793">	if (error == B_OK) {</a>
<a name="ln2794">		error = reply.what == B_REG_RESULT</a>
<a name="ln2795">			? (status_t)B_OK : (status_t)B_BAD_REPLY;</a>
<a name="ln2796">	}</a>
<a name="ln2797">	if (error == B_OK)</a>
<a name="ln2798">		error = reply.FindInt32(&quot;result&quot;, &amp;result);</a>
<a name="ln2799"> </a>
<a name="ln2800">	if (error == B_OK)</a>
<a name="ln2801">		error = result;</a>
<a name="ln2802"> </a>
<a name="ln2803">	// Nothing to return... how sad :-(</a>
<a name="ln2804">	//return error;</a>
<a name="ln2805">}</a>
<a name="ln2806"> </a>
<a name="ln2807"> </a>
<a name="ln2808">/*!	Saves the system's recently used document, folder, and</a>
<a name="ln2809">	application lists to the specified file.</a>
<a name="ln2810"> </a>
<a name="ln2811">	\param filename The name of the file to save to</a>
<a name="ln2812">*/</a>
<a name="ln2813">void</a>
<a name="ln2814">BRoster::_SaveRecentLists(const char* filename) const</a>
<a name="ln2815">{</a>
<a name="ln2816">	status_t error = B_OK;</a>
<a name="ln2817"> </a>
<a name="ln2818">	// compose the request message</a>
<a name="ln2819">	BMessage request(B_REG_SAVE_RECENT_LISTS);</a>
<a name="ln2820">	if (error == B_OK)</a>
<a name="ln2821">		error = request.AddString(&quot;filename&quot;, filename);</a>
<a name="ln2822"> </a>
<a name="ln2823">	// send the request</a>
<a name="ln2824">	BMessage reply;</a>
<a name="ln2825">	if (error == B_OK)</a>
<a name="ln2826">		error = fMessenger.SendMessage(&amp;request, &amp;reply);</a>
<a name="ln2827"> </a>
<a name="ln2828">	// evaluate the reply</a>
<a name="ln2829">	status_t result;</a>
<a name="ln2830">	if (error == B_OK) {</a>
<a name="ln2831">		error = reply.what == B_REG_RESULT</a>
<a name="ln2832">			? (status_t)B_OK : (status_t)B_BAD_REPLY;</a>
<a name="ln2833">	}</a>
<a name="ln2834">	if (error == B_OK)</a>
<a name="ln2835">		error = reply.FindInt32(&quot;result&quot;, &amp;result);</a>
<a name="ln2836"> </a>
<a name="ln2837">	if (error == B_OK)</a>
<a name="ln2838">		error = result;</a>
<a name="ln2839"> </a>
<a name="ln2840">	// Nothing to return... how sad :-(</a>
<a name="ln2841">	//return error;</a>
<a name="ln2842">}</a>

</code></pre>
<div class="balloon" rel="866"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'error == ((int) 0)' is always true.</p></div>
<div class="balloon" rel="1322"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'error == ((int) 0)' is always true.</p></div>
<div class="balloon" rel="1526"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'error == ((int) 0)' is always true.</p></div>
<div class="balloon" rel="1683"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'error == ((int) 0)' is always true.</p></div>
<div class="balloon" rel="2783"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'error == ((int) 0)' is always true.</p></div>
<div class="balloon" rel="2820"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'error == ((int) 0)' is always true.</p></div>
<div class="balloon" rel="841"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'error == ((int) 0)' is always true.</p></div>
<div class="balloon" rel="2713"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'error == ((int) 0)' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
