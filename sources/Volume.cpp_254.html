
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>Volume.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2009-2014, Ingo Weinhold, ingo_weinhold@gmx.de.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> */</a>
<a name="ln5"> </a>
<a name="ln6"> </a>
<a name="ln7">#include &quot;Volume.h&quot;</a>
<a name="ln8"> </a>
<a name="ln9">#include &lt;dirent.h&gt;</a>
<a name="ln10">#include &lt;errno.h&gt;</a>
<a name="ln11">#include &lt;fcntl.h&gt;</a>
<a name="ln12">#include &lt;string.h&gt;</a>
<a name="ln13">#include &lt;sys/param.h&gt;</a>
<a name="ln14">#include &lt;sys/stat.h&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;new&gt;</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;AppDefs.h&gt;</a>
<a name="ln19">#include &lt;driver_settings.h&gt;</a>
<a name="ln20">#include &lt;KernelExport.h&gt;</a>
<a name="ln21">#include &lt;NodeMonitor.h&gt;</a>
<a name="ln22">#include &lt;package/PackageInfoAttributes.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &lt;AutoDeleter.h&gt;</a>
<a name="ln25">#include &lt;PackagesDirectoryDefs.h&gt;</a>
<a name="ln26"> </a>
<a name="ln27">#include &lt;vfs.h&gt;</a>
<a name="ln28"> </a>
<a name="ln29">#include &quot;AttributeIndex.h&quot;</a>
<a name="ln30">#include &quot;DebugSupport.h&quot;</a>
<a name="ln31">#include &quot;kernel_interface.h&quot;</a>
<a name="ln32">#include &quot;LastModifiedIndex.h&quot;</a>
<a name="ln33">#include &quot;NameIndex.h&quot;</a>
<a name="ln34">#include &quot;OldUnpackingNodeAttributes.h&quot;</a>
<a name="ln35">#include &quot;PackageFSRoot.h&quot;</a>
<a name="ln36">#include &quot;PackageLinkDirectory.h&quot;</a>
<a name="ln37">#include &quot;PackageLinksDirectory.h&quot;</a>
<a name="ln38">#include &quot;Resolvable.h&quot;</a>
<a name="ln39">#include &quot;SizeIndex.h&quot;</a>
<a name="ln40">#include &quot;UnpackingLeafNode.h&quot;</a>
<a name="ln41">#include &quot;UnpackingDirectory.h&quot;</a>
<a name="ln42">#include &quot;Utils.h&quot;</a>
<a name="ln43">#include &quot;Version.h&quot;</a>
<a name="ln44"> </a>
<a name="ln45"> </a>
<a name="ln46">// node ID of the root directory</a>
<a name="ln47">static const ino_t kRootDirectoryID = 1;</a>
<a name="ln48"> </a>
<a name="ln49">static const uint32 kAllStatFields = B_STAT_MODE | B_STAT_UID | B_STAT_GID</a>
<a name="ln50">	| B_STAT_SIZE | B_STAT_ACCESS_TIME | B_STAT_MODIFICATION_TIME</a>
<a name="ln51">	| B_STAT_CREATION_TIME | B_STAT_CHANGE_TIME;</a>
<a name="ln52"> </a>
<a name="ln53">// shine-through directories</a>
<a name="ln54">const char* const kShineThroughDirectories[] = {</a>
<a name="ln55">	&quot;cache&quot;, &quot;non-packaged&quot;, &quot;packages&quot;, &quot;settings&quot;, &quot;var&quot;, NULL</a>
<a name="ln56">};</a>
<a name="ln57"> </a>
<a name="ln58">// sanity limit for activation change request</a>
<a name="ln59">const size_t kMaxActivationRequestSize = 10 * 1024 * 1024;</a>
<a name="ln60"> </a>
<a name="ln61">// sanity limit for activation file size</a>
<a name="ln62">const size_t kMaxActivationFileSize = 10 * 1024 * 1024;</a>
<a name="ln63"> </a>
<a name="ln64">static const char* const kAdministrativeDirectoryName</a>
<a name="ln65">	= PACKAGES_DIRECTORY_ADMIN_DIRECTORY;</a>
<a name="ln66">static const char* const kActivationFileName</a>
<a name="ln67">	= PACKAGES_DIRECTORY_ACTIVATION_FILE;</a>
<a name="ln68">static const char* const kActivationFilePath</a>
<a name="ln69">	= PACKAGES_DIRECTORY_ADMIN_DIRECTORY &quot;/&quot;</a>
<a name="ln70">		PACKAGES_DIRECTORY_ACTIVATION_FILE;</a>
<a name="ln71"> </a>
<a name="ln72"> </a>
<a name="ln73">// #pragma mark - ShineThroughDirectory</a>
<a name="ln74"> </a>
<a name="ln75"> </a>
<a name="ln76">struct Volume::ShineThroughDirectory : public Directory {</a>
<a name="ln77">	ShineThroughDirectory(ino_t id)</a>
<a name="ln78">		:</a>
<a name="ln79">		Directory(id)</a>
<a name="ln80">	{</a>
<a name="ln81">		get_real_time(fModifiedTime);</a>
<a name="ln82">	}</a>
<a name="ln83"> </a>
<a name="ln84">	virtual timespec ModifiedTime() const</a>
<a name="ln85">	{</a>
<a name="ln86">		return fModifiedTime;</a>
<a name="ln87">	}</a>
<a name="ln88"> </a>
<a name="ln89">private:</a>
<a name="ln90">	timespec	fModifiedTime;</a>
<a name="ln91">};</a>
<a name="ln92"> </a>
<a name="ln93"> </a>
<a name="ln94">// #pragma mark - ActivationChangeRequest</a>
<a name="ln95"> </a>
<a name="ln96"> </a>
<a name="ln97">struct Volume::ActivationChangeRequest {</a>
<a name="ln98">public:</a>
<a name="ln99">	ActivationChangeRequest()</a>
<a name="ln100">		:</a>
<a name="ln101">		fRequest(NULL),</a>
<a name="ln102">		fRequestSize(0)</a>
<a name="ln103">	{</a>
<a name="ln104">	}</a>
<a name="ln105"> </a>
<a name="ln106">	~ActivationChangeRequest()</a>
<a name="ln107">	{</a>
<a name="ln108">		free(fRequest);</a>
<a name="ln109">	}</a>
<a name="ln110"> </a>
<a name="ln111">	status_t Init(const void* userRequest, size_t requestSize)</a>
<a name="ln112">	{</a>
<a name="ln113">		// copy request to kernel</a>
<a name="ln114">		if (requestSize &gt; kMaxActivationRequestSize)</a>
<a name="ln115">			RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln116"> </a>
<a name="ln117">		fRequest = (PackageFSActivationChangeRequest*)malloc(requestSize);</a>
<a name="ln118">		if (fRequest == NULL)</a>
<a name="ln119">			RETURN_ERROR(B_NO_MEMORY);</a>
<a name="ln120">		fRequestSize = requestSize;</a>
<a name="ln121"> </a>
<a name="ln122">		status_t error = user_memcpy(fRequest, userRequest, fRequestSize);</a>
<a name="ln123">		if (error != B_OK)</a>
<a name="ln124">			RETURN_ERROR(error);</a>
<a name="ln125"> </a>
<a name="ln126">		uint32 itemCount = fRequest-&gt;itemCount;</a>
<a name="ln127">		const char* requestEnd = (const char*)fRequest + requestSize;</a>
<a name="ln128">		if (&amp;fRequest-&gt;items[itemCount] &gt; (void*)requestEnd)</a>
<a name="ln129">			RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln130"> </a>
<a name="ln131">		// adjust the item name pointers and check their validity</a>
<a name="ln132">		addr_t nameDelta = (addr_t)fRequest - (addr_t)userRequest;</a>
<a name="ln133">		for (uint32 i = 0; i &lt; itemCount; i++) {</a>
<a name="ln134">			PackageFSActivationChangeItem&amp; item = fRequest-&gt;items[i];</a>
<a name="ln135">			item.name += nameDelta;</a>
<a name="ln136">			if (item.name &lt; (char*)fRequest || item.name &gt;= requestEnd)</a>
<a name="ln137">				RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln138">			size_t maxNameSize = requestEnd - item.name;</a>
<a name="ln139">			if (strnlen(item.name, maxNameSize) == maxNameSize)</a>
<a name="ln140">				RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln141">		}</a>
<a name="ln142"> </a>
<a name="ln143">		return B_OK;</a>
<a name="ln144">	}</a>
<a name="ln145"> </a>
<a name="ln146">	uint32 CountItems() const</a>
<a name="ln147">	{</a>
<a name="ln148">		return fRequest-&gt;itemCount;</a>
<a name="ln149">	}</a>
<a name="ln150"> </a>
<a name="ln151">	PackageFSActivationChangeItem* ItemAt(uint32 index) const</a>
<a name="ln152">	{</a>
<a name="ln153">		return index &lt; CountItems() ? &amp;fRequest-&gt;items[index] : NULL;</a>
<a name="ln154">	}</a>
<a name="ln155"> </a>
<a name="ln156">private:</a>
<a name="ln157">	PackageFSActivationChangeRequest*	fRequest;</a>
<a name="ln158">	size_t								fRequestSize;</a>
<a name="ln159">};</a>
<a name="ln160"> </a>
<a name="ln161"> </a>
<a name="ln162">// #pragma mark - Volume</a>
<a name="ln163"> </a>
<a name="ln164"> </a>
<a name="ln165">Volume::Volume(fs_volume* fsVolume)</a>
<a name="ln166">	:</a>
<a name="ln167">	fFSVolume(fsVolume),</a>
<a name="ln168">	fRootDirectory(NULL),</a>
<a name="ln169">	fPackageFSRoot(NULL),</a>
<a name="ln170">	fPackagesDirectory(NULL),</a>
<a name="ln171">	fPackagesDirectories(),</a>
<a name="ln172">	fPackagesDirectoriesByNodeRef(),</a>
<a name="ln173">	fPackageSettings(),</a>
<a name="ln174">	fNextNodeID(kRootDirectoryID + 1)</a>
<a name="ln175">{</a>
<a name="ln176">	rw_lock_init(&amp;fLock, &quot;packagefs volume&quot;);</a>
<a name="ln177">}</a>
<a name="ln178"> </a>
<a name="ln179"> </a>
<a name="ln180">Volume::~Volume()</a>
<a name="ln181">{</a>
<a name="ln182">	// remove the packages from the node tree</a>
<a name="ln183">	{</a>
<a name="ln184">		VolumeWriteLocker systemVolumeLocker(_SystemVolumeIfNotSelf());</a>
<a name="ln185">		VolumeWriteLocker volumeLocker(this);</a>
<a name="ln186">		for (PackageFileNameHashTable::Iterator it = fPackages.GetIterator();</a>
<a name="ln187">			Package* package = it.Next();) {</a>
<a name="ln188">			_RemovePackageContent(package, NULL, false);</a>
<a name="ln189">		}</a>
<a name="ln190">	}</a>
<a name="ln191"> </a>
<a name="ln192">	// delete the packages</a>
<a name="ln193">	_RemoveAllPackages();</a>
<a name="ln194"> </a>
<a name="ln195">	// delete all indices</a>
<a name="ln196">	Index* index = fIndices.Clear(true);</a>
<a name="ln197">	while (index != NULL) {</a>
<a name="ln198">		Index* next = index-&gt;IndexHashLink();</a>
<a name="ln199">		delete index;</a>
<a name="ln200">		index = next;</a>
<a name="ln201">	}</a>
<a name="ln202"> </a>
<a name="ln203">	// remove all nodes from the ID hash table</a>
<a name="ln204">	Node* node = fNodes.Clear(true);</a>
<a name="ln205">	while (node != NULL) {</a>
<a name="ln206">		Node* next = node-&gt;IDHashTableNext();</a>
<a name="ln207">		node-&gt;ReleaseReference();</a>
<a name="ln208">		node = next;</a>
<a name="ln209">	}</a>
<a name="ln210"> </a>
<a name="ln211">	if (fPackageFSRoot != NULL) {</a>
<a name="ln212">		if (this == fPackageFSRoot-&gt;SystemVolume())</a>
<a name="ln213">			_RemovePackageLinksDirectory();</a>
<a name="ln214"> </a>
<a name="ln215">		fPackageFSRoot-&gt;UnregisterVolume(this);</a>
<a name="ln216">	}</a>
<a name="ln217"> </a>
<a name="ln218">	if (fRootDirectory != NULL)</a>
<a name="ln219">		fRootDirectory-&gt;ReleaseReference();</a>
<a name="ln220"> </a>
<a name="ln221">	while (PackagesDirectory* directory = fPackagesDirectories.RemoveHead())</a>
<a name="ln222">		directory-&gt;ReleaseReference();</a>
<a name="ln223"> </a>
<a name="ln224">	rw_lock_destroy(&amp;fLock);</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227"> </a>
<a name="ln228">status_t</a>
<a name="ln229">Volume::Mount(const char* parameterString)</a>
<a name="ln230">{</a>
<a name="ln231">	// init the hash tables</a>
<a name="ln232">	status_t error = fPackagesDirectoriesByNodeRef.Init();</a>
<a name="ln233">	if (error != B_OK)</a>
<a name="ln234">		RETURN_ERROR(error);</a>
<a name="ln235"> </a>
<a name="ln236">	error = fNodes.Init();</a>
<a name="ln237">	if (error != B_OK)</a>
<a name="ln238">		RETURN_ERROR(error);</a>
<a name="ln239"> </a>
<a name="ln240">	error = fNodeListeners.Init();</a>
<a name="ln241">	if (error != B_OK)</a>
<a name="ln242">		RETURN_ERROR(error);</a>
<a name="ln243"> </a>
<a name="ln244">	error = fPackages.Init();</a>
<a name="ln245">	if (error != B_OK)</a>
<a name="ln246">		RETURN_ERROR(error);</a>
<a name="ln247"> </a>
<a name="ln248">	error = fIndices.Init();</a>
<a name="ln249">	if (error != B_OK)</a>
<a name="ln250">		RETURN_ERROR(error);</a>
<a name="ln251"> </a>
<a name="ln252">	// create the name index</a>
<a name="ln253">	{</a>
<a name="ln254">		NameIndex* index = new(std::nothrow) NameIndex;</a>
<a name="ln255">		if (index == NULL)</a>
<a name="ln256">			RETURN_ERROR(B_NO_MEMORY);</a>
<a name="ln257"> </a>
<a name="ln258">		error = index-&gt;Init(this);</a>
<a name="ln259">		if (error != B_OK) {</a>
<a name="ln260">			delete index;</a>
<a name="ln261">			RETURN_ERROR(error);</a>
<a name="ln262">		}</a>
<a name="ln263"> </a>
<a name="ln264">		fIndices.Insert(index);</a>
<a name="ln265">	}</a>
<a name="ln266"> </a>
<a name="ln267">	// create the size index</a>
<a name="ln268">	{</a>
<a name="ln269">		SizeIndex* index = new(std::nothrow) SizeIndex;</a>
<a name="ln270">		if (index == NULL)</a>
<a name="ln271">			RETURN_ERROR(B_NO_MEMORY);</a>
<a name="ln272"> </a>
<a name="ln273">		error = index-&gt;Init(this);</a>
<a name="ln274">		if (error != B_OK) {</a>
<a name="ln275">			delete index;</a>
<a name="ln276">			RETURN_ERROR(error);</a>
<a name="ln277">		}</a>
<a name="ln278"> </a>
<a name="ln279">		fIndices.Insert(index);</a>
<a name="ln280">	}</a>
<a name="ln281"> </a>
<a name="ln282">	// create the last modified index</a>
<a name="ln283">	{</a>
<a name="ln284">		LastModifiedIndex* index = new(std::nothrow) LastModifiedIndex;</a>
<a name="ln285">		if (index == NULL)</a>
<a name="ln286">			RETURN_ERROR(B_NO_MEMORY);</a>
<a name="ln287"> </a>
<a name="ln288">		error = index-&gt;Init(this);</a>
<a name="ln289">		if (error != B_OK) {</a>
<a name="ln290">			delete index;</a>
<a name="ln291">			RETURN_ERROR(error);</a>
<a name="ln292">		}</a>
<a name="ln293"> </a>
<a name="ln294">		fIndices.Insert(index);</a>
<a name="ln295">	}</a>
<a name="ln296"> </a>
<a name="ln297">	// create a BEOS:APP_SIG index</a>
<a name="ln298">	{</a>
<a name="ln299">		AttributeIndex* index = new(std::nothrow) AttributeIndex;</a>
<a name="ln300">		if (index == NULL)</a>
<a name="ln301">			RETURN_ERROR(B_NO_MEMORY);</a>
<a name="ln302"> </a>
<a name="ln303">		error = index-&gt;Init(this, &quot;BEOS:APP_SIG&quot;, B_MIME_STRING_TYPE, 0);</a>
<a name="ln304">		if (error != B_OK) {</a>
<a name="ln305">			delete index;</a>
<a name="ln306">			RETURN_ERROR(error);</a>
<a name="ln307">		}</a>
<a name="ln308"> </a>
<a name="ln309">		fIndices.Insert(index);</a>
<a name="ln310">	}</a>
<a name="ln311"> </a>
<a name="ln312">	// get the mount parameters</a>
<a name="ln313">	const char* packages = NULL;</a>
<a name="ln314">	const char* volumeName = NULL;</a>
<a name="ln315">	const char* mountType = NULL;</a>
<a name="ln316">	const char* shineThrough = NULL;</a>
<a name="ln317">	const char* packagesState = NULL;</a>
<a name="ln318"> </a>
<a name="ln319">	void* parameterHandle = parse_driver_settings_string(parameterString);</a>
<a name="ln320">	if (parameterHandle != NULL) {</a>
<a name="ln321">		packages = get_driver_parameter(parameterHandle, &quot;packages&quot;, NULL,</a>
<a name="ln322">			NULL);</a>
<a name="ln323">		volumeName = get_driver_parameter(parameterHandle, &quot;volume-name&quot;, NULL,</a>
<a name="ln324">			NULL);</a>
<a name="ln325">		mountType = get_driver_parameter(parameterHandle, &quot;type&quot;, NULL, NULL);</a>
<a name="ln326">		shineThrough = get_driver_parameter(parameterHandle, &quot;shine-through&quot;,</a>
<a name="ln327">			NULL, NULL);</a>
<a name="ln328">		packagesState = get_driver_parameter(parameterHandle, &quot;state&quot;, NULL,</a>
<a name="ln329">			NULL);</a>
<a name="ln330">	}</a>
<a name="ln331"> </a>
<a name="ln332">	CObjectDeleter&lt;void, status_t&gt; parameterHandleDeleter(parameterHandle,</a>
<a name="ln333">		&amp;delete_driver_settings);</a>
<a name="ln334"> </a>
<a name="ln335">	if (packages != NULL &amp;&amp; packages[0] == '\0') {</a>
<a name="ln336">		FATAL(&quot;invalid package folder ('packages' parameter)!\n&quot;);</a>
<a name="ln337">		RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln338">	}</a>
<a name="ln339"> </a>
<a name="ln340">	error = _InitMountType(mountType);</a>
<a name="ln341">	if (error != B_OK) {</a>
<a name="ln342">		FATAL(&quot;invalid mount type: \&quot;%s\&quot;\n&quot;, mountType);</a>
<a name="ln343">		RETURN_ERROR(error);</a>
<a name="ln344">	}</a>
<a name="ln345"> </a>
<a name="ln346">	// get our mount point</a>
<a name="ln347">	error = vfs_get_mount_point(fFSVolume-&gt;id, &amp;fMountPoint.deviceID,</a>
<a name="ln348">		&amp;fMountPoint.nodeID);</a>
<a name="ln349">	if (error != B_OK)</a>
<a name="ln350">		RETURN_ERROR(error);</a>
<a name="ln351"> </a>
<a name="ln352">	// load package settings</a>
<a name="ln353">	error = fPackageSettings.Load(fMountPoint.deviceID, fMountPoint.nodeID,</a>
<a name="ln354">		fMountType);</a>
<a name="ln355">	// abort only in case of serious issues (memory shortage)</a>
<a name="ln356">	if (error == B_NO_MEMORY)</a>
<a name="ln357">		RETURN_ERROR(error);</a>
<a name="ln358"> </a>
<a name="ln359">	// create package domain</a>
<a name="ln360">	fPackagesDirectory = new(std::nothrow) PackagesDirectory;</a>
<a name="ln361">	if (fPackagesDirectory == NULL)</a>
<a name="ln362">		RETURN_ERROR(B_NO_MEMORY);</a>
<a name="ln363">	fPackagesDirectories.Add(fPackagesDirectory);</a>
<a name="ln364">	fPackagesDirectoriesByNodeRef.Insert(fPackagesDirectory);</a>
<a name="ln365"> </a>
<a name="ln366">	struct stat st;</a>
<a name="ln367">	error = fPackagesDirectory-&gt;Init(packages, fMountPoint.deviceID,</a>
<a name="ln368">		fMountPoint.nodeID, st);</a>
<a name="ln369">	if (error != B_OK)</a>
<a name="ln370">		RETURN_ERROR(error);</a>
<a name="ln371"> </a>
<a name="ln372">	// If a packages state has been specified, load the needed states.</a>
<a name="ln373">	if (packagesState != NULL) {</a>
<a name="ln374">		error = _LoadOldPackagesStates(packagesState);</a>
<a name="ln375">		if (error != B_OK)</a>
<a name="ln376">			RETURN_ERROR(error);</a>
<a name="ln377">	}</a>
<a name="ln378"> </a>
<a name="ln379">	// If no volume name is given, infer it from the mount type.</a>
<a name="ln380">	if (volumeName == NULL) {</a>
<a name="ln381">		switch (fMountType) {</a>
<a name="ln382">			case PACKAGE_FS_MOUNT_TYPE_SYSTEM:</a>
<a name="ln383">				volumeName = &quot;system&quot;;</a>
<a name="ln384">				break;</a>
<a name="ln385">			case PACKAGE_FS_MOUNT_TYPE_HOME:</a>
<a name="ln386">				volumeName = &quot;config&quot;;</a>
<a name="ln387">				break;</a>
<a name="ln388">			case PACKAGE_FS_MOUNT_TYPE_CUSTOM:</a>
<a name="ln389">			default:</a>
<a name="ln390">				volumeName = &quot;Package FS&quot;;</a>
<a name="ln391">				break;</a>
<a name="ln392">		}</a>
<a name="ln393">	}</a>
<a name="ln394"> </a>
<a name="ln395">	String volumeNameString;</a>
<a name="ln396">	if (!volumeNameString.SetTo(volumeName))</a>
<a name="ln397">		RETURN_ERROR(B_NO_MEMORY);</a>
<a name="ln398"> </a>
<a name="ln399">	// create the root node</a>
<a name="ln400">	fRootDirectory</a>
<a name="ln401">		= new(std::nothrow) ::RootDirectory(kRootDirectoryID, st.st_mtim);</a>
<a name="ln402">	if (fRootDirectory == NULL)</a>
<a name="ln403">		RETURN_ERROR(B_NO_MEMORY);</a>
<a name="ln404">	fRootDirectory-&gt;Init(NULL, volumeNameString);</a>
<a name="ln405">	fNodes.Insert(fRootDirectory);</a>
<a name="ln406">	fRootDirectory-&gt;AcquireReference();</a>
<a name="ln407">		// one reference for the table</a>
<a name="ln408"> </a>
<a name="ln409">	// register with packagefs root</a>
<a name="ln410">	error = ::PackageFSRoot::RegisterVolume(this);</a>
<a name="ln411">	if (error != B_OK)</a>
<a name="ln412">		RETURN_ERROR(error);</a>
<a name="ln413"> </a>
<a name="ln414">	if (this == fPackageFSRoot-&gt;SystemVolume()) {</a>
<a name="ln415">		error = _AddPackageLinksDirectory();</a>
<a name="ln416">		if (error != B_OK)</a>
<a name="ln417">			RETURN_ERROR(error);</a>
<a name="ln418">	}</a>
<a name="ln419"> </a>
<a name="ln420">	// create shine-through directories</a>
<a name="ln421">	error = _CreateShineThroughDirectories(shineThrough);</a>
<a name="ln422">	if (error != B_OK)</a>
<a name="ln423">		RETURN_ERROR(error);</a>
<a name="ln424"> </a>
<a name="ln425">	// add initial packages</a>
<a name="ln426">	error = _AddInitialPackages();</a>
<a name="ln427">	if (error != B_OK)</a>
<a name="ln428">		RETURN_ERROR(error);</a>
<a name="ln429"> </a>
<a name="ln430">	// publish the root node</a>
<a name="ln431">	fRootDirectory-&gt;AcquireReference();</a>
<a name="ln432">	error = PublishVNode(fRootDirectory);</a>
<a name="ln433">	if (error != B_OK) {</a>
<a name="ln434">		fRootDirectory-&gt;ReleaseReference();</a>
<a name="ln435">		RETURN_ERROR(error);</a>
<a name="ln436">	}</a>
<a name="ln437"> </a>
<a name="ln438">	// bind and publish the shine-through directories</a>
<a name="ln439">	error = _PublishShineThroughDirectories();</a>
<a name="ln440">	if (error != B_OK)</a>
<a name="ln441">		RETURN_ERROR(error);</a>
<a name="ln442"> </a>
<a name="ln443">	StringPool::DumpUsageStatistics();</a>
<a name="ln444"> </a>
<a name="ln445">	return B_OK;</a>
<a name="ln446">}</a>
<a name="ln447"> </a>
<a name="ln448"> </a>
<a name="ln449">void</a>
<a name="ln450">Volume::Unmount()</a>
<a name="ln451">{</a>
<a name="ln452">}</a>
<a name="ln453"> </a>
<a name="ln454"> </a>
<a name="ln455">status_t</a>
<a name="ln456">Volume::IOCtl(Node* node, uint32 operation, void* buffer, size_t size)</a>
<a name="ln457">{</a>
<a name="ln458">	switch (operation) {</a>
<a name="ln459">		case PACKAGE_FS_OPERATION_GET_VOLUME_INFO:</a>
<a name="ln460">		{</a>
<a name="ln461">			if (size &lt; sizeof(PackageFSVolumeInfo))</a>
<a name="ln462">				RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln463"> </a>
<a name="ln464">			PackageFSVolumeInfo* userVolumeInfo</a>
<a name="ln465">				= (PackageFSVolumeInfo*)buffer;</a>
<a name="ln466"> </a>
<a name="ln467">			VolumeReadLocker volumeReadLocker(this);</a>
<a name="ln468"> </a>
<a name="ln469">			PackageFSVolumeInfo volumeInfo;</a>
<a name="ln470">			volumeInfo.mountType = fMountType;</a>
<a name="ln471">			volumeInfo.rootDeviceID = fPackageFSRoot-&gt;DeviceID();</a>
<a name="ln472">			volumeInfo.rootDirectoryID = fPackageFSRoot-&gt;NodeID();</a>
<a name="ln473">			volumeInfo.packagesDirectoryCount = fPackagesDirectories.Count();</a>
<a name="ln474"> </a>
<a name="ln475">			status_t error = user_memcpy(userVolumeInfo, &amp;volumeInfo,</a>
<a name="ln476">				sizeof(volumeInfo));</a>
<a name="ln477">			if (error != B_OK)</a>
<a name="ln478">				RETURN_ERROR(error);</a>
<a name="ln479"> </a>
<a name="ln480">			uint32 directoryIndex = 0;</a>
<a name="ln481">			for (PackagesDirectoryList::Iterator it</a>
<a name="ln482">					= fPackagesDirectories.GetIterator();</a>
<a name="ln483">				PackagesDirectory* directory = it.Next();</a>
<a name="ln484">				directoryIndex++) {</a>
<a name="ln485">				PackageFSDirectoryInfo info;</a>
<a name="ln486">				info.deviceID = directory-&gt;DeviceID();</a>
<a name="ln487">				info.nodeID = directory-&gt;NodeID();</a>
<a name="ln488"> </a>
<a name="ln489">				PackageFSDirectoryInfo* userInfo</a>
<a name="ln490">					= userVolumeInfo-&gt;packagesDirectoryInfos + directoryIndex;</a>
<a name="ln491">				if (addr_t(userInfo + 1) &gt; (addr_t)buffer + size)</a>
<a name="ln492">					break;</a>
<a name="ln493"> </a>
<a name="ln494">				if (user_memcpy(userInfo, &amp;info, sizeof(info)) != B_OK)</a>
<a name="ln495">					return B_BAD_ADDRESS;</a>
<a name="ln496">			}</a>
<a name="ln497"> </a>
<a name="ln498">			return B_OK;</a>
<a name="ln499">		}</a>
<a name="ln500"> </a>
<a name="ln501">		case PACKAGE_FS_OPERATION_GET_PACKAGE_INFOS:</a>
<a name="ln502">		{</a>
<a name="ln503">			if (size &lt; sizeof(PackageFSGetPackageInfosRequest))</a>
<a name="ln504">				RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln505"> </a>
<a name="ln506">			PackageFSGetPackageInfosRequest* request</a>
<a name="ln507">				= (PackageFSGetPackageInfosRequest*)buffer;</a>
<a name="ln508"> </a>
<a name="ln509">			VolumeReadLocker volumeReadLocker(this);</a>
<a name="ln510"> </a>
<a name="ln511">			addr_t bufferEnd = (addr_t)buffer + size;</a>
<a name="ln512">			uint32 packageCount = fPackages.CountElements();</a>
<a name="ln513">			char* nameBuffer = (char*)(request-&gt;infos + packageCount);</a>
<a name="ln514"> </a>
<a name="ln515">			uint32 packageIndex = 0;</a>
<a name="ln516">			for (PackageFileNameHashTable::Iterator it</a>
<a name="ln517">					= fPackages.GetIterator(); it.HasNext();</a>
<a name="ln518">				packageIndex++) {</a>
<a name="ln519">				Package* package = it.Next();</a>
<a name="ln520">				PackageFSPackageInfo info;</a>
<a name="ln521">				info.packageDeviceID = package-&gt;DeviceID();</a>
<a name="ln522">				info.packageNodeID = package-&gt;NodeID();</a>
<a name="ln523">				PackagesDirectory* directory = package-&gt;Directory();</a>
<a name="ln524">				info.directoryDeviceID = directory-&gt;DeviceID();</a>
<a name="ln525">				info.directoryNodeID = directory-&gt;NodeID();</a>
<a name="ln526">				info.name = nameBuffer;</a>
<a name="ln527"> </a>
<a name="ln528">				PackageFSPackageInfo* userInfo = request-&gt;infos + packageIndex;</a>
<a name="ln529">				if (addr_t(userInfo + 1) &lt;= bufferEnd) {</a>
<a name="ln530">					if (user_memcpy(userInfo, &amp;info, sizeof(info)) != B_OK)</a>
<a name="ln531">						return B_BAD_ADDRESS;</a>
<a name="ln532">				}</a>
<a name="ln533"> </a>
<a name="ln534">				const char* name = package-&gt;FileName();</a>
<a name="ln535">				size_t nameSize = strlen(name) + 1;</a>
<a name="ln536">				char* nameEnd = nameBuffer + nameSize;</a>
<a name="ln537">				if ((addr_t)nameEnd &lt;= bufferEnd) {</a>
<a name="ln538">					if (user_memcpy(nameBuffer, name, nameSize) != B_OK)</a>
<a name="ln539">						return B_BAD_ADDRESS;</a>
<a name="ln540">				}</a>
<a name="ln541">				nameBuffer = nameEnd;</a>
<a name="ln542">			}</a>
<a name="ln543"> </a>
<a name="ln544">			PackageFSGetPackageInfosRequest header;</a>
<a name="ln545">			header.bufferSize = nameBuffer - (char*)request;</a>
<a name="ln546">			header.packageCount = packageCount;</a>
<a name="ln547">			size_t headerSize = (char*)&amp;request-&gt;infos - (char*)request;</a>
<a name="ln548">			RETURN_ERROR(user_memcpy(request, &amp;header, headerSize));</a>
<a name="ln549">		}</a>
<a name="ln550"> </a>
<a name="ln551">		case PACKAGE_FS_OPERATION_CHANGE_ACTIVATION:</a>
<a name="ln552">		{</a>
<a name="ln553">			ActivationChangeRequest request;</a>
<a name="ln554">			status_t error = request.Init(buffer, size);</a>
<a name="ln555">			if (error != B_OK)</a>
<a name="ln556">				RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln557"> </a>
<a name="ln558">			return _ChangeActivation(request);</a>
<a name="ln559">		}</a>
<a name="ln560"> </a>
<a name="ln561">		default:</a>
<a name="ln562">			return B_BAD_VALUE;</a>
<a name="ln563">	}</a>
<a name="ln564">}</a>
<a name="ln565"> </a>
<a name="ln566"> </a>
<a name="ln567">void</a>
<a name="ln568">Volume::AddNodeListener(NodeListener* listener, Node* node)</a>
<a name="ln569">{</a>
<a name="ln570">	ASSERT(!listener-&gt;IsListening());</a>
<a name="ln571"> </a>
<a name="ln572">	listener-&gt;StartedListening(node);</a>
<a name="ln573"> </a>
<a name="ln574">	if (NodeListener* list = fNodeListeners.Lookup(node))</a>
<a name="ln575">		list-&gt;AddNodeListener(listener);</a>
<a name="ln576">	else</a>
<a name="ln577">		fNodeListeners.Insert(listener);</a>
<a name="ln578">}</a>
<a name="ln579"> </a>
<a name="ln580"> </a>
<a name="ln581">void</a>
<a name="ln582">Volume::RemoveNodeListener(NodeListener* listener)</a>
<a name="ln583">{</a>
<a name="ln584">	ASSERT(listener-&gt;IsListening());</a>
<a name="ln585"> </a>
<a name="ln586">	Node* node = listener-&gt;ListenedNode();</a>
<a name="ln587"> </a>
<a name="ln588">	if (NodeListener* next = listener-&gt;RemoveNodeListener()) {</a>
<a name="ln589">		// list not empty yet -- if we removed the head, add a new head to the</a>
<a name="ln590">		// hash table</a>
<a name="ln591">		NodeListener* list = fNodeListeners.Lookup(node);</a>
<a name="ln592">		if (list == listener) {</a>
<a name="ln593">			fNodeListeners.Remove(listener);</a>
<a name="ln594">			fNodeListeners.Insert(next);</a>
<a name="ln595">		}</a>
<a name="ln596">	} else</a>
<a name="ln597">		fNodeListeners.Remove(listener);</a>
<a name="ln598"> </a>
<a name="ln599">	listener-&gt;StoppedListening();</a>
<a name="ln600">}</a>
<a name="ln601"> </a>
<a name="ln602"> </a>
<a name="ln603">void</a>
<a name="ln604">Volume::AddQuery(Query* query)</a>
<a name="ln605">{</a>
<a name="ln606">	fQueries.Add(query);</a>
<a name="ln607">}</a>
<a name="ln608"> </a>
<a name="ln609"> </a>
<a name="ln610">void</a>
<a name="ln611">Volume::RemoveQuery(Query* query)</a>
<a name="ln612">{</a>
<a name="ln613">	fQueries.Remove(query);</a>
<a name="ln614">}</a>
<a name="ln615"> </a>
<a name="ln616"> </a>
<a name="ln617">void</a>
<a name="ln618">Volume::UpdateLiveQueries(Node* node, const char* attribute, int32 type,</a>
<a name="ln619">	const void* oldKey, size_t oldLength, const void* newKey,</a>
<a name="ln620">	size_t newLength)</a>
<a name="ln621">{</a>
<a name="ln622">	for (QueryList::Iterator it = fQueries.GetIterator();</a>
<a name="ln623">			Query* query = it.Next();) {</a>
<a name="ln624">		query-&gt;LiveUpdate(node, attribute, type, oldKey, oldLength, newKey,</a>
<a name="ln625">			newLength);</a>
<a name="ln626">	}</a>
<a name="ln627">}</a>
<a name="ln628"> </a>
<a name="ln629"> </a>
<a name="ln630">status_t</a>
<a name="ln631">Volume::GetVNode(ino_t nodeID, Node*&amp; _node)</a>
<a name="ln632">{</a>
<a name="ln633">	return get_vnode(fFSVolume, nodeID, (void**)&amp;_node);</a>
<a name="ln634">}</a>
<a name="ln635"> </a>
<a name="ln636"> </a>
<a name="ln637">status_t</a>
<a name="ln638">Volume::PutVNode(ino_t nodeID)</a>
<a name="ln639">{</a>
<a name="ln640">	return put_vnode(fFSVolume, nodeID);</a>
<a name="ln641">}</a>
<a name="ln642"> </a>
<a name="ln643"> </a>
<a name="ln644">status_t</a>
<a name="ln645">Volume::RemoveVNode(ino_t nodeID)</a>
<a name="ln646">{</a>
<a name="ln647">	return remove_vnode(fFSVolume, nodeID);</a>
<a name="ln648">}</a>
<a name="ln649"> </a>
<a name="ln650"> </a>
<a name="ln651">status_t</a>
<a name="ln652">Volume::PublishVNode(Node* node)</a>
<a name="ln653">{</a>
<a name="ln654">	return publish_vnode(fFSVolume, node-&gt;ID(), node, &amp;gPackageFSVnodeOps,</a>
<a name="ln655">		node-&gt;Mode() &amp; S_IFMT, 0);</a>
<a name="ln656">}</a>
<a name="ln657"> </a>
<a name="ln658"> </a>
<a name="ln659">void</a>
<a name="ln660">Volume::PackageLinkNodeAdded(Node* node)</a>
<a name="ln661">{</a>
<a name="ln662">	_AddPackageLinksNode(node);</a>
<a name="ln663"> </a>
<a name="ln664">	notify_entry_created(ID(), node-&gt;Parent()-&gt;ID(), node-&gt;Name(), node-&gt;ID());</a>
<a name="ln665">	_NotifyNodeAdded(node);</a>
<a name="ln666">}</a>
<a name="ln667"> </a>
<a name="ln668"> </a>
<a name="ln669">void</a>
<a name="ln670">Volume::PackageLinkNodeRemoved(Node* node)</a>
<a name="ln671">{</a>
<a name="ln672">	_RemovePackageLinksNode(node);</a>
<a name="ln673"> </a>
<a name="ln674">	notify_entry_removed(ID(), node-&gt;Parent()-&gt;ID(), node-&gt;Name(), node-&gt;ID());</a>
<a name="ln675">	_NotifyNodeRemoved(node);</a>
<a name="ln676">}</a>
<a name="ln677"> </a>
<a name="ln678"> </a>
<a name="ln679">void</a>
<a name="ln680">Volume::PackageLinkNodeChanged(Node* node, uint32 statFields,</a>
<a name="ln681">	const OldNodeAttributes&amp; oldAttributes)</a>
<a name="ln682">{</a>
<a name="ln683">	Directory* parent = node-&gt;Parent();</a>
<a name="ln684">	notify_stat_changed(ID(), parent != NULL ? parent-&gt;ID() : -1, node-&gt;ID(),</a>
<a name="ln685">		statFields);</a>
<a name="ln686">	_NotifyNodeChanged(node, statFields, oldAttributes);</a>
<a name="ln687">}</a>
<a name="ln688"> </a>
<a name="ln689"> </a>
<a name="ln690">status_t</a>
<a name="ln691">Volume::_LoadOldPackagesStates(const char* packagesState)</a>
<a name="ln692">{</a>
<a name="ln693">	// open and stat the admininistrative dir</a>
<a name="ln694">	int fd = openat(fPackagesDirectory-&gt;DirectoryFD(),</a>
<a name="ln695">		kAdministrativeDirectoryName, O_RDONLY);</a>
<a name="ln696">	if (fd &lt; 0) {</a>
<a name="ln697">		ERROR(&quot;Failed to open administrative directory: %s\n&quot;, strerror(errno));</a>
<a name="ln698">		RETURN_ERROR(errno);</a>
<a name="ln699">	}</a>
<a name="ln700"> </a>
<a name="ln701">	struct stat adminDirStat;</a>
<a name="ln702">	if (fstat(fd, &amp;adminDirStat) &lt; 0) {</a>
<a name="ln703">		ERROR(&quot;Failed to fstat() administrative directory: %s\n&quot;,</a>
<a name="ln704">			strerror(errno));</a>
<a name="ln705">		RETURN_ERROR(errno);</a>
<a name="ln706">	}</a>
<a name="ln707"> </a>
<a name="ln708">	// iterate through the &quot;administrative&quot; dir</a>
<a name="ln709">	DIR* dir = fdopendir(fd);</a>
<a name="ln710">	if (dir == NULL) {</a>
<a name="ln711">		ERROR(&quot;Failed to open administrative directory: %s\n&quot;, strerror(errno));</a>
<a name="ln712">		RETURN_ERROR(errno);</a>
<a name="ln713">	}</a>
<a name="ln714">	CObjectDeleter&lt;DIR, int&gt; dirCloser(dir, closedir);</a>
<a name="ln715"> </a>
<a name="ln716">	while (dirent* entry = readdir(dir)) {</a>
<a name="ln717">		if (strncmp(entry-&gt;d_name, &quot;state_&quot;, 6) != 0</a>
<a name="ln718">			|| strcmp(entry-&gt;d_name, packagesState) &lt; 0) {</a>
<a name="ln719">			continue;</a>
<a name="ln720">		}</a>
<a name="ln721"> </a>
<a name="ln722">		PackagesDirectory* packagesDirectory</a>
<a name="ln723">			= new(std::nothrow) PackagesDirectory;</a>
<a name="ln724">		status_t error = packagesDirectory-&gt;InitOldState(adminDirStat.st_dev,</a>
<a name="ln725">			adminDirStat.st_ino, entry-&gt;d_name);</a>
<a name="ln726">		if (error != B_OK) {</a>
<a name="ln727">			delete packagesDirectory;</a>
<a name="ln728">			continue;</a>
<a name="ln729">		}</a>
<a name="ln730"> </a>
<a name="ln731">		fPackagesDirectories.Add(packagesDirectory);</a>
<a name="ln732">		fPackagesDirectoriesByNodeRef.Insert(packagesDirectory);</a>
<a name="ln733"> </a>
<a name="ln734">		INFORM(&quot;added old packages dir state \&quot;%s\&quot;\n&quot;,</a>
<a name="ln735">			packagesDirectory-&gt;StateName().Data());</a>
<a name="ln736">	}</a>
<a name="ln737"> </a>
<a name="ln738">	// sort the packages directories by state age</a>
<a name="ln739">	fPackagesDirectories.Sort(&amp;PackagesDirectory::IsNewer);</a>
<a name="ln740"> </a>
<a name="ln741">	return B_OK;</a>
<a name="ln742">}</a>
<a name="ln743"> </a>
<a name="ln744"> </a>
<a name="ln745">status_t</a>
<a name="ln746">Volume::_AddInitialPackages()</a>
<a name="ln747">{</a>
<a name="ln748">	PackagesDirectory* packagesDirectory = fPackagesDirectories.Last();</a>
<a name="ln749">	INFORM(&quot;Adding packages from \&quot;%s\&quot;\n&quot;, packagesDirectory-&gt;Path());</a>
<a name="ln750"> </a>
<a name="ln751">	// try reading the activation file of the oldest state</a>
<a name="ln752">	status_t error = _AddInitialPackagesFromActivationFile(packagesDirectory);</a>
<a name="ln753">	if (error != B_OK &amp;&amp; packagesDirectory != fPackagesDirectory) {</a>
<a name="ln754">		WARN(&quot;Loading packages from old state \&quot;%s\&quot; failed. Loading packages &quot;</a>
<a name="ln755">			&quot;from latest state.\n&quot;, packagesDirectory-&gt;StateName().Data());</a>
<a name="ln756"> </a>
<a name="ln757">		// remove all packages already added</a>
<a name="ln758">		{</a>
<a name="ln759">			VolumeWriteLocker systemVolumeLocker(_SystemVolumeIfNotSelf());</a>
<a name="ln760">			VolumeWriteLocker volumeLocker(this);</a>
<a name="ln761">			_RemoveAllPackages();</a>
<a name="ln762">		}</a>
<a name="ln763"> </a>
<a name="ln764">		// remove the old states</a>
<a name="ln765">		while (fPackagesDirectories.Last() != fPackagesDirectory)</a>
<a name="ln766">			fPackagesDirectories.RemoveTail()-&gt;ReleaseReference();</a>
<a name="ln767"> </a>
<a name="ln768">		// try reading the activation file of the latest state</a>
<a name="ln769">		packagesDirectory = fPackagesDirectory;</a>
<a name="ln770">		error = _AddInitialPackagesFromActivationFile(packagesDirectory);</a>
<a name="ln771">	}</a>
<a name="ln772"> </a>
<a name="ln773">	if (error != B_OK) {</a>
<a name="ln774">		INFORM(&quot;Loading packages from activation file failed. Loading all &quot;</a>
<a name="ln775">			&quot;packages in packages directory.\n&quot;);</a>
<a name="ln776"> </a>
<a name="ln777">		// remove all packages already added</a>
<a name="ln778">		{</a>
<a name="ln779">			VolumeWriteLocker systemVolumeLocker(_SystemVolumeIfNotSelf());</a>
<a name="ln780">			VolumeWriteLocker volumeLocker(this);</a>
<a name="ln781">			_RemoveAllPackages();</a>
<a name="ln782">		}</a>
<a name="ln783"> </a>
<a name="ln784">		// read the whole directory</a>
<a name="ln785">		error = _AddInitialPackagesFromDirectory();</a>
<a name="ln786">		if (error != B_OK)</a>
<a name="ln787">			RETURN_ERROR(error);</a>
<a name="ln788">	}</a>
<a name="ln789"> </a>
<a name="ln790">	// add the packages to the node tree</a>
<a name="ln791">	VolumeWriteLocker systemVolumeLocker(_SystemVolumeIfNotSelf());</a>
<a name="ln792">	VolumeWriteLocker volumeLocker(this);</a>
<a name="ln793">	for (PackageFileNameHashTable::Iterator it = fPackages.GetIterator();</a>
<a name="ln794">		Package* package = it.Next();) {</a>
<a name="ln795">		error = _AddPackageContent(package, false);</a>
<a name="ln796">		if (error != B_OK) {</a>
<a name="ln797">			for (it.Rewind(); Package* activePackage = it.Next();) {</a>
<a name="ln798">				if (activePackage == package)</a>
<a name="ln799">					break;</a>
<a name="ln800">				_RemovePackageContent(activePackage, NULL, false);</a>
<a name="ln801">			}</a>
<a name="ln802">			RETURN_ERROR(error);</a>
<a name="ln803">		}</a>
<a name="ln804">	}</a>
<a name="ln805"> </a>
<a name="ln806">	return B_OK;</a>
<a name="ln807">}</a>
<a name="ln808"> </a>
<a name="ln809"> </a>
<a name="ln810">status_t</a>
<a name="ln811">Volume::_AddInitialPackagesFromActivationFile(</a>
<a name="ln812">	PackagesDirectory* packagesDirectory)</a>
<a name="ln813">{</a>
<a name="ln814">	// try reading the activation file</a>
<a name="ln815">	int fd = openat(packagesDirectory-&gt;DirectoryFD(),</a>
<a name="ln816">		packagesDirectory == fPackagesDirectory</a>
<a name="ln817">			? kActivationFilePath : kActivationFileName,</a>
<a name="ln818">		O_RDONLY);</a>
<a name="ln819">	if (fd &lt; 0) {</a>
<a name="ln820">		INFORM(&quot;Failed to open packages activation file: %s\n&quot;,</a>
<a name="ln821">			strerror(errno));</a>
<a name="ln822">		RETURN_ERROR(errno);</a>
<a name="ln823">	}</a>
<a name="ln824">	FileDescriptorCloser fdCloser(fd);</a>
<a name="ln825"> </a>
<a name="ln826">	// read the whole file into memory to simplify things</a>
<a name="ln827">	struct stat st;</a>
<a name="ln828">	if (fstat(fd, &amp;st) != 0) {</a>
<a name="ln829">		ERROR(&quot;Failed to stat packages activation file: %s\n&quot;,</a>
<a name="ln830">			strerror(errno));</a>
<a name="ln831">		RETURN_ERROR(errno);</a>
<a name="ln832">	}</a>
<a name="ln833"> </a>
<a name="ln834">	if (st.st_size &gt; (off_t)kMaxActivationFileSize) {</a>
<a name="ln835">		ERROR(&quot;The packages activation file is too big.\n&quot;);</a>
<a name="ln836">		RETURN_ERROR(B_BAD_DATA);</a>
<a name="ln837">	}</a>
<a name="ln838"> </a>
<a name="ln839">	char* fileContent = (char*)malloc(st.st_size + 1);</a>
<a name="ln840">	if (fileContent == NULL)</a>
<a name="ln841">		RETURN_ERROR(B_NO_MEMORY);</a>
<a name="ln842">	MemoryDeleter fileContentDeleter(fileContent);</a>
<a name="ln843"> </a>
<a name="ln844">	ssize_t bytesRead = read(fd, fileContent, st.st_size);</a>
<a name="ln845">	if (bytesRead &lt; 0) {</a>
<a name="ln846">		ERROR(&quot;Failed to read packages activation file: %s\n&quot;, strerror(errno));</a>
<a name="ln847">		RETURN_ERROR(errno);</a>
<a name="ln848">	}</a>
<a name="ln849"> </a>
<a name="ln850">	if (bytesRead != st.st_size) {</a>
<a name="ln851">		ERROR(&quot;Failed to read whole packages activation file\n&quot;);</a>
<a name="ln852">		RETURN_ERROR(B_ERROR);</a>
<a name="ln853">	}</a>
<a name="ln854"> </a>
<a name="ln855">	// null-terminate to simplify parsing</a>
<a name="ln856">	fileContent[st.st_size] = '\0';</a>
<a name="ln857"> </a>
<a name="ln858">	// parse the file and add the respective packages</a>
<a name="ln859">	const char* packageName = fileContent;</a>
<a name="ln860">	char* const fileContentEnd = fileContent + st.st_size;</a>
<a name="ln861">	while (packageName &lt; fileContentEnd) {</a>
<a name="ln862">		char* packageNameEnd = strchr(packageName, '\n');</a>
<a name="ln863">		if (packageNameEnd == NULL)</a>
<a name="ln864">			packageNameEnd = fileContentEnd;</a>
<a name="ln865"> </a>
<a name="ln866">		// skip empty lines</a>
<a name="ln867">		if (packageName == packageNameEnd) {</a>
<a name="ln868">			packageName++;</a>
<a name="ln869">			continue;</a>
<a name="ln870">		}</a>
<a name="ln871">		*packageNameEnd = '\0';</a>
<a name="ln872"> </a>
<a name="ln873">		if (packageNameEnd - packageName &gt;= B_FILE_NAME_LENGTH) {</a>
<a name="ln874">			ERROR(&quot;Invalid packages activation file content.\n&quot;);</a>
<a name="ln875">			RETURN_ERROR(B_BAD_DATA);</a>
<a name="ln876">		}</a>
<a name="ln877"> </a>
<a name="ln878">		status_t error = _LoadAndAddInitialPackage(packagesDirectory,</a>
<a name="ln879">			packageName);</a>
<a name="ln880">		if (error != B_OK)</a>
<a name="ln881">			RETURN_ERROR(error);</a>
<a name="ln882"> </a>
<a name="ln883">		packageName = packageNameEnd + 1;</a>
<a name="ln884">	}</a>
<a name="ln885"> </a>
<a name="ln886">	return B_OK;</a>
<a name="ln887">}</a>
<a name="ln888"> </a>
<a name="ln889"> </a>
<a name="ln890">status_t</a>
<a name="ln891">Volume::_AddInitialPackagesFromDirectory()</a>
<a name="ln892">{</a>
<a name="ln893">	// iterate through the dir and create packages</a>
<a name="ln894">	int fd = openat(fPackagesDirectory-&gt;DirectoryFD(), &quot;.&quot;, O_RDONLY);</a>
<a name="ln895">	if (fd &lt; 0) {</a>
<a name="ln896">		ERROR(&quot;Failed to open packages directory: %s\n&quot;, strerror(errno));</a>
<a name="ln897">		RETURN_ERROR(errno);</a>
<a name="ln898">	}</a>
<a name="ln899"> </a>
<a name="ln900">	DIR* dir = fdopendir(fd);</a>
<a name="ln901">	if (dir == NULL) {</a>
<a name="ln902">		ERROR(&quot;Failed to open packages directory \&quot;%s\&quot;: %s\n&quot;,</a>
<a name="ln903">			fPackagesDirectory-&gt;Path(), strerror(errno));</a>
<a name="ln904">		RETURN_ERROR(errno);</a>
<a name="ln905">	}</a>
<a name="ln906">	CObjectDeleter&lt;DIR, int&gt; dirCloser(dir, closedir);</a>
<a name="ln907"> </a>
<a name="ln908">	while (dirent* entry = readdir(dir)) {</a>
<a name="ln909">		// skip &quot;.&quot; and &quot;..&quot;</a>
<a name="ln910">		if (strcmp(entry-&gt;d_name, &quot;.&quot;) == 0 || strcmp(entry-&gt;d_name, &quot;..&quot;) == 0)</a>
<a name="ln911">			continue;</a>
<a name="ln912"> </a>
<a name="ln913">		// also skip any entry without a &quot;.hpkg&quot; extension</a>
<a name="ln914">		size_t nameLength = strlen(entry-&gt;d_name);</a>
<a name="ln915">		if (nameLength &lt; 5</a>
<a name="ln916">			|| memcmp(entry-&gt;d_name + nameLength - 5, &quot;.hpkg&quot;, 5) != 0) {</a>
<a name="ln917">			continue;</a>
<a name="ln918">		}</a>
<a name="ln919"> </a>
<a name="ln920">		_LoadAndAddInitialPackage(fPackagesDirectory, entry-&gt;d_name);</a>
<a name="ln921">	}</a>
<a name="ln922"> </a>
<a name="ln923">	return B_OK;</a>
<a name="ln924">}</a>
<a name="ln925"> </a>
<a name="ln926"> </a>
<a name="ln927">status_t</a>
<a name="ln928">Volume::_LoadAndAddInitialPackage(PackagesDirectory* packagesDirectory,</a>
<a name="ln929">	const char* name)</a>
<a name="ln930">{</a>
<a name="ln931">	Package* package;</a>
<a name="ln932">	status_t error = _LoadPackage(packagesDirectory, name, package);</a>
<a name="ln933">	if (error != B_OK) {</a>
<a name="ln934">		ERROR(&quot;Failed to load package \&quot;%s\&quot;: %s\n&quot;, name, strerror(error));</a>
<a name="ln935">		RETURN_ERROR(error);</a>
<a name="ln936">	}</a>
<a name="ln937">	BReference&lt;Package&gt; packageReference(package, true);</a>
<a name="ln938"> </a>
<a name="ln939">	VolumeWriteLocker systemVolumeLocker(_SystemVolumeIfNotSelf());</a>
<a name="ln940">	VolumeWriteLocker volumeLocker(this);</a>
<a name="ln941">	_AddPackage(package);</a>
<a name="ln942"> </a>
<a name="ln943">	return B_OK;</a>
<a name="ln944">}</a>
<a name="ln945"> </a>
<a name="ln946"> </a>
<a name="ln947">inline void</a>
<a name="ln948">Volume::_AddPackage(Package* package)</a>
<a name="ln949">{</a>
<a name="ln950">	fPackages.Insert(package);</a>
<a name="ln951">	package-&gt;AcquireReference();</a>
<a name="ln952">}</a>
<a name="ln953"> </a>
<a name="ln954"> </a>
<a name="ln955">inline void</a>
<a name="ln956">Volume::_RemovePackage(Package* package)</a>
<a name="ln957">{</a>
<a name="ln958">	fPackages.Remove(package);</a>
<a name="ln959">	package-&gt;ReleaseReference();</a>
<a name="ln960">}</a>
<a name="ln961"> </a>
<a name="ln962"> </a>
<a name="ln963">void</a>
<a name="ln964">Volume::_RemoveAllPackages()</a>
<a name="ln965">{</a>
<a name="ln966">	Package* package = fPackages.Clear(true);</a>
<a name="ln967">	while (package != NULL) {</a>
<a name="ln968">		Package* next = package-&gt;FileNameHashTableNext();</a>
<a name="ln969">		package-&gt;ReleaseReference();</a>
<a name="ln970">		package = next;</a>
<a name="ln971">	}</a>
<a name="ln972">}</a>
<a name="ln973"> </a>
<a name="ln974"> </a>
<a name="ln975">inline Package*</a>
<a name="ln976">Volume::_FindPackage(const char* fileName) const</a>
<a name="ln977">{</a>
<a name="ln978">	return fPackages.Lookup(fileName);</a>
<a name="ln979">}</a>
<a name="ln980"> </a>
<a name="ln981"> </a>
<a name="ln982">status_t</a>
<a name="ln983">Volume::_AddPackageContent(Package* package, bool notify)</a>
<a name="ln984">{</a>
<a name="ln985">	// Open the package. We don't need the FD here, but this is an optimization.</a>
<a name="ln986">	// The attribute indices may want to read the package nodes' attributes and</a>
<a name="ln987">	// the package file would be opened and closed for each attribute instance.</a>
<a name="ln988">	// Since Package keeps and shares the FD as long as at least one party has</a>
<a name="ln989">	// the package open, we prevent that.</a>
<a name="ln990">	int fd = package-&gt;Open();</a>
<a name="ln991">	if (fd &lt; 0)</a>
<a name="ln992">		RETURN_ERROR(fd);</a>
<a name="ln993">	PackageCloser packageCloser(package);</a>
<a name="ln994"> </a>
<a name="ln995">	status_t error = fPackageFSRoot-&gt;AddPackage(package);</a>
<a name="ln996">	if (error != B_OK)</a>
<a name="ln997">		RETURN_ERROR(error);</a>
<a name="ln998"> </a>
<a name="ln999">	for (PackageNodeList::Iterator it = package-&gt;Nodes().GetIterator();</a>
<a name="ln1000">			PackageNode* node = it.Next();) {</a>
<a name="ln1001">		// skip over &quot;.PackageInfo&quot; file, it isn't part of the package content</a>
<a name="ln1002">		if (strcmp(node-&gt;Name(),</a>
<a name="ln1003">				BPackageKit::BHPKG::B_HPKG_PACKAGE_INFO_FILE_NAME) == 0) {</a>
<a name="ln1004">			continue;</a>
<a name="ln1005">		}</a>
<a name="ln1006">		error = _AddPackageContentRootNode(package, node, notify);</a>
<a name="ln1007">		if (error != B_OK) {</a>
<a name="ln1008">			_RemovePackageContent(package, node, notify);</a>
<a name="ln1009">			RETURN_ERROR(error);</a>
<a name="ln1010">		}</a>
<a name="ln1011">	}</a>
<a name="ln1012"> </a>
<a name="ln1013">	return B_OK;</a>
<a name="ln1014">}</a>
<a name="ln1015"> </a>
<a name="ln1016"> </a>
<a name="ln1017">void</a>
<a name="ln1018">Volume::_RemovePackageContent(Package* package, PackageNode* endNode,</a>
<a name="ln1019">	bool notify)</a>
<a name="ln1020">{</a>
<a name="ln1021">	PackageNode* node = package-&gt;Nodes().Head();</a>
<a name="ln1022">	while (node != NULL) {</a>
<a name="ln1023">		if (node == endNode)</a>
<a name="ln1024">			break;</a>
<a name="ln1025"> </a>
<a name="ln1026">		PackageNode* nextNode = package-&gt;Nodes().GetNext(node);</a>
<a name="ln1027"> </a>
<a name="ln1028">		// skip over &quot;.PackageInfo&quot; file, it isn't part of the package content</a>
<a name="ln1029">		if (strcmp(node-&gt;Name(),</a>
<a name="ln1030">				BPackageKit::BHPKG::B_HPKG_PACKAGE_INFO_FILE_NAME) != 0) {</a>
<a name="ln1031">			_RemovePackageContentRootNode(package, node, NULL, notify);</a>
<a name="ln1032">		}</a>
<a name="ln1033"> </a>
<a name="ln1034">		node = nextNode;</a>
<a name="ln1035">	}</a>
<a name="ln1036"> </a>
<a name="ln1037">	fPackageFSRoot-&gt;RemovePackage(package);;</a>
<a name="ln1038">}</a>
<a name="ln1039"> </a>
<a name="ln1040"> </a>
<a name="ln1041">/*!	This method recursively iterates through the descendents of the given</a>
<a name="ln1042">	package root node and adds all package nodes to the node tree in</a>
<a name="ln1043">	pre-order.</a>
<a name="ln1044">	Due to limited kernel stack space we avoid deep recursive function calls</a>
<a name="ln1045">	and rather use the package node stack implied by the tree.</a>
<a name="ln1046">*/</a>
<a name="ln1047">status_t</a>
<a name="ln1048">Volume::_AddPackageContentRootNode(Package* package,</a>
<a name="ln1049">	PackageNode* rootPackageNode, bool notify)</a>
<a name="ln1050">{</a>
<a name="ln1051">	PackageNode* packageNode = rootPackageNode;</a>
<a name="ln1052">	Directory* directory = fRootDirectory;</a>
<a name="ln1053">	directory-&gt;WriteLock();</a>
<a name="ln1054"> </a>
<a name="ln1055">	do {</a>
<a name="ln1056">		Node* node;</a>
<a name="ln1057">		status_t error = _AddPackageNode(directory, packageNode, notify, node);</a>
<a name="ln1058">			// returns B_OK with a NULL node, when skipping the node</a>
<a name="ln1059">		if (error != B_OK) {</a>
<a name="ln1060">			// unlock all directories</a>
<a name="ln1061">			while (directory != NULL) {</a>
<a name="ln1062">				directory-&gt;WriteUnlock();</a>
<a name="ln1063">				directory = directory-&gt;Parent();</a>
<a name="ln1064">			}</a>
<a name="ln1065"> </a>
<a name="ln1066">			// remove the added package nodes</a>
<a name="ln1067">			_RemovePackageContentRootNode(package, rootPackageNode, packageNode,</a>
<a name="ln1068">				notify);</a>
<a name="ln1069">			RETURN_ERROR(error);</a>
<a name="ln1070">		}</a>
<a name="ln1071"> </a>
<a name="ln1072">		// recurse into directory, unless we're supposed to skip the node</a>
<a name="ln1073">		if (node != NULL) {</a>
<a name="ln1074">			if (PackageDirectory* packageDirectory</a>
<a name="ln1075">					= dynamic_cast&lt;PackageDirectory*&gt;(packageNode)) {</a>
<a name="ln1076">				if (packageDirectory-&gt;FirstChild() != NULL) {</a>
<a name="ln1077">					directory = dynamic_cast&lt;Directory*&gt;(node);</a>
<a name="ln1078">					packageNode = packageDirectory-&gt;FirstChild();</a>
<a name="ln1079">					directory-&gt;WriteLock();</a>
<a name="ln1080">					continue;</a>
<a name="ln1081">				}</a>
<a name="ln1082">			}</a>
<a name="ln1083">		}</a>
<a name="ln1084"> </a>
<a name="ln1085">		// continue with the next available (ancestors's) sibling</a>
<a name="ln1086">		do {</a>
<a name="ln1087">			PackageDirectory* packageDirectory = packageNode-&gt;Parent();</a>
<a name="ln1088">			PackageNode* sibling = packageDirectory != NULL</a>
<a name="ln1089">				? packageDirectory-&gt;NextChild(packageNode) : NULL;</a>
<a name="ln1090"> </a>
<a name="ln1091">			if (sibling != NULL) {</a>
<a name="ln1092">				packageNode = sibling;</a>
<a name="ln1093">				break;</a>
<a name="ln1094">			}</a>
<a name="ln1095"> </a>
<a name="ln1096">			// no more siblings -- go back up the tree</a>
<a name="ln1097">			packageNode = packageDirectory;</a>
<a name="ln1098">			directory-&gt;WriteUnlock();</a>
<a name="ln1099">			directory = directory-&gt;Parent();</a>
<a name="ln1100">				// the parent is still locked, so this is safe</a>
<a name="ln1101">		} while (packageNode != NULL);</a>
<a name="ln1102">	} while (packageNode != NULL);</a>
<a name="ln1103"> </a>
<a name="ln1104">	return B_OK;</a>
<a name="ln1105">}</a>
<a name="ln1106"> </a>
<a name="ln1107"> </a>
<a name="ln1108">/*!	Recursively iterates through the descendents of the given package root node</a>
<a name="ln1109">	and removes all package nodes from the node tree in post-order, until</a>
<a name="ln1110">	encountering \a endPackageNode (if non-null).</a>
<a name="ln1111">	Due to limited kernel stack space we avoid deep recursive function calls</a>
<a name="ln1112">	and rather use the package node stack implied by the tree.</a>
<a name="ln1113">*/</a>
<a name="ln1114">void</a>
<a name="ln1115">Volume::_RemovePackageContentRootNode(Package* package,</a>
<a name="ln1116">	PackageNode* rootPackageNode, PackageNode* endPackageNode, bool notify)</a>
<a name="ln1117">{</a>
<a name="ln1118">	PackageNode* packageNode = rootPackageNode;</a>
<a name="ln1119">	Directory* directory = fRootDirectory;</a>
<a name="ln1120">	directory-&gt;WriteLock();</a>
<a name="ln1121"> </a>
<a name="ln1122">	do {</a>
<a name="ln1123">		if (packageNode == endPackageNode)</a>
<a name="ln1124">			break;</a>
<a name="ln1125"> </a>
<a name="ln1126">		// recurse into directory</a>
<a name="ln1127">		if (PackageDirectory* packageDirectory</a>
<a name="ln1128">				= dynamic_cast&lt;PackageDirectory*&gt;(packageNode)) {</a>
<a name="ln1129">			if (packageDirectory-&gt;FirstChild() != NULL) {</a>
<a name="ln1130">				if (Directory* childDirectory = dynamic_cast&lt;Directory*&gt;(</a>
<a name="ln1131">						directory-&gt;FindChild(packageNode-&gt;Name()))) {</a>
<a name="ln1132">					directory = childDirectory;</a>
<a name="ln1133">					packageNode = packageDirectory-&gt;FirstChild();</a>
<a name="ln1134">					directory-&gt;WriteLock();</a>
<a name="ln1135">					continue;</a>
<a name="ln1136">				}</a>
<a name="ln1137">			}</a>
<a name="ln1138">		}</a>
<a name="ln1139"> </a>
<a name="ln1140">		// continue with the next available (ancestors's) sibling</a>
<a name="ln1141">		do {</a>
<a name="ln1142">			PackageDirectory* packageDirectory = packageNode-&gt;Parent();</a>
<a name="ln1143">			PackageNode* sibling = packageDirectory != NULL</a>
<a name="ln1144">				? packageDirectory-&gt;NextChild(packageNode) : NULL;</a>
<a name="ln1145"> </a>
<a name="ln1146">			// we're done with the node -- remove it</a>
<a name="ln1147">			_RemovePackageNode(directory, packageNode,</a>
<a name="ln1148">				directory-&gt;FindChild(packageNode-&gt;Name()), notify);</a>
<a name="ln1149"> </a>
<a name="ln1150">			if (sibling != NULL) {</a>
<a name="ln1151">				packageNode = sibling;</a>
<a name="ln1152">				break;</a>
<a name="ln1153">			}</a>
<a name="ln1154"> </a>
<a name="ln1155">			// no more siblings -- go back up the tree</a>
<a name="ln1156">			packageNode = packageDirectory;</a>
<a name="ln1157">			directory-&gt;WriteUnlock();</a>
<a name="ln1158">			directory = directory-&gt;Parent();</a>
<a name="ln1159">				// the parent is still locked, so this is safe</a>
<a name="ln1160">		} while (packageNode != NULL/* &amp;&amp; packageNode != rootPackageNode*/);</a>
<a name="ln1161">	} while (packageNode != NULL/* &amp;&amp; packageNode != rootPackageNode*/);</a>
<a name="ln1162">}</a>
<a name="ln1163"> </a>
<a name="ln1164"> </a>
<a name="ln1165">status_t</a>
<a name="ln1166">Volume::_AddPackageNode(Directory* directory, PackageNode* packageNode,</a>
<a name="ln1167">	bool notify, Node*&amp; _node)</a>
<a name="ln1168">{</a>
<a name="ln1169">	bool newNode = false;</a>
<a name="ln1170">	UnpackingNode* unpackingNode;</a>
<a name="ln1171">	Node* node = directory-&gt;FindChild(packageNode-&gt;Name());</a>
<a name="ln1172">	PackageNode* oldPackageNode = NULL;</a>
<a name="ln1173"> </a>
<a name="ln1174">	if (node != NULL) {</a>
<a name="ln1175">		unpackingNode = dynamic_cast&lt;UnpackingNode*&gt;(node);</a>
<a name="ln1176">		if (unpackingNode == NULL) {</a>
<a name="ln1177">			_node = NULL;</a>
<a name="ln1178">			return B_OK;</a>
<a name="ln1179">		}</a>
<a name="ln1180">		oldPackageNode = unpackingNode-&gt;GetPackageNode();</a>
<a name="ln1181">	} else {</a>
<a name="ln1182">		status_t error = _CreateUnpackingNode(packageNode-&gt;Mode(), directory,</a>
<a name="ln1183">			packageNode-&gt;Name(), unpackingNode);</a>
<a name="ln1184">		if (error != B_OK)</a>
<a name="ln1185">			RETURN_ERROR(error);</a>
<a name="ln1186"> </a>
<a name="ln1187">		node = unpackingNode-&gt;GetNode();</a>
<a name="ln1188">		newNode = true;</a>
<a name="ln1189">	}</a>
<a name="ln1190"> </a>
<a name="ln1191">	BReference&lt;Node&gt; nodeReference(node);</a>
<a name="ln1192">	NodeWriteLocker nodeWriteLocker(node);</a>
<a name="ln1193"> </a>
<a name="ln1194">	BReference&lt;Node&gt; newNodeReference;</a>
<a name="ln1195">	NodeWriteLocker newNodeWriteLocker;</a>
<a name="ln1196">	Node* oldNode = NULL;</a>
<a name="ln1197"> </a>
<a name="ln1198">	if (!newNode &amp;&amp; !S_ISDIR(node-&gt;Mode()) &amp;&amp; oldPackageNode != NULL</a>
<a name="ln1199">		&amp;&amp; unpackingNode-&gt;WillBeFirstPackageNode(packageNode)) {</a>
<a name="ln1200">		// The package node we're going to add will represent the node,</a>
<a name="ln1201">		// replacing the current head package node. Since the node isn't a</a>
<a name="ln1202">		// directory, we must make sure that clients having opened or mapped the</a>
<a name="ln1203">		// node won't be surprised. So we create a new node and remove the</a>
<a name="ln1204">		// current one.</a>
<a name="ln1205">		// create a new node and transfer the package nodes to it</a>
<a name="ln1206">		UnpackingNode* newUnpackingNode;</a>
<a name="ln1207">		status_t error = unpackingNode-&gt;CloneTransferPackageNodes(</a>
<a name="ln1208">			fNextNodeID++, newUnpackingNode);</a>
<a name="ln1209">		if (error != B_OK)</a>
<a name="ln1210">			RETURN_ERROR(error);</a>
<a name="ln1211"> </a>
<a name="ln1212">		// remove the old node</a>
<a name="ln1213">		_NotifyNodeRemoved(node);</a>
<a name="ln1214">		_RemoveNodeAndVNode(node);</a>
<a name="ln1215">		oldNode = node;</a>
<a name="ln1216"> </a>
<a name="ln1217">		// add the new node</a>
<a name="ln1218">		unpackingNode = newUnpackingNode;</a>
<a name="ln1219">		node = unpackingNode-&gt;GetNode();</a>
<a name="ln1220">		newNodeReference.SetTo(node);</a>
<a name="ln1221">		newNodeWriteLocker.SetTo(node, false);</a>
<a name="ln1222"> </a>
<a name="ln1223">		directory-&gt;AddChild(node);</a>
<a name="ln1224">		fNodes.Insert(node);</a>
<a name="ln1225">		newNode = true;</a>
<a name="ln1226">	}</a>
<a name="ln1227"> </a>
<a name="ln1228">	status_t error = unpackingNode-&gt;AddPackageNode(packageNode, ID());</a>
<a name="ln1229">	if (error != B_OK) {</a>
<a name="ln1230">		// Remove the node, if created before. If the node was created to</a>
<a name="ln1231">		// replace the previous node, send out notifications instead.</a>
<a name="ln1232">		if (newNode) {</a>
<a name="ln1233">			if (oldNode != NULL) {</a>
<a name="ln1234">				_NotifyNodeAdded(node);</a>
<a name="ln1235">				if (notify) {</a>
<a name="ln1236">					notify_entry_removed(ID(), directory-&gt;ID(), oldNode-&gt;Name(),</a>
<a name="ln1237">						oldNode-&gt;ID());</a>
<a name="ln1238">					notify_entry_created(ID(), directory-&gt;ID(), node-&gt;Name(),</a>
<a name="ln1239">						node-&gt;ID());</a>
<a name="ln1240">				}</a>
<a name="ln1241">			} else</a>
<a name="ln1242">				_RemoveNode(node);</a>
<a name="ln1243">		}</a>
<a name="ln1244">		RETURN_ERROR(error);</a>
<a name="ln1245">	}</a>
<a name="ln1246"> </a>
<a name="ln1247">	if (newNode) {</a>
<a name="ln1248">		_NotifyNodeAdded(node);</a>
<a name="ln1249">	} else if (packageNode == unpackingNode-&gt;GetPackageNode()) {</a>
<a name="ln1250">		_NotifyNodeChanged(node, kAllStatFields,</a>
<a name="ln1251">			OldUnpackingNodeAttributes(oldPackageNode));</a>
<a name="ln1252">	}</a>
<a name="ln1253"> </a>
<a name="ln1254">	if (notify) {</a>
<a name="ln1255">		if (newNode) {</a>
<a name="ln1256">			if (oldNode != NULL) {</a>
<a name="ln1257">				notify_entry_removed(ID(), directory-&gt;ID(), oldNode-&gt;Name(),</a>
<a name="ln1258">					oldNode-&gt;ID());</a>
<a name="ln1259">			}</a>
<a name="ln1260">			notify_entry_created(ID(), directory-&gt;ID(), node-&gt;Name(),</a>
<a name="ln1261">				node-&gt;ID());</a>
<a name="ln1262">		} else if (packageNode == unpackingNode-&gt;GetPackageNode()) {</a>
<a name="ln1263">			// The new package node has become the one representing the node.</a>
<a name="ln1264">			// Send stat changed notification for directories and entry</a>
<a name="ln1265">			// removed + created notifications for files and symlinks.</a>
<a name="ln1266">			notify_stat_changed(ID(), directory-&gt;ID(), node-&gt;ID(),</a>
<a name="ln1267">				kAllStatFields);</a>
<a name="ln1268">			// TODO: Actually the attributes might change, too!</a>
<a name="ln1269">		}</a>
<a name="ln1270">	}</a>
<a name="ln1271"> </a>
<a name="ln1272">	_node = node;</a>
<a name="ln1273">	return B_OK;</a>
<a name="ln1274">}</a>
<a name="ln1275"> </a>
<a name="ln1276"> </a>
<a name="ln1277">void</a>
<a name="ln1278">Volume::_RemovePackageNode(Directory* directory, PackageNode* packageNode,</a>
<a name="ln1279">	Node* node, bool notify)</a>
<a name="ln1280">{</a>
<a name="ln1281">	UnpackingNode* unpackingNode = dynamic_cast&lt;UnpackingNode*&gt;(node);</a>
<a name="ln1282">	if (unpackingNode == NULL)</a>
<a name="ln1283">		return;</a>
<a name="ln1284"> </a>
<a name="ln1285">	BReference&lt;Node&gt; nodeReference(node);</a>
<a name="ln1286">	NodeWriteLocker nodeWriteLocker(node);</a>
<a name="ln1287"> </a>
<a name="ln1288">	PackageNode* headPackageNode = unpackingNode-&gt;GetPackageNode();</a>
<a name="ln1289">	bool nodeRemoved = false;</a>
<a name="ln1290">	Node* newNode = NULL;</a>
<a name="ln1291"> </a>
<a name="ln1292">	BReference&lt;Node&gt; newNodeReference;</a>
<a name="ln1293">	NodeWriteLocker newNodeWriteLocker;</a>
<a name="ln1294"> </a>
<a name="ln1295">	// If this is the last package node of the node, remove it completely.</a>
<a name="ln1296">	if (unpackingNode-&gt;IsOnlyPackageNode(packageNode)) {</a>
<a name="ln1297">		// Notify before removing the node. Otherwise the indices might not</a>
<a name="ln1298">		// find the node anymore.</a>
<a name="ln1299">		_NotifyNodeRemoved(node);</a>
<a name="ln1300"> </a>
<a name="ln1301">		unpackingNode-&gt;PrepareForRemoval();</a>
<a name="ln1302"> </a>
<a name="ln1303">		_RemoveNodeAndVNode(node);</a>
<a name="ln1304">		nodeRemoved = true;</a>
<a name="ln1305">	} else if (packageNode == headPackageNode) {</a>
<a name="ln1306">		// The node does at least have one more package node, but the one to be</a>
<a name="ln1307">		// removed is the head. Unless it's a directory, we replace the node</a>
<a name="ln1308">		// with a completely new one and let the old one die. This is necessary</a>
<a name="ln1309">		// to avoid surprises for clients that have opened/mapped the node.</a>
<a name="ln1310">		if (S_ISDIR(packageNode-&gt;Mode())) {</a>
<a name="ln1311">			unpackingNode-&gt;RemovePackageNode(packageNode, ID());</a>
<a name="ln1312">			_NotifyNodeChanged(node, kAllStatFields,</a>
<a name="ln1313">				OldUnpackingNodeAttributes(headPackageNode));</a>
<a name="ln1314">		} else {</a>
<a name="ln1315">			// create a new node and transfer the package nodes to it</a>
<a name="ln1316">			UnpackingNode* newUnpackingNode;</a>
<a name="ln1317">			status_t error = unpackingNode-&gt;CloneTransferPackageNodes(</a>
<a name="ln1318">				fNextNodeID++, newUnpackingNode);</a>
<a name="ln1319">			if (error == B_OK) {</a>
<a name="ln1320">				// remove the package node</a>
<a name="ln1321">				newUnpackingNode-&gt;RemovePackageNode(packageNode, ID());</a>
<a name="ln1322"> </a>
<a name="ln1323">				// remove the old node</a>
<a name="ln1324">				_NotifyNodeRemoved(node);</a>
<a name="ln1325">				_RemoveNodeAndVNode(node);</a>
<a name="ln1326"> </a>
<a name="ln1327">				// add the new node</a>
<a name="ln1328">				newNode = newUnpackingNode-&gt;GetNode();</a>
<a name="ln1329">				newNodeReference.SetTo(newNode);</a>
<a name="ln1330">				newNodeWriteLocker.SetTo(newNode, false);</a>
<a name="ln1331"> </a>
<a name="ln1332">				directory-&gt;AddChild(newNode);</a>
<a name="ln1333">				fNodes.Insert(newNode);</a>
<a name="ln1334">				_NotifyNodeAdded(newNode);</a>
<a name="ln1335">			} else {</a>
<a name="ln1336">				// There's nothing we can do. Remove the node completely.</a>
<a name="ln1337">				_NotifyNodeRemoved(node);</a>
<a name="ln1338"> </a>
<a name="ln1339">				unpackingNode-&gt;PrepareForRemoval();</a>
<a name="ln1340"> </a>
<a name="ln1341">				_RemoveNodeAndVNode(node);</a>
<a name="ln1342">				nodeRemoved = true;</a>
<a name="ln1343">			}</a>
<a name="ln1344">		}</a>
<a name="ln1345">	} else {</a>
<a name="ln1346">		// The package node to remove is not the head of the node. This change</a>
<a name="ln1347">		// doesn't have any visible effect.</a>
<a name="ln1348">		unpackingNode-&gt;RemovePackageNode(packageNode, ID());</a>
<a name="ln1349">	}</a>
<a name="ln1350"> </a>
<a name="ln1351">	if (!notify)</a>
<a name="ln1352">		return;</a>
<a name="ln1353"> </a>
<a name="ln1354">	// send notifications</a>
<a name="ln1355">	if (nodeRemoved) {</a>
<a name="ln1356">		notify_entry_removed(ID(), directory-&gt;ID(), node-&gt;Name(), node-&gt;ID());</a>
<a name="ln1357">	} else if (packageNode == headPackageNode) {</a>
<a name="ln1358">		// The removed package node was the one representing the node.</a>
<a name="ln1359">		// Send stat changed notification for directories and entry</a>
<a name="ln1360">		// removed + created notifications for files and symlinks.</a>
<a name="ln1361">		if (S_ISDIR(packageNode-&gt;Mode())) {</a>
<a name="ln1362">			notify_stat_changed(ID(), directory-&gt;ID(), node-&gt;ID(),</a>
<a name="ln1363">				kAllStatFields);</a>
<a name="ln1364">			// TODO: Actually the attributes might change, too!</a>
<a name="ln1365">		} else {</a>
<a name="ln1366">			notify_entry_removed(ID(), directory-&gt;ID(), node-&gt;Name(),</a>
<a name="ln1367">				node-&gt;ID());</a>
<a name="ln1368">			notify_entry_created(ID(), directory-&gt;ID(), newNode-&gt;Name(),</a>
<a name="ln1369">				newNode-&gt;ID());</a>
<a name="ln1370">		}</a>
<a name="ln1371">	}</a>
<a name="ln1372">}</a>
<a name="ln1373"> </a>
<a name="ln1374"> </a>
<a name="ln1375">status_t</a>
<a name="ln1376">Volume::_CreateUnpackingNode(mode_t mode, Directory* parent, const String&amp; name,</a>
<a name="ln1377">	UnpackingNode*&amp; _node)</a>
<a name="ln1378">{</a>
<a name="ln1379">	UnpackingNode* unpackingNode;</a>
<a name="ln1380">	if (S_ISREG(mode) || S_ISLNK(mode))</a>
<a name="ln1381">		unpackingNode = new(std::nothrow) UnpackingLeafNode(fNextNodeID++);</a>
<a name="ln1382">	else if (S_ISDIR(mode))</a>
<a name="ln1383">		unpackingNode = new(std::nothrow) UnpackingDirectory(fNextNodeID++);</a>
<a name="ln1384">	else</a>
<a name="ln1385">		RETURN_ERROR(B_UNSUPPORTED);</a>
<a name="ln1386"> </a>
<a name="ln1387">	if (unpackingNode == NULL)</a>
<a name="ln1388">		RETURN_ERROR(B_NO_MEMORY);</a>
<a name="ln1389"> </a>
<a name="ln1390">	Node* node = unpackingNode-&gt;GetNode();</a>
<a name="ln1391">	BReference&lt;Node&gt; nodeReference(node, true);</a>
<a name="ln1392"> </a>
<a name="ln1393">	status_t error = node-&gt;Init(parent, name);</a>
<a name="ln1394">	if (error != B_OK)</a>
<a name="ln1395">		RETURN_ERROR(error);</a>
<a name="ln1396"> </a>
<a name="ln1397">	parent-&gt;AddChild(node);</a>
<a name="ln1398"> </a>
<a name="ln1399">	fNodes.Insert(node);</a>
<a name="ln1400">	nodeReference.Detach();</a>
<a name="ln1401">		// we keep the initial node reference for the table</a>
<a name="ln1402"> </a>
<a name="ln1403">	_node = unpackingNode;</a>
<a name="ln1404">	return B_OK;</a>
<a name="ln1405">}</a>
<a name="ln1406"> </a>
<a name="ln1407"> </a>
<a name="ln1408">void</a>
<a name="ln1409">Volume::_RemoveNode(Node* node)</a>
<a name="ln1410">{</a>
<a name="ln1411">	// remove from parent</a>
<a name="ln1412">	Directory* parent = node-&gt;Parent();</a>
<a name="ln1413">	parent-&gt;RemoveChild(node);</a>
<a name="ln1414"> </a>
<a name="ln1415">	// remove from node table</a>
<a name="ln1416">	fNodes.Remove(node);</a>
<a name="ln1417">	node-&gt;ReleaseReference();</a>
<a name="ln1418">}</a>
<a name="ln1419"> </a>
<a name="ln1420"> </a>
<a name="ln1421">void</a>
<a name="ln1422">Volume::_RemoveNodeAndVNode(Node* node)</a>
<a name="ln1423">{</a>
<a name="ln1424">	// If the node is known to the VFS, we get the vnode, remove it, and put it,</a>
<a name="ln1425">	// so that the VFS will discard it as soon as possible (i.e. now, if no one</a>
<a name="ln1426">	// else is using it).</a>
<a name="ln1427">	NodeWriteLocker nodeWriteLocker(node);</a>
<a name="ln1428"> </a>
<a name="ln1429">	// Remove the node from its parent and the volume. This makes the node</a>
<a name="ln1430">	// inaccessible via the get_vnode() and lookup() hooks.</a>
<a name="ln1431">	_RemoveNode(node);</a>
<a name="ln1432"> </a>
<a name="ln1433">	bool getVNode = node-&gt;IsKnownToVFS();</a>
<a name="ln1434"> </a>
<a name="ln1435">	nodeWriteLocker.Unlock();</a>
<a name="ln1436"> </a>
<a name="ln1437">	// Get a vnode reference, if the node is already known to the VFS.</a>
<a name="ln1438">	Node* dummyNode;</a>
<a name="ln1439">	if (getVNode &amp;&amp; GetVNode(node-&gt;ID(), dummyNode) == B_OK) {</a>
<a name="ln1440">		// TODO: There still is a race condition here which we can't avoid</a>
<a name="ln1441">		// without more help from the VFS. Right after we drop the write</a>
<a name="ln1442">		// lock a vnode for the node could be discarded by the VFS. At that</a>
<a name="ln1443">		// point another thread trying to get the vnode by ID would create</a>
<a name="ln1444">		// a vnode, mark it busy and call our get_vnode() hook. It would</a>
<a name="ln1445">		// block since we (i.e. the package loader thread executing this</a>
<a name="ln1446">		// method) still have the volume write lock. Our get_vnode() call</a>
<a name="ln1447">		// would block, since it finds the vnode marked busy. It times out</a>
<a name="ln1448">		// eventually, but until then a good deal of FS operations might</a>
<a name="ln1449">		// block as well due to us holding the volume lock and probably</a>
<a name="ln1450">		// several node locks as well. A get_vnode*() variant (e.g.</a>
<a name="ln1451">		// get_vnode_etc() with flags parameter) that wouldn't block and</a>
<a name="ln1452">		// only get the vnode, if already loaded and non-busy, would be</a>
<a name="ln1453">		// perfect here.</a>
<a name="ln1454">		RemoveVNode(node-&gt;ID());</a>
<a name="ln1455">		PutVNode(node-&gt;ID());</a>
<a name="ln1456">	}</a>
<a name="ln1457">}</a>
<a name="ln1458"> </a>
<a name="ln1459"> </a>
<a name="ln1460">status_t</a>
<a name="ln1461">Volume::_LoadPackage(PackagesDirectory* packagesDirectory, const char* name,</a>
<a name="ln1462">	Package*&amp; _package)</a>
<a name="ln1463">{</a>
<a name="ln1464">	// Find the package -- check the specified packages directory and iterate</a>
<a name="ln1465">	// toward the newer states.</a>
<a name="ln1466">	struct stat st;</a>
<a name="ln1467">	for (;;) {</a>
<a name="ln1468">		if (packagesDirectory == NULL)</a>
<a name="ln1469">			return B_ENTRY_NOT_FOUND;</a>
<a name="ln1470"> </a>
<a name="ln1471">		if (fstatat(packagesDirectory-&gt;DirectoryFD(), name, &amp;st, 0) == 0) {</a>
<a name="ln1472">			// check whether the entry is a file</a>
<a name="ln1473">			if (!S_ISREG(st.st_mode))</a>
<a name="ln1474">				return B_BAD_VALUE;</a>
<a name="ln1475">			break;</a>
<a name="ln1476">		}</a>
<a name="ln1477"> </a>
<a name="ln1478">		packagesDirectory = fPackagesDirectories.GetPrevious(packagesDirectory);</a>
<a name="ln1479">	}</a>
<a name="ln1480"> </a>
<a name="ln1481">	// create a package</a>
<a name="ln1482">	Package* package = new(std::nothrow) Package(this, packagesDirectory,</a>
<a name="ln1483">		st.st_dev, st.st_ino);</a>
<a name="ln1484">	if (package == NULL)</a>
<a name="ln1485">		RETURN_ERROR(B_NO_MEMORY);</a>
<a name="ln1486">	BReference&lt;Package&gt; packageReference(package, true);</a>
<a name="ln1487"> </a>
<a name="ln1488">	status_t error = package-&gt;Init(name);</a>
<a name="ln1489">	if (error != B_OK)</a>
<a name="ln1490">		return error;</a>
<a name="ln1491"> </a>
<a name="ln1492">	error = package-&gt;Load(fPackageSettings);</a>
<a name="ln1493">	if (error != B_OK)</a>
<a name="ln1494">		return error;</a>
<a name="ln1495"> </a>
<a name="ln1496">	_package = packageReference.Detach();</a>
<a name="ln1497">	return B_OK;</a>
<a name="ln1498">}</a>
<a name="ln1499"> </a>
<a name="ln1500"> </a>
<a name="ln1501">status_t</a>
<a name="ln1502">Volume::_ChangeActivation(ActivationChangeRequest&amp; request)</a>
<a name="ln1503">{</a>
<a name="ln1504">	uint32 itemCount = request.CountItems();</a>
<a name="ln1505">	if (itemCount == 0)</a>
<a name="ln1506">		return B_OK;</a>
<a name="ln1507"> </a>
<a name="ln1508">	// first check the request</a>
<a name="ln1509">	int32 newPackageCount = 0;</a>
<a name="ln1510">	int32 oldPackageCount = 0;</a>
<a name="ln1511">	{</a>
<a name="ln1512">		VolumeReadLocker volumeLocker(this);</a>
<a name="ln1513"> </a>
<a name="ln1514">		for (uint32 i = 0; i &lt; itemCount; i++) {</a>
<a name="ln1515">			PackageFSActivationChangeItem* item = request.ItemAt(i);</a>
<a name="ln1516">			if (item-&gt;parentDeviceID != fPackagesDirectory-&gt;DeviceID()</a>
<a name="ln1517">				|| item-&gt;parentDirectoryID != fPackagesDirectory-&gt;NodeID()) {</a>
<a name="ln1518">				ERROR(&quot;Volume::_ChangeActivation(): mismatching packages &quot;</a>
<a name="ln1519">					&quot;directory\n&quot;);</a>
<a name="ln1520">				RETURN_ERROR(B_MISMATCHED_VALUES);</a>
<a name="ln1521">			}</a>
<a name="ln1522"> </a>
<a name="ln1523">			Package* package = _FindPackage(item-&gt;name);</a>
<a name="ln1524">// TODO: We should better look up the package by node_ref!</a>
<a name="ln1525">			if (item-&gt;type == PACKAGE_FS_ACTIVATE_PACKAGE) {</a>
<a name="ln1526">				if (package != NULL) {</a>
<a name="ln1527">					ERROR(&quot;Volume::_ChangeActivation(): package to activate &quot;</a>
<a name="ln1528">						&quot;already activated: \&quot;%s\&quot;\n&quot;, item-&gt;name);</a>
<a name="ln1529">					RETURN_ERROR(B_NAME_IN_USE);</a>
<a name="ln1530">				}</a>
<a name="ln1531">				newPackageCount++;</a>
<a name="ln1532">			} else if (item-&gt;type == PACKAGE_FS_DEACTIVATE_PACKAGE) {</a>
<a name="ln1533">				if (package == NULL) {</a>
<a name="ln1534">					ERROR(&quot;Volume::_ChangeActivation(): package to deactivate &quot;</a>
<a name="ln1535">						&quot;not found: \&quot;%s\&quot;\n&quot;, item-&gt;name);</a>
<a name="ln1536">					RETURN_ERROR(B_NAME_NOT_FOUND);</a>
<a name="ln1537">				}</a>
<a name="ln1538">				oldPackageCount++;</a>
<a name="ln1539">			} else if (item-&gt;type == PACKAGE_FS_REACTIVATE_PACKAGE) {</a>
<a name="ln1540">				if (package == NULL) {</a>
<a name="ln1541">					ERROR(&quot;Volume::_ChangeActivation(): package to reactivate &quot;</a>
<a name="ln1542">						&quot;not found: \&quot;%s\&quot;\n&quot;, item-&gt;name);</a>
<a name="ln1543">					RETURN_ERROR(B_NAME_NOT_FOUND);</a>
<a name="ln1544">				}</a>
<a name="ln1545">				oldPackageCount++;</a>
<a name="ln1546">				newPackageCount++;</a>
<a name="ln1547">			} else</a>
<a name="ln1548">				RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln1549">		}</a>
<a name="ln1550">	}</a>
<a name="ln1551"> </a>
<a name="ln1552">	INFORM(&quot;Volume::_ChangeActivation(): %&quot; B_PRId32 &quot; new packages, %&quot; B_PRId32</a>
<a name="ln1553">		&quot; old packages\n&quot;, newPackageCount, oldPackageCount);</a>
<a name="ln1554"> </a>
<a name="ln1555">	// Things look good so far -- allocate reference arrays for the packages to</a>
<a name="ln1556">	// add and remove.</a>
<a name="ln1557">	BReference&lt;Package&gt;* newPackageReferences</a>
<a name="ln1558">		= new(std::nothrow) BReference&lt;Package&gt;[newPackageCount];</a>
<a name="ln1559">	if (newPackageReferences == NULL)</a>
<a name="ln1560">		RETURN_ERROR(B_NO_MEMORY);</a>
<a name="ln1561">	ArrayDeleter&lt;BReference&lt;Package&gt; &gt; newPackageReferencesDeleter(</a>
<a name="ln1562">			newPackageReferences);</a>
<a name="ln1563"> </a>
<a name="ln1564">	BReference&lt;Package&gt;* oldPackageReferences</a>
<a name="ln1565">		= new(std::nothrow) BReference&lt;Package&gt;[oldPackageCount];</a>
<a name="ln1566">	if (oldPackageReferences == NULL)</a>
<a name="ln1567">		RETURN_ERROR(B_NO_MEMORY);</a>
<a name="ln1568">	ArrayDeleter&lt;BReference&lt;Package&gt; &gt; oldPackageReferencesDeleter(</a>
<a name="ln1569">			oldPackageReferences);</a>
<a name="ln1570"> </a>
<a name="ln1571">	// load all new packages</a>
<a name="ln1572">	int32 newPackageIndex = 0;</a>
<a name="ln1573">	for (uint32 i = 0; i &lt; itemCount; i++) {</a>
<a name="ln1574">		PackageFSActivationChangeItem* item = request.ItemAt(i);</a>
<a name="ln1575"> </a>
<a name="ln1576">		if (item-&gt;type != PACKAGE_FS_ACTIVATE_PACKAGE</a>
<a name="ln1577">			&amp;&amp; item-&gt;type != PACKAGE_FS_REACTIVATE_PACKAGE) {</a>
<a name="ln1578">			continue;</a>
<a name="ln1579">		}</a>
<a name="ln1580"> </a>
<a name="ln1581">		Package* package;</a>
<a name="ln1582">		status_t error = _LoadPackage(fPackagesDirectory, item-&gt;name, package);</a>
<a name="ln1583">		if (error != B_OK) {</a>
<a name="ln1584">			ERROR(&quot;Volume::_ChangeActivation(): failed to load package &quot;</a>
<a name="ln1585">				&quot;\&quot;%s\&quot;\n&quot;, item-&gt;name);</a>
<a name="ln1586">			RETURN_ERROR(error);</a>
<a name="ln1587">		}</a>
<a name="ln1588"> </a>
<a name="ln1589">		newPackageReferences[newPackageIndex++].SetTo(package, true);</a>
<a name="ln1590">	}</a>
<a name="ln1591"> </a>
<a name="ln1592">	// apply the changes</a>
<a name="ln1593">	VolumeWriteLocker systemVolumeLocker(_SystemVolumeIfNotSelf());</a>
<a name="ln1594">	VolumeWriteLocker volumeLocker(this);</a>
<a name="ln1595">// TODO: Add a change counter to Volume, so we can easily check whether</a>
<a name="ln1596">// everything is still the same.</a>
<a name="ln1597"> </a>
<a name="ln1598">	// remove the old packages</a>
<a name="ln1599">	int32 oldPackageIndex = 0;</a>
<a name="ln1600">	for (uint32 i = 0; i &lt; itemCount; i++) {</a>
<a name="ln1601">		PackageFSActivationChangeItem* item = request.ItemAt(i);</a>
<a name="ln1602"> </a>
<a name="ln1603">		if (item-&gt;type != PACKAGE_FS_DEACTIVATE_PACKAGE</a>
<a name="ln1604">			&amp;&amp; item-&gt;type != PACKAGE_FS_REACTIVATE_PACKAGE) {</a>
<a name="ln1605">			continue;</a>
<a name="ln1606">		}</a>
<a name="ln1607"> </a>
<a name="ln1608">		Package* package = _FindPackage(item-&gt;name);</a>
<a name="ln1609">// TODO: We should better look up the package by node_ref!</a>
<a name="ln1610">		oldPackageReferences[oldPackageIndex++].SetTo(package);</a>
<a name="ln1611">		_RemovePackageContent(package, NULL, true);</a>
<a name="ln1612">		_RemovePackage(package);</a>
<a name="ln1613"> </a>
<a name="ln1614">		INFORM(&quot;package \&quot;%s\&quot; deactivated\n&quot;, package-&gt;FileName().Data());</a>
<a name="ln1615">	}</a>
<a name="ln1616">// TODO: Since package removal cannot fail, consider adding the new packages</a>
<a name="ln1617">// first. The reactivation case may make that problematic, since two packages</a>
<a name="ln1618">// with the same name would be active after activating the new one. Check!</a>
<a name="ln1619"> </a>
<a name="ln1620">	// add the new packages</a>
<a name="ln1621">	status_t error = B_OK;</a>
<a name="ln1622">	for (newPackageIndex = 0; newPackageIndex &lt; newPackageCount;</a>
<a name="ln1623">		newPackageIndex++) {</a>
<a name="ln1624">		Package* package = newPackageReferences[newPackageIndex];</a>
<a name="ln1625">		_AddPackage(package);</a>
<a name="ln1626"> </a>
<a name="ln1627">		// add the package to the node tree</a>
<a name="ln1628">		error = _AddPackageContent(package, true);</a>
<a name="ln1629">		if (error != B_OK) {</a>
<a name="ln1630">			_RemovePackage(package);</a>
<a name="ln1631">			break;</a>
<a name="ln1632">		}</a>
<a name="ln1633">		INFORM(&quot;package \&quot;%s\&quot; activated\n&quot;, package-&gt;FileName().Data());</a>
<a name="ln1634">	}</a>
<a name="ln1635"> </a>
<a name="ln1636">	// Try to roll back the changes, if an error occurred.</a>
<a name="ln1637">	if (error != B_OK) {</a>
<a name="ln1638">		for (int32 i = newPackageIndex - 1; i &gt;= 0; i--) {</a>
<a name="ln1639">			Package* package = newPackageReferences[i];</a>
<a name="ln1640">			_RemovePackageContent(package, NULL, true);</a>
<a name="ln1641">			_RemovePackage(package);</a>
<a name="ln1642">		}</a>
<a name="ln1643"> </a>
<a name="ln1644">		for (int32 i = oldPackageCount - 1; i &gt;= 0; i--) {</a>
<a name="ln1645">			Package* package = oldPackageReferences[i];</a>
<a name="ln1646">			_AddPackage(package);</a>
<a name="ln1647"> </a>
<a name="ln1648">			if (_AddPackageContent(package, true) != B_OK) {</a>
<a name="ln1649">				// nothing we can do here</a>
<a name="ln1650">				ERROR(&quot;Volume::_ChangeActivation(): failed to roll back &quot;</a>
<a name="ln1651">					&quot;deactivation of package \&quot;%s\&quot; after error\n&quot;,</a>
<a name="ln1652">		  			package-&gt;FileName().Data());</a>
<a name="ln1653">				_RemovePackage(package);</a>
<a name="ln1654">			}</a>
<a name="ln1655">		}</a>
<a name="ln1656">	}</a>
<a name="ln1657"> </a>
<a name="ln1658">	return error;</a>
<a name="ln1659">}</a>
<a name="ln1660"> </a>
<a name="ln1661"> </a>
<a name="ln1662">status_t</a>
<a name="ln1663">Volume::_InitMountType(const char* mountType)</a>
<a name="ln1664">{</a>
<a name="ln1665">	if (mountType == NULL)</a>
<a name="ln1666">		fMountType = PACKAGE_FS_MOUNT_TYPE_CUSTOM;</a>
<a name="ln1667">	else if (strcmp(mountType, &quot;system&quot;) == 0)</a>
<a name="ln1668">		fMountType = PACKAGE_FS_MOUNT_TYPE_SYSTEM;</a>
<a name="ln1669">	else if (strcmp(mountType, &quot;home&quot;) == 0)</a>
<a name="ln1670">		fMountType = PACKAGE_FS_MOUNT_TYPE_HOME;</a>
<a name="ln1671">	else if (strcmp(mountType, &quot;custom&quot;) == 0)</a>
<a name="ln1672">		fMountType = PACKAGE_FS_MOUNT_TYPE_CUSTOM;</a>
<a name="ln1673">	else</a>
<a name="ln1674">		RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln1675"> </a>
<a name="ln1676">	return B_OK;</a>
<a name="ln1677">}</a>
<a name="ln1678"> </a>
<a name="ln1679"> </a>
<a name="ln1680">status_t</a>
<a name="ln1681">Volume::_CreateShineThroughDirectory(Directory* parent, const char* name,</a>
<a name="ln1682">	Directory*&amp; _directory)</a>
<a name="ln1683">{</a>
<a name="ln1684">	ShineThroughDirectory* directory = new(std::nothrow) ShineThroughDirectory(</a>
<a name="ln1685">		fNextNodeID++);</a>
<a name="ln1686">	if (directory == NULL)</a>
<a name="ln1687">		RETURN_ERROR(B_NO_MEMORY);</a>
<a name="ln1688">	BReference&lt;ShineThroughDirectory&gt; directoryReference(directory, true);</a>
<a name="ln1689"> </a>
<a name="ln1690">	String nameString;</a>
<a name="ln1691">	if (!nameString.SetTo(name))</a>
<a name="ln1692">		RETURN_ERROR(B_NO_MEMORY);</a>
<a name="ln1693"> </a>
<a name="ln1694">	status_t error = directory-&gt;Init(parent, nameString);</a>
<a name="ln1695">	if (error != B_OK)</a>
<a name="ln1696">		RETURN_ERROR(error);</a>
<a name="ln1697"> </a>
<a name="ln1698">	parent-&gt;AddChild(directory);</a>
<a name="ln1699"> </a>
<a name="ln1700">	fNodes.Insert(directory);</a>
<a name="ln1701">	directoryReference.Detach();</a>
<a name="ln1702">		// we keep the initial node reference for the table</a>
<a name="ln1703"> </a>
<a name="ln1704">	_directory = directory;</a>
<a name="ln1705">	return B_OK;</a>
<a name="ln1706">}</a>
<a name="ln1707"> </a>
<a name="ln1708"> </a>
<a name="ln1709">status_t</a>
<a name="ln1710">Volume::_CreateShineThroughDirectories(const char* shineThroughSetting)</a>
<a name="ln1711">{</a>
<a name="ln1712">	// get the directories to map</a>
<a name="ln1713">	const char* const* directories = NULL;</a>
<a name="ln1714"> </a>
<a name="ln1715">	if (shineThroughSetting == NULL) {</a>
<a name="ln1716">		// nothing specified -- derive from mount type</a>
<a name="ln1717">		switch (fMountType) {</a>
<a name="ln1718">			case PACKAGE_FS_MOUNT_TYPE_SYSTEM:</a>
<a name="ln1719">			case PACKAGE_FS_MOUNT_TYPE_HOME:</a>
<a name="ln1720">				directories = kShineThroughDirectories;</a>
<a name="ln1721">				break;</a>
<a name="ln1722">			case PACKAGE_FS_MOUNT_TYPE_CUSTOM:</a>
<a name="ln1723">				return B_OK;</a>
<a name="ln1724">			case PACKAGE_FS_MOUNT_TYPE_ENUM_COUNT:</a>
<a name="ln1725">				return B_BAD_VALUE;</a>
<a name="ln1726">		}</a>
<a name="ln1727">	} else if (strcmp(shineThroughSetting, &quot;system&quot;) == 0)</a>
<a name="ln1728">		directories = kShineThroughDirectories;</a>
<a name="ln1729">	else if (strcmp(shineThroughSetting, &quot;home&quot;) == 0)</a>
<a name="ln1730">		directories = kShineThroughDirectories;</a>
<a name="ln1731">	else if (strcmp(shineThroughSetting, &quot;none&quot;) == 0)</a>
<a name="ln1732">		directories = NULL;</a>
<a name="ln1733">	else</a>
<a name="ln1734">		RETURN_ERROR(B_BAD_VALUE);</a>
<a name="ln1735"> </a>
<a name="ln1736">	if (directories == NULL)</a>
<a name="ln1737">		return B_OK;</a>
<a name="ln1738"> </a>
<a name="ln1739">	// iterate through the directory list and create the directories</a>
<a name="ln1740">	while (const char* directoryName = *(directories++)) {</a>
<a name="ln1741">		// create the directory</a>
<a name="ln1742">		Directory* directory;</a>
<a name="ln1743">		status_t error = _CreateShineThroughDirectory(fRootDirectory,</a>
<a name="ln1744">			directoryName, directory);</a>
<a name="ln1745">		if (error != B_OK)</a>
<a name="ln1746">			RETURN_ERROR(error);</a>
<a name="ln1747">	}</a>
<a name="ln1748"> </a>
<a name="ln1749">	return B_OK;</a>
<a name="ln1750">}</a>
<a name="ln1751"> </a>
<a name="ln1752"> </a>
<a name="ln1753">status_t</a>
<a name="ln1754">Volume::_PublishShineThroughDirectories()</a>
<a name="ln1755">{</a>
<a name="ln1756">	// Iterate through the root directory children and bind the shine-through</a>
<a name="ln1757">	// directories to the respective mount point subdirectories.</a>
<a name="ln1758">	Node* nextNode;</a>
<a name="ln1759">	for (Node* node = fRootDirectory-&gt;FirstChild(); node != NULL;</a>
<a name="ln1760">			node = nextNode) {</a>
<a name="ln1761">		nextNode = fRootDirectory-&gt;NextChild(node);</a>
<a name="ln1762"> </a>
<a name="ln1763">		// skip anything but shine-through directories</a>
<a name="ln1764">		ShineThroughDirectory* directory</a>
<a name="ln1765">			= dynamic_cast&lt;ShineThroughDirectory*&gt;(node);</a>
<a name="ln1766">		if (directory == NULL)</a>
<a name="ln1767">			continue;</a>
<a name="ln1768"> </a>
<a name="ln1769">		const char* directoryName = directory-&gt;Name();</a>
<a name="ln1770"> </a>
<a name="ln1771">		// look up the mount point subdirectory</a>
<a name="ln1772">		struct vnode* vnode;</a>
<a name="ln1773">		status_t error = vfs_entry_ref_to_vnode(fMountPoint.deviceID,</a>
<a name="ln1774">			fMountPoint.nodeID, directoryName, &amp;vnode);</a>
<a name="ln1775">		if (error != B_OK) {</a>
<a name="ln1776">			dprintf(&quot;packagefs: Failed to get shine-through directory \&quot;%s\&quot;: &quot;</a>
<a name="ln1777">				&quot;%s\n&quot;, directoryName, strerror(error));</a>
<a name="ln1778">			_RemoveNode(directory);</a>
<a name="ln1779">			continue;</a>
<a name="ln1780">		}</a>
<a name="ln1781">		CObjectDeleter&lt;struct vnode&gt; vnodePutter(vnode, &amp;vfs_put_vnode);</a>
<a name="ln1782"> </a>
<a name="ln1783">		// stat it</a>
<a name="ln1784">		struct stat st;</a>
<a name="ln1785">		error = vfs_stat_vnode(vnode, &amp;st);</a>
<a name="ln1786">		if (error != B_OK) {</a>
<a name="ln1787">			dprintf(&quot;packagefs: Failed to stat shine-through directory \&quot;%s\&quot;: &quot;</a>
<a name="ln1788">				&quot;%s\n&quot;, directoryName, strerror(error));</a>
<a name="ln1789">			_RemoveNode(directory);</a>
<a name="ln1790">			continue;</a>
<a name="ln1791">		}</a>
<a name="ln1792"> </a>
<a name="ln1793">		if (!S_ISDIR(st.st_mode)) {</a>
<a name="ln1794">			dprintf(&quot;packagefs: Shine-through entry \&quot;%s\&quot; is not a &quot;</a>
<a name="ln1795">				&quot;directory\n&quot;, directoryName);</a>
<a name="ln1796">			_RemoveNode(directory);</a>
<a name="ln1797">			continue;</a>
<a name="ln1798">		}</a>
<a name="ln1799"> </a>
<a name="ln1800">		// publish the vnode, so the VFS will find it without asking us</a>
<a name="ln1801">		directory-&gt;AcquireReference();</a>
<a name="ln1802">		error = PublishVNode(directory);</a>
<a name="ln1803">		if (error != B_OK) {</a>
<a name="ln1804">			directory-&gt;ReleaseReference();</a>
<a name="ln1805">			_RemoveNode(directory);</a>
<a name="ln1806">			RETURN_ERROR(error);</a>
<a name="ln1807">		}</a>
<a name="ln1808"> </a>
<a name="ln1809">		// bind the directory</a>
<a name="ln1810">		error = vfs_bind_mount_directory(st.st_dev, st.st_ino, fFSVolume-&gt;id,</a>
<a name="ln1811">			directory-&gt;ID());</a>
<a name="ln1812"> </a>
<a name="ln1813">		PutVNode(directory-&gt;ID());</a>
<a name="ln1814">			// release our reference again -- on success</a>
<a name="ln1815">			// vfs_bind_mount_directory() got one</a>
<a name="ln1816"> </a>
<a name="ln1817">		if (error != B_OK)</a>
<a name="ln1818">			RETURN_ERROR(error);</a>
<a name="ln1819">	}</a>
<a name="ln1820"> </a>
<a name="ln1821">	return B_OK;</a>
<a name="ln1822">}</a>
<a name="ln1823"> </a>
<a name="ln1824"> </a>
<a name="ln1825">status_t</a>
<a name="ln1826">Volume::_AddPackageLinksDirectory()</a>
<a name="ln1827">{</a>
<a name="ln1828">	// called when mounting, so we don't need to lock the volume</a>
<a name="ln1829"> </a>
<a name="ln1830">	PackageLinksDirectory* packageLinksDirectory</a>
<a name="ln1831">		= fPackageFSRoot-&gt;GetPackageLinksDirectory();</a>
<a name="ln1832"> </a>
<a name="ln1833">	NodeWriteLocker rootDirectoryWriteLocker(fRootDirectory);</a>
<a name="ln1834">	NodeWriteLocker packageLinksDirectoryWriteLocker(packageLinksDirectory);</a>
<a name="ln1835"> </a>
<a name="ln1836">	packageLinksDirectory-&gt;SetParent(fRootDirectory);</a>
<a name="ln1837">	fRootDirectory-&gt;AddChild(packageLinksDirectory);</a>
<a name="ln1838"> </a>
<a name="ln1839">	_AddPackageLinksNode(packageLinksDirectory);</a>
<a name="ln1840"> </a>
<a name="ln1841">	packageLinksDirectory-&gt;SetListener(this);</a>
<a name="ln1842"> </a>
<a name="ln1843">	return B_OK;</a>
<a name="ln1844">}</a>
<a name="ln1845"> </a>
<a name="ln1846"> </a>
<a name="ln1847">void</a>
<a name="ln1848">Volume::_RemovePackageLinksDirectory()</a>
<a name="ln1849">{</a>
<a name="ln1850">	PackageLinksDirectory* packageLinksDirectory</a>
<a name="ln1851">		= fPackageFSRoot-&gt;GetPackageLinksDirectory();</a>
<a name="ln1852"> </a>
<a name="ln1853">	VolumeWriteLocker volumeLocker(this);</a>
<a name="ln1854">	NodeWriteLocker rootDirectoryWriteLocker(fRootDirectory);</a>
<a name="ln1855">	NodeWriteLocker packageLinksDirectoryWriteLocker(packageLinksDirectory);</a>
<a name="ln1856"> </a>
<a name="ln1857">	if (packageLinksDirectory-&gt;Parent() == fRootDirectory) {</a>
<a name="ln1858">		packageLinksDirectory-&gt;SetListener(NULL);</a>
<a name="ln1859">		fRootDirectory-&gt;RemoveChild(packageLinksDirectory);</a>
<a name="ln1860">		packageLinksDirectory-&gt;SetParent(NULL);</a>
<a name="ln1861">	}</a>
<a name="ln1862">}</a>
<a name="ln1863"> </a>
<a name="ln1864"> </a>
<a name="ln1865">void</a>
<a name="ln1866">Volume::_AddPackageLinksNode(Node* node)</a>
<a name="ln1867">{</a>
<a name="ln1868">	node-&gt;SetID(fNextNodeID++);</a>
<a name="ln1869"> </a>
<a name="ln1870">	fNodes.Insert(node);</a>
<a name="ln1871">	node-&gt;AcquireReference();</a>
<a name="ln1872"> </a>
<a name="ln1873">	// If this is a directory, recursively add descendants. The directory tree</a>
<a name="ln1874">	// for the package links isn't deep, so we can do recursion.</a>
<a name="ln1875">	if (Directory* directory = dynamic_cast&lt;Directory*&gt;(node)) {</a>
<a name="ln1876">		for (Node* child = directory-&gt;FirstChild(); child != NULL;</a>
<a name="ln1877">				child = directory-&gt;NextChild(child)) {</a>
<a name="ln1878">			NodeWriteLocker childWriteLocker(child);</a>
<a name="ln1879">			_AddPackageLinksNode(child);</a>
<a name="ln1880">		}</a>
<a name="ln1881">	}</a>
<a name="ln1882">}</a>
<a name="ln1883"> </a>
<a name="ln1884"> </a>
<a name="ln1885">void</a>
<a name="ln1886">Volume::_RemovePackageLinksNode(Node* node)</a>
<a name="ln1887">{</a>
<a name="ln1888">	// If this is a directory, recursively remove descendants. The directory</a>
<a name="ln1889">	// tree for the package links isn't deep, so we can do recursion.</a>
<a name="ln1890">	if (Directory* directory = dynamic_cast&lt;Directory*&gt;(node)) {</a>
<a name="ln1891">		for (Node* child = directory-&gt;FirstChild(); child != NULL;</a>
<a name="ln1892">				child = directory-&gt;NextChild(child)) {</a>
<a name="ln1893">			NodeWriteLocker childWriteLocker(child);</a>
<a name="ln1894">			_RemovePackageLinksNode(child);</a>
<a name="ln1895">		}</a>
<a name="ln1896">	}</a>
<a name="ln1897"> </a>
<a name="ln1898">	fNodes.Remove(node);</a>
<a name="ln1899">	node-&gt;ReleaseReference();</a>
<a name="ln1900">}</a>
<a name="ln1901"> </a>
<a name="ln1902"> </a>
<a name="ln1903">inline Volume*</a>
<a name="ln1904">Volume::_SystemVolumeIfNotSelf() const</a>
<a name="ln1905">{</a>
<a name="ln1906">	if (Volume* systemVolume = fPackageFSRoot-&gt;SystemVolume())</a>
<a name="ln1907">		return systemVolume == this ? NULL : systemVolume;</a>
<a name="ln1908">	return NULL;</a>
<a name="ln1909">}</a>
<a name="ln1910"> </a>
<a name="ln1911"> </a>
<a name="ln1912">void</a>
<a name="ln1913">Volume::_NotifyNodeAdded(Node* node)</a>
<a name="ln1914">{</a>
<a name="ln1915">	Node* key = node;</a>
<a name="ln1916"> </a>
<a name="ln1917">	for (int i = 0; i &lt; 2; i++) {</a>
<a name="ln1918">		if (NodeListener* listener = fNodeListeners.Lookup(key)) {</a>
<a name="ln1919">			NodeListener* last = listener-&gt;PreviousNodeListener();</a>
<a name="ln1920"> </a>
<a name="ln1921">			while (true) {</a>
<a name="ln1922">				NodeListener* next = listener-&gt;NextNodeListener();</a>
<a name="ln1923"> </a>
<a name="ln1924">				listener-&gt;NodeAdded(node);</a>
<a name="ln1925"> </a>
<a name="ln1926">				if (listener == last)</a>
<a name="ln1927">					break;</a>
<a name="ln1928"> </a>
<a name="ln1929">				listener = next;</a>
<a name="ln1930">			}</a>
<a name="ln1931">		}</a>
<a name="ln1932"> </a>
<a name="ln1933">		key = NULL;</a>
<a name="ln1934">	}</a>
<a name="ln1935">}</a>
<a name="ln1936"> </a>
<a name="ln1937"> </a>
<a name="ln1938">void</a>
<a name="ln1939">Volume::_NotifyNodeRemoved(Node* node)</a>
<a name="ln1940">{</a>
<a name="ln1941">	Node* key = node;</a>
<a name="ln1942"> </a>
<a name="ln1943">	for (int i = 0; i &lt; 2; i++) {</a>
<a name="ln1944">		if (NodeListener* listener = fNodeListeners.Lookup(key)) {</a>
<a name="ln1945">			NodeListener* last = listener-&gt;PreviousNodeListener();</a>
<a name="ln1946"> </a>
<a name="ln1947">			while (true) {</a>
<a name="ln1948">				NodeListener* next = listener-&gt;NextNodeListener();</a>
<a name="ln1949"> </a>
<a name="ln1950">				listener-&gt;NodeRemoved(node);</a>
<a name="ln1951"> </a>
<a name="ln1952">				if (listener == last)</a>
<a name="ln1953">					break;</a>
<a name="ln1954"> </a>
<a name="ln1955">				listener = next;</a>
<a name="ln1956">			}</a>
<a name="ln1957">		}</a>
<a name="ln1958"> </a>
<a name="ln1959">		key = NULL;</a>
<a name="ln1960">	}</a>
<a name="ln1961">}</a>
<a name="ln1962"> </a>
<a name="ln1963"> </a>
<a name="ln1964">void</a>
<a name="ln1965">Volume::_NotifyNodeChanged(Node* node, uint32 statFields,</a>
<a name="ln1966">	const OldNodeAttributes&amp; oldAttributes)</a>
<a name="ln1967">{</a>
<a name="ln1968">	Node* key = node;</a>
<a name="ln1969"> </a>
<a name="ln1970">	for (int i = 0; i &lt; 2; i++) {</a>
<a name="ln1971">		if (NodeListener* listener = fNodeListeners.Lookup(key)) {</a>
<a name="ln1972">			NodeListener* last = listener-&gt;PreviousNodeListener();</a>
<a name="ln1973"> </a>
<a name="ln1974">			while (true) {</a>
<a name="ln1975">				NodeListener* next = listener-&gt;NextNodeListener();</a>
<a name="ln1976"> </a>
<a name="ln1977">				listener-&gt;NodeChanged(node, statFields, oldAttributes);</a>
<a name="ln1978"> </a>
<a name="ln1979">				if (listener == last)</a>
<a name="ln1980">					break;</a>
<a name="ln1981"> </a>
<a name="ln1982">				listener = next;</a>
<a name="ln1983">			}</a>
<a name="ln1984">		}</a>
<a name="ln1985"> </a>
<a name="ln1986">		key = NULL;</a>
<a name="ln1987">	}</a>
<a name="ln1988">}</a>

</code></pre>
<div class="balloon" rel="1395"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'unpackingNode' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="165"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fMountType, fMountPoint.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
