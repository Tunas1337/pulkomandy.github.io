
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>MailDaemonApplication.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2007-2016, Haiku, Inc. All rights reserved.</a>
<a name="ln3"> * Copyright 2001-2002 Dr. Zoidberg Enterprises. All rights reserved.</a>
<a name="ln4"> * Copyright 2011, Clemens Zeidler &lt;haiku@clemens-zeidler.de&gt;</a>
<a name="ln5"> * Distributed under the terms of the MIT License.</a>
<a name="ln6"> */</a>
<a name="ln7"> </a>
<a name="ln8"> </a>
<a name="ln9">#include &quot;MailDaemonApplication.h&quot;</a>
<a name="ln10"> </a>
<a name="ln11">#include &lt;stdio.h&gt;</a>
<a name="ln12">#include &lt;stdlib.h&gt;</a>
<a name="ln13">#include &lt;vector&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;Beep.h&gt;</a>
<a name="ln16">#include &lt;Catalog.h&gt;</a>
<a name="ln17">#include &lt;Deskbar.h&gt;</a>
<a name="ln18">#include &lt;Directory.h&gt;</a>
<a name="ln19">#include &lt;Entry.h&gt;</a>
<a name="ln20">#include &lt;FindDirectory.h&gt;</a>
<a name="ln21">#include &lt;fs_index.h&gt;</a>
<a name="ln22">#include &lt;IconUtils.h&gt;</a>
<a name="ln23">#include &lt;NodeMonitor.h&gt;</a>
<a name="ln24">#include &lt;Notification.h&gt;</a>
<a name="ln25">#include &lt;Path.h&gt;</a>
<a name="ln26">#include &lt;Roster.h&gt;</a>
<a name="ln27">#include &lt;StringList.h&gt;</a>
<a name="ln28">#include &lt;StringFormat.h&gt;</a>
<a name="ln29">#include &lt;VolumeRoster.h&gt;</a>
<a name="ln30"> </a>
<a name="ln31">#include &lt;E-mail.h&gt;</a>
<a name="ln32">#include &lt;MailDaemon.h&gt;</a>
<a name="ln33">#include &lt;MailMessage.h&gt;</a>
<a name="ln34">#include &lt;MailSettings.h&gt;</a>
<a name="ln35"> </a>
<a name="ln36">#include &lt;MailPrivate.h&gt;</a>
<a name="ln37"> </a>
<a name="ln38"> </a>
<a name="ln39">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln40">#define B_TRANSLATION_CONTEXT &quot;MailDaemon&quot;</a>
<a name="ln41"> </a>
<a name="ln42"> </a>
<a name="ln43">static const uint32 kMsgStartAutoCheck = 'stAC';</a>
<a name="ln44">static const uint32 kMsgAutoCheck = 'moto';</a>
<a name="ln45"> </a>
<a name="ln46">static const bigtime_t kStartAutoCheckDelay = 30000000;</a>
<a name="ln47">	// Wait 30 seconds before the first auto check - this usually lets the</a>
<a name="ln48">	// boot process settle down, and give the network a chance to come up.</a>
<a name="ln49"> </a>
<a name="ln50"> </a>
<a name="ln51">struct send_mails_info {</a>
<a name="ln52">	send_mails_info()</a>
<a name="ln53">	{</a>
<a name="ln54">		bytes = 0;</a>
<a name="ln55">	}</a>
<a name="ln56"> </a>
<a name="ln57">	BMessage	files;</a>
<a name="ln58">	off_t		bytes;</a>
<a name="ln59">};</a>
<a name="ln60"> </a>
<a name="ln61"> </a>
<a name="ln62">class InboundMessenger : public BMessenger {</a>
<a name="ln63">public:</a>
<a name="ln64">	InboundMessenger(BInboundMailProtocol* protocol)</a>
<a name="ln65">		:</a>
<a name="ln66">		BMessenger(protocol)</a>
<a name="ln67">	{</a>
<a name="ln68">	}</a>
<a name="ln69"> </a>
<a name="ln70">	status_t MarkAsRead(const entry_ref&amp; ref, read_flags flag)</a>
<a name="ln71">	{</a>
<a name="ln72">		BMessage message(kMsgMarkMessageAsRead);</a>
<a name="ln73">		message.AddRef(&quot;ref&quot;, &amp;ref);</a>
<a name="ln74">		message.AddInt32(&quot;read&quot;, flag);</a>
<a name="ln75"> </a>
<a name="ln76">		return SendMessage(&amp;message);</a>
<a name="ln77">	}</a>
<a name="ln78"> </a>
<a name="ln79">	status_t SynchronizeMessages()</a>
<a name="ln80">	{</a>
<a name="ln81">		BMessage message(kMsgSyncMessages);</a>
<a name="ln82">		return SendMessage(&amp;message);</a>
<a name="ln83">	}</a>
<a name="ln84">};</a>
<a name="ln85"> </a>
<a name="ln86"> </a>
<a name="ln87">// #pragma mark -</a>
<a name="ln88"> </a>
<a name="ln89"> </a>
<a name="ln90">static void</a>
<a name="ln91">makeIndices()</a>
<a name="ln92">{</a>
<a name="ln93">	const char* stringIndices[] = {</a>
<a name="ln94">		B_MAIL_ATTR_CC, B_MAIL_ATTR_FROM, B_MAIL_ATTR_NAME,</a>
<a name="ln95">		B_MAIL_ATTR_PRIORITY, B_MAIL_ATTR_REPLY, B_MAIL_ATTR_STATUS,</a>
<a name="ln96">		B_MAIL_ATTR_SUBJECT, B_MAIL_ATTR_TO, B_MAIL_ATTR_THREAD,</a>
<a name="ln97">		B_MAIL_ATTR_ACCOUNT, NULL</a>
<a name="ln98">	};</a>
<a name="ln99"> </a>
<a name="ln100">	// add mail indices for all devices capable of querying</a>
<a name="ln101"> </a>
<a name="ln102">	int32 cookie = 0;</a>
<a name="ln103">	dev_t device;</a>
<a name="ln104">	while ((device = next_dev(&amp;cookie)) &gt;= B_OK) {</a>
<a name="ln105">		fs_info info;</a>
<a name="ln106">		if (fs_stat_dev(device, &amp;info) &lt; 0</a>
<a name="ln107">			|| (info.flags &amp; B_FS_HAS_QUERY) == 0)</a>
<a name="ln108">			continue;</a>
<a name="ln109"> </a>
<a name="ln110">		for (int32 i = 0; stringIndices[i]; i++)</a>
<a name="ln111">			fs_create_index(device, stringIndices[i], B_STRING_TYPE, 0);</a>
<a name="ln112"> </a>
<a name="ln113">		fs_create_index(device, &quot;MAIL:draft&quot;, B_INT32_TYPE, 0);</a>
<a name="ln114">		fs_create_index(device, B_MAIL_ATTR_WHEN, B_INT32_TYPE, 0);</a>
<a name="ln115">		fs_create_index(device, B_MAIL_ATTR_FLAGS, B_INT32_TYPE, 0);</a>
<a name="ln116">		fs_create_index(device, B_MAIL_ATTR_ACCOUNT_ID, B_INT32_TYPE, 0);</a>
<a name="ln117">		fs_create_index(device, B_MAIL_ATTR_READ, B_INT32_TYPE, 0);</a>
<a name="ln118">	}</a>
<a name="ln119">}</a>
<a name="ln120"> </a>
<a name="ln121"> </a>
<a name="ln122">static void</a>
<a name="ln123">addAttribute(BMessage&amp; msg, const char* name, const char* publicName,</a>
<a name="ln124">	int32 type = B_STRING_TYPE, bool viewable = true, bool editable = false,</a>
<a name="ln125">	int32 width = 200)</a>
<a name="ln126">{</a>
<a name="ln127">	msg.AddString(&quot;attr:name&quot;, name);</a>
<a name="ln128">	msg.AddString(&quot;attr:public_name&quot;, publicName);</a>
<a name="ln129">	msg.AddInt32(&quot;attr:type&quot;, type);</a>
<a name="ln130">	msg.AddBool(&quot;attr:viewable&quot;, viewable);</a>
<a name="ln131">	msg.AddBool(&quot;attr:editable&quot;, editable);</a>
<a name="ln132">	msg.AddInt32(&quot;attr:width&quot;, width);</a>
<a name="ln133">	msg.AddInt32(&quot;attr:alignment&quot;, B_ALIGN_LEFT);</a>
<a name="ln134">}</a>
<a name="ln135"> </a>
<a name="ln136"> </a>
<a name="ln137">// #pragma mark -</a>
<a name="ln138"> </a>
<a name="ln139"> </a>
<a name="ln140">account_protocols::account_protocols()</a>
<a name="ln141">	:</a>
<a name="ln142">	inboundImage(-1),</a>
<a name="ln143">	inboundProtocol(NULL),</a>
<a name="ln144">	outboundImage(-1),</a>
<a name="ln145">	outboundProtocol(NULL)</a>
<a name="ln146">{</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149"> </a>
<a name="ln150">// #pragma mark -</a>
<a name="ln151"> </a>
<a name="ln152"> </a>
<a name="ln153">MailDaemonApplication::MailDaemonApplication()</a>
<a name="ln154">	:</a>
<a name="ln155">	BServer(B_MAIL_DAEMON_SIGNATURE, true, NULL),</a>
<a name="ln156">	fAutoCheckRunner(NULL)</a>
<a name="ln157">{</a>
<a name="ln158">	fErrorLogWindow = new ErrorLogWindow(BRect(200, 200, 500, 250),</a>
<a name="ln159">		B_TRANSLATE(&quot;Mail daemon status log&quot;), B_TITLED_WINDOW);</a>
<a name="ln160">	// install MimeTypes, attributes, indices, and the</a>
<a name="ln161">	// system beep add startup</a>
<a name="ln162">	MakeMimeTypes();</a>
<a name="ln163">	makeIndices();</a>
<a name="ln164">	add_system_beep_event(&quot;New E-mail&quot;);</a>
<a name="ln165">}</a>
<a name="ln166"> </a>
<a name="ln167"> </a>
<a name="ln168">MailDaemonApplication::~MailDaemonApplication()</a>
<a name="ln169">{</a>
<a name="ln170">	delete fAutoCheckRunner;</a>
<a name="ln171"> </a>
<a name="ln172">	for (int32 i = 0; i &lt; fQueries.CountItems(); i++)</a>
<a name="ln173">		delete fQueries.ItemAt(i);</a>
<a name="ln174"> </a>
<a name="ln175">	while (!fAccounts.empty()) {</a>
<a name="ln176">		_RemoveAccount(fAccounts.begin()-&gt;second);</a>
<a name="ln177">		fAccounts.erase(fAccounts.begin());</a>
<a name="ln178">	}</a>
<a name="ln179"> </a>
<a name="ln180">	delete fLEDAnimation;</a>
<a name="ln181">	delete fNotification;</a>
<a name="ln182">}</a>
<a name="ln183"> </a>
<a name="ln184"> </a>
<a name="ln185">void</a>
<a name="ln186">MailDaemonApplication::ReadyToRun()</a>
<a name="ln187">{</a>
<a name="ln188">	InstallDeskbarIcon();</a>
<a name="ln189"> </a>
<a name="ln190">	_InitAccounts();</a>
<a name="ln191"> </a>
<a name="ln192">	// Start auto mail check with a delay</a>
<a name="ln193">	BMessage startAutoCheck(kMsgStartAutoCheck);</a>
<a name="ln194">	BMessageRunner::StartSending(this, &amp;startAutoCheck,</a>
<a name="ln195">		kStartAutoCheckDelay, 1);</a>
<a name="ln196"> </a>
<a name="ln197">	_InitNewMessagesCount();</a>
<a name="ln198"> </a>
<a name="ln199">	fCentralBeep = false;</a>
<a name="ln200"> </a>
<a name="ln201">	fNotification = new BNotification(B_INFORMATION_NOTIFICATION);</a>
<a name="ln202">	fNotification-&gt;SetGroup(B_TRANSLATE(&quot;Mail status&quot;));</a>
<a name="ln203">	fNotification-&gt;SetMessageID(&quot;daemon_status&quot;);</a>
<a name="ln204">	_UpdateNewMessagesNotification();</a>
<a name="ln205"> </a>
<a name="ln206">	app_info info;</a>
<a name="ln207">	be_roster-&gt;GetAppInfo(B_MAIL_DAEMON_SIGNATURE, &amp;info);</a>
<a name="ln208">	BBitmap icon(BRect(0, 0, 32, 32), B_RGBA32);</a>
<a name="ln209">	BNode node(&amp;info.ref);</a>
<a name="ln210">	BIconUtils::GetVectorIcon(&amp;node, &quot;BEOS:ICON&quot;, &amp;icon);</a>
<a name="ln211">	fNotification-&gt;SetIcon(&amp;icon);</a>
<a name="ln212"> </a>
<a name="ln213">	fLEDAnimation = new LEDAnimation();</a>
<a name="ln214">	SetPulseRate(1000000);</a>
<a name="ln215">}</a>
<a name="ln216"> </a>
<a name="ln217"> </a>
<a name="ln218">void</a>
<a name="ln219">MailDaemonApplication::RefsReceived(BMessage* message)</a>
<a name="ln220">{</a>
<a name="ln221">	entry_ref ref;</a>
<a name="ln222">	for (int32 i = 0; message-&gt;FindRef(&quot;refs&quot;, i, &amp;ref) == B_OK; i++) {</a>
<a name="ln223">		BNode node(&amp;ref);</a>
<a name="ln224">		if (node.InitCheck() != B_OK)</a>
<a name="ln225">			continue;</a>
<a name="ln226"> </a>
<a name="ln227">		int32 account;</a>
<a name="ln228">		if (node.ReadAttr(B_MAIL_ATTR_ACCOUNT_ID, B_INT32_TYPE, 0, &amp;account,</a>
<a name="ln229">				sizeof(account)) &lt; 0)</a>
<a name="ln230">			continue;</a>
<a name="ln231"> </a>
<a name="ln232">		BInboundMailProtocol* protocol = _InboundProtocol(account);</a>
<a name="ln233">		if (protocol == NULL)</a>
<a name="ln234">			continue;</a>
<a name="ln235"> </a>
<a name="ln236">		BMessenger target;</a>
<a name="ln237">		BMessenger* replyTo = &amp;target;</a>
<a name="ln238">		if (message-&gt;FindMessenger(&quot;target&quot;, &amp;target) != B_OK)</a>
<a name="ln239">			replyTo = NULL;</a>
<a name="ln240"> </a>
<a name="ln241">		protocol-&gt;FetchBody(ref, replyTo);</a>
<a name="ln242">	}</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245"> </a>
<a name="ln246">void</a>
<a name="ln247">MailDaemonApplication::MessageReceived(BMessage* msg)</a>
<a name="ln248">{</a>
<a name="ln249">	switch (msg-&gt;what) {</a>
<a name="ln250">		case kMsgStartAutoCheck:</a>
<a name="ln251">			_UpdateAutoCheckRunner();</a>
<a name="ln252">			break;</a>
<a name="ln253"> </a>
<a name="ln254">		case kMsgAutoCheck:</a>
<a name="ln255">			// TODO: check whether internet is up and running!</a>
<a name="ln256">			// supposed to fall through</a>
<a name="ln257">		case kMsgCheckAndSend:	// check &amp; send messages</a>
<a name="ln258">			msg-&gt;what = kMsgSendMessages;</a>
<a name="ln259">			PostMessage(msg);</a>
<a name="ln260">			// supposed to fall trough</a>
<a name="ln261">		case kMsgCheckMessage:	// check messages</a>
<a name="ln262">			GetNewMessages(msg);</a>
<a name="ln263">			break;</a>
<a name="ln264"> </a>
<a name="ln265">		case kMsgSendMessages:	// send messages</a>
<a name="ln266">			SendPendingMessages(msg);</a>
<a name="ln267">			break;</a>
<a name="ln268"> </a>
<a name="ln269">		case kMsgSettingsUpdated:</a>
<a name="ln270">			fSettingsFile.Reload();</a>
<a name="ln271">			_UpdateAutoCheckRunner();</a>
<a name="ln272">			break;</a>
<a name="ln273"> </a>
<a name="ln274">		case kMsgAccountsChanged:</a>
<a name="ln275">			_ReloadAccounts(msg);</a>
<a name="ln276">			break;</a>
<a name="ln277"> </a>
<a name="ln278">		case kMsgMarkMessageAsRead:</a>
<a name="ln279">		{</a>
<a name="ln280">			int32 account = msg-&gt;FindInt32(&quot;account&quot;);</a>
<a name="ln281">			entry_ref ref;</a>
<a name="ln282">			if (msg-&gt;FindRef(&quot;ref&quot;, &amp;ref) != B_OK)</a>
<a name="ln283">				break;</a>
<a name="ln284">			read_flags read = (read_flags)msg-&gt;FindInt32(&quot;read&quot;);</a>
<a name="ln285"> </a>
<a name="ln286">			BInboundMailProtocol* protocol = _InboundProtocol(account);</a>
<a name="ln287">			if (protocol != NULL)</a>
<a name="ln288">				InboundMessenger(protocol).MarkAsRead(ref, read);</a>
<a name="ln289">			break;</a>
<a name="ln290">		}</a>
<a name="ln291"> </a>
<a name="ln292">		case kMsgFetchBody:</a>
<a name="ln293">			RefsReceived(msg);</a>
<a name="ln294">			break;</a>
<a name="ln295"> </a>
<a name="ln296">		case 'stwg':	// Status window gone</a>
<a name="ln297">		{</a>
<a name="ln298">			BMessage reply('mnuc');</a>
<a name="ln299">			reply.AddInt32(&quot;num_new_messages&quot;, fNewMessages);</a>
<a name="ln300"> </a>
<a name="ln301">			while ((msg = fFetchDoneRespondents.RemoveItemAt(0))) {</a>
<a name="ln302">				msg-&gt;SendReply(&amp;reply);</a>
<a name="ln303">				delete msg;</a>
<a name="ln304">			}</a>
<a name="ln305"> </a>
<a name="ln306">			if (fAlertString != B_EMPTY_STRING) {</a>
<a name="ln307">				fAlertString.Truncate(fAlertString.Length() - 1);</a>
<a name="ln308">				BAlert* alert = new BAlert(B_TRANSLATE(&quot;New Messages&quot;),</a>
<a name="ln309">					fAlertString.String(), &quot;OK&quot;, NULL, NULL, B_WIDTH_AS_USUAL);</a>
<a name="ln310">				alert-&gt;SetFeel(B_NORMAL_WINDOW_FEEL);</a>
<a name="ln311">				alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln312">				alert-&gt;Go(NULL);</a>
<a name="ln313">				fAlertString = B_EMPTY_STRING;</a>
<a name="ln314">			}</a>
<a name="ln315"> </a>
<a name="ln316">			if (fCentralBeep) {</a>
<a name="ln317">				system_beep(&quot;New E-mail&quot;);</a>
<a name="ln318">				fCentralBeep = false;</a>
<a name="ln319">			}</a>
<a name="ln320">			break;</a>
<a name="ln321">		}</a>
<a name="ln322"> </a>
<a name="ln323">		case 'mcbp':</a>
<a name="ln324">			if (fNewMessages &gt; 0)</a>
<a name="ln325">				fCentralBeep = true;</a>
<a name="ln326">			break;</a>
<a name="ln327"> </a>
<a name="ln328">		case kMsgCountNewMessages:	// Number of new messages</a>
<a name="ln329">		{</a>
<a name="ln330">			BMessage reply('mnuc');	// Mail New message Count</a>
<a name="ln331">			if (msg-&gt;FindBool(&quot;wait_for_fetch_done&quot;)) {</a>
<a name="ln332">				fFetchDoneRespondents.AddItem(DetachCurrentMessage());</a>
<a name="ln333">				break;</a>
<a name="ln334">			}</a>
<a name="ln335"> </a>
<a name="ln336">			reply.AddInt32(&quot;num_new_messages&quot;, fNewMessages);</a>
<a name="ln337">			msg-&gt;SendReply(&amp;reply);</a>
<a name="ln338">			break;</a>
<a name="ln339">		}</a>
<a name="ln340"> </a>
<a name="ln341">		case 'mblk':	// Mail Blink</a>
<a name="ln342">			if (fNewMessages &gt; 0)</a>
<a name="ln343">				fLEDAnimation-&gt;Start();</a>
<a name="ln344">			break;</a>
<a name="ln345"> </a>
<a name="ln346">		case 'enda':	// End Auto Check</a>
<a name="ln347">			delete fAutoCheckRunner;</a>
<a name="ln348">			fAutoCheckRunner = NULL;</a>
<a name="ln349">			break;</a>
<a name="ln350"> </a>
<a name="ln351">		case 'numg':</a>
<a name="ln352">		{</a>
<a name="ln353">			static BStringFormat format(B_TRANSLATE(&quot;{0, plural, &quot;</a>
<a name="ln354">				&quot;one{# new message} other{# new messages}} for %name\n&quot;));</a>
<a name="ln355"> </a>
<a name="ln356">			int32 numMessages = msg-&gt;FindInt32(&quot;num_messages&quot;);</a>
<a name="ln357">			fAlertString.Truncate(0);</a>
<a name="ln358">			format.Format(fAlertString, numMessages);</a>
<a name="ln359">			fAlertString.ReplaceFirst(&quot;%name&quot;, msg-&gt;FindString(&quot;name&quot;));</a>
<a name="ln360">			break;</a>
<a name="ln361">		}</a>
<a name="ln362"> </a>
<a name="ln363">		case B_QUERY_UPDATE:</a>
<a name="ln364">		{</a>
<a name="ln365">			int32 previousCount = fNewMessages;</a>
<a name="ln366"> </a>
<a name="ln367">			int32 opcode = msg-&gt;GetInt32(&quot;opcode&quot;, -1);</a>
<a name="ln368">			switch (opcode) {</a>
<a name="ln369">				case B_ENTRY_CREATED:</a>
<a name="ln370">					fNewMessages++;</a>
<a name="ln371">					break;</a>
<a name="ln372">				case B_ENTRY_REMOVED:</a>
<a name="ln373">					fNewMessages--;</a>
<a name="ln374">					break;</a>
<a name="ln375">				default:</a>
<a name="ln376">					return;</a>
<a name="ln377">			}</a>
<a name="ln378"> </a>
<a name="ln379">			_UpdateNewMessagesNotification();</a>
<a name="ln380"> </a>
<a name="ln381">			if (fSettingsFile.ShowStatusWindow()</a>
<a name="ln382">					!= B_MAIL_SHOW_STATUS_WINDOW_NEVER</a>
<a name="ln383">				&amp;&amp; previousCount &lt; fNewMessages) {</a>
<a name="ln384">				fNotification-&gt;Send();</a>
<a name="ln385">			}</a>
<a name="ln386">			break;</a>
<a name="ln387">		}</a>
<a name="ln388"> </a>
<a name="ln389">		default:</a>
<a name="ln390">			BApplication::MessageReceived(msg);</a>
<a name="ln391">			break;</a>
<a name="ln392">	}</a>
<a name="ln393">}</a>
<a name="ln394"> </a>
<a name="ln395"> </a>
<a name="ln396">void</a>
<a name="ln397">MailDaemonApplication::Pulse()</a>
<a name="ln398">{</a>
<a name="ln399">	bigtime_t idle = idle_time();</a>
<a name="ln400">	if (fLEDAnimation-&gt;IsRunning() &amp;&amp; idle &lt; 100000)</a>
<a name="ln401">		fLEDAnimation-&gt;Stop();</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404"> </a>
<a name="ln405">bool</a>
<a name="ln406">MailDaemonApplication::QuitRequested()</a>
<a name="ln407">{</a>
<a name="ln408">	RemoveDeskbarIcon();</a>
<a name="ln409">	return true;</a>
<a name="ln410">}</a>
<a name="ln411"> </a>
<a name="ln412"> </a>
<a name="ln413">void</a>
<a name="ln414">MailDaemonApplication::InstallDeskbarIcon()</a>
<a name="ln415">{</a>
<a name="ln416">	BDeskbar deskbar;</a>
<a name="ln417"> </a>
<a name="ln418">	if (!deskbar.HasItem(&quot;mail_daemon&quot;)) {</a>
<a name="ln419">		BRoster roster;</a>
<a name="ln420">		entry_ref ref;</a>
<a name="ln421"> </a>
<a name="ln422">		status_t status = roster.FindApp(B_MAIL_DAEMON_SIGNATURE, &amp;ref);</a>
<a name="ln423">		if (status &lt; B_OK) {</a>
<a name="ln424">			fprintf(stderr, &quot;Can't find application to tell deskbar: %s\n&quot;,</a>
<a name="ln425">				strerror(status));</a>
<a name="ln426">			return;</a>
<a name="ln427">		}</a>
<a name="ln428"> </a>
<a name="ln429">		status = deskbar.AddItem(&amp;ref);</a>
<a name="ln430">		if (status &lt; B_OK) {</a>
<a name="ln431">			fprintf(stderr, &quot;Can't add deskbar replicant: %s\n&quot;,</a>
<a name="ln432">				strerror(status));</a>
<a name="ln433">			return;</a>
<a name="ln434">		}</a>
<a name="ln435">	}</a>
<a name="ln436">}</a>
<a name="ln437"> </a>
<a name="ln438"> </a>
<a name="ln439">void</a>
<a name="ln440">MailDaemonApplication::RemoveDeskbarIcon()</a>
<a name="ln441">{</a>
<a name="ln442">	BDeskbar deskbar;</a>
<a name="ln443">	if (deskbar.HasItem(&quot;mail_daemon&quot;))</a>
<a name="ln444">		deskbar.RemoveItem(&quot;mail_daemon&quot;);</a>
<a name="ln445">}</a>
<a name="ln446"> </a>
<a name="ln447"> </a>
<a name="ln448">void</a>
<a name="ln449">MailDaemonApplication::GetNewMessages(BMessage* msg)</a>
<a name="ln450">{</a>
<a name="ln451">	int32 account = -1;</a>
<a name="ln452">	if (msg-&gt;FindInt32(&quot;account&quot;, &amp;account) == B_OK &amp;&amp; account &gt;= 0) {</a>
<a name="ln453">		// Check the single requested account</a>
<a name="ln454">		BInboundMailProtocol* protocol = _InboundProtocol(account);</a>
<a name="ln455">		if (protocol != NULL)</a>
<a name="ln456">			InboundMessenger(protocol).SynchronizeMessages();</a>
<a name="ln457">		return;</a>
<a name="ln458">	}</a>
<a name="ln459"> </a>
<a name="ln460">	// Check all accounts</a>
<a name="ln461"> </a>
<a name="ln462">	AccountMap::const_iterator iterator = fAccounts.begin();</a>
<a name="ln463">	for (; iterator != fAccounts.end(); iterator++) {</a>
<a name="ln464">		BInboundMailProtocol* protocol = iterator-&gt;second.inboundProtocol;</a>
<a name="ln465">		if (protocol != NULL)</a>
<a name="ln466">			InboundMessenger(protocol).SynchronizeMessages();</a>
<a name="ln467">	}</a>
<a name="ln468">}</a>
<a name="ln469"> </a>
<a name="ln470"> </a>
<a name="ln471">void</a>
<a name="ln472">MailDaemonApplication::SendPendingMessages(BMessage* msg)</a>
<a name="ln473">{</a>
<a name="ln474">	BVolumeRoster roster;</a>
<a name="ln475">	BVolume volume;</a>
<a name="ln476">	std::map&lt;int32, send_mails_info&gt; messages;</a>
<a name="ln477">	int32 account = msg-&gt;GetInt32(&quot;account&quot;, -1);</a>
<a name="ln478"> </a>
<a name="ln479">	if (!msg-&gt;HasString(&quot;message_path&quot;)) {</a>
<a name="ln480">		while (roster.GetNextVolume(&amp;volume) == B_OK) {</a>
<a name="ln481">			BQuery query;</a>
<a name="ln482">			query.SetVolume(&amp;volume);</a>
<a name="ln483">			query.PushAttr(B_MAIL_ATTR_FLAGS);</a>
<a name="ln484">			query.PushInt32(B_MAIL_PENDING);</a>
<a name="ln485">			query.PushOp(B_EQ);</a>
<a name="ln486"> </a>
<a name="ln487">			query.PushAttr(B_MAIL_ATTR_FLAGS);</a>
<a name="ln488">			query.PushInt32(B_MAIL_PENDING | B_MAIL_SAVE);</a>
<a name="ln489">			query.PushOp(B_EQ);</a>
<a name="ln490"> </a>
<a name="ln491">			if (account &gt;= 0) {</a>
<a name="ln492">				query.PushAttr(B_MAIL_ATTR_ACCOUNT_ID);</a>
<a name="ln493">				query.PushInt32(account);</a>
<a name="ln494">				query.PushOp(B_EQ);</a>
<a name="ln495">				query.PushOp(B_AND);</a>
<a name="ln496">			}</a>
<a name="ln497"> </a>
<a name="ln498">			query.PushOp(B_OR);</a>
<a name="ln499">			query.Fetch();</a>
<a name="ln500">			BEntry entry;</a>
<a name="ln501">			while (query.GetNextEntry(&amp;entry) == B_OK) {</a>
<a name="ln502">				if (_IsEntryInTrash(entry))</a>
<a name="ln503">					continue;</a>
<a name="ln504"> </a>
<a name="ln505">				BNode node;</a>
<a name="ln506">				while (node.SetTo(&amp;entry) == B_BUSY)</a>
<a name="ln507">					snooze(1000);</a>
<a name="ln508">				if (!_IsPending(node))</a>
<a name="ln509">					continue;</a>
<a name="ln510"> </a>
<a name="ln511">				if (node.ReadAttr(B_MAIL_ATTR_ACCOUNT_ID, B_INT32_TYPE, 0,</a>
<a name="ln512">						&amp;account, sizeof(int32)) &lt; 0)</a>
<a name="ln513">					account = -1;</a>
<a name="ln514"> </a>
<a name="ln515">				_AddMessage(messages[account], entry, node);</a>
<a name="ln516">			}</a>
<a name="ln517">		}</a>
<a name="ln518">	} else {</a>
<a name="ln519">		// Send the requested message only</a>
<a name="ln520">		const char* path;</a>
<a name="ln521">		if (msg-&gt;FindString(&quot;message_path&quot;, &amp;path) != B_OK)</a>
<a name="ln522">			return;</a>
<a name="ln523"> </a>
<a name="ln524">		BEntry entry(path);</a>
<a name="ln525">		_AddMessage(messages[account], entry, BNode(&amp;entry));</a>
<a name="ln526">	}</a>
<a name="ln527"> </a>
<a name="ln528">	std::map&lt;int32, send_mails_info&gt;::iterator iterator = messages.begin();</a>
<a name="ln529">	for (; iterator != messages.end(); iterator++) {</a>
<a name="ln530">		BOutboundMailProtocol* protocol = _OutboundProtocol(iterator-&gt;first);</a>
<a name="ln531">		if (protocol == NULL)</a>
<a name="ln532">			continue;</a>
<a name="ln533"> </a>
<a name="ln534">		send_mails_info&amp; info = iterator-&gt;second;</a>
<a name="ln535">		if (info.bytes == 0)</a>
<a name="ln536">			continue;</a>
<a name="ln537"> </a>
<a name="ln538">		protocol-&gt;SendMessages(info.files, info.bytes);</a>
<a name="ln539">	}</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542"> </a>
<a name="ln543">void</a>
<a name="ln544">MailDaemonApplication::MakeMimeTypes(bool remakeMIMETypes)</a>
<a name="ln545">{</a>
<a name="ln546">	// Add MIME database entries for the e-mail file types we handle.  Either</a>
<a name="ln547">	// do a full rebuild from nothing, or just add on the new attributes that</a>
<a name="ln548">	// we support which the regular BeOS mail daemon didn't have.</a>
<a name="ln549"> </a>
<a name="ln550">	const uint8 kNTypes = 2;</a>
<a name="ln551">	const char* types[kNTypes] = {&quot;text/x-email&quot;, &quot;text/x-partial-email&quot;};</a>
<a name="ln552"> </a>
<a name="ln553">	for (size_t i = 0; i &lt; kNTypes; i++) {</a>
<a name="ln554">		BMessage info;</a>
<a name="ln555">		BMimeType mime(types[i]);</a>
<a name="ln556">		if (mime.InitCheck() != B_OK) {</a>
<a name="ln557">			fputs(&quot;could not init mime type.\n&quot;, stderr);</a>
<a name="ln558">			return;</a>
<a name="ln559">		}</a>
<a name="ln560"> </a>
<a name="ln561">		if (!mime.IsInstalled() || remakeMIMETypes) {</a>
<a name="ln562">			// install the full mime type</a>
<a name="ln563">			mime.Delete();</a>
<a name="ln564">			mime.Install();</a>
<a name="ln565"> </a>
<a name="ln566">			// Set up the list of e-mail related attributes that Tracker will</a>
<a name="ln567">			// let you display in columns for e-mail messages.</a>
<a name="ln568">			addAttribute(info, B_MAIL_ATTR_NAME, &quot;Name&quot;);</a>
<a name="ln569">			addAttribute(info, B_MAIL_ATTR_SUBJECT, &quot;Subject&quot;);</a>
<a name="ln570">			addAttribute(info, B_MAIL_ATTR_TO, &quot;To&quot;);</a>
<a name="ln571">			addAttribute(info, B_MAIL_ATTR_CC, &quot;Cc&quot;);</a>
<a name="ln572">			addAttribute(info, B_MAIL_ATTR_FROM, &quot;From&quot;);</a>
<a name="ln573">			addAttribute(info, B_MAIL_ATTR_REPLY, &quot;Reply To&quot;);</a>
<a name="ln574">			addAttribute(info, B_MAIL_ATTR_STATUS, &quot;Status&quot;);</a>
<a name="ln575">			addAttribute(info, B_MAIL_ATTR_PRIORITY, &quot;Priority&quot;, B_STRING_TYPE,</a>
<a name="ln576">				true, true, 40);</a>
<a name="ln577">			addAttribute(info, B_MAIL_ATTR_WHEN, &quot;When&quot;, B_TIME_TYPE, true,</a>
<a name="ln578">				false, 150);</a>
<a name="ln579">			addAttribute(info, B_MAIL_ATTR_THREAD, &quot;Thread&quot;);</a>
<a name="ln580">			addAttribute(info, B_MAIL_ATTR_ACCOUNT, &quot;Account&quot;, B_STRING_TYPE,</a>
<a name="ln581">				true, false, 100);</a>
<a name="ln582">			addAttribute(info, B_MAIL_ATTR_READ, &quot;Read&quot;, B_INT32_TYPE,</a>
<a name="ln583">				true, false, 70);</a>
<a name="ln584">			mime.SetAttrInfo(&amp;info);</a>
<a name="ln585"> </a>
<a name="ln586">			if (i == 0) {</a>
<a name="ln587">				mime.SetShortDescription(&quot;E-mail&quot;);</a>
<a name="ln588">				mime.SetLongDescription(&quot;Electronic Mail Message&quot;);</a>
<a name="ln589">				mime.SetPreferredApp(&quot;application/x-vnd.Be-MAIL&quot;);</a>
<a name="ln590">			} else {</a>
<a name="ln591">				mime.SetShortDescription(&quot;Partial E-mail&quot;);</a>
<a name="ln592">				mime.SetLongDescription(&quot;A Partially Downloaded E-mail&quot;);</a>
<a name="ln593">				mime.SetPreferredApp(&quot;application/x-vnd.Be-MAIL&quot;);</a>
<a name="ln594">			}</a>
<a name="ln595">		}</a>
<a name="ln596">	}</a>
<a name="ln597">}</a>
<a name="ln598"> </a>
<a name="ln599"> </a>
<a name="ln600">void</a>
<a name="ln601">MailDaemonApplication::_InitAccounts()</a>
<a name="ln602">{</a>
<a name="ln603">	BMailAccounts accounts;</a>
<a name="ln604">	for (int i = 0; i &lt; accounts.CountAccounts(); i++)</a>
<a name="ln605">		_InitAccount(*accounts.AccountAt(i));</a>
<a name="ln606">}</a>
<a name="ln607"> </a>
<a name="ln608"> </a>
<a name="ln609">void</a>
<a name="ln610">MailDaemonApplication::_InitAccount(BMailAccountSettings&amp; settings)</a>
<a name="ln611">{</a>
<a name="ln612">	account_protocols account;</a>
<a name="ln613"> </a>
<a name="ln614">	// inbound</a>
<a name="ln615">	if (settings.IsInboundEnabled()) {</a>
<a name="ln616">		account.inboundProtocol = _CreateInboundProtocol(settings,</a>
<a name="ln617">			account.inboundImage);</a>
<a name="ln618">	}</a>
<a name="ln619">	if (account.inboundProtocol != NULL) {</a>
<a name="ln620">		DefaultNotifier* notifier = new DefaultNotifier(settings.Name(), true,</a>
<a name="ln621">			fErrorLogWindow, fSettingsFile.ShowStatusWindow());</a>
<a name="ln622">		account.inboundProtocol-&gt;SetMailNotifier(notifier);</a>
<a name="ln623">		account.inboundProtocol-&gt;Run();</a>
<a name="ln624">	}</a>
<a name="ln625"> </a>
<a name="ln626">	// outbound</a>
<a name="ln627">	if (settings.IsOutboundEnabled()) {</a>
<a name="ln628">		account.outboundProtocol = _CreateOutboundProtocol(settings,</a>
<a name="ln629">			account.outboundImage);</a>
<a name="ln630">	}</a>
<a name="ln631">	if (account.outboundProtocol != NULL) {</a>
<a name="ln632">		DefaultNotifier* notifier = new DefaultNotifier(settings.Name(), false,</a>
<a name="ln633">			fErrorLogWindow, fSettingsFile.ShowStatusWindow());</a>
<a name="ln634">		account.outboundProtocol-&gt;SetMailNotifier(notifier);</a>
<a name="ln635">		account.outboundProtocol-&gt;Run();</a>
<a name="ln636">	}</a>
<a name="ln637"> </a>
<a name="ln638">	printf(&quot;account name %s, id %i, in %p, out %p\n&quot;, settings.Name(),</a>
<a name="ln639">		(int)settings.AccountID(), account.inboundProtocol,</a>
<a name="ln640">		account.outboundProtocol);</a>
<a name="ln641"> </a>
<a name="ln642">	if (account.inboundProtocol != NULL || account.outboundProtocol != NULL)</a>
<a name="ln643">		fAccounts[settings.AccountID()] = account;</a>
<a name="ln644">}</a>
<a name="ln645"> </a>
<a name="ln646"> </a>
<a name="ln647">void</a>
<a name="ln648">MailDaemonApplication::_ReloadAccounts(BMessage* message)</a>
<a name="ln649">{</a>
<a name="ln650">	type_code typeFound;</a>
<a name="ln651">	int32 countFound;</a>
<a name="ln652">	message-&gt;GetInfo(&quot;account&quot;, &amp;typeFound, &amp;countFound);</a>
<a name="ln653">	if (typeFound != B_INT32_TYPE)</a>
<a name="ln654">		return;</a>
<a name="ln655"> </a>
<a name="ln656">	// reload accounts</a>
<a name="ln657">	BMailAccounts accounts;</a>
<a name="ln658"> </a>
<a name="ln659">	for (int i = 0; i &lt; countFound; i++) {</a>
<a name="ln660">		int32 account = message-&gt;FindInt32(&quot;account&quot;, i);</a>
<a name="ln661">		AccountMap::iterator found = fAccounts.find(account);</a>
<a name="ln662">		if (found != fAccounts.end()) {</a>
<a name="ln663">			_RemoveAccount(found-&gt;second);</a>
<a name="ln664">			fAccounts.erase(found);</a>
<a name="ln665">		}</a>
<a name="ln666"> </a>
<a name="ln667">		BMailAccountSettings* settings = accounts.AccountByID(account);</a>
<a name="ln668">		if (settings != NULL)</a>
<a name="ln669">			_InitAccount(*settings);</a>
<a name="ln670">	}</a>
<a name="ln671">}</a>
<a name="ln672"> </a>
<a name="ln673"> </a>
<a name="ln674">void</a>
<a name="ln675">MailDaemonApplication::_RemoveAccount(const account_protocols&amp; account)</a>
<a name="ln676">{</a>
<a name="ln677">	if (account.inboundProtocol != NULL) {</a>
<a name="ln678">		account.inboundProtocol-&gt;Lock();</a>
<a name="ln679">		account.inboundProtocol-&gt;Quit();</a>
<a name="ln680"> </a>
<a name="ln681">		unload_add_on(account.inboundImage);</a>
<a name="ln682">	}</a>
<a name="ln683"> </a>
<a name="ln684">	if (account.outboundProtocol != NULL) {</a>
<a name="ln685">		account.outboundProtocol-&gt;Lock();</a>
<a name="ln686">		account.outboundProtocol-&gt;Quit();</a>
<a name="ln687"> </a>
<a name="ln688">		unload_add_on(account.outboundImage);</a>
<a name="ln689">	}</a>
<a name="ln690">}</a>
<a name="ln691"> </a>
<a name="ln692"> </a>
<a name="ln693">BInboundMailProtocol*</a>
<a name="ln694">MailDaemonApplication::_CreateInboundProtocol(BMailAccountSettings&amp; settings,</a>
<a name="ln695">	image_id&amp; image)</a>
<a name="ln696">{</a>
<a name="ln697">	const entry_ref&amp; entry = settings.InboundAddOnRef();</a>
<a name="ln698">	BInboundMailProtocol* (*instantiateProtocol)(BMailAccountSettings*);</a>
<a name="ln699"> </a>
<a name="ln700">	BPath path(&amp;entry);</a>
<a name="ln701">	image = load_add_on(path.Path());</a>
<a name="ln702">	if (image &lt; 0)</a>
<a name="ln703">		return NULL;</a>
<a name="ln704"> </a>
<a name="ln705">	if (get_image_symbol(image, &quot;instantiate_inbound_protocol&quot;,</a>
<a name="ln706">			B_SYMBOL_TYPE_TEXT, (void**)&amp;instantiateProtocol) != B_OK) {</a>
<a name="ln707">		unload_add_on(image);</a>
<a name="ln708">		image = -1;</a>
<a name="ln709">		return NULL;</a>
<a name="ln710">	}</a>
<a name="ln711">	return instantiateProtocol(&amp;settings);</a>
<a name="ln712">}</a>
<a name="ln713"> </a>
<a name="ln714"> </a>
<a name="ln715">BOutboundMailProtocol*</a>
<a name="ln716">MailDaemonApplication::_CreateOutboundProtocol(BMailAccountSettings&amp; settings,</a>
<a name="ln717">	image_id&amp; image)</a>
<a name="ln718">{</a>
<a name="ln719">	const entry_ref&amp; entry = settings.OutboundAddOnRef();</a>
<a name="ln720">	BOutboundMailProtocol* (*instantiateProtocol)(BMailAccountSettings*);</a>
<a name="ln721"> </a>
<a name="ln722">	BPath path(&amp;entry);</a>
<a name="ln723">	image = load_add_on(path.Path());</a>
<a name="ln724">	if (image &lt; 0)</a>
<a name="ln725">		return NULL;</a>
<a name="ln726"> </a>
<a name="ln727">	if (get_image_symbol(image, &quot;instantiate_outbound_protocol&quot;,</a>
<a name="ln728">			B_SYMBOL_TYPE_TEXT, (void**)&amp;instantiateProtocol) != B_OK) {</a>
<a name="ln729">		unload_add_on(image);</a>
<a name="ln730">		image = -1;</a>
<a name="ln731">		return NULL;</a>
<a name="ln732">	}</a>
<a name="ln733">	return instantiateProtocol(&amp;settings);</a>
<a name="ln734">}</a>
<a name="ln735"> </a>
<a name="ln736"> </a>
<a name="ln737">BInboundMailProtocol*</a>
<a name="ln738">MailDaemonApplication::_InboundProtocol(int32 account)</a>
<a name="ln739">{</a>
<a name="ln740">	AccountMap::iterator found = fAccounts.find(account);</a>
<a name="ln741">	if (found == fAccounts.end())</a>
<a name="ln742">		return NULL;</a>
<a name="ln743">	return found-&gt;second.inboundProtocol;</a>
<a name="ln744">}</a>
<a name="ln745"> </a>
<a name="ln746"> </a>
<a name="ln747">BOutboundMailProtocol*</a>
<a name="ln748">MailDaemonApplication::_OutboundProtocol(int32 account)</a>
<a name="ln749">{</a>
<a name="ln750">	if (account &lt; 0)</a>
<a name="ln751">		account = BMailSettings().DefaultOutboundAccount();</a>
<a name="ln752"> </a>
<a name="ln753">	AccountMap::iterator found = fAccounts.find(account);</a>
<a name="ln754">	if (found == fAccounts.end())</a>
<a name="ln755">		return NULL;</a>
<a name="ln756">	return found-&gt;second.outboundProtocol;</a>
<a name="ln757">}</a>
<a name="ln758"> </a>
<a name="ln759"> </a>
<a name="ln760">void</a>
<a name="ln761">MailDaemonApplication::_InitNewMessagesCount()</a>
<a name="ln762">{</a>
<a name="ln763">	BVolume volume;</a>
<a name="ln764">	BVolumeRoster roster;</a>
<a name="ln765"> </a>
<a name="ln766">	fNewMessages = 0;</a>
<a name="ln767"> </a>
<a name="ln768">	while (roster.GetNextVolume(&amp;volume) == B_OK) {</a>
<a name="ln769">		BQuery* query = new BQuery;</a>
<a name="ln770"> </a>
<a name="ln771">		query-&gt;SetTarget(this);</a>
<a name="ln772">		query-&gt;SetVolume(&amp;volume);</a>
<a name="ln773">		query-&gt;PushAttr(B_MAIL_ATTR_STATUS);</a>
<a name="ln774">		query-&gt;PushString(&quot;New&quot;);</a>
<a name="ln775">		query-&gt;PushOp(B_EQ);</a>
<a name="ln776">		query-&gt;PushAttr(&quot;BEOS:TYPE&quot;);</a>
<a name="ln777">		query-&gt;PushString(&quot;text/x-email&quot;);</a>
<a name="ln778">		query-&gt;PushOp(B_EQ);</a>
<a name="ln779">		query-&gt;PushAttr(&quot;BEOS:TYPE&quot;);</a>
<a name="ln780">		query-&gt;PushString(&quot;text/x-partial-email&quot;);</a>
<a name="ln781">		query-&gt;PushOp(B_EQ);</a>
<a name="ln782">		query-&gt;PushOp(B_OR);</a>
<a name="ln783">		query-&gt;PushOp(B_AND);</a>
<a name="ln784">		query-&gt;Fetch();</a>
<a name="ln785"> </a>
<a name="ln786">		BEntry entry;</a>
<a name="ln787">		while (query-&gt;GetNextEntry(&amp;entry) == B_OK)</a>
<a name="ln788">			fNewMessages++;</a>
<a name="ln789"> </a>
<a name="ln790">		fQueries.AddItem(query);</a>
<a name="ln791">	}</a>
<a name="ln792">}</a>
<a name="ln793"> </a>
<a name="ln794"> </a>
<a name="ln795">void</a>
<a name="ln796">MailDaemonApplication::_UpdateNewMessagesNotification()</a>
<a name="ln797">{</a>
<a name="ln798">	BString title;</a>
<a name="ln799">	if (fNewMessages &gt; 0) {</a>
<a name="ln800">		BStringFormat format(B_TRANSLATE(</a>
<a name="ln801">			&quot;{0, plural, one{One new message} other{# new messages}}&quot;));</a>
<a name="ln802"> </a>
<a name="ln803">		format.Format(title, fNewMessages);</a>
<a name="ln804">	} else</a>
<a name="ln805">		title = B_TRANSLATE(&quot;No new messages&quot;);</a>
<a name="ln806"> </a>
<a name="ln807">	fNotification-&gt;SetTitle(title.String());</a>
<a name="ln808">}</a>
<a name="ln809"> </a>
<a name="ln810"> </a>
<a name="ln811">void</a>
<a name="ln812">MailDaemonApplication::_UpdateAutoCheckRunner()</a>
<a name="ln813">{</a>
<a name="ln814">	bigtime_t interval = fSettingsFile.AutoCheckInterval();</a>
<a name="ln815">	if (interval &gt; 0) {</a>
<a name="ln816">		if (fAutoCheckRunner != NULL) {</a>
<a name="ln817">			fAutoCheckRunner-&gt;SetInterval(interval);</a>
<a name="ln818">			fAutoCheckRunner-&gt;SetCount(-1);</a>
<a name="ln819">		} else {</a>
<a name="ln820">			BMessage update(kMsgAutoCheck);</a>
<a name="ln821">			fAutoCheckRunner = new BMessageRunner(be_app_messenger, &amp;update,</a>
<a name="ln822">				interval);</a>
<a name="ln823"> </a>
<a name="ln824">			// Send one right away -- the message runner will wait until the</a>
<a name="ln825">			// first interval has passed before sending a message</a>
<a name="ln826">			PostMessage(&amp;update);</a>
<a name="ln827">		}</a>
<a name="ln828">	} else {</a>
<a name="ln829">		delete fAutoCheckRunner;</a>
<a name="ln830">		fAutoCheckRunner = NULL;</a>
<a name="ln831">	}</a>
<a name="ln832">}</a>
<a name="ln833"> </a>
<a name="ln834"> </a>
<a name="ln835">void</a>
<a name="ln836">MailDaemonApplication::_AddMessage(send_mails_info&amp; info, const BEntry&amp; entry,</a>
<a name="ln837">	const BNode&amp; node)</a>
<a name="ln838">{</a>
<a name="ln839">	entry_ref ref;</a>
<a name="ln840">	off_t size;</a>
<a name="ln841">	if (node.GetSize(&amp;size) == B_OK &amp;&amp; entry.GetRef(&amp;ref) == B_OK) {</a>
<a name="ln842">		info.files.AddRef(&quot;ref&quot;, &amp;ref);</a>
<a name="ln843">		info.bytes += size;</a>
<a name="ln844">	}</a>
<a name="ln845">}</a>
<a name="ln846"> </a>
<a name="ln847"> </a>
<a name="ln848">/*!	Work-around for a broken index that contains out-of-date information.</a>
<a name="ln849">*/</a>
<a name="ln850">/*static*/ bool</a>
<a name="ln851">MailDaemonApplication::_IsPending(BNode&amp; node)</a>
<a name="ln852">{</a>
<a name="ln853">	int32 flags;</a>
<a name="ln854">	if (node.ReadAttr(B_MAIL_ATTR_FLAGS, B_INT32_TYPE, 0, &amp;flags, sizeof(int32))</a>
<a name="ln855">			!= (ssize_t)sizeof(int32))</a>
<a name="ln856">		return false;</a>
<a name="ln857"> </a>
<a name="ln858">	return (flags &amp; B_MAIL_PENDING) != 0;</a>
<a name="ln859">}</a>
<a name="ln860"> </a>
<a name="ln861"> </a>
<a name="ln862">/*static*/ bool</a>
<a name="ln863">MailDaemonApplication::_IsEntryInTrash(BEntry&amp; entry)</a>
<a name="ln864">{</a>
<a name="ln865">	entry_ref ref;</a>
<a name="ln866">	entry.GetRef(&amp;ref);</a>
<a name="ln867"> </a>
<a name="ln868">	BVolume volume(ref.device);</a>
<a name="ln869">	BPath path;</a>
<a name="ln870">	if (volume.InitCheck() != B_OK</a>
<a name="ln871">		|| find_directory(B_TRASH_DIRECTORY, &amp;path, false, &amp;volume) != B_OK)</a>
<a name="ln872">		return false;</a>
<a name="ln873"> </a>
<a name="ln874">	BDirectory trash(path.Path());</a>
<a name="ln875">	return trash.Contains(&amp;entry);</a>
<a name="ln876">}</a>

</code></pre>
<div class="balloon" rel="314"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
