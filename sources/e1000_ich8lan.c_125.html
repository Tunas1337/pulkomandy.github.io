
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>e1000_ich8lan.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/******************************************************************************</a>
<a name="ln2">  SPDX-License-Identifier: BSD-3-Clause</a>
<a name="ln3"> </a>
<a name="ln4">  Copyright (c) 2001-2015, Intel Corporation </a>
<a name="ln5">  All rights reserved.</a>
<a name="ln6">  </a>
<a name="ln7">  Redistribution and use in source and binary forms, with or without </a>
<a name="ln8">  modification, are permitted provided that the following conditions are met:</a>
<a name="ln9">  </a>
<a name="ln10">   1. Redistributions of source code must retain the above copyright notice, </a>
<a name="ln11">      this list of conditions and the following disclaimer.</a>
<a name="ln12">  </a>
<a name="ln13">   2. Redistributions in binary form must reproduce the above copyright </a>
<a name="ln14">      notice, this list of conditions and the following disclaimer in the </a>
<a name="ln15">      documentation and/or other materials provided with the distribution.</a>
<a name="ln16">  </a>
<a name="ln17">   3. Neither the name of the Intel Corporation nor the names of its </a>
<a name="ln18">      contributors may be used to endorse or promote products derived from </a>
<a name="ln19">      this software without specific prior written permission.</a>
<a name="ln20">  </a>
<a name="ln21">  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</a>
<a name="ln22">  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE </a>
<a name="ln23">  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE </a>
<a name="ln24">  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE </a>
<a name="ln25">  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR </a>
<a name="ln26">  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF </a>
<a name="ln27">  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS </a>
<a name="ln28">  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN </a>
<a name="ln29">  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) </a>
<a name="ln30">  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</a>
<a name="ln31">  POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln32"> </a>
<a name="ln33">******************************************************************************/</a>
<a name="ln34">/*$FreeBSD: releng/12.0/sys/dev/e1000/e1000_ich8lan.c 333345 2018-05-08 01:39:45Z mmacy $*/</a>
<a name="ln35"> </a>
<a name="ln36">/* 82562G 10/100 Network Connection</a>
<a name="ln37"> * 82562G-2 10/100 Network Connection</a>
<a name="ln38"> * 82562GT 10/100 Network Connection</a>
<a name="ln39"> * 82562GT-2 10/100 Network Connection</a>
<a name="ln40"> * 82562V 10/100 Network Connection</a>
<a name="ln41"> * 82562V-2 10/100 Network Connection</a>
<a name="ln42"> * 82566DC-2 Gigabit Network Connection</a>
<a name="ln43"> * 82566DC Gigabit Network Connection</a>
<a name="ln44"> * 82566DM-2 Gigabit Network Connection</a>
<a name="ln45"> * 82566DM Gigabit Network Connection</a>
<a name="ln46"> * 82566MC Gigabit Network Connection</a>
<a name="ln47"> * 82566MM Gigabit Network Connection</a>
<a name="ln48"> * 82567LM Gigabit Network Connection</a>
<a name="ln49"> * 82567LF Gigabit Network Connection</a>
<a name="ln50"> * 82567V Gigabit Network Connection</a>
<a name="ln51"> * 82567LM-2 Gigabit Network Connection</a>
<a name="ln52"> * 82567LF-2 Gigabit Network Connection</a>
<a name="ln53"> * 82567V-2 Gigabit Network Connection</a>
<a name="ln54"> * 82567LF-3 Gigabit Network Connection</a>
<a name="ln55"> * 82567LM-3 Gigabit Network Connection</a>
<a name="ln56"> * 82567LM-4 Gigabit Network Connection</a>
<a name="ln57"> * 82577LM Gigabit Network Connection</a>
<a name="ln58"> * 82577LC Gigabit Network Connection</a>
<a name="ln59"> * 82578DM Gigabit Network Connection</a>
<a name="ln60"> * 82578DC Gigabit Network Connection</a>
<a name="ln61"> * 82579LM Gigabit Network Connection</a>
<a name="ln62"> * 82579V Gigabit Network Connection</a>
<a name="ln63"> * Ethernet Connection I217-LM</a>
<a name="ln64"> * Ethernet Connection I217-V</a>
<a name="ln65"> * Ethernet Connection I218-V</a>
<a name="ln66"> * Ethernet Connection I218-LM</a>
<a name="ln67"> * Ethernet Connection (2) I218-LM</a>
<a name="ln68"> * Ethernet Connection (2) I218-V</a>
<a name="ln69"> * Ethernet Connection (3) I218-LM</a>
<a name="ln70"> * Ethernet Connection (3) I218-V</a>
<a name="ln71"> */</a>
<a name="ln72"> </a>
<a name="ln73">#include &quot;e1000_api.h&quot;</a>
<a name="ln74"> </a>
<a name="ln75">static s32  e1000_acquire_swflag_ich8lan(struct e1000_hw *hw);</a>
<a name="ln76">static void e1000_release_swflag_ich8lan(struct e1000_hw *hw);</a>
<a name="ln77">static s32  e1000_acquire_nvm_ich8lan(struct e1000_hw *hw);</a>
<a name="ln78">static void e1000_release_nvm_ich8lan(struct e1000_hw *hw);</a>
<a name="ln79">static bool e1000_check_mng_mode_ich8lan(struct e1000_hw *hw);</a>
<a name="ln80">static bool e1000_check_mng_mode_pchlan(struct e1000_hw *hw);</a>
<a name="ln81">static int  e1000_rar_set_pch2lan(struct e1000_hw *hw, u8 *addr, u32 index);</a>
<a name="ln82">static int  e1000_rar_set_pch_lpt(struct e1000_hw *hw, u8 *addr, u32 index);</a>
<a name="ln83">static s32 e1000_sw_lcd_config_ich8lan(struct e1000_hw *hw);</a>
<a name="ln84">static void e1000_update_mc_addr_list_pch2lan(struct e1000_hw *hw,</a>
<a name="ln85">					      u8 *mc_addr_list,</a>
<a name="ln86">					      u32 mc_addr_count);</a>
<a name="ln87">static s32  e1000_check_reset_block_ich8lan(struct e1000_hw *hw);</a>
<a name="ln88">static s32  e1000_phy_hw_reset_ich8lan(struct e1000_hw *hw);</a>
<a name="ln89">static s32  e1000_set_lplu_state_pchlan(struct e1000_hw *hw, bool active);</a>
<a name="ln90">static s32  e1000_set_d0_lplu_state_ich8lan(struct e1000_hw *hw,</a>
<a name="ln91">					    bool active);</a>
<a name="ln92">static s32  e1000_set_d3_lplu_state_ich8lan(struct e1000_hw *hw,</a>
<a name="ln93">					    bool active);</a>
<a name="ln94">static s32  e1000_read_nvm_ich8lan(struct e1000_hw *hw, u16 offset,</a>
<a name="ln95">				   u16 words, u16 *data);</a>
<a name="ln96">static s32  e1000_read_nvm_spt(struct e1000_hw *hw, u16 offset, u16 words,</a>
<a name="ln97">			       u16 *data);</a>
<a name="ln98">static s32  e1000_write_nvm_ich8lan(struct e1000_hw *hw, u16 offset,</a>
<a name="ln99">				    u16 words, u16 *data);</a>
<a name="ln100">static s32  e1000_validate_nvm_checksum_ich8lan(struct e1000_hw *hw);</a>
<a name="ln101">static s32  e1000_update_nvm_checksum_ich8lan(struct e1000_hw *hw);</a>
<a name="ln102">static s32  e1000_update_nvm_checksum_spt(struct e1000_hw *hw);</a>
<a name="ln103">static s32  e1000_valid_led_default_ich8lan(struct e1000_hw *hw,</a>
<a name="ln104">					    u16 *data);</a>
<a name="ln105">static s32 e1000_id_led_init_pchlan(struct e1000_hw *hw);</a>
<a name="ln106">static s32  e1000_get_bus_info_ich8lan(struct e1000_hw *hw);</a>
<a name="ln107">static s32  e1000_reset_hw_ich8lan(struct e1000_hw *hw);</a>
<a name="ln108">static s32  e1000_init_hw_ich8lan(struct e1000_hw *hw);</a>
<a name="ln109">static s32  e1000_setup_link_ich8lan(struct e1000_hw *hw);</a>
<a name="ln110">static s32  e1000_setup_copper_link_ich8lan(struct e1000_hw *hw);</a>
<a name="ln111">static s32  e1000_setup_copper_link_pch_lpt(struct e1000_hw *hw);</a>
<a name="ln112">static s32  e1000_get_link_up_info_ich8lan(struct e1000_hw *hw,</a>
<a name="ln113">					   u16 *speed, u16 *duplex);</a>
<a name="ln114">static s32  e1000_cleanup_led_ich8lan(struct e1000_hw *hw);</a>
<a name="ln115">static s32  e1000_led_on_ich8lan(struct e1000_hw *hw);</a>
<a name="ln116">static s32  e1000_led_off_ich8lan(struct e1000_hw *hw);</a>
<a name="ln117">static s32  e1000_k1_gig_workaround_hv(struct e1000_hw *hw, bool link);</a>
<a name="ln118">static s32  e1000_setup_led_pchlan(struct e1000_hw *hw);</a>
<a name="ln119">static s32  e1000_cleanup_led_pchlan(struct e1000_hw *hw);</a>
<a name="ln120">static s32  e1000_led_on_pchlan(struct e1000_hw *hw);</a>
<a name="ln121">static s32  e1000_led_off_pchlan(struct e1000_hw *hw);</a>
<a name="ln122">static void e1000_clear_hw_cntrs_ich8lan(struct e1000_hw *hw);</a>
<a name="ln123">static s32  e1000_erase_flash_bank_ich8lan(struct e1000_hw *hw, u32 bank);</a>
<a name="ln124">static void e1000_initialize_hw_bits_ich8lan(struct e1000_hw *hw);</a>
<a name="ln125">static s32  e1000_kmrn_lock_loss_workaround_ich8lan(struct e1000_hw *hw);</a>
<a name="ln126">static s32  e1000_read_flash_byte_ich8lan(struct e1000_hw *hw,</a>
<a name="ln127">					  u32 offset, u8 *data);</a>
<a name="ln128">static s32  e1000_read_flash_data_ich8lan(struct e1000_hw *hw, u32 offset,</a>
<a name="ln129">					  u8 size, u16 *data);</a>
<a name="ln130">static s32  e1000_read_flash_data32_ich8lan(struct e1000_hw *hw, u32 offset,</a>
<a name="ln131">					    u32 *data);</a>
<a name="ln132">static s32  e1000_read_flash_dword_ich8lan(struct e1000_hw *hw,</a>
<a name="ln133">					   u32 offset, u32 *data);</a>
<a name="ln134">static s32  e1000_write_flash_data32_ich8lan(struct e1000_hw *hw,</a>
<a name="ln135">					     u32 offset, u32 data);</a>
<a name="ln136">static s32  e1000_retry_write_flash_dword_ich8lan(struct e1000_hw *hw,</a>
<a name="ln137">						  u32 offset, u32 dword);</a>
<a name="ln138">static s32  e1000_read_flash_word_ich8lan(struct e1000_hw *hw,</a>
<a name="ln139">					  u32 offset, u16 *data);</a>
<a name="ln140">static s32  e1000_retry_write_flash_byte_ich8lan(struct e1000_hw *hw,</a>
<a name="ln141">						 u32 offset, u8 byte);</a>
<a name="ln142">static s32 e1000_get_cfg_done_ich8lan(struct e1000_hw *hw);</a>
<a name="ln143">static void e1000_power_down_phy_copper_ich8lan(struct e1000_hw *hw);</a>
<a name="ln144">static s32 e1000_check_for_copper_link_ich8lan(struct e1000_hw *hw);</a>
<a name="ln145">static s32 e1000_set_mdio_slow_mode_hv(struct e1000_hw *hw);</a>
<a name="ln146">static s32 e1000_k1_workaround_lv(struct e1000_hw *hw);</a>
<a name="ln147">static void e1000_gate_hw_phy_config_ich8lan(struct e1000_hw *hw, bool gate);</a>
<a name="ln148">static s32 e1000_set_obff_timer_pch_lpt(struct e1000_hw *hw, u32 itr);</a>
<a name="ln149"> </a>
<a name="ln150">/* ICH GbE Flash Hardware Sequencing Flash Status Register bit breakdown */</a>
<a name="ln151">/* Offset 04h HSFSTS */</a>
<a name="ln152">union ich8_hws_flash_status {</a>
<a name="ln153">	struct ich8_hsfsts {</a>
<a name="ln154">		u16 flcdone:1; /* bit 0 Flash Cycle Done */</a>
<a name="ln155">		u16 flcerr:1; /* bit 1 Flash Cycle Error */</a>
<a name="ln156">		u16 dael:1; /* bit 2 Direct Access error Log */</a>
<a name="ln157">		u16 berasesz:2; /* bit 4:3 Sector Erase Size */</a>
<a name="ln158">		u16 flcinprog:1; /* bit 5 flash cycle in Progress */</a>
<a name="ln159">		u16 reserved1:2; /* bit 13:6 Reserved */</a>
<a name="ln160">		u16 reserved2:6; /* bit 13:6 Reserved */</a>
<a name="ln161">		u16 fldesvalid:1; /* bit 14 Flash Descriptor Valid */</a>
<a name="ln162">		u16 flockdn:1; /* bit 15 Flash Config Lock-Down */</a>
<a name="ln163">	} hsf_status;</a>
<a name="ln164">	u16 regval;</a>
<a name="ln165">};</a>
<a name="ln166"> </a>
<a name="ln167">/* ICH GbE Flash Hardware Sequencing Flash control Register bit breakdown */</a>
<a name="ln168">/* Offset 06h FLCTL */</a>
<a name="ln169">union ich8_hws_flash_ctrl {</a>
<a name="ln170">	struct ich8_hsflctl {</a>
<a name="ln171">		u16 flcgo:1;   /* 0 Flash Cycle Go */</a>
<a name="ln172">		u16 flcycle:2;   /* 2:1 Flash Cycle */</a>
<a name="ln173">		u16 reserved:5;   /* 7:3 Reserved  */</a>
<a name="ln174">		u16 fldbcount:2;   /* 9:8 Flash Data Byte Count */</a>
<a name="ln175">		u16 flockdn:6;   /* 15:10 Reserved */</a>
<a name="ln176">	} hsf_ctrl;</a>
<a name="ln177">	u16 regval;</a>
<a name="ln178">};</a>
<a name="ln179"> </a>
<a name="ln180">/* ICH Flash Region Access Permissions */</a>
<a name="ln181">union ich8_hws_flash_regacc {</a>
<a name="ln182">	struct ich8_flracc {</a>
<a name="ln183">		u32 grra:8; /* 0:7 GbE region Read Access */</a>
<a name="ln184">		u32 grwa:8; /* 8:15 GbE region Write Access */</a>
<a name="ln185">		u32 gmrag:8; /* 23:16 GbE Master Read Access Grant */</a>
<a name="ln186">		u32 gmwag:8; /* 31:24 GbE Master Write Access Grant */</a>
<a name="ln187">	} hsf_flregacc;</a>
<a name="ln188">	u16 regval;</a>
<a name="ln189">};</a>
<a name="ln190"> </a>
<a name="ln191">/**</a>
<a name="ln192"> *  e1000_phy_is_accessible_pchlan - Check if able to access PHY registers</a>
<a name="ln193"> *  @hw: pointer to the HW structure</a>
<a name="ln194"> *</a>
<a name="ln195"> *  Test access to the PHY registers by reading the PHY ID registers.  If</a>
<a name="ln196"> *  the PHY ID is already known (e.g. resume path) compare it with known ID,</a>
<a name="ln197"> *  otherwise assume the read PHY ID is correct if it is valid.</a>
<a name="ln198"> *</a>
<a name="ln199"> *  Assumes the sw/fw/hw semaphore is already acquired.</a>
<a name="ln200"> **/</a>
<a name="ln201">static bool e1000_phy_is_accessible_pchlan(struct e1000_hw *hw)</a>
<a name="ln202">{</a>
<a name="ln203">	u16 phy_reg = 0;</a>
<a name="ln204">	u32 phy_id = 0;</a>
<a name="ln205">	s32 ret_val = 0;</a>
<a name="ln206">	u16 retry_count;</a>
<a name="ln207">	u32 mac_reg = 0;</a>
<a name="ln208"> </a>
<a name="ln209">	for (retry_count = 0; retry_count &lt; 2; retry_count++) {</a>
<a name="ln210">		ret_val = hw-&gt;phy.ops.read_reg_locked(hw, PHY_ID1, &amp;phy_reg);</a>
<a name="ln211">		if (ret_val || (phy_reg == 0xFFFF))</a>
<a name="ln212">			continue;</a>
<a name="ln213">		phy_id = (u32)(phy_reg &lt;&lt; 16);</a>
<a name="ln214"> </a>
<a name="ln215">		ret_val = hw-&gt;phy.ops.read_reg_locked(hw, PHY_ID2, &amp;phy_reg);</a>
<a name="ln216">		if (ret_val || (phy_reg == 0xFFFF)) {</a>
<a name="ln217">			phy_id = 0;</a>
<a name="ln218">			continue;</a>
<a name="ln219">		}</a>
<a name="ln220">		phy_id |= (u32)(phy_reg &amp; PHY_REVISION_MASK);</a>
<a name="ln221">		break;</a>
<a name="ln222">	}</a>
<a name="ln223"> </a>
<a name="ln224">	if (hw-&gt;phy.id) {</a>
<a name="ln225">		if  (hw-&gt;phy.id == phy_id)</a>
<a name="ln226">			goto out;</a>
<a name="ln227">	} else if (phy_id) {</a>
<a name="ln228">		hw-&gt;phy.id = phy_id;</a>
<a name="ln229">		hw-&gt;phy.revision = (u32)(phy_reg &amp; ~PHY_REVISION_MASK);</a>
<a name="ln230">		goto out;</a>
<a name="ln231">	}</a>
<a name="ln232"> </a>
<a name="ln233">	/* In case the PHY needs to be in mdio slow mode,</a>
<a name="ln234">	 * set slow mode and try to get the PHY id again.</a>
<a name="ln235">	 */</a>
<a name="ln236">	if (hw-&gt;mac.type &lt; e1000_pch_lpt) {</a>
<a name="ln237">		hw-&gt;phy.ops.release(hw);</a>
<a name="ln238">		ret_val = e1000_set_mdio_slow_mode_hv(hw);</a>
<a name="ln239">		if (!ret_val)</a>
<a name="ln240">			ret_val = e1000_get_phy_id(hw);</a>
<a name="ln241">		hw-&gt;phy.ops.acquire(hw);</a>
<a name="ln242">	}</a>
<a name="ln243"> </a>
<a name="ln244">	if (ret_val)</a>
<a name="ln245">		return FALSE;</a>
<a name="ln246">out:</a>
<a name="ln247">	if (hw-&gt;mac.type &gt;= e1000_pch_lpt) {</a>
<a name="ln248">		/* Only unforce SMBus if ME is not active */</a>
<a name="ln249">		if (!(E1000_READ_REG(hw, E1000_FWSM) &amp;</a>
<a name="ln250">		    E1000_ICH_FWSM_FW_VALID)) {</a>
<a name="ln251">			/* Unforce SMBus mode in PHY */</a>
<a name="ln252">			hw-&gt;phy.ops.read_reg_locked(hw, CV_SMB_CTRL, &amp;phy_reg);</a>
<a name="ln253">			phy_reg &amp;= ~CV_SMB_CTRL_FORCE_SMBUS;</a>
<a name="ln254">			hw-&gt;phy.ops.write_reg_locked(hw, CV_SMB_CTRL, phy_reg);</a>
<a name="ln255"> </a>
<a name="ln256">			/* Unforce SMBus mode in MAC */</a>
<a name="ln257">			mac_reg = E1000_READ_REG(hw, E1000_CTRL_EXT);</a>
<a name="ln258">			mac_reg &amp;= ~E1000_CTRL_EXT_FORCE_SMBUS;</a>
<a name="ln259">			E1000_WRITE_REG(hw, E1000_CTRL_EXT, mac_reg);</a>
<a name="ln260">		}</a>
<a name="ln261">	}</a>
<a name="ln262"> </a>
<a name="ln263">	return TRUE;</a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266">/**</a>
<a name="ln267"> *  e1000_toggle_lanphypc_pch_lpt - toggle the LANPHYPC pin value</a>
<a name="ln268"> *  @hw: pointer to the HW structure</a>
<a name="ln269"> *</a>
<a name="ln270"> *  Toggling the LANPHYPC pin value fully power-cycles the PHY and is</a>
<a name="ln271"> *  used to reset the PHY to a quiescent state when necessary.</a>
<a name="ln272"> **/</a>
<a name="ln273">static void e1000_toggle_lanphypc_pch_lpt(struct e1000_hw *hw)</a>
<a name="ln274">{</a>
<a name="ln275">	u32 mac_reg;</a>
<a name="ln276"> </a>
<a name="ln277">	DEBUGFUNC(&quot;e1000_toggle_lanphypc_pch_lpt&quot;);</a>
<a name="ln278"> </a>
<a name="ln279">	/* Set Phy Config Counter to 50msec */</a>
<a name="ln280">	mac_reg = E1000_READ_REG(hw, E1000_FEXTNVM3);</a>
<a name="ln281">	mac_reg &amp;= ~E1000_FEXTNVM3_PHY_CFG_COUNTER_MASK;</a>
<a name="ln282">	mac_reg |= E1000_FEXTNVM3_PHY_CFG_COUNTER_50MSEC;</a>
<a name="ln283">	E1000_WRITE_REG(hw, E1000_FEXTNVM3, mac_reg);</a>
<a name="ln284"> </a>
<a name="ln285">	/* Toggle LANPHYPC Value bit */</a>
<a name="ln286">	mac_reg = E1000_READ_REG(hw, E1000_CTRL);</a>
<a name="ln287">	mac_reg |= E1000_CTRL_LANPHYPC_OVERRIDE;</a>
<a name="ln288">	mac_reg &amp;= ~E1000_CTRL_LANPHYPC_VALUE;</a>
<a name="ln289">	E1000_WRITE_REG(hw, E1000_CTRL, mac_reg);</a>
<a name="ln290">	E1000_WRITE_FLUSH(hw);</a>
<a name="ln291">	msec_delay(1);</a>
<a name="ln292">	mac_reg &amp;= ~E1000_CTRL_LANPHYPC_OVERRIDE;</a>
<a name="ln293">	E1000_WRITE_REG(hw, E1000_CTRL, mac_reg);</a>
<a name="ln294">	E1000_WRITE_FLUSH(hw);</a>
<a name="ln295"> </a>
<a name="ln296">	if (hw-&gt;mac.type &lt; e1000_pch_lpt) {</a>
<a name="ln297">		msec_delay(50);</a>
<a name="ln298">	} else {</a>
<a name="ln299">		u16 count = 20;</a>
<a name="ln300"> </a>
<a name="ln301">		do {</a>
<a name="ln302">			msec_delay(5);</a>
<a name="ln303">		} while (!(E1000_READ_REG(hw, E1000_CTRL_EXT) &amp;</a>
<a name="ln304">			   E1000_CTRL_EXT_LPCD) &amp;&amp; count--);</a>
<a name="ln305"> </a>
<a name="ln306">		msec_delay(30);</a>
<a name="ln307">	}</a>
<a name="ln308">}</a>
<a name="ln309"> </a>
<a name="ln310">/**</a>
<a name="ln311"> *  e1000_init_phy_workarounds_pchlan - PHY initialization workarounds</a>
<a name="ln312"> *  @hw: pointer to the HW structure</a>
<a name="ln313"> *</a>
<a name="ln314"> *  Workarounds/flow necessary for PHY initialization during driver load</a>
<a name="ln315"> *  and resume paths.</a>
<a name="ln316"> **/</a>
<a name="ln317">static s32 e1000_init_phy_workarounds_pchlan(struct e1000_hw *hw)</a>
<a name="ln318">{</a>
<a name="ln319">	u32 mac_reg, fwsm = E1000_READ_REG(hw, E1000_FWSM);</a>
<a name="ln320">	s32 ret_val;</a>
<a name="ln321"> </a>
<a name="ln322">	DEBUGFUNC(&quot;e1000_init_phy_workarounds_pchlan&quot;);</a>
<a name="ln323"> </a>
<a name="ln324">	/* Gate automatic PHY configuration by hardware on managed and</a>
<a name="ln325">	 * non-managed 82579 and newer adapters.</a>
<a name="ln326">	 */</a>
<a name="ln327">	e1000_gate_hw_phy_config_ich8lan(hw, TRUE);</a>
<a name="ln328"> </a>
<a name="ln329">	/* It is not possible to be certain of the current state of ULP</a>
<a name="ln330">	 * so forcibly disable it.</a>
<a name="ln331">	 */</a>
<a name="ln332">	hw-&gt;dev_spec.ich8lan.ulp_state = e1000_ulp_state_unknown;</a>
<a name="ln333">	e1000_disable_ulp_lpt_lp(hw, TRUE);</a>
<a name="ln334"> </a>
<a name="ln335">	ret_val = hw-&gt;phy.ops.acquire(hw);</a>
<a name="ln336">	if (ret_val) {</a>
<a name="ln337">		DEBUGOUT(&quot;Failed to initialize PHY flow\n&quot;);</a>
<a name="ln338">		goto out;</a>
<a name="ln339">	}</a>
<a name="ln340"> </a>
<a name="ln341">	/* The MAC-PHY interconnect may be in SMBus mode.  If the PHY is</a>
<a name="ln342">	 * inaccessible and resetting the PHY is not blocked, toggle the</a>
<a name="ln343">	 * LANPHYPC Value bit to force the interconnect to PCIe mode.</a>
<a name="ln344">	 */</a>
<a name="ln345">	switch (hw-&gt;mac.type) {</a>
<a name="ln346">	case e1000_pch_lpt:</a>
<a name="ln347">	case e1000_pch_spt:</a>
<a name="ln348">	case e1000_pch_cnp:</a>
<a name="ln349">		if (e1000_phy_is_accessible_pchlan(hw))</a>
<a name="ln350">			break;</a>
<a name="ln351"> </a>
<a name="ln352">		/* Before toggling LANPHYPC, see if PHY is accessible by</a>
<a name="ln353">		 * forcing MAC to SMBus mode first.</a>
<a name="ln354">		 */</a>
<a name="ln355">		mac_reg = E1000_READ_REG(hw, E1000_CTRL_EXT);</a>
<a name="ln356">		mac_reg |= E1000_CTRL_EXT_FORCE_SMBUS;</a>
<a name="ln357">		E1000_WRITE_REG(hw, E1000_CTRL_EXT, mac_reg);</a>
<a name="ln358"> </a>
<a name="ln359">		/* Wait 50 milliseconds for MAC to finish any retries</a>
<a name="ln360">		 * that it might be trying to perform from previous</a>
<a name="ln361">		 * attempts to acknowledge any phy read requests.</a>
<a name="ln362">		 */</a>
<a name="ln363">		 msec_delay(50);</a>
<a name="ln364"> </a>
<a name="ln365">		/* fall-through */</a>
<a name="ln366">	case e1000_pch2lan:</a>
<a name="ln367">		if (e1000_phy_is_accessible_pchlan(hw))</a>
<a name="ln368">			break;</a>
<a name="ln369"> </a>
<a name="ln370">		/* fall-through */</a>
<a name="ln371">	case e1000_pchlan:</a>
<a name="ln372">		if ((hw-&gt;mac.type == e1000_pchlan) &amp;&amp;</a>
<a name="ln373">		    (fwsm &amp; E1000_ICH_FWSM_FW_VALID))</a>
<a name="ln374">			break;</a>
<a name="ln375"> </a>
<a name="ln376">		if (hw-&gt;phy.ops.check_reset_block(hw)) {</a>
<a name="ln377">			DEBUGOUT(&quot;Required LANPHYPC toggle blocked by ME\n&quot;);</a>
<a name="ln378">			ret_val = -E1000_ERR_PHY;</a>
<a name="ln379">			break;</a>
<a name="ln380">		}</a>
<a name="ln381"> </a>
<a name="ln382">		/* Toggle LANPHYPC Value bit */</a>
<a name="ln383">		e1000_toggle_lanphypc_pch_lpt(hw);</a>
<a name="ln384">		if (hw-&gt;mac.type &gt;= e1000_pch_lpt) {</a>
<a name="ln385">			if (e1000_phy_is_accessible_pchlan(hw))</a>
<a name="ln386">				break;</a>
<a name="ln387"> </a>
<a name="ln388">			/* Toggling LANPHYPC brings the PHY out of SMBus mode</a>
<a name="ln389">			 * so ensure that the MAC is also out of SMBus mode</a>
<a name="ln390">			 */</a>
<a name="ln391">			mac_reg = E1000_READ_REG(hw, E1000_CTRL_EXT);</a>
<a name="ln392">			mac_reg &amp;= ~E1000_CTRL_EXT_FORCE_SMBUS;</a>
<a name="ln393">			E1000_WRITE_REG(hw, E1000_CTRL_EXT, mac_reg);</a>
<a name="ln394"> </a>
<a name="ln395">			if (e1000_phy_is_accessible_pchlan(hw))</a>
<a name="ln396">				break;</a>
<a name="ln397"> </a>
<a name="ln398">			ret_val = -E1000_ERR_PHY;</a>
<a name="ln399">		}</a>
<a name="ln400">		break;</a>
<a name="ln401">	default:</a>
<a name="ln402">		break;</a>
<a name="ln403">	}</a>
<a name="ln404"> </a>
<a name="ln405">	hw-&gt;phy.ops.release(hw);</a>
<a name="ln406">	if (!ret_val) {</a>
<a name="ln407"> </a>
<a name="ln408">		/* Check to see if able to reset PHY.  Print error if not */</a>
<a name="ln409">		if (hw-&gt;phy.ops.check_reset_block(hw)) {</a>
<a name="ln410">			ERROR_REPORT(&quot;Reset blocked by ME\n&quot;);</a>
<a name="ln411">			goto out;</a>
<a name="ln412">		}</a>
<a name="ln413"> </a>
<a name="ln414">		/* Reset the PHY before any access to it.  Doing so, ensures</a>
<a name="ln415">		 * that the PHY is in a known good state before we read/write</a>
<a name="ln416">		 * PHY registers.  The generic reset is sufficient here,</a>
<a name="ln417">		 * because we haven't determined the PHY type yet.</a>
<a name="ln418">		 */</a>
<a name="ln419">		ret_val = e1000_phy_hw_reset_generic(hw);</a>
<a name="ln420">		if (ret_val)</a>
<a name="ln421">			goto out;</a>
<a name="ln422"> </a>
<a name="ln423">		/* On a successful reset, possibly need to wait for the PHY</a>
<a name="ln424">		 * to quiesce to an accessible state before returning control</a>
<a name="ln425">		 * to the calling function.  If the PHY does not quiesce, then</a>
<a name="ln426">		 * return E1000E_BLK_PHY_RESET, as this is the condition that</a>
<a name="ln427">		 *  the PHY is in.</a>
<a name="ln428">		 */</a>
<a name="ln429">		ret_val = hw-&gt;phy.ops.check_reset_block(hw);</a>
<a name="ln430">		if (ret_val)</a>
<a name="ln431">			ERROR_REPORT(&quot;ME blocked access to PHY after reset\n&quot;);</a>
<a name="ln432">	}</a>
<a name="ln433"> </a>
<a name="ln434">out:</a>
<a name="ln435">	/* Ungate automatic PHY configuration on non-managed 82579 */</a>
<a name="ln436">	if ((hw-&gt;mac.type == e1000_pch2lan) &amp;&amp;</a>
<a name="ln437">	    !(fwsm &amp; E1000_ICH_FWSM_FW_VALID)) {</a>
<a name="ln438">		msec_delay(10);</a>
<a name="ln439">		e1000_gate_hw_phy_config_ich8lan(hw, FALSE);</a>
<a name="ln440">	}</a>
<a name="ln441"> </a>
<a name="ln442">	return ret_val;</a>
<a name="ln443">}</a>
<a name="ln444"> </a>
<a name="ln445">/**</a>
<a name="ln446"> *  e1000_init_phy_params_pchlan - Initialize PHY function pointers</a>
<a name="ln447"> *  @hw: pointer to the HW structure</a>
<a name="ln448"> *</a>
<a name="ln449"> *  Initialize family-specific PHY parameters and function pointers.</a>
<a name="ln450"> **/</a>
<a name="ln451">static s32 e1000_init_phy_params_pchlan(struct e1000_hw *hw)</a>
<a name="ln452">{</a>
<a name="ln453">	struct e1000_phy_info *phy = &amp;hw-&gt;phy;</a>
<a name="ln454">	s32 ret_val;</a>
<a name="ln455"> </a>
<a name="ln456">	DEBUGFUNC(&quot;e1000_init_phy_params_pchlan&quot;);</a>
<a name="ln457"> </a>
<a name="ln458">	phy-&gt;addr		= 1;</a>
<a name="ln459">	phy-&gt;reset_delay_us	= 100;</a>
<a name="ln460"> </a>
<a name="ln461">	phy-&gt;ops.acquire	= e1000_acquire_swflag_ich8lan;</a>
<a name="ln462">	phy-&gt;ops.check_reset_block = e1000_check_reset_block_ich8lan;</a>
<a name="ln463">	phy-&gt;ops.get_cfg_done	= e1000_get_cfg_done_ich8lan;</a>
<a name="ln464">	phy-&gt;ops.set_page	= e1000_set_page_igp;</a>
<a name="ln465">	phy-&gt;ops.read_reg	= e1000_read_phy_reg_hv;</a>
<a name="ln466">	phy-&gt;ops.read_reg_locked = e1000_read_phy_reg_hv_locked;</a>
<a name="ln467">	phy-&gt;ops.read_reg_page	= e1000_read_phy_reg_page_hv;</a>
<a name="ln468">	phy-&gt;ops.release	= e1000_release_swflag_ich8lan;</a>
<a name="ln469">	phy-&gt;ops.reset		= e1000_phy_hw_reset_ich8lan;</a>
<a name="ln470">	phy-&gt;ops.set_d0_lplu_state = e1000_set_lplu_state_pchlan;</a>
<a name="ln471">	phy-&gt;ops.set_d3_lplu_state = e1000_set_lplu_state_pchlan;</a>
<a name="ln472">	phy-&gt;ops.write_reg	= e1000_write_phy_reg_hv;</a>
<a name="ln473">	phy-&gt;ops.write_reg_locked = e1000_write_phy_reg_hv_locked;</a>
<a name="ln474">	phy-&gt;ops.write_reg_page	= e1000_write_phy_reg_page_hv;</a>
<a name="ln475">	phy-&gt;ops.power_up	= e1000_power_up_phy_copper;</a>
<a name="ln476">	phy-&gt;ops.power_down	= e1000_power_down_phy_copper_ich8lan;</a>
<a name="ln477">	phy-&gt;autoneg_mask	= AUTONEG_ADVERTISE_SPEED_DEFAULT;</a>
<a name="ln478"> </a>
<a name="ln479">	phy-&gt;id = e1000_phy_unknown;</a>
<a name="ln480"> </a>
<a name="ln481">	ret_val = e1000_init_phy_workarounds_pchlan(hw);</a>
<a name="ln482">	if (ret_val)</a>
<a name="ln483">		return ret_val;</a>
<a name="ln484"> </a>
<a name="ln485">	if (phy-&gt;id == e1000_phy_unknown)</a>
<a name="ln486">		switch (hw-&gt;mac.type) {</a>
<a name="ln487">		default:</a>
<a name="ln488">			ret_val = e1000_get_phy_id(hw);</a>
<a name="ln489">			if (ret_val)</a>
<a name="ln490">				return ret_val;</a>
<a name="ln491">			if ((phy-&gt;id != 0) &amp;&amp; (phy-&gt;id != PHY_REVISION_MASK))</a>
<a name="ln492">				break;</a>
<a name="ln493">			/* fall-through */</a>
<a name="ln494">		case e1000_pch2lan:</a>
<a name="ln495">		case e1000_pch_lpt:</a>
<a name="ln496">		case e1000_pch_spt:</a>
<a name="ln497">		case e1000_pch_cnp:</a>
<a name="ln498">			/* In case the PHY needs to be in mdio slow mode,</a>
<a name="ln499">			 * set slow mode and try to get the PHY id again.</a>
<a name="ln500">			 */</a>
<a name="ln501">			ret_val = e1000_set_mdio_slow_mode_hv(hw);</a>
<a name="ln502">			if (ret_val)</a>
<a name="ln503">				return ret_val;</a>
<a name="ln504">			ret_val = e1000_get_phy_id(hw);</a>
<a name="ln505">			if (ret_val)</a>
<a name="ln506">				return ret_val;</a>
<a name="ln507">			break;</a>
<a name="ln508">		}</a>
<a name="ln509">	phy-&gt;type = e1000_get_phy_type_from_id(phy-&gt;id);</a>
<a name="ln510"> </a>
<a name="ln511">	switch (phy-&gt;type) {</a>
<a name="ln512">	case e1000_phy_82577:</a>
<a name="ln513">	case e1000_phy_82579:</a>
<a name="ln514">	case e1000_phy_i217:</a>
<a name="ln515">		phy-&gt;ops.check_polarity = e1000_check_polarity_82577;</a>
<a name="ln516">		phy-&gt;ops.force_speed_duplex =</a>
<a name="ln517">			e1000_phy_force_speed_duplex_82577;</a>
<a name="ln518">		phy-&gt;ops.get_cable_length = e1000_get_cable_length_82577;</a>
<a name="ln519">		phy-&gt;ops.get_info = e1000_get_phy_info_82577;</a>
<a name="ln520">		phy-&gt;ops.commit = e1000_phy_sw_reset_generic;</a>
<a name="ln521">		break;</a>
<a name="ln522">	case e1000_phy_82578:</a>
<a name="ln523">		phy-&gt;ops.check_polarity = e1000_check_polarity_m88;</a>
<a name="ln524">		phy-&gt;ops.force_speed_duplex = e1000_phy_force_speed_duplex_m88;</a>
<a name="ln525">		phy-&gt;ops.get_cable_length = e1000_get_cable_length_m88;</a>
<a name="ln526">		phy-&gt;ops.get_info = e1000_get_phy_info_m88;</a>
<a name="ln527">		break;</a>
<a name="ln528">	default:</a>
<a name="ln529">		ret_val = -E1000_ERR_PHY;</a>
<a name="ln530">		break;</a>
<a name="ln531">	}</a>
<a name="ln532"> </a>
<a name="ln533">	return ret_val;</a>
<a name="ln534">}</a>
<a name="ln535"> </a>
<a name="ln536">/**</a>
<a name="ln537"> *  e1000_init_phy_params_ich8lan - Initialize PHY function pointers</a>
<a name="ln538"> *  @hw: pointer to the HW structure</a>
<a name="ln539"> *</a>
<a name="ln540"> *  Initialize family-specific PHY parameters and function pointers.</a>
<a name="ln541"> **/</a>
<a name="ln542">static s32 e1000_init_phy_params_ich8lan(struct e1000_hw *hw)</a>
<a name="ln543">{</a>
<a name="ln544">	struct e1000_phy_info *phy = &amp;hw-&gt;phy;</a>
<a name="ln545">	s32 ret_val;</a>
<a name="ln546">	u16 i = 0;</a>
<a name="ln547"> </a>
<a name="ln548">	DEBUGFUNC(&quot;e1000_init_phy_params_ich8lan&quot;);</a>
<a name="ln549"> </a>
<a name="ln550">	phy-&gt;addr		= 1;</a>
<a name="ln551">	phy-&gt;reset_delay_us	= 100;</a>
<a name="ln552"> </a>
<a name="ln553">	phy-&gt;ops.acquire	= e1000_acquire_swflag_ich8lan;</a>
<a name="ln554">	phy-&gt;ops.check_reset_block = e1000_check_reset_block_ich8lan;</a>
<a name="ln555">	phy-&gt;ops.get_cable_length = e1000_get_cable_length_igp_2;</a>
<a name="ln556">	phy-&gt;ops.get_cfg_done	= e1000_get_cfg_done_ich8lan;</a>
<a name="ln557">	phy-&gt;ops.read_reg	= e1000_read_phy_reg_igp;</a>
<a name="ln558">	phy-&gt;ops.release	= e1000_release_swflag_ich8lan;</a>
<a name="ln559">	phy-&gt;ops.reset		= e1000_phy_hw_reset_ich8lan;</a>
<a name="ln560">	phy-&gt;ops.set_d0_lplu_state = e1000_set_d0_lplu_state_ich8lan;</a>
<a name="ln561">	phy-&gt;ops.set_d3_lplu_state = e1000_set_d3_lplu_state_ich8lan;</a>
<a name="ln562">	phy-&gt;ops.write_reg	= e1000_write_phy_reg_igp;</a>
<a name="ln563">	phy-&gt;ops.power_up	= e1000_power_up_phy_copper;</a>
<a name="ln564">	phy-&gt;ops.power_down	= e1000_power_down_phy_copper_ich8lan;</a>
<a name="ln565"> </a>
<a name="ln566">	/* We may need to do this twice - once for IGP and if that fails,</a>
<a name="ln567">	 * we'll set BM func pointers and try again</a>
<a name="ln568">	 */</a>
<a name="ln569">	ret_val = e1000_determine_phy_address(hw);</a>
<a name="ln570">	if (ret_val) {</a>
<a name="ln571">		phy-&gt;ops.write_reg = e1000_write_phy_reg_bm;</a>
<a name="ln572">		phy-&gt;ops.read_reg  = e1000_read_phy_reg_bm;</a>
<a name="ln573">		ret_val = e1000_determine_phy_address(hw);</a>
<a name="ln574">		if (ret_val) {</a>
<a name="ln575">			DEBUGOUT(&quot;Cannot determine PHY addr. Erroring out\n&quot;);</a>
<a name="ln576">			return ret_val;</a>
<a name="ln577">		}</a>
<a name="ln578">	}</a>
<a name="ln579"> </a>
<a name="ln580">	phy-&gt;id = 0;</a>
<a name="ln581">	while ((e1000_phy_unknown == e1000_get_phy_type_from_id(phy-&gt;id)) &amp;&amp;</a>
<a name="ln582">	       (i++ &lt; 100)) {</a>
<a name="ln583">		msec_delay(1);</a>
<a name="ln584">		ret_val = e1000_get_phy_id(hw);</a>
<a name="ln585">		if (ret_val)</a>
<a name="ln586">			return ret_val;</a>
<a name="ln587">	}</a>
<a name="ln588"> </a>
<a name="ln589">	/* Verify phy id */</a>
<a name="ln590">	switch (phy-&gt;id) {</a>
<a name="ln591">	case IGP03E1000_E_PHY_ID:</a>
<a name="ln592">		phy-&gt;type = e1000_phy_igp_3;</a>
<a name="ln593">		phy-&gt;autoneg_mask = AUTONEG_ADVERTISE_SPEED_DEFAULT;</a>
<a name="ln594">		phy-&gt;ops.read_reg_locked = e1000_read_phy_reg_igp_locked;</a>
<a name="ln595">		phy-&gt;ops.write_reg_locked = e1000_write_phy_reg_igp_locked;</a>
<a name="ln596">		phy-&gt;ops.get_info = e1000_get_phy_info_igp;</a>
<a name="ln597">		phy-&gt;ops.check_polarity = e1000_check_polarity_igp;</a>
<a name="ln598">		phy-&gt;ops.force_speed_duplex = e1000_phy_force_speed_duplex_igp;</a>
<a name="ln599">		break;</a>
<a name="ln600">	case IFE_E_PHY_ID:</a>
<a name="ln601">	case IFE_PLUS_E_PHY_ID:</a>
<a name="ln602">	case IFE_C_E_PHY_ID:</a>
<a name="ln603">		phy-&gt;type = e1000_phy_ife;</a>
<a name="ln604">		phy-&gt;autoneg_mask = E1000_ALL_NOT_GIG;</a>
<a name="ln605">		phy-&gt;ops.get_info = e1000_get_phy_info_ife;</a>
<a name="ln606">		phy-&gt;ops.check_polarity = e1000_check_polarity_ife;</a>
<a name="ln607">		phy-&gt;ops.force_speed_duplex = e1000_phy_force_speed_duplex_ife;</a>
<a name="ln608">		break;</a>
<a name="ln609">	case BME1000_E_PHY_ID:</a>
<a name="ln610">		phy-&gt;type = e1000_phy_bm;</a>
<a name="ln611">		phy-&gt;autoneg_mask = AUTONEG_ADVERTISE_SPEED_DEFAULT;</a>
<a name="ln612">		phy-&gt;ops.read_reg = e1000_read_phy_reg_bm;</a>
<a name="ln613">		phy-&gt;ops.write_reg = e1000_write_phy_reg_bm;</a>
<a name="ln614">		phy-&gt;ops.commit = e1000_phy_sw_reset_generic;</a>
<a name="ln615">		phy-&gt;ops.get_info = e1000_get_phy_info_m88;</a>
<a name="ln616">		phy-&gt;ops.check_polarity = e1000_check_polarity_m88;</a>
<a name="ln617">		phy-&gt;ops.force_speed_duplex = e1000_phy_force_speed_duplex_m88;</a>
<a name="ln618">		break;</a>
<a name="ln619">	default:</a>
<a name="ln620">		return -E1000_ERR_PHY;</a>
<a name="ln621">		break;</a>
<a name="ln622">	}</a>
<a name="ln623"> </a>
<a name="ln624">	return E1000_SUCCESS;</a>
<a name="ln625">}</a>
<a name="ln626"> </a>
<a name="ln627">/**</a>
<a name="ln628"> *  e1000_init_nvm_params_ich8lan - Initialize NVM function pointers</a>
<a name="ln629"> *  @hw: pointer to the HW structure</a>
<a name="ln630"> *</a>
<a name="ln631"> *  Initialize family-specific NVM parameters and function</a>
<a name="ln632"> *  pointers.</a>
<a name="ln633"> **/</a>
<a name="ln634">static s32 e1000_init_nvm_params_ich8lan(struct e1000_hw *hw)</a>
<a name="ln635">{</a>
<a name="ln636">	struct e1000_nvm_info *nvm = &amp;hw-&gt;nvm;</a>
<a name="ln637">	struct e1000_dev_spec_ich8lan *dev_spec = &amp;hw-&gt;dev_spec.ich8lan;</a>
<a name="ln638">	u32 gfpreg, sector_base_addr, sector_end_addr;</a>
<a name="ln639">	u16 i;</a>
<a name="ln640">	u32 nvm_size;</a>
<a name="ln641"> </a>
<a name="ln642">	DEBUGFUNC(&quot;e1000_init_nvm_params_ich8lan&quot;);</a>
<a name="ln643"> </a>
<a name="ln644">	nvm-&gt;type = e1000_nvm_flash_sw;</a>
<a name="ln645"> </a>
<a name="ln646">	if (hw-&gt;mac.type &gt;= e1000_pch_spt) {</a>
<a name="ln647">		/* in SPT, gfpreg doesn't exist. NVM size is taken from the</a>
<a name="ln648">		 * STRAP register. This is because in SPT the GbE Flash region</a>
<a name="ln649">		 * is no longer accessed through the flash registers. Instead,</a>
<a name="ln650">		 * the mechanism has changed, and the Flash region access</a>
<a name="ln651">		 * registers are now implemented in GbE memory space.</a>
<a name="ln652">		 */</a>
<a name="ln653">		nvm-&gt;flash_base_addr = 0;</a>
<a name="ln654">		nvm_size =</a>
<a name="ln655">		    (((E1000_READ_REG(hw, E1000_STRAP) &gt;&gt; 1) &amp; 0x1F) + 1)</a>
<a name="ln656">		    * NVM_SIZE_MULTIPLIER;</a>
<a name="ln657">		nvm-&gt;flash_bank_size = nvm_size / 2;</a>
<a name="ln658">		/* Adjust to word count */</a>
<a name="ln659">		nvm-&gt;flash_bank_size /= sizeof(u16);</a>
<a name="ln660">		/* Set the base address for flash register access */</a>
<a name="ln661">		hw-&gt;flash_address = hw-&gt;hw_addr + E1000_FLASH_BASE_ADDR;</a>
<a name="ln662">	} else {</a>
<a name="ln663">		/* Can't read flash registers if register set isn't mapped. */</a>
<a name="ln664">		if (!hw-&gt;flash_address) {</a>
<a name="ln665">			DEBUGOUT(&quot;ERROR: Flash registers not mapped\n&quot;);</a>
<a name="ln666">			return -E1000_ERR_CONFIG;</a>
<a name="ln667">		}</a>
<a name="ln668"> </a>
<a name="ln669">		gfpreg = E1000_READ_FLASH_REG(hw, ICH_FLASH_GFPREG);</a>
<a name="ln670"> </a>
<a name="ln671">		/* sector_X_addr is a &quot;sector&quot;-aligned address (4096 bytes)</a>
<a name="ln672">		 * Add 1 to sector_end_addr since this sector is included in</a>
<a name="ln673">		 * the overall size.</a>
<a name="ln674">		 */</a>
<a name="ln675">		sector_base_addr = gfpreg &amp; FLASH_GFPREG_BASE_MASK;</a>
<a name="ln676">		sector_end_addr = ((gfpreg &gt;&gt; 16) &amp; FLASH_GFPREG_BASE_MASK) + 1;</a>
<a name="ln677"> </a>
<a name="ln678">		/* flash_base_addr is byte-aligned */</a>
<a name="ln679">		nvm-&gt;flash_base_addr = sector_base_addr</a>
<a name="ln680">				       &lt;&lt; FLASH_SECTOR_ADDR_SHIFT;</a>
<a name="ln681"> </a>
<a name="ln682">		/* find total size of the NVM, then cut in half since the total</a>
<a name="ln683">		 * size represents two separate NVM banks.</a>
<a name="ln684">		 */</a>
<a name="ln685">		nvm-&gt;flash_bank_size = ((sector_end_addr - sector_base_addr)</a>
<a name="ln686">					&lt;&lt; FLASH_SECTOR_ADDR_SHIFT);</a>
<a name="ln687">		nvm-&gt;flash_bank_size /= 2;</a>
<a name="ln688">		/* Adjust to word count */</a>
<a name="ln689">		nvm-&gt;flash_bank_size /= sizeof(u16);</a>
<a name="ln690">	}</a>
<a name="ln691"> </a>
<a name="ln692">	nvm-&gt;word_size = E1000_SHADOW_RAM_WORDS;</a>
<a name="ln693"> </a>
<a name="ln694">	/* Clear shadow ram */</a>
<a name="ln695">	for (i = 0; i &lt; nvm-&gt;word_size; i++) {</a>
<a name="ln696">		dev_spec-&gt;shadow_ram[i].modified = FALSE;</a>
<a name="ln697">		dev_spec-&gt;shadow_ram[i].value    = 0xFFFF;</a>
<a name="ln698">	}</a>
<a name="ln699"> </a>
<a name="ln700">	/* Function Pointers */</a>
<a name="ln701">	nvm-&gt;ops.acquire	= e1000_acquire_nvm_ich8lan;</a>
<a name="ln702">	nvm-&gt;ops.release	= e1000_release_nvm_ich8lan;</a>
<a name="ln703">	if (hw-&gt;mac.type &gt;= e1000_pch_spt) {</a>
<a name="ln704">		nvm-&gt;ops.read	= e1000_read_nvm_spt;</a>
<a name="ln705">		nvm-&gt;ops.update	= e1000_update_nvm_checksum_spt;</a>
<a name="ln706">	} else {</a>
<a name="ln707">		nvm-&gt;ops.read	= e1000_read_nvm_ich8lan;</a>
<a name="ln708">		nvm-&gt;ops.update	= e1000_update_nvm_checksum_ich8lan;</a>
<a name="ln709">	}</a>
<a name="ln710">	nvm-&gt;ops.valid_led_default = e1000_valid_led_default_ich8lan;</a>
<a name="ln711">	nvm-&gt;ops.validate	= e1000_validate_nvm_checksum_ich8lan;</a>
<a name="ln712">	nvm-&gt;ops.write		= e1000_write_nvm_ich8lan;</a>
<a name="ln713"> </a>
<a name="ln714">	return E1000_SUCCESS;</a>
<a name="ln715">}</a>
<a name="ln716"> </a>
<a name="ln717">/**</a>
<a name="ln718"> *  e1000_init_mac_params_ich8lan - Initialize MAC function pointers</a>
<a name="ln719"> *  @hw: pointer to the HW structure</a>
<a name="ln720"> *</a>
<a name="ln721"> *  Initialize family-specific MAC parameters and function</a>
<a name="ln722"> *  pointers.</a>
<a name="ln723"> **/</a>
<a name="ln724">static s32 e1000_init_mac_params_ich8lan(struct e1000_hw *hw)</a>
<a name="ln725">{</a>
<a name="ln726">	struct e1000_mac_info *mac = &amp;hw-&gt;mac;</a>
<a name="ln727"> </a>
<a name="ln728">	DEBUGFUNC(&quot;e1000_init_mac_params_ich8lan&quot;);</a>
<a name="ln729"> </a>
<a name="ln730">	/* Set media type function pointer */</a>
<a name="ln731">	hw-&gt;phy.media_type = e1000_media_type_copper;</a>
<a name="ln732"> </a>
<a name="ln733">	/* Set mta register count */</a>
<a name="ln734">	mac-&gt;mta_reg_count = 32;</a>
<a name="ln735">	/* Set rar entry count */</a>
<a name="ln736">	mac-&gt;rar_entry_count = E1000_ICH_RAR_ENTRIES;</a>
<a name="ln737">	if (mac-&gt;type == e1000_ich8lan)</a>
<a name="ln738">		mac-&gt;rar_entry_count--;</a>
<a name="ln739">	/* Set if part includes ASF firmware */</a>
<a name="ln740">	mac-&gt;asf_firmware_present = TRUE;</a>
<a name="ln741">	/* FWSM register */</a>
<a name="ln742">	mac-&gt;has_fwsm = TRUE;</a>
<a name="ln743">	/* ARC subsystem not supported */</a>
<a name="ln744">	mac-&gt;arc_subsystem_valid = FALSE;</a>
<a name="ln745">	/* Adaptive IFS supported */</a>
<a name="ln746">	mac-&gt;adaptive_ifs = TRUE;</a>
<a name="ln747"> </a>
<a name="ln748">	/* Function pointers */</a>
<a name="ln749"> </a>
<a name="ln750">	/* bus type/speed/width */</a>
<a name="ln751">	mac-&gt;ops.get_bus_info = e1000_get_bus_info_ich8lan;</a>
<a name="ln752">	/* function id */</a>
<a name="ln753">	mac-&gt;ops.set_lan_id = e1000_set_lan_id_single_port;</a>
<a name="ln754">	/* reset */</a>
<a name="ln755">	mac-&gt;ops.reset_hw = e1000_reset_hw_ich8lan;</a>
<a name="ln756">	/* hw initialization */</a>
<a name="ln757">	mac-&gt;ops.init_hw = e1000_init_hw_ich8lan;</a>
<a name="ln758">	/* link setup */</a>
<a name="ln759">	mac-&gt;ops.setup_link = e1000_setup_link_ich8lan;</a>
<a name="ln760">	/* physical interface setup */</a>
<a name="ln761">	mac-&gt;ops.setup_physical_interface = e1000_setup_copper_link_ich8lan;</a>
<a name="ln762">	/* check for link */</a>
<a name="ln763">	mac-&gt;ops.check_for_link = e1000_check_for_copper_link_ich8lan;</a>
<a name="ln764">	/* link info */</a>
<a name="ln765">	mac-&gt;ops.get_link_up_info = e1000_get_link_up_info_ich8lan;</a>
<a name="ln766">	/* multicast address update */</a>
<a name="ln767">	mac-&gt;ops.update_mc_addr_list = e1000_update_mc_addr_list_generic;</a>
<a name="ln768">	/* clear hardware counters */</a>
<a name="ln769">	mac-&gt;ops.clear_hw_cntrs = e1000_clear_hw_cntrs_ich8lan;</a>
<a name="ln770"> </a>
<a name="ln771">	/* LED and other operations */</a>
<a name="ln772">	switch (mac-&gt;type) {</a>
<a name="ln773">	case e1000_ich8lan:</a>
<a name="ln774">	case e1000_ich9lan:</a>
<a name="ln775">	case e1000_ich10lan:</a>
<a name="ln776">		/* check management mode */</a>
<a name="ln777">		mac-&gt;ops.check_mng_mode = e1000_check_mng_mode_ich8lan;</a>
<a name="ln778">		/* ID LED init */</a>
<a name="ln779">		mac-&gt;ops.id_led_init = e1000_id_led_init_generic;</a>
<a name="ln780">		/* blink LED */</a>
<a name="ln781">		mac-&gt;ops.blink_led = e1000_blink_led_generic;</a>
<a name="ln782">		/* setup LED */</a>
<a name="ln783">		mac-&gt;ops.setup_led = e1000_setup_led_generic;</a>
<a name="ln784">		/* cleanup LED */</a>
<a name="ln785">		mac-&gt;ops.cleanup_led = e1000_cleanup_led_ich8lan;</a>
<a name="ln786">		/* turn on/off LED */</a>
<a name="ln787">		mac-&gt;ops.led_on = e1000_led_on_ich8lan;</a>
<a name="ln788">		mac-&gt;ops.led_off = e1000_led_off_ich8lan;</a>
<a name="ln789">		break;</a>
<a name="ln790">	case e1000_pch2lan:</a>
<a name="ln791">		mac-&gt;rar_entry_count = E1000_PCH2_RAR_ENTRIES;</a>
<a name="ln792">		mac-&gt;ops.rar_set = e1000_rar_set_pch2lan;</a>
<a name="ln793">		/* fall-through */</a>
<a name="ln794">	case e1000_pch_lpt:</a>
<a name="ln795">	case e1000_pch_spt:</a>
<a name="ln796">	case e1000_pch_cnp:</a>
<a name="ln797">		/* multicast address update for pch2 */</a>
<a name="ln798">		mac-&gt;ops.update_mc_addr_list =</a>
<a name="ln799">			e1000_update_mc_addr_list_pch2lan;</a>
<a name="ln800">		/* fall-through */</a>
<a name="ln801">	case e1000_pchlan:</a>
<a name="ln802">		/* check management mode */</a>
<a name="ln803">		mac-&gt;ops.check_mng_mode = e1000_check_mng_mode_pchlan;</a>
<a name="ln804">		/* ID LED init */</a>
<a name="ln805">		mac-&gt;ops.id_led_init = e1000_id_led_init_pchlan;</a>
<a name="ln806">		/* setup LED */</a>
<a name="ln807">		mac-&gt;ops.setup_led = e1000_setup_led_pchlan;</a>
<a name="ln808">		/* cleanup LED */</a>
<a name="ln809">		mac-&gt;ops.cleanup_led = e1000_cleanup_led_pchlan;</a>
<a name="ln810">		/* turn on/off LED */</a>
<a name="ln811">		mac-&gt;ops.led_on = e1000_led_on_pchlan;</a>
<a name="ln812">		mac-&gt;ops.led_off = e1000_led_off_pchlan;</a>
<a name="ln813">		break;</a>
<a name="ln814">	default:</a>
<a name="ln815">		break;</a>
<a name="ln816">	}</a>
<a name="ln817"> </a>
<a name="ln818">	if (mac-&gt;type &gt;= e1000_pch_lpt) {</a>
<a name="ln819">		mac-&gt;rar_entry_count = E1000_PCH_LPT_RAR_ENTRIES;</a>
<a name="ln820">		mac-&gt;ops.rar_set = e1000_rar_set_pch_lpt;</a>
<a name="ln821">		mac-&gt;ops.setup_physical_interface = e1000_setup_copper_link_pch_lpt;</a>
<a name="ln822">		mac-&gt;ops.set_obff_timer = e1000_set_obff_timer_pch_lpt;</a>
<a name="ln823">	}</a>
<a name="ln824"> </a>
<a name="ln825">	/* Enable PCS Lock-loss workaround for ICH8 */</a>
<a name="ln826">	if (mac-&gt;type == e1000_ich8lan)</a>
<a name="ln827">		e1000_set_kmrn_lock_loss_workaround_ich8lan(hw, TRUE);</a>
<a name="ln828"> </a>
<a name="ln829">	return E1000_SUCCESS;</a>
<a name="ln830">}</a>
<a name="ln831"> </a>
<a name="ln832">/**</a>
<a name="ln833"> *  __e1000_access_emi_reg_locked - Read/write EMI register</a>
<a name="ln834"> *  @hw: pointer to the HW structure</a>
<a name="ln835"> *  @addr: EMI address to program</a>
<a name="ln836"> *  @data: pointer to value to read/write from/to the EMI address</a>
<a name="ln837"> *  @read: boolean flag to indicate read or write</a>
<a name="ln838"> *</a>
<a name="ln839"> *  This helper function assumes the SW/FW/HW Semaphore is already acquired.</a>
<a name="ln840"> **/</a>
<a name="ln841">static s32 __e1000_access_emi_reg_locked(struct e1000_hw *hw, u16 address,</a>
<a name="ln842">					 u16 *data, bool read)</a>
<a name="ln843">{</a>
<a name="ln844">	s32 ret_val;</a>
<a name="ln845"> </a>
<a name="ln846">	DEBUGFUNC(&quot;__e1000_access_emi_reg_locked&quot;);</a>
<a name="ln847"> </a>
<a name="ln848">	ret_val = hw-&gt;phy.ops.write_reg_locked(hw, I82579_EMI_ADDR, address);</a>
<a name="ln849">	if (ret_val)</a>
<a name="ln850">		return ret_val;</a>
<a name="ln851"> </a>
<a name="ln852">	if (read)</a>
<a name="ln853">		ret_val = hw-&gt;phy.ops.read_reg_locked(hw, I82579_EMI_DATA,</a>
<a name="ln854">						      data);</a>
<a name="ln855">	else</a>
<a name="ln856">		ret_val = hw-&gt;phy.ops.write_reg_locked(hw, I82579_EMI_DATA,</a>
<a name="ln857">						       *data);</a>
<a name="ln858"> </a>
<a name="ln859">	return ret_val;</a>
<a name="ln860">}</a>
<a name="ln861"> </a>
<a name="ln862">/**</a>
<a name="ln863"> *  e1000_read_emi_reg_locked - Read Extended Management Interface register</a>
<a name="ln864"> *  @hw: pointer to the HW structure</a>
<a name="ln865"> *  @addr: EMI address to program</a>
<a name="ln866"> *  @data: value to be read from the EMI address</a>
<a name="ln867"> *</a>
<a name="ln868"> *  Assumes the SW/FW/HW Semaphore is already acquired.</a>
<a name="ln869"> **/</a>
<a name="ln870">s32 e1000_read_emi_reg_locked(struct e1000_hw *hw, u16 addr, u16 *data)</a>
<a name="ln871">{</a>
<a name="ln872">	DEBUGFUNC(&quot;e1000_read_emi_reg_locked&quot;);</a>
<a name="ln873"> </a>
<a name="ln874">	return __e1000_access_emi_reg_locked(hw, addr, data, TRUE);</a>
<a name="ln875">}</a>
<a name="ln876"> </a>
<a name="ln877">/**</a>
<a name="ln878"> *  e1000_write_emi_reg_locked - Write Extended Management Interface register</a>
<a name="ln879"> *  @hw: pointer to the HW structure</a>
<a name="ln880"> *  @addr: EMI address to program</a>
<a name="ln881"> *  @data: value to be written to the EMI address</a>
<a name="ln882"> *</a>
<a name="ln883"> *  Assumes the SW/FW/HW Semaphore is already acquired.</a>
<a name="ln884"> **/</a>
<a name="ln885">s32 e1000_write_emi_reg_locked(struct e1000_hw *hw, u16 addr, u16 data)</a>
<a name="ln886">{</a>
<a name="ln887">	DEBUGFUNC(&quot;e1000_read_emi_reg_locked&quot;);</a>
<a name="ln888"> </a>
<a name="ln889">	return __e1000_access_emi_reg_locked(hw, addr, &amp;data, FALSE);</a>
<a name="ln890">}</a>
<a name="ln891"> </a>
<a name="ln892">/**</a>
<a name="ln893"> *  e1000_set_eee_pchlan - Enable/disable EEE support</a>
<a name="ln894"> *  @hw: pointer to the HW structure</a>
<a name="ln895"> *</a>
<a name="ln896"> *  Enable/disable EEE based on setting in dev_spec structure, the duplex of</a>
<a name="ln897"> *  the link and the EEE capabilities of the link partner.  The LPI Control</a>
<a name="ln898"> *  register bits will remain set only if/when link is up.</a>
<a name="ln899"> *</a>
<a name="ln900"> *  EEE LPI must not be asserted earlier than one second after link is up.</a>
<a name="ln901"> *  On 82579, EEE LPI should not be enabled until such time otherwise there</a>
<a name="ln902"> *  can be link issues with some switches.  Other devices can have EEE LPI</a>
<a name="ln903"> *  enabled immediately upon link up since they have a timer in hardware which</a>
<a name="ln904"> *  prevents LPI from being asserted too early.</a>
<a name="ln905"> **/</a>
<a name="ln906">s32 e1000_set_eee_pchlan(struct e1000_hw *hw)</a>
<a name="ln907">{</a>
<a name="ln908">	struct e1000_dev_spec_ich8lan *dev_spec = &amp;hw-&gt;dev_spec.ich8lan;</a>
<a name="ln909">	s32 ret_val;</a>
<a name="ln910">	u16 lpa, pcs_status, adv, adv_addr, lpi_ctrl, data;</a>
<a name="ln911"> </a>
<a name="ln912">	DEBUGFUNC(&quot;e1000_set_eee_pchlan&quot;);</a>
<a name="ln913"> </a>
<a name="ln914">	switch (hw-&gt;phy.type) {</a>
<a name="ln915">	case e1000_phy_82579:</a>
<a name="ln916">		lpa = I82579_EEE_LP_ABILITY;</a>
<a name="ln917">		pcs_status = I82579_EEE_PCS_STATUS;</a>
<a name="ln918">		adv_addr = I82579_EEE_ADVERTISEMENT;</a>
<a name="ln919">		break;</a>
<a name="ln920">	case e1000_phy_i217:</a>
<a name="ln921">		lpa = I217_EEE_LP_ABILITY;</a>
<a name="ln922">		pcs_status = I217_EEE_PCS_STATUS;</a>
<a name="ln923">		adv_addr = I217_EEE_ADVERTISEMENT;</a>
<a name="ln924">		break;</a>
<a name="ln925">	default:</a>
<a name="ln926">		return E1000_SUCCESS;</a>
<a name="ln927">	}</a>
<a name="ln928"> </a>
<a name="ln929">	ret_val = hw-&gt;phy.ops.acquire(hw);</a>
<a name="ln930">	if (ret_val)</a>
<a name="ln931">		return ret_val;</a>
<a name="ln932"> </a>
<a name="ln933">	ret_val = hw-&gt;phy.ops.read_reg_locked(hw, I82579_LPI_CTRL, &amp;lpi_ctrl);</a>
<a name="ln934">	if (ret_val)</a>
<a name="ln935">		goto release;</a>
<a name="ln936"> </a>
<a name="ln937">	/* Clear bits that enable EEE in various speeds */</a>
<a name="ln938">	lpi_ctrl &amp;= ~I82579_LPI_CTRL_ENABLE_MASK;</a>
<a name="ln939"> </a>
<a name="ln940">	/* Enable EEE if not disabled by user */</a>
<a name="ln941">	if (!dev_spec-&gt;eee_disable) {</a>
<a name="ln942">		/* Save off link partner's EEE ability */</a>
<a name="ln943">		ret_val = e1000_read_emi_reg_locked(hw, lpa,</a>
<a name="ln944">						    &amp;dev_spec-&gt;eee_lp_ability);</a>
<a name="ln945">		if (ret_val)</a>
<a name="ln946">			goto release;</a>
<a name="ln947"> </a>
<a name="ln948">		/* Read EEE advertisement */</a>
<a name="ln949">		ret_val = e1000_read_emi_reg_locked(hw, adv_addr, &amp;adv);</a>
<a name="ln950">		if (ret_val)</a>
<a name="ln951">			goto release;</a>
<a name="ln952"> </a>
<a name="ln953">		/* Enable EEE only for speeds in which the link partner is</a>
<a name="ln954">		 * EEE capable and for which we advertise EEE.</a>
<a name="ln955">		 */</a>
<a name="ln956">		if (adv &amp; dev_spec-&gt;eee_lp_ability &amp; I82579_EEE_1000_SUPPORTED)</a>
<a name="ln957">			lpi_ctrl |= I82579_LPI_CTRL_1000_ENABLE;</a>
<a name="ln958"> </a>
<a name="ln959">		if (adv &amp; dev_spec-&gt;eee_lp_ability &amp; I82579_EEE_100_SUPPORTED) {</a>
<a name="ln960">			hw-&gt;phy.ops.read_reg_locked(hw, PHY_LP_ABILITY, &amp;data);</a>
<a name="ln961">			if (data &amp; NWAY_LPAR_100TX_FD_CAPS)</a>
<a name="ln962">				lpi_ctrl |= I82579_LPI_CTRL_100_ENABLE;</a>
<a name="ln963">			else</a>
<a name="ln964">				/* EEE is not supported in 100Half, so ignore</a>
<a name="ln965">				 * partner's EEE in 100 ability if full-duplex</a>
<a name="ln966">				 * is not advertised.</a>
<a name="ln967">				 */</a>
<a name="ln968">				dev_spec-&gt;eee_lp_ability &amp;=</a>
<a name="ln969">				    ~I82579_EEE_100_SUPPORTED;</a>
<a name="ln970">		}</a>
<a name="ln971">	}</a>
<a name="ln972"> </a>
<a name="ln973">	if (hw-&gt;phy.type == e1000_phy_82579) {</a>
<a name="ln974">		ret_val = e1000_read_emi_reg_locked(hw, I82579_LPI_PLL_SHUT,</a>
<a name="ln975">						    &amp;data);</a>
<a name="ln976">		if (ret_val)</a>
<a name="ln977">			goto release;</a>
<a name="ln978"> </a>
<a name="ln979">		data &amp;= ~I82579_LPI_100_PLL_SHUT;</a>
<a name="ln980">		ret_val = e1000_write_emi_reg_locked(hw, I82579_LPI_PLL_SHUT,</a>
<a name="ln981">						     data);</a>
<a name="ln982">	}</a>
<a name="ln983"> </a>
<a name="ln984">	/* R/Clr IEEE MMD 3.1 bits 11:10 - Tx/Rx LPI Received */</a>
<a name="ln985">	ret_val = e1000_read_emi_reg_locked(hw, pcs_status, &amp;data);</a>
<a name="ln986">	if (ret_val)</a>
<a name="ln987">		goto release;</a>
<a name="ln988"> </a>
<a name="ln989">	ret_val = hw-&gt;phy.ops.write_reg_locked(hw, I82579_LPI_CTRL, lpi_ctrl);</a>
<a name="ln990">release:</a>
<a name="ln991">	hw-&gt;phy.ops.release(hw);</a>
<a name="ln992"> </a>
<a name="ln993">	return ret_val;</a>
<a name="ln994">}</a>
<a name="ln995"> </a>
<a name="ln996">/**</a>
<a name="ln997"> *  e1000_k1_workaround_lpt_lp - K1 workaround on Lynxpoint-LP</a>
<a name="ln998"> *  @hw:   pointer to the HW structure</a>
<a name="ln999"> *  @link: link up bool flag</a>
<a name="ln1000"> *</a>
<a name="ln1001"> *  When K1 is enabled for 1Gbps, the MAC can miss 2 DMA completion indications</a>
<a name="ln1002"> *  preventing further DMA write requests.  Workaround the issue by disabling</a>
<a name="ln1003"> *  the de-assertion of the clock request when in 1Gpbs mode.</a>
<a name="ln1004"> *  Also, set appropriate Tx re-transmission timeouts for 10 and 100Half link</a>
<a name="ln1005"> *  speeds in order to avoid Tx hangs.</a>
<a name="ln1006"> **/</a>
<a name="ln1007">static s32 e1000_k1_workaround_lpt_lp(struct e1000_hw *hw, bool link)</a>
<a name="ln1008">{</a>
<a name="ln1009">	u32 fextnvm6 = E1000_READ_REG(hw, E1000_FEXTNVM6);</a>
<a name="ln1010">	u32 status = E1000_READ_REG(hw, E1000_STATUS);</a>
<a name="ln1011">	s32 ret_val = E1000_SUCCESS;</a>
<a name="ln1012">	u16 reg;</a>
<a name="ln1013"> </a>
<a name="ln1014">	if (link &amp;&amp; (status &amp; E1000_STATUS_SPEED_1000)) {</a>
<a name="ln1015">		ret_val = hw-&gt;phy.ops.acquire(hw);</a>
<a name="ln1016">		if (ret_val)</a>
<a name="ln1017">			return ret_val;</a>
<a name="ln1018"> </a>
<a name="ln1019">		ret_val =</a>
<a name="ln1020">		    e1000_read_kmrn_reg_locked(hw, E1000_KMRNCTRLSTA_K1_CONFIG,</a>
<a name="ln1021">					       &amp;reg);</a>
<a name="ln1022">		if (ret_val)</a>
<a name="ln1023">			goto release;</a>
<a name="ln1024"> </a>
<a name="ln1025">		ret_val =</a>
<a name="ln1026">		    e1000_write_kmrn_reg_locked(hw,</a>
<a name="ln1027">						E1000_KMRNCTRLSTA_K1_CONFIG,</a>
<a name="ln1028">						reg &amp;</a>
<a name="ln1029">						~E1000_KMRNCTRLSTA_K1_ENABLE);</a>
<a name="ln1030">		if (ret_val)</a>
<a name="ln1031">			goto release;</a>
<a name="ln1032"> </a>
<a name="ln1033">		usec_delay(10);</a>
<a name="ln1034"> </a>
<a name="ln1035">		E1000_WRITE_REG(hw, E1000_FEXTNVM6,</a>
<a name="ln1036">				fextnvm6 | E1000_FEXTNVM6_REQ_PLL_CLK);</a>
<a name="ln1037"> </a>
<a name="ln1038">		ret_val =</a>
<a name="ln1039">		    e1000_write_kmrn_reg_locked(hw,</a>
<a name="ln1040">						E1000_KMRNCTRLSTA_K1_CONFIG,</a>
<a name="ln1041">						reg);</a>
<a name="ln1042">release:</a>
<a name="ln1043">		hw-&gt;phy.ops.release(hw);</a>
<a name="ln1044">	} else {</a>
<a name="ln1045">		/* clear FEXTNVM6 bit 8 on link down or 10/100 */</a>
<a name="ln1046">		fextnvm6 &amp;= ~E1000_FEXTNVM6_REQ_PLL_CLK;</a>
<a name="ln1047"> </a>
<a name="ln1048">		if ((hw-&gt;phy.revision &gt; 5) || !link ||</a>
<a name="ln1049">		    ((status &amp; E1000_STATUS_SPEED_100) &amp;&amp;</a>
<a name="ln1050">		     (status &amp; E1000_STATUS_FD)))</a>
<a name="ln1051">			goto update_fextnvm6;</a>
<a name="ln1052"> </a>
<a name="ln1053">		ret_val = hw-&gt;phy.ops.read_reg(hw, I217_INBAND_CTRL, &amp;reg);</a>
<a name="ln1054">		if (ret_val)</a>
<a name="ln1055">			return ret_val;</a>
<a name="ln1056"> </a>
<a name="ln1057">		/* Clear link status transmit timeout */</a>
<a name="ln1058">		reg &amp;= ~I217_INBAND_CTRL_LINK_STAT_TX_TIMEOUT_MASK;</a>
<a name="ln1059"> </a>
<a name="ln1060">		if (status &amp; E1000_STATUS_SPEED_100) {</a>
<a name="ln1061">			/* Set inband Tx timeout to 5x10us for 100Half */</a>
<a name="ln1062">			reg |= 5 &lt;&lt; I217_INBAND_CTRL_LINK_STAT_TX_TIMEOUT_SHIFT;</a>
<a name="ln1063"> </a>
<a name="ln1064">			/* Do not extend the K1 entry latency for 100Half */</a>
<a name="ln1065">			fextnvm6 &amp;= ~E1000_FEXTNVM6_ENABLE_K1_ENTRY_CONDITION;</a>
<a name="ln1066">		} else {</a>
<a name="ln1067">			/* Set inband Tx timeout to 50x10us for 10Full/Half */</a>
<a name="ln1068">			reg |= 50 &lt;&lt;</a>
<a name="ln1069">			       I217_INBAND_CTRL_LINK_STAT_TX_TIMEOUT_SHIFT;</a>
<a name="ln1070"> </a>
<a name="ln1071">			/* Extend the K1 entry latency for 10 Mbps */</a>
<a name="ln1072">			fextnvm6 |= E1000_FEXTNVM6_ENABLE_K1_ENTRY_CONDITION;</a>
<a name="ln1073">		}</a>
<a name="ln1074"> </a>
<a name="ln1075">		ret_val = hw-&gt;phy.ops.write_reg(hw, I217_INBAND_CTRL, reg);</a>
<a name="ln1076">		if (ret_val)</a>
<a name="ln1077">			return ret_val;</a>
<a name="ln1078"> </a>
<a name="ln1079">update_fextnvm6:</a>
<a name="ln1080">		E1000_WRITE_REG(hw, E1000_FEXTNVM6, fextnvm6);</a>
<a name="ln1081">	}</a>
<a name="ln1082"> </a>
<a name="ln1083">	return ret_val;</a>
<a name="ln1084">}</a>
<a name="ln1085"> </a>
<a name="ln1086">static u64 e1000_ltr2ns(u16 ltr)</a>
<a name="ln1087">{</a>
<a name="ln1088">	u32 value, scale;</a>
<a name="ln1089"> </a>
<a name="ln1090">	/* Determine the latency in nsec based on the LTR value &amp; scale */</a>
<a name="ln1091">	value = ltr &amp; E1000_LTRV_VALUE_MASK;</a>
<a name="ln1092">	scale = (ltr &amp; E1000_LTRV_SCALE_MASK) &gt;&gt; E1000_LTRV_SCALE_SHIFT;</a>
<a name="ln1093"> </a>
<a name="ln1094">	return value * (1 &lt;&lt; (scale * E1000_LTRV_SCALE_FACTOR));</a>
<a name="ln1095">}</a>
<a name="ln1096"> </a>
<a name="ln1097">/**</a>
<a name="ln1098"> *  e1000_platform_pm_pch_lpt - Set platform power management values</a>
<a name="ln1099"> *  @hw: pointer to the HW structure</a>
<a name="ln1100"> *  @link: bool indicating link status</a>
<a name="ln1101"> *</a>
<a name="ln1102"> *  Set the Latency Tolerance Reporting (LTR) values for the &quot;PCIe-like&quot;</a>
<a name="ln1103"> *  GbE MAC in the Lynx Point PCH based on Rx buffer size and link speed</a>
<a name="ln1104"> *  when link is up (which must not exceed the maximum latency supported</a>
<a name="ln1105"> *  by the platform), otherwise specify there is no LTR requirement.</a>
<a name="ln1106"> *  Unlike TRUE-PCIe devices which set the LTR maximum snoop/no-snoop</a>
<a name="ln1107"> *  latencies in the LTR Extended Capability Structure in the PCIe Extended</a>
<a name="ln1108"> *  Capability register set, on this device LTR is set by writing the</a>
<a name="ln1109"> *  equivalent snoop/no-snoop latencies in the LTRV register in the MAC and</a>
<a name="ln1110"> *  set the SEND bit to send an Intel On-chip System Fabric sideband (IOSF-SB)</a>
<a name="ln1111"> *  message to the PMC.</a>
<a name="ln1112"> *</a>
<a name="ln1113"> *  Use the LTR value to calculate the Optimized Buffer Flush/Fill (OBFF)</a>
<a name="ln1114"> *  high-water mark.</a>
<a name="ln1115"> **/</a>
<a name="ln1116">static s32 e1000_platform_pm_pch_lpt(struct e1000_hw *hw, bool link)</a>
<a name="ln1117">{</a>
<a name="ln1118">	u32 reg = link &lt;&lt; (E1000_LTRV_REQ_SHIFT + E1000_LTRV_NOSNOOP_SHIFT) |</a>
<a name="ln1119">		  link &lt;&lt; E1000_LTRV_REQ_SHIFT | E1000_LTRV_SEND;</a>
<a name="ln1120">	u16 lat_enc = 0;	/* latency encoded */</a>
<a name="ln1121">	s32 obff_hwm = 0;</a>
<a name="ln1122"> </a>
<a name="ln1123">	DEBUGFUNC(&quot;e1000_platform_pm_pch_lpt&quot;);</a>
<a name="ln1124"> </a>
<a name="ln1125">	if (link) {</a>
<a name="ln1126">		u16 speed, duplex, scale = 0;</a>
<a name="ln1127">		u16 max_snoop, max_nosnoop;</a>
<a name="ln1128">		u16 max_ltr_enc;	/* max LTR latency encoded */</a>
<a name="ln1129">		s64 lat_ns;</a>
<a name="ln1130">		s64 value;</a>
<a name="ln1131">		u32 rxa;</a>
<a name="ln1132"> </a>
<a name="ln1133">		if (!hw-&gt;mac.max_frame_size) {</a>
<a name="ln1134">			DEBUGOUT(&quot;max_frame_size not set.\n&quot;);</a>
<a name="ln1135">			return -E1000_ERR_CONFIG;</a>
<a name="ln1136">		}</a>
<a name="ln1137"> </a>
<a name="ln1138">		hw-&gt;mac.ops.get_link_up_info(hw, &amp;speed, &amp;duplex);</a>
<a name="ln1139">		if (!speed) {</a>
<a name="ln1140">			DEBUGOUT(&quot;Speed not set.\n&quot;);</a>
<a name="ln1141">			return -E1000_ERR_CONFIG;</a>
<a name="ln1142">		}</a>
<a name="ln1143"> </a>
<a name="ln1144">		/* Rx Packet Buffer Allocation size (KB) */</a>
<a name="ln1145">		rxa = E1000_READ_REG(hw, E1000_PBA) &amp; E1000_PBA_RXA_MASK;</a>
<a name="ln1146"> </a>
<a name="ln1147">		/* Determine the maximum latency tolerated by the device.</a>
<a name="ln1148">		 *</a>
<a name="ln1149">		 * Per the PCIe spec, the tolerated latencies are encoded as</a>
<a name="ln1150">		 * a 3-bit encoded scale (only 0-5 are valid) multiplied by</a>
<a name="ln1151">		 * a 10-bit value (0-1023) to provide a range from 1 ns to</a>
<a name="ln1152">		 * 2^25*(2^10-1) ns.  The scale is encoded as 0=2^0ns,</a>
<a name="ln1153">		 * 1=2^5ns, 2=2^10ns,...5=2^25ns.</a>
<a name="ln1154">		 */</a>
<a name="ln1155">		lat_ns = ((s64)rxa * 1024 -</a>
<a name="ln1156">			  (2 * (s64)hw-&gt;mac.max_frame_size)) * 8 * 1000;</a>
<a name="ln1157">		if (lat_ns &lt; 0)</a>
<a name="ln1158">			lat_ns = 0;</a>
<a name="ln1159">		else</a>
<a name="ln1160">			lat_ns /= speed;</a>
<a name="ln1161">		value = lat_ns;</a>
<a name="ln1162"> </a>
<a name="ln1163">		while (value &gt; E1000_LTRV_VALUE_MASK) {</a>
<a name="ln1164">			scale++;</a>
<a name="ln1165">			value = E1000_DIVIDE_ROUND_UP(value, (1 &lt;&lt; 5));</a>
<a name="ln1166">		}</a>
<a name="ln1167">		if (scale &gt; E1000_LTRV_SCALE_MAX) {</a>
<a name="ln1168">			DEBUGOUT1(&quot;Invalid LTR latency scale %d\n&quot;, scale);</a>
<a name="ln1169">			return -E1000_ERR_CONFIG;</a>
<a name="ln1170">		}</a>
<a name="ln1171">		lat_enc = (u16)((scale &lt;&lt; E1000_LTRV_SCALE_SHIFT) | value);</a>
<a name="ln1172"> </a>
<a name="ln1173">		/* Determine the maximum latency tolerated by the platform */</a>
<a name="ln1174">		e1000_read_pci_cfg(hw, E1000_PCI_LTR_CAP_LPT, &amp;max_snoop);</a>
<a name="ln1175">		e1000_read_pci_cfg(hw, E1000_PCI_LTR_CAP_LPT + 2, &amp;max_nosnoop);</a>
<a name="ln1176">		max_ltr_enc = E1000_MAX(max_snoop, max_nosnoop);</a>
<a name="ln1177"> </a>
<a name="ln1178">		if (lat_enc &gt; max_ltr_enc) {</a>
<a name="ln1179">			lat_enc = max_ltr_enc;</a>
<a name="ln1180">			lat_ns = e1000_ltr2ns(max_ltr_enc);</a>
<a name="ln1181">		}</a>
<a name="ln1182"> </a>
<a name="ln1183">		if (lat_ns) {</a>
<a name="ln1184">			lat_ns *= speed * 1000;</a>
<a name="ln1185">			lat_ns /= 8;</a>
<a name="ln1186">			lat_ns /= 1000000000;</a>
<a name="ln1187">			obff_hwm = (s32)(rxa - lat_ns);</a>
<a name="ln1188">		}</a>
<a name="ln1189">		if ((obff_hwm &lt; 0) || (obff_hwm &gt; E1000_SVT_OFF_HWM_MASK)) {</a>
<a name="ln1190">			DEBUGOUT1(&quot;Invalid high water mark %d\n&quot;, obff_hwm);</a>
<a name="ln1191">			return -E1000_ERR_CONFIG;</a>
<a name="ln1192">		}</a>
<a name="ln1193">	}</a>
<a name="ln1194"> </a>
<a name="ln1195">	/* Set Snoop and No-Snoop latencies the same */</a>
<a name="ln1196">	reg |= lat_enc | (lat_enc &lt;&lt; E1000_LTRV_NOSNOOP_SHIFT);</a>
<a name="ln1197">	E1000_WRITE_REG(hw, E1000_LTRV, reg);</a>
<a name="ln1198"> </a>
<a name="ln1199">	/* Set OBFF high water mark */</a>
<a name="ln1200">	reg = E1000_READ_REG(hw, E1000_SVT) &amp; ~E1000_SVT_OFF_HWM_MASK;</a>
<a name="ln1201">	reg |= obff_hwm;</a>
<a name="ln1202">	E1000_WRITE_REG(hw, E1000_SVT, reg);</a>
<a name="ln1203"> </a>
<a name="ln1204">	/* Enable OBFF */</a>
<a name="ln1205">	reg = E1000_READ_REG(hw, E1000_SVCR);</a>
<a name="ln1206">	reg |= E1000_SVCR_OFF_EN;</a>
<a name="ln1207">	/* Always unblock interrupts to the CPU even when the system is</a>
<a name="ln1208">	 * in OBFF mode. This ensures that small round-robin traffic</a>
<a name="ln1209">	 * (like ping) does not get dropped or experience long latency.</a>
<a name="ln1210">	 */</a>
<a name="ln1211">	reg |= E1000_SVCR_OFF_MASKINT;</a>
<a name="ln1212">	E1000_WRITE_REG(hw, E1000_SVCR, reg);</a>
<a name="ln1213"> </a>
<a name="ln1214">	return E1000_SUCCESS;</a>
<a name="ln1215">}</a>
<a name="ln1216"> </a>
<a name="ln1217">/**</a>
<a name="ln1218"> *  e1000_set_obff_timer_pch_lpt - Update Optimized Buffer Flush/Fill timer</a>
<a name="ln1219"> *  @hw: pointer to the HW structure</a>
<a name="ln1220"> *  @itr: interrupt throttling rate</a>
<a name="ln1221"> *</a>
<a name="ln1222"> *  Configure OBFF with the updated interrupt rate.</a>
<a name="ln1223"> **/</a>
<a name="ln1224">static s32 e1000_set_obff_timer_pch_lpt(struct e1000_hw *hw, u32 itr)</a>
<a name="ln1225">{</a>
<a name="ln1226">	u32 svcr;</a>
<a name="ln1227">	s32 timer;</a>
<a name="ln1228"> </a>
<a name="ln1229">	DEBUGFUNC(&quot;e1000_set_obff_timer_pch_lpt&quot;);</a>
<a name="ln1230"> </a>
<a name="ln1231">	/* Convert ITR value into microseconds for OBFF timer */</a>
<a name="ln1232">	timer = itr &amp; E1000_ITR_MASK;</a>
<a name="ln1233">	timer = (timer * E1000_ITR_MULT) / 1000;</a>
<a name="ln1234"> </a>
<a name="ln1235">	if ((timer &lt; 0) || (timer &gt; E1000_ITR_MASK)) {</a>
<a name="ln1236">		DEBUGOUT1(&quot;Invalid OBFF timer %d\n&quot;, timer);</a>
<a name="ln1237">		return -E1000_ERR_CONFIG;</a>
<a name="ln1238">	}</a>
<a name="ln1239"> </a>
<a name="ln1240">	svcr = E1000_READ_REG(hw, E1000_SVCR);</a>
<a name="ln1241">	svcr &amp;= ~E1000_SVCR_OFF_TIMER_MASK;</a>
<a name="ln1242">	svcr |= timer &lt;&lt; E1000_SVCR_OFF_TIMER_SHIFT;</a>
<a name="ln1243">	E1000_WRITE_REG(hw, E1000_SVCR, svcr);</a>
<a name="ln1244"> </a>
<a name="ln1245">	return E1000_SUCCESS;</a>
<a name="ln1246">}</a>
<a name="ln1247"> </a>
<a name="ln1248">/**</a>
<a name="ln1249"> *  e1000_enable_ulp_lpt_lp - configure Ultra Low Power mode for LynxPoint-LP</a>
<a name="ln1250"> *  @hw: pointer to the HW structure</a>
<a name="ln1251"> *  @to_sx: boolean indicating a system power state transition to Sx</a>
<a name="ln1252"> *</a>
<a name="ln1253"> *  When link is down, configure ULP mode to significantly reduce the power</a>
<a name="ln1254"> *  to the PHY.  If on a Manageability Engine (ME) enabled system, tell the</a>
<a name="ln1255"> *  ME firmware to start the ULP configuration.  If not on an ME enabled</a>
<a name="ln1256"> *  system, configure the ULP mode by software.</a>
<a name="ln1257"> */</a>
<a name="ln1258">s32 e1000_enable_ulp_lpt_lp(struct e1000_hw *hw, bool to_sx)</a>
<a name="ln1259">{</a>
<a name="ln1260">	u32 mac_reg;</a>
<a name="ln1261">	s32 ret_val = E1000_SUCCESS;</a>
<a name="ln1262">	u16 phy_reg;</a>
<a name="ln1263">	u16 oem_reg = 0;</a>
<a name="ln1264"> </a>
<a name="ln1265">	if ((hw-&gt;mac.type &lt; e1000_pch_lpt) ||</a>
<a name="ln1266">	    (hw-&gt;device_id == E1000_DEV_ID_PCH_LPT_I217_LM) ||</a>
<a name="ln1267">	    (hw-&gt;device_id == E1000_DEV_ID_PCH_LPT_I217_V) ||</a>
<a name="ln1268">	    (hw-&gt;device_id == E1000_DEV_ID_PCH_I218_LM2) ||</a>
<a name="ln1269">	    (hw-&gt;device_id == E1000_DEV_ID_PCH_I218_V2) ||</a>
<a name="ln1270">	    (hw-&gt;dev_spec.ich8lan.ulp_state == e1000_ulp_state_on))</a>
<a name="ln1271">		return 0;</a>
<a name="ln1272"> </a>
<a name="ln1273">	if (E1000_READ_REG(hw, E1000_FWSM) &amp; E1000_ICH_FWSM_FW_VALID) {</a>
<a name="ln1274">		/* Request ME configure ULP mode in the PHY */</a>
<a name="ln1275">		mac_reg = E1000_READ_REG(hw, E1000_H2ME);</a>
<a name="ln1276">		mac_reg |= E1000_H2ME_ULP | E1000_H2ME_ENFORCE_SETTINGS;</a>
<a name="ln1277">		E1000_WRITE_REG(hw, E1000_H2ME, mac_reg);</a>
<a name="ln1278"> </a>
<a name="ln1279">		goto out;</a>
<a name="ln1280">	}</a>
<a name="ln1281"> </a>
<a name="ln1282">	if (!to_sx) {</a>
<a name="ln1283">		int i = 0;</a>
<a name="ln1284"> </a>
<a name="ln1285">		/* Poll up to 5 seconds for Cable Disconnected indication */</a>
<a name="ln1286">		while (!(E1000_READ_REG(hw, E1000_FEXT) &amp;</a>
<a name="ln1287">			 E1000_FEXT_PHY_CABLE_DISCONNECTED)) {</a>
<a name="ln1288">			/* Bail if link is re-acquired */</a>
<a name="ln1289">			if (E1000_READ_REG(hw, E1000_STATUS) &amp; E1000_STATUS_LU)</a>
<a name="ln1290">				return -E1000_ERR_PHY;</a>
<a name="ln1291"> </a>
<a name="ln1292">			if (i++ == 100)</a>
<a name="ln1293">				break;</a>
<a name="ln1294"> </a>
<a name="ln1295">			msec_delay(50);</a>
<a name="ln1296">		}</a>
<a name="ln1297">		DEBUGOUT2(&quot;CABLE_DISCONNECTED %s set after %dmsec\n&quot;,</a>
<a name="ln1298">			 (E1000_READ_REG(hw, E1000_FEXT) &amp;</a>
<a name="ln1299">			  E1000_FEXT_PHY_CABLE_DISCONNECTED) ? &quot;&quot; : &quot;not&quot;,</a>
<a name="ln1300">			 i * 50);</a>
<a name="ln1301">	}</a>
<a name="ln1302"> </a>
<a name="ln1303">	ret_val = hw-&gt;phy.ops.acquire(hw);</a>
<a name="ln1304">	if (ret_val)</a>
<a name="ln1305">		goto out;</a>
<a name="ln1306"> </a>
<a name="ln1307">	/* Force SMBus mode in PHY */</a>
<a name="ln1308">	ret_val = e1000_read_phy_reg_hv_locked(hw, CV_SMB_CTRL, &amp;phy_reg);</a>
<a name="ln1309">	if (ret_val)</a>
<a name="ln1310">		goto release;</a>
<a name="ln1311">	phy_reg |= CV_SMB_CTRL_FORCE_SMBUS;</a>
<a name="ln1312">	e1000_write_phy_reg_hv_locked(hw, CV_SMB_CTRL, phy_reg);</a>
<a name="ln1313"> </a>
<a name="ln1314">	/* Force SMBus mode in MAC */</a>
<a name="ln1315">	mac_reg = E1000_READ_REG(hw, E1000_CTRL_EXT);</a>
<a name="ln1316">	mac_reg |= E1000_CTRL_EXT_FORCE_SMBUS;</a>
<a name="ln1317">	E1000_WRITE_REG(hw, E1000_CTRL_EXT, mac_reg);</a>
<a name="ln1318"> </a>
<a name="ln1319">	/* Si workaround for ULP entry flow on i127/rev6 h/w.  Enable</a>
<a name="ln1320">	 * LPLU and disable Gig speed when entering ULP</a>
<a name="ln1321">	 */</a>
<a name="ln1322">	if ((hw-&gt;phy.type == e1000_phy_i217) &amp;&amp; (hw-&gt;phy.revision == 6)) {</a>
<a name="ln1323">		ret_val = e1000_read_phy_reg_hv_locked(hw, HV_OEM_BITS,</a>
<a name="ln1324">						       &amp;oem_reg);</a>
<a name="ln1325">		if (ret_val)</a>
<a name="ln1326">			goto release;</a>
<a name="ln1327"> </a>
<a name="ln1328">		phy_reg = oem_reg;</a>
<a name="ln1329">		phy_reg |= HV_OEM_BITS_LPLU | HV_OEM_BITS_GBE_DIS;</a>
<a name="ln1330"> </a>
<a name="ln1331">		ret_val = e1000_write_phy_reg_hv_locked(hw, HV_OEM_BITS,</a>
<a name="ln1332">							phy_reg);</a>
<a name="ln1333"> </a>
<a name="ln1334">		if (ret_val)</a>
<a name="ln1335">			goto release;</a>
<a name="ln1336">	}</a>
<a name="ln1337"> </a>
<a name="ln1338">	/* Set Inband ULP Exit, Reset to SMBus mode and</a>
<a name="ln1339">	 * Disable SMBus Release on PERST# in PHY</a>
<a name="ln1340">	 */</a>
<a name="ln1341">	ret_val = e1000_read_phy_reg_hv_locked(hw, I218_ULP_CONFIG1, &amp;phy_reg);</a>
<a name="ln1342">	if (ret_val)</a>
<a name="ln1343">		goto release;</a>
<a name="ln1344">	phy_reg |= (I218_ULP_CONFIG1_RESET_TO_SMBUS |</a>
<a name="ln1345">		    I218_ULP_CONFIG1_DISABLE_SMB_PERST);</a>
<a name="ln1346">	if (to_sx) {</a>
<a name="ln1347">		if (E1000_READ_REG(hw, E1000_WUFC) &amp; E1000_WUFC_LNKC)</a>
<a name="ln1348">			phy_reg |= I218_ULP_CONFIG1_WOL_HOST;</a>
<a name="ln1349">		else</a>
<a name="ln1350">			phy_reg &amp;= ~I218_ULP_CONFIG1_WOL_HOST;</a>
<a name="ln1351"> </a>
<a name="ln1352">		phy_reg |= I218_ULP_CONFIG1_STICKY_ULP;</a>
<a name="ln1353">		phy_reg &amp;= ~I218_ULP_CONFIG1_INBAND_EXIT;</a>
<a name="ln1354">	} else {</a>
<a name="ln1355">		phy_reg |= I218_ULP_CONFIG1_INBAND_EXIT;</a>
<a name="ln1356">		phy_reg &amp;= ~I218_ULP_CONFIG1_STICKY_ULP;</a>
<a name="ln1357">		phy_reg &amp;= ~I218_ULP_CONFIG1_WOL_HOST;</a>
<a name="ln1358">	}</a>
<a name="ln1359">	e1000_write_phy_reg_hv_locked(hw, I218_ULP_CONFIG1, phy_reg);</a>
<a name="ln1360"> </a>
<a name="ln1361">	/* Set Disable SMBus Release on PERST# in MAC */</a>
<a name="ln1362">	mac_reg = E1000_READ_REG(hw, E1000_FEXTNVM7);</a>
<a name="ln1363">	mac_reg |= E1000_FEXTNVM7_DISABLE_SMB_PERST;</a>
<a name="ln1364">	E1000_WRITE_REG(hw, E1000_FEXTNVM7, mac_reg);</a>
<a name="ln1365"> </a>
<a name="ln1366">	/* Commit ULP changes in PHY by starting auto ULP configuration */</a>
<a name="ln1367">	phy_reg |= I218_ULP_CONFIG1_START;</a>
<a name="ln1368">	e1000_write_phy_reg_hv_locked(hw, I218_ULP_CONFIG1, phy_reg);</a>
<a name="ln1369"> </a>
<a name="ln1370">	if ((hw-&gt;phy.type == e1000_phy_i217) &amp;&amp; (hw-&gt;phy.revision == 6) &amp;&amp;</a>
<a name="ln1371">	    to_sx &amp;&amp; (E1000_READ_REG(hw, E1000_STATUS) &amp; E1000_STATUS_LU)) {</a>
<a name="ln1372">		ret_val = e1000_write_phy_reg_hv_locked(hw, HV_OEM_BITS,</a>
<a name="ln1373">							oem_reg);</a>
<a name="ln1374">		if (ret_val)</a>
<a name="ln1375">			goto release;</a>
<a name="ln1376">	}</a>
<a name="ln1377"> </a>
<a name="ln1378">release:</a>
<a name="ln1379">	hw-&gt;phy.ops.release(hw);</a>
<a name="ln1380">out:</a>
<a name="ln1381">	if (ret_val)</a>
<a name="ln1382">		DEBUGOUT1(&quot;Error in ULP enable flow: %d\n&quot;, ret_val);</a>
<a name="ln1383">	else</a>
<a name="ln1384">		hw-&gt;dev_spec.ich8lan.ulp_state = e1000_ulp_state_on;</a>
<a name="ln1385"> </a>
<a name="ln1386">	return ret_val;</a>
<a name="ln1387">}</a>
<a name="ln1388"> </a>
<a name="ln1389">/**</a>
<a name="ln1390"> *  e1000_disable_ulp_lpt_lp - unconfigure Ultra Low Power mode for LynxPoint-LP</a>
<a name="ln1391"> *  @hw: pointer to the HW structure</a>
<a name="ln1392"> *  @force: boolean indicating whether or not to force disabling ULP</a>
<a name="ln1393"> *</a>
<a name="ln1394"> *  Un-configure ULP mode when link is up, the system is transitioned from</a>
<a name="ln1395"> *  Sx or the driver is unloaded.  If on a Manageability Engine (ME) enabled</a>
<a name="ln1396"> *  system, poll for an indication from ME that ULP has been un-configured.</a>
<a name="ln1397"> *  If not on an ME enabled system, un-configure the ULP mode by software.</a>
<a name="ln1398"> *</a>
<a name="ln1399"> *  During nominal operation, this function is called when link is acquired</a>
<a name="ln1400"> *  to disable ULP mode (force=FALSE); otherwise, for example when unloading</a>
<a name="ln1401"> *  the driver or during Sx-&gt;S0 transitions, this is called with force=TRUE</a>
<a name="ln1402"> *  to forcibly disable ULP.</a>
<a name="ln1403"> */</a>
<a name="ln1404">s32 e1000_disable_ulp_lpt_lp(struct e1000_hw *hw, bool force)</a>
<a name="ln1405">{</a>
<a name="ln1406">	s32 ret_val = E1000_SUCCESS;</a>
<a name="ln1407">	u32 mac_reg;</a>
<a name="ln1408">	u16 phy_reg;</a>
<a name="ln1409">	int i = 0;</a>
<a name="ln1410"> </a>
<a name="ln1411">	if ((hw-&gt;mac.type &lt; e1000_pch_lpt) ||</a>
<a name="ln1412">	    (hw-&gt;device_id == E1000_DEV_ID_PCH_LPT_I217_LM) ||</a>
<a name="ln1413">	    (hw-&gt;device_id == E1000_DEV_ID_PCH_LPT_I217_V) ||</a>
<a name="ln1414">	    (hw-&gt;device_id == E1000_DEV_ID_PCH_I218_LM2) ||</a>
<a name="ln1415">	    (hw-&gt;device_id == E1000_DEV_ID_PCH_I218_V2) ||</a>
<a name="ln1416">	    (hw-&gt;dev_spec.ich8lan.ulp_state == e1000_ulp_state_off))</a>
<a name="ln1417">		return 0;</a>
<a name="ln1418"> </a>
<a name="ln1419">	if (E1000_READ_REG(hw, E1000_FWSM) &amp; E1000_ICH_FWSM_FW_VALID) {</a>
<a name="ln1420">		if (force) {</a>
<a name="ln1421">			/* Request ME un-configure ULP mode in the PHY */</a>
<a name="ln1422">			mac_reg = E1000_READ_REG(hw, E1000_H2ME);</a>
<a name="ln1423">			mac_reg &amp;= ~E1000_H2ME_ULP;</a>
<a name="ln1424">			mac_reg |= E1000_H2ME_ENFORCE_SETTINGS;</a>
<a name="ln1425">			E1000_WRITE_REG(hw, E1000_H2ME, mac_reg);</a>
<a name="ln1426">		}</a>
<a name="ln1427"> </a>
<a name="ln1428">		/* Poll up to 300msec for ME to clear ULP_CFG_DONE. */</a>
<a name="ln1429">		while (E1000_READ_REG(hw, E1000_FWSM) &amp;</a>
<a name="ln1430">		       E1000_FWSM_ULP_CFG_DONE) {</a>
<a name="ln1431">			if (i++ == 30) {</a>
<a name="ln1432">				ret_val = -E1000_ERR_PHY;</a>
<a name="ln1433">				goto out;</a>
<a name="ln1434">			}</a>
<a name="ln1435"> </a>
<a name="ln1436">			msec_delay(10);</a>
<a name="ln1437">		}</a>
<a name="ln1438">		DEBUGOUT1(&quot;ULP_CONFIG_DONE cleared after %dmsec\n&quot;, i * 10);</a>
<a name="ln1439"> </a>
<a name="ln1440">		if (force) {</a>
<a name="ln1441">			mac_reg = E1000_READ_REG(hw, E1000_H2ME);</a>
<a name="ln1442">			mac_reg &amp;= ~E1000_H2ME_ENFORCE_SETTINGS;</a>
<a name="ln1443">			E1000_WRITE_REG(hw, E1000_H2ME, mac_reg);</a>
<a name="ln1444">		} else {</a>
<a name="ln1445">			/* Clear H2ME.ULP after ME ULP configuration */</a>
<a name="ln1446">			mac_reg = E1000_READ_REG(hw, E1000_H2ME);</a>
<a name="ln1447">			mac_reg &amp;= ~E1000_H2ME_ULP;</a>
<a name="ln1448">			E1000_WRITE_REG(hw, E1000_H2ME, mac_reg);</a>
<a name="ln1449">		}</a>
<a name="ln1450"> </a>
<a name="ln1451">		goto out;</a>
<a name="ln1452">	}</a>
<a name="ln1453"> </a>
<a name="ln1454">	ret_val = hw-&gt;phy.ops.acquire(hw);</a>
<a name="ln1455">	if (ret_val)</a>
<a name="ln1456">		goto out;</a>
<a name="ln1457"> </a>
<a name="ln1458">	if (force)</a>
<a name="ln1459">		/* Toggle LANPHYPC Value bit */</a>
<a name="ln1460">		e1000_toggle_lanphypc_pch_lpt(hw);</a>
<a name="ln1461"> </a>
<a name="ln1462">	/* Unforce SMBus mode in PHY */</a>
<a name="ln1463">	ret_val = e1000_read_phy_reg_hv_locked(hw, CV_SMB_CTRL, &amp;phy_reg);</a>
<a name="ln1464">	if (ret_val) {</a>
<a name="ln1465">		/* The MAC might be in PCIe mode, so temporarily force to</a>
<a name="ln1466">		 * SMBus mode in order to access the PHY.</a>
<a name="ln1467">		 */</a>
<a name="ln1468">		mac_reg = E1000_READ_REG(hw, E1000_CTRL_EXT);</a>
<a name="ln1469">		mac_reg |= E1000_CTRL_EXT_FORCE_SMBUS;</a>
<a name="ln1470">		E1000_WRITE_REG(hw, E1000_CTRL_EXT, mac_reg);</a>
<a name="ln1471"> </a>
<a name="ln1472">		msec_delay(50);</a>
<a name="ln1473"> </a>
<a name="ln1474">		ret_val = e1000_read_phy_reg_hv_locked(hw, CV_SMB_CTRL,</a>
<a name="ln1475">						       &amp;phy_reg);</a>
<a name="ln1476">		if (ret_val)</a>
<a name="ln1477">			goto release;</a>
<a name="ln1478">	}</a>
<a name="ln1479">	phy_reg &amp;= ~CV_SMB_CTRL_FORCE_SMBUS;</a>
<a name="ln1480">	e1000_write_phy_reg_hv_locked(hw, CV_SMB_CTRL, phy_reg);</a>
<a name="ln1481"> </a>
<a name="ln1482">	/* Unforce SMBus mode in MAC */</a>
<a name="ln1483">	mac_reg = E1000_READ_REG(hw, E1000_CTRL_EXT);</a>
<a name="ln1484">	mac_reg &amp;= ~E1000_CTRL_EXT_FORCE_SMBUS;</a>
<a name="ln1485">	E1000_WRITE_REG(hw, E1000_CTRL_EXT, mac_reg);</a>
<a name="ln1486"> </a>
<a name="ln1487">	/* When ULP mode was previously entered, K1 was disabled by the</a>
<a name="ln1488">	 * hardware.  Re-Enable K1 in the PHY when exiting ULP.</a>
<a name="ln1489">	 */</a>
<a name="ln1490">	ret_val = e1000_read_phy_reg_hv_locked(hw, HV_PM_CTRL, &amp;phy_reg);</a>
<a name="ln1491">	if (ret_val)</a>
<a name="ln1492">		goto release;</a>
<a name="ln1493">	phy_reg |= HV_PM_CTRL_K1_ENABLE;</a>
<a name="ln1494">	e1000_write_phy_reg_hv_locked(hw, HV_PM_CTRL, phy_reg);</a>
<a name="ln1495"> </a>
<a name="ln1496">	/* Clear ULP enabled configuration */</a>
<a name="ln1497">	ret_val = e1000_read_phy_reg_hv_locked(hw, I218_ULP_CONFIG1, &amp;phy_reg);</a>
<a name="ln1498">	if (ret_val)</a>
<a name="ln1499">		goto release;</a>
<a name="ln1500">	phy_reg &amp;= ~(I218_ULP_CONFIG1_IND |</a>
<a name="ln1501">		     I218_ULP_CONFIG1_STICKY_ULP |</a>
<a name="ln1502">		     I218_ULP_CONFIG1_RESET_TO_SMBUS |</a>
<a name="ln1503">		     I218_ULP_CONFIG1_WOL_HOST |</a>
<a name="ln1504">		     I218_ULP_CONFIG1_INBAND_EXIT |</a>
<a name="ln1505">		     I218_ULP_CONFIG1_EN_ULP_LANPHYPC |</a>
<a name="ln1506">		     I218_ULP_CONFIG1_DIS_CLR_STICKY_ON_PERST |</a>
<a name="ln1507">		     I218_ULP_CONFIG1_DISABLE_SMB_PERST);</a>
<a name="ln1508">	e1000_write_phy_reg_hv_locked(hw, I218_ULP_CONFIG1, phy_reg);</a>
<a name="ln1509"> </a>
<a name="ln1510">	/* Commit ULP changes by starting auto ULP configuration */</a>
<a name="ln1511">	phy_reg |= I218_ULP_CONFIG1_START;</a>
<a name="ln1512">	e1000_write_phy_reg_hv_locked(hw, I218_ULP_CONFIG1, phy_reg);</a>
<a name="ln1513"> </a>
<a name="ln1514">	/* Clear Disable SMBus Release on PERST# in MAC */</a>
<a name="ln1515">	mac_reg = E1000_READ_REG(hw, E1000_FEXTNVM7);</a>
<a name="ln1516">	mac_reg &amp;= ~E1000_FEXTNVM7_DISABLE_SMB_PERST;</a>
<a name="ln1517">	E1000_WRITE_REG(hw, E1000_FEXTNVM7, mac_reg);</a>
<a name="ln1518"> </a>
<a name="ln1519">release:</a>
<a name="ln1520">	hw-&gt;phy.ops.release(hw);</a>
<a name="ln1521">	if (force) {</a>
<a name="ln1522">		hw-&gt;phy.ops.reset(hw);</a>
<a name="ln1523">		msec_delay(50);</a>
<a name="ln1524">	}</a>
<a name="ln1525">out:</a>
<a name="ln1526">	if (ret_val)</a>
<a name="ln1527">		DEBUGOUT1(&quot;Error in ULP disable flow: %d\n&quot;, ret_val);</a>
<a name="ln1528">	else</a>
<a name="ln1529">		hw-&gt;dev_spec.ich8lan.ulp_state = e1000_ulp_state_off;</a>
<a name="ln1530"> </a>
<a name="ln1531">	return ret_val;</a>
<a name="ln1532">}</a>
<a name="ln1533"> </a>
<a name="ln1534">/**</a>
<a name="ln1535"> *  e1000_check_for_copper_link_ich8lan - Check for link (Copper)</a>
<a name="ln1536"> *  @hw: pointer to the HW structure</a>
<a name="ln1537"> *</a>
<a name="ln1538"> *  Checks to see of the link status of the hardware has changed.  If a</a>
<a name="ln1539"> *  change in link status has been detected, then we read the PHY registers</a>
<a name="ln1540"> *  to get the current speed/duplex if link exists.</a>
<a name="ln1541"> **/</a>
<a name="ln1542">static s32 e1000_check_for_copper_link_ich8lan(struct e1000_hw *hw)</a>
<a name="ln1543">{</a>
<a name="ln1544">	struct e1000_mac_info *mac = &amp;hw-&gt;mac;</a>
<a name="ln1545">	s32 ret_val, tipg_reg = 0;</a>
<a name="ln1546">	u16 emi_addr, emi_val = 0;</a>
<a name="ln1547">	bool link;</a>
<a name="ln1548">	u16 phy_reg;</a>
<a name="ln1549"> </a>
<a name="ln1550">	DEBUGFUNC(&quot;e1000_check_for_copper_link_ich8lan&quot;);</a>
<a name="ln1551"> </a>
<a name="ln1552">	/* We only want to go out to the PHY registers to see if Auto-Neg</a>
<a name="ln1553">	 * has completed and/or if our link status has changed.  The</a>
<a name="ln1554">	 * get_link_status flag is set upon receiving a Link Status</a>
<a name="ln1555">	 * Change or Rx Sequence Error interrupt.</a>
<a name="ln1556">	 */</a>
<a name="ln1557">	if (!mac-&gt;get_link_status)</a>
<a name="ln1558">		return E1000_SUCCESS;</a>
<a name="ln1559"> </a>
<a name="ln1560">	/* First we want to see if the MII Status Register reports</a>
<a name="ln1561">	 * link.  If so, then we want to get the current speed/duplex</a>
<a name="ln1562">	 * of the PHY.</a>
<a name="ln1563">	 */</a>
<a name="ln1564">	ret_val = e1000_phy_has_link_generic(hw, 1, 0, &amp;link);</a>
<a name="ln1565">	if (ret_val)</a>
<a name="ln1566">		return ret_val;</a>
<a name="ln1567"> </a>
<a name="ln1568">	if (hw-&gt;mac.type == e1000_pchlan) {</a>
<a name="ln1569">		ret_val = e1000_k1_gig_workaround_hv(hw, link);</a>
<a name="ln1570">		if (ret_val)</a>
<a name="ln1571">			return ret_val;</a>
<a name="ln1572">	}</a>
<a name="ln1573"> </a>
<a name="ln1574">	/* When connected at 10Mbps half-duplex, some parts are excessively</a>
<a name="ln1575">	 * aggressive resulting in many collisions. To avoid this, increase</a>
<a name="ln1576">	 * the IPG and reduce Rx latency in the PHY.</a>
<a name="ln1577">	 */</a>
<a name="ln1578">	if ((hw-&gt;mac.type &gt;= e1000_pch2lan) &amp;&amp; link) {</a>
<a name="ln1579">		u16 speed, duplex;</a>
<a name="ln1580"> </a>
<a name="ln1581">		e1000_get_speed_and_duplex_copper_generic(hw, &amp;speed, &amp;duplex);</a>
<a name="ln1582">		tipg_reg = E1000_READ_REG(hw, E1000_TIPG);</a>
<a name="ln1583">		tipg_reg &amp;= ~E1000_TIPG_IPGT_MASK;</a>
<a name="ln1584"> </a>
<a name="ln1585">		if (duplex == HALF_DUPLEX &amp;&amp; speed == SPEED_10) {</a>
<a name="ln1586">			tipg_reg |= 0xFF;</a>
<a name="ln1587">			/* Reduce Rx latency in analog PHY */</a>
<a name="ln1588">			emi_val = 0;</a>
<a name="ln1589">		} else if (hw-&gt;mac.type &gt;= e1000_pch_spt &amp;&amp;</a>
<a name="ln1590">			   duplex == FULL_DUPLEX &amp;&amp; speed != SPEED_1000) {</a>
<a name="ln1591">			tipg_reg |= 0xC;</a>
<a name="ln1592">			emi_val = 1;</a>
<a name="ln1593">		} else {</a>
<a name="ln1594">			/* Roll back the default values */</a>
<a name="ln1595">			tipg_reg |= 0x08;</a>
<a name="ln1596">			emi_val = 1;</a>
<a name="ln1597">		}</a>
<a name="ln1598"> </a>
<a name="ln1599">		E1000_WRITE_REG(hw, E1000_TIPG, tipg_reg);</a>
<a name="ln1600"> </a>
<a name="ln1601">		ret_val = hw-&gt;phy.ops.acquire(hw);</a>
<a name="ln1602">		if (ret_val)</a>
<a name="ln1603">			return ret_val;</a>
<a name="ln1604"> </a>
<a name="ln1605">		if (hw-&gt;mac.type == e1000_pch2lan)</a>
<a name="ln1606">			emi_addr = I82579_RX_CONFIG;</a>
<a name="ln1607">		else</a>
<a name="ln1608">			emi_addr = I217_RX_CONFIG;</a>
<a name="ln1609">		ret_val = e1000_write_emi_reg_locked(hw, emi_addr, emi_val);</a>
<a name="ln1610"> </a>
<a name="ln1611"> </a>
<a name="ln1612">		if (hw-&gt;mac.type &gt;= e1000_pch_lpt) {</a>
<a name="ln1613">			u16 phy_reg;</a>
<a name="ln1614"> </a>
<a name="ln1615">			hw-&gt;phy.ops.read_reg_locked(hw, I217_PLL_CLOCK_GATE_REG,</a>
<a name="ln1616">						    &amp;phy_reg);</a>
<a name="ln1617">			phy_reg &amp;= ~I217_PLL_CLOCK_GATE_MASK;</a>
<a name="ln1618">			if (speed == SPEED_100 || speed == SPEED_10)</a>
<a name="ln1619">				phy_reg |= 0x3E8;</a>
<a name="ln1620">			else</a>
<a name="ln1621">				phy_reg |= 0xFA;</a>
<a name="ln1622">			hw-&gt;phy.ops.write_reg_locked(hw,</a>
<a name="ln1623">						     I217_PLL_CLOCK_GATE_REG,</a>
<a name="ln1624">						     phy_reg);</a>
<a name="ln1625"> </a>
<a name="ln1626">			if (speed == SPEED_1000) {</a>
<a name="ln1627">				hw-&gt;phy.ops.read_reg_locked(hw, HV_PM_CTRL,</a>
<a name="ln1628">							    &amp;phy_reg);</a>
<a name="ln1629"> </a>
<a name="ln1630">				phy_reg |= HV_PM_CTRL_K1_CLK_REQ;</a>
<a name="ln1631"> </a>
<a name="ln1632">				hw-&gt;phy.ops.write_reg_locked(hw, HV_PM_CTRL,</a>
<a name="ln1633">							     phy_reg);</a>
<a name="ln1634">				}</a>
<a name="ln1635">		 }</a>
<a name="ln1636">		hw-&gt;phy.ops.release(hw);</a>
<a name="ln1637"> </a>
<a name="ln1638">		if (ret_val)</a>
<a name="ln1639">			return ret_val;</a>
<a name="ln1640"> </a>
<a name="ln1641">		if (hw-&gt;mac.type &gt;= e1000_pch_spt) {</a>
<a name="ln1642">			u16 data;</a>
<a name="ln1643">			u16 ptr_gap;</a>
<a name="ln1644"> </a>
<a name="ln1645">			if (speed == SPEED_1000) {</a>
<a name="ln1646">				ret_val = hw-&gt;phy.ops.acquire(hw);</a>
<a name="ln1647">				if (ret_val)</a>
<a name="ln1648">					return ret_val;</a>
<a name="ln1649"> </a>
<a name="ln1650">				ret_val = hw-&gt;phy.ops.read_reg_locked(hw,</a>
<a name="ln1651">							      PHY_REG(776, 20),</a>
<a name="ln1652">							      &amp;data);</a>
<a name="ln1653">				if (ret_val) {</a>
<a name="ln1654">					hw-&gt;phy.ops.release(hw);</a>
<a name="ln1655">					return ret_val;</a>
<a name="ln1656">				}</a>
<a name="ln1657"> </a>
<a name="ln1658">				ptr_gap = (data &amp; (0x3FF &lt;&lt; 2)) &gt;&gt; 2;</a>
<a name="ln1659">				if (ptr_gap &lt; 0x18) {</a>
<a name="ln1660">					data &amp;= ~(0x3FF &lt;&lt; 2);</a>
<a name="ln1661">					data |= (0x18 &lt;&lt; 2);</a>
<a name="ln1662">					ret_val =</a>
<a name="ln1663">						hw-&gt;phy.ops.write_reg_locked(hw,</a>
<a name="ln1664">							PHY_REG(776, 20), data);</a>
<a name="ln1665">				}</a>
<a name="ln1666">				hw-&gt;phy.ops.release(hw);</a>
<a name="ln1667">				if (ret_val)</a>
<a name="ln1668">					return ret_val;</a>
<a name="ln1669">			} else {</a>
<a name="ln1670">				ret_val = hw-&gt;phy.ops.acquire(hw);</a>
<a name="ln1671">				if (ret_val)</a>
<a name="ln1672">					return ret_val;</a>
<a name="ln1673"> </a>
<a name="ln1674">				ret_val = hw-&gt;phy.ops.write_reg_locked(hw,</a>
<a name="ln1675">							     PHY_REG(776, 20),</a>
<a name="ln1676">							     0xC023);</a>
<a name="ln1677">				hw-&gt;phy.ops.release(hw);</a>
<a name="ln1678">				if (ret_val)</a>
<a name="ln1679">					return ret_val;</a>
<a name="ln1680"> </a>
<a name="ln1681">			}</a>
<a name="ln1682">		}</a>
<a name="ln1683">	}</a>
<a name="ln1684"> </a>
<a name="ln1685">	/* I217 Packet Loss issue:</a>
<a name="ln1686">	 * ensure that FEXTNVM4 Beacon Duration is set correctly</a>
<a name="ln1687">	 * on power up.</a>
<a name="ln1688">	 * Set the Beacon Duration for I217 to 8 usec</a>
<a name="ln1689">	 */</a>
<a name="ln1690">	if (hw-&gt;mac.type &gt;= e1000_pch_lpt) {</a>
<a name="ln1691">		u32 mac_reg;</a>
<a name="ln1692"> </a>
<a name="ln1693">		mac_reg = E1000_READ_REG(hw, E1000_FEXTNVM4);</a>
<a name="ln1694">		mac_reg &amp;= ~E1000_FEXTNVM4_BEACON_DURATION_MASK;</a>
<a name="ln1695">		mac_reg |= E1000_FEXTNVM4_BEACON_DURATION_8USEC;</a>
<a name="ln1696">		E1000_WRITE_REG(hw, E1000_FEXTNVM4, mac_reg);</a>
<a name="ln1697">	}</a>
<a name="ln1698"> </a>
<a name="ln1699">	/* Work-around I218 hang issue */</a>
<a name="ln1700">	if ((hw-&gt;device_id == E1000_DEV_ID_PCH_LPTLP_I218_LM) ||</a>
<a name="ln1701">	    (hw-&gt;device_id == E1000_DEV_ID_PCH_LPTLP_I218_V) ||</a>
<a name="ln1702">	    (hw-&gt;device_id == E1000_DEV_ID_PCH_I218_LM3) ||</a>
<a name="ln1703">	    (hw-&gt;device_id == E1000_DEV_ID_PCH_I218_V3)) {</a>
<a name="ln1704">		ret_val = e1000_k1_workaround_lpt_lp(hw, link);</a>
<a name="ln1705">		if (ret_val)</a>
<a name="ln1706">			return ret_val;</a>
<a name="ln1707">	}</a>
<a name="ln1708">	if (hw-&gt;mac.type &gt;= e1000_pch_lpt) {</a>
<a name="ln1709">		/* Set platform power management values for</a>
<a name="ln1710">		 * Latency Tolerance Reporting (LTR)</a>
<a name="ln1711">		 * Optimized Buffer Flush/Fill (OBFF)</a>
<a name="ln1712">		 */</a>
<a name="ln1713">		ret_val = e1000_platform_pm_pch_lpt(hw, link);</a>
<a name="ln1714">		if (ret_val)</a>
<a name="ln1715">			return ret_val;</a>
<a name="ln1716">	}</a>
<a name="ln1717"> </a>
<a name="ln1718">	/* Clear link partner's EEE ability */</a>
<a name="ln1719">	hw-&gt;dev_spec.ich8lan.eee_lp_ability = 0;</a>
<a name="ln1720"> </a>
<a name="ln1721">	if (hw-&gt;mac.type &gt;= e1000_pch_lpt) {</a>
<a name="ln1722">		u32 fextnvm6 = E1000_READ_REG(hw, E1000_FEXTNVM6);</a>
<a name="ln1723"> </a>
<a name="ln1724">		if (hw-&gt;mac.type == e1000_pch_spt) {</a>
<a name="ln1725">			/* FEXTNVM6 K1-off workaround - for SPT only */</a>
<a name="ln1726">			u32 pcieanacfg = E1000_READ_REG(hw, E1000_PCIEANACFG);</a>
<a name="ln1727"> </a>
<a name="ln1728">			if (pcieanacfg &amp; E1000_FEXTNVM6_K1_OFF_ENABLE)</a>
<a name="ln1729">				fextnvm6 |= E1000_FEXTNVM6_K1_OFF_ENABLE;</a>
<a name="ln1730">			else</a>
<a name="ln1731">				fextnvm6 &amp;= ~E1000_FEXTNVM6_K1_OFF_ENABLE;</a>
<a name="ln1732">		}</a>
<a name="ln1733"> </a>
<a name="ln1734">		if (hw-&gt;dev_spec.ich8lan.disable_k1_off == TRUE)</a>
<a name="ln1735">			fextnvm6 &amp;= ~E1000_FEXTNVM6_K1_OFF_ENABLE;</a>
<a name="ln1736"> </a>
<a name="ln1737">		E1000_WRITE_REG(hw, E1000_FEXTNVM6, fextnvm6);</a>
<a name="ln1738">	}</a>
<a name="ln1739"> </a>
<a name="ln1740">	if (!link)</a>
<a name="ln1741">		return E1000_SUCCESS; /* No link detected */</a>
<a name="ln1742"> </a>
<a name="ln1743">	mac-&gt;get_link_status = FALSE;</a>
<a name="ln1744"> </a>
<a name="ln1745">	switch (hw-&gt;mac.type) {</a>
<a name="ln1746">	case e1000_pch2lan:</a>
<a name="ln1747">		ret_val = e1000_k1_workaround_lv(hw);</a>
<a name="ln1748">		if (ret_val)</a>
<a name="ln1749">			return ret_val;</a>
<a name="ln1750">		/* fall-thru */</a>
<a name="ln1751">	case e1000_pchlan:</a>
<a name="ln1752">		if (hw-&gt;phy.type == e1000_phy_82578) {</a>
<a name="ln1753">			ret_val = e1000_link_stall_workaround_hv(hw);</a>
<a name="ln1754">			if (ret_val)</a>
<a name="ln1755">				return ret_val;</a>
<a name="ln1756">		}</a>
<a name="ln1757"> </a>
<a name="ln1758">		/* Workaround for PCHx parts in half-duplex:</a>
<a name="ln1759">		 * Set the number of preambles removed from the packet</a>
<a name="ln1760">		 * when it is passed from the PHY to the MAC to prevent</a>
<a name="ln1761">		 * the MAC from misinterpreting the packet type.</a>
<a name="ln1762">		 */</a>
<a name="ln1763">		hw-&gt;phy.ops.read_reg(hw, HV_KMRN_FIFO_CTRLSTA, &amp;phy_reg);</a>
<a name="ln1764">		phy_reg &amp;= ~HV_KMRN_FIFO_CTRLSTA_PREAMBLE_MASK;</a>
<a name="ln1765"> </a>
<a name="ln1766">		if ((E1000_READ_REG(hw, E1000_STATUS) &amp; E1000_STATUS_FD) !=</a>
<a name="ln1767">		    E1000_STATUS_FD)</a>
<a name="ln1768">			phy_reg |= (1 &lt;&lt; HV_KMRN_FIFO_CTRLSTA_PREAMBLE_SHIFT);</a>
<a name="ln1769"> </a>
<a name="ln1770">		hw-&gt;phy.ops.write_reg(hw, HV_KMRN_FIFO_CTRLSTA, phy_reg);</a>
<a name="ln1771">		break;</a>
<a name="ln1772">	default:</a>
<a name="ln1773">		break;</a>
<a name="ln1774">	}</a>
<a name="ln1775"> </a>
<a name="ln1776">	/* Check if there was DownShift, must be checked</a>
<a name="ln1777">	 * immediately after link-up</a>
<a name="ln1778">	 */</a>
<a name="ln1779">	e1000_check_downshift_generic(hw);</a>
<a name="ln1780"> </a>
<a name="ln1781">	/* Enable/Disable EEE after link up */</a>
<a name="ln1782">	if (hw-&gt;phy.type &gt; e1000_phy_82579) {</a>
<a name="ln1783">		ret_val = e1000_set_eee_pchlan(hw);</a>
<a name="ln1784">		if (ret_val)</a>
<a name="ln1785">			return ret_val;</a>
<a name="ln1786">	}</a>
<a name="ln1787"> </a>
<a name="ln1788">	/* If we are forcing speed/duplex, then we simply return since</a>
<a name="ln1789">	 * we have already determined whether we have link or not.</a>
<a name="ln1790">	 */</a>
<a name="ln1791">	if (!mac-&gt;autoneg)</a>
<a name="ln1792">		return -E1000_ERR_CONFIG;</a>
<a name="ln1793"> </a>
<a name="ln1794">	/* Auto-Neg is enabled.  Auto Speed Detection takes care</a>
<a name="ln1795">	 * of MAC speed/duplex configuration.  So we only need to</a>
<a name="ln1796">	 * configure Collision Distance in the MAC.</a>
<a name="ln1797">	 */</a>
<a name="ln1798">	mac-&gt;ops.config_collision_dist(hw);</a>
<a name="ln1799"> </a>
<a name="ln1800">	/* Configure Flow Control now that Auto-Neg has completed.</a>
<a name="ln1801">	 * First, we need to restore the desired flow control</a>
<a name="ln1802">	 * settings because we may have had to re-autoneg with a</a>
<a name="ln1803">	 * different link partner.</a>
<a name="ln1804">	 */</a>
<a name="ln1805">	ret_val = e1000_config_fc_after_link_up_generic(hw);</a>
<a name="ln1806">	if (ret_val)</a>
<a name="ln1807">		DEBUGOUT(&quot;Error configuring flow control\n&quot;);</a>
<a name="ln1808"> </a>
<a name="ln1809">	return ret_val;</a>
<a name="ln1810">}</a>
<a name="ln1811"> </a>
<a name="ln1812">/**</a>
<a name="ln1813"> *  e1000_init_function_pointers_ich8lan - Initialize ICH8 function pointers</a>
<a name="ln1814"> *  @hw: pointer to the HW structure</a>
<a name="ln1815"> *</a>
<a name="ln1816"> *  Initialize family-specific function pointers for PHY, MAC, and NVM.</a>
<a name="ln1817"> **/</a>
<a name="ln1818">void e1000_init_function_pointers_ich8lan(struct e1000_hw *hw)</a>
<a name="ln1819">{</a>
<a name="ln1820">	DEBUGFUNC(&quot;e1000_init_function_pointers_ich8lan&quot;);</a>
<a name="ln1821"> </a>
<a name="ln1822">	hw-&gt;mac.ops.init_params = e1000_init_mac_params_ich8lan;</a>
<a name="ln1823">	hw-&gt;nvm.ops.init_params = e1000_init_nvm_params_ich8lan;</a>
<a name="ln1824">	switch (hw-&gt;mac.type) {</a>
<a name="ln1825">	case e1000_ich8lan:</a>
<a name="ln1826">	case e1000_ich9lan:</a>
<a name="ln1827">	case e1000_ich10lan:</a>
<a name="ln1828">		hw-&gt;phy.ops.init_params = e1000_init_phy_params_ich8lan;</a>
<a name="ln1829">		break;</a>
<a name="ln1830">	case e1000_pchlan:</a>
<a name="ln1831">	case e1000_pch2lan:</a>
<a name="ln1832">	case e1000_pch_lpt:</a>
<a name="ln1833">	case e1000_pch_spt:</a>
<a name="ln1834">	case e1000_pch_cnp:</a>
<a name="ln1835">		hw-&gt;phy.ops.init_params = e1000_init_phy_params_pchlan;</a>
<a name="ln1836">		break;</a>
<a name="ln1837">	default:</a>
<a name="ln1838">		break;</a>
<a name="ln1839">	}</a>
<a name="ln1840">}</a>
<a name="ln1841"> </a>
<a name="ln1842">/**</a>
<a name="ln1843"> *  e1000_acquire_nvm_ich8lan - Acquire NVM mutex</a>
<a name="ln1844"> *  @hw: pointer to the HW structure</a>
<a name="ln1845"> *</a>
<a name="ln1846"> *  Acquires the mutex for performing NVM operations.</a>
<a name="ln1847"> **/</a>
<a name="ln1848">static s32 e1000_acquire_nvm_ich8lan(struct e1000_hw *hw)</a>
<a name="ln1849">{</a>
<a name="ln1850">	DEBUGFUNC(&quot;e1000_acquire_nvm_ich8lan&quot;);</a>
<a name="ln1851"> </a>
<a name="ln1852">	ASSERT_CTX_LOCK_HELD(hw);</a>
<a name="ln1853"> </a>
<a name="ln1854">	return E1000_SUCCESS;</a>
<a name="ln1855">}</a>
<a name="ln1856"> </a>
<a name="ln1857">/**</a>
<a name="ln1858"> *  e1000_release_nvm_ich8lan - Release NVM mutex</a>
<a name="ln1859"> *  @hw: pointer to the HW structure</a>
<a name="ln1860"> *</a>
<a name="ln1861"> *  Releases the mutex used while performing NVM operations.</a>
<a name="ln1862"> **/</a>
<a name="ln1863">static void e1000_release_nvm_ich8lan(struct e1000_hw *hw)</a>
<a name="ln1864">{</a>
<a name="ln1865">	DEBUGFUNC(&quot;e1000_release_nvm_ich8lan&quot;);</a>
<a name="ln1866"> </a>
<a name="ln1867">	ASSERT_CTX_LOCK_HELD(hw);</a>
<a name="ln1868">}</a>
<a name="ln1869"> </a>
<a name="ln1870">/**</a>
<a name="ln1871"> *  e1000_acquire_swflag_ich8lan - Acquire software control flag</a>
<a name="ln1872"> *  @hw: pointer to the HW structure</a>
<a name="ln1873"> *</a>
<a name="ln1874"> *  Acquires the software control flag for performing PHY and select</a>
<a name="ln1875"> *  MAC CSR accesses.</a>
<a name="ln1876"> **/</a>
<a name="ln1877">static s32 e1000_acquire_swflag_ich8lan(struct e1000_hw *hw)</a>
<a name="ln1878">{</a>
<a name="ln1879">	u32 extcnf_ctrl, timeout = PHY_CFG_TIMEOUT;</a>
<a name="ln1880">	s32 ret_val = E1000_SUCCESS;</a>
<a name="ln1881"> </a>
<a name="ln1882">	DEBUGFUNC(&quot;e1000_acquire_swflag_ich8lan&quot;);</a>
<a name="ln1883"> </a>
<a name="ln1884">	ASSERT_CTX_LOCK_HELD(hw);</a>
<a name="ln1885"> </a>
<a name="ln1886">	while (timeout) {</a>
<a name="ln1887">		extcnf_ctrl = E1000_READ_REG(hw, E1000_EXTCNF_CTRL);</a>
<a name="ln1888">		if (!(extcnf_ctrl &amp; E1000_EXTCNF_CTRL_SWFLAG))</a>
<a name="ln1889">			break;</a>
<a name="ln1890"> </a>
<a name="ln1891">		msec_delay_irq(1);</a>
<a name="ln1892">		timeout--;</a>
<a name="ln1893">	}</a>
<a name="ln1894"> </a>
<a name="ln1895">	if (!timeout) {</a>
<a name="ln1896">		DEBUGOUT(&quot;SW has already locked the resource.\n&quot;);</a>
<a name="ln1897">		ret_val = -E1000_ERR_CONFIG;</a>
<a name="ln1898">		goto out;</a>
<a name="ln1899">	}</a>
<a name="ln1900"> </a>
<a name="ln1901">	timeout = SW_FLAG_TIMEOUT;</a>
<a name="ln1902"> </a>
<a name="ln1903">	extcnf_ctrl |= E1000_EXTCNF_CTRL_SWFLAG;</a>
<a name="ln1904">	E1000_WRITE_REG(hw, E1000_EXTCNF_CTRL, extcnf_ctrl);</a>
<a name="ln1905"> </a>
<a name="ln1906">	while (timeout) {</a>
<a name="ln1907">		extcnf_ctrl = E1000_READ_REG(hw, E1000_EXTCNF_CTRL);</a>
<a name="ln1908">		if (extcnf_ctrl &amp; E1000_EXTCNF_CTRL_SWFLAG)</a>
<a name="ln1909">			break;</a>
<a name="ln1910"> </a>
<a name="ln1911">		msec_delay_irq(1);</a>
<a name="ln1912">		timeout--;</a>
<a name="ln1913">	}</a>
<a name="ln1914"> </a>
<a name="ln1915">	if (!timeout) {</a>
<a name="ln1916">		DEBUGOUT2(&quot;Failed to acquire the semaphore, FW or HW has it: FWSM=0x%8.8x EXTCNF_CTRL=0x%8.8x)\n&quot;,</a>
<a name="ln1917">			  E1000_READ_REG(hw, E1000_FWSM), extcnf_ctrl);</a>
<a name="ln1918">		extcnf_ctrl &amp;= ~E1000_EXTCNF_CTRL_SWFLAG;</a>
<a name="ln1919">		E1000_WRITE_REG(hw, E1000_EXTCNF_CTRL, extcnf_ctrl);</a>
<a name="ln1920">		ret_val = -E1000_ERR_CONFIG;</a>
<a name="ln1921">		goto out;</a>
<a name="ln1922">	}</a>
<a name="ln1923"> </a>
<a name="ln1924">out:</a>
<a name="ln1925">	return ret_val;</a>
<a name="ln1926">}</a>
<a name="ln1927"> </a>
<a name="ln1928">/**</a>
<a name="ln1929"> *  e1000_release_swflag_ich8lan - Release software control flag</a>
<a name="ln1930"> *  @hw: pointer to the HW structure</a>
<a name="ln1931"> *</a>
<a name="ln1932"> *  Releases the software control flag for performing PHY and select</a>
<a name="ln1933"> *  MAC CSR accesses.</a>
<a name="ln1934"> **/</a>
<a name="ln1935">static void e1000_release_swflag_ich8lan(struct e1000_hw *hw)</a>
<a name="ln1936">{</a>
<a name="ln1937">	u32 extcnf_ctrl;</a>
<a name="ln1938"> </a>
<a name="ln1939">	DEBUGFUNC(&quot;e1000_release_swflag_ich8lan&quot;);</a>
<a name="ln1940"> </a>
<a name="ln1941">	extcnf_ctrl = E1000_READ_REG(hw, E1000_EXTCNF_CTRL);</a>
<a name="ln1942"> </a>
<a name="ln1943">	if (extcnf_ctrl &amp; E1000_EXTCNF_CTRL_SWFLAG) {</a>
<a name="ln1944">		extcnf_ctrl &amp;= ~E1000_EXTCNF_CTRL_SWFLAG;</a>
<a name="ln1945">		E1000_WRITE_REG(hw, E1000_EXTCNF_CTRL, extcnf_ctrl);</a>
<a name="ln1946">	} else {</a>
<a name="ln1947">		DEBUGOUT(&quot;Semaphore unexpectedly released by sw/fw/hw\n&quot;);</a>
<a name="ln1948">	}</a>
<a name="ln1949">}</a>
<a name="ln1950"> </a>
<a name="ln1951">/**</a>
<a name="ln1952"> *  e1000_check_mng_mode_ich8lan - Checks management mode</a>
<a name="ln1953"> *  @hw: pointer to the HW structure</a>
<a name="ln1954"> *</a>
<a name="ln1955"> *  This checks if the adapter has any manageability enabled.</a>
<a name="ln1956"> *  This is a function pointer entry point only called by read/write</a>
<a name="ln1957"> *  routines for the PHY and NVM parts.</a>
<a name="ln1958"> **/</a>
<a name="ln1959">static bool e1000_check_mng_mode_ich8lan(struct e1000_hw *hw)</a>
<a name="ln1960">{</a>
<a name="ln1961">	u32 fwsm;</a>
<a name="ln1962"> </a>
<a name="ln1963">	DEBUGFUNC(&quot;e1000_check_mng_mode_ich8lan&quot;);</a>
<a name="ln1964"> </a>
<a name="ln1965">	fwsm = E1000_READ_REG(hw, E1000_FWSM);</a>
<a name="ln1966"> </a>
<a name="ln1967">	return (fwsm &amp; E1000_ICH_FWSM_FW_VALID) &amp;&amp;</a>
<a name="ln1968">	       ((fwsm &amp; E1000_FWSM_MODE_MASK) ==</a>
<a name="ln1969">		(E1000_ICH_MNG_IAMT_MODE &lt;&lt; E1000_FWSM_MODE_SHIFT));</a>
<a name="ln1970">}</a>
<a name="ln1971"> </a>
<a name="ln1972">/**</a>
<a name="ln1973"> *  e1000_check_mng_mode_pchlan - Checks management mode</a>
<a name="ln1974"> *  @hw: pointer to the HW structure</a>
<a name="ln1975"> *</a>
<a name="ln1976"> *  This checks if the adapter has iAMT enabled.</a>
<a name="ln1977"> *  This is a function pointer entry point only called by read/write</a>
<a name="ln1978"> *  routines for the PHY and NVM parts.</a>
<a name="ln1979"> **/</a>
<a name="ln1980">static bool e1000_check_mng_mode_pchlan(struct e1000_hw *hw)</a>
<a name="ln1981">{</a>
<a name="ln1982">	u32 fwsm;</a>
<a name="ln1983"> </a>
<a name="ln1984">	DEBUGFUNC(&quot;e1000_check_mng_mode_pchlan&quot;);</a>
<a name="ln1985"> </a>
<a name="ln1986">	fwsm = E1000_READ_REG(hw, E1000_FWSM);</a>
<a name="ln1987"> </a>
<a name="ln1988">	return (fwsm &amp; E1000_ICH_FWSM_FW_VALID) &amp;&amp;</a>
<a name="ln1989">	       (fwsm &amp; (E1000_ICH_MNG_IAMT_MODE &lt;&lt; E1000_FWSM_MODE_SHIFT));</a>
<a name="ln1990">}</a>
<a name="ln1991"> </a>
<a name="ln1992">/**</a>
<a name="ln1993"> *  e1000_rar_set_pch2lan - Set receive address register</a>
<a name="ln1994"> *  @hw: pointer to the HW structure</a>
<a name="ln1995"> *  @addr: pointer to the receive address</a>
<a name="ln1996"> *  @index: receive address array register</a>
<a name="ln1997"> *</a>
<a name="ln1998"> *  Sets the receive address array register at index to the address passed</a>
<a name="ln1999"> *  in by addr.  For 82579, RAR[0] is the base address register that is to</a>
<a name="ln2000"> *  contain the MAC address but RAR[1-6] are reserved for manageability (ME).</a>
<a name="ln2001"> *  Use SHRA[0-3] in place of those reserved for ME.</a>
<a name="ln2002"> **/</a>
<a name="ln2003">static int e1000_rar_set_pch2lan(struct e1000_hw *hw, u8 *addr, u32 index)</a>
<a name="ln2004">{</a>
<a name="ln2005">	u32 rar_low, rar_high;</a>
<a name="ln2006"> </a>
<a name="ln2007">	DEBUGFUNC(&quot;e1000_rar_set_pch2lan&quot;);</a>
<a name="ln2008"> </a>
<a name="ln2009">	/* HW expects these in little endian so we reverse the byte order</a>
<a name="ln2010">	 * from network order (big endian) to little endian</a>
<a name="ln2011">	 */</a>
<a name="ln2012">	rar_low = ((u32) addr[0] |</a>
<a name="ln2013">		   ((u32) addr[1] &lt;&lt; 8) |</a>
<a name="ln2014">		   ((u32) addr[2] &lt;&lt; 16) | ((u32) addr[3] &lt;&lt; 24));</a>
<a name="ln2015"> </a>
<a name="ln2016">	rar_high = ((u32) addr[4] | ((u32) addr[5] &lt;&lt; 8));</a>
<a name="ln2017"> </a>
<a name="ln2018">	/* If MAC address zero, no need to set the AV bit */</a>
<a name="ln2019">	if (rar_low || rar_high)</a>
<a name="ln2020">		rar_high |= E1000_RAH_AV;</a>
<a name="ln2021"> </a>
<a name="ln2022">	if (index == 0) {</a>
<a name="ln2023">		E1000_WRITE_REG(hw, E1000_RAL(index), rar_low);</a>
<a name="ln2024">		E1000_WRITE_FLUSH(hw);</a>
<a name="ln2025">		E1000_WRITE_REG(hw, E1000_RAH(index), rar_high);</a>
<a name="ln2026">		E1000_WRITE_FLUSH(hw);</a>
<a name="ln2027">		return E1000_SUCCESS;</a>
<a name="ln2028">	}</a>
<a name="ln2029"> </a>
<a name="ln2030">	/* RAR[1-6] are owned by manageability.  Skip those and program the</a>
<a name="ln2031">	 * next address into the SHRA register array.</a>
<a name="ln2032">	 */</a>
<a name="ln2033">	if (index &lt; (u32) (hw-&gt;mac.rar_entry_count)) {</a>
<a name="ln2034">		s32 ret_val;</a>
<a name="ln2035"> </a>
<a name="ln2036">		ret_val = e1000_acquire_swflag_ich8lan(hw);</a>
<a name="ln2037">		if (ret_val)</a>
<a name="ln2038">			goto out;</a>
<a name="ln2039"> </a>
<a name="ln2040">		E1000_WRITE_REG(hw, E1000_SHRAL(index - 1), rar_low);</a>
<a name="ln2041">		E1000_WRITE_FLUSH(hw);</a>
<a name="ln2042">		E1000_WRITE_REG(hw, E1000_SHRAH(index - 1), rar_high);</a>
<a name="ln2043">		E1000_WRITE_FLUSH(hw);</a>
<a name="ln2044"> </a>
<a name="ln2045">		e1000_release_swflag_ich8lan(hw);</a>
<a name="ln2046"> </a>
<a name="ln2047">		/* verify the register updates */</a>
<a name="ln2048">		if ((E1000_READ_REG(hw, E1000_SHRAL(index - 1)) == rar_low) &amp;&amp;</a>
<a name="ln2049">		    (E1000_READ_REG(hw, E1000_SHRAH(index - 1)) == rar_high))</a>
<a name="ln2050">			return E1000_SUCCESS;</a>
<a name="ln2051"> </a>
<a name="ln2052">		DEBUGOUT2(&quot;SHRA[%d] might be locked by ME - FWSM=0x%8.8x\n&quot;,</a>
<a name="ln2053">			 (index - 1), E1000_READ_REG(hw, E1000_FWSM));</a>
<a name="ln2054">	}</a>
<a name="ln2055"> </a>
<a name="ln2056">out:</a>
<a name="ln2057">	DEBUGOUT1(&quot;Failed to write receive address at index %d\n&quot;, index);</a>
<a name="ln2058">	return -E1000_ERR_CONFIG;</a>
<a name="ln2059">}</a>
<a name="ln2060"> </a>
<a name="ln2061">/**</a>
<a name="ln2062"> *  e1000_rar_set_pch_lpt - Set receive address registers</a>
<a name="ln2063"> *  @hw: pointer to the HW structure</a>
<a name="ln2064"> *  @addr: pointer to the receive address</a>
<a name="ln2065"> *  @index: receive address array register</a>
<a name="ln2066"> *</a>
<a name="ln2067"> *  Sets the receive address register array at index to the address passed</a>
<a name="ln2068"> *  in by addr. For LPT, RAR[0] is the base address register that is to</a>
<a name="ln2069"> *  contain the MAC address. SHRA[0-10] are the shared receive address</a>
<a name="ln2070"> *  registers that are shared between the Host and manageability engine (ME).</a>
<a name="ln2071"> **/</a>
<a name="ln2072">static int e1000_rar_set_pch_lpt(struct e1000_hw *hw, u8 *addr, u32 index)</a>
<a name="ln2073">{</a>
<a name="ln2074">	u32 rar_low, rar_high;</a>
<a name="ln2075">	u32 wlock_mac;</a>
<a name="ln2076"> </a>
<a name="ln2077">	DEBUGFUNC(&quot;e1000_rar_set_pch_lpt&quot;);</a>
<a name="ln2078"> </a>
<a name="ln2079">	/* HW expects these in little endian so we reverse the byte order</a>
<a name="ln2080">	 * from network order (big endian) to little endian</a>
<a name="ln2081">	 */</a>
<a name="ln2082">	rar_low = ((u32) addr[0] | ((u32) addr[1] &lt;&lt; 8) |</a>
<a name="ln2083">		   ((u32) addr[2] &lt;&lt; 16) | ((u32) addr[3] &lt;&lt; 24));</a>
<a name="ln2084"> </a>
<a name="ln2085">	rar_high = ((u32) addr[4] | ((u32) addr[5] &lt;&lt; 8));</a>
<a name="ln2086"> </a>
<a name="ln2087">	/* If MAC address zero, no need to set the AV bit */</a>
<a name="ln2088">	if (rar_low || rar_high)</a>
<a name="ln2089">		rar_high |= E1000_RAH_AV;</a>
<a name="ln2090"> </a>
<a name="ln2091">	if (index == 0) {</a>
<a name="ln2092">		E1000_WRITE_REG(hw, E1000_RAL(index), rar_low);</a>
<a name="ln2093">		E1000_WRITE_FLUSH(hw);</a>
<a name="ln2094">		E1000_WRITE_REG(hw, E1000_RAH(index), rar_high);</a>
<a name="ln2095">		E1000_WRITE_FLUSH(hw);</a>
<a name="ln2096">		return E1000_SUCCESS;</a>
<a name="ln2097">	}</a>
<a name="ln2098"> </a>
<a name="ln2099">	/* The manageability engine (ME) can lock certain SHRAR registers that</a>
<a name="ln2100">	 * it is using - those registers are unavailable for use.</a>
<a name="ln2101">	 */</a>
<a name="ln2102">	if (index &lt; hw-&gt;mac.rar_entry_count) {</a>
<a name="ln2103">		wlock_mac = E1000_READ_REG(hw, E1000_FWSM) &amp;</a>
<a name="ln2104">			    E1000_FWSM_WLOCK_MAC_MASK;</a>
<a name="ln2105">		wlock_mac &gt;&gt;= E1000_FWSM_WLOCK_MAC_SHIFT;</a>
<a name="ln2106"> </a>
<a name="ln2107">		/* Check if all SHRAR registers are locked */</a>
<a name="ln2108">		if (wlock_mac == 1)</a>
<a name="ln2109">			goto out;</a>
<a name="ln2110"> </a>
<a name="ln2111">		if ((wlock_mac == 0) || (index &lt;= wlock_mac)) {</a>
<a name="ln2112">			s32 ret_val;</a>
<a name="ln2113"> </a>
<a name="ln2114">			ret_val = e1000_acquire_swflag_ich8lan(hw);</a>
<a name="ln2115"> </a>
<a name="ln2116">			if (ret_val)</a>
<a name="ln2117">				goto out;</a>
<a name="ln2118"> </a>
<a name="ln2119">			E1000_WRITE_REG(hw, E1000_SHRAL_PCH_LPT(index - 1),</a>
<a name="ln2120">					rar_low);</a>
<a name="ln2121">			E1000_WRITE_FLUSH(hw);</a>
<a name="ln2122">			E1000_WRITE_REG(hw, E1000_SHRAH_PCH_LPT(index - 1),</a>
<a name="ln2123">					rar_high);</a>
<a name="ln2124">			E1000_WRITE_FLUSH(hw);</a>
<a name="ln2125"> </a>
<a name="ln2126">			e1000_release_swflag_ich8lan(hw);</a>
<a name="ln2127"> </a>
<a name="ln2128">			/* verify the register updates */</a>
<a name="ln2129">			if ((E1000_READ_REG(hw, E1000_SHRAL_PCH_LPT(index - 1)) == rar_low) &amp;&amp;</a>
<a name="ln2130">			    (E1000_READ_REG(hw, E1000_SHRAH_PCH_LPT(index - 1)) == rar_high))</a>
<a name="ln2131">				return E1000_SUCCESS;</a>
<a name="ln2132">		}</a>
<a name="ln2133">	}</a>
<a name="ln2134"> </a>
<a name="ln2135">out:</a>
<a name="ln2136">	DEBUGOUT1(&quot;Failed to write receive address at index %d\n&quot;, index);</a>
<a name="ln2137">	return -E1000_ERR_CONFIG;</a>
<a name="ln2138">}</a>
<a name="ln2139"> </a>
<a name="ln2140">/**</a>
<a name="ln2141"> *  e1000_update_mc_addr_list_pch2lan - Update Multicast addresses</a>
<a name="ln2142"> *  @hw: pointer to the HW structure</a>
<a name="ln2143"> *  @mc_addr_list: array of multicast addresses to program</a>
<a name="ln2144"> *  @mc_addr_count: number of multicast addresses to program</a>
<a name="ln2145"> *</a>
<a name="ln2146"> *  Updates entire Multicast Table Array of the PCH2 MAC and PHY.</a>
<a name="ln2147"> *  The caller must have a packed mc_addr_list of multicast addresses.</a>
<a name="ln2148"> **/</a>
<a name="ln2149">static void e1000_update_mc_addr_list_pch2lan(struct e1000_hw *hw,</a>
<a name="ln2150">					      u8 *mc_addr_list,</a>
<a name="ln2151">					      u32 mc_addr_count)</a>
<a name="ln2152">{</a>
<a name="ln2153">	u16 phy_reg = 0;</a>
<a name="ln2154">	int i;</a>
<a name="ln2155">	s32 ret_val;</a>
<a name="ln2156"> </a>
<a name="ln2157">	DEBUGFUNC(&quot;e1000_update_mc_addr_list_pch2lan&quot;);</a>
<a name="ln2158"> </a>
<a name="ln2159">	e1000_update_mc_addr_list_generic(hw, mc_addr_list, mc_addr_count);</a>
<a name="ln2160"> </a>
<a name="ln2161">	ret_val = hw-&gt;phy.ops.acquire(hw);</a>
<a name="ln2162">	if (ret_val)</a>
<a name="ln2163">		return;</a>
<a name="ln2164"> </a>
<a name="ln2165">	ret_val = e1000_enable_phy_wakeup_reg_access_bm(hw, &amp;phy_reg);</a>
<a name="ln2166">	if (ret_val)</a>
<a name="ln2167">		goto release;</a>
<a name="ln2168"> </a>
<a name="ln2169">	for (i = 0; i &lt; hw-&gt;mac.mta_reg_count; i++) {</a>
<a name="ln2170">		hw-&gt;phy.ops.write_reg_page(hw, BM_MTA(i),</a>
<a name="ln2171">					   (u16)(hw-&gt;mac.mta_shadow[i] &amp;</a>
<a name="ln2172">						 0xFFFF));</a>
<a name="ln2173">		hw-&gt;phy.ops.write_reg_page(hw, (BM_MTA(i) + 1),</a>
<a name="ln2174">					   (u16)((hw-&gt;mac.mta_shadow[i] &gt;&gt; 16) &amp;</a>
<a name="ln2175">						 0xFFFF));</a>
<a name="ln2176">	}</a>
<a name="ln2177"> </a>
<a name="ln2178">	e1000_disable_phy_wakeup_reg_access_bm(hw, &amp;phy_reg);</a>
<a name="ln2179"> </a>
<a name="ln2180">release:</a>
<a name="ln2181">	hw-&gt;phy.ops.release(hw);</a>
<a name="ln2182">}</a>
<a name="ln2183"> </a>
<a name="ln2184">/**</a>
<a name="ln2185"> *  e1000_check_reset_block_ich8lan - Check if PHY reset is blocked</a>
<a name="ln2186"> *  @hw: pointer to the HW structure</a>
<a name="ln2187"> *</a>
<a name="ln2188"> *  Checks if firmware is blocking the reset of the PHY.</a>
<a name="ln2189"> *  This is a function pointer entry point only called by</a>
<a name="ln2190"> *  reset routines.</a>
<a name="ln2191"> **/</a>
<a name="ln2192">static s32 e1000_check_reset_block_ich8lan(struct e1000_hw *hw)</a>
<a name="ln2193">{</a>
<a name="ln2194">	u32 fwsm;</a>
<a name="ln2195">	bool blocked = FALSE;</a>
<a name="ln2196">	int i = 0;</a>
<a name="ln2197"> </a>
<a name="ln2198">	DEBUGFUNC(&quot;e1000_check_reset_block_ich8lan&quot;);</a>
<a name="ln2199"> </a>
<a name="ln2200">	do {</a>
<a name="ln2201">		fwsm = E1000_READ_REG(hw, E1000_FWSM);</a>
<a name="ln2202">		if (!(fwsm &amp; E1000_ICH_FWSM_RSPCIPHY)) {</a>
<a name="ln2203">			blocked = TRUE;</a>
<a name="ln2204">			msec_delay(10);</a>
<a name="ln2205">			continue;</a>
<a name="ln2206">		}</a>
<a name="ln2207">		blocked = FALSE;</a>
<a name="ln2208">	} while (blocked &amp;&amp; (i++ &lt; 30));</a>
<a name="ln2209">	return blocked ? E1000_BLK_PHY_RESET : E1000_SUCCESS;</a>
<a name="ln2210">}</a>
<a name="ln2211"> </a>
<a name="ln2212">/**</a>
<a name="ln2213"> *  e1000_write_smbus_addr - Write SMBus address to PHY needed during Sx states</a>
<a name="ln2214"> *  @hw: pointer to the HW structure</a>
<a name="ln2215"> *</a>
<a name="ln2216"> *  Assumes semaphore already acquired.</a>
<a name="ln2217"> *</a>
<a name="ln2218"> **/</a>
<a name="ln2219">static s32 e1000_write_smbus_addr(struct e1000_hw *hw)</a>
<a name="ln2220">{</a>
<a name="ln2221">	u16 phy_data;</a>
<a name="ln2222">	u32 strap = E1000_READ_REG(hw, E1000_STRAP);</a>
<a name="ln2223">	u32 freq = (strap &amp; E1000_STRAP_SMT_FREQ_MASK) &gt;&gt;</a>
<a name="ln2224">		E1000_STRAP_SMT_FREQ_SHIFT;</a>
<a name="ln2225">	s32 ret_val;</a>
<a name="ln2226"> </a>
<a name="ln2227">	strap &amp;= E1000_STRAP_SMBUS_ADDRESS_MASK;</a>
<a name="ln2228"> </a>
<a name="ln2229">	ret_val = e1000_read_phy_reg_hv_locked(hw, HV_SMB_ADDR, &amp;phy_data);</a>
<a name="ln2230">	if (ret_val)</a>
<a name="ln2231">		return ret_val;</a>
<a name="ln2232"> </a>
<a name="ln2233">	phy_data &amp;= ~HV_SMB_ADDR_MASK;</a>
<a name="ln2234">	phy_data |= (strap &gt;&gt; E1000_STRAP_SMBUS_ADDRESS_SHIFT);</a>
<a name="ln2235">	phy_data |= HV_SMB_ADDR_PEC_EN | HV_SMB_ADDR_VALID;</a>
<a name="ln2236"> </a>
<a name="ln2237">	if (hw-&gt;phy.type == e1000_phy_i217) {</a>
<a name="ln2238">		/* Restore SMBus frequency */</a>
<a name="ln2239">		if (freq--) {</a>
<a name="ln2240">			phy_data &amp;= ~HV_SMB_ADDR_FREQ_MASK;</a>
<a name="ln2241">			phy_data |= (freq &amp; (1 &lt;&lt; 0)) &lt;&lt;</a>
<a name="ln2242">				HV_SMB_ADDR_FREQ_LOW_SHIFT;</a>
<a name="ln2243">			phy_data |= (freq &amp; (1 &lt;&lt; 1)) &lt;&lt;</a>
<a name="ln2244">				(HV_SMB_ADDR_FREQ_HIGH_SHIFT - 1);</a>
<a name="ln2245">		} else {</a>
<a name="ln2246">			DEBUGOUT(&quot;Unsupported SMB frequency in PHY\n&quot;);</a>
<a name="ln2247">		}</a>
<a name="ln2248">	}</a>
<a name="ln2249"> </a>
<a name="ln2250">	return e1000_write_phy_reg_hv_locked(hw, HV_SMB_ADDR, phy_data);</a>
<a name="ln2251">}</a>
<a name="ln2252"> </a>
<a name="ln2253">/**</a>
<a name="ln2254"> *  e1000_sw_lcd_config_ich8lan - SW-based LCD Configuration</a>
<a name="ln2255"> *  @hw:   pointer to the HW structure</a>
<a name="ln2256"> *</a>
<a name="ln2257"> *  SW should configure the LCD from the NVM extended configuration region</a>
<a name="ln2258"> *  as a workaround for certain parts.</a>
<a name="ln2259"> **/</a>
<a name="ln2260">static s32 e1000_sw_lcd_config_ich8lan(struct e1000_hw *hw)</a>
<a name="ln2261">{</a>
<a name="ln2262">	struct e1000_phy_info *phy = &amp;hw-&gt;phy;</a>
<a name="ln2263">	u32 i, data, cnf_size, cnf_base_addr, sw_cfg_mask;</a>
<a name="ln2264">	s32 ret_val = E1000_SUCCESS;</a>
<a name="ln2265">	u16 word_addr, reg_data, reg_addr, phy_page = 0;</a>
<a name="ln2266"> </a>
<a name="ln2267">	DEBUGFUNC(&quot;e1000_sw_lcd_config_ich8lan&quot;);</a>
<a name="ln2268"> </a>
<a name="ln2269">	/* Initialize the PHY from the NVM on ICH platforms.  This</a>
<a name="ln2270">	 * is needed due to an issue where the NVM configuration is</a>
<a name="ln2271">	 * not properly autoloaded after power transitions.</a>
<a name="ln2272">	 * Therefore, after each PHY reset, we will load the</a>
<a name="ln2273">	 * configuration data out of the NVM manually.</a>
<a name="ln2274">	 */</a>
<a name="ln2275">	switch (hw-&gt;mac.type) {</a>
<a name="ln2276">	case e1000_ich8lan:</a>
<a name="ln2277">		if (phy-&gt;type != e1000_phy_igp_3)</a>
<a name="ln2278">			return ret_val;</a>
<a name="ln2279"> </a>
<a name="ln2280">		if ((hw-&gt;device_id == E1000_DEV_ID_ICH8_IGP_AMT) ||</a>
<a name="ln2281">		    (hw-&gt;device_id == E1000_DEV_ID_ICH8_IGP_C)) {</a>
<a name="ln2282">			sw_cfg_mask = E1000_FEXTNVM_SW_CONFIG;</a>
<a name="ln2283">			break;</a>
<a name="ln2284">		}</a>
<a name="ln2285">		/* Fall-thru */</a>
<a name="ln2286">	case e1000_pchlan:</a>
<a name="ln2287">	case e1000_pch2lan:</a>
<a name="ln2288">	case e1000_pch_lpt:</a>
<a name="ln2289">	case e1000_pch_spt:</a>
<a name="ln2290">	case e1000_pch_cnp:</a>
<a name="ln2291">		sw_cfg_mask = E1000_FEXTNVM_SW_CONFIG_ICH8M;</a>
<a name="ln2292">		break;</a>
<a name="ln2293">	default:</a>
<a name="ln2294">		return ret_val;</a>
<a name="ln2295">	}</a>
<a name="ln2296"> </a>
<a name="ln2297">	ret_val = hw-&gt;phy.ops.acquire(hw);</a>
<a name="ln2298">	if (ret_val)</a>
<a name="ln2299">		return ret_val;</a>
<a name="ln2300"> </a>
<a name="ln2301">	data = E1000_READ_REG(hw, E1000_FEXTNVM);</a>
<a name="ln2302">	if (!(data &amp; sw_cfg_mask))</a>
<a name="ln2303">		goto release;</a>
<a name="ln2304"> </a>
<a name="ln2305">	/* Make sure HW does not configure LCD from PHY</a>
<a name="ln2306">	 * extended configuration before SW configuration</a>
<a name="ln2307">	 */</a>
<a name="ln2308">	data = E1000_READ_REG(hw, E1000_EXTCNF_CTRL);</a>
<a name="ln2309">	if ((hw-&gt;mac.type &lt; e1000_pch2lan) &amp;&amp;</a>
<a name="ln2310">	    (data &amp; E1000_EXTCNF_CTRL_LCD_WRITE_ENABLE))</a>
<a name="ln2311">			goto release;</a>
<a name="ln2312"> </a>
<a name="ln2313">	cnf_size = E1000_READ_REG(hw, E1000_EXTCNF_SIZE);</a>
<a name="ln2314">	cnf_size &amp;= E1000_EXTCNF_SIZE_EXT_PCIE_LENGTH_MASK;</a>
<a name="ln2315">	cnf_size &gt;&gt;= E1000_EXTCNF_SIZE_EXT_PCIE_LENGTH_SHIFT;</a>
<a name="ln2316">	if (!cnf_size)</a>
<a name="ln2317">		goto release;</a>
<a name="ln2318"> </a>
<a name="ln2319">	cnf_base_addr = data &amp; E1000_EXTCNF_CTRL_EXT_CNF_POINTER_MASK;</a>
<a name="ln2320">	cnf_base_addr &gt;&gt;= E1000_EXTCNF_CTRL_EXT_CNF_POINTER_SHIFT;</a>
<a name="ln2321"> </a>
<a name="ln2322">	if (((hw-&gt;mac.type == e1000_pchlan) &amp;&amp;</a>
<a name="ln2323">	     !(data &amp; E1000_EXTCNF_CTRL_OEM_WRITE_ENABLE)) ||</a>
<a name="ln2324">	    (hw-&gt;mac.type &gt; e1000_pchlan)) {</a>
<a name="ln2325">		/* HW configures the SMBus address and LEDs when the</a>
<a name="ln2326">		 * OEM and LCD Write Enable bits are set in the NVM.</a>
<a name="ln2327">		 * When both NVM bits are cleared, SW will configure</a>
<a name="ln2328">		 * them instead.</a>
<a name="ln2329">		 */</a>
<a name="ln2330">		ret_val = e1000_write_smbus_addr(hw);</a>
<a name="ln2331">		if (ret_val)</a>
<a name="ln2332">			goto release;</a>
<a name="ln2333"> </a>
<a name="ln2334">		data = E1000_READ_REG(hw, E1000_LEDCTL);</a>
<a name="ln2335">		ret_val = e1000_write_phy_reg_hv_locked(hw, HV_LED_CONFIG,</a>
<a name="ln2336">							(u16)data);</a>
<a name="ln2337">		if (ret_val)</a>
<a name="ln2338">			goto release;</a>
<a name="ln2339">	}</a>
<a name="ln2340"> </a>
<a name="ln2341">	/* Configure LCD from extended configuration region. */</a>
<a name="ln2342"> </a>
<a name="ln2343">	/* cnf_base_addr is in DWORD */</a>
<a name="ln2344">	word_addr = (u16)(cnf_base_addr &lt;&lt; 1);</a>
<a name="ln2345"> </a>
<a name="ln2346">	for (i = 0; i &lt; cnf_size; i++) {</a>
<a name="ln2347">		ret_val = hw-&gt;nvm.ops.read(hw, (word_addr + i * 2), 1,</a>
<a name="ln2348">					   &amp;reg_data);</a>
<a name="ln2349">		if (ret_val)</a>
<a name="ln2350">			goto release;</a>
<a name="ln2351"> </a>
<a name="ln2352">		ret_val = hw-&gt;nvm.ops.read(hw, (word_addr + i * 2 + 1),</a>
<a name="ln2353">					   1, &amp;reg_addr);</a>
<a name="ln2354">		if (ret_val)</a>
<a name="ln2355">			goto release;</a>
<a name="ln2356"> </a>
<a name="ln2357">		/* Save off the PHY page for future writes. */</a>
<a name="ln2358">		if (reg_addr == IGP01E1000_PHY_PAGE_SELECT) {</a>
<a name="ln2359">			phy_page = reg_data;</a>
<a name="ln2360">			continue;</a>
<a name="ln2361">		}</a>
<a name="ln2362"> </a>
<a name="ln2363">		reg_addr &amp;= PHY_REG_MASK;</a>
<a name="ln2364">		reg_addr |= phy_page;</a>
<a name="ln2365"> </a>
<a name="ln2366">		ret_val = phy-&gt;ops.write_reg_locked(hw, (u32)reg_addr,</a>
<a name="ln2367">						    reg_data);</a>
<a name="ln2368">		if (ret_val)</a>
<a name="ln2369">			goto release;</a>
<a name="ln2370">	}</a>
<a name="ln2371"> </a>
<a name="ln2372">release:</a>
<a name="ln2373">	hw-&gt;phy.ops.release(hw);</a>
<a name="ln2374">	return ret_val;</a>
<a name="ln2375">}</a>
<a name="ln2376"> </a>
<a name="ln2377">/**</a>
<a name="ln2378"> *  e1000_k1_gig_workaround_hv - K1 Si workaround</a>
<a name="ln2379"> *  @hw:   pointer to the HW structure</a>
<a name="ln2380"> *  @link: link up bool flag</a>
<a name="ln2381"> *</a>
<a name="ln2382"> *  If K1 is enabled for 1Gbps, the MAC might stall when transitioning</a>
<a name="ln2383"> *  from a lower speed.  This workaround disables K1 whenever link is at 1Gig</a>
<a name="ln2384"> *  If link is down, the function will restore the default K1 setting located</a>
<a name="ln2385"> *  in the NVM.</a>
<a name="ln2386"> **/</a>
<a name="ln2387">static s32 e1000_k1_gig_workaround_hv(struct e1000_hw *hw, bool link)</a>
<a name="ln2388">{</a>
<a name="ln2389">	s32 ret_val = E1000_SUCCESS;</a>
<a name="ln2390">	u16 status_reg = 0;</a>
<a name="ln2391">	bool k1_enable = hw-&gt;dev_spec.ich8lan.nvm_k1_enabled;</a>
<a name="ln2392"> </a>
<a name="ln2393">	DEBUGFUNC(&quot;e1000_k1_gig_workaround_hv&quot;);</a>
<a name="ln2394"> </a>
<a name="ln2395">	if (hw-&gt;mac.type != e1000_pchlan)</a>
<a name="ln2396">		return E1000_SUCCESS;</a>
<a name="ln2397"> </a>
<a name="ln2398">	/* Wrap the whole flow with the sw flag */</a>
<a name="ln2399">	ret_val = hw-&gt;phy.ops.acquire(hw);</a>
<a name="ln2400">	if (ret_val)</a>
<a name="ln2401">		return ret_val;</a>
<a name="ln2402"> </a>
<a name="ln2403">	/* Disable K1 when link is 1Gbps, otherwise use the NVM setting */</a>
<a name="ln2404">	if (link) {</a>
<a name="ln2405">		if (hw-&gt;phy.type == e1000_phy_82578) {</a>
<a name="ln2406">			ret_val = hw-&gt;phy.ops.read_reg_locked(hw, BM_CS_STATUS,</a>
<a name="ln2407">							      &amp;status_reg);</a>
<a name="ln2408">			if (ret_val)</a>
<a name="ln2409">				goto release;</a>
<a name="ln2410"> </a>
<a name="ln2411">			status_reg &amp;= (BM_CS_STATUS_LINK_UP |</a>
<a name="ln2412">				       BM_CS_STATUS_RESOLVED |</a>
<a name="ln2413">				       BM_CS_STATUS_SPEED_MASK);</a>
<a name="ln2414"> </a>
<a name="ln2415">			if (status_reg == (BM_CS_STATUS_LINK_UP |</a>
<a name="ln2416">					   BM_CS_STATUS_RESOLVED |</a>
<a name="ln2417">					   BM_CS_STATUS_SPEED_1000))</a>
<a name="ln2418">				k1_enable = FALSE;</a>
<a name="ln2419">		}</a>
<a name="ln2420"> </a>
<a name="ln2421">		if (hw-&gt;phy.type == e1000_phy_82577) {</a>
<a name="ln2422">			ret_val = hw-&gt;phy.ops.read_reg_locked(hw, HV_M_STATUS,</a>
<a name="ln2423">							      &amp;status_reg);</a>
<a name="ln2424">			if (ret_val)</a>
<a name="ln2425">				goto release;</a>
<a name="ln2426"> </a>
<a name="ln2427">			status_reg &amp;= (HV_M_STATUS_LINK_UP |</a>
<a name="ln2428">				       HV_M_STATUS_AUTONEG_COMPLETE |</a>
<a name="ln2429">				       HV_M_STATUS_SPEED_MASK);</a>
<a name="ln2430"> </a>
<a name="ln2431">			if (status_reg == (HV_M_STATUS_LINK_UP |</a>
<a name="ln2432">					   HV_M_STATUS_AUTONEG_COMPLETE |</a>
<a name="ln2433">					   HV_M_STATUS_SPEED_1000))</a>
<a name="ln2434">				k1_enable = FALSE;</a>
<a name="ln2435">		}</a>
<a name="ln2436"> </a>
<a name="ln2437">		/* Link stall fix for link up */</a>
<a name="ln2438">		ret_val = hw-&gt;phy.ops.write_reg_locked(hw, PHY_REG(770, 19),</a>
<a name="ln2439">						       0x0100);</a>
<a name="ln2440">		if (ret_val)</a>
<a name="ln2441">			goto release;</a>
<a name="ln2442"> </a>
<a name="ln2443">	} else {</a>
<a name="ln2444">		/* Link stall fix for link down */</a>
<a name="ln2445">		ret_val = hw-&gt;phy.ops.write_reg_locked(hw, PHY_REG(770, 19),</a>
<a name="ln2446">						       0x4100);</a>
<a name="ln2447">		if (ret_val)</a>
<a name="ln2448">			goto release;</a>
<a name="ln2449">	}</a>
<a name="ln2450"> </a>
<a name="ln2451">	ret_val = e1000_configure_k1_ich8lan(hw, k1_enable);</a>
<a name="ln2452"> </a>
<a name="ln2453">release:</a>
<a name="ln2454">	hw-&gt;phy.ops.release(hw);</a>
<a name="ln2455"> </a>
<a name="ln2456">	return ret_val;</a>
<a name="ln2457">}</a>
<a name="ln2458"> </a>
<a name="ln2459">/**</a>
<a name="ln2460"> *  e1000_configure_k1_ich8lan - Configure K1 power state</a>
<a name="ln2461"> *  @hw: pointer to the HW structure</a>
<a name="ln2462"> *  @enable: K1 state to configure</a>
<a name="ln2463"> *</a>
<a name="ln2464"> *  Configure the K1 power state based on the provided parameter.</a>
<a name="ln2465"> *  Assumes semaphore already acquired.</a>
<a name="ln2466"> *</a>
<a name="ln2467"> *  Success returns 0, Failure returns -E1000_ERR_PHY (-2)</a>
<a name="ln2468"> **/</a>
<a name="ln2469">s32 e1000_configure_k1_ich8lan(struct e1000_hw *hw, bool k1_enable)</a>
<a name="ln2470">{</a>
<a name="ln2471">	s32 ret_val;</a>
<a name="ln2472">	u32 ctrl_reg = 0;</a>
<a name="ln2473">	u32 ctrl_ext = 0;</a>
<a name="ln2474">	u32 reg = 0;</a>
<a name="ln2475">	u16 kmrn_reg = 0;</a>
<a name="ln2476"> </a>
<a name="ln2477">	DEBUGFUNC(&quot;e1000_configure_k1_ich8lan&quot;);</a>
<a name="ln2478"> </a>
<a name="ln2479">	ret_val = e1000_read_kmrn_reg_locked(hw, E1000_KMRNCTRLSTA_K1_CONFIG,</a>
<a name="ln2480">					     &amp;kmrn_reg);</a>
<a name="ln2481">	if (ret_val)</a>
<a name="ln2482">		return ret_val;</a>
<a name="ln2483"> </a>
<a name="ln2484">	if (k1_enable)</a>
<a name="ln2485">		kmrn_reg |= E1000_KMRNCTRLSTA_K1_ENABLE;</a>
<a name="ln2486">	else</a>
<a name="ln2487">		kmrn_reg &amp;= ~E1000_KMRNCTRLSTA_K1_ENABLE;</a>
<a name="ln2488"> </a>
<a name="ln2489">	ret_val = e1000_write_kmrn_reg_locked(hw, E1000_KMRNCTRLSTA_K1_CONFIG,</a>
<a name="ln2490">					      kmrn_reg);</a>
<a name="ln2491">	if (ret_val)</a>
<a name="ln2492">		return ret_val;</a>
<a name="ln2493"> </a>
<a name="ln2494">	usec_delay(20);</a>
<a name="ln2495">	ctrl_ext = E1000_READ_REG(hw, E1000_CTRL_EXT);</a>
<a name="ln2496">	ctrl_reg = E1000_READ_REG(hw, E1000_CTRL);</a>
<a name="ln2497"> </a>
<a name="ln2498">	reg = ctrl_reg &amp; ~(E1000_CTRL_SPD_1000 | E1000_CTRL_SPD_100);</a>
<a name="ln2499">	reg |= E1000_CTRL_FRCSPD;</a>
<a name="ln2500">	E1000_WRITE_REG(hw, E1000_CTRL, reg);</a>
<a name="ln2501"> </a>
<a name="ln2502">	E1000_WRITE_REG(hw, E1000_CTRL_EXT, ctrl_ext | E1000_CTRL_EXT_SPD_BYPS);</a>
<a name="ln2503">	E1000_WRITE_FLUSH(hw);</a>
<a name="ln2504">	usec_delay(20);</a>
<a name="ln2505">	E1000_WRITE_REG(hw, E1000_CTRL, ctrl_reg);</a>
<a name="ln2506">	E1000_WRITE_REG(hw, E1000_CTRL_EXT, ctrl_ext);</a>
<a name="ln2507">	E1000_WRITE_FLUSH(hw);</a>
<a name="ln2508">	usec_delay(20);</a>
<a name="ln2509"> </a>
<a name="ln2510">	return E1000_SUCCESS;</a>
<a name="ln2511">}</a>
<a name="ln2512"> </a>
<a name="ln2513">/**</a>
<a name="ln2514"> *  e1000_oem_bits_config_ich8lan - SW-based LCD Configuration</a>
<a name="ln2515"> *  @hw:       pointer to the HW structure</a>
<a name="ln2516"> *  @d0_state: boolean if entering d0 or d3 device state</a>
<a name="ln2517"> *</a>
<a name="ln2518"> *  SW will configure Gbe Disable and LPLU based on the NVM. The four bits are</a>
<a name="ln2519"> *  collectively called OEM bits.  The OEM Write Enable bit and SW Config bit</a>
<a name="ln2520"> *  in NVM determines whether HW should configure LPLU and Gbe Disable.</a>
<a name="ln2521"> **/</a>
<a name="ln2522">static s32 e1000_oem_bits_config_ich8lan(struct e1000_hw *hw, bool d0_state)</a>
<a name="ln2523">{</a>
<a name="ln2524">	s32 ret_val = 0;</a>
<a name="ln2525">	u32 mac_reg;</a>
<a name="ln2526">	u16 oem_reg;</a>
<a name="ln2527"> </a>
<a name="ln2528">	DEBUGFUNC(&quot;e1000_oem_bits_config_ich8lan&quot;);</a>
<a name="ln2529"> </a>
<a name="ln2530">	if (hw-&gt;mac.type &lt; e1000_pchlan)</a>
<a name="ln2531">		return ret_val;</a>
<a name="ln2532"> </a>
<a name="ln2533">	ret_val = hw-&gt;phy.ops.acquire(hw);</a>
<a name="ln2534">	if (ret_val)</a>
<a name="ln2535">		return ret_val;</a>
<a name="ln2536"> </a>
<a name="ln2537">	if (hw-&gt;mac.type == e1000_pchlan) {</a>
<a name="ln2538">		mac_reg = E1000_READ_REG(hw, E1000_EXTCNF_CTRL);</a>
<a name="ln2539">		if (mac_reg &amp; E1000_EXTCNF_CTRL_OEM_WRITE_ENABLE)</a>
<a name="ln2540">			goto release;</a>
<a name="ln2541">	}</a>
<a name="ln2542"> </a>
<a name="ln2543">	mac_reg = E1000_READ_REG(hw, E1000_FEXTNVM);</a>
<a name="ln2544">	if (!(mac_reg &amp; E1000_FEXTNVM_SW_CONFIG_ICH8M))</a>
<a name="ln2545">		goto release;</a>
<a name="ln2546"> </a>
<a name="ln2547">	mac_reg = E1000_READ_REG(hw, E1000_PHY_CTRL);</a>
<a name="ln2548"> </a>
<a name="ln2549">	ret_val = hw-&gt;phy.ops.read_reg_locked(hw, HV_OEM_BITS, &amp;oem_reg);</a>
<a name="ln2550">	if (ret_val)</a>
<a name="ln2551">		goto release;</a>
<a name="ln2552"> </a>
<a name="ln2553">	oem_reg &amp;= ~(HV_OEM_BITS_GBE_DIS | HV_OEM_BITS_LPLU);</a>
<a name="ln2554"> </a>
<a name="ln2555">	if (d0_state) {</a>
<a name="ln2556">		if (mac_reg &amp; E1000_PHY_CTRL_GBE_DISABLE)</a>
<a name="ln2557">			oem_reg |= HV_OEM_BITS_GBE_DIS;</a>
<a name="ln2558"> </a>
<a name="ln2559">		if (mac_reg &amp; E1000_PHY_CTRL_D0A_LPLU)</a>
<a name="ln2560">			oem_reg |= HV_OEM_BITS_LPLU;</a>
<a name="ln2561">	} else {</a>
<a name="ln2562">		if (mac_reg &amp; (E1000_PHY_CTRL_GBE_DISABLE |</a>
<a name="ln2563">		    E1000_PHY_CTRL_NOND0A_GBE_DISABLE))</a>
<a name="ln2564">			oem_reg |= HV_OEM_BITS_GBE_DIS;</a>
<a name="ln2565"> </a>
<a name="ln2566">		if (mac_reg &amp; (E1000_PHY_CTRL_D0A_LPLU |</a>
<a name="ln2567">		    E1000_PHY_CTRL_NOND0A_LPLU))</a>
<a name="ln2568">			oem_reg |= HV_OEM_BITS_LPLU;</a>
<a name="ln2569">	}</a>
<a name="ln2570"> </a>
<a name="ln2571">	/* Set Restart auto-neg to activate the bits */</a>
<a name="ln2572">	if ((d0_state || (hw-&gt;mac.type != e1000_pchlan)) &amp;&amp;</a>
<a name="ln2573">	    !hw-&gt;phy.ops.check_reset_block(hw))</a>
<a name="ln2574">		oem_reg |= HV_OEM_BITS_RESTART_AN;</a>
<a name="ln2575"> </a>
<a name="ln2576">	ret_val = hw-&gt;phy.ops.write_reg_locked(hw, HV_OEM_BITS, oem_reg);</a>
<a name="ln2577"> </a>
<a name="ln2578">release:</a>
<a name="ln2579">	hw-&gt;phy.ops.release(hw);</a>
<a name="ln2580"> </a>
<a name="ln2581">	return ret_val;</a>
<a name="ln2582">}</a>
<a name="ln2583"> </a>
<a name="ln2584"> </a>
<a name="ln2585">/**</a>
<a name="ln2586"> *  e1000_set_mdio_slow_mode_hv - Set slow MDIO access mode</a>
<a name="ln2587"> *  @hw:   pointer to the HW structure</a>
<a name="ln2588"> **/</a>
<a name="ln2589">static s32 e1000_set_mdio_slow_mode_hv(struct e1000_hw *hw)</a>
<a name="ln2590">{</a>
<a name="ln2591">	s32 ret_val;</a>
<a name="ln2592">	u16 data;</a>
<a name="ln2593"> </a>
<a name="ln2594">	DEBUGFUNC(&quot;e1000_set_mdio_slow_mode_hv&quot;);</a>
<a name="ln2595"> </a>
<a name="ln2596">	ret_val = hw-&gt;phy.ops.read_reg(hw, HV_KMRN_MODE_CTRL, &amp;data);</a>
<a name="ln2597">	if (ret_val)</a>
<a name="ln2598">		return ret_val;</a>
<a name="ln2599"> </a>
<a name="ln2600">	data |= HV_KMRN_MDIO_SLOW;</a>
<a name="ln2601"> </a>
<a name="ln2602">	ret_val = hw-&gt;phy.ops.write_reg(hw, HV_KMRN_MODE_CTRL, data);</a>
<a name="ln2603"> </a>
<a name="ln2604">	return ret_val;</a>
<a name="ln2605">}</a>
<a name="ln2606"> </a>
<a name="ln2607">/**</a>
<a name="ln2608"> *  e1000_hv_phy_workarounds_ich8lan - A series of Phy workarounds to be</a>
<a name="ln2609"> *  done after every PHY reset.</a>
<a name="ln2610"> **/</a>
<a name="ln2611">static s32 e1000_hv_phy_workarounds_ich8lan(struct e1000_hw *hw)</a>
<a name="ln2612">{</a>
<a name="ln2613">	s32 ret_val = E1000_SUCCESS;</a>
<a name="ln2614">	u16 phy_data;</a>
<a name="ln2615"> </a>
<a name="ln2616">	DEBUGFUNC(&quot;e1000_hv_phy_workarounds_ich8lan&quot;);</a>
<a name="ln2617"> </a>
<a name="ln2618">	if (hw-&gt;mac.type != e1000_pchlan)</a>
<a name="ln2619">		return E1000_SUCCESS;</a>
<a name="ln2620"> </a>
<a name="ln2621">	/* Set MDIO slow mode before any other MDIO access */</a>
<a name="ln2622">	if (hw-&gt;phy.type == e1000_phy_82577) {</a>
<a name="ln2623">		ret_val = e1000_set_mdio_slow_mode_hv(hw);</a>
<a name="ln2624">		if (ret_val)</a>
<a name="ln2625">			return ret_val;</a>
<a name="ln2626">	}</a>
<a name="ln2627"> </a>
<a name="ln2628">	if (((hw-&gt;phy.type == e1000_phy_82577) &amp;&amp;</a>
<a name="ln2629">	     ((hw-&gt;phy.revision == 1) || (hw-&gt;phy.revision == 2))) ||</a>
<a name="ln2630">	    ((hw-&gt;phy.type == e1000_phy_82578) &amp;&amp; (hw-&gt;phy.revision == 1))) {</a>
<a name="ln2631">		/* Disable generation of early preamble */</a>
<a name="ln2632">		ret_val = hw-&gt;phy.ops.write_reg(hw, PHY_REG(769, 25), 0x4431);</a>
<a name="ln2633">		if (ret_val)</a>
<a name="ln2634">			return ret_val;</a>
<a name="ln2635"> </a>
<a name="ln2636">		/* Preamble tuning for SSC */</a>
<a name="ln2637">		ret_val = hw-&gt;phy.ops.write_reg(hw, HV_KMRN_FIFO_CTRLSTA,</a>
<a name="ln2638">						0xA204);</a>
<a name="ln2639">		if (ret_val)</a>
<a name="ln2640">			return ret_val;</a>
<a name="ln2641">	}</a>
<a name="ln2642"> </a>
<a name="ln2643">	if (hw-&gt;phy.type == e1000_phy_82578) {</a>
<a name="ln2644">		/* Return registers to default by doing a soft reset then</a>
<a name="ln2645">		 * writing 0x3140 to the control register.</a>
<a name="ln2646">		 */</a>
<a name="ln2647">		if (hw-&gt;phy.revision &lt; 2) {</a>
<a name="ln2648">			e1000_phy_sw_reset_generic(hw);</a>
<a name="ln2649">			ret_val = hw-&gt;phy.ops.write_reg(hw, PHY_CONTROL,</a>
<a name="ln2650">							0x3140);</a>
<a name="ln2651">			if (ret_val)</a>
<a name="ln2652">				return ret_val;</a>
<a name="ln2653">		}</a>
<a name="ln2654">	}</a>
<a name="ln2655"> </a>
<a name="ln2656">	/* Select page 0 */</a>
<a name="ln2657">	ret_val = hw-&gt;phy.ops.acquire(hw);</a>
<a name="ln2658">	if (ret_val)</a>
<a name="ln2659">		return ret_val;</a>
<a name="ln2660"> </a>
<a name="ln2661">	hw-&gt;phy.addr = 1;</a>
<a name="ln2662">	ret_val = e1000_write_phy_reg_mdic(hw, IGP01E1000_PHY_PAGE_SELECT, 0);</a>
<a name="ln2663">	hw-&gt;phy.ops.release(hw);</a>
<a name="ln2664">	if (ret_val)</a>
<a name="ln2665">		return ret_val;</a>
<a name="ln2666"> </a>
<a name="ln2667">	/* Configure the K1 Si workaround during phy reset assuming there is</a>
<a name="ln2668">	 * link so that it disables K1 if link is in 1Gbps.</a>
<a name="ln2669">	 */</a>
<a name="ln2670">	ret_val = e1000_k1_gig_workaround_hv(hw, TRUE);</a>
<a name="ln2671">	if (ret_val)</a>
<a name="ln2672">		return ret_val;</a>
<a name="ln2673"> </a>
<a name="ln2674">	/* Workaround for link disconnects on a busy hub in half duplex */</a>
<a name="ln2675">	ret_val = hw-&gt;phy.ops.acquire(hw);</a>
<a name="ln2676">	if (ret_val)</a>
<a name="ln2677">		return ret_val;</a>
<a name="ln2678">	ret_val = hw-&gt;phy.ops.read_reg_locked(hw, BM_PORT_GEN_CFG, &amp;phy_data);</a>
<a name="ln2679">	if (ret_val)</a>
<a name="ln2680">		goto release;</a>
<a name="ln2681">	ret_val = hw-&gt;phy.ops.write_reg_locked(hw, BM_PORT_GEN_CFG,</a>
<a name="ln2682">					       phy_data &amp; 0x00FF);</a>
<a name="ln2683">	if (ret_val)</a>
<a name="ln2684">		goto release;</a>
<a name="ln2685"> </a>
<a name="ln2686">	/* set MSE higher to enable link to stay up when noise is high */</a>
<a name="ln2687">	ret_val = e1000_write_emi_reg_locked(hw, I82577_MSE_THRESHOLD, 0x0034);</a>
<a name="ln2688">release:</a>
<a name="ln2689">	hw-&gt;phy.ops.release(hw);</a>
<a name="ln2690"> </a>
<a name="ln2691">	return ret_val;</a>
<a name="ln2692">}</a>
<a name="ln2693"> </a>
<a name="ln2694">/**</a>
<a name="ln2695"> *  e1000_copy_rx_addrs_to_phy_ich8lan - Copy Rx addresses from MAC to PHY</a>
<a name="ln2696"> *  @hw:   pointer to the HW structure</a>
<a name="ln2697"> **/</a>
<a name="ln2698">void e1000_copy_rx_addrs_to_phy_ich8lan(struct e1000_hw *hw)</a>
<a name="ln2699">{</a>
<a name="ln2700">	u32 mac_reg;</a>
<a name="ln2701">	u16 i, phy_reg = 0;</a>
<a name="ln2702">	s32 ret_val;</a>
<a name="ln2703"> </a>
<a name="ln2704">	DEBUGFUNC(&quot;e1000_copy_rx_addrs_to_phy_ich8lan&quot;);</a>
<a name="ln2705"> </a>
<a name="ln2706">	ret_val = hw-&gt;phy.ops.acquire(hw);</a>
<a name="ln2707">	if (ret_val)</a>
<a name="ln2708">		return;</a>
<a name="ln2709">	ret_val = e1000_enable_phy_wakeup_reg_access_bm(hw, &amp;phy_reg);</a>
<a name="ln2710">	if (ret_val)</a>
<a name="ln2711">		goto release;</a>
<a name="ln2712"> </a>
<a name="ln2713">	/* Copy both RAL/H (rar_entry_count) and SHRAL/H to PHY */</a>
<a name="ln2714">	for (i = 0; i &lt; (hw-&gt;mac.rar_entry_count); i++) {</a>
<a name="ln2715">		mac_reg = E1000_READ_REG(hw, E1000_RAL(i));</a>
<a name="ln2716">		hw-&gt;phy.ops.write_reg_page(hw, BM_RAR_L(i),</a>
<a name="ln2717">					   (u16)(mac_reg &amp; 0xFFFF));</a>
<a name="ln2718">		hw-&gt;phy.ops.write_reg_page(hw, BM_RAR_M(i),</a>
<a name="ln2719">					   (u16)((mac_reg &gt;&gt; 16) &amp; 0xFFFF));</a>
<a name="ln2720"> </a>
<a name="ln2721">		mac_reg = E1000_READ_REG(hw, E1000_RAH(i));</a>
<a name="ln2722">		hw-&gt;phy.ops.write_reg_page(hw, BM_RAR_H(i),</a>
<a name="ln2723">					   (u16)(mac_reg &amp; 0xFFFF));</a>
<a name="ln2724">		hw-&gt;phy.ops.write_reg_page(hw, BM_RAR_CTRL(i),</a>
<a name="ln2725">					   (u16)((mac_reg &amp; E1000_RAH_AV)</a>
<a name="ln2726">						 &gt;&gt; 16));</a>
<a name="ln2727">	}</a>
<a name="ln2728"> </a>
<a name="ln2729">	e1000_disable_phy_wakeup_reg_access_bm(hw, &amp;phy_reg);</a>
<a name="ln2730"> </a>
<a name="ln2731">release:</a>
<a name="ln2732">	hw-&gt;phy.ops.release(hw);</a>
<a name="ln2733">}</a>
<a name="ln2734"> </a>
<a name="ln2735">static u32 e1000_calc_rx_da_crc(u8 mac[])</a>
<a name="ln2736">{</a>
<a name="ln2737">	u32 poly = 0xEDB88320;	/* Polynomial for 802.3 CRC calculation */</a>
<a name="ln2738">	u32 i, j, mask, crc;</a>
<a name="ln2739"> </a>
<a name="ln2740">	DEBUGFUNC(&quot;e1000_calc_rx_da_crc&quot;);</a>
<a name="ln2741"> </a>
<a name="ln2742">	crc = 0xffffffff;</a>
<a name="ln2743">	for (i = 0; i &lt; 6; i++) {</a>
<a name="ln2744">		crc = crc ^ mac[i];</a>
<a name="ln2745">		for (j = 8; j &gt; 0; j--) {</a>
<a name="ln2746">			mask = (crc &amp; 1) * (-1);</a>
<a name="ln2747">			crc = (crc &gt;&gt; 1) ^ (poly &amp; mask);</a>
<a name="ln2748">		}</a>
<a name="ln2749">	}</a>
<a name="ln2750">	return ~crc;</a>
<a name="ln2751">}</a>
<a name="ln2752"> </a>
<a name="ln2753">/**</a>
<a name="ln2754"> *  e1000_lv_jumbo_workaround_ich8lan - required for jumbo frame operation</a>
<a name="ln2755"> *  with 82579 PHY</a>
<a name="ln2756"> *  @hw: pointer to the HW structure</a>
<a name="ln2757"> *  @enable: flag to enable/disable workaround when enabling/disabling jumbos</a>
<a name="ln2758"> **/</a>
<a name="ln2759">s32 e1000_lv_jumbo_workaround_ich8lan(struct e1000_hw *hw, bool enable)</a>
<a name="ln2760">{</a>
<a name="ln2761">	s32 ret_val = E1000_SUCCESS;</a>
<a name="ln2762">	u16 phy_reg, data;</a>
<a name="ln2763">	u32 mac_reg;</a>
<a name="ln2764">	u16 i;</a>
<a name="ln2765"> </a>
<a name="ln2766">	DEBUGFUNC(&quot;e1000_lv_jumbo_workaround_ich8lan&quot;);</a>
<a name="ln2767"> </a>
<a name="ln2768">	if (hw-&gt;mac.type &lt; e1000_pch2lan)</a>
<a name="ln2769">		return E1000_SUCCESS;</a>
<a name="ln2770"> </a>
<a name="ln2771">	/* disable Rx path while enabling/disabling workaround */</a>
<a name="ln2772">	hw-&gt;phy.ops.read_reg(hw, PHY_REG(769, 20), &amp;phy_reg);</a>
<a name="ln2773">	ret_val = hw-&gt;phy.ops.write_reg(hw, PHY_REG(769, 20),</a>
<a name="ln2774">					phy_reg | (1 &lt;&lt; 14));</a>
<a name="ln2775">	if (ret_val)</a>
<a name="ln2776">		return ret_val;</a>
<a name="ln2777"> </a>
<a name="ln2778">	if (enable) {</a>
<a name="ln2779">		/* Write Rx addresses (rar_entry_count for RAL/H, and</a>
<a name="ln2780">		 * SHRAL/H) and initial CRC values to the MAC</a>
<a name="ln2781">		 */</a>
<a name="ln2782">		for (i = 0; i &lt; hw-&gt;mac.rar_entry_count; i++) {</a>
<a name="ln2783">			u8 mac_addr[ETH_ADDR_LEN] = {0};</a>
<a name="ln2784">			u32 addr_high, addr_low;</a>
<a name="ln2785"> </a>
<a name="ln2786">			addr_high = E1000_READ_REG(hw, E1000_RAH(i));</a>
<a name="ln2787">			if (!(addr_high &amp; E1000_RAH_AV))</a>
<a name="ln2788">				continue;</a>
<a name="ln2789">			addr_low = E1000_READ_REG(hw, E1000_RAL(i));</a>
<a name="ln2790">			mac_addr[0] = (addr_low &amp; 0xFF);</a>
<a name="ln2791">			mac_addr[1] = ((addr_low &gt;&gt; 8) &amp; 0xFF);</a>
<a name="ln2792">			mac_addr[2] = ((addr_low &gt;&gt; 16) &amp; 0xFF);</a>
<a name="ln2793">			mac_addr[3] = ((addr_low &gt;&gt; 24) &amp; 0xFF);</a>
<a name="ln2794">			mac_addr[4] = (addr_high &amp; 0xFF);</a>
<a name="ln2795">			mac_addr[5] = ((addr_high &gt;&gt; 8) &amp; 0xFF);</a>
<a name="ln2796"> </a>
<a name="ln2797">			E1000_WRITE_REG(hw, E1000_PCH_RAICC(i),</a>
<a name="ln2798">					e1000_calc_rx_da_crc(mac_addr));</a>
<a name="ln2799">		}</a>
<a name="ln2800"> </a>
<a name="ln2801">		/* Write Rx addresses to the PHY */</a>
<a name="ln2802">		e1000_copy_rx_addrs_to_phy_ich8lan(hw);</a>
<a name="ln2803"> </a>
<a name="ln2804">		/* Enable jumbo frame workaround in the MAC */</a>
<a name="ln2805">		mac_reg = E1000_READ_REG(hw, E1000_FFLT_DBG);</a>
<a name="ln2806">		mac_reg &amp;= ~(1 &lt;&lt; 14);</a>
<a name="ln2807">		mac_reg |= (7 &lt;&lt; 15);</a>
<a name="ln2808">		E1000_WRITE_REG(hw, E1000_FFLT_DBG, mac_reg);</a>
<a name="ln2809"> </a>
<a name="ln2810">		mac_reg = E1000_READ_REG(hw, E1000_RCTL);</a>
<a name="ln2811">		mac_reg |= E1000_RCTL_SECRC;</a>
<a name="ln2812">		E1000_WRITE_REG(hw, E1000_RCTL, mac_reg);</a>
<a name="ln2813"> </a>
<a name="ln2814">		ret_val = e1000_read_kmrn_reg_generic(hw,</a>
<a name="ln2815">						E1000_KMRNCTRLSTA_CTRL_OFFSET,</a>
<a name="ln2816">						&amp;data);</a>
<a name="ln2817">		if (ret_val)</a>
<a name="ln2818">			return ret_val;</a>
<a name="ln2819">		ret_val = e1000_write_kmrn_reg_generic(hw,</a>
<a name="ln2820">						E1000_KMRNCTRLSTA_CTRL_OFFSET,</a>
<a name="ln2821">						data | (1 &lt;&lt; 0));</a>
<a name="ln2822">		if (ret_val)</a>
<a name="ln2823">			return ret_val;</a>
<a name="ln2824">		ret_val = e1000_read_kmrn_reg_generic(hw,</a>
<a name="ln2825">						E1000_KMRNCTRLSTA_HD_CTRL,</a>
<a name="ln2826">						&amp;data);</a>
<a name="ln2827">		if (ret_val)</a>
<a name="ln2828">			return ret_val;</a>
<a name="ln2829">		data &amp;= ~(0xF &lt;&lt; 8);</a>
<a name="ln2830">		data |= (0xB &lt;&lt; 8);</a>
<a name="ln2831">		ret_val = e1000_write_kmrn_reg_generic(hw,</a>
<a name="ln2832">						E1000_KMRNCTRLSTA_HD_CTRL,</a>
<a name="ln2833">						data);</a>
<a name="ln2834">		if (ret_val)</a>
<a name="ln2835">			return ret_val;</a>
<a name="ln2836"> </a>
<a name="ln2837">		/* Enable jumbo frame workaround in the PHY */</a>
<a name="ln2838">		hw-&gt;phy.ops.read_reg(hw, PHY_REG(769, 23), &amp;data);</a>
<a name="ln2839">		data &amp;= ~(0x7F &lt;&lt; 5);</a>
<a name="ln2840">		data |= (0x37 &lt;&lt; 5);</a>
<a name="ln2841">		ret_val = hw-&gt;phy.ops.write_reg(hw, PHY_REG(769, 23), data);</a>
<a name="ln2842">		if (ret_val)</a>
<a name="ln2843">			return ret_val;</a>
<a name="ln2844">		hw-&gt;phy.ops.read_reg(hw, PHY_REG(769, 16), &amp;data);</a>
<a name="ln2845">		data &amp;= ~(1 &lt;&lt; 13);</a>
<a name="ln2846">		ret_val = hw-&gt;phy.ops.write_reg(hw, PHY_REG(769, 16), data);</a>
<a name="ln2847">		if (ret_val)</a>
<a name="ln2848">			return ret_val;</a>
<a name="ln2849">		hw-&gt;phy.ops.read_reg(hw, PHY_REG(776, 20), &amp;data);</a>
<a name="ln2850">		data &amp;= ~(0x3FF &lt;&lt; 2);</a>
<a name="ln2851">		data |= (E1000_TX_PTR_GAP &lt;&lt; 2);</a>
<a name="ln2852">		ret_val = hw-&gt;phy.ops.write_reg(hw, PHY_REG(776, 20), data);</a>
<a name="ln2853">		if (ret_val)</a>
<a name="ln2854">			return ret_val;</a>
<a name="ln2855">		ret_val = hw-&gt;phy.ops.write_reg(hw, PHY_REG(776, 23), 0xF100);</a>
<a name="ln2856">		if (ret_val)</a>
<a name="ln2857">			return ret_val;</a>
<a name="ln2858">		hw-&gt;phy.ops.read_reg(hw, HV_PM_CTRL, &amp;data);</a>
<a name="ln2859">		ret_val = hw-&gt;phy.ops.write_reg(hw, HV_PM_CTRL, data |</a>
<a name="ln2860">						(1 &lt;&lt; 10));</a>
<a name="ln2861">		if (ret_val)</a>
<a name="ln2862">			return ret_val;</a>
<a name="ln2863">	} else {</a>
<a name="ln2864">		/* Write MAC register values back to h/w defaults */</a>
<a name="ln2865">		mac_reg = E1000_READ_REG(hw, E1000_FFLT_DBG);</a>
<a name="ln2866">		mac_reg &amp;= ~(0xF &lt;&lt; 14);</a>
<a name="ln2867">		E1000_WRITE_REG(hw, E1000_FFLT_DBG, mac_reg);</a>
<a name="ln2868"> </a>
<a name="ln2869">		mac_reg = E1000_READ_REG(hw, E1000_RCTL);</a>
<a name="ln2870">		mac_reg &amp;= ~E1000_RCTL_SECRC;</a>
<a name="ln2871">		E1000_WRITE_REG(hw, E1000_RCTL, mac_reg);</a>
<a name="ln2872"> </a>
<a name="ln2873">		ret_val = e1000_read_kmrn_reg_generic(hw,</a>
<a name="ln2874">						E1000_KMRNCTRLSTA_CTRL_OFFSET,</a>
<a name="ln2875">						&amp;data);</a>
<a name="ln2876">		if (ret_val)</a>
<a name="ln2877">			return ret_val;</a>
<a name="ln2878">		ret_val = e1000_write_kmrn_reg_generic(hw,</a>
<a name="ln2879">						E1000_KMRNCTRLSTA_CTRL_OFFSET,</a>
<a name="ln2880">						data &amp; ~(1 &lt;&lt; 0));</a>
<a name="ln2881">		if (ret_val)</a>
<a name="ln2882">			return ret_val;</a>
<a name="ln2883">		ret_val = e1000_read_kmrn_reg_generic(hw,</a>
<a name="ln2884">						E1000_KMRNCTRLSTA_HD_CTRL,</a>
<a name="ln2885">						&amp;data);</a>
<a name="ln2886">		if (ret_val)</a>
<a name="ln2887">			return ret_val;</a>
<a name="ln2888">		data &amp;= ~(0xF &lt;&lt; 8);</a>
<a name="ln2889">		data |= (0xB &lt;&lt; 8);</a>
<a name="ln2890">		ret_val = e1000_write_kmrn_reg_generic(hw,</a>
<a name="ln2891">						E1000_KMRNCTRLSTA_HD_CTRL,</a>
<a name="ln2892">						data);</a>
<a name="ln2893">		if (ret_val)</a>
<a name="ln2894">			return ret_val;</a>
<a name="ln2895"> </a>
<a name="ln2896">		/* Write PHY register values back to h/w defaults */</a>
<a name="ln2897">		hw-&gt;phy.ops.read_reg(hw, PHY_REG(769, 23), &amp;data);</a>
<a name="ln2898">		data &amp;= ~(0x7F &lt;&lt; 5);</a>
<a name="ln2899">		ret_val = hw-&gt;phy.ops.write_reg(hw, PHY_REG(769, 23), data);</a>
<a name="ln2900">		if (ret_val)</a>
<a name="ln2901">			return ret_val;</a>
<a name="ln2902">		hw-&gt;phy.ops.read_reg(hw, PHY_REG(769, 16), &amp;data);</a>
<a name="ln2903">		data |= (1 &lt;&lt; 13);</a>
<a name="ln2904">		ret_val = hw-&gt;phy.ops.write_reg(hw, PHY_REG(769, 16), data);</a>
<a name="ln2905">		if (ret_val)</a>
<a name="ln2906">			return ret_val;</a>
<a name="ln2907">		hw-&gt;phy.ops.read_reg(hw, PHY_REG(776, 20), &amp;data);</a>
<a name="ln2908">		data &amp;= ~(0x3FF &lt;&lt; 2);</a>
<a name="ln2909">		data |= (0x8 &lt;&lt; 2);</a>
<a name="ln2910">		ret_val = hw-&gt;phy.ops.write_reg(hw, PHY_REG(776, 20), data);</a>
<a name="ln2911">		if (ret_val)</a>
<a name="ln2912">			return ret_val;</a>
<a name="ln2913">		ret_val = hw-&gt;phy.ops.write_reg(hw, PHY_REG(776, 23), 0x7E00);</a>
<a name="ln2914">		if (ret_val)</a>
<a name="ln2915">			return ret_val;</a>
<a name="ln2916">		hw-&gt;phy.ops.read_reg(hw, HV_PM_CTRL, &amp;data);</a>
<a name="ln2917">		ret_val = hw-&gt;phy.ops.write_reg(hw, HV_PM_CTRL, data &amp;</a>
<a name="ln2918">						~(1 &lt;&lt; 10));</a>
<a name="ln2919">		if (ret_val)</a>
<a name="ln2920">			return ret_val;</a>
<a name="ln2921">	}</a>
<a name="ln2922"> </a>
<a name="ln2923">	/* re-enable Rx path after enabling/disabling workaround */</a>
<a name="ln2924">	return hw-&gt;phy.ops.write_reg(hw, PHY_REG(769, 20), phy_reg &amp;</a>
<a name="ln2925">				     ~(1 &lt;&lt; 14));</a>
<a name="ln2926">}</a>
<a name="ln2927"> </a>
<a name="ln2928">/**</a>
<a name="ln2929"> *  e1000_lv_phy_workarounds_ich8lan - A series of Phy workarounds to be</a>
<a name="ln2930"> *  done after every PHY reset.</a>
<a name="ln2931"> **/</a>
<a name="ln2932">static s32 e1000_lv_phy_workarounds_ich8lan(struct e1000_hw *hw)</a>
<a name="ln2933">{</a>
<a name="ln2934">	s32 ret_val = E1000_SUCCESS;</a>
<a name="ln2935"> </a>
<a name="ln2936">	DEBUGFUNC(&quot;e1000_lv_phy_workarounds_ich8lan&quot;);</a>
<a name="ln2937"> </a>
<a name="ln2938">	if (hw-&gt;mac.type != e1000_pch2lan)</a>
<a name="ln2939">		return E1000_SUCCESS;</a>
<a name="ln2940"> </a>
<a name="ln2941">	/* Set MDIO slow mode before any other MDIO access */</a>
<a name="ln2942">	ret_val = e1000_set_mdio_slow_mode_hv(hw);</a>
<a name="ln2943">	if (ret_val)</a>
<a name="ln2944">		return ret_val;</a>
<a name="ln2945"> </a>
<a name="ln2946">	ret_val = hw-&gt;phy.ops.acquire(hw);</a>
<a name="ln2947">	if (ret_val)</a>
<a name="ln2948">		return ret_val;</a>
<a name="ln2949">	/* set MSE higher to enable link to stay up when noise is high */</a>
<a name="ln2950">	ret_val = e1000_write_emi_reg_locked(hw, I82579_MSE_THRESHOLD, 0x0034);</a>
<a name="ln2951">	if (ret_val)</a>
<a name="ln2952">		goto release;</a>
<a name="ln2953">	/* drop link after 5 times MSE threshold was reached */</a>
<a name="ln2954">	ret_val = e1000_write_emi_reg_locked(hw, I82579_MSE_LINK_DOWN, 0x0005);</a>
<a name="ln2955">release:</a>
<a name="ln2956">	hw-&gt;phy.ops.release(hw);</a>
<a name="ln2957"> </a>
<a name="ln2958">	return ret_val;</a>
<a name="ln2959">}</a>
<a name="ln2960"> </a>
<a name="ln2961">/**</a>
<a name="ln2962"> *  e1000_k1_gig_workaround_lv - K1 Si workaround</a>
<a name="ln2963"> *  @hw:   pointer to the HW structure</a>
<a name="ln2964"> *</a>
<a name="ln2965"> *  Workaround to set the K1 beacon duration for 82579 parts in 10Mbps</a>
<a name="ln2966"> *  Disable K1 for 1000 and 100 speeds</a>
<a name="ln2967"> **/</a>
<a name="ln2968">static s32 e1000_k1_workaround_lv(struct e1000_hw *hw)</a>
<a name="ln2969">{</a>
<a name="ln2970">	s32 ret_val = E1000_SUCCESS;</a>
<a name="ln2971">	u16 status_reg = 0;</a>
<a name="ln2972"> </a>
<a name="ln2973">	DEBUGFUNC(&quot;e1000_k1_workaround_lv&quot;);</a>
<a name="ln2974"> </a>
<a name="ln2975">	if (hw-&gt;mac.type != e1000_pch2lan)</a>
<a name="ln2976">		return E1000_SUCCESS;</a>
<a name="ln2977"> </a>
<a name="ln2978">	/* Set K1 beacon duration based on 10Mbs speed */</a>
<a name="ln2979">	ret_val = hw-&gt;phy.ops.read_reg(hw, HV_M_STATUS, &amp;status_reg);</a>
<a name="ln2980">	if (ret_val)</a>
<a name="ln2981">		return ret_val;</a>
<a name="ln2982"> </a>
<a name="ln2983">	if ((status_reg &amp; (HV_M_STATUS_LINK_UP | HV_M_STATUS_AUTONEG_COMPLETE))</a>
<a name="ln2984">	    == (HV_M_STATUS_LINK_UP | HV_M_STATUS_AUTONEG_COMPLETE)) {</a>
<a name="ln2985">		if (status_reg &amp;</a>
<a name="ln2986">		    (HV_M_STATUS_SPEED_1000 | HV_M_STATUS_SPEED_100)) {</a>
<a name="ln2987">			u16 pm_phy_reg;</a>
<a name="ln2988"> </a>
<a name="ln2989">			/* LV 1G/100 Packet drop issue wa  */</a>
<a name="ln2990">			ret_val = hw-&gt;phy.ops.read_reg(hw, HV_PM_CTRL,</a>
<a name="ln2991">						       &amp;pm_phy_reg);</a>
<a name="ln2992">			if (ret_val)</a>
<a name="ln2993">				return ret_val;</a>
<a name="ln2994">			pm_phy_reg &amp;= ~HV_PM_CTRL_K1_ENABLE;</a>
<a name="ln2995">			ret_val = hw-&gt;phy.ops.write_reg(hw, HV_PM_CTRL,</a>
<a name="ln2996">							pm_phy_reg);</a>
<a name="ln2997">			if (ret_val)</a>
<a name="ln2998">				return ret_val;</a>
<a name="ln2999">		} else {</a>
<a name="ln3000">			u32 mac_reg;</a>
<a name="ln3001">			mac_reg = E1000_READ_REG(hw, E1000_FEXTNVM4);</a>
<a name="ln3002">			mac_reg &amp;= ~E1000_FEXTNVM4_BEACON_DURATION_MASK;</a>
<a name="ln3003">			mac_reg |= E1000_FEXTNVM4_BEACON_DURATION_16USEC;</a>
<a name="ln3004">			E1000_WRITE_REG(hw, E1000_FEXTNVM4, mac_reg);</a>
<a name="ln3005">		}</a>
<a name="ln3006">	}</a>
<a name="ln3007"> </a>
<a name="ln3008">	return ret_val;</a>
<a name="ln3009">}</a>
<a name="ln3010"> </a>
<a name="ln3011">/**</a>
<a name="ln3012"> *  e1000_gate_hw_phy_config_ich8lan - disable PHY config via hardware</a>
<a name="ln3013"> *  @hw:   pointer to the HW structure</a>
<a name="ln3014"> *  @gate: boolean set to TRUE to gate, FALSE to ungate</a>
<a name="ln3015"> *</a>
<a name="ln3016"> *  Gate/ungate the automatic PHY configuration via hardware; perform</a>
<a name="ln3017"> *  the configuration via software instead.</a>
<a name="ln3018"> **/</a>
<a name="ln3019">static void e1000_gate_hw_phy_config_ich8lan(struct e1000_hw *hw, bool gate)</a>
<a name="ln3020">{</a>
<a name="ln3021">	u32 extcnf_ctrl;</a>
<a name="ln3022"> </a>
<a name="ln3023">	DEBUGFUNC(&quot;e1000_gate_hw_phy_config_ich8lan&quot;);</a>
<a name="ln3024"> </a>
<a name="ln3025">	if (hw-&gt;mac.type &lt; e1000_pch2lan)</a>
<a name="ln3026">		return;</a>
<a name="ln3027"> </a>
<a name="ln3028">	extcnf_ctrl = E1000_READ_REG(hw, E1000_EXTCNF_CTRL);</a>
<a name="ln3029"> </a>
<a name="ln3030">	if (gate)</a>
<a name="ln3031">		extcnf_ctrl |= E1000_EXTCNF_CTRL_GATE_PHY_CFG;</a>
<a name="ln3032">	else</a>
<a name="ln3033">		extcnf_ctrl &amp;= ~E1000_EXTCNF_CTRL_GATE_PHY_CFG;</a>
<a name="ln3034"> </a>
<a name="ln3035">	E1000_WRITE_REG(hw, E1000_EXTCNF_CTRL, extcnf_ctrl);</a>
<a name="ln3036">}</a>
<a name="ln3037"> </a>
<a name="ln3038">/**</a>
<a name="ln3039"> *  e1000_lan_init_done_ich8lan - Check for PHY config completion</a>
<a name="ln3040"> *  @hw: pointer to the HW structure</a>
<a name="ln3041"> *</a>
<a name="ln3042"> *  Check the appropriate indication the MAC has finished configuring the</a>
<a name="ln3043"> *  PHY after a software reset.</a>
<a name="ln3044"> **/</a>
<a name="ln3045">static void e1000_lan_init_done_ich8lan(struct e1000_hw *hw)</a>
<a name="ln3046">{</a>
<a name="ln3047">	u32 data, loop = E1000_ICH8_LAN_INIT_TIMEOUT;</a>
<a name="ln3048"> </a>
<a name="ln3049">	DEBUGFUNC(&quot;e1000_lan_init_done_ich8lan&quot;);</a>
<a name="ln3050"> </a>
<a name="ln3051">	/* Wait for basic configuration completes before proceeding */</a>
<a name="ln3052">	do {</a>
<a name="ln3053">		data = E1000_READ_REG(hw, E1000_STATUS);</a>
<a name="ln3054">		data &amp;= E1000_STATUS_LAN_INIT_DONE;</a>
<a name="ln3055">		usec_delay(100);</a>
<a name="ln3056">	} while ((!data) &amp;&amp; --loop);</a>
<a name="ln3057"> </a>
<a name="ln3058">	/* If basic configuration is incomplete before the above loop</a>
<a name="ln3059">	 * count reaches 0, loading the configuration from NVM will</a>
<a name="ln3060">	 * leave the PHY in a bad state possibly resulting in no link.</a>
<a name="ln3061">	 */</a>
<a name="ln3062">	if (loop == 0)</a>
<a name="ln3063">		DEBUGOUT(&quot;LAN_INIT_DONE not set, increase timeout\n&quot;);</a>
<a name="ln3064"> </a>
<a name="ln3065">	/* Clear the Init Done bit for the next init event */</a>
<a name="ln3066">	data = E1000_READ_REG(hw, E1000_STATUS);</a>
<a name="ln3067">	data &amp;= ~E1000_STATUS_LAN_INIT_DONE;</a>
<a name="ln3068">	E1000_WRITE_REG(hw, E1000_STATUS, data);</a>
<a name="ln3069">}</a>
<a name="ln3070"> </a>
<a name="ln3071">/**</a>
<a name="ln3072"> *  e1000_post_phy_reset_ich8lan - Perform steps required after a PHY reset</a>
<a name="ln3073"> *  @hw: pointer to the HW structure</a>
<a name="ln3074"> **/</a>
<a name="ln3075">static s32 e1000_post_phy_reset_ich8lan(struct e1000_hw *hw)</a>
<a name="ln3076">{</a>
<a name="ln3077">	s32 ret_val = E1000_SUCCESS;</a>
<a name="ln3078">	u16 reg;</a>
<a name="ln3079"> </a>
<a name="ln3080">	DEBUGFUNC(&quot;e1000_post_phy_reset_ich8lan&quot;);</a>
<a name="ln3081"> </a>
<a name="ln3082">	if (hw-&gt;phy.ops.check_reset_block(hw))</a>
<a name="ln3083">		return E1000_SUCCESS;</a>
<a name="ln3084"> </a>
<a name="ln3085">	/* Allow time for h/w to get to quiescent state after reset */</a>
<a name="ln3086">	msec_delay(10);</a>
<a name="ln3087"> </a>
<a name="ln3088">	/* Perform any necessary post-reset workarounds */</a>
<a name="ln3089">	switch (hw-&gt;mac.type) {</a>
<a name="ln3090">	case e1000_pchlan:</a>
<a name="ln3091">		ret_val = e1000_hv_phy_workarounds_ich8lan(hw);</a>
<a name="ln3092">		if (ret_val)</a>
<a name="ln3093">			return ret_val;</a>
<a name="ln3094">		break;</a>
<a name="ln3095">	case e1000_pch2lan:</a>
<a name="ln3096">		ret_val = e1000_lv_phy_workarounds_ich8lan(hw);</a>
<a name="ln3097">		if (ret_val)</a>
<a name="ln3098">			return ret_val;</a>
<a name="ln3099">		break;</a>
<a name="ln3100">	default:</a>
<a name="ln3101">		break;</a>
<a name="ln3102">	}</a>
<a name="ln3103"> </a>
<a name="ln3104">	/* Clear the host wakeup bit after lcd reset */</a>
<a name="ln3105">	if (hw-&gt;mac.type &gt;= e1000_pchlan) {</a>
<a name="ln3106">		hw-&gt;phy.ops.read_reg(hw, BM_PORT_GEN_CFG, &amp;reg);</a>
<a name="ln3107">		reg &amp;= ~BM_WUC_HOST_WU_BIT;</a>
<a name="ln3108">		hw-&gt;phy.ops.write_reg(hw, BM_PORT_GEN_CFG, reg);</a>
<a name="ln3109">	}</a>
<a name="ln3110"> </a>
<a name="ln3111">	/* Configure the LCD with the extended configuration region in NVM */</a>
<a name="ln3112">	ret_val = e1000_sw_lcd_config_ich8lan(hw);</a>
<a name="ln3113">	if (ret_val)</a>
<a name="ln3114">		return ret_val;</a>
<a name="ln3115"> </a>
<a name="ln3116">	/* Configure the LCD with the OEM bits in NVM */</a>
<a name="ln3117">	ret_val = e1000_oem_bits_config_ich8lan(hw, TRUE);</a>
<a name="ln3118"> </a>
<a name="ln3119">	if (hw-&gt;mac.type == e1000_pch2lan) {</a>
<a name="ln3120">		/* Ungate automatic PHY configuration on non-managed 82579 */</a>
<a name="ln3121">		if (!(E1000_READ_REG(hw, E1000_FWSM) &amp;</a>
<a name="ln3122">		    E1000_ICH_FWSM_FW_VALID)) {</a>
<a name="ln3123">			msec_delay(10);</a>
<a name="ln3124">			e1000_gate_hw_phy_config_ich8lan(hw, FALSE);</a>
<a name="ln3125">		}</a>
<a name="ln3126"> </a>
<a name="ln3127">		/* Set EEE LPI Update Timer to 200usec */</a>
<a name="ln3128">		ret_val = hw-&gt;phy.ops.acquire(hw);</a>
<a name="ln3129">		if (ret_val)</a>
<a name="ln3130">			return ret_val;</a>
<a name="ln3131">		ret_val = e1000_write_emi_reg_locked(hw,</a>
<a name="ln3132">						     I82579_LPI_UPDATE_TIMER,</a>
<a name="ln3133">						     0x1387);</a>
<a name="ln3134">		hw-&gt;phy.ops.release(hw);</a>
<a name="ln3135">	}</a>
<a name="ln3136"> </a>
<a name="ln3137">	return ret_val;</a>
<a name="ln3138">}</a>
<a name="ln3139"> </a>
<a name="ln3140">/**</a>
<a name="ln3141"> *  e1000_phy_hw_reset_ich8lan - Performs a PHY reset</a>
<a name="ln3142"> *  @hw: pointer to the HW structure</a>
<a name="ln3143"> *</a>
<a name="ln3144"> *  Resets the PHY</a>
<a name="ln3145"> *  This is a function pointer entry point called by drivers</a>
<a name="ln3146"> *  or other shared routines.</a>
<a name="ln3147"> **/</a>
<a name="ln3148">static s32 e1000_phy_hw_reset_ich8lan(struct e1000_hw *hw)</a>
<a name="ln3149">{</a>
<a name="ln3150">	s32 ret_val = E1000_SUCCESS;</a>
<a name="ln3151"> </a>
<a name="ln3152">	DEBUGFUNC(&quot;e1000_phy_hw_reset_ich8lan&quot;);</a>
<a name="ln3153"> </a>
<a name="ln3154">	/* Gate automatic PHY configuration by hardware on non-managed 82579 */</a>
<a name="ln3155">	if ((hw-&gt;mac.type == e1000_pch2lan) &amp;&amp;</a>
<a name="ln3156">	    !(E1000_READ_REG(hw, E1000_FWSM) &amp; E1000_ICH_FWSM_FW_VALID))</a>
<a name="ln3157">		e1000_gate_hw_phy_config_ich8lan(hw, TRUE);</a>
<a name="ln3158"> </a>
<a name="ln3159">	ret_val = e1000_phy_hw_reset_generic(hw);</a>
<a name="ln3160">	if (ret_val)</a>
<a name="ln3161">		return ret_val;</a>
<a name="ln3162"> </a>
<a name="ln3163">	return e1000_post_phy_reset_ich8lan(hw);</a>
<a name="ln3164">}</a>
<a name="ln3165"> </a>
<a name="ln3166">/**</a>
<a name="ln3167"> *  e1000_set_lplu_state_pchlan - Set Low Power Link Up state</a>
<a name="ln3168"> *  @hw: pointer to the HW structure</a>
<a name="ln3169"> *  @active: TRUE to enable LPLU, FALSE to disable</a>
<a name="ln3170"> *</a>
<a name="ln3171"> *  Sets the LPLU state according to the active flag.  For PCH, if OEM write</a>
<a name="ln3172"> *  bit are disabled in the NVM, writing the LPLU bits in the MAC will not set</a>
<a name="ln3173"> *  the phy speed. This function will manually set the LPLU bit and restart</a>
<a name="ln3174"> *  auto-neg as hw would do. D3 and D0 LPLU will call the same function</a>
<a name="ln3175"> *  since it configures the same bit.</a>
<a name="ln3176"> **/</a>
<a name="ln3177">static s32 e1000_set_lplu_state_pchlan(struct e1000_hw *hw, bool active)</a>
<a name="ln3178">{</a>
<a name="ln3179">	s32 ret_val;</a>
<a name="ln3180">	u16 oem_reg;</a>
<a name="ln3181"> </a>
<a name="ln3182">	DEBUGFUNC(&quot;e1000_set_lplu_state_pchlan&quot;);</a>
<a name="ln3183">	ret_val = hw-&gt;phy.ops.read_reg(hw, HV_OEM_BITS, &amp;oem_reg);</a>
<a name="ln3184">	if (ret_val)</a>
<a name="ln3185">		return ret_val;</a>
<a name="ln3186"> </a>
<a name="ln3187">	if (active)</a>
<a name="ln3188">		oem_reg |= HV_OEM_BITS_LPLU;</a>
<a name="ln3189">	else</a>
<a name="ln3190">		oem_reg &amp;= ~HV_OEM_BITS_LPLU;</a>
<a name="ln3191"> </a>
<a name="ln3192">	if (!hw-&gt;phy.ops.check_reset_block(hw))</a>
<a name="ln3193">		oem_reg |= HV_OEM_BITS_RESTART_AN;</a>
<a name="ln3194"> </a>
<a name="ln3195">	return hw-&gt;phy.ops.write_reg(hw, HV_OEM_BITS, oem_reg);</a>
<a name="ln3196">}</a>
<a name="ln3197"> </a>
<a name="ln3198">/**</a>
<a name="ln3199"> *  e1000_set_d0_lplu_state_ich8lan - Set Low Power Linkup D0 state</a>
<a name="ln3200"> *  @hw: pointer to the HW structure</a>
<a name="ln3201"> *  @active: TRUE to enable LPLU, FALSE to disable</a>
<a name="ln3202"> *</a>
<a name="ln3203"> *  Sets the LPLU D0 state according to the active flag.  When</a>
<a name="ln3204"> *  activating LPLU this function also disables smart speed</a>
<a name="ln3205"> *  and vice versa.  LPLU will not be activated unless the</a>
<a name="ln3206"> *  device autonegotiation advertisement meets standards of</a>
<a name="ln3207"> *  either 10 or 10/100 or 10/100/1000 at all duplexes.</a>
<a name="ln3208"> *  This is a function pointer entry point only called by</a>
<a name="ln3209"> *  PHY setup routines.</a>
<a name="ln3210"> **/</a>
<a name="ln3211">static s32 e1000_set_d0_lplu_state_ich8lan(struct e1000_hw *hw, bool active)</a>
<a name="ln3212">{</a>
<a name="ln3213">	struct e1000_phy_info *phy = &amp;hw-&gt;phy;</a>
<a name="ln3214">	u32 phy_ctrl;</a>
<a name="ln3215">	s32 ret_val = E1000_SUCCESS;</a>
<a name="ln3216">	u16 data;</a>
<a name="ln3217"> </a>
<a name="ln3218">	DEBUGFUNC(&quot;e1000_set_d0_lplu_state_ich8lan&quot;);</a>
<a name="ln3219"> </a>
<a name="ln3220">	if (phy-&gt;type == e1000_phy_ife)</a>
<a name="ln3221">		return E1000_SUCCESS;</a>
<a name="ln3222"> </a>
<a name="ln3223">	phy_ctrl = E1000_READ_REG(hw, E1000_PHY_CTRL);</a>
<a name="ln3224"> </a>
<a name="ln3225">	if (active) {</a>
<a name="ln3226">		phy_ctrl |= E1000_PHY_CTRL_D0A_LPLU;</a>
<a name="ln3227">		E1000_WRITE_REG(hw, E1000_PHY_CTRL, phy_ctrl);</a>
<a name="ln3228"> </a>
<a name="ln3229">		if (phy-&gt;type != e1000_phy_igp_3)</a>
<a name="ln3230">			return E1000_SUCCESS;</a>
<a name="ln3231"> </a>
<a name="ln3232">		/* Call gig speed drop workaround on LPLU before accessing</a>
<a name="ln3233">		 * any PHY registers</a>
<a name="ln3234">		 */</a>
<a name="ln3235">		if (hw-&gt;mac.type == e1000_ich8lan)</a>
<a name="ln3236">			e1000_gig_downshift_workaround_ich8lan(hw);</a>
<a name="ln3237"> </a>
<a name="ln3238">		/* When LPLU is enabled, we should disable SmartSpeed */</a>
<a name="ln3239">		ret_val = phy-&gt;ops.read_reg(hw,</a>
<a name="ln3240">					    IGP01E1000_PHY_PORT_CONFIG,</a>
<a name="ln3241">					    &amp;data);</a>
<a name="ln3242">		if (ret_val)</a>
<a name="ln3243">			return ret_val;</a>
<a name="ln3244">		data &amp;= ~IGP01E1000_PSCFR_SMART_SPEED;</a>
<a name="ln3245">		ret_val = phy-&gt;ops.write_reg(hw,</a>
<a name="ln3246">					     IGP01E1000_PHY_PORT_CONFIG,</a>
<a name="ln3247">					     data);</a>
<a name="ln3248">		if (ret_val)</a>
<a name="ln3249">			return ret_val;</a>
<a name="ln3250">	} else {</a>
<a name="ln3251">		phy_ctrl &amp;= ~E1000_PHY_CTRL_D0A_LPLU;</a>
<a name="ln3252">		E1000_WRITE_REG(hw, E1000_PHY_CTRL, phy_ctrl);</a>
<a name="ln3253"> </a>
<a name="ln3254">		if (phy-&gt;type != e1000_phy_igp_3)</a>
<a name="ln3255">			return E1000_SUCCESS;</a>
<a name="ln3256"> </a>
<a name="ln3257">		/* LPLU and SmartSpeed are mutually exclusive.  LPLU is used</a>
<a name="ln3258">		 * during Dx states where the power conservation is most</a>
<a name="ln3259">		 * important.  During driver activity we should enable</a>
<a name="ln3260">		 * SmartSpeed, so performance is maintained.</a>
<a name="ln3261">		 */</a>
<a name="ln3262">		if (phy-&gt;smart_speed == e1000_smart_speed_on) {</a>
<a name="ln3263">			ret_val = phy-&gt;ops.read_reg(hw,</a>
<a name="ln3264">						    IGP01E1000_PHY_PORT_CONFIG,</a>
<a name="ln3265">						    &amp;data);</a>
<a name="ln3266">			if (ret_val)</a>
<a name="ln3267">				return ret_val;</a>
<a name="ln3268"> </a>
<a name="ln3269">			data |= IGP01E1000_PSCFR_SMART_SPEED;</a>
<a name="ln3270">			ret_val = phy-&gt;ops.write_reg(hw,</a>
<a name="ln3271">						     IGP01E1000_PHY_PORT_CONFIG,</a>
<a name="ln3272">						     data);</a>
<a name="ln3273">			if (ret_val)</a>
<a name="ln3274">				return ret_val;</a>
<a name="ln3275">		} else if (phy-&gt;smart_speed == e1000_smart_speed_off) {</a>
<a name="ln3276">			ret_val = phy-&gt;ops.read_reg(hw,</a>
<a name="ln3277">						    IGP01E1000_PHY_PORT_CONFIG,</a>
<a name="ln3278">						    &amp;data);</a>
<a name="ln3279">			if (ret_val)</a>
<a name="ln3280">				return ret_val;</a>
<a name="ln3281"> </a>
<a name="ln3282">			data &amp;= ~IGP01E1000_PSCFR_SMART_SPEED;</a>
<a name="ln3283">			ret_val = phy-&gt;ops.write_reg(hw,</a>
<a name="ln3284">						     IGP01E1000_PHY_PORT_CONFIG,</a>
<a name="ln3285">						     data);</a>
<a name="ln3286">			if (ret_val)</a>
<a name="ln3287">				return ret_val;</a>
<a name="ln3288">		}</a>
<a name="ln3289">	}</a>
<a name="ln3290"> </a>
<a name="ln3291">	return E1000_SUCCESS;</a>
<a name="ln3292">}</a>
<a name="ln3293"> </a>
<a name="ln3294">/**</a>
<a name="ln3295"> *  e1000_set_d3_lplu_state_ich8lan - Set Low Power Linkup D3 state</a>
<a name="ln3296"> *  @hw: pointer to the HW structure</a>
<a name="ln3297"> *  @active: TRUE to enable LPLU, FALSE to disable</a>
<a name="ln3298"> *</a>
<a name="ln3299"> *  Sets the LPLU D3 state according to the active flag.  When</a>
<a name="ln3300"> *  activating LPLU this function also disables smart speed</a>
<a name="ln3301"> *  and vice versa.  LPLU will not be activated unless the</a>
<a name="ln3302"> *  device autonegotiation advertisement meets standards of</a>
<a name="ln3303"> *  either 10 or 10/100 or 10/100/1000 at all duplexes.</a>
<a name="ln3304"> *  This is a function pointer entry point only called by</a>
<a name="ln3305"> *  PHY setup routines.</a>
<a name="ln3306"> **/</a>
<a name="ln3307">static s32 e1000_set_d3_lplu_state_ich8lan(struct e1000_hw *hw, bool active)</a>
<a name="ln3308">{</a>
<a name="ln3309">	struct e1000_phy_info *phy = &amp;hw-&gt;phy;</a>
<a name="ln3310">	u32 phy_ctrl;</a>
<a name="ln3311">	s32 ret_val = E1000_SUCCESS;</a>
<a name="ln3312">	u16 data;</a>
<a name="ln3313"> </a>
<a name="ln3314">	DEBUGFUNC(&quot;e1000_set_d3_lplu_state_ich8lan&quot;);</a>
<a name="ln3315"> </a>
<a name="ln3316">	phy_ctrl = E1000_READ_REG(hw, E1000_PHY_CTRL);</a>
<a name="ln3317"> </a>
<a name="ln3318">	if (!active) {</a>
<a name="ln3319">		phy_ctrl &amp;= ~E1000_PHY_CTRL_NOND0A_LPLU;</a>
<a name="ln3320">		E1000_WRITE_REG(hw, E1000_PHY_CTRL, phy_ctrl);</a>
<a name="ln3321"> </a>
<a name="ln3322">		if (phy-&gt;type != e1000_phy_igp_3)</a>
<a name="ln3323">			return E1000_SUCCESS;</a>
<a name="ln3324"> </a>
<a name="ln3325">		/* LPLU and SmartSpeed are mutually exclusive.  LPLU is used</a>
<a name="ln3326">		 * during Dx states where the power conservation is most</a>
<a name="ln3327">		 * important.  During driver activity we should enable</a>
<a name="ln3328">		 * SmartSpeed, so performance is maintained.</a>
<a name="ln3329">		 */</a>
<a name="ln3330">		if (phy-&gt;smart_speed == e1000_smart_speed_on) {</a>
<a name="ln3331">			ret_val = phy-&gt;ops.read_reg(hw,</a>
<a name="ln3332">						    IGP01E1000_PHY_PORT_CONFIG,</a>
<a name="ln3333">						    &amp;data);</a>
<a name="ln3334">			if (ret_val)</a>
<a name="ln3335">				return ret_val;</a>
<a name="ln3336"> </a>
<a name="ln3337">			data |= IGP01E1000_PSCFR_SMART_SPEED;</a>
<a name="ln3338">			ret_val = phy-&gt;ops.write_reg(hw,</a>
<a name="ln3339">						     IGP01E1000_PHY_PORT_CONFIG,</a>
<a name="ln3340">						     data);</a>
<a name="ln3341">			if (ret_val)</a>
<a name="ln3342">				return ret_val;</a>
<a name="ln3343">		} else if (phy-&gt;smart_speed == e1000_smart_speed_off) {</a>
<a name="ln3344">			ret_val = phy-&gt;ops.read_reg(hw,</a>
<a name="ln3345">						    IGP01E1000_PHY_PORT_CONFIG,</a>
<a name="ln3346">						    &amp;data);</a>
<a name="ln3347">			if (ret_val)</a>
<a name="ln3348">				return ret_val;</a>
<a name="ln3349"> </a>
<a name="ln3350">			data &amp;= ~IGP01E1000_PSCFR_SMART_SPEED;</a>
<a name="ln3351">			ret_val = phy-&gt;ops.write_reg(hw,</a>
<a name="ln3352">						     IGP01E1000_PHY_PORT_CONFIG,</a>
<a name="ln3353">						     data);</a>
<a name="ln3354">			if (ret_val)</a>
<a name="ln3355">				return ret_val;</a>
<a name="ln3356">		}</a>
<a name="ln3357">	} else if ((phy-&gt;autoneg_advertised == E1000_ALL_SPEED_DUPLEX) ||</a>
<a name="ln3358">		   (phy-&gt;autoneg_advertised == E1000_ALL_NOT_GIG) ||</a>
<a name="ln3359">		   (phy-&gt;autoneg_advertised == E1000_ALL_10_SPEED)) {</a>
<a name="ln3360">		phy_ctrl |= E1000_PHY_CTRL_NOND0A_LPLU;</a>
<a name="ln3361">		E1000_WRITE_REG(hw, E1000_PHY_CTRL, phy_ctrl);</a>
<a name="ln3362"> </a>
<a name="ln3363">		if (phy-&gt;type != e1000_phy_igp_3)</a>
<a name="ln3364">			return E1000_SUCCESS;</a>
<a name="ln3365"> </a>
<a name="ln3366">		/* Call gig speed drop workaround on LPLU before accessing</a>
<a name="ln3367">		 * any PHY registers</a>
<a name="ln3368">		 */</a>
<a name="ln3369">		if (hw-&gt;mac.type == e1000_ich8lan)</a>
<a name="ln3370">			e1000_gig_downshift_workaround_ich8lan(hw);</a>
<a name="ln3371"> </a>
<a name="ln3372">		/* When LPLU is enabled, we should disable SmartSpeed */</a>
<a name="ln3373">		ret_val = phy-&gt;ops.read_reg(hw,</a>
<a name="ln3374">					    IGP01E1000_PHY_PORT_CONFIG,</a>
<a name="ln3375">					    &amp;data);</a>
<a name="ln3376">		if (ret_val)</a>
<a name="ln3377">			return ret_val;</a>
<a name="ln3378"> </a>
<a name="ln3379">		data &amp;= ~IGP01E1000_PSCFR_SMART_SPEED;</a>
<a name="ln3380">		ret_val = phy-&gt;ops.write_reg(hw,</a>
<a name="ln3381">					     IGP01E1000_PHY_PORT_CONFIG,</a>
<a name="ln3382">					     data);</a>
<a name="ln3383">	}</a>
<a name="ln3384"> </a>
<a name="ln3385">	return ret_val;</a>
<a name="ln3386">}</a>
<a name="ln3387"> </a>
<a name="ln3388">/**</a>
<a name="ln3389"> *  e1000_valid_nvm_bank_detect_ich8lan - finds out the valid bank 0 or 1</a>
<a name="ln3390"> *  @hw: pointer to the HW structure</a>
<a name="ln3391"> *  @bank:  pointer to the variable that returns the active bank</a>
<a name="ln3392"> *</a>
<a name="ln3393"> *  Reads signature byte from the NVM using the flash access registers.</a>
<a name="ln3394"> *  Word 0x13 bits 15:14 = 10b indicate a valid signature for that bank.</a>
<a name="ln3395"> **/</a>
<a name="ln3396">static s32 e1000_valid_nvm_bank_detect_ich8lan(struct e1000_hw *hw, u32 *bank)</a>
<a name="ln3397">{</a>
<a name="ln3398">	u32 eecd;</a>
<a name="ln3399">	struct e1000_nvm_info *nvm = &amp;hw-&gt;nvm;</a>
<a name="ln3400">	u32 bank1_offset = nvm-&gt;flash_bank_size * sizeof(u16);</a>
<a name="ln3401">	u32 act_offset = E1000_ICH_NVM_SIG_WORD * 2 + 1;</a>
<a name="ln3402">	u32 nvm_dword = 0;</a>
<a name="ln3403">	u8 sig_byte = 0;</a>
<a name="ln3404">	s32 ret_val;</a>
<a name="ln3405"> </a>
<a name="ln3406">	DEBUGFUNC(&quot;e1000_valid_nvm_bank_detect_ich8lan&quot;);</a>
<a name="ln3407"> </a>
<a name="ln3408">	switch (hw-&gt;mac.type) {</a>
<a name="ln3409">	case e1000_pch_spt:</a>
<a name="ln3410">	case e1000_pch_cnp:</a>
<a name="ln3411">		bank1_offset = nvm-&gt;flash_bank_size;</a>
<a name="ln3412">		act_offset = E1000_ICH_NVM_SIG_WORD;</a>
<a name="ln3413"> </a>
<a name="ln3414">		/* set bank to 0 in case flash read fails */</a>
<a name="ln3415">		*bank = 0;</a>
<a name="ln3416"> </a>
<a name="ln3417">		/* Check bank 0 */</a>
<a name="ln3418">		ret_val = e1000_read_flash_dword_ich8lan(hw, act_offset,</a>
<a name="ln3419">							 &amp;nvm_dword);</a>
<a name="ln3420">		if (ret_val)</a>
<a name="ln3421">			return ret_val;</a>
<a name="ln3422">		sig_byte = (u8)((nvm_dword &amp; 0xFF00) &gt;&gt; 8);</a>
<a name="ln3423">		if ((sig_byte &amp; E1000_ICH_NVM_VALID_SIG_MASK) ==</a>
<a name="ln3424">		    E1000_ICH_NVM_SIG_VALUE) {</a>
<a name="ln3425">			*bank = 0;</a>
<a name="ln3426">			return E1000_SUCCESS;</a>
<a name="ln3427">		}</a>
<a name="ln3428"> </a>
<a name="ln3429">		/* Check bank 1 */</a>
<a name="ln3430">		ret_val = e1000_read_flash_dword_ich8lan(hw, act_offset +</a>
<a name="ln3431">							 bank1_offset,</a>
<a name="ln3432">							 &amp;nvm_dword);</a>
<a name="ln3433">		if (ret_val)</a>
<a name="ln3434">			return ret_val;</a>
<a name="ln3435">		sig_byte = (u8)((nvm_dword &amp; 0xFF00) &gt;&gt; 8);</a>
<a name="ln3436">		if ((sig_byte &amp; E1000_ICH_NVM_VALID_SIG_MASK) ==</a>
<a name="ln3437">		    E1000_ICH_NVM_SIG_VALUE) {</a>
<a name="ln3438">			*bank = 1;</a>
<a name="ln3439">			return E1000_SUCCESS;</a>
<a name="ln3440">		}</a>
<a name="ln3441"> </a>
<a name="ln3442">		DEBUGOUT(&quot;ERROR: No valid NVM bank present\n&quot;);</a>
<a name="ln3443">		return -E1000_ERR_NVM;</a>
<a name="ln3444">	case e1000_ich8lan:</a>
<a name="ln3445">	case e1000_ich9lan:</a>
<a name="ln3446">		eecd = E1000_READ_REG(hw, E1000_EECD);</a>
<a name="ln3447">		if ((eecd &amp; E1000_EECD_SEC1VAL_VALID_MASK) ==</a>
<a name="ln3448">		    E1000_EECD_SEC1VAL_VALID_MASK) {</a>
<a name="ln3449">			if (eecd &amp; E1000_EECD_SEC1VAL)</a>
<a name="ln3450">				*bank = 1;</a>
<a name="ln3451">			else</a>
<a name="ln3452">				*bank = 0;</a>
<a name="ln3453"> </a>
<a name="ln3454">			return E1000_SUCCESS;</a>
<a name="ln3455">		}</a>
<a name="ln3456">		DEBUGOUT(&quot;Unable to determine valid NVM bank via EEC - reading flash signature\n&quot;);</a>
<a name="ln3457">		/* fall-thru */</a>
<a name="ln3458">	default:</a>
<a name="ln3459">		/* set bank to 0 in case flash read fails */</a>
<a name="ln3460">		*bank = 0;</a>
<a name="ln3461"> </a>
<a name="ln3462">		/* Check bank 0 */</a>
<a name="ln3463">		ret_val = e1000_read_flash_byte_ich8lan(hw, act_offset,</a>
<a name="ln3464">							&amp;sig_byte);</a>
<a name="ln3465">		if (ret_val)</a>
<a name="ln3466">			return ret_val;</a>
<a name="ln3467">		if ((sig_byte &amp; E1000_ICH_NVM_VALID_SIG_MASK) ==</a>
<a name="ln3468">		    E1000_ICH_NVM_SIG_VALUE) {</a>
<a name="ln3469">			*bank = 0;</a>
<a name="ln3470">			return E1000_SUCCESS;</a>
<a name="ln3471">		}</a>
<a name="ln3472"> </a>
<a name="ln3473">		/* Check bank 1 */</a>
<a name="ln3474">		ret_val = e1000_read_flash_byte_ich8lan(hw, act_offset +</a>
<a name="ln3475">							bank1_offset,</a>
<a name="ln3476">							&amp;sig_byte);</a>
<a name="ln3477">		if (ret_val)</a>
<a name="ln3478">			return ret_val;</a>
<a name="ln3479">		if ((sig_byte &amp; E1000_ICH_NVM_VALID_SIG_MASK) ==</a>
<a name="ln3480">		    E1000_ICH_NVM_SIG_VALUE) {</a>
<a name="ln3481">			*bank = 1;</a>
<a name="ln3482">			return E1000_SUCCESS;</a>
<a name="ln3483">		}</a>
<a name="ln3484"> </a>
<a name="ln3485">		DEBUGOUT(&quot;ERROR: No valid NVM bank present\n&quot;);</a>
<a name="ln3486">		return -E1000_ERR_NVM;</a>
<a name="ln3487">	}</a>
<a name="ln3488">}</a>
<a name="ln3489"> </a>
<a name="ln3490">/**</a>
<a name="ln3491"> *  e1000_read_nvm_spt - NVM access for SPT</a>
<a name="ln3492"> *  @hw: pointer to the HW structure</a>
<a name="ln3493"> *  @offset: The offset (in bytes) of the word(s) to read.</a>
<a name="ln3494"> *  @words: Size of data to read in words.</a>
<a name="ln3495"> *  @data: pointer to the word(s) to read at offset.</a>
<a name="ln3496"> *</a>
<a name="ln3497"> *  Reads a word(s) from the NVM</a>
<a name="ln3498"> **/</a>
<a name="ln3499">static s32 e1000_read_nvm_spt(struct e1000_hw *hw, u16 offset, u16 words,</a>
<a name="ln3500">			      u16 *data)</a>
<a name="ln3501">{</a>
<a name="ln3502">	struct e1000_nvm_info *nvm = &amp;hw-&gt;nvm;</a>
<a name="ln3503">	struct e1000_dev_spec_ich8lan *dev_spec = &amp;hw-&gt;dev_spec.ich8lan;</a>
<a name="ln3504">	u32 act_offset;</a>
<a name="ln3505">	s32 ret_val = E1000_SUCCESS;</a>
<a name="ln3506">	u32 bank = 0;</a>
<a name="ln3507">	u32 dword = 0;</a>
<a name="ln3508">	u16 offset_to_read;</a>
<a name="ln3509">	u16 i;</a>
<a name="ln3510"> </a>
<a name="ln3511">	DEBUGFUNC(&quot;e1000_read_nvm_spt&quot;);</a>
<a name="ln3512"> </a>
<a name="ln3513">	if ((offset &gt;= nvm-&gt;word_size) || (words &gt; nvm-&gt;word_size - offset) ||</a>
<a name="ln3514">	    (words == 0)) {</a>
<a name="ln3515">		DEBUGOUT(&quot;nvm parameter(s) out of bounds\n&quot;);</a>
<a name="ln3516">		ret_val = -E1000_ERR_NVM;</a>
<a name="ln3517">		goto out;</a>
<a name="ln3518">	}</a>
<a name="ln3519"> </a>
<a name="ln3520">	nvm-&gt;ops.acquire(hw);</a>
<a name="ln3521"> </a>
<a name="ln3522">	ret_val = e1000_valid_nvm_bank_detect_ich8lan(hw, &amp;bank);</a>
<a name="ln3523">	if (ret_val != E1000_SUCCESS) {</a>
<a name="ln3524">		DEBUGOUT(&quot;Could not detect valid bank, assuming bank 0\n&quot;);</a>
<a name="ln3525">		bank = 0;</a>
<a name="ln3526">	}</a>
<a name="ln3527"> </a>
<a name="ln3528">	act_offset = (bank) ? nvm-&gt;flash_bank_size : 0;</a>
<a name="ln3529">	act_offset += offset;</a>
<a name="ln3530"> </a>
<a name="ln3531">	ret_val = E1000_SUCCESS;</a>
<a name="ln3532"> </a>
<a name="ln3533">	for (i = 0; i &lt; words; i += 2) {</a>
<a name="ln3534">		if (words - i == 1) {</a>
<a name="ln3535">			if (dev_spec-&gt;shadow_ram[offset+i].modified) {</a>
<a name="ln3536">				data[i] = dev_spec-&gt;shadow_ram[offset+i].value;</a>
<a name="ln3537">			} else {</a>
<a name="ln3538">				offset_to_read = act_offset + i -</a>
<a name="ln3539">						 ((act_offset + i) % 2);</a>
<a name="ln3540">				ret_val =</a>
<a name="ln3541">				   e1000_read_flash_dword_ich8lan(hw,</a>
<a name="ln3542">								 offset_to_read,</a>
<a name="ln3543">								 &amp;dword);</a>
<a name="ln3544">				if (ret_val)</a>
<a name="ln3545">					break;</a>
<a name="ln3546">				if ((act_offset + i) % 2 == 0)</a>
<a name="ln3547">					data[i] = (u16)(dword &amp; 0xFFFF);</a>
<a name="ln3548">				else</a>
<a name="ln3549">					data[i] = (u16)((dword &gt;&gt; 16) &amp; 0xFFFF);</a>
<a name="ln3550">			}</a>
<a name="ln3551">		} else {</a>
<a name="ln3552">			offset_to_read = act_offset + i;</a>
<a name="ln3553">			if (!(dev_spec-&gt;shadow_ram[offset+i].modified) ||</a>
<a name="ln3554">			    !(dev_spec-&gt;shadow_ram[offset+i+1].modified)) {</a>
<a name="ln3555">				ret_val =</a>
<a name="ln3556">				   e1000_read_flash_dword_ich8lan(hw,</a>
<a name="ln3557">								 offset_to_read,</a>
<a name="ln3558">								 &amp;dword);</a>
<a name="ln3559">				if (ret_val)</a>
<a name="ln3560">					break;</a>
<a name="ln3561">			}</a>
<a name="ln3562">			if (dev_spec-&gt;shadow_ram[offset+i].modified)</a>
<a name="ln3563">				data[i] = dev_spec-&gt;shadow_ram[offset+i].value;</a>
<a name="ln3564">			else</a>
<a name="ln3565">				data[i] = (u16) (dword &amp; 0xFFFF);</a>
<a name="ln3566">			if (dev_spec-&gt;shadow_ram[offset+i].modified)</a>
<a name="ln3567">				data[i+1] =</a>
<a name="ln3568">				   dev_spec-&gt;shadow_ram[offset+i+1].value;</a>
<a name="ln3569">			else</a>
<a name="ln3570">				data[i+1] = (u16) (dword &gt;&gt; 16 &amp; 0xFFFF);</a>
<a name="ln3571">		}</a>
<a name="ln3572">	}</a>
<a name="ln3573"> </a>
<a name="ln3574">	nvm-&gt;ops.release(hw);</a>
<a name="ln3575"> </a>
<a name="ln3576">out:</a>
<a name="ln3577">	if (ret_val)</a>
<a name="ln3578">		DEBUGOUT1(&quot;NVM read error: %d\n&quot;, ret_val);</a>
<a name="ln3579"> </a>
<a name="ln3580">	return ret_val;</a>
<a name="ln3581">}</a>
<a name="ln3582"> </a>
<a name="ln3583">/**</a>
<a name="ln3584"> *  e1000_read_nvm_ich8lan - Read word(s) from the NVM</a>
<a name="ln3585"> *  @hw: pointer to the HW structure</a>
<a name="ln3586"> *  @offset: The offset (in bytes) of the word(s) to read.</a>
<a name="ln3587"> *  @words: Size of data to read in words</a>
<a name="ln3588"> *  @data: Pointer to the word(s) to read at offset.</a>
<a name="ln3589"> *</a>
<a name="ln3590"> *  Reads a word(s) from the NVM using the flash access registers.</a>
<a name="ln3591"> **/</a>
<a name="ln3592">static s32 e1000_read_nvm_ich8lan(struct e1000_hw *hw, u16 offset, u16 words,</a>
<a name="ln3593">				  u16 *data)</a>
<a name="ln3594">{</a>
<a name="ln3595">	struct e1000_nvm_info *nvm = &amp;hw-&gt;nvm;</a>
<a name="ln3596">	struct e1000_dev_spec_ich8lan *dev_spec = &amp;hw-&gt;dev_spec.ich8lan;</a>
<a name="ln3597">	u32 act_offset;</a>
<a name="ln3598">	s32 ret_val = E1000_SUCCESS;</a>
<a name="ln3599">	u32 bank = 0;</a>
<a name="ln3600">	u16 i, word;</a>
<a name="ln3601"> </a>
<a name="ln3602">	DEBUGFUNC(&quot;e1000_read_nvm_ich8lan&quot;);</a>
<a name="ln3603"> </a>
<a name="ln3604">	if ((offset &gt;= nvm-&gt;word_size) || (words &gt; nvm-&gt;word_size - offset) ||</a>
<a name="ln3605">	    (words == 0)) {</a>
<a name="ln3606">		DEBUGOUT(&quot;nvm parameter(s) out of bounds\n&quot;);</a>
<a name="ln3607">		ret_val = -E1000_ERR_NVM;</a>
<a name="ln3608">		goto out;</a>
<a name="ln3609">	}</a>
<a name="ln3610"> </a>
<a name="ln3611">	nvm-&gt;ops.acquire(hw);</a>
<a name="ln3612"> </a>
<a name="ln3613">	ret_val = e1000_valid_nvm_bank_detect_ich8lan(hw, &amp;bank);</a>
<a name="ln3614">	if (ret_val != E1000_SUCCESS) {</a>
<a name="ln3615">		DEBUGOUT(&quot;Could not detect valid bank, assuming bank 0\n&quot;);</a>
<a name="ln3616">		bank = 0;</a>
<a name="ln3617">	}</a>
<a name="ln3618"> </a>
<a name="ln3619">	act_offset = (bank) ? nvm-&gt;flash_bank_size : 0;</a>
<a name="ln3620">	act_offset += offset;</a>
<a name="ln3621"> </a>
<a name="ln3622">	ret_val = E1000_SUCCESS;</a>
<a name="ln3623">	for (i = 0; i &lt; words; i++) {</a>
<a name="ln3624">		if (dev_spec-&gt;shadow_ram[offset+i].modified) {</a>
<a name="ln3625">			data[i] = dev_spec-&gt;shadow_ram[offset+i].value;</a>
<a name="ln3626">		} else {</a>
<a name="ln3627">			ret_val = e1000_read_flash_word_ich8lan(hw,</a>
<a name="ln3628">								act_offset + i,</a>
<a name="ln3629">								&amp;word);</a>
<a name="ln3630">			if (ret_val)</a>
<a name="ln3631">				break;</a>
<a name="ln3632">			data[i] = word;</a>
<a name="ln3633">		}</a>
<a name="ln3634">	}</a>
<a name="ln3635"> </a>
<a name="ln3636">	nvm-&gt;ops.release(hw);</a>
<a name="ln3637"> </a>
<a name="ln3638">out:</a>
<a name="ln3639">	if (ret_val)</a>
<a name="ln3640">		DEBUGOUT1(&quot;NVM read error: %d\n&quot;, ret_val);</a>
<a name="ln3641"> </a>
<a name="ln3642">	return ret_val;</a>
<a name="ln3643">}</a>
<a name="ln3644"> </a>
<a name="ln3645">/**</a>
<a name="ln3646"> *  e1000_flash_cycle_init_ich8lan - Initialize flash</a>
<a name="ln3647"> *  @hw: pointer to the HW structure</a>
<a name="ln3648"> *</a>
<a name="ln3649"> *  This function does initial flash setup so that a new read/write/erase cycle</a>
<a name="ln3650"> *  can be started.</a>
<a name="ln3651"> **/</a>
<a name="ln3652">static s32 e1000_flash_cycle_init_ich8lan(struct e1000_hw *hw)</a>
<a name="ln3653">{</a>
<a name="ln3654">	union ich8_hws_flash_status hsfsts;</a>
<a name="ln3655">	s32 ret_val = -E1000_ERR_NVM;</a>
<a name="ln3656"> </a>
<a name="ln3657">	DEBUGFUNC(&quot;e1000_flash_cycle_init_ich8lan&quot;);</a>
<a name="ln3658"> </a>
<a name="ln3659">	hsfsts.regval = E1000_READ_FLASH_REG16(hw, ICH_FLASH_HSFSTS);</a>
<a name="ln3660"> </a>
<a name="ln3661">	/* Check if the flash descriptor is valid */</a>
<a name="ln3662">	if (!hsfsts.hsf_status.fldesvalid) {</a>
<a name="ln3663">		DEBUGOUT(&quot;Flash descriptor invalid.  SW Sequencing must be used.\n&quot;);</a>
<a name="ln3664">		return -E1000_ERR_NVM;</a>
<a name="ln3665">	}</a>
<a name="ln3666"> </a>
<a name="ln3667">	/* Clear FCERR and DAEL in hw status by writing 1 */</a>
<a name="ln3668">	hsfsts.hsf_status.flcerr = 1;</a>
<a name="ln3669">	hsfsts.hsf_status.dael = 1;</a>
<a name="ln3670">	if (hw-&gt;mac.type &gt;= e1000_pch_spt)</a>
<a name="ln3671">		E1000_WRITE_FLASH_REG(hw, ICH_FLASH_HSFSTS,</a>
<a name="ln3672">				      hsfsts.regval &amp; 0xFFFF);</a>
<a name="ln3673">	else</a>
<a name="ln3674">		E1000_WRITE_FLASH_REG16(hw, ICH_FLASH_HSFSTS, hsfsts.regval);</a>
<a name="ln3675"> </a>
<a name="ln3676">	/* Either we should have a hardware SPI cycle in progress</a>
<a name="ln3677">	 * bit to check against, in order to start a new cycle or</a>
<a name="ln3678">	 * FDONE bit should be changed in the hardware so that it</a>
<a name="ln3679">	 * is 1 after hardware reset, which can then be used as an</a>
<a name="ln3680">	 * indication whether a cycle is in progress or has been</a>
<a name="ln3681">	 * completed.</a>
<a name="ln3682">	 */</a>
<a name="ln3683"> </a>
<a name="ln3684">	if (!hsfsts.hsf_status.flcinprog) {</a>
<a name="ln3685">		/* There is no cycle running at present,</a>
<a name="ln3686">		 * so we can start a cycle.</a>
<a name="ln3687">		 * Begin by setting Flash Cycle Done.</a>
<a name="ln3688">		 */</a>
<a name="ln3689">		hsfsts.hsf_status.flcdone = 1;</a>
<a name="ln3690">		if (hw-&gt;mac.type &gt;= e1000_pch_spt)</a>
<a name="ln3691">			E1000_WRITE_FLASH_REG(hw, ICH_FLASH_HSFSTS,</a>
<a name="ln3692">					      hsfsts.regval &amp; 0xFFFF);</a>
<a name="ln3693">		else</a>
<a name="ln3694">			E1000_WRITE_FLASH_REG16(hw, ICH_FLASH_HSFSTS,</a>
<a name="ln3695">						hsfsts.regval);</a>
<a name="ln3696">		ret_val = E1000_SUCCESS;</a>
<a name="ln3697">	} else {</a>
<a name="ln3698">		s32 i;</a>
<a name="ln3699"> </a>
<a name="ln3700">		/* Otherwise poll for sometime so the current</a>
<a name="ln3701">		 * cycle has a chance to end before giving up.</a>
<a name="ln3702">		 */</a>
<a name="ln3703">		for (i = 0; i &lt; ICH_FLASH_READ_COMMAND_TIMEOUT; i++) {</a>
<a name="ln3704">			hsfsts.regval = E1000_READ_FLASH_REG16(hw,</a>
<a name="ln3705">							      ICH_FLASH_HSFSTS);</a>
<a name="ln3706">			if (!hsfsts.hsf_status.flcinprog) {</a>
<a name="ln3707">				ret_val = E1000_SUCCESS;</a>
<a name="ln3708">				break;</a>
<a name="ln3709">			}</a>
<a name="ln3710">			usec_delay(1);</a>
<a name="ln3711">		}</a>
<a name="ln3712">		if (ret_val == E1000_SUCCESS) {</a>
<a name="ln3713">			/* Successful in waiting for previous cycle to timeout,</a>
<a name="ln3714">			 * now set the Flash Cycle Done.</a>
<a name="ln3715">			 */</a>
<a name="ln3716">			hsfsts.hsf_status.flcdone = 1;</a>
<a name="ln3717">			if (hw-&gt;mac.type &gt;= e1000_pch_spt)</a>
<a name="ln3718">				E1000_WRITE_FLASH_REG(hw, ICH_FLASH_HSFSTS,</a>
<a name="ln3719">						      hsfsts.regval &amp; 0xFFFF);</a>
<a name="ln3720">			else</a>
<a name="ln3721">				E1000_WRITE_FLASH_REG16(hw, ICH_FLASH_HSFSTS,</a>
<a name="ln3722">							hsfsts.regval);</a>
<a name="ln3723">		} else {</a>
<a name="ln3724">			DEBUGOUT(&quot;Flash controller busy, cannot get access\n&quot;);</a>
<a name="ln3725">		}</a>
<a name="ln3726">	}</a>
<a name="ln3727"> </a>
<a name="ln3728">	return ret_val;</a>
<a name="ln3729">}</a>
<a name="ln3730"> </a>
<a name="ln3731">/**</a>
<a name="ln3732"> *  e1000_flash_cycle_ich8lan - Starts flash cycle (read/write/erase)</a>
<a name="ln3733"> *  @hw: pointer to the HW structure</a>
<a name="ln3734"> *  @timeout: maximum time to wait for completion</a>
<a name="ln3735"> *</a>
<a name="ln3736"> *  This function starts a flash cycle and waits for its completion.</a>
<a name="ln3737"> **/</a>
<a name="ln3738">static s32 e1000_flash_cycle_ich8lan(struct e1000_hw *hw, u32 timeout)</a>
<a name="ln3739">{</a>
<a name="ln3740">	union ich8_hws_flash_ctrl hsflctl;</a>
<a name="ln3741">	union ich8_hws_flash_status hsfsts;</a>
<a name="ln3742">	u32 i = 0;</a>
<a name="ln3743"> </a>
<a name="ln3744">	DEBUGFUNC(&quot;e1000_flash_cycle_ich8lan&quot;);</a>
<a name="ln3745"> </a>
<a name="ln3746">	/* Start a cycle by writing 1 in Flash Cycle Go in Hw Flash Control */</a>
<a name="ln3747">	if (hw-&gt;mac.type &gt;= e1000_pch_spt)</a>
<a name="ln3748">		hsflctl.regval = E1000_READ_FLASH_REG(hw, ICH_FLASH_HSFSTS)&gt;&gt;16;</a>
<a name="ln3749">	else</a>
<a name="ln3750">		hsflctl.regval = E1000_READ_FLASH_REG16(hw, ICH_FLASH_HSFCTL);</a>
<a name="ln3751">	hsflctl.hsf_ctrl.flcgo = 1;</a>
<a name="ln3752"> </a>
<a name="ln3753">	if (hw-&gt;mac.type &gt;= e1000_pch_spt)</a>
<a name="ln3754">		E1000_WRITE_FLASH_REG(hw, ICH_FLASH_HSFSTS,</a>
<a name="ln3755">				      hsflctl.regval &lt;&lt; 16);</a>
<a name="ln3756">	else</a>
<a name="ln3757">		E1000_WRITE_FLASH_REG16(hw, ICH_FLASH_HSFCTL, hsflctl.regval);</a>
<a name="ln3758"> </a>
<a name="ln3759">	/* wait till FDONE bit is set to 1 */</a>
<a name="ln3760">	do {</a>
<a name="ln3761">		hsfsts.regval = E1000_READ_FLASH_REG16(hw, ICH_FLASH_HSFSTS);</a>
<a name="ln3762">		if (hsfsts.hsf_status.flcdone)</a>
<a name="ln3763">			break;</a>
<a name="ln3764">		usec_delay(1);</a>
<a name="ln3765">	} while (i++ &lt; timeout);</a>
<a name="ln3766"> </a>
<a name="ln3767">	if (hsfsts.hsf_status.flcdone &amp;&amp; !hsfsts.hsf_status.flcerr)</a>
<a name="ln3768">		return E1000_SUCCESS;</a>
<a name="ln3769"> </a>
<a name="ln3770">	return -E1000_ERR_NVM;</a>
<a name="ln3771">}</a>
<a name="ln3772"> </a>
<a name="ln3773">/**</a>
<a name="ln3774"> *  e1000_read_flash_dword_ich8lan - Read dword from flash</a>
<a name="ln3775"> *  @hw: pointer to the HW structure</a>
<a name="ln3776"> *  @offset: offset to data location</a>
<a name="ln3777"> *  @data: pointer to the location for storing the data</a>
<a name="ln3778"> *</a>
<a name="ln3779"> *  Reads the flash dword at offset into data.  Offset is converted</a>
<a name="ln3780"> *  to bytes before read.</a>
<a name="ln3781"> **/</a>
<a name="ln3782">static s32 e1000_read_flash_dword_ich8lan(struct e1000_hw *hw, u32 offset,</a>
<a name="ln3783">					  u32 *data)</a>
<a name="ln3784">{</a>
<a name="ln3785">	DEBUGFUNC(&quot;e1000_read_flash_dword_ich8lan&quot;);</a>
<a name="ln3786"> </a>
<a name="ln3787">	if (!data)</a>
<a name="ln3788">		return -E1000_ERR_NVM;</a>
<a name="ln3789"> </a>
<a name="ln3790">	/* Must convert word offset into bytes. */</a>
<a name="ln3791">	offset &lt;&lt;= 1;</a>
<a name="ln3792"> </a>
<a name="ln3793">	return e1000_read_flash_data32_ich8lan(hw, offset, data);</a>
<a name="ln3794">}</a>
<a name="ln3795"> </a>
<a name="ln3796">/**</a>
<a name="ln3797"> *  e1000_read_flash_word_ich8lan - Read word from flash</a>
<a name="ln3798"> *  @hw: pointer to the HW structure</a>
<a name="ln3799"> *  @offset: offset to data location</a>
<a name="ln3800"> *  @data: pointer to the location for storing the data</a>
<a name="ln3801"> *</a>
<a name="ln3802"> *  Reads the flash word at offset into data.  Offset is converted</a>
<a name="ln3803"> *  to bytes before read.</a>
<a name="ln3804"> **/</a>
<a name="ln3805">static s32 e1000_read_flash_word_ich8lan(struct e1000_hw *hw, u32 offset,</a>
<a name="ln3806">					 u16 *data)</a>
<a name="ln3807">{</a>
<a name="ln3808">	DEBUGFUNC(&quot;e1000_read_flash_word_ich8lan&quot;);</a>
<a name="ln3809"> </a>
<a name="ln3810">	if (!data)</a>
<a name="ln3811">		return -E1000_ERR_NVM;</a>
<a name="ln3812"> </a>
<a name="ln3813">	/* Must convert offset into bytes. */</a>
<a name="ln3814">	offset &lt;&lt;= 1;</a>
<a name="ln3815"> </a>
<a name="ln3816">	return e1000_read_flash_data_ich8lan(hw, offset, 2, data);</a>
<a name="ln3817">}</a>
<a name="ln3818"> </a>
<a name="ln3819">/**</a>
<a name="ln3820"> *  e1000_read_flash_byte_ich8lan - Read byte from flash</a>
<a name="ln3821"> *  @hw: pointer to the HW structure</a>
<a name="ln3822"> *  @offset: The offset of the byte to read.</a>
<a name="ln3823"> *  @data: Pointer to a byte to store the value read.</a>
<a name="ln3824"> *</a>
<a name="ln3825"> *  Reads a single byte from the NVM using the flash access registers.</a>
<a name="ln3826"> **/</a>
<a name="ln3827">static s32 e1000_read_flash_byte_ich8lan(struct e1000_hw *hw, u32 offset,</a>
<a name="ln3828">					 u8 *data)</a>
<a name="ln3829">{</a>
<a name="ln3830">	s32 ret_val;</a>
<a name="ln3831">	u16 word = 0;</a>
<a name="ln3832"> </a>
<a name="ln3833">	/* In SPT, only 32 bits access is supported,</a>
<a name="ln3834">	 * so this function should not be called.</a>
<a name="ln3835">	 */</a>
<a name="ln3836">	if (hw-&gt;mac.type &gt;= e1000_pch_spt)</a>
<a name="ln3837">		return -E1000_ERR_NVM;</a>
<a name="ln3838">	else</a>
<a name="ln3839">		ret_val = e1000_read_flash_data_ich8lan(hw, offset, 1, &amp;word);</a>
<a name="ln3840"> </a>
<a name="ln3841">	if (ret_val)</a>
<a name="ln3842">		return ret_val;</a>
<a name="ln3843"> </a>
<a name="ln3844">	*data = (u8)word;</a>
<a name="ln3845"> </a>
<a name="ln3846">	return E1000_SUCCESS;</a>
<a name="ln3847">}</a>
<a name="ln3848"> </a>
<a name="ln3849">/**</a>
<a name="ln3850"> *  e1000_read_flash_data_ich8lan - Read byte or word from NVM</a>
<a name="ln3851"> *  @hw: pointer to the HW structure</a>
<a name="ln3852"> *  @offset: The offset (in bytes) of the byte or word to read.</a>
<a name="ln3853"> *  @size: Size of data to read, 1=byte 2=word</a>
<a name="ln3854"> *  @data: Pointer to the word to store the value read.</a>
<a name="ln3855"> *</a>
<a name="ln3856"> *  Reads a byte or word from the NVM using the flash access registers.</a>
<a name="ln3857"> **/</a>
<a name="ln3858">static s32 e1000_read_flash_data_ich8lan(struct e1000_hw *hw, u32 offset,</a>
<a name="ln3859">					 u8 size, u16 *data)</a>
<a name="ln3860">{</a>
<a name="ln3861">	union ich8_hws_flash_status hsfsts;</a>
<a name="ln3862">	union ich8_hws_flash_ctrl hsflctl;</a>
<a name="ln3863">	u32 flash_linear_addr;</a>
<a name="ln3864">	u32 flash_data = 0;</a>
<a name="ln3865">	s32 ret_val = -E1000_ERR_NVM;</a>
<a name="ln3866">	u8 count = 0;</a>
<a name="ln3867"> </a>
<a name="ln3868">	DEBUGFUNC(&quot;e1000_read_flash_data_ich8lan&quot;);</a>
<a name="ln3869"> </a>
<a name="ln3870">	if (size &lt; 1 || size &gt; 2 || offset &gt; ICH_FLASH_LINEAR_ADDR_MASK)</a>
<a name="ln3871">		return -E1000_ERR_NVM;</a>
<a name="ln3872">	flash_linear_addr = ((ICH_FLASH_LINEAR_ADDR_MASK &amp; offset) +</a>
<a name="ln3873">			     hw-&gt;nvm.flash_base_addr);</a>
<a name="ln3874"> </a>
<a name="ln3875">	do {</a>
<a name="ln3876">		usec_delay(1);</a>
<a name="ln3877">		/* Steps */</a>
<a name="ln3878">		ret_val = e1000_flash_cycle_init_ich8lan(hw);</a>
<a name="ln3879">		if (ret_val != E1000_SUCCESS)</a>
<a name="ln3880">			break;</a>
<a name="ln3881">		hsflctl.regval = E1000_READ_FLASH_REG16(hw, ICH_FLASH_HSFCTL);</a>
<a name="ln3882"> </a>
<a name="ln3883">		/* 0b/1b corresponds to 1 or 2 byte size, respectively. */</a>
<a name="ln3884">		hsflctl.hsf_ctrl.fldbcount = size - 1;</a>
<a name="ln3885">		hsflctl.hsf_ctrl.flcycle = ICH_CYCLE_READ;</a>
<a name="ln3886">		E1000_WRITE_FLASH_REG16(hw, ICH_FLASH_HSFCTL, hsflctl.regval);</a>
<a name="ln3887">		E1000_WRITE_FLASH_REG(hw, ICH_FLASH_FADDR, flash_linear_addr);</a>
<a name="ln3888"> </a>
<a name="ln3889">		ret_val = e1000_flash_cycle_ich8lan(hw,</a>
<a name="ln3890">						ICH_FLASH_READ_COMMAND_TIMEOUT);</a>
<a name="ln3891"> </a>
<a name="ln3892">		/* Check if FCERR is set to 1, if set to 1, clear it</a>
<a name="ln3893">		 * and try the whole sequence a few more times, else</a>
<a name="ln3894">		 * read in (shift in) the Flash Data0, the order is</a>
<a name="ln3895">		 * least significant byte first msb to lsb</a>
<a name="ln3896">		 */</a>
<a name="ln3897">		if (ret_val == E1000_SUCCESS) {</a>
<a name="ln3898">			flash_data = E1000_READ_FLASH_REG(hw, ICH_FLASH_FDATA0);</a>
<a name="ln3899">			if (size == 1)</a>
<a name="ln3900">				*data = (u8)(flash_data &amp; 0x000000FF);</a>
<a name="ln3901">			else if (size == 2)</a>
<a name="ln3902">				*data = (u16)(flash_data &amp; 0x0000FFFF);</a>
<a name="ln3903">			break;</a>
<a name="ln3904">		} else {</a>
<a name="ln3905">			/* If we've gotten here, then things are probably</a>
<a name="ln3906">			 * completely hosed, but if the error condition is</a>
<a name="ln3907">			 * detected, it won't hurt to give it another try...</a>
<a name="ln3908">			 * ICH_FLASH_CYCLE_REPEAT_COUNT times.</a>
<a name="ln3909">			 */</a>
<a name="ln3910">			hsfsts.regval = E1000_READ_FLASH_REG16(hw,</a>
<a name="ln3911">							      ICH_FLASH_HSFSTS);</a>
<a name="ln3912">			if (hsfsts.hsf_status.flcerr) {</a>
<a name="ln3913">				/* Repeat for some time before giving up. */</a>
<a name="ln3914">				continue;</a>
<a name="ln3915">			} else if (!hsfsts.hsf_status.flcdone) {</a>
<a name="ln3916">				DEBUGOUT(&quot;Timeout error - flash cycle did not complete.\n&quot;);</a>
<a name="ln3917">				break;</a>
<a name="ln3918">			}</a>
<a name="ln3919">		}</a>
<a name="ln3920">	} while (count++ &lt; ICH_FLASH_CYCLE_REPEAT_COUNT);</a>
<a name="ln3921"> </a>
<a name="ln3922">	return ret_val;</a>
<a name="ln3923">}</a>
<a name="ln3924"> </a>
<a name="ln3925">/**</a>
<a name="ln3926"> *  e1000_read_flash_data32_ich8lan - Read dword from NVM</a>
<a name="ln3927"> *  @hw: pointer to the HW structure</a>
<a name="ln3928"> *  @offset: The offset (in bytes) of the dword to read.</a>
<a name="ln3929"> *  @data: Pointer to the dword to store the value read.</a>
<a name="ln3930"> *</a>
<a name="ln3931"> *  Reads a byte or word from the NVM using the flash access registers.</a>
<a name="ln3932"> **/</a>
<a name="ln3933">static s32 e1000_read_flash_data32_ich8lan(struct e1000_hw *hw, u32 offset,</a>
<a name="ln3934">					   u32 *data)</a>
<a name="ln3935">{</a>
<a name="ln3936">	union ich8_hws_flash_status hsfsts;</a>
<a name="ln3937">	union ich8_hws_flash_ctrl hsflctl;</a>
<a name="ln3938">	u32 flash_linear_addr;</a>
<a name="ln3939">	s32 ret_val = -E1000_ERR_NVM;</a>
<a name="ln3940">	u8 count = 0;</a>
<a name="ln3941"> </a>
<a name="ln3942">	DEBUGFUNC(&quot;e1000_read_flash_data_ich8lan&quot;);</a>
<a name="ln3943"> </a>
<a name="ln3944">		if (offset &gt; ICH_FLASH_LINEAR_ADDR_MASK ||</a>
<a name="ln3945">		    hw-&gt;mac.type &lt; e1000_pch_spt)</a>
<a name="ln3946">			return -E1000_ERR_NVM;</a>
<a name="ln3947">	flash_linear_addr = ((ICH_FLASH_LINEAR_ADDR_MASK &amp; offset) +</a>
<a name="ln3948">			     hw-&gt;nvm.flash_base_addr);</a>
<a name="ln3949"> </a>
<a name="ln3950">	do {</a>
<a name="ln3951">		usec_delay(1);</a>
<a name="ln3952">		/* Steps */</a>
<a name="ln3953">		ret_val = e1000_flash_cycle_init_ich8lan(hw);</a>
<a name="ln3954">		if (ret_val != E1000_SUCCESS)</a>
<a name="ln3955">			break;</a>
<a name="ln3956">		/* In SPT, This register is in Lan memory space, not flash.</a>
<a name="ln3957">		 * Therefore, only 32 bit access is supported</a>
<a name="ln3958">		 */</a>
<a name="ln3959">		hsflctl.regval = E1000_READ_FLASH_REG(hw, ICH_FLASH_HSFSTS)&gt;&gt;16;</a>
<a name="ln3960"> </a>
<a name="ln3961">		/* 0b/1b corresponds to 1 or 2 byte size, respectively. */</a>
<a name="ln3962">		hsflctl.hsf_ctrl.fldbcount = sizeof(u32) - 1;</a>
<a name="ln3963">		hsflctl.hsf_ctrl.flcycle = ICH_CYCLE_READ;</a>
<a name="ln3964">		/* In SPT, This register is in Lan memory space, not flash.</a>
<a name="ln3965">		 * Therefore, only 32 bit access is supported</a>
<a name="ln3966">		 */</a>
<a name="ln3967">		E1000_WRITE_FLASH_REG(hw, ICH_FLASH_HSFSTS,</a>
<a name="ln3968">				      (u32)hsflctl.regval &lt;&lt; 16);</a>
<a name="ln3969">		E1000_WRITE_FLASH_REG(hw, ICH_FLASH_FADDR, flash_linear_addr);</a>
<a name="ln3970"> </a>
<a name="ln3971">		ret_val = e1000_flash_cycle_ich8lan(hw,</a>
<a name="ln3972">						ICH_FLASH_READ_COMMAND_TIMEOUT);</a>
<a name="ln3973"> </a>
<a name="ln3974">		/* Check if FCERR is set to 1, if set to 1, clear it</a>
<a name="ln3975">		 * and try the whole sequence a few more times, else</a>
<a name="ln3976">		 * read in (shift in) the Flash Data0, the order is</a>
<a name="ln3977">		 * least significant byte first msb to lsb</a>
<a name="ln3978">		 */</a>
<a name="ln3979">		if (ret_val == E1000_SUCCESS) {</a>
<a name="ln3980">			*data = E1000_READ_FLASH_REG(hw, ICH_FLASH_FDATA0);</a>
<a name="ln3981">			break;</a>
<a name="ln3982">		} else {</a>
<a name="ln3983">			/* If we've gotten here, then things are probably</a>
<a name="ln3984">			 * completely hosed, but if the error condition is</a>
<a name="ln3985">			 * detected, it won't hurt to give it another try...</a>
<a name="ln3986">			 * ICH_FLASH_CYCLE_REPEAT_COUNT times.</a>
<a name="ln3987">			 */</a>
<a name="ln3988">			hsfsts.regval = E1000_READ_FLASH_REG16(hw,</a>
<a name="ln3989">							      ICH_FLASH_HSFSTS);</a>
<a name="ln3990">			if (hsfsts.hsf_status.flcerr) {</a>
<a name="ln3991">				/* Repeat for some time before giving up. */</a>
<a name="ln3992">				continue;</a>
<a name="ln3993">			} else if (!hsfsts.hsf_status.flcdone) {</a>
<a name="ln3994">				DEBUGOUT(&quot;Timeout error - flash cycle did not complete.\n&quot;);</a>
<a name="ln3995">				break;</a>
<a name="ln3996">			}</a>
<a name="ln3997">		}</a>
<a name="ln3998">	} while (count++ &lt; ICH_FLASH_CYCLE_REPEAT_COUNT);</a>
<a name="ln3999"> </a>
<a name="ln4000">	return ret_val;</a>
<a name="ln4001">}</a>
<a name="ln4002"> </a>
<a name="ln4003">/**</a>
<a name="ln4004"> *  e1000_write_nvm_ich8lan - Write word(s) to the NVM</a>
<a name="ln4005"> *  @hw: pointer to the HW structure</a>
<a name="ln4006"> *  @offset: The offset (in bytes) of the word(s) to write.</a>
<a name="ln4007"> *  @words: Size of data to write in words</a>
<a name="ln4008"> *  @data: Pointer to the word(s) to write at offset.</a>
<a name="ln4009"> *</a>
<a name="ln4010"> *  Writes a byte or word to the NVM using the flash access registers.</a>
<a name="ln4011"> **/</a>
<a name="ln4012">static s32 e1000_write_nvm_ich8lan(struct e1000_hw *hw, u16 offset, u16 words,</a>
<a name="ln4013">				   u16 *data)</a>
<a name="ln4014">{</a>
<a name="ln4015">	struct e1000_nvm_info *nvm = &amp;hw-&gt;nvm;</a>
<a name="ln4016">	struct e1000_dev_spec_ich8lan *dev_spec = &amp;hw-&gt;dev_spec.ich8lan;</a>
<a name="ln4017">	u16 i;</a>
<a name="ln4018"> </a>
<a name="ln4019">	DEBUGFUNC(&quot;e1000_write_nvm_ich8lan&quot;);</a>
<a name="ln4020"> </a>
<a name="ln4021">	if ((offset &gt;= nvm-&gt;word_size) || (words &gt; nvm-&gt;word_size - offset) ||</a>
<a name="ln4022">	    (words == 0)) {</a>
<a name="ln4023">		DEBUGOUT(&quot;nvm parameter(s) out of bounds\n&quot;);</a>
<a name="ln4024">		return -E1000_ERR_NVM;</a>
<a name="ln4025">	}</a>
<a name="ln4026"> </a>
<a name="ln4027">	nvm-&gt;ops.acquire(hw);</a>
<a name="ln4028"> </a>
<a name="ln4029">	for (i = 0; i &lt; words; i++) {</a>
<a name="ln4030">		dev_spec-&gt;shadow_ram[offset+i].modified = TRUE;</a>
<a name="ln4031">		dev_spec-&gt;shadow_ram[offset+i].value = data[i];</a>
<a name="ln4032">	}</a>
<a name="ln4033"> </a>
<a name="ln4034">	nvm-&gt;ops.release(hw);</a>
<a name="ln4035"> </a>
<a name="ln4036">	return E1000_SUCCESS;</a>
<a name="ln4037">}</a>
<a name="ln4038"> </a>
<a name="ln4039">/**</a>
<a name="ln4040"> *  e1000_update_nvm_checksum_spt - Update the checksum for NVM</a>
<a name="ln4041"> *  @hw: pointer to the HW structure</a>
<a name="ln4042"> *</a>
<a name="ln4043"> *  The NVM checksum is updated by calling the generic update_nvm_checksum,</a>
<a name="ln4044"> *  which writes the checksum to the shadow ram.  The changes in the shadow</a>
<a name="ln4045"> *  ram are then committed to the EEPROM by processing each bank at a time</a>
<a name="ln4046"> *  checking for the modified bit and writing only the pending changes.</a>
<a name="ln4047"> *  After a successful commit, the shadow ram is cleared and is ready for</a>
<a name="ln4048"> *  future writes.</a>
<a name="ln4049"> **/</a>
<a name="ln4050">static s32 e1000_update_nvm_checksum_spt(struct e1000_hw *hw)</a>
<a name="ln4051">{</a>
<a name="ln4052">	struct e1000_nvm_info *nvm = &amp;hw-&gt;nvm;</a>
<a name="ln4053">	struct e1000_dev_spec_ich8lan *dev_spec = &amp;hw-&gt;dev_spec.ich8lan;</a>
<a name="ln4054">	u32 i, act_offset, new_bank_offset, old_bank_offset, bank;</a>
<a name="ln4055">	s32 ret_val;</a>
<a name="ln4056">	u32 dword = 0;</a>
<a name="ln4057"> </a>
<a name="ln4058">	DEBUGFUNC(&quot;e1000_update_nvm_checksum_spt&quot;);</a>
<a name="ln4059"> </a>
<a name="ln4060">	ret_val = e1000_update_nvm_checksum_generic(hw);</a>
<a name="ln4061">	if (ret_val)</a>
<a name="ln4062">		goto out;</a>
<a name="ln4063"> </a>
<a name="ln4064">	if (nvm-&gt;type != e1000_nvm_flash_sw)</a>
<a name="ln4065">		goto out;</a>
<a name="ln4066"> </a>
<a name="ln4067">	nvm-&gt;ops.acquire(hw);</a>
<a name="ln4068"> </a>
<a name="ln4069">	/* We're writing to the opposite bank so if we're on bank 1,</a>
<a name="ln4070">	 * write to bank 0 etc.  We also need to erase the segment that</a>
<a name="ln4071">	 * is going to be written</a>
<a name="ln4072">	 */</a>
<a name="ln4073">	ret_val =  e1000_valid_nvm_bank_detect_ich8lan(hw, &amp;bank);</a>
<a name="ln4074">	if (ret_val != E1000_SUCCESS) {</a>
<a name="ln4075">		DEBUGOUT(&quot;Could not detect valid bank, assuming bank 0\n&quot;);</a>
<a name="ln4076">		bank = 0;</a>
<a name="ln4077">	}</a>
<a name="ln4078"> </a>
<a name="ln4079">	if (bank == 0) {</a>
<a name="ln4080">		new_bank_offset = nvm-&gt;flash_bank_size;</a>
<a name="ln4081">		old_bank_offset = 0;</a>
<a name="ln4082">		ret_val = e1000_erase_flash_bank_ich8lan(hw, 1);</a>
<a name="ln4083">		if (ret_val)</a>
<a name="ln4084">			goto release;</a>
<a name="ln4085">	} else {</a>
<a name="ln4086">		old_bank_offset = nvm-&gt;flash_bank_size;</a>
<a name="ln4087">		new_bank_offset = 0;</a>
<a name="ln4088">		ret_val = e1000_erase_flash_bank_ich8lan(hw, 0);</a>
<a name="ln4089">		if (ret_val)</a>
<a name="ln4090">			goto release;</a>
<a name="ln4091">	}</a>
<a name="ln4092">	for (i = 0; i &lt; E1000_SHADOW_RAM_WORDS; i += 2) {</a>
<a name="ln4093">		/* Determine whether to write the value stored</a>
<a name="ln4094">		 * in the other NVM bank or a modified value stored</a>
<a name="ln4095">		 * in the shadow RAM</a>
<a name="ln4096">		 */</a>
<a name="ln4097">		ret_val = e1000_read_flash_dword_ich8lan(hw,</a>
<a name="ln4098">							 i + old_bank_offset,</a>
<a name="ln4099">							 &amp;dword);</a>
<a name="ln4100"> </a>
<a name="ln4101">		if (dev_spec-&gt;shadow_ram[i].modified) {</a>
<a name="ln4102">			dword &amp;= 0xffff0000;</a>
<a name="ln4103">			dword |= (dev_spec-&gt;shadow_ram[i].value &amp; 0xffff);</a>
<a name="ln4104">		}</a>
<a name="ln4105">		if (dev_spec-&gt;shadow_ram[i + 1].modified) {</a>
<a name="ln4106">			dword &amp;= 0x0000ffff;</a>
<a name="ln4107">			dword |= ((dev_spec-&gt;shadow_ram[i + 1].value &amp; 0xffff)</a>
<a name="ln4108">				  &lt;&lt; 16);</a>
<a name="ln4109">		}</a>
<a name="ln4110">		if (ret_val)</a>
<a name="ln4111">			break;</a>
<a name="ln4112"> </a>
<a name="ln4113">		/* If the word is 0x13, then make sure the signature bits</a>
<a name="ln4114">		 * (15:14) are 11b until the commit has completed.</a>
<a name="ln4115">		 * This will allow us to write 10b which indicates the</a>
<a name="ln4116">		 * signature is valid.  We want to do this after the write</a>
<a name="ln4117">		 * has completed so that we don't mark the segment valid</a>
<a name="ln4118">		 * while the write is still in progress</a>
<a name="ln4119">		 */</a>
<a name="ln4120">		if (i == E1000_ICH_NVM_SIG_WORD - 1)</a>
<a name="ln4121">			dword |= E1000_ICH_NVM_SIG_MASK &lt;&lt; 16;</a>
<a name="ln4122"> </a>
<a name="ln4123">		/* Convert offset to bytes. */</a>
<a name="ln4124">		act_offset = (i + new_bank_offset) &lt;&lt; 1;</a>
<a name="ln4125"> </a>
<a name="ln4126">		usec_delay(100);</a>
<a name="ln4127"> </a>
<a name="ln4128">		/* Write the data to the new bank. Offset in words*/</a>
<a name="ln4129">		act_offset = i + new_bank_offset;</a>
<a name="ln4130">		ret_val = e1000_retry_write_flash_dword_ich8lan(hw, act_offset,</a>
<a name="ln4131">								dword);</a>
<a name="ln4132">		if (ret_val)</a>
<a name="ln4133">			break;</a>
<a name="ln4134">	 }</a>
<a name="ln4135"> </a>
<a name="ln4136">	/* Don't bother writing the segment valid bits if sector</a>
<a name="ln4137">	 * programming failed.</a>
<a name="ln4138">	 */</a>
<a name="ln4139">	if (ret_val) {</a>
<a name="ln4140">		DEBUGOUT(&quot;Flash commit failed.\n&quot;);</a>
<a name="ln4141">		goto release;</a>
<a name="ln4142">	}</a>
<a name="ln4143"> </a>
<a name="ln4144">	/* Finally validate the new segment by setting bit 15:14</a>
<a name="ln4145">	 * to 10b in word 0x13 , this can be done without an</a>
<a name="ln4146">	 * erase as well since these bits are 11 to start with</a>
<a name="ln4147">	 * and we need to change bit 14 to 0b</a>
<a name="ln4148">	 */</a>
<a name="ln4149">	act_offset = new_bank_offset + E1000_ICH_NVM_SIG_WORD;</a>
<a name="ln4150"> </a>
<a name="ln4151">	/*offset in words but we read dword*/</a>
<a name="ln4152">	--act_offset;</a>
<a name="ln4153">	ret_val = e1000_read_flash_dword_ich8lan(hw, act_offset, &amp;dword);</a>
<a name="ln4154"> </a>
<a name="ln4155">	if (ret_val)</a>
<a name="ln4156">		goto release;</a>
<a name="ln4157"> </a>
<a name="ln4158">	dword &amp;= 0xBFFFFFFF;</a>
<a name="ln4159">	ret_val = e1000_retry_write_flash_dword_ich8lan(hw, act_offset, dword);</a>
<a name="ln4160"> </a>
<a name="ln4161">	if (ret_val)</a>
<a name="ln4162">		goto release;</a>
<a name="ln4163"> </a>
<a name="ln4164">	/* And invalidate the previously valid segment by setting</a>
<a name="ln4165">	 * its signature word (0x13) high_byte to 0b. This can be</a>
<a name="ln4166">	 * done without an erase because flash erase sets all bits</a>
<a name="ln4167">	 * to 1's. We can write 1's to 0's without an erase</a>
<a name="ln4168">	 */</a>
<a name="ln4169">	act_offset = (old_bank_offset + E1000_ICH_NVM_SIG_WORD) * 2 + 1;</a>
<a name="ln4170"> </a>
<a name="ln4171">	/* offset in words but we read dword*/</a>
<a name="ln4172">	act_offset = old_bank_offset + E1000_ICH_NVM_SIG_WORD - 1;</a>
<a name="ln4173">	ret_val = e1000_read_flash_dword_ich8lan(hw, act_offset, &amp;dword);</a>
<a name="ln4174"> </a>
<a name="ln4175">	if (ret_val)</a>
<a name="ln4176">		goto release;</a>
<a name="ln4177"> </a>
<a name="ln4178">	dword &amp;= 0x00FFFFFF;</a>
<a name="ln4179">	ret_val = e1000_retry_write_flash_dword_ich8lan(hw, act_offset, dword);</a>
<a name="ln4180"> </a>
<a name="ln4181">	if (ret_val)</a>
<a name="ln4182">		goto release;</a>
<a name="ln4183"> </a>
<a name="ln4184">	/* Great!  Everything worked, we can now clear the cached entries. */</a>
<a name="ln4185">	for (i = 0; i &lt; E1000_SHADOW_RAM_WORDS; i++) {</a>
<a name="ln4186">		dev_spec-&gt;shadow_ram[i].modified = FALSE;</a>
<a name="ln4187">		dev_spec-&gt;shadow_ram[i].value = 0xFFFF;</a>
<a name="ln4188">	}</a>
<a name="ln4189"> </a>
<a name="ln4190">release:</a>
<a name="ln4191">	nvm-&gt;ops.release(hw);</a>
<a name="ln4192"> </a>
<a name="ln4193">	/* Reload the EEPROM, or else modifications will not appear</a>
<a name="ln4194">	 * until after the next adapter reset.</a>
<a name="ln4195">	 */</a>
<a name="ln4196">	if (!ret_val) {</a>
<a name="ln4197">		nvm-&gt;ops.reload(hw);</a>
<a name="ln4198">		msec_delay(10);</a>
<a name="ln4199">	}</a>
<a name="ln4200"> </a>
<a name="ln4201">out:</a>
<a name="ln4202">	if (ret_val)</a>
<a name="ln4203">		DEBUGOUT1(&quot;NVM update error: %d\n&quot;, ret_val);</a>
<a name="ln4204"> </a>
<a name="ln4205">	return ret_val;</a>
<a name="ln4206">}</a>
<a name="ln4207"> </a>
<a name="ln4208">/**</a>
<a name="ln4209"> *  e1000_update_nvm_checksum_ich8lan - Update the checksum for NVM</a>
<a name="ln4210"> *  @hw: pointer to the HW structure</a>
<a name="ln4211"> *</a>
<a name="ln4212"> *  The NVM checksum is updated by calling the generic update_nvm_checksum,</a>
<a name="ln4213"> *  which writes the checksum to the shadow ram.  The changes in the shadow</a>
<a name="ln4214"> *  ram are then committed to the EEPROM by processing each bank at a time</a>
<a name="ln4215"> *  checking for the modified bit and writing only the pending changes.</a>
<a name="ln4216"> *  After a successful commit, the shadow ram is cleared and is ready for</a>
<a name="ln4217"> *  future writes.</a>
<a name="ln4218"> **/</a>
<a name="ln4219">static s32 e1000_update_nvm_checksum_ich8lan(struct e1000_hw *hw)</a>
<a name="ln4220">{</a>
<a name="ln4221">	struct e1000_nvm_info *nvm = &amp;hw-&gt;nvm;</a>
<a name="ln4222">	struct e1000_dev_spec_ich8lan *dev_spec = &amp;hw-&gt;dev_spec.ich8lan;</a>
<a name="ln4223">	u32 i, act_offset, new_bank_offset, old_bank_offset, bank;</a>
<a name="ln4224">	s32 ret_val;</a>
<a name="ln4225">	u16 data = 0;</a>
<a name="ln4226"> </a>
<a name="ln4227">	DEBUGFUNC(&quot;e1000_update_nvm_checksum_ich8lan&quot;);</a>
<a name="ln4228"> </a>
<a name="ln4229">	ret_val = e1000_update_nvm_checksum_generic(hw);</a>
<a name="ln4230">	if (ret_val)</a>
<a name="ln4231">		goto out;</a>
<a name="ln4232"> </a>
<a name="ln4233">	if (nvm-&gt;type != e1000_nvm_flash_sw)</a>
<a name="ln4234">		goto out;</a>
<a name="ln4235"> </a>
<a name="ln4236">	nvm-&gt;ops.acquire(hw);</a>
<a name="ln4237"> </a>
<a name="ln4238">	/* We're writing to the opposite bank so if we're on bank 1,</a>
<a name="ln4239">	 * write to bank 0 etc.  We also need to erase the segment that</a>
<a name="ln4240">	 * is going to be written</a>
<a name="ln4241">	 */</a>
<a name="ln4242">	ret_val =  e1000_valid_nvm_bank_detect_ich8lan(hw, &amp;bank);</a>
<a name="ln4243">	if (ret_val != E1000_SUCCESS) {</a>
<a name="ln4244">		DEBUGOUT(&quot;Could not detect valid bank, assuming bank 0\n&quot;);</a>
<a name="ln4245">		bank = 0;</a>
<a name="ln4246">	}</a>
<a name="ln4247"> </a>
<a name="ln4248">	if (bank == 0) {</a>
<a name="ln4249">		new_bank_offset = nvm-&gt;flash_bank_size;</a>
<a name="ln4250">		old_bank_offset = 0;</a>
<a name="ln4251">		ret_val = e1000_erase_flash_bank_ich8lan(hw, 1);</a>
<a name="ln4252">		if (ret_val)</a>
<a name="ln4253">			goto release;</a>
<a name="ln4254">	} else {</a>
<a name="ln4255">		old_bank_offset = nvm-&gt;flash_bank_size;</a>
<a name="ln4256">		new_bank_offset = 0;</a>
<a name="ln4257">		ret_val = e1000_erase_flash_bank_ich8lan(hw, 0);</a>
<a name="ln4258">		if (ret_val)</a>
<a name="ln4259">			goto release;</a>
<a name="ln4260">	}</a>
<a name="ln4261">	for (i = 0; i &lt; E1000_SHADOW_RAM_WORDS; i++) {</a>
<a name="ln4262">		if (dev_spec-&gt;shadow_ram[i].modified) {</a>
<a name="ln4263">			data = dev_spec-&gt;shadow_ram[i].value;</a>
<a name="ln4264">		} else {</a>
<a name="ln4265">			ret_val = e1000_read_flash_word_ich8lan(hw, i +</a>
<a name="ln4266">								old_bank_offset,</a>
<a name="ln4267">								&amp;data);</a>
<a name="ln4268">			if (ret_val)</a>
<a name="ln4269">				break;</a>
<a name="ln4270">		}</a>
<a name="ln4271">		/* If the word is 0x13, then make sure the signature bits</a>
<a name="ln4272">		 * (15:14) are 11b until the commit has completed.</a>
<a name="ln4273">		 * This will allow us to write 10b which indicates the</a>
<a name="ln4274">		 * signature is valid.  We want to do this after the write</a>
<a name="ln4275">		 * has completed so that we don't mark the segment valid</a>
<a name="ln4276">		 * while the write is still in progress</a>
<a name="ln4277">		 */</a>
<a name="ln4278">		if (i == E1000_ICH_NVM_SIG_WORD)</a>
<a name="ln4279">			data |= E1000_ICH_NVM_SIG_MASK;</a>
<a name="ln4280"> </a>
<a name="ln4281">		/* Convert offset to bytes. */</a>
<a name="ln4282">		act_offset = (i + new_bank_offset) &lt;&lt; 1;</a>
<a name="ln4283"> </a>
<a name="ln4284">		usec_delay(100);</a>
<a name="ln4285"> </a>
<a name="ln4286">		/* Write the bytes to the new bank. */</a>
<a name="ln4287">		ret_val = e1000_retry_write_flash_byte_ich8lan(hw,</a>
<a name="ln4288">							       act_offset,</a>
<a name="ln4289">							       (u8)data);</a>
<a name="ln4290">		if (ret_val)</a>
<a name="ln4291">			break;</a>
<a name="ln4292"> </a>
<a name="ln4293">		usec_delay(100);</a>
<a name="ln4294">		ret_val = e1000_retry_write_flash_byte_ich8lan(hw,</a>
<a name="ln4295">							  act_offset + 1,</a>
<a name="ln4296">							  (u8)(data &gt;&gt; 8));</a>
<a name="ln4297">		if (ret_val)</a>
<a name="ln4298">			break;</a>
<a name="ln4299">	 }</a>
<a name="ln4300"> </a>
<a name="ln4301">	/* Don't bother writing the segment valid bits if sector</a>
<a name="ln4302">	 * programming failed.</a>
<a name="ln4303">	 */</a>
<a name="ln4304">	if (ret_val) {</a>
<a name="ln4305">		DEBUGOUT(&quot;Flash commit failed.\n&quot;);</a>
<a name="ln4306">		goto release;</a>
<a name="ln4307">	}</a>
<a name="ln4308"> </a>
<a name="ln4309">	/* Finally validate the new segment by setting bit 15:14</a>
<a name="ln4310">	 * to 10b in word 0x13 , this can be done without an</a>
<a name="ln4311">	 * erase as well since these bits are 11 to start with</a>
<a name="ln4312">	 * and we need to change bit 14 to 0b</a>
<a name="ln4313">	 */</a>
<a name="ln4314">	act_offset = new_bank_offset + E1000_ICH_NVM_SIG_WORD;</a>
<a name="ln4315">	ret_val = e1000_read_flash_word_ich8lan(hw, act_offset, &amp;data);</a>
<a name="ln4316">	if (ret_val)</a>
<a name="ln4317">		goto release;</a>
<a name="ln4318"> </a>
<a name="ln4319">	data &amp;= 0xBFFF;</a>
<a name="ln4320">	ret_val = e1000_retry_write_flash_byte_ich8lan(hw, act_offset * 2 + 1,</a>
<a name="ln4321">						       (u8)(data &gt;&gt; 8));</a>
<a name="ln4322">	if (ret_val)</a>
<a name="ln4323">		goto release;</a>
<a name="ln4324"> </a>
<a name="ln4325">	/* And invalidate the previously valid segment by setting</a>
<a name="ln4326">	 * its signature word (0x13) high_byte to 0b. This can be</a>
<a name="ln4327">	 * done without an erase because flash erase sets all bits</a>
<a name="ln4328">	 * to 1's. We can write 1's to 0's without an erase</a>
<a name="ln4329">	 */</a>
<a name="ln4330">	act_offset = (old_bank_offset + E1000_ICH_NVM_SIG_WORD) * 2 + 1;</a>
<a name="ln4331"> </a>
<a name="ln4332">	ret_val = e1000_retry_write_flash_byte_ich8lan(hw, act_offset, 0);</a>
<a name="ln4333"> </a>
<a name="ln4334">	if (ret_val)</a>
<a name="ln4335">		goto release;</a>
<a name="ln4336"> </a>
<a name="ln4337">	/* Great!  Everything worked, we can now clear the cached entries. */</a>
<a name="ln4338">	for (i = 0; i &lt; E1000_SHADOW_RAM_WORDS; i++) {</a>
<a name="ln4339">		dev_spec-&gt;shadow_ram[i].modified = FALSE;</a>
<a name="ln4340">		dev_spec-&gt;shadow_ram[i].value = 0xFFFF;</a>
<a name="ln4341">	}</a>
<a name="ln4342"> </a>
<a name="ln4343">release:</a>
<a name="ln4344">	nvm-&gt;ops.release(hw);</a>
<a name="ln4345"> </a>
<a name="ln4346">	/* Reload the EEPROM, or else modifications will not appear</a>
<a name="ln4347">	 * until after the next adapter reset.</a>
<a name="ln4348">	 */</a>
<a name="ln4349">	if (!ret_val) {</a>
<a name="ln4350">		nvm-&gt;ops.reload(hw);</a>
<a name="ln4351">		msec_delay(10);</a>
<a name="ln4352">	}</a>
<a name="ln4353"> </a>
<a name="ln4354">out:</a>
<a name="ln4355">	if (ret_val)</a>
<a name="ln4356">		DEBUGOUT1(&quot;NVM update error: %d\n&quot;, ret_val);</a>
<a name="ln4357"> </a>
<a name="ln4358">	return ret_val;</a>
<a name="ln4359">}</a>
<a name="ln4360"> </a>
<a name="ln4361">/**</a>
<a name="ln4362"> *  e1000_validate_nvm_checksum_ich8lan - Validate EEPROM checksum</a>
<a name="ln4363"> *  @hw: pointer to the HW structure</a>
<a name="ln4364"> *</a>
<a name="ln4365"> *  Check to see if checksum needs to be fixed by reading bit 6 in word 0x19.</a>
<a name="ln4366"> *  If the bit is 0, that the EEPROM had been modified, but the checksum was not</a>
<a name="ln4367"> *  calculated, in which case we need to calculate the checksum and set bit 6.</a>
<a name="ln4368"> **/</a>
<a name="ln4369">static s32 e1000_validate_nvm_checksum_ich8lan(struct e1000_hw *hw)</a>
<a name="ln4370">{</a>
<a name="ln4371">	s32 ret_val;</a>
<a name="ln4372">	u16 data;</a>
<a name="ln4373">	u16 word;</a>
<a name="ln4374">	u16 valid_csum_mask;</a>
<a name="ln4375"> </a>
<a name="ln4376">	DEBUGFUNC(&quot;e1000_validate_nvm_checksum_ich8lan&quot;);</a>
<a name="ln4377"> </a>
<a name="ln4378">	/* Read NVM and check Invalid Image CSUM bit.  If this bit is 0,</a>
<a name="ln4379">	 * the checksum needs to be fixed.  This bit is an indication that</a>
<a name="ln4380">	 * the NVM was prepared by OEM software and did not calculate</a>
<a name="ln4381">	 * the checksum...a likely scenario.</a>
<a name="ln4382">	 */</a>
<a name="ln4383">	switch (hw-&gt;mac.type) {</a>
<a name="ln4384">	case e1000_pch_lpt:</a>
<a name="ln4385">	case e1000_pch_spt:</a>
<a name="ln4386">	case e1000_pch_cnp:</a>
<a name="ln4387">		word = NVM_COMPAT;</a>
<a name="ln4388">		valid_csum_mask = NVM_COMPAT_VALID_CSUM;</a>
<a name="ln4389">		break;</a>
<a name="ln4390">	default:</a>
<a name="ln4391">		word = NVM_FUTURE_INIT_WORD1;</a>
<a name="ln4392">		valid_csum_mask = NVM_FUTURE_INIT_WORD1_VALID_CSUM;</a>
<a name="ln4393">		break;</a>
<a name="ln4394">	}</a>
<a name="ln4395"> </a>
<a name="ln4396">	ret_val = hw-&gt;nvm.ops.read(hw, word, 1, &amp;data);</a>
<a name="ln4397">	if (ret_val)</a>
<a name="ln4398">		return ret_val;</a>
<a name="ln4399"> </a>
<a name="ln4400">	if (!(data &amp; valid_csum_mask)) {</a>
<a name="ln4401">		data |= valid_csum_mask;</a>
<a name="ln4402">		ret_val = hw-&gt;nvm.ops.write(hw, word, 1, &amp;data);</a>
<a name="ln4403">		if (ret_val)</a>
<a name="ln4404">			return ret_val;</a>
<a name="ln4405">		ret_val = hw-&gt;nvm.ops.update(hw);</a>
<a name="ln4406">		if (ret_val)</a>
<a name="ln4407">			return ret_val;</a>
<a name="ln4408">	}</a>
<a name="ln4409"> </a>
<a name="ln4410">	return e1000_validate_nvm_checksum_generic(hw);</a>
<a name="ln4411">}</a>
<a name="ln4412"> </a>
<a name="ln4413">/**</a>
<a name="ln4414"> *  e1000_write_flash_data_ich8lan - Writes bytes to the NVM</a>
<a name="ln4415"> *  @hw: pointer to the HW structure</a>
<a name="ln4416"> *  @offset: The offset (in bytes) of the byte/word to read.</a>
<a name="ln4417"> *  @size: Size of data to read, 1=byte 2=word</a>
<a name="ln4418"> *  @data: The byte(s) to write to the NVM.</a>
<a name="ln4419"> *</a>
<a name="ln4420"> *  Writes one/two bytes to the NVM using the flash access registers.</a>
<a name="ln4421"> **/</a>
<a name="ln4422">static s32 e1000_write_flash_data_ich8lan(struct e1000_hw *hw, u32 offset,</a>
<a name="ln4423">					  u8 size, u16 data)</a>
<a name="ln4424">{</a>
<a name="ln4425">	union ich8_hws_flash_status hsfsts;</a>
<a name="ln4426">	union ich8_hws_flash_ctrl hsflctl;</a>
<a name="ln4427">	u32 flash_linear_addr;</a>
<a name="ln4428">	u32 flash_data = 0;</a>
<a name="ln4429">	s32 ret_val;</a>
<a name="ln4430">	u8 count = 0;</a>
<a name="ln4431"> </a>
<a name="ln4432">	DEBUGFUNC(&quot;e1000_write_ich8_data&quot;);</a>
<a name="ln4433"> </a>
<a name="ln4434">	if (hw-&gt;mac.type &gt;= e1000_pch_spt) {</a>
<a name="ln4435">		if (size != 4 || offset &gt; ICH_FLASH_LINEAR_ADDR_MASK)</a>
<a name="ln4436">			return -E1000_ERR_NVM;</a>
<a name="ln4437">	} else {</a>
<a name="ln4438">		if (size &lt; 1 || size &gt; 2 || offset &gt; ICH_FLASH_LINEAR_ADDR_MASK)</a>
<a name="ln4439">			return -E1000_ERR_NVM;</a>
<a name="ln4440">	}</a>
<a name="ln4441"> </a>
<a name="ln4442">	flash_linear_addr = ((ICH_FLASH_LINEAR_ADDR_MASK &amp; offset) +</a>
<a name="ln4443">			     hw-&gt;nvm.flash_base_addr);</a>
<a name="ln4444"> </a>
<a name="ln4445">	do {</a>
<a name="ln4446">		usec_delay(1);</a>
<a name="ln4447">		/* Steps */</a>
<a name="ln4448">		ret_val = e1000_flash_cycle_init_ich8lan(hw);</a>
<a name="ln4449">		if (ret_val != E1000_SUCCESS)</a>
<a name="ln4450">			break;</a>
<a name="ln4451">		/* In SPT, This register is in Lan memory space, not</a>
<a name="ln4452">		 * flash.  Therefore, only 32 bit access is supported</a>
<a name="ln4453">		 */</a>
<a name="ln4454">		if (hw-&gt;mac.type &gt;= e1000_pch_spt)</a>
<a name="ln4455">			hsflctl.regval =</a>
<a name="ln4456">			    E1000_READ_FLASH_REG(hw, ICH_FLASH_HSFSTS)&gt;&gt;16;</a>
<a name="ln4457">		else</a>
<a name="ln4458">			hsflctl.regval =</a>
<a name="ln4459">			    E1000_READ_FLASH_REG16(hw, ICH_FLASH_HSFCTL);</a>
<a name="ln4460"> </a>
<a name="ln4461">		/* 0b/1b corresponds to 1 or 2 byte size, respectively. */</a>
<a name="ln4462">		hsflctl.hsf_ctrl.fldbcount = size - 1;</a>
<a name="ln4463">		hsflctl.hsf_ctrl.flcycle = ICH_CYCLE_WRITE;</a>
<a name="ln4464">		/* In SPT, This register is in Lan memory space,</a>
<a name="ln4465">		 * not flash.  Therefore, only 32 bit access is</a>
<a name="ln4466">		 * supported</a>
<a name="ln4467">		 */</a>
<a name="ln4468">		if (hw-&gt;mac.type &gt;= e1000_pch_spt)</a>
<a name="ln4469">			E1000_WRITE_FLASH_REG(hw, ICH_FLASH_HSFSTS,</a>
<a name="ln4470">					      hsflctl.regval &lt;&lt; 16);</a>
<a name="ln4471">		else</a>
<a name="ln4472">			E1000_WRITE_FLASH_REG16(hw, ICH_FLASH_HSFCTL,</a>
<a name="ln4473">						hsflctl.regval);</a>
<a name="ln4474"> </a>
<a name="ln4475">		E1000_WRITE_FLASH_REG(hw, ICH_FLASH_FADDR, flash_linear_addr);</a>
<a name="ln4476"> </a>
<a name="ln4477">		if (size == 1)</a>
<a name="ln4478">			flash_data = (u32)data &amp; 0x00FF;</a>
<a name="ln4479">		else</a>
<a name="ln4480">			flash_data = (u32)data;</a>
<a name="ln4481"> </a>
<a name="ln4482">		E1000_WRITE_FLASH_REG(hw, ICH_FLASH_FDATA0, flash_data);</a>
<a name="ln4483"> </a>
<a name="ln4484">		/* check if FCERR is set to 1 , if set to 1, clear it</a>
<a name="ln4485">		 * and try the whole sequence a few more times else done</a>
<a name="ln4486">		 */</a>
<a name="ln4487">		ret_val =</a>
<a name="ln4488">		    e1000_flash_cycle_ich8lan(hw,</a>
<a name="ln4489">					      ICH_FLASH_WRITE_COMMAND_TIMEOUT);</a>
<a name="ln4490">		if (ret_val == E1000_SUCCESS)</a>
<a name="ln4491">			break;</a>
<a name="ln4492"> </a>
<a name="ln4493">		/* If we're here, then things are most likely</a>
<a name="ln4494">		 * completely hosed, but if the error condition</a>
<a name="ln4495">		 * is detected, it won't hurt to give it another</a>
<a name="ln4496">		 * try...ICH_FLASH_CYCLE_REPEAT_COUNT times.</a>
<a name="ln4497">		 */</a>
<a name="ln4498">		hsfsts.regval = E1000_READ_FLASH_REG16(hw, ICH_FLASH_HSFSTS);</a>
<a name="ln4499">		if (hsfsts.hsf_status.flcerr)</a>
<a name="ln4500">			/* Repeat for some time before giving up. */</a>
<a name="ln4501">			continue;</a>
<a name="ln4502">		if (!hsfsts.hsf_status.flcdone) {</a>
<a name="ln4503">			DEBUGOUT(&quot;Timeout error - flash cycle did not complete.\n&quot;);</a>
<a name="ln4504">			break;</a>
<a name="ln4505">		}</a>
<a name="ln4506">	} while (count++ &lt; ICH_FLASH_CYCLE_REPEAT_COUNT);</a>
<a name="ln4507"> </a>
<a name="ln4508">	return ret_val;</a>
<a name="ln4509">}</a>
<a name="ln4510"> </a>
<a name="ln4511">/**</a>
<a name="ln4512">*  e1000_write_flash_data32_ich8lan - Writes 4 bytes to the NVM</a>
<a name="ln4513">*  @hw: pointer to the HW structure</a>
<a name="ln4514">*  @offset: The offset (in bytes) of the dwords to read.</a>
<a name="ln4515">*  @data: The 4 bytes to write to the NVM.</a>
<a name="ln4516">*</a>
<a name="ln4517">*  Writes one/two/four bytes to the NVM using the flash access registers.</a>
<a name="ln4518">**/</a>
<a name="ln4519">static s32 e1000_write_flash_data32_ich8lan(struct e1000_hw *hw, u32 offset,</a>
<a name="ln4520">					    u32 data)</a>
<a name="ln4521">{</a>
<a name="ln4522">	union ich8_hws_flash_status hsfsts;</a>
<a name="ln4523">	union ich8_hws_flash_ctrl hsflctl;</a>
<a name="ln4524">	u32 flash_linear_addr;</a>
<a name="ln4525">	s32 ret_val;</a>
<a name="ln4526">	u8 count = 0;</a>
<a name="ln4527"> </a>
<a name="ln4528">	DEBUGFUNC(&quot;e1000_write_flash_data32_ich8lan&quot;);</a>
<a name="ln4529"> </a>
<a name="ln4530">	if (hw-&gt;mac.type &gt;= e1000_pch_spt) {</a>
<a name="ln4531">		if (offset &gt; ICH_FLASH_LINEAR_ADDR_MASK)</a>
<a name="ln4532">			return -E1000_ERR_NVM;</a>
<a name="ln4533">	}</a>
<a name="ln4534">	flash_linear_addr = ((ICH_FLASH_LINEAR_ADDR_MASK &amp; offset) +</a>
<a name="ln4535">			     hw-&gt;nvm.flash_base_addr);</a>
<a name="ln4536">	do {</a>
<a name="ln4537">		usec_delay(1);</a>
<a name="ln4538">		/* Steps */</a>
<a name="ln4539">		ret_val = e1000_flash_cycle_init_ich8lan(hw);</a>
<a name="ln4540">		if (ret_val != E1000_SUCCESS)</a>
<a name="ln4541">			break;</a>
<a name="ln4542"> </a>
<a name="ln4543">		/* In SPT, This register is in Lan memory space, not</a>
<a name="ln4544">		 * flash.  Therefore, only 32 bit access is supported</a>
<a name="ln4545">		 */</a>
<a name="ln4546">		if (hw-&gt;mac.type &gt;= e1000_pch_spt)</a>
<a name="ln4547">			hsflctl.regval = E1000_READ_FLASH_REG(hw,</a>
<a name="ln4548">							      ICH_FLASH_HSFSTS)</a>
<a name="ln4549">					 &gt;&gt; 16;</a>
<a name="ln4550">		else</a>
<a name="ln4551">			hsflctl.regval = E1000_READ_FLASH_REG16(hw,</a>
<a name="ln4552">							      ICH_FLASH_HSFCTL);</a>
<a name="ln4553"> </a>
<a name="ln4554">		hsflctl.hsf_ctrl.fldbcount = sizeof(u32) - 1;</a>
<a name="ln4555">		hsflctl.hsf_ctrl.flcycle = ICH_CYCLE_WRITE;</a>
<a name="ln4556"> </a>
<a name="ln4557">		/* In SPT, This register is in Lan memory space,</a>
<a name="ln4558">		 * not flash.  Therefore, only 32 bit access is</a>
<a name="ln4559">		 * supported</a>
<a name="ln4560">		 */</a>
<a name="ln4561">		if (hw-&gt;mac.type &gt;= e1000_pch_spt)</a>
<a name="ln4562">			E1000_WRITE_FLASH_REG(hw, ICH_FLASH_HSFSTS,</a>
<a name="ln4563">					      hsflctl.regval &lt;&lt; 16);</a>
<a name="ln4564">		else</a>
<a name="ln4565">			E1000_WRITE_FLASH_REG16(hw, ICH_FLASH_HSFCTL,</a>
<a name="ln4566">						hsflctl.regval);</a>
<a name="ln4567"> </a>
<a name="ln4568">		E1000_WRITE_FLASH_REG(hw, ICH_FLASH_FADDR, flash_linear_addr);</a>
<a name="ln4569"> </a>
<a name="ln4570">		E1000_WRITE_FLASH_REG(hw, ICH_FLASH_FDATA0, data);</a>
<a name="ln4571"> </a>
<a name="ln4572">		/* check if FCERR is set to 1 , if set to 1, clear it</a>
<a name="ln4573">		 * and try the whole sequence a few more times else done</a>
<a name="ln4574">		 */</a>
<a name="ln4575">		ret_val = e1000_flash_cycle_ich8lan(hw,</a>
<a name="ln4576">					       ICH_FLASH_WRITE_COMMAND_TIMEOUT);</a>
<a name="ln4577"> </a>
<a name="ln4578">		if (ret_val == E1000_SUCCESS)</a>
<a name="ln4579">			break;</a>
<a name="ln4580"> </a>
<a name="ln4581">		/* If we're here, then things are most likely</a>
<a name="ln4582">		 * completely hosed, but if the error condition</a>
<a name="ln4583">		 * is detected, it won't hurt to give it another</a>
<a name="ln4584">		 * try...ICH_FLASH_CYCLE_REPEAT_COUNT times.</a>
<a name="ln4585">		 */</a>
<a name="ln4586">		hsfsts.regval = E1000_READ_FLASH_REG16(hw, ICH_FLASH_HSFSTS);</a>
<a name="ln4587"> </a>
<a name="ln4588">		if (hsfsts.hsf_status.flcerr)</a>
<a name="ln4589">			/* Repeat for some time before giving up. */</a>
<a name="ln4590">			continue;</a>
<a name="ln4591">		if (!hsfsts.hsf_status.flcdone) {</a>
<a name="ln4592">			DEBUGOUT(&quot;Timeout error - flash cycle did not complete.\n&quot;);</a>
<a name="ln4593">			break;</a>
<a name="ln4594">		}</a>
<a name="ln4595">	} while (count++ &lt; ICH_FLASH_CYCLE_REPEAT_COUNT);</a>
<a name="ln4596"> </a>
<a name="ln4597">	return ret_val;</a>
<a name="ln4598">}</a>
<a name="ln4599"> </a>
<a name="ln4600">/**</a>
<a name="ln4601"> *  e1000_write_flash_byte_ich8lan - Write a single byte to NVM</a>
<a name="ln4602"> *  @hw: pointer to the HW structure</a>
<a name="ln4603"> *  @offset: The index of the byte to read.</a>
<a name="ln4604"> *  @data: The byte to write to the NVM.</a>
<a name="ln4605"> *</a>
<a name="ln4606"> *  Writes a single byte to the NVM using the flash access registers.</a>
<a name="ln4607"> **/</a>
<a name="ln4608">static s32 e1000_write_flash_byte_ich8lan(struct e1000_hw *hw, u32 offset,</a>
<a name="ln4609">					  u8 data)</a>
<a name="ln4610">{</a>
<a name="ln4611">	u16 word = (u16)data;</a>
<a name="ln4612"> </a>
<a name="ln4613">	DEBUGFUNC(&quot;e1000_write_flash_byte_ich8lan&quot;);</a>
<a name="ln4614"> </a>
<a name="ln4615">	return e1000_write_flash_data_ich8lan(hw, offset, 1, word);</a>
<a name="ln4616">}</a>
<a name="ln4617"> </a>
<a name="ln4618">/**</a>
<a name="ln4619">*  e1000_retry_write_flash_dword_ich8lan - Writes a dword to NVM</a>
<a name="ln4620">*  @hw: pointer to the HW structure</a>
<a name="ln4621">*  @offset: The offset of the word to write.</a>
<a name="ln4622">*  @dword: The dword to write to the NVM.</a>
<a name="ln4623">*</a>
<a name="ln4624">*  Writes a single dword to the NVM using the flash access registers.</a>
<a name="ln4625">*  Goes through a retry algorithm before giving up.</a>
<a name="ln4626">**/</a>
<a name="ln4627">static s32 e1000_retry_write_flash_dword_ich8lan(struct e1000_hw *hw,</a>
<a name="ln4628">						 u32 offset, u32 dword)</a>
<a name="ln4629">{</a>
<a name="ln4630">	s32 ret_val;</a>
<a name="ln4631">	u16 program_retries;</a>
<a name="ln4632"> </a>
<a name="ln4633">	DEBUGFUNC(&quot;e1000_retry_write_flash_dword_ich8lan&quot;);</a>
<a name="ln4634"> </a>
<a name="ln4635">	/* Must convert word offset into bytes. */</a>
<a name="ln4636">	offset &lt;&lt;= 1;</a>
<a name="ln4637"> </a>
<a name="ln4638">	ret_val = e1000_write_flash_data32_ich8lan(hw, offset, dword);</a>
<a name="ln4639"> </a>
<a name="ln4640">	if (!ret_val)</a>
<a name="ln4641">		return ret_val;</a>
<a name="ln4642">	for (program_retries = 0; program_retries &lt; 100; program_retries++) {</a>
<a name="ln4643">		DEBUGOUT2(&quot;Retrying Byte %8.8X at offset %u\n&quot;, dword, offset);</a>
<a name="ln4644">		usec_delay(100);</a>
<a name="ln4645">		ret_val = e1000_write_flash_data32_ich8lan(hw, offset, dword);</a>
<a name="ln4646">		if (ret_val == E1000_SUCCESS)</a>
<a name="ln4647">			break;</a>
<a name="ln4648">	}</a>
<a name="ln4649">	if (program_retries == 100)</a>
<a name="ln4650">		return -E1000_ERR_NVM;</a>
<a name="ln4651"> </a>
<a name="ln4652">	return E1000_SUCCESS;</a>
<a name="ln4653">}</a>
<a name="ln4654"> </a>
<a name="ln4655">/**</a>
<a name="ln4656"> *  e1000_retry_write_flash_byte_ich8lan - Writes a single byte to NVM</a>
<a name="ln4657"> *  @hw: pointer to the HW structure</a>
<a name="ln4658"> *  @offset: The offset of the byte to write.</a>
<a name="ln4659"> *  @byte: The byte to write to the NVM.</a>
<a name="ln4660"> *</a>
<a name="ln4661"> *  Writes a single byte to the NVM using the flash access registers.</a>
<a name="ln4662"> *  Goes through a retry algorithm before giving up.</a>
<a name="ln4663"> **/</a>
<a name="ln4664">static s32 e1000_retry_write_flash_byte_ich8lan(struct e1000_hw *hw,</a>
<a name="ln4665">						u32 offset, u8 byte)</a>
<a name="ln4666">{</a>
<a name="ln4667">	s32 ret_val;</a>
<a name="ln4668">	u16 program_retries;</a>
<a name="ln4669"> </a>
<a name="ln4670">	DEBUGFUNC(&quot;e1000_retry_write_flash_byte_ich8lan&quot;);</a>
<a name="ln4671"> </a>
<a name="ln4672">	ret_val = e1000_write_flash_byte_ich8lan(hw, offset, byte);</a>
<a name="ln4673">	if (!ret_val)</a>
<a name="ln4674">		return ret_val;</a>
<a name="ln4675"> </a>
<a name="ln4676">	for (program_retries = 0; program_retries &lt; 100; program_retries++) {</a>
<a name="ln4677">		DEBUGOUT2(&quot;Retrying Byte %2.2X at offset %u\n&quot;, byte, offset);</a>
<a name="ln4678">		usec_delay(100);</a>
<a name="ln4679">		ret_val = e1000_write_flash_byte_ich8lan(hw, offset, byte);</a>
<a name="ln4680">		if (ret_val == E1000_SUCCESS)</a>
<a name="ln4681">			break;</a>
<a name="ln4682">	}</a>
<a name="ln4683">	if (program_retries == 100)</a>
<a name="ln4684">		return -E1000_ERR_NVM;</a>
<a name="ln4685"> </a>
<a name="ln4686">	return E1000_SUCCESS;</a>
<a name="ln4687">}</a>
<a name="ln4688"> </a>
<a name="ln4689">/**</a>
<a name="ln4690"> *  e1000_erase_flash_bank_ich8lan - Erase a bank (4k) from NVM</a>
<a name="ln4691"> *  @hw: pointer to the HW structure</a>
<a name="ln4692"> *  @bank: 0 for first bank, 1 for second bank, etc.</a>
<a name="ln4693"> *</a>
<a name="ln4694"> *  Erases the bank specified. Each bank is a 4k block. Banks are 0 based.</a>
<a name="ln4695"> *  bank N is 4096 * N + flash_reg_addr.</a>
<a name="ln4696"> **/</a>
<a name="ln4697">static s32 e1000_erase_flash_bank_ich8lan(struct e1000_hw *hw, u32 bank)</a>
<a name="ln4698">{</a>
<a name="ln4699">	struct e1000_nvm_info *nvm = &amp;hw-&gt;nvm;</a>
<a name="ln4700">	union ich8_hws_flash_status hsfsts;</a>
<a name="ln4701">	union ich8_hws_flash_ctrl hsflctl;</a>
<a name="ln4702">	u32 flash_linear_addr;</a>
<a name="ln4703">	/* bank size is in 16bit words - adjust to bytes */</a>
<a name="ln4704">	u32 flash_bank_size = nvm-&gt;flash_bank_size * 2;</a>
<a name="ln4705">	s32 ret_val;</a>
<a name="ln4706">	s32 count = 0;</a>
<a name="ln4707">	s32 j, iteration, sector_size;</a>
<a name="ln4708"> </a>
<a name="ln4709">	DEBUGFUNC(&quot;e1000_erase_flash_bank_ich8lan&quot;);</a>
<a name="ln4710"> </a>
<a name="ln4711">	hsfsts.regval = E1000_READ_FLASH_REG16(hw, ICH_FLASH_HSFSTS);</a>
<a name="ln4712"> </a>
<a name="ln4713">	/* Determine HW Sector size: Read BERASE bits of hw flash status</a>
<a name="ln4714">	 * register</a>
<a name="ln4715">	 * 00: The Hw sector is 256 bytes, hence we need to erase 16</a>
<a name="ln4716">	 *     consecutive sectors.  The start index for the nth Hw sector</a>
<a name="ln4717">	 *     can be calculated as = bank * 4096 + n * 256</a>
<a name="ln4718">	 * 01: The Hw sector is 4K bytes, hence we need to erase 1 sector.</a>
<a name="ln4719">	 *     The start index for the nth Hw sector can be calculated</a>
<a name="ln4720">	 *     as = bank * 4096</a>
<a name="ln4721">	 * 10: The Hw sector is 8K bytes, nth sector = bank * 8192</a>
<a name="ln4722">	 *     (ich9 only, otherwise error condition)</a>
<a name="ln4723">	 * 11: The Hw sector is 64K bytes, nth sector = bank * 65536</a>
<a name="ln4724">	 */</a>
<a name="ln4725">	switch (hsfsts.hsf_status.berasesz) {</a>
<a name="ln4726">	case 0:</a>
<a name="ln4727">		/* Hw sector size 256 */</a>
<a name="ln4728">		sector_size = ICH_FLASH_SEG_SIZE_256;</a>
<a name="ln4729">		iteration = flash_bank_size / ICH_FLASH_SEG_SIZE_256;</a>
<a name="ln4730">		break;</a>
<a name="ln4731">	case 1:</a>
<a name="ln4732">		sector_size = ICH_FLASH_SEG_SIZE_4K;</a>
<a name="ln4733">		iteration = 1;</a>
<a name="ln4734">		break;</a>
<a name="ln4735">	case 2:</a>
<a name="ln4736">		sector_size = ICH_FLASH_SEG_SIZE_8K;</a>
<a name="ln4737">		iteration = 1;</a>
<a name="ln4738">		break;</a>
<a name="ln4739">	case 3:</a>
<a name="ln4740">		sector_size = ICH_FLASH_SEG_SIZE_64K;</a>
<a name="ln4741">		iteration = 1;</a>
<a name="ln4742">		break;</a>
<a name="ln4743">	default:</a>
<a name="ln4744">		return -E1000_ERR_NVM;</a>
<a name="ln4745">	}</a>
<a name="ln4746"> </a>
<a name="ln4747">	/* Start with the base address, then add the sector offset. */</a>
<a name="ln4748">	flash_linear_addr = hw-&gt;nvm.flash_base_addr;</a>
<a name="ln4749">	flash_linear_addr += (bank) ? flash_bank_size : 0;</a>
<a name="ln4750"> </a>
<a name="ln4751">	for (j = 0; j &lt; iteration; j++) {</a>
<a name="ln4752">		do {</a>
<a name="ln4753">			u32 timeout = ICH_FLASH_ERASE_COMMAND_TIMEOUT;</a>
<a name="ln4754"> </a>
<a name="ln4755">			/* Steps */</a>
<a name="ln4756">			ret_val = e1000_flash_cycle_init_ich8lan(hw);</a>
<a name="ln4757">			if (ret_val)</a>
<a name="ln4758">				return ret_val;</a>
<a name="ln4759"> </a>
<a name="ln4760">			/* Write a value 11 (block Erase) in Flash</a>
<a name="ln4761">			 * Cycle field in hw flash control</a>
<a name="ln4762">			 */</a>
<a name="ln4763">			if (hw-&gt;mac.type &gt;= e1000_pch_spt)</a>
<a name="ln4764">				hsflctl.regval =</a>
<a name="ln4765">				    E1000_READ_FLASH_REG(hw,</a>
<a name="ln4766">							 ICH_FLASH_HSFSTS)&gt;&gt;16;</a>
<a name="ln4767">			else</a>
<a name="ln4768">				hsflctl.regval =</a>
<a name="ln4769">				    E1000_READ_FLASH_REG16(hw,</a>
<a name="ln4770">							   ICH_FLASH_HSFCTL);</a>
<a name="ln4771"> </a>
<a name="ln4772">			hsflctl.hsf_ctrl.flcycle = ICH_CYCLE_ERASE;</a>
<a name="ln4773">			if (hw-&gt;mac.type &gt;= e1000_pch_spt)</a>
<a name="ln4774">				E1000_WRITE_FLASH_REG(hw, ICH_FLASH_HSFSTS,</a>
<a name="ln4775">						      hsflctl.regval &lt;&lt; 16);</a>
<a name="ln4776">			else</a>
<a name="ln4777">				E1000_WRITE_FLASH_REG16(hw, ICH_FLASH_HSFCTL,</a>
<a name="ln4778">							hsflctl.regval);</a>
<a name="ln4779"> </a>
<a name="ln4780">			/* Write the last 24 bits of an index within the</a>
<a name="ln4781">			 * block into Flash Linear address field in Flash</a>
<a name="ln4782">			 * Address.</a>
<a name="ln4783">			 */</a>
<a name="ln4784">			flash_linear_addr += (j * sector_size);</a>
<a name="ln4785">			E1000_WRITE_FLASH_REG(hw, ICH_FLASH_FADDR,</a>
<a name="ln4786">					      flash_linear_addr);</a>
<a name="ln4787"> </a>
<a name="ln4788">			ret_val = e1000_flash_cycle_ich8lan(hw, timeout);</a>
<a name="ln4789">			if (ret_val == E1000_SUCCESS)</a>
<a name="ln4790">				break;</a>
<a name="ln4791"> </a>
<a name="ln4792">			/* Check if FCERR is set to 1.  If 1,</a>
<a name="ln4793">			 * clear it and try the whole sequence</a>
<a name="ln4794">			 * a few more times else Done</a>
<a name="ln4795">			 */</a>
<a name="ln4796">			hsfsts.regval = E1000_READ_FLASH_REG16(hw,</a>
<a name="ln4797">						      ICH_FLASH_HSFSTS);</a>
<a name="ln4798">			if (hsfsts.hsf_status.flcerr)</a>
<a name="ln4799">				/* repeat for some time before giving up */</a>
<a name="ln4800">				continue;</a>
<a name="ln4801">			else if (!hsfsts.hsf_status.flcdone)</a>
<a name="ln4802">				return ret_val;</a>
<a name="ln4803">		} while (++count &lt; ICH_FLASH_CYCLE_REPEAT_COUNT);</a>
<a name="ln4804">	}</a>
<a name="ln4805"> </a>
<a name="ln4806">	return E1000_SUCCESS;</a>
<a name="ln4807">}</a>
<a name="ln4808"> </a>
<a name="ln4809">/**</a>
<a name="ln4810"> *  e1000_valid_led_default_ich8lan - Set the default LED settings</a>
<a name="ln4811"> *  @hw: pointer to the HW structure</a>
<a name="ln4812"> *  @data: Pointer to the LED settings</a>
<a name="ln4813"> *</a>
<a name="ln4814"> *  Reads the LED default settings from the NVM to data.  If the NVM LED</a>
<a name="ln4815"> *  settings is all 0's or F's, set the LED default to a valid LED default</a>
<a name="ln4816"> *  setting.</a>
<a name="ln4817"> **/</a>
<a name="ln4818">static s32 e1000_valid_led_default_ich8lan(struct e1000_hw *hw, u16 *data)</a>
<a name="ln4819">{</a>
<a name="ln4820">	s32 ret_val;</a>
<a name="ln4821"> </a>
<a name="ln4822">	DEBUGFUNC(&quot;e1000_valid_led_default_ich8lan&quot;);</a>
<a name="ln4823"> </a>
<a name="ln4824">	ret_val = hw-&gt;nvm.ops.read(hw, NVM_ID_LED_SETTINGS, 1, data);</a>
<a name="ln4825">	if (ret_val) {</a>
<a name="ln4826">		DEBUGOUT(&quot;NVM Read Error\n&quot;);</a>
<a name="ln4827">		return ret_val;</a>
<a name="ln4828">	}</a>
<a name="ln4829"> </a>
<a name="ln4830">	if (*data == ID_LED_RESERVED_0000 || *data == ID_LED_RESERVED_FFFF)</a>
<a name="ln4831">		*data = ID_LED_DEFAULT_ICH8LAN;</a>
<a name="ln4832"> </a>
<a name="ln4833">	return E1000_SUCCESS;</a>
<a name="ln4834">}</a>
<a name="ln4835"> </a>
<a name="ln4836">/**</a>
<a name="ln4837"> *  e1000_id_led_init_pchlan - store LED configurations</a>
<a name="ln4838"> *  @hw: pointer to the HW structure</a>
<a name="ln4839"> *</a>
<a name="ln4840"> *  PCH does not control LEDs via the LEDCTL register, rather it uses</a>
<a name="ln4841"> *  the PHY LED configuration register.</a>
<a name="ln4842"> *</a>
<a name="ln4843"> *  PCH also does not have an &quot;always on&quot; or &quot;always off&quot; mode which</a>
<a name="ln4844"> *  complicates the ID feature.  Instead of using the &quot;on&quot; mode to indicate</a>
<a name="ln4845"> *  in ledctl_mode2 the LEDs to use for ID (see e1000_id_led_init_generic()),</a>
<a name="ln4846"> *  use &quot;link_up&quot; mode.  The LEDs will still ID on request if there is no</a>
<a name="ln4847"> *  link based on logic in e1000_led_[on|off]_pchlan().</a>
<a name="ln4848"> **/</a>
<a name="ln4849">static s32 e1000_id_led_init_pchlan(struct e1000_hw *hw)</a>
<a name="ln4850">{</a>
<a name="ln4851">	struct e1000_mac_info *mac = &amp;hw-&gt;mac;</a>
<a name="ln4852">	s32 ret_val;</a>
<a name="ln4853">	const u32 ledctl_on = E1000_LEDCTL_MODE_LINK_UP;</a>
<a name="ln4854">	const u32 ledctl_off = E1000_LEDCTL_MODE_LINK_UP | E1000_PHY_LED0_IVRT;</a>
<a name="ln4855">	u16 data, i, temp, shift;</a>
<a name="ln4856"> </a>
<a name="ln4857">	DEBUGFUNC(&quot;e1000_id_led_init_pchlan&quot;);</a>
<a name="ln4858"> </a>
<a name="ln4859">	/* Get default ID LED modes */</a>
<a name="ln4860">	ret_val = hw-&gt;nvm.ops.valid_led_default(hw, &amp;data);</a>
<a name="ln4861">	if (ret_val)</a>
<a name="ln4862">		return ret_val;</a>
<a name="ln4863"> </a>
<a name="ln4864">	mac-&gt;ledctl_default = E1000_READ_REG(hw, E1000_LEDCTL);</a>
<a name="ln4865">	mac-&gt;ledctl_mode1 = mac-&gt;ledctl_default;</a>
<a name="ln4866">	mac-&gt;ledctl_mode2 = mac-&gt;ledctl_default;</a>
<a name="ln4867"> </a>
<a name="ln4868">	for (i = 0; i &lt; 4; i++) {</a>
<a name="ln4869">		temp = (data &gt;&gt; (i &lt;&lt; 2)) &amp; E1000_LEDCTL_LED0_MODE_MASK;</a>
<a name="ln4870">		shift = (i * 5);</a>
<a name="ln4871">		switch (temp) {</a>
<a name="ln4872">		case ID_LED_ON1_DEF2:</a>
<a name="ln4873">		case ID_LED_ON1_ON2:</a>
<a name="ln4874">		case ID_LED_ON1_OFF2:</a>
<a name="ln4875">			mac-&gt;ledctl_mode1 &amp;= ~(E1000_PHY_LED0_MASK &lt;&lt; shift);</a>
<a name="ln4876">			mac-&gt;ledctl_mode1 |= (ledctl_on &lt;&lt; shift);</a>
<a name="ln4877">			break;</a>
<a name="ln4878">		case ID_LED_OFF1_DEF2:</a>
<a name="ln4879">		case ID_LED_OFF1_ON2:</a>
<a name="ln4880">		case ID_LED_OFF1_OFF2:</a>
<a name="ln4881">			mac-&gt;ledctl_mode1 &amp;= ~(E1000_PHY_LED0_MASK &lt;&lt; shift);</a>
<a name="ln4882">			mac-&gt;ledctl_mode1 |= (ledctl_off &lt;&lt; shift);</a>
<a name="ln4883">			break;</a>
<a name="ln4884">		default:</a>
<a name="ln4885">			/* Do nothing */</a>
<a name="ln4886">			break;</a>
<a name="ln4887">		}</a>
<a name="ln4888">		switch (temp) {</a>
<a name="ln4889">		case ID_LED_DEF1_ON2:</a>
<a name="ln4890">		case ID_LED_ON1_ON2:</a>
<a name="ln4891">		case ID_LED_OFF1_ON2:</a>
<a name="ln4892">			mac-&gt;ledctl_mode2 &amp;= ~(E1000_PHY_LED0_MASK &lt;&lt; shift);</a>
<a name="ln4893">			mac-&gt;ledctl_mode2 |= (ledctl_on &lt;&lt; shift);</a>
<a name="ln4894">			break;</a>
<a name="ln4895">		case ID_LED_DEF1_OFF2:</a>
<a name="ln4896">		case ID_LED_ON1_OFF2:</a>
<a name="ln4897">		case ID_LED_OFF1_OFF2:</a>
<a name="ln4898">			mac-&gt;ledctl_mode2 &amp;= ~(E1000_PHY_LED0_MASK &lt;&lt; shift);</a>
<a name="ln4899">			mac-&gt;ledctl_mode2 |= (ledctl_off &lt;&lt; shift);</a>
<a name="ln4900">			break;</a>
<a name="ln4901">		default:</a>
<a name="ln4902">			/* Do nothing */</a>
<a name="ln4903">			break;</a>
<a name="ln4904">		}</a>
<a name="ln4905">	}</a>
<a name="ln4906"> </a>
<a name="ln4907">	return E1000_SUCCESS;</a>
<a name="ln4908">}</a>
<a name="ln4909"> </a>
<a name="ln4910">/**</a>
<a name="ln4911"> *  e1000_get_bus_info_ich8lan - Get/Set the bus type and width</a>
<a name="ln4912"> *  @hw: pointer to the HW structure</a>
<a name="ln4913"> *</a>
<a name="ln4914"> *  ICH8 use the PCI Express bus, but does not contain a PCI Express Capability</a>
<a name="ln4915"> *  register, so the bus width is hard coded.</a>
<a name="ln4916"> **/</a>
<a name="ln4917">static s32 e1000_get_bus_info_ich8lan(struct e1000_hw *hw)</a>
<a name="ln4918">{</a>
<a name="ln4919">	struct e1000_bus_info *bus = &amp;hw-&gt;bus;</a>
<a name="ln4920">	s32 ret_val;</a>
<a name="ln4921"> </a>
<a name="ln4922">	DEBUGFUNC(&quot;e1000_get_bus_info_ich8lan&quot;);</a>
<a name="ln4923"> </a>
<a name="ln4924">	ret_val = e1000_get_bus_info_pcie_generic(hw);</a>
<a name="ln4925"> </a>
<a name="ln4926">	/* ICH devices are &quot;PCI Express&quot;-ish.  They have</a>
<a name="ln4927">	 * a configuration space, but do not contain</a>
<a name="ln4928">	 * PCI Express Capability registers, so bus width</a>
<a name="ln4929">	 * must be hardcoded.</a>
<a name="ln4930">	 */</a>
<a name="ln4931">	if (bus-&gt;width == e1000_bus_width_unknown)</a>
<a name="ln4932">		bus-&gt;width = e1000_bus_width_pcie_x1;</a>
<a name="ln4933"> </a>
<a name="ln4934">	return ret_val;</a>
<a name="ln4935">}</a>
<a name="ln4936"> </a>
<a name="ln4937">/**</a>
<a name="ln4938"> *  e1000_reset_hw_ich8lan - Reset the hardware</a>
<a name="ln4939"> *  @hw: pointer to the HW structure</a>
<a name="ln4940"> *</a>
<a name="ln4941"> *  Does a full reset of the hardware which includes a reset of the PHY and</a>
<a name="ln4942"> *  MAC.</a>
<a name="ln4943"> **/</a>
<a name="ln4944">static s32 e1000_reset_hw_ich8lan(struct e1000_hw *hw)</a>
<a name="ln4945">{</a>
<a name="ln4946">	struct e1000_dev_spec_ich8lan *dev_spec = &amp;hw-&gt;dev_spec.ich8lan;</a>
<a name="ln4947">	u16 kum_cfg;</a>
<a name="ln4948">	u32 ctrl, reg;</a>
<a name="ln4949">	s32 ret_val;</a>
<a name="ln4950"> </a>
<a name="ln4951">	DEBUGFUNC(&quot;e1000_reset_hw_ich8lan&quot;);</a>
<a name="ln4952"> </a>
<a name="ln4953">	/* Prevent the PCI-E bus from sticking if there is no TLP connection</a>
<a name="ln4954">	 * on the last TLP read/write transaction when MAC is reset.</a>
<a name="ln4955">	 */</a>
<a name="ln4956">	ret_val = e1000_disable_pcie_master_generic(hw);</a>
<a name="ln4957">	if (ret_val)</a>
<a name="ln4958">		DEBUGOUT(&quot;PCI-E Master disable polling has failed.\n&quot;);</a>
<a name="ln4959"> </a>
<a name="ln4960">	DEBUGOUT(&quot;Masking off all interrupts\n&quot;);</a>
<a name="ln4961">	E1000_WRITE_REG(hw, E1000_IMC, 0xffffffff);</a>
<a name="ln4962"> </a>
<a name="ln4963">	/* Disable the Transmit and Receive units.  Then delay to allow</a>
<a name="ln4964">	 * any pending transactions to complete before we hit the MAC</a>
<a name="ln4965">	 * with the global reset.</a>
<a name="ln4966">	 */</a>
<a name="ln4967">	E1000_WRITE_REG(hw, E1000_RCTL, 0);</a>
<a name="ln4968">	E1000_WRITE_REG(hw, E1000_TCTL, E1000_TCTL_PSP);</a>
<a name="ln4969">	E1000_WRITE_FLUSH(hw);</a>
<a name="ln4970"> </a>
<a name="ln4971">	msec_delay(10);</a>
<a name="ln4972"> </a>
<a name="ln4973">	/* Workaround for ICH8 bit corruption issue in FIFO memory */</a>
<a name="ln4974">	if (hw-&gt;mac.type == e1000_ich8lan) {</a>
<a name="ln4975">		/* Set Tx and Rx buffer allocation to 8k apiece. */</a>
<a name="ln4976">		E1000_WRITE_REG(hw, E1000_PBA, E1000_PBA_8K);</a>
<a name="ln4977">		/* Set Packet Buffer Size to 16k. */</a>
<a name="ln4978">		E1000_WRITE_REG(hw, E1000_PBS, E1000_PBS_16K);</a>
<a name="ln4979">	}</a>
<a name="ln4980"> </a>
<a name="ln4981">	if (hw-&gt;mac.type == e1000_pchlan) {</a>
<a name="ln4982">		/* Save the NVM K1 bit setting*/</a>
<a name="ln4983">		ret_val = e1000_read_nvm(hw, E1000_NVM_K1_CONFIG, 1, &amp;kum_cfg);</a>
<a name="ln4984">		if (ret_val)</a>
<a name="ln4985">			return ret_val;</a>
<a name="ln4986"> </a>
<a name="ln4987">		if (kum_cfg &amp; E1000_NVM_K1_ENABLE)</a>
<a name="ln4988">			dev_spec-&gt;nvm_k1_enabled = TRUE;</a>
<a name="ln4989">		else</a>
<a name="ln4990">			dev_spec-&gt;nvm_k1_enabled = FALSE;</a>
<a name="ln4991">	}</a>
<a name="ln4992"> </a>
<a name="ln4993">	ctrl = E1000_READ_REG(hw, E1000_CTRL);</a>
<a name="ln4994"> </a>
<a name="ln4995">	if (!hw-&gt;phy.ops.check_reset_block(hw)) {</a>
<a name="ln4996">		/* Full-chip reset requires MAC and PHY reset at the same</a>
<a name="ln4997">		 * time to make sure the interface between MAC and the</a>
<a name="ln4998">		 * external PHY is reset.</a>
<a name="ln4999">		 */</a>
<a name="ln5000">		ctrl |= E1000_CTRL_PHY_RST;</a>
<a name="ln5001"> </a>
<a name="ln5002">		/* Gate automatic PHY configuration by hardware on</a>
<a name="ln5003">		 * non-managed 82579</a>
<a name="ln5004">		 */</a>
<a name="ln5005">		if ((hw-&gt;mac.type == e1000_pch2lan) &amp;&amp;</a>
<a name="ln5006">		    !(E1000_READ_REG(hw, E1000_FWSM) &amp; E1000_ICH_FWSM_FW_VALID))</a>
<a name="ln5007">			e1000_gate_hw_phy_config_ich8lan(hw, TRUE);</a>
<a name="ln5008">	}</a>
<a name="ln5009">	ret_val = e1000_acquire_swflag_ich8lan(hw);</a>
<a name="ln5010">	DEBUGOUT(&quot;Issuing a global reset to ich8lan\n&quot;);</a>
<a name="ln5011">	E1000_WRITE_REG(hw, E1000_CTRL, (ctrl | E1000_CTRL_RST));</a>
<a name="ln5012">	/* cannot issue a flush here because it hangs the hardware */</a>
<a name="ln5013">	msec_delay(20);</a>
<a name="ln5014"> </a>
<a name="ln5015">	/* Set Phy Config Counter to 50msec */</a>
<a name="ln5016">	if (hw-&gt;mac.type == e1000_pch2lan) {</a>
<a name="ln5017">		reg = E1000_READ_REG(hw, E1000_FEXTNVM3);</a>
<a name="ln5018">		reg &amp;= ~E1000_FEXTNVM3_PHY_CFG_COUNTER_MASK;</a>
<a name="ln5019">		reg |= E1000_FEXTNVM3_PHY_CFG_COUNTER_50MSEC;</a>
<a name="ln5020">		E1000_WRITE_REG(hw, E1000_FEXTNVM3, reg);</a>
<a name="ln5021">	}</a>
<a name="ln5022"> </a>
<a name="ln5023"> </a>
<a name="ln5024">	if (ctrl &amp; E1000_CTRL_PHY_RST) {</a>
<a name="ln5025">		ret_val = hw-&gt;phy.ops.get_cfg_done(hw);</a>
<a name="ln5026">		if (ret_val)</a>
<a name="ln5027">			return ret_val;</a>
<a name="ln5028"> </a>
<a name="ln5029">		ret_val = e1000_post_phy_reset_ich8lan(hw);</a>
<a name="ln5030">		if (ret_val)</a>
<a name="ln5031">			return ret_val;</a>
<a name="ln5032">	}</a>
<a name="ln5033"> </a>
<a name="ln5034">	/* For PCH, this write will make sure that any noise</a>
<a name="ln5035">	 * will be detected as a CRC error and be dropped rather than show up</a>
<a name="ln5036">	 * as a bad packet to the DMA engine.</a>
<a name="ln5037">	 */</a>
<a name="ln5038">	if (hw-&gt;mac.type == e1000_pchlan)</a>
<a name="ln5039">		E1000_WRITE_REG(hw, E1000_CRC_OFFSET, 0x65656565);</a>
<a name="ln5040"> </a>
<a name="ln5041">	E1000_WRITE_REG(hw, E1000_IMC, 0xffffffff);</a>
<a name="ln5042">	E1000_READ_REG(hw, E1000_ICR);</a>
<a name="ln5043"> </a>
<a name="ln5044">	reg = E1000_READ_REG(hw, E1000_KABGTXD);</a>
<a name="ln5045">	reg |= E1000_KABGTXD_BGSQLBIAS;</a>
<a name="ln5046">	E1000_WRITE_REG(hw, E1000_KABGTXD, reg);</a>
<a name="ln5047"> </a>
<a name="ln5048">	return E1000_SUCCESS;</a>
<a name="ln5049">}</a>
<a name="ln5050"> </a>
<a name="ln5051">/**</a>
<a name="ln5052"> *  e1000_init_hw_ich8lan - Initialize the hardware</a>
<a name="ln5053"> *  @hw: pointer to the HW structure</a>
<a name="ln5054"> *</a>
<a name="ln5055"> *  Prepares the hardware for transmit and receive by doing the following:</a>
<a name="ln5056"> *   - initialize hardware bits</a>
<a name="ln5057"> *   - initialize LED identification</a>
<a name="ln5058"> *   - setup receive address registers</a>
<a name="ln5059"> *   - setup flow control</a>
<a name="ln5060"> *   - setup transmit descriptors</a>
<a name="ln5061"> *   - clear statistics</a>
<a name="ln5062"> **/</a>
<a name="ln5063">static s32 e1000_init_hw_ich8lan(struct e1000_hw *hw)</a>
<a name="ln5064">{</a>
<a name="ln5065">	struct e1000_mac_info *mac = &amp;hw-&gt;mac;</a>
<a name="ln5066">	u32 ctrl_ext, txdctl, snoop;</a>
<a name="ln5067">	s32 ret_val;</a>
<a name="ln5068">	u16 i;</a>
<a name="ln5069"> </a>
<a name="ln5070">	DEBUGFUNC(&quot;e1000_init_hw_ich8lan&quot;);</a>
<a name="ln5071"> </a>
<a name="ln5072">	e1000_initialize_hw_bits_ich8lan(hw);</a>
<a name="ln5073"> </a>
<a name="ln5074">	/* Initialize identification LED */</a>
<a name="ln5075">	ret_val = mac-&gt;ops.id_led_init(hw);</a>
<a name="ln5076">	/* An error is not fatal and we should not stop init due to this */</a>
<a name="ln5077">	if (ret_val)</a>
<a name="ln5078">		DEBUGOUT(&quot;Error initializing identification LED\n&quot;);</a>
<a name="ln5079"> </a>
<a name="ln5080">	/* Setup the receive address. */</a>
<a name="ln5081">	e1000_init_rx_addrs_generic(hw, mac-&gt;rar_entry_count);</a>
<a name="ln5082"> </a>
<a name="ln5083">	/* Zero out the Multicast HASH table */</a>
<a name="ln5084">	DEBUGOUT(&quot;Zeroing the MTA\n&quot;);</a>
<a name="ln5085">	for (i = 0; i &lt; mac-&gt;mta_reg_count; i++)</a>
<a name="ln5086">		E1000_WRITE_REG_ARRAY(hw, E1000_MTA, i, 0);</a>
<a name="ln5087"> </a>
<a name="ln5088">	/* The 82578 Rx buffer will stall if wakeup is enabled in host and</a>
<a name="ln5089">	 * the ME.  Disable wakeup by clearing the host wakeup bit.</a>
<a name="ln5090">	 * Reset the phy after disabling host wakeup to reset the Rx buffer.</a>
<a name="ln5091">	 */</a>
<a name="ln5092">	if (hw-&gt;phy.type == e1000_phy_82578) {</a>
<a name="ln5093">		hw-&gt;phy.ops.read_reg(hw, BM_PORT_GEN_CFG, &amp;i);</a>
<a name="ln5094">		i &amp;= ~BM_WUC_HOST_WU_BIT;</a>
<a name="ln5095">		hw-&gt;phy.ops.write_reg(hw, BM_PORT_GEN_CFG, i);</a>
<a name="ln5096">		ret_val = e1000_phy_hw_reset_ich8lan(hw);</a>
<a name="ln5097">		if (ret_val)</a>
<a name="ln5098">			return ret_val;</a>
<a name="ln5099">	}</a>
<a name="ln5100"> </a>
<a name="ln5101">	/* Setup link and flow control */</a>
<a name="ln5102">	ret_val = mac-&gt;ops.setup_link(hw);</a>
<a name="ln5103"> </a>
<a name="ln5104">	/* Set the transmit descriptor write-back policy for both queues */</a>
<a name="ln5105">	txdctl = E1000_READ_REG(hw, E1000_TXDCTL(0));</a>
<a name="ln5106">	txdctl = ((txdctl &amp; ~E1000_TXDCTL_WTHRESH) |</a>
<a name="ln5107">		  E1000_TXDCTL_FULL_TX_DESC_WB);</a>
<a name="ln5108">	txdctl = ((txdctl &amp; ~E1000_TXDCTL_PTHRESH) |</a>
<a name="ln5109">		  E1000_TXDCTL_MAX_TX_DESC_PREFETCH);</a>
<a name="ln5110">	E1000_WRITE_REG(hw, E1000_TXDCTL(0), txdctl);</a>
<a name="ln5111">	txdctl = E1000_READ_REG(hw, E1000_TXDCTL(1));</a>
<a name="ln5112">	txdctl = ((txdctl &amp; ~E1000_TXDCTL_WTHRESH) |</a>
<a name="ln5113">		  E1000_TXDCTL_FULL_TX_DESC_WB);</a>
<a name="ln5114">	txdctl = ((txdctl &amp; ~E1000_TXDCTL_PTHRESH) |</a>
<a name="ln5115">		  E1000_TXDCTL_MAX_TX_DESC_PREFETCH);</a>
<a name="ln5116">	E1000_WRITE_REG(hw, E1000_TXDCTL(1), txdctl);</a>
<a name="ln5117"> </a>
<a name="ln5118">	/* ICH8 has opposite polarity of no_snoop bits.</a>
<a name="ln5119">	 * By default, we should use snoop behavior.</a>
<a name="ln5120">	 */</a>
<a name="ln5121">	if (mac-&gt;type == e1000_ich8lan)</a>
<a name="ln5122">		snoop = PCIE_ICH8_SNOOP_ALL;</a>
<a name="ln5123">	else</a>
<a name="ln5124">		snoop = (u32) ~(PCIE_NO_SNOOP_ALL);</a>
<a name="ln5125">	e1000_set_pcie_no_snoop_generic(hw, snoop);</a>
<a name="ln5126"> </a>
<a name="ln5127">	ctrl_ext = E1000_READ_REG(hw, E1000_CTRL_EXT);</a>
<a name="ln5128">	ctrl_ext |= E1000_CTRL_EXT_RO_DIS;</a>
<a name="ln5129">	E1000_WRITE_REG(hw, E1000_CTRL_EXT, ctrl_ext);</a>
<a name="ln5130"> </a>
<a name="ln5131">	/* Clear all of the statistics registers (clear on read).  It is</a>
<a name="ln5132">	 * important that we do this after we have tried to establish link</a>
<a name="ln5133">	 * because the symbol error count will increment wildly if there</a>
<a name="ln5134">	 * is no link.</a>
<a name="ln5135">	 */</a>
<a name="ln5136">	e1000_clear_hw_cntrs_ich8lan(hw);</a>
<a name="ln5137"> </a>
<a name="ln5138">	return ret_val;</a>
<a name="ln5139">}</a>
<a name="ln5140"> </a>
<a name="ln5141">/**</a>
<a name="ln5142"> *  e1000_initialize_hw_bits_ich8lan - Initialize required hardware bits</a>
<a name="ln5143"> *  @hw: pointer to the HW structure</a>
<a name="ln5144"> *</a>
<a name="ln5145"> *  Sets/Clears required hardware bits necessary for correctly setting up the</a>
<a name="ln5146"> *  hardware for transmit and receive.</a>
<a name="ln5147"> **/</a>
<a name="ln5148">static void e1000_initialize_hw_bits_ich8lan(struct e1000_hw *hw)</a>
<a name="ln5149">{</a>
<a name="ln5150">	u32 reg;</a>
<a name="ln5151"> </a>
<a name="ln5152">	DEBUGFUNC(&quot;e1000_initialize_hw_bits_ich8lan&quot;);</a>
<a name="ln5153"> </a>
<a name="ln5154">	/* Extended Device Control */</a>
<a name="ln5155">	reg = E1000_READ_REG(hw, E1000_CTRL_EXT);</a>
<a name="ln5156">	reg |= (1 &lt;&lt; 22);</a>
<a name="ln5157">	/* Enable PHY low-power state when MAC is at D3 w/o WoL */</a>
<a name="ln5158">	if (hw-&gt;mac.type &gt;= e1000_pchlan)</a>
<a name="ln5159">		reg |= E1000_CTRL_EXT_PHYPDEN;</a>
<a name="ln5160">	E1000_WRITE_REG(hw, E1000_CTRL_EXT, reg);</a>
<a name="ln5161"> </a>
<a name="ln5162">	/* Transmit Descriptor Control 0 */</a>
<a name="ln5163">	reg = E1000_READ_REG(hw, E1000_TXDCTL(0));</a>
<a name="ln5164">	reg |= (1 &lt;&lt; 22);</a>
<a name="ln5165">	E1000_WRITE_REG(hw, E1000_TXDCTL(0), reg);</a>
<a name="ln5166"> </a>
<a name="ln5167">	/* Transmit Descriptor Control 1 */</a>
<a name="ln5168">	reg = E1000_READ_REG(hw, E1000_TXDCTL(1));</a>
<a name="ln5169">	reg |= (1 &lt;&lt; 22);</a>
<a name="ln5170">	E1000_WRITE_REG(hw, E1000_TXDCTL(1), reg);</a>
<a name="ln5171"> </a>
<a name="ln5172">	/* Transmit Arbitration Control 0 */</a>
<a name="ln5173">	reg = E1000_READ_REG(hw, E1000_TARC(0));</a>
<a name="ln5174">	if (hw-&gt;mac.type == e1000_ich8lan)</a>
<a name="ln5175">		reg |= (1 &lt;&lt; 28) | (1 &lt;&lt; 29);</a>
<a name="ln5176">	reg |= (1 &lt;&lt; 23) | (1 &lt;&lt; 24) | (1 &lt;&lt; 26) | (1 &lt;&lt; 27);</a>
<a name="ln5177">	E1000_WRITE_REG(hw, E1000_TARC(0), reg);</a>
<a name="ln5178"> </a>
<a name="ln5179">	/* Transmit Arbitration Control 1 */</a>
<a name="ln5180">	reg = E1000_READ_REG(hw, E1000_TARC(1));</a>
<a name="ln5181">	if (E1000_READ_REG(hw, E1000_TCTL) &amp; E1000_TCTL_MULR)</a>
<a name="ln5182">		reg &amp;= ~(1 &lt;&lt; 28);</a>
<a name="ln5183">	else</a>
<a name="ln5184">		reg |= (1 &lt;&lt; 28);</a>
<a name="ln5185">	reg |= (1 &lt;&lt; 24) | (1 &lt;&lt; 26) | (1 &lt;&lt; 30);</a>
<a name="ln5186">	E1000_WRITE_REG(hw, E1000_TARC(1), reg);</a>
<a name="ln5187"> </a>
<a name="ln5188">	/* Device Status */</a>
<a name="ln5189">	if (hw-&gt;mac.type == e1000_ich8lan) {</a>
<a name="ln5190">		reg = E1000_READ_REG(hw, E1000_STATUS);</a>
<a name="ln5191">		reg &amp;= ~(1U &lt;&lt; 31);</a>
<a name="ln5192">		E1000_WRITE_REG(hw, E1000_STATUS, reg);</a>
<a name="ln5193">	}</a>
<a name="ln5194"> </a>
<a name="ln5195">	/* work-around descriptor data corruption issue during nfs v2 udp</a>
<a name="ln5196">	 * traffic, just disable the nfs filtering capability</a>
<a name="ln5197">	 */</a>
<a name="ln5198">	reg = E1000_READ_REG(hw, E1000_RFCTL);</a>
<a name="ln5199">	reg |= (E1000_RFCTL_NFSW_DIS | E1000_RFCTL_NFSR_DIS);</a>
<a name="ln5200"> </a>
<a name="ln5201">	/* Disable IPv6 extension header parsing because some malformed</a>
<a name="ln5202">	 * IPv6 headers can hang the Rx.</a>
<a name="ln5203">	 */</a>
<a name="ln5204">	if (hw-&gt;mac.type == e1000_ich8lan)</a>
<a name="ln5205">		reg |= (E1000_RFCTL_IPV6_EX_DIS | E1000_RFCTL_NEW_IPV6_EXT_DIS);</a>
<a name="ln5206">	E1000_WRITE_REG(hw, E1000_RFCTL, reg);</a>
<a name="ln5207"> </a>
<a name="ln5208">	/* Enable ECC on Lynxpoint */</a>
<a name="ln5209">	if (hw-&gt;mac.type &gt;= e1000_pch_lpt) {</a>
<a name="ln5210">		reg = E1000_READ_REG(hw, E1000_PBECCSTS);</a>
<a name="ln5211">		reg |= E1000_PBECCSTS_ECC_ENABLE;</a>
<a name="ln5212">		E1000_WRITE_REG(hw, E1000_PBECCSTS, reg);</a>
<a name="ln5213"> </a>
<a name="ln5214">		reg = E1000_READ_REG(hw, E1000_CTRL);</a>
<a name="ln5215">		reg |= E1000_CTRL_MEHE;</a>
<a name="ln5216">		E1000_WRITE_REG(hw, E1000_CTRL, reg);</a>
<a name="ln5217">	}</a>
<a name="ln5218"> </a>
<a name="ln5219">	return;</a>
<a name="ln5220">}</a>
<a name="ln5221"> </a>
<a name="ln5222">/**</a>
<a name="ln5223"> *  e1000_setup_link_ich8lan - Setup flow control and link settings</a>
<a name="ln5224"> *  @hw: pointer to the HW structure</a>
<a name="ln5225"> *</a>
<a name="ln5226"> *  Determines which flow control settings to use, then configures flow</a>
<a name="ln5227"> *  control.  Calls the appropriate media-specific link configuration</a>
<a name="ln5228"> *  function.  Assuming the adapter has a valid link partner, a valid link</a>
<a name="ln5229"> *  should be established.  Assumes the hardware has previously been reset</a>
<a name="ln5230"> *  and the transmitter and receiver are not enabled.</a>
<a name="ln5231"> **/</a>
<a name="ln5232">static s32 e1000_setup_link_ich8lan(struct e1000_hw *hw)</a>
<a name="ln5233">{</a>
<a name="ln5234">	s32 ret_val;</a>
<a name="ln5235"> </a>
<a name="ln5236">	DEBUGFUNC(&quot;e1000_setup_link_ich8lan&quot;);</a>
<a name="ln5237"> </a>
<a name="ln5238">	if (hw-&gt;phy.ops.check_reset_block(hw))</a>
<a name="ln5239">		return E1000_SUCCESS;</a>
<a name="ln5240"> </a>
<a name="ln5241">	/* ICH parts do not have a word in the NVM to determine</a>
<a name="ln5242">	 * the default flow control setting, so we explicitly</a>
<a name="ln5243">	 * set it to full.</a>
<a name="ln5244">	 */</a>
<a name="ln5245">	if (hw-&gt;fc.requested_mode == e1000_fc_default)</a>
<a name="ln5246">		hw-&gt;fc.requested_mode = e1000_fc_full;</a>
<a name="ln5247"> </a>
<a name="ln5248">	/* Save off the requested flow control mode for use later.  Depending</a>
<a name="ln5249">	 * on the link partner's capabilities, we may or may not use this mode.</a>
<a name="ln5250">	 */</a>
<a name="ln5251">	hw-&gt;fc.current_mode = hw-&gt;fc.requested_mode;</a>
<a name="ln5252"> </a>
<a name="ln5253">	DEBUGOUT1(&quot;After fix-ups FlowControl is now = %x\n&quot;,</a>
<a name="ln5254">		hw-&gt;fc.current_mode);</a>
<a name="ln5255"> </a>
<a name="ln5256">	/* Continue to configure the copper link. */</a>
<a name="ln5257">	ret_val = hw-&gt;mac.ops.setup_physical_interface(hw);</a>
<a name="ln5258">	if (ret_val)</a>
<a name="ln5259">		return ret_val;</a>
<a name="ln5260"> </a>
<a name="ln5261">	E1000_WRITE_REG(hw, E1000_FCTTV, hw-&gt;fc.pause_time);</a>
<a name="ln5262">	if ((hw-&gt;phy.type == e1000_phy_82578) ||</a>
<a name="ln5263">	    (hw-&gt;phy.type == e1000_phy_82579) ||</a>
<a name="ln5264">	    (hw-&gt;phy.type == e1000_phy_i217) ||</a>
<a name="ln5265">	    (hw-&gt;phy.type == e1000_phy_82577)) {</a>
<a name="ln5266">		E1000_WRITE_REG(hw, E1000_FCRTV_PCH, hw-&gt;fc.refresh_time);</a>
<a name="ln5267"> </a>
<a name="ln5268">		ret_val = hw-&gt;phy.ops.write_reg(hw,</a>
<a name="ln5269">					     PHY_REG(BM_PORT_CTRL_PAGE, 27),</a>
<a name="ln5270">					     hw-&gt;fc.pause_time);</a>
<a name="ln5271">		if (ret_val)</a>
<a name="ln5272">			return ret_val;</a>
<a name="ln5273">	}</a>
<a name="ln5274"> </a>
<a name="ln5275">	return e1000_set_fc_watermarks_generic(hw);</a>
<a name="ln5276">}</a>
<a name="ln5277"> </a>
<a name="ln5278">/**</a>
<a name="ln5279"> *  e1000_setup_copper_link_ich8lan - Configure MAC/PHY interface</a>
<a name="ln5280"> *  @hw: pointer to the HW structure</a>
<a name="ln5281"> *</a>
<a name="ln5282"> *  Configures the kumeran interface to the PHY to wait the appropriate time</a>
<a name="ln5283"> *  when polling the PHY, then call the generic setup_copper_link to finish</a>
<a name="ln5284"> *  configuring the copper link.</a>
<a name="ln5285"> **/</a>
<a name="ln5286">static s32 e1000_setup_copper_link_ich8lan(struct e1000_hw *hw)</a>
<a name="ln5287">{</a>
<a name="ln5288">	u32 ctrl;</a>
<a name="ln5289">	s32 ret_val;</a>
<a name="ln5290">	u16 reg_data;</a>
<a name="ln5291"> </a>
<a name="ln5292">	DEBUGFUNC(&quot;e1000_setup_copper_link_ich8lan&quot;);</a>
<a name="ln5293"> </a>
<a name="ln5294">	ctrl = E1000_READ_REG(hw, E1000_CTRL);</a>
<a name="ln5295">	ctrl |= E1000_CTRL_SLU;</a>
<a name="ln5296">	ctrl &amp;= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);</a>
<a name="ln5297">	E1000_WRITE_REG(hw, E1000_CTRL, ctrl);</a>
<a name="ln5298"> </a>
<a name="ln5299">	/* Set the mac to wait the maximum time between each iteration</a>
<a name="ln5300">	 * and increase the max iterations when polling the phy;</a>
<a name="ln5301">	 * this fixes erroneous timeouts at 10Mbps.</a>
<a name="ln5302">	 */</a>
<a name="ln5303">	ret_val = e1000_write_kmrn_reg_generic(hw, E1000_KMRNCTRLSTA_TIMEOUTS,</a>
<a name="ln5304">					       0xFFFF);</a>
<a name="ln5305">	if (ret_val)</a>
<a name="ln5306">		return ret_val;</a>
<a name="ln5307">	ret_val = e1000_read_kmrn_reg_generic(hw,</a>
<a name="ln5308">					      E1000_KMRNCTRLSTA_INBAND_PARAM,</a>
<a name="ln5309">					      &amp;reg_data);</a>
<a name="ln5310">	if (ret_val)</a>
<a name="ln5311">		return ret_val;</a>
<a name="ln5312">	reg_data |= 0x3F;</a>
<a name="ln5313">	ret_val = e1000_write_kmrn_reg_generic(hw,</a>
<a name="ln5314">					       E1000_KMRNCTRLSTA_INBAND_PARAM,</a>
<a name="ln5315">					       reg_data);</a>
<a name="ln5316">	if (ret_val)</a>
<a name="ln5317">		return ret_val;</a>
<a name="ln5318"> </a>
<a name="ln5319">	switch (hw-&gt;phy.type) {</a>
<a name="ln5320">	case e1000_phy_igp_3:</a>
<a name="ln5321">		ret_val = e1000_copper_link_setup_igp(hw);</a>
<a name="ln5322">		if (ret_val)</a>
<a name="ln5323">			return ret_val;</a>
<a name="ln5324">		break;</a>
<a name="ln5325">	case e1000_phy_bm:</a>
<a name="ln5326">	case e1000_phy_82578:</a>
<a name="ln5327">		ret_val = e1000_copper_link_setup_m88(hw);</a>
<a name="ln5328">		if (ret_val)</a>
<a name="ln5329">			return ret_val;</a>
<a name="ln5330">		break;</a>
<a name="ln5331">	case e1000_phy_82577:</a>
<a name="ln5332">	case e1000_phy_82579:</a>
<a name="ln5333">		ret_val = e1000_copper_link_setup_82577(hw);</a>
<a name="ln5334">		if (ret_val)</a>
<a name="ln5335">			return ret_val;</a>
<a name="ln5336">		break;</a>
<a name="ln5337">	case e1000_phy_ife:</a>
<a name="ln5338">		ret_val = hw-&gt;phy.ops.read_reg(hw, IFE_PHY_MDIX_CONTROL,</a>
<a name="ln5339">					       &amp;reg_data);</a>
<a name="ln5340">		if (ret_val)</a>
<a name="ln5341">			return ret_val;</a>
<a name="ln5342"> </a>
<a name="ln5343">		reg_data &amp;= ~IFE_PMC_AUTO_MDIX;</a>
<a name="ln5344"> </a>
<a name="ln5345">		switch (hw-&gt;phy.mdix) {</a>
<a name="ln5346">		case 1:</a>
<a name="ln5347">			reg_data &amp;= ~IFE_PMC_FORCE_MDIX;</a>
<a name="ln5348">			break;</a>
<a name="ln5349">		case 2:</a>
<a name="ln5350">			reg_data |= IFE_PMC_FORCE_MDIX;</a>
<a name="ln5351">			break;</a>
<a name="ln5352">		case 0:</a>
<a name="ln5353">		default:</a>
<a name="ln5354">			reg_data |= IFE_PMC_AUTO_MDIX;</a>
<a name="ln5355">			break;</a>
<a name="ln5356">		}</a>
<a name="ln5357">		ret_val = hw-&gt;phy.ops.write_reg(hw, IFE_PHY_MDIX_CONTROL,</a>
<a name="ln5358">						reg_data);</a>
<a name="ln5359">		if (ret_val)</a>
<a name="ln5360">			return ret_val;</a>
<a name="ln5361">		break;</a>
<a name="ln5362">	default:</a>
<a name="ln5363">		break;</a>
<a name="ln5364">	}</a>
<a name="ln5365"> </a>
<a name="ln5366">	return e1000_setup_copper_link_generic(hw);</a>
<a name="ln5367">}</a>
<a name="ln5368"> </a>
<a name="ln5369">/**</a>
<a name="ln5370"> *  e1000_setup_copper_link_pch_lpt - Configure MAC/PHY interface</a>
<a name="ln5371"> *  @hw: pointer to the HW structure</a>
<a name="ln5372"> *</a>
<a name="ln5373"> *  Calls the PHY specific link setup function and then calls the</a>
<a name="ln5374"> *  generic setup_copper_link to finish configuring the link for</a>
<a name="ln5375"> *  Lynxpoint PCH devices</a>
<a name="ln5376"> **/</a>
<a name="ln5377">static s32 e1000_setup_copper_link_pch_lpt(struct e1000_hw *hw)</a>
<a name="ln5378">{</a>
<a name="ln5379">	u32 ctrl;</a>
<a name="ln5380">	s32 ret_val;</a>
<a name="ln5381"> </a>
<a name="ln5382">	DEBUGFUNC(&quot;e1000_setup_copper_link_pch_lpt&quot;);</a>
<a name="ln5383"> </a>
<a name="ln5384">	ctrl = E1000_READ_REG(hw, E1000_CTRL);</a>
<a name="ln5385">	ctrl |= E1000_CTRL_SLU;</a>
<a name="ln5386">	ctrl &amp;= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);</a>
<a name="ln5387">	E1000_WRITE_REG(hw, E1000_CTRL, ctrl);</a>
<a name="ln5388"> </a>
<a name="ln5389">	ret_val = e1000_copper_link_setup_82577(hw);</a>
<a name="ln5390">	if (ret_val)</a>
<a name="ln5391">		return ret_val;</a>
<a name="ln5392"> </a>
<a name="ln5393">	return e1000_setup_copper_link_generic(hw);</a>
<a name="ln5394">}</a>
<a name="ln5395"> </a>
<a name="ln5396">/**</a>
<a name="ln5397"> *  e1000_get_link_up_info_ich8lan - Get current link speed and duplex</a>
<a name="ln5398"> *  @hw: pointer to the HW structure</a>
<a name="ln5399"> *  @speed: pointer to store current link speed</a>
<a name="ln5400"> *  @duplex: pointer to store the current link duplex</a>
<a name="ln5401"> *</a>
<a name="ln5402"> *  Calls the generic get_speed_and_duplex to retrieve the current link</a>
<a name="ln5403"> *  information and then calls the Kumeran lock loss workaround for links at</a>
<a name="ln5404"> *  gigabit speeds.</a>
<a name="ln5405"> **/</a>
<a name="ln5406">static s32 e1000_get_link_up_info_ich8lan(struct e1000_hw *hw, u16 *speed,</a>
<a name="ln5407">					  u16 *duplex)</a>
<a name="ln5408">{</a>
<a name="ln5409">	s32 ret_val;</a>
<a name="ln5410"> </a>
<a name="ln5411">	DEBUGFUNC(&quot;e1000_get_link_up_info_ich8lan&quot;);</a>
<a name="ln5412"> </a>
<a name="ln5413">	ret_val = e1000_get_speed_and_duplex_copper_generic(hw, speed, duplex);</a>
<a name="ln5414">	if (ret_val)</a>
<a name="ln5415">		return ret_val;</a>
<a name="ln5416"> </a>
<a name="ln5417">	if ((hw-&gt;mac.type == e1000_ich8lan) &amp;&amp;</a>
<a name="ln5418">	    (hw-&gt;phy.type == e1000_phy_igp_3) &amp;&amp;</a>
<a name="ln5419">	    (*speed == SPEED_1000)) {</a>
<a name="ln5420">		ret_val = e1000_kmrn_lock_loss_workaround_ich8lan(hw);</a>
<a name="ln5421">	}</a>
<a name="ln5422"> </a>
<a name="ln5423">	return ret_val;</a>
<a name="ln5424">}</a>
<a name="ln5425"> </a>
<a name="ln5426">/**</a>
<a name="ln5427"> *  e1000_kmrn_lock_loss_workaround_ich8lan - Kumeran workaround</a>
<a name="ln5428"> *  @hw: pointer to the HW structure</a>
<a name="ln5429"> *</a>
<a name="ln5430"> *  Work-around for 82566 Kumeran PCS lock loss:</a>
<a name="ln5431"> *  On link status change (i.e. PCI reset, speed change) and link is up and</a>
<a name="ln5432"> *  speed is gigabit-</a>
<a name="ln5433"> *    0) if workaround is optionally disabled do nothing</a>
<a name="ln5434"> *    1) wait 1ms for Kumeran link to come up</a>
<a name="ln5435"> *    2) check Kumeran Diagnostic register PCS lock loss bit</a>
<a name="ln5436"> *    3) if not set the link is locked (all is good), otherwise...</a>
<a name="ln5437"> *    4) reset the PHY</a>
<a name="ln5438"> *    5) repeat up to 10 times</a>
<a name="ln5439"> *  Note: this is only called for IGP3 copper when speed is 1gb.</a>
<a name="ln5440"> **/</a>
<a name="ln5441">static s32 e1000_kmrn_lock_loss_workaround_ich8lan(struct e1000_hw *hw)</a>
<a name="ln5442">{</a>
<a name="ln5443">	struct e1000_dev_spec_ich8lan *dev_spec = &amp;hw-&gt;dev_spec.ich8lan;</a>
<a name="ln5444">	u32 phy_ctrl;</a>
<a name="ln5445">	s32 ret_val;</a>
<a name="ln5446">	u16 i, data;</a>
<a name="ln5447">	bool link;</a>
<a name="ln5448"> </a>
<a name="ln5449">	DEBUGFUNC(&quot;e1000_kmrn_lock_loss_workaround_ich8lan&quot;);</a>
<a name="ln5450"> </a>
<a name="ln5451">	if (!dev_spec-&gt;kmrn_lock_loss_workaround_enabled)</a>
<a name="ln5452">		return E1000_SUCCESS;</a>
<a name="ln5453"> </a>
<a name="ln5454">	/* Make sure link is up before proceeding.  If not just return.</a>
<a name="ln5455">	 * Attempting this while link is negotiating fouled up link</a>
<a name="ln5456">	 * stability</a>
<a name="ln5457">	 */</a>
<a name="ln5458">	ret_val = e1000_phy_has_link_generic(hw, 1, 0, &amp;link);</a>
<a name="ln5459">	if (!link)</a>
<a name="ln5460">		return E1000_SUCCESS;</a>
<a name="ln5461"> </a>
<a name="ln5462">	for (i = 0; i &lt; 10; i++) {</a>
<a name="ln5463">		/* read once to clear */</a>
<a name="ln5464">		ret_val = hw-&gt;phy.ops.read_reg(hw, IGP3_KMRN_DIAG, &amp;data);</a>
<a name="ln5465">		if (ret_val)</a>
<a name="ln5466">			return ret_val;</a>
<a name="ln5467">		/* and again to get new status */</a>
<a name="ln5468">		ret_val = hw-&gt;phy.ops.read_reg(hw, IGP3_KMRN_DIAG, &amp;data);</a>
<a name="ln5469">		if (ret_val)</a>
<a name="ln5470">			return ret_val;</a>
<a name="ln5471"> </a>
<a name="ln5472">		/* check for PCS lock */</a>
<a name="ln5473">		if (!(data &amp; IGP3_KMRN_DIAG_PCS_LOCK_LOSS))</a>
<a name="ln5474">			return E1000_SUCCESS;</a>
<a name="ln5475"> </a>
<a name="ln5476">		/* Issue PHY reset */</a>
<a name="ln5477">		hw-&gt;phy.ops.reset(hw);</a>
<a name="ln5478">		msec_delay_irq(5);</a>
<a name="ln5479">	}</a>
<a name="ln5480">	/* Disable GigE link negotiation */</a>
<a name="ln5481">	phy_ctrl = E1000_READ_REG(hw, E1000_PHY_CTRL);</a>
<a name="ln5482">	phy_ctrl |= (E1000_PHY_CTRL_GBE_DISABLE |</a>
<a name="ln5483">		     E1000_PHY_CTRL_NOND0A_GBE_DISABLE);</a>
<a name="ln5484">	E1000_WRITE_REG(hw, E1000_PHY_CTRL, phy_ctrl);</a>
<a name="ln5485"> </a>
<a name="ln5486">	/* Call gig speed drop workaround on Gig disable before accessing</a>
<a name="ln5487">	 * any PHY registers</a>
<a name="ln5488">	 */</a>
<a name="ln5489">	e1000_gig_downshift_workaround_ich8lan(hw);</a>
<a name="ln5490"> </a>
<a name="ln5491">	/* unable to acquire PCS lock */</a>
<a name="ln5492">	return -E1000_ERR_PHY;</a>
<a name="ln5493">}</a>
<a name="ln5494"> </a>
<a name="ln5495">/**</a>
<a name="ln5496"> *  e1000_set_kmrn_lock_loss_workaround_ich8lan - Set Kumeran workaround state</a>
<a name="ln5497"> *  @hw: pointer to the HW structure</a>
<a name="ln5498"> *  @state: boolean value used to set the current Kumeran workaround state</a>
<a name="ln5499"> *</a>
<a name="ln5500"> *  If ICH8, set the current Kumeran workaround state (enabled - TRUE</a>
<a name="ln5501"> *  /disabled - FALSE).</a>
<a name="ln5502"> **/</a>
<a name="ln5503">void e1000_set_kmrn_lock_loss_workaround_ich8lan(struct e1000_hw *hw,</a>
<a name="ln5504">						 bool state)</a>
<a name="ln5505">{</a>
<a name="ln5506">	struct e1000_dev_spec_ich8lan *dev_spec = &amp;hw-&gt;dev_spec.ich8lan;</a>
<a name="ln5507"> </a>
<a name="ln5508">	DEBUGFUNC(&quot;e1000_set_kmrn_lock_loss_workaround_ich8lan&quot;);</a>
<a name="ln5509"> </a>
<a name="ln5510">	if (hw-&gt;mac.type != e1000_ich8lan) {</a>
<a name="ln5511">		DEBUGOUT(&quot;Workaround applies to ICH8 only.\n&quot;);</a>
<a name="ln5512">		return;</a>
<a name="ln5513">	}</a>
<a name="ln5514"> </a>
<a name="ln5515">	dev_spec-&gt;kmrn_lock_loss_workaround_enabled = state;</a>
<a name="ln5516"> </a>
<a name="ln5517">	return;</a>
<a name="ln5518">}</a>
<a name="ln5519"> </a>
<a name="ln5520">/**</a>
<a name="ln5521"> *  e1000_ipg3_phy_powerdown_workaround_ich8lan - Power down workaround on D3</a>
<a name="ln5522"> *  @hw: pointer to the HW structure</a>
<a name="ln5523"> *</a>
<a name="ln5524"> *  Workaround for 82566 power-down on D3 entry:</a>
<a name="ln5525"> *    1) disable gigabit link</a>
<a name="ln5526"> *    2) write VR power-down enable</a>
<a name="ln5527"> *    3) read it back</a>
<a name="ln5528"> *  Continue if successful, else issue LCD reset and repeat</a>
<a name="ln5529"> **/</a>
<a name="ln5530">void e1000_igp3_phy_powerdown_workaround_ich8lan(struct e1000_hw *hw)</a>
<a name="ln5531">{</a>
<a name="ln5532">	u32 reg;</a>
<a name="ln5533">	u16 data;</a>
<a name="ln5534">	u8  retry = 0;</a>
<a name="ln5535"> </a>
<a name="ln5536">	DEBUGFUNC(&quot;e1000_igp3_phy_powerdown_workaround_ich8lan&quot;);</a>
<a name="ln5537"> </a>
<a name="ln5538">	if (hw-&gt;phy.type != e1000_phy_igp_3)</a>
<a name="ln5539">		return;</a>
<a name="ln5540"> </a>
<a name="ln5541">	/* Try the workaround twice (if needed) */</a>
<a name="ln5542">	do {</a>
<a name="ln5543">		/* Disable link */</a>
<a name="ln5544">		reg = E1000_READ_REG(hw, E1000_PHY_CTRL);</a>
<a name="ln5545">		reg |= (E1000_PHY_CTRL_GBE_DISABLE |</a>
<a name="ln5546">			E1000_PHY_CTRL_NOND0A_GBE_DISABLE);</a>
<a name="ln5547">		E1000_WRITE_REG(hw, E1000_PHY_CTRL, reg);</a>
<a name="ln5548"> </a>
<a name="ln5549">		/* Call gig speed drop workaround on Gig disable before</a>
<a name="ln5550">		 * accessing any PHY registers</a>
<a name="ln5551">		 */</a>
<a name="ln5552">		if (hw-&gt;mac.type == e1000_ich8lan)</a>
<a name="ln5553">			e1000_gig_downshift_workaround_ich8lan(hw);</a>
<a name="ln5554"> </a>
<a name="ln5555">		/* Write VR power-down enable */</a>
<a name="ln5556">		hw-&gt;phy.ops.read_reg(hw, IGP3_VR_CTRL, &amp;data);</a>
<a name="ln5557">		data &amp;= ~IGP3_VR_CTRL_DEV_POWERDOWN_MODE_MASK;</a>
<a name="ln5558">		hw-&gt;phy.ops.write_reg(hw, IGP3_VR_CTRL,</a>
<a name="ln5559">				      data | IGP3_VR_CTRL_MODE_SHUTDOWN);</a>
<a name="ln5560"> </a>
<a name="ln5561">		/* Read it back and test */</a>
<a name="ln5562">		hw-&gt;phy.ops.read_reg(hw, IGP3_VR_CTRL, &amp;data);</a>
<a name="ln5563">		data &amp;= IGP3_VR_CTRL_DEV_POWERDOWN_MODE_MASK;</a>
<a name="ln5564">		if ((data == IGP3_VR_CTRL_MODE_SHUTDOWN) || retry)</a>
<a name="ln5565">			break;</a>
<a name="ln5566"> </a>
<a name="ln5567">		/* Issue PHY reset and repeat at most one more time */</a>
<a name="ln5568">		reg = E1000_READ_REG(hw, E1000_CTRL);</a>
<a name="ln5569">		E1000_WRITE_REG(hw, E1000_CTRL, reg | E1000_CTRL_PHY_RST);</a>
<a name="ln5570">		retry++;</a>
<a name="ln5571">	} while (retry);</a>
<a name="ln5572">}</a>
<a name="ln5573"> </a>
<a name="ln5574">/**</a>
<a name="ln5575"> *  e1000_gig_downshift_workaround_ich8lan - WoL from S5 stops working</a>
<a name="ln5576"> *  @hw: pointer to the HW structure</a>
<a name="ln5577"> *</a>
<a name="ln5578"> *  Steps to take when dropping from 1Gb/s (eg. link cable removal (LSC),</a>
<a name="ln5579"> *  LPLU, Gig disable, MDIC PHY reset):</a>
<a name="ln5580"> *    1) Set Kumeran Near-end loopback</a>
<a name="ln5581"> *    2) Clear Kumeran Near-end loopback</a>
<a name="ln5582"> *  Should only be called for ICH8[m] devices with any 1G Phy.</a>
<a name="ln5583"> **/</a>
<a name="ln5584">void e1000_gig_downshift_workaround_ich8lan(struct e1000_hw *hw)</a>
<a name="ln5585">{</a>
<a name="ln5586">	s32 ret_val;</a>
<a name="ln5587">	u16 reg_data;</a>
<a name="ln5588"> </a>
<a name="ln5589">	DEBUGFUNC(&quot;e1000_gig_downshift_workaround_ich8lan&quot;);</a>
<a name="ln5590"> </a>
<a name="ln5591">	if ((hw-&gt;mac.type != e1000_ich8lan) ||</a>
<a name="ln5592">	    (hw-&gt;phy.type == e1000_phy_ife))</a>
<a name="ln5593">		return;</a>
<a name="ln5594"> </a>
<a name="ln5595">	ret_val = e1000_read_kmrn_reg_generic(hw, E1000_KMRNCTRLSTA_DIAG_OFFSET,</a>
<a name="ln5596">					      &amp;reg_data);</a>
<a name="ln5597">	if (ret_val)</a>
<a name="ln5598">		return;</a>
<a name="ln5599">	reg_data |= E1000_KMRNCTRLSTA_DIAG_NELPBK;</a>
<a name="ln5600">	ret_val = e1000_write_kmrn_reg_generic(hw,</a>
<a name="ln5601">					       E1000_KMRNCTRLSTA_DIAG_OFFSET,</a>
<a name="ln5602">					       reg_data);</a>
<a name="ln5603">	if (ret_val)</a>
<a name="ln5604">		return;</a>
<a name="ln5605">	reg_data &amp;= ~E1000_KMRNCTRLSTA_DIAG_NELPBK;</a>
<a name="ln5606">	e1000_write_kmrn_reg_generic(hw, E1000_KMRNCTRLSTA_DIAG_OFFSET,</a>
<a name="ln5607">				     reg_data);</a>
<a name="ln5608">}</a>
<a name="ln5609"> </a>
<a name="ln5610">/**</a>
<a name="ln5611"> *  e1000_suspend_workarounds_ich8lan - workarounds needed during S0-&gt;Sx</a>
<a name="ln5612"> *  @hw: pointer to the HW structure</a>
<a name="ln5613"> *</a>
<a name="ln5614"> *  During S0 to Sx transition, it is possible the link remains at gig</a>
<a name="ln5615"> *  instead of negotiating to a lower speed.  Before going to Sx, set</a>
<a name="ln5616"> *  'Gig Disable' to force link speed negotiation to a lower speed based on</a>
<a name="ln5617"> *  the LPLU setting in the NVM or custom setting.  For PCH and newer parts,</a>
<a name="ln5618"> *  the OEM bits PHY register (LED, GbE disable and LPLU configurations) also</a>
<a name="ln5619"> *  needs to be written.</a>
<a name="ln5620"> *  Parts that support (and are linked to a partner which support) EEE in</a>
<a name="ln5621"> *  100Mbps should disable LPLU since 100Mbps w/ EEE requires less power</a>
<a name="ln5622"> *  than 10Mbps w/o EEE.</a>
<a name="ln5623"> **/</a>
<a name="ln5624">void e1000_suspend_workarounds_ich8lan(struct e1000_hw *hw)</a>
<a name="ln5625">{</a>
<a name="ln5626">	struct e1000_dev_spec_ich8lan *dev_spec = &amp;hw-&gt;dev_spec.ich8lan;</a>
<a name="ln5627">	u32 phy_ctrl;</a>
<a name="ln5628">	s32 ret_val;</a>
<a name="ln5629"> </a>
<a name="ln5630">	DEBUGFUNC(&quot;e1000_suspend_workarounds_ich8lan&quot;);</a>
<a name="ln5631"> </a>
<a name="ln5632">	phy_ctrl = E1000_READ_REG(hw, E1000_PHY_CTRL);</a>
<a name="ln5633">	phy_ctrl |= E1000_PHY_CTRL_GBE_DISABLE;</a>
<a name="ln5634"> </a>
<a name="ln5635">	if (hw-&gt;phy.type == e1000_phy_i217) {</a>
<a name="ln5636">		u16 phy_reg, device_id = hw-&gt;device_id;</a>
<a name="ln5637"> </a>
<a name="ln5638">		if ((device_id == E1000_DEV_ID_PCH_LPTLP_I218_LM) ||</a>
<a name="ln5639">		    (device_id == E1000_DEV_ID_PCH_LPTLP_I218_V) ||</a>
<a name="ln5640">		    (device_id == E1000_DEV_ID_PCH_I218_LM3) ||</a>
<a name="ln5641">		    (device_id == E1000_DEV_ID_PCH_I218_V3) ||</a>
<a name="ln5642">		    (hw-&gt;mac.type &gt;= e1000_pch_spt)) {</a>
<a name="ln5643">			u32 fextnvm6 = E1000_READ_REG(hw, E1000_FEXTNVM6);</a>
<a name="ln5644"> </a>
<a name="ln5645">			E1000_WRITE_REG(hw, E1000_FEXTNVM6,</a>
<a name="ln5646">					fextnvm6 &amp; ~E1000_FEXTNVM6_REQ_PLL_CLK);</a>
<a name="ln5647">		}</a>
<a name="ln5648"> </a>
<a name="ln5649">		ret_val = hw-&gt;phy.ops.acquire(hw);</a>
<a name="ln5650">		if (ret_val)</a>
<a name="ln5651">			goto out;</a>
<a name="ln5652"> </a>
<a name="ln5653">		if (!dev_spec-&gt;eee_disable) {</a>
<a name="ln5654">			u16 eee_advert;</a>
<a name="ln5655"> </a>
<a name="ln5656">			ret_val =</a>
<a name="ln5657">			    e1000_read_emi_reg_locked(hw,</a>
<a name="ln5658">						      I217_EEE_ADVERTISEMENT,</a>
<a name="ln5659">						      &amp;eee_advert);</a>
<a name="ln5660">			if (ret_val)</a>
<a name="ln5661">				goto release;</a>
<a name="ln5662"> </a>
<a name="ln5663">			/* Disable LPLU if both link partners support 100BaseT</a>
<a name="ln5664">			 * EEE and 100Full is advertised on both ends of the</a>
<a name="ln5665">			 * link, and enable Auto Enable LPI since there will</a>
<a name="ln5666">			 * be no driver to enable LPI while in Sx.</a>
<a name="ln5667">			 */</a>
<a name="ln5668">			if ((eee_advert &amp; I82579_EEE_100_SUPPORTED) &amp;&amp;</a>
<a name="ln5669">			    (dev_spec-&gt;eee_lp_ability &amp;</a>
<a name="ln5670">			     I82579_EEE_100_SUPPORTED) &amp;&amp;</a>
<a name="ln5671">			    (hw-&gt;phy.autoneg_advertised &amp; ADVERTISE_100_FULL)) {</a>
<a name="ln5672">				phy_ctrl &amp;= ~(E1000_PHY_CTRL_D0A_LPLU |</a>
<a name="ln5673">					      E1000_PHY_CTRL_NOND0A_LPLU);</a>
<a name="ln5674"> </a>
<a name="ln5675">				/* Set Auto Enable LPI after link up */</a>
<a name="ln5676">				hw-&gt;phy.ops.read_reg_locked(hw,</a>
<a name="ln5677">							    I217_LPI_GPIO_CTRL,</a>
<a name="ln5678">							    &amp;phy_reg);</a>
<a name="ln5679">				phy_reg |= I217_LPI_GPIO_CTRL_AUTO_EN_LPI;</a>
<a name="ln5680">				hw-&gt;phy.ops.write_reg_locked(hw,</a>
<a name="ln5681">							     I217_LPI_GPIO_CTRL,</a>
<a name="ln5682">							     phy_reg);</a>
<a name="ln5683">			}</a>
<a name="ln5684">		}</a>
<a name="ln5685"> </a>
<a name="ln5686">		/* For i217 Intel Rapid Start Technology support,</a>
<a name="ln5687">		 * when the system is going into Sx and no manageability engine</a>
<a name="ln5688">		 * is present, the driver must configure proxy to reset only on</a>
<a name="ln5689">		 * power good.  LPI (Low Power Idle) state must also reset only</a>
<a name="ln5690">		 * on power good, as well as the MTA (Multicast table array).</a>
<a name="ln5691">		 * The SMBus release must also be disabled on LCD reset.</a>
<a name="ln5692">		 */</a>
<a name="ln5693">		if (!(E1000_READ_REG(hw, E1000_FWSM) &amp;</a>
<a name="ln5694">		      E1000_ICH_FWSM_FW_VALID)) {</a>
<a name="ln5695">			/* Enable proxy to reset only on power good. */</a>
<a name="ln5696">			hw-&gt;phy.ops.read_reg_locked(hw, I217_PROXY_CTRL,</a>
<a name="ln5697">						    &amp;phy_reg);</a>
<a name="ln5698">			phy_reg |= I217_PROXY_CTRL_AUTO_DISABLE;</a>
<a name="ln5699">			hw-&gt;phy.ops.write_reg_locked(hw, I217_PROXY_CTRL,</a>
<a name="ln5700">						     phy_reg);</a>
<a name="ln5701"> </a>
<a name="ln5702">			/* Set bit enable LPI (EEE) to reset only on</a>
<a name="ln5703">			 * power good.</a>
<a name="ln5704">			*/</a>
<a name="ln5705">			hw-&gt;phy.ops.read_reg_locked(hw, I217_SxCTRL, &amp;phy_reg);</a>
<a name="ln5706">			phy_reg |= I217_SxCTRL_ENABLE_LPI_RESET;</a>
<a name="ln5707">			hw-&gt;phy.ops.write_reg_locked(hw, I217_SxCTRL, phy_reg);</a>
<a name="ln5708"> </a>
<a name="ln5709">			/* Disable the SMB release on LCD reset. */</a>
<a name="ln5710">			hw-&gt;phy.ops.read_reg_locked(hw, I217_MEMPWR, &amp;phy_reg);</a>
<a name="ln5711">			phy_reg &amp;= ~I217_MEMPWR_DISABLE_SMB_RELEASE;</a>
<a name="ln5712">			hw-&gt;phy.ops.write_reg_locked(hw, I217_MEMPWR, phy_reg);</a>
<a name="ln5713">		}</a>
<a name="ln5714"> </a>
<a name="ln5715">		/* Enable MTA to reset for Intel Rapid Start Technology</a>
<a name="ln5716">		 * Support</a>
<a name="ln5717">		 */</a>
<a name="ln5718">		hw-&gt;phy.ops.read_reg_locked(hw, I217_CGFREG, &amp;phy_reg);</a>
<a name="ln5719">		phy_reg |= I217_CGFREG_ENABLE_MTA_RESET;</a>
<a name="ln5720">		hw-&gt;phy.ops.write_reg_locked(hw, I217_CGFREG, phy_reg);</a>
<a name="ln5721"> </a>
<a name="ln5722">release:</a>
<a name="ln5723">		hw-&gt;phy.ops.release(hw);</a>
<a name="ln5724">	}</a>
<a name="ln5725">out:</a>
<a name="ln5726">	E1000_WRITE_REG(hw, E1000_PHY_CTRL, phy_ctrl);</a>
<a name="ln5727"> </a>
<a name="ln5728">	if (hw-&gt;mac.type == e1000_ich8lan)</a>
<a name="ln5729">		e1000_gig_downshift_workaround_ich8lan(hw);</a>
<a name="ln5730"> </a>
<a name="ln5731">	if (hw-&gt;mac.type &gt;= e1000_pchlan) {</a>
<a name="ln5732">		e1000_oem_bits_config_ich8lan(hw, FALSE);</a>
<a name="ln5733"> </a>
<a name="ln5734">		/* Reset PHY to activate OEM bits on 82577/8 */</a>
<a name="ln5735">		if (hw-&gt;mac.type == e1000_pchlan)</a>
<a name="ln5736">			e1000_phy_hw_reset_generic(hw);</a>
<a name="ln5737"> </a>
<a name="ln5738">		ret_val = hw-&gt;phy.ops.acquire(hw);</a>
<a name="ln5739">		if (ret_val)</a>
<a name="ln5740">			return;</a>
<a name="ln5741">		e1000_write_smbus_addr(hw);</a>
<a name="ln5742">		hw-&gt;phy.ops.release(hw);</a>
<a name="ln5743">	}</a>
<a name="ln5744"> </a>
<a name="ln5745">	return;</a>
<a name="ln5746">}</a>
<a name="ln5747"> </a>
<a name="ln5748">/**</a>
<a name="ln5749"> *  e1000_resume_workarounds_pchlan - workarounds needed during Sx-&gt;S0</a>
<a name="ln5750"> *  @hw: pointer to the HW structure</a>
<a name="ln5751"> *</a>
<a name="ln5752"> *  During Sx to S0 transitions on non-managed devices or managed devices</a>
<a name="ln5753"> *  on which PHY resets are not blocked, if the PHY registers cannot be</a>
<a name="ln5754"> *  accessed properly by the s/w toggle the LANPHYPC value to power cycle</a>
<a name="ln5755"> *  the PHY.</a>
<a name="ln5756"> *  On i217, setup Intel Rapid Start Technology.</a>
<a name="ln5757"> **/</a>
<a name="ln5758">u32 e1000_resume_workarounds_pchlan(struct e1000_hw *hw)</a>
<a name="ln5759">{</a>
<a name="ln5760">	s32 ret_val;</a>
<a name="ln5761"> </a>
<a name="ln5762">	DEBUGFUNC(&quot;e1000_resume_workarounds_pchlan&quot;);</a>
<a name="ln5763">	if (hw-&gt;mac.type &lt; e1000_pch2lan)</a>
<a name="ln5764">		return E1000_SUCCESS;</a>
<a name="ln5765"> </a>
<a name="ln5766">	ret_val = e1000_init_phy_workarounds_pchlan(hw);</a>
<a name="ln5767">	if (ret_val) {</a>
<a name="ln5768">		DEBUGOUT1(&quot;Failed to init PHY flow ret_val=%d\n&quot;, ret_val);</a>
<a name="ln5769">		return ret_val;</a>
<a name="ln5770">	}</a>
<a name="ln5771"> </a>
<a name="ln5772">	/* For i217 Intel Rapid Start Technology support when the system</a>
<a name="ln5773">	 * is transitioning from Sx and no manageability engine is present</a>
<a name="ln5774">	 * configure SMBus to restore on reset, disable proxy, and enable</a>
<a name="ln5775">	 * the reset on MTA (Multicast table array).</a>
<a name="ln5776">	 */</a>
<a name="ln5777">	if (hw-&gt;phy.type == e1000_phy_i217) {</a>
<a name="ln5778">		u16 phy_reg;</a>
<a name="ln5779"> </a>
<a name="ln5780">		ret_val = hw-&gt;phy.ops.acquire(hw);</a>
<a name="ln5781">		if (ret_val) {</a>
<a name="ln5782">			DEBUGOUT(&quot;Failed to setup iRST\n&quot;);</a>
<a name="ln5783">			return ret_val;</a>
<a name="ln5784">		}</a>
<a name="ln5785"> </a>
<a name="ln5786">		/* Clear Auto Enable LPI after link up */</a>
<a name="ln5787">		hw-&gt;phy.ops.read_reg_locked(hw, I217_LPI_GPIO_CTRL, &amp;phy_reg);</a>
<a name="ln5788">		phy_reg &amp;= ~I217_LPI_GPIO_CTRL_AUTO_EN_LPI;</a>
<a name="ln5789">		hw-&gt;phy.ops.write_reg_locked(hw, I217_LPI_GPIO_CTRL, phy_reg);</a>
<a name="ln5790"> </a>
<a name="ln5791">		if (!(E1000_READ_REG(hw, E1000_FWSM) &amp;</a>
<a name="ln5792">		    E1000_ICH_FWSM_FW_VALID)) {</a>
<a name="ln5793">			/* Restore clear on SMB if no manageability engine</a>
<a name="ln5794">			 * is present</a>
<a name="ln5795">			 */</a>
<a name="ln5796">			ret_val = hw-&gt;phy.ops.read_reg_locked(hw, I217_MEMPWR,</a>
<a name="ln5797">							      &amp;phy_reg);</a>
<a name="ln5798">			if (ret_val)</a>
<a name="ln5799">				goto release;</a>
<a name="ln5800">			phy_reg |= I217_MEMPWR_DISABLE_SMB_RELEASE;</a>
<a name="ln5801">			hw-&gt;phy.ops.write_reg_locked(hw, I217_MEMPWR, phy_reg);</a>
<a name="ln5802"> </a>
<a name="ln5803">			/* Disable Proxy */</a>
<a name="ln5804">			hw-&gt;phy.ops.write_reg_locked(hw, I217_PROXY_CTRL, 0);</a>
<a name="ln5805">		}</a>
<a name="ln5806">		/* Enable reset on MTA */</a>
<a name="ln5807">		ret_val = hw-&gt;phy.ops.read_reg_locked(hw, I217_CGFREG,</a>
<a name="ln5808">						      &amp;phy_reg);</a>
<a name="ln5809">		if (ret_val)</a>
<a name="ln5810">			goto release;</a>
<a name="ln5811">		phy_reg &amp;= ~I217_CGFREG_ENABLE_MTA_RESET;</a>
<a name="ln5812">		hw-&gt;phy.ops.write_reg_locked(hw, I217_CGFREG, phy_reg);</a>
<a name="ln5813">release:</a>
<a name="ln5814">		if (ret_val)</a>
<a name="ln5815">			DEBUGOUT1(&quot;Error %d in resume workarounds\n&quot;, ret_val);</a>
<a name="ln5816">		hw-&gt;phy.ops.release(hw);</a>
<a name="ln5817">		return ret_val;</a>
<a name="ln5818">	}</a>
<a name="ln5819">	return E1000_SUCCESS;</a>
<a name="ln5820">}</a>
<a name="ln5821"> </a>
<a name="ln5822">/**</a>
<a name="ln5823"> *  e1000_cleanup_led_ich8lan - Restore the default LED operation</a>
<a name="ln5824"> *  @hw: pointer to the HW structure</a>
<a name="ln5825"> *</a>
<a name="ln5826"> *  Return the LED back to the default configuration.</a>
<a name="ln5827"> **/</a>
<a name="ln5828">static s32 e1000_cleanup_led_ich8lan(struct e1000_hw *hw)</a>
<a name="ln5829">{</a>
<a name="ln5830">	DEBUGFUNC(&quot;e1000_cleanup_led_ich8lan&quot;);</a>
<a name="ln5831"> </a>
<a name="ln5832">	if (hw-&gt;phy.type == e1000_phy_ife)</a>
<a name="ln5833">		return hw-&gt;phy.ops.write_reg(hw, IFE_PHY_SPECIAL_CONTROL_LED,</a>
<a name="ln5834">					     0);</a>
<a name="ln5835"> </a>
<a name="ln5836">	E1000_WRITE_REG(hw, E1000_LEDCTL, hw-&gt;mac.ledctl_default);</a>
<a name="ln5837">	return E1000_SUCCESS;</a>
<a name="ln5838">}</a>
<a name="ln5839"> </a>
<a name="ln5840">/**</a>
<a name="ln5841"> *  e1000_led_on_ich8lan - Turn LEDs on</a>
<a name="ln5842"> *  @hw: pointer to the HW structure</a>
<a name="ln5843"> *</a>
<a name="ln5844"> *  Turn on the LEDs.</a>
<a name="ln5845"> **/</a>
<a name="ln5846">static s32 e1000_led_on_ich8lan(struct e1000_hw *hw)</a>
<a name="ln5847">{</a>
<a name="ln5848">	DEBUGFUNC(&quot;e1000_led_on_ich8lan&quot;);</a>
<a name="ln5849"> </a>
<a name="ln5850">	if (hw-&gt;phy.type == e1000_phy_ife)</a>
<a name="ln5851">		return hw-&gt;phy.ops.write_reg(hw, IFE_PHY_SPECIAL_CONTROL_LED,</a>
<a name="ln5852">				(IFE_PSCL_PROBE_MODE | IFE_PSCL_PROBE_LEDS_ON));</a>
<a name="ln5853"> </a>
<a name="ln5854">	E1000_WRITE_REG(hw, E1000_LEDCTL, hw-&gt;mac.ledctl_mode2);</a>
<a name="ln5855">	return E1000_SUCCESS;</a>
<a name="ln5856">}</a>
<a name="ln5857"> </a>
<a name="ln5858">/**</a>
<a name="ln5859"> *  e1000_led_off_ich8lan - Turn LEDs off</a>
<a name="ln5860"> *  @hw: pointer to the HW structure</a>
<a name="ln5861"> *</a>
<a name="ln5862"> *  Turn off the LEDs.</a>
<a name="ln5863"> **/</a>
<a name="ln5864">static s32 e1000_led_off_ich8lan(struct e1000_hw *hw)</a>
<a name="ln5865">{</a>
<a name="ln5866">	DEBUGFUNC(&quot;e1000_led_off_ich8lan&quot;);</a>
<a name="ln5867"> </a>
<a name="ln5868">	if (hw-&gt;phy.type == e1000_phy_ife)</a>
<a name="ln5869">		return hw-&gt;phy.ops.write_reg(hw, IFE_PHY_SPECIAL_CONTROL_LED,</a>
<a name="ln5870">			       (IFE_PSCL_PROBE_MODE | IFE_PSCL_PROBE_LEDS_OFF));</a>
<a name="ln5871"> </a>
<a name="ln5872">	E1000_WRITE_REG(hw, E1000_LEDCTL, hw-&gt;mac.ledctl_mode1);</a>
<a name="ln5873">	return E1000_SUCCESS;</a>
<a name="ln5874">}</a>
<a name="ln5875"> </a>
<a name="ln5876">/**</a>
<a name="ln5877"> *  e1000_setup_led_pchlan - Configures SW controllable LED</a>
<a name="ln5878"> *  @hw: pointer to the HW structure</a>
<a name="ln5879"> *</a>
<a name="ln5880"> *  This prepares the SW controllable LED for use.</a>
<a name="ln5881"> **/</a>
<a name="ln5882">static s32 e1000_setup_led_pchlan(struct e1000_hw *hw)</a>
<a name="ln5883">{</a>
<a name="ln5884">	DEBUGFUNC(&quot;e1000_setup_led_pchlan&quot;);</a>
<a name="ln5885"> </a>
<a name="ln5886">	return hw-&gt;phy.ops.write_reg(hw, HV_LED_CONFIG,</a>
<a name="ln5887">				     (u16)hw-&gt;mac.ledctl_mode1);</a>
<a name="ln5888">}</a>
<a name="ln5889"> </a>
<a name="ln5890">/**</a>
<a name="ln5891"> *  e1000_cleanup_led_pchlan - Restore the default LED operation</a>
<a name="ln5892"> *  @hw: pointer to the HW structure</a>
<a name="ln5893"> *</a>
<a name="ln5894"> *  Return the LED back to the default configuration.</a>
<a name="ln5895"> **/</a>
<a name="ln5896">static s32 e1000_cleanup_led_pchlan(struct e1000_hw *hw)</a>
<a name="ln5897">{</a>
<a name="ln5898">	DEBUGFUNC(&quot;e1000_cleanup_led_pchlan&quot;);</a>
<a name="ln5899"> </a>
<a name="ln5900">	return hw-&gt;phy.ops.write_reg(hw, HV_LED_CONFIG,</a>
<a name="ln5901">				     (u16)hw-&gt;mac.ledctl_default);</a>
<a name="ln5902">}</a>
<a name="ln5903"> </a>
<a name="ln5904">/**</a>
<a name="ln5905"> *  e1000_led_on_pchlan - Turn LEDs on</a>
<a name="ln5906"> *  @hw: pointer to the HW structure</a>
<a name="ln5907"> *</a>
<a name="ln5908"> *  Turn on the LEDs.</a>
<a name="ln5909"> **/</a>
<a name="ln5910">static s32 e1000_led_on_pchlan(struct e1000_hw *hw)</a>
<a name="ln5911">{</a>
<a name="ln5912">	u16 data = (u16)hw-&gt;mac.ledctl_mode2;</a>
<a name="ln5913">	u32 i, led;</a>
<a name="ln5914"> </a>
<a name="ln5915">	DEBUGFUNC(&quot;e1000_led_on_pchlan&quot;);</a>
<a name="ln5916"> </a>
<a name="ln5917">	/* If no link, then turn LED on by setting the invert bit</a>
<a name="ln5918">	 * for each LED that's mode is &quot;link_up&quot; in ledctl_mode2.</a>
<a name="ln5919">	 */</a>
<a name="ln5920">	if (!(E1000_READ_REG(hw, E1000_STATUS) &amp; E1000_STATUS_LU)) {</a>
<a name="ln5921">		for (i = 0; i &lt; 3; i++) {</a>
<a name="ln5922">			led = (data &gt;&gt; (i * 5)) &amp; E1000_PHY_LED0_MASK;</a>
<a name="ln5923">			if ((led &amp; E1000_PHY_LED0_MODE_MASK) !=</a>
<a name="ln5924">			    E1000_LEDCTL_MODE_LINK_UP)</a>
<a name="ln5925">				continue;</a>
<a name="ln5926">			if (led &amp; E1000_PHY_LED0_IVRT)</a>
<a name="ln5927">				data &amp;= ~(E1000_PHY_LED0_IVRT &lt;&lt; (i * 5));</a>
<a name="ln5928">			else</a>
<a name="ln5929">				data |= (E1000_PHY_LED0_IVRT &lt;&lt; (i * 5));</a>
<a name="ln5930">		}</a>
<a name="ln5931">	}</a>
<a name="ln5932"> </a>
<a name="ln5933">	return hw-&gt;phy.ops.write_reg(hw, HV_LED_CONFIG, data);</a>
<a name="ln5934">}</a>
<a name="ln5935"> </a>
<a name="ln5936">/**</a>
<a name="ln5937"> *  e1000_led_off_pchlan - Turn LEDs off</a>
<a name="ln5938"> *  @hw: pointer to the HW structure</a>
<a name="ln5939"> *</a>
<a name="ln5940"> *  Turn off the LEDs.</a>
<a name="ln5941"> **/</a>
<a name="ln5942">static s32 e1000_led_off_pchlan(struct e1000_hw *hw)</a>
<a name="ln5943">{</a>
<a name="ln5944">	u16 data = (u16)hw-&gt;mac.ledctl_mode1;</a>
<a name="ln5945">	u32 i, led;</a>
<a name="ln5946"> </a>
<a name="ln5947">	DEBUGFUNC(&quot;e1000_led_off_pchlan&quot;);</a>
<a name="ln5948"> </a>
<a name="ln5949">	/* If no link, then turn LED off by clearing the invert bit</a>
<a name="ln5950">	 * for each LED that's mode is &quot;link_up&quot; in ledctl_mode1.</a>
<a name="ln5951">	 */</a>
<a name="ln5952">	if (!(E1000_READ_REG(hw, E1000_STATUS) &amp; E1000_STATUS_LU)) {</a>
<a name="ln5953">		for (i = 0; i &lt; 3; i++) {</a>
<a name="ln5954">			led = (data &gt;&gt; (i * 5)) &amp; E1000_PHY_LED0_MASK;</a>
<a name="ln5955">			if ((led &amp; E1000_PHY_LED0_MODE_MASK) !=</a>
<a name="ln5956">			    E1000_LEDCTL_MODE_LINK_UP)</a>
<a name="ln5957">				continue;</a>
<a name="ln5958">			if (led &amp; E1000_PHY_LED0_IVRT)</a>
<a name="ln5959">				data &amp;= ~(E1000_PHY_LED0_IVRT &lt;&lt; (i * 5));</a>
<a name="ln5960">			else</a>
<a name="ln5961">				data |= (E1000_PHY_LED0_IVRT &lt;&lt; (i * 5));</a>
<a name="ln5962">		}</a>
<a name="ln5963">	}</a>
<a name="ln5964"> </a>
<a name="ln5965">	return hw-&gt;phy.ops.write_reg(hw, HV_LED_CONFIG, data);</a>
<a name="ln5966">}</a>
<a name="ln5967"> </a>
<a name="ln5968">/**</a>
<a name="ln5969"> *  e1000_get_cfg_done_ich8lan - Read config done bit after Full or PHY reset</a>
<a name="ln5970"> *  @hw: pointer to the HW structure</a>
<a name="ln5971"> *</a>
<a name="ln5972"> *  Read appropriate register for the config done bit for completion status</a>
<a name="ln5973"> *  and configure the PHY through s/w for EEPROM-less parts.</a>
<a name="ln5974"> *</a>
<a name="ln5975"> *  NOTE: some silicon which is EEPROM-less will fail trying to read the</a>
<a name="ln5976"> *  config done bit, so only an error is logged and continues.  If we were</a>
<a name="ln5977"> *  to return with error, EEPROM-less silicon would not be able to be reset</a>
<a name="ln5978"> *  or change link.</a>
<a name="ln5979"> **/</a>
<a name="ln5980">static s32 e1000_get_cfg_done_ich8lan(struct e1000_hw *hw)</a>
<a name="ln5981">{</a>
<a name="ln5982">	s32 ret_val = E1000_SUCCESS;</a>
<a name="ln5983">	u32 bank = 0;</a>
<a name="ln5984">	u32 status;</a>
<a name="ln5985"> </a>
<a name="ln5986">	DEBUGFUNC(&quot;e1000_get_cfg_done_ich8lan&quot;);</a>
<a name="ln5987"> </a>
<a name="ln5988">	e1000_get_cfg_done_generic(hw);</a>
<a name="ln5989"> </a>
<a name="ln5990">	/* Wait for indication from h/w that it has completed basic config */</a>
<a name="ln5991">	if (hw-&gt;mac.type &gt;= e1000_ich10lan) {</a>
<a name="ln5992">		e1000_lan_init_done_ich8lan(hw);</a>
<a name="ln5993">	} else {</a>
<a name="ln5994">		ret_val = e1000_get_auto_rd_done_generic(hw);</a>
<a name="ln5995">		if (ret_val) {</a>
<a name="ln5996">			/* When auto config read does not complete, do not</a>
<a name="ln5997">			 * return with an error. This can happen in situations</a>
<a name="ln5998">			 * where there is no eeprom and prevents getting link.</a>
<a name="ln5999">			 */</a>
<a name="ln6000">			DEBUGOUT(&quot;Auto Read Done did not complete\n&quot;);</a>
<a name="ln6001">			ret_val = E1000_SUCCESS;</a>
<a name="ln6002">		}</a>
<a name="ln6003">	}</a>
<a name="ln6004"> </a>
<a name="ln6005">	/* Clear PHY Reset Asserted bit */</a>
<a name="ln6006">	status = E1000_READ_REG(hw, E1000_STATUS);</a>
<a name="ln6007">	if (status &amp; E1000_STATUS_PHYRA)</a>
<a name="ln6008">		E1000_WRITE_REG(hw, E1000_STATUS, status &amp; ~E1000_STATUS_PHYRA);</a>
<a name="ln6009">	else</a>
<a name="ln6010">		DEBUGOUT(&quot;PHY Reset Asserted not set - needs delay\n&quot;);</a>
<a name="ln6011"> </a>
<a name="ln6012">	/* If EEPROM is not marked present, init the IGP 3 PHY manually */</a>
<a name="ln6013">	if (hw-&gt;mac.type &lt;= e1000_ich9lan) {</a>
<a name="ln6014">		if (!(E1000_READ_REG(hw, E1000_EECD) &amp; E1000_EECD_PRES) &amp;&amp;</a>
<a name="ln6015">		    (hw-&gt;phy.type == e1000_phy_igp_3)) {</a>
<a name="ln6016">			e1000_phy_init_script_igp3(hw);</a>
<a name="ln6017">		}</a>
<a name="ln6018">	} else {</a>
<a name="ln6019">		if (e1000_valid_nvm_bank_detect_ich8lan(hw, &amp;bank)) {</a>
<a name="ln6020">			/* Maybe we should do a basic PHY config */</a>
<a name="ln6021">			DEBUGOUT(&quot;EEPROM not present\n&quot;);</a>
<a name="ln6022">			ret_val = -E1000_ERR_CONFIG;</a>
<a name="ln6023">		}</a>
<a name="ln6024">	}</a>
<a name="ln6025"> </a>
<a name="ln6026">	return ret_val;</a>
<a name="ln6027">}</a>
<a name="ln6028"> </a>
<a name="ln6029">/**</a>
<a name="ln6030"> * e1000_power_down_phy_copper_ich8lan - Remove link during PHY power down</a>
<a name="ln6031"> * @hw: pointer to the HW structure</a>
<a name="ln6032"> *</a>
<a name="ln6033"> * In the case of a PHY power down to save power, or to turn off link during a</a>
<a name="ln6034"> * driver unload, or wake on lan is not enabled, remove the link.</a>
<a name="ln6035"> **/</a>
<a name="ln6036">static void e1000_power_down_phy_copper_ich8lan(struct e1000_hw *hw)</a>
<a name="ln6037">{</a>
<a name="ln6038">	/* If the management interface is not enabled, then power down */</a>
<a name="ln6039">	if (!(hw-&gt;mac.ops.check_mng_mode(hw) ||</a>
<a name="ln6040">	      hw-&gt;phy.ops.check_reset_block(hw)))</a>
<a name="ln6041">		e1000_power_down_phy_copper(hw);</a>
<a name="ln6042"> </a>
<a name="ln6043">	return;</a>
<a name="ln6044">}</a>
<a name="ln6045"> </a>
<a name="ln6046">/**</a>
<a name="ln6047"> *  e1000_clear_hw_cntrs_ich8lan - Clear statistical counters</a>
<a name="ln6048"> *  @hw: pointer to the HW structure</a>
<a name="ln6049"> *</a>
<a name="ln6050"> *  Clears hardware counters specific to the silicon family and calls</a>
<a name="ln6051"> *  clear_hw_cntrs_generic to clear all general purpose counters.</a>
<a name="ln6052"> **/</a>
<a name="ln6053">static void e1000_clear_hw_cntrs_ich8lan(struct e1000_hw *hw)</a>
<a name="ln6054">{</a>
<a name="ln6055">	u16 phy_data;</a>
<a name="ln6056">	s32 ret_val;</a>
<a name="ln6057"> </a>
<a name="ln6058">	DEBUGFUNC(&quot;e1000_clear_hw_cntrs_ich8lan&quot;);</a>
<a name="ln6059"> </a>
<a name="ln6060">	e1000_clear_hw_cntrs_base_generic(hw);</a>
<a name="ln6061"> </a>
<a name="ln6062">	E1000_READ_REG(hw, E1000_ALGNERRC);</a>
<a name="ln6063">	E1000_READ_REG(hw, E1000_RXERRC);</a>
<a name="ln6064">	E1000_READ_REG(hw, E1000_TNCRS);</a>
<a name="ln6065">	E1000_READ_REG(hw, E1000_CEXTERR);</a>
<a name="ln6066">	E1000_READ_REG(hw, E1000_TSCTC);</a>
<a name="ln6067">	E1000_READ_REG(hw, E1000_TSCTFC);</a>
<a name="ln6068"> </a>
<a name="ln6069">	E1000_READ_REG(hw, E1000_MGTPRC);</a>
<a name="ln6070">	E1000_READ_REG(hw, E1000_MGTPDC);</a>
<a name="ln6071">	E1000_READ_REG(hw, E1000_MGTPTC);</a>
<a name="ln6072"> </a>
<a name="ln6073">	E1000_READ_REG(hw, E1000_IAC);</a>
<a name="ln6074">	E1000_READ_REG(hw, E1000_ICRXOC);</a>
<a name="ln6075"> </a>
<a name="ln6076">	/* Clear PHY statistics registers */</a>
<a name="ln6077">	if ((hw-&gt;phy.type == e1000_phy_82578) ||</a>
<a name="ln6078">	    (hw-&gt;phy.type == e1000_phy_82579) ||</a>
<a name="ln6079">	    (hw-&gt;phy.type == e1000_phy_i217) ||</a>
<a name="ln6080">	    (hw-&gt;phy.type == e1000_phy_82577)) {</a>
<a name="ln6081">		ret_val = hw-&gt;phy.ops.acquire(hw);</a>
<a name="ln6082">		if (ret_val)</a>
<a name="ln6083">			return;</a>
<a name="ln6084">		ret_val = hw-&gt;phy.ops.set_page(hw,</a>
<a name="ln6085">					       HV_STATS_PAGE &lt;&lt; IGP_PAGE_SHIFT);</a>
<a name="ln6086">		if (ret_val)</a>
<a name="ln6087">			goto release;</a>
<a name="ln6088">		hw-&gt;phy.ops.read_reg_page(hw, HV_SCC_UPPER, &amp;phy_data);</a>
<a name="ln6089">		hw-&gt;phy.ops.read_reg_page(hw, HV_SCC_LOWER, &amp;phy_data);</a>
<a name="ln6090">		hw-&gt;phy.ops.read_reg_page(hw, HV_ECOL_UPPER, &amp;phy_data);</a>
<a name="ln6091">		hw-&gt;phy.ops.read_reg_page(hw, HV_ECOL_LOWER, &amp;phy_data);</a>
<a name="ln6092">		hw-&gt;phy.ops.read_reg_page(hw, HV_MCC_UPPER, &amp;phy_data);</a>
<a name="ln6093">		hw-&gt;phy.ops.read_reg_page(hw, HV_MCC_LOWER, &amp;phy_data);</a>
<a name="ln6094">		hw-&gt;phy.ops.read_reg_page(hw, HV_LATECOL_UPPER, &amp;phy_data);</a>
<a name="ln6095">		hw-&gt;phy.ops.read_reg_page(hw, HV_LATECOL_LOWER, &amp;phy_data);</a>
<a name="ln6096">		hw-&gt;phy.ops.read_reg_page(hw, HV_COLC_UPPER, &amp;phy_data);</a>
<a name="ln6097">		hw-&gt;phy.ops.read_reg_page(hw, HV_COLC_LOWER, &amp;phy_data);</a>
<a name="ln6098">		hw-&gt;phy.ops.read_reg_page(hw, HV_DC_UPPER, &amp;phy_data);</a>
<a name="ln6099">		hw-&gt;phy.ops.read_reg_page(hw, HV_DC_LOWER, &amp;phy_data);</a>
<a name="ln6100">		hw-&gt;phy.ops.read_reg_page(hw, HV_TNCRS_UPPER, &amp;phy_data);</a>
<a name="ln6101">		hw-&gt;phy.ops.read_reg_page(hw, HV_TNCRS_LOWER, &amp;phy_data);</a>
<a name="ln6102">release:</a>
<a name="ln6103">		hw-&gt;phy.ops.release(hw);</a>
<a name="ln6104">	}</a>
<a name="ln6105">}</a>
<a name="ln6106"> </a>

</code></pre>
<div class="balloon" rel="1094"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v629/" target="_blank">V629</a> Consider inspecting the '1 << (scale * 5)' expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type.</p></div>
<div class="balloon" rel="485"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'phy->id == e1000_phy_unknown' is always true.</p></div>
<div class="balloon" rel="5571"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v654/" target="_blank">V654</a> The condition 'retry' of loop is always true.</p></div>
<div class="balloon" rel="3712"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'ret_val == 0' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
