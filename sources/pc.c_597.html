
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>pc.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">               PC -- programmer's calculator.</a>
<a name="ln3"> </a>
<a name="ln4">   This program implements a simple recursive descent parser that</a>
<a name="ln5">understands pretty much all standard C language math and logic</a>
<a name="ln6">expressions.  It handles the usual add, subtract, multiply, divide,</a>
<a name="ln7">and mod sort of stuff.  It can also deal with logical/relational</a>
<a name="ln8">operations and expressions.  The logic/relational operations AND, OR,</a>
<a name="ln9">NOT, and EXCLUSIVE OR, &amp;&amp;, ||, ==, !=, &lt;, &gt;, &lt;=, and &gt;= are all</a>
<a name="ln10">supported.  It also handles parens and nested expresions as well as</a>
<a name="ln11">left and right shifts.  There are variables and assignments (as well</a>
<a name="ln12">as assignment operators like &quot;*=&quot;).</a>
<a name="ln13"> </a>
<a name="ln14">   The other useful feature is that you can use &quot;.&quot; in an expression</a>
<a name="ln15">to refer to the value from the previous expression (just like bc).</a>
<a name="ln16"> </a>
<a name="ln17">   Multiple statements can be separated by semi-colons (;) on a single</a>
<a name="ln18">line (though a single statement can't span multiple lines).   </a>
<a name="ln19"> </a>
<a name="ln20">   This calculator is mainly a programmers calculator because it</a>
<a name="ln21">doesn't work in floating point and only deals with integers.</a>
<a name="ln22"> </a>
<a name="ln23">   I wrote this because the standard unix calculator (bc) doesn't</a>
<a name="ln24">offer a useful modulo, it doesn't have left and right shifts and</a>
<a name="ln25">sometimes it is a pain in the ass to use (but I still use bc for</a>
<a name="ln26">things that require any kind of floating point).  This program is</a>
<a name="ln27">great when you have to do address calculations and bit-wise</a>
<a name="ln28">masking/shifting as you do when working on kernel type code.  It's</a>
<a name="ln29">also handy for doing quick conversions between decimal, hex and ascii</a>
<a name="ln30">(and if you want to see octal for some reason, just put it in the</a>
<a name="ln31">printf string).</a>
<a name="ln32"> </a>
<a name="ln33">   The parser is completely separable and could be spliced into other</a>
<a name="ln34">code very easy.  The routine parse_expression() just expects a char</a>
<a name="ln35">pointer and returns the value.  Implementing command line editing</a>
<a name="ln36">would be easy using a readline() type of library.</a>
<a name="ln37"> </a>
<a name="ln38">   This isn't the world's best parser or anything, but it works and</a>
<a name="ln39">suits my needs.  It faithfully implements C style precedence of</a>
<a name="ln40">operators for:</a>
<a name="ln41"> </a>
<a name="ln42">        ++ -- ~ ! * / % + - &lt;&lt; &gt;&gt; &lt; &gt; &lt;= &gt;= == != &amp; ^ | &amp;&amp; ||</a>
<a name="ln43"> </a>
<a name="ln44">(in that order, from greatest to least precedence).</a>
<a name="ln45"> </a>
<a name="ln46">   Note: The ! unary operator is a logical negation, not a bitwise</a>
<a name="ln47">negation (if you want bitwise negation, use ~).</a>
<a name="ln48"> </a>
<a name="ln49">   I've been working on adding variables and assignments, and I've</a>
<a name="ln50">just (10/26/94) got it working right and with code I'm not ashamed of.</a>
<a name="ln51">Now you can have variables (no restrictions on length) and assign to</a>
<a name="ln52">them and use them in expressions.  Variable names have the usual C</a>
<a name="ln53">rules (i.e. alpha or underscore followed by alpha-numeric and</a>
<a name="ln54">underscore).  Variables are initialized to zero and created as needed.</a>
<a name="ln55">You can have any number of variables. Here are some examples:</a>
<a name="ln56"> </a>
<a name="ln57">      x = 5</a>
<a name="ln58">      x = y = 10</a>
<a name="ln59">      x = (y + 5) * 2</a>
<a name="ln60">      (y * 2) + (x &amp; 0xffeef)</a>
<a name="ln61"> </a>
<a name="ln62"> </a>
<a name="ln63">   Assignment operators also work.  The allowable assignment operators</a>
<a name="ln64">are (just as in C):</a>
<a name="ln65"> </a>
<a name="ln66">       +=, -=, *=, /=, %=, &amp;=, ^=, |=, &lt;&lt;=, and &gt;&gt;=</a>
<a name="ln67"> </a>
<a name="ln68"> </a>
<a name="ln69">   The basic ideas for this code came from the book &quot;Compiler Design</a>
<a name="ln70">in C&quot;, by Allen I. Holub, but I've extended them significantly.</a>
<a name="ln71"> </a>
<a name="ln72">   If you find bugs or parsing bogosites, I'd like to know about them</a>
<a name="ln73">so I can fix them.  Other comments and criticism of the code are</a>
<a name="ln74">welcome as well.</a>
<a name="ln75"> </a>
<a name="ln76">   Thanks go to Joel Tesler (joel@engr.sgi.com) for adding the ability</a>
<a name="ln77">to pass command line arguments and have pc evaluate them instead of reading</a>
<a name="ln78">from stdin.</a>
<a name="ln79"> </a>
<a name="ln80">      Dominic Giampaolo</a>
<a name="ln81">      dbg@be.com (though this was written while I was at sgi)</a>
<a name="ln82"> */</a>
<a name="ln83">#include &lt;stdio.h&gt;</a>
<a name="ln84">#include &lt;stdlib.h&gt;</a>
<a name="ln85">#include &lt;limits.h&gt;</a>
<a name="ln86">#include &lt;string.h&gt;</a>
<a name="ln87">#include &lt;ctype.h&gt;</a>
<a name="ln88">#include &quot;lex.h&quot;</a>
<a name="ln89"> </a>
<a name="ln90"> </a>
<a name="ln91">/*</a>
<a name="ln92"> * You should #define USE_LONG_LONG if your compiler supports the long long</a>
<a name="ln93"> * data type, has strtoull(), and a %lld conversion specifier for printf.</a>
<a name="ln94"> * Otherwise just comment out the #define and pc will use plain longs.</a>
<a name="ln95"> */</a>
<a name="ln96"> </a>
<a name="ln97">#define  USE_LONG_LONG</a>
<a name="ln98"> </a>
<a name="ln99"> </a>
<a name="ln100">#ifdef  USE_LONG_LONG</a>
<a name="ln101">#define LONG     long long</a>
<a name="ln102">#define ULONG    unsigned long long</a>
<a name="ln103">#define STRTOUL  strtoull</a>
<a name="ln104">#define STR1     &quot;%20llu  0x%.16llx signed: %20lld&quot; </a>
<a name="ln105">#define STR2     &quot;%20llu  0x%.16llx&quot;</a>
<a name="ln106">#define STR3     &quot; char: &quot;</a>
<a name="ln107">#define STR4     &quot;%20lu  0x%-16.8lx signed: %20ld&quot; </a>
<a name="ln108">#define STR5     &quot;%20lu  0x%-16.8lx&quot;</a>
<a name="ln109">#else</a>
<a name="ln110">#define LONG     long</a>
<a name="ln111">#define ULONG    unsigned long</a>
<a name="ln112">#define STRTOUL  strtoul</a>
<a name="ln113">#define STR1     &quot;%10lu\t 0x%.8lx\t signed: %10ld&quot; </a>
<a name="ln114">#define STR2     &quot;%10lu\t 0x%.8lx&quot;</a>
<a name="ln115">#define STR3     &quot; char: &quot;</a>
<a name="ln116">#define STR4     STR1</a>
<a name="ln117">#define STR5     STR2</a>
<a name="ln118">#endif</a>
<a name="ln119"> </a>
<a name="ln120"> </a>
<a name="ln121">ULONG parse_expression(char *str);   /* top-level interface to parser */</a>
<a name="ln122">ULONG assignment_expr(char **str);   /* assignments =, +=, *=, etc */</a>
<a name="ln123">ULONG do_assignment_operator(char **str, char *var_name);</a>
<a name="ln124">ULONG logical_or_expr(char **str);   /* logical OR  `||' */</a>
<a name="ln125">ULONG logical_and_expr(char **str);  /* logical AND  `&amp;&amp;' */</a>
<a name="ln126">ULONG or_expr(char **str);           /* OR  `|' */</a>
<a name="ln127">ULONG xor_expr(char **str);          /* XOR `^' */</a>
<a name="ln128">ULONG and_expr(char **str);          /* AND `&amp;' */</a>
<a name="ln129">ULONG equality_expr(char **str);     /* equality ==, != */</a>
<a name="ln130">ULONG relational_expr(char **str);   /* relational &lt;, &gt;, &lt;=, &gt;= */</a>
<a name="ln131">ULONG shift_expr(char **str);        /* shifts &lt;&lt;, &gt;&gt; */</a>
<a name="ln132">ULONG add_expression(char **str);    /* addition/subtraction +, - */</a>
<a name="ln133">ULONG term(char **str);              /* multiplication/division *,%,/ */</a>
<a name="ln134">ULONG factor(char **str);            /* negation, logical not ~, ! */</a>
<a name="ln135">ULONG get_value(char **str);</a>
<a name="ln136">int   get_var(char *name, ULONG *val); /* external interfaces to vars */</a>
<a name="ln137">void  set_var(char *name, ULONG val);</a>
<a name="ln138"> </a>
<a name="ln139">void  do_input(void);                /* reads stdin and calls parser */</a>
<a name="ln140">char *skipwhite(char *str);          /* skip over input white space */</a>
<a name="ln141"> </a>
<a name="ln142"> </a>
<a name="ln143"> </a>
<a name="ln144">/*</a>
<a name="ln145"> * Variables are kept in a simple singly-linked list. Not high</a>
<a name="ln146"> * performance, but it's also an extremely small implementation.</a>
<a name="ln147"> *</a>
<a name="ln148"> * New variables get added to the head of the list.  Variables are</a>
<a name="ln149"> * never deleted, though it wouldn't be hard to do that.</a>
<a name="ln150"> *</a>
<a name="ln151"> */</a>
<a name="ln152">typedef struct variable </a>
<a name="ln153">{</a>
<a name="ln154">  char  *name;</a>
<a name="ln155">  ULONG  value;</a>
<a name="ln156">  struct variable *next;</a>
<a name="ln157">}variable;</a>
<a name="ln158"> </a>
<a name="ln159">variable dummy = { NULL, 0L, NULL };</a>
<a name="ln160">variable *vars=&amp;dummy;</a>
<a name="ln161"> </a>
<a name="ln162">variable *lookup_var(char *name);</a>
<a name="ln163">variable *add_var(char *name, ULONG value);</a>
<a name="ln164">char     *get_var_name(char **input_str);</a>
<a name="ln165">void      parse_args(int argc, char *argv[]);</a>
<a name="ln166">int (*set_var_lookup_hook(int (*func)(char *name, ULONG *val)))</a>
<a name="ln167">                         (char *name, ULONG *val);</a>
<a name="ln168"> </a>
<a name="ln169">/*</a>
<a name="ln170"> * last_result is equal to the result of the last expression and </a>
<a name="ln171"> * expressions can refer to it as `.' (just like bc).</a>
<a name="ln172"> */</a>
<a name="ln173">ULONG last_result = 0;</a>
<a name="ln174"> </a>
<a name="ln175"> </a>
<a name="ln176">static int</a>
<a name="ln177">special_vars(char *name, ULONG *val)</a>
<a name="ln178">{</a>
<a name="ln179">  if (strcmp(name, &quot;time&quot;) == 0)</a>
<a name="ln180">    *val = (ULONG)time(NULL);</a>
<a name="ln181">  else if (strcmp(name, &quot;rand&quot;) == 0)</a>
<a name="ln182">    *val = (ULONG)rand();</a>
<a name="ln183">  else if (strcmp(name, &quot;dbg&quot;) == 0)</a>
<a name="ln184">    *val = 0x82969;</a>
<a name="ln185">  else</a>
<a name="ln186">    return 0;</a>
<a name="ln187"> </a>
<a name="ln188">  return 1;</a>
<a name="ln189">}</a>
<a name="ln190"> </a>
<a name="ln191"> </a>
<a name="ln192">int</a>
<a name="ln193">main(int argc, char *argv[])</a>
<a name="ln194">{</a>
<a name="ln195"> </a>
<a name="ln196">  set_var_lookup_hook(special_vars);</a>
<a name="ln197"> </a>
<a name="ln198">  if (argc &gt; 1)</a>
<a name="ln199">    parse_args(argc, argv);</a>
<a name="ln200">  else</a>
<a name="ln201">    do_input();</a>
<a name="ln202">  </a>
<a name="ln203">  return 0;</a>
<a name="ln204">}</a>
<a name="ln205"> </a>
<a name="ln206">/*</a>
<a name="ln207">   This function prints the result of the expression.</a>
<a name="ln208">   It tries to be smart about printing numbers so it</a>
<a name="ln209">   only uses the necessary number of digits.  If you</a>
<a name="ln210">   have long long (i.e. 64 bit numbers) it's very</a>
<a name="ln211">   annoying to have lots of leading zeros when they</a>
<a name="ln212">   aren't necessary.  By doing the somewhat bizarre</a>
<a name="ln213">   casting and comparisons we can determine if a value</a>
<a name="ln214">   will fit in a 32 bit quantity and only print that.</a>
<a name="ln215">*/</a>
<a name="ln216">static void</a>
<a name="ln217">print_result(ULONG value)</a>
<a name="ln218">{</a>
<a name="ln219">  int i;</a>
<a name="ln220">  ULONG ch, shift;</a>
<a name="ln221">  </a>
<a name="ln222">  if ((signed LONG)value &lt; 0)</a>
<a name="ln223">   {</a>
<a name="ln224">     if ((signed LONG)value &lt; (signed LONG)(LONG_MIN))</a>
<a name="ln225">       printf(STR1, value, value, value);</a>
<a name="ln226">     else </a>
<a name="ln227">       printf(STR4, (long)value, (long)value, (long)value);</a>
<a name="ln228">   }</a>
<a name="ln229">  else if ((ULONG)value &lt;= (ULONG)ULONG_MAX)</a>
<a name="ln230">    printf(STR5, (long)value, (long)value);</a>
<a name="ln231">  else</a>
<a name="ln232">    printf(STR2, value, value);</a>
<a name="ln233">     </a>
<a name="ln234">  /*</a>
<a name="ln235">     Print any printable character (and print dots for unprintable chars</a>
<a name="ln236">  */  </a>
<a name="ln237">  printf(STR3);</a>
<a name="ln238">  for(i=sizeof(ULONG)-1; i &gt;= 0; i--)</a>
<a name="ln239">   {</a>
<a name="ln240">     shift = i * 8;</a>
<a name="ln241">     ch = ((ULONG)value &amp; ((ULONG)0xff &lt;&lt; shift)) &gt;&gt; shift;</a>
<a name="ln242"> </a>
<a name="ln243">     if (isprint((int)ch))</a>
<a name="ln244">       printf(&quot;%c&quot;, (char)(ch));</a>
<a name="ln245">     else</a>
<a name="ln246">       printf(&quot;.&quot;);</a>
<a name="ln247">   }</a>
<a name="ln248"> </a>
<a name="ln249">  printf(&quot;\n&quot;);</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252">void</a>
<a name="ln253">parse_args(int argc, char *argv[])</a>
<a name="ln254">{</a>
<a name="ln255">  int i, len;</a>
<a name="ln256">  char *buff;</a>
<a name="ln257">  ULONG value;</a>
<a name="ln258"> </a>
<a name="ln259">  for(i=1, len=0; i &lt; argc; i++)</a>
<a name="ln260">    len += strlen(argv[i]);</a>
<a name="ln261">  len++;</a>
<a name="ln262"> </a>
<a name="ln263">  buff = malloc(len*sizeof(char));</a>
<a name="ln264">  if (buff == NULL)</a>
<a name="ln265">    return;</a>
<a name="ln266"> </a>
<a name="ln267">  buff[0] = '\0';</a>
<a name="ln268">  while (--argc &gt; 0)</a>
<a name="ln269">  {</a>
<a name="ln270">    strcat(buff, *++argv);</a>
<a name="ln271">  }</a>
<a name="ln272">  value = parse_expression(buff);</a>
<a name="ln273"> </a>
<a name="ln274">  print_result(value);</a>
<a name="ln275"> </a>
<a name="ln276">  free(buff);</a>
<a name="ln277">}</a>
<a name="ln278">  </a>
<a name="ln279">void</a>
<a name="ln280">do_input(void)</a>
<a name="ln281">{</a>
<a name="ln282">  ULONG value;</a>
<a name="ln283">  char buff[256], *ptr;</a>
<a name="ln284">  </a>
<a name="ln285">  while(fgets(buff, 256, stdin) != NULL)</a>
<a name="ln286">   {</a>
<a name="ln287">     if (buff[strlen(buff)-1] == '\n')</a>
<a name="ln288">       buff[strlen(buff)-1] = '\0';     /* kill the newline character */</a>
<a name="ln289"> </a>
<a name="ln290">     for(ptr=buff; isspace(*ptr) &amp;&amp; *ptr; ptr++)</a>
<a name="ln291">        /* skip whitespace */;</a>
<a name="ln292"> </a>
<a name="ln293">     if (*ptr == '\0')    /* hmmm, an empty line, just skip it */</a>
<a name="ln294">       continue;</a>
<a name="ln295">     </a>
<a name="ln296">     value = parse_expression(buff);</a>
<a name="ln297">     </a>
<a name="ln298">     print_result(value);</a>
<a name="ln299">   }</a>
<a name="ln300">}</a>
<a name="ln301"> </a>
<a name="ln302"> </a>
<a name="ln303">ULONG</a>
<a name="ln304">parse_expression(char *str)</a>
<a name="ln305">{</a>
<a name="ln306">  ULONG val;</a>
<a name="ln307">  char *ptr = str;</a>
<a name="ln308"> </a>
<a name="ln309">  ptr = skipwhite(ptr);</a>
<a name="ln310">  if (*ptr == '\0')</a>
<a name="ln311">    return last_result;</a>
<a name="ln312"> </a>
<a name="ln313">  val = assignment_expr(&amp;ptr);</a>
<a name="ln314"> </a>
<a name="ln315">  ptr = skipwhite(ptr);</a>
<a name="ln316">  while (*ptr == SEMI_COLON &amp;&amp; *ptr != '\0')</a>
<a name="ln317">   {</a>
<a name="ln318">     ptr++;</a>
<a name="ln319">     if (*ptr == '\0')   /* reached the end of the string, stop parsing */</a>
<a name="ln320">       continue;</a>
<a name="ln321">     </a>
<a name="ln322">     val = assignment_expr(&amp;ptr);</a>
<a name="ln323">   }</a>
<a name="ln324"> </a>
<a name="ln325">  last_result = val;</a>
<a name="ln326">  return val;</a>
<a name="ln327">}</a>
<a name="ln328"> </a>
<a name="ln329"> </a>
<a name="ln330">ULONG</a>
<a name="ln331">assignment_expr(char **str)</a>
<a name="ln332">{</a>
<a name="ln333">  ULONG val; </a>
<a name="ln334">  char *orig_str;</a>
<a name="ln335">  char *var_name;</a>
<a name="ln336">  variable *v;</a>
<a name="ln337">  </a>
<a name="ln338">  *str = skipwhite(*str);</a>
<a name="ln339">  orig_str = *str;</a>
<a name="ln340"> </a>
<a name="ln341">  var_name = get_var_name(str);</a>
<a name="ln342"> </a>
<a name="ln343">  *str = skipwhite(*str);</a>
<a name="ln344">  if (**str == EQUAL &amp;&amp; *(*str+1) != EQUAL)</a>
<a name="ln345">   {</a>
<a name="ln346">     *str = skipwhite(*str + 1);     /* skip the equal sign */</a>
<a name="ln347"> </a>
<a name="ln348">     val = assignment_expr(str);     /* go recursive! */</a>
<a name="ln349"> </a>
<a name="ln350">     if ((v = lookup_var(var_name)) == NULL)</a>
<a name="ln351">       add_var(var_name, val);</a>
<a name="ln352">     else</a>
<a name="ln353">       v-&gt;value = val;</a>
<a name="ln354">   }</a>
<a name="ln355">  else if (((**str == PLUS  || **str == MINUS    || **str == OR ||</a>
<a name="ln356">	     **str == TIMES || **str == DIVISION || **str == MODULO ||</a>
<a name="ln357">	     **str == AND   || **str == XOR) &amp;&amp; *(*str+1) == EQUAL) ||</a>
<a name="ln358">	   strncmp(*str, &quot;&lt;&lt;=&quot;, 3) == 0 || strncmp(*str, &quot;&gt;&gt;=&quot;, 3) == 0)</a>
<a name="ln359">   {</a>
<a name="ln360">     val = do_assignment_operator(str, var_name);</a>
<a name="ln361">   }</a>
<a name="ln362">  else</a>
<a name="ln363">   {</a>
<a name="ln364">     *str = orig_str;</a>
<a name="ln365">     val = logical_or_expr(str);     /* no equal sign, just get var value */</a>
<a name="ln366"> </a>
<a name="ln367">     *str = skipwhite(*str);</a>
<a name="ln368">     if (**str == EQUAL)</a>
<a name="ln369">      {</a>
<a name="ln370">	fprintf(stderr, &quot;Left hand side of expression is not assignable.\n&quot;);</a>
<a name="ln371">      }</a>
<a name="ln372">   }</a>
<a name="ln373"> </a>
<a name="ln374">  if (var_name)</a>
<a name="ln375">    free(var_name);</a>
<a name="ln376"> </a>
<a name="ln377">  return val;</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380"> </a>
<a name="ln381">ULONG</a>
<a name="ln382">do_assignment_operator(char **str, char *var_name)</a>
<a name="ln383">{</a>
<a name="ln384">  ULONG val;</a>
<a name="ln385">  variable *v;</a>
<a name="ln386">  char operator;</a>
<a name="ln387">  </a>
<a name="ln388">  operator = **str;</a>
<a name="ln389"> </a>
<a name="ln390">  if (operator == SHIFT_L || operator == SHIFT_R)</a>
<a name="ln391">    *str = skipwhite(*str + 3);</a>
<a name="ln392">  else</a>
<a name="ln393">    *str = skipwhite(*str + 2);     /* skip the assignment operator */</a>
<a name="ln394"> </a>
<a name="ln395">  val = assignment_expr(str);       /* go recursive! */</a>
<a name="ln396"> </a>
<a name="ln397">  v = lookup_var(var_name);</a>
<a name="ln398">  if (v == NULL)</a>
<a name="ln399">   {</a>
<a name="ln400">     v = add_var(var_name, 0);</a>
<a name="ln401">     if (v == NULL)</a>
<a name="ln402">       return 0;</a>
<a name="ln403">   }</a>
<a name="ln404">  </a>
<a name="ln405">  if (operator == PLUS)</a>
<a name="ln406">    v-&gt;value += val;</a>
<a name="ln407">  else if (operator == MINUS)</a>
<a name="ln408">    v-&gt;value -= val;</a>
<a name="ln409">  else if (operator == AND)</a>
<a name="ln410">    v-&gt;value &amp;= val;</a>
<a name="ln411">  else if (operator == XOR)</a>
<a name="ln412">    v-&gt;value ^= val;</a>
<a name="ln413">  else if (operator == OR)</a>
<a name="ln414">    v-&gt;value |= val;</a>
<a name="ln415">  else if (operator == SHIFT_L)</a>
<a name="ln416">    v-&gt;value &lt;&lt;= val;</a>
<a name="ln417">  else if (operator == SHIFT_R)</a>
<a name="ln418">    v-&gt;value &gt;&gt;= val;</a>
<a name="ln419">  else if (operator == TIMES)</a>
<a name="ln420">    v-&gt;value *= val;</a>
<a name="ln421">  else if (operator == DIVISION)</a>
<a name="ln422">   {</a>
<a name="ln423">     if (val == 0)  /* check for it, but still get the result */</a>
<a name="ln424">       fprintf(stderr, &quot;Divide by zero!\n&quot;);</a>
<a name="ln425"> </a>
<a name="ln426">     v-&gt;value /= val;</a>
<a name="ln427">   }</a>
<a name="ln428">  else if (operator == MODULO)</a>
<a name="ln429">   {</a>
<a name="ln430">     if (val == 0)  /* check for it, but still get the result */</a>
<a name="ln431">       fprintf(stderr, &quot;Modulo by zero!\n&quot;);</a>
<a name="ln432"> </a>
<a name="ln433">     v-&gt;value %= val;</a>
<a name="ln434">   }</a>
<a name="ln435">  else</a>
<a name="ln436">   {</a>
<a name="ln437">     fprintf(stderr, &quot;Unknown operator: %c\n&quot;, operator);</a>
<a name="ln438">     v-&gt;value = 0;</a>
<a name="ln439">   }</a>
<a name="ln440"> </a>
<a name="ln441">  return v-&gt;value;</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444"> </a>
<a name="ln445">ULONG</a>
<a name="ln446">logical_or_expr(char **str)</a>
<a name="ln447">{</a>
<a name="ln448">  ULONG val, sum = 0; </a>
<a name="ln449">  </a>
<a name="ln450">  *str = skipwhite(*str);</a>
<a name="ln451"> </a>
<a name="ln452">  sum = logical_and_expr(str);</a>
<a name="ln453"> </a>
<a name="ln454">  *str = skipwhite(*str);</a>
<a name="ln455">  while(**str == OR &amp;&amp; *(*str + 1) == OR)</a>
<a name="ln456">   {</a>
<a name="ln457">     *str = skipwhite(*str + 2);   /* advance over the operator */</a>
<a name="ln458">     </a>
<a name="ln459">     val = logical_and_expr(str);</a>
<a name="ln460"> </a>
<a name="ln461">     sum = (val || sum);</a>
<a name="ln462">   }</a>
<a name="ln463"> </a>
<a name="ln464">  return sum;</a>
<a name="ln465">}</a>
<a name="ln466"> </a>
<a name="ln467"> </a>
<a name="ln468"> </a>
<a name="ln469">ULONG</a>
<a name="ln470">logical_and_expr(char **str)</a>
<a name="ln471">{</a>
<a name="ln472">  ULONG val, sum = 0; </a>
<a name="ln473">  </a>
<a name="ln474">  *str = skipwhite(*str);</a>
<a name="ln475"> </a>
<a name="ln476">  sum = or_expr(str);</a>
<a name="ln477"> </a>
<a name="ln478">  *str = skipwhite(*str);</a>
<a name="ln479">  while(**str == AND &amp;&amp; *(*str + 1) == AND)</a>
<a name="ln480">   {</a>
<a name="ln481">     *str = skipwhite(*str + 2);   /* advance over the operator */</a>
<a name="ln482">     </a>
<a name="ln483">     val = or_expr(str);</a>
<a name="ln484"> </a>
<a name="ln485">     sum = (val &amp;&amp; sum);</a>
<a name="ln486">   }</a>
<a name="ln487"> </a>
<a name="ln488">  return sum;</a>
<a name="ln489">}</a>
<a name="ln490"> </a>
<a name="ln491"> </a>
<a name="ln492">ULONG</a>
<a name="ln493">or_expr(char **str)</a>
<a name="ln494">{</a>
<a name="ln495">  ULONG val, sum = 0; </a>
<a name="ln496">  </a>
<a name="ln497">  *str = skipwhite(*str);</a>
<a name="ln498"> </a>
<a name="ln499">  sum = xor_expr(str);</a>
<a name="ln500"> </a>
<a name="ln501">  *str = skipwhite(*str);</a>
<a name="ln502">  while(**str == OR &amp;&amp; *(*str+1) != OR)</a>
<a name="ln503">   {</a>
<a name="ln504">     *str = skipwhite(*str + 1);   /* advance over the operator */</a>
<a name="ln505">     </a>
<a name="ln506">     val = xor_expr(str);</a>
<a name="ln507"> </a>
<a name="ln508">     sum |= val;</a>
<a name="ln509">   }</a>
<a name="ln510"> </a>
<a name="ln511">  return sum;</a>
<a name="ln512">}</a>
<a name="ln513"> </a>
<a name="ln514"> </a>
<a name="ln515"> </a>
<a name="ln516">ULONG</a>
<a name="ln517">xor_expr(char **str)</a>
<a name="ln518">{</a>
<a name="ln519">  ULONG val, sum = 0; </a>
<a name="ln520">  </a>
<a name="ln521">  *str = skipwhite(*str);</a>
<a name="ln522"> </a>
<a name="ln523">  sum = and_expr(str);</a>
<a name="ln524"> </a>
<a name="ln525">  *str = skipwhite(*str);</a>
<a name="ln526">  while(**str == XOR)</a>
<a name="ln527">   {</a>
<a name="ln528">     *str = skipwhite(*str + 1);   /* advance over the operator */</a>
<a name="ln529">     </a>
<a name="ln530">     val = and_expr(str);</a>
<a name="ln531"> </a>
<a name="ln532">     sum ^= val;</a>
<a name="ln533">   }</a>
<a name="ln534"> </a>
<a name="ln535">  return sum;</a>
<a name="ln536">}</a>
<a name="ln537"> </a>
<a name="ln538"> </a>
<a name="ln539"> </a>
<a name="ln540">ULONG</a>
<a name="ln541">and_expr(char **str)</a>
<a name="ln542">{</a>
<a name="ln543">  ULONG val, sum = 0; </a>
<a name="ln544">  </a>
<a name="ln545">  *str = skipwhite(*str);</a>
<a name="ln546"> </a>
<a name="ln547">  sum = equality_expr(str);</a>
<a name="ln548"> </a>
<a name="ln549">  *str = skipwhite(*str);</a>
<a name="ln550">  while(**str == AND &amp;&amp; *(*str+1) != AND)</a>
<a name="ln551">   {</a>
<a name="ln552">     *str = skipwhite(*str + 1);   /* advance over the operator */</a>
<a name="ln553">     </a>
<a name="ln554">     val = equality_expr(str);</a>
<a name="ln555"> </a>
<a name="ln556">     sum &amp;= val;</a>
<a name="ln557">   }</a>
<a name="ln558"> </a>
<a name="ln559">  return sum;</a>
<a name="ln560">}</a>
<a name="ln561"> </a>
<a name="ln562"> </a>
<a name="ln563">ULONG </a>
<a name="ln564">equality_expr(char **str)</a>
<a name="ln565">{</a>
<a name="ln566">  ULONG val, sum = 0; </a>
<a name="ln567">  char op;</a>
<a name="ln568">  </a>
<a name="ln569">  *str = skipwhite(*str);</a>
<a name="ln570"> </a>
<a name="ln571">  sum = relational_expr(str);</a>
<a name="ln572"> </a>
<a name="ln573">  *str = skipwhite(*str);</a>
<a name="ln574">  while((**str == EQUAL &amp;&amp; *(*str+1) == EQUAL) ||</a>
<a name="ln575">	(**str == BANG  &amp;&amp; *(*str+1) == EQUAL))</a>
<a name="ln576">   {</a>
<a name="ln577">     op = **str;</a>
<a name="ln578">     </a>
<a name="ln579">     *str = skipwhite(*str + 2);   /* advance over the operator */</a>
<a name="ln580">     </a>
<a name="ln581">     val = relational_expr(str);</a>
<a name="ln582"> </a>
<a name="ln583">     if (op == EQUAL)</a>
<a name="ln584">       sum = (sum == val);</a>
<a name="ln585">     else if (op == BANG)</a>
<a name="ln586">       sum = (sum != val);</a>
<a name="ln587">   }</a>
<a name="ln588"> </a>
<a name="ln589">  return sum;</a>
<a name="ln590">}</a>
<a name="ln591"> </a>
<a name="ln592"> </a>
<a name="ln593">ULONG </a>
<a name="ln594">relational_expr(char **str)</a>
<a name="ln595">{</a>
<a name="ln596">  ULONG val, sum = 0; </a>
<a name="ln597">  char op, equal_to=0;</a>
<a name="ln598">  </a>
<a name="ln599">  *str = skipwhite(*str);</a>
<a name="ln600"> </a>
<a name="ln601">  sum = shift_expr(str);</a>
<a name="ln602"> </a>
<a name="ln603">  *str = skipwhite(*str);</a>
<a name="ln604">  while(**str == LESS_THAN || **str == GREATER_THAN)</a>
<a name="ln605">   {</a>
<a name="ln606">     equal_to = 0;</a>
<a name="ln607">     op = **str;</a>
<a name="ln608"> </a>
<a name="ln609">     if (*(*str+1) == EQUAL)</a>
<a name="ln610">      {</a>
<a name="ln611">	equal_to = 1;</a>
<a name="ln612">	*str = *str+1;             /* skip initial operator */</a>
<a name="ln613">      }</a>
<a name="ln614">       </a>
<a name="ln615">     *str = skipwhite(*str + 1);   /* advance over the operator */</a>
<a name="ln616">     </a>
<a name="ln617">     val = shift_expr(str);</a>
<a name="ln618"> </a>
<a name="ln619">     /*</a>
<a name="ln620">       Notice that we do the relational expressions as signed</a>
<a name="ln621">       comparisons.  This is because of expressions like:</a>
<a name="ln622">             0 &gt; -1</a>
<a name="ln623">       which would not return the expected value if we did the</a>
<a name="ln624">       comparison as unsigned.  This may not always be the</a>
<a name="ln625">       desired behavior, but aside from adding casting to epxressions,</a>
<a name="ln626">       there isn't much of a way around it.</a>
<a name="ln627">     */</a>
<a name="ln628">     if (op == LESS_THAN &amp;&amp; equal_to == 0)</a>
<a name="ln629">       sum = ((LONG)sum &lt; (LONG)val);</a>
<a name="ln630">     else if (op == LESS_THAN &amp;&amp; equal_to == 1)</a>
<a name="ln631">       sum = ((LONG)sum &lt;= (LONG)val);</a>
<a name="ln632">     else if (op == GREATER_THAN &amp;&amp; equal_to == 0)</a>
<a name="ln633">       sum = ((LONG)sum &gt; (LONG)val);</a>
<a name="ln634">     else if (op == GREATER_THAN &amp;&amp; equal_to == 1)</a>
<a name="ln635">       sum = ((LONG)sum &gt;= (LONG)val);</a>
<a name="ln636">   }</a>
<a name="ln637"> </a>
<a name="ln638">  return sum;</a>
<a name="ln639">}</a>
<a name="ln640"> </a>
<a name="ln641"> </a>
<a name="ln642">ULONG</a>
<a name="ln643">shift_expr(char **str)</a>
<a name="ln644">{</a>
<a name="ln645">  ULONG val, sum = 0; </a>
<a name="ln646">  char op;</a>
<a name="ln647">  </a>
<a name="ln648">  *str = skipwhite(*str);</a>
<a name="ln649"> </a>
<a name="ln650">  sum = add_expression(str);</a>
<a name="ln651"> </a>
<a name="ln652">  *str = skipwhite(*str);</a>
<a name="ln653">  while((strncmp(*str, &quot;&lt;&lt;&quot;, 2) == 0) || (strncmp(*str, &quot;&gt;&gt;&quot;, 2) == 0))</a>
<a name="ln654">   {</a>
<a name="ln655">     op = **str;</a>
<a name="ln656">     </a>
<a name="ln657">     *str = skipwhite(*str + 2);   /* advance over the operator */</a>
<a name="ln658">     </a>
<a name="ln659">     val = add_expression(str);</a>
<a name="ln660"> </a>
<a name="ln661">     if (op == SHIFT_L)</a>
<a name="ln662">       sum &lt;&lt;= val;</a>
<a name="ln663">     else if (op == SHIFT_R)</a>
<a name="ln664">       sum &gt;&gt;= val;</a>
<a name="ln665">   }</a>
<a name="ln666"> </a>
<a name="ln667">  return sum;</a>
<a name="ln668">}</a>
<a name="ln669"> </a>
<a name="ln670"> </a>
<a name="ln671"> </a>
<a name="ln672"> </a>
<a name="ln673">ULONG</a>
<a name="ln674">add_expression(char **str)</a>
<a name="ln675">{</a>
<a name="ln676">  ULONG val, sum = 0; </a>
<a name="ln677">  char op;</a>
<a name="ln678">  </a>
<a name="ln679">  *str = skipwhite(*str);</a>
<a name="ln680"> </a>
<a name="ln681">  sum = term(str);</a>
<a name="ln682"> </a>
<a name="ln683">  *str = skipwhite(*str);</a>
<a name="ln684">  while(**str == PLUS || **str == MINUS)</a>
<a name="ln685">   {</a>
<a name="ln686">     op = **str;</a>
<a name="ln687">     </a>
<a name="ln688">     *str = skipwhite(*str + 1);   /* advance over the operator */</a>
<a name="ln689">     </a>
<a name="ln690">     val = term(str);</a>
<a name="ln691"> </a>
<a name="ln692">     if (op == PLUS)</a>
<a name="ln693">       sum += val;</a>
<a name="ln694">     else if (op == MINUS)</a>
<a name="ln695">       sum -= val;</a>
<a name="ln696">   }</a>
<a name="ln697"> </a>
<a name="ln698">  return sum;</a>
<a name="ln699">}</a>
<a name="ln700"> </a>
<a name="ln701"> </a>
<a name="ln702"> </a>
<a name="ln703"> </a>
<a name="ln704">ULONG</a>
<a name="ln705">term(char **str)</a>
<a name="ln706">{</a>
<a name="ln707">  ULONG val, sum = 0;</a>
<a name="ln708">  char op;</a>
<a name="ln709"> </a>
<a name="ln710"> </a>
<a name="ln711">  sum = factor(str);</a>
<a name="ln712">  *str = skipwhite(*str);</a>
<a name="ln713"> </a>
<a name="ln714">  /*</a>
<a name="ln715">   * We're at the bottom of the parse.  At this point we either have</a>
<a name="ln716">   * an operator or we're through with this string.  Otherwise it's</a>
<a name="ln717">   * an error and we print a message.</a>
<a name="ln718">   */</a>
<a name="ln719">  if (**str != TIMES     &amp;&amp; **str != DIVISION &amp;&amp; **str != MODULO &amp;&amp;</a>
<a name="ln720">      **str != PLUS      &amp;&amp; **str != MINUS    &amp;&amp; **str != OR     &amp;&amp;</a>
<a name="ln721">      **str != AND       &amp;&amp; **str != XOR      &amp;&amp; **str != BANG   &amp;&amp;</a>
<a name="ln722">      **str != NEGATIVE  &amp;&amp; **str != TWIDDLE  &amp;&amp; **str != RPAREN &amp;&amp;</a>
<a name="ln723">      **str != LESS_THAN &amp;&amp; **str != GREATER_THAN &amp;&amp; **str != SEMI_COLON &amp;&amp;</a>
<a name="ln724">      strncmp(*str, &quot;&lt;&lt;&quot;, 2) != 0 &amp;&amp; strncmp(*str, &quot;&gt;&gt;&quot;, 2) &amp;&amp;      </a>
<a name="ln725">      **str != EQUAL &amp;&amp; **str != '\0')</a>
<a name="ln726">   {</a>
<a name="ln727">     fprintf(stderr, &quot;Parsing stopped: unknown operator %s\n&quot;, *str);</a>
<a name="ln728">     return sum;</a>
<a name="ln729">   }</a>
<a name="ln730"> </a>
<a name="ln731">  while(**str == TIMES || **str == DIVISION || **str == MODULO)</a>
<a name="ln732">   {</a>
<a name="ln733">     op   = **str;</a>
<a name="ln734">     *str = skipwhite(*str + 1);</a>
<a name="ln735">     val = factor(str);</a>
<a name="ln736">     </a>
<a name="ln737">     if (op == TIMES)</a>
<a name="ln738">       sum *= val;</a>
<a name="ln739">     else if (op == DIVISION)</a>
<a name="ln740">      {</a>
<a name="ln741">	if (val == 0)</a>
<a name="ln742">	  fprintf(stderr, &quot;Divide by zero!\n&quot;);</a>
<a name="ln743"> </a>
<a name="ln744">	sum /= val;</a>
<a name="ln745">      }</a>
<a name="ln746">     else if (op == MODULO)</a>
<a name="ln747">      {</a>
<a name="ln748">	if (val == 0)</a>
<a name="ln749">	  fprintf(stderr, &quot;Modulo by zero!\n&quot;);</a>
<a name="ln750"> </a>
<a name="ln751">	sum %= val;</a>
<a name="ln752">      }</a>
<a name="ln753">   }</a>
<a name="ln754"> </a>
<a name="ln755">  return sum;</a>
<a name="ln756">}</a>
<a name="ln757"> </a>
<a name="ln758"> </a>
<a name="ln759">ULONG</a>
<a name="ln760">factor(char **str)</a>
<a name="ln761">{</a>
<a name="ln762">  ULONG val=0;</a>
<a name="ln763">  char op = NOTHING, have_special=0;</a>
<a name="ln764">  char *var_name, *var_name_ptr;</a>
<a name="ln765">  variable *v;</a>
<a name="ln766"> </a>
<a name="ln767">  if (**str == NEGATIVE || **str == PLUS || **str == TWIDDLE || **str == BANG)</a>
<a name="ln768">   {</a>
<a name="ln769">     op = **str;                     /* must be a unary op */</a>
<a name="ln770"> </a>
<a name="ln771">     if ((op == NEGATIVE &amp;&amp; *(*str + 1) == NEGATIVE) ||  /* look for ++/-- */</a>
<a name="ln772">	 (op == PLUS     &amp;&amp; *(*str + 1) == PLUS))</a>
<a name="ln773">      {</a>
<a name="ln774">	*str = *str + 1;</a>
<a name="ln775">	have_special = 1;</a>
<a name="ln776">      }</a>
<a name="ln777">     </a>
<a name="ln778">     *str = skipwhite(*str + 1);</a>
<a name="ln779">     var_name_ptr = *str;          /* save where the varname should be */</a>
<a name="ln780">   }</a>
<a name="ln781">    </a>
<a name="ln782">  val = get_value(str);</a>
<a name="ln783"> </a>
<a name="ln784">  *str = skipwhite(*str);</a>
<a name="ln785">  </a>
<a name="ln786">  /*</a>
<a name="ln787">   * Now is the time to actually do the unary operation if one</a>
<a name="ln788">   * was present.</a>
<a name="ln789">   */</a>
<a name="ln790">  if (have_special)   /* we've got a ++ or -- */</a>
<a name="ln791">   {</a>
<a name="ln792">     var_name = get_var_name(&amp;var_name_ptr);</a>
<a name="ln793">     if (var_name == NULL)</a>
<a name="ln794">      {</a>
<a name="ln795">	fprintf(stderr, &quot;Can only use ++/-- on variables.\n&quot;);</a>
<a name="ln796">	return val;</a>
<a name="ln797">      }</a>
<a name="ln798">     if ((v = lookup_var(var_name)) == NULL)</a>
<a name="ln799">      {</a>
<a name="ln800">	v = add_var(var_name, 0);</a>
<a name="ln801">	if (v == NULL)</a>
<a name="ln802">	  return val;</a>
<a name="ln803">      }</a>
<a name="ln804">     free(var_name);</a>
<a name="ln805"> </a>
<a name="ln806">     if (op == PLUS)</a>
<a name="ln807">	val = ++v-&gt;value;</a>
<a name="ln808">     else</a>
<a name="ln809">	val = --v-&gt;value;</a>
<a name="ln810">   }</a>
<a name="ln811">  else                   /* normal unary operator */</a>
<a name="ln812">   {</a>
<a name="ln813">     switch(op)</a>
<a name="ln814">      {</a>
<a name="ln815">	case NEGATIVE : val *= -1;</a>
<a name="ln816">	                break;</a>
<a name="ln817"> </a>
<a name="ln818">	case BANG     : val = !val;</a>
<a name="ln819">	                break;</a>
<a name="ln820">	</a>
<a name="ln821">	case TWIDDLE  : val = ~val;</a>
<a name="ln822">                        break;</a>
<a name="ln823">      }</a>
<a name="ln824">   }</a>
<a name="ln825"> </a>
<a name="ln826">  return val;</a>
<a name="ln827">}</a>
<a name="ln828"> </a>
<a name="ln829"> </a>
<a name="ln830"> </a>
<a name="ln831">ULONG</a>
<a name="ln832">get_value(char **str)</a>
<a name="ln833">{</a>
<a name="ln834">  ULONG val;</a>
<a name="ln835">  char *var_name;</a>
<a name="ln836">  variable *v;</a>
<a name="ln837">  </a>
<a name="ln838">  if (**str == SINGLE_QUOTE)         /* a character constant */</a>
<a name="ln839">   {</a>
<a name="ln840">     unsigned int i;</a>
<a name="ln841">     </a>
<a name="ln842">     *str = *str + 1;                /* advance over the leading quote */</a>
<a name="ln843">     val = 0;</a>
<a name="ln844">     for(i=0; **str &amp;&amp; **str != SINGLE_QUOTE &amp;&amp; i &lt; sizeof(LONG); *str+=1,i++)</a>
<a name="ln845">      {</a>
<a name="ln846">	if (**str == '\\')  /* escape the next char */</a>
<a name="ln847">	  *str += 1;</a>
<a name="ln848">	</a>
<a name="ln849">	val &lt;&lt;= 8;</a>
<a name="ln850">	val |= (ULONG)((unsigned)**str);</a>
<a name="ln851">      }</a>
<a name="ln852"> </a>
<a name="ln853">     if (**str != SINGLE_QUOTE)       /* constant must have been too long */</a>
<a name="ln854">      {</a>
<a name="ln855">	fprintf(stderr, &quot;Warning: character constant not terminated or too &quot;</a>
<a name="ln856">		&quot;long (max len == %ld bytes)\n&quot;, sizeof(LONG));</a>
<a name="ln857">	while(**str &amp;&amp; **str != SINGLE_QUOTE)</a>
<a name="ln858">	  *str += 1;</a>
<a name="ln859">      }</a>
<a name="ln860">     else if (**str != '\0')</a>
<a name="ln861">       *str += 1;</a>
<a name="ln862">   }</a>
<a name="ln863">  else if (isdigit(**str))            /* a regular number */</a>
<a name="ln864">   {</a>
<a name="ln865">     val = STRTOUL(*str, str, 0);</a>
<a name="ln866"> </a>
<a name="ln867">     *str = skipwhite(*str);</a>
<a name="ln868">   }</a>
<a name="ln869">  else if (**str == USE_LAST_RESULT)  /* a `.' meaning use the last result */</a>
<a name="ln870">   {</a>
<a name="ln871">     val = last_result;</a>
<a name="ln872">     *str = skipwhite(*str+1);</a>
<a name="ln873">   }</a>
<a name="ln874">  else if (**str == LPAREN)           /* a parenthesized expression */</a>
<a name="ln875">   {</a>
<a name="ln876">     *str = skipwhite(*str + 1);</a>
<a name="ln877"> </a>
<a name="ln878">     val = assignment_expr(str);      /* start at top and come back down */</a>
<a name="ln879"> </a>
<a name="ln880">     if (**str == RPAREN)</a>
<a name="ln881">       *str = *str + 1;</a>
<a name="ln882">     else</a>
<a name="ln883">       fprintf(stderr, &quot;Mismatched paren's\n&quot;);</a>
<a name="ln884">   }</a>
<a name="ln885">  else if (isalpha(**str) || **str == '_')          /* a variable name */</a>
<a name="ln886">   {</a>
<a name="ln887">     if ((var_name = get_var_name(str)) == NULL)</a>
<a name="ln888">      {</a>
<a name="ln889">	fprintf(stderr, &quot;Can't get var name!\n&quot;);</a>
<a name="ln890">	return 0;	</a>
<a name="ln891">      }</a>
<a name="ln892">     </a>
<a name="ln893">     if (get_var(var_name, &amp;val) == 0)</a>
<a name="ln894">      {</a>
<a name="ln895">	fprintf(stderr, &quot;No such variable: %s (assigning value of zero)\n&quot;,</a>
<a name="ln896">		var_name);</a>
<a name="ln897"> </a>
<a name="ln898">	val = 0;</a>
<a name="ln899">	v = add_var(var_name, val);</a>
<a name="ln900">	if (v == NULL)</a>
<a name="ln901">	  return 0;</a>
<a name="ln902">      }</a>
<a name="ln903">     </a>
<a name="ln904">     *str = skipwhite(*str);</a>
<a name="ln905">     if (strncmp(*str, &quot;++&quot;, 2) == 0 || strncmp(*str, &quot;--&quot;, 2) == 0)</a>
<a name="ln906">      {</a>
<a name="ln907">	if ((v = lookup_var(var_name)) != NULL)</a>
<a name="ln908">	  {</a>
<a name="ln909">	    val = v-&gt;value;</a>
<a name="ln910">	    if (**str == '+')</a>
<a name="ln911">	      v-&gt;value++;</a>
<a name="ln912">	    else </a>
<a name="ln913">	      v-&gt;value--;</a>
<a name="ln914">	    *str = *str + 2;</a>
<a name="ln915">	  }</a>
<a name="ln916">	else</a>
<a name="ln917">	  {</a>
<a name="ln918">	    fprintf(stderr, &quot;%s is a read-only variable\n&quot;, var_name);</a>
<a name="ln919">	  }</a>
<a name="ln920">      }</a>
<a name="ln921"> </a>
<a name="ln922">     free(var_name);</a>
<a name="ln923">   }</a>
<a name="ln924">  else</a>
<a name="ln925">   {</a>
<a name="ln926">     fprintf(stderr, &quot;Expecting left paren, unary op, constant or variable.&quot;);</a>
<a name="ln927">     fprintf(stderr, &quot;  Got: `%s'\n&quot;, *str);</a>
<a name="ln928">     return 0;</a>
<a name="ln929">   }</a>
<a name="ln930"> </a>
<a name="ln931"> </a>
<a name="ln932">  return val;</a>
<a name="ln933">}</a>
<a name="ln934"> </a>
<a name="ln935"> </a>
<a name="ln936">/*</a>
<a name="ln937"> * Here are the functions that manipulate variables.</a>
<a name="ln938"> */</a>
<a name="ln939"> </a>
<a name="ln940">/*</a>
<a name="ln941">   this is a hook function for external read-only</a>
<a name="ln942">   variables.  If it is set and we don't find a</a>
<a name="ln943">   variable name in our name space, we call it to</a>
<a name="ln944">   look for the variable.  If it finds the name, it</a>
<a name="ln945">   fills in val and returns 1. If it returns 0, it</a>
<a name="ln946">   didn't find the variable.</a>
<a name="ln947">*/   </a>
<a name="ln948">static int (*external_var_lookup)(char *name, ULONG *val) = NULL;</a>
<a name="ln949"> </a>
<a name="ln950">/*</a>
<a name="ln951">   this very ugly function declaration is for the function</a>
<a name="ln952">   set_var_lookup_hook which accepts one argument, &quot;func&quot;, which</a>
<a name="ln953">   is a pointer to a function that returns int (and accepts a</a>
<a name="ln954">   char * and ULONG *).  set_var_lookup_hook returns a pointer to</a>
<a name="ln955">   a function that returns int and accepts char * and ULONG *.</a>
<a name="ln956"> </a>
<a name="ln957">   It's very ugly looking but fairly basic in what it does.  You</a>
<a name="ln958">   pass in a function to set as the variable name lookup up hook</a>
<a name="ln959">   and it passes back to you the old function (which you should</a>
<a name="ln960">   call if it is non-null and your function fails to find the</a>
<a name="ln961">   variable name).</a>
<a name="ln962">*/   </a>
<a name="ln963">int (*set_var_lookup_hook(int (*func)(char *name, ULONG *val)))(char *name, ULONG *val)</a>
<a name="ln964">{</a>
<a name="ln965">  int (*old_func)(char *name, ULONG *val) = external_var_lookup;</a>
<a name="ln966"> </a>
<a name="ln967">  external_var_lookup = func;</a>
<a name="ln968"> </a>
<a name="ln969">  return old_func;</a>
<a name="ln970">}</a>
<a name="ln971"> </a>
<a name="ln972"> </a>
<a name="ln973">variable *</a>
<a name="ln974">lookup_var(char *name)</a>
<a name="ln975">{</a>
<a name="ln976">  variable *v;</a>
<a name="ln977"> </a>
<a name="ln978">  for(v=vars; v; v=v-&gt;next)</a>
<a name="ln979">    if (v-&gt;name &amp;&amp; strcmp(v-&gt;name, name) == 0)</a>
<a name="ln980">      return v;</a>
<a name="ln981"> </a>
<a name="ln982">  return NULL;</a>
<a name="ln983">}</a>
<a name="ln984"> </a>
<a name="ln985"> </a>
<a name="ln986">variable *</a>
<a name="ln987">add_var(char *name, ULONG value)</a>
<a name="ln988">{</a>
<a name="ln989">  variable *v;</a>
<a name="ln990">  ULONG tmp;</a>
<a name="ln991"> </a>
<a name="ln992">  /* first make sure this isn't an external read-only variable */</a>
<a name="ln993">  if (external_var_lookup)</a>
<a name="ln994">    if (external_var_lookup(name, &amp;tmp) != 0)</a>
<a name="ln995">     {</a>
<a name="ln996">       fprintf(stderr, &quot;Can't assign/create %s, it is a read-only var\n&quot;,name);</a>
<a name="ln997">       return NULL;	 </a>
<a name="ln998">     }</a>
<a name="ln999">      </a>
<a name="ln1000">      </a>
<a name="ln1001">  v = (variable *)malloc(sizeof(variable));</a>
<a name="ln1002">  if (v == NULL)</a>
<a name="ln1003">   {</a>
<a name="ln1004">     fprintf(stderr, &quot;No memory to add variable: %s\n&quot;, name);</a>
<a name="ln1005">     return NULL;</a>
<a name="ln1006">   }</a>
<a name="ln1007"> </a>
<a name="ln1008">  v-&gt;name = strdup(name);</a>
<a name="ln1009">  v-&gt;value = value;</a>
<a name="ln1010">  v-&gt;next = vars;</a>
<a name="ln1011"> </a>
<a name="ln1012">  vars = v;  /* set head of list to the new guy */</a>
<a name="ln1013"> </a>
<a name="ln1014">  return v;</a>
<a name="ln1015">}</a>
<a name="ln1016"> </a>
<a name="ln1017">/*</a>
<a name="ln1018">   This routine and the companion get_var() are external</a>
<a name="ln1019">   interfaces to the variable manipulation routines.</a>
<a name="ln1020">*/   </a>
<a name="ln1021">void</a>
<a name="ln1022">set_var(char *name, ULONG val)</a>
<a name="ln1023">{</a>
<a name="ln1024">  variable *v;</a>
<a name="ln1025"> </a>
<a name="ln1026">  v = lookup_var(name);</a>
<a name="ln1027">  if (v != NULL)</a>
<a name="ln1028">    v-&gt;value = val;</a>
<a name="ln1029">  else</a>
<a name="ln1030">    add_var(name, val);</a>
<a name="ln1031">}</a>
<a name="ln1032"> </a>
<a name="ln1033"> </a>
<a name="ln1034">/*</a>
<a name="ln1035">   This function returns 1 on success of finding</a>
<a name="ln1036">   a variable and 0 on failure to find a variable.</a>
<a name="ln1037">   If a variable is found, val is filled with its</a>
<a name="ln1038">   value.</a>
<a name="ln1039">*/   </a>
<a name="ln1040">int</a>
<a name="ln1041">get_var(char *name, ULONG *val)</a>
<a name="ln1042">{</a>
<a name="ln1043">  variable *v;</a>
<a name="ln1044"> </a>
<a name="ln1045">  v = lookup_var(name);</a>
<a name="ln1046">  if (v != NULL)</a>
<a name="ln1047">   {</a>
<a name="ln1048">     *val = v-&gt;value;</a>
<a name="ln1049">     return 1;</a>
<a name="ln1050">   }</a>
<a name="ln1051">  else if (external_var_lookup != NULL)</a>
<a name="ln1052">   {</a>
<a name="ln1053">     return external_var_lookup(name, val);</a>
<a name="ln1054">   }</a>
<a name="ln1055">    </a>
<a name="ln1056">    return 0;</a>
<a name="ln1057">}</a>
<a name="ln1058"> </a>
<a name="ln1059">#define DEFAULT_LEN 32</a>
<a name="ln1060"> </a>
<a name="ln1061">char *</a>
<a name="ln1062">get_var_name(char **str)</a>
<a name="ln1063">{</a>
<a name="ln1064">  int i, len=DEFAULT_LEN;</a>
<a name="ln1065">  char *buff;</a>
<a name="ln1066"> </a>
<a name="ln1067">  if (isalpha(**str) == 0 &amp;&amp; **str != '_')</a>
<a name="ln1068">    return NULL;</a>
<a name="ln1069"> </a>
<a name="ln1070">  buff = (char *)malloc(len*sizeof(char));</a>
<a name="ln1071">  if (buff == NULL)</a>
<a name="ln1072">    return NULL;</a>
<a name="ln1073"> </a>
<a name="ln1074">  /*</a>
<a name="ln1075">   * First get the variable name</a>
<a name="ln1076">   */</a>
<a name="ln1077">  i=0;</a>
<a name="ln1078">  while(**str &amp;&amp; (isalnum(**str) || **str == '_'))</a>
<a name="ln1079">   {</a>
<a name="ln1080">     if (i &gt;= len-1)</a>
<a name="ln1081">      {</a>
<a name="ln1082">	len *= 2;</a>
<a name="ln1083">	buff = (char *)realloc(buff, len);</a>
<a name="ln1084">	if (buff == NULL)</a>
<a name="ln1085">	  return NULL;</a>
<a name="ln1086">      }</a>
<a name="ln1087">     </a>
<a name="ln1088">     buff[i++] = **str;</a>
<a name="ln1089">     *str = *str+1;</a>
<a name="ln1090">   }</a>
<a name="ln1091"> </a>
<a name="ln1092">  buff[i] = '\0';  /* null terminate */</a>
<a name="ln1093"> </a>
<a name="ln1094">  while (isalnum(**str) || **str == '_')  /* skip over any remaining junk */</a>
<a name="ln1095">    *str = *str+1;</a>
<a name="ln1096"> </a>
<a name="ln1097">  return buff;</a>
<a name="ln1098">}</a>
<a name="ln1099"> </a>
<a name="ln1100"> </a>
<a name="ln1101"> </a>
<a name="ln1102">char *</a>
<a name="ln1103">skipwhite(char *str)</a>
<a name="ln1104">{</a>
<a name="ln1105">  if (str == NULL)</a>
<a name="ln1106">    return NULL;</a>
<a name="ln1107">  </a>
<a name="ln1108">  while(*str &amp;&amp; (*str == ' ' || *str == '\t' || *str == '\n' || *str == '\f'))</a>
<a name="ln1109">    str++;</a>
<a name="ln1110"> </a>
<a name="ln1111">  return str;</a>
<a name="ln1112">}</a>

</code></pre>
<div class="balloon" rel="316"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v590/" target="_blank">V590</a> Consider inspecting the '* ptr == ';' && * ptr != '\0'' expression. The expression is excessive or contains a misprint.</p></div>
<div class="balloon" rel="287"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1010/" target="_blank">V1010</a> Unchecked tainted data is used in index: 'strlen(buff)'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
