
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>TermViewStates.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2001-2015, Haiku, Inc.</a>
<a name="ln3"> * Copyright 2003-2004 Kian Duffy, myob@users.sourceforge.net</a>
<a name="ln4"> * Parts Copyright 1998-1999 Kazuho Okui and Takashi Murai.</a>
<a name="ln5"> * All rights reserved. Distributed under the terms of the MIT license.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Authors:</a>
<a name="ln8"> *		Stefano Ceccherini, stefano.ceccherini@gmail.com</a>
<a name="ln9"> *		Kian Duffy, myob@users.sourceforge.net</a>
<a name="ln10"> *		Y.Hayakawa, hida@sawada.riec.tohoku.ac.jp</a>
<a name="ln11"> *		Ingo Weinhold, ingo_weinhold@gmx.de</a>
<a name="ln12"> *		Clemens Zeidler, haiku@Clemens-Zeidler.de</a>
<a name="ln13"> *		Siarzhuk Zharski, zharik@gmx.li</a>
<a name="ln14"> */</a>
<a name="ln15"> </a>
<a name="ln16"> </a>
<a name="ln17">#include &quot;TermViewStates.h&quot;</a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;stdio.h&gt;</a>
<a name="ln20">#include &lt;stdlib.h&gt;</a>
<a name="ln21">#include &lt;sys/stat.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;Catalog.h&gt;</a>
<a name="ln24">#include &lt;Clipboard.h&gt;</a>
<a name="ln25">#include &lt;Cursor.h&gt;</a>
<a name="ln26">#include &lt;FindDirectory.h&gt;</a>
<a name="ln27">#include &lt;LayoutBuilder.h&gt;</a>
<a name="ln28">#include &lt;MessageRunner.h&gt;</a>
<a name="ln29">#include &lt;Path.h&gt;</a>
<a name="ln30">#include &lt;PopUpMenu.h&gt;</a>
<a name="ln31">#include &lt;ScrollBar.h&gt;</a>
<a name="ln32">#include &lt;UTF8.h&gt;</a>
<a name="ln33">#include &lt;Window.h&gt;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;Array.h&gt;</a>
<a name="ln36"> </a>
<a name="ln37">#include &quot;ActiveProcessInfo.h&quot;</a>
<a name="ln38">#include &quot;Shell.h&quot;</a>
<a name="ln39">#include &quot;TermConst.h&quot;</a>
<a name="ln40">#include &quot;TerminalBuffer.h&quot;</a>
<a name="ln41">#include &quot;VTkeymap.h&quot;</a>
<a name="ln42">#include &quot;VTKeyTbl.h&quot;</a>
<a name="ln43"> </a>
<a name="ln44"> </a>
<a name="ln45">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln46">#define B_TRANSLATION_CONTEXT &quot;Terminal TermView&quot;</a>
<a name="ln47"> </a>
<a name="ln48"> </a>
<a name="ln49">// selection granularity</a>
<a name="ln50">enum {</a>
<a name="ln51">	SELECT_CHARS,</a>
<a name="ln52">	SELECT_WORDS,</a>
<a name="ln53">	SELECT_LINES</a>
<a name="ln54">};</a>
<a name="ln55"> </a>
<a name="ln56">static const uint32 kAutoScroll = 'AScr';</a>
<a name="ln57"> </a>
<a name="ln58">static const uint32 kMessageOpenLink = 'OLnk';</a>
<a name="ln59">static const uint32 kMessageCopyLink = 'CLnk';</a>
<a name="ln60">static const uint32 kMessageCopyAbsolutePath = 'CAbs';</a>
<a name="ln61">static const uint32 kMessageMenuClosed = 'MClo';</a>
<a name="ln62"> </a>
<a name="ln63"> </a>
<a name="ln64">static const char* const kKnownURLProtocols = &quot;http:https:ftp:mailto&quot;;</a>
<a name="ln65"> </a>
<a name="ln66"> </a>
<a name="ln67">// #pragma mark - State</a>
<a name="ln68"> </a>
<a name="ln69"> </a>
<a name="ln70">TermView::State::State(TermView* view)</a>
<a name="ln71">	:</a>
<a name="ln72">	fView(view)</a>
<a name="ln73">{</a>
<a name="ln74">}</a>
<a name="ln75"> </a>
<a name="ln76"> </a>
<a name="ln77">TermView::State::~State()</a>
<a name="ln78">{</a>
<a name="ln79">}</a>
<a name="ln80"> </a>
<a name="ln81"> </a>
<a name="ln82">void</a>
<a name="ln83">TermView::State::Entered()</a>
<a name="ln84">{</a>
<a name="ln85">}</a>
<a name="ln86"> </a>
<a name="ln87"> </a>
<a name="ln88">void</a>
<a name="ln89">TermView::State::Exited()</a>
<a name="ln90">{</a>
<a name="ln91">}</a>
<a name="ln92"> </a>
<a name="ln93"> </a>
<a name="ln94">bool</a>
<a name="ln95">TermView::State::MessageReceived(BMessage* message)</a>
<a name="ln96">{</a>
<a name="ln97">	return false;</a>
<a name="ln98">}</a>
<a name="ln99"> </a>
<a name="ln100"> </a>
<a name="ln101">void</a>
<a name="ln102">TermView::State::ModifiersChanged(int32 oldModifiers, int32 modifiers)</a>
<a name="ln103">{</a>
<a name="ln104">}</a>
<a name="ln105"> </a>
<a name="ln106"> </a>
<a name="ln107">void</a>
<a name="ln108">TermView::State::KeyDown(const char* bytes, int32 numBytes)</a>
<a name="ln109">{</a>
<a name="ln110">}</a>
<a name="ln111"> </a>
<a name="ln112"> </a>
<a name="ln113">void</a>
<a name="ln114">TermView::State::MouseDown(BPoint where, int32 buttons, int32 modifiers)</a>
<a name="ln115">{</a>
<a name="ln116">}</a>
<a name="ln117"> </a>
<a name="ln118"> </a>
<a name="ln119">void</a>
<a name="ln120">TermView::State::MouseMoved(BPoint where, uint32 transit,</a>
<a name="ln121">	const BMessage* message, int32 modifiers)</a>
<a name="ln122">{</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125"> </a>
<a name="ln126">void</a>
<a name="ln127">TermView::State::MouseUp(BPoint where, int32 buttons)</a>
<a name="ln128">{</a>
<a name="ln129">}</a>
<a name="ln130"> </a>
<a name="ln131"> </a>
<a name="ln132">void</a>
<a name="ln133">TermView::State::WindowActivated(bool active)</a>
<a name="ln134">{</a>
<a name="ln135">}</a>
<a name="ln136"> </a>
<a name="ln137"> </a>
<a name="ln138">void</a>
<a name="ln139">TermView::State::VisibleTextBufferChanged()</a>
<a name="ln140">{</a>
<a name="ln141">}</a>
<a name="ln142"> </a>
<a name="ln143"> </a>
<a name="ln144">// #pragma mark - StandardBaseState</a>
<a name="ln145"> </a>
<a name="ln146"> </a>
<a name="ln147">TermView::StandardBaseState::StandardBaseState(TermView* view)</a>
<a name="ln148">	:</a>
<a name="ln149">	State(view)</a>
<a name="ln150">{</a>
<a name="ln151">}</a>
<a name="ln152"> </a>
<a name="ln153"> </a>
<a name="ln154">bool</a>
<a name="ln155">TermView::StandardBaseState::_StandardMouseMoved(BPoint where, int32 modifiers)</a>
<a name="ln156">{</a>
<a name="ln157">	if (!fView-&gt;fReportAnyMouseEvent &amp;&amp; !fView-&gt;fReportButtonMouseEvent)</a>
<a name="ln158">		return false;</a>
<a name="ln159"> </a>
<a name="ln160">	TermPos clickPos = fView-&gt;_ConvertToTerminal(where);</a>
<a name="ln161"> </a>
<a name="ln162">	if (fView-&gt;fReportButtonMouseEvent) {</a>
<a name="ln163">		if (fView-&gt;fPrevPos.x != clickPos.x</a>
<a name="ln164">			|| fView-&gt;fPrevPos.y != clickPos.y) {</a>
<a name="ln165">			fView-&gt;_SendMouseEvent(fView-&gt;fMouseButtons, modifiers,</a>
<a name="ln166">				clickPos.x, clickPos.y, true);</a>
<a name="ln167">		}</a>
<a name="ln168">		fView-&gt;fPrevPos = clickPos;</a>
<a name="ln169">	} else {</a>
<a name="ln170">		fView-&gt;_SendMouseEvent(fView-&gt;fMouseButtons, modifiers, clickPos.x,</a>
<a name="ln171">			clickPos.y, true);</a>
<a name="ln172">	}</a>
<a name="ln173"> </a>
<a name="ln174">	return true;</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177"> </a>
<a name="ln178">// #pragma mark - DefaultState</a>
<a name="ln179"> </a>
<a name="ln180"> </a>
<a name="ln181">TermView::DefaultState::DefaultState(TermView* view)</a>
<a name="ln182">	:</a>
<a name="ln183">	StandardBaseState(view)</a>
<a name="ln184">{</a>
<a name="ln185">}</a>
<a name="ln186"> </a>
<a name="ln187"> </a>
<a name="ln188">void</a>
<a name="ln189">TermView::DefaultState::ModifiersChanged(int32 oldModifiers, int32 modifiers)</a>
<a name="ln190">{</a>
<a name="ln191">	_CheckEnterHyperLinkState(modifiers);</a>
<a name="ln192">}</a>
<a name="ln193"> </a>
<a name="ln194"> </a>
<a name="ln195">void</a>
<a name="ln196">TermView::DefaultState::KeyDown(const char* bytes, int32 numBytes)</a>
<a name="ln197">{</a>
<a name="ln198">	int32 key;</a>
<a name="ln199">	int32 mod;</a>
<a name="ln200">	int32 rawChar;</a>
<a name="ln201">	BMessage* currentMessage = fView-&gt;Looper()-&gt;CurrentMessage();</a>
<a name="ln202">	if (currentMessage == NULL)</a>
<a name="ln203">		return;</a>
<a name="ln204"> </a>
<a name="ln205">	currentMessage-&gt;FindInt32(&quot;modifiers&quot;, &amp;mod);</a>
<a name="ln206">	currentMessage-&gt;FindInt32(&quot;key&quot;, &amp;key);</a>
<a name="ln207">	currentMessage-&gt;FindInt32(&quot;raw_char&quot;, &amp;rawChar);</a>
<a name="ln208"> </a>
<a name="ln209">	fView-&gt;_ActivateCursor(true);</a>
<a name="ln210"> </a>
<a name="ln211">	// handle multi-byte chars</a>
<a name="ln212">	if (numBytes &gt; 1) {</a>
<a name="ln213">		if (fView-&gt;fEncoding != M_UTF8) {</a>
<a name="ln214">			char destBuffer[16];</a>
<a name="ln215">			int32 destLen = sizeof(destBuffer);</a>
<a name="ln216">			int32 state = 0;</a>
<a name="ln217">			convert_from_utf8(fView-&gt;fEncoding, bytes, &amp;numBytes, destBuffer,</a>
<a name="ln218">				&amp;destLen, &amp;state, '?');</a>
<a name="ln219">			fView-&gt;_ScrollTo(0, true);</a>
<a name="ln220">			fView-&gt;fShell-&gt;Write(destBuffer, destLen);</a>
<a name="ln221">			return;</a>
<a name="ln222">		}</a>
<a name="ln223"> </a>
<a name="ln224">		fView-&gt;_ScrollTo(0, true);</a>
<a name="ln225">		fView-&gt;fShell-&gt;Write(bytes, numBytes);</a>
<a name="ln226">		return;</a>
<a name="ln227">	}</a>
<a name="ln228"> </a>
<a name="ln229">	// Terminal filters RET, ENTER, F1...F12, and ARROW key code.</a>
<a name="ln230">	const char *toWrite = NULL;</a>
<a name="ln231"> </a>
<a name="ln232">	switch (*bytes) {</a>
<a name="ln233">		case B_RETURN:</a>
<a name="ln234">			if (rawChar == B_RETURN)</a>
<a name="ln235">				toWrite = &quot;\r&quot;;</a>
<a name="ln236">			break;</a>
<a name="ln237"> </a>
<a name="ln238">		case B_DELETE:</a>
<a name="ln239">			toWrite = DELETE_KEY_CODE;</a>
<a name="ln240">			break;</a>
<a name="ln241"> </a>
<a name="ln242">		case B_BACKSPACE:</a>
<a name="ln243">			// Translate only the actual backspace key to the backspace</a>
<a name="ln244">			// code. CTRL-H shall just be echoed.</a>
<a name="ln245">			if (!((mod &amp; B_CONTROL_KEY) &amp;&amp; rawChar == 'h'))</a>
<a name="ln246">				toWrite = BACKSPACE_KEY_CODE;</a>
<a name="ln247">			break;</a>
<a name="ln248"> </a>
<a name="ln249">		case B_LEFT_ARROW:</a>
<a name="ln250">			if (rawChar == B_LEFT_ARROW) {</a>
<a name="ln251">				if ((mod &amp; B_SHIFT_KEY) != 0) {</a>
<a name="ln252">					if (fView-&gt;fListener != NULL)</a>
<a name="ln253">						fView-&gt;fListener-&gt;PreviousTermView(fView);</a>
<a name="ln254">					return;</a>
<a name="ln255">				}</a>
<a name="ln256">				if ((mod &amp; B_CONTROL_KEY) || (mod &amp; B_COMMAND_KEY))</a>
<a name="ln257">					toWrite = CTRL_LEFT_ARROW_KEY_CODE;</a>
<a name="ln258">				else</a>
<a name="ln259">					toWrite = LEFT_ARROW_KEY_CODE;</a>
<a name="ln260">			}</a>
<a name="ln261">			break;</a>
<a name="ln262"> </a>
<a name="ln263">		case B_RIGHT_ARROW:</a>
<a name="ln264">			if (rawChar == B_RIGHT_ARROW) {</a>
<a name="ln265">				if ((mod &amp; B_SHIFT_KEY) != 0) {</a>
<a name="ln266">					if (fView-&gt;fListener != NULL)</a>
<a name="ln267">						fView-&gt;fListener-&gt;NextTermView(fView);</a>
<a name="ln268">					return;</a>
<a name="ln269">				}</a>
<a name="ln270">				if ((mod &amp; B_CONTROL_KEY) || (mod &amp; B_COMMAND_KEY))</a>
<a name="ln271">					toWrite = CTRL_RIGHT_ARROW_KEY_CODE;</a>
<a name="ln272">				else</a>
<a name="ln273">					toWrite = RIGHT_ARROW_KEY_CODE;</a>
<a name="ln274">			}</a>
<a name="ln275">			break;</a>
<a name="ln276"> </a>
<a name="ln277">		case B_UP_ARROW:</a>
<a name="ln278">			if (mod &amp; B_SHIFT_KEY) {</a>
<a name="ln279">				fView-&gt;_ScrollTo(fView-&gt;fScrollOffset - fView-&gt;fFontHeight,</a>
<a name="ln280">					true);</a>
<a name="ln281">				return;</a>
<a name="ln282">			}</a>
<a name="ln283">			if (rawChar == B_UP_ARROW) {</a>
<a name="ln284">				if (mod &amp; B_CONTROL_KEY)</a>
<a name="ln285">					toWrite = CTRL_UP_ARROW_KEY_CODE;</a>
<a name="ln286">				else</a>
<a name="ln287">					toWrite = UP_ARROW_KEY_CODE;</a>
<a name="ln288">			}</a>
<a name="ln289">			break;</a>
<a name="ln290"> </a>
<a name="ln291">		case B_DOWN_ARROW:</a>
<a name="ln292">			if (mod &amp; B_SHIFT_KEY) {</a>
<a name="ln293">				fView-&gt;_ScrollTo(fView-&gt;fScrollOffset + fView-&gt;fFontHeight,</a>
<a name="ln294">					true);</a>
<a name="ln295">				return;</a>
<a name="ln296">			}</a>
<a name="ln297"> </a>
<a name="ln298">			if (rawChar == B_DOWN_ARROW) {</a>
<a name="ln299">				if (mod &amp; B_CONTROL_KEY)</a>
<a name="ln300">					toWrite = CTRL_DOWN_ARROW_KEY_CODE;</a>
<a name="ln301">				else</a>
<a name="ln302">					toWrite = DOWN_ARROW_KEY_CODE;</a>
<a name="ln303">			}</a>
<a name="ln304">			break;</a>
<a name="ln305"> </a>
<a name="ln306">		case B_INSERT:</a>
<a name="ln307">			if (rawChar == B_INSERT)</a>
<a name="ln308">				toWrite = INSERT_KEY_CODE;</a>
<a name="ln309">			break;</a>
<a name="ln310"> </a>
<a name="ln311">		case B_HOME:</a>
<a name="ln312">			if (rawChar == B_HOME)</a>
<a name="ln313">				toWrite = HOME_KEY_CODE;</a>
<a name="ln314">			break;</a>
<a name="ln315"> </a>
<a name="ln316">		case B_END:</a>
<a name="ln317">			if (rawChar == B_END)</a>
<a name="ln318">				toWrite = END_KEY_CODE;</a>
<a name="ln319">			break;</a>
<a name="ln320"> </a>
<a name="ln321">		case B_PAGE_UP:</a>
<a name="ln322">			if (mod &amp; B_SHIFT_KEY) {</a>
<a name="ln323">				fView-&gt;_ScrollTo(</a>
<a name="ln324">					fView-&gt;fScrollOffset - fView-&gt;fFontHeight  * fView-&gt;fRows,</a>
<a name="ln325">					true);</a>
<a name="ln326">				return;</a>
<a name="ln327">			}</a>
<a name="ln328">			if (rawChar == B_PAGE_UP)</a>
<a name="ln329">				toWrite = PAGE_UP_KEY_CODE;</a>
<a name="ln330">			break;</a>
<a name="ln331"> </a>
<a name="ln332">		case B_PAGE_DOWN:</a>
<a name="ln333">			if (mod &amp; B_SHIFT_KEY) {</a>
<a name="ln334">				fView-&gt;_ScrollTo(</a>
<a name="ln335">					fView-&gt;fScrollOffset + fView-&gt;fFontHeight * fView-&gt;fRows,</a>
<a name="ln336">					true);</a>
<a name="ln337">				return;</a>
<a name="ln338">			}</a>
<a name="ln339">			if (rawChar == B_PAGE_DOWN)</a>
<a name="ln340">				toWrite = PAGE_DOWN_KEY_CODE;</a>
<a name="ln341">			break;</a>
<a name="ln342"> </a>
<a name="ln343">		case B_FUNCTION_KEY:</a>
<a name="ln344">			for (int32 i = 0; i &lt; 12; i++) {</a>
<a name="ln345">				if (key == function_keycode_table[i]) {</a>
<a name="ln346">					toWrite = function_key_char_table[i];</a>
<a name="ln347">					break;</a>
<a name="ln348">				}</a>
<a name="ln349">			}</a>
<a name="ln350">			break;</a>
<a name="ln351">	}</a>
<a name="ln352"> </a>
<a name="ln353">	// If the above code proposed an alternative string to write, we get it's</a>
<a name="ln354">	// length. Otherwise we write exactly the bytes passed to this method.</a>
<a name="ln355">	size_t toWriteLen;</a>
<a name="ln356">	if (toWrite != NULL) {</a>
<a name="ln357">		toWriteLen = strlen(toWrite);</a>
<a name="ln358">	} else {</a>
<a name="ln359">		toWrite = bytes;</a>
<a name="ln360">		toWriteLen = numBytes;</a>
<a name="ln361">	}</a>
<a name="ln362"> </a>
<a name="ln363">	fView-&gt;_ScrollTo(0, true);</a>
<a name="ln364">	fView-&gt;fShell-&gt;Write(toWrite, toWriteLen);</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367"> </a>
<a name="ln368">void</a>
<a name="ln369">TermView::DefaultState::MouseDown(BPoint where, int32 buttons, int32 modifiers)</a>
<a name="ln370">{</a>
<a name="ln371">	if (fView-&gt;fReportAnyMouseEvent || fView-&gt;fReportButtonMouseEvent</a>
<a name="ln372">		|| fView-&gt;fReportNormalMouseEvent || fView-&gt;fReportX10MouseEvent) {</a>
<a name="ln373">		TermPos clickPos = fView-&gt;_ConvertToTerminal(where);</a>
<a name="ln374">		fView-&gt;_SendMouseEvent(buttons, modifiers, clickPos.x, clickPos.y,</a>
<a name="ln375">			false);</a>
<a name="ln376">		return;</a>
<a name="ln377">	}</a>
<a name="ln378"> </a>
<a name="ln379">	// paste button</a>
<a name="ln380">	if ((buttons &amp; (B_SECONDARY_MOUSE_BUTTON | B_TERTIARY_MOUSE_BUTTON)) != 0) {</a>
<a name="ln381">		fView-&gt;Paste(fView-&gt;fMouseClipboard);</a>
<a name="ln382">		return;</a>
<a name="ln383">	}</a>
<a name="ln384"> </a>
<a name="ln385">	// select region</a>
<a name="ln386">	if (buttons == B_PRIMARY_MOUSE_BUTTON) {</a>
<a name="ln387">		fView-&gt;fSelectState-&gt;Prepare(where, modifiers);</a>
<a name="ln388">		fView-&gt;_NextState(fView-&gt;fSelectState);</a>
<a name="ln389">	}</a>
<a name="ln390">}</a>
<a name="ln391"> </a>
<a name="ln392"> </a>
<a name="ln393">void</a>
<a name="ln394">TermView::DefaultState::MouseMoved(BPoint where, uint32 transit,</a>
<a name="ln395">	const BMessage* dragMessage, int32 modifiers)</a>
<a name="ln396">{</a>
<a name="ln397">	if (_CheckEnterHyperLinkState(modifiers))</a>
<a name="ln398">		return;</a>
<a name="ln399"> </a>
<a name="ln400">	_StandardMouseMoved(where, modifiers);</a>
<a name="ln401">}</a>
<a name="ln402"> </a>
<a name="ln403"> </a>
<a name="ln404">void</a>
<a name="ln405">TermView::DefaultState::WindowActivated(bool active)</a>
<a name="ln406">{</a>
<a name="ln407">	if (active)</a>
<a name="ln408">		_CheckEnterHyperLinkState(fView-&gt;fModifiers);</a>
<a name="ln409">}</a>
<a name="ln410"> </a>
<a name="ln411"> </a>
<a name="ln412">bool</a>
<a name="ln413">TermView::DefaultState::_CheckEnterHyperLinkState(int32 modifiers)</a>
<a name="ln414">{</a>
<a name="ln415">	if ((modifiers &amp; B_COMMAND_KEY) != 0 &amp;&amp; fView-&gt;Window()-&gt;IsActive()) {</a>
<a name="ln416">		fView-&gt;_NextState(fView-&gt;fHyperLinkState);</a>
<a name="ln417">		return true;</a>
<a name="ln418">	}</a>
<a name="ln419"> </a>
<a name="ln420">	return false;</a>
<a name="ln421">}</a>
<a name="ln422"> </a>
<a name="ln423"> </a>
<a name="ln424">// #pragma mark - SelectState</a>
<a name="ln425"> </a>
<a name="ln426"> </a>
<a name="ln427">TermView::SelectState::SelectState(TermView* view)</a>
<a name="ln428">	:</a>
<a name="ln429">	StandardBaseState(view),</a>
<a name="ln430">	fSelectGranularity(SELECT_CHARS),</a>
<a name="ln431">	fCheckMouseTracking(false),</a>
<a name="ln432">	fMouseTracking(false)</a>
<a name="ln433">{</a>
<a name="ln434">}</a>
<a name="ln435"> </a>
<a name="ln436"> </a>
<a name="ln437">void</a>
<a name="ln438">TermView::SelectState::Prepare(BPoint where, int32 modifiers)</a>
<a name="ln439">{</a>
<a name="ln440">	int32 clicks;</a>
<a name="ln441">	fView-&gt;Window()-&gt;CurrentMessage()-&gt;FindInt32(&quot;clicks&quot;, &amp;clicks);</a>
<a name="ln442"> </a>
<a name="ln443">	if (fView-&gt;_HasSelection()) {</a>
<a name="ln444">		TermPos inPos = fView-&gt;_ConvertToTerminal(where);</a>
<a name="ln445">		if (fView-&gt;fSelection.RangeContains(inPos)) {</a>
<a name="ln446">			if (modifiers &amp; B_CONTROL_KEY) {</a>
<a name="ln447">				BPoint p;</a>
<a name="ln448">				uint32 bt;</a>
<a name="ln449">				do {</a>
<a name="ln450">					fView-&gt;GetMouse(&amp;p, &amp;bt);</a>
<a name="ln451"> </a>
<a name="ln452">					if (bt == 0) {</a>
<a name="ln453">						fView-&gt;_Deselect();</a>
<a name="ln454">						return;</a>
<a name="ln455">					}</a>
<a name="ln456"> </a>
<a name="ln457">					snooze(40000);</a>
<a name="ln458"> </a>
<a name="ln459">				} while (abs((int)(where.x - p.x)) &lt; 4</a>
<a name="ln460">					&amp;&amp; abs((int)(where.y - p.y)) &lt; 4);</a>
<a name="ln461"> </a>
<a name="ln462">				fView-&gt;InitiateDrag();</a>
<a name="ln463">				return;</a>
<a name="ln464">			}</a>
<a name="ln465">		}</a>
<a name="ln466">	}</a>
<a name="ln467"> </a>
<a name="ln468">	// If mouse has moved too much, disable double/triple click.</a>
<a name="ln469">	if (fView-&gt;_MouseDistanceSinceLastClick(where) &gt; 8)</a>
<a name="ln470">		clicks = 1;</a>
<a name="ln471"> </a>
<a name="ln472">	fView-&gt;SetMouseEventMask(B_POINTER_EVENTS | B_KEYBOARD_EVENTS,</a>
<a name="ln473">		B_NO_POINTER_HISTORY | B_LOCK_WINDOW_FOCUS);</a>
<a name="ln474"> </a>
<a name="ln475">	TermPos clickPos = fView-&gt;_ConvertToTerminal(where);</a>
<a name="ln476"> </a>
<a name="ln477">	if (modifiers &amp; B_SHIFT_KEY) {</a>
<a name="ln478">		fView-&gt;fInitialSelectionStart = clickPos;</a>
<a name="ln479">		fView-&gt;fInitialSelectionEnd = clickPos;</a>
<a name="ln480">		fView-&gt;_ExtendSelection(fView-&gt;fInitialSelectionStart, true, false);</a>
<a name="ln481">	} else {</a>
<a name="ln482">		fView-&gt;_Deselect();</a>
<a name="ln483">		fView-&gt;fInitialSelectionStart = clickPos;</a>
<a name="ln484">		fView-&gt;fInitialSelectionEnd = clickPos;</a>
<a name="ln485">	}</a>
<a name="ln486"> </a>
<a name="ln487">	// If clicks larger than 3, reset mouse click counter.</a>
<a name="ln488">	clicks = (clicks - 1) % 3 + 1;</a>
<a name="ln489"> </a>
<a name="ln490">	switch (clicks) {</a>
<a name="ln491">		case 1:</a>
<a name="ln492">			fCheckMouseTracking = true;</a>
<a name="ln493">			fSelectGranularity = SELECT_CHARS;</a>
<a name="ln494">			break;</a>
<a name="ln495"> </a>
<a name="ln496">		case 2:</a>
<a name="ln497">			fView-&gt;_SelectWord(where, (modifiers &amp; B_SHIFT_KEY) != 0, false);</a>
<a name="ln498">			fMouseTracking = true;</a>
<a name="ln499">			fSelectGranularity = SELECT_WORDS;</a>
<a name="ln500">			break;</a>
<a name="ln501"> </a>
<a name="ln502">		case 3:</a>
<a name="ln503">			fView-&gt;_SelectLine(where, (modifiers &amp; B_SHIFT_KEY) != 0, false);</a>
<a name="ln504">			fMouseTracking = true;</a>
<a name="ln505">			fSelectGranularity = SELECT_LINES;</a>
<a name="ln506">			break;</a>
<a name="ln507">	}</a>
<a name="ln508">}</a>
<a name="ln509"> </a>
<a name="ln510"> </a>
<a name="ln511">bool</a>
<a name="ln512">TermView::SelectState::MessageReceived(BMessage* message)</a>
<a name="ln513">{</a>
<a name="ln514">	if (message-&gt;what == kAutoScroll) {</a>
<a name="ln515">		_AutoScrollUpdate();</a>
<a name="ln516">		return true;</a>
<a name="ln517">	}</a>
<a name="ln518"> </a>
<a name="ln519">	return false;</a>
<a name="ln520">}</a>
<a name="ln521"> </a>
<a name="ln522"> </a>
<a name="ln523">void</a>
<a name="ln524">TermView::SelectState::MouseMoved(BPoint where, uint32 transit,</a>
<a name="ln525">	const BMessage* message, int32 modifiers)</a>
<a name="ln526">{</a>
<a name="ln527">	if (_StandardMouseMoved(where, modifiers))</a>
<a name="ln528">		return;</a>
<a name="ln529"> </a>
<a name="ln530">	if (fCheckMouseTracking) {</a>
<a name="ln531">		if (fView-&gt;_MouseDistanceSinceLastClick(where) &gt; 9)</a>
<a name="ln532">			fMouseTracking = true;</a>
<a name="ln533">	}</a>
<a name="ln534">	if (!fMouseTracking)</a>
<a name="ln535">		return;</a>
<a name="ln536"> </a>
<a name="ln537">	bool doAutoScroll = false;</a>
<a name="ln538"> </a>
<a name="ln539">	if (where.y &lt; 0) {</a>
<a name="ln540">		doAutoScroll = true;</a>
<a name="ln541">		fView-&gt;fAutoScrollSpeed = where.y;</a>
<a name="ln542">		where.x = 0;</a>
<a name="ln543">		where.y = 0;</a>
<a name="ln544">	}</a>
<a name="ln545"> </a>
<a name="ln546">	BRect bounds(fView-&gt;Bounds());</a>
<a name="ln547">	if (where.y &gt; bounds.bottom) {</a>
<a name="ln548">		doAutoScroll = true;</a>
<a name="ln549">		fView-&gt;fAutoScrollSpeed = where.y - bounds.bottom;</a>
<a name="ln550">		where.x = bounds.right;</a>
<a name="ln551">		where.y = bounds.bottom;</a>
<a name="ln552">	}</a>
<a name="ln553"> </a>
<a name="ln554">	if (doAutoScroll) {</a>
<a name="ln555">		if (fView-&gt;fAutoScrollRunner == NULL) {</a>
<a name="ln556">			BMessage message(kAutoScroll);</a>
<a name="ln557">			fView-&gt;fAutoScrollRunner = new (std::nothrow) BMessageRunner(</a>
<a name="ln558">				BMessenger(fView), &amp;message, 10000);</a>
<a name="ln559">		}</a>
<a name="ln560">	} else {</a>
<a name="ln561">		delete fView-&gt;fAutoScrollRunner;</a>
<a name="ln562">		fView-&gt;fAutoScrollRunner = NULL;</a>
<a name="ln563">	}</a>
<a name="ln564"> </a>
<a name="ln565">	switch (fSelectGranularity) {</a>
<a name="ln566">		case SELECT_CHARS:</a>
<a name="ln567">		{</a>
<a name="ln568">			// If we just start selecting, we first select the initially</a>
<a name="ln569">			// hit char, so that we get a proper initial selection -- the char</a>
<a name="ln570">			// in question, which will thus always be selected, regardless of</a>
<a name="ln571">			// whether selecting forward or backward.</a>
<a name="ln572">			if (fView-&gt;fInitialSelectionStart == fView-&gt;fInitialSelectionEnd) {</a>
<a name="ln573">				fView-&gt;_Select(fView-&gt;fInitialSelectionStart,</a>
<a name="ln574">					fView-&gt;fInitialSelectionEnd, true, true);</a>
<a name="ln575">			}</a>
<a name="ln576"> </a>
<a name="ln577">			fView-&gt;_ExtendSelection(fView-&gt;_ConvertToTerminal(where), true,</a>
<a name="ln578">				true);</a>
<a name="ln579">			break;</a>
<a name="ln580">		}</a>
<a name="ln581">		case SELECT_WORDS:</a>
<a name="ln582">			fView-&gt;_SelectWord(where, true, true);</a>
<a name="ln583">			break;</a>
<a name="ln584">		case SELECT_LINES:</a>
<a name="ln585">			fView-&gt;_SelectLine(where, true, true);</a>
<a name="ln586">			break;</a>
<a name="ln587">	}</a>
<a name="ln588">}</a>
<a name="ln589"> </a>
<a name="ln590"> </a>
<a name="ln591">void</a>
<a name="ln592">TermView::SelectState::MouseUp(BPoint where, int32 buttons)</a>
<a name="ln593">{</a>
<a name="ln594">	fCheckMouseTracking = false;</a>
<a name="ln595">	fMouseTracking = false;</a>
<a name="ln596"> </a>
<a name="ln597">	if (fView-&gt;fAutoScrollRunner != NULL) {</a>
<a name="ln598">		delete fView-&gt;fAutoScrollRunner;</a>
<a name="ln599">		fView-&gt;fAutoScrollRunner = NULL;</a>
<a name="ln600">	}</a>
<a name="ln601"> </a>
<a name="ln602">	// When releasing the first mouse button, we copy the selected text to the</a>
<a name="ln603">	// clipboard.</a>
<a name="ln604"> </a>
<a name="ln605">	if (fView-&gt;fReportAnyMouseEvent || fView-&gt;fReportButtonMouseEvent</a>
<a name="ln606">		|| fView-&gt;fReportNormalMouseEvent) {</a>
<a name="ln607">		TermPos clickPos = fView-&gt;_ConvertToTerminal(where);</a>
<a name="ln608">		fView-&gt;_SendMouseEvent(0, 0, clickPos.x, clickPos.y, false);</a>
<a name="ln609">	} else if ((buttons &amp; B_PRIMARY_MOUSE_BUTTON) == 0</a>
<a name="ln610">		&amp;&amp; (fView-&gt;fMouseButtons &amp; B_PRIMARY_MOUSE_BUTTON) != 0) {</a>
<a name="ln611">		fView-&gt;Copy(fView-&gt;fMouseClipboard);</a>
<a name="ln612">	}</a>
<a name="ln613"> </a>
<a name="ln614">	fView-&gt;_NextState(fView-&gt;fDefaultState);</a>
<a name="ln615">}</a>
<a name="ln616"> </a>
<a name="ln617"> </a>
<a name="ln618">void</a>
<a name="ln619">TermView::SelectState::_AutoScrollUpdate()</a>
<a name="ln620">{</a>
<a name="ln621">	if (fMouseTracking &amp;&amp; fView-&gt;fAutoScrollRunner != NULL</a>
<a name="ln622">		&amp;&amp; fView-&gt;fScrollBar != NULL) {</a>
<a name="ln623">		float value = fView-&gt;fScrollBar-&gt;Value();</a>
<a name="ln624">		fView-&gt;_ScrollTo(value + fView-&gt;fAutoScrollSpeed, true);</a>
<a name="ln625">		if (fView-&gt;fAutoScrollSpeed &lt; 0) {</a>
<a name="ln626">			fView-&gt;_ExtendSelection(</a>
<a name="ln627">				fView-&gt;_ConvertToTerminal(BPoint(0, 0)), true, true);</a>
<a name="ln628">		} else {</a>
<a name="ln629">			fView-&gt;_ExtendSelection(</a>
<a name="ln630">				fView-&gt;_ConvertToTerminal(fView-&gt;Bounds().RightBottom()), true,</a>
<a name="ln631">				true);</a>
<a name="ln632">		}</a>
<a name="ln633">	}</a>
<a name="ln634">}</a>
<a name="ln635"> </a>
<a name="ln636"> </a>
<a name="ln637">// #pragma mark - HyperLinkState</a>
<a name="ln638"> </a>
<a name="ln639"> </a>
<a name="ln640">TermView::HyperLinkState::HyperLinkState(TermView* view)</a>
<a name="ln641">	:</a>
<a name="ln642">	State(view),</a>
<a name="ln643">	fURLCharClassifier(kURLAdditionalWordCharacters),</a>
<a name="ln644">	fPathComponentCharClassifier(</a>
<a name="ln645">		BString(kDefaultAdditionalWordCharacters).RemoveFirst(&quot;/&quot;)),</a>
<a name="ln646">	fCurrentDirectory(),</a>
<a name="ln647">	fHighlight(),</a>
<a name="ln648">	fHighlightActive(false)</a>
<a name="ln649">{</a>
<a name="ln650">	fHighlight.SetHighlighter(this);</a>
<a name="ln651">}</a>
<a name="ln652"> </a>
<a name="ln653"> </a>
<a name="ln654">void</a>
<a name="ln655">TermView::HyperLinkState::Entered()</a>
<a name="ln656">{</a>
<a name="ln657">	ActiveProcessInfo activeProcessInfo;</a>
<a name="ln658">	if (fView-&gt;GetActiveProcessInfo(activeProcessInfo))</a>
<a name="ln659">		fCurrentDirectory = activeProcessInfo.CurrentDirectory();</a>
<a name="ln660">	else</a>
<a name="ln661">		fCurrentDirectory.Truncate(0);</a>
<a name="ln662"> </a>
<a name="ln663">	_UpdateHighlight();</a>
<a name="ln664">}</a>
<a name="ln665"> </a>
<a name="ln666"> </a>
<a name="ln667">void</a>
<a name="ln668">TermView::HyperLinkState::Exited()</a>
<a name="ln669">{</a>
<a name="ln670">	_DeactivateHighlight();</a>
<a name="ln671">}</a>
<a name="ln672"> </a>
<a name="ln673"> </a>
<a name="ln674">void</a>
<a name="ln675">TermView::HyperLinkState::ModifiersChanged(int32 oldModifiers, int32 modifiers)</a>
<a name="ln676">{</a>
<a name="ln677">	if ((modifiers &amp; B_COMMAND_KEY) == 0)</a>
<a name="ln678">		fView-&gt;_NextState(fView-&gt;fDefaultState);</a>
<a name="ln679">	else</a>
<a name="ln680">		_UpdateHighlight();</a>
<a name="ln681">}</a>
<a name="ln682"> </a>
<a name="ln683"> </a>
<a name="ln684">void</a>
<a name="ln685">TermView::HyperLinkState::MouseDown(BPoint where, int32 buttons,</a>
<a name="ln686">	int32 modifiers)</a>
<a name="ln687">{</a>
<a name="ln688">	TermPos start;</a>
<a name="ln689">	TermPos end;</a>
<a name="ln690">	HyperLink link;</a>
<a name="ln691"> </a>
<a name="ln692">	bool pathPrefixOnly = (modifiers &amp; B_SHIFT_KEY) != 0;</a>
<a name="ln693">	if (!_GetHyperLinkAt(where, pathPrefixOnly, link, start, end))</a>
<a name="ln694">		return;</a>
<a name="ln695"> </a>
<a name="ln696">	if ((buttons &amp; B_PRIMARY_MOUSE_BUTTON) != 0) {</a>
<a name="ln697">		link.Open();</a>
<a name="ln698">	} else if ((buttons &amp; B_SECONDARY_MOUSE_BUTTON) != 0) {</a>
<a name="ln699">		fView-&gt;fHyperLinkMenuState-&gt;Prepare(where, link);</a>
<a name="ln700">		fView-&gt;_NextState(fView-&gt;fHyperLinkMenuState);</a>
<a name="ln701">	}</a>
<a name="ln702">}</a>
<a name="ln703"> </a>
<a name="ln704"> </a>
<a name="ln705">void</a>
<a name="ln706">TermView::HyperLinkState::MouseMoved(BPoint where, uint32 transit,</a>
<a name="ln707">	const BMessage* message, int32 modifiers)</a>
<a name="ln708">{</a>
<a name="ln709">	_UpdateHighlight(where, modifiers);</a>
<a name="ln710">}</a>
<a name="ln711"> </a>
<a name="ln712"> </a>
<a name="ln713">void</a>
<a name="ln714">TermView::HyperLinkState::WindowActivated(bool active)</a>
<a name="ln715">{</a>
<a name="ln716">	if (!active)</a>
<a name="ln717">		fView-&gt;_NextState(fView-&gt;fDefaultState);</a>
<a name="ln718">}</a>
<a name="ln719"> </a>
<a name="ln720"> </a>
<a name="ln721">void</a>
<a name="ln722">TermView::HyperLinkState::VisibleTextBufferChanged()</a>
<a name="ln723">{</a>
<a name="ln724">	_UpdateHighlight();</a>
<a name="ln725">}</a>
<a name="ln726"> </a>
<a name="ln727"> </a>
<a name="ln728">rgb_color</a>
<a name="ln729">TermView::HyperLinkState::ForegroundColor()</a>
<a name="ln730">{</a>
<a name="ln731">	return make_color(0, 0, 255);</a>
<a name="ln732">}</a>
<a name="ln733"> </a>
<a name="ln734"> </a>
<a name="ln735">rgb_color</a>
<a name="ln736">TermView::HyperLinkState::BackgroundColor()</a>
<a name="ln737">{</a>
<a name="ln738">	return fView-&gt;fTextBackColor;</a>
<a name="ln739">}</a>
<a name="ln740"> </a>
<a name="ln741"> </a>
<a name="ln742">uint32</a>
<a name="ln743">TermView::HyperLinkState::AdjustTextAttributes(uint32 attributes)</a>
<a name="ln744">{</a>
<a name="ln745">	return attributes | UNDERLINE;</a>
<a name="ln746">}</a>
<a name="ln747"> </a>
<a name="ln748"> </a>
<a name="ln749">bool</a>
<a name="ln750">TermView::HyperLinkState::_GetHyperLinkAt(BPoint where, bool pathPrefixOnly,</a>
<a name="ln751">	HyperLink&amp; _link, TermPos&amp; _start, TermPos&amp; _end)</a>
<a name="ln752">{</a>
<a name="ln753">	TerminalBuffer* textBuffer = fView-&gt;fTextBuffer;</a>
<a name="ln754">	BAutolock textBufferLocker(textBuffer);</a>
<a name="ln755"> </a>
<a name="ln756">	TermPos pos = fView-&gt;_ConvertToTerminal(where);</a>
<a name="ln757"> </a>
<a name="ln758">	// try to get a URL first</a>
<a name="ln759">	BString text;</a>
<a name="ln760">	if (!textBuffer-&gt;FindWord(pos, &amp;fURLCharClassifier, false, _start, _end))</a>
<a name="ln761">		return false;</a>
<a name="ln762"> </a>
<a name="ln763">	text.Truncate(0);</a>
<a name="ln764">	textBuffer-&gt;GetStringFromRegion(text, _start, _end);</a>
<a name="ln765">	text.Trim();</a>
<a name="ln766"> </a>
<a name="ln767">	// We're only happy, if it has a protocol part which we know.</a>
<a name="ln768">	int32 colonIndex = text.FindFirst(':');</a>
<a name="ln769">	if (colonIndex &gt;= 0) {</a>
<a name="ln770">		BString protocol(text, colonIndex);</a>
<a name="ln771">		if (strstr(kKnownURLProtocols, protocol) != NULL) {</a>
<a name="ln772">			_link = HyperLink(text, HyperLink::TYPE_URL);</a>
<a name="ln773">			return true;</a>
<a name="ln774">		}</a>
<a name="ln775">	}</a>
<a name="ln776"> </a>
<a name="ln777">	// no obvious URL -- try file name</a>
<a name="ln778">	if (!textBuffer-&gt;FindWord(pos, fView-&gt;fCharClassifier, false, _start, _end))</a>
<a name="ln779">		return false;</a>
<a name="ln780"> </a>
<a name="ln781">	// In path-prefix-only mode we determine the end position anew by omitting</a>
<a name="ln782">	// the '/' in the allowed word chars.</a>
<a name="ln783">	if (pathPrefixOnly) {</a>
<a name="ln784">		TermPos componentStart;</a>
<a name="ln785">		TermPos componentEnd;</a>
<a name="ln786">		if (textBuffer-&gt;FindWord(pos, &amp;fPathComponentCharClassifier, false,</a>
<a name="ln787">				componentStart, componentEnd)) {</a>
<a name="ln788">			_end = componentEnd;</a>
<a name="ln789">		} else {</a>
<a name="ln790">			// That means pos points to a '/'. We simply use the previous</a>
<a name="ln791">			// position.</a>
<a name="ln792">			_end = pos;</a>
<a name="ln793">			if (_start == _end) {</a>
<a name="ln794">				// Well, must be just &quot;/&quot;. Advance to the next position.</a>
<a name="ln795">				if (!textBuffer-&gt;NextLinePos(_end, false))</a>
<a name="ln796">					return false;</a>
<a name="ln797">			}</a>
<a name="ln798">		}</a>
<a name="ln799">	}</a>
<a name="ln800"> </a>
<a name="ln801">	text.Truncate(0);</a>
<a name="ln802">	textBuffer-&gt;GetStringFromRegion(text, _start, _end);</a>
<a name="ln803">	text.Trim();</a>
<a name="ln804">	if (text.IsEmpty())</a>
<a name="ln805">		return false;</a>
<a name="ln806"> </a>
<a name="ln807">	// Collect a list of colons in the string and their respective positions in</a>
<a name="ln808">	// the text buffer. We do this up-front so we can unlock the text buffer</a>
<a name="ln809">	// while we're doing all the entry existence tests.</a>
<a name="ln810">	typedef Array&lt;CharPosition&gt; ColonList;</a>
<a name="ln811">	ColonList colonPositions;</a>
<a name="ln812">	TermPos searchPos = _start;</a>
<a name="ln813">	for (int32 index = 0; (index = text.FindFirst(':', index)) &gt;= 0;) {</a>
<a name="ln814">		TermPos foundStart;</a>
<a name="ln815">		TermPos foundEnd;</a>
<a name="ln816">		if (!textBuffer-&gt;Find(&quot;:&quot;, searchPos, true, true, false, foundStart,</a>
<a name="ln817">				foundEnd)) {</a>
<a name="ln818">			return false;</a>
<a name="ln819">		}</a>
<a name="ln820"> </a>
<a name="ln821">		CharPosition colonPosition;</a>
<a name="ln822">		colonPosition.index = index;</a>
<a name="ln823">		colonPosition.position = foundStart;</a>
<a name="ln824">		if (!colonPositions.Add(colonPosition))</a>
<a name="ln825">			return false;</a>
<a name="ln826"> </a>
<a name="ln827">		index++;</a>
<a name="ln828">		searchPos = foundEnd;</a>
<a name="ln829">	}</a>
<a name="ln830"> </a>
<a name="ln831">	textBufferLocker.Unlock();</a>
<a name="ln832"> </a>
<a name="ln833">	// Since we also want to consider ':' a potential path delimiter, in two</a>
<a name="ln834">	// nested loops we chop off components from the beginning respective the</a>
<a name="ln835">	// end.</a>
<a name="ln836">	BString originalText = text;</a>
<a name="ln837">	TermPos originalStart = _start;</a>
<a name="ln838">	TermPos originalEnd = _end;</a>
<a name="ln839"> </a>
<a name="ln840">	int32 colonCount = colonPositions.Count();</a>
<a name="ln841">	for (int32 startColonIndex = -1; startColonIndex &lt; colonCount;</a>
<a name="ln842">			startColonIndex++) {</a>
<a name="ln843">		int32 startIndex;</a>
<a name="ln844">		if (startColonIndex &lt; 0) {</a>
<a name="ln845">			startIndex = 0;</a>
<a name="ln846">			_start = originalStart;</a>
<a name="ln847">		} else {</a>
<a name="ln848">			startIndex = colonPositions[startColonIndex].index + 1;</a>
<a name="ln849">			_start = colonPositions[startColonIndex].position;</a>
<a name="ln850">			if (_start &gt;= pos)</a>
<a name="ln851">				break;</a>
<a name="ln852">			_start.x++;</a>
<a name="ln853">				// Note: This is potentially a non-normalized position (i.e.</a>
<a name="ln854">				// the end of a soft-wrapped line). While not that nice, it</a>
<a name="ln855">				// works anyway.</a>
<a name="ln856">		}</a>
<a name="ln857"> </a>
<a name="ln858">		for (int32 endColonIndex = colonCount; endColonIndex &gt; startColonIndex;</a>
<a name="ln859">				endColonIndex--) {</a>
<a name="ln860">			int32 endIndex;</a>
<a name="ln861">			if (endColonIndex == colonCount) {</a>
<a name="ln862">				endIndex = originalText.Length();</a>
<a name="ln863">				_end = originalEnd;</a>
<a name="ln864">			} else {</a>
<a name="ln865">				endIndex = colonPositions[endColonIndex].index;</a>
<a name="ln866">				_end = colonPositions[endColonIndex].position;</a>
<a name="ln867">				if (_end &lt;= pos)</a>
<a name="ln868">					break;</a>
<a name="ln869">			}</a>
<a name="ln870"> </a>
<a name="ln871">			originalText.CopyInto(text, startIndex, endIndex - startIndex);</a>
<a name="ln872">			if (text.IsEmpty())</a>
<a name="ln873">				continue;</a>
<a name="ln874"> </a>
<a name="ln875">			// check, whether the file exists</a>
<a name="ln876">			BString actualPath;</a>
<a name="ln877">			if (_EntryExists(text, actualPath)) {</a>
<a name="ln878">				_link = HyperLink(text, actualPath, HyperLink::TYPE_PATH);</a>
<a name="ln879">				return true;</a>
<a name="ln880">			}</a>
<a name="ln881"> </a>
<a name="ln882">			// As such this isn't an existing path. We also want to recognize:</a>
<a name="ln883">			// * &quot;&lt;path&gt;:&lt;line&gt;&quot;</a>
<a name="ln884">			// * &quot;&lt;path&gt;:&lt;line&gt;:&lt;column&gt;&quot;</a>
<a name="ln885"> </a>
<a name="ln886">			BString path = text;</a>
<a name="ln887"> </a>
<a name="ln888">			for (int32 i = 0; i &lt; 2; i++) {</a>
<a name="ln889">				int32 colonIndex = path.FindLast(':');</a>
<a name="ln890">				if (colonIndex &lt;= 0 || colonIndex == path.Length() - 1)</a>
<a name="ln891">					break;</a>
<a name="ln892"> </a>
<a name="ln893">				char* numberEnd;</a>
<a name="ln894">				strtol(path.String() + colonIndex + 1, &amp;numberEnd, 0);</a>
<a name="ln895">				if (*numberEnd != '\0')</a>
<a name="ln896">					break;</a>
<a name="ln897"> </a>
<a name="ln898">				path.Truncate(colonIndex);</a>
<a name="ln899">				if (_EntryExists(path, actualPath)) {</a>
<a name="ln900">					BString address = path == actualPath</a>
<a name="ln901">						? text</a>
<a name="ln902">						: BString(actualPath) &lt;&lt; (text.String() + colonIndex);</a>
<a name="ln903">					_link = HyperLink(text, address,</a>
<a name="ln904">						i == 0</a>
<a name="ln905">							? HyperLink::TYPE_PATH_WITH_LINE</a>
<a name="ln906">							: HyperLink::TYPE_PATH_WITH_LINE_AND_COLUMN);</a>
<a name="ln907">					return true;</a>
<a name="ln908">				}</a>
<a name="ln909">			}</a>
<a name="ln910">		}</a>
<a name="ln911">	}</a>
<a name="ln912"> </a>
<a name="ln913">	return false;</a>
<a name="ln914">}</a>
<a name="ln915"> </a>
<a name="ln916"> </a>
<a name="ln917">bool</a>
<a name="ln918">TermView::HyperLinkState::_EntryExists(const BString&amp; path,</a>
<a name="ln919">	BString&amp; _actualPath) const</a>
<a name="ln920">{</a>
<a name="ln921">	if (path.IsEmpty())</a>
<a name="ln922">		return false;</a>
<a name="ln923"> </a>
<a name="ln924">	if (path[0] == '/' || fCurrentDirectory.IsEmpty()) {</a>
<a name="ln925">		_actualPath = path;</a>
<a name="ln926">	} else if (path == &quot;~&quot; || path.StartsWith(&quot;~/&quot;)) {</a>
<a name="ln927">		// Replace '~' with the user's home directory. We don't handle &quot;~user&quot;</a>
<a name="ln928">		// here yet.</a>
<a name="ln929">		BPath homeDirectory;</a>
<a name="ln930">		if (find_directory(B_USER_DIRECTORY, &amp;homeDirectory) != B_OK)</a>
<a name="ln931">			return false;</a>
<a name="ln932">		_actualPath = homeDirectory.Path();</a>
<a name="ln933">		_actualPath &lt;&lt; path.String() + 1;</a>
<a name="ln934">	} else {</a>
<a name="ln935">		_actualPath.Truncate(0);</a>
<a name="ln936">		_actualPath &lt;&lt; fCurrentDirectory &lt;&lt; '/' &lt;&lt; path;</a>
<a name="ln937">	}</a>
<a name="ln938"> </a>
<a name="ln939">	struct stat st;</a>
<a name="ln940">	return lstat(_actualPath, &amp;st) == 0;</a>
<a name="ln941">}</a>
<a name="ln942"> </a>
<a name="ln943"> </a>
<a name="ln944">void</a>
<a name="ln945">TermView::HyperLinkState::_UpdateHighlight()</a>
<a name="ln946">{</a>
<a name="ln947">	BPoint where;</a>
<a name="ln948">	uint32 buttons;</a>
<a name="ln949">	fView-&gt;GetMouse(&amp;where, &amp;buttons, false);</a>
<a name="ln950">	_UpdateHighlight(where, fView-&gt;fModifiers);</a>
<a name="ln951">}</a>
<a name="ln952"> </a>
<a name="ln953"> </a>
<a name="ln954">void</a>
<a name="ln955">TermView::HyperLinkState::_UpdateHighlight(BPoint where, int32 modifiers)</a>
<a name="ln956">{</a>
<a name="ln957">	TermPos start;</a>
<a name="ln958">	TermPos end;</a>
<a name="ln959">	HyperLink link;</a>
<a name="ln960"> </a>
<a name="ln961">	bool pathPrefixOnly = (modifiers &amp; B_SHIFT_KEY) != 0;</a>
<a name="ln962">	if (_GetHyperLinkAt(where, pathPrefixOnly, link, start, end))</a>
<a name="ln963">		_ActivateHighlight(start, end);</a>
<a name="ln964">	else</a>
<a name="ln965">		_DeactivateHighlight();</a>
<a name="ln966">}</a>
<a name="ln967"> </a>
<a name="ln968"> </a>
<a name="ln969">void</a>
<a name="ln970">TermView::HyperLinkState::_ActivateHighlight(const TermPos&amp; start,</a>
<a name="ln971">	const TermPos&amp; end)</a>
<a name="ln972">{</a>
<a name="ln973">	if (fHighlightActive) {</a>
<a name="ln974">		if (fHighlight.Start() == start &amp;&amp; fHighlight.End() == end)</a>
<a name="ln975">			return;</a>
<a name="ln976"> </a>
<a name="ln977">		_DeactivateHighlight();</a>
<a name="ln978">	}</a>
<a name="ln979"> </a>
<a name="ln980">	fHighlight.SetRange(start, end);</a>
<a name="ln981">	fView-&gt;_AddHighlight(&amp;fHighlight);</a>
<a name="ln982">	BCursor cursor(B_CURSOR_ID_FOLLOW_LINK);</a>
<a name="ln983">	fView-&gt;SetViewCursor(&amp;cursor);</a>
<a name="ln984">	fHighlightActive = true;</a>
<a name="ln985">}</a>
<a name="ln986"> </a>
<a name="ln987"> </a>
<a name="ln988">void</a>
<a name="ln989">TermView::HyperLinkState::_DeactivateHighlight()</a>
<a name="ln990">{</a>
<a name="ln991">	if (fHighlightActive) {</a>
<a name="ln992">		fView-&gt;_RemoveHighlight(&amp;fHighlight);</a>
<a name="ln993">		BCursor cursor(B_CURSOR_ID_SYSTEM_DEFAULT);</a>
<a name="ln994">		fView-&gt;SetViewCursor(&amp;cursor);</a>
<a name="ln995">		fHighlightActive = false;</a>
<a name="ln996">	}</a>
<a name="ln997">}</a>
<a name="ln998"> </a>
<a name="ln999"> </a>
<a name="ln1000">// #pragma mark - HyperLinkMenuState</a>
<a name="ln1001"> </a>
<a name="ln1002"> </a>
<a name="ln1003">class TermView::HyperLinkMenuState::PopUpMenu : public BPopUpMenu {</a>
<a name="ln1004">public:</a>
<a name="ln1005">	PopUpMenu(const BMessenger&amp; messageTarget)</a>
<a name="ln1006">		:</a>
<a name="ln1007">		BPopUpMenu(&quot;open hyperlink&quot;),</a>
<a name="ln1008">		fMessageTarget(messageTarget)</a>
<a name="ln1009">	{</a>
<a name="ln1010">		SetAsyncAutoDestruct(true);</a>
<a name="ln1011">	}</a>
<a name="ln1012"> </a>
<a name="ln1013">	~PopUpMenu()</a>
<a name="ln1014">	{</a>
<a name="ln1015">		fMessageTarget.SendMessage(kMessageMenuClosed);</a>
<a name="ln1016">	}</a>
<a name="ln1017"> </a>
<a name="ln1018">private:</a>
<a name="ln1019">	BMessenger	fMessageTarget;</a>
<a name="ln1020">};</a>
<a name="ln1021"> </a>
<a name="ln1022"> </a>
<a name="ln1023">TermView::HyperLinkMenuState::HyperLinkMenuState(TermView* view)</a>
<a name="ln1024">	:</a>
<a name="ln1025">	State(view),</a>
<a name="ln1026">	fLink()</a>
<a name="ln1027">{</a>
<a name="ln1028">}</a>
<a name="ln1029"> </a>
<a name="ln1030"> </a>
<a name="ln1031">void</a>
<a name="ln1032">TermView::HyperLinkMenuState::Prepare(BPoint point, const HyperLink&amp; link)</a>
<a name="ln1033">{</a>
<a name="ln1034">	fLink = link;</a>
<a name="ln1035"> </a>
<a name="ln1036">	// open context menu</a>
<a name="ln1037">	PopUpMenu* menu = new PopUpMenu(fView);</a>
<a name="ln1038">	BLayoutBuilder::Menu&lt;&gt; menuBuilder(menu);</a>
<a name="ln1039">	switch (link.GetType()) {</a>
<a name="ln1040">		case HyperLink::TYPE_URL:</a>
<a name="ln1041">			menuBuilder</a>
<a name="ln1042">				.AddItem(B_TRANSLATE(&quot;Open link&quot;), kMessageOpenLink)</a>
<a name="ln1043">				.AddItem(B_TRANSLATE(&quot;Copy link location&quot;), kMessageCopyLink);</a>
<a name="ln1044">			break;</a>
<a name="ln1045"> </a>
<a name="ln1046">		case HyperLink::TYPE_PATH:</a>
<a name="ln1047">		case HyperLink::TYPE_PATH_WITH_LINE:</a>
<a name="ln1048">		case HyperLink::TYPE_PATH_WITH_LINE_AND_COLUMN:</a>
<a name="ln1049">			menuBuilder.AddItem(B_TRANSLATE(&quot;Open path&quot;), kMessageOpenLink);</a>
<a name="ln1050">			menuBuilder.AddItem(B_TRANSLATE(&quot;Copy path&quot;), kMessageCopyLink);</a>
<a name="ln1051">			if (fLink.Text() != fLink.Address()) {</a>
<a name="ln1052">				menuBuilder.AddItem(B_TRANSLATE(&quot;Copy absolute path&quot;),</a>
<a name="ln1053">					kMessageCopyAbsolutePath);</a>
<a name="ln1054">			}</a>
<a name="ln1055">			break;</a>
<a name="ln1056">	}</a>
<a name="ln1057">	menu-&gt;SetTargetForItems(fView);</a>
<a name="ln1058">	menu-&gt;Go(fView-&gt;ConvertToScreen(point), true, true, true);</a>
<a name="ln1059">}</a>
<a name="ln1060"> </a>
<a name="ln1061"> </a>
<a name="ln1062">void</a>
<a name="ln1063">TermView::HyperLinkMenuState::Exited()</a>
<a name="ln1064">{</a>
<a name="ln1065">	fLink = HyperLink();</a>
<a name="ln1066">}</a>
<a name="ln1067"> </a>
<a name="ln1068"> </a>
<a name="ln1069">bool</a>
<a name="ln1070">TermView::HyperLinkMenuState::MessageReceived(BMessage* message)</a>
<a name="ln1071">{</a>
<a name="ln1072">	switch (message-&gt;what) {</a>
<a name="ln1073">		case kMessageOpenLink:</a>
<a name="ln1074">			if (fLink.IsValid())</a>
<a name="ln1075">				fLink.Open();</a>
<a name="ln1076">			return true;</a>
<a name="ln1077"> </a>
<a name="ln1078">		case kMessageCopyLink:</a>
<a name="ln1079">		case kMessageCopyAbsolutePath:</a>
<a name="ln1080">		{</a>
<a name="ln1081">			if (fLink.IsValid()) {</a>
<a name="ln1082">				BString toCopy = message-&gt;what == kMessageCopyLink</a>
<a name="ln1083">					? fLink.Text() : fLink.Address();</a>
<a name="ln1084"> </a>
<a name="ln1085">				if (!be_clipboard-&gt;Lock())</a>
<a name="ln1086">					return true;</a>
<a name="ln1087"> </a>
<a name="ln1088">				be_clipboard-&gt;Clear();</a>
<a name="ln1089"> </a>
<a name="ln1090">				if (BMessage *data = be_clipboard-&gt;Data()) {</a>
<a name="ln1091">					data-&gt;AddData(&quot;text/plain&quot;, B_MIME_TYPE, toCopy.String(),</a>
<a name="ln1092">						toCopy.Length());</a>
<a name="ln1093">					be_clipboard-&gt;Commit();</a>
<a name="ln1094">				}</a>
<a name="ln1095"> </a>
<a name="ln1096">				be_clipboard-&gt;Unlock();</a>
<a name="ln1097">			}</a>
<a name="ln1098">			return true;</a>
<a name="ln1099">		}</a>
<a name="ln1100"> </a>
<a name="ln1101">		case kMessageMenuClosed:</a>
<a name="ln1102">			fView-&gt;_NextState(fView-&gt;fDefaultState);</a>
<a name="ln1103">			return true;</a>
<a name="ln1104">	}</a>
<a name="ln1105"> </a>
<a name="ln1106">	return false;</a>
<a name="ln1107">}</a>

</code></pre>
<div class="balloon" rel="894"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v530/" target="_blank">V530</a> The return value of function 'strtol' is required to be utilized.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
