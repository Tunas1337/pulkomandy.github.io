
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>Iterators.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// Iterators.h</a>
<a name="ln2">//</a>
<a name="ln3">// Copyright (c) 2003-2010, Ingo Weinhold (bonefish@cs.tu-berlin.de)</a>
<a name="ln4">//</a>
<a name="ln5">// This program is free software; you can redistribute it and/or modify</a>
<a name="ln6">// it under the terms of the GNU General Public License as published by</a>
<a name="ln7">// the Free Software Foundation; either version 2 of the License, or</a>
<a name="ln8">// (at your option) any later version.</a>
<a name="ln9">//</a>
<a name="ln10">// This program is distributed in the hope that it will be useful,</a>
<a name="ln11">// but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">// GNU General Public License for more details.</a>
<a name="ln14">//</a>
<a name="ln15">// You should have received a copy of the GNU General Public License</a>
<a name="ln16">// along with this program; if not, write to the Free Software</a>
<a name="ln17">// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</a>
<a name="ln18">//</a>
<a name="ln19">// You can alternatively use *this file* under the terms of the the MIT</a>
<a name="ln20">// license included in this package.</a>
<a name="ln21"> </a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;Iterators.h&quot;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;Block.h&quot;</a>
<a name="ln26">#include &quot;BlockCache.h&quot;</a>
<a name="ln27">#include &quot;Key.h&quot;</a>
<a name="ln28">#include &quot;IndirectItem.h&quot;</a>
<a name="ln29">#include &quot;StatItem.h&quot;</a>
<a name="ln30">#include &quot;Tree.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32"> </a>
<a name="ln33">// min and max</a>
<a name="ln34">// We don't want to include &lt;algobase.h&gt; otherwise we also get &lt;iostream.h&gt;</a>
<a name="ln35">// and other undesired things.</a>
<a name="ln36">template&lt;typename C&gt;</a>
<a name="ln37">static inline C min(const C &amp;a, const C &amp;b) { return (a &lt; b ? a : b); }</a>
<a name="ln38">template&lt;typename C&gt;</a>
<a name="ln39">static inline C max(const C &amp;a, const C &amp;b) { return (a &gt; b ? a : b); }</a>
<a name="ln40"> </a>
<a name="ln41">/*!</a>
<a name="ln42">	\class TreePath</a>
<a name="ln43">	\brief Represents a path in the tree.</a>
<a name="ln44"> </a>
<a name="ln45">	It is composed of TreePath::Elements each one storing the block number</a>
<a name="ln46">	of a node and the index of a child node.</a>
<a name="ln47">*/</a>
<a name="ln48"> </a>
<a name="ln49">// constructor</a>
<a name="ln50">TreePath::TreePath(uint32 maxLength)</a>
<a name="ln51">	: fMaxLength(maxLength),</a>
<a name="ln52">	  fLength(0),</a>
<a name="ln53">	  fElements(NULL)</a>
<a name="ln54">{</a>
<a name="ln55">	fElements = new(nothrow) Element[fMaxLength];</a>
<a name="ln56">}</a>
<a name="ln57"> </a>
<a name="ln58">// destructor</a>
<a name="ln59">TreePath::~TreePath()</a>
<a name="ln60">{</a>
<a name="ln61">	if (fElements)</a>
<a name="ln62">		delete[] fElements;</a>
<a name="ln63">}</a>
<a name="ln64"> </a>
<a name="ln65">// InitCheck</a>
<a name="ln66">status_t</a>
<a name="ln67">TreePath::InitCheck() const</a>
<a name="ln68">{</a>
<a name="ln69">	return (fElements ? B_OK : B_NO_MEMORY);</a>
<a name="ln70">}</a>
<a name="ln71"> </a>
<a name="ln72">// GetMaxLength</a>
<a name="ln73">uint32</a>
<a name="ln74">TreePath::GetMaxLength() const</a>
<a name="ln75">{</a>
<a name="ln76">	return fMaxLength;</a>
<a name="ln77">}</a>
<a name="ln78"> </a>
<a name="ln79">// GetLength</a>
<a name="ln80">uint32</a>
<a name="ln81">TreePath::GetLength() const</a>
<a name="ln82">{</a>
<a name="ln83">	return fLength;</a>
<a name="ln84">}</a>
<a name="ln85"> </a>
<a name="ln86">// ElementAt</a>
<a name="ln87">const TreePath::Element *</a>
<a name="ln88">TreePath::ElementAt(int32 index) const</a>
<a name="ln89">{</a>
<a name="ln90">	Element *element = NULL;</a>
<a name="ln91">	if (InitCheck() == B_OK &amp;&amp; index &gt;= 0 &amp;&amp; (uint32)index &lt; GetLength())</a>
<a name="ln92">		element = fElements + index;</a>
<a name="ln93">	return element;</a>
<a name="ln94">}</a>
<a name="ln95"> </a>
<a name="ln96">// GetTopElement</a>
<a name="ln97">const TreePath::Element *</a>
<a name="ln98">TreePath::GetTopElement() const</a>
<a name="ln99">{</a>
<a name="ln100">	return ElementAt(GetLength() - 1);</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">// PushElement</a>
<a name="ln104">status_t</a>
<a name="ln105">TreePath::PushElement(uint64 blockNumber, int32 index)</a>
<a name="ln106">{</a>
<a name="ln107">	status_t error = (fLength &lt; fMaxLength ? InitCheck() : B_BAD_VALUE);</a>
<a name="ln108">	if (error == B_OK) {</a>
<a name="ln109">		error = fElements[fLength].SetTo(blockNumber, index);</a>
<a name="ln110">		if (error == B_OK)</a>
<a name="ln111">			fLength++;</a>
<a name="ln112">	}</a>
<a name="ln113">	return error;</a>
<a name="ln114">}</a>
<a name="ln115"> </a>
<a name="ln116">// PopElement</a>
<a name="ln117">status_t</a>
<a name="ln118">TreePath::PopElement()</a>
<a name="ln119">{</a>
<a name="ln120">	status_t error = InitCheck();</a>
<a name="ln121">	if (error == B_OK) {</a>
<a name="ln122">		if (fLength &gt; 0)</a>
<a name="ln123">			fLength--;</a>
<a name="ln124">		else</a>
<a name="ln125">			error = B_ERROR;</a>
<a name="ln126">	}</a>
<a name="ln127">	return error;</a>
<a name="ln128">}</a>
<a name="ln129"> </a>
<a name="ln130"> </a>
<a name="ln131">/*!</a>
<a name="ln132">	\class TreePath::Element</a>
<a name="ln133">	\brief Store information about one element in a tree path.</a>
<a name="ln134">*/</a>
<a name="ln135"> </a>
<a name="ln136">// SetTo</a>
<a name="ln137">status_t</a>
<a name="ln138">TreePath::Element::SetTo(uint64 blockNumber, int32 index)</a>
<a name="ln139">{</a>
<a name="ln140">	fBlockNumber = blockNumber;</a>
<a name="ln141">	fIndex = index;</a>
<a name="ln142">	return B_OK;</a>
<a name="ln143">}</a>
<a name="ln144"> </a>
<a name="ln145">// GetBlockNumber</a>
<a name="ln146">uint64</a>
<a name="ln147">TreePath::Element::GetBlockNumber() const</a>
<a name="ln148">{</a>
<a name="ln149">	return fBlockNumber;</a>
<a name="ln150">}</a>
<a name="ln151"> </a>
<a name="ln152">// GetIndex</a>
<a name="ln153">int32</a>
<a name="ln154">TreePath::Element::GetIndex() const</a>
<a name="ln155">{</a>
<a name="ln156">	return fIndex;</a>
<a name="ln157">}</a>
<a name="ln158"> </a>
<a name="ln159"> </a>
<a name="ln160">/*!</a>
<a name="ln161">	\class TreeIterator</a>
<a name="ln162">	\brief Class used to iterate and navigate in trees.</a>
<a name="ln163"> </a>
<a name="ln164">	A TreeIterator is usually initialized to the root node of the tree</a>
<a name="ln165">	and can be used to navigate and search in the tree.</a>
<a name="ln166">*/</a>
<a name="ln167"> </a>
<a name="ln168">// constructor</a>
<a name="ln169">TreeIterator::TreeIterator(Tree *tree)</a>
<a name="ln170">	: fTree(NULL),</a>
<a name="ln171">	  fCurrentNode(NULL),</a>
<a name="ln172">	  fPath(NULL)</a>
<a name="ln173">{</a>
<a name="ln174">	SetTo(tree);</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177">// destructor</a>
<a name="ln178">TreeIterator::~TreeIterator()</a>
<a name="ln179">{</a>
<a name="ln180">	Unset();</a>
<a name="ln181">}</a>
<a name="ln182"> </a>
<a name="ln183">// SetTo</a>
<a name="ln184">status_t</a>
<a name="ln185">TreeIterator::SetTo(Tree *tree)</a>
<a name="ln186">{</a>
<a name="ln187">	Unset();</a>
<a name="ln188">	fTree = tree;</a>
<a name="ln189">	fCurrentNode = NULL;</a>
<a name="ln190">	fPath = NULL;</a>
<a name="ln191">	if (fTree) {</a>
<a name="ln192">		fCurrentNode = fTree-&gt;GetRootNode();</a>
<a name="ln193">		if (fCurrentNode)</a>
<a name="ln194">			fCurrentNode-&gt;Get();</a>
<a name="ln195">		fPath = new(nothrow) TreePath(tree-&gt;GetTreeHeight());</a>
<a name="ln196">	}</a>
<a name="ln197">	return InitCheck();</a>
<a name="ln198">}</a>
<a name="ln199"> </a>
<a name="ln200">// Unset</a>
<a name="ln201">void</a>
<a name="ln202">TreeIterator::Unset()</a>
<a name="ln203">{</a>
<a name="ln204">	if (fPath) {</a>
<a name="ln205">		delete fPath;</a>
<a name="ln206">		fPath = NULL;</a>
<a name="ln207">	}</a>
<a name="ln208">	if (fCurrentNode) {</a>
<a name="ln209">		fCurrentNode-&gt;Put();</a>
<a name="ln210">		fCurrentNode = NULL;</a>
<a name="ln211">	}</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">// InitCheck</a>
<a name="ln215">status_t</a>
<a name="ln216">TreeIterator::InitCheck() const</a>
<a name="ln217">{</a>
<a name="ln218">	return (fTree &amp;&amp; fCurrentNode &amp;&amp; fPath ? fPath-&gt;InitCheck() : B_NO_INIT);</a>
<a name="ln219">}</a>
<a name="ln220"> </a>
<a name="ln221">// GetNode</a>
<a name="ln222">Node *</a>
<a name="ln223">TreeIterator::GetNode() const</a>
<a name="ln224">{</a>
<a name="ln225">	return fCurrentNode;</a>
<a name="ln226">}</a>
<a name="ln227"> </a>
<a name="ln228">// GetLevel</a>
<a name="ln229">int32</a>
<a name="ln230">TreeIterator::GetLevel() const</a>
<a name="ln231">{</a>
<a name="ln232">	int32 level = 0;</a>
<a name="ln233">	if (fCurrentNode)</a>
<a name="ln234">		level = fCurrentNode-&gt;GetLevel();</a>
<a name="ln235">	return level;</a>
<a name="ln236">}</a>
<a name="ln237"> </a>
<a name="ln238">// GoTo</a>
<a name="ln239">/*!	\brief Goes into a given direction.</a>
<a name="ln240"> </a>
<a name="ln241">	\a direction can be</a>
<a name="ln242">	- \c FORWARD: Forward/to the right. Goes to the next child node of the</a>
<a name="ln243">	  current node.</a>
<a name="ln244">	- \c BACKWARDS: Forward/to the right. Goes to the previous child node of</a>
<a name="ln245">	  the current node.</a>
<a name="ln246">	- \c UP: Up one level (in root direction). Goes to the parent node of</a>
<a name="ln247">	  the current node. The current node is the child node, it is pointed</a>
<a name="ln248">	  to afterward.</a>
<a name="ln249">	- \c DOWN: Down one level (in leaf direction). Goes to the child node of</a>
<a name="ln250">	  the current node the iterator currently points at. Points afterwards to</a>
<a name="ln251">	  the 0th child node of the new current node (unless it is a leaf node).</a>
<a name="ln252"> </a>
<a name="ln253">	\c FORWARD and \c BACKWARDS do not change the current node!</a>
<a name="ln254"> </a>
<a name="ln255">	\param direction \c FORWARD, \c BACKWARDS, \c UP or \c DOWN</a>
<a name="ln256">	\return \c B_OK, if everything went fine</a>
<a name="ln257">*/</a>
<a name="ln258">status_t</a>
<a name="ln259">TreeIterator::GoTo(uint32 direction)</a>
<a name="ln260">{</a>
<a name="ln261">	status_t error = InitCheck();</a>
<a name="ln262">	if (error == B_OK) {</a>
<a name="ln263">		switch (direction) {</a>
<a name="ln264">			case FORWARD:</a>
<a name="ln265">			{</a>
<a name="ln266">				if (fCurrentNode-&gt;IsInternal()</a>
<a name="ln267">					&amp;&amp; fIndex &lt; fCurrentNode-&gt;CountItems()) {</a>
<a name="ln268">					fIndex++;</a>
<a name="ln269">				} else {</a>
<a name="ln270">					error = B_ENTRY_NOT_FOUND;</a>
<a name="ln271">				}</a>
<a name="ln272">				break;</a>
<a name="ln273">			}</a>
<a name="ln274">			case BACKWARDS:</a>
<a name="ln275">			{</a>
<a name="ln276">				if (fCurrentNode-&gt;IsInternal() &amp;&amp; fIndex &gt; 0)</a>
<a name="ln277">					fIndex--;</a>
<a name="ln278">				else</a>
<a name="ln279">					error = B_ENTRY_NOT_FOUND;</a>
<a name="ln280">				break;</a>
<a name="ln281">			}</a>
<a name="ln282">			case UP:</a>
<a name="ln283">			{</a>
<a name="ln284">				error = _PopTopNode();</a>
<a name="ln285">				break;</a>
<a name="ln286">			}</a>
<a name="ln287">			case DOWN:</a>
<a name="ln288">			{</a>
<a name="ln289">				if (fCurrentNode-&gt;IsInternal()) {</a>
<a name="ln290">					InternalNode *internal = fCurrentNode-&gt;ToInternalNode();</a>
<a name="ln291">					const DiskChild *child = internal-&gt;ChildAt(fIndex);</a>
<a name="ln292">					if (child) {</a>
<a name="ln293">						Node *node = NULL;</a>
<a name="ln294">						error = fTree-&gt;GetNode(child-&gt;GetBlockNumber(), &amp;node);</a>
<a name="ln295">						if (error == B_OK)</a>
<a name="ln296">							error = _PushCurrentNode(node, 0);</a>
<a name="ln297">					} else</a>
<a name="ln298">						error = B_ENTRY_NOT_FOUND;</a>
<a name="ln299">				} else</a>
<a name="ln300">					error = B_ENTRY_NOT_FOUND;</a>
<a name="ln301">				break;</a>
<a name="ln302">			}</a>
<a name="ln303">		}</a>
<a name="ln304">	}</a>
<a name="ln305">	return error;</a>
<a name="ln306">}</a>
<a name="ln307"> </a>
<a name="ln308">// GoToPreviousLeaf</a>
<a name="ln309">/*!	\brief Goes to the previous leaf node.</a>
<a name="ln310"> </a>
<a name="ln311">	This method operates only at leaf node level. It finds the next leaf</a>
<a name="ln312">	node to the left. Fails, if the current node is no leaf node.</a>
<a name="ln313"> </a>
<a name="ln314">	\param node Pointer to a pre-allocated LeafNode pointer that shall be set</a>
<a name="ln315">		   to the found node.</a>
<a name="ln316">	\return \c B_OK, if everything went fine</a>
<a name="ln317">*/</a>
<a name="ln318">status_t</a>
<a name="ln319">TreeIterator::GoToPreviousLeaf(LeafNode **node)</a>
<a name="ln320">{</a>
<a name="ln321">	status_t error = InitCheck();</a>
<a name="ln322">	if (error == B_OK) {</a>
<a name="ln323">		if (fCurrentNode-&gt;IsLeaf()) {</a>
<a name="ln324">			// find downmost branch on our path, that leads further left</a>
<a name="ln325">			bool found = false;</a>
<a name="ln326">			while (error == B_OK &amp;&amp; !found) {</a>
<a name="ln327">				error = GoTo(UP);</a>
<a name="ln328">				if (error == B_OK)</a>
<a name="ln329">					found = (GoTo(BACKWARDS) == B_OK);</a>
<a name="ln330">			}</a>
<a name="ln331">			// descend the branch to the rightmost leaf</a>
<a name="ln332">			if (error == B_OK) {</a>
<a name="ln333">				// one level down</a>
<a name="ln334">				error = GoTo(DOWN);</a>
<a name="ln335">				// then keep right</a>
<a name="ln336">				while (error == B_OK &amp;&amp; fCurrentNode-&gt;IsInternal()) {</a>
<a name="ln337">					fIndex = fCurrentNode-&gt;CountItems();</a>
<a name="ln338">					error = GoTo(DOWN);</a>
<a name="ln339">				}</a>
<a name="ln340">			}</a>
<a name="ln341">			// set the result</a>
<a name="ln342">			if (error == B_OK &amp;&amp; node)</a>
<a name="ln343">				*node = fCurrentNode-&gt;ToLeafNode();</a>
<a name="ln344">		} else</a>
<a name="ln345">			error = B_ENTRY_NOT_FOUND;</a>
<a name="ln346">	}</a>
<a name="ln347">	return error;</a>
<a name="ln348">}</a>
<a name="ln349"> </a>
<a name="ln350">// GoToNextLeaf</a>
<a name="ln351">/*!	\brief Goes to the next leaf node.</a>
<a name="ln352"> </a>
<a name="ln353">	This method operates only at leaf node level. It finds the next leaf</a>
<a name="ln354">	node to the right. Fails, if the current node is no leaf node.</a>
<a name="ln355"> </a>
<a name="ln356">	\param node Pointer to a pre-allocated LeafNode pointer that shall be set</a>
<a name="ln357">		   to the found node.</a>
<a name="ln358">	\return \c B_OK, if everything went fine</a>
<a name="ln359">*/</a>
<a name="ln360">status_t</a>
<a name="ln361">TreeIterator::GoToNextLeaf(LeafNode **node)</a>
<a name="ln362">{</a>
<a name="ln363">	status_t error = InitCheck();</a>
<a name="ln364">	if (error == B_OK) {</a>
<a name="ln365">		if (fCurrentNode-&gt;IsLeaf()) {</a>
<a name="ln366">			// find downmost branch on our path, that leads further right</a>
<a name="ln367">			bool found = false;</a>
<a name="ln368">			while (error == B_OK &amp;&amp; !found) {</a>
<a name="ln369">				error = GoTo(UP);</a>
<a name="ln370">				if (error == B_OK)</a>
<a name="ln371">					found = (GoTo(FORWARD) == B_OK);</a>
<a name="ln372">			}</a>
<a name="ln373">			// descend the branch to the leftmost leaf</a>
<a name="ln374">			while (error == B_OK &amp;&amp; fCurrentNode-&gt;IsInternal())</a>
<a name="ln375">				error = GoTo(DOWN);</a>
<a name="ln376">			// set the result</a>
<a name="ln377">			if (error == B_OK &amp;&amp; node)</a>
<a name="ln378">				*node = fCurrentNode-&gt;ToLeafNode();</a>
<a name="ln379">		} else</a>
<a name="ln380">			error = B_ENTRY_NOT_FOUND;</a>
<a name="ln381">	}</a>
<a name="ln382">	return error;</a>
<a name="ln383">}</a>
<a name="ln384"> </a>
<a name="ln385">// FindRightMostLeaf</a>
<a name="ln386">/*!	\brief Finds the rightmost leaf node that may contain the supplied key.</a>
<a name="ln387"> </a>
<a name="ln388">	The method starts at the current node and only goes downwards.</a>
<a name="ln389">	In the spanned subtree it finds the rightmost leaf node whose left</a>
<a name="ln390">	delimiting key is not greater than the supplied key.</a>
<a name="ln391"> </a>
<a name="ln392">	\param key The key to be found.</a>
<a name="ln393">	\param node Pointer to a pre-allocated LeafNode pointer that shall be set</a>
<a name="ln394">		   to the found node.</a>
<a name="ln395">	\return \c B_OK, if everything went fine.</a>
<a name="ln396">*/</a>
<a name="ln397">status_t</a>
<a name="ln398">TreeIterator::FindRightMostLeaf(const VKey *k, LeafNode **node)</a>
<a name="ln399">{</a>
<a name="ln400">//printf(&quot;TreeIterator::FindRightMostLeaf()\n&quot;);</a>
<a name="ln401">	status_t error = (k ? InitCheck() : B_BAD_VALUE);</a>
<a name="ln402">	while (error == B_OK &amp;&amp; fCurrentNode-&gt;IsInternal()) {</a>
<a name="ln403">		int32 index = 0;</a>
<a name="ln404">		error = _SearchRightMost(fCurrentNode-&gt;ToInternalNode(), k, &amp;index);</a>
<a name="ln405">		if (error == B_OK) {</a>
<a name="ln406">			fIndex = index;</a>
<a name="ln407">			error = GoTo(DOWN);</a>
<a name="ln408">		}</a>
<a name="ln409">	}</a>
<a name="ln410">//if (error == B_OK)</a>
<a name="ln411">//printf(&quot;found node: index: %ld\n&quot;, fIndex);</a>
<a name="ln412">	// set the result</a>
<a name="ln413">	if (error == B_OK &amp;&amp; node)</a>
<a name="ln414">		*node = fCurrentNode-&gt;ToLeafNode();</a>
<a name="ln415">//printf(&quot;TreeIterator::FindRightMostLeaf() done: %s\n&quot;, strerror(error));</a>
<a name="ln416">	return error;</a>
<a name="ln417">}</a>
<a name="ln418"> </a>
<a name="ln419">// Suspend</a>
<a name="ln420">/*!	\brief Suspends the iterator.</a>
<a name="ln421"> </a>
<a name="ln422">	This means, the current node is Put() and its block number and child node</a>
<a name="ln423">	index pushed onto the tree path. This should be done, when the iteration</a>
<a name="ln424">	is not to be continued immediately (or for the foreseeable future) and</a>
<a name="ln425">	the node block shall not be locked in memory for that time.</a>
<a name="ln426"> </a>
<a name="ln427">	Resume() is to be called, before the iteration can be continued.</a>
<a name="ln428"> </a>
<a name="ln429">	\return \c B_OK, if everything went fine.</a>
<a name="ln430">*/</a>
<a name="ln431">status_t</a>
<a name="ln432">TreeIterator::Suspend()</a>
<a name="ln433">{</a>
<a name="ln434">	status_t error = InitCheck();</a>
<a name="ln435">	if (error == B_OK)</a>
<a name="ln436">		error = _PushCurrentNode();</a>
<a name="ln437">	if (error == B_OK)</a>
<a name="ln438">		fCurrentNode = NULL;</a>
<a name="ln439">	return error;</a>
<a name="ln440">}</a>
<a name="ln441"> </a>
<a name="ln442">// Resume</a>
<a name="ln443">/*!	\brief Resumes the iteration.</a>
<a name="ln444"> </a>
<a name="ln445">	To be called after a Suspend(), before the iteration can be continued.</a>
<a name="ln446"> </a>
<a name="ln447">	\return \c B_OK, if everything went fine.</a>
<a name="ln448">*/</a>
<a name="ln449">status_t</a>
<a name="ln450">TreeIterator::Resume()</a>
<a name="ln451">{</a>
<a name="ln452">	status_t error</a>
<a name="ln453">		= (fTree &amp;&amp; !fCurrentNode &amp;&amp; fPath ? fPath-&gt;InitCheck() : B_NO_INIT);</a>
<a name="ln454">	if (error == B_OK)</a>
<a name="ln455">		error = _PopTopNode();</a>
<a name="ln456">	return error;</a>
<a name="ln457">}</a>
<a name="ln458"> </a>
<a name="ln459">// _PushCurrentNode</a>
<a name="ln460">status_t</a>
<a name="ln461">TreeIterator::_PushCurrentNode(Node *newTopNode, int32 newIndex)</a>
<a name="ln462">{</a>
<a name="ln463">	status_t error = fPath-&gt;PushElement(fCurrentNode-&gt;GetNumber(), fIndex);</a>
<a name="ln464">	if (error == B_OK) {</a>
<a name="ln465">		fCurrentNode-&gt;Put();</a>
<a name="ln466">		fCurrentNode = newTopNode;</a>
<a name="ln467">		fIndex = newIndex;</a>
<a name="ln468">	}</a>
<a name="ln469">	return error;</a>
<a name="ln470">}</a>
<a name="ln471"> </a>
<a name="ln472">// _PopTopNode</a>
<a name="ln473">status_t</a>
<a name="ln474">TreeIterator::_PopTopNode()</a>
<a name="ln475">{</a>
<a name="ln476">	status_t error = B_OK;</a>
<a name="ln477">	if (fPath-&gt;GetLength() &gt; 0) {</a>
<a name="ln478">		const TreePath::Element *element = fPath-&gt;GetTopElement();</a>
<a name="ln479">		Node *node = NULL;</a>
<a name="ln480">		error = fTree-&gt;GetNode(element-&gt;GetBlockNumber(), &amp;node);</a>
<a name="ln481">		if (error == B_OK) {</a>
<a name="ln482">			if (fCurrentNode)</a>
<a name="ln483">				fCurrentNode-&gt;Put();</a>
<a name="ln484">			fCurrentNode = node;</a>
<a name="ln485">			fIndex = element-&gt;GetIndex();</a>
<a name="ln486">			fPath-&gt;PopElement();</a>
<a name="ln487">		}</a>
<a name="ln488">	} else</a>
<a name="ln489">		error = B_BAD_VALUE;</a>
<a name="ln490">	return error;</a>
<a name="ln491">}</a>
<a name="ln492"> </a>
<a name="ln493">// _SearchRightMost</a>
<a name="ln494">status_t</a>
<a name="ln495">TreeIterator::_SearchRightMost(InternalNode *node, const VKey *k, int32 *index)</a>
<a name="ln496">{</a>
<a name="ln497">//FUNCTION_START();</a>
<a name="ln498">	// find the last node that may contain the key, i.e. the node with the</a>
<a name="ln499">	// greatest index whose left delimiting key is less or equal the given key</a>
<a name="ln500">	status_t error = (node &amp;&amp; k &amp;&amp; index ? B_OK : B_BAD_VALUE);</a>
<a name="ln501">	if (error == B_OK) {</a>
<a name="ln502">//PRINT((&quot;  searching: &quot;));</a>
<a name="ln503">//k-&gt;Dump();</a>
<a name="ln504">		// binary search: lower and upper are node indices, mid is a key index</a>
<a name="ln505">		int32 lower = 0;</a>
<a name="ln506">		int32 upper = node-&gt;CountItems();</a>
<a name="ln507">		while (lower &lt; upper) {</a>
<a name="ln508">			int32 mid = (lower + upper) / 2;	// lower &lt;= mid &lt; upper &lt;= count</a>
<a name="ln509">			VKey midKey(node-&gt;KeyAt(mid));</a>
<a name="ln510">//PRINT((&quot;  mid: %3ld: &quot;, mid));</a>
<a name="ln511">//midKey.Dump();</a>
<a name="ln512">			if (*k &lt; midKey)			// =&gt; node index &lt;= mid</a>
<a name="ln513">				upper = mid;					// lower &lt;= upper &lt; count</a>
<a name="ln514">			else								// =&gt; node index &gt; mid</a>
<a name="ln515">				lower = mid + 1;				// lower &lt;= upper &lt;= count</a>
<a name="ln516">//PRINT((&quot;  lower: %ld, upper: %ld\n&quot;, lower, upper));</a>
<a name="ln517">		}</a>
<a name="ln518">		if (error == B_OK)</a>
<a name="ln519">			*index = lower;</a>
<a name="ln520">	}</a>
<a name="ln521">//RETURN_ERROR(error);</a>
<a name="ln522">	return error;</a>
<a name="ln523">}</a>
<a name="ln524"> </a>
<a name="ln525"> </a>
<a name="ln526">/*!</a>
<a name="ln527">	\class ItemIterator</a>
<a name="ln528">	\brief Class used to iterate through leaf node items.</a>
<a name="ln529"> </a>
<a name="ln530">	A ItemIterator is usually initialized to the root node of the tree,</a>
<a name="ln531">	and before it can be used for iteration, FindRightMostClose() or</a>
<a name="ln532">	FindRightMost() must be invoked. They set the iterator to an item</a>
<a name="ln533">	and afterwards one can use GoToPrevious() and GoToNext() to get the</a>
<a name="ln534">	previous/next ones.</a>
<a name="ln535">*/</a>
<a name="ln536"> </a>
<a name="ln537">// constructor</a>
<a name="ln538">ItemIterator::ItemIterator(Tree *tree)</a>
<a name="ln539">	: fTreeIterator(tree),</a>
<a name="ln540">	  fIndex(0)</a>
<a name="ln541">{</a>
<a name="ln542">}</a>
<a name="ln543"> </a>
<a name="ln544">// SetTo</a>
<a name="ln545">status_t</a>
<a name="ln546">ItemIterator::SetTo(Tree *tree)</a>
<a name="ln547">{</a>
<a name="ln548">	status_t error = fTreeIterator.SetTo(tree);</a>
<a name="ln549">	fIndex = 0;</a>
<a name="ln550">	return error;</a>
<a name="ln551">}</a>
<a name="ln552"> </a>
<a name="ln553">// InitCheck</a>
<a name="ln554">status_t</a>
<a name="ln555">ItemIterator::InitCheck() const</a>
<a name="ln556">{</a>
<a name="ln557">	return fTreeIterator.InitCheck();</a>
<a name="ln558">}</a>
<a name="ln559"> </a>
<a name="ln560">// GetCurrent</a>
<a name="ln561">status_t</a>
<a name="ln562">ItemIterator::GetCurrent(Item *item)</a>
<a name="ln563">{</a>
<a name="ln564">	LeafNode *node = NULL;</a>
<a name="ln565">	status_t error = (item ? _GetLeafNode(&amp;node) : B_BAD_VALUE);</a>
<a name="ln566">	if (error == B_OK) {</a>
<a name="ln567">		if (fIndex &gt;= 0 &amp;&amp; fIndex &lt; node-&gt;CountItems())</a>
<a name="ln568">			error = item-&gt;SetTo(node, fIndex);</a>
<a name="ln569">		else</a>
<a name="ln570">			error = B_ENTRY_NOT_FOUND;</a>
<a name="ln571">	}</a>
<a name="ln572">	return error;</a>
<a name="ln573">}</a>
<a name="ln574"> </a>
<a name="ln575">// GoToPrevious</a>
<a name="ln576">status_t</a>
<a name="ln577">ItemIterator::GoToPrevious(Item *item)</a>
<a name="ln578">{</a>
<a name="ln579">	LeafNode *node = NULL;</a>
<a name="ln580">	status_t error = _GetLeafNode(&amp;node);</a>
<a name="ln581">	if (error == B_OK) {</a>
<a name="ln582">		// get the leaf node on which the next item resides</a>
<a name="ln583">		int32 newIndex = fIndex - 1;</a>
<a name="ln584">		while (error == B_OK</a>
<a name="ln585">			   &amp;&amp; (newIndex &lt; 0 || newIndex &gt;= node-&gt;CountItems())) {</a>
<a name="ln586">			error = fTreeIterator.GoToPreviousLeaf(&amp;node);</a>
<a name="ln587">			if (error == B_OK)</a>
<a name="ln588">				newIndex = node-&gt;CountItems() - 1;</a>
<a name="ln589">		}</a>
<a name="ln590">		// got the node, get the item</a>
<a name="ln591">		if (error == B_OK) {</a>
<a name="ln592">			fIndex = newIndex;</a>
<a name="ln593">			if (item)</a>
<a name="ln594">				error = item-&gt;SetTo(node, fIndex);</a>
<a name="ln595">		}</a>
<a name="ln596">	}</a>
<a name="ln597">	return error;</a>
<a name="ln598">}</a>
<a name="ln599"> </a>
<a name="ln600">// GoToNext</a>
<a name="ln601">status_t</a>
<a name="ln602">ItemIterator::GoToNext(Item *item)</a>
<a name="ln603">{</a>
<a name="ln604">//PRINT((&quot;ItemIterator::GoToNext()\n&quot;));</a>
<a name="ln605">	LeafNode *node = NULL;</a>
<a name="ln606">	status_t error = _GetLeafNode(&amp;node);</a>
<a name="ln607">	if (error == B_OK) {</a>
<a name="ln608">//PRINT((&quot;  leaf node: %Ld\n&quot;, node-&gt;GetNumber()));</a>
<a name="ln609">		// get the leaf node on which the next item resides</a>
<a name="ln610">		int32 newIndex = fIndex + 1;</a>
<a name="ln611">		while (error == B_OK &amp;&amp; newIndex &gt;= node-&gt;CountItems()) {</a>
<a name="ln612">			error = fTreeIterator.GoToNextLeaf(&amp;node);</a>
<a name="ln613">			newIndex = 0;</a>
<a name="ln614">		}</a>
<a name="ln615">		// got the node, get the item</a>
<a name="ln616">		if (error == B_OK) {</a>
<a name="ln617">//PRINT((&quot;  leaf node now: %Ld\n&quot;, node-&gt;GetNumber()));</a>
<a name="ln618">			fIndex = newIndex;</a>
<a name="ln619">//PRINT((&quot;  index now: %ld\n&quot;, fIndex));</a>
<a name="ln620">			if (item)</a>
<a name="ln621">				error = item-&gt;SetTo(node, fIndex);</a>
<a name="ln622">		}</a>
<a name="ln623">	}</a>
<a name="ln624">//PRINT((&quot;ItemIterator::GoToNext() done: %s\n&quot;, strerror(error)));</a>
<a name="ln625">	return error;</a>
<a name="ln626">}</a>
<a name="ln627"> </a>
<a name="ln628">// FindRightMostClose</a>
<a name="ln629">/*!	\brief Finds the rightmost item that may contain the supplied key.</a>
<a name="ln630"> </a>
<a name="ln631">	The method finds the rightmost item whose left delimiting key is not</a>
<a name="ln632">	greater than the supplied key.</a>
<a name="ln633"> </a>
<a name="ln634">	\param key The key to be found.</a>
<a name="ln635">	\param item Pointer to a pre-allocated Item that shall be set</a>
<a name="ln636">		   to the found item.</a>
<a name="ln637">	\return \c B_OK, if everything went fine.</a>
<a name="ln638">*/</a>
<a name="ln639">status_t</a>
<a name="ln640">ItemIterator::FindRightMostClose(const VKey *k, Item *item)</a>
<a name="ln641">{</a>
<a name="ln642">//printf(&quot;ItemIterator::FindRightMostClose()\n&quot;);</a>
<a name="ln643">	status_t error = (k ? InitCheck() : B_BAD_VALUE);</a>
<a name="ln644">	// find rightmost leaf node with the given key</a>
<a name="ln645">	if (error == B_OK)</a>
<a name="ln646">		error = fTreeIterator.FindRightMostLeaf(k);</a>
<a name="ln647">	// search the node for the key</a>
<a name="ln648">	if (error == B_OK) {</a>
<a name="ln649">		LeafNode *node = fTreeIterator.GetNode()-&gt;ToLeafNode();</a>
<a name="ln650">		error = _SearchRightMost(node, k, &amp;fIndex);</a>
<a name="ln651">		if (error == B_OK &amp;&amp; item)</a>
<a name="ln652">{</a>
<a name="ln653">			error = item-&gt;SetTo(node, fIndex);</a>
<a name="ln654">//VKey itemKey;</a>
<a name="ln655">//printf(&quot;  found item: &quot;);</a>
<a name="ln656">//item-&gt;GetKey(&amp;itemKey)-&gt;Dump();</a>
<a name="ln657">}</a>
<a name="ln658">	}</a>
<a name="ln659">//printf(&quot;ItemIterator::FindRightMostClose() done: %s\n&quot;, strerror(error));</a>
<a name="ln660">	return error;</a>
<a name="ln661">}</a>
<a name="ln662"> </a>
<a name="ln663">// FindRightMost</a>
<a name="ln664">/*!	\brief Finds the rightmost item that starts with the supplied key.</a>
<a name="ln665"> </a>
<a name="ln666">	The method finds the rightmost item whose left delimiting key is equal</a>
<a name="ln667">	to the supplied key.</a>
<a name="ln668"> </a>
<a name="ln669">	\param key The key to be found.</a>
<a name="ln670">	\param item Pointer to a pre-allocated Item that shall be set</a>
<a name="ln671">		   to the found item.</a>
<a name="ln672">	\return \c B_OK, if everything went fine.</a>
<a name="ln673">*/</a>
<a name="ln674">status_t</a>
<a name="ln675">ItemIterator::FindRightMost(const VKey *k, Item *item)</a>
<a name="ln676">{</a>
<a name="ln677">//TFUNCTION_START();</a>
<a name="ln678">	// find the first item with a greater or equal key, and check whether the</a>
<a name="ln679">	// key is equal</a>
<a name="ln680">	Item closeItem;</a>
<a name="ln681">	status_t error = FindRightMostClose(k, &amp;closeItem);</a>
<a name="ln682">//REPORT_ERROR(error);</a>
<a name="ln683">	if (error == B_OK) {</a>
<a name="ln684">		VKey itemKey;</a>
<a name="ln685">		closeItem.GetHeader()-&gt;GetKey(&amp;itemKey);</a>
<a name="ln686">		if (*k == itemKey) {</a>
<a name="ln687">			if (item)</a>
<a name="ln688">				*item = closeItem;</a>
<a name="ln689">		} else</a>
<a name="ln690">{</a>
<a name="ln691">//PRINT((&quot;keys not equal: dirID: %lu, objectID: %lu, offset: %Lu, type: %hu\n&quot;,</a>
<a name="ln692">//itemKey.GetDirID(), itemKey.GetObjectID(), itemKey.GetOffset(), itemKey.GetType()));</a>
<a name="ln693">			error = B_ENTRY_NOT_FOUND;</a>
<a name="ln694">}</a>
<a name="ln695">	}</a>
<a name="ln696">//REPORT_ERROR(error);</a>
<a name="ln697">	return error;</a>
<a name="ln698">}</a>
<a name="ln699"> </a>
<a name="ln700">// Suspend</a>
<a name="ln701">/*! \brief Suspends the iterator.</a>
<a name="ln702">	\see TreeIterator::Suspend().</a>
<a name="ln703">	\return \c B_OK, if everything went fine.</a>
<a name="ln704">*/</a>
<a name="ln705">status_t</a>
<a name="ln706">ItemIterator::Suspend()</a>
<a name="ln707">{</a>
<a name="ln708">	return fTreeIterator.Suspend();</a>
<a name="ln709">}</a>
<a name="ln710"> </a>
<a name="ln711">// Resume</a>
<a name="ln712">/*! \brief Resumes the iteration.</a>
<a name="ln713">	\see TreeIterator::Resume().</a>
<a name="ln714">	\return \c B_OK, if everything went fine.</a>
<a name="ln715">*/</a>
<a name="ln716">status_t</a>
<a name="ln717">ItemIterator::Resume()</a>
<a name="ln718">{</a>
<a name="ln719">	return fTreeIterator.Resume();</a>
<a name="ln720">}</a>
<a name="ln721"> </a>
<a name="ln722">// _GetLeafNode</a>
<a name="ln723">status_t</a>
<a name="ln724">ItemIterator::_GetLeafNode(LeafNode **leafNode) const</a>
<a name="ln725">{</a>
<a name="ln726">	status_t error = InitCheck();</a>
<a name="ln727">	if (error == B_OK) {</a>
<a name="ln728">		if (Node *node = fTreeIterator.GetNode()) {</a>
<a name="ln729">			if (node-&gt;IsLeaf())</a>
<a name="ln730">				*leafNode = node-&gt;ToLeafNode();</a>
<a name="ln731">			else</a>
<a name="ln732">				error = B_ENTRY_NOT_FOUND;</a>
<a name="ln733">		} else</a>
<a name="ln734">			error = B_ERROR;</a>
<a name="ln735">	}</a>
<a name="ln736">	return error;</a>
<a name="ln737">}</a>
<a name="ln738"> </a>
<a name="ln739">// _SearchRightMost</a>
<a name="ln740">status_t</a>
<a name="ln741">ItemIterator::_SearchRightMost(LeafNode *node, const VKey *k,</a>
<a name="ln742">							   int32 *index) const</a>
<a name="ln743">{</a>
<a name="ln744">//FUNCTION_START();</a>
<a name="ln745">	status_t error = (node &amp;&amp; k &amp;&amp; index ? B_OK : B_BAD_VALUE);</a>
<a name="ln746">	// find the first item with a less or equal key</a>
<a name="ln747">	if (error == B_OK) {</a>
<a name="ln748">//PRINT((&quot;  searching: &quot;));</a>
<a name="ln749">//k-&gt;Dump();</a>
<a name="ln750">/*</a>
<a name="ln751">		// simple linear search backwards</a>
<a name="ln752">		int32 foundIndex = -1;</a>
<a name="ln753">		for (int32 i = node-&gt;CountItems() - 1; foundIndex &lt; 0 &amp;&amp; i &gt;= 0; i--) {</a>
<a name="ln754">			VKey itemKey;</a>
<a name="ln755">			node-&gt;ItemHeaderAt(i)-&gt;GetKey(&amp;itemKey);</a>
<a name="ln756">			if (itemKey &lt;= *k) {</a>
<a name="ln757">				foundIndex = i;</a>
<a name="ln758">				error = B_OK;</a>
<a name="ln759">				break;</a>
<a name="ln760">			}</a>
<a name="ln761">		}</a>
<a name="ln762">		// check whether all item keys are greater</a>
<a name="ln763">		if (foundIndex &lt; 0)</a>
<a name="ln764">			error = B_ENTRY_NOT_FOUND;</a>
<a name="ln765">		// set result</a>
<a name="ln766">		if (error == B_OK)</a>
<a name="ln767">			*index = foundIndex;</a>
<a name="ln768">*/</a>
<a name="ln769">		// binary search</a>
<a name="ln770">		// check lower bound first</a>
<a name="ln771">		VKey lowerKey;</a>
<a name="ln772">		node-&gt;ItemHeaderAt(0)-&gt;GetKey(&amp;lowerKey);</a>
<a name="ln773">		if (lowerKey &lt;= *k) {</a>
<a name="ln774">			// pre-conditions hold</a>
<a name="ln775">			int32 lower = 0;</a>
<a name="ln776">			int32 upper = node-&gt;CountItems() - 1;</a>
<a name="ln777">			while (lower &lt; upper) {</a>
<a name="ln778">				int32 mid = (lower + upper + 1) / 2;</a>
<a name="ln779">				VKey midKey;</a>
<a name="ln780">				node-&gt;ItemHeaderAt(mid)-&gt;GetKey(&amp;midKey);</a>
<a name="ln781">//PRINT((&quot;  mid: %3ld: &quot;, mid));</a>
<a name="ln782">//midKey.Dump();</a>
<a name="ln783">				if (midKey &gt; *k)</a>
<a name="ln784">					upper = mid - 1;</a>
<a name="ln785">				else</a>
<a name="ln786">					lower = mid;</a>
<a name="ln787">//PRINT((&quot;  lower: %ld, upper: %ld\n&quot;, lower, upper));</a>
<a name="ln788">			}</a>
<a name="ln789">			*index = lower;</a>
<a name="ln790">		} else</a>
<a name="ln791">			error = B_ENTRY_NOT_FOUND;</a>
<a name="ln792">	}</a>
<a name="ln793">//RETURN_ERROR(error);</a>
<a name="ln794">	return error;</a>
<a name="ln795">}</a>
<a name="ln796"> </a>
<a name="ln797"> </a>
<a name="ln798">/*!</a>
<a name="ln799">	\class ObjectItemIterator</a>
<a name="ln800">	\brief Class used to iterate through leaf node items.</a>
<a name="ln801"> </a>
<a name="ln802">	This class basically wraps the ItemIterator class and provides a</a>
<a name="ln803">	more convenient interface for iteration through items of one given</a>
<a name="ln804">	object (directory, link or file). It finds only items of the object</a>
<a name="ln805">	identified by the dir and object ID specified on initialization.</a>
<a name="ln806">*/</a>
<a name="ln807"> </a>
<a name="ln808">// constructor</a>
<a name="ln809">/*!	\brief Creates and initializes a ObjectItemIterator.</a>
<a name="ln810"> </a>
<a name="ln811">	The iterator is initialized to find only items belonging to the object</a>
<a name="ln812">	identified by \a dirID and \a objectID. \a startOffset specifies the</a>
<a name="ln813">	offset (key offset) at which the iteration shall begin.</a>
<a name="ln814"> </a>
<a name="ln815">	Note, that offsets don't need to be unique for an object, at least not</a>
<a name="ln816">	for files -- all indirect (and direct?) items have the same offset (1).</a>
<a name="ln817">	This has the ugly side effect, when iterating forward there may be items</a>
<a name="ln818">	with the same offset on previous nodes that will be skipped at the</a>
<a name="ln819">	beginning. The GetNext() does always find the item on the rightmost</a>
<a name="ln820">	possible node. Therefore searching forward starting with FIRST_ITEM_OFFSET</a>
<a name="ln821">	doesn't work for files!</a>
<a name="ln822"> </a>
<a name="ln823">	\param tree The tree.</a>
<a name="ln824">	\param dirID The directory ID of the object.</a>
<a name="ln825">	\param objectID The object ID of the object.</a>
<a name="ln826">	\param startOffset The offset at which to begin the iteration.</a>
<a name="ln827">*/</a>
<a name="ln828">ObjectItemIterator::ObjectItemIterator(Tree *tree, uint32 dirID,</a>
<a name="ln829">									   uint32 objectID, uint64 startOffset)</a>
<a name="ln830">	: fItemIterator(tree),</a>
<a name="ln831">	  fDirID(dirID),</a>
<a name="ln832">	  fObjectID(objectID),</a>
<a name="ln833">	  fOffset(startOffset),</a>
<a name="ln834">	  fFindFirst(true),</a>
<a name="ln835">	  fDone(false)</a>
<a name="ln836">{</a>
<a name="ln837">}</a>
<a name="ln838"> </a>
<a name="ln839">// SetTo</a>
<a name="ln840">/*!	\brief Re-initializes a ObjectItemIterator.</a>
<a name="ln841"> </a>
<a name="ln842">	The iterator is initialized to find only items belonging to the object</a>
<a name="ln843">	identified by \a dirID and \a objectID. \a startOffset specifies the</a>
<a name="ln844">	offset (key offset) at which the iteration shall begin.</a>
<a name="ln845"> </a>
<a name="ln846">	\param tree The tree.</a>
<a name="ln847">	\param dirID The directory ID of the object.</a>
<a name="ln848">	\param objectID The object ID of the object.</a>
<a name="ln849">	\param startOffset The offset at which to begin the iteration.</a>
<a name="ln850">	\return \c B_OK, if everything went fine.</a>
<a name="ln851">*/</a>
<a name="ln852">status_t</a>
<a name="ln853">ObjectItemIterator::SetTo(Tree *tree, uint32 dirID, uint32 objectID,</a>
<a name="ln854">						  uint64 startOffset)</a>
<a name="ln855">{</a>
<a name="ln856">	status_t error = fItemIterator.SetTo(tree);</a>
<a name="ln857">	fDirID = dirID;</a>
<a name="ln858">	fObjectID = objectID;</a>
<a name="ln859">	fOffset = startOffset;</a>
<a name="ln860">	fFindFirst = true;</a>
<a name="ln861">	fDone = false;</a>
<a name="ln862">	return error;</a>
<a name="ln863">}</a>
<a name="ln864"> </a>
<a name="ln865">// InitCheck</a>
<a name="ln866">status_t</a>
<a name="ln867">ObjectItemIterator::InitCheck() const</a>
<a name="ln868">{</a>
<a name="ln869">	return fItemIterator.InitCheck();</a>
<a name="ln870">}</a>
<a name="ln871"> </a>
<a name="ln872">// GetNext</a>
<a name="ln873">/*!	\brief Returns the next item belonging to the object.</a>
<a name="ln874"> </a>
<a name="ln875">	Note, that offsets don't need to be unique for an object, at least not</a>
<a name="ln876">	for files -- all indirect (and direct?) items have the same offset (1).</a>
<a name="ln877">	This has the ugly side effect, when iterating forward there may be items</a>
<a name="ln878">	with the same offset on previous nodes that will be skipped at the</a>
<a name="ln879">	beginning. The GetNext() does always find the item on the rightmost</a>
<a name="ln880">	possible node. Therefore searching forward starting with FIRST_ITEM_OFFSET</a>
<a name="ln881">	doesn't work for files!</a>
<a name="ln882"> </a>
<a name="ln883">	\param foundItem Pointer to a pre-allocated Item that shall be set</a>
<a name="ln884">		   to the found item.</a>
<a name="ln885">	\return \c B_OK, if everything went fine, \c B_ENTRY_NOT_FOUND, if we're</a>
<a name="ln886">			through.</a>
<a name="ln887">*/</a>
<a name="ln888">status_t</a>
<a name="ln889">ObjectItemIterator::GetNext(Item *foundItem)</a>
<a name="ln890">{</a>
<a name="ln891">//PRINT((&quot;ObjectItemIterator::GetNext(): fDirID: %lu, fObjectID: %lu\n&quot;, fDirID, fObjectID));</a>
<a name="ln892">	status_t error = (foundItem ? InitCheck() : B_BAD_VALUE);</a>
<a name="ln893">	if (error == B_OK &amp;&amp; fDone)</a>
<a name="ln894">		error = B_ENTRY_NOT_FOUND;</a>
<a name="ln895">	if (error == B_OK) {</a>
<a name="ln896">		// get the next item</a>
<a name="ln897">		Item item;</a>
<a name="ln898">		if (fFindFirst) {</a>
<a name="ln899">			// first invocation: find the item with the given IDs and offset</a>
<a name="ln900">			VKey k(fDirID, fObjectID, fOffset, 0, KEY_FORMAT_3_5);</a>
<a name="ln901">			error = fItemIterator.FindRightMostClose(&amp;k, &amp;item);</a>
<a name="ln902">			fFindFirst = false;</a>
<a name="ln903">		} else {</a>
<a name="ln904">			// item iterator positioned, get the next item</a>
<a name="ln905">			error = fItemIterator.GoToNext(&amp;item);</a>
<a name="ln906">//REPORT_ERROR(error);</a>
<a name="ln907">		}</a>
<a name="ln908">		// check whether the item belongs to our object</a>
<a name="ln909">		if (error == B_OK) {</a>
<a name="ln910">			VKey itemKey;</a>
<a name="ln911">			if (item.GetDirID() == fDirID &amp;&amp; item.GetObjectID() == fObjectID)</a>
<a name="ln912">				*foundItem = item;</a>
<a name="ln913">			else</a>
<a name="ln914">{</a>
<a name="ln915">//PRINT((&quot;  found item for another object: (%lu, %lu)\n&quot;, item.GetDirID(), item.GetObjectID()));</a>
<a name="ln916">				error = B_ENTRY_NOT_FOUND;</a>
<a name="ln917">}</a>
<a name="ln918">		}</a>
<a name="ln919">		if (error != B_OK)</a>
<a name="ln920">			fDone = true;</a>
<a name="ln921">	}</a>
<a name="ln922">//	return error;</a>
<a name="ln923">RETURN_ERROR(error)</a>
<a name="ln924">}</a>
<a name="ln925"> </a>
<a name="ln926">// GetNext</a>
<a name="ln927">/*!	\brief Returns the next item belonging to the object.</a>
<a name="ln928"> </a>
<a name="ln929">	This version finds only items of the specified type.</a>
<a name="ln930"> </a>
<a name="ln931">	\param foundItem Pointer to a pre-allocated Item that shall be set</a>
<a name="ln932">		   to the found item.</a>
<a name="ln933">	\param type The type the found item must have.</a>
<a name="ln934">	\return \c B_OK, if everything went fine, \c B_ENTRY_NOT_FOUND, if we're</a>
<a name="ln935">			through.</a>
<a name="ln936">*/</a>
<a name="ln937">status_t</a>
<a name="ln938">ObjectItemIterator::GetNext(Item *foundItem, uint32 type)</a>
<a name="ln939">{</a>
<a name="ln940">	status_t error = B_OK;</a>
<a name="ln941">	do {</a>
<a name="ln942">		error = GetNext(foundItem);</a>
<a name="ln943">	} while (error == B_OK &amp;&amp; foundItem-&gt;GetType() != type);</a>
<a name="ln944">	return error;</a>
<a name="ln945">}</a>
<a name="ln946"> </a>
<a name="ln947">// GetPrevious</a>
<a name="ln948">/*!	\brief Returns the previous item belonging to the object.</a>
<a name="ln949">	\param foundItem Pointer to a pre-allocated Item that shall be set</a>
<a name="ln950">		   to the found item.</a>
<a name="ln951">	\return \c B_OK, if everything went fine, \c B_ENTRY_NOT_FOUND, if we're</a>
<a name="ln952">			through.</a>
<a name="ln953">*/</a>
<a name="ln954">status_t</a>
<a name="ln955">ObjectItemIterator::GetPrevious(Item *foundItem)</a>
<a name="ln956">{</a>
<a name="ln957">//PRINT((&quot;ObjectItemIterator::GetPrevious()\n&quot;));</a>
<a name="ln958">	status_t error = (foundItem ? InitCheck() : B_BAD_VALUE);</a>
<a name="ln959">	if (error == B_OK &amp;&amp; fDone)</a>
<a name="ln960">		error = B_ENTRY_NOT_FOUND;</a>
<a name="ln961">	if (error == B_OK) {</a>
<a name="ln962">		// get the next item</a>
<a name="ln963">		Item item;</a>
<a name="ln964">		if (fFindFirst) {</a>
<a name="ln965">			// first invocation: find the rightmost item of the object</a>
<a name="ln966">			VKey k(fDirID, fObjectID, fOffset, 0xffffffffUL, KEY_FORMAT_3_5);</a>
<a name="ln967">			error = fItemIterator.FindRightMostClose(&amp;k, &amp;item);</a>
<a name="ln968">			fFindFirst = false;</a>
<a name="ln969">		} else {</a>
<a name="ln970">			// item iterator positioned, get the previous item</a>
<a name="ln971">			error = fItemIterator.GoToPrevious(&amp;item);</a>
<a name="ln972">		}</a>
<a name="ln973">		// check whether the item belongs to our object</a>
<a name="ln974">		if (error == B_OK) {</a>
<a name="ln975">			VKey itemKey;</a>
<a name="ln976">			if (item.GetDirID() == fDirID &amp;&amp; item.GetObjectID() == fObjectID) {</a>
<a name="ln977">//PRINT((&quot;  found item: %lu, %lu, %Lu\n&quot;, fDirID, fObjectID, item.GetOffset()));</a>
<a name="ln978">				*foundItem = item;</a>
<a name="ln979">			} else</a>
<a name="ln980">{</a>
<a name="ln981">//PRINT((&quot;  item belongs to different object: (%lu, %lu)\n&quot;, item.GetDirID(), item.GetObjectID()));</a>
<a name="ln982">				error = B_ENTRY_NOT_FOUND;</a>
<a name="ln983">}</a>
<a name="ln984">		}</a>
<a name="ln985">		if (error != B_OK)</a>
<a name="ln986">			fDone = true;</a>
<a name="ln987">	}</a>
<a name="ln988">//PRINT((&quot;ObjectItemIterator::GetPrevious() done: %s\n&quot;, strerror(error)));</a>
<a name="ln989">	return error;</a>
<a name="ln990">}</a>
<a name="ln991"> </a>
<a name="ln992">// GetPrevious</a>
<a name="ln993">/*!	\brief Returns the previous item belonging to the object.</a>
<a name="ln994"> </a>
<a name="ln995">	This version finds only items of the specified type.</a>
<a name="ln996"> </a>
<a name="ln997">	\param foundItem Pointer to a pre-allocated Item that shall be set</a>
<a name="ln998">		   to the found item.</a>
<a name="ln999">	\param type The type the found item must have.</a>
<a name="ln1000">	\return \c B_OK, if everything went fine, \c B_ENTRY_NOT_FOUND, if we're</a>
<a name="ln1001">			through.</a>
<a name="ln1002">*/</a>
<a name="ln1003">status_t</a>
<a name="ln1004">ObjectItemIterator::GetPrevious(Item *foundItem, uint32 type)</a>
<a name="ln1005">{</a>
<a name="ln1006">	status_t error = B_OK;</a>
<a name="ln1007">	do {</a>
<a name="ln1008">		error = GetPrevious(foundItem);</a>
<a name="ln1009">	} while (error == B_OK &amp;&amp; foundItem-&gt;GetType() != type);</a>
<a name="ln1010">	return error;</a>
<a name="ln1011">}</a>
<a name="ln1012"> </a>
<a name="ln1013">// Suspend</a>
<a name="ln1014">/*! \brief Suspends the iterator.</a>
<a name="ln1015">	\see ItemIterator::Suspend().</a>
<a name="ln1016">	\return \c B_OK, if everything went fine.</a>
<a name="ln1017">*/</a>
<a name="ln1018">status_t</a>
<a name="ln1019">ObjectItemIterator::Suspend()</a>
<a name="ln1020">{</a>
<a name="ln1021">	return fItemIterator.Suspend();</a>
<a name="ln1022">}</a>
<a name="ln1023"> </a>
<a name="ln1024">// Resume</a>
<a name="ln1025">/*! \brief Resumes the iteration.</a>
<a name="ln1026">	\see ItemIterator::Resume().</a>
<a name="ln1027">	\return \c B_OK, if everything went fine.</a>
<a name="ln1028">*/</a>
<a name="ln1029">status_t</a>
<a name="ln1030">ObjectItemIterator::Resume()</a>
<a name="ln1031">{</a>
<a name="ln1032">	return fItemIterator.Resume();</a>
<a name="ln1033">}</a>
<a name="ln1034"> </a>
<a name="ln1035"> </a>
<a name="ln1036">/*!</a>
<a name="ln1037">	\class DirEntryIterator</a>
<a name="ln1038">	\brief Class used to iterate through DirEntries.</a>
<a name="ln1039">*/</a>
<a name="ln1040"> </a>
<a name="ln1041">// constructor</a>
<a name="ln1042">/*!	\brief Creates and initializes a DirEntryIterator.</a>
<a name="ln1043"> </a>
<a name="ln1044">	The iterator is initialized to find only entries belonging to the directory</a>
<a name="ln1045">	identified by \a dirID and \a objectID. \a startOffset specifies the</a>
<a name="ln1046">	offset (key offset) at which the iteration shall begin. If \a fixedHash</a>
<a name="ln1047">	is \c true, only items that have the same hash value as \a startOffset</a>
<a name="ln1048">	are found.</a>
<a name="ln1049"> </a>
<a name="ln1050">	\param tree The tree.</a>
<a name="ln1051">	\param dirID The directory ID of the object.</a>
<a name="ln1052">	\param objectID The object ID of the object.</a>
<a name="ln1053">	\param startOffset The offset at which to begin the iteration.</a>
<a name="ln1054">	\param fixedHash \c true to find only entries with the same hash as</a>
<a name="ln1055">		   \a startOffset</a>
<a name="ln1056">*/</a>
<a name="ln1057">DirEntryIterator::DirEntryIterator(Tree *tree, uint32 dirID, uint32 objectID,</a>
<a name="ln1058">								   uint64 startOffset, bool fixedHash)</a>
<a name="ln1059">	: fItemIterator(tree, dirID, objectID, startOffset),</a>
<a name="ln1060">	  fDirItem(),</a>
<a name="ln1061">	  fIndex(-1),</a>
<a name="ln1062">	  fFixedHash(fixedHash),</a>
<a name="ln1063">	  fDone(false)</a>
<a name="ln1064">{</a>
<a name="ln1065">}</a>
<a name="ln1066"> </a>
<a name="ln1067">// SetTo</a>
<a name="ln1068">/*!	\brief Re-initializes a DirEntryIterator.</a>
<a name="ln1069"> </a>
<a name="ln1070">	The iterator is initialized to find only entries belonging to the directory</a>
<a name="ln1071">	identified by \a dirID and \a objectID. \a startOffset specifies the</a>
<a name="ln1072">	offset (key offset) at which the iteration shall begin. If \a fixedHash</a>
<a name="ln1073">	is \c true, only items that have the same hash value as \a startOffset</a>
<a name="ln1074">	are found.</a>
<a name="ln1075"> </a>
<a name="ln1076">	\param tree The tree.</a>
<a name="ln1077">	\param dirID The directory ID of the object.</a>
<a name="ln1078">	\param objectID The object ID of the object.</a>
<a name="ln1079">	\param startOffset The offset at which to begin the iteration.</a>
<a name="ln1080">	\param fixedHash \c true to find only entries with the same hash as</a>
<a name="ln1081">		   \a startOffset</a>
<a name="ln1082">*/</a>
<a name="ln1083">status_t</a>
<a name="ln1084">DirEntryIterator::SetTo(Tree *tree, uint32 dirID, uint32 objectID,</a>
<a name="ln1085">						uint64 startOffset, bool fixedHash)</a>
<a name="ln1086">{</a>
<a name="ln1087">	fDirItem.Unset();</a>
<a name="ln1088">	status_t error = fItemIterator.SetTo(tree, dirID, objectID, startOffset);</a>
<a name="ln1089">	fIndex = -1;</a>
<a name="ln1090">	fFixedHash = fixedHash;</a>
<a name="ln1091">	fDone = false;</a>
<a name="ln1092">	return error;</a>
<a name="ln1093">}</a>
<a name="ln1094"> </a>
<a name="ln1095">// InitCheck</a>
<a name="ln1096">status_t</a>
<a name="ln1097">DirEntryIterator::InitCheck() const</a>
<a name="ln1098">{</a>
<a name="ln1099">	return fItemIterator.InitCheck();</a>
<a name="ln1100">}</a>
<a name="ln1101"> </a>
<a name="ln1102">// Rewind</a>
<a name="ln1103">/*!	\brief Rewinds the iterator.</a>
<a name="ln1104"> </a>
<a name="ln1105">	Simply re-initializes the iterator to the parameters of the last</a>
<a name="ln1106">	initialization.</a>
<a name="ln1107"> </a>
<a name="ln1108">	\return \c B_OK, if everything went fine.</a>
<a name="ln1109">*/</a>
<a name="ln1110">status_t</a>
<a name="ln1111">DirEntryIterator::Rewind()</a>
<a name="ln1112">{</a>
<a name="ln1113">	return SetTo(GetTree(), GetDirID(), GetObjectID(), GetOffset(),</a>
<a name="ln1114">				 fFixedHash);</a>
<a name="ln1115">}</a>
<a name="ln1116"> </a>
<a name="ln1117">// GetNext</a>
<a name="ln1118">/*!	\brief Returns the next entry belonging to the directory.</a>
<a name="ln1119">	\param foundItem Pointer to a pre-allocated Item that shall be set</a>
<a name="ln1120">		   to the found item.</a>
<a name="ln1121">	\param entryIndex Pointer to a pre-allocated int32 that shall be set</a>
<a name="ln1122">		   to the found entry index.</a>
<a name="ln1123">	\param _entry Pointer to a pre-allocated DirEntry pointer that shall be set</a>
<a name="ln1124">		   to the found entry. May be \c NULL.</a>
<a name="ln1125">	\return \c B_OK, if everything went fine, \c B_ENTRY_NOT_FOUND, if we're</a>
<a name="ln1126">			through.</a>
<a name="ln1127">*/</a>
<a name="ln1128">status_t</a>
<a name="ln1129">DirEntryIterator::GetNext(DirItem *foundItem, int32 *entryIndex,</a>
<a name="ln1130">						  DirEntry **_entry)</a>
<a name="ln1131">{</a>
<a name="ln1132">	status_t error = (foundItem &amp;&amp; entryIndex ? InitCheck() : B_BAD_VALUE);</a>
<a name="ln1133">	// get the next DirItem, if necessary</a>
<a name="ln1134">	// the loop skips empty DirItems gracefully</a>
<a name="ln1135">	while (error == B_OK</a>
<a name="ln1136">		   &amp;&amp; (fIndex &lt; 0 || fIndex &gt;= fDirItem.GetEntryCount())) {</a>
<a name="ln1137">		error = fItemIterator.GetNext(&amp;fDirItem, TYPE_DIRENTRY);</a>
<a name="ln1138">		if (error == B_OK) {</a>
<a name="ln1139">			if (fDirItem.Check() == B_OK)</a>
<a name="ln1140">				fIndex = 0;</a>
<a name="ln1141">			else	// bad data: skip the item</a>
<a name="ln1142">				fIndex = -1;</a>
<a name="ln1143">		}</a>
<a name="ln1144">	}</a>
<a name="ln1145">	// get the next entry and check whether it has the correct offset</a>
<a name="ln1146">	if (error == B_OK) {</a>
<a name="ln1147">		DirEntry *entry = fDirItem.EntryAt(fIndex);</a>
<a name="ln1148">		if (!fFixedHash</a>
<a name="ln1149">			|| offset_hash_value(entry-&gt;GetOffset())</a>
<a name="ln1150">			   == offset_hash_value(GetOffset())) {</a>
<a name="ln1151">			*foundItem = fDirItem;</a>
<a name="ln1152">			*entryIndex = fIndex;</a>
<a name="ln1153">			if (_entry)</a>
<a name="ln1154">				*_entry = entry;</a>
<a name="ln1155">			fIndex++;</a>
<a name="ln1156">		} else</a>
<a name="ln1157">			error = B_ENTRY_NOT_FOUND;</a>
<a name="ln1158">	}</a>
<a name="ln1159">	return error;</a>
<a name="ln1160">}</a>
<a name="ln1161"> </a>
<a name="ln1162">// GetPrevious</a>
<a name="ln1163">/*!	\brief Returns the previous entry belonging to the directory.</a>
<a name="ln1164">	\param foundItem Pointer to a pre-allocated Item that shall be set</a>
<a name="ln1165">		   to the found item.</a>
<a name="ln1166">	\param entryIndex Pointer to a pre-allocated int32 that shall be set</a>
<a name="ln1167">		   to the found entry index.</a>
<a name="ln1168">	\param _entry Pointer to a pre-allocated DirEntry pointer that shall be set</a>
<a name="ln1169">		   to the found entry. May be \c NULL.</a>
<a name="ln1170">	\return \c B_OK, if everything went fine, \c B_ENTRY_NOT_FOUND, if we're</a>
<a name="ln1171">			through.</a>
<a name="ln1172">*/</a>
<a name="ln1173">status_t</a>
<a name="ln1174">DirEntryIterator::GetPrevious(DirItem *foundItem, int32 *entryIndex,</a>
<a name="ln1175">							  DirEntry **_entry)</a>
<a name="ln1176">{</a>
<a name="ln1177">//printf(&quot;DirEntryIterator::GetPrevious()\n&quot;);</a>
<a name="ln1178">	status_t error = (foundItem &amp;&amp; entryIndex ? InitCheck() : B_BAD_VALUE);</a>
<a name="ln1179">	if (error == B_OK &amp;&amp; fDone)</a>
<a name="ln1180">		error = B_ENTRY_NOT_FOUND;</a>
<a name="ln1181">	// get the next DirItem, if necessary</a>
<a name="ln1182">	// the loop skips empty DirItems gracefully</a>
<a name="ln1183">	while (error == B_OK</a>
<a name="ln1184">		   &amp;&amp; (fIndex &lt; 0 || fIndex &gt;= fDirItem.GetEntryCount())) {</a>
<a name="ln1185">		error = fItemIterator.GetPrevious(&amp;fDirItem, TYPE_DIRENTRY);</a>
<a name="ln1186">		if (error == B_OK) {</a>
<a name="ln1187">			if (fDirItem.Check() == B_OK)</a>
<a name="ln1188">				fIndex = fDirItem.GetEntryCount() - 1;</a>
<a name="ln1189">			else	// bad data: skip the item</a>
<a name="ln1190">				fIndex = -1;</a>
<a name="ln1191">		}</a>
<a name="ln1192">	}</a>
<a name="ln1193">//printf(&quot;  found dir item: %s\n&quot;, strerror(error));</a>
<a name="ln1194">	// skip entries with a greater offset</a>
<a name="ln1195">	while (error == B_OK &amp;&amp; fIndex &gt;= 0</a>
<a name="ln1196">		   &amp;&amp; fDirItem.EntryAt(fIndex)-&gt;GetOffset() &gt; GetOffset()) {</a>
<a name="ln1197">//printf(&quot;  skipping entry %ld: offset %lu\n&quot;, fIndex, fDirItem.EntryAt(fIndex)-&gt;GetOffset());</a>
<a name="ln1198">		fIndex--;</a>
<a name="ln1199">	}</a>
<a name="ln1200">	// get the entry and check whether it has the correct offset</a>
<a name="ln1201">	if (error == B_OK) {</a>
<a name="ln1202">//printf(&quot;  entries with greater offsets skipped: index: %ld\n&quot;, fIndex);</a>
<a name="ln1203">		if (fIndex &gt;= 0</a>
<a name="ln1204">//&amp;&amp; (printf(&quot;  entry index %ld: offset %lu\n&quot;, fIndex, fDirItem.EntryAt(fIndex)-&gt;GetOffset()), true)</a>
<a name="ln1205">			&amp;&amp; (!fFixedHash</a>
<a name="ln1206">				|| offset_hash_value(fDirItem.EntryAt(fIndex)-&gt;GetOffset())</a>
<a name="ln1207">				   == offset_hash_value(GetOffset()))) {</a>
<a name="ln1208">//printf(&quot;  entry found\n&quot;);</a>
<a name="ln1209">			DirEntry *entry = fDirItem.EntryAt(fIndex);</a>
<a name="ln1210">			*foundItem = fDirItem;</a>
<a name="ln1211">			*entryIndex = fIndex;</a>
<a name="ln1212">			fDone = (fFixedHash</a>
<a name="ln1213">					 &amp;&amp; offset_generation_number(entry-&gt;GetOffset()) == 0);</a>
<a name="ln1214">			if (_entry)</a>
<a name="ln1215">				*_entry = entry;</a>
<a name="ln1216">			fIndex--;</a>
<a name="ln1217">		} else</a>
<a name="ln1218">			error = B_ENTRY_NOT_FOUND;</a>
<a name="ln1219">	}</a>
<a name="ln1220">//printf(&quot;DirEntryIterator::GetPrevious() done: %s\n&quot;, strerror(error));</a>
<a name="ln1221">	return error;</a>
<a name="ln1222">}</a>
<a name="ln1223"> </a>
<a name="ln1224">// Suspend</a>
<a name="ln1225">/*! \brief Suspends the iterator.</a>
<a name="ln1226">	\see ObjectItemIterator::Suspend().</a>
<a name="ln1227">	\return \c B_OK, if everything went fine.</a>
<a name="ln1228">*/</a>
<a name="ln1229">status_t</a>
<a name="ln1230">DirEntryIterator::Suspend()</a>
<a name="ln1231">{</a>
<a name="ln1232">	return fItemIterator.Suspend();</a>
<a name="ln1233">}</a>
<a name="ln1234"> </a>
<a name="ln1235">// Resume</a>
<a name="ln1236">/*! \brief Resumes the iteration.</a>
<a name="ln1237">	\see ObjectItemIterator::Resume().</a>
<a name="ln1238">	\return \c B_OK, if everything went fine.</a>
<a name="ln1239">*/</a>
<a name="ln1240">status_t</a>
<a name="ln1241">DirEntryIterator::Resume()</a>
<a name="ln1242">{</a>
<a name="ln1243">	return fItemIterator.Resume();</a>
<a name="ln1244">}</a>
<a name="ln1245"> </a>
<a name="ln1246"> </a>
<a name="ln1247">/*!</a>
<a name="ln1248">	\class StreamReader</a>
<a name="ln1249">	\brief Class used to read object streams (files, links).</a>
<a name="ln1250">*/</a>
<a name="ln1251"> </a>
<a name="ln1252">// constructor</a>
<a name="ln1253">/*!	\brief Creates and initializes a StreamReader.</a>
<a name="ln1254"> </a>
<a name="ln1255">	The reader is initialized to read the stream of the object</a>
<a name="ln1256">	identified by \a dirID and \a objectID.</a>
<a name="ln1257"> </a>
<a name="ln1258">	\param tree The tree.</a>
<a name="ln1259">	\param dirID The directory ID of the object.</a>
<a name="ln1260">	\param objectID The object ID of the object.</a>
<a name="ln1261">*/</a>
<a name="ln1262">StreamReader::StreamReader(Tree *tree, uint32 dirID, uint32 objectID)</a>
<a name="ln1263">	: fItemIterator(tree, dirID, objectID, SD_OFFSET),</a>
<a name="ln1264">	  fItem(),</a>
<a name="ln1265">	  fStreamSize(-1),</a>
<a name="ln1266">	  fItemOffset(-1),</a>
<a name="ln1267">	  fItemSize(0),</a>
<a name="ln1268">	  fBlockSize(0)</a>
<a name="ln1269">{</a>
<a name="ln1270">	fBlockSize = tree-&gt;GetBlockSize();</a>
<a name="ln1271">}</a>
<a name="ln1272"> </a>
<a name="ln1273">// SetTo</a>
<a name="ln1274">/*!	\brief Creates and initializes a StreamReader.</a>
<a name="ln1275"> </a>
<a name="ln1276">	The reader is initialized to read the stream of the object</a>
<a name="ln1277">	identified by \a dirID and \a objectID.</a>
<a name="ln1278"> </a>
<a name="ln1279">	\param tree The tree.</a>
<a name="ln1280">	\param dirID The directory ID of the object.</a>
<a name="ln1281">	\param objectID The object ID of the object.</a>
<a name="ln1282">	\return \c B_OK, if everything went fine.</a>
<a name="ln1283">*/</a>
<a name="ln1284">status_t</a>
<a name="ln1285">StreamReader::SetTo(Tree *tree, uint32 dirID, uint32 objectID)</a>
<a name="ln1286">{</a>
<a name="ln1287">	fItem.Unset();</a>
<a name="ln1288">	status_t error = fItemIterator.SetTo(tree, dirID, objectID, SD_OFFSET);</a>
<a name="ln1289">	fStreamSize = -1;</a>
<a name="ln1290">	fItemOffset = -1;</a>
<a name="ln1291">	fItemSize = 0;</a>
<a name="ln1292">	fBlockSize = tree-&gt;GetBlockSize();</a>
<a name="ln1293">	return error;</a>
<a name="ln1294">}</a>
<a name="ln1295"> </a>
<a name="ln1296">// InitCheck</a>
<a name="ln1297">status_t</a>
<a name="ln1298">StreamReader::InitCheck() const</a>
<a name="ln1299">{</a>
<a name="ln1300">	return fItemIterator.InitCheck();</a>
<a name="ln1301">}</a>
<a name="ln1302"> </a>
<a name="ln1303">// ReadAt</a>
<a name="ln1304">/*!	\brief Tries to read the specified number of bytes from the stream into</a>
<a name="ln1305">		   the supplied buffer.</a>
<a name="ln1306">	\param position Stream position at which to start reading.</a>
<a name="ln1307">	\param buffer Pointer to a pre-allocated buffer into which the read data</a>
<a name="ln1308">		   shall be written.</a>
<a name="ln1309">	\param bufferSize Number of bytes to be read.</a>
<a name="ln1310">	\param _bytesRead Pointer to a pre-allocated size_t which shall be set to</a>
<a name="ln1311">		   the number of bytes actually read.</a>
<a name="ln1312">	\return \c B_OK, if everything went fine.</a>
<a name="ln1313">*/</a>
<a name="ln1314">status_t</a>
<a name="ln1315">StreamReader::ReadAt(off_t position, void *buffer, size_t bufferSize,</a>
<a name="ln1316">					 size_t *_bytesRead)</a>
<a name="ln1317">{</a>
<a name="ln1318">//PRINT((&quot;StreamReader::ReadAt(%Ld, %p, %lu)\n&quot;, position, buffer, bufferSize));</a>
<a name="ln1319">	status_t error = (position &gt;= 0 &amp;&amp; buffer &amp;&amp; _bytesRead ? InitCheck()</a>
<a name="ln1320">															: B_BAD_VALUE);</a>
<a name="ln1321">	// get the size of the stream</a>
<a name="ln1322">	if (error == B_OK)</a>
<a name="ln1323">		error = _GetStreamSize();</a>
<a name="ln1324">	// compute the number of bytes that acually have to be read</a>
<a name="ln1325">	if (error == B_OK) {</a>
<a name="ln1326">		if (position &lt; fStreamSize) {</a>
<a name="ln1327">			if (position + bufferSize &gt; fStreamSize)</a>
<a name="ln1328">				bufferSize = fStreamSize - position;</a>
<a name="ln1329">		} else</a>
<a name="ln1330">			bufferSize = 0;</a>
<a name="ln1331">	}</a>
<a name="ln1332">	// do the reading</a>
<a name="ln1333">	if (error == B_OK) {</a>
<a name="ln1334">		size_t bytesRead = 0;</a>
<a name="ln1335">		while (error == B_OK &amp;&amp; bufferSize &gt; 0</a>
<a name="ln1336">			   &amp;&amp; (error = _SeekTo(position)) == B_OK) {</a>
<a name="ln1337">//PRINT((&quot;  seeked to %Ld: fItemOffset: %Ld, fItemSize: %Ld\n&quot;, position,</a>
<a name="ln1338">//fItemOffset, fItemSize));</a>
<a name="ln1339">			off_t inItemOffset = max_c(0LL, position - fItemOffset);</a>
<a name="ln1340">			off_t toRead = min_c(fItemSize - inItemOffset, (off_t)bufferSize);</a>
<a name="ln1341">			switch (fItem.GetType()) {</a>
<a name="ln1342">				case TYPE_INDIRECT:</a>
<a name="ln1343">					error = _ReadIndirectItem(inItemOffset, buffer, toRead);</a>
<a name="ln1344">					break;</a>
<a name="ln1345">				case TYPE_DIRECT:</a>
<a name="ln1346">					error = _ReadDirectItem(inItemOffset, buffer, toRead);</a>
<a name="ln1347">					break;</a>
<a name="ln1348">				case TYPE_STAT_DATA:</a>
<a name="ln1349">				case TYPE_DIRENTRY:</a>
<a name="ln1350">				case TYPE_ANY:</a>
<a name="ln1351">				default:</a>
<a name="ln1352">					FATAL((&quot;Neither direct nor indirect item! type: %u\n&quot;,</a>
<a name="ln1353">						   fItem.GetType()));</a>
<a name="ln1354">					error = B_IO_ERROR;</a>
<a name="ln1355">					break;</a>
<a name="ln1356">			}</a>
<a name="ln1357">			if (error == B_OK) {</a>
<a name="ln1358">				buffer = (uint8*)buffer + toRead;</a>
<a name="ln1359">				position += toRead;</a>
<a name="ln1360">				bufferSize -= toRead;</a>
<a name="ln1361">				bytesRead += toRead;</a>
<a name="ln1362">			}</a>
<a name="ln1363">		}</a>
<a name="ln1364">		*_bytesRead = bytesRead;</a>
<a name="ln1365">	}</a>
<a name="ln1366">//if (error == B_OK)</a>
<a name="ln1367">//PRINT((&quot;StreamReader::ReadAt() done: read: %lu bytes\n&quot;, *_bytesRead))</a>
<a name="ln1368">//else</a>
<a name="ln1369">//PRINT((&quot;StreamReader::ReadAt() done: %s\n&quot;, strerror(error)))</a>
<a name="ln1370">	return error;</a>
<a name="ln1371">}</a>
<a name="ln1372"> </a>
<a name="ln1373">// Suspend</a>
<a name="ln1374">/*! \brief Suspends the reader.</a>
<a name="ln1375">	\see ObjectItemIterator::Suspend().</a>
<a name="ln1376">	\return \c B_OK, if everything went fine.</a>
<a name="ln1377">*/</a>
<a name="ln1378">status_t</a>
<a name="ln1379">StreamReader::Suspend()</a>
<a name="ln1380">{</a>
<a name="ln1381">	return fItemIterator.Suspend();</a>
<a name="ln1382">}</a>
<a name="ln1383"> </a>
<a name="ln1384">// Resume</a>
<a name="ln1385">/*! \brief Resumes the reader.</a>
<a name="ln1386">	\see ObjectItemIterator::Resume().</a>
<a name="ln1387">	\return \c B_OK, if everything went fine.</a>
<a name="ln1388">*/</a>
<a name="ln1389">status_t</a>
<a name="ln1390">StreamReader::Resume()</a>
<a name="ln1391">{</a>
<a name="ln1392">	return fItemIterator.Resume();</a>
<a name="ln1393">}</a>
<a name="ln1394"> </a>
<a name="ln1395">// _GetStreamSize</a>
<a name="ln1396">status_t</a>
<a name="ln1397">StreamReader::_GetStreamSize()</a>
<a name="ln1398">{</a>
<a name="ln1399">	status_t error = B_OK;</a>
<a name="ln1400">	if (fStreamSize &lt; 0) {</a>
<a name="ln1401">		// get the stat item</a>
<a name="ln1402">		error = fItemIterator.GetNext(&amp;fItem, TYPE_STAT_DATA);</a>
<a name="ln1403">		if (error == B_OK) {</a>
<a name="ln1404">			StatData statData;</a>
<a name="ln1405">			error = (static_cast&lt;StatItem*&gt;(&amp;fItem))-&gt;GetStatData(&amp;statData);</a>
<a name="ln1406">			if (error == B_OK)</a>
<a name="ln1407">				fStreamSize = statData.GetSize();</a>
<a name="ln1408">		}</a>
<a name="ln1409">	}</a>
<a name="ln1410">	return error;</a>
<a name="ln1411">}</a>
<a name="ln1412"> </a>
<a name="ln1413">// _SeekTo</a>
<a name="ln1414">status_t</a>
<a name="ln1415">StreamReader::_SeekTo(off_t position)</a>
<a name="ln1416">{</a>
<a name="ln1417">	status_t error = _GetStreamSize();</a>
<a name="ln1418">	if (error == B_OK &amp;&amp; fItemOffset &lt; 0)</a>
<a name="ln1419">		fItemOffset = 0;	// prepare for the loop</a>
<a name="ln1420">	if (error == B_OK) {</a>
<a name="ln1421">		if (2 * position &lt; fItemOffset) {</a>
<a name="ln1422">			// seek backwards</a>
<a name="ln1423">			// since the position is closer to the beginning of the file than</a>
<a name="ln1424">			// to the current position, we simply reinit the item iterator</a>
<a name="ln1425">			// and seek forward</a>
<a name="ln1426">			error = fItemIterator.SetTo(GetTree(), GetDirID(), GetObjectID(),</a>
<a name="ln1427">										SD_OFFSET);</a>
<a name="ln1428">			fStreamSize = -1;</a>
<a name="ln1429">			fItemOffset = -1;</a>
<a name="ln1430">			fItemSize = 0;</a>
<a name="ln1431">			if (error == B_OK)</a>
<a name="ln1432">				error = _SeekTo(position);</a>
<a name="ln1433">		} else if (position &lt; fItemOffset) {</a>
<a name="ln1434">			// seek backwards</a>
<a name="ln1435">			// iterate through the items</a>
<a name="ln1436">			while (error == B_OK &amp;&amp; position &lt; fItemOffset</a>
<a name="ln1437">				   &amp;&amp; (error = fItemIterator.GetPrevious(&amp;fItem)) == B_OK) {</a>
<a name="ln1438">				fItemSize = 0;</a>
<a name="ln1439">				switch (fItem.GetType()) {</a>
<a name="ln1440">					case TYPE_INDIRECT:</a>
<a name="ln1441">					{</a>
<a name="ln1442">						IndirectItem &amp;indirect</a>
<a name="ln1443">							= *static_cast&lt;IndirectItem*&gt;(&amp;fItem);</a>
<a name="ln1444">						// Note, that it is assumed, that the existence of a</a>
<a name="ln1445">						// next item implies, that all blocks are fully used.</a>
<a name="ln1446">						// This is safe, since otherwise we would have never</a>
<a name="ln1447">						// come to the next item.</a>
<a name="ln1448">						fItemSize = indirect.CountBlocks() * (off_t)fBlockSize;</a>
<a name="ln1449">						break;</a>
<a name="ln1450">					}</a>
<a name="ln1451">					case TYPE_DIRECT:</a>
<a name="ln1452">						// See the comment for indirect items.</a>
<a name="ln1453">						fItemSize = fItem.GetLen();</a>
<a name="ln1454">						break;</a>
<a name="ln1455">					case TYPE_STAT_DATA:</a>
<a name="ln1456">					case TYPE_DIRENTRY:</a>
<a name="ln1457">					case TYPE_ANY:</a>
<a name="ln1458">					default:</a>
<a name="ln1459">						// simply skip items of other kinds</a>
<a name="ln1460">						break;</a>
<a name="ln1461">				}</a>
<a name="ln1462">				fItemOffset -= fItemSize;</a>
<a name="ln1463">			}</a>
<a name="ln1464">		} else if (position &gt;= fItemOffset + fItemSize) {</a>
<a name="ln1465">			// seek forward</a>
<a name="ln1466">			// iterate through the items</a>
<a name="ln1467">			while (error == B_OK &amp;&amp; position &gt;= fItemOffset + fItemSize</a>
<a name="ln1468">				   &amp;&amp; (error = fItemIterator.GetNext(&amp;fItem)) == B_OK) {</a>
<a name="ln1469">				fItemOffset += fItemSize;</a>
<a name="ln1470">				fItemSize = 0;</a>
<a name="ln1471">				switch (fItem.GetType()) {</a>
<a name="ln1472">					case TYPE_INDIRECT:</a>
<a name="ln1473">					{</a>
<a name="ln1474">						IndirectItem &amp;indirect</a>
<a name="ln1475">							= *static_cast&lt;IndirectItem*&gt;(&amp;fItem);</a>
<a name="ln1476">						fItemSize = min(indirect.CountBlocks()</a>
<a name="ln1477">											* (off_t)fBlockSize,</a>
<a name="ln1478">										fStreamSize - fItemOffset);</a>
<a name="ln1479">						break;</a>
<a name="ln1480">					}</a>
<a name="ln1481">					case TYPE_DIRECT:</a>
<a name="ln1482">						fItemSize = min((off_t)fItem.GetLen(),</a>
<a name="ln1483">										fStreamSize - fItemOffset);</a>
<a name="ln1484">						break;</a>
<a name="ln1485">					case TYPE_STAT_DATA:</a>
<a name="ln1486">					case TYPE_DIRENTRY:</a>
<a name="ln1487">					case TYPE_ANY:</a>
<a name="ln1488">					default:</a>
<a name="ln1489">						// simply skip items of other kinds</a>
<a name="ln1490">						break;</a>
<a name="ln1491">				}</a>
<a name="ln1492">			}</a>
<a name="ln1493">		}</a>
<a name="ln1494">	}</a>
<a name="ln1495">//	return error;</a>
<a name="ln1496">RETURN_ERROR(error);</a>
<a name="ln1497">}</a>
<a name="ln1498"> </a>
<a name="ln1499">// _ReadIndirectItem</a>
<a name="ln1500">status_t</a>
<a name="ln1501">StreamReader::_ReadIndirectItem(off_t offset, void *buffer, size_t bufferSize)</a>
<a name="ln1502">{</a>
<a name="ln1503">//PRINT((&quot;StreamReader::_ReadIndirectItem(%Ld, %p, %lu)\n&quot;, offset, buffer, bufferSize));</a>
<a name="ln1504">	status_t error = B_OK;</a>
<a name="ln1505">	IndirectItem &amp;indirect = *static_cast&lt;IndirectItem*&gt;(&amp;fItem);</a>
<a name="ln1506">	// skip items until the offset is reached</a>
<a name="ln1507">	uint32 skipItems = 0;</a>
<a name="ln1508">	if (offset &gt; 0) {</a>
<a name="ln1509">		skipItems = uint32(offset / fBlockSize);</a>
<a name="ln1510">		skipItems = min(skipItems, indirect.CountBlocks());	// not necessary</a>
<a name="ln1511">	}</a>
<a name="ln1512">//PRINT((&quot;  skipItems: %lu\n&quot;, skipItems));</a>
<a name="ln1513">	for (uint32 i = skipItems;</a>
<a name="ln1514">		 error == B_OK &amp;&amp; bufferSize &gt; 0 &amp;&amp; i &lt; indirect.CountBlocks();</a>
<a name="ln1515">		 i++) {</a>
<a name="ln1516">//PRINT((&quot;    child %lu\n&quot;, i));</a>
<a name="ln1517">		// get the block</a>
<a name="ln1518">		Block *block = NULL;</a>
<a name="ln1519">		error = GetTree()-&gt;GetBlock(indirect.BlockNumberAt(i), &amp;block);</a>
<a name="ln1520">		if (error == B_OK) {</a>
<a name="ln1521">			// copy the data into the buffer</a>
<a name="ln1522">			off_t blockOffset = i * (off_t)fBlockSize;</a>
<a name="ln1523">			uint32 localOffset = max_c(0LL, offset - blockOffset);</a>
<a name="ln1524">			uint32 toRead = min_c(fBlockSize - localOffset, bufferSize);</a>
<a name="ln1525">			memcpy(buffer, (uint8*)block-&gt;GetData() + localOffset, toRead);</a>
<a name="ln1526">			block-&gt;Put();</a>
<a name="ln1527">			bufferSize -= toRead;</a>
<a name="ln1528">			buffer = (uint8*)buffer + toRead;</a>
<a name="ln1529">		} else {</a>
<a name="ln1530">			FATAL((&quot;failed to get block %Lu\n&quot;, indirect.BlockNumberAt(i)));</a>
<a name="ln1531">			error = B_IO_ERROR;</a>
<a name="ln1532">		}</a>
<a name="ln1533">	}</a>
<a name="ln1534">//PRINT((&quot;StreamReader::_ReadIndirectItem() done: %s\n&quot;, strerror(error)))</a>
<a name="ln1535">	return error;</a>
<a name="ln1536">}</a>
<a name="ln1537"> </a>
<a name="ln1538">// _ReadDirectItem</a>
<a name="ln1539">status_t</a>
<a name="ln1540">StreamReader::_ReadDirectItem(off_t offset, void *buffer, size_t bufferSize)</a>
<a name="ln1541">{</a>
<a name="ln1542">//PRINT((&quot;StreamReader::_ReadDirectItem(%Ld, %p, %lu)\n&quot;, offset, buffer, bufferSize));</a>
<a name="ln1543">	// copy the data into the buffer</a>
<a name="ln1544">	memcpy(buffer, (uint8*)fItem.GetData() + offset, bufferSize);</a>
<a name="ln1545">	return B_OK;</a>
<a name="ln1546">}</a>
<a name="ln1547"> </a>

</code></pre>
<div class="balloon" rel="518"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'error == ((int) 0)' is always true.</p></div>
<div class="balloon" rel="1530"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Potentially incorrect format string is passed to the 'dprintf' function. Prefix 'L' is not applicable to conversion specifier 'u'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
