
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>file.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">	Copyright 1999-2001, Be Incorporated.   All Rights Reserved.</a>
<a name="ln3">	This file may be used under the terms of the Be Sample Code License.</a>
<a name="ln4">*/</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;stdlib.h&gt;</a>
<a name="ln7">#include &lt;string.h&gt;</a>
<a name="ln8">#include &lt;sys/stat.h&gt;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;fs_cache.h&gt;</a>
<a name="ln11">#include &lt;fs_info.h&gt;</a>
<a name="ln12">#include &lt;Drivers.h&gt;</a>
<a name="ln13">#include &lt;KernelExport.h&gt;</a>
<a name="ln14">#include &lt;NodeMonitor.h&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;time.h&gt;</a>
<a name="ln17"> </a>
<a name="ln18">#include &quot;iter.h&quot;</a>
<a name="ln19">#include &quot;dosfs.h&quot;</a>
<a name="ln20">#include &quot;dlist.h&quot;</a>
<a name="ln21">#include &quot;fat.h&quot;</a>
<a name="ln22">#include &quot;dir.h&quot;</a>
<a name="ln23">#include &quot;file.h&quot;</a>
<a name="ln24">#include &quot;attr.h&quot;</a>
<a name="ln25">#include &quot;vcache.h&quot;</a>
<a name="ln26">#include &quot;util.h&quot;</a>
<a name="ln27"> </a>
<a name="ln28">#define DPRINTF(a,b) if (debug_file &gt; (a)) dprintf b</a>
<a name="ln29"> </a>
<a name="ln30">#define MAX_FILE_SIZE 0xffffffffLL</a>
<a name="ln31"> </a>
<a name="ln32"> </a>
<a name="ln33">typedef struct filecookie {</a>
<a name="ln34">	uint32		mode;		// open mode</a>
<a name="ln35">} filecookie;</a>
<a name="ln36"> </a>
<a name="ln37"> </a>
<a name="ln38">mode_t</a>
<a name="ln39">make_mode(nspace *volume, vnode *node)</a>
<a name="ln40">{</a>
<a name="ln41">	mode_t result = S_IFREG | S_IRUSR | S_IRGRP | S_IROTH | S_IWUSR | S_IWGRP | S_IWOTH;</a>
<a name="ln42">	if (node-&gt;mode &amp; FAT_SUBDIR) {</a>
<a name="ln43">		result &amp;= ~S_IFREG;</a>
<a name="ln44">		result |= S_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;</a>
<a name="ln45">	}</a>
<a name="ln46">	if ((node-&gt;mode &amp; FAT_READ_ONLY) != 0)</a>
<a name="ln47">		result &amp;= ~(S_IWUSR | S_IWGRP | S_IWOTH);</a>
<a name="ln48"> </a>
<a name="ln49">	return result;</a>
<a name="ln50">}</a>
<a name="ln51"> </a>
<a name="ln52"> </a>
<a name="ln53">status_t</a>
<a name="ln54">dosfs_get_vnode_name(fs_volume *_ns, fs_vnode *_node, char *buffer,</a>
<a name="ln55">	size_t bufferSize)</a>
<a name="ln56">{</a>
<a name="ln57">	vnode   *node = (vnode*)_node-&gt;private_node;</a>
<a name="ln58">	strlcpy(buffer, node-&gt;filename, bufferSize);</a>
<a name="ln59">	return B_OK;</a>
<a name="ln60">}</a>
<a name="ln61"> </a>
<a name="ln62"> </a>
<a name="ln63">status_t write_vnode_entry(nspace *vol, vnode *node)</a>
<a name="ln64">{</a>
<a name="ln65">	uint32 i;</a>
<a name="ln66">	struct diri diri;</a>
<a name="ln67">	uint8 *buffer;</a>
<a name="ln68"> </a>
<a name="ln69"> </a>
<a name="ln70">	// TODO : is it needed ? vfs job ?</a>
<a name="ln71">	// don't update entries of deleted files</a>
<a name="ln72">	//if (is_vnode_removed(vol-&gt;id, node-&gt;vnid) &gt; 0) return 0;</a>
<a name="ln73"> </a>
<a name="ln74">	// XXX: should check if directory position is still valid even</a>
<a name="ln75">	// though we do the is_vnode_removed check above</a>
<a name="ln76"> </a>
<a name="ln77">	if ((node-&gt;cluster != 0) &amp;&amp; !IS_DATA_CLUSTER(node-&gt;cluster)) {</a>
<a name="ln78">		dprintf(&quot;write_vnode_entry called on invalid cluster (%&quot; B_PRIu32 &quot;)\n&quot;,</a>
<a name="ln79">			node-&gt;cluster);</a>
<a name="ln80">		return EINVAL;</a>
<a name="ln81">	}</a>
<a name="ln82"> </a>
<a name="ln83">	buffer = diri_init(vol, VNODE_PARENT_DIR_CLUSTER(node), node-&gt;eindex, &amp;diri);</a>
<a name="ln84">	if (buffer == NULL)</a>
<a name="ln85">		return ENOENT;</a>
<a name="ln86"> </a>
<a name="ln87">	diri_make_writable(&amp;diri);</a>
<a name="ln88">	buffer[0x0b] = node-&gt;mode; // file attributes</a>
<a name="ln89"> </a>
<a name="ln90">	memset(buffer+0xc, 0, 0x16-0xc);</a>
<a name="ln91">	i = time_t2dos(node-&gt;st_crtim);</a>
<a name="ln92">	buffer[0x0e] = i &amp; 0xff;</a>
<a name="ln93">	buffer[0x0f] = (i &gt;&gt; 8) &amp; 0xff;</a>
<a name="ln94">	buffer[0x10] = (i &gt;&gt; 16) &amp; 0xff;</a>
<a name="ln95">	buffer[0x11] = (i &gt;&gt; 24) &amp; 0xff;</a>
<a name="ln96">	i = time_t2dos(node-&gt;st_time);</a>
<a name="ln97">	buffer[0x16] = i &amp; 0xff;</a>
<a name="ln98">	buffer[0x17] = (i &gt;&gt; 8) &amp; 0xff;</a>
<a name="ln99">	buffer[0x18] = (i &gt;&gt; 16) &amp; 0xff;</a>
<a name="ln100">	buffer[0x19] = (i &gt;&gt; 24) &amp; 0xff;</a>
<a name="ln101">	buffer[0x1a] = node-&gt;cluster &amp; 0xff;	// starting cluster</a>
<a name="ln102">	buffer[0x1b] = (node-&gt;cluster &gt;&gt; 8) &amp; 0xff;</a>
<a name="ln103">	if (vol-&gt;fat_bits == 32) {</a>
<a name="ln104">		buffer[0x14] = (node-&gt;cluster &gt;&gt; 16) &amp; 0xff;</a>
<a name="ln105">		buffer[0x15] = (node-&gt;cluster &gt;&gt; 24) &amp; 0xff;</a>
<a name="ln106">	}</a>
<a name="ln107">	if (node-&gt;mode &amp; FAT_SUBDIR) {</a>
<a name="ln108">		buffer[0x1c] = buffer[0x1d] = buffer[0x1e] = buffer[0x1f] = 0;</a>
<a name="ln109">	} else {</a>
<a name="ln110">		buffer[0x1c] = node-&gt;st_size &amp; 0xff;	// file size</a>
<a name="ln111">		buffer[0x1d] = (node-&gt;st_size &gt;&gt; 8) &amp; 0xff;</a>
<a name="ln112">		buffer[0x1e] = (node-&gt;st_size &gt;&gt; 16) &amp; 0xff;</a>
<a name="ln113">		buffer[0x1f] = (node-&gt;st_size &gt;&gt; 24) &amp; 0xff;</a>
<a name="ln114">	}</a>
<a name="ln115"> </a>
<a name="ln116">	diri_free(&amp;diri);</a>
<a name="ln117"> </a>
<a name="ln118">	// TODO: figure out which stats have actually changed</a>
<a name="ln119">	notify_stat_changed(vol-&gt;id, -1, node-&gt;vnid, B_STAT_MODE | B_STAT_UID</a>
<a name="ln120">		| B_STAT_GID | B_STAT_SIZE | B_STAT_ACCESS_TIME</a>
<a name="ln121">		| B_STAT_MODIFICATION_TIME | B_STAT_CREATION_TIME</a>
<a name="ln122">		| B_STAT_CHANGE_TIME);</a>
<a name="ln123"> </a>
<a name="ln124">	return B_OK;</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127"> </a>
<a name="ln128">// called when fs is done with vnode</a>
<a name="ln129">// after close, etc. free vnode resources here</a>
<a name="ln130">status_t</a>
<a name="ln131">dosfs_release_vnode(fs_volume *_vol, fs_vnode *_node, bool reenter)</a>
<a name="ln132">{</a>
<a name="ln133">	nspace *vol = (nspace *)_vol-&gt;private_volume;</a>
<a name="ln134">	vnode *node = (vnode *)_node-&gt;private_node;</a>
<a name="ln135"> </a>
<a name="ln136">	TOUCH(reenter);</a>
<a name="ln137"> </a>
<a name="ln138">	DPRINTF(0, (&quot;dosfs_release_vnode (ino_t %&quot; B_PRIdINO &quot;)\n&quot;, node-&gt;vnid));</a>
<a name="ln139"> </a>
<a name="ln140">	if ((vol-&gt;fs_flags &amp; FS_FLAGS_OP_SYNC) &amp;&amp; node-&gt;dirty) {</a>
<a name="ln141">		LOCK_VOL(vol);</a>
<a name="ln142">		_dosfs_sync(vol);</a>
<a name="ln143">		UNLOCK_VOL(vol);</a>
<a name="ln144">	}</a>
<a name="ln145"> </a>
<a name="ln146">	if (node != NULL) {</a>
<a name="ln147">#if TRACK_FILENAME</a>
<a name="ln148">		if (node-&gt;filename) free(node-&gt;filename);</a>
<a name="ln149">#endif</a>
<a name="ln150"> </a>
<a name="ln151">		if (node-&gt;vnid != vol-&gt;root_vnode.vnid) {</a>
<a name="ln152">			file_cache_delete(node-&gt;cache);</a>
<a name="ln153">			file_map_delete(node-&gt;file_map);</a>
<a name="ln154">			free(node);</a>
<a name="ln155">		}</a>
<a name="ln156">	}</a>
<a name="ln157"> </a>
<a name="ln158">	return 0;</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161"> </a>
<a name="ln162">status_t</a>
<a name="ln163">dosfs_rstat(fs_volume *_vol, fs_vnode *_node, struct stat *st)</a>
<a name="ln164">{</a>
<a name="ln165">	nspace	*vol = (nspace*)_vol-&gt;private_volume;</a>
<a name="ln166">	vnode	*node = (vnode*)_node-&gt;private_node;</a>
<a name="ln167"> </a>
<a name="ln168">	LOCK_VOL(vol);</a>
<a name="ln169"> </a>
<a name="ln170">	DPRINTF(1, (&quot;dosfs_rstat (vnode id %&quot; B_PRIdINO &quot;)\n&quot;, node-&gt;vnid));</a>
<a name="ln171"> </a>
<a name="ln172">	st-&gt;st_dev = vol-&gt;id;</a>
<a name="ln173">	st-&gt;st_ino = node-&gt;vnid;</a>
<a name="ln174">	st-&gt;st_mode = make_mode(vol, node);</a>
<a name="ln175"> </a>
<a name="ln176">	st-&gt;st_nlink = 1;</a>
<a name="ln177">	st-&gt;st_uid = 0;</a>
<a name="ln178">	st-&gt;st_gid = 0;</a>
<a name="ln179">	st-&gt;st_size = node-&gt;st_size;</a>
<a name="ln180">	st-&gt;st_blocks = (node-&gt;st_size + 511) / 512;</a>
<a name="ln181">	st-&gt;st_blksize = 0x10000; /* this value was chosen arbitrarily */</a>
<a name="ln182">	st-&gt;st_atim.tv_sec = st-&gt;st_mtim.tv_sec = st-&gt;st_ctim.tv_sec</a>
<a name="ln183">		= node-&gt;st_time;</a>
<a name="ln184">	st-&gt;st_crtim.tv_sec = node-&gt;st_crtim;</a>
<a name="ln185">	st-&gt;st_atim.tv_nsec = st-&gt;st_mtim.tv_nsec = st-&gt;st_ctim.tv_nsec</a>
<a name="ln186">		= st-&gt;st_crtim.tv_nsec = 0;</a>
<a name="ln187"> </a>
<a name="ln188">	UNLOCK_VOL(vol);</a>
<a name="ln189"> </a>
<a name="ln190">	return B_NO_ERROR;</a>
<a name="ln191">}</a>
<a name="ln192"> </a>
<a name="ln193"> </a>
<a name="ln194">status_t</a>
<a name="ln195">dosfs_wstat(fs_volume *_vol, fs_vnode *_node, const struct stat *st,</a>
<a name="ln196">	uint32 mask)</a>
<a name="ln197">{</a>
<a name="ln198">	int err = B_OK;</a>
<a name="ln199">	nspace	*vol = (nspace*)_vol-&gt;private_volume;</a>
<a name="ln200">	vnode	*node = (vnode*)_node-&gt;private_node;</a>
<a name="ln201">	bool dirty = false;</a>
<a name="ln202"> </a>
<a name="ln203">	LOCK_VOL(vol);</a>
<a name="ln204"> </a>
<a name="ln205">	DPRINTF(0, (&quot;dosfs_wstat (vnode id %&quot; B_PRIdINO &quot;)\n&quot;, node-&gt;vnid));</a>
<a name="ln206"> </a>
<a name="ln207">	if (vol-&gt;flags &amp; B_FS_IS_READONLY) {</a>
<a name="ln208">		dprintf(&quot;can't wstat on read-only volume\n&quot;);</a>
<a name="ln209">		UNLOCK_VOL(vol);</a>
<a name="ln210">		return EROFS;</a>
<a name="ln211">	}</a>
<a name="ln212"> </a>
<a name="ln213">	if (node-&gt;disk_image == 2) {</a>
<a name="ln214">		dprintf(&quot;can't wstat disk image\n&quot;);</a>
<a name="ln215">		UNLOCK_VOL(vol);</a>
<a name="ln216">		return EPERM;</a>
<a name="ln217">	}</a>
<a name="ln218"> </a>
<a name="ln219">	if ((mask &amp; B_STAT_MODE) != 0) {</a>
<a name="ln220">		DPRINTF(0, (&quot;setting file mode to %o\n&quot;, st-&gt;st_mode));</a>
<a name="ln221">		if (st-&gt;st_mode &amp; S_IWUSR)</a>
<a name="ln222">			node-&gt;mode &amp;= ~FAT_READ_ONLY;</a>
<a name="ln223">		else</a>
<a name="ln224">			node-&gt;mode |= FAT_READ_ONLY;</a>
<a name="ln225">		dirty = true;</a>
<a name="ln226">	}</a>
<a name="ln227"> </a>
<a name="ln228">	if ((mask &amp; B_STAT_SIZE) != 0) {</a>
<a name="ln229">		DPRINTF(0, (&quot;setting file size to %&quot; B_PRIdOFF &quot;\n&quot;, st-&gt;st_size));</a>
<a name="ln230">		if (node-&gt;mode &amp; FAT_SUBDIR) {</a>
<a name="ln231">			dprintf(&quot;dosfs_wstat: can't set file size of directory!\n&quot;);</a>
<a name="ln232">			err = EISDIR;</a>
<a name="ln233">		} else if (st-&gt;st_size &gt; MAX_FILE_SIZE) {</a>
<a name="ln234">			dprintf(&quot;dosfs_wstat: desired file size exceeds fat limit\n&quot;);</a>
<a name="ln235">			err = E2BIG;</a>
<a name="ln236">		} else {</a>
<a name="ln237">			uint32 clusters = (st-&gt;st_size + vol-&gt;bytes_per_sector</a>
<a name="ln238">					* vol-&gt;sectors_per_cluster - 1) / vol-&gt;bytes_per_sector</a>
<a name="ln239">				/ vol-&gt;sectors_per_cluster;</a>
<a name="ln240">			DPRINTF(0, (&quot;setting fat chain length to %&quot; B_PRIu32 &quot; clusters\n&quot;,</a>
<a name="ln241">				clusters));</a>
<a name="ln242">			if ((err = set_fat_chain_length(vol, node, clusters, false))</a>
<a name="ln243">					== B_OK) {</a>
<a name="ln244">				node-&gt;st_size = st-&gt;st_size;</a>
<a name="ln245">				node-&gt;iteration++;</a>
<a name="ln246">				dirty = true;</a>
<a name="ln247">				file_cache_set_size(node-&gt;cache, node-&gt;st_size);</a>
<a name="ln248">				file_map_set_size(node-&gt;file_map, node-&gt;st_size);</a>
<a name="ln249">			}</a>
<a name="ln250">		}</a>
<a name="ln251">	}</a>
<a name="ln252"> </a>
<a name="ln253">	if ((mask &amp; B_STAT_MODIFICATION_TIME) != 0) {</a>
<a name="ln254">		DPRINTF(0, (&quot;setting modification time\n&quot;));</a>
<a name="ln255">		if ((node-&gt;mode &amp; FAT_SUBDIR) == 0)</a>
<a name="ln256">			node-&gt;mode |= FAT_ARCHIVE;</a>
<a name="ln257">		node-&gt;st_time = st-&gt;st_mtime;</a>
<a name="ln258">		dirty = true;</a>
<a name="ln259">	}</a>
<a name="ln260"> </a>
<a name="ln261">	if ((mask &amp; B_STAT_CREATION_TIME) != 0) {</a>
<a name="ln262">		DPRINTF(0, (&quot;setting creation time\n&quot;));</a>
<a name="ln263">		// As a file's modification time is also set when it is created,</a>
<a name="ln264">		// the archive bit should be set automatically.</a>
<a name="ln265">		node-&gt;st_crtim = st-&gt;st_crtime;</a>
<a name="ln266">		dirty = true;</a>
<a name="ln267">	}</a>
<a name="ln268"> </a>
<a name="ln269">	if (dirty) {</a>
<a name="ln270">		write_vnode_entry(vol, node);</a>
<a name="ln271"> </a>
<a name="ln272">		if (vol-&gt;fs_flags &amp; FS_FLAGS_OP_SYNC) {</a>
<a name="ln273">			// sync the filesystem</a>
<a name="ln274">			_dosfs_sync(vol);</a>
<a name="ln275">			node-&gt;dirty = false;</a>
<a name="ln276">		}</a>
<a name="ln277">	}</a>
<a name="ln278"> </a>
<a name="ln279">	if (err != B_OK) DPRINTF(0, (&quot;dosfs_wstat (%s)\n&quot;, strerror(err)));</a>
<a name="ln280"> </a>
<a name="ln281">	UNLOCK_VOL(vol);</a>
<a name="ln282"> </a>
<a name="ln283">	return err;</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286"> </a>
<a name="ln287">status_t</a>
<a name="ln288">dosfs_open(fs_volume *_vol, fs_vnode *_node, int omode, void **_cookie)</a>
<a name="ln289">{</a>
<a name="ln290">	status_t	result = EINVAL;</a>
<a name="ln291">	nspace *vol = (nspace *)_vol-&gt;private_volume;</a>
<a name="ln292">	vnode* 	node = (vnode*)_node-&gt;private_node;</a>
<a name="ln293">	filecookie *cookie;</a>
<a name="ln294"> </a>
<a name="ln295">	*_cookie = NULL;</a>
<a name="ln296"> </a>
<a name="ln297">	LOCK_VOL(vol);</a>
<a name="ln298"> </a>
<a name="ln299">	DPRINTF(0, (&quot;dosfs_open: vnode id %&quot; B_PRIdINO &quot;, omode %o\n&quot;, node-&gt;vnid,</a>
<a name="ln300">		omode));</a>
<a name="ln301"> </a>
<a name="ln302">	if (omode &amp; O_CREAT) {</a>
<a name="ln303">		dprintf(&quot;dosfs_open called with O_CREAT. call dosfs_create instead!\n&quot;);</a>
<a name="ln304">		result = EINVAL;</a>
<a name="ln305">		goto error;</a>
<a name="ln306">	}</a>
<a name="ln307"> </a>
<a name="ln308">	if ((vol-&gt;flags &amp; B_FS_IS_READONLY) ||</a>
<a name="ln309">		(node-&gt;mode &amp; FAT_READ_ONLY) ||</a>
<a name="ln310">		(node-&gt;disk_image != 0) ||</a>
<a name="ln311">		// allow opening directories for ioctl() calls</a>
<a name="ln312">		// and to let BVolume to work</a>
<a name="ln313">		(node-&gt;mode &amp; FAT_SUBDIR)) {</a>
<a name="ln314">		omode = (omode &amp; ~O_RWMASK) | O_RDONLY;</a>
<a name="ln315">	}</a>
<a name="ln316"> </a>
<a name="ln317">	if ((omode &amp; O_TRUNC) &amp;&amp; ((omode &amp; O_RWMASK) == O_RDONLY)) {</a>
<a name="ln318">		DPRINTF(0, (&quot;can't open file for reading with O_TRUNC\n&quot;));</a>
<a name="ln319">		result = EPERM;</a>
<a name="ln320">		goto error;</a>
<a name="ln321">	}</a>
<a name="ln322"> </a>
<a name="ln323">	if (omode &amp; O_TRUNC) {</a>
<a name="ln324">		DPRINTF(0, (&quot;dosfs_open called with O_TRUNC set\n&quot;));</a>
<a name="ln325">		if ((result = set_fat_chain_length(vol, node, 0, false)) != B_OK) {</a>
<a name="ln326">			dprintf(&quot;dosfs_open: error truncating file\n&quot;);</a>
<a name="ln327">			goto error;</a>
<a name="ln328">		}</a>
<a name="ln329">		node-&gt;mode = 0;</a>
<a name="ln330">		node-&gt;st_size = 0;</a>
<a name="ln331">		node-&gt;iteration++;</a>
<a name="ln332">	}</a>
<a name="ln333"> </a>
<a name="ln334">	if ((cookie = calloc(sizeof(filecookie), 1)) == NULL) {</a>
<a name="ln335">		result = ENOMEM;</a>
<a name="ln336">		goto error;</a>
<a name="ln337">	}</a>
<a name="ln338"> </a>
<a name="ln339">	cookie-&gt;mode = omode;</a>
<a name="ln340">	*_cookie = cookie;</a>
<a name="ln341">	result = B_OK;</a>
<a name="ln342"> </a>
<a name="ln343">error:</a>
<a name="ln344">	if (result != B_OK) DPRINTF(0, (&quot;dosfs_open (%s)\n&quot;, strerror(result)));</a>
<a name="ln345"> </a>
<a name="ln346">	UNLOCK_VOL(vol);</a>
<a name="ln347">	return result;</a>
<a name="ln348">}</a>
<a name="ln349"> </a>
<a name="ln350"> </a>
<a name="ln351">status_t</a>
<a name="ln352">dosfs_read(fs_volume *_vol, fs_vnode *_node, void *_cookie, off_t pos,</a>
<a name="ln353">			void *buf, size_t *len)</a>
<a name="ln354">{</a>
<a name="ln355">	nspace	*vol = (nspace *)_vol-&gt;private_volume;</a>
<a name="ln356">	vnode	*node = (vnode *)_node-&gt;private_node;</a>
<a name="ln357">	filecookie *cookie = (filecookie *)_cookie;</a>
<a name="ln358">	int result = B_OK;</a>
<a name="ln359"> </a>
<a name="ln360">	LOCK_VOL(vol);</a>
<a name="ln361"> </a>
<a name="ln362">	if (node-&gt;mode &amp; FAT_SUBDIR) {</a>
<a name="ln363">		DPRINTF(0, (&quot;dosfs_read called on subdirectory %&quot; B_PRIdINO &quot;\n&quot;,</a>
<a name="ln364">			node-&gt;vnid));</a>
<a name="ln365">		*len = 0;</a>
<a name="ln366">		UNLOCK_VOL(vol);</a>
<a name="ln367">		return EISDIR;</a>
<a name="ln368">	}</a>
<a name="ln369"> </a>
<a name="ln370">	DPRINTF(0, (&quot;dosfs_read called %&quot; B_PRIuSIZE &quot; bytes at %&quot; B_PRIdOFF</a>
<a name="ln371">		&quot; (vnode id %&quot; B_PRIdINO &quot;)\n&quot;, *len, pos, node-&gt;vnid));</a>
<a name="ln372"> </a>
<a name="ln373">	result = file_cache_read(node-&gt;cache, cookie, pos, buf, len);</a>
<a name="ln374"> </a>
<a name="ln375">	if (result != B_OK) {</a>
<a name="ln376">		DPRINTF(0, (&quot;dosfs_read (%s)\n&quot;, strerror(result)));</a>
<a name="ln377">	} else {</a>
<a name="ln378">		DPRINTF(0, (&quot;dosfs_read: read %&quot; B_PRIuSIZE &quot; bytes\n&quot;, *len));</a>
<a name="ln379">	}</a>
<a name="ln380">	UNLOCK_VOL(vol);</a>
<a name="ln381"> </a>
<a name="ln382">	return result;</a>
<a name="ln383">}</a>
<a name="ln384"> </a>
<a name="ln385"> </a>
<a name="ln386">status_t</a>
<a name="ln387">dosfs_write(fs_volume *_vol, fs_vnode *_node, void *_cookie, off_t pos,</a>
<a name="ln388">	const void *buf, size_t *len)</a>
<a name="ln389">{</a>
<a name="ln390">	nspace	*vol = (nspace *)_vol-&gt;private_volume;</a>
<a name="ln391">	vnode	*node = (vnode *)_node-&gt;private_node;</a>
<a name="ln392">	filecookie *cookie = (filecookie *)_cookie;</a>
<a name="ln393">	int result = B_OK;</a>
<a name="ln394"> </a>
<a name="ln395">	LOCK_VOL(vol);</a>
<a name="ln396"> </a>
<a name="ln397">	if ((vol-&gt;flags &amp; B_FS_IS_READONLY) != 0) {</a>
<a name="ln398">		UNLOCK_VOL(vol);</a>
<a name="ln399">		return EROFS;</a>
<a name="ln400">	}</a>
<a name="ln401"> </a>
<a name="ln402">	if (node-&gt;mode &amp; FAT_SUBDIR) {</a>
<a name="ln403">		DPRINTF(0, (&quot;dosfs_write called on subdirectory %&quot; B_PRIdINO &quot;\n&quot;,</a>
<a name="ln404">			node-&gt;vnid));</a>
<a name="ln405">		*len = 0;</a>
<a name="ln406">		UNLOCK_VOL(vol);</a>
<a name="ln407">		return EISDIR;</a>
<a name="ln408"> </a>
<a name="ln409">	}</a>
<a name="ln410"> </a>
<a name="ln411">	DPRINTF(0, (&quot;dosfs_write called %&quot; B_PRIuSIZE &quot; bytes at %&quot; B_PRIdOFF</a>
<a name="ln412">		&quot; from buffer at %p (vnode id %&quot; B_PRIdINO &quot;)\n&quot;, *len, pos, buf,</a>
<a name="ln413">		node-&gt;vnid));</a>
<a name="ln414"> </a>
<a name="ln415">	if ((cookie-&gt;mode &amp; O_RWMASK) == O_RDONLY) {</a>
<a name="ln416">		dprintf(&quot;dosfs_write: called on file opened as read-only\n&quot;);</a>
<a name="ln417">		*len = 0;</a>
<a name="ln418">		result = EPERM;</a>
<a name="ln419">		goto bi;</a>
<a name="ln420">	}</a>
<a name="ln421"> </a>
<a name="ln422">	if (pos &lt; 0) pos = 0;</a>
<a name="ln423"> </a>
<a name="ln424">	if (cookie-&gt;mode &amp; O_APPEND) {</a>
<a name="ln425">		pos = node-&gt;st_size;</a>
<a name="ln426">	}</a>
<a name="ln427"> </a>
<a name="ln428">	if (pos &gt;= MAX_FILE_SIZE) {</a>
<a name="ln429">		dprintf(&quot;dosfs_write: write position exceeds fat limits\n&quot;);</a>
<a name="ln430">		*len = 0;</a>
<a name="ln431">		result = E2BIG;</a>
<a name="ln432">		goto bi;</a>
<a name="ln433">	}</a>
<a name="ln434"> </a>
<a name="ln435">	if (pos + *len &gt;= MAX_FILE_SIZE) {</a>
<a name="ln436">		*len = (size_t)(MAX_FILE_SIZE - pos);</a>
<a name="ln437">	}</a>
<a name="ln438"> </a>
<a name="ln439">	// extend file size if needed</a>
<a name="ln440">	if (pos + *len &gt; node-&gt;st_size) {</a>
<a name="ln441">		uint32 clusters = (pos + *len + vol-&gt;bytes_per_sector*vol-&gt;sectors_per_cluster - 1) / vol-&gt;bytes_per_sector / vol-&gt;sectors_per_cluster;</a>
<a name="ln442">		if (node-&gt;st_size &lt;= (clusters - 1) * vol-&gt;sectors_per_cluster * vol-&gt;bytes_per_sector) {</a>
<a name="ln443">			if ((result = set_fat_chain_length(vol, node, clusters, false))</a>
<a name="ln444">					!= B_OK) {</a>
<a name="ln445">				goto bi;</a>
<a name="ln446">			}</a>
<a name="ln447">			node-&gt;iteration++;</a>
<a name="ln448">		}</a>
<a name="ln449">		node-&gt;st_size = pos + *len;</a>
<a name="ln450">		/* needs to be written to disk asap so that later vnid calculations</a>
<a name="ln451">		 * by get_next_dirent are correct</a>
<a name="ln452">		 */</a>
<a name="ln453">		write_vnode_entry(vol, node);</a>
<a name="ln454"> </a>
<a name="ln455">		DPRINTF(0, (&quot;setting file size to %&quot; B_PRIdOFF &quot; (%&quot; B_PRIu32</a>
<a name="ln456">			&quot; clusters)\n&quot;, node-&gt;st_size, clusters));</a>
<a name="ln457">		node-&gt;dirty = true;</a>
<a name="ln458">		file_cache_set_size(node-&gt;cache, node-&gt;st_size);</a>
<a name="ln459">		file_map_set_size(node-&gt;file_map, node-&gt;st_size);</a>
<a name="ln460">	}</a>
<a name="ln461"> </a>
<a name="ln462">	result = file_cache_write(node-&gt;cache, cookie, pos, buf, len);</a>
<a name="ln463"> </a>
<a name="ln464">bi:</a>
<a name="ln465">	if (result != B_OK) {</a>
<a name="ln466">		DPRINTF(0, (&quot;dosfs_write (%s)\n&quot;, strerror(result)));</a>
<a name="ln467">	} else {</a>
<a name="ln468">		DPRINTF(0, (&quot;dosfs_write: wrote %&quot; B_PRIuSIZE &quot; bytes\n&quot;, *len));</a>
<a name="ln469">	}</a>
<a name="ln470">	UNLOCK_VOL(vol);</a>
<a name="ln471"> </a>
<a name="ln472">	return result;</a>
<a name="ln473">}</a>
<a name="ln474"> </a>
<a name="ln475"> </a>
<a name="ln476">status_t</a>
<a name="ln477">dosfs_close(fs_volume *_vol, fs_vnode *_node, void *_cookie)</a>
<a name="ln478">{</a>
<a name="ln479">	nspace	*vol = (nspace *)_vol-&gt;private_volume;</a>
<a name="ln480">	vnode	*node = (vnode *)_node-&gt;private_node;</a>
<a name="ln481"> </a>
<a name="ln482">	LOCK_VOL(vol);</a>
<a name="ln483"> </a>
<a name="ln484">	DPRINTF(0, (&quot;dosfs_close (vnode id %&quot; B_PRIdINO &quot;)\n&quot;, node-&gt;vnid));</a>
<a name="ln485"> </a>
<a name="ln486">	if ((vol-&gt;fs_flags &amp; FS_FLAGS_OP_SYNC) &amp;&amp; node-&gt;dirty) {</a>
<a name="ln487">		_dosfs_sync(vol);</a>
<a name="ln488">		node-&gt;dirty = false;</a>
<a name="ln489">	}</a>
<a name="ln490"> </a>
<a name="ln491">	UNLOCK_VOL(vol);</a>
<a name="ln492"> </a>
<a name="ln493">	return 0;</a>
<a name="ln494">}</a>
<a name="ln495"> </a>
<a name="ln496"> </a>
<a name="ln497">status_t</a>
<a name="ln498">dosfs_free_cookie(fs_volume *_vol, fs_vnode *_node, void *_cookie)</a>
<a name="ln499">{</a>
<a name="ln500">	nspace *vol = _vol-&gt;private_volume;</a>
<a name="ln501">	vnode *node = _node-&gt;private_node;</a>
<a name="ln502">	filecookie *cookie = _cookie;</a>
<a name="ln503">	LOCK_VOL(vol);</a>
<a name="ln504"> </a>
<a name="ln505">	DPRINTF(0, (&quot;dosfs_free_cookie (vnode id %&quot; B_PRIdINO &quot;)\n&quot;, node-&gt;vnid));</a>
<a name="ln506"> </a>
<a name="ln507">	free(cookie);</a>
<a name="ln508"> </a>
<a name="ln509">	UNLOCK_VOL(vol);</a>
<a name="ln510"> </a>
<a name="ln511">	return 0;</a>
<a name="ln512">}</a>
<a name="ln513"> </a>
<a name="ln514"> </a>
<a name="ln515">status_t</a>
<a name="ln516">dosfs_create(fs_volume *_vol, fs_vnode *_dir, const char *name, int omode,</a>
<a name="ln517">	int perms, void **_cookie, ino_t *vnid)</a>
<a name="ln518">{</a>
<a name="ln519">	nspace *vol = (nspace *)_vol-&gt;private_volume;</a>
<a name="ln520">	vnode *dir = (vnode *)_dir-&gt;private_node, *file;</a>
<a name="ln521">	filecookie *cookie;</a>
<a name="ln522">	status_t result = EINVAL;</a>
<a name="ln523">	bool dups_exist;</a>
<a name="ln524"> </a>
<a name="ln525">	LOCK_VOL(vol);</a>
<a name="ln526"> </a>
<a name="ln527">	ASSERT(name != NULL);</a>
<a name="ln528">	if (name == NULL) {</a>
<a name="ln529">		dprintf(&quot;dosfs_create called with null name\n&quot;);</a>
<a name="ln530">		UNLOCK_VOL(vol);</a>
<a name="ln531">		return EINVAL;</a>
<a name="ln532">	}</a>
<a name="ln533"> </a>
<a name="ln534">	DPRINTF(0, (&quot;dosfs_create called: %&quot; B_PRIdINO &quot;/%s perms=%o omode=%o\n&quot;,</a>
<a name="ln535">		dir-&gt;vnid, name, perms, omode));</a>
<a name="ln536"> </a>
<a name="ln537">	if (vol-&gt;flags &amp; B_FS_IS_READONLY) {</a>
<a name="ln538">		dprintf(&quot;dosfs_create called on read-only volume\n&quot;);</a>
<a name="ln539">		UNLOCK_VOL(vol);</a>
<a name="ln540">		return EROFS;</a>
<a name="ln541">	}</a>
<a name="ln542"> </a>
<a name="ln543">	// TODO : is it needed ? vfs job ?</a>
<a name="ln544">	/*if (is_vnode_removed(vol-&gt;id, dir-&gt;vnid) &gt; 0) {</a>
<a name="ln545">		dprintf(&quot;dosfs_create() called in removed directory. disallowed.\n&quot;);</a>
<a name="ln546">		UNLOCK_VOL(vol);</a>
<a name="ln547">		return EPERM;</a>
<a name="ln548">	}*/</a>
<a name="ln549"> </a>
<a name="ln550">	if ((omode &amp; O_RWMASK) == O_RDONLY) {</a>
<a name="ln551">		dprintf(&quot;invalid permissions used in creating file\n&quot;);</a>
<a name="ln552">		UNLOCK_VOL(vol);</a>
<a name="ln553">		return EPERM;</a>
<a name="ln554">	}</a>
<a name="ln555"> </a>
<a name="ln556">	// create file cookie; do it here to make cleaning up easier</a>
<a name="ln557">	if ((cookie = calloc(sizeof(filecookie), 1)) == NULL) {</a>
<a name="ln558">		result = ENOMEM;</a>
<a name="ln559">		goto bi;</a>
<a name="ln560">	}</a>
<a name="ln561"> </a>
<a name="ln562">	result = findfile_case_duplicates(vol, dir, name, vnid, &amp;file, &amp;dups_exist);</a>
<a name="ln563">	if (result == B_OK) {</a>
<a name="ln564">		if (omode &amp; O_EXCL) {</a>
<a name="ln565">			dprintf(&quot;exclusive dosfs_create called on existing file %s\n&quot;, name);</a>
<a name="ln566">			put_vnode(_vol, file-&gt;vnid);</a>
<a name="ln567">			result = EEXIST;</a>
<a name="ln568">			goto bi;</a>
<a name="ln569">		}</a>
<a name="ln570"> </a>
<a name="ln571">		if (file-&gt;mode &amp; FAT_SUBDIR) {</a>
<a name="ln572">			dprintf(&quot;can't dosfs_create over an existing subdirectory\n&quot;);</a>
<a name="ln573">			put_vnode(_vol, file-&gt;vnid);</a>
<a name="ln574">			result = EPERM;</a>
<a name="ln575">			goto bi;</a>
<a name="ln576">		}</a>
<a name="ln577"> </a>
<a name="ln578">		if (file-&gt;disk_image) {</a>
<a name="ln579">			dprintf(&quot;can't dosfs_create over a disk image\n&quot;);</a>
<a name="ln580">			put_vnode(_vol, file-&gt;vnid);</a>
<a name="ln581">			result = EPERM;</a>
<a name="ln582">			goto bi;</a>
<a name="ln583">		}</a>
<a name="ln584"> </a>
<a name="ln585">		if (omode &amp; O_TRUNC) {</a>
<a name="ln586">			set_fat_chain_length(vol, file, 0, false);</a>
<a name="ln587">			file-&gt;st_size = 0;</a>
<a name="ln588">			file-&gt;iteration++;</a>
<a name="ln589">		}</a>
<a name="ln590">	} else if (result == ENOENT &amp;&amp; dups_exist) {</a>
<a name="ln591">		// the file doesn't exist in the exact case, but another does in the</a>
<a name="ln592">		// non-exact case. We wont create the new file.</a>
<a name="ln593">		result = EEXIST;</a>
<a name="ln594">		goto bi;</a>
<a name="ln595">	} else if (result == ENOENT &amp;&amp; !dups_exist) {</a>
<a name="ln596">		// the file doesn't already exist in any case</a>
<a name="ln597">		vnode dummy; /* used only to create directory entry */</a>
<a name="ln598"> </a>
<a name="ln599">		dummy.dir_vnid = dir-&gt;vnid;</a>
<a name="ln600">		dummy.cluster = 0;</a>
<a name="ln601">		dummy.end_cluster = 0;</a>
<a name="ln602">		dummy.mode = 0;</a>
<a name="ln603">		dummy.st_size = 0;</a>
<a name="ln604">		time(&amp;(dummy.st_time));</a>
<a name="ln605">		dummy.st_crtim = dummy.st_time;</a>
<a name="ln606"> </a>
<a name="ln607">		if ((result = create_dir_entry(vol, dir, &amp;dummy, name, &amp;(dummy.sindex), &amp;(dummy.eindex))) != B_OK) {</a>
<a name="ln608">			dprintf(&quot;dosfs_create: error creating directory entry for %s (%s)\n&quot;, name, strerror(result));</a>
<a name="ln609">			goto bi;</a>
<a name="ln610">		}</a>
<a name="ln611">		dummy.vnid = GENERATE_DIR_INDEX_VNID(dummy.dir_vnid, dummy.sindex);</a>
<a name="ln612">		// XXX: dangerous construct</a>
<a name="ln613">		if (find_vnid_in_vcache(vol, dummy.vnid) == B_OK) {</a>
<a name="ln614">			dummy.vnid = generate_unique_vnid(vol);</a>
<a name="ln615">			if ((result = add_to_vcache(vol, dummy.vnid, GENERATE_DIR_INDEX_VNID(dummy.dir_vnid, dummy.sindex))) &lt; 0) {</a>
<a name="ln616">				// XXX: should remove entry on failure</a>
<a name="ln617">				if (vol-&gt;fs_flags &amp; FS_FLAGS_OP_SYNC)</a>
<a name="ln618">					_dosfs_sync(vol);</a>
<a name="ln619">				goto bi;</a>
<a name="ln620">			}</a>
<a name="ln621">		}</a>
<a name="ln622">		*vnid = dummy.vnid;</a>
<a name="ln623"> </a>
<a name="ln624">		result = get_vnode(_vol, *vnid, (void **)&amp;file);</a>
<a name="ln625">		if (result &lt; B_OK) {</a>
<a name="ln626">			if (vol-&gt;fs_flags &amp; FS_FLAGS_OP_SYNC)</a>
<a name="ln627">				_dosfs_sync(vol);</a>
<a name="ln628">			goto bi;</a>
<a name="ln629">		}</a>
<a name="ln630">	} else {</a>
<a name="ln631">		goto bi;</a>
<a name="ln632">	}</a>
<a name="ln633"> </a>
<a name="ln634">	cookie-&gt;mode = omode;</a>
<a name="ln635">	*_cookie = cookie;</a>
<a name="ln636"> </a>
<a name="ln637">	notify_entry_created(vol-&gt;id, dir-&gt;vnid, name, *vnid);</a>
<a name="ln638"> </a>
<a name="ln639">	result = 0;</a>
<a name="ln640"> </a>
<a name="ln641">	if (vol-&gt;fs_flags &amp; FS_FLAGS_OP_SYNC)</a>
<a name="ln642">		_dosfs_sync(vol);</a>
<a name="ln643"> </a>
<a name="ln644">bi:	if (result != B_OK) free(cookie);</a>
<a name="ln645"> </a>
<a name="ln646">	UNLOCK_VOL(vol);</a>
<a name="ln647"> </a>
<a name="ln648">	if (result != B_OK) DPRINTF(0, (&quot;dosfs_create (%s)\n&quot;, strerror(result)));</a>
<a name="ln649"> </a>
<a name="ln650">	return result;</a>
<a name="ln651">}</a>
<a name="ln652"> </a>
<a name="ln653"> </a>
<a name="ln654">status_t</a>
<a name="ln655">dosfs_mkdir(fs_volume *_vol, fs_vnode *_dir, const char *name, int perms)</a>
<a name="ln656">{</a>
<a name="ln657">	nspace *vol = (nspace *)_vol-&gt;private_volume;</a>
<a name="ln658">	vnode *dir = (vnode *)_dir-&gt;private_node, dummy;</a>
<a name="ln659">	status_t result = EINVAL;</a>
<a name="ln660">	struct csi csi;</a>
<a name="ln661">	uchar *buffer;</a>
<a name="ln662">	uint32 i;</a>
<a name="ln663"> </a>
<a name="ln664">	LOCK_VOL(vol);</a>
<a name="ln665"> </a>
<a name="ln666">	// TODO : is it needed ? vfs job ?</a>
<a name="ln667">	/*if (is_vnode_removed(vol-&gt;id, dir-&gt;vnid) &gt; 0) {</a>
<a name="ln668">		dprintf(&quot;dosfs_mkdir() called in removed directory. disallowed.\n&quot;);</a>
<a name="ln669">		UNLOCK_VOL(vol);</a>
<a name="ln670">		return EPERM;</a>
<a name="ln671">	}*/</a>
<a name="ln672"> </a>
<a name="ln673">	DPRINTF(0, (&quot;dosfs_mkdir called: %&quot; B_PRIdINO &quot;/%s (perm %o)\n&quot;, dir-&gt;vnid,</a>
<a name="ln674">		name, perms));</a>
<a name="ln675"> </a>
<a name="ln676">	if ((dir-&gt;mode &amp; FAT_SUBDIR) == 0) {</a>
<a name="ln677">		dprintf(&quot;dosfs_mkdir: vnode id %&quot; B_PRIdINO &quot; is not a directory\n&quot;,</a>
<a name="ln678">			dir-&gt;vnid);</a>
<a name="ln679">		UNLOCK_VOL(vol);</a>
<a name="ln680">		return EINVAL;</a>
<a name="ln681">	}</a>
<a name="ln682"> </a>
<a name="ln683">	// S_IFDIR is never set in perms, so we patch it</a>
<a name="ln684">	perms &amp;= ~S_IFMT; perms |= S_IFDIR;</a>
<a name="ln685"> </a>
<a name="ln686">	if (vol-&gt;flags &amp; B_FS_IS_READONLY) {</a>
<a name="ln687">		dprintf(&quot;mkdir called on read-only volume\n&quot;);</a>
<a name="ln688">		UNLOCK_VOL(vol);</a>
<a name="ln689">		return EROFS;</a>
<a name="ln690">	}</a>
<a name="ln691"> </a>
<a name="ln692">	/* only used to create directory entry */</a>
<a name="ln693">	dummy.dir_vnid = dir-&gt;vnid;</a>
<a name="ln694">	if ((result = allocate_n_fat_entries(vol, 1, (int32 *)&amp;(dummy.cluster))) &lt; 0) {</a>
<a name="ln695">		dprintf(&quot;dosfs_mkdir: error allocating space for %s (%s))\n&quot;, name, strerror(result));</a>
<a name="ln696">		goto bi;</a>
<a name="ln697">	}</a>
<a name="ln698">	dummy.end_cluster = dummy.cluster;</a>
<a name="ln699">	dummy.mode = FAT_SUBDIR;</a>
<a name="ln700">	if (!(perms &amp; (S_IWUSR | S_IWGRP | S_IWGRP))) {</a>
<a name="ln701">		dummy.mode |= FAT_READ_ONLY;</a>
<a name="ln702">	}</a>
<a name="ln703">	dummy.st_size = vol-&gt;bytes_per_sector*vol-&gt;sectors_per_cluster;</a>
<a name="ln704">	time(&amp;(dummy.st_time));</a>
<a name="ln705">	dummy.st_crtim = dummy.st_time;</a>
<a name="ln706"> </a>
<a name="ln707">	dummy.vnid = GENERATE_DIR_CLUSTER_VNID(dummy.dir_vnid, dummy.cluster);</a>
<a name="ln708">	// XXX: dangerous construct</a>
<a name="ln709">	if (find_vnid_in_vcache(vol, dummy.vnid) == B_OK) {</a>
<a name="ln710">		dummy.vnid = generate_unique_vnid(vol);</a>
<a name="ln711">		if ((result = add_to_vcache(vol, dummy.vnid, GENERATE_DIR_CLUSTER_VNID(dummy.dir_vnid, dummy.cluster))) &lt; 0)</a>
<a name="ln712">			goto bi2;</a>
<a name="ln713">	}</a>
<a name="ln714"> </a>
<a name="ln715">	if ((result = dlist_add(vol, dummy.vnid)) &lt; 0) {</a>
<a name="ln716">		dprintf(&quot;dosfs_mkdir: error adding directory %s to dlist (%s)\n&quot;, name, strerror(result));</a>
<a name="ln717">		goto bi3;</a>
<a name="ln718">	}</a>
<a name="ln719"> </a>
<a name="ln720">	buffer = malloc(vol-&gt;bytes_per_sector);</a>
<a name="ln721">	if (!buffer) {</a>
<a name="ln722">		result = ENOMEM;</a>
<a name="ln723">		goto bi4;</a>
<a name="ln724">	}</a>
<a name="ln725"> </a>
<a name="ln726">	if ((result = create_dir_entry(vol, dir, &amp;dummy, name, &amp;(dummy.sindex), &amp;(dummy.eindex))) != B_OK) {</a>
<a name="ln727">		dprintf(&quot;dosfs_mkdir: error creating directory entry for %s (%s))\n&quot;, name, strerror(result));</a>
<a name="ln728">		goto bi5;</a>
<a name="ln729">	}</a>
<a name="ln730"> </a>
<a name="ln731">	// create '.' and '..' entries and then end of directories</a>
<a name="ln732">	memset(buffer, 0, vol-&gt;bytes_per_sector);</a>
<a name="ln733">	memset(buffer, ' ', 11);</a>
<a name="ln734">	memset(buffer+0x20, ' ', 11);</a>
<a name="ln735">	buffer[0] = buffer[0x20] = buffer[0x21] = '.';</a>
<a name="ln736">	buffer[0x0b] = buffer[0x2b] = FAT_SUBDIR;</a>
<a name="ln737">	i = time_t2dos(dummy.st_time);</a>
<a name="ln738">	buffer[0x0e] = i &amp; 0xff;</a>
<a name="ln739">	buffer[0x0f] = (i &gt;&gt; 8) &amp; 0xff;</a>
<a name="ln740">	buffer[0x10] = (i &gt;&gt; 16) &amp; 0xff;</a>
<a name="ln741">	buffer[0x11] = (i &gt;&gt; 24) &amp; 0xff;</a>
<a name="ln742">	buffer[0x16] = i &amp; 0xff;</a>
<a name="ln743">	buffer[0x17] = (i &gt;&gt; 8) &amp; 0xff;</a>
<a name="ln744">	buffer[0x18] = (i &gt;&gt; 16) &amp; 0xff;</a>
<a name="ln745">	buffer[0x19] = (i &gt;&gt; 24) &amp; 0xff;</a>
<a name="ln746">	i = time_t2dos(dir-&gt;st_crtim);</a>
<a name="ln747">	buffer[0x2e] = i &amp; 0xff;</a>
<a name="ln748">	buffer[0x2f] = (i &gt;&gt; 8) &amp; 0xff;</a>
<a name="ln749">	buffer[0x30] = (i &gt;&gt; 16) &amp; 0xff;</a>
<a name="ln750">	buffer[0x31] = (i &gt;&gt; 24) &amp; 0xff;</a>
<a name="ln751">	i = time_t2dos(dir-&gt;st_time);</a>
<a name="ln752">	buffer[0x36] = i &amp; 0xff;</a>
<a name="ln753">	buffer[0x37] = (i &gt;&gt; 8) &amp; 0xff;</a>
<a name="ln754">	buffer[0x38] = (i &gt;&gt; 16) &amp; 0xff;</a>
<a name="ln755">	buffer[0x39] = (i &gt;&gt; 24) &amp; 0xff;</a>
<a name="ln756">	buffer[0x1a] = dummy.cluster &amp; 0xff;</a>
<a name="ln757">	buffer[0x1b] = (dummy.cluster &gt;&gt; 8) &amp; 0xff;</a>
<a name="ln758">	if (vol-&gt;fat_bits == 32) {</a>
<a name="ln759">		buffer[0x14] = (dummy.cluster &gt;&gt; 16) &amp; 0xff;</a>
<a name="ln760">		buffer[0x15] = (dummy.cluster &gt;&gt; 24) &amp; 0xff;</a>
<a name="ln761">	}</a>
<a name="ln762">	// root directory is always denoted by cluster 0, even for fat32 (!)</a>
<a name="ln763">	if (dir-&gt;vnid != vol-&gt;root_vnode.vnid) {</a>
<a name="ln764">		buffer[0x3a] = dir-&gt;cluster &amp; 0xff;</a>
<a name="ln765">		buffer[0x3b] = (dir-&gt;cluster &gt;&gt; 8) &amp; 0xff;</a>
<a name="ln766">		if (vol-&gt;fat_bits == 32) {</a>
<a name="ln767">			buffer[0x34] = (dir-&gt;cluster &gt;&gt; 16) &amp; 0xff;</a>
<a name="ln768">			buffer[0x35] = (dir-&gt;cluster &gt;&gt; 24) &amp; 0xff;</a>
<a name="ln769">		}</a>
<a name="ln770">	}</a>
<a name="ln771"> </a>
<a name="ln772">	init_csi(vol, dummy.cluster, 0, &amp;csi);</a>
<a name="ln773">	csi_write_block(&amp;csi, buffer);</a>
<a name="ln774"> </a>
<a name="ln775">	// clear out rest of cluster to keep scandisk happy</a>
<a name="ln776">	memset(buffer, 0, vol-&gt;bytes_per_sector);</a>
<a name="ln777">	for (i=1;i&lt;vol-&gt;sectors_per_cluster;i++) {</a>
<a name="ln778">		if (iter_csi(&amp;csi, 1) != B_OK) {</a>
<a name="ln779">			dprintf(&quot;dosfs_mkdir: error writing directory cluster\n&quot;);</a>
<a name="ln780">			break;</a>
<a name="ln781">		}</a>
<a name="ln782">		csi_write_block(&amp;csi, buffer);</a>
<a name="ln783">	}</a>
<a name="ln784"> </a>
<a name="ln785">	free(buffer);</a>
<a name="ln786"> </a>
<a name="ln787">	notify_entry_created(vol-&gt;id, dir-&gt;vnid, name, dummy.vnid);</a>
<a name="ln788"> </a>
<a name="ln789">	result = B_OK;</a>
<a name="ln790"> </a>
<a name="ln791">	if (vol-&gt;fs_flags &amp; FS_FLAGS_OP_SYNC)</a>
<a name="ln792">		_dosfs_sync(vol);</a>
<a name="ln793"> </a>
<a name="ln794">	UNLOCK_VOL(vol);</a>
<a name="ln795">	return result;</a>
<a name="ln796"> </a>
<a name="ln797">bi5:</a>
<a name="ln798">	free(buffer);</a>
<a name="ln799">bi4:</a>
<a name="ln800">	dlist_remove(vol, dummy.vnid);</a>
<a name="ln801">bi3:</a>
<a name="ln802">	if (IS_ARTIFICIAL_VNID(dummy.vnid))</a>
<a name="ln803">		remove_from_vcache(vol, dummy.vnid);</a>
<a name="ln804">bi2:</a>
<a name="ln805">	clear_fat_chain(vol, dummy.cluster, false);</a>
<a name="ln806">	if (vol-&gt;fs_flags &amp; FS_FLAGS_OP_SYNC)</a>
<a name="ln807">		_dosfs_sync(vol);</a>
<a name="ln808">bi:</a>
<a name="ln809">	UNLOCK_VOL(vol);</a>
<a name="ln810">	if (result != B_OK) DPRINTF(0, (&quot;dosfs_mkdir (%s)\n&quot;, strerror(result)));</a>
<a name="ln811">	return result;</a>
<a name="ln812">}</a>
<a name="ln813"> </a>
<a name="ln814"> </a>
<a name="ln815">status_t</a>
<a name="ln816">dosfs_rename(fs_volume *_vol, fs_vnode *_odir, const char *oldname,</a>
<a name="ln817">	fs_vnode *_ndir, const char *newname)</a>
<a name="ln818">{</a>
<a name="ln819">	status_t result = EINVAL;</a>
<a name="ln820">	nspace *vol = (nspace *)_vol-&gt;private_volume;</a>
<a name="ln821">	vnode *odir = (vnode *)_odir-&gt;private_node;</a>
<a name="ln822">	vnode *ndir = (vnode *)_ndir-&gt;private_node;</a>
<a name="ln823">	vnode *file, *file2;</a>
<a name="ln824">	uint32 ns, ne;</a>
<a name="ln825">	bool dups_exist;</a>
<a name="ln826">	bool dirty = false;</a>
<a name="ln827"> </a>
<a name="ln828">	LOCK_VOL(vol);</a>
<a name="ln829"> </a>
<a name="ln830">	DPRINTF(0, (&quot;dosfs_rename called: %&quot; B_PRIdINO &quot;/%s-&gt;%&quot; B_PRIdINO &quot;/%s\n&quot;,</a>
<a name="ln831">		odir-&gt;vnid, oldname, ndir-&gt;vnid, newname));</a>
<a name="ln832"> </a>
<a name="ln833">	if (!oldname || !(*oldname) || !newname || !(*newname)) {</a>
<a name="ln834">		result = EINVAL;</a>
<a name="ln835">		goto bi;</a>
<a name="ln836">	}</a>
<a name="ln837"> </a>
<a name="ln838">	if(!is_filename_legal(newname)) {</a>
<a name="ln839">		dprintf(&quot;dosfs_rename called with invalid name '%s'\n&quot;, newname);</a>
<a name="ln840">		result = EINVAL;</a>
<a name="ln841">		goto bi;</a>
<a name="ln842">	}</a>
<a name="ln843"> </a>
<a name="ln844">	if (vol-&gt;flags &amp; B_FS_IS_READONLY) {</a>
<a name="ln845">		dprintf(&quot;rename called on read-only volume\n&quot;);</a>
<a name="ln846">		result = EROFS;</a>
<a name="ln847">		goto bi;</a>
<a name="ln848">	}</a>
<a name="ln849"> </a>
<a name="ln850">	if ((odir-&gt;vnid == ndir-&gt;vnid) &amp;&amp; !strcmp(oldname, newname)) {</a>
<a name="ln851">		result = EPERM;</a>
<a name="ln852">		goto bi;</a>
<a name="ln853">	}</a>
<a name="ln854"> </a>
<a name="ln855">	// locate the file</a>
<a name="ln856">	if ((result = findfile_case(vol,odir,oldname,NULL,&amp;file)) != B_OK) {</a>
<a name="ln857">		DPRINTF(0, (&quot;dosfs_rename: can't find file %s in directory %&quot; B_PRIdINO</a>
<a name="ln858">			&quot;\n&quot;, oldname, odir-&gt;vnid));</a>
<a name="ln859">		goto bi;</a>
<a name="ln860">	}</a>
<a name="ln861"> </a>
<a name="ln862">	if (file-&gt;disk_image) {</a>
<a name="ln863">		dprintf(&quot;rename called on disk image or disk image directory\n&quot;);</a>
<a name="ln864">		result = EPERM;</a>
<a name="ln865">		goto bi1;</a>
<a name="ln866">	}</a>
<a name="ln867"> </a>
<a name="ln868">	// don't move a directory into one of its children</a>
<a name="ln869">	if (file-&gt;mode &amp; FAT_SUBDIR) {</a>
<a name="ln870">		ino_t vnid = ndir-&gt;vnid;</a>
<a name="ln871">		while (1) {</a>
<a name="ln872">			vnode *dir;</a>
<a name="ln873">			ino_t parent;</a>
<a name="ln874"> </a>
<a name="ln875">			if (vnid == file-&gt;vnid) {</a>
<a name="ln876">				result = EINVAL;</a>
<a name="ln877">				goto bi1;</a>
<a name="ln878">			}</a>
<a name="ln879"> </a>
<a name="ln880">			if (vnid == vol-&gt;root_vnode.vnid)</a>
<a name="ln881">				break;</a>
<a name="ln882"> </a>
<a name="ln883">			result = get_vnode(_vol, vnid, (void **)&amp;dir);</a>
<a name="ln884">			if (result &lt; B_OK)</a>
<a name="ln885">				goto bi1;</a>
<a name="ln886">			parent = dir-&gt;dir_vnid;</a>
<a name="ln887">			put_vnode(_vol, vnid);</a>
<a name="ln888">			vnid = parent;</a>
<a name="ln889">		}</a>
<a name="ln890">	}</a>
<a name="ln891"> </a>
<a name="ln892">	// see if file already exists and erase it if it does</a>
<a name="ln893">	result = findfile_case_duplicates(vol, ndir, newname, NULL, &amp;file2, &amp;dups_exist);</a>
<a name="ln894">	if (result == B_OK) {</a>
<a name="ln895">		if (file2-&gt;mode &amp; FAT_SUBDIR) {</a>
<a name="ln896">			dprintf(&quot;destination already occupied by a directory\n&quot;);</a>
<a name="ln897">			result = EPERM;</a>
<a name="ln898">			goto bi2;</a>
<a name="ln899">		}</a>
<a name="ln900"> </a>
<a name="ln901">		if (file2-&gt;disk_image) {</a>
<a name="ln902">			DPRINTF(0, (&quot;dosfs_rename: can't replace disk image or disk image directory\n&quot;));</a>
<a name="ln903">			result = EPERM;</a>
<a name="ln904">			goto bi2;</a>
<a name="ln905">		}</a>
<a name="ln906">		ns = file2-&gt;sindex; ne = file2-&gt;eindex;</a>
<a name="ln907"> </a>
<a name="ln908">		// let others know the old file is gone</a>
<a name="ln909">		notify_entry_removed(vol-&gt;id, ndir-&gt;vnid, oldname, file2-&gt;vnid);</a>
<a name="ln910"> </a>
<a name="ln911">		// Make sure this vnode 1) is in the vcache and 2) no longer has a</a>
<a name="ln912">		// location associated with it. See discussion in dosfs_unlink()</a>
<a name="ln913">		vcache_set_entry(vol, file2-&gt;vnid, generate_unique_vnid(vol));</a>
<a name="ln914"> </a>
<a name="ln915">		// mark vnode for removal (dosfs_remove_vnode will clear the fat chain)</a>
<a name="ln916">		// note we don't have to lock the file because the fat chain doesn't</a>
<a name="ln917">		// get wiped from the disk until dosfs_remove_vnode() is called; we'll</a>
<a name="ln918">		// have a phantom chain in effect until the last file is closed.</a>
<a name="ln919">		remove_vnode(_vol, file2-&gt;vnid); // must be done in this order</a>
<a name="ln920">		put_vnode(_vol, file2-&gt;vnid);</a>
<a name="ln921"> </a>
<a name="ln922">		dirty = true;</a>
<a name="ln923"> </a>
<a name="ln924">		// erase old directory entry</a>
<a name="ln925">		if ((result = erase_dir_entry(vol, file)) != B_OK) {</a>
<a name="ln926">			dprintf(&quot;dosfs_rename: error erasing old directory entry for %s (%s)\n&quot;, newname, strerror(result));</a>
<a name="ln927">			goto bi1;</a>
<a name="ln928">		}</a>
<a name="ln929">	} else if (result == ENOENT &amp;&amp; (!dups_exist || (odir-&gt;vnid == ndir-&gt;vnid &amp;&amp; !strcasecmp(oldname, newname)))) {</a>
<a name="ln930">		// there isn't an entry and there are no duplicates in the target dir or</a>
<a name="ln931">		// there isn't an entry and the target dir is the same as the source dir and</a>
<a name="ln932">		//   the source and target name are the same, case-insensitively</a>
<a name="ln933"> </a>
<a name="ln934">		// erase old directory entry</a>
<a name="ln935">		if ((result = erase_dir_entry(vol, file)) != B_OK) {</a>
<a name="ln936">			dprintf(&quot;dosfs_rename: error erasing old directory entry for %s (%s)\n&quot;, newname, strerror(result));</a>
<a name="ln937">			goto bi1;</a>
<a name="ln938">		}</a>
<a name="ln939"> </a>
<a name="ln940">		dirty = true;</a>
<a name="ln941"> </a>
<a name="ln942">		// create the new directory entry</a>
<a name="ln943">		if ((result = create_dir_entry(vol, ndir, file, newname, &amp;ns, &amp;ne)) != B_OK) {</a>
<a name="ln944">			dprintf(&quot;dosfs_rename: error creating directory entry for %s\n&quot;, newname);</a>
<a name="ln945">			goto bi1;</a>
<a name="ln946">		}</a>
<a name="ln947">	} else if (result == ENOENT &amp;&amp; dups_exist) {</a>
<a name="ln948">		// the entry doesn't exist but a non-case entry does, so we can't do it</a>
<a name="ln949">		result = EEXIST;</a>
<a name="ln950">		goto bi1;</a>
<a name="ln951">	} else {</a>
<a name="ln952">		goto bi1;</a>
<a name="ln953">	}</a>
<a name="ln954"> </a>
<a name="ln955">	// shrink the directory (an error here is not disastrous)</a>
<a name="ln956">	compact_directory(vol, odir);</a>
<a name="ln957"> </a>
<a name="ln958">	dirty = true;</a>
<a name="ln959"> </a>
<a name="ln960">	// update vnode information</a>
<a name="ln961">	file-&gt;dir_vnid = ndir-&gt;vnid;</a>
<a name="ln962">	file-&gt;sindex = ns;</a>
<a name="ln963">	file-&gt;eindex = ne;</a>
<a name="ln964"> </a>
<a name="ln965">	// update vcache</a>
<a name="ln966">	vcache_set_entry(vol, file-&gt;vnid,</a>
<a name="ln967">			(file-&gt;st_size) ?</a>
<a name="ln968">			GENERATE_DIR_CLUSTER_VNID(file-&gt;dir_vnid, file-&gt;cluster) :</a>
<a name="ln969">			GENERATE_DIR_INDEX_VNID(file-&gt;dir_vnid, file-&gt;sindex));</a>
<a name="ln970"> </a>
<a name="ln971">	// XXX: only write changes in the directory entry if needed</a>
<a name="ln972">	//      (i.e. old entry, not new)</a>
<a name="ln973">	write_vnode_entry(vol, file);</a>
<a name="ln974"> </a>
<a name="ln975">	if (file-&gt;mode &amp; FAT_SUBDIR) {</a>
<a name="ln976">		// update '..' directory entry if needed</a>
<a name="ln977">		// this should most properly be in write_vnode, but it is safe</a>
<a name="ln978">		// to keep it here since this is the only way the cluster of</a>
<a name="ln979">		// the parent can change.</a>
<a name="ln980">		struct diri diri;</a>
<a name="ln981">		uint8 *buffer;</a>
<a name="ln982">		if ((buffer = diri_init(vol, file-&gt;cluster, 1, &amp;diri)) == NULL) {</a>
<a name="ln983">			dprintf(&quot;error opening directory :(\n&quot;);</a>
<a name="ln984">			result = EIO;</a>
<a name="ln985">			goto bi2;</a>
<a name="ln986">		}</a>
<a name="ln987"> </a>
<a name="ln988">		diri_make_writable(&amp;diri);</a>
<a name="ln989"> </a>
<a name="ln990">		if (memcmp(buffer, &quot;..         &quot;, 11)) {</a>
<a name="ln991">			dprintf(&quot;invalid directory :(\n&quot;);</a>
<a name="ln992">			result = EIO;</a>
<a name="ln993">			goto bi2;</a>
<a name="ln994">		}</a>
<a name="ln995">		if (ndir-&gt;vnid == vol-&gt;root_vnode.vnid) {</a>
<a name="ln996">			// root directory always has cluster = 0</a>
<a name="ln997">			buffer[0x1a] = buffer[0x1b] = 0;</a>
<a name="ln998">		} else {</a>
<a name="ln999">			buffer[0x1a] = ndir-&gt;cluster &amp; 0xff;</a>
<a name="ln1000">			buffer[0x1b] = (ndir-&gt;cluster &gt;&gt; 8) &amp; 0xff;</a>
<a name="ln1001">			if (vol-&gt;fat_bits == 32) {</a>
<a name="ln1002">				buffer[0x14] = (ndir-&gt;cluster &gt;&gt; 16) &amp; 0xff;</a>
<a name="ln1003">				buffer[0x15] = (ndir-&gt;cluster &gt;&gt; 24) &amp; 0xff;</a>
<a name="ln1004">			}</a>
<a name="ln1005">		}</a>
<a name="ln1006">		diri_free(&amp;diri);</a>
<a name="ln1007">	}</a>
<a name="ln1008"> </a>
<a name="ln1009">#if TRACK_FILENAME</a>
<a name="ln1010">	if (file-&gt;filename) free(file-&gt;filename);</a>
<a name="ln1011">	file-&gt;filename = malloc(strlen(newname) + 1);</a>
<a name="ln1012">	if (file-&gt;filename) strcpy(file-&gt;filename, newname);</a>
<a name="ln1013">#endif</a>
<a name="ln1014"> </a>
<a name="ln1015">	notify_entry_moved(vol-&gt;id, odir-&gt;vnid, oldname, ndir-&gt;vnid, newname,</a>
<a name="ln1016">		file-&gt;vnid);</a>
<a name="ln1017"> </a>
<a name="ln1018">	// update MIME information</a>
<a name="ln1019">	if(!(file-&gt;mode &amp; FAT_SUBDIR)) {</a>
<a name="ln1020">		set_mime_type(file, newname);</a>
<a name="ln1021">		notify_attribute_changed(vol-&gt;id, -1, file-&gt;vnid, &quot;BEOS:TYPE&quot;,</a>
<a name="ln1022">			B_ATTR_CHANGED);</a>
<a name="ln1023">	}</a>
<a name="ln1024"> </a>
<a name="ln1025">	result = 0;</a>
<a name="ln1026"> </a>
<a name="ln1027">bi2:</a>
<a name="ln1028">	if (result != B_OK)</a>
<a name="ln1029">		put_vnode(_vol, file2-&gt;vnid);</a>
<a name="ln1030">bi1:</a>
<a name="ln1031">	put_vnode(_vol, file-&gt;vnid);</a>
<a name="ln1032">bi:</a>
<a name="ln1033">	if ((vol-&gt;fs_flags &amp; FS_FLAGS_OP_SYNC) &amp;&amp; dirty)</a>
<a name="ln1034">		_dosfs_sync(vol);</a>
<a name="ln1035">	UNLOCK_VOL(vol);</a>
<a name="ln1036">	if (result != B_OK) DPRINTF(0, (&quot;dosfs_rename (%s)\n&quot;, strerror(result)));</a>
<a name="ln1037">	return result;</a>
<a name="ln1038">}</a>
<a name="ln1039"> </a>
<a name="ln1040"> </a>
<a name="ln1041">status_t</a>
<a name="ln1042">dosfs_remove_vnode(fs_volume *_vol, fs_vnode *_node, bool reenter)</a>
<a name="ln1043">{</a>
<a name="ln1044">	nspace *vol = (nspace *)_vol-&gt;private_volume;</a>
<a name="ln1045">	vnode *node = (vnode *)_node-&gt;private_node;</a>
<a name="ln1046"> </a>
<a name="ln1047">	LOCK_VOL(vol);</a>
<a name="ln1048"> </a>
<a name="ln1049">	DPRINTF(0, (&quot;dosfs_remove_vnode (%&quot; B_PRIdINO &quot;)\n&quot;, node-&gt;vnid));</a>
<a name="ln1050"> </a>
<a name="ln1051">	if (vol-&gt;flags &amp; B_FS_IS_READONLY) {</a>
<a name="ln1052">		dprintf(&quot;dosfs_remove_vnode: read-only volume\n&quot;);</a>
<a name="ln1053">		UNLOCK_VOL(vol);</a>
<a name="ln1054">		return EROFS;</a>
<a name="ln1055">	}</a>
<a name="ln1056"> </a>
<a name="ln1057">	// clear the fat chain</a>
<a name="ln1058">	ASSERT((node-&gt;cluster == 0) || IS_DATA_CLUSTER(node-&gt;cluster));</a>
<a name="ln1059">	/* XXX: the following assertion was tripped */</a>
<a name="ln1060">	ASSERT((node-&gt;cluster != 0) || (node-&gt;st_size == 0));</a>
<a name="ln1061">	if (node-&gt;cluster != 0)</a>
<a name="ln1062">		clear_fat_chain(vol, node-&gt;cluster, (node-&gt;mode &amp; FAT_SUBDIR) != 0);</a>
<a name="ln1063"> </a>
<a name="ln1064">	/* remove vnode id from the cache */</a>
<a name="ln1065">	if (find_vnid_in_vcache(vol, node-&gt;vnid) == B_OK)</a>
<a name="ln1066">		remove_from_vcache(vol, node-&gt;vnid);</a>
<a name="ln1067"> </a>
<a name="ln1068">	/* at this point, the node shouldn't be in the dlist anymore */</a>
<a name="ln1069">	if ((node-&gt;mode &amp; FAT_SUBDIR) != 0) {</a>
<a name="ln1070">		ASSERT(dlist_find(vol, CLUSTER_OF_DIR_CLUSTER_VNID(node-&gt;vnid)) == -1);</a>
<a name="ln1071">	}</a>
<a name="ln1072"> </a>
<a name="ln1073">	free(node);</a>
<a name="ln1074"> </a>
<a name="ln1075">	if (!reenter &amp;&amp; vol-&gt;fs_flags &amp; FS_FLAGS_OP_SYNC) {</a>
<a name="ln1076">		// sync the entire filesystem,</a>
<a name="ln1077">		// but only if we're not reentrant. Presumably the</a>
<a name="ln1078">		// function that called this will sync.</a>
<a name="ln1079">		_dosfs_sync(vol);</a>
<a name="ln1080">	}</a>
<a name="ln1081"> </a>
<a name="ln1082">	UNLOCK_VOL(vol);</a>
<a name="ln1083"> </a>
<a name="ln1084">	return B_OK;</a>
<a name="ln1085">}</a>
<a name="ln1086"> </a>
<a name="ln1087"> </a>
<a name="ln1088">// get rid of node or directory</a>
<a name="ln1089">static status_t</a>
<a name="ln1090">do_unlink(fs_volume *_vol, fs_vnode *_dir, const char *name, bool is_file)</a>
<a name="ln1091">{</a>
<a name="ln1092">	status_t result = EINVAL;</a>
<a name="ln1093">	nspace *vol = (nspace *)_vol-&gt;private_volume;</a>
<a name="ln1094">	vnode *dir = (vnode *)_dir-&gt;private_node, *file;</a>
<a name="ln1095">	ino_t vnid;</a>
<a name="ln1096"> </a>
<a name="ln1097">	if (!strcmp(name, &quot;.&quot;))</a>
<a name="ln1098">		return EPERM;</a>
<a name="ln1099"> </a>
<a name="ln1100">	if (!strcmp(name, &quot;..&quot;))</a>
<a name="ln1101">		return EPERM;</a>
<a name="ln1102"> </a>
<a name="ln1103">	LOCK_VOL(vol);</a>
<a name="ln1104"> </a>
<a name="ln1105">	DPRINTF(0, (&quot;do_unlink %&quot; B_PRIdINO &quot;/%s\n&quot;, dir-&gt;vnid, name));</a>
<a name="ln1106"> </a>
<a name="ln1107">	if (vol-&gt;flags &amp; B_FS_IS_READONLY) {</a>
<a name="ln1108">		dprintf(&quot;do_unlink: read-only volume\n&quot;);</a>
<a name="ln1109">		result = EROFS;</a>
<a name="ln1110">		goto bi;</a>
<a name="ln1111">	}</a>
<a name="ln1112"> </a>
<a name="ln1113">	// locate the file</a>
<a name="ln1114">	if ((result = findfile_case(vol,dir,name,&amp;vnid,&amp;file)) != B_OK) {</a>
<a name="ln1115">		DPRINTF(0, (&quot;do_unlink: can't find file %s in directory %&quot; B_PRIdINO</a>
<a name="ln1116">			&quot;\n&quot;, name, dir-&gt;vnid));</a>
<a name="ln1117">		result = ENOENT;</a>
<a name="ln1118">		goto bi;</a>
<a name="ln1119">	}</a>
<a name="ln1120"> </a>
<a name="ln1121">	if (file-&gt;disk_image) {</a>
<a name="ln1122">		DPRINTF(0, (&quot;do_unlink: can't unlink disk image or disk image directory\n&quot;));</a>
<a name="ln1123">		result = EPERM;</a>
<a name="ln1124">		goto bi1;</a>
<a name="ln1125">	}</a>
<a name="ln1126"> </a>
<a name="ln1127">	// don't need to check file permissions because it will be done for us</a>
<a name="ln1128">	// also don't need to lock the file (see dosfs_rename for reasons why)</a>
<a name="ln1129">	if (is_file) {</a>
<a name="ln1130">		if (file-&gt;mode &amp; FAT_SUBDIR) {</a>
<a name="ln1131">			result = EISDIR;</a>
<a name="ln1132">			goto bi1;</a>
<a name="ln1133">		}</a>
<a name="ln1134">	} else {</a>
<a name="ln1135">		if ((file-&gt;mode &amp; FAT_SUBDIR) == 0) {</a>
<a name="ln1136">			result = ENOTDIR;</a>
<a name="ln1137">			goto bi1;</a>
<a name="ln1138">		}</a>
<a name="ln1139"> </a>
<a name="ln1140">		if (file-&gt;vnid == vol-&gt;root_vnode.vnid) {</a>
<a name="ln1141">			// this actually isn't a problem since the root vnode</a>
<a name="ln1142">			// will always be busy while the volume mounted</a>
<a name="ln1143">			dprintf(&quot;dosfs_rmdir: don't call this on the root directory\n&quot;);</a>
<a name="ln1144">			result = EPERM;</a>
<a name="ln1145">			goto bi1;</a>
<a name="ln1146">		}</a>
<a name="ln1147"> </a>
<a name="ln1148">		if ((result = check_dir_empty(vol, file)) &lt; 0) {</a>
<a name="ln1149">			if (result == ENOTEMPTY) DPRINTF(0, (&quot;dosfs_rmdir called on non-empty directory\n&quot;));</a>
<a name="ln1150">			goto bi1;</a>
<a name="ln1151">		}</a>
<a name="ln1152">	}</a>
<a name="ln1153"> </a>
<a name="ln1154">	// erase the entry in the parent directory</a>
<a name="ln1155">	if ((result = erase_dir_entry(vol, file)) != B_OK)</a>
<a name="ln1156">		goto bi1;</a>
<a name="ln1157"> </a>
<a name="ln1158">	// shrink the parent directory (errors here are not disastrous)</a>
<a name="ln1159">	compact_directory(vol, dir);</a>
<a name="ln1160"> </a>
<a name="ln1161">	notify_entry_removed(vol-&gt;id, dir-&gt;vnid, name, file-&gt;vnid);</a>
<a name="ln1162"> </a>
<a name="ln1163">	/* Set the loc to a unique value. This effectively removes it from the</a>
<a name="ln1164">	 * vcache without releasing its vnid for reuse. It also nicely reserves</a>
<a name="ln1165">	 * the vnid from use by other nodes. This is okay because the vnode is</a>
<a name="ln1166">	 * locked in memory after this point and loc will not be referenced from</a>
<a name="ln1167">	 * here on.</a>
<a name="ln1168">	 */</a>
<a name="ln1169">	vcache_set_entry(vol, file-&gt;vnid, generate_unique_vnid(vol));</a>
<a name="ln1170"> </a>
<a name="ln1171">	if (!is_file)</a>
<a name="ln1172">		dlist_remove(vol, file-&gt;vnid);</a>
<a name="ln1173"> </a>
<a name="ln1174">	// fsil doesn't call dosfs_write_vnode for us, so we have to free the</a>
<a name="ln1175">	// vnode manually here.</a>
<a name="ln1176">	remove_vnode(_vol, file-&gt;vnid);</a>
<a name="ln1177"> </a>
<a name="ln1178">	result = 0;</a>
<a name="ln1179"> </a>
<a name="ln1180">	if (vol-&gt;fs_flags &amp; FS_FLAGS_OP_SYNC)</a>
<a name="ln1181">		_dosfs_sync(vol);</a>
<a name="ln1182"> </a>
<a name="ln1183">bi1:</a>
<a name="ln1184">	put_vnode(_vol, vnid);		// get 1 free</a>
<a name="ln1185">bi:</a>
<a name="ln1186">	UNLOCK_VOL(vol);</a>
<a name="ln1187"> </a>
<a name="ln1188">	if (result != B_OK) DPRINTF(0, (&quot;do_unlink (%s)\n&quot;, strerror(result)));</a>
<a name="ln1189"> </a>
<a name="ln1190">	return result;</a>
<a name="ln1191">}</a>
<a name="ln1192"> </a>
<a name="ln1193"> </a>
<a name="ln1194">status_t</a>
<a name="ln1195">dosfs_unlink(fs_volume *vol, fs_vnode *dir, const char *name)</a>
<a name="ln1196">{</a>
<a name="ln1197">	DPRINTF(1, (&quot;dosfs_unlink called\n&quot;));</a>
<a name="ln1198"> </a>
<a name="ln1199">	return do_unlink(vol, dir, name, true);</a>
<a name="ln1200">}</a>
<a name="ln1201"> </a>
<a name="ln1202"> </a>
<a name="ln1203">status_t</a>
<a name="ln1204">dosfs_rmdir(fs_volume *vol, fs_vnode *dir, const char *name)</a>
<a name="ln1205">{</a>
<a name="ln1206">	DPRINTF(1, (&quot;dosfs_rmdir called\n&quot;));</a>
<a name="ln1207"> </a>
<a name="ln1208">	return do_unlink(vol, dir, name, false);</a>
<a name="ln1209">}</a>
<a name="ln1210"> </a>
<a name="ln1211"> </a>
<a name="ln1212">bool</a>
<a name="ln1213">dosfs_can_page(fs_volume *_vol, fs_vnode *_node, void *_cookie)</a>
<a name="ln1214">{</a>
<a name="ln1215">	// ToDo: we're obviously not even asked...</a>
<a name="ln1216">	return false;</a>
<a name="ln1217">}</a>
<a name="ln1218"> </a>
<a name="ln1219"> </a>
<a name="ln1220">status_t</a>
<a name="ln1221">dosfs_read_pages(fs_volume *_vol, fs_vnode *_node, void *_cookie, off_t pos,</a>
<a name="ln1222">	const iovec *vecs, size_t count, size_t *_numBytes)</a>
<a name="ln1223">{</a>
<a name="ln1224">	nspace *vol = (nspace *)_vol-&gt;private_volume;</a>
<a name="ln1225">	vnode *node = (vnode *)_node-&gt;private_node;</a>
<a name="ln1226">	uint32 vecIndex = 0;</a>
<a name="ln1227">	size_t vecOffset = 0;</a>
<a name="ln1228">	size_t bytesLeft = *_numBytes;</a>
<a name="ln1229">	status_t status;</a>
<a name="ln1230"> </a>
<a name="ln1231">	if (node-&gt;cache == NULL)</a>
<a name="ln1232">		return(B_BAD_VALUE);</a>
<a name="ln1233"> </a>
<a name="ln1234">	LOCK_VOL(vol);</a>
<a name="ln1235"> </a>
<a name="ln1236">	while (true) {</a>
<a name="ln1237">		struct file_io_vec fileVecs[8];</a>
<a name="ln1238">		size_t fileVecCount = 8;</a>
<a name="ln1239">		bool bufferOverflow;</a>
<a name="ln1240">		size_t bytes = bytesLeft;</a>
<a name="ln1241"> </a>
<a name="ln1242">		status = file_map_translate(node-&gt;file_map, pos, bytesLeft, fileVecs,</a>
<a name="ln1243">			&amp;fileVecCount, 0);</a>
<a name="ln1244">		if (status != B_OK &amp;&amp; status != B_BUFFER_OVERFLOW)</a>
<a name="ln1245">			break;</a>
<a name="ln1246"> </a>
<a name="ln1247">		bufferOverflow = status == B_BUFFER_OVERFLOW;</a>
<a name="ln1248"> </a>
<a name="ln1249">		status = read_file_io_vec_pages(vol-&gt;fd, fileVecs,</a>
<a name="ln1250">			fileVecCount, vecs, count, &amp;vecIndex, &amp;vecOffset, &amp;bytes);</a>
<a name="ln1251">		if (status != B_OK || !bufferOverflow)</a>
<a name="ln1252">			break;</a>
<a name="ln1253"> </a>
<a name="ln1254">		pos += bytes;</a>
<a name="ln1255">		bytesLeft -= bytes;</a>
<a name="ln1256">	}</a>
<a name="ln1257"> </a>
<a name="ln1258">	UNLOCK_VOL(vol);</a>
<a name="ln1259"> </a>
<a name="ln1260">	return status;</a>
<a name="ln1261">}</a>
<a name="ln1262"> </a>
<a name="ln1263"> </a>
<a name="ln1264">status_t</a>
<a name="ln1265">dosfs_write_pages(fs_volume *_vol, fs_vnode *_node, void *_cookie, off_t pos,</a>
<a name="ln1266">	const iovec *vecs, size_t count, size_t *_numBytes)</a>
<a name="ln1267">{</a>
<a name="ln1268">	nspace *vol = (nspace *)_vol-&gt;private_volume;</a>
<a name="ln1269">	vnode *node = (vnode *)_node-&gt;private_node;</a>
<a name="ln1270">	uint32 vecIndex = 0;</a>
<a name="ln1271">	size_t vecOffset = 0;</a>
<a name="ln1272">	size_t bytesLeft = *_numBytes;</a>
<a name="ln1273">	status_t status;</a>
<a name="ln1274"> </a>
<a name="ln1275">	if (node-&gt;cache == NULL)</a>
<a name="ln1276">		return B_BAD_VALUE;</a>
<a name="ln1277"> </a>
<a name="ln1278">	LOCK_VOL(vol);</a>
<a name="ln1279"> </a>
<a name="ln1280">	if ((vol-&gt;flags &amp; B_FS_IS_READONLY) != 0) {</a>
<a name="ln1281">		UNLOCK_VOL(vol);</a>
<a name="ln1282">		return EROFS;</a>
<a name="ln1283">	}</a>
<a name="ln1284"> </a>
<a name="ln1285">	while (true) {</a>
<a name="ln1286">		struct file_io_vec fileVecs[8];</a>
<a name="ln1287">		size_t fileVecCount = 8;</a>
<a name="ln1288">		bool bufferOverflow;</a>
<a name="ln1289">		size_t bytes = bytesLeft;</a>
<a name="ln1290"> </a>
<a name="ln1291">		status = file_map_translate(node-&gt;file_map, pos, bytesLeft, fileVecs,</a>
<a name="ln1292">			&amp;fileVecCount, 0);</a>
<a name="ln1293">		if (status != B_OK &amp;&amp; status != B_BUFFER_OVERFLOW)</a>
<a name="ln1294">			break;</a>
<a name="ln1295"> </a>
<a name="ln1296">		bufferOverflow = status == B_BUFFER_OVERFLOW;</a>
<a name="ln1297"> </a>
<a name="ln1298">		status = write_file_io_vec_pages(vol-&gt;fd, fileVecs,</a>
<a name="ln1299">			fileVecCount, vecs, count, &amp;vecIndex, &amp;vecOffset, &amp;bytes);</a>
<a name="ln1300">		if (status != B_OK || !bufferOverflow)</a>
<a name="ln1301">			break;</a>
<a name="ln1302"> </a>
<a name="ln1303">		pos += bytes;</a>
<a name="ln1304">		bytesLeft -= bytes;</a>
<a name="ln1305">	}</a>
<a name="ln1306"> </a>
<a name="ln1307">	UNLOCK_VOL(vol);</a>
<a name="ln1308"> </a>
<a name="ln1309">	return status;</a>
<a name="ln1310">}</a>
<a name="ln1311"> </a>
<a name="ln1312"> </a>
<a name="ln1313">status_t</a>
<a name="ln1314">dosfs_get_file_map(fs_volume *_vol, fs_vnode *_node, off_t position,</a>
<a name="ln1315">	size_t length, struct file_io_vec *vecs, size_t *_count)</a>
<a name="ln1316">{</a>
<a name="ln1317">	nspace *vol = (nspace *)_vol-&gt;private_volume;</a>
<a name="ln1318">	vnode *node = (vnode *)_node-&gt;private_node;</a>
<a name="ln1319">	struct csi iter;</a>
<a name="ln1320">	status_t result;</a>
<a name="ln1321">	uint32 skipSectors;</a>
<a name="ln1322">	off_t offset;</a>
<a name="ln1323">	size_t index = 0;</a>
<a name="ln1324">	size_t max = *_count;</a>
<a name="ln1325"> </a>
<a name="ln1326">	LOCK_VOL(vol);</a>
<a name="ln1327">	*_count = 0;</a>
<a name="ln1328"> </a>
<a name="ln1329">	if ((node-&gt;mode &amp; FAT_SUBDIR) != 0) {</a>
<a name="ln1330">		DPRINTF(0, (&quot;dosfs_get_file_map called on subdirectory %&quot; B_PRIdINO</a>
<a name="ln1331">			&quot;\n&quot;, node-&gt;vnid));</a>
<a name="ln1332">		UNLOCK_VOL(vol);</a>
<a name="ln1333">		return EISDIR;</a>
<a name="ln1334">	}</a>
<a name="ln1335"> </a>
<a name="ln1336">	DPRINTF(0, (&quot;dosfs_get_file_map called %&quot; B_PRIuSIZE &quot; bytes at %&quot; B_PRIdOFF</a>
<a name="ln1337">		&quot; (vnode id %&quot; B_PRIdINO &quot;)\n&quot;, length, position, node-&gt;vnid));</a>
<a name="ln1338"> </a>
<a name="ln1339">	if (position &lt; 0)</a>
<a name="ln1340">		position = 0;</a>
<a name="ln1341"> </a>
<a name="ln1342">	if (node-&gt;st_size == 0 || length == 0 || position &gt;= node-&gt;st_size) {</a>
<a name="ln1343">		result = B_OK;</a>
<a name="ln1344">		goto bi;</a>
<a name="ln1345">	}</a>
<a name="ln1346"> </a>
<a name="ln1347">	// Truncate to file size, taking overflow into account.</a>
<a name="ln1348">	if (position + length &gt;= node-&gt;st_size || position + length &lt; position)</a>
<a name="ln1349">		length = node-&gt;st_size - position;</a>
<a name="ln1350"> </a>
<a name="ln1351">	result = init_csi(vol, node-&gt;cluster, 0, &amp;iter);</a>
<a name="ln1352">	if (result != B_OK) {</a>
<a name="ln1353">		dprintf(&quot;dosfs_get_file_map: invalid starting cluster (%&quot; B_PRIu32</a>
<a name="ln1354">			&quot;)\n&quot;, node-&gt;cluster);</a>
<a name="ln1355">		result = EIO;</a>
<a name="ln1356">		goto bi;</a>
<a name="ln1357">	}</a>
<a name="ln1358"> </a>
<a name="ln1359">	skipSectors = position / vol-&gt;bytes_per_sector;</a>
<a name="ln1360">	if (skipSectors &gt; 0) {</a>
<a name="ln1361">		result = iter_csi(&amp;iter, skipSectors);</a>
<a name="ln1362">		if (result != B_OK) {</a>
<a name="ln1363">			dprintf(&quot;dosfs_get_file_map: end of file reached (init)\n&quot;);</a>
<a name="ln1364">			result = EIO;</a>
<a name="ln1365">			goto bi;</a>
<a name="ln1366">		}</a>
<a name="ln1367">	}</a>
<a name="ln1368"> </a>
<a name="ln1369">	ASSERT(iter.cluster == get_nth_fat_entry(vol, node-&gt;cluster,</a>
<a name="ln1370">			position / vol-&gt;bytes_per_sector / vol-&gt;sectors_per_cluster));</a>
<a name="ln1371"> </a>
<a name="ln1372">	offset = position % vol-&gt;bytes_per_sector;</a>
<a name="ln1373">	while (length &gt; 0) {</a>
<a name="ln1374">		off_t block = csi_to_block(&amp;iter);</a>
<a name="ln1375">		uint32 sectors = 1;</a>
<a name="ln1376"> </a>
<a name="ln1377">		length -= min(length, vol-&gt;bytes_per_sector - offset);</a>
<a name="ln1378"> </a>
<a name="ln1379">		while (length &gt; 0) {</a>
<a name="ln1380">			result = iter_csi(&amp;iter, 1);</a>
<a name="ln1381">			if (result != B_OK) {</a>
<a name="ln1382">				dprintf(&quot;dosfs_get_file_map: end of file reached\n&quot;);</a>
<a name="ln1383">				result = EIO;</a>
<a name="ln1384">				goto bi;</a>
<a name="ln1385">			}</a>
<a name="ln1386"> </a>
<a name="ln1387">			if (block + sectors != csi_to_block(&amp;iter)) {</a>
<a name="ln1388">				// Disjoint sectors, need to flush and begin a new vector.</a>
<a name="ln1389">				break;</a>
<a name="ln1390">			}</a>
<a name="ln1391"> </a>
<a name="ln1392">			length -= min(length, vol-&gt;bytes_per_sector);</a>
<a name="ln1393">			sectors++;</a>
<a name="ln1394">		}</a>
<a name="ln1395"> </a>
<a name="ln1396">		vecs[index].offset = block * vol-&gt;bytes_per_sector + offset;</a>
<a name="ln1397">		vecs[index].length = sectors * vol-&gt;bytes_per_sector - offset;</a>
<a name="ln1398">		index++;</a>
<a name="ln1399"> </a>
<a name="ln1400">		if (length == 0)</a>
<a name="ln1401">			break;</a>
<a name="ln1402"> </a>
<a name="ln1403">		if (index &gt;= max) {</a>
<a name="ln1404">			// we're out of file_io_vecs; let's bail out</a>
<a name="ln1405">			result = B_BUFFER_OVERFLOW;</a>
<a name="ln1406">			goto bi;</a>
<a name="ln1407">		}</a>
<a name="ln1408"> </a>
<a name="ln1409">		offset = 0;</a>
<a name="ln1410">	}</a>
<a name="ln1411"> </a>
<a name="ln1412">	result = B_OK;</a>
<a name="ln1413">bi:</a>
<a name="ln1414">	*_count = index;</a>
<a name="ln1415"> </a>
<a name="ln1416">	if (result != B_OK) {</a>
<a name="ln1417">		DPRINTF(0, (&quot;dosfs_get_file_map (%s)\n&quot;, strerror(result)));</a>
<a name="ln1418">	}</a>
<a name="ln1419">	UNLOCK_VOL(vol);</a>
<a name="ln1420"> </a>
<a name="ln1421">	return result;</a>
<a name="ln1422">}</a>

</code></pre>
<div class="balloon" rel="140"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'node' pointer was utilized before it was verified against nullptr. Check lines: 140, 146.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
