
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>if_ath_tx.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting</a>
<a name="ln5"> * Copyright (c) 2010-2012 Adrian Chadd, Xenion Pty Ltd</a>
<a name="ln6"> * All rights reserved.</a>
<a name="ln7"> *</a>
<a name="ln8"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln9"> * modification, are permitted provided that the following conditions</a>
<a name="ln10"> * are met:</a>
<a name="ln11"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln12"> *    notice, this list of conditions and the following disclaimer,</a>
<a name="ln13"> *    without modification.</a>
<a name="ln14"> * 2. Redistributions in binary form must reproduce at minimum a disclaimer</a>
<a name="ln15"> *    similar to the &quot;NO WARRANTY&quot; disclaimer below (&quot;Disclaimer&quot;) and any</a>
<a name="ln16"> *    redistribution must be conditioned upon including a substantially</a>
<a name="ln17"> *    similar Disclaimer requirement for further binary redistribution.</a>
<a name="ln18"> *</a>
<a name="ln19"> * NO WARRANTY</a>
<a name="ln20"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</a>
<a name="ln21"> * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</a>
<a name="ln22"> * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY</a>
<a name="ln23"> * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL</a>
<a name="ln24"> * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,</a>
<a name="ln25"> * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</a>
<a name="ln26"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</a>
<a name="ln27"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER</a>
<a name="ln28"> * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</a>
<a name="ln29"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF</a>
<a name="ln30"> * THE POSSIBILITY OF SUCH DAMAGES.</a>
<a name="ln31"> */</a>
<a name="ln32"> </a>
<a name="ln33">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln34">__FBSDID(&quot;$FreeBSD: releng/12.0/sys/dev/ath/if_ath_tx.c 327479 2018-01-02 00:07:28Z adrian $&quot;);</a>
<a name="ln35"> </a>
<a name="ln36">/*</a>
<a name="ln37"> * Driver for the Atheros Wireless LAN controller.</a>
<a name="ln38"> *</a>
<a name="ln39"> * This software is derived from work of Atsushi Onoe; his contribution</a>
<a name="ln40"> * is greatly appreciated.</a>
<a name="ln41"> */</a>
<a name="ln42"> </a>
<a name="ln43">#include &quot;opt_inet.h&quot;</a>
<a name="ln44">#include &quot;opt_ath.h&quot;</a>
<a name="ln45">#include &quot;opt_wlan.h&quot;</a>
<a name="ln46"> </a>
<a name="ln47">#include &lt;sys/param.h&gt;</a>
<a name="ln48">#include &lt;sys/systm.h&gt;</a>
<a name="ln49">#include &lt;sys/sysctl.h&gt;</a>
<a name="ln50">#include &lt;sys/mbuf.h&gt;</a>
<a name="ln51">#include &lt;sys/malloc.h&gt;</a>
<a name="ln52">#include &lt;sys/lock.h&gt;</a>
<a name="ln53">#include &lt;sys/mutex.h&gt;</a>
<a name="ln54">#include &lt;sys/kernel.h&gt;</a>
<a name="ln55">#include &lt;sys/socket.h&gt;</a>
<a name="ln56">#include &lt;sys/sockio.h&gt;</a>
<a name="ln57">#include &lt;sys/errno.h&gt;</a>
<a name="ln58">#include &lt;sys/callout.h&gt;</a>
<a name="ln59">#include &lt;sys/bus.h&gt;</a>
<a name="ln60">#include &lt;sys/endian.h&gt;</a>
<a name="ln61">#include &lt;sys/kthread.h&gt;</a>
<a name="ln62">#include &lt;sys/taskqueue.h&gt;</a>
<a name="ln63">#include &lt;sys/priv.h&gt;</a>
<a name="ln64">#include &lt;sys/ktr.h&gt;</a>
<a name="ln65"> </a>
<a name="ln66">#include &lt;machine/bus.h&gt;</a>
<a name="ln67"> </a>
<a name="ln68">#include &lt;net/if.h&gt;</a>
<a name="ln69">#include &lt;net/if_var.h&gt;</a>
<a name="ln70">#include &lt;net/if_dl.h&gt;</a>
<a name="ln71">#include &lt;net/if_media.h&gt;</a>
<a name="ln72">#include &lt;net/if_types.h&gt;</a>
<a name="ln73">#include &lt;net/if_arp.h&gt;</a>
<a name="ln74">#include &lt;net/ethernet.h&gt;</a>
<a name="ln75">#include &lt;net/if_llc.h&gt;</a>
<a name="ln76"> </a>
<a name="ln77">#include &lt;net80211/ieee80211_var.h&gt;</a>
<a name="ln78">#include &lt;net80211/ieee80211_regdomain.h&gt;</a>
<a name="ln79">#ifdef IEEE80211_SUPPORT_SUPERG</a>
<a name="ln80">#include &lt;net80211/ieee80211_superg.h&gt;</a>
<a name="ln81">#endif</a>
<a name="ln82">#ifdef IEEE80211_SUPPORT_TDMA</a>
<a name="ln83">#include &lt;net80211/ieee80211_tdma.h&gt;</a>
<a name="ln84">#endif</a>
<a name="ln85">#include &lt;net80211/ieee80211_ht.h&gt;</a>
<a name="ln86"> </a>
<a name="ln87">#include &lt;net/bpf.h&gt;</a>
<a name="ln88"> </a>
<a name="ln89">#ifdef INET</a>
<a name="ln90">#include &lt;netinet/in.h&gt;</a>
<a name="ln91">#include &lt;netinet/if_ether.h&gt;</a>
<a name="ln92">#endif</a>
<a name="ln93"> </a>
<a name="ln94">#include &lt;dev/ath/if_athvar.h&gt;</a>
<a name="ln95">#include &lt;dev/ath/ath_hal/ah_devid.h&gt;		/* XXX for softled */</a>
<a name="ln96">#include &lt;dev/ath/ath_hal/ah_diagcodes.h&gt;</a>
<a name="ln97"> </a>
<a name="ln98">#include &lt;dev/ath/if_ath_debug.h&gt;</a>
<a name="ln99"> </a>
<a name="ln100">#ifdef ATH_TX99_DIAG</a>
<a name="ln101">#include &lt;dev/ath/ath_tx99/ath_tx99.h&gt;</a>
<a name="ln102">#endif</a>
<a name="ln103"> </a>
<a name="ln104">#include &lt;dev/ath/if_ath_misc.h&gt;</a>
<a name="ln105">#include &lt;dev/ath/if_ath_tx.h&gt;</a>
<a name="ln106">#include &lt;dev/ath/if_ath_tx_ht.h&gt;</a>
<a name="ln107"> </a>
<a name="ln108">#ifdef	ATH_DEBUG_ALQ</a>
<a name="ln109">#include &lt;dev/ath/if_ath_alq.h&gt;</a>
<a name="ln110">#endif</a>
<a name="ln111"> </a>
<a name="ln112">/*</a>
<a name="ln113"> * How many retries to perform in software</a>
<a name="ln114"> */</a>
<a name="ln115">#define	SWMAX_RETRIES		10</a>
<a name="ln116"> </a>
<a name="ln117">/*</a>
<a name="ln118"> * What queue to throw the non-QoS TID traffic into</a>
<a name="ln119"> */</a>
<a name="ln120">#define	ATH_NONQOS_TID_AC	WME_AC_VO</a>
<a name="ln121"> </a>
<a name="ln122">#if 0</a>
<a name="ln123">static int ath_tx_node_is_asleep(struct ath_softc *sc, struct ath_node *an);</a>
<a name="ln124">#endif</a>
<a name="ln125">static int ath_tx_ampdu_pending(struct ath_softc *sc, struct ath_node *an,</a>
<a name="ln126">    int tid);</a>
<a name="ln127">static int ath_tx_ampdu_running(struct ath_softc *sc, struct ath_node *an,</a>
<a name="ln128">    int tid);</a>
<a name="ln129">static ieee80211_seq ath_tx_tid_seqno_assign(struct ath_softc *sc,</a>
<a name="ln130">    struct ieee80211_node *ni, struct ath_buf *bf, struct mbuf *m0);</a>
<a name="ln131">static int ath_tx_action_frame_override_queue(struct ath_softc *sc,</a>
<a name="ln132">    struct ieee80211_node *ni, struct mbuf *m0, int *tid);</a>
<a name="ln133">static struct ath_buf *</a>
<a name="ln134">ath_tx_retry_clone(struct ath_softc *sc, struct ath_node *an,</a>
<a name="ln135">    struct ath_tid *tid, struct ath_buf *bf);</a>
<a name="ln136"> </a>
<a name="ln137">#ifdef	ATH_DEBUG_ALQ</a>
<a name="ln138">void</a>
<a name="ln139">ath_tx_alq_post(struct ath_softc *sc, struct ath_buf *bf_first)</a>
<a name="ln140">{</a>
<a name="ln141">	struct ath_buf *bf;</a>
<a name="ln142">	int i, n;</a>
<a name="ln143">	const char *ds;</a>
<a name="ln144"> </a>
<a name="ln145">	/* XXX we should skip out early if debugging isn't enabled! */</a>
<a name="ln146">	bf = bf_first;</a>
<a name="ln147"> </a>
<a name="ln148">	while (bf != NULL) {</a>
<a name="ln149">		/* XXX should ensure bf_nseg &gt; 0! */</a>
<a name="ln150">		if (bf-&gt;bf_nseg == 0)</a>
<a name="ln151">			break;</a>
<a name="ln152">		n = ((bf-&gt;bf_nseg - 1) / sc-&gt;sc_tx_nmaps) + 1;</a>
<a name="ln153">		for (i = 0, ds = (const char *) bf-&gt;bf_desc;</a>
<a name="ln154">		    i &lt; n;</a>
<a name="ln155">		    i++, ds += sc-&gt;sc_tx_desclen) {</a>
<a name="ln156">			if_ath_alq_post(&amp;sc-&gt;sc_alq,</a>
<a name="ln157">			    ATH_ALQ_EDMA_TXDESC,</a>
<a name="ln158">			    sc-&gt;sc_tx_desclen,</a>
<a name="ln159">			    ds);</a>
<a name="ln160">		}</a>
<a name="ln161">		bf = bf-&gt;bf_next;</a>
<a name="ln162">	}</a>
<a name="ln163">}</a>
<a name="ln164">#endif /* ATH_DEBUG_ALQ */</a>
<a name="ln165"> </a>
<a name="ln166">/*</a>
<a name="ln167"> * Whether to use the 11n rate scenario functions or not</a>
<a name="ln168"> */</a>
<a name="ln169">static inline int</a>
<a name="ln170">ath_tx_is_11n(struct ath_softc *sc)</a>
<a name="ln171">{</a>
<a name="ln172">	return ((sc-&gt;sc_ah-&gt;ah_magic == 0x20065416) ||</a>
<a name="ln173">		    (sc-&gt;sc_ah-&gt;ah_magic == 0x19741014));</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176">/*</a>
<a name="ln177"> * Obtain the current TID from the given frame.</a>
<a name="ln178"> *</a>
<a name="ln179"> * Non-QoS frames get mapped to a TID so frames consistently</a>
<a name="ln180"> * go on a sensible queue.</a>
<a name="ln181"> */</a>
<a name="ln182">static int</a>
<a name="ln183">ath_tx_gettid(struct ath_softc *sc, const struct mbuf *m0)</a>
<a name="ln184">{</a>
<a name="ln185">	const struct ieee80211_frame *wh;</a>
<a name="ln186"> </a>
<a name="ln187">	wh = mtod(m0, const struct ieee80211_frame *);</a>
<a name="ln188"> </a>
<a name="ln189">	/* Non-QoS: map frame to a TID queue for software queueing */</a>
<a name="ln190">	if (! IEEE80211_QOS_HAS_SEQ(wh))</a>
<a name="ln191">		return (WME_AC_TO_TID(M_WME_GETAC(m0)));</a>
<a name="ln192"> </a>
<a name="ln193">	/* QoS - fetch the TID from the header, ignore mbuf WME */</a>
<a name="ln194">	return (ieee80211_gettid(wh));</a>
<a name="ln195">}</a>
<a name="ln196"> </a>
<a name="ln197">static void</a>
<a name="ln198">ath_tx_set_retry(struct ath_softc *sc, struct ath_buf *bf)</a>
<a name="ln199">{</a>
<a name="ln200">	struct ieee80211_frame *wh;</a>
<a name="ln201"> </a>
<a name="ln202">	wh = mtod(bf-&gt;bf_m, struct ieee80211_frame *);</a>
<a name="ln203">	/* Only update/resync if needed */</a>
<a name="ln204">	if (bf-&gt;bf_state.bfs_isretried == 0) {</a>
<a name="ln205">		wh-&gt;i_fc[1] |= IEEE80211_FC1_RETRY;</a>
<a name="ln206">		bus_dmamap_sync(sc-&gt;sc_dmat, bf-&gt;bf_dmamap,</a>
<a name="ln207">		    BUS_DMASYNC_PREWRITE);</a>
<a name="ln208">	}</a>
<a name="ln209">	bf-&gt;bf_state.bfs_isretried = 1;</a>
<a name="ln210">	bf-&gt;bf_state.bfs_retries ++;</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213">/*</a>
<a name="ln214"> * Determine what the correct AC queue for the given frame</a>
<a name="ln215"> * should be.</a>
<a name="ln216"> *</a>
<a name="ln217"> * For QoS frames, obey the TID.  That way things like</a>
<a name="ln218"> * management frames that are related to a given TID</a>
<a name="ln219"> * are thus serialised with the rest of the TID traffic,</a>
<a name="ln220"> * regardless of net80211 overriding priority.</a>
<a name="ln221"> *</a>
<a name="ln222"> * For non-QoS frames, return the mbuf WMI priority.</a>
<a name="ln223"> *</a>
<a name="ln224"> * This has implications that higher priority non-QoS traffic</a>
<a name="ln225"> * may end up being scheduled before other non-QoS traffic,</a>
<a name="ln226"> * leading to out-of-sequence packets being emitted.</a>
<a name="ln227"> *</a>
<a name="ln228"> * (It'd be nice to log/count this so we can see if it</a>
<a name="ln229"> * really is a problem.)</a>
<a name="ln230"> *</a>
<a name="ln231"> * TODO: maybe we should throw multicast traffic, QoS or</a>
<a name="ln232"> * otherwise, into a separate TX queue?</a>
<a name="ln233"> */</a>
<a name="ln234">static int</a>
<a name="ln235">ath_tx_getac(struct ath_softc *sc, const struct mbuf *m0)</a>
<a name="ln236">{</a>
<a name="ln237">	const struct ieee80211_frame *wh;</a>
<a name="ln238"> </a>
<a name="ln239">	wh = mtod(m0, const struct ieee80211_frame *);</a>
<a name="ln240"> </a>
<a name="ln241">	/*</a>
<a name="ln242">	 * QoS data frame (sequence number or otherwise) -</a>
<a name="ln243">	 * return hardware queue mapping for the underlying</a>
<a name="ln244">	 * TID.</a>
<a name="ln245">	 */</a>
<a name="ln246">	if (IEEE80211_QOS_HAS_SEQ(wh))</a>
<a name="ln247">		return TID_TO_WME_AC(ieee80211_gettid(wh));</a>
<a name="ln248"> </a>
<a name="ln249">	/*</a>
<a name="ln250">	 * Otherwise - return mbuf QoS pri.</a>
<a name="ln251">	 */</a>
<a name="ln252">	return (M_WME_GETAC(m0));</a>
<a name="ln253">}</a>
<a name="ln254"> </a>
<a name="ln255">void</a>
<a name="ln256">ath_txfrag_cleanup(struct ath_softc *sc,</a>
<a name="ln257">	ath_bufhead *frags, struct ieee80211_node *ni)</a>
<a name="ln258">{</a>
<a name="ln259">	struct ath_buf *bf, *next;</a>
<a name="ln260"> </a>
<a name="ln261">	ATH_TXBUF_LOCK_ASSERT(sc);</a>
<a name="ln262"> </a>
<a name="ln263">	TAILQ_FOREACH_SAFE(bf, frags, bf_list, next) {</a>
<a name="ln264">		/* NB: bf assumed clean */</a>
<a name="ln265">		TAILQ_REMOVE(frags, bf, bf_list);</a>
<a name="ln266">		ath_returnbuf_head(sc, bf);</a>
<a name="ln267">		ieee80211_node_decref(ni);</a>
<a name="ln268">	}</a>
<a name="ln269">}</a>
<a name="ln270"> </a>
<a name="ln271">/*</a>
<a name="ln272"> * Setup xmit of a fragmented frame.  Allocate a buffer</a>
<a name="ln273"> * for each frag and bump the node reference count to</a>
<a name="ln274"> * reflect the held reference to be setup by ath_tx_start.</a>
<a name="ln275"> */</a>
<a name="ln276">int</a>
<a name="ln277">ath_txfrag_setup(struct ath_softc *sc, ath_bufhead *frags,</a>
<a name="ln278">	struct mbuf *m0, struct ieee80211_node *ni)</a>
<a name="ln279">{</a>
<a name="ln280">	struct mbuf *m;</a>
<a name="ln281">	struct ath_buf *bf;</a>
<a name="ln282"> </a>
<a name="ln283">	ATH_TXBUF_LOCK(sc);</a>
<a name="ln284">	for (m = m0-&gt;m_nextpkt; m != NULL; m = m-&gt;m_nextpkt) {</a>
<a name="ln285">		/* XXX non-management? */</a>
<a name="ln286">		bf = _ath_getbuf_locked(sc, ATH_BUFTYPE_NORMAL);</a>
<a name="ln287">		if (bf == NULL) {	/* out of buffers, cleanup */</a>
<a name="ln288">			DPRINTF(sc, ATH_DEBUG_XMIT, &quot;%s: no buffer?\n&quot;,</a>
<a name="ln289">			    __func__);</a>
<a name="ln290">			ath_txfrag_cleanup(sc, frags, ni);</a>
<a name="ln291">			break;</a>
<a name="ln292">		}</a>
<a name="ln293">		ieee80211_node_incref(ni);</a>
<a name="ln294">		TAILQ_INSERT_TAIL(frags, bf, bf_list);</a>
<a name="ln295">	}</a>
<a name="ln296">	ATH_TXBUF_UNLOCK(sc);</a>
<a name="ln297"> </a>
<a name="ln298">	return !TAILQ_EMPTY(frags);</a>
<a name="ln299">}</a>
<a name="ln300"> </a>
<a name="ln301">static int</a>
<a name="ln302">ath_tx_dmasetup(struct ath_softc *sc, struct ath_buf *bf, struct mbuf *m0)</a>
<a name="ln303">{</a>
<a name="ln304">	struct mbuf *m;</a>
<a name="ln305">	int error;</a>
<a name="ln306"> </a>
<a name="ln307">	/*</a>
<a name="ln308">	 * Load the DMA map so any coalescing is done.  This</a>
<a name="ln309">	 * also calculates the number of descriptors we need.</a>
<a name="ln310">	 */</a>
<a name="ln311">	error = bus_dmamap_load_mbuf_sg(sc-&gt;sc_dmat, bf-&gt;bf_dmamap, m0,</a>
<a name="ln312">				     bf-&gt;bf_segs, &amp;bf-&gt;bf_nseg,</a>
<a name="ln313">				     BUS_DMA_NOWAIT);</a>
<a name="ln314">	if (error == EFBIG) {</a>
<a name="ln315">		/* XXX packet requires too many descriptors */</a>
<a name="ln316">		bf-&gt;bf_nseg = ATH_MAX_SCATTER + 1;</a>
<a name="ln317">	} else if (error != 0) {</a>
<a name="ln318">		sc-&gt;sc_stats.ast_tx_busdma++;</a>
<a name="ln319">		ieee80211_free_mbuf(m0);</a>
<a name="ln320">		return error;</a>
<a name="ln321">	}</a>
<a name="ln322">	/*</a>
<a name="ln323">	 * Discard null packets and check for packets that</a>
<a name="ln324">	 * require too many TX descriptors.  We try to convert</a>
<a name="ln325">	 * the latter to a cluster.</a>
<a name="ln326">	 */</a>
<a name="ln327">	if (bf-&gt;bf_nseg &gt; ATH_MAX_SCATTER) {		/* too many desc's, linearize */</a>
<a name="ln328">		sc-&gt;sc_stats.ast_tx_linear++;</a>
<a name="ln329">		m = m_collapse(m0, M_NOWAIT, ATH_MAX_SCATTER);</a>
<a name="ln330">		if (m == NULL) {</a>
<a name="ln331">			ieee80211_free_mbuf(m0);</a>
<a name="ln332">			sc-&gt;sc_stats.ast_tx_nombuf++;</a>
<a name="ln333">			return ENOMEM;</a>
<a name="ln334">		}</a>
<a name="ln335">		m0 = m;</a>
<a name="ln336">		error = bus_dmamap_load_mbuf_sg(sc-&gt;sc_dmat, bf-&gt;bf_dmamap, m0,</a>
<a name="ln337">					     bf-&gt;bf_segs, &amp;bf-&gt;bf_nseg,</a>
<a name="ln338">					     BUS_DMA_NOWAIT);</a>
<a name="ln339">		if (error != 0) {</a>
<a name="ln340">			sc-&gt;sc_stats.ast_tx_busdma++;</a>
<a name="ln341">			ieee80211_free_mbuf(m0);</a>
<a name="ln342">			return error;</a>
<a name="ln343">		}</a>
<a name="ln344">		KASSERT(bf-&gt;bf_nseg &lt;= ATH_MAX_SCATTER,</a>
<a name="ln345">		    (&quot;too many segments after defrag; nseg %u&quot;, bf-&gt;bf_nseg));</a>
<a name="ln346">	} else if (bf-&gt;bf_nseg == 0) {		/* null packet, discard */</a>
<a name="ln347">		sc-&gt;sc_stats.ast_tx_nodata++;</a>
<a name="ln348">		ieee80211_free_mbuf(m0);</a>
<a name="ln349">		return EIO;</a>
<a name="ln350">	}</a>
<a name="ln351">	DPRINTF(sc, ATH_DEBUG_XMIT, &quot;%s: m %p len %u\n&quot;,</a>
<a name="ln352">		__func__, m0, m0-&gt;m_pkthdr.len);</a>
<a name="ln353">	bus_dmamap_sync(sc-&gt;sc_dmat, bf-&gt;bf_dmamap, BUS_DMASYNC_PREWRITE);</a>
<a name="ln354">	bf-&gt;bf_m = m0;</a>
<a name="ln355"> </a>
<a name="ln356">	return 0;</a>
<a name="ln357">}</a>
<a name="ln358"> </a>
<a name="ln359">/*</a>
<a name="ln360"> * Chain together segments+descriptors for a frame - 11n or otherwise.</a>
<a name="ln361"> *</a>
<a name="ln362"> * For aggregates, this is called on each frame in the aggregate.</a>
<a name="ln363"> */</a>
<a name="ln364">static void</a>
<a name="ln365">ath_tx_chaindesclist(struct ath_softc *sc, struct ath_desc *ds0,</a>
<a name="ln366">    struct ath_buf *bf, int is_aggr, int is_first_subframe,</a>
<a name="ln367">    int is_last_subframe)</a>
<a name="ln368">{</a>
<a name="ln369">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln370">	char *ds;</a>
<a name="ln371">	int i, bp, dsp;</a>
<a name="ln372">	HAL_DMA_ADDR bufAddrList[4];</a>
<a name="ln373">	uint32_t segLenList[4];</a>
<a name="ln374">	int numTxMaps = 1;</a>
<a name="ln375">	int isFirstDesc = 1;</a>
<a name="ln376"> </a>
<a name="ln377">	/*</a>
<a name="ln378">	 * XXX There's txdma and txdma_mgmt; the descriptor</a>
<a name="ln379">	 * sizes must match.</a>
<a name="ln380">	 */</a>
<a name="ln381">	struct ath_descdma *dd = &amp;sc-&gt;sc_txdma;</a>
<a name="ln382"> </a>
<a name="ln383">	/*</a>
<a name="ln384">	 * Fillin the remainder of the descriptor info.</a>
<a name="ln385">	 */</a>
<a name="ln386"> </a>
<a name="ln387">	/*</a>
<a name="ln388">	 * We need the number of TX data pointers in each descriptor.</a>
<a name="ln389">	 * EDMA and later chips support 4 TX buffers per descriptor;</a>
<a name="ln390">	 * previous chips just support one.</a>
<a name="ln391">	 */</a>
<a name="ln392">	numTxMaps = sc-&gt;sc_tx_nmaps;</a>
<a name="ln393"> </a>
<a name="ln394">	/*</a>
<a name="ln395">	 * For EDMA and later chips ensure the TX map is fully populated</a>
<a name="ln396">	 * before advancing to the next descriptor.</a>
<a name="ln397">	 */</a>
<a name="ln398">	ds = (char *) bf-&gt;bf_desc;</a>
<a name="ln399">	bp = dsp = 0;</a>
<a name="ln400">	bzero(bufAddrList, sizeof(bufAddrList));</a>
<a name="ln401">	bzero(segLenList, sizeof(segLenList));</a>
<a name="ln402">	for (i = 0; i &lt; bf-&gt;bf_nseg; i++) {</a>
<a name="ln403">		bufAddrList[bp] = bf-&gt;bf_segs[i].ds_addr;</a>
<a name="ln404">		segLenList[bp] = bf-&gt;bf_segs[i].ds_len;</a>
<a name="ln405">		bp++;</a>
<a name="ln406"> </a>
<a name="ln407">		/*</a>
<a name="ln408">		 * Go to the next segment if this isn't the last segment</a>
<a name="ln409">		 * and there's space in the current TX map.</a>
<a name="ln410">		 */</a>
<a name="ln411">		if ((i != bf-&gt;bf_nseg - 1) &amp;&amp; (bp &lt; numTxMaps))</a>
<a name="ln412">			continue;</a>
<a name="ln413"> </a>
<a name="ln414">		/*</a>
<a name="ln415">		 * Last segment or we're out of buffer pointers.</a>
<a name="ln416">		 */</a>
<a name="ln417">		bp = 0;</a>
<a name="ln418"> </a>
<a name="ln419">		if (i == bf-&gt;bf_nseg - 1)</a>
<a name="ln420">			ath_hal_settxdesclink(ah, (struct ath_desc *) ds, 0);</a>
<a name="ln421">		else</a>
<a name="ln422">			ath_hal_settxdesclink(ah, (struct ath_desc *) ds,</a>
<a name="ln423">			    bf-&gt;bf_daddr + dd-&gt;dd_descsize * (dsp + 1));</a>
<a name="ln424"> </a>
<a name="ln425">		/*</a>
<a name="ln426">		 * XXX This assumes that bfs_txq is the actual destination</a>
<a name="ln427">		 * hardware queue at this point.  It may not have been</a>
<a name="ln428">		 * assigned, it may actually be pointing to the multicast</a>
<a name="ln429">		 * software TXQ id.  These must be fixed!</a>
<a name="ln430">		 */</a>
<a name="ln431">		ath_hal_filltxdesc(ah, (struct ath_desc *) ds</a>
<a name="ln432">			, bufAddrList</a>
<a name="ln433">			, segLenList</a>
<a name="ln434">			, bf-&gt;bf_descid		/* XXX desc id */</a>
<a name="ln435">			, bf-&gt;bf_state.bfs_tx_queue</a>
<a name="ln436">			, isFirstDesc		/* first segment */</a>
<a name="ln437">			, i == bf-&gt;bf_nseg - 1	/* last segment */</a>
<a name="ln438">			, (struct ath_desc *) ds0	/* first descriptor */</a>
<a name="ln439">		);</a>
<a name="ln440"> </a>
<a name="ln441">		/*</a>
<a name="ln442">		 * Make sure the 11n aggregate fields are cleared.</a>
<a name="ln443">		 *</a>
<a name="ln444">		 * XXX TODO: this doesn't need to be called for</a>
<a name="ln445">		 * aggregate frames; as it'll be called on all</a>
<a name="ln446">		 * sub-frames.  Since the descriptors are in</a>
<a name="ln447">		 * non-cacheable memory, this leads to some</a>
<a name="ln448">		 * rather slow writes on MIPS/ARM platforms.</a>
<a name="ln449">		 */</a>
<a name="ln450">		if (ath_tx_is_11n(sc))</a>
<a name="ln451">			ath_hal_clr11n_aggr(sc-&gt;sc_ah, (struct ath_desc *) ds);</a>
<a name="ln452"> </a>
<a name="ln453">		/*</a>
<a name="ln454">		 * If 11n is enabled, set it up as if it's an aggregate</a>
<a name="ln455">		 * frame.</a>
<a name="ln456">		 */</a>
<a name="ln457">		if (is_last_subframe) {</a>
<a name="ln458">			ath_hal_set11n_aggr_last(sc-&gt;sc_ah,</a>
<a name="ln459">			    (struct ath_desc *) ds);</a>
<a name="ln460">		} else if (is_aggr) {</a>
<a name="ln461">			/*</a>
<a name="ln462">			 * This clears the aggrlen field; so</a>
<a name="ln463">			 * the caller needs to call set_aggr_first()!</a>
<a name="ln464">			 *</a>
<a name="ln465">			 * XXX TODO: don't call this for the first</a>
<a name="ln466">			 * descriptor in the first frame in an</a>
<a name="ln467">			 * aggregate!</a>
<a name="ln468">			 */</a>
<a name="ln469">			ath_hal_set11n_aggr_middle(sc-&gt;sc_ah,</a>
<a name="ln470">			    (struct ath_desc *) ds,</a>
<a name="ln471">			    bf-&gt;bf_state.bfs_ndelim);</a>
<a name="ln472">		}</a>
<a name="ln473">		isFirstDesc = 0;</a>
<a name="ln474">		bf-&gt;bf_lastds = (struct ath_desc *) ds;</a>
<a name="ln475"> </a>
<a name="ln476">		/*</a>
<a name="ln477">		 * Don't forget to skip to the next descriptor.</a>
<a name="ln478">		 */</a>
<a name="ln479">		ds += sc-&gt;sc_tx_desclen;</a>
<a name="ln480">		dsp++;</a>
<a name="ln481"> </a>
<a name="ln482">		/*</a>
<a name="ln483">		 * .. and don't forget to blank these out!</a>
<a name="ln484">		 */</a>
<a name="ln485">		bzero(bufAddrList, sizeof(bufAddrList));</a>
<a name="ln486">		bzero(segLenList, sizeof(segLenList));</a>
<a name="ln487">	}</a>
<a name="ln488">	bus_dmamap_sync(sc-&gt;sc_dmat, bf-&gt;bf_dmamap, BUS_DMASYNC_PREWRITE);</a>
<a name="ln489">}</a>
<a name="ln490"> </a>
<a name="ln491">/*</a>
<a name="ln492"> * Set the rate control fields in the given descriptor based on</a>
<a name="ln493"> * the bf_state fields and node state.</a>
<a name="ln494"> *</a>
<a name="ln495"> * The bfs fields should already be set with the relevant rate</a>
<a name="ln496"> * control information, including whether MRR is to be enabled.</a>
<a name="ln497"> *</a>
<a name="ln498"> * Since the FreeBSD HAL currently sets up the first TX rate</a>
<a name="ln499"> * in ath_hal_setuptxdesc(), this will setup the MRR</a>
<a name="ln500"> * conditionally for the pre-11n chips, and call ath_buf_set_rate</a>
<a name="ln501"> * unconditionally for 11n chips. These require the 11n rate</a>
<a name="ln502"> * scenario to be set if MCS rates are enabled, so it's easier</a>
<a name="ln503"> * to just always call it. The caller can then only set rates 2, 3</a>
<a name="ln504"> * and 4 if multi-rate retry is needed.</a>
<a name="ln505"> */</a>
<a name="ln506">static void</a>
<a name="ln507">ath_tx_set_ratectrl(struct ath_softc *sc, struct ieee80211_node *ni,</a>
<a name="ln508">    struct ath_buf *bf)</a>
<a name="ln509">{</a>
<a name="ln510">	struct ath_rc_series *rc = bf-&gt;bf_state.bfs_rc;</a>
<a name="ln511"> </a>
<a name="ln512">	/* If mrr is disabled, blank tries 1, 2, 3 */</a>
<a name="ln513">	if (! bf-&gt;bf_state.bfs_ismrr)</a>
<a name="ln514">		rc[1].tries = rc[2].tries = rc[3].tries = 0;</a>
<a name="ln515"> </a>
<a name="ln516">#if 0</a>
<a name="ln517">	/*</a>
<a name="ln518">	 * If NOACK is set, just set ntries=1.</a>
<a name="ln519">	 */</a>
<a name="ln520">	else if (bf-&gt;bf_state.bfs_txflags &amp; HAL_TXDESC_NOACK) {</a>
<a name="ln521">		rc[1].tries = rc[2].tries = rc[3].tries = 0;</a>
<a name="ln522">		rc[0].tries = 1;</a>
<a name="ln523">	}</a>
<a name="ln524">#endif</a>
<a name="ln525"> </a>
<a name="ln526">	/*</a>
<a name="ln527">	 * Always call - that way a retried descriptor will</a>
<a name="ln528">	 * have the MRR fields overwritten.</a>
<a name="ln529">	 *</a>
<a name="ln530">	 * XXX TODO: see if this is really needed - setting up</a>
<a name="ln531">	 * the first descriptor should set the MRR fields to 0</a>
<a name="ln532">	 * for us anyway.</a>
<a name="ln533">	 */</a>
<a name="ln534">	if (ath_tx_is_11n(sc)) {</a>
<a name="ln535">		ath_buf_set_rate(sc, ni, bf);</a>
<a name="ln536">	} else {</a>
<a name="ln537">		ath_hal_setupxtxdesc(sc-&gt;sc_ah, bf-&gt;bf_desc</a>
<a name="ln538">			, rc[1].ratecode, rc[1].tries</a>
<a name="ln539">			, rc[2].ratecode, rc[2].tries</a>
<a name="ln540">			, rc[3].ratecode, rc[3].tries</a>
<a name="ln541">		);</a>
<a name="ln542">	}</a>
<a name="ln543">}</a>
<a name="ln544"> </a>
<a name="ln545">/*</a>
<a name="ln546"> * Setup segments+descriptors for an 11n aggregate.</a>
<a name="ln547"> * bf_first is the first buffer in the aggregate.</a>
<a name="ln548"> * The descriptor list must already been linked together using</a>
<a name="ln549"> * bf-&gt;bf_next.</a>
<a name="ln550"> */</a>
<a name="ln551">static void</a>
<a name="ln552">ath_tx_setds_11n(struct ath_softc *sc, struct ath_buf *bf_first)</a>
<a name="ln553">{</a>
<a name="ln554">	struct ath_buf *bf, *bf_prev = NULL;</a>
<a name="ln555">	struct ath_desc *ds0 = bf_first-&gt;bf_desc;</a>
<a name="ln556"> </a>
<a name="ln557">	DPRINTF(sc, ATH_DEBUG_SW_TX_AGGR, &quot;%s: nframes=%d, al=%d\n&quot;,</a>
<a name="ln558">	    __func__, bf_first-&gt;bf_state.bfs_nframes,</a>
<a name="ln559">	    bf_first-&gt;bf_state.bfs_al);</a>
<a name="ln560"> </a>
<a name="ln561">	bf = bf_first;</a>
<a name="ln562"> </a>
<a name="ln563">	if (bf-&gt;bf_state.bfs_txrate0 == 0)</a>
<a name="ln564">		DPRINTF(sc, ATH_DEBUG_SW_TX_AGGR, &quot;%s: bf=%p, txrate0=%d\n&quot;,</a>
<a name="ln565">		    __func__, bf, 0);</a>
<a name="ln566">	if (bf-&gt;bf_state.bfs_rc[0].ratecode == 0)</a>
<a name="ln567">		DPRINTF(sc, ATH_DEBUG_SW_TX_AGGR, &quot;%s: bf=%p, rix0=%d\n&quot;,</a>
<a name="ln568">		    __func__, bf, 0);</a>
<a name="ln569"> </a>
<a name="ln570">	/*</a>
<a name="ln571">	 * Setup all descriptors of all subframes - this will</a>
<a name="ln572">	 * call ath_hal_set11naggrmiddle() on every frame.</a>
<a name="ln573">	 */</a>
<a name="ln574">	while (bf != NULL) {</a>
<a name="ln575">		DPRINTF(sc, ATH_DEBUG_SW_TX_AGGR,</a>
<a name="ln576">		    &quot;%s: bf=%p, nseg=%d, pktlen=%d, seqno=%d\n&quot;,</a>
<a name="ln577">		    __func__, bf, bf-&gt;bf_nseg, bf-&gt;bf_state.bfs_pktlen,</a>
<a name="ln578">		    SEQNO(bf-&gt;bf_state.bfs_seqno));</a>
<a name="ln579"> </a>
<a name="ln580">		/*</a>
<a name="ln581">		 * Setup the initial fields for the first descriptor - all</a>
<a name="ln582">		 * the non-11n specific stuff.</a>
<a name="ln583">		 */</a>
<a name="ln584">		ath_hal_setuptxdesc(sc-&gt;sc_ah, bf-&gt;bf_desc</a>
<a name="ln585">			, bf-&gt;bf_state.bfs_pktlen	/* packet length */</a>
<a name="ln586">			, bf-&gt;bf_state.bfs_hdrlen	/* header length */</a>
<a name="ln587">			, bf-&gt;bf_state.bfs_atype	/* Atheros packet type */</a>
<a name="ln588">			, bf-&gt;bf_state.bfs_txpower	/* txpower */</a>
<a name="ln589">			, bf-&gt;bf_state.bfs_txrate0</a>
<a name="ln590">			, bf-&gt;bf_state.bfs_try0		/* series 0 rate/tries */</a>
<a name="ln591">			, bf-&gt;bf_state.bfs_keyix	/* key cache index */</a>
<a name="ln592">			, bf-&gt;bf_state.bfs_txantenna	/* antenna mode */</a>
<a name="ln593">			, bf-&gt;bf_state.bfs_txflags | HAL_TXDESC_INTREQ	/* flags */</a>
<a name="ln594">			, bf-&gt;bf_state.bfs_ctsrate	/* rts/cts rate */</a>
<a name="ln595">			, bf-&gt;bf_state.bfs_ctsduration	/* rts/cts duration */</a>
<a name="ln596">		);</a>
<a name="ln597"> </a>
<a name="ln598">		/*</a>
<a name="ln599">		 * First descriptor? Setup the rate control and initial</a>
<a name="ln600">		 * aggregate header information.</a>
<a name="ln601">		 */</a>
<a name="ln602">		if (bf == bf_first) {</a>
<a name="ln603">			/*</a>
<a name="ln604">			 * setup first desc with rate and aggr info</a>
<a name="ln605">			 */</a>
<a name="ln606">			ath_tx_set_ratectrl(sc, bf-&gt;bf_node, bf);</a>
<a name="ln607">		}</a>
<a name="ln608"> </a>
<a name="ln609">		/*</a>
<a name="ln610">		 * Setup the descriptors for a multi-descriptor frame.</a>
<a name="ln611">		 * This is both aggregate and non-aggregate aware.</a>
<a name="ln612">		 */</a>
<a name="ln613">		ath_tx_chaindesclist(sc, ds0, bf,</a>
<a name="ln614">		    1, /* is_aggr */</a>
<a name="ln615">		    !! (bf == bf_first), /* is_first_subframe */</a>
<a name="ln616">		    !! (bf-&gt;bf_next == NULL) /* is_last_subframe */</a>
<a name="ln617">		    );</a>
<a name="ln618"> </a>
<a name="ln619">		if (bf == bf_first) {</a>
<a name="ln620">			/*</a>
<a name="ln621">			 * Initialise the first 11n aggregate with the</a>
<a name="ln622">			 * aggregate length and aggregate enable bits.</a>
<a name="ln623">			 */</a>
<a name="ln624">			ath_hal_set11n_aggr_first(sc-&gt;sc_ah,</a>
<a name="ln625">			    ds0,</a>
<a name="ln626">			    bf-&gt;bf_state.bfs_al,</a>
<a name="ln627">			    bf-&gt;bf_state.bfs_ndelim);</a>
<a name="ln628">		}</a>
<a name="ln629"> </a>
<a name="ln630">		/*</a>
<a name="ln631">		 * Link the last descriptor of the previous frame</a>
<a name="ln632">		 * to the beginning descriptor of this frame.</a>
<a name="ln633">		 */</a>
<a name="ln634">		if (bf_prev != NULL)</a>
<a name="ln635">			ath_hal_settxdesclink(sc-&gt;sc_ah, bf_prev-&gt;bf_lastds,</a>
<a name="ln636">			    bf-&gt;bf_daddr);</a>
<a name="ln637"> </a>
<a name="ln638">		/* Save a copy so we can link the next descriptor in */</a>
<a name="ln639">		bf_prev = bf;</a>
<a name="ln640">		bf = bf-&gt;bf_next;</a>
<a name="ln641">	}</a>
<a name="ln642"> </a>
<a name="ln643">	/*</a>
<a name="ln644">	 * Set the first descriptor bf_lastds field to point to</a>
<a name="ln645">	 * the last descriptor in the last subframe, that's where</a>
<a name="ln646">	 * the status update will occur.</a>
<a name="ln647">	 */</a>
<a name="ln648">	bf_first-&gt;bf_lastds = bf_prev-&gt;bf_lastds;</a>
<a name="ln649"> </a>
<a name="ln650">	/*</a>
<a name="ln651">	 * And bf_last in the first descriptor points to the end of</a>
<a name="ln652">	 * the aggregate list.</a>
<a name="ln653">	 */</a>
<a name="ln654">	bf_first-&gt;bf_last = bf_prev;</a>
<a name="ln655"> </a>
<a name="ln656">	/*</a>
<a name="ln657">	 * For non-AR9300 NICs, which require the rate control</a>
<a name="ln658">	 * in the final descriptor - let's set that up now.</a>
<a name="ln659">	 *</a>
<a name="ln660">	 * This is because the filltxdesc() HAL call doesn't</a>
<a name="ln661">	 * populate the last segment with rate control information</a>
<a name="ln662">	 * if firstSeg is also true.  For non-aggregate frames</a>
<a name="ln663">	 * that is fine, as the first frame already has rate control</a>
<a name="ln664">	 * info.  But if the last frame in an aggregate has one</a>
<a name="ln665">	 * descriptor, both firstseg and lastseg will be true and</a>
<a name="ln666">	 * the rate info isn't copied.</a>
<a name="ln667">	 *</a>
<a name="ln668">	 * This is inefficient on MIPS/ARM platforms that have</a>
<a name="ln669">	 * non-cachable memory for TX descriptors, but we'll just</a>
<a name="ln670">	 * make do for now.</a>
<a name="ln671">	 *</a>
<a name="ln672">	 * As to why the rate table is stashed in the last descriptor</a>
<a name="ln673">	 * rather than the first descriptor?  Because proctxdesc()</a>
<a name="ln674">	 * is called on the final descriptor in an MPDU or A-MPDU -</a>
<a name="ln675">	 * ie, the one that gets updated by the hardware upon</a>
<a name="ln676">	 * completion.  That way proctxdesc() doesn't need to know</a>
<a name="ln677">	 * about the first _and_ last TX descriptor.</a>
<a name="ln678">	 */</a>
<a name="ln679">	ath_hal_setuplasttxdesc(sc-&gt;sc_ah, bf_prev-&gt;bf_lastds, ds0);</a>
<a name="ln680"> </a>
<a name="ln681">	DPRINTF(sc, ATH_DEBUG_SW_TX_AGGR, &quot;%s: end\n&quot;, __func__);</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684">/*</a>
<a name="ln685"> * Hand-off a frame to the multicast TX queue.</a>
<a name="ln686"> *</a>
<a name="ln687"> * This is a software TXQ which will be appended to the CAB queue</a>
<a name="ln688"> * during the beacon setup code.</a>
<a name="ln689"> *</a>
<a name="ln690"> * XXX TODO: since the AR9300 EDMA TX queue support wants the QCU ID</a>
<a name="ln691"> * as part of the TX descriptor, bf_state.bfs_tx_queue must be updated</a>
<a name="ln692"> * with the actual hardware txq, or all of this will fall apart.</a>
<a name="ln693"> *</a>
<a name="ln694"> * XXX It may not be a bad idea to just stuff the QCU ID into bf_state</a>
<a name="ln695"> * and retire bfs_tx_queue; then make sure the CABQ QCU ID is populated</a>
<a name="ln696"> * correctly.</a>
<a name="ln697"> */</a>
<a name="ln698">static void</a>
<a name="ln699">ath_tx_handoff_mcast(struct ath_softc *sc, struct ath_txq *txq,</a>
<a name="ln700">    struct ath_buf *bf)</a>
<a name="ln701">{</a>
<a name="ln702">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln703"> </a>
<a name="ln704">	KASSERT((bf-&gt;bf_flags &amp; ATH_BUF_BUSY) == 0,</a>
<a name="ln705">	     (&quot;%s: busy status 0x%x&quot;, __func__, bf-&gt;bf_flags));</a>
<a name="ln706"> </a>
<a name="ln707">	/*</a>
<a name="ln708">	 * Ensure that the tx queue is the cabq, so things get</a>
<a name="ln709">	 * mapped correctly.</a>
<a name="ln710">	 */</a>
<a name="ln711">	if (bf-&gt;bf_state.bfs_tx_queue != sc-&gt;sc_cabq-&gt;axq_qnum) {</a>
<a name="ln712">		DPRINTF(sc, ATH_DEBUG_XMIT,</a>
<a name="ln713">		    &quot;%s: bf=%p, bfs_tx_queue=%d, axq_qnum=%d\n&quot;,</a>
<a name="ln714">		    __func__, bf, bf-&gt;bf_state.bfs_tx_queue,</a>
<a name="ln715">		    txq-&gt;axq_qnum);</a>
<a name="ln716">	}</a>
<a name="ln717"> </a>
<a name="ln718">	ATH_TXQ_LOCK(txq);</a>
<a name="ln719">	if (ATH_TXQ_LAST(txq, axq_q_s) != NULL) {</a>
<a name="ln720">		struct ath_buf *bf_last = ATH_TXQ_LAST(txq, axq_q_s);</a>
<a name="ln721">		struct ieee80211_frame *wh;</a>
<a name="ln722"> </a>
<a name="ln723">		/* mark previous frame */</a>
<a name="ln724">		wh = mtod(bf_last-&gt;bf_m, struct ieee80211_frame *);</a>
<a name="ln725">		wh-&gt;i_fc[1] |= IEEE80211_FC1_MORE_DATA;</a>
<a name="ln726">		bus_dmamap_sync(sc-&gt;sc_dmat, bf_last-&gt;bf_dmamap,</a>
<a name="ln727">		    BUS_DMASYNC_PREWRITE);</a>
<a name="ln728"> </a>
<a name="ln729">		/* link descriptor */</a>
<a name="ln730">		ath_hal_settxdesclink(sc-&gt;sc_ah,</a>
<a name="ln731">		    bf_last-&gt;bf_lastds,</a>
<a name="ln732">		    bf-&gt;bf_daddr);</a>
<a name="ln733">	}</a>
<a name="ln734">	ATH_TXQ_INSERT_TAIL(txq, bf, bf_list);</a>
<a name="ln735">	ATH_TXQ_UNLOCK(txq);</a>
<a name="ln736">}</a>
<a name="ln737"> </a>
<a name="ln738">/*</a>
<a name="ln739"> * Hand-off packet to a hardware queue.</a>
<a name="ln740"> */</a>
<a name="ln741">static void</a>
<a name="ln742">ath_tx_handoff_hw(struct ath_softc *sc, struct ath_txq *txq,</a>
<a name="ln743">    struct ath_buf *bf)</a>
<a name="ln744">{</a>
<a name="ln745">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln746">	struct ath_buf *bf_first;</a>
<a name="ln747"> </a>
<a name="ln748">	/*</a>
<a name="ln749">	 * Insert the frame on the outbound list and pass it on</a>
<a name="ln750">	 * to the hardware.  Multicast frames buffered for power</a>
<a name="ln751">	 * save stations and transmit from the CAB queue are stored</a>
<a name="ln752">	 * on a s/w only queue and loaded on to the CAB queue in</a>
<a name="ln753">	 * the SWBA handler since frames only go out on DTIM and</a>
<a name="ln754">	 * to avoid possible races.</a>
<a name="ln755">	 */</a>
<a name="ln756">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln757">	KASSERT((bf-&gt;bf_flags &amp; ATH_BUF_BUSY) == 0,</a>
<a name="ln758">	     (&quot;%s: busy status 0x%x&quot;, __func__, bf-&gt;bf_flags));</a>
<a name="ln759">	KASSERT(txq-&gt;axq_qnum != ATH_TXQ_SWQ,</a>
<a name="ln760">	     (&quot;ath_tx_handoff_hw called for mcast queue&quot;));</a>
<a name="ln761"> </a>
<a name="ln762">	/*</a>
<a name="ln763">	 * XXX We should instead just verify that sc_txstart_cnt</a>
<a name="ln764">	 * or ath_txproc_cnt &gt; 0.  That would mean that</a>
<a name="ln765">	 * the reset is going to be waiting for us to complete.</a>
<a name="ln766">	 */</a>
<a name="ln767">	if (sc-&gt;sc_txproc_cnt == 0 &amp;&amp; sc-&gt;sc_txstart_cnt == 0) {</a>
<a name="ln768">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln769">		    &quot;%s: TX dispatch without holding txcount/txstart refcnt!\n&quot;,</a>
<a name="ln770">		    __func__);</a>
<a name="ln771">	}</a>
<a name="ln772"> </a>
<a name="ln773">	/*</a>
<a name="ln774">	 * XXX .. this is going to cause the hardware to get upset;</a>
<a name="ln775">	 * so we really should find some way to drop or queue</a>
<a name="ln776">	 * things.</a>
<a name="ln777">	 */</a>
<a name="ln778"> </a>
<a name="ln779">	ATH_TXQ_LOCK(txq);</a>
<a name="ln780"> </a>
<a name="ln781">	/*</a>
<a name="ln782">	 * XXX TODO: if there's a holdingbf, then</a>
<a name="ln783">	 * ATH_TXQ_PUTRUNNING should be clear.</a>
<a name="ln784">	 *</a>
<a name="ln785">	 * If there is a holdingbf and the list is empty,</a>
<a name="ln786">	 * then axq_link should be pointing to the holdingbf.</a>
<a name="ln787">	 *</a>
<a name="ln788">	 * Otherwise it should point to the last descriptor</a>
<a name="ln789">	 * in the last ath_buf.</a>
<a name="ln790">	 *</a>
<a name="ln791">	 * In any case, we should really ensure that we</a>
<a name="ln792">	 * update the previous descriptor link pointer to</a>
<a name="ln793">	 * this descriptor, regardless of all of the above state.</a>
<a name="ln794">	 *</a>
<a name="ln795">	 * For now this is captured by having axq_link point</a>
<a name="ln796">	 * to either the holdingbf (if the TXQ list is empty)</a>
<a name="ln797">	 * or the end of the list (if the TXQ list isn't empty.)</a>
<a name="ln798">	 * I'd rather just kill axq_link here and do it as above.</a>
<a name="ln799">	 */</a>
<a name="ln800"> </a>
<a name="ln801">	/*</a>
<a name="ln802">	 * Append the frame to the TX queue.</a>
<a name="ln803">	 */</a>
<a name="ln804">	ATH_TXQ_INSERT_TAIL(txq, bf, bf_list);</a>
<a name="ln805">	ATH_KTR(sc, ATH_KTR_TX, 3,</a>
<a name="ln806">	    &quot;ath_tx_handoff: non-tdma: txq=%u, add bf=%p &quot;</a>
<a name="ln807">	    &quot;depth=%d&quot;,</a>
<a name="ln808">	    txq-&gt;axq_qnum,</a>
<a name="ln809">	    bf,</a>
<a name="ln810">	    txq-&gt;axq_depth);</a>
<a name="ln811"> </a>
<a name="ln812">	/*</a>
<a name="ln813">	 * If there's a link pointer, update it.</a>
<a name="ln814">	 *</a>
<a name="ln815">	 * XXX we should replace this with the above logic, just</a>
<a name="ln816">	 * to kill axq_link with fire.</a>
<a name="ln817">	 */</a>
<a name="ln818">	if (txq-&gt;axq_link != NULL) {</a>
<a name="ln819">		*txq-&gt;axq_link = bf-&gt;bf_daddr;</a>
<a name="ln820">		DPRINTF(sc, ATH_DEBUG_XMIT,</a>
<a name="ln821">		    &quot;%s: link[%u](%p)=%p (%p) depth %d\n&quot;, __func__,</a>
<a name="ln822">		    txq-&gt;axq_qnum, txq-&gt;axq_link,</a>
<a name="ln823">		    (caddr_t)bf-&gt;bf_daddr, bf-&gt;bf_desc,</a>
<a name="ln824">		    txq-&gt;axq_depth);</a>
<a name="ln825">		ATH_KTR(sc, ATH_KTR_TX, 5,</a>
<a name="ln826">		    &quot;ath_tx_handoff: non-tdma: link[%u](%p)=%p (%p) &quot;</a>
<a name="ln827">		    &quot;lastds=%d&quot;,</a>
<a name="ln828">		    txq-&gt;axq_qnum, txq-&gt;axq_link,</a>
<a name="ln829">		    (caddr_t)bf-&gt;bf_daddr, bf-&gt;bf_desc,</a>
<a name="ln830">		    bf-&gt;bf_lastds);</a>
<a name="ln831">	}</a>
<a name="ln832"> </a>
<a name="ln833">	/*</a>
<a name="ln834">	 * If we've not pushed anything into the hardware yet,</a>
<a name="ln835">	 * push the head of the queue into the TxDP.</a>
<a name="ln836">	 *</a>
<a name="ln837">	 * Once we've started DMA, there's no guarantee that</a>
<a name="ln838">	 * updating the TxDP with a new value will actually work.</a>
<a name="ln839">	 * So we just don't do that - if we hit the end of the list,</a>
<a name="ln840">	 * we keep that buffer around (the &quot;holding buffer&quot;) and</a>
<a name="ln841">	 * re-start DMA by updating the link pointer of _that_</a>
<a name="ln842">	 * descriptor and then restart DMA.</a>
<a name="ln843">	 */</a>
<a name="ln844">	if (! (txq-&gt;axq_flags &amp; ATH_TXQ_PUTRUNNING)) {</a>
<a name="ln845">		bf_first = TAILQ_FIRST(&amp;txq-&gt;axq_q);</a>
<a name="ln846">		txq-&gt;axq_flags |= ATH_TXQ_PUTRUNNING;</a>
<a name="ln847">		ath_hal_puttxbuf(ah, txq-&gt;axq_qnum, bf_first-&gt;bf_daddr);</a>
<a name="ln848">		DPRINTF(sc, ATH_DEBUG_XMIT,</a>
<a name="ln849">		    &quot;%s: TXDP[%u] = %p (%p) depth %d\n&quot;,</a>
<a name="ln850">		    __func__, txq-&gt;axq_qnum,</a>
<a name="ln851">		    (caddr_t)bf_first-&gt;bf_daddr, bf_first-&gt;bf_desc,</a>
<a name="ln852">		    txq-&gt;axq_depth);</a>
<a name="ln853">		ATH_KTR(sc, ATH_KTR_TX, 5,</a>
<a name="ln854">		    &quot;ath_tx_handoff: TXDP[%u] = %p (%p) &quot;</a>
<a name="ln855">		    &quot;lastds=%p depth %d&quot;,</a>
<a name="ln856">		    txq-&gt;axq_qnum,</a>
<a name="ln857">		    (caddr_t)bf_first-&gt;bf_daddr, bf_first-&gt;bf_desc,</a>
<a name="ln858">		    bf_first-&gt;bf_lastds,</a>
<a name="ln859">		    txq-&gt;axq_depth);</a>
<a name="ln860">	}</a>
<a name="ln861"> </a>
<a name="ln862">	/*</a>
<a name="ln863">	 * Ensure that the bf TXQ matches this TXQ, so later</a>
<a name="ln864">	 * checking and holding buffer manipulation is sane.</a>
<a name="ln865">	 */</a>
<a name="ln866">	if (bf-&gt;bf_state.bfs_tx_queue != txq-&gt;axq_qnum) {</a>
<a name="ln867">		DPRINTF(sc, ATH_DEBUG_XMIT,</a>
<a name="ln868">		    &quot;%s: bf=%p, bfs_tx_queue=%d, axq_qnum=%d\n&quot;,</a>
<a name="ln869">		    __func__, bf, bf-&gt;bf_state.bfs_tx_queue,</a>
<a name="ln870">		    txq-&gt;axq_qnum);</a>
<a name="ln871">	}</a>
<a name="ln872"> </a>
<a name="ln873">	/*</a>
<a name="ln874">	 * Track aggregate queue depth.</a>
<a name="ln875">	 */</a>
<a name="ln876">	if (bf-&gt;bf_state.bfs_aggr)</a>
<a name="ln877">		txq-&gt;axq_aggr_depth++;</a>
<a name="ln878"> </a>
<a name="ln879">	/*</a>
<a name="ln880">	 * Update the link pointer.</a>
<a name="ln881">	 */</a>
<a name="ln882">	ath_hal_gettxdesclinkptr(ah, bf-&gt;bf_lastds, &amp;txq-&gt;axq_link);</a>
<a name="ln883"> </a>
<a name="ln884">	/*</a>
<a name="ln885">	 * Start DMA.</a>
<a name="ln886">	 *</a>
<a name="ln887">	 * If we wrote a TxDP above, DMA will start from here.</a>
<a name="ln888">	 *</a>
<a name="ln889">	 * If DMA is running, it'll do nothing.</a>
<a name="ln890">	 *</a>
<a name="ln891">	 * If the DMA engine hit the end of the QCU list (ie LINK=NULL,</a>
<a name="ln892">	 * or VEOL) then it stops at the last transmitted write.</a>
<a name="ln893">	 * We then append a new frame by updating the link pointer</a>
<a name="ln894">	 * in that descriptor and then kick TxE here; it will re-read</a>
<a name="ln895">	 * that last descriptor and find the new descriptor to transmit.</a>
<a name="ln896">	 *</a>
<a name="ln897">	 * This is why we keep the holding descriptor around.</a>
<a name="ln898">	 */</a>
<a name="ln899">	ath_hal_txstart(ah, txq-&gt;axq_qnum);</a>
<a name="ln900">	ATH_TXQ_UNLOCK(txq);</a>
<a name="ln901">	ATH_KTR(sc, ATH_KTR_TX, 1,</a>
<a name="ln902">	    &quot;ath_tx_handoff: txq=%u, txstart&quot;, txq-&gt;axq_qnum);</a>
<a name="ln903">}</a>
<a name="ln904"> </a>
<a name="ln905">/*</a>
<a name="ln906"> * Restart TX DMA for the given TXQ.</a>
<a name="ln907"> *</a>
<a name="ln908"> * This must be called whether the queue is empty or not.</a>
<a name="ln909"> */</a>
<a name="ln910">static void</a>
<a name="ln911">ath_legacy_tx_dma_restart(struct ath_softc *sc, struct ath_txq *txq)</a>
<a name="ln912">{</a>
<a name="ln913">	struct ath_buf *bf, *bf_last;</a>
<a name="ln914"> </a>
<a name="ln915">	ATH_TXQ_LOCK_ASSERT(txq);</a>
<a name="ln916"> </a>
<a name="ln917">	/* XXX make this ATH_TXQ_FIRST */</a>
<a name="ln918">	bf = TAILQ_FIRST(&amp;txq-&gt;axq_q);</a>
<a name="ln919">	bf_last = ATH_TXQ_LAST(txq, axq_q_s);</a>
<a name="ln920"> </a>
<a name="ln921">	if (bf == NULL)</a>
<a name="ln922">		return;</a>
<a name="ln923"> </a>
<a name="ln924">	DPRINTF(sc, ATH_DEBUG_RESET,</a>
<a name="ln925">	    &quot;%s: Q%d: bf=%p, bf_last=%p, daddr=0x%08x\n&quot;,</a>
<a name="ln926">	    __func__,</a>
<a name="ln927">	    txq-&gt;axq_qnum,</a>
<a name="ln928">	    bf,</a>
<a name="ln929">	    bf_last,</a>
<a name="ln930">	    (uint32_t) bf-&gt;bf_daddr);</a>
<a name="ln931"> </a>
<a name="ln932">#ifdef	ATH_DEBUG</a>
<a name="ln933">	if (sc-&gt;sc_debug &amp; ATH_DEBUG_RESET)</a>
<a name="ln934">		ath_tx_dump(sc, txq);</a>
<a name="ln935">#endif</a>
<a name="ln936"> </a>
<a name="ln937">	/*</a>
<a name="ln938">	 * This is called from a restart, so DMA is known to be</a>
<a name="ln939">	 * completely stopped.</a>
<a name="ln940">	 */</a>
<a name="ln941">	KASSERT((!(txq-&gt;axq_flags &amp; ATH_TXQ_PUTRUNNING)),</a>
<a name="ln942">	    (&quot;%s: Q%d: called with PUTRUNNING=1\n&quot;,</a>
<a name="ln943">	    __func__,</a>
<a name="ln944">	    txq-&gt;axq_qnum));</a>
<a name="ln945"> </a>
<a name="ln946">	ath_hal_puttxbuf(sc-&gt;sc_ah, txq-&gt;axq_qnum, bf-&gt;bf_daddr);</a>
<a name="ln947">	txq-&gt;axq_flags |= ATH_TXQ_PUTRUNNING;</a>
<a name="ln948"> </a>
<a name="ln949">	ath_hal_gettxdesclinkptr(sc-&gt;sc_ah, bf_last-&gt;bf_lastds,</a>
<a name="ln950">	    &amp;txq-&gt;axq_link);</a>
<a name="ln951">	ath_hal_txstart(sc-&gt;sc_ah, txq-&gt;axq_qnum);</a>
<a name="ln952">}</a>
<a name="ln953"> </a>
<a name="ln954">/*</a>
<a name="ln955"> * Hand off a packet to the hardware (or mcast queue.)</a>
<a name="ln956"> *</a>
<a name="ln957"> * The relevant hardware txq should be locked.</a>
<a name="ln958"> */</a>
<a name="ln959">static void</a>
<a name="ln960">ath_legacy_xmit_handoff(struct ath_softc *sc, struct ath_txq *txq,</a>
<a name="ln961">    struct ath_buf *bf)</a>
<a name="ln962">{</a>
<a name="ln963">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln964"> </a>
<a name="ln965">#ifdef	ATH_DEBUG_ALQ</a>
<a name="ln966">	if (if_ath_alq_checkdebug(&amp;sc-&gt;sc_alq, ATH_ALQ_EDMA_TXDESC))</a>
<a name="ln967">		ath_tx_alq_post(sc, bf);</a>
<a name="ln968">#endif</a>
<a name="ln969"> </a>
<a name="ln970">	if (txq-&gt;axq_qnum == ATH_TXQ_SWQ)</a>
<a name="ln971">		ath_tx_handoff_mcast(sc, txq, bf);</a>
<a name="ln972">	else</a>
<a name="ln973">		ath_tx_handoff_hw(sc, txq, bf);</a>
<a name="ln974">}</a>
<a name="ln975"> </a>
<a name="ln976">static int</a>
<a name="ln977">ath_tx_tag_crypto(struct ath_softc *sc, struct ieee80211_node *ni,</a>
<a name="ln978">    struct mbuf *m0, int iswep, int isfrag, int *hdrlen, int *pktlen,</a>
<a name="ln979">    int *keyix)</a>
<a name="ln980">{</a>
<a name="ln981">	DPRINTF(sc, ATH_DEBUG_XMIT,</a>
<a name="ln982">	    &quot;%s: hdrlen=%d, pktlen=%d, isfrag=%d, iswep=%d, m0=%p\n&quot;,</a>
<a name="ln983">	    __func__,</a>
<a name="ln984">	    *hdrlen,</a>
<a name="ln985">	    *pktlen,</a>
<a name="ln986">	    isfrag,</a>
<a name="ln987">	    iswep,</a>
<a name="ln988">	    m0);</a>
<a name="ln989"> </a>
<a name="ln990">	if (iswep) {</a>
<a name="ln991">		const struct ieee80211_cipher *cip;</a>
<a name="ln992">		struct ieee80211_key *k;</a>
<a name="ln993"> </a>
<a name="ln994">		/*</a>
<a name="ln995">		 * Construct the 802.11 header+trailer for an encrypted</a>
<a name="ln996">		 * frame. The only reason this can fail is because of an</a>
<a name="ln997">		 * unknown or unsupported cipher/key type.</a>
<a name="ln998">		 */</a>
<a name="ln999">		k = ieee80211_crypto_encap(ni, m0);</a>
<a name="ln1000">		if (k == NULL) {</a>
<a name="ln1001">			/*</a>
<a name="ln1002">			 * This can happen when the key is yanked after the</a>
<a name="ln1003">			 * frame was queued.  Just discard the frame; the</a>
<a name="ln1004">			 * 802.11 layer counts failures and provides</a>
<a name="ln1005">			 * debugging/diagnostics.</a>
<a name="ln1006">			 */</a>
<a name="ln1007">			return (0);</a>
<a name="ln1008">		}</a>
<a name="ln1009">		/*</a>
<a name="ln1010">		 * Adjust the packet + header lengths for the crypto</a>
<a name="ln1011">		 * additions and calculate the h/w key index.  When</a>
<a name="ln1012">		 * a s/w mic is done the frame will have had any mic</a>
<a name="ln1013">		 * added to it prior to entry so m0-&gt;m_pkthdr.len will</a>
<a name="ln1014">		 * account for it. Otherwise we need to add it to the</a>
<a name="ln1015">		 * packet length.</a>
<a name="ln1016">		 */</a>
<a name="ln1017">		cip = k-&gt;wk_cipher;</a>
<a name="ln1018">		(*hdrlen) += cip-&gt;ic_header;</a>
<a name="ln1019">		(*pktlen) += cip-&gt;ic_header + cip-&gt;ic_trailer;</a>
<a name="ln1020">		/* NB: frags always have any TKIP MIC done in s/w */</a>
<a name="ln1021">		if ((k-&gt;wk_flags &amp; IEEE80211_KEY_SWMIC) == 0 &amp;&amp; !isfrag)</a>
<a name="ln1022">			(*pktlen) += cip-&gt;ic_miclen;</a>
<a name="ln1023">		(*keyix) = k-&gt;wk_keyix;</a>
<a name="ln1024">	} else if (ni-&gt;ni_ucastkey.wk_cipher == &amp;ieee80211_cipher_none) {</a>
<a name="ln1025">		/*</a>
<a name="ln1026">		 * Use station key cache slot, if assigned.</a>
<a name="ln1027">		 */</a>
<a name="ln1028">		(*keyix) = ni-&gt;ni_ucastkey.wk_keyix;</a>
<a name="ln1029">		if ((*keyix) == IEEE80211_KEYIX_NONE)</a>
<a name="ln1030">			(*keyix) = HAL_TXKEYIX_INVALID;</a>
<a name="ln1031">	} else</a>
<a name="ln1032">		(*keyix) = HAL_TXKEYIX_INVALID;</a>
<a name="ln1033"> </a>
<a name="ln1034">	return (1);</a>
<a name="ln1035">}</a>
<a name="ln1036"> </a>
<a name="ln1037">/*</a>
<a name="ln1038"> * Calculate whether interoperability protection is required for</a>
<a name="ln1039"> * this frame.</a>
<a name="ln1040"> *</a>
<a name="ln1041"> * This requires the rate control information be filled in,</a>
<a name="ln1042"> * as the protection requirement depends upon the current</a>
<a name="ln1043"> * operating mode / PHY.</a>
<a name="ln1044"> */</a>
<a name="ln1045">static void</a>
<a name="ln1046">ath_tx_calc_protection(struct ath_softc *sc, struct ath_buf *bf)</a>
<a name="ln1047">{</a>
<a name="ln1048">	struct ieee80211_frame *wh;</a>
<a name="ln1049">	uint8_t rix;</a>
<a name="ln1050">	uint16_t flags;</a>
<a name="ln1051">	int shortPreamble;</a>
<a name="ln1052">	const HAL_RATE_TABLE *rt = sc-&gt;sc_currates;</a>
<a name="ln1053">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1054"> </a>
<a name="ln1055">	flags = bf-&gt;bf_state.bfs_txflags;</a>
<a name="ln1056">	rix = bf-&gt;bf_state.bfs_rc[0].rix;</a>
<a name="ln1057">	shortPreamble = bf-&gt;bf_state.bfs_shpream;</a>
<a name="ln1058">	wh = mtod(bf-&gt;bf_m, struct ieee80211_frame *);</a>
<a name="ln1059"> </a>
<a name="ln1060">	/* Disable frame protection for TOA probe frames */</a>
<a name="ln1061">	if (bf-&gt;bf_flags &amp; ATH_BUF_TOA_PROBE) {</a>
<a name="ln1062">		/* XXX count */</a>
<a name="ln1063">		flags &amp;= ~(HAL_TXDESC_CTSENA | HAL_TXDESC_RTSENA);</a>
<a name="ln1064">		bf-&gt;bf_state.bfs_doprot = 0;</a>
<a name="ln1065">		goto finish;</a>
<a name="ln1066">	}</a>
<a name="ln1067"> </a>
<a name="ln1068">	/*</a>
<a name="ln1069">	 * If 802.11g protection is enabled, determine whether</a>
<a name="ln1070">	 * to use RTS/CTS or just CTS.  Note that this is only</a>
<a name="ln1071">	 * done for OFDM unicast frames.</a>
<a name="ln1072">	 */</a>
<a name="ln1073">	if ((ic-&gt;ic_flags &amp; IEEE80211_F_USEPROT) &amp;&amp;</a>
<a name="ln1074">	    rt-&gt;info[rix].phy == IEEE80211_T_OFDM &amp;&amp;</a>
<a name="ln1075">	    (flags &amp; HAL_TXDESC_NOACK) == 0) {</a>
<a name="ln1076">		bf-&gt;bf_state.bfs_doprot = 1;</a>
<a name="ln1077">		/* XXX fragments must use CCK rates w/ protection */</a>
<a name="ln1078">		if (ic-&gt;ic_protmode == IEEE80211_PROT_RTSCTS) {</a>
<a name="ln1079">			flags |= HAL_TXDESC_RTSENA;</a>
<a name="ln1080">		} else if (ic-&gt;ic_protmode == IEEE80211_PROT_CTSONLY) {</a>
<a name="ln1081">			flags |= HAL_TXDESC_CTSENA;</a>
<a name="ln1082">		}</a>
<a name="ln1083">		/*</a>
<a name="ln1084">		 * For frags it would be desirable to use the</a>
<a name="ln1085">		 * highest CCK rate for RTS/CTS.  But stations</a>
<a name="ln1086">		 * farther away may detect it at a lower CCK rate</a>
<a name="ln1087">		 * so use the configured protection rate instead</a>
<a name="ln1088">		 * (for now).</a>
<a name="ln1089">		 */</a>
<a name="ln1090">		sc-&gt;sc_stats.ast_tx_protect++;</a>
<a name="ln1091">	}</a>
<a name="ln1092"> </a>
<a name="ln1093">	/*</a>
<a name="ln1094">	 * If 11n protection is enabled and it's a HT frame,</a>
<a name="ln1095">	 * enable RTS.</a>
<a name="ln1096">	 *</a>
<a name="ln1097">	 * XXX ic_htprotmode or ic_curhtprotmode?</a>
<a name="ln1098">	 * XXX should it_htprotmode only matter if ic_curhtprotmode </a>
<a name="ln1099">	 * XXX indicates it's not a HT pure environment?</a>
<a name="ln1100">	 */</a>
<a name="ln1101">	if ((ic-&gt;ic_htprotmode == IEEE80211_PROT_RTSCTS) &amp;&amp;</a>
<a name="ln1102">	    rt-&gt;info[rix].phy == IEEE80211_T_HT &amp;&amp;</a>
<a name="ln1103">	    (flags &amp; HAL_TXDESC_NOACK) == 0) {</a>
<a name="ln1104">		flags |= HAL_TXDESC_RTSENA;</a>
<a name="ln1105">		sc-&gt;sc_stats.ast_tx_htprotect++;</a>
<a name="ln1106">	}</a>
<a name="ln1107"> </a>
<a name="ln1108">finish:</a>
<a name="ln1109">	bf-&gt;bf_state.bfs_txflags = flags;</a>
<a name="ln1110">}</a>
<a name="ln1111"> </a>
<a name="ln1112">/*</a>
<a name="ln1113"> * Update the frame duration given the currently selected rate.</a>
<a name="ln1114"> *</a>
<a name="ln1115"> * This also updates the frame duration value, so it will require</a>
<a name="ln1116"> * a DMA flush.</a>
<a name="ln1117"> */</a>
<a name="ln1118">static void</a>
<a name="ln1119">ath_tx_calc_duration(struct ath_softc *sc, struct ath_buf *bf)</a>
<a name="ln1120">{</a>
<a name="ln1121">	struct ieee80211_frame *wh;</a>
<a name="ln1122">	uint8_t rix;</a>
<a name="ln1123">	uint16_t flags;</a>
<a name="ln1124">	int shortPreamble;</a>
<a name="ln1125">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln1126">	const HAL_RATE_TABLE *rt = sc-&gt;sc_currates;</a>
<a name="ln1127">	int isfrag = bf-&gt;bf_m-&gt;m_flags &amp; M_FRAG;</a>
<a name="ln1128"> </a>
<a name="ln1129">	flags = bf-&gt;bf_state.bfs_txflags;</a>
<a name="ln1130">	rix = bf-&gt;bf_state.bfs_rc[0].rix;</a>
<a name="ln1131">	shortPreamble = bf-&gt;bf_state.bfs_shpream;</a>
<a name="ln1132">	wh = mtod(bf-&gt;bf_m, struct ieee80211_frame *);</a>
<a name="ln1133"> </a>
<a name="ln1134">	/*</a>
<a name="ln1135">	 * Calculate duration.  This logically belongs in the 802.11</a>
<a name="ln1136">	 * layer but it lacks sufficient information to calculate it.</a>
<a name="ln1137">	 */</a>
<a name="ln1138">	if ((flags &amp; HAL_TXDESC_NOACK) == 0 &amp;&amp;</a>
<a name="ln1139">	    (wh-&gt;i_fc[0] &amp; IEEE80211_FC0_TYPE_MASK) != IEEE80211_FC0_TYPE_CTL) {</a>
<a name="ln1140">		u_int16_t dur;</a>
<a name="ln1141">		if (shortPreamble)</a>
<a name="ln1142">			dur = rt-&gt;info[rix].spAckDuration;</a>
<a name="ln1143">		else</a>
<a name="ln1144">			dur = rt-&gt;info[rix].lpAckDuration;</a>
<a name="ln1145">		if (wh-&gt;i_fc[1] &amp; IEEE80211_FC1_MORE_FRAG) {</a>
<a name="ln1146">			dur += dur;		/* additional SIFS+ACK */</a>
<a name="ln1147">			/*</a>
<a name="ln1148">			 * Include the size of next fragment so NAV is</a>
<a name="ln1149">			 * updated properly.  The last fragment uses only</a>
<a name="ln1150">			 * the ACK duration</a>
<a name="ln1151">			 *</a>
<a name="ln1152">			 * XXX TODO: ensure that the rate lookup for each</a>
<a name="ln1153">			 * fragment is the same as the rate used by the</a>
<a name="ln1154">			 * first fragment!</a>
<a name="ln1155">			 */</a>
<a name="ln1156">			dur += ath_hal_computetxtime(ah,</a>
<a name="ln1157">			    rt,</a>
<a name="ln1158">			    bf-&gt;bf_nextfraglen,</a>
<a name="ln1159">			    rix, shortPreamble,</a>
<a name="ln1160">			    AH_TRUE);</a>
<a name="ln1161">		}</a>
<a name="ln1162">		if (isfrag) {</a>
<a name="ln1163">			/*</a>
<a name="ln1164">			 * Force hardware to use computed duration for next</a>
<a name="ln1165">			 * fragment by disabling multi-rate retry which updates</a>
<a name="ln1166">			 * duration based on the multi-rate duration table.</a>
<a name="ln1167">			 */</a>
<a name="ln1168">			bf-&gt;bf_state.bfs_ismrr = 0;</a>
<a name="ln1169">			bf-&gt;bf_state.bfs_try0 = ATH_TXMGTTRY;</a>
<a name="ln1170">			/* XXX update bfs_rc[0].try? */</a>
<a name="ln1171">		}</a>
<a name="ln1172"> </a>
<a name="ln1173">		/* Update the duration field itself */</a>
<a name="ln1174">		*(u_int16_t *)wh-&gt;i_dur = htole16(dur);</a>
<a name="ln1175">	}</a>
<a name="ln1176">}</a>
<a name="ln1177"> </a>
<a name="ln1178">static uint8_t</a>
<a name="ln1179">ath_tx_get_rtscts_rate(struct ath_hal *ah, const HAL_RATE_TABLE *rt,</a>
<a name="ln1180">    int cix, int shortPreamble)</a>
<a name="ln1181">{</a>
<a name="ln1182">	uint8_t ctsrate;</a>
<a name="ln1183"> </a>
<a name="ln1184">	/*</a>
<a name="ln1185">	 * CTS transmit rate is derived from the transmit rate</a>
<a name="ln1186">	 * by looking in the h/w rate table.  We must also factor</a>
<a name="ln1187">	 * in whether or not a short preamble is to be used.</a>
<a name="ln1188">	 */</a>
<a name="ln1189">	/* NB: cix is set above where RTS/CTS is enabled */</a>
<a name="ln1190">	KASSERT(cix != 0xff, (&quot;cix not setup&quot;));</a>
<a name="ln1191">	ctsrate = rt-&gt;info[cix].rateCode;</a>
<a name="ln1192"> </a>
<a name="ln1193">	/* XXX this should only matter for legacy rates */</a>
<a name="ln1194">	if (shortPreamble)</a>
<a name="ln1195">		ctsrate |= rt-&gt;info[cix].shortPreamble;</a>
<a name="ln1196"> </a>
<a name="ln1197">	return (ctsrate);</a>
<a name="ln1198">}</a>
<a name="ln1199"> </a>
<a name="ln1200">/*</a>
<a name="ln1201"> * Calculate the RTS/CTS duration for legacy frames.</a>
<a name="ln1202"> */</a>
<a name="ln1203">static int</a>
<a name="ln1204">ath_tx_calc_ctsduration(struct ath_hal *ah, int rix, int cix,</a>
<a name="ln1205">    int shortPreamble, int pktlen, const HAL_RATE_TABLE *rt,</a>
<a name="ln1206">    int flags)</a>
<a name="ln1207">{</a>
<a name="ln1208">	int ctsduration = 0;</a>
<a name="ln1209"> </a>
<a name="ln1210">	/* This mustn't be called for HT modes */</a>
<a name="ln1211">	if (rt-&gt;info[cix].phy == IEEE80211_T_HT) {</a>
<a name="ln1212">		printf(&quot;%s: HT rate where it shouldn't be (0x%x)\n&quot;,</a>
<a name="ln1213">		    __func__, rt-&gt;info[cix].rateCode);</a>
<a name="ln1214">		return (-1);</a>
<a name="ln1215">	}</a>
<a name="ln1216"> </a>
<a name="ln1217">	/*</a>
<a name="ln1218">	 * Compute the transmit duration based on the frame</a>
<a name="ln1219">	 * size and the size of an ACK frame.  We call into the</a>
<a name="ln1220">	 * HAL to do the computation since it depends on the</a>
<a name="ln1221">	 * characteristics of the actual PHY being used.</a>
<a name="ln1222">	 *</a>
<a name="ln1223">	 * NB: CTS is assumed the same size as an ACK so we can</a>
<a name="ln1224">	 *     use the precalculated ACK durations.</a>
<a name="ln1225">	 */</a>
<a name="ln1226">	if (shortPreamble) {</a>
<a name="ln1227">		if (flags &amp; HAL_TXDESC_RTSENA)		/* SIFS + CTS */</a>
<a name="ln1228">			ctsduration += rt-&gt;info[cix].spAckDuration;</a>
<a name="ln1229">		ctsduration += ath_hal_computetxtime(ah,</a>
<a name="ln1230">			rt, pktlen, rix, AH_TRUE, AH_TRUE);</a>
<a name="ln1231">		if ((flags &amp; HAL_TXDESC_NOACK) == 0)	/* SIFS + ACK */</a>
<a name="ln1232">			ctsduration += rt-&gt;info[rix].spAckDuration;</a>
<a name="ln1233">	} else {</a>
<a name="ln1234">		if (flags &amp; HAL_TXDESC_RTSENA)		/* SIFS + CTS */</a>
<a name="ln1235">			ctsduration += rt-&gt;info[cix].lpAckDuration;</a>
<a name="ln1236">		ctsduration += ath_hal_computetxtime(ah,</a>
<a name="ln1237">			rt, pktlen, rix, AH_FALSE, AH_TRUE);</a>
<a name="ln1238">		if ((flags &amp; HAL_TXDESC_NOACK) == 0)	/* SIFS + ACK */</a>
<a name="ln1239">			ctsduration += rt-&gt;info[rix].lpAckDuration;</a>
<a name="ln1240">	}</a>
<a name="ln1241"> </a>
<a name="ln1242">	return (ctsduration);</a>
<a name="ln1243">}</a>
<a name="ln1244"> </a>
<a name="ln1245">/*</a>
<a name="ln1246"> * Update the given ath_buf with updated rts/cts setup and duration</a>
<a name="ln1247"> * values.</a>
<a name="ln1248"> *</a>
<a name="ln1249"> * To support rate lookups for each software retry, the rts/cts rate</a>
<a name="ln1250"> * and cts duration must be re-calculated.</a>
<a name="ln1251"> *</a>
<a name="ln1252"> * This function assumes the RTS/CTS flags have been set as needed;</a>
<a name="ln1253"> * mrr has been disabled; and the rate control lookup has been done.</a>
<a name="ln1254"> *</a>
<a name="ln1255"> * XXX TODO: MRR need only be disabled for the pre-11n NICs.</a>
<a name="ln1256"> * XXX The 11n NICs support per-rate RTS/CTS configuration.</a>
<a name="ln1257"> */</a>
<a name="ln1258">static void</a>
<a name="ln1259">ath_tx_set_rtscts(struct ath_softc *sc, struct ath_buf *bf)</a>
<a name="ln1260">{</a>
<a name="ln1261">	uint16_t ctsduration = 0;</a>
<a name="ln1262">	uint8_t ctsrate = 0;</a>
<a name="ln1263">	uint8_t rix = bf-&gt;bf_state.bfs_rc[0].rix;</a>
<a name="ln1264">	uint8_t cix = 0;</a>
<a name="ln1265">	const HAL_RATE_TABLE *rt = sc-&gt;sc_currates;</a>
<a name="ln1266"> </a>
<a name="ln1267">	/*</a>
<a name="ln1268">	 * No RTS/CTS enabled? Don't bother.</a>
<a name="ln1269">	 */</a>
<a name="ln1270">	if ((bf-&gt;bf_state.bfs_txflags &amp;</a>
<a name="ln1271">	    (HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA)) == 0) {</a>
<a name="ln1272">		/* XXX is this really needed? */</a>
<a name="ln1273">		bf-&gt;bf_state.bfs_ctsrate = 0;</a>
<a name="ln1274">		bf-&gt;bf_state.bfs_ctsduration = 0;</a>
<a name="ln1275">		return;</a>
<a name="ln1276">	}</a>
<a name="ln1277"> </a>
<a name="ln1278">	/*</a>
<a name="ln1279">	 * If protection is enabled, use the protection rix control</a>
<a name="ln1280">	 * rate. Otherwise use the rate0 control rate.</a>
<a name="ln1281">	 */</a>
<a name="ln1282">	if (bf-&gt;bf_state.bfs_doprot)</a>
<a name="ln1283">		rix = sc-&gt;sc_protrix;</a>
<a name="ln1284">	else</a>
<a name="ln1285">		rix = bf-&gt;bf_state.bfs_rc[0].rix;</a>
<a name="ln1286"> </a>
<a name="ln1287">	/*</a>
<a name="ln1288">	 * If the raw path has hard-coded ctsrate0 to something,</a>
<a name="ln1289">	 * use it.</a>
<a name="ln1290">	 */</a>
<a name="ln1291">	if (bf-&gt;bf_state.bfs_ctsrate0 != 0)</a>
<a name="ln1292">		cix = ath_tx_findrix(sc, bf-&gt;bf_state.bfs_ctsrate0);</a>
<a name="ln1293">	else</a>
<a name="ln1294">		/* Control rate from above */</a>
<a name="ln1295">		cix = rt-&gt;info[rix].controlRate;</a>
<a name="ln1296"> </a>
<a name="ln1297">	/* Calculate the rtscts rate for the given cix */</a>
<a name="ln1298">	ctsrate = ath_tx_get_rtscts_rate(sc-&gt;sc_ah, rt, cix,</a>
<a name="ln1299">	    bf-&gt;bf_state.bfs_shpream);</a>
<a name="ln1300"> </a>
<a name="ln1301">	/* The 11n chipsets do ctsduration calculations for you */</a>
<a name="ln1302">	if (! ath_tx_is_11n(sc))</a>
<a name="ln1303">		ctsduration = ath_tx_calc_ctsduration(sc-&gt;sc_ah, rix, cix,</a>
<a name="ln1304">		    bf-&gt;bf_state.bfs_shpream, bf-&gt;bf_state.bfs_pktlen,</a>
<a name="ln1305">		    rt, bf-&gt;bf_state.bfs_txflags);</a>
<a name="ln1306"> </a>
<a name="ln1307">	/* Squirrel away in ath_buf */</a>
<a name="ln1308">	bf-&gt;bf_state.bfs_ctsrate = ctsrate;</a>
<a name="ln1309">	bf-&gt;bf_state.bfs_ctsduration = ctsduration;</a>
<a name="ln1310">	</a>
<a name="ln1311">	/*</a>
<a name="ln1312">	 * Must disable multi-rate retry when using RTS/CTS.</a>
<a name="ln1313">	 */</a>
<a name="ln1314">	if (!sc-&gt;sc_mrrprot) {</a>
<a name="ln1315">		bf-&gt;bf_state.bfs_ismrr = 0;</a>
<a name="ln1316">		bf-&gt;bf_state.bfs_try0 =</a>
<a name="ln1317">		    bf-&gt;bf_state.bfs_rc[0].tries = ATH_TXMGTTRY; /* XXX ew */</a>
<a name="ln1318">	}</a>
<a name="ln1319">}</a>
<a name="ln1320"> </a>
<a name="ln1321">/*</a>
<a name="ln1322"> * Setup the descriptor chain for a normal or fast-frame</a>
<a name="ln1323"> * frame.</a>
<a name="ln1324"> *</a>
<a name="ln1325"> * XXX TODO: extend to include the destination hardware QCU ID.</a>
<a name="ln1326"> * Make sure that is correct.  Make sure that when being added</a>
<a name="ln1327"> * to the mcastq, the CABQ QCUID is set or things will get a bit</a>
<a name="ln1328"> * odd.</a>
<a name="ln1329"> */</a>
<a name="ln1330">static void</a>
<a name="ln1331">ath_tx_setds(struct ath_softc *sc, struct ath_buf *bf)</a>
<a name="ln1332">{</a>
<a name="ln1333">	struct ath_desc *ds = bf-&gt;bf_desc;</a>
<a name="ln1334">	struct ath_hal *ah = sc-&gt;sc_ah;</a>
<a name="ln1335"> </a>
<a name="ln1336">	if (bf-&gt;bf_state.bfs_txrate0 == 0)</a>
<a name="ln1337">		DPRINTF(sc, ATH_DEBUG_XMIT, </a>
<a name="ln1338">		    &quot;%s: bf=%p, txrate0=%d\n&quot;, __func__, bf, 0);</a>
<a name="ln1339"> </a>
<a name="ln1340">	ath_hal_setuptxdesc(ah, ds</a>
<a name="ln1341">		, bf-&gt;bf_state.bfs_pktlen	/* packet length */</a>
<a name="ln1342">		, bf-&gt;bf_state.bfs_hdrlen	/* header length */</a>
<a name="ln1343">		, bf-&gt;bf_state.bfs_atype	/* Atheros packet type */</a>
<a name="ln1344">		, bf-&gt;bf_state.bfs_txpower	/* txpower */</a>
<a name="ln1345">		, bf-&gt;bf_state.bfs_txrate0</a>
<a name="ln1346">		, bf-&gt;bf_state.bfs_try0		/* series 0 rate/tries */</a>
<a name="ln1347">		, bf-&gt;bf_state.bfs_keyix	/* key cache index */</a>
<a name="ln1348">		, bf-&gt;bf_state.bfs_txantenna	/* antenna mode */</a>
<a name="ln1349">		, bf-&gt;bf_state.bfs_txflags	/* flags */</a>
<a name="ln1350">		, bf-&gt;bf_state.bfs_ctsrate	/* rts/cts rate */</a>
<a name="ln1351">		, bf-&gt;bf_state.bfs_ctsduration	/* rts/cts duration */</a>
<a name="ln1352">	);</a>
<a name="ln1353"> </a>
<a name="ln1354">	/*</a>
<a name="ln1355">	 * This will be overriden when the descriptor chain is written.</a>
<a name="ln1356">	 */</a>
<a name="ln1357">	bf-&gt;bf_lastds = ds;</a>
<a name="ln1358">	bf-&gt;bf_last = bf;</a>
<a name="ln1359"> </a>
<a name="ln1360">	/* Set rate control and descriptor chain for this frame */</a>
<a name="ln1361">	ath_tx_set_ratectrl(sc, bf-&gt;bf_node, bf);</a>
<a name="ln1362">	ath_tx_chaindesclist(sc, ds, bf, 0, 0, 0);</a>
<a name="ln1363">}</a>
<a name="ln1364"> </a>
<a name="ln1365">/*</a>
<a name="ln1366"> * Do a rate lookup.</a>
<a name="ln1367"> *</a>
<a name="ln1368"> * This performs a rate lookup for the given ath_buf only if it's required.</a>
<a name="ln1369"> * Non-data frames and raw frames don't require it.</a>
<a name="ln1370"> *</a>
<a name="ln1371"> * This populates the primary and MRR entries; MRR values are</a>
<a name="ln1372"> * then disabled later on if something requires it (eg RTS/CTS on</a>
<a name="ln1373"> * pre-11n chipsets.</a>
<a name="ln1374"> *</a>
<a name="ln1375"> * This needs to be done before the RTS/CTS fields are calculated</a>
<a name="ln1376"> * as they may depend upon the rate chosen.</a>
<a name="ln1377"> */</a>
<a name="ln1378">static void</a>
<a name="ln1379">ath_tx_do_ratelookup(struct ath_softc *sc, struct ath_buf *bf)</a>
<a name="ln1380">{</a>
<a name="ln1381">	uint8_t rate, rix;</a>
<a name="ln1382">	int try0;</a>
<a name="ln1383"> </a>
<a name="ln1384">	if (! bf-&gt;bf_state.bfs_doratelookup)</a>
<a name="ln1385">		return;</a>
<a name="ln1386"> </a>
<a name="ln1387">	/* Get rid of any previous state */</a>
<a name="ln1388">	bzero(bf-&gt;bf_state.bfs_rc, sizeof(bf-&gt;bf_state.bfs_rc));</a>
<a name="ln1389"> </a>
<a name="ln1390">	ATH_NODE_LOCK(ATH_NODE(bf-&gt;bf_node));</a>
<a name="ln1391">	ath_rate_findrate(sc, ATH_NODE(bf-&gt;bf_node), bf-&gt;bf_state.bfs_shpream,</a>
<a name="ln1392">	    bf-&gt;bf_state.bfs_pktlen, &amp;rix, &amp;try0, &amp;rate);</a>
<a name="ln1393"> </a>
<a name="ln1394">	/* In case MRR is disabled, make sure rc[0] is setup correctly */</a>
<a name="ln1395">	bf-&gt;bf_state.bfs_rc[0].rix = rix;</a>
<a name="ln1396">	bf-&gt;bf_state.bfs_rc[0].ratecode = rate;</a>
<a name="ln1397">	bf-&gt;bf_state.bfs_rc[0].tries = try0;</a>
<a name="ln1398"> </a>
<a name="ln1399">	if (bf-&gt;bf_state.bfs_ismrr &amp;&amp; try0 != ATH_TXMAXTRY)</a>
<a name="ln1400">		ath_rate_getxtxrates(sc, ATH_NODE(bf-&gt;bf_node), rix,</a>
<a name="ln1401">		    bf-&gt;bf_state.bfs_rc);</a>
<a name="ln1402">	ATH_NODE_UNLOCK(ATH_NODE(bf-&gt;bf_node));</a>
<a name="ln1403"> </a>
<a name="ln1404">	sc-&gt;sc_txrix = rix;	/* for LED blinking */</a>
<a name="ln1405">	sc-&gt;sc_lastdatarix = rix;	/* for fast frames */</a>
<a name="ln1406">	bf-&gt;bf_state.bfs_try0 = try0;</a>
<a name="ln1407">	bf-&gt;bf_state.bfs_txrate0 = rate;</a>
<a name="ln1408">}</a>
<a name="ln1409"> </a>
<a name="ln1410">/*</a>
<a name="ln1411"> * Update the CLRDMASK bit in the ath_buf if it needs to be set.</a>
<a name="ln1412"> */</a>
<a name="ln1413">static void</a>
<a name="ln1414">ath_tx_update_clrdmask(struct ath_softc *sc, struct ath_tid *tid,</a>
<a name="ln1415">    struct ath_buf *bf)</a>
<a name="ln1416">{</a>
<a name="ln1417">	struct ath_node *an = ATH_NODE(bf-&gt;bf_node);</a>
<a name="ln1418"> </a>
<a name="ln1419">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln1420"> </a>
<a name="ln1421">	if (an-&gt;clrdmask == 1) {</a>
<a name="ln1422">		bf-&gt;bf_state.bfs_txflags |= HAL_TXDESC_CLRDMASK;</a>
<a name="ln1423">		an-&gt;clrdmask = 0;</a>
<a name="ln1424">	}</a>
<a name="ln1425">}</a>
<a name="ln1426"> </a>
<a name="ln1427">/*</a>
<a name="ln1428"> * Return whether this frame should be software queued or</a>
<a name="ln1429"> * direct dispatched.</a>
<a name="ln1430"> *</a>
<a name="ln1431"> * When doing powersave, BAR frames should be queued but other management</a>
<a name="ln1432"> * frames should be directly sent.</a>
<a name="ln1433"> *</a>
<a name="ln1434"> * When not doing powersave, stick BAR frames into the hardware queue</a>
<a name="ln1435"> * so it goes out even though the queue is paused.</a>
<a name="ln1436"> *</a>
<a name="ln1437"> * For now, management frames are also software queued by default.</a>
<a name="ln1438"> */</a>
<a name="ln1439">static int</a>
<a name="ln1440">ath_tx_should_swq_frame(struct ath_softc *sc, struct ath_node *an,</a>
<a name="ln1441">    struct mbuf *m0, int *queue_to_head)</a>
<a name="ln1442">{</a>
<a name="ln1443">	struct ieee80211_node *ni = &amp;an-&gt;an_node;</a>
<a name="ln1444">	struct ieee80211_frame *wh;</a>
<a name="ln1445">	uint8_t type, subtype;</a>
<a name="ln1446"> </a>
<a name="ln1447">	wh = mtod(m0, struct ieee80211_frame *);</a>
<a name="ln1448">	type = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_TYPE_MASK;</a>
<a name="ln1449">	subtype = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_SUBTYPE_MASK;</a>
<a name="ln1450"> </a>
<a name="ln1451">	(*queue_to_head) = 0;</a>
<a name="ln1452"> </a>
<a name="ln1453">	/* If it's not in powersave - direct-dispatch BAR */</a>
<a name="ln1454">	if ((ATH_NODE(ni)-&gt;an_is_powersave == 0)</a>
<a name="ln1455">	    &amp;&amp; type == IEEE80211_FC0_TYPE_CTL &amp;&amp;</a>
<a name="ln1456">	    subtype == IEEE80211_FC0_SUBTYPE_BAR) {</a>
<a name="ln1457">		DPRINTF(sc, ATH_DEBUG_SW_TX,</a>
<a name="ln1458">		    &quot;%s: BAR: TX'ing direct\n&quot;, __func__);</a>
<a name="ln1459">		return (0);</a>
<a name="ln1460">	} else if ((ATH_NODE(ni)-&gt;an_is_powersave == 1)</a>
<a name="ln1461">	    &amp;&amp; type == IEEE80211_FC0_TYPE_CTL &amp;&amp;</a>
<a name="ln1462">	    subtype == IEEE80211_FC0_SUBTYPE_BAR) {</a>
<a name="ln1463">		/* BAR TX whilst asleep; queue */</a>
<a name="ln1464">		DPRINTF(sc, ATH_DEBUG_SW_TX,</a>
<a name="ln1465">		    &quot;%s: swq: TX'ing\n&quot;, __func__);</a>
<a name="ln1466">		(*queue_to_head) = 1;</a>
<a name="ln1467">		return (1);</a>
<a name="ln1468">	} else if ((ATH_NODE(ni)-&gt;an_is_powersave == 1)</a>
<a name="ln1469">	    &amp;&amp; (type == IEEE80211_FC0_TYPE_MGT ||</a>
<a name="ln1470">	        type == IEEE80211_FC0_TYPE_CTL)) {</a>
<a name="ln1471">		/*</a>
<a name="ln1472">		 * Other control/mgmt frame; bypass software queuing</a>
<a name="ln1473">		 * for now!</a>
<a name="ln1474">		 */</a>
<a name="ln1475">		DPRINTF(sc, ATH_DEBUG_XMIT, </a>
<a name="ln1476">		    &quot;%s: %6D: Node is asleep; sending mgmt &quot;</a>
<a name="ln1477">		    &quot;(type=%d, subtype=%d)\n&quot;,</a>
<a name="ln1478">		    __func__, ni-&gt;ni_macaddr, &quot;:&quot;, type, subtype);</a>
<a name="ln1479">		return (0);</a>
<a name="ln1480">	} else {</a>
<a name="ln1481">		return (1);</a>
<a name="ln1482">	}</a>
<a name="ln1483">}</a>
<a name="ln1484"> </a>
<a name="ln1485"> </a>
<a name="ln1486">/*</a>
<a name="ln1487"> * Transmit the given frame to the hardware.</a>
<a name="ln1488"> *</a>
<a name="ln1489"> * The frame must already be setup; rate control must already have</a>
<a name="ln1490"> * been done.</a>
<a name="ln1491"> *</a>
<a name="ln1492"> * XXX since the TXQ lock is being held here (and I dislike holding</a>
<a name="ln1493"> * it for this long when not doing software aggregation), later on</a>
<a name="ln1494"> * break this function into &quot;setup_normal&quot; and &quot;xmit_normal&quot;. The</a>
<a name="ln1495"> * lock only needs to be held for the ath_tx_handoff call.</a>
<a name="ln1496"> *</a>
<a name="ln1497"> * XXX we don't update the leak count here - if we're doing</a>
<a name="ln1498"> * direct frame dispatch, we need to be able to do it without</a>
<a name="ln1499"> * decrementing the leak count (eg multicast queue frames.)</a>
<a name="ln1500"> */</a>
<a name="ln1501">static void</a>
<a name="ln1502">ath_tx_xmit_normal(struct ath_softc *sc, struct ath_txq *txq,</a>
<a name="ln1503">    struct ath_buf *bf)</a>
<a name="ln1504">{</a>
<a name="ln1505">	struct ath_node *an = ATH_NODE(bf-&gt;bf_node);</a>
<a name="ln1506">	struct ath_tid *tid = &amp;an-&gt;an_tid[bf-&gt;bf_state.bfs_tid];</a>
<a name="ln1507"> </a>
<a name="ln1508">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln1509"> </a>
<a name="ln1510">	/*</a>
<a name="ln1511">	 * For now, just enable CLRDMASK. ath_tx_xmit_normal() does</a>
<a name="ln1512">	 * set a completion handler however it doesn't (yet) properly</a>
<a name="ln1513">	 * handle the strict ordering requirements needed for normal,</a>
<a name="ln1514">	 * non-aggregate session frames.</a>
<a name="ln1515">	 *</a>
<a name="ln1516">	 * Once this is implemented, only set CLRDMASK like this for</a>
<a name="ln1517">	 * frames that must go out - eg management/raw frames.</a>
<a name="ln1518">	 */</a>
<a name="ln1519">	bf-&gt;bf_state.bfs_txflags |= HAL_TXDESC_CLRDMASK;</a>
<a name="ln1520"> </a>
<a name="ln1521">	/* Setup the descriptor before handoff */</a>
<a name="ln1522">	ath_tx_do_ratelookup(sc, bf);</a>
<a name="ln1523">	ath_tx_calc_duration(sc, bf);</a>
<a name="ln1524">	ath_tx_calc_protection(sc, bf);</a>
<a name="ln1525">	ath_tx_set_rtscts(sc, bf);</a>
<a name="ln1526">	ath_tx_rate_fill_rcflags(sc, bf);</a>
<a name="ln1527">	ath_tx_setds(sc, bf);</a>
<a name="ln1528"> </a>
<a name="ln1529">	/* Track per-TID hardware queue depth correctly */</a>
<a name="ln1530">	tid-&gt;hwq_depth++;</a>
<a name="ln1531"> </a>
<a name="ln1532">	/* Assign the completion handler */</a>
<a name="ln1533">	bf-&gt;bf_comp = ath_tx_normal_comp;</a>
<a name="ln1534"> </a>
<a name="ln1535">	/* Hand off to hardware */</a>
<a name="ln1536">	ath_tx_handoff(sc, txq, bf);</a>
<a name="ln1537">}</a>
<a name="ln1538"> </a>
<a name="ln1539">/*</a>
<a name="ln1540"> * Do the basic frame setup stuff that's required before the frame</a>
<a name="ln1541"> * is added to a software queue.</a>
<a name="ln1542"> *</a>
<a name="ln1543"> * All frames get mostly the same treatment and it's done once.</a>
<a name="ln1544"> * Retransmits fiddle with things like the rate control setup,</a>
<a name="ln1545"> * setting the retransmit bit in the packet; doing relevant DMA/bus</a>
<a name="ln1546"> * syncing and relinking it (back) into the hardware TX queue.</a>
<a name="ln1547"> *</a>
<a name="ln1548"> * Note that this may cause the mbuf to be reallocated, so</a>
<a name="ln1549"> * m0 may not be valid.</a>
<a name="ln1550"> */</a>
<a name="ln1551">static int</a>
<a name="ln1552">ath_tx_normal_setup(struct ath_softc *sc, struct ieee80211_node *ni,</a>
<a name="ln1553">    struct ath_buf *bf, struct mbuf *m0, struct ath_txq *txq)</a>
<a name="ln1554">{</a>
<a name="ln1555">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln1556">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1557">	int error, iswep, ismcast, isfrag, ismrr;</a>
<a name="ln1558">	int keyix, hdrlen, pktlen, try0 = 0;</a>
<a name="ln1559">	u_int8_t rix = 0, txrate = 0;</a>
<a name="ln1560">	struct ath_desc *ds;</a>
<a name="ln1561">	struct ieee80211_frame *wh;</a>
<a name="ln1562">	u_int subtype, flags;</a>
<a name="ln1563">	HAL_PKT_TYPE atype;</a>
<a name="ln1564">	const HAL_RATE_TABLE *rt;</a>
<a name="ln1565">	HAL_BOOL shortPreamble;</a>
<a name="ln1566">	struct ath_node *an;</a>
<a name="ln1567"> </a>
<a name="ln1568">	/* XXX TODO: this pri is only used for non-QoS check, right? */</a>
<a name="ln1569">	u_int pri;</a>
<a name="ln1570"> </a>
<a name="ln1571">	/*</a>
<a name="ln1572">	 * To ensure that both sequence numbers and the CCMP PN handling</a>
<a name="ln1573">	 * is &quot;correct&quot;, make sure that the relevant TID queue is locked.</a>
<a name="ln1574">	 * Otherwise the CCMP PN and seqno may appear out of order, causing</a>
<a name="ln1575">	 * re-ordered frames to have out of order CCMP PN's, resulting</a>
<a name="ln1576">	 * in many, many frame drops.</a>
<a name="ln1577">	 */</a>
<a name="ln1578">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln1579"> </a>
<a name="ln1580">	wh = mtod(m0, struct ieee80211_frame *);</a>
<a name="ln1581">	iswep = wh-&gt;i_fc[1] &amp; IEEE80211_FC1_PROTECTED;</a>
<a name="ln1582">	ismcast = IEEE80211_IS_MULTICAST(wh-&gt;i_addr1);</a>
<a name="ln1583">	isfrag = m0-&gt;m_flags &amp; M_FRAG;</a>
<a name="ln1584">	hdrlen = ieee80211_anyhdrsize(wh);</a>
<a name="ln1585">	/*</a>
<a name="ln1586">	 * Packet length must not include any</a>
<a name="ln1587">	 * pad bytes; deduct them here.</a>
<a name="ln1588">	 */</a>
<a name="ln1589">	pktlen = m0-&gt;m_pkthdr.len - (hdrlen &amp; 3);</a>
<a name="ln1590"> </a>
<a name="ln1591">	/* Handle encryption twiddling if needed */</a>
<a name="ln1592">	if (! ath_tx_tag_crypto(sc, ni, m0, iswep, isfrag, &amp;hdrlen,</a>
<a name="ln1593">	    &amp;pktlen, &amp;keyix)) {</a>
<a name="ln1594">		ieee80211_free_mbuf(m0);</a>
<a name="ln1595">		return EIO;</a>
<a name="ln1596">	}</a>
<a name="ln1597"> </a>
<a name="ln1598">	/* packet header may have moved, reset our local pointer */</a>
<a name="ln1599">	wh = mtod(m0, struct ieee80211_frame *);</a>
<a name="ln1600"> </a>
<a name="ln1601">	pktlen += IEEE80211_CRC_LEN;</a>
<a name="ln1602"> </a>
<a name="ln1603">	/*</a>
<a name="ln1604">	 * Load the DMA map so any coalescing is done.  This</a>
<a name="ln1605">	 * also calculates the number of descriptors we need.</a>
<a name="ln1606">	 */</a>
<a name="ln1607">	error = ath_tx_dmasetup(sc, bf, m0);</a>
<a name="ln1608">	if (error != 0)</a>
<a name="ln1609">		return error;</a>
<a name="ln1610">	KASSERT((ni != NULL), (&quot;%s: ni=NULL!&quot;, __func__));</a>
<a name="ln1611">	bf-&gt;bf_node = ni;			/* NB: held reference */</a>
<a name="ln1612">	m0 = bf-&gt;bf_m;				/* NB: may have changed */</a>
<a name="ln1613">	wh = mtod(m0, struct ieee80211_frame *);</a>
<a name="ln1614"> </a>
<a name="ln1615">	/* setup descriptors */</a>
<a name="ln1616">	ds = bf-&gt;bf_desc;</a>
<a name="ln1617">	rt = sc-&gt;sc_currates;</a>
<a name="ln1618">	KASSERT(rt != NULL, (&quot;no rate table, mode %u&quot;, sc-&gt;sc_curmode));</a>
<a name="ln1619"> </a>
<a name="ln1620">	/*</a>
<a name="ln1621">	 * NB: the 802.11 layer marks whether or not we should</a>
<a name="ln1622">	 * use short preamble based on the current mode and</a>
<a name="ln1623">	 * negotiated parameters.</a>
<a name="ln1624">	 */</a>
<a name="ln1625">	if ((ic-&gt;ic_flags &amp; IEEE80211_F_SHPREAMBLE) &amp;&amp;</a>
<a name="ln1626">	    (ni-&gt;ni_capinfo &amp; IEEE80211_CAPINFO_SHORT_PREAMBLE)) {</a>
<a name="ln1627">		shortPreamble = AH_TRUE;</a>
<a name="ln1628">		sc-&gt;sc_stats.ast_tx_shortpre++;</a>
<a name="ln1629">	} else {</a>
<a name="ln1630">		shortPreamble = AH_FALSE;</a>
<a name="ln1631">	}</a>
<a name="ln1632"> </a>
<a name="ln1633">	an = ATH_NODE(ni);</a>
<a name="ln1634">	//flags = HAL_TXDESC_CLRDMASK;		/* XXX needed for crypto errs */</a>
<a name="ln1635">	flags = 0;</a>
<a name="ln1636">	ismrr = 0;				/* default no multi-rate retry*/</a>
<a name="ln1637"> </a>
<a name="ln1638">	pri = ath_tx_getac(sc, m0);			/* honor classification */</a>
<a name="ln1639">	/* XXX use txparams instead of fixed values */</a>
<a name="ln1640">	/*</a>
<a name="ln1641">	 * Calculate Atheros packet type from IEEE80211 packet header,</a>
<a name="ln1642">	 * setup for rate calculations, and select h/w transmit queue.</a>
<a name="ln1643">	 */</a>
<a name="ln1644">	switch (wh-&gt;i_fc[0] &amp; IEEE80211_FC0_TYPE_MASK) {</a>
<a name="ln1645">	case IEEE80211_FC0_TYPE_MGT:</a>
<a name="ln1646">		subtype = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_SUBTYPE_MASK;</a>
<a name="ln1647">		if (subtype == IEEE80211_FC0_SUBTYPE_BEACON)</a>
<a name="ln1648">			atype = HAL_PKT_TYPE_BEACON;</a>
<a name="ln1649">		else if (subtype == IEEE80211_FC0_SUBTYPE_PROBE_RESP)</a>
<a name="ln1650">			atype = HAL_PKT_TYPE_PROBE_RESP;</a>
<a name="ln1651">		else if (subtype == IEEE80211_FC0_SUBTYPE_ATIM)</a>
<a name="ln1652">			atype = HAL_PKT_TYPE_ATIM;</a>
<a name="ln1653">		else</a>
<a name="ln1654">			atype = HAL_PKT_TYPE_NORMAL;	/* XXX */</a>
<a name="ln1655">		rix = an-&gt;an_mgmtrix;</a>
<a name="ln1656">		txrate = rt-&gt;info[rix].rateCode;</a>
<a name="ln1657">		if (shortPreamble)</a>
<a name="ln1658">			txrate |= rt-&gt;info[rix].shortPreamble;</a>
<a name="ln1659">		try0 = ATH_TXMGTTRY;</a>
<a name="ln1660">		flags |= HAL_TXDESC_INTREQ;	/* force interrupt */</a>
<a name="ln1661">		break;</a>
<a name="ln1662">	case IEEE80211_FC0_TYPE_CTL:</a>
<a name="ln1663">		atype = HAL_PKT_TYPE_PSPOLL;	/* stop setting of duration */</a>
<a name="ln1664">		rix = an-&gt;an_mgmtrix;</a>
<a name="ln1665">		txrate = rt-&gt;info[rix].rateCode;</a>
<a name="ln1666">		if (shortPreamble)</a>
<a name="ln1667">			txrate |= rt-&gt;info[rix].shortPreamble;</a>
<a name="ln1668">		try0 = ATH_TXMGTTRY;</a>
<a name="ln1669">		flags |= HAL_TXDESC_INTREQ;	/* force interrupt */</a>
<a name="ln1670">		break;</a>
<a name="ln1671">	case IEEE80211_FC0_TYPE_DATA:</a>
<a name="ln1672">		atype = HAL_PKT_TYPE_NORMAL;		/* default */</a>
<a name="ln1673">		/*</a>
<a name="ln1674">		 * Data frames: multicast frames go out at a fixed rate,</a>
<a name="ln1675">		 * EAPOL frames use the mgmt frame rate; otherwise consult</a>
<a name="ln1676">		 * the rate control module for the rate to use.</a>
<a name="ln1677">		 */</a>
<a name="ln1678">		if (ismcast) {</a>
<a name="ln1679">			rix = an-&gt;an_mcastrix;</a>
<a name="ln1680">			txrate = rt-&gt;info[rix].rateCode;</a>
<a name="ln1681">			if (shortPreamble)</a>
<a name="ln1682">				txrate |= rt-&gt;info[rix].shortPreamble;</a>
<a name="ln1683">			try0 = 1;</a>
<a name="ln1684">		} else if (m0-&gt;m_flags &amp; M_EAPOL) {</a>
<a name="ln1685">			/* XXX? maybe always use long preamble? */</a>
<a name="ln1686">			rix = an-&gt;an_mgmtrix;</a>
<a name="ln1687">			txrate = rt-&gt;info[rix].rateCode;</a>
<a name="ln1688">			if (shortPreamble)</a>
<a name="ln1689">				txrate |= rt-&gt;info[rix].shortPreamble;</a>
<a name="ln1690">			try0 = ATH_TXMAXTRY;	/* XXX?too many? */</a>
<a name="ln1691">		} else {</a>
<a name="ln1692">			/*</a>
<a name="ln1693">			 * Do rate lookup on each TX, rather than using</a>
<a name="ln1694">			 * the hard-coded TX information decided here.</a>
<a name="ln1695">			 */</a>
<a name="ln1696">			ismrr = 1;</a>
<a name="ln1697">			bf-&gt;bf_state.bfs_doratelookup = 1;</a>
<a name="ln1698">		}</a>
<a name="ln1699"> </a>
<a name="ln1700">		/*</a>
<a name="ln1701">		 * Check whether to set NOACK for this WME category or not.</a>
<a name="ln1702">		 */</a>
<a name="ln1703">		if (ieee80211_wme_vap_ac_is_noack(vap, pri))</a>
<a name="ln1704">			flags |= HAL_TXDESC_NOACK;</a>
<a name="ln1705">		break;</a>
<a name="ln1706">	default:</a>
<a name="ln1707">		device_printf(sc-&gt;sc_dev, &quot;bogus frame type 0x%x (%s)\n&quot;,</a>
<a name="ln1708">		    wh-&gt;i_fc[0] &amp; IEEE80211_FC0_TYPE_MASK, __func__);</a>
<a name="ln1709">		/* XXX statistic */</a>
<a name="ln1710">		/* XXX free tx dmamap */</a>
<a name="ln1711">		ieee80211_free_mbuf(m0);</a>
<a name="ln1712">		return EIO;</a>
<a name="ln1713">	}</a>
<a name="ln1714"> </a>
<a name="ln1715">	/*</a>
<a name="ln1716">	 * There are two known scenarios where the frame AC doesn't match</a>
<a name="ln1717">	 * what the destination TXQ is.</a>
<a name="ln1718">	 *</a>
<a name="ln1719">	 * + non-QoS frames (eg management?) that the net80211 stack has</a>
<a name="ln1720">	 *   assigned a higher AC to, but since it's a non-QoS TID, it's</a>
<a name="ln1721">	 *   being thrown into TID 16.  TID 16 gets the AC_BE queue.</a>
<a name="ln1722">	 *   It's quite possible that management frames should just be</a>
<a name="ln1723">	 *   direct dispatched to hardware rather than go via the software</a>
<a name="ln1724">	 *   queue; that should be investigated in the future.  There are</a>
<a name="ln1725">	 *   some specific scenarios where this doesn't make sense, mostly</a>
<a name="ln1726">	 *   surrounding ADDBA request/response - hence why that is special</a>
<a name="ln1727">	 *   cased.</a>
<a name="ln1728">	 *</a>
<a name="ln1729">	 * + Multicast frames going into the VAP mcast queue.  That shows up</a>
<a name="ln1730">	 *   as &quot;TXQ 11&quot;.</a>
<a name="ln1731">	 *</a>
<a name="ln1732">	 * This driver should eventually support separate TID and TXQ locking,</a>
<a name="ln1733">	 * allowing for arbitrary AC frames to appear on arbitrary software</a>
<a name="ln1734">	 * queues, being queued to the &quot;correct&quot; hardware queue when needed.</a>
<a name="ln1735">	 */</a>
<a name="ln1736">#if 0</a>
<a name="ln1737">	if (txq != sc-&gt;sc_ac2q[pri]) {</a>
<a name="ln1738">		DPRINTF(sc, ATH_DEBUG_XMIT, </a>
<a name="ln1739">		    &quot;%s: txq=%p (%d), pri=%d, pri txq=%p (%d)\n&quot;,</a>
<a name="ln1740">		    __func__,</a>
<a name="ln1741">		    txq,</a>
<a name="ln1742">		    txq-&gt;axq_qnum,</a>
<a name="ln1743">		    pri,</a>
<a name="ln1744">		    sc-&gt;sc_ac2q[pri],</a>
<a name="ln1745">		    sc-&gt;sc_ac2q[pri]-&gt;axq_qnum);</a>
<a name="ln1746">	}</a>
<a name="ln1747">#endif</a>
<a name="ln1748"> </a>
<a name="ln1749">	/*</a>
<a name="ln1750">	 * Calculate miscellaneous flags.</a>
<a name="ln1751">	 */</a>
<a name="ln1752">	if (ismcast) {</a>
<a name="ln1753">		flags |= HAL_TXDESC_NOACK;	/* no ack on broad/multicast */</a>
<a name="ln1754">	} else if (pktlen &gt; vap-&gt;iv_rtsthreshold &amp;&amp;</a>
<a name="ln1755">	    (ni-&gt;ni_ath_flags &amp; IEEE80211_NODE_FF) == 0) {</a>
<a name="ln1756">		flags |= HAL_TXDESC_RTSENA;	/* RTS based on frame length */</a>
<a name="ln1757">		sc-&gt;sc_stats.ast_tx_rts++;</a>
<a name="ln1758">	}</a>
<a name="ln1759">	if (flags &amp; HAL_TXDESC_NOACK)		/* NB: avoid double counting */</a>
<a name="ln1760">		sc-&gt;sc_stats.ast_tx_noack++;</a>
<a name="ln1761">#ifdef IEEE80211_SUPPORT_TDMA</a>
<a name="ln1762">	if (sc-&gt;sc_tdma &amp;&amp; (flags &amp; HAL_TXDESC_NOACK) == 0) {</a>
<a name="ln1763">		DPRINTF(sc, ATH_DEBUG_TDMA,</a>
<a name="ln1764">		    &quot;%s: discard frame, ACK required w/ TDMA\n&quot;, __func__);</a>
<a name="ln1765">		sc-&gt;sc_stats.ast_tdma_ack++;</a>
<a name="ln1766">		/* XXX free tx dmamap */</a>
<a name="ln1767">		ieee80211_free_mbuf(m0);</a>
<a name="ln1768">		return EIO;</a>
<a name="ln1769">	}</a>
<a name="ln1770">#endif</a>
<a name="ln1771"> </a>
<a name="ln1772">	/*</a>
<a name="ln1773">	 * If it's a frame to do location reporting on,</a>
<a name="ln1774">	 * communicate it to the HAL.</a>
<a name="ln1775">	 */</a>
<a name="ln1776">	if (ieee80211_get_toa_params(m0, NULL)) {</a>
<a name="ln1777">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln1778">		    &quot;%s: setting TX positioning bit\n&quot;, __func__);</a>
<a name="ln1779">		flags |= HAL_TXDESC_POS;</a>
<a name="ln1780"> </a>
<a name="ln1781">		/*</a>
<a name="ln1782">		 * Note: The hardware reports timestamps for</a>
<a name="ln1783">		 * each of the RX'ed packets as part of the packet</a>
<a name="ln1784">		 * exchange.  So this means things like RTS/CTS</a>
<a name="ln1785">		 * exchanges, as well as the final ACK.</a>
<a name="ln1786">		 *</a>
<a name="ln1787">		 * So, if you send a RTS-protected NULL data frame,</a>
<a name="ln1788">		 * you'll get an RX report for the RTS response, then</a>
<a name="ln1789">		 * an RX report for the NULL frame, and then the TX</a>
<a name="ln1790">		 * completion at the end.</a>
<a name="ln1791">		 *</a>
<a name="ln1792">		 * NOTE: it doesn't work right for CCK frames;</a>
<a name="ln1793">		 * there's no channel info data provided unless</a>
<a name="ln1794">		 * it's OFDM or HT.  Will have to dig into it.</a>
<a name="ln1795">		 */</a>
<a name="ln1796">		flags &amp;= ~(HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA);</a>
<a name="ln1797">		bf-&gt;bf_flags |= ATH_BUF_TOA_PROBE;</a>
<a name="ln1798">	}</a>
<a name="ln1799"> </a>
<a name="ln1800">#if 0</a>
<a name="ln1801">	/*</a>
<a name="ln1802">	 * Placeholder: if you want to transmit with the azimuth</a>
<a name="ln1803">	 * timestamp in the end of the payload, here's where you</a>
<a name="ln1804">	 * should set the TXDESC field.</a>
<a name="ln1805">	 */</a>
<a name="ln1806">	flags |= HAL_TXDESC_HWTS;</a>
<a name="ln1807">#endif</a>
<a name="ln1808"> </a>
<a name="ln1809">	/*</a>
<a name="ln1810">	 * Determine if a tx interrupt should be generated for</a>
<a name="ln1811">	 * this descriptor.  We take a tx interrupt to reap</a>
<a name="ln1812">	 * descriptors when the h/w hits an EOL condition or</a>
<a name="ln1813">	 * when the descriptor is specifically marked to generate</a>
<a name="ln1814">	 * an interrupt.  We periodically mark descriptors in this</a>
<a name="ln1815">	 * way to insure timely replenishing of the supply needed</a>
<a name="ln1816">	 * for sending frames.  Defering interrupts reduces system</a>
<a name="ln1817">	 * load and potentially allows more concurrent work to be</a>
<a name="ln1818">	 * done but if done to aggressively can cause senders to</a>
<a name="ln1819">	 * backup.</a>
<a name="ln1820">	 *</a>
<a name="ln1821">	 * NB: use &gt;= to deal with sc_txintrperiod changing</a>
<a name="ln1822">	 *     dynamically through sysctl.</a>
<a name="ln1823">	 */</a>
<a name="ln1824">	if (flags &amp; HAL_TXDESC_INTREQ) {</a>
<a name="ln1825">		txq-&gt;axq_intrcnt = 0;</a>
<a name="ln1826">	} else if (++txq-&gt;axq_intrcnt &gt;= sc-&gt;sc_txintrperiod) {</a>
<a name="ln1827">		flags |= HAL_TXDESC_INTREQ;</a>
<a name="ln1828">		txq-&gt;axq_intrcnt = 0;</a>
<a name="ln1829">	}</a>
<a name="ln1830"> </a>
<a name="ln1831">	/* This point forward is actual TX bits */</a>
<a name="ln1832"> </a>
<a name="ln1833">	/*</a>
<a name="ln1834">	 * At this point we are committed to sending the frame</a>
<a name="ln1835">	 * and we don't need to look at m_nextpkt; clear it in</a>
<a name="ln1836">	 * case this frame is part of frag chain.</a>
<a name="ln1837">	 */</a>
<a name="ln1838">	m0-&gt;m_nextpkt = NULL;</a>
<a name="ln1839"> </a>
<a name="ln1840">	if (IFF_DUMPPKTS(sc, ATH_DEBUG_XMIT))</a>
<a name="ln1841">		ieee80211_dump_pkt(ic, mtod(m0, const uint8_t *), m0-&gt;m_len,</a>
<a name="ln1842">		    sc-&gt;sc_hwmap[rix].ieeerate, -1);</a>
<a name="ln1843"> </a>
<a name="ln1844">	if (ieee80211_radiotap_active_vap(vap)) {</a>
<a name="ln1845">		sc-&gt;sc_tx_th.wt_flags = sc-&gt;sc_hwmap[rix].txflags;</a>
<a name="ln1846">		if (iswep)</a>
<a name="ln1847">			sc-&gt;sc_tx_th.wt_flags |= IEEE80211_RADIOTAP_F_WEP;</a>
<a name="ln1848">		if (isfrag)</a>
<a name="ln1849">			sc-&gt;sc_tx_th.wt_flags |= IEEE80211_RADIOTAP_F_FRAG;</a>
<a name="ln1850">		sc-&gt;sc_tx_th.wt_rate = sc-&gt;sc_hwmap[rix].ieeerate;</a>
<a name="ln1851">		sc-&gt;sc_tx_th.wt_txpower = ieee80211_get_node_txpower(ni);</a>
<a name="ln1852">		sc-&gt;sc_tx_th.wt_antenna = sc-&gt;sc_txantenna;</a>
<a name="ln1853"> </a>
<a name="ln1854">		ieee80211_radiotap_tx(vap, m0);</a>
<a name="ln1855">	}</a>
<a name="ln1856"> </a>
<a name="ln1857">	/* Blank the legacy rate array */</a>
<a name="ln1858">	bzero(&amp;bf-&gt;bf_state.bfs_rc, sizeof(bf-&gt;bf_state.bfs_rc));</a>
<a name="ln1859"> </a>
<a name="ln1860">	/*</a>
<a name="ln1861">	 * ath_buf_set_rate needs at least one rate/try to setup</a>
<a name="ln1862">	 * the rate scenario.</a>
<a name="ln1863">	 */</a>
<a name="ln1864">	bf-&gt;bf_state.bfs_rc[0].rix = rix;</a>
<a name="ln1865">	bf-&gt;bf_state.bfs_rc[0].tries = try0;</a>
<a name="ln1866">	bf-&gt;bf_state.bfs_rc[0].ratecode = txrate;</a>
<a name="ln1867"> </a>
<a name="ln1868">	/* Store the decided rate index values away */</a>
<a name="ln1869">	bf-&gt;bf_state.bfs_pktlen = pktlen;</a>
<a name="ln1870">	bf-&gt;bf_state.bfs_hdrlen = hdrlen;</a>
<a name="ln1871">	bf-&gt;bf_state.bfs_atype = atype;</a>
<a name="ln1872">	bf-&gt;bf_state.bfs_txpower = ieee80211_get_node_txpower(ni);</a>
<a name="ln1873">	bf-&gt;bf_state.bfs_txrate0 = txrate;</a>
<a name="ln1874">	bf-&gt;bf_state.bfs_try0 = try0;</a>
<a name="ln1875">	bf-&gt;bf_state.bfs_keyix = keyix;</a>
<a name="ln1876">	bf-&gt;bf_state.bfs_txantenna = sc-&gt;sc_txantenna;</a>
<a name="ln1877">	bf-&gt;bf_state.bfs_txflags = flags;</a>
<a name="ln1878">	bf-&gt;bf_state.bfs_shpream = shortPreamble;</a>
<a name="ln1879"> </a>
<a name="ln1880">	/* XXX this should be done in ath_tx_setrate() */</a>
<a name="ln1881">	bf-&gt;bf_state.bfs_ctsrate0 = 0;	/* ie, no hard-coded ctsrate */</a>
<a name="ln1882">	bf-&gt;bf_state.bfs_ctsrate = 0;	/* calculated later */</a>
<a name="ln1883">	bf-&gt;bf_state.bfs_ctsduration = 0;</a>
<a name="ln1884">	bf-&gt;bf_state.bfs_ismrr = ismrr;</a>
<a name="ln1885"> </a>
<a name="ln1886">	return 0;</a>
<a name="ln1887">}</a>
<a name="ln1888"> </a>
<a name="ln1889">/*</a>
<a name="ln1890"> * Queue a frame to the hardware or software queue.</a>
<a name="ln1891"> *</a>
<a name="ln1892"> * This can be called by the net80211 code.</a>
<a name="ln1893"> *</a>
<a name="ln1894"> * XXX what about locking? Or, push the seqno assign into the</a>
<a name="ln1895"> * XXX aggregate scheduler so its serialised?</a>
<a name="ln1896"> *</a>
<a name="ln1897"> * XXX When sending management frames via ath_raw_xmit(),</a>
<a name="ln1898"> *     should CLRDMASK be set unconditionally?</a>
<a name="ln1899"> */</a>
<a name="ln1900">int</a>
<a name="ln1901">ath_tx_start(struct ath_softc *sc, struct ieee80211_node *ni,</a>
<a name="ln1902">    struct ath_buf *bf, struct mbuf *m0)</a>
<a name="ln1903">{</a>
<a name="ln1904">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln1905">	struct ath_vap *avp = ATH_VAP(vap);</a>
<a name="ln1906">	int r = 0;</a>
<a name="ln1907">	u_int pri;</a>
<a name="ln1908">	int tid;</a>
<a name="ln1909">	struct ath_txq *txq;</a>
<a name="ln1910">	int ismcast;</a>
<a name="ln1911">	const struct ieee80211_frame *wh;</a>
<a name="ln1912">	int is_ampdu, is_ampdu_tx, is_ampdu_pending;</a>
<a name="ln1913">	ieee80211_seq seqno;</a>
<a name="ln1914">	uint8_t type, subtype;</a>
<a name="ln1915">	int queue_to_head;</a>
<a name="ln1916"> </a>
<a name="ln1917">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln1918"> </a>
<a name="ln1919">	/*</a>
<a name="ln1920">	 * Determine the target hardware queue.</a>
<a name="ln1921">	 *</a>
<a name="ln1922">	 * For multicast frames, the txq gets overridden appropriately</a>
<a name="ln1923">	 * depending upon the state of PS.  If powersave is enabled</a>
<a name="ln1924">	 * then they get added to the cabq for later transmit.</a>
<a name="ln1925">	 *</a>
<a name="ln1926">	 * The &quot;fun&quot; issue here is that group addressed frames should</a>
<a name="ln1927">	 * have the sequence number from a different pool, rather than</a>
<a name="ln1928">	 * the per-TID pool.  That means that even QoS group addressed</a>
<a name="ln1929">	 * frames will have a sequence number from that global value,</a>
<a name="ln1930">	 * which means if we transmit different group addressed frames</a>
<a name="ln1931">	 * at different traffic priorities, the sequence numbers will</a>
<a name="ln1932">	 * all be out of whack.  So - chances are, the right thing</a>
<a name="ln1933">	 * to do here is to always put group addressed frames into the BE</a>
<a name="ln1934">	 * queue, and ignore the TID for queue selection.</a>
<a name="ln1935">	 *</a>
<a name="ln1936">	 * For any other frame, we do a TID/QoS lookup inside the frame</a>
<a name="ln1937">	 * to see what the TID should be. If it's a non-QoS frame, the</a>
<a name="ln1938">	 * AC and TID are overridden. The TID/TXQ code assumes the</a>
<a name="ln1939">	 * TID is on a predictable hardware TXQ, so we don't support</a>
<a name="ln1940">	 * having a node TID queued to multiple hardware TXQs.</a>
<a name="ln1941">	 * This may change in the future but would require some locking</a>
<a name="ln1942">	 * fudgery.</a>
<a name="ln1943">	 */</a>
<a name="ln1944">	pri = ath_tx_getac(sc, m0);</a>
<a name="ln1945">	tid = ath_tx_gettid(sc, m0);</a>
<a name="ln1946"> </a>
<a name="ln1947">	txq = sc-&gt;sc_ac2q[pri];</a>
<a name="ln1948">	wh = mtod(m0, struct ieee80211_frame *);</a>
<a name="ln1949">	ismcast = IEEE80211_IS_MULTICAST(wh-&gt;i_addr1);</a>
<a name="ln1950">	type = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_TYPE_MASK;</a>
<a name="ln1951">	subtype = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_SUBTYPE_MASK;</a>
<a name="ln1952"> </a>
<a name="ln1953">	/*</a>
<a name="ln1954">	 * Enforce how deep the multicast queue can grow.</a>
<a name="ln1955">	 *</a>
<a name="ln1956">	 * XXX duplicated in ath_raw_xmit().</a>
<a name="ln1957">	 */</a>
<a name="ln1958">	if (IEEE80211_IS_MULTICAST(wh-&gt;i_addr1)) {</a>
<a name="ln1959">		if (sc-&gt;sc_cabq-&gt;axq_depth + sc-&gt;sc_cabq-&gt;fifo.axq_depth</a>
<a name="ln1960">		    &gt; sc-&gt;sc_txq_mcastq_maxdepth) {</a>
<a name="ln1961">			sc-&gt;sc_stats.ast_tx_mcastq_overflow++;</a>
<a name="ln1962">			m_freem(m0);</a>
<a name="ln1963">			return (ENOBUFS);</a>
<a name="ln1964">		}</a>
<a name="ln1965">	}</a>
<a name="ln1966"> </a>
<a name="ln1967">	/*</a>
<a name="ln1968">	 * Enforce how deep the unicast queue can grow.</a>
<a name="ln1969">	 *</a>
<a name="ln1970">	 * If the node is in power save then we don't want</a>
<a name="ln1971">	 * the software queue to grow too deep, or a node may</a>
<a name="ln1972">	 * end up consuming all of the ath_buf entries.</a>
<a name="ln1973">	 *</a>
<a name="ln1974">	 * For now, only do this for DATA frames.</a>
<a name="ln1975">	 *</a>
<a name="ln1976">	 * We will want to cap how many management/control</a>
<a name="ln1977">	 * frames get punted to the software queue so it doesn't</a>
<a name="ln1978">	 * fill up.  But the correct solution isn't yet obvious.</a>
<a name="ln1979">	 * In any case, this check should at least let frames pass</a>
<a name="ln1980">	 * that we are direct-dispatching.</a>
<a name="ln1981">	 *</a>
<a name="ln1982">	 * XXX TODO: duplicate this to the raw xmit path!</a>
<a name="ln1983">	 */</a>
<a name="ln1984">	if (type == IEEE80211_FC0_TYPE_DATA &amp;&amp;</a>
<a name="ln1985">	    ATH_NODE(ni)-&gt;an_is_powersave &amp;&amp;</a>
<a name="ln1986">	    ATH_NODE(ni)-&gt;an_swq_depth &gt;</a>
<a name="ln1987">	     sc-&gt;sc_txq_node_psq_maxdepth) {</a>
<a name="ln1988">		sc-&gt;sc_stats.ast_tx_node_psq_overflow++;</a>
<a name="ln1989">		m_freem(m0);</a>
<a name="ln1990">		return (ENOBUFS);</a>
<a name="ln1991">	}</a>
<a name="ln1992"> </a>
<a name="ln1993">	/* A-MPDU TX */</a>
<a name="ln1994">	is_ampdu_tx = ath_tx_ampdu_running(sc, ATH_NODE(ni), tid);</a>
<a name="ln1995">	is_ampdu_pending = ath_tx_ampdu_pending(sc, ATH_NODE(ni), tid);</a>
<a name="ln1996">	is_ampdu = is_ampdu_tx | is_ampdu_pending;</a>
<a name="ln1997"> </a>
<a name="ln1998">	DPRINTF(sc, ATH_DEBUG_SW_TX, &quot;%s: tid=%d, ac=%d, is_ampdu=%d\n&quot;,</a>
<a name="ln1999">	    __func__, tid, pri, is_ampdu);</a>
<a name="ln2000"> </a>
<a name="ln2001">	/* Set local packet state, used to queue packets to hardware */</a>
<a name="ln2002">	bf-&gt;bf_state.bfs_tid = tid;</a>
<a name="ln2003">	bf-&gt;bf_state.bfs_tx_queue = txq-&gt;axq_qnum;</a>
<a name="ln2004">	bf-&gt;bf_state.bfs_pri = pri;</a>
<a name="ln2005"> </a>
<a name="ln2006">#if 1</a>
<a name="ln2007">	/*</a>
<a name="ln2008">	 * When servicing one or more stations in power-save mode</a>
<a name="ln2009">	 * (or) if there is some mcast data waiting on the mcast</a>
<a name="ln2010">	 * queue (to prevent out of order delivery) multicast frames</a>
<a name="ln2011">	 * must be bufferd until after the beacon.</a>
<a name="ln2012">	 *</a>
<a name="ln2013">	 * TODO: we should lock the mcastq before we check the length.</a>
<a name="ln2014">	 */</a>
<a name="ln2015">	if (sc-&gt;sc_cabq_enable &amp;&amp; ismcast &amp;&amp; (vap-&gt;iv_ps_sta || avp-&gt;av_mcastq.axq_depth)) {</a>
<a name="ln2016">		txq = &amp;avp-&gt;av_mcastq;</a>
<a name="ln2017">		/*</a>
<a name="ln2018">		 * Mark the frame as eventually belonging on the CAB</a>
<a name="ln2019">		 * queue, so the descriptor setup functions will</a>
<a name="ln2020">		 * correctly initialise the descriptor 'qcuId' field.</a>
<a name="ln2021">		 */</a>
<a name="ln2022">		bf-&gt;bf_state.bfs_tx_queue = sc-&gt;sc_cabq-&gt;axq_qnum;</a>
<a name="ln2023">	}</a>
<a name="ln2024">#endif</a>
<a name="ln2025"> </a>
<a name="ln2026">	/* Do the generic frame setup */</a>
<a name="ln2027">	/* XXX should just bzero the bf_state? */</a>
<a name="ln2028">	bf-&gt;bf_state.bfs_dobaw = 0;</a>
<a name="ln2029"> </a>
<a name="ln2030">	/* A-MPDU TX? Manually set sequence number */</a>
<a name="ln2031">	/*</a>
<a name="ln2032">	 * Don't do it whilst pending; the net80211 layer still</a>
<a name="ln2033">	 * assigns them.</a>
<a name="ln2034">	 *</a>
<a name="ln2035">	 * Don't assign A-MPDU sequence numbers to group address</a>
<a name="ln2036">	 * frames; they come from a different sequence number space.</a>
<a name="ln2037">	 */</a>
<a name="ln2038">	if (is_ampdu_tx &amp;&amp; (! IEEE80211_IS_MULTICAST(wh-&gt;i_addr1))) {</a>
<a name="ln2039">		/*</a>
<a name="ln2040">		 * Always call; this function will</a>
<a name="ln2041">		 * handle making sure that null data frames</a>
<a name="ln2042">		 * and group-addressed frames don't get a sequence number</a>
<a name="ln2043">		 * from the current TID and thus mess with the BAW.</a>
<a name="ln2044">		 */</a>
<a name="ln2045">		seqno = ath_tx_tid_seqno_assign(sc, ni, bf, m0);</a>
<a name="ln2046"> </a>
<a name="ln2047">		/*</a>
<a name="ln2048">		 * Don't add QoS NULL frames and group-addressed frames</a>
<a name="ln2049">		 * to the BAW.</a>
<a name="ln2050">		 */</a>
<a name="ln2051">		if (IEEE80211_QOS_HAS_SEQ(wh) &amp;&amp;</a>
<a name="ln2052">		    (! IEEE80211_IS_MULTICAST(wh-&gt;i_addr1)) &amp;&amp;</a>
<a name="ln2053">		    (subtype != IEEE80211_FC0_SUBTYPE_QOS_NULL)) {</a>
<a name="ln2054">			bf-&gt;bf_state.bfs_dobaw = 1;</a>
<a name="ln2055">		}</a>
<a name="ln2056">	}</a>
<a name="ln2057"> </a>
<a name="ln2058">	/*</a>
<a name="ln2059">	 * If needed, the sequence number has been assigned.</a>
<a name="ln2060">	 * Squirrel it away somewhere easy to get to.</a>
<a name="ln2061">	 */</a>
<a name="ln2062">	bf-&gt;bf_state.bfs_seqno = M_SEQNO_GET(m0) &lt;&lt; IEEE80211_SEQ_SEQ_SHIFT;</a>
<a name="ln2063"> </a>
<a name="ln2064">	/* Is ampdu pending? fetch the seqno and print it out */</a>
<a name="ln2065">	if (is_ampdu_pending)</a>
<a name="ln2066">		DPRINTF(sc, ATH_DEBUG_SW_TX,</a>
<a name="ln2067">		    &quot;%s: tid %d: ampdu pending, seqno %d\n&quot;,</a>
<a name="ln2068">		    __func__, tid, M_SEQNO_GET(m0));</a>
<a name="ln2069"> </a>
<a name="ln2070">	/* This also sets up the DMA map; crypto; frame parameters, etc */</a>
<a name="ln2071">	r = ath_tx_normal_setup(sc, ni, bf, m0, txq);</a>
<a name="ln2072"> </a>
<a name="ln2073">	if (r != 0)</a>
<a name="ln2074">		goto done;</a>
<a name="ln2075"> </a>
<a name="ln2076">	/* At this point m0 could have changed! */</a>
<a name="ln2077">	m0 = bf-&gt;bf_m;</a>
<a name="ln2078"> </a>
<a name="ln2079">#if 1</a>
<a name="ln2080">	/*</a>
<a name="ln2081">	 * If it's a multicast frame, do a direct-dispatch to the</a>
<a name="ln2082">	 * destination hardware queue. Don't bother software</a>
<a name="ln2083">	 * queuing it.</a>
<a name="ln2084">	 */</a>
<a name="ln2085">	/*</a>
<a name="ln2086">	 * If it's a BAR frame, do a direct dispatch to the</a>
<a name="ln2087">	 * destination hardware queue. Don't bother software</a>
<a name="ln2088">	 * queuing it, as the TID will now be paused.</a>
<a name="ln2089">	 * Sending a BAR frame can occur from the net80211 txa timer</a>
<a name="ln2090">	 * (ie, retries) or from the ath txtask (completion call.)</a>
<a name="ln2091">	 * It queues directly to hardware because the TID is paused</a>
<a name="ln2092">	 * at this point (and won't be unpaused until the BAR has</a>
<a name="ln2093">	 * either been TXed successfully or max retries has been</a>
<a name="ln2094">	 * reached.)</a>
<a name="ln2095">	 */</a>
<a name="ln2096">	/*</a>
<a name="ln2097">	 * Until things are better debugged - if this node is asleep</a>
<a name="ln2098">	 * and we're sending it a non-BAR frame, direct dispatch it.</a>
<a name="ln2099">	 * Why? Because we need to figure out what's actually being</a>
<a name="ln2100">	 * sent - eg, during reassociation/reauthentication after</a>
<a name="ln2101">	 * the node (last) disappeared whilst asleep, the driver should</a>
<a name="ln2102">	 * have unpaused/unsleep'ed the node.  So until that is</a>
<a name="ln2103">	 * sorted out, use this workaround.</a>
<a name="ln2104">	 */</a>
<a name="ln2105">	if (txq == &amp;avp-&gt;av_mcastq) {</a>
<a name="ln2106">		DPRINTF(sc, ATH_DEBUG_SW_TX,</a>
<a name="ln2107">		    &quot;%s: bf=%p: mcastq: TX'ing\n&quot;, __func__, bf);</a>
<a name="ln2108">		bf-&gt;bf_state.bfs_txflags |= HAL_TXDESC_CLRDMASK;</a>
<a name="ln2109">		ath_tx_xmit_normal(sc, txq, bf);</a>
<a name="ln2110">	} else if (ath_tx_should_swq_frame(sc, ATH_NODE(ni), m0,</a>
<a name="ln2111">	    &amp;queue_to_head)) {</a>
<a name="ln2112">		ath_tx_swq(sc, ni, txq, queue_to_head, bf);</a>
<a name="ln2113">	} else {</a>
<a name="ln2114">		bf-&gt;bf_state.bfs_txflags |= HAL_TXDESC_CLRDMASK;</a>
<a name="ln2115">		ath_tx_xmit_normal(sc, txq, bf);</a>
<a name="ln2116">	}</a>
<a name="ln2117">#else</a>
<a name="ln2118">	/*</a>
<a name="ln2119">	 * For now, since there's no software queue,</a>
<a name="ln2120">	 * direct-dispatch to the hardware.</a>
<a name="ln2121">	 */</a>
<a name="ln2122">	bf-&gt;bf_state.bfs_txflags |= HAL_TXDESC_CLRDMASK;</a>
<a name="ln2123">	/*</a>
<a name="ln2124">	 * Update the current leak count if</a>
<a name="ln2125">	 * we're leaking frames; and set the</a>
<a name="ln2126">	 * MORE flag as appropriate.</a>
<a name="ln2127">	 */</a>
<a name="ln2128">	ath_tx_leak_count_update(sc, tid, bf);</a>
<a name="ln2129">	ath_tx_xmit_normal(sc, txq, bf);</a>
<a name="ln2130">#endif</a>
<a name="ln2131">done:</a>
<a name="ln2132">	return 0;</a>
<a name="ln2133">}</a>
<a name="ln2134"> </a>
<a name="ln2135">static int</a>
<a name="ln2136">ath_tx_raw_start(struct ath_softc *sc, struct ieee80211_node *ni,</a>
<a name="ln2137">	struct ath_buf *bf, struct mbuf *m0,</a>
<a name="ln2138">	const struct ieee80211_bpf_params *params)</a>
<a name="ln2139">{</a>
<a name="ln2140">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln2141">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln2142">	int error, ismcast, ismrr;</a>
<a name="ln2143">	int keyix, hdrlen, pktlen, try0, txantenna;</a>
<a name="ln2144">	u_int8_t rix, txrate;</a>
<a name="ln2145">	struct ieee80211_frame *wh;</a>
<a name="ln2146">	u_int flags;</a>
<a name="ln2147">	HAL_PKT_TYPE atype;</a>
<a name="ln2148">	const HAL_RATE_TABLE *rt;</a>
<a name="ln2149">	struct ath_desc *ds;</a>
<a name="ln2150">	u_int pri;</a>
<a name="ln2151">	int o_tid = -1;</a>
<a name="ln2152">	int do_override;</a>
<a name="ln2153">	uint8_t type, subtype;</a>
<a name="ln2154">	int queue_to_head;</a>
<a name="ln2155">	struct ath_node *an = ATH_NODE(ni);</a>
<a name="ln2156"> </a>
<a name="ln2157">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln2158"> </a>
<a name="ln2159">	wh = mtod(m0, struct ieee80211_frame *);</a>
<a name="ln2160">	ismcast = IEEE80211_IS_MULTICAST(wh-&gt;i_addr1);</a>
<a name="ln2161">	hdrlen = ieee80211_anyhdrsize(wh);</a>
<a name="ln2162">	/*</a>
<a name="ln2163">	 * Packet length must not include any</a>
<a name="ln2164">	 * pad bytes; deduct them here.</a>
<a name="ln2165">	 */</a>
<a name="ln2166">	/* XXX honor IEEE80211_BPF_DATAPAD */</a>
<a name="ln2167">	pktlen = m0-&gt;m_pkthdr.len - (hdrlen &amp; 3) + IEEE80211_CRC_LEN;</a>
<a name="ln2168"> </a>
<a name="ln2169">	type = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_TYPE_MASK;</a>
<a name="ln2170">	subtype = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_SUBTYPE_MASK;</a>
<a name="ln2171"> </a>
<a name="ln2172">	ATH_KTR(sc, ATH_KTR_TX, 2,</a>
<a name="ln2173">	     &quot;ath_tx_raw_start: ni=%p, bf=%p, raw&quot;, ni, bf);</a>
<a name="ln2174"> </a>
<a name="ln2175">	DPRINTF(sc, ATH_DEBUG_SW_TX, &quot;%s: ismcast=%d\n&quot;,</a>
<a name="ln2176">	    __func__, ismcast);</a>
<a name="ln2177"> </a>
<a name="ln2178">	pri = params-&gt;ibp_pri &amp; 3;</a>
<a name="ln2179">	/* Override pri if the frame isn't a QoS one */</a>
<a name="ln2180">	if (! IEEE80211_QOS_HAS_SEQ(wh))</a>
<a name="ln2181">		pri = ath_tx_getac(sc, m0);</a>
<a name="ln2182"> </a>
<a name="ln2183">	/* XXX If it's an ADDBA, override the correct queue */</a>
<a name="ln2184">	do_override = ath_tx_action_frame_override_queue(sc, ni, m0, &amp;o_tid);</a>
<a name="ln2185"> </a>
<a name="ln2186">	/* Map ADDBA to the correct priority */</a>
<a name="ln2187">	if (do_override) {</a>
<a name="ln2188">#if 1</a>
<a name="ln2189">		DPRINTF(sc, ATH_DEBUG_XMIT, </a>
<a name="ln2190">		    &quot;%s: overriding tid %d pri %d -&gt; %d\n&quot;,</a>
<a name="ln2191">		    __func__, o_tid, pri, TID_TO_WME_AC(o_tid));</a>
<a name="ln2192">#endif</a>
<a name="ln2193">		pri = TID_TO_WME_AC(o_tid);</a>
<a name="ln2194">	}</a>
<a name="ln2195"> </a>
<a name="ln2196">	/*</a>
<a name="ln2197">	 * &quot;pri&quot; is the hardware queue to transmit on.</a>
<a name="ln2198">	 *</a>
<a name="ln2199">	 * Look at the description in ath_tx_start() to understand</a>
<a name="ln2200">	 * what needs to be &quot;fixed&quot; here so we just use the TID</a>
<a name="ln2201">	 * for QoS frames.</a>
<a name="ln2202">	 */</a>
<a name="ln2203"> </a>
<a name="ln2204">	/* Handle encryption twiddling if needed */</a>
<a name="ln2205">	if (! ath_tx_tag_crypto(sc, ni,</a>
<a name="ln2206">	    m0, params-&gt;ibp_flags &amp; IEEE80211_BPF_CRYPTO, 0,</a>
<a name="ln2207">	    &amp;hdrlen, &amp;pktlen, &amp;keyix)) {</a>
<a name="ln2208">		ieee80211_free_mbuf(m0);</a>
<a name="ln2209">		return EIO;</a>
<a name="ln2210">	}</a>
<a name="ln2211">	/* packet header may have moved, reset our local pointer */</a>
<a name="ln2212">	wh = mtod(m0, struct ieee80211_frame *);</a>
<a name="ln2213"> </a>
<a name="ln2214">	/* Do the generic frame setup */</a>
<a name="ln2215">	/* XXX should just bzero the bf_state? */</a>
<a name="ln2216">	bf-&gt;bf_state.bfs_dobaw = 0;</a>
<a name="ln2217"> </a>
<a name="ln2218">	error = ath_tx_dmasetup(sc, bf, m0);</a>
<a name="ln2219">	if (error != 0)</a>
<a name="ln2220">		return error;</a>
<a name="ln2221">	m0 = bf-&gt;bf_m;				/* NB: may have changed */</a>
<a name="ln2222">	wh = mtod(m0, struct ieee80211_frame *);</a>
<a name="ln2223">	KASSERT((ni != NULL), (&quot;%s: ni=NULL!&quot;, __func__));</a>
<a name="ln2224">	bf-&gt;bf_node = ni;			/* NB: held reference */</a>
<a name="ln2225"> </a>
<a name="ln2226">	/* Always enable CLRDMASK for raw frames for now.. */</a>
<a name="ln2227">	flags = HAL_TXDESC_CLRDMASK;		/* XXX needed for crypto errs */</a>
<a name="ln2228">	flags |= HAL_TXDESC_INTREQ;		/* force interrupt */</a>
<a name="ln2229">	if (params-&gt;ibp_flags &amp; IEEE80211_BPF_RTS)</a>
<a name="ln2230">		flags |= HAL_TXDESC_RTSENA;</a>
<a name="ln2231">	else if (params-&gt;ibp_flags &amp; IEEE80211_BPF_CTS) {</a>
<a name="ln2232">		/* XXX assume 11g/11n protection? */</a>
<a name="ln2233">		bf-&gt;bf_state.bfs_doprot = 1;</a>
<a name="ln2234">		flags |= HAL_TXDESC_CTSENA;</a>
<a name="ln2235">	}</a>
<a name="ln2236">	/* XXX leave ismcast to injector? */</a>
<a name="ln2237">	if ((params-&gt;ibp_flags &amp; IEEE80211_BPF_NOACK) || ismcast)</a>
<a name="ln2238">		flags |= HAL_TXDESC_NOACK;</a>
<a name="ln2239"> </a>
<a name="ln2240">	rt = sc-&gt;sc_currates;</a>
<a name="ln2241">	KASSERT(rt != NULL, (&quot;no rate table, mode %u&quot;, sc-&gt;sc_curmode));</a>
<a name="ln2242"> </a>
<a name="ln2243">	/* Fetch first rate information */</a>
<a name="ln2244">	rix = ath_tx_findrix(sc, params-&gt;ibp_rate0);</a>
<a name="ln2245">	try0 = params-&gt;ibp_try0;</a>
<a name="ln2246"> </a>
<a name="ln2247">	/*</a>
<a name="ln2248">	 * Override EAPOL rate as appropriate.</a>
<a name="ln2249">	 */</a>
<a name="ln2250">	if (m0-&gt;m_flags &amp; M_EAPOL) {</a>
<a name="ln2251">		/* XXX? maybe always use long preamble? */</a>
<a name="ln2252">		rix = an-&gt;an_mgmtrix;</a>
<a name="ln2253">		try0 = ATH_TXMAXTRY;	/* XXX?too many? */</a>
<a name="ln2254">	}</a>
<a name="ln2255"> </a>
<a name="ln2256">	/*</a>
<a name="ln2257">	 * If it's a frame to do location reporting on,</a>
<a name="ln2258">	 * communicate it to the HAL.</a>
<a name="ln2259">	 */</a>
<a name="ln2260">	if (ieee80211_get_toa_params(m0, NULL)) {</a>
<a name="ln2261">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln2262">		    &quot;%s: setting TX positioning bit\n&quot;, __func__);</a>
<a name="ln2263">		flags |= HAL_TXDESC_POS;</a>
<a name="ln2264">		flags &amp;= ~(HAL_TXDESC_RTSENA | HAL_TXDESC_CTSENA);</a>
<a name="ln2265">		bf-&gt;bf_flags |= ATH_BUF_TOA_PROBE;</a>
<a name="ln2266">	}</a>
<a name="ln2267"> </a>
<a name="ln2268">	txrate = rt-&gt;info[rix].rateCode;</a>
<a name="ln2269">	if (params-&gt;ibp_flags &amp; IEEE80211_BPF_SHORTPRE)</a>
<a name="ln2270">		txrate |= rt-&gt;info[rix].shortPreamble;</a>
<a name="ln2271">	sc-&gt;sc_txrix = rix;</a>
<a name="ln2272">	ismrr = (params-&gt;ibp_try1 != 0);</a>
<a name="ln2273">	txantenna = params-&gt;ibp_pri &gt;&gt; 2;</a>
<a name="ln2274">	if (txantenna == 0)			/* XXX? */</a>
<a name="ln2275">		txantenna = sc-&gt;sc_txantenna;</a>
<a name="ln2276"> </a>
<a name="ln2277">	/*</a>
<a name="ln2278">	 * Since ctsrate is fixed, store it away for later</a>
<a name="ln2279">	 * use when the descriptor fields are being set.</a>
<a name="ln2280">	 */</a>
<a name="ln2281">	if (flags &amp; (HAL_TXDESC_RTSENA|HAL_TXDESC_CTSENA))</a>
<a name="ln2282">		bf-&gt;bf_state.bfs_ctsrate0 = params-&gt;ibp_ctsrate;</a>
<a name="ln2283"> </a>
<a name="ln2284">	/*</a>
<a name="ln2285">	 * NB: we mark all packets as type PSPOLL so the h/w won't</a>
<a name="ln2286">	 * set the sequence number, duration, etc.</a>
<a name="ln2287">	 */</a>
<a name="ln2288">	atype = HAL_PKT_TYPE_PSPOLL;</a>
<a name="ln2289"> </a>
<a name="ln2290">	if (IFF_DUMPPKTS(sc, ATH_DEBUG_XMIT))</a>
<a name="ln2291">		ieee80211_dump_pkt(ic, mtod(m0, caddr_t), m0-&gt;m_len,</a>
<a name="ln2292">		    sc-&gt;sc_hwmap[rix].ieeerate, -1);</a>
<a name="ln2293"> </a>
<a name="ln2294">	if (ieee80211_radiotap_active_vap(vap)) {</a>
<a name="ln2295">		sc-&gt;sc_tx_th.wt_flags = sc-&gt;sc_hwmap[rix].txflags;</a>
<a name="ln2296">		if (wh-&gt;i_fc[1] &amp; IEEE80211_FC1_PROTECTED)</a>
<a name="ln2297">			sc-&gt;sc_tx_th.wt_flags |= IEEE80211_RADIOTAP_F_WEP;</a>
<a name="ln2298">		if (m0-&gt;m_flags &amp; M_FRAG)</a>
<a name="ln2299">			sc-&gt;sc_tx_th.wt_flags |= IEEE80211_RADIOTAP_F_FRAG;</a>
<a name="ln2300">		sc-&gt;sc_tx_th.wt_rate = sc-&gt;sc_hwmap[rix].ieeerate;</a>
<a name="ln2301">		sc-&gt;sc_tx_th.wt_txpower = MIN(params-&gt;ibp_power,</a>
<a name="ln2302">		    ieee80211_get_node_txpower(ni));</a>
<a name="ln2303">		sc-&gt;sc_tx_th.wt_antenna = sc-&gt;sc_txantenna;</a>
<a name="ln2304"> </a>
<a name="ln2305">		ieee80211_radiotap_tx(vap, m0);</a>
<a name="ln2306">	}</a>
<a name="ln2307"> </a>
<a name="ln2308">	/*</a>
<a name="ln2309">	 * Formulate first tx descriptor with tx controls.</a>
<a name="ln2310">	 */</a>
<a name="ln2311">	ds = bf-&gt;bf_desc;</a>
<a name="ln2312">	/* XXX check return value? */</a>
<a name="ln2313"> </a>
<a name="ln2314">	/* Store the decided rate index values away */</a>
<a name="ln2315">	bf-&gt;bf_state.bfs_pktlen = pktlen;</a>
<a name="ln2316">	bf-&gt;bf_state.bfs_hdrlen = hdrlen;</a>
<a name="ln2317">	bf-&gt;bf_state.bfs_atype = atype;</a>
<a name="ln2318">	bf-&gt;bf_state.bfs_txpower = MIN(params-&gt;ibp_power,</a>
<a name="ln2319">	    ieee80211_get_node_txpower(ni));</a>
<a name="ln2320">	bf-&gt;bf_state.bfs_txrate0 = txrate;</a>
<a name="ln2321">	bf-&gt;bf_state.bfs_try0 = try0;</a>
<a name="ln2322">	bf-&gt;bf_state.bfs_keyix = keyix;</a>
<a name="ln2323">	bf-&gt;bf_state.bfs_txantenna = txantenna;</a>
<a name="ln2324">	bf-&gt;bf_state.bfs_txflags = flags;</a>
<a name="ln2325">	bf-&gt;bf_state.bfs_shpream =</a>
<a name="ln2326">	    !! (params-&gt;ibp_flags &amp; IEEE80211_BPF_SHORTPRE);</a>
<a name="ln2327"> </a>
<a name="ln2328">	/* Set local packet state, used to queue packets to hardware */</a>
<a name="ln2329">	bf-&gt;bf_state.bfs_tid = WME_AC_TO_TID(pri);</a>
<a name="ln2330">	bf-&gt;bf_state.bfs_tx_queue = sc-&gt;sc_ac2q[pri]-&gt;axq_qnum;</a>
<a name="ln2331">	bf-&gt;bf_state.bfs_pri = pri;</a>
<a name="ln2332"> </a>
<a name="ln2333">	/* XXX this should be done in ath_tx_setrate() */</a>
<a name="ln2334">	bf-&gt;bf_state.bfs_ctsrate = 0;</a>
<a name="ln2335">	bf-&gt;bf_state.bfs_ctsduration = 0;</a>
<a name="ln2336">	bf-&gt;bf_state.bfs_ismrr = ismrr;</a>
<a name="ln2337"> </a>
<a name="ln2338">	/* Blank the legacy rate array */</a>
<a name="ln2339">	bzero(&amp;bf-&gt;bf_state.bfs_rc, sizeof(bf-&gt;bf_state.bfs_rc));</a>
<a name="ln2340"> </a>
<a name="ln2341">	bf-&gt;bf_state.bfs_rc[0].rix = rix;</a>
<a name="ln2342">	bf-&gt;bf_state.bfs_rc[0].tries = try0;</a>
<a name="ln2343">	bf-&gt;bf_state.bfs_rc[0].ratecode = txrate;</a>
<a name="ln2344"> </a>
<a name="ln2345">	if (ismrr) {</a>
<a name="ln2346">		int rix;</a>
<a name="ln2347"> </a>
<a name="ln2348">		rix = ath_tx_findrix(sc, params-&gt;ibp_rate1);</a>
<a name="ln2349">		bf-&gt;bf_state.bfs_rc[1].rix = rix;</a>
<a name="ln2350">		bf-&gt;bf_state.bfs_rc[1].tries = params-&gt;ibp_try1;</a>
<a name="ln2351"> </a>
<a name="ln2352">		rix = ath_tx_findrix(sc, params-&gt;ibp_rate2);</a>
<a name="ln2353">		bf-&gt;bf_state.bfs_rc[2].rix = rix;</a>
<a name="ln2354">		bf-&gt;bf_state.bfs_rc[2].tries = params-&gt;ibp_try2;</a>
<a name="ln2355"> </a>
<a name="ln2356">		rix = ath_tx_findrix(sc, params-&gt;ibp_rate3);</a>
<a name="ln2357">		bf-&gt;bf_state.bfs_rc[3].rix = rix;</a>
<a name="ln2358">		bf-&gt;bf_state.bfs_rc[3].tries = params-&gt;ibp_try3;</a>
<a name="ln2359">	}</a>
<a name="ln2360">	/*</a>
<a name="ln2361">	 * All the required rate control decisions have been made;</a>
<a name="ln2362">	 * fill in the rc flags.</a>
<a name="ln2363">	 */</a>
<a name="ln2364">	ath_tx_rate_fill_rcflags(sc, bf);</a>
<a name="ln2365"> </a>
<a name="ln2366">	/* NB: no buffered multicast in power save support */</a>
<a name="ln2367"> </a>
<a name="ln2368">	/*</a>
<a name="ln2369">	 * If we're overiding the ADDBA destination, dump directly</a>
<a name="ln2370">	 * into the hardware queue, right after any pending</a>
<a name="ln2371">	 * frames to that node are.</a>
<a name="ln2372">	 */</a>
<a name="ln2373">	DPRINTF(sc, ATH_DEBUG_SW_TX, &quot;%s: dooverride=%d\n&quot;,</a>
<a name="ln2374">	    __func__, do_override);</a>
<a name="ln2375"> </a>
<a name="ln2376">#if 1</a>
<a name="ln2377">	/*</a>
<a name="ln2378">	 * Put addba frames in the right place in the right TID/HWQ.</a>
<a name="ln2379">	 */</a>
<a name="ln2380">	if (do_override) {</a>
<a name="ln2381">		bf-&gt;bf_state.bfs_txflags |= HAL_TXDESC_CLRDMASK;</a>
<a name="ln2382">		/*</a>
<a name="ln2383">		 * XXX if it's addba frames, should we be leaking</a>
<a name="ln2384">		 * them out via the frame leak method?</a>
<a name="ln2385">		 * XXX for now let's not risk it; but we may wish</a>
<a name="ln2386">		 * to investigate this later.</a>
<a name="ln2387">		 */</a>
<a name="ln2388">		ath_tx_xmit_normal(sc, sc-&gt;sc_ac2q[pri], bf);</a>
<a name="ln2389">	} else if (ath_tx_should_swq_frame(sc, ATH_NODE(ni), m0,</a>
<a name="ln2390">	    &amp;queue_to_head)) {</a>
<a name="ln2391">		/* Queue to software queue */</a>
<a name="ln2392">		ath_tx_swq(sc, ni, sc-&gt;sc_ac2q[pri], queue_to_head, bf);</a>
<a name="ln2393">	} else {</a>
<a name="ln2394">		bf-&gt;bf_state.bfs_txflags |= HAL_TXDESC_CLRDMASK;</a>
<a name="ln2395">		ath_tx_xmit_normal(sc, sc-&gt;sc_ac2q[pri], bf);</a>
<a name="ln2396">	}</a>
<a name="ln2397">#else</a>
<a name="ln2398">	/* Direct-dispatch to the hardware */</a>
<a name="ln2399">	bf-&gt;bf_state.bfs_txflags |= HAL_TXDESC_CLRDMASK;</a>
<a name="ln2400">	/*</a>
<a name="ln2401">	 * Update the current leak count if</a>
<a name="ln2402">	 * we're leaking frames; and set the</a>
<a name="ln2403">	 * MORE flag as appropriate.</a>
<a name="ln2404">	 */</a>
<a name="ln2405">	ath_tx_leak_count_update(sc, tid, bf);</a>
<a name="ln2406">	ath_tx_xmit_normal(sc, sc-&gt;sc_ac2q[pri], bf);</a>
<a name="ln2407">#endif</a>
<a name="ln2408">	return 0;</a>
<a name="ln2409">}</a>
<a name="ln2410"> </a>
<a name="ln2411">/*</a>
<a name="ln2412"> * Send a raw frame.</a>
<a name="ln2413"> *</a>
<a name="ln2414"> * This can be called by net80211.</a>
<a name="ln2415"> */</a>
<a name="ln2416">int</a>
<a name="ln2417">ath_raw_xmit(struct ieee80211_node *ni, struct mbuf *m,</a>
<a name="ln2418">	const struct ieee80211_bpf_params *params)</a>
<a name="ln2419">{</a>
<a name="ln2420">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln2421">	struct ath_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln2422">	struct ath_buf *bf;</a>
<a name="ln2423">	struct ieee80211_frame *wh = mtod(m, struct ieee80211_frame *);</a>
<a name="ln2424">	int error = 0;</a>
<a name="ln2425"> </a>
<a name="ln2426">	ATH_PCU_LOCK(sc);</a>
<a name="ln2427">	if (sc-&gt;sc_inreset_cnt &gt; 0) {</a>
<a name="ln2428">		DPRINTF(sc, ATH_DEBUG_XMIT, </a>
<a name="ln2429">		    &quot;%s: sc_inreset_cnt &gt; 0; bailing\n&quot;, __func__);</a>
<a name="ln2430">		error = EIO;</a>
<a name="ln2431">		ATH_PCU_UNLOCK(sc);</a>
<a name="ln2432">		goto badbad;</a>
<a name="ln2433">	}</a>
<a name="ln2434">	sc-&gt;sc_txstart_cnt++;</a>
<a name="ln2435">	ATH_PCU_UNLOCK(sc);</a>
<a name="ln2436"> </a>
<a name="ln2437">	/* Wake the hardware up already */</a>
<a name="ln2438">	ATH_LOCK(sc);</a>
<a name="ln2439">	ath_power_set_power_state(sc, HAL_PM_AWAKE);</a>
<a name="ln2440">	ATH_UNLOCK(sc);</a>
<a name="ln2441"> </a>
<a name="ln2442">	ATH_TX_LOCK(sc);</a>
<a name="ln2443"> </a>
<a name="ln2444">	if (!sc-&gt;sc_running || sc-&gt;sc_invalid) {</a>
<a name="ln2445">		DPRINTF(sc, ATH_DEBUG_XMIT, &quot;%s: discard frame, r/i: %d/%d&quot;,</a>
<a name="ln2446">		    __func__, sc-&gt;sc_running, sc-&gt;sc_invalid);</a>
<a name="ln2447">		m_freem(m);</a>
<a name="ln2448">		error = ENETDOWN;</a>
<a name="ln2449">		goto bad;</a>
<a name="ln2450">	}</a>
<a name="ln2451"> </a>
<a name="ln2452">	/*</a>
<a name="ln2453">	 * Enforce how deep the multicast queue can grow.</a>
<a name="ln2454">	 *</a>
<a name="ln2455">	 * XXX duplicated in ath_tx_start().</a>
<a name="ln2456">	 */</a>
<a name="ln2457">	if (IEEE80211_IS_MULTICAST(wh-&gt;i_addr1)) {</a>
<a name="ln2458">		if (sc-&gt;sc_cabq-&gt;axq_depth + sc-&gt;sc_cabq-&gt;fifo.axq_depth</a>
<a name="ln2459">		    &gt; sc-&gt;sc_txq_mcastq_maxdepth) {</a>
<a name="ln2460">			sc-&gt;sc_stats.ast_tx_mcastq_overflow++;</a>
<a name="ln2461">			error = ENOBUFS;</a>
<a name="ln2462">		}</a>
<a name="ln2463"> </a>
<a name="ln2464">		if (error != 0) {</a>
<a name="ln2465">			m_freem(m);</a>
<a name="ln2466">			goto bad;</a>
<a name="ln2467">		}</a>
<a name="ln2468">	}</a>
<a name="ln2469"> </a>
<a name="ln2470">	/*</a>
<a name="ln2471">	 * Grab a TX buffer and associated resources.</a>
<a name="ln2472">	 */</a>
<a name="ln2473">	bf = ath_getbuf(sc, ATH_BUFTYPE_MGMT);</a>
<a name="ln2474">	if (bf == NULL) {</a>
<a name="ln2475">		sc-&gt;sc_stats.ast_tx_nobuf++;</a>
<a name="ln2476">		m_freem(m);</a>
<a name="ln2477">		error = ENOBUFS;</a>
<a name="ln2478">		goto bad;</a>
<a name="ln2479">	}</a>
<a name="ln2480">	ATH_KTR(sc, ATH_KTR_TX, 3, &quot;ath_raw_xmit: m=%p, params=%p, bf=%p\n&quot;,</a>
<a name="ln2481">	    m, params,  bf);</a>
<a name="ln2482"> </a>
<a name="ln2483">	if (params == NULL) {</a>
<a name="ln2484">		/*</a>
<a name="ln2485">		 * Legacy path; interpret frame contents to decide</a>
<a name="ln2486">		 * precisely how to send the frame.</a>
<a name="ln2487">		 */</a>
<a name="ln2488">		if (ath_tx_start(sc, ni, bf, m)) {</a>
<a name="ln2489">			error = EIO;		/* XXX */</a>
<a name="ln2490">			goto bad2;</a>
<a name="ln2491">		}</a>
<a name="ln2492">	} else {</a>
<a name="ln2493">		/*</a>
<a name="ln2494">		 * Caller supplied explicit parameters to use in</a>
<a name="ln2495">		 * sending the frame.</a>
<a name="ln2496">		 */</a>
<a name="ln2497">		if (ath_tx_raw_start(sc, ni, bf, m, params)) {</a>
<a name="ln2498">			error = EIO;		/* XXX */</a>
<a name="ln2499">			goto bad2;</a>
<a name="ln2500">		}</a>
<a name="ln2501">	}</a>
<a name="ln2502">	sc-&gt;sc_wd_timer = 5;</a>
<a name="ln2503">	sc-&gt;sc_stats.ast_tx_raw++;</a>
<a name="ln2504"> </a>
<a name="ln2505">	/*</a>
<a name="ln2506">	 * Update the TIM - if there's anything queued to the</a>
<a name="ln2507">	 * software queue and power save is enabled, we should</a>
<a name="ln2508">	 * set the TIM.</a>
<a name="ln2509">	 */</a>
<a name="ln2510">	ath_tx_update_tim(sc, ni, 1);</a>
<a name="ln2511"> </a>
<a name="ln2512">	ATH_TX_UNLOCK(sc);</a>
<a name="ln2513"> </a>
<a name="ln2514">	ATH_PCU_LOCK(sc);</a>
<a name="ln2515">	sc-&gt;sc_txstart_cnt--;</a>
<a name="ln2516">	ATH_PCU_UNLOCK(sc);</a>
<a name="ln2517"> </a>
<a name="ln2518"> </a>
<a name="ln2519">	/* Put the hardware back to sleep if required */</a>
<a name="ln2520">	ATH_LOCK(sc);</a>
<a name="ln2521">	ath_power_restore_power_state(sc);</a>
<a name="ln2522">	ATH_UNLOCK(sc);</a>
<a name="ln2523"> </a>
<a name="ln2524">	return 0;</a>
<a name="ln2525"> </a>
<a name="ln2526">bad2:</a>
<a name="ln2527">	ATH_KTR(sc, ATH_KTR_TX, 3, &quot;ath_raw_xmit: bad2: m=%p, params=%p, &quot;</a>
<a name="ln2528">	    &quot;bf=%p&quot;,</a>
<a name="ln2529">	    m,</a>
<a name="ln2530">	    params,</a>
<a name="ln2531">	    bf);</a>
<a name="ln2532">	ATH_TXBUF_LOCK(sc);</a>
<a name="ln2533">	ath_returnbuf_head(sc, bf);</a>
<a name="ln2534">	ATH_TXBUF_UNLOCK(sc);</a>
<a name="ln2535"> </a>
<a name="ln2536">bad:</a>
<a name="ln2537">	ATH_TX_UNLOCK(sc);</a>
<a name="ln2538"> </a>
<a name="ln2539">	ATH_PCU_LOCK(sc);</a>
<a name="ln2540">	sc-&gt;sc_txstart_cnt--;</a>
<a name="ln2541">	ATH_PCU_UNLOCK(sc);</a>
<a name="ln2542"> </a>
<a name="ln2543">	/* Put the hardware back to sleep if required */</a>
<a name="ln2544">	ATH_LOCK(sc);</a>
<a name="ln2545">	ath_power_restore_power_state(sc);</a>
<a name="ln2546">	ATH_UNLOCK(sc);</a>
<a name="ln2547"> </a>
<a name="ln2548">badbad:</a>
<a name="ln2549">	ATH_KTR(sc, ATH_KTR_TX, 2, &quot;ath_raw_xmit: bad0: m=%p, params=%p&quot;,</a>
<a name="ln2550">	    m, params);</a>
<a name="ln2551">	sc-&gt;sc_stats.ast_tx_raw_fail++;</a>
<a name="ln2552"> </a>
<a name="ln2553">	return error;</a>
<a name="ln2554">}</a>
<a name="ln2555"> </a>
<a name="ln2556">/* Some helper functions */</a>
<a name="ln2557"> </a>
<a name="ln2558">/*</a>
<a name="ln2559"> * ADDBA (and potentially others) need to be placed in the same</a>
<a name="ln2560"> * hardware queue as the TID/node it's relating to. This is so</a>
<a name="ln2561"> * it goes out after any pending non-aggregate frames to the</a>
<a name="ln2562"> * same node/TID.</a>
<a name="ln2563"> *</a>
<a name="ln2564"> * If this isn't done, the ADDBA can go out before the frames</a>
<a name="ln2565"> * queued in hardware. Even though these frames have a sequence</a>
<a name="ln2566"> * number -earlier- than the ADDBA can be transmitted (but</a>
<a name="ln2567"> * no frames whose sequence numbers are after the ADDBA should</a>
<a name="ln2568"> * be!) they'll arrive after the ADDBA - and the receiving end</a>
<a name="ln2569"> * will simply drop them as being out of the BAW.</a>
<a name="ln2570"> *</a>
<a name="ln2571"> * The frames can't be appended to the TID software queue - it'll</a>
<a name="ln2572"> * never be sent out. So these frames have to be directly</a>
<a name="ln2573"> * dispatched to the hardware, rather than queued in software.</a>
<a name="ln2574"> * So if this function returns true, the TXQ has to be</a>
<a name="ln2575"> * overridden and it has to be directly dispatched.</a>
<a name="ln2576"> *</a>
<a name="ln2577"> * It's a dirty hack, but someone's gotta do it.</a>
<a name="ln2578"> */</a>
<a name="ln2579"> </a>
<a name="ln2580">/*</a>
<a name="ln2581"> * XXX doesn't belong here!</a>
<a name="ln2582"> */</a>
<a name="ln2583">static int</a>
<a name="ln2584">ieee80211_is_action(struct ieee80211_frame *wh)</a>
<a name="ln2585">{</a>
<a name="ln2586">	/* Type: Management frame? */</a>
<a name="ln2587">	if ((wh-&gt;i_fc[0] &amp; IEEE80211_FC0_TYPE_MASK) !=</a>
<a name="ln2588">	    IEEE80211_FC0_TYPE_MGT)</a>
<a name="ln2589">		return 0;</a>
<a name="ln2590"> </a>
<a name="ln2591">	/* Subtype: Action frame? */</a>
<a name="ln2592">	if ((wh-&gt;i_fc[0] &amp; IEEE80211_FC0_SUBTYPE_MASK) !=</a>
<a name="ln2593">	    IEEE80211_FC0_SUBTYPE_ACTION)</a>
<a name="ln2594">		return 0;</a>
<a name="ln2595"> </a>
<a name="ln2596">	return 1;</a>
<a name="ln2597">}</a>
<a name="ln2598"> </a>
<a name="ln2599">#define	MS(_v, _f)	(((_v) &amp; _f) &gt;&gt; _f##_S)</a>
<a name="ln2600">/*</a>
<a name="ln2601"> * Return an alternate TID for ADDBA request frames.</a>
<a name="ln2602"> *</a>
<a name="ln2603"> * Yes, this likely should be done in the net80211 layer.</a>
<a name="ln2604"> */</a>
<a name="ln2605">static int</a>
<a name="ln2606">ath_tx_action_frame_override_queue(struct ath_softc *sc,</a>
<a name="ln2607">    struct ieee80211_node *ni,</a>
<a name="ln2608">    struct mbuf *m0, int *tid)</a>
<a name="ln2609">{</a>
<a name="ln2610">	struct ieee80211_frame *wh = mtod(m0, struct ieee80211_frame *);</a>
<a name="ln2611">	struct ieee80211_action_ba_addbarequest *ia;</a>
<a name="ln2612">	uint8_t *frm;</a>
<a name="ln2613">	uint16_t baparamset;</a>
<a name="ln2614"> </a>
<a name="ln2615">	/* Not action frame? Bail */</a>
<a name="ln2616">	if (! ieee80211_is_action(wh))</a>
<a name="ln2617">		return 0;</a>
<a name="ln2618"> </a>
<a name="ln2619">	/* XXX Not needed for frames we send? */</a>
<a name="ln2620">#if 0</a>
<a name="ln2621">	/* Correct length? */</a>
<a name="ln2622">	if (! ieee80211_parse_action(ni, m))</a>
<a name="ln2623">		return 0;</a>
<a name="ln2624">#endif</a>
<a name="ln2625"> </a>
<a name="ln2626">	/* Extract out action frame */</a>
<a name="ln2627">	frm = (u_int8_t *)&amp;wh[1];</a>
<a name="ln2628">	ia = (struct ieee80211_action_ba_addbarequest *) frm;</a>
<a name="ln2629"> </a>
<a name="ln2630">	/* Not ADDBA? Bail */</a>
<a name="ln2631">	if (ia-&gt;rq_header.ia_category != IEEE80211_ACTION_CAT_BA)</a>
<a name="ln2632">		return 0;</a>
<a name="ln2633">	if (ia-&gt;rq_header.ia_action != IEEE80211_ACTION_BA_ADDBA_REQUEST)</a>
<a name="ln2634">		return 0;</a>
<a name="ln2635"> </a>
<a name="ln2636">	/* Extract TID, return it */</a>
<a name="ln2637">	baparamset = le16toh(ia-&gt;rq_baparamset);</a>
<a name="ln2638">	*tid = (int) MS(baparamset, IEEE80211_BAPS_TID);</a>
<a name="ln2639"> </a>
<a name="ln2640">	return 1;</a>
<a name="ln2641">}</a>
<a name="ln2642">#undef	MS</a>
<a name="ln2643"> </a>
<a name="ln2644">/* Per-node software queue operations */</a>
<a name="ln2645"> </a>
<a name="ln2646">/*</a>
<a name="ln2647"> * Add the current packet to the given BAW.</a>
<a name="ln2648"> * It is assumed that the current packet</a>
<a name="ln2649"> *</a>
<a name="ln2650"> * + fits inside the BAW;</a>
<a name="ln2651"> * + already has had a sequence number allocated.</a>
<a name="ln2652"> *</a>
<a name="ln2653"> * Since the BAW status may be modified by both the ath task and</a>
<a name="ln2654"> * the net80211/ifnet contexts, the TID must be locked.</a>
<a name="ln2655"> */</a>
<a name="ln2656">void</a>
<a name="ln2657">ath_tx_addto_baw(struct ath_softc *sc, struct ath_node *an,</a>
<a name="ln2658">    struct ath_tid *tid, struct ath_buf *bf)</a>
<a name="ln2659">{</a>
<a name="ln2660">	int index, cindex;</a>
<a name="ln2661">	struct ieee80211_tx_ampdu *tap;</a>
<a name="ln2662"> </a>
<a name="ln2663">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln2664"> </a>
<a name="ln2665">	if (bf-&gt;bf_state.bfs_isretried)</a>
<a name="ln2666">		return;</a>
<a name="ln2667"> </a>
<a name="ln2668">	tap = ath_tx_get_tx_tid(an, tid-&gt;tid);</a>
<a name="ln2669"> </a>
<a name="ln2670">	if (! bf-&gt;bf_state.bfs_dobaw) {</a>
<a name="ln2671">		DPRINTF(sc, ATH_DEBUG_SW_TX_BAW,</a>
<a name="ln2672">		    &quot;%s: dobaw=0, seqno=%d, window %d:%d\n&quot;,</a>
<a name="ln2673">		    __func__, SEQNO(bf-&gt;bf_state.bfs_seqno),</a>
<a name="ln2674">		    tap-&gt;txa_start, tap-&gt;txa_wnd);</a>
<a name="ln2675">	}</a>
<a name="ln2676"> </a>
<a name="ln2677">	if (bf-&gt;bf_state.bfs_addedbaw)</a>
<a name="ln2678">		DPRINTF(sc, ATH_DEBUG_SW_TX_BAW,</a>
<a name="ln2679">		    &quot;%s: re-added? tid=%d, seqno %d; window %d:%d; &quot;</a>
<a name="ln2680">		    &quot;baw head=%d tail=%d\n&quot;,</a>
<a name="ln2681">		    __func__, tid-&gt;tid, SEQNO(bf-&gt;bf_state.bfs_seqno),</a>
<a name="ln2682">		    tap-&gt;txa_start, tap-&gt;txa_wnd, tid-&gt;baw_head,</a>
<a name="ln2683">		    tid-&gt;baw_tail);</a>
<a name="ln2684"> </a>
<a name="ln2685">	/*</a>
<a name="ln2686">	 * Verify that the given sequence number is not outside of the</a>
<a name="ln2687">	 * BAW.  Complain loudly if that's the case.</a>
<a name="ln2688">	 */</a>
<a name="ln2689">	if (! BAW_WITHIN(tap-&gt;txa_start, tap-&gt;txa_wnd,</a>
<a name="ln2690">	    SEQNO(bf-&gt;bf_state.bfs_seqno))) {</a>
<a name="ln2691">		DPRINTF(sc, ATH_DEBUG_SW_TX_BAW,</a>
<a name="ln2692">		    &quot;%s: bf=%p: outside of BAW?? tid=%d, seqno %d; window %d:%d; &quot;</a>
<a name="ln2693">		    &quot;baw head=%d tail=%d\n&quot;,</a>
<a name="ln2694">		    __func__, bf, tid-&gt;tid, SEQNO(bf-&gt;bf_state.bfs_seqno),</a>
<a name="ln2695">		    tap-&gt;txa_start, tap-&gt;txa_wnd, tid-&gt;baw_head,</a>
<a name="ln2696">		    tid-&gt;baw_tail);</a>
<a name="ln2697">	}</a>
<a name="ln2698"> </a>
<a name="ln2699">	/*</a>
<a name="ln2700">	 * ni-&gt;ni_txseqs[] is the currently allocated seqno.</a>
<a name="ln2701">	 * the txa state contains the current baw start.</a>
<a name="ln2702">	 */</a>
<a name="ln2703">	index  = ATH_BA_INDEX(tap-&gt;txa_start, SEQNO(bf-&gt;bf_state.bfs_seqno));</a>
<a name="ln2704">	cindex = (tid-&gt;baw_head + index) &amp; (ATH_TID_MAX_BUFS - 1);</a>
<a name="ln2705">	DPRINTF(sc, ATH_DEBUG_SW_TX_BAW,</a>
<a name="ln2706">	    &quot;%s: tid=%d, seqno %d; window %d:%d; index=%d cindex=%d &quot;</a>
<a name="ln2707">	    &quot;baw head=%d tail=%d\n&quot;,</a>
<a name="ln2708">	    __func__, tid-&gt;tid, SEQNO(bf-&gt;bf_state.bfs_seqno),</a>
<a name="ln2709">	    tap-&gt;txa_start, tap-&gt;txa_wnd, index, cindex, tid-&gt;baw_head,</a>
<a name="ln2710">	    tid-&gt;baw_tail);</a>
<a name="ln2711"> </a>
<a name="ln2712"> </a>
<a name="ln2713">#if 0</a>
<a name="ln2714">	assert(tid-&gt;tx_buf[cindex] == NULL);</a>
<a name="ln2715">#endif</a>
<a name="ln2716">	if (tid-&gt;tx_buf[cindex] != NULL) {</a>
<a name="ln2717">		DPRINTF(sc, ATH_DEBUG_SW_TX_BAW,</a>
<a name="ln2718">		    &quot;%s: ba packet dup (index=%d, cindex=%d, &quot;</a>
<a name="ln2719">		    &quot;head=%d, tail=%d)\n&quot;,</a>
<a name="ln2720">		    __func__, index, cindex, tid-&gt;baw_head, tid-&gt;baw_tail);</a>
<a name="ln2721">		DPRINTF(sc, ATH_DEBUG_SW_TX_BAW,</a>
<a name="ln2722">		    &quot;%s: BA bf: %p; seqno=%d ; new bf: %p; seqno=%d\n&quot;,</a>
<a name="ln2723">		    __func__,</a>
<a name="ln2724">		    tid-&gt;tx_buf[cindex],</a>
<a name="ln2725">		    SEQNO(tid-&gt;tx_buf[cindex]-&gt;bf_state.bfs_seqno),</a>
<a name="ln2726">		    bf,</a>
<a name="ln2727">		    SEQNO(bf-&gt;bf_state.bfs_seqno)</a>
<a name="ln2728">		);</a>
<a name="ln2729">	}</a>
<a name="ln2730">	tid-&gt;tx_buf[cindex] = bf;</a>
<a name="ln2731"> </a>
<a name="ln2732">	if (index &gt;= ((tid-&gt;baw_tail - tid-&gt;baw_head) &amp;</a>
<a name="ln2733">	    (ATH_TID_MAX_BUFS - 1))) {</a>
<a name="ln2734">		tid-&gt;baw_tail = cindex;</a>
<a name="ln2735">		INCR(tid-&gt;baw_tail, ATH_TID_MAX_BUFS);</a>
<a name="ln2736">	}</a>
<a name="ln2737">}</a>
<a name="ln2738"> </a>
<a name="ln2739">/*</a>
<a name="ln2740"> * Flip the BAW buffer entry over from the existing one to the new one.</a>
<a name="ln2741"> *</a>
<a name="ln2742"> * When software retransmitting a (sub-)frame, it is entirely possible that</a>
<a name="ln2743"> * the frame ath_buf is marked as BUSY and can't be immediately reused.</a>
<a name="ln2744"> * In that instance the buffer is cloned and the new buffer is used for</a>
<a name="ln2745"> * retransmit. We thus need to update the ath_buf slot in the BAW buf</a>
<a name="ln2746"> * tracking array to maintain consistency.</a>
<a name="ln2747"> */</a>
<a name="ln2748">static void</a>
<a name="ln2749">ath_tx_switch_baw_buf(struct ath_softc *sc, struct ath_node *an,</a>
<a name="ln2750">    struct ath_tid *tid, struct ath_buf *old_bf, struct ath_buf *new_bf)</a>
<a name="ln2751">{</a>
<a name="ln2752">	int index, cindex;</a>
<a name="ln2753">	struct ieee80211_tx_ampdu *tap;</a>
<a name="ln2754">	int seqno = SEQNO(old_bf-&gt;bf_state.bfs_seqno);</a>
<a name="ln2755"> </a>
<a name="ln2756">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln2757"> </a>
<a name="ln2758">	tap = ath_tx_get_tx_tid(an, tid-&gt;tid);</a>
<a name="ln2759">	index  = ATH_BA_INDEX(tap-&gt;txa_start, seqno);</a>
<a name="ln2760">	cindex = (tid-&gt;baw_head + index) &amp; (ATH_TID_MAX_BUFS - 1);</a>
<a name="ln2761"> </a>
<a name="ln2762">	/*</a>
<a name="ln2763">	 * Just warn for now; if it happens then we should find out</a>
<a name="ln2764">	 * about it. It's highly likely the aggregation session will</a>
<a name="ln2765">	 * soon hang.</a>
<a name="ln2766">	 */</a>
<a name="ln2767">	if (old_bf-&gt;bf_state.bfs_seqno != new_bf-&gt;bf_state.bfs_seqno) {</a>
<a name="ln2768">		DPRINTF(sc, ATH_DEBUG_SW_TX_BAW,</a>
<a name="ln2769">		    &quot;%s: retransmitted buffer&quot;</a>
<a name="ln2770">		    &quot; has mismatching seqno's, BA session may hang.\n&quot;,</a>
<a name="ln2771">		    __func__);</a>
<a name="ln2772">		DPRINTF(sc, ATH_DEBUG_SW_TX_BAW,</a>
<a name="ln2773">		    &quot;%s: old seqno=%d, new_seqno=%d\n&quot;, __func__,</a>
<a name="ln2774">		    old_bf-&gt;bf_state.bfs_seqno, new_bf-&gt;bf_state.bfs_seqno);</a>
<a name="ln2775">	}</a>
<a name="ln2776"> </a>
<a name="ln2777">	if (tid-&gt;tx_buf[cindex] != old_bf) {</a>
<a name="ln2778">		DPRINTF(sc, ATH_DEBUG_SW_TX_BAW,</a>
<a name="ln2779">		    &quot;%s: ath_buf pointer incorrect; &quot;</a>
<a name="ln2780">		    &quot; has m BA session may hang.\n&quot;, __func__);</a>
<a name="ln2781">		DPRINTF(sc, ATH_DEBUG_SW_TX_BAW,</a>
<a name="ln2782">		    &quot;%s: old bf=%p, new bf=%p\n&quot;, __func__, old_bf, new_bf);</a>
<a name="ln2783">	}</a>
<a name="ln2784"> </a>
<a name="ln2785">	tid-&gt;tx_buf[cindex] = new_bf;</a>
<a name="ln2786">}</a>
<a name="ln2787"> </a>
<a name="ln2788">/*</a>
<a name="ln2789"> * seq_start - left edge of BAW</a>
<a name="ln2790"> * seq_next - current/next sequence number to allocate</a>
<a name="ln2791"> *</a>
<a name="ln2792"> * Since the BAW status may be modified by both the ath task and</a>
<a name="ln2793"> * the net80211/ifnet contexts, the TID must be locked.</a>
<a name="ln2794"> */</a>
<a name="ln2795">static void</a>
<a name="ln2796">ath_tx_update_baw(struct ath_softc *sc, struct ath_node *an,</a>
<a name="ln2797">    struct ath_tid *tid, const struct ath_buf *bf)</a>
<a name="ln2798">{</a>
<a name="ln2799">	int index, cindex;</a>
<a name="ln2800">	struct ieee80211_tx_ampdu *tap;</a>
<a name="ln2801">	int seqno = SEQNO(bf-&gt;bf_state.bfs_seqno);</a>
<a name="ln2802"> </a>
<a name="ln2803">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln2804"> </a>
<a name="ln2805">	tap = ath_tx_get_tx_tid(an, tid-&gt;tid);</a>
<a name="ln2806">	index  = ATH_BA_INDEX(tap-&gt;txa_start, seqno);</a>
<a name="ln2807">	cindex = (tid-&gt;baw_head + index) &amp; (ATH_TID_MAX_BUFS - 1);</a>
<a name="ln2808"> </a>
<a name="ln2809">	DPRINTF(sc, ATH_DEBUG_SW_TX_BAW,</a>
<a name="ln2810">	    &quot;%s: tid=%d, baw=%d:%d, seqno=%d, index=%d, cindex=%d, &quot;</a>
<a name="ln2811">	    &quot;baw head=%d, tail=%d\n&quot;,</a>
<a name="ln2812">	    __func__, tid-&gt;tid, tap-&gt;txa_start, tap-&gt;txa_wnd, seqno, index,</a>
<a name="ln2813">	    cindex, tid-&gt;baw_head, tid-&gt;baw_tail);</a>
<a name="ln2814"> </a>
<a name="ln2815">	/*</a>
<a name="ln2816">	 * If this occurs then we have a big problem - something else</a>
<a name="ln2817">	 * has slid tap-&gt;txa_start along without updating the BAW</a>
<a name="ln2818">	 * tracking start/end pointers. Thus the TX BAW state is now</a>
<a name="ln2819">	 * completely busted.</a>
<a name="ln2820">	 *</a>
<a name="ln2821">	 * But for now, since I haven't yet fixed TDMA and buffer cloning,</a>
<a name="ln2822">	 * it's quite possible that a cloned buffer is making its way</a>
<a name="ln2823">	 * here and causing it to fire off. Disable TDMA for now.</a>
<a name="ln2824">	 */</a>
<a name="ln2825">	if (tid-&gt;tx_buf[cindex] != bf) {</a>
<a name="ln2826">		DPRINTF(sc, ATH_DEBUG_SW_TX_BAW,</a>
<a name="ln2827">		    &quot;%s: comp bf=%p, seq=%d; slot bf=%p, seqno=%d\n&quot;,</a>
<a name="ln2828">		    __func__, bf, SEQNO(bf-&gt;bf_state.bfs_seqno),</a>
<a name="ln2829">		    tid-&gt;tx_buf[cindex],</a>
<a name="ln2830">		    (tid-&gt;tx_buf[cindex] != NULL) ?</a>
<a name="ln2831">		      SEQNO(tid-&gt;tx_buf[cindex]-&gt;bf_state.bfs_seqno) : -1);</a>
<a name="ln2832">	}</a>
<a name="ln2833"> </a>
<a name="ln2834">	tid-&gt;tx_buf[cindex] = NULL;</a>
<a name="ln2835"> </a>
<a name="ln2836">	while (tid-&gt;baw_head != tid-&gt;baw_tail &amp;&amp;</a>
<a name="ln2837">	    !tid-&gt;tx_buf[tid-&gt;baw_head]) {</a>
<a name="ln2838">		INCR(tap-&gt;txa_start, IEEE80211_SEQ_RANGE);</a>
<a name="ln2839">		INCR(tid-&gt;baw_head, ATH_TID_MAX_BUFS);</a>
<a name="ln2840">	}</a>
<a name="ln2841">	DPRINTF(sc, ATH_DEBUG_SW_TX_BAW,</a>
<a name="ln2842">	    &quot;%s: tid=%d: baw is now %d:%d, baw head=%d\n&quot;,</a>
<a name="ln2843">	    __func__, tid-&gt;tid, tap-&gt;txa_start, tap-&gt;txa_wnd, tid-&gt;baw_head);</a>
<a name="ln2844">}</a>
<a name="ln2845"> </a>
<a name="ln2846">static void</a>
<a name="ln2847">ath_tx_leak_count_update(struct ath_softc *sc, struct ath_tid *tid,</a>
<a name="ln2848">    struct ath_buf *bf)</a>
<a name="ln2849">{</a>
<a name="ln2850">	struct ieee80211_frame *wh;</a>
<a name="ln2851"> </a>
<a name="ln2852">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln2853"> </a>
<a name="ln2854">	if (tid-&gt;an-&gt;an_leak_count &gt; 0) {</a>
<a name="ln2855">		wh = mtod(bf-&gt;bf_m, struct ieee80211_frame *);</a>
<a name="ln2856"> </a>
<a name="ln2857">		/*</a>
<a name="ln2858">		 * Update MORE based on the software/net80211 queue states.</a>
<a name="ln2859">		 */</a>
<a name="ln2860">		if ((tid-&gt;an-&gt;an_stack_psq &gt; 0)</a>
<a name="ln2861">		    || (tid-&gt;an-&gt;an_swq_depth &gt; 0))</a>
<a name="ln2862">			wh-&gt;i_fc[1] |= IEEE80211_FC1_MORE_DATA;</a>
<a name="ln2863">		else</a>
<a name="ln2864">			wh-&gt;i_fc[1] &amp;= ~IEEE80211_FC1_MORE_DATA;</a>
<a name="ln2865"> </a>
<a name="ln2866">		DPRINTF(sc, ATH_DEBUG_NODE_PWRSAVE,</a>
<a name="ln2867">		    &quot;%s: %6D: leak count = %d, psq=%d, swq=%d, MORE=%d\n&quot;,</a>
<a name="ln2868">		    __func__,</a>
<a name="ln2869">		    tid-&gt;an-&gt;an_node.ni_macaddr,</a>
<a name="ln2870">		    &quot;:&quot;,</a>
<a name="ln2871">		    tid-&gt;an-&gt;an_leak_count,</a>
<a name="ln2872">		    tid-&gt;an-&gt;an_stack_psq,</a>
<a name="ln2873">		    tid-&gt;an-&gt;an_swq_depth,</a>
<a name="ln2874">		    !! (wh-&gt;i_fc[1] &amp; IEEE80211_FC1_MORE_DATA));</a>
<a name="ln2875"> </a>
<a name="ln2876">		/*</a>
<a name="ln2877">		 * Re-sync the underlying buffer.</a>
<a name="ln2878">		 */</a>
<a name="ln2879">		bus_dmamap_sync(sc-&gt;sc_dmat, bf-&gt;bf_dmamap,</a>
<a name="ln2880">		    BUS_DMASYNC_PREWRITE);</a>
<a name="ln2881"> </a>
<a name="ln2882">		tid-&gt;an-&gt;an_leak_count --;</a>
<a name="ln2883">	}</a>
<a name="ln2884">}</a>
<a name="ln2885"> </a>
<a name="ln2886">static int</a>
<a name="ln2887">ath_tx_tid_can_tx_or_sched(struct ath_softc *sc, struct ath_tid *tid)</a>
<a name="ln2888">{</a>
<a name="ln2889"> </a>
<a name="ln2890">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln2891"> </a>
<a name="ln2892">	if (tid-&gt;an-&gt;an_leak_count &gt; 0) {</a>
<a name="ln2893">		return (1);</a>
<a name="ln2894">	}</a>
<a name="ln2895">	if (tid-&gt;paused)</a>
<a name="ln2896">		return (0);</a>
<a name="ln2897">	return (1);</a>
<a name="ln2898">}</a>
<a name="ln2899"> </a>
<a name="ln2900">/*</a>
<a name="ln2901"> * Mark the current node/TID as ready to TX.</a>
<a name="ln2902"> *</a>
<a name="ln2903"> * This is done to make it easy for the software scheduler to</a>
<a name="ln2904"> * find which nodes have data to send.</a>
<a name="ln2905"> *</a>
<a name="ln2906"> * The TXQ lock must be held.</a>
<a name="ln2907"> */</a>
<a name="ln2908">void</a>
<a name="ln2909">ath_tx_tid_sched(struct ath_softc *sc, struct ath_tid *tid)</a>
<a name="ln2910">{</a>
<a name="ln2911">	struct ath_txq *txq = sc-&gt;sc_ac2q[tid-&gt;ac];</a>
<a name="ln2912"> </a>
<a name="ln2913">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln2914"> </a>
<a name="ln2915">	/*</a>
<a name="ln2916">	 * If we are leaking out a frame to this destination</a>
<a name="ln2917">	 * for PS-POLL, ensure that we allow scheduling to</a>
<a name="ln2918">	 * occur.</a>
<a name="ln2919">	 */</a>
<a name="ln2920">	if (! ath_tx_tid_can_tx_or_sched(sc, tid))</a>
<a name="ln2921">		return;		/* paused, can't schedule yet */</a>
<a name="ln2922"> </a>
<a name="ln2923">	if (tid-&gt;sched)</a>
<a name="ln2924">		return;		/* already scheduled */</a>
<a name="ln2925"> </a>
<a name="ln2926">	tid-&gt;sched = 1;</a>
<a name="ln2927"> </a>
<a name="ln2928">#if 0</a>
<a name="ln2929">	/*</a>
<a name="ln2930">	 * If this is a sleeping node we're leaking to, given</a>
<a name="ln2931">	 * it a higher priority.  This is so bad for QoS it hurts.</a>
<a name="ln2932">	 */</a>
<a name="ln2933">	if (tid-&gt;an-&gt;an_leak_count) {</a>
<a name="ln2934">		TAILQ_INSERT_HEAD(&amp;txq-&gt;axq_tidq, tid, axq_qelem);</a>
<a name="ln2935">	} else {</a>
<a name="ln2936">		TAILQ_INSERT_TAIL(&amp;txq-&gt;axq_tidq, tid, axq_qelem);</a>
<a name="ln2937">	}</a>
<a name="ln2938">#endif</a>
<a name="ln2939"> </a>
<a name="ln2940">	/*</a>
<a name="ln2941">	 * We can't do the above - it'll confuse the TXQ software</a>
<a name="ln2942">	 * scheduler which will keep checking the _head_ TID</a>
<a name="ln2943">	 * in the list to see if it has traffic.  If we queue</a>
<a name="ln2944">	 * a TID to the head of the list and it doesn't transmit,</a>
<a name="ln2945">	 * we'll check it again.</a>
<a name="ln2946">	 *</a>
<a name="ln2947">	 * So, get the rest of this leaking frames support working</a>
<a name="ln2948">	 * and reliable first and _then_ optimise it so they're</a>
<a name="ln2949">	 * pushed out in front of any other pending software</a>
<a name="ln2950">	 * queued nodes.</a>
<a name="ln2951">	 */</a>
<a name="ln2952">	TAILQ_INSERT_TAIL(&amp;txq-&gt;axq_tidq, tid, axq_qelem);</a>
<a name="ln2953">}</a>
<a name="ln2954"> </a>
<a name="ln2955">/*</a>
<a name="ln2956"> * Mark the current node as no longer needing to be polled for</a>
<a name="ln2957"> * TX packets.</a>
<a name="ln2958"> *</a>
<a name="ln2959"> * The TXQ lock must be held.</a>
<a name="ln2960"> */</a>
<a name="ln2961">static void</a>
<a name="ln2962">ath_tx_tid_unsched(struct ath_softc *sc, struct ath_tid *tid)</a>
<a name="ln2963">{</a>
<a name="ln2964">	struct ath_txq *txq = sc-&gt;sc_ac2q[tid-&gt;ac];</a>
<a name="ln2965"> </a>
<a name="ln2966">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln2967"> </a>
<a name="ln2968">	if (tid-&gt;sched == 0)</a>
<a name="ln2969">		return;</a>
<a name="ln2970"> </a>
<a name="ln2971">	tid-&gt;sched = 0;</a>
<a name="ln2972">	TAILQ_REMOVE(&amp;txq-&gt;axq_tidq, tid, axq_qelem);</a>
<a name="ln2973">}</a>
<a name="ln2974"> </a>
<a name="ln2975">/*</a>
<a name="ln2976"> * Assign a sequence number manually to the given frame.</a>
<a name="ln2977"> *</a>
<a name="ln2978"> * This should only be called for A-MPDU TX frames.</a>
<a name="ln2979"> *</a>
<a name="ln2980"> * Note: for group addressed frames, the sequence number</a>
<a name="ln2981"> * should be from NONQOS_TID, and net80211 should have</a>
<a name="ln2982"> * already assigned it for us.</a>
<a name="ln2983"> */</a>
<a name="ln2984">static ieee80211_seq</a>
<a name="ln2985">ath_tx_tid_seqno_assign(struct ath_softc *sc, struct ieee80211_node *ni,</a>
<a name="ln2986">    struct ath_buf *bf, struct mbuf *m0)</a>
<a name="ln2987">{</a>
<a name="ln2988">	struct ieee80211_frame *wh;</a>
<a name="ln2989">	int tid;</a>
<a name="ln2990">	ieee80211_seq seqno;</a>
<a name="ln2991">	uint8_t subtype;</a>
<a name="ln2992"> </a>
<a name="ln2993">	wh = mtod(m0, struct ieee80211_frame *);</a>
<a name="ln2994">	tid = ieee80211_gettid(wh);</a>
<a name="ln2995"> </a>
<a name="ln2996">	DPRINTF(sc, ATH_DEBUG_SW_TX, &quot;%s: tid=%d, qos has seq=%d\n&quot;,</a>
<a name="ln2997">	    __func__, tid, IEEE80211_QOS_HAS_SEQ(wh));</a>
<a name="ln2998"> </a>
<a name="ln2999">	/* XXX Is it a control frame? Ignore */</a>
<a name="ln3000"> </a>
<a name="ln3001">	/* Does the packet require a sequence number? */</a>
<a name="ln3002">	if (! IEEE80211_QOS_HAS_SEQ(wh))</a>
<a name="ln3003">		return -1;</a>
<a name="ln3004"> </a>
<a name="ln3005">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln3006"> </a>
<a name="ln3007">	/*</a>
<a name="ln3008">	 * Is it a QOS NULL Data frame? Give it a sequence number from</a>
<a name="ln3009">	 * the default TID (IEEE80211_NONQOS_TID.)</a>
<a name="ln3010">	 *</a>
<a name="ln3011">	 * The RX path of everything I've looked at doesn't include the NULL</a>
<a name="ln3012">	 * data frame sequence number in the aggregation state updates, so</a>
<a name="ln3013">	 * assigning it a sequence number there will cause a BAW hole on the</a>
<a name="ln3014">	 * RX side.</a>
<a name="ln3015">	 */</a>
<a name="ln3016">	subtype = wh-&gt;i_fc[0] &amp; IEEE80211_FC0_SUBTYPE_MASK;</a>
<a name="ln3017">	if (subtype == IEEE80211_FC0_SUBTYPE_QOS_NULL) {</a>
<a name="ln3018">		/* XXX no locking for this TID? This is a bit of a problem. */</a>
<a name="ln3019">		seqno = ni-&gt;ni_txseqs[IEEE80211_NONQOS_TID];</a>
<a name="ln3020">		INCR(ni-&gt;ni_txseqs[IEEE80211_NONQOS_TID], IEEE80211_SEQ_RANGE);</a>
<a name="ln3021">	} else if (IEEE80211_IS_MULTICAST(wh-&gt;i_addr1)) {</a>
<a name="ln3022">		/*</a>
<a name="ln3023">		 * group addressed frames get a sequence number from</a>
<a name="ln3024">		 * a different sequence number space.</a>
<a name="ln3025">		 */</a>
<a name="ln3026">		seqno = ni-&gt;ni_txseqs[IEEE80211_NONQOS_TID];</a>
<a name="ln3027">		INCR(ni-&gt;ni_txseqs[IEEE80211_NONQOS_TID], IEEE80211_SEQ_RANGE);</a>
<a name="ln3028">	} else {</a>
<a name="ln3029">		/* Manually assign sequence number */</a>
<a name="ln3030">		seqno = ni-&gt;ni_txseqs[tid];</a>
<a name="ln3031">		INCR(ni-&gt;ni_txseqs[tid], IEEE80211_SEQ_RANGE);</a>
<a name="ln3032">	}</a>
<a name="ln3033">	*(uint16_t *)&amp;wh-&gt;i_seq[0] = htole16(seqno &lt;&lt; IEEE80211_SEQ_SEQ_SHIFT);</a>
<a name="ln3034">	M_SEQNO_SET(m0, seqno);</a>
<a name="ln3035"> </a>
<a name="ln3036">	/* Return so caller can do something with it if needed */</a>
<a name="ln3037">	DPRINTF(sc, ATH_DEBUG_SW_TX,</a>
<a name="ln3038">	    &quot;%s:  -&gt; subtype=0x%x, tid=%d, seqno=%d\n&quot;,</a>
<a name="ln3039">	    __func__, subtype, tid, seqno);</a>
<a name="ln3040">	return seqno;</a>
<a name="ln3041">}</a>
<a name="ln3042"> </a>
<a name="ln3043">/*</a>
<a name="ln3044"> * Attempt to direct dispatch an aggregate frame to hardware.</a>
<a name="ln3045"> * If the frame is out of BAW, queue.</a>
<a name="ln3046"> * Otherwise, schedule it as a single frame.</a>
<a name="ln3047"> */</a>
<a name="ln3048">static void</a>
<a name="ln3049">ath_tx_xmit_aggr(struct ath_softc *sc, struct ath_node *an,</a>
<a name="ln3050">    struct ath_txq *txq, struct ath_buf *bf)</a>
<a name="ln3051">{</a>
<a name="ln3052">	struct ath_tid *tid = &amp;an-&gt;an_tid[bf-&gt;bf_state.bfs_tid];</a>
<a name="ln3053">	struct ieee80211_tx_ampdu *tap;</a>
<a name="ln3054"> </a>
<a name="ln3055">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln3056"> </a>
<a name="ln3057">	tap = ath_tx_get_tx_tid(an, tid-&gt;tid);</a>
<a name="ln3058"> </a>
<a name="ln3059">	/* paused? queue */</a>
<a name="ln3060">	if (! ath_tx_tid_can_tx_or_sched(sc, tid)) {</a>
<a name="ln3061">		ATH_TID_INSERT_HEAD(tid, bf, bf_list);</a>
<a name="ln3062">		/* XXX don't sched - we're paused! */</a>
<a name="ln3063">		return;</a>
<a name="ln3064">	}</a>
<a name="ln3065"> </a>
<a name="ln3066">	/* outside baw? queue */</a>
<a name="ln3067">	if (bf-&gt;bf_state.bfs_dobaw &amp;&amp;</a>
<a name="ln3068">	    (! BAW_WITHIN(tap-&gt;txa_start, tap-&gt;txa_wnd,</a>
<a name="ln3069">	    SEQNO(bf-&gt;bf_state.bfs_seqno)))) {</a>
<a name="ln3070">		ATH_TID_INSERT_HEAD(tid, bf, bf_list);</a>
<a name="ln3071">		ath_tx_tid_sched(sc, tid);</a>
<a name="ln3072">		return;</a>
<a name="ln3073">	}</a>
<a name="ln3074"> </a>
<a name="ln3075">	/*</a>
<a name="ln3076">	 * This is a temporary check and should be removed once</a>
<a name="ln3077">	 * all the relevant code paths have been fixed.</a>
<a name="ln3078">	 *</a>
<a name="ln3079">	 * During aggregate retries, it's possible that the head</a>
<a name="ln3080">	 * frame will fail (which has the bfs_aggr and bfs_nframes</a>
<a name="ln3081">	 * fields set for said aggregate) and will be retried as</a>
<a name="ln3082">	 * a single frame.  In this instance, the values should</a>
<a name="ln3083">	 * be reset or the completion code will get upset with you.</a>
<a name="ln3084">	 */</a>
<a name="ln3085">	if (bf-&gt;bf_state.bfs_aggr != 0 || bf-&gt;bf_state.bfs_nframes &gt; 1) {</a>
<a name="ln3086">		DPRINTF(sc, ATH_DEBUG_SW_TX_AGGR,</a>
<a name="ln3087">		    &quot;%s: bfs_aggr=%d, bfs_nframes=%d\n&quot;, __func__,</a>
<a name="ln3088">		    bf-&gt;bf_state.bfs_aggr, bf-&gt;bf_state.bfs_nframes);</a>
<a name="ln3089">		bf-&gt;bf_state.bfs_aggr = 0;</a>
<a name="ln3090">		bf-&gt;bf_state.bfs_nframes = 1;</a>
<a name="ln3091">	}</a>
<a name="ln3092"> </a>
<a name="ln3093">	/* Update CLRDMASK just before this frame is queued */</a>
<a name="ln3094">	ath_tx_update_clrdmask(sc, tid, bf);</a>
<a name="ln3095"> </a>
<a name="ln3096">	/* Direct dispatch to hardware */</a>
<a name="ln3097">	ath_tx_do_ratelookup(sc, bf);</a>
<a name="ln3098">	ath_tx_calc_duration(sc, bf);</a>
<a name="ln3099">	ath_tx_calc_protection(sc, bf);</a>
<a name="ln3100">	ath_tx_set_rtscts(sc, bf);</a>
<a name="ln3101">	ath_tx_rate_fill_rcflags(sc, bf);</a>
<a name="ln3102">	ath_tx_setds(sc, bf);</a>
<a name="ln3103"> </a>
<a name="ln3104">	/* Statistics */</a>
<a name="ln3105">	sc-&gt;sc_aggr_stats.aggr_low_hwq_single_pkt++;</a>
<a name="ln3106"> </a>
<a name="ln3107">	/* Track per-TID hardware queue depth correctly */</a>
<a name="ln3108">	tid-&gt;hwq_depth++;</a>
<a name="ln3109"> </a>
<a name="ln3110">	/* Add to BAW */</a>
<a name="ln3111">	if (bf-&gt;bf_state.bfs_dobaw) {</a>
<a name="ln3112">		ath_tx_addto_baw(sc, an, tid, bf);</a>
<a name="ln3113">		bf-&gt;bf_state.bfs_addedbaw = 1;</a>
<a name="ln3114">	}</a>
<a name="ln3115"> </a>
<a name="ln3116">	/* Set completion handler, multi-frame aggregate or not */</a>
<a name="ln3117">	bf-&gt;bf_comp = ath_tx_aggr_comp;</a>
<a name="ln3118"> </a>
<a name="ln3119">	/*</a>
<a name="ln3120">	 * Update the current leak count if</a>
<a name="ln3121">	 * we're leaking frames; and set the</a>
<a name="ln3122">	 * MORE flag as appropriate.</a>
<a name="ln3123">	 */</a>
<a name="ln3124">	ath_tx_leak_count_update(sc, tid, bf);</a>
<a name="ln3125"> </a>
<a name="ln3126">	/* Hand off to hardware */</a>
<a name="ln3127">	ath_tx_handoff(sc, txq, bf);</a>
<a name="ln3128">}</a>
<a name="ln3129"> </a>
<a name="ln3130">/*</a>
<a name="ln3131"> * Attempt to send the packet.</a>
<a name="ln3132"> * If the queue isn't busy, direct-dispatch.</a>
<a name="ln3133"> * If the queue is busy enough, queue the given packet on the</a>
<a name="ln3134"> *  relevant software queue.</a>
<a name="ln3135"> */</a>
<a name="ln3136">void</a>
<a name="ln3137">ath_tx_swq(struct ath_softc *sc, struct ieee80211_node *ni,</a>
<a name="ln3138">    struct ath_txq *txq, int queue_to_head, struct ath_buf *bf)</a>
<a name="ln3139">{</a>
<a name="ln3140">	struct ath_node *an = ATH_NODE(ni);</a>
<a name="ln3141">	struct ieee80211_frame *wh;</a>
<a name="ln3142">	struct ath_tid *atid;</a>
<a name="ln3143">	int pri, tid;</a>
<a name="ln3144">	struct mbuf *m0 = bf-&gt;bf_m;</a>
<a name="ln3145"> </a>
<a name="ln3146">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln3147"> </a>
<a name="ln3148">	/* Fetch the TID - non-QoS frames get assigned to TID 16 */</a>
<a name="ln3149">	wh = mtod(m0, struct ieee80211_frame *);</a>
<a name="ln3150">	pri = ath_tx_getac(sc, m0);</a>
<a name="ln3151">	tid = ath_tx_gettid(sc, m0);</a>
<a name="ln3152">	atid = &amp;an-&gt;an_tid[tid];</a>
<a name="ln3153"> </a>
<a name="ln3154">	DPRINTF(sc, ATH_DEBUG_SW_TX, &quot;%s: bf=%p, pri=%d, tid=%d, qos=%d\n&quot;,</a>
<a name="ln3155">	    __func__, bf, pri, tid, IEEE80211_QOS_HAS_SEQ(wh));</a>
<a name="ln3156"> </a>
<a name="ln3157">	/* Set local packet state, used to queue packets to hardware */</a>
<a name="ln3158">	/* XXX potentially duplicate info, re-check */</a>
<a name="ln3159">	bf-&gt;bf_state.bfs_tid = tid;</a>
<a name="ln3160">	bf-&gt;bf_state.bfs_tx_queue = txq-&gt;axq_qnum;</a>
<a name="ln3161">	bf-&gt;bf_state.bfs_pri = pri;</a>
<a name="ln3162"> </a>
<a name="ln3163">	/*</a>
<a name="ln3164">	 * If the hardware queue isn't busy, queue it directly.</a>
<a name="ln3165">	 * If the hardware queue is busy, queue it.</a>
<a name="ln3166">	 * If the TID is paused or the traffic it outside BAW, software</a>
<a name="ln3167">	 * queue it.</a>
<a name="ln3168">	 *</a>
<a name="ln3169">	 * If the node is in power-save and we're leaking a frame,</a>
<a name="ln3170">	 * leak a single frame.</a>
<a name="ln3171">	 */</a>
<a name="ln3172">	if (! ath_tx_tid_can_tx_or_sched(sc, atid)) {</a>
<a name="ln3173">		/* TID is paused, queue */</a>
<a name="ln3174">		DPRINTF(sc, ATH_DEBUG_SW_TX, &quot;%s: paused\n&quot;, __func__);</a>
<a name="ln3175">		/*</a>
<a name="ln3176">		 * If the caller requested that it be sent at a high</a>
<a name="ln3177">		 * priority, queue it at the head of the list.</a>
<a name="ln3178">		 */</a>
<a name="ln3179">		if (queue_to_head)</a>
<a name="ln3180">			ATH_TID_INSERT_HEAD(atid, bf, bf_list);</a>
<a name="ln3181">		else</a>
<a name="ln3182">			ATH_TID_INSERT_TAIL(atid, bf, bf_list);</a>
<a name="ln3183">	} else if (ath_tx_ampdu_pending(sc, an, tid)) {</a>
<a name="ln3184">		/* AMPDU pending; queue */</a>
<a name="ln3185">		DPRINTF(sc, ATH_DEBUG_SW_TX, &quot;%s: pending\n&quot;, __func__);</a>
<a name="ln3186">		ATH_TID_INSERT_TAIL(atid, bf, bf_list);</a>
<a name="ln3187">		/* XXX sched? */</a>
<a name="ln3188">	} else if (ath_tx_ampdu_running(sc, an, tid)) {</a>
<a name="ln3189">		/*</a>
<a name="ln3190">		 * AMPDU running, queue single-frame if the hardware queue</a>
<a name="ln3191">		 * isn't busy.</a>
<a name="ln3192">		 *</a>
<a name="ln3193">		 * If the hardware queue is busy, sending an aggregate frame</a>
<a name="ln3194">		 * then just hold off so we can queue more aggregate frames.</a>
<a name="ln3195">		 *</a>
<a name="ln3196">		 * Otherwise we may end up with single frames leaking through</a>
<a name="ln3197">		 * because we are dispatching them too quickly.</a>
<a name="ln3198">		 *</a>
<a name="ln3199">		 * TODO: maybe we should treat this as two policies - minimise</a>
<a name="ln3200">		 * latency, or maximise throughput.  Then for BE/BK we can</a>
<a name="ln3201">		 * maximise throughput, and VO/VI (if AMPDU is enabled!)</a>
<a name="ln3202">		 * minimise latency.</a>
<a name="ln3203">		 */</a>
<a name="ln3204"> </a>
<a name="ln3205">		/*</a>
<a name="ln3206">		 * Always queue the frame to the tail of the list.</a>
<a name="ln3207">		 */</a>
<a name="ln3208">		ATH_TID_INSERT_TAIL(atid, bf, bf_list);</a>
<a name="ln3209"> </a>
<a name="ln3210">		/*</a>
<a name="ln3211">		 * If the hardware queue isn't busy, direct dispatch</a>
<a name="ln3212">		 * the head frame in the list.</a>
<a name="ln3213">		 *</a>
<a name="ln3214">		 * Note: if we're say, configured to do ADDBA but not A-MPDU</a>
<a name="ln3215">		 * then maybe we want to still queue two non-aggregate frames</a>
<a name="ln3216">		 * to the hardware.  Again with the per-TID policy</a>
<a name="ln3217">		 * configuration..)</a>
<a name="ln3218">		 *</a>
<a name="ln3219">		 * Otherwise, schedule the TID.</a>
<a name="ln3220">		 */</a>
<a name="ln3221">		/* XXX TXQ locking */</a>
<a name="ln3222">		if (txq-&gt;axq_depth + txq-&gt;fifo.axq_depth == 0) {</a>
<a name="ln3223"> </a>
<a name="ln3224">			bf = ATH_TID_FIRST(atid);</a>
<a name="ln3225">			ATH_TID_REMOVE(atid, bf, bf_list);</a>
<a name="ln3226"> </a>
<a name="ln3227">			/*</a>
<a name="ln3228">			 * Ensure it's definitely treated as a non-AMPDU</a>
<a name="ln3229">			 * frame - this information may have been left</a>
<a name="ln3230">			 * over from a previous attempt.</a>
<a name="ln3231">			 */</a>
<a name="ln3232">			bf-&gt;bf_state.bfs_aggr = 0;</a>
<a name="ln3233">			bf-&gt;bf_state.bfs_nframes = 1;</a>
<a name="ln3234"> </a>
<a name="ln3235">			/* Queue to the hardware */</a>
<a name="ln3236">			ath_tx_xmit_aggr(sc, an, txq, bf);</a>
<a name="ln3237">			DPRINTF(sc, ATH_DEBUG_SW_TX,</a>
<a name="ln3238">			    &quot;%s: xmit_aggr\n&quot;,</a>
<a name="ln3239">			    __func__);</a>
<a name="ln3240">		} else {</a>
<a name="ln3241">			DPRINTF(sc, ATH_DEBUG_SW_TX,</a>
<a name="ln3242">			    &quot;%s: ampdu; swq'ing\n&quot;,</a>
<a name="ln3243">			    __func__);</a>
<a name="ln3244"> </a>
<a name="ln3245">			ath_tx_tid_sched(sc, atid);</a>
<a name="ln3246">		}</a>
<a name="ln3247">	/*</a>
<a name="ln3248">	 * If we're not doing A-MPDU, be prepared to direct dispatch</a>
<a name="ln3249">	 * up to both limits if possible.  This particular corner</a>
<a name="ln3250">	 * case may end up with packet starvation between aggregate</a>
<a name="ln3251">	 * traffic and non-aggregate traffic: we want to ensure</a>
<a name="ln3252">	 * that non-aggregate stations get a few frames queued to the</a>
<a name="ln3253">	 * hardware before the aggregate station(s) get their chance.</a>
<a name="ln3254">	 *</a>
<a name="ln3255">	 * So if you only ever see a couple of frames direct dispatched</a>
<a name="ln3256">	 * to the hardware from a non-AMPDU client, check both here</a>
<a name="ln3257">	 * and in the software queue dispatcher to ensure that those</a>
<a name="ln3258">	 * non-AMPDU stations get a fair chance to transmit.</a>
<a name="ln3259">	 */</a>
<a name="ln3260">	/* XXX TXQ locking */</a>
<a name="ln3261">	} else if ((txq-&gt;axq_depth + txq-&gt;fifo.axq_depth &lt; sc-&gt;sc_hwq_limit_nonaggr) &amp;&amp;</a>
<a name="ln3262">		    (txq-&gt;axq_aggr_depth &lt; sc-&gt;sc_hwq_limit_aggr)) {</a>
<a name="ln3263">		/* AMPDU not running, attempt direct dispatch */</a>
<a name="ln3264">		DPRINTF(sc, ATH_DEBUG_SW_TX, &quot;%s: xmit_normal\n&quot;, __func__);</a>
<a name="ln3265">		/* See if clrdmask needs to be set */</a>
<a name="ln3266">		ath_tx_update_clrdmask(sc, atid, bf);</a>
<a name="ln3267"> </a>
<a name="ln3268">		/*</a>
<a name="ln3269">		 * Update the current leak count if</a>
<a name="ln3270">		 * we're leaking frames; and set the</a>
<a name="ln3271">		 * MORE flag as appropriate.</a>
<a name="ln3272">		 */</a>
<a name="ln3273">		ath_tx_leak_count_update(sc, atid, bf);</a>
<a name="ln3274"> </a>
<a name="ln3275">		/*</a>
<a name="ln3276">		 * Dispatch the frame.</a>
<a name="ln3277">		 */</a>
<a name="ln3278">		ath_tx_xmit_normal(sc, txq, bf);</a>
<a name="ln3279">	} else {</a>
<a name="ln3280">		/* Busy; queue */</a>
<a name="ln3281">		DPRINTF(sc, ATH_DEBUG_SW_TX, &quot;%s: swq'ing\n&quot;, __func__);</a>
<a name="ln3282">		ATH_TID_INSERT_TAIL(atid, bf, bf_list);</a>
<a name="ln3283">		ath_tx_tid_sched(sc, atid);</a>
<a name="ln3284">	}</a>
<a name="ln3285">}</a>
<a name="ln3286"> </a>
<a name="ln3287">/*</a>
<a name="ln3288"> * Only set the clrdmask bit if none of the nodes are currently</a>
<a name="ln3289"> * filtered.</a>
<a name="ln3290"> *</a>
<a name="ln3291"> * XXX TODO: go through all the callers and check to see</a>
<a name="ln3292"> * which are being called in the context of looping over all</a>
<a name="ln3293"> * TIDs (eg, if all tids are being paused, resumed, etc.)</a>
<a name="ln3294"> * That'll avoid O(n^2) complexity here.</a>
<a name="ln3295"> */</a>
<a name="ln3296">static void</a>
<a name="ln3297">ath_tx_set_clrdmask(struct ath_softc *sc, struct ath_node *an)</a>
<a name="ln3298">{</a>
<a name="ln3299">	int i;</a>
<a name="ln3300"> </a>
<a name="ln3301">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln3302"> </a>
<a name="ln3303">	for (i = 0; i &lt; IEEE80211_TID_SIZE; i++) {</a>
<a name="ln3304">		if (an-&gt;an_tid[i].isfiltered == 1)</a>
<a name="ln3305">			return;</a>
<a name="ln3306">	}</a>
<a name="ln3307">	an-&gt;clrdmask = 1;</a>
<a name="ln3308">}</a>
<a name="ln3309"> </a>
<a name="ln3310">/*</a>
<a name="ln3311"> * Configure the per-TID node state.</a>
<a name="ln3312"> *</a>
<a name="ln3313"> * This likely belongs in if_ath_node.c but I can't think of anywhere</a>
<a name="ln3314"> * else to put it just yet.</a>
<a name="ln3315"> *</a>
<a name="ln3316"> * This sets up the SLISTs and the mutex as appropriate.</a>
<a name="ln3317"> */</a>
<a name="ln3318">void</a>
<a name="ln3319">ath_tx_tid_init(struct ath_softc *sc, struct ath_node *an)</a>
<a name="ln3320">{</a>
<a name="ln3321">	int i, j;</a>
<a name="ln3322">	struct ath_tid *atid;</a>
<a name="ln3323"> </a>
<a name="ln3324">	for (i = 0; i &lt; IEEE80211_TID_SIZE; i++) {</a>
<a name="ln3325">		atid = &amp;an-&gt;an_tid[i];</a>
<a name="ln3326"> </a>
<a name="ln3327">		/* XXX now with this bzer(), is the field 0'ing needed? */</a>
<a name="ln3328">		bzero(atid, sizeof(*atid));</a>
<a name="ln3329"> </a>
<a name="ln3330">		TAILQ_INIT(&amp;atid-&gt;tid_q);</a>
<a name="ln3331">		TAILQ_INIT(&amp;atid-&gt;filtq.tid_q);</a>
<a name="ln3332">		atid-&gt;tid = i;</a>
<a name="ln3333">		atid-&gt;an = an;</a>
<a name="ln3334">		for (j = 0; j &lt; ATH_TID_MAX_BUFS; j++)</a>
<a name="ln3335">			atid-&gt;tx_buf[j] = NULL;</a>
<a name="ln3336">		atid-&gt;baw_head = atid-&gt;baw_tail = 0;</a>
<a name="ln3337">		atid-&gt;paused = 0;</a>
<a name="ln3338">		atid-&gt;sched = 0;</a>
<a name="ln3339">		atid-&gt;hwq_depth = 0;</a>
<a name="ln3340">		atid-&gt;cleanup_inprogress = 0;</a>
<a name="ln3341">		if (i == IEEE80211_NONQOS_TID)</a>
<a name="ln3342">			atid-&gt;ac = ATH_NONQOS_TID_AC;</a>
<a name="ln3343">		else</a>
<a name="ln3344">			atid-&gt;ac = TID_TO_WME_AC(i);</a>
<a name="ln3345">	}</a>
<a name="ln3346">	an-&gt;clrdmask = 1;	/* Always start by setting this bit */</a>
<a name="ln3347">}</a>
<a name="ln3348"> </a>
<a name="ln3349">/*</a>
<a name="ln3350"> * Pause the current TID. This stops packets from being transmitted</a>
<a name="ln3351"> * on it.</a>
<a name="ln3352"> *</a>
<a name="ln3353"> * Since this is also called from upper layers as well as the driver,</a>
<a name="ln3354"> * it will get the TID lock.</a>
<a name="ln3355"> */</a>
<a name="ln3356">static void</a>
<a name="ln3357">ath_tx_tid_pause(struct ath_softc *sc, struct ath_tid *tid)</a>
<a name="ln3358">{</a>
<a name="ln3359"> </a>
<a name="ln3360">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln3361">	tid-&gt;paused++;</a>
<a name="ln3362">	DPRINTF(sc, ATH_DEBUG_SW_TX_CTRL, &quot;%s: [%6D]: tid=%d, paused = %d\n&quot;,</a>
<a name="ln3363">	    __func__,</a>
<a name="ln3364">	    tid-&gt;an-&gt;an_node.ni_macaddr, &quot;:&quot;,</a>
<a name="ln3365">	    tid-&gt;tid,</a>
<a name="ln3366">	    tid-&gt;paused);</a>
<a name="ln3367">}</a>
<a name="ln3368"> </a>
<a name="ln3369">/*</a>
<a name="ln3370"> * Unpause the current TID, and schedule it if needed.</a>
<a name="ln3371"> */</a>
<a name="ln3372">static void</a>
<a name="ln3373">ath_tx_tid_resume(struct ath_softc *sc, struct ath_tid *tid)</a>
<a name="ln3374">{</a>
<a name="ln3375">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln3376"> </a>
<a name="ln3377">	/*</a>
<a name="ln3378">	 * There's some odd places where ath_tx_tid_resume() is called</a>
<a name="ln3379">	 * when it shouldn't be; this works around that particular issue</a>
<a name="ln3380">	 * until it's actually resolved.</a>
<a name="ln3381">	 */</a>
<a name="ln3382">	if (tid-&gt;paused == 0) {</a>
<a name="ln3383">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln3384">		    &quot;%s: [%6D]: tid=%d, paused=0?\n&quot;,</a>
<a name="ln3385">		    __func__,</a>
<a name="ln3386">		    tid-&gt;an-&gt;an_node.ni_macaddr, &quot;:&quot;,</a>
<a name="ln3387">		    tid-&gt;tid);</a>
<a name="ln3388">	} else {</a>
<a name="ln3389">		tid-&gt;paused--;</a>
<a name="ln3390">	}</a>
<a name="ln3391"> </a>
<a name="ln3392">	DPRINTF(sc, ATH_DEBUG_SW_TX_CTRL,</a>
<a name="ln3393">	    &quot;%s: [%6D]: tid=%d, unpaused = %d\n&quot;,</a>
<a name="ln3394">	    __func__,</a>
<a name="ln3395">	    tid-&gt;an-&gt;an_node.ni_macaddr, &quot;:&quot;,</a>
<a name="ln3396">	    tid-&gt;tid,</a>
<a name="ln3397">	    tid-&gt;paused);</a>
<a name="ln3398"> </a>
<a name="ln3399">	if (tid-&gt;paused)</a>
<a name="ln3400">		return;</a>
<a name="ln3401"> </a>
<a name="ln3402">	/*</a>
<a name="ln3403">	 * Override the clrdmask configuration for the next frame</a>
<a name="ln3404">	 * from this TID, just to get the ball rolling.</a>
<a name="ln3405">	 */</a>
<a name="ln3406">	ath_tx_set_clrdmask(sc, tid-&gt;an);</a>
<a name="ln3407"> </a>
<a name="ln3408">	if (tid-&gt;axq_depth == 0)</a>
<a name="ln3409">		return;</a>
<a name="ln3410"> </a>
<a name="ln3411">	/* XXX isfiltered shouldn't ever be 0 at this point */</a>
<a name="ln3412">	if (tid-&gt;isfiltered == 1) {</a>
<a name="ln3413">		DPRINTF(sc, ATH_DEBUG_SW_TX_CTRL, &quot;%s: filtered?!\n&quot;,</a>
<a name="ln3414">		    __func__);</a>
<a name="ln3415">		return;</a>
<a name="ln3416">	}</a>
<a name="ln3417"> </a>
<a name="ln3418">	ath_tx_tid_sched(sc, tid);</a>
<a name="ln3419"> </a>
<a name="ln3420">	/*</a>
<a name="ln3421">	 * Queue the software TX scheduler.</a>
<a name="ln3422">	 */</a>
<a name="ln3423">	ath_tx_swq_kick(sc);</a>
<a name="ln3424">}</a>
<a name="ln3425"> </a>
<a name="ln3426">/*</a>
<a name="ln3427"> * Add the given ath_buf to the TID filtered frame list.</a>
<a name="ln3428"> * This requires the TID be filtered.</a>
<a name="ln3429"> */</a>
<a name="ln3430">static void</a>
<a name="ln3431">ath_tx_tid_filt_addbuf(struct ath_softc *sc, struct ath_tid *tid,</a>
<a name="ln3432">    struct ath_buf *bf)</a>
<a name="ln3433">{</a>
<a name="ln3434"> </a>
<a name="ln3435">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln3436"> </a>
<a name="ln3437">	if (!tid-&gt;isfiltered)</a>
<a name="ln3438">		DPRINTF(sc, ATH_DEBUG_SW_TX_FILT, &quot;%s: not filtered?!\n&quot;,</a>
<a name="ln3439">		    __func__);</a>
<a name="ln3440"> </a>
<a name="ln3441">	DPRINTF(sc, ATH_DEBUG_SW_TX_FILT, &quot;%s: bf=%p\n&quot;, __func__, bf);</a>
<a name="ln3442"> </a>
<a name="ln3443">	/* Set the retry bit and bump the retry counter */</a>
<a name="ln3444">	ath_tx_set_retry(sc, bf);</a>
<a name="ln3445">	sc-&gt;sc_stats.ast_tx_swfiltered++;</a>
<a name="ln3446"> </a>
<a name="ln3447">	ATH_TID_FILT_INSERT_TAIL(tid, bf, bf_list);</a>
<a name="ln3448">}</a>
<a name="ln3449"> </a>
<a name="ln3450">/*</a>
<a name="ln3451"> * Handle a completed filtered frame from the given TID.</a>
<a name="ln3452"> * This just enables/pauses the filtered frame state if required</a>
<a name="ln3453"> * and appends the filtered frame to the filtered queue.</a>
<a name="ln3454"> */</a>
<a name="ln3455">static void</a>
<a name="ln3456">ath_tx_tid_filt_comp_buf(struct ath_softc *sc, struct ath_tid *tid,</a>
<a name="ln3457">    struct ath_buf *bf)</a>
<a name="ln3458">{</a>
<a name="ln3459"> </a>
<a name="ln3460">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln3461"> </a>
<a name="ln3462">	if (! tid-&gt;isfiltered) {</a>
<a name="ln3463">		DPRINTF(sc, ATH_DEBUG_SW_TX_FILT, &quot;%s: tid=%d; filter transition\n&quot;,</a>
<a name="ln3464">		    __func__, tid-&gt;tid);</a>
<a name="ln3465">		tid-&gt;isfiltered = 1;</a>
<a name="ln3466">		ath_tx_tid_pause(sc, tid);</a>
<a name="ln3467">	}</a>
<a name="ln3468"> </a>
<a name="ln3469">	/* Add the frame to the filter queue */</a>
<a name="ln3470">	ath_tx_tid_filt_addbuf(sc, tid, bf);</a>
<a name="ln3471">}</a>
<a name="ln3472"> </a>
<a name="ln3473">/*</a>
<a name="ln3474"> * Complete the filtered frame TX completion.</a>
<a name="ln3475"> *</a>
<a name="ln3476"> * If there are no more frames in the hardware queue, unpause/unfilter</a>
<a name="ln3477"> * the TID if applicable.  Otherwise we will wait for a node PS transition</a>
<a name="ln3478"> * to unfilter.</a>
<a name="ln3479"> */</a>
<a name="ln3480">static void</a>
<a name="ln3481">ath_tx_tid_filt_comp_complete(struct ath_softc *sc, struct ath_tid *tid)</a>
<a name="ln3482">{</a>
<a name="ln3483">	struct ath_buf *bf;</a>
<a name="ln3484">	int do_resume = 0;</a>
<a name="ln3485"> </a>
<a name="ln3486">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln3487"> </a>
<a name="ln3488">	if (tid-&gt;hwq_depth != 0)</a>
<a name="ln3489">		return;</a>
<a name="ln3490"> </a>
<a name="ln3491">	DPRINTF(sc, ATH_DEBUG_SW_TX_FILT, &quot;%s: tid=%d, hwq=0, transition back\n&quot;,</a>
<a name="ln3492">	    __func__, tid-&gt;tid);</a>
<a name="ln3493">	if (tid-&gt;isfiltered == 1) {</a>
<a name="ln3494">		tid-&gt;isfiltered = 0;</a>
<a name="ln3495">		do_resume = 1;</a>
<a name="ln3496">	}</a>
<a name="ln3497"> </a>
<a name="ln3498">	/* XXX ath_tx_tid_resume() also calls ath_tx_set_clrdmask()! */</a>
<a name="ln3499">	ath_tx_set_clrdmask(sc, tid-&gt;an);</a>
<a name="ln3500"> </a>
<a name="ln3501">	/* XXX this is really quite inefficient */</a>
<a name="ln3502">	while ((bf = ATH_TID_FILT_LAST(tid, ath_bufhead_s)) != NULL) {</a>
<a name="ln3503">		ATH_TID_FILT_REMOVE(tid, bf, bf_list);</a>
<a name="ln3504">		ATH_TID_INSERT_HEAD(tid, bf, bf_list);</a>
<a name="ln3505">	}</a>
<a name="ln3506"> </a>
<a name="ln3507">	/* And only resume if we had paused before */</a>
<a name="ln3508">	if (do_resume)</a>
<a name="ln3509">		ath_tx_tid_resume(sc, tid);</a>
<a name="ln3510">}</a>
<a name="ln3511"> </a>
<a name="ln3512">/*</a>
<a name="ln3513"> * Called when a single (aggregate or otherwise) frame is completed.</a>
<a name="ln3514"> *</a>
<a name="ln3515"> * Returns 0 if the buffer could be added to the filtered list</a>
<a name="ln3516"> * (cloned or otherwise), 1 if the buffer couldn't be added to the</a>
<a name="ln3517"> * filtered list (failed clone; expired retry) and the caller should</a>
<a name="ln3518"> * free it and handle it like a failure (eg by sending a BAR.)</a>
<a name="ln3519"> *</a>
<a name="ln3520"> * since the buffer may be cloned, bf must be not touched after this</a>
<a name="ln3521"> * if the return value is 0.</a>
<a name="ln3522"> */</a>
<a name="ln3523">static int</a>
<a name="ln3524">ath_tx_tid_filt_comp_single(struct ath_softc *sc, struct ath_tid *tid,</a>
<a name="ln3525">    struct ath_buf *bf)</a>
<a name="ln3526">{</a>
<a name="ln3527">	struct ath_buf *nbf;</a>
<a name="ln3528">	int retval;</a>
<a name="ln3529"> </a>
<a name="ln3530">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln3531"> </a>
<a name="ln3532">	/*</a>
<a name="ln3533">	 * Don't allow a filtered frame to live forever.</a>
<a name="ln3534">	 */</a>
<a name="ln3535">	if (bf-&gt;bf_state.bfs_retries &gt; SWMAX_RETRIES) {</a>
<a name="ln3536">		sc-&gt;sc_stats.ast_tx_swretrymax++;</a>
<a name="ln3537">		DPRINTF(sc, ATH_DEBUG_SW_TX_FILT,</a>
<a name="ln3538">		    &quot;%s: bf=%p, seqno=%d, exceeded retries\n&quot;,</a>
<a name="ln3539">		    __func__,</a>
<a name="ln3540">		    bf,</a>
<a name="ln3541">		    SEQNO(bf-&gt;bf_state.bfs_seqno));</a>
<a name="ln3542">		retval = 1; /* error */</a>
<a name="ln3543">		goto finish;</a>
<a name="ln3544">	}</a>
<a name="ln3545"> </a>
<a name="ln3546">	/*</a>
<a name="ln3547">	 * A busy buffer can't be added to the retry list.</a>
<a name="ln3548">	 * It needs to be cloned.</a>
<a name="ln3549">	 */</a>
<a name="ln3550">	if (bf-&gt;bf_flags &amp; ATH_BUF_BUSY) {</a>
<a name="ln3551">		nbf = ath_tx_retry_clone(sc, tid-&gt;an, tid, bf);</a>
<a name="ln3552">		DPRINTF(sc, ATH_DEBUG_SW_TX_FILT,</a>
<a name="ln3553">		    &quot;%s: busy buffer clone: %p -&gt; %p\n&quot;,</a>
<a name="ln3554">		    __func__, bf, nbf);</a>
<a name="ln3555">	} else {</a>
<a name="ln3556">		nbf = bf;</a>
<a name="ln3557">	}</a>
<a name="ln3558"> </a>
<a name="ln3559">	if (nbf == NULL) {</a>
<a name="ln3560">		DPRINTF(sc, ATH_DEBUG_SW_TX_FILT,</a>
<a name="ln3561">		    &quot;%s: busy buffer couldn't be cloned (%p)!\n&quot;,</a>
<a name="ln3562">		    __func__, bf);</a>
<a name="ln3563">		retval = 1; /* error */</a>
<a name="ln3564">	} else {</a>
<a name="ln3565">		ath_tx_tid_filt_comp_buf(sc, tid, nbf);</a>
<a name="ln3566">		retval = 0; /* ok */</a>
<a name="ln3567">	}</a>
<a name="ln3568">finish:</a>
<a name="ln3569">	ath_tx_tid_filt_comp_complete(sc, tid);</a>
<a name="ln3570"> </a>
<a name="ln3571">	return (retval);</a>
<a name="ln3572">}</a>
<a name="ln3573"> </a>
<a name="ln3574">static void</a>
<a name="ln3575">ath_tx_tid_filt_comp_aggr(struct ath_softc *sc, struct ath_tid *tid,</a>
<a name="ln3576">    struct ath_buf *bf_first, ath_bufhead *bf_q)</a>
<a name="ln3577">{</a>
<a name="ln3578">	struct ath_buf *bf, *bf_next, *nbf;</a>
<a name="ln3579"> </a>
<a name="ln3580">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln3581"> </a>
<a name="ln3582">	bf = bf_first;</a>
<a name="ln3583">	while (bf) {</a>
<a name="ln3584">		bf_next = bf-&gt;bf_next;</a>
<a name="ln3585">		bf-&gt;bf_next = NULL;	/* Remove it from the aggr list */</a>
<a name="ln3586"> </a>
<a name="ln3587">		/*</a>
<a name="ln3588">		 * Don't allow a filtered frame to live forever.</a>
<a name="ln3589">		 */</a>
<a name="ln3590">		if (bf-&gt;bf_state.bfs_retries &gt; SWMAX_RETRIES) {</a>
<a name="ln3591">			sc-&gt;sc_stats.ast_tx_swretrymax++;</a>
<a name="ln3592">			DPRINTF(sc, ATH_DEBUG_SW_TX_FILT,</a>
<a name="ln3593">			    &quot;%s: tid=%d, bf=%p, seqno=%d, exceeded retries\n&quot;,</a>
<a name="ln3594">			    __func__,</a>
<a name="ln3595">			    tid-&gt;tid,</a>
<a name="ln3596">			    bf,</a>
<a name="ln3597">			    SEQNO(bf-&gt;bf_state.bfs_seqno));</a>
<a name="ln3598">			TAILQ_INSERT_TAIL(bf_q, bf, bf_list);</a>
<a name="ln3599">			goto next;</a>
<a name="ln3600">		}</a>
<a name="ln3601"> </a>
<a name="ln3602">		if (bf-&gt;bf_flags &amp; ATH_BUF_BUSY) {</a>
<a name="ln3603">			nbf = ath_tx_retry_clone(sc, tid-&gt;an, tid, bf);</a>
<a name="ln3604">			DPRINTF(sc, ATH_DEBUG_SW_TX_FILT,</a>
<a name="ln3605">			    &quot;%s: tid=%d, busy buffer cloned: %p -&gt; %p, seqno=%d\n&quot;,</a>
<a name="ln3606">			    __func__, tid-&gt;tid, bf, nbf, SEQNO(bf-&gt;bf_state.bfs_seqno));</a>
<a name="ln3607">		} else {</a>
<a name="ln3608">			nbf = bf;</a>
<a name="ln3609">		}</a>
<a name="ln3610"> </a>
<a name="ln3611">		/*</a>
<a name="ln3612">		 * If the buffer couldn't be cloned, add it to bf_q;</a>
<a name="ln3613">		 * the caller will free the buffer(s) as required.</a>
<a name="ln3614">		 */</a>
<a name="ln3615">		if (nbf == NULL) {</a>
<a name="ln3616">			DPRINTF(sc, ATH_DEBUG_SW_TX_FILT,</a>
<a name="ln3617">			    &quot;%s: tid=%d, buffer couldn't be cloned! (%p) seqno=%d\n&quot;,</a>
<a name="ln3618">			    __func__, tid-&gt;tid, bf, SEQNO(bf-&gt;bf_state.bfs_seqno));</a>
<a name="ln3619">			TAILQ_INSERT_TAIL(bf_q, bf, bf_list);</a>
<a name="ln3620">		} else {</a>
<a name="ln3621">			ath_tx_tid_filt_comp_buf(sc, tid, nbf);</a>
<a name="ln3622">		}</a>
<a name="ln3623">next:</a>
<a name="ln3624">		bf = bf_next;</a>
<a name="ln3625">	}</a>
<a name="ln3626"> </a>
<a name="ln3627">	ath_tx_tid_filt_comp_complete(sc, tid);</a>
<a name="ln3628">}</a>
<a name="ln3629"> </a>
<a name="ln3630">/*</a>
<a name="ln3631"> * Suspend the queue because we need to TX a BAR.</a>
<a name="ln3632"> */</a>
<a name="ln3633">static void</a>
<a name="ln3634">ath_tx_tid_bar_suspend(struct ath_softc *sc, struct ath_tid *tid)</a>
<a name="ln3635">{</a>
<a name="ln3636"> </a>
<a name="ln3637">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln3638"> </a>
<a name="ln3639">	DPRINTF(sc, ATH_DEBUG_SW_TX_BAR,</a>
<a name="ln3640">	    &quot;%s: tid=%d, bar_wait=%d, bar_tx=%d, called\n&quot;,</a>
<a name="ln3641">	    __func__,</a>
<a name="ln3642">	    tid-&gt;tid,</a>
<a name="ln3643">	    tid-&gt;bar_wait,</a>
<a name="ln3644">	    tid-&gt;bar_tx);</a>
<a name="ln3645"> </a>
<a name="ln3646">	/* We shouldn't be called when bar_tx is 1 */</a>
<a name="ln3647">	if (tid-&gt;bar_tx) {</a>
<a name="ln3648">		DPRINTF(sc, ATH_DEBUG_SW_TX_BAR,</a>
<a name="ln3649">		    &quot;%s: bar_tx is 1?!\n&quot;, __func__);</a>
<a name="ln3650">	}</a>
<a name="ln3651"> </a>
<a name="ln3652">	/* If we've already been called, just be patient. */</a>
<a name="ln3653">	if (tid-&gt;bar_wait)</a>
<a name="ln3654">		return;</a>
<a name="ln3655"> </a>
<a name="ln3656">	/* Wait! */</a>
<a name="ln3657">	tid-&gt;bar_wait = 1;</a>
<a name="ln3658"> </a>
<a name="ln3659">	/* Only one pause, no matter how many frames fail */</a>
<a name="ln3660">	ath_tx_tid_pause(sc, tid);</a>
<a name="ln3661">}</a>
<a name="ln3662"> </a>
<a name="ln3663">/*</a>
<a name="ln3664"> * We've finished with BAR handling - either we succeeded or</a>
<a name="ln3665"> * failed. Either way, unsuspend TX.</a>
<a name="ln3666"> */</a>
<a name="ln3667">static void</a>
<a name="ln3668">ath_tx_tid_bar_unsuspend(struct ath_softc *sc, struct ath_tid *tid)</a>
<a name="ln3669">{</a>
<a name="ln3670"> </a>
<a name="ln3671">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln3672"> </a>
<a name="ln3673">	DPRINTF(sc, ATH_DEBUG_SW_TX_BAR,</a>
<a name="ln3674">	    &quot;%s: %6D: TID=%d, called\n&quot;,</a>
<a name="ln3675">	    __func__,</a>
<a name="ln3676">	    tid-&gt;an-&gt;an_node.ni_macaddr,</a>
<a name="ln3677">	    &quot;:&quot;,</a>
<a name="ln3678">	    tid-&gt;tid);</a>
<a name="ln3679"> </a>
<a name="ln3680">	if (tid-&gt;bar_tx == 0 || tid-&gt;bar_wait == 0) {</a>
<a name="ln3681">		DPRINTF(sc, ATH_DEBUG_SW_TX_BAR,</a>
<a name="ln3682">		    &quot;%s: %6D: TID=%d, bar_tx=%d, bar_wait=%d: ?\n&quot;,</a>
<a name="ln3683">		    __func__, tid-&gt;an-&gt;an_node.ni_macaddr, &quot;:&quot;,</a>
<a name="ln3684">		    tid-&gt;tid, tid-&gt;bar_tx, tid-&gt;bar_wait);</a>
<a name="ln3685">	}</a>
<a name="ln3686"> </a>
<a name="ln3687">	tid-&gt;bar_tx = tid-&gt;bar_wait = 0;</a>
<a name="ln3688">	ath_tx_tid_resume(sc, tid);</a>
<a name="ln3689">}</a>
<a name="ln3690"> </a>
<a name="ln3691">/*</a>
<a name="ln3692"> * Return whether we're ready to TX a BAR frame.</a>
<a name="ln3693"> *</a>
<a name="ln3694"> * Requires the TID lock be held.</a>
<a name="ln3695"> */</a>
<a name="ln3696">static int</a>
<a name="ln3697">ath_tx_tid_bar_tx_ready(struct ath_softc *sc, struct ath_tid *tid)</a>
<a name="ln3698">{</a>
<a name="ln3699"> </a>
<a name="ln3700">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln3701"> </a>
<a name="ln3702">	if (tid-&gt;bar_wait == 0 || tid-&gt;hwq_depth &gt; 0)</a>
<a name="ln3703">		return (0);</a>
<a name="ln3704"> </a>
<a name="ln3705">	DPRINTF(sc, ATH_DEBUG_SW_TX_BAR,</a>
<a name="ln3706">	    &quot;%s: %6D: TID=%d, bar ready\n&quot;,</a>
<a name="ln3707">	    __func__,</a>
<a name="ln3708">	    tid-&gt;an-&gt;an_node.ni_macaddr,</a>
<a name="ln3709">	    &quot;:&quot;,</a>
<a name="ln3710">	    tid-&gt;tid);</a>
<a name="ln3711"> </a>
<a name="ln3712">	return (1);</a>
<a name="ln3713">}</a>
<a name="ln3714"> </a>
<a name="ln3715">/*</a>
<a name="ln3716"> * Check whether the current TID is ready to have a BAR</a>
<a name="ln3717"> * TXed and if so, do the TX.</a>
<a name="ln3718"> *</a>
<a name="ln3719"> * Since the TID/TXQ lock can't be held during a call to</a>
<a name="ln3720"> * ieee80211_send_bar(), we have to do the dirty thing of unlocking it,</a>
<a name="ln3721"> * sending the BAR and locking it again.</a>
<a name="ln3722"> *</a>
<a name="ln3723"> * Eventually, the code to send the BAR should be broken out</a>
<a name="ln3724"> * from this routine so the lock doesn't have to be reacquired</a>
<a name="ln3725"> * just to be immediately dropped by the caller.</a>
<a name="ln3726"> */</a>
<a name="ln3727">static void</a>
<a name="ln3728">ath_tx_tid_bar_tx(struct ath_softc *sc, struct ath_tid *tid)</a>
<a name="ln3729">{</a>
<a name="ln3730">	struct ieee80211_tx_ampdu *tap;</a>
<a name="ln3731"> </a>
<a name="ln3732">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln3733"> </a>
<a name="ln3734">	DPRINTF(sc, ATH_DEBUG_SW_TX_BAR,</a>
<a name="ln3735">	    &quot;%s: %6D: TID=%d, called\n&quot;,</a>
<a name="ln3736">	    __func__,</a>
<a name="ln3737">	    tid-&gt;an-&gt;an_node.ni_macaddr,</a>
<a name="ln3738">	    &quot;:&quot;,</a>
<a name="ln3739">	    tid-&gt;tid);</a>
<a name="ln3740"> </a>
<a name="ln3741">	tap = ath_tx_get_tx_tid(tid-&gt;an, tid-&gt;tid);</a>
<a name="ln3742"> </a>
<a name="ln3743">	/*</a>
<a name="ln3744">	 * This is an error condition!</a>
<a name="ln3745">	 */</a>
<a name="ln3746">	if (tid-&gt;bar_wait == 0 || tid-&gt;bar_tx == 1) {</a>
<a name="ln3747">		DPRINTF(sc, ATH_DEBUG_SW_TX_BAR,</a>
<a name="ln3748">		    &quot;%s: %6D: TID=%d, bar_tx=%d, bar_wait=%d: ?\n&quot;,</a>
<a name="ln3749">		    __func__, tid-&gt;an-&gt;an_node.ni_macaddr, &quot;:&quot;,</a>
<a name="ln3750">		    tid-&gt;tid, tid-&gt;bar_tx, tid-&gt;bar_wait);</a>
<a name="ln3751">		return;</a>
<a name="ln3752">	}</a>
<a name="ln3753"> </a>
<a name="ln3754">	/* Don't do anything if we still have pending frames */</a>
<a name="ln3755">	if (tid-&gt;hwq_depth &gt; 0) {</a>
<a name="ln3756">		DPRINTF(sc, ATH_DEBUG_SW_TX_BAR,</a>
<a name="ln3757">		    &quot;%s: %6D: TID=%d, hwq_depth=%d, waiting\n&quot;,</a>
<a name="ln3758">		    __func__,</a>
<a name="ln3759">		    tid-&gt;an-&gt;an_node.ni_macaddr,</a>
<a name="ln3760">		    &quot;:&quot;,</a>
<a name="ln3761">		    tid-&gt;tid,</a>
<a name="ln3762">		    tid-&gt;hwq_depth);</a>
<a name="ln3763">		return;</a>
<a name="ln3764">	}</a>
<a name="ln3765"> </a>
<a name="ln3766">	/* We're now about to TX */</a>
<a name="ln3767">	tid-&gt;bar_tx = 1;</a>
<a name="ln3768"> </a>
<a name="ln3769">	/*</a>
<a name="ln3770">	 * Override the clrdmask configuration for the next frame,</a>
<a name="ln3771">	 * just to get the ball rolling.</a>
<a name="ln3772">	 */</a>
<a name="ln3773">	ath_tx_set_clrdmask(sc, tid-&gt;an);</a>
<a name="ln3774"> </a>
<a name="ln3775">	/*</a>
<a name="ln3776">	 * Calculate new BAW left edge, now that all frames have either</a>
<a name="ln3777">	 * succeeded or failed.</a>
<a name="ln3778">	 *</a>
<a name="ln3779">	 * XXX verify this is _actually_ the valid value to begin at!</a>
<a name="ln3780">	 */</a>
<a name="ln3781">	DPRINTF(sc, ATH_DEBUG_SW_TX_BAR,</a>
<a name="ln3782">	    &quot;%s: %6D: TID=%d, new BAW left edge=%d\n&quot;,</a>
<a name="ln3783">	    __func__,</a>
<a name="ln3784">	    tid-&gt;an-&gt;an_node.ni_macaddr,</a>
<a name="ln3785">	    &quot;:&quot;,</a>
<a name="ln3786">	    tid-&gt;tid,</a>
<a name="ln3787">	    tap-&gt;txa_start);</a>
<a name="ln3788"> </a>
<a name="ln3789">	/* Try sending the BAR frame */</a>
<a name="ln3790">	/* We can't hold the lock here! */</a>
<a name="ln3791"> </a>
<a name="ln3792">	ATH_TX_UNLOCK(sc);</a>
<a name="ln3793">	if (ieee80211_send_bar(&amp;tid-&gt;an-&gt;an_node, tap, tap-&gt;txa_start) == 0) {</a>
<a name="ln3794">		/* Success? Now we wait for notification that it's done */</a>
<a name="ln3795">		ATH_TX_LOCK(sc);</a>
<a name="ln3796">		return;</a>
<a name="ln3797">	}</a>
<a name="ln3798"> </a>
<a name="ln3799">	/* Failure? For now, warn loudly and continue */</a>
<a name="ln3800">	ATH_TX_LOCK(sc);</a>
<a name="ln3801">	DPRINTF(sc, ATH_DEBUG_SW_TX_BAR,</a>
<a name="ln3802">	    &quot;%s: %6D: TID=%d, failed to TX BAR, continue!\n&quot;,</a>
<a name="ln3803">	    __func__, tid-&gt;an-&gt;an_node.ni_macaddr, &quot;:&quot;,</a>
<a name="ln3804">	    tid-&gt;tid);</a>
<a name="ln3805">	ath_tx_tid_bar_unsuspend(sc, tid);</a>
<a name="ln3806">}</a>
<a name="ln3807"> </a>
<a name="ln3808">static void</a>
<a name="ln3809">ath_tx_tid_drain_pkt(struct ath_softc *sc, struct ath_node *an,</a>
<a name="ln3810">    struct ath_tid *tid, ath_bufhead *bf_cq, struct ath_buf *bf)</a>
<a name="ln3811">{</a>
<a name="ln3812"> </a>
<a name="ln3813">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln3814"> </a>
<a name="ln3815">	/*</a>
<a name="ln3816">	 * If the current TID is running AMPDU, update</a>
<a name="ln3817">	 * the BAW.</a>
<a name="ln3818">	 */</a>
<a name="ln3819">	if (ath_tx_ampdu_running(sc, an, tid-&gt;tid) &amp;&amp;</a>
<a name="ln3820">	    bf-&gt;bf_state.bfs_dobaw) {</a>
<a name="ln3821">		/*</a>
<a name="ln3822">		 * Only remove the frame from the BAW if it's</a>
<a name="ln3823">		 * been transmitted at least once; this means</a>
<a name="ln3824">		 * the frame was in the BAW to begin with.</a>
<a name="ln3825">		 */</a>
<a name="ln3826">		if (bf-&gt;bf_state.bfs_retries &gt; 0) {</a>
<a name="ln3827">			ath_tx_update_baw(sc, an, tid, bf);</a>
<a name="ln3828">			bf-&gt;bf_state.bfs_dobaw = 0;</a>
<a name="ln3829">		}</a>
<a name="ln3830">#if 0</a>
<a name="ln3831">		/*</a>
<a name="ln3832">		 * This has become a non-fatal error now</a>
<a name="ln3833">		 */</a>
<a name="ln3834">		if (! bf-&gt;bf_state.bfs_addedbaw)</a>
<a name="ln3835">			DPRINTF(sc, ATH_DEBUG_SW_TX_BAW</a>
<a name="ln3836">			    &quot;%s: wasn't added: seqno %d\n&quot;,</a>
<a name="ln3837">			    __func__, SEQNO(bf-&gt;bf_state.bfs_seqno));</a>
<a name="ln3838">#endif</a>
<a name="ln3839">	}</a>
<a name="ln3840"> </a>
<a name="ln3841">	/* Strip it out of an aggregate list if it was in one */</a>
<a name="ln3842">	bf-&gt;bf_next = NULL;</a>
<a name="ln3843"> </a>
<a name="ln3844">	/* Insert on the free queue to be freed by the caller */</a>
<a name="ln3845">	TAILQ_INSERT_TAIL(bf_cq, bf, bf_list);</a>
<a name="ln3846">}</a>
<a name="ln3847"> </a>
<a name="ln3848">static void</a>
<a name="ln3849">ath_tx_tid_drain_print(struct ath_softc *sc, struct ath_node *an,</a>
<a name="ln3850">    const char *pfx, struct ath_tid *tid, struct ath_buf *bf)</a>
<a name="ln3851">{</a>
<a name="ln3852">	struct ieee80211_node *ni = &amp;an-&gt;an_node;</a>
<a name="ln3853">	struct ath_txq *txq;</a>
<a name="ln3854">	struct ieee80211_tx_ampdu *tap;</a>
<a name="ln3855"> </a>
<a name="ln3856">	txq = sc-&gt;sc_ac2q[tid-&gt;ac];</a>
<a name="ln3857">	tap = ath_tx_get_tx_tid(an, tid-&gt;tid);</a>
<a name="ln3858"> </a>
<a name="ln3859">	DPRINTF(sc, ATH_DEBUG_SW_TX | ATH_DEBUG_RESET,</a>
<a name="ln3860">	    &quot;%s: %s: %6D: bf=%p: addbaw=%d, dobaw=%d, &quot;</a>
<a name="ln3861">	    &quot;seqno=%d, retry=%d\n&quot;,</a>
<a name="ln3862">	    __func__,</a>
<a name="ln3863">	    pfx,</a>
<a name="ln3864">	    ni-&gt;ni_macaddr,</a>
<a name="ln3865">	    &quot;:&quot;,</a>
<a name="ln3866">	    bf,</a>
<a name="ln3867">	    bf-&gt;bf_state.bfs_addedbaw,</a>
<a name="ln3868">	    bf-&gt;bf_state.bfs_dobaw,</a>
<a name="ln3869">	    SEQNO(bf-&gt;bf_state.bfs_seqno),</a>
<a name="ln3870">	    bf-&gt;bf_state.bfs_retries);</a>
<a name="ln3871">	DPRINTF(sc, ATH_DEBUG_SW_TX | ATH_DEBUG_RESET,</a>
<a name="ln3872">	    &quot;%s: %s: %6D: bf=%p: txq[%d] axq_depth=%d, axq_aggr_depth=%d\n&quot;,</a>
<a name="ln3873">	    __func__,</a>
<a name="ln3874">	    pfx,</a>
<a name="ln3875">	    ni-&gt;ni_macaddr,</a>
<a name="ln3876">	    &quot;:&quot;,</a>
<a name="ln3877">	    bf,</a>
<a name="ln3878">	    txq-&gt;axq_qnum,</a>
<a name="ln3879">	    txq-&gt;axq_depth,</a>
<a name="ln3880">	    txq-&gt;axq_aggr_depth);</a>
<a name="ln3881">	DPRINTF(sc, ATH_DEBUG_SW_TX | ATH_DEBUG_RESET,</a>
<a name="ln3882">	    &quot;%s: %s: %6D: bf=%p: tid txq_depth=%d hwq_depth=%d, bar_wait=%d, &quot;</a>
<a name="ln3883">	      &quot;isfiltered=%d\n&quot;,</a>
<a name="ln3884">	    __func__,</a>
<a name="ln3885">	    pfx,</a>
<a name="ln3886">	    ni-&gt;ni_macaddr,</a>
<a name="ln3887">	    &quot;:&quot;,</a>
<a name="ln3888">	    bf,</a>
<a name="ln3889">	    tid-&gt;axq_depth,</a>
<a name="ln3890">	    tid-&gt;hwq_depth,</a>
<a name="ln3891">	    tid-&gt;bar_wait,</a>
<a name="ln3892">	    tid-&gt;isfiltered);</a>
<a name="ln3893">	DPRINTF(sc, ATH_DEBUG_SW_TX | ATH_DEBUG_RESET,</a>
<a name="ln3894">	    &quot;%s: %s: %6D: tid %d: &quot;</a>
<a name="ln3895">	    &quot;sched=%d, paused=%d, &quot;</a>
<a name="ln3896">	    &quot;incomp=%d, baw_head=%d, &quot;</a>
<a name="ln3897">	    &quot;baw_tail=%d txa_start=%d, ni_txseqs=%d\n&quot;,</a>
<a name="ln3898">	     __func__,</a>
<a name="ln3899">	     pfx,</a>
<a name="ln3900">	     ni-&gt;ni_macaddr,</a>
<a name="ln3901">	     &quot;:&quot;,</a>
<a name="ln3902">	     tid-&gt;tid,</a>
<a name="ln3903">	     tid-&gt;sched, tid-&gt;paused,</a>
<a name="ln3904">	     tid-&gt;incomp, tid-&gt;baw_head,</a>
<a name="ln3905">	     tid-&gt;baw_tail, tap == NULL ? -1 : tap-&gt;txa_start,</a>
<a name="ln3906">	     ni-&gt;ni_txseqs[tid-&gt;tid]);</a>
<a name="ln3907"> </a>
<a name="ln3908">	/* XXX Dump the frame, see what it is? */</a>
<a name="ln3909">	if (IFF_DUMPPKTS(sc, ATH_DEBUG_XMIT))</a>
<a name="ln3910">		ieee80211_dump_pkt(ni-&gt;ni_ic,</a>
<a name="ln3911">		    mtod(bf-&gt;bf_m, const uint8_t *),</a>
<a name="ln3912">		    bf-&gt;bf_m-&gt;m_len, 0, -1);</a>
<a name="ln3913">}</a>
<a name="ln3914"> </a>
<a name="ln3915">/*</a>
<a name="ln3916"> * Free any packets currently pending in the software TX queue.</a>
<a name="ln3917"> *</a>
<a name="ln3918"> * This will be called when a node is being deleted.</a>
<a name="ln3919"> *</a>
<a name="ln3920"> * It can also be called on an active node during an interface</a>
<a name="ln3921"> * reset or state transition.</a>
<a name="ln3922"> *</a>
<a name="ln3923"> * (From Linux/reference):</a>
<a name="ln3924"> *</a>
<a name="ln3925"> * TODO: For frame(s) that are in the retry state, we will reuse the</a>
<a name="ln3926"> * sequence number(s) without setting the retry bit. The</a>
<a name="ln3927"> * alternative is to give up on these and BAR the receiver's window</a>
<a name="ln3928"> * forward.</a>
<a name="ln3929"> */</a>
<a name="ln3930">static void</a>
<a name="ln3931">ath_tx_tid_drain(struct ath_softc *sc, struct ath_node *an,</a>
<a name="ln3932">    struct ath_tid *tid, ath_bufhead *bf_cq)</a>
<a name="ln3933">{</a>
<a name="ln3934">	struct ath_buf *bf;</a>
<a name="ln3935">	struct ieee80211_tx_ampdu *tap;</a>
<a name="ln3936">	struct ieee80211_node *ni = &amp;an-&gt;an_node;</a>
<a name="ln3937">	int t;</a>
<a name="ln3938"> </a>
<a name="ln3939">	tap = ath_tx_get_tx_tid(an, tid-&gt;tid);</a>
<a name="ln3940"> </a>
<a name="ln3941">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln3942"> </a>
<a name="ln3943">	/* Walk the queue, free frames */</a>
<a name="ln3944">	t = 0;</a>
<a name="ln3945">	for (;;) {</a>
<a name="ln3946">		bf = ATH_TID_FIRST(tid);</a>
<a name="ln3947">		if (bf == NULL) {</a>
<a name="ln3948">			break;</a>
<a name="ln3949">		}</a>
<a name="ln3950"> </a>
<a name="ln3951">		if (t == 0) {</a>
<a name="ln3952">			ath_tx_tid_drain_print(sc, an, &quot;norm&quot;, tid, bf);</a>
<a name="ln3953">//			t = 1;</a>
<a name="ln3954">		}</a>
<a name="ln3955"> </a>
<a name="ln3956">		ATH_TID_REMOVE(tid, bf, bf_list);</a>
<a name="ln3957">		ath_tx_tid_drain_pkt(sc, an, tid, bf_cq, bf);</a>
<a name="ln3958">	}</a>
<a name="ln3959"> </a>
<a name="ln3960">	/* And now, drain the filtered frame queue */</a>
<a name="ln3961">	t = 0;</a>
<a name="ln3962">	for (;;) {</a>
<a name="ln3963">		bf = ATH_TID_FILT_FIRST(tid);</a>
<a name="ln3964">		if (bf == NULL)</a>
<a name="ln3965">			break;</a>
<a name="ln3966"> </a>
<a name="ln3967">		if (t == 0) {</a>
<a name="ln3968">			ath_tx_tid_drain_print(sc, an, &quot;filt&quot;, tid, bf);</a>
<a name="ln3969">//			t = 1;</a>
<a name="ln3970">		}</a>
<a name="ln3971"> </a>
<a name="ln3972">		ATH_TID_FILT_REMOVE(tid, bf, bf_list);</a>
<a name="ln3973">		ath_tx_tid_drain_pkt(sc, an, tid, bf_cq, bf);</a>
<a name="ln3974">	}</a>
<a name="ln3975"> </a>
<a name="ln3976">	/*</a>
<a name="ln3977">	 * Override the clrdmask configuration for the next frame</a>
<a name="ln3978">	 * in case there is some future transmission, just to get</a>
<a name="ln3979">	 * the ball rolling.</a>
<a name="ln3980">	 *</a>
<a name="ln3981">	 * This won't hurt things if the TID is about to be freed.</a>
<a name="ln3982">	 */</a>
<a name="ln3983">	ath_tx_set_clrdmask(sc, tid-&gt;an);</a>
<a name="ln3984"> </a>
<a name="ln3985">	/*</a>
<a name="ln3986">	 * Now that it's completed, grab the TID lock and update</a>
<a name="ln3987">	 * the sequence number and BAW window.</a>
<a name="ln3988">	 * Because sequence numbers have been assigned to frames</a>
<a name="ln3989">	 * that haven't been sent yet, it's entirely possible</a>
<a name="ln3990">	 * we'll be called with some pending frames that have not</a>
<a name="ln3991">	 * been transmitted.</a>
<a name="ln3992">	 *</a>
<a name="ln3993">	 * The cleaner solution is to do the sequence number allocation</a>
<a name="ln3994">	 * when the packet is first transmitted - and thus the &quot;retries&quot;</a>
<a name="ln3995">	 * check above would be enough to update the BAW/seqno.</a>
<a name="ln3996">	 */</a>
<a name="ln3997"> </a>
<a name="ln3998">	/* But don't do it for non-QoS TIDs */</a>
<a name="ln3999">	if (tap) {</a>
<a name="ln4000">#if 1</a>
<a name="ln4001">		DPRINTF(sc, ATH_DEBUG_SW_TX_CTRL,</a>
<a name="ln4002">		    &quot;%s: %6D: node %p: TID %d: sliding BAW left edge to %d\n&quot;,</a>
<a name="ln4003">		    __func__,</a>
<a name="ln4004">		    ni-&gt;ni_macaddr,</a>
<a name="ln4005">		    &quot;:&quot;,</a>
<a name="ln4006">		    an,</a>
<a name="ln4007">		    tid-&gt;tid,</a>
<a name="ln4008">		    tap-&gt;txa_start);</a>
<a name="ln4009">#endif</a>
<a name="ln4010">		ni-&gt;ni_txseqs[tid-&gt;tid] = tap-&gt;txa_start;</a>
<a name="ln4011">		tid-&gt;baw_tail = tid-&gt;baw_head;</a>
<a name="ln4012">	}</a>
<a name="ln4013">}</a>
<a name="ln4014"> </a>
<a name="ln4015">/*</a>
<a name="ln4016"> * Reset the TID state.  This must be only called once the node has</a>
<a name="ln4017"> * had its frames flushed from this TID, to ensure that no other</a>
<a name="ln4018"> * pause / unpause logic can kick in.</a>
<a name="ln4019"> */</a>
<a name="ln4020">static void</a>
<a name="ln4021">ath_tx_tid_reset(struct ath_softc *sc, struct ath_tid *tid)</a>
<a name="ln4022">{</a>
<a name="ln4023"> </a>
<a name="ln4024">#if 0</a>
<a name="ln4025">	tid-&gt;bar_wait = tid-&gt;bar_tx = tid-&gt;isfiltered = 0;</a>
<a name="ln4026">	tid-&gt;paused = tid-&gt;sched = tid-&gt;addba_tx_pending = 0;</a>
<a name="ln4027">	tid-&gt;incomp = tid-&gt;cleanup_inprogress = 0;</a>
<a name="ln4028">#endif</a>
<a name="ln4029"> </a>
<a name="ln4030">	/*</a>
<a name="ln4031">	 * If we have a bar_wait set, we need to unpause the TID</a>
<a name="ln4032">	 * here.  Otherwise once cleanup has finished, the TID won't</a>
<a name="ln4033">	 * have the right paused counter.</a>
<a name="ln4034">	 *</a>
<a name="ln4035">	 * XXX I'm not going through resume here - I don't want the</a>
<a name="ln4036">	 * node to be rescheuled just yet.  This however should be</a>
<a name="ln4037">	 * methodized!</a>
<a name="ln4038">	 */</a>
<a name="ln4039">	if (tid-&gt;bar_wait) {</a>
<a name="ln4040">		if (tid-&gt;paused &gt; 0) {</a>
<a name="ln4041">			tid-&gt;paused --;</a>
<a name="ln4042">		}</a>
<a name="ln4043">	}</a>
<a name="ln4044"> </a>
<a name="ln4045">	/*</a>
<a name="ln4046">	 * XXX same with a currently filtered TID.</a>
<a name="ln4047">	 *</a>
<a name="ln4048">	 * Since this is being called during a flush, we assume that</a>
<a name="ln4049">	 * the filtered frame list is actually empty.</a>
<a name="ln4050">	 *</a>
<a name="ln4051">	 * XXX TODO: add in a check to ensure that the filtered queue</a>
<a name="ln4052">	 * depth is actually 0!</a>
<a name="ln4053">	 */</a>
<a name="ln4054">	if (tid-&gt;isfiltered) {</a>
<a name="ln4055">		if (tid-&gt;paused &gt; 0) {</a>
<a name="ln4056">			tid-&gt;paused --;</a>
<a name="ln4057">		}</a>
<a name="ln4058">	}</a>
<a name="ln4059"> </a>
<a name="ln4060">	/*</a>
<a name="ln4061">	 * Clear BAR, filtered frames, scheduled and ADDBA pending.</a>
<a name="ln4062">	 * The TID may be going through cleanup from the last association</a>
<a name="ln4063">	 * where things in the BAW are still in the hardware queue.</a>
<a name="ln4064">	 */</a>
<a name="ln4065">	tid-&gt;bar_wait = 0;</a>
<a name="ln4066">	tid-&gt;bar_tx = 0;</a>
<a name="ln4067">	tid-&gt;isfiltered = 0;</a>
<a name="ln4068">	tid-&gt;sched = 0;</a>
<a name="ln4069">	tid-&gt;addba_tx_pending = 0;</a>
<a name="ln4070"> </a>
<a name="ln4071">	/*</a>
<a name="ln4072">	 * XXX TODO: it may just be enough to walk the HWQs and mark</a>
<a name="ln4073">	 * frames for that node as non-aggregate; or mark the ath_node</a>
<a name="ln4074">	 * with something that indicates that aggregation is no longer</a>
<a name="ln4075">	 * occurring.  Then we can just toss the BAW complaints and</a>
<a name="ln4076">	 * do a complete hard reset of state here - no pause, no</a>
<a name="ln4077">	 * complete counter, etc.</a>
<a name="ln4078">	 */</a>
<a name="ln4079"> </a>
<a name="ln4080">}</a>
<a name="ln4081"> </a>
<a name="ln4082">/*</a>
<a name="ln4083"> * Flush all software queued packets for the given node.</a>
<a name="ln4084"> *</a>
<a name="ln4085"> * This occurs when a completion handler frees the last buffer</a>
<a name="ln4086"> * for a node, and the node is thus freed. This causes the node</a>
<a name="ln4087"> * to be cleaned up, which ends up calling ath_tx_node_flush.</a>
<a name="ln4088"> */</a>
<a name="ln4089">void</a>
<a name="ln4090">ath_tx_node_flush(struct ath_softc *sc, struct ath_node *an)</a>
<a name="ln4091">{</a>
<a name="ln4092">	int tid;</a>
<a name="ln4093">	ath_bufhead bf_cq;</a>
<a name="ln4094">	struct ath_buf *bf;</a>
<a name="ln4095"> </a>
<a name="ln4096">	TAILQ_INIT(&amp;bf_cq);</a>
<a name="ln4097"> </a>
<a name="ln4098">	ATH_KTR(sc, ATH_KTR_NODE, 1, &quot;ath_tx_node_flush: flush node; ni=%p&quot;,</a>
<a name="ln4099">	    &amp;an-&gt;an_node);</a>
<a name="ln4100"> </a>
<a name="ln4101">	ATH_TX_LOCK(sc);</a>
<a name="ln4102">	DPRINTF(sc, ATH_DEBUG_NODE,</a>
<a name="ln4103">	    &quot;%s: %6D: flush; is_powersave=%d, stack_psq=%d, tim=%d, &quot;</a>
<a name="ln4104">	    &quot;swq_depth=%d, clrdmask=%d, leak_count=%d\n&quot;,</a>
<a name="ln4105">	    __func__,</a>
<a name="ln4106">	    an-&gt;an_node.ni_macaddr,</a>
<a name="ln4107">	    &quot;:&quot;,</a>
<a name="ln4108">	    an-&gt;an_is_powersave,</a>
<a name="ln4109">	    an-&gt;an_stack_psq,</a>
<a name="ln4110">	    an-&gt;an_tim_set,</a>
<a name="ln4111">	    an-&gt;an_swq_depth,</a>
<a name="ln4112">	    an-&gt;clrdmask,</a>
<a name="ln4113">	    an-&gt;an_leak_count);</a>
<a name="ln4114"> </a>
<a name="ln4115">	for (tid = 0; tid &lt; IEEE80211_TID_SIZE; tid++) {</a>
<a name="ln4116">		struct ath_tid *atid = &amp;an-&gt;an_tid[tid];</a>
<a name="ln4117"> </a>
<a name="ln4118">		/* Free packets */</a>
<a name="ln4119">		ath_tx_tid_drain(sc, an, atid, &amp;bf_cq);</a>
<a name="ln4120"> </a>
<a name="ln4121">		/* Remove this tid from the list of active tids */</a>
<a name="ln4122">		ath_tx_tid_unsched(sc, atid);</a>
<a name="ln4123"> </a>
<a name="ln4124">		/* Reset the per-TID pause, BAR, etc state */</a>
<a name="ln4125">		ath_tx_tid_reset(sc, atid);</a>
<a name="ln4126">	}</a>
<a name="ln4127"> </a>
<a name="ln4128">	/*</a>
<a name="ln4129">	 * Clear global leak count</a>
<a name="ln4130">	 */</a>
<a name="ln4131">	an-&gt;an_leak_count = 0;</a>
<a name="ln4132">	ATH_TX_UNLOCK(sc);</a>
<a name="ln4133"> </a>
<a name="ln4134">	/* Handle completed frames */</a>
<a name="ln4135">	while ((bf = TAILQ_FIRST(&amp;bf_cq)) != NULL) {</a>
<a name="ln4136">		TAILQ_REMOVE(&amp;bf_cq, bf, bf_list);</a>
<a name="ln4137">		ath_tx_default_comp(sc, bf, 0);</a>
<a name="ln4138">	}</a>
<a name="ln4139">}</a>
<a name="ln4140"> </a>
<a name="ln4141">/*</a>
<a name="ln4142"> * Drain all the software TXQs currently with traffic queued.</a>
<a name="ln4143"> */</a>
<a name="ln4144">void</a>
<a name="ln4145">ath_tx_txq_drain(struct ath_softc *sc, struct ath_txq *txq)</a>
<a name="ln4146">{</a>
<a name="ln4147">	struct ath_tid *tid;</a>
<a name="ln4148">	ath_bufhead bf_cq;</a>
<a name="ln4149">	struct ath_buf *bf;</a>
<a name="ln4150"> </a>
<a name="ln4151">	TAILQ_INIT(&amp;bf_cq);</a>
<a name="ln4152">	ATH_TX_LOCK(sc);</a>
<a name="ln4153"> </a>
<a name="ln4154">	/*</a>
<a name="ln4155">	 * Iterate over all active tids for the given txq,</a>
<a name="ln4156">	 * flushing and unsched'ing them</a>
<a name="ln4157">	 */</a>
<a name="ln4158">	while (! TAILQ_EMPTY(&amp;txq-&gt;axq_tidq)) {</a>
<a name="ln4159">		tid = TAILQ_FIRST(&amp;txq-&gt;axq_tidq);</a>
<a name="ln4160">		ath_tx_tid_drain(sc, tid-&gt;an, tid, &amp;bf_cq);</a>
<a name="ln4161">		ath_tx_tid_unsched(sc, tid);</a>
<a name="ln4162">	}</a>
<a name="ln4163"> </a>
<a name="ln4164">	ATH_TX_UNLOCK(sc);</a>
<a name="ln4165"> </a>
<a name="ln4166">	while ((bf = TAILQ_FIRST(&amp;bf_cq)) != NULL) {</a>
<a name="ln4167">		TAILQ_REMOVE(&amp;bf_cq, bf, bf_list);</a>
<a name="ln4168">		ath_tx_default_comp(sc, bf, 0);</a>
<a name="ln4169">	}</a>
<a name="ln4170">}</a>
<a name="ln4171"> </a>
<a name="ln4172">/*</a>
<a name="ln4173"> * Handle completion of non-aggregate session frames.</a>
<a name="ln4174"> *</a>
<a name="ln4175"> * This (currently) doesn't implement software retransmission of</a>
<a name="ln4176"> * non-aggregate frames!</a>
<a name="ln4177"> *</a>
<a name="ln4178"> * Software retransmission of non-aggregate frames needs to obey</a>
<a name="ln4179"> * the strict sequence number ordering, and drop any frames that</a>
<a name="ln4180"> * will fail this.</a>
<a name="ln4181"> *</a>
<a name="ln4182"> * For now, filtered frames and frame transmission will cause</a>
<a name="ln4183"> * all kinds of issues.  So we don't support them.</a>
<a name="ln4184"> *</a>
<a name="ln4185"> * So anyone queuing frames via ath_tx_normal_xmit() or</a>
<a name="ln4186"> * ath_tx_hw_queue_norm() must override and set CLRDMASK.</a>
<a name="ln4187"> */</a>
<a name="ln4188">void</a>
<a name="ln4189">ath_tx_normal_comp(struct ath_softc *sc, struct ath_buf *bf, int fail)</a>
<a name="ln4190">{</a>
<a name="ln4191">	struct ieee80211_node *ni = bf-&gt;bf_node;</a>
<a name="ln4192">	struct ath_node *an = ATH_NODE(ni);</a>
<a name="ln4193">	int tid = bf-&gt;bf_state.bfs_tid;</a>
<a name="ln4194">	struct ath_tid *atid = &amp;an-&gt;an_tid[tid];</a>
<a name="ln4195">	struct ath_tx_status *ts = &amp;bf-&gt;bf_status.ds_txstat;</a>
<a name="ln4196"> </a>
<a name="ln4197">	/* The TID state is protected behind the TXQ lock */</a>
<a name="ln4198">	ATH_TX_LOCK(sc);</a>
<a name="ln4199"> </a>
<a name="ln4200">	DPRINTF(sc, ATH_DEBUG_SW_TX, &quot;%s: bf=%p: fail=%d, hwq_depth now %d\n&quot;,</a>
<a name="ln4201">	    __func__, bf, fail, atid-&gt;hwq_depth - 1);</a>
<a name="ln4202"> </a>
<a name="ln4203">	atid-&gt;hwq_depth--;</a>
<a name="ln4204"> </a>
<a name="ln4205">#if 0</a>
<a name="ln4206">	/*</a>
<a name="ln4207">	 * If the frame was filtered, stick it on the filter frame</a>
<a name="ln4208">	 * queue and complain about it.  It shouldn't happen!</a>
<a name="ln4209">	 */</a>
<a name="ln4210">	if ((ts-&gt;ts_status &amp; HAL_TXERR_FILT) ||</a>
<a name="ln4211">	    (ts-&gt;ts_status != 0 &amp;&amp; atid-&gt;isfiltered)) {</a>
<a name="ln4212">		DPRINTF(sc, ATH_DEBUG_SW_TX,</a>
<a name="ln4213">		    &quot;%s: isfiltered=%d, ts_status=%d: huh?\n&quot;,</a>
<a name="ln4214">		    __func__,</a>
<a name="ln4215">		    atid-&gt;isfiltered,</a>
<a name="ln4216">		    ts-&gt;ts_status);</a>
<a name="ln4217">		ath_tx_tid_filt_comp_buf(sc, atid, bf);</a>
<a name="ln4218">	}</a>
<a name="ln4219">#endif</a>
<a name="ln4220">	if (atid-&gt;isfiltered)</a>
<a name="ln4221">		DPRINTF(sc, ATH_DEBUG_SW_TX, &quot;%s: filtered?!\n&quot;, __func__);</a>
<a name="ln4222">	if (atid-&gt;hwq_depth &lt; 0)</a>
<a name="ln4223">		DPRINTF(sc, ATH_DEBUG_SW_TX, &quot;%s: hwq_depth &lt; 0: %d\n&quot;,</a>
<a name="ln4224">		    __func__, atid-&gt;hwq_depth);</a>
<a name="ln4225"> </a>
<a name="ln4226">	/* If the TID is being cleaned up, track things */</a>
<a name="ln4227">	/* XXX refactor! */</a>
<a name="ln4228">	if (atid-&gt;cleanup_inprogress) {</a>
<a name="ln4229">		atid-&gt;incomp--;</a>
<a name="ln4230">		if (atid-&gt;incomp == 0) {</a>
<a name="ln4231">			DPRINTF(sc, ATH_DEBUG_SW_TX_CTRL,</a>
<a name="ln4232">			    &quot;%s: TID %d: cleaned up! resume!\n&quot;,</a>
<a name="ln4233">			    __func__, tid);</a>
<a name="ln4234">			atid-&gt;cleanup_inprogress = 0;</a>
<a name="ln4235">			ath_tx_tid_resume(sc, atid);</a>
<a name="ln4236">		}</a>
<a name="ln4237">	}</a>
<a name="ln4238"> </a>
<a name="ln4239">	/*</a>
<a name="ln4240">	 * If the queue is filtered, potentially mark it as complete</a>
<a name="ln4241">	 * and reschedule it as needed.</a>
<a name="ln4242">	 *</a>
<a name="ln4243">	 * This is required as there may be a subsequent TX descriptor</a>
<a name="ln4244">	 * for this end-node that has CLRDMASK set, so it's quite possible</a>
<a name="ln4245">	 * that a filtered frame will be followed by a non-filtered</a>
<a name="ln4246">	 * (complete or otherwise) frame.</a>
<a name="ln4247">	 *</a>
<a name="ln4248">	 * XXX should we do this before we complete the frame?</a>
<a name="ln4249">	 */</a>
<a name="ln4250">	if (atid-&gt;isfiltered)</a>
<a name="ln4251">		ath_tx_tid_filt_comp_complete(sc, atid);</a>
<a name="ln4252">	ATH_TX_UNLOCK(sc);</a>
<a name="ln4253"> </a>
<a name="ln4254">	/*</a>
<a name="ln4255">	 * punt to rate control if we're not being cleaned up</a>
<a name="ln4256">	 * during a hw queue drain and the frame wanted an ACK.</a>
<a name="ln4257">	 */</a>
<a name="ln4258">	if (fail == 0 &amp;&amp; ((bf-&gt;bf_state.bfs_txflags &amp; HAL_TXDESC_NOACK) == 0))</a>
<a name="ln4259">		ath_tx_update_ratectrl(sc, ni, bf-&gt;bf_state.bfs_rc,</a>
<a name="ln4260">		    ts, bf-&gt;bf_state.bfs_pktlen,</a>
<a name="ln4261">		    1, (ts-&gt;ts_status == 0) ? 0 : 1);</a>
<a name="ln4262"> </a>
<a name="ln4263">	ath_tx_default_comp(sc, bf, fail);</a>
<a name="ln4264">}</a>
<a name="ln4265"> </a>
<a name="ln4266">/*</a>
<a name="ln4267"> * Handle cleanup of aggregate session packets that aren't</a>
<a name="ln4268"> * an A-MPDU.</a>
<a name="ln4269"> *</a>
<a name="ln4270"> * There's no need to update the BAW here - the session is being</a>
<a name="ln4271"> * torn down.</a>
<a name="ln4272"> */</a>
<a name="ln4273">static void</a>
<a name="ln4274">ath_tx_comp_cleanup_unaggr(struct ath_softc *sc, struct ath_buf *bf)</a>
<a name="ln4275">{</a>
<a name="ln4276">	struct ieee80211_node *ni = bf-&gt;bf_node;</a>
<a name="ln4277">	struct ath_node *an = ATH_NODE(ni);</a>
<a name="ln4278">	int tid = bf-&gt;bf_state.bfs_tid;</a>
<a name="ln4279">	struct ath_tid *atid = &amp;an-&gt;an_tid[tid];</a>
<a name="ln4280"> </a>
<a name="ln4281">	DPRINTF(sc, ATH_DEBUG_SW_TX_CTRL, &quot;%s: TID %d: incomp=%d\n&quot;,</a>
<a name="ln4282">	    __func__, tid, atid-&gt;incomp);</a>
<a name="ln4283"> </a>
<a name="ln4284">	ATH_TX_LOCK(sc);</a>
<a name="ln4285">	atid-&gt;incomp--;</a>
<a name="ln4286"> </a>
<a name="ln4287">	/* XXX refactor! */</a>
<a name="ln4288">	if (bf-&gt;bf_state.bfs_dobaw) {</a>
<a name="ln4289">		ath_tx_update_baw(sc, an, atid, bf);</a>
<a name="ln4290">		if (!bf-&gt;bf_state.bfs_addedbaw)</a>
<a name="ln4291">			DPRINTF(sc, ATH_DEBUG_SW_TX,</a>
<a name="ln4292">			    &quot;%s: wasn't added: seqno %d\n&quot;,</a>
<a name="ln4293">			    __func__, SEQNO(bf-&gt;bf_state.bfs_seqno));</a>
<a name="ln4294">	}</a>
<a name="ln4295"> </a>
<a name="ln4296">	if (atid-&gt;incomp == 0) {</a>
<a name="ln4297">		DPRINTF(sc, ATH_DEBUG_SW_TX_CTRL,</a>
<a name="ln4298">		    &quot;%s: TID %d: cleaned up! resume!\n&quot;,</a>
<a name="ln4299">		    __func__, tid);</a>
<a name="ln4300">		atid-&gt;cleanup_inprogress = 0;</a>
<a name="ln4301">		ath_tx_tid_resume(sc, atid);</a>
<a name="ln4302">	}</a>
<a name="ln4303">	ATH_TX_UNLOCK(sc);</a>
<a name="ln4304"> </a>
<a name="ln4305">	ath_tx_default_comp(sc, bf, 0);</a>
<a name="ln4306">}</a>
<a name="ln4307"> </a>
<a name="ln4308"> </a>
<a name="ln4309">/*</a>
<a name="ln4310"> * This as it currently stands is a bit dumb.  Ideally we'd just</a>
<a name="ln4311"> * fail the frame the normal way and have it permanently fail</a>
<a name="ln4312"> * via the normal aggregate completion path.</a>
<a name="ln4313"> */</a>
<a name="ln4314">static void</a>
<a name="ln4315">ath_tx_tid_cleanup_frame(struct ath_softc *sc, struct ath_node *an,</a>
<a name="ln4316">    int tid, struct ath_buf *bf_head, ath_bufhead *bf_cq)</a>
<a name="ln4317">{</a>
<a name="ln4318">	struct ath_tid *atid = &amp;an-&gt;an_tid[tid];</a>
<a name="ln4319">	struct ath_buf *bf, *bf_next;</a>
<a name="ln4320"> </a>
<a name="ln4321">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln4322"> </a>
<a name="ln4323">	/*</a>
<a name="ln4324">	 * Remove this frame from the queue.</a>
<a name="ln4325">	 */</a>
<a name="ln4326">	ATH_TID_REMOVE(atid, bf_head, bf_list);</a>
<a name="ln4327"> </a>
<a name="ln4328">	/*</a>
<a name="ln4329">	 * Loop over all the frames in the aggregate.</a>
<a name="ln4330">	 */</a>
<a name="ln4331">	bf = bf_head;</a>
<a name="ln4332">	while (bf != NULL) {</a>
<a name="ln4333">		bf_next = bf-&gt;bf_next;	/* next aggregate frame, or NULL */</a>
<a name="ln4334"> </a>
<a name="ln4335">		/*</a>
<a name="ln4336">		 * If it's been added to the BAW we need to kick</a>
<a name="ln4337">		 * it out of the BAW before we continue.</a>
<a name="ln4338">		 *</a>
<a name="ln4339">		 * XXX if it's an aggregate, assert that it's in the</a>
<a name="ln4340">		 * BAW - we shouldn't have it be in an aggregate</a>
<a name="ln4341">		 * otherwise!</a>
<a name="ln4342">		 */</a>
<a name="ln4343">		if (bf-&gt;bf_state.bfs_addedbaw) {</a>
<a name="ln4344">			ath_tx_update_baw(sc, an, atid, bf);</a>
<a name="ln4345">			bf-&gt;bf_state.bfs_dobaw = 0;</a>
<a name="ln4346">		}</a>
<a name="ln4347"> </a>
<a name="ln4348">		/*</a>
<a name="ln4349">		 * Give it the default completion handler.</a>
<a name="ln4350">		 */</a>
<a name="ln4351">		bf-&gt;bf_comp = ath_tx_normal_comp;</a>
<a name="ln4352">		bf-&gt;bf_next = NULL;</a>
<a name="ln4353"> </a>
<a name="ln4354">		/*</a>
<a name="ln4355">		 * Add it to the list to free.</a>
<a name="ln4356">		 */</a>
<a name="ln4357">		TAILQ_INSERT_TAIL(bf_cq, bf, bf_list);</a>
<a name="ln4358"> </a>
<a name="ln4359">		/*</a>
<a name="ln4360">		 * Now advance to the next frame in the aggregate.</a>
<a name="ln4361">		 */</a>
<a name="ln4362">		bf = bf_next;</a>
<a name="ln4363">	}</a>
<a name="ln4364">}</a>
<a name="ln4365"> </a>
<a name="ln4366">/*</a>
<a name="ln4367"> * Performs transmit side cleanup when TID changes from aggregated to</a>
<a name="ln4368"> * unaggregated and during reassociation.</a>
<a name="ln4369"> *</a>
<a name="ln4370"> * For now, this just tosses everything from the TID software queue</a>
<a name="ln4371"> * whether or not it has been retried and marks the TID as</a>
<a name="ln4372"> * pending completion if there's anything for this TID queued to</a>
<a name="ln4373"> * the hardware.</a>
<a name="ln4374"> *</a>
<a name="ln4375"> * The caller is responsible for pausing the TID and unpausing the</a>
<a name="ln4376"> * TID if no cleanup was required. Otherwise the cleanup path will</a>
<a name="ln4377"> * unpause the TID once the last hardware queued frame is completed.</a>
<a name="ln4378"> */</a>
<a name="ln4379">static void</a>
<a name="ln4380">ath_tx_tid_cleanup(struct ath_softc *sc, struct ath_node *an, int tid,</a>
<a name="ln4381">    ath_bufhead *bf_cq)</a>
<a name="ln4382">{</a>
<a name="ln4383">	struct ath_tid *atid = &amp;an-&gt;an_tid[tid];</a>
<a name="ln4384">	struct ath_buf *bf, *bf_next;</a>
<a name="ln4385"> </a>
<a name="ln4386">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln4387"> </a>
<a name="ln4388">	DPRINTF(sc, ATH_DEBUG_SW_TX_BAW,</a>
<a name="ln4389">	    &quot;%s: TID %d: called; inprogress=%d\n&quot;, __func__, tid,</a>
<a name="ln4390">	    atid-&gt;cleanup_inprogress);</a>
<a name="ln4391"> </a>
<a name="ln4392">	/*</a>
<a name="ln4393">	 * Move the filtered frames to the TX queue, before</a>
<a name="ln4394">	 * we run off and discard/process things.</a>
<a name="ln4395">	 */</a>
<a name="ln4396"> </a>
<a name="ln4397">	/* XXX this is really quite inefficient */</a>
<a name="ln4398">	while ((bf = ATH_TID_FILT_LAST(atid, ath_bufhead_s)) != NULL) {</a>
<a name="ln4399">		ATH_TID_FILT_REMOVE(atid, bf, bf_list);</a>
<a name="ln4400">		ATH_TID_INSERT_HEAD(atid, bf, bf_list);</a>
<a name="ln4401">	}</a>
<a name="ln4402"> </a>
<a name="ln4403">	/*</a>
<a name="ln4404">	 * Update the frames in the software TX queue:</a>
<a name="ln4405">	 *</a>
<a name="ln4406">	 * + Discard retry frames in the queue</a>
<a name="ln4407">	 * + Fix the completion function to be non-aggregate</a>
<a name="ln4408">	 */</a>
<a name="ln4409">	bf = ATH_TID_FIRST(atid);</a>
<a name="ln4410">	while (bf) {</a>
<a name="ln4411">		/*</a>
<a name="ln4412">		 * Grab the next frame in the list, we may</a>
<a name="ln4413">		 * be fiddling with the list.</a>
<a name="ln4414">		 */</a>
<a name="ln4415">		bf_next = TAILQ_NEXT(bf, bf_list);</a>
<a name="ln4416"> </a>
<a name="ln4417">		/*</a>
<a name="ln4418">		 * Free the frame and all subframes.</a>
<a name="ln4419">		 */</a>
<a name="ln4420">		ath_tx_tid_cleanup_frame(sc, an, tid, bf, bf_cq);</a>
<a name="ln4421"> </a>
<a name="ln4422">		/*</a>
<a name="ln4423">		 * Next frame!</a>
<a name="ln4424">		 */</a>
<a name="ln4425">		bf = bf_next;</a>
<a name="ln4426">	}</a>
<a name="ln4427"> </a>
<a name="ln4428">	/*</a>
<a name="ln4429">	 * If there's anything in the hardware queue we wait</a>
<a name="ln4430">	 * for the TID HWQ to empty.</a>
<a name="ln4431">	 */</a>
<a name="ln4432">	if (atid-&gt;hwq_depth &gt; 0) {</a>
<a name="ln4433">		/*</a>
<a name="ln4434">		 * XXX how about we kill atid-&gt;incomp, and instead</a>
<a name="ln4435">		 * replace it with a macro that checks that atid-&gt;hwq_depth</a>
<a name="ln4436">		 * is 0?</a>
<a name="ln4437">		 */</a>
<a name="ln4438">		atid-&gt;incomp = atid-&gt;hwq_depth;</a>
<a name="ln4439">		atid-&gt;cleanup_inprogress = 1;</a>
<a name="ln4440">	}</a>
<a name="ln4441"> </a>
<a name="ln4442">	if (atid-&gt;cleanup_inprogress)</a>
<a name="ln4443">		DPRINTF(sc, ATH_DEBUG_SW_TX_CTRL,</a>
<a name="ln4444">		    &quot;%s: TID %d: cleanup needed: %d packets\n&quot;,</a>
<a name="ln4445">		    __func__, tid, atid-&gt;incomp);</a>
<a name="ln4446"> </a>
<a name="ln4447">	/* Owner now must free completed frames */</a>
<a name="ln4448">}</a>
<a name="ln4449"> </a>
<a name="ln4450">static struct ath_buf *</a>
<a name="ln4451">ath_tx_retry_clone(struct ath_softc *sc, struct ath_node *an,</a>
<a name="ln4452">    struct ath_tid *tid, struct ath_buf *bf)</a>
<a name="ln4453">{</a>
<a name="ln4454">	struct ath_buf *nbf;</a>
<a name="ln4455">	int error;</a>
<a name="ln4456"> </a>
<a name="ln4457">	/*</a>
<a name="ln4458">	 * Clone the buffer.  This will handle the dma unmap and</a>
<a name="ln4459">	 * copy the node reference to the new buffer.  If this</a>
<a name="ln4460">	 * works out, 'bf' will have no DMA mapping, no mbuf</a>
<a name="ln4461">	 * pointer and no node reference.</a>
<a name="ln4462">	 */</a>
<a name="ln4463">	nbf = ath_buf_clone(sc, bf);</a>
<a name="ln4464"> </a>
<a name="ln4465">#if 0</a>
<a name="ln4466">	DPRINTF(sc, ATH_DEBUG_XMIT, &quot;%s: ATH_BUF_BUSY; cloning\n&quot;,</a>
<a name="ln4467">	    __func__);</a>
<a name="ln4468">#endif</a>
<a name="ln4469"> </a>
<a name="ln4470">	if (nbf == NULL) {</a>
<a name="ln4471">		/* Failed to clone */</a>
<a name="ln4472">		DPRINTF(sc, ATH_DEBUG_XMIT,</a>
<a name="ln4473">		    &quot;%s: failed to clone a busy buffer\n&quot;,</a>
<a name="ln4474">		    __func__);</a>
<a name="ln4475">		return NULL;</a>
<a name="ln4476">	}</a>
<a name="ln4477"> </a>
<a name="ln4478">	/* Setup the dma for the new buffer */</a>
<a name="ln4479">	error = ath_tx_dmasetup(sc, nbf, nbf-&gt;bf_m);</a>
<a name="ln4480">	if (error != 0) {</a>
<a name="ln4481">		DPRINTF(sc, ATH_DEBUG_XMIT,</a>
<a name="ln4482">		    &quot;%s: failed to setup dma for clone\n&quot;,</a>
<a name="ln4483">		    __func__);</a>
<a name="ln4484">		/*</a>
<a name="ln4485">		 * Put this at the head of the list, not tail;</a>
<a name="ln4486">		 * that way it doesn't interfere with the</a>
<a name="ln4487">		 * busy buffer logic (which uses the tail of</a>
<a name="ln4488">		 * the list.)</a>
<a name="ln4489">		 */</a>
<a name="ln4490">		ATH_TXBUF_LOCK(sc);</a>
<a name="ln4491">		ath_returnbuf_head(sc, nbf);</a>
<a name="ln4492">		ATH_TXBUF_UNLOCK(sc);</a>
<a name="ln4493">		return NULL;</a>
<a name="ln4494">	}</a>
<a name="ln4495"> </a>
<a name="ln4496">	/* Update BAW if required, before we free the original buf */</a>
<a name="ln4497">	if (bf-&gt;bf_state.bfs_dobaw)</a>
<a name="ln4498">		ath_tx_switch_baw_buf(sc, an, tid, bf, nbf);</a>
<a name="ln4499"> </a>
<a name="ln4500">	/* Free original buffer; return new buffer */</a>
<a name="ln4501">	ath_freebuf(sc, bf);</a>
<a name="ln4502"> </a>
<a name="ln4503">	return nbf;</a>
<a name="ln4504">}</a>
<a name="ln4505"> </a>
<a name="ln4506">/*</a>
<a name="ln4507"> * Handle retrying an unaggregate frame in an aggregate</a>
<a name="ln4508"> * session.</a>
<a name="ln4509"> *</a>
<a name="ln4510"> * If too many retries occur, pause the TID, wait for</a>
<a name="ln4511"> * any further retransmits (as there's no reason why</a>
<a name="ln4512"> * non-aggregate frames in an aggregate session are</a>
<a name="ln4513"> * transmitted in-order; they just have to be in-BAW)</a>
<a name="ln4514"> * and then queue a BAR.</a>
<a name="ln4515"> */</a>
<a name="ln4516">static void</a>
<a name="ln4517">ath_tx_aggr_retry_unaggr(struct ath_softc *sc, struct ath_buf *bf)</a>
<a name="ln4518">{</a>
<a name="ln4519">	struct ieee80211_node *ni = bf-&gt;bf_node;</a>
<a name="ln4520">	struct ath_node *an = ATH_NODE(ni);</a>
<a name="ln4521">	int tid = bf-&gt;bf_state.bfs_tid;</a>
<a name="ln4522">	struct ath_tid *atid = &amp;an-&gt;an_tid[tid];</a>
<a name="ln4523">	struct ieee80211_tx_ampdu *tap;</a>
<a name="ln4524"> </a>
<a name="ln4525">	ATH_TX_LOCK(sc);</a>
<a name="ln4526"> </a>
<a name="ln4527">	tap = ath_tx_get_tx_tid(an, tid);</a>
<a name="ln4528"> </a>
<a name="ln4529">	/*</a>
<a name="ln4530">	 * If the buffer is marked as busy, we can't directly</a>
<a name="ln4531">	 * reuse it. Instead, try to clone the buffer.</a>
<a name="ln4532">	 * If the clone is successful, recycle the old buffer.</a>
<a name="ln4533">	 * If the clone is unsuccessful, set bfs_retries to max</a>
<a name="ln4534">	 * to force the next bit of code to free the buffer</a>
<a name="ln4535">	 * for us.</a>
<a name="ln4536">	 */</a>
<a name="ln4537">	if ((bf-&gt;bf_state.bfs_retries &lt; SWMAX_RETRIES) &amp;&amp;</a>
<a name="ln4538">	    (bf-&gt;bf_flags &amp; ATH_BUF_BUSY)) {</a>
<a name="ln4539">		struct ath_buf *nbf;</a>
<a name="ln4540">		nbf = ath_tx_retry_clone(sc, an, atid, bf);</a>
<a name="ln4541">		if (nbf)</a>
<a name="ln4542">			/* bf has been freed at this point */</a>
<a name="ln4543">			bf = nbf;</a>
<a name="ln4544">		else</a>
<a name="ln4545">			bf-&gt;bf_state.bfs_retries = SWMAX_RETRIES + 1;</a>
<a name="ln4546">	}</a>
<a name="ln4547"> </a>
<a name="ln4548">	if (bf-&gt;bf_state.bfs_retries &gt;= SWMAX_RETRIES) {</a>
<a name="ln4549">		DPRINTF(sc, ATH_DEBUG_SW_TX_RETRIES,</a>
<a name="ln4550">		    &quot;%s: exceeded retries; seqno %d\n&quot;,</a>
<a name="ln4551">		    __func__, SEQNO(bf-&gt;bf_state.bfs_seqno));</a>
<a name="ln4552">		sc-&gt;sc_stats.ast_tx_swretrymax++;</a>
<a name="ln4553"> </a>
<a name="ln4554">		/* Update BAW anyway */</a>
<a name="ln4555">		if (bf-&gt;bf_state.bfs_dobaw) {</a>
<a name="ln4556">			ath_tx_update_baw(sc, an, atid, bf);</a>
<a name="ln4557">			if (! bf-&gt;bf_state.bfs_addedbaw)</a>
<a name="ln4558">				DPRINTF(sc, ATH_DEBUG_SW_TX_BAW,</a>
<a name="ln4559">				    &quot;%s: wasn't added: seqno %d\n&quot;,</a>
<a name="ln4560">				    __func__, SEQNO(bf-&gt;bf_state.bfs_seqno));</a>
<a name="ln4561">		}</a>
<a name="ln4562">		bf-&gt;bf_state.bfs_dobaw = 0;</a>
<a name="ln4563"> </a>
<a name="ln4564">		/* Suspend the TX queue and get ready to send the BAR */</a>
<a name="ln4565">		ath_tx_tid_bar_suspend(sc, atid);</a>
<a name="ln4566"> </a>
<a name="ln4567">		/* Send the BAR if there are no other frames waiting */</a>
<a name="ln4568">		if (ath_tx_tid_bar_tx_ready(sc, atid))</a>
<a name="ln4569">			ath_tx_tid_bar_tx(sc, atid);</a>
<a name="ln4570"> </a>
<a name="ln4571">		ATH_TX_UNLOCK(sc);</a>
<a name="ln4572"> </a>
<a name="ln4573">		/* Free buffer, bf is free after this call */</a>
<a name="ln4574">		ath_tx_default_comp(sc, bf, 0);</a>
<a name="ln4575">		return;</a>
<a name="ln4576">	}</a>
<a name="ln4577"> </a>
<a name="ln4578">	/*</a>
<a name="ln4579">	 * This increments the retry counter as well as</a>
<a name="ln4580">	 * sets the retry flag in the ath_buf and packet</a>
<a name="ln4581">	 * body.</a>
<a name="ln4582">	 */</a>
<a name="ln4583">	ath_tx_set_retry(sc, bf);</a>
<a name="ln4584">	sc-&gt;sc_stats.ast_tx_swretries++;</a>
<a name="ln4585"> </a>
<a name="ln4586">	/*</a>
<a name="ln4587">	 * Insert this at the head of the queue, so it's</a>
<a name="ln4588">	 * retried before any current/subsequent frames.</a>
<a name="ln4589">	 */</a>
<a name="ln4590">	ATH_TID_INSERT_HEAD(atid, bf, bf_list);</a>
<a name="ln4591">	ath_tx_tid_sched(sc, atid);</a>
<a name="ln4592">	/* Send the BAR if there are no other frames waiting */</a>
<a name="ln4593">	if (ath_tx_tid_bar_tx_ready(sc, atid))</a>
<a name="ln4594">		ath_tx_tid_bar_tx(sc, atid);</a>
<a name="ln4595"> </a>
<a name="ln4596">	ATH_TX_UNLOCK(sc);</a>
<a name="ln4597">}</a>
<a name="ln4598"> </a>
<a name="ln4599">/*</a>
<a name="ln4600"> * Common code for aggregate excessive retry/subframe retry.</a>
<a name="ln4601"> * If retrying, queues buffers to bf_q. If not, frees the</a>
<a name="ln4602"> * buffers.</a>
<a name="ln4603"> *</a>
<a name="ln4604"> * XXX should unify this with ath_tx_aggr_retry_unaggr()</a>
<a name="ln4605"> */</a>
<a name="ln4606">static int</a>
<a name="ln4607">ath_tx_retry_subframe(struct ath_softc *sc, struct ath_buf *bf,</a>
<a name="ln4608">    ath_bufhead *bf_q)</a>
<a name="ln4609">{</a>
<a name="ln4610">	struct ieee80211_node *ni = bf-&gt;bf_node;</a>
<a name="ln4611">	struct ath_node *an = ATH_NODE(ni);</a>
<a name="ln4612">	int tid = bf-&gt;bf_state.bfs_tid;</a>
<a name="ln4613">	struct ath_tid *atid = &amp;an-&gt;an_tid[tid];</a>
<a name="ln4614"> </a>
<a name="ln4615">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln4616"> </a>
<a name="ln4617">	/* XXX clr11naggr should be done for all subframes */</a>
<a name="ln4618">	ath_hal_clr11n_aggr(sc-&gt;sc_ah, bf-&gt;bf_desc);</a>
<a name="ln4619">	ath_hal_set11nburstduration(sc-&gt;sc_ah, bf-&gt;bf_desc, 0);</a>
<a name="ln4620"> </a>
<a name="ln4621">	/* ath_hal_set11n_virtualmorefrag(sc-&gt;sc_ah, bf-&gt;bf_desc, 0); */</a>
<a name="ln4622"> </a>
<a name="ln4623">	/*</a>
<a name="ln4624">	 * If the buffer is marked as busy, we can't directly</a>
<a name="ln4625">	 * reuse it. Instead, try to clone the buffer.</a>
<a name="ln4626">	 * If the clone is successful, recycle the old buffer.</a>
<a name="ln4627">	 * If the clone is unsuccessful, set bfs_retries to max</a>
<a name="ln4628">	 * to force the next bit of code to free the buffer</a>
<a name="ln4629">	 * for us.</a>
<a name="ln4630">	 */</a>
<a name="ln4631">	if ((bf-&gt;bf_state.bfs_retries &lt; SWMAX_RETRIES) &amp;&amp;</a>
<a name="ln4632">	    (bf-&gt;bf_flags &amp; ATH_BUF_BUSY)) {</a>
<a name="ln4633">		struct ath_buf *nbf;</a>
<a name="ln4634">		nbf = ath_tx_retry_clone(sc, an, atid, bf);</a>
<a name="ln4635">		if (nbf)</a>
<a name="ln4636">			/* bf has been freed at this point */</a>
<a name="ln4637">			bf = nbf;</a>
<a name="ln4638">		else</a>
<a name="ln4639">			bf-&gt;bf_state.bfs_retries = SWMAX_RETRIES + 1;</a>
<a name="ln4640">	}</a>
<a name="ln4641"> </a>
<a name="ln4642">	if (bf-&gt;bf_state.bfs_retries &gt;= SWMAX_RETRIES) {</a>
<a name="ln4643">		sc-&gt;sc_stats.ast_tx_swretrymax++;</a>
<a name="ln4644">		DPRINTF(sc, ATH_DEBUG_SW_TX_RETRIES,</a>
<a name="ln4645">		    &quot;%s: max retries: seqno %d\n&quot;,</a>
<a name="ln4646">		    __func__, SEQNO(bf-&gt;bf_state.bfs_seqno));</a>
<a name="ln4647">		ath_tx_update_baw(sc, an, atid, bf);</a>
<a name="ln4648">		if (!bf-&gt;bf_state.bfs_addedbaw)</a>
<a name="ln4649">			DPRINTF(sc, ATH_DEBUG_SW_TX_BAW,</a>
<a name="ln4650">			    &quot;%s: wasn't added: seqno %d\n&quot;,</a>
<a name="ln4651">			    __func__, SEQNO(bf-&gt;bf_state.bfs_seqno));</a>
<a name="ln4652">		bf-&gt;bf_state.bfs_dobaw = 0;</a>
<a name="ln4653">		return 1;</a>
<a name="ln4654">	}</a>
<a name="ln4655"> </a>
<a name="ln4656">	ath_tx_set_retry(sc, bf);</a>
<a name="ln4657">	sc-&gt;sc_stats.ast_tx_swretries++;</a>
<a name="ln4658">	bf-&gt;bf_next = NULL;		/* Just to make sure */</a>
<a name="ln4659"> </a>
<a name="ln4660">	/* Clear the aggregate state */</a>
<a name="ln4661">	bf-&gt;bf_state.bfs_aggr = 0;</a>
<a name="ln4662">	bf-&gt;bf_state.bfs_ndelim = 0;	/* ??? needed? */</a>
<a name="ln4663">	bf-&gt;bf_state.bfs_nframes = 1;</a>
<a name="ln4664"> </a>
<a name="ln4665">	TAILQ_INSERT_TAIL(bf_q, bf, bf_list);</a>
<a name="ln4666">	return 0;</a>
<a name="ln4667">}</a>
<a name="ln4668"> </a>
<a name="ln4669">/*</a>
<a name="ln4670"> * error pkt completion for an aggregate destination</a>
<a name="ln4671"> */</a>
<a name="ln4672">static void</a>
<a name="ln4673">ath_tx_comp_aggr_error(struct ath_softc *sc, struct ath_buf *bf_first,</a>
<a name="ln4674">    struct ath_tid *tid)</a>
<a name="ln4675">{</a>
<a name="ln4676">	struct ieee80211_node *ni = bf_first-&gt;bf_node;</a>
<a name="ln4677">	struct ath_node *an = ATH_NODE(ni);</a>
<a name="ln4678">	struct ath_buf *bf_next, *bf;</a>
<a name="ln4679">	ath_bufhead bf_q;</a>
<a name="ln4680">	int drops = 0;</a>
<a name="ln4681">	struct ieee80211_tx_ampdu *tap;</a>
<a name="ln4682">	ath_bufhead bf_cq;</a>
<a name="ln4683"> </a>
<a name="ln4684">	TAILQ_INIT(&amp;bf_q);</a>
<a name="ln4685">	TAILQ_INIT(&amp;bf_cq);</a>
<a name="ln4686"> </a>
<a name="ln4687">	/*</a>
<a name="ln4688">	 * Update rate control - all frames have failed.</a>
<a name="ln4689">	 *</a>
<a name="ln4690">	 * XXX use the length in the first frame in the series;</a>
<a name="ln4691">	 * XXX just so things are consistent for now.</a>
<a name="ln4692">	 */</a>
<a name="ln4693">	ath_tx_update_ratectrl(sc, ni, bf_first-&gt;bf_state.bfs_rc,</a>
<a name="ln4694">	    &amp;bf_first-&gt;bf_status.ds_txstat,</a>
<a name="ln4695">	    bf_first-&gt;bf_state.bfs_pktlen,</a>
<a name="ln4696">	    bf_first-&gt;bf_state.bfs_nframes, bf_first-&gt;bf_state.bfs_nframes);</a>
<a name="ln4697"> </a>
<a name="ln4698">	ATH_TX_LOCK(sc);</a>
<a name="ln4699">	tap = ath_tx_get_tx_tid(an, tid-&gt;tid);</a>
<a name="ln4700">	sc-&gt;sc_stats.ast_tx_aggr_failall++;</a>
<a name="ln4701"> </a>
<a name="ln4702">	/* Retry all subframes */</a>
<a name="ln4703">	bf = bf_first;</a>
<a name="ln4704">	while (bf) {</a>
<a name="ln4705">		bf_next = bf-&gt;bf_next;</a>
<a name="ln4706">		bf-&gt;bf_next = NULL;	/* Remove it from the aggr list */</a>
<a name="ln4707">		sc-&gt;sc_stats.ast_tx_aggr_fail++;</a>
<a name="ln4708">		if (ath_tx_retry_subframe(sc, bf, &amp;bf_q)) {</a>
<a name="ln4709">			drops++;</a>
<a name="ln4710">			bf-&gt;bf_next = NULL;</a>
<a name="ln4711">			TAILQ_INSERT_TAIL(&amp;bf_cq, bf, bf_list);</a>
<a name="ln4712">		}</a>
<a name="ln4713">		bf = bf_next;</a>
<a name="ln4714">	}</a>
<a name="ln4715"> </a>
<a name="ln4716">	/* Prepend all frames to the beginning of the queue */</a>
<a name="ln4717">	while ((bf = TAILQ_LAST(&amp;bf_q, ath_bufhead_s)) != NULL) {</a>
<a name="ln4718">		TAILQ_REMOVE(&amp;bf_q, bf, bf_list);</a>
<a name="ln4719">		ATH_TID_INSERT_HEAD(tid, bf, bf_list);</a>
<a name="ln4720">	}</a>
<a name="ln4721"> </a>
<a name="ln4722">	/*</a>
<a name="ln4723">	 * Schedule the TID to be re-tried.</a>
<a name="ln4724">	 */</a>
<a name="ln4725">	ath_tx_tid_sched(sc, tid);</a>
<a name="ln4726"> </a>
<a name="ln4727">	/*</a>
<a name="ln4728">	 * send bar if we dropped any frames</a>
<a name="ln4729">	 *</a>
<a name="ln4730">	 * Keep the txq lock held for now, as we need to ensure</a>
<a name="ln4731">	 * that ni_txseqs[] is consistent (as it's being updated</a>
<a name="ln4732">	 * in the ifnet TX context or raw TX context.)</a>
<a name="ln4733">	 */</a>
<a name="ln4734">	if (drops) {</a>
<a name="ln4735">		/* Suspend the TX queue and get ready to send the BAR */</a>
<a name="ln4736">		ath_tx_tid_bar_suspend(sc, tid);</a>
<a name="ln4737">	}</a>
<a name="ln4738"> </a>
<a name="ln4739">	/*</a>
<a name="ln4740">	 * Send BAR if required</a>
<a name="ln4741">	 */</a>
<a name="ln4742">	if (ath_tx_tid_bar_tx_ready(sc, tid))</a>
<a name="ln4743">		ath_tx_tid_bar_tx(sc, tid);</a>
<a name="ln4744"> </a>
<a name="ln4745">	ATH_TX_UNLOCK(sc);</a>
<a name="ln4746"> </a>
<a name="ln4747">	/* Complete frames which errored out */</a>
<a name="ln4748">	while ((bf = TAILQ_FIRST(&amp;bf_cq)) != NULL) {</a>
<a name="ln4749">		TAILQ_REMOVE(&amp;bf_cq, bf, bf_list);</a>
<a name="ln4750">		ath_tx_default_comp(sc, bf, 0);</a>
<a name="ln4751">	}</a>
<a name="ln4752">}</a>
<a name="ln4753"> </a>
<a name="ln4754">/*</a>
<a name="ln4755"> * Handle clean-up of packets from an aggregate list.</a>
<a name="ln4756"> *</a>
<a name="ln4757"> * There's no need to update the BAW here - the session is being</a>
<a name="ln4758"> * torn down.</a>
<a name="ln4759"> */</a>
<a name="ln4760">static void</a>
<a name="ln4761">ath_tx_comp_cleanup_aggr(struct ath_softc *sc, struct ath_buf *bf_first)</a>
<a name="ln4762">{</a>
<a name="ln4763">	struct ath_buf *bf, *bf_next;</a>
<a name="ln4764">	struct ieee80211_node *ni = bf_first-&gt;bf_node;</a>
<a name="ln4765">	struct ath_node *an = ATH_NODE(ni);</a>
<a name="ln4766">	int tid = bf_first-&gt;bf_state.bfs_tid;</a>
<a name="ln4767">	struct ath_tid *atid = &amp;an-&gt;an_tid[tid];</a>
<a name="ln4768"> </a>
<a name="ln4769">	ATH_TX_LOCK(sc);</a>
<a name="ln4770"> </a>
<a name="ln4771">	/* update incomp */</a>
<a name="ln4772">	atid-&gt;incomp--;</a>
<a name="ln4773"> </a>
<a name="ln4774">	/* Update the BAW */</a>
<a name="ln4775">	bf = bf_first;</a>
<a name="ln4776">	while (bf) {</a>
<a name="ln4777">		/* XXX refactor! */</a>
<a name="ln4778">		if (bf-&gt;bf_state.bfs_dobaw) {</a>
<a name="ln4779">			ath_tx_update_baw(sc, an, atid, bf);</a>
<a name="ln4780">			if (!bf-&gt;bf_state.bfs_addedbaw)</a>
<a name="ln4781">				DPRINTF(sc, ATH_DEBUG_SW_TX,</a>
<a name="ln4782">				    &quot;%s: wasn't added: seqno %d\n&quot;,</a>
<a name="ln4783">				    __func__, SEQNO(bf-&gt;bf_state.bfs_seqno));</a>
<a name="ln4784">		}</a>
<a name="ln4785">		bf = bf-&gt;bf_next;</a>
<a name="ln4786">	}</a>
<a name="ln4787"> </a>
<a name="ln4788">	if (atid-&gt;incomp == 0) {</a>
<a name="ln4789">		DPRINTF(sc, ATH_DEBUG_SW_TX_CTRL,</a>
<a name="ln4790">		    &quot;%s: TID %d: cleaned up! resume!\n&quot;,</a>
<a name="ln4791">		    __func__, tid);</a>
<a name="ln4792">		atid-&gt;cleanup_inprogress = 0;</a>
<a name="ln4793">		ath_tx_tid_resume(sc, atid);</a>
<a name="ln4794">	}</a>
<a name="ln4795"> </a>
<a name="ln4796">	/* Send BAR if required */</a>
<a name="ln4797">	/* XXX why would we send a BAR when transitioning to non-aggregation? */</a>
<a name="ln4798">	/*</a>
<a name="ln4799">	 * XXX TODO: we should likely just tear down the BAR state here,</a>
<a name="ln4800">	 * rather than sending a BAR.</a>
<a name="ln4801">	 */</a>
<a name="ln4802">	if (ath_tx_tid_bar_tx_ready(sc, atid))</a>
<a name="ln4803">		ath_tx_tid_bar_tx(sc, atid);</a>
<a name="ln4804"> </a>
<a name="ln4805">	ATH_TX_UNLOCK(sc);</a>
<a name="ln4806"> </a>
<a name="ln4807">	/* Handle frame completion as individual frames */</a>
<a name="ln4808">	bf = bf_first;</a>
<a name="ln4809">	while (bf) {</a>
<a name="ln4810">		bf_next = bf-&gt;bf_next;</a>
<a name="ln4811">		bf-&gt;bf_next = NULL;</a>
<a name="ln4812">		ath_tx_default_comp(sc, bf, 1);</a>
<a name="ln4813">		bf = bf_next;</a>
<a name="ln4814">	}</a>
<a name="ln4815">}</a>
<a name="ln4816"> </a>
<a name="ln4817">/*</a>
<a name="ln4818"> * Handle completion of an set of aggregate frames.</a>
<a name="ln4819"> *</a>
<a name="ln4820"> * Note: the completion handler is the last descriptor in the aggregate,</a>
<a name="ln4821"> * not the last descriptor in the first frame.</a>
<a name="ln4822"> */</a>
<a name="ln4823">static void</a>
<a name="ln4824">ath_tx_aggr_comp_aggr(struct ath_softc *sc, struct ath_buf *bf_first,</a>
<a name="ln4825">    int fail)</a>
<a name="ln4826">{</a>
<a name="ln4827">	//struct ath_desc *ds = bf-&gt;bf_lastds;</a>
<a name="ln4828">	struct ieee80211_node *ni = bf_first-&gt;bf_node;</a>
<a name="ln4829">	struct ath_node *an = ATH_NODE(ni);</a>
<a name="ln4830">	int tid = bf_first-&gt;bf_state.bfs_tid;</a>
<a name="ln4831">	struct ath_tid *atid = &amp;an-&gt;an_tid[tid];</a>
<a name="ln4832">	struct ath_tx_status ts;</a>
<a name="ln4833">	struct ieee80211_tx_ampdu *tap;</a>
<a name="ln4834">	ath_bufhead bf_q;</a>
<a name="ln4835">	ath_bufhead bf_cq;</a>
<a name="ln4836">	int seq_st, tx_ok;</a>
<a name="ln4837">	int hasba, isaggr;</a>
<a name="ln4838">	uint32_t ba[2];</a>
<a name="ln4839">	struct ath_buf *bf, *bf_next;</a>
<a name="ln4840">	int ba_index;</a>
<a name="ln4841">	int drops = 0;</a>
<a name="ln4842">	int nframes = 0, nbad = 0, nf;</a>
<a name="ln4843">	int pktlen;</a>
<a name="ln4844">	/* XXX there's too much on the stack? */</a>
<a name="ln4845">	struct ath_rc_series rc[ATH_RC_NUM];</a>
<a name="ln4846">	int txseq;</a>
<a name="ln4847"> </a>
<a name="ln4848">	DPRINTF(sc, ATH_DEBUG_SW_TX_AGGR, &quot;%s: called; hwq_depth=%d\n&quot;,</a>
<a name="ln4849">	    __func__, atid-&gt;hwq_depth);</a>
<a name="ln4850"> </a>
<a name="ln4851">	/*</a>
<a name="ln4852">	 * Take a copy; this may be needed -after- bf_first</a>
<a name="ln4853">	 * has been completed and freed.</a>
<a name="ln4854">	 */</a>
<a name="ln4855">	ts = bf_first-&gt;bf_status.ds_txstat;</a>
<a name="ln4856"> </a>
<a name="ln4857">	TAILQ_INIT(&amp;bf_q);</a>
<a name="ln4858">	TAILQ_INIT(&amp;bf_cq);</a>
<a name="ln4859"> </a>
<a name="ln4860">	/* The TID state is kept behind the TXQ lock */</a>
<a name="ln4861">	ATH_TX_LOCK(sc);</a>
<a name="ln4862"> </a>
<a name="ln4863">	atid-&gt;hwq_depth--;</a>
<a name="ln4864">	if (atid-&gt;hwq_depth &lt; 0)</a>
<a name="ln4865">		DPRINTF(sc, ATH_DEBUG_SW_TX_AGGR, &quot;%s: hwq_depth &lt; 0: %d\n&quot;,</a>
<a name="ln4866">		    __func__, atid-&gt;hwq_depth);</a>
<a name="ln4867"> </a>
<a name="ln4868">	/*</a>
<a name="ln4869">	 * If the TID is filtered, handle completing the filter</a>
<a name="ln4870">	 * transition before potentially kicking it to the cleanup</a>
<a name="ln4871">	 * function.</a>
<a name="ln4872">	 *</a>
<a name="ln4873">	 * XXX this is duplicate work, ew.</a>
<a name="ln4874">	 */</a>
<a name="ln4875">	if (atid-&gt;isfiltered)</a>
<a name="ln4876">		ath_tx_tid_filt_comp_complete(sc, atid);</a>
<a name="ln4877"> </a>
<a name="ln4878">	/*</a>
<a name="ln4879">	 * Punt cleanup to the relevant function, not our problem now</a>
<a name="ln4880">	 */</a>
<a name="ln4881">	if (atid-&gt;cleanup_inprogress) {</a>
<a name="ln4882">		if (atid-&gt;isfiltered)</a>
<a name="ln4883">			DPRINTF(sc, ATH_DEBUG_SW_TX_AGGR,</a>
<a name="ln4884">			    &quot;%s: isfiltered=1, normal_comp?\n&quot;,</a>
<a name="ln4885">			    __func__);</a>
<a name="ln4886">		ATH_TX_UNLOCK(sc);</a>
<a name="ln4887">		ath_tx_comp_cleanup_aggr(sc, bf_first);</a>
<a name="ln4888">		return;</a>
<a name="ln4889">	}</a>
<a name="ln4890"> </a>
<a name="ln4891">	/*</a>
<a name="ln4892">	 * If the frame is filtered, transition to filtered frame</a>
<a name="ln4893">	 * mode and add this to the filtered frame list.</a>
<a name="ln4894">	 *</a>
<a name="ln4895">	 * XXX TODO: figure out how this interoperates with</a>
<a name="ln4896">	 * BAR, pause and cleanup states.</a>
<a name="ln4897">	 */</a>
<a name="ln4898">	if ((ts.ts_status &amp; HAL_TXERR_FILT) ||</a>
<a name="ln4899">	    (ts.ts_status != 0 &amp;&amp; atid-&gt;isfiltered)) {</a>
<a name="ln4900">		if (fail != 0)</a>
<a name="ln4901">			DPRINTF(sc, ATH_DEBUG_SW_TX_AGGR,</a>
<a name="ln4902">			    &quot;%s: isfiltered=1, fail=%d\n&quot;, __func__, fail);</a>
<a name="ln4903">		ath_tx_tid_filt_comp_aggr(sc, atid, bf_first, &amp;bf_cq);</a>
<a name="ln4904"> </a>
<a name="ln4905">		/* Remove from BAW */</a>
<a name="ln4906">		TAILQ_FOREACH_SAFE(bf, &amp;bf_cq, bf_list, bf_next) {</a>
<a name="ln4907">			if (bf-&gt;bf_state.bfs_addedbaw)</a>
<a name="ln4908">				drops++;</a>
<a name="ln4909">			if (bf-&gt;bf_state.bfs_dobaw) {</a>
<a name="ln4910">				ath_tx_update_baw(sc, an, atid, bf);</a>
<a name="ln4911">				if (!bf-&gt;bf_state.bfs_addedbaw)</a>
<a name="ln4912">					DPRINTF(sc, ATH_DEBUG_SW_TX_AGGR,</a>
<a name="ln4913">					    &quot;%s: wasn't added: seqno %d\n&quot;,</a>
<a name="ln4914">					    __func__,</a>
<a name="ln4915">					    SEQNO(bf-&gt;bf_state.bfs_seqno));</a>
<a name="ln4916">			}</a>
<a name="ln4917">			bf-&gt;bf_state.bfs_dobaw = 0;</a>
<a name="ln4918">		}</a>
<a name="ln4919">		/*</a>
<a name="ln4920">		 * If any intermediate frames in the BAW were dropped when</a>
<a name="ln4921">		 * handling filtering things, send a BAR.</a>
<a name="ln4922">		 */</a>
<a name="ln4923">		if (drops)</a>
<a name="ln4924">			ath_tx_tid_bar_suspend(sc, atid);</a>
<a name="ln4925"> </a>
<a name="ln4926">		/*</a>
<a name="ln4927">		 * Finish up by sending a BAR if required and freeing</a>
<a name="ln4928">		 * the frames outside of the TX lock.</a>
<a name="ln4929">		 */</a>
<a name="ln4930">		goto finish_send_bar;</a>
<a name="ln4931">	}</a>
<a name="ln4932"> </a>
<a name="ln4933">	/*</a>
<a name="ln4934">	 * XXX for now, use the first frame in the aggregate for</a>
<a name="ln4935">	 * XXX rate control completion; it's at least consistent.</a>
<a name="ln4936">	 */</a>
<a name="ln4937">	pktlen = bf_first-&gt;bf_state.bfs_pktlen;</a>
<a name="ln4938"> </a>
<a name="ln4939">	/*</a>
<a name="ln4940">	 * Handle errors first!</a>
<a name="ln4941">	 *</a>
<a name="ln4942">	 * Here, handle _any_ error as a &quot;exceeded retries&quot; error.</a>
<a name="ln4943">	 * Later on (when filtered frames are to be specially handled)</a>
<a name="ln4944">	 * it'll have to be expanded.</a>
<a name="ln4945">	 */</a>
<a name="ln4946">#if 0</a>
<a name="ln4947">	if (ts.ts_status &amp; HAL_TXERR_XRETRY) {</a>
<a name="ln4948">#endif</a>
<a name="ln4949">	if (ts.ts_status != 0) {</a>
<a name="ln4950">		ATH_TX_UNLOCK(sc);</a>
<a name="ln4951">		ath_tx_comp_aggr_error(sc, bf_first, atid);</a>
<a name="ln4952">		return;</a>
<a name="ln4953">	}</a>
<a name="ln4954"> </a>
<a name="ln4955">	tap = ath_tx_get_tx_tid(an, tid);</a>
<a name="ln4956"> </a>
<a name="ln4957">	/*</a>
<a name="ln4958">	 * extract starting sequence and block-ack bitmap</a>
<a name="ln4959">	 */</a>
<a name="ln4960">	/* XXX endian-ness of seq_st, ba? */</a>
<a name="ln4961">	seq_st = ts.ts_seqnum;</a>
<a name="ln4962">	hasba = !! (ts.ts_flags &amp; HAL_TX_BA);</a>
<a name="ln4963">	tx_ok = (ts.ts_status == 0);</a>
<a name="ln4964">	isaggr = bf_first-&gt;bf_state.bfs_aggr;</a>
<a name="ln4965">	ba[0] = ts.ts_ba_low;</a>
<a name="ln4966">	ba[1] = ts.ts_ba_high;</a>
<a name="ln4967"> </a>
<a name="ln4968">	/*</a>
<a name="ln4969">	 * Copy the TX completion status and the rate control</a>
<a name="ln4970">	 * series from the first descriptor, as it may be freed</a>
<a name="ln4971">	 * before the rate control code can get its grubby fingers</a>
<a name="ln4972">	 * into things.</a>
<a name="ln4973">	 */</a>
<a name="ln4974">	memcpy(rc, bf_first-&gt;bf_state.bfs_rc, sizeof(rc));</a>
<a name="ln4975"> </a>
<a name="ln4976">	DPRINTF(sc, ATH_DEBUG_SW_TX_AGGR,</a>
<a name="ln4977">	    &quot;%s: txa_start=%d, tx_ok=%d, status=%.8x, flags=%.8x, &quot;</a>
<a name="ln4978">	    &quot;isaggr=%d, seq_st=%d, hasba=%d, ba=%.8x, %.8x\n&quot;,</a>
<a name="ln4979">	    __func__, tap-&gt;txa_start, tx_ok, ts.ts_status, ts.ts_flags,</a>
<a name="ln4980">	    isaggr, seq_st, hasba, ba[0], ba[1]);</a>
<a name="ln4981"> </a>
<a name="ln4982">	/*</a>
<a name="ln4983">	 * The reference driver doesn't do this; it simply ignores</a>
<a name="ln4984">	 * this check in its entirety.</a>
<a name="ln4985">	 *</a>
<a name="ln4986">	 * I've seen this occur when using iperf to send traffic</a>
<a name="ln4987">	 * out tid 1 - the aggregate frames are all marked as TID 1,</a>
<a name="ln4988">	 * but the TXSTATUS has TID=0.  So, let's just ignore this</a>
<a name="ln4989">	 * check.</a>
<a name="ln4990">	 */</a>
<a name="ln4991">#if 0</a>
<a name="ln4992">	/* Occasionally, the MAC sends a tx status for the wrong TID. */</a>
<a name="ln4993">	if (tid != ts.ts_tid) {</a>
<a name="ln4994">		DPRINTF(sc, ATH_DEBUG_SW_TX_AGGR, &quot;%s: tid %d != hw tid %d\n&quot;,</a>
<a name="ln4995">		    __func__, tid, ts.ts_tid);</a>
<a name="ln4996">		tx_ok = 0;</a>
<a name="ln4997">	}</a>
<a name="ln4998">#endif</a>
<a name="ln4999"> </a>
<a name="ln5000">	/* AR5416 BA bug; this requires an interface reset */</a>
<a name="ln5001">	if (isaggr &amp;&amp; tx_ok &amp;&amp; (! hasba)) {</a>
<a name="ln5002">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln5003">		    &quot;%s: AR5416 bug: hasba=%d; txok=%d, isaggr=%d, &quot;</a>
<a name="ln5004">		    &quot;seq_st=%d\n&quot;,</a>
<a name="ln5005">		    __func__, hasba, tx_ok, isaggr, seq_st);</a>
<a name="ln5006">		/* XXX TODO: schedule an interface reset */</a>
<a name="ln5007">#ifdef ATH_DEBUG</a>
<a name="ln5008">		ath_printtxbuf(sc, bf_first,</a>
<a name="ln5009">		    sc-&gt;sc_ac2q[atid-&gt;ac]-&gt;axq_qnum, 0, 0);</a>
<a name="ln5010">#endif</a>
<a name="ln5011">	}</a>
<a name="ln5012"> </a>
<a name="ln5013">	/*</a>
<a name="ln5014">	 * Walk the list of frames, figure out which ones were correctly</a>
<a name="ln5015">	 * sent and which weren't.</a>
<a name="ln5016">	 */</a>
<a name="ln5017">	bf = bf_first;</a>
<a name="ln5018">	nf = bf_first-&gt;bf_state.bfs_nframes;</a>
<a name="ln5019"> </a>
<a name="ln5020">	/* bf_first is going to be invalid once this list is walked */</a>
<a name="ln5021">	bf_first = NULL;</a>
<a name="ln5022"> </a>
<a name="ln5023">	/*</a>
<a name="ln5024">	 * Walk the list of completed frames and determine</a>
<a name="ln5025">	 * which need to be completed and which need to be</a>
<a name="ln5026">	 * retransmitted.</a>
<a name="ln5027">	 *</a>
<a name="ln5028">	 * For completed frames, the completion functions need</a>
<a name="ln5029">	 * to be called at the end of this function as the last</a>
<a name="ln5030">	 * node reference may free the node.</a>
<a name="ln5031">	 *</a>
<a name="ln5032">	 * Finally, since the TXQ lock can't be held during the</a>
<a name="ln5033">	 * completion callback (to avoid lock recursion),</a>
<a name="ln5034">	 * the completion calls have to be done outside of the</a>
<a name="ln5035">	 * lock.</a>
<a name="ln5036">	 */</a>
<a name="ln5037">	while (bf) {</a>
<a name="ln5038">		nframes++;</a>
<a name="ln5039">		ba_index = ATH_BA_INDEX(seq_st,</a>
<a name="ln5040">		    SEQNO(bf-&gt;bf_state.bfs_seqno));</a>
<a name="ln5041">		bf_next = bf-&gt;bf_next;</a>
<a name="ln5042">		bf-&gt;bf_next = NULL;	/* Remove it from the aggr list */</a>
<a name="ln5043"> </a>
<a name="ln5044">		DPRINTF(sc, ATH_DEBUG_SW_TX_AGGR,</a>
<a name="ln5045">		    &quot;%s: checking bf=%p seqno=%d; ack=%d\n&quot;,</a>
<a name="ln5046">		    __func__, bf, SEQNO(bf-&gt;bf_state.bfs_seqno),</a>
<a name="ln5047">		    ATH_BA_ISSET(ba, ba_index));</a>
<a name="ln5048"> </a>
<a name="ln5049">		if (tx_ok &amp;&amp; ATH_BA_ISSET(ba, ba_index)) {</a>
<a name="ln5050">			sc-&gt;sc_stats.ast_tx_aggr_ok++;</a>
<a name="ln5051">			ath_tx_update_baw(sc, an, atid, bf);</a>
<a name="ln5052">			bf-&gt;bf_state.bfs_dobaw = 0;</a>
<a name="ln5053">			if (!bf-&gt;bf_state.bfs_addedbaw)</a>
<a name="ln5054">				DPRINTF(sc, ATH_DEBUG_SW_TX_AGGR,</a>
<a name="ln5055">				    &quot;%s: wasn't added: seqno %d\n&quot;,</a>
<a name="ln5056">				    __func__, SEQNO(bf-&gt;bf_state.bfs_seqno));</a>
<a name="ln5057">			bf-&gt;bf_next = NULL;</a>
<a name="ln5058">			TAILQ_INSERT_TAIL(&amp;bf_cq, bf, bf_list);</a>
<a name="ln5059">		} else {</a>
<a name="ln5060">			sc-&gt;sc_stats.ast_tx_aggr_fail++;</a>
<a name="ln5061">			if (ath_tx_retry_subframe(sc, bf, &amp;bf_q)) {</a>
<a name="ln5062">				drops++;</a>
<a name="ln5063">				bf-&gt;bf_next = NULL;</a>
<a name="ln5064">				TAILQ_INSERT_TAIL(&amp;bf_cq, bf, bf_list);</a>
<a name="ln5065">			}</a>
<a name="ln5066">			nbad++;</a>
<a name="ln5067">		}</a>
<a name="ln5068">		bf = bf_next;</a>
<a name="ln5069">	}</a>
<a name="ln5070"> </a>
<a name="ln5071">	/*</a>
<a name="ln5072">	 * Now that the BAW updates have been done, unlock</a>
<a name="ln5073">	 *</a>
<a name="ln5074">	 * txseq is grabbed before the lock is released so we</a>
<a name="ln5075">	 * have a consistent view of what -was- in the BAW.</a>
<a name="ln5076">	 * Anything after this point will not yet have been</a>
<a name="ln5077">	 * TXed.</a>
<a name="ln5078">	 */</a>
<a name="ln5079">	txseq = tap-&gt;txa_start;</a>
<a name="ln5080">	ATH_TX_UNLOCK(sc);</a>
<a name="ln5081"> </a>
<a name="ln5082">	if (nframes != nf)</a>
<a name="ln5083">		DPRINTF(sc, ATH_DEBUG_SW_TX_AGGR,</a>
<a name="ln5084">		    &quot;%s: num frames seen=%d; bf nframes=%d\n&quot;,</a>
<a name="ln5085">		    __func__, nframes, nf);</a>
<a name="ln5086"> </a>
<a name="ln5087">	/*</a>
<a name="ln5088">	 * Now we know how many frames were bad, call the rate</a>
<a name="ln5089">	 * control code.</a>
<a name="ln5090">	 */</a>
<a name="ln5091">	if (fail == 0)</a>
<a name="ln5092">		ath_tx_update_ratectrl(sc, ni, rc, &amp;ts, pktlen, nframes,</a>
<a name="ln5093">		    nbad);</a>
<a name="ln5094"> </a>
<a name="ln5095">	/*</a>
<a name="ln5096">	 * send bar if we dropped any frames</a>
<a name="ln5097">	 */</a>
<a name="ln5098">	if (drops) {</a>
<a name="ln5099">		/* Suspend the TX queue and get ready to send the BAR */</a>
<a name="ln5100">		ATH_TX_LOCK(sc);</a>
<a name="ln5101">		ath_tx_tid_bar_suspend(sc, atid);</a>
<a name="ln5102">		ATH_TX_UNLOCK(sc);</a>
<a name="ln5103">	}</a>
<a name="ln5104"> </a>
<a name="ln5105">	DPRINTF(sc, ATH_DEBUG_SW_TX_AGGR,</a>
<a name="ln5106">	    &quot;%s: txa_start now %d\n&quot;, __func__, tap-&gt;txa_start);</a>
<a name="ln5107"> </a>
<a name="ln5108">	ATH_TX_LOCK(sc);</a>
<a name="ln5109"> </a>
<a name="ln5110">	/* Prepend all frames to the beginning of the queue */</a>
<a name="ln5111">	while ((bf = TAILQ_LAST(&amp;bf_q, ath_bufhead_s)) != NULL) {</a>
<a name="ln5112">		TAILQ_REMOVE(&amp;bf_q, bf, bf_list);</a>
<a name="ln5113">		ATH_TID_INSERT_HEAD(atid, bf, bf_list);</a>
<a name="ln5114">	}</a>
<a name="ln5115"> </a>
<a name="ln5116">	/*</a>
<a name="ln5117">	 * Reschedule to grab some further frames.</a>
<a name="ln5118">	 */</a>
<a name="ln5119">	ath_tx_tid_sched(sc, atid);</a>
<a name="ln5120"> </a>
<a name="ln5121">	/*</a>
<a name="ln5122">	 * If the queue is filtered, re-schedule as required.</a>
<a name="ln5123">	 *</a>
<a name="ln5124">	 * This is required as there may be a subsequent TX descriptor</a>
<a name="ln5125">	 * for this end-node that has CLRDMASK set, so it's quite possible</a>
<a name="ln5126">	 * that a filtered frame will be followed by a non-filtered</a>
<a name="ln5127">	 * (complete or otherwise) frame.</a>
<a name="ln5128">	 *</a>
<a name="ln5129">	 * XXX should we do this before we complete the frame?</a>
<a name="ln5130">	 */</a>
<a name="ln5131">	if (atid-&gt;isfiltered)</a>
<a name="ln5132">		ath_tx_tid_filt_comp_complete(sc, atid);</a>
<a name="ln5133"> </a>
<a name="ln5134">finish_send_bar:</a>
<a name="ln5135"> </a>
<a name="ln5136">	/*</a>
<a name="ln5137">	 * Send BAR if required</a>
<a name="ln5138">	 */</a>
<a name="ln5139">	if (ath_tx_tid_bar_tx_ready(sc, atid))</a>
<a name="ln5140">		ath_tx_tid_bar_tx(sc, atid);</a>
<a name="ln5141"> </a>
<a name="ln5142">	ATH_TX_UNLOCK(sc);</a>
<a name="ln5143"> </a>
<a name="ln5144">	/* Do deferred completion */</a>
<a name="ln5145">	while ((bf = TAILQ_FIRST(&amp;bf_cq)) != NULL) {</a>
<a name="ln5146">		TAILQ_REMOVE(&amp;bf_cq, bf, bf_list);</a>
<a name="ln5147">		ath_tx_default_comp(sc, bf, 0);</a>
<a name="ln5148">	}</a>
<a name="ln5149">}</a>
<a name="ln5150"> </a>
<a name="ln5151">/*</a>
<a name="ln5152"> * Handle completion of unaggregated frames in an ADDBA</a>
<a name="ln5153"> * session.</a>
<a name="ln5154"> *</a>
<a name="ln5155"> * Fail is set to 1 if the entry is being freed via a call to</a>
<a name="ln5156"> * ath_tx_draintxq().</a>
<a name="ln5157"> */</a>
<a name="ln5158">static void</a>
<a name="ln5159">ath_tx_aggr_comp_unaggr(struct ath_softc *sc, struct ath_buf *bf, int fail)</a>
<a name="ln5160">{</a>
<a name="ln5161">	struct ieee80211_node *ni = bf-&gt;bf_node;</a>
<a name="ln5162">	struct ath_node *an = ATH_NODE(ni);</a>
<a name="ln5163">	int tid = bf-&gt;bf_state.bfs_tid;</a>
<a name="ln5164">	struct ath_tid *atid = &amp;an-&gt;an_tid[tid];</a>
<a name="ln5165">	struct ath_tx_status ts;</a>
<a name="ln5166">	int drops = 0;</a>
<a name="ln5167"> </a>
<a name="ln5168">	/*</a>
<a name="ln5169">	 * Take a copy of this; filtering/cloning the frame may free the</a>
<a name="ln5170">	 * bf pointer.</a>
<a name="ln5171">	 */</a>
<a name="ln5172">	ts = bf-&gt;bf_status.ds_txstat;</a>
<a name="ln5173"> </a>
<a name="ln5174">	/*</a>
<a name="ln5175">	 * Update rate control status here, before we possibly</a>
<a name="ln5176">	 * punt to retry or cleanup.</a>
<a name="ln5177">	 *</a>
<a name="ln5178">	 * Do it outside of the TXQ lock.</a>
<a name="ln5179">	 */</a>
<a name="ln5180">	if (fail == 0 &amp;&amp; ((bf-&gt;bf_state.bfs_txflags &amp; HAL_TXDESC_NOACK) == 0))</a>
<a name="ln5181">		ath_tx_update_ratectrl(sc, ni, bf-&gt;bf_state.bfs_rc,</a>
<a name="ln5182">		    &amp;bf-&gt;bf_status.ds_txstat,</a>
<a name="ln5183">		    bf-&gt;bf_state.bfs_pktlen,</a>
<a name="ln5184">		    1, (ts.ts_status == 0) ? 0 : 1);</a>
<a name="ln5185"> </a>
<a name="ln5186">	/*</a>
<a name="ln5187">	 * This is called early so atid-&gt;hwq_depth can be tracked.</a>
<a name="ln5188">	 * This unfortunately means that it's released and regrabbed</a>
<a name="ln5189">	 * during retry and cleanup. That's rather inefficient.</a>
<a name="ln5190">	 */</a>
<a name="ln5191">	ATH_TX_LOCK(sc);</a>
<a name="ln5192"> </a>
<a name="ln5193">	if (tid == IEEE80211_NONQOS_TID)</a>
<a name="ln5194">		DPRINTF(sc, ATH_DEBUG_SW_TX, &quot;%s: TID=16!\n&quot;, __func__);</a>
<a name="ln5195"> </a>
<a name="ln5196">	DPRINTF(sc, ATH_DEBUG_SW_TX,</a>
<a name="ln5197">	    &quot;%s: bf=%p: tid=%d, hwq_depth=%d, seqno=%d\n&quot;,</a>
<a name="ln5198">	    __func__, bf, bf-&gt;bf_state.bfs_tid, atid-&gt;hwq_depth,</a>
<a name="ln5199">	    SEQNO(bf-&gt;bf_state.bfs_seqno));</a>
<a name="ln5200"> </a>
<a name="ln5201">	atid-&gt;hwq_depth--;</a>
<a name="ln5202">	if (atid-&gt;hwq_depth &lt; 0)</a>
<a name="ln5203">		DPRINTF(sc, ATH_DEBUG_SW_TX, &quot;%s: hwq_depth &lt; 0: %d\n&quot;,</a>
<a name="ln5204">		    __func__, atid-&gt;hwq_depth);</a>
<a name="ln5205"> </a>
<a name="ln5206">	/*</a>
<a name="ln5207">	 * If the TID is filtered, handle completing the filter</a>
<a name="ln5208">	 * transition before potentially kicking it to the cleanup</a>
<a name="ln5209">	 * function.</a>
<a name="ln5210">	 */</a>
<a name="ln5211">	if (atid-&gt;isfiltered)</a>
<a name="ln5212">		ath_tx_tid_filt_comp_complete(sc, atid);</a>
<a name="ln5213"> </a>
<a name="ln5214">	/*</a>
<a name="ln5215">	 * If a cleanup is in progress, punt to comp_cleanup;</a>
<a name="ln5216">	 * rather than handling it here. It's thus their</a>
<a name="ln5217">	 * responsibility to clean up, call the completion</a>
<a name="ln5218">	 * function in net80211, etc.</a>
<a name="ln5219">	 */</a>
<a name="ln5220">	if (atid-&gt;cleanup_inprogress) {</a>
<a name="ln5221">		if (atid-&gt;isfiltered)</a>
<a name="ln5222">			DPRINTF(sc, ATH_DEBUG_SW_TX,</a>
<a name="ln5223">			    &quot;%s: isfiltered=1, normal_comp?\n&quot;,</a>
<a name="ln5224">			    __func__);</a>
<a name="ln5225">		ATH_TX_UNLOCK(sc);</a>
<a name="ln5226">		DPRINTF(sc, ATH_DEBUG_SW_TX, &quot;%s: cleanup_unaggr\n&quot;,</a>
<a name="ln5227">		    __func__);</a>
<a name="ln5228">		ath_tx_comp_cleanup_unaggr(sc, bf);</a>
<a name="ln5229">		return;</a>
<a name="ln5230">	}</a>
<a name="ln5231"> </a>
<a name="ln5232">	/*</a>
<a name="ln5233">	 * XXX TODO: how does cleanup, BAR and filtered frame handling</a>
<a name="ln5234">	 * overlap?</a>
<a name="ln5235">	 *</a>
<a name="ln5236">	 * If the frame is filtered OR if it's any failure but</a>
<a name="ln5237">	 * the TID is filtered, the frame must be added to the</a>
<a name="ln5238">	 * filtered frame list.</a>
<a name="ln5239">	 *</a>
<a name="ln5240">	 * However - a busy buffer can't be added to the filtered</a>
<a name="ln5241">	 * list as it will end up being recycled without having</a>
<a name="ln5242">	 * been made available for the hardware.</a>
<a name="ln5243">	 */</a>
<a name="ln5244">	if ((ts.ts_status &amp; HAL_TXERR_FILT) ||</a>
<a name="ln5245">	    (ts.ts_status != 0 &amp;&amp; atid-&gt;isfiltered)) {</a>
<a name="ln5246">		int freeframe;</a>
<a name="ln5247"> </a>
<a name="ln5248">		if (fail != 0)</a>
<a name="ln5249">			DPRINTF(sc, ATH_DEBUG_SW_TX,</a>
<a name="ln5250">			    &quot;%s: isfiltered=1, fail=%d\n&quot;,</a>
<a name="ln5251">			    __func__, fail);</a>
<a name="ln5252">		freeframe = ath_tx_tid_filt_comp_single(sc, atid, bf);</a>
<a name="ln5253">		/*</a>
<a name="ln5254">		 * If freeframe=0 then bf is no longer ours; don't</a>
<a name="ln5255">		 * touch it.</a>
<a name="ln5256">		 */</a>
<a name="ln5257">		if (freeframe) {</a>
<a name="ln5258">			/* Remove from BAW */</a>
<a name="ln5259">			if (bf-&gt;bf_state.bfs_addedbaw)</a>
<a name="ln5260">				drops++;</a>
<a name="ln5261">			if (bf-&gt;bf_state.bfs_dobaw) {</a>
<a name="ln5262">				ath_tx_update_baw(sc, an, atid, bf);</a>
<a name="ln5263">				if (!bf-&gt;bf_state.bfs_addedbaw)</a>
<a name="ln5264">					DPRINTF(sc, ATH_DEBUG_SW_TX,</a>
<a name="ln5265">					    &quot;%s: wasn't added: seqno %d\n&quot;,</a>
<a name="ln5266">					    __func__, SEQNO(bf-&gt;bf_state.bfs_seqno));</a>
<a name="ln5267">			}</a>
<a name="ln5268">			bf-&gt;bf_state.bfs_dobaw = 0;</a>
<a name="ln5269">		}</a>
<a name="ln5270"> </a>
<a name="ln5271">		/*</a>
<a name="ln5272">		 * If the frame couldn't be filtered, treat it as a drop and</a>
<a name="ln5273">		 * prepare to send a BAR.</a>
<a name="ln5274">		 */</a>
<a name="ln5275">		if (freeframe &amp;&amp; drops)</a>
<a name="ln5276">			ath_tx_tid_bar_suspend(sc, atid);</a>
<a name="ln5277"> </a>
<a name="ln5278">		/*</a>
<a name="ln5279">		 * Send BAR if required</a>
<a name="ln5280">		 */</a>
<a name="ln5281">		if (ath_tx_tid_bar_tx_ready(sc, atid))</a>
<a name="ln5282">			ath_tx_tid_bar_tx(sc, atid);</a>
<a name="ln5283"> </a>
<a name="ln5284">		ATH_TX_UNLOCK(sc);</a>
<a name="ln5285">		/*</a>
<a name="ln5286">		 * If freeframe is set, then the frame couldn't be</a>
<a name="ln5287">		 * cloned and bf is still valid.  Just complete/free it.</a>
<a name="ln5288">		 */</a>
<a name="ln5289">		if (freeframe)</a>
<a name="ln5290">			ath_tx_default_comp(sc, bf, fail);</a>
<a name="ln5291"> </a>
<a name="ln5292">		return;</a>
<a name="ln5293">	}</a>
<a name="ln5294">	/*</a>
<a name="ln5295">	 * Don't bother with the retry check if all frames</a>
<a name="ln5296">	 * are being failed (eg during queue deletion.)</a>
<a name="ln5297">	 */</a>
<a name="ln5298">#if 0</a>
<a name="ln5299">	if (fail == 0 &amp;&amp; ts-&gt;ts_status &amp; HAL_TXERR_XRETRY) {</a>
<a name="ln5300">#endif</a>
<a name="ln5301">	if (fail == 0 &amp;&amp; ts.ts_status != 0) {</a>
<a name="ln5302">		ATH_TX_UNLOCK(sc);</a>
<a name="ln5303">		DPRINTF(sc, ATH_DEBUG_SW_TX, &quot;%s: retry_unaggr\n&quot;,</a>
<a name="ln5304">		    __func__);</a>
<a name="ln5305">		ath_tx_aggr_retry_unaggr(sc, bf);</a>
<a name="ln5306">		return;</a>
<a name="ln5307">	}</a>
<a name="ln5308"> </a>
<a name="ln5309">	/* Success? Complete */</a>
<a name="ln5310">	DPRINTF(sc, ATH_DEBUG_SW_TX, &quot;%s: TID=%d, seqno %d\n&quot;,</a>
<a name="ln5311">	    __func__, tid, SEQNO(bf-&gt;bf_state.bfs_seqno));</a>
<a name="ln5312">	if (bf-&gt;bf_state.bfs_dobaw) {</a>
<a name="ln5313">		ath_tx_update_baw(sc, an, atid, bf);</a>
<a name="ln5314">		bf-&gt;bf_state.bfs_dobaw = 0;</a>
<a name="ln5315">		if (!bf-&gt;bf_state.bfs_addedbaw)</a>
<a name="ln5316">			DPRINTF(sc, ATH_DEBUG_SW_TX,</a>
<a name="ln5317">			    &quot;%s: wasn't added: seqno %d\n&quot;,</a>
<a name="ln5318">			    __func__, SEQNO(bf-&gt;bf_state.bfs_seqno));</a>
<a name="ln5319">	}</a>
<a name="ln5320"> </a>
<a name="ln5321">	/*</a>
<a name="ln5322">	 * If the queue is filtered, re-schedule as required.</a>
<a name="ln5323">	 *</a>
<a name="ln5324">	 * This is required as there may be a subsequent TX descriptor</a>
<a name="ln5325">	 * for this end-node that has CLRDMASK set, so it's quite possible</a>
<a name="ln5326">	 * that a filtered frame will be followed by a non-filtered</a>
<a name="ln5327">	 * (complete or otherwise) frame.</a>
<a name="ln5328">	 *</a>
<a name="ln5329">	 * XXX should we do this before we complete the frame?</a>
<a name="ln5330">	 */</a>
<a name="ln5331">	if (atid-&gt;isfiltered)</a>
<a name="ln5332">		ath_tx_tid_filt_comp_complete(sc, atid);</a>
<a name="ln5333"> </a>
<a name="ln5334">	/*</a>
<a name="ln5335">	 * Send BAR if required</a>
<a name="ln5336">	 */</a>
<a name="ln5337">	if (ath_tx_tid_bar_tx_ready(sc, atid))</a>
<a name="ln5338">		ath_tx_tid_bar_tx(sc, atid);</a>
<a name="ln5339"> </a>
<a name="ln5340">	ATH_TX_UNLOCK(sc);</a>
<a name="ln5341"> </a>
<a name="ln5342">	ath_tx_default_comp(sc, bf, fail);</a>
<a name="ln5343">	/* bf is freed at this point */</a>
<a name="ln5344">}</a>
<a name="ln5345"> </a>
<a name="ln5346">void</a>
<a name="ln5347">ath_tx_aggr_comp(struct ath_softc *sc, struct ath_buf *bf, int fail)</a>
<a name="ln5348">{</a>
<a name="ln5349">	if (bf-&gt;bf_state.bfs_aggr)</a>
<a name="ln5350">		ath_tx_aggr_comp_aggr(sc, bf, fail);</a>
<a name="ln5351">	else</a>
<a name="ln5352">		ath_tx_aggr_comp_unaggr(sc, bf, fail);</a>
<a name="ln5353">}</a>
<a name="ln5354"> </a>
<a name="ln5355">/*</a>
<a name="ln5356"> * Schedule some packets from the given node/TID to the hardware.</a>
<a name="ln5357"> *</a>
<a name="ln5358"> * This is the aggregate version.</a>
<a name="ln5359"> */</a>
<a name="ln5360">void</a>
<a name="ln5361">ath_tx_tid_hw_queue_aggr(struct ath_softc *sc, struct ath_node *an,</a>
<a name="ln5362">    struct ath_tid *tid)</a>
<a name="ln5363">{</a>
<a name="ln5364">	struct ath_buf *bf;</a>
<a name="ln5365">	struct ath_txq *txq = sc-&gt;sc_ac2q[tid-&gt;ac];</a>
<a name="ln5366">	struct ieee80211_tx_ampdu *tap;</a>
<a name="ln5367">	ATH_AGGR_STATUS status;</a>
<a name="ln5368">	ath_bufhead bf_q;</a>
<a name="ln5369"> </a>
<a name="ln5370">	DPRINTF(sc, ATH_DEBUG_SW_TX, &quot;%s: tid=%d\n&quot;, __func__, tid-&gt;tid);</a>
<a name="ln5371">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln5372"> </a>
<a name="ln5373">	/*</a>
<a name="ln5374">	 * XXX TODO: If we're called for a queue that we're leaking frames to,</a>
<a name="ln5375">	 * ensure we only leak one.</a>
<a name="ln5376">	 */</a>
<a name="ln5377"> </a>
<a name="ln5378">	tap = ath_tx_get_tx_tid(an, tid-&gt;tid);</a>
<a name="ln5379"> </a>
<a name="ln5380">	if (tid-&gt;tid == IEEE80211_NONQOS_TID)</a>
<a name="ln5381">		DPRINTF(sc, ATH_DEBUG_SW_TX, </a>
<a name="ln5382">		    &quot;%s: called for TID=NONQOS_TID?\n&quot;, __func__);</a>
<a name="ln5383"> </a>
<a name="ln5384">	for (;;) {</a>
<a name="ln5385">		status = ATH_AGGR_DONE;</a>
<a name="ln5386"> </a>
<a name="ln5387">		/*</a>
<a name="ln5388">		 * If the upper layer has paused the TID, don't</a>
<a name="ln5389">		 * queue any further packets.</a>
<a name="ln5390">		 *</a>
<a name="ln5391">		 * This can also occur from the completion task because</a>
<a name="ln5392">		 * of packet loss; but as its serialised with this code,</a>
<a name="ln5393">		 * it won't &quot;appear&quot; half way through queuing packets.</a>
<a name="ln5394">		 */</a>
<a name="ln5395">		if (! ath_tx_tid_can_tx_or_sched(sc, tid))</a>
<a name="ln5396">			break;</a>
<a name="ln5397"> </a>
<a name="ln5398">		bf = ATH_TID_FIRST(tid);</a>
<a name="ln5399">		if (bf == NULL) {</a>
<a name="ln5400">			break;</a>
<a name="ln5401">		}</a>
<a name="ln5402"> </a>
<a name="ln5403">		/*</a>
<a name="ln5404">		 * If the packet doesn't fall within the BAW (eg a NULL</a>
<a name="ln5405">		 * data frame), schedule it directly; continue.</a>
<a name="ln5406">		 */</a>
<a name="ln5407">		if (! bf-&gt;bf_state.bfs_dobaw) {</a>
<a name="ln5408">			DPRINTF(sc, ATH_DEBUG_SW_TX_AGGR,</a>
<a name="ln5409">			    &quot;%s: non-baw packet\n&quot;,</a>
<a name="ln5410">			    __func__);</a>
<a name="ln5411">			ATH_TID_REMOVE(tid, bf, bf_list);</a>
<a name="ln5412"> </a>
<a name="ln5413">			if (bf-&gt;bf_state.bfs_nframes &gt; 1)</a>
<a name="ln5414">				DPRINTF(sc, ATH_DEBUG_SW_TX, </a>
<a name="ln5415">				    &quot;%s: aggr=%d, nframes=%d\n&quot;,</a>
<a name="ln5416">				    __func__,</a>
<a name="ln5417">				    bf-&gt;bf_state.bfs_aggr,</a>
<a name="ln5418">				    bf-&gt;bf_state.bfs_nframes);</a>
<a name="ln5419"> </a>
<a name="ln5420">			/*</a>
<a name="ln5421">			 * This shouldn't happen - such frames shouldn't</a>
<a name="ln5422">			 * ever have been queued as an aggregate in the</a>
<a name="ln5423">			 * first place.  However, make sure the fields</a>
<a name="ln5424">			 * are correctly setup just to be totally sure.</a>
<a name="ln5425">			 */</a>
<a name="ln5426">			bf-&gt;bf_state.bfs_aggr = 0;</a>
<a name="ln5427">			bf-&gt;bf_state.bfs_nframes = 1;</a>
<a name="ln5428"> </a>
<a name="ln5429">			/* Update CLRDMASK just before this frame is queued */</a>
<a name="ln5430">			ath_tx_update_clrdmask(sc, tid, bf);</a>
<a name="ln5431"> </a>
<a name="ln5432">			ath_tx_do_ratelookup(sc, bf);</a>
<a name="ln5433">			ath_tx_calc_duration(sc, bf);</a>
<a name="ln5434">			ath_tx_calc_protection(sc, bf);</a>
<a name="ln5435">			ath_tx_set_rtscts(sc, bf);</a>
<a name="ln5436">			ath_tx_rate_fill_rcflags(sc, bf);</a>
<a name="ln5437">			ath_tx_setds(sc, bf);</a>
<a name="ln5438">			ath_hal_clr11n_aggr(sc-&gt;sc_ah, bf-&gt;bf_desc);</a>
<a name="ln5439"> </a>
<a name="ln5440">			sc-&gt;sc_aggr_stats.aggr_nonbaw_pkt++;</a>
<a name="ln5441"> </a>
<a name="ln5442">			/* Queue the packet; continue */</a>
<a name="ln5443">			goto queuepkt;</a>
<a name="ln5444">		}</a>
<a name="ln5445"> </a>
<a name="ln5446">		TAILQ_INIT(&amp;bf_q);</a>
<a name="ln5447"> </a>
<a name="ln5448">		/*</a>
<a name="ln5449">		 * Do a rate control lookup on the first frame in the</a>
<a name="ln5450">		 * list. The rate control code needs that to occur</a>
<a name="ln5451">		 * before it can determine whether to TX.</a>
<a name="ln5452">		 * It's inaccurate because the rate control code doesn't</a>
<a name="ln5453">		 * really &quot;do&quot; aggregate lookups, so it only considers</a>
<a name="ln5454">		 * the size of the first frame.</a>
<a name="ln5455">		 */</a>
<a name="ln5456">		ath_tx_do_ratelookup(sc, bf);</a>
<a name="ln5457">		bf-&gt;bf_state.bfs_rc[3].rix = 0;</a>
<a name="ln5458">		bf-&gt;bf_state.bfs_rc[3].tries = 0;</a>
<a name="ln5459"> </a>
<a name="ln5460">		ath_tx_calc_duration(sc, bf);</a>
<a name="ln5461">		ath_tx_calc_protection(sc, bf);</a>
<a name="ln5462"> </a>
<a name="ln5463">		ath_tx_set_rtscts(sc, bf);</a>
<a name="ln5464">		ath_tx_rate_fill_rcflags(sc, bf);</a>
<a name="ln5465"> </a>
<a name="ln5466">		status = ath_tx_form_aggr(sc, an, tid, &amp;bf_q);</a>
<a name="ln5467"> </a>
<a name="ln5468">		DPRINTF(sc, ATH_DEBUG_SW_TX_AGGR,</a>
<a name="ln5469">		    &quot;%s: ath_tx_form_aggr() status=%d\n&quot;, __func__, status);</a>
<a name="ln5470"> </a>
<a name="ln5471">		/*</a>
<a name="ln5472">		 * No frames to be picked up - out of BAW</a>
<a name="ln5473">		 */</a>
<a name="ln5474">		if (TAILQ_EMPTY(&amp;bf_q))</a>
<a name="ln5475">			break;</a>
<a name="ln5476"> </a>
<a name="ln5477">		/*</a>
<a name="ln5478">		 * This assumes that the descriptor list in the ath_bufhead</a>
<a name="ln5479">		 * are already linked together via bf_next pointers.</a>
<a name="ln5480">		 */</a>
<a name="ln5481">		bf = TAILQ_FIRST(&amp;bf_q);</a>
<a name="ln5482"> </a>
<a name="ln5483">		if (status == ATH_AGGR_8K_LIMITED)</a>
<a name="ln5484">			sc-&gt;sc_aggr_stats.aggr_rts_aggr_limited++;</a>
<a name="ln5485"> </a>
<a name="ln5486">		/*</a>
<a name="ln5487">		 * If it's the only frame send as non-aggregate</a>
<a name="ln5488">		 * assume that ath_tx_form_aggr() has checked</a>
<a name="ln5489">		 * whether it's in the BAW and added it appropriately.</a>
<a name="ln5490">		 */</a>
<a name="ln5491">		if (bf-&gt;bf_state.bfs_nframes == 1) {</a>
<a name="ln5492">			DPRINTF(sc, ATH_DEBUG_SW_TX_AGGR,</a>
<a name="ln5493">			    &quot;%s: single-frame aggregate\n&quot;, __func__);</a>
<a name="ln5494"> </a>
<a name="ln5495">			/* Update CLRDMASK just before this frame is queued */</a>
<a name="ln5496">			ath_tx_update_clrdmask(sc, tid, bf);</a>
<a name="ln5497"> </a>
<a name="ln5498">			bf-&gt;bf_state.bfs_aggr = 0;</a>
<a name="ln5499">			bf-&gt;bf_state.bfs_ndelim = 0;</a>
<a name="ln5500">			ath_tx_setds(sc, bf);</a>
<a name="ln5501">			ath_hal_clr11n_aggr(sc-&gt;sc_ah, bf-&gt;bf_desc);</a>
<a name="ln5502">			if (status == ATH_AGGR_BAW_CLOSED)</a>
<a name="ln5503">				sc-&gt;sc_aggr_stats.aggr_baw_closed_single_pkt++;</a>
<a name="ln5504">			else</a>
<a name="ln5505">				sc-&gt;sc_aggr_stats.aggr_single_pkt++;</a>
<a name="ln5506">		} else {</a>
<a name="ln5507">			DPRINTF(sc, ATH_DEBUG_SW_TX_AGGR,</a>
<a name="ln5508">			    &quot;%s: multi-frame aggregate: %d frames, &quot;</a>
<a name="ln5509">			    &quot;length %d\n&quot;,</a>
<a name="ln5510">			     __func__, bf-&gt;bf_state.bfs_nframes,</a>
<a name="ln5511">			    bf-&gt;bf_state.bfs_al);</a>
<a name="ln5512">			bf-&gt;bf_state.bfs_aggr = 1;</a>
<a name="ln5513">			sc-&gt;sc_aggr_stats.aggr_pkts[bf-&gt;bf_state.bfs_nframes]++;</a>
<a name="ln5514">			sc-&gt;sc_aggr_stats.aggr_aggr_pkt++;</a>
<a name="ln5515"> </a>
<a name="ln5516">			/* Update CLRDMASK just before this frame is queued */</a>
<a name="ln5517">			ath_tx_update_clrdmask(sc, tid, bf);</a>
<a name="ln5518"> </a>
<a name="ln5519">			/*</a>
<a name="ln5520">			 * Calculate the duration/protection as required.</a>
<a name="ln5521">			 */</a>
<a name="ln5522">			ath_tx_calc_duration(sc, bf);</a>
<a name="ln5523">			ath_tx_calc_protection(sc, bf);</a>
<a name="ln5524"> </a>
<a name="ln5525">			/*</a>
<a name="ln5526">			 * Update the rate and rtscts information based on the</a>
<a name="ln5527">			 * rate decision made by the rate control code;</a>
<a name="ln5528">			 * the first frame in the aggregate needs it.</a>
<a name="ln5529">			 */</a>
<a name="ln5530">			ath_tx_set_rtscts(sc, bf);</a>
<a name="ln5531"> </a>
<a name="ln5532">			/*</a>
<a name="ln5533">			 * Setup the relevant descriptor fields</a>
<a name="ln5534">			 * for aggregation. The first descriptor</a>
<a name="ln5535">			 * already points to the rest in the chain.</a>
<a name="ln5536">			 */</a>
<a name="ln5537">			ath_tx_setds_11n(sc, bf);</a>
<a name="ln5538"> </a>
<a name="ln5539">		}</a>
<a name="ln5540">	queuepkt:</a>
<a name="ln5541">		/* Set completion handler, multi-frame aggregate or not */</a>
<a name="ln5542">		bf-&gt;bf_comp = ath_tx_aggr_comp;</a>
<a name="ln5543"> </a>
<a name="ln5544">		if (bf-&gt;bf_state.bfs_tid == IEEE80211_NONQOS_TID)</a>
<a name="ln5545">			DPRINTF(sc, ATH_DEBUG_SW_TX, &quot;%s: TID=16?\n&quot;, __func__);</a>
<a name="ln5546"> </a>
<a name="ln5547">		/*</a>
<a name="ln5548">		 * Update leak count and frame config if were leaking frames.</a>
<a name="ln5549">		 *</a>
<a name="ln5550">		 * XXX TODO: it should update all frames in an aggregate</a>
<a name="ln5551">		 * correctly!</a>
<a name="ln5552">		 */</a>
<a name="ln5553">		ath_tx_leak_count_update(sc, tid, bf);</a>
<a name="ln5554"> </a>
<a name="ln5555">		/* Punt to txq */</a>
<a name="ln5556">		ath_tx_handoff(sc, txq, bf);</a>
<a name="ln5557"> </a>
<a name="ln5558">		/* Track outstanding buffer count to hardware */</a>
<a name="ln5559">		/* aggregates are &quot;one&quot; buffer */</a>
<a name="ln5560">		tid-&gt;hwq_depth++;</a>
<a name="ln5561"> </a>
<a name="ln5562">		/*</a>
<a name="ln5563">		 * Break out if ath_tx_form_aggr() indicated</a>
<a name="ln5564">		 * there can't be any further progress (eg BAW is full.)</a>
<a name="ln5565">		 * Checking for an empty txq is done above.</a>
<a name="ln5566">		 *</a>
<a name="ln5567">		 * XXX locking on txq here?</a>
<a name="ln5568">		 */</a>
<a name="ln5569">		/* XXX TXQ locking */</a>
<a name="ln5570">		if (txq-&gt;axq_aggr_depth &gt;= sc-&gt;sc_hwq_limit_aggr ||</a>
<a name="ln5571">		    (status == ATH_AGGR_BAW_CLOSED ||</a>
<a name="ln5572">		     status == ATH_AGGR_LEAK_CLOSED))</a>
<a name="ln5573">			break;</a>
<a name="ln5574">	}</a>
<a name="ln5575">}</a>
<a name="ln5576"> </a>
<a name="ln5577">/*</a>
<a name="ln5578"> * Schedule some packets from the given node/TID to the hardware.</a>
<a name="ln5579"> *</a>
<a name="ln5580"> * XXX TODO: this routine doesn't enforce the maximum TXQ depth.</a>
<a name="ln5581"> * It just dumps frames into the TXQ.  We should limit how deep</a>
<a name="ln5582"> * the transmit queue can grow for frames dispatched to the given</a>
<a name="ln5583"> * TXQ.</a>
<a name="ln5584"> *</a>
<a name="ln5585"> * To avoid locking issues, either we need to own the TXQ lock</a>
<a name="ln5586"> * at this point, or we need to pass in the maximum frame count</a>
<a name="ln5587"> * from the caller.</a>
<a name="ln5588"> */</a>
<a name="ln5589">void</a>
<a name="ln5590">ath_tx_tid_hw_queue_norm(struct ath_softc *sc, struct ath_node *an,</a>
<a name="ln5591">    struct ath_tid *tid)</a>
<a name="ln5592">{</a>
<a name="ln5593">	struct ath_buf *bf;</a>
<a name="ln5594">	struct ath_txq *txq = sc-&gt;sc_ac2q[tid-&gt;ac];</a>
<a name="ln5595"> </a>
<a name="ln5596">	DPRINTF(sc, ATH_DEBUG_SW_TX, &quot;%s: node %p: TID %d: called\n&quot;,</a>
<a name="ln5597">	    __func__, an, tid-&gt;tid);</a>
<a name="ln5598"> </a>
<a name="ln5599">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln5600"> </a>
<a name="ln5601">	/* Check - is AMPDU pending or running? then print out something */</a>
<a name="ln5602">	if (ath_tx_ampdu_pending(sc, an, tid-&gt;tid))</a>
<a name="ln5603">		DPRINTF(sc, ATH_DEBUG_SW_TX, &quot;%s: tid=%d, ampdu pending?\n&quot;,</a>
<a name="ln5604">		    __func__, tid-&gt;tid);</a>
<a name="ln5605">	if (ath_tx_ampdu_running(sc, an, tid-&gt;tid))</a>
<a name="ln5606">		DPRINTF(sc, ATH_DEBUG_SW_TX, &quot;%s: tid=%d, ampdu running?\n&quot;,</a>
<a name="ln5607">		    __func__, tid-&gt;tid);</a>
<a name="ln5608"> </a>
<a name="ln5609">	for (;;) {</a>
<a name="ln5610"> </a>
<a name="ln5611">		/*</a>
<a name="ln5612">		 * If the upper layers have paused the TID, don't</a>
<a name="ln5613">		 * queue any further packets.</a>
<a name="ln5614">		 *</a>
<a name="ln5615">		 * XXX if we are leaking frames, make sure we decrement</a>
<a name="ln5616">		 * that counter _and_ we continue here.</a>
<a name="ln5617">		 */</a>
<a name="ln5618">		if (! ath_tx_tid_can_tx_or_sched(sc, tid))</a>
<a name="ln5619">			break;</a>
<a name="ln5620"> </a>
<a name="ln5621">		bf = ATH_TID_FIRST(tid);</a>
<a name="ln5622">		if (bf == NULL) {</a>
<a name="ln5623">			break;</a>
<a name="ln5624">		}</a>
<a name="ln5625"> </a>
<a name="ln5626">		ATH_TID_REMOVE(tid, bf, bf_list);</a>
<a name="ln5627"> </a>
<a name="ln5628">		/* Sanity check! */</a>
<a name="ln5629">		if (tid-&gt;tid != bf-&gt;bf_state.bfs_tid) {</a>
<a name="ln5630">			DPRINTF(sc, ATH_DEBUG_SW_TX, &quot;%s: bfs_tid %d !=&quot;</a>
<a name="ln5631">			    &quot; tid %d\n&quot;, __func__, bf-&gt;bf_state.bfs_tid,</a>
<a name="ln5632">			    tid-&gt;tid);</a>
<a name="ln5633">		}</a>
<a name="ln5634">		/* Normal completion handler */</a>
<a name="ln5635">		bf-&gt;bf_comp = ath_tx_normal_comp;</a>
<a name="ln5636"> </a>
<a name="ln5637">		/*</a>
<a name="ln5638">		 * Override this for now, until the non-aggregate</a>
<a name="ln5639">		 * completion handler correctly handles software retransmits.</a>
<a name="ln5640">		 */</a>
<a name="ln5641">		bf-&gt;bf_state.bfs_txflags |= HAL_TXDESC_CLRDMASK;</a>
<a name="ln5642"> </a>
<a name="ln5643">		/* Update CLRDMASK just before this frame is queued */</a>
<a name="ln5644">		ath_tx_update_clrdmask(sc, tid, bf);</a>
<a name="ln5645"> </a>
<a name="ln5646">		/* Program descriptors + rate control */</a>
<a name="ln5647">		ath_tx_do_ratelookup(sc, bf);</a>
<a name="ln5648">		ath_tx_calc_duration(sc, bf);</a>
<a name="ln5649">		ath_tx_calc_protection(sc, bf);</a>
<a name="ln5650">		ath_tx_set_rtscts(sc, bf);</a>
<a name="ln5651">		ath_tx_rate_fill_rcflags(sc, bf);</a>
<a name="ln5652">		ath_tx_setds(sc, bf);</a>
<a name="ln5653"> </a>
<a name="ln5654">		/*</a>
<a name="ln5655">		 * Update the current leak count if</a>
<a name="ln5656">		 * we're leaking frames; and set the</a>
<a name="ln5657">		 * MORE flag as appropriate.</a>
<a name="ln5658">		 */</a>
<a name="ln5659">		ath_tx_leak_count_update(sc, tid, bf);</a>
<a name="ln5660"> </a>
<a name="ln5661">		/* Track outstanding buffer count to hardware */</a>
<a name="ln5662">		/* aggregates are &quot;one&quot; buffer */</a>
<a name="ln5663">		tid-&gt;hwq_depth++;</a>
<a name="ln5664"> </a>
<a name="ln5665">		/* Punt to hardware or software txq */</a>
<a name="ln5666">		ath_tx_handoff(sc, txq, bf);</a>
<a name="ln5667">	}</a>
<a name="ln5668">}</a>
<a name="ln5669"> </a>
<a name="ln5670">/*</a>
<a name="ln5671"> * Schedule some packets to the given hardware queue.</a>
<a name="ln5672"> *</a>
<a name="ln5673"> * This function walks the list of TIDs (ie, ath_node TIDs</a>
<a name="ln5674"> * with queued traffic) and attempts to schedule traffic</a>
<a name="ln5675"> * from them.</a>
<a name="ln5676"> *</a>
<a name="ln5677"> * TID scheduling is implemented as a FIFO, with TIDs being</a>
<a name="ln5678"> * added to the end of the queue after some frames have been</a>
<a name="ln5679"> * scheduled.</a>
<a name="ln5680"> */</a>
<a name="ln5681">void</a>
<a name="ln5682">ath_txq_sched(struct ath_softc *sc, struct ath_txq *txq)</a>
<a name="ln5683">{</a>
<a name="ln5684">	struct ath_tid *tid, *next, *last;</a>
<a name="ln5685"> </a>
<a name="ln5686">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln5687"> </a>
<a name="ln5688">	/*</a>
<a name="ln5689">	 * For non-EDMA chips, aggr frames that have been built are</a>
<a name="ln5690">	 * in axq_aggr_depth, whether they've been scheduled or not.</a>
<a name="ln5691">	 * There's no FIFO, so txq-&gt;axq_depth is what's been scheduled</a>
<a name="ln5692">	 * to the hardware.</a>
<a name="ln5693">	 *</a>
<a name="ln5694">	 * For EDMA chips, we do it in two stages.  The existing code</a>
<a name="ln5695">	 * builds a list of frames to go to the hardware and the EDMA</a>
<a name="ln5696">	 * code turns it into a single entry to push into the FIFO.</a>
<a name="ln5697">	 * That way we don't take up one packet per FIFO slot.</a>
<a name="ln5698">	 * We do push one aggregate per FIFO slot though, just to keep</a>
<a name="ln5699">	 * things simple.</a>
<a name="ln5700">	 *</a>
<a name="ln5701">	 * The FIFO depth is what's in the hardware; the txq-&gt;axq_depth</a>
<a name="ln5702">	 * is what's been scheduled to the FIFO.</a>
<a name="ln5703">	 *</a>
<a name="ln5704">	 * fifo.axq_depth is the number of frames (or aggregates) pushed</a>
<a name="ln5705">	 *  into the EDMA FIFO.  For multi-frame lists, this is the number</a>
<a name="ln5706">	 *  of frames pushed in.</a>
<a name="ln5707">	 * axq_fifo_depth is the number of FIFO slots currently busy.</a>
<a name="ln5708">	 */</a>
<a name="ln5709"> </a>
<a name="ln5710">	/* For EDMA and non-EDMA, check built/scheduled against aggr limit */</a>
<a name="ln5711">	if (txq-&gt;axq_aggr_depth &gt;= sc-&gt;sc_hwq_limit_aggr) {</a>
<a name="ln5712">		sc-&gt;sc_aggr_stats.aggr_sched_nopkt++;</a>
<a name="ln5713">		return;</a>
<a name="ln5714">	}</a>
<a name="ln5715"> </a>
<a name="ln5716">	/*</a>
<a name="ln5717">	 * For non-EDMA chips, axq_depth is the &quot;what's scheduled to</a>
<a name="ln5718">	 * the hardware list&quot;.  For EDMA it's &quot;What's built for the hardware&quot;</a>
<a name="ln5719">	 * and fifo.axq_depth is how many frames have been dispatched</a>
<a name="ln5720">	 * already to the hardware.</a>
<a name="ln5721">	 */</a>
<a name="ln5722">	if (txq-&gt;axq_depth + txq-&gt;fifo.axq_depth &gt;= sc-&gt;sc_hwq_limit_nonaggr) {</a>
<a name="ln5723">		sc-&gt;sc_aggr_stats.aggr_sched_nopkt++;</a>
<a name="ln5724">		return;</a>
<a name="ln5725">	}</a>
<a name="ln5726"> </a>
<a name="ln5727">	last = TAILQ_LAST(&amp;txq-&gt;axq_tidq, axq_t_s);</a>
<a name="ln5728"> </a>
<a name="ln5729">	TAILQ_FOREACH_SAFE(tid, &amp;txq-&gt;axq_tidq, axq_qelem, next) {</a>
<a name="ln5730">		/*</a>
<a name="ln5731">		 * Suspend paused queues here; they'll be resumed</a>
<a name="ln5732">		 * once the addba completes or times out.</a>
<a name="ln5733">		 */</a>
<a name="ln5734">		DPRINTF(sc, ATH_DEBUG_SW_TX, &quot;%s: tid=%d, paused=%d\n&quot;,</a>
<a name="ln5735">		    __func__, tid-&gt;tid, tid-&gt;paused);</a>
<a name="ln5736">		ath_tx_tid_unsched(sc, tid);</a>
<a name="ln5737">		/*</a>
<a name="ln5738">		 * This node may be in power-save and we're leaking</a>
<a name="ln5739">		 * a frame; be careful.</a>
<a name="ln5740">		 */</a>
<a name="ln5741">		if (! ath_tx_tid_can_tx_or_sched(sc, tid)) {</a>
<a name="ln5742">			goto loop_done;</a>
<a name="ln5743">		}</a>
<a name="ln5744">		if (ath_tx_ampdu_running(sc, tid-&gt;an, tid-&gt;tid))</a>
<a name="ln5745">			ath_tx_tid_hw_queue_aggr(sc, tid-&gt;an, tid);</a>
<a name="ln5746">		else</a>
<a name="ln5747">			ath_tx_tid_hw_queue_norm(sc, tid-&gt;an, tid);</a>
<a name="ln5748"> </a>
<a name="ln5749">		/* Not empty? Re-schedule */</a>
<a name="ln5750">		if (tid-&gt;axq_depth != 0)</a>
<a name="ln5751">			ath_tx_tid_sched(sc, tid);</a>
<a name="ln5752"> </a>
<a name="ln5753">		/*</a>
<a name="ln5754">		 * Give the software queue time to aggregate more</a>
<a name="ln5755">		 * packets.  If we aren't running aggregation then</a>
<a name="ln5756">		 * we should still limit the hardware queue depth.</a>
<a name="ln5757">		 */</a>
<a name="ln5758">		/* XXX TXQ locking */</a>
<a name="ln5759">		if (txq-&gt;axq_aggr_depth + txq-&gt;fifo.axq_depth &gt;= sc-&gt;sc_hwq_limit_aggr) {</a>
<a name="ln5760">			break;</a>
<a name="ln5761">		}</a>
<a name="ln5762">		if (txq-&gt;axq_depth &gt;= sc-&gt;sc_hwq_limit_nonaggr) {</a>
<a name="ln5763">			break;</a>
<a name="ln5764">		}</a>
<a name="ln5765">loop_done:</a>
<a name="ln5766">		/*</a>
<a name="ln5767">		 * If this was the last entry on the original list, stop.</a>
<a name="ln5768">		 * Otherwise nodes that have been rescheduled onto the end</a>
<a name="ln5769">		 * of the TID FIFO list will just keep being rescheduled.</a>
<a name="ln5770">		 *</a>
<a name="ln5771">		 * XXX What should we do about nodes that were paused</a>
<a name="ln5772">		 * but are pending a leaking frame in response to a ps-poll?</a>
<a name="ln5773">		 * They'll be put at the front of the list; so they'll</a>
<a name="ln5774">		 * prematurely trigger this condition! Ew.</a>
<a name="ln5775">		 */</a>
<a name="ln5776">		if (tid == last)</a>
<a name="ln5777">			break;</a>
<a name="ln5778">	}</a>
<a name="ln5779">}</a>
<a name="ln5780"> </a>
<a name="ln5781">/*</a>
<a name="ln5782"> * TX addba handling</a>
<a name="ln5783"> */</a>
<a name="ln5784"> </a>
<a name="ln5785">/*</a>
<a name="ln5786"> * Return net80211 TID struct pointer, or NULL for none</a>
<a name="ln5787"> */</a>
<a name="ln5788">struct ieee80211_tx_ampdu *</a>
<a name="ln5789">ath_tx_get_tx_tid(struct ath_node *an, int tid)</a>
<a name="ln5790">{</a>
<a name="ln5791">	struct ieee80211_node *ni = &amp;an-&gt;an_node;</a>
<a name="ln5792">	struct ieee80211_tx_ampdu *tap;</a>
<a name="ln5793"> </a>
<a name="ln5794">	if (tid == IEEE80211_NONQOS_TID)</a>
<a name="ln5795">		return NULL;</a>
<a name="ln5796"> </a>
<a name="ln5797">	tap = &amp;ni-&gt;ni_tx_ampdu[tid];</a>
<a name="ln5798">	return tap;</a>
<a name="ln5799">}</a>
<a name="ln5800"> </a>
<a name="ln5801">/*</a>
<a name="ln5802"> * Is AMPDU-TX running?</a>
<a name="ln5803"> */</a>
<a name="ln5804">static int</a>
<a name="ln5805">ath_tx_ampdu_running(struct ath_softc *sc, struct ath_node *an, int tid)</a>
<a name="ln5806">{</a>
<a name="ln5807">	struct ieee80211_tx_ampdu *tap;</a>
<a name="ln5808"> </a>
<a name="ln5809">	if (tid == IEEE80211_NONQOS_TID)</a>
<a name="ln5810">		return 0;</a>
<a name="ln5811"> </a>
<a name="ln5812">	tap = ath_tx_get_tx_tid(an, tid);</a>
<a name="ln5813">	if (tap == NULL)</a>
<a name="ln5814">		return 0;	/* Not valid; default to not running */</a>
<a name="ln5815"> </a>
<a name="ln5816">	return !! (tap-&gt;txa_flags &amp; IEEE80211_AGGR_RUNNING);</a>
<a name="ln5817">}</a>
<a name="ln5818"> </a>
<a name="ln5819">/*</a>
<a name="ln5820"> * Is AMPDU-TX negotiation pending?</a>
<a name="ln5821"> */</a>
<a name="ln5822">static int</a>
<a name="ln5823">ath_tx_ampdu_pending(struct ath_softc *sc, struct ath_node *an, int tid)</a>
<a name="ln5824">{</a>
<a name="ln5825">	struct ieee80211_tx_ampdu *tap;</a>
<a name="ln5826"> </a>
<a name="ln5827">	if (tid == IEEE80211_NONQOS_TID)</a>
<a name="ln5828">		return 0;</a>
<a name="ln5829"> </a>
<a name="ln5830">	tap = ath_tx_get_tx_tid(an, tid);</a>
<a name="ln5831">	if (tap == NULL)</a>
<a name="ln5832">		return 0;	/* Not valid; default to not pending */</a>
<a name="ln5833"> </a>
<a name="ln5834">	return !! (tap-&gt;txa_flags &amp; IEEE80211_AGGR_XCHGPEND);</a>
<a name="ln5835">}</a>
<a name="ln5836"> </a>
<a name="ln5837">/*</a>
<a name="ln5838"> * Is AMPDU-TX pending for the given TID?</a>
<a name="ln5839"> */</a>
<a name="ln5840"> </a>
<a name="ln5841"> </a>
<a name="ln5842">/*</a>
<a name="ln5843"> * Method to handle sending an ADDBA request.</a>
<a name="ln5844"> *</a>
<a name="ln5845"> * We tap this so the relevant flags can be set to pause the TID</a>
<a name="ln5846"> * whilst waiting for the response.</a>
<a name="ln5847"> *</a>
<a name="ln5848"> * XXX there's no timeout handler we can override?</a>
<a name="ln5849"> */</a>
<a name="ln5850">int</a>
<a name="ln5851">ath_addba_request(struct ieee80211_node *ni, struct ieee80211_tx_ampdu *tap,</a>
<a name="ln5852">    int dialogtoken, int baparamset, int batimeout)</a>
<a name="ln5853">{</a>
<a name="ln5854">	struct ath_softc *sc = ni-&gt;ni_ic-&gt;ic_softc;</a>
<a name="ln5855">	int tid = tap-&gt;txa_tid;</a>
<a name="ln5856">	struct ath_node *an = ATH_NODE(ni);</a>
<a name="ln5857">	struct ath_tid *atid = &amp;an-&gt;an_tid[tid];</a>
<a name="ln5858"> </a>
<a name="ln5859">	/*</a>
<a name="ln5860">	 * XXX danger Will Robinson!</a>
<a name="ln5861">	 *</a>
<a name="ln5862">	 * Although the taskqueue may be running and scheduling some more</a>
<a name="ln5863">	 * packets, these should all be _before_ the addba sequence number.</a>
<a name="ln5864">	 * However, net80211 will keep self-assigning sequence numbers</a>
<a name="ln5865">	 * until addba has been negotiated.</a>
<a name="ln5866">	 *</a>
<a name="ln5867">	 * In the past, these packets would be &quot;paused&quot; (which still works</a>
<a name="ln5868">	 * fine, as they're being scheduled to the driver in the same</a>
<a name="ln5869">	 * serialised method which is calling the addba request routine)</a>
<a name="ln5870">	 * and when the aggregation session begins, they'll be dequeued</a>
<a name="ln5871">	 * as aggregate packets and added to the BAW. However, now there's</a>
<a name="ln5872">	 * a &quot;bf-&gt;bf_state.bfs_dobaw&quot; flag, and this isn't set for these</a>
<a name="ln5873">	 * packets. Thus they never get included in the BAW tracking and</a>
<a name="ln5874">	 * this can cause the initial burst of packets after the addba</a>
<a name="ln5875">	 * negotiation to &quot;hang&quot;, as they quickly fall outside the BAW.</a>
<a name="ln5876">	 *</a>
<a name="ln5877">	 * The &quot;eventual&quot; solution should be to tag these packets with</a>
<a name="ln5878">	 * dobaw. Although net80211 has given us a sequence number,</a>
<a name="ln5879">	 * it'll be &quot;after&quot; the left edge of the BAW and thus it'll</a>
<a name="ln5880">	 * fall within it.</a>
<a name="ln5881">	 */</a>
<a name="ln5882">	ATH_TX_LOCK(sc);</a>
<a name="ln5883">	/*</a>
<a name="ln5884">	 * This is a bit annoying.  Until net80211 HT code inherits some</a>
<a name="ln5885">	 * (any) locking, we may have this called in parallel BUT only</a>
<a name="ln5886">	 * one response/timeout will be called.  Grr.</a>
<a name="ln5887">	 */</a>
<a name="ln5888">	if (atid-&gt;addba_tx_pending == 0) {</a>
<a name="ln5889">		ath_tx_tid_pause(sc, atid);</a>
<a name="ln5890">		atid-&gt;addba_tx_pending = 1;</a>
<a name="ln5891">	}</a>
<a name="ln5892">	ATH_TX_UNLOCK(sc);</a>
<a name="ln5893"> </a>
<a name="ln5894">	DPRINTF(sc, ATH_DEBUG_SW_TX_CTRL,</a>
<a name="ln5895">	    &quot;%s: %6D: called; dialogtoken=%d, baparamset=%d, batimeout=%d\n&quot;,</a>
<a name="ln5896">	    __func__,</a>
<a name="ln5897">	    ni-&gt;ni_macaddr,</a>
<a name="ln5898">	    &quot;:&quot;,</a>
<a name="ln5899">	    dialogtoken, baparamset, batimeout);</a>
<a name="ln5900">	DPRINTF(sc, ATH_DEBUG_SW_TX_CTRL,</a>
<a name="ln5901">	    &quot;%s: txa_start=%d, ni_txseqs=%d\n&quot;,</a>
<a name="ln5902">	    __func__, tap-&gt;txa_start, ni-&gt;ni_txseqs[tid]);</a>
<a name="ln5903"> </a>
<a name="ln5904">	return sc-&gt;sc_addba_request(ni, tap, dialogtoken, baparamset,</a>
<a name="ln5905">	    batimeout);</a>
<a name="ln5906">}</a>
<a name="ln5907"> </a>
<a name="ln5908">/*</a>
<a name="ln5909"> * Handle an ADDBA response.</a>
<a name="ln5910"> *</a>
<a name="ln5911"> * We unpause the queue so TX'ing can resume.</a>
<a name="ln5912"> *</a>
<a name="ln5913"> * Any packets TX'ed from this point should be &quot;aggregate&quot; (whether</a>
<a name="ln5914"> * aggregate or not) so the BAW is updated.</a>
<a name="ln5915"> *</a>
<a name="ln5916"> * Note! net80211 keeps self-assigning sequence numbers until</a>
<a name="ln5917"> * ampdu is negotiated. This means the initially-negotiated BAW left</a>
<a name="ln5918"> * edge won't match the ni-&gt;ni_txseq.</a>
<a name="ln5919"> *</a>
<a name="ln5920"> * So, being very dirty, the BAW left edge is &quot;slid&quot; here to match</a>
<a name="ln5921"> * ni-&gt;ni_txseq.</a>
<a name="ln5922"> *</a>
<a name="ln5923"> * What likely SHOULD happen is that all packets subsequent to the</a>
<a name="ln5924"> * addba request should be tagged as aggregate and queued as non-aggregate</a>
<a name="ln5925"> * frames; thus updating the BAW. For now though, I'll just slide the</a>
<a name="ln5926"> * window.</a>
<a name="ln5927"> */</a>
<a name="ln5928">int</a>
<a name="ln5929">ath_addba_response(struct ieee80211_node *ni, struct ieee80211_tx_ampdu *tap,</a>
<a name="ln5930">    int status, int code, int batimeout)</a>
<a name="ln5931">{</a>
<a name="ln5932">	struct ath_softc *sc = ni-&gt;ni_ic-&gt;ic_softc;</a>
<a name="ln5933">	int tid = tap-&gt;txa_tid;</a>
<a name="ln5934">	struct ath_node *an = ATH_NODE(ni);</a>
<a name="ln5935">	struct ath_tid *atid = &amp;an-&gt;an_tid[tid];</a>
<a name="ln5936">	int r;</a>
<a name="ln5937"> </a>
<a name="ln5938">	DPRINTF(sc, ATH_DEBUG_SW_TX_CTRL,</a>
<a name="ln5939">	    &quot;%s: %6D: called; status=%d, code=%d, batimeout=%d\n&quot;, __func__,</a>
<a name="ln5940">	    ni-&gt;ni_macaddr,</a>
<a name="ln5941">	    &quot;:&quot;,</a>
<a name="ln5942">	    status, code, batimeout);</a>
<a name="ln5943"> </a>
<a name="ln5944">	DPRINTF(sc, ATH_DEBUG_SW_TX_CTRL,</a>
<a name="ln5945">	    &quot;%s: txa_start=%d, ni_txseqs=%d\n&quot;,</a>
<a name="ln5946">	    __func__, tap-&gt;txa_start, ni-&gt;ni_txseqs[tid]);</a>
<a name="ln5947"> </a>
<a name="ln5948">	/*</a>
<a name="ln5949">	 * Call this first, so the interface flags get updated</a>
<a name="ln5950">	 * before the TID is unpaused. Otherwise a race condition</a>
<a name="ln5951">	 * exists where the unpaused TID still doesn't yet have</a>
<a name="ln5952">	 * IEEE80211_AGGR_RUNNING set.</a>
<a name="ln5953">	 */</a>
<a name="ln5954">	r = sc-&gt;sc_addba_response(ni, tap, status, code, batimeout);</a>
<a name="ln5955"> </a>
<a name="ln5956">	ATH_TX_LOCK(sc);</a>
<a name="ln5957">	atid-&gt;addba_tx_pending = 0;</a>
<a name="ln5958">	/*</a>
<a name="ln5959">	 * XXX dirty!</a>
<a name="ln5960">	 * Slide the BAW left edge to wherever net80211 left it for us.</a>
<a name="ln5961">	 * Read above for more information.</a>
<a name="ln5962">	 */</a>
<a name="ln5963">	tap-&gt;txa_start = ni-&gt;ni_txseqs[tid];</a>
<a name="ln5964">	ath_tx_tid_resume(sc, atid);</a>
<a name="ln5965">	ATH_TX_UNLOCK(sc);</a>
<a name="ln5966">	return r;</a>
<a name="ln5967">}</a>
<a name="ln5968"> </a>
<a name="ln5969"> </a>
<a name="ln5970">/*</a>
<a name="ln5971"> * Stop ADDBA on a queue.</a>
<a name="ln5972"> *</a>
<a name="ln5973"> * This can be called whilst BAR TX is currently active on the queue,</a>
<a name="ln5974"> * so make sure this is unblocked before continuing.</a>
<a name="ln5975"> */</a>
<a name="ln5976">void</a>
<a name="ln5977">ath_addba_stop(struct ieee80211_node *ni, struct ieee80211_tx_ampdu *tap)</a>
<a name="ln5978">{</a>
<a name="ln5979">	struct ath_softc *sc = ni-&gt;ni_ic-&gt;ic_softc;</a>
<a name="ln5980">	int tid = tap-&gt;txa_tid;</a>
<a name="ln5981">	struct ath_node *an = ATH_NODE(ni);</a>
<a name="ln5982">	struct ath_tid *atid = &amp;an-&gt;an_tid[tid];</a>
<a name="ln5983">	ath_bufhead bf_cq;</a>
<a name="ln5984">	struct ath_buf *bf;</a>
<a name="ln5985"> </a>
<a name="ln5986">	DPRINTF(sc, ATH_DEBUG_SW_TX_CTRL, &quot;%s: %6D: called\n&quot;,</a>
<a name="ln5987">	    __func__,</a>
<a name="ln5988">	    ni-&gt;ni_macaddr,</a>
<a name="ln5989">	    &quot;:&quot;);</a>
<a name="ln5990"> </a>
<a name="ln5991">	/*</a>
<a name="ln5992">	 * Pause TID traffic early, so there aren't any races</a>
<a name="ln5993">	 * Unblock the pending BAR held traffic, if it's currently paused.</a>
<a name="ln5994">	 */</a>
<a name="ln5995">	ATH_TX_LOCK(sc);</a>
<a name="ln5996">	ath_tx_tid_pause(sc, atid);</a>
<a name="ln5997">	if (atid-&gt;bar_wait) {</a>
<a name="ln5998">		/*</a>
<a name="ln5999">		 * bar_unsuspend() expects bar_tx == 1, as it should be</a>
<a name="ln6000">		 * called from the TX completion path.  This quietens</a>
<a name="ln6001">		 * the warning.  It's cleared for us anyway.</a>
<a name="ln6002">		 */</a>
<a name="ln6003">		atid-&gt;bar_tx = 1;</a>
<a name="ln6004">		ath_tx_tid_bar_unsuspend(sc, atid);</a>
<a name="ln6005">	}</a>
<a name="ln6006">	ATH_TX_UNLOCK(sc);</a>
<a name="ln6007"> </a>
<a name="ln6008">	/* There's no need to hold the TXQ lock here */</a>
<a name="ln6009">	sc-&gt;sc_addba_stop(ni, tap);</a>
<a name="ln6010"> </a>
<a name="ln6011">	/*</a>
<a name="ln6012">	 * ath_tx_tid_cleanup will resume the TID if possible, otherwise</a>
<a name="ln6013">	 * it'll set the cleanup flag, and it'll be unpaused once</a>
<a name="ln6014">	 * things have been cleaned up.</a>
<a name="ln6015">	 */</a>
<a name="ln6016">	TAILQ_INIT(&amp;bf_cq);</a>
<a name="ln6017">	ATH_TX_LOCK(sc);</a>
<a name="ln6018"> </a>
<a name="ln6019">	/*</a>
<a name="ln6020">	 * In case there's a followup call to this, only call it</a>
<a name="ln6021">	 * if we don't have a cleanup in progress.</a>
<a name="ln6022">	 *</a>
<a name="ln6023">	 * Since we've paused the queue above, we need to make</a>
<a name="ln6024">	 * sure we unpause if there's already a cleanup in</a>
<a name="ln6025">	 * progress - it means something else is also doing</a>
<a name="ln6026">	 * this stuff, so we don't need to also keep it paused.</a>
<a name="ln6027">	 */</a>
<a name="ln6028">	if (atid-&gt;cleanup_inprogress) {</a>
<a name="ln6029">		ath_tx_tid_resume(sc, atid);</a>
<a name="ln6030">	} else {</a>
<a name="ln6031">		ath_tx_tid_cleanup(sc, an, tid, &amp;bf_cq);</a>
<a name="ln6032">		/*</a>
<a name="ln6033">		 * Unpause the TID if no cleanup is required.</a>
<a name="ln6034">		 */</a>
<a name="ln6035">		if (! atid-&gt;cleanup_inprogress)</a>
<a name="ln6036">			ath_tx_tid_resume(sc, atid);</a>
<a name="ln6037">	}</a>
<a name="ln6038">	ATH_TX_UNLOCK(sc);</a>
<a name="ln6039"> </a>
<a name="ln6040">	/* Handle completing frames and fail them */</a>
<a name="ln6041">	while ((bf = TAILQ_FIRST(&amp;bf_cq)) != NULL) {</a>
<a name="ln6042">		TAILQ_REMOVE(&amp;bf_cq, bf, bf_list);</a>
<a name="ln6043">		ath_tx_default_comp(sc, bf, 1);</a>
<a name="ln6044">	}</a>
<a name="ln6045"> </a>
<a name="ln6046">}</a>
<a name="ln6047"> </a>
<a name="ln6048">/*</a>
<a name="ln6049"> * Handle a node reassociation.</a>
<a name="ln6050"> *</a>
<a name="ln6051"> * We may have a bunch of frames queued to the hardware; those need</a>
<a name="ln6052"> * to be marked as cleanup.</a>
<a name="ln6053"> */</a>
<a name="ln6054">void</a>
<a name="ln6055">ath_tx_node_reassoc(struct ath_softc *sc, struct ath_node *an)</a>
<a name="ln6056">{</a>
<a name="ln6057">	struct ath_tid *tid;</a>
<a name="ln6058">	int i;</a>
<a name="ln6059">	ath_bufhead bf_cq;</a>
<a name="ln6060">	struct ath_buf *bf;</a>
<a name="ln6061"> </a>
<a name="ln6062">	TAILQ_INIT(&amp;bf_cq);</a>
<a name="ln6063"> </a>
<a name="ln6064">	ATH_TX_UNLOCK_ASSERT(sc);</a>
<a name="ln6065"> </a>
<a name="ln6066">	ATH_TX_LOCK(sc);</a>
<a name="ln6067">	for (i = 0; i &lt; IEEE80211_TID_SIZE; i++) {</a>
<a name="ln6068">		tid = &amp;an-&gt;an_tid[i];</a>
<a name="ln6069">		if (tid-&gt;hwq_depth == 0)</a>
<a name="ln6070">			continue;</a>
<a name="ln6071">		DPRINTF(sc, ATH_DEBUG_NODE,</a>
<a name="ln6072">		    &quot;%s: %6D: TID %d: cleaning up TID\n&quot;,</a>
<a name="ln6073">		    __func__,</a>
<a name="ln6074">		    an-&gt;an_node.ni_macaddr,</a>
<a name="ln6075">		    &quot;:&quot;,</a>
<a name="ln6076">		    i);</a>
<a name="ln6077">		/*</a>
<a name="ln6078">		 * In case there's a followup call to this, only call it</a>
<a name="ln6079">		 * if we don't have a cleanup in progress.</a>
<a name="ln6080">		 */</a>
<a name="ln6081">		if (! tid-&gt;cleanup_inprogress) {</a>
<a name="ln6082">			ath_tx_tid_pause(sc, tid);</a>
<a name="ln6083">			ath_tx_tid_cleanup(sc, an, i, &amp;bf_cq);</a>
<a name="ln6084">			/*</a>
<a name="ln6085">			 * Unpause the TID if no cleanup is required.</a>
<a name="ln6086">			 */</a>
<a name="ln6087">			if (! tid-&gt;cleanup_inprogress)</a>
<a name="ln6088">				ath_tx_tid_resume(sc, tid);</a>
<a name="ln6089">		}</a>
<a name="ln6090">	}</a>
<a name="ln6091">	ATH_TX_UNLOCK(sc);</a>
<a name="ln6092"> </a>
<a name="ln6093">	/* Handle completing frames and fail them */</a>
<a name="ln6094">	while ((bf = TAILQ_FIRST(&amp;bf_cq)) != NULL) {</a>
<a name="ln6095">		TAILQ_REMOVE(&amp;bf_cq, bf, bf_list);</a>
<a name="ln6096">		ath_tx_default_comp(sc, bf, 1);</a>
<a name="ln6097">	}</a>
<a name="ln6098">}</a>
<a name="ln6099"> </a>
<a name="ln6100">/*</a>
<a name="ln6101"> * Note: net80211 bar_timeout() doesn't call this function on BAR failure;</a>
<a name="ln6102"> * it simply tears down the aggregation session. Ew.</a>
<a name="ln6103"> *</a>
<a name="ln6104"> * It however will call ieee80211_ampdu_stop() which will call</a>
<a name="ln6105"> * ic-&gt;ic_addba_stop().</a>
<a name="ln6106"> *</a>
<a name="ln6107"> * XXX This uses a hard-coded max BAR count value; the whole</a>
<a name="ln6108"> * XXX BAR TX success or failure should be better handled!</a>
<a name="ln6109"> */</a>
<a name="ln6110">void</a>
<a name="ln6111">ath_bar_response(struct ieee80211_node *ni, struct ieee80211_tx_ampdu *tap,</a>
<a name="ln6112">    int status)</a>
<a name="ln6113">{</a>
<a name="ln6114">	struct ath_softc *sc = ni-&gt;ni_ic-&gt;ic_softc;</a>
<a name="ln6115">	int tid = tap-&gt;txa_tid;</a>
<a name="ln6116">	struct ath_node *an = ATH_NODE(ni);</a>
<a name="ln6117">	struct ath_tid *atid = &amp;an-&gt;an_tid[tid];</a>
<a name="ln6118">	int attempts = tap-&gt;txa_attempts;</a>
<a name="ln6119">	int old_txa_start;</a>
<a name="ln6120"> </a>
<a name="ln6121">	DPRINTF(sc, ATH_DEBUG_SW_TX_BAR,</a>
<a name="ln6122">	    &quot;%s: %6D: called; txa_tid=%d, atid-&gt;tid=%d, status=%d, attempts=%d, txa_start=%d, txa_seqpending=%d\n&quot;,</a>
<a name="ln6123">	    __func__,</a>
<a name="ln6124">	    ni-&gt;ni_macaddr,</a>
<a name="ln6125">	    &quot;:&quot;,</a>
<a name="ln6126">	    tap-&gt;txa_tid,</a>
<a name="ln6127">	    atid-&gt;tid,</a>
<a name="ln6128">	    status,</a>
<a name="ln6129">	    attempts,</a>
<a name="ln6130">	    tap-&gt;txa_start,</a>
<a name="ln6131">	    tap-&gt;txa_seqpending);</a>
<a name="ln6132"> </a>
<a name="ln6133">	/* Note: This may update the BAW details */</a>
<a name="ln6134">	/*</a>
<a name="ln6135">	 * XXX What if this does slide the BAW along? We need to somehow</a>
<a name="ln6136">	 * XXX either fix things when it does happen, or prevent the</a>
<a name="ln6137">	 * XXX seqpending value to be anything other than exactly what</a>
<a name="ln6138">	 * XXX the hell we want!</a>
<a name="ln6139">	 *</a>
<a name="ln6140">	 * XXX So for now, how I do this inside the TX lock for now</a>
<a name="ln6141">	 * XXX and just correct it afterwards? The below condition should</a>
<a name="ln6142">	 * XXX never happen and if it does I need to fix all kinds of things.</a>
<a name="ln6143">	 */</a>
<a name="ln6144">	ATH_TX_LOCK(sc);</a>
<a name="ln6145">	old_txa_start = tap-&gt;txa_start;</a>
<a name="ln6146">	sc-&gt;sc_bar_response(ni, tap, status);</a>
<a name="ln6147">	if (tap-&gt;txa_start != old_txa_start) {</a>
<a name="ln6148">		device_printf(sc-&gt;sc_dev, &quot;%s: tid=%d; txa_start=%d, old=%d, adjusting\n&quot;,</a>
<a name="ln6149">		    __func__,</a>
<a name="ln6150">		    tid,</a>
<a name="ln6151">		    tap-&gt;txa_start,</a>
<a name="ln6152">		    old_txa_start);</a>
<a name="ln6153">	}</a>
<a name="ln6154">	tap-&gt;txa_start = old_txa_start;</a>
<a name="ln6155">	ATH_TX_UNLOCK(sc);</a>
<a name="ln6156"> </a>
<a name="ln6157">	/* Unpause the TID */</a>
<a name="ln6158">	/*</a>
<a name="ln6159">	 * XXX if this is attempt=50, the TID will be downgraded</a>
<a name="ln6160">	 * XXX to a non-aggregate session. So we must unpause the</a>
<a name="ln6161">	 * XXX TID here or it'll never be done.</a>
<a name="ln6162">	 *</a>
<a name="ln6163">	 * Also, don't call it if bar_tx/bar_wait are 0; something</a>
<a name="ln6164">	 * has beaten us to the punch? (XXX figure out what?)</a>
<a name="ln6165">	 */</a>
<a name="ln6166">	if (status == 0 || attempts == 50) {</a>
<a name="ln6167">		ATH_TX_LOCK(sc);</a>
<a name="ln6168">		if (atid-&gt;bar_tx == 0 || atid-&gt;bar_wait == 0)</a>
<a name="ln6169">			DPRINTF(sc, ATH_DEBUG_SW_TX_BAR,</a>
<a name="ln6170">			    &quot;%s: huh? bar_tx=%d, bar_wait=%d\n&quot;,</a>
<a name="ln6171">			    __func__,</a>
<a name="ln6172">			    atid-&gt;bar_tx, atid-&gt;bar_wait);</a>
<a name="ln6173">		else</a>
<a name="ln6174">			ath_tx_tid_bar_unsuspend(sc, atid);</a>
<a name="ln6175">		ATH_TX_UNLOCK(sc);</a>
<a name="ln6176">	}</a>
<a name="ln6177">}</a>
<a name="ln6178"> </a>
<a name="ln6179">/*</a>
<a name="ln6180"> * This is called whenever the pending ADDBA request times out.</a>
<a name="ln6181"> * Unpause and reschedule the TID.</a>
<a name="ln6182"> */</a>
<a name="ln6183">void</a>
<a name="ln6184">ath_addba_response_timeout(struct ieee80211_node *ni,</a>
<a name="ln6185">    struct ieee80211_tx_ampdu *tap)</a>
<a name="ln6186">{</a>
<a name="ln6187">	struct ath_softc *sc = ni-&gt;ni_ic-&gt;ic_softc;</a>
<a name="ln6188">	int tid = tap-&gt;txa_tid;</a>
<a name="ln6189">	struct ath_node *an = ATH_NODE(ni);</a>
<a name="ln6190">	struct ath_tid *atid = &amp;an-&gt;an_tid[tid];</a>
<a name="ln6191"> </a>
<a name="ln6192">	DPRINTF(sc, ATH_DEBUG_SW_TX_CTRL,</a>
<a name="ln6193">	    &quot;%s: %6D: TID=%d, called; resuming\n&quot;,</a>
<a name="ln6194">	    __func__,</a>
<a name="ln6195">	    ni-&gt;ni_macaddr,</a>
<a name="ln6196">	    &quot;:&quot;,</a>
<a name="ln6197">	    tid);</a>
<a name="ln6198"> </a>
<a name="ln6199">	ATH_TX_LOCK(sc);</a>
<a name="ln6200">	atid-&gt;addba_tx_pending = 0;</a>
<a name="ln6201">	ATH_TX_UNLOCK(sc);</a>
<a name="ln6202"> </a>
<a name="ln6203">	/* Note: This updates the aggregate state to (again) pending */</a>
<a name="ln6204">	sc-&gt;sc_addba_response_timeout(ni, tap);</a>
<a name="ln6205"> </a>
<a name="ln6206">	/* Unpause the TID; which reschedules it */</a>
<a name="ln6207">	ATH_TX_LOCK(sc);</a>
<a name="ln6208">	ath_tx_tid_resume(sc, atid);</a>
<a name="ln6209">	ATH_TX_UNLOCK(sc);</a>
<a name="ln6210">}</a>
<a name="ln6211"> </a>
<a name="ln6212">/*</a>
<a name="ln6213"> * Check if a node is asleep or not.</a>
<a name="ln6214"> */</a>
<a name="ln6215">int</a>
<a name="ln6216">ath_tx_node_is_asleep(struct ath_softc *sc, struct ath_node *an)</a>
<a name="ln6217">{</a>
<a name="ln6218"> </a>
<a name="ln6219">	ATH_TX_LOCK_ASSERT(sc);</a>
<a name="ln6220"> </a>
<a name="ln6221">	return (an-&gt;an_is_powersave);</a>
<a name="ln6222">}</a>
<a name="ln6223"> </a>
<a name="ln6224">/*</a>
<a name="ln6225"> * Mark a node as currently &quot;in powersaving.&quot;</a>
<a name="ln6226"> * This suspends all traffic on the node.</a>
<a name="ln6227"> *</a>
<a name="ln6228"> * This must be called with the node/tx locks free.</a>
<a name="ln6229"> *</a>
<a name="ln6230"> * XXX TODO: the locking silliness below is due to how the node</a>
<a name="ln6231"> * locking currently works.  Right now, the node lock is grabbed</a>
<a name="ln6232"> * to do rate control lookups and these are done with the TX</a>
<a name="ln6233"> * queue lock held.  This means the node lock can't be grabbed</a>
<a name="ln6234"> * first here or a LOR will occur.</a>
<a name="ln6235"> *</a>
<a name="ln6236"> * Eventually (hopefully!) the TX path code will only grab</a>
<a name="ln6237"> * the TXQ lock when transmitting and the ath_node lock when</a>
<a name="ln6238"> * doing node/TID operations.  There are other complications -</a>
<a name="ln6239"> * the sched/unsched operations involve walking the per-txq</a>
<a name="ln6240"> * 'active tid' list and this requires both locks to be held.</a>
<a name="ln6241"> */</a>
<a name="ln6242">void</a>
<a name="ln6243">ath_tx_node_sleep(struct ath_softc *sc, struct ath_node *an)</a>
<a name="ln6244">{</a>
<a name="ln6245">	struct ath_tid *atid;</a>
<a name="ln6246">	struct ath_txq *txq;</a>
<a name="ln6247">	int tid;</a>
<a name="ln6248"> </a>
<a name="ln6249">	ATH_TX_UNLOCK_ASSERT(sc);</a>
<a name="ln6250"> </a>
<a name="ln6251">	/* Suspend all traffic on the node */</a>
<a name="ln6252">	ATH_TX_LOCK(sc);</a>
<a name="ln6253"> </a>
<a name="ln6254">	if (an-&gt;an_is_powersave) {</a>
<a name="ln6255">		DPRINTF(sc, ATH_DEBUG_XMIT,</a>
<a name="ln6256">		    &quot;%s: %6D: node was already asleep!\n&quot;,</a>
<a name="ln6257">		    __func__, an-&gt;an_node.ni_macaddr, &quot;:&quot;);</a>
<a name="ln6258">		ATH_TX_UNLOCK(sc);</a>
<a name="ln6259">		return;</a>
<a name="ln6260">	}</a>
<a name="ln6261"> </a>
<a name="ln6262">	for (tid = 0; tid &lt; IEEE80211_TID_SIZE; tid++) {</a>
<a name="ln6263">		atid = &amp;an-&gt;an_tid[tid];</a>
<a name="ln6264">		txq = sc-&gt;sc_ac2q[atid-&gt;ac];</a>
<a name="ln6265"> </a>
<a name="ln6266">		ath_tx_tid_pause(sc, atid);</a>
<a name="ln6267">	}</a>
<a name="ln6268"> </a>
<a name="ln6269">	/* Mark node as in powersaving */</a>
<a name="ln6270">	an-&gt;an_is_powersave = 1;</a>
<a name="ln6271"> </a>
<a name="ln6272">	ATH_TX_UNLOCK(sc);</a>
<a name="ln6273">}</a>
<a name="ln6274"> </a>
<a name="ln6275">/*</a>
<a name="ln6276"> * Mark a node as currently &quot;awake.&quot;</a>
<a name="ln6277"> * This resumes all traffic to the node.</a>
<a name="ln6278"> */</a>
<a name="ln6279">void</a>
<a name="ln6280">ath_tx_node_wakeup(struct ath_softc *sc, struct ath_node *an)</a>
<a name="ln6281">{</a>
<a name="ln6282">	struct ath_tid *atid;</a>
<a name="ln6283">	struct ath_txq *txq;</a>
<a name="ln6284">	int tid;</a>
<a name="ln6285"> </a>
<a name="ln6286">	ATH_TX_UNLOCK_ASSERT(sc);</a>
<a name="ln6287"> </a>
<a name="ln6288">	ATH_TX_LOCK(sc);</a>
<a name="ln6289"> </a>
<a name="ln6290">	/* !? */</a>
<a name="ln6291">	if (an-&gt;an_is_powersave == 0) {</a>
<a name="ln6292">		ATH_TX_UNLOCK(sc);</a>
<a name="ln6293">		DPRINTF(sc, ATH_DEBUG_XMIT,</a>
<a name="ln6294">		    &quot;%s: an=%p: node was already awake\n&quot;,</a>
<a name="ln6295">		    __func__, an);</a>
<a name="ln6296">		return;</a>
<a name="ln6297">	}</a>
<a name="ln6298"> </a>
<a name="ln6299">	/* Mark node as awake */</a>
<a name="ln6300">	an-&gt;an_is_powersave = 0;</a>
<a name="ln6301">	/*</a>
<a name="ln6302">	 * Clear any pending leaked frame requests</a>
<a name="ln6303">	 */</a>
<a name="ln6304">	an-&gt;an_leak_count = 0;</a>
<a name="ln6305"> </a>
<a name="ln6306">	for (tid = 0; tid &lt; IEEE80211_TID_SIZE; tid++) {</a>
<a name="ln6307">		atid = &amp;an-&gt;an_tid[tid];</a>
<a name="ln6308">		txq = sc-&gt;sc_ac2q[atid-&gt;ac];</a>
<a name="ln6309"> </a>
<a name="ln6310">		ath_tx_tid_resume(sc, atid);</a>
<a name="ln6311">	}</a>
<a name="ln6312">	ATH_TX_UNLOCK(sc);</a>
<a name="ln6313">}</a>
<a name="ln6314"> </a>
<a name="ln6315">static int</a>
<a name="ln6316">ath_legacy_dma_txsetup(struct ath_softc *sc)</a>
<a name="ln6317">{</a>
<a name="ln6318"> </a>
<a name="ln6319">	/* nothing new needed */</a>
<a name="ln6320">	return (0);</a>
<a name="ln6321">}</a>
<a name="ln6322"> </a>
<a name="ln6323">static int</a>
<a name="ln6324">ath_legacy_dma_txteardown(struct ath_softc *sc)</a>
<a name="ln6325">{</a>
<a name="ln6326"> </a>
<a name="ln6327">	/* nothing new needed */</a>
<a name="ln6328">	return (0);</a>
<a name="ln6329">}</a>
<a name="ln6330"> </a>
<a name="ln6331">void</a>
<a name="ln6332">ath_xmit_setup_legacy(struct ath_softc *sc)</a>
<a name="ln6333">{</a>
<a name="ln6334">	/*</a>
<a name="ln6335">	 * For now, just set the descriptor length to sizeof(ath_desc);</a>
<a name="ln6336">	 * worry about extracting the real length out of the HAL later.</a>
<a name="ln6337">	 */</a>
<a name="ln6338">	sc-&gt;sc_tx_desclen = sizeof(struct ath_desc);</a>
<a name="ln6339">	sc-&gt;sc_tx_statuslen = sizeof(struct ath_desc);</a>
<a name="ln6340">	sc-&gt;sc_tx_nmaps = 1;	/* only one buffer per TX desc */</a>
<a name="ln6341"> </a>
<a name="ln6342">	sc-&gt;sc_tx.xmit_setup = ath_legacy_dma_txsetup;</a>
<a name="ln6343">	sc-&gt;sc_tx.xmit_teardown = ath_legacy_dma_txteardown;</a>
<a name="ln6344">	sc-&gt;sc_tx.xmit_attach_comp_func = ath_legacy_attach_comp_func;</a>
<a name="ln6345"> </a>
<a name="ln6346">	sc-&gt;sc_tx.xmit_dma_restart = ath_legacy_tx_dma_restart;</a>
<a name="ln6347">	sc-&gt;sc_tx.xmit_handoff = ath_legacy_xmit_handoff;</a>
<a name="ln6348"> </a>
<a name="ln6349">	sc-&gt;sc_tx.xmit_drain = ath_legacy_tx_drain;</a>
<a name="ln6350">}</a>

</code></pre>
<div class="balloon" rel="3951"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 't == 0' is always true.</p></div>
<div class="balloon" rel="4963"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'ts.ts_status == 0' is always true.</p></div>
<div class="balloon" rel="3967"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 't == 0' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
