
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>nbd.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2006-2007, Fran√ßois Revol. All rights reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> */</a>
<a name="ln5"> </a>
<a name="ln6">/*</a>
<a name="ln7"> * nbd driver for Haiku</a>
<a name="ln8"> *</a>
<a name="ln9"> * Maps a Network Block Device as virtual partitions.</a>
<a name="ln10"> */</a>
<a name="ln11"> </a>
<a name="ln12"> </a>
<a name="ln13">#include &lt;ByteOrder.h&gt;</a>
<a name="ln14">#include &lt;KernelExport.h&gt;</a>
<a name="ln15">#include &lt;Drivers.h&gt;</a>
<a name="ln16">#include &lt;driver_settings.h&gt;</a>
<a name="ln17">#include &lt;Errors.h&gt;</a>
<a name="ln18">#include &lt;errno.h&gt;</a>
<a name="ln19">#include &lt;stdio.h&gt;</a>
<a name="ln20">#include &lt;stdlib.h&gt;</a>
<a name="ln21">#include &lt;string.h&gt;</a>
<a name="ln22">#include &lt;unistd.h&gt;</a>
<a name="ln23">#include &lt;ksocket.h&gt;</a>
<a name="ln24">#include &lt;netinet/in.h&gt;</a>
<a name="ln25"> </a>
<a name="ln26">//#define DEBUG 1</a>
<a name="ln27"> </a>
<a name="ln28">/* on the first open(), open ourselves for some seconds, </a>
<a name="ln29"> * to avoid trying to reconnect and failing on a 2nd open,</a>
<a name="ln30"> * as it happens with the python server.</a>
<a name="ln31"> */</a>
<a name="ln32">//#define MOUNT_KLUDGE</a>
<a name="ln33"> </a>
<a name="ln34"> </a>
<a name="ln35">/* names, ohh names... */</a>
<a name="ln36">#ifndef SHUT_RDWR</a>
<a name="ln37">#define SHUT_RDWR SHUTDOWN_BOTH </a>
<a name="ln38">#endif</a>
<a name="ln39"> </a>
<a name="ln40">/* locking support */</a>
<a name="ln41">#ifdef __HAIKU__</a>
<a name="ln42">#include &lt;kernel/lock.h&gt;</a>
<a name="ln43">#else</a>
<a name="ln44">/* wrappers for R5 */</a>
<a name="ln45">#ifndef _IMPEXP_KERNEL</a>
<a name="ln46">#define _IMPEXP_KERNEL</a>
<a name="ln47">#endif</a>
<a name="ln48">#include &quot;lock.h&quot;</a>
<a name="ln49">#define mutex lock</a>
<a name="ln50">#define mutex_init new_lock</a>
<a name="ln51">#define mutex_destroy free_lock</a>
<a name="ln52">#define mutex_lock LOCK</a>
<a name="ln53">#define mutex_unlock UNLOCK</a>
<a name="ln54">#endif</a>
<a name="ln55"> </a>
<a name="ln56">#include &quot;nbd.h&quot;</a>
<a name="ln57"> </a>
<a name="ln58">#define DRV &quot;nbd&quot;</a>
<a name="ln59">#define DP &quot;nbd:&quot;</a>
<a name="ln60">#define MAX_NBDS 4</a>
<a name="ln61">#define DEVICE_PREFIX &quot;disk/virtual/nbd/&quot;</a>
<a name="ln62">#define DEVICE_FMT DEVICE_PREFIX &quot;%d/raw&quot;</a>
<a name="ln63">#define DEVICE_NAME_MAX 32</a>
<a name="ln64">#define MAX_REQ_SIZE (32*1024*1024)</a>
<a name="ln65">#define BLKSIZE 512</a>
<a name="ln66"> </a>
<a name="ln67">/* debugging */</a>
<a name="ln68">#if DEBUG</a>
<a name="ln69">#define PRINT(a) dprintf a</a>
<a name="ln70">#define WHICH(dev) ((int)(dev - nbd_devices))</a>
<a name="ln71">#else</a>
<a name="ln72">#define PRINT(a)</a>
<a name="ln73">#endif</a>
<a name="ln74"> </a>
<a name="ln75">struct nbd_request_entry {</a>
<a name="ln76">	struct nbd_request_entry *next;</a>
<a name="ln77">	struct nbd_request req; /* net byte order */</a>
<a name="ln78">	struct nbd_reply reply; /* net byte order */</a>
<a name="ln79">	sem_id sem;</a>
<a name="ln80">	bool replied;</a>
<a name="ln81">	bool discard;</a>
<a name="ln82">	uint64 handle;</a>
<a name="ln83">	uint32 type;</a>
<a name="ln84">	uint64 from;</a>
<a name="ln85">	size_t len;</a>
<a name="ln86">	void *buffer; /* write: ptr to passed buffer; read: ptr to malloc()ed extra */</a>
<a name="ln87">};</a>
<a name="ln88"> </a>
<a name="ln89">struct nbd_device {</a>
<a name="ln90">	bool valid;</a>
<a name="ln91">	bool readonly;</a>
<a name="ln92">	struct sockaddr_in server;</a>
<a name="ln93">	mutex ben;</a>
<a name="ln94">	vint32 refcnt;</a>
<a name="ln95">	uint64 req; /* next ID for requests */</a>
<a name="ln96">	int sock;</a>
<a name="ln97">	thread_id postoffice;</a>
<a name="ln98">	uint64 size;</a>
<a name="ln99">	struct nbd_request_entry *reqs;</a>
<a name="ln100">#ifdef MOUNT_KLUDGE</a>
<a name="ln101">	int kludge;</a>
<a name="ln102">#endif</a>
<a name="ln103">};</a>
<a name="ln104"> </a>
<a name="ln105">typedef struct cookie {</a>
<a name="ln106">	struct nbd_device *dev;</a>
<a name="ln107">	</a>
<a name="ln108">} cookie_t;</a>
<a name="ln109"> </a>
<a name="ln110">/* data=NULL on read */</a>
<a name="ln111">status_t nbd_alloc_request(struct nbd_device *dev, struct nbd_request_entry **req, uint32 type, off_t from, size_t len, const char *data);</a>
<a name="ln112">status_t nbd_queue_request(struct nbd_device *dev, struct nbd_request_entry *req);</a>
<a name="ln113">status_t nbd_dequeue_request(struct nbd_device *dev, uint64 handle, struct nbd_request_entry **req);</a>
<a name="ln114">status_t nbd_free_request(struct nbd_device *dev, struct nbd_request_entry *req);</a>
<a name="ln115"> </a>
<a name="ln116">struct nbd_device *nbd_find_device(const char* name);</a>
<a name="ln117"> </a>
<a name="ln118">int32 nbd_postoffice(void *arg);</a>
<a name="ln119">status_t nbd_connect(struct nbd_device *dev);</a>
<a name="ln120">status_t nbd_teardown(struct nbd_device *dev);</a>
<a name="ln121">status_t nbd_post_request(struct nbd_device *dev, struct nbd_request_entry *req);</a>
<a name="ln122"> </a>
<a name="ln123">status_t nbd_open(const char *name, uint32 flags, cookie_t **cookie);</a>
<a name="ln124">status_t nbd_close(cookie_t *cookie);</a>
<a name="ln125">status_t nbd_free(cookie_t *cookie);</a>
<a name="ln126">status_t nbd_control(cookie_t *cookie, uint32 op, void *data, size_t len);</a>
<a name="ln127">status_t nbd_read(cookie_t *cookie, off_t position, void *data, size_t *numbytes);</a>
<a name="ln128">status_t nbd_write(cookie_t *cookie, off_t position, const void *data, size_t *numbytes);</a>
<a name="ln129"> </a>
<a name="ln130">KSOCKET_MODULE_DECL;</a>
<a name="ln131"> </a>
<a name="ln132">/* HACK:</a>
<a name="ln133"> * In BONE at least, if connect() fails (EINTR or ETIMEDOUT)</a>
<a name="ln134"> * keeps locked pages around (likely a bone_data,</a>
<a name="ln135"> * until TCP gets the last ACK). If that happens, we snooze()</a>
<a name="ln136"> * in unload_driver() to let TCP timeout before the kernel</a>
<a name="ln137"> * tries to delete the image. */</a>
<a name="ln138">bool gDelayUnload = false;</a>
<a name="ln139">#define BONE_TEARDOWN_DELAY 60000000</a>
<a name="ln140"> </a>
<a name="ln141">#if 0</a>
<a name="ln142">#pragma mark ==== support ====</a>
<a name="ln143">#endif</a>
<a name="ln144"> </a>
<a name="ln145">// move that to ksocket inlined</a>
<a name="ln146">static int kinet_aton(const char *in, struct in_addr *addr)</a>
<a name="ln147">{</a>
<a name="ln148">	int i;</a>
<a name="ln149">	unsigned long a;</a>
<a name="ln150">	uint32 inaddr = 0L;</a>
<a name="ln151">	char *p = (char *)in;</a>
<a name="ln152">	for (i = 0; i &lt; 4; i++) {</a>
<a name="ln153">		a = strtoul(p, &amp;p, 10);</a>
<a name="ln154">		if (!p)</a>
<a name="ln155">			return -1;</a>
<a name="ln156">		inaddr = (inaddr &gt;&gt; 8) | ((a &amp; 0x0ff) &lt;&lt; 24);</a>
<a name="ln157">		*(uint32 *)addr = inaddr;</a>
<a name="ln158">		if (!*p)</a>
<a name="ln159">			return 0;</a>
<a name="ln160">		p++;</a>
<a name="ln161">	}</a>
<a name="ln162">	return 0;</a>
<a name="ln163">}</a>
<a name="ln164"> </a>
<a name="ln165">#if 0</a>
<a name="ln166">#pragma mark ==== request manager ====</a>
<a name="ln167">#endif</a>
<a name="ln168"> </a>
<a name="ln169">status_t nbd_alloc_request(struct nbd_device *dev, struct nbd_request_entry **req, uint32 type, off_t from, size_t len, const char *data)</a>
<a name="ln170">{</a>
<a name="ln171">	bool w = (type == NBD_CMD_WRITE);</a>
<a name="ln172">	struct nbd_request_entry *r;</a>
<a name="ln173">	status_t err = EINVAL;</a>
<a name="ln174">	uint64 handle;</a>
<a name="ln175">	PRINT((DP &quot;&gt;%s(%&quot; B_PRIu32 &quot;, %&quot; B_PRIdOFF &quot;, %ld)\n&quot;, __FUNCTION__, type,</a>
<a name="ln176">		from, len));</a>
<a name="ln177">	</a>
<a name="ln178">	if (type != NBD_CMD_READ &amp;&amp; type != NBD_CMD_WRITE &amp;&amp; type != NBD_CMD_DISC)</a>
<a name="ln179">		return err;</a>
<a name="ln180">	if (!dev || !req || from &lt; 0)</a>
<a name="ln181">		return err;</a>
<a name="ln182">	</a>
<a name="ln183">	//LOCK</a>
<a name="ln184">	err = mutex_lock(&amp;dev-&gt;ben);</a>
<a name="ln185">	if (err)</a>
<a name="ln186">		return err;</a>
<a name="ln187"> </a>
<a name="ln188">	// atomic</a>
<a name="ln189">	handle = dev-&gt;req++;</a>
<a name="ln190">	</a>
<a name="ln191">	</a>
<a name="ln192">	//UNLOCK</a>
<a name="ln193">	mutex_unlock(&amp;dev-&gt;ben);</a>
<a name="ln194">	</a>
<a name="ln195">	err = ENOMEM;</a>
<a name="ln196">	r = malloc(sizeof(struct nbd_request_entry) + (w ? 0 : len));</a>
<a name="ln197">	if (r == NULL)</a>
<a name="ln198">		goto err0;</a>
<a name="ln199">	r-&gt;next = NULL;</a>
<a name="ln200">	err = r-&gt;sem = create_sem(0, &quot;nbd request sem&quot;);</a>
<a name="ln201">	if (err &lt; 0)</a>
<a name="ln202">		goto err1;</a>
<a name="ln203">	</a>
<a name="ln204">	r-&gt;replied = false;</a>
<a name="ln205">	r-&gt;discard = false;</a>
<a name="ln206">	r-&gt;handle = handle;</a>
<a name="ln207">	r-&gt;type = type;</a>
<a name="ln208">	r-&gt;from = from;</a>
<a name="ln209">	r-&gt;len = len;</a>
<a name="ln210">	</a>
<a name="ln211">	r-&gt;req.magic = B_HOST_TO_BENDIAN_INT32(NBD_REQUEST_MAGIC);</a>
<a name="ln212">	r-&gt;req.type = B_HOST_TO_BENDIAN_INT32(type);</a>
<a name="ln213">	r-&gt;req.handle = B_HOST_TO_BENDIAN_INT64(r-&gt;handle);</a>
<a name="ln214">	r-&gt;req.from = B_HOST_TO_BENDIAN_INT64(r-&gt;from);</a>
<a name="ln215">	r-&gt;req.len = B_HOST_TO_BENDIAN_INT32(len);</a>
<a name="ln216">	</a>
<a name="ln217">	r-&gt;buffer = (void *)(w ? data : (((char *)r) + sizeof(struct nbd_request_entry)));</a>
<a name="ln218">	</a>
<a name="ln219">	*req = r;</a>
<a name="ln220">	return B_OK;</a>
<a name="ln221"> </a>
<a name="ln222">err1:</a>
<a name="ln223">	free(r);</a>
<a name="ln224">err0:</a>
<a name="ln225">	dprintf(DP &quot; %s: error 0x%08&quot; B_PRIx32 &quot;\n&quot;, __FUNCTION__, err);</a>
<a name="ln226">	return err;</a>
<a name="ln227">}</a>
<a name="ln228"> </a>
<a name="ln229"> </a>
<a name="ln230">status_t nbd_queue_request(struct nbd_device *dev, struct nbd_request_entry *req)</a>
<a name="ln231">{</a>
<a name="ln232">	PRINT((DP &quot;&gt;%s(handle:%&quot; B_PRIu64 &quot;)\n&quot;, __FUNCTION__, req-&gt;handle));</a>
<a name="ln233">	req-&gt;next = dev-&gt;reqs;</a>
<a name="ln234">	dev-&gt;reqs = req;</a>
<a name="ln235">	return B_OK;</a>
<a name="ln236">}</a>
<a name="ln237"> </a>
<a name="ln238"> </a>
<a name="ln239">status_t nbd_dequeue_request(struct nbd_device *dev, uint64 handle, struct nbd_request_entry **req)</a>
<a name="ln240">{</a>
<a name="ln241">	struct nbd_request_entry *r, *prev;</a>
<a name="ln242">	PRINT((DP &quot;&gt;%s(handle:%&quot; B_PRIu64 &quot;)\n&quot;, __FUNCTION__, handle));</a>
<a name="ln243">	r = dev-&gt;reqs;</a>
<a name="ln244">	prev = NULL;</a>
<a name="ln245">	while (r &amp;&amp; r-&gt;handle != handle) {</a>
<a name="ln246">		prev = r;</a>
<a name="ln247">		r = r-&gt;next;</a>
<a name="ln248">	}</a>
<a name="ln249">	if (!r)</a>
<a name="ln250">		return ENOENT;</a>
<a name="ln251">	</a>
<a name="ln252">	if (prev)</a>
<a name="ln253">		prev-&gt;next = r-&gt;next;</a>
<a name="ln254">	else</a>
<a name="ln255">		dev-&gt;reqs = r-&gt;next;</a>
<a name="ln256">	</a>
<a name="ln257">	*req = r;</a>
<a name="ln258">	return B_OK;</a>
<a name="ln259">}</a>
<a name="ln260"> </a>
<a name="ln261"> </a>
<a name="ln262">status_t nbd_free_request(struct nbd_device *dev, struct nbd_request_entry *req)</a>
<a name="ln263">{</a>
<a name="ln264">	PRINT((DP &quot;&gt;%s(handle:%&quot; B_PRIu64 &quot;)\n&quot;, __FUNCTION__, req-&gt;handle));</a>
<a name="ln265">	delete_sem(req-&gt;sem);</a>
<a name="ln266">	free(req);</a>
<a name="ln267">	return B_OK;</a>
<a name="ln268">}</a>
<a name="ln269"> </a>
<a name="ln270"> </a>
<a name="ln271">#if 0</a>
<a name="ln272">#pragma mark ==== nbd handler ====</a>
<a name="ln273">#endif</a>
<a name="ln274"> </a>
<a name="ln275">int32 nbd_postoffice(void *arg)</a>
<a name="ln276">{</a>
<a name="ln277">	struct nbd_device *dev = (struct nbd_device *)arg;</a>
<a name="ln278">	struct nbd_request_entry *req = NULL;</a>
<a name="ln279">	struct nbd_reply reply;</a>
<a name="ln280">	status_t err;</a>
<a name="ln281">	const char *reason;</a>
<a name="ln282">	PRINT((DP &quot;&gt;%s()\n&quot;, __FUNCTION__));</a>
<a name="ln283">	</a>
<a name="ln284">	for (;;) {</a>
<a name="ln285">		reason = &quot;recv&quot;;</a>
<a name="ln286">		err = krecv(dev-&gt;sock, &amp;reply, sizeof(reply), 0);</a>
<a name="ln287">		if (err == -1 &amp;&amp; errno &lt; 0)</a>
<a name="ln288">			err = errno;</a>
<a name="ln289">		if (err &lt; 0)</a>
<a name="ln290">			goto err;</a>
<a name="ln291">		reason = &quot;recv:size&quot;;</a>
<a name="ln292">		if (err &lt; sizeof(reply))</a>
<a name="ln293">			err = EINVAL;</a>
<a name="ln294">		if (err &lt; 0)</a>
<a name="ln295">			goto err;</a>
<a name="ln296">		reason = &quot;magic&quot;;</a>
<a name="ln297">		err = EINVAL;</a>
<a name="ln298">		if (B_BENDIAN_TO_HOST_INT32(reply.magic) != NBD_REPLY_MAGIC)</a>
<a name="ln299">			goto err;</a>
<a name="ln300">		</a>
<a name="ln301">		reason = &quot;lock&quot;;</a>
<a name="ln302">		//LOCK</a>
<a name="ln303">		err = mutex_lock(&amp;dev-&gt;ben);</a>
<a name="ln304">		if (err)</a>
<a name="ln305">			goto err;</a>
<a name="ln306">		</a>
<a name="ln307">		reason = &quot;dequeue_request&quot;;</a>
<a name="ln308">		err = nbd_dequeue_request(dev, B_BENDIAN_TO_HOST_INT64(reply.handle), &amp;req);</a>
<a name="ln309">		</a>
<a name="ln310">		//UNLOCK</a>
<a name="ln311">		mutex_unlock(&amp;dev-&gt;ben);</a>
<a name="ln312">		</a>
<a name="ln313">		if (!err &amp;&amp; !req) {</a>
<a name="ln314">			dprintf(DP &quot;nbd_dequeue_rquest found NULL!\n&quot;);</a>
<a name="ln315">			err = ENOENT;</a>
<a name="ln316">		}</a>
<a name="ln317">		</a>
<a name="ln318">		if (err == B_OK) {</a>
<a name="ln319">			memcpy(&amp;req-&gt;reply, &amp;reply, sizeof(reply));</a>
<a name="ln320">			if (req-&gt;type == NBD_CMD_READ) {</a>
<a name="ln321">				err = 0;</a>
<a name="ln322">				reason = &quot;recv(data)&quot;;</a>
<a name="ln323">				if (reply.error == 0)</a>
<a name="ln324">					err = krecv(dev-&gt;sock, req-&gt;buffer, req-&gt;len, 0);</a>
<a name="ln325">				if (err &lt; 0)</a>
<a name="ln326">					goto err;</a>
<a name="ln327">				/* tell back how much we've got (?) */</a>
<a name="ln328">				req-&gt;len = err;</a>
<a name="ln329">			} else {</a>
<a name="ln330">				if (reply.error)</a>
<a name="ln331">					req-&gt;len = 0;</a>
<a name="ln332">			}</a>
<a name="ln333">			</a>
<a name="ln334">			reason = &quot;lock&quot;;</a>
<a name="ln335">			//LOCK</a>
<a name="ln336">			err = mutex_lock(&amp;dev-&gt;ben);</a>
<a name="ln337">			if (err)</a>
<a name="ln338">				goto err;</a>
<a name="ln339">			</a>
<a name="ln340">			// this also must be atomic!</a>
<a name="ln341">			release_sem(req-&gt;sem);</a>
<a name="ln342">			req-&gt;replied = true;</a>
<a name="ln343">			if (req-&gt;discard)</a>
<a name="ln344">				nbd_free_request(dev, req);</a>
<a name="ln345">			</a>
<a name="ln346">			//UNLOCK</a>
<a name="ln347">			mutex_unlock(&amp;dev-&gt;ben);</a>
<a name="ln348">		}</a>
<a name="ln349">		</a>
<a name="ln350">	}</a>
<a name="ln351">	</a>
<a name="ln352">	PRINT((DP &quot;&lt;%s\n&quot;, __FUNCTION__));</a>
<a name="ln353">	return 0;</a>
<a name="ln354"> </a>
<a name="ln355">err:</a>
<a name="ln356">	dprintf(DP &quot;%s: %s: error 0x%08&quot; B_PRIx32 &quot;\n&quot;, __FUNCTION__, reason, err);</a>
<a name="ln357">	return err;</a>
<a name="ln358">}</a>
<a name="ln359"> </a>
<a name="ln360"> </a>
<a name="ln361">status_t nbd_connect(struct nbd_device *dev)</a>
<a name="ln362">{</a>
<a name="ln363">	struct nbd_init_packet initpkt;</a>
<a name="ln364">	status_t err;</a>
<a name="ln365">	PRINT((DP &quot;&gt;%s()\n&quot;, __FUNCTION__));</a>
<a name="ln366"> </a>
<a name="ln367">	PRINT((DP &quot; %s: socket()\n&quot;, __FUNCTION__));</a>
<a name="ln368">	err = dev-&gt;sock = ksocket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</a>
<a name="ln369">	if (err == -1 &amp;&amp; errno &lt; 0)</a>
<a name="ln370">		err = errno;</a>
<a name="ln371">	if (err &lt; 0)</a>
<a name="ln372">		goto err0;</a>
<a name="ln373">	</a>
<a name="ln374">	PRINT((DP &quot; %s: connect()\n&quot;, __FUNCTION__));</a>
<a name="ln375">	err = kconnect(dev-&gt;sock, (struct sockaddr *)&amp;dev-&gt;server, sizeof(dev-&gt;server));</a>
<a name="ln376">	//err = ENOSYS;</a>
<a name="ln377">	if (err == -1 &amp;&amp; errno &lt; 0)</a>
<a name="ln378">		err = errno;</a>
<a name="ln379">	/* HACK: avoid the kernel unloading us with locked pages from TCP */</a>
<a name="ln380">	if (err)</a>
<a name="ln381">		gDelayUnload = true;</a>
<a name="ln382">	if (err)</a>
<a name="ln383">		goto err1;</a>
<a name="ln384">	</a>
<a name="ln385">	PRINT((DP &quot; %s: recv(initpkt)\n&quot;, __FUNCTION__));</a>
<a name="ln386">	err = krecv(dev-&gt;sock, &amp;initpkt, sizeof(initpkt), 0);</a>
<a name="ln387">	if (err == -1 &amp;&amp; errno &lt; 0)</a>
<a name="ln388">		err = errno;</a>
<a name="ln389">	if (err &lt; sizeof(initpkt))</a>
<a name="ln390">		goto err2;</a>
<a name="ln391">	err = EINVAL;//EPROTO;</a>
<a name="ln392">	if (memcmp(initpkt.passwd, NBD_INIT_PASSWD, sizeof(initpkt.passwd)))</a>
<a name="ln393">		goto err3;</a>
<a name="ln394">	if (B_BENDIAN_TO_HOST_INT64(initpkt.magic) != NBD_INIT_MAGIC)</a>
<a name="ln395">		goto err3;</a>
<a name="ln396">	</a>
<a name="ln397">	dev-&gt;size = B_BENDIAN_TO_HOST_INT64(initpkt.device_size);</a>
<a name="ln398">	</a>
<a name="ln399">	dprintf(DP &quot; %s: connected, device size %&quot; B_PRIu64 &quot; bytes.\n&quot;,</a>
<a name="ln400">		__FUNCTION__, dev-&gt;size);</a>
<a name="ln401"> </a>
<a name="ln402">	err = dev-&gt;postoffice = spawn_kernel_thread(nbd_postoffice, &quot;nbd postoffice&quot;, B_REAL_TIME_PRIORITY, dev);</a>
<a name="ln403">	if (err &lt; B_OK)</a>
<a name="ln404">		goto err4;</a>
<a name="ln405">	resume_thread(dev-&gt;postoffice);</a>
<a name="ln406">	</a>
<a name="ln407">	PRINT((DP &quot;&lt;%s\n&quot;, __FUNCTION__));</a>
<a name="ln408">	return B_OK;</a>
<a name="ln409">	</a>
<a name="ln410">err4:</a>
<a name="ln411">	dev-&gt;postoffice = -1;</a>
<a name="ln412">err3:</a>
<a name="ln413">err2:</a>
<a name="ln414">err1:</a>
<a name="ln415">	kclosesocket(dev-&gt;sock);</a>
<a name="ln416">	dev-&gt;sock = -1;</a>
<a name="ln417">err0:</a>
<a name="ln418">	dprintf(DP &quot;&lt;%s: error 0x%08&quot; B_PRIx32 &quot;\n&quot;, __FUNCTION__, err);</a>
<a name="ln419">	return err;</a>
<a name="ln420">}</a>
<a name="ln421"> </a>
<a name="ln422"> </a>
<a name="ln423">status_t nbd_teardown(struct nbd_device *dev)</a>
<a name="ln424">{</a>
<a name="ln425">	status_t ret;</a>
<a name="ln426">	PRINT((DP &quot;&gt;%s()\n&quot;, __FUNCTION__));</a>
<a name="ln427">	kshutdown(dev-&gt;sock, SHUT_RDWR);</a>
<a name="ln428">	kclosesocket(dev-&gt;sock);</a>
<a name="ln429">	dev-&gt;sock = -1;</a>
<a name="ln430">	wait_for_thread(dev-&gt;postoffice, &amp;ret);</a>
<a name="ln431">	return B_OK;</a>
<a name="ln432">}</a>
<a name="ln433"> </a>
<a name="ln434"> </a>
<a name="ln435">status_t nbd_post_request(struct nbd_device *dev, struct nbd_request_entry *req)</a>
<a name="ln436">{</a>
<a name="ln437">	status_t err;</a>
<a name="ln438">	PRINT((DP &quot;&gt;%s(handle:%&quot; B_PRIu64 &quot;)\n&quot;, __FUNCTION__, req-&gt;handle));</a>
<a name="ln439">	</a>
<a name="ln440">	err = ksend(dev-&gt;sock, &amp;req-&gt;req, sizeof(req-&gt;req), 0);</a>
<a name="ln441">	if (err &lt; 0)</a>
<a name="ln442">		return err;</a>
<a name="ln443"> </a>
<a name="ln444">	if (req-&gt;type == NBD_CMD_WRITE)</a>
<a name="ln445">		err = ksend(dev-&gt;sock, req-&gt;buffer, req-&gt;len, 0);</a>
<a name="ln446">	if (err &lt; 0)</a>
<a name="ln447">		return err;</a>
<a name="ln448">	else</a>
<a name="ln449">		req-&gt;len = err;</a>
<a name="ln450">	</a>
<a name="ln451">	err = nbd_queue_request(dev, req);</a>
<a name="ln452">	return err;</a>
<a name="ln453">}</a>
<a name="ln454"> </a>
<a name="ln455"> </a>
<a name="ln456">#if 0</a>
<a name="ln457">#pragma mark ==== device hooks ====</a>
<a name="ln458">#endif</a>
<a name="ln459"> </a>
<a name="ln460">static struct nbd_device nbd_devices[MAX_NBDS];</a>
<a name="ln461"> </a>
<a name="ln462">status_t nbd_open(const char *name, uint32 flags, cookie_t **cookie) {</a>
<a name="ln463">	status_t err;</a>
<a name="ln464">#ifdef MOUNT_KLUDGE</a>
<a name="ln465">	int32 refcnt;</a>
<a name="ln466">	int kfd;</a>
<a name="ln467">#endif</a>
<a name="ln468">	struct nbd_device *dev = NULL;</a>
<a name="ln469">	PRINT((DP &quot;&gt;%s(%s, %&quot; B_PRIx32 &quot;, )\n&quot;, __FUNCTION__, name, flags));</a>
<a name="ln470">	(void)name; (void)flags;</a>
<a name="ln471">	dev = nbd_find_device(name);</a>
<a name="ln472">	if (!dev || !dev-&gt;valid)</a>
<a name="ln473">		return ENOENT;</a>
<a name="ln474">	err = ENOMEM;</a>
<a name="ln475">	*cookie = (void*)malloc(sizeof(cookie_t));</a>
<a name="ln476">	if (*cookie == NULL)</a>
<a name="ln477">		goto err0;</a>
<a name="ln478">	memset(*cookie, 0, sizeof(cookie_t));</a>
<a name="ln479">	(*cookie)-&gt;dev = dev;</a>
<a name="ln480">	err = mutex_lock(&amp;dev-&gt;ben);</a>
<a name="ln481">	if (err)</a>
<a name="ln482">		goto err1;</a>
<a name="ln483">	/*  */</a>
<a name="ln484">	if (dev-&gt;sock &lt; 0)</a>
<a name="ln485">		err = nbd_connect(dev);</a>
<a name="ln486">	if (err)</a>
<a name="ln487">		goto err2;</a>
<a name="ln488">#ifdef MOUNT_KLUDGE</a>
<a name="ln489">	refcnt = dev-&gt;refcnt++;</a>
<a name="ln490">	kfd = dev-&gt;kludge;</a>
<a name="ln491">	dev-&gt;kludge = -1;</a>
<a name="ln492">#endif</a>
<a name="ln493">	mutex_unlock(&amp;dev-&gt;ben);</a>
<a name="ln494">	</a>
<a name="ln495">#ifdef MOUNT_KLUDGE</a>
<a name="ln496">	if (refcnt == 0) {</a>
<a name="ln497">		char buf[32];</a>
<a name="ln498">		sprintf(buf, &quot;/dev/%s&quot;, name);</a>
<a name="ln499">		dev-&gt;kludge = open(buf, O_RDONLY);</a>
<a name="ln500">	} else if (kfd) {</a>
<a name="ln501">		close(kfd);</a>
<a name="ln502">	}</a>
<a name="ln503">#endif</a>
<a name="ln504">	</a>
<a name="ln505">	return B_OK;</a>
<a name="ln506">	</a>
<a name="ln507">err2:</a>
<a name="ln508">	mutex_unlock(&amp;dev-&gt;ben);</a>
<a name="ln509">err1:</a>
<a name="ln510">	free(*cookie);</a>
<a name="ln511">err0:</a>
<a name="ln512">	dprintf(DP &quot; %s: error 0x%08&quot; B_PRIx32 &quot;\n&quot;, __FUNCTION__, err);</a>
<a name="ln513">	return err;</a>
<a name="ln514">}</a>
<a name="ln515"> </a>
<a name="ln516"> </a>
<a name="ln517">status_t nbd_close(cookie_t *cookie) {</a>
<a name="ln518">	struct nbd_device *dev = cookie-&gt;dev;</a>
<a name="ln519">	status_t err;</a>
<a name="ln520">#ifdef MOUNT_KLUDGE</a>
<a name="ln521">	int kfd = -1;</a>
<a name="ln522">#endif</a>
<a name="ln523">	PRINT((DP &quot;&gt;%s(%d)\n&quot;, __FUNCTION__, WHICH(cookie-&gt;dev)));</a>
<a name="ln524">	</a>
<a name="ln525">	err = mutex_lock(&amp;dev-&gt;ben);</a>
<a name="ln526">	if (err)</a>
<a name="ln527">		return err;</a>
<a name="ln528">	</a>
<a name="ln529">	// XXX: do something ?</a>
<a name="ln530">#ifdef MOUNT_KLUDGE</a>
<a name="ln531">	kfd = dev-&gt;kludge;</a>
<a name="ln532">	dev-&gt;kludge = -1;</a>
<a name="ln533">#endif</a>
<a name="ln534">	</a>
<a name="ln535">	mutex_unlock(&amp;dev-&gt;ben);</a>
<a name="ln536"> </a>
<a name="ln537">#ifdef MOUNT_KLUDGE</a>
<a name="ln538">	if (kfd &gt; -1) {</a>
<a name="ln539">		close(kfd);</a>
<a name="ln540">	}</a>
<a name="ln541">#endif</a>
<a name="ln542">	return B_OK;</a>
<a name="ln543">}</a>
<a name="ln544"> </a>
<a name="ln545"> </a>
<a name="ln546">status_t nbd_free(cookie_t *cookie) {</a>
<a name="ln547">	struct nbd_device *dev = cookie-&gt;dev;</a>
<a name="ln548">	status_t err;</a>
<a name="ln549">	PRINT((DP &quot;&gt;%s(%d)\n&quot;, __FUNCTION__, WHICH(cookie-&gt;dev)));</a>
<a name="ln550">	</a>
<a name="ln551">	err = mutex_lock(&amp;dev-&gt;ben);</a>
<a name="ln552">	if (err)</a>
<a name="ln553">		return err;</a>
<a name="ln554">	</a>
<a name="ln555">	if (--dev-&gt;refcnt == 0) {</a>
<a name="ln556">		err = nbd_teardown(dev);</a>
<a name="ln557">	}</a>
<a name="ln558">	</a>
<a name="ln559">	mutex_unlock(&amp;dev-&gt;ben);</a>
<a name="ln560">	</a>
<a name="ln561">	free(cookie);</a>
<a name="ln562">	return err;</a>
<a name="ln563">}</a>
<a name="ln564"> </a>
<a name="ln565"> </a>
<a name="ln566">status_t nbd_control(cookie_t *cookie, uint32 op, void *data, size_t len) {</a>
<a name="ln567">	PRINT((DP &quot;&gt;%s(%d, %&quot; B_PRIu32 &quot;, , %ld)\n&quot;, __FUNCTION__,</a>
<a name="ln568">		WHICH(cookie-&gt;dev), op, len));</a>
<a name="ln569">	switch (op) {</a>
<a name="ln570">	case B_GET_DEVICE_SIZE: /* this one is broken anyway... */</a>
<a name="ln571">		if (data) {</a>
<a name="ln572">			*(size_t *)data = (size_t)cookie-&gt;dev-&gt;size;</a>
<a name="ln573">			return B_OK;</a>
<a name="ln574">		}</a>
<a name="ln575">		return EINVAL;</a>
<a name="ln576">	case B_SET_DEVICE_SIZE: /* broken */</a>
<a name="ln577">		return EINVAL;</a>
<a name="ln578">	case B_SET_NONBLOCKING_IO:</a>
<a name="ln579">		return EINVAL;</a>
<a name="ln580">	case B_SET_BLOCKING_IO:</a>
<a name="ln581">		return B_OK;</a>
<a name="ln582">	case B_GET_READ_STATUS:</a>
<a name="ln583">	case B_GET_WRITE_STATUS:</a>
<a name="ln584">		if (data) {</a>
<a name="ln585">			*(bool *)data = false;</a>
<a name="ln586">			return B_OK;</a>
<a name="ln587">		}</a>
<a name="ln588">		return EINVAL;</a>
<a name="ln589">	case B_GET_GEOMETRY:</a>
<a name="ln590">	case B_GET_BIOS_GEOMETRY:</a>
<a name="ln591">		if (data) {</a>
<a name="ln592">			device_geometry *geom = (device_geometry *)data;</a>
<a name="ln593">			geom-&gt;bytes_per_sector = BLKSIZE;</a>
<a name="ln594">			geom-&gt;sectors_per_track = 1;</a>
<a name="ln595">			geom-&gt;cylinder_count = cookie-&gt;dev-&gt;size / BLKSIZE;</a>
<a name="ln596">			geom-&gt;head_count = 1;</a>
<a name="ln597">			geom-&gt;device_type = B_DISK;</a>
<a name="ln598">			geom-&gt;removable = false;</a>
<a name="ln599">			geom-&gt;read_only = cookie-&gt;dev-&gt;readonly;</a>
<a name="ln600">			geom-&gt;write_once = false;</a>
<a name="ln601">			return B_OK;</a>
<a name="ln602">		}</a>
<a name="ln603">		return EINVAL;</a>
<a name="ln604">	case B_GET_MEDIA_STATUS:</a>
<a name="ln605">		if (data) {</a>
<a name="ln606">			*(status_t *)data = B_OK;</a>
<a name="ln607">			return B_OK;</a>
<a name="ln608">		}</a>
<a name="ln609">		return EINVAL;</a>
<a name="ln610">		</a>
<a name="ln611">	case B_EJECT_DEVICE:</a>
<a name="ln612">	case B_LOAD_MEDIA:</a>
<a name="ln613">		return B_BAD_VALUE;</a>
<a name="ln614">	case B_FLUSH_DRIVE_CACHE: /* wait for request list to be empty ? */</a>
<a name="ln615">		return B_OK;</a>
<a name="ln616">	default:</a>
<a name="ln617">		return B_BAD_VALUE;</a>
<a name="ln618">	}</a>
<a name="ln619">	return B_NOT_ALLOWED;</a>
<a name="ln620">}</a>
<a name="ln621"> </a>
<a name="ln622"> </a>
<a name="ln623">status_t nbd_read(cookie_t *cookie, off_t position, void *data, size_t *numbytes) {</a>
<a name="ln624">	struct nbd_device *dev = cookie-&gt;dev;</a>
<a name="ln625">	struct nbd_request_entry *req;</a>
<a name="ln626">	status_t err, semerr;</a>
<a name="ln627">	PRINT((DP &quot;&gt;%s(%d, %&quot; B_PRIdOFF &quot;, , )\n&quot;, __FUNCTION__,</a>
<a name="ln628">		WHICH(cookie-&gt;dev), position));</a>
<a name="ln629">	</a>
<a name="ln630">	if (position &lt; 0)</a>
<a name="ln631">		return EINVAL;</a>
<a name="ln632">	if (!data)</a>
<a name="ln633">		return EINVAL;</a>
<a name="ln634">	</a>
<a name="ln635">	err = nbd_alloc_request(dev, &amp;req, NBD_CMD_READ, position, *numbytes, NULL);</a>
<a name="ln636">	if (err)</a>
<a name="ln637">		goto err0;</a>
<a name="ln638">	</a>
<a name="ln639">	//LOCK</a>
<a name="ln640">	err = mutex_lock(&amp;dev-&gt;ben);</a>
<a name="ln641">	if (err)</a>
<a name="ln642">		goto err1;</a>
<a name="ln643">	</a>
<a name="ln644">	err = nbd_post_request(dev, req);</a>
<a name="ln645">	</a>
<a name="ln646">	//UNLOCK</a>
<a name="ln647">	mutex_unlock(&amp;dev-&gt;ben);</a>
<a name="ln648"> </a>
<a name="ln649">	if (err)</a>
<a name="ln650">		goto err2;</a>
<a name="ln651"> </a>
<a name="ln652"> </a>
<a name="ln653">	semerr = acquire_sem(req-&gt;sem);</a>
<a name="ln654">	</a>
<a name="ln655">	//LOCK</a>
<a name="ln656">	err = mutex_lock(&amp;dev-&gt;ben);</a>
<a name="ln657">	if(err)</a>
<a name="ln658">		goto err3;</a>
<a name="ln659">	</a>
<a name="ln660">	/* bad scenarii */</a>
<a name="ln661">	if (!req-&gt;replied)</a>
<a name="ln662">		req-&gt;discard = true;</a>
<a name="ln663">	else if (semerr)</a>
<a name="ln664">		nbd_free_request(dev, req);</a>
<a name="ln665">	</a>
<a name="ln666">	//UNLOCK</a>
<a name="ln667">	mutex_unlock(&amp;dev-&gt;ben);</a>
<a name="ln668"> </a>
<a name="ln669">	if (semerr == B_OK) {</a>
<a name="ln670">		*numbytes = req-&gt;len;</a>
<a name="ln671">		memcpy(data, req-&gt;buffer, req-&gt;len);</a>
<a name="ln672">		err = B_OK;</a>
<a name="ln673">		if (*numbytes == 0 &amp;&amp; req-&gt;reply.error)</a>
<a name="ln674">			err = EIO;</a>
<a name="ln675">		nbd_free_request(dev, req);</a>
<a name="ln676">		return err;</a>
<a name="ln677">	}</a>
<a name="ln678">	</a>
<a name="ln679">	*numbytes = 0;</a>
<a name="ln680">	return semerr;</a>
<a name="ln681">			</a>
<a name="ln682"> </a>
<a name="ln683">err3:</a>
<a name="ln684">err2:</a>
<a name="ln685">err1:</a>
<a name="ln686">	nbd_free_request(dev, req);</a>
<a name="ln687">err0:</a>
<a name="ln688">	*numbytes = 0;</a>
<a name="ln689">	return err;</a>
<a name="ln690">}</a>
<a name="ln691"> </a>
<a name="ln692"> </a>
<a name="ln693">status_t nbd_write(cookie_t *cookie, off_t position, const void *data, size_t *numbytes) {</a>
<a name="ln694">	struct nbd_device *dev = cookie-&gt;dev;</a>
<a name="ln695">	struct nbd_request_entry *req;</a>
<a name="ln696">	status_t err, semerr;</a>
<a name="ln697">	PRINT((DP &quot;&gt;%s(%d, %&quot; B_PRIdOFF &quot;, %ld, )\n&quot;, __FUNCTION__,</a>
<a name="ln698">		WHICH(cookie-&gt;dev), position, *numbytes));</a>
<a name="ln699">	</a>
<a name="ln700">	if (position &lt; 0)</a>
<a name="ln701">		return EINVAL;</a>
<a name="ln702">	if (!data)</a>
<a name="ln703">		return EINVAL;</a>
<a name="ln704">	err = B_NOT_ALLOWED;</a>
<a name="ln705">	if (dev-&gt;readonly)</a>
<a name="ln706">		goto err0;</a>
<a name="ln707">	</a>
<a name="ln708">	err = nbd_alloc_request(dev, &amp;req, NBD_CMD_WRITE, position, *numbytes, data);</a>
<a name="ln709">	if (err)</a>
<a name="ln710">		goto err0;</a>
<a name="ln711">	</a>
<a name="ln712">	//LOCK</a>
<a name="ln713">	err = mutex_lock(&amp;dev-&gt;ben);</a>
<a name="ln714">	if (err)</a>
<a name="ln715">		goto err1;</a>
<a name="ln716">	</a>
<a name="ln717">	/* sending request+data must be atomic */</a>
<a name="ln718">	err = nbd_post_request(dev, req);</a>
<a name="ln719">	</a>
<a name="ln720">	//UNLOCK</a>
<a name="ln721">	mutex_unlock(&amp;dev-&gt;ben);</a>
<a name="ln722"> </a>
<a name="ln723">	if (err)</a>
<a name="ln724">		goto err2;</a>
<a name="ln725"> </a>
<a name="ln726"> </a>
<a name="ln727">	semerr = acquire_sem(req-&gt;sem);</a>
<a name="ln728">	</a>
<a name="ln729">	//LOCK</a>
<a name="ln730">	err = mutex_lock(&amp;dev-&gt;ben);</a>
<a name="ln731">	if(err)</a>
<a name="ln732">		goto err3;</a>
<a name="ln733">	</a>
<a name="ln734">	/* bad scenarii */</a>
<a name="ln735">	if (!req-&gt;replied)</a>
<a name="ln736">		req-&gt;discard = true;</a>
<a name="ln737">	else if (semerr)</a>
<a name="ln738">		nbd_free_request(dev, req);</a>
<a name="ln739">	</a>
<a name="ln740">	//UNLOCK</a>
<a name="ln741">	mutex_unlock(&amp;dev-&gt;ben);</a>
<a name="ln742"> </a>
<a name="ln743">	if (semerr == B_OK) {</a>
<a name="ln744">		*numbytes = req-&gt;len;</a>
<a name="ln745">		err = B_OK;</a>
<a name="ln746">		if (*numbytes == 0 &amp;&amp; req-&gt;reply.error)</a>
<a name="ln747">			err = EIO;</a>
<a name="ln748">		nbd_free_request(dev, req);</a>
<a name="ln749">		return err;</a>
<a name="ln750">	}</a>
<a name="ln751">	</a>
<a name="ln752">	*numbytes = 0;</a>
<a name="ln753">	return semerr;</a>
<a name="ln754">			</a>
<a name="ln755"> </a>
<a name="ln756">err3:</a>
<a name="ln757">err2:</a>
<a name="ln758">err1:</a>
<a name="ln759">	nbd_free_request(dev, req);</a>
<a name="ln760">err0:</a>
<a name="ln761">	*numbytes = 0;</a>
<a name="ln762">	return err;</a>
<a name="ln763">}</a>
<a name="ln764"> </a>
<a name="ln765"> </a>
<a name="ln766">device_hooks nbd_hooks={</a>
<a name="ln767">	(device_open_hook)nbd_open,</a>
<a name="ln768">	(device_close_hook)nbd_close,</a>
<a name="ln769">	(device_free_hook)nbd_free,</a>
<a name="ln770">	(device_control_hook)nbd_control,</a>
<a name="ln771">	(device_read_hook)nbd_read,</a>
<a name="ln772">	(device_write_hook)nbd_write,</a>
<a name="ln773">	NULL,</a>
<a name="ln774">	NULL,</a>
<a name="ln775">	NULL,</a>
<a name="ln776">	NULL</a>
<a name="ln777">};</a>
<a name="ln778"> </a>
<a name="ln779">#if 0</a>
<a name="ln780">#pragma mark ==== driver hooks ====</a>
<a name="ln781">#endif</a>
<a name="ln782"> </a>
<a name="ln783">int32 api_version = B_CUR_DRIVER_API_VERSION;</a>
<a name="ln784"> </a>
<a name="ln785">static char *nbd_name[MAX_NBDS+1] = {</a>
<a name="ln786">	NULL</a>
<a name="ln787">};</a>
<a name="ln788"> </a>
<a name="ln789"> </a>
<a name="ln790">status_t</a>
<a name="ln791">init_hardware (void)</a>
<a name="ln792">{</a>
<a name="ln793">	PRINT((DP &quot;&gt;%s()\n&quot;, __FUNCTION__));</a>
<a name="ln794">	return B_OK;</a>
<a name="ln795">}</a>
<a name="ln796"> </a>
<a name="ln797"> </a>
<a name="ln798">status_t</a>
<a name="ln799">init_driver (void)</a>
<a name="ln800">{</a>
<a name="ln801">	status_t err;</a>
<a name="ln802">	int i, j;</a>
<a name="ln803">	// XXX: load settings</a>
<a name="ln804">	void *handle;</a>
<a name="ln805">	char **names = nbd_name;</a>
<a name="ln806">	PRINT((DP &quot;&gt;%s()\n&quot;, __FUNCTION__));</a>
<a name="ln807"> </a>
<a name="ln808">	handle = load_driver_settings(DRV);</a>
<a name="ln809">	if (handle == NULL)</a>
<a name="ln810">		return ENOENT;</a>
<a name="ln811">	// XXX: test for boot args ?</a>
<a name="ln812">	</a>
<a name="ln813">	</a>
<a name="ln814">	err = ksocket_init();</a>
<a name="ln815">	if (err &lt; B_OK)</a>
<a name="ln816">		return err;</a>
<a name="ln817">	</a>
<a name="ln818">	for (i = 0; i &lt; MAX_NBDS; i++) {</a>
<a name="ln819">		nbd_devices[i].valid = false;</a>
<a name="ln820">		nbd_devices[i].readonly = false;</a>
<a name="ln821">		mutex_init(&amp;nbd_devices[i].ben, &quot;nbd lock&quot;);</a>
<a name="ln822">		nbd_devices[i].refcnt = 0;</a>
<a name="ln823">		nbd_devices[i].req = 0LL; /* next ID for requests */</a>
<a name="ln824">		nbd_devices[i].sock = -1;</a>
<a name="ln825">		nbd_devices[i].postoffice = -1;</a>
<a name="ln826">		nbd_devices[i].size = 0LL;</a>
<a name="ln827">		nbd_devices[i].reqs = NULL;</a>
<a name="ln828">#ifdef MOUNT_KLUDGE</a>
<a name="ln829">		nbd_devices[i].kludge = -1;</a>
<a name="ln830">#endif</a>
<a name="ln831">		nbd_name[i] = NULL;</a>
<a name="ln832">	}</a>
<a name="ln833">	</a>
<a name="ln834">	for (i = 0; i &lt; MAX_NBDS; i++) {</a>
<a name="ln835">		const driver_settings *settings = get_driver_settings(handle);</a>
<a name="ln836">		driver_parameter *p = NULL;</a>
<a name="ln837">		char keyname[10];</a>
<a name="ln838">		sprintf(keyname, &quot;%d&quot;, i);</a>
<a name="ln839">		for (j = 0; j &lt; settings-&gt;parameter_count; j++)</a>
<a name="ln840">			if (!strcmp(settings-&gt;parameters[j].name, keyname))</a>
<a name="ln841">				p = &amp;settings-&gt;parameters[j];</a>
<a name="ln842">		if (!p)</a>
<a name="ln843">			continue;</a>
<a name="ln844">		for (j = 0; j &lt; p-&gt;parameter_count; j++) {</a>
<a name="ln845">			if (!strcmp(p-&gt;parameters[j].name, &quot;readonly&quot;))</a>
<a name="ln846">				nbd_devices[i].readonly = true;</a>
<a name="ln847">			if (!strcmp(p-&gt;parameters[j].name, &quot;server&quot;)) {</a>
<a name="ln848">				if (p-&gt;parameters[j].value_count &lt; 2)</a>
<a name="ln849">					continue;</a>
<a name="ln850">				nbd_devices[i].server.sin_len = sizeof(struct sockaddr_in);</a>
<a name="ln851">				nbd_devices[i].server.sin_family = AF_INET;</a>
<a name="ln852">				kinet_aton(p-&gt;parameters[j].values[0], &amp;nbd_devices[i].server.sin_addr);</a>
<a name="ln853">				nbd_devices[i].server.sin_port = htons(atoi(p-&gt;parameters[j].values[1]));</a>
<a name="ln854">				dprintf(DP &quot; configured [%d]\n&quot;, i);</a>
<a name="ln855">				*(names) = malloc(DEVICE_NAME_MAX);</a>
<a name="ln856">				if (*(names) == NULL)</a>
<a name="ln857">					return ENOMEM;</a>
<a name="ln858">				sprintf(*(names++), DEVICE_FMT, i);</a>
<a name="ln859">				nbd_devices[i].valid = true;</a>
<a name="ln860">			}</a>
<a name="ln861">		}</a>
<a name="ln862">	}</a>
<a name="ln863">	*names = NULL;</a>
<a name="ln864">		</a>
<a name="ln865">	unload_driver_settings(handle);</a>
<a name="ln866">	return B_OK;</a>
<a name="ln867">}</a>
<a name="ln868"> </a>
<a name="ln869"> </a>
<a name="ln870">void</a>
<a name="ln871">uninit_driver (void)</a>
<a name="ln872">{</a>
<a name="ln873">	int i;</a>
<a name="ln874">	PRINT((DP &quot;&gt;%s()\n&quot;, __FUNCTION__));</a>
<a name="ln875">	for (i = 0; i &lt; MAX_NBDS; i++) {</a>
<a name="ln876">		free(nbd_name[i]);</a>
<a name="ln877">		mutex_destroy(&amp;nbd_devices[i].ben);</a>
<a name="ln878">	}</a>
<a name="ln879">	ksocket_cleanup();</a>
<a name="ln880">	/* HACK */</a>
<a name="ln881">	if (gDelayUnload)</a>
<a name="ln882">		snooze(BONE_TEARDOWN_DELAY);</a>
<a name="ln883">}</a>
<a name="ln884"> </a>
<a name="ln885"> </a>
<a name="ln886">const char**</a>
<a name="ln887">publish_devices()</a>
<a name="ln888">{</a>
<a name="ln889">	PRINT((DP &quot;&gt;%s()\n&quot;, __FUNCTION__));</a>
<a name="ln890">	return (const char **)nbd_name;</a>
<a name="ln891">}</a>
<a name="ln892"> </a>
<a name="ln893"> </a>
<a name="ln894">device_hooks*</a>
<a name="ln895">find_device(const char* name)</a>
<a name="ln896">{</a>
<a name="ln897">	PRINT((DP &quot;&gt;%s(%s)\n&quot;, __FUNCTION__, name));</a>
<a name="ln898">	return &amp;nbd_hooks;</a>
<a name="ln899">}</a>
<a name="ln900"> </a>
<a name="ln901"> </a>
<a name="ln902">struct nbd_device*</a>
<a name="ln903">nbd_find_device(const char* name)</a>
<a name="ln904">{</a>
<a name="ln905">	int i;</a>
<a name="ln906">	PRINT((DP &quot;&gt;%s(%s)\n&quot;, __FUNCTION__, name));</a>
<a name="ln907">	for (i = 0; i &lt; MAX_NBDS; i++) {</a>
<a name="ln908">		char buf[DEVICE_NAME_MAX];</a>
<a name="ln909">		sprintf(buf, DEVICE_FMT, i);</a>
<a name="ln910">		if (!strcmp(buf, name))</a>
<a name="ln911">			return &amp;nbd_devices[i];</a>
<a name="ln912">	}</a>
<a name="ln913">	return NULL;</a>
<a name="ln914">}</a>
<a name="ln915"> </a>

</code></pre>
<div class="balloon" rel="815"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'err < ((int) 0)' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
