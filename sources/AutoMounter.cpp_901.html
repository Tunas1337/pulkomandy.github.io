
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>AutoMounter.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2007-2018, Haiku, Inc. All rights reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Stephan Aßmus, superstippi@gmx.de</a>
<a name="ln7"> *		Axel Dörfler, axeld@pinc-software.de</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10"> </a>
<a name="ln11">#include &quot;AutoMounter.h&quot;</a>
<a name="ln12"> </a>
<a name="ln13">#include &lt;new&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &lt;string.h&gt;</a>
<a name="ln16">#include &lt;unistd.h&gt;</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;Alert.h&gt;</a>
<a name="ln19">#include &lt;AutoLocker.h&gt;</a>
<a name="ln20">#include &lt;Catalog.h&gt;</a>
<a name="ln21">#include &lt;Debug.h&gt;</a>
<a name="ln22">#include &lt;Directory.h&gt;</a>
<a name="ln23">#include &lt;DiskDevice.h&gt;</a>
<a name="ln24">#include &lt;DiskDeviceRoster.h&gt;</a>
<a name="ln25">#include &lt;DiskDeviceList.h&gt;</a>
<a name="ln26">#include &lt;DiskDeviceTypes.h&gt;</a>
<a name="ln27">#include &lt;DiskSystem.h&gt;</a>
<a name="ln28">#include &lt;FindDirectory.h&gt;</a>
<a name="ln29">#include &lt;fs_info.h&gt;</a>
<a name="ln30">#include &lt;fs_volume.h&gt;</a>
<a name="ln31">#include &lt;LaunchRoster.h&gt;</a>
<a name="ln32">#include &lt;Locale.h&gt;</a>
<a name="ln33">#include &lt;Message.h&gt;</a>
<a name="ln34">#include &lt;Node.h&gt;</a>
<a name="ln35">#include &lt;NodeMonitor.h&gt;</a>
<a name="ln36">#include &lt;Path.h&gt;</a>
<a name="ln37">#include &lt;PropertyInfo.h&gt;</a>
<a name="ln38">#include &lt;String.h&gt;</a>
<a name="ln39">#include &lt;VolumeRoster.h&gt;</a>
<a name="ln40"> </a>
<a name="ln41">#include &quot;MountServer.h&quot;</a>
<a name="ln42"> </a>
<a name="ln43">#include &quot;Utilities.h&quot;</a>
<a name="ln44"> </a>
<a name="ln45"> </a>
<a name="ln46">#undef B_TRANSLATION_CONTEXT</a>
<a name="ln47">#define B_TRANSLATION_CONTEXT &quot;AutoMounter&quot;</a>
<a name="ln48"> </a>
<a name="ln49"> </a>
<a name="ln50">static const char* kMountServerSettings = &quot;mount_server&quot;;</a>
<a name="ln51">static const char* kMountFlagsKeyExtension = &quot; mount flags&quot;;</a>
<a name="ln52"> </a>
<a name="ln53">static const char* kInitialMountEvent = &quot;initial_volumes_mounted&quot;;</a>
<a name="ln54"> </a>
<a name="ln55"> </a>
<a name="ln56">class MountVisitor : public BDiskDeviceVisitor {</a>
<a name="ln57">public:</a>
<a name="ln58">								MountVisitor(mount_mode normalMode,</a>
<a name="ln59">									mount_mode removableMode,</a>
<a name="ln60">									bool initialRescan, BMessage&amp; previous,</a>
<a name="ln61">									partition_id deviceID);</a>
<a name="ln62">	virtual						~MountVisitor()</a>
<a name="ln63">									{}</a>
<a name="ln64"> </a>
<a name="ln65">	virtual	bool				Visit(BDiskDevice* device);</a>
<a name="ln66">	virtual	bool				Visit(BPartition* partition, int32 level);</a>
<a name="ln67"> </a>
<a name="ln68">private:</a>
<a name="ln69">			bool				_WasPreviouslyMounted(const BPath&amp; path,</a>
<a name="ln70">									const BPartition* partition);</a>
<a name="ln71"> </a>
<a name="ln72">private:</a>
<a name="ln73">			mount_mode			fNormalMode;</a>
<a name="ln74">			mount_mode			fRemovableMode;</a>
<a name="ln75">			bool				fInitialRescan;</a>
<a name="ln76">			BMessage&amp;			fPrevious;</a>
<a name="ln77">			partition_id		fOnlyOnDeviceID;</a>
<a name="ln78">};</a>
<a name="ln79"> </a>
<a name="ln80"> </a>
<a name="ln81">class MountArchivedVisitor : public BDiskDeviceVisitor {</a>
<a name="ln82">public:</a>
<a name="ln83">								MountArchivedVisitor(</a>
<a name="ln84">									const BDiskDeviceList&amp; devices,</a>
<a name="ln85">									const BMessage&amp; archived);</a>
<a name="ln86">	virtual						~MountArchivedVisitor();</a>
<a name="ln87"> </a>
<a name="ln88">	virtual	bool				Visit(BDiskDevice* device);</a>
<a name="ln89">	virtual	bool				Visit(BPartition* partition, int32 level);</a>
<a name="ln90"> </a>
<a name="ln91">private:</a>
<a name="ln92">			int					_Score(BPartition* partition);</a>
<a name="ln93"> </a>
<a name="ln94">private:</a>
<a name="ln95">			const BDiskDeviceList&amp; fDevices;</a>
<a name="ln96">			const BMessage&amp;		fArchived;</a>
<a name="ln97">			int					fBestScore;</a>
<a name="ln98">			partition_id		fBestID;</a>
<a name="ln99">};</a>
<a name="ln100"> </a>
<a name="ln101"> </a>
<a name="ln102">static bool</a>
<a name="ln103">BootedInSafeMode()</a>
<a name="ln104">{</a>
<a name="ln105">	const char* safeMode = getenv(&quot;SAFEMODE&quot;);</a>
<a name="ln106">	return safeMode != NULL &amp;&amp; strcmp(safeMode, &quot;yes&quot;) == 0;</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109"> </a>
<a name="ln110">class ArchiveVisitor : public BDiskDeviceVisitor {</a>
<a name="ln111">public:</a>
<a name="ln112">								ArchiveVisitor(BMessage&amp; message);</a>
<a name="ln113">	virtual						~ArchiveVisitor();</a>
<a name="ln114"> </a>
<a name="ln115">	virtual	bool				Visit(BDiskDevice* device);</a>
<a name="ln116">	virtual	bool				Visit(BPartition* partition, int32 level);</a>
<a name="ln117"> </a>
<a name="ln118">private:</a>
<a name="ln119">			BMessage&amp;			fMessage;</a>
<a name="ln120">};</a>
<a name="ln121"> </a>
<a name="ln122"> </a>
<a name="ln123">// #pragma mark - MountVisitor</a>
<a name="ln124"> </a>
<a name="ln125"> </a>
<a name="ln126">MountVisitor::MountVisitor(mount_mode normalMode, mount_mode removableMode,</a>
<a name="ln127">		bool initialRescan, BMessage&amp; previous, partition_id deviceID)</a>
<a name="ln128">	:</a>
<a name="ln129">	fNormalMode(normalMode),</a>
<a name="ln130">	fRemovableMode(removableMode),</a>
<a name="ln131">	fInitialRescan(initialRescan),</a>
<a name="ln132">	fPrevious(previous),</a>
<a name="ln133">	fOnlyOnDeviceID(deviceID)</a>
<a name="ln134">{</a>
<a name="ln135">}</a>
<a name="ln136"> </a>
<a name="ln137"> </a>
<a name="ln138">bool</a>
<a name="ln139">MountVisitor::Visit(BDiskDevice* device)</a>
<a name="ln140">{</a>
<a name="ln141">	return Visit(device, 0);</a>
<a name="ln142">}</a>
<a name="ln143"> </a>
<a name="ln144"> </a>
<a name="ln145">bool</a>
<a name="ln146">MountVisitor::Visit(BPartition* partition, int32 level)</a>
<a name="ln147">{</a>
<a name="ln148">	if (fOnlyOnDeviceID &gt;= 0) {</a>
<a name="ln149">		// only mount partitions on the given device id</a>
<a name="ln150">		// or if the partition ID is already matched</a>
<a name="ln151">		BPartition* device = partition;</a>
<a name="ln152">		while (device-&gt;Parent() != NULL) {</a>
<a name="ln153">			if (device-&gt;ID() == fOnlyOnDeviceID) {</a>
<a name="ln154">				// we are happy</a>
<a name="ln155">				break;</a>
<a name="ln156">			}</a>
<a name="ln157">			device = device-&gt;Parent();</a>
<a name="ln158">		}</a>
<a name="ln159">		if (device-&gt;ID() != fOnlyOnDeviceID)</a>
<a name="ln160">			return false;</a>
<a name="ln161">	}</a>
<a name="ln162"> </a>
<a name="ln163">	mount_mode mode = !fInitialRescan &amp;&amp; partition-&gt;Device()-&gt;IsRemovableMedia()</a>
<a name="ln164">		? fRemovableMode : fNormalMode;</a>
<a name="ln165">	if (mode == kNoVolumes || partition-&gt;IsMounted()</a>
<a name="ln166">		|| !partition-&gt;ContainsFileSystem()) {</a>
<a name="ln167">		return false;</a>
<a name="ln168">	}</a>
<a name="ln169"> </a>
<a name="ln170">	BPath path;</a>
<a name="ln171">	if (partition-&gt;GetPath(&amp;path) != B_OK)</a>
<a name="ln172">		return false;</a>
<a name="ln173"> </a>
<a name="ln174">	if (mode == kRestorePreviousVolumes) {</a>
<a name="ln175">		// mount all volumes that were stored in the settings file</a>
<a name="ln176">		if (!_WasPreviouslyMounted(path, partition))</a>
<a name="ln177">			return false;</a>
<a name="ln178">	} else if (mode == kOnlyBFSVolumes) {</a>
<a name="ln179">		if (partition-&gt;ContentType() == NULL</a>
<a name="ln180">			|| strcmp(partition-&gt;ContentType(), kPartitionTypeBFS))</a>
<a name="ln181">			return false;</a>
<a name="ln182">	}</a>
<a name="ln183"> </a>
<a name="ln184">	uint32 mountFlags;</a>
<a name="ln185">	if (!fInitialRescan) {</a>
<a name="ln186">		// Ask the user about mount flags if this is not the</a>
<a name="ln187">		// initial scan.</a>
<a name="ln188">		if (!AutoMounter::_SuggestMountFlags(partition, &amp;mountFlags))</a>
<a name="ln189">			return false;</a>
<a name="ln190">	} else {</a>
<a name="ln191">		BString mountFlagsKey(path.Path());</a>
<a name="ln192">		mountFlagsKey &lt;&lt; kMountFlagsKeyExtension;</a>
<a name="ln193">		if (fPrevious.FindInt32(mountFlagsKey.String(),</a>
<a name="ln194">				(int32*)&amp;mountFlags) &lt; B_OK) {</a>
<a name="ln195">			mountFlags = 0;</a>
<a name="ln196">		}</a>
<a name="ln197">	}</a>
<a name="ln198"> </a>
<a name="ln199">	if (partition-&gt;Mount(NULL, mountFlags) != B_OK) {</a>
<a name="ln200">		// TODO: Error to syslog</a>
<a name="ln201">	}</a>
<a name="ln202">	return false;</a>
<a name="ln203">}</a>
<a name="ln204"> </a>
<a name="ln205"> </a>
<a name="ln206">bool</a>
<a name="ln207">MountVisitor::_WasPreviouslyMounted(const BPath&amp; path,</a>
<a name="ln208">	const BPartition* partition)</a>
<a name="ln209">{</a>
<a name="ln210">	// We only check the legacy config data here; the current method</a>
<a name="ln211">	// is implemented in ArchivedVolumeVisitor -- this can be removed</a>
<a name="ln212">	// some day.</a>
<a name="ln213">	const char* volumeName = NULL;</a>
<a name="ln214">	if (partition-&gt;ContentName() == NULL</a>
<a name="ln215">		|| fPrevious.FindString(path.Path(), &amp;volumeName) != B_OK</a>
<a name="ln216">		|| strcmp(volumeName, partition-&gt;ContentName()) != 0)</a>
<a name="ln217">		return false;</a>
<a name="ln218"> </a>
<a name="ln219">	return true;</a>
<a name="ln220">}</a>
<a name="ln221"> </a>
<a name="ln222"> </a>
<a name="ln223">// #pragma mark - MountArchivedVisitor</a>
<a name="ln224"> </a>
<a name="ln225"> </a>
<a name="ln226">MountArchivedVisitor::MountArchivedVisitor(const BDiskDeviceList&amp; devices,</a>
<a name="ln227">		const BMessage&amp; archived)</a>
<a name="ln228">	:</a>
<a name="ln229">	fDevices(devices),</a>
<a name="ln230">	fArchived(archived),</a>
<a name="ln231">	fBestScore(-1),</a>
<a name="ln232">	fBestID(-1)</a>
<a name="ln233">{</a>
<a name="ln234">}</a>
<a name="ln235"> </a>
<a name="ln236"> </a>
<a name="ln237">MountArchivedVisitor::~MountArchivedVisitor()</a>
<a name="ln238">{</a>
<a name="ln239">	if (fBestScore &gt;= 6) {</a>
<a name="ln240">		uint32 mountFlags = fArchived.GetUInt32(&quot;mountFlags&quot;, 0);</a>
<a name="ln241">		BPartition* partition = fDevices.PartitionWithID(fBestID);</a>
<a name="ln242">		if (partition != NULL)</a>
<a name="ln243">			partition-&gt;Mount(NULL, mountFlags);</a>
<a name="ln244">	}</a>
<a name="ln245">}</a>
<a name="ln246"> </a>
<a name="ln247"> </a>
<a name="ln248">bool</a>
<a name="ln249">MountArchivedVisitor::Visit(BDiskDevice* device)</a>
<a name="ln250">{</a>
<a name="ln251">	return Visit(device, 0);</a>
<a name="ln252">}</a>
<a name="ln253"> </a>
<a name="ln254"> </a>
<a name="ln255">bool</a>
<a name="ln256">MountArchivedVisitor::Visit(BPartition* partition, int32 level)</a>
<a name="ln257">{</a>
<a name="ln258">	if (partition-&gt;IsMounted() || !partition-&gt;ContainsFileSystem())</a>
<a name="ln259">		return false;</a>
<a name="ln260"> </a>
<a name="ln261">	int score = _Score(partition);</a>
<a name="ln262">	if (score &gt; fBestScore) {</a>
<a name="ln263">		fBestScore = score;</a>
<a name="ln264">		fBestID = partition-&gt;ID();</a>
<a name="ln265">	}</a>
<a name="ln266"> </a>
<a name="ln267">	return false;</a>
<a name="ln268">}</a>
<a name="ln269"> </a>
<a name="ln270"> </a>
<a name="ln271">int</a>
<a name="ln272">MountArchivedVisitor::_Score(BPartition* partition)</a>
<a name="ln273">{</a>
<a name="ln274">	BPath path;</a>
<a name="ln275">	if (partition-&gt;GetPath(&amp;path) != B_OK)</a>
<a name="ln276">		return false;</a>
<a name="ln277"> </a>
<a name="ln278">	int score = 0;</a>
<a name="ln279"> </a>
<a name="ln280">	int64 capacity = fArchived.GetInt64(&quot;capacity&quot;, 0);</a>
<a name="ln281">	if (capacity == partition-&gt;ContentSize())</a>
<a name="ln282">		score += 4;</a>
<a name="ln283"> </a>
<a name="ln284">	BString deviceName = fArchived.GetString(&quot;deviceName&quot;);</a>
<a name="ln285">	if (deviceName == path.Path())</a>
<a name="ln286">		score += 3;</a>
<a name="ln287"> </a>
<a name="ln288">	BString volumeName = fArchived.GetString(&quot;volumeName&quot;);</a>
<a name="ln289">	if (volumeName == partition-&gt;ContentName())</a>
<a name="ln290">		score += 2;</a>
<a name="ln291"> </a>
<a name="ln292">	BString fsName = fArchived.FindString(&quot;fsName&quot;);</a>
<a name="ln293">	if (fsName == partition-&gt;ContentType())</a>
<a name="ln294">		score += 1;</a>
<a name="ln295"> </a>
<a name="ln296">	uint32 blockSize = fArchived.GetUInt32(&quot;blockSize&quot;, 0);</a>
<a name="ln297">	if (blockSize == partition-&gt;BlockSize())</a>
<a name="ln298">		score += 1;</a>
<a name="ln299"> </a>
<a name="ln300">	return score;</a>
<a name="ln301">}</a>
<a name="ln302"> </a>
<a name="ln303"> </a>
<a name="ln304">// #pragma mark - ArchiveVisitor</a>
<a name="ln305"> </a>
<a name="ln306"> </a>
<a name="ln307">ArchiveVisitor::ArchiveVisitor(BMessage&amp; message)</a>
<a name="ln308">	:</a>
<a name="ln309">	fMessage(message)</a>
<a name="ln310">{</a>
<a name="ln311">}</a>
<a name="ln312"> </a>
<a name="ln313"> </a>
<a name="ln314">ArchiveVisitor::~ArchiveVisitor()</a>
<a name="ln315">{</a>
<a name="ln316">}</a>
<a name="ln317"> </a>
<a name="ln318"> </a>
<a name="ln319">bool</a>
<a name="ln320">ArchiveVisitor::Visit(BDiskDevice* device)</a>
<a name="ln321">{</a>
<a name="ln322">	return Visit(device, 0);</a>
<a name="ln323">}</a>
<a name="ln324"> </a>
<a name="ln325"> </a>
<a name="ln326">bool</a>
<a name="ln327">ArchiveVisitor::Visit(BPartition* partition, int32 level)</a>
<a name="ln328">{</a>
<a name="ln329">	if (!partition-&gt;ContainsFileSystem())</a>
<a name="ln330">		return false;</a>
<a name="ln331"> </a>
<a name="ln332">	BPath path;</a>
<a name="ln333">	if (partition-&gt;GetPath(&amp;path) != B_OK)</a>
<a name="ln334">		return false;</a>
<a name="ln335"> </a>
<a name="ln336">	BMessage info;</a>
<a name="ln337">	info.AddUInt32(&quot;blockSize&quot;, partition-&gt;BlockSize());</a>
<a name="ln338">	info.AddInt64(&quot;capacity&quot;, partition-&gt;ContentSize());</a>
<a name="ln339">	info.AddString(&quot;deviceName&quot;, path.Path());</a>
<a name="ln340">	info.AddString(&quot;volumeName&quot;, partition-&gt;ContentName());</a>
<a name="ln341">	info.AddString(&quot;fsName&quot;, partition-&gt;ContentType());</a>
<a name="ln342"> </a>
<a name="ln343">	fMessage.AddMessage(&quot;info&quot;, &amp;info);</a>
<a name="ln344">	return false;</a>
<a name="ln345">}</a>
<a name="ln346"> </a>
<a name="ln347"> </a>
<a name="ln348">// #pragma mark -</a>
<a name="ln349"> </a>
<a name="ln350"> </a>
<a name="ln351">AutoMounter::AutoMounter()</a>
<a name="ln352">	:</a>
<a name="ln353">	BServer(kMountServerSignature, true, NULL),</a>
<a name="ln354">	fNormalMode(kRestorePreviousVolumes),</a>
<a name="ln355">	fRemovableMode(kAllVolumes),</a>
<a name="ln356">	fEjectWhenUnmounting(true)</a>
<a name="ln357">{</a>
<a name="ln358">	set_thread_priority(Thread(), B_LOW_PRIORITY);</a>
<a name="ln359"> </a>
<a name="ln360">	if (!BootedInSafeMode()) {</a>
<a name="ln361">		_ReadSettings();</a>
<a name="ln362">	} else {</a>
<a name="ln363">		// defeat automounter in safe mode, don't even care about the settings</a>
<a name="ln364">		fNormalMode = kNoVolumes;</a>
<a name="ln365">		fRemovableMode = kNoVolumes;</a>
<a name="ln366">	}</a>
<a name="ln367"> </a>
<a name="ln368">	BDiskDeviceRoster().StartWatching(this,</a>
<a name="ln369">		B_DEVICE_REQUEST_DEVICE | B_DEVICE_REQUEST_DEVICE_LIST);</a>
<a name="ln370">	BLaunchRoster().RegisterEvent(this, kInitialMountEvent, B_STICKY_EVENT);</a>
<a name="ln371">}</a>
<a name="ln372"> </a>
<a name="ln373"> </a>
<a name="ln374">AutoMounter::~AutoMounter()</a>
<a name="ln375">{</a>
<a name="ln376">	BLaunchRoster().UnregisterEvent(this, kInitialMountEvent);</a>
<a name="ln377">	BDiskDeviceRoster().StopWatching(this);</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380"> </a>
<a name="ln381">void</a>
<a name="ln382">AutoMounter::ReadyToRun()</a>
<a name="ln383">{</a>
<a name="ln384">	// Do initial scan</a>
<a name="ln385">	_MountVolumes(fNormalMode, fRemovableMode, true);</a>
<a name="ln386">	BLaunchRoster().NotifyEvent(this, kInitialMountEvent);</a>
<a name="ln387">}</a>
<a name="ln388"> </a>
<a name="ln389"> </a>
<a name="ln390">void</a>
<a name="ln391">AutoMounter::MessageReceived(BMessage* message)</a>
<a name="ln392">{</a>
<a name="ln393">	switch (message-&gt;what) {</a>
<a name="ln394">		case kMountVolume:</a>
<a name="ln395">			_MountVolume(message);</a>
<a name="ln396">			break;</a>
<a name="ln397"> </a>
<a name="ln398">		case kUnmountVolume:</a>
<a name="ln399">			_UnmountAndEjectVolume(message);</a>
<a name="ln400">			break;</a>
<a name="ln401"> </a>
<a name="ln402">		case kSetAutomounterParams:</a>
<a name="ln403">		{</a>
<a name="ln404">			bool rescanNow = false;</a>
<a name="ln405">			message-&gt;FindBool(&quot;rescanNow&quot;, &amp;rescanNow);</a>
<a name="ln406"> </a>
<a name="ln407">			_UpdateSettingsFromMessage(message);</a>
<a name="ln408">			_GetSettings(&amp;fSettings);</a>
<a name="ln409">			_WriteSettings();</a>
<a name="ln410"> </a>
<a name="ln411">			if (rescanNow)</a>
<a name="ln412">				_MountVolumes(fNormalMode, fRemovableMode);</a>
<a name="ln413">			break;</a>
<a name="ln414">		}</a>
<a name="ln415"> </a>
<a name="ln416">		case kGetAutomounterParams:</a>
<a name="ln417">		{</a>
<a name="ln418">			BMessage reply;</a>
<a name="ln419">			_GetSettings(&amp;reply);</a>
<a name="ln420">			message-&gt;SendReply(&amp;reply);</a>
<a name="ln421">			break;</a>
<a name="ln422">		}</a>
<a name="ln423"> </a>
<a name="ln424">		case kMountAllNow:</a>
<a name="ln425">			_MountVolumes(kAllVolumes, kAllVolumes);</a>
<a name="ln426">			break;</a>
<a name="ln427"> </a>
<a name="ln428">		case B_DEVICE_UPDATE:</a>
<a name="ln429">			int32 event;</a>
<a name="ln430">			if (message-&gt;FindInt32(&quot;event&quot;, &amp;event) != B_OK</a>
<a name="ln431">				|| (event != B_DEVICE_MEDIA_CHANGED</a>
<a name="ln432">					&amp;&amp; event != B_DEVICE_ADDED))</a>
<a name="ln433">				break;</a>
<a name="ln434"> </a>
<a name="ln435">			partition_id deviceID;</a>
<a name="ln436">			if (message-&gt;FindInt32(&quot;id&quot;, &amp;deviceID) != B_OK)</a>
<a name="ln437">				break;</a>
<a name="ln438"> </a>
<a name="ln439">			_MountVolumes(kNoVolumes, fRemovableMode, false, deviceID);</a>
<a name="ln440">			break;</a>
<a name="ln441"> </a>
<a name="ln442">#if 0</a>
<a name="ln443">		case B_NODE_MONITOR:</a>
<a name="ln444">		{</a>
<a name="ln445">			int32 opcode;</a>
<a name="ln446">			if (message-&gt;FindInt32(&quot;opcode&quot;, &amp;opcode) != B_OK)</a>
<a name="ln447">				break;</a>
<a name="ln448"> </a>
<a name="ln449">			switch (opcode) {</a>
<a name="ln450">				//	The name of a mount point has changed</a>
<a name="ln451">				case B_ENTRY_MOVED: {</a>
<a name="ln452">					WRITELOG((&quot;*** Received Mount Point Renamed Notification&quot;));</a>
<a name="ln453"> </a>
<a name="ln454">					const char *newName;</a>
<a name="ln455">					if (message-&gt;FindString(&quot;name&quot;, &amp;newName) != B_OK) {</a>
<a name="ln456">						WRITELOG((&quot;ERROR: Couldn't find name field in update &quot;</a>
<a name="ln457">							&quot;message&quot;));</a>
<a name="ln458">						PRINT_OBJECT(*message);</a>
<a name="ln459">						break ;</a>
<a name="ln460">					}</a>
<a name="ln461"> </a>
<a name="ln462">					//</a>
<a name="ln463">					// When the node monitor reports a move, it gives the</a>
<a name="ln464">					// parent device and inode that moved.  The problem is</a>
<a name="ln465">					// that  the inode is the inode of root *in* the filesystem,</a>
<a name="ln466">					// which is generally always the same number for every</a>
<a name="ln467">					// filesystem of a type.</a>
<a name="ln468">					//</a>
<a name="ln469">					// What we'd really like is the device that the moved</a>
<a name="ln470">					// volume is mounted on.  Find this by using the</a>
<a name="ln471">					// *new* name and directory, and then stat()ing that to</a>
<a name="ln472">					// find the device.</a>
<a name="ln473">					//</a>
<a name="ln474">					dev_t parentDevice;</a>
<a name="ln475">					if (message-&gt;FindInt32(&quot;device&quot;, &amp;parentDevice) != B_OK) {</a>
<a name="ln476">						WRITELOG((&quot;ERROR: Couldn't find 'device' field in &quot;</a>
<a name="ln477">							&quot;update message&quot;));</a>
<a name="ln478">						PRINT_OBJECT(*message);</a>
<a name="ln479">						break;</a>
<a name="ln480">					}</a>
<a name="ln481"> </a>
<a name="ln482">					ino_t toDirectory;</a>
<a name="ln483">					if (message-&gt;FindInt64(&quot;to directory&quot;, &amp;toDirectory)</a>
<a name="ln484">						!= B_OK) {</a>
<a name="ln485">						WRITELOG((&quot;ERROR: Couldn't find 'to directory' field &quot;</a>
<a name="ln486">							&quot;in update message&quot;));</a>
<a name="ln487">						PRINT_OBJECT(*message);</a>
<a name="ln488">						break;</a>
<a name="ln489">					}</a>
<a name="ln490"> </a>
<a name="ln491">					entry_ref root_entry(parentDevice, toDirectory, newName);</a>
<a name="ln492"> </a>
<a name="ln493">					BNode entryNode(&amp;root_entry);</a>
<a name="ln494">					if (entryNode.InitCheck() != B_OK) {</a>
<a name="ln495">						WRITELOG((&quot;ERROR: Couldn't create mount point entry &quot;</a>
<a name="ln496">							&quot;node: %s/n&quot;, strerror(entryNode.InitCheck())));</a>
<a name="ln497">						break;</a>
<a name="ln498">					}</a>
<a name="ln499"> </a>
<a name="ln500">					node_ref mountPointNode;</a>
<a name="ln501">					if (entryNode.GetNodeRef(&amp;mountPointNode) != B_OK) {</a>
<a name="ln502">						WRITELOG((&quot;ERROR: Couldn't get node ref for new mount &quot;</a>
<a name="ln503">							&quot;point&quot;));</a>
<a name="ln504">						break;</a>
<a name="ln505">					}</a>
<a name="ln506"> </a>
<a name="ln507">					WRITELOG((&quot;Attempt to rename device %li to %s&quot;,</a>
<a name="ln508">						mountPointNode.device, newName));</a>
<a name="ln509"> </a>
<a name="ln510">					Partition *partition = FindPartition(mountPointNode.device);</a>
<a name="ln511">					if (partition != NULL) {</a>
<a name="ln512">						WRITELOG((&quot;Found device, changing name.&quot;));</a>
<a name="ln513"> </a>
<a name="ln514">						BVolume mountVolume(partition-&gt;VolumeDeviceID());</a>
<a name="ln515">						BDirectory mountDir;</a>
<a name="ln516">						mountVolume.GetRootDirectory(&amp;mountDir);</a>
<a name="ln517">						BPath dirPath(&amp;mountDir, 0);</a>
<a name="ln518"> </a>
<a name="ln519">						partition-&gt;SetMountedAt(dirPath.Path());</a>
<a name="ln520">						partition-&gt;SetVolumeName(newName);</a>
<a name="ln521">						break;</a>
<a name="ln522">					} else {</a>
<a name="ln523">						WRITELOG((&quot;ERROR: Device %li does not appear to be &quot;</a>
<a name="ln524">							&quot;present&quot;, mountPointNode.device));</a>
<a name="ln525">					}</a>
<a name="ln526">				}</a>
<a name="ln527">			}</a>
<a name="ln528">			break;</a>
<a name="ln529">		}</a>
<a name="ln530">#endif</a>
<a name="ln531"> </a>
<a name="ln532">		default:</a>
<a name="ln533">			BLooper::MessageReceived(message);</a>
<a name="ln534">			break;</a>
<a name="ln535">	}</a>
<a name="ln536">}</a>
<a name="ln537"> </a>
<a name="ln538"> </a>
<a name="ln539">bool</a>
<a name="ln540">AutoMounter::QuitRequested()</a>
<a name="ln541">{</a>
<a name="ln542">	if (!BootedInSafeMode()) {</a>
<a name="ln543">		// Don't write out settings in safe mode - this would overwrite the</a>
<a name="ln544">		// normal, non-safe mode settings.</a>
<a name="ln545">		_WriteSettings();</a>
<a name="ln546">	}</a>
<a name="ln547"> </a>
<a name="ln548">	return true;</a>
<a name="ln549">}</a>
<a name="ln550"> </a>
<a name="ln551"> </a>
<a name="ln552">// #pragma mark - private methods</a>
<a name="ln553"> </a>
<a name="ln554"> </a>
<a name="ln555">void</a>
<a name="ln556">AutoMounter::_MountVolumes(mount_mode normal, mount_mode removable,</a>
<a name="ln557">	bool initialRescan, partition_id deviceID)</a>
<a name="ln558">{</a>
<a name="ln559">	if (normal == kNoVolumes &amp;&amp; removable == kNoVolumes)</a>
<a name="ln560">		return;</a>
<a name="ln561"> </a>
<a name="ln562">	BDiskDeviceList devices;</a>
<a name="ln563">	status_t status = devices.Fetch();</a>
<a name="ln564">	if (status != B_OK)</a>
<a name="ln565">		return;</a>
<a name="ln566"> </a>
<a name="ln567">	if (normal == kRestorePreviousVolumes) {</a>
<a name="ln568">		BMessage archived;</a>
<a name="ln569">		for (int32 index = 0;</a>
<a name="ln570">				fSettings.FindMessage(&quot;info&quot;, index, &amp;archived) == B_OK;</a>
<a name="ln571">				index++) {</a>
<a name="ln572">			MountArchivedVisitor visitor(devices, archived);</a>
<a name="ln573">			devices.VisitEachPartition(&amp;visitor);</a>
<a name="ln574">		}</a>
<a name="ln575">	}</a>
<a name="ln576"> </a>
<a name="ln577">	MountVisitor visitor(normal, removable, initialRescan, fSettings, deviceID);</a>
<a name="ln578">	devices.VisitEachPartition(&amp;visitor);</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581"> </a>
<a name="ln582">void</a>
<a name="ln583">AutoMounter::_MountVolume(const BMessage* message)</a>
<a name="ln584">{</a>
<a name="ln585">	int32 id;</a>
<a name="ln586">	if (message-&gt;FindInt32(&quot;id&quot;, &amp;id) != B_OK)</a>
<a name="ln587">		return;</a>
<a name="ln588"> </a>
<a name="ln589">	BDiskDeviceRoster roster;</a>
<a name="ln590">	BPartition *partition;</a>
<a name="ln591">	BDiskDevice device;</a>
<a name="ln592">	if (roster.GetPartitionWithID(id, &amp;device, &amp;partition) != B_OK)</a>
<a name="ln593">		return;</a>
<a name="ln594"> </a>
<a name="ln595">	uint32 mountFlags;</a>
<a name="ln596">	if (!_SuggestMountFlags(partition, &amp;mountFlags))</a>
<a name="ln597">		return;</a>
<a name="ln598"> </a>
<a name="ln599">	status_t status = partition-&gt;Mount(NULL, mountFlags);</a>
<a name="ln600">	if (status &lt; B_OK) {</a>
<a name="ln601">		char text[512];</a>
<a name="ln602">		snprintf(text, sizeof(text),</a>
<a name="ln603">			B_TRANSLATE(&quot;Error mounting volume:\n\n%s&quot;), strerror(status));</a>
<a name="ln604">		BAlert* alert = new BAlert(B_TRANSLATE(&quot;Mount error&quot;), text,</a>
<a name="ln605">			B_TRANSLATE(&quot;OK&quot;));</a>
<a name="ln606">		alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln607">		alert-&gt;Go(NULL);</a>
<a name="ln608">	}</a>
<a name="ln609">}</a>
<a name="ln610"> </a>
<a name="ln611"> </a>
<a name="ln612">bool</a>
<a name="ln613">AutoMounter::_SuggestForceUnmount(const char* name, status_t error)</a>
<a name="ln614">{</a>
<a name="ln615">	char text[1024];</a>
<a name="ln616">	snprintf(text, sizeof(text),</a>
<a name="ln617">		B_TRANSLATE(&quot;Could not unmount disk \&quot;%s\&quot;:\n\t%s\n\n&quot;</a>
<a name="ln618">			&quot;Should unmounting be forced?\n\n&quot;</a>
<a name="ln619">			&quot;Note: If an application is currently writing to the volume, &quot;</a>
<a name="ln620">			&quot;unmounting it now might result in loss of data.\n&quot;),</a>
<a name="ln621">		name, strerror(error));</a>
<a name="ln622"> </a>
<a name="ln623">	BAlert* alert = new BAlert(B_TRANSLATE(&quot;Force unmount&quot;), text,</a>
<a name="ln624">		B_TRANSLATE(&quot;Cancel&quot;), B_TRANSLATE(&quot;Force unmount&quot;), NULL,</a>
<a name="ln625">		B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln626">	alert-&gt;SetShortcut(0, B_ESCAPE);</a>
<a name="ln627">	int32 choice = alert-&gt;Go();</a>
<a name="ln628"> </a>
<a name="ln629">	return choice == 1;</a>
<a name="ln630">}</a>
<a name="ln631"> </a>
<a name="ln632"> </a>
<a name="ln633">void</a>
<a name="ln634">AutoMounter::_ReportUnmountError(const char* name, status_t error)</a>
<a name="ln635">{</a>
<a name="ln636">	char text[512];</a>
<a name="ln637">	snprintf(text, sizeof(text), B_TRANSLATE(&quot;Could not unmount disk &quot;</a>
<a name="ln638">		&quot;\&quot;%s\&quot;:\n\t%s&quot;), name, strerror(error));</a>
<a name="ln639"> </a>
<a name="ln640">	BAlert* alert = new BAlert(B_TRANSLATE(&quot;Unmount error&quot;), text,</a>
<a name="ln641">		B_TRANSLATE(&quot;OK&quot;), NULL, NULL, B_WIDTH_AS_USUAL, B_WARNING_ALERT);</a>
<a name="ln642">	alert-&gt;SetFlags(alert-&gt;Flags() | B_CLOSE_ON_ESCAPE);</a>
<a name="ln643">	alert-&gt;Go(NULL);</a>
<a name="ln644">}</a>
<a name="ln645"> </a>
<a name="ln646"> </a>
<a name="ln647">void</a>
<a name="ln648">AutoMounter::_UnmountAndEjectVolume(BPartition* partition, BPath&amp; mountPoint,</a>
<a name="ln649">	const char* name)</a>
<a name="ln650">{</a>
<a name="ln651">	BDiskDevice deviceStorage;</a>
<a name="ln652">	BDiskDevice* device;</a>
<a name="ln653">	if (partition == NULL) {</a>
<a name="ln654">		// Try to retrieve partition</a>
<a name="ln655">		BDiskDeviceRoster().FindPartitionByMountPoint(mountPoint.Path(),</a>
<a name="ln656">			&amp;deviceStorage, &amp;partition);</a>
<a name="ln657">			device = &amp;deviceStorage;</a>
<a name="ln658">	} else {</a>
<a name="ln659">		device = partition-&gt;Device();</a>
<a name="ln660">	}</a>
<a name="ln661"> </a>
<a name="ln662">	status_t status;</a>
<a name="ln663">	if (partition != NULL)</a>
<a name="ln664">		status = partition-&gt;Unmount();</a>
<a name="ln665">	else</a>
<a name="ln666">		status = fs_unmount_volume(mountPoint.Path(), 0);</a>
<a name="ln667"> </a>
<a name="ln668">	if (status != B_OK) {</a>
<a name="ln669">		if (!_SuggestForceUnmount(name, status))</a>
<a name="ln670">			return;</a>
<a name="ln671"> </a>
<a name="ln672">		if (partition != NULL)</a>
<a name="ln673">			status = partition-&gt;Unmount(B_FORCE_UNMOUNT);</a>
<a name="ln674">		else</a>
<a name="ln675">			status = fs_unmount_volume(mountPoint.Path(), B_FORCE_UNMOUNT);</a>
<a name="ln676">	}</a>
<a name="ln677"> </a>
<a name="ln678">	if (status != B_OK) {</a>
<a name="ln679">		_ReportUnmountError(name, status);</a>
<a name="ln680">		return;</a>
<a name="ln681">	}</a>
<a name="ln682"> </a>
<a name="ln683">	if (fEjectWhenUnmounting &amp;&amp; partition != NULL) {</a>
<a name="ln684">		// eject device if it doesn't have any mounted partitions left</a>
<a name="ln685">		class IsMountedVisitor : public BDiskDeviceVisitor {</a>
<a name="ln686">		public:</a>
<a name="ln687">			IsMountedVisitor()</a>
<a name="ln688">				:</a>
<a name="ln689">				fHasMounted(false)</a>
<a name="ln690">			{</a>
<a name="ln691">			}</a>
<a name="ln692"> </a>
<a name="ln693">			virtual bool Visit(BDiskDevice* device)</a>
<a name="ln694">			{</a>
<a name="ln695">				return Visit(device, 0);</a>
<a name="ln696">			}</a>
<a name="ln697"> </a>
<a name="ln698">			virtual bool Visit(BPartition* partition, int32 level)</a>
<a name="ln699">			{</a>
<a name="ln700">				if (partition-&gt;IsMounted()) {</a>
<a name="ln701">					fHasMounted = true;</a>
<a name="ln702">					return true;</a>
<a name="ln703">				}</a>
<a name="ln704"> </a>
<a name="ln705">				return false;</a>
<a name="ln706">			}</a>
<a name="ln707"> </a>
<a name="ln708">			bool HasMountedPartitions() const</a>
<a name="ln709">			{</a>
<a name="ln710">				return fHasMounted;</a>
<a name="ln711">			}</a>
<a name="ln712"> </a>
<a name="ln713">		private:</a>
<a name="ln714">			bool	fHasMounted;</a>
<a name="ln715">		} visitor;</a>
<a name="ln716"> </a>
<a name="ln717">		device-&gt;VisitEachDescendant(&amp;visitor);</a>
<a name="ln718"> </a>
<a name="ln719">		if (!visitor.HasMountedPartitions())</a>
<a name="ln720">			device-&gt;Eject();</a>
<a name="ln721">	}</a>
<a name="ln722"> </a>
<a name="ln723">	// remove the directory if it's a directory in rootfs</a>
<a name="ln724">	if (dev_for_path(mountPoint.Path()) == dev_for_path(&quot;/&quot;))</a>
<a name="ln725">		rmdir(mountPoint.Path());</a>
<a name="ln726">}</a>
<a name="ln727"> </a>
<a name="ln728"> </a>
<a name="ln729">void</a>
<a name="ln730">AutoMounter::_UnmountAndEjectVolume(BMessage* message)</a>
<a name="ln731">{</a>
<a name="ln732">	int32 id;</a>
<a name="ln733">	if (message-&gt;FindInt32(&quot;id&quot;, &amp;id) == B_OK) {</a>
<a name="ln734">		BDiskDeviceRoster roster;</a>
<a name="ln735">		BPartition *partition;</a>
<a name="ln736">		BDiskDevice device;</a>
<a name="ln737">		if (roster.GetPartitionWithID(id, &amp;device, &amp;partition) != B_OK)</a>
<a name="ln738">			return;</a>
<a name="ln739"> </a>
<a name="ln740">		BPath path;</a>
<a name="ln741">		if (partition-&gt;GetMountPoint(&amp;path) == B_OK)</a>
<a name="ln742">			_UnmountAndEjectVolume(partition, path, partition-&gt;ContentName());</a>
<a name="ln743">	} else {</a>
<a name="ln744">		// see if we got a dev_t</a>
<a name="ln745"> </a>
<a name="ln746">		dev_t device;</a>
<a name="ln747">		if (message-&gt;FindInt32(&quot;device_id&quot;, &amp;device) != B_OK)</a>
<a name="ln748">			return;</a>
<a name="ln749"> </a>
<a name="ln750">		BVolume volume(device);</a>
<a name="ln751">		status_t status = volume.InitCheck();</a>
<a name="ln752"> </a>
<a name="ln753">		char name[B_FILE_NAME_LENGTH];</a>
<a name="ln754">		if (status == B_OK)</a>
<a name="ln755">			status = volume.GetName(name);</a>
<a name="ln756">		if (status &lt; B_OK)</a>
<a name="ln757">			snprintf(name, sizeof(name), &quot;device:%&quot; B_PRIdDEV, device);</a>
<a name="ln758"> </a>
<a name="ln759">		BPath path;</a>
<a name="ln760">		if (status == B_OK) {</a>
<a name="ln761">			BDirectory mountPoint;</a>
<a name="ln762">			status = volume.GetRootDirectory(&amp;mountPoint);</a>
<a name="ln763">			if (status == B_OK)</a>
<a name="ln764">				status = path.SetTo(&amp;mountPoint, &quot;.&quot;);</a>
<a name="ln765">		}</a>
<a name="ln766"> </a>
<a name="ln767">		if (status == B_OK)</a>
<a name="ln768">			_UnmountAndEjectVolume(NULL, path, name);</a>
<a name="ln769">	}</a>
<a name="ln770">}</a>
<a name="ln771"> </a>
<a name="ln772"> </a>
<a name="ln773">void</a>
<a name="ln774">AutoMounter::_FromMode(mount_mode mode, bool&amp; all, bool&amp; bfs, bool&amp; restore)</a>
<a name="ln775">{</a>
<a name="ln776">	all = bfs = restore = false;</a>
<a name="ln777"> </a>
<a name="ln778">	switch (mode) {</a>
<a name="ln779">		case kAllVolumes:</a>
<a name="ln780">			all = true;</a>
<a name="ln781">			break;</a>
<a name="ln782">		case kOnlyBFSVolumes:</a>
<a name="ln783">			bfs = true;</a>
<a name="ln784">			break;</a>
<a name="ln785">		case kRestorePreviousVolumes:</a>
<a name="ln786">			restore = true;</a>
<a name="ln787">			break;</a>
<a name="ln788"> </a>
<a name="ln789">		default:</a>
<a name="ln790">			break;</a>
<a name="ln791">	}</a>
<a name="ln792">}</a>
<a name="ln793"> </a>
<a name="ln794"> </a>
<a name="ln795">mount_mode</a>
<a name="ln796">AutoMounter::_ToMode(bool all, bool bfs, bool restore)</a>
<a name="ln797">{</a>
<a name="ln798">	if (all)</a>
<a name="ln799">		return kAllVolumes;</a>
<a name="ln800">	if (bfs)</a>
<a name="ln801">		return kOnlyBFSVolumes;</a>
<a name="ln802">	if (restore)</a>
<a name="ln803">		return kRestorePreviousVolumes;</a>
<a name="ln804"> </a>
<a name="ln805">	return kNoVolumes;</a>
<a name="ln806">}</a>
<a name="ln807"> </a>
<a name="ln808"> </a>
<a name="ln809">void</a>
<a name="ln810">AutoMounter::_ReadSettings()</a>
<a name="ln811">{</a>
<a name="ln812">	BPath directoryPath;</a>
<a name="ln813">	if (find_directory(B_USER_SETTINGS_DIRECTORY, &amp;directoryPath, true)</a>
<a name="ln814">		!= B_OK) {</a>
<a name="ln815">		return;</a>
<a name="ln816">	}</a>
<a name="ln817"> </a>
<a name="ln818">	BPath path(directoryPath);</a>
<a name="ln819">	path.Append(kMountServerSettings);</a>
<a name="ln820">	fPrefsFile.SetTo(path.Path(), O_RDWR);</a>
<a name="ln821"> </a>
<a name="ln822">	if (fPrefsFile.InitCheck() != B_OK) {</a>
<a name="ln823">		// no prefs file yet, create a new one</a>
<a name="ln824"> </a>
<a name="ln825">		BDirectory dir(directoryPath.Path());</a>
<a name="ln826">		dir.CreateFile(kMountServerSettings, &amp;fPrefsFile);</a>
<a name="ln827">		return;</a>
<a name="ln828">	}</a>
<a name="ln829"> </a>
<a name="ln830">	ssize_t settingsSize = (ssize_t)fPrefsFile.Seek(0, SEEK_END);</a>
<a name="ln831">	if (settingsSize == 0)</a>
<a name="ln832">		return;</a>
<a name="ln833"> </a>
<a name="ln834">	ASSERT(settingsSize != 0);</a>
<a name="ln835">	char *buffer = new(std::nothrow) char[settingsSize];</a>
<a name="ln836">	if (buffer == NULL) {</a>
<a name="ln837">		PRINT((&quot;error writing automounter settings, out of memory\n&quot;));</a>
<a name="ln838">		return;</a>
<a name="ln839">	}</a>
<a name="ln840"> </a>
<a name="ln841">	fPrefsFile.Seek(0, 0);</a>
<a name="ln842">	if (fPrefsFile.Read(buffer, (size_t)settingsSize) != settingsSize) {</a>
<a name="ln843">		PRINT((&quot;error reading automounter settings\n&quot;));</a>
<a name="ln844">		delete [] buffer;</a>
<a name="ln845">		return;</a>
<a name="ln846">	}</a>
<a name="ln847"> </a>
<a name="ln848">	BMessage message('stng');</a>
<a name="ln849">	status_t result = message.Unflatten(buffer);</a>
<a name="ln850">	if (result != B_OK) {</a>
<a name="ln851">		PRINT((&quot;error %s unflattening automounter settings, size %&quot; B_PRIdSSIZE &quot;\n&quot;,</a>
<a name="ln852">			strerror(result), settingsSize));</a>
<a name="ln853">		delete [] buffer;</a>
<a name="ln854">		return;</a>
<a name="ln855">	}</a>
<a name="ln856"> </a>
<a name="ln857">	delete [] buffer;</a>
<a name="ln858"> </a>
<a name="ln859">	// update flags and modes from the message</a>
<a name="ln860">	_UpdateSettingsFromMessage(&amp;message);</a>
<a name="ln861">	// copy the previously mounted partitions</a>
<a name="ln862">	fSettings = message;</a>
<a name="ln863">}</a>
<a name="ln864"> </a>
<a name="ln865"> </a>
<a name="ln866">void</a>
<a name="ln867">AutoMounter::_WriteSettings()</a>
<a name="ln868">{</a>
<a name="ln869">	if (fPrefsFile.InitCheck() != B_OK)</a>
<a name="ln870">		return;</a>
<a name="ln871"> </a>
<a name="ln872">	BMessage message('stng');</a>
<a name="ln873">	_GetSettings(&amp;message);</a>
<a name="ln874"> </a>
<a name="ln875">	ssize_t settingsSize = message.FlattenedSize();</a>
<a name="ln876"> </a>
<a name="ln877">	char* buffer = new(std::nothrow) char[settingsSize];</a>
<a name="ln878">	if (buffer == NULL) {</a>
<a name="ln879">		PRINT((&quot;error writing automounter settings, out of memory\n&quot;));</a>
<a name="ln880">		return;</a>
<a name="ln881">	}</a>
<a name="ln882"> </a>
<a name="ln883">	status_t result = message.Flatten(buffer, settingsSize);</a>
<a name="ln884"> </a>
<a name="ln885">	fPrefsFile.Seek(0, SEEK_SET);</a>
<a name="ln886">	fPrefsFile.SetSize(0);</a>
<a name="ln887"> </a>
<a name="ln888">	result = fPrefsFile.Write(buffer, (size_t)settingsSize);</a>
<a name="ln889">	if (result != settingsSize)</a>
<a name="ln890">		PRINT((&quot;error writing automounter settings, %s\n&quot;, strerror(result)));</a>
<a name="ln891"> </a>
<a name="ln892">	delete [] buffer;</a>
<a name="ln893">}</a>
<a name="ln894"> </a>
<a name="ln895"> </a>
<a name="ln896">void</a>
<a name="ln897">AutoMounter::_UpdateSettingsFromMessage(BMessage* message)</a>
<a name="ln898">{</a>
<a name="ln899">	// auto mounter settings</a>
<a name="ln900"> </a>
<a name="ln901">	bool all, bfs, restore;</a>
<a name="ln902">	if (message-&gt;FindBool(&quot;autoMountAll&quot;, &amp;all) != B_OK)</a>
<a name="ln903">		all = true;</a>
<a name="ln904">	if (message-&gt;FindBool(&quot;autoMountAllBFS&quot;, &amp;bfs) != B_OK)</a>
<a name="ln905">		bfs = false;</a>
<a name="ln906"> </a>
<a name="ln907">	fRemovableMode = _ToMode(all, bfs, false);</a>
<a name="ln908"> </a>
<a name="ln909">	// initial mount settings</a>
<a name="ln910"> </a>
<a name="ln911">	if (message-&gt;FindBool(&quot;initialMountAll&quot;, &amp;all) != B_OK)</a>
<a name="ln912">		all = false;</a>
<a name="ln913">	if (message-&gt;FindBool(&quot;initialMountAllBFS&quot;, &amp;bfs) != B_OK)</a>
<a name="ln914">		bfs = false;</a>
<a name="ln915">	if (message-&gt;FindBool(&quot;initialMountRestore&quot;, &amp;restore) != B_OK)</a>
<a name="ln916">		restore = true;</a>
<a name="ln917"> </a>
<a name="ln918">	fNormalMode = _ToMode(all, bfs, restore);</a>
<a name="ln919"> </a>
<a name="ln920">	// eject settings</a>
<a name="ln921">	bool eject;</a>
<a name="ln922">	if (message-&gt;FindBool(&quot;ejectWhenUnmounting&quot;, &amp;eject) == B_OK)</a>
<a name="ln923">		fEjectWhenUnmounting = eject;</a>
<a name="ln924">}</a>
<a name="ln925"> </a>
<a name="ln926"> </a>
<a name="ln927">void</a>
<a name="ln928">AutoMounter::_GetSettings(BMessage *message)</a>
<a name="ln929">{</a>
<a name="ln930">	message-&gt;MakeEmpty();</a>
<a name="ln931"> </a>
<a name="ln932">	bool all, bfs, restore;</a>
<a name="ln933"> </a>
<a name="ln934">	_FromMode(fNormalMode, all, bfs, restore);</a>
<a name="ln935">	message-&gt;AddBool(&quot;initialMountAll&quot;, all);</a>
<a name="ln936">	message-&gt;AddBool(&quot;initialMountAllBFS&quot;, bfs);</a>
<a name="ln937">	message-&gt;AddBool(&quot;initialMountRestore&quot;, restore);</a>
<a name="ln938"> </a>
<a name="ln939">	_FromMode(fRemovableMode, all, bfs, restore);</a>
<a name="ln940">	message-&gt;AddBool(&quot;autoMountAll&quot;, all);</a>
<a name="ln941">	message-&gt;AddBool(&quot;autoMountAllBFS&quot;, bfs);</a>
<a name="ln942"> </a>
<a name="ln943">	message-&gt;AddBool(&quot;ejectWhenUnmounting&quot;, fEjectWhenUnmounting);</a>
<a name="ln944"> </a>
<a name="ln945">	// Save mounted volumes so we can optionally mount them on next</a>
<a name="ln946">	// startup</a>
<a name="ln947">	ArchiveVisitor visitor(*message);</a>
<a name="ln948">	BDiskDeviceRoster().VisitEachMountedPartition(&amp;visitor);</a>
<a name="ln949">}</a>
<a name="ln950"> </a>
<a name="ln951"> </a>
<a name="ln952">/*static*/ bool</a>
<a name="ln953">AutoMounter::_SuggestMountFlags(const BPartition* partition, uint32* _flags)</a>
<a name="ln954">{</a>
<a name="ln955">	uint32 mountFlags = 0;</a>
<a name="ln956"> </a>
<a name="ln957">	bool askReadOnly = true;</a>
<a name="ln958">	bool isBFS = false;</a>
<a name="ln959"> </a>
<a name="ln960">	if (partition-&gt;ContentType() != NULL</a>
<a name="ln961">		&amp;&amp; strcmp(partition-&gt;ContentType(), kPartitionTypeBFS) == 0) {</a>
<a name="ln962">#if 0</a>
<a name="ln963">		askReadOnly = false;</a>
<a name="ln964">#endif</a>
<a name="ln965">		isBFS = true;</a>
<a name="ln966">	}</a>
<a name="ln967"> </a>
<a name="ln968">	BDiskSystem diskSystem;</a>
<a name="ln969">	status_t status = partition-&gt;GetDiskSystem(&amp;diskSystem);</a>
<a name="ln970">	if (status == B_OK &amp;&amp; !diskSystem.SupportsWriting())</a>
<a name="ln971">		askReadOnly = false;</a>
<a name="ln972"> </a>
<a name="ln973">	if (partition-&gt;IsReadOnly())</a>
<a name="ln974">		askReadOnly = false;</a>
<a name="ln975"> </a>
<a name="ln976">	if (askReadOnly) {</a>
<a name="ln977">		// Suggest to the user to mount read-only until Haiku is more mature.</a>
<a name="ln978">		BString string;</a>
<a name="ln979">		if (partition-&gt;ContentName() != NULL) {</a>
<a name="ln980">			char buffer[512];</a>
<a name="ln981">			snprintf(buffer, sizeof(buffer),</a>
<a name="ln982">				B_TRANSLATE(&quot;Mounting volume '%s'\n\n&quot;),</a>
<a name="ln983">				partition-&gt;ContentName());</a>
<a name="ln984">			string &lt;&lt; buffer;</a>
<a name="ln985">		} else</a>
<a name="ln986">			string &lt;&lt; B_TRANSLATE(&quot;Mounting volume &lt;unnamed volume&gt;\n\n&quot;);</a>
<a name="ln987"> </a>
<a name="ln988">		// TODO: Use distro name instead of &quot;Haiku&quot;...</a>
<a name="ln989">		if (!isBFS) {</a>
<a name="ln990">			string &lt;&lt; B_TRANSLATE(&quot;The file system on this volume is not the &quot;</a>
<a name="ln991">				&quot;Haiku file system. It is strongly suggested to mount it in &quot;</a>
<a name="ln992">				&quot;read-only mode. This will prevent unintentional data loss &quot;</a>
<a name="ln993">				&quot;because of errors in Haiku.&quot;);</a>
<a name="ln994">		} else {</a>
<a name="ln995">			string &lt;&lt; B_TRANSLATE(&quot;It is suggested to mount all additional &quot;</a>
<a name="ln996">				&quot;Haiku volumes in read-only mode. This will prevent &quot;</a>
<a name="ln997">				&quot;unintentional data loss because of errors in Haiku.&quot;);</a>
<a name="ln998">		}</a>
<a name="ln999"> </a>
<a name="ln1000">		BAlert* alert = new BAlert(B_TRANSLATE(&quot;Mount warning&quot;),</a>
<a name="ln1001">			string.String(), B_TRANSLATE(&quot;Mount read/write&quot;),</a>
<a name="ln1002">			B_TRANSLATE(&quot;Cancel&quot;), B_TRANSLATE(&quot;Mount read-only&quot;),</a>
<a name="ln1003">			B_WIDTH_FROM_WIDEST, B_WARNING_ALERT);</a>
<a name="ln1004">		alert-&gt;SetShortcut(1, B_ESCAPE);</a>
<a name="ln1005">		int32 choice = alert-&gt;Go();</a>
<a name="ln1006">		switch (choice) {</a>
<a name="ln1007">			case 0:</a>
<a name="ln1008">				break;</a>
<a name="ln1009">			case 1:</a>
<a name="ln1010">				return false;</a>
<a name="ln1011">			case 2:</a>
<a name="ln1012">				mountFlags |= B_MOUNT_READ_ONLY;</a>
<a name="ln1013">				break;</a>
<a name="ln1014">		}</a>
<a name="ln1015">	}</a>
<a name="ln1016"> </a>
<a name="ln1017">	*_flags = mountFlags;</a>
<a name="ln1018">	return true;</a>
<a name="ln1019">}</a>
<a name="ln1020"> </a>
<a name="ln1021"> </a>
<a name="ln1022">// #pragma mark -</a>
<a name="ln1023"> </a>
<a name="ln1024"> </a>
<a name="ln1025">int</a>
<a name="ln1026">main(int argc, char* argv[])</a>
<a name="ln1027">{</a>
<a name="ln1028">	AutoMounter app;</a>
<a name="ln1029"> </a>
<a name="ln1030">	app.Run();</a>
<a name="ln1031">	return 0;</a>
<a name="ln1032">}</a>
<a name="ln1033"> </a>
<a name="ln1034"> </a>

</code></pre>
<div class="balloon" rel="644"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="1010"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="629"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'alert' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="608"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> Visibility scope of the 'alert' pointer was exited without releasing the memory. A memory leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
