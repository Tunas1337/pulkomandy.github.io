
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>PackageWriterImpl.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2009-2014, Ingo Weinhold, ingo_weinhold@gmx.de.</a>
<a name="ln3"> * Copyright 2011, Oliver Tappe &lt;zooey@hirschkaefer.de&gt;</a>
<a name="ln4"> * Distributed under the terms of the MIT License.</a>
<a name="ln5"> */</a>
<a name="ln6"> </a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;package/hpkg/PackageWriterImpl.h&gt;</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;dirent.h&gt;</a>
<a name="ln11">#include &lt;errno.h&gt;</a>
<a name="ln12">#include &lt;fcntl.h&gt;</a>
<a name="ln13">#include &lt;stdio.h&gt;</a>
<a name="ln14">#include &lt;stdlib.h&gt;</a>
<a name="ln15">#include &lt;string.h&gt;</a>
<a name="ln16">#include &lt;sys/stat.h&gt;</a>
<a name="ln17">#include &lt;unistd.h&gt;</a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;algorithm&gt;</a>
<a name="ln20">#include &lt;new&gt;</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;ByteOrder.h&gt;</a>
<a name="ln23">#include &lt;Directory.h&gt;</a>
<a name="ln24">#include &lt;Entry.h&gt;</a>
<a name="ln25">#include &lt;FindDirectory.h&gt;</a>
<a name="ln26">#include &lt;fs_attr.h&gt;</a>
<a name="ln27">#include &lt;Path.h&gt;</a>
<a name="ln28"> </a>
<a name="ln29">#include &lt;package/hpkg/BlockBufferPoolNoLock.h&gt;</a>
<a name="ln30">#include &lt;package/hpkg/PackageAttributeValue.h&gt;</a>
<a name="ln31">#include &lt;package/hpkg/PackageContentHandler.h&gt;</a>
<a name="ln32">#include &lt;package/hpkg/PackageData.h&gt;</a>
<a name="ln33">#include &lt;package/hpkg/PackageDataReader.h&gt;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;AutoDeleter.h&gt;</a>
<a name="ln36">#include &lt;RangeArray.h&gt;</a>
<a name="ln37"> </a>
<a name="ln38">#include &lt;package/hpkg/HPKGDefsPrivate.h&gt;</a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;package/hpkg/DataReader.h&gt;</a>
<a name="ln41">#include &lt;package/hpkg/PackageFileHeapReader.h&gt;</a>
<a name="ln42">#include &lt;package/hpkg/PackageFileHeapWriter.h&gt;</a>
<a name="ln43">#include &lt;package/hpkg/PackageReaderImpl.h&gt;</a>
<a name="ln44">#include &lt;package/hpkg/Stacker.h&gt;</a>
<a name="ln45"> </a>
<a name="ln46"> </a>
<a name="ln47">using BPrivate::FileDescriptorCloser;</a>
<a name="ln48"> </a>
<a name="ln49"> </a>
<a name="ln50">static const char* const kPublicDomainLicenseName = &quot;Public Domain&quot;;</a>
<a name="ln51"> </a>
<a name="ln52"> </a>
<a name="ln53">#include &lt;typeinfo&gt;</a>
<a name="ln54"> </a>
<a name="ln55">namespace BPackageKit {</a>
<a name="ln56"> </a>
<a name="ln57">namespace BHPKG {</a>
<a name="ln58"> </a>
<a name="ln59">namespace BPrivate {</a>
<a name="ln60"> </a>
<a name="ln61"> </a>
<a name="ln62">// #pragma mark - Attributes</a>
<a name="ln63"> </a>
<a name="ln64"> </a>
<a name="ln65">struct PackageWriterImpl::Attribute</a>
<a name="ln66">	: public DoublyLinkedListLinkImpl&lt;Attribute&gt; {</a>
<a name="ln67">	BHPKGAttributeID			id;</a>
<a name="ln68">	AttributeValue				value;</a>
<a name="ln69">	DoublyLinkedList&lt;Attribute&gt;	children;</a>
<a name="ln70"> </a>
<a name="ln71">	Attribute(BHPKGAttributeID id_ = B_HPKG_ATTRIBUTE_ID_ENUM_COUNT)</a>
<a name="ln72">		:</a>
<a name="ln73">		id(id_)</a>
<a name="ln74">	{</a>
<a name="ln75">	}</a>
<a name="ln76"> </a>
<a name="ln77">	~Attribute()</a>
<a name="ln78">	{</a>
<a name="ln79">		DeleteChildren();</a>
<a name="ln80">	}</a>
<a name="ln81"> </a>
<a name="ln82">	void AddChild(Attribute* child)</a>
<a name="ln83">	{</a>
<a name="ln84">		children.Add(child);</a>
<a name="ln85">	}</a>
<a name="ln86"> </a>
<a name="ln87">	void RemoveChild(Attribute* child)</a>
<a name="ln88">	{</a>
<a name="ln89">		children.Remove(child);</a>
<a name="ln90">	}</a>
<a name="ln91"> </a>
<a name="ln92">	void DeleteChildren()</a>
<a name="ln93">	{</a>
<a name="ln94">		while (Attribute* child = children.RemoveHead())</a>
<a name="ln95">			delete child;</a>
<a name="ln96">	}</a>
<a name="ln97"> </a>
<a name="ln98">	Attribute* FindEntryChild(const char* fileName) const</a>
<a name="ln99">	{</a>
<a name="ln100">		for (DoublyLinkedList&lt;Attribute&gt;::ConstIterator it</a>
<a name="ln101">				= children.GetIterator(); Attribute* child = it.Next();) {</a>
<a name="ln102">			if (child-&gt;id != B_HPKG_ATTRIBUTE_ID_DIRECTORY_ENTRY)</a>
<a name="ln103">				continue;</a>
<a name="ln104">			if (child-&gt;value.type != B_HPKG_ATTRIBUTE_TYPE_STRING)</a>
<a name="ln105">				continue;</a>
<a name="ln106">			const char* childName = child-&gt;value.string-&gt;string;</a>
<a name="ln107">			if (strcmp(fileName, childName) == 0)</a>
<a name="ln108">				return child;</a>
<a name="ln109">		}</a>
<a name="ln110"> </a>
<a name="ln111">		return NULL;</a>
<a name="ln112">	}</a>
<a name="ln113"> </a>
<a name="ln114">	Attribute* FindEntryChild(const char* fileName, size_t nameLength) const</a>
<a name="ln115">	{</a>
<a name="ln116">		BString name(fileName, nameLength);</a>
<a name="ln117">		return (size_t)name.Length() == nameLength</a>
<a name="ln118">			? FindEntryChild(name) : NULL;</a>
<a name="ln119">	}</a>
<a name="ln120"> </a>
<a name="ln121">	Attribute* FindNodeAttributeChild(const char* attributeName) const</a>
<a name="ln122">	{</a>
<a name="ln123">		for (DoublyLinkedList&lt;Attribute&gt;::ConstIterator it</a>
<a name="ln124">				= children.GetIterator(); Attribute* child = it.Next();) {</a>
<a name="ln125">			if (child-&gt;id != B_HPKG_ATTRIBUTE_ID_FILE_ATTRIBUTE)</a>
<a name="ln126">				continue;</a>
<a name="ln127">			if (child-&gt;value.type != B_HPKG_ATTRIBUTE_TYPE_STRING)</a>
<a name="ln128">				continue;</a>
<a name="ln129">			const char* childName = child-&gt;value.string-&gt;string;</a>
<a name="ln130">			if (strcmp(attributeName, childName) == 0)</a>
<a name="ln131">				return child;</a>
<a name="ln132">		}</a>
<a name="ln133"> </a>
<a name="ln134">		return NULL;</a>
<a name="ln135">	}</a>
<a name="ln136"> </a>
<a name="ln137">	Attribute* ChildWithID(BHPKGAttributeID id) const</a>
<a name="ln138">	{</a>
<a name="ln139">		for (DoublyLinkedList&lt;Attribute&gt;::ConstIterator it</a>
<a name="ln140">				= children.GetIterator(); Attribute* child = it.Next();) {</a>
<a name="ln141">			if (child-&gt;id == id)</a>
<a name="ln142">				return child;</a>
<a name="ln143">		}</a>
<a name="ln144"> </a>
<a name="ln145">		return NULL;</a>
<a name="ln146">	}</a>
<a name="ln147">};</a>
<a name="ln148"> </a>
<a name="ln149"> </a>
<a name="ln150">// #pragma mark - PackageContentHandler</a>
<a name="ln151"> </a>
<a name="ln152"> </a>
<a name="ln153">struct PackageWriterImpl::PackageContentHandler</a>
<a name="ln154">	: BLowLevelPackageContentHandler {</a>
<a name="ln155">	PackageContentHandler(Attribute* rootAttribute, BErrorOutput* errorOutput,</a>
<a name="ln156">		StringCache&amp; stringCache)</a>
<a name="ln157">		:</a>
<a name="ln158">		fErrorOutput(errorOutput),</a>
<a name="ln159">		fStringCache(stringCache),</a>
<a name="ln160">		fRootAttribute(rootAttribute),</a>
<a name="ln161">		fErrorOccurred(false)</a>
<a name="ln162">	{</a>
<a name="ln163">	}</a>
<a name="ln164"> </a>
<a name="ln165">	virtual status_t HandleSectionStart(BHPKGPackageSectionID sectionID,</a>
<a name="ln166">		bool&amp; _handleSection)</a>
<a name="ln167">	{</a>
<a name="ln168">		// we're only interested in the TOC</a>
<a name="ln169">		_handleSection = sectionID == B_HPKG_SECTION_PACKAGE_TOC;</a>
<a name="ln170">		return B_OK;</a>
<a name="ln171">	}</a>
<a name="ln172"> </a>
<a name="ln173">	virtual status_t HandleSectionEnd(BHPKGPackageSectionID sectionID)</a>
<a name="ln174">	{</a>
<a name="ln175">		return B_OK;</a>
<a name="ln176">	}</a>
<a name="ln177"> </a>
<a name="ln178">	virtual status_t HandleAttribute(BHPKGAttributeID attributeID,</a>
<a name="ln179">		const BPackageAttributeValue&amp; value, void* parentToken, void*&amp; _token)</a>
<a name="ln180">	{</a>
<a name="ln181">		if (fErrorOccurred)</a>
<a name="ln182">			return B_OK;</a>
<a name="ln183"> </a>
<a name="ln184">		Attribute* parentAttribute = parentToken != NULL</a>
<a name="ln185">			? (Attribute*)parentToken : fRootAttribute;</a>
<a name="ln186"> </a>
<a name="ln187">		Attribute* attribute = new Attribute(attributeID);</a>
<a name="ln188">		parentAttribute-&gt;AddChild(attribute);</a>
<a name="ln189"> </a>
<a name="ln190">		switch (value.type) {</a>
<a name="ln191">			case B_HPKG_ATTRIBUTE_TYPE_INT:</a>
<a name="ln192">				attribute-&gt;value.SetTo(value.signedInt);</a>
<a name="ln193">				break;</a>
<a name="ln194"> </a>
<a name="ln195">			case B_HPKG_ATTRIBUTE_TYPE_UINT:</a>
<a name="ln196">				attribute-&gt;value.SetTo(value.unsignedInt);</a>
<a name="ln197">				break;</a>
<a name="ln198"> </a>
<a name="ln199">			case B_HPKG_ATTRIBUTE_TYPE_STRING:</a>
<a name="ln200">			{</a>
<a name="ln201">				CachedString* string = fStringCache.Get(value.string);</a>
<a name="ln202">				if (string == NULL)</a>
<a name="ln203">					throw std::bad_alloc();</a>
<a name="ln204">				attribute-&gt;value.SetTo(string);</a>
<a name="ln205">				break;</a>
<a name="ln206">			}</a>
<a name="ln207"> </a>
<a name="ln208">			case B_HPKG_ATTRIBUTE_TYPE_RAW:</a>
<a name="ln209">				if (value.encoding == B_HPKG_ATTRIBUTE_ENCODING_RAW_HEAP) {</a>
<a name="ln210">					attribute-&gt;value.SetToData(value.data.size,</a>
<a name="ln211">						value.data.offset);</a>
<a name="ln212">				} else if (value.encoding</a>
<a name="ln213">						== B_HPKG_ATTRIBUTE_ENCODING_RAW_INLINE) {</a>
<a name="ln214">					attribute-&gt;value.SetToData(value.data.size, value.data.raw);</a>
<a name="ln215">				} else {</a>
<a name="ln216">					fErrorOutput-&gt;PrintError(&quot;Invalid attribute value encoding &quot;</a>
<a name="ln217">						&quot;%d (attribute %d)\n&quot;, value.encoding, attributeID);</a>
<a name="ln218">					return B_BAD_DATA;</a>
<a name="ln219">				}</a>
<a name="ln220">				break;</a>
<a name="ln221"> </a>
<a name="ln222">			case B_HPKG_ATTRIBUTE_TYPE_INVALID:</a>
<a name="ln223">			default:</a>
<a name="ln224">				fErrorOutput-&gt;PrintError(&quot;Invalid attribute value type %d &quot;</a>
<a name="ln225">					&quot;(attribute %d)\n&quot;, value.type, attributeID);</a>
<a name="ln226">				return B_BAD_DATA;</a>
<a name="ln227">		}</a>
<a name="ln228"> </a>
<a name="ln229">		_token = attribute;</a>
<a name="ln230">		return B_OK;</a>
<a name="ln231">	}</a>
<a name="ln232"> </a>
<a name="ln233">	virtual status_t HandleAttributeDone(BHPKGAttributeID attributeID,</a>
<a name="ln234">		const BPackageAttributeValue&amp; value, void* parentToken, void* token)</a>
<a name="ln235">	{</a>
<a name="ln236">		return B_OK;</a>
<a name="ln237">	}</a>
<a name="ln238"> </a>
<a name="ln239">	virtual void HandleErrorOccurred()</a>
<a name="ln240">	{</a>
<a name="ln241">		fErrorOccurred = true;</a>
<a name="ln242">	}</a>
<a name="ln243"> </a>
<a name="ln244">private:</a>
<a name="ln245">	BErrorOutput*	fErrorOutput;</a>
<a name="ln246">	StringCache&amp;	fStringCache;</a>
<a name="ln247">	Attribute*		fRootAttribute;</a>
<a name="ln248">	bool			fErrorOccurred;</a>
<a name="ln249">};</a>
<a name="ln250"> </a>
<a name="ln251"> </a>
<a name="ln252">// #pragma mark - Entry</a>
<a name="ln253"> </a>
<a name="ln254"> </a>
<a name="ln255">struct PackageWriterImpl::Entry : DoublyLinkedListLinkImpl&lt;Entry&gt; {</a>
<a name="ln256">	Entry(char* name, size_t nameLength, int fd, bool isImplicit)</a>
<a name="ln257">		:</a>
<a name="ln258">		fName(name),</a>
<a name="ln259">		fNameLength(nameLength),</a>
<a name="ln260">		fFD(fd),</a>
<a name="ln261">		fIsImplicit(isImplicit)</a>
<a name="ln262">	{</a>
<a name="ln263">	}</a>
<a name="ln264"> </a>
<a name="ln265">	~Entry()</a>
<a name="ln266">	{</a>
<a name="ln267">		DeleteChildren();</a>
<a name="ln268">		free(fName);</a>
<a name="ln269">	}</a>
<a name="ln270"> </a>
<a name="ln271">	static Entry* Create(const char* name, size_t nameLength, int fd,</a>
<a name="ln272">		bool isImplicit)</a>
<a name="ln273">	{</a>
<a name="ln274">		char* clonedName = (char*)malloc(nameLength + 1);</a>
<a name="ln275">		if (clonedName == NULL)</a>
<a name="ln276">			throw std::bad_alloc();</a>
<a name="ln277">		memcpy(clonedName, name, nameLength);</a>
<a name="ln278">		clonedName[nameLength] = '\0';</a>
<a name="ln279"> </a>
<a name="ln280">		Entry* entry = new(std::nothrow) Entry(clonedName, nameLength, fd,</a>
<a name="ln281">			isImplicit);</a>
<a name="ln282">		if (entry == NULL) {</a>
<a name="ln283">			free(clonedName);</a>
<a name="ln284">			throw std::bad_alloc();</a>
<a name="ln285">		}</a>
<a name="ln286"> </a>
<a name="ln287">		return entry;</a>
<a name="ln288">	}</a>
<a name="ln289"> </a>
<a name="ln290">	const char* Name() const</a>
<a name="ln291">	{</a>
<a name="ln292">		return fName;</a>
<a name="ln293">	}</a>
<a name="ln294"> </a>
<a name="ln295">	int FD() const</a>
<a name="ln296">	{</a>
<a name="ln297">		return fFD;</a>
<a name="ln298">	}</a>
<a name="ln299"> </a>
<a name="ln300">	void SetFD(int fd)</a>
<a name="ln301">	{</a>
<a name="ln302">		fFD = fd;</a>
<a name="ln303">	}</a>
<a name="ln304"> </a>
<a name="ln305">	bool IsImplicit() const</a>
<a name="ln306">	{</a>
<a name="ln307">		return fIsImplicit;</a>
<a name="ln308">	}</a>
<a name="ln309"> </a>
<a name="ln310">	void SetImplicit(bool isImplicit)</a>
<a name="ln311">	{</a>
<a name="ln312">		fIsImplicit = isImplicit;</a>
<a name="ln313">	}</a>
<a name="ln314"> </a>
<a name="ln315">	bool HasName(const char* name, size_t nameLength)</a>
<a name="ln316">	{</a>
<a name="ln317">		return nameLength == fNameLength</a>
<a name="ln318">			&amp;&amp; strncmp(name, fName, nameLength) == 0;</a>
<a name="ln319">	}</a>
<a name="ln320"> </a>
<a name="ln321">	void AddChild(Entry* child)</a>
<a name="ln322">	{</a>
<a name="ln323">		fChildren.Add(child);</a>
<a name="ln324">	}</a>
<a name="ln325"> </a>
<a name="ln326">	void DeleteChildren()</a>
<a name="ln327">	{</a>
<a name="ln328">		while (Entry* child = fChildren.RemoveHead())</a>
<a name="ln329">			delete child;</a>
<a name="ln330">	}</a>
<a name="ln331"> </a>
<a name="ln332">	Entry* GetChild(const char* name, size_t nameLength) const</a>
<a name="ln333">	{</a>
<a name="ln334">		EntryList::ConstIterator it = fChildren.GetIterator();</a>
<a name="ln335">		while (Entry* child = it.Next()) {</a>
<a name="ln336">			if (child-&gt;HasName(name, nameLength))</a>
<a name="ln337">				return child;</a>
<a name="ln338">		}</a>
<a name="ln339"> </a>
<a name="ln340">		return NULL;</a>
<a name="ln341">	}</a>
<a name="ln342"> </a>
<a name="ln343">	EntryList::ConstIterator ChildIterator() const</a>
<a name="ln344">	{</a>
<a name="ln345">		return fChildren.GetIterator();</a>
<a name="ln346">	}</a>
<a name="ln347"> </a>
<a name="ln348">private:</a>
<a name="ln349">	char*		fName;</a>
<a name="ln350">	size_t		fNameLength;</a>
<a name="ln351">	int			fFD;</a>
<a name="ln352">	bool		fIsImplicit;</a>
<a name="ln353">	EntryList	fChildren;</a>
<a name="ln354">};</a>
<a name="ln355"> </a>
<a name="ln356"> </a>
<a name="ln357">// #pragma mark - SubPathAdder</a>
<a name="ln358"> </a>
<a name="ln359"> </a>
<a name="ln360">struct PackageWriterImpl::SubPathAdder {</a>
<a name="ln361">	SubPathAdder(BErrorOutput* errorOutput, char* pathBuffer,</a>
<a name="ln362">		const char* subPath)</a>
<a name="ln363">		:</a>
<a name="ln364">		fOriginalPathEnd(pathBuffer + strlen(pathBuffer))</a>
<a name="ln365">	{</a>
<a name="ln366">		if (fOriginalPathEnd != pathBuffer)</a>
<a name="ln367">			strlcat(pathBuffer, &quot;/&quot;, B_PATH_NAME_LENGTH);</a>
<a name="ln368"> </a>
<a name="ln369">		if (strlcat(pathBuffer, subPath, B_PATH_NAME_LENGTH)</a>
<a name="ln370">				&gt;= B_PATH_NAME_LENGTH) {</a>
<a name="ln371">			*fOriginalPathEnd = '\0';</a>
<a name="ln372">			errorOutput-&gt;PrintError(&quot;Path too long: \&quot;%s/%s\&quot;\n&quot;, pathBuffer,</a>
<a name="ln373">				subPath);</a>
<a name="ln374">			throw status_t(B_BUFFER_OVERFLOW);</a>
<a name="ln375">		}</a>
<a name="ln376">	}</a>
<a name="ln377"> </a>
<a name="ln378">	~SubPathAdder()</a>
<a name="ln379">	{</a>
<a name="ln380">		*fOriginalPathEnd = '\0';</a>
<a name="ln381">	}</a>
<a name="ln382"> </a>
<a name="ln383">private:</a>
<a name="ln384">	char* fOriginalPathEnd;</a>
<a name="ln385">};</a>
<a name="ln386"> </a>
<a name="ln387"> </a>
<a name="ln388">// #pragma mark - HeapAttributeOffsetter</a>
<a name="ln389"> </a>
<a name="ln390"> </a>
<a name="ln391">struct PackageWriterImpl::HeapAttributeOffsetter {</a>
<a name="ln392">	HeapAttributeOffsetter(const RangeArray&lt;uint64&gt;&amp; ranges,</a>
<a name="ln393">		const Array&lt;uint64&gt;&amp; deltas)</a>
<a name="ln394">		:</a>
<a name="ln395">		fRanges(ranges),</a>
<a name="ln396">		fDeltas(deltas)</a>
<a name="ln397">	{</a>
<a name="ln398">	}</a>
<a name="ln399"> </a>
<a name="ln400">	void ProcessAttribute(Attribute* attribute)</a>
<a name="ln401">	{</a>
<a name="ln402">		// If the attribute refers to a heap value, adjust it</a>
<a name="ln403">		AttributeValue&amp; value = attribute-&gt;value;</a>
<a name="ln404"> </a>
<a name="ln405">		if (value.type == B_HPKG_ATTRIBUTE_TYPE_RAW</a>
<a name="ln406">			&amp;&amp; value.encoding == B_HPKG_ATTRIBUTE_ENCODING_RAW_HEAP) {</a>
<a name="ln407">			uint64 delta = fDeltas[fRanges.InsertionIndex(value.data.offset)];</a>
<a name="ln408">			value.data.offset -= delta;</a>
<a name="ln409">		}</a>
<a name="ln410"> </a>
<a name="ln411">		// recurse</a>
<a name="ln412">		for (DoublyLinkedList&lt;Attribute&gt;::Iterator it</a>
<a name="ln413">					= attribute-&gt;children.GetIterator();</a>
<a name="ln414">				Attribute* child = it.Next();) {</a>
<a name="ln415">			ProcessAttribute(child);</a>
<a name="ln416">		}</a>
<a name="ln417">	}</a>
<a name="ln418"> </a>
<a name="ln419">private:</a>
<a name="ln420">	const RangeArray&lt;uint64&gt;&amp;	fRanges;</a>
<a name="ln421">	const Array&lt;uint64&gt;&amp;		fDeltas;</a>
<a name="ln422">};</a>
<a name="ln423"> </a>
<a name="ln424"> </a>
<a name="ln425">// #pragma mark - PackageWriterImpl (Inline Methods)</a>
<a name="ln426"> </a>
<a name="ln427"> </a>
<a name="ln428">template&lt;typename Type&gt;</a>
<a name="ln429">inline PackageWriterImpl::Attribute*</a>
<a name="ln430">PackageWriterImpl::_AddAttribute(BHPKGAttributeID attributeID, Type value)</a>
<a name="ln431">{</a>
<a name="ln432">	AttributeValue attributeValue;</a>
<a name="ln433">	attributeValue.SetTo(value);</a>
<a name="ln434">	return _AddAttribute(attributeID, attributeValue);</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437"> </a>
<a name="ln438">// #pragma mark - PackageWriterImpl</a>
<a name="ln439"> </a>
<a name="ln440"> </a>
<a name="ln441">PackageWriterImpl::PackageWriterImpl(BPackageWriterListener* listener)</a>
<a name="ln442">	:</a>
<a name="ln443">	inherited(&quot;package&quot;, listener),</a>
<a name="ln444">	fListener(listener),</a>
<a name="ln445">	fHeapRangesToRemove(NULL),</a>
<a name="ln446">	fRootEntry(NULL),</a>
<a name="ln447">	fRootAttribute(NULL),</a>
<a name="ln448">	fTopAttribute(NULL),</a>
<a name="ln449">	fCheckLicenses(true)</a>
<a name="ln450">{</a>
<a name="ln451">}</a>
<a name="ln452"> </a>
<a name="ln453"> </a>
<a name="ln454">PackageWriterImpl::~PackageWriterImpl()</a>
<a name="ln455">{</a>
<a name="ln456">	delete fHeapRangesToRemove;</a>
<a name="ln457">	delete fRootAttribute;</a>
<a name="ln458">	delete fRootEntry;</a>
<a name="ln459">}</a>
<a name="ln460"> </a>
<a name="ln461"> </a>
<a name="ln462">status_t</a>
<a name="ln463">PackageWriterImpl::Init(const char* fileName,</a>
<a name="ln464">	const BPackageWriterParameters&amp; parameters)</a>
<a name="ln465">{</a>
<a name="ln466">	try {</a>
<a name="ln467">		return _Init(NULL, false, fileName, parameters);</a>
<a name="ln468">	} catch (status_t error) {</a>
<a name="ln469">		return error;</a>
<a name="ln470">	} catch (std::bad_alloc&amp;) {</a>
<a name="ln471">		fListener-&gt;PrintError(&quot;Out of memory!\n&quot;);</a>
<a name="ln472">		return B_NO_MEMORY;</a>
<a name="ln473">	}</a>
<a name="ln474">}</a>
<a name="ln475"> </a>
<a name="ln476"> </a>
<a name="ln477">status_t</a>
<a name="ln478">PackageWriterImpl::Init(BPositionIO* file, bool keepFile,</a>
<a name="ln479">	const BPackageWriterParameters&amp; parameters)</a>
<a name="ln480">{</a>
<a name="ln481">	try {</a>
<a name="ln482">		return _Init(file, keepFile, NULL, parameters);</a>
<a name="ln483">	} catch (status_t error) {</a>
<a name="ln484">		return error;</a>
<a name="ln485">	} catch (std::bad_alloc&amp;) {</a>
<a name="ln486">		fListener-&gt;PrintError(&quot;Out of memory!\n&quot;);</a>
<a name="ln487">		return B_NO_MEMORY;</a>
<a name="ln488">	}</a>
<a name="ln489">}</a>
<a name="ln490"> </a>
<a name="ln491"> </a>
<a name="ln492">status_t</a>
<a name="ln493">PackageWriterImpl::SetInstallPath(const char* installPath)</a>
<a name="ln494">{</a>
<a name="ln495">	fInstallPath = installPath;</a>
<a name="ln496">	return installPath == NULL</a>
<a name="ln497">		|| (size_t)fInstallPath.Length() == strlen(installPath)</a>
<a name="ln498">		? B_OK : B_NO_MEMORY;</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501"> </a>
<a name="ln502">void</a>
<a name="ln503">PackageWriterImpl::SetCheckLicenses(bool checkLicenses)</a>
<a name="ln504">{</a>
<a name="ln505">	fCheckLicenses = checkLicenses;</a>
<a name="ln506">}</a>
<a name="ln507"> </a>
<a name="ln508"> </a>
<a name="ln509">status_t</a>
<a name="ln510">PackageWriterImpl::AddEntry(const char* fileName, int fd)</a>
<a name="ln511">{</a>
<a name="ln512">	try {</a>
<a name="ln513">		// if it's &quot;.PackageInfo&quot;, parse it</a>
<a name="ln514">		if (strcmp(fileName, B_HPKG_PACKAGE_INFO_FILE_NAME) == 0) {</a>
<a name="ln515">			struct ErrorListener : public BPackageInfo::ParseErrorListener {</a>
<a name="ln516">				ErrorListener(BPackageWriterListener* _listener)</a>
<a name="ln517">					:</a>
<a name="ln518">					listener(_listener),</a>
<a name="ln519">					errorSeen(false)</a>
<a name="ln520">				{</a>
<a name="ln521">				}</a>
<a name="ln522"> </a>
<a name="ln523">				virtual void OnError(const BString&amp; msg, int line, int col) {</a>
<a name="ln524">					listener-&gt;PrintError(&quot;Parse error in %s(%d:%d) -&gt; %s\n&quot;,</a>
<a name="ln525">						B_HPKG_PACKAGE_INFO_FILE_NAME, line, col, msg.String());</a>
<a name="ln526">					errorSeen = true;</a>
<a name="ln527">				}</a>
<a name="ln528"> </a>
<a name="ln529">				BPackageWriterListener* listener;</a>
<a name="ln530">				bool errorSeen;</a>
<a name="ln531">			} errorListener(fListener);</a>
<a name="ln532"> </a>
<a name="ln533">			if (fd &gt;= 0) {</a>
<a name="ln534">				// a file descriptor is given -- read the config from there</a>
<a name="ln535">				// stat the file to get the file size</a>
<a name="ln536">				struct stat st;</a>
<a name="ln537">				if (fstat(fd, &amp;st) != 0)</a>
<a name="ln538">					return errno;</a>
<a name="ln539"> </a>
<a name="ln540">				BString packageInfoString;</a>
<a name="ln541">				char* buffer = packageInfoString.LockBuffer(st.st_size);</a>
<a name="ln542">				if (buffer == NULL)</a>
<a name="ln543">					return B_NO_MEMORY;</a>
<a name="ln544"> </a>
<a name="ln545">				ssize_t result = read_pos(fd, 0, buffer, st.st_size);</a>
<a name="ln546">				if (result &lt; 0) {</a>
<a name="ln547">					packageInfoString.UnlockBuffer(0);</a>
<a name="ln548">					return errno;</a>
<a name="ln549">				}</a>
<a name="ln550"> </a>
<a name="ln551">				buffer[st.st_size] = '\0';</a>
<a name="ln552">				packageInfoString.UnlockBuffer(st.st_size);</a>
<a name="ln553"> </a>
<a name="ln554">				result = fPackageInfo.ReadFromConfigString(packageInfoString,</a>
<a name="ln555">					&amp;errorListener);</a>
<a name="ln556">				if (result != B_OK)</a>
<a name="ln557">					return result;</a>
<a name="ln558">			} else {</a>
<a name="ln559">				// use the file name</a>
<a name="ln560">				BEntry packageInfoEntry(fileName);</a>
<a name="ln561">				status_t result = fPackageInfo.ReadFromConfigFile(</a>
<a name="ln562">					packageInfoEntry, &amp;errorListener);</a>
<a name="ln563">				if (result != B_OK</a>
<a name="ln564">					|| (result = fPackageInfo.InitCheck()) != B_OK) {</a>
<a name="ln565">					if (!errorListener.errorSeen) {</a>
<a name="ln566">						fListener-&gt;PrintError(&quot;Failed to read %s: %s\n&quot;,</a>
<a name="ln567">							fileName, strerror(result));</a>
<a name="ln568">					}</a>
<a name="ln569">					return result;</a>
<a name="ln570">				}</a>
<a name="ln571">			}</a>
<a name="ln572">		}</a>
<a name="ln573"> </a>
<a name="ln574">		return _RegisterEntry(fileName, fd);</a>
<a name="ln575">	} catch (status_t error) {</a>
<a name="ln576">		return error;</a>
<a name="ln577">	} catch (std::bad_alloc&amp;) {</a>
<a name="ln578">		fListener-&gt;PrintError(&quot;Out of memory!\n&quot;);</a>
<a name="ln579">		return B_NO_MEMORY;</a>
<a name="ln580">	}</a>
<a name="ln581">}</a>
<a name="ln582"> </a>
<a name="ln583"> </a>
<a name="ln584">status_t</a>
<a name="ln585">PackageWriterImpl::Finish()</a>
<a name="ln586">{</a>
<a name="ln587">	try {</a>
<a name="ln588">		if ((Flags() &amp; B_HPKG_WRITER_UPDATE_PACKAGE) != 0) {</a>
<a name="ln589">			_UpdateCheckEntryCollisions();</a>
<a name="ln590"> </a>
<a name="ln591">			if (fPackageInfo.InitCheck() != B_OK)</a>
<a name="ln592">				_UpdateReadPackageInfo();</a>
<a name="ln593">		}</a>
<a name="ln594"> </a>
<a name="ln595">		if (fPackageInfo.InitCheck() != B_OK) {</a>
<a name="ln596">			fListener-&gt;PrintError(&quot;No package-info file found (%s)!\n&quot;,</a>
<a name="ln597">				B_HPKG_PACKAGE_INFO_FILE_NAME);</a>
<a name="ln598">			return B_BAD_DATA;</a>
<a name="ln599">		}</a>
<a name="ln600"> </a>
<a name="ln601">		fPackageInfo.SetInstallPath(fInstallPath);</a>
<a name="ln602"> </a>
<a name="ln603">		RegisterPackageInfo(PackageAttributes(), fPackageInfo);</a>
<a name="ln604"> </a>
<a name="ln605">		if (fCheckLicenses) {</a>
<a name="ln606">			status_t result = _CheckLicenses();</a>
<a name="ln607">			if (result != B_OK)</a>
<a name="ln608">				return result;</a>
<a name="ln609">		}</a>
<a name="ln610"> </a>
<a name="ln611">		if ((Flags() &amp; B_HPKG_WRITER_UPDATE_PACKAGE) != 0)</a>
<a name="ln612">			_CompactHeap();</a>
<a name="ln613"> </a>
<a name="ln614">		return _Finish();</a>
<a name="ln615">	} catch (status_t error) {</a>
<a name="ln616">		return error;</a>
<a name="ln617">	} catch (std::bad_alloc&amp;) {</a>
<a name="ln618">		fListener-&gt;PrintError(&quot;Out of memory!\n&quot;);</a>
<a name="ln619">		return B_NO_MEMORY;</a>
<a name="ln620">	}</a>
<a name="ln621">}</a>
<a name="ln622"> </a>
<a name="ln623"> </a>
<a name="ln624">status_t</a>
<a name="ln625">PackageWriterImpl::Recompress(BPositionIO* inputFile)</a>
<a name="ln626">{</a>
<a name="ln627">	if (inputFile == NULL)</a>
<a name="ln628">		return B_BAD_VALUE;</a>
<a name="ln629"> </a>
<a name="ln630">	try {</a>
<a name="ln631">		return _Recompress(inputFile);</a>
<a name="ln632">	} catch (status_t error) {</a>
<a name="ln633">		return error;</a>
<a name="ln634">	} catch (std::bad_alloc&amp;) {</a>
<a name="ln635">		fListener-&gt;PrintError(&quot;Out of memory!\n&quot;);</a>
<a name="ln636">		return B_NO_MEMORY;</a>
<a name="ln637">	}</a>
<a name="ln638">}</a>
<a name="ln639"> </a>
<a name="ln640"> </a>
<a name="ln641">status_t</a>
<a name="ln642">PackageWriterImpl::_Init(BPositionIO* file, bool keepFile, const char* fileName,</a>
<a name="ln643">	const BPackageWriterParameters&amp; parameters)</a>
<a name="ln644">{</a>
<a name="ln645">	status_t result = inherited::Init(file, keepFile, fileName, parameters);</a>
<a name="ln646">	if (result != B_OK)</a>
<a name="ln647">		return result;</a>
<a name="ln648"> </a>
<a name="ln649">	if (fStringCache.Init() != B_OK)</a>
<a name="ln650">		throw std::bad_alloc();</a>
<a name="ln651"> </a>
<a name="ln652">	// create entry list</a>
<a name="ln653">	fRootEntry = new Entry(NULL, 0, -1, true);</a>
<a name="ln654"> </a>
<a name="ln655">	fRootAttribute = new Attribute();</a>
<a name="ln656"> </a>
<a name="ln657">	fHeapOffset = fHeaderSize = sizeof(hpkg_header);</a>
<a name="ln658">	fTopAttribute = fRootAttribute;</a>
<a name="ln659"> </a>
<a name="ln660">	fHeapRangesToRemove = new RangeArray&lt;uint64&gt;;</a>
<a name="ln661"> </a>
<a name="ln662">	// in update mode, parse the TOC</a>
<a name="ln663">	if ((Flags() &amp; B_HPKG_WRITER_UPDATE_PACKAGE) != 0) {</a>
<a name="ln664">		PackageReaderImpl packageReader(fListener);</a>
<a name="ln665">		hpkg_header header;</a>
<a name="ln666">		result = packageReader.Init(File(), false, 0, &amp;header);</a>
<a name="ln667">		if (result != B_OK)</a>
<a name="ln668">			return result;</a>
<a name="ln669"> </a>
<a name="ln670">		fHeapOffset = packageReader.HeapOffset();</a>
<a name="ln671"> </a>
<a name="ln672">		PackageContentHandler handler(fRootAttribute, fListener, fStringCache);</a>
<a name="ln673"> </a>
<a name="ln674">		result = packageReader.ParseContent(&amp;handler);</a>
<a name="ln675">		if (result != B_OK)</a>
<a name="ln676">			return result;</a>
<a name="ln677"> </a>
<a name="ln678">		// While the compression level can change, we have to reuse the</a>
<a name="ln679">		// compression algorithm at least.</a>
<a name="ln680">		SetCompression(B_BENDIAN_TO_HOST_INT16(header.heap_compression));</a>
<a name="ln681"> </a>
<a name="ln682">		result = InitHeapReader(fHeapOffset);</a>
<a name="ln683">		if (result != B_OK)</a>
<a name="ln684">			return result;</a>
<a name="ln685"> </a>
<a name="ln686">		fHeapWriter-&gt;Reinit(packageReader.RawHeapReader());</a>
<a name="ln687"> </a>
<a name="ln688">		// Remove the old packages attributes and TOC section from the heap.</a>
<a name="ln689">		// We'll write new ones later.</a>
<a name="ln690">		const PackageFileSection&amp; attributesSection</a>
<a name="ln691">			= packageReader.PackageAttributesSection();</a>
<a name="ln692">		const PackageFileSection&amp; tocSection = packageReader.TOCSection();</a>
<a name="ln693">		if (!fHeapRangesToRemove-&gt;AddRange(attributesSection.offset,</a>
<a name="ln694">				attributesSection.uncompressedLength)</a>
<a name="ln695">		   || !fHeapRangesToRemove-&gt;AddRange(tocSection.offset,</a>
<a name="ln696">				tocSection.uncompressedLength)) {</a>
<a name="ln697">			throw std::bad_alloc();</a>
<a name="ln698">		}</a>
<a name="ln699">	} else {</a>
<a name="ln700">		result = InitHeapReader(fHeapOffset);</a>
<a name="ln701">		if (result != B_OK)</a>
<a name="ln702">			return result;</a>
<a name="ln703">	}</a>
<a name="ln704"> </a>
<a name="ln705">	return B_OK;</a>
<a name="ln706">}</a>
<a name="ln707"> </a>
<a name="ln708"> </a>
<a name="ln709">status_t</a>
<a name="ln710">PackageWriterImpl::_Finish()</a>
<a name="ln711">{</a>
<a name="ln712">	// write entries</a>
<a name="ln713">	for (EntryList::ConstIterator it = fRootEntry-&gt;ChildIterator();</a>
<a name="ln714">			Entry* entry = it.Next();) {</a>
<a name="ln715">		char pathBuffer[B_PATH_NAME_LENGTH];</a>
<a name="ln716">		pathBuffer[0] = '\0';</a>
<a name="ln717">		_AddEntry(AT_FDCWD, entry, entry-&gt;Name(), pathBuffer);</a>
<a name="ln718">	}</a>
<a name="ln719"> </a>
<a name="ln720">	hpkg_header header;</a>
<a name="ln721"> </a>
<a name="ln722">	// write the TOC and package attributes</a>
<a name="ln723">	uint64 tocLength;</a>
<a name="ln724">	_WriteTOC(header, tocLength);</a>
<a name="ln725"> </a>
<a name="ln726">	uint64 attributesLength;</a>
<a name="ln727">	_WritePackageAttributes(header, attributesLength);</a>
<a name="ln728"> </a>
<a name="ln729">	// flush the heap</a>
<a name="ln730">	status_t error = fHeapWriter-&gt;Finish();</a>
<a name="ln731">	if (error != B_OK)</a>
<a name="ln732">		return error;</a>
<a name="ln733"> </a>
<a name="ln734">	uint64 compressedHeapSize = fHeapWriter-&gt;CompressedHeapSize();</a>
<a name="ln735"> </a>
<a name="ln736">	header.heap_compression = B_HOST_TO_BENDIAN_INT16(</a>
<a name="ln737">		Parameters().Compression());</a>
<a name="ln738">	header.heap_chunk_size = B_HOST_TO_BENDIAN_INT32(fHeapWriter-&gt;ChunkSize());</a>
<a name="ln739">	header.heap_size_compressed = B_HOST_TO_BENDIAN_INT64(compressedHeapSize);</a>
<a name="ln740">	header.heap_size_uncompressed = B_HOST_TO_BENDIAN_INT64(</a>
<a name="ln741">		fHeapWriter-&gt;UncompressedHeapSize());</a>
<a name="ln742"> </a>
<a name="ln743">	// Truncate the file to the size it is supposed to have. In update mode, it</a>
<a name="ln744">	// can be greater when one or more files are shrunk. In creation mode it</a>
<a name="ln745">	// should already have the correct size.</a>
<a name="ln746">	off_t totalSize = fHeapWriter-&gt;HeapOffset() + (off_t)compressedHeapSize;</a>
<a name="ln747">	error = File()-&gt;SetSize(totalSize);</a>
<a name="ln748">	if (error != B_OK) {</a>
<a name="ln749">		fListener-&gt;PrintError(&quot;Failed to truncate package file to new &quot;</a>
<a name="ln750">			&quot;size: %s\n&quot;, strerror(errno));</a>
<a name="ln751">		return errno;</a>
<a name="ln752">	}</a>
<a name="ln753"> </a>
<a name="ln754">	fListener-&gt;OnPackageSizeInfo(fHeaderSize, compressedHeapSize, tocLength,</a>
<a name="ln755">		attributesLength, totalSize);</a>
<a name="ln756"> </a>
<a name="ln757">	// prepare the header</a>
<a name="ln758"> </a>
<a name="ln759">	// general</a>
<a name="ln760">	header.magic = B_HOST_TO_BENDIAN_INT32(B_HPKG_MAGIC);</a>
<a name="ln761">	header.header_size = B_HOST_TO_BENDIAN_INT16(fHeaderSize);</a>
<a name="ln762">	header.version = B_HOST_TO_BENDIAN_INT16(B_HPKG_VERSION);</a>
<a name="ln763">	header.total_size = B_HOST_TO_BENDIAN_INT64(totalSize);</a>
<a name="ln764">	header.minor_version = B_HOST_TO_BENDIAN_INT16(B_HPKG_MINOR_VERSION);</a>
<a name="ln765"> </a>
<a name="ln766">	// write the header</a>
<a name="ln767">	RawWriteBuffer(&amp;header, sizeof(hpkg_header), 0);</a>
<a name="ln768"> </a>
<a name="ln769">	SetFinished(true);</a>
<a name="ln770">	return B_OK;</a>
<a name="ln771">}</a>
<a name="ln772"> </a>
<a name="ln773"> </a>
<a name="ln774">status_t</a>
<a name="ln775">PackageWriterImpl::_Recompress(BPositionIO* inputFile)</a>
<a name="ln776">{</a>
<a name="ln777">	if (inputFile == NULL)</a>
<a name="ln778">		return B_BAD_VALUE;</a>
<a name="ln779"> </a>
<a name="ln780">	// create a package reader for the input file</a>
<a name="ln781">	PackageReaderImpl reader(fListener);</a>
<a name="ln782">	hpkg_header header;</a>
<a name="ln783">	status_t error = reader.Init(inputFile, false, 0, &amp;header);</a>
<a name="ln784">	if (error != B_OK) {</a>
<a name="ln785">		fListener-&gt;PrintError(&quot;Failed to open hpkg file: %s\n&quot;,</a>
<a name="ln786">			strerror(error));</a>
<a name="ln787">		return error;</a>
<a name="ln788">	}</a>
<a name="ln789"> </a>
<a name="ln790">	// Update some header fields, assuming no compression. We'll rewrite the</a>
<a name="ln791">	// header later, should compression have been used. Doing it this way allows</a>
<a name="ln792">	// for streaming an uncompressed package.</a>
<a name="ln793">	uint64 uncompressedHeapSize</a>
<a name="ln794">		= reader.RawHeapReader()-&gt;UncompressedHeapSize();</a>
<a name="ln795">	uint64 compressedHeapSize = uncompressedHeapSize;</a>
<a name="ln796"> </a>
<a name="ln797">	off_t totalSize = fHeapWriter-&gt;HeapOffset() + (off_t)compressedHeapSize;</a>
<a name="ln798"> </a>
<a name="ln799">	header.heap_compression = B_HOST_TO_BENDIAN_INT16(</a>
<a name="ln800">		Parameters().Compression());</a>
<a name="ln801">	header.heap_chunk_size = B_HOST_TO_BENDIAN_INT32(fHeapWriter-&gt;ChunkSize());</a>
<a name="ln802">	header.heap_size_uncompressed</a>
<a name="ln803">		= B_HOST_TO_BENDIAN_INT64(uncompressedHeapSize);</a>
<a name="ln804"> </a>
<a name="ln805">	if (Parameters().Compression() == B_HPKG_COMPRESSION_NONE) {</a>
<a name="ln806">		header.heap_size_compressed</a>
<a name="ln807">			= B_HOST_TO_BENDIAN_INT64(compressedHeapSize);</a>
<a name="ln808">		header.total_size = B_HOST_TO_BENDIAN_INT64(totalSize);</a>
<a name="ln809"> </a>
<a name="ln810">		// write the header</a>
<a name="ln811">		RawWriteBuffer(&amp;header, sizeof(hpkg_header), 0);</a>
<a name="ln812">	}</a>
<a name="ln813"> </a>
<a name="ln814">	// copy the heap data</a>
<a name="ln815">	uint64 bytesCompressed;</a>
<a name="ln816">	error = fHeapWriter-&gt;AddData(*reader.RawHeapReader(), uncompressedHeapSize,</a>
<a name="ln817">		bytesCompressed);</a>
<a name="ln818">	if (error != B_OK)</a>
<a name="ln819">		return error;</a>
<a name="ln820"> </a>
<a name="ln821">	// flush the heap</a>
<a name="ln822">	error = fHeapWriter-&gt;Finish();</a>
<a name="ln823">	if (error != B_OK)</a>
<a name="ln824">		return error;</a>
<a name="ln825"> </a>
<a name="ln826">	// If compression is enabled, update and write the header.</a>
<a name="ln827">	if (Parameters().Compression() != B_HPKG_COMPRESSION_NONE) {</a>
<a name="ln828">		compressedHeapSize = fHeapWriter-&gt;CompressedHeapSize();</a>
<a name="ln829">		totalSize = fHeapWriter-&gt;HeapOffset() + (off_t)compressedHeapSize;</a>
<a name="ln830">		header.heap_size_compressed = B_HOST_TO_BENDIAN_INT64(compressedHeapSize);</a>
<a name="ln831">		header.total_size = B_HOST_TO_BENDIAN_INT64(totalSize);</a>
<a name="ln832"> </a>
<a name="ln833">		// write the header</a>
<a name="ln834">		RawWriteBuffer(&amp;header, sizeof(hpkg_header), 0);</a>
<a name="ln835">	}</a>
<a name="ln836"> </a>
<a name="ln837">	SetFinished(true);</a>
<a name="ln838">	return B_OK;</a>
<a name="ln839">}</a>
<a name="ln840"> </a>
<a name="ln841"> </a>
<a name="ln842">status_t</a>
<a name="ln843">PackageWriterImpl::_CheckLicenses()</a>
<a name="ln844">{</a>
<a name="ln845">	BPath systemLicensePath;</a>
<a name="ln846">	status_t result</a>
<a name="ln847">#ifdef HAIKU_TARGET_PLATFORM_HAIKU</a>
<a name="ln848">		= find_directory(B_SYSTEM_DATA_DIRECTORY, &amp;systemLicensePath);</a>
<a name="ln849">#else</a>
<a name="ln850">		= systemLicensePath.SetTo(HAIKU_BUILD_SYSTEM_DATA_DIRECTORY);</a>
<a name="ln851">#endif</a>
<a name="ln852">	if (result != B_OK) {</a>
<a name="ln853">		fListener-&gt;PrintError(&quot;unable to find system data path: %s!\n&quot;,</a>
<a name="ln854">			strerror(result));</a>
<a name="ln855">		return result;</a>
<a name="ln856">	}</a>
<a name="ln857">	if ((result = systemLicensePath.Append(&quot;licenses&quot;)) != B_OK) {</a>
<a name="ln858">		fListener-&gt;PrintError(&quot;unable to append to system data path!\n&quot;);</a>
<a name="ln859">		return result;</a>
<a name="ln860">	}</a>
<a name="ln861"> </a>
<a name="ln862">	BDirectory systemLicenseDir(systemLicensePath.Path());</a>
<a name="ln863"> </a>
<a name="ln864">	const BStringList&amp; licenseList = fPackageInfo.LicenseList();</a>
<a name="ln865">	for (int i = 0; i &lt; licenseList.CountStrings(); ++i) {</a>
<a name="ln866">		const BString&amp; licenseName = licenseList.StringAt(i);</a>
<a name="ln867">		if (licenseName == kPublicDomainLicenseName)</a>
<a name="ln868">			continue;</a>
<a name="ln869"> </a>
<a name="ln870">		BEntry license;</a>
<a name="ln871">		if (systemLicenseDir.FindEntry(licenseName.String(), &amp;license) == B_OK)</a>
<a name="ln872">			continue;</a>
<a name="ln873"> </a>
<a name="ln874">		// license is not a system license, so it must be contained in package</a>
<a name="ln875">		BString licensePath(&quot;data/licenses/&quot;);</a>
<a name="ln876">		licensePath &lt;&lt; licenseName;</a>
<a name="ln877"> </a>
<a name="ln878">		if (!_IsEntryInPackage(licensePath)) {</a>
<a name="ln879">			fListener-&gt;PrintError(&quot;License '%s' isn't contained in package!\n&quot;,</a>
<a name="ln880">				licenseName.String());</a>
<a name="ln881">			return B_BAD_DATA;</a>
<a name="ln882">		}</a>
<a name="ln883">	}</a>
<a name="ln884"> </a>
<a name="ln885">	return B_OK;</a>
<a name="ln886">}</a>
<a name="ln887"> </a>
<a name="ln888"> </a>
<a name="ln889">bool</a>
<a name="ln890">PackageWriterImpl::_IsEntryInPackage(const char* fileName)</a>
<a name="ln891">{</a>
<a name="ln892">	const char* originalFileName = fileName;</a>
<a name="ln893"> </a>
<a name="ln894">	// find the closest ancestor of the entry that is in the added entries</a>
<a name="ln895">	bool added = false;</a>
<a name="ln896">	Entry* entry = fRootEntry;</a>
<a name="ln897">	while (entry != NULL) {</a>
<a name="ln898">		if (!entry-&gt;IsImplicit()) {</a>
<a name="ln899">			added = true;</a>
<a name="ln900">			break;</a>
<a name="ln901">		}</a>
<a name="ln902"> </a>
<a name="ln903">		if (*fileName == '\0')</a>
<a name="ln904">			break;</a>
<a name="ln905"> </a>
<a name="ln906">		const char* nextSlash = strchr(fileName, '/');</a>
<a name="ln907"> </a>
<a name="ln908">		if (nextSlash == NULL) {</a>
<a name="ln909">			// no slash, just the file name</a>
<a name="ln910">			size_t length = strlen(fileName);</a>
<a name="ln911">			entry  = entry-&gt;GetChild(fileName, length);</a>
<a name="ln912">			fileName += length;</a>
<a name="ln913">			continue;</a>
<a name="ln914">		}</a>
<a name="ln915"> </a>
<a name="ln916">		// find the start of the next component, skipping slashes</a>
<a name="ln917">		const char* nextComponent = nextSlash + 1;</a>
<a name="ln918">		while (*nextComponent == '/')</a>
<a name="ln919">			nextComponent++;</a>
<a name="ln920"> </a>
<a name="ln921">		entry = entry-&gt;GetChild(fileName, nextSlash - fileName);</a>
<a name="ln922"> </a>
<a name="ln923">		fileName = nextComponent;</a>
<a name="ln924">	}</a>
<a name="ln925"> </a>
<a name="ln926">	if (added) {</a>
<a name="ln927">		// the entry itself or one of its ancestors has been added to the</a>
<a name="ln928">		// package explicitly -- stat it, to see, if it exists</a>
<a name="ln929">		struct stat st;</a>
<a name="ln930">		if (entry-&gt;FD() &gt;= 0) {</a>
<a name="ln931">			if (fstatat(entry-&gt;FD(), *fileName != '\0' ? fileName : NULL, &amp;st,</a>
<a name="ln932">					AT_SYMLINK_NOFOLLOW) == 0) {</a>
<a name="ln933">				return true;</a>
<a name="ln934">			}</a>
<a name="ln935">		} else {</a>
<a name="ln936">			if (lstat(originalFileName, &amp;st) == 0)</a>
<a name="ln937">				return true;</a>
<a name="ln938">		}</a>
<a name="ln939">	}</a>
<a name="ln940"> </a>
<a name="ln941">	// In update mode the entry might already be in the package.</a>
<a name="ln942">	Attribute* attribute = fRootAttribute;</a>
<a name="ln943">	fileName = originalFileName;</a>
<a name="ln944"> </a>
<a name="ln945">	while (attribute != NULL) {</a>
<a name="ln946">		if (*fileName == '\0')</a>
<a name="ln947">			return true;</a>
<a name="ln948"> </a>
<a name="ln949">		const char* nextSlash = strchr(fileName, '/');</a>
<a name="ln950"> </a>
<a name="ln951">		if (nextSlash == NULL) {</a>
<a name="ln952">			// no slash, just the file name</a>
<a name="ln953">			return attribute-&gt;FindEntryChild(fileName) != NULL;</a>
<a name="ln954">		}</a>
<a name="ln955"> </a>
<a name="ln956">		// find the start of the next component, skipping slashes</a>
<a name="ln957">		const char* nextComponent = nextSlash + 1;</a>
<a name="ln958">		while (*nextComponent == '/')</a>
<a name="ln959">			nextComponent++;</a>
<a name="ln960"> </a>
<a name="ln961">		attribute = attribute-&gt;FindEntryChild(fileName, nextSlash - fileName);</a>
<a name="ln962"> </a>
<a name="ln963">		fileName = nextComponent;</a>
<a name="ln964">	}</a>
<a name="ln965"> </a>
<a name="ln966">	return false;</a>
<a name="ln967">}</a>
<a name="ln968"> </a>
<a name="ln969"> </a>
<a name="ln970">void</a>
<a name="ln971">PackageWriterImpl::_UpdateReadPackageInfo()</a>
<a name="ln972">{</a>
<a name="ln973">	// get the .PackageInfo entry attribute</a>
<a name="ln974">	Attribute* attribute = fRootAttribute-&gt;FindEntryChild(</a>
<a name="ln975">		B_HPKG_PACKAGE_INFO_FILE_NAME);</a>
<a name="ln976">	if (attribute == NULL) {</a>
<a name="ln977">		fListener-&gt;PrintError(&quot;No %s in package file.\n&quot;,</a>
<a name="ln978">			B_HPKG_PACKAGE_INFO_FILE_NAME);</a>
<a name="ln979">		throw status_t(B_BAD_DATA);</a>
<a name="ln980">	}</a>
<a name="ln981"> </a>
<a name="ln982">	// get the data attribute</a>
<a name="ln983">	Attribute* dataAttribute = attribute-&gt;ChildWithID(B_HPKG_ATTRIBUTE_ID_DATA);</a>
<a name="ln984">	if (dataAttribute == NULL)  {</a>
<a name="ln985">		fListener-&gt;PrintError(&quot;%s entry in package file doesn't have data.\n&quot;,</a>
<a name="ln986">			B_HPKG_PACKAGE_INFO_FILE_NAME);</a>
<a name="ln987">		throw status_t(B_BAD_DATA);</a>
<a name="ln988">	}</a>
<a name="ln989"> </a>
<a name="ln990">	AttributeValue&amp; value = dataAttribute-&gt;value;</a>
<a name="ln991">	if (value.type != B_HPKG_ATTRIBUTE_TYPE_RAW) {</a>
<a name="ln992">		fListener-&gt;PrintError(&quot;%s entry in package file has an invalid data &quot;</a>
<a name="ln993">			&quot;attribute (not of type raw).\n&quot;, B_HPKG_PACKAGE_INFO_FILE_NAME);</a>
<a name="ln994">		throw status_t(B_BAD_DATA);</a>
<a name="ln995">	}</a>
<a name="ln996"> </a>
<a name="ln997">	BPackageData data;</a>
<a name="ln998">	if (value.encoding == B_HPKG_ATTRIBUTE_ENCODING_RAW_INLINE)</a>
<a name="ln999">		data.SetData(value.data.size, value.data.raw);</a>
<a name="ln1000">	else</a>
<a name="ln1001">		data.SetData(value.data.size, value.data.offset);</a>
<a name="ln1002"> </a>
<a name="ln1003">	// read the value into a string</a>
<a name="ln1004">	BString valueString;</a>
<a name="ln1005">	char* valueBuffer = valueString.LockBuffer(value.data.size);</a>
<a name="ln1006">	if (valueBuffer == NULL)</a>
<a name="ln1007">		throw std::bad_alloc();</a>
<a name="ln1008"> </a>
<a name="ln1009">	if (value.encoding == B_HPKG_ATTRIBUTE_ENCODING_RAW_INLINE) {</a>
<a name="ln1010">		// data encoded inline -- just copy to buffer</a>
<a name="ln1011">		memcpy(valueBuffer, value.data.raw, value.data.size);</a>
<a name="ln1012">	} else {</a>
<a name="ln1013">		// data on heap -- read from there</a>
<a name="ln1014">		status_t error = fHeapWriter-&gt;ReadData(data.Offset(), valueBuffer,</a>
<a name="ln1015">			data.Size());</a>
<a name="ln1016">		if (error != B_OK)</a>
<a name="ln1017">			throw error;</a>
<a name="ln1018">	}</a>
<a name="ln1019"> </a>
<a name="ln1020">	valueString.UnlockBuffer();</a>
<a name="ln1021"> </a>
<a name="ln1022">	// parse the package info</a>
<a name="ln1023">	status_t error = fPackageInfo.ReadFromConfigString(valueString);</a>
<a name="ln1024">	if (error != B_OK) {</a>
<a name="ln1025">		fListener-&gt;PrintError(&quot;Failed to parse package info data from package &quot;</a>
<a name="ln1026">			&quot;file: %s\n&quot;, strerror(error));</a>
<a name="ln1027">		throw status_t(error);</a>
<a name="ln1028">	}</a>
<a name="ln1029">}</a>
<a name="ln1030"> </a>
<a name="ln1031"> </a>
<a name="ln1032">void</a>
<a name="ln1033">PackageWriterImpl::_UpdateCheckEntryCollisions()</a>
<a name="ln1034">{</a>
<a name="ln1035">	for (EntryList::ConstIterator it = fRootEntry-&gt;ChildIterator();</a>
<a name="ln1036">			Entry* entry = it.Next();) {</a>
<a name="ln1037">		char pathBuffer[B_PATH_NAME_LENGTH];</a>
<a name="ln1038">		pathBuffer[0] = '\0';</a>
<a name="ln1039">		_UpdateCheckEntryCollisions(fRootAttribute, AT_FDCWD, entry,</a>
<a name="ln1040">			entry-&gt;Name(), pathBuffer);</a>
<a name="ln1041">	}</a>
<a name="ln1042">}</a>
<a name="ln1043"> </a>
<a name="ln1044"> </a>
<a name="ln1045">void</a>
<a name="ln1046">PackageWriterImpl::_UpdateCheckEntryCollisions(Attribute* parentAttribute,</a>
<a name="ln1047">	int dirFD, Entry* entry, const char* fileName, char* pathBuffer)</a>
<a name="ln1048">{</a>
<a name="ln1049">	bool isImplicitEntry = entry != NULL &amp;&amp; entry-&gt;IsImplicit();</a>
<a name="ln1050"> </a>
<a name="ln1051">	SubPathAdder pathAdder(fListener, pathBuffer, fileName);</a>
<a name="ln1052"> </a>
<a name="ln1053">	// Check whether there's an entry attribute for this entry. If not, we can</a>
<a name="ln1054">	// ignore this entry.</a>
<a name="ln1055">	Attribute* entryAttribute = parentAttribute-&gt;FindEntryChild(fileName);</a>
<a name="ln1056">	if (entryAttribute == NULL)</a>
<a name="ln1057">		return;</a>
<a name="ln1058"> </a>
<a name="ln1059">	// open the node</a>
<a name="ln1060">	int fd;</a>
<a name="ln1061">	FileDescriptorCloser fdCloser;</a>
<a name="ln1062"> </a>
<a name="ln1063">	if (entry != NULL &amp;&amp; entry-&gt;FD() &gt;= 0) {</a>
<a name="ln1064">		// a file descriptor is already given -- use that</a>
<a name="ln1065">		fd = entry-&gt;FD();</a>
<a name="ln1066">	} else {</a>
<a name="ln1067">		fd = openat(dirFD, fileName,</a>
<a name="ln1068">			O_RDONLY | (isImplicitEntry ? 0 : O_NOTRAVERSE));</a>
<a name="ln1069">		if (fd &lt; 0) {</a>
<a name="ln1070">			fListener-&gt;PrintError(&quot;Failed to open entry \&quot;%s\&quot;: %s\n&quot;,</a>
<a name="ln1071">				pathBuffer, strerror(errno));</a>
<a name="ln1072">			throw status_t(errno);</a>
<a name="ln1073">		}</a>
<a name="ln1074">		fdCloser.SetTo(fd);</a>
<a name="ln1075">	}</a>
<a name="ln1076"> </a>
<a name="ln1077">	// stat the node</a>
<a name="ln1078">	struct stat st;</a>
<a name="ln1079">	if (fstat(fd, &amp;st) &lt; 0) {</a>
<a name="ln1080">		fListener-&gt;PrintError(&quot;Failed to fstat() file \&quot;%s\&quot;: %s\n&quot;, pathBuffer,</a>
<a name="ln1081">			strerror(errno));</a>
<a name="ln1082">		throw status_t(errno);</a>
<a name="ln1083">	}</a>
<a name="ln1084"> </a>
<a name="ln1085">	// implicit entries must be directories</a>
<a name="ln1086">	if (isImplicitEntry &amp;&amp; !S_ISDIR(st.st_mode)) {</a>
<a name="ln1087">		fListener-&gt;PrintError(&quot;Non-leaf path component \&quot;%s\&quot; is not a &quot;</a>
<a name="ln1088">			&quot;directory.\n&quot;, pathBuffer);</a>
<a name="ln1089">		throw status_t(B_BAD_VALUE);</a>
<a name="ln1090">	}</a>
<a name="ln1091"> </a>
<a name="ln1092">	// get the pre-existing node's file type</a>
<a name="ln1093">	uint32 preExistingFileType = B_HPKG_DEFAULT_FILE_TYPE;</a>
<a name="ln1094">	if (Attribute* fileTypeAttribute</a>
<a name="ln1095">			= entryAttribute-&gt;ChildWithID(B_HPKG_ATTRIBUTE_ID_FILE_TYPE)) {</a>
<a name="ln1096">		if (fileTypeAttribute-&gt;value.type == B_HPKG_ATTRIBUTE_TYPE_UINT)</a>
<a name="ln1097">			preExistingFileType = fileTypeAttribute-&gt;value.unsignedInt;</a>
<a name="ln1098">	}</a>
<a name="ln1099"> </a>
<a name="ln1100">	// Compare the node type with that of the pre-existing one.</a>
<a name="ln1101">	if (!S_ISDIR(st.st_mode)) {</a>
<a name="ln1102">		// the pre-existing must not a directory either -- we'll remove it</a>
<a name="ln1103">		if (preExistingFileType == B_HPKG_FILE_TYPE_DIRECTORY) {</a>
<a name="ln1104">			fListener-&gt;PrintError(&quot;Specified file \&quot;%s\&quot; clashes with an &quot;</a>
<a name="ln1105">				&quot;archived directory.\n&quot;, pathBuffer);</a>
<a name="ln1106">			throw status_t(B_BAD_VALUE);</a>
<a name="ln1107">		}</a>
<a name="ln1108"> </a>
<a name="ln1109">		if ((Flags() &amp; B_HPKG_WRITER_FORCE_ADD) == 0) {</a>
<a name="ln1110">			fListener-&gt;PrintError(&quot;Specified file \&quot;%s\&quot; clashes with an &quot;</a>
<a name="ln1111">				&quot;archived file.\n&quot;, pathBuffer);</a>
<a name="ln1112">			throw status_t(B_FILE_EXISTS);</a>
<a name="ln1113">		}</a>
<a name="ln1114"> </a>
<a name="ln1115">		parentAttribute-&gt;RemoveChild(entryAttribute);</a>
<a name="ln1116">		_AttributeRemoved(entryAttribute);</a>
<a name="ln1117"> </a>
<a name="ln1118">		return;</a>
<a name="ln1119">	}</a>
<a name="ln1120"> </a>
<a name="ln1121">	// the pre-existing entry needs to be a directory too -- we will merge</a>
<a name="ln1122">	if (preExistingFileType != B_HPKG_FILE_TYPE_DIRECTORY) {</a>
<a name="ln1123">		fListener-&gt;PrintError(&quot;Specified directory \&quot;%s\&quot; clashes with an &quot;</a>
<a name="ln1124">			&quot;archived non-directory.\n&quot;, pathBuffer);</a>
<a name="ln1125">		throw status_t(B_BAD_VALUE);</a>
<a name="ln1126">	}</a>
<a name="ln1127"> </a>
<a name="ln1128">	// directory -- recursively add children</a>
<a name="ln1129">	if (isImplicitEntry) {</a>
<a name="ln1130">		// this is an implicit entry -- just check the child entries</a>
<a name="ln1131">		for (EntryList::ConstIterator it = entry-&gt;ChildIterator();</a>
<a name="ln1132">				Entry* child = it.Next();) {</a>
<a name="ln1133">			_UpdateCheckEntryCollisions(entryAttribute, fd, child,</a>
<a name="ln1134">				child-&gt;Name(), pathBuffer);</a>
<a name="ln1135">		}</a>
<a name="ln1136">	} else {</a>
<a name="ln1137">		// explicitly specified directory -- we need to read the directory</a>
<a name="ln1138"> </a>
<a name="ln1139">		// first we check for colliding node attributes, though</a>
<a name="ln1140">		if (DIR* attrDir = fs_fopen_attr_dir(fd)) {</a>
<a name="ln1141">			CObjectDeleter&lt;DIR, int&gt; attrDirCloser(attrDir, fs_close_attr_dir);</a>
<a name="ln1142"> </a>
<a name="ln1143">			while (dirent* entry = fs_read_attr_dir(attrDir)) {</a>
<a name="ln1144">				attr_info attrInfo;</a>
<a name="ln1145">				if (fs_stat_attr(fd, entry-&gt;d_name, &amp;attrInfo) &lt; 0) {</a>
<a name="ln1146">					fListener-&gt;PrintError(</a>
<a name="ln1147">						&quot;Failed to stat attribute \&quot;%s\&quot; of directory \&quot;%s\&quot;: &quot;</a>
<a name="ln1148">						&quot;%s\n&quot;, entry-&gt;d_name, pathBuffer, strerror(errno));</a>
<a name="ln1149">					throw status_t(errno);</a>
<a name="ln1150">				}</a>
<a name="ln1151"> </a>
<a name="ln1152">				// check whether the attribute exists</a>
<a name="ln1153">				Attribute* attributeAttribute</a>
<a name="ln1154">					= entryAttribute-&gt;FindNodeAttributeChild(entry-&gt;d_name);</a>
<a name="ln1155">				if (attributeAttribute == NULL)</a>
<a name="ln1156">					continue;</a>
<a name="ln1157"> </a>
<a name="ln1158">				if ((Flags() &amp; B_HPKG_WRITER_FORCE_ADD) == 0) {</a>
<a name="ln1159">					fListener-&gt;PrintError(&quot;Attribute \&quot;%s\&quot; of specified &quot;</a>
<a name="ln1160">						&quot;directory \&quot;%s\&quot; clashes with an archived &quot;</a>
<a name="ln1161">						&quot;attribute.\n&quot;, pathBuffer);</a>
<a name="ln1162">					throw status_t(B_FILE_EXISTS);</a>
<a name="ln1163">				}</a>
<a name="ln1164"> </a>
<a name="ln1165">				// remove it</a>
<a name="ln1166">				entryAttribute-&gt;RemoveChild(attributeAttribute);</a>
<a name="ln1167">				_AttributeRemoved(attributeAttribute);</a>
<a name="ln1168">			}</a>
<a name="ln1169">		}</a>
<a name="ln1170"> </a>
<a name="ln1171">		// we need to clone the directory FD for fdopendir()</a>
<a name="ln1172">		int clonedFD = dup(fd);</a>
<a name="ln1173">		if (clonedFD &lt; 0) {</a>
<a name="ln1174">			fListener-&gt;PrintError(</a>
<a name="ln1175">				&quot;Failed to dup() directory FD: %s\n&quot;, strerror(errno));</a>
<a name="ln1176">			throw status_t(errno);</a>
<a name="ln1177">		}</a>
<a name="ln1178"> </a>
<a name="ln1179">		DIR* dir = fdopendir(clonedFD);</a>
<a name="ln1180">		if (dir == NULL) {</a>
<a name="ln1181">			fListener-&gt;PrintError(</a>
<a name="ln1182">				&quot;Failed to open directory \&quot;%s\&quot;: %s\n&quot;, pathBuffer,</a>
<a name="ln1183">				strerror(errno));</a>
<a name="ln1184">			close(clonedFD);</a>
<a name="ln1185">			throw status_t(errno);</a>
<a name="ln1186">		}</a>
<a name="ln1187">		CObjectDeleter&lt;DIR, int&gt; dirCloser(dir, closedir);</a>
<a name="ln1188"> </a>
<a name="ln1189">		while (dirent* entry = readdir(dir)) {</a>
<a name="ln1190">			// skip &quot;.&quot; and &quot;..&quot;</a>
<a name="ln1191">			if (strcmp(entry-&gt;d_name, &quot;.&quot;) == 0</a>
<a name="ln1192">				|| strcmp(entry-&gt;d_name, &quot;..&quot;) == 0) {</a>
<a name="ln1193">				continue;</a>
<a name="ln1194">			}</a>
<a name="ln1195"> </a>
<a name="ln1196">			_UpdateCheckEntryCollisions(entryAttribute, fd, NULL, entry-&gt;d_name,</a>
<a name="ln1197">				pathBuffer);</a>
<a name="ln1198">		}</a>
<a name="ln1199">	}</a>
<a name="ln1200">}</a>
<a name="ln1201"> </a>
<a name="ln1202"> </a>
<a name="ln1203">void</a>
<a name="ln1204">PackageWriterImpl::_CompactHeap()</a>
<a name="ln1205">{</a>
<a name="ln1206">	int32 count = fHeapRangesToRemove-&gt;CountRanges();</a>
<a name="ln1207">	if (count == 0)</a>
<a name="ln1208">		return;</a>
<a name="ln1209"> </a>
<a name="ln1210">	// compute the move deltas for the ranges</a>
<a name="ln1211">	Array&lt;uint64&gt; deltas;</a>
<a name="ln1212">	uint64 delta = 0;</a>
<a name="ln1213">	for (int32 i = 0; i &lt; count; i++) {</a>
<a name="ln1214">		if (!deltas.Add(delta))</a>
<a name="ln1215">			throw std::bad_alloc();</a>
<a name="ln1216"> </a>
<a name="ln1217">		delta += fHeapRangesToRemove-&gt;RangeAt(i).size;</a>
<a name="ln1218">	}</a>
<a name="ln1219"> </a>
<a name="ln1220">	if (!deltas.Add(delta))</a>
<a name="ln1221">		throw std::bad_alloc();</a>
<a name="ln1222"> </a>
<a name="ln1223">	// offset the attributes</a>
<a name="ln1224">	HeapAttributeOffsetter(*fHeapRangesToRemove, deltas).ProcessAttribute(</a>
<a name="ln1225">		fRootAttribute);</a>
<a name="ln1226"> </a>
<a name="ln1227">	// remove the ranges from the heap</a>
<a name="ln1228">	fHeapWriter-&gt;RemoveDataRanges(*fHeapRangesToRemove);</a>
<a name="ln1229">}</a>
<a name="ln1230"> </a>
<a name="ln1231"> </a>
<a name="ln1232">void</a>
<a name="ln1233">PackageWriterImpl::_AttributeRemoved(Attribute* attribute)</a>
<a name="ln1234">{</a>
<a name="ln1235">	AttributeValue&amp; value = attribute-&gt;value;</a>
<a name="ln1236">	if (value.type == B_HPKG_ATTRIBUTE_TYPE_RAW</a>
<a name="ln1237">		&amp;&amp; value.encoding == B_HPKG_ATTRIBUTE_ENCODING_RAW_HEAP) {</a>
<a name="ln1238">		if (!fHeapRangesToRemove-&gt;AddRange(value.data.offset, value.data.size))</a>
<a name="ln1239">			throw std::bad_alloc();</a>
<a name="ln1240">	} else if (value.type == B_HPKG_ATTRIBUTE_TYPE_STRING)</a>
<a name="ln1241">		fStringCache.Put(value.string);</a>
<a name="ln1242"> </a>
<a name="ln1243">	for (DoublyLinkedList&lt;Attribute&gt;::Iterator it</a>
<a name="ln1244">				= attribute-&gt;children.GetIterator();</a>
<a name="ln1245">			Attribute* child = it.Next();) {</a>
<a name="ln1246">		_AttributeRemoved(child);</a>
<a name="ln1247">	}</a>
<a name="ln1248">}</a>
<a name="ln1249"> </a>
<a name="ln1250"> </a>
<a name="ln1251">status_t</a>
<a name="ln1252">PackageWriterImpl::_RegisterEntry(const char* fileName, int fd)</a>
<a name="ln1253">{</a>
<a name="ln1254">	if (*fileName == '\0') {</a>
<a name="ln1255">		fListener-&gt;PrintError(&quot;Invalid empty file name\n&quot;);</a>
<a name="ln1256">		return B_BAD_VALUE;</a>
<a name="ln1257">	}</a>
<a name="ln1258"> </a>
<a name="ln1259">	// add all components of the path</a>
<a name="ln1260">	Entry* entry = fRootEntry;</a>
<a name="ln1261">	while (*fileName != 0) {</a>
<a name="ln1262">		const char* nextSlash = strchr(fileName, '/');</a>
<a name="ln1263">		// no slash, just add the file name</a>
<a name="ln1264">		if (nextSlash == NULL) {</a>
<a name="ln1265">			entry = _RegisterEntry(entry, fileName, strlen(fileName), fd,</a>
<a name="ln1266">				false);</a>
<a name="ln1267">			break;</a>
<a name="ln1268">		}</a>
<a name="ln1269"> </a>
<a name="ln1270">		// find the start of the next component, skipping slashes</a>
<a name="ln1271">		const char* nextComponent = nextSlash + 1;</a>
<a name="ln1272">		while (*nextComponent == '/')</a>
<a name="ln1273">			nextComponent++;</a>
<a name="ln1274"> </a>
<a name="ln1275">		bool lastComponent = *nextComponent != '\0';</a>
<a name="ln1276"> </a>
<a name="ln1277">		if (nextSlash == fileName) {</a>
<a name="ln1278">			// the FS root</a>
<a name="ln1279">			entry = _RegisterEntry(entry, fileName, 1, lastComponent ? fd : -1,</a>
<a name="ln1280">				lastComponent);</a>
<a name="ln1281">		} else {</a>
<a name="ln1282">			entry = _RegisterEntry(entry, fileName, nextSlash - fileName,</a>
<a name="ln1283">				lastComponent ? fd : -1, lastComponent);</a>
<a name="ln1284">		}</a>
<a name="ln1285"> </a>
<a name="ln1286">		fileName = nextComponent;</a>
<a name="ln1287">	}</a>
<a name="ln1288"> </a>
<a name="ln1289">	return B_OK;</a>
<a name="ln1290">}</a>
<a name="ln1291"> </a>
<a name="ln1292"> </a>
<a name="ln1293">PackageWriterImpl::Entry*</a>
<a name="ln1294">PackageWriterImpl::_RegisterEntry(Entry* parent, const char* name,</a>
<a name="ln1295">	size_t nameLength, int fd, bool isImplicit)</a>
<a name="ln1296">{</a>
<a name="ln1297">	// check the component name -- don't allow &quot;.&quot; or &quot;..&quot;</a>
<a name="ln1298">	if (name[0] == '.'</a>
<a name="ln1299">		&amp;&amp; (nameLength == 1 || (nameLength == 2 &amp;&amp; name[1] == '.'))) {</a>
<a name="ln1300">		fListener-&gt;PrintError(&quot;Invalid file name: \&quot;.\&quot; and \&quot;..\&quot; &quot;</a>
<a name="ln1301">			&quot;are not allowed as path components\n&quot;);</a>
<a name="ln1302">		throw status_t(B_BAD_VALUE);</a>
<a name="ln1303">	}</a>
<a name="ln1304"> </a>
<a name="ln1305">	// the entry might already exist</a>
<a name="ln1306">	Entry* entry = parent-&gt;GetChild(name, nameLength);</a>
<a name="ln1307">	if (entry != NULL) {</a>
<a name="ln1308">		// If the entry was implicit and is no longer, we mark it non-implicit</a>
<a name="ln1309">		// and delete all of it's children.</a>
<a name="ln1310">		if (entry-&gt;IsImplicit() &amp;&amp; !isImplicit) {</a>
<a name="ln1311">			entry-&gt;DeleteChildren();</a>
<a name="ln1312">			entry-&gt;SetImplicit(false);</a>
<a name="ln1313">			entry-&gt;SetFD(fd);</a>
<a name="ln1314">		}</a>
<a name="ln1315">	} else {</a>
<a name="ln1316">		// nope -- create it</a>
<a name="ln1317">		entry = Entry::Create(name, nameLength, fd, isImplicit);</a>
<a name="ln1318">		parent-&gt;AddChild(entry);</a>
<a name="ln1319">	}</a>
<a name="ln1320"> </a>
<a name="ln1321">	return entry;</a>
<a name="ln1322">}</a>
<a name="ln1323"> </a>
<a name="ln1324"> </a>
<a name="ln1325">void</a>
<a name="ln1326">PackageWriterImpl::_WriteTOC(hpkg_header&amp; header, uint64&amp; _length)</a>
<a name="ln1327">{</a>
<a name="ln1328">	// write the subsections</a>
<a name="ln1329">	uint64 startOffset = fHeapWriter-&gt;UncompressedHeapSize();</a>
<a name="ln1330"> </a>
<a name="ln1331">	// cached strings</a>
<a name="ln1332">	uint64 cachedStringsOffset = fHeapWriter-&gt;UncompressedHeapSize();</a>
<a name="ln1333">	int32 cachedStringsWritten = WriteCachedStrings(fStringCache, 2);</a>
<a name="ln1334"> </a>
<a name="ln1335">	// main TOC section</a>
<a name="ln1336">	uint64 mainOffset = fHeapWriter-&gt;UncompressedHeapSize();</a>
<a name="ln1337">	_WriteAttributeChildren(fRootAttribute);</a>
<a name="ln1338"> </a>
<a name="ln1339">	// notify the listener</a>
<a name="ln1340">	uint64 endOffset = fHeapWriter-&gt;UncompressedHeapSize();</a>
<a name="ln1341">	uint64 stringsSize = mainOffset - cachedStringsOffset;</a>
<a name="ln1342">	uint64 mainSize = endOffset - mainOffset;</a>
<a name="ln1343">	uint64 tocSize = endOffset - startOffset;</a>
<a name="ln1344">	fListener-&gt;OnTOCSizeInfo(stringsSize, mainSize, tocSize);</a>
<a name="ln1345"> </a>
<a name="ln1346">	// update the header</a>
<a name="ln1347">	header.toc_length = B_HOST_TO_BENDIAN_INT64(tocSize);</a>
<a name="ln1348">	header.toc_strings_length = B_HOST_TO_BENDIAN_INT64(stringsSize);</a>
<a name="ln1349">	header.toc_strings_count = B_HOST_TO_BENDIAN_INT64(cachedStringsWritten);</a>
<a name="ln1350"> </a>
<a name="ln1351">	_length = tocSize;</a>
<a name="ln1352">}</a>
<a name="ln1353"> </a>
<a name="ln1354"> </a>
<a name="ln1355">void</a>
<a name="ln1356">PackageWriterImpl::_WriteAttributeChildren(Attribute* attribute)</a>
<a name="ln1357">{</a>
<a name="ln1358">	DoublyLinkedList&lt;Attribute&gt;::Iterator it</a>
<a name="ln1359">		= attribute-&gt;children.GetIterator();</a>
<a name="ln1360">	while (Attribute* child = it.Next()) {</a>
<a name="ln1361">		// write tag</a>
<a name="ln1362">		uint8 encoding = child-&gt;value.ApplicableEncoding();</a>
<a name="ln1363">		WriteUnsignedLEB128(compose_attribute_tag(child-&gt;id,</a>
<a name="ln1364">			child-&gt;value.type, encoding, !child-&gt;children.IsEmpty()));</a>
<a name="ln1365"> </a>
<a name="ln1366">		// write value</a>
<a name="ln1367">		WriteAttributeValue(child-&gt;value, encoding);</a>
<a name="ln1368"> </a>
<a name="ln1369">		if (!child-&gt;children.IsEmpty())</a>
<a name="ln1370">			_WriteAttributeChildren(child);</a>
<a name="ln1371">	}</a>
<a name="ln1372"> </a>
<a name="ln1373">	WriteUnsignedLEB128(0);</a>
<a name="ln1374">}</a>
<a name="ln1375"> </a>
<a name="ln1376"> </a>
<a name="ln1377">void</a>
<a name="ln1378">PackageWriterImpl::_WritePackageAttributes(hpkg_header&amp; header, uint64&amp; _length)</a>
<a name="ln1379">{</a>
<a name="ln1380">	// write cached strings and package attributes tree</a>
<a name="ln1381">	off_t startOffset = fHeapWriter-&gt;UncompressedHeapSize();</a>
<a name="ln1382"> </a>
<a name="ln1383">	uint32 stringsLength;</a>
<a name="ln1384">	uint32 stringsCount = WritePackageAttributes(PackageAttributes(),</a>
<a name="ln1385">		stringsLength);</a>
<a name="ln1386"> </a>
<a name="ln1387">	// notify listener</a>
<a name="ln1388">	uint32 attributesLength = fHeapWriter-&gt;UncompressedHeapSize() - startOffset;</a>
<a name="ln1389">	fListener-&gt;OnPackageAttributesSizeInfo(stringsCount, attributesLength);</a>
<a name="ln1390"> </a>
<a name="ln1391">	// update the header</a>
<a name="ln1392">	header.attributes_length = B_HOST_TO_BENDIAN_INT32(attributesLength);</a>
<a name="ln1393">	header.attributes_strings_count = B_HOST_TO_BENDIAN_INT32(stringsCount);</a>
<a name="ln1394">	header.attributes_strings_length = B_HOST_TO_BENDIAN_INT32(stringsLength);</a>
<a name="ln1395"> </a>
<a name="ln1396">	_length = attributesLength;</a>
<a name="ln1397">}</a>
<a name="ln1398"> </a>
<a name="ln1399"> </a>
<a name="ln1400">void</a>
<a name="ln1401">PackageWriterImpl::_AddEntry(int dirFD, Entry* entry, const char* fileName,</a>
<a name="ln1402">	char* pathBuffer)</a>
<a name="ln1403">{</a>
<a name="ln1404">	bool isImplicitEntry = entry != NULL &amp;&amp; entry-&gt;IsImplicit();</a>
<a name="ln1405"> </a>
<a name="ln1406">	SubPathAdder pathAdder(fListener, pathBuffer, fileName);</a>
<a name="ln1407">	if (!isImplicitEntry)</a>
<a name="ln1408">		fListener-&gt;OnEntryAdded(pathBuffer);</a>
<a name="ln1409"> </a>
<a name="ln1410">	// open the node</a>
<a name="ln1411">	int fd;</a>
<a name="ln1412">	FileDescriptorCloser fdCloser;</a>
<a name="ln1413"> </a>
<a name="ln1414">	if (entry != NULL &amp;&amp; entry-&gt;FD() &gt;= 0) {</a>
<a name="ln1415">		// a file descriptor is already given -- use that</a>
<a name="ln1416">		fd = entry-&gt;FD();</a>
<a name="ln1417">	} else {</a>
<a name="ln1418">		fd = openat(dirFD, fileName,</a>
<a name="ln1419">			O_RDONLY | (isImplicitEntry ? 0 : O_NOTRAVERSE));</a>
<a name="ln1420">		if (fd &lt; 0) {</a>
<a name="ln1421">			fListener-&gt;PrintError(&quot;Failed to open entry \&quot;%s\&quot;: %s\n&quot;,</a>
<a name="ln1422">				pathBuffer, strerror(errno));</a>
<a name="ln1423">			throw status_t(errno);</a>
<a name="ln1424">		}</a>
<a name="ln1425">		fdCloser.SetTo(fd);</a>
<a name="ln1426">	}</a>
<a name="ln1427"> </a>
<a name="ln1428">	// stat the node</a>
<a name="ln1429">	struct stat st;</a>
<a name="ln1430">	if (fstat(fd, &amp;st) &lt; 0) {</a>
<a name="ln1431">		fListener-&gt;PrintError(&quot;Failed to fstat() file \&quot;%s\&quot;: %s\n&quot;, pathBuffer,</a>
<a name="ln1432">			strerror(errno));</a>
<a name="ln1433">		throw status_t(errno);</a>
<a name="ln1434">	}</a>
<a name="ln1435"> </a>
<a name="ln1436">	// implicit entries must be directories</a>
<a name="ln1437">	if (isImplicitEntry &amp;&amp; !S_ISDIR(st.st_mode)) {</a>
<a name="ln1438">		fListener-&gt;PrintError(&quot;Non-leaf path component \&quot;%s\&quot; is not a &quot;</a>
<a name="ln1439">			&quot;directory\n&quot;, pathBuffer);</a>
<a name="ln1440">		throw status_t(B_BAD_VALUE);</a>
<a name="ln1441">	}</a>
<a name="ln1442"> </a>
<a name="ln1443">	// In update mode we don't need to add an entry attribute for an implicit</a>
<a name="ln1444">	// directory, if there already is one.</a>
<a name="ln1445">	Attribute* entryAttribute = NULL;</a>
<a name="ln1446">	if (S_ISDIR(st.st_mode) &amp;&amp; (Flags() &amp; B_HPKG_WRITER_UPDATE_PACKAGE) != 0) {</a>
<a name="ln1447">		entryAttribute = fTopAttribute-&gt;FindEntryChild(fileName);</a>
<a name="ln1448">		if (entryAttribute != NULL &amp;&amp; isImplicitEntry) {</a>
<a name="ln1449">			Stacker&lt;Attribute&gt; entryAttributeStacker(fTopAttribute,</a>
<a name="ln1450">				entryAttribute);</a>
<a name="ln1451">			_AddDirectoryChildren(entry, fd, pathBuffer);</a>
<a name="ln1452">			return;</a>
<a name="ln1453">		}</a>
<a name="ln1454">	}</a>
<a name="ln1455"> </a>
<a name="ln1456">	// check/translate the node type</a>
<a name="ln1457">	uint8 fileType;</a>
<a name="ln1458">	uint32 defaultPermissions;</a>
<a name="ln1459">	if (S_ISREG(st.st_mode)) {</a>
<a name="ln1460">		fileType = B_HPKG_FILE_TYPE_FILE;</a>
<a name="ln1461">		defaultPermissions = B_HPKG_DEFAULT_FILE_PERMISSIONS;</a>
<a name="ln1462">	} else if (S_ISLNK(st.st_mode)) {</a>
<a name="ln1463">		fileType = B_HPKG_FILE_TYPE_SYMLINK;</a>
<a name="ln1464">		defaultPermissions = B_HPKG_DEFAULT_SYMLINK_PERMISSIONS;</a>
<a name="ln1465">	} else if (S_ISDIR(st.st_mode)) {</a>
<a name="ln1466">		fileType = B_HPKG_FILE_TYPE_DIRECTORY;</a>
<a name="ln1467">		defaultPermissions = B_HPKG_DEFAULT_DIRECTORY_PERMISSIONS;</a>
<a name="ln1468">	} else {</a>
<a name="ln1469">		// unsupported node type</a>
<a name="ln1470">		fListener-&gt;PrintError(&quot;Unsupported node type, entry: \&quot;%s\&quot;\n&quot;,</a>
<a name="ln1471">			pathBuffer);</a>
<a name="ln1472">		throw status_t(B_UNSUPPORTED);</a>
<a name="ln1473">	}</a>
<a name="ln1474"> </a>
<a name="ln1475">	// add attribute entry, if it doesn't already exist (update mode, directory)</a>
<a name="ln1476">	bool isNewEntry = entryAttribute == NULL;</a>
<a name="ln1477">	if (entryAttribute == NULL) {</a>
<a name="ln1478">		entryAttribute = _AddStringAttribute(</a>
<a name="ln1479">			B_HPKG_ATTRIBUTE_ID_DIRECTORY_ENTRY, fileName);</a>
<a name="ln1480">	}</a>
<a name="ln1481"> </a>
<a name="ln1482">	Stacker&lt;Attribute&gt; entryAttributeStacker(fTopAttribute, entryAttribute);</a>
<a name="ln1483"> </a>
<a name="ln1484">	if (isNewEntry) {</a>
<a name="ln1485">		// add stat data</a>
<a name="ln1486">		if (fileType != B_HPKG_DEFAULT_FILE_TYPE)</a>
<a name="ln1487">			_AddAttribute(B_HPKG_ATTRIBUTE_ID_FILE_TYPE, fileType);</a>
<a name="ln1488">		if (defaultPermissions != uint32(st.st_mode &amp; ALLPERMS)) {</a>
<a name="ln1489">			_AddAttribute(B_HPKG_ATTRIBUTE_ID_FILE_PERMISSIONS,</a>
<a name="ln1490">				uint32(st.st_mode &amp; ALLPERMS));</a>
<a name="ln1491">		}</a>
<a name="ln1492">		_AddAttribute(B_HPKG_ATTRIBUTE_ID_FILE_ATIME, uint32(st.st_atime));</a>
<a name="ln1493">		_AddAttribute(B_HPKG_ATTRIBUTE_ID_FILE_MTIME, uint32(st.st_mtime));</a>
<a name="ln1494">#ifdef __HAIKU__</a>
<a name="ln1495">		_AddAttribute(B_HPKG_ATTRIBUTE_ID_FILE_CRTIME, uint32(st.st_crtime));</a>
<a name="ln1496">#else</a>
<a name="ln1497">		_AddAttribute(B_HPKG_ATTRIBUTE_ID_FILE_CRTIME, uint32(st.st_mtime));</a>
<a name="ln1498">#endif</a>
<a name="ln1499">		// TODO: File user/group!</a>
<a name="ln1500"> </a>
<a name="ln1501">		// add file data/symlink path</a>
<a name="ln1502">		if (S_ISREG(st.st_mode)) {</a>
<a name="ln1503">			// regular file -- add data</a>
<a name="ln1504">			if (st.st_size &gt; 0) {</a>
<a name="ln1505">				BFDDataReader dataReader(fd);</a>
<a name="ln1506">				status_t error = _AddData(dataReader, st.st_size);</a>
<a name="ln1507">				if (error != B_OK)</a>
<a name="ln1508">					throw status_t(error);</a>
<a name="ln1509">			}</a>
<a name="ln1510">		} else if (S_ISLNK(st.st_mode)) {</a>
<a name="ln1511">			// symlink -- add link address</a>
<a name="ln1512">			char path[B_PATH_NAME_LENGTH + 1];</a>
<a name="ln1513">			ssize_t bytesRead = readlinkat(dirFD, fileName, path,</a>
<a name="ln1514">				B_PATH_NAME_LENGTH);</a>
<a name="ln1515">			if (bytesRead &lt; 0) {</a>
<a name="ln1516">				fListener-&gt;PrintError(&quot;Failed to read symlink \&quot;%s\&quot;: %s\n&quot;,</a>
<a name="ln1517">					pathBuffer, strerror(errno));</a>
<a name="ln1518">				throw status_t(errno);</a>
<a name="ln1519">			}</a>
<a name="ln1520"> </a>
<a name="ln1521">			path[bytesRead] = '\0';</a>
<a name="ln1522">			_AddStringAttribute(B_HPKG_ATTRIBUTE_ID_SYMLINK_PATH, path);</a>
<a name="ln1523">		}</a>
<a name="ln1524">	}</a>
<a name="ln1525"> </a>
<a name="ln1526">	// add attributes</a>
<a name="ln1527">	if (DIR* attrDir = fs_fopen_attr_dir(fd)) {</a>
<a name="ln1528">		CObjectDeleter&lt;DIR, int&gt; attrDirCloser(attrDir, fs_close_attr_dir);</a>
<a name="ln1529"> </a>
<a name="ln1530">		while (dirent* entry = fs_read_attr_dir(attrDir)) {</a>
<a name="ln1531">			attr_info attrInfo;</a>
<a name="ln1532">			if (fs_stat_attr(fd, entry-&gt;d_name, &amp;attrInfo) &lt; 0) {</a>
<a name="ln1533">				fListener-&gt;PrintError(</a>
<a name="ln1534">					&quot;Failed to stat attribute \&quot;%s\&quot; of file \&quot;%s\&quot;: %s\n&quot;,</a>
<a name="ln1535">					entry-&gt;d_name, pathBuffer, strerror(errno));</a>
<a name="ln1536">				throw status_t(errno);</a>
<a name="ln1537">			}</a>
<a name="ln1538"> </a>
<a name="ln1539">			// create attribute entry</a>
<a name="ln1540">			Attribute* attributeAttribute = _AddStringAttribute(</a>
<a name="ln1541">				B_HPKG_ATTRIBUTE_ID_FILE_ATTRIBUTE, entry-&gt;d_name);</a>
<a name="ln1542">			Stacker&lt;Attribute&gt; attributeAttributeStacker(fTopAttribute,</a>
<a name="ln1543">				attributeAttribute);</a>
<a name="ln1544"> </a>
<a name="ln1545">			// add type</a>
<a name="ln1546">			_AddAttribute(B_HPKG_ATTRIBUTE_ID_FILE_ATTRIBUTE_TYPE,</a>
<a name="ln1547">				(uint32)attrInfo.type);</a>
<a name="ln1548"> </a>
<a name="ln1549">			// add data</a>
<a name="ln1550">			BAttributeDataReader dataReader(fd, entry-&gt;d_name, attrInfo.type);</a>
<a name="ln1551">			status_t error = _AddData(dataReader, attrInfo.size);</a>
<a name="ln1552">			if (error != B_OK)</a>
<a name="ln1553">				throw status_t(error);</a>
<a name="ln1554">		}</a>
<a name="ln1555">	}</a>
<a name="ln1556"> </a>
<a name="ln1557">	if (S_ISDIR(st.st_mode))</a>
<a name="ln1558">		_AddDirectoryChildren(entry, fd, pathBuffer);</a>
<a name="ln1559">}</a>
<a name="ln1560"> </a>
<a name="ln1561"> </a>
<a name="ln1562">void</a>
<a name="ln1563">PackageWriterImpl::_AddDirectoryChildren(Entry* entry, int fd, char* pathBuffer)</a>
<a name="ln1564">{</a>
<a name="ln1565">	// directory -- recursively add children</a>
<a name="ln1566">	if (entry != NULL &amp;&amp; entry-&gt;IsImplicit()) {</a>
<a name="ln1567">		// this is an implicit entry -- just add it's children</a>
<a name="ln1568">		for (EntryList::ConstIterator it = entry-&gt;ChildIterator();</a>
<a name="ln1569">				Entry* child = it.Next();) {</a>
<a name="ln1570">			_AddEntry(fd, child, child-&gt;Name(), pathBuffer);</a>
<a name="ln1571">		}</a>
<a name="ln1572">	} else {</a>
<a name="ln1573">		// we need to clone the directory FD for fdopendir()</a>
<a name="ln1574">		int clonedFD = dup(fd);</a>
<a name="ln1575">		if (clonedFD &lt; 0) {</a>
<a name="ln1576">			fListener-&gt;PrintError(</a>
<a name="ln1577">				&quot;Failed to dup() directory FD: %s\n&quot;, strerror(errno));</a>
<a name="ln1578">			throw status_t(errno);</a>
<a name="ln1579">		}</a>
<a name="ln1580"> </a>
<a name="ln1581">		DIR* dir = fdopendir(clonedFD);</a>
<a name="ln1582">		if (dir == NULL) {</a>
<a name="ln1583">			fListener-&gt;PrintError(</a>
<a name="ln1584">				&quot;Failed to open directory \&quot;%s\&quot;: %s\n&quot;, pathBuffer,</a>
<a name="ln1585">				strerror(errno));</a>
<a name="ln1586">			close(clonedFD);</a>
<a name="ln1587">			throw status_t(errno);</a>
<a name="ln1588">		}</a>
<a name="ln1589">		CObjectDeleter&lt;DIR, int&gt; dirCloser(dir, closedir);</a>
<a name="ln1590"> </a>
<a name="ln1591">		while (dirent* entry = readdir(dir)) {</a>
<a name="ln1592">			// skip &quot;.&quot; and &quot;..&quot;</a>
<a name="ln1593">			if (strcmp(entry-&gt;d_name, &quot;.&quot;) == 0</a>
<a name="ln1594">				|| strcmp(entry-&gt;d_name, &quot;..&quot;) == 0) {</a>
<a name="ln1595">				continue;</a>
<a name="ln1596">			}</a>
<a name="ln1597"> </a>
<a name="ln1598">			_AddEntry(fd, NULL, entry-&gt;d_name, pathBuffer);</a>
<a name="ln1599">		}</a>
<a name="ln1600">	}</a>
<a name="ln1601">}</a>
<a name="ln1602"> </a>
<a name="ln1603"> </a>
<a name="ln1604">PackageWriterImpl::Attribute*</a>
<a name="ln1605">PackageWriterImpl::_AddAttribute(BHPKGAttributeID id,</a>
<a name="ln1606">	const AttributeValue&amp; value)</a>
<a name="ln1607">{</a>
<a name="ln1608">	Attribute* attribute = new Attribute(id);</a>
<a name="ln1609"> </a>
<a name="ln1610">	attribute-&gt;value = value;</a>
<a name="ln1611">	fTopAttribute-&gt;AddChild(attribute);</a>
<a name="ln1612"> </a>
<a name="ln1613">	return attribute;</a>
<a name="ln1614">}</a>
<a name="ln1615"> </a>
<a name="ln1616"> </a>
<a name="ln1617">PackageWriterImpl::Attribute*</a>
<a name="ln1618">PackageWriterImpl::_AddStringAttribute(BHPKGAttributeID attributeID,</a>
<a name="ln1619">	const char* value)</a>
<a name="ln1620">{</a>
<a name="ln1621">	AttributeValue attributeValue;</a>
<a name="ln1622">	attributeValue.SetTo(fStringCache.Get(value));</a>
<a name="ln1623">	return _AddAttribute(attributeID, attributeValue);</a>
<a name="ln1624">}</a>
<a name="ln1625"> </a>
<a name="ln1626"> </a>
<a name="ln1627">PackageWriterImpl::Attribute*</a>
<a name="ln1628">PackageWriterImpl::_AddDataAttribute(BHPKGAttributeID attributeID,</a>
<a name="ln1629">	uint64 dataSize, uint64 dataOffset)</a>
<a name="ln1630">{</a>
<a name="ln1631">	AttributeValue attributeValue;</a>
<a name="ln1632">	attributeValue.SetToData(dataSize, dataOffset);</a>
<a name="ln1633">	return _AddAttribute(attributeID, attributeValue);</a>
<a name="ln1634">}</a>
<a name="ln1635"> </a>
<a name="ln1636"> </a>
<a name="ln1637">PackageWriterImpl::Attribute*</a>
<a name="ln1638">PackageWriterImpl::_AddDataAttribute(BHPKGAttributeID attributeID,</a>
<a name="ln1639">	uint64 dataSize, const uint8* data)</a>
<a name="ln1640">{</a>
<a name="ln1641">	AttributeValue attributeValue;</a>
<a name="ln1642">	attributeValue.SetToData(dataSize, data);</a>
<a name="ln1643">	return _AddAttribute(attributeID, attributeValue);</a>
<a name="ln1644">}</a>
<a name="ln1645"> </a>
<a name="ln1646"> </a>
<a name="ln1647">status_t</a>
<a name="ln1648">PackageWriterImpl::_AddData(BDataReader&amp; dataReader, off_t size)</a>
<a name="ln1649">{</a>
<a name="ln1650">	// add short data inline</a>
<a name="ln1651">	if (size &lt;= B_HPKG_MAX_INLINE_DATA_SIZE) {</a>
<a name="ln1652">		uint8 buffer[B_HPKG_MAX_INLINE_DATA_SIZE];</a>
<a name="ln1653">		status_t error = dataReader.ReadData(0, buffer, size);</a>
<a name="ln1654">		if (error != B_OK) {</a>
<a name="ln1655">			fListener-&gt;PrintError(&quot;Failed to read data: %s\n&quot;, strerror(error));</a>
<a name="ln1656">			return error;</a>
<a name="ln1657">		}</a>
<a name="ln1658"> </a>
<a name="ln1659">		_AddDataAttribute(B_HPKG_ATTRIBUTE_ID_DATA, size, buffer);</a>
<a name="ln1660">		return B_OK;</a>
<a name="ln1661">	}</a>
<a name="ln1662"> </a>
<a name="ln1663">	// add data to heap</a>
<a name="ln1664">	uint64 dataOffset;</a>
<a name="ln1665">	status_t error = fHeapWriter-&gt;AddData(dataReader, size, dataOffset);</a>
<a name="ln1666">	if (error != B_OK)</a>
<a name="ln1667">		return error;</a>
<a name="ln1668"> </a>
<a name="ln1669">	_AddDataAttribute(B_HPKG_ATTRIBUTE_ID_DATA, size, dataOffset);</a>
<a name="ln1670">	return B_OK;</a>
<a name="ln1671">}</a>
<a name="ln1672"> </a>
<a name="ln1673"> </a>
<a name="ln1674">}	// namespace BPrivate</a>
<a name="ln1675"> </a>
<a name="ln1676">}	// namespace BHPKG</a>
<a name="ln1677"> </a>
<a name="ln1678">}	// namespace BPackageKit</a>

</code></pre>
<div class="balloon" rel="441"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: fHeapOffset, fHeaderSize.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
