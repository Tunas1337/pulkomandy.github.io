
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>if_mwl.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * SPDX-License-Identifier: BSD-2-Clause-FreeBSD</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2007-2009 Sam Leffler, Errno Consulting</a>
<a name="ln5"> * Copyright (c) 2007-2008 Marvell Semiconductor, Inc.</a>
<a name="ln6"> * All rights reserved.</a>
<a name="ln7"> *</a>
<a name="ln8"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln9"> * modification, are permitted provided that the following conditions</a>
<a name="ln10"> * are met:</a>
<a name="ln11"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln12"> *    notice, this list of conditions and the following disclaimer,</a>
<a name="ln13"> *    without modification.</a>
<a name="ln14"> * 2. Redistributions in binary form must reproduce at minimum a disclaimer</a>
<a name="ln15"> *    similar to the &quot;NO WARRANTY&quot; disclaimer below (&quot;Disclaimer&quot;) and any</a>
<a name="ln16"> *    redistribution must be conditioned upon including a substantially</a>
<a name="ln17"> *    similar Disclaimer requirement for further binary redistribution.</a>
<a name="ln18"> *</a>
<a name="ln19"> * NO WARRANTY</a>
<a name="ln20"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</a>
<a name="ln21"> * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</a>
<a name="ln22"> * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY</a>
<a name="ln23"> * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL</a>
<a name="ln24"> * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,</a>
<a name="ln25"> * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</a>
<a name="ln26"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</a>
<a name="ln27"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER</a>
<a name="ln28"> * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</a>
<a name="ln29"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF</a>
<a name="ln30"> * THE POSSIBILITY OF SUCH DAMAGES.</a>
<a name="ln31"> */</a>
<a name="ln32"> </a>
<a name="ln33">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln34">__FBSDID(&quot;$FreeBSD: releng/12.0/sys/dev/mwl/if_mwl.c 331797 2018-03-30 18:50:13Z brooks $&quot;);</a>
<a name="ln35"> </a>
<a name="ln36">/*</a>
<a name="ln37"> * Driver for the Marvell 88W8363 Wireless LAN controller.</a>
<a name="ln38"> */</a>
<a name="ln39"> </a>
<a name="ln40">#include &quot;opt_inet.h&quot;</a>
<a name="ln41">#include &quot;opt_mwl.h&quot;</a>
<a name="ln42"> </a>
<a name="ln43">#include &lt;sys/param.h&gt;</a>
<a name="ln44">#include &lt;sys/systm.h&gt;</a>
<a name="ln45">#include &lt;sys/sysctl.h&gt;</a>
<a name="ln46">#include &lt;sys/mbuf.h&gt;</a>
<a name="ln47">#include &lt;sys/malloc.h&gt;</a>
<a name="ln48">#include &lt;sys/lock.h&gt;</a>
<a name="ln49">#include &lt;sys/mutex.h&gt;</a>
<a name="ln50">#include &lt;sys/kernel.h&gt;</a>
<a name="ln51">#include &lt;sys/socket.h&gt;</a>
<a name="ln52">#include &lt;sys/sockio.h&gt;</a>
<a name="ln53">#include &lt;sys/errno.h&gt;</a>
<a name="ln54">#include &lt;sys/callout.h&gt;</a>
<a name="ln55">#include &lt;sys/bus.h&gt;</a>
<a name="ln56">#include &lt;sys/endian.h&gt;</a>
<a name="ln57">#include &lt;sys/kthread.h&gt;</a>
<a name="ln58">#include &lt;sys/taskqueue.h&gt;</a>
<a name="ln59"> </a>
<a name="ln60">#include &lt;machine/bus.h&gt;</a>
<a name="ln61"> </a>
<a name="ln62">#include &lt;net/if.h&gt;</a>
<a name="ln63">#include &lt;net/if_var.h&gt;</a>
<a name="ln64">#include &lt;net/if_dl.h&gt;</a>
<a name="ln65">#include &lt;net/if_media.h&gt;</a>
<a name="ln66">#include &lt;net/if_types.h&gt;</a>
<a name="ln67">#include &lt;net/if_arp.h&gt;</a>
<a name="ln68">#include &lt;net/ethernet.h&gt;</a>
<a name="ln69">#include &lt;net/if_llc.h&gt;</a>
<a name="ln70"> </a>
<a name="ln71">#include &lt;net/bpf.h&gt;</a>
<a name="ln72"> </a>
<a name="ln73">#include &lt;net80211/ieee80211_var.h&gt;</a>
<a name="ln74">#include &lt;net80211/ieee80211_input.h&gt;</a>
<a name="ln75">#include &lt;net80211/ieee80211_regdomain.h&gt;</a>
<a name="ln76"> </a>
<a name="ln77">#ifdef INET</a>
<a name="ln78">#include &lt;netinet/in.h&gt;</a>
<a name="ln79">#include &lt;netinet/if_ether.h&gt;</a>
<a name="ln80">#endif /* INET */</a>
<a name="ln81"> </a>
<a name="ln82">#include &lt;dev/mwl/if_mwlvar.h&gt;</a>
<a name="ln83">#include &lt;dev/mwl/mwldiag.h&gt;</a>
<a name="ln84"> </a>
<a name="ln85">/* idiomatic shorthands: MS = mask+shift, SM = shift+mask */</a>
<a name="ln86">#define	MS(v,x)	(((v) &amp; x) &gt;&gt; x##_S)</a>
<a name="ln87">#define	SM(v,x)	(((v) &lt;&lt; x##_S) &amp; x)</a>
<a name="ln88"> </a>
<a name="ln89">static struct ieee80211vap *mwl_vap_create(struct ieee80211com *,</a>
<a name="ln90">		    const char [IFNAMSIZ], int, enum ieee80211_opmode, int,</a>
<a name="ln91">		    const uint8_t [IEEE80211_ADDR_LEN],</a>
<a name="ln92">		    const uint8_t [IEEE80211_ADDR_LEN]);</a>
<a name="ln93">static void	mwl_vap_delete(struct ieee80211vap *);</a>
<a name="ln94">static int	mwl_setupdma(struct mwl_softc *);</a>
<a name="ln95">static int	mwl_hal_reset(struct mwl_softc *sc);</a>
<a name="ln96">static int	mwl_init(struct mwl_softc *);</a>
<a name="ln97">static void	mwl_parent(struct ieee80211com *);</a>
<a name="ln98">static int	mwl_reset(struct ieee80211vap *, u_long);</a>
<a name="ln99">static void	mwl_stop(struct mwl_softc *);</a>
<a name="ln100">static void	mwl_start(struct mwl_softc *);</a>
<a name="ln101">static int	mwl_transmit(struct ieee80211com *, struct mbuf *);</a>
<a name="ln102">static int	mwl_raw_xmit(struct ieee80211_node *, struct mbuf *,</a>
<a name="ln103">			const struct ieee80211_bpf_params *);</a>
<a name="ln104">static int	mwl_media_change(struct ifnet *);</a>
<a name="ln105">static void	mwl_watchdog(void *);</a>
<a name="ln106">static int	mwl_ioctl(struct ieee80211com *, u_long, void *);</a>
<a name="ln107">static void	mwl_radar_proc(void *, int);</a>
<a name="ln108">static void	mwl_chanswitch_proc(void *, int);</a>
<a name="ln109">static void	mwl_bawatchdog_proc(void *, int);</a>
<a name="ln110">static int	mwl_key_alloc(struct ieee80211vap *,</a>
<a name="ln111">			struct ieee80211_key *,</a>
<a name="ln112">			ieee80211_keyix *, ieee80211_keyix *);</a>
<a name="ln113">static int	mwl_key_delete(struct ieee80211vap *,</a>
<a name="ln114">			const struct ieee80211_key *);</a>
<a name="ln115">static int	mwl_key_set(struct ieee80211vap *,</a>
<a name="ln116">			const struct ieee80211_key *);</a>
<a name="ln117">static int	_mwl_key_set(struct ieee80211vap *,</a>
<a name="ln118">			const struct ieee80211_key *,</a>
<a name="ln119">			const uint8_t mac[IEEE80211_ADDR_LEN]);</a>
<a name="ln120">static int	mwl_mode_init(struct mwl_softc *);</a>
<a name="ln121">static void	mwl_update_mcast(struct ieee80211com *);</a>
<a name="ln122">static void	mwl_update_promisc(struct ieee80211com *);</a>
<a name="ln123">static void	mwl_updateslot(struct ieee80211com *);</a>
<a name="ln124">static int	mwl_beacon_setup(struct ieee80211vap *);</a>
<a name="ln125">static void	mwl_beacon_update(struct ieee80211vap *, int);</a>
<a name="ln126">#ifdef MWL_HOST_PS_SUPPORT</a>
<a name="ln127">static void	mwl_update_ps(struct ieee80211vap *, int);</a>
<a name="ln128">static int	mwl_set_tim(struct ieee80211_node *, int);</a>
<a name="ln129">#endif</a>
<a name="ln130">static int	mwl_dma_setup(struct mwl_softc *);</a>
<a name="ln131">static void	mwl_dma_cleanup(struct mwl_softc *);</a>
<a name="ln132">static struct ieee80211_node *mwl_node_alloc(struct ieee80211vap *,</a>
<a name="ln133">		    const uint8_t [IEEE80211_ADDR_LEN]);</a>
<a name="ln134">static void	mwl_node_cleanup(struct ieee80211_node *);</a>
<a name="ln135">static void	mwl_node_drain(struct ieee80211_node *);</a>
<a name="ln136">static void	mwl_node_getsignal(const struct ieee80211_node *,</a>
<a name="ln137">			int8_t *, int8_t *);</a>
<a name="ln138">static void	mwl_node_getmimoinfo(const struct ieee80211_node *,</a>
<a name="ln139">			struct ieee80211_mimo_info *);</a>
<a name="ln140">static int	mwl_rxbuf_init(struct mwl_softc *, struct mwl_rxbuf *);</a>
<a name="ln141">static void	mwl_rx_proc(void *, int);</a>
<a name="ln142">static void	mwl_txq_init(struct mwl_softc *sc, struct mwl_txq *, int);</a>
<a name="ln143">static int	mwl_tx_setup(struct mwl_softc *, int, int);</a>
<a name="ln144">static int	mwl_wme_update(struct ieee80211com *);</a>
<a name="ln145">static void	mwl_tx_cleanupq(struct mwl_softc *, struct mwl_txq *);</a>
<a name="ln146">static void	mwl_tx_cleanup(struct mwl_softc *);</a>
<a name="ln147">static uint16_t	mwl_calcformat(uint8_t rate, const struct ieee80211_node *);</a>
<a name="ln148">static int	mwl_tx_start(struct mwl_softc *, struct ieee80211_node *,</a>
<a name="ln149">			     struct mwl_txbuf *, struct mbuf *);</a>
<a name="ln150">static void	mwl_tx_proc(void *, int);</a>
<a name="ln151">static int	mwl_chan_set(struct mwl_softc *, struct ieee80211_channel *);</a>
<a name="ln152">static void	mwl_draintxq(struct mwl_softc *);</a>
<a name="ln153">static void	mwl_cleartxq(struct mwl_softc *, struct ieee80211vap *);</a>
<a name="ln154">static int	mwl_recv_action(struct ieee80211_node *,</a>
<a name="ln155">			const struct ieee80211_frame *,</a>
<a name="ln156">			const uint8_t *, const uint8_t *);</a>
<a name="ln157">static int	mwl_addba_request(struct ieee80211_node *,</a>
<a name="ln158">			struct ieee80211_tx_ampdu *, int dialogtoken,</a>
<a name="ln159">			int baparamset, int batimeout);</a>
<a name="ln160">static int	mwl_addba_response(struct ieee80211_node *,</a>
<a name="ln161">			struct ieee80211_tx_ampdu *, int status,</a>
<a name="ln162">			int baparamset, int batimeout);</a>
<a name="ln163">static void	mwl_addba_stop(struct ieee80211_node *,</a>
<a name="ln164">			struct ieee80211_tx_ampdu *);</a>
<a name="ln165">static int	mwl_startrecv(struct mwl_softc *);</a>
<a name="ln166">static MWL_HAL_APMODE mwl_getapmode(const struct ieee80211vap *,</a>
<a name="ln167">			struct ieee80211_channel *);</a>
<a name="ln168">static int	mwl_setapmode(struct ieee80211vap *, struct ieee80211_channel*);</a>
<a name="ln169">static void	mwl_scan_start(struct ieee80211com *);</a>
<a name="ln170">static void	mwl_scan_end(struct ieee80211com *);</a>
<a name="ln171">static void	mwl_set_channel(struct ieee80211com *);</a>
<a name="ln172">static int	mwl_peerstadb(struct ieee80211_node *,</a>
<a name="ln173">			int aid, int staid, MWL_HAL_PEERINFO *pi);</a>
<a name="ln174">static int	mwl_localstadb(struct ieee80211vap *);</a>
<a name="ln175">static int	mwl_newstate(struct ieee80211vap *, enum ieee80211_state, int);</a>
<a name="ln176">static int	allocstaid(struct mwl_softc *sc, int aid);</a>
<a name="ln177">static void	delstaid(struct mwl_softc *sc, int staid);</a>
<a name="ln178">static void	mwl_newassoc(struct ieee80211_node *, int);</a>
<a name="ln179">static void	mwl_agestations(void *);</a>
<a name="ln180">static int	mwl_setregdomain(struct ieee80211com *,</a>
<a name="ln181">			struct ieee80211_regdomain *, int,</a>
<a name="ln182">			struct ieee80211_channel []);</a>
<a name="ln183">static void	mwl_getradiocaps(struct ieee80211com *, int, int *,</a>
<a name="ln184">			struct ieee80211_channel []);</a>
<a name="ln185">static int	mwl_getchannels(struct mwl_softc *);</a>
<a name="ln186"> </a>
<a name="ln187">static void	mwl_sysctlattach(struct mwl_softc *);</a>
<a name="ln188">static void	mwl_announce(struct mwl_softc *);</a>
<a name="ln189"> </a>
<a name="ln190">SYSCTL_NODE(_hw, OID_AUTO, mwl, CTLFLAG_RD, 0, &quot;Marvell driver parameters&quot;);</a>
<a name="ln191"> </a>
<a name="ln192">static	int mwl_rxdesc = MWL_RXDESC;		/* # rx desc's to allocate */</a>
<a name="ln193">SYSCTL_INT(_hw_mwl, OID_AUTO, rxdesc, CTLFLAG_RW, &amp;mwl_rxdesc,</a>
<a name="ln194">	    0, &quot;rx descriptors allocated&quot;);</a>
<a name="ln195">static	int mwl_rxbuf = MWL_RXBUF;		/* # rx buffers to allocate */</a>
<a name="ln196">SYSCTL_INT(_hw_mwl, OID_AUTO, rxbuf, CTLFLAG_RWTUN, &amp;mwl_rxbuf,</a>
<a name="ln197">	    0, &quot;rx buffers allocated&quot;);</a>
<a name="ln198">static	int mwl_txbuf = MWL_TXBUF;		/* # tx buffers to allocate */</a>
<a name="ln199">SYSCTL_INT(_hw_mwl, OID_AUTO, txbuf, CTLFLAG_RWTUN, &amp;mwl_txbuf,</a>
<a name="ln200">	    0, &quot;tx buffers allocated&quot;);</a>
<a name="ln201">static	int mwl_txcoalesce = 8;		/* # tx packets to q before poking f/w*/</a>
<a name="ln202">SYSCTL_INT(_hw_mwl, OID_AUTO, txcoalesce, CTLFLAG_RWTUN, &amp;mwl_txcoalesce,</a>
<a name="ln203">	    0, &quot;tx buffers to send at once&quot;);</a>
<a name="ln204">static	int mwl_rxquota = MWL_RXBUF;		/* # max buffers to process */</a>
<a name="ln205">SYSCTL_INT(_hw_mwl, OID_AUTO, rxquota, CTLFLAG_RWTUN, &amp;mwl_rxquota,</a>
<a name="ln206">	    0, &quot;max rx buffers to process per interrupt&quot;);</a>
<a name="ln207">static	int mwl_rxdmalow = 3;			/* # min buffers for wakeup */</a>
<a name="ln208">SYSCTL_INT(_hw_mwl, OID_AUTO, rxdmalow, CTLFLAG_RWTUN, &amp;mwl_rxdmalow,</a>
<a name="ln209">	    0, &quot;min free rx buffers before restarting traffic&quot;);</a>
<a name="ln210"> </a>
<a name="ln211">#ifdef MWL_DEBUG</a>
<a name="ln212">static	int mwl_debug = 0;</a>
<a name="ln213">SYSCTL_INT(_hw_mwl, OID_AUTO, debug, CTLFLAG_RWTUN, &amp;mwl_debug,</a>
<a name="ln214">	    0, &quot;control debugging printfs&quot;);</a>
<a name="ln215">enum {</a>
<a name="ln216">	MWL_DEBUG_XMIT		= 0x00000001,	/* basic xmit operation */</a>
<a name="ln217">	MWL_DEBUG_XMIT_DESC	= 0x00000002,	/* xmit descriptors */</a>
<a name="ln218">	MWL_DEBUG_RECV		= 0x00000004,	/* basic recv operation */</a>
<a name="ln219">	MWL_DEBUG_RECV_DESC	= 0x00000008,	/* recv descriptors */</a>
<a name="ln220">	MWL_DEBUG_RESET		= 0x00000010,	/* reset processing */</a>
<a name="ln221">	MWL_DEBUG_BEACON 	= 0x00000020,	/* beacon handling */</a>
<a name="ln222">	MWL_DEBUG_INTR		= 0x00000040,	/* ISR */</a>
<a name="ln223">	MWL_DEBUG_TX_PROC	= 0x00000080,	/* tx ISR proc */</a>
<a name="ln224">	MWL_DEBUG_RX_PROC	= 0x00000100,	/* rx ISR proc */</a>
<a name="ln225">	MWL_DEBUG_KEYCACHE	= 0x00000200,	/* key cache management */</a>
<a name="ln226">	MWL_DEBUG_STATE		= 0x00000400,	/* 802.11 state transitions */</a>
<a name="ln227">	MWL_DEBUG_NODE		= 0x00000800,	/* node management */</a>
<a name="ln228">	MWL_DEBUG_RECV_ALL	= 0x00001000,	/* trace all frames (beacons) */</a>
<a name="ln229">	MWL_DEBUG_TSO		= 0x00002000,	/* TSO processing */</a>
<a name="ln230">	MWL_DEBUG_AMPDU		= 0x00004000,	/* BA stream handling */</a>
<a name="ln231">	MWL_DEBUG_ANY		= 0xffffffff</a>
<a name="ln232">};</a>
<a name="ln233">#define	IS_BEACON(wh) \</a>
<a name="ln234">    ((wh-&gt;i_fc[0] &amp; (IEEE80211_FC0_TYPE_MASK|IEEE80211_FC0_SUBTYPE_MASK)) == \</a>
<a name="ln235">	 (IEEE80211_FC0_TYPE_MGT|IEEE80211_FC0_SUBTYPE_BEACON))</a>
<a name="ln236">#define	IFF_DUMPPKTS_RECV(sc, wh) \</a>
<a name="ln237">    ((sc-&gt;sc_debug &amp; MWL_DEBUG_RECV) &amp;&amp; \</a>
<a name="ln238">      ((sc-&gt;sc_debug &amp; MWL_DEBUG_RECV_ALL) || !IS_BEACON(wh)))</a>
<a name="ln239">#define	IFF_DUMPPKTS_XMIT(sc) \</a>
<a name="ln240">	(sc-&gt;sc_debug &amp; MWL_DEBUG_XMIT)</a>
<a name="ln241"> </a>
<a name="ln242">#define	DPRINTF(sc, m, fmt, ...) do {				\</a>
<a name="ln243">	if (sc-&gt;sc_debug &amp; (m))					\</a>
<a name="ln244">		printf(fmt, __VA_ARGS__);			\</a>
<a name="ln245">} while (0)</a>
<a name="ln246">#define	KEYPRINTF(sc, hk, mac) do {				\</a>
<a name="ln247">	if (sc-&gt;sc_debug &amp; MWL_DEBUG_KEYCACHE)			\</a>
<a name="ln248">		mwl_keyprint(sc, __func__, hk, mac);		\</a>
<a name="ln249">} while (0)</a>
<a name="ln250">static	void mwl_printrxbuf(const struct mwl_rxbuf *bf, u_int ix);</a>
<a name="ln251">static	void mwl_printtxbuf(const struct mwl_txbuf *bf, u_int qnum, u_int ix);</a>
<a name="ln252">#else</a>
<a name="ln253">#define	IFF_DUMPPKTS_RECV(sc, wh)	0</a>
<a name="ln254">#define	IFF_DUMPPKTS_XMIT(sc)		0</a>
<a name="ln255">#define	DPRINTF(sc, m, fmt, ...)	do { (void )sc; } while (0)</a>
<a name="ln256">#define	KEYPRINTF(sc, k, mac)		do { (void )sc; } while (0)</a>
<a name="ln257">#endif</a>
<a name="ln258"> </a>
<a name="ln259">static MALLOC_DEFINE(M_MWLDEV, &quot;mwldev&quot;, &quot;mwl driver dma buffers&quot;);</a>
<a name="ln260"> </a>
<a name="ln261">/*</a>
<a name="ln262"> * Each packet has fixed front matter: a 2-byte length</a>
<a name="ln263"> * of the payload, followed by a 4-address 802.11 header</a>
<a name="ln264"> * (regardless of the actual header and always w/o any</a>
<a name="ln265"> * QoS header).  The payload then follows.</a>
<a name="ln266"> */</a>
<a name="ln267">struct mwltxrec {</a>
<a name="ln268">	uint16_t fwlen;</a>
<a name="ln269">	struct ieee80211_frame_addr4 wh;</a>
<a name="ln270">} __packed;</a>
<a name="ln271"> </a>
<a name="ln272">/*</a>
<a name="ln273"> * Read/Write shorthands for accesses to BAR 0.  Note</a>
<a name="ln274"> * that all BAR 1 operations are done in the &quot;hal&quot; and</a>
<a name="ln275"> * there should be no reference to them here.</a>
<a name="ln276"> */</a>
<a name="ln277">#ifdef MWL_DEBUG</a>
<a name="ln278">static __inline uint32_t</a>
<a name="ln279">RD4(struct mwl_softc *sc, bus_size_t off)</a>
<a name="ln280">{</a>
<a name="ln281">	return bus_space_read_4(sc-&gt;sc_io0t, sc-&gt;sc_io0h, off);</a>
<a name="ln282">}</a>
<a name="ln283">#endif</a>
<a name="ln284"> </a>
<a name="ln285">static __inline void</a>
<a name="ln286">WR4(struct mwl_softc *sc, bus_size_t off, uint32_t val)</a>
<a name="ln287">{</a>
<a name="ln288">	bus_space_write_4(sc-&gt;sc_io0t, sc-&gt;sc_io0h, off, val);</a>
<a name="ln289">}</a>
<a name="ln290"> </a>
<a name="ln291">int</a>
<a name="ln292">mwl_attach(uint16_t devid, struct mwl_softc *sc)</a>
<a name="ln293">{</a>
<a name="ln294">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln295">	struct mwl_hal *mh;</a>
<a name="ln296">	int error = 0;</a>
<a name="ln297"> </a>
<a name="ln298">	DPRINTF(sc, MWL_DEBUG_ANY, &quot;%s: devid 0x%x\n&quot;, __func__, devid);</a>
<a name="ln299"> </a>
<a name="ln300">	/*</a>
<a name="ln301">	 * Setup the RX free list lock early, so it can be consistently</a>
<a name="ln302">	 * removed.</a>
<a name="ln303">	 */</a>
<a name="ln304">	MWL_RXFREE_INIT(sc);</a>
<a name="ln305"> </a>
<a name="ln306">	mh = mwl_hal_attach(sc-&gt;sc_dev, devid,</a>
<a name="ln307">	    sc-&gt;sc_io1h, sc-&gt;sc_io1t, sc-&gt;sc_dmat);</a>
<a name="ln308">	if (mh == NULL) {</a>
<a name="ln309">		device_printf(sc-&gt;sc_dev, &quot;unable to attach HAL\n&quot;);</a>
<a name="ln310">		error = EIO;</a>
<a name="ln311">		goto bad;</a>
<a name="ln312">	}</a>
<a name="ln313">	sc-&gt;sc_mh = mh;</a>
<a name="ln314">	/*</a>
<a name="ln315">	 * Load firmware so we can get setup.  We arbitrarily</a>
<a name="ln316">	 * pick station firmware; we'll re-load firmware as</a>
<a name="ln317">	 * needed so setting up the wrong mode isn't a big deal.</a>
<a name="ln318">	 */</a>
<a name="ln319">	if (mwl_hal_fwload(mh, NULL) != 0) {</a>
<a name="ln320">		device_printf(sc-&gt;sc_dev, &quot;unable to setup builtin firmware\n&quot;);</a>
<a name="ln321">		error = EIO;</a>
<a name="ln322">		goto bad1;</a>
<a name="ln323">	}</a>
<a name="ln324">	if (mwl_hal_gethwspecs(mh, &amp;sc-&gt;sc_hwspecs) != 0) {</a>
<a name="ln325">		device_printf(sc-&gt;sc_dev, &quot;unable to fetch h/w specs\n&quot;);</a>
<a name="ln326">		error = EIO;</a>
<a name="ln327">		goto bad1;</a>
<a name="ln328">	}</a>
<a name="ln329">	error = mwl_getchannels(sc);</a>
<a name="ln330">	if (error != 0)</a>
<a name="ln331">		goto bad1;</a>
<a name="ln332"> </a>
<a name="ln333">	sc-&gt;sc_txantenna = 0;		/* h/w default */</a>
<a name="ln334">	sc-&gt;sc_rxantenna = 0;		/* h/w default */</a>
<a name="ln335">	sc-&gt;sc_invalid = 0;		/* ready to go, enable int handling */</a>
<a name="ln336">	sc-&gt;sc_ageinterval = MWL_AGEINTERVAL;</a>
<a name="ln337"> </a>
<a name="ln338">	/*</a>
<a name="ln339">	 * Allocate tx+rx descriptors and populate the lists.</a>
<a name="ln340">	 * We immediately push the information to the firmware</a>
<a name="ln341">	 * as otherwise it gets upset.</a>
<a name="ln342">	 */</a>
<a name="ln343">	error = mwl_dma_setup(sc);</a>
<a name="ln344">	if (error != 0) {</a>
<a name="ln345">		device_printf(sc-&gt;sc_dev, &quot;failed to setup descriptors: %d\n&quot;,</a>
<a name="ln346">		    error);</a>
<a name="ln347">		goto bad1;</a>
<a name="ln348">	}</a>
<a name="ln349">	error = mwl_setupdma(sc);	/* push to firmware */</a>
<a name="ln350">	if (error != 0)			/* NB: mwl_setupdma prints msg */</a>
<a name="ln351">		goto bad1;</a>
<a name="ln352"> </a>
<a name="ln353">	callout_init(&amp;sc-&gt;sc_timer, 1);</a>
<a name="ln354">	callout_init_mtx(&amp;sc-&gt;sc_watchdog, &amp;sc-&gt;sc_mtx, 0);</a>
<a name="ln355">	mbufq_init(&amp;sc-&gt;sc_snd, ifqmaxlen);</a>
<a name="ln356"> </a>
<a name="ln357">	sc-&gt;sc_tq = taskqueue_create(&quot;mwl_taskq&quot;, M_NOWAIT,</a>
<a name="ln358">		taskqueue_thread_enqueue, &amp;sc-&gt;sc_tq);</a>
<a name="ln359">	taskqueue_start_threads(&amp;sc-&gt;sc_tq, 1, PI_NET,</a>
<a name="ln360">		&quot;%s taskq&quot;, device_get_nameunit(sc-&gt;sc_dev));</a>
<a name="ln361"> </a>
<a name="ln362">	TASK_INIT(&amp;sc-&gt;sc_rxtask, 0, mwl_rx_proc, sc);</a>
<a name="ln363">	TASK_INIT(&amp;sc-&gt;sc_radartask, 0, mwl_radar_proc, sc);</a>
<a name="ln364">	TASK_INIT(&amp;sc-&gt;sc_chanswitchtask, 0, mwl_chanswitch_proc, sc);</a>
<a name="ln365">	TASK_INIT(&amp;sc-&gt;sc_bawatchdogtask, 0, mwl_bawatchdog_proc, sc);</a>
<a name="ln366"> </a>
<a name="ln367">	/* NB: insure BK queue is the lowest priority h/w queue */</a>
<a name="ln368">	if (!mwl_tx_setup(sc, WME_AC_BK, MWL_WME_AC_BK)) {</a>
<a name="ln369">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln370">		    &quot;unable to setup xmit queue for %s traffic!\n&quot;,</a>
<a name="ln371">		     ieee80211_wme_acnames[WME_AC_BK]);</a>
<a name="ln372">		error = EIO;</a>
<a name="ln373">		goto bad2;</a>
<a name="ln374">	}</a>
<a name="ln375">	if (!mwl_tx_setup(sc, WME_AC_BE, MWL_WME_AC_BE) ||</a>
<a name="ln376">	    !mwl_tx_setup(sc, WME_AC_VI, MWL_WME_AC_VI) ||</a>
<a name="ln377">	    !mwl_tx_setup(sc, WME_AC_VO, MWL_WME_AC_VO)) {</a>
<a name="ln378">		/*</a>
<a name="ln379">		 * Not enough hardware tx queues to properly do WME;</a>
<a name="ln380">		 * just punt and assign them all to the same h/w queue.</a>
<a name="ln381">		 * We could do a better job of this if, for example,</a>
<a name="ln382">		 * we allocate queues when we switch from station to</a>
<a name="ln383">		 * AP mode.</a>
<a name="ln384">		 */</a>
<a name="ln385">		if (sc-&gt;sc_ac2q[WME_AC_VI] != NULL)</a>
<a name="ln386">			mwl_tx_cleanupq(sc, sc-&gt;sc_ac2q[WME_AC_VI]);</a>
<a name="ln387">		if (sc-&gt;sc_ac2q[WME_AC_BE] != NULL)</a>
<a name="ln388">			mwl_tx_cleanupq(sc, sc-&gt;sc_ac2q[WME_AC_BE]);</a>
<a name="ln389">		sc-&gt;sc_ac2q[WME_AC_BE] = sc-&gt;sc_ac2q[WME_AC_BK];</a>
<a name="ln390">		sc-&gt;sc_ac2q[WME_AC_VI] = sc-&gt;sc_ac2q[WME_AC_BK];</a>
<a name="ln391">		sc-&gt;sc_ac2q[WME_AC_VO] = sc-&gt;sc_ac2q[WME_AC_BK];</a>
<a name="ln392">	}</a>
<a name="ln393">	TASK_INIT(&amp;sc-&gt;sc_txtask, 0, mwl_tx_proc, sc);</a>
<a name="ln394"> </a>
<a name="ln395">	ic-&gt;ic_softc = sc;</a>
<a name="ln396">	ic-&gt;ic_name = device_get_nameunit(sc-&gt;sc_dev);</a>
<a name="ln397">	/* XXX not right but it's not used anywhere important */</a>
<a name="ln398">	ic-&gt;ic_phytype = IEEE80211_T_OFDM;</a>
<a name="ln399">	ic-&gt;ic_opmode = IEEE80211_M_STA;</a>
<a name="ln400">	ic-&gt;ic_caps =</a>
<a name="ln401">		  IEEE80211_C_STA		/* station mode supported */</a>
<a name="ln402">		| IEEE80211_C_HOSTAP		/* hostap mode */</a>
<a name="ln403">		| IEEE80211_C_MONITOR		/* monitor mode */</a>
<a name="ln404">#if 0</a>
<a name="ln405">		| IEEE80211_C_IBSS		/* ibss, nee adhoc, mode */</a>
<a name="ln406">		| IEEE80211_C_AHDEMO		/* adhoc demo mode */</a>
<a name="ln407">#endif</a>
<a name="ln408">		| IEEE80211_C_MBSS		/* mesh point link mode */</a>
<a name="ln409">		| IEEE80211_C_WDS		/* WDS supported */</a>
<a name="ln410">		| IEEE80211_C_SHPREAMBLE	/* short preamble supported */</a>
<a name="ln411">		| IEEE80211_C_SHSLOT		/* short slot time supported */</a>
<a name="ln412">		| IEEE80211_C_WME		/* WME/WMM supported */</a>
<a name="ln413">		| IEEE80211_C_BURST		/* xmit bursting supported */</a>
<a name="ln414">		| IEEE80211_C_WPA		/* capable of WPA1+WPA2 */</a>
<a name="ln415">		| IEEE80211_C_BGSCAN		/* capable of bg scanning */</a>
<a name="ln416">		| IEEE80211_C_TXFRAG		/* handle tx frags */</a>
<a name="ln417">		| IEEE80211_C_TXPMGT		/* capable of txpow mgt */</a>
<a name="ln418">		| IEEE80211_C_DFS		/* DFS supported */</a>
<a name="ln419">		;</a>
<a name="ln420"> </a>
<a name="ln421">	ic-&gt;ic_htcaps =</a>
<a name="ln422">		  IEEE80211_HTCAP_SMPS_ENA	/* SM PS mode enabled */</a>
<a name="ln423">		| IEEE80211_HTCAP_CHWIDTH40	/* 40MHz channel width */</a>
<a name="ln424">		| IEEE80211_HTCAP_SHORTGI20	/* short GI in 20MHz */</a>
<a name="ln425">		| IEEE80211_HTCAP_SHORTGI40	/* short GI in 40MHz */</a>
<a name="ln426">		| IEEE80211_HTCAP_RXSTBC_2STREAM/* 1-2 spatial streams */</a>
<a name="ln427">#if MWL_AGGR_SIZE == 7935</a>
<a name="ln428">		| IEEE80211_HTCAP_MAXAMSDU_7935	/* max A-MSDU length */</a>
<a name="ln429">#else</a>
<a name="ln430">		| IEEE80211_HTCAP_MAXAMSDU_3839	/* max A-MSDU length */</a>
<a name="ln431">#endif</a>
<a name="ln432">#if 0</a>
<a name="ln433">		| IEEE80211_HTCAP_PSMP		/* PSMP supported */</a>
<a name="ln434">		| IEEE80211_HTCAP_40INTOLERANT	/* 40MHz intolerant */</a>
<a name="ln435">#endif</a>
<a name="ln436">		/* s/w capabilities */</a>
<a name="ln437">		| IEEE80211_HTC_HT		/* HT operation */</a>
<a name="ln438">		| IEEE80211_HTC_AMPDU		/* tx A-MPDU */</a>
<a name="ln439">		| IEEE80211_HTC_AMSDU		/* tx A-MSDU */</a>
<a name="ln440">		| IEEE80211_HTC_SMPS		/* SMPS available */</a>
<a name="ln441">		;</a>
<a name="ln442"> </a>
<a name="ln443">	/*</a>
<a name="ln444">	 * Mark h/w crypto support.</a>
<a name="ln445">	 * XXX no way to query h/w support.</a>
<a name="ln446">	 */</a>
<a name="ln447">	ic-&gt;ic_cryptocaps |= IEEE80211_CRYPTO_WEP</a>
<a name="ln448">			  |  IEEE80211_CRYPTO_AES_CCM</a>
<a name="ln449">			  |  IEEE80211_CRYPTO_TKIP</a>
<a name="ln450">			  |  IEEE80211_CRYPTO_TKIPMIC</a>
<a name="ln451">			  ;</a>
<a name="ln452">	/*</a>
<a name="ln453">	 * Transmit requires space in the packet for a special</a>
<a name="ln454">	 * format transmit record and optional padding between</a>
<a name="ln455">	 * this record and the payload.  Ask the net80211 layer</a>
<a name="ln456">	 * to arrange this when encapsulating packets so we can</a>
<a name="ln457">	 * add it efficiently.</a>
<a name="ln458">	 */</a>
<a name="ln459">	ic-&gt;ic_headroom = sizeof(struct mwltxrec) -</a>
<a name="ln460">		sizeof(struct ieee80211_frame);</a>
<a name="ln461"> </a>
<a name="ln462">	IEEE80211_ADDR_COPY(ic-&gt;ic_macaddr, sc-&gt;sc_hwspecs.macAddr);</a>
<a name="ln463"> </a>
<a name="ln464">	/* call MI attach routine. */</a>
<a name="ln465">	ieee80211_ifattach(ic);</a>
<a name="ln466">	ic-&gt;ic_setregdomain = mwl_setregdomain;</a>
<a name="ln467">	ic-&gt;ic_getradiocaps = mwl_getradiocaps;</a>
<a name="ln468">	/* override default methods */</a>
<a name="ln469">	ic-&gt;ic_raw_xmit = mwl_raw_xmit;</a>
<a name="ln470">	ic-&gt;ic_newassoc = mwl_newassoc;</a>
<a name="ln471">	ic-&gt;ic_updateslot = mwl_updateslot;</a>
<a name="ln472">	ic-&gt;ic_update_mcast = mwl_update_mcast;</a>
<a name="ln473">	ic-&gt;ic_update_promisc = mwl_update_promisc;</a>
<a name="ln474">	ic-&gt;ic_wme.wme_update = mwl_wme_update;</a>
<a name="ln475">	ic-&gt;ic_transmit = mwl_transmit;</a>
<a name="ln476">	ic-&gt;ic_ioctl = mwl_ioctl;</a>
<a name="ln477">	ic-&gt;ic_parent = mwl_parent;</a>
<a name="ln478"> </a>
<a name="ln479">	ic-&gt;ic_node_alloc = mwl_node_alloc;</a>
<a name="ln480">	sc-&gt;sc_node_cleanup = ic-&gt;ic_node_cleanup;</a>
<a name="ln481">	ic-&gt;ic_node_cleanup = mwl_node_cleanup;</a>
<a name="ln482">	sc-&gt;sc_node_drain = ic-&gt;ic_node_drain;</a>
<a name="ln483">	ic-&gt;ic_node_drain = mwl_node_drain;</a>
<a name="ln484">	ic-&gt;ic_node_getsignal = mwl_node_getsignal;</a>
<a name="ln485">	ic-&gt;ic_node_getmimoinfo = mwl_node_getmimoinfo;</a>
<a name="ln486"> </a>
<a name="ln487">	ic-&gt;ic_scan_start = mwl_scan_start;</a>
<a name="ln488">	ic-&gt;ic_scan_end = mwl_scan_end;</a>
<a name="ln489">	ic-&gt;ic_set_channel = mwl_set_channel;</a>
<a name="ln490"> </a>
<a name="ln491">	sc-&gt;sc_recv_action = ic-&gt;ic_recv_action;</a>
<a name="ln492">	ic-&gt;ic_recv_action = mwl_recv_action;</a>
<a name="ln493">	sc-&gt;sc_addba_request = ic-&gt;ic_addba_request;</a>
<a name="ln494">	ic-&gt;ic_addba_request = mwl_addba_request;</a>
<a name="ln495">	sc-&gt;sc_addba_response = ic-&gt;ic_addba_response;</a>
<a name="ln496">	ic-&gt;ic_addba_response = mwl_addba_response;</a>
<a name="ln497">	sc-&gt;sc_addba_stop = ic-&gt;ic_addba_stop;</a>
<a name="ln498">	ic-&gt;ic_addba_stop = mwl_addba_stop;</a>
<a name="ln499"> </a>
<a name="ln500">	ic-&gt;ic_vap_create = mwl_vap_create;</a>
<a name="ln501">	ic-&gt;ic_vap_delete = mwl_vap_delete;</a>
<a name="ln502"> </a>
<a name="ln503">	ieee80211_radiotap_attach(ic,</a>
<a name="ln504">	    &amp;sc-&gt;sc_tx_th.wt_ihdr, sizeof(sc-&gt;sc_tx_th),</a>
<a name="ln505">		MWL_TX_RADIOTAP_PRESENT,</a>
<a name="ln506">	    &amp;sc-&gt;sc_rx_th.wr_ihdr, sizeof(sc-&gt;sc_rx_th),</a>
<a name="ln507">		MWL_RX_RADIOTAP_PRESENT);</a>
<a name="ln508">	/*</a>
<a name="ln509">	 * Setup dynamic sysctl's now that country code and</a>
<a name="ln510">	 * regdomain are available from the hal.</a>
<a name="ln511">	 */</a>
<a name="ln512">	mwl_sysctlattach(sc);</a>
<a name="ln513"> </a>
<a name="ln514">	if (bootverbose)</a>
<a name="ln515">		ieee80211_announce(ic);</a>
<a name="ln516">	mwl_announce(sc);</a>
<a name="ln517">	return 0;</a>
<a name="ln518">bad2:</a>
<a name="ln519">	mwl_dma_cleanup(sc);</a>
<a name="ln520">bad1:</a>
<a name="ln521">	mwl_hal_detach(mh);</a>
<a name="ln522">bad:</a>
<a name="ln523">	MWL_RXFREE_DESTROY(sc);</a>
<a name="ln524">	sc-&gt;sc_invalid = 1;</a>
<a name="ln525">	return error;</a>
<a name="ln526">}</a>
<a name="ln527"> </a>
<a name="ln528">int</a>
<a name="ln529">mwl_detach(struct mwl_softc *sc)</a>
<a name="ln530">{</a>
<a name="ln531">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln532"> </a>
<a name="ln533">	MWL_LOCK(sc);</a>
<a name="ln534">	mwl_stop(sc);</a>
<a name="ln535">	MWL_UNLOCK(sc);</a>
<a name="ln536">	/*</a>
<a name="ln537">	 * NB: the order of these is important:</a>
<a name="ln538">	 * o call the 802.11 layer before detaching the hal to</a>
<a name="ln539">	 *   insure callbacks into the driver to delete global</a>
<a name="ln540">	 *   key cache entries can be handled</a>
<a name="ln541">	 * o reclaim the tx queue data structures after calling</a>
<a name="ln542">	 *   the 802.11 layer as we'll get called back to reclaim</a>
<a name="ln543">	 *   node state and potentially want to use them</a>
<a name="ln544">	 * o to cleanup the tx queues the hal is called, so detach</a>
<a name="ln545">	 *   it last</a>
<a name="ln546">	 * Other than that, it's straightforward...</a>
<a name="ln547">	 */</a>
<a name="ln548">	ieee80211_ifdetach(ic);</a>
<a name="ln549">	callout_drain(&amp;sc-&gt;sc_watchdog);</a>
<a name="ln550">	mwl_dma_cleanup(sc);</a>
<a name="ln551">	MWL_RXFREE_DESTROY(sc);</a>
<a name="ln552">	mwl_tx_cleanup(sc);</a>
<a name="ln553">	mwl_hal_detach(sc-&gt;sc_mh);</a>
<a name="ln554">	mbufq_drain(&amp;sc-&gt;sc_snd);</a>
<a name="ln555"> </a>
<a name="ln556">	return 0;</a>
<a name="ln557">}</a>
<a name="ln558"> </a>
<a name="ln559">/*</a>
<a name="ln560"> * MAC address handling for multiple BSS on the same radio.</a>
<a name="ln561"> * The first vap uses the MAC address from the EEPROM.  For</a>
<a name="ln562"> * subsequent vap's we set the U/L bit (bit 1) in the MAC</a>
<a name="ln563"> * address and use the next six bits as an index.</a>
<a name="ln564"> */</a>
<a name="ln565">static void</a>
<a name="ln566">assign_address(struct mwl_softc *sc, uint8_t mac[IEEE80211_ADDR_LEN], int clone)</a>
<a name="ln567">{</a>
<a name="ln568">	int i;</a>
<a name="ln569"> </a>
<a name="ln570">	if (clone &amp;&amp; mwl_hal_ismbsscapable(sc-&gt;sc_mh)) {</a>
<a name="ln571">		/* NB: we only do this if h/w supports multiple bssid */</a>
<a name="ln572">		for (i = 0; i &lt; 32; i++)</a>
<a name="ln573">			if ((sc-&gt;sc_bssidmask &amp; (1&lt;&lt;i)) == 0)</a>
<a name="ln574">				break;</a>
<a name="ln575">		if (i != 0)</a>
<a name="ln576">			mac[0] |= (i &lt;&lt; 2)|0x2;</a>
<a name="ln577">	} else</a>
<a name="ln578">		i = 0;</a>
<a name="ln579">	sc-&gt;sc_bssidmask |= 1&lt;&lt;i;</a>
<a name="ln580">	if (i == 0)</a>
<a name="ln581">		sc-&gt;sc_nbssid0++;</a>
<a name="ln582">}</a>
<a name="ln583"> </a>
<a name="ln584">static void</a>
<a name="ln585">reclaim_address(struct mwl_softc *sc, const uint8_t mac[IEEE80211_ADDR_LEN])</a>
<a name="ln586">{</a>
<a name="ln587">	int i = mac[0] &gt;&gt; 2;</a>
<a name="ln588">	if (i != 0 || --sc-&gt;sc_nbssid0 == 0)</a>
<a name="ln589">		sc-&gt;sc_bssidmask &amp;= ~(1&lt;&lt;i);</a>
<a name="ln590">}</a>
<a name="ln591"> </a>
<a name="ln592">static struct ieee80211vap *</a>
<a name="ln593">mwl_vap_create(struct ieee80211com *ic, const char name[IFNAMSIZ], int unit,</a>
<a name="ln594">    enum ieee80211_opmode opmode, int flags,</a>
<a name="ln595">    const uint8_t bssid[IEEE80211_ADDR_LEN],</a>
<a name="ln596">    const uint8_t mac0[IEEE80211_ADDR_LEN])</a>
<a name="ln597">{</a>
<a name="ln598">	struct mwl_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln599">	struct mwl_hal *mh = sc-&gt;sc_mh;</a>
<a name="ln600">	struct ieee80211vap *vap, *apvap;</a>
<a name="ln601">	struct mwl_hal_vap *hvap;</a>
<a name="ln602">	struct mwl_vap *mvp;</a>
<a name="ln603">	uint8_t mac[IEEE80211_ADDR_LEN];</a>
<a name="ln604"> </a>
<a name="ln605">	IEEE80211_ADDR_COPY(mac, mac0);</a>
<a name="ln606">	switch (opmode) {</a>
<a name="ln607">	case IEEE80211_M_HOSTAP:</a>
<a name="ln608">	case IEEE80211_M_MBSS:</a>
<a name="ln609">		if ((flags &amp; IEEE80211_CLONE_MACADDR) == 0)</a>
<a name="ln610">			assign_address(sc, mac, flags &amp; IEEE80211_CLONE_BSSID);</a>
<a name="ln611">		hvap = mwl_hal_newvap(mh, MWL_HAL_AP, mac);</a>
<a name="ln612">		if (hvap == NULL) {</a>
<a name="ln613">			if ((flags &amp; IEEE80211_CLONE_MACADDR) == 0)</a>
<a name="ln614">				reclaim_address(sc, mac);</a>
<a name="ln615">			return NULL;</a>
<a name="ln616">		}</a>
<a name="ln617">		break;</a>
<a name="ln618">	case IEEE80211_M_STA:</a>
<a name="ln619">		if ((flags &amp; IEEE80211_CLONE_MACADDR) == 0)</a>
<a name="ln620">			assign_address(sc, mac, flags &amp; IEEE80211_CLONE_BSSID);</a>
<a name="ln621">		hvap = mwl_hal_newvap(mh, MWL_HAL_STA, mac);</a>
<a name="ln622">		if (hvap == NULL) {</a>
<a name="ln623">			if ((flags &amp; IEEE80211_CLONE_MACADDR) == 0)</a>
<a name="ln624">				reclaim_address(sc, mac);</a>
<a name="ln625">			return NULL;</a>
<a name="ln626">		}</a>
<a name="ln627">		/* no h/w beacon miss support; always use s/w */</a>
<a name="ln628">		flags |= IEEE80211_CLONE_NOBEACONS;</a>
<a name="ln629">		break;</a>
<a name="ln630">	case IEEE80211_M_WDS:</a>
<a name="ln631">		hvap = NULL;		/* NB: we use associated AP vap */</a>
<a name="ln632">		if (sc-&gt;sc_napvaps == 0)</a>
<a name="ln633">			return NULL;	/* no existing AP vap */</a>
<a name="ln634">		break;</a>
<a name="ln635">	case IEEE80211_M_MONITOR:</a>
<a name="ln636">		hvap = NULL;</a>
<a name="ln637">		break;</a>
<a name="ln638">	case IEEE80211_M_IBSS:</a>
<a name="ln639">	case IEEE80211_M_AHDEMO:</a>
<a name="ln640">	default:</a>
<a name="ln641">		return NULL;</a>
<a name="ln642">	}</a>
<a name="ln643"> </a>
<a name="ln644">	mvp = malloc(sizeof(struct mwl_vap), M_80211_VAP, M_WAITOK | M_ZERO);</a>
<a name="ln645">	mvp-&gt;mv_hvap = hvap;</a>
<a name="ln646">	if (opmode == IEEE80211_M_WDS) {</a>
<a name="ln647">		/*</a>
<a name="ln648">		 * WDS vaps must have an associated AP vap; find one.</a>
<a name="ln649">		 * XXX not right.</a>
<a name="ln650">		 */</a>
<a name="ln651">		TAILQ_FOREACH(apvap, &amp;ic-&gt;ic_vaps, iv_next)</a>
<a name="ln652">			if (apvap-&gt;iv_opmode == IEEE80211_M_HOSTAP) {</a>
<a name="ln653">				mvp-&gt;mv_ap_hvap = MWL_VAP(apvap)-&gt;mv_hvap;</a>
<a name="ln654">				break;</a>
<a name="ln655">			}</a>
<a name="ln656">		KASSERT(mvp-&gt;mv_ap_hvap != NULL, (&quot;no ap vap&quot;));</a>
<a name="ln657">	}</a>
<a name="ln658">	vap = &amp;mvp-&gt;mv_vap;</a>
<a name="ln659">	ieee80211_vap_setup(ic, vap, name, unit, opmode, flags, bssid);</a>
<a name="ln660">	/* override with driver methods */</a>
<a name="ln661">	mvp-&gt;mv_newstate = vap-&gt;iv_newstate;</a>
<a name="ln662">	vap-&gt;iv_newstate = mwl_newstate;</a>
<a name="ln663">	vap-&gt;iv_max_keyix = 0;	/* XXX */</a>
<a name="ln664">	vap-&gt;iv_key_alloc = mwl_key_alloc;</a>
<a name="ln665">	vap-&gt;iv_key_delete = mwl_key_delete;</a>
<a name="ln666">	vap-&gt;iv_key_set = mwl_key_set;</a>
<a name="ln667">#ifdef MWL_HOST_PS_SUPPORT</a>
<a name="ln668">	if (opmode == IEEE80211_M_HOSTAP || opmode == IEEE80211_M_MBSS) {</a>
<a name="ln669">		vap-&gt;iv_update_ps = mwl_update_ps;</a>
<a name="ln670">		mvp-&gt;mv_set_tim = vap-&gt;iv_set_tim;</a>
<a name="ln671">		vap-&gt;iv_set_tim = mwl_set_tim;</a>
<a name="ln672">	}</a>
<a name="ln673">#endif</a>
<a name="ln674">	vap-&gt;iv_reset = mwl_reset;</a>
<a name="ln675">	vap-&gt;iv_update_beacon = mwl_beacon_update;</a>
<a name="ln676"> </a>
<a name="ln677">	/* override max aid so sta's cannot assoc when we're out of sta id's */</a>
<a name="ln678">	vap-&gt;iv_max_aid = MWL_MAXSTAID;</a>
<a name="ln679">	/* override default A-MPDU rx parameters */</a>
<a name="ln680">	vap-&gt;iv_ampdu_rxmax = IEEE80211_HTCAP_MAXRXAMPDU_64K;</a>
<a name="ln681">	vap-&gt;iv_ampdu_density = IEEE80211_HTCAP_MPDUDENSITY_4;</a>
<a name="ln682"> </a>
<a name="ln683">	/* complete setup */</a>
<a name="ln684">	ieee80211_vap_attach(vap, mwl_media_change, ieee80211_media_status,</a>
<a name="ln685">	    mac);</a>
<a name="ln686"> </a>
<a name="ln687">	switch (vap-&gt;iv_opmode) {</a>
<a name="ln688">	case IEEE80211_M_HOSTAP:</a>
<a name="ln689">	case IEEE80211_M_MBSS:</a>
<a name="ln690">	case IEEE80211_M_STA:</a>
<a name="ln691">		/*</a>
<a name="ln692">		 * Setup sta db entry for local address.</a>
<a name="ln693">		 */</a>
<a name="ln694">		mwl_localstadb(vap);</a>
<a name="ln695">		if (vap-&gt;iv_opmode == IEEE80211_M_HOSTAP ||</a>
<a name="ln696">		    vap-&gt;iv_opmode == IEEE80211_M_MBSS)</a>
<a name="ln697">			sc-&gt;sc_napvaps++;</a>
<a name="ln698">		else</a>
<a name="ln699">			sc-&gt;sc_nstavaps++;</a>
<a name="ln700">		break;</a>
<a name="ln701">	case IEEE80211_M_WDS:</a>
<a name="ln702">		sc-&gt;sc_nwdsvaps++;</a>
<a name="ln703">		break;</a>
<a name="ln704">	default:</a>
<a name="ln705">		break;</a>
<a name="ln706">	}</a>
<a name="ln707">	/*</a>
<a name="ln708">	 * Setup overall operating mode.</a>
<a name="ln709">	 */</a>
<a name="ln710">	if (sc-&gt;sc_napvaps)</a>
<a name="ln711">		ic-&gt;ic_opmode = IEEE80211_M_HOSTAP;</a>
<a name="ln712">	else if (sc-&gt;sc_nstavaps)</a>
<a name="ln713">		ic-&gt;ic_opmode = IEEE80211_M_STA;</a>
<a name="ln714">	else</a>
<a name="ln715">		ic-&gt;ic_opmode = opmode;</a>
<a name="ln716"> </a>
<a name="ln717">	return vap;</a>
<a name="ln718">}</a>
<a name="ln719"> </a>
<a name="ln720">static void</a>
<a name="ln721">mwl_vap_delete(struct ieee80211vap *vap)</a>
<a name="ln722">{</a>
<a name="ln723">	struct mwl_vap *mvp = MWL_VAP(vap);</a>
<a name="ln724">	struct mwl_softc *sc = vap-&gt;iv_ic-&gt;ic_softc;</a>
<a name="ln725">	struct mwl_hal *mh = sc-&gt;sc_mh;</a>
<a name="ln726">	struct mwl_hal_vap *hvap = mvp-&gt;mv_hvap;</a>
<a name="ln727">	enum ieee80211_opmode opmode = vap-&gt;iv_opmode;</a>
<a name="ln728"> </a>
<a name="ln729">	/* XXX disallow ap vap delete if WDS still present */</a>
<a name="ln730">	if (sc-&gt;sc_running) {</a>
<a name="ln731">		/* quiesce h/w while we remove the vap */</a>
<a name="ln732">		mwl_hal_intrset(mh, 0);		/* disable interrupts */</a>
<a name="ln733">	}</a>
<a name="ln734">	ieee80211_vap_detach(vap);</a>
<a name="ln735">	switch (opmode) {</a>
<a name="ln736">	case IEEE80211_M_HOSTAP:</a>
<a name="ln737">	case IEEE80211_M_MBSS:</a>
<a name="ln738">	case IEEE80211_M_STA:</a>
<a name="ln739">		KASSERT(hvap != NULL, (&quot;no hal vap handle&quot;));</a>
<a name="ln740">		(void) mwl_hal_delstation(hvap, vap-&gt;iv_myaddr);</a>
<a name="ln741">		mwl_hal_delvap(hvap);</a>
<a name="ln742">		if (opmode == IEEE80211_M_HOSTAP || opmode == IEEE80211_M_MBSS)</a>
<a name="ln743">			sc-&gt;sc_napvaps--;</a>
<a name="ln744">		else</a>
<a name="ln745">			sc-&gt;sc_nstavaps--;</a>
<a name="ln746">		/* XXX don't do it for IEEE80211_CLONE_MACADDR */</a>
<a name="ln747">		reclaim_address(sc, vap-&gt;iv_myaddr);</a>
<a name="ln748">		break;</a>
<a name="ln749">	case IEEE80211_M_WDS:</a>
<a name="ln750">		sc-&gt;sc_nwdsvaps--;</a>
<a name="ln751">		break;</a>
<a name="ln752">	default:</a>
<a name="ln753">		break;</a>
<a name="ln754">	}</a>
<a name="ln755">	mwl_cleartxq(sc, vap);</a>
<a name="ln756">	free(mvp, M_80211_VAP);</a>
<a name="ln757">	if (sc-&gt;sc_running)</a>
<a name="ln758">		mwl_hal_intrset(mh, sc-&gt;sc_imask);</a>
<a name="ln759">}</a>
<a name="ln760"> </a>
<a name="ln761">void</a>
<a name="ln762">mwl_suspend(struct mwl_softc *sc)</a>
<a name="ln763">{</a>
<a name="ln764"> </a>
<a name="ln765">	MWL_LOCK(sc);</a>
<a name="ln766">	mwl_stop(sc);</a>
<a name="ln767">	MWL_UNLOCK(sc);</a>
<a name="ln768">}</a>
<a name="ln769"> </a>
<a name="ln770">void</a>
<a name="ln771">mwl_resume(struct mwl_softc *sc)</a>
<a name="ln772">{</a>
<a name="ln773">	int error = EDOOFUS;</a>
<a name="ln774"> </a>
<a name="ln775">	MWL_LOCK(sc);</a>
<a name="ln776">	if (sc-&gt;sc_ic.ic_nrunning &gt; 0)</a>
<a name="ln777">		error = mwl_init(sc);</a>
<a name="ln778">	MWL_UNLOCK(sc);</a>
<a name="ln779"> </a>
<a name="ln780">	if (error == 0)</a>
<a name="ln781">		ieee80211_start_all(&amp;sc-&gt;sc_ic);	/* start all vap's */</a>
<a name="ln782">}</a>
<a name="ln783"> </a>
<a name="ln784">void</a>
<a name="ln785">mwl_shutdown(void *arg)</a>
<a name="ln786">{</a>
<a name="ln787">	struct mwl_softc *sc = arg;</a>
<a name="ln788"> </a>
<a name="ln789">	MWL_LOCK(sc);</a>
<a name="ln790">	mwl_stop(sc);</a>
<a name="ln791">	MWL_UNLOCK(sc);</a>
<a name="ln792">}</a>
<a name="ln793"> </a>
<a name="ln794">/*</a>
<a name="ln795"> * Interrupt handler.  Most of the actual processing is deferred.</a>
<a name="ln796"> */</a>
<a name="ln797">void</a>
<a name="ln798">mwl_intr(void *arg)</a>
<a name="ln799">{</a>
<a name="ln800">	struct mwl_softc *sc = arg;</a>
<a name="ln801">	struct mwl_hal *mh = sc-&gt;sc_mh;</a>
<a name="ln802">	uint32_t status;</a>
<a name="ln803"> </a>
<a name="ln804">#if !defined(__HAIKU__)</a>
<a name="ln805">	if (sc-&gt;sc_invalid) {</a>
<a name="ln806">		/*</a>
<a name="ln807">		 * The hardware is not ready/present, don't touch anything.</a>
<a name="ln808">		 * Note this can happen early on if the IRQ is shared.</a>
<a name="ln809">		 */</a>
<a name="ln810">		DPRINTF(sc, MWL_DEBUG_ANY, &quot;%s: invalid; ignored\n&quot;, __func__);</a>
<a name="ln811">		return;</a>
<a name="ln812">	}</a>
<a name="ln813">	/*</a>
<a name="ln814">	 * Figure out the reason(s) for the interrupt.</a>
<a name="ln815">	 */</a>
<a name="ln816">	mwl_hal_getisr(mh, &amp;status);		/* NB: clears ISR too */</a>
<a name="ln817">	if (status == 0)			/* must be a shared irq */</a>
<a name="ln818">		return;</a>
<a name="ln819">#else</a>
<a name="ln820">	status = atomic_get((int32 *)&amp;sc-&gt;sc_intr_status);</a>
<a name="ln821">#endif</a>
<a name="ln822"> </a>
<a name="ln823">	DPRINTF(sc, MWL_DEBUG_INTR, &quot;%s: status 0x%x imask 0x%x\n&quot;,</a>
<a name="ln824">	    __func__, status, sc-&gt;sc_imask);</a>
<a name="ln825">	if (status &amp; MACREG_A2HRIC_BIT_RX_RDY)</a>
<a name="ln826">		taskqueue_enqueue(sc-&gt;sc_tq, &amp;sc-&gt;sc_rxtask);</a>
<a name="ln827">	if (status &amp; MACREG_A2HRIC_BIT_TX_DONE)</a>
<a name="ln828">		taskqueue_enqueue(sc-&gt;sc_tq, &amp;sc-&gt;sc_txtask);</a>
<a name="ln829">	if (status &amp; MACREG_A2HRIC_BIT_BA_WATCHDOG)</a>
<a name="ln830">		taskqueue_enqueue(sc-&gt;sc_tq, &amp;sc-&gt;sc_bawatchdogtask);</a>
<a name="ln831">	if (status &amp; MACREG_A2HRIC_BIT_OPC_DONE)</a>
<a name="ln832">		mwl_hal_cmddone(mh);</a>
<a name="ln833">	if (status &amp; MACREG_A2HRIC_BIT_MAC_EVENT) {</a>
<a name="ln834">		;</a>
<a name="ln835">	}</a>
<a name="ln836">	if (status &amp; MACREG_A2HRIC_BIT_ICV_ERROR) {</a>
<a name="ln837">		/* TKIP ICV error */</a>
<a name="ln838">		sc-&gt;sc_stats.mst_rx_badtkipicv++;</a>
<a name="ln839">	}</a>
<a name="ln840">	if (status &amp; MACREG_A2HRIC_BIT_QUEUE_EMPTY) {</a>
<a name="ln841">		/* 11n aggregation queue is empty, re-fill */</a>
<a name="ln842">		;</a>
<a name="ln843">	}</a>
<a name="ln844">	if (status &amp; MACREG_A2HRIC_BIT_QUEUE_FULL) {</a>
<a name="ln845">		;</a>
<a name="ln846">	}</a>
<a name="ln847">	if (status &amp; MACREG_A2HRIC_BIT_RADAR_DETECT) {</a>
<a name="ln848">		/* radar detected, process event */</a>
<a name="ln849">		taskqueue_enqueue(sc-&gt;sc_tq, &amp;sc-&gt;sc_radartask);</a>
<a name="ln850">	}</a>
<a name="ln851">	if (status &amp; MACREG_A2HRIC_BIT_CHAN_SWITCH) {</a>
<a name="ln852">		/* DFS channel switch */</a>
<a name="ln853">		taskqueue_enqueue(sc-&gt;sc_tq, &amp;sc-&gt;sc_chanswitchtask);</a>
<a name="ln854">	}</a>
<a name="ln855">}</a>
<a name="ln856"> </a>
<a name="ln857">static void</a>
<a name="ln858">mwl_radar_proc(void *arg, int pending)</a>
<a name="ln859">{</a>
<a name="ln860">	struct mwl_softc *sc = arg;</a>
<a name="ln861">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln862"> </a>
<a name="ln863">	DPRINTF(sc, MWL_DEBUG_ANY, &quot;%s: radar detected, pending %u\n&quot;,</a>
<a name="ln864">	    __func__, pending);</a>
<a name="ln865"> </a>
<a name="ln866">	sc-&gt;sc_stats.mst_radardetect++;</a>
<a name="ln867">	/* XXX stop h/w BA streams? */</a>
<a name="ln868"> </a>
<a name="ln869">	IEEE80211_LOCK(ic);</a>
<a name="ln870">	ieee80211_dfs_notify_radar(ic, ic-&gt;ic_curchan);</a>
<a name="ln871">	IEEE80211_UNLOCK(ic);</a>
<a name="ln872">}</a>
<a name="ln873"> </a>
<a name="ln874">static void</a>
<a name="ln875">mwl_chanswitch_proc(void *arg, int pending)</a>
<a name="ln876">{</a>
<a name="ln877">	struct mwl_softc *sc = arg;</a>
<a name="ln878">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln879"> </a>
<a name="ln880">	DPRINTF(sc, MWL_DEBUG_ANY, &quot;%s: channel switch notice, pending %u\n&quot;,</a>
<a name="ln881">	    __func__, pending);</a>
<a name="ln882"> </a>
<a name="ln883">	IEEE80211_LOCK(ic);</a>
<a name="ln884">	sc-&gt;sc_csapending = 0;</a>
<a name="ln885">	ieee80211_csa_completeswitch(ic);</a>
<a name="ln886">	IEEE80211_UNLOCK(ic);</a>
<a name="ln887">}</a>
<a name="ln888"> </a>
<a name="ln889">static void</a>
<a name="ln890">mwl_bawatchdog(const MWL_HAL_BASTREAM *sp)</a>
<a name="ln891">{</a>
<a name="ln892">	struct ieee80211_node *ni = sp-&gt;data[0];</a>
<a name="ln893"> </a>
<a name="ln894">	/* send DELBA and drop the stream */</a>
<a name="ln895">	ieee80211_ampdu_stop(ni, sp-&gt;data[1], IEEE80211_REASON_UNSPECIFIED);</a>
<a name="ln896">}</a>
<a name="ln897"> </a>
<a name="ln898">static void</a>
<a name="ln899">mwl_bawatchdog_proc(void *arg, int pending)</a>
<a name="ln900">{</a>
<a name="ln901">	struct mwl_softc *sc = arg;</a>
<a name="ln902">	struct mwl_hal *mh = sc-&gt;sc_mh;</a>
<a name="ln903">	const MWL_HAL_BASTREAM *sp;</a>
<a name="ln904">	uint8_t bitmap, n;</a>
<a name="ln905"> </a>
<a name="ln906">	sc-&gt;sc_stats.mst_bawatchdog++;</a>
<a name="ln907"> </a>
<a name="ln908">	if (mwl_hal_getwatchdogbitmap(mh, &amp;bitmap) != 0) {</a>
<a name="ln909">		DPRINTF(sc, MWL_DEBUG_AMPDU,</a>
<a name="ln910">		    &quot;%s: could not get bitmap\n&quot;, __func__);</a>
<a name="ln911">		sc-&gt;sc_stats.mst_bawatchdog_failed++;</a>
<a name="ln912">		return;</a>
<a name="ln913">	}</a>
<a name="ln914">	DPRINTF(sc, MWL_DEBUG_AMPDU, &quot;%s: bitmap 0x%x\n&quot;, __func__, bitmap);</a>
<a name="ln915">	if (bitmap == 0xff) {</a>
<a name="ln916">		n = 0;</a>
<a name="ln917">		/* disable all ba streams */</a>
<a name="ln918">		for (bitmap = 0; bitmap &lt; 8; bitmap++) {</a>
<a name="ln919">			sp = mwl_hal_bastream_lookup(mh, bitmap);</a>
<a name="ln920">			if (sp != NULL) {</a>
<a name="ln921">				mwl_bawatchdog(sp);</a>
<a name="ln922">				n++;</a>
<a name="ln923">			}</a>
<a name="ln924">		}</a>
<a name="ln925">		if (n == 0) {</a>
<a name="ln926">			DPRINTF(sc, MWL_DEBUG_AMPDU,</a>
<a name="ln927">			    &quot;%s: no BA streams found\n&quot;, __func__);</a>
<a name="ln928">			sc-&gt;sc_stats.mst_bawatchdog_empty++;</a>
<a name="ln929">		}</a>
<a name="ln930">	} else if (bitmap != 0xaa) {</a>
<a name="ln931">		/* disable a single ba stream */</a>
<a name="ln932">		sp = mwl_hal_bastream_lookup(mh, bitmap);</a>
<a name="ln933">		if (sp != NULL) {</a>
<a name="ln934">			mwl_bawatchdog(sp);</a>
<a name="ln935">		} else {</a>
<a name="ln936">			DPRINTF(sc, MWL_DEBUG_AMPDU,</a>
<a name="ln937">			    &quot;%s: no BA stream %d\n&quot;, __func__, bitmap);</a>
<a name="ln938">			sc-&gt;sc_stats.mst_bawatchdog_notfound++;</a>
<a name="ln939">		}</a>
<a name="ln940">	}</a>
<a name="ln941">}</a>
<a name="ln942"> </a>
<a name="ln943">/*</a>
<a name="ln944"> * Convert net80211 channel to a HAL channel.</a>
<a name="ln945"> */</a>
<a name="ln946">static void</a>
<a name="ln947">mwl_mapchan(MWL_HAL_CHANNEL *hc, const struct ieee80211_channel *chan)</a>
<a name="ln948">{</a>
<a name="ln949">	hc-&gt;channel = chan-&gt;ic_ieee;</a>
<a name="ln950"> </a>
<a name="ln951">	*(uint32_t *)&amp;hc-&gt;channelFlags = 0;</a>
<a name="ln952">	if (IEEE80211_IS_CHAN_2GHZ(chan))</a>
<a name="ln953">		hc-&gt;channelFlags.FreqBand = MWL_FREQ_BAND_2DOT4GHZ;</a>
<a name="ln954">	else if (IEEE80211_IS_CHAN_5GHZ(chan))</a>
<a name="ln955">		hc-&gt;channelFlags.FreqBand = MWL_FREQ_BAND_5GHZ;</a>
<a name="ln956">	if (IEEE80211_IS_CHAN_HT40(chan)) {</a>
<a name="ln957">		hc-&gt;channelFlags.ChnlWidth = MWL_CH_40_MHz_WIDTH;</a>
<a name="ln958">		if (IEEE80211_IS_CHAN_HT40U(chan))</a>
<a name="ln959">			hc-&gt;channelFlags.ExtChnlOffset = MWL_EXT_CH_ABOVE_CTRL_CH;</a>
<a name="ln960">		else</a>
<a name="ln961">			hc-&gt;channelFlags.ExtChnlOffset = MWL_EXT_CH_BELOW_CTRL_CH;</a>
<a name="ln962">	} else</a>
<a name="ln963">		hc-&gt;channelFlags.ChnlWidth = MWL_CH_20_MHz_WIDTH;</a>
<a name="ln964">	/* XXX 10MHz channels */</a>
<a name="ln965">}</a>
<a name="ln966"> </a>
<a name="ln967">/*</a>
<a name="ln968"> * Inform firmware of our tx/rx dma setup.  The BAR 0</a>
<a name="ln969"> * writes below are for compatibility with older firmware.</a>
<a name="ln970"> * For current firmware we send this information with a</a>
<a name="ln971"> * cmd block via mwl_hal_sethwdma.</a>
<a name="ln972"> */</a>
<a name="ln973">static int</a>
<a name="ln974">mwl_setupdma(struct mwl_softc *sc)</a>
<a name="ln975">{</a>
<a name="ln976">	int error, i;</a>
<a name="ln977"> </a>
<a name="ln978">	sc-&gt;sc_hwdma.rxDescRead = sc-&gt;sc_rxdma.dd_desc_paddr;</a>
<a name="ln979">	WR4(sc, sc-&gt;sc_hwspecs.rxDescRead, sc-&gt;sc_hwdma.rxDescRead);</a>
<a name="ln980">	WR4(sc, sc-&gt;sc_hwspecs.rxDescWrite, sc-&gt;sc_hwdma.rxDescRead);</a>
<a name="ln981"> </a>
<a name="ln982">	for (i = 0; i &lt; MWL_NUM_TX_QUEUES-MWL_NUM_ACK_QUEUES; i++) {</a>
<a name="ln983">		struct mwl_txq *txq = &amp;sc-&gt;sc_txq[i];</a>
<a name="ln984">		sc-&gt;sc_hwdma.wcbBase[i] = txq-&gt;dma.dd_desc_paddr;</a>
<a name="ln985">		WR4(sc, sc-&gt;sc_hwspecs.wcbBase[i], sc-&gt;sc_hwdma.wcbBase[i]);</a>
<a name="ln986">	}</a>
<a name="ln987">	sc-&gt;sc_hwdma.maxNumTxWcb = mwl_txbuf;</a>
<a name="ln988">	sc-&gt;sc_hwdma.maxNumWCB = MWL_NUM_TX_QUEUES-MWL_NUM_ACK_QUEUES;</a>
<a name="ln989"> </a>
<a name="ln990">	error = mwl_hal_sethwdma(sc-&gt;sc_mh, &amp;sc-&gt;sc_hwdma);</a>
<a name="ln991">	if (error != 0) {</a>
<a name="ln992">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln993">		    &quot;unable to setup tx/rx dma; hal status %u\n&quot;, error);</a>
<a name="ln994">		/* XXX */</a>
<a name="ln995">	}</a>
<a name="ln996">	return error;</a>
<a name="ln997">}</a>
<a name="ln998"> </a>
<a name="ln999">/*</a>
<a name="ln1000"> * Inform firmware of tx rate parameters.</a>
<a name="ln1001"> * Called after a channel change.</a>
<a name="ln1002"> */</a>
<a name="ln1003">static int</a>
<a name="ln1004">mwl_setcurchanrates(struct mwl_softc *sc)</a>
<a name="ln1005">{</a>
<a name="ln1006">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1007">	const struct ieee80211_rateset *rs;</a>
<a name="ln1008">	MWL_HAL_TXRATE rates;</a>
<a name="ln1009"> </a>
<a name="ln1010">	memset(&amp;rates, 0, sizeof(rates));</a>
<a name="ln1011">	rs = ieee80211_get_suprates(ic, ic-&gt;ic_curchan);</a>
<a name="ln1012">	/* rate used to send management frames */</a>
<a name="ln1013">	rates.MgtRate = rs-&gt;rs_rates[0] &amp; IEEE80211_RATE_VAL;</a>
<a name="ln1014">	/* rate used to send multicast frames */</a>
<a name="ln1015">	rates.McastRate = rates.MgtRate;</a>
<a name="ln1016"> </a>
<a name="ln1017">	return mwl_hal_settxrate_auto(sc-&gt;sc_mh, &amp;rates);</a>
<a name="ln1018">}</a>
<a name="ln1019"> </a>
<a name="ln1020">/*</a>
<a name="ln1021"> * Inform firmware of tx rate parameters.  Called whenever</a>
<a name="ln1022"> * user-settable params change and after a channel change.</a>
<a name="ln1023"> */</a>
<a name="ln1024">static int</a>
<a name="ln1025">mwl_setrates(struct ieee80211vap *vap)</a>
<a name="ln1026">{</a>
<a name="ln1027">	struct mwl_vap *mvp = MWL_VAP(vap);</a>
<a name="ln1028">	struct ieee80211_node *ni = vap-&gt;iv_bss;</a>
<a name="ln1029">	const struct ieee80211_txparam *tp = ni-&gt;ni_txparms;</a>
<a name="ln1030">	MWL_HAL_TXRATE rates;</a>
<a name="ln1031"> </a>
<a name="ln1032">	KASSERT(vap-&gt;iv_state == IEEE80211_S_RUN, (&quot;state %d&quot;, vap-&gt;iv_state));</a>
<a name="ln1033"> </a>
<a name="ln1034">	/*</a>
<a name="ln1035">	 * Update the h/w rate map.</a>
<a name="ln1036">	 * NB: 0x80 for MCS is passed through unchanged</a>
<a name="ln1037">	 */</a>
<a name="ln1038">	memset(&amp;rates, 0, sizeof(rates));</a>
<a name="ln1039">	/* rate used to send management frames */</a>
<a name="ln1040">	rates.MgtRate = tp-&gt;mgmtrate;</a>
<a name="ln1041">	/* rate used to send multicast frames */</a>
<a name="ln1042">	rates.McastRate = tp-&gt;mcastrate;</a>
<a name="ln1043"> </a>
<a name="ln1044">	/* while here calculate EAPOL fixed rate cookie */</a>
<a name="ln1045">	mvp-&gt;mv_eapolformat = htole16(mwl_calcformat(rates.MgtRate, ni));</a>
<a name="ln1046"> </a>
<a name="ln1047">	return mwl_hal_settxrate(mvp-&gt;mv_hvap,</a>
<a name="ln1048">	    tp-&gt;ucastrate != IEEE80211_FIXED_RATE_NONE ?</a>
<a name="ln1049">		RATE_FIXED : RATE_AUTO, &amp;rates);</a>
<a name="ln1050">}</a>
<a name="ln1051"> </a>
<a name="ln1052">/*</a>
<a name="ln1053"> * Setup a fixed xmit rate cookie for EAPOL frames.</a>
<a name="ln1054"> */</a>
<a name="ln1055">static void</a>
<a name="ln1056">mwl_seteapolformat(struct ieee80211vap *vap)</a>
<a name="ln1057">{</a>
<a name="ln1058">	struct mwl_vap *mvp = MWL_VAP(vap);</a>
<a name="ln1059">	struct ieee80211_node *ni = vap-&gt;iv_bss;</a>
<a name="ln1060">	enum ieee80211_phymode mode;</a>
<a name="ln1061">	uint8_t rate;</a>
<a name="ln1062"> </a>
<a name="ln1063">	KASSERT(vap-&gt;iv_state == IEEE80211_S_RUN, (&quot;state %d&quot;, vap-&gt;iv_state));</a>
<a name="ln1064"> </a>
<a name="ln1065">	mode = ieee80211_chan2mode(ni-&gt;ni_chan);</a>
<a name="ln1066">	/*</a>
<a name="ln1067">	 * Use legacy rates when operating a mixed HT+non-HT bss.</a>
<a name="ln1068">	 * NB: this may violate POLA for sta and wds vap's.</a>
<a name="ln1069">	 */</a>
<a name="ln1070">	if (mode == IEEE80211_MODE_11NA &amp;&amp;</a>
<a name="ln1071">	    (vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_PUREN) == 0)</a>
<a name="ln1072">		rate = vap-&gt;iv_txparms[IEEE80211_MODE_11A].mgmtrate;</a>
<a name="ln1073">	else if (mode == IEEE80211_MODE_11NG &amp;&amp;</a>
<a name="ln1074">	    (vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_PUREN) == 0)</a>
<a name="ln1075">		rate = vap-&gt;iv_txparms[IEEE80211_MODE_11G].mgmtrate;</a>
<a name="ln1076">	else</a>
<a name="ln1077">		rate = vap-&gt;iv_txparms[mode].mgmtrate;</a>
<a name="ln1078"> </a>
<a name="ln1079">	mvp-&gt;mv_eapolformat = htole16(mwl_calcformat(rate, ni));</a>
<a name="ln1080">}</a>
<a name="ln1081"> </a>
<a name="ln1082">/*</a>
<a name="ln1083"> * Map SKU+country code to region code for radar bin'ing.</a>
<a name="ln1084"> */</a>
<a name="ln1085">static int</a>
<a name="ln1086">mwl_map2regioncode(const struct ieee80211_regdomain *rd)</a>
<a name="ln1087">{</a>
<a name="ln1088">	switch (rd-&gt;regdomain) {</a>
<a name="ln1089">	case SKU_FCC:</a>
<a name="ln1090">	case SKU_FCC3:</a>
<a name="ln1091">		return DOMAIN_CODE_FCC;</a>
<a name="ln1092">	case SKU_CA:</a>
<a name="ln1093">		return DOMAIN_CODE_IC;</a>
<a name="ln1094">	case SKU_ETSI:</a>
<a name="ln1095">	case SKU_ETSI2:</a>
<a name="ln1096">	case SKU_ETSI3:</a>
<a name="ln1097">		if (rd-&gt;country == CTRY_SPAIN)</a>
<a name="ln1098">			return DOMAIN_CODE_SPAIN;</a>
<a name="ln1099">		if (rd-&gt;country == CTRY_FRANCE || rd-&gt;country == CTRY_FRANCE2)</a>
<a name="ln1100">			return DOMAIN_CODE_FRANCE;</a>
<a name="ln1101">		/* XXX force 1.3.1 radar type */</a>
<a name="ln1102">		return DOMAIN_CODE_ETSI_131;</a>
<a name="ln1103">	case SKU_JAPAN:</a>
<a name="ln1104">		return DOMAIN_CODE_MKK;</a>
<a name="ln1105">	case SKU_ROW:</a>
<a name="ln1106">		return DOMAIN_CODE_DGT;	/* Taiwan */</a>
<a name="ln1107">	case SKU_APAC:</a>
<a name="ln1108">	case SKU_APAC2:</a>
<a name="ln1109">	case SKU_APAC3:</a>
<a name="ln1110">		return DOMAIN_CODE_AUS;	/* Australia */</a>
<a name="ln1111">	}</a>
<a name="ln1112">	/* XXX KOREA? */</a>
<a name="ln1113">	return DOMAIN_CODE_FCC;			/* XXX? */</a>
<a name="ln1114">}</a>
<a name="ln1115"> </a>
<a name="ln1116">static int</a>
<a name="ln1117">mwl_hal_reset(struct mwl_softc *sc)</a>
<a name="ln1118">{</a>
<a name="ln1119">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1120">	struct mwl_hal *mh = sc-&gt;sc_mh;</a>
<a name="ln1121"> </a>
<a name="ln1122">	mwl_hal_setantenna(mh, WL_ANTENNATYPE_RX, sc-&gt;sc_rxantenna);</a>
<a name="ln1123">	mwl_hal_setantenna(mh, WL_ANTENNATYPE_TX, sc-&gt;sc_txantenna);</a>
<a name="ln1124">	mwl_hal_setradio(mh, 1, WL_AUTO_PREAMBLE);</a>
<a name="ln1125">	mwl_hal_setwmm(sc-&gt;sc_mh, (ic-&gt;ic_flags &amp; IEEE80211_F_WME) != 0);</a>
<a name="ln1126">	mwl_chan_set(sc, ic-&gt;ic_curchan);</a>
<a name="ln1127">	/* NB: RF/RA performance tuned for indoor mode */</a>
<a name="ln1128">	mwl_hal_setrateadaptmode(mh, 0);</a>
<a name="ln1129">	mwl_hal_setoptimizationlevel(mh,</a>
<a name="ln1130">	    (ic-&gt;ic_flags &amp; IEEE80211_F_BURST) != 0);</a>
<a name="ln1131"> </a>
<a name="ln1132">	mwl_hal_setregioncode(mh, mwl_map2regioncode(&amp;ic-&gt;ic_regdomain));</a>
<a name="ln1133"> </a>
<a name="ln1134">	mwl_hal_setaggampduratemode(mh, 1, 80);		/* XXX */</a>
<a name="ln1135">	mwl_hal_setcfend(mh, 0);			/* XXX */</a>
<a name="ln1136"> </a>
<a name="ln1137">	return 1;</a>
<a name="ln1138">}</a>
<a name="ln1139"> </a>
<a name="ln1140">static int</a>
<a name="ln1141">mwl_init(struct mwl_softc *sc)</a>
<a name="ln1142">{</a>
<a name="ln1143">	struct mwl_hal *mh = sc-&gt;sc_mh;</a>
<a name="ln1144">	int error = 0;</a>
<a name="ln1145"> </a>
<a name="ln1146">	MWL_LOCK_ASSERT(sc);</a>
<a name="ln1147"> </a>
<a name="ln1148">	/*</a>
<a name="ln1149">	 * Stop anything previously setup.  This is safe</a>
<a name="ln1150">	 * whether this is the first time through or not.</a>
<a name="ln1151">	 */</a>
<a name="ln1152">	mwl_stop(sc);</a>
<a name="ln1153"> </a>
<a name="ln1154">	/*</a>
<a name="ln1155">	 * Push vap-independent state to the firmware.</a>
<a name="ln1156">	 */</a>
<a name="ln1157">	if (!mwl_hal_reset(sc)) {</a>
<a name="ln1158">		device_printf(sc-&gt;sc_dev, &quot;unable to reset hardware\n&quot;);</a>
<a name="ln1159">		return EIO;</a>
<a name="ln1160">	}</a>
<a name="ln1161"> </a>
<a name="ln1162">	/*</a>
<a name="ln1163">	 * Setup recv (once); transmit is already good to go.</a>
<a name="ln1164">	 */</a>
<a name="ln1165">	error = mwl_startrecv(sc);</a>
<a name="ln1166">	if (error != 0) {</a>
<a name="ln1167">		device_printf(sc-&gt;sc_dev, &quot;unable to start recv logic\n&quot;);</a>
<a name="ln1168">		return error;</a>
<a name="ln1169">	}</a>
<a name="ln1170"> </a>
<a name="ln1171">	/*</a>
<a name="ln1172">	 * Enable interrupts.</a>
<a name="ln1173">	 */</a>
<a name="ln1174">	sc-&gt;sc_imask = MACREG_A2HRIC_BIT_RX_RDY</a>
<a name="ln1175">		     | MACREG_A2HRIC_BIT_TX_DONE</a>
<a name="ln1176">		     | MACREG_A2HRIC_BIT_OPC_DONE</a>
<a name="ln1177">#if 0</a>
<a name="ln1178">		     | MACREG_A2HRIC_BIT_MAC_EVENT</a>
<a name="ln1179">#endif</a>
<a name="ln1180">		     | MACREG_A2HRIC_BIT_ICV_ERROR</a>
<a name="ln1181">		     | MACREG_A2HRIC_BIT_RADAR_DETECT</a>
<a name="ln1182">		     | MACREG_A2HRIC_BIT_CHAN_SWITCH</a>
<a name="ln1183">#if 0</a>
<a name="ln1184">		     | MACREG_A2HRIC_BIT_QUEUE_EMPTY</a>
<a name="ln1185">#endif</a>
<a name="ln1186">		     | MACREG_A2HRIC_BIT_BA_WATCHDOG</a>
<a name="ln1187">		     | MACREQ_A2HRIC_BIT_TX_ACK</a>
<a name="ln1188">		     ;</a>
<a name="ln1189"> </a>
<a name="ln1190">	sc-&gt;sc_running = 1;</a>
<a name="ln1191">	mwl_hal_intrset(mh, sc-&gt;sc_imask);</a>
<a name="ln1192">	callout_reset(&amp;sc-&gt;sc_watchdog, hz, mwl_watchdog, sc);</a>
<a name="ln1193"> </a>
<a name="ln1194">	return 0;</a>
<a name="ln1195">}</a>
<a name="ln1196"> </a>
<a name="ln1197">static void</a>
<a name="ln1198">mwl_stop(struct mwl_softc *sc)</a>
<a name="ln1199">{</a>
<a name="ln1200"> </a>
<a name="ln1201">	MWL_LOCK_ASSERT(sc);</a>
<a name="ln1202">	if (sc-&gt;sc_running) {</a>
<a name="ln1203">		/*</a>
<a name="ln1204">		 * Shutdown the hardware and driver.</a>
<a name="ln1205">		 */</a>
<a name="ln1206">		sc-&gt;sc_running = 0;</a>
<a name="ln1207">		callout_stop(&amp;sc-&gt;sc_watchdog);</a>
<a name="ln1208">		sc-&gt;sc_tx_timer = 0;</a>
<a name="ln1209">		mwl_draintxq(sc);</a>
<a name="ln1210">	}</a>
<a name="ln1211">}</a>
<a name="ln1212"> </a>
<a name="ln1213">static int</a>
<a name="ln1214">mwl_reset_vap(struct ieee80211vap *vap, int state)</a>
<a name="ln1215">{</a>
<a name="ln1216">	struct mwl_hal_vap *hvap = MWL_VAP(vap)-&gt;mv_hvap;</a>
<a name="ln1217">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln1218"> </a>
<a name="ln1219">	if (state == IEEE80211_S_RUN)</a>
<a name="ln1220">		mwl_setrates(vap);</a>
<a name="ln1221">	/* XXX off by 1? */</a>
<a name="ln1222">	mwl_hal_setrtsthreshold(hvap, vap-&gt;iv_rtsthreshold);</a>
<a name="ln1223">	/* XXX auto? 20/40 split? */</a>
<a name="ln1224">	mwl_hal_sethtgi(hvap, (vap-&gt;iv_flags_ht &amp;</a>
<a name="ln1225">	    (IEEE80211_FHT_SHORTGI20|IEEE80211_FHT_SHORTGI40)) ? 1 : 0);</a>
<a name="ln1226">	mwl_hal_setnprot(hvap, ic-&gt;ic_htprotmode == IEEE80211_PROT_NONE ?</a>
<a name="ln1227">	    HTPROTECT_NONE : HTPROTECT_AUTO);</a>
<a name="ln1228">	/* XXX txpower cap */</a>
<a name="ln1229"> </a>
<a name="ln1230">	/* re-setup beacons */</a>
<a name="ln1231">	if (state == IEEE80211_S_RUN &amp;&amp;</a>
<a name="ln1232">	    (vap-&gt;iv_opmode == IEEE80211_M_HOSTAP ||</a>
<a name="ln1233">	     vap-&gt;iv_opmode == IEEE80211_M_MBSS ||</a>
<a name="ln1234">	     vap-&gt;iv_opmode == IEEE80211_M_IBSS)) {</a>
<a name="ln1235">		mwl_setapmode(vap, vap-&gt;iv_bss-&gt;ni_chan);</a>
<a name="ln1236">		mwl_hal_setnprotmode(hvap,</a>
<a name="ln1237">		    MS(ic-&gt;ic_curhtprotmode, IEEE80211_HTINFO_OPMODE));</a>
<a name="ln1238">		return mwl_beacon_setup(vap);</a>
<a name="ln1239">	}</a>
<a name="ln1240">	return 0;</a>
<a name="ln1241">}</a>
<a name="ln1242"> </a>
<a name="ln1243">/*</a>
<a name="ln1244"> * Reset the hardware w/o losing operational state.</a>
<a name="ln1245"> * Used to reset or reload hardware state for a vap.</a>
<a name="ln1246"> */</a>
<a name="ln1247">static int</a>
<a name="ln1248">mwl_reset(struct ieee80211vap *vap, u_long cmd)</a>
<a name="ln1249">{</a>
<a name="ln1250">	struct mwl_hal_vap *hvap = MWL_VAP(vap)-&gt;mv_hvap;</a>
<a name="ln1251">	int error = 0;</a>
<a name="ln1252"> </a>
<a name="ln1253">	if (hvap != NULL) {			/* WDS, MONITOR, etc. */</a>
<a name="ln1254">		struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln1255">		struct mwl_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1256">		struct mwl_hal *mh = sc-&gt;sc_mh;</a>
<a name="ln1257"> </a>
<a name="ln1258">		/* XXX handle DWDS sta vap change */</a>
<a name="ln1259">		/* XXX do we need to disable interrupts? */</a>
<a name="ln1260">		mwl_hal_intrset(mh, 0);		/* disable interrupts */</a>
<a name="ln1261">		error = mwl_reset_vap(vap, vap-&gt;iv_state);</a>
<a name="ln1262">		mwl_hal_intrset(mh, sc-&gt;sc_imask);</a>
<a name="ln1263">	}</a>
<a name="ln1264">	return error;</a>
<a name="ln1265">}</a>
<a name="ln1266"> </a>
<a name="ln1267">/*</a>
<a name="ln1268"> * Allocate a tx buffer for sending a frame.  The</a>
<a name="ln1269"> * packet is assumed to have the WME AC stored so</a>
<a name="ln1270"> * we can use it to select the appropriate h/w queue.</a>
<a name="ln1271"> */</a>
<a name="ln1272">static struct mwl_txbuf *</a>
<a name="ln1273">mwl_gettxbuf(struct mwl_softc *sc, struct mwl_txq *txq)</a>
<a name="ln1274">{</a>
<a name="ln1275">	struct mwl_txbuf *bf;</a>
<a name="ln1276"> </a>
<a name="ln1277">	/*</a>
<a name="ln1278">	 * Grab a TX buffer and associated resources.</a>
<a name="ln1279">	 */</a>
<a name="ln1280">	MWL_TXQ_LOCK(txq);</a>
<a name="ln1281">	bf = STAILQ_FIRST(&amp;txq-&gt;free);</a>
<a name="ln1282">	if (bf != NULL) {</a>
<a name="ln1283">		STAILQ_REMOVE_HEAD(&amp;txq-&gt;free, bf_list);</a>
<a name="ln1284">		txq-&gt;nfree--;</a>
<a name="ln1285">	}</a>
<a name="ln1286">	MWL_TXQ_UNLOCK(txq);</a>
<a name="ln1287">	if (bf == NULL)</a>
<a name="ln1288">		DPRINTF(sc, MWL_DEBUG_XMIT,</a>
<a name="ln1289">		    &quot;%s: out of xmit buffers on q %d\n&quot;, __func__, txq-&gt;qnum);</a>
<a name="ln1290">	return bf;</a>
<a name="ln1291">}</a>
<a name="ln1292"> </a>
<a name="ln1293">/*</a>
<a name="ln1294"> * Return a tx buffer to the queue it came from.  Note there</a>
<a name="ln1295"> * are two cases because we must preserve the order of buffers</a>
<a name="ln1296"> * as it reflects the fixed order of descriptors in memory</a>
<a name="ln1297"> * (the firmware pre-fetches descriptors so we cannot reorder).</a>
<a name="ln1298"> */</a>
<a name="ln1299">static void</a>
<a name="ln1300">mwl_puttxbuf_head(struct mwl_txq *txq, struct mwl_txbuf *bf)</a>
<a name="ln1301">{</a>
<a name="ln1302">	bf-&gt;bf_m = NULL;</a>
<a name="ln1303">	bf-&gt;bf_node = NULL;</a>
<a name="ln1304">	MWL_TXQ_LOCK(txq);</a>
<a name="ln1305">	STAILQ_INSERT_HEAD(&amp;txq-&gt;free, bf, bf_list);</a>
<a name="ln1306">	txq-&gt;nfree++;</a>
<a name="ln1307">	MWL_TXQ_UNLOCK(txq);</a>
<a name="ln1308">}</a>
<a name="ln1309"> </a>
<a name="ln1310">static void</a>
<a name="ln1311">mwl_puttxbuf_tail(struct mwl_txq *txq, struct mwl_txbuf *bf)</a>
<a name="ln1312">{</a>
<a name="ln1313">	bf-&gt;bf_m = NULL;</a>
<a name="ln1314">	bf-&gt;bf_node = NULL;</a>
<a name="ln1315">	MWL_TXQ_LOCK(txq);</a>
<a name="ln1316">	STAILQ_INSERT_TAIL(&amp;txq-&gt;free, bf, bf_list);</a>
<a name="ln1317">	txq-&gt;nfree++;</a>
<a name="ln1318">	MWL_TXQ_UNLOCK(txq);</a>
<a name="ln1319">}</a>
<a name="ln1320"> </a>
<a name="ln1321">static int</a>
<a name="ln1322">mwl_transmit(struct ieee80211com *ic, struct mbuf *m)</a>
<a name="ln1323">{</a>
<a name="ln1324">	struct mwl_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1325">	int error;</a>
<a name="ln1326"> </a>
<a name="ln1327">	MWL_LOCK(sc);</a>
<a name="ln1328">	if (!sc-&gt;sc_running) {</a>
<a name="ln1329">		MWL_UNLOCK(sc);</a>
<a name="ln1330">		return (ENXIO);</a>
<a name="ln1331">	}</a>
<a name="ln1332">	error = mbufq_enqueue(&amp;sc-&gt;sc_snd, m);</a>
<a name="ln1333">	if (error) {</a>
<a name="ln1334">		MWL_UNLOCK(sc);</a>
<a name="ln1335">		return (error);</a>
<a name="ln1336">	}</a>
<a name="ln1337">	mwl_start(sc);</a>
<a name="ln1338">	MWL_UNLOCK(sc);</a>
<a name="ln1339">	return (0);</a>
<a name="ln1340">}</a>
<a name="ln1341"> </a>
<a name="ln1342">static void</a>
<a name="ln1343">mwl_start(struct mwl_softc *sc)</a>
<a name="ln1344">{</a>
<a name="ln1345">	struct ieee80211_node *ni;</a>
<a name="ln1346">	struct mwl_txbuf *bf;</a>
<a name="ln1347">	struct mbuf *m;</a>
<a name="ln1348">	struct mwl_txq *txq = NULL;	/* XXX silence gcc */</a>
<a name="ln1349">	int nqueued;</a>
<a name="ln1350"> </a>
<a name="ln1351">	MWL_LOCK_ASSERT(sc);</a>
<a name="ln1352">	if (!sc-&gt;sc_running || sc-&gt;sc_invalid)</a>
<a name="ln1353">		return;</a>
<a name="ln1354">	nqueued = 0;</a>
<a name="ln1355">	while ((m = mbufq_dequeue(&amp;sc-&gt;sc_snd)) != NULL) {</a>
<a name="ln1356">		/*</a>
<a name="ln1357">		 * Grab the node for the destination.</a>
<a name="ln1358">		 */</a>
<a name="ln1359">		ni = (struct ieee80211_node *) m-&gt;m_pkthdr.rcvif;</a>
<a name="ln1360">		KASSERT(ni != NULL, (&quot;no node&quot;));</a>
<a name="ln1361">		m-&gt;m_pkthdr.rcvif = NULL;	/* committed, clear ref */</a>
<a name="ln1362">		/*</a>
<a name="ln1363">		 * Grab a TX buffer and associated resources.</a>
<a name="ln1364">		 * We honor the classification by the 802.11 layer.</a>
<a name="ln1365">		 */</a>
<a name="ln1366">		txq = sc-&gt;sc_ac2q[M_WME_GETAC(m)];</a>
<a name="ln1367">		bf = mwl_gettxbuf(sc, txq);</a>
<a name="ln1368">		if (bf == NULL) {</a>
<a name="ln1369">			m_freem(m);</a>
<a name="ln1370">			ieee80211_free_node(ni);</a>
<a name="ln1371">#ifdef MWL_TX_NODROP</a>
<a name="ln1372">			sc-&gt;sc_stats.mst_tx_qstop++;</a>
<a name="ln1373">			break;</a>
<a name="ln1374">#else</a>
<a name="ln1375">			DPRINTF(sc, MWL_DEBUG_XMIT,</a>
<a name="ln1376">			    &quot;%s: tail drop on q %d\n&quot;, __func__, txq-&gt;qnum);</a>
<a name="ln1377">			sc-&gt;sc_stats.mst_tx_qdrop++;</a>
<a name="ln1378">			continue;</a>
<a name="ln1379">#endif /* MWL_TX_NODROP */</a>
<a name="ln1380">		}</a>
<a name="ln1381"> </a>
<a name="ln1382">		/*</a>
<a name="ln1383">		 * Pass the frame to the h/w for transmission.</a>
<a name="ln1384">		 */</a>
<a name="ln1385">		if (mwl_tx_start(sc, ni, bf, m)) {</a>
<a name="ln1386">			if_inc_counter(ni-&gt;ni_vap-&gt;iv_ifp,</a>
<a name="ln1387">			    IFCOUNTER_OERRORS, 1);</a>
<a name="ln1388">			mwl_puttxbuf_head(txq, bf);</a>
<a name="ln1389">			ieee80211_free_node(ni);</a>
<a name="ln1390">			continue;</a>
<a name="ln1391">		}</a>
<a name="ln1392">		nqueued++;</a>
<a name="ln1393">		if (nqueued &gt;= mwl_txcoalesce) {</a>
<a name="ln1394">			/*</a>
<a name="ln1395">			 * Poke the firmware to process queued frames;</a>
<a name="ln1396">			 * see below about (lack of) locking.</a>
<a name="ln1397">			 */</a>
<a name="ln1398">			nqueued = 0;</a>
<a name="ln1399">			mwl_hal_txstart(sc-&gt;sc_mh, 0/*XXX*/);</a>
<a name="ln1400">		}</a>
<a name="ln1401">	}</a>
<a name="ln1402">	if (nqueued) {</a>
<a name="ln1403">		/*</a>
<a name="ln1404">		 * NB: We don't need to lock against tx done because</a>
<a name="ln1405">		 * this just prods the firmware to check the transmit</a>
<a name="ln1406">		 * descriptors.  The firmware will also start fetching</a>
<a name="ln1407">		 * descriptors by itself if it notices new ones are</a>
<a name="ln1408">		 * present when it goes to deliver a tx done interrupt</a>
<a name="ln1409">		 * to the host. So if we race with tx done processing</a>
<a name="ln1410">		 * it's ok.  Delivering the kick here rather than in</a>
<a name="ln1411">		 * mwl_tx_start is an optimization to avoid poking the</a>
<a name="ln1412">		 * firmware for each packet.</a>
<a name="ln1413">		 *</a>
<a name="ln1414">		 * NB: the queue id isn't used so 0 is ok.</a>
<a name="ln1415">		 */</a>
<a name="ln1416">		mwl_hal_txstart(sc-&gt;sc_mh, 0/*XXX*/);</a>
<a name="ln1417">	}</a>
<a name="ln1418">}</a>
<a name="ln1419"> </a>
<a name="ln1420">static int</a>
<a name="ln1421">mwl_raw_xmit(struct ieee80211_node *ni, struct mbuf *m,</a>
<a name="ln1422">	const struct ieee80211_bpf_params *params)</a>
<a name="ln1423">{</a>
<a name="ln1424">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln1425">	struct mwl_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1426">	struct mwl_txbuf *bf;</a>
<a name="ln1427">	struct mwl_txq *txq;</a>
<a name="ln1428"> </a>
<a name="ln1429">	if (!sc-&gt;sc_running || sc-&gt;sc_invalid) {</a>
<a name="ln1430">		m_freem(m);</a>
<a name="ln1431">		return ENETDOWN;</a>
<a name="ln1432">	}</a>
<a name="ln1433">	/*</a>
<a name="ln1434">	 * Grab a TX buffer and associated resources.</a>
<a name="ln1435">	 * Note that we depend on the classification</a>
<a name="ln1436">	 * by the 802.11 layer to get to the right h/w</a>
<a name="ln1437">	 * queue.  Management frames must ALWAYS go on</a>
<a name="ln1438">	 * queue 1 but we cannot just force that here</a>
<a name="ln1439">	 * because we may receive non-mgt frames.</a>
<a name="ln1440">	 */</a>
<a name="ln1441">	txq = sc-&gt;sc_ac2q[M_WME_GETAC(m)];</a>
<a name="ln1442">	bf = mwl_gettxbuf(sc, txq);</a>
<a name="ln1443">	if (bf == NULL) {</a>
<a name="ln1444">		sc-&gt;sc_stats.mst_tx_qstop++;</a>
<a name="ln1445">		m_freem(m);</a>
<a name="ln1446">		return ENOBUFS;</a>
<a name="ln1447">	}</a>
<a name="ln1448">	/*</a>
<a name="ln1449">	 * Pass the frame to the h/w for transmission.</a>
<a name="ln1450">	 */</a>
<a name="ln1451">	if (mwl_tx_start(sc, ni, bf, m)) {</a>
<a name="ln1452">		mwl_puttxbuf_head(txq, bf);</a>
<a name="ln1453"> </a>
<a name="ln1454">		return EIO;		/* XXX */</a>
<a name="ln1455">	}</a>
<a name="ln1456">	/*</a>
<a name="ln1457">	 * NB: We don't need to lock against tx done because</a>
<a name="ln1458">	 * this just prods the firmware to check the transmit</a>
<a name="ln1459">	 * descriptors.  The firmware will also start fetching</a>
<a name="ln1460">	 * descriptors by itself if it notices new ones are</a>
<a name="ln1461">	 * present when it goes to deliver a tx done interrupt</a>
<a name="ln1462">	 * to the host. So if we race with tx done processing</a>
<a name="ln1463">	 * it's ok.  Delivering the kick here rather than in</a>
<a name="ln1464">	 * mwl_tx_start is an optimization to avoid poking the</a>
<a name="ln1465">	 * firmware for each packet.</a>
<a name="ln1466">	 *</a>
<a name="ln1467">	 * NB: the queue id isn't used so 0 is ok.</a>
<a name="ln1468">	 */</a>
<a name="ln1469">	mwl_hal_txstart(sc-&gt;sc_mh, 0/*XXX*/);</a>
<a name="ln1470">	return 0;</a>
<a name="ln1471">}</a>
<a name="ln1472"> </a>
<a name="ln1473">static int</a>
<a name="ln1474">mwl_media_change(struct ifnet *ifp)</a>
<a name="ln1475">{</a>
<a name="ln1476">	struct ieee80211vap *vap = ifp-&gt;if_softc;</a>
<a name="ln1477">	int error;</a>
<a name="ln1478"> </a>
<a name="ln1479">	error = ieee80211_media_change(ifp);</a>
<a name="ln1480">	/* NB: only the fixed rate can change and that doesn't need a reset */</a>
<a name="ln1481">	if (error == ENETRESET) {</a>
<a name="ln1482">		mwl_setrates(vap);</a>
<a name="ln1483">		error = 0;</a>
<a name="ln1484">	}</a>
<a name="ln1485">	return error;</a>
<a name="ln1486">}</a>
<a name="ln1487"> </a>
<a name="ln1488">#ifdef MWL_DEBUG</a>
<a name="ln1489">static void</a>
<a name="ln1490">mwl_keyprint(struct mwl_softc *sc, const char *tag,</a>
<a name="ln1491">	const MWL_HAL_KEYVAL *hk, const uint8_t mac[IEEE80211_ADDR_LEN])</a>
<a name="ln1492">{</a>
<a name="ln1493">	static const char *ciphers[] = {</a>
<a name="ln1494">		&quot;WEP&quot;,</a>
<a name="ln1495">		&quot;TKIP&quot;,</a>
<a name="ln1496">		&quot;AES-CCM&quot;,</a>
<a name="ln1497">	};</a>
<a name="ln1498">	int i, n;</a>
<a name="ln1499"> </a>
<a name="ln1500">	printf(&quot;%s: [%u] %-7s&quot;, tag, hk-&gt;keyIndex, ciphers[hk-&gt;keyTypeId]);</a>
<a name="ln1501">	for (i = 0, n = hk-&gt;keyLen; i &lt; n; i++)</a>
<a name="ln1502">		printf(&quot; %02x&quot;, hk-&gt;key.aes[i]);</a>
<a name="ln1503">	printf(&quot; mac %s&quot;, ether_sprintf(mac));</a>
<a name="ln1504">	if (hk-&gt;keyTypeId == KEY_TYPE_ID_TKIP) {</a>
<a name="ln1505">		printf(&quot; %s&quot;, &quot;rxmic&quot;);</a>
<a name="ln1506">		for (i = 0; i &lt; sizeof(hk-&gt;key.tkip.rxMic); i++)</a>
<a name="ln1507">			printf(&quot; %02x&quot;, hk-&gt;key.tkip.rxMic[i]);</a>
<a name="ln1508">		printf(&quot; txmic&quot;);</a>
<a name="ln1509">		for (i = 0; i &lt; sizeof(hk-&gt;key.tkip.txMic); i++)</a>
<a name="ln1510">			printf(&quot; %02x&quot;, hk-&gt;key.tkip.txMic[i]);</a>
<a name="ln1511">	}</a>
<a name="ln1512">	printf(&quot; flags 0x%x\n&quot;, hk-&gt;keyFlags);</a>
<a name="ln1513">}</a>
<a name="ln1514">#endif</a>
<a name="ln1515"> </a>
<a name="ln1516">/*</a>
<a name="ln1517"> * Allocate a key cache slot for a unicast key.  The</a>
<a name="ln1518"> * firmware handles key allocation and every station is</a>
<a name="ln1519"> * guaranteed key space so we are always successful.</a>
<a name="ln1520"> */</a>
<a name="ln1521">static int</a>
<a name="ln1522">mwl_key_alloc(struct ieee80211vap *vap, struct ieee80211_key *k,</a>
<a name="ln1523">	ieee80211_keyix *keyix, ieee80211_keyix *rxkeyix)</a>
<a name="ln1524">{</a>
<a name="ln1525">	struct mwl_softc *sc = vap-&gt;iv_ic-&gt;ic_softc;</a>
<a name="ln1526"> </a>
<a name="ln1527">	if (k-&gt;wk_keyix != IEEE80211_KEYIX_NONE ||</a>
<a name="ln1528">	    (k-&gt;wk_flags &amp; IEEE80211_KEY_GROUP)) {</a>
<a name="ln1529">		if (!(&amp;vap-&gt;iv_nw_keys[0] &lt;= k &amp;&amp;</a>
<a name="ln1530">		      k &lt; &amp;vap-&gt;iv_nw_keys[IEEE80211_WEP_NKID])) {</a>
<a name="ln1531">			/* should not happen */</a>
<a name="ln1532">			DPRINTF(sc, MWL_DEBUG_KEYCACHE,</a>
<a name="ln1533">				&quot;%s: bogus group key\n&quot;, __func__);</a>
<a name="ln1534">			return 0;</a>
<a name="ln1535">		}</a>
<a name="ln1536">		/* give the caller what they requested */</a>
<a name="ln1537">		*keyix = *rxkeyix = ieee80211_crypto_get_key_wepidx(vap, k);</a>
<a name="ln1538">	} else {</a>
<a name="ln1539">		/*</a>
<a name="ln1540">		 * Firmware handles key allocation.</a>
<a name="ln1541">		 */</a>
<a name="ln1542">		*keyix = *rxkeyix = 0;</a>
<a name="ln1543">	}</a>
<a name="ln1544">	return 1;</a>
<a name="ln1545">}</a>
<a name="ln1546"> </a>
<a name="ln1547">/*</a>
<a name="ln1548"> * Delete a key entry allocated by mwl_key_alloc.</a>
<a name="ln1549"> */</a>
<a name="ln1550">static int</a>
<a name="ln1551">mwl_key_delete(struct ieee80211vap *vap, const struct ieee80211_key *k)</a>
<a name="ln1552">{</a>
<a name="ln1553">	struct mwl_softc *sc = vap-&gt;iv_ic-&gt;ic_softc;</a>
<a name="ln1554">	struct mwl_hal_vap *hvap = MWL_VAP(vap)-&gt;mv_hvap;</a>
<a name="ln1555">	MWL_HAL_KEYVAL hk;</a>
<a name="ln1556">	const uint8_t bcastaddr[IEEE80211_ADDR_LEN] =</a>
<a name="ln1557">	    { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };</a>
<a name="ln1558"> </a>
<a name="ln1559">	if (hvap == NULL) {</a>
<a name="ln1560">		if (vap-&gt;iv_opmode != IEEE80211_M_WDS) {</a>
<a name="ln1561">			/* XXX monitor mode? */</a>
<a name="ln1562">			DPRINTF(sc, MWL_DEBUG_KEYCACHE,</a>
<a name="ln1563">			    &quot;%s: no hvap for opmode %d\n&quot;, __func__,</a>
<a name="ln1564">			    vap-&gt;iv_opmode);</a>
<a name="ln1565">			return 0;</a>
<a name="ln1566">		}</a>
<a name="ln1567">		hvap = MWL_VAP(vap)-&gt;mv_ap_hvap;</a>
<a name="ln1568">	}</a>
<a name="ln1569"> </a>
<a name="ln1570">	DPRINTF(sc, MWL_DEBUG_KEYCACHE, &quot;%s: delete key %u\n&quot;,</a>
<a name="ln1571">	    __func__, k-&gt;wk_keyix);</a>
<a name="ln1572"> </a>
<a name="ln1573">	memset(&amp;hk, 0, sizeof(hk));</a>
<a name="ln1574">	hk.keyIndex = k-&gt;wk_keyix;</a>
<a name="ln1575">	switch (k-&gt;wk_cipher-&gt;ic_cipher) {</a>
<a name="ln1576">	case IEEE80211_CIPHER_WEP:</a>
<a name="ln1577">		hk.keyTypeId = KEY_TYPE_ID_WEP;</a>
<a name="ln1578">		break;</a>
<a name="ln1579">	case IEEE80211_CIPHER_TKIP:</a>
<a name="ln1580">		hk.keyTypeId = KEY_TYPE_ID_TKIP;</a>
<a name="ln1581">		break;</a>
<a name="ln1582">	case IEEE80211_CIPHER_AES_CCM:</a>
<a name="ln1583">		hk.keyTypeId = KEY_TYPE_ID_AES;</a>
<a name="ln1584">		break;</a>
<a name="ln1585">	default:</a>
<a name="ln1586">		/* XXX should not happen */</a>
<a name="ln1587">		DPRINTF(sc, MWL_DEBUG_KEYCACHE, &quot;%s: unknown cipher %d\n&quot;,</a>
<a name="ln1588">		    __func__, k-&gt;wk_cipher-&gt;ic_cipher);</a>
<a name="ln1589">		return 0;</a>
<a name="ln1590">	}</a>
<a name="ln1591">	return (mwl_hal_keyreset(hvap, &amp;hk, bcastaddr) == 0);	/*XXX*/</a>
<a name="ln1592">}</a>
<a name="ln1593"> </a>
<a name="ln1594">static __inline int</a>
<a name="ln1595">addgroupflags(MWL_HAL_KEYVAL *hk, const struct ieee80211_key *k)</a>
<a name="ln1596">{</a>
<a name="ln1597">	if (k-&gt;wk_flags &amp; IEEE80211_KEY_GROUP) {</a>
<a name="ln1598">		if (k-&gt;wk_flags &amp; IEEE80211_KEY_XMIT)</a>
<a name="ln1599">			hk-&gt;keyFlags |= KEY_FLAG_TXGROUPKEY;</a>
<a name="ln1600">		if (k-&gt;wk_flags &amp; IEEE80211_KEY_RECV)</a>
<a name="ln1601">			hk-&gt;keyFlags |= KEY_FLAG_RXGROUPKEY;</a>
<a name="ln1602">		return 1;</a>
<a name="ln1603">	} else</a>
<a name="ln1604">		return 0;</a>
<a name="ln1605">}</a>
<a name="ln1606"> </a>
<a name="ln1607">/*</a>
<a name="ln1608"> * Set the key cache contents for the specified key.  Key cache</a>
<a name="ln1609"> * slot(s) must already have been allocated by mwl_key_alloc.</a>
<a name="ln1610"> */</a>
<a name="ln1611">static int</a>
<a name="ln1612">mwl_key_set(struct ieee80211vap *vap, const struct ieee80211_key *k)</a>
<a name="ln1613">{</a>
<a name="ln1614">	return (_mwl_key_set(vap, k, k-&gt;wk_macaddr));</a>
<a name="ln1615">}</a>
<a name="ln1616"> </a>
<a name="ln1617">static int</a>
<a name="ln1618">_mwl_key_set(struct ieee80211vap *vap, const struct ieee80211_key *k,</a>
<a name="ln1619">	const uint8_t mac[IEEE80211_ADDR_LEN])</a>
<a name="ln1620">{</a>
<a name="ln1621">#define	GRPXMIT	(IEEE80211_KEY_XMIT | IEEE80211_KEY_GROUP)</a>
<a name="ln1622">/* NB: static wep keys are marked GROUP+tx/rx; GTK will be tx or rx */</a>
<a name="ln1623">#define	IEEE80211_IS_STATICKEY(k) \</a>
<a name="ln1624">	(((k)-&gt;wk_flags &amp; (GRPXMIT|IEEE80211_KEY_RECV)) == \</a>
<a name="ln1625">	 (GRPXMIT|IEEE80211_KEY_RECV))</a>
<a name="ln1626">	struct mwl_softc *sc = vap-&gt;iv_ic-&gt;ic_softc;</a>
<a name="ln1627">	struct mwl_hal_vap *hvap = MWL_VAP(vap)-&gt;mv_hvap;</a>
<a name="ln1628">	const struct ieee80211_cipher *cip = k-&gt;wk_cipher;</a>
<a name="ln1629">	const uint8_t *macaddr;</a>
<a name="ln1630">	MWL_HAL_KEYVAL hk;</a>
<a name="ln1631"> </a>
<a name="ln1632">	KASSERT((k-&gt;wk_flags &amp; IEEE80211_KEY_SWCRYPT) == 0,</a>
<a name="ln1633">		(&quot;s/w crypto set?&quot;));</a>
<a name="ln1634"> </a>
<a name="ln1635">	if (hvap == NULL) {</a>
<a name="ln1636">		if (vap-&gt;iv_opmode != IEEE80211_M_WDS) {</a>
<a name="ln1637">			/* XXX monitor mode? */</a>
<a name="ln1638">			DPRINTF(sc, MWL_DEBUG_KEYCACHE,</a>
<a name="ln1639">			    &quot;%s: no hvap for opmode %d\n&quot;, __func__,</a>
<a name="ln1640">			    vap-&gt;iv_opmode);</a>
<a name="ln1641">			return 0;</a>
<a name="ln1642">		}</a>
<a name="ln1643">		hvap = MWL_VAP(vap)-&gt;mv_ap_hvap;</a>
<a name="ln1644">	}</a>
<a name="ln1645">	memset(&amp;hk, 0, sizeof(hk));</a>
<a name="ln1646">	hk.keyIndex = k-&gt;wk_keyix;</a>
<a name="ln1647">	switch (cip-&gt;ic_cipher) {</a>
<a name="ln1648">	case IEEE80211_CIPHER_WEP:</a>
<a name="ln1649">		hk.keyTypeId = KEY_TYPE_ID_WEP;</a>
<a name="ln1650">		hk.keyLen = k-&gt;wk_keylen;</a>
<a name="ln1651">		if (k-&gt;wk_keyix == vap-&gt;iv_def_txkey)</a>
<a name="ln1652">			hk.keyFlags = KEY_FLAG_WEP_TXKEY;</a>
<a name="ln1653">		if (!IEEE80211_IS_STATICKEY(k)) {</a>
<a name="ln1654">			/* NB: WEP is never used for the PTK */</a>
<a name="ln1655">			(void) addgroupflags(&amp;hk, k);</a>
<a name="ln1656">		}</a>
<a name="ln1657">		break;</a>
<a name="ln1658">	case IEEE80211_CIPHER_TKIP:</a>
<a name="ln1659">		hk.keyTypeId = KEY_TYPE_ID_TKIP;</a>
<a name="ln1660">		hk.key.tkip.tsc.high = (uint32_t)(k-&gt;wk_keytsc &gt;&gt; 16);</a>
<a name="ln1661">		hk.key.tkip.tsc.low = (uint16_t)k-&gt;wk_keytsc;</a>
<a name="ln1662">		hk.keyFlags = KEY_FLAG_TSC_VALID | KEY_FLAG_MICKEY_VALID;</a>
<a name="ln1663">		hk.keyLen = k-&gt;wk_keylen + IEEE80211_MICBUF_SIZE;</a>
<a name="ln1664">		if (!addgroupflags(&amp;hk, k))</a>
<a name="ln1665">			hk.keyFlags |= KEY_FLAG_PAIRWISE;</a>
<a name="ln1666">		break;</a>
<a name="ln1667">	case IEEE80211_CIPHER_AES_CCM:</a>
<a name="ln1668">		hk.keyTypeId = KEY_TYPE_ID_AES;</a>
<a name="ln1669">		hk.keyLen = k-&gt;wk_keylen;</a>
<a name="ln1670">		if (!addgroupflags(&amp;hk, k))</a>
<a name="ln1671">			hk.keyFlags |= KEY_FLAG_PAIRWISE;</a>
<a name="ln1672">		break;</a>
<a name="ln1673">	default:</a>
<a name="ln1674">		/* XXX should not happen */</a>
<a name="ln1675">		DPRINTF(sc, MWL_DEBUG_KEYCACHE, &quot;%s: unknown cipher %d\n&quot;,</a>
<a name="ln1676">		    __func__, k-&gt;wk_cipher-&gt;ic_cipher);</a>
<a name="ln1677">		return 0;</a>
<a name="ln1678">	}</a>
<a name="ln1679">	/*</a>
<a name="ln1680">	 * NB: tkip mic keys get copied here too; the layout</a>
<a name="ln1681">	 *     just happens to match that in ieee80211_key.</a>
<a name="ln1682">	 */</a>
<a name="ln1683">	memcpy(hk.key.aes, k-&gt;wk_key, hk.keyLen);</a>
<a name="ln1684"> </a>
<a name="ln1685">	/*</a>
<a name="ln1686">	 * Locate address of sta db entry for writing key;</a>
<a name="ln1687">	 * the convention unfortunately is somewhat different</a>
<a name="ln1688">	 * than how net80211, hostapd, and wpa_supplicant think.</a>
<a name="ln1689">	 */</a>
<a name="ln1690">	if (vap-&gt;iv_opmode == IEEE80211_M_STA) {</a>
<a name="ln1691">		/*</a>
<a name="ln1692">		 * NB: keys plumbed before the sta reaches AUTH state</a>
<a name="ln1693">		 * will be discarded or written to the wrong sta db</a>
<a name="ln1694">		 * entry because iv_bss is meaningless.  This is ok</a>
<a name="ln1695">		 * (right now) because we handle deferred plumbing of</a>
<a name="ln1696">		 * WEP keys when the sta reaches AUTH state.</a>
<a name="ln1697">		 */</a>
<a name="ln1698">		macaddr = vap-&gt;iv_bss-&gt;ni_bssid;</a>
<a name="ln1699">		if ((k-&gt;wk_flags &amp; IEEE80211_KEY_GROUP) == 0) {</a>
<a name="ln1700">			/* XXX plumb to local sta db too for static key wep */</a>
<a name="ln1701">			mwl_hal_keyset(hvap, &amp;hk, vap-&gt;iv_myaddr);</a>
<a name="ln1702">		}</a>
<a name="ln1703">	} else if (vap-&gt;iv_opmode == IEEE80211_M_WDS &amp;&amp;</a>
<a name="ln1704">	    vap-&gt;iv_state != IEEE80211_S_RUN) {</a>
<a name="ln1705">		/*</a>
<a name="ln1706">		 * Prior to RUN state a WDS vap will not it's BSS node</a>
<a name="ln1707">		 * setup so we will plumb the key to the wrong mac</a>
<a name="ln1708">		 * address (it'll be our local address).  Workaround</a>
<a name="ln1709">		 * this for the moment by grabbing the correct address.</a>
<a name="ln1710">		 */</a>
<a name="ln1711">		macaddr = vap-&gt;iv_des_bssid;</a>
<a name="ln1712">	} else if ((k-&gt;wk_flags &amp; GRPXMIT) == GRPXMIT)</a>
<a name="ln1713">		macaddr = vap-&gt;iv_myaddr;</a>
<a name="ln1714">	else</a>
<a name="ln1715">		macaddr = mac;</a>
<a name="ln1716">	KEYPRINTF(sc, &amp;hk, macaddr);</a>
<a name="ln1717">	return (mwl_hal_keyset(hvap, &amp;hk, macaddr) == 0);</a>
<a name="ln1718">#undef IEEE80211_IS_STATICKEY</a>
<a name="ln1719">#undef GRPXMIT</a>
<a name="ln1720">}</a>
<a name="ln1721"> </a>
<a name="ln1722">/*</a>
<a name="ln1723"> * Set the multicast filter contents into the hardware.</a>
<a name="ln1724"> * XXX f/w has no support; just defer to the os.</a>
<a name="ln1725"> */</a>
<a name="ln1726">static void</a>
<a name="ln1727">mwl_setmcastfilter(struct mwl_softc *sc)</a>
<a name="ln1728">{</a>
<a name="ln1729">#if 0</a>
<a name="ln1730">	struct ether_multi *enm;</a>
<a name="ln1731">	struct ether_multistep estep;</a>
<a name="ln1732">	uint8_t macs[IEEE80211_ADDR_LEN*MWL_HAL_MCAST_MAX];/* XXX stack use */</a>
<a name="ln1733">	uint8_t *mp;</a>
<a name="ln1734">	int nmc;</a>
<a name="ln1735"> </a>
<a name="ln1736">	mp = macs;</a>
<a name="ln1737">	nmc = 0;</a>
<a name="ln1738">	ETHER_FIRST_MULTI(estep, &amp;sc-&gt;sc_ec, enm);</a>
<a name="ln1739">	while (enm != NULL) {</a>
<a name="ln1740">		/* XXX Punt on ranges. */</a>
<a name="ln1741">		if (nmc == MWL_HAL_MCAST_MAX ||</a>
<a name="ln1742">		    !IEEE80211_ADDR_EQ(enm-&gt;enm_addrlo, enm-&gt;enm_addrhi)) {</a>
<a name="ln1743">			ifp-&gt;if_flags |= IFF_ALLMULTI;</a>
<a name="ln1744">			return;</a>
<a name="ln1745">		}</a>
<a name="ln1746">		IEEE80211_ADDR_COPY(mp, enm-&gt;enm_addrlo);</a>
<a name="ln1747">		mp += IEEE80211_ADDR_LEN, nmc++;</a>
<a name="ln1748">		ETHER_NEXT_MULTI(estep, enm);</a>
<a name="ln1749">	}</a>
<a name="ln1750">	ifp-&gt;if_flags &amp;= ~IFF_ALLMULTI;</a>
<a name="ln1751">	mwl_hal_setmcast(sc-&gt;sc_mh, nmc, macs);</a>
<a name="ln1752">#endif</a>
<a name="ln1753">}</a>
<a name="ln1754"> </a>
<a name="ln1755">static int</a>
<a name="ln1756">mwl_mode_init(struct mwl_softc *sc)</a>
<a name="ln1757">{</a>
<a name="ln1758">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1759">	struct mwl_hal *mh = sc-&gt;sc_mh;</a>
<a name="ln1760"> </a>
<a name="ln1761">	mwl_hal_setpromisc(mh, ic-&gt;ic_promisc &gt; 0);</a>
<a name="ln1762">	mwl_setmcastfilter(sc);</a>
<a name="ln1763"> </a>
<a name="ln1764">	return 0;</a>
<a name="ln1765">}</a>
<a name="ln1766"> </a>
<a name="ln1767">/*</a>
<a name="ln1768"> * Callback from the 802.11 layer after a multicast state change.</a>
<a name="ln1769"> */</a>
<a name="ln1770">static void</a>
<a name="ln1771">mwl_update_mcast(struct ieee80211com *ic)</a>
<a name="ln1772">{</a>
<a name="ln1773">	struct mwl_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1774"> </a>
<a name="ln1775">	mwl_setmcastfilter(sc);</a>
<a name="ln1776">}</a>
<a name="ln1777"> </a>
<a name="ln1778">/*</a>
<a name="ln1779"> * Callback from the 802.11 layer after a promiscuous mode change.</a>
<a name="ln1780"> * Note this interface does not check the operating mode as this</a>
<a name="ln1781"> * is an internal callback and we are expected to honor the current</a>
<a name="ln1782"> * state (e.g. this is used for setting the interface in promiscuous</a>
<a name="ln1783"> * mode when operating in hostap mode to do ACS).</a>
<a name="ln1784"> */</a>
<a name="ln1785">static void</a>
<a name="ln1786">mwl_update_promisc(struct ieee80211com *ic)</a>
<a name="ln1787">{</a>
<a name="ln1788">	struct mwl_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1789"> </a>
<a name="ln1790">	mwl_hal_setpromisc(sc-&gt;sc_mh, ic-&gt;ic_promisc &gt; 0);</a>
<a name="ln1791">}</a>
<a name="ln1792"> </a>
<a name="ln1793">/*</a>
<a name="ln1794"> * Callback from the 802.11 layer to update the slot time</a>
<a name="ln1795"> * based on the current setting.  We use it to notify the</a>
<a name="ln1796"> * firmware of ERP changes and the f/w takes care of things</a>
<a name="ln1797"> * like slot time and preamble.</a>
<a name="ln1798"> */</a>
<a name="ln1799">static void</a>
<a name="ln1800">mwl_updateslot(struct ieee80211com *ic)</a>
<a name="ln1801">{</a>
<a name="ln1802">	struct mwl_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln1803">	struct mwl_hal *mh = sc-&gt;sc_mh;</a>
<a name="ln1804">	int prot;</a>
<a name="ln1805"> </a>
<a name="ln1806">	/* NB: can be called early; suppress needless cmds */</a>
<a name="ln1807">	if (!sc-&gt;sc_running)</a>
<a name="ln1808">		return;</a>
<a name="ln1809"> </a>
<a name="ln1810">	/*</a>
<a name="ln1811">	 * Calculate the ERP flags.  The firwmare will use</a>
<a name="ln1812">	 * this to carry out the appropriate measures.</a>
<a name="ln1813">	 */</a>
<a name="ln1814">	prot = 0;</a>
<a name="ln1815">	if (IEEE80211_IS_CHAN_ANYG(ic-&gt;ic_curchan)) {</a>
<a name="ln1816">		if ((ic-&gt;ic_flags &amp; IEEE80211_F_SHSLOT) == 0)</a>
<a name="ln1817">			prot |= IEEE80211_ERP_NON_ERP_PRESENT;</a>
<a name="ln1818">		if (ic-&gt;ic_flags &amp; IEEE80211_F_USEPROT)</a>
<a name="ln1819">			prot |= IEEE80211_ERP_USE_PROTECTION;</a>
<a name="ln1820">		if (ic-&gt;ic_flags &amp; IEEE80211_F_USEBARKER)</a>
<a name="ln1821">			prot |= IEEE80211_ERP_LONG_PREAMBLE;</a>
<a name="ln1822">	}</a>
<a name="ln1823"> </a>
<a name="ln1824">	DPRINTF(sc, MWL_DEBUG_RESET,</a>
<a name="ln1825">	    &quot;%s: chan %u MHz/flags 0x%x %s slot, (prot 0x%x ic_flags 0x%x)\n&quot;,</a>
<a name="ln1826">	    __func__, ic-&gt;ic_curchan-&gt;ic_freq, ic-&gt;ic_curchan-&gt;ic_flags,</a>
<a name="ln1827">	    ic-&gt;ic_flags &amp; IEEE80211_F_SHSLOT ? &quot;short&quot; : &quot;long&quot;, prot,</a>
<a name="ln1828">	    ic-&gt;ic_flags);</a>
<a name="ln1829"> </a>
<a name="ln1830">	mwl_hal_setgprot(mh, prot);</a>
<a name="ln1831">}</a>
<a name="ln1832"> </a>
<a name="ln1833">/*</a>
<a name="ln1834"> * Setup the beacon frame.</a>
<a name="ln1835"> */</a>
<a name="ln1836">static int</a>
<a name="ln1837">mwl_beacon_setup(struct ieee80211vap *vap)</a>
<a name="ln1838">{</a>
<a name="ln1839">	struct mwl_hal_vap *hvap = MWL_VAP(vap)-&gt;mv_hvap;</a>
<a name="ln1840">	struct ieee80211_node *ni = vap-&gt;iv_bss;</a>
<a name="ln1841">	struct mbuf *m;</a>
<a name="ln1842"> </a>
<a name="ln1843">	m = ieee80211_beacon_alloc(ni);</a>
<a name="ln1844">	if (m == NULL)</a>
<a name="ln1845">		return ENOBUFS;</a>
<a name="ln1846">	mwl_hal_setbeacon(hvap, mtod(m, const void *), m-&gt;m_len);</a>
<a name="ln1847">	m_free(m);</a>
<a name="ln1848"> </a>
<a name="ln1849">	return 0;</a>
<a name="ln1850">}</a>
<a name="ln1851"> </a>
<a name="ln1852">/*</a>
<a name="ln1853"> * Update the beacon frame in response to a change.</a>
<a name="ln1854"> */</a>
<a name="ln1855">static void</a>
<a name="ln1856">mwl_beacon_update(struct ieee80211vap *vap, int item)</a>
<a name="ln1857">{</a>
<a name="ln1858">	struct mwl_hal_vap *hvap = MWL_VAP(vap)-&gt;mv_hvap;</a>
<a name="ln1859">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln1860"> </a>
<a name="ln1861">	KASSERT(hvap != NULL, (&quot;no beacon&quot;));</a>
<a name="ln1862">	switch (item) {</a>
<a name="ln1863">	case IEEE80211_BEACON_ERP:</a>
<a name="ln1864">		mwl_updateslot(ic);</a>
<a name="ln1865">		break;</a>
<a name="ln1866">	case IEEE80211_BEACON_HTINFO:</a>
<a name="ln1867">		mwl_hal_setnprotmode(hvap,</a>
<a name="ln1868">		    MS(ic-&gt;ic_curhtprotmode, IEEE80211_HTINFO_OPMODE));</a>
<a name="ln1869">		break;</a>
<a name="ln1870">	case IEEE80211_BEACON_CAPS:</a>
<a name="ln1871">	case IEEE80211_BEACON_WME:</a>
<a name="ln1872">	case IEEE80211_BEACON_APPIE:</a>
<a name="ln1873">	case IEEE80211_BEACON_CSA:</a>
<a name="ln1874">		break;</a>
<a name="ln1875">	case IEEE80211_BEACON_TIM:</a>
<a name="ln1876">		/* NB: firmware always forms TIM */</a>
<a name="ln1877">		return;</a>
<a name="ln1878">	}</a>
<a name="ln1879">	/* XXX retain beacon frame and update */</a>
<a name="ln1880">	mwl_beacon_setup(vap);</a>
<a name="ln1881">}</a>
<a name="ln1882"> </a>
<a name="ln1883">static void</a>
<a name="ln1884">mwl_load_cb(void *arg, bus_dma_segment_t *segs, int nsegs, int error)</a>
<a name="ln1885">{</a>
<a name="ln1886">	bus_addr_t *paddr = (bus_addr_t*) arg;</a>
<a name="ln1887">	KASSERT(error == 0, (&quot;error %u on bus_dma callback&quot;, error));</a>
<a name="ln1888">	*paddr = segs-&gt;ds_addr;</a>
<a name="ln1889">}</a>
<a name="ln1890"> </a>
<a name="ln1891">#ifdef MWL_HOST_PS_SUPPORT</a>
<a name="ln1892">/*</a>
<a name="ln1893"> * Handle power save station occupancy changes.</a>
<a name="ln1894"> */</a>
<a name="ln1895">static void</a>
<a name="ln1896">mwl_update_ps(struct ieee80211vap *vap, int nsta)</a>
<a name="ln1897">{</a>
<a name="ln1898">	struct mwl_vap *mvp = MWL_VAP(vap);</a>
<a name="ln1899"> </a>
<a name="ln1900">	if (nsta == 0 || mvp-&gt;mv_last_ps_sta == 0)</a>
<a name="ln1901">		mwl_hal_setpowersave_bss(mvp-&gt;mv_hvap, nsta);</a>
<a name="ln1902">	mvp-&gt;mv_last_ps_sta = nsta;</a>
<a name="ln1903">}</a>
<a name="ln1904"> </a>
<a name="ln1905">/*</a>
<a name="ln1906"> * Handle associated station power save state changes.</a>
<a name="ln1907"> */</a>
<a name="ln1908">static int</a>
<a name="ln1909">mwl_set_tim(struct ieee80211_node *ni, int set)</a>
<a name="ln1910">{</a>
<a name="ln1911">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln1912">	struct mwl_vap *mvp = MWL_VAP(vap);</a>
<a name="ln1913"> </a>
<a name="ln1914">	if (mvp-&gt;mv_set_tim(ni, set)) {		/* NB: state change */</a>
<a name="ln1915">		mwl_hal_setpowersave_sta(mvp-&gt;mv_hvap,</a>
<a name="ln1916">		    IEEE80211_AID(ni-&gt;ni_associd), set);</a>
<a name="ln1917">		return 1;</a>
<a name="ln1918">	} else</a>
<a name="ln1919">		return 0;</a>
<a name="ln1920">}</a>
<a name="ln1921">#endif /* MWL_HOST_PS_SUPPORT */</a>
<a name="ln1922"> </a>
<a name="ln1923">static int</a>
<a name="ln1924">mwl_desc_setup(struct mwl_softc *sc, const char *name,</a>
<a name="ln1925">	struct mwl_descdma *dd,</a>
<a name="ln1926">	int nbuf, size_t bufsize, int ndesc, size_t descsize)</a>
<a name="ln1927">{</a>
<a name="ln1928">	uint8_t *ds;</a>
<a name="ln1929">	int error;</a>
<a name="ln1930"> </a>
<a name="ln1931">	DPRINTF(sc, MWL_DEBUG_RESET,</a>
<a name="ln1932">	    &quot;%s: %s DMA: %u bufs (%ju) %u desc/buf (%ju)\n&quot;,</a>
<a name="ln1933">	    __func__, name, nbuf, (uintmax_t) bufsize,</a>
<a name="ln1934">	    ndesc, (uintmax_t) descsize);</a>
<a name="ln1935"> </a>
<a name="ln1936">	dd-&gt;dd_name = name;</a>
<a name="ln1937">	dd-&gt;dd_desc_len = nbuf * ndesc * descsize;</a>
<a name="ln1938"> </a>
<a name="ln1939">	/*</a>
<a name="ln1940">	 * Setup DMA descriptor area.</a>
<a name="ln1941">	 */</a>
<a name="ln1942">	error = bus_dma_tag_create(bus_get_dma_tag(sc-&gt;sc_dev),	/* parent */</a>
<a name="ln1943">		       PAGE_SIZE, 0,		/* alignment, bounds */</a>
<a name="ln1944">		       BUS_SPACE_MAXADDR_32BIT,	/* lowaddr */</a>
<a name="ln1945">		       BUS_SPACE_MAXADDR,	/* highaddr */</a>
<a name="ln1946">		       NULL, NULL,		/* filter, filterarg */</a>
<a name="ln1947">		       dd-&gt;dd_desc_len,		/* maxsize */</a>
<a name="ln1948">		       1,			/* nsegments */</a>
<a name="ln1949">		       dd-&gt;dd_desc_len,		/* maxsegsize */</a>
<a name="ln1950">		       BUS_DMA_ALLOCNOW,	/* flags */</a>
<a name="ln1951">		       NULL,			/* lockfunc */</a>
<a name="ln1952">		       NULL,			/* lockarg */</a>
<a name="ln1953">		       &amp;dd-&gt;dd_dmat);</a>
<a name="ln1954">	if (error != 0) {</a>
<a name="ln1955">		device_printf(sc-&gt;sc_dev, &quot;cannot allocate %s DMA tag\n&quot;, dd-&gt;dd_name);</a>
<a name="ln1956">		return error;</a>
<a name="ln1957">	}</a>
<a name="ln1958"> </a>
<a name="ln1959">	/* allocate descriptors */</a>
<a name="ln1960">	error = bus_dmamem_alloc(dd-&gt;dd_dmat, (void**) &amp;dd-&gt;dd_desc,</a>
<a name="ln1961">				 BUS_DMA_NOWAIT | BUS_DMA_COHERENT,</a>
<a name="ln1962">				 &amp;dd-&gt;dd_dmamap);</a>
<a name="ln1963">	if (error != 0) {</a>
<a name="ln1964">		device_printf(sc-&gt;sc_dev, &quot;unable to alloc memory for %u %s descriptors, &quot;</a>
<a name="ln1965">			&quot;error %u\n&quot;, nbuf * ndesc, dd-&gt;dd_name, error);</a>
<a name="ln1966">		goto fail1;</a>
<a name="ln1967">	}</a>
<a name="ln1968"> </a>
<a name="ln1969">	error = bus_dmamap_load(dd-&gt;dd_dmat, dd-&gt;dd_dmamap,</a>
<a name="ln1970">				dd-&gt;dd_desc, dd-&gt;dd_desc_len,</a>
<a name="ln1971">				mwl_load_cb, &amp;dd-&gt;dd_desc_paddr,</a>
<a name="ln1972">				BUS_DMA_NOWAIT);</a>
<a name="ln1973">	if (error != 0) {</a>
<a name="ln1974">		device_printf(sc-&gt;sc_dev, &quot;unable to map %s descriptors, error %u\n&quot;,</a>
<a name="ln1975">			dd-&gt;dd_name, error);</a>
<a name="ln1976">		goto fail2;</a>
<a name="ln1977">	}</a>
<a name="ln1978"> </a>
<a name="ln1979">	ds = dd-&gt;dd_desc;</a>
<a name="ln1980">	memset(ds, 0, dd-&gt;dd_desc_len);</a>
<a name="ln1981">	DPRINTF(sc, MWL_DEBUG_RESET,</a>
<a name="ln1982">	    &quot;%s: %s DMA map: %p (%lu) -&gt; 0x%jx (%lu)\n&quot;,</a>
<a name="ln1983">	    __func__, dd-&gt;dd_name, ds, (u_long) dd-&gt;dd_desc_len,</a>
<a name="ln1984">	    (uintmax_t) dd-&gt;dd_desc_paddr, /*XXX*/ (u_long) dd-&gt;dd_desc_len);</a>
<a name="ln1985"> </a>
<a name="ln1986">	return 0;</a>
<a name="ln1987">fail2:</a>
<a name="ln1988">	bus_dmamem_free(dd-&gt;dd_dmat, dd-&gt;dd_desc, dd-&gt;dd_dmamap);</a>
<a name="ln1989">fail1:</a>
<a name="ln1990">	bus_dma_tag_destroy(dd-&gt;dd_dmat);</a>
<a name="ln1991">	memset(dd, 0, sizeof(*dd));</a>
<a name="ln1992">	return error;</a>
<a name="ln1993">#undef DS2PHYS</a>
<a name="ln1994">}</a>
<a name="ln1995"> </a>
<a name="ln1996">static void</a>
<a name="ln1997">mwl_desc_cleanup(struct mwl_softc *sc, struct mwl_descdma *dd)</a>
<a name="ln1998">{</a>
<a name="ln1999">	bus_dmamap_unload(dd-&gt;dd_dmat, dd-&gt;dd_dmamap);</a>
<a name="ln2000">	bus_dmamem_free(dd-&gt;dd_dmat, dd-&gt;dd_desc, dd-&gt;dd_dmamap);</a>
<a name="ln2001">	bus_dma_tag_destroy(dd-&gt;dd_dmat);</a>
<a name="ln2002"> </a>
<a name="ln2003">	memset(dd, 0, sizeof(*dd));</a>
<a name="ln2004">}</a>
<a name="ln2005"> </a>
<a name="ln2006">/*</a>
<a name="ln2007"> * Construct a tx q's free list.  The order of entries on</a>
<a name="ln2008"> * the list must reflect the physical layout of tx descriptors</a>
<a name="ln2009"> * because the firmware pre-fetches descriptors.</a>
<a name="ln2010"> *</a>
<a name="ln2011"> * XXX might be better to use indices into the buffer array.</a>
<a name="ln2012"> */</a>
<a name="ln2013">static void</a>
<a name="ln2014">mwl_txq_reset(struct mwl_softc *sc, struct mwl_txq *txq)</a>
<a name="ln2015">{</a>
<a name="ln2016">	struct mwl_txbuf *bf;</a>
<a name="ln2017">	int i;</a>
<a name="ln2018"> </a>
<a name="ln2019">	bf = txq-&gt;dma.dd_bufptr;</a>
<a name="ln2020">	STAILQ_INIT(&amp;txq-&gt;free);</a>
<a name="ln2021">	for (i = 0; i &lt; mwl_txbuf; i++, bf++)</a>
<a name="ln2022">		STAILQ_INSERT_TAIL(&amp;txq-&gt;free, bf, bf_list);</a>
<a name="ln2023">	txq-&gt;nfree = i;</a>
<a name="ln2024">}</a>
<a name="ln2025"> </a>
<a name="ln2026">#define	DS2PHYS(_dd, _ds) \</a>
<a name="ln2027">	((_dd)-&gt;dd_desc_paddr + ((caddr_t)(_ds) - (caddr_t)(_dd)-&gt;dd_desc))</a>
<a name="ln2028"> </a>
<a name="ln2029">static int</a>
<a name="ln2030">mwl_txdma_setup(struct mwl_softc *sc, struct mwl_txq *txq)</a>
<a name="ln2031">{</a>
<a name="ln2032">	int error, bsize, i;</a>
<a name="ln2033">	struct mwl_txbuf *bf;</a>
<a name="ln2034">	struct mwl_txdesc *ds;</a>
<a name="ln2035"> </a>
<a name="ln2036">	error = mwl_desc_setup(sc, &quot;tx&quot;, &amp;txq-&gt;dma,</a>
<a name="ln2037">			mwl_txbuf, sizeof(struct mwl_txbuf),</a>
<a name="ln2038">			MWL_TXDESC, sizeof(struct mwl_txdesc));</a>
<a name="ln2039">	if (error != 0)</a>
<a name="ln2040">		return error;</a>
<a name="ln2041"> </a>
<a name="ln2042">	/* allocate and setup tx buffers */</a>
<a name="ln2043">	bsize = mwl_txbuf * sizeof(struct mwl_txbuf);</a>
<a name="ln2044">	bf = malloc(bsize, M_MWLDEV, M_NOWAIT | M_ZERO);</a>
<a name="ln2045">	if (bf == NULL) {</a>
<a name="ln2046">		device_printf(sc-&gt;sc_dev, &quot;malloc of %u tx buffers failed\n&quot;,</a>
<a name="ln2047">			mwl_txbuf);</a>
<a name="ln2048">		return ENOMEM;</a>
<a name="ln2049">	}</a>
<a name="ln2050">	txq-&gt;dma.dd_bufptr = bf;</a>
<a name="ln2051"> </a>
<a name="ln2052">	ds = txq-&gt;dma.dd_desc;</a>
<a name="ln2053">	for (i = 0; i &lt; mwl_txbuf; i++, bf++, ds += MWL_TXDESC) {</a>
<a name="ln2054">		bf-&gt;bf_desc = ds;</a>
<a name="ln2055">		bf-&gt;bf_daddr = DS2PHYS(&amp;txq-&gt;dma, ds);</a>
<a name="ln2056">		error = bus_dmamap_create(sc-&gt;sc_dmat, BUS_DMA_NOWAIT,</a>
<a name="ln2057">				&amp;bf-&gt;bf_dmamap);</a>
<a name="ln2058">		if (error != 0) {</a>
<a name="ln2059">			device_printf(sc-&gt;sc_dev, &quot;unable to create dmamap for tx &quot;</a>
<a name="ln2060">				&quot;buffer %u, error %u\n&quot;, i, error);</a>
<a name="ln2061">			return error;</a>
<a name="ln2062">		}</a>
<a name="ln2063">	}</a>
<a name="ln2064">	mwl_txq_reset(sc, txq);</a>
<a name="ln2065">	return 0;</a>
<a name="ln2066">}</a>
<a name="ln2067"> </a>
<a name="ln2068">static void</a>
<a name="ln2069">mwl_txdma_cleanup(struct mwl_softc *sc, struct mwl_txq *txq)</a>
<a name="ln2070">{</a>
<a name="ln2071">	struct mwl_txbuf *bf;</a>
<a name="ln2072">	int i;</a>
<a name="ln2073"> </a>
<a name="ln2074">	bf = txq-&gt;dma.dd_bufptr;</a>
<a name="ln2075">	for (i = 0; i &lt; mwl_txbuf; i++, bf++) {</a>
<a name="ln2076">		KASSERT(bf-&gt;bf_m == NULL, (&quot;mbuf on free list&quot;));</a>
<a name="ln2077">		KASSERT(bf-&gt;bf_node == NULL, (&quot;node on free list&quot;));</a>
<a name="ln2078">		if (bf-&gt;bf_dmamap != NULL)</a>
<a name="ln2079">			bus_dmamap_destroy(sc-&gt;sc_dmat, bf-&gt;bf_dmamap);</a>
<a name="ln2080">	}</a>
<a name="ln2081">	STAILQ_INIT(&amp;txq-&gt;free);</a>
<a name="ln2082">	txq-&gt;nfree = 0;</a>
<a name="ln2083">	if (txq-&gt;dma.dd_bufptr != NULL) {</a>
<a name="ln2084">		free(txq-&gt;dma.dd_bufptr, M_MWLDEV);</a>
<a name="ln2085">		txq-&gt;dma.dd_bufptr = NULL;</a>
<a name="ln2086">	}</a>
<a name="ln2087">	if (txq-&gt;dma.dd_desc_len != 0)</a>
<a name="ln2088">		mwl_desc_cleanup(sc, &amp;txq-&gt;dma);</a>
<a name="ln2089">}</a>
<a name="ln2090"> </a>
<a name="ln2091">static int</a>
<a name="ln2092">mwl_rxdma_setup(struct mwl_softc *sc)</a>
<a name="ln2093">{</a>
<a name="ln2094">	int error, jumbosize, bsize, i;</a>
<a name="ln2095">	struct mwl_rxbuf *bf;</a>
<a name="ln2096">	struct mwl_jumbo *rbuf;</a>
<a name="ln2097">	struct mwl_rxdesc *ds;</a>
<a name="ln2098">	caddr_t data;</a>
<a name="ln2099"> </a>
<a name="ln2100">	error = mwl_desc_setup(sc, &quot;rx&quot;, &amp;sc-&gt;sc_rxdma,</a>
<a name="ln2101">			mwl_rxdesc, sizeof(struct mwl_rxbuf),</a>
<a name="ln2102">			1, sizeof(struct mwl_rxdesc));</a>
<a name="ln2103">	if (error != 0)</a>
<a name="ln2104">		return error;</a>
<a name="ln2105"> </a>
<a name="ln2106">	/*</a>
<a name="ln2107">	 * Receive is done to a private pool of jumbo buffers.</a>
<a name="ln2108">	 * This allows us to attach to mbuf's and avoid re-mapping</a>
<a name="ln2109">	 * memory on each rx we post.  We allocate a large chunk</a>
<a name="ln2110">	 * of memory and manage it in the driver.  The mbuf free</a>
<a name="ln2111">	 * callback method is used to reclaim frames after sending</a>
<a name="ln2112">	 * them up the stack.  By default we allocate 2x the number of</a>
<a name="ln2113">	 * rx descriptors configured so we have some slop to hold</a>
<a name="ln2114">	 * us while frames are processed.</a>
<a name="ln2115">	 */</a>
<a name="ln2116">	if (mwl_rxbuf &lt; 2*mwl_rxdesc) {</a>
<a name="ln2117">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln2118">		    &quot;too few rx dma buffers (%d); increasing to %d\n&quot;,</a>
<a name="ln2119">		    mwl_rxbuf, 2*mwl_rxdesc);</a>
<a name="ln2120">		mwl_rxbuf = 2*mwl_rxdesc;</a>
<a name="ln2121">	}</a>
<a name="ln2122">	jumbosize = roundup(MWL_AGGR_SIZE, PAGE_SIZE);</a>
<a name="ln2123">	sc-&gt;sc_rxmemsize = mwl_rxbuf*jumbosize;</a>
<a name="ln2124"> </a>
<a name="ln2125">	error = bus_dma_tag_create(sc-&gt;sc_dmat,	/* parent */</a>
<a name="ln2126">		       PAGE_SIZE, 0,		/* alignment, bounds */</a>
<a name="ln2127">		       BUS_SPACE_MAXADDR_32BIT,	/* lowaddr */</a>
<a name="ln2128">		       BUS_SPACE_MAXADDR,	/* highaddr */</a>
<a name="ln2129">		       NULL, NULL,		/* filter, filterarg */</a>
<a name="ln2130">		       sc-&gt;sc_rxmemsize,	/* maxsize */</a>
<a name="ln2131">		       1,			/* nsegments */</a>
<a name="ln2132">		       sc-&gt;sc_rxmemsize,	/* maxsegsize */</a>
<a name="ln2133">		       BUS_DMA_ALLOCNOW,	/* flags */</a>
<a name="ln2134">		       NULL,			/* lockfunc */</a>
<a name="ln2135">		       NULL,			/* lockarg */</a>
<a name="ln2136">		       &amp;sc-&gt;sc_rxdmat);</a>
<a name="ln2137">	if (error != 0) {</a>
<a name="ln2138">		device_printf(sc-&gt;sc_dev, &quot;could not create rx DMA tag\n&quot;);</a>
<a name="ln2139">		return error;</a>
<a name="ln2140">	}</a>
<a name="ln2141"> </a>
<a name="ln2142">	error = bus_dmamem_alloc(sc-&gt;sc_rxdmat, (void**) &amp;sc-&gt;sc_rxmem,</a>
<a name="ln2143">				 BUS_DMA_NOWAIT | BUS_DMA_COHERENT,</a>
<a name="ln2144">				 &amp;sc-&gt;sc_rxmap);</a>
<a name="ln2145">	if (error != 0) {</a>
<a name="ln2146">		device_printf(sc-&gt;sc_dev, &quot;could not alloc %ju bytes of rx DMA memory\n&quot;,</a>
<a name="ln2147">		    (uintmax_t) sc-&gt;sc_rxmemsize);</a>
<a name="ln2148">		return error;</a>
<a name="ln2149">	}</a>
<a name="ln2150"> </a>
<a name="ln2151">	error = bus_dmamap_load(sc-&gt;sc_rxdmat, sc-&gt;sc_rxmap,</a>
<a name="ln2152">				sc-&gt;sc_rxmem, sc-&gt;sc_rxmemsize,</a>
<a name="ln2153">				mwl_load_cb, &amp;sc-&gt;sc_rxmem_paddr,</a>
<a name="ln2154">				BUS_DMA_NOWAIT);</a>
<a name="ln2155">	if (error != 0) {</a>
<a name="ln2156">		device_printf(sc-&gt;sc_dev, &quot;could not load rx DMA map\n&quot;);</a>
<a name="ln2157">		return error;</a>
<a name="ln2158">	}</a>
<a name="ln2159"> </a>
<a name="ln2160">	/*</a>
<a name="ln2161">	 * Allocate rx buffers and set them up.</a>
<a name="ln2162">	 */</a>
<a name="ln2163">	bsize = mwl_rxdesc * sizeof(struct mwl_rxbuf);</a>
<a name="ln2164">	bf = malloc(bsize, M_MWLDEV, M_NOWAIT | M_ZERO);</a>
<a name="ln2165">	if (bf == NULL) {</a>
<a name="ln2166">		device_printf(sc-&gt;sc_dev, &quot;malloc of %u rx buffers failed\n&quot;, bsize);</a>
<a name="ln2167">		return error;</a>
<a name="ln2168">	}</a>
<a name="ln2169">	sc-&gt;sc_rxdma.dd_bufptr = bf;</a>
<a name="ln2170"> </a>
<a name="ln2171">	STAILQ_INIT(&amp;sc-&gt;sc_rxbuf);</a>
<a name="ln2172">	ds = sc-&gt;sc_rxdma.dd_desc;</a>
<a name="ln2173">	for (i = 0; i &lt; mwl_rxdesc; i++, bf++, ds++) {</a>
<a name="ln2174">		bf-&gt;bf_desc = ds;</a>
<a name="ln2175">		bf-&gt;bf_daddr = DS2PHYS(&amp;sc-&gt;sc_rxdma, ds);</a>
<a name="ln2176">		/* pre-assign dma buffer */</a>
<a name="ln2177">		bf-&gt;bf_data = ((uint8_t *)sc-&gt;sc_rxmem) + (i*jumbosize);</a>
<a name="ln2178">		/* NB: tail is intentional to preserve descriptor order */</a>
<a name="ln2179">		STAILQ_INSERT_TAIL(&amp;sc-&gt;sc_rxbuf, bf, bf_list);</a>
<a name="ln2180">	}</a>
<a name="ln2181"> </a>
<a name="ln2182">	/*</a>
<a name="ln2183">	 * Place remainder of dma memory buffers on the free list.</a>
<a name="ln2184">	 */</a>
<a name="ln2185">	SLIST_INIT(&amp;sc-&gt;sc_rxfree);</a>
<a name="ln2186">	for (; i &lt; mwl_rxbuf; i++) {</a>
<a name="ln2187">		data = ((uint8_t *)sc-&gt;sc_rxmem) + (i*jumbosize);</a>
<a name="ln2188">		rbuf = MWL_JUMBO_DATA2BUF(data);</a>
<a name="ln2189">		SLIST_INSERT_HEAD(&amp;sc-&gt;sc_rxfree, rbuf, next);</a>
<a name="ln2190">		sc-&gt;sc_nrxfree++;</a>
<a name="ln2191">	}</a>
<a name="ln2192">	return 0;</a>
<a name="ln2193">}</a>
<a name="ln2194">#undef DS2PHYS</a>
<a name="ln2195"> </a>
<a name="ln2196">static void</a>
<a name="ln2197">mwl_rxdma_cleanup(struct mwl_softc *sc)</a>
<a name="ln2198">{</a>
<a name="ln2199">	if (sc-&gt;sc_rxmem_paddr != 0) {</a>
<a name="ln2200">		bus_dmamap_unload(sc-&gt;sc_rxdmat, sc-&gt;sc_rxmap);</a>
<a name="ln2201">		sc-&gt;sc_rxmem_paddr = 0;</a>
<a name="ln2202">	}</a>
<a name="ln2203">	if (sc-&gt;sc_rxmem != NULL) {</a>
<a name="ln2204">		bus_dmamem_free(sc-&gt;sc_rxdmat, sc-&gt;sc_rxmem, sc-&gt;sc_rxmap);</a>
<a name="ln2205">		sc-&gt;sc_rxmem = NULL;</a>
<a name="ln2206">	}</a>
<a name="ln2207">	if (sc-&gt;sc_rxdma.dd_bufptr != NULL) {</a>
<a name="ln2208">		free(sc-&gt;sc_rxdma.dd_bufptr, M_MWLDEV);</a>
<a name="ln2209">		sc-&gt;sc_rxdma.dd_bufptr = NULL;</a>
<a name="ln2210">	}</a>
<a name="ln2211">	if (sc-&gt;sc_rxdma.dd_desc_len != 0)</a>
<a name="ln2212">		mwl_desc_cleanup(sc, &amp;sc-&gt;sc_rxdma);</a>
<a name="ln2213">}</a>
<a name="ln2214"> </a>
<a name="ln2215">static int</a>
<a name="ln2216">mwl_dma_setup(struct mwl_softc *sc)</a>
<a name="ln2217">{</a>
<a name="ln2218">	int error, i;</a>
<a name="ln2219"> </a>
<a name="ln2220">	error = mwl_rxdma_setup(sc);</a>
<a name="ln2221">	if (error != 0) {</a>
<a name="ln2222">		mwl_rxdma_cleanup(sc);</a>
<a name="ln2223">		return error;</a>
<a name="ln2224">	}</a>
<a name="ln2225"> </a>
<a name="ln2226">	for (i = 0; i &lt; MWL_NUM_TX_QUEUES; i++) {</a>
<a name="ln2227">		error = mwl_txdma_setup(sc, &amp;sc-&gt;sc_txq[i]);</a>
<a name="ln2228">		if (error != 0) {</a>
<a name="ln2229">			mwl_dma_cleanup(sc);</a>
<a name="ln2230">			return error;</a>
<a name="ln2231">		}</a>
<a name="ln2232">	}</a>
<a name="ln2233">	return 0;</a>
<a name="ln2234">}</a>
<a name="ln2235"> </a>
<a name="ln2236">static void</a>
<a name="ln2237">mwl_dma_cleanup(struct mwl_softc *sc)</a>
<a name="ln2238">{</a>
<a name="ln2239">	int i;</a>
<a name="ln2240"> </a>
<a name="ln2241">	for (i = 0; i &lt; MWL_NUM_TX_QUEUES; i++)</a>
<a name="ln2242">		mwl_txdma_cleanup(sc, &amp;sc-&gt;sc_txq[i]);</a>
<a name="ln2243">	mwl_rxdma_cleanup(sc);</a>
<a name="ln2244">}</a>
<a name="ln2245"> </a>
<a name="ln2246">static struct ieee80211_node *</a>
<a name="ln2247">mwl_node_alloc(struct ieee80211vap *vap, const uint8_t mac[IEEE80211_ADDR_LEN])</a>
<a name="ln2248">{</a>
<a name="ln2249">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln2250">	struct mwl_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln2251">	const size_t space = sizeof(struct mwl_node);</a>
<a name="ln2252">	struct mwl_node *mn;</a>
<a name="ln2253"> </a>
<a name="ln2254">	mn = malloc(space, M_80211_NODE, M_NOWAIT|M_ZERO);</a>
<a name="ln2255">	if (mn == NULL) {</a>
<a name="ln2256">		/* XXX stat+msg */</a>
<a name="ln2257">		return NULL;</a>
<a name="ln2258">	}</a>
<a name="ln2259">	DPRINTF(sc, MWL_DEBUG_NODE, &quot;%s: mn %p\n&quot;, __func__, mn);</a>
<a name="ln2260">	return &amp;mn-&gt;mn_node;</a>
<a name="ln2261">}</a>
<a name="ln2262"> </a>
<a name="ln2263">static void</a>
<a name="ln2264">mwl_node_cleanup(struct ieee80211_node *ni)</a>
<a name="ln2265">{</a>
<a name="ln2266">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln2267">        struct mwl_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln2268">	struct mwl_node *mn = MWL_NODE(ni);</a>
<a name="ln2269"> </a>
<a name="ln2270">	DPRINTF(sc, MWL_DEBUG_NODE, &quot;%s: ni %p ic %p staid %d\n&quot;,</a>
<a name="ln2271">	    __func__, ni, ni-&gt;ni_ic, mn-&gt;mn_staid);</a>
<a name="ln2272"> </a>
<a name="ln2273">	if (mn-&gt;mn_staid != 0) {</a>
<a name="ln2274">		struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln2275"> </a>
<a name="ln2276">		if (mn-&gt;mn_hvap != NULL) {</a>
<a name="ln2277">			if (vap-&gt;iv_opmode == IEEE80211_M_STA)</a>
<a name="ln2278">				mwl_hal_delstation(mn-&gt;mn_hvap, vap-&gt;iv_myaddr);</a>
<a name="ln2279">			else</a>
<a name="ln2280">				mwl_hal_delstation(mn-&gt;mn_hvap, ni-&gt;ni_macaddr);</a>
<a name="ln2281">		}</a>
<a name="ln2282">		/*</a>
<a name="ln2283">		 * NB: legacy WDS peer sta db entry is installed using</a>
<a name="ln2284">		 * the associate ap's hvap; use it again to delete it.</a>
<a name="ln2285">		 * XXX can vap be NULL?</a>
<a name="ln2286">		 */</a>
<a name="ln2287">		else if (vap-&gt;iv_opmode == IEEE80211_M_WDS &amp;&amp;</a>
<a name="ln2288">		    MWL_VAP(vap)-&gt;mv_ap_hvap != NULL)</a>
<a name="ln2289">			mwl_hal_delstation(MWL_VAP(vap)-&gt;mv_ap_hvap,</a>
<a name="ln2290">			    ni-&gt;ni_macaddr);</a>
<a name="ln2291">		delstaid(sc, mn-&gt;mn_staid);</a>
<a name="ln2292">		mn-&gt;mn_staid = 0;</a>
<a name="ln2293">	}</a>
<a name="ln2294">	sc-&gt;sc_node_cleanup(ni);</a>
<a name="ln2295">}</a>
<a name="ln2296"> </a>
<a name="ln2297">/*</a>
<a name="ln2298"> * Reclaim rx dma buffers from packets sitting on the ampdu</a>
<a name="ln2299"> * reorder queue for a station.  We replace buffers with a</a>
<a name="ln2300"> * system cluster (if available).</a>
<a name="ln2301"> */</a>
<a name="ln2302">static void</a>
<a name="ln2303">mwl_ampdu_rxdma_reclaim(struct ieee80211_rx_ampdu *rap)</a>
<a name="ln2304">{</a>
<a name="ln2305">#if 0</a>
<a name="ln2306">	int i, n, off;</a>
<a name="ln2307">	struct mbuf *m;</a>
<a name="ln2308">	void *cl;</a>
<a name="ln2309"> </a>
<a name="ln2310">	n = rap-&gt;rxa_qframes;</a>
<a name="ln2311">	for (i = 0; i &lt; rap-&gt;rxa_wnd &amp;&amp; n &gt; 0; i++) {</a>
<a name="ln2312">		m = rap-&gt;rxa_m[i];</a>
<a name="ln2313">		if (m == NULL)</a>
<a name="ln2314">			continue;</a>
<a name="ln2315">		n--;</a>
<a name="ln2316">		/* our dma buffers have a well-known free routine */</a>
<a name="ln2317">		if ((m-&gt;m_flags &amp; M_EXT) == 0 ||</a>
<a name="ln2318">		    m-&gt;m_ext.ext_free != mwl_ext_free)</a>
<a name="ln2319">			continue;</a>
<a name="ln2320">		/*</a>
<a name="ln2321">		 * Try to allocate a cluster and move the data.</a>
<a name="ln2322">		 */</a>
<a name="ln2323">		off = m-&gt;m_data - m-&gt;m_ext.ext_buf;</a>
<a name="ln2324">		if (off + m-&gt;m_pkthdr.len &gt; MCLBYTES) {</a>
<a name="ln2325">			/* XXX no AMSDU for now */</a>
<a name="ln2326">			continue;</a>
<a name="ln2327">		}</a>
<a name="ln2328">		cl = pool_cache_get_paddr(&amp;mclpool_cache, 0,</a>
<a name="ln2329">		    &amp;m-&gt;m_ext.ext_paddr);</a>
<a name="ln2330">		if (cl != NULL) {</a>
<a name="ln2331">			/*</a>
<a name="ln2332">			 * Copy the existing data to the cluster, remove</a>
<a name="ln2333">			 * the rx dma buffer, and attach the cluster in</a>
<a name="ln2334">			 * its place.  Note we preserve the offset to the</a>
<a name="ln2335">			 * data so frames being bridged can still prepend</a>
<a name="ln2336">			 * their headers without adding another mbuf.</a>
<a name="ln2337">			 */</a>
<a name="ln2338">			memcpy((caddr_t) cl + off, m-&gt;m_data, m-&gt;m_pkthdr.len);</a>
<a name="ln2339">			MEXTREMOVE(m);</a>
<a name="ln2340">			MEXTADD(m, cl, MCLBYTES, 0, NULL, &amp;mclpool_cache);</a>
<a name="ln2341">			/* setup mbuf like _MCLGET does */</a>
<a name="ln2342">			m-&gt;m_flags |= M_CLUSTER | M_EXT_RW;</a>
<a name="ln2343">			_MOWNERREF(m, M_EXT | M_CLUSTER);</a>
<a name="ln2344">			/* NB: m_data is clobbered by MEXTADDR, adjust */</a>
<a name="ln2345">			m-&gt;m_data += off;</a>
<a name="ln2346">		}</a>
<a name="ln2347">	}</a>
<a name="ln2348">#endif</a>
<a name="ln2349">}</a>
<a name="ln2350"> </a>
<a name="ln2351">/*</a>
<a name="ln2352"> * Callback to reclaim resources.  We first let the</a>
<a name="ln2353"> * net80211 layer do it's thing, then if we are still</a>
<a name="ln2354"> * blocked by a lack of rx dma buffers we walk the ampdu</a>
<a name="ln2355"> * reorder q's to reclaim buffers by copying to a system</a>
<a name="ln2356"> * cluster.</a>
<a name="ln2357"> */</a>
<a name="ln2358">static void</a>
<a name="ln2359">mwl_node_drain(struct ieee80211_node *ni)</a>
<a name="ln2360">{</a>
<a name="ln2361">	struct ieee80211com *ic = ni-&gt;ni_ic;</a>
<a name="ln2362">        struct mwl_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln2363">	struct mwl_node *mn = MWL_NODE(ni);</a>
<a name="ln2364"> </a>
<a name="ln2365">	DPRINTF(sc, MWL_DEBUG_NODE, &quot;%s: ni %p vap %p staid %d\n&quot;,</a>
<a name="ln2366">	    __func__, ni, ni-&gt;ni_vap, mn-&gt;mn_staid);</a>
<a name="ln2367"> </a>
<a name="ln2368">	/* NB: call up first to age out ampdu q's */</a>
<a name="ln2369">	sc-&gt;sc_node_drain(ni);</a>
<a name="ln2370"> </a>
<a name="ln2371">	/* XXX better to not check low water mark? */</a>
<a name="ln2372">	if (sc-&gt;sc_rxblocked &amp;&amp; mn-&gt;mn_staid != 0 &amp;&amp;</a>
<a name="ln2373">	    (ni-&gt;ni_flags &amp; IEEE80211_NODE_HT)) {</a>
<a name="ln2374">		uint8_t tid;</a>
<a name="ln2375">		/*</a>
<a name="ln2376">		 * Walk the reorder q and reclaim rx dma buffers by copying</a>
<a name="ln2377">		 * the packet contents into clusters.</a>
<a name="ln2378">		 */</a>
<a name="ln2379">		for (tid = 0; tid &lt; WME_NUM_TID; tid++) {</a>
<a name="ln2380">			struct ieee80211_rx_ampdu *rap;</a>
<a name="ln2381"> </a>
<a name="ln2382">			rap = &amp;ni-&gt;ni_rx_ampdu[tid];</a>
<a name="ln2383">			if ((rap-&gt;rxa_flags &amp; IEEE80211_AGGR_XCHGPEND) == 0)</a>
<a name="ln2384">				continue;</a>
<a name="ln2385">			if (rap-&gt;rxa_qframes)</a>
<a name="ln2386">				mwl_ampdu_rxdma_reclaim(rap);</a>
<a name="ln2387">		}</a>
<a name="ln2388">	}</a>
<a name="ln2389">}</a>
<a name="ln2390"> </a>
<a name="ln2391">static void</a>
<a name="ln2392">mwl_node_getsignal(const struct ieee80211_node *ni, int8_t *rssi, int8_t *noise)</a>
<a name="ln2393">{</a>
<a name="ln2394">	*rssi = ni-&gt;ni_ic-&gt;ic_node_getrssi(ni);</a>
<a name="ln2395">#ifdef MWL_ANT_INFO_SUPPORT</a>
<a name="ln2396">#if 0</a>
<a name="ln2397">	/* XXX need to smooth data */</a>
<a name="ln2398">	*noise = -MWL_NODE_CONST(ni)-&gt;mn_ai.nf;</a>
<a name="ln2399">#else</a>
<a name="ln2400">	*noise = -95;		/* XXX */</a>
<a name="ln2401">#endif</a>
<a name="ln2402">#else</a>
<a name="ln2403">	*noise = -95;		/* XXX */</a>
<a name="ln2404">#endif</a>
<a name="ln2405">}</a>
<a name="ln2406"> </a>
<a name="ln2407">/*</a>
<a name="ln2408"> * Convert Hardware per-antenna rssi info to common format:</a>
<a name="ln2409"> * Let a1, a2, a3 represent the amplitudes per chain</a>
<a name="ln2410"> * Let amax represent max[a1, a2, a3]</a>
<a name="ln2411"> * Rssi1_dBm = RSSI_dBm + 20*log10(a1/amax)</a>
<a name="ln2412"> * Rssi1_dBm = RSSI_dBm + 20*log10(a1) - 20*log10(amax)</a>
<a name="ln2413"> * We store a table that is 4*20*log10(idx) - the extra 4 is to store or</a>
<a name="ln2414"> * maintain some extra precision.</a>
<a name="ln2415"> *</a>
<a name="ln2416"> * Values are stored in .5 db format capped at 127.</a>
<a name="ln2417"> */</a>
<a name="ln2418">static void</a>
<a name="ln2419">mwl_node_getmimoinfo(const struct ieee80211_node *ni,</a>
<a name="ln2420">	struct ieee80211_mimo_info *mi)</a>
<a name="ln2421">{</a>
<a name="ln2422">#define	CVT(_dst, _src) do {						\</a>
<a name="ln2423">	(_dst) = rssi + ((logdbtbl[_src] - logdbtbl[rssi_max]) &gt;&gt; 2);	\</a>
<a name="ln2424">	(_dst) = (_dst) &gt; 64 ? 127 : ((_dst) &lt;&lt; 1);			\</a>
<a name="ln2425">} while (0)</a>
<a name="ln2426">	static const int8_t logdbtbl[32] = {</a>
<a name="ln2427">	       0,   0,  24,  38,  48,  56,  62,  68,</a>
<a name="ln2428">	      72,  76,  80,  83,  86,  89,  92,  94,</a>
<a name="ln2429">	      96,  98, 100, 102, 104, 106, 107, 109,</a>
<a name="ln2430">	     110, 112, 113, 115, 116, 117, 118, 119</a>
<a name="ln2431">	};</a>
<a name="ln2432">	const struct mwl_node *mn = MWL_NODE_CONST(ni);</a>
<a name="ln2433">	uint8_t rssi = mn-&gt;mn_ai.rsvd1/2;		/* XXX */</a>
<a name="ln2434">	uint32_t rssi_max;</a>
<a name="ln2435"> </a>
<a name="ln2436">	rssi_max = mn-&gt;mn_ai.rssi_a;</a>
<a name="ln2437">	if (mn-&gt;mn_ai.rssi_b &gt; rssi_max)</a>
<a name="ln2438">		rssi_max = mn-&gt;mn_ai.rssi_b;</a>
<a name="ln2439">	if (mn-&gt;mn_ai.rssi_c &gt; rssi_max)</a>
<a name="ln2440">		rssi_max = mn-&gt;mn_ai.rssi_c;</a>
<a name="ln2441"> </a>
<a name="ln2442">	CVT(mi-&gt;ch[0].rssi[0], mn-&gt;mn_ai.rssi_a);</a>
<a name="ln2443">	CVT(mi-&gt;ch[1].rssi[0], mn-&gt;mn_ai.rssi_b);</a>
<a name="ln2444">	CVT(mi-&gt;ch[2].rssi[0], mn-&gt;mn_ai.rssi_c);</a>
<a name="ln2445"> </a>
<a name="ln2446">	mi-&gt;ch[0].noise[0] = mn-&gt;mn_ai.nf_a;</a>
<a name="ln2447">	mi-&gt;ch[1].noise[0] = mn-&gt;mn_ai.nf_b;</a>
<a name="ln2448">	mi-&gt;ch[2].noise[0] = mn-&gt;mn_ai.nf_c;</a>
<a name="ln2449">#undef CVT</a>
<a name="ln2450">}</a>
<a name="ln2451"> </a>
<a name="ln2452">static __inline void *</a>
<a name="ln2453">mwl_getrxdma(struct mwl_softc *sc)</a>
<a name="ln2454">{</a>
<a name="ln2455">	struct mwl_jumbo *buf;</a>
<a name="ln2456">	void *data;</a>
<a name="ln2457"> </a>
<a name="ln2458">	/*</a>
<a name="ln2459">	 * Allocate from jumbo pool.</a>
<a name="ln2460">	 */</a>
<a name="ln2461">	MWL_RXFREE_LOCK(sc);</a>
<a name="ln2462">	buf = SLIST_FIRST(&amp;sc-&gt;sc_rxfree);</a>
<a name="ln2463">	if (buf == NULL) {</a>
<a name="ln2464">		DPRINTF(sc, MWL_DEBUG_ANY,</a>
<a name="ln2465">		    &quot;%s: out of rx dma buffers\n&quot;, __func__);</a>
<a name="ln2466">		sc-&gt;sc_stats.mst_rx_nodmabuf++;</a>
<a name="ln2467">		data = NULL;</a>
<a name="ln2468">	} else {</a>
<a name="ln2469">		SLIST_REMOVE_HEAD(&amp;sc-&gt;sc_rxfree, next);</a>
<a name="ln2470">		sc-&gt;sc_nrxfree--;</a>
<a name="ln2471">		data = MWL_JUMBO_BUF2DATA(buf);</a>
<a name="ln2472">	}</a>
<a name="ln2473">	MWL_RXFREE_UNLOCK(sc);</a>
<a name="ln2474">	return data;</a>
<a name="ln2475">}</a>
<a name="ln2476"> </a>
<a name="ln2477">static __inline void</a>
<a name="ln2478">mwl_putrxdma(struct mwl_softc *sc, void *data)</a>
<a name="ln2479">{</a>
<a name="ln2480">	struct mwl_jumbo *buf;</a>
<a name="ln2481"> </a>
<a name="ln2482">	/* XXX bounds check data */</a>
<a name="ln2483">	MWL_RXFREE_LOCK(sc);</a>
<a name="ln2484">	buf = MWL_JUMBO_DATA2BUF(data);</a>
<a name="ln2485">	SLIST_INSERT_HEAD(&amp;sc-&gt;sc_rxfree, buf, next);</a>
<a name="ln2486">	sc-&gt;sc_nrxfree++;</a>
<a name="ln2487">	MWL_RXFREE_UNLOCK(sc);</a>
<a name="ln2488">}</a>
<a name="ln2489"> </a>
<a name="ln2490">static int</a>
<a name="ln2491">mwl_rxbuf_init(struct mwl_softc *sc, struct mwl_rxbuf *bf)</a>
<a name="ln2492">{</a>
<a name="ln2493">	struct mwl_rxdesc *ds;</a>
<a name="ln2494"> </a>
<a name="ln2495">	ds = bf-&gt;bf_desc;</a>
<a name="ln2496">	if (bf-&gt;bf_data == NULL) {</a>
<a name="ln2497">		bf-&gt;bf_data = mwl_getrxdma(sc);</a>
<a name="ln2498">		if (bf-&gt;bf_data == NULL) {</a>
<a name="ln2499">			/* mark descriptor to be skipped */</a>
<a name="ln2500">			ds-&gt;RxControl = EAGLE_RXD_CTRL_OS_OWN;</a>
<a name="ln2501">			/* NB: don't need PREREAD */</a>
<a name="ln2502">			MWL_RXDESC_SYNC(sc, ds, BUS_DMASYNC_PREWRITE);</a>
<a name="ln2503">			sc-&gt;sc_stats.mst_rxbuf_failed++;</a>
<a name="ln2504">			return ENOMEM;</a>
<a name="ln2505">		}</a>
<a name="ln2506">	}</a>
<a name="ln2507">	/*</a>
<a name="ln2508">	 * NB: DMA buffer contents is known to be unmodified</a>
<a name="ln2509">	 *     so there's no need to flush the data cache.</a>
<a name="ln2510">	 */</a>
<a name="ln2511"> </a>
<a name="ln2512">	/*</a>
<a name="ln2513">	 * Setup descriptor.</a>
<a name="ln2514">	 */</a>
<a name="ln2515">	ds-&gt;QosCtrl = 0;</a>
<a name="ln2516">	ds-&gt;RSSI = 0;</a>
<a name="ln2517">	ds-&gt;Status = EAGLE_RXD_STATUS_IDLE;</a>
<a name="ln2518">	ds-&gt;Channel = 0;</a>
<a name="ln2519">	ds-&gt;PktLen = htole16(MWL_AGGR_SIZE);</a>
<a name="ln2520">	ds-&gt;SQ2 = 0;</a>
<a name="ln2521">	ds-&gt;pPhysBuffData = htole32(MWL_JUMBO_DMA_ADDR(sc, bf-&gt;bf_data));</a>
<a name="ln2522">	/* NB: don't touch pPhysNext, set once */</a>
<a name="ln2523">	ds-&gt;RxControl = EAGLE_RXD_CTRL_DRIVER_OWN;</a>
<a name="ln2524">	MWL_RXDESC_SYNC(sc, ds, BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln2525"> </a>
<a name="ln2526">	return 0;</a>
<a name="ln2527">}</a>
<a name="ln2528"> </a>
<a name="ln2529">static void</a>
<a name="ln2530">mwl_ext_free(struct mbuf *m, void *data, void *arg)</a>
<a name="ln2531">{</a>
<a name="ln2532">	struct mwl_softc *sc = arg;</a>
<a name="ln2533"> </a>
<a name="ln2534">	/* XXX bounds check data */</a>
<a name="ln2535">	mwl_putrxdma(sc, m-&gt;m_ext.ext_buf);</a>
<a name="ln2536">	/*</a>
<a name="ln2537">	 * If we were previously blocked by a lack of rx dma buffers</a>
<a name="ln2538">	 * check if we now have enough to restart rx interrupt handling.</a>
<a name="ln2539">	 * NB: we know we are called at splvm which is above splnet.</a>
<a name="ln2540">	 */</a>
<a name="ln2541">	if (sc-&gt;sc_rxblocked &amp;&amp; sc-&gt;sc_nrxfree &gt; mwl_rxdmalow) {</a>
<a name="ln2542">		sc-&gt;sc_rxblocked = 0;</a>
<a name="ln2543">		mwl_hal_intrset(sc-&gt;sc_mh, sc-&gt;sc_imask);</a>
<a name="ln2544">	}</a>
<a name="ln2545">}</a>
<a name="ln2546"> </a>
<a name="ln2547">struct mwl_frame_bar {</a>
<a name="ln2548">	u_int8_t	i_fc[2];</a>
<a name="ln2549">	u_int8_t	i_dur[2];</a>
<a name="ln2550">	u_int8_t	i_ra[IEEE80211_ADDR_LEN];</a>
<a name="ln2551">	u_int8_t	i_ta[IEEE80211_ADDR_LEN];</a>
<a name="ln2552">	/* ctl, seq, FCS */</a>
<a name="ln2553">} __packed;</a>
<a name="ln2554"> </a>
<a name="ln2555">/*</a>
<a name="ln2556"> * Like ieee80211_anyhdrsize, but handles BAR frames</a>
<a name="ln2557"> * specially so the logic below to piece the 802.11</a>
<a name="ln2558"> * header together works.</a>
<a name="ln2559"> */</a>
<a name="ln2560">static __inline int</a>
<a name="ln2561">mwl_anyhdrsize(const void *data)</a>
<a name="ln2562">{</a>
<a name="ln2563">	const struct ieee80211_frame *wh = data;</a>
<a name="ln2564"> </a>
<a name="ln2565">	if ((wh-&gt;i_fc[0]&amp;IEEE80211_FC0_TYPE_MASK) == IEEE80211_FC0_TYPE_CTL) {</a>
<a name="ln2566">		switch (wh-&gt;i_fc[0] &amp; IEEE80211_FC0_SUBTYPE_MASK) {</a>
<a name="ln2567">		case IEEE80211_FC0_SUBTYPE_CTS:</a>
<a name="ln2568">		case IEEE80211_FC0_SUBTYPE_ACK:</a>
<a name="ln2569">			return sizeof(struct ieee80211_frame_ack);</a>
<a name="ln2570">		case IEEE80211_FC0_SUBTYPE_BAR:</a>
<a name="ln2571">			return sizeof(struct mwl_frame_bar);</a>
<a name="ln2572">		}</a>
<a name="ln2573">		return sizeof(struct ieee80211_frame_min);</a>
<a name="ln2574">	} else</a>
<a name="ln2575">		return ieee80211_hdrsize(data);</a>
<a name="ln2576">}</a>
<a name="ln2577"> </a>
<a name="ln2578">static void</a>
<a name="ln2579">mwl_handlemicerror(struct ieee80211com *ic, const uint8_t *data)</a>
<a name="ln2580">{</a>
<a name="ln2581">	const struct ieee80211_frame *wh;</a>
<a name="ln2582">	struct ieee80211_node *ni;</a>
<a name="ln2583"> </a>
<a name="ln2584">	wh = (const struct ieee80211_frame *)(data + sizeof(uint16_t));</a>
<a name="ln2585">	ni = ieee80211_find_rxnode(ic, (const struct ieee80211_frame_min *) wh);</a>
<a name="ln2586">	if (ni != NULL) {</a>
<a name="ln2587">		ieee80211_notify_michael_failure(ni-&gt;ni_vap, wh, 0);</a>
<a name="ln2588">		ieee80211_free_node(ni);</a>
<a name="ln2589">	}</a>
<a name="ln2590">}</a>
<a name="ln2591"> </a>
<a name="ln2592">/*</a>
<a name="ln2593"> * Convert hardware signal strength to rssi.  The value</a>
<a name="ln2594"> * provided by the device has the noise floor added in;</a>
<a name="ln2595"> * we need to compensate for this but we don't have that</a>
<a name="ln2596"> * so we use a fixed value.</a>
<a name="ln2597"> *</a>
<a name="ln2598"> * The offset of 8 is good for both 2.4 and 5GHz.  The LNA</a>
<a name="ln2599"> * offset is already set as part of the initial gain.  This</a>
<a name="ln2600"> * will give at least +/- 3dB for 2.4GHz and +/- 5dB for 5GHz.</a>
<a name="ln2601"> */</a>
<a name="ln2602">static __inline int</a>
<a name="ln2603">cvtrssi(uint8_t ssi)</a>
<a name="ln2604">{</a>
<a name="ln2605">	int rssi = (int) ssi + 8;</a>
<a name="ln2606">	/* XXX hack guess until we have a real noise floor */</a>
<a name="ln2607">	rssi = 2*(87 - rssi);	/* NB: .5 dBm units */</a>
<a name="ln2608">	return (rssi &lt; 0 ? 0 : rssi &gt; 127 ? 127 : rssi);</a>
<a name="ln2609">}</a>
<a name="ln2610"> </a>
<a name="ln2611">static void</a>
<a name="ln2612">mwl_rx_proc(void *arg, int npending)</a>
<a name="ln2613">{</a>
<a name="ln2614">	struct mwl_softc *sc = arg;</a>
<a name="ln2615">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln2616">	struct mwl_rxbuf *bf;</a>
<a name="ln2617">	struct mwl_rxdesc *ds;</a>
<a name="ln2618">	struct mbuf *m;</a>
<a name="ln2619">	struct ieee80211_qosframe *wh;</a>
<a name="ln2620">	struct ieee80211_qosframe_addr4 *wh4;</a>
<a name="ln2621">	struct ieee80211_node *ni;</a>
<a name="ln2622">	struct mwl_node *mn;</a>
<a name="ln2623">	int off, len, hdrlen, pktlen, rssi, ntodo;</a>
<a name="ln2624">	uint8_t *data, status;</a>
<a name="ln2625">	void *newdata;</a>
<a name="ln2626">	int16_t nf;</a>
<a name="ln2627"> </a>
<a name="ln2628">	DPRINTF(sc, MWL_DEBUG_RX_PROC, &quot;%s: pending %u rdptr 0x%x wrptr 0x%x\n&quot;,</a>
<a name="ln2629">	    __func__, npending, RD4(sc, sc-&gt;sc_hwspecs.rxDescRead),</a>
<a name="ln2630">	    RD4(sc, sc-&gt;sc_hwspecs.rxDescWrite));</a>
<a name="ln2631">	nf = -96;			/* XXX */</a>
<a name="ln2632">	bf = sc-&gt;sc_rxnext;</a>
<a name="ln2633">	for (ntodo = mwl_rxquota; ntodo &gt; 0; ntodo--) {</a>
<a name="ln2634">		if (bf == NULL)</a>
<a name="ln2635">			bf = STAILQ_FIRST(&amp;sc-&gt;sc_rxbuf);</a>
<a name="ln2636">		ds = bf-&gt;bf_desc;</a>
<a name="ln2637">		data = bf-&gt;bf_data;</a>
<a name="ln2638">		if (data == NULL) {</a>
<a name="ln2639">			/*</a>
<a name="ln2640">			 * If data allocation failed previously there</a>
<a name="ln2641">			 * will be no buffer; try again to re-populate it.</a>
<a name="ln2642">			 * Note the firmware will not advance to the next</a>
<a name="ln2643">			 * descriptor with a dma buffer so we must mimic</a>
<a name="ln2644">			 * this or we'll get out of sync.</a>
<a name="ln2645">			 */</a>
<a name="ln2646">			DPRINTF(sc, MWL_DEBUG_ANY,</a>
<a name="ln2647">			    &quot;%s: rx buf w/o dma memory\n&quot;, __func__);</a>
<a name="ln2648">			(void) mwl_rxbuf_init(sc, bf);</a>
<a name="ln2649">			sc-&gt;sc_stats.mst_rx_dmabufmissing++;</a>
<a name="ln2650">			break;</a>
<a name="ln2651">		}</a>
<a name="ln2652">		MWL_RXDESC_SYNC(sc, ds,</a>
<a name="ln2653">		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);</a>
<a name="ln2654">		if (ds-&gt;RxControl != EAGLE_RXD_CTRL_DMA_OWN)</a>
<a name="ln2655">			break;</a>
<a name="ln2656">#ifdef MWL_DEBUG</a>
<a name="ln2657">		if (sc-&gt;sc_debug &amp; MWL_DEBUG_RECV_DESC)</a>
<a name="ln2658">			mwl_printrxbuf(bf, 0);</a>
<a name="ln2659">#endif</a>
<a name="ln2660">		status = ds-&gt;Status;</a>
<a name="ln2661">		if (status &amp; EAGLE_RXD_STATUS_DECRYPT_ERR_MASK) {</a>
<a name="ln2662">			counter_u64_add(ic-&gt;ic_ierrors, 1);</a>
<a name="ln2663">			sc-&gt;sc_stats.mst_rx_crypto++;</a>
<a name="ln2664">			/*</a>
<a name="ln2665">			 * NB: Check EAGLE_RXD_STATUS_GENERAL_DECRYPT_ERR</a>
<a name="ln2666">			 *     for backwards compatibility.</a>
<a name="ln2667">			 */</a>
<a name="ln2668">			if (status != EAGLE_RXD_STATUS_GENERAL_DECRYPT_ERR &amp;&amp;</a>
<a name="ln2669">			    (status &amp; EAGLE_RXD_STATUS_TKIP_MIC_DECRYPT_ERR)) {</a>
<a name="ln2670">				/*</a>
<a name="ln2671">				 * MIC error, notify upper layers.</a>
<a name="ln2672">				 */</a>
<a name="ln2673">				bus_dmamap_sync(sc-&gt;sc_rxdmat, sc-&gt;sc_rxmap,</a>
<a name="ln2674">				    BUS_DMASYNC_POSTREAD);</a>
<a name="ln2675">				mwl_handlemicerror(ic, data);</a>
<a name="ln2676">				sc-&gt;sc_stats.mst_rx_tkipmic++;</a>
<a name="ln2677">			}</a>
<a name="ln2678">			/* XXX too painful to tap packets */</a>
<a name="ln2679">			goto rx_next;</a>
<a name="ln2680">		}</a>
<a name="ln2681">		/*</a>
<a name="ln2682">		 * Sync the data buffer.</a>
<a name="ln2683">		 */</a>
<a name="ln2684">		len = le16toh(ds-&gt;PktLen);</a>
<a name="ln2685">		bus_dmamap_sync(sc-&gt;sc_rxdmat, sc-&gt;sc_rxmap, BUS_DMASYNC_POSTREAD);</a>
<a name="ln2686">		/*</a>
<a name="ln2687">		 * The 802.11 header is provided all or in part at the front;</a>
<a name="ln2688">		 * use it to calculate the true size of the header that we'll</a>
<a name="ln2689">		 * construct below.  We use this to figure out where to copy</a>
<a name="ln2690">		 * payload prior to constructing the header.</a>
<a name="ln2691">		 */</a>
<a name="ln2692">		hdrlen = mwl_anyhdrsize(data + sizeof(uint16_t));</a>
<a name="ln2693">		off = sizeof(uint16_t) + sizeof(struct ieee80211_frame_addr4);</a>
<a name="ln2694"> </a>
<a name="ln2695">		/* calculate rssi early so we can re-use for each aggregate */</a>
<a name="ln2696">		rssi = cvtrssi(ds-&gt;RSSI);</a>
<a name="ln2697"> </a>
<a name="ln2698">		pktlen = hdrlen + (len - off);</a>
<a name="ln2699">		/*</a>
<a name="ln2700">		 * NB: we know our frame is at least as large as</a>
<a name="ln2701">		 * IEEE80211_MIN_LEN because there is a 4-address</a>
<a name="ln2702">		 * frame at the front.  Hence there's no need to</a>
<a name="ln2703">		 * vet the packet length.  If the frame in fact</a>
<a name="ln2704">		 * is too small it should be discarded at the</a>
<a name="ln2705">		 * net80211 layer.</a>
<a name="ln2706">		 */</a>
<a name="ln2707"> </a>
<a name="ln2708">		/*</a>
<a name="ln2709">		 * Attach dma buffer to an mbuf.  We tried</a>
<a name="ln2710">		 * doing this based on the packet size (i.e.</a>
<a name="ln2711">		 * copying small packets) but it turns out to</a>
<a name="ln2712">		 * be a net loss.  The tradeoff might be system</a>
<a name="ln2713">		 * dependent (cache architecture is important).</a>
<a name="ln2714">		 */</a>
<a name="ln2715">		MGETHDR(m, M_NOWAIT, MT_DATA);</a>
<a name="ln2716">		if (m == NULL) {</a>
<a name="ln2717">			DPRINTF(sc, MWL_DEBUG_ANY,</a>
<a name="ln2718">			    &quot;%s: no rx mbuf\n&quot;, __func__);</a>
<a name="ln2719">			sc-&gt;sc_stats.mst_rx_nombuf++;</a>
<a name="ln2720">			goto rx_next;</a>
<a name="ln2721">		}</a>
<a name="ln2722">		/*</a>
<a name="ln2723">		 * Acquire the replacement dma buffer before</a>
<a name="ln2724">		 * processing the frame.  If we're out of dma</a>
<a name="ln2725">		 * buffers we disable rx interrupts and wait</a>
<a name="ln2726">		 * for the free pool to reach mlw_rxdmalow buffers</a>
<a name="ln2727">		 * before starting to do work again.  If the firmware</a>
<a name="ln2728">		 * runs out of descriptors then it will toss frames</a>
<a name="ln2729">		 * which is better than our doing it as that can</a>
<a name="ln2730">		 * starve our processing.  It is also important that</a>
<a name="ln2731">		 * we always process rx'd frames in case they are</a>
<a name="ln2732">		 * A-MPDU as otherwise the host's view of the BA</a>
<a name="ln2733">		 * window may get out of sync with the firmware.</a>
<a name="ln2734">		 */</a>
<a name="ln2735">		newdata = mwl_getrxdma(sc);</a>
<a name="ln2736">		if (newdata == NULL) {</a>
<a name="ln2737">			/* NB: stat+msg in mwl_getrxdma */</a>
<a name="ln2738">			m_free(m);</a>
<a name="ln2739">			/* disable RX interrupt and mark state */</a>
<a name="ln2740">			mwl_hal_intrset(sc-&gt;sc_mh,</a>
<a name="ln2741">			    sc-&gt;sc_imask &amp;~ MACREG_A2HRIC_BIT_RX_RDY);</a>
<a name="ln2742">			sc-&gt;sc_rxblocked = 1;</a>
<a name="ln2743">			ieee80211_drain(ic);</a>
<a name="ln2744">			/* XXX check rxblocked and immediately start again? */</a>
<a name="ln2745">			goto rx_stop;</a>
<a name="ln2746">		}</a>
<a name="ln2747">		bf-&gt;bf_data = newdata;</a>
<a name="ln2748">		/*</a>
<a name="ln2749">		 * Attach the dma buffer to the mbuf;</a>
<a name="ln2750">		 * mwl_rxbuf_init will re-setup the rx</a>
<a name="ln2751">		 * descriptor using the replacement dma</a>
<a name="ln2752">		 * buffer we just installed above.</a>
<a name="ln2753">		 */</a>
<a name="ln2754">		MEXTADD(m, data, MWL_AGGR_SIZE, mwl_ext_free,</a>
<a name="ln2755">			data, sc, 0, EXT_NET_DRV);</a>
<a name="ln2756">		m-&gt;m_data += off - hdrlen;</a>
<a name="ln2757">		m-&gt;m_pkthdr.len = m-&gt;m_len = pktlen;</a>
<a name="ln2758">		/* NB: dma buffer assumed read-only */</a>
<a name="ln2759"> </a>
<a name="ln2760">		/*</a>
<a name="ln2761">		 * Piece 802.11 header together.</a>
<a name="ln2762">		 */</a>
<a name="ln2763">		wh = mtod(m, struct ieee80211_qosframe *);</a>
<a name="ln2764">		/* NB: don't need to do this sometimes but ... */</a>
<a name="ln2765">		/* XXX special case so we can memcpy after m_devget? */</a>
<a name="ln2766">		ovbcopy(data + sizeof(uint16_t), wh, hdrlen);</a>
<a name="ln2767">		if (IEEE80211_QOS_HAS_SEQ(wh)) {</a>
<a name="ln2768">			if (IEEE80211_IS_DSTODS(wh)) {</a>
<a name="ln2769">				wh4 = mtod(m,</a>
<a name="ln2770">				    struct ieee80211_qosframe_addr4*);</a>
<a name="ln2771">				*(uint16_t *)wh4-&gt;i_qos = ds-&gt;QosCtrl;</a>
<a name="ln2772">			} else {</a>
<a name="ln2773">				*(uint16_t *)wh-&gt;i_qos = ds-&gt;QosCtrl;</a>
<a name="ln2774">			}</a>
<a name="ln2775">		}</a>
<a name="ln2776">		/*</a>
<a name="ln2777">		 * The f/w strips WEP header but doesn't clear</a>
<a name="ln2778">		 * the WEP bit; mark the packet with M_WEP so</a>
<a name="ln2779">		 * net80211 will treat the data as decrypted.</a>
<a name="ln2780">		 * While here also clear the PWR_MGT bit since</a>
<a name="ln2781">		 * power save is handled by the firmware and</a>
<a name="ln2782">		 * passing this up will potentially cause the</a>
<a name="ln2783">		 * upper layer to put a station in power save</a>
<a name="ln2784">		 * (except when configured with MWL_HOST_PS_SUPPORT).</a>
<a name="ln2785">		 */</a>
<a name="ln2786">		if (wh-&gt;i_fc[1] &amp; IEEE80211_FC1_PROTECTED)</a>
<a name="ln2787">			m-&gt;m_flags |= M_WEP;</a>
<a name="ln2788">#ifdef MWL_HOST_PS_SUPPORT</a>
<a name="ln2789">		wh-&gt;i_fc[1] &amp;= ~IEEE80211_FC1_PROTECTED;</a>
<a name="ln2790">#else</a>
<a name="ln2791">		wh-&gt;i_fc[1] &amp;= ~(IEEE80211_FC1_PROTECTED |</a>
<a name="ln2792">		    IEEE80211_FC1_PWR_MGT);</a>
<a name="ln2793">#endif</a>
<a name="ln2794"> </a>
<a name="ln2795">		if (ieee80211_radiotap_active(ic)) {</a>
<a name="ln2796">			struct mwl_rx_radiotap_header *tap = &amp;sc-&gt;sc_rx_th;</a>
<a name="ln2797"> </a>
<a name="ln2798">			tap-&gt;wr_flags = 0;</a>
<a name="ln2799">			tap-&gt;wr_rate = ds-&gt;Rate;</a>
<a name="ln2800">			tap-&gt;wr_antsignal = rssi + nf;</a>
<a name="ln2801">			tap-&gt;wr_antnoise = nf;</a>
<a name="ln2802">		}</a>
<a name="ln2803">		if (IFF_DUMPPKTS_RECV(sc, wh)) {</a>
<a name="ln2804">			ieee80211_dump_pkt(ic, mtod(m, caddr_t),</a>
<a name="ln2805">			    len, ds-&gt;Rate, rssi);</a>
<a name="ln2806">		}</a>
<a name="ln2807">		/* dispatch */</a>
<a name="ln2808">		ni = ieee80211_find_rxnode(ic,</a>
<a name="ln2809">		    (const struct ieee80211_frame_min *) wh);</a>
<a name="ln2810">		if (ni != NULL) {</a>
<a name="ln2811">			mn = MWL_NODE(ni);</a>
<a name="ln2812">#ifdef MWL_ANT_INFO_SUPPORT</a>
<a name="ln2813">			mn-&gt;mn_ai.rssi_a = ds-&gt;ai.rssi_a;</a>
<a name="ln2814">			mn-&gt;mn_ai.rssi_b = ds-&gt;ai.rssi_b;</a>
<a name="ln2815">			mn-&gt;mn_ai.rssi_c = ds-&gt;ai.rssi_c;</a>
<a name="ln2816">			mn-&gt;mn_ai.rsvd1 = rssi;</a>
<a name="ln2817">#endif</a>
<a name="ln2818">			/* tag AMPDU aggregates for reorder processing */</a>
<a name="ln2819">			if (ni-&gt;ni_flags &amp; IEEE80211_NODE_HT)</a>
<a name="ln2820">				m-&gt;m_flags |= M_AMPDU;</a>
<a name="ln2821">			(void) ieee80211_input(ni, m, rssi, nf);</a>
<a name="ln2822">			ieee80211_free_node(ni);</a>
<a name="ln2823">		} else</a>
<a name="ln2824">			(void) ieee80211_input_all(ic, m, rssi, nf);</a>
<a name="ln2825">rx_next:</a>
<a name="ln2826">		/* NB: ignore ENOMEM so we process more descriptors */</a>
<a name="ln2827">		(void) mwl_rxbuf_init(sc, bf);</a>
<a name="ln2828">		bf = STAILQ_NEXT(bf, bf_list);</a>
<a name="ln2829">	}</a>
<a name="ln2830">rx_stop:</a>
<a name="ln2831">	sc-&gt;sc_rxnext = bf;</a>
<a name="ln2832"> </a>
<a name="ln2833">	if (mbufq_first(&amp;sc-&gt;sc_snd) != NULL) {</a>
<a name="ln2834">		/* NB: kick fw; the tx thread may have been preempted */</a>
<a name="ln2835">		mwl_hal_txstart(sc-&gt;sc_mh, 0);</a>
<a name="ln2836">		mwl_start(sc);</a>
<a name="ln2837">	}</a>
<a name="ln2838">}</a>
<a name="ln2839"> </a>
<a name="ln2840">static void</a>
<a name="ln2841">mwl_txq_init(struct mwl_softc *sc, struct mwl_txq *txq, int qnum)</a>
<a name="ln2842">{</a>
<a name="ln2843">	struct mwl_txbuf *bf, *bn;</a>
<a name="ln2844">	struct mwl_txdesc *ds;</a>
<a name="ln2845"> </a>
<a name="ln2846">	MWL_TXQ_LOCK_INIT(sc, txq);</a>
<a name="ln2847">	txq-&gt;qnum = qnum;</a>
<a name="ln2848">	txq-&gt;txpri = 0;	/* XXX */</a>
<a name="ln2849">#if 0</a>
<a name="ln2850">	/* NB: q setup by mwl_txdma_setup XXX */</a>
<a name="ln2851">	STAILQ_INIT(&amp;txq-&gt;free);</a>
<a name="ln2852">#endif</a>
<a name="ln2853">	STAILQ_FOREACH(bf, &amp;txq-&gt;free, bf_list) {</a>
<a name="ln2854">		bf-&gt;bf_txq = txq;</a>
<a name="ln2855"> </a>
<a name="ln2856">		ds = bf-&gt;bf_desc;</a>
<a name="ln2857">		bn = STAILQ_NEXT(bf, bf_list);</a>
<a name="ln2858">		if (bn == NULL)</a>
<a name="ln2859">			bn = STAILQ_FIRST(&amp;txq-&gt;free);</a>
<a name="ln2860">		ds-&gt;pPhysNext = htole32(bn-&gt;bf_daddr);</a>
<a name="ln2861">	}</a>
<a name="ln2862">	STAILQ_INIT(&amp;txq-&gt;active);</a>
<a name="ln2863">}</a>
<a name="ln2864"> </a>
<a name="ln2865">/*</a>
<a name="ln2866"> * Setup a hardware data transmit queue for the specified</a>
<a name="ln2867"> * access control.  We record the mapping from ac's</a>
<a name="ln2868"> * to h/w queues for use by mwl_tx_start.</a>
<a name="ln2869"> */</a>
<a name="ln2870">static int</a>
<a name="ln2871">mwl_tx_setup(struct mwl_softc *sc, int ac, int mvtype)</a>
<a name="ln2872">{</a>
<a name="ln2873">	struct mwl_txq *txq;</a>
<a name="ln2874"> </a>
<a name="ln2875">	if (ac &gt;= nitems(sc-&gt;sc_ac2q)) {</a>
<a name="ln2876">		device_printf(sc-&gt;sc_dev, &quot;AC %u out of range, max %zu!\n&quot;,</a>
<a name="ln2877">			ac, nitems(sc-&gt;sc_ac2q));</a>
<a name="ln2878">		return 0;</a>
<a name="ln2879">	}</a>
<a name="ln2880">	if (mvtype &gt;= MWL_NUM_TX_QUEUES) {</a>
<a name="ln2881">		device_printf(sc-&gt;sc_dev, &quot;mvtype %u out of range, max %u!\n&quot;,</a>
<a name="ln2882">			mvtype, MWL_NUM_TX_QUEUES);</a>
<a name="ln2883">		return 0;</a>
<a name="ln2884">	}</a>
<a name="ln2885">	txq = &amp;sc-&gt;sc_txq[mvtype];</a>
<a name="ln2886">	mwl_txq_init(sc, txq, mvtype);</a>
<a name="ln2887">	sc-&gt;sc_ac2q[ac] = txq;</a>
<a name="ln2888">	return 1;</a>
<a name="ln2889">}</a>
<a name="ln2890"> </a>
<a name="ln2891">/*</a>
<a name="ln2892"> * Update WME parameters for a transmit queue.</a>
<a name="ln2893"> */</a>
<a name="ln2894">static int</a>
<a name="ln2895">mwl_txq_update(struct mwl_softc *sc, int ac)</a>
<a name="ln2896">{</a>
<a name="ln2897">#define	MWL_EXPONENT_TO_VALUE(v)	((1&lt;&lt;v)-1)</a>
<a name="ln2898">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln2899">	struct chanAccParams chp;</a>
<a name="ln2900">	struct mwl_txq *txq = sc-&gt;sc_ac2q[ac];</a>
<a name="ln2901">	struct wmeParams *wmep;</a>
<a name="ln2902">	struct mwl_hal *mh = sc-&gt;sc_mh;</a>
<a name="ln2903">	int aifs, cwmin, cwmax, txoplim;</a>
<a name="ln2904"> </a>
<a name="ln2905">	ieee80211_wme_ic_getparams(ic, &amp;chp);</a>
<a name="ln2906">	wmep = &amp;chp.cap_wmeParams[ac];</a>
<a name="ln2907"> </a>
<a name="ln2908">	aifs = wmep-&gt;wmep_aifsn;</a>
<a name="ln2909">	/* XXX in sta mode need to pass log values for cwmin/max */</a>
<a name="ln2910">	cwmin = MWL_EXPONENT_TO_VALUE(wmep-&gt;wmep_logcwmin);</a>
<a name="ln2911">	cwmax = MWL_EXPONENT_TO_VALUE(wmep-&gt;wmep_logcwmax);</a>
<a name="ln2912">	txoplim = wmep-&gt;wmep_txopLimit;		/* NB: units of 32us */</a>
<a name="ln2913"> </a>
<a name="ln2914">	if (mwl_hal_setedcaparams(mh, txq-&gt;qnum, cwmin, cwmax, aifs, txoplim)) {</a>
<a name="ln2915">		device_printf(sc-&gt;sc_dev, &quot;unable to update hardware queue &quot;</a>
<a name="ln2916">			&quot;parameters for %s traffic!\n&quot;,</a>
<a name="ln2917">			ieee80211_wme_acnames[ac]);</a>
<a name="ln2918">		return 0;</a>
<a name="ln2919">	}</a>
<a name="ln2920">	return 1;</a>
<a name="ln2921">#undef MWL_EXPONENT_TO_VALUE</a>
<a name="ln2922">}</a>
<a name="ln2923"> </a>
<a name="ln2924">/*</a>
<a name="ln2925"> * Callback from the 802.11 layer to update WME parameters.</a>
<a name="ln2926"> */</a>
<a name="ln2927">static int</a>
<a name="ln2928">mwl_wme_update(struct ieee80211com *ic)</a>
<a name="ln2929">{</a>
<a name="ln2930">	struct mwl_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln2931"> </a>
<a name="ln2932">	return !mwl_txq_update(sc, WME_AC_BE) ||</a>
<a name="ln2933">	    !mwl_txq_update(sc, WME_AC_BK) ||</a>
<a name="ln2934">	    !mwl_txq_update(sc, WME_AC_VI) ||</a>
<a name="ln2935">	    !mwl_txq_update(sc, WME_AC_VO) ? EIO : 0;</a>
<a name="ln2936">}</a>
<a name="ln2937"> </a>
<a name="ln2938">/*</a>
<a name="ln2939"> * Reclaim resources for a setup queue.</a>
<a name="ln2940"> */</a>
<a name="ln2941">static void</a>
<a name="ln2942">mwl_tx_cleanupq(struct mwl_softc *sc, struct mwl_txq *txq)</a>
<a name="ln2943">{</a>
<a name="ln2944">	/* XXX hal work? */</a>
<a name="ln2945">	MWL_TXQ_LOCK_DESTROY(txq);</a>
<a name="ln2946">}</a>
<a name="ln2947"> </a>
<a name="ln2948">/*</a>
<a name="ln2949"> * Reclaim all tx queue resources.</a>
<a name="ln2950"> */</a>
<a name="ln2951">static void</a>
<a name="ln2952">mwl_tx_cleanup(struct mwl_softc *sc)</a>
<a name="ln2953">{</a>
<a name="ln2954">	int i;</a>
<a name="ln2955"> </a>
<a name="ln2956">	for (i = 0; i &lt; MWL_NUM_TX_QUEUES; i++)</a>
<a name="ln2957">		mwl_tx_cleanupq(sc, &amp;sc-&gt;sc_txq[i]);</a>
<a name="ln2958">}</a>
<a name="ln2959"> </a>
<a name="ln2960">static int</a>
<a name="ln2961">mwl_tx_dmasetup(struct mwl_softc *sc, struct mwl_txbuf *bf, struct mbuf *m0)</a>
<a name="ln2962">{</a>
<a name="ln2963">	struct mbuf *m;</a>
<a name="ln2964">	int error;</a>
<a name="ln2965"> </a>
<a name="ln2966">	/*</a>
<a name="ln2967">	 * Load the DMA map so any coalescing is done.  This</a>
<a name="ln2968">	 * also calculates the number of descriptors we need.</a>
<a name="ln2969">	 */</a>
<a name="ln2970">	error = bus_dmamap_load_mbuf_sg(sc-&gt;sc_dmat, bf-&gt;bf_dmamap, m0,</a>
<a name="ln2971">				     bf-&gt;bf_segs, &amp;bf-&gt;bf_nseg,</a>
<a name="ln2972">				     BUS_DMA_NOWAIT);</a>
<a name="ln2973">	if (error == EFBIG) {</a>
<a name="ln2974">		/* XXX packet requires too many descriptors */</a>
<a name="ln2975">		bf-&gt;bf_nseg = MWL_TXDESC+1;</a>
<a name="ln2976">	} else if (error != 0) {</a>
<a name="ln2977">		sc-&gt;sc_stats.mst_tx_busdma++;</a>
<a name="ln2978">		m_freem(m0);</a>
<a name="ln2979">		return error;</a>
<a name="ln2980">	}</a>
<a name="ln2981">	/*</a>
<a name="ln2982">	 * Discard null packets and check for packets that</a>
<a name="ln2983">	 * require too many TX descriptors.  We try to convert</a>
<a name="ln2984">	 * the latter to a cluster.</a>
<a name="ln2985">	 */</a>
<a name="ln2986">	if (error == EFBIG) {		/* too many desc's, linearize */</a>
<a name="ln2987">		sc-&gt;sc_stats.mst_tx_linear++;</a>
<a name="ln2988">#if MWL_TXDESC &gt; 1</a>
<a name="ln2989">		m = m_collapse(m0, M_NOWAIT, MWL_TXDESC);</a>
<a name="ln2990">#else</a>
<a name="ln2991">		m = m_defrag(m0, M_NOWAIT);</a>
<a name="ln2992">#endif</a>
<a name="ln2993">		if (m == NULL) {</a>
<a name="ln2994">			m_freem(m0);</a>
<a name="ln2995">			sc-&gt;sc_stats.mst_tx_nombuf++;</a>
<a name="ln2996">			return ENOMEM;</a>
<a name="ln2997">		}</a>
<a name="ln2998">		m0 = m;</a>
<a name="ln2999">		error = bus_dmamap_load_mbuf_sg(sc-&gt;sc_dmat, bf-&gt;bf_dmamap, m0,</a>
<a name="ln3000">					     bf-&gt;bf_segs, &amp;bf-&gt;bf_nseg,</a>
<a name="ln3001">					     BUS_DMA_NOWAIT);</a>
<a name="ln3002">		if (error != 0) {</a>
<a name="ln3003">			sc-&gt;sc_stats.mst_tx_busdma++;</a>
<a name="ln3004">			m_freem(m0);</a>
<a name="ln3005">			return error;</a>
<a name="ln3006">		}</a>
<a name="ln3007">		KASSERT(bf-&gt;bf_nseg &lt;= MWL_TXDESC,</a>
<a name="ln3008">		    (&quot;too many segments after defrag; nseg %u&quot;, bf-&gt;bf_nseg));</a>
<a name="ln3009">	} else if (bf-&gt;bf_nseg == 0) {		/* null packet, discard */</a>
<a name="ln3010">		sc-&gt;sc_stats.mst_tx_nodata++;</a>
<a name="ln3011">		m_freem(m0);</a>
<a name="ln3012">		return EIO;</a>
<a name="ln3013">	}</a>
<a name="ln3014">	DPRINTF(sc, MWL_DEBUG_XMIT, &quot;%s: m %p len %u\n&quot;,</a>
<a name="ln3015">		__func__, m0, m0-&gt;m_pkthdr.len);</a>
<a name="ln3016">	bus_dmamap_sync(sc-&gt;sc_dmat, bf-&gt;bf_dmamap, BUS_DMASYNC_PREWRITE);</a>
<a name="ln3017">	bf-&gt;bf_m = m0;</a>
<a name="ln3018"> </a>
<a name="ln3019">	return 0;</a>
<a name="ln3020">}</a>
<a name="ln3021"> </a>
<a name="ln3022">static __inline int</a>
<a name="ln3023">mwl_cvtlegacyrate(int rate)</a>
<a name="ln3024">{</a>
<a name="ln3025">	switch (rate) {</a>
<a name="ln3026">	case 2:	 return 0;</a>
<a name="ln3027">	case 4:	 return 1;</a>
<a name="ln3028">	case 11: return 2;</a>
<a name="ln3029">	case 22: return 3;</a>
<a name="ln3030">	case 44: return 4;</a>
<a name="ln3031">	case 12: return 5;</a>
<a name="ln3032">	case 18: return 6;</a>
<a name="ln3033">	case 24: return 7;</a>
<a name="ln3034">	case 36: return 8;</a>
<a name="ln3035">	case 48: return 9;</a>
<a name="ln3036">	case 72: return 10;</a>
<a name="ln3037">	case 96: return 11;</a>
<a name="ln3038">	case 108:return 12;</a>
<a name="ln3039">	}</a>
<a name="ln3040">	return 0;</a>
<a name="ln3041">}</a>
<a name="ln3042"> </a>
<a name="ln3043">/*</a>
<a name="ln3044"> * Calculate fixed tx rate information per client state;</a>
<a name="ln3045"> * this value is suitable for writing to the Format field</a>
<a name="ln3046"> * of a tx descriptor.</a>
<a name="ln3047"> */</a>
<a name="ln3048">static uint16_t</a>
<a name="ln3049">mwl_calcformat(uint8_t rate, const struct ieee80211_node *ni)</a>
<a name="ln3050">{</a>
<a name="ln3051">	uint16_t fmt;</a>
<a name="ln3052"> </a>
<a name="ln3053">	fmt = SM(3, EAGLE_TXD_ANTENNA)</a>
<a name="ln3054">	    | (IEEE80211_IS_CHAN_HT40D(ni-&gt;ni_chan) ?</a>
<a name="ln3055">		EAGLE_TXD_EXTCHAN_LO : EAGLE_TXD_EXTCHAN_HI);</a>
<a name="ln3056">	if (rate &amp; IEEE80211_RATE_MCS) {	/* HT MCS */</a>
<a name="ln3057">		fmt |= EAGLE_TXD_FORMAT_HT</a>
<a name="ln3058">		    /* NB: 0x80 implicitly stripped from ucastrate */</a>
<a name="ln3059">		    | SM(rate, EAGLE_TXD_RATE);</a>
<a name="ln3060">		/* XXX short/long GI may be wrong; re-check */</a>
<a name="ln3061">		if (IEEE80211_IS_CHAN_HT40(ni-&gt;ni_chan)) {</a>
<a name="ln3062">			fmt |= EAGLE_TXD_CHW_40</a>
<a name="ln3063">			    | (ni-&gt;ni_htcap &amp; IEEE80211_HTCAP_SHORTGI40 ?</a>
<a name="ln3064">			        EAGLE_TXD_GI_SHORT : EAGLE_TXD_GI_LONG);</a>
<a name="ln3065">		} else {</a>
<a name="ln3066">			fmt |= EAGLE_TXD_CHW_20</a>
<a name="ln3067">			    | (ni-&gt;ni_htcap &amp; IEEE80211_HTCAP_SHORTGI20 ?</a>
<a name="ln3068">			        EAGLE_TXD_GI_SHORT : EAGLE_TXD_GI_LONG);</a>
<a name="ln3069">		}</a>
<a name="ln3070">	} else {			/* legacy rate */</a>
<a name="ln3071">		fmt |= EAGLE_TXD_FORMAT_LEGACY</a>
<a name="ln3072">		    | SM(mwl_cvtlegacyrate(rate), EAGLE_TXD_RATE)</a>
<a name="ln3073">		    | EAGLE_TXD_CHW_20</a>
<a name="ln3074">		    /* XXX iv_flags &amp; IEEE80211_F_SHPREAMBLE? */</a>
<a name="ln3075">		    | (ni-&gt;ni_capinfo &amp; IEEE80211_CAPINFO_SHORT_PREAMBLE ?</a>
<a name="ln3076">			EAGLE_TXD_PREAMBLE_SHORT : EAGLE_TXD_PREAMBLE_LONG);</a>
<a name="ln3077">	}</a>
<a name="ln3078">	return fmt;</a>
<a name="ln3079">}</a>
<a name="ln3080"> </a>
<a name="ln3081">static int</a>
<a name="ln3082">mwl_tx_start(struct mwl_softc *sc, struct ieee80211_node *ni, struct mwl_txbuf *bf,</a>
<a name="ln3083">    struct mbuf *m0)</a>
<a name="ln3084">{</a>
<a name="ln3085">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln3086">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln3087">	int error, iswep, ismcast;</a>
<a name="ln3088">	int hdrlen, copyhdrlen, pktlen;</a>
<a name="ln3089">	struct mwl_txdesc *ds;</a>
<a name="ln3090">	struct mwl_txq *txq;</a>
<a name="ln3091">	struct ieee80211_frame *wh;</a>
<a name="ln3092">	struct mwltxrec *tr;</a>
<a name="ln3093">	struct mwl_node *mn;</a>
<a name="ln3094">	uint16_t qos;</a>
<a name="ln3095">#if MWL_TXDESC &gt; 1</a>
<a name="ln3096">	int i;</a>
<a name="ln3097">#endif</a>
<a name="ln3098"> </a>
<a name="ln3099">	wh = mtod(m0, struct ieee80211_frame *);</a>
<a name="ln3100">	iswep = wh-&gt;i_fc[1] &amp; IEEE80211_FC1_PROTECTED;</a>
<a name="ln3101">	ismcast = IEEE80211_IS_MULTICAST(wh-&gt;i_addr1);</a>
<a name="ln3102">	hdrlen = ieee80211_anyhdrsize(wh);</a>
<a name="ln3103">	copyhdrlen = hdrlen;</a>
<a name="ln3104">	pktlen = m0-&gt;m_pkthdr.len;</a>
<a name="ln3105">	if (IEEE80211_QOS_HAS_SEQ(wh)) {</a>
<a name="ln3106">		if (IEEE80211_IS_DSTODS(wh)) {</a>
<a name="ln3107">			qos = *(uint16_t *)</a>
<a name="ln3108">			    (((struct ieee80211_qosframe_addr4 *) wh)-&gt;i_qos);</a>
<a name="ln3109">			copyhdrlen -= sizeof(qos);</a>
<a name="ln3110">		} else</a>
<a name="ln3111">			qos = *(uint16_t *)</a>
<a name="ln3112">			    (((struct ieee80211_qosframe *) wh)-&gt;i_qos);</a>
<a name="ln3113">	} else</a>
<a name="ln3114">		qos = 0;</a>
<a name="ln3115"> </a>
<a name="ln3116">	if (iswep) {</a>
<a name="ln3117">		const struct ieee80211_cipher *cip;</a>
<a name="ln3118">		struct ieee80211_key *k;</a>
<a name="ln3119"> </a>
<a name="ln3120">		/*</a>
<a name="ln3121">		 * Construct the 802.11 header+trailer for an encrypted</a>
<a name="ln3122">		 * frame. The only reason this can fail is because of an</a>
<a name="ln3123">		 * unknown or unsupported cipher/key type.</a>
<a name="ln3124">		 *</a>
<a name="ln3125">		 * NB: we do this even though the firmware will ignore</a>
<a name="ln3126">		 *     what we've done for WEP and TKIP as we need the</a>
<a name="ln3127">		 *     ExtIV filled in for CCMP and this also adjusts</a>
<a name="ln3128">		 *     the headers which simplifies our work below.</a>
<a name="ln3129">		 */</a>
<a name="ln3130">		k = ieee80211_crypto_encap(ni, m0);</a>
<a name="ln3131">		if (k == NULL) {</a>
<a name="ln3132">			/*</a>
<a name="ln3133">			 * This can happen when the key is yanked after the</a>
<a name="ln3134">			 * frame was queued.  Just discard the frame; the</a>
<a name="ln3135">			 * 802.11 layer counts failures and provides</a>
<a name="ln3136">			 * debugging/diagnostics.</a>
<a name="ln3137">			 */</a>
<a name="ln3138">			m_freem(m0);</a>
<a name="ln3139">			return EIO;</a>
<a name="ln3140">		}</a>
<a name="ln3141">		/*</a>
<a name="ln3142">		 * Adjust the packet length for the crypto additions</a>
<a name="ln3143">		 * done during encap and any other bits that the f/w</a>
<a name="ln3144">		 * will add later on.</a>
<a name="ln3145">		 */</a>
<a name="ln3146">		cip = k-&gt;wk_cipher;</a>
<a name="ln3147">		pktlen += cip-&gt;ic_header + cip-&gt;ic_miclen + cip-&gt;ic_trailer;</a>
<a name="ln3148"> </a>
<a name="ln3149">		/* packet header may have moved, reset our local pointer */</a>
<a name="ln3150">		wh = mtod(m0, struct ieee80211_frame *);</a>
<a name="ln3151">	}</a>
<a name="ln3152"> </a>
<a name="ln3153">	if (ieee80211_radiotap_active_vap(vap)) {</a>
<a name="ln3154">		sc-&gt;sc_tx_th.wt_flags = 0;	/* XXX */</a>
<a name="ln3155">		if (iswep)</a>
<a name="ln3156">			sc-&gt;sc_tx_th.wt_flags |= IEEE80211_RADIOTAP_F_WEP;</a>
<a name="ln3157">#if 0</a>
<a name="ln3158">		sc-&gt;sc_tx_th.wt_rate = ds-&gt;DataRate;</a>
<a name="ln3159">#endif</a>
<a name="ln3160">		sc-&gt;sc_tx_th.wt_txpower = ni-&gt;ni_txpower;</a>
<a name="ln3161">		sc-&gt;sc_tx_th.wt_antenna = sc-&gt;sc_txantenna;</a>
<a name="ln3162"> </a>
<a name="ln3163">		ieee80211_radiotap_tx(vap, m0);</a>
<a name="ln3164">	}</a>
<a name="ln3165">	/*</a>
<a name="ln3166">	 * Copy up/down the 802.11 header; the firmware requires</a>
<a name="ln3167">	 * we present a 2-byte payload length followed by a</a>
<a name="ln3168">	 * 4-address header (w/o QoS), followed (optionally) by</a>
<a name="ln3169">	 * any WEP/ExtIV header (but only filled in for CCMP).</a>
<a name="ln3170">	 * We are assured the mbuf has sufficient headroom to</a>
<a name="ln3171">	 * prepend in-place by the setup of ic_headroom in</a>
<a name="ln3172">	 * mwl_attach.</a>
<a name="ln3173">	 */</a>
<a name="ln3174">	if (hdrlen &lt; sizeof(struct mwltxrec)) {</a>
<a name="ln3175">		const int space = sizeof(struct mwltxrec) - hdrlen;</a>
<a name="ln3176">		if (M_LEADINGSPACE(m0) &lt; space) {</a>
<a name="ln3177">			/* NB: should never happen */</a>
<a name="ln3178">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln3179">			    &quot;not enough headroom, need %d found %zd, &quot;</a>
<a name="ln3180">			    &quot;m_flags 0x%x m_len %d\n&quot;,</a>
<a name="ln3181">			    space, M_LEADINGSPACE(m0), m0-&gt;m_flags, m0-&gt;m_len);</a>
<a name="ln3182">			ieee80211_dump_pkt(ic,</a>
<a name="ln3183">			    mtod(m0, const uint8_t *), m0-&gt;m_len, 0, -1);</a>
<a name="ln3184">			m_freem(m0);</a>
<a name="ln3185">			sc-&gt;sc_stats.mst_tx_noheadroom++;</a>
<a name="ln3186">			return EIO;</a>
<a name="ln3187">		}</a>
<a name="ln3188">		M_PREPEND(m0, space, M_NOWAIT);</a>
<a name="ln3189">	}</a>
<a name="ln3190">	tr = mtod(m0, struct mwltxrec *);</a>
<a name="ln3191">	if (wh != (struct ieee80211_frame *) &amp;tr-&gt;wh)</a>
<a name="ln3192">		ovbcopy(wh, &amp;tr-&gt;wh, hdrlen);</a>
<a name="ln3193">	/*</a>
<a name="ln3194">	 * Note: the &quot;firmware length&quot; is actually the length</a>
<a name="ln3195">	 * of the fully formed &quot;802.11 payload&quot;.  That is, it's</a>
<a name="ln3196">	 * everything except for the 802.11 header.  In particular</a>
<a name="ln3197">	 * this includes all crypto material including the MIC!</a>
<a name="ln3198">	 */</a>
<a name="ln3199">	tr-&gt;fwlen = htole16(pktlen - hdrlen);</a>
<a name="ln3200"> </a>
<a name="ln3201">	/*</a>
<a name="ln3202">	 * Load the DMA map so any coalescing is done.  This</a>
<a name="ln3203">	 * also calculates the number of descriptors we need.</a>
<a name="ln3204">	 */</a>
<a name="ln3205">	error = mwl_tx_dmasetup(sc, bf, m0);</a>
<a name="ln3206">	if (error != 0) {</a>
<a name="ln3207">		/* NB: stat collected in mwl_tx_dmasetup */</a>
<a name="ln3208">		DPRINTF(sc, MWL_DEBUG_XMIT,</a>
<a name="ln3209">		    &quot;%s: unable to setup dma\n&quot;, __func__);</a>
<a name="ln3210">		return error;</a>
<a name="ln3211">	}</a>
<a name="ln3212">	bf-&gt;bf_node = ni;			/* NB: held reference */</a>
<a name="ln3213">	m0 = bf-&gt;bf_m;				/* NB: may have changed */</a>
<a name="ln3214">	tr = mtod(m0, struct mwltxrec *);</a>
<a name="ln3215">	wh = (struct ieee80211_frame *)&amp;tr-&gt;wh;</a>
<a name="ln3216"> </a>
<a name="ln3217">	/*</a>
<a name="ln3218">	 * Formulate tx descriptor.</a>
<a name="ln3219">	 */</a>
<a name="ln3220">	ds = bf-&gt;bf_desc;</a>
<a name="ln3221">	txq = bf-&gt;bf_txq;</a>
<a name="ln3222"> </a>
<a name="ln3223">	ds-&gt;QosCtrl = qos;			/* NB: already little-endian */</a>
<a name="ln3224">#if MWL_TXDESC == 1</a>
<a name="ln3225">	/*</a>
<a name="ln3226">	 * NB: multiframes should be zero because the descriptors</a>
<a name="ln3227">	 *     are initialized to zero.  This should handle the case</a>
<a name="ln3228">	 *     where the driver is built with MWL_TXDESC=1 but we are</a>
<a name="ln3229">	 *     using firmware with multi-segment support.</a>
<a name="ln3230">	 */</a>
<a name="ln3231">	ds-&gt;PktPtr = htole32(bf-&gt;bf_segs[0].ds_addr);</a>
<a name="ln3232">	ds-&gt;PktLen = htole16(bf-&gt;bf_segs[0].ds_len);</a>
<a name="ln3233">#else</a>
<a name="ln3234">	ds-&gt;multiframes = htole32(bf-&gt;bf_nseg);</a>
<a name="ln3235">	ds-&gt;PktLen = htole16(m0-&gt;m_pkthdr.len);</a>
<a name="ln3236">	for (i = 0; i &lt; bf-&gt;bf_nseg; i++) {</a>
<a name="ln3237">		ds-&gt;PktPtrArray[i] = htole32(bf-&gt;bf_segs[i].ds_addr);</a>
<a name="ln3238">		ds-&gt;PktLenArray[i] = htole16(bf-&gt;bf_segs[i].ds_len);</a>
<a name="ln3239">	}</a>
<a name="ln3240">#endif</a>
<a name="ln3241">	/* NB: pPhysNext, DataRate, and SapPktInfo setup once, don't touch */</a>
<a name="ln3242">	ds-&gt;Format = 0;</a>
<a name="ln3243">	ds-&gt;pad = 0;</a>
<a name="ln3244">	ds-&gt;ack_wcb_addr = 0;</a>
<a name="ln3245"> </a>
<a name="ln3246">	mn = MWL_NODE(ni);</a>
<a name="ln3247">	/*</a>
<a name="ln3248">	 * Select transmit rate.</a>
<a name="ln3249">	 */</a>
<a name="ln3250">	switch (wh-&gt;i_fc[0] &amp; IEEE80211_FC0_TYPE_MASK) {</a>
<a name="ln3251">	case IEEE80211_FC0_TYPE_MGT:</a>
<a name="ln3252">		sc-&gt;sc_stats.mst_tx_mgmt++;</a>
<a name="ln3253">		/* fall thru... */</a>
<a name="ln3254">	case IEEE80211_FC0_TYPE_CTL:</a>
<a name="ln3255">		/* NB: assign to BE q to avoid bursting */</a>
<a name="ln3256">		ds-&gt;TxPriority = MWL_WME_AC_BE;</a>
<a name="ln3257">		break;</a>
<a name="ln3258">	case IEEE80211_FC0_TYPE_DATA:</a>
<a name="ln3259">		if (!ismcast) {</a>
<a name="ln3260">			const struct ieee80211_txparam *tp = ni-&gt;ni_txparms;</a>
<a name="ln3261">			/*</a>
<a name="ln3262">			 * EAPOL frames get forced to a fixed rate and w/o</a>
<a name="ln3263">			 * aggregation; otherwise check for any fixed rate</a>
<a name="ln3264">			 * for the client (may depend on association state).</a>
<a name="ln3265">			 */</a>
<a name="ln3266">			if (m0-&gt;m_flags &amp; M_EAPOL) {</a>
<a name="ln3267">				const struct mwl_vap *mvp = MWL_VAP_CONST(vap);</a>
<a name="ln3268">				ds-&gt;Format = mvp-&gt;mv_eapolformat;</a>
<a name="ln3269">				ds-&gt;pad = htole16(</a>
<a name="ln3270">				    EAGLE_TXD_FIXED_RATE | EAGLE_TXD_DONT_AGGR);</a>
<a name="ln3271">			} else if (tp-&gt;ucastrate != IEEE80211_FIXED_RATE_NONE) {</a>
<a name="ln3272">				/* XXX pre-calculate per node */</a>
<a name="ln3273">				ds-&gt;Format = htole16(</a>
<a name="ln3274">				    mwl_calcformat(tp-&gt;ucastrate, ni));</a>
<a name="ln3275">				ds-&gt;pad = htole16(EAGLE_TXD_FIXED_RATE);</a>
<a name="ln3276">			}</a>
<a name="ln3277">			/* NB: EAPOL frames will never have qos set */</a>
<a name="ln3278">			if (qos == 0)</a>
<a name="ln3279">				ds-&gt;TxPriority = txq-&gt;qnum;</a>
<a name="ln3280">#if MWL_MAXBA &gt; 3</a>
<a name="ln3281">			else if (mwl_bastream_match(&amp;mn-&gt;mn_ba[3], qos))</a>
<a name="ln3282">				ds-&gt;TxPriority = mn-&gt;mn_ba[3].txq;</a>
<a name="ln3283">#endif</a>
<a name="ln3284">#if MWL_MAXBA &gt; 2</a>
<a name="ln3285">			else if (mwl_bastream_match(&amp;mn-&gt;mn_ba[2], qos))</a>
<a name="ln3286">				ds-&gt;TxPriority = mn-&gt;mn_ba[2].txq;</a>
<a name="ln3287">#endif</a>
<a name="ln3288">#if MWL_MAXBA &gt; 1</a>
<a name="ln3289">			else if (mwl_bastream_match(&amp;mn-&gt;mn_ba[1], qos))</a>
<a name="ln3290">				ds-&gt;TxPriority = mn-&gt;mn_ba[1].txq;</a>
<a name="ln3291">#endif</a>
<a name="ln3292">#if MWL_MAXBA &gt; 0</a>
<a name="ln3293">			else if (mwl_bastream_match(&amp;mn-&gt;mn_ba[0], qos))</a>
<a name="ln3294">				ds-&gt;TxPriority = mn-&gt;mn_ba[0].txq;</a>
<a name="ln3295">#endif</a>
<a name="ln3296">			else</a>
<a name="ln3297">				ds-&gt;TxPriority = txq-&gt;qnum;</a>
<a name="ln3298">		} else</a>
<a name="ln3299">			ds-&gt;TxPriority = txq-&gt;qnum;</a>
<a name="ln3300">		break;</a>
<a name="ln3301">	default:</a>
<a name="ln3302">		device_printf(sc-&gt;sc_dev, &quot;bogus frame type 0x%x (%s)\n&quot;,</a>
<a name="ln3303">			wh-&gt;i_fc[0] &amp; IEEE80211_FC0_TYPE_MASK, __func__);</a>
<a name="ln3304">		sc-&gt;sc_stats.mst_tx_badframetype++;</a>
<a name="ln3305">		m_freem(m0);</a>
<a name="ln3306">		return EIO;</a>
<a name="ln3307">	}</a>
<a name="ln3308"> </a>
<a name="ln3309">	if (IFF_DUMPPKTS_XMIT(sc))</a>
<a name="ln3310">		ieee80211_dump_pkt(ic,</a>
<a name="ln3311">		    mtod(m0, const uint8_t *)+sizeof(uint16_t),</a>
<a name="ln3312">		    m0-&gt;m_len - sizeof(uint16_t), ds-&gt;DataRate, -1);</a>
<a name="ln3313"> </a>
<a name="ln3314">	MWL_TXQ_LOCK(txq);</a>
<a name="ln3315">	ds-&gt;Status = htole32(EAGLE_TXD_STATUS_FW_OWNED);</a>
<a name="ln3316">	STAILQ_INSERT_TAIL(&amp;txq-&gt;active, bf, bf_list);</a>
<a name="ln3317">	MWL_TXDESC_SYNC(txq, ds, BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);</a>
<a name="ln3318"> </a>
<a name="ln3319">	sc-&gt;sc_tx_timer = 5;</a>
<a name="ln3320">	MWL_TXQ_UNLOCK(txq);</a>
<a name="ln3321"> </a>
<a name="ln3322">	return 0;</a>
<a name="ln3323">}</a>
<a name="ln3324"> </a>
<a name="ln3325">static __inline int</a>
<a name="ln3326">mwl_cvtlegacyrix(int rix)</a>
<a name="ln3327">{</a>
<a name="ln3328">	static const int ieeerates[] =</a>
<a name="ln3329">	    { 2, 4, 11, 22, 44, 12, 18, 24, 36, 48, 72, 96, 108 };</a>
<a name="ln3330">	return (rix &lt; nitems(ieeerates) ? ieeerates[rix] : 0);</a>
<a name="ln3331">}</a>
<a name="ln3332"> </a>
<a name="ln3333">/*</a>
<a name="ln3334"> * Process completed xmit descriptors from the specified queue.</a>
<a name="ln3335"> */</a>
<a name="ln3336">static int</a>
<a name="ln3337">mwl_tx_processq(struct mwl_softc *sc, struct mwl_txq *txq)</a>
<a name="ln3338">{</a>
<a name="ln3339">#define	EAGLE_TXD_STATUS_MCAST \</a>
<a name="ln3340">	(EAGLE_TXD_STATUS_MULTICAST_TX | EAGLE_TXD_STATUS_BROADCAST_TX)</a>
<a name="ln3341">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln3342">	struct mwl_txbuf *bf;</a>
<a name="ln3343">	struct mwl_txdesc *ds;</a>
<a name="ln3344">	struct ieee80211_node *ni;</a>
<a name="ln3345">	struct mwl_node *an;</a>
<a name="ln3346">	int nreaped;</a>
<a name="ln3347">	uint32_t status;</a>
<a name="ln3348"> </a>
<a name="ln3349">	DPRINTF(sc, MWL_DEBUG_TX_PROC, &quot;%s: tx queue %u\n&quot;, __func__, txq-&gt;qnum);</a>
<a name="ln3350">	for (nreaped = 0;; nreaped++) {</a>
<a name="ln3351">		MWL_TXQ_LOCK(txq);</a>
<a name="ln3352">		bf = STAILQ_FIRST(&amp;txq-&gt;active);</a>
<a name="ln3353">		if (bf == NULL) {</a>
<a name="ln3354">			MWL_TXQ_UNLOCK(txq);</a>
<a name="ln3355">			break;</a>
<a name="ln3356">		}</a>
<a name="ln3357">		ds = bf-&gt;bf_desc;</a>
<a name="ln3358">		MWL_TXDESC_SYNC(txq, ds,</a>
<a name="ln3359">		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);</a>
<a name="ln3360">		if (ds-&gt;Status &amp; htole32(EAGLE_TXD_STATUS_FW_OWNED)) {</a>
<a name="ln3361">			MWL_TXQ_UNLOCK(txq);</a>
<a name="ln3362">			break;</a>
<a name="ln3363">		}</a>
<a name="ln3364">		STAILQ_REMOVE_HEAD(&amp;txq-&gt;active, bf_list);</a>
<a name="ln3365">		MWL_TXQ_UNLOCK(txq);</a>
<a name="ln3366"> </a>
<a name="ln3367">#ifdef MWL_DEBUG</a>
<a name="ln3368">		if (sc-&gt;sc_debug &amp; MWL_DEBUG_XMIT_DESC)</a>
<a name="ln3369">			mwl_printtxbuf(bf, txq-&gt;qnum, nreaped);</a>
<a name="ln3370">#endif</a>
<a name="ln3371">		ni = bf-&gt;bf_node;</a>
<a name="ln3372">		if (ni != NULL) {</a>
<a name="ln3373">			an = MWL_NODE(ni);</a>
<a name="ln3374">			status = le32toh(ds-&gt;Status);</a>
<a name="ln3375">			if (status &amp; EAGLE_TXD_STATUS_OK) {</a>
<a name="ln3376">				uint16_t Format = le16toh(ds-&gt;Format);</a>
<a name="ln3377">				uint8_t txant = MS(Format, EAGLE_TXD_ANTENNA);</a>
<a name="ln3378"> </a>
<a name="ln3379">				sc-&gt;sc_stats.mst_ant_tx[txant]++;</a>
<a name="ln3380">				if (status &amp; EAGLE_TXD_STATUS_OK_RETRY)</a>
<a name="ln3381">					sc-&gt;sc_stats.mst_tx_retries++;</a>
<a name="ln3382">				if (status &amp; EAGLE_TXD_STATUS_OK_MORE_RETRY)</a>
<a name="ln3383">					sc-&gt;sc_stats.mst_tx_mretries++;</a>
<a name="ln3384">				if (txq-&gt;qnum &gt;= MWL_WME_AC_VO)</a>
<a name="ln3385">					ic-&gt;ic_wme.wme_hipri_traffic++;</a>
<a name="ln3386">				ni-&gt;ni_txrate = MS(Format, EAGLE_TXD_RATE);</a>
<a name="ln3387">				if ((Format &amp; EAGLE_TXD_FORMAT_HT) == 0) {</a>
<a name="ln3388">					ni-&gt;ni_txrate = mwl_cvtlegacyrix(</a>
<a name="ln3389">					    ni-&gt;ni_txrate);</a>
<a name="ln3390">				} else</a>
<a name="ln3391">					ni-&gt;ni_txrate |= IEEE80211_RATE_MCS;</a>
<a name="ln3392">				sc-&gt;sc_stats.mst_tx_rate = ni-&gt;ni_txrate;</a>
<a name="ln3393">			} else {</a>
<a name="ln3394">				if (status &amp; EAGLE_TXD_STATUS_FAILED_LINK_ERROR)</a>
<a name="ln3395">					sc-&gt;sc_stats.mst_tx_linkerror++;</a>
<a name="ln3396">				if (status &amp; EAGLE_TXD_STATUS_FAILED_XRETRY)</a>
<a name="ln3397">					sc-&gt;sc_stats.mst_tx_xretries++;</a>
<a name="ln3398">				if (status &amp; EAGLE_TXD_STATUS_FAILED_AGING)</a>
<a name="ln3399">					sc-&gt;sc_stats.mst_tx_aging++;</a>
<a name="ln3400">				if (bf-&gt;bf_m-&gt;m_flags &amp; M_FF)</a>
<a name="ln3401">					sc-&gt;sc_stats.mst_ff_txerr++;</a>
<a name="ln3402">			}</a>
<a name="ln3403">			if (bf-&gt;bf_m-&gt;m_flags &amp; M_TXCB)</a>
<a name="ln3404">				/* XXX strip fw len in case header inspected */</a>
<a name="ln3405">				m_adj(bf-&gt;bf_m, sizeof(uint16_t));</a>
<a name="ln3406">			ieee80211_tx_complete(ni, bf-&gt;bf_m,</a>
<a name="ln3407">			    (status &amp; EAGLE_TXD_STATUS_OK) == 0);</a>
<a name="ln3408">		} else</a>
<a name="ln3409">			m_freem(bf-&gt;bf_m);</a>
<a name="ln3410">		ds-&gt;Status = htole32(EAGLE_TXD_STATUS_IDLE);</a>
<a name="ln3411"> </a>
<a name="ln3412">		bus_dmamap_sync(sc-&gt;sc_dmat, bf-&gt;bf_dmamap,</a>
<a name="ln3413">		    BUS_DMASYNC_POSTWRITE);</a>
<a name="ln3414">		bus_dmamap_unload(sc-&gt;sc_dmat, bf-&gt;bf_dmamap);</a>
<a name="ln3415"> </a>
<a name="ln3416">		mwl_puttxbuf_tail(txq, bf);</a>
<a name="ln3417">	}</a>
<a name="ln3418">	return nreaped;</a>
<a name="ln3419">#undef EAGLE_TXD_STATUS_MCAST</a>
<a name="ln3420">}</a>
<a name="ln3421"> </a>
<a name="ln3422">/*</a>
<a name="ln3423"> * Deferred processing of transmit interrupt; special-cased</a>
<a name="ln3424"> * for four hardware queues, 0-3.</a>
<a name="ln3425"> */</a>
<a name="ln3426">static void</a>
<a name="ln3427">mwl_tx_proc(void *arg, int npending)</a>
<a name="ln3428">{</a>
<a name="ln3429">	struct mwl_softc *sc = arg;</a>
<a name="ln3430">	int nreaped;</a>
<a name="ln3431"> </a>
<a name="ln3432">	/*</a>
<a name="ln3433">	 * Process each active queue.</a>
<a name="ln3434">	 */</a>
<a name="ln3435">	nreaped = 0;</a>
<a name="ln3436">	if (!STAILQ_EMPTY(&amp;sc-&gt;sc_txq[0].active))</a>
<a name="ln3437">		nreaped += mwl_tx_processq(sc, &amp;sc-&gt;sc_txq[0]);</a>
<a name="ln3438">	if (!STAILQ_EMPTY(&amp;sc-&gt;sc_txq[1].active))</a>
<a name="ln3439">		nreaped += mwl_tx_processq(sc, &amp;sc-&gt;sc_txq[1]);</a>
<a name="ln3440">	if (!STAILQ_EMPTY(&amp;sc-&gt;sc_txq[2].active))</a>
<a name="ln3441">		nreaped += mwl_tx_processq(sc, &amp;sc-&gt;sc_txq[2]);</a>
<a name="ln3442">	if (!STAILQ_EMPTY(&amp;sc-&gt;sc_txq[3].active))</a>
<a name="ln3443">		nreaped += mwl_tx_processq(sc, &amp;sc-&gt;sc_txq[3]);</a>
<a name="ln3444"> </a>
<a name="ln3445">	if (nreaped != 0) {</a>
<a name="ln3446">		sc-&gt;sc_tx_timer = 0;</a>
<a name="ln3447">		if (mbufq_first(&amp;sc-&gt;sc_snd) != NULL) {</a>
<a name="ln3448">			/* NB: kick fw; the tx thread may have been preempted */</a>
<a name="ln3449">			mwl_hal_txstart(sc-&gt;sc_mh, 0);</a>
<a name="ln3450">			mwl_start(sc);</a>
<a name="ln3451">		}</a>
<a name="ln3452">	}</a>
<a name="ln3453">}</a>
<a name="ln3454"> </a>
<a name="ln3455">static void</a>
<a name="ln3456">mwl_tx_draintxq(struct mwl_softc *sc, struct mwl_txq *txq)</a>
<a name="ln3457">{</a>
<a name="ln3458">	struct ieee80211_node *ni;</a>
<a name="ln3459">	struct mwl_txbuf *bf;</a>
<a name="ln3460">	u_int ix;</a>
<a name="ln3461"> </a>
<a name="ln3462">	/*</a>
<a name="ln3463">	 * NB: this assumes output has been stopped and</a>
<a name="ln3464">	 *     we do not need to block mwl_tx_tasklet</a>
<a name="ln3465">	 */</a>
<a name="ln3466">	for (ix = 0;; ix++) {</a>
<a name="ln3467">		MWL_TXQ_LOCK(txq);</a>
<a name="ln3468">		bf = STAILQ_FIRST(&amp;txq-&gt;active);</a>
<a name="ln3469">		if (bf == NULL) {</a>
<a name="ln3470">			MWL_TXQ_UNLOCK(txq);</a>
<a name="ln3471">			break;</a>
<a name="ln3472">		}</a>
<a name="ln3473">		STAILQ_REMOVE_HEAD(&amp;txq-&gt;active, bf_list);</a>
<a name="ln3474">		MWL_TXQ_UNLOCK(txq);</a>
<a name="ln3475">#ifdef MWL_DEBUG</a>
<a name="ln3476">		if (sc-&gt;sc_debug &amp; MWL_DEBUG_RESET) {</a>
<a name="ln3477">			struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln3478">			const struct mwltxrec *tr =</a>
<a name="ln3479">			    mtod(bf-&gt;bf_m, const struct mwltxrec *);</a>
<a name="ln3480">			mwl_printtxbuf(bf, txq-&gt;qnum, ix);</a>
<a name="ln3481">			ieee80211_dump_pkt(ic, (const uint8_t *)&amp;tr-&gt;wh,</a>
<a name="ln3482">				bf-&gt;bf_m-&gt;m_len - sizeof(tr-&gt;fwlen), 0, -1);</a>
<a name="ln3483">		}</a>
<a name="ln3484">#endif /* MWL_DEBUG */</a>
<a name="ln3485">		bus_dmamap_unload(sc-&gt;sc_dmat, bf-&gt;bf_dmamap);</a>
<a name="ln3486">		ni = bf-&gt;bf_node;</a>
<a name="ln3487">		if (ni != NULL) {</a>
<a name="ln3488">			/*</a>
<a name="ln3489">			 * Reclaim node reference.</a>
<a name="ln3490">			 */</a>
<a name="ln3491">			ieee80211_free_node(ni);</a>
<a name="ln3492">		}</a>
<a name="ln3493">		m_freem(bf-&gt;bf_m);</a>
<a name="ln3494"> </a>
<a name="ln3495">		mwl_puttxbuf_tail(txq, bf);</a>
<a name="ln3496">	}</a>
<a name="ln3497">}</a>
<a name="ln3498"> </a>
<a name="ln3499">/*</a>
<a name="ln3500"> * Drain the transmit queues and reclaim resources.</a>
<a name="ln3501"> */</a>
<a name="ln3502">static void</a>
<a name="ln3503">mwl_draintxq(struct mwl_softc *sc)</a>
<a name="ln3504">{</a>
<a name="ln3505">	int i;</a>
<a name="ln3506"> </a>
<a name="ln3507">	for (i = 0; i &lt; MWL_NUM_TX_QUEUES; i++)</a>
<a name="ln3508">		mwl_tx_draintxq(sc, &amp;sc-&gt;sc_txq[i]);</a>
<a name="ln3509">	sc-&gt;sc_tx_timer = 0;</a>
<a name="ln3510">}</a>
<a name="ln3511"> </a>
<a name="ln3512">#ifdef MWL_DIAGAPI</a>
<a name="ln3513">/*</a>
<a name="ln3514"> * Reset the transmit queues to a pristine state after a fw download.</a>
<a name="ln3515"> */</a>
<a name="ln3516">static void</a>
<a name="ln3517">mwl_resettxq(struct mwl_softc *sc)</a>
<a name="ln3518">{</a>
<a name="ln3519">	int i;</a>
<a name="ln3520"> </a>
<a name="ln3521">	for (i = 0; i &lt; MWL_NUM_TX_QUEUES; i++)</a>
<a name="ln3522">		mwl_txq_reset(sc, &amp;sc-&gt;sc_txq[i]);</a>
<a name="ln3523">}</a>
<a name="ln3524">#endif /* MWL_DIAGAPI */</a>
<a name="ln3525"> </a>
<a name="ln3526">/*</a>
<a name="ln3527"> * Clear the transmit queues of any frames submitted for the</a>
<a name="ln3528"> * specified vap.  This is done when the vap is deleted so we</a>
<a name="ln3529"> * don't potentially reference the vap after it is gone.</a>
<a name="ln3530"> * Note we cannot remove the frames; we only reclaim the node</a>
<a name="ln3531"> * reference.</a>
<a name="ln3532"> */</a>
<a name="ln3533">static void</a>
<a name="ln3534">mwl_cleartxq(struct mwl_softc *sc, struct ieee80211vap *vap)</a>
<a name="ln3535">{</a>
<a name="ln3536">	struct mwl_txq *txq;</a>
<a name="ln3537">	struct mwl_txbuf *bf;</a>
<a name="ln3538">	int i;</a>
<a name="ln3539"> </a>
<a name="ln3540">	for (i = 0; i &lt; MWL_NUM_TX_QUEUES; i++) {</a>
<a name="ln3541">		txq = &amp;sc-&gt;sc_txq[i];</a>
<a name="ln3542">		MWL_TXQ_LOCK(txq);</a>
<a name="ln3543">		STAILQ_FOREACH(bf, &amp;txq-&gt;active, bf_list) {</a>
<a name="ln3544">			struct ieee80211_node *ni = bf-&gt;bf_node;</a>
<a name="ln3545">			if (ni != NULL &amp;&amp; ni-&gt;ni_vap == vap) {</a>
<a name="ln3546">				bf-&gt;bf_node = NULL;</a>
<a name="ln3547">				ieee80211_free_node(ni);</a>
<a name="ln3548">			}</a>
<a name="ln3549">		}</a>
<a name="ln3550">		MWL_TXQ_UNLOCK(txq);</a>
<a name="ln3551">	}</a>
<a name="ln3552">}</a>
<a name="ln3553"> </a>
<a name="ln3554">static int</a>
<a name="ln3555">mwl_recv_action(struct ieee80211_node *ni, const struct ieee80211_frame *wh,</a>
<a name="ln3556">	const uint8_t *frm, const uint8_t *efrm)</a>
<a name="ln3557">{</a>
<a name="ln3558">	struct mwl_softc *sc = ni-&gt;ni_ic-&gt;ic_softc;</a>
<a name="ln3559">	const struct ieee80211_action *ia;</a>
<a name="ln3560"> </a>
<a name="ln3561">	ia = (const struct ieee80211_action *) frm;</a>
<a name="ln3562">	if (ia-&gt;ia_category == IEEE80211_ACTION_CAT_HT &amp;&amp;</a>
<a name="ln3563">	    ia-&gt;ia_action == IEEE80211_ACTION_HT_MIMOPWRSAVE) {</a>
<a name="ln3564">		const struct ieee80211_action_ht_mimopowersave *mps =</a>
<a name="ln3565">		    (const struct ieee80211_action_ht_mimopowersave *) ia;</a>
<a name="ln3566"> </a>
<a name="ln3567">		mwl_hal_setmimops(sc-&gt;sc_mh, ni-&gt;ni_macaddr,</a>
<a name="ln3568">		    mps-&gt;am_control &amp; IEEE80211_A_HT_MIMOPWRSAVE_ENA,</a>
<a name="ln3569">		    MS(mps-&gt;am_control, IEEE80211_A_HT_MIMOPWRSAVE_MODE));</a>
<a name="ln3570">		return 0;</a>
<a name="ln3571">	} else</a>
<a name="ln3572">		return sc-&gt;sc_recv_action(ni, wh, frm, efrm);</a>
<a name="ln3573">}</a>
<a name="ln3574"> </a>
<a name="ln3575">static int</a>
<a name="ln3576">mwl_addba_request(struct ieee80211_node *ni, struct ieee80211_tx_ampdu *tap,</a>
<a name="ln3577">	int dialogtoken, int baparamset, int batimeout)</a>
<a name="ln3578">{</a>
<a name="ln3579">	struct mwl_softc *sc = ni-&gt;ni_ic-&gt;ic_softc;</a>
<a name="ln3580">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln3581">	struct mwl_node *mn = MWL_NODE(ni);</a>
<a name="ln3582">	struct mwl_bastate *bas;</a>
<a name="ln3583"> </a>
<a name="ln3584">	bas = tap-&gt;txa_private;</a>
<a name="ln3585">	if (bas == NULL) {</a>
<a name="ln3586">		const MWL_HAL_BASTREAM *sp;</a>
<a name="ln3587">		/*</a>
<a name="ln3588">		 * Check for a free BA stream slot.</a>
<a name="ln3589">		 */</a>
<a name="ln3590">#if MWL_MAXBA &gt; 3</a>
<a name="ln3591">		if (mn-&gt;mn_ba[3].bastream == NULL)</a>
<a name="ln3592">			bas = &amp;mn-&gt;mn_ba[3];</a>
<a name="ln3593">		else</a>
<a name="ln3594">#endif</a>
<a name="ln3595">#if MWL_MAXBA &gt; 2</a>
<a name="ln3596">		if (mn-&gt;mn_ba[2].bastream == NULL)</a>
<a name="ln3597">			bas = &amp;mn-&gt;mn_ba[2];</a>
<a name="ln3598">		else</a>
<a name="ln3599">#endif</a>
<a name="ln3600">#if MWL_MAXBA &gt; 1</a>
<a name="ln3601">		if (mn-&gt;mn_ba[1].bastream == NULL)</a>
<a name="ln3602">			bas = &amp;mn-&gt;mn_ba[1];</a>
<a name="ln3603">		else</a>
<a name="ln3604">#endif</a>
<a name="ln3605">#if MWL_MAXBA &gt; 0</a>
<a name="ln3606">		if (mn-&gt;mn_ba[0].bastream == NULL)</a>
<a name="ln3607">			bas = &amp;mn-&gt;mn_ba[0];</a>
<a name="ln3608">		else</a>
<a name="ln3609">#endif</a>
<a name="ln3610">		{</a>
<a name="ln3611">			/* sta already has max BA streams */</a>
<a name="ln3612">			/* XXX assign BA stream to highest priority tid */</a>
<a name="ln3613">			DPRINTF(sc, MWL_DEBUG_AMPDU,</a>
<a name="ln3614">			    &quot;%s: already has max bastreams\n&quot;, __func__);</a>
<a name="ln3615">			sc-&gt;sc_stats.mst_ampdu_reject++;</a>
<a name="ln3616">			return 0;</a>
<a name="ln3617">		}</a>
<a name="ln3618">		/* NB: no held reference to ni */</a>
<a name="ln3619">		sp = mwl_hal_bastream_alloc(MWL_VAP(vap)-&gt;mv_hvap,</a>
<a name="ln3620">		    (baparamset &amp; IEEE80211_BAPS_POLICY_IMMEDIATE) != 0,</a>
<a name="ln3621">		    ni-&gt;ni_macaddr, tap-&gt;txa_tid, ni-&gt;ni_htparam,</a>
<a name="ln3622">		    ni, tap);</a>
<a name="ln3623">		if (sp == NULL) {</a>
<a name="ln3624">			/*</a>
<a name="ln3625">			 * No available stream, return 0 so no</a>
<a name="ln3626">			 * a-mpdu aggregation will be done.</a>
<a name="ln3627">			 */</a>
<a name="ln3628">			DPRINTF(sc, MWL_DEBUG_AMPDU,</a>
<a name="ln3629">			    &quot;%s: no bastream available\n&quot;, __func__);</a>
<a name="ln3630">			sc-&gt;sc_stats.mst_ampdu_nostream++;</a>
<a name="ln3631">			return 0;</a>
<a name="ln3632">		}</a>
<a name="ln3633">		DPRINTF(sc, MWL_DEBUG_AMPDU, &quot;%s: alloc bastream %p\n&quot;,</a>
<a name="ln3634">		    __func__, sp);</a>
<a name="ln3635">		/* NB: qos is left zero so we won't match in mwl_tx_start */</a>
<a name="ln3636">		bas-&gt;bastream = sp;</a>
<a name="ln3637">		tap-&gt;txa_private = bas;</a>
<a name="ln3638">	}</a>
<a name="ln3639">	/* fetch current seq# from the firmware; if available */</a>
<a name="ln3640">	if (mwl_hal_bastream_get_seqno(sc-&gt;sc_mh, bas-&gt;bastream,</a>
<a name="ln3641">	    vap-&gt;iv_opmode == IEEE80211_M_STA ? vap-&gt;iv_myaddr : ni-&gt;ni_macaddr,</a>
<a name="ln3642">	    &amp;tap-&gt;txa_start) != 0)</a>
<a name="ln3643">		tap-&gt;txa_start = 0;</a>
<a name="ln3644">	return sc-&gt;sc_addba_request(ni, tap, dialogtoken, baparamset, batimeout);</a>
<a name="ln3645">}</a>
<a name="ln3646"> </a>
<a name="ln3647">static int</a>
<a name="ln3648">mwl_addba_response(struct ieee80211_node *ni, struct ieee80211_tx_ampdu *tap,</a>
<a name="ln3649">	int code, int baparamset, int batimeout)</a>
<a name="ln3650">{</a>
<a name="ln3651">	struct mwl_softc *sc = ni-&gt;ni_ic-&gt;ic_softc;</a>
<a name="ln3652">	struct mwl_bastate *bas;</a>
<a name="ln3653"> </a>
<a name="ln3654">	bas = tap-&gt;txa_private;</a>
<a name="ln3655">	if (bas == NULL) {</a>
<a name="ln3656">		/* XXX should not happen */</a>
<a name="ln3657">		DPRINTF(sc, MWL_DEBUG_AMPDU,</a>
<a name="ln3658">		    &quot;%s: no BA stream allocated, TID %d\n&quot;,</a>
<a name="ln3659">		    __func__, tap-&gt;txa_tid);</a>
<a name="ln3660">		sc-&gt;sc_stats.mst_addba_nostream++;</a>
<a name="ln3661">		return 0;</a>
<a name="ln3662">	}</a>
<a name="ln3663">	if (code == IEEE80211_STATUS_SUCCESS) {</a>
<a name="ln3664">		struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln3665">		int bufsiz, error;</a>
<a name="ln3666"> </a>
<a name="ln3667">		/*</a>
<a name="ln3668">		 * Tell the firmware to setup the BA stream;</a>
<a name="ln3669">		 * we know resources are available because we</a>
<a name="ln3670">		 * pre-allocated one before forming the request.</a>
<a name="ln3671">		 */</a>
<a name="ln3672">		bufsiz = MS(baparamset, IEEE80211_BAPS_BUFSIZ);</a>
<a name="ln3673">		if (bufsiz == 0)</a>
<a name="ln3674">			bufsiz = IEEE80211_AGGR_BAWMAX;</a>
<a name="ln3675">		error = mwl_hal_bastream_create(MWL_VAP(vap)-&gt;mv_hvap,</a>
<a name="ln3676">		    bas-&gt;bastream, bufsiz, bufsiz, tap-&gt;txa_start);</a>
<a name="ln3677">		if (error != 0) {</a>
<a name="ln3678">			/*</a>
<a name="ln3679">			 * Setup failed, return immediately so no a-mpdu</a>
<a name="ln3680">			 * aggregation will be done.</a>
<a name="ln3681">			 */</a>
<a name="ln3682">			mwl_hal_bastream_destroy(sc-&gt;sc_mh, bas-&gt;bastream);</a>
<a name="ln3683">			mwl_bastream_free(bas);</a>
<a name="ln3684">			tap-&gt;txa_private = NULL;</a>
<a name="ln3685"> </a>
<a name="ln3686">			DPRINTF(sc, MWL_DEBUG_AMPDU,</a>
<a name="ln3687">			    &quot;%s: create failed, error %d, bufsiz %d TID %d &quot;</a>
<a name="ln3688">			    &quot;htparam 0x%x\n&quot;, __func__, error, bufsiz,</a>
<a name="ln3689">			    tap-&gt;txa_tid, ni-&gt;ni_htparam);</a>
<a name="ln3690">			sc-&gt;sc_stats.mst_bacreate_failed++;</a>
<a name="ln3691">			return 0;</a>
<a name="ln3692">		}</a>
<a name="ln3693">		/* NB: cache txq to avoid ptr indirect */</a>
<a name="ln3694">		mwl_bastream_setup(bas, tap-&gt;txa_tid, bas-&gt;bastream-&gt;txq);</a>
<a name="ln3695">		DPRINTF(sc, MWL_DEBUG_AMPDU,</a>
<a name="ln3696">		    &quot;%s: bastream %p assigned to txq %d TID %d bufsiz %d &quot;</a>
<a name="ln3697">		    &quot;htparam 0x%x\n&quot;, __func__, bas-&gt;bastream,</a>
<a name="ln3698">		    bas-&gt;txq, tap-&gt;txa_tid, bufsiz, ni-&gt;ni_htparam);</a>
<a name="ln3699">	} else {</a>
<a name="ln3700">		/*</a>
<a name="ln3701">		 * Other side NAK'd us; return the resources.</a>
<a name="ln3702">		 */</a>
<a name="ln3703">		DPRINTF(sc, MWL_DEBUG_AMPDU,</a>
<a name="ln3704">		    &quot;%s: request failed with code %d, destroy bastream %p\n&quot;,</a>
<a name="ln3705">		    __func__, code, bas-&gt;bastream);</a>
<a name="ln3706">		mwl_hal_bastream_destroy(sc-&gt;sc_mh, bas-&gt;bastream);</a>
<a name="ln3707">		mwl_bastream_free(bas);</a>
<a name="ln3708">		tap-&gt;txa_private = NULL;</a>
<a name="ln3709">	}</a>
<a name="ln3710">	/* NB: firmware sends BAR so we don't need to */</a>
<a name="ln3711">	return sc-&gt;sc_addba_response(ni, tap, code, baparamset, batimeout);</a>
<a name="ln3712">}</a>
<a name="ln3713"> </a>
<a name="ln3714">static void</a>
<a name="ln3715">mwl_addba_stop(struct ieee80211_node *ni, struct ieee80211_tx_ampdu *tap)</a>
<a name="ln3716">{</a>
<a name="ln3717">	struct mwl_softc *sc = ni-&gt;ni_ic-&gt;ic_softc;</a>
<a name="ln3718">	struct mwl_bastate *bas;</a>
<a name="ln3719"> </a>
<a name="ln3720">	bas = tap-&gt;txa_private;</a>
<a name="ln3721">	if (bas != NULL) {</a>
<a name="ln3722">		DPRINTF(sc, MWL_DEBUG_AMPDU, &quot;%s: destroy bastream %p\n&quot;,</a>
<a name="ln3723">		    __func__, bas-&gt;bastream);</a>
<a name="ln3724">		mwl_hal_bastream_destroy(sc-&gt;sc_mh, bas-&gt;bastream);</a>
<a name="ln3725">		mwl_bastream_free(bas);</a>
<a name="ln3726">		tap-&gt;txa_private = NULL;</a>
<a name="ln3727">	}</a>
<a name="ln3728">	sc-&gt;sc_addba_stop(ni, tap);</a>
<a name="ln3729">}</a>
<a name="ln3730"> </a>
<a name="ln3731">/*</a>
<a name="ln3732"> * Setup the rx data structures.  This should only be</a>
<a name="ln3733"> * done once or we may get out of sync with the firmware.</a>
<a name="ln3734"> */</a>
<a name="ln3735">static int</a>
<a name="ln3736">mwl_startrecv(struct mwl_softc *sc)</a>
<a name="ln3737">{</a>
<a name="ln3738">	if (!sc-&gt;sc_recvsetup) {</a>
<a name="ln3739">		struct mwl_rxbuf *bf, *prev;</a>
<a name="ln3740">		struct mwl_rxdesc *ds;</a>
<a name="ln3741"> </a>
<a name="ln3742">		prev = NULL;</a>
<a name="ln3743">		STAILQ_FOREACH(bf, &amp;sc-&gt;sc_rxbuf, bf_list) {</a>
<a name="ln3744">			int error = mwl_rxbuf_init(sc, bf);</a>
<a name="ln3745">			if (error != 0) {</a>
<a name="ln3746">				DPRINTF(sc, MWL_DEBUG_RECV,</a>
<a name="ln3747">					&quot;%s: mwl_rxbuf_init failed %d\n&quot;,</a>
<a name="ln3748">					__func__, error);</a>
<a name="ln3749">				return error;</a>
<a name="ln3750">			}</a>
<a name="ln3751">			if (prev != NULL) {</a>
<a name="ln3752">				ds = prev-&gt;bf_desc;</a>
<a name="ln3753">				ds-&gt;pPhysNext = htole32(bf-&gt;bf_daddr);</a>
<a name="ln3754">			}</a>
<a name="ln3755">			prev = bf;</a>
<a name="ln3756">		}</a>
<a name="ln3757">		if (prev != NULL) {</a>
<a name="ln3758">			ds = prev-&gt;bf_desc;</a>
<a name="ln3759">			ds-&gt;pPhysNext =</a>
<a name="ln3760">			    htole32(STAILQ_FIRST(&amp;sc-&gt;sc_rxbuf)-&gt;bf_daddr);</a>
<a name="ln3761">		}</a>
<a name="ln3762">		sc-&gt;sc_recvsetup = 1;</a>
<a name="ln3763">	}</a>
<a name="ln3764">	mwl_mode_init(sc);		/* set filters, etc. */</a>
<a name="ln3765">	return 0;</a>
<a name="ln3766">}</a>
<a name="ln3767"> </a>
<a name="ln3768">static MWL_HAL_APMODE</a>
<a name="ln3769">mwl_getapmode(const struct ieee80211vap *vap, struct ieee80211_channel *chan)</a>
<a name="ln3770">{</a>
<a name="ln3771">	MWL_HAL_APMODE mode;</a>
<a name="ln3772"> </a>
<a name="ln3773">	if (IEEE80211_IS_CHAN_HT(chan)) {</a>
<a name="ln3774">		if (vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_PUREN)</a>
<a name="ln3775">			mode = AP_MODE_N_ONLY;</a>
<a name="ln3776">		else if (IEEE80211_IS_CHAN_5GHZ(chan))</a>
<a name="ln3777">			mode = AP_MODE_AandN;</a>
<a name="ln3778">		else if (vap-&gt;iv_flags &amp; IEEE80211_F_PUREG)</a>
<a name="ln3779">			mode = AP_MODE_GandN;</a>
<a name="ln3780">		else</a>
<a name="ln3781">			mode = AP_MODE_BandGandN;</a>
<a name="ln3782">	} else if (IEEE80211_IS_CHAN_ANYG(chan)) {</a>
<a name="ln3783">		if (vap-&gt;iv_flags &amp; IEEE80211_F_PUREG)</a>
<a name="ln3784">			mode = AP_MODE_G_ONLY;</a>
<a name="ln3785">		else</a>
<a name="ln3786">			mode = AP_MODE_MIXED;</a>
<a name="ln3787">	} else if (IEEE80211_IS_CHAN_B(chan))</a>
<a name="ln3788">		mode = AP_MODE_B_ONLY;</a>
<a name="ln3789">	else if (IEEE80211_IS_CHAN_A(chan))</a>
<a name="ln3790">		mode = AP_MODE_A_ONLY;</a>
<a name="ln3791">	else</a>
<a name="ln3792">		mode = AP_MODE_MIXED;		/* XXX should not happen? */</a>
<a name="ln3793">	return mode;</a>
<a name="ln3794">}</a>
<a name="ln3795"> </a>
<a name="ln3796">static int</a>
<a name="ln3797">mwl_setapmode(struct ieee80211vap *vap, struct ieee80211_channel *chan)</a>
<a name="ln3798">{</a>
<a name="ln3799">	struct mwl_hal_vap *hvap = MWL_VAP(vap)-&gt;mv_hvap;</a>
<a name="ln3800">	return mwl_hal_setapmode(hvap, mwl_getapmode(vap, chan));</a>
<a name="ln3801">}</a>
<a name="ln3802"> </a>
<a name="ln3803">/*</a>
<a name="ln3804"> * Set/change channels.</a>
<a name="ln3805"> */</a>
<a name="ln3806">static int</a>
<a name="ln3807">mwl_chan_set(struct mwl_softc *sc, struct ieee80211_channel *chan)</a>
<a name="ln3808">{</a>
<a name="ln3809">	struct mwl_hal *mh = sc-&gt;sc_mh;</a>
<a name="ln3810">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln3811">	MWL_HAL_CHANNEL hchan;</a>
<a name="ln3812">	int maxtxpow;</a>
<a name="ln3813"> </a>
<a name="ln3814">	DPRINTF(sc, MWL_DEBUG_RESET, &quot;%s: chan %u MHz/flags 0x%x\n&quot;,</a>
<a name="ln3815">	    __func__, chan-&gt;ic_freq, chan-&gt;ic_flags);</a>
<a name="ln3816"> </a>
<a name="ln3817">	/*</a>
<a name="ln3818">	 * Convert to a HAL channel description with</a>
<a name="ln3819">	 * the flags constrained to reflect the current</a>
<a name="ln3820">	 * operating mode.</a>
<a name="ln3821">	 */</a>
<a name="ln3822">	mwl_mapchan(&amp;hchan, chan);</a>
<a name="ln3823">	mwl_hal_intrset(mh, 0);		/* disable interrupts */</a>
<a name="ln3824">#if 0</a>
<a name="ln3825">	mwl_draintxq(sc);		/* clear pending tx frames */</a>
<a name="ln3826">#endif</a>
<a name="ln3827">	mwl_hal_setchannel(mh, &amp;hchan);</a>
<a name="ln3828">	/*</a>
<a name="ln3829">	 * Tx power is cap'd by the regulatory setting and</a>
<a name="ln3830">	 * possibly a user-set limit.  We pass the min of</a>
<a name="ln3831">	 * these to the hal to apply them to the cal data</a>
<a name="ln3832">	 * for this channel.</a>
<a name="ln3833">	 * XXX min bound?</a>
<a name="ln3834">	 */</a>
<a name="ln3835">	maxtxpow = 2*chan-&gt;ic_maxregpower;</a>
<a name="ln3836">	if (maxtxpow &gt; ic-&gt;ic_txpowlimit)</a>
<a name="ln3837">		maxtxpow = ic-&gt;ic_txpowlimit;</a>
<a name="ln3838">	mwl_hal_settxpower(mh, &amp;hchan, maxtxpow / 2);</a>
<a name="ln3839">	/* NB: potentially change mcast/mgt rates */</a>
<a name="ln3840">	mwl_setcurchanrates(sc);</a>
<a name="ln3841"> </a>
<a name="ln3842">	/*</a>
<a name="ln3843">	 * Update internal state.</a>
<a name="ln3844">	 */</a>
<a name="ln3845">	sc-&gt;sc_tx_th.wt_chan_freq = htole16(chan-&gt;ic_freq);</a>
<a name="ln3846">	sc-&gt;sc_rx_th.wr_chan_freq = htole16(chan-&gt;ic_freq);</a>
<a name="ln3847">	if (IEEE80211_IS_CHAN_A(chan)) {</a>
<a name="ln3848">		sc-&gt;sc_tx_th.wt_chan_flags = htole16(IEEE80211_CHAN_A);</a>
<a name="ln3849">		sc-&gt;sc_rx_th.wr_chan_flags = htole16(IEEE80211_CHAN_A);</a>
<a name="ln3850">	} else if (IEEE80211_IS_CHAN_ANYG(chan)) {</a>
<a name="ln3851">		sc-&gt;sc_tx_th.wt_chan_flags = htole16(IEEE80211_CHAN_G);</a>
<a name="ln3852">		sc-&gt;sc_rx_th.wr_chan_flags = htole16(IEEE80211_CHAN_G);</a>
<a name="ln3853">	} else {</a>
<a name="ln3854">		sc-&gt;sc_tx_th.wt_chan_flags = htole16(IEEE80211_CHAN_B);</a>
<a name="ln3855">		sc-&gt;sc_rx_th.wr_chan_flags = htole16(IEEE80211_CHAN_B);</a>
<a name="ln3856">	}</a>
<a name="ln3857">	sc-&gt;sc_curchan = hchan;</a>
<a name="ln3858">	mwl_hal_intrset(mh, sc-&gt;sc_imask);</a>
<a name="ln3859"> </a>
<a name="ln3860">	return 0;</a>
<a name="ln3861">}</a>
<a name="ln3862"> </a>
<a name="ln3863">static void</a>
<a name="ln3864">mwl_scan_start(struct ieee80211com *ic)</a>
<a name="ln3865">{</a>
<a name="ln3866">	struct mwl_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln3867"> </a>
<a name="ln3868">	DPRINTF(sc, MWL_DEBUG_STATE, &quot;%s\n&quot;, __func__);</a>
<a name="ln3869">}</a>
<a name="ln3870"> </a>
<a name="ln3871">static void</a>
<a name="ln3872">mwl_scan_end(struct ieee80211com *ic)</a>
<a name="ln3873">{</a>
<a name="ln3874">	struct mwl_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln3875"> </a>
<a name="ln3876">	DPRINTF(sc, MWL_DEBUG_STATE, &quot;%s\n&quot;, __func__);</a>
<a name="ln3877">}</a>
<a name="ln3878"> </a>
<a name="ln3879">static void</a>
<a name="ln3880">mwl_set_channel(struct ieee80211com *ic)</a>
<a name="ln3881">{</a>
<a name="ln3882">	struct mwl_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln3883"> </a>
<a name="ln3884">	(void) mwl_chan_set(sc, ic-&gt;ic_curchan);</a>
<a name="ln3885">}</a>
<a name="ln3886"> </a>
<a name="ln3887">/*</a>
<a name="ln3888"> * Handle a channel switch request.  We inform the firmware</a>
<a name="ln3889"> * and mark the global state to suppress various actions.</a>
<a name="ln3890"> * NB: we issue only one request to the fw; we may be called</a>
<a name="ln3891"> * multiple times if there are multiple vap's.</a>
<a name="ln3892"> */</a>
<a name="ln3893">static void</a>
<a name="ln3894">mwl_startcsa(struct ieee80211vap *vap)</a>
<a name="ln3895">{</a>
<a name="ln3896">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln3897">	struct mwl_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln3898">	MWL_HAL_CHANNEL hchan;</a>
<a name="ln3899"> </a>
<a name="ln3900">	if (sc-&gt;sc_csapending)</a>
<a name="ln3901">		return;</a>
<a name="ln3902"> </a>
<a name="ln3903">	mwl_mapchan(&amp;hchan, ic-&gt;ic_csa_newchan);</a>
<a name="ln3904">	/* 1 =&gt;'s quiet channel */</a>
<a name="ln3905">	mwl_hal_setchannelswitchie(sc-&gt;sc_mh, &amp;hchan, 1, ic-&gt;ic_csa_count);</a>
<a name="ln3906">	sc-&gt;sc_csapending = 1;</a>
<a name="ln3907">}</a>
<a name="ln3908"> </a>
<a name="ln3909">/*</a>
<a name="ln3910"> * Plumb any static WEP key for the station.  This is</a>
<a name="ln3911"> * necessary as we must propagate the key from the</a>
<a name="ln3912"> * global key table of the vap to each sta db entry.</a>
<a name="ln3913"> */</a>
<a name="ln3914">static void</a>
<a name="ln3915">mwl_setanywepkey(struct ieee80211vap *vap, const uint8_t mac[IEEE80211_ADDR_LEN])</a>
<a name="ln3916">{</a>
<a name="ln3917">	if ((vap-&gt;iv_flags &amp; (IEEE80211_F_PRIVACY|IEEE80211_F_WPA)) ==</a>
<a name="ln3918">		IEEE80211_F_PRIVACY &amp;&amp;</a>
<a name="ln3919">	    vap-&gt;iv_def_txkey != IEEE80211_KEYIX_NONE &amp;&amp;</a>
<a name="ln3920">	    vap-&gt;iv_nw_keys[vap-&gt;iv_def_txkey].wk_keyix != IEEE80211_KEYIX_NONE)</a>
<a name="ln3921">		(void) _mwl_key_set(vap, &amp;vap-&gt;iv_nw_keys[vap-&gt;iv_def_txkey],</a>
<a name="ln3922">				    mac);</a>
<a name="ln3923">}</a>
<a name="ln3924"> </a>
<a name="ln3925">static int</a>
<a name="ln3926">mwl_peerstadb(struct ieee80211_node *ni, int aid, int staid, MWL_HAL_PEERINFO *pi)</a>
<a name="ln3927">{</a>
<a name="ln3928">#define	WME(ie) ((const struct ieee80211_wme_info *) ie)</a>
<a name="ln3929">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln3930">	struct mwl_hal_vap *hvap;</a>
<a name="ln3931">	int error;</a>
<a name="ln3932"> </a>
<a name="ln3933">	if (vap-&gt;iv_opmode == IEEE80211_M_WDS) {</a>
<a name="ln3934">		/*</a>
<a name="ln3935">		 * WDS vap's do not have a f/w vap; instead they piggyback</a>
<a name="ln3936">		 * on an AP vap and we must install the sta db entry and</a>
<a name="ln3937">		 * crypto state using that AP's handle (the WDS vap has none).</a>
<a name="ln3938">		 */</a>
<a name="ln3939">		hvap = MWL_VAP(vap)-&gt;mv_ap_hvap;</a>
<a name="ln3940">	} else</a>
<a name="ln3941">		hvap = MWL_VAP(vap)-&gt;mv_hvap;</a>
<a name="ln3942">	error = mwl_hal_newstation(hvap, ni-&gt;ni_macaddr,</a>
<a name="ln3943">	    aid, staid, pi,</a>
<a name="ln3944">	    ni-&gt;ni_flags &amp; (IEEE80211_NODE_QOS | IEEE80211_NODE_HT),</a>
<a name="ln3945">	    ni-&gt;ni_ies.wme_ie != NULL ? WME(ni-&gt;ni_ies.wme_ie)-&gt;wme_info : 0);</a>
<a name="ln3946">	if (error == 0) {</a>
<a name="ln3947">		/*</a>
<a name="ln3948">		 * Setup security for this station.  For sta mode this is</a>
<a name="ln3949">		 * needed even though do the same thing on transition to</a>
<a name="ln3950">		 * AUTH state because the call to mwl_hal_newstation</a>
<a name="ln3951">		 * clobbers the crypto state we setup.</a>
<a name="ln3952">		 */</a>
<a name="ln3953">		mwl_setanywepkey(vap, ni-&gt;ni_macaddr);</a>
<a name="ln3954">	}</a>
<a name="ln3955">	return error;</a>
<a name="ln3956">#undef WME</a>
<a name="ln3957">}</a>
<a name="ln3958"> </a>
<a name="ln3959">static void</a>
<a name="ln3960">mwl_setglobalkeys(struct ieee80211vap *vap)</a>
<a name="ln3961">{</a>
<a name="ln3962">	struct ieee80211_key *wk;</a>
<a name="ln3963"> </a>
<a name="ln3964">	wk = &amp;vap-&gt;iv_nw_keys[0];</a>
<a name="ln3965">	for (; wk &lt; &amp;vap-&gt;iv_nw_keys[IEEE80211_WEP_NKID]; wk++)</a>
<a name="ln3966">		if (wk-&gt;wk_keyix != IEEE80211_KEYIX_NONE)</a>
<a name="ln3967">			(void) _mwl_key_set(vap, wk, vap-&gt;iv_myaddr);</a>
<a name="ln3968">}</a>
<a name="ln3969"> </a>
<a name="ln3970">/*</a>
<a name="ln3971"> * Convert a legacy rate set to a firmware bitmask.</a>
<a name="ln3972"> */</a>
<a name="ln3973">static uint32_t</a>
<a name="ln3974">get_rate_bitmap(const struct ieee80211_rateset *rs)</a>
<a name="ln3975">{</a>
<a name="ln3976">	uint32_t rates;</a>
<a name="ln3977">	int i;</a>
<a name="ln3978"> </a>
<a name="ln3979">	rates = 0;</a>
<a name="ln3980">	for (i = 0; i &lt; rs-&gt;rs_nrates; i++)</a>
<a name="ln3981">		switch (rs-&gt;rs_rates[i] &amp; IEEE80211_RATE_VAL) {</a>
<a name="ln3982">		case 2:	  rates |= 0x001; break;</a>
<a name="ln3983">		case 4:	  rates |= 0x002; break;</a>
<a name="ln3984">		case 11:  rates |= 0x004; break;</a>
<a name="ln3985">		case 22:  rates |= 0x008; break;</a>
<a name="ln3986">		case 44:  rates |= 0x010; break;</a>
<a name="ln3987">		case 12:  rates |= 0x020; break;</a>
<a name="ln3988">		case 18:  rates |= 0x040; break;</a>
<a name="ln3989">		case 24:  rates |= 0x080; break;</a>
<a name="ln3990">		case 36:  rates |= 0x100; break;</a>
<a name="ln3991">		case 48:  rates |= 0x200; break;</a>
<a name="ln3992">		case 72:  rates |= 0x400; break;</a>
<a name="ln3993">		case 96:  rates |= 0x800; break;</a>
<a name="ln3994">		case 108: rates |= 0x1000; break;</a>
<a name="ln3995">		}</a>
<a name="ln3996">	return rates;</a>
<a name="ln3997">}</a>
<a name="ln3998"> </a>
<a name="ln3999">/*</a>
<a name="ln4000"> * Construct an HT firmware bitmask from an HT rate set.</a>
<a name="ln4001"> */</a>
<a name="ln4002">static uint32_t</a>
<a name="ln4003">get_htrate_bitmap(const struct ieee80211_htrateset *rs)</a>
<a name="ln4004">{</a>
<a name="ln4005">	uint32_t rates;</a>
<a name="ln4006">	int i;</a>
<a name="ln4007"> </a>
<a name="ln4008">	rates = 0;</a>
<a name="ln4009">	for (i = 0; i &lt; rs-&gt;rs_nrates; i++) {</a>
<a name="ln4010">		if (rs-&gt;rs_rates[i] &lt; 16)</a>
<a name="ln4011">			rates |= 1&lt;&lt;rs-&gt;rs_rates[i];</a>
<a name="ln4012">	}</a>
<a name="ln4013">	return rates;</a>
<a name="ln4014">}</a>
<a name="ln4015"> </a>
<a name="ln4016">/*</a>
<a name="ln4017"> * Craft station database entry for station.</a>
<a name="ln4018"> * NB: use host byte order here, the hal handles byte swapping.</a>
<a name="ln4019"> */</a>
<a name="ln4020">static MWL_HAL_PEERINFO *</a>
<a name="ln4021">mkpeerinfo(MWL_HAL_PEERINFO *pi, const struct ieee80211_node *ni)</a>
<a name="ln4022">{</a>
<a name="ln4023">	const struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln4024"> </a>
<a name="ln4025">	memset(pi, 0, sizeof(*pi));</a>
<a name="ln4026">	pi-&gt;LegacyRateBitMap = get_rate_bitmap(&amp;ni-&gt;ni_rates);</a>
<a name="ln4027">	pi-&gt;CapInfo = ni-&gt;ni_capinfo;</a>
<a name="ln4028">	if (ni-&gt;ni_flags &amp; IEEE80211_NODE_HT) {</a>
<a name="ln4029">		/* HT capabilities, etc */</a>
<a name="ln4030">		pi-&gt;HTCapabilitiesInfo = ni-&gt;ni_htcap;</a>
<a name="ln4031">		/* XXX pi.HTCapabilitiesInfo */</a>
<a name="ln4032">	        pi-&gt;MacHTParamInfo = ni-&gt;ni_htparam;</a>
<a name="ln4033">		pi-&gt;HTRateBitMap = get_htrate_bitmap(&amp;ni-&gt;ni_htrates);</a>
<a name="ln4034">		pi-&gt;AddHtInfo.ControlChan = ni-&gt;ni_htctlchan;</a>
<a name="ln4035">		pi-&gt;AddHtInfo.AddChan = ni-&gt;ni_ht2ndchan;</a>
<a name="ln4036">		pi-&gt;AddHtInfo.OpMode = ni-&gt;ni_htopmode;</a>
<a name="ln4037">		pi-&gt;AddHtInfo.stbc = ni-&gt;ni_htstbc;</a>
<a name="ln4038"> </a>
<a name="ln4039">		/* constrain according to local configuration */</a>
<a name="ln4040">		if ((vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_SHORTGI40) == 0)</a>
<a name="ln4041">			pi-&gt;HTCapabilitiesInfo &amp;= ~IEEE80211_HTCAP_SHORTGI40;</a>
<a name="ln4042">		if ((vap-&gt;iv_flags_ht &amp; IEEE80211_FHT_SHORTGI20) == 0)</a>
<a name="ln4043">			pi-&gt;HTCapabilitiesInfo &amp;= ~IEEE80211_HTCAP_SHORTGI20;</a>
<a name="ln4044">		if (ni-&gt;ni_chw != 40)</a>
<a name="ln4045">			pi-&gt;HTCapabilitiesInfo &amp;= ~IEEE80211_HTCAP_CHWIDTH40;</a>
<a name="ln4046">	}</a>
<a name="ln4047">	return pi;</a>
<a name="ln4048">}</a>
<a name="ln4049"> </a>
<a name="ln4050">/*</a>
<a name="ln4051"> * Re-create the local sta db entry for a vap to ensure</a>
<a name="ln4052"> * up to date WME state is pushed to the firmware.  Because</a>
<a name="ln4053"> * this resets crypto state this must be followed by a</a>
<a name="ln4054"> * reload of any keys in the global key table.</a>
<a name="ln4055"> */</a>
<a name="ln4056">static int</a>
<a name="ln4057">mwl_localstadb(struct ieee80211vap *vap)</a>
<a name="ln4058">{</a>
<a name="ln4059">#define	WME(ie) ((const struct ieee80211_wme_info *) ie)</a>
<a name="ln4060">	struct mwl_hal_vap *hvap = MWL_VAP(vap)-&gt;mv_hvap;</a>
<a name="ln4061">	struct ieee80211_node *bss;</a>
<a name="ln4062">	MWL_HAL_PEERINFO pi;</a>
<a name="ln4063">	int error;</a>
<a name="ln4064"> </a>
<a name="ln4065">	switch (vap-&gt;iv_opmode) {</a>
<a name="ln4066">	case IEEE80211_M_STA:</a>
<a name="ln4067">		bss = vap-&gt;iv_bss;</a>
<a name="ln4068">		error = mwl_hal_newstation(hvap, vap-&gt;iv_myaddr, 0, 0,</a>
<a name="ln4069">		    vap-&gt;iv_state == IEEE80211_S_RUN ?</a>
<a name="ln4070">			mkpeerinfo(&amp;pi, bss) : NULL,</a>
<a name="ln4071">		    (bss-&gt;ni_flags &amp; (IEEE80211_NODE_QOS | IEEE80211_NODE_HT)),</a>
<a name="ln4072">		    bss-&gt;ni_ies.wme_ie != NULL ?</a>
<a name="ln4073">			WME(bss-&gt;ni_ies.wme_ie)-&gt;wme_info : 0);</a>
<a name="ln4074">		if (error == 0)</a>
<a name="ln4075">			mwl_setglobalkeys(vap);</a>
<a name="ln4076">		break;</a>
<a name="ln4077">	case IEEE80211_M_HOSTAP:</a>
<a name="ln4078">	case IEEE80211_M_MBSS:</a>
<a name="ln4079">		error = mwl_hal_newstation(hvap, vap-&gt;iv_myaddr,</a>
<a name="ln4080">		    0, 0, NULL, vap-&gt;iv_flags &amp; IEEE80211_F_WME, 0);</a>
<a name="ln4081">		if (error == 0)</a>
<a name="ln4082">			mwl_setglobalkeys(vap);</a>
<a name="ln4083">		break;</a>
<a name="ln4084">	default:</a>
<a name="ln4085">		error = 0;</a>
<a name="ln4086">		break;</a>
<a name="ln4087">	}</a>
<a name="ln4088">	return error;</a>
<a name="ln4089">#undef WME</a>
<a name="ln4090">}</a>
<a name="ln4091"> </a>
<a name="ln4092">static int</a>
<a name="ln4093">mwl_newstate(struct ieee80211vap *vap, enum ieee80211_state nstate, int arg)</a>
<a name="ln4094">{</a>
<a name="ln4095">	struct mwl_vap *mvp = MWL_VAP(vap);</a>
<a name="ln4096">	struct mwl_hal_vap *hvap = mvp-&gt;mv_hvap;</a>
<a name="ln4097">	struct ieee80211com *ic = vap-&gt;iv_ic;</a>
<a name="ln4098">	struct ieee80211_node *ni = NULL;</a>
<a name="ln4099">	struct mwl_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln4100">	struct mwl_hal *mh = sc-&gt;sc_mh;</a>
<a name="ln4101">	enum ieee80211_state ostate = vap-&gt;iv_state;</a>
<a name="ln4102">	int error;</a>
<a name="ln4103"> </a>
<a name="ln4104">	DPRINTF(sc, MWL_DEBUG_STATE, &quot;%s: %s: %s -&gt; %s\n&quot;,</a>
<a name="ln4105">	    vap-&gt;iv_ifp-&gt;if_xname, __func__,</a>
<a name="ln4106">	    ieee80211_state_name[ostate], ieee80211_state_name[nstate]);</a>
<a name="ln4107"> </a>
<a name="ln4108">	callout_stop(&amp;sc-&gt;sc_timer);</a>
<a name="ln4109">	/*</a>
<a name="ln4110">	 * Clear current radar detection state.</a>
<a name="ln4111">	 */</a>
<a name="ln4112">	if (ostate == IEEE80211_S_CAC) {</a>
<a name="ln4113">		/* stop quiet mode radar detection */</a>
<a name="ln4114">		mwl_hal_setradardetection(mh, DR_CHK_CHANNEL_AVAILABLE_STOP);</a>
<a name="ln4115">	} else if (sc-&gt;sc_radarena) {</a>
<a name="ln4116">		/* stop in-service radar detection */</a>
<a name="ln4117">		mwl_hal_setradardetection(mh, DR_DFS_DISABLE);</a>
<a name="ln4118">		sc-&gt;sc_radarena = 0;</a>
<a name="ln4119">	}</a>
<a name="ln4120">	/*</a>
<a name="ln4121">	 * Carry out per-state actions before doing net80211 work.</a>
<a name="ln4122">	 */</a>
<a name="ln4123">	if (nstate == IEEE80211_S_INIT) {</a>
<a name="ln4124">		/* NB: only ap+sta vap's have a fw entity */</a>
<a name="ln4125">		if (hvap != NULL)</a>
<a name="ln4126">			mwl_hal_stop(hvap);</a>
<a name="ln4127">	} else if (nstate == IEEE80211_S_SCAN) {</a>
<a name="ln4128">		mwl_hal_start(hvap);</a>
<a name="ln4129">		/* NB: this disables beacon frames */</a>
<a name="ln4130">		mwl_hal_setinframode(hvap);</a>
<a name="ln4131">	} else if (nstate == IEEE80211_S_AUTH) {</a>
<a name="ln4132">		/*</a>
<a name="ln4133">		 * Must create a sta db entry in case a WEP key needs to</a>
<a name="ln4134">		 * be plumbed.  This entry will be overwritten if we</a>
<a name="ln4135">		 * associate; otherwise it will be reclaimed on node free.</a>
<a name="ln4136">		 */</a>
<a name="ln4137">		ni = vap-&gt;iv_bss;</a>
<a name="ln4138">		MWL_NODE(ni)-&gt;mn_hvap = hvap;</a>
<a name="ln4139">		(void) mwl_peerstadb(ni, 0, 0, NULL);</a>
<a name="ln4140">	} else if (nstate == IEEE80211_S_CSA) {</a>
<a name="ln4141">		/* XXX move to below? */</a>
<a name="ln4142">		if (vap-&gt;iv_opmode == IEEE80211_M_HOSTAP ||</a>
<a name="ln4143">		    vap-&gt;iv_opmode == IEEE80211_M_MBSS)</a>
<a name="ln4144">			mwl_startcsa(vap);</a>
<a name="ln4145">	} else if (nstate == IEEE80211_S_CAC) {</a>
<a name="ln4146">		/* XXX move to below? */</a>
<a name="ln4147">		/* stop ap xmit and enable quiet mode radar detection */</a>
<a name="ln4148">		mwl_hal_setradardetection(mh, DR_CHK_CHANNEL_AVAILABLE_START);</a>
<a name="ln4149">	}</a>
<a name="ln4150"> </a>
<a name="ln4151">	/*</a>
<a name="ln4152">	 * Invoke the parent method to do net80211 work.</a>
<a name="ln4153">	 */</a>
<a name="ln4154">	error = mvp-&gt;mv_newstate(vap, nstate, arg);</a>
<a name="ln4155"> </a>
<a name="ln4156">	/*</a>
<a name="ln4157">	 * Carry out work that must be done after net80211 runs;</a>
<a name="ln4158">	 * this work requires up to date state (e.g. iv_bss).</a>
<a name="ln4159">	 */</a>
<a name="ln4160">	if (error == 0 &amp;&amp; nstate == IEEE80211_S_RUN) {</a>
<a name="ln4161">		/* NB: collect bss node again, it may have changed */</a>
<a name="ln4162">		ni = vap-&gt;iv_bss;</a>
<a name="ln4163"> </a>
<a name="ln4164">		DPRINTF(sc, MWL_DEBUG_STATE,</a>
<a name="ln4165">		    &quot;%s: %s(RUN): iv_flags 0x%08x bintvl %d bssid %s &quot;</a>
<a name="ln4166">		    &quot;capinfo 0x%04x chan %d\n&quot;,</a>
<a name="ln4167">		    vap-&gt;iv_ifp-&gt;if_xname, __func__, vap-&gt;iv_flags,</a>
<a name="ln4168">		    ni-&gt;ni_intval, ether_sprintf(ni-&gt;ni_bssid), ni-&gt;ni_capinfo,</a>
<a name="ln4169">		    ieee80211_chan2ieee(ic, ic-&gt;ic_curchan));</a>
<a name="ln4170"> </a>
<a name="ln4171">		/*</a>
<a name="ln4172">		 * Recreate local sta db entry to update WME/HT state.</a>
<a name="ln4173">		 */</a>
<a name="ln4174">		mwl_localstadb(vap);</a>
<a name="ln4175">		switch (vap-&gt;iv_opmode) {</a>
<a name="ln4176">		case IEEE80211_M_HOSTAP:</a>
<a name="ln4177">		case IEEE80211_M_MBSS:</a>
<a name="ln4178">			if (ostate == IEEE80211_S_CAC) {</a>
<a name="ln4179">				/* enable in-service radar detection */</a>
<a name="ln4180">				mwl_hal_setradardetection(mh,</a>
<a name="ln4181">				    DR_IN_SERVICE_MONITOR_START);</a>
<a name="ln4182">				sc-&gt;sc_radarena = 1;</a>
<a name="ln4183">			}</a>
<a name="ln4184">			/*</a>
<a name="ln4185">			 * Allocate and setup the beacon frame</a>
<a name="ln4186">			 * (and related state).</a>
<a name="ln4187">			 */</a>
<a name="ln4188">			error = mwl_reset_vap(vap, IEEE80211_S_RUN);</a>
<a name="ln4189">			if (error != 0) {</a>
<a name="ln4190">				DPRINTF(sc, MWL_DEBUG_STATE,</a>
<a name="ln4191">				    &quot;%s: beacon setup failed, error %d\n&quot;,</a>
<a name="ln4192">				    __func__, error);</a>
<a name="ln4193">				goto bad;</a>
<a name="ln4194">			}</a>
<a name="ln4195">			/* NB: must be after setting up beacon */</a>
<a name="ln4196">			mwl_hal_start(hvap);</a>
<a name="ln4197">			break;</a>
<a name="ln4198">		case IEEE80211_M_STA:</a>
<a name="ln4199">			DPRINTF(sc, MWL_DEBUG_STATE, &quot;%s: %s: aid 0x%x\n&quot;,</a>
<a name="ln4200">			    vap-&gt;iv_ifp-&gt;if_xname, __func__, ni-&gt;ni_associd);</a>
<a name="ln4201">			/*</a>
<a name="ln4202">			 * Set state now that we're associated.</a>
<a name="ln4203">			 */</a>
<a name="ln4204">			mwl_hal_setassocid(hvap, ni-&gt;ni_bssid, ni-&gt;ni_associd);</a>
<a name="ln4205">			mwl_setrates(vap);</a>
<a name="ln4206">			mwl_hal_setrtsthreshold(hvap, vap-&gt;iv_rtsthreshold);</a>
<a name="ln4207">			if ((vap-&gt;iv_flags &amp; IEEE80211_F_DWDS) &amp;&amp;</a>
<a name="ln4208">			    sc-&gt;sc_ndwdsvaps++ == 0)</a>
<a name="ln4209">				mwl_hal_setdwds(mh, 1);</a>
<a name="ln4210">			break;</a>
<a name="ln4211">		case IEEE80211_M_WDS:</a>
<a name="ln4212">			DPRINTF(sc, MWL_DEBUG_STATE, &quot;%s: %s: bssid %s\n&quot;,</a>
<a name="ln4213">			    vap-&gt;iv_ifp-&gt;if_xname, __func__,</a>
<a name="ln4214">			    ether_sprintf(ni-&gt;ni_bssid));</a>
<a name="ln4215">			mwl_seteapolformat(vap);</a>
<a name="ln4216">			break;</a>
<a name="ln4217">		default:</a>
<a name="ln4218">			break;</a>
<a name="ln4219">		}</a>
<a name="ln4220">		/*</a>
<a name="ln4221">		 * Set CS mode according to operating channel;</a>
<a name="ln4222">		 * this mostly an optimization for 5GHz.</a>
<a name="ln4223">		 *</a>
<a name="ln4224">		 * NB: must follow mwl_hal_start which resets csmode</a>
<a name="ln4225">		 */</a>
<a name="ln4226">		if (IEEE80211_IS_CHAN_5GHZ(ic-&gt;ic_bsschan))</a>
<a name="ln4227">			mwl_hal_setcsmode(mh, CSMODE_AGGRESSIVE);</a>
<a name="ln4228">		else</a>
<a name="ln4229">			mwl_hal_setcsmode(mh, CSMODE_AUTO_ENA);</a>
<a name="ln4230">		/*</a>
<a name="ln4231">		 * Start timer to prod firmware.</a>
<a name="ln4232">		 */</a>
<a name="ln4233">		if (sc-&gt;sc_ageinterval != 0)</a>
<a name="ln4234">			callout_reset(&amp;sc-&gt;sc_timer, sc-&gt;sc_ageinterval*hz,</a>
<a name="ln4235">			    mwl_agestations, sc);</a>
<a name="ln4236">	} else if (nstate == IEEE80211_S_SLEEP) {</a>
<a name="ln4237">		/* XXX set chip in power save */</a>
<a name="ln4238">	} else if ((vap-&gt;iv_flags &amp; IEEE80211_F_DWDS) &amp;&amp;</a>
<a name="ln4239">	    --sc-&gt;sc_ndwdsvaps == 0)</a>
<a name="ln4240">		mwl_hal_setdwds(mh, 0);</a>
<a name="ln4241">bad:</a>
<a name="ln4242">	return error;</a>
<a name="ln4243">}</a>
<a name="ln4244"> </a>
<a name="ln4245">/*</a>
<a name="ln4246"> * Manage station id's; these are separate from AID's</a>
<a name="ln4247"> * as AID's may have values out of the range of possible</a>
<a name="ln4248"> * station id's acceptable to the firmware.</a>
<a name="ln4249"> */</a>
<a name="ln4250">static int</a>
<a name="ln4251">allocstaid(struct mwl_softc *sc, int aid)</a>
<a name="ln4252">{</a>
<a name="ln4253">	int staid;</a>
<a name="ln4254"> </a>
<a name="ln4255">	if (!(0 &lt; aid &amp;&amp; aid &lt; MWL_MAXSTAID) || isset(sc-&gt;sc_staid, aid)) {</a>
<a name="ln4256">		/* NB: don't use 0 */</a>
<a name="ln4257">		for (staid = 1; staid &lt; MWL_MAXSTAID; staid++)</a>
<a name="ln4258">			if (isclr(sc-&gt;sc_staid, staid))</a>
<a name="ln4259">				break;</a>
<a name="ln4260">	} else</a>
<a name="ln4261">		staid = aid;</a>
<a name="ln4262">	setbit(sc-&gt;sc_staid, staid);</a>
<a name="ln4263">	return staid;</a>
<a name="ln4264">}</a>
<a name="ln4265"> </a>
<a name="ln4266">static void</a>
<a name="ln4267">delstaid(struct mwl_softc *sc, int staid)</a>
<a name="ln4268">{</a>
<a name="ln4269">	clrbit(sc-&gt;sc_staid, staid);</a>
<a name="ln4270">}</a>
<a name="ln4271"> </a>
<a name="ln4272">/*</a>
<a name="ln4273"> * Setup driver-specific state for a newly associated node.</a>
<a name="ln4274"> * Note that we're called also on a re-associate, the isnew</a>
<a name="ln4275"> * param tells us if this is the first time or not.</a>
<a name="ln4276"> */</a>
<a name="ln4277">static void</a>
<a name="ln4278">mwl_newassoc(struct ieee80211_node *ni, int isnew)</a>
<a name="ln4279">{</a>
<a name="ln4280">	struct ieee80211vap *vap = ni-&gt;ni_vap;</a>
<a name="ln4281">        struct mwl_softc *sc = vap-&gt;iv_ic-&gt;ic_softc;</a>
<a name="ln4282">	struct mwl_node *mn = MWL_NODE(ni);</a>
<a name="ln4283">	MWL_HAL_PEERINFO pi;</a>
<a name="ln4284">	uint16_t aid;</a>
<a name="ln4285">	int error;</a>
<a name="ln4286"> </a>
<a name="ln4287">	aid = IEEE80211_AID(ni-&gt;ni_associd);</a>
<a name="ln4288">	if (isnew) {</a>
<a name="ln4289">		mn-&gt;mn_staid = allocstaid(sc, aid);</a>
<a name="ln4290">		mn-&gt;mn_hvap = MWL_VAP(vap)-&gt;mv_hvap;</a>
<a name="ln4291">	} else {</a>
<a name="ln4292">		mn = MWL_NODE(ni);</a>
<a name="ln4293">		/* XXX reset BA stream? */</a>
<a name="ln4294">	}</a>
<a name="ln4295">	DPRINTF(sc, MWL_DEBUG_NODE, &quot;%s: mac %s isnew %d aid %d staid %d\n&quot;,</a>
<a name="ln4296">	    __func__, ether_sprintf(ni-&gt;ni_macaddr), isnew, aid, mn-&gt;mn_staid);</a>
<a name="ln4297">	error = mwl_peerstadb(ni, aid, mn-&gt;mn_staid, mkpeerinfo(&amp;pi, ni));</a>
<a name="ln4298">	if (error != 0) {</a>
<a name="ln4299">		DPRINTF(sc, MWL_DEBUG_NODE,</a>
<a name="ln4300">		    &quot;%s: error %d creating sta db entry\n&quot;,</a>
<a name="ln4301">		    __func__, error);</a>
<a name="ln4302">		/* XXX how to deal with error? */</a>
<a name="ln4303">	}</a>
<a name="ln4304">}</a>
<a name="ln4305"> </a>
<a name="ln4306">/*</a>
<a name="ln4307"> * Periodically poke the firmware to age out station state</a>
<a name="ln4308"> * (power save queues, pending tx aggregates).</a>
<a name="ln4309"> */</a>
<a name="ln4310">static void</a>
<a name="ln4311">mwl_agestations(void *arg)</a>
<a name="ln4312">{</a>
<a name="ln4313">	struct mwl_softc *sc = arg;</a>
<a name="ln4314"> </a>
<a name="ln4315">	mwl_hal_setkeepalive(sc-&gt;sc_mh);</a>
<a name="ln4316">	if (sc-&gt;sc_ageinterval != 0)		/* NB: catch dynamic changes */</a>
<a name="ln4317">		callout_schedule(&amp;sc-&gt;sc_timer, sc-&gt;sc_ageinterval*hz);</a>
<a name="ln4318">}</a>
<a name="ln4319"> </a>
<a name="ln4320">static const struct mwl_hal_channel *</a>
<a name="ln4321">findhalchannel(const MWL_HAL_CHANNELINFO *ci, int ieee)</a>
<a name="ln4322">{</a>
<a name="ln4323">	int i;</a>
<a name="ln4324"> </a>
<a name="ln4325">	for (i = 0; i &lt; ci-&gt;nchannels; i++) {</a>
<a name="ln4326">		const struct mwl_hal_channel *hc = &amp;ci-&gt;channels[i];</a>
<a name="ln4327">		if (hc-&gt;ieee == ieee)</a>
<a name="ln4328">			return hc;</a>
<a name="ln4329">	}</a>
<a name="ln4330">	return NULL;</a>
<a name="ln4331">}</a>
<a name="ln4332"> </a>
<a name="ln4333">static int</a>
<a name="ln4334">mwl_setregdomain(struct ieee80211com *ic, struct ieee80211_regdomain *rd,</a>
<a name="ln4335">	int nchan, struct ieee80211_channel chans[])</a>
<a name="ln4336">{</a>
<a name="ln4337">	struct mwl_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln4338">	struct mwl_hal *mh = sc-&gt;sc_mh;</a>
<a name="ln4339">	const MWL_HAL_CHANNELINFO *ci;</a>
<a name="ln4340">	int i;</a>
<a name="ln4341"> </a>
<a name="ln4342">	for (i = 0; i &lt; nchan; i++) {</a>
<a name="ln4343">		struct ieee80211_channel *c = &amp;chans[i];</a>
<a name="ln4344">		const struct mwl_hal_channel *hc;</a>
<a name="ln4345"> </a>
<a name="ln4346">		if (IEEE80211_IS_CHAN_2GHZ(c)) {</a>
<a name="ln4347">			mwl_hal_getchannelinfo(mh, MWL_FREQ_BAND_2DOT4GHZ,</a>
<a name="ln4348">			    IEEE80211_IS_CHAN_HT40(c) ?</a>
<a name="ln4349">				MWL_CH_40_MHz_WIDTH : MWL_CH_20_MHz_WIDTH, &amp;ci);</a>
<a name="ln4350">		} else if (IEEE80211_IS_CHAN_5GHZ(c)) {</a>
<a name="ln4351">			mwl_hal_getchannelinfo(mh, MWL_FREQ_BAND_5GHZ,</a>
<a name="ln4352">			    IEEE80211_IS_CHAN_HT40(c) ?</a>
<a name="ln4353">				MWL_CH_40_MHz_WIDTH : MWL_CH_20_MHz_WIDTH, &amp;ci);</a>
<a name="ln4354">		} else {</a>
<a name="ln4355">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln4356">			    &quot;%s: channel %u freq %u/0x%x not 2.4/5GHz\n&quot;,</a>
<a name="ln4357">			    __func__, c-&gt;ic_ieee, c-&gt;ic_freq, c-&gt;ic_flags);</a>
<a name="ln4358">			return EINVAL;</a>
<a name="ln4359">		}</a>
<a name="ln4360">		/*</a>
<a name="ln4361">		 * Verify channel has cal data and cap tx power.</a>
<a name="ln4362">		 */</a>
<a name="ln4363">		hc = findhalchannel(ci, c-&gt;ic_ieee);</a>
<a name="ln4364">		if (hc != NULL) {</a>
<a name="ln4365">			if (c-&gt;ic_maxpower &gt; 2*hc-&gt;maxTxPow)</a>
<a name="ln4366">				c-&gt;ic_maxpower = 2*hc-&gt;maxTxPow;</a>
<a name="ln4367">			goto next;</a>
<a name="ln4368">		}</a>
<a name="ln4369">		if (IEEE80211_IS_CHAN_HT40(c)) {</a>
<a name="ln4370">			/*</a>
<a name="ln4371">			 * Look for the extension channel since the</a>
<a name="ln4372">			 * hal table only has the primary channel.</a>
<a name="ln4373">			 */</a>
<a name="ln4374">			hc = findhalchannel(ci, c-&gt;ic_extieee);</a>
<a name="ln4375">			if (hc != NULL) {</a>
<a name="ln4376">				if (c-&gt;ic_maxpower &gt; 2*hc-&gt;maxTxPow)</a>
<a name="ln4377">					c-&gt;ic_maxpower = 2*hc-&gt;maxTxPow;</a>
<a name="ln4378">				goto next;</a>
<a name="ln4379">			}</a>
<a name="ln4380">		}</a>
<a name="ln4381">		device_printf(sc-&gt;sc_dev,</a>
<a name="ln4382">		    &quot;%s: no cal data for channel %u ext %u freq %u/0x%x\n&quot;,</a>
<a name="ln4383">		    __func__, c-&gt;ic_ieee, c-&gt;ic_extieee,</a>
<a name="ln4384">		    c-&gt;ic_freq, c-&gt;ic_flags);</a>
<a name="ln4385">		return EINVAL;</a>
<a name="ln4386">	next:</a>
<a name="ln4387">		;</a>
<a name="ln4388">	}</a>
<a name="ln4389">	return 0;</a>
<a name="ln4390">}</a>
<a name="ln4391"> </a>
<a name="ln4392">#define	IEEE80211_CHAN_HTG	(IEEE80211_CHAN_HT|IEEE80211_CHAN_G)</a>
<a name="ln4393">#define	IEEE80211_CHAN_HTA	(IEEE80211_CHAN_HT|IEEE80211_CHAN_A)</a>
<a name="ln4394"> </a>
<a name="ln4395">static void</a>
<a name="ln4396">addht40channels(struct ieee80211_channel chans[], int maxchans, int *nchans,</a>
<a name="ln4397">	const MWL_HAL_CHANNELINFO *ci, int flags)</a>
<a name="ln4398">{</a>
<a name="ln4399">	int i, error;</a>
<a name="ln4400"> </a>
<a name="ln4401">	for (i = 0; i &lt; ci-&gt;nchannels; i++) {</a>
<a name="ln4402">		const struct mwl_hal_channel *hc = &amp;ci-&gt;channels[i];</a>
<a name="ln4403"> </a>
<a name="ln4404">		error = ieee80211_add_channel_ht40(chans, maxchans, nchans,</a>
<a name="ln4405">		    hc-&gt;ieee, hc-&gt;maxTxPow, flags);</a>
<a name="ln4406">		if (error != 0 &amp;&amp; error != ENOENT)</a>
<a name="ln4407">			break;</a>
<a name="ln4408">	}</a>
<a name="ln4409">}</a>
<a name="ln4410"> </a>
<a name="ln4411">static void</a>
<a name="ln4412">addchannels(struct ieee80211_channel chans[], int maxchans, int *nchans,</a>
<a name="ln4413">	const MWL_HAL_CHANNELINFO *ci, const uint8_t bands[])</a>
<a name="ln4414">{</a>
<a name="ln4415">	int i, error;</a>
<a name="ln4416"> </a>
<a name="ln4417">	error = 0;</a>
<a name="ln4418">	for (i = 0; i &lt; ci-&gt;nchannels &amp;&amp; error == 0; i++) {</a>
<a name="ln4419">		const struct mwl_hal_channel *hc = &amp;ci-&gt;channels[i];</a>
<a name="ln4420"> </a>
<a name="ln4421">		error = ieee80211_add_channel(chans, maxchans, nchans,</a>
<a name="ln4422">		    hc-&gt;ieee, hc-&gt;freq, hc-&gt;maxTxPow, 0, bands);</a>
<a name="ln4423">	}</a>
<a name="ln4424">}</a>
<a name="ln4425"> </a>
<a name="ln4426">static void</a>
<a name="ln4427">getchannels(struct mwl_softc *sc, int maxchans, int *nchans,</a>
<a name="ln4428">	struct ieee80211_channel chans[])</a>
<a name="ln4429">{</a>
<a name="ln4430">	const MWL_HAL_CHANNELINFO *ci;</a>
<a name="ln4431">	uint8_t bands[IEEE80211_MODE_BYTES];</a>
<a name="ln4432"> </a>
<a name="ln4433">	/*</a>
<a name="ln4434">	 * Use the channel info from the hal to craft the</a>
<a name="ln4435">	 * channel list.  Note that we pass back an unsorted</a>
<a name="ln4436">	 * list; the caller is required to sort it for us</a>
<a name="ln4437">	 * (if desired).</a>
<a name="ln4438">	 */</a>
<a name="ln4439">	*nchans = 0;</a>
<a name="ln4440">	if (mwl_hal_getchannelinfo(sc-&gt;sc_mh,</a>
<a name="ln4441">	    MWL_FREQ_BAND_2DOT4GHZ, MWL_CH_20_MHz_WIDTH, &amp;ci) == 0) {</a>
<a name="ln4442">		memset(bands, 0, sizeof(bands));</a>
<a name="ln4443">		setbit(bands, IEEE80211_MODE_11B);</a>
<a name="ln4444">		setbit(bands, IEEE80211_MODE_11G);</a>
<a name="ln4445">		setbit(bands, IEEE80211_MODE_11NG);</a>
<a name="ln4446">		addchannels(chans, maxchans, nchans, ci, bands);</a>
<a name="ln4447">	}</a>
<a name="ln4448">	if (mwl_hal_getchannelinfo(sc-&gt;sc_mh,</a>
<a name="ln4449">	    MWL_FREQ_BAND_5GHZ, MWL_CH_20_MHz_WIDTH, &amp;ci) == 0) {</a>
<a name="ln4450">		memset(bands, 0, sizeof(bands));</a>
<a name="ln4451">		setbit(bands, IEEE80211_MODE_11A);</a>
<a name="ln4452">		setbit(bands, IEEE80211_MODE_11NA);</a>
<a name="ln4453">		addchannels(chans, maxchans, nchans, ci, bands);</a>
<a name="ln4454">	}</a>
<a name="ln4455">	if (mwl_hal_getchannelinfo(sc-&gt;sc_mh,</a>
<a name="ln4456">	    MWL_FREQ_BAND_2DOT4GHZ, MWL_CH_40_MHz_WIDTH, &amp;ci) == 0)</a>
<a name="ln4457">		addht40channels(chans, maxchans, nchans, ci, IEEE80211_CHAN_HTG);</a>
<a name="ln4458">	if (mwl_hal_getchannelinfo(sc-&gt;sc_mh,</a>
<a name="ln4459">	    MWL_FREQ_BAND_5GHZ, MWL_CH_40_MHz_WIDTH, &amp;ci) == 0)</a>
<a name="ln4460">		addht40channels(chans, maxchans, nchans, ci, IEEE80211_CHAN_HTA);</a>
<a name="ln4461">}</a>
<a name="ln4462"> </a>
<a name="ln4463">static void</a>
<a name="ln4464">mwl_getradiocaps(struct ieee80211com *ic,</a>
<a name="ln4465">	int maxchans, int *nchans, struct ieee80211_channel chans[])</a>
<a name="ln4466">{</a>
<a name="ln4467">	struct mwl_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln4468"> </a>
<a name="ln4469">	getchannels(sc, maxchans, nchans, chans);</a>
<a name="ln4470">}</a>
<a name="ln4471"> </a>
<a name="ln4472">static int</a>
<a name="ln4473">mwl_getchannels(struct mwl_softc *sc)</a>
<a name="ln4474">{</a>
<a name="ln4475">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln4476"> </a>
<a name="ln4477">	/*</a>
<a name="ln4478">	 * Use the channel info from the hal to craft the</a>
<a name="ln4479">	 * channel list for net80211.  Note that we pass up</a>
<a name="ln4480">	 * an unsorted list; net80211 will sort it for us.</a>
<a name="ln4481">	 */</a>
<a name="ln4482">	memset(ic-&gt;ic_channels, 0, sizeof(ic-&gt;ic_channels));</a>
<a name="ln4483">	ic-&gt;ic_nchans = 0;</a>
<a name="ln4484">	getchannels(sc, IEEE80211_CHAN_MAX, &amp;ic-&gt;ic_nchans, ic-&gt;ic_channels);</a>
<a name="ln4485"> </a>
<a name="ln4486">	ic-&gt;ic_regdomain.regdomain = SKU_DEBUG;</a>
<a name="ln4487">	ic-&gt;ic_regdomain.country = CTRY_DEFAULT;</a>
<a name="ln4488">	ic-&gt;ic_regdomain.location = 'I';</a>
<a name="ln4489">	ic-&gt;ic_regdomain.isocc[0] = ' ';	/* XXX? */</a>
<a name="ln4490">	ic-&gt;ic_regdomain.isocc[1] = ' ';</a>
<a name="ln4491">	return (ic-&gt;ic_nchans == 0 ? EIO : 0);</a>
<a name="ln4492">}</a>
<a name="ln4493">#undef IEEE80211_CHAN_HTA</a>
<a name="ln4494">#undef IEEE80211_CHAN_HTG</a>
<a name="ln4495"> </a>
<a name="ln4496">#ifdef MWL_DEBUG</a>
<a name="ln4497">static void</a>
<a name="ln4498">mwl_printrxbuf(const struct mwl_rxbuf *bf, u_int ix)</a>
<a name="ln4499">{</a>
<a name="ln4500">	const struct mwl_rxdesc *ds = bf-&gt;bf_desc;</a>
<a name="ln4501">	uint32_t status = le32toh(ds-&gt;Status);</a>
<a name="ln4502"> </a>
<a name="ln4503">	printf(&quot;R[%2u] (DS.V:%p DS.P:0x%jx) NEXT:%08x DATA:%08x RC:%02x%s\n&quot;</a>
<a name="ln4504">	       &quot;      STAT:%02x LEN:%04x RSSI:%02x CHAN:%02x RATE:%02x QOS:%04x HT:%04x\n&quot;,</a>
<a name="ln4505">	    ix, ds, (uintmax_t)bf-&gt;bf_daddr, le32toh(ds-&gt;pPhysNext),</a>
<a name="ln4506">	    le32toh(ds-&gt;pPhysBuffData), ds-&gt;RxControl,</a>
<a name="ln4507">	    ds-&gt;RxControl != EAGLE_RXD_CTRL_DRIVER_OWN ?</a>
<a name="ln4508">	        &quot;&quot; : (status &amp; EAGLE_RXD_STATUS_OK) ? &quot; *&quot; : &quot; !&quot;,</a>
<a name="ln4509">	    ds-&gt;Status, le16toh(ds-&gt;PktLen), ds-&gt;RSSI, ds-&gt;Channel,</a>
<a name="ln4510">	    ds-&gt;Rate, le16toh(ds-&gt;QosCtrl), le16toh(ds-&gt;HtSig2));</a>
<a name="ln4511">}</a>
<a name="ln4512"> </a>
<a name="ln4513">static void</a>
<a name="ln4514">mwl_printtxbuf(const struct mwl_txbuf *bf, u_int qnum, u_int ix)</a>
<a name="ln4515">{</a>
<a name="ln4516">	const struct mwl_txdesc *ds = bf-&gt;bf_desc;</a>
<a name="ln4517">	uint32_t status = le32toh(ds-&gt;Status);</a>
<a name="ln4518"> </a>
<a name="ln4519">	printf(&quot;Q%u[%3u]&quot;, qnum, ix);</a>
<a name="ln4520">	printf(&quot; (DS.V:%p DS.P:0x%jx)\n&quot;, ds, (uintmax_t)bf-&gt;bf_daddr);</a>
<a name="ln4521">	printf(&quot;    NEXT:%08x DATA:%08x LEN:%04x STAT:%08x%s\n&quot;,</a>
<a name="ln4522">	    le32toh(ds-&gt;pPhysNext),</a>
<a name="ln4523">	    le32toh(ds-&gt;PktPtr), le16toh(ds-&gt;PktLen), status,</a>
<a name="ln4524">	    status &amp; EAGLE_TXD_STATUS_USED ?</a>
<a name="ln4525">		&quot;&quot; : (status &amp; 3) != 0 ? &quot; *&quot; : &quot; !&quot;);</a>
<a name="ln4526">	printf(&quot;    RATE:%02x PRI:%x QOS:%04x SAP:%08x FORMAT:%04x\n&quot;,</a>
<a name="ln4527">	    ds-&gt;DataRate, ds-&gt;TxPriority, le16toh(ds-&gt;QosCtrl),</a>
<a name="ln4528">	    le32toh(ds-&gt;SapPktInfo), le16toh(ds-&gt;Format));</a>
<a name="ln4529">#if MWL_TXDESC &gt; 1</a>
<a name="ln4530">	printf(&quot;    MULTIFRAMES:%u LEN:%04x %04x %04x %04x %04x %04x\n&quot;</a>
<a name="ln4531">	    , le32toh(ds-&gt;multiframes)</a>
<a name="ln4532">	    , le16toh(ds-&gt;PktLenArray[0]), le16toh(ds-&gt;PktLenArray[1])</a>
<a name="ln4533">	    , le16toh(ds-&gt;PktLenArray[2]), le16toh(ds-&gt;PktLenArray[3])</a>
<a name="ln4534">	    , le16toh(ds-&gt;PktLenArray[4]), le16toh(ds-&gt;PktLenArray[5])</a>
<a name="ln4535">	);</a>
<a name="ln4536">	printf(&quot;    DATA:%08x %08x %08x %08x %08x %08x\n&quot;</a>
<a name="ln4537">	    , le32toh(ds-&gt;PktPtrArray[0]), le32toh(ds-&gt;PktPtrArray[1])</a>
<a name="ln4538">	    , le32toh(ds-&gt;PktPtrArray[2]), le32toh(ds-&gt;PktPtrArray[3])</a>
<a name="ln4539">	    , le32toh(ds-&gt;PktPtrArray[4]), le32toh(ds-&gt;PktPtrArray[5])</a>
<a name="ln4540">	);</a>
<a name="ln4541">#endif</a>
<a name="ln4542">#if 0</a>
<a name="ln4543">{ const uint8_t *cp = (const uint8_t *) ds;</a>
<a name="ln4544">  int i;</a>
<a name="ln4545">  for (i = 0; i &lt; sizeof(struct mwl_txdesc); i++) {</a>
<a name="ln4546">	printf(&quot;%02x &quot;, cp[i]);</a>
<a name="ln4547">	if (((i+1) % 16) == 0)</a>
<a name="ln4548">		printf(&quot;\n&quot;);</a>
<a name="ln4549">  }</a>
<a name="ln4550">  printf(&quot;\n&quot;);</a>
<a name="ln4551">}</a>
<a name="ln4552">#endif</a>
<a name="ln4553">}</a>
<a name="ln4554">#endif /* MWL_DEBUG */</a>
<a name="ln4555"> </a>
<a name="ln4556">#if 0</a>
<a name="ln4557">static void</a>
<a name="ln4558">mwl_txq_dump(struct mwl_txq *txq)</a>
<a name="ln4559">{</a>
<a name="ln4560">	struct mwl_txbuf *bf;</a>
<a name="ln4561">	int i = 0;</a>
<a name="ln4562"> </a>
<a name="ln4563">	MWL_TXQ_LOCK(txq);</a>
<a name="ln4564">	STAILQ_FOREACH(bf, &amp;txq-&gt;active, bf_list) {</a>
<a name="ln4565">		struct mwl_txdesc *ds = bf-&gt;bf_desc;</a>
<a name="ln4566">		MWL_TXDESC_SYNC(txq, ds,</a>
<a name="ln4567">		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);</a>
<a name="ln4568">#ifdef MWL_DEBUG</a>
<a name="ln4569">		mwl_printtxbuf(bf, txq-&gt;qnum, i);</a>
<a name="ln4570">#endif</a>
<a name="ln4571">		i++;</a>
<a name="ln4572">	}</a>
<a name="ln4573">	MWL_TXQ_UNLOCK(txq);</a>
<a name="ln4574">}</a>
<a name="ln4575">#endif</a>
<a name="ln4576"> </a>
<a name="ln4577">static void</a>
<a name="ln4578">mwl_watchdog(void *arg)</a>
<a name="ln4579">{</a>
<a name="ln4580">	struct mwl_softc *sc = arg;</a>
<a name="ln4581"> </a>
<a name="ln4582">	callout_reset(&amp;sc-&gt;sc_watchdog, hz, mwl_watchdog, sc);</a>
<a name="ln4583">	if (sc-&gt;sc_tx_timer == 0 || --sc-&gt;sc_tx_timer &gt; 0)</a>
<a name="ln4584">		return;</a>
<a name="ln4585"> </a>
<a name="ln4586">	if (sc-&gt;sc_running &amp;&amp; !sc-&gt;sc_invalid) {</a>
<a name="ln4587">		if (mwl_hal_setkeepalive(sc-&gt;sc_mh))</a>
<a name="ln4588">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln4589">			    &quot;transmit timeout (firmware hung?)\n&quot;);</a>
<a name="ln4590">		else</a>
<a name="ln4591">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln4592">			    &quot;transmit timeout\n&quot;);</a>
<a name="ln4593">#if 0</a>
<a name="ln4594">		mwl_reset(sc);</a>
<a name="ln4595">mwl_txq_dump(&amp;sc-&gt;sc_txq[0]);/*XXX*/</a>
<a name="ln4596">#endif</a>
<a name="ln4597">		counter_u64_add(sc-&gt;sc_ic.ic_oerrors, 1);</a>
<a name="ln4598">		sc-&gt;sc_stats.mst_watchdog++;</a>
<a name="ln4599">	}</a>
<a name="ln4600">}</a>
<a name="ln4601"> </a>
<a name="ln4602">#ifdef MWL_DIAGAPI</a>
<a name="ln4603">/*</a>
<a name="ln4604"> * Diagnostic interface to the HAL.  This is used by various</a>
<a name="ln4605"> * tools to do things like retrieve register contents for</a>
<a name="ln4606"> * debugging.  The mechanism is intentionally opaque so that</a>
<a name="ln4607"> * it can change frequently w/o concern for compatibility.</a>
<a name="ln4608"> */</a>
<a name="ln4609">static int</a>
<a name="ln4610">mwl_ioctl_diag(struct mwl_softc *sc, struct mwl_diag *md)</a>
<a name="ln4611">{</a>
<a name="ln4612">	struct mwl_hal *mh = sc-&gt;sc_mh;</a>
<a name="ln4613">	u_int id = md-&gt;md_id &amp; MWL_DIAG_ID;</a>
<a name="ln4614">	void *indata = NULL;</a>
<a name="ln4615">	void *outdata = NULL;</a>
<a name="ln4616">	u_int32_t insize = md-&gt;md_in_size;</a>
<a name="ln4617">	u_int32_t outsize = md-&gt;md_out_size;</a>
<a name="ln4618">	int error = 0;</a>
<a name="ln4619"> </a>
<a name="ln4620">	if (md-&gt;md_id &amp; MWL_DIAG_IN) {</a>
<a name="ln4621">		/*</a>
<a name="ln4622">		 * Copy in data.</a>
<a name="ln4623">		 */</a>
<a name="ln4624">		indata = malloc(insize, M_TEMP, M_NOWAIT);</a>
<a name="ln4625">		if (indata == NULL) {</a>
<a name="ln4626">			error = ENOMEM;</a>
<a name="ln4627">			goto bad;</a>
<a name="ln4628">		}</a>
<a name="ln4629">		error = copyin(md-&gt;md_in_data, indata, insize);</a>
<a name="ln4630">		if (error)</a>
<a name="ln4631">			goto bad;</a>
<a name="ln4632">	}</a>
<a name="ln4633">	if (md-&gt;md_id &amp; MWL_DIAG_DYN) {</a>
<a name="ln4634">		/*</a>
<a name="ln4635">		 * Allocate a buffer for the results (otherwise the HAL</a>
<a name="ln4636">		 * returns a pointer to a buffer where we can read the</a>
<a name="ln4637">		 * results).  Note that we depend on the HAL leaving this</a>
<a name="ln4638">		 * pointer for us to use below in reclaiming the buffer;</a>
<a name="ln4639">		 * may want to be more defensive.</a>
<a name="ln4640">		 */</a>
<a name="ln4641">		outdata = malloc(outsize, M_TEMP, M_NOWAIT);</a>
<a name="ln4642">		if (outdata == NULL) {</a>
<a name="ln4643">			error = ENOMEM;</a>
<a name="ln4644">			goto bad;</a>
<a name="ln4645">		}</a>
<a name="ln4646">	}</a>
<a name="ln4647">	if (mwl_hal_getdiagstate(mh, id, indata, insize, &amp;outdata, &amp;outsize)) {</a>
<a name="ln4648">		if (outsize &lt; md-&gt;md_out_size)</a>
<a name="ln4649">			md-&gt;md_out_size = outsize;</a>
<a name="ln4650">		if (outdata != NULL)</a>
<a name="ln4651">			error = copyout(outdata, md-&gt;md_out_data,</a>
<a name="ln4652">					md-&gt;md_out_size);</a>
<a name="ln4653">	} else {</a>
<a name="ln4654">		error = EINVAL;</a>
<a name="ln4655">	}</a>
<a name="ln4656">bad:</a>
<a name="ln4657">	if ((md-&gt;md_id &amp; MWL_DIAG_IN) &amp;&amp; indata != NULL)</a>
<a name="ln4658">		free(indata, M_TEMP);</a>
<a name="ln4659">	if ((md-&gt;md_id &amp; MWL_DIAG_DYN) &amp;&amp; outdata != NULL)</a>
<a name="ln4660">		free(outdata, M_TEMP);</a>
<a name="ln4661">	return error;</a>
<a name="ln4662">}</a>
<a name="ln4663"> </a>
<a name="ln4664">static int</a>
<a name="ln4665">mwl_ioctl_reset(struct mwl_softc *sc, struct mwl_diag *md)</a>
<a name="ln4666">{</a>
<a name="ln4667">	struct mwl_hal *mh = sc-&gt;sc_mh;</a>
<a name="ln4668">	int error;</a>
<a name="ln4669"> </a>
<a name="ln4670">	MWL_LOCK_ASSERT(sc);</a>
<a name="ln4671"> </a>
<a name="ln4672">	if (md-&gt;md_id == 0 &amp;&amp; mwl_hal_fwload(mh, NULL) != 0) {</a>
<a name="ln4673">		device_printf(sc-&gt;sc_dev, &quot;unable to load firmware\n&quot;);</a>
<a name="ln4674">		return EIO;</a>
<a name="ln4675">	}</a>
<a name="ln4676">	if (mwl_hal_gethwspecs(mh, &amp;sc-&gt;sc_hwspecs) != 0) {</a>
<a name="ln4677">		device_printf(sc-&gt;sc_dev, &quot;unable to fetch h/w specs\n&quot;);</a>
<a name="ln4678">		return EIO;</a>
<a name="ln4679">	}</a>
<a name="ln4680">	error = mwl_setupdma(sc);</a>
<a name="ln4681">	if (error != 0) {</a>
<a name="ln4682">		/* NB: mwl_setupdma prints a msg */</a>
<a name="ln4683">		return error;</a>
<a name="ln4684">	}</a>
<a name="ln4685">	/*</a>
<a name="ln4686">	 * Reset tx/rx data structures; after reload we must</a>
<a name="ln4687">	 * re-start the driver's notion of the next xmit/recv.</a>
<a name="ln4688">	 */</a>
<a name="ln4689">	mwl_draintxq(sc);		/* clear pending frames */</a>
<a name="ln4690">	mwl_resettxq(sc);		/* rebuild tx q lists */</a>
<a name="ln4691">	sc-&gt;sc_rxnext = NULL;		/* force rx to start at the list head */</a>
<a name="ln4692">	return 0;</a>
<a name="ln4693">}</a>
<a name="ln4694">#endif /* MWL_DIAGAPI */</a>
<a name="ln4695"> </a>
<a name="ln4696">static void</a>
<a name="ln4697">mwl_parent(struct ieee80211com *ic)</a>
<a name="ln4698">{</a>
<a name="ln4699">	struct mwl_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln4700">	int startall = 0;</a>
<a name="ln4701"> </a>
<a name="ln4702">	MWL_LOCK(sc);</a>
<a name="ln4703">	if (ic-&gt;ic_nrunning &gt; 0) {</a>
<a name="ln4704">		if (sc-&gt;sc_running) {</a>
<a name="ln4705">			/*</a>
<a name="ln4706">			 * To avoid rescanning another access point,</a>
<a name="ln4707">			 * do not call mwl_init() here.  Instead,</a>
<a name="ln4708">			 * only reflect promisc mode settings.</a>
<a name="ln4709">			 */</a>
<a name="ln4710">			mwl_mode_init(sc);</a>
<a name="ln4711">		} else {</a>
<a name="ln4712">			/*</a>
<a name="ln4713">			 * Beware of being called during attach/detach</a>
<a name="ln4714">			 * to reset promiscuous mode.  In that case we</a>
<a name="ln4715">			 * will still be marked UP but not RUNNING.</a>
<a name="ln4716">			 * However trying to re-init the interface</a>
<a name="ln4717">			 * is the wrong thing to do as we've already</a>
<a name="ln4718">			 * torn down much of our state.  There's</a>
<a name="ln4719">			 * probably a better way to deal with this.</a>
<a name="ln4720">			 */</a>
<a name="ln4721">			if (!sc-&gt;sc_invalid) {</a>
<a name="ln4722">				mwl_init(sc);	/* XXX lose error */</a>
<a name="ln4723">				startall = 1;</a>
<a name="ln4724">			}</a>
<a name="ln4725">		}</a>
<a name="ln4726">	} else</a>
<a name="ln4727">		mwl_stop(sc);</a>
<a name="ln4728">	MWL_UNLOCK(sc);</a>
<a name="ln4729">	if (startall)</a>
<a name="ln4730">		ieee80211_start_all(ic);</a>
<a name="ln4731">}</a>
<a name="ln4732"> </a>
<a name="ln4733">static int</a>
<a name="ln4734">mwl_ioctl(struct ieee80211com *ic, u_long cmd, void *data)</a>
<a name="ln4735">{</a>
<a name="ln4736">	struct mwl_softc *sc = ic-&gt;ic_softc;</a>
<a name="ln4737">	struct ifreq *ifr = data;</a>
<a name="ln4738">	int error = 0;</a>
<a name="ln4739"> </a>
<a name="ln4740">	switch (cmd) {</a>
<a name="ln4741">	case SIOCGMVSTATS:</a>
<a name="ln4742">		mwl_hal_gethwstats(sc-&gt;sc_mh, &amp;sc-&gt;sc_stats.hw_stats);</a>
<a name="ln4743">#if 0</a>
<a name="ln4744">		/* NB: embed these numbers to get a consistent view */</a>
<a name="ln4745">		sc-&gt;sc_stats.mst_tx_packets =</a>
<a name="ln4746">		    ifp-&gt;if_get_counter(ifp, IFCOUNTER_OPACKETS);</a>
<a name="ln4747">		sc-&gt;sc_stats.mst_rx_packets =</a>
<a name="ln4748">		    ifp-&gt;if_get_counter(ifp, IFCOUNTER_IPACKETS);</a>
<a name="ln4749">#endif</a>
<a name="ln4750">		/*</a>
<a name="ln4751">		 * NB: Drop the softc lock in case of a page fault;</a>
<a name="ln4752">		 * we'll accept any potential inconsisentcy in the</a>
<a name="ln4753">		 * statistics.  The alternative is to copy the data</a>
<a name="ln4754">		 * to a local structure.</a>
<a name="ln4755">		 */</a>
<a name="ln4756">		return (copyout(&amp;sc-&gt;sc_stats, ifr_data_get_ptr(ifr),</a>
<a name="ln4757">		    sizeof (sc-&gt;sc_stats)));</a>
<a name="ln4758">#ifdef MWL_DIAGAPI</a>
<a name="ln4759">	case SIOCGMVDIAG:</a>
<a name="ln4760">		/* XXX check privs */</a>
<a name="ln4761">		return mwl_ioctl_diag(sc, (struct mwl_diag *) ifr);</a>
<a name="ln4762">	case SIOCGMVRESET:</a>
<a name="ln4763">		/* XXX check privs */</a>
<a name="ln4764">		MWL_LOCK(sc);</a>
<a name="ln4765">		error = mwl_ioctl_reset(sc,(struct mwl_diag *) ifr);</a>
<a name="ln4766">		MWL_UNLOCK(sc);</a>
<a name="ln4767">		break;</a>
<a name="ln4768">#endif /* MWL_DIAGAPI */</a>
<a name="ln4769">	default:</a>
<a name="ln4770">		error = ENOTTY;</a>
<a name="ln4771">		break;</a>
<a name="ln4772">	}</a>
<a name="ln4773">	return (error);</a>
<a name="ln4774">}</a>
<a name="ln4775"> </a>
<a name="ln4776">#ifdef	MWL_DEBUG</a>
<a name="ln4777">static int</a>
<a name="ln4778">mwl_sysctl_debug(SYSCTL_HANDLER_ARGS)</a>
<a name="ln4779">{</a>
<a name="ln4780">	struct mwl_softc *sc = arg1;</a>
<a name="ln4781">	int debug, error;</a>
<a name="ln4782"> </a>
<a name="ln4783">	debug = sc-&gt;sc_debug | (mwl_hal_getdebug(sc-&gt;sc_mh) &lt;&lt; 24);</a>
<a name="ln4784">	error = sysctl_handle_int(oidp, &amp;debug, 0, req);</a>
<a name="ln4785">	if (error || !req-&gt;newptr)</a>
<a name="ln4786">		return error;</a>
<a name="ln4787">	mwl_hal_setdebug(sc-&gt;sc_mh, debug &gt;&gt; 24);</a>
<a name="ln4788">	sc-&gt;sc_debug = debug &amp; 0x00ffffff;</a>
<a name="ln4789">	return 0;</a>
<a name="ln4790">}</a>
<a name="ln4791">#endif /* MWL_DEBUG */</a>
<a name="ln4792"> </a>
<a name="ln4793">static void</a>
<a name="ln4794">mwl_sysctlattach(struct mwl_softc *sc)</a>
<a name="ln4795">{</a>
<a name="ln4796">#ifdef	MWL_DEBUG</a>
<a name="ln4797">	struct sysctl_ctx_list *ctx = device_get_sysctl_ctx(sc-&gt;sc_dev);</a>
<a name="ln4798">	struct sysctl_oid *tree = device_get_sysctl_tree(sc-&gt;sc_dev);</a>
<a name="ln4799"> </a>
<a name="ln4800">	sc-&gt;sc_debug = mwl_debug;</a>
<a name="ln4801">	SYSCTL_ADD_PROC(ctx, SYSCTL_CHILDREN(tree), OID_AUTO,</a>
<a name="ln4802">		&quot;debug&quot;, CTLTYPE_INT | CTLFLAG_RW, sc, 0,</a>
<a name="ln4803">		mwl_sysctl_debug, &quot;I&quot;, &quot;control debugging printfs&quot;);</a>
<a name="ln4804">#endif</a>
<a name="ln4805">}</a>
<a name="ln4806"> </a>
<a name="ln4807">/*</a>
<a name="ln4808"> * Announce various information on device/driver attach.</a>
<a name="ln4809"> */</a>
<a name="ln4810">static void</a>
<a name="ln4811">mwl_announce(struct mwl_softc *sc)</a>
<a name="ln4812">{</a>
<a name="ln4813"> </a>
<a name="ln4814">	device_printf(sc-&gt;sc_dev, &quot;Rev A%d hardware, v%d.%d.%d.%d firmware (regioncode %d)\n&quot;,</a>
<a name="ln4815">		sc-&gt;sc_hwspecs.hwVersion,</a>
<a name="ln4816">		(sc-&gt;sc_hwspecs.fwReleaseNumber&gt;&gt;24) &amp; 0xff,</a>
<a name="ln4817">		(sc-&gt;sc_hwspecs.fwReleaseNumber&gt;&gt;16) &amp; 0xff,</a>
<a name="ln4818">		(sc-&gt;sc_hwspecs.fwReleaseNumber&gt;&gt;8) &amp; 0xff,</a>
<a name="ln4819">		(sc-&gt;sc_hwspecs.fwReleaseNumber&gt;&gt;0) &amp; 0xff,</a>
<a name="ln4820">		sc-&gt;sc_hwspecs.regionCode);</a>
<a name="ln4821">	sc-&gt;sc_fwrelease = sc-&gt;sc_hwspecs.fwReleaseNumber;</a>
<a name="ln4822"> </a>
<a name="ln4823">	if (bootverbose) {</a>
<a name="ln4824">		int i;</a>
<a name="ln4825">		for (i = 0; i &lt;= WME_AC_VO; i++) {</a>
<a name="ln4826">			struct mwl_txq *txq = sc-&gt;sc_ac2q[i];</a>
<a name="ln4827">			device_printf(sc-&gt;sc_dev, &quot;Use hw queue %u for %s traffic\n&quot;,</a>
<a name="ln4828">				txq-&gt;qnum, ieee80211_wme_acnames[i]);</a>
<a name="ln4829">		}</a>
<a name="ln4830">	}</a>
<a name="ln4831">	if (bootverbose || mwl_rxdesc != MWL_RXDESC)</a>
<a name="ln4832">		device_printf(sc-&gt;sc_dev, &quot;using %u rx descriptors\n&quot;, mwl_rxdesc);</a>
<a name="ln4833">	if (bootverbose || mwl_rxbuf != MWL_RXBUF)</a>
<a name="ln4834">		device_printf(sc-&gt;sc_dev, &quot;using %u rx buffers\n&quot;, mwl_rxbuf);</a>
<a name="ln4835">	if (bootverbose || mwl_txbuf != MWL_TXBUF)</a>
<a name="ln4836">		device_printf(sc-&gt;sc_dev, &quot;using %u tx buffers\n&quot;, mwl_txbuf);</a>
<a name="ln4837">	if (bootverbose &amp;&amp; mwl_hal_ismbsscapable(sc-&gt;sc_mh))</a>
<a name="ln4838">		device_printf(sc-&gt;sc_dev, &quot;multi-bss support\n&quot;);</a>
<a name="ln4839">#ifdef MWL_TX_NODROP</a>
<a name="ln4840">	if (bootverbose)</a>
<a name="ln4841">		device_printf(sc-&gt;sc_dev, &quot;no tx drop\n&quot;);</a>
<a name="ln4842">#endif</a>
<a name="ln4843">}</a>

</code></pre>
<div class="balloon" rel="2444"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v610/" target="_blank">V610</a> Unspecified behavior. Check the shift operator '>>'. The left operand is negative ('....' = [-119..119]).</p></div>
<div class="balloon" rel="2443"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v610/" target="_blank">V610</a> Unspecified behavior. Check the shift operator '>>'. The left operand is negative ('....' = [-119..119]).</p></div>
<div class="balloon" rel="2442"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v610/" target="_blank">V610</a> Unspecified behavior. Check the shift operator '>>'. The left operand is negative ('....' = [-119..119]).</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
