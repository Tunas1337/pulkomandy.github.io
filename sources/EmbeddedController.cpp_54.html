
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>EmbeddedController.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2013, Jérôme Duval, korli@users.berlios.de.</a>
<a name="ln3"> * Copyright (c) 2009 Clemens Zeidler</a>
<a name="ln4"> * Copyright (c) 2003-2007 Nate Lawson</a>
<a name="ln5"> * Copyright (c) 2000 Michael Smith</a>
<a name="ln6"> * Copyright (c) 2000 BSDi</a>
<a name="ln7"> * All rights reserved.</a>
<a name="ln8"> *</a>
<a name="ln9"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln10"> * modification, are permitted provided that the following conditions</a>
<a name="ln11"> * are met:</a>
<a name="ln12"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln13"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln14"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln15"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln16"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln17"> *</a>
<a name="ln18"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln19"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln20"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln21"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</a>
<a name="ln22"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln23"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln24"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln25"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln26"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln27"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln28"> * SUCH DAMAGE.</a>
<a name="ln29"> */</a>
<a name="ln30"> </a>
<a name="ln31"> </a>
<a name="ln32">#include &quot;EmbeddedController.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#include &lt;kernel.h&gt;</a>
<a name="ln35">#include &lt;stdio.h&gt;</a>
<a name="ln36">#include &lt;stdlib.h&gt;</a>
<a name="ln37">#include &lt;string.h&gt;</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;condition_variable.h&gt;</a>
<a name="ln40">#include &lt;Errors.h&gt;</a>
<a name="ln41">#include &lt;KernelExport.h&gt;</a>
<a name="ln42">#include &lt;drivers/PCI.h&gt;</a>
<a name="ln43"> </a>
<a name="ln44"> </a>
<a name="ln45">#define ACPI_EC_DRIVER_NAME &quot;drivers/power/acpi_embedded_controller/driver_v1&quot;</a>
<a name="ln46"> </a>
<a name="ln47">#define ACPI_EC_DEVICE_NAME &quot;drivers/power/acpi_embedded_controller/device_v1&quot;</a>
<a name="ln48"> </a>
<a name="ln49">/* Base Namespace devices are published to */</a>
<a name="ln50">#define ACPI_EC_BASENAME &quot;power/embedded_controller/%d&quot;</a>
<a name="ln51"> </a>
<a name="ln52">// name of pnp generator of path ids</a>
<a name="ln53">#define ACPI_EC_PATHID_GENERATOR &quot;embedded_controller/path_id&quot;</a>
<a name="ln54"> </a>
<a name="ln55"> </a>
<a name="ln56">uint8</a>
<a name="ln57">bus_space_read_1(int address)</a>
<a name="ln58">{</a>
<a name="ln59">	return gPCIManager-&gt;read_io_8(address);</a>
<a name="ln60">}</a>
<a name="ln61"> </a>
<a name="ln62"> </a>
<a name="ln63">void</a>
<a name="ln64">bus_space_write_1(int address, uint8 value)</a>
<a name="ln65">{</a>
<a name="ln66">	gPCIManager-&gt;write_io_8(address, value);</a>
<a name="ln67">}</a>
<a name="ln68"> </a>
<a name="ln69"> </a>
<a name="ln70">status_t</a>
<a name="ln71">acpi_GetInteger(acpi_device_module_info* acpi, acpi_device&amp; acpiCookie,</a>
<a name="ln72">	const char* path, int* number)</a>
<a name="ln73">{</a>
<a name="ln74">	acpi_data buf;</a>
<a name="ln75">	acpi_object_type object;</a>
<a name="ln76">	buf.pointer = &amp;object;</a>
<a name="ln77">	buf.length = sizeof(acpi_object_type);</a>
<a name="ln78"> </a>
<a name="ln79">	// Assume that what we've been pointed at is an Integer object, or</a>
<a name="ln80">	// a method that will return an Integer.</a>
<a name="ln81">	status_t status = acpi-&gt;evaluate_method(acpiCookie, path, NULL, &amp;buf);</a>
<a name="ln82">	if (status == B_OK) {</a>
<a name="ln83">		if (object.object_type == ACPI_TYPE_INTEGER)</a>
<a name="ln84">			*number = object.integer.integer;</a>
<a name="ln85">		else</a>
<a name="ln86">			status = B_BAD_VALUE;</a>
<a name="ln87">	}</a>
<a name="ln88">	return status;</a>
<a name="ln89">}</a>
<a name="ln90"> </a>
<a name="ln91"> </a>
<a name="ln92">acpi_handle</a>
<a name="ln93">acpi_GetReference(acpi_module_info* acpi, acpi_handle scope,</a>
<a name="ln94">	acpi_object_type* obj)</a>
<a name="ln95">{</a>
<a name="ln96">	if (obj == NULL)</a>
<a name="ln97">		return NULL;</a>
<a name="ln98"> </a>
<a name="ln99">	switch (obj-&gt;object_type) {</a>
<a name="ln100">		case ACPI_TYPE_LOCAL_REFERENCE:</a>
<a name="ln101">		case ACPI_TYPE_ANY:</a>
<a name="ln102">			return obj-&gt;reference.handle;</a>
<a name="ln103"> </a>
<a name="ln104">		case ACPI_TYPE_STRING:</a>
<a name="ln105">		{</a>
<a name="ln106">			// The String object usually contains a fully-qualified path, so</a>
<a name="ln107">			// scope can be NULL.</a>
<a name="ln108">			// TODO: This may not always be the case.</a>
<a name="ln109">			acpi_handle handle;</a>
<a name="ln110">			if (acpi-&gt;get_handle(scope, obj-&gt;string.string, &amp;handle)</a>
<a name="ln111">					== B_OK)</a>
<a name="ln112">				return handle;</a>
<a name="ln113">		}</a>
<a name="ln114">	}</a>
<a name="ln115"> </a>
<a name="ln116">	return NULL;</a>
<a name="ln117">}</a>
<a name="ln118"> </a>
<a name="ln119"> </a>
<a name="ln120">status_t</a>
<a name="ln121">acpi_PkgInt(acpi_object_type* res, int idx, int* dst)</a>
<a name="ln122">{</a>
<a name="ln123">	acpi_object_type* obj = &amp;res-&gt;package.objects[idx];</a>
<a name="ln124">	if (obj == NULL || obj-&gt;object_type != ACPI_TYPE_INTEGER)</a>
<a name="ln125">		return B_BAD_VALUE;</a>
<a name="ln126">	*dst = obj-&gt;integer.integer;</a>
<a name="ln127"> </a>
<a name="ln128">	return B_OK;</a>
<a name="ln129">}</a>
<a name="ln130"> </a>
<a name="ln131"> </a>
<a name="ln132">status_t</a>
<a name="ln133">acpi_PkgInt32(acpi_object_type* res, int idx, uint32* dst)</a>
<a name="ln134">{</a>
<a name="ln135">	int tmp;</a>
<a name="ln136"> </a>
<a name="ln137">	status_t status = acpi_PkgInt(res, idx, &amp;tmp);</a>
<a name="ln138">	if (status == B_OK)</a>
<a name="ln139">		*dst = (uint32) tmp;</a>
<a name="ln140"> </a>
<a name="ln141">	return status;</a>
<a name="ln142">}</a>
<a name="ln143"> </a>
<a name="ln144"> </a>
<a name="ln145">acpi_status</a>
<a name="ln146">embedded_controller_io_ports_parse_callback(ACPI_RESOURCE* resource,</a>
<a name="ln147">	void* _context)</a>
<a name="ln148">{</a>
<a name="ln149">	acpi_ec_cookie* sc = (acpi_ec_cookie*)_context;</a>
<a name="ln150">	if (resource-&gt;Type != ACPI_RESOURCE_TYPE_IO)</a>
<a name="ln151">		return AE_OK;</a>
<a name="ln152">	if (sc-&gt;ec_data_pci_address == 0) {</a>
<a name="ln153">		sc-&gt;ec_data_pci_address = resource-&gt;Data.Io.Minimum;</a>
<a name="ln154">	} else if (sc-&gt;ec_csr_pci_address == 0) {</a>
<a name="ln155">		sc-&gt;ec_csr_pci_address = resource-&gt;Data.Io.Minimum;</a>
<a name="ln156">	} else {</a>
<a name="ln157">		return AE_CTRL_TERMINATE;</a>
<a name="ln158">	}</a>
<a name="ln159"> </a>
<a name="ln160">	return AE_OK;</a>
<a name="ln161">}</a>
<a name="ln162"> </a>
<a name="ln163"> </a>
<a name="ln164">// #pragma mark -</a>
<a name="ln165"> </a>
<a name="ln166"> </a>
<a name="ln167">static status_t</a>
<a name="ln168">embedded_controller_open(void* initCookie, const char* path, int flags,</a>
<a name="ln169">	void** cookie)</a>
<a name="ln170">{</a>
<a name="ln171">	acpi_ec_cookie* device = (acpi_ec_cookie*) initCookie;</a>
<a name="ln172">	*cookie = device;</a>
<a name="ln173"> </a>
<a name="ln174">	return B_OK;</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177"> </a>
<a name="ln178">static status_t</a>
<a name="ln179">embedded_controller_close(void* cookie)</a>
<a name="ln180">{</a>
<a name="ln181">	return B_OK;</a>
<a name="ln182">}</a>
<a name="ln183"> </a>
<a name="ln184"> </a>
<a name="ln185">static status_t</a>
<a name="ln186">embedded_controller_read(void* _cookie, off_t position, void* buffer,</a>
<a name="ln187">	size_t* numBytes)</a>
<a name="ln188">{</a>
<a name="ln189">	return B_IO_ERROR;</a>
<a name="ln190">}</a>
<a name="ln191"> </a>
<a name="ln192"> </a>
<a name="ln193">static status_t</a>
<a name="ln194">embedded_controller_write(void* cookie, off_t position, const void* buffer,</a>
<a name="ln195">	size_t* numBytes)</a>
<a name="ln196">{</a>
<a name="ln197">	return B_IO_ERROR;</a>
<a name="ln198">}</a>
<a name="ln199"> </a>
<a name="ln200"> </a>
<a name="ln201">status_t</a>
<a name="ln202">embedded_controller_control(void* _cookie, uint32 op, void* arg, size_t len)</a>
<a name="ln203">{</a>
<a name="ln204">	return B_ERROR;</a>
<a name="ln205">}</a>
<a name="ln206"> </a>
<a name="ln207"> </a>
<a name="ln208">static status_t</a>
<a name="ln209">embedded_controller_free(void* cookie)</a>
<a name="ln210">{</a>
<a name="ln211">	return B_OK;</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214"> </a>
<a name="ln215">//	#pragma mark - driver module API</a>
<a name="ln216"> </a>
<a name="ln217"> </a>
<a name="ln218">static int32</a>
<a name="ln219">acpi_get_type(device_node* dev)</a>
<a name="ln220">{</a>
<a name="ln221">	const char *bus;</a>
<a name="ln222">	if (gDeviceManager-&gt;get_attr_string(dev, B_DEVICE_BUS, &amp;bus, false))</a>
<a name="ln223">		return -1;</a>
<a name="ln224"> </a>
<a name="ln225">	if (strcmp(bus, &quot;acpi&quot;))</a>
<a name="ln226">		return -1;</a>
<a name="ln227"> </a>
<a name="ln228">	uint32 deviceType;</a>
<a name="ln229">	if (gDeviceManager-&gt;get_attr_uint32(dev, ACPI_DEVICE_TYPE_ITEM,</a>
<a name="ln230">			&amp;deviceType, false) != B_OK)</a>
<a name="ln231">		return -1;</a>
<a name="ln232"> </a>
<a name="ln233">	return deviceType;</a>
<a name="ln234">}</a>
<a name="ln235"> </a>
<a name="ln236"> </a>
<a name="ln237">static float</a>
<a name="ln238">embedded_controller_support(device_node* dev)</a>
<a name="ln239">{</a>
<a name="ln240">	TRACE(&quot;embedded_controller_support()\n&quot;);</a>
<a name="ln241"> </a>
<a name="ln242">	// Check that this is a device</a>
<a name="ln243">	if (acpi_get_type(dev) != ACPI_TYPE_DEVICE)</a>
<a name="ln244">		return 0.0;</a>
<a name="ln245"> </a>
<a name="ln246">	const char* name;</a>
<a name="ln247">	if (gDeviceManager-&gt;get_attr_string(dev, ACPI_DEVICE_HID_ITEM, &amp;name, false)</a>
<a name="ln248">			!= B_OK)</a>
<a name="ln249">		return 0.0;</a>
<a name="ln250"> </a>
<a name="ln251">	// Test all known IDs</a>
<a name="ln252"> </a>
<a name="ln253">	static const char* kEmbeddedControllerIDs[] = { &quot;PNP0C09&quot; };</a>
<a name="ln254"> </a>
<a name="ln255">	for (size_t i = 0; i &lt; sizeof(kEmbeddedControllerIDs)</a>
<a name="ln256">			/ sizeof(kEmbeddedControllerIDs[0]); i++) {</a>
<a name="ln257">		if (!strcmp(name, kEmbeddedControllerIDs[i])) {</a>
<a name="ln258">			TRACE(&quot;supported device found %s\n&quot;, name);</a>
<a name="ln259">			return 0.6;</a>
<a name="ln260">		}</a>
<a name="ln261">	}</a>
<a name="ln262"> </a>
<a name="ln263">	return 0.0;</a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266"> </a>
<a name="ln267">static status_t</a>
<a name="ln268">embedded_controller_register_device(device_node* node)</a>
<a name="ln269">{</a>
<a name="ln270">	device_attr attrs[] = {</a>
<a name="ln271">		{ B_DEVICE_PRETTY_NAME, B_STRING_TYPE,</a>
<a name="ln272">			{ string: &quot;ACPI embedded controller&quot; }},</a>
<a name="ln273">		{ NULL }</a>
<a name="ln274">	};</a>
<a name="ln275"> </a>
<a name="ln276">	return gDeviceManager-&gt;register_node(node, ACPI_EC_DRIVER_NAME, attrs,</a>
<a name="ln277">		NULL, NULL);</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280"> </a>
<a name="ln281">static status_t</a>
<a name="ln282">embedded_controller_init_driver(device_node* dev, void** _driverCookie)</a>
<a name="ln283">{</a>
<a name="ln284">	TRACE(&quot;init driver\n&quot;);</a>
<a name="ln285"> </a>
<a name="ln286">	acpi_ec_cookie* sc;</a>
<a name="ln287">	sc = (acpi_ec_cookie*)malloc(sizeof(acpi_ec_cookie));</a>
<a name="ln288">	if (sc == NULL)</a>
<a name="ln289">		return B_NO_MEMORY;</a>
<a name="ln290"> </a>
<a name="ln291">	memset(sc, 0, sizeof(acpi_ec_cookie));</a>
<a name="ln292"> </a>
<a name="ln293">	*_driverCookie = sc;</a>
<a name="ln294">	sc-&gt;ec_dev = dev;</a>
<a name="ln295"> </a>
<a name="ln296">	sc-&gt;ec_condition_var.Init(NULL, &quot;ec condition variable&quot;);</a>
<a name="ln297">	mutex_init(&amp;sc-&gt;ec_lock, &quot;ec lock&quot;);</a>
<a name="ln298">	device_node* parent = gDeviceManager-&gt;get_parent_node(dev);</a>
<a name="ln299">	gDeviceManager-&gt;get_driver(parent, (driver_module_info**)&amp;sc-&gt;ec_acpi,</a>
<a name="ln300">		(void**)&amp;sc-&gt;ec_handle);</a>
<a name="ln301">	gDeviceManager-&gt;put_node(parent);</a>
<a name="ln302"> </a>
<a name="ln303">	if (get_module(B_ACPI_MODULE_NAME, (module_info**)&amp;sc-&gt;ec_acpi_module)</a>
<a name="ln304">			!= B_OK)</a>
<a name="ln305">		return B_ERROR;</a>
<a name="ln306"> </a>
<a name="ln307">	acpi_data buf;</a>
<a name="ln308">	buf.pointer = NULL;</a>
<a name="ln309">	buf.length = ACPI_ALLOCATE_BUFFER;</a>
<a name="ln310"> </a>
<a name="ln311">	// Read the unit ID to check for duplicate attach and the</a>
<a name="ln312">	// global lock value to see if we should acquire it when</a>
<a name="ln313">	// accessing the EC.</a>
<a name="ln314">	status_t status = acpi_GetInteger(sc-&gt;ec_acpi, sc-&gt;ec_handle, &quot;_UID&quot;,</a>
<a name="ln315">		&amp;sc-&gt;ec_uid);</a>
<a name="ln316">	if (status != B_OK)</a>
<a name="ln317">		sc-&gt;ec_uid = 0;</a>
<a name="ln318">	status = acpi_GetInteger(sc-&gt;ec_acpi, sc-&gt;ec_handle, &quot;_GLK&quot;, &amp;sc-&gt;ec_glk);</a>
<a name="ln319">	if (status != B_OK)</a>
<a name="ln320">		sc-&gt;ec_glk = 0;</a>
<a name="ln321"> </a>
<a name="ln322">	// Evaluate the _GPE method to find the GPE bit used by the EC to</a>
<a name="ln323">	// signal status (SCI).  If it's a package, it contains a reference</a>
<a name="ln324">	// and GPE bit, similar to _PRW.</a>
<a name="ln325">	status = sc-&gt;ec_acpi-&gt;evaluate_method(sc-&gt;ec_handle, &quot;_GPE&quot;, NULL, &amp;buf);</a>
<a name="ln326">	if (status != B_OK) {</a>
<a name="ln327">		ERROR(&quot;can't evaluate _GPE\n&quot;);</a>
<a name="ln328">		goto error;</a>
<a name="ln329">	}</a>
<a name="ln330"> </a>
<a name="ln331">	acpi_object_type* obj;</a>
<a name="ln332">	obj = (acpi_object_type*)buf.pointer;</a>
<a name="ln333">	if (obj == NULL)</a>
<a name="ln334">		goto error;</a>
<a name="ln335"> </a>
<a name="ln336">	switch (obj-&gt;object_type) {</a>
<a name="ln337">		case ACPI_TYPE_INTEGER:</a>
<a name="ln338">			sc-&gt;ec_gpehandle = NULL;</a>
<a name="ln339">			sc-&gt;ec_gpebit = obj-&gt;integer.integer;</a>
<a name="ln340">			break;</a>
<a name="ln341">		case ACPI_TYPE_PACKAGE:</a>
<a name="ln342">			if (!ACPI_PKG_VALID(obj, 2))</a>
<a name="ln343">				goto error;</a>
<a name="ln344">			sc-&gt;ec_gpehandle = acpi_GetReference(sc-&gt;ec_acpi_module, NULL,</a>
<a name="ln345">				&amp;obj-&gt;package.objects[0]);</a>
<a name="ln346">			if (sc-&gt;ec_gpehandle == NULL</a>
<a name="ln347">				|| acpi_PkgInt32(obj, 1, (uint32*)&amp;sc-&gt;ec_gpebit) != B_OK)</a>
<a name="ln348">				goto error;</a>
<a name="ln349">			break;</a>
<a name="ln350">		default:</a>
<a name="ln351">			ERROR(&quot;_GPE has invalid type %i\n&quot;, int(obj-&gt;object_type));</a>
<a name="ln352">			goto error;</a>
<a name="ln353">	}</a>
<a name="ln354"> </a>
<a name="ln355">	sc-&gt;ec_suspending = FALSE;</a>
<a name="ln356"> </a>
<a name="ln357">	// Attach bus resources for data and command/status ports.</a>
<a name="ln358">	status = sc-&gt;ec_acpi-&gt;walk_resources(sc-&gt;ec_handle, (ACPI_STRING)&quot;_CRS&quot;,</a>
<a name="ln359">		embedded_controller_io_ports_parse_callback, sc);</a>
<a name="ln360">	if (status != B_OK) {</a>
<a name="ln361">		ERROR(&quot;Error while getting IO ports addresses\n&quot;);</a>
<a name="ln362">		goto error;</a>
<a name="ln363">	}</a>
<a name="ln364"> </a>
<a name="ln365">	// Install a handler for this EC's GPE bit.  We want edge-triggered</a>
<a name="ln366">	// behavior.</a>
<a name="ln367">	TRACE(&quot;attaching GPE handler\n&quot;);</a>
<a name="ln368">	status = sc-&gt;ec_acpi_module-&gt;install_gpe_handler(sc-&gt;ec_gpehandle,</a>
<a name="ln369">		sc-&gt;ec_gpebit, ACPI_GPE_EDGE_TRIGGERED, &amp;EcGpeHandler, sc);</a>
<a name="ln370">	if (status != B_OK) {</a>
<a name="ln371">		TRACE(&quot;can't install ec GPE handler\n&quot;);</a>
<a name="ln372">		goto error;</a>
<a name="ln373">	}</a>
<a name="ln374"> </a>
<a name="ln375">	// Install address space handler</a>
<a name="ln376">	TRACE(&quot;attaching address space handler\n&quot;);</a>
<a name="ln377">	status = sc-&gt;ec_acpi-&gt;install_address_space_handler(sc-&gt;ec_handle,</a>
<a name="ln378">		ACPI_ADR_SPACE_EC, &amp;EcSpaceHandler, &amp;EcSpaceSetup, sc);</a>
<a name="ln379">	if (status != B_OK) {</a>
<a name="ln380">		ERROR(&quot;can't install address space handler\n&quot;);</a>
<a name="ln381">		goto error;</a>
<a name="ln382">	}</a>
<a name="ln383"> </a>
<a name="ln384">	// Enable runtime GPEs for the handler.</a>
<a name="ln385">	status = sc-&gt;ec_acpi_module-&gt;enable_gpe(sc-&gt;ec_gpehandle, sc-&gt;ec_gpebit);</a>
<a name="ln386">	if (status != B_OK) {</a>
<a name="ln387">		ERROR(&quot;AcpiEnableGpe failed.\n&quot;);</a>
<a name="ln388">		goto error;</a>
<a name="ln389">	}</a>
<a name="ln390"> </a>
<a name="ln391">	return 0;</a>
<a name="ln392"> </a>
<a name="ln393">error:</a>
<a name="ln394">	free(buf.pointer);</a>
<a name="ln395"> </a>
<a name="ln396">	sc-&gt;ec_acpi_module-&gt;remove_gpe_handler(sc-&gt;ec_gpehandle, sc-&gt;ec_gpebit,</a>
<a name="ln397">		&amp;EcGpeHandler);</a>
<a name="ln398">	sc-&gt;ec_acpi-&gt;remove_address_space_handler(sc-&gt;ec_handle, ACPI_ADR_SPACE_EC,</a>
<a name="ln399">		EcSpaceHandler);</a>
<a name="ln400"> </a>
<a name="ln401">	return ENXIO;</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404"> </a>
<a name="ln405">static void</a>
<a name="ln406">embedded_controller_uninit_driver(void* driverCookie)</a>
<a name="ln407">{</a>
<a name="ln408">	acpi_ec_cookie* sc = (struct acpi_ec_cookie*)driverCookie;</a>
<a name="ln409">	mutex_destroy(&amp;sc-&gt;ec_lock);</a>
<a name="ln410">	free(sc);</a>
<a name="ln411">	put_module(B_ACPI_MODULE_NAME);</a>
<a name="ln412">}</a>
<a name="ln413"> </a>
<a name="ln414"> </a>
<a name="ln415">static status_t</a>
<a name="ln416">embedded_controller_register_child_devices(void* _cookie)</a>
<a name="ln417">{</a>
<a name="ln418">	device_node* node = ((acpi_ec_cookie*)_cookie)-&gt;ec_dev;</a>
<a name="ln419"> </a>
<a name="ln420">	int pathID = gDeviceManager-&gt;create_id(ACPI_EC_PATHID_GENERATOR);</a>
<a name="ln421">	if (pathID &lt; 0) {</a>
<a name="ln422">		TRACE(&quot;register_child_device couldn't create a path_id\n&quot;);</a>
<a name="ln423">		return B_ERROR;</a>
<a name="ln424">	}</a>
<a name="ln425"> </a>
<a name="ln426">	char name[128];</a>
<a name="ln427">	snprintf(name, sizeof(name), ACPI_EC_BASENAME, pathID);</a>
<a name="ln428"> </a>
<a name="ln429">	return gDeviceManager-&gt;publish_device(node, name, ACPI_EC_DEVICE_NAME);</a>
<a name="ln430">}</a>
<a name="ln431"> </a>
<a name="ln432"> </a>
<a name="ln433">static status_t</a>
<a name="ln434">embedded_controller_init_device(void* driverCookie, void** cookie)</a>
<a name="ln435">{</a>
<a name="ln436">	return B_ERROR;</a>
<a name="ln437">}</a>
<a name="ln438"> </a>
<a name="ln439"> </a>
<a name="ln440">static void</a>
<a name="ln441">embedded_controller_uninit_device(void* _cookie)</a>
<a name="ln442">{</a>
<a name="ln443">	acpi_ec_cookie* device = (acpi_ec_cookie*)_cookie;</a>
<a name="ln444">	free(device);</a>
<a name="ln445">}</a>
<a name="ln446"> </a>
<a name="ln447"> </a>
<a name="ln448">driver_module_info embedded_controller_driver_module = {</a>
<a name="ln449">	{</a>
<a name="ln450">		ACPI_EC_DRIVER_NAME,</a>
<a name="ln451">		0,</a>
<a name="ln452">		NULL</a>
<a name="ln453">	},</a>
<a name="ln454"> </a>
<a name="ln455">	embedded_controller_support,</a>
<a name="ln456">	embedded_controller_register_device,</a>
<a name="ln457">	embedded_controller_init_driver,</a>
<a name="ln458">	embedded_controller_uninit_driver,</a>
<a name="ln459">	embedded_controller_register_child_devices,</a>
<a name="ln460">	NULL,	// rescan</a>
<a name="ln461">	NULL,	// removed</a>
<a name="ln462">};</a>
<a name="ln463"> </a>
<a name="ln464"> </a>
<a name="ln465">struct device_module_info embedded_controller_device_module = {</a>
<a name="ln466">	{</a>
<a name="ln467">		ACPI_EC_DEVICE_NAME,</a>
<a name="ln468">		0,</a>
<a name="ln469">		NULL</a>
<a name="ln470">	},</a>
<a name="ln471"> </a>
<a name="ln472">	embedded_controller_init_device,</a>
<a name="ln473">	embedded_controller_uninit_device,</a>
<a name="ln474">	NULL,</a>
<a name="ln475"> </a>
<a name="ln476">	embedded_controller_open,</a>
<a name="ln477">	embedded_controller_close,</a>
<a name="ln478">	embedded_controller_free,</a>
<a name="ln479">	embedded_controller_read,</a>
<a name="ln480">	embedded_controller_write,</a>
<a name="ln481">	NULL,</a>
<a name="ln482">	embedded_controller_control,</a>
<a name="ln483"> </a>
<a name="ln484">	NULL,</a>
<a name="ln485">	NULL</a>
<a name="ln486">};</a>
<a name="ln487"> </a>
<a name="ln488"> </a>
<a name="ln489">// #pragma mark -</a>
<a name="ln490"> </a>
<a name="ln491"> </a>
<a name="ln492">static acpi_status</a>
<a name="ln493">EcCheckStatus(struct acpi_ec_cookie* sc, const char* msg, EC_EVENT event)</a>
<a name="ln494">{</a>
<a name="ln495">	acpi_status status = AE_NO_HARDWARE_RESPONSE;</a>
<a name="ln496">	EC_STATUS ec_status = EC_GET_CSR(sc);</a>
<a name="ln497"> </a>
<a name="ln498">	if (sc-&gt;ec_burstactive &amp;&amp; !(ec_status &amp; EC_FLAG_BURST_MODE)) {</a>
<a name="ln499">		TRACE(&quot;burst disabled in waitevent (%s)\n&quot;, msg);</a>
<a name="ln500">		sc-&gt;ec_burstactive = false;</a>
<a name="ln501">	}</a>
<a name="ln502">	if (EVENT_READY(event, ec_status)) {</a>
<a name="ln503">		TRACE(&quot;%s wait ready, status %#x\n&quot;, msg, ec_status);</a>
<a name="ln504">		status = AE_OK;</a>
<a name="ln505">	}</a>
<a name="ln506">	return status;</a>
<a name="ln507">}</a>
<a name="ln508"> </a>
<a name="ln509"> </a>
<a name="ln510">static void</a>
<a name="ln511">EcGpeQueryHandlerSub(struct acpi_ec_cookie *sc)</a>
<a name="ln512">{</a>
<a name="ln513">	// Serialize user access with EcSpaceHandler().</a>
<a name="ln514">	status_t status = EcLock(sc);</a>
<a name="ln515">	if (status != B_OK) {</a>
<a name="ln516">		TRACE(&quot;GpeQuery lock error.\n&quot;);</a>
<a name="ln517">		return;</a>
<a name="ln518">	}</a>
<a name="ln519"> </a>
<a name="ln520">	// Send a query command to the EC to find out which _Qxx call it</a>
<a name="ln521">	// wants to make.  This command clears the SCI bit and also the</a>
<a name="ln522">	// interrupt source since we are edge-triggered.  To prevent the GPE</a>
<a name="ln523">	// that may arise from running the query from causing another query</a>
<a name="ln524">	// to be queued, we clear the pending flag only after running it.</a>
<a name="ln525">	acpi_status acpi_status = AE_ERROR;</a>
<a name="ln526">	for (uint8 retry = 0; retry &lt; 2; retry++) {</a>
<a name="ln527">		acpi_status = EcCommand(sc, EC_COMMAND_QUERY);</a>
<a name="ln528">		if (acpi_status == AE_OK)</a>
<a name="ln529">			break;</a>
<a name="ln530">		if (EcCheckStatus(sc, &quot;retr_check&quot;,</a>
<a name="ln531">			EC_EVENT_INPUT_BUFFER_EMPTY) != AE_OK)</a>
<a name="ln532">			break;</a>
<a name="ln533">	}</a>
<a name="ln534"> </a>
<a name="ln535">	if (acpi_status != AE_OK) {</a>
<a name="ln536">		EcUnlock(sc);</a>
<a name="ln537">		TRACE(&quot;GPE query failed.\n&quot;);</a>
<a name="ln538">		return;</a>
<a name="ln539">	}</a>
<a name="ln540">	uint8 data = EC_GET_DATA(sc);</a>
<a name="ln541"> </a>
<a name="ln542">	// We have to unlock before running the _Qxx method below since that</a>
<a name="ln543">	// method may attempt to read/write from EC address space, causing</a>
<a name="ln544">	// recursive acquisition of the lock.</a>
<a name="ln545">	EcUnlock(sc);</a>
<a name="ln546"> </a>
<a name="ln547">	// Ignore the value for &quot;no outstanding event&quot;. (13.3.5)</a>
<a name="ln548">	TRACE(&quot;query ok,%s running _Q%02X\n&quot;, data ? &quot;&quot; : &quot; not&quot;, data);</a>
<a name="ln549">	if (data == 0)</a>
<a name="ln550">		return;</a>
<a name="ln551"> </a>
<a name="ln552">	// Evaluate _Qxx to respond to the controller.</a>
<a name="ln553">	char qxx[5];</a>
<a name="ln554">	snprintf(qxx, sizeof(qxx), &quot;_Q%02X&quot;, data);</a>
<a name="ln555">	AcpiUtStrupr(qxx);</a>
<a name="ln556">	status = sc-&gt;ec_acpi-&gt;evaluate_method(sc-&gt;ec_handle, qxx, NULL, NULL);</a>
<a name="ln557">	if (status != B_OK) {</a>
<a name="ln558">		TRACE(&quot;evaluation of query method %s failed\n&quot;, qxx);</a>
<a name="ln559">	}</a>
<a name="ln560">}</a>
<a name="ln561"> </a>
<a name="ln562"> </a>
<a name="ln563">static void</a>
<a name="ln564">EcGpeQueryHandler(void* context)</a>
<a name="ln565">{</a>
<a name="ln566">	struct acpi_ec_cookie* sc = (struct acpi_ec_cookie*)context;</a>
<a name="ln567">	int32 pending;</a>
<a name="ln568"> </a>
<a name="ln569">	ASSERT(context != NULL);</a>
<a name="ln570"> </a>
<a name="ln571">	do {</a>
<a name="ln572">		// Read the current pending count</a>
<a name="ln573">		pending = atomic_get(&amp;sc-&gt;ec_sci_pending);</a>
<a name="ln574"> </a>
<a name="ln575">		// Call GPE handler function</a>
<a name="ln576">		EcGpeQueryHandlerSub(sc);</a>
<a name="ln577"> </a>
<a name="ln578">		// Try to reset the pending count to zero. If this fails we</a>
<a name="ln579">		// know another GPE event has occurred while handling the</a>
<a name="ln580">		// current GPE event and need to loop.</a>
<a name="ln581">	} while (atomic_test_and_set(&amp;sc-&gt;ec_sci_pending, 0, pending));</a>
<a name="ln582">}</a>
<a name="ln583"> </a>
<a name="ln584"> </a>
<a name="ln585">/*!	The GPE handler is called when IBE/OBF or SCI events occur.  We are</a>
<a name="ln586">	called from an unknown lock context.</a>
<a name="ln587">*/</a>
<a name="ln588">static uint32</a>
<a name="ln589">EcGpeHandler(acpi_handle gpeDevice, uint32 gpeNumber, void* context)</a>
<a name="ln590">{</a>
<a name="ln591">	struct acpi_ec_cookie* sc = (acpi_ec_cookie*)context;</a>
<a name="ln592"> </a>
<a name="ln593">	ASSERT(context != NULL);//, (&quot;EcGpeHandler called with NULL&quot;));</a>
<a name="ln594">	TRACE(&quot;gpe handler start\n&quot;);</a>
<a name="ln595"> </a>
<a name="ln596">	// Notify EcWaitEvent() that the status register is now fresh.  If we</a>
<a name="ln597">	// didn't do this, it wouldn't be possible to distinguish an old IBE</a>
<a name="ln598">	// from a new one, for example when doing a write transaction (writing</a>
<a name="ln599">	// address and then data values.)</a>
<a name="ln600">	atomic_add(&amp;sc-&gt;ec_gencount, 1);</a>
<a name="ln601">	sc-&gt;ec_condition_var.NotifyAll();</a>
<a name="ln602"> </a>
<a name="ln603">	// If the EC_SCI bit of the status register is set, queue a query handler.</a>
<a name="ln604">	// It will run the query and _Qxx method later, under the lock.</a>
<a name="ln605">	EC_STATUS ecStatus = EC_GET_CSR(sc);</a>
<a name="ln606">	if ((ecStatus &amp; EC_EVENT_SCI) &amp;&amp; atomic_add(&amp;sc-&gt;ec_sci_pending, 1) == 0) {</a>
<a name="ln607">		TRACE(&quot;gpe queueing query handler\n&quot;);</a>
<a name="ln608">		acpi_status status = AcpiOsExecute(OSL_GPE_HANDLER, EcGpeQueryHandler,</a>
<a name="ln609">			context);</a>
<a name="ln610">		if (status != AE_OK) {</a>
<a name="ln611">			dprintf(&quot;EcGpeHandler: queuing GPE query handler failed\n&quot;);</a>
<a name="ln612">			atomic_add(&amp;sc-&gt;ec_sci_pending, -1);</a>
<a name="ln613">		}</a>
<a name="ln614">	}</a>
<a name="ln615">	return ACPI_REENABLE_GPE;</a>
<a name="ln616">}</a>
<a name="ln617"> </a>
<a name="ln618"> </a>
<a name="ln619">static acpi_status</a>
<a name="ln620">EcSpaceSetup(acpi_handle region, uint32 function, void* context,</a>
<a name="ln621">	void** regionContext)</a>
<a name="ln622">{</a>
<a name="ln623">	// If deactivating a region, always set the output to NULL.  Otherwise,</a>
<a name="ln624">	// just pass the context through.</a>
<a name="ln625">	if (function == ACPI_REGION_DEACTIVATE)</a>
<a name="ln626">		*regionContext = NULL;</a>
<a name="ln627">	else</a>
<a name="ln628">		*regionContext = context;</a>
<a name="ln629"> </a>
<a name="ln630">	return AE_OK;</a>
<a name="ln631">}</a>
<a name="ln632"> </a>
<a name="ln633"> </a>
<a name="ln634">static acpi_status</a>
<a name="ln635">EcSpaceHandler(uint32 function, acpi_physical_address address, uint32 width,</a>
<a name="ln636">	int* value, void* context, void* regionContext)</a>
<a name="ln637">{</a>
<a name="ln638">	TRACE(&quot;enter EcSpaceHandler\n&quot;);</a>
<a name="ln639">	struct acpi_ec_cookie* sc = (struct acpi_ec_cookie*)context;</a>
<a name="ln640"> </a>
<a name="ln641">	if (function != ACPI_READ &amp;&amp; function != ACPI_WRITE)</a>
<a name="ln642">		return AE_BAD_PARAMETER;</a>
<a name="ln643">	if (width % 8 != 0 || value == NULL || context == NULL)</a>
<a name="ln644">		return AE_BAD_PARAMETER;</a>
<a name="ln645">	if (address + width / 8 &gt; 256)</a>
<a name="ln646">		return AE_BAD_ADDRESS;</a>
<a name="ln647"> </a>
<a name="ln648">	// If booting, check if we need to run the query handler.  If so, we</a>
<a name="ln649">	// we call it directly here as scheduling and dpc might not be up yet.</a>
<a name="ln650">	// (Not sure if it's needed)</a>
<a name="ln651"> </a>
<a name="ln652">	if (gKernelStartup || gKernelShutdown || sc-&gt;ec_suspending) {</a>
<a name="ln653">		if ((EC_GET_CSR(sc) &amp; EC_EVENT_SCI) &amp;&amp;</a>
<a name="ln654">			atomic_add(&amp;sc-&gt;ec_sci_pending, 1) == 0) {</a>
<a name="ln655">			//CTR0(KTR_ACPI, &quot;ec running gpe handler directly&quot;);</a>
<a name="ln656">			EcGpeQueryHandler(sc);</a>
<a name="ln657">		}</a>
<a name="ln658">	}</a>
<a name="ln659"> </a>
<a name="ln660">	// Serialize with EcGpeQueryHandler() at transaction granularity.</a>
<a name="ln661">	acpi_status status = EcLock(sc);</a>
<a name="ln662">	if (status != B_OK)</a>
<a name="ln663">		return AE_NOT_ACQUIRED;</a>
<a name="ln664"> </a>
<a name="ln665">	// If we can't start burst mode, continue anyway.</a>
<a name="ln666">	status = EcCommand(sc, EC_COMMAND_BURST_ENABLE);</a>
<a name="ln667">	if (status == B_OK) {</a>
<a name="ln668">		if (EC_GET_DATA(sc) == EC_BURST_ACK) {</a>
<a name="ln669">			TRACE(&quot;burst enabled.\n&quot;);</a>
<a name="ln670">			sc-&gt;ec_burstactive = TRUE;</a>
<a name="ln671">		}</a>
<a name="ln672">	}</a>
<a name="ln673"> </a>
<a name="ln674">	// Perform the transaction(s), based on width.</a>
<a name="ln675">	ACPI_PHYSICAL_ADDRESS ecAddr = address;</a>
<a name="ln676">	uint8* ecData = (uint8 *) value;</a>
<a name="ln677">	if (function == ACPI_READ)</a>
<a name="ln678">		*value = 0;</a>
<a name="ln679">	do {</a>
<a name="ln680">		switch (function) {</a>
<a name="ln681">			case ACPI_READ:</a>
<a name="ln682">				status = EcRead(sc, ecAddr, ecData);</a>
<a name="ln683">				break;</a>
<a name="ln684">			case ACPI_WRITE:</a>
<a name="ln685">				status = EcWrite(sc, ecAddr, *ecData);</a>
<a name="ln686">				break;</a>
<a name="ln687">		}</a>
<a name="ln688">		if (status != AE_OK)</a>
<a name="ln689">			break;</a>
<a name="ln690">		ecAddr++;</a>
<a name="ln691">		ecData++;</a>
<a name="ln692">	} while (ecAddr &lt; address + width / 8);</a>
<a name="ln693"> </a>
<a name="ln694">	if (sc-&gt;ec_burstactive) {</a>
<a name="ln695">		sc-&gt;ec_burstactive = FALSE;</a>
<a name="ln696">		if (EcCommand(sc, EC_COMMAND_BURST_DISABLE) == AE_OK)</a>
<a name="ln697">			TRACE(&quot;disabled burst ok.&quot;);</a>
<a name="ln698">	}</a>
<a name="ln699"> </a>
<a name="ln700">	EcUnlock(sc);</a>
<a name="ln701">	return status;</a>
<a name="ln702">}</a>
<a name="ln703"> </a>
<a name="ln704"> </a>
<a name="ln705">static acpi_status</a>
<a name="ln706">EcWaitEvent(struct acpi_ec_cookie* sc, EC_EVENT event, int32 generationCount)</a>
<a name="ln707">{</a>
<a name="ln708">	static int32 noIntr = 0;</a>
<a name="ln709">	acpi_status status = AE_NO_HARDWARE_RESPONSE;</a>
<a name="ln710">	int32 count, i;</a>
<a name="ln711"> </a>
<a name="ln712">	int needPoll = ec_polled_mode || sc-&gt;ec_suspending</a>
<a name="ln713">		|| gKernelStartup || gKernelShutdown;</a>
<a name="ln714"> </a>
<a name="ln715">	// Wait for event by polling or GPE (interrupt).</a>
<a name="ln716">	if (needPoll) {</a>
<a name="ln717">		count = (ec_timeout * 1000) / EC_POLL_DELAY;</a>
<a name="ln718">		if (count == 0)</a>
<a name="ln719">			count = 1;</a>
<a name="ln720">		spin(10);</a>
<a name="ln721">		for (i = 0; i &lt; count; i++) {</a>
<a name="ln722">			status = EcCheckStatus(sc, &quot;poll&quot;, event);</a>
<a name="ln723">			if (status == AE_OK)</a>
<a name="ln724">				break;</a>
<a name="ln725">			spin(EC_POLL_DELAY);</a>
<a name="ln726">		}</a>
<a name="ln727">	} else {</a>
<a name="ln728">		// Wait for the GPE to signal the status changed, checking the</a>
<a name="ln729">		// status register each time we get one.  It's possible to get a</a>
<a name="ln730">		// GPE for an event we're not interested in here (i.e., SCI for</a>
<a name="ln731">		// EC query).</a>
<a name="ln732">		for (i = 0; i &lt; ec_timeout; i++) {</a>
<a name="ln733">			if (generationCount == sc-&gt;ec_gencount) {</a>
<a name="ln734">				sc-&gt;ec_condition_var.Wait(B_RELATIVE_TIMEOUT, 1000);</a>
<a name="ln735">			}</a>
<a name="ln736">			/*</a>
<a name="ln737">			 * Record new generation count.  It's possible the GPE was</a>
<a name="ln738">			 * just to notify us that a query is needed and we need to</a>
<a name="ln739">			 * wait for a second GPE to signal the completion of the</a>
<a name="ln740">			 * event we are actually waiting for.</a>
<a name="ln741">			 */</a>
<a name="ln742">			status = EcCheckStatus(sc, &quot;sleep&quot;, event);</a>
<a name="ln743">			if (status == AE_OK) {</a>
<a name="ln744">				if (generationCount == sc-&gt;ec_gencount)</a>
<a name="ln745">					noIntr++;</a>
<a name="ln746">				else</a>
<a name="ln747">					noIntr = 0;</a>
<a name="ln748">				break;</a>
<a name="ln749">			}</a>
<a name="ln750">			generationCount = sc-&gt;ec_gencount;</a>
<a name="ln751">		}</a>
<a name="ln752"> </a>
<a name="ln753">		/*</a>
<a name="ln754">		 * We finished waiting for the GPE and it never arrived.  Try to</a>
<a name="ln755">		 * read the register once and trust whatever value we got.  This is</a>
<a name="ln756">		 * the best we can do at this point.</a>
<a name="ln757">		 */</a>
<a name="ln758">		if (status != AE_OK)</a>
<a name="ln759">			status = EcCheckStatus(sc, &quot;sleep_end&quot;, event);</a>
<a name="ln760">	}</a>
<a name="ln761">	if (!needPoll &amp;&amp; noIntr &gt; 10) {</a>
<a name="ln762">		TRACE(&quot;not getting interrupts, switched to polled mode\n&quot;);</a>
<a name="ln763">		ec_polled_mode = true;</a>
<a name="ln764">	}</a>
<a name="ln765"> </a>
<a name="ln766">	if (status != AE_OK)</a>
<a name="ln767">		TRACE(&quot;error: ec wait timed out\n&quot;);</a>
<a name="ln768"> </a>
<a name="ln769">	return status;</a>
<a name="ln770">}</a>
<a name="ln771"> </a>
<a name="ln772"> </a>
<a name="ln773">static acpi_status</a>
<a name="ln774">EcCommand(struct acpi_ec_cookie* sc, EC_COMMAND cmd)</a>
<a name="ln775">{</a>
<a name="ln776">	// Don't use burst mode if user disabled it.</a>
<a name="ln777">	if (!ec_burst_mode &amp;&amp; cmd == EC_COMMAND_BURST_ENABLE)</a>
<a name="ln778">		return AE_ERROR;</a>
<a name="ln779"> </a>
<a name="ln780">	// Decide what to wait for based on command type.</a>
<a name="ln781">	EC_EVENT event;</a>
<a name="ln782">	switch (cmd) {</a>
<a name="ln783">		case EC_COMMAND_READ:</a>
<a name="ln784">		case EC_COMMAND_WRITE:</a>
<a name="ln785">		case EC_COMMAND_BURST_DISABLE:</a>
<a name="ln786">			event = EC_EVENT_INPUT_BUFFER_EMPTY;</a>
<a name="ln787">			break;</a>
<a name="ln788">		case EC_COMMAND_QUERY:</a>
<a name="ln789">		case EC_COMMAND_BURST_ENABLE:</a>
<a name="ln790">			event = EC_EVENT_OUTPUT_BUFFER_FULL;</a>
<a name="ln791">			break;</a>
<a name="ln792">		default:</a>
<a name="ln793">			TRACE(&quot;EcCommand: invalid command %#x\n&quot;, cmd);</a>
<a name="ln794">			return AE_BAD_PARAMETER;</a>
<a name="ln795">	}</a>
<a name="ln796"> </a>
<a name="ln797">	// Ensure empty input buffer before issuing command.</a>
<a name="ln798">	// Use generation count of zero to force a quick check.</a>
<a name="ln799">	acpi_status status = EcWaitEvent(sc, EC_EVENT_INPUT_BUFFER_EMPTY, 0);</a>
<a name="ln800">	if (status != AE_OK)</a>
<a name="ln801">		return status;</a>
<a name="ln802"> </a>
<a name="ln803">	// Run the command and wait for the chosen event.</a>
<a name="ln804">	TRACE(&quot;running command %#x\n&quot;, cmd);</a>
<a name="ln805">	int32 generationCount = sc-&gt;ec_gencount;</a>
<a name="ln806">	EC_SET_CSR(sc, cmd);</a>
<a name="ln807">	status = EcWaitEvent(sc, event, generationCount);</a>
<a name="ln808">	if (status == AE_OK) {</a>
<a name="ln809">		// If we succeeded, burst flag should now be present.</a>
<a name="ln810">		if (cmd == EC_COMMAND_BURST_ENABLE) {</a>
<a name="ln811">			EC_STATUS ec_status = EC_GET_CSR(sc);</a>
<a name="ln812">			if ((ec_status &amp; EC_FLAG_BURST_MODE) == 0)</a>
<a name="ln813">				status = AE_ERROR;</a>
<a name="ln814">		}</a>
<a name="ln815">	} else</a>
<a name="ln816">		TRACE(&quot;EcCommand: no response to %#x\n&quot;, cmd);</a>
<a name="ln817"> </a>
<a name="ln818">	return status;</a>
<a name="ln819">}</a>
<a name="ln820"> </a>
<a name="ln821"> </a>
<a name="ln822">static acpi_status</a>
<a name="ln823">EcRead(struct acpi_ec_cookie* sc, uint8 address, uint8* readData)</a>
<a name="ln824">{</a>
<a name="ln825">	TRACE(&quot;read from %#x\n&quot;, address);</a>
<a name="ln826"> </a>
<a name="ln827">	acpi_status status;</a>
<a name="ln828">	for (uint8 retry = 0; retry &lt; 2; retry++) {</a>
<a name="ln829">		status = EcCommand(sc, EC_COMMAND_READ);</a>
<a name="ln830">		if (status != AE_OK)</a>
<a name="ln831">			return status;</a>
<a name="ln832"> </a>
<a name="ln833">		int32 generationCount = sc-&gt;ec_gencount;</a>
<a name="ln834">		EC_SET_DATA(sc, address);</a>
<a name="ln835">		status = EcWaitEvent(sc, EC_EVENT_OUTPUT_BUFFER_FULL, generationCount);</a>
<a name="ln836">		if (status == AE_OK) {</a>
<a name="ln837">			*readData = EC_GET_DATA(sc);</a>
<a name="ln838">			return AE_OK;</a>
<a name="ln839">		}</a>
<a name="ln840">		if (EcCheckStatus(sc, &quot;retr_check&quot;, EC_EVENT_INPUT_BUFFER_EMPTY)</a>
<a name="ln841">				!= AE_OK) {</a>
<a name="ln842">			break;</a>
<a name="ln843">		}</a>
<a name="ln844">	}</a>
<a name="ln845"> </a>
<a name="ln846">	TRACE(&quot;EcRead: failed waiting to get data\n&quot;);</a>
<a name="ln847">	return status;</a>
<a name="ln848">}</a>
<a name="ln849"> </a>
<a name="ln850"> </a>
<a name="ln851">static acpi_status</a>
<a name="ln852">EcWrite(struct acpi_ec_cookie* sc, uint8 address, uint8 writeData)</a>
<a name="ln853">{</a>
<a name="ln854">	acpi_status status = EcCommand(sc, EC_COMMAND_WRITE);</a>
<a name="ln855">	if (status != AE_OK)</a>
<a name="ln856">		return status;</a>
<a name="ln857"> </a>
<a name="ln858">	int32 generationCount = sc-&gt;ec_gencount;</a>
<a name="ln859">	EC_SET_DATA(sc, address);</a>
<a name="ln860">	status = EcWaitEvent(sc, EC_EVENT_INPUT_BUFFER_EMPTY, generationCount);</a>
<a name="ln861">	if (status != AE_OK) {</a>
<a name="ln862">		TRACE(&quot;EcWrite: failed waiting for sent address\n&quot;);</a>
<a name="ln863">		return status;</a>
<a name="ln864">	}</a>
<a name="ln865"> </a>
<a name="ln866">	generationCount = sc-&gt;ec_gencount;</a>
<a name="ln867">	EC_SET_DATA(sc, writeData);</a>
<a name="ln868">	status = EcWaitEvent(sc, EC_EVENT_INPUT_BUFFER_EMPTY, generationCount);</a>
<a name="ln869">	if (status != AE_OK) {</a>
<a name="ln870">		TRACE(&quot;EcWrite: failed waiting for sent data\n&quot;);</a>
<a name="ln871">		return status;</a>
<a name="ln872">	}</a>
<a name="ln873"> </a>
<a name="ln874">	return AE_OK;</a>
<a name="ln875">}</a>

</code></pre>
<div class="balloon" rel="287"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v630/" target="_blank">V630</a> The 'malloc' function is used to allocate memory for an array of objects which are classes containing constructors and destructors.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
