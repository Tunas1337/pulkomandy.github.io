
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>attribute_overlay.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2009-2016, Haiku Inc. All rights reserved.</a>
<a name="ln3"> * Distributed under the terms of the MIT License.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Authors:</a>
<a name="ln6"> *		Michael Lotz &lt;mmlr@mlotz.ch&gt;</a>
<a name="ln7"> */</a>
<a name="ln8"> </a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;new&gt;</a>
<a name="ln11">#include &lt;stdlib.h&gt;</a>
<a name="ln12">#include &lt;string.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;dirent.h&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &lt;util/kernel_cpp.h&gt;</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;fs_info.h&gt;</a>
<a name="ln19">#include &lt;fs_interface.h&gt;</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;debug.h&gt;</a>
<a name="ln22">#include &lt;KernelExport.h&gt;</a>
<a name="ln23">#include &lt;NodeMonitor.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25"> </a>
<a name="ln26">//#define TRACE_OVERLAY</a>
<a name="ln27">#ifdef TRACE_OVERLAY</a>
<a name="ln28">#	define TRACE(x...)			dprintf(&quot;attribute_overlay: &quot; x)</a>
<a name="ln29">#	define TRACE_VOLUME(x...)	dprintf(&quot;attribute_overlay: &quot; x)</a>
<a name="ln30">#	define TRACE_ALWAYS(x...)	dprintf(&quot;attribute_overlay: &quot; x)</a>
<a name="ln31">#else</a>
<a name="ln32">#	define TRACE(x...)			/* nothing */</a>
<a name="ln33">#	define TRACE_VOLUME(x...)	/* nothing */</a>
<a name="ln34">#	define TRACE_ALWAYS(x...)	dprintf(&quot;attribute_overlay: &quot; x)</a>
<a name="ln35">#endif</a>
<a name="ln36"> </a>
<a name="ln37"> </a>
<a name="ln38">#define ATTRIBUTE_OVERLAY_FILE_MAGIC			'attr'</a>
<a name="ln39">#define ATTRIBUTE_OVERLAY_ATTRIBUTE_DIR_NAME	&quot;_HAIKU&quot;</a>
<a name="ln40"> </a>
<a name="ln41"> </a>
<a name="ln42">#define OVERLAY_CALL(op, params...) \</a>
<a name="ln43">	TRACE(&quot;relaying op: &quot; #op &quot;\n&quot;); \</a>
<a name="ln44">	OverlayInode *node = (OverlayInode *)vnode-&gt;private_node; \</a>
<a name="ln45">	fs_vnode *superVnode = node-&gt;SuperVnode(); \</a>
<a name="ln46">	if (superVnode-&gt;ops-&gt;op != NULL) \</a>
<a name="ln47">		return superVnode-&gt;ops-&gt;op(volume-&gt;super_volume, superVnode, params); \</a>
<a name="ln48">	return B_UNSUPPORTED;</a>
<a name="ln49"> </a>
<a name="ln50"> </a>
<a name="ln51">#define OVERLAY_VOLUME_CALL(op, params...) \</a>
<a name="ln52">	TRACE_VOLUME(&quot;relaying volume op: &quot; #op &quot;\n&quot;); \</a>
<a name="ln53">	if (volume-&gt;super_volume-&gt;ops-&gt;op != NULL) \</a>
<a name="ln54">		return volume-&gt;super_volume-&gt;ops-&gt;op(volume-&gt;super_volume, params);</a>
<a name="ln55"> </a>
<a name="ln56"> </a>
<a name="ln57">namespace attribute_overlay {</a>
<a name="ln58"> </a>
<a name="ln59">class AttributeFile;</a>
<a name="ln60">class AttributeEntry;</a>
<a name="ln61"> </a>
<a name="ln62"> </a>
<a name="ln63">struct attribute_dir_cookie {</a>
<a name="ln64">	AttributeFile *	file;</a>
<a name="ln65">	uint32			index;</a>
<a name="ln66">};</a>
<a name="ln67"> </a>
<a name="ln68"> </a>
<a name="ln69">class OverlayVolume {</a>
<a name="ln70">public:</a>
<a name="ln71">							OverlayVolume(fs_volume *volume);</a>
<a name="ln72">							~OverlayVolume();</a>
<a name="ln73"> </a>
<a name="ln74">		fs_volume *			Volume() { return fVolume; }</a>
<a name="ln75">		fs_volume *			SuperVolume() { return fVolume-&gt;super_volume; }</a>
<a name="ln76"> </a>
<a name="ln77">private:</a>
<a name="ln78">		fs_volume *			fVolume;</a>
<a name="ln79">};</a>
<a name="ln80"> </a>
<a name="ln81"> </a>
<a name="ln82">class OverlayInode {</a>
<a name="ln83">public:</a>
<a name="ln84">							OverlayInode(OverlayVolume *volume,</a>
<a name="ln85">								fs_vnode *superVnode, ino_t inodeNumber);</a>
<a name="ln86">							~OverlayInode();</a>
<a name="ln87"> </a>
<a name="ln88">		status_t			InitCheck();</a>
<a name="ln89"> </a>
<a name="ln90">		fs_volume *			Volume() { return fVolume-&gt;Volume(); }</a>
<a name="ln91">		fs_volume *			SuperVolume() { return fVolume-&gt;SuperVolume(); }</a>
<a name="ln92">		fs_vnode *			SuperVnode() { return &amp;fSuperVnode; }</a>
<a name="ln93">		ino_t				InodeNumber() { return fInodeNumber; }</a>
<a name="ln94"> </a>
<a name="ln95">		status_t			GetAttributeFile(AttributeFile **attributeFile);</a>
<a name="ln96">		status_t			WriteAttributeFile();</a>
<a name="ln97">		status_t			RemoveAttributeFile();</a>
<a name="ln98"> </a>
<a name="ln99">private:</a>
<a name="ln100">		OverlayVolume *		fVolume;</a>
<a name="ln101">		fs_vnode			fSuperVnode;</a>
<a name="ln102">		ino_t				fInodeNumber;</a>
<a name="ln103">		AttributeFile *		fAttributeFile;</a>
<a name="ln104">};</a>
<a name="ln105"> </a>
<a name="ln106"> </a>
<a name="ln107">class AttributeFile {</a>
<a name="ln108">public:</a>
<a name="ln109">								AttributeFile(fs_volume *overlay,</a>
<a name="ln110">									fs_volume *volume, fs_vnode *vnode);</a>
<a name="ln111">								~AttributeFile();</a>
<a name="ln112"> </a>
<a name="ln113">			status_t			InitCheck() { return fStatus; }</a>
<a name="ln114"> </a>
<a name="ln115">			dev_t				VolumeID() { return fVolumeID; }</a>
<a name="ln116">			ino_t				FileInode() { return fFileInode; }</a>
<a name="ln117"> </a>
<a name="ln118">			status_t			CreateEmpty();</a>
<a name="ln119">			status_t			WriteAttributeFile(fs_volume *overlay,</a>
<a name="ln120">									fs_volume *volume, fs_vnode *vnode);</a>
<a name="ln121">			status_t			RemoveAttributeFile(fs_volume *overlay,</a>
<a name="ln122">									fs_volume *volume, fs_vnode *vnode);</a>
<a name="ln123"> </a>
<a name="ln124">			status_t			ReadAttributeDir(struct dirent *dirent,</a>
<a name="ln125">									size_t bufferSize, uint32 *numEntries,</a>
<a name="ln126">									uint32 *index);</a>
<a name="ln127"> </a>
<a name="ln128">			uint32				CountAttributes();</a>
<a name="ln129">			AttributeEntry *	FindAttribute(const char *name,</a>
<a name="ln130">									uint32 *index = NULL);</a>
<a name="ln131"> </a>
<a name="ln132">			status_t			CreateAttribute(const char *name, type_code type,</a>
<a name="ln133">									int openMode, AttributeEntry **entry);</a>
<a name="ln134">			status_t			OpenAttribute(const char *name, int openMode,</a>
<a name="ln135">									AttributeEntry **entry);</a>
<a name="ln136">			status_t			RemoveAttribute(const char *name,</a>
<a name="ln137">									AttributeEntry **entry);</a>
<a name="ln138">			status_t			AddAttribute(AttributeEntry *entry);</a>
<a name="ln139"> </a>
<a name="ln140">private:</a>
<a name="ln141">			struct attribute_file {</a>
<a name="ln142">				uint32			magic;</a>
<a name="ln143">					// ATTRIBUTE_OVERLAY_FILE_MAGIC</a>
<a name="ln144">				uint32			entry_count;</a>
<a name="ln145">				uint8			entries[1];</a>
<a name="ln146">			} _PACKED;</a>
<a name="ln147"> </a>
<a name="ln148">			status_t			fStatus;</a>
<a name="ln149">			dev_t				fVolumeID;</a>
<a name="ln150">			ino_t				fFileInode;</a>
<a name="ln151">			ino_t				fDirectoryInode;</a>
<a name="ln152">			ino_t				fAttributeDirInode;</a>
<a name="ln153">			ino_t				fAttributeFileInode;</a>
<a name="ln154">			attribute_file *	fFile;</a>
<a name="ln155">			uint32				fAttributeDirIndex;</a>
<a name="ln156">			AttributeEntry **	fEntries;</a>
<a name="ln157">};</a>
<a name="ln158"> </a>
<a name="ln159"> </a>
<a name="ln160">class AttributeEntry {</a>
<a name="ln161">public:</a>
<a name="ln162">								AttributeEntry(AttributeFile *parent,</a>
<a name="ln163">									uint8 *buffer);</a>
<a name="ln164">								AttributeEntry(AttributeFile *parent,</a>
<a name="ln165">									const char *name, type_code type);</a>
<a name="ln166">								~AttributeEntry();</a>
<a name="ln167"> </a>
<a name="ln168">			status_t			InitCheck() { return fStatus; }</a>
<a name="ln169"> </a>
<a name="ln170">			uint8 *				Entry() { return (uint8 *)fEntry; }</a>
<a name="ln171">			size_t				EntrySize();</a>
<a name="ln172">			uint8 *				Data() { return fData; }</a>
<a name="ln173">			size_t				DataSize() { return fEntry-&gt;size; }</a>
<a name="ln174"> </a>
<a name="ln175">			status_t			SetType(type_code type);</a>
<a name="ln176">			type_code			Type() { return fEntry-&gt;type; }</a>
<a name="ln177"> </a>
<a name="ln178">			status_t			SetSize(size_t size);</a>
<a name="ln179">			uint32				Size() { return fEntry-&gt;size; }</a>
<a name="ln180"> </a>
<a name="ln181">			status_t			SetName(const char *name);</a>
<a name="ln182">			const char *		Name() { return fEntry-&gt;name; }</a>
<a name="ln183">			uint8				NameLength() { return fEntry-&gt;name_length; }</a>
<a name="ln184"> </a>
<a name="ln185">			status_t			FillDirent(struct dirent *dirent,</a>
<a name="ln186">									size_t bufferSize, uint32 *numEntries);</a>
<a name="ln187"> </a>
<a name="ln188">			status_t			Read(off_t position, void *buffer,</a>
<a name="ln189">									size_t *length);</a>
<a name="ln190">			status_t			Write(off_t position, const void *buffer,</a>
<a name="ln191">									size_t *length);</a>
<a name="ln192"> </a>
<a name="ln193">			status_t			ReadStat(struct stat *stat);</a>
<a name="ln194">			status_t			WriteStat(const struct stat *stat,</a>
<a name="ln195">									uint32 statMask);</a>
<a name="ln196"> </a>
<a name="ln197">private:</a>
<a name="ln198">			struct attribute_entry {</a>
<a name="ln199">				type_code		type;</a>
<a name="ln200">				uint32			size;</a>
<a name="ln201">				uint8			name_length; // including 0 byte</a>
<a name="ln202">				char			name[1]; // 0 terminated, followed by data</a>
<a name="ln203">			} _PACKED;</a>
<a name="ln204"> </a>
<a name="ln205">			AttributeFile *		fParent;</a>
<a name="ln206">			attribute_entry *	fEntry;</a>
<a name="ln207">			uint8 *				fData;</a>
<a name="ln208">			status_t			fStatus;</a>
<a name="ln209">			bool				fAllocatedEntry;</a>
<a name="ln210">			bool				fAllocatedData;</a>
<a name="ln211">};</a>
<a name="ln212"> </a>
<a name="ln213"> </a>
<a name="ln214">//	#pragma mark OverlayVolume</a>
<a name="ln215"> </a>
<a name="ln216"> </a>
<a name="ln217">OverlayVolume::OverlayVolume(fs_volume *volume)</a>
<a name="ln218">	:</a>
<a name="ln219">	fVolume(volume)</a>
<a name="ln220">{</a>
<a name="ln221">}</a>
<a name="ln222"> </a>
<a name="ln223"> </a>
<a name="ln224">OverlayVolume::~OverlayVolume()</a>
<a name="ln225">{</a>
<a name="ln226">}</a>
<a name="ln227"> </a>
<a name="ln228"> </a>
<a name="ln229">//	#pragma mark OverlayInode</a>
<a name="ln230"> </a>
<a name="ln231"> </a>
<a name="ln232">OverlayInode::OverlayInode(OverlayVolume *volume, fs_vnode *superVnode,</a>
<a name="ln233">	ino_t inodeNumber)</a>
<a name="ln234">	:</a>
<a name="ln235">	fVolume(volume),</a>
<a name="ln236">	fSuperVnode(*superVnode),</a>
<a name="ln237">	fInodeNumber(inodeNumber),</a>
<a name="ln238">	fAttributeFile(NULL)</a>
<a name="ln239">{</a>
<a name="ln240">	TRACE(&quot;inode created\n&quot;);</a>
<a name="ln241">}</a>
<a name="ln242"> </a>
<a name="ln243"> </a>
<a name="ln244">OverlayInode::~OverlayInode()</a>
<a name="ln245">{</a>
<a name="ln246">	TRACE(&quot;inode destroyed\n&quot;);</a>
<a name="ln247">	delete fAttributeFile;</a>
<a name="ln248">}</a>
<a name="ln249"> </a>
<a name="ln250"> </a>
<a name="ln251">status_t</a>
<a name="ln252">OverlayInode::InitCheck()</a>
<a name="ln253">{</a>
<a name="ln254">	return B_OK;</a>
<a name="ln255">}</a>
<a name="ln256"> </a>
<a name="ln257"> </a>
<a name="ln258">status_t</a>
<a name="ln259">OverlayInode::GetAttributeFile(AttributeFile **attributeFile)</a>
<a name="ln260">{</a>
<a name="ln261">	if (fAttributeFile == NULL) {</a>
<a name="ln262">		fAttributeFile = new(std::nothrow) AttributeFile(Volume(),</a>
<a name="ln263">			SuperVolume(), &amp;fSuperVnode);</a>
<a name="ln264">		if (fAttributeFile == NULL) {</a>
<a name="ln265">			TRACE_ALWAYS(&quot;no memory to allocate attribute file\n&quot;);</a>
<a name="ln266">			return B_NO_MEMORY;</a>
<a name="ln267">		}</a>
<a name="ln268">	}</a>
<a name="ln269"> </a>
<a name="ln270">	status_t result = fAttributeFile-&gt;InitCheck();</a>
<a name="ln271">	if (result != B_OK) {</a>
<a name="ln272">		if (result == B_ENTRY_NOT_FOUND) {</a>
<a name="ln273">			// TODO: need to check if we're able to create the file</a>
<a name="ln274">			// but at least allow virtual attributes for now</a>
<a name="ln275">		}</a>
<a name="ln276"> </a>
<a name="ln277">		result = fAttributeFile-&gt;CreateEmpty();</a>
<a name="ln278">		if (result != B_OK)</a>
<a name="ln279">			return result;</a>
<a name="ln280">	}</a>
<a name="ln281"> </a>
<a name="ln282">	*attributeFile = fAttributeFile;</a>
<a name="ln283">	return B_OK;</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286"> </a>
<a name="ln287">status_t</a>
<a name="ln288">OverlayInode::WriteAttributeFile()</a>
<a name="ln289">{</a>
<a name="ln290">	if (fAttributeFile == NULL)</a>
<a name="ln291">		return B_NO_INIT;</a>
<a name="ln292"> </a>
<a name="ln293">	status_t result = fAttributeFile-&gt;InitCheck();</a>
<a name="ln294">	if (result != B_OK)</a>
<a name="ln295">		return result;</a>
<a name="ln296"> </a>
<a name="ln297">	return fAttributeFile-&gt;WriteAttributeFile(Volume(), SuperVolume(),</a>
<a name="ln298">		&amp;fSuperVnode);</a>
<a name="ln299">}</a>
<a name="ln300"> </a>
<a name="ln301"> </a>
<a name="ln302">status_t</a>
<a name="ln303">OverlayInode::RemoveAttributeFile()</a>
<a name="ln304">{</a>
<a name="ln305">	if (fAttributeFile == NULL)</a>
<a name="ln306">		return B_NO_INIT;</a>
<a name="ln307"> </a>
<a name="ln308">	status_t result = fAttributeFile-&gt;InitCheck();</a>
<a name="ln309">	if (result != B_OK)</a>
<a name="ln310">		return result;</a>
<a name="ln311"> </a>
<a name="ln312">	return fAttributeFile-&gt;RemoveAttributeFile(Volume(), SuperVolume(),</a>
<a name="ln313">		&amp;fSuperVnode);</a>
<a name="ln314">}</a>
<a name="ln315"> </a>
<a name="ln316"> </a>
<a name="ln317">//	#pragma mark AttributeFile</a>
<a name="ln318"> </a>
<a name="ln319"> </a>
<a name="ln320">AttributeFile::AttributeFile(fs_volume *overlay, fs_volume *volume,</a>
<a name="ln321">	fs_vnode *vnode)</a>
<a name="ln322">	:</a>
<a name="ln323">	fStatus(B_NO_INIT),</a>
<a name="ln324">	fVolumeID(volume-&gt;id),</a>
<a name="ln325">	fFileInode(0),</a>
<a name="ln326">	fDirectoryInode(0),</a>
<a name="ln327">	fAttributeDirInode(0),</a>
<a name="ln328">	fAttributeFileInode(0),</a>
<a name="ln329">	fFile(NULL),</a>
<a name="ln330">	fAttributeDirIndex(0),</a>
<a name="ln331">	fEntries(NULL)</a>
<a name="ln332">{</a>
<a name="ln333">	if (vnode-&gt;ops-&gt;get_vnode_name == NULL) {</a>
<a name="ln334">		TRACE_ALWAYS(&quot;cannot get vnode name, hook missing\n&quot;);</a>
<a name="ln335">		fStatus = B_UNSUPPORTED;</a>
<a name="ln336">		return;</a>
<a name="ln337">	}</a>
<a name="ln338"> </a>
<a name="ln339">	char nameBuffer[B_FILE_NAME_LENGTH];</a>
<a name="ln340">	nameBuffer[sizeof(nameBuffer) - 1] = 0;</a>
<a name="ln341">	fStatus = vnode-&gt;ops-&gt;get_vnode_name(volume, vnode, nameBuffer,</a>
<a name="ln342">		sizeof(nameBuffer) - 1);</a>
<a name="ln343">	if (fStatus != B_OK) {</a>
<a name="ln344">		TRACE_ALWAYS(&quot;failed to get vnode name: %s\n&quot;, strerror(fStatus));</a>
<a name="ln345">		return;</a>
<a name="ln346">	}</a>
<a name="ln347"> </a>
<a name="ln348">	if (strcmp(nameBuffer, ATTRIBUTE_OVERLAY_ATTRIBUTE_DIR_NAME) == 0) {</a>
<a name="ln349">		// we don't want attribute overlays on the attribute dir itself</a>
<a name="ln350">		fStatus = B_UNSUPPORTED;</a>
<a name="ln351">		return;</a>
<a name="ln352">	}</a>
<a name="ln353"> </a>
<a name="ln354">	struct stat stat;</a>
<a name="ln355">	if (vnode-&gt;ops-&gt;read_stat != NULL</a>
<a name="ln356">		&amp;&amp; vnode-&gt;ops-&gt;read_stat(volume, vnode, &amp;stat) == B_OK) {</a>
<a name="ln357">		fFileInode = stat.st_ino;</a>
<a name="ln358">	}</a>
<a name="ln359"> </a>
<a name="ln360">	// TODO: the &quot;..&quot; lookup is not actually valid for non-directory vnodes.</a>
<a name="ln361">	// we make use of the fact that a filesystem probably still provides the</a>
<a name="ln362">	// lookup hook and has hardcoded &quot;..&quot; to resolve to the parent entry. if we</a>
<a name="ln363">	// wanted to do this correctly we need some other way to relate this vnode</a>
<a name="ln364">	// to its parent directory vnode.</a>
<a name="ln365">	const char *lookup[]</a>
<a name="ln366">		= { &quot;..&quot;, ATTRIBUTE_OVERLAY_ATTRIBUTE_DIR_NAME, nameBuffer };</a>
<a name="ln367">	int32 lookupCount = sizeof(lookup) / sizeof(lookup[0]);</a>
<a name="ln368">	fs_vnode currentVnode = *vnode;</a>
<a name="ln369">	ino_t lastInodeNumber = 0;</a>
<a name="ln370"> </a>
<a name="ln371">	for (int32 i = 0; i &lt; lookupCount; i++) {</a>
<a name="ln372">		if (currentVnode.ops-&gt;lookup == NULL) {</a>
<a name="ln373">			TRACE_ALWAYS(&quot;lookup not possible, lookup hook missing\n&quot;);</a>
<a name="ln374">			fStatus = B_UNSUPPORTED;</a>
<a name="ln375">			if (i &gt; 0)</a>
<a name="ln376">				put_vnode(volume, lastInodeNumber);</a>
<a name="ln377">			return;</a>
<a name="ln378">		}</a>
<a name="ln379"> </a>
<a name="ln380">		ino_t inodeNumber;</a>
<a name="ln381">		fStatus = currentVnode.ops-&gt;lookup(volume, &amp;currentVnode, lookup[i],</a>
<a name="ln382">			&amp;inodeNumber);</a>
<a name="ln383"> </a>
<a name="ln384">		if (i &gt; 0)</a>
<a name="ln385">			put_vnode(volume, lastInodeNumber);</a>
<a name="ln386"> </a>
<a name="ln387">		if (fStatus != B_OK) {</a>
<a name="ln388">			if (fStatus != B_ENTRY_NOT_FOUND) {</a>
<a name="ln389">				TRACE_ALWAYS(&quot;lookup of \&quot;%s\&quot; failed: %s\n&quot;, lookup[i],</a>
<a name="ln390">					strerror(fStatus));</a>
<a name="ln391">			}</a>
<a name="ln392">			return;</a>
<a name="ln393">		}</a>
<a name="ln394"> </a>
<a name="ln395">		if (i == 0)</a>
<a name="ln396">			fDirectoryInode = inodeNumber;</a>
<a name="ln397">		else if (i == 1)</a>
<a name="ln398">			fAttributeDirInode = inodeNumber;</a>
<a name="ln399">		else if (i == 2)</a>
<a name="ln400">			fAttributeFileInode = inodeNumber;</a>
<a name="ln401"> </a>
<a name="ln402">		OverlayInode *overlayInode = NULL;</a>
<a name="ln403">		fStatus = get_vnode(overlay, inodeNumber, (void **)&amp;overlayInode);</a>
<a name="ln404">		if (fStatus != B_OK) {</a>
<a name="ln405">			TRACE_ALWAYS(&quot;getting vnode failed: %s\n&quot;, strerror(fStatus));</a>
<a name="ln406">			return;</a>
<a name="ln407">		}</a>
<a name="ln408"> </a>
<a name="ln409">		currentVnode = *overlayInode-&gt;SuperVnode();</a>
<a name="ln410">		lastInodeNumber = inodeNumber;</a>
<a name="ln411">	}</a>
<a name="ln412"> </a>
<a name="ln413">	if (currentVnode.ops-&gt;read_stat == NULL || currentVnode.ops-&gt;open == NULL</a>
<a name="ln414">		|| currentVnode.ops-&gt;read == NULL) {</a>
<a name="ln415">		TRACE_ALWAYS(&quot;can't use attribute file, hooks missing\n&quot;);</a>
<a name="ln416">		put_vnode(volume, lastInodeNumber);</a>
<a name="ln417">		fStatus = B_UNSUPPORTED;</a>
<a name="ln418">		return;</a>
<a name="ln419">	}</a>
<a name="ln420"> </a>
<a name="ln421">	fStatus = currentVnode.ops-&gt;read_stat(volume, &amp;currentVnode, &amp;stat);</a>
<a name="ln422">	if (fStatus != B_OK) {</a>
<a name="ln423">		TRACE_ALWAYS(&quot;failed to stat attribute file: %s\n&quot;, strerror(fStatus));</a>
<a name="ln424">		put_vnode(volume, lastInodeNumber);</a>
<a name="ln425">		return;</a>
<a name="ln426">	}</a>
<a name="ln427"> </a>
<a name="ln428">	void *attrFileCookie = NULL;</a>
<a name="ln429">	fStatus = currentVnode.ops-&gt;open(volume, &amp;currentVnode, O_RDONLY,</a>
<a name="ln430">		&amp;attrFileCookie);</a>
<a name="ln431">	if (fStatus != B_OK) {</a>
<a name="ln432">		TRACE_ALWAYS(&quot;failed to open attribute file: %s\n&quot;, strerror(fStatus));</a>
<a name="ln433">		put_vnode(volume, lastInodeNumber);</a>
<a name="ln434">		return;</a>
<a name="ln435">	}</a>
<a name="ln436"> </a>
<a name="ln437">	size_t readLength = stat.st_size;</a>
<a name="ln438">	uint8 *buffer = (uint8 *)malloc(readLength);</a>
<a name="ln439">	if (buffer == NULL) {</a>
<a name="ln440">		TRACE_ALWAYS(&quot;cannot allocate memory for read buffer\n&quot;);</a>
<a name="ln441">		put_vnode(volume, lastInodeNumber);</a>
<a name="ln442">		fStatus = B_NO_MEMORY;</a>
<a name="ln443">		return;</a>
<a name="ln444">	}</a>
<a name="ln445"> </a>
<a name="ln446">	fStatus = currentVnode.ops-&gt;read(volume, &amp;currentVnode, attrFileCookie, 0,</a>
<a name="ln447">		buffer, &amp;readLength);</a>
<a name="ln448">	if (fStatus != B_OK) {</a>
<a name="ln449">		TRACE_ALWAYS(&quot;failed to read from file: %s\n&quot;, strerror(fStatus));</a>
<a name="ln450">		put_vnode(volume, lastInodeNumber);</a>
<a name="ln451">		return;</a>
<a name="ln452">	}</a>
<a name="ln453"> </a>
<a name="ln454">	if (currentVnode.ops-&gt;close != NULL)</a>
<a name="ln455">		currentVnode.ops-&gt;close(volume, &amp;currentVnode, attrFileCookie);</a>
<a name="ln456">	if (currentVnode.ops-&gt;free_cookie != NULL)</a>
<a name="ln457">		currentVnode.ops-&gt;free_cookie(volume, &amp;currentVnode, attrFileCookie);</a>
<a name="ln458"> </a>
<a name="ln459">	put_vnode(volume, lastInodeNumber);</a>
<a name="ln460"> </a>
<a name="ln461">	fFile = (attribute_file *)buffer;</a>
<a name="ln462">	if (fFile-&gt;magic != ATTRIBUTE_OVERLAY_FILE_MAGIC) {</a>
<a name="ln463">		TRACE_ALWAYS(&quot;attribute file has bad magic\n&quot;);</a>
<a name="ln464">		fStatus = B_BAD_VALUE;</a>
<a name="ln465">		return;</a>
<a name="ln466">	}</a>
<a name="ln467"> </a>
<a name="ln468">	fEntries = (AttributeEntry **)malloc(fFile-&gt;entry_count</a>
<a name="ln469">		* sizeof(AttributeEntry *));</a>
<a name="ln470">	if (fEntries == NULL) {</a>
<a name="ln471">		TRACE_ALWAYS(&quot;no memory to allocate entry pointers\n&quot;);</a>
<a name="ln472">		fStatus = B_NO_MEMORY;</a>
<a name="ln473">		return;</a>
<a name="ln474">	}</a>
<a name="ln475"> </a>
<a name="ln476">	for (uint32 i = 0; i &lt; fFile-&gt;entry_count; i++)</a>
<a name="ln477">		fEntries[i] = NULL;</a>
<a name="ln478"> </a>
<a name="ln479">	size_t totalSize = 0;</a>
<a name="ln480">	readLength -= sizeof(attribute_file) - 1;</a>
<a name="ln481">	for (uint32 i = 0; i &lt; fFile-&gt;entry_count; i++) {</a>
<a name="ln482">		fEntries[i] = new(std::nothrow) AttributeEntry(this,</a>
<a name="ln483">			fFile-&gt;entries + totalSize);</a>
<a name="ln484">		if (fEntries[i] == NULL) {</a>
<a name="ln485">			TRACE_ALWAYS(&quot;no memory to allocate attribute entry\n&quot;);</a>
<a name="ln486">			fStatus = B_NO_MEMORY;</a>
<a name="ln487">			return;</a>
<a name="ln488">		}</a>
<a name="ln489"> </a>
<a name="ln490">		totalSize += fEntries[i]-&gt;EntrySize() + fEntries[i]-&gt;DataSize();</a>
<a name="ln491">		if (totalSize &gt; readLength) {</a>
<a name="ln492">			TRACE_ALWAYS(&quot;attribute entries are too large for buffer\n&quot;);</a>
<a name="ln493">			fStatus = B_BAD_VALUE;</a>
<a name="ln494">			return;</a>
<a name="ln495">		}</a>
<a name="ln496">	}</a>
<a name="ln497">}</a>
<a name="ln498"> </a>
<a name="ln499"> </a>
<a name="ln500">AttributeFile::~AttributeFile()</a>
<a name="ln501">{</a>
<a name="ln502">	if (fFile == NULL)</a>
<a name="ln503">		return;</a>
<a name="ln504"> </a>
<a name="ln505">	if (fEntries != NULL) {</a>
<a name="ln506">		for (uint32 i = 0; i &lt; fFile-&gt;entry_count; i++)</a>
<a name="ln507">			delete fEntries[i];</a>
<a name="ln508"> </a>
<a name="ln509">		free(fEntries);</a>
<a name="ln510">	}</a>
<a name="ln511"> </a>
<a name="ln512">	free(fFile);</a>
<a name="ln513">}</a>
<a name="ln514"> </a>
<a name="ln515"> </a>
<a name="ln516">status_t</a>
<a name="ln517">AttributeFile::CreateEmpty()</a>
<a name="ln518">{</a>
<a name="ln519">	if (fFile == NULL) {</a>
<a name="ln520">		fFile = (attribute_file *)malloc(sizeof(attribute_file) - 1);</a>
<a name="ln521">		if (fFile == NULL) {</a>
<a name="ln522">			TRACE_ALWAYS(&quot;failed to allocate file buffer\n&quot;);</a>
<a name="ln523">			fStatus = B_NO_MEMORY;</a>
<a name="ln524">			return fStatus;</a>
<a name="ln525">		}</a>
<a name="ln526"> </a>
<a name="ln527">		fFile-&gt;entry_count = 0;</a>
<a name="ln528">		fFile-&gt;magic = ATTRIBUTE_OVERLAY_FILE_MAGIC;</a>
<a name="ln529">	}</a>
<a name="ln530"> </a>
<a name="ln531">	fStatus = B_OK;</a>
<a name="ln532">	return B_OK;</a>
<a name="ln533">}</a>
<a name="ln534"> </a>
<a name="ln535"> </a>
<a name="ln536">status_t</a>
<a name="ln537">AttributeFile::WriteAttributeFile(fs_volume *overlay, fs_volume *volume,</a>
<a name="ln538">	fs_vnode *vnode)</a>
<a name="ln539">{</a>
<a name="ln540">	if (fFile == NULL)</a>
<a name="ln541">		return B_NO_INIT;</a>
<a name="ln542"> </a>
<a name="ln543">	char nameBuffer[B_FILE_NAME_LENGTH];</a>
<a name="ln544">	nameBuffer[sizeof(nameBuffer) - 1] = 0;</a>
<a name="ln545">	status_t result = vnode-&gt;ops-&gt;get_vnode_name(volume, vnode, nameBuffer,</a>
<a name="ln546">		sizeof(nameBuffer) - 1);</a>
<a name="ln547">	if (result != B_OK) {</a>
<a name="ln548">		TRACE_ALWAYS(&quot;failed to get vnode name: %s\n&quot;, strerror(result));</a>
<a name="ln549">		return result;</a>
<a name="ln550">	}</a>
<a name="ln551"> </a>
<a name="ln552">	fs_vnode currentVnode = *vnode;</a>
<a name="ln553">	if (fDirectoryInode == 0) {</a>
<a name="ln554">		if (currentVnode.ops-&gt;lookup == NULL) {</a>
<a name="ln555">			TRACE_ALWAYS(&quot;lookup not possible, lookup hook missing\n&quot;);</a>
<a name="ln556">			return B_UNSUPPORTED;</a>
<a name="ln557">		}</a>
<a name="ln558"> </a>
<a name="ln559">		// see TODO above</a>
<a name="ln560">		result = currentVnode.ops-&gt;lookup(volume, &amp;currentVnode, &quot;..&quot;,</a>
<a name="ln561">			&amp;fDirectoryInode);</a>
<a name="ln562">		if (result != B_OK) {</a>
<a name="ln563">			TRACE_ALWAYS(&quot;lookup of parent directory failed: %s\n&quot;,</a>
<a name="ln564">				strerror(result));</a>
<a name="ln565">			return B_UNSUPPORTED;</a>
<a name="ln566">		}</a>
<a name="ln567"> </a>
<a name="ln568">		put_vnode(volume, fDirectoryInode);</a>
<a name="ln569">	}</a>
<a name="ln570"> </a>
<a name="ln571">	OverlayInode *overlayInode = NULL;</a>
<a name="ln572">	if (fAttributeDirInode == 0) {</a>
<a name="ln573">		result = get_vnode(overlay, fDirectoryInode, (void **)&amp;overlayInode);</a>
<a name="ln574">		if (result != B_OK) {</a>
<a name="ln575">			TRACE_ALWAYS(&quot;failed to get directory vnode: %s\n&quot;,</a>
<a name="ln576">				strerror(result));</a>
<a name="ln577">			return result;</a>
<a name="ln578">		}</a>
<a name="ln579"> </a>
<a name="ln580">		currentVnode = *overlayInode-&gt;SuperVnode();</a>
<a name="ln581"> </a>
<a name="ln582">		// create the attribute directory</a>
<a name="ln583">		result = currentVnode.ops-&gt;create_dir(volume, &amp;currentVnode,</a>
<a name="ln584">			ATTRIBUTE_OVERLAY_ATTRIBUTE_DIR_NAME, S_IRWXU | S_IRWXG | S_IRWXO);</a>
<a name="ln585"> </a>
<a name="ln586">		if (result == B_OK) {</a>
<a name="ln587">			result = currentVnode.ops-&gt;lookup(volume, &amp;currentVnode,</a>
<a name="ln588">				ATTRIBUTE_OVERLAY_ATTRIBUTE_DIR_NAME, &amp;fAttributeDirInode);</a>
<a name="ln589"> </a>
<a name="ln590">			// lookup() got us a reference we don't need -- put it</a>
<a name="ln591">			if (result == B_OK)</a>
<a name="ln592">				put_vnode(volume, fAttributeDirInode);</a>
<a name="ln593">		}</a>
<a name="ln594"> </a>
<a name="ln595">		put_vnode(volume, fDirectoryInode);</a>
<a name="ln596"> </a>
<a name="ln597">		if (result != B_OK) {</a>
<a name="ln598">			TRACE_ALWAYS(&quot;failed to create attribute directory: %s\n&quot;,</a>
<a name="ln599">				strerror(result));</a>
<a name="ln600">			fAttributeDirInode = 0;</a>
<a name="ln601">			return result;</a>
<a name="ln602">		}</a>
<a name="ln603">	}</a>
<a name="ln604"> </a>
<a name="ln605">	void *attrFileCookie = NULL;</a>
<a name="ln606">	if (fAttributeFileInode == 0) {</a>
<a name="ln607">		result = get_vnode(overlay, fAttributeDirInode, (void **)&amp;overlayInode);</a>
<a name="ln608">		if (result != B_OK) {</a>
<a name="ln609">			TRACE_ALWAYS(&quot;failed to get attribute directory vnode: %s\n&quot;,</a>
<a name="ln610">				strerror(result));</a>
<a name="ln611">			return result;</a>
<a name="ln612">		}</a>
<a name="ln613"> </a>
<a name="ln614">		currentVnode = *overlayInode-&gt;SuperVnode();</a>
<a name="ln615"> </a>
<a name="ln616">		// create the attribute file</a>
<a name="ln617">		result = currentVnode.ops-&gt;create(volume, &amp;currentVnode,</a>
<a name="ln618">			nameBuffer, O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP</a>
<a name="ln619">			| S_IWGRP | S_IROTH | S_IWOTH, &amp;attrFileCookie,</a>
<a name="ln620">			&amp;fAttributeFileInode);</a>
<a name="ln621"> </a>
<a name="ln622">		put_vnode(volume, fAttributeDirInode);</a>
<a name="ln623"> </a>
<a name="ln624">		if (result != B_OK) {</a>
<a name="ln625">			TRACE_ALWAYS(&quot;failed to create attribute file: %s\n&quot;,</a>
<a name="ln626">				strerror(result));</a>
<a name="ln627">			return result;</a>
<a name="ln628">		}</a>
<a name="ln629"> </a>
<a name="ln630">		result = get_vnode(overlay, fAttributeFileInode,</a>
<a name="ln631">			(void **)&amp;overlayInode);</a>
<a name="ln632">		if (result != B_OK) {</a>
<a name="ln633">			TRACE_ALWAYS(&quot;getting attribute file vnode after create failed: &quot;</a>
<a name="ln634">				&quot;%s\n&quot;, strerror(result));</a>
<a name="ln635">			return result;</a>
<a name="ln636">		}</a>
<a name="ln637"> </a>
<a name="ln638">		currentVnode = *overlayInode-&gt;SuperVnode();</a>
<a name="ln639">	} else {</a>
<a name="ln640">		result = get_vnode(overlay, fAttributeFileInode,</a>
<a name="ln641">			(void **)&amp;overlayInode);</a>
<a name="ln642">		if (result != B_OK) {</a>
<a name="ln643">			TRACE_ALWAYS(&quot;getting attribute file vnode failed: %s\n&quot;,</a>
<a name="ln644">				strerror(result));</a>
<a name="ln645">			return result;</a>
<a name="ln646">		}</a>
<a name="ln647"> </a>
<a name="ln648">		currentVnode = *overlayInode-&gt;SuperVnode();</a>
<a name="ln649"> </a>
<a name="ln650">		// open the attribute file</a>
<a name="ln651">		result = currentVnode.ops-&gt;open(volume, &amp;currentVnode, O_RDWR | O_TRUNC,</a>
<a name="ln652">			&amp;attrFileCookie);</a>
<a name="ln653">		if (result != B_OK) {</a>
<a name="ln654">			TRACE_ALWAYS(&quot;failed to open attribute file for writing: %s\n&quot;,</a>
<a name="ln655">				strerror(result));</a>
<a name="ln656">			put_vnode(volume, fAttributeFileInode);</a>
<a name="ln657">			return result;</a>
<a name="ln658">		}</a>
<a name="ln659">	}</a>
<a name="ln660"> </a>
<a name="ln661">	off_t position = 0;</a>
<a name="ln662">	size_t writeLength = sizeof(attribute_file) - 1;</a>
<a name="ln663">	result = currentVnode.ops-&gt;write(volume, &amp;currentVnode, attrFileCookie,</a>
<a name="ln664">		position, fFile, &amp;writeLength);</a>
<a name="ln665">	if (result != B_OK) {</a>
<a name="ln666">		TRACE_ALWAYS(&quot;failed to write to attribute file: %s\n&quot;,</a>
<a name="ln667">			strerror(result));</a>
<a name="ln668">		goto close_and_put;</a>
<a name="ln669">	}</a>
<a name="ln670"> </a>
<a name="ln671">	for (uint32 i = 0; i &lt; fFile-&gt;entry_count; i++) {</a>
<a name="ln672">		writeLength = fEntries[i]-&gt;EntrySize();</a>
<a name="ln673">		result = currentVnode.ops-&gt;write(volume, &amp;currentVnode, attrFileCookie,</a>
<a name="ln674">			position, fEntries[i]-&gt;Entry(), &amp;writeLength);</a>
<a name="ln675">		if (result != B_OK) {</a>
<a name="ln676">			TRACE_ALWAYS(&quot;failed to write to attribute file: %s\n&quot;,</a>
<a name="ln677">				strerror(result));</a>
<a name="ln678">			goto close_and_put;</a>
<a name="ln679">		}</a>
<a name="ln680"> </a>
<a name="ln681">		writeLength = fEntries[i]-&gt;DataSize();</a>
<a name="ln682">		result = currentVnode.ops-&gt;write(volume, &amp;currentVnode, attrFileCookie,</a>
<a name="ln683">			position, fEntries[i]-&gt;Data(), &amp;writeLength);</a>
<a name="ln684">		if (result != B_OK) {</a>
<a name="ln685">			TRACE_ALWAYS(&quot;failed to write to attribute file: %s\n&quot;,</a>
<a name="ln686">				strerror(result));</a>
<a name="ln687">			goto close_and_put;</a>
<a name="ln688">		}</a>
<a name="ln689">	}</a>
<a name="ln690"> </a>
<a name="ln691">close_and_put:</a>
<a name="ln692">	if (currentVnode.ops-&gt;close != NULL)</a>
<a name="ln693">		currentVnode.ops-&gt;close(volume, &amp;currentVnode, attrFileCookie);</a>
<a name="ln694">	if (currentVnode.ops-&gt;free_cookie != NULL)</a>
<a name="ln695">		currentVnode.ops-&gt;free_cookie(volume, &amp;currentVnode, attrFileCookie);</a>
<a name="ln696"> </a>
<a name="ln697">	put_vnode(volume, fAttributeFileInode);</a>
<a name="ln698">	return B_OK;</a>
<a name="ln699">}</a>
<a name="ln700"> </a>
<a name="ln701"> </a>
<a name="ln702">status_t</a>
<a name="ln703">AttributeFile::RemoveAttributeFile(fs_volume *overlay, fs_volume *volume,</a>
<a name="ln704">	fs_vnode *vnode)</a>
<a name="ln705">{</a>
<a name="ln706">	bool hasAttributeFile = fAttributeFileInode != 0;</a>
<a name="ln707">	ino_t attributeDirInode = fAttributeDirInode;</a>
<a name="ln708"> </a>
<a name="ln709">	// invalidate all of our cached inode numbers</a>
<a name="ln710">	fDirectoryInode = 0;</a>
<a name="ln711">	fAttributeDirInode = 0;</a>
<a name="ln712">	fAttributeFileInode = 0;</a>
<a name="ln713"> </a>
<a name="ln714">	if (!hasAttributeFile) {</a>
<a name="ln715">		// there is no backing file at all yet</a>
<a name="ln716">		return B_OK;</a>
<a name="ln717">	}</a>
<a name="ln718"> </a>
<a name="ln719">	char nameBuffer[B_FILE_NAME_LENGTH];</a>
<a name="ln720">	nameBuffer[sizeof(nameBuffer) - 1] = 0;</a>
<a name="ln721">	status_t result = vnode-&gt;ops-&gt;get_vnode_name(volume, vnode, nameBuffer,</a>
<a name="ln722">		sizeof(nameBuffer) - 1);</a>
<a name="ln723">	if (result != B_OK) {</a>
<a name="ln724">		TRACE_ALWAYS(&quot;failed to get vnode name: %s\n&quot;, strerror(result));</a>
<a name="ln725">		return result;</a>
<a name="ln726">	}</a>
<a name="ln727"> </a>
<a name="ln728">	OverlayInode *overlayInode = NULL;</a>
<a name="ln729">	result = get_vnode(overlay, attributeDirInode, (void **)&amp;overlayInode);</a>
<a name="ln730">	if (result != B_OK) {</a>
<a name="ln731">		TRACE_ALWAYS(&quot;getting attribute directory vnode failed: %s\n&quot;,</a>
<a name="ln732">			strerror(result));</a>
<a name="ln733">		return result;</a>
<a name="ln734">	}</a>
<a name="ln735"> </a>
<a name="ln736">	fs_vnode attributeDir = *overlayInode-&gt;SuperVnode();</a>
<a name="ln737">	if (attributeDir.ops-&gt;unlink == NULL) {</a>
<a name="ln738">		TRACE_ALWAYS(&quot;cannot remove attribute file, unlink hook missing\n&quot;);</a>
<a name="ln739">		put_vnode(volume, attributeDirInode);</a>
<a name="ln740">		return B_UNSUPPORTED;</a>
<a name="ln741">	}</a>
<a name="ln742"> </a>
<a name="ln743">	result = attributeDir.ops-&gt;unlink(volume, &amp;attributeDir, nameBuffer);</a>
<a name="ln744">	if (result != B_OK) {</a>
<a name="ln745">		TRACE_ALWAYS(&quot;failed to unlink attribute file: %s\n&quot;, strerror(result));</a>
<a name="ln746">		put_vnode(volume, attributeDirInode);</a>
<a name="ln747">		return result;</a>
<a name="ln748">	}</a>
<a name="ln749"> </a>
<a name="ln750">	put_vnode(volume, attributeDirInode);</a>
<a name="ln751">	return B_OK;</a>
<a name="ln752">}</a>
<a name="ln753"> </a>
<a name="ln754"> </a>
<a name="ln755">uint32</a>
<a name="ln756">AttributeFile::CountAttributes()</a>
<a name="ln757">{</a>
<a name="ln758">	if (fFile == NULL)</a>
<a name="ln759">		return 0;</a>
<a name="ln760"> </a>
<a name="ln761">	return fFile-&gt;entry_count;</a>
<a name="ln762">}</a>
<a name="ln763"> </a>
<a name="ln764"> </a>
<a name="ln765">AttributeEntry *</a>
<a name="ln766">AttributeFile::FindAttribute(const char *name, uint32 *index)</a>
<a name="ln767">{</a>
<a name="ln768">	for (uint32 i = 0; i &lt; fFile-&gt;entry_count; i++) {</a>
<a name="ln769">		if (strcmp(fEntries[i]-&gt;Name(), name) == 0) {</a>
<a name="ln770">			if (index)</a>
<a name="ln771">				*index = i;</a>
<a name="ln772"> </a>
<a name="ln773">			return fEntries[i];</a>
<a name="ln774">		}</a>
<a name="ln775">	}</a>
<a name="ln776"> </a>
<a name="ln777">	return NULL;</a>
<a name="ln778">}</a>
<a name="ln779"> </a>
<a name="ln780"> </a>
<a name="ln781">status_t</a>
<a name="ln782">AttributeFile::CreateAttribute(const char *name, type_code type, int openMode,</a>
<a name="ln783">	AttributeEntry **_entry)</a>
<a name="ln784">{</a>
<a name="ln785">	AttributeEntry *existing = FindAttribute(name);</a>
<a name="ln786">	if (existing != NULL) {</a>
<a name="ln787">		if ((openMode &amp; O_TRUNC) != 0)</a>
<a name="ln788">			existing-&gt;SetSize(0);</a>
<a name="ln789"> </a>
<a name="ln790">		// attribute already exists, only allow if the attribute type is</a>
<a name="ln791">		// compatible or the attribute size is 0</a>
<a name="ln792">		if (existing-&gt;Type() != type) {</a>
<a name="ln793">			if (existing-&gt;Size() != 0)</a>
<a name="ln794">				return B_FILE_EXISTS;</a>
<a name="ln795">			existing-&gt;SetType(type);</a>
<a name="ln796">		}</a>
<a name="ln797"> </a>
<a name="ln798">		if (existing-&gt;InitCheck() == B_OK) {</a>
<a name="ln799">			*_entry = existing;</a>
<a name="ln800">			return B_OK;</a>
<a name="ln801">		}</a>
<a name="ln802"> </a>
<a name="ln803">		// we tried to change the existing item but failed, try to just</a>
<a name="ln804">		// remove it instead and creating a new one</a>
<a name="ln805">		RemoveAttribute(name, NULL);</a>
<a name="ln806">	}</a>
<a name="ln807"> </a>
<a name="ln808">	AttributeEntry *entry = new(std::nothrow) AttributeEntry(this, name, type);</a>
<a name="ln809">	if (entry == NULL)</a>
<a name="ln810">		return B_NO_MEMORY;</a>
<a name="ln811"> </a>
<a name="ln812">	status_t result = AddAttribute(entry);</a>
<a name="ln813">	if (result != B_OK) {</a>
<a name="ln814">		delete entry;</a>
<a name="ln815">		return result;</a>
<a name="ln816">	}</a>
<a name="ln817"> </a>
<a name="ln818">	*_entry = entry;</a>
<a name="ln819">	return B_OK;</a>
<a name="ln820">}</a>
<a name="ln821"> </a>
<a name="ln822"> </a>
<a name="ln823">status_t</a>
<a name="ln824">AttributeFile::OpenAttribute(const char *name, int openMode,</a>
<a name="ln825">	AttributeEntry **_entry)</a>
<a name="ln826">{</a>
<a name="ln827">	AttributeEntry *entry = FindAttribute(name);</a>
<a name="ln828">	if (entry == NULL)</a>
<a name="ln829">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln830"> </a>
<a name="ln831">	if (openMode &amp; O_TRUNC)</a>
<a name="ln832">		entry-&gt;SetSize(0);</a>
<a name="ln833"> </a>
<a name="ln834">	*_entry = entry;</a>
<a name="ln835">	return B_OK;</a>
<a name="ln836">}</a>
<a name="ln837"> </a>
<a name="ln838"> </a>
<a name="ln839">status_t</a>
<a name="ln840">AttributeFile::RemoveAttribute(const char *name, AttributeEntry **_entry)</a>
<a name="ln841">{</a>
<a name="ln842">	uint32 index = 0;</a>
<a name="ln843">	AttributeEntry *entry = FindAttribute(name, &amp;index);</a>
<a name="ln844">	if (entry == NULL)</a>
<a name="ln845">		return B_ENTRY_NOT_FOUND;</a>
<a name="ln846"> </a>
<a name="ln847">	for (uint32 i = index + 1; i &lt; fFile-&gt;entry_count; i++)</a>
<a name="ln848">		fEntries[i - 1] = fEntries[i];</a>
<a name="ln849">	fFile-&gt;entry_count--;</a>
<a name="ln850"> </a>
<a name="ln851">	if (_entry)</a>
<a name="ln852">		*_entry = entry;</a>
<a name="ln853">	else</a>
<a name="ln854">		delete entry;</a>
<a name="ln855"> </a>
<a name="ln856">	notify_attribute_changed(fVolumeID, -1, fFileInode, name, B_ATTR_REMOVED);</a>
<a name="ln857">	return B_OK;</a>
<a name="ln858">}</a>
<a name="ln859"> </a>
<a name="ln860"> </a>
<a name="ln861">status_t</a>
<a name="ln862">AttributeFile::AddAttribute(AttributeEntry *entry)</a>
<a name="ln863">{</a>
<a name="ln864">	status_t result = entry-&gt;InitCheck();</a>
<a name="ln865">	if (result != B_OK)</a>
<a name="ln866">		return result;</a>
<a name="ln867"> </a>
<a name="ln868">	if (FindAttribute(entry-&gt;Name()) != NULL)</a>
<a name="ln869">		return B_FILE_EXISTS;</a>
<a name="ln870"> </a>
<a name="ln871">	AttributeEntry **newEntries = (AttributeEntry **)realloc(fEntries,</a>
<a name="ln872">		(fFile-&gt;entry_count + 1) * sizeof(AttributeEntry *));</a>
<a name="ln873">	if (newEntries == NULL)</a>
<a name="ln874">		return B_NO_MEMORY;</a>
<a name="ln875"> </a>
<a name="ln876">	fEntries = newEntries;</a>
<a name="ln877">	fEntries[fFile-&gt;entry_count++] = entry;</a>
<a name="ln878"> </a>
<a name="ln879">	notify_attribute_changed(fVolumeID, -1, fFileInode, entry-&gt;Name(),</a>
<a name="ln880">		B_ATTR_CREATED);</a>
<a name="ln881"> </a>
<a name="ln882">	return B_OK;</a>
<a name="ln883">}</a>
<a name="ln884"> </a>
<a name="ln885"> </a>
<a name="ln886">status_t</a>
<a name="ln887">AttributeFile::ReadAttributeDir(struct dirent *dirent, size_t bufferSize,</a>
<a name="ln888">	uint32 *numEntries, uint32 *index)</a>
<a name="ln889">{</a>
<a name="ln890">	if (fFile == NULL || *index &gt;= fFile-&gt;entry_count) {</a>
<a name="ln891">		*numEntries = 0;</a>
<a name="ln892">		return B_OK;</a>
<a name="ln893">	}</a>
<a name="ln894"> </a>
<a name="ln895">	return fEntries[(*index)++]-&gt;FillDirent(dirent, bufferSize, numEntries);</a>
<a name="ln896">}</a>
<a name="ln897"> </a>
<a name="ln898"> </a>
<a name="ln899">//	#pragma mark AttributeEntry</a>
<a name="ln900"> </a>
<a name="ln901"> </a>
<a name="ln902">AttributeEntry::AttributeEntry(AttributeFile *parent, uint8 *buffer)</a>
<a name="ln903">	:</a>
<a name="ln904">	fParent(parent),</a>
<a name="ln905">	fEntry(NULL),</a>
<a name="ln906">	fData(NULL),</a>
<a name="ln907">	fStatus(B_NO_INIT),</a>
<a name="ln908">	fAllocatedEntry(false),</a>
<a name="ln909">	fAllocatedData(false)</a>
<a name="ln910">{</a>
<a name="ln911">	if (buffer == NULL)</a>
<a name="ln912">		return;</a>
<a name="ln913"> </a>
<a name="ln914">	fEntry = (attribute_entry *)buffer;</a>
<a name="ln915">	fData = (uint8 *)fEntry-&gt;name + fEntry-&gt;name_length;</a>
<a name="ln916">	fStatus = B_OK;</a>
<a name="ln917">}</a>
<a name="ln918"> </a>
<a name="ln919"> </a>
<a name="ln920">AttributeEntry::AttributeEntry(AttributeFile *parent, const char *name,</a>
<a name="ln921">	type_code type)</a>
<a name="ln922">	:</a>
<a name="ln923">	fParent(parent),</a>
<a name="ln924">	fEntry(NULL),</a>
<a name="ln925">	fData(NULL),</a>
<a name="ln926">	fStatus(B_NO_INIT),</a>
<a name="ln927">	fAllocatedEntry(false),</a>
<a name="ln928">	fAllocatedData(false)</a>
<a name="ln929">{</a>
<a name="ln930">	fStatus = SetName(name);</a>
<a name="ln931">	if (fStatus != B_OK)</a>
<a name="ln932">		return;</a>
<a name="ln933"> </a>
<a name="ln934">	fEntry-&gt;type = type;</a>
<a name="ln935">	fEntry-&gt;size = 0;</a>
<a name="ln936">}</a>
<a name="ln937"> </a>
<a name="ln938"> </a>
<a name="ln939">AttributeEntry::~AttributeEntry()</a>
<a name="ln940">{</a>
<a name="ln941">	if (fAllocatedEntry)</a>
<a name="ln942">		free(fEntry);</a>
<a name="ln943">	if (fAllocatedData)</a>
<a name="ln944">		free(fData);</a>
<a name="ln945">}</a>
<a name="ln946"> </a>
<a name="ln947"> </a>
<a name="ln948">size_t</a>
<a name="ln949">AttributeEntry::EntrySize()</a>
<a name="ln950">{</a>
<a name="ln951">	return sizeof(attribute_entry) - 1 + fEntry-&gt;name_length;</a>
<a name="ln952">}</a>
<a name="ln953"> </a>
<a name="ln954"> </a>
<a name="ln955">status_t</a>
<a name="ln956">AttributeEntry::SetType(type_code type)</a>
<a name="ln957">{</a>
<a name="ln958">	fEntry-&gt;type = type;</a>
<a name="ln959">	return B_OK;</a>
<a name="ln960">}</a>
<a name="ln961"> </a>
<a name="ln962"> </a>
<a name="ln963">status_t</a>
<a name="ln964">AttributeEntry::SetSize(size_t size)</a>
<a name="ln965">{</a>
<a name="ln966">	if (size &lt;= fEntry-&gt;size) {</a>
<a name="ln967">		fEntry-&gt;size = size;</a>
<a name="ln968">		return B_OK;</a>
<a name="ln969">	}</a>
<a name="ln970"> </a>
<a name="ln971">	if (fAllocatedData) {</a>
<a name="ln972">		uint8 *newData = (uint8 *)realloc(fData, size);</a>
<a name="ln973">		if (newData == NULL) {</a>
<a name="ln974">			fStatus = B_NO_MEMORY;</a>
<a name="ln975">			return fStatus;</a>
<a name="ln976">		}</a>
<a name="ln977"> </a>
<a name="ln978">		fData = newData;</a>
<a name="ln979">		fEntry-&gt;size = size;</a>
<a name="ln980">		return B_OK;</a>
<a name="ln981">	}</a>
<a name="ln982"> </a>
<a name="ln983">	uint8 *newData = (uint8 *)malloc(size);</a>
<a name="ln984">	if (newData == NULL) {</a>
<a name="ln985">		fStatus = B_NO_MEMORY;</a>
<a name="ln986">		return fStatus;</a>
<a name="ln987">	}</a>
<a name="ln988"> </a>
<a name="ln989">	memcpy(newData, fData, min_c(fEntry-&gt;size, size));</a>
<a name="ln990">	fEntry-&gt;size = size;</a>
<a name="ln991">	fAllocatedData = true;</a>
<a name="ln992">	fData = newData;</a>
<a name="ln993">	return B_OK;</a>
<a name="ln994">}</a>
<a name="ln995"> </a>
<a name="ln996"> </a>
<a name="ln997">status_t</a>
<a name="ln998">AttributeEntry::SetName(const char *name)</a>
<a name="ln999">{</a>
<a name="ln1000">	size_t nameLength = strlen(name) + 1;</a>
<a name="ln1001">	if (nameLength &gt; 255) {</a>
<a name="ln1002">		fStatus = B_NAME_TOO_LONG;</a>
<a name="ln1003">		return fStatus;</a>
<a name="ln1004">	}</a>
<a name="ln1005"> </a>
<a name="ln1006">	if (!fAllocatedEntry || fEntry-&gt;name_length &lt; nameLength) {</a>
<a name="ln1007">		attribute_entry *newEntry = (attribute_entry *)malloc(</a>
<a name="ln1008">			sizeof(attribute_entry) - 1 + nameLength);</a>
<a name="ln1009">		if (newEntry == NULL) {</a>
<a name="ln1010">			fStatus = B_NO_MEMORY;</a>
<a name="ln1011">			return fStatus;</a>
<a name="ln1012">		}</a>
<a name="ln1013"> </a>
<a name="ln1014">		if (fEntry != NULL)</a>
<a name="ln1015">			memcpy(newEntry, fEntry, sizeof(attribute_entry) - 1);</a>
<a name="ln1016">		if (fAllocatedEntry)</a>
<a name="ln1017">			free(fEntry);</a>
<a name="ln1018"> </a>
<a name="ln1019">		fAllocatedEntry = true;</a>
<a name="ln1020">		fEntry = newEntry;</a>
<a name="ln1021">	}</a>
<a name="ln1022"> </a>
<a name="ln1023">	fEntry-&gt;name_length = nameLength;</a>
<a name="ln1024">	strlcpy(fEntry-&gt;name, name, nameLength);</a>
<a name="ln1025">	return B_OK;</a>
<a name="ln1026">}</a>
<a name="ln1027"> </a>
<a name="ln1028"> </a>
<a name="ln1029">status_t</a>
<a name="ln1030">AttributeEntry::FillDirent(struct dirent *dirent, size_t bufferSize,</a>
<a name="ln1031">	uint32 *numEntries)</a>
<a name="ln1032">{</a>
<a name="ln1033">	dirent-&gt;d_dev = dirent-&gt;d_pdev = fParent-&gt;VolumeID();</a>
<a name="ln1034">	dirent-&gt;d_ino = (ino_t)this;</a>
<a name="ln1035">	dirent-&gt;d_pino = fParent-&gt;FileInode();</a>
<a name="ln1036">	dirent-&gt;d_reclen = sizeof(struct dirent) + fEntry-&gt;name_length;</a>
<a name="ln1037">	if (bufferSize &lt; dirent-&gt;d_reclen) {</a>
<a name="ln1038">		*numEntries = 0;</a>
<a name="ln1039">		return B_BAD_VALUE;</a>
<a name="ln1040">	}</a>
<a name="ln1041"> </a>
<a name="ln1042">	strncpy(dirent-&gt;d_name, fEntry-&gt;name, fEntry-&gt;name_length);</a>
<a name="ln1043">	dirent-&gt;d_name[fEntry-&gt;name_length - 1] = 0;</a>
<a name="ln1044">	*numEntries = 1;</a>
<a name="ln1045">	return B_OK;</a>
<a name="ln1046">}</a>
<a name="ln1047"> </a>
<a name="ln1048"> </a>
<a name="ln1049">status_t</a>
<a name="ln1050">AttributeEntry::Read(off_t position, void *buffer, size_t *length)</a>
<a name="ln1051">{</a>
<a name="ln1052">	*length = (size_t)min_c((off_t)*length, fEntry-&gt;size - position);</a>
<a name="ln1053">	memcpy(buffer, fData + position, *length);</a>
<a name="ln1054">	return B_OK;</a>
<a name="ln1055">}</a>
<a name="ln1056"> </a>
<a name="ln1057"> </a>
<a name="ln1058">status_t</a>
<a name="ln1059">AttributeEntry::Write(off_t position, const void *buffer, size_t *length)</a>
<a name="ln1060">{</a>
<a name="ln1061">	size_t neededSize = position + *length;</a>
<a name="ln1062">	if (neededSize &gt; fEntry-&gt;size) {</a>
<a name="ln1063">		status_t result = SetSize(neededSize);</a>
<a name="ln1064">		if (result != B_OK) {</a>
<a name="ln1065">			*length = 0;</a>
<a name="ln1066">			return result;</a>
<a name="ln1067">		}</a>
<a name="ln1068">	}</a>
<a name="ln1069"> </a>
<a name="ln1070">	memcpy(fData + position, buffer, *length);</a>
<a name="ln1071">	notify_attribute_changed(fParent-&gt;VolumeID(), -1, fParent-&gt;FileInode(),</a>
<a name="ln1072">		fEntry-&gt;name, B_ATTR_CHANGED);</a>
<a name="ln1073">	return B_OK;</a>
<a name="ln1074">}</a>
<a name="ln1075"> </a>
<a name="ln1076"> </a>
<a name="ln1077">status_t</a>
<a name="ln1078">AttributeEntry::ReadStat(struct stat *stat)</a>
<a name="ln1079">{</a>
<a name="ln1080">	stat-&gt;st_dev = fParent-&gt;VolumeID();</a>
<a name="ln1081">	stat-&gt;st_ino = (ino_t)this;</a>
<a name="ln1082">	stat-&gt;st_nlink = 1;</a>
<a name="ln1083">	stat-&gt;st_blksize = 512;</a>
<a name="ln1084">	stat-&gt;st_uid = 1;</a>
<a name="ln1085">	stat-&gt;st_gid = 1;</a>
<a name="ln1086">	stat-&gt;st_size = fEntry-&gt;size;</a>
<a name="ln1087">	stat-&gt;st_mode = S_ATTR | 0x0777;</a>
<a name="ln1088">	stat-&gt;st_type = fEntry-&gt;type;</a>
<a name="ln1089">	stat-&gt;st_atime = stat-&gt;st_mtime = stat-&gt;st_crtime = time(NULL);</a>
<a name="ln1090">	stat-&gt;st_blocks = (fEntry-&gt;size + stat-&gt;st_blksize - 1) / stat-&gt;st_blksize;</a>
<a name="ln1091">	return B_OK;</a>
<a name="ln1092">}</a>
<a name="ln1093"> </a>
<a name="ln1094"> </a>
<a name="ln1095">status_t</a>
<a name="ln1096">AttributeEntry::WriteStat(const struct stat *stat, uint32 statMask)</a>
<a name="ln1097">{</a>
<a name="ln1098">	return B_UNSUPPORTED;</a>
<a name="ln1099">}</a>
<a name="ln1100"> </a>
<a name="ln1101"> </a>
<a name="ln1102">//	#pragma mark - vnode ops</a>
<a name="ln1103"> </a>
<a name="ln1104"> </a>
<a name="ln1105">static status_t</a>
<a name="ln1106">overlay_put_vnode(fs_volume *volume, fs_vnode *vnode, bool reenter)</a>
<a name="ln1107">{</a>
<a name="ln1108">	OverlayInode *node = (OverlayInode *)vnode-&gt;private_node;</a>
<a name="ln1109">	fs_vnode *superVnode = node-&gt;SuperVnode();</a>
<a name="ln1110"> </a>
<a name="ln1111">	status_t result = B_OK;</a>
<a name="ln1112">	if (superVnode-&gt;ops-&gt;put_vnode != NULL) {</a>
<a name="ln1113">		result = superVnode-&gt;ops-&gt;put_vnode(volume-&gt;super_volume, superVnode,</a>
<a name="ln1114">			reenter);</a>
<a name="ln1115">	}</a>
<a name="ln1116"> </a>
<a name="ln1117">	delete node;</a>
<a name="ln1118">	return result;</a>
<a name="ln1119">}</a>
<a name="ln1120"> </a>
<a name="ln1121"> </a>
<a name="ln1122">static status_t</a>
<a name="ln1123">overlay_remove_vnode(fs_volume *volume, fs_vnode *vnode, bool reenter)</a>
<a name="ln1124">{</a>
<a name="ln1125">	OverlayInode *node = (OverlayInode *)vnode-&gt;private_node;</a>
<a name="ln1126">	fs_vnode *superVnode = node-&gt;SuperVnode();</a>
<a name="ln1127"> </a>
<a name="ln1128">	status_t result = B_OK;</a>
<a name="ln1129">	if (superVnode-&gt;ops-&gt;remove_vnode != NULL) {</a>
<a name="ln1130">		result = superVnode-&gt;ops-&gt;remove_vnode(volume-&gt;super_volume, superVnode,</a>
<a name="ln1131">			reenter);</a>
<a name="ln1132">	}</a>
<a name="ln1133"> </a>
<a name="ln1134">	delete node;</a>
<a name="ln1135">	return result;</a>
<a name="ln1136">}</a>
<a name="ln1137"> </a>
<a name="ln1138"> </a>
<a name="ln1139">static status_t</a>
<a name="ln1140">overlay_get_super_vnode(fs_volume *volume, fs_vnode *vnode,</a>
<a name="ln1141">	fs_volume *superVolume, fs_vnode *_superVnode)</a>
<a name="ln1142">{</a>
<a name="ln1143">	if (volume == superVolume) {</a>
<a name="ln1144">		*_superVnode = *vnode;</a>
<a name="ln1145">		return B_OK;</a>
<a name="ln1146">	}</a>
<a name="ln1147"> </a>
<a name="ln1148">	OverlayInode *node = (OverlayInode *)vnode-&gt;private_node;</a>
<a name="ln1149">	fs_vnode *superVnode = node-&gt;SuperVnode();</a>
<a name="ln1150"> </a>
<a name="ln1151">	if (superVnode-&gt;ops-&gt;get_super_vnode != NULL) {</a>
<a name="ln1152">		return superVnode-&gt;ops-&gt;get_super_vnode(volume-&gt;super_volume,</a>
<a name="ln1153">			superVnode, superVolume, _superVnode);</a>
<a name="ln1154">	}</a>
<a name="ln1155"> </a>
<a name="ln1156">	*_superVnode = *superVnode;</a>
<a name="ln1157">	return B_OK;</a>
<a name="ln1158">}</a>
<a name="ln1159"> </a>
<a name="ln1160"> </a>
<a name="ln1161">static status_t</a>
<a name="ln1162">overlay_lookup(fs_volume *volume, fs_vnode *vnode, const char *name, ino_t *id)</a>
<a name="ln1163">{</a>
<a name="ln1164">	OVERLAY_CALL(lookup, name, id)</a>
<a name="ln1165">}</a>
<a name="ln1166"> </a>
<a name="ln1167"> </a>
<a name="ln1168">static status_t</a>
<a name="ln1169">overlay_get_vnode_name(fs_volume *volume, fs_vnode *vnode, char *buffer,</a>
<a name="ln1170">	size_t bufferSize)</a>
<a name="ln1171">{</a>
<a name="ln1172">	OVERLAY_CALL(get_vnode_name, buffer, bufferSize)</a>
<a name="ln1173">}</a>
<a name="ln1174"> </a>
<a name="ln1175"> </a>
<a name="ln1176">static bool</a>
<a name="ln1177">overlay_can_page(fs_volume *volume, fs_vnode *vnode, void *cookie)</a>
<a name="ln1178">{</a>
<a name="ln1179">	TRACE(&quot;relaying op: can_page\n&quot;);</a>
<a name="ln1180">	OverlayInode *node = (OverlayInode *)vnode-&gt;private_node;</a>
<a name="ln1181">	fs_vnode *superVnode = node-&gt;SuperVnode();</a>
<a name="ln1182"> </a>
<a name="ln1183">	if (superVnode-&gt;ops-&gt;can_page != NULL) {</a>
<a name="ln1184">		return superVnode-&gt;ops-&gt;can_page(volume-&gt;super_volume, superVnode,</a>
<a name="ln1185">			cookie);</a>
<a name="ln1186">	}</a>
<a name="ln1187"> </a>
<a name="ln1188">	return false;</a>
<a name="ln1189">}</a>
<a name="ln1190"> </a>
<a name="ln1191"> </a>
<a name="ln1192">static status_t</a>
<a name="ln1193">overlay_read_pages(fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos,</a>
<a name="ln1194">	const iovec *vecs, size_t count, size_t *numBytes)</a>
<a name="ln1195">{</a>
<a name="ln1196">	OVERLAY_CALL(read_pages, cookie, pos, vecs, count, numBytes)</a>
<a name="ln1197">}</a>
<a name="ln1198"> </a>
<a name="ln1199"> </a>
<a name="ln1200">static status_t</a>
<a name="ln1201">overlay_write_pages(fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos,</a>
<a name="ln1202">	const iovec *vecs, size_t count, size_t *numBytes)</a>
<a name="ln1203">{</a>
<a name="ln1204">	OVERLAY_CALL(write_pages, cookie, pos, vecs, count, numBytes)</a>
<a name="ln1205">}</a>
<a name="ln1206"> </a>
<a name="ln1207"> </a>
<a name="ln1208">static status_t</a>
<a name="ln1209">overlay_io(fs_volume *volume, fs_vnode *vnode, void *cookie,</a>
<a name="ln1210">	io_request *request)</a>
<a name="ln1211">{</a>
<a name="ln1212">	OVERLAY_CALL(io, cookie, request)</a>
<a name="ln1213">}</a>
<a name="ln1214"> </a>
<a name="ln1215"> </a>
<a name="ln1216">static status_t</a>
<a name="ln1217">overlay_cancel_io(fs_volume *volume, fs_vnode *vnode, void *cookie,</a>
<a name="ln1218">	io_request *request)</a>
<a name="ln1219">{</a>
<a name="ln1220">	OVERLAY_CALL(cancel_io, cookie, request)</a>
<a name="ln1221">}</a>
<a name="ln1222"> </a>
<a name="ln1223"> </a>
<a name="ln1224">static status_t</a>
<a name="ln1225">overlay_get_file_map(fs_volume *volume, fs_vnode *vnode, off_t offset,</a>
<a name="ln1226">	size_t size, struct file_io_vec *vecs, size_t *count)</a>
<a name="ln1227">{</a>
<a name="ln1228">	OVERLAY_CALL(get_file_map, offset, size, vecs, count)</a>
<a name="ln1229">}</a>
<a name="ln1230"> </a>
<a name="ln1231"> </a>
<a name="ln1232">static status_t</a>
<a name="ln1233">overlay_ioctl(fs_volume *volume, fs_vnode *vnode, void *cookie, uint32 op,</a>
<a name="ln1234">	void *buffer, size_t length)</a>
<a name="ln1235">{</a>
<a name="ln1236">	OVERLAY_CALL(ioctl, cookie, op, buffer, length)</a>
<a name="ln1237">}</a>
<a name="ln1238"> </a>
<a name="ln1239"> </a>
<a name="ln1240">static status_t</a>
<a name="ln1241">overlay_set_flags(fs_volume *volume, fs_vnode *vnode, void *cookie,</a>
<a name="ln1242">	int flags)</a>
<a name="ln1243">{</a>
<a name="ln1244">	OVERLAY_CALL(set_flags, cookie, flags)</a>
<a name="ln1245">}</a>
<a name="ln1246"> </a>
<a name="ln1247"> </a>
<a name="ln1248">static status_t</a>
<a name="ln1249">overlay_select(fs_volume *volume, fs_vnode *vnode, void *cookie, uint8 event,</a>
<a name="ln1250">	selectsync *sync)</a>
<a name="ln1251">{</a>
<a name="ln1252">	OVERLAY_CALL(select, cookie, event, sync)</a>
<a name="ln1253">}</a>
<a name="ln1254"> </a>
<a name="ln1255"> </a>
<a name="ln1256">static status_t</a>
<a name="ln1257">overlay_deselect(fs_volume *volume, fs_vnode *vnode, void *cookie, uint8 event,</a>
<a name="ln1258">	selectsync *sync)</a>
<a name="ln1259">{</a>
<a name="ln1260">	OVERLAY_CALL(deselect, cookie, event, sync)</a>
<a name="ln1261">}</a>
<a name="ln1262"> </a>
<a name="ln1263"> </a>
<a name="ln1264">static status_t</a>
<a name="ln1265">overlay_fsync(fs_volume *volume, fs_vnode *vnode)</a>
<a name="ln1266">{</a>
<a name="ln1267">	OverlayInode *node = (OverlayInode *)vnode-&gt;private_node;</a>
<a name="ln1268">	fs_vnode *superVnode = node-&gt;SuperVnode();</a>
<a name="ln1269"> </a>
<a name="ln1270">	if (superVnode-&gt;ops-&gt;fsync != NULL)</a>
<a name="ln1271">		return superVnode-&gt;ops-&gt;fsync(volume-&gt;super_volume, superVnode);</a>
<a name="ln1272"> </a>
<a name="ln1273">	return B_OK;</a>
<a name="ln1274">}</a>
<a name="ln1275"> </a>
<a name="ln1276"> </a>
<a name="ln1277">static status_t</a>
<a name="ln1278">overlay_read_symlink(fs_volume *volume, fs_vnode *vnode, char *buffer,</a>
<a name="ln1279">	size_t *bufferSize)</a>
<a name="ln1280">{</a>
<a name="ln1281">	OVERLAY_CALL(read_symlink, buffer, bufferSize)</a>
<a name="ln1282">}</a>
<a name="ln1283"> </a>
<a name="ln1284"> </a>
<a name="ln1285">static status_t</a>
<a name="ln1286">overlay_create_symlink(fs_volume *volume, fs_vnode *vnode, const char *name,</a>
<a name="ln1287">	const char *path, int mode)</a>
<a name="ln1288">{</a>
<a name="ln1289">	OVERLAY_CALL(create_symlink, name, path, mode)</a>
<a name="ln1290">}</a>
<a name="ln1291"> </a>
<a name="ln1292"> </a>
<a name="ln1293">static status_t</a>
<a name="ln1294">overlay_link(fs_volume *volume, fs_vnode *vnode, const char *name,</a>
<a name="ln1295">	fs_vnode *target)</a>
<a name="ln1296">{</a>
<a name="ln1297">	OverlayInode *targetNode = (OverlayInode *)target-&gt;private_node;</a>
<a name="ln1298">	OVERLAY_CALL(link, name, targetNode-&gt;SuperVnode())</a>
<a name="ln1299">}</a>
<a name="ln1300"> </a>
<a name="ln1301"> </a>
<a name="ln1302">static status_t</a>
<a name="ln1303">overlay_unlink(fs_volume *volume, fs_vnode *vnode, const char *name)</a>
<a name="ln1304">{</a>
<a name="ln1305">	OVERLAY_CALL(unlink, name)</a>
<a name="ln1306">}</a>
<a name="ln1307"> </a>
<a name="ln1308"> </a>
<a name="ln1309">static status_t</a>
<a name="ln1310">overlay_rename(fs_volume *volume, fs_vnode *vnode,</a>
<a name="ln1311">	const char *fromName, fs_vnode *toDir, const char *toName)</a>
<a name="ln1312">{</a>
<a name="ln1313">	OverlayInode *toDirNode = (OverlayInode *)toDir-&gt;private_node;</a>
<a name="ln1314">	OVERLAY_CALL(rename, fromName, toDirNode-&gt;SuperVnode(), toName)</a>
<a name="ln1315">}</a>
<a name="ln1316"> </a>
<a name="ln1317"> </a>
<a name="ln1318">static status_t</a>
<a name="ln1319">overlay_access(fs_volume *volume, fs_vnode *vnode, int mode)</a>
<a name="ln1320">{</a>
<a name="ln1321">	OVERLAY_CALL(access, mode)</a>
<a name="ln1322">}</a>
<a name="ln1323"> </a>
<a name="ln1324"> </a>
<a name="ln1325">static status_t</a>
<a name="ln1326">overlay_read_stat(fs_volume *volume, fs_vnode *vnode, struct stat *stat)</a>
<a name="ln1327">{</a>
<a name="ln1328">	OVERLAY_CALL(read_stat, stat)</a>
<a name="ln1329">}</a>
<a name="ln1330"> </a>
<a name="ln1331"> </a>
<a name="ln1332">static status_t</a>
<a name="ln1333">overlay_write_stat(fs_volume *volume, fs_vnode *vnode, const struct stat *stat,</a>
<a name="ln1334">	uint32 statMask)</a>
<a name="ln1335">{</a>
<a name="ln1336">	OVERLAY_CALL(write_stat, stat, statMask)</a>
<a name="ln1337">}</a>
<a name="ln1338"> </a>
<a name="ln1339"> </a>
<a name="ln1340">static status_t</a>
<a name="ln1341">overlay_create(fs_volume *volume, fs_vnode *vnode, const char *name,</a>
<a name="ln1342">	int openMode, int perms, void **cookie, ino_t *newVnodeID)</a>
<a name="ln1343">{</a>
<a name="ln1344">	OVERLAY_CALL(create, name, openMode, perms, cookie, newVnodeID)</a>
<a name="ln1345">}</a>
<a name="ln1346"> </a>
<a name="ln1347"> </a>
<a name="ln1348">static status_t</a>
<a name="ln1349">overlay_open(fs_volume *volume, fs_vnode *vnode, int openMode, void **cookie)</a>
<a name="ln1350">{</a>
<a name="ln1351">	OVERLAY_CALL(open, openMode, cookie)</a>
<a name="ln1352">}</a>
<a name="ln1353"> </a>
<a name="ln1354"> </a>
<a name="ln1355">static status_t</a>
<a name="ln1356">overlay_close(fs_volume *volume, fs_vnode *vnode, void *cookie)</a>
<a name="ln1357">{</a>
<a name="ln1358">	OVERLAY_CALL(close, cookie)</a>
<a name="ln1359">}</a>
<a name="ln1360"> </a>
<a name="ln1361"> </a>
<a name="ln1362">static status_t</a>
<a name="ln1363">overlay_free_cookie(fs_volume *volume, fs_vnode *vnode, void *cookie)</a>
<a name="ln1364">{</a>
<a name="ln1365">	OVERLAY_CALL(free_cookie, cookie)</a>
<a name="ln1366">}</a>
<a name="ln1367"> </a>
<a name="ln1368"> </a>
<a name="ln1369">static status_t</a>
<a name="ln1370">overlay_read(fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos,</a>
<a name="ln1371">	void *buffer, size_t *length)</a>
<a name="ln1372">{</a>
<a name="ln1373">	OVERLAY_CALL(read, cookie, pos, buffer, length)</a>
<a name="ln1374">}</a>
<a name="ln1375"> </a>
<a name="ln1376"> </a>
<a name="ln1377">static status_t</a>
<a name="ln1378">overlay_write(fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos,</a>
<a name="ln1379">	const void *buffer, size_t *length)</a>
<a name="ln1380">{</a>
<a name="ln1381">	OVERLAY_CALL(write, cookie, pos, buffer, length)</a>
<a name="ln1382">}</a>
<a name="ln1383"> </a>
<a name="ln1384"> </a>
<a name="ln1385">static status_t</a>
<a name="ln1386">overlay_create_dir(fs_volume *volume, fs_vnode *vnode, const char *name,</a>
<a name="ln1387">	int perms)</a>
<a name="ln1388">{</a>
<a name="ln1389">	OVERLAY_CALL(create_dir, name, perms)</a>
<a name="ln1390">}</a>
<a name="ln1391"> </a>
<a name="ln1392"> </a>
<a name="ln1393">static status_t</a>
<a name="ln1394">overlay_remove_dir(fs_volume *volume, fs_vnode *vnode, const char *name)</a>
<a name="ln1395">{</a>
<a name="ln1396">	OVERLAY_CALL(remove_dir, name)</a>
<a name="ln1397">}</a>
<a name="ln1398"> </a>
<a name="ln1399"> </a>
<a name="ln1400">static status_t</a>
<a name="ln1401">overlay_open_dir(fs_volume *volume, fs_vnode *vnode, void **cookie)</a>
<a name="ln1402">{</a>
<a name="ln1403">	OVERLAY_CALL(open_dir, cookie)</a>
<a name="ln1404">}</a>
<a name="ln1405"> </a>
<a name="ln1406"> </a>
<a name="ln1407">static status_t</a>
<a name="ln1408">overlay_close_dir(fs_volume *volume, fs_vnode *vnode, void *cookie)</a>
<a name="ln1409">{</a>
<a name="ln1410">	OVERLAY_CALL(close_dir, cookie)</a>
<a name="ln1411">}</a>
<a name="ln1412"> </a>
<a name="ln1413"> </a>
<a name="ln1414">static status_t</a>
<a name="ln1415">overlay_free_dir_cookie(fs_volume *volume, fs_vnode *vnode, void *cookie)</a>
<a name="ln1416">{</a>
<a name="ln1417">	OVERLAY_CALL(free_dir_cookie, cookie)</a>
<a name="ln1418">}</a>
<a name="ln1419"> </a>
<a name="ln1420"> </a>
<a name="ln1421">static status_t</a>
<a name="ln1422">overlay_read_dir(fs_volume *volume, fs_vnode *vnode, void *cookie,</a>
<a name="ln1423">	struct dirent *buffer, size_t bufferSize, uint32 *num)</a>
<a name="ln1424">{</a>
<a name="ln1425">	TRACE(&quot;relaying op: read_dir\n&quot;);</a>
<a name="ln1426">	OverlayInode *node = (OverlayInode *)vnode-&gt;private_node;</a>
<a name="ln1427">	fs_vnode *superVnode = node-&gt;SuperVnode();</a>
<a name="ln1428">	if (superVnode-&gt;ops-&gt;read_dir != NULL) {</a>
<a name="ln1429">		status_t result = superVnode-&gt;ops-&gt;read_dir(volume-&gt;super_volume,</a>
<a name="ln1430">			superVnode, cookie, buffer, bufferSize, num);</a>
<a name="ln1431"> </a>
<a name="ln1432">		// TODO: handle multiple records</a>
<a name="ln1433">		if (result == B_OK &amp;&amp; *num == 1 &amp;&amp; strcmp(buffer-&gt;d_name,</a>
<a name="ln1434">			ATTRIBUTE_OVERLAY_ATTRIBUTE_DIR_NAME) == 0) {</a>
<a name="ln1435">			// skip over the attribute directory</a>
<a name="ln1436">			return superVnode-&gt;ops-&gt;read_dir(volume-&gt;super_volume, superVnode,</a>
<a name="ln1437">				cookie, buffer, bufferSize, num);</a>
<a name="ln1438">		}</a>
<a name="ln1439"> </a>
<a name="ln1440">		return result;</a>
<a name="ln1441">	}</a>
<a name="ln1442"> </a>
<a name="ln1443">	return B_UNSUPPORTED;</a>
<a name="ln1444">}</a>
<a name="ln1445"> </a>
<a name="ln1446"> </a>
<a name="ln1447">static status_t</a>
<a name="ln1448">overlay_rewind_dir(fs_volume *volume, fs_vnode *vnode, void *cookie)</a>
<a name="ln1449">{</a>
<a name="ln1450">	OVERLAY_CALL(rewind_dir, cookie)</a>
<a name="ln1451">}</a>
<a name="ln1452"> </a>
<a name="ln1453"> </a>
<a name="ln1454">static status_t</a>
<a name="ln1455">overlay_open_attr_dir(fs_volume *volume, fs_vnode *vnode, void **cookie)</a>
<a name="ln1456">{</a>
<a name="ln1457">	OverlayInode *node = (OverlayInode *)vnode-&gt;private_node;</a>
<a name="ln1458">	AttributeFile *attributeFile = NULL;</a>
<a name="ln1459">	status_t result = node-&gt;GetAttributeFile(&amp;attributeFile);</a>
<a name="ln1460">	if (result != B_OK)</a>
<a name="ln1461">		return result;</a>
<a name="ln1462"> </a>
<a name="ln1463">	attribute_dir_cookie *dirCookie = (attribute_dir_cookie *)malloc(</a>
<a name="ln1464">		sizeof(attribute_dir_cookie));</a>
<a name="ln1465">	if (dirCookie == NULL)</a>
<a name="ln1466">		return B_NO_MEMORY;</a>
<a name="ln1467"> </a>
<a name="ln1468">	dirCookie-&gt;file = attributeFile;</a>
<a name="ln1469">	dirCookie-&gt;index = 0;</a>
<a name="ln1470">	*cookie = dirCookie;</a>
<a name="ln1471">	return B_OK;</a>
<a name="ln1472">}</a>
<a name="ln1473"> </a>
<a name="ln1474"> </a>
<a name="ln1475">static status_t</a>
<a name="ln1476">overlay_close_attr_dir(fs_volume *volume, fs_vnode *vnode, void *cookie)</a>
<a name="ln1477">{</a>
<a name="ln1478">	return B_OK;</a>
<a name="ln1479">}</a>
<a name="ln1480"> </a>
<a name="ln1481"> </a>
<a name="ln1482">static status_t</a>
<a name="ln1483">overlay_free_attr_dir_cookie(fs_volume *volume, fs_vnode *vnode, void *cookie)</a>
<a name="ln1484">{</a>
<a name="ln1485">	free(cookie);</a>
<a name="ln1486">	return B_OK;</a>
<a name="ln1487">}</a>
<a name="ln1488"> </a>
<a name="ln1489"> </a>
<a name="ln1490">static status_t</a>
<a name="ln1491">overlay_read_attr_dir(fs_volume *volume, fs_vnode *vnode, void *cookie,</a>
<a name="ln1492">	struct dirent *buffer, size_t bufferSize, uint32 *num)</a>
<a name="ln1493">{</a>
<a name="ln1494">	attribute_dir_cookie *dirCookie = (attribute_dir_cookie *)cookie;</a>
<a name="ln1495">	return dirCookie-&gt;file-&gt;ReadAttributeDir(buffer, bufferSize, num,</a>
<a name="ln1496">		&amp;dirCookie-&gt;index);</a>
<a name="ln1497">}</a>
<a name="ln1498"> </a>
<a name="ln1499"> </a>
<a name="ln1500">static status_t</a>
<a name="ln1501">overlay_rewind_attr_dir(fs_volume *volume, fs_vnode *vnode, void *cookie)</a>
<a name="ln1502">{</a>
<a name="ln1503">	attribute_dir_cookie *dirCookie = (attribute_dir_cookie *)cookie;</a>
<a name="ln1504">	dirCookie-&gt;index = 0;</a>
<a name="ln1505">	return B_OK;</a>
<a name="ln1506">}</a>
<a name="ln1507"> </a>
<a name="ln1508"> </a>
<a name="ln1509">static status_t</a>
<a name="ln1510">overlay_create_attr(fs_volume *volume, fs_vnode *vnode, const char *name,</a>
<a name="ln1511">	uint32 type, int openMode, void **cookie)</a>
<a name="ln1512">{</a>
<a name="ln1513">	OverlayInode *node = (OverlayInode *)vnode-&gt;private_node;</a>
<a name="ln1514">	AttributeFile *attributeFile = NULL;</a>
<a name="ln1515">	status_t result = node-&gt;GetAttributeFile(&amp;attributeFile);</a>
<a name="ln1516">	if (result != B_OK)</a>
<a name="ln1517">		return result;</a>
<a name="ln1518"> </a>
<a name="ln1519">	return attributeFile-&gt;CreateAttribute(name, type, openMode,</a>
<a name="ln1520">		(AttributeEntry **)cookie);</a>
<a name="ln1521">}</a>
<a name="ln1522"> </a>
<a name="ln1523"> </a>
<a name="ln1524">static status_t</a>
<a name="ln1525">overlay_open_attr(fs_volume *volume, fs_vnode *vnode, const char *name,</a>
<a name="ln1526">	int openMode, void **cookie)</a>
<a name="ln1527">{</a>
<a name="ln1528">	OverlayInode *node = (OverlayInode *)vnode-&gt;private_node;</a>
<a name="ln1529">	AttributeFile *attributeFile = NULL;</a>
<a name="ln1530">	status_t result = node-&gt;GetAttributeFile(&amp;attributeFile);</a>
<a name="ln1531">	if (result != B_OK)</a>
<a name="ln1532">		return result;</a>
<a name="ln1533"> </a>
<a name="ln1534">	return attributeFile-&gt;OpenAttribute(name, openMode,</a>
<a name="ln1535">		(AttributeEntry **)cookie);</a>
<a name="ln1536">}</a>
<a name="ln1537"> </a>
<a name="ln1538"> </a>
<a name="ln1539">static status_t</a>
<a name="ln1540">overlay_close_attr(fs_volume *volume, fs_vnode *vnode, void *cookie)</a>
<a name="ln1541">{</a>
<a name="ln1542">	return B_OK;</a>
<a name="ln1543">}</a>
<a name="ln1544"> </a>
<a name="ln1545"> </a>
<a name="ln1546">static status_t</a>
<a name="ln1547">overlay_free_attr_cookie(fs_volume *volume, fs_vnode *vnode, void *cookie)</a>
<a name="ln1548">{</a>
<a name="ln1549">	return B_OK;</a>
<a name="ln1550">}</a>
<a name="ln1551"> </a>
<a name="ln1552"> </a>
<a name="ln1553">static status_t</a>
<a name="ln1554">overlay_read_attr(fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos,</a>
<a name="ln1555">	void *buffer, size_t *length)</a>
<a name="ln1556">{</a>
<a name="ln1557">	return ((AttributeEntry *)cookie)-&gt;Read(pos, buffer, length);</a>
<a name="ln1558">}</a>
<a name="ln1559"> </a>
<a name="ln1560"> </a>
<a name="ln1561">static status_t</a>
<a name="ln1562">overlay_write_attr(fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos,</a>
<a name="ln1563">	const void *buffer, size_t *length)</a>
<a name="ln1564">{</a>
<a name="ln1565">	return ((AttributeEntry *)cookie)-&gt;Write(pos, buffer, length);</a>
<a name="ln1566">}</a>
<a name="ln1567"> </a>
<a name="ln1568"> </a>
<a name="ln1569">static status_t</a>
<a name="ln1570">overlay_read_attr_stat(fs_volume *volume, fs_vnode *vnode, void *cookie,</a>
<a name="ln1571">	struct stat *stat)</a>
<a name="ln1572">{</a>
<a name="ln1573">	return ((AttributeEntry *)cookie)-&gt;ReadStat(stat);</a>
<a name="ln1574">}</a>
<a name="ln1575"> </a>
<a name="ln1576"> </a>
<a name="ln1577">static status_t</a>
<a name="ln1578">overlay_write_attr_stat(fs_volume *volume, fs_vnode *vnode, void *cookie,</a>
<a name="ln1579">	const struct stat *stat, int statMask)</a>
<a name="ln1580">{</a>
<a name="ln1581">	return ((AttributeEntry *)cookie)-&gt;WriteStat(stat, statMask);</a>
<a name="ln1582">}</a>
<a name="ln1583"> </a>
<a name="ln1584"> </a>
<a name="ln1585">static status_t</a>
<a name="ln1586">overlay_rename_attr(fs_volume *volume, fs_vnode *vnode,</a>
<a name="ln1587">	const char *fromName, fs_vnode *toVnode, const char *toName)</a>
<a name="ln1588">{</a>
<a name="ln1589">	OverlayInode *node = (OverlayInode *)vnode-&gt;private_node;</a>
<a name="ln1590">	AttributeFile *attributeFile = NULL;</a>
<a name="ln1591">	status_t result = node-&gt;GetAttributeFile(&amp;attributeFile);</a>
<a name="ln1592">	if (result != B_OK)</a>
<a name="ln1593">		return B_OK;</a>
<a name="ln1594"> </a>
<a name="ln1595">	AttributeFile *toAttributeFile = attributeFile;</a>
<a name="ln1596">	if (vnode-&gt;private_node != toVnode-&gt;private_node) {</a>
<a name="ln1597">		OverlayInode *toNode = (OverlayInode *)toVnode-&gt;private_node;</a>
<a name="ln1598">		result = toNode-&gt;GetAttributeFile(&amp;toAttributeFile);</a>
<a name="ln1599">		if (result != B_OK)</a>
<a name="ln1600">			return result;</a>
<a name="ln1601">	}</a>
<a name="ln1602"> </a>
<a name="ln1603">	AttributeEntry *entry = NULL;</a>
<a name="ln1604">	result = attributeFile-&gt;RemoveAttribute(fromName, &amp;entry);</a>
<a name="ln1605">	if (result != B_OK)</a>
<a name="ln1606">		return result;</a>
<a name="ln1607"> </a>
<a name="ln1608">	result = entry-&gt;SetName(toName);</a>
<a name="ln1609">	if (result != B_OK) {</a>
<a name="ln1610">		if (attributeFile-&gt;AddAttribute(entry) != B_OK)</a>
<a name="ln1611">			delete entry;</a>
<a name="ln1612">		return result;</a>
<a name="ln1613">	}</a>
<a name="ln1614"> </a>
<a name="ln1615">	result = toAttributeFile-&gt;AddAttribute(entry);</a>
<a name="ln1616">	if (result != B_OK) {</a>
<a name="ln1617">		if (entry-&gt;SetName(fromName) != B_OK</a>
<a name="ln1618">			|| attributeFile-&gt;AddAttribute(entry) != B_OK)</a>
<a name="ln1619">			delete entry;</a>
<a name="ln1620">		return result;</a>
<a name="ln1621">	}</a>
<a name="ln1622"> </a>
<a name="ln1623">	return B_OK;</a>
<a name="ln1624">}</a>
<a name="ln1625"> </a>
<a name="ln1626"> </a>
<a name="ln1627">static status_t</a>
<a name="ln1628">overlay_remove_attr(fs_volume *volume, fs_vnode *vnode, const char *name)</a>
<a name="ln1629">{</a>
<a name="ln1630">	OverlayInode *node = (OverlayInode *)vnode-&gt;private_node;</a>
<a name="ln1631">	AttributeFile *attributeFile = NULL;</a>
<a name="ln1632">	status_t result = node-&gt;GetAttributeFile(&amp;attributeFile);</a>
<a name="ln1633">	if (result != B_OK)</a>
<a name="ln1634">		return result;</a>
<a name="ln1635"> </a>
<a name="ln1636">	return attributeFile-&gt;RemoveAttribute(name, NULL);</a>
<a name="ln1637">}</a>
<a name="ln1638"> </a>
<a name="ln1639"> </a>
<a name="ln1640">static status_t</a>
<a name="ln1641">overlay_create_special_node(fs_volume *volume, fs_vnode *vnode,</a>
<a name="ln1642">	const char *name, fs_vnode *subVnode, mode_t mode, uint32 flags,</a>
<a name="ln1643">	fs_vnode *_superVnode, ino_t *nodeID)</a>
<a name="ln1644">{</a>
<a name="ln1645">	OVERLAY_CALL(create_special_node, name, subVnode, mode, flags, _superVnode,</a>
<a name="ln1646">		nodeID)</a>
<a name="ln1647">}</a>
<a name="ln1648"> </a>
<a name="ln1649"> </a>
<a name="ln1650">static fs_vnode_ops sOverlayVnodeOps = {</a>
<a name="ln1651">	&amp;overlay_lookup,</a>
<a name="ln1652">	&amp;overlay_get_vnode_name,</a>
<a name="ln1653"> </a>
<a name="ln1654">	&amp;overlay_put_vnode,</a>
<a name="ln1655">	&amp;overlay_remove_vnode,</a>
<a name="ln1656"> </a>
<a name="ln1657">	&amp;overlay_can_page,</a>
<a name="ln1658">	&amp;overlay_read_pages,</a>
<a name="ln1659">	&amp;overlay_write_pages,</a>
<a name="ln1660"> </a>
<a name="ln1661">	&amp;overlay_io,</a>
<a name="ln1662">	&amp;overlay_cancel_io,</a>
<a name="ln1663"> </a>
<a name="ln1664">	&amp;overlay_get_file_map,</a>
<a name="ln1665"> </a>
<a name="ln1666">	/* common */</a>
<a name="ln1667">	&amp;overlay_ioctl,</a>
<a name="ln1668">	&amp;overlay_set_flags,</a>
<a name="ln1669">	&amp;overlay_select,</a>
<a name="ln1670">	&amp;overlay_deselect,</a>
<a name="ln1671">	&amp;overlay_fsync,</a>
<a name="ln1672"> </a>
<a name="ln1673">	&amp;overlay_read_symlink,</a>
<a name="ln1674">	&amp;overlay_create_symlink,</a>
<a name="ln1675">	&amp;overlay_link,</a>
<a name="ln1676">	&amp;overlay_unlink,</a>
<a name="ln1677">	&amp;overlay_rename,</a>
<a name="ln1678"> </a>
<a name="ln1679">	&amp;overlay_access,</a>
<a name="ln1680">	&amp;overlay_read_stat,</a>
<a name="ln1681">	&amp;overlay_write_stat,</a>
<a name="ln1682">	NULL,	// fs_preallocate</a>
<a name="ln1683"> </a>
<a name="ln1684">	/* file */</a>
<a name="ln1685">	&amp;overlay_create,</a>
<a name="ln1686">	&amp;overlay_open,</a>
<a name="ln1687">	&amp;overlay_close,</a>
<a name="ln1688">	&amp;overlay_free_cookie,</a>
<a name="ln1689">	&amp;overlay_read,</a>
<a name="ln1690">	&amp;overlay_write,</a>
<a name="ln1691"> </a>
<a name="ln1692">	/* directory */</a>
<a name="ln1693">	&amp;overlay_create_dir,</a>
<a name="ln1694">	&amp;overlay_remove_dir,</a>
<a name="ln1695">	&amp;overlay_open_dir,</a>
<a name="ln1696">	&amp;overlay_close_dir,</a>
<a name="ln1697">	&amp;overlay_free_dir_cookie,</a>
<a name="ln1698">	&amp;overlay_read_dir,</a>
<a name="ln1699">	&amp;overlay_rewind_dir,</a>
<a name="ln1700"> </a>
<a name="ln1701">	/* attribute directory operations */</a>
<a name="ln1702">	&amp;overlay_open_attr_dir,</a>
<a name="ln1703">	&amp;overlay_close_attr_dir,</a>
<a name="ln1704">	&amp;overlay_free_attr_dir_cookie,</a>
<a name="ln1705">	&amp;overlay_read_attr_dir,</a>
<a name="ln1706">	&amp;overlay_rewind_attr_dir,</a>
<a name="ln1707"> </a>
<a name="ln1708">	/* attribute operations */</a>
<a name="ln1709">	&amp;overlay_create_attr,</a>
<a name="ln1710">	&amp;overlay_open_attr,</a>
<a name="ln1711">	&amp;overlay_close_attr,</a>
<a name="ln1712">	&amp;overlay_free_attr_cookie,</a>
<a name="ln1713">	&amp;overlay_read_attr,</a>
<a name="ln1714">	&amp;overlay_write_attr,</a>
<a name="ln1715"> </a>
<a name="ln1716">	&amp;overlay_read_attr_stat,</a>
<a name="ln1717">	&amp;overlay_write_attr_stat,</a>
<a name="ln1718">	&amp;overlay_rename_attr,</a>
<a name="ln1719">	&amp;overlay_remove_attr,</a>
<a name="ln1720"> </a>
<a name="ln1721">	/* support for node and FS layers */</a>
<a name="ln1722">	&amp;overlay_create_special_node,</a>
<a name="ln1723">	&amp;overlay_get_super_vnode</a>
<a name="ln1724">};</a>
<a name="ln1725"> </a>
<a name="ln1726"> </a>
<a name="ln1727">//	#pragma mark - volume ops</a>
<a name="ln1728"> </a>
<a name="ln1729"> </a>
<a name="ln1730">static status_t</a>
<a name="ln1731">overlay_unmount(fs_volume *volume)</a>
<a name="ln1732">{</a>
<a name="ln1733">	TRACE_VOLUME(&quot;relaying volume op: unmount\n&quot;);</a>
<a name="ln1734">	if (volume-&gt;super_volume != NULL</a>
<a name="ln1735">		&amp;&amp; volume-&gt;super_volume-&gt;ops != NULL</a>
<a name="ln1736">		&amp;&amp; volume-&gt;super_volume-&gt;ops-&gt;unmount != NULL)</a>
<a name="ln1737">		volume-&gt;super_volume-&gt;ops-&gt;unmount(volume-&gt;super_volume);</a>
<a name="ln1738"> </a>
<a name="ln1739">	delete (OverlayVolume *)volume-&gt;private_volume;</a>
<a name="ln1740">	return B_OK;</a>
<a name="ln1741">}</a>
<a name="ln1742"> </a>
<a name="ln1743"> </a>
<a name="ln1744">static status_t</a>
<a name="ln1745">overlay_read_fs_info(fs_volume *volume, struct fs_info *info)</a>
<a name="ln1746">{</a>
<a name="ln1747">	TRACE_VOLUME(&quot;relaying volume op: read_fs_info\n&quot;);</a>
<a name="ln1748">	status_t result = B_UNSUPPORTED;</a>
<a name="ln1749">	if (volume-&gt;super_volume-&gt;ops-&gt;read_fs_info != NULL) {</a>
<a name="ln1750">		result = volume-&gt;super_volume-&gt;ops-&gt;read_fs_info(volume-&gt;super_volume,</a>
<a name="ln1751">			info);</a>
<a name="ln1752">		if (result != B_OK)</a>
<a name="ln1753">			return result;</a>
<a name="ln1754"> </a>
<a name="ln1755">		info-&gt;flags &amp;= B_FS_SUPPORTS_MONITOR_CHILDREN;</a>
<a name="ln1756">		info-&gt;flags |= B_FS_HAS_MIME | B_FS_HAS_ATTR /*| B_FS_HAS_QUERY*/;</a>
<a name="ln1757">		return B_OK;</a>
<a name="ln1758">	}</a>
<a name="ln1759"> </a>
<a name="ln1760">	return B_UNSUPPORTED;</a>
<a name="ln1761">}</a>
<a name="ln1762"> </a>
<a name="ln1763"> </a>
<a name="ln1764">static status_t</a>
<a name="ln1765">overlay_write_fs_info(fs_volume *volume, const struct fs_info *info,</a>
<a name="ln1766">	uint32 mask)</a>
<a name="ln1767">{</a>
<a name="ln1768">	OVERLAY_VOLUME_CALL(write_fs_info, info, mask)</a>
<a name="ln1769">	return B_UNSUPPORTED;</a>
<a name="ln1770">}</a>
<a name="ln1771"> </a>
<a name="ln1772"> </a>
<a name="ln1773">static status_t</a>
<a name="ln1774">overlay_sync(fs_volume *volume)</a>
<a name="ln1775">{</a>
<a name="ln1776">	TRACE_VOLUME(&quot;relaying volume op: sync\n&quot;);</a>
<a name="ln1777">	if (volume-&gt;super_volume-&gt;ops-&gt;sync != NULL)</a>
<a name="ln1778">		return volume-&gt;super_volume-&gt;ops-&gt;sync(volume-&gt;super_volume);</a>
<a name="ln1779">	return B_UNSUPPORTED;</a>
<a name="ln1780">}</a>
<a name="ln1781"> </a>
<a name="ln1782"> </a>
<a name="ln1783">static status_t</a>
<a name="ln1784">overlay_get_vnode(fs_volume *volume, ino_t id, fs_vnode *vnode, int *_type,</a>
<a name="ln1785">	uint32 *_flags, bool reenter)</a>
<a name="ln1786">{</a>
<a name="ln1787">	TRACE_VOLUME(&quot;relaying volume op: get_vnode\n&quot;);</a>
<a name="ln1788">	if (volume-&gt;super_volume-&gt;ops-&gt;get_vnode != NULL) {</a>
<a name="ln1789">		status_t status = volume-&gt;super_volume-&gt;ops-&gt;get_vnode(</a>
<a name="ln1790">			volume-&gt;super_volume, id, vnode, _type, _flags, reenter);</a>
<a name="ln1791">		if (status != B_OK)</a>
<a name="ln1792">			return status;</a>
<a name="ln1793"> </a>
<a name="ln1794">		OverlayInode *node = new(std::nothrow) OverlayInode(</a>
<a name="ln1795">			(OverlayVolume *)volume-&gt;private_volume, vnode, id);</a>
<a name="ln1796">		if (node == NULL) {</a>
<a name="ln1797">			vnode-&gt;ops-&gt;put_vnode(volume-&gt;super_volume, vnode, reenter);</a>
<a name="ln1798">			return B_NO_MEMORY;</a>
<a name="ln1799">		}</a>
<a name="ln1800"> </a>
<a name="ln1801">		status = node-&gt;InitCheck();</a>
<a name="ln1802">		if (status != B_OK) {</a>
<a name="ln1803">			vnode-&gt;ops-&gt;put_vnode(volume-&gt;super_volume, vnode, reenter);</a>
<a name="ln1804">			delete node;</a>
<a name="ln1805">			return status;</a>
<a name="ln1806">		}</a>
<a name="ln1807"> </a>
<a name="ln1808">		vnode-&gt;private_node = node;</a>
<a name="ln1809">		vnode-&gt;ops = &amp;sOverlayVnodeOps;</a>
<a name="ln1810">		return B_OK;</a>
<a name="ln1811">	}</a>
<a name="ln1812"> </a>
<a name="ln1813">	return B_UNSUPPORTED;</a>
<a name="ln1814">}</a>
<a name="ln1815"> </a>
<a name="ln1816"> </a>
<a name="ln1817">static status_t</a>
<a name="ln1818">overlay_open_index_dir(fs_volume *volume, void **cookie)</a>
<a name="ln1819">{</a>
<a name="ln1820">	OVERLAY_VOLUME_CALL(open_index_dir, cookie)</a>
<a name="ln1821">	return B_UNSUPPORTED;</a>
<a name="ln1822">}</a>
<a name="ln1823"> </a>
<a name="ln1824"> </a>
<a name="ln1825">static status_t</a>
<a name="ln1826">overlay_close_index_dir(fs_volume *volume, void *cookie)</a>
<a name="ln1827">{</a>
<a name="ln1828">	OVERLAY_VOLUME_CALL(close_index_dir, cookie)</a>
<a name="ln1829">	return B_UNSUPPORTED;</a>
<a name="ln1830">}</a>
<a name="ln1831"> </a>
<a name="ln1832"> </a>
<a name="ln1833">static status_t</a>
<a name="ln1834">overlay_free_index_dir_cookie(fs_volume *volume, void *cookie)</a>
<a name="ln1835">{</a>
<a name="ln1836">	OVERLAY_VOLUME_CALL(free_index_dir_cookie, cookie)</a>
<a name="ln1837">	return B_UNSUPPORTED;</a>
<a name="ln1838">}</a>
<a name="ln1839"> </a>
<a name="ln1840"> </a>
<a name="ln1841">static status_t</a>
<a name="ln1842">overlay_read_index_dir(fs_volume *volume, void *cookie, struct dirent *buffer,</a>
<a name="ln1843">	size_t bufferSize, uint32 *_num)</a>
<a name="ln1844">{</a>
<a name="ln1845">	OVERLAY_VOLUME_CALL(read_index_dir, cookie, buffer, bufferSize, _num)</a>
<a name="ln1846">	return B_UNSUPPORTED;</a>
<a name="ln1847">}</a>
<a name="ln1848"> </a>
<a name="ln1849"> </a>
<a name="ln1850">static status_t</a>
<a name="ln1851">overlay_rewind_index_dir(fs_volume *volume, void *cookie)</a>
<a name="ln1852">{</a>
<a name="ln1853">	OVERLAY_VOLUME_CALL(rewind_index_dir, cookie)</a>
<a name="ln1854">	return B_UNSUPPORTED;</a>
<a name="ln1855">}</a>
<a name="ln1856"> </a>
<a name="ln1857"> </a>
<a name="ln1858">static status_t</a>
<a name="ln1859">overlay_create_index(fs_volume *volume, const char *name, uint32 type,</a>
<a name="ln1860">	uint32 flags)</a>
<a name="ln1861">{</a>
<a name="ln1862">	OVERLAY_VOLUME_CALL(create_index, name, type, flags)</a>
<a name="ln1863">	return B_UNSUPPORTED;</a>
<a name="ln1864">}</a>
<a name="ln1865"> </a>
<a name="ln1866"> </a>
<a name="ln1867">static status_t</a>
<a name="ln1868">overlay_remove_index(fs_volume *volume, const char *name)</a>
<a name="ln1869">{</a>
<a name="ln1870">	OVERLAY_VOLUME_CALL(remove_index, name)</a>
<a name="ln1871">	return B_UNSUPPORTED;</a>
<a name="ln1872">}</a>
<a name="ln1873"> </a>
<a name="ln1874"> </a>
<a name="ln1875">static status_t</a>
<a name="ln1876">overlay_read_index_stat(fs_volume *volume, const char *name, struct stat *stat)</a>
<a name="ln1877">{</a>
<a name="ln1878">	OVERLAY_VOLUME_CALL(read_index_stat, name, stat)</a>
<a name="ln1879">	return B_UNSUPPORTED;</a>
<a name="ln1880">}</a>
<a name="ln1881"> </a>
<a name="ln1882"> </a>
<a name="ln1883">static status_t</a>
<a name="ln1884">overlay_open_query(fs_volume *volume, const char *query, uint32 flags,</a>
<a name="ln1885">	port_id port, uint32 token, void **_cookie)</a>
<a name="ln1886">{</a>
<a name="ln1887">	OVERLAY_VOLUME_CALL(open_query, query, flags, port, token, _cookie)</a>
<a name="ln1888">	return B_UNSUPPORTED;</a>
<a name="ln1889">}</a>
<a name="ln1890"> </a>
<a name="ln1891"> </a>
<a name="ln1892">static status_t</a>
<a name="ln1893">overlay_close_query(fs_volume *volume, void *cookie)</a>
<a name="ln1894">{</a>
<a name="ln1895">	OVERLAY_VOLUME_CALL(close_query, cookie)</a>
<a name="ln1896">	return B_UNSUPPORTED;</a>
<a name="ln1897">}</a>
<a name="ln1898"> </a>
<a name="ln1899"> </a>
<a name="ln1900">static status_t</a>
<a name="ln1901">overlay_free_query_cookie(fs_volume *volume, void *cookie)</a>
<a name="ln1902">{</a>
<a name="ln1903">	OVERLAY_VOLUME_CALL(free_query_cookie, cookie)</a>
<a name="ln1904">	return B_UNSUPPORTED;</a>
<a name="ln1905">}</a>
<a name="ln1906"> </a>
<a name="ln1907"> </a>
<a name="ln1908">static status_t</a>
<a name="ln1909">overlay_read_query(fs_volume *volume, void *cookie, struct dirent *buffer,</a>
<a name="ln1910">	size_t bufferSize, uint32 *_num)</a>
<a name="ln1911">{</a>
<a name="ln1912">	OVERLAY_VOLUME_CALL(read_query, cookie, buffer, bufferSize, _num)</a>
<a name="ln1913">	return B_UNSUPPORTED;</a>
<a name="ln1914">}</a>
<a name="ln1915"> </a>
<a name="ln1916"> </a>
<a name="ln1917">static status_t</a>
<a name="ln1918">overlay_rewind_query(fs_volume *volume, void *cookie)</a>
<a name="ln1919">{</a>
<a name="ln1920">	OVERLAY_VOLUME_CALL(rewind_query, cookie)</a>
<a name="ln1921">	return B_UNSUPPORTED;</a>
<a name="ln1922">}</a>
<a name="ln1923"> </a>
<a name="ln1924"> </a>
<a name="ln1925">static status_t</a>
<a name="ln1926">overlay_all_layers_mounted(fs_volume *volume)</a>
<a name="ln1927">{</a>
<a name="ln1928">	return B_OK;</a>
<a name="ln1929">}</a>
<a name="ln1930"> </a>
<a name="ln1931"> </a>
<a name="ln1932">static status_t</a>
<a name="ln1933">overlay_create_sub_vnode(fs_volume *volume, ino_t id, fs_vnode *vnode)</a>
<a name="ln1934">{</a>
<a name="ln1935">	OverlayInode *node = new(std::nothrow) OverlayInode(</a>
<a name="ln1936">		(OverlayVolume *)volume-&gt;private_volume, vnode, id);</a>
<a name="ln1937">	if (node == NULL)</a>
<a name="ln1938">		return B_NO_MEMORY;</a>
<a name="ln1939"> </a>
<a name="ln1940">	status_t status = node-&gt;InitCheck();</a>
<a name="ln1941">	if (status != B_OK) {</a>
<a name="ln1942">		delete node;</a>
<a name="ln1943">		return status;</a>
<a name="ln1944">	}</a>
<a name="ln1945"> </a>
<a name="ln1946">	vnode-&gt;private_node = node;</a>
<a name="ln1947">	vnode-&gt;ops = &amp;sOverlayVnodeOps;</a>
<a name="ln1948">	return B_OK;</a>
<a name="ln1949">}</a>
<a name="ln1950"> </a>
<a name="ln1951"> </a>
<a name="ln1952">static status_t</a>
<a name="ln1953">overlay_delete_sub_vnode(fs_volume *volume, fs_vnode *vnode)</a>
<a name="ln1954">{</a>
<a name="ln1955">	delete (OverlayInode *)vnode-&gt;private_node;</a>
<a name="ln1956">	return B_OK;</a>
<a name="ln1957">}</a>
<a name="ln1958"> </a>
<a name="ln1959"> </a>
<a name="ln1960">static fs_volume_ops sOverlayVolumeOps = {</a>
<a name="ln1961">	&amp;overlay_unmount,</a>
<a name="ln1962"> </a>
<a name="ln1963">	&amp;overlay_read_fs_info,</a>
<a name="ln1964">	&amp;overlay_write_fs_info,</a>
<a name="ln1965">	&amp;overlay_sync,</a>
<a name="ln1966"> </a>
<a name="ln1967">	&amp;overlay_get_vnode,</a>
<a name="ln1968">	&amp;overlay_open_index_dir,</a>
<a name="ln1969">	&amp;overlay_close_index_dir,</a>
<a name="ln1970">	&amp;overlay_free_index_dir_cookie,</a>
<a name="ln1971">	&amp;overlay_read_index_dir,</a>
<a name="ln1972">	&amp;overlay_rewind_index_dir,</a>
<a name="ln1973"> </a>
<a name="ln1974">	&amp;overlay_create_index,</a>
<a name="ln1975">	&amp;overlay_remove_index,</a>
<a name="ln1976">	&amp;overlay_read_index_stat,</a>
<a name="ln1977"> </a>
<a name="ln1978">	&amp;overlay_open_query,</a>
<a name="ln1979">	&amp;overlay_close_query,</a>
<a name="ln1980">	&amp;overlay_free_query_cookie,</a>
<a name="ln1981">	&amp;overlay_read_query,</a>
<a name="ln1982">	&amp;overlay_rewind_query,</a>
<a name="ln1983"> </a>
<a name="ln1984">	&amp;overlay_all_layers_mounted,</a>
<a name="ln1985">	&amp;overlay_create_sub_vnode,</a>
<a name="ln1986">	&amp;overlay_delete_sub_vnode</a>
<a name="ln1987">};</a>
<a name="ln1988"> </a>
<a name="ln1989"> </a>
<a name="ln1990">//	#pragma mark - filesystem module</a>
<a name="ln1991"> </a>
<a name="ln1992"> </a>
<a name="ln1993">static status_t</a>
<a name="ln1994">overlay_mount(fs_volume *volume, const char *device, uint32 flags,</a>
<a name="ln1995">	const char *args, ino_t *rootID)</a>
<a name="ln1996">{</a>
<a name="ln1997">	TRACE_VOLUME(&quot;mounting attribute overlay\n&quot;);</a>
<a name="ln1998">	volume-&gt;private_volume = new(std::nothrow) OverlayVolume(volume);</a>
<a name="ln1999">	if (volume-&gt;private_volume == NULL)</a>
<a name="ln2000">		return B_NO_MEMORY;</a>
<a name="ln2001"> </a>
<a name="ln2002">	volume-&gt;ops = &amp;sOverlayVolumeOps;</a>
<a name="ln2003">	return B_OK;</a>
<a name="ln2004">}</a>
<a name="ln2005"> </a>
<a name="ln2006"> </a>
<a name="ln2007">static status_t</a>
<a name="ln2008">overlay_std_ops(int32 op, ...)</a>
<a name="ln2009">{</a>
<a name="ln2010">	switch (op) {</a>
<a name="ln2011">		case B_MODULE_INIT:</a>
<a name="ln2012">		case B_MODULE_UNINIT:</a>
<a name="ln2013">			return B_OK;</a>
<a name="ln2014">		default:</a>
<a name="ln2015">			return B_ERROR;</a>
<a name="ln2016">	}</a>
<a name="ln2017">}</a>
<a name="ln2018"> </a>
<a name="ln2019"> </a>
<a name="ln2020">static file_system_module_info sOverlayFileSystem = {</a>
<a name="ln2021">	{</a>
<a name="ln2022">		&quot;file_systems/attribute_overlay&quot; B_CURRENT_FS_API_VERSION,</a>
<a name="ln2023">		0,</a>
<a name="ln2024">		overlay_std_ops,</a>
<a name="ln2025">	},</a>
<a name="ln2026"> </a>
<a name="ln2027">	&quot;attribute_overlay&quot;,				// short_name</a>
<a name="ln2028">	&quot;Attribute Overlay File System&quot;,	// pretty_name</a>
<a name="ln2029">	0,									// DDM flags</a>
<a name="ln2030"> </a>
<a name="ln2031">	// scanning</a>
<a name="ln2032">	NULL, // identify_partition</a>
<a name="ln2033">	NULL, // scan_partition</a>
<a name="ln2034">	NULL, // free_identify_partition_cookie</a>
<a name="ln2035">	NULL, // free_partition_content_cookie</a>
<a name="ln2036"> </a>
<a name="ln2037">	// general operations</a>
<a name="ln2038">	&amp;overlay_mount,</a>
<a name="ln2039"> </a>
<a name="ln2040">	// capability querying</a>
<a name="ln2041">	NULL, // get_supported_operations</a>
<a name="ln2042"> </a>
<a name="ln2043">	NULL, // validate_resize</a>
<a name="ln2044">	NULL, // validate_move</a>
<a name="ln2045">	NULL, // validate_set_content_name</a>
<a name="ln2046">	NULL, // validate_set_content_parameters</a>
<a name="ln2047">	NULL, // validate_initialize</a>
<a name="ln2048"> </a>
<a name="ln2049">	// shadow partition modification</a>
<a name="ln2050">	NULL, // shadow_changed</a>
<a name="ln2051"> </a>
<a name="ln2052">	// writing</a>
<a name="ln2053">	NULL, // defragment</a>
<a name="ln2054">	NULL, // repair</a>
<a name="ln2055">	NULL, // resize</a>
<a name="ln2056">	NULL, // move</a>
<a name="ln2057">	NULL, // set_content_name</a>
<a name="ln2058">	NULL, // set_content_parameters</a>
<a name="ln2059">	NULL // initialize</a>
<a name="ln2060">};</a>
<a name="ln2061"> </a>
<a name="ln2062">}	// namespace attribute_overlay</a>
<a name="ln2063"> </a>
<a name="ln2064">using namespace attribute_overlay;</a>
<a name="ln2065"> </a>
<a name="ln2066">module_info *modules[] = {</a>
<a name="ln2067">	(module_info *)&amp;sOverlayFileSystem,</a>
<a name="ln2068">	NULL,</a>
<a name="ln2069">};</a>

</code></pre>
<div class="balloon" rel="520"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v641/" target="_blank">V641</a> The size of the allocated memory buffer is not a multiple of the element size.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
