
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>MailMessage.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2007-2015, Haiku Inc. All Rights Reserved.</a>
<a name="ln3"> * Copyright 2001-2004 Dr. Zoidberg Enterprises. All rights reserved.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Distributed under the terms of the MIT License.</a>
<a name="ln6"> */</a>
<a name="ln7"> </a>
<a name="ln8"> </a>
<a name="ln9">//! The main general purpose mail message class</a>
<a name="ln10"> </a>
<a name="ln11"> </a>
<a name="ln12">#include &lt;MailMessage.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &lt;ctype.h&gt;</a>
<a name="ln15">#include &lt;stdio.h&gt;</a>
<a name="ln16">#include &lt;stdlib.h&gt;</a>
<a name="ln17">#include &lt;string.h&gt;</a>
<a name="ln18">#include &lt;sys/utsname.h&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;parsedate.h&gt;</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;Directory.h&gt;</a>
<a name="ln23">#include &lt;E-mail.h&gt;</a>
<a name="ln24">#include &lt;Entry.h&gt;</a>
<a name="ln25">#include &lt;File.h&gt;</a>
<a name="ln26">#include &lt;FindDirectory.h&gt;</a>
<a name="ln27">#include &lt;List.h&gt;</a>
<a name="ln28">#include &lt;MailAttachment.h&gt;</a>
<a name="ln29">#include &lt;MailDaemon.h&gt;</a>
<a name="ln30">#include &lt;MailSettings.h&gt;</a>
<a name="ln31">#include &lt;Messenger.h&gt;</a>
<a name="ln32">#include &lt;netdb.h&gt;</a>
<a name="ln33">#include &lt;NodeInfo.h&gt;</a>
<a name="ln34">#include &lt;Path.h&gt;</a>
<a name="ln35">#include &lt;String.h&gt;</a>
<a name="ln36">#include &lt;StringList.h&gt;</a>
<a name="ln37"> </a>
<a name="ln38">#include &lt;MailPrivate.h&gt;</a>
<a name="ln39">#include &lt;mail_util.h&gt;</a>
<a name="ln40"> </a>
<a name="ln41"> </a>
<a name="ln42">using namespace BPrivate;</a>
<a name="ln43"> </a>
<a name="ln44"> </a>
<a name="ln45">//-------Change the following!----------------------</a>
<a name="ln46">#define mime_boundary &quot;----------Zoidberg-BeMail-temp--------&quot;</a>
<a name="ln47">#define mime_warning &quot;This is a multipart message in MIME format.&quot;</a>
<a name="ln48"> </a>
<a name="ln49"> </a>
<a name="ln50">BEmailMessage::BEmailMessage(BPositionIO* file, bool own, uint32 defaultCharSet)</a>
<a name="ln51">	:</a>
<a name="ln52">	BMailContainer(defaultCharSet),</a>
<a name="ln53">	fData(NULL),</a>
<a name="ln54">	fStatus(B_NO_ERROR),</a>
<a name="ln55">	fBCC(NULL),</a>
<a name="ln56">	fComponentCount(0),</a>
<a name="ln57">	fBody(NULL),</a>
<a name="ln58">	fTextBody(NULL)</a>
<a name="ln59">{</a>
<a name="ln60">	BMailSettings settings;</a>
<a name="ln61">	fAccountID = settings.DefaultOutboundAccount();</a>
<a name="ln62"> </a>
<a name="ln63">	if (own)</a>
<a name="ln64">		fData = file;</a>
<a name="ln65"> </a>
<a name="ln66">	if (file != NULL)</a>
<a name="ln67">		SetToRFC822(file, ~0L);</a>
<a name="ln68">}</a>
<a name="ln69"> </a>
<a name="ln70"> </a>
<a name="ln71">BEmailMessage::BEmailMessage(const entry_ref* ref, uint32 defaultCharSet)</a>
<a name="ln72">	:</a>
<a name="ln73">	BMailContainer(defaultCharSet),</a>
<a name="ln74">	fBCC(NULL),</a>
<a name="ln75">	fComponentCount(0),</a>
<a name="ln76">	fBody(NULL),</a>
<a name="ln77">	fTextBody(NULL)</a>
<a name="ln78">{</a>
<a name="ln79">	BMailSettings settings;</a>
<a name="ln80">	fAccountID = settings.DefaultOutboundAccount();</a>
<a name="ln81"> </a>
<a name="ln82">	fData = new BFile();</a>
<a name="ln83">	fStatus = static_cast&lt;BFile*&gt;(fData)-&gt;SetTo(ref, B_READ_ONLY);</a>
<a name="ln84"> </a>
<a name="ln85">	if (fStatus == B_OK)</a>
<a name="ln86">		SetToRFC822(fData, ~0L);</a>
<a name="ln87">}</a>
<a name="ln88"> </a>
<a name="ln89"> </a>
<a name="ln90">BEmailMessage::~BEmailMessage()</a>
<a name="ln91">{</a>
<a name="ln92">	free(fBCC);</a>
<a name="ln93"> </a>
<a name="ln94">	delete fBody;</a>
<a name="ln95">	delete fData;</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98"> </a>
<a name="ln99">status_t</a>
<a name="ln100">BEmailMessage::InitCheck() const</a>
<a name="ln101">{</a>
<a name="ln102">	return fStatus;</a>
<a name="ln103">}</a>
<a name="ln104"> </a>
<a name="ln105"> </a>
<a name="ln106">BEmailMessage*</a>
<a name="ln107">BEmailMessage::ReplyMessage(mail_reply_to_mode replyTo, bool accountFromMail,</a>
<a name="ln108">	const char* quoteStyle)</a>
<a name="ln109">{</a>
<a name="ln110">	BEmailMessage* reply = new BEmailMessage;</a>
<a name="ln111"> </a>
<a name="ln112">	// Set ReplyTo:</a>
<a name="ln113"> </a>
<a name="ln114">	if (replyTo == B_MAIL_REPLY_TO_ALL) {</a>
<a name="ln115">		reply-&gt;SetTo(From());</a>
<a name="ln116"> </a>
<a name="ln117">		BList list;</a>
<a name="ln118">		get_address_list(list, CC(), extract_address);</a>
<a name="ln119">		get_address_list(list, To(), extract_address);</a>
<a name="ln120"> </a>
<a name="ln121">		// Filter out the sender</a>
<a name="ln122">		BMailAccounts accounts;</a>
<a name="ln123">		BMailAccountSettings* account = accounts.AccountByID(Account());</a>
<a name="ln124">		BString sender;</a>
<a name="ln125">		if (account != NULL)</a>
<a name="ln126">			sender = account-&gt;ReturnAddress();</a>
<a name="ln127">		extract_address(sender);</a>
<a name="ln128"> </a>
<a name="ln129">		BString cc;</a>
<a name="ln130"> </a>
<a name="ln131">		for (int32 i = list.CountItems(); i-- &gt; 0;) {</a>
<a name="ln132">			char* address = (char*)list.RemoveItem((int32)0);</a>
<a name="ln133"> </a>
<a name="ln134">			// Add everything which is not the sender and not already in the</a>
<a name="ln135">			// list</a>
<a name="ln136">			if (sender.ICompare(address) &amp;&amp; cc.FindFirst(address) &lt; 0) {</a>
<a name="ln137">				if (cc.Length() &gt; 0)</a>
<a name="ln138">					cc &lt;&lt; &quot;, &quot;;</a>
<a name="ln139"> </a>
<a name="ln140">				cc &lt;&lt; address;</a>
<a name="ln141">			}</a>
<a name="ln142"> </a>
<a name="ln143">			free(address);</a>
<a name="ln144">		}</a>
<a name="ln145"> </a>
<a name="ln146">		if (cc.Length() &gt; 0)</a>
<a name="ln147">			reply-&gt;SetCC(cc.String());</a>
<a name="ln148">	} else if (replyTo == B_MAIL_REPLY_TO_SENDER || ReplyTo() == NULL)</a>
<a name="ln149">		reply-&gt;SetTo(From());</a>
<a name="ln150">	else</a>
<a name="ln151">		reply-&gt;SetTo(ReplyTo());</a>
<a name="ln152"> </a>
<a name="ln153">	// Set special &quot;In-Reply-To:&quot; header (used for threading)</a>
<a name="ln154">	const char* messageID = fBody ? fBody-&gt;HeaderField(&quot;Message-Id&quot;) : NULL;</a>
<a name="ln155">	if (messageID != NULL)</a>
<a name="ln156">		reply-&gt;SetHeaderField(&quot;In-Reply-To&quot;, messageID);</a>
<a name="ln157"> </a>
<a name="ln158">	// quote body text</a>
<a name="ln159">	reply-&gt;SetBodyTextTo(BodyText());</a>
<a name="ln160">	if (quoteStyle)</a>
<a name="ln161">		reply-&gt;Body()-&gt;Quote(quoteStyle);</a>
<a name="ln162"> </a>
<a name="ln163">	// Set the subject (and add a &quot;Re:&quot; if needed)</a>
<a name="ln164">	BString string = Subject();</a>
<a name="ln165">	if (string.ICompare(&quot;re:&quot;, 3) != 0)</a>
<a name="ln166">		string.Prepend(&quot;Re: &quot;);</a>
<a name="ln167">	reply-&gt;SetSubject(string.String());</a>
<a name="ln168"> </a>
<a name="ln169">	// set the matching outbound chain</a>
<a name="ln170">	if (accountFromMail)</a>
<a name="ln171">		reply-&gt;SendViaAccountFrom(this);</a>
<a name="ln172"> </a>
<a name="ln173">	return reply;</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176"> </a>
<a name="ln177">BEmailMessage*</a>
<a name="ln178">BEmailMessage::ForwardMessage(bool accountFromMail, bool includeAttachments)</a>
<a name="ln179">{</a>
<a name="ln180">	BString header = &quot;------ Forwarded Message: ------\n&quot;;</a>
<a name="ln181">	header &lt;&lt; &quot;To: &quot; &lt;&lt; To() &lt;&lt; '\n';</a>
<a name="ln182">	header &lt;&lt; &quot;From: &quot; &lt;&lt; From() &lt;&lt; '\n';</a>
<a name="ln183">	if (CC() != NULL) {</a>
<a name="ln184">		// Can use CC rather than &quot;Cc&quot; since display only.</a>
<a name="ln185">		header &lt;&lt; &quot;CC: &quot; &lt;&lt; CC() &lt;&lt; '\n';</a>
<a name="ln186">	}</a>
<a name="ln187">	header &lt;&lt; &quot;Subject: &quot; &lt;&lt; Subject() &lt;&lt; '\n';</a>
<a name="ln188">	header &lt;&lt; &quot;Date: &quot; &lt;&lt; Date() &lt;&lt; &quot;\n\n&quot;;</a>
<a name="ln189">	if (fTextBody != NULL)</a>
<a name="ln190">		header &lt;&lt; fTextBody-&gt;Text() &lt;&lt; '\n';</a>
<a name="ln191">	BEmailMessage *message = new BEmailMessage();</a>
<a name="ln192">	message-&gt;SetBodyTextTo(header.String());</a>
<a name="ln193"> </a>
<a name="ln194">	// set the subject</a>
<a name="ln195">	BString subject = Subject();</a>
<a name="ln196">	if (subject.IFindFirst(&quot;fwd&quot;) == B_ERROR</a>
<a name="ln197">		&amp;&amp; subject.IFindFirst(&quot;forward&quot;) == B_ERROR</a>
<a name="ln198">		&amp;&amp; subject.FindFirst(&quot;FW&quot;) == B_ERROR)</a>
<a name="ln199">		subject &lt;&lt; &quot; (fwd)&quot;;</a>
<a name="ln200">	message-&gt;SetSubject(subject.String());</a>
<a name="ln201"> </a>
<a name="ln202">	if (includeAttachments) {</a>
<a name="ln203">		for (int32 i = 0; i &lt; CountComponents(); i++) {</a>
<a name="ln204">			BMailComponent* component = GetComponent(i);</a>
<a name="ln205">			if (component == fTextBody || component == NULL)</a>
<a name="ln206">				continue;</a>
<a name="ln207"> </a>
<a name="ln208">			//---I am ashamed to have the written the code between here and the next comment</a>
<a name="ln209">			// ... and you still managed to get it wrong ;-)), axeld.</a>
<a name="ln210">			// we should really move this stuff into copy constructors</a>
<a name="ln211">			// or something like that</a>
<a name="ln212"> </a>
<a name="ln213">			BMallocIO io;</a>
<a name="ln214">			component-&gt;RenderToRFC822(&amp;io);</a>
<a name="ln215">			BMailComponent* clone = component-&gt;WhatIsThis();</a>
<a name="ln216">			io.Seek(0, SEEK_SET);</a>
<a name="ln217">			clone-&gt;SetToRFC822(&amp;io, io.BufferLength(), true);</a>
<a name="ln218">			message-&gt;AddComponent(clone);</a>
<a name="ln219">		}</a>
<a name="ln220">	}</a>
<a name="ln221">	if (accountFromMail)</a>
<a name="ln222">		message-&gt;SendViaAccountFrom(this);</a>
<a name="ln223"> </a>
<a name="ln224">	return message;</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227"> </a>
<a name="ln228">const char*</a>
<a name="ln229">BEmailMessage::To() const</a>
<a name="ln230">{</a>
<a name="ln231">	return HeaderField(&quot;To&quot;);</a>
<a name="ln232">}</a>
<a name="ln233"> </a>
<a name="ln234"> </a>
<a name="ln235">const char*</a>
<a name="ln236">BEmailMessage::From() const</a>
<a name="ln237">{</a>
<a name="ln238">	return HeaderField(&quot;From&quot;);</a>
<a name="ln239">}</a>
<a name="ln240"> </a>
<a name="ln241"> </a>
<a name="ln242">const char*</a>
<a name="ln243">BEmailMessage::ReplyTo() const</a>
<a name="ln244">{</a>
<a name="ln245">	return HeaderField(&quot;Reply-To&quot;);</a>
<a name="ln246">}</a>
<a name="ln247"> </a>
<a name="ln248"> </a>
<a name="ln249">const char*</a>
<a name="ln250">BEmailMessage::CC() const</a>
<a name="ln251">{</a>
<a name="ln252">	return HeaderField(&quot;Cc&quot;);</a>
<a name="ln253">		// Note case of CC is &quot;Cc&quot; in our internal headers.</a>
<a name="ln254">}</a>
<a name="ln255"> </a>
<a name="ln256"> </a>
<a name="ln257">const char*</a>
<a name="ln258">BEmailMessage::Subject() const</a>
<a name="ln259">{</a>
<a name="ln260">	return HeaderField(&quot;Subject&quot;);</a>
<a name="ln261">}</a>
<a name="ln262"> </a>
<a name="ln263"> </a>
<a name="ln264">time_t</a>
<a name="ln265">BEmailMessage::Date() const</a>
<a name="ln266">{</a>
<a name="ln267">	const char* dateField = HeaderField(&quot;Date&quot;);</a>
<a name="ln268">	if (dateField == NULL)</a>
<a name="ln269">		return -1;</a>
<a name="ln270"> </a>
<a name="ln271">	return ParseDateWithTimeZone(dateField);</a>
<a name="ln272">}</a>
<a name="ln273"> </a>
<a name="ln274"> </a>
<a name="ln275">int</a>
<a name="ln276">BEmailMessage::Priority() const</a>
<a name="ln277">{</a>
<a name="ln278">	int priorityNumber;</a>
<a name="ln279">	const char* priorityString;</a>
<a name="ln280"> </a>
<a name="ln281">	/* The usual values are a number from 1 to 5, or one of three words:</a>
<a name="ln282">	X-Priority: 1 and/or X-MSMail-Priority: High</a>
<a name="ln283">	X-Priority: 3 and/or X-MSMail-Priority: Normal</a>
<a name="ln284">	X-Priority: 5 and/or X-MSMail-Priority: Low</a>
<a name="ln285">	Also plain Priority: is &quot;normal&quot;, &quot;urgent&quot; or &quot;non-urgent&quot;, see RFC 1327. */</a>
<a name="ln286"> </a>
<a name="ln287">	priorityString = HeaderField(&quot;Priority&quot;);</a>
<a name="ln288">	if (priorityString == NULL)</a>
<a name="ln289">		priorityString = HeaderField(&quot;X-Priority&quot;);</a>
<a name="ln290">	if (priorityString == NULL)</a>
<a name="ln291">		priorityString = HeaderField(&quot;X-Msmail-Priority&quot;);</a>
<a name="ln292">	if (priorityString == NULL)</a>
<a name="ln293">		return 3;</a>
<a name="ln294">	priorityNumber = atoi (priorityString);</a>
<a name="ln295">	if (priorityNumber != 0) {</a>
<a name="ln296">		if (priorityNumber &gt; 5)</a>
<a name="ln297">			priorityNumber = 5;</a>
<a name="ln298">		if (priorityNumber &lt; 1)</a>
<a name="ln299">			priorityNumber = 1;</a>
<a name="ln300">		return priorityNumber;</a>
<a name="ln301">	}</a>
<a name="ln302">	if (strcasecmp (priorityString, &quot;Low&quot;) == 0</a>
<a name="ln303">		|| strcasecmp (priorityString, &quot;non-urgent&quot;) == 0)</a>
<a name="ln304">		return 5;</a>
<a name="ln305">	if (strcasecmp (priorityString, &quot;High&quot;) == 0</a>
<a name="ln306">		|| strcasecmp (priorityString, &quot;urgent&quot;) == 0)</a>
<a name="ln307">		return 1;</a>
<a name="ln308">	return 3;</a>
<a name="ln309">}</a>
<a name="ln310"> </a>
<a name="ln311"> </a>
<a name="ln312">void</a>
<a name="ln313">BEmailMessage::SetSubject(const char* subject, uint32 charset,</a>
<a name="ln314">	mail_encoding encoding)</a>
<a name="ln315">{</a>
<a name="ln316">	SetHeaderField(&quot;Subject&quot;, subject, charset, encoding);</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319"> </a>
<a name="ln320">void</a>
<a name="ln321">BEmailMessage::SetReplyTo(const char* replyTo, uint32 charset,</a>
<a name="ln322">	mail_encoding encoding)</a>
<a name="ln323">{</a>
<a name="ln324">	SetHeaderField(&quot;Reply-To&quot;, replyTo, charset, encoding);</a>
<a name="ln325">}</a>
<a name="ln326"> </a>
<a name="ln327"> </a>
<a name="ln328">void</a>
<a name="ln329">BEmailMessage::SetFrom(const char* from, uint32 charset, mail_encoding encoding)</a>
<a name="ln330">{</a>
<a name="ln331">	SetHeaderField(&quot;From&quot;, from, charset, encoding);</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334"> </a>
<a name="ln335">void</a>
<a name="ln336">BEmailMessage::SetTo(const char* to, uint32 charset, mail_encoding encoding)</a>
<a name="ln337">{</a>
<a name="ln338">	SetHeaderField(&quot;To&quot;, to, charset, encoding);</a>
<a name="ln339">}</a>
<a name="ln340"> </a>
<a name="ln341"> </a>
<a name="ln342">void</a>
<a name="ln343">BEmailMessage::SetCC(const char* cc, uint32 charset, mail_encoding encoding)</a>
<a name="ln344">{</a>
<a name="ln345">	// For consistency with our header names, use Cc as the name.</a>
<a name="ln346">	SetHeaderField(&quot;Cc&quot;, cc, charset, encoding);</a>
<a name="ln347">}</a>
<a name="ln348"> </a>
<a name="ln349"> </a>
<a name="ln350">void</a>
<a name="ln351">BEmailMessage::SetBCC(const char* bcc)</a>
<a name="ln352">{</a>
<a name="ln353">	free(fBCC);</a>
<a name="ln354">	fBCC = strdup(bcc);</a>
<a name="ln355">}</a>
<a name="ln356"> </a>
<a name="ln357"> </a>
<a name="ln358">void</a>
<a name="ln359">BEmailMessage::SetPriority(int to)</a>
<a name="ln360">{</a>
<a name="ln361">	char tempString[20];</a>
<a name="ln362"> </a>
<a name="ln363">	if (to &lt; 1)</a>
<a name="ln364">		to = 1;</a>
<a name="ln365">	if (to &gt; 5)</a>
<a name="ln366">		to = 5;</a>
<a name="ln367">	sprintf (tempString, &quot;%d&quot;, to);</a>
<a name="ln368">	SetHeaderField(&quot;X-Priority&quot;, tempString);</a>
<a name="ln369">	if (to &lt;= 2) {</a>
<a name="ln370">		SetHeaderField(&quot;Priority&quot;, &quot;urgent&quot;);</a>
<a name="ln371">		SetHeaderField(&quot;X-Msmail-Priority&quot;, &quot;High&quot;);</a>
<a name="ln372">	} else if (to &gt;= 4) {</a>
<a name="ln373">		SetHeaderField(&quot;Priority&quot;, &quot;non-urgent&quot;);</a>
<a name="ln374">		SetHeaderField(&quot;X-Msmail-Priority&quot;, &quot;Low&quot;);</a>
<a name="ln375">	} else {</a>
<a name="ln376">		SetHeaderField(&quot;Priority&quot;, &quot;normal&quot;);</a>
<a name="ln377">		SetHeaderField(&quot;X-Msmail-Priority&quot;, &quot;Normal&quot;);</a>
<a name="ln378">	}</a>
<a name="ln379">}</a>
<a name="ln380"> </a>
<a name="ln381"> </a>
<a name="ln382">status_t</a>
<a name="ln383">BEmailMessage::GetName(char* name, int32 maxLength) const</a>
<a name="ln384">{</a>
<a name="ln385">	if (name == NULL || maxLength &lt;= 0)</a>
<a name="ln386">		return B_BAD_VALUE;</a>
<a name="ln387"> </a>
<a name="ln388">	if (BFile* file = dynamic_cast&lt;BFile*&gt;(fData)) {</a>
<a name="ln389">		status_t status = file-&gt;ReadAttr(B_MAIL_ATTR_NAME, B_STRING_TYPE, 0,</a>
<a name="ln390">			name, maxLength);</a>
<a name="ln391">		name[maxLength - 1] = '\0';</a>
<a name="ln392"> </a>
<a name="ln393">		return status &gt;= 0 ? B_OK : status;</a>
<a name="ln394">	}</a>
<a name="ln395">	// TODO: look at From header?  But usually there is</a>
<a name="ln396">	// a file since only the BeMail GUI calls this.</a>
<a name="ln397">	return B_ERROR;</a>
<a name="ln398">}</a>
<a name="ln399"> </a>
<a name="ln400"> </a>
<a name="ln401">status_t</a>
<a name="ln402">BEmailMessage::GetName(BString* name) const</a>
<a name="ln403">{</a>
<a name="ln404">	char* buffer = name-&gt;LockBuffer(B_FILE_NAME_LENGTH);</a>
<a name="ln405">	status_t status = GetName(buffer, B_FILE_NAME_LENGTH);</a>
<a name="ln406">	name-&gt;UnlockBuffer();</a>
<a name="ln407"> </a>
<a name="ln408">	return status;</a>
<a name="ln409">}</a>
<a name="ln410"> </a>
<a name="ln411"> </a>
<a name="ln412">void</a>
<a name="ln413">BEmailMessage::SendViaAccountFrom(BEmailMessage* message)</a>
<a name="ln414">{</a>
<a name="ln415">	BString name;</a>
<a name="ln416">	if (message-&gt;GetAccountName(name) &lt; B_OK) {</a>
<a name="ln417">		// just return the message with the default account</a>
<a name="ln418">		return;</a>
<a name="ln419">	}</a>
<a name="ln420"> </a>
<a name="ln421">	SendViaAccount(name);</a>
<a name="ln422">}</a>
<a name="ln423"> </a>
<a name="ln424"> </a>
<a name="ln425">void</a>
<a name="ln426">BEmailMessage::SendViaAccount(const char* accountName)</a>
<a name="ln427">{</a>
<a name="ln428">	BMailAccounts accounts;</a>
<a name="ln429">	BMailAccountSettings* account = accounts.AccountByName(accountName);</a>
<a name="ln430">	if (account != NULL)</a>
<a name="ln431">		SendViaAccount(account-&gt;AccountID());</a>
<a name="ln432">}</a>
<a name="ln433"> </a>
<a name="ln434"> </a>
<a name="ln435">void</a>
<a name="ln436">BEmailMessage::SendViaAccount(int32 account)</a>
<a name="ln437">{</a>
<a name="ln438">	fAccountID = account;</a>
<a name="ln439"> </a>
<a name="ln440">	BMailAccounts accounts;</a>
<a name="ln441">	BMailAccountSettings* accountSettings = accounts.AccountByID(fAccountID);</a>
<a name="ln442"> </a>
<a name="ln443">	BString from;</a>
<a name="ln444">	if (accountSettings) {</a>
<a name="ln445">		from &lt;&lt; '\&quot;' &lt;&lt; accountSettings-&gt;RealName() &lt;&lt; &quot;\&quot; &lt;&quot;</a>
<a name="ln446">			&lt;&lt; accountSettings-&gt;ReturnAddress() &lt;&lt; '&gt;';</a>
<a name="ln447">	}</a>
<a name="ln448">	SetFrom(from);</a>
<a name="ln449">}</a>
<a name="ln450"> </a>
<a name="ln451"> </a>
<a name="ln452">int32</a>
<a name="ln453">BEmailMessage::Account() const</a>
<a name="ln454">{</a>
<a name="ln455">	return fAccountID;</a>
<a name="ln456">}</a>
<a name="ln457"> </a>
<a name="ln458"> </a>
<a name="ln459">status_t</a>
<a name="ln460">BEmailMessage::GetAccountName(BString&amp; accountName) const</a>
<a name="ln461">{</a>
<a name="ln462">	BFile* file = dynamic_cast&lt;BFile*&gt;(fData);</a>
<a name="ln463">	if (file == NULL)</a>
<a name="ln464">		return B_ERROR;</a>
<a name="ln465"> </a>
<a name="ln466">	int32 accountID;</a>
<a name="ln467">	size_t read = file-&gt;ReadAttr(B_MAIL_ATTR_ACCOUNT, B_INT32_TYPE, 0,</a>
<a name="ln468">		&amp;accountID, sizeof(int32));</a>
<a name="ln469">	if (read &lt; sizeof(int32))</a>
<a name="ln470">		return B_ERROR;</a>
<a name="ln471"> </a>
<a name="ln472">	BMailAccounts accounts;</a>
<a name="ln473">	BMailAccountSettings* account =  accounts.AccountByID(accountID);</a>
<a name="ln474">	if (account != NULL)</a>
<a name="ln475">		accountName = account-&gt;Name();</a>
<a name="ln476">	else</a>
<a name="ln477">		accountName = &quot;&quot;;</a>
<a name="ln478"> </a>
<a name="ln479">	return B_OK;</a>
<a name="ln480">}</a>
<a name="ln481"> </a>
<a name="ln482"> </a>
<a name="ln483">status_t</a>
<a name="ln484">BEmailMessage::AddComponent(BMailComponent* component)</a>
<a name="ln485">{</a>
<a name="ln486">	status_t status = B_OK;</a>
<a name="ln487"> </a>
<a name="ln488">	if (fComponentCount == 0)</a>
<a name="ln489">		fBody = component;</a>
<a name="ln490">	else if (fComponentCount == 1) {</a>
<a name="ln491">		BMIMEMultipartMailContainer *container</a>
<a name="ln492">			= new BMIMEMultipartMailContainer(</a>
<a name="ln493">				mime_boundary, mime_warning, _charSetForTextDecoding);</a>
<a name="ln494">		status = container-&gt;AddComponent(fBody);</a>
<a name="ln495">		if (status == B_OK)</a>
<a name="ln496">			status = container-&gt;AddComponent(component);</a>
<a name="ln497">		fBody = container;</a>
<a name="ln498">	} else {</a>
<a name="ln499">		BMIMEMultipartMailContainer* container</a>
<a name="ln500">			= dynamic_cast&lt;BMIMEMultipartMailContainer*&gt;(fBody);</a>
<a name="ln501">		if (container == NULL)</a>
<a name="ln502">			return B_MISMATCHED_VALUES;</a>
<a name="ln503"> </a>
<a name="ln504">		status = container-&gt;AddComponent(component);</a>
<a name="ln505">	}</a>
<a name="ln506"> </a>
<a name="ln507">	if (status == B_OK)</a>
<a name="ln508">		fComponentCount++;</a>
<a name="ln509">	return status;</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512"> </a>
<a name="ln513">status_t</a>
<a name="ln514">BEmailMessage::RemoveComponent(BMailComponent* /*component*/)</a>
<a name="ln515">{</a>
<a name="ln516">	// not yet implemented</a>
<a name="ln517">	// BeMail/Enclosures.cpp:169: contains a warning about this fact</a>
<a name="ln518">	return B_ERROR;</a>
<a name="ln519">}</a>
<a name="ln520"> </a>
<a name="ln521"> </a>
<a name="ln522">status_t</a>
<a name="ln523">BEmailMessage::RemoveComponent(int32 /*index*/)</a>
<a name="ln524">{</a>
<a name="ln525">	// not yet implemented</a>
<a name="ln526">	return B_ERROR;</a>
<a name="ln527">}</a>
<a name="ln528"> </a>
<a name="ln529"> </a>
<a name="ln530">BMailComponent*</a>
<a name="ln531">BEmailMessage::GetComponent(int32 i, bool parseNow)</a>
<a name="ln532">{</a>
<a name="ln533">	if (BMIMEMultipartMailContainer* container</a>
<a name="ln534">			= dynamic_cast&lt;BMIMEMultipartMailContainer*&gt;(fBody))</a>
<a name="ln535">		return container-&gt;GetComponent(i, parseNow);</a>
<a name="ln536"> </a>
<a name="ln537">	if (i &lt; fComponentCount)</a>
<a name="ln538">		return fBody;</a>
<a name="ln539"> </a>
<a name="ln540">	return NULL;</a>
<a name="ln541">}</a>
<a name="ln542"> </a>
<a name="ln543"> </a>
<a name="ln544">int32</a>
<a name="ln545">BEmailMessage::CountComponents() const</a>
<a name="ln546">{</a>
<a name="ln547">	return fComponentCount;</a>
<a name="ln548">}</a>
<a name="ln549"> </a>
<a name="ln550"> </a>
<a name="ln551">void</a>
<a name="ln552">BEmailMessage::Attach(entry_ref* ref, bool includeAttributes)</a>
<a name="ln553">{</a>
<a name="ln554">	if (includeAttributes)</a>
<a name="ln555">		AddComponent(new BAttributedMailAttachment(ref));</a>
<a name="ln556">	else</a>
<a name="ln557">		AddComponent(new BSimpleMailAttachment(ref));</a>
<a name="ln558">}</a>
<a name="ln559"> </a>
<a name="ln560"> </a>
<a name="ln561">bool</a>
<a name="ln562">BEmailMessage::IsComponentAttachment(int32 i)</a>
<a name="ln563">{</a>
<a name="ln564">	if ((i &gt;= fComponentCount) || (fComponentCount == 0))</a>
<a name="ln565">		return false;</a>
<a name="ln566"> </a>
<a name="ln567">	if (fComponentCount == 1)</a>
<a name="ln568">		return fBody-&gt;IsAttachment();</a>
<a name="ln569"> </a>
<a name="ln570">	BMIMEMultipartMailContainer* container</a>
<a name="ln571">		= dynamic_cast&lt;BMIMEMultipartMailContainer*&gt;(fBody);</a>
<a name="ln572">	if (container == NULL)</a>
<a name="ln573">		return false;</a>
<a name="ln574"> </a>
<a name="ln575">	BMailComponent* component = container-&gt;GetComponent(i);</a>
<a name="ln576">	if (component == NULL)</a>
<a name="ln577">		return false;</a>
<a name="ln578"> </a>
<a name="ln579">	return component-&gt;IsAttachment();</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582"> </a>
<a name="ln583">void</a>
<a name="ln584">BEmailMessage::SetBodyTextTo(const char* text)</a>
<a name="ln585">{</a>
<a name="ln586">	if (fTextBody == NULL) {</a>
<a name="ln587">		fTextBody = new BTextMailComponent;</a>
<a name="ln588">		AddComponent(fTextBody);</a>
<a name="ln589">	}</a>
<a name="ln590"> </a>
<a name="ln591">	fTextBody-&gt;SetText(text);</a>
<a name="ln592">}</a>
<a name="ln593"> </a>
<a name="ln594"> </a>
<a name="ln595">BTextMailComponent*</a>
<a name="ln596">BEmailMessage::Body()</a>
<a name="ln597">{</a>
<a name="ln598">	if (fTextBody == NULL)</a>
<a name="ln599">		fTextBody = _RetrieveTextBody(fBody);</a>
<a name="ln600"> </a>
<a name="ln601">	return fTextBody;</a>
<a name="ln602">}</a>
<a name="ln603"> </a>
<a name="ln604"> </a>
<a name="ln605">const char*</a>
<a name="ln606">BEmailMessage::BodyText()</a>
<a name="ln607">{</a>
<a name="ln608">	if (Body() == NULL)</a>
<a name="ln609">		return NULL;</a>
<a name="ln610"> </a>
<a name="ln611">	return fTextBody-&gt;Text();</a>
<a name="ln612">}</a>
<a name="ln613"> </a>
<a name="ln614"> </a>
<a name="ln615">status_t</a>
<a name="ln616">BEmailMessage::SetBody(BTextMailComponent* body)</a>
<a name="ln617">{</a>
<a name="ln618">	if (fTextBody != NULL) {</a>
<a name="ln619">		return B_ERROR;</a>
<a name="ln620">//	removing doesn't exist for now</a>
<a name="ln621">//		RemoveComponent(fTextBody);</a>
<a name="ln622">//		delete fTextBody;</a>
<a name="ln623">	}</a>
<a name="ln624">	fTextBody = body;</a>
<a name="ln625">	AddComponent(fTextBody);</a>
<a name="ln626"> </a>
<a name="ln627">	return B_OK;</a>
<a name="ln628">}</a>
<a name="ln629"> </a>
<a name="ln630"> </a>
<a name="ln631">BTextMailComponent*</a>
<a name="ln632">BEmailMessage::_RetrieveTextBody(BMailComponent* component)</a>
<a name="ln633">{</a>
<a name="ln634">	BTextMailComponent* body = dynamic_cast&lt;BTextMailComponent*&gt;(component);</a>
<a name="ln635">	if (body != NULL)</a>
<a name="ln636">		return body;</a>
<a name="ln637"> </a>
<a name="ln638">	BMIMEMultipartMailContainer* container</a>
<a name="ln639">		= dynamic_cast&lt;BMIMEMultipartMailContainer*&gt;(component);</a>
<a name="ln640">	if (container != NULL) {</a>
<a name="ln641">		for (int32 i = 0; i &lt; container-&gt;CountComponents(); i++) {</a>
<a name="ln642">			if ((component = container-&gt;GetComponent(i)) == NULL)</a>
<a name="ln643">				continue;</a>
<a name="ln644"> </a>
<a name="ln645">			switch (component-&gt;ComponentType()) {</a>
<a name="ln646">				case B_MAIL_PLAIN_TEXT_BODY:</a>
<a name="ln647">					// AttributedAttachment returns the MIME type of its</a>
<a name="ln648">					// contents, so we have to use dynamic_cast here</a>
<a name="ln649">					body = dynamic_cast&lt;BTextMailComponent*&gt;(</a>
<a name="ln650">						container-&gt;GetComponent(i));</a>
<a name="ln651">					if (body != NULL)</a>
<a name="ln652">						return body;</a>
<a name="ln653">					break;</a>
<a name="ln654"> </a>
<a name="ln655">				case B_MAIL_MULTIPART_CONTAINER:</a>
<a name="ln656">					body = _RetrieveTextBody(container-&gt;GetComponent(i));</a>
<a name="ln657">					if (body != NULL)</a>
<a name="ln658">						return body;</a>
<a name="ln659">					break;</a>
<a name="ln660">			}</a>
<a name="ln661">		}</a>
<a name="ln662">	}</a>
<a name="ln663">	return NULL;</a>
<a name="ln664">}</a>
<a name="ln665"> </a>
<a name="ln666"> </a>
<a name="ln667">status_t</a>
<a name="ln668">BEmailMessage::SetToRFC822(BPositionIO* mailFile, size_t length,</a>
<a name="ln669">	bool parseNow)</a>
<a name="ln670">{</a>
<a name="ln671">	if (BFile* file = dynamic_cast&lt;BFile*&gt;(mailFile)) {</a>
<a name="ln672">		file-&gt;ReadAttr(B_MAIL_ATTR_ACCOUNT_ID, B_INT32_TYPE, 0, &amp;fAccountID,</a>
<a name="ln673">			sizeof(fAccountID));</a>
<a name="ln674">	}</a>
<a name="ln675"> </a>
<a name="ln676">	mailFile-&gt;Seek(0, SEEK_END);</a>
<a name="ln677">	length = mailFile-&gt;Position();</a>
<a name="ln678">	mailFile-&gt;Seek(0, SEEK_SET);</a>
<a name="ln679"> </a>
<a name="ln680">	fStatus = BMailComponent::SetToRFC822(mailFile, length, parseNow);</a>
<a name="ln681">	if (fStatus &lt; B_OK)</a>
<a name="ln682">		return fStatus;</a>
<a name="ln683"> </a>
<a name="ln684">	fBody = WhatIsThis();</a>
<a name="ln685"> </a>
<a name="ln686">	mailFile-&gt;Seek(0, SEEK_SET);</a>
<a name="ln687">	fStatus = fBody-&gt;SetToRFC822(mailFile, length, parseNow);</a>
<a name="ln688">	if (fStatus &lt; B_OK)</a>
<a name="ln689">		return fStatus;</a>
<a name="ln690"> </a>
<a name="ln691">	// Move headers that we use to us, everything else to fBody</a>
<a name="ln692">	const char* name;</a>
<a name="ln693">	for (int32 i = 0; (name = fBody-&gt;HeaderAt(i)) != NULL; i++) {</a>
<a name="ln694">		if (strcasecmp(name, &quot;Subject&quot;) != 0</a>
<a name="ln695">			&amp;&amp; strcasecmp(name, &quot;To&quot;) != 0</a>
<a name="ln696">			&amp;&amp; strcasecmp(name, &quot;From&quot;) != 0</a>
<a name="ln697">			&amp;&amp; strcasecmp(name, &quot;Reply-To&quot;) != 0</a>
<a name="ln698">			&amp;&amp; strcasecmp(name, &quot;Cc&quot;) != 0</a>
<a name="ln699">			&amp;&amp; strcasecmp(name, &quot;Priority&quot;) != 0</a>
<a name="ln700">			&amp;&amp; strcasecmp(name, &quot;X-Priority&quot;) != 0</a>
<a name="ln701">			&amp;&amp; strcasecmp(name, &quot;X-Msmail-Priority&quot;) != 0</a>
<a name="ln702">			&amp;&amp; strcasecmp(name, &quot;Date&quot;) != 0) {</a>
<a name="ln703">			RemoveHeader(name);</a>
<a name="ln704">		}</a>
<a name="ln705">	}</a>
<a name="ln706"> </a>
<a name="ln707">	fBody-&gt;RemoveHeader(&quot;Subject&quot;);</a>
<a name="ln708">	fBody-&gt;RemoveHeader(&quot;To&quot;);</a>
<a name="ln709">	fBody-&gt;RemoveHeader(&quot;From&quot;);</a>
<a name="ln710">	fBody-&gt;RemoveHeader(&quot;Reply-To&quot;);</a>
<a name="ln711">	fBody-&gt;RemoveHeader(&quot;Cc&quot;);</a>
<a name="ln712">	fBody-&gt;RemoveHeader(&quot;Priority&quot;);</a>
<a name="ln713">	fBody-&gt;RemoveHeader(&quot;X-Priority&quot;);</a>
<a name="ln714">	fBody-&gt;RemoveHeader(&quot;X-Msmail-Priority&quot;);</a>
<a name="ln715">	fBody-&gt;RemoveHeader(&quot;Date&quot;);</a>
<a name="ln716"> </a>
<a name="ln717">	fComponentCount = 1;</a>
<a name="ln718">	if (BMIMEMultipartMailContainer* container</a>
<a name="ln719">			= dynamic_cast&lt;BMIMEMultipartMailContainer*&gt;(fBody))</a>
<a name="ln720">		fComponentCount = container-&gt;CountComponents();</a>
<a name="ln721"> </a>
<a name="ln722">	return B_OK;</a>
<a name="ln723">}</a>
<a name="ln724"> </a>
<a name="ln725"> </a>
<a name="ln726">status_t</a>
<a name="ln727">BEmailMessage::RenderToRFC822(BPositionIO* file)</a>
<a name="ln728">{</a>
<a name="ln729">	if (fBody == NULL)</a>
<a name="ln730">		return B_MAIL_INVALID_MAIL;</a>
<a name="ln731"> </a>
<a name="ln732">	// Do real rendering</a>
<a name="ln733"> </a>
<a name="ln734">	if (From() == NULL) {</a>
<a name="ln735">		// set the &quot;From:&quot; string</a>
<a name="ln736">		SendViaAccount(fAccountID);</a>
<a name="ln737">	}</a>
<a name="ln738"> </a>
<a name="ln739">	BList recipientList;</a>
<a name="ln740">	get_address_list(recipientList, To(), extract_address);</a>
<a name="ln741">	get_address_list(recipientList, CC(), extract_address);</a>
<a name="ln742">	get_address_list(recipientList, fBCC, extract_address);</a>
<a name="ln743"> </a>
<a name="ln744">	BString recipients;</a>
<a name="ln745">	for (int32 i = recipientList.CountItems(); i-- &gt; 0;) {</a>
<a name="ln746">		char *address = (char *)recipientList.RemoveItem((int32)0);</a>
<a name="ln747"> </a>
<a name="ln748">		recipients &lt;&lt; '&lt;' &lt;&lt; address &lt;&lt; '&gt;';</a>
<a name="ln749">		if (i)</a>
<a name="ln750">			recipients &lt;&lt; ',';</a>
<a name="ln751"> </a>
<a name="ln752">		free(address);</a>
<a name="ln753">	}</a>
<a name="ln754"> </a>
<a name="ln755">	// add the date field</a>
<a name="ln756">	time_t creationTime = time(NULL);</a>
<a name="ln757">	{</a>
<a name="ln758">		char date[128];</a>
<a name="ln759">		struct tm tm;</a>
<a name="ln760">		localtime_r(&amp;creationTime, &amp;tm);</a>
<a name="ln761"> </a>
<a name="ln762">		size_t length = strftime(date, sizeof(date),</a>
<a name="ln763">			&quot;%a, %d %b %Y %H:%M:%S&quot;, &amp;tm);</a>
<a name="ln764"> </a>
<a name="ln765">		// GMT offsets are full hours, yes, but you never know :-)</a>
<a name="ln766">		snprintf(date + length, sizeof(date) - length, &quot; %+03d%02d&quot;,</a>
<a name="ln767">			tm.tm_gmtoff / 3600, (tm.tm_gmtoff / 60) % 60);</a>
<a name="ln768"> </a>
<a name="ln769">		SetHeaderField(&quot;Date&quot;, date);</a>
<a name="ln770">	}</a>
<a name="ln771"> </a>
<a name="ln772">	// add a message-id</a>
<a name="ln773"> </a>
<a name="ln774">	// empirical evidence indicates message id must be enclosed in</a>
<a name="ln775">	// angle brackets and there must be an &quot;at&quot; symbol in it</a>
<a name="ln776">	BString messageID;</a>
<a name="ln777">	messageID &lt;&lt; &quot;&lt;&quot;;</a>
<a name="ln778">	messageID &lt;&lt; system_time();</a>
<a name="ln779">	messageID &lt;&lt; &quot;-BeMail@&quot;;</a>
<a name="ln780"> </a>
<a name="ln781">	char host[255];</a>
<a name="ln782">	if (gethostname(host, sizeof(host)) &lt; 0 || !host[0])</a>
<a name="ln783">		strcpy(host, &quot;zoidberg&quot;);</a>
<a name="ln784"> </a>
<a name="ln785">	messageID &lt;&lt; host;</a>
<a name="ln786">	messageID &lt;&lt; &quot;&gt;&quot;;</a>
<a name="ln787"> </a>
<a name="ln788">	SetHeaderField(&quot;Message-Id&quot;, messageID.String());</a>
<a name="ln789"> </a>
<a name="ln790">	status_t err = BMailComponent::RenderToRFC822(file);</a>
<a name="ln791">	if (err &lt; B_OK)</a>
<a name="ln792">		return err;</a>
<a name="ln793"> </a>
<a name="ln794">	file-&gt;Seek(-2, SEEK_CUR);</a>
<a name="ln795">		// Remove division between headers</a>
<a name="ln796"> </a>
<a name="ln797">	err = fBody-&gt;RenderToRFC822(file);</a>
<a name="ln798">	if (err &lt; B_OK)</a>
<a name="ln799">		return err;</a>
<a name="ln800"> </a>
<a name="ln801">	// Set the message file's attributes.  Do this after the rest of the file</a>
<a name="ln802">	// is filled in, in case the daemon attempts to send it before it is ready</a>
<a name="ln803">	// (since the daemon may send it when it sees the status attribute getting</a>
<a name="ln804">	// set to &quot;Pending&quot;).</a>
<a name="ln805"> </a>
<a name="ln806">	if (BFile* attributed = dynamic_cast &lt;BFile*&gt;(file)) {</a>
<a name="ln807">		BNodeInfo(attributed).SetType(B_MAIL_TYPE);</a>
<a name="ln808"> </a>
<a name="ln809">		attributed-&gt;WriteAttrString(B_MAIL_ATTR_RECIPIENTS,&amp;recipients);</a>
<a name="ln810"> </a>
<a name="ln811">		BString attr;</a>
<a name="ln812"> </a>
<a name="ln813">		attr = To();</a>
<a name="ln814">		attributed-&gt;WriteAttrString(B_MAIL_ATTR_TO, &amp;attr);</a>
<a name="ln815">		attr = CC();</a>
<a name="ln816">		attributed-&gt;WriteAttrString(B_MAIL_ATTR_CC, &amp;attr);</a>
<a name="ln817">		attr = Subject();</a>
<a name="ln818">		attributed-&gt;WriteAttrString(B_MAIL_ATTR_SUBJECT, &amp;attr);</a>
<a name="ln819">		attr = ReplyTo();</a>
<a name="ln820">		attributed-&gt;WriteAttrString(B_MAIL_ATTR_REPLY, &amp;attr);</a>
<a name="ln821">		attr = From();</a>
<a name="ln822">		attributed-&gt;WriteAttrString(B_MAIL_ATTR_FROM, &amp;attr);</a>
<a name="ln823">		if (Priority() != 3 /* Normal is 3 */) {</a>
<a name="ln824">			sprintf(attr.LockBuffer(40), &quot;%d&quot;, Priority());</a>
<a name="ln825">			attr.UnlockBuffer(-1);</a>
<a name="ln826">			attributed-&gt;WriteAttrString(B_MAIL_ATTR_PRIORITY, &amp;attr);</a>
<a name="ln827">		}</a>
<a name="ln828">		attr = &quot;Pending&quot;;</a>
<a name="ln829">		attributed-&gt;WriteAttrString(B_MAIL_ATTR_STATUS, &amp;attr);</a>
<a name="ln830">		attr = &quot;1.0&quot;;</a>
<a name="ln831">		attributed-&gt;WriteAttrString(B_MAIL_ATTR_MIME, &amp;attr);</a>
<a name="ln832"> </a>
<a name="ln833">		attributed-&gt;WriteAttr(B_MAIL_ATTR_ACCOUNT, B_INT32_TYPE, 0,</a>
<a name="ln834">			&amp;fAccountID, sizeof(int32));</a>
<a name="ln835"> </a>
<a name="ln836">		attributed-&gt;WriteAttr(B_MAIL_ATTR_WHEN, B_TIME_TYPE, 0, &amp;creationTime,</a>
<a name="ln837">			sizeof(int32));</a>
<a name="ln838">		int32 flags = B_MAIL_PENDING | B_MAIL_SAVE;</a>
<a name="ln839">		attributed-&gt;WriteAttr(B_MAIL_ATTR_FLAGS, B_INT32_TYPE, 0, &amp;flags,</a>
<a name="ln840">			sizeof(int32));</a>
<a name="ln841"> </a>
<a name="ln842">		attributed-&gt;WriteAttr(B_MAIL_ATTR_ACCOUNT_ID, B_INT32_TYPE, 0,</a>
<a name="ln843">			&amp;fAccountID, sizeof(int32));</a>
<a name="ln844">	}</a>
<a name="ln845"> </a>
<a name="ln846">	return B_OK;</a>
<a name="ln847">}</a>
<a name="ln848"> </a>
<a name="ln849"> </a>
<a name="ln850">status_t</a>
<a name="ln851">BEmailMessage::RenderTo(BDirectory* dir, BEntry* msg)</a>
<a name="ln852">{</a>
<a name="ln853">	time_t currentTime;</a>
<a name="ln854">	char numericDateString[40];</a>
<a name="ln855">	struct tm timeFields;</a>
<a name="ln856">	BString worker;</a>
<a name="ln857"> </a>
<a name="ln858">	// Generate a file name for the outgoing message.  See also</a>
<a name="ln859">	// FolderFilter::ProcessMailMessage which does something similar for</a>
<a name="ln860">	// incoming messages.</a>
<a name="ln861"> </a>
<a name="ln862">	BString name = Subject();</a>
<a name="ln863">	SubjectToThread(name);</a>
<a name="ln864">		// Extract the core subject words.</a>
<a name="ln865">	if (name.Length() &lt;= 0)</a>
<a name="ln866">		name = &quot;No Subject&quot;;</a>
<a name="ln867">	if (name[0] == '.') {</a>
<a name="ln868">		// Avoid hidden files, starting with a dot.</a>
<a name="ln869">		name.Prepend(&quot;_&quot;);</a>
<a name="ln870">	}</a>
<a name="ln871"> </a>
<a name="ln872">	// Convert the date into a year-month-day fixed digit width format, so that</a>
<a name="ln873">	// sorting by file name will give all the messages with the same subject in</a>
<a name="ln874">	// order of date.</a>
<a name="ln875">	time (&amp;currentTime);</a>
<a name="ln876">	localtime_r (&amp;currentTime, &amp;timeFields);</a>
<a name="ln877">	sprintf (numericDateString, &quot;%04d%02d%02d%02d%02d%02d&quot;,</a>
<a name="ln878">		timeFields.tm_year + 1900, timeFields.tm_mon + 1, timeFields.tm_mday,</a>
<a name="ln879">		timeFields.tm_hour, timeFields.tm_min, timeFields.tm_sec);</a>
<a name="ln880">	name &lt;&lt; &quot; &quot; &lt;&lt; numericDateString;</a>
<a name="ln881"> </a>
<a name="ln882">	worker = From();</a>
<a name="ln883">	extract_address_name(worker);</a>
<a name="ln884">	name &lt;&lt; &quot; &quot; &lt;&lt; worker;</a>
<a name="ln885"> </a>
<a name="ln886">	name.Truncate(222);	// reserve space for the uniquer</a>
<a name="ln887"> </a>
<a name="ln888">	// Get rid of annoying characters which are hard to use in the shell.</a>
<a name="ln889">	name.ReplaceAll('/','_');</a>
<a name="ln890">	name.ReplaceAll('\'','_');</a>
<a name="ln891">	name.ReplaceAll('&quot;','_');</a>
<a name="ln892">	name.ReplaceAll('!','_');</a>
<a name="ln893">	name.ReplaceAll('&lt;','_');</a>
<a name="ln894">	name.ReplaceAll('&gt;','_');</a>
<a name="ln895"> </a>
<a name="ln896">	// Remove multiple spaces.</a>
<a name="ln897">	while (name.FindFirst(&quot;  &quot;) &gt;= 0)</a>
<a name="ln898">		name.Replace(&quot;  &quot;, &quot; &quot;, 1024);</a>
<a name="ln899"> </a>
<a name="ln900">	int32 uniquer = time(NULL);</a>
<a name="ln901">	worker = name;</a>
<a name="ln902"> </a>
<a name="ln903">	int32 tries = 30;</a>
<a name="ln904">	bool exists;</a>
<a name="ln905">	while ((exists = dir-&gt;Contains(worker.String())) &amp;&amp; --tries &gt; 0) {</a>
<a name="ln906">		srand(rand());</a>
<a name="ln907">		uniquer += (rand() &gt;&gt; 16) - 16384;</a>
<a name="ln908"> </a>
<a name="ln909">		worker = name;</a>
<a name="ln910">		worker &lt;&lt; ' ' &lt;&lt; uniquer;</a>
<a name="ln911">	}</a>
<a name="ln912"> </a>
<a name="ln913">	if (exists)</a>
<a name="ln914">		printf(&quot;could not create mail! (should be: %s)\n&quot;, worker.String());</a>
<a name="ln915"> </a>
<a name="ln916">	BFile file;</a>
<a name="ln917">	status_t status = dir-&gt;CreateFile(worker.String(), &amp;file);</a>
<a name="ln918">	if (status != B_OK)</a>
<a name="ln919">		return status;</a>
<a name="ln920"> </a>
<a name="ln921">	if (msg != NULL)</a>
<a name="ln922">		msg-&gt;SetTo(dir,worker.String());</a>
<a name="ln923"> </a>
<a name="ln924">	return RenderToRFC822(&amp;file);</a>
<a name="ln925">}</a>
<a name="ln926"> </a>
<a name="ln927"> </a>
<a name="ln928">status_t</a>
<a name="ln929">BEmailMessage::Send(bool sendNow)</a>
<a name="ln930">{</a>
<a name="ln931">	BMailAccounts accounts;</a>
<a name="ln932">	BMailAccountSettings* account = accounts.AccountByID(fAccountID);</a>
<a name="ln933">	if (account == NULL || !account-&gt;HasOutbound()) {</a>
<a name="ln934">		account = accounts.AccountByID(</a>
<a name="ln935">			BMailSettings().DefaultOutboundAccount());</a>
<a name="ln936">		if (!account)</a>
<a name="ln937">			return B_ERROR;</a>
<a name="ln938">		SendViaAccount(account-&gt;AccountID());</a>
<a name="ln939">	}</a>
<a name="ln940"> </a>
<a name="ln941">	BString path;</a>
<a name="ln942">	if (account-&gt;OutboundSettings().FindString(&quot;path&quot;, &amp;path) != B_OK) {</a>
<a name="ln943">		BPath defaultMailOutPath;</a>
<a name="ln944">		if (find_directory(B_USER_DIRECTORY, &amp;defaultMailOutPath) != B_OK</a>
<a name="ln945">			|| defaultMailOutPath.Append(&quot;mail/out&quot;) != B_OK)</a>
<a name="ln946">			path = &quot;/boot/home/mail/out&quot;;</a>
<a name="ln947">		else</a>
<a name="ln948">			path = defaultMailOutPath.Path();</a>
<a name="ln949">	}</a>
<a name="ln950"> </a>
<a name="ln951">	create_directory(path.String(), 0777);</a>
<a name="ln952">	BDirectory directory(path.String());</a>
<a name="ln953"> </a>
<a name="ln954">	BEntry message;</a>
<a name="ln955"> </a>
<a name="ln956">	status_t status = RenderTo(&amp;directory, &amp;message);</a>
<a name="ln957">	if (status &gt;= B_OK &amp;&amp; sendNow) {</a>
<a name="ln958">		// TODO: check whether or not the internet connection is available</a>
<a name="ln959">		BMessenger daemon(B_MAIL_DAEMON_SIGNATURE);</a>
<a name="ln960">		if (!daemon.IsValid())</a>
<a name="ln961">			return B_MAIL_NO_DAEMON;</a>
<a name="ln962"> </a>
<a name="ln963">		BMessage msg(kMsgSendMessages);</a>
<a name="ln964">		msg.AddInt32(&quot;account&quot;, fAccountID);</a>
<a name="ln965">		BPath path;</a>
<a name="ln966">		message.GetPath(&amp;path);</a>
<a name="ln967">		msg.AddString(&quot;message_path&quot;, path.Path());</a>
<a name="ln968">		daemon.SendMessage(&amp;msg);</a>
<a name="ln969">	}</a>
<a name="ln970"> </a>
<a name="ln971">	return status;</a>
<a name="ln972">}</a>
<a name="ln973"> </a>
<a name="ln974"> </a>
<a name="ln975">void BEmailMessage::_ReservedMessage1() {}</a>
<a name="ln976">void BEmailMessage::_ReservedMessage2() {}</a>
<a name="ln977">void BEmailMessage::_ReservedMessage3() {}</a>

</code></pre>
<div class="balloon" rel="677"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v763/" target="_blank">V763</a> Parameter 'length' is always rewritten in function body before being used.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
