
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>sample.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*-</a>
<a name="ln2"> * SPDX-License-Identifier: BSD-3-Clause</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2005 John Bicket</a>
<a name="ln5"> * All rights reserved.</a>
<a name="ln6"> *</a>
<a name="ln7"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln8"> * modification, are permitted provided that the following conditions</a>
<a name="ln9"> * are met:</a>
<a name="ln10"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln11"> *    notice, this list of conditions and the following disclaimer,</a>
<a name="ln12"> *    without modification.</a>
<a name="ln13"> * 2. Redistributions in binary form must reproduce at minimum a disclaimer</a>
<a name="ln14"> *    similar to the &quot;NO WARRANTY&quot; disclaimer below (&quot;Disclaimer&quot;) and any</a>
<a name="ln15"> *    redistribution must be conditioned upon including a substantially</a>
<a name="ln16"> *    similar Disclaimer requirement for further binary redistribution.</a>
<a name="ln17"> * 3. Neither the names of the above-listed copyright holders nor the names</a>
<a name="ln18"> *    of any contributors may be used to endorse or promote products derived</a>
<a name="ln19"> *    from this software without specific prior written permission.</a>
<a name="ln20"> *</a>
<a name="ln21"> * Alternatively, this software may be distributed under the terms of the</a>
<a name="ln22"> * GNU General Public License (&quot;GPL&quot;) version 2 as published by the Free</a>
<a name="ln23"> * Software Foundation.</a>
<a name="ln24"> *</a>
<a name="ln25"> * NO WARRANTY</a>
<a name="ln26"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</a>
<a name="ln27"> * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</a>
<a name="ln28"> * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY</a>
<a name="ln29"> * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL</a>
<a name="ln30"> * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,</a>
<a name="ln31"> * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</a>
<a name="ln32"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</a>
<a name="ln33"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER</a>
<a name="ln34"> * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</a>
<a name="ln35"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF</a>
<a name="ln36"> * THE POSSIBILITY OF SUCH DAMAGES.</a>
<a name="ln37"> *</a>
<a name="ln38"> */</a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;sys/cdefs.h&gt;</a>
<a name="ln41">__FBSDID(&quot;$FreeBSD: releng/12.0/sys/dev/ath/ath_rate/sample/sample.c 326255 2017-11-27 14:52:40Z pfg $&quot;);</a>
<a name="ln42"> </a>
<a name="ln43">/*</a>
<a name="ln44"> * John Bicket's SampleRate control algorithm.</a>
<a name="ln45"> */</a>
<a name="ln46">#include &quot;opt_ath.h&quot;</a>
<a name="ln47">#include &quot;opt_inet.h&quot;</a>
<a name="ln48">#include &quot;opt_wlan.h&quot;</a>
<a name="ln49">#include &quot;opt_ah.h&quot;</a>
<a name="ln50"> </a>
<a name="ln51">#include &lt;sys/param.h&gt;</a>
<a name="ln52">#include &lt;sys/systm.h&gt; </a>
<a name="ln53">#include &lt;sys/sysctl.h&gt;</a>
<a name="ln54">#include &lt;sys/kernel.h&gt;</a>
<a name="ln55">#include &lt;sys/lock.h&gt;</a>
<a name="ln56">#include &lt;sys/malloc.h&gt;</a>
<a name="ln57">#include &lt;sys/mutex.h&gt;</a>
<a name="ln58">#include &lt;sys/errno.h&gt;</a>
<a name="ln59"> </a>
<a name="ln60">#include &lt;machine/bus.h&gt;</a>
<a name="ln61">#include &lt;machine/resource.h&gt;</a>
<a name="ln62">#include &lt;sys/bus.h&gt;</a>
<a name="ln63"> </a>
<a name="ln64">#include &lt;sys/socket.h&gt;</a>
<a name="ln65"> </a>
<a name="ln66">#include &lt;net/if.h&gt;</a>
<a name="ln67">#include &lt;net/if_var.h&gt;</a>
<a name="ln68">#include &lt;net/if_media.h&gt;</a>
<a name="ln69">#include &lt;net/if_arp.h&gt;</a>
<a name="ln70">#include &lt;net/ethernet.h&gt;		/* XXX for ether_sprintf */</a>
<a name="ln71"> </a>
<a name="ln72">#include &lt;net80211/ieee80211_var.h&gt;</a>
<a name="ln73"> </a>
<a name="ln74">#include &lt;net/bpf.h&gt;</a>
<a name="ln75"> </a>
<a name="ln76">#ifdef INET</a>
<a name="ln77">#include &lt;netinet/in.h&gt; </a>
<a name="ln78">#include &lt;netinet/if_ether.h&gt;</a>
<a name="ln79">#endif</a>
<a name="ln80"> </a>
<a name="ln81">#include &lt;dev/ath/if_athvar.h&gt;</a>
<a name="ln82">#include &lt;dev/ath/ath_rate/sample/sample.h&gt;</a>
<a name="ln83">#include &lt;dev/ath/ath_hal/ah_desc.h&gt;</a>
<a name="ln84">#include &lt;dev/ath/ath_rate/sample/tx_schedules.h&gt;</a>
<a name="ln85"> </a>
<a name="ln86">/*</a>
<a name="ln87"> * This file is an implementation of the SampleRate algorithm</a>
<a name="ln88"> * in &quot;Bit-rate Selection in Wireless Networks&quot;</a>
<a name="ln89"> * (http://www.pdos.lcs.mit.edu/papers/jbicket-ms.ps)</a>
<a name="ln90"> *</a>
<a name="ln91"> * SampleRate chooses the bit-rate it predicts will provide the most</a>
<a name="ln92"> * throughput based on estimates of the expected per-packet</a>
<a name="ln93"> * transmission time for each bit-rate.  SampleRate periodically sends</a>
<a name="ln94"> * packets at bit-rates other than the current one to estimate when</a>
<a name="ln95"> * another bit-rate will provide better performance. SampleRate</a>
<a name="ln96"> * switches to another bit-rate when its estimated per-packet</a>
<a name="ln97"> * transmission time becomes smaller than the current bit-rate's.</a>
<a name="ln98"> * SampleRate reduces the number of bit-rates it must sample by</a>
<a name="ln99"> * eliminating those that could not perform better than the one</a>
<a name="ln100"> * currently being used.  SampleRate also stops probing at a bit-rate</a>
<a name="ln101"> * if it experiences several successive losses.</a>
<a name="ln102"> *</a>
<a name="ln103"> * The difference between the algorithm in the thesis and the one in this</a>
<a name="ln104"> * file is that the one in this file uses a ewma instead of a window.</a>
<a name="ln105"> *</a>
<a name="ln106"> * Also, this implementation tracks the average transmission time for</a>
<a name="ln107"> * a few different packet sizes independently for each link.</a>
<a name="ln108"> */</a>
<a name="ln109"> </a>
<a name="ln110">static void	ath_rate_ctl_reset(struct ath_softc *, struct ieee80211_node *);</a>
<a name="ln111"> </a>
<a name="ln112">static __inline int</a>
<a name="ln113">size_to_bin(int size) </a>
<a name="ln114">{</a>
<a name="ln115">#if NUM_PACKET_SIZE_BINS &gt; 1</a>
<a name="ln116">	if (size &lt;= packet_size_bins[0])</a>
<a name="ln117">		return 0;</a>
<a name="ln118">#endif</a>
<a name="ln119">#if NUM_PACKET_SIZE_BINS &gt; 2</a>
<a name="ln120">	if (size &lt;= packet_size_bins[1])</a>
<a name="ln121">		return 1;</a>
<a name="ln122">#endif</a>
<a name="ln123">#if NUM_PACKET_SIZE_BINS &gt; 3</a>
<a name="ln124">	if (size &lt;= packet_size_bins[2])</a>
<a name="ln125">		return 2;</a>
<a name="ln126">#endif</a>
<a name="ln127">#if NUM_PACKET_SIZE_BINS &gt; 4</a>
<a name="ln128">#error &quot;add support for more packet sizes&quot;</a>
<a name="ln129">#endif</a>
<a name="ln130">	return NUM_PACKET_SIZE_BINS-1;</a>
<a name="ln131">}</a>
<a name="ln132"> </a>
<a name="ln133">void</a>
<a name="ln134">ath_rate_node_init(struct ath_softc *sc, struct ath_node *an)</a>
<a name="ln135">{</a>
<a name="ln136">	/* NB: assumed to be zero'd by caller */</a>
<a name="ln137">}</a>
<a name="ln138"> </a>
<a name="ln139">void</a>
<a name="ln140">ath_rate_node_cleanup(struct ath_softc *sc, struct ath_node *an)</a>
<a name="ln141">{</a>
<a name="ln142">}</a>
<a name="ln143"> </a>
<a name="ln144">static int</a>
<a name="ln145">dot11rate(const HAL_RATE_TABLE *rt, int rix)</a>
<a name="ln146">{</a>
<a name="ln147">	if (rix &lt; 0)</a>
<a name="ln148">		return -1;</a>
<a name="ln149">	return rt-&gt;info[rix].phy == IEEE80211_T_HT ?</a>
<a name="ln150">	    rt-&gt;info[rix].dot11Rate : (rt-&gt;info[rix].dot11Rate &amp; IEEE80211_RATE_VAL) / 2;</a>
<a name="ln151">}</a>
<a name="ln152"> </a>
<a name="ln153">static const char *</a>
<a name="ln154">dot11rate_label(const HAL_RATE_TABLE *rt, int rix)</a>
<a name="ln155">{</a>
<a name="ln156">	if (rix &lt; 0)</a>
<a name="ln157">		return &quot;&quot;;</a>
<a name="ln158">	return rt-&gt;info[rix].phy == IEEE80211_T_HT ? &quot;MCS&quot; : &quot;Mb &quot;;</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161">/*</a>
<a name="ln162"> * Return the rix with the lowest average_tx_time,</a>
<a name="ln163"> * or -1 if all the average_tx_times are 0.</a>
<a name="ln164"> */</a>
<a name="ln165">static __inline int</a>
<a name="ln166">pick_best_rate(struct ath_node *an, const HAL_RATE_TABLE *rt,</a>
<a name="ln167">    int size_bin, int require_acked_before)</a>
<a name="ln168">{</a>
<a name="ln169">	struct sample_node *sn = ATH_NODE_SAMPLE(an);</a>
<a name="ln170">        int best_rate_rix, best_rate_tt, best_rate_pct;</a>
<a name="ln171">	uint64_t mask;</a>
<a name="ln172">	int rix, tt, pct;</a>
<a name="ln173"> </a>
<a name="ln174">        best_rate_rix = 0;</a>
<a name="ln175">        best_rate_tt = 0;</a>
<a name="ln176">	best_rate_pct = 0;</a>
<a name="ln177">	for (mask = sn-&gt;ratemask, rix = 0; mask != 0; mask &gt;&gt;= 1, rix++) {</a>
<a name="ln178">		if ((mask &amp; 1) == 0)		/* not a supported rate */</a>
<a name="ln179">			continue;</a>
<a name="ln180"> </a>
<a name="ln181">		/* Don't pick a non-HT rate for a HT node */</a>
<a name="ln182">		if ((an-&gt;an_node.ni_flags &amp; IEEE80211_NODE_HT) &amp;&amp;</a>
<a name="ln183">		    (rt-&gt;info[rix].phy != IEEE80211_T_HT)) {</a>
<a name="ln184">			continue;</a>
<a name="ln185">		}</a>
<a name="ln186"> </a>
<a name="ln187">		tt = sn-&gt;stats[size_bin][rix].average_tx_time;</a>
<a name="ln188">		if (tt &lt;= 0 ||</a>
<a name="ln189">		    (require_acked_before &amp;&amp;</a>
<a name="ln190">		     !sn-&gt;stats[size_bin][rix].packets_acked))</a>
<a name="ln191">			continue;</a>
<a name="ln192"> </a>
<a name="ln193">		/* Calculate percentage if possible */</a>
<a name="ln194">		if (sn-&gt;stats[size_bin][rix].total_packets &gt; 0) {</a>
<a name="ln195">			pct = sn-&gt;stats[size_bin][rix].ewma_pct;</a>
<a name="ln196">		} else {</a>
<a name="ln197">			/* XXX for now, assume 95% ok */</a>
<a name="ln198">			pct = 95;</a>
<a name="ln199">		}</a>
<a name="ln200"> </a>
<a name="ln201">		/* don't use a bit-rate that has been failing */</a>
<a name="ln202">		if (sn-&gt;stats[size_bin][rix].successive_failures &gt; 3)</a>
<a name="ln203">			continue;</a>
<a name="ln204"> </a>
<a name="ln205">		/*</a>
<a name="ln206">		 * For HT, Don't use a bit rate that is much more</a>
<a name="ln207">		 * lossy than the best.</a>
<a name="ln208">		 *</a>
<a name="ln209">		 * XXX this isn't optimal; it's just designed to</a>
<a name="ln210">		 * eliminate rates that are going to be obviously</a>
<a name="ln211">		 * worse.</a>
<a name="ln212">		 */</a>
<a name="ln213">		if (an-&gt;an_node.ni_flags &amp; IEEE80211_NODE_HT) {</a>
<a name="ln214">			if (best_rate_pct &gt; (pct + 50))</a>
<a name="ln215">				continue;</a>
<a name="ln216">		}</a>
<a name="ln217"> </a>
<a name="ln218">		/*</a>
<a name="ln219">		 * For non-MCS rates, use the current average txtime for</a>
<a name="ln220">		 * comparison.</a>
<a name="ln221">		 */</a>
<a name="ln222">		if (! (an-&gt;an_node.ni_flags &amp; IEEE80211_NODE_HT)) {</a>
<a name="ln223">			if (best_rate_tt == 0 || tt &lt;= best_rate_tt) {</a>
<a name="ln224">				best_rate_tt = tt;</a>
<a name="ln225">				best_rate_rix = rix;</a>
<a name="ln226">				best_rate_pct = pct;</a>
<a name="ln227">			}</a>
<a name="ln228">		}</a>
<a name="ln229"> </a>
<a name="ln230">		/*</a>
<a name="ln231">		 * Since 2 stream rates have slightly higher TX times,</a>
<a name="ln232">		 * allow a little bit of leeway. This should later</a>
<a name="ln233">		 * be abstracted out and properly handled.</a>
<a name="ln234">		 */</a>
<a name="ln235">		if (an-&gt;an_node.ni_flags &amp; IEEE80211_NODE_HT) {</a>
<a name="ln236">			if (best_rate_tt == 0 || (tt * 8 &lt;= best_rate_tt * 10)) {</a>
<a name="ln237">				best_rate_tt = tt;</a>
<a name="ln238">				best_rate_rix = rix;</a>
<a name="ln239">				best_rate_pct = pct;</a>
<a name="ln240">			}</a>
<a name="ln241">		}</a>
<a name="ln242">        }</a>
<a name="ln243">        return (best_rate_tt ? best_rate_rix : -1);</a>
<a name="ln244">}</a>
<a name="ln245"> </a>
<a name="ln246">/*</a>
<a name="ln247"> * Pick a good &quot;random&quot; bit-rate to sample other than the current one.</a>
<a name="ln248"> */</a>
<a name="ln249">static __inline int</a>
<a name="ln250">pick_sample_rate(struct sample_softc *ssc , struct ath_node *an,</a>
<a name="ln251">    const HAL_RATE_TABLE *rt, int size_bin)</a>
<a name="ln252">{</a>
<a name="ln253">#define	DOT11RATE(ix)	(rt-&gt;info[ix].dot11Rate &amp; IEEE80211_RATE_VAL)</a>
<a name="ln254">#define	MCS(ix)		(rt-&gt;info[ix].dot11Rate | IEEE80211_RATE_MCS)</a>
<a name="ln255">	struct sample_node *sn = ATH_NODE_SAMPLE(an);</a>
<a name="ln256">	int current_rix, rix;</a>
<a name="ln257">	unsigned current_tt;</a>
<a name="ln258">	uint64_t mask;</a>
<a name="ln259">	</a>
<a name="ln260">	current_rix = sn-&gt;current_rix[size_bin];</a>
<a name="ln261">	if (current_rix &lt; 0) {</a>
<a name="ln262">		/* no successes yet, send at the lowest bit-rate */</a>
<a name="ln263">		/* XXX should return MCS0 if HT */</a>
<a name="ln264">		return 0;</a>
<a name="ln265">	}</a>
<a name="ln266"> </a>
<a name="ln267">	current_tt = sn-&gt;stats[size_bin][current_rix].average_tx_time;</a>
<a name="ln268"> </a>
<a name="ln269">	rix = sn-&gt;last_sample_rix[size_bin]+1;	/* next sample rate */</a>
<a name="ln270">	mask = sn-&gt;ratemask &amp;~ ((uint64_t) 1&lt;&lt;current_rix);/* don't sample current rate */</a>
<a name="ln271">	while (mask != 0) {</a>
<a name="ln272">		if ((mask &amp; ((uint64_t) 1&lt;&lt;rix)) == 0) {	/* not a supported rate */</a>
<a name="ln273">	nextrate:</a>
<a name="ln274">			if (++rix &gt;= rt-&gt;rateCount)</a>
<a name="ln275">				rix = 0;</a>
<a name="ln276">			continue;</a>
<a name="ln277">		}</a>
<a name="ln278"> </a>
<a name="ln279">		/*</a>
<a name="ln280">		 * The following code stops trying to sample</a>
<a name="ln281">		 * non-MCS rates when speaking to an MCS node.</a>
<a name="ln282">		 * However, at least for CCK rates in 2.4GHz mode,</a>
<a name="ln283">		 * the non-MCS rates MAY actually provide better</a>
<a name="ln284">		 * PER at the very far edge of reception.</a>
<a name="ln285">		 *</a>
<a name="ln286">		 * However! Until ath_rate_form_aggr() grows</a>
<a name="ln287">		 * some logic to not form aggregates if the</a>
<a name="ln288">		 * selected rate is non-MCS, this won't work.</a>
<a name="ln289">		 *</a>
<a name="ln290">		 * So don't disable this code until you've taught</a>
<a name="ln291">		 * ath_rate_form_aggr() to drop out if any of</a>
<a name="ln292">		 * the selected rates are non-MCS.</a>
<a name="ln293">		 */</a>
<a name="ln294">#if 1</a>
<a name="ln295">		/* if the node is HT and the rate isn't HT, don't bother sample */</a>
<a name="ln296">		if ((an-&gt;an_node.ni_flags &amp; IEEE80211_NODE_HT) &amp;&amp;</a>
<a name="ln297">		    (rt-&gt;info[rix].phy != IEEE80211_T_HT)) {</a>
<a name="ln298">			mask &amp;= ~((uint64_t) 1&lt;&lt;rix);</a>
<a name="ln299">			goto nextrate;</a>
<a name="ln300">		}</a>
<a name="ln301">#endif</a>
<a name="ln302"> </a>
<a name="ln303">		/* this bit-rate is always worse than the current one */</a>
<a name="ln304">		if (sn-&gt;stats[size_bin][rix].perfect_tx_time &gt; current_tt) {</a>
<a name="ln305">			mask &amp;= ~((uint64_t) 1&lt;&lt;rix);</a>
<a name="ln306">			goto nextrate;</a>
<a name="ln307">		}</a>
<a name="ln308"> </a>
<a name="ln309">		/* rarely sample bit-rates that fail a lot */</a>
<a name="ln310">		if (sn-&gt;stats[size_bin][rix].successive_failures &gt; ssc-&gt;max_successive_failures &amp;&amp;</a>
<a name="ln311">		    ticks - sn-&gt;stats[size_bin][rix].last_tx &lt; ssc-&gt;stale_failure_timeout) {</a>
<a name="ln312">			mask &amp;= ~((uint64_t) 1&lt;&lt;rix);</a>
<a name="ln313">			goto nextrate;</a>
<a name="ln314">		}</a>
<a name="ln315"> </a>
<a name="ln316">		/*</a>
<a name="ln317">		 * For HT, only sample a few rates on either side of the</a>
<a name="ln318">		 * current rix; there's quite likely a lot of them.</a>
<a name="ln319">		 */</a>
<a name="ln320">		if (an-&gt;an_node.ni_flags &amp; IEEE80211_NODE_HT) {</a>
<a name="ln321">			if (rix &lt; (current_rix - 3) ||</a>
<a name="ln322">			    rix &gt; (current_rix + 3)) {</a>
<a name="ln323">				mask &amp;= ~((uint64_t) 1&lt;&lt;rix);</a>
<a name="ln324">				goto nextrate;</a>
<a name="ln325">			}</a>
<a name="ln326">		}</a>
<a name="ln327"> </a>
<a name="ln328">		/* Don't sample more than 2 rates higher for rates &gt; 11M for non-HT rates */</a>
<a name="ln329">		if (! (an-&gt;an_node.ni_flags &amp; IEEE80211_NODE_HT)) {</a>
<a name="ln330">			if (DOT11RATE(rix) &gt; 2*11 &amp;&amp; rix &gt; current_rix + 2) {</a>
<a name="ln331">				mask &amp;= ~((uint64_t) 1&lt;&lt;rix);</a>
<a name="ln332">				goto nextrate;</a>
<a name="ln333">			}</a>
<a name="ln334">		}</a>
<a name="ln335"> </a>
<a name="ln336">		sn-&gt;last_sample_rix[size_bin] = rix;</a>
<a name="ln337">		return rix;</a>
<a name="ln338">	}</a>
<a name="ln339">	return current_rix;</a>
<a name="ln340">#undef DOT11RATE</a>
<a name="ln341">#undef	MCS</a>
<a name="ln342">}</a>
<a name="ln343"> </a>
<a name="ln344">static int</a>
<a name="ln345">ath_rate_get_static_rix(struct ath_softc *sc, const struct ieee80211_node *ni)</a>
<a name="ln346">{</a>
<a name="ln347">#define	RATE(_ix)	(ni-&gt;ni_rates.rs_rates[(_ix)] &amp; IEEE80211_RATE_VAL)</a>
<a name="ln348">#define	DOT11RATE(_ix)	(rt-&gt;info[(_ix)].dot11Rate &amp; IEEE80211_RATE_VAL)</a>
<a name="ln349">#define	MCS(_ix)	(ni-&gt;ni_htrates.rs_rates[_ix] | IEEE80211_RATE_MCS)</a>
<a name="ln350">	const struct ieee80211_txparam *tp = ni-&gt;ni_txparms;</a>
<a name="ln351">	int srate;</a>
<a name="ln352"> </a>
<a name="ln353">	/* Check MCS rates */</a>
<a name="ln354">	for (srate = ni-&gt;ni_htrates.rs_nrates - 1; srate &gt;= 0; srate--) {</a>
<a name="ln355">		if (MCS(srate) == tp-&gt;ucastrate)</a>
<a name="ln356">			return sc-&gt;sc_rixmap[tp-&gt;ucastrate];</a>
<a name="ln357">	}</a>
<a name="ln358"> </a>
<a name="ln359">	/* Check legacy rates */</a>
<a name="ln360">	for (srate = ni-&gt;ni_rates.rs_nrates - 1; srate &gt;= 0; srate--) {</a>
<a name="ln361">		if (RATE(srate) == tp-&gt;ucastrate)</a>
<a name="ln362">			return sc-&gt;sc_rixmap[tp-&gt;ucastrate];</a>
<a name="ln363">	}</a>
<a name="ln364">	return -1;</a>
<a name="ln365">#undef	RATE</a>
<a name="ln366">#undef	DOT11RATE</a>
<a name="ln367">#undef	MCS</a>
<a name="ln368">}</a>
<a name="ln369"> </a>
<a name="ln370">static void</a>
<a name="ln371">ath_rate_update_static_rix(struct ath_softc *sc, struct ieee80211_node *ni)</a>
<a name="ln372">{</a>
<a name="ln373">	struct ath_node *an = ATH_NODE(ni);</a>
<a name="ln374">	const struct ieee80211_txparam *tp = ni-&gt;ni_txparms;</a>
<a name="ln375">	struct sample_node *sn = ATH_NODE_SAMPLE(an);</a>
<a name="ln376"> </a>
<a name="ln377">	if (tp != NULL &amp;&amp; tp-&gt;ucastrate != IEEE80211_FIXED_RATE_NONE) {</a>
<a name="ln378">		/*</a>
<a name="ln379">		 * A fixed rate is to be used; ucastrate is the IEEE code</a>
<a name="ln380">		 * for this rate (sans basic bit).  Check this against the</a>
<a name="ln381">		 * negotiated rate set for the node.  Note the fixed rate</a>
<a name="ln382">		 * may not be available for various reasons so we only</a>
<a name="ln383">		 * setup the static rate index if the lookup is successful.</a>
<a name="ln384">		 */</a>
<a name="ln385">		sn-&gt;static_rix = ath_rate_get_static_rix(sc, ni);</a>
<a name="ln386">	} else {</a>
<a name="ln387">		sn-&gt;static_rix = -1;</a>
<a name="ln388">	}</a>
<a name="ln389">}</a>
<a name="ln390"> </a>
<a name="ln391">/*</a>
<a name="ln392"> * Pick a non-HT rate to begin using.</a>
<a name="ln393"> */</a>
<a name="ln394">static int</a>
<a name="ln395">ath_rate_pick_seed_rate_legacy(struct ath_softc *sc, struct ath_node *an,</a>
<a name="ln396">    int frameLen)</a>
<a name="ln397">{</a>
<a name="ln398">#define	DOT11RATE(ix)	(rt-&gt;info[ix].dot11Rate &amp; IEEE80211_RATE_VAL)</a>
<a name="ln399">#define	MCS(ix)		(rt-&gt;info[ix].dot11Rate | IEEE80211_RATE_MCS)</a>
<a name="ln400">#define	RATE(ix)	(DOT11RATE(ix) / 2)</a>
<a name="ln401">	int rix = -1;</a>
<a name="ln402">	const HAL_RATE_TABLE *rt = sc-&gt;sc_currates;</a>
<a name="ln403">	struct sample_node *sn = ATH_NODE_SAMPLE(an);</a>
<a name="ln404">	const int size_bin = size_to_bin(frameLen);</a>
<a name="ln405"> </a>
<a name="ln406">	/* no packet has been sent successfully yet */</a>
<a name="ln407">	for (rix = rt-&gt;rateCount-1; rix &gt; 0; rix--) {</a>
<a name="ln408">		if ((sn-&gt;ratemask &amp; ((uint64_t) 1&lt;&lt;rix)) == 0)</a>
<a name="ln409">			continue;</a>
<a name="ln410"> </a>
<a name="ln411">		/* Skip HT rates */</a>
<a name="ln412">		if (rt-&gt;info[rix].phy == IEEE80211_T_HT)</a>
<a name="ln413">			continue;</a>
<a name="ln414"> </a>
<a name="ln415">		/*</a>
<a name="ln416">		 * Pick the highest rate &lt;= 36 Mbps</a>
<a name="ln417">		 * that hasn't failed.</a>
<a name="ln418">		 */</a>
<a name="ln419">		if (DOT11RATE(rix) &lt;= 72 &amp;&amp;</a>
<a name="ln420">		    sn-&gt;stats[size_bin][rix].successive_failures == 0) {</a>
<a name="ln421">			break;</a>
<a name="ln422">		}</a>
<a name="ln423">	}</a>
<a name="ln424">	return rix;</a>
<a name="ln425">#undef	RATE</a>
<a name="ln426">#undef	MCS</a>
<a name="ln427">#undef	DOT11RATE</a>
<a name="ln428">}</a>
<a name="ln429"> </a>
<a name="ln430">/*</a>
<a name="ln431"> * Pick a HT rate to begin using.</a>
<a name="ln432"> *</a>
<a name="ln433"> * Don't use any non-HT rates; only consider HT rates.</a>
<a name="ln434"> */</a>
<a name="ln435">static int</a>
<a name="ln436">ath_rate_pick_seed_rate_ht(struct ath_softc *sc, struct ath_node *an,</a>
<a name="ln437">    int frameLen)</a>
<a name="ln438">{</a>
<a name="ln439">#define	DOT11RATE(ix)	(rt-&gt;info[ix].dot11Rate &amp; IEEE80211_RATE_VAL)</a>
<a name="ln440">#define	MCS(ix)		(rt-&gt;info[ix].dot11Rate | IEEE80211_RATE_MCS)</a>
<a name="ln441">#define	RATE(ix)	(DOT11RATE(ix) / 2)</a>
<a name="ln442">	int rix = -1, ht_rix = -1;</a>
<a name="ln443">	const HAL_RATE_TABLE *rt = sc-&gt;sc_currates;</a>
<a name="ln444">	struct sample_node *sn = ATH_NODE_SAMPLE(an);</a>
<a name="ln445">	const int size_bin = size_to_bin(frameLen);</a>
<a name="ln446"> </a>
<a name="ln447">	/* no packet has been sent successfully yet */</a>
<a name="ln448">	for (rix = rt-&gt;rateCount-1; rix &gt; 0; rix--) {</a>
<a name="ln449">		/* Skip rates we can't use */</a>
<a name="ln450">		if ((sn-&gt;ratemask &amp; ((uint64_t) 1&lt;&lt;rix)) == 0)</a>
<a name="ln451">			continue;</a>
<a name="ln452"> </a>
<a name="ln453">		/* Keep a copy of the last seen HT rate index */</a>
<a name="ln454">		if (rt-&gt;info[rix].phy == IEEE80211_T_HT)</a>
<a name="ln455">			ht_rix = rix;</a>
<a name="ln456"> </a>
<a name="ln457">		/* Skip non-HT rates */</a>
<a name="ln458">		if (rt-&gt;info[rix].phy != IEEE80211_T_HT)</a>
<a name="ln459">			continue;</a>
<a name="ln460"> </a>
<a name="ln461">		/*</a>
<a name="ln462">		 * Pick a medium-speed rate regardless of stream count</a>
<a name="ln463">		 * which has not seen any failures. Higher rates may fail;</a>
<a name="ln464">		 * we'll try them later.</a>
<a name="ln465">		 */</a>
<a name="ln466">		if (((MCS(rix) &amp; 0x7) &lt;= 4) &amp;&amp;</a>
<a name="ln467">		    sn-&gt;stats[size_bin][rix].successive_failures == 0) {</a>
<a name="ln468">			break;</a>
<a name="ln469">		}</a>
<a name="ln470">	}</a>
<a name="ln471"> </a>
<a name="ln472">	/*</a>
<a name="ln473">	 * If all the MCS rates have successive failures, rix should be</a>
<a name="ln474">	 * &gt; 0; otherwise use the lowest MCS rix (hopefully MCS 0.)</a>
<a name="ln475">	 */</a>
<a name="ln476">	return MAX(rix, ht_rix);</a>
<a name="ln477">#undef	RATE</a>
<a name="ln478">#undef	MCS</a>
<a name="ln479">#undef	DOT11RATE</a>
<a name="ln480">}</a>
<a name="ln481"> </a>
<a name="ln482"> </a>
<a name="ln483">void</a>
<a name="ln484">ath_rate_findrate(struct ath_softc *sc, struct ath_node *an,</a>
<a name="ln485">		  int shortPreamble, size_t frameLen,</a>
<a name="ln486">		  u_int8_t *rix0, int *try0, u_int8_t *txrate)</a>
<a name="ln487">{</a>
<a name="ln488">#define	DOT11RATE(ix)	(rt-&gt;info[ix].dot11Rate &amp; IEEE80211_RATE_VAL)</a>
<a name="ln489">#define	MCS(ix)		(rt-&gt;info[ix].dot11Rate | IEEE80211_RATE_MCS)</a>
<a name="ln490">#define	RATE(ix)	(DOT11RATE(ix) / 2)</a>
<a name="ln491">	struct sample_node *sn = ATH_NODE_SAMPLE(an);</a>
<a name="ln492">	struct sample_softc *ssc = ATH_SOFTC_SAMPLE(sc);</a>
<a name="ln493">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln494">	const HAL_RATE_TABLE *rt = sc-&gt;sc_currates;</a>
<a name="ln495">	const int size_bin = size_to_bin(frameLen);</a>
<a name="ln496">	int rix, mrr, best_rix, change_rates;</a>
<a name="ln497">	unsigned average_tx_time;</a>
<a name="ln498"> </a>
<a name="ln499">	ath_rate_update_static_rix(sc, &amp;an-&gt;an_node);</a>
<a name="ln500"> </a>
<a name="ln501">	if (sn-&gt;currates != sc-&gt;sc_currates) {</a>
<a name="ln502">		device_printf(sc-&gt;sc_dev, &quot;%s: currates != sc_currates!\n&quot;,</a>
<a name="ln503">		    __func__);</a>
<a name="ln504">		rix = 0;</a>
<a name="ln505">		*try0 = ATH_TXMAXTRY;</a>
<a name="ln506">		goto done;</a>
<a name="ln507">	}</a>
<a name="ln508"> </a>
<a name="ln509">	if (sn-&gt;static_rix != -1) {</a>
<a name="ln510">		rix = sn-&gt;static_rix;</a>
<a name="ln511">		*try0 = ATH_TXMAXTRY;</a>
<a name="ln512">		goto done;</a>
<a name="ln513">	}</a>
<a name="ln514"> </a>
<a name="ln515">	mrr = sc-&gt;sc_mrretry;</a>
<a name="ln516">	/* XXX check HT protmode too */</a>
<a name="ln517">	if (mrr &amp;&amp; (ic-&gt;ic_flags &amp; IEEE80211_F_USEPROT &amp;&amp; !sc-&gt;sc_mrrprot))</a>
<a name="ln518">		mrr = 0;</a>
<a name="ln519"> </a>
<a name="ln520">	best_rix = pick_best_rate(an, rt, size_bin, !mrr);</a>
<a name="ln521">	if (best_rix &gt;= 0) {</a>
<a name="ln522">		average_tx_time = sn-&gt;stats[size_bin][best_rix].average_tx_time;</a>
<a name="ln523">	} else {</a>
<a name="ln524">		average_tx_time = 0;</a>
<a name="ln525">	}</a>
<a name="ln526">	/*</a>
<a name="ln527">	 * Limit the time measuring the performance of other tx</a>
<a name="ln528">	 * rates to sample_rate% of the total transmission time.</a>
<a name="ln529">	 */</a>
<a name="ln530">	if (sn-&gt;sample_tt[size_bin] &lt; average_tx_time * (sn-&gt;packets_since_sample[size_bin]*ssc-&gt;sample_rate/100)) {</a>
<a name="ln531">		rix = pick_sample_rate(ssc, an, rt, size_bin);</a>
<a name="ln532">		IEEE80211_NOTE(an-&gt;an_node.ni_vap, IEEE80211_MSG_RATECTL,</a>
<a name="ln533">		     &amp;an-&gt;an_node, &quot;att %d sample_tt %d size %u sample rate %d %s current rate %d %s&quot;,</a>
<a name="ln534">		     average_tx_time,</a>
<a name="ln535">		     sn-&gt;sample_tt[size_bin],</a>
<a name="ln536">		     bin_to_size(size_bin),</a>
<a name="ln537">		     dot11rate(rt, rix),</a>
<a name="ln538">		     dot11rate_label(rt, rix),</a>
<a name="ln539">		     dot11rate(rt, sn-&gt;current_rix[size_bin]),</a>
<a name="ln540">		     dot11rate_label(rt, sn-&gt;current_rix[size_bin]));</a>
<a name="ln541">		if (rix != sn-&gt;current_rix[size_bin]) {</a>
<a name="ln542">			sn-&gt;current_sample_rix[size_bin] = rix;</a>
<a name="ln543">		} else {</a>
<a name="ln544">			sn-&gt;current_sample_rix[size_bin] = -1;</a>
<a name="ln545">		}</a>
<a name="ln546">		sn-&gt;packets_since_sample[size_bin] = 0;</a>
<a name="ln547">	} else {</a>
<a name="ln548">		change_rates = 0;</a>
<a name="ln549">		if (!sn-&gt;packets_sent[size_bin] || best_rix == -1) {</a>
<a name="ln550">			/* no packet has been sent successfully yet */</a>
<a name="ln551">			change_rates = 1;</a>
<a name="ln552">			if (an-&gt;an_node.ni_flags &amp; IEEE80211_NODE_HT)</a>
<a name="ln553">				best_rix =</a>
<a name="ln554">				    ath_rate_pick_seed_rate_ht(sc, an, frameLen);</a>
<a name="ln555">			else</a>
<a name="ln556">				best_rix =</a>
<a name="ln557">				    ath_rate_pick_seed_rate_legacy(sc, an, frameLen);</a>
<a name="ln558">		} else if (sn-&gt;packets_sent[size_bin] &lt; 20) {</a>
<a name="ln559">			/* let the bit-rate switch quickly during the first few packets */</a>
<a name="ln560">			IEEE80211_NOTE(an-&gt;an_node.ni_vap,</a>
<a name="ln561">			    IEEE80211_MSG_RATECTL, &amp;an-&gt;an_node,</a>
<a name="ln562">			    &quot;%s: switching quickly..&quot;, __func__);</a>
<a name="ln563">			change_rates = 1;</a>
<a name="ln564">		} else if (ticks - ssc-&gt;min_switch &gt; sn-&gt;ticks_since_switch[size_bin]) {</a>
<a name="ln565">			/* min_switch seconds have gone by */</a>
<a name="ln566">			IEEE80211_NOTE(an-&gt;an_node.ni_vap,</a>
<a name="ln567">			    IEEE80211_MSG_RATECTL, &amp;an-&gt;an_node,</a>
<a name="ln568">			    &quot;%s: min_switch %d &gt; ticks_since_switch %d..&quot;,</a>
<a name="ln569">			    __func__, ticks - ssc-&gt;min_switch, sn-&gt;ticks_since_switch[size_bin]);</a>
<a name="ln570">			change_rates = 1;</a>
<a name="ln571">		} else if ((! (an-&gt;an_node.ni_flags &amp; IEEE80211_NODE_HT)) &amp;&amp;</a>
<a name="ln572">		    (2*average_tx_time &lt; sn-&gt;stats[size_bin][sn-&gt;current_rix[size_bin]].average_tx_time)) {</a>
<a name="ln573">			/* the current bit-rate is twice as slow as the best one */</a>
<a name="ln574">			IEEE80211_NOTE(an-&gt;an_node.ni_vap,</a>
<a name="ln575">			    IEEE80211_MSG_RATECTL, &amp;an-&gt;an_node,</a>
<a name="ln576">			    &quot;%s: 2x att (= %d) &lt; cur_rix att %d&quot;,</a>
<a name="ln577">			    __func__,</a>
<a name="ln578">			    2 * average_tx_time, sn-&gt;stats[size_bin][sn-&gt;current_rix[size_bin]].average_tx_time);</a>
<a name="ln579">			change_rates = 1;</a>
<a name="ln580">		} else if ((an-&gt;an_node.ni_flags &amp; IEEE80211_NODE_HT)) {</a>
<a name="ln581">			int cur_rix = sn-&gt;current_rix[size_bin];</a>
<a name="ln582">			int cur_att = sn-&gt;stats[size_bin][cur_rix].average_tx_time;</a>
<a name="ln583">			/*</a>
<a name="ln584">			 * If the node is HT, upgrade it if the MCS rate is</a>
<a name="ln585">			 * higher and the average tx time is within 20% of</a>
<a name="ln586">			 * the current rate. It can fail a little.</a>
<a name="ln587">			 *</a>
<a name="ln588">			 * This is likely not optimal!</a>
<a name="ln589">			 */</a>
<a name="ln590">#if 0</a>
<a name="ln591">			printf(&quot;cur rix/att %x/%d, best rix/att %x/%d\n&quot;,</a>
<a name="ln592">			    MCS(cur_rix), cur_att, MCS(best_rix), average_tx_time);</a>
<a name="ln593">#endif</a>
<a name="ln594">			if ((MCS(best_rix) &gt; MCS(cur_rix)) &amp;&amp;</a>
<a name="ln595">			    (average_tx_time * 8) &lt;= (cur_att * 10)) {</a>
<a name="ln596">				IEEE80211_NOTE(an-&gt;an_node.ni_vap,</a>
<a name="ln597">				    IEEE80211_MSG_RATECTL, &amp;an-&gt;an_node,</a>
<a name="ln598">				    &quot;%s: HT: best_rix 0x%d &gt; cur_rix 0x%x, average_tx_time %d, cur_att %d&quot;,</a>
<a name="ln599">				    __func__,</a>
<a name="ln600">				    MCS(best_rix), MCS(cur_rix), average_tx_time, cur_att);</a>
<a name="ln601">				change_rates = 1;</a>
<a name="ln602">			}</a>
<a name="ln603">		}</a>
<a name="ln604"> </a>
<a name="ln605">		sn-&gt;packets_since_sample[size_bin]++;</a>
<a name="ln606">		</a>
<a name="ln607">		if (change_rates) {</a>
<a name="ln608">			if (best_rix != sn-&gt;current_rix[size_bin]) {</a>
<a name="ln609">				IEEE80211_NOTE(an-&gt;an_node.ni_vap,</a>
<a name="ln610">				    IEEE80211_MSG_RATECTL,</a>
<a name="ln611">				    &amp;an-&gt;an_node,</a>
<a name="ln612">&quot;%s: size %d switch rate %d (%d/%d) -&gt; %d (%d/%d) after %d packets mrr %d&quot;,</a>
<a name="ln613">				    __func__,</a>
<a name="ln614">				    bin_to_size(size_bin),</a>
<a name="ln615">				    RATE(sn-&gt;current_rix[size_bin]),</a>
<a name="ln616">				    sn-&gt;stats[size_bin][sn-&gt;current_rix[size_bin]].average_tx_time,</a>
<a name="ln617">				    sn-&gt;stats[size_bin][sn-&gt;current_rix[size_bin]].perfect_tx_time,</a>
<a name="ln618">				    RATE(best_rix),</a>
<a name="ln619">				    sn-&gt;stats[size_bin][best_rix].average_tx_time,</a>
<a name="ln620">				    sn-&gt;stats[size_bin][best_rix].perfect_tx_time,</a>
<a name="ln621">				    sn-&gt;packets_since_switch[size_bin],</a>
<a name="ln622">				    mrr);</a>
<a name="ln623">			}</a>
<a name="ln624">			sn-&gt;packets_since_switch[size_bin] = 0;</a>
<a name="ln625">			sn-&gt;current_rix[size_bin] = best_rix;</a>
<a name="ln626">			sn-&gt;ticks_since_switch[size_bin] = ticks;</a>
<a name="ln627">			/* </a>
<a name="ln628">			 * Set the visible txrate for this node.</a>
<a name="ln629">			 */</a>
<a name="ln630">			an-&gt;an_node.ni_txrate = (rt-&gt;info[best_rix].phy == IEEE80211_T_HT) ?  MCS(best_rix) : DOT11RATE(best_rix);</a>
<a name="ln631">		}</a>
<a name="ln632">		rix = sn-&gt;current_rix[size_bin];</a>
<a name="ln633">		sn-&gt;packets_since_switch[size_bin]++;</a>
<a name="ln634">	}</a>
<a name="ln635">	*try0 = mrr ? sn-&gt;sched[rix].t0 : ATH_TXMAXTRY;</a>
<a name="ln636">done:</a>
<a name="ln637"> </a>
<a name="ln638">	/*</a>
<a name="ln639">	 * This bug totally sucks and should be fixed.</a>
<a name="ln640">	 *</a>
<a name="ln641">	 * For now though, let's not panic, so we can start to figure</a>
<a name="ln642">	 * out how to better reproduce it.</a>
<a name="ln643">	 */</a>
<a name="ln644">	if (rix &lt; 0 || rix &gt;= rt-&gt;rateCount) {</a>
<a name="ln645">		printf(&quot;%s: ERROR: rix %d out of bounds (rateCount=%d)\n&quot;,</a>
<a name="ln646">		    __func__,</a>
<a name="ln647">		    rix,</a>
<a name="ln648">		    rt-&gt;rateCount);</a>
<a name="ln649">		    rix = 0;	/* XXX just default for now */</a>
<a name="ln650">	}</a>
<a name="ln651">	KASSERT(rix &gt;= 0 &amp;&amp; rix &lt; rt-&gt;rateCount, (&quot;rix is %d&quot;, rix));</a>
<a name="ln652"> </a>
<a name="ln653">	*rix0 = rix;</a>
<a name="ln654">	*txrate = rt-&gt;info[rix].rateCode</a>
<a name="ln655">		| (shortPreamble ? rt-&gt;info[rix].shortPreamble : 0);</a>
<a name="ln656">	sn-&gt;packets_sent[size_bin]++;</a>
<a name="ln657">#undef DOT11RATE</a>
<a name="ln658">#undef MCS</a>
<a name="ln659">#undef RATE</a>
<a name="ln660">}</a>
<a name="ln661"> </a>
<a name="ln662">/*</a>
<a name="ln663"> * Get the TX rates. Don't fiddle with short preamble flags for them;</a>
<a name="ln664"> * the caller can do that.</a>
<a name="ln665"> */</a>
<a name="ln666">void</a>
<a name="ln667">ath_rate_getxtxrates(struct ath_softc *sc, struct ath_node *an,</a>
<a name="ln668">    uint8_t rix0, struct ath_rc_series *rc)</a>
<a name="ln669">{</a>
<a name="ln670">	struct sample_node *sn = ATH_NODE_SAMPLE(an);</a>
<a name="ln671">	const struct txschedule *sched = &amp;sn-&gt;sched[rix0];</a>
<a name="ln672"> </a>
<a name="ln673">	KASSERT(rix0 == sched-&gt;r0, (&quot;rix0 (%x) != sched-&gt;r0 (%x)!\n&quot;,</a>
<a name="ln674">	    rix0, sched-&gt;r0));</a>
<a name="ln675"> </a>
<a name="ln676">	rc[0].flags = rc[1].flags = rc[2].flags = rc[3].flags = 0;</a>
<a name="ln677"> </a>
<a name="ln678">	rc[0].rix = sched-&gt;r0;</a>
<a name="ln679">	rc[1].rix = sched-&gt;r1;</a>
<a name="ln680">	rc[2].rix = sched-&gt;r2;</a>
<a name="ln681">	rc[3].rix = sched-&gt;r3;</a>
<a name="ln682"> </a>
<a name="ln683">	rc[0].tries = sched-&gt;t0;</a>
<a name="ln684">	rc[1].tries = sched-&gt;t1;</a>
<a name="ln685">	rc[2].tries = sched-&gt;t2;</a>
<a name="ln686">	rc[3].tries = sched-&gt;t3;</a>
<a name="ln687">}</a>
<a name="ln688"> </a>
<a name="ln689">void</a>
<a name="ln690">ath_rate_setupxtxdesc(struct ath_softc *sc, struct ath_node *an,</a>
<a name="ln691">		      struct ath_desc *ds, int shortPreamble, u_int8_t rix)</a>
<a name="ln692">{</a>
<a name="ln693">	struct sample_node *sn = ATH_NODE_SAMPLE(an);</a>
<a name="ln694">	const struct txschedule *sched = &amp;sn-&gt;sched[rix];</a>
<a name="ln695">	const HAL_RATE_TABLE *rt = sc-&gt;sc_currates;</a>
<a name="ln696">	uint8_t rix1, s1code, rix2, s2code, rix3, s3code;</a>
<a name="ln697"> </a>
<a name="ln698">	/* XXX precalculate short preamble tables */</a>
<a name="ln699">	rix1 = sched-&gt;r1;</a>
<a name="ln700">	s1code = rt-&gt;info[rix1].rateCode</a>
<a name="ln701">	       | (shortPreamble ? rt-&gt;info[rix1].shortPreamble : 0);</a>
<a name="ln702">	rix2 = sched-&gt;r2;</a>
<a name="ln703">	s2code = rt-&gt;info[rix2].rateCode</a>
<a name="ln704">	       | (shortPreamble ? rt-&gt;info[rix2].shortPreamble : 0);</a>
<a name="ln705">	rix3 = sched-&gt;r3;</a>
<a name="ln706">	s3code = rt-&gt;info[rix3].rateCode</a>
<a name="ln707">	       | (shortPreamble ? rt-&gt;info[rix3].shortPreamble : 0);</a>
<a name="ln708">	ath_hal_setupxtxdesc(sc-&gt;sc_ah, ds,</a>
<a name="ln709">	    s1code, sched-&gt;t1,		/* series 1 */</a>
<a name="ln710">	    s2code, sched-&gt;t2,		/* series 2 */</a>
<a name="ln711">	    s3code, sched-&gt;t3);		/* series 3 */</a>
<a name="ln712">}</a>
<a name="ln713"> </a>
<a name="ln714">static void</a>
<a name="ln715">update_stats(struct ath_softc *sc, struct ath_node *an, </a>
<a name="ln716">		  int frame_size,</a>
<a name="ln717">		  int rix0, int tries0,</a>
<a name="ln718">		  int rix1, int tries1,</a>
<a name="ln719">		  int rix2, int tries2,</a>
<a name="ln720">		  int rix3, int tries3,</a>
<a name="ln721">		  int short_tries, int tries, int status,</a>
<a name="ln722">		  int nframes, int nbad)</a>
<a name="ln723">{</a>
<a name="ln724">	struct sample_node *sn = ATH_NODE_SAMPLE(an);</a>
<a name="ln725">	struct sample_softc *ssc = ATH_SOFTC_SAMPLE(sc);</a>
<a name="ln726">#ifdef IEEE80211_DEBUG</a>
<a name="ln727">	const HAL_RATE_TABLE *rt = sc-&gt;sc_currates;</a>
<a name="ln728">#endif</a>
<a name="ln729">	const int size_bin = size_to_bin(frame_size);</a>
<a name="ln730">	const int size = bin_to_size(size_bin);</a>
<a name="ln731">	int tt, tries_so_far;</a>
<a name="ln732">	int is_ht40 = (an-&gt;an_node.ni_chw == 40);</a>
<a name="ln733">	int pct;</a>
<a name="ln734"> </a>
<a name="ln735">	if (!IS_RATE_DEFINED(sn, rix0))</a>
<a name="ln736">		return;</a>
<a name="ln737">	tt = calc_usecs_unicast_packet(sc, size, rix0, short_tries,</a>
<a name="ln738">		MIN(tries0, tries) - 1, is_ht40);</a>
<a name="ln739">	tries_so_far = tries0;</a>
<a name="ln740"> </a>
<a name="ln741">	if (tries1 &amp;&amp; tries_so_far &lt; tries) {</a>
<a name="ln742">		if (!IS_RATE_DEFINED(sn, rix1))</a>
<a name="ln743">			return;</a>
<a name="ln744">		tt += calc_usecs_unicast_packet(sc, size, rix1, short_tries,</a>
<a name="ln745">			MIN(tries1 + tries_so_far, tries) - tries_so_far - 1, is_ht40);</a>
<a name="ln746">		tries_so_far += tries1;</a>
<a name="ln747">	}</a>
<a name="ln748"> </a>
<a name="ln749">	if (tries2 &amp;&amp; tries_so_far &lt; tries) {</a>
<a name="ln750">		if (!IS_RATE_DEFINED(sn, rix2))</a>
<a name="ln751">			return;</a>
<a name="ln752">		tt += calc_usecs_unicast_packet(sc, size, rix2, short_tries,</a>
<a name="ln753">			MIN(tries2 + tries_so_far, tries) - tries_so_far - 1, is_ht40);</a>
<a name="ln754">		tries_so_far += tries2;</a>
<a name="ln755">	}</a>
<a name="ln756"> </a>
<a name="ln757">	if (tries3 &amp;&amp; tries_so_far &lt; tries) {</a>
<a name="ln758">		if (!IS_RATE_DEFINED(sn, rix3))</a>
<a name="ln759">			return;</a>
<a name="ln760">		tt += calc_usecs_unicast_packet(sc, size, rix3, short_tries,</a>
<a name="ln761">			MIN(tries3 + tries_so_far, tries) - tries_so_far - 1, is_ht40);</a>
<a name="ln762">	}</a>
<a name="ln763"> </a>
<a name="ln764">	if (sn-&gt;stats[size_bin][rix0].total_packets &lt; ssc-&gt;smoothing_minpackets) {</a>
<a name="ln765">		/* just average the first few packets */</a>
<a name="ln766">		int avg_tx = sn-&gt;stats[size_bin][rix0].average_tx_time;</a>
<a name="ln767">		int packets = sn-&gt;stats[size_bin][rix0].total_packets;</a>
<a name="ln768">		sn-&gt;stats[size_bin][rix0].average_tx_time = (tt+(avg_tx*packets))/(packets+nframes);</a>
<a name="ln769">	} else {</a>
<a name="ln770">		/* use a ewma */</a>
<a name="ln771">		sn-&gt;stats[size_bin][rix0].average_tx_time = </a>
<a name="ln772">			((sn-&gt;stats[size_bin][rix0].average_tx_time * ssc-&gt;smoothing_rate) + </a>
<a name="ln773">			 (tt * (100 - ssc-&gt;smoothing_rate))) / 100;</a>
<a name="ln774">	}</a>
<a name="ln775">	</a>
<a name="ln776">	/*</a>
<a name="ln777">	 * XXX Don't mark the higher bit rates as also having failed; as this</a>
<a name="ln778">	 * unfortunately stops those rates from being tasted when trying to</a>
<a name="ln779">	 * TX. This happens with 11n aggregation.</a>
<a name="ln780">	 *</a>
<a name="ln781">	 * This is valid for higher CCK rates, higher OFDM rates, and higher</a>
<a name="ln782">	 * HT rates within the current number of streams (eg MCS0..7, 8..15,</a>
<a name="ln783">	 * etc.)</a>
<a name="ln784">	 */</a>
<a name="ln785">	if (nframes == nbad) {</a>
<a name="ln786">#if 0</a>
<a name="ln787">		int y;</a>
<a name="ln788">#endif</a>
<a name="ln789">		sn-&gt;stats[size_bin][rix0].successive_failures += nbad;</a>
<a name="ln790">#if 0</a>
<a name="ln791">		for (y = size_bin+1; y &lt; NUM_PACKET_SIZE_BINS; y++) {</a>
<a name="ln792">			/*</a>
<a name="ln793">			 * Also say larger packets failed since we</a>
<a name="ln794">			 * assume if a small packet fails at a</a>
<a name="ln795">			 * bit-rate then a larger one will also.</a>
<a name="ln796">			 */</a>
<a name="ln797">			sn-&gt;stats[y][rix0].successive_failures += nbad;</a>
<a name="ln798">			sn-&gt;stats[y][rix0].last_tx = ticks;</a>
<a name="ln799">			sn-&gt;stats[y][rix0].tries += tries;</a>
<a name="ln800">			sn-&gt;stats[y][rix0].total_packets += nframes;</a>
<a name="ln801">		}</a>
<a name="ln802">#endif</a>
<a name="ln803">	} else {</a>
<a name="ln804">		sn-&gt;stats[size_bin][rix0].packets_acked += (nframes - nbad);</a>
<a name="ln805">		sn-&gt;stats[size_bin][rix0].successive_failures = 0;</a>
<a name="ln806">	}</a>
<a name="ln807">	sn-&gt;stats[size_bin][rix0].tries += tries;</a>
<a name="ln808">	sn-&gt;stats[size_bin][rix0].last_tx = ticks;</a>
<a name="ln809">	sn-&gt;stats[size_bin][rix0].total_packets += nframes;</a>
<a name="ln810"> </a>
<a name="ln811">	/* update EWMA for this rix */</a>
<a name="ln812"> </a>
<a name="ln813">	/* Calculate percentage based on current rate */</a>
<a name="ln814">	if (nframes == 0)</a>
<a name="ln815">		nframes = nbad = 1;</a>
<a name="ln816">	pct = ((nframes - nbad) * 1000) / nframes;</a>
<a name="ln817"> </a>
<a name="ln818">	if (sn-&gt;stats[size_bin][rix0].total_packets &lt;</a>
<a name="ln819">	    ssc-&gt;smoothing_minpackets) {</a>
<a name="ln820">		/* just average the first few packets */</a>
<a name="ln821">		int a_pct = (sn-&gt;stats[size_bin][rix0].packets_acked * 1000) /</a>
<a name="ln822">		    (sn-&gt;stats[size_bin][rix0].total_packets);</a>
<a name="ln823">		sn-&gt;stats[size_bin][rix0].ewma_pct = a_pct;</a>
<a name="ln824">	} else {</a>
<a name="ln825">		/* use a ewma */</a>
<a name="ln826">		sn-&gt;stats[size_bin][rix0].ewma_pct =</a>
<a name="ln827">			((sn-&gt;stats[size_bin][rix0].ewma_pct * ssc-&gt;smoothing_rate) +</a>
<a name="ln828">			 (pct * (100 - ssc-&gt;smoothing_rate))) / 100;</a>
<a name="ln829">	}</a>
<a name="ln830"> </a>
<a name="ln831"> </a>
<a name="ln832">	if (rix0 == sn-&gt;current_sample_rix[size_bin]) {</a>
<a name="ln833">		IEEE80211_NOTE(an-&gt;an_node.ni_vap, IEEE80211_MSG_RATECTL,</a>
<a name="ln834">		   &amp;an-&gt;an_node,</a>
<a name="ln835">&quot;%s: size %d %s sample rate %d %s tries (%d/%d) tt %d avg_tt (%d/%d) nfrm %d nbad %d&quot;, </a>
<a name="ln836">		    __func__, </a>
<a name="ln837">		    size,</a>
<a name="ln838">		    status ? &quot;FAIL&quot; : &quot;OK&quot;,</a>
<a name="ln839">		    dot11rate(rt, rix0),</a>
<a name="ln840">		    dot11rate_label(rt, rix0),</a>
<a name="ln841">		    short_tries, tries, tt, </a>
<a name="ln842">		    sn-&gt;stats[size_bin][rix0].average_tx_time,</a>
<a name="ln843">		    sn-&gt;stats[size_bin][rix0].perfect_tx_time,</a>
<a name="ln844">		    nframes, nbad);</a>
<a name="ln845">		sn-&gt;sample_tt[size_bin] = tt;</a>
<a name="ln846">		sn-&gt;current_sample_rix[size_bin] = -1;</a>
<a name="ln847">	}</a>
<a name="ln848">}</a>
<a name="ln849"> </a>
<a name="ln850">static void</a>
<a name="ln851">badrate(struct ath_softc *sc, int series, int hwrate, int tries, int status)</a>
<a name="ln852">{</a>
<a name="ln853"> </a>
<a name="ln854">	device_printf(sc-&gt;sc_dev,</a>
<a name="ln855">	    &quot;bad series%d hwrate 0x%x, tries %u ts_status 0x%x\n&quot;,</a>
<a name="ln856">	    series, hwrate, tries, status);</a>
<a name="ln857">}</a>
<a name="ln858"> </a>
<a name="ln859">void</a>
<a name="ln860">ath_rate_tx_complete(struct ath_softc *sc, struct ath_node *an,</a>
<a name="ln861">	const struct ath_rc_series *rc, const struct ath_tx_status *ts,</a>
<a name="ln862">	int frame_size, int nframes, int nbad)</a>
<a name="ln863">{</a>
<a name="ln864">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln865">	struct sample_node *sn = ATH_NODE_SAMPLE(an);</a>
<a name="ln866">	int final_rix, short_tries, long_tries;</a>
<a name="ln867">	const HAL_RATE_TABLE *rt = sc-&gt;sc_currates;</a>
<a name="ln868">	int status = ts-&gt;ts_status;</a>
<a name="ln869">	int mrr;</a>
<a name="ln870"> </a>
<a name="ln871">	final_rix = rt-&gt;rateCodeToIndex[ts-&gt;ts_rate];</a>
<a name="ln872">	short_tries = ts-&gt;ts_shortretry;</a>
<a name="ln873">	long_tries = ts-&gt;ts_longretry + 1;</a>
<a name="ln874"> </a>
<a name="ln875">	if (nframes == 0) {</a>
<a name="ln876">		device_printf(sc-&gt;sc_dev, &quot;%s: nframes=0?\n&quot;, __func__);</a>
<a name="ln877">		return;</a>
<a name="ln878">	}</a>
<a name="ln879"> </a>
<a name="ln880">	if (frame_size == 0)		    /* NB: should not happen */</a>
<a name="ln881">		frame_size = 1500;</a>
<a name="ln882"> </a>
<a name="ln883">	if (sn-&gt;ratemask == 0) {</a>
<a name="ln884">		IEEE80211_NOTE(an-&gt;an_node.ni_vap, IEEE80211_MSG_RATECTL,</a>
<a name="ln885">		    &amp;an-&gt;an_node,</a>
<a name="ln886">		    &quot;%s: size %d %s rate/try %d/%d no rates yet&quot;, </a>
<a name="ln887">		    __func__,</a>
<a name="ln888">		    bin_to_size(size_to_bin(frame_size)),</a>
<a name="ln889">		    status ? &quot;FAIL&quot; : &quot;OK&quot;,</a>
<a name="ln890">		    short_tries, long_tries);</a>
<a name="ln891">		return;</a>
<a name="ln892">	}</a>
<a name="ln893">	mrr = sc-&gt;sc_mrretry;</a>
<a name="ln894">	/* XXX check HT protmode too */</a>
<a name="ln895">	if (mrr &amp;&amp; (ic-&gt;ic_flags &amp; IEEE80211_F_USEPROT &amp;&amp; !sc-&gt;sc_mrrprot))</a>
<a name="ln896">		mrr = 0;</a>
<a name="ln897"> </a>
<a name="ln898">	if (!mrr || ts-&gt;ts_finaltsi == 0) {</a>
<a name="ln899">		if (!IS_RATE_DEFINED(sn, final_rix)) {</a>
<a name="ln900">			device_printf(sc-&gt;sc_dev,</a>
<a name="ln901">			    &quot;%s: ts_rate=%d ts_finaltsi=%d, final_rix=%d\n&quot;,</a>
<a name="ln902">			    __func__, ts-&gt;ts_rate, ts-&gt;ts_finaltsi, final_rix);</a>
<a name="ln903">			badrate(sc, 0, ts-&gt;ts_rate, long_tries, status);</a>
<a name="ln904">			return;</a>
<a name="ln905">		}</a>
<a name="ln906">		/*</a>
<a name="ln907">		 * Only one rate was used; optimize work.</a>
<a name="ln908">		 */</a>
<a name="ln909">		IEEE80211_NOTE(an-&gt;an_node.ni_vap, IEEE80211_MSG_RATECTL,</a>
<a name="ln910">		     &amp;an-&gt;an_node, &quot;%s: size %d (%d bytes) %s rate/short/long %d %s/%d/%d nframes/nbad [%d/%d]&quot;,</a>
<a name="ln911">		     __func__,</a>
<a name="ln912">		     bin_to_size(size_to_bin(frame_size)),</a>
<a name="ln913">		     frame_size,</a>
<a name="ln914">		     status ? &quot;FAIL&quot; : &quot;OK&quot;,</a>
<a name="ln915">		     dot11rate(rt, final_rix), dot11rate_label(rt, final_rix),</a>
<a name="ln916">		     short_tries, long_tries, nframes, nbad);</a>
<a name="ln917">		update_stats(sc, an, frame_size, </a>
<a name="ln918">			     final_rix, long_tries,</a>
<a name="ln919">			     0, 0,</a>
<a name="ln920">			     0, 0,</a>
<a name="ln921">			     0, 0,</a>
<a name="ln922">			     short_tries, long_tries, status,</a>
<a name="ln923">			     nframes, nbad);</a>
<a name="ln924"> </a>
<a name="ln925">	} else {</a>
<a name="ln926">		int finalTSIdx = ts-&gt;ts_finaltsi;</a>
<a name="ln927">		int i;</a>
<a name="ln928"> </a>
<a name="ln929">		/*</a>
<a name="ln930">		 * Process intermediate rates that failed.</a>
<a name="ln931">		 */</a>
<a name="ln932"> </a>
<a name="ln933">		IEEE80211_NOTE(an-&gt;an_node.ni_vap, IEEE80211_MSG_RATECTL,</a>
<a name="ln934">		    &amp;an-&gt;an_node,</a>
<a name="ln935">&quot;%s: size %d (%d bytes) finaltsidx %d short %d long %d %s rate/try [%d %s/%d %d %s/%d %d %s/%d %d %s/%d] nframes/nbad [%d/%d]&quot;, </a>
<a name="ln936">		     __func__,</a>
<a name="ln937">		     bin_to_size(size_to_bin(frame_size)),</a>
<a name="ln938">		     frame_size,</a>
<a name="ln939">		     finalTSIdx,</a>
<a name="ln940">		     short_tries,</a>
<a name="ln941">		     long_tries,</a>
<a name="ln942">		     status ? &quot;FAIL&quot; : &quot;OK&quot;,</a>
<a name="ln943">		     dot11rate(rt, rc[0].rix),</a>
<a name="ln944">		      dot11rate_label(rt, rc[0].rix), rc[0].tries,</a>
<a name="ln945">		     dot11rate(rt, rc[1].rix),</a>
<a name="ln946">		      dot11rate_label(rt, rc[1].rix), rc[1].tries,</a>
<a name="ln947">		     dot11rate(rt, rc[2].rix),</a>
<a name="ln948">		      dot11rate_label(rt, rc[2].rix), rc[2].tries,</a>
<a name="ln949">		     dot11rate(rt, rc[3].rix),</a>
<a name="ln950">		      dot11rate_label(rt, rc[3].rix), rc[3].tries,</a>
<a name="ln951">		     nframes, nbad);</a>
<a name="ln952"> </a>
<a name="ln953">		for (i = 0; i &lt; 4; i++) {</a>
<a name="ln954">			if (rc[i].tries &amp;&amp; !IS_RATE_DEFINED(sn, rc[i].rix))</a>
<a name="ln955">				badrate(sc, 0, rc[i].ratecode, rc[i].tries,</a>
<a name="ln956">				    status);</a>
<a name="ln957">		}</a>
<a name="ln958"> </a>
<a name="ln959">		/*</a>
<a name="ln960">		 * NB: series &gt; 0 are not penalized for failure</a>
<a name="ln961">		 * based on the try counts under the assumption</a>
<a name="ln962">		 * that losses are often bursty and since we</a>
<a name="ln963">		 * sample higher rates 1 try at a time doing so</a>
<a name="ln964">		 * may unfairly penalize them.</a>
<a name="ln965">		 */</a>
<a name="ln966">		if (rc[0].tries) {</a>
<a name="ln967">			update_stats(sc, an, frame_size,</a>
<a name="ln968">				     rc[0].rix, rc[0].tries,</a>
<a name="ln969">				     rc[1].rix, rc[1].tries,</a>
<a name="ln970">				     rc[2].rix, rc[2].tries,</a>
<a name="ln971">				     rc[3].rix, rc[3].tries,</a>
<a name="ln972">				     short_tries, long_tries,</a>
<a name="ln973">				     long_tries &gt; rc[0].tries,</a>
<a name="ln974">				     nframes, nbad);</a>
<a name="ln975">			long_tries -= rc[0].tries;</a>
<a name="ln976">		}</a>
<a name="ln977">		</a>
<a name="ln978">		if (rc[1].tries &amp;&amp; finalTSIdx &gt; 0) {</a>
<a name="ln979">			update_stats(sc, an, frame_size,</a>
<a name="ln980">				     rc[1].rix, rc[1].tries,</a>
<a name="ln981">				     rc[2].rix, rc[2].tries,</a>
<a name="ln982">				     rc[3].rix, rc[3].tries,</a>
<a name="ln983">				     0, 0,</a>
<a name="ln984">				     short_tries, long_tries,</a>
<a name="ln985">				     status,</a>
<a name="ln986">				     nframes, nbad);</a>
<a name="ln987">			long_tries -= rc[1].tries;</a>
<a name="ln988">		}</a>
<a name="ln989"> </a>
<a name="ln990">		if (rc[2].tries &amp;&amp; finalTSIdx &gt; 1) {</a>
<a name="ln991">			update_stats(sc, an, frame_size,</a>
<a name="ln992">				     rc[2].rix, rc[2].tries,</a>
<a name="ln993">				     rc[3].rix, rc[3].tries,</a>
<a name="ln994">				     0, 0,</a>
<a name="ln995">				     0, 0,</a>
<a name="ln996">				     short_tries, long_tries,</a>
<a name="ln997">				     status,</a>
<a name="ln998">				     nframes, nbad);</a>
<a name="ln999">			long_tries -= rc[2].tries;</a>
<a name="ln1000">		}</a>
<a name="ln1001"> </a>
<a name="ln1002">		if (rc[3].tries &amp;&amp; finalTSIdx &gt; 2) {</a>
<a name="ln1003">			update_stats(sc, an, frame_size,</a>
<a name="ln1004">				     rc[3].rix, rc[3].tries,</a>
<a name="ln1005">				     0, 0,</a>
<a name="ln1006">				     0, 0,</a>
<a name="ln1007">				     0, 0,</a>
<a name="ln1008">				     short_tries, long_tries,</a>
<a name="ln1009">				     status,</a>
<a name="ln1010">				     nframes, nbad);</a>
<a name="ln1011">		}</a>
<a name="ln1012">	}</a>
<a name="ln1013">}</a>
<a name="ln1014"> </a>
<a name="ln1015">void</a>
<a name="ln1016">ath_rate_newassoc(struct ath_softc *sc, struct ath_node *an, int isnew)</a>
<a name="ln1017">{</a>
<a name="ln1018">	if (isnew)</a>
<a name="ln1019">		ath_rate_ctl_reset(sc, &amp;an-&gt;an_node);</a>
<a name="ln1020">}</a>
<a name="ln1021"> </a>
<a name="ln1022">static const struct txschedule *mrr_schedules[IEEE80211_MODE_MAX+2] = {</a>
<a name="ln1023">	NULL,		/* IEEE80211_MODE_AUTO */</a>
<a name="ln1024">	series_11a,	/* IEEE80211_MODE_11A */</a>
<a name="ln1025">	series_11g,	/* IEEE80211_MODE_11B */</a>
<a name="ln1026">	series_11g,	/* IEEE80211_MODE_11G */</a>
<a name="ln1027">	NULL,		/* IEEE80211_MODE_FH */</a>
<a name="ln1028">	series_11a,	/* IEEE80211_MODE_TURBO_A */</a>
<a name="ln1029">	series_11g,	/* IEEE80211_MODE_TURBO_G */</a>
<a name="ln1030">	series_11a,	/* IEEE80211_MODE_STURBO_A */</a>
<a name="ln1031">	series_11na,	/* IEEE80211_MODE_11NA */</a>
<a name="ln1032">	series_11ng,	/* IEEE80211_MODE_11NG */</a>
<a name="ln1033">	series_half,	/* IEEE80211_MODE_HALF */</a>
<a name="ln1034">	series_quarter,	/* IEEE80211_MODE_QUARTER */</a>
<a name="ln1035">};</a>
<a name="ln1036"> </a>
<a name="ln1037">/*</a>
<a name="ln1038"> * Initialize the tables for a node.</a>
<a name="ln1039"> */</a>
<a name="ln1040">static void</a>
<a name="ln1041">ath_rate_ctl_reset(struct ath_softc *sc, struct ieee80211_node *ni)</a>
<a name="ln1042">{</a>
<a name="ln1043">#define	RATE(_ix)	(ni-&gt;ni_rates.rs_rates[(_ix)] &amp; IEEE80211_RATE_VAL)</a>
<a name="ln1044">#define	DOT11RATE(_ix)	(rt-&gt;info[(_ix)].dot11Rate &amp; IEEE80211_RATE_VAL)</a>
<a name="ln1045">#define	MCS(_ix)	(ni-&gt;ni_htrates.rs_rates[_ix] | IEEE80211_RATE_MCS)</a>
<a name="ln1046">	struct ath_node *an = ATH_NODE(ni);</a>
<a name="ln1047">	struct sample_node *sn = ATH_NODE_SAMPLE(an);</a>
<a name="ln1048">	const HAL_RATE_TABLE *rt = sc-&gt;sc_currates;</a>
<a name="ln1049">	int x, y, rix;</a>
<a name="ln1050"> </a>
<a name="ln1051">	KASSERT(rt != NULL, (&quot;no rate table, mode %u&quot;, sc-&gt;sc_curmode));</a>
<a name="ln1052"> </a>
<a name="ln1053">	KASSERT(sc-&gt;sc_curmode &lt; IEEE80211_MODE_MAX+2,</a>
<a name="ln1054">	    (&quot;curmode %u&quot;, sc-&gt;sc_curmode));</a>
<a name="ln1055"> </a>
<a name="ln1056">	sn-&gt;sched = mrr_schedules[sc-&gt;sc_curmode];</a>
<a name="ln1057">	KASSERT(sn-&gt;sched != NULL,</a>
<a name="ln1058">	    (&quot;no mrr schedule for mode %u&quot;, sc-&gt;sc_curmode));</a>
<a name="ln1059"> </a>
<a name="ln1060">        sn-&gt;static_rix = -1;</a>
<a name="ln1061">	ath_rate_update_static_rix(sc, ni);</a>
<a name="ln1062"> </a>
<a name="ln1063">	sn-&gt;currates = sc-&gt;sc_currates;</a>
<a name="ln1064"> </a>
<a name="ln1065">	/*</a>
<a name="ln1066">	 * Construct a bitmask of usable rates.  This has all</a>
<a name="ln1067">	 * negotiated rates minus those marked by the hal as</a>
<a name="ln1068">	 * to be ignored for doing rate control.</a>
<a name="ln1069">	 */</a>
<a name="ln1070">	sn-&gt;ratemask = 0;</a>
<a name="ln1071">	/* MCS rates */</a>
<a name="ln1072">	if (ni-&gt;ni_flags &amp; IEEE80211_NODE_HT) {</a>
<a name="ln1073">		for (x = 0; x &lt; ni-&gt;ni_htrates.rs_nrates; x++) {</a>
<a name="ln1074">			rix = sc-&gt;sc_rixmap[MCS(x)];</a>
<a name="ln1075">			if (rix == 0xff)</a>
<a name="ln1076">				continue;</a>
<a name="ln1077">			/* skip rates marked broken by hal */</a>
<a name="ln1078">			if (!rt-&gt;info[rix].valid)</a>
<a name="ln1079">				continue;</a>
<a name="ln1080">			KASSERT(rix &lt; SAMPLE_MAXRATES,</a>
<a name="ln1081">			    (&quot;mcs %u has rix %d&quot;, MCS(x), rix));</a>
<a name="ln1082">			sn-&gt;ratemask |= (uint64_t) 1&lt;&lt;rix;</a>
<a name="ln1083">		}</a>
<a name="ln1084">	}</a>
<a name="ln1085"> </a>
<a name="ln1086">	/* Legacy rates */</a>
<a name="ln1087">	for (x = 0; x &lt; ni-&gt;ni_rates.rs_nrates; x++) {</a>
<a name="ln1088">		rix = sc-&gt;sc_rixmap[RATE(x)];</a>
<a name="ln1089">		if (rix == 0xff)</a>
<a name="ln1090">			continue;</a>
<a name="ln1091">		/* skip rates marked broken by hal */</a>
<a name="ln1092">		if (!rt-&gt;info[rix].valid)</a>
<a name="ln1093">			continue;</a>
<a name="ln1094">		KASSERT(rix &lt; SAMPLE_MAXRATES,</a>
<a name="ln1095">		    (&quot;rate %u has rix %d&quot;, RATE(x), rix));</a>
<a name="ln1096">		sn-&gt;ratemask |= (uint64_t) 1&lt;&lt;rix;</a>
<a name="ln1097">	}</a>
<a name="ln1098">#ifdef IEEE80211_DEBUG</a>
<a name="ln1099">	if (ieee80211_msg(ni-&gt;ni_vap, IEEE80211_MSG_RATECTL)) {</a>
<a name="ln1100">		uint64_t mask;</a>
<a name="ln1101"> </a>
<a name="ln1102">		ieee80211_note(ni-&gt;ni_vap, &quot;[%6D] %s: size 1600 rate/tt&quot;,</a>
<a name="ln1103">		    ni-&gt;ni_macaddr, &quot;:&quot;, __func__);</a>
<a name="ln1104">		for (mask = sn-&gt;ratemask, rix = 0; mask != 0; mask &gt;&gt;= 1, rix++) {</a>
<a name="ln1105">			if ((mask &amp; 1) == 0)</a>
<a name="ln1106">				continue;</a>
<a name="ln1107">			printf(&quot; %d %s/%d&quot;, dot11rate(rt, rix), dot11rate_label(rt, rix),</a>
<a name="ln1108">			    calc_usecs_unicast_packet(sc, 1600, rix, 0,0,</a>
<a name="ln1109">			        (ni-&gt;ni_chw == 40)));</a>
<a name="ln1110">		}</a>
<a name="ln1111">		printf(&quot;\n&quot;);</a>
<a name="ln1112">	}</a>
<a name="ln1113">#endif</a>
<a name="ln1114">	for (y = 0; y &lt; NUM_PACKET_SIZE_BINS; y++) {</a>
<a name="ln1115">		int size = bin_to_size(y);</a>
<a name="ln1116">		uint64_t mask;</a>
<a name="ln1117"> </a>
<a name="ln1118">		sn-&gt;packets_sent[y] = 0;</a>
<a name="ln1119">		sn-&gt;current_sample_rix[y] = -1;</a>
<a name="ln1120">		sn-&gt;last_sample_rix[y] = 0;</a>
<a name="ln1121">		/* XXX start with first valid rate */</a>
<a name="ln1122">		sn-&gt;current_rix[y] = ffs(sn-&gt;ratemask)-1;</a>
<a name="ln1123">		</a>
<a name="ln1124">		/*</a>
<a name="ln1125">		 * Initialize the statistics buckets; these are</a>
<a name="ln1126">		 * indexed by the rate code index.</a>
<a name="ln1127">		 */</a>
<a name="ln1128">		for (rix = 0, mask = sn-&gt;ratemask; mask != 0; rix++, mask &gt;&gt;= 1) {</a>
<a name="ln1129">			if ((mask &amp; 1) == 0)		/* not a valid rate */</a>
<a name="ln1130">				continue;</a>
<a name="ln1131">			sn-&gt;stats[y][rix].successive_failures = 0;</a>
<a name="ln1132">			sn-&gt;stats[y][rix].tries = 0;</a>
<a name="ln1133">			sn-&gt;stats[y][rix].total_packets = 0;</a>
<a name="ln1134">			sn-&gt;stats[y][rix].packets_acked = 0;</a>
<a name="ln1135">			sn-&gt;stats[y][rix].last_tx = 0;</a>
<a name="ln1136">			sn-&gt;stats[y][rix].ewma_pct = 0;</a>
<a name="ln1137">			</a>
<a name="ln1138">			sn-&gt;stats[y][rix].perfect_tx_time =</a>
<a name="ln1139">			    calc_usecs_unicast_packet(sc, size, rix, 0, 0,</a>
<a name="ln1140">			    (ni-&gt;ni_chw == 40));</a>
<a name="ln1141">			sn-&gt;stats[y][rix].average_tx_time =</a>
<a name="ln1142">			    sn-&gt;stats[y][rix].perfect_tx_time;</a>
<a name="ln1143">		}</a>
<a name="ln1144">	}</a>
<a name="ln1145">#if 0</a>
<a name="ln1146">	/* XXX 0, num_rates-1 are wrong */</a>
<a name="ln1147">	IEEE80211_NOTE(ni-&gt;ni_vap, IEEE80211_MSG_RATECTL, ni,</a>
<a name="ln1148">	    &quot;%s: %d rates %d%sMbps (%dus)- %d%sMbps (%dus)&quot;, __func__, </a>
<a name="ln1149">	    sn-&gt;num_rates,</a>
<a name="ln1150">	    DOT11RATE(0)/2, DOT11RATE(0) % 1 ? &quot;.5&quot; : &quot;&quot;,</a>
<a name="ln1151">	    sn-&gt;stats[1][0].perfect_tx_time,</a>
<a name="ln1152">	    DOT11RATE(sn-&gt;num_rates-1)/2, DOT11RATE(sn-&gt;num_rates-1) % 1 ? &quot;.5&quot; : &quot;&quot;,</a>
<a name="ln1153">	    sn-&gt;stats[1][sn-&gt;num_rates-1].perfect_tx_time</a>
<a name="ln1154">	);</a>
<a name="ln1155">#endif</a>
<a name="ln1156">	/* set the visible bit-rate */</a>
<a name="ln1157">	if (sn-&gt;static_rix != -1)</a>
<a name="ln1158">		ni-&gt;ni_txrate = DOT11RATE(sn-&gt;static_rix);</a>
<a name="ln1159">	else</a>
<a name="ln1160">		ni-&gt;ni_txrate = RATE(0);</a>
<a name="ln1161">#undef RATE</a>
<a name="ln1162">#undef DOT11RATE</a>
<a name="ln1163">}</a>
<a name="ln1164"> </a>
<a name="ln1165">/*</a>
<a name="ln1166"> * Fetch the statistics for the given node.</a>
<a name="ln1167"> *</a>
<a name="ln1168"> * The ieee80211 node must be referenced and unlocked, however the ath_node</a>
<a name="ln1169"> * must be locked.</a>
<a name="ln1170"> *</a>
<a name="ln1171"> * The main difference here is that we convert the rate indexes</a>
<a name="ln1172"> * to 802.11 rates, or the userland output won't make much sense</a>
<a name="ln1173"> * as it has no access to the rix table.</a>
<a name="ln1174"> */</a>
<a name="ln1175">int</a>
<a name="ln1176">ath_rate_fetch_node_stats(struct ath_softc *sc, struct ath_node *an,</a>
<a name="ln1177">    struct ath_rateioctl *rs)</a>
<a name="ln1178">{</a>
<a name="ln1179">	struct sample_node *sn = ATH_NODE_SAMPLE(an);</a>
<a name="ln1180">	const HAL_RATE_TABLE *rt = sc-&gt;sc_currates;</a>
<a name="ln1181">	struct ath_rateioctl_tlv av;</a>
<a name="ln1182">	struct ath_rateioctl_rt *tv;</a>
<a name="ln1183">	int y;</a>
<a name="ln1184">	int o = 0;</a>
<a name="ln1185"> </a>
<a name="ln1186">	ATH_NODE_LOCK_ASSERT(an);</a>
<a name="ln1187"> </a>
<a name="ln1188">	/*</a>
<a name="ln1189">	 * Ensure there's enough space for the statistics.</a>
<a name="ln1190">	 */</a>
<a name="ln1191">	if (rs-&gt;len &lt;</a>
<a name="ln1192">	    sizeof(struct ath_rateioctl_tlv) +</a>
<a name="ln1193">	    sizeof(struct ath_rateioctl_rt) +</a>
<a name="ln1194">	    sizeof(struct ath_rateioctl_tlv) +</a>
<a name="ln1195">	    sizeof(struct sample_node)) {</a>
<a name="ln1196">		device_printf(sc-&gt;sc_dev, &quot;%s: len=%d, too short\n&quot;,</a>
<a name="ln1197">		    __func__,</a>
<a name="ln1198">		    rs-&gt;len);</a>
<a name="ln1199">		return (EINVAL);</a>
<a name="ln1200">	}</a>
<a name="ln1201"> </a>
<a name="ln1202">	/*</a>
<a name="ln1203">	 * Take a temporary copy of the sample node state so we can</a>
<a name="ln1204">	 * modify it before we copy it.</a>
<a name="ln1205">	 */</a>
<a name="ln1206">	tv = malloc(sizeof(struct ath_rateioctl_rt), M_TEMP,</a>
<a name="ln1207">	    M_NOWAIT | M_ZERO);</a>
<a name="ln1208">	if (tv == NULL) {</a>
<a name="ln1209">		return (ENOMEM);</a>
<a name="ln1210">	}</a>
<a name="ln1211"> </a>
<a name="ln1212">	/*</a>
<a name="ln1213">	 * Populate the rate table mapping TLV.</a>
<a name="ln1214">	 */</a>
<a name="ln1215">	tv-&gt;nentries = rt-&gt;rateCount;</a>
<a name="ln1216">	for (y = 0; y &lt; rt-&gt;rateCount; y++) {</a>
<a name="ln1217">		tv-&gt;ratecode[y] = rt-&gt;info[y].dot11Rate &amp; IEEE80211_RATE_VAL;</a>
<a name="ln1218">		if (rt-&gt;info[y].phy == IEEE80211_T_HT)</a>
<a name="ln1219">			tv-&gt;ratecode[y] |= IEEE80211_RATE_MCS;</a>
<a name="ln1220">	}</a>
<a name="ln1221"> </a>
<a name="ln1222">	o = 0;</a>
<a name="ln1223">	/*</a>
<a name="ln1224">	 * First TLV - rate code mapping</a>
<a name="ln1225">	 */</a>
<a name="ln1226">	av.tlv_id = ATH_RATE_TLV_RATETABLE;</a>
<a name="ln1227">	av.tlv_len = sizeof(struct ath_rateioctl_rt);</a>
<a name="ln1228">	copyout(&amp;av, rs-&gt;buf + o, sizeof(struct ath_rateioctl_tlv));</a>
<a name="ln1229">	o += sizeof(struct ath_rateioctl_tlv);</a>
<a name="ln1230">	copyout(tv, rs-&gt;buf + o, sizeof(struct ath_rateioctl_rt));</a>
<a name="ln1231">	o += sizeof(struct ath_rateioctl_rt);</a>
<a name="ln1232"> </a>
<a name="ln1233">	/*</a>
<a name="ln1234">	 * Second TLV - sample node statistics</a>
<a name="ln1235">	 */</a>
<a name="ln1236">	av.tlv_id = ATH_RATE_TLV_SAMPLENODE;</a>
<a name="ln1237">	av.tlv_len = sizeof(struct sample_node);</a>
<a name="ln1238">	copyout(&amp;av, rs-&gt;buf + o, sizeof(struct ath_rateioctl_tlv));</a>
<a name="ln1239">	o += sizeof(struct ath_rateioctl_tlv);</a>
<a name="ln1240"> </a>
<a name="ln1241">	/*</a>
<a name="ln1242">	 * Copy the statistics over to the provided buffer.</a>
<a name="ln1243">	 */</a>
<a name="ln1244">	copyout(sn, rs-&gt;buf + o, sizeof(struct sample_node));</a>
<a name="ln1245">	o += sizeof(struct sample_node);</a>
<a name="ln1246"> </a>
<a name="ln1247">	free(tv, M_TEMP);</a>
<a name="ln1248"> </a>
<a name="ln1249">	return (0);</a>
<a name="ln1250">}</a>
<a name="ln1251"> </a>
<a name="ln1252">static void</a>
<a name="ln1253">sample_stats(void *arg, struct ieee80211_node *ni)</a>
<a name="ln1254">{</a>
<a name="ln1255">	struct ath_softc *sc = arg;</a>
<a name="ln1256">	const HAL_RATE_TABLE *rt = sc-&gt;sc_currates;</a>
<a name="ln1257">	struct sample_node *sn = ATH_NODE_SAMPLE(ATH_NODE(ni));</a>
<a name="ln1258">	uint64_t mask;</a>
<a name="ln1259">	int rix, y;</a>
<a name="ln1260"> </a>
<a name="ln1261">	printf(&quot;\n[%s] refcnt %d static_rix (%d %s) ratemask 0x%jx\n&quot;,</a>
<a name="ln1262">	    ether_sprintf(ni-&gt;ni_macaddr), ieee80211_node_refcnt(ni),</a>
<a name="ln1263">	    dot11rate(rt, sn-&gt;static_rix),</a>
<a name="ln1264">	    dot11rate_label(rt, sn-&gt;static_rix),</a>
<a name="ln1265">	    (uintmax_t)sn-&gt;ratemask);</a>
<a name="ln1266">	for (y = 0; y &lt; NUM_PACKET_SIZE_BINS; y++) {</a>
<a name="ln1267">		printf(&quot;[%4u] cur rix %d (%d %s) since switch: packets %d ticks %u\n&quot;,</a>
<a name="ln1268">		    bin_to_size(y), sn-&gt;current_rix[y],</a>
<a name="ln1269">		    dot11rate(rt, sn-&gt;current_rix[y]),</a>
<a name="ln1270">		    dot11rate_label(rt, sn-&gt;current_rix[y]),</a>
<a name="ln1271">		    sn-&gt;packets_since_switch[y], sn-&gt;ticks_since_switch[y]);</a>
<a name="ln1272">		printf(&quot;[%4u] last sample (%d %s) cur sample (%d %s) packets sent %d\n&quot;,</a>
<a name="ln1273">		    bin_to_size(y),</a>
<a name="ln1274">		    dot11rate(rt, sn-&gt;last_sample_rix[y]),</a>
<a name="ln1275">		    dot11rate_label(rt, sn-&gt;last_sample_rix[y]),</a>
<a name="ln1276">		    dot11rate(rt, sn-&gt;current_sample_rix[y]),</a>
<a name="ln1277">		    dot11rate_label(rt, sn-&gt;current_sample_rix[y]),</a>
<a name="ln1278">		    sn-&gt;packets_sent[y]);</a>
<a name="ln1279">		printf(&quot;[%4u] packets since sample %d sample tt %u\n&quot;,</a>
<a name="ln1280">		    bin_to_size(y), sn-&gt;packets_since_sample[y],</a>
<a name="ln1281">		    sn-&gt;sample_tt[y]);</a>
<a name="ln1282">	}</a>
<a name="ln1283">	for (mask = sn-&gt;ratemask, rix = 0; mask != 0; mask &gt;&gt;= 1, rix++) {</a>
<a name="ln1284">		if ((mask &amp; 1) == 0)</a>
<a name="ln1285">				continue;</a>
<a name="ln1286">		for (y = 0; y &lt; NUM_PACKET_SIZE_BINS; y++) {</a>
<a name="ln1287">			if (sn-&gt;stats[y][rix].total_packets == 0)</a>
<a name="ln1288">				continue;</a>
<a name="ln1289">			printf(&quot;[%2u %s:%4u] %8ju:%-8ju (%3d%%) (EWMA %3d.%1d%%) T %8ju F %4d avg %5u last %u\n&quot;,</a>
<a name="ln1290">			    dot11rate(rt, rix), dot11rate_label(rt, rix),</a>
<a name="ln1291">			    bin_to_size(y),</a>
<a name="ln1292">			    (uintmax_t) sn-&gt;stats[y][rix].total_packets,</a>
<a name="ln1293">			    (uintmax_t) sn-&gt;stats[y][rix].packets_acked,</a>
<a name="ln1294">			    (int) ((sn-&gt;stats[y][rix].packets_acked * 100ULL) /</a>
<a name="ln1295">			     sn-&gt;stats[y][rix].total_packets),</a>
<a name="ln1296">			    sn-&gt;stats[y][rix].ewma_pct / 10,</a>
<a name="ln1297">			    sn-&gt;stats[y][rix].ewma_pct % 10,</a>
<a name="ln1298">			    (uintmax_t) sn-&gt;stats[y][rix].tries,</a>
<a name="ln1299">			    sn-&gt;stats[y][rix].successive_failures,</a>
<a name="ln1300">			    sn-&gt;stats[y][rix].average_tx_time,</a>
<a name="ln1301">			    ticks - sn-&gt;stats[y][rix].last_tx);</a>
<a name="ln1302">		}</a>
<a name="ln1303">	}</a>
<a name="ln1304">}</a>
<a name="ln1305"> </a>
<a name="ln1306">static int</a>
<a name="ln1307">ath_rate_sysctl_stats(SYSCTL_HANDLER_ARGS)</a>
<a name="ln1308">{</a>
<a name="ln1309">	struct ath_softc *sc = arg1;</a>
<a name="ln1310">	struct ieee80211com *ic = &amp;sc-&gt;sc_ic;</a>
<a name="ln1311">	int error, v;</a>
<a name="ln1312"> </a>
<a name="ln1313">	v = 0;</a>
<a name="ln1314">	error = sysctl_handle_int(oidp, &amp;v, 0, req);</a>
<a name="ln1315">	if (error || !req-&gt;newptr)</a>
<a name="ln1316">		return error;</a>
<a name="ln1317">	ieee80211_iterate_nodes(&amp;ic-&gt;ic_sta, sample_stats, sc);</a>
<a name="ln1318">	return 0;</a>
<a name="ln1319">}</a>
<a name="ln1320"> </a>
<a name="ln1321">static int</a>
<a name="ln1322">ath_rate_sysctl_smoothing_rate(SYSCTL_HANDLER_ARGS)</a>
<a name="ln1323">{</a>
<a name="ln1324">	struct sample_softc *ssc = arg1;</a>
<a name="ln1325">	int rate, error;</a>
<a name="ln1326"> </a>
<a name="ln1327">	rate = ssc-&gt;smoothing_rate;</a>
<a name="ln1328">	error = sysctl_handle_int(oidp, &amp;rate, 0, req);</a>
<a name="ln1329">	if (error || !req-&gt;newptr)</a>
<a name="ln1330">		return error;</a>
<a name="ln1331">	if (!(0 &lt;= rate &amp;&amp; rate &lt; 100))</a>
<a name="ln1332">		return EINVAL;</a>
<a name="ln1333">	ssc-&gt;smoothing_rate = rate;</a>
<a name="ln1334">	ssc-&gt;smoothing_minpackets = 100 / (100 - rate);</a>
<a name="ln1335">	return 0;</a>
<a name="ln1336">}</a>
<a name="ln1337"> </a>
<a name="ln1338">static int</a>
<a name="ln1339">ath_rate_sysctl_sample_rate(SYSCTL_HANDLER_ARGS)</a>
<a name="ln1340">{</a>
<a name="ln1341">	struct sample_softc *ssc = arg1;</a>
<a name="ln1342">	int rate, error;</a>
<a name="ln1343"> </a>
<a name="ln1344">	rate = ssc-&gt;sample_rate;</a>
<a name="ln1345">	error = sysctl_handle_int(oidp, &amp;rate, 0, req);</a>
<a name="ln1346">	if (error || !req-&gt;newptr)</a>
<a name="ln1347">		return error;</a>
<a name="ln1348">	if (!(2 &lt;= rate &amp;&amp; rate &lt;= 100))</a>
<a name="ln1349">		return EINVAL;</a>
<a name="ln1350">	ssc-&gt;sample_rate = rate;</a>
<a name="ln1351">	return 0;</a>
<a name="ln1352">}</a>
<a name="ln1353"> </a>
<a name="ln1354">static void</a>
<a name="ln1355">ath_rate_sysctlattach(struct ath_softc *sc, struct sample_softc *ssc)</a>
<a name="ln1356">{</a>
<a name="ln1357">	struct sysctl_ctx_list *ctx = device_get_sysctl_ctx(sc-&gt;sc_dev);</a>
<a name="ln1358">	struct sysctl_oid *tree = device_get_sysctl_tree(sc-&gt;sc_dev);</a>
<a name="ln1359"> </a>
<a name="ln1360">	SYSCTL_ADD_PROC(ctx, SYSCTL_CHILDREN(tree), OID_AUTO,</a>
<a name="ln1361">	    &quot;smoothing_rate&quot;, CTLTYPE_INT | CTLFLAG_RW, ssc, 0,</a>
<a name="ln1362">	    ath_rate_sysctl_smoothing_rate, &quot;I&quot;,</a>
<a name="ln1363">	    &quot;sample: smoothing rate for avg tx time (%%)&quot;);</a>
<a name="ln1364">	SYSCTL_ADD_PROC(ctx, SYSCTL_CHILDREN(tree), OID_AUTO,</a>
<a name="ln1365">	    &quot;sample_rate&quot;, CTLTYPE_INT | CTLFLAG_RW, ssc, 0,</a>
<a name="ln1366">	    ath_rate_sysctl_sample_rate, &quot;I&quot;,</a>
<a name="ln1367">	    &quot;sample: percent air time devoted to sampling new rates (%%)&quot;);</a>
<a name="ln1368">	/* XXX max_successive_failures, stale_failure_timeout, min_switch */</a>
<a name="ln1369">	SYSCTL_ADD_PROC(ctx, SYSCTL_CHILDREN(tree), OID_AUTO,</a>
<a name="ln1370">	    &quot;sample_stats&quot;, CTLTYPE_INT | CTLFLAG_RW, sc, 0,</a>
<a name="ln1371">	    ath_rate_sysctl_stats, &quot;I&quot;, &quot;sample: print statistics&quot;);</a>
<a name="ln1372">}</a>
<a name="ln1373"> </a>
<a name="ln1374">struct ath_ratectrl *</a>
<a name="ln1375">ath_rate_attach(struct ath_softc *sc)</a>
<a name="ln1376">{</a>
<a name="ln1377">	struct sample_softc *ssc;</a>
<a name="ln1378">	</a>
<a name="ln1379">	ssc = malloc(sizeof(struct sample_softc), M_DEVBUF, M_NOWAIT|M_ZERO);</a>
<a name="ln1380">	if (ssc == NULL)</a>
<a name="ln1381">		return NULL;</a>
<a name="ln1382">	ssc-&gt;arc.arc_space = sizeof(struct sample_node);</a>
<a name="ln1383">	ssc-&gt;smoothing_rate = 75;		/* ewma percentage ([0..99]) */</a>
<a name="ln1384">	ssc-&gt;smoothing_minpackets = 100 / (100 - ssc-&gt;smoothing_rate);</a>
<a name="ln1385">	ssc-&gt;sample_rate = 10;			/* %time to try diff tx rates */</a>
<a name="ln1386">	ssc-&gt;max_successive_failures = 3;	/* threshold for rate sampling*/</a>
<a name="ln1387">	ssc-&gt;stale_failure_timeout = 10 * hz;	/* 10 seconds */</a>
<a name="ln1388">	ssc-&gt;min_switch = hz;			/* 1 second */</a>
<a name="ln1389">	ath_rate_sysctlattach(sc, ssc);</a>
<a name="ln1390">	return &amp;ssc-&gt;arc;</a>
<a name="ln1391">}</a>
<a name="ln1392"> </a>
<a name="ln1393">void</a>
<a name="ln1394">ath_rate_detach(struct ath_ratectrl *arc)</a>
<a name="ln1395">{</a>
<a name="ln1396">	struct sample_softc *ssc = (struct sample_softc *) arc;</a>
<a name="ln1397">	</a>
<a name="ln1398">	free(ssc, M_DEVBUF);</a>
<a name="ln1399">}</a>

</code></pre>
<div class="balloon" rel="1157"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'sn->static_rix != - 1' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
