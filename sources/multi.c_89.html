
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>multi.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Emuxki BeOS Driver for Creative Labs SBLive!/Audigy series</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (c) 2002, Jerome Duval (jerome.duval@free.fr)</a>
<a name="ln5"> *</a>
<a name="ln6"> * Original code : BeOS Driver for Intel ICH AC'97 Link interface</a>
<a name="ln7"> * Copyright (c) 2002, Marcus Overhagen &lt;marcus@overhagen.de&gt;</a>
<a name="ln8"> *</a>
<a name="ln9"> * All rights reserved.</a>
<a name="ln10"> * Redistribution and use in source and binary forms, with or without modification,</a>
<a name="ln11"> * are permitted provided that the following conditions are met:</a>
<a name="ln12"> *</a>
<a name="ln13"> * - Redistributions of source code must retain the above copyright notice,</a>
<a name="ln14"> *   this list of conditions and the following disclaimer.</a>
<a name="ln15"> * - Redistributions in binary form must reproduce the above copyright notice,</a>
<a name="ln16"> *   this list of conditions and the following disclaimer in the documentation</a>
<a name="ln17"> *   and/or other materials provided with the distribution.</a>
<a name="ln18"> *</a>
<a name="ln19"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND</a>
<a name="ln20"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</a>
<a name="ln21"> * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</a>
<a name="ln22"> * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR</a>
<a name="ln23"> * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</a>
<a name="ln24"> * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS</a>
<a name="ln25"> * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</a>
<a name="ln26"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</a>
<a name="ln27"> * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,</a>
<a name="ln28"> * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln29"> *</a>
<a name="ln30"> */</a>
<a name="ln31"> </a>
<a name="ln32">#include &lt;OS.h&gt;</a>
<a name="ln33">#include &lt;MediaDefs.h&gt;</a>
<a name="ln34">#include &lt;strings.h&gt;</a>
<a name="ln35">#include &quot;hmulti_audio.h&quot;</a>
<a name="ln36">#include &quot;multi.h&quot;</a>
<a name="ln37">#include &quot;ac97.h&quot;</a>
<a name="ln38">#include &quot;debug.h&quot;</a>
<a name="ln39">#include &quot;emuxki.h&quot;</a>
<a name="ln40">#include &quot;util.h&quot;</a>
<a name="ln41">#include &quot;io.h&quot;</a>
<a name="ln42"> </a>
<a name="ln43">static void</a>
<a name="ln44">emuxki_ac97_get_mix(void *card, const void *cookie, int32 type, float *values) {</a>
<a name="ln45">	emuxki_dev *dev = (emuxki_dev*)card;</a>
<a name="ln46">	ac97_source_info *info = (ac97_source_info *)cookie;</a>
<a name="ln47">	uint16 value, mask;</a>
<a name="ln48">	float gain;</a>
<a name="ln49"> </a>
<a name="ln50">	switch(type) {</a>
<a name="ln51">		case B_MIX_GAIN:</a>
<a name="ln52">			value = emuxki_codec_read(&amp;dev-&gt;config, info-&gt;reg);</a>
<a name="ln53">			//PRINT((&quot;B_MIX_GAIN value : %u\n&quot;, value));</a>
<a name="ln54">			if (info-&gt;type &amp; B_MIX_STEREO) {</a>
<a name="ln55">				mask = ((1 &lt;&lt; (info-&gt;bits + 1)) - 1) &lt;&lt; 8;</a>
<a name="ln56">				gain = ((value &amp; mask) &gt;&gt; 8) * info-&gt;granularity;</a>
<a name="ln57">				if (info-&gt;polarity == 1)</a>
<a name="ln58">					values[0] = info-&gt;max_gain - gain;</a>
<a name="ln59">				else</a>
<a name="ln60">					values[0] = gain - info-&gt;min_gain;</a>
<a name="ln61"> </a>
<a name="ln62">				mask = ((1 &lt;&lt; (info-&gt;bits + 1)) - 1);</a>
<a name="ln63">				gain = (value &amp; mask) * info-&gt;granularity;</a>
<a name="ln64">				if (info-&gt;polarity == 1)</a>
<a name="ln65">					values[1] = info-&gt;max_gain - gain;</a>
<a name="ln66">				else</a>
<a name="ln67">					values[1] = gain - info-&gt;min_gain;</a>
<a name="ln68">			} else {</a>
<a name="ln69">				mask = ((1 &lt;&lt; (info-&gt;bits + 1)) - 1);</a>
<a name="ln70">				gain = (value &amp; mask) * info-&gt;granularity;</a>
<a name="ln71">				if (info-&gt;polarity == 1)</a>
<a name="ln72">					values[0] = info-&gt;max_gain - gain;</a>
<a name="ln73">				else</a>
<a name="ln74">					values[0] = gain - info-&gt;min_gain;</a>
<a name="ln75">			}</a>
<a name="ln76">			break;</a>
<a name="ln77">		case B_MIX_MUTE:</a>
<a name="ln78">			mask = ((1 &lt;&lt; 1) - 1) &lt;&lt; 15;</a>
<a name="ln79">			value = emuxki_codec_read(&amp;dev-&gt;config, info-&gt;reg);</a>
<a name="ln80">			//PRINT((&quot;B_MIX_MUTE value : %u\n&quot;, value));</a>
<a name="ln81">			value &amp;= mask;</a>
<a name="ln82">			values[0] = ((value &gt;&gt; 15) == 1) ? 1.0 : 0.0;</a>
<a name="ln83">			break;</a>
<a name="ln84">		case B_MIX_MICBOOST:</a>
<a name="ln85">			mask = ((1 &lt;&lt; 1) - 1) &lt;&lt; 6;</a>
<a name="ln86">			value = emuxki_codec_read(&amp;dev-&gt;config, info-&gt;reg);</a>
<a name="ln87">			//PRINT((&quot;B_MIX_MICBOOST value : %u\n&quot;, value));</a>
<a name="ln88">			value &amp;= mask;</a>
<a name="ln89">			values[0] = ((value &gt;&gt; 6) == 1) ? 1.0 : 0.0;</a>
<a name="ln90">			break;</a>
<a name="ln91">		case B_MIX_MUX:</a>
<a name="ln92">			mask = ((1 &lt;&lt; 3) - 1);</a>
<a name="ln93">			value = emuxki_codec_read(&amp;dev-&gt;config, AC97_RECORD_SELECT);</a>
<a name="ln94">			value &amp;= mask;</a>
<a name="ln95">			//PRINT((&quot;B_MIX_MUX value : %u\n&quot;, value));</a>
<a name="ln96">			values[0] = (float)value;</a>
<a name="ln97">			break;</a>
<a name="ln98">	}</a>
<a name="ln99">}</a>
<a name="ln100"> </a>
<a name="ln101">static void</a>
<a name="ln102">emuxki_ac97_set_mix(void *card, const void *cookie, int32 type, float *values) {</a>
<a name="ln103">	emuxki_dev *dev = (emuxki_dev*)card;</a>
<a name="ln104">	ac97_source_info *info = (ac97_source_info *)cookie;</a>
<a name="ln105">	uint16 value, mask;</a>
<a name="ln106">	float gain;</a>
<a name="ln107"> </a>
<a name="ln108">	switch(type) {</a>
<a name="ln109">		case B_MIX_GAIN:</a>
<a name="ln110">			value = emuxki_codec_read(&amp;dev-&gt;config, info-&gt;reg);</a>
<a name="ln111">			if (info-&gt;type &amp; B_MIX_STEREO) {</a>
<a name="ln112">				mask = ((1 &lt;&lt; (info-&gt;bits + 1)) - 1) &lt;&lt; 8;</a>
<a name="ln113">				value &amp;= ~mask;</a>
<a name="ln114"> </a>
<a name="ln115">				if (info-&gt;polarity == 1)</a>
<a name="ln116">					gain = info-&gt;max_gain - values[0];</a>
<a name="ln117">				else</a>
<a name="ln118">					gain =  values[0] - info-&gt;min_gain;</a>
<a name="ln119">				value |= ((uint16)(gain	/ info-&gt;granularity) &lt;&lt; 8) &amp; mask;</a>
<a name="ln120"> </a>
<a name="ln121">				mask = ((1 &lt;&lt; (info-&gt;bits + 1)) - 1);</a>
<a name="ln122">				value &amp;= ~mask;</a>
<a name="ln123">				if (info-&gt;polarity == 1)</a>
<a name="ln124">					gain = info-&gt;max_gain - values[1];</a>
<a name="ln125">				else</a>
<a name="ln126">					gain =  values[1] - info-&gt;min_gain;</a>
<a name="ln127">				value |= ((uint16)(gain / info-&gt;granularity)) &amp; mask;</a>
<a name="ln128">			} else {</a>
<a name="ln129">				mask = ((1 &lt;&lt; (info-&gt;bits + 1)) - 1);</a>
<a name="ln130">				value &amp;= ~mask;</a>
<a name="ln131">				if (info-&gt;polarity == 1)</a>
<a name="ln132">					gain = info-&gt;max_gain - values[0];</a>
<a name="ln133">				else</a>
<a name="ln134">					gain =  values[0] - info-&gt;min_gain;</a>
<a name="ln135">				value |= ((uint16)(gain / info-&gt;granularity)) &amp; mask;</a>
<a name="ln136">			}</a>
<a name="ln137">			//PRINT((&quot;B_MIX_GAIN value : %u\n&quot;, value));</a>
<a name="ln138">			emuxki_codec_write(&amp;dev-&gt;config, info-&gt;reg, value);</a>
<a name="ln139">			break;</a>
<a name="ln140">		case B_MIX_MUTE:</a>
<a name="ln141">			mask = ((1 &lt;&lt; 1) - 1) &lt;&lt; 15;</a>
<a name="ln142">			value = emuxki_codec_read(&amp;dev-&gt;config, info-&gt;reg);</a>
<a name="ln143">			value &amp;= ~mask;</a>
<a name="ln144">			value |= ((values[0] == 1.0 ? 1 : 0 ) &lt;&lt; 15 &amp; mask);</a>
<a name="ln145">			if (info-&gt;reg == AC97_SURROUND_VOLUME) {</a>
<a name="ln146">				// there is a independent mute for each channel</a>
<a name="ln147">				mask = ((1 &lt;&lt; 1) - 1) &lt;&lt; 7;</a>
<a name="ln148">				value &amp;= ~mask;</a>
<a name="ln149">				value |= ((values[0] == 1.0 ? 1 : 0 ) &lt;&lt; 7 &amp; mask);</a>
<a name="ln150">			}</a>
<a name="ln151">			//PRINT((&quot;B_MIX_MUTE value : %u\n&quot;, value));</a>
<a name="ln152">			emuxki_codec_write(&amp;dev-&gt;config, info-&gt;reg, value);</a>
<a name="ln153">			break;</a>
<a name="ln154">		case B_MIX_MICBOOST:</a>
<a name="ln155">			mask = ((1 &lt;&lt; 1) - 1) &lt;&lt; 6;</a>
<a name="ln156">			value = emuxki_codec_read(&amp;dev-&gt;config, info-&gt;reg);</a>
<a name="ln157">			value &amp;= ~mask;</a>
<a name="ln158">			value |= ((values[0] == 1.0 ? 1 : 0 ) &lt;&lt; 6 &amp; mask);</a>
<a name="ln159">			//PRINT((&quot;B_MIX_MICBOOST value : %u\n&quot;, value));</a>
<a name="ln160">			emuxki_codec_write(&amp;dev-&gt;config, info-&gt;reg, value);</a>
<a name="ln161">			break;</a>
<a name="ln162">		case B_MIX_MUX:</a>
<a name="ln163">			mask = ((1 &lt;&lt; 3) - 1);</a>
<a name="ln164">			value = ((int32)values[0]) &amp; mask;</a>
<a name="ln165">			value = value | (value &lt;&lt; 8);</a>
<a name="ln166">			//PRINT((&quot;B_MIX_MUX value : %u\n&quot;, value));</a>
<a name="ln167">			emuxki_codec_write(&amp;dev-&gt;config, AC97_RECORD_SELECT, value);</a>
<a name="ln168">			break;</a>
<a name="ln169">	}</a>
<a name="ln170"> </a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">static void</a>
<a name="ln174">emuxki_gpr_get_mix(void *card, const void *cookie, int32 type, float *values) {</a>
<a name="ln175">	emuxki_gpr_get((emuxki_dev*)card, (emuxki_gpr *)cookie, type, values);</a>
<a name="ln176">}</a>
<a name="ln177"> </a>
<a name="ln178">static void</a>
<a name="ln179">emuxki_gpr_set_mix(void *card, const void *cookie, int32 type, float *values) {</a>
<a name="ln180">	emuxki_gpr_set((emuxki_dev*)card, (emuxki_gpr *)cookie, type, values);</a>
<a name="ln181">}</a>
<a name="ln182"> </a>
<a name="ln183">static void</a>
<a name="ln184">emuxki_parameter_get_mix(void *card, const void *cookie, int32 type, float *values) {</a>
<a name="ln185">	int32 value;</a>
<a name="ln186">	emuxki_parameter_get((emuxki_dev*)card, cookie, type, &amp;value);</a>
<a name="ln187">	values[0] = (float)value;</a>
<a name="ln188">}</a>
<a name="ln189"> </a>
<a name="ln190">static void</a>
<a name="ln191">emuxki_parameter_set_mix(void *card, const void *cookie, int32 type, float *values) {</a>
<a name="ln192">	int32 value;</a>
<a name="ln193">	value = (int32)values[0];</a>
<a name="ln194">	emuxki_parameter_set((emuxki_dev*)card, cookie, type, &amp;value);</a>
<a name="ln195">}</a>
<a name="ln196"> </a>
<a name="ln197">static int32</a>
<a name="ln198">emuxki_create_group_control(multi_dev *multi, int32 *index, int32 parent,</a>
<a name="ln199">	int32 string, const char* name) {</a>
<a name="ln200">	int32 i = *index;</a>
<a name="ln201">	(*index)++;</a>
<a name="ln202">	multi-&gt;controls[i].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + i;</a>
<a name="ln203">	multi-&gt;controls[i].mix_control.parent = parent;</a>
<a name="ln204">	multi-&gt;controls[i].mix_control.flags = B_MULTI_MIX_GROUP;</a>
<a name="ln205">	multi-&gt;controls[i].mix_control.master = EMU_MULTI_CONTROL_MASTERID;</a>
<a name="ln206">	multi-&gt;controls[i].mix_control.string = string;</a>
<a name="ln207">	if (name)</a>
<a name="ln208">		strcpy(multi-&gt;controls[i].mix_control.name, name);</a>
<a name="ln209"> </a>
<a name="ln210">	return multi-&gt;controls[i].mix_control.id;</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213">static void</a>
<a name="ln214">emuxki_create_gpr_control(multi_dev *multi, int32 *index, int32 parent, int32 string,</a>
<a name="ln215">	const emuxki_gpr *gpr) {</a>
<a name="ln216">	int32 i = *index, id;</a>
<a name="ln217">	multi_mixer_control control;</a>
<a name="ln218"> </a>
<a name="ln219">	control.mix_control.master = EMU_MULTI_CONTROL_MASTERID;</a>
<a name="ln220">	control.mix_control.parent = parent;</a>
<a name="ln221">	control.cookie = gpr;</a>
<a name="ln222">	control.get = &amp;emuxki_gpr_get_mix;</a>
<a name="ln223">	control.set = &amp;emuxki_gpr_set_mix;</a>
<a name="ln224">	control.mix_control.u.gain.min_gain = gpr-&gt;min_gain;</a>
<a name="ln225">	control.mix_control.u.gain.max_gain = gpr-&gt;max_gain;</a>
<a name="ln226">	control.mix_control.u.gain.granularity = gpr-&gt;granularity;</a>
<a name="ln227"> </a>
<a name="ln228">	if (gpr-&gt;type &amp; EMU_MIX_GAIN) {</a>
<a name="ln229">		if (gpr-&gt;type &amp; EMU_MIX_MUTE) {</a>
<a name="ln230">			control.mix_control.id = EMU_MULTI_CONTROL_FIRSTID + i;</a>
<a name="ln231">			control.mix_control.flags = B_MULTI_MIX_ENABLE;</a>
<a name="ln232">			control.mix_control.string = S_MUTE;</a>
<a name="ln233">			control.type = EMU_MIX_MUTE;</a>
<a name="ln234">			multi-&gt;controls[i] = control;</a>
<a name="ln235">			i++;</a>
<a name="ln236">		}</a>
<a name="ln237"> </a>
<a name="ln238">		control.mix_control.id = EMU_MULTI_CONTROL_FIRSTID + i;</a>
<a name="ln239">		control.mix_control.flags = B_MULTI_MIX_GAIN;</a>
<a name="ln240">		strcpy(control.mix_control.name, gpr-&gt;name);</a>
<a name="ln241">		control.type = EMU_MIX_GAIN;</a>
<a name="ln242">		multi-&gt;controls[i] = control;</a>
<a name="ln243">		id = control.mix_control.id;</a>
<a name="ln244">		i++;</a>
<a name="ln245"> </a>
<a name="ln246">		if (gpr-&gt;type &amp; EMU_MIX_STEREO) {</a>
<a name="ln247">			control.mix_control.id = EMU_MULTI_CONTROL_FIRSTID + i;</a>
<a name="ln248">			control.mix_control.master = id;</a>
<a name="ln249">			multi-&gt;controls[i] = control;</a>
<a name="ln250">			i++;</a>
<a name="ln251">		}</a>
<a name="ln252">	}</a>
<a name="ln253">	*index = i;</a>
<a name="ln254">}</a>
<a name="ln255"> </a>
<a name="ln256">static status_t</a>
<a name="ln257">emuxki_create_controls_list(multi_dev *multi)</a>
<a name="ln258">{</a>
<a name="ln259">	uint32 	i = 0, index = 0, count, id, parent, parent2, parent3;</a>
<a name="ln260">	emuxki_dev *card = (emuxki_dev*)multi-&gt;card;</a>
<a name="ln261">	const ac97_source_info *info;</a>
<a name="ln262"> </a>
<a name="ln263">	parent = emuxki_create_group_control(multi, &amp;index, 0, 0, &quot;Playback&quot;);</a>
<a name="ln264"> </a>
<a name="ln265">	for (i = EMU_GPR_FIRST_MIX; i &lt; card-&gt;gpr_count; i++) {</a>
<a name="ln266">		const emuxki_gpr *gpr = &amp;card-&gt;gpr[i];</a>
<a name="ln267">		if ((gpr-&gt;type &amp; EMU_MIX_PLAYBACK) == 0)</a>
<a name="ln268">			continue;</a>
<a name="ln269"> </a>
<a name="ln270">		parent2 = emuxki_create_group_control(multi, &amp;index, parent, 0, gpr-&gt;name);</a>
<a name="ln271"> </a>
<a name="ln272">		emuxki_create_gpr_control(multi, &amp;index, parent2, 0, gpr);</a>
<a name="ln273">		if (gpr-&gt;type &amp; EMU_MIX_GAIN &amp;&amp; gpr-&gt;type &amp; EMU_MIX_STEREO)</a>
<a name="ln274">			i++;</a>
<a name="ln275">	}</a>
<a name="ln276"> </a>
<a name="ln277">	parent = emuxki_create_group_control(multi, &amp;index, 0, 0, &quot;Record&quot;);</a>
<a name="ln278"> </a>
<a name="ln279">	for (i = EMU_GPR_FIRST_MIX; i &lt; card-&gt;gpr_count; i++) {</a>
<a name="ln280">		const emuxki_gpr *gpr = &amp;card-&gt;gpr[i];</a>
<a name="ln281">		if ((gpr-&gt;type &amp; EMU_MIX_RECORD) == 0)</a>
<a name="ln282">			continue;</a>
<a name="ln283">		parent2 = emuxki_create_group_control(multi, &amp;index, parent, 0, gpr-&gt;name);</a>
<a name="ln284"> </a>
<a name="ln285">		emuxki_create_gpr_control(multi, &amp;index, parent2, 0, gpr);</a>
<a name="ln286">		if (gpr-&gt;type &amp; EMU_MIX_GAIN &amp;&amp; gpr-&gt;type &amp; EMU_MIX_STEREO)</a>
<a name="ln287">			i++;</a>
<a name="ln288">	}</a>
<a name="ln289"> </a>
<a name="ln290">	/* AC97 Record */</a>
<a name="ln291">	info = &amp;source_info[0];</a>
<a name="ln292">	PRINT((&quot;name : %s\n&quot;, info-&gt;name));</a>
<a name="ln293"> </a>
<a name="ln294">	parent2 = emuxki_create_group_control(multi, &amp;index, parent, 0, info-&gt;name);</a>
<a name="ln295"> </a>
<a name="ln296">	if (info-&gt;type &amp; B_MIX_GAIN) {</a>
<a name="ln297">		if (info-&gt;type &amp; B_MIX_MUTE) {</a>
<a name="ln298">			multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln299">			multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_ENABLE;</a>
<a name="ln300">			multi-&gt;controls[index].mix_control.master = EMU_MULTI_CONTROL_MASTERID;</a>
<a name="ln301">			multi-&gt;controls[index].mix_control.parent = parent2;</a>
<a name="ln302">			multi-&gt;controls[index].mix_control.string = S_MUTE;</a>
<a name="ln303">			multi-&gt;controls[index].cookie = info;</a>
<a name="ln304">			multi-&gt;controls[index].type = B_MIX_MUTE;</a>
<a name="ln305">			multi-&gt;controls[index].get = &amp;emuxki_ac97_get_mix;</a>
<a name="ln306">			multi-&gt;controls[index].set = &amp;emuxki_ac97_set_mix;</a>
<a name="ln307">			index++;</a>
<a name="ln308">		}</a>
<a name="ln309"> </a>
<a name="ln310">		multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln311">		multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_GAIN;</a>
<a name="ln312">		multi-&gt;controls[index].mix_control.master = EMU_MULTI_CONTROL_MASTERID;</a>
<a name="ln313">		multi-&gt;controls[index].mix_control.parent = parent2;</a>
<a name="ln314">		strcpy(multi-&gt;controls[index].mix_control.name, info-&gt;name);</a>
<a name="ln315">		multi-&gt;controls[index].mix_control.u.gain.min_gain = info-&gt;min_gain;</a>
<a name="ln316">		multi-&gt;controls[index].mix_control.u.gain.max_gain = info-&gt;max_gain;</a>
<a name="ln317">		multi-&gt;controls[index].mix_control.u.gain.granularity = info-&gt;granularity;</a>
<a name="ln318">		multi-&gt;controls[index].cookie = info;</a>
<a name="ln319">		multi-&gt;controls[index].type = B_MIX_GAIN;</a>
<a name="ln320">		multi-&gt;controls[index].get = &amp;emuxki_ac97_get_mix;</a>
<a name="ln321">		multi-&gt;controls[index].set = &amp;emuxki_ac97_set_mix;</a>
<a name="ln322">		id = multi-&gt;controls[index].mix_control.id;</a>
<a name="ln323">		index++;</a>
<a name="ln324"> </a>
<a name="ln325">		if (info-&gt;type &amp; B_MIX_STEREO) {</a>
<a name="ln326">			multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln327">			multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_GAIN;</a>
<a name="ln328">			multi-&gt;controls[index].mix_control.master = id;</a>
<a name="ln329">			multi-&gt;controls[index].mix_control.parent = parent2;</a>
<a name="ln330">			strcpy(multi-&gt;controls[index].mix_control.name, info-&gt;name);</a>
<a name="ln331">			multi-&gt;controls[index].mix_control.u.gain.min_gain = info-&gt;min_gain;</a>
<a name="ln332">			multi-&gt;controls[index].mix_control.u.gain.max_gain = info-&gt;max_gain;</a>
<a name="ln333">			multi-&gt;controls[index].mix_control.u.gain.granularity = info-&gt;granularity;</a>
<a name="ln334">			multi-&gt;controls[index].cookie = info;</a>
<a name="ln335">			multi-&gt;controls[index].type = B_MIX_GAIN;</a>
<a name="ln336">			multi-&gt;controls[index].get = &amp;emuxki_ac97_get_mix;</a>
<a name="ln337">			multi-&gt;controls[index].set = &amp;emuxki_ac97_set_mix;</a>
<a name="ln338">			index++;</a>
<a name="ln339">		}</a>
<a name="ln340"> </a>
<a name="ln341">		if (info-&gt;type &amp; B_MIX_RECORDMUX) {</a>
<a name="ln342">			multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln343">			multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_MUX;</a>
<a name="ln344">			multi-&gt;controls[index].mix_control.parent = parent2;</a>
<a name="ln345">			strcpy(multi-&gt;controls[index].mix_control.name, &quot;Record mux&quot;);</a>
<a name="ln346">			multi-&gt;controls[index].cookie = info;</a>
<a name="ln347">			multi-&gt;controls[index].type = B_MIX_MUX;</a>
<a name="ln348">			multi-&gt;controls[index].get = &amp;emuxki_ac97_get_mix;</a>
<a name="ln349">			multi-&gt;controls[index].set = &amp;emuxki_ac97_set_mix;</a>
<a name="ln350">			parent3 = multi-&gt;controls[index].mix_control.id;</a>
<a name="ln351">			index++;</a>
<a name="ln352"> </a>
<a name="ln353">			multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln354">			multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_MUX_VALUE;</a>
<a name="ln355">			multi-&gt;controls[index].mix_control.parent = parent3;</a>
<a name="ln356">			multi-&gt;controls[index].mix_control.string = S_MIC;</a>
<a name="ln357">			index++;</a>
<a name="ln358">			multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln359">			multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_MUX_VALUE;</a>
<a name="ln360">			multi-&gt;controls[index].mix_control.parent = parent3;</a>
<a name="ln361">			strcpy(multi-&gt;controls[index].mix_control.name, &quot;CD in&quot;);</a>
<a name="ln362">			index++;</a>
<a name="ln363">			multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln364">			multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_MUX_VALUE;</a>
<a name="ln365">			multi-&gt;controls[index].mix_control.parent = parent3;</a>
<a name="ln366">			strcpy(multi-&gt;controls[index].mix_control.name, &quot;Video in&quot;);</a>
<a name="ln367">			index++;</a>
<a name="ln368">			multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln369">			multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_MUX_VALUE;</a>
<a name="ln370">			multi-&gt;controls[index].mix_control.parent = parent3;</a>
<a name="ln371">			strcpy(multi-&gt;controls[index].mix_control.name, &quot;Aux in&quot;);</a>
<a name="ln372">			index++;</a>
<a name="ln373">			multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln374">			multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_MUX_VALUE;</a>
<a name="ln375">			multi-&gt;controls[index].mix_control.parent = parent3;</a>
<a name="ln376">			strcpy(multi-&gt;controls[index].mix_control.name, &quot;Line in&quot;);</a>
<a name="ln377">			index++;</a>
<a name="ln378">			multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln379">			multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_MUX_VALUE;</a>
<a name="ln380">			multi-&gt;controls[index].mix_control.parent = parent3;</a>
<a name="ln381">			multi-&gt;controls[index].mix_control.string = S_STEREO_MIX;</a>
<a name="ln382">			index++;</a>
<a name="ln383">			multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln384">			multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_MUX_VALUE;</a>
<a name="ln385">			multi-&gt;controls[index].mix_control.parent = parent3;</a>
<a name="ln386">			multi-&gt;controls[index].mix_control.string = S_MONO_MIX;</a>
<a name="ln387">			index++;</a>
<a name="ln388">			multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln389">			multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_MUX_VALUE;</a>
<a name="ln390">			multi-&gt;controls[index].mix_control.parent = parent3;</a>
<a name="ln391">			strcpy(multi-&gt;controls[index].mix_control.name, &quot;TAD&quot;);</a>
<a name="ln392">			index++;</a>
<a name="ln393">		}</a>
<a name="ln394">	}</a>
<a name="ln395"> </a>
<a name="ln396">	parent = emuxki_create_group_control(multi, &amp;index, 0, 0, &quot;AC97 mixer&quot;);</a>
<a name="ln397"> </a>
<a name="ln398">	count = source_info_size;</a>
<a name="ln399">	if (IS_AUDIGY2(&amp;card-&gt;config))</a>
<a name="ln400">		count = 1;</a>
<a name="ln401">	if (!IS_LIVE_5_1(&amp;card-&gt;config) &amp;&amp; !IS_AUDIGY(&amp;card-&gt;config))</a>
<a name="ln402">		count--;</a>
<a name="ln403"> </a>
<a name="ln404">	for (i = 1; i &lt; count ; i++) {</a>
<a name="ln405">		info = &amp;source_info[i];</a>
<a name="ln406">		PRINT((&quot;name : %s\n&quot;, info-&gt;name));</a>
<a name="ln407"> </a>
<a name="ln408">		parent2 = emuxki_create_group_control(multi, &amp;index, parent, 0, info-&gt;name);</a>
<a name="ln409"> </a>
<a name="ln410">		if (info-&gt;type &amp; B_MIX_GAIN) {</a>
<a name="ln411">			if (info-&gt;type &amp; B_MIX_MUTE) {</a>
<a name="ln412">				multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln413">				multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_ENABLE;</a>
<a name="ln414">				multi-&gt;controls[index].mix_control.master = EMU_MULTI_CONTROL_MASTERID;</a>
<a name="ln415">				multi-&gt;controls[index].mix_control.parent = parent2;</a>
<a name="ln416">				multi-&gt;controls[index].mix_control.string = S_MUTE;</a>
<a name="ln417">				multi-&gt;controls[index].cookie = info;</a>
<a name="ln418">				multi-&gt;controls[index].type = B_MIX_MUTE;</a>
<a name="ln419">				multi-&gt;controls[index].get = &amp;emuxki_ac97_get_mix;</a>
<a name="ln420">				multi-&gt;controls[index].set = &amp;emuxki_ac97_set_mix;</a>
<a name="ln421">				index++;</a>
<a name="ln422">			}</a>
<a name="ln423"> </a>
<a name="ln424">			multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln425">			multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_GAIN;</a>
<a name="ln426">			multi-&gt;controls[index].mix_control.master = EMU_MULTI_CONTROL_MASTERID;</a>
<a name="ln427">			multi-&gt;controls[index].mix_control.parent = parent2;</a>
<a name="ln428">			strcpy(multi-&gt;controls[index].mix_control.name, info-&gt;name);</a>
<a name="ln429">			multi-&gt;controls[index].mix_control.u.gain.min_gain = info-&gt;min_gain;</a>
<a name="ln430">			multi-&gt;controls[index].mix_control.u.gain.max_gain = info-&gt;max_gain;</a>
<a name="ln431">			multi-&gt;controls[index].mix_control.u.gain.granularity = info-&gt;granularity;</a>
<a name="ln432">			multi-&gt;controls[index].cookie = info;</a>
<a name="ln433">			multi-&gt;controls[index].type = B_MIX_GAIN;</a>
<a name="ln434">			multi-&gt;controls[index].get = &amp;emuxki_ac97_get_mix;</a>
<a name="ln435">			multi-&gt;controls[index].set = &amp;emuxki_ac97_set_mix;</a>
<a name="ln436">			id = multi-&gt;controls[index].mix_control.id;</a>
<a name="ln437">			index++;</a>
<a name="ln438"> </a>
<a name="ln439">			if (info-&gt;type &amp; B_MIX_STEREO) {</a>
<a name="ln440">				multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln441">				multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_GAIN;</a>
<a name="ln442">				multi-&gt;controls[index].mix_control.master = id;</a>
<a name="ln443">				multi-&gt;controls[index].mix_control.parent = parent2;</a>
<a name="ln444">				strcpy(multi-&gt;controls[index].mix_control.name, info-&gt;name);</a>
<a name="ln445">				multi-&gt;controls[index].mix_control.u.gain.min_gain = info-&gt;min_gain;</a>
<a name="ln446">				multi-&gt;controls[index].mix_control.u.gain.max_gain = info-&gt;max_gain;</a>
<a name="ln447">				multi-&gt;controls[index].mix_control.u.gain.granularity = info-&gt;granularity;</a>
<a name="ln448">				multi-&gt;controls[index].cookie = info;</a>
<a name="ln449">				multi-&gt;controls[index].type = B_MIX_GAIN;</a>
<a name="ln450">				multi-&gt;controls[index].get = &amp;emuxki_ac97_get_mix;</a>
<a name="ln451">				multi-&gt;controls[index].set = &amp;emuxki_ac97_set_mix;</a>
<a name="ln452">				index++;</a>
<a name="ln453">			}</a>
<a name="ln454">		}</a>
<a name="ln455">	}</a>
<a name="ln456"> </a>
<a name="ln457">	parent = emuxki_create_group_control(multi, &amp;index, 0, S_SETUP, NULL);</a>
<a name="ln458"> </a>
<a name="ln459">	/* AC97 20db Boost Mic */</a>
<a name="ln460">	info = &amp;source_info[6];</a>
<a name="ln461"> </a>
<a name="ln462">	if (info-&gt;type &amp; B_MIX_GAIN &amp;&amp; info-&gt;type &amp; B_MIX_MICBOOST) {</a>
<a name="ln463">		multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln464">		multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_ENABLE;</a>
<a name="ln465">		multi-&gt;controls[index].mix_control.master = EMU_MULTI_CONTROL_MASTERID;</a>
<a name="ln466">		multi-&gt;controls[index].mix_control.parent = parent;</a>
<a name="ln467">		strcpy(multi-&gt;controls[index].mix_control.name, &quot;Mic +20dB&quot;);</a>
<a name="ln468">		multi-&gt;controls[index].cookie = info;</a>
<a name="ln469">		multi-&gt;controls[index].type = B_MIX_MICBOOST;</a>
<a name="ln470">		multi-&gt;controls[index].get = &amp;emuxki_ac97_get_mix;</a>
<a name="ln471">		multi-&gt;controls[index].set = &amp;emuxki_ac97_set_mix;</a>
<a name="ln472">		index++;</a>
<a name="ln473">	}</a>
<a name="ln474"> </a>
<a name="ln475">	if (true) {</a>
<a name="ln476">		multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln477">		multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_ENABLE;</a>
<a name="ln478">		multi-&gt;controls[index].mix_control.master = EMU_MULTI_CONTROL_MASTERID;</a>
<a name="ln479">		multi-&gt;controls[index].mix_control.parent = parent;</a>
<a name="ln480">		strcpy(multi-&gt;controls[index].mix_control.name, &quot;Enable digital&quot;);</a>
<a name="ln481">		multi-&gt;controls[index].cookie = NULL;</a>
<a name="ln482">		multi-&gt;controls[index].type = EMU_DIGITAL_MODE;</a>
<a name="ln483">		multi-&gt;controls[index].get = &amp;emuxki_parameter_get_mix;</a>
<a name="ln484">		multi-&gt;controls[index].set = &amp;emuxki_parameter_set_mix;</a>
<a name="ln485">		index++;</a>
<a name="ln486">	}</a>
<a name="ln487"> </a>
<a name="ln488">	if (true) {</a>
<a name="ln489">		multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln490">		multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_MUX;</a>
<a name="ln491">		multi-&gt;controls[index].mix_control.parent = parent;</a>
<a name="ln492">		strcpy(multi-&gt;controls[index].mix_control.name, &quot;Audio mode&quot;);</a>
<a name="ln493">		multi-&gt;controls[index].cookie = NULL;</a>
<a name="ln494">		multi-&gt;controls[index].type = EMU_AUDIO_MODE;</a>
<a name="ln495">		multi-&gt;controls[index].get = &amp;emuxki_parameter_get_mix;</a>
<a name="ln496">		multi-&gt;controls[index].set = &amp;emuxki_parameter_set_mix;</a>
<a name="ln497">		parent2 = multi-&gt;controls[index].mix_control.id;</a>
<a name="ln498">		index++;</a>
<a name="ln499"> </a>
<a name="ln500">		multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln501">		multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_MUX_VALUE;</a>
<a name="ln502">		multi-&gt;controls[index].mix_control.parent = parent2;</a>
<a name="ln503">		strcpy(multi-&gt;controls[index].mix_control.name, &quot;2.0&quot;);</a>
<a name="ln504">		index++;</a>
<a name="ln505">		multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln506">		multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_MUX_VALUE;</a>
<a name="ln507">		multi-&gt;controls[index].mix_control.parent = parent2;</a>
<a name="ln508">		strcpy(multi-&gt;controls[index].mix_control.name, &quot;4.0&quot;);</a>
<a name="ln509">		index++;</a>
<a name="ln510">		multi-&gt;controls[index].mix_control.id = EMU_MULTI_CONTROL_FIRSTID + index;</a>
<a name="ln511">		multi-&gt;controls[index].mix_control.flags = B_MULTI_MIX_MUX_VALUE;</a>
<a name="ln512">		multi-&gt;controls[index].mix_control.parent = parent2;</a>
<a name="ln513">		strcpy(multi-&gt;controls[index].mix_control.name, &quot;5.1&quot;);</a>
<a name="ln514">		index++;</a>
<a name="ln515">	}</a>
<a name="ln516"> </a>
<a name="ln517">	multi-&gt;control_count = index;</a>
<a name="ln518">	PRINT((&quot;multi-&gt;control_count %lu\n&quot;, multi-&gt;control_count));</a>
<a name="ln519">	return B_OK;</a>
<a name="ln520">}</a>
<a name="ln521"> </a>
<a name="ln522">static status_t</a>
<a name="ln523">emuxki_get_mix(emuxki_dev *card, multi_mix_value_info * mmvi)</a>
<a name="ln524">{</a>
<a name="ln525">	int32 i;</a>
<a name="ln526">	uint32 id;</a>
<a name="ln527">	multi_mixer_control *control = NULL;</a>
<a name="ln528">	for (i = 0; i &lt; mmvi-&gt;item_count; i++) {</a>
<a name="ln529">		id = mmvi-&gt;values[i].id - EMU_MULTI_CONTROL_FIRSTID;</a>
<a name="ln530">		if (id &lt; 0 || id &gt;= card-&gt;multi.control_count) {</a>
<a name="ln531">			PRINT((&quot;emuxki_get_mix : invalid control id requested : %li\n&quot;, id));</a>
<a name="ln532">			continue;</a>
<a name="ln533">		}</a>
<a name="ln534">		control = &amp;card-&gt;multi.controls[id];</a>
<a name="ln535"> </a>
<a name="ln536">		if (control-&gt;mix_control.flags &amp; B_MULTI_MIX_GAIN) {</a>
<a name="ln537">			if (control-&gt;get) {</a>
<a name="ln538">				float values[2];</a>
<a name="ln539">				control-&gt;get(card, control-&gt;cookie, control-&gt;type, values);</a>
<a name="ln540">				if (control-&gt;mix_control.master == EMU_MULTI_CONTROL_MASTERID)</a>
<a name="ln541">					mmvi-&gt;values[i].u.gain = values[0];</a>
<a name="ln542">				else</a>
<a name="ln543">					mmvi-&gt;values[i].u.gain = values[1];</a>
<a name="ln544">			}</a>
<a name="ln545">		}</a>
<a name="ln546"> </a>
<a name="ln547">		if (control-&gt;mix_control.flags &amp; B_MULTI_MIX_ENABLE &amp;&amp; control-&gt;get) {</a>
<a name="ln548">			float values[1];</a>
<a name="ln549">			control-&gt;get(card, control-&gt;cookie, control-&gt;type, values);</a>
<a name="ln550">			mmvi-&gt;values[i].u.enable = (values[0] == 1.0);</a>
<a name="ln551">		}</a>
<a name="ln552"> </a>
<a name="ln553">		if (control-&gt;mix_control.flags &amp; B_MULTI_MIX_MUX &amp;&amp; control-&gt;get) {</a>
<a name="ln554">			float values[1];</a>
<a name="ln555">			control-&gt;get(card, control-&gt;cookie, control-&gt;type, values);</a>
<a name="ln556">			mmvi-&gt;values[i].u.mux = (int32)values[0];</a>
<a name="ln557">		}</a>
<a name="ln558">	}</a>
<a name="ln559">	return B_OK;</a>
<a name="ln560">}</a>
<a name="ln561"> </a>
<a name="ln562">static status_t</a>
<a name="ln563">emuxki_set_mix(emuxki_dev *card, multi_mix_value_info * mmvi)</a>
<a name="ln564">{</a>
<a name="ln565">	int32 i;</a>
<a name="ln566">	uint32 id;</a>
<a name="ln567">	multi_mixer_control *control = NULL;</a>
<a name="ln568">	for (i = 0; i &lt; mmvi-&gt;item_count; i++) {</a>
<a name="ln569">		id = mmvi-&gt;values[i].id - EMU_MULTI_CONTROL_FIRSTID;</a>
<a name="ln570">		if (id &lt; 0 || id &gt;= card-&gt;multi.control_count) {</a>
<a name="ln571">			PRINT((&quot;emuxki_set_mix : invalid control id requested : %li\n&quot;, id));</a>
<a name="ln572">			continue;</a>
<a name="ln573">		}</a>
<a name="ln574">		control = &amp;card-&gt;multi.controls[id];</a>
<a name="ln575"> </a>
<a name="ln576">		if (control-&gt;mix_control.flags &amp; B_MULTI_MIX_GAIN) {</a>
<a name="ln577">			multi_mixer_control *control2 = NULL;</a>
<a name="ln578">			if (i+1&lt;mmvi-&gt;item_count) {</a>
<a name="ln579">				id = mmvi-&gt;values[i + 1].id - EMU_MULTI_CONTROL_FIRSTID;</a>
<a name="ln580">				if (id &lt; 0 || id &gt;= card-&gt;multi.control_count) {</a>
<a name="ln581">					PRINT((&quot;emuxki_set_mix : invalid control id requested : %li\n&quot;, id));</a>
<a name="ln582">				} else {</a>
<a name="ln583">					control2 = &amp;card-&gt;multi.controls[id];</a>
<a name="ln584">					if (control2-&gt;mix_control.master != control-&gt;mix_control.id)</a>
<a name="ln585">						control2 = NULL;</a>
<a name="ln586">				}</a>
<a name="ln587">			}</a>
<a name="ln588"> </a>
<a name="ln589">			if (control-&gt;set) {</a>
<a name="ln590">				float values[2];</a>
<a name="ln591">				values[0] = 0.0;</a>
<a name="ln592">				values[1] = 0.0;</a>
<a name="ln593"> </a>
<a name="ln594">				if (control-&gt;mix_control.master == EMU_MULTI_CONTROL_MASTERID)</a>
<a name="ln595">					values[0] = mmvi-&gt;values[i].u.gain;</a>
<a name="ln596">				else</a>
<a name="ln597">					values[1] = mmvi-&gt;values[i].u.gain;</a>
<a name="ln598"> </a>
<a name="ln599">				if (control2 &amp;&amp; control2-&gt;mix_control.master != EMU_MULTI_CONTROL_MASTERID)</a>
<a name="ln600">					values[1] = mmvi-&gt;values[i+1].u.gain;</a>
<a name="ln601"> </a>
<a name="ln602">				control-&gt;set(card, control-&gt;cookie, control-&gt;type, values);</a>
<a name="ln603">			}</a>
<a name="ln604"> </a>
<a name="ln605">			if (control2)</a>
<a name="ln606">				i++;</a>
<a name="ln607">		}</a>
<a name="ln608"> </a>
<a name="ln609">		if (control-&gt;mix_control.flags &amp; B_MULTI_MIX_ENABLE &amp;&amp; control-&gt;set) {</a>
<a name="ln610">			float values[1];</a>
<a name="ln611"> </a>
<a name="ln612">			values[0] = mmvi-&gt;values[i].u.enable ? 1.0 : 0.0;</a>
<a name="ln613">			control-&gt;set(card, control-&gt;cookie, control-&gt;type, values);</a>
<a name="ln614">		}</a>
<a name="ln615"> </a>
<a name="ln616">		if (control-&gt;mix_control.flags &amp; B_MULTI_MIX_MUX &amp;&amp; control-&gt;set) {</a>
<a name="ln617">			float values[1];</a>
<a name="ln618"> </a>
<a name="ln619">			values[0] = (float)mmvi-&gt;values[i].u.mux;</a>
<a name="ln620">			control-&gt;set(card, control-&gt;cookie, control-&gt;type, values);</a>
<a name="ln621">		}</a>
<a name="ln622">	}</a>
<a name="ln623">	return B_OK;</a>
<a name="ln624">}</a>
<a name="ln625"> </a>
<a name="ln626">static status_t</a>
<a name="ln627">emuxki_list_mix_controls(emuxki_dev *card, multi_mix_control_info * mmci)</a>
<a name="ln628">{</a>
<a name="ln629">	multi_mix_control	*mmc;</a>
<a name="ln630">	uint32 i;</a>
<a name="ln631"> </a>
<a name="ln632">	mmc = mmci-&gt;controls;</a>
<a name="ln633">	if (mmci-&gt;control_count &lt; EMU_MULTICONTROLSNUM)</a>
<a name="ln634">		return B_ERROR;</a>
<a name="ln635"> </a>
<a name="ln636">	if (emuxki_create_controls_list(&amp;card-&gt;multi) &lt; B_OK)</a>
<a name="ln637">		return B_ERROR;</a>
<a name="ln638">	for (i = 0; i &lt; card-&gt;multi.control_count; i++) {</a>
<a name="ln639">		mmc[i] = card-&gt;multi.controls[i].mix_control;</a>
<a name="ln640">	}</a>
<a name="ln641"> </a>
<a name="ln642">	mmci-&gt;control_count = card-&gt;multi.control_count;</a>
<a name="ln643">	return B_OK;</a>
<a name="ln644">}</a>
<a name="ln645"> </a>
<a name="ln646">static status_t</a>
<a name="ln647">emuxki_list_mix_connections(emuxki_dev *card, multi_mix_connection_info * data)</a>
<a name="ln648">{</a>
<a name="ln649">	return B_ERROR;</a>
<a name="ln650">}</a>
<a name="ln651"> </a>
<a name="ln652">static status_t</a>
<a name="ln653">emuxki_list_mix_channels(emuxki_dev *card, multi_mix_channel_info *data)</a>
<a name="ln654">{</a>
<a name="ln655">	return B_ERROR;</a>
<a name="ln656">}</a>
<a name="ln657"> </a>
<a name="ln658">/*multi_channel_info chans[] = {</a>
<a name="ln659">{  0, B_MULTI_OUTPUT_CHANNEL, 	B_CHANNEL_LEFT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln660">{  1, B_MULTI_OUTPUT_CHANNEL, 	B_CHANNEL_RIGHT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln661">{  2, B_MULTI_OUTPUT_CHANNEL, 	B_CHANNEL_LEFT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln662">{  3, B_MULTI_OUTPUT_CHANNEL, 	B_CHANNEL_RIGHT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln663">{  4, B_MULTI_INPUT_CHANNEL, 	B_CHANNEL_LEFT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln664">{  5, B_MULTI_INPUT_CHANNEL, 	B_CHANNEL_RIGHT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln665">{  6, B_MULTI_INPUT_CHANNEL, 	B_CHANNEL_LEFT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln666">{  7, B_MULTI_INPUT_CHANNEL, 	B_CHANNEL_RIGHT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln667">{  8, B_MULTI_OUTPUT_BUS, 		B_CHANNEL_LEFT | B_CHANNEL_STEREO_BUS, 	B_CHANNEL_MINI_JACK_STEREO },</a>
<a name="ln668">{  9, B_MULTI_OUTPUT_BUS, 		B_CHANNEL_RIGHT | B_CHANNEL_STEREO_BUS, B_CHANNEL_MINI_JACK_STEREO },</a>
<a name="ln669">{  10, B_MULTI_INPUT_BUS, 		B_CHANNEL_LEFT | B_CHANNEL_STEREO_BUS, 	B_CHANNEL_MINI_JACK_STEREO },</a>
<a name="ln670">{  11, B_MULTI_INPUT_BUS, 		B_CHANNEL_RIGHT | B_CHANNEL_STEREO_BUS, B_CHANNEL_MINI_JACK_STEREO },</a>
<a name="ln671">};*/</a>
<a name="ln672"> </a>
<a name="ln673">/*multi_channel_info chans[] = {</a>
<a name="ln674">{  0, B_MULTI_OUTPUT_CHANNEL, 	B_CHANNEL_LEFT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln675">{  1, B_MULTI_OUTPUT_CHANNEL, 	B_CHANNEL_RIGHT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln676">{  2, B_MULTI_OUTPUT_CHANNEL, 	B_CHANNEL_LEFT | B_CHANNEL_SURROUND_BUS, 0 },</a>
<a name="ln677">{  3, B_MULTI_OUTPUT_CHANNEL, 	B_CHANNEL_RIGHT | B_CHANNEL_SURROUND_BUS, 0 },</a>
<a name="ln678">{  4, B_MULTI_OUTPUT_CHANNEL, 	B_CHANNEL_REARLEFT | B_CHANNEL_SURROUND_BUS, 0 },</a>
<a name="ln679">{  5, B_MULTI_OUTPUT_CHANNEL, 	B_CHANNEL_REARRIGHT | B_CHANNEL_SURROUND_BUS, 0 },</a>
<a name="ln680">{  6, B_MULTI_INPUT_CHANNEL, 	B_CHANNEL_LEFT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln681">{  7, B_MULTI_INPUT_CHANNEL, 	B_CHANNEL_RIGHT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln682">{  8, B_MULTI_INPUT_CHANNEL, 	B_CHANNEL_LEFT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln683">{  9, B_MULTI_INPUT_CHANNEL, 	B_CHANNEL_RIGHT | B_CHANNEL_STEREO_BUS, 0 },</a>
<a name="ln684">{  10, B_MULTI_OUTPUT_BUS, 		B_CHANNEL_LEFT | B_CHANNEL_STEREO_BUS, 	B_CHANNEL_MINI_JACK_STEREO },</a>
<a name="ln685">{  11, B_MULTI_OUTPUT_BUS, 		B_CHANNEL_RIGHT | B_CHANNEL_STEREO_BUS, B_CHANNEL_MINI_JACK_STEREO },</a>
<a name="ln686">{  12, B_MULTI_INPUT_BUS, 		B_CHANNEL_LEFT | B_CHANNEL_STEREO_BUS, 	B_CHANNEL_MINI_JACK_STEREO },</a>
<a name="ln687">{  13, B_MULTI_INPUT_BUS, 		B_CHANNEL_RIGHT | B_CHANNEL_STEREO_BUS, B_CHANNEL_MINI_JACK_STEREO },</a>
<a name="ln688">};*/</a>
<a name="ln689"> </a>
<a name="ln690"> </a>
<a name="ln691">static void</a>
<a name="ln692">emuxki_create_channels_list(multi_dev *multi)</a>
<a name="ln693">{</a>
<a name="ln694">	emuxki_stream *stream;</a>
<a name="ln695">	uint32 index, i, designations, nchannels;</a>
<a name="ln696">	int32 mode;</a>
<a name="ln697">	multi_channel_info *chans;</a>
<a name="ln698">	uint32 chan_designations[] = {</a>
<a name="ln699">		B_CHANNEL_LEFT,</a>
<a name="ln700">		B_CHANNEL_RIGHT,</a>
<a name="ln701">		B_CHANNEL_REARLEFT,</a>
<a name="ln702">		B_CHANNEL_REARRIGHT,</a>
<a name="ln703">		B_CHANNEL_CENTER,</a>
<a name="ln704">		B_CHANNEL_SUB</a>
<a name="ln705">	};</a>
<a name="ln706"> </a>
<a name="ln707">	chans = multi-&gt;chans;</a>
<a name="ln708">	index = 0;</a>
<a name="ln709"> </a>
<a name="ln710">	for (mode=EMU_USE_PLAY; mode!=-1;</a>
<a name="ln711">		mode = (mode == EMU_USE_PLAY) ? EMU_USE_RECORD : -1) {</a>
<a name="ln712">		LIST_FOREACH(stream, &amp;((emuxki_dev*)multi-&gt;card)-&gt;streams, next) {</a>
<a name="ln713">			if ((stream-&gt;use &amp; mode) == 0)</a>
<a name="ln714">				continue;</a>
<a name="ln715"> </a>
<a name="ln716">			nchannels = stream-&gt;nmono + 2 * stream-&gt;nstereo;</a>
<a name="ln717">			if (nchannels == 2)</a>
<a name="ln718">				designations = B_CHANNEL_STEREO_BUS;</a>
<a name="ln719">			else</a>
<a name="ln720">				designations = B_CHANNEL_SURROUND_BUS;</a>
<a name="ln721"> </a>
<a name="ln722">			for (i = 0; i &lt; nchannels; i++) {</a>
<a name="ln723">				chans[index].channel_id = index;</a>
<a name="ln724">				chans[index].kind = (mode == EMU_USE_PLAY) ? B_MULTI_OUTPUT_CHANNEL : B_MULTI_INPUT_CHANNEL;</a>
<a name="ln725">				chans[index].designations = designations | chan_designations[i];</a>
<a name="ln726">				chans[index].connectors = 0;</a>
<a name="ln727">				index++;</a>
<a name="ln728">			}</a>
<a name="ln729">		}</a>
<a name="ln730"> </a>
<a name="ln731">		if (mode==EMU_USE_PLAY) {</a>
<a name="ln732">			multi-&gt;output_channel_count = index;</a>
<a name="ln733">		} else {</a>
<a name="ln734">			multi-&gt;input_channel_count = index - multi-&gt;output_channel_count;</a>
<a name="ln735">		}</a>
<a name="ln736">	}</a>
<a name="ln737"> </a>
<a name="ln738">	chans[index].channel_id = index;</a>
<a name="ln739">	chans[index].kind = B_MULTI_OUTPUT_BUS;</a>
<a name="ln740">	chans[index].designations = B_CHANNEL_LEFT | B_CHANNEL_STEREO_BUS;</a>
<a name="ln741">	chans[index].connectors = B_CHANNEL_MINI_JACK_STEREO;</a>
<a name="ln742">	index++;</a>
<a name="ln743"> </a>
<a name="ln744">	chans[index].channel_id = index;</a>
<a name="ln745">	chans[index].kind = B_MULTI_OUTPUT_BUS;</a>
<a name="ln746">	chans[index].designations = B_CHANNEL_RIGHT | B_CHANNEL_STEREO_BUS;</a>
<a name="ln747">	chans[index].connectors = B_CHANNEL_MINI_JACK_STEREO;</a>
<a name="ln748">	index++;</a>
<a name="ln749"> </a>
<a name="ln750">	multi-&gt;output_bus_channel_count = index - multi-&gt;output_channel_count</a>
<a name="ln751">		- multi-&gt;input_channel_count;</a>
<a name="ln752"> </a>
<a name="ln753">	chans[index].channel_id = index;</a>
<a name="ln754">	chans[index].kind = B_MULTI_INPUT_BUS;</a>
<a name="ln755">	chans[index].designations = B_CHANNEL_LEFT | B_CHANNEL_STEREO_BUS;</a>
<a name="ln756">	chans[index].connectors = B_CHANNEL_MINI_JACK_STEREO;</a>
<a name="ln757">	index++;</a>
<a name="ln758"> </a>
<a name="ln759">	chans[index].channel_id = index;</a>
<a name="ln760">	chans[index].kind = B_MULTI_INPUT_BUS;</a>
<a name="ln761">	chans[index].designations = B_CHANNEL_RIGHT | B_CHANNEL_STEREO_BUS;</a>
<a name="ln762">	chans[index].connectors = B_CHANNEL_MINI_JACK_STEREO;</a>
<a name="ln763">	index++;</a>
<a name="ln764"> </a>
<a name="ln765">	multi-&gt;input_bus_channel_count = index - multi-&gt;output_channel_count</a>
<a name="ln766">		- multi-&gt;input_channel_count - multi-&gt;output_bus_channel_count;</a>
<a name="ln767"> </a>
<a name="ln768">	multi-&gt;aux_bus_channel_count = 0;</a>
<a name="ln769">}</a>
<a name="ln770"> </a>
<a name="ln771"> </a>
<a name="ln772">static status_t</a>
<a name="ln773">emuxki_get_description(emuxki_dev *card, multi_description *data)</a>
<a name="ln774">{</a>
<a name="ln775">	int32 size;</a>
<a name="ln776"> </a>
<a name="ln777">	data-&gt;interface_version = B_CURRENT_INTERFACE_VERSION;</a>
<a name="ln778">	data-&gt;interface_minimum = B_CURRENT_INTERFACE_VERSION;</a>
<a name="ln779"> </a>
<a name="ln780">	if (IS_AUDIGY2_VALUE(&amp;card-&gt;config))</a>
<a name="ln781">		strncpy(data-&gt;friendly_name, FRIENDLY_NAME_AUDIGY2_VALUE, 32);</a>
<a name="ln782">	else if (IS_AUDIGY2(&amp;card-&gt;config))</a>
<a name="ln783">		strncpy(data-&gt;friendly_name, FRIENDLY_NAME_AUDIGY2, 32);</a>
<a name="ln784">	else if (IS_AUDIGY(&amp;card-&gt;config))</a>
<a name="ln785">		strncpy(data-&gt;friendly_name, FRIENDLY_NAME_AUDIGY, 32);</a>
<a name="ln786">	else if (IS_LIVE_5_1(&amp;card-&gt;config))</a>
<a name="ln787">		strncpy(data-&gt;friendly_name, FRIENDLY_NAME_LIVE_5_1, 32);</a>
<a name="ln788">	else</a>
<a name="ln789">		strncpy(data-&gt;friendly_name, FRIENDLY_NAME_LIVE, 32);</a>
<a name="ln790">	strcpy(data-&gt;vendor_info, AUTHOR);</a>
<a name="ln791"> </a>
<a name="ln792">	/*data-&gt;output_channel_count = 6;</a>
<a name="ln793">	data-&gt;input_channel_count = 4;</a>
<a name="ln794">	data-&gt;output_bus_channel_count = 2;</a>
<a name="ln795">	data-&gt;input_bus_channel_count = 2;</a>
<a name="ln796">	data-&gt;aux_bus_channel_count = 0;*/</a>
<a name="ln797"> </a>
<a name="ln798">	data-&gt;output_channel_count = card-&gt;multi.output_channel_count;</a>
<a name="ln799">	data-&gt;input_channel_count = card-&gt;multi.input_channel_count;</a>
<a name="ln800">	data-&gt;output_bus_channel_count = card-&gt;multi.output_bus_channel_count;</a>
<a name="ln801">	data-&gt;input_bus_channel_count = card-&gt;multi.input_bus_channel_count;</a>
<a name="ln802">	data-&gt;aux_bus_channel_count = card-&gt;multi.aux_bus_channel_count;</a>
<a name="ln803"> </a>
<a name="ln804">	size = card-&gt;multi.output_channel_count + card-&gt;multi.input_channel_count</a>
<a name="ln805">			+ card-&gt;multi.output_bus_channel_count + card-&gt;multi.input_bus_channel_count</a>
<a name="ln806">			+ card-&gt;multi.aux_bus_channel_count;</a>
<a name="ln807"> </a>
<a name="ln808">	// for each channel, starting with the first output channel,</a>
<a name="ln809">	// then the second, third..., followed by the first input</a>
<a name="ln810">	// channel, second, third, ..., followed by output bus</a>
<a name="ln811">	// channels and input bus channels and finally auxillary channels,</a>
<a name="ln812"> </a>
<a name="ln813">	LOG((&quot;request_channel_count = %d\n&quot;,data-&gt;request_channel_count));</a>
<a name="ln814">	if (data-&gt;request_channel_count &gt;= size) {</a>
<a name="ln815">		LOG((&quot;copying data\n&quot;));</a>
<a name="ln816">		memcpy(data-&gt;channels, card-&gt;multi.chans, size * sizeof(card-&gt;multi.chans[0]));</a>
<a name="ln817">	}</a>
<a name="ln818"> </a>
<a name="ln819">	switch (current_settings.sample_rate) {</a>
<a name="ln820">		case 192000: data-&gt;output_rates = data-&gt;input_rates = B_SR_192000; break;</a>
<a name="ln821">		case 96000: data-&gt;output_rates = data-&gt;input_rates = B_SR_96000; break;</a>
<a name="ln822">		case 48000: data-&gt;output_rates = data-&gt;input_rates = B_SR_48000; break;</a>
<a name="ln823">		case 44100: data-&gt;output_rates = data-&gt;input_rates = B_SR_44100; break;</a>
<a name="ln824">	}</a>
<a name="ln825">	data-&gt;min_cvsr_rate = 0;</a>
<a name="ln826">	data-&gt;max_cvsr_rate = 48000;</a>
<a name="ln827"> </a>
<a name="ln828">	switch (current_settings.bitsPerSample) {</a>
<a name="ln829">		case 8: data-&gt;output_formats = data-&gt;input_formats = B_FMT_8BIT_U; break;</a>
<a name="ln830">		case 16: data-&gt;output_formats = data-&gt;input_formats = B_FMT_16BIT; break;</a>
<a name="ln831">		case 24: data-&gt;output_formats = data-&gt;input_formats = B_FMT_24BIT; break;</a>
<a name="ln832">		case 32: data-&gt;output_formats = data-&gt;input_formats = B_FMT_32BIT; break;</a>
<a name="ln833">	}</a>
<a name="ln834">	data-&gt;lock_sources = B_MULTI_LOCK_INTERNAL;</a>
<a name="ln835">	data-&gt;timecode_sources = 0;</a>
<a name="ln836">	data-&gt;interface_flags = B_MULTI_INTERFACE_PLAYBACK | B_MULTI_INTERFACE_RECORD;</a>
<a name="ln837">	data-&gt;start_latency = 3000;</a>
<a name="ln838"> </a>
<a name="ln839">	strcpy(data-&gt;control_panel,&quot;&quot;);</a>
<a name="ln840"> </a>
<a name="ln841">	return B_OK;</a>
<a name="ln842">}</a>
<a name="ln843"> </a>
<a name="ln844">static status_t</a>
<a name="ln845">emuxki_get_enabled_channels(emuxki_dev *card, multi_channel_enable *data)</a>
<a name="ln846">{</a>
<a name="ln847">	B_SET_CHANNEL(data-&gt;enable_bits, 0, true);</a>
<a name="ln848">	B_SET_CHANNEL(data-&gt;enable_bits, 1, true);</a>
<a name="ln849">	B_SET_CHANNEL(data-&gt;enable_bits, 2, true);</a>
<a name="ln850">	B_SET_CHANNEL(data-&gt;enable_bits, 3, true);</a>
<a name="ln851">	data-&gt;lock_source = B_MULTI_LOCK_INTERNAL;</a>
<a name="ln852">/*</a>
<a name="ln853">	uint32			lock_source;</a>
<a name="ln854">	int32			lock_data;</a>
<a name="ln855">	uint32			timecode_source;</a>
<a name="ln856">	uint32 *		connectors;</a>
<a name="ln857">*/</a>
<a name="ln858">	return B_OK;</a>
<a name="ln859">}</a>
<a name="ln860"> </a>
<a name="ln861">static status_t</a>
<a name="ln862">emuxki_set_enabled_channels(emuxki_dev *card, multi_channel_enable *data)</a>
<a name="ln863">{</a>
<a name="ln864">	PRINT((&quot;set_enabled_channels 0 : %s\n&quot;, B_TEST_CHANNEL(data-&gt;enable_bits, 0) ? &quot;enabled&quot;: &quot;disabled&quot;));</a>
<a name="ln865">	PRINT((&quot;set_enabled_channels 1 : %s\n&quot;, B_TEST_CHANNEL(data-&gt;enable_bits, 1) ? &quot;enabled&quot;: &quot;disabled&quot;));</a>
<a name="ln866">	PRINT((&quot;set_enabled_channels 2 : %s\n&quot;, B_TEST_CHANNEL(data-&gt;enable_bits, 2) ? &quot;enabled&quot;: &quot;disabled&quot;));</a>
<a name="ln867">	PRINT((&quot;set_enabled_channels 3 : %s\n&quot;, B_TEST_CHANNEL(data-&gt;enable_bits, 3) ? &quot;enabled&quot;: &quot;disabled&quot;));</a>
<a name="ln868">	return B_OK;</a>
<a name="ln869">}</a>
<a name="ln870"> </a>
<a name="ln871">static status_t</a>
<a name="ln872">emuxki_get_global_format(emuxki_dev *card, multi_format_info *data)</a>
<a name="ln873">{</a>
<a name="ln874">	data-&gt;output_latency = 0;</a>
<a name="ln875">	data-&gt;input_latency = 0;</a>
<a name="ln876">	data-&gt;timecode_kind = 0;</a>
<a name="ln877">	switch (current_settings.sample_rate) {</a>
<a name="ln878">		case 192000: data-&gt;output.rate = data-&gt;input.rate = B_SR_192000; break;</a>
<a name="ln879">		case 96000: data-&gt;output.rate = data-&gt;input.rate = B_SR_96000; break;</a>
<a name="ln880">		case 48000: data-&gt;output.rate = data-&gt;input.rate = B_SR_48000; break;</a>
<a name="ln881">		case 44100: data-&gt;output.rate = data-&gt;input.rate = B_SR_44100; break;</a>
<a name="ln882">	}</a>
<a name="ln883">	switch (current_settings.bitsPerSample) {</a>
<a name="ln884">		case 8: data-&gt;input.format = data-&gt;output.format = B_FMT_8BIT_U; break;</a>
<a name="ln885">		case 16: data-&gt;input.format = data-&gt;output.format = B_FMT_16BIT; break;</a>
<a name="ln886">		case 24: data-&gt;input.format = data-&gt;output.format = B_FMT_24BIT; break;</a>
<a name="ln887">		case 32: data-&gt;input.format = data-&gt;output.format = B_FMT_32BIT; break;</a>
<a name="ln888">	}</a>
<a name="ln889">	data-&gt;input.cvsr = data-&gt;output.cvsr = current_settings.sample_rate;</a>
<a name="ln890">	return B_OK;</a>
<a name="ln891">}</a>
<a name="ln892"> </a>
<a name="ln893">static status_t</a>
<a name="ln894">emuxki_get_buffers(emuxki_dev *card, multi_buffer_list *data)</a>
<a name="ln895">{</a>
<a name="ln896">	int32 i, j, pchannels, pchannels2, rchannels, rchannels2;</a>
<a name="ln897"> </a>
<a name="ln898">	LOG((&quot;flags = %#x\n&quot;,data-&gt;flags));</a>
<a name="ln899">	LOG((&quot;request_playback_buffers = %#x\n&quot;,data-&gt;request_playback_buffers));</a>
<a name="ln900">	LOG((&quot;request_playback_channels = %#x\n&quot;,data-&gt;request_playback_channels));</a>
<a name="ln901">	LOG((&quot;request_playback_buffer_size = %#x\n&quot;,data-&gt;request_playback_buffer_size));</a>
<a name="ln902">	LOG((&quot;request_record_buffers = %#x\n&quot;,data-&gt;request_record_buffers));</a>
<a name="ln903">	LOG((&quot;request_record_channels = %#x\n&quot;,data-&gt;request_record_channels));</a>
<a name="ln904">	LOG((&quot;request_record_buffer_size = %#x\n&quot;,data-&gt;request_record_buffer_size));</a>
<a name="ln905"> </a>
<a name="ln906">	pchannels = card-&gt;pstream-&gt;nmono + card-&gt;pstream-&gt;nstereo * 2;</a>
<a name="ln907">	pchannels2 = card-&gt;pstream2-&gt;nmono + card-&gt;pstream2-&gt;nstereo * 2;</a>
<a name="ln908">	rchannels = card-&gt;rstream-&gt;nmono + card-&gt;rstream-&gt;nstereo * 2;</a>
<a name="ln909">	rchannels2 = card-&gt;rstream2-&gt;nmono + card-&gt;rstream2-&gt;nstereo * 2;</a>
<a name="ln910"> </a>
<a name="ln911">	if (data-&gt;request_playback_buffers &lt; current_settings.buffer_count ||</a>
<a name="ln912">		data-&gt;request_playback_channels &lt; (pchannels + pchannels2) ||</a>
<a name="ln913">		data-&gt;request_record_buffers &lt; current_settings.buffer_count ||</a>
<a name="ln914">		data-&gt;request_record_channels &lt; (rchannels + rchannels2)) {</a>
<a name="ln915">		LOG((&quot;not enough channels/buffers\n&quot;));</a>
<a name="ln916">	}</a>
<a name="ln917"> </a>
<a name="ln918">	data-&gt;flags = B_MULTI_BUFFER_PLAYBACK | B_MULTI_BUFFER_RECORD;</a>
<a name="ln919"> </a>
<a name="ln920">	data-&gt;return_playback_buffers = current_settings.buffer_count;	/* playback_buffers[b][] */</a>
<a name="ln921">	data-&gt;return_playback_channels = pchannels + pchannels2;		/* playback_buffers[][c] */</a>
<a name="ln922">	data-&gt;return_playback_buffer_size = current_settings.buffer_frames;		/* frames */</a>
<a name="ln923"> </a>
<a name="ln924">	for (i = 0; i &lt; current_settings.buffer_count; i++)</a>
<a name="ln925">		for (j=0; j&lt;pchannels; j++)</a>
<a name="ln926">			emuxki_stream_get_nth_buffer(card-&gt;pstream, j, i,</a>
<a name="ln927">				&amp;data-&gt;playback_buffers[i][j].base,</a>
<a name="ln928">				&amp;data-&gt;playback_buffers[i][j].stride);</a>
<a name="ln929"> </a>
<a name="ln930">	for (i = 0; i &lt; current_settings.buffer_count; i++)</a>
<a name="ln931">		for (j=0; j&lt;pchannels2; j++)</a>
<a name="ln932">			emuxki_stream_get_nth_buffer(card-&gt;pstream2, j, i,</a>
<a name="ln933">				&amp;data-&gt;playback_buffers[i][pchannels + j].base,</a>
<a name="ln934">				&amp;data-&gt;playback_buffers[i][pchannels + j].stride);</a>
<a name="ln935"> </a>
<a name="ln936">	data-&gt;return_record_buffers = current_settings.buffer_count;</a>
<a name="ln937">	data-&gt;return_record_channels = rchannels + rchannels2;</a>
<a name="ln938">	data-&gt;return_record_buffer_size = current_settings.buffer_frames;	/* frames */</a>
<a name="ln939"> </a>
<a name="ln940">	for (i = 0; i &lt; current_settings.buffer_count; i++)</a>
<a name="ln941">		for (j=0; j&lt;rchannels; j++)</a>
<a name="ln942">			emuxki_stream_get_nth_buffer(card-&gt;rstream, j, i,</a>
<a name="ln943">				&amp;data-&gt;record_buffers[i][j].base,</a>
<a name="ln944">				&amp;data-&gt;record_buffers[i][j].stride);</a>
<a name="ln945"> </a>
<a name="ln946">	for (i = 0; i &lt; current_settings.buffer_count; i++)</a>
<a name="ln947">		for (j=0; j&lt;rchannels2; j++)</a>
<a name="ln948">			emuxki_stream_get_nth_buffer(card-&gt;rstream2, j, i,</a>
<a name="ln949">				&amp;data-&gt;record_buffers[i][rchannels + j].base,</a>
<a name="ln950">				&amp;data-&gt;record_buffers[i][rchannels + j].stride);</a>
<a name="ln951"> </a>
<a name="ln952">	return B_OK;</a>
<a name="ln953">}</a>
<a name="ln954"> </a>
<a name="ln955"> </a>
<a name="ln956">static void</a>
<a name="ln957">emuxki_play_inth(void* inthparams)</a>
<a name="ln958">{</a>
<a name="ln959">	emuxki_stream *stream = (emuxki_stream *)inthparams;</a>
<a name="ln960">	//int32 count;</a>
<a name="ln961"> </a>
<a name="ln962">	acquire_spinlock(&amp;slock);</a>
<a name="ln963">	stream-&gt;real_time = system_time();</a>
<a name="ln964">	stream-&gt;frames_count += current_settings.buffer_frames;</a>
<a name="ln965">	stream-&gt;buffer_cycle = stream-&gt;first_voice-&gt;trigblk;</a>
<a name="ln966">	stream-&gt;update_needed = true;</a>
<a name="ln967">	release_spinlock(&amp;slock);</a>
<a name="ln968"> </a>
<a name="ln969">	//get_sem_count(stream-&gt;card-&gt;buffer_ready_sem, &amp;count);</a>
<a name="ln970">	//if (count &lt;= 0)</a>
<a name="ln971">		release_sem_etc(stream-&gt;card-&gt;buffer_ready_sem, 1, B_DO_NOT_RESCHEDULE);</a>
<a name="ln972">}</a>
<a name="ln973"> </a>
<a name="ln974">static void</a>
<a name="ln975">emuxki_record_inth(void* inthparams)</a>
<a name="ln976">{</a>
<a name="ln977">	emuxki_stream *stream = (emuxki_stream *)inthparams;</a>
<a name="ln978">	//int32 count;</a>
<a name="ln979"> </a>
<a name="ln980">	//TRACE((&quot;emuxki_record_inth\n&quot;));</a>
<a name="ln981"> </a>
<a name="ln982">	acquire_spinlock(&amp;slock);</a>
<a name="ln983">	stream-&gt;real_time = system_time();</a>
<a name="ln984">	stream-&gt;frames_count += current_settings.buffer_frames;</a>
<a name="ln985">	stream-&gt;buffer_cycle = (stream-&gt;first_voice-&gt;trigblk</a>
<a name="ln986">		+ stream-&gt;first_voice-&gt;blkmod -1) % stream-&gt;first_voice-&gt;blkmod;</a>
<a name="ln987">	stream-&gt;update_needed = true;</a>
<a name="ln988">	release_spinlock(&amp;slock);</a>
<a name="ln989"> </a>
<a name="ln990">	//get_sem_count(stream-&gt;card-&gt;buffer_ready_sem, &amp;count);</a>
<a name="ln991">	//if (count &lt;= 0)</a>
<a name="ln992">		release_sem_etc(stream-&gt;card-&gt;buffer_ready_sem, 1, B_DO_NOT_RESCHEDULE);</a>
<a name="ln993">}</a>
<a name="ln994"> </a>
<a name="ln995">static status_t</a>
<a name="ln996">emuxki_buffer_exchange(emuxki_dev *card, multi_buffer_info *data)</a>
<a name="ln997">{</a>
<a name="ln998">	cpu_status status;</a>
<a name="ln999">	emuxki_stream *pstream, *rstream;</a>
<a name="ln1000">	multi_buffer_info buffer_info;</a>
<a name="ln1001"> </a>
<a name="ln1002">#ifdef __HAIKU__</a>
<a name="ln1003">	if (user_memcpy(&amp;buffer_info, data, sizeof(buffer_info)) &lt; B_OK)</a>
<a name="ln1004">		return B_BAD_ADDRESS;</a>
<a name="ln1005">#else</a>
<a name="ln1006">	memcpy(&amp;buffer_info, data, sizeof(buffer_info));</a>
<a name="ln1007">#endif</a>
<a name="ln1008"> </a>
<a name="ln1009">	buffer_info.flags = B_MULTI_BUFFER_PLAYBACK | B_MULTI_BUFFER_RECORD;</a>
<a name="ln1010"> </a>
<a name="ln1011">	if (!(card-&gt;pstream-&gt;state &amp; EMU_STATE_STARTED))</a>
<a name="ln1012">		emuxki_stream_start(card-&gt;pstream, emuxki_play_inth, card-&gt;pstream);</a>
<a name="ln1013"> </a>
<a name="ln1014">	if (!(card-&gt;pstream2-&gt;state &amp; EMU_STATE_STARTED))</a>
<a name="ln1015">		emuxki_stream_start(card-&gt;pstream2, emuxki_play_inth, card-&gt;pstream2);</a>
<a name="ln1016"> </a>
<a name="ln1017">	if (!(card-&gt;rstream-&gt;state &amp; EMU_STATE_STARTED))</a>
<a name="ln1018">		emuxki_stream_start(card-&gt;rstream, emuxki_record_inth, card-&gt;rstream);</a>
<a name="ln1019"> </a>
<a name="ln1020">	if (!(card-&gt;rstream2-&gt;state &amp; EMU_STATE_STARTED))</a>
<a name="ln1021">		emuxki_stream_start(card-&gt;rstream2, emuxki_record_inth, card-&gt;rstream2);</a>
<a name="ln1022"> </a>
<a name="ln1023"> </a>
<a name="ln1024">	if (acquire_sem_etc(card-&gt;buffer_ready_sem, 1, B_RELATIVE_TIMEOUT | B_CAN_INTERRUPT, 50000)</a>
<a name="ln1025">		== B_TIMED_OUT) {</a>
<a name="ln1026">		LOG((&quot;buffer_exchange timeout ff\n&quot;));</a>
<a name="ln1027">		LOG((&quot;EMU_IPR = %#08x\n&quot;,emuxki_reg_read_32(&amp;card-&gt;config, EMU_IPR)));</a>
<a name="ln1028">		LOG((&quot;EMU_INTE = %#08x\n&quot;,emuxki_reg_read_32(&amp;card-&gt;config, EMU_INTE)));</a>
<a name="ln1029">		LOG((&quot;EMU_HCFG = %#08x\n&quot;,emuxki_reg_read_32(&amp;card-&gt;config, EMU_HCFG)));</a>
<a name="ln1030">	}</a>
<a name="ln1031"> </a>
<a name="ln1032">	status = lock();</a>
<a name="ln1033"> </a>
<a name="ln1034">	LIST_FOREACH(pstream, &amp;card-&gt;streams, next) {</a>
<a name="ln1035">		if ((pstream-&gt;use &amp; EMU_USE_PLAY) == 0 ||</a>
<a name="ln1036">			(pstream-&gt;state &amp; EMU_STATE_STARTED) == 0)</a>
<a name="ln1037">			continue;</a>
<a name="ln1038">		if (pstream-&gt;update_needed)</a>
<a name="ln1039">			break;</a>
<a name="ln1040">	}</a>
<a name="ln1041"> </a>
<a name="ln1042">	LIST_FOREACH(rstream, &amp;card-&gt;streams, next) {</a>
<a name="ln1043">		if ((rstream-&gt;use &amp; EMU_USE_RECORD) == 0 ||</a>
<a name="ln1044">			(rstream-&gt;state &amp; EMU_STATE_STARTED) == 0)</a>
<a name="ln1045">			continue;</a>
<a name="ln1046">		if (rstream-&gt;update_needed)</a>
<a name="ln1047">			break;</a>
<a name="ln1048">	}</a>
<a name="ln1049"> </a>
<a name="ln1050">	if (!pstream)</a>
<a name="ln1051">		pstream = card-&gt;pstream;</a>
<a name="ln1052">	if (!rstream)</a>
<a name="ln1053">		rstream = card-&gt;rstream;</a>
<a name="ln1054"> </a>
<a name="ln1055">	/* do playback */</a>
<a name="ln1056">	buffer_info.playback_buffer_cycle = pstream-&gt;buffer_cycle;</a>
<a name="ln1057">	buffer_info.played_real_time = pstream-&gt;real_time;</a>
<a name="ln1058">	buffer_info.played_frames_count = pstream-&gt;frames_count;</a>
<a name="ln1059">	buffer_info._reserved_0 = pstream-&gt;first_channel;</a>
<a name="ln1060">	pstream-&gt;update_needed = false;</a>
<a name="ln1061"> </a>
<a name="ln1062">	/* do record */</a>
<a name="ln1063">	buffer_info.record_buffer_cycle = rstream-&gt;buffer_cycle;</a>
<a name="ln1064">	buffer_info.recorded_frames_count = rstream-&gt;frames_count;</a>
<a name="ln1065">	buffer_info.recorded_real_time = rstream-&gt;real_time;</a>
<a name="ln1066">	buffer_info._reserved_1 = rstream-&gt;first_channel;</a>
<a name="ln1067">	rstream-&gt;update_needed = false;</a>
<a name="ln1068">	unlock(status);</a>
<a name="ln1069"> </a>
<a name="ln1070">#ifdef __HAIKU__</a>
<a name="ln1071">	if (user_memcpy(data, &amp;buffer_info, sizeof(buffer_info)) &lt; B_OK)</a>
<a name="ln1072">		return B_BAD_ADDRESS;</a>
<a name="ln1073">#else</a>
<a name="ln1074">	memcpy(data, &amp;buffer_info, sizeof(buffer_info));</a>
<a name="ln1075">#endif</a>
<a name="ln1076"> </a>
<a name="ln1077">	//TRACE((&quot;buffer_exchange ended\n&quot;));</a>
<a name="ln1078">	return B_OK;</a>
<a name="ln1079">}</a>
<a name="ln1080"> </a>
<a name="ln1081">static status_t</a>
<a name="ln1082">emuxki_buffer_force_stop(emuxki_dev *card)</a>
<a name="ln1083">{</a>
<a name="ln1084">	return B_OK;</a>
<a name="ln1085">}</a>
<a name="ln1086"> </a>
<a name="ln1087">static status_t</a>
<a name="ln1088">emuxki_multi_control(void *cookie, uint32 op, void *data, size_t length)</a>
<a name="ln1089">{</a>
<a name="ln1090">	emuxki_dev *card = (emuxki_dev *)cookie;</a>
<a name="ln1091"> </a>
<a name="ln1092">    switch (op) {</a>
<a name="ln1093">		case B_MULTI_GET_DESCRIPTION:</a>
<a name="ln1094">			LOG((&quot;B_MULTI_GET_DESCRIPTION\n&quot;));</a>
<a name="ln1095">			return emuxki_get_description(card, (multi_description *)data);</a>
<a name="ln1096">		case B_MULTI_GET_EVENT_INFO:</a>
<a name="ln1097">			LOG((&quot;B_MULTI_GET_EVENT_INFO\n&quot;));</a>
<a name="ln1098">			return B_ERROR;</a>
<a name="ln1099">		case B_MULTI_SET_EVENT_INFO:</a>
<a name="ln1100">			LOG((&quot;B_MULTI_SET_EVENT_INFO\n&quot;));</a>
<a name="ln1101">			return B_ERROR;</a>
<a name="ln1102">		case B_MULTI_GET_EVENT:</a>
<a name="ln1103">			LOG((&quot;B_MULTI_GET_EVENT\n&quot;));</a>
<a name="ln1104">			return B_ERROR;</a>
<a name="ln1105">		case B_MULTI_GET_ENABLED_CHANNELS:</a>
<a name="ln1106">			LOG((&quot;B_MULTI_GET_ENABLED_CHANNELS\n&quot;));</a>
<a name="ln1107">			return emuxki_get_enabled_channels(card, (multi_channel_enable *)data);</a>
<a name="ln1108">		case B_MULTI_SET_ENABLED_CHANNELS:</a>
<a name="ln1109">			LOG((&quot;B_MULTI_SET_ENABLED_CHANNELS\n&quot;));</a>
<a name="ln1110">			return emuxki_set_enabled_channels(card, (multi_channel_enable *)data);</a>
<a name="ln1111">		case B_MULTI_GET_GLOBAL_FORMAT:</a>
<a name="ln1112">			LOG((&quot;B_MULTI_GET_GLOBAL_FORMAT\n&quot;));</a>
<a name="ln1113">			return emuxki_get_global_format(card, (multi_format_info *)data);</a>
<a name="ln1114">		case B_MULTI_SET_GLOBAL_FORMAT:</a>
<a name="ln1115">			LOG((&quot;B_MULTI_SET_GLOBAL_FORMAT\n&quot;));</a>
<a name="ln1116">			return B_OK; /* XXX BUG! we *MUST* return B_OK, returning B_ERROR will prevent</a>
<a name="ln1117">						  * BeOS to accept the format returned in B_MULTI_GET_GLOBAL_FORMAT</a>
<a name="ln1118">						  */</a>
<a name="ln1119">		case B_MULTI_GET_CHANNEL_FORMATS:</a>
<a name="ln1120">			LOG((&quot;B_MULTI_GET_CHANNEL_FORMATS\n&quot;));</a>
<a name="ln1121">			return B_ERROR;</a>
<a name="ln1122">		case B_MULTI_SET_CHANNEL_FORMATS:	/* only implemented if possible */</a>
<a name="ln1123">			LOG((&quot;B_MULTI_SET_CHANNEL_FORMATS\n&quot;));</a>
<a name="ln1124">			return B_ERROR;</a>
<a name="ln1125">		case B_MULTI_GET_MIX:</a>
<a name="ln1126">			LOG((&quot;B_MULTI_GET_MIX\n&quot;));</a>
<a name="ln1127">			return emuxki_get_mix(card, (multi_mix_value_info *)data);</a>
<a name="ln1128">		case B_MULTI_SET_MIX:</a>
<a name="ln1129">			LOG((&quot;B_MULTI_SET_MIX\n&quot;));</a>
<a name="ln1130">			return emuxki_set_mix(card, (multi_mix_value_info *)data);</a>
<a name="ln1131">		case B_MULTI_LIST_MIX_CHANNELS:</a>
<a name="ln1132">			LOG((&quot;B_MULTI_LIST_MIX_CHANNELS\n&quot;));</a>
<a name="ln1133">			return emuxki_list_mix_channels(card, (multi_mix_channel_info *)data);</a>
<a name="ln1134">		case B_MULTI_LIST_MIX_CONTROLS:</a>
<a name="ln1135">			LOG((&quot;B_MULTI_LIST_MIX_CONTROLS\n&quot;));</a>
<a name="ln1136">			return emuxki_list_mix_controls(card, (multi_mix_control_info *)data);</a>
<a name="ln1137">		case B_MULTI_LIST_MIX_CONNECTIONS:</a>
<a name="ln1138">			LOG((&quot;B_MULTI_LIST_MIX_CONNECTIONS\n&quot;));</a>
<a name="ln1139">			return emuxki_list_mix_connections(card, (multi_mix_connection_info *)data);</a>
<a name="ln1140">		case B_MULTI_GET_BUFFERS:			/* Fill out the struct for the first time; doesn't start anything. */</a>
<a name="ln1141">			LOG((&quot;B_MULTI_GET_BUFFERS\n&quot;));</a>
<a name="ln1142">			return emuxki_get_buffers(card, data);</a>
<a name="ln1143">		case B_MULTI_SET_BUFFERS:			/* Set what buffers to use, if the driver supports soft buffers. */</a>
<a name="ln1144">			LOG((&quot;B_MULTI_SET_BUFFERS\n&quot;));</a>
<a name="ln1145">			return B_ERROR; /* we do not support soft buffers */</a>
<a name="ln1146">		case B_MULTI_SET_START_TIME:			/* When to actually start */</a>
<a name="ln1147">			LOG((&quot;B_MULTI_SET_START_TIME\n&quot;));</a>
<a name="ln1148">			return B_ERROR;</a>
<a name="ln1149">		case B_MULTI_BUFFER_EXCHANGE:		/* stop and go are derived from this being called */</a>
<a name="ln1150">			//TRACE((&quot;B_MULTI_BUFFER_EXCHANGE\n&quot;));</a>
<a name="ln1151">			return emuxki_buffer_exchange(card, (multi_buffer_info *)data);</a>
<a name="ln1152">		case B_MULTI_BUFFER_FORCE_STOP:		/* force stop of playback, nothing in data */</a>
<a name="ln1153">			LOG((&quot;B_MULTI_BUFFER_FORCE_STOP\n&quot;));</a>
<a name="ln1154">			return emuxki_buffer_force_stop(card);</a>
<a name="ln1155">	}</a>
<a name="ln1156">	LOG((&quot;ERROR: unknown multi_control %#x\n&quot;,op));</a>
<a name="ln1157">	return B_ERROR;</a>
<a name="ln1158">}</a>
<a name="ln1159"> </a>
<a name="ln1160">static status_t emuxki_open(const char *name, uint32 flags, void** cookie);</a>
<a name="ln1161">static status_t emuxki_close(void* cookie);</a>
<a name="ln1162">static status_t emuxki_free(void* cookie);</a>
<a name="ln1163">static status_t emuxki_control(void* cookie, uint32 op, void* arg, size_t len);</a>
<a name="ln1164">static status_t emuxki_read(void* cookie, off_t position, void *buf, size_t* num_bytes);</a>
<a name="ln1165">static status_t emuxki_write(void* cookie, off_t position, const void* buffer, size_t* num_bytes);</a>
<a name="ln1166"> </a>
<a name="ln1167">device_hooks multi_hooks = {</a>
<a name="ln1168">	emuxki_open, 			/* -&gt; open entry point */</a>
<a name="ln1169">	emuxki_close, 			/* -&gt; close entry point */</a>
<a name="ln1170">	emuxki_free,			/* -&gt; free cookie */</a>
<a name="ln1171">	emuxki_control, 		/* -&gt; control entry point */</a>
<a name="ln1172">	emuxki_read,			/* -&gt; read entry point */</a>
<a name="ln1173">	emuxki_write,			/* -&gt; write entry point */</a>
<a name="ln1174">	NULL,					/* start select */</a>
<a name="ln1175">	NULL,					/* stop select */</a>
<a name="ln1176">	NULL,					/* scatter-gather read from the device */</a>
<a name="ln1177">	NULL					/* scatter-gather write to the device */</a>
<a name="ln1178">};</a>
<a name="ln1179"> </a>
<a name="ln1180">static status_t</a>
<a name="ln1181">emuxki_open(const char *name, uint32 flags, void** cookie)</a>
<a name="ln1182">{</a>
<a name="ln1183">	emuxki_dev *card = NULL;</a>
<a name="ln1184">	emuxki_recparams recparams;</a>
<a name="ln1185">	int ix;</a>
<a name="ln1186"> </a>
<a name="ln1187">	LOG((&quot;open()\n&quot;));</a>
<a name="ln1188"> </a>
<a name="ln1189">	for (ix=0; ix&lt;num_cards; ix++) {</a>
<a name="ln1190">		if (!strcmp(cards[ix].name, name)) {</a>
<a name="ln1191">			card = &amp;cards[ix];</a>
<a name="ln1192">		}</a>
<a name="ln1193">	}</a>
<a name="ln1194"> </a>
<a name="ln1195">	if (card == NULL) {</a>
<a name="ln1196">		LOG((&quot;open() card not found %s\n&quot;, name));</a>
<a name="ln1197">		for (ix=0; ix&lt;num_cards; ix++) {</a>
<a name="ln1198">			LOG((&quot;open() card available %s\n&quot;, cards[ix].name));</a>
<a name="ln1199">		}</a>
<a name="ln1200">		return B_ERROR;</a>
<a name="ln1201">	}</a>
<a name="ln1202"> </a>
<a name="ln1203">	LOG((&quot;open() got card\n&quot;));</a>
<a name="ln1204"> </a>
<a name="ln1205">	if (card-&gt;pstream !=NULL)</a>
<a name="ln1206">		return B_ERROR;</a>
<a name="ln1207">	if (card-&gt;pstream2 !=NULL)</a>
<a name="ln1208">		return B_ERROR;</a>
<a name="ln1209">	if (card-&gt;rstream !=NULL)</a>
<a name="ln1210">		return B_ERROR;</a>
<a name="ln1211">	if (card-&gt;rstream2 !=NULL)</a>
<a name="ln1212">		return B_ERROR;</a>
<a name="ln1213"> </a>
<a name="ln1214">	*cookie = card;</a>
<a name="ln1215">	card-&gt;multi.card = card;</a>
<a name="ln1216"> </a>
<a name="ln1217">	LOG((&quot;voice_new\n&quot;));</a>
<a name="ln1218"> </a>
<a name="ln1219">	card-&gt;rstream2 = emuxki_stream_new(card, EMU_USE_RECORD, current_settings.buffer_frames, current_settings.buffer_count);</a>
<a name="ln1220">	card-&gt;rstream = emuxki_stream_new(card, EMU_USE_RECORD, current_settings.buffer_frames, current_settings.buffer_count);</a>
<a name="ln1221">	card-&gt;pstream2 = emuxki_stream_new(card, EMU_USE_PLAY, current_settings.buffer_frames, current_settings.buffer_count);</a>
<a name="ln1222">	card-&gt;pstream = emuxki_stream_new(card, EMU_USE_PLAY, current_settings.buffer_frames, current_settings.buffer_count);</a>
<a name="ln1223"> </a>
<a name="ln1224">	card-&gt;buffer_ready_sem = create_sem(0,&quot;pbuffer ready&quot;);</a>
<a name="ln1225"> </a>
<a name="ln1226">	LOG((&quot;voice_setaudio\n&quot;));</a>
<a name="ln1227"> </a>
<a name="ln1228">	emuxki_stream_set_audioparms(card-&gt;pstream, true, current_settings.channels,</a>
<a name="ln1229">		current_settings.bitsPerSample == 16, current_settings.sample_rate);</a>
<a name="ln1230">	emuxki_stream_set_audioparms(card-&gt;pstream2, false, 4,</a>
<a name="ln1231">		current_settings.bitsPerSample == 16, current_settings.sample_rate);</a>
<a name="ln1232">	emuxki_stream_set_audioparms(card-&gt;rstream, true, current_settings.channels,</a>
<a name="ln1233">		current_settings.bitsPerSample == 16, current_settings.sample_rate);</a>
<a name="ln1234">	emuxki_stream_set_audioparms(card-&gt;rstream2, true, current_settings.channels,</a>
<a name="ln1235">		current_settings.bitsPerSample == 16, current_settings.sample_rate);</a>
<a name="ln1236">	recparams.efx_voices[0] = 3; // channels 1,2</a>
<a name="ln1237">	recparams.efx_voices[1] = 0;</a>
<a name="ln1238">	emuxki_stream_set_recparms(card-&gt;rstream, EMU_RECSRC_ADC, NULL);</a>
<a name="ln1239">	emuxki_stream_set_recparms(card-&gt;rstream2, EMU_RECSRC_FX, &amp;recparams);</a>
<a name="ln1240"> </a>
<a name="ln1241">	card-&gt;pstream-&gt;first_channel = 0;</a>
<a name="ln1242">	card-&gt;pstream2-&gt;first_channel = current_settings.channels;</a>
<a name="ln1243">	card-&gt;rstream-&gt;first_channel = current_settings.channels + 4;</a>
<a name="ln1244">	card-&gt;rstream2-&gt;first_channel = 2 * current_settings.channels + 4;</a>
<a name="ln1245"> </a>
<a name="ln1246">	emuxki_stream_commit_parms(card-&gt;pstream);</a>
<a name="ln1247">	emuxki_stream_commit_parms(card-&gt;pstream2);</a>
<a name="ln1248">	emuxki_stream_commit_parms(card-&gt;rstream);</a>
<a name="ln1249">	emuxki_stream_commit_parms(card-&gt;rstream2);</a>
<a name="ln1250"> </a>
<a name="ln1251">	emuxki_create_channels_list(&amp;card-&gt;multi);</a>
<a name="ln1252"> </a>
<a name="ln1253">	return B_OK;</a>
<a name="ln1254">}</a>
<a name="ln1255"> </a>
<a name="ln1256">static status_t</a>
<a name="ln1257">emuxki_close(void* cookie)</a>
<a name="ln1258">{</a>
<a name="ln1259">	//emuxki_dev *card = cookie;</a>
<a name="ln1260">	LOG((&quot;close()\n&quot;));</a>
<a name="ln1261"> </a>
<a name="ln1262">	return B_OK;</a>
<a name="ln1263">}</a>
<a name="ln1264"> </a>
<a name="ln1265">static status_t</a>
<a name="ln1266">emuxki_free(void* cookie)</a>
<a name="ln1267">{</a>
<a name="ln1268">	emuxki_dev *card = cookie;</a>
<a name="ln1269">	emuxki_stream *stream;</a>
<a name="ln1270">	LOG((&quot;free()\n&quot;));</a>
<a name="ln1271"> </a>
<a name="ln1272">	if (card-&gt;buffer_ready_sem &gt; B_OK)</a>
<a name="ln1273">			delete_sem(card-&gt;buffer_ready_sem);</a>
<a name="ln1274"> </a>
<a name="ln1275">	LIST_FOREACH(stream, &amp;card-&gt;streams, next) {</a>
<a name="ln1276">		emuxki_stream_halt(stream);</a>
<a name="ln1277">	}</a>
<a name="ln1278"> </a>
<a name="ln1279">	while (!LIST_EMPTY(&amp;card-&gt;streams)) {</a>
<a name="ln1280">		emuxki_stream_delete(LIST_FIRST(&amp;card-&gt;streams));</a>
<a name="ln1281">	}</a>
<a name="ln1282"> </a>
<a name="ln1283">	card-&gt;pstream = NULL;</a>
<a name="ln1284">	card-&gt;pstream2 = NULL;</a>
<a name="ln1285">	card-&gt;rstream = NULL;</a>
<a name="ln1286">	card-&gt;rstream2 = NULL;</a>
<a name="ln1287"> </a>
<a name="ln1288">	return B_OK;</a>
<a name="ln1289">}</a>
<a name="ln1290"> </a>
<a name="ln1291">static status_t</a>
<a name="ln1292">emuxki_control(void* cookie, uint32 op, void* arg, size_t len)</a>
<a name="ln1293">{</a>
<a name="ln1294">	return emuxki_multi_control(cookie, op, arg, len);</a>
<a name="ln1295">}</a>
<a name="ln1296"> </a>
<a name="ln1297">static status_t</a>
<a name="ln1298">emuxki_read(void* cookie, off_t position, void *buf, size_t* num_bytes)</a>
<a name="ln1299">{</a>
<a name="ln1300">	*num_bytes = 0;				/* tell caller nothing was read */</a>
<a name="ln1301">	return B_IO_ERROR;</a>
<a name="ln1302">}</a>
<a name="ln1303"> </a>
<a name="ln1304">static status_t</a>
<a name="ln1305">emuxki_write(void* cookie, off_t position, const void* buffer, size_t* num_bytes)</a>
<a name="ln1306">{</a>
<a name="ln1307">	*num_bytes = 0;				/* tell caller nothing was written */</a>
<a name="ln1308">	return B_IO_ERROR;</a>
<a name="ln1309">}</a>
<a name="ln1310"> </a>

</code></pre>
<div class="balloon" rel="518"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'debug_printf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="531"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'debug_printf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="816"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1031/" target="_blank">V1031</a> The 'memcpy' function is not declared. Passing data to or from this function can be affected.</p></div>
<div class="balloon" rel="571"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'debug_printf' function. The memsize type argument is expected.</p></div>
<div class="balloon" rel="581"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v576/" target="_blank">V576</a> Incorrect format. Consider checking the second actual argument of the 'debug_printf' function. The memsize type argument is expected.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
